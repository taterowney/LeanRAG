{"name":"SemidirectProduct.ext_iff","module":"Mathlib.GroupTheory.SemidirectProduct","initialProofState":"N : Type u_1\nG : Type u_2\ninst✝¹ : Group N\ninst✝ : Group G\nφ : MonoidHom G (MulAut N)\nx y : SemidirectProduct N G φ\n⊢ Iff (Eq x y) (And (Eq x.left y.left) (Eq x.right y.right))","decl":"set_option genSizeOfSpec false in\nset_option genInjectivity false in\n/-- The semidirect product of groups `N` and `G`, given a map `φ` from `G` to the automorphism\n  group of `N`. It the product of sets with the group operation\n  `⟨n₁, g₁⟩ * ⟨n₂, g₂⟩ = ⟨n₁ * φ g₁ n₂, g₁ * g₂⟩` -/\n@[ext]\nstructure SemidirectProduct (φ : G →* MulAut N) where\n  /-- The element of N -/\n  left : N\n  /-- The element of G -/\n  right : G\n  deriving DecidableEq\n\n-- Porting note: unknown attribute\n-- attribute [pp_using_anonymous_constructor] SemidirectProduct\n\n"}
{"name":"SemidirectProduct.ext","module":"Mathlib.GroupTheory.SemidirectProduct","initialProofState":"N : Type u_1\nG : Type u_2\ninst✝¹ : Group N\ninst✝ : Group G\nφ : MonoidHom G (MulAut N)\nx y : SemidirectProduct N G φ\nleft : Eq x.left y.left\nright : Eq x.right y.right\n⊢ Eq x y","decl":"set_option genSizeOfSpec false in\nset_option genInjectivity false in\n/-- The semidirect product of groups `N` and `G`, given a map `φ` from `G` to the automorphism\n  group of `N`. It the product of sets with the group operation\n  `⟨n₁, g₁⟩ * ⟨n₂, g₂⟩ = ⟨n₁ * φ g₁ n₂, g₁ * g₂⟩` -/\n@[ext]\nstructure SemidirectProduct (φ : G →* MulAut N) where\n  /-- The element of N -/\n  left : N\n  /-- The element of G -/\n  right : G\n  deriving DecidableEq\n\n-- Porting note: unknown attribute\n-- attribute [pp_using_anonymous_constructor] SemidirectProduct\n\n"}
{"name":"SemidirectProduct.mul_def","module":"Mathlib.GroupTheory.SemidirectProduct","initialProofState":"N : Type u_1\nG : Type u_2\ninst✝¹ : Group N\ninst✝ : Group G\nφ : MonoidHom G (MulAut N)\na b : SemidirectProduct N G φ\n⊢ Eq (HMul.hMul a b) { left := HMul.hMul a.left ((φ a.right) b.left), right := HMul.hMul a.right b.right }","decl":"lemma mul_def (a b : SemidirectProduct N G φ) : a * b = ⟨a.1 * φ a.2 b.1, a.2 * b.2⟩ := rfl\n\n"}
{"name":"SemidirectProduct.mul_left","module":"Mathlib.GroupTheory.SemidirectProduct","initialProofState":"N : Type u_1\nG : Type u_2\ninst✝¹ : Group N\ninst✝ : Group G\nφ : MonoidHom G (MulAut N)\na b : SemidirectProduct N G φ\n⊢ Eq (HMul.hMul a b).left (HMul.hMul a.left ((φ a.right) b.left))","decl":"@[simp]\ntheorem mul_left (a b : N ⋊[φ] G) : (a * b).left = a.left * φ a.right b.left := rfl\n\n"}
{"name":"SemidirectProduct.mul_right","module":"Mathlib.GroupTheory.SemidirectProduct","initialProofState":"N : Type u_1\nG : Type u_2\ninst✝¹ : Group N\ninst✝ : Group G\nφ : MonoidHom G (MulAut N)\na b : SemidirectProduct N G φ\n⊢ Eq (HMul.hMul a b).right (HMul.hMul a.right b.right)","decl":"@[simp]\ntheorem mul_right (a b : N ⋊[φ] G) : (a * b).right = a.right * b.right := rfl\n\n"}
{"name":"SemidirectProduct.one_left","module":"Mathlib.GroupTheory.SemidirectProduct","initialProofState":"N : Type u_1\nG : Type u_2\ninst✝¹ : Group N\ninst✝ : Group G\nφ : MonoidHom G (MulAut N)\n⊢ Eq (SemidirectProduct.left 1) 1","decl":"@[simp]\ntheorem one_left : (1 : N ⋊[φ] G).left = 1 := rfl\n\n"}
{"name":"SemidirectProduct.one_right","module":"Mathlib.GroupTheory.SemidirectProduct","initialProofState":"N : Type u_1\nG : Type u_2\ninst✝¹ : Group N\ninst✝ : Group G\nφ : MonoidHom G (MulAut N)\n⊢ Eq (SemidirectProduct.right 1) 1","decl":"@[simp]\ntheorem one_right : (1 : N ⋊[φ] G).right = 1 := rfl\n\n"}
{"name":"SemidirectProduct.inv_left","module":"Mathlib.GroupTheory.SemidirectProduct","initialProofState":"N : Type u_1\nG : Type u_2\ninst✝¹ : Group N\ninst✝ : Group G\nφ : MonoidHom G (MulAut N)\na : SemidirectProduct N G φ\n⊢ Eq (Inv.inv a).left ((φ (Inv.inv a.right)) (Inv.inv a.left))","decl":"@[simp]\ntheorem inv_left (a : N ⋊[φ] G) : a⁻¹.left = φ a.right⁻¹ a.left⁻¹ := rfl\n\n"}
{"name":"SemidirectProduct.inv_right","module":"Mathlib.GroupTheory.SemidirectProduct","initialProofState":"N : Type u_1\nG : Type u_2\ninst✝¹ : Group N\ninst✝ : Group G\nφ : MonoidHom G (MulAut N)\na : SemidirectProduct N G φ\n⊢ Eq (Inv.inv a).right (Inv.inv a.right)","decl":"@[simp]\ntheorem inv_right (a : N ⋊[φ] G) : a⁻¹.right = a.right⁻¹ := rfl\n\n"}
{"name":"SemidirectProduct.left_inl","module":"Mathlib.GroupTheory.SemidirectProduct","initialProofState":"N : Type u_1\nG : Type u_2\ninst✝¹ : Group N\ninst✝ : Group G\nφ : MonoidHom G (MulAut N)\nn : N\n⊢ Eq (SemidirectProduct.inl n).left n","decl":"@[simp]\ntheorem left_inl (n : N) : (inl n : N ⋊[φ] G).left = n := rfl\n\n"}
{"name":"SemidirectProduct.right_inl","module":"Mathlib.GroupTheory.SemidirectProduct","initialProofState":"N : Type u_1\nG : Type u_2\ninst✝¹ : Group N\ninst✝ : Group G\nφ : MonoidHom G (MulAut N)\nn : N\n⊢ Eq (SemidirectProduct.inl n).right 1","decl":"@[simp]\ntheorem right_inl (n : N) : (inl n : N ⋊[φ] G).right = 1 := rfl\n\n"}
{"name":"SemidirectProduct.inl_injective","module":"Mathlib.GroupTheory.SemidirectProduct","initialProofState":"N : Type u_1\nG : Type u_2\ninst✝¹ : Group N\ninst✝ : Group G\nφ : MonoidHom G (MulAut N)\n⊢ Function.Injective ⇑SemidirectProduct.inl","decl":"theorem inl_injective : Function.Injective (inl : N → N ⋊[φ] G) :=\n  Function.injective_iff_hasLeftInverse.2 ⟨left, left_inl⟩\n\n"}
{"name":"SemidirectProduct.inl_inj","module":"Mathlib.GroupTheory.SemidirectProduct","initialProofState":"N : Type u_1\nG : Type u_2\ninst✝¹ : Group N\ninst✝ : Group G\nφ : MonoidHom G (MulAut N)\nn₁ n₂ : N\n⊢ Iff (Eq (SemidirectProduct.inl n₁) (SemidirectProduct.inl n₂)) (Eq n₁ n₂)","decl":"@[simp]\ntheorem inl_inj {n₁ n₂ : N} : (inl n₁ : N ⋊[φ] G) = inl n₂ ↔ n₁ = n₂ :=\n  inl_injective.eq_iff\n\n"}
{"name":"SemidirectProduct.left_inr","module":"Mathlib.GroupTheory.SemidirectProduct","initialProofState":"N : Type u_1\nG : Type u_2\ninst✝¹ : Group N\ninst✝ : Group G\nφ : MonoidHom G (MulAut N)\ng : G\n⊢ Eq (SemidirectProduct.inr g).left 1","decl":"@[simp]\ntheorem left_inr (g : G) : (inr g : N ⋊[φ] G).left = 1 := rfl\n\n"}
{"name":"SemidirectProduct.right_inr","module":"Mathlib.GroupTheory.SemidirectProduct","initialProofState":"N : Type u_1\nG : Type u_2\ninst✝¹ : Group N\ninst✝ : Group G\nφ : MonoidHom G (MulAut N)\ng : G\n⊢ Eq (SemidirectProduct.inr g).right g","decl":"@[simp]\ntheorem right_inr (g : G) : (inr g : N ⋊[φ] G).right = g := rfl\n\n"}
{"name":"SemidirectProduct.inr_injective","module":"Mathlib.GroupTheory.SemidirectProduct","initialProofState":"N : Type u_1\nG : Type u_2\ninst✝¹ : Group N\ninst✝ : Group G\nφ : MonoidHom G (MulAut N)\n⊢ Function.Injective ⇑SemidirectProduct.inr","decl":"theorem inr_injective : Function.Injective (inr : G → N ⋊[φ] G) :=\n  Function.injective_iff_hasLeftInverse.2 ⟨right, right_inr⟩\n\n"}
{"name":"SemidirectProduct.inr_inj","module":"Mathlib.GroupTheory.SemidirectProduct","initialProofState":"N : Type u_1\nG : Type u_2\ninst✝¹ : Group N\ninst✝ : Group G\nφ : MonoidHom G (MulAut N)\ng₁ g₂ : G\n⊢ Iff (Eq (SemidirectProduct.inr g₁) (SemidirectProduct.inr g₂)) (Eq g₁ g₂)","decl":"@[simp]\ntheorem inr_inj {g₁ g₂ : G} : (inr g₁ : N ⋊[φ] G) = inr g₂ ↔ g₁ = g₂ :=\n  inr_injective.eq_iff\n\n"}
{"name":"SemidirectProduct.inl_aut","module":"Mathlib.GroupTheory.SemidirectProduct","initialProofState":"N : Type u_1\nG : Type u_2\ninst✝¹ : Group N\ninst✝ : Group G\nφ : MonoidHom G (MulAut N)\ng : G\nn : N\n⊢ Eq (SemidirectProduct.inl ((φ g) n)) (HMul.hMul (HMul.hMul (SemidirectProduct.inr g) (SemidirectProduct.inl n)) (SemidirectProduct.inr (Inv.inv g)))","decl":"theorem inl_aut (g : G) (n : N) : (inl (φ g n) : N ⋊[φ] G) = inr g * inl n * inr g⁻¹ := by\n  ext <;> simp\n\n"}
{"name":"SemidirectProduct.inl_aut_inv","module":"Mathlib.GroupTheory.SemidirectProduct","initialProofState":"N : Type u_1\nG : Type u_2\ninst✝¹ : Group N\ninst✝ : Group G\nφ : MonoidHom G (MulAut N)\ng : G\nn : N\n⊢ Eq (SemidirectProduct.inl ((Inv.inv (φ g)) n)) (HMul.hMul (HMul.hMul (SemidirectProduct.inr (Inv.inv g)) (SemidirectProduct.inl n)) (SemidirectProduct.inr g))","decl":"theorem inl_aut_inv (g : G) (n : N) : (inl ((φ g)⁻¹ n) : N ⋊[φ] G) = inr g⁻¹ * inl n * inr g := by\n  rw [← MonoidHom.map_inv, inl_aut, inv_inv]\n\n"}
{"name":"SemidirectProduct.mk_eq_inl_mul_inr","module":"Mathlib.GroupTheory.SemidirectProduct","initialProofState":"N : Type u_1\nG : Type u_2\ninst✝¹ : Group N\ninst✝ : Group G\nφ : MonoidHom G (MulAut N)\ng : G\nn : N\n⊢ Eq { left := n, right := g } (HMul.hMul (SemidirectProduct.inl n) (SemidirectProduct.inr g))","decl":"@[simp]\ntheorem mk_eq_inl_mul_inr (g : G) (n : N) : (⟨n, g⟩ : N ⋊[φ] G) = inl n * inr g := by ext <;> simp\n\n"}
{"name":"SemidirectProduct.inl_left_mul_inr_right","module":"Mathlib.GroupTheory.SemidirectProduct","initialProofState":"N : Type u_1\nG : Type u_2\ninst✝¹ : Group N\ninst✝ : Group G\nφ : MonoidHom G (MulAut N)\nx : SemidirectProduct N G φ\n⊢ Eq (HMul.hMul (SemidirectProduct.inl x.left) (SemidirectProduct.inr x.right)) x","decl":"@[simp]\ntheorem inl_left_mul_inr_right (x : N ⋊[φ] G) : inl x.left * inr x.right = x := by ext <;> simp\n\n"}
{"name":"SemidirectProduct.rightHom_eq_right","module":"Mathlib.GroupTheory.SemidirectProduct","initialProofState":"N : Type u_1\nG : Type u_2\ninst✝¹ : Group N\ninst✝ : Group G\nφ : MonoidHom G (MulAut N)\n⊢ Eq (⇑SemidirectProduct.rightHom) SemidirectProduct.right","decl":"@[simp]\ntheorem rightHom_eq_right : (rightHom : N ⋊[φ] G → G) = right := rfl\n\n"}
{"name":"SemidirectProduct.rightHom_comp_inl","module":"Mathlib.GroupTheory.SemidirectProduct","initialProofState":"N : Type u_1\nG : Type u_2\ninst✝¹ : Group N\ninst✝ : Group G\nφ : MonoidHom G (MulAut N)\n⊢ Eq (SemidirectProduct.rightHom.comp SemidirectProduct.inl) 1","decl":"@[simp]\ntheorem rightHom_comp_inl : (rightHom : N ⋊[φ] G →* G).comp inl = 1 := by ext; simp [rightHom]\n\n"}
{"name":"SemidirectProduct.rightHom_comp_inr","module":"Mathlib.GroupTheory.SemidirectProduct","initialProofState":"N : Type u_1\nG : Type u_2\ninst✝¹ : Group N\ninst✝ : Group G\nφ : MonoidHom G (MulAut N)\n⊢ Eq (SemidirectProduct.rightHom.comp SemidirectProduct.inr) (MonoidHom.id G)","decl":"@[simp]\ntheorem rightHom_comp_inr : (rightHom : N ⋊[φ] G →* G).comp inr = MonoidHom.id _ := by\n  ext; simp [rightHom]\n\n"}
{"name":"SemidirectProduct.rightHom_inl","module":"Mathlib.GroupTheory.SemidirectProduct","initialProofState":"N : Type u_1\nG : Type u_2\ninst✝¹ : Group N\ninst✝ : Group G\nφ : MonoidHom G (MulAut N)\nn : N\n⊢ Eq (SemidirectProduct.rightHom (SemidirectProduct.inl n)) 1","decl":"@[simp]\ntheorem rightHom_inl (n : N) : rightHom (inl n : N ⋊[φ] G) = 1 := by simp [rightHom]\n\n"}
{"name":"SemidirectProduct.rightHom_inr","module":"Mathlib.GroupTheory.SemidirectProduct","initialProofState":"N : Type u_1\nG : Type u_2\ninst✝¹ : Group N\ninst✝ : Group G\nφ : MonoidHom G (MulAut N)\ng : G\n⊢ Eq (SemidirectProduct.rightHom (SemidirectProduct.inr g)) g","decl":"@[simp]\ntheorem rightHom_inr (g : G) : rightHom (inr g : N ⋊[φ] G) = g := by simp [rightHom]\n\n"}
{"name":"SemidirectProduct.rightHom_surjective","module":"Mathlib.GroupTheory.SemidirectProduct","initialProofState":"N : Type u_1\nG : Type u_2\ninst✝¹ : Group N\ninst✝ : Group G\nφ : MonoidHom G (MulAut N)\n⊢ Function.Surjective ⇑SemidirectProduct.rightHom","decl":"theorem rightHom_surjective : Function.Surjective (rightHom : N ⋊[φ] G → G) :=\n  Function.surjective_iff_hasRightInverse.2 ⟨inr, rightHom_inr⟩\n\n"}
{"name":"SemidirectProduct.range_inl_eq_ker_rightHom","module":"Mathlib.GroupTheory.SemidirectProduct","initialProofState":"N : Type u_1\nG : Type u_2\ninst✝¹ : Group N\ninst✝ : Group G\nφ : MonoidHom G (MulAut N)\n⊢ Eq SemidirectProduct.inl.range SemidirectProduct.rightHom.ker","decl":"theorem range_inl_eq_ker_rightHom : (inl : N →* N ⋊[φ] G).range = rightHom.ker :=\n  le_antisymm (fun _ ↦ by simp +contextual [MonoidHom.mem_ker, eq_comm])\n    fun x hx ↦ ⟨x.left, by ext <;> simp_all [MonoidHom.mem_ker]⟩\n\n"}
{"name":"SemidirectProduct.equivProd_symm_apply_right","module":"Mathlib.GroupTheory.SemidirectProduct","initialProofState":"N : Type u_1\nG : Type u_2\ninst✝¹ : Group N\ninst✝ : Group G\nφ : MonoidHom G (MulAut N)\nx : Prod N G\n⊢ Eq (SemidirectProduct.equivProd.symm x).right x.2","decl":"/-- The bijection between the semidirect product and the product. -/\n@[simps]\ndef equivProd : N ⋊[φ] G ≃ N × G where\n  toFun x := ⟨x.1, x.2⟩\n  invFun x := ⟨x.1, x.2⟩\n  left_inv _ := rfl\n  right_inv _ := rfl\n\n"}
{"name":"SemidirectProduct.equivProd_apply","module":"Mathlib.GroupTheory.SemidirectProduct","initialProofState":"N : Type u_1\nG : Type u_2\ninst✝¹ : Group N\ninst✝ : Group G\nφ : MonoidHom G (MulAut N)\nx : SemidirectProduct N G φ\n⊢ Eq (SemidirectProduct.equivProd x) { fst := x.left, snd := x.right }","decl":"/-- The bijection between the semidirect product and the product. -/\n@[simps]\ndef equivProd : N ⋊[φ] G ≃ N × G where\n  toFun x := ⟨x.1, x.2⟩\n  invFun x := ⟨x.1, x.2⟩\n  left_inv _ := rfl\n  right_inv _ := rfl\n\n"}
{"name":"SemidirectProduct.equivProd_symm_apply_left","module":"Mathlib.GroupTheory.SemidirectProduct","initialProofState":"N : Type u_1\nG : Type u_2\ninst✝¹ : Group N\ninst✝ : Group G\nφ : MonoidHom G (MulAut N)\nx : Prod N G\n⊢ Eq (SemidirectProduct.equivProd.symm x).left x.1","decl":"/-- The bijection between the semidirect product and the product. -/\n@[simps]\ndef equivProd : N ⋊[φ] G ≃ N × G where\n  toFun x := ⟨x.1, x.2⟩\n  invFun x := ⟨x.1, x.2⟩\n  left_inv _ := rfl\n  right_inv _ := rfl\n\n"}
{"name":"SemidirectProduct.mulEquivProd_symm_apply_right","module":"Mathlib.GroupTheory.SemidirectProduct","initialProofState":"N : Type u_1\nG : Type u_2\ninst✝¹ : Group N\ninst✝ : Group G\nx : Prod N G\n⊢ Eq (SemidirectProduct.mulEquivProd.symm x).right x.2","decl":"/-- The group isomorphism between a semidirect product with respect to the trivial map\n  and the product. -/\n@[simps (config := {rhsMd := .default})]\ndef mulEquivProd : N ⋊[1] G ≃* N × G :=\n  { equivProd with map_mul' _ _ := rfl }\n\n"}
{"name":"SemidirectProduct.mulEquivProd_symm_apply_left","module":"Mathlib.GroupTheory.SemidirectProduct","initialProofState":"N : Type u_1\nG : Type u_2\ninst✝¹ : Group N\ninst✝ : Group G\nx : Prod N G\n⊢ Eq (SemidirectProduct.mulEquivProd.symm x).left x.1","decl":"/-- The group isomorphism between a semidirect product with respect to the trivial map\n  and the product. -/\n@[simps (config := {rhsMd := .default})]\ndef mulEquivProd : N ⋊[1] G ≃* N × G :=\n  { equivProd with map_mul' _ _ := rfl }\n\n"}
{"name":"SemidirectProduct.mulEquivProd_apply","module":"Mathlib.GroupTheory.SemidirectProduct","initialProofState":"N : Type u_1\nG : Type u_2\ninst✝¹ : Group N\ninst✝ : Group G\nx : SemidirectProduct N G 1\n⊢ Eq (SemidirectProduct.mulEquivProd x) { fst := x.left, snd := x.right }","decl":"/-- The group isomorphism between a semidirect product with respect to the trivial map\n  and the product. -/\n@[simps (config := {rhsMd := .default})]\ndef mulEquivProd : N ⋊[1] G ≃* N × G :=\n  { equivProd with map_mul' _ _ := rfl }\n\n"}
{"name":"SemidirectProduct.lift_inl","module":"Mathlib.GroupTheory.SemidirectProduct","initialProofState":"N : Type u_1\nH : Type u_3\ninst✝¹ : Group N\ninst✝ : Group H\nfn : MonoidHom N H\nn : N\n⊢ Eq (sorryAx (Unit → H) Bool.true (Function.const Lean.Name Unit.unit ((((((((((Lean.Name.anonymous.num 208).num 27).num 208).num 47).num 27).num 47).str \"_sorry\").str \"_@\").str \"_hyg\").num 2722))) (fn n)","decl":"@[simp]\ntheorem lift_inl (n : N) : lift fn fg h (inl n) = fn n := by simp [lift]\n\n"}
{"name":"SemidirectProduct.lift_comp_inl","module":"Mathlib.GroupTheory.SemidirectProduct","initialProofState":"N : Type u_1\nH : Type u_3\ninst✝¹ : Group N\ninst✝ : Group H\nfn : MonoidHom N H\n⊢ Eq (sorryAx (Unit → MonoidHom N H) Bool.true (Function.const Lean.Name Unit.unit ((((((((((Lean.Name.anonymous.num 211).num 24).num 211).num 47).num 24).num 47).str \"_sorry\").str \"_@\").str \"_hyg\").num 2794))) fn","decl":"@[simp]\ntheorem lift_comp_inl : (lift fn fg h).comp inl = fn := by ext; simp\n\n"}
{"name":"SemidirectProduct.lift_inr","module":"Mathlib.GroupTheory.SemidirectProduct","initialProofState":"G : Type u_2\nH : Type u_3\ninst✝¹ : Group G\ninst✝ : Group H\nfg : MonoidHom G H\ng : G\n⊢ Eq (sorryAx (Unit → H) Bool.true (Function.const Lean.Name Unit.unit ((((((((((Lean.Name.anonymous.num 214).num 27).num 214).num 47).num 27).num 47).str \"_sorry\").str \"_@\").str \"_hyg\").num 2863))) (fg g)","decl":"@[simp]\ntheorem lift_inr (g : G) : lift fn fg h (inr g) = fg g := by simp [lift]\n\n"}
{"name":"SemidirectProduct.lift_comp_inr","module":"Mathlib.GroupTheory.SemidirectProduct","initialProofState":"G : Type u_2\nH : Type u_3\ninst✝¹ : Group G\ninst✝ : Group H\nfg : MonoidHom G H\n⊢ Eq (sorryAx (Unit → MonoidHom G H) Bool.true (Function.const Lean.Name Unit.unit ((((((((((Lean.Name.anonymous.num 217).num 24).num 217).num 47).num 24).num 47).str \"_sorry\").str \"_@\").str \"_hyg\").num 2935))) fg","decl":"@[simp]\ntheorem lift_comp_inr : (lift fn fg h).comp inr = fg := by ext; simp\n\n"}
{"name":"SemidirectProduct.hom_ext","module":"Mathlib.GroupTheory.SemidirectProduct","initialProofState":"N : Type u_1\nG : Type u_2\nH : Type u_3\ninst✝² : Group N\ninst✝¹ : Group G\ninst✝ : Group H\nφ : MonoidHom G (MulAut N)\nf g : MonoidHom (SemidirectProduct N G φ) H\nhl : Eq (f.comp SemidirectProduct.inl) (g.comp SemidirectProduct.inl)\nhr : Eq (f.comp SemidirectProduct.inr) (g.comp SemidirectProduct.inr)\n⊢ Eq f g","decl":"/-- Two maps out of the semidirect product are equal if they're equal after composition\n  with both `inl` and `inr` -/\ntheorem hom_ext {f g : N ⋊[φ] G →* H} (hl : f.comp inl = g.comp inl)\n    (hr : f.comp inr = g.comp inr) : f = g := by\n  rw [lift_unique f, lift_unique g]\n  simp only [*]\n\n"}
{"name":"SemidirectProduct.map_left","module":"Mathlib.GroupTheory.SemidirectProduct","initialProofState":"N₁ : Type u_4\nG₁ : Type u_5\nN₂ : Type u_6\ninst✝² : Group N₁\ninst✝¹ : Group G₁\ninst✝ : Group N₂\nφ₁ : MonoidHom G₁ (MulAut N₁)\nfn : MonoidHom N₁ N₂\ng : SemidirectProduct N₁ G₁ φ₁\n⊢ Eq (sorryAx (Unit → N₂) Bool.true (Function.const Lean.Name Unit.unit ((((((((((Lean.Name.anonymous.num 263).num 37).num 263).num 57).num 37).num 57).str \"_sorry\").str \"_@\").str \"_hyg\").num 3731))) (fn g.left)","decl":"@[simp]\ntheorem map_left (g : N₁ ⋊[φ₁] G₁) : (map fn fg h g).left = fn g.left := rfl\n\n"}
{"name":"SemidirectProduct.map_right","module":"Mathlib.GroupTheory.SemidirectProduct","initialProofState":"N₁ : Type u_4\nG₁ : Type u_5\nG₂ : Type u_7\ninst✝² : Group N₁\ninst✝¹ : Group G₁\ninst✝ : Group G₂\nφ₁ : MonoidHom G₁ (MulAut N₁)\nfg : MonoidHom G₁ G₂\ng : SemidirectProduct N₁ G₁ φ₁\n⊢ Eq (sorryAx (Unit → G₂) Bool.true (Function.const Lean.Name Unit.unit ((((((((((Lean.Name.anonymous.num 266).num 38).num 266).num 59).num 38).num 59).str \"_sorry\").str \"_@\").str \"_hyg\").num 3915))) (fg g.right)","decl":"@[simp]\ntheorem map_right (g : N₁ ⋊[φ₁] G₁) : (map fn fg h g).right = fg g.right := rfl\n\n"}
{"name":"SemidirectProduct.congr_symm_apply_left","module":"Mathlib.GroupTheory.SemidirectProduct","initialProofState":"N₁ : Type u_4\nG₁ : Type u_5\nN₂ : Type u_6\nG₂ : Type u_7\ninst✝³ : Group N₁\ninst✝² : Group G₁\ninst✝¹ : Group N₂\ninst✝ : Group G₂\nφ₁ : MonoidHom G₁ (MulAut N₁)\nφ₂ : MonoidHom G₂ (MulAut N₂)\nfn : MulEquiv N₁ N₂\nfg : MulEquiv G₁ G₂\nx : SemidirectProduct N₂ G₂ φ₂\n⊢ Eq ((SemidirectProduct.congr fn fg).symm x).left (fn.symm x.left)","decl":"/-- Define an isomorphism from `N₁ ⋊[φ₁] G₁` to `N₂ ⋊[φ₂] G₂` given isomorphisms `N₁ ≃* N₂` and\n  `G₁ ≃* G₂` that satisfy a commutativity condition `∀ n g, fn (φ₁ g n) = φ₂ (fg g) (fn n)`. -/\n@[simps]\ndef congr : N₁ ⋊[φ₁] G₁ ≃* N₂ ⋊[φ₂] G₂ where\n  toFun x := ⟨fn x.1, fg x.2⟩\n  invFun x := ⟨fn.symm x.1, fg.symm x.2⟩\n  left_inv _ := by simp\n  right_inv _ := by simp\n  map_mul' x y := by\n    replace h := DFunLike.ext_iff.1 (h x.right) y.left\n    ext <;> simp_all\n\n"}
{"name":"SemidirectProduct.congr_apply_left","module":"Mathlib.GroupTheory.SemidirectProduct","initialProofState":"N₁ : Type u_4\nG₁ : Type u_5\nN₂ : Type u_6\nG₂ : Type u_7\ninst✝³ : Group N₁\ninst✝² : Group G₁\ninst✝¹ : Group N₂\ninst✝ : Group G₂\nφ₁ : MonoidHom G₁ (MulAut N₁)\nφ₂ : MonoidHom G₂ (MulAut N₂)\nfn : MulEquiv N₁ N₂\nfg : MulEquiv G₁ G₂\nx : SemidirectProduct N₁ G₁ φ₁\n⊢ Eq ((SemidirectProduct.congr fn fg) x).left (fn x.left)","decl":"/-- Define an isomorphism from `N₁ ⋊[φ₁] G₁` to `N₂ ⋊[φ₂] G₂` given isomorphisms `N₁ ≃* N₂` and\n  `G₁ ≃* G₂` that satisfy a commutativity condition `∀ n g, fn (φ₁ g n) = φ₂ (fg g) (fn n)`. -/\n@[simps]\ndef congr : N₁ ⋊[φ₁] G₁ ≃* N₂ ⋊[φ₂] G₂ where\n  toFun x := ⟨fn x.1, fg x.2⟩\n  invFun x := ⟨fn.symm x.1, fg.symm x.2⟩\n  left_inv _ := by simp\n  right_inv _ := by simp\n  map_mul' x y := by\n    replace h := DFunLike.ext_iff.1 (h x.right) y.left\n    ext <;> simp_all\n\n"}
{"name":"SemidirectProduct.congr_apply_right","module":"Mathlib.GroupTheory.SemidirectProduct","initialProofState":"N₁ : Type u_4\nG₁ : Type u_5\nN₂ : Type u_6\nG₂ : Type u_7\ninst✝³ : Group N₁\ninst✝² : Group G₁\ninst✝¹ : Group N₂\ninst✝ : Group G₂\nφ₁ : MonoidHom G₁ (MulAut N₁)\nφ₂ : MonoidHom G₂ (MulAut N₂)\nfn : MulEquiv N₁ N₂\nfg : MulEquiv G₁ G₂\nx : SemidirectProduct N₁ G₁ φ₁\n⊢ Eq ((SemidirectProduct.congr fn fg) x).right (fg x.right)","decl":"/-- Define an isomorphism from `N₁ ⋊[φ₁] G₁` to `N₂ ⋊[φ₂] G₂` given isomorphisms `N₁ ≃* N₂` and\n  `G₁ ≃* G₂` that satisfy a commutativity condition `∀ n g, fn (φ₁ g n) = φ₂ (fg g) (fn n)`. -/\n@[simps]\ndef congr : N₁ ⋊[φ₁] G₁ ≃* N₂ ⋊[φ₂] G₂ where\n  toFun x := ⟨fn x.1, fg x.2⟩\n  invFun x := ⟨fn.symm x.1, fg.symm x.2⟩\n  left_inv _ := by simp\n  right_inv _ := by simp\n  map_mul' x y := by\n    replace h := DFunLike.ext_iff.1 (h x.right) y.left\n    ext <;> simp_all\n\n"}
{"name":"SemidirectProduct.congr_symm_apply_right","module":"Mathlib.GroupTheory.SemidirectProduct","initialProofState":"N₁ : Type u_4\nG₁ : Type u_5\nN₂ : Type u_6\nG₂ : Type u_7\ninst✝³ : Group N₁\ninst✝² : Group G₁\ninst✝¹ : Group N₂\ninst✝ : Group G₂\nφ₁ : MonoidHom G₁ (MulAut N₁)\nφ₂ : MonoidHom G₂ (MulAut N₂)\nfn : MulEquiv N₁ N₂\nfg : MulEquiv G₁ G₂\nx : SemidirectProduct N₂ G₂ φ₂\n⊢ Eq ((SemidirectProduct.congr fn fg).symm x).right (fg.symm x.right)","decl":"/-- Define an isomorphism from `N₁ ⋊[φ₁] G₁` to `N₂ ⋊[φ₂] G₂` given isomorphisms `N₁ ≃* N₂` and\n  `G₁ ≃* G₂` that satisfy a commutativity condition `∀ n g, fn (φ₁ g n) = φ₂ (fg g) (fn n)`. -/\n@[simps]\ndef congr : N₁ ⋊[φ₁] G₁ ≃* N₂ ⋊[φ₂] G₂ where\n  toFun x := ⟨fn x.1, fg x.2⟩\n  invFun x := ⟨fn.symm x.1, fg.symm x.2⟩\n  left_inv _ := by simp\n  right_inv _ := by simp\n  map_mul' x y := by\n    replace h := DFunLike.ext_iff.1 (h x.right) y.left\n    ext <;> simp_all\n\n"}
{"name":"SemidirectProduct.card","module":"Mathlib.GroupTheory.SemidirectProduct","initialProofState":"N : Type u_1\nG : Type u_2\ninst✝¹ : Group N\ninst✝ : Group G\nφ : MonoidHom G (MulAut N)\n⊢ Eq (Nat.card (SemidirectProduct N G φ)) (HMul.hMul (Nat.card N) (Nat.card G))","decl":"@[simp]\nlemma card : Nat.card (N ⋊[φ] G) = Nat.card N * Nat.card G :=\n  Nat.card_prod _ _ ▸ Nat.card_congr equivProd\n\n"}
