{"name":"Subgroup.smul_diff_smul'","module":"Mathlib.GroupTheory.SchurZassenhaus","initialProofState":"G : Type u_1\ninst✝² : Group G\nH : Subgroup G\ninst✝¹ : H.IsCommutative\ninst✝ : H.FiniteIndex\nα β : H.LeftTransversal\nhH : H.Normal\ng : MulOpposite G\n⊢ Eq (Subgroup.leftTransversals.diff (MonoidHom.id (Subtype fun x => Membership.mem H x)) (HSMul.hSMul g α) (HSMul.hSMul g β)) ⟨HMul.hMul (HMul.hMul (Inv.inv (MulOpposite.unop g)) ↑(Subgroup.leftTransversals.diff (MonoidHom.id (Subtype fun x => Membership.mem H x)) α β)) (MulOpposite.unop g), ⋯⟩","decl":"theorem smul_diff_smul' [hH : Normal H] (g : Gᵐᵒᵖ) :\n    diff (MonoidHom.id H) (g • α) (g • β) =\n      ⟨g.unop⁻¹ * (diff (MonoidHom.id H) α β : H) * g.unop,\n        hH.mem_comm ((congr_arg (· ∈ H) (mul_inv_cancel_left _ _)).mpr (SetLike.coe_mem _))⟩ := by\n  letI := H.fintypeQuotientOfFiniteIndex\n  let ϕ : H →* H :=\n    { toFun := fun h =>\n        ⟨g.unop⁻¹ * h * g.unop,\n          hH.mem_comm ((congr_arg (· ∈ H) (mul_inv_cancel_left _ _)).mpr (SetLike.coe_mem _))⟩\n      map_one' := by rw [Subtype.ext_iff, coe_mk, coe_one, mul_one, inv_mul_cancel]\n      map_mul' := fun h₁ h₂ => by\n        simp only [Subtype.ext_iff, coe_mk, coe_mul, mul_assoc, mul_inv_cancel_left] }\n  refine (Fintype.prod_equiv (MulAction.toPerm g).symm _ _ fun x ↦ ?_).trans (map_prod ϕ _ _).symm\n  simp only [ϕ, smul_apply_eq_smul_apply_inv_smul, smul_eq_mul_unop, mul_inv_rev, mul_assoc,\n    MonoidHom.id_apply, toPerm_symm_apply, MonoidHom.coe_mk, OneHom.coe_mk]\n\n"}
{"name":"Subgroup.smul_diff'","module":"Mathlib.GroupTheory.SchurZassenhaus","initialProofState":"G : Type u_1\ninst✝³ : Group G\nH : Subgroup G\ninst✝² : H.IsCommutative\ninst✝¹ : H.FiniteIndex\nα β : H.LeftTransversal\ninst✝ : H.Normal\nh : Subtype fun x => Membership.mem H x\n⊢ Eq (Subgroup.leftTransversals.diff (MonoidHom.id (Subtype fun x => Membership.mem H x)) α (HSMul.hSMul (MulOpposite.op ↑h) β)) (HMul.hMul (Subgroup.leftTransversals.diff (MonoidHom.id (Subtype fun x => Membership.mem H x)) α β) (HPow.hPow h H.index))","decl":"theorem smul_diff' (h : H) :\n    diff (MonoidHom.id H) α (op (h : G) • β) = diff (MonoidHom.id H) α β * h ^ H.index := by\n  letI := H.fintypeQuotientOfFiniteIndex\n  rw [diff, diff, index_eq_card, Nat.card_eq_fintype_card,\n      ← Finset.card_univ, ← Finset.prod_const, ← Finset.prod_mul_distrib]\n  refine Finset.prod_congr rfl fun q _ => ?_\n  simp_rw [Subtype.ext_iff, MonoidHom.id_apply, coe_mul, mul_assoc, mul_right_inj]\n  rw [smul_apply_eq_smul_apply_inv_smul, smul_eq_mul_unop, MulOpposite.unop_op, mul_left_inj,\n    ← Subtype.ext_iff, Equiv.apply_eq_iff_eq, inv_smul_eq_iff]\n  exact self_eq_mul_right.mpr ((QuotientGroup.eq_one_iff _).mpr h.2)\n\n"}
{"name":"Subgroup.eq_one_of_smul_eq_one","module":"Mathlib.GroupTheory.SchurZassenhaus","initialProofState":"G : Type u_1\ninst✝³ : Group G\nH : Subgroup G\ninst✝² : H.IsCommutative\ninst✝¹ : H.FiniteIndex\ninst✝ : H.Normal\nhH : (Nat.card (Subtype fun x => Membership.mem H x)).Coprime H.index\nα : H.QuotientDiff\nh : Subtype fun x => Membership.mem H x\na✝ : Eq (HSMul.hSMul h α) α\n⊢ Eq h 1","decl":"theorem eq_one_of_smul_eq_one (hH : Nat.Coprime (Nat.card H) H.index) (α : H.QuotientDiff)\n    (h : H) : h • α = α → h = 1 :=\n  Quotient.inductionOn' α fun α hα =>\n    (powCoprime hH).injective <|\n      calc\n        h ^ H.index = diff (MonoidHom.id H) (op ((h⁻¹ : H) : G) • α) α := by\n          rw [← diff_inv, smul_diff', diff_self, one_mul, inv_pow, inv_inv]\n        _ = 1 ^ H.index := (Quotient.exact' hα).trans (one_pow H.index).symm\n\n"}
{"name":"Subgroup.exists_smul_eq","module":"Mathlib.GroupTheory.SchurZassenhaus","initialProofState":"G : Type u_1\ninst✝³ : Group G\nH : Subgroup G\ninst✝² : H.IsCommutative\ninst✝¹ : H.FiniteIndex\ninst✝ : H.Normal\nhH : (Nat.card (Subtype fun x => Membership.mem H x)).Coprime H.index\nα β : H.QuotientDiff\n⊢ Exists fun h => Eq (HSMul.hSMul h α) β","decl":"theorem exists_smul_eq (hH : Nat.Coprime (Nat.card H) H.index) (α β : H.QuotientDiff) :\n    ∃ h : H, h • α = β :=\n  Quotient.inductionOn' α\n    (Quotient.inductionOn' β fun β α =>\n      Exists.imp (fun _ => Quotient.sound')\n        ⟨(powCoprime hH).symm (diff (MonoidHom.id H) β α),\n          (diff_inv _ _ _).symm.trans\n            (inv_eq_one.mpr\n              ((smul_diff' β α ((powCoprime hH).symm (diff (MonoidHom.id H) β α))⁻¹).trans\n                (by rw [inv_pow, ← powCoprime_apply hH, Equiv.apply_symm_apply, mul_inv_cancel])))⟩)\n\n"}
{"name":"Subgroup.isComplement'_stabilizer_of_coprime","module":"Mathlib.GroupTheory.SchurZassenhaus","initialProofState":"G : Type u_1\ninst✝³ : Group G\nH : Subgroup G\ninst✝² : H.IsCommutative\ninst✝¹ : H.FiniteIndex\ninst✝ : H.Normal\nα : H.QuotientDiff\nhH : (Nat.card (Subtype fun x => Membership.mem H x)).Coprime H.index\n⊢ H.IsComplement' (MulAction.stabilizer G α)","decl":"theorem isComplement'_stabilizer_of_coprime {α : H.QuotientDiff}\n    (hH : Nat.Coprime (Nat.card H) H.index) : IsComplement' H (stabilizer G α) :=\n  isComplement'_stabilizer α (eq_one_of_smul_eq_one hH α) fun g => exists_smul_eq hH (g • α) α\n\n"}
{"name":"Subgroup.SchurZassenhausInduction.step7","module":"Mathlib.GroupTheory.SchurZassenhaus","initialProofState":"G : Type u\ninst✝² : Group G\nN : Subgroup G\ninst✝¹ : N.Normal\nh1 : (Nat.card (Subtype fun x => Membership.mem N x)).Coprime N.index\nh2 : ∀ (G' : Type u) [inst : Group G'] [inst_1 : Finite G'], LT.lt (Nat.card G') (Nat.card G) → ∀ {N' : Subgroup G'} [inst_2 : N'.Normal], (Nat.card (Subtype fun x => Membership.mem N' x)).Coprime N'.index → Exists fun H' => N'.IsComplement' H'\nh3 : ∀ (H : Subgroup G), Not (N.IsComplement' H)\ninst✝ : Finite G\n⊢ N.IsCommutative","decl":"include h2 in\n/-- Do not use this lemma: It is made obsolete by `exists_right_complement'_of_coprime` -/\ntheorem step7 : IsCommutative N := by\n  haveI := N.bot_or_nontrivial.resolve_left (step0 h1 h3)\n  haveI : Fact (Nat.card N).minFac.Prime := ⟨step4 h1 h3⟩\n  exact\n    ⟨⟨fun g h => ((eq_top_iff.mp ((step3 h1 h2 h3 (center N)).resolve_left\n      (step6 h1 h2 h3).bot_lt_center.ne') (mem_top h)).comm g).symm⟩⟩\n\n"}
{"name":"Subgroup.exists_right_complement'_of_coprime","module":"Mathlib.GroupTheory.SchurZassenhaus","initialProofState":"G : Type u\ninst✝¹ : Group G\nN : Subgroup G\ninst✝ : N.Normal\nhN : (Nat.card (Subtype fun x => Membership.mem N x)).Coprime N.index\n⊢ Exists fun H => N.IsComplement' H","decl":"/-- **Schur-Zassenhaus** for normal subgroups:\n  If `H : Subgroup G` is normal, and has order coprime to its index, then there exists a\n  subgroup `K` which is a (right) complement of `H`. -/\ntheorem exists_right_complement'_of_coprime {N : Subgroup G} [N.Normal]\n    (hN : Nat.Coprime (Nat.card N) N.index) : ∃ H : Subgroup G, IsComplement' N H := by\n  by_cases hN1 : Nat.card N = 0\n  · rw [hN1, Nat.coprime_zero_left, index_eq_one] at hN\n    rw [hN]\n    exact ⟨⊥, isComplement'_top_bot⟩\n  by_cases hN2 : N.index = 0\n  · rw [hN2, Nat.coprime_zero_right] at hN\n    haveI := (Cardinal.toNat_eq_one_iff_unique.mp hN).1\n    rw [N.eq_bot_of_subsingleton]\n    exact ⟨⊤, isComplement'_bot_top⟩\n  have hN3 : Nat.card G ≠ 0 := by\n    rw [← N.card_mul_index]\n    exact mul_ne_zero hN1 hN2\n  haveI := (Cardinal.lt_aleph0_iff_fintype.mp\n    (lt_of_not_ge (mt Cardinal.toNat_apply_of_aleph0_le hN3))).some\n  exact exists_right_complement'_of_coprime_aux' rfl hN\n\n"}
{"name":"Subgroup.exists_left_complement'_of_coprime","module":"Mathlib.GroupTheory.SchurZassenhaus","initialProofState":"G : Type u\ninst✝¹ : Group G\nN : Subgroup G\ninst✝ : N.Normal\nhN : (Nat.card (Subtype fun x => Membership.mem N x)).Coprime N.index\n⊢ Exists fun H => H.IsComplement' N","decl":"/-- **Schur-Zassenhaus** for normal subgroups:\n  If `H : Subgroup G` is normal, and has order coprime to its index, then there exists a\n  subgroup `K` which is a (left) complement of `H`. -/\ntheorem exists_left_complement'_of_coprime {N : Subgroup G} [N.Normal]\n    (hN : Nat.Coprime (Nat.card N) N.index) : ∃ H : Subgroup G, IsComplement' H N :=\n  Exists.imp (fun _ => IsComplement'.symm) (exists_right_complement'_of_coprime hN)\n\n"}
