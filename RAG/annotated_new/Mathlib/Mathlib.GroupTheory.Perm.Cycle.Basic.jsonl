{"name":"Equiv.Perm.SameCycle.refl","module":"Mathlib.GroupTheory.Perm.Cycle.Basic","initialProofState":"α : Type u_2\nf : Equiv.Perm α\nx : α\n⊢ f.SameCycle x x","decl":"@[refl]\ntheorem SameCycle.refl (f : Perm α) (x : α) : SameCycle f x x :=\n  ⟨0, rfl⟩\n\n"}
{"name":"Equiv.Perm.SameCycle.rfl","module":"Mathlib.GroupTheory.Perm.Cycle.Basic","initialProofState":"α : Type u_2\nf : Equiv.Perm α\nx : α\n⊢ f.SameCycle x x","decl":"theorem SameCycle.rfl : SameCycle f x x :=\n  SameCycle.refl _ _\n\n"}
{"name":"Eq.sameCycle","module":"Mathlib.GroupTheory.Perm.Cycle.Basic","initialProofState":"α : Type u_2\nx y : α\nh : Eq x y\nf : Equiv.Perm α\n⊢ f.SameCycle x y","decl":"protected theorem _root_.Eq.sameCycle (h : x = y) (f : Perm α) : f.SameCycle x y := by rw [h]\n\n"}
{"name":"Equiv.Perm.SameCycle.symm","module":"Mathlib.GroupTheory.Perm.Cycle.Basic","initialProofState":"α : Type u_2\nf : Equiv.Perm α\nx y : α\na✝ : f.SameCycle x y\n⊢ f.SameCycle y x","decl":"@[symm]\ntheorem SameCycle.symm : SameCycle f x y → SameCycle f y x := fun ⟨i, hi⟩ =>\n  ⟨-i, by rw [zpow_neg, ← hi, inv_apply_self]⟩\n\n"}
{"name":"Equiv.Perm.sameCycle_comm","module":"Mathlib.GroupTheory.Perm.Cycle.Basic","initialProofState":"α : Type u_2\nf : Equiv.Perm α\nx y : α\n⊢ Iff (f.SameCycle x y) (f.SameCycle y x)","decl":"theorem sameCycle_comm : SameCycle f x y ↔ SameCycle f y x :=\n  ⟨SameCycle.symm, SameCycle.symm⟩\n\n"}
{"name":"Equiv.Perm.SameCycle.trans","module":"Mathlib.GroupTheory.Perm.Cycle.Basic","initialProofState":"α : Type u_2\nf : Equiv.Perm α\nx y z : α\na✝¹ : f.SameCycle x y\na✝ : f.SameCycle y z\n⊢ f.SameCycle x z","decl":"@[trans]\ntheorem SameCycle.trans : SameCycle f x y → SameCycle f y z → SameCycle f x z :=\n  fun ⟨i, hi⟩ ⟨j, hj⟩ => ⟨j + i, by rw [zpow_add, mul_apply, hi, hj]⟩\n\n"}
{"name":"Equiv.Perm.SameCycle.equivalence","module":"Mathlib.GroupTheory.Perm.Cycle.Basic","initialProofState":"α : Type u_2\nf : Equiv.Perm α\n⊢ Equivalence f.SameCycle","decl":"variable (f) in\ntheorem SameCycle.equivalence : Equivalence (SameCycle f) :=\n  ⟨SameCycle.refl f, SameCycle.symm, SameCycle.trans⟩\n\n"}
{"name":"Equiv.Perm.sameCycle_one","module":"Mathlib.GroupTheory.Perm.Cycle.Basic","initialProofState":"α : Type u_2\nx y : α\n⊢ Iff (Equiv.Perm.SameCycle 1 x y) (Eq x y)","decl":"@[simp]\ntheorem sameCycle_one : SameCycle 1 x y ↔ x = y := by simp [SameCycle]\n\n"}
{"name":"Equiv.Perm.sameCycle_inv","module":"Mathlib.GroupTheory.Perm.Cycle.Basic","initialProofState":"α : Type u_2\nf : Equiv.Perm α\nx y : α\n⊢ Iff ((Inv.inv f).SameCycle x y) (f.SameCycle x y)","decl":"@[simp]\ntheorem sameCycle_inv : SameCycle f⁻¹ x y ↔ SameCycle f x y :=\n  (Equiv.neg _).exists_congr_left.trans <| by simp [SameCycle]\n\n"}
{"name":"Equiv.Perm.SameCycle.of_inv","module":"Mathlib.GroupTheory.Perm.Cycle.Basic","initialProofState":"α : Type u_2\nf : Equiv.Perm α\nx y : α\na✝ : (Inv.inv f).SameCycle x y\n⊢ f.SameCycle x y","decl":"alias ⟨SameCycle.of_inv, SameCycle.inv⟩ := sameCycle_inv\n\n"}
{"name":"Equiv.Perm.SameCycle.inv","module":"Mathlib.GroupTheory.Perm.Cycle.Basic","initialProofState":"α : Type u_2\nf : Equiv.Perm α\nx y : α\na✝ : f.SameCycle x y\n⊢ (Inv.inv f).SameCycle x y","decl":"alias ⟨SameCycle.of_inv, SameCycle.inv⟩ := sameCycle_inv\n\n"}
{"name":"Equiv.Perm.sameCycle_conj","module":"Mathlib.GroupTheory.Perm.Cycle.Basic","initialProofState":"α : Type u_2\nf g : Equiv.Perm α\nx y : α\n⊢ Iff ((HMul.hMul (HMul.hMul g f) (Inv.inv g)).SameCycle x y) (f.SameCycle ((Inv.inv g) x) ((Inv.inv g) y))","decl":"@[simp]\ntheorem sameCycle_conj : SameCycle (g * f * g⁻¹) x y ↔ SameCycle f (g⁻¹ x) (g⁻¹ y) :=\n  exists_congr fun i => by simp [conj_zpow, eq_inv_iff_eq]\n\n"}
{"name":"Equiv.Perm.SameCycle.conj","module":"Mathlib.GroupTheory.Perm.Cycle.Basic","initialProofState":"α : Type u_2\nf g : Equiv.Perm α\nx y : α\na✝ : f.SameCycle x y\n⊢ (HMul.hMul (HMul.hMul g f) (Inv.inv g)).SameCycle (g x) (g y)","decl":"theorem SameCycle.conj : SameCycle f x y → SameCycle (g * f * g⁻¹) (g x) (g y) := by\n  simp [sameCycle_conj]\n\n"}
{"name":"Equiv.Perm.SameCycle.apply_eq_self_iff","module":"Mathlib.GroupTheory.Perm.Cycle.Basic","initialProofState":"α : Type u_2\nf : Equiv.Perm α\nx y : α\na✝ : f.SameCycle x y\n⊢ Iff (Eq (f x) x) (Eq (f y) y)","decl":"theorem SameCycle.apply_eq_self_iff : SameCycle f x y → (f x = x ↔ f y = y) := fun ⟨i, hi⟩ => by\n  rw [← hi, ← mul_apply, ← zpow_one_add, add_comm, zpow_add_one, mul_apply,\n    (f ^ i).injective.eq_iff]\n\n"}
{"name":"Equiv.Perm.SameCycle.eq_of_left","module":"Mathlib.GroupTheory.Perm.Cycle.Basic","initialProofState":"α : Type u_2\nf : Equiv.Perm α\nx y : α\nh : f.SameCycle x y\nhx : Function.IsFixedPt (⇑f) x\n⊢ Eq x y","decl":"theorem SameCycle.eq_of_left (h : SameCycle f x y) (hx : IsFixedPt f x) : x = y :=\n  let ⟨_, hn⟩ := h\n  (hx.perm_zpow _).eq.symm.trans hn\n\n"}
{"name":"Equiv.Perm.SameCycle.eq_of_right","module":"Mathlib.GroupTheory.Perm.Cycle.Basic","initialProofState":"α : Type u_2\nf : Equiv.Perm α\nx y : α\nh : f.SameCycle x y\nhy : Function.IsFixedPt (⇑f) y\n⊢ Eq x y","decl":"theorem SameCycle.eq_of_right (h : SameCycle f x y) (hy : IsFixedPt f y) : x = y :=\n  h.eq_of_left <| h.apply_eq_self_iff.2 hy\n\n"}
{"name":"Equiv.Perm.sameCycle_apply_left","module":"Mathlib.GroupTheory.Perm.Cycle.Basic","initialProofState":"α : Type u_2\nf : Equiv.Perm α\nx y : α\n⊢ Iff (f.SameCycle (f x) y) (f.SameCycle x y)","decl":"@[simp]\ntheorem sameCycle_apply_left : SameCycle f (f x) y ↔ SameCycle f x y :=\n  (Equiv.addRight 1).exists_congr_left.trans <| by\n    simp [zpow_sub, SameCycle, Int.add_neg_one, Function.comp]\n\n"}
{"name":"Equiv.Perm.sameCycle_apply_right","module":"Mathlib.GroupTheory.Perm.Cycle.Basic","initialProofState":"α : Type u_2\nf : Equiv.Perm α\nx y : α\n⊢ Iff (f.SameCycle x (f y)) (f.SameCycle x y)","decl":"@[simp]\ntheorem sameCycle_apply_right : SameCycle f x (f y) ↔ SameCycle f x y := by\n  rw [sameCycle_comm, sameCycle_apply_left, sameCycle_comm]\n\n"}
{"name":"Equiv.Perm.sameCycle_inv_apply_left","module":"Mathlib.GroupTheory.Perm.Cycle.Basic","initialProofState":"α : Type u_2\nf : Equiv.Perm α\nx y : α\n⊢ Iff (f.SameCycle ((Inv.inv f) x) y) (f.SameCycle x y)","decl":"@[simp]\ntheorem sameCycle_inv_apply_left : SameCycle f (f⁻¹ x) y ↔ SameCycle f x y := by\n  rw [← sameCycle_apply_left, apply_inv_self]\n\n"}
{"name":"Equiv.Perm.sameCycle_inv_apply_right","module":"Mathlib.GroupTheory.Perm.Cycle.Basic","initialProofState":"α : Type u_2\nf : Equiv.Perm α\nx y : α\n⊢ Iff (f.SameCycle x ((Inv.inv f) y)) (f.SameCycle x y)","decl":"@[simp]\ntheorem sameCycle_inv_apply_right : SameCycle f x (f⁻¹ y) ↔ SameCycle f x y := by\n  rw [← sameCycle_apply_right, apply_inv_self]\n\n"}
{"name":"Equiv.Perm.sameCycle_zpow_left","module":"Mathlib.GroupTheory.Perm.Cycle.Basic","initialProofState":"α : Type u_2\nf : Equiv.Perm α\nx y : α\nn : Int\n⊢ Iff (f.SameCycle ((HPow.hPow f n) x) y) (f.SameCycle x y)","decl":"@[simp]\ntheorem sameCycle_zpow_left {n : ℤ} : SameCycle f ((f ^ n) x) y ↔ SameCycle f x y :=\n  (Equiv.addRight (n : ℤ)).exists_congr_left.trans <| by simp [SameCycle, zpow_add]\n\n"}
{"name":"Equiv.Perm.sameCycle_zpow_right","module":"Mathlib.GroupTheory.Perm.Cycle.Basic","initialProofState":"α : Type u_2\nf : Equiv.Perm α\nx y : α\nn : Int\n⊢ Iff (f.SameCycle x ((HPow.hPow f n) y)) (f.SameCycle x y)","decl":"@[simp]\ntheorem sameCycle_zpow_right {n : ℤ} : SameCycle f x ((f ^ n) y) ↔ SameCycle f x y := by\n  rw [sameCycle_comm, sameCycle_zpow_left, sameCycle_comm]\n\n"}
{"name":"Equiv.Perm.sameCycle_pow_left","module":"Mathlib.GroupTheory.Perm.Cycle.Basic","initialProofState":"α : Type u_2\nf : Equiv.Perm α\nx y : α\nn : Nat\n⊢ Iff (f.SameCycle ((HPow.hPow f n) x) y) (f.SameCycle x y)","decl":"@[simp]\ntheorem sameCycle_pow_left {n : ℕ} : SameCycle f ((f ^ n) x) y ↔ SameCycle f x y := by\n  rw [← zpow_natCast, sameCycle_zpow_left]\n\n"}
{"name":"Equiv.Perm.sameCycle_pow_right","module":"Mathlib.GroupTheory.Perm.Cycle.Basic","initialProofState":"α : Type u_2\nf : Equiv.Perm α\nx y : α\nn : Nat\n⊢ Iff (f.SameCycle x ((HPow.hPow f n) y)) (f.SameCycle x y)","decl":"@[simp]\ntheorem sameCycle_pow_right {n : ℕ} : SameCycle f x ((f ^ n) y) ↔ SameCycle f x y := by\n  rw [← zpow_natCast, sameCycle_zpow_right]\n\n"}
{"name":"Equiv.Perm.SameCycle.of_apply_left","module":"Mathlib.GroupTheory.Perm.Cycle.Basic","initialProofState":"α : Type u_2\nf : Equiv.Perm α\nx y : α\na✝ : f.SameCycle (f x) y\n⊢ f.SameCycle x y","decl":"alias ⟨SameCycle.of_apply_left, SameCycle.apply_left⟩ := sameCycle_apply_left\n\n"}
{"name":"Equiv.Perm.SameCycle.apply_left","module":"Mathlib.GroupTheory.Perm.Cycle.Basic","initialProofState":"α : Type u_2\nf : Equiv.Perm α\nx y : α\na✝ : f.SameCycle x y\n⊢ f.SameCycle (f x) y","decl":"alias ⟨SameCycle.of_apply_left, SameCycle.apply_left⟩ := sameCycle_apply_left\n\n"}
{"name":"Equiv.Perm.SameCycle.apply_right","module":"Mathlib.GroupTheory.Perm.Cycle.Basic","initialProofState":"α : Type u_2\nf : Equiv.Perm α\nx y : α\na✝ : f.SameCycle x y\n⊢ f.SameCycle x (f y)","decl":"alias ⟨SameCycle.of_apply_right, SameCycle.apply_right⟩ := sameCycle_apply_right\n\n"}
{"name":"Equiv.Perm.SameCycle.of_apply_right","module":"Mathlib.GroupTheory.Perm.Cycle.Basic","initialProofState":"α : Type u_2\nf : Equiv.Perm α\nx y : α\na✝ : f.SameCycle x (f y)\n⊢ f.SameCycle x y","decl":"alias ⟨SameCycle.of_apply_right, SameCycle.apply_right⟩ := sameCycle_apply_right\n\n"}
{"name":"Equiv.Perm.SameCycle.inv_apply_left","module":"Mathlib.GroupTheory.Perm.Cycle.Basic","initialProofState":"α : Type u_2\nf : Equiv.Perm α\nx y : α\na✝ : f.SameCycle x y\n⊢ f.SameCycle ((Inv.inv f) x) y","decl":"alias ⟨SameCycle.of_inv_apply_left, SameCycle.inv_apply_left⟩ := sameCycle_inv_apply_left\n\n"}
{"name":"Equiv.Perm.SameCycle.of_inv_apply_left","module":"Mathlib.GroupTheory.Perm.Cycle.Basic","initialProofState":"α : Type u_2\nf : Equiv.Perm α\nx y : α\na✝ : f.SameCycle ((Inv.inv f) x) y\n⊢ f.SameCycle x y","decl":"alias ⟨SameCycle.of_inv_apply_left, SameCycle.inv_apply_left⟩ := sameCycle_inv_apply_left\n\n"}
{"name":"Equiv.Perm.SameCycle.of_inv_apply_right","module":"Mathlib.GroupTheory.Perm.Cycle.Basic","initialProofState":"α : Type u_2\nf : Equiv.Perm α\nx y : α\na✝ : f.SameCycle x ((Inv.inv f) y)\n⊢ f.SameCycle x y","decl":"alias ⟨SameCycle.of_inv_apply_right, SameCycle.inv_apply_right⟩ := sameCycle_inv_apply_right\n\n"}
{"name":"Equiv.Perm.SameCycle.inv_apply_right","module":"Mathlib.GroupTheory.Perm.Cycle.Basic","initialProofState":"α : Type u_2\nf : Equiv.Perm α\nx y : α\na✝ : f.SameCycle x y\n⊢ f.SameCycle x ((Inv.inv f) y)","decl":"alias ⟨SameCycle.of_inv_apply_right, SameCycle.inv_apply_right⟩ := sameCycle_inv_apply_right\n\n"}
{"name":"Equiv.Perm.SameCycle.pow_left","module":"Mathlib.GroupTheory.Perm.Cycle.Basic","initialProofState":"α : Type u_2\nf : Equiv.Perm α\nx y : α\nn : Nat\na✝ : f.SameCycle x y\n⊢ f.SameCycle ((HPow.hPow f n) x) y","decl":"alias ⟨SameCycle.of_pow_left, SameCycle.pow_left⟩ := sameCycle_pow_left\n\n"}
{"name":"Equiv.Perm.SameCycle.of_pow_left","module":"Mathlib.GroupTheory.Perm.Cycle.Basic","initialProofState":"α : Type u_2\nf : Equiv.Perm α\nx y : α\nn : Nat\na✝ : f.SameCycle ((HPow.hPow f n) x) y\n⊢ f.SameCycle x y","decl":"alias ⟨SameCycle.of_pow_left, SameCycle.pow_left⟩ := sameCycle_pow_left\n\n"}
{"name":"Equiv.Perm.SameCycle.pow_right","module":"Mathlib.GroupTheory.Perm.Cycle.Basic","initialProofState":"α : Type u_2\nf : Equiv.Perm α\nx y : α\nn : Nat\na✝ : f.SameCycle x y\n⊢ f.SameCycle x ((HPow.hPow f n) y)","decl":"alias ⟨SameCycle.of_pow_right, SameCycle.pow_right⟩ := sameCycle_pow_right\n\n"}
{"name":"Equiv.Perm.SameCycle.of_pow_right","module":"Mathlib.GroupTheory.Perm.Cycle.Basic","initialProofState":"α : Type u_2\nf : Equiv.Perm α\nx y : α\nn : Nat\na✝ : f.SameCycle x ((HPow.hPow f n) y)\n⊢ f.SameCycle x y","decl":"alias ⟨SameCycle.of_pow_right, SameCycle.pow_right⟩ := sameCycle_pow_right\n\n"}
{"name":"Equiv.Perm.SameCycle.zpow_left","module":"Mathlib.GroupTheory.Perm.Cycle.Basic","initialProofState":"α : Type u_2\nf : Equiv.Perm α\nx y : α\nn : Int\na✝ : f.SameCycle x y\n⊢ f.SameCycle ((HPow.hPow f n) x) y","decl":"alias ⟨SameCycle.of_zpow_left, SameCycle.zpow_left⟩ := sameCycle_zpow_left\n\n"}
{"name":"Equiv.Perm.SameCycle.of_zpow_left","module":"Mathlib.GroupTheory.Perm.Cycle.Basic","initialProofState":"α : Type u_2\nf : Equiv.Perm α\nx y : α\nn : Int\na✝ : f.SameCycle ((HPow.hPow f n) x) y\n⊢ f.SameCycle x y","decl":"alias ⟨SameCycle.of_zpow_left, SameCycle.zpow_left⟩ := sameCycle_zpow_left\n\n"}
{"name":"Equiv.Perm.SameCycle.zpow_right","module":"Mathlib.GroupTheory.Perm.Cycle.Basic","initialProofState":"α : Type u_2\nf : Equiv.Perm α\nx y : α\nn : Int\na✝ : f.SameCycle x y\n⊢ f.SameCycle x ((HPow.hPow f n) y)","decl":"alias ⟨SameCycle.of_zpow_right, SameCycle.zpow_right⟩ := sameCycle_zpow_right\n\n"}
{"name":"Equiv.Perm.SameCycle.of_zpow_right","module":"Mathlib.GroupTheory.Perm.Cycle.Basic","initialProofState":"α : Type u_2\nf : Equiv.Perm α\nx y : α\nn : Int\na✝ : f.SameCycle x ((HPow.hPow f n) y)\n⊢ f.SameCycle x y","decl":"alias ⟨SameCycle.of_zpow_right, SameCycle.zpow_right⟩ := sameCycle_zpow_right\n\n"}
{"name":"Equiv.Perm.SameCycle.of_pow","module":"Mathlib.GroupTheory.Perm.Cycle.Basic","initialProofState":"α : Type u_2\nf : Equiv.Perm α\nx y : α\nn : Nat\na✝ : (HPow.hPow f n).SameCycle x y\n⊢ f.SameCycle x y","decl":"theorem SameCycle.of_pow {n : ℕ} : SameCycle (f ^ n) x y → SameCycle f x y := fun ⟨m, h⟩ =>\n  ⟨n * m, by simp [zpow_mul, h]⟩\n\n"}
{"name":"Equiv.Perm.SameCycle.of_zpow","module":"Mathlib.GroupTheory.Perm.Cycle.Basic","initialProofState":"α : Type u_2\nf : Equiv.Perm α\nx y : α\nn : Int\na✝ : (HPow.hPow f n).SameCycle x y\n⊢ f.SameCycle x y","decl":"theorem SameCycle.of_zpow {n : ℤ} : SameCycle (f ^ n) x y → SameCycle f x y := fun ⟨m, h⟩ =>\n  ⟨n * m, by simp [zpow_mul, h]⟩\n\n"}
{"name":"Equiv.Perm.sameCycle_subtypePerm","module":"Mathlib.GroupTheory.Perm.Cycle.Basic","initialProofState":"α : Type u_2\nf : Equiv.Perm α\np : α → Prop\nh : ∀ (x : α), Iff (p x) (p (f x))\nx y : Subtype fun x => p x\n⊢ Iff ((f.subtypePerm h).SameCycle x y) (f.SameCycle ↑x ↑y)","decl":"@[simp]\ntheorem sameCycle_subtypePerm {h} {x y : { x // p x }} :\n    (f.subtypePerm h).SameCycle x y ↔ f.SameCycle x y :=\n  exists_congr fun n => by simp [Subtype.ext_iff]\n\n"}
{"name":"Equiv.Perm.SameCycle.subtypePerm","module":"Mathlib.GroupTheory.Perm.Cycle.Basic","initialProofState":"α : Type u_2\nf : Equiv.Perm α\np : α → Prop\nh : ∀ (x : α), Iff (p x) (p (f x))\nx y : Subtype fun x => p x\na✝ : f.SameCycle ↑x ↑y\n⊢ (f.subtypePerm h).SameCycle x y","decl":"alias ⟨_, SameCycle.subtypePerm⟩ := sameCycle_subtypePerm\n\n"}
{"name":"Equiv.Perm.sameCycle_extendDomain","module":"Mathlib.GroupTheory.Perm.Cycle.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ng : Equiv.Perm α\nx y : α\np : β → Prop\ninst✝ : DecidablePred p\nf : Equiv α (Subtype p)\n⊢ Iff ((g.extendDomain f).SameCycle ↑(f x) ↑(f y)) (g.SameCycle x y)","decl":"@[simp]\ntheorem sameCycle_extendDomain {p : β → Prop} [DecidablePred p] {f : α ≃ Subtype p} :\n    SameCycle (g.extendDomain f) (f x) (f y) ↔ g.SameCycle x y :=\n  exists_congr fun n => by\n    rw [← extendDomain_zpow, extendDomain_apply_image, Subtype.coe_inj, f.injective.eq_iff]\n\n"}
{"name":"Equiv.Perm.SameCycle.extendDomain","module":"Mathlib.GroupTheory.Perm.Cycle.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ng : Equiv.Perm α\nx y : α\np : β → Prop\ninst✝ : DecidablePred p\nf : Equiv α (Subtype p)\na✝ : g.SameCycle x y\n⊢ (g.extendDomain f).SameCycle ↑(f x) ↑(f y)","decl":"alias ⟨_, SameCycle.extendDomain⟩ := sameCycle_extendDomain\n\n"}
{"name":"Equiv.Perm.SameCycle.exists_pow_eq'","module":"Mathlib.GroupTheory.Perm.Cycle.Basic","initialProofState":"α : Type u_2\nf : Equiv.Perm α\nx y : α\ninst✝ : Finite α\na✝ : f.SameCycle x y\n⊢ Exists fun i => And (LT.lt i (orderOf f)) (Eq ((HPow.hPow f i) x) y)","decl":"theorem SameCycle.exists_pow_eq' [Finite α] : SameCycle f x y → ∃ i < orderOf f, (f ^ i) x = y := by\n  rintro ⟨k, rfl⟩\n  use (k % orderOf f).natAbs\n  have h₀ := Int.natCast_pos.mpr (orderOf_pos f)\n  have h₁ := Int.emod_nonneg k h₀.ne'\n  rw [← zpow_natCast, Int.natAbs_of_nonneg h₁, zpow_mod_orderOf]\n  refine ⟨?_, by rfl⟩\n  rw [← Int.ofNat_lt, Int.natAbs_of_nonneg h₁]\n  exact Int.emod_lt_of_pos _ h₀\n\n"}
{"name":"Equiv.Perm.SameCycle.exists_pow_eq''","module":"Mathlib.GroupTheory.Perm.Cycle.Basic","initialProofState":"α : Type u_2\nf : Equiv.Perm α\nx y : α\ninst✝ : Finite α\nh : f.SameCycle x y\n⊢ Exists fun i => And (LT.lt 0 i) (And (LE.le i (orderOf f)) (Eq ((HPow.hPow f i) x) y))","decl":"theorem SameCycle.exists_pow_eq'' [Finite α] (h : SameCycle f x y) :\n    ∃ i : ℕ, 0 < i ∧ i ≤ orderOf f ∧ (f ^ i) x = y := by\n  obtain ⟨_ | i, hi, rfl⟩ := h.exists_pow_eq'\n  · refine ⟨orderOf f, orderOf_pos f, le_rfl, ?_⟩\n    rw [pow_orderOf_eq_one, pow_zero]\n  · exact ⟨i.succ, i.zero_lt_succ, hi.le, by rfl⟩\n\n"}
{"name":"Equiv.Perm.SameCycle.exists_fin_pow_eq","module":"Mathlib.GroupTheory.Perm.Cycle.Basic","initialProofState":"α : Type u_2\nf : Equiv.Perm α\nx y : α\ninst✝ : Finite α\nh : f.SameCycle x y\n⊢ Exists fun i => Eq ((HPow.hPow f ↑i) x) y","decl":"theorem SameCycle.exists_fin_pow_eq [Finite α] (h : SameCycle f x y) :\n    ∃ i : Fin (orderOf f), (f ^ (i : ℕ)) x = y := by\n  obtain ⟨i, hi, hx⟩ := SameCycle.exists_pow_eq' h\n  exact ⟨⟨i, hi⟩, hx⟩\n\n"}
{"name":"Equiv.Perm.SameCycle.exists_nat_pow_eq","module":"Mathlib.GroupTheory.Perm.Cycle.Basic","initialProofState":"α : Type u_2\nf : Equiv.Perm α\nx y : α\ninst✝ : Finite α\nh : f.SameCycle x y\n⊢ Exists fun i => Eq ((HPow.hPow f i) x) y","decl":"theorem SameCycle.exists_nat_pow_eq [Finite α] (h : SameCycle f x y) :\n    ∃ i : ℕ, (f ^ i) x = y := by\n  obtain ⟨i, _, hi⟩ := h.exists_pow_eq'\n  exact ⟨i, hi⟩\n\n"}
{"name":"Equiv.Perm.IsCycle.ne_one","module":"Mathlib.GroupTheory.Perm.Cycle.Basic","initialProofState":"α : Type u_2\nf : Equiv.Perm α\nh : f.IsCycle\n⊢ Ne f 1","decl":"theorem IsCycle.ne_one (h : IsCycle f) : f ≠ 1 := fun hf => by simp [hf, IsCycle] at h\n\n"}
{"name":"Equiv.Perm.not_isCycle_one","module":"Mathlib.GroupTheory.Perm.Cycle.Basic","initialProofState":"α : Type u_2\n⊢ Not (Equiv.Perm.IsCycle 1)","decl":"@[simp]\ntheorem not_isCycle_one : ¬(1 : Perm α).IsCycle := fun H => H.ne_one rfl\n\n"}
{"name":"Equiv.Perm.IsCycle.sameCycle","module":"Mathlib.GroupTheory.Perm.Cycle.Basic","initialProofState":"α : Type u_2\nf : Equiv.Perm α\nx y : α\nhf : f.IsCycle\nhx : Ne (f x) x\nhy : Ne (f y) y\n⊢ f.SameCycle x y","decl":"protected theorem IsCycle.sameCycle (hf : IsCycle f) (hx : f x ≠ x) (hy : f y ≠ y) :\n    SameCycle f x y :=\n  let ⟨g, hg⟩ := hf\n  let ⟨a, ha⟩ := hg.2 hx\n  let ⟨b, hb⟩ := hg.2 hy\n  ⟨b - a, by rw [← ha, ← mul_apply, ← zpow_add, sub_add_cancel, hb]⟩\n\n"}
{"name":"Equiv.Perm.IsCycle.exists_zpow_eq","module":"Mathlib.GroupTheory.Perm.Cycle.Basic","initialProofState":"α : Type u_2\nf : Equiv.Perm α\nx y : α\na✝² : f.IsCycle\na✝¹ : Ne (f x) x\na✝ : Ne (f y) y\n⊢ Exists fun i => Eq ((HPow.hPow f i) x) y","decl":"theorem IsCycle.exists_zpow_eq : IsCycle f → f x ≠ x → f y ≠ y → ∃ i : ℤ, (f ^ i) x = y :=\n  IsCycle.sameCycle\n\n"}
{"name":"Equiv.Perm.IsCycle.inv","module":"Mathlib.GroupTheory.Perm.Cycle.Basic","initialProofState":"α : Type u_2\nf : Equiv.Perm α\nhf : f.IsCycle\n⊢ (Inv.inv f).IsCycle","decl":"theorem IsCycle.inv (hf : IsCycle f) : IsCycle f⁻¹ :=\n  hf.imp fun _ ⟨hx, h⟩ =>\n    ⟨inv_eq_iff_eq.not.2 hx.symm, fun _ hy => (h <| inv_eq_iff_eq.not.2 hy.symm).inv⟩\n\n"}
{"name":"Equiv.Perm.isCycle_inv","module":"Mathlib.GroupTheory.Perm.Cycle.Basic","initialProofState":"α : Type u_2\nf : Equiv.Perm α\n⊢ Iff (Inv.inv f).IsCycle f.IsCycle","decl":"@[simp]\ntheorem isCycle_inv : IsCycle f⁻¹ ↔ IsCycle f :=\n  ⟨fun h => h.inv, IsCycle.inv⟩\n\n"}
{"name":"Equiv.Perm.IsCycle.conj","module":"Mathlib.GroupTheory.Perm.Cycle.Basic","initialProofState":"α : Type u_2\nf g : Equiv.Perm α\na✝ : f.IsCycle\n⊢ (HMul.hMul (HMul.hMul g f) (Inv.inv g)).IsCycle","decl":"theorem IsCycle.conj : IsCycle f → IsCycle (g * f * g⁻¹) := by\n  rintro ⟨x, hx, h⟩\n  refine ⟨g x, by simp [coe_mul, inv_apply_self, hx], fun y hy => ?_⟩\n  rw [← apply_inv_self g y]\n  exact (h <| eq_inv_iff_eq.not.2 hy).conj\n\n"}
{"name":"Equiv.Perm.IsCycle.extendDomain","module":"Mathlib.GroupTheory.Perm.Cycle.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ng : Equiv.Perm α\np : β → Prop\ninst✝ : DecidablePred p\nf : Equiv α (Subtype p)\na✝ : g.IsCycle\n⊢ (g.extendDomain f).IsCycle","decl":"protected theorem IsCycle.extendDomain {p : β → Prop} [DecidablePred p] (f : α ≃ Subtype p) :\n    IsCycle g → IsCycle (g.extendDomain f) := by\n  rintro ⟨a, ha, ha'⟩\n  refine ⟨f a, ?_, fun b hb => ?_⟩\n  · rw [extendDomain_apply_image]\n    exact Subtype.coe_injective.ne (f.injective.ne ha)\n  have h : b = f (f.symm ⟨b, of_not_not <| hb ∘ extendDomain_apply_not_subtype _ _⟩) := by\n    rw [apply_symm_apply, Subtype.coe_mk]\n  rw [h] at hb ⊢\n  simp only [extendDomain_apply_image, Subtype.coe_injective.ne_iff, f.injective.ne_iff] at hb\n  exact (ha' hb).extendDomain\n\n"}
{"name":"Equiv.Perm.isCycle_iff_sameCycle","module":"Mathlib.GroupTheory.Perm.Cycle.Basic","initialProofState":"α : Type u_2\nf : Equiv.Perm α\nx : α\nhx : Ne (f x) x\n⊢ Iff f.IsCycle (∀ {y : α}, Iff (f.SameCycle x y) (Ne (f y) y))","decl":"theorem isCycle_iff_sameCycle (hx : f x ≠ x) : IsCycle f ↔ ∀ {y}, SameCycle f x y ↔ f y ≠ y :=\n  ⟨fun hf y =>\n    ⟨fun ⟨i, hi⟩ hy =>\n      hx <| by\n        rw [← zpow_apply_eq_self_of_apply_eq_self hy i, (f ^ i).injective.eq_iff] at hi\n        rw [hi, hy],\n      hf.exists_zpow_eq hx⟩,\n    fun h => ⟨x, hx, fun _ hy => h.2 hy⟩⟩\n\n"}
{"name":"Equiv.Perm.IsCycle.exists_pow_eq","module":"Mathlib.GroupTheory.Perm.Cycle.Basic","initialProofState":"α : Type u_2\nf : Equiv.Perm α\nx y : α\ninst✝ : Finite α\nhf : f.IsCycle\nhx : Ne (f x) x\nhy : Ne (f y) y\n⊢ Exists fun i => Eq ((HPow.hPow f i) x) y","decl":"theorem IsCycle.exists_pow_eq (hf : IsCycle f) (hx : f x ≠ x) (hy : f y ≠ y) :\n    ∃ i : ℕ, (f ^ i) x = y := by\n  let ⟨n, hn⟩ := hf.exists_zpow_eq hx hy\n  classical exact\n      ⟨(n % orderOf f).toNat, by\n        {have := n.emod_nonneg (Int.natCast_ne_zero.mpr (ne_of_gt (orderOf_pos f)))\n         rwa [← zpow_natCast, Int.toNat_of_nonneg this, zpow_mod_orderOf]}⟩\n\n"}
{"name":"Equiv.Perm.isCycle_swap","module":"Mathlib.GroupTheory.Perm.Cycle.Basic","initialProofState":"α : Type u_2\nx y : α\ninst✝ : DecidableEq α\nhxy : Ne x y\n⊢ (Equiv.swap x y).IsCycle","decl":"theorem isCycle_swap (hxy : x ≠ y) : IsCycle (swap x y) :=\n  ⟨y, by rwa [swap_apply_right], fun a (ha : ite (a = x) y (ite (a = y) x a) ≠ a) =>\n    if hya : y = a then ⟨0, hya⟩\n    else\n      ⟨1, by\n        rw [zpow_one, swap_apply_def]\n        split_ifs at * <;> tauto⟩⟩\n\n"}
{"name":"Equiv.Perm.IsSwap.isCycle","module":"Mathlib.GroupTheory.Perm.Cycle.Basic","initialProofState":"α : Type u_2\nf : Equiv.Perm α\ninst✝ : DecidableEq α\na✝ : f.IsSwap\n⊢ f.IsCycle","decl":"protected theorem IsSwap.isCycle : IsSwap f → IsCycle f := by\n  rintro ⟨x, y, hxy, rfl⟩\n  exact isCycle_swap hxy\n\n"}
{"name":"Equiv.Perm.IsCycle.two_le_card_support","module":"Mathlib.GroupTheory.Perm.Cycle.Basic","initialProofState":"α : Type u_2\nf : Equiv.Perm α\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\nh : f.IsCycle\n⊢ LE.le 2 f.support.card","decl":"theorem IsCycle.two_le_card_support (h : IsCycle f) : 2 ≤ #f.support :=\n  two_le_card_support_of_ne_one h.ne_one\n\n"}
{"name":"Equiv.Perm.IsCycle.zpowersEquivSupport_apply","module":"Mathlib.GroupTheory.Perm.Cycle.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\nσ : Equiv.Perm α\nhσ : σ.IsCycle\nn : Nat\n⊢ Eq (hσ.zpowersEquivSupport ⟨HPow.hPow σ n, ⋯⟩) ⟨(HPow.hPow σ n) (Classical.choose hσ), ⋯⟩","decl":"@[simp]\ntheorem IsCycle.zpowersEquivSupport_apply {σ : Perm α} (hσ : IsCycle σ) {n : ℕ} :\n    hσ.zpowersEquivSupport ⟨σ ^ n, n, rfl⟩ =\n      ⟨(σ ^ n) (Classical.choose hσ),\n        pow_apply_mem_support.2 (mem_support.2 (Classical.choose_spec hσ).1)⟩ :=\n  rfl\n\n"}
{"name":"Equiv.Perm.IsCycle.zpowersEquivSupport_symm_apply","module":"Mathlib.GroupTheory.Perm.Cycle.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\nσ : Equiv.Perm α\nhσ : σ.IsCycle\nn : Nat\n⊢ Eq (hσ.zpowersEquivSupport.symm ⟨(HPow.hPow σ n) (Classical.choose hσ), ⋯⟩) ⟨HPow.hPow σ n, ⋯⟩","decl":"@[simp]\ntheorem IsCycle.zpowersEquivSupport_symm_apply {σ : Perm α} (hσ : IsCycle σ) (n : ℕ) :\n    hσ.zpowersEquivSupport.symm\n        ⟨(σ ^ n) (Classical.choose hσ),\n          pow_apply_mem_support.2 (mem_support.2 (Classical.choose_spec hσ).1)⟩ =\n      ⟨σ ^ n, n, rfl⟩ :=\n  (Equiv.symm_apply_eq _).2 hσ.zpowersEquivSupport_apply\n\n"}
{"name":"Equiv.Perm.IsCycle.orderOf","module":"Mathlib.GroupTheory.Perm.Cycle.Basic","initialProofState":"α : Type u_2\nf : Equiv.Perm α\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\nhf : f.IsCycle\n⊢ Eq (orderOf f) f.support.card","decl":"protected theorem IsCycle.orderOf (hf : IsCycle f) : orderOf f = #f.support := by\n  rw [← Fintype.card_zpowers, ← Fintype.card_coe]\n  convert Fintype.card_congr (IsCycle.zpowersEquivSupport hf)\n\n"}
{"name":"Equiv.Perm.isCycle_swap_mul_aux₁","module":"Mathlib.GroupTheory.Perm.Cycle.Basic","initialProofState":"α : Type u_4\ninst✝ : DecidableEq α\nn : Nat\nb x : α\nf : Equiv.Perm α\nx✝¹ : Ne ((HMul.hMul (Equiv.swap x (f x)) f) b) b\nx✝ : Eq ((HPow.hPow f n) (f x)) b\n⊢ Exists fun i => Eq ((HPow.hPow (HMul.hMul (Equiv.swap x (f x)) f) i) (f x)) b","decl":"theorem isCycle_swap_mul_aux₁ {α : Type*} [DecidableEq α] :\n    ∀ (n : ℕ) {b x : α} {f : Perm α} (_ : (swap x (f x) * f) b ≠ b) (_ : (f ^ n) (f x) = b),\n      ∃ i : ℤ, ((swap x (f x) * f) ^ i) (f x) = b := by\n  intro n\n  induction n with\n  | zero => exact fun _ h => ⟨0, h⟩\n  | succ n hn =>\n    intro b x f hb h\n    exact if hfbx : f x = b then ⟨0, hfbx⟩\n      else\n        have : f b ≠ b ∧ b ≠ x := ne_and_ne_of_swap_mul_apply_ne_self hb\n        have hb' : (swap x (f x) * f) (f⁻¹ b) ≠ f⁻¹ b := by\n          rw [mul_apply, apply_inv_self, swap_apply_of_ne_of_ne this.2 (Ne.symm hfbx), Ne, ←\n            f.injective.eq_iff, apply_inv_self]\n          exact this.1\n        let ⟨i, hi⟩ := hn hb' (f.injective <| by\n          rw [apply_inv_self]; rwa [pow_succ', mul_apply] at h)\n        ⟨i + 1, by\n          rw [add_comm, zpow_add, mul_apply, hi, zpow_one, mul_apply, apply_inv_self,\n            swap_apply_of_ne_of_ne (ne_and_ne_of_swap_mul_apply_ne_self hb).2 (Ne.symm hfbx)]⟩\n\n"}
{"name":"Equiv.Perm.isCycle_swap_mul_aux₂","module":"Mathlib.GroupTheory.Perm.Cycle.Basic","initialProofState":"α : Type u_4\ninst✝ : DecidableEq α\nn : Int\nb x : α\nf : Equiv.Perm α\nx✝¹ : Ne ((HMul.hMul (Equiv.swap x (f x)) f) b) b\nx✝ : Eq ((HPow.hPow f n) (f x)) b\n⊢ Exists fun i => Eq ((HPow.hPow (HMul.hMul (Equiv.swap x (f x)) f) i) (f x)) b","decl":"theorem isCycle_swap_mul_aux₂ {α : Type*} [DecidableEq α] :\n    ∀ (n : ℤ) {b x : α} {f : Perm α} (_ : (swap x (f x) * f) b ≠ b) (_ : (f ^ n) (f x) = b),\n      ∃ i : ℤ, ((swap x (f x) * f) ^ i) (f x) = b := by\n  intro n\n  induction n with\n  | ofNat n => exact isCycle_swap_mul_aux₁ n\n  | negSucc n =>\n    intro b x f hb h\n    exact if hfbx' : f x = b then ⟨0, hfbx'⟩\n      else\n        have : f b ≠ b ∧ b ≠ x := ne_and_ne_of_swap_mul_apply_ne_self hb\n        have hb : (swap x (f⁻¹ x) * f⁻¹) (f⁻¹ b) ≠ f⁻¹ b := by\n          rw [mul_apply, swap_apply_def]\n          split_ifs <;>\n            simp only [inv_eq_iff_eq, Perm.mul_apply, zpow_negSucc, Ne, Perm.apply_inv_self] at *\n              <;> tauto\n        let ⟨i, hi⟩ :=\n          isCycle_swap_mul_aux₁ n hb\n            (show (f⁻¹ ^ n) (f⁻¹ x) = f⁻¹ b by\n              rw [← zpow_natCast, ← h, ← mul_apply, ← mul_apply, ← mul_apply, zpow_negSucc,\n                ← inv_pow, pow_succ, mul_assoc, mul_assoc, inv_mul_cancel, mul_one, zpow_natCast,\n                ← pow_succ', ← pow_succ])\n        have h : (swap x (f⁻¹ x) * f⁻¹) (f x) = f⁻¹ x := by\n          rw [mul_apply, inv_apply_self, swap_apply_left]\n        ⟨-i, by\n          rw [← add_sub_cancel_right i 1, neg_sub, sub_eq_add_neg, zpow_add, zpow_one, zpow_neg,\n            ← inv_zpow, mul_inv_rev, swap_inv, mul_swap_eq_swap_mul, inv_apply_self, swap_comm _ x,\n            zpow_add, zpow_one, mul_apply, mul_apply (_ ^ i), h, hi, mul_apply, apply_inv_self,\n            swap_apply_of_ne_of_ne this.2 (Ne.symm hfbx')]⟩\n\n"}
{"name":"Equiv.Perm.IsCycle.eq_swap_of_apply_apply_eq_self","module":"Mathlib.GroupTheory.Perm.Cycle.Basic","initialProofState":"α : Type u_4\ninst✝ : DecidableEq α\nf : Equiv.Perm α\nhf : f.IsCycle\nx : α\nhfx : Ne (f x) x\nhffx : Eq (f (f x)) x\n⊢ Eq f (Equiv.swap x (f x))","decl":"theorem IsCycle.eq_swap_of_apply_apply_eq_self {α : Type*} [DecidableEq α] {f : Perm α}\n    (hf : IsCycle f) {x : α} (hfx : f x ≠ x) (hffx : f (f x) = x) : f = swap x (f x) :=\n  Equiv.ext fun y =>\n    let ⟨z, hz⟩ := hf\n    let ⟨i, hi⟩ := hz.2 hfx\n    if hyx : y = x then by simp [hyx]\n    else\n      if hfyx : y = f x then by simp [hfyx, hffx]\n      else by\n        rw [swap_apply_of_ne_of_ne hyx hfyx]\n        refine by_contradiction fun hy => ?_\n        cases' hz.2 hy with j hj\n        rw [← sub_add_cancel j i, zpow_add, mul_apply, hi] at hj\n        cases' zpow_apply_eq_of_apply_apply_eq_self hffx (j - i) with hji hji\n        · rw [← hj, hji] at hyx\n          tauto\n        · rw [← hj, hji] at hfyx\n          tauto\n\n"}
{"name":"Equiv.Perm.IsCycle.swap_mul","module":"Mathlib.GroupTheory.Perm.Cycle.Basic","initialProofState":"α : Type u_4\ninst✝ : DecidableEq α\nf : Equiv.Perm α\nhf : f.IsCycle\nx : α\nhx : Ne (f x) x\nhffx : Ne (f (f x)) x\n⊢ (HMul.hMul (Equiv.swap x (f x)) f).IsCycle","decl":"theorem IsCycle.swap_mul {α : Type*} [DecidableEq α] {f : Perm α} (hf : IsCycle f) {x : α}\n    (hx : f x ≠ x) (hffx : f (f x) ≠ x) : IsCycle (swap x (f x) * f) :=\n  ⟨f x, by simp [swap_apply_def, mul_apply, if_neg hffx, f.injective.eq_iff, if_neg hx, hx],\n    fun y hy =>\n    let ⟨i, hi⟩ := hf.exists_zpow_eq hx (ne_and_ne_of_swap_mul_apply_ne_self hy).1\n    -- Porting note: Needed to add Perm α typehint, otherwise does not know how to coerce to fun\n    have hi : (f ^ (i - 1) : Perm α) (f x) = y :=\n      calc\n        (f ^ (i - 1) : Perm α) (f x) = (f ^ (i - 1) * f ^ (1 : ℤ) : Perm α) x := by simp\n        _ = y := by rwa [← zpow_add, sub_add_cancel]\n\n    isCycle_swap_mul_aux₂ (i - 1) hy hi⟩\n\n"}
{"name":"Equiv.Perm.IsCycle.sign","module":"Mathlib.GroupTheory.Perm.Cycle.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\nf : Equiv.Perm α\nhf : f.IsCycle\n⊢ Eq (Equiv.Perm.sign f) (Neg.neg (HPow.hPow (-1) f.support.card))","decl":"theorem IsCycle.sign {f : Perm α} (hf : IsCycle f) : sign f = -(-1) ^ #f.support :=\n  let ⟨x, hx⟩ := hf\n  calc\n    Perm.sign f = Perm.sign (swap x (f x) * (swap x (f x) * f)) := by\n      {rw [← mul_assoc, mul_def, mul_def, swap_swap, trans_refl]}\n    _ = -(-1) ^ #f.support :=\n      if h1 : f (f x) = x then by\n        have h : swap x (f x) * f = 1 := by\n          simp only [mul_def, one_def]\n          rw [hf.eq_swap_of_apply_apply_eq_self hx.1 h1, swap_apply_left, swap_swap]\n        rw [sign_mul, sign_swap hx.1.symm, h, sign_one,\n          hf.eq_swap_of_apply_apply_eq_self hx.1 h1, card_support_swap hx.1.symm]\n        rfl\n      else by\n        have h : #(swap x (f x) * f).support + 1 = #f.support := by\n          rw [← insert_erase (mem_support.2 hx.1), support_swap_mul_eq _ _ h1,\n            card_insert_of_not_mem (not_mem_erase _ _), sdiff_singleton_eq_erase]\n        have : #(swap x (f x) * f).support < #f.support := card_support_swap_mul hx.1\n        rw [sign_mul, sign_swap hx.1.symm, (hf.swap_mul hx.1 h1).sign, ← h]\n        simp only [mul_neg, neg_mul, one_mul, neg_neg, pow_add, pow_one, mul_one]\ntermination_by #f.support\n\n"}
{"name":"Equiv.Perm.IsCycle.of_pow","module":"Mathlib.GroupTheory.Perm.Cycle.Basic","initialProofState":"α : Type u_2\nf : Equiv.Perm α\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\nn : Nat\nh1 : (HPow.hPow f n).IsCycle\nh2 : HasSubset.Subset f.support (HPow.hPow f n).support\n⊢ f.IsCycle","decl":"theorem IsCycle.of_pow {n : ℕ} (h1 : IsCycle (f ^ n)) (h2 : f.support ⊆ (f ^ n).support) :\n    IsCycle f := by\n  have key : ∀ x : α, (f ^ n) x ≠ x ↔ f x ≠ x := by\n    simp_rw [← mem_support, ← Finset.ext_iff]\n    exact (support_pow_le _ n).antisymm h2\n  obtain ⟨x, hx1, hx2⟩ := h1\n  refine ⟨x, (key x).mp hx1, fun y hy => ?_⟩\n  cases' hx2 ((key y).mpr hy) with i _\n  exact ⟨n * i, by rwa [zpow_mul]⟩\n\n-- The lemma `support_zpow_le` is relevant. It means that `h2` is equivalent to\n-- `σ.support = (σ ^ n).support`, as well as to `#σ.support ≤ #(σ ^ n).support`.\n"}
{"name":"Equiv.Perm.IsCycle.of_zpow","module":"Mathlib.GroupTheory.Perm.Cycle.Basic","initialProofState":"α : Type u_2\nf : Equiv.Perm α\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\nn : Int\nh1 : (HPow.hPow f n).IsCycle\nh2 : HasSubset.Subset f.support (HPow.hPow f n).support\n⊢ f.IsCycle","decl":"theorem IsCycle.of_zpow {n : ℤ} (h1 : IsCycle (f ^ n)) (h2 : f.support ⊆ (f ^ n).support) :\n    IsCycle f := by\n  cases n\n  · exact h1.of_pow h2\n  · simp only [le_eq_subset, zpow_negSucc, Perm.support_inv] at h1 h2\n    exact (inv_inv (f ^ _) ▸ h1.inv).of_pow h2\n\n"}
{"name":"Equiv.Perm.nodup_of_pairwise_disjoint_cycles","module":"Mathlib.GroupTheory.Perm.Cycle.Basic","initialProofState":"β : Type u_3\nl : List (Equiv.Perm β)\nh1 : ∀ (f : Equiv.Perm β), Membership.mem l f → f.IsCycle\nh2 : List.Pairwise Equiv.Perm.Disjoint l\n⊢ l.Nodup","decl":"theorem nodup_of_pairwise_disjoint_cycles {l : List (Perm β)} (h1 : ∀ f ∈ l, IsCycle f)\n    (h2 : l.Pairwise Disjoint) : l.Nodup :=\n  nodup_of_pairwise_disjoint (fun h => (h1 1 h).ne_one rfl) h2\n\n"}
{"name":"Equiv.Perm.IsCycle.support_congr","module":"Mathlib.GroupTheory.Perm.Cycle.Basic","initialProofState":"α : Type u_2\nf g : Equiv.Perm α\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\nhf : f.IsCycle\nhg : g.IsCycle\nh : HasSubset.Subset f.support g.support\nh' : ∀ (x : α), Membership.mem f.support x → Eq (f x) (g x)\n⊢ Eq f g","decl":"/-- Unlike `support_congr`, which assumes that `∀ (x ∈ g.support), f x = g x)`, here\nwe have the weaker assumption that `∀ (x ∈ f.support), f x = g x`. -/\ntheorem IsCycle.support_congr (hf : IsCycle f) (hg : IsCycle g) (h : f.support ⊆ g.support)\n    (h' : ∀ x ∈ f.support, f x = g x) : f = g := by\n  have : f.support = g.support := by\n    refine le_antisymm h ?_\n    intro z hz\n    obtain ⟨x, hx, _⟩ := id hf\n    have hx' : g x ≠ x := by rwa [← h' x (mem_support.mpr hx)]\n    obtain ⟨m, hm⟩ := hg.exists_pow_eq hx' (mem_support.mp hz)\n    have h'' : ∀ x ∈ f.support ∩ g.support, f x = g x := by\n      intro x hx\n      exact h' x (mem_of_mem_inter_left hx)\n    rwa [← hm, ←\n      pow_eq_on_of_mem_support h'' _ x\n        (mem_inter_of_mem (mem_support.mpr hx) (mem_support.mpr hx')),\n      pow_apply_mem_support, mem_support]\n  refine Equiv.Perm.support_congr h ?_\n  simpa [← this] using h'\n\n"}
{"name":"Equiv.Perm.IsCycle.eq_on_support_inter_nonempty_congr","module":"Mathlib.GroupTheory.Perm.Cycle.Basic","initialProofState":"α : Type u_2\nf g : Equiv.Perm α\nx : α\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\nhf : f.IsCycle\nhg : g.IsCycle\nh : ∀ (x : α), Membership.mem (Inter.inter f.support g.support) x → Eq (f x) (g x)\nhx : Eq (f x) (g x)\nhx' : Membership.mem f.support x\n⊢ Eq f g","decl":"/-- If two cyclic permutations agree on all terms in their intersection,\nand that intersection is not empty, then the two cyclic permutations must be equal. -/\ntheorem IsCycle.eq_on_support_inter_nonempty_congr (hf : IsCycle f) (hg : IsCycle g)\n    (h : ∀ x ∈ f.support ∩ g.support, f x = g x)\n    (hx : f x = g x) (hx' : x ∈ f.support) : f = g := by\n  have hx'' : x ∈ g.support := by rwa [mem_support, ← hx, ← mem_support]\n  have : f.support ⊆ g.support := by\n    intro y hy\n    obtain ⟨k, rfl⟩ := hf.exists_pow_eq (mem_support.mp hx') (mem_support.mp hy)\n    rwa [pow_eq_on_of_mem_support h _ _ (mem_inter_of_mem hx' hx''), pow_apply_mem_support]\n  rw [inter_eq_left.mpr this] at h\n  exact hf.support_congr hg this h\n\n"}
{"name":"Equiv.Perm.IsCycle.support_pow_eq_iff","module":"Mathlib.GroupTheory.Perm.Cycle.Basic","initialProofState":"α : Type u_2\nf : Equiv.Perm α\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\nhf : f.IsCycle\nn : Nat\n⊢ Iff (Eq (HPow.hPow f n).support f.support) (Not (Dvd.dvd (orderOf f) n))","decl":"theorem IsCycle.support_pow_eq_iff (hf : IsCycle f) {n : ℕ} :\n    support (f ^ n) = support f ↔ ¬orderOf f ∣ n := by\n  rw [orderOf_dvd_iff_pow_eq_one]\n  constructor\n  · intro h H\n    refine hf.ne_one ?_\n    rw [← support_eq_empty_iff, ← h, H, support_one]\n  · intro H\n    apply le_antisymm (support_pow_le _ n) _\n    intro x hx\n    contrapose! H\n    ext z\n    by_cases hz : f z = z\n    · rw [pow_apply_eq_self_of_apply_eq_self hz, one_apply]\n    · obtain ⟨k, rfl⟩ := hf.exists_pow_eq hz (mem_support.mp hx)\n      apply (f ^ k).injective\n      rw [← mul_apply, (Commute.pow_pow_self _ _ _).eq, mul_apply]\n      simpa using H\n\n"}
{"name":"Equiv.Perm.IsCycle.support_pow_of_pos_of_lt_orderOf","module":"Mathlib.GroupTheory.Perm.Cycle.Basic","initialProofState":"α : Type u_2\nf : Equiv.Perm α\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\nhf : f.IsCycle\nn : Nat\nnpos : LT.lt 0 n\nhn : LT.lt n (orderOf f)\n⊢ Eq (HPow.hPow f n).support f.support","decl":"theorem IsCycle.support_pow_of_pos_of_lt_orderOf (hf : IsCycle f) {n : ℕ} (npos : 0 < n)\n    (hn : n < orderOf f) : (f ^ n).support = f.support :=\n  hf.support_pow_eq_iff.2 <| Nat.not_dvd_of_pos_of_lt npos hn\n\n"}
{"name":"Equiv.Perm.IsCycle.pow_iff","module":"Mathlib.GroupTheory.Perm.Cycle.Basic","initialProofState":"β : Type u_3\ninst✝ : Finite β\nf : Equiv.Perm β\nhf : f.IsCycle\nn : Nat\n⊢ Iff (HPow.hPow f n).IsCycle (n.Coprime (orderOf f))","decl":"theorem IsCycle.pow_iff [Finite β] {f : Perm β} (hf : IsCycle f) {n : ℕ} :\n    IsCycle (f ^ n) ↔ n.Coprime (orderOf f) := by\n  classical\n    cases nonempty_fintype β\n    constructor\n    · intro h\n      have hr : support (f ^ n) = support f := by\n        rw [hf.support_pow_eq_iff]\n        rintro ⟨k, rfl⟩\n        refine h.ne_one ?_\n        simp [pow_mul, pow_orderOf_eq_one]\n      have : orderOf (f ^ n) = orderOf f := by rw [h.orderOf, hr, hf.orderOf]\n      rw [orderOf_pow, Nat.div_eq_self] at this\n      cases' this with h\n      · exact absurd h (orderOf_pos _).ne'\n      · rwa [Nat.coprime_iff_gcd_eq_one, Nat.gcd_comm]\n    · intro h\n      obtain ⟨m, hm⟩ := exists_pow_eq_self_of_coprime h\n      have hf' : IsCycle ((f ^ n) ^ m) := by rwa [hm]\n      refine hf'.of_pow fun x hx => ?_\n      rw [hm]\n      exact support_pow_le _ n hx\n\n-- TODO: Define a `Set`-valued support to get rid of the `Finite β` assumption\n"}
{"name":"Equiv.Perm.IsCycle.pow_eq_one_iff","module":"Mathlib.GroupTheory.Perm.Cycle.Basic","initialProofState":"β : Type u_3\ninst✝ : Finite β\nf : Equiv.Perm β\nhf : f.IsCycle\nn : Nat\n⊢ Iff (Eq (HPow.hPow f n) 1) (Exists fun x => And (Ne (f x) x) (Eq ((HPow.hPow f n) x) x))","decl":"theorem IsCycle.pow_eq_one_iff [Finite β] {f : Perm β} (hf : IsCycle f) {n : ℕ} :\n    f ^ n = 1 ↔ ∃ x, f x ≠ x ∧ (f ^ n) x = x := by\n  classical\n    cases nonempty_fintype β\n    constructor\n    · intro h\n      obtain ⟨x, hx, -⟩ := id hf\n      exact ⟨x, hx, by simp [h]⟩\n    · rintro ⟨x, hx, hx'⟩\n      by_cases h : support (f ^ n) = support f\n      · rw [← mem_support, ← h, mem_support] at hx\n        contradiction\n      · rw [hf.support_pow_eq_iff, Classical.not_not] at h\n        obtain ⟨k, rfl⟩ := h\n        rw [pow_mul, pow_orderOf_eq_one, one_pow]\n\n-- TODO: Define a `Set`-valued support to get rid of the `Finite β` assumption\n"}
{"name":"Equiv.Perm.IsCycle.pow_eq_one_iff'","module":"Mathlib.GroupTheory.Perm.Cycle.Basic","initialProofState":"β : Type u_3\ninst✝ : Finite β\nf : Equiv.Perm β\nhf : f.IsCycle\nn : Nat\nx : β\nhx : Ne (f x) x\n⊢ Iff (Eq (HPow.hPow f n) 1) (Eq ((HPow.hPow f n) x) x)","decl":"theorem IsCycle.pow_eq_one_iff' [Finite β] {f : Perm β} (hf : IsCycle f) {n : ℕ} {x : β}\n    (hx : f x ≠ x) : f ^ n = 1 ↔ (f ^ n) x = x :=\n  ⟨fun h => DFunLike.congr_fun h x, fun h => hf.pow_eq_one_iff.2 ⟨x, hx, h⟩⟩\n\n-- TODO: Define a `Set`-valued support to get rid of the `Finite β` assumption\n"}
{"name":"Equiv.Perm.IsCycle.pow_eq_one_iff''","module":"Mathlib.GroupTheory.Perm.Cycle.Basic","initialProofState":"β : Type u_3\ninst✝ : Finite β\nf : Equiv.Perm β\nhf : f.IsCycle\nn : Nat\n⊢ Iff (Eq (HPow.hPow f n) 1) (∀ (x : β), Ne (f x) x → Eq ((HPow.hPow f n) x) x)","decl":"theorem IsCycle.pow_eq_one_iff'' [Finite β] {f : Perm β} (hf : IsCycle f) {n : ℕ} :\n    f ^ n = 1 ↔ ∀ x, f x ≠ x → (f ^ n) x = x :=\n  ⟨fun h _ hx => (hf.pow_eq_one_iff' hx).1 h, fun h =>\n    let ⟨_, hx, _⟩ := id hf\n    (hf.pow_eq_one_iff' hx).2 (h _ hx)⟩\n\n-- TODO: Define a `Set`-valued support to get rid of the `Finite β` assumption\n"}
{"name":"Equiv.Perm.IsCycle.pow_eq_pow_iff","module":"Mathlib.GroupTheory.Perm.Cycle.Basic","initialProofState":"β : Type u_3\ninst✝ : Finite β\nf : Equiv.Perm β\nhf : f.IsCycle\na b : Nat\n⊢ Iff (Eq (HPow.hPow f a) (HPow.hPow f b)) (Exists fun x => And (Ne (f x) x) (Eq ((HPow.hPow f a) x) ((HPow.hPow f b) x)))","decl":"theorem IsCycle.pow_eq_pow_iff [Finite β] {f : Perm β} (hf : IsCycle f) {a b : ℕ} :\n    f ^ a = f ^ b ↔ ∃ x, f x ≠ x ∧ (f ^ a) x = (f ^ b) x := by\n  classical\n    cases nonempty_fintype β\n    constructor\n    · intro h\n      obtain ⟨x, hx, -⟩ := id hf\n      exact ⟨x, hx, by simp [h]⟩\n    · rintro ⟨x, hx, hx'⟩\n      wlog hab : a ≤ b generalizing a b\n      · exact (this hx'.symm (le_of_not_le hab)).symm\n      suffices f ^ (b - a) = 1 by\n        rw [pow_sub _ hab, mul_inv_eq_one] at this\n        rw [this]\n      rw [hf.pow_eq_one_iff]\n      by_cases hfa : (f ^ a) x ∈ f.support\n      · refine ⟨(f ^ a) x, mem_support.mp hfa, ?_⟩\n        simp only [pow_sub _ hab, Equiv.Perm.coe_mul, Function.comp_apply, inv_apply_self, ← hx']\n      · have h := @Equiv.Perm.zpow_apply_comm _ f 1 a x\n        simp only [zpow_one, zpow_natCast] at h\n        rw [not_mem_support, h, Function.Injective.eq_iff (f ^ a).injective] at hfa\n        contradiction\n\n"}
{"name":"Equiv.Perm.IsCycle.isCycle_pow_pos_of_lt_prime_order","module":"Mathlib.GroupTheory.Perm.Cycle.Basic","initialProofState":"β : Type u_3\ninst✝ : Finite β\nf : Equiv.Perm β\nhf : f.IsCycle\nhf' : Nat.Prime (orderOf f)\nn : Nat\nhn : LT.lt 0 n\nhn' : LT.lt n (orderOf f)\n⊢ (HPow.hPow f n).IsCycle","decl":"theorem IsCycle.isCycle_pow_pos_of_lt_prime_order [Finite β] {f : Perm β} (hf : IsCycle f)\n    (hf' : (orderOf f).Prime) (n : ℕ) (hn : 0 < n) (hn' : n < orderOf f) : IsCycle (f ^ n) := by\n  classical\n    cases nonempty_fintype β\n    have : n.Coprime (orderOf f) := by\n      refine Nat.Coprime.symm ?_\n      rw [Nat.Prime.coprime_iff_not_dvd hf']\n      exact Nat.not_dvd_of_pos_of_lt hn hn'\n    obtain ⟨m, hm⟩ := exists_pow_eq_self_of_coprime this\n    have hf'' := hf\n    rw [← hm] at hf''\n    refine hf''.of_pow ?_\n    rw [hm]\n    exact support_pow_le f n\n\n"}
{"name":"Int.addLeft_one_isCycle","module":"Mathlib.GroupTheory.Perm.Cycle.Basic","initialProofState":"⊢ (Equiv.addLeft 1).IsCycle","decl":"theorem _root_.Int.addLeft_one_isCycle : (Equiv.addLeft 1 : Perm ℤ).IsCycle :=\n  ⟨0, one_ne_zero, fun n _ => ⟨n, by simp⟩⟩\n\n"}
{"name":"Int.addRight_one_isCycle","module":"Mathlib.GroupTheory.Perm.Cycle.Basic","initialProofState":"⊢ (Equiv.addRight 1).IsCycle","decl":"theorem _root_.Int.addRight_one_isCycle : (Equiv.addRight 1 : Perm ℤ).IsCycle :=\n  ⟨0, one_ne_zero, fun n _ => ⟨n, by simp⟩⟩\n\n"}
{"name":"Equiv.Perm.IsCycle.isConj","module":"Mathlib.GroupTheory.Perm.Cycle.Basic","initialProofState":"α : Type u_2\ninst✝¹ : Fintype α\ninst✝ : DecidableEq α\nσ τ : Equiv.Perm α\nhσ : σ.IsCycle\nhτ : τ.IsCycle\nh : Eq σ.support.card τ.support.card\n⊢ IsConj σ τ","decl":"theorem IsCycle.isConj (hσ : IsCycle σ) (hτ : IsCycle τ) (h : #σ.support = #τ.support) :\n    IsConj σ τ := by\n  refine\n    isConj_of_support_equiv\n      (hσ.zpowersEquivSupport.symm.trans <|\n        (zpowersEquivZPowers <| by rw [hσ.orderOf, h, hτ.orderOf]).trans hτ.zpowersEquivSupport)\n      ?_\n  intro x hx\n  simp only [Perm.mul_apply, Equiv.trans_apply, Equiv.sumCongr_apply]\n  obtain ⟨n, rfl⟩ := hσ.exists_pow_eq (Classical.choose_spec hσ).1 (mem_support.1 hx)\n  erw [hσ.zpowersEquivSupport_symm_apply n]\n  simp only [← Perm.mul_apply, ← pow_succ']\n  erw [hσ.zpowersEquivSupport_symm_apply (n + 1)]\n  -- This used to be a `simp only` before https://github.com/leanprover/lean4/pull/2644\n  erw [zpowersEquivZPowers_apply, zpowersEquivZPowers_apply, zpowersEquivSupport_apply]\n  -- This used to be `rw`, but we need `erw` after https://github.com/leanprover/lean4/pull/2644\n  simp_rw [pow_succ', Perm.mul_apply]\n  rfl\n\n"}
{"name":"Equiv.Perm.IsCycle.isConj_iff","module":"Mathlib.GroupTheory.Perm.Cycle.Basic","initialProofState":"α : Type u_2\ninst✝¹ : Fintype α\ninst✝ : DecidableEq α\nσ τ : Equiv.Perm α\nhσ : σ.IsCycle\nhτ : τ.IsCycle\n⊢ Iff (IsConj σ τ) (Eq σ.support.card τ.support.card)","decl":"theorem IsCycle.isConj_iff (hσ : IsCycle σ) (hτ : IsCycle τ) :\n    IsConj σ τ ↔ #σ.support = #τ.support where\n  mp h := by\n    obtain ⟨π, rfl⟩ := (_root_.isConj_iff).1 h\n    refine Finset.card_bij (fun a _ => π a) (fun _ ha => ?_) (fun _ _ _ _ ab => π.injective ab)\n        fun b hb ↦ ⟨π⁻¹ b, ?_, π.apply_inv_self b⟩\n    · simp [mem_support.1 ha]\n    contrapose! hb\n    rw [mem_support, Classical.not_not] at hb\n    rw [mem_support, Classical.not_not, Perm.mul_apply, Perm.mul_apply, hb, Perm.apply_inv_self]\n  mpr := hσ.isConj hτ\n\n"}
{"name":"Equiv.Perm.isCycleOn_empty","module":"Mathlib.GroupTheory.Perm.Cycle.Basic","initialProofState":"α : Type u_2\nf : Equiv.Perm α\n⊢ f.IsCycleOn EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem isCycleOn_empty : f.IsCycleOn ∅ := by simp [IsCycleOn, Set.bijOn_empty]\n\n"}
{"name":"Equiv.Perm.isCycleOn_one","module":"Mathlib.GroupTheory.Perm.Cycle.Basic","initialProofState":"α : Type u_2\ns : Set α\n⊢ Iff (Equiv.Perm.IsCycleOn 1 s) s.Subsingleton","decl":"@[simp]\ntheorem isCycleOn_one : (1 : Perm α).IsCycleOn s ↔ s.Subsingleton := by\n  simp [IsCycleOn, Set.bijOn_id, Set.Subsingleton]\n\n"}
{"name":"Set.Subsingleton.isCycleOn_one","module":"Mathlib.GroupTheory.Perm.Cycle.Basic","initialProofState":"α : Type u_2\ns : Set α\na✝ : s.Subsingleton\n⊢ Equiv.Perm.IsCycleOn 1 s","decl":"alias ⟨IsCycleOn.subsingleton, _root_.Set.Subsingleton.isCycleOn_one⟩ := isCycleOn_one\n\n"}
{"name":"Equiv.Perm.IsCycleOn.subsingleton","module":"Mathlib.GroupTheory.Perm.Cycle.Basic","initialProofState":"α : Type u_2\ns : Set α\na✝ : Equiv.Perm.IsCycleOn 1 s\n⊢ s.Subsingleton","decl":"alias ⟨IsCycleOn.subsingleton, _root_.Set.Subsingleton.isCycleOn_one⟩ := isCycleOn_one\n\n"}
{"name":"Equiv.Perm.isCycleOn_singleton","module":"Mathlib.GroupTheory.Perm.Cycle.Basic","initialProofState":"α : Type u_2\nf : Equiv.Perm α\na : α\n⊢ Iff (f.IsCycleOn (Singleton.singleton a)) (Eq (f a) a)","decl":"@[simp]\ntheorem isCycleOn_singleton : f.IsCycleOn {a} ↔ f a = a := by simp [IsCycleOn, SameCycle.rfl]\n\n"}
{"name":"Equiv.Perm.isCycleOn_of_subsingleton","module":"Mathlib.GroupTheory.Perm.Cycle.Basic","initialProofState":"α : Type u_2\ninst✝ : Subsingleton α\nf : Equiv.Perm α\ns : Set α\n⊢ f.IsCycleOn s","decl":"theorem isCycleOn_of_subsingleton [Subsingleton α] (f : Perm α) (s : Set α) : f.IsCycleOn s :=\n  ⟨s.bijOn_of_subsingleton _, fun x _ y _ => (Subsingleton.elim x y).sameCycle _⟩\n\n"}
{"name":"Equiv.Perm.isCycleOn_inv","module":"Mathlib.GroupTheory.Perm.Cycle.Basic","initialProofState":"α : Type u_2\nf : Equiv.Perm α\ns : Set α\n⊢ Iff ((Inv.inv f).IsCycleOn s) (f.IsCycleOn s)","decl":"@[simp]\ntheorem isCycleOn_inv : f⁻¹.IsCycleOn s ↔ f.IsCycleOn s := by\n  simp only [IsCycleOn, sameCycle_inv, and_congr_left_iff]\n  exact fun _ ↦ ⟨fun h ↦ Set.BijOn.perm_inv h, fun h ↦ Set.BijOn.perm_inv h⟩\n\n"}
{"name":"Equiv.Perm.IsCycleOn.inv","module":"Mathlib.GroupTheory.Perm.Cycle.Basic","initialProofState":"α : Type u_2\nf : Equiv.Perm α\ns : Set α\na✝ : f.IsCycleOn s\n⊢ (Inv.inv f).IsCycleOn s","decl":"alias ⟨IsCycleOn.of_inv, IsCycleOn.inv⟩ := isCycleOn_inv\n\n"}
{"name":"Equiv.Perm.IsCycleOn.of_inv","module":"Mathlib.GroupTheory.Perm.Cycle.Basic","initialProofState":"α : Type u_2\nf : Equiv.Perm α\ns : Set α\na✝ : (Inv.inv f).IsCycleOn s\n⊢ f.IsCycleOn s","decl":"alias ⟨IsCycleOn.of_inv, IsCycleOn.inv⟩ := isCycleOn_inv\n\n"}
{"name":"Equiv.Perm.IsCycleOn.conj","module":"Mathlib.GroupTheory.Perm.Cycle.Basic","initialProofState":"α : Type u_2\nf g : Equiv.Perm α\ns : Set α\nh : f.IsCycleOn s\n⊢ (HMul.hMul (HMul.hMul g f) (Inv.inv g)).IsCycleOn (Set.image (⇑g) s)","decl":"theorem IsCycleOn.conj (h : f.IsCycleOn s) : (g * f * g⁻¹).IsCycleOn ((g : Perm α) '' s) :=\n  ⟨(g.bijOn_image.comp h.1).comp g.bijOn_symm_image, fun x hx y hy => by\n    rw [← preimage_inv] at hx hy\n    convert Equiv.Perm.SameCycle.conj (h.2 hx hy) (g := g) <;> rw [apply_inv_self]⟩\n\n"}
{"name":"Equiv.Perm.isCycleOn_swap","module":"Mathlib.GroupTheory.Perm.Cycle.Basic","initialProofState":"α : Type u_2\na b : α\ninst✝ : DecidableEq α\nhab : Ne a b\n⊢ (Equiv.swap a b).IsCycleOn (Insert.insert a (Singleton.singleton b))","decl":"theorem isCycleOn_swap [DecidableEq α] (hab : a ≠ b) : (swap a b).IsCycleOn {a, b} :=\n  ⟨bijOn_swap (by simp) (by simp), fun x hx y hy => by\n    rw [Set.mem_insert_iff, Set.mem_singleton_iff] at hx hy\n    obtain rfl | rfl := hx <;> obtain rfl | rfl := hy\n    · exact ⟨0, by rw [zpow_zero, coe_one, id]⟩\n    · exact ⟨1, by rw [zpow_one, swap_apply_left]⟩\n    · exact ⟨1, by rw [zpow_one, swap_apply_right]⟩\n    · exact ⟨0, by rw [zpow_zero, coe_one, id]⟩⟩\n\n"}
{"name":"Equiv.Perm.IsCycleOn.apply_ne","module":"Mathlib.GroupTheory.Perm.Cycle.Basic","initialProofState":"α : Type u_2\nf : Equiv.Perm α\ns : Set α\na : α\nhf : f.IsCycleOn s\nhs : s.Nontrivial\nha : Membership.mem s a\n⊢ Ne (f a) a","decl":"protected theorem IsCycleOn.apply_ne (hf : f.IsCycleOn s) (hs : s.Nontrivial) (ha : a ∈ s) :\n    f a ≠ a := by\n  obtain ⟨b, hb, hba⟩ := hs.exists_ne a\n  obtain ⟨n, rfl⟩ := hf.2 ha hb\n  exact fun h => hba (IsFixedPt.perm_zpow h n)\n\n"}
{"name":"Equiv.Perm.IsCycle.isCycleOn","module":"Mathlib.GroupTheory.Perm.Cycle.Basic","initialProofState":"α : Type u_2\nf : Equiv.Perm α\nhf : f.IsCycle\n⊢ f.IsCycleOn (setOf fun x => Ne (f x) x)","decl":"protected theorem IsCycle.isCycleOn (hf : f.IsCycle) : f.IsCycleOn { x | f x ≠ x } :=\n  ⟨f.bijOn fun _ => f.apply_eq_iff_eq.not, fun _ ha _ => hf.sameCycle ha⟩\n\n"}
{"name":"Equiv.Perm.isCycle_iff_exists_isCycleOn","module":"Mathlib.GroupTheory.Perm.Cycle.Basic","initialProofState":"α : Type u_2\nf : Equiv.Perm α\n⊢ Iff f.IsCycle (Exists fun s => And s.Nontrivial (And (f.IsCycleOn s) (∀ ⦃x : α⦄, Not (Function.IsFixedPt (⇑f) x) → Membership.mem s x)))","decl":"/-- This lemma demonstrates the relation between `Equiv.Perm.IsCycle` and `Equiv.Perm.IsCycleOn`\nin non-degenerate cases. -/\ntheorem isCycle_iff_exists_isCycleOn :\n    f.IsCycle ↔ ∃ s : Set α, s.Nontrivial ∧ f.IsCycleOn s ∧ ∀ ⦃x⦄, ¬IsFixedPt f x → x ∈ s := by\n  refine ⟨fun hf => ⟨{ x | f x ≠ x }, ?_, hf.isCycleOn, fun _ => id⟩, ?_⟩\n  · obtain ⟨a, ha⟩ := hf\n    exact ⟨f a, f.injective.ne ha.1, a, ha.1, ha.1⟩\n  · rintro ⟨s, hs, hf, hsf⟩\n    obtain ⟨a, ha⟩ := hs.nonempty\n    exact ⟨a, hf.apply_ne hs ha, fun b hb => hf.2 ha <| hsf hb⟩\n\n"}
{"name":"Equiv.Perm.IsCycleOn.apply_mem_iff","module":"Mathlib.GroupTheory.Perm.Cycle.Basic","initialProofState":"α : Type u_2\nf : Equiv.Perm α\ns : Set α\nx : α\nhf : f.IsCycleOn s\n⊢ Iff (Membership.mem s (f x)) (Membership.mem s x)","decl":"theorem IsCycleOn.apply_mem_iff (hf : f.IsCycleOn s) : f x ∈ s ↔ x ∈ s :=\n  ⟨fun hx => by\n    convert hf.1.perm_inv.1 hx\n    rw [inv_apply_self], fun hx => hf.1.mapsTo hx⟩\n\n"}
{"name":"Equiv.Perm.IsCycleOn.isCycle_subtypePerm","module":"Mathlib.GroupTheory.Perm.Cycle.Basic","initialProofState":"α : Type u_2\nf : Equiv.Perm α\ns : Set α\nhf : f.IsCycleOn s\nhs : s.Nontrivial\n⊢ (f.subtypePerm ⋯).IsCycle","decl":"/-- Note that the identity satisfies `IsCycleOn` for any subsingleton set, but not `IsCycle`. -/\ntheorem IsCycleOn.isCycle_subtypePerm (hf : f.IsCycleOn s) (hs : s.Nontrivial) :\n    (f.subtypePerm fun _ => hf.apply_mem_iff.symm : Perm s).IsCycle := by\n  obtain ⟨a, ha⟩ := hs.nonempty\n  exact\n    ⟨⟨a, ha⟩, ne_of_apply_ne ((↑) : s → α) (hf.apply_ne hs ha), fun b _ =>\n      (hf.2 (⟨a, ha⟩ : s).2 b.2).subtypePerm⟩\n\n"}
{"name":"Equiv.Perm.IsCycleOn.subtypePerm","module":"Mathlib.GroupTheory.Perm.Cycle.Basic","initialProofState":"α : Type u_2\nf : Equiv.Perm α\ns : Set α\nhf : f.IsCycleOn s\n⊢ (f.subtypePerm ⋯).IsCycleOn Set.univ","decl":"/-- Note that the identity is a cycle on any subsingleton set, but not a cycle. -/\nprotected theorem IsCycleOn.subtypePerm (hf : f.IsCycleOn s) :\n    (f.subtypePerm fun _ => hf.apply_mem_iff.symm : Perm s).IsCycleOn _root_.Set.univ := by\n  obtain hs | hs := s.subsingleton_or_nontrivial\n  · haveI := hs.coe_sort\n    exact isCycleOn_of_subsingleton _ _\n  convert (hf.isCycle_subtypePerm hs).isCycleOn\n  rw [eq_comm, Set.eq_univ_iff_forall]\n  exact fun x => ne_of_apply_ne ((↑) : s → α) (hf.apply_ne hs x.2)\n\n-- TODO: Theory of order of an element under an action\n"}
{"name":"Equiv.Perm.IsCycleOn.pow_apply_eq","module":"Mathlib.GroupTheory.Perm.Cycle.Basic","initialProofState":"α : Type u_2\nf : Equiv.Perm α\na : α\ns : Finset α\nhf : f.IsCycleOn ↑s\nha : Membership.mem s a\nn : Nat\n⊢ Iff (Eq ((HPow.hPow f n) a) a) (Dvd.dvd s.card n)","decl":"theorem IsCycleOn.pow_apply_eq {s : Finset α} (hf : f.IsCycleOn s) (ha : a ∈ s) {n : ℕ} :\n    (f ^ n) a = a ↔ #s ∣ n := by\n  obtain rfl | hs := Finset.eq_singleton_or_nontrivial ha\n  · rw [coe_singleton, isCycleOn_singleton] at hf\n    simpa using IsFixedPt.iterate hf n\n  classical\n    have h (x : s) : ¬f x = x := hf.apply_ne hs x.2\n    have := (hf.isCycle_subtypePerm hs).orderOf\n    simp only [coe_sort_coe, support_subtype_perm, ne_eq, h, not_false_eq_true, univ_eq_attach,\n      mem_attach, imp_self, implies_true, filter_true_of_mem, card_attach] at this\n    rw [← this, orderOf_dvd_iff_pow_eq_one,\n      (hf.isCycle_subtypePerm hs).pow_eq_one_iff'\n        (ne_of_apply_ne ((↑) : s → α) <| hf.apply_ne hs (⟨a, ha⟩ : s).2)]\n    simp\n    -- This used to be the end of the proof before https://github.com/leanprover/lean4/pull/2644\n    erw [subtypePerm_apply]\n    simp\n\n"}
{"name":"Equiv.Perm.IsCycleOn.zpow_apply_eq","module":"Mathlib.GroupTheory.Perm.Cycle.Basic","initialProofState":"α : Type u_2\nf : Equiv.Perm α\na : α\ns : Finset α\nhf : f.IsCycleOn ↑s\nha : Membership.mem s a\nn : Int\n⊢ Iff (Eq ((HPow.hPow f n) a) a) (Dvd.dvd (↑s.card) n)","decl":"theorem IsCycleOn.zpow_apply_eq {s : Finset α} (hf : f.IsCycleOn s) (ha : a ∈ s) :\n    ∀ {n : ℤ}, (f ^ n) a = a ↔ (#s : ℤ) ∣ n\n  | Int.ofNat _ => (hf.pow_apply_eq ha).trans Int.natCast_dvd_natCast.symm\n  | Int.negSucc n => by\n    rw [zpow_negSucc, ← inv_pow]\n    exact (hf.inv.pow_apply_eq ha).trans (dvd_neg.trans Int.natCast_dvd_natCast).symm\n\n"}
{"name":"Equiv.Perm.IsCycleOn.pow_apply_eq_pow_apply","module":"Mathlib.GroupTheory.Perm.Cycle.Basic","initialProofState":"α : Type u_2\nf : Equiv.Perm α\na : α\ns : Finset α\nhf : f.IsCycleOn ↑s\nha : Membership.mem s a\nm n : Nat\n⊢ Iff (Eq ((HPow.hPow f m) a) ((HPow.hPow f n) a)) (s.card.ModEq m n)","decl":"theorem IsCycleOn.pow_apply_eq_pow_apply {s : Finset α} (hf : f.IsCycleOn s) (ha : a ∈ s)\n    {m n : ℕ} : (f ^ m) a = (f ^ n) a ↔ m ≡ n [MOD #s] := by\n  rw [Nat.modEq_iff_dvd, ← hf.zpow_apply_eq ha]\n  simp [sub_eq_neg_add, zpow_add, eq_inv_iff_eq, eq_comm]\n\n"}
{"name":"Equiv.Perm.IsCycleOn.zpow_apply_eq_zpow_apply","module":"Mathlib.GroupTheory.Perm.Cycle.Basic","initialProofState":"α : Type u_2\nf : Equiv.Perm α\na : α\ns : Finset α\nhf : f.IsCycleOn ↑s\nha : Membership.mem s a\nm n : Int\n⊢ Iff (Eq ((HPow.hPow f m) a) ((HPow.hPow f n) a)) ((↑s.card).ModEq m n)","decl":"theorem IsCycleOn.zpow_apply_eq_zpow_apply {s : Finset α} (hf : f.IsCycleOn s) (ha : a ∈ s)\n    {m n : ℤ} : (f ^ m) a = (f ^ n) a ↔ m ≡ n [ZMOD #s] := by\n  rw [Int.modEq_iff_dvd, ← hf.zpow_apply_eq ha]\n  simp [sub_eq_neg_add, zpow_add, eq_inv_iff_eq, eq_comm]\n\n"}
{"name":"Equiv.Perm.IsCycleOn.pow_card_apply","module":"Mathlib.GroupTheory.Perm.Cycle.Basic","initialProofState":"α : Type u_2\nf : Equiv.Perm α\na : α\ns : Finset α\nhf : f.IsCycleOn ↑s\nha : Membership.mem s a\n⊢ Eq ((HPow.hPow f s.card) a) a","decl":"theorem IsCycleOn.pow_card_apply {s : Finset α} (hf : f.IsCycleOn s) (ha : a ∈ s) :\n    (f ^ #s) a = a :=\n  (hf.pow_apply_eq ha).2 dvd_rfl\n\n"}
{"name":"Equiv.Perm.IsCycleOn.exists_pow_eq","module":"Mathlib.GroupTheory.Perm.Cycle.Basic","initialProofState":"α : Type u_2\nf : Equiv.Perm α\na b : α\ns : Finset α\nhf : f.IsCycleOn ↑s\nha : Membership.mem s a\nhb : Membership.mem s b\n⊢ Exists fun n => And (LT.lt n s.card) (Eq ((HPow.hPow f n) a) b)","decl":"theorem IsCycleOn.exists_pow_eq {s : Finset α} (hf : f.IsCycleOn s) (ha : a ∈ s) (hb : b ∈ s) :\n    ∃ n < #s, (f ^ n) a = b := by\n  classical\n    obtain ⟨n, rfl⟩ := hf.2 ha hb\n    obtain ⟨k, hk⟩ := (Int.mod_modEq n #s).symm.dvd\n    refine ⟨n.natMod #s, Int.natMod_lt (Nonempty.card_pos ⟨a, ha⟩).ne', ?_⟩\n    rw [← zpow_natCast, Int.natMod,\n      Int.toNat_of_nonneg (Int.emod_nonneg _ <| Nat.cast_ne_zero.2\n        (Nonempty.card_pos ⟨a, ha⟩).ne'), sub_eq_iff_eq_add'.1 hk, zpow_add, zpow_mul]\n    simp only [zpow_natCast, coe_mul, comp_apply, EmbeddingLike.apply_eq_iff_eq]\n    exact IsFixedPt.perm_zpow (hf.pow_card_apply ha) _\n\n"}
{"name":"Equiv.Perm.IsCycleOn.exists_pow_eq'","module":"Mathlib.GroupTheory.Perm.Cycle.Basic","initialProofState":"α : Type u_2\nf : Equiv.Perm α\ns : Set α\na b : α\nhs : s.Finite\nhf : f.IsCycleOn s\nha : Membership.mem s a\nhb : Membership.mem s b\n⊢ Exists fun n => Eq ((HPow.hPow f n) a) b","decl":"theorem IsCycleOn.exists_pow_eq' (hs : s.Finite) (hf : f.IsCycleOn s) (ha : a ∈ s) (hb : b ∈ s) :\n    ∃ n : ℕ, (f ^ n) a = b := by\n  lift s to Finset α using id hs\n  obtain ⟨n, -, hn⟩ := hf.exists_pow_eq ha hb\n  exact ⟨n, hn⟩\n\n"}
{"name":"Equiv.Perm.IsCycleOn.range_pow","module":"Mathlib.GroupTheory.Perm.Cycle.Basic","initialProofState":"α : Type u_2\nf : Equiv.Perm α\ns : Set α\na : α\nhs : s.Finite\nh : f.IsCycleOn s\nha : Membership.mem s a\n⊢ Eq (Set.range fun n => (HPow.hPow f n) a) s","decl":"theorem IsCycleOn.range_pow (hs : s.Finite) (h : f.IsCycleOn s) (ha : a ∈ s) :\n    Set.range (fun n => (f ^ n) a : ℕ → α) = s :=\n  Set.Subset.antisymm (Set.range_subset_iff.2 fun _ => h.1.mapsTo.perm_pow _ ha) fun _ =>\n    h.exists_pow_eq' hs ha\n\n"}
{"name":"Equiv.Perm.IsCycleOn.range_zpow","module":"Mathlib.GroupTheory.Perm.Cycle.Basic","initialProofState":"α : Type u_2\nf : Equiv.Perm α\ns : Set α\na : α\nh : f.IsCycleOn s\nha : Membership.mem s a\n⊢ Eq (Set.range fun n => (HPow.hPow f n) a) s","decl":"theorem IsCycleOn.range_zpow (h : f.IsCycleOn s) (ha : a ∈ s) :\n    Set.range (fun n => (f ^ n) a : ℤ → α) = s :=\n  Set.Subset.antisymm (Set.range_subset_iff.2 fun _ => (h.1.perm_zpow _).mapsTo ha) <| h.2 ha\n\n"}
{"name":"Equiv.Perm.IsCycleOn.of_pow","module":"Mathlib.GroupTheory.Perm.Cycle.Basic","initialProofState":"α : Type u_2\nf : Equiv.Perm α\ns : Set α\nn : Nat\nhf : (HPow.hPow f n).IsCycleOn s\nh : Set.BijOn (⇑f) s s\n⊢ f.IsCycleOn s","decl":"theorem IsCycleOn.of_pow {n : ℕ} (hf : (f ^ n).IsCycleOn s) (h : Set.BijOn f s s) : f.IsCycleOn s :=\n  ⟨h, fun _ hx _ hy => (hf.2 hx hy).of_pow⟩\n\n"}
{"name":"Equiv.Perm.IsCycleOn.of_zpow","module":"Mathlib.GroupTheory.Perm.Cycle.Basic","initialProofState":"α : Type u_2\nf : Equiv.Perm α\ns : Set α\nn : Int\nhf : (HPow.hPow f n).IsCycleOn s\nh : Set.BijOn (⇑f) s s\n⊢ f.IsCycleOn s","decl":"theorem IsCycleOn.of_zpow {n : ℤ} (hf : (f ^ n).IsCycleOn s) (h : Set.BijOn f s s) :\n    f.IsCycleOn s :=\n  ⟨h, fun _ hx _ hy => (hf.2 hx hy).of_zpow⟩\n\n"}
{"name":"Equiv.Perm.IsCycleOn.extendDomain","module":"Mathlib.GroupTheory.Perm.Cycle.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ng : Equiv.Perm α\ns : Set α\np : β → Prop\ninst✝ : DecidablePred p\nf : Equiv α (Subtype p)\nh : g.IsCycleOn s\n⊢ (g.extendDomain f).IsCycleOn (Set.image (Function.comp Subtype.val ⇑f) s)","decl":"theorem IsCycleOn.extendDomain {p : β → Prop} [DecidablePred p] (f : α ≃ Subtype p)\n    (h : g.IsCycleOn s) : (g.extendDomain f).IsCycleOn ((↑) ∘ f '' s) :=\n  ⟨h.1.extendDomain, by\n    rintro _ ⟨a, ha, rfl⟩ _ ⟨b, hb, rfl⟩\n    exact (h.2 ha hb).extendDomain⟩\n\n"}
{"name":"Equiv.Perm.IsCycleOn.countable","module":"Mathlib.GroupTheory.Perm.Cycle.Basic","initialProofState":"α : Type u_2\nf : Equiv.Perm α\ns : Set α\nhs : f.IsCycleOn s\n⊢ s.Countable","decl":"protected theorem IsCycleOn.countable (hs : f.IsCycleOn s) : s.Countable := by\n  obtain rfl | ⟨a, ha⟩ := s.eq_empty_or_nonempty\n  · exact Set.countable_empty\n  · exact (Set.countable_range fun n : ℤ => (⇑(f ^ n) : α → α) a).mono (hs.2 ha)\n\n\n"}
{"name":"List.Nodup.isCycleOn_formPerm","module":"Mathlib.GroupTheory.Perm.Cycle.Basic","initialProofState":"α : Type u_2\ninst✝ : DecidableEq α\nl : List α\nh : l.Nodup\n⊢ l.formPerm.IsCycleOn (setOf fun a => Membership.mem l a)","decl":"theorem Nodup.isCycleOn_formPerm (h : l.Nodup) :\n    l.formPerm.IsCycleOn { a | a ∈ l } := by\n  refine ⟨l.formPerm.bijOn fun _ => List.formPerm_mem_iff_mem, fun a ha b hb => ?_⟩\n  rw [Set.mem_setOf, ← List.indexOf_lt_length_iff] at ha hb\n  rw [← List.getElem_indexOf ha, ← List.getElem_indexOf hb]\n  refine ⟨l.indexOf b - l.indexOf a, ?_⟩\n  simp only [sub_eq_neg_add, zpow_add, zpow_neg, Equiv.Perm.inv_eq_iff_eq, zpow_natCast,\n    Equiv.Perm.coe_mul, List.formPerm_pow_apply_getElem _ h, Function.comp]\n  rw [add_comm]\n\n"}
{"name":"Finset.exists_cycleOn","module":"Mathlib.GroupTheory.Perm.Cycle.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\ns : Finset α\n⊢ Exists fun f => And (f.IsCycleOn ↑s) (HasSubset.Subset f.support s)","decl":"theorem exists_cycleOn (s : Finset α) :\n    ∃ f : Perm α, f.IsCycleOn s ∧ f.support ⊆ s := by\n  refine ⟨s.toList.formPerm, ?_, fun x hx => by\n    simpa using List.mem_of_formPerm_apply_ne (Perm.mem_support.1 hx)⟩\n  convert s.nodup_toList.isCycleOn_formPerm\n  simp\n\n"}
{"name":"Set.Countable.exists_cycleOn","module":"Mathlib.GroupTheory.Perm.Cycle.Basic","initialProofState":"α : Type u_2\ns : Set α\nhs : s.Countable\n⊢ Exists fun f => And (f.IsCycleOn s) (HasSubset.Subset (setOf fun x => Ne (f x) x) s)","decl":"theorem Countable.exists_cycleOn (hs : s.Countable) :\n    ∃ f : Perm α, f.IsCycleOn s ∧ { x | f x ≠ x } ⊆ s := by\n  classical\n  obtain hs' | hs' := s.finite_or_infinite\n  · refine ⟨hs'.toFinset.toList.formPerm, ?_, fun x hx => by\n      simpa using List.mem_of_formPerm_apply_ne hx⟩\n    convert hs'.toFinset.nodup_toList.isCycleOn_formPerm\n    simp\n  · haveI := hs.to_subtype\n    haveI := hs'.to_subtype\n    obtain ⟨f⟩ : Nonempty (ℤ ≃ s) := inferInstance\n    refine ⟨(Equiv.addRight 1).extendDomain f, ?_, fun x hx =>\n      of_not_not fun h => hx <| Perm.extendDomain_apply_not_subtype _ _ h⟩\n    convert Int.addRight_one_isCycle.isCycleOn.extendDomain f\n    rw [Set.image_comp, Equiv.image_eq_preimage]\n    ext\n    simp\n\n"}
{"name":"Set.prod_self_eq_iUnion_perm","module":"Mathlib.GroupTheory.Perm.Cycle.Basic","initialProofState":"α : Type u_2\nf : Equiv.Perm α\ns : Set α\nhf : f.IsCycleOn s\n⊢ Eq (SProd.sprod s s) (Set.iUnion fun n => Set.image (fun a => { fst := a, snd := (HPow.hPow f n) a }) s)","decl":"theorem prod_self_eq_iUnion_perm (hf : f.IsCycleOn s) :\n    s ×ˢ s = ⋃ n : ℤ, (fun a => (a, (f ^ n) a)) '' s := by\n  ext ⟨a, b⟩\n  simp only [Set.mem_prod, Set.mem_iUnion, Set.mem_image]\n  refine ⟨fun hx => ?_, ?_⟩\n  · obtain ⟨n, rfl⟩ := hf.2 hx.1 hx.2\n    exact ⟨_, _, hx.1, rfl⟩\n  · rintro ⟨n, a, ha, ⟨⟩⟩\n    exact ⟨ha, (hf.1.perm_zpow _).mapsTo ha⟩\n\n"}
{"name":"Finset.product_self_eq_disjiUnion_perm_aux","module":"Mathlib.GroupTheory.Perm.Cycle.Basic","initialProofState":"α : Type u_2\nf : Equiv.Perm α\ns : Finset α\nhf : f.IsCycleOn ↑s\n⊢ (↑(Finset.range s.card)).PairwiseDisjoint fun k => Finset.map { toFun := fun i => { fst := i, snd := (HPow.hPow f k) i }, inj' := ⋯ } s","decl":"theorem product_self_eq_disjiUnion_perm_aux (hf : f.IsCycleOn s) :\n    (range #s : Set ℕ).PairwiseDisjoint fun k =>\n      s.map ⟨fun i => (i, (f ^ k) i), fun _ _ => congr_arg Prod.fst⟩ := by\n  obtain hs | _ := (s : Set α).subsingleton_or_nontrivial\n  · refine Set.Subsingleton.pairwise ?_ _\n    simp_rw [Set.Subsingleton, mem_coe, ← card_le_one] at hs ⊢\n    rwa [card_range]\n  classical\n    rintro m hm n hn hmn\n    simp only [disjoint_left, Function.onFun, mem_map, Function.Embedding.coeFn_mk, exists_prop,\n      not_exists, not_and, forall_exists_index, and_imp, Prod.forall, Prod.mk.inj_iff]\n    rintro _ _ _ - rfl rfl a ha rfl h\n    rw [hf.pow_apply_eq_pow_apply ha] at h\n    rw [mem_coe, mem_range] at hm hn\n    exact hmn.symm (h.eq_of_lt_of_lt hn hm)\n\n"}
{"name":"Finset.product_self_eq_disjiUnion_perm","module":"Mathlib.GroupTheory.Perm.Cycle.Basic","initialProofState":"α : Type u_2\nf : Equiv.Perm α\ns : Finset α\nhf : f.IsCycleOn ↑s\n⊢ Eq (SProd.sprod s s) ((Finset.range s.card).disjiUnion (fun k => Finset.map { toFun := fun i => { fst := i, snd := (HPow.hPow f k) i }, inj' := ⋯ } s) ⋯)","decl":"/-- We can partition the square `s ×ˢ s` into shifted diagonals as such:\n```\n01234\n40123\n34012\n23401\n12340\n```\n\nThe diagonals are given by the cycle `f`.\n-/\ntheorem product_self_eq_disjiUnion_perm (hf : f.IsCycleOn s) :\n    s ×ˢ s =\n      (range #s).disjiUnion\n        (fun k => s.map ⟨fun i => (i, (f ^ k) i), fun _ _ => congr_arg Prod.fst⟩)\n        (product_self_eq_disjiUnion_perm_aux hf) := by\n  ext ⟨a, b⟩\n  simp only [mem_product, Equiv.Perm.coe_pow, mem_disjiUnion, mem_range, mem_map,\n    Function.Embedding.coeFn_mk, Prod.mk.inj_iff, exists_prop]\n  refine ⟨fun hx => ?_, ?_⟩\n  · obtain ⟨n, hn, rfl⟩ := hf.exists_pow_eq hx.1 hx.2\n    exact ⟨n, hn, a, hx.1, rfl, by rw [f.iterate_eq_pow]⟩\n  · rintro ⟨n, -, a, ha, rfl, rfl⟩\n    exact ⟨ha, (hf.1.iterate _).mapsTo ha⟩\n\n"}
{"name":"Finset.sum_smul_sum_eq_sum_perm","module":"Mathlib.GroupTheory.Perm.Cycle.Basic","initialProofState":"ι : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝² : Semiring α\ninst✝¹ : AddCommMonoid β\ninst✝ : Module α β\ns : Finset ι\nσ : Equiv.Perm ι\nhσ : σ.IsCycleOn ↑s\nf : ι → α\ng : ι → β\n⊢ Eq (HSMul.hSMul (s.sum fun i => f i) (s.sum fun i => g i)) ((Finset.range s.card).sum fun k => s.sum fun i => HSMul.hSMul (f i) (g ((HPow.hPow σ k) i)))","decl":"theorem sum_smul_sum_eq_sum_perm (hσ : σ.IsCycleOn s) (f : ι → α) (g : ι → β) :\n    (∑ i ∈ s, f i) • ∑ i ∈ s, g i = ∑ k ∈ range #s, ∑ i ∈ s, f i • g ((σ ^ k) i) := by\n  rw [sum_smul_sum, ← sum_product']\n  simp_rw [product_self_eq_disjiUnion_perm hσ, sum_disjiUnion, sum_map, Embedding.coeFn_mk]\n\n"}
{"name":"Finset.sum_mul_sum_eq_sum_perm","module":"Mathlib.GroupTheory.Perm.Cycle.Basic","initialProofState":"ι : Type u_1\nα : Type u_2\ninst✝ : Semiring α\ns : Finset ι\nσ : Equiv.Perm ι\nhσ : σ.IsCycleOn ↑s\nf g : ι → α\n⊢ Eq (HMul.hMul (s.sum fun i => f i) (s.sum fun i => g i)) ((Finset.range s.card).sum fun k => s.sum fun i => HMul.hMul (f i) (g ((HPow.hPow σ k) i)))","decl":"theorem sum_mul_sum_eq_sum_perm (hσ : σ.IsCycleOn s) (f g : ι → α) :\n    ((∑ i ∈ s, f i) * ∑ i ∈ s, g i) = ∑ k ∈ range #s, ∑ i ∈ s, f i * g ((σ ^ k) i) :=\n  sum_smul_sum_eq_sum_perm hσ f g\n\n"}
{"name":"Equiv.Perm.subtypePerm_apply_pow_of_mem","module":"Mathlib.GroupTheory.Perm.Cycle.Basic","initialProofState":"α : Type u_2\ng : Equiv.Perm α\ns : Finset α\nhs : ∀ (x : α), Iff (Membership.mem s x) (Membership.mem s (g x))\nn : Nat\nx : α\nhx : Membership.mem s x\n⊢ Eq (↑((HPow.hPow (g.subtypePerm hs) n) ⟨x, hx⟩)) ((HPow.hPow g n) x)","decl":"theorem subtypePerm_apply_pow_of_mem {g : Perm α} {s : Finset α}\n    (hs : ∀ x : α, x ∈ s ↔ g x ∈ s) {n : ℕ} {x : α} (hx : x ∈ s) :\n    ((g.subtypePerm hs ^ n) (⟨x, hx⟩ : s) : α) = (g ^ n) x := by\n  simp only [subtypePerm_pow, subtypePerm_apply]\n\n"}
{"name":"Equiv.Perm.subtypePerm_apply_zpow_of_mem","module":"Mathlib.GroupTheory.Perm.Cycle.Basic","initialProofState":"α : Type u_2\ng : Equiv.Perm α\ns : Finset α\nhs : ∀ (x : α), Iff (Membership.mem s x) (Membership.mem s (g x))\ni : Int\nx : α\nhx : Membership.mem s x\n⊢ Eq (↑((HPow.hPow (g.subtypePerm hs) i) ⟨x, hx⟩)) ((HPow.hPow g i) x)","decl":"theorem subtypePerm_apply_zpow_of_mem {g : Perm α} {s : Finset α}\n    (hs : ∀ x : α, x ∈ s ↔ g x ∈ s) {i : ℤ} {x : α} (hx : x ∈ s) :\n    ((g.subtypePerm hs ^ i) (⟨x, hx⟩ : s) : α) = (g ^ i) x := by\n  simp only [subtypePerm_zpow, subtypePerm_apply]\n\n"}
{"name":"Equiv.Perm.IsCycle.nonempty_support","module":"Mathlib.GroupTheory.Perm.Cycle.Basic","initialProofState":"α : Type u_2\ninst✝¹ : Fintype α\ninst✝ : DecidableEq α\ng : Equiv.Perm α\nhg : g.IsCycle\n⊢ g.support.Nonempty","decl":"/-- Support of a cycle is nonempty -/\ntheorem IsCycle.nonempty_support {g : Perm α} (hg : g.IsCycle) :\n    g.support.Nonempty := by\n  rw [Finset.nonempty_iff_ne_empty, ne_eq, support_eq_empty_iff]\n  exact IsCycle.ne_one hg\n\n"}
{"name":"Equiv.Perm.IsCycle.commute_iff'","module":"Mathlib.GroupTheory.Perm.Cycle.Basic","initialProofState":"α : Type u_2\ninst✝¹ : Fintype α\ninst✝ : DecidableEq α\ng c : Equiv.Perm α\nhc : c.IsCycle\n⊢ Iff (Commute g c) (Exists fun hc' => Membership.mem (Subgroup.zpowers c.subtypePermOfSupport) (g.subtypePerm hc'))","decl":"/-- Centralizer of a cycle is a power of that cycle on the cycle -/\ntheorem IsCycle.commute_iff' {g c : Perm α} (hc : c.IsCycle) :\n    Commute g c ↔\n      ∃ hc' : ∀ x : α, x ∈ c.support ↔ g x ∈ c.support,\n        subtypePerm g hc' ∈ Subgroup.zpowers c.subtypePermOfSupport := by\n  constructor\n  · intro hgc\n    have hgc' := mem_support_iff_of_commute hgc\n    use hgc'\n    obtain ⟨a, ha⟩ := IsCycle.nonempty_support hc\n    obtain ⟨i, hi⟩ := hc.sameCycle (mem_support.mp ha) (mem_support.mp ((hgc' a).mp ha))\n    use i\n    ext ⟨x, hx⟩\n    simp only [subtypePermOfSupport, Subtype.coe_mk, subtypePerm_apply]\n    rw [subtypePerm_apply_zpow_of_mem]\n    obtain ⟨j, rfl⟩ := hc.sameCycle (mem_support.mp ha) (mem_support.mp hx)\n    simp only [← mul_apply, Commute.eq (Commute.zpow_right hgc j)]\n    rw [← zpow_add, add_comm i j, zpow_add]\n    simp only [mul_apply, EmbeddingLike.apply_eq_iff_eq]\n    exact hi\n  · rintro ⟨hc', ⟨i, hi⟩⟩\n    ext x\n    simp only [coe_mul, Function.comp_apply]\n    by_cases hx : x ∈ c.support\n    · suffices hi' : ∀ x ∈ c.support, g x = (c ^ i) x by\n        rw [hi' x hx, hi' (c x) (apply_mem_support.mpr hx)]\n        simp only [← mul_apply, ← zpow_add_one, ← zpow_one_add, add_comm]\n      intro x hx\n      have hix := Perm.congr_fun hi ⟨x, hx⟩\n      simp only [← Subtype.coe_inj, subtypePermOfSupport, Subtype.coe_mk, subtypePerm_apply,\n        subtypePerm_apply_zpow_of_mem] at hix\n      exact hix.symm\n    · rw [not_mem_support.mp hx, eq_comm, ← not_mem_support]\n      contrapose! hx\n      exact (hc' x).mpr hx\n\n"}
{"name":"Equiv.Perm.IsCycle.commute_iff","module":"Mathlib.GroupTheory.Perm.Cycle.Basic","initialProofState":"α : Type u_2\ninst✝¹ : Fintype α\ninst✝ : DecidableEq α\ng c : Equiv.Perm α\nhc : c.IsCycle\n⊢ Iff (Commute g c) (Exists fun hc' => Membership.mem (Subgroup.zpowers c) (Equiv.Perm.ofSubtype (g.subtypePerm hc')))","decl":"/-- A permutation `g` commutes with a cycle `c` if and only if\n  `c.support` is invariant under `g`, and `g` acts on it as a power of `c`. -/\ntheorem IsCycle.commute_iff {g c : Perm α} (hc : c.IsCycle) :\n    Commute g c ↔\n      ∃ hc' : ∀ x : α, x ∈ c.support ↔ g x ∈ c.support,\n        ofSubtype (subtypePerm g hc') ∈ Subgroup.zpowers c := by\n  simp_rw [hc.commute_iff', Subgroup.mem_zpowers_iff]\n  refine exists_congr fun hc' => exists_congr fun k => ?_\n  rw [subtypePermOfSupport, subtypePerm_zpow c k]\n  simp only [Perm.ext_iff, subtypePerm_apply, Subtype.mk.injEq, Subtype.forall]\n  apply forall_congr'\n  intro a\n  by_cases ha : a ∈ c.support\n  · rw [imp_iff_right ha, ofSubtype_subtypePerm_of_mem hc' ha]\n  · rw [iff_true_left (fun b ↦ (ha b).elim), ofSubtype_apply_of_not_mem, ← not_mem_support]\n    · exact Finset.not_mem_mono (support_zpow_le c k) ha\n    · exact ha\n\n"}
{"name":"Equiv.Perm.zpow_eq_ofSubtype_subtypePerm_iff","module":"Mathlib.GroupTheory.Perm.Cycle.Basic","initialProofState":"α : Type u_2\ninst✝¹ : Fintype α\ninst✝ : DecidableEq α\ng c : Equiv.Perm α\ns : Finset α\nhg : ∀ (x : α), Iff (Membership.mem s x) (Membership.mem s (g x))\nhc : HasSubset.Subset c.support s\nn : Int\n⊢ Iff (Eq (HPow.hPow c n) (Equiv.Perm.ofSubtype (g.subtypePerm hg))) (Eq (HPow.hPow (c.subtypePerm ⋯) n) (g.subtypePerm hg))","decl":"theorem zpow_eq_ofSubtype_subtypePerm_iff\n    {g c : Equiv.Perm α} {s : Finset α}\n    (hg : ∀ x, x ∈ s ↔ g x ∈ s) (hc : c.support ⊆ s) (n : ℤ) :\n    c ^ n = ofSubtype (g.subtypePerm hg) ↔\n      c.subtypePerm (isInvariant_of_support_le hc) ^ n = g.subtypePerm hg := by\n  constructor\n  · intro h\n    ext ⟨x, hx⟩\n    simp only [Perm.congr_fun h x, subtypePerm_apply_zpow_of_mem, Subtype.coe_mk, subtypePerm_apply]\n    rw [ofSubtype_apply_of_mem]\n    · simp only [Subtype.coe_mk, subtypePerm_apply]\n    · exact hx\n  · intro h; ext x\n    rw [← h]\n    by_cases hx : x ∈ s\n    · rw [ofSubtype_apply_of_mem (subtypePerm c _ ^ n) hx,\n        subtypePerm_zpow, subtypePerm_apply]\n    · rw [ofSubtype_apply_of_not_mem (subtypePerm c _ ^ n) hx,\n        ← not_mem_support]\n      exact fun hx' ↦ hx (hc (support_zpow_le _ _ hx'))\n\n"}
{"name":"Equiv.Perm.cycle_zpow_mem_support_iff","module":"Mathlib.GroupTheory.Perm.Cycle.Basic","initialProofState":"α : Type u_2\ninst✝¹ : Fintype α\ninst✝ : DecidableEq α\ng : Equiv.Perm α\nhg : g.IsCycle\nn : Int\nx : α\nhx : Ne (g x) x\n⊢ Iff (Eq ((HPow.hPow g n) x) x) (Eq (HMod.hMod n ↑g.support.card) 0)","decl":"theorem cycle_zpow_mem_support_iff {g : Perm α}\n    (hg : g.IsCycle) {n : ℤ} {x : α} (hx : g x ≠ x) :\n    (g ^ n) x = x ↔ n % #g.support = 0 := by\n  set q := n / #g.support\n  set r := n % #g.support\n  have div_euc : r + #g.support * q = n ∧ 0 ≤ r ∧ r < #g.support := by\n    rw [← Int.ediv_emod_unique _]\n    · exact ⟨rfl, rfl⟩\n    simp only [Int.natCast_pos]\n    apply lt_of_lt_of_le _ (IsCycle.two_le_card_support hg); norm_num\n  simp only [← hg.orderOf] at div_euc\n  obtain ⟨m, hm⟩ := Int.eq_ofNat_of_zero_le div_euc.2.1\n  simp only [hm, Nat.cast_nonneg, Nat.cast_lt, true_and] at div_euc\n  rw [← div_euc.1, zpow_add g]\n  simp only [hm, Nat.cast_eq_zero, zpow_natCast, coe_mul, comp_apply,zpow_mul,\n    pow_orderOf_eq_one, one_zpow, coe_one, id_eq]\n  have : (g ^ m) x = x ↔ g ^ m = 1 := by\n    constructor\n    · intro hgm\n      simp only [IsCycle.pow_eq_one_iff hg]\n      use x\n    · intro hgm\n      simp only [hgm, coe_one, id_eq]\n  rw [this]\n  by_cases hm0 : m = 0\n  · simp only [hm0, pow_zero, Nat.cast_zero]\n  · simp only [Nat.cast_eq_zero, hm0, iff_false]\n    exact pow_ne_one_of_lt_orderOf hm0 div_euc.2\n\n"}
