{"name":"MeasureTheory.SimpleFunc.nearestPtInd_zero","module":"Mathlib.MeasureTheory.Function.SimpleFuncDense","initialProofState":"α : Type u_1\ninst✝² : MeasurableSpace α\ninst✝¹ : PseudoEMetricSpace α\ninst✝ : OpensMeasurableSpace α\ne : Nat → α\n⊢ Eq (MeasureTheory.SimpleFunc.nearestPtInd e 0) (MeasureTheory.SimpleFunc.const α 0)","decl":"@[simp]\ntheorem nearestPtInd_zero (e : ℕ → α) : nearestPtInd e 0 = const α 0 :=\n  rfl\n\n"}
{"name":"MeasureTheory.SimpleFunc.nearestPt_zero","module":"Mathlib.MeasureTheory.Function.SimpleFuncDense","initialProofState":"α : Type u_1\ninst✝² : MeasurableSpace α\ninst✝¹ : PseudoEMetricSpace α\ninst✝ : OpensMeasurableSpace α\ne : Nat → α\n⊢ Eq (MeasureTheory.SimpleFunc.nearestPt e 0) (MeasureTheory.SimpleFunc.const α (e 0))","decl":"@[simp]\ntheorem nearestPt_zero (e : ℕ → α) : nearestPt e 0 = const α (e 0) :=\n  rfl\n\n"}
{"name":"MeasureTheory.SimpleFunc.nearestPtInd_succ","module":"Mathlib.MeasureTheory.Function.SimpleFuncDense","initialProofState":"α : Type u_1\ninst✝² : MeasurableSpace α\ninst✝¹ : PseudoEMetricSpace α\ninst✝ : OpensMeasurableSpace α\ne : Nat → α\nN : Nat\nx : α\n⊢ Eq ((MeasureTheory.SimpleFunc.nearestPtInd e (HAdd.hAdd N 1)) x) (ite (∀ (k : Nat), LE.le k N → LT.lt (EDist.edist (e (HAdd.hAdd N 1)) x) (EDist.edist (e k) x)) (HAdd.hAdd N 1) ((MeasureTheory.SimpleFunc.nearestPtInd e N) x))","decl":"theorem nearestPtInd_succ (e : ℕ → α) (N : ℕ) (x : α) :\n    nearestPtInd e (N + 1) x =\n      if ∀ k ≤ N, edist (e (N + 1)) x < edist (e k) x then N + 1 else nearestPtInd e N x := by\n  simp only [nearestPtInd, coe_piecewise, Set.piecewise]\n  congr\n  simp\n\n"}
{"name":"MeasureTheory.SimpleFunc.nearestPtInd_le","module":"Mathlib.MeasureTheory.Function.SimpleFuncDense","initialProofState":"α : Type u_1\ninst✝² : MeasurableSpace α\ninst✝¹ : PseudoEMetricSpace α\ninst✝ : OpensMeasurableSpace α\ne : Nat → α\nN : Nat\nx : α\n⊢ LE.le ((MeasureTheory.SimpleFunc.nearestPtInd e N) x) N","decl":"theorem nearestPtInd_le (e : ℕ → α) (N : ℕ) (x : α) : nearestPtInd e N x ≤ N := by\n  induction' N with N ihN; · simp\n  simp only [nearestPtInd_succ]\n  split_ifs\n  exacts [le_rfl, ihN.trans N.le_succ]\n\n"}
{"name":"MeasureTheory.SimpleFunc.edist_nearestPt_le","module":"Mathlib.MeasureTheory.Function.SimpleFuncDense","initialProofState":"α : Type u_1\ninst✝² : MeasurableSpace α\ninst✝¹ : PseudoEMetricSpace α\ninst✝ : OpensMeasurableSpace α\ne : Nat → α\nx : α\nk N : Nat\nhk : LE.le k N\n⊢ LE.le (EDist.edist ((MeasureTheory.SimpleFunc.nearestPt e N) x) x) (EDist.edist (e k) x)","decl":"theorem edist_nearestPt_le (e : ℕ → α) (x : α) {k N : ℕ} (hk : k ≤ N) :\n    edist (nearestPt e N x) x ≤ edist (e k) x := by\n  induction' N with N ihN generalizing k\n  · simp [nonpos_iff_eq_zero.1 hk, le_refl]\n  · simp only [nearestPt, nearestPtInd_succ, map_apply]\n    split_ifs with h\n    · rcases hk.eq_or_lt with (rfl | hk)\n      exacts [le_rfl, (h k (Nat.lt_succ_iff.1 hk)).le]\n    · push_neg at h\n      rcases h with ⟨l, hlN, hxl⟩\n      rcases hk.eq_or_lt with (rfl | hk)\n      exacts [(ihN hlN).trans hxl, ihN (Nat.lt_succ_iff.1 hk)]\n\n"}
{"name":"MeasureTheory.SimpleFunc.tendsto_nearestPt","module":"Mathlib.MeasureTheory.Function.SimpleFuncDense","initialProofState":"α : Type u_1\ninst✝² : MeasurableSpace α\ninst✝¹ : PseudoEMetricSpace α\ninst✝ : OpensMeasurableSpace α\ne : Nat → α\nx : α\nhx : Membership.mem (closure (Set.range e)) x\n⊢ Filter.Tendsto (fun N => (MeasureTheory.SimpleFunc.nearestPt e N) x) Filter.atTop (nhds x)","decl":"theorem tendsto_nearestPt {e : ℕ → α} {x : α} (hx : x ∈ closure (range e)) :\n    Tendsto (fun N => nearestPt e N x) atTop (𝓝 x) := by\n  refine (atTop_basis.tendsto_iff nhds_basis_eball).2 fun ε hε => ?_\n  rcases EMetric.mem_closure_iff.1 hx ε hε with ⟨_, ⟨N, rfl⟩, hN⟩\n  rw [edist_comm] at hN\n  exact ⟨N, trivial, fun n hn => (edist_nearestPt_le e x hn).trans_lt hN⟩\n\n"}
{"name":"MeasureTheory.SimpleFunc.approxOn_zero","module":"Mathlib.MeasureTheory.Function.SimpleFuncDense","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝⁴ : MeasurableSpace α\ninst✝³ : PseudoEMetricSpace α\ninst✝² : OpensMeasurableSpace α\ninst✝¹ : MeasurableSpace β\nf : β → α\nhf : Measurable f\ns : Set α\ny₀ : α\nh₀ : Membership.mem s y₀\ninst✝ : TopologicalSpace.SeparableSpace ↑s\nx : β\n⊢ Eq ((MeasureTheory.SimpleFunc.approxOn f hf s y₀ h₀ 0) x) y₀","decl":"@[simp]\ntheorem approxOn_zero {f : β → α} (hf : Measurable f) {s : Set α} {y₀ : α} (h₀ : y₀ ∈ s)\n    [SeparableSpace s] (x : β) : approxOn f hf s y₀ h₀ 0 x = y₀ :=\n  rfl\n\n"}
{"name":"MeasureTheory.SimpleFunc.approxOn_mem","module":"Mathlib.MeasureTheory.Function.SimpleFuncDense","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝⁴ : MeasurableSpace α\ninst✝³ : PseudoEMetricSpace α\ninst✝² : OpensMeasurableSpace α\ninst✝¹ : MeasurableSpace β\nf : β → α\nhf : Measurable f\ns : Set α\ny₀ : α\nh₀ : Membership.mem s y₀\ninst✝ : TopologicalSpace.SeparableSpace ↑s\nn : Nat\nx : β\n⊢ Membership.mem s ((MeasureTheory.SimpleFunc.approxOn f hf s y₀ h₀ n) x)","decl":"theorem approxOn_mem {f : β → α} (hf : Measurable f) {s : Set α} {y₀ : α} (h₀ : y₀ ∈ s)\n    [SeparableSpace s] (n : ℕ) (x : β) : approxOn f hf s y₀ h₀ n x ∈ s := by\n  haveI : Nonempty s := ⟨⟨y₀, h₀⟩⟩\n  suffices ∀ n, (Nat.casesOn n y₀ ((↑) ∘ denseSeq s) : α) ∈ s by apply this\n  rintro (_ | n)\n  exacts [h₀, Subtype.mem _]\n\n"}
{"name":"MeasureTheory.SimpleFunc.approxOn_comp","module":"Mathlib.MeasureTheory.Function.SimpleFuncDense","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝⁵ : MeasurableSpace α\ninst✝⁴ : PseudoEMetricSpace α\ninst✝³ : OpensMeasurableSpace α\ninst✝² : MeasurableSpace β\nγ : Type u_7\ninst✝¹ : MeasurableSpace γ\nf : β → α\nhf : Measurable f\ng : γ → β\nhg : Measurable g\ns : Set α\ny₀ : α\nh₀ : Membership.mem s y₀\ninst✝ : TopologicalSpace.SeparableSpace ↑s\nn : Nat\n⊢ Eq (MeasureTheory.SimpleFunc.approxOn (Function.comp f g) ⋯ s y₀ h₀ n) ((MeasureTheory.SimpleFunc.approxOn f hf s y₀ h₀ n).comp g hg)","decl":"@[simp, nolint simpNF] -- Porting note: LHS doesn't simplify.\ntheorem approxOn_comp {γ : Type*} [MeasurableSpace γ] {f : β → α} (hf : Measurable f) {g : γ → β}\n    (hg : Measurable g) {s : Set α} {y₀ : α} (h₀ : y₀ ∈ s) [SeparableSpace s] (n : ℕ) :\n    approxOn (f ∘ g) (hf.comp hg) s y₀ h₀ n = (approxOn f hf s y₀ h₀ n).comp g hg :=\n  rfl\n\n"}
{"name":"MeasureTheory.SimpleFunc.tendsto_approxOn","module":"Mathlib.MeasureTheory.Function.SimpleFuncDense","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝⁴ : MeasurableSpace α\ninst✝³ : PseudoEMetricSpace α\ninst✝² : OpensMeasurableSpace α\ninst✝¹ : MeasurableSpace β\nf : β → α\nhf : Measurable f\ns : Set α\ny₀ : α\nh₀ : Membership.mem s y₀\ninst✝ : TopologicalSpace.SeparableSpace ↑s\nx : β\nhx : Membership.mem (closure s) (f x)\n⊢ Filter.Tendsto (fun n => (MeasureTheory.SimpleFunc.approxOn f hf s y₀ h₀ n) x) Filter.atTop (nhds (f x))","decl":"theorem tendsto_approxOn {f : β → α} (hf : Measurable f) {s : Set α} {y₀ : α} (h₀ : y₀ ∈ s)\n    [SeparableSpace s] {x : β} (hx : f x ∈ closure s) :\n    Tendsto (fun n => approxOn f hf s y₀ h₀ n x) atTop (𝓝 <| f x) := by\n  haveI : Nonempty s := ⟨⟨y₀, h₀⟩⟩\n  rw [← @Subtype.range_coe _ s, ← image_univ, ← (denseRange_denseSeq s).closure_eq] at hx\n  simp (config := { iota := false }) only [approxOn, coe_comp]\n  refine tendsto_nearestPt (closure_minimal ?_ isClosed_closure hx)\n  simp (config := { iota := false }) only [Nat.range_casesOn, closure_union, range_comp]\n  exact\n    Subset.trans (image_closure_subset_closure_image continuous_subtype_val)\n      subset_union_right\n\n"}
{"name":"MeasureTheory.SimpleFunc.edist_approxOn_mono","module":"Mathlib.MeasureTheory.Function.SimpleFuncDense","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝⁴ : MeasurableSpace α\ninst✝³ : PseudoEMetricSpace α\ninst✝² : OpensMeasurableSpace α\ninst✝¹ : MeasurableSpace β\nf : β → α\nhf : Measurable f\ns : Set α\ny₀ : α\nh₀ : Membership.mem s y₀\ninst✝ : TopologicalSpace.SeparableSpace ↑s\nx : β\nm n : Nat\nh : LE.le m n\n⊢ LE.le (EDist.edist ((MeasureTheory.SimpleFunc.approxOn f hf s y₀ h₀ n) x) (f x)) (EDist.edist ((MeasureTheory.SimpleFunc.approxOn f hf s y₀ h₀ m) x) (f x))","decl":"theorem edist_approxOn_mono {f : β → α} (hf : Measurable f) {s : Set α} {y₀ : α} (h₀ : y₀ ∈ s)\n    [SeparableSpace s] (x : β) {m n : ℕ} (h : m ≤ n) :\n    edist (approxOn f hf s y₀ h₀ n x) (f x) ≤ edist (approxOn f hf s y₀ h₀ m x) (f x) := by\n  dsimp only [approxOn, coe_comp, Function.comp_def]\n  exact edist_nearestPt_le _ _ ((nearestPtInd_le _ _ _).trans h)\n\n"}
{"name":"MeasureTheory.SimpleFunc.edist_approxOn_le","module":"Mathlib.MeasureTheory.Function.SimpleFuncDense","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝⁴ : MeasurableSpace α\ninst✝³ : PseudoEMetricSpace α\ninst✝² : OpensMeasurableSpace α\ninst✝¹ : MeasurableSpace β\nf : β → α\nhf : Measurable f\ns : Set α\ny₀ : α\nh₀ : Membership.mem s y₀\ninst✝ : TopologicalSpace.SeparableSpace ↑s\nx : β\nn : Nat\n⊢ LE.le (EDist.edist ((MeasureTheory.SimpleFunc.approxOn f hf s y₀ h₀ n) x) (f x)) (EDist.edist y₀ (f x))","decl":"theorem edist_approxOn_le {f : β → α} (hf : Measurable f) {s : Set α} {y₀ : α} (h₀ : y₀ ∈ s)\n    [SeparableSpace s] (x : β) (n : ℕ) : edist (approxOn f hf s y₀ h₀ n x) (f x) ≤ edist y₀ (f x) :=\n  edist_approxOn_mono hf h₀ x (zero_le n)\n\n"}
{"name":"MeasureTheory.SimpleFunc.edist_approxOn_y0_le","module":"Mathlib.MeasureTheory.Function.SimpleFuncDense","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝⁴ : MeasurableSpace α\ninst✝³ : PseudoEMetricSpace α\ninst✝² : OpensMeasurableSpace α\ninst✝¹ : MeasurableSpace β\nf : β → α\nhf : Measurable f\ns : Set α\ny₀ : α\nh₀ : Membership.mem s y₀\ninst✝ : TopologicalSpace.SeparableSpace ↑s\nx : β\nn : Nat\n⊢ LE.le (EDist.edist y₀ ((MeasureTheory.SimpleFunc.approxOn f hf s y₀ h₀ n) x)) (HAdd.hAdd (EDist.edist y₀ (f x)) (EDist.edist y₀ (f x)))","decl":"theorem edist_approxOn_y0_le {f : β → α} (hf : Measurable f) {s : Set α} {y₀ : α} (h₀ : y₀ ∈ s)\n    [SeparableSpace s] (x : β) (n : ℕ) :\n    edist y₀ (approxOn f hf s y₀ h₀ n x) ≤ edist y₀ (f x) + edist y₀ (f x) :=\n  calc\n    edist y₀ (approxOn f hf s y₀ h₀ n x) ≤\n        edist y₀ (f x) + edist (approxOn f hf s y₀ h₀ n x) (f x) :=\n      edist_triangle_right _ _ _\n    _ ≤ edist y₀ (f x) + edist y₀ (f x) := add_le_add_left (edist_approxOn_le hf h₀ x n) _\n\n"}
{"name":"HasCompactSupport.exists_simpleFunc_approx_of_prod","module":"Mathlib.MeasureTheory.Function.SimpleFuncDense","initialProofState":"X : Type u_7\nY : Type u_8\nα : Type u_9\ninst✝⁷ : Zero α\ninst✝⁶ : TopologicalSpace X\ninst✝⁵ : TopologicalSpace Y\ninst✝⁴ : MeasurableSpace X\ninst✝³ : MeasurableSpace Y\ninst✝² : OpensMeasurableSpace X\ninst✝¹ : OpensMeasurableSpace Y\ninst✝ : PseudoMetricSpace α\nf : Prod X Y → α\nhf : Continuous f\nh'f : HasCompactSupport f\nε : Real\nhε : LT.lt 0 ε\n⊢ Exists fun g => ∀ (x : Prod X Y), LT.lt (Dist.dist (f x) (g x)) ε","decl":"/-- A continuous function with compact support on a product space can be uniformly approximated by\nsimple functions. The subtlety is that we do not assume that the spaces are separable, so the\nproduct of the Borel sigma algebras might not contain all open sets, but still it contains enough\nof them to approximate compactly supported continuous functions. -/\nlemma HasCompactSupport.exists_simpleFunc_approx_of_prod [PseudoMetricSpace α]\n    {f : X × Y → α} (hf : Continuous f) (h'f : HasCompactSupport f)\n    {ε : ℝ} (hε : 0 < ε) :\n    ∃ (g : SimpleFunc (X × Y) α), ∀ x, dist (f x) (g x) < ε := by\n  have M : ∀ (K : Set (X × Y)), IsCompact K →\n      ∃ (g : SimpleFunc (X × Y) α), ∃ (s : Set (X × Y)), MeasurableSet s ∧ K ⊆ s ∧\n      ∀ x ∈ s, dist (f x) (g x) < ε := by\n    intro K hK\n    apply IsCompact.induction_on\n      (p := fun t ↦ ∃ (g : SimpleFunc (X × Y) α), ∃ (s : Set (X × Y)), MeasurableSet s ∧ t ⊆ s ∧\n        ∀ x ∈ s, dist (f x) (g x) < ε) hK\n    · exact ⟨0, ∅, by simp⟩\n    · intro t t' htt' ⟨g, s, s_meas, ts, hg⟩\n      exact ⟨g, s, s_meas, htt'.trans ts, hg⟩\n    · intro t t' ⟨g, s, s_meas, ts, hg⟩ ⟨g', s', s'_meas, t's', hg'⟩\n      refine ⟨g.piecewise s s_meas g', s ∪ s', s_meas.union s'_meas,\n        union_subset_union ts t's', fun p hp ↦ ?_⟩\n      by_cases H : p ∈ s\n      · simpa [H, SimpleFunc.piecewise_apply] using hg p H\n      · simp only [SimpleFunc.piecewise_apply, H, ite_false]\n        apply hg'\n        simpa [H] using (mem_union _ _ _).1 hp\n    · rintro ⟨x, y⟩ -\n      obtain ⟨u, v, hu, xu, hv, yv, huv⟩ : ∃ u v, IsOpen u ∧ x ∈ u ∧ IsOpen v ∧ y ∈ v ∧\n        u ×ˢ v ⊆ {z | dist (f z) (f (x, y)) < ε} :=\n          mem_nhds_prod_iff'.1 <| Metric.continuousAt_iff'.1 hf.continuousAt ε hε\n      refine ⟨u ×ˢ v, nhdsWithin_le_nhds <| (hu.prod hv).mem_nhds (mk_mem_prod xu yv), ?_⟩\n      exact ⟨SimpleFunc.const _ (f (x, y)), u ×ˢ v, hu.measurableSet.prod hv.measurableSet,\n        Subset.rfl, fun z hz ↦ huv hz⟩\n  obtain ⟨g, s, s_meas, fs, hg⟩ : ∃ (g : SimpleFunc (X × Y) α) (s : Set (X × Y)),\n    MeasurableSet s ∧ tsupport f ⊆ s ∧ ∀ (x : X × Y), x ∈ s → dist (f x) (g x) < ε := M _ h'f\n  refine ⟨g.piecewise s s_meas 0, fun p ↦ ?_⟩\n  by_cases H : p ∈ s\n  · simpa [H, SimpleFunc.piecewise_apply] using hg p H\n  · have : f p = 0 := by\n      contrapose! H\n      rw [← Function.mem_support] at H\n      exact fs (subset_tsupport _ H)\n    simp [SimpleFunc.piecewise_apply, H, ite_false, this, hε]\n\n"}
{"name":"HasCompactSupport.measurable_of_prod","module":"Mathlib.MeasureTheory.Function.SimpleFuncDense","initialProofState":"X : Type u_7\nY : Type u_8\nα : Type u_9\ninst✝¹⁰ : Zero α\ninst✝⁹ : TopologicalSpace X\ninst✝⁸ : TopologicalSpace Y\ninst✝⁷ : MeasurableSpace X\ninst✝⁶ : MeasurableSpace Y\ninst✝⁵ : OpensMeasurableSpace X\ninst✝⁴ : OpensMeasurableSpace Y\ninst✝³ : TopologicalSpace α\ninst✝² : TopologicalSpace.PseudoMetrizableSpace α\ninst✝¹ : MeasurableSpace α\ninst✝ : BorelSpace α\nf : Prod X Y → α\nhf : Continuous f\nh'f : HasCompactSupport f\n⊢ Measurable f","decl":"/-- A continuous function with compact support on a product space is measurable for the product\nsigma-algebra. The subtlety is that we do not assume that the spaces are separable, so the\nproduct of the Borel sigma algebras might not contain all open sets, but still it contains enough\nof them to approximate compactly supported continuous functions. -/\nlemma HasCompactSupport.measurable_of_prod\n    [TopologicalSpace α] [PseudoMetrizableSpace α] [MeasurableSpace α] [BorelSpace α]\n    {f : X × Y → α} (hf : Continuous f) (h'f : HasCompactSupport f) :\n    Measurable f := by\n  letI : PseudoMetricSpace α := TopologicalSpace.pseudoMetrizableSpacePseudoMetric α\n  obtain ⟨u, -, u_pos, u_lim⟩ : ∃ u, StrictAnti u ∧ (∀ (n : ℕ), 0 < u n) ∧ Tendsto u atTop (𝓝 0) :=\n    exists_seq_strictAnti_tendsto (0 : ℝ)\n  have : ∀ n, ∃ (g : SimpleFunc (X × Y) α), ∀ x, dist (f x) (g x) < u n :=\n    fun n ↦ h'f.exists_simpleFunc_approx_of_prod hf (u_pos n)\n  choose g hg using this\n  have A : ∀ x, Tendsto (fun n ↦ g n x) atTop (𝓝 (f x)) := by\n    intro x\n    rw [tendsto_iff_dist_tendsto_zero]\n    apply squeeze_zero (fun n ↦ dist_nonneg) (fun n ↦ ?_) u_lim\n    rw [dist_comm]\n    exact (hg n x).le\n  apply measurable_of_tendsto_metrizable (fun n ↦ (g n).measurable) (tendsto_pi_nhds.2 A)\n\n"}
