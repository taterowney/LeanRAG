{"name":"MeasureTheory.SimpleFunc.nearestPtInd_zero","module":"Mathlib.MeasureTheory.Function.SimpleFuncDense","initialProofState":"Î± : Type u_1\ninstâœÂ² : MeasurableSpace Î±\ninstâœÂ¹ : PseudoEMetricSpace Î±\ninstâœ : OpensMeasurableSpace Î±\ne : Nat â†’ Î±\nâŠ¢ Eq (MeasureTheory.SimpleFunc.nearestPtInd e 0) (MeasureTheory.SimpleFunc.const Î± 0)","decl":"@[simp]\ntheorem nearestPtInd_zero (e : â„• â†’ Î±) : nearestPtInd e 0 = const Î± 0 :=\n  rfl\n\n"}
{"name":"MeasureTheory.SimpleFunc.nearestPt_zero","module":"Mathlib.MeasureTheory.Function.SimpleFuncDense","initialProofState":"Î± : Type u_1\ninstâœÂ² : MeasurableSpace Î±\ninstâœÂ¹ : PseudoEMetricSpace Î±\ninstâœ : OpensMeasurableSpace Î±\ne : Nat â†’ Î±\nâŠ¢ Eq (MeasureTheory.SimpleFunc.nearestPt e 0) (MeasureTheory.SimpleFunc.const Î± (e 0))","decl":"@[simp]\ntheorem nearestPt_zero (e : â„• â†’ Î±) : nearestPt e 0 = const Î± (e 0) :=\n  rfl\n\n"}
{"name":"MeasureTheory.SimpleFunc.nearestPtInd_succ","module":"Mathlib.MeasureTheory.Function.SimpleFuncDense","initialProofState":"Î± : Type u_1\ninstâœÂ² : MeasurableSpace Î±\ninstâœÂ¹ : PseudoEMetricSpace Î±\ninstâœ : OpensMeasurableSpace Î±\ne : Nat â†’ Î±\nN : Nat\nx : Î±\nâŠ¢ Eq ((MeasureTheory.SimpleFunc.nearestPtInd e (HAdd.hAdd N 1)) x) (ite (âˆ€ (k : Nat), LE.le k N â†’ LT.lt (EDist.edist (e (HAdd.hAdd N 1)) x) (EDist.edist (e k) x)) (HAdd.hAdd N 1) ((MeasureTheory.SimpleFunc.nearestPtInd e N) x))","decl":"theorem nearestPtInd_succ (e : â„• â†’ Î±) (N : â„•) (x : Î±) :\n    nearestPtInd e (N + 1) x =\n      if âˆ€ k â‰¤ N, edist (e (N + 1)) x < edist (e k) x then N + 1 else nearestPtInd e N x := by\n  simp only [nearestPtInd, coe_piecewise, Set.piecewise]\n  congr\n  simp\n\n"}
{"name":"MeasureTheory.SimpleFunc.nearestPtInd_le","module":"Mathlib.MeasureTheory.Function.SimpleFuncDense","initialProofState":"Î± : Type u_1\ninstâœÂ² : MeasurableSpace Î±\ninstâœÂ¹ : PseudoEMetricSpace Î±\ninstâœ : OpensMeasurableSpace Î±\ne : Nat â†’ Î±\nN : Nat\nx : Î±\nâŠ¢ LE.le ((MeasureTheory.SimpleFunc.nearestPtInd e N) x) N","decl":"theorem nearestPtInd_le (e : â„• â†’ Î±) (N : â„•) (x : Î±) : nearestPtInd e N x â‰¤ N := by\n  induction' N with N ihN; Â· simp\n  simp only [nearestPtInd_succ]\n  split_ifs\n  exacts [le_rfl, ihN.trans N.le_succ]\n\n"}
{"name":"MeasureTheory.SimpleFunc.edist_nearestPt_le","module":"Mathlib.MeasureTheory.Function.SimpleFuncDense","initialProofState":"Î± : Type u_1\ninstâœÂ² : MeasurableSpace Î±\ninstâœÂ¹ : PseudoEMetricSpace Î±\ninstâœ : OpensMeasurableSpace Î±\ne : Nat â†’ Î±\nx : Î±\nk N : Nat\nhk : LE.le k N\nâŠ¢ LE.le (EDist.edist ((MeasureTheory.SimpleFunc.nearestPt e N) x) x) (EDist.edist (e k) x)","decl":"theorem edist_nearestPt_le (e : â„• â†’ Î±) (x : Î±) {k N : â„•} (hk : k â‰¤ N) :\n    edist (nearestPt e N x) x â‰¤ edist (e k) x := by\n  induction' N with N ihN generalizing k\n  Â· simp [nonpos_iff_eq_zero.1 hk, le_refl]\n  Â· simp only [nearestPt, nearestPtInd_succ, map_apply]\n    split_ifs with h\n    Â· rcases hk.eq_or_lt with (rfl | hk)\n      exacts [le_rfl, (h k (Nat.lt_succ_iff.1 hk)).le]\n    Â· push_neg at h\n      rcases h with âŸ¨l, hlN, hxlâŸ©\n      rcases hk.eq_or_lt with (rfl | hk)\n      exacts [(ihN hlN).trans hxl, ihN (Nat.lt_succ_iff.1 hk)]\n\n"}
{"name":"MeasureTheory.SimpleFunc.tendsto_nearestPt","module":"Mathlib.MeasureTheory.Function.SimpleFuncDense","initialProofState":"Î± : Type u_1\ninstâœÂ² : MeasurableSpace Î±\ninstâœÂ¹ : PseudoEMetricSpace Î±\ninstâœ : OpensMeasurableSpace Î±\ne : Nat â†’ Î±\nx : Î±\nhx : Membership.mem (closure (Set.range e)) x\nâŠ¢ Filter.Tendsto (fun N => (MeasureTheory.SimpleFunc.nearestPt e N) x) Filter.atTop (nhds x)","decl":"theorem tendsto_nearestPt {e : â„• â†’ Î±} {x : Î±} (hx : x âˆˆ closure (range e)) :\n    Tendsto (fun N => nearestPt e N x) atTop (ğ“ x) := by\n  refine (atTop_basis.tendsto_iff nhds_basis_eball).2 fun Îµ hÎµ => ?_\n  rcases EMetric.mem_closure_iff.1 hx Îµ hÎµ with âŸ¨_, âŸ¨N, rflâŸ©, hNâŸ©\n  rw [edist_comm] at hN\n  exact âŸ¨N, trivial, fun n hn => (edist_nearestPt_le e x hn).trans_lt hNâŸ©\n\n"}
{"name":"MeasureTheory.SimpleFunc.approxOn_zero","module":"Mathlib.MeasureTheory.Function.SimpleFuncDense","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœâ´ : MeasurableSpace Î±\ninstâœÂ³ : PseudoEMetricSpace Î±\ninstâœÂ² : OpensMeasurableSpace Î±\ninstâœÂ¹ : MeasurableSpace Î²\nf : Î² â†’ Î±\nhf : Measurable f\ns : Set Î±\nyâ‚€ : Î±\nhâ‚€ : Membership.mem s yâ‚€\ninstâœ : TopologicalSpace.SeparableSpace â†‘s\nx : Î²\nâŠ¢ Eq ((MeasureTheory.SimpleFunc.approxOn f hf s yâ‚€ hâ‚€ 0) x) yâ‚€","decl":"@[simp]\ntheorem approxOn_zero {f : Î² â†’ Î±} (hf : Measurable f) {s : Set Î±} {yâ‚€ : Î±} (hâ‚€ : yâ‚€ âˆˆ s)\n    [SeparableSpace s] (x : Î²) : approxOn f hf s yâ‚€ hâ‚€ 0 x = yâ‚€ :=\n  rfl\n\n"}
{"name":"MeasureTheory.SimpleFunc.approxOn_mem","module":"Mathlib.MeasureTheory.Function.SimpleFuncDense","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœâ´ : MeasurableSpace Î±\ninstâœÂ³ : PseudoEMetricSpace Î±\ninstâœÂ² : OpensMeasurableSpace Î±\ninstâœÂ¹ : MeasurableSpace Î²\nf : Î² â†’ Î±\nhf : Measurable f\ns : Set Î±\nyâ‚€ : Î±\nhâ‚€ : Membership.mem s yâ‚€\ninstâœ : TopologicalSpace.SeparableSpace â†‘s\nn : Nat\nx : Î²\nâŠ¢ Membership.mem s ((MeasureTheory.SimpleFunc.approxOn f hf s yâ‚€ hâ‚€ n) x)","decl":"theorem approxOn_mem {f : Î² â†’ Î±} (hf : Measurable f) {s : Set Î±} {yâ‚€ : Î±} (hâ‚€ : yâ‚€ âˆˆ s)\n    [SeparableSpace s] (n : â„•) (x : Î²) : approxOn f hf s yâ‚€ hâ‚€ n x âˆˆ s := by\n  haveI : Nonempty s := âŸ¨âŸ¨yâ‚€, hâ‚€âŸ©âŸ©\n  suffices âˆ€ n, (Nat.casesOn n yâ‚€ ((â†‘) âˆ˜ denseSeq s) : Î±) âˆˆ s by apply this\n  rintro (_ | n)\n  exacts [hâ‚€, Subtype.mem _]\n\n"}
{"name":"MeasureTheory.SimpleFunc.approxOn_comp","module":"Mathlib.MeasureTheory.Function.SimpleFuncDense","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœâµ : MeasurableSpace Î±\ninstâœâ´ : PseudoEMetricSpace Î±\ninstâœÂ³ : OpensMeasurableSpace Î±\ninstâœÂ² : MeasurableSpace Î²\nÎ³ : Type u_7\ninstâœÂ¹ : MeasurableSpace Î³\nf : Î² â†’ Î±\nhf : Measurable f\ng : Î³ â†’ Î²\nhg : Measurable g\ns : Set Î±\nyâ‚€ : Î±\nhâ‚€ : Membership.mem s yâ‚€\ninstâœ : TopologicalSpace.SeparableSpace â†‘s\nn : Nat\nâŠ¢ Eq (MeasureTheory.SimpleFunc.approxOn (Function.comp f g) â‹¯ s yâ‚€ hâ‚€ n) ((MeasureTheory.SimpleFunc.approxOn f hf s yâ‚€ hâ‚€ n).comp g hg)","decl":"@[simp, nolint simpNF] -- Porting note: LHS doesn't simplify.\ntheorem approxOn_comp {Î³ : Type*} [MeasurableSpace Î³] {f : Î² â†’ Î±} (hf : Measurable f) {g : Î³ â†’ Î²}\n    (hg : Measurable g) {s : Set Î±} {yâ‚€ : Î±} (hâ‚€ : yâ‚€ âˆˆ s) [SeparableSpace s] (n : â„•) :\n    approxOn (f âˆ˜ g) (hf.comp hg) s yâ‚€ hâ‚€ n = (approxOn f hf s yâ‚€ hâ‚€ n).comp g hg :=\n  rfl\n\n"}
{"name":"MeasureTheory.SimpleFunc.tendsto_approxOn","module":"Mathlib.MeasureTheory.Function.SimpleFuncDense","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœâ´ : MeasurableSpace Î±\ninstâœÂ³ : PseudoEMetricSpace Î±\ninstâœÂ² : OpensMeasurableSpace Î±\ninstâœÂ¹ : MeasurableSpace Î²\nf : Î² â†’ Î±\nhf : Measurable f\ns : Set Î±\nyâ‚€ : Î±\nhâ‚€ : Membership.mem s yâ‚€\ninstâœ : TopologicalSpace.SeparableSpace â†‘s\nx : Î²\nhx : Membership.mem (closure s) (f x)\nâŠ¢ Filter.Tendsto (fun n => (MeasureTheory.SimpleFunc.approxOn f hf s yâ‚€ hâ‚€ n) x) Filter.atTop (nhds (f x))","decl":"theorem tendsto_approxOn {f : Î² â†’ Î±} (hf : Measurable f) {s : Set Î±} {yâ‚€ : Î±} (hâ‚€ : yâ‚€ âˆˆ s)\n    [SeparableSpace s] {x : Î²} (hx : f x âˆˆ closure s) :\n    Tendsto (fun n => approxOn f hf s yâ‚€ hâ‚€ n x) atTop (ğ“ <| f x) := by\n  haveI : Nonempty s := âŸ¨âŸ¨yâ‚€, hâ‚€âŸ©âŸ©\n  rw [â† @Subtype.range_coe _ s, â† image_univ, â† (denseRange_denseSeq s).closure_eq] at hx\n  simp (config := { iota := false }) only [approxOn, coe_comp]\n  refine tendsto_nearestPt (closure_minimal ?_ isClosed_closure hx)\n  simp (config := { iota := false }) only [Nat.range_casesOn, closure_union, range_comp]\n  exact\n    Subset.trans (image_closure_subset_closure_image continuous_subtype_val)\n      subset_union_right\n\n"}
{"name":"MeasureTheory.SimpleFunc.edist_approxOn_mono","module":"Mathlib.MeasureTheory.Function.SimpleFuncDense","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœâ´ : MeasurableSpace Î±\ninstâœÂ³ : PseudoEMetricSpace Î±\ninstâœÂ² : OpensMeasurableSpace Î±\ninstâœÂ¹ : MeasurableSpace Î²\nf : Î² â†’ Î±\nhf : Measurable f\ns : Set Î±\nyâ‚€ : Î±\nhâ‚€ : Membership.mem s yâ‚€\ninstâœ : TopologicalSpace.SeparableSpace â†‘s\nx : Î²\nm n : Nat\nh : LE.le m n\nâŠ¢ LE.le (EDist.edist ((MeasureTheory.SimpleFunc.approxOn f hf s yâ‚€ hâ‚€ n) x) (f x)) (EDist.edist ((MeasureTheory.SimpleFunc.approxOn f hf s yâ‚€ hâ‚€ m) x) (f x))","decl":"theorem edist_approxOn_mono {f : Î² â†’ Î±} (hf : Measurable f) {s : Set Î±} {yâ‚€ : Î±} (hâ‚€ : yâ‚€ âˆˆ s)\n    [SeparableSpace s] (x : Î²) {m n : â„•} (h : m â‰¤ n) :\n    edist (approxOn f hf s yâ‚€ hâ‚€ n x) (f x) â‰¤ edist (approxOn f hf s yâ‚€ hâ‚€ m x) (f x) := by\n  dsimp only [approxOn, coe_comp, Function.comp_def]\n  exact edist_nearestPt_le _ _ ((nearestPtInd_le _ _ _).trans h)\n\n"}
{"name":"MeasureTheory.SimpleFunc.edist_approxOn_le","module":"Mathlib.MeasureTheory.Function.SimpleFuncDense","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœâ´ : MeasurableSpace Î±\ninstâœÂ³ : PseudoEMetricSpace Î±\ninstâœÂ² : OpensMeasurableSpace Î±\ninstâœÂ¹ : MeasurableSpace Î²\nf : Î² â†’ Î±\nhf : Measurable f\ns : Set Î±\nyâ‚€ : Î±\nhâ‚€ : Membership.mem s yâ‚€\ninstâœ : TopologicalSpace.SeparableSpace â†‘s\nx : Î²\nn : Nat\nâŠ¢ LE.le (EDist.edist ((MeasureTheory.SimpleFunc.approxOn f hf s yâ‚€ hâ‚€ n) x) (f x)) (EDist.edist yâ‚€ (f x))","decl":"theorem edist_approxOn_le {f : Î² â†’ Î±} (hf : Measurable f) {s : Set Î±} {yâ‚€ : Î±} (hâ‚€ : yâ‚€ âˆˆ s)\n    [SeparableSpace s] (x : Î²) (n : â„•) : edist (approxOn f hf s yâ‚€ hâ‚€ n x) (f x) â‰¤ edist yâ‚€ (f x) :=\n  edist_approxOn_mono hf hâ‚€ x (zero_le n)\n\n"}
{"name":"MeasureTheory.SimpleFunc.edist_approxOn_y0_le","module":"Mathlib.MeasureTheory.Function.SimpleFuncDense","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœâ´ : MeasurableSpace Î±\ninstâœÂ³ : PseudoEMetricSpace Î±\ninstâœÂ² : OpensMeasurableSpace Î±\ninstâœÂ¹ : MeasurableSpace Î²\nf : Î² â†’ Î±\nhf : Measurable f\ns : Set Î±\nyâ‚€ : Î±\nhâ‚€ : Membership.mem s yâ‚€\ninstâœ : TopologicalSpace.SeparableSpace â†‘s\nx : Î²\nn : Nat\nâŠ¢ LE.le (EDist.edist yâ‚€ ((MeasureTheory.SimpleFunc.approxOn f hf s yâ‚€ hâ‚€ n) x)) (HAdd.hAdd (EDist.edist yâ‚€ (f x)) (EDist.edist yâ‚€ (f x)))","decl":"theorem edist_approxOn_y0_le {f : Î² â†’ Î±} (hf : Measurable f) {s : Set Î±} {yâ‚€ : Î±} (hâ‚€ : yâ‚€ âˆˆ s)\n    [SeparableSpace s] (x : Î²) (n : â„•) :\n    edist yâ‚€ (approxOn f hf s yâ‚€ hâ‚€ n x) â‰¤ edist yâ‚€ (f x) + edist yâ‚€ (f x) :=\n  calc\n    edist yâ‚€ (approxOn f hf s yâ‚€ hâ‚€ n x) â‰¤\n        edist yâ‚€ (f x) + edist (approxOn f hf s yâ‚€ hâ‚€ n x) (f x) :=\n      edist_triangle_right _ _ _\n    _ â‰¤ edist yâ‚€ (f x) + edist yâ‚€ (f x) := add_le_add_left (edist_approxOn_le hf hâ‚€ x n) _\n\n"}
{"name":"HasCompactSupport.exists_simpleFunc_approx_of_prod","module":"Mathlib.MeasureTheory.Function.SimpleFuncDense","initialProofState":"X : Type u_7\nY : Type u_8\nÎ± : Type u_9\ninstâœâ· : Zero Î±\ninstâœâ¶ : TopologicalSpace X\ninstâœâµ : TopologicalSpace Y\ninstâœâ´ : MeasurableSpace X\ninstâœÂ³ : MeasurableSpace Y\ninstâœÂ² : OpensMeasurableSpace X\ninstâœÂ¹ : OpensMeasurableSpace Y\ninstâœ : PseudoMetricSpace Î±\nf : Prod X Y â†’ Î±\nhf : Continuous f\nh'f : HasCompactSupport f\nÎµ : Real\nhÎµ : LT.lt 0 Îµ\nâŠ¢ Exists fun g => âˆ€ (x : Prod X Y), LT.lt (Dist.dist (f x) (g x)) Îµ","decl":"/-- A continuous function with compact support on a product space can be uniformly approximated by\nsimple functions. The subtlety is that we do not assume that the spaces are separable, so the\nproduct of the Borel sigma algebras might not contain all open sets, but still it contains enough\nof them to approximate compactly supported continuous functions. -/\nlemma HasCompactSupport.exists_simpleFunc_approx_of_prod [PseudoMetricSpace Î±]\n    {f : X Ã— Y â†’ Î±} (hf : Continuous f) (h'f : HasCompactSupport f)\n    {Îµ : â„} (hÎµ : 0 < Îµ) :\n    âˆƒ (g : SimpleFunc (X Ã— Y) Î±), âˆ€ x, dist (f x) (g x) < Îµ := by\n  have M : âˆ€ (K : Set (X Ã— Y)), IsCompact K â†’\n      âˆƒ (g : SimpleFunc (X Ã— Y) Î±), âˆƒ (s : Set (X Ã— Y)), MeasurableSet s âˆ§ K âŠ† s âˆ§\n      âˆ€ x âˆˆ s, dist (f x) (g x) < Îµ := by\n    intro K hK\n    apply IsCompact.induction_on\n      (p := fun t â†¦ âˆƒ (g : SimpleFunc (X Ã— Y) Î±), âˆƒ (s : Set (X Ã— Y)), MeasurableSet s âˆ§ t âŠ† s âˆ§\n        âˆ€ x âˆˆ s, dist (f x) (g x) < Îµ) hK\n    Â· exact âŸ¨0, âˆ…, by simpâŸ©\n    Â· intro t t' htt' âŸ¨g, s, s_meas, ts, hgâŸ©\n      exact âŸ¨g, s, s_meas, htt'.trans ts, hgâŸ©\n    Â· intro t t' âŸ¨g, s, s_meas, ts, hgâŸ© âŸ¨g', s', s'_meas, t's', hg'âŸ©\n      refine âŸ¨g.piecewise s s_meas g', s âˆª s', s_meas.union s'_meas,\n        union_subset_union ts t's', fun p hp â†¦ ?_âŸ©\n      by_cases H : p âˆˆ s\n      Â· simpa [H, SimpleFunc.piecewise_apply] using hg p H\n      Â· simp only [SimpleFunc.piecewise_apply, H, ite_false]\n        apply hg'\n        simpa [H] using (mem_union _ _ _).1 hp\n    Â· rintro âŸ¨x, yâŸ© -\n      obtain âŸ¨u, v, hu, xu, hv, yv, huvâŸ© : âˆƒ u v, IsOpen u âˆ§ x âˆˆ u âˆ§ IsOpen v âˆ§ y âˆˆ v âˆ§\n        u Ã—Ë¢ v âŠ† {z | dist (f z) (f (x, y)) < Îµ} :=\n          mem_nhds_prod_iff'.1 <| Metric.continuousAt_iff'.1 hf.continuousAt Îµ hÎµ\n      refine âŸ¨u Ã—Ë¢ v, nhdsWithin_le_nhds <| (hu.prod hv).mem_nhds (mk_mem_prod xu yv), ?_âŸ©\n      exact âŸ¨SimpleFunc.const _ (f (x, y)), u Ã—Ë¢ v, hu.measurableSet.prod hv.measurableSet,\n        Subset.rfl, fun z hz â†¦ huv hzâŸ©\n  obtain âŸ¨g, s, s_meas, fs, hgâŸ© : âˆƒ (g : SimpleFunc (X Ã— Y) Î±) (s : Set (X Ã— Y)),\n    MeasurableSet s âˆ§ tsupport f âŠ† s âˆ§ âˆ€ (x : X Ã— Y), x âˆˆ s â†’ dist (f x) (g x) < Îµ := M _ h'f\n  refine âŸ¨g.piecewise s s_meas 0, fun p â†¦ ?_âŸ©\n  by_cases H : p âˆˆ s\n  Â· simpa [H, SimpleFunc.piecewise_apply] using hg p H\n  Â· have : f p = 0 := by\n      contrapose! H\n      rw [â† Function.mem_support] at H\n      exact fs (subset_tsupport _ H)\n    simp [SimpleFunc.piecewise_apply, H, ite_false, this, hÎµ]\n\n"}
{"name":"HasCompactSupport.measurable_of_prod","module":"Mathlib.MeasureTheory.Function.SimpleFuncDense","initialProofState":"X : Type u_7\nY : Type u_8\nÎ± : Type u_9\ninstâœÂ¹â° : Zero Î±\ninstâœâ¹ : TopologicalSpace X\ninstâœâ¸ : TopologicalSpace Y\ninstâœâ· : MeasurableSpace X\ninstâœâ¶ : MeasurableSpace Y\ninstâœâµ : OpensMeasurableSpace X\ninstâœâ´ : OpensMeasurableSpace Y\ninstâœÂ³ : TopologicalSpace Î±\ninstâœÂ² : TopologicalSpace.PseudoMetrizableSpace Î±\ninstâœÂ¹ : MeasurableSpace Î±\ninstâœ : BorelSpace Î±\nf : Prod X Y â†’ Î±\nhf : Continuous f\nh'f : HasCompactSupport f\nâŠ¢ Measurable f","decl":"/-- A continuous function with compact support on a product space is measurable for the product\nsigma-algebra. The subtlety is that we do not assume that the spaces are separable, so the\nproduct of the Borel sigma algebras might not contain all open sets, but still it contains enough\nof them to approximate compactly supported continuous functions. -/\nlemma HasCompactSupport.measurable_of_prod\n    [TopologicalSpace Î±] [PseudoMetrizableSpace Î±] [MeasurableSpace Î±] [BorelSpace Î±]\n    {f : X Ã— Y â†’ Î±} (hf : Continuous f) (h'f : HasCompactSupport f) :\n    Measurable f := by\n  letI : PseudoMetricSpace Î± := TopologicalSpace.pseudoMetrizableSpacePseudoMetric Î±\n  obtain âŸ¨u, -, u_pos, u_limâŸ© : âˆƒ u, StrictAnti u âˆ§ (âˆ€ (n : â„•), 0 < u n) âˆ§ Tendsto u atTop (ğ“ 0) :=\n    exists_seq_strictAnti_tendsto (0 : â„)\n  have : âˆ€ n, âˆƒ (g : SimpleFunc (X Ã— Y) Î±), âˆ€ x, dist (f x) (g x) < u n :=\n    fun n â†¦ h'f.exists_simpleFunc_approx_of_prod hf (u_pos n)\n  choose g hg using this\n  have A : âˆ€ x, Tendsto (fun n â†¦ g n x) atTop (ğ“ (f x)) := by\n    intro x\n    rw [tendsto_iff_dist_tendsto_zero]\n    apply squeeze_zero (fun n â†¦ dist_nonneg) (fun n â†¦ ?_) u_lim\n    rw [dist_comm]\n    exact (hg n x).le\n  apply measurable_of_tendsto_metrizable (fun n â†¦ (g n).measurable) (tendsto_pi_nhds.2 A)\n\n"}
