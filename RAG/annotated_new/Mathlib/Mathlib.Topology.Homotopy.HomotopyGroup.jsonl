{"name":"Cube.insertAt_boundary","module":"Mathlib.Topology.Homotopy.HomotopyGroup","initialProofState":"N : Type u_1\ninst✝ : DecidableEq N\ni : N\nt₀ : ↑unitInterval\nt : (Subtype fun j => Ne j i) → ↑unitInterval\nH : Or (Or (Eq t₀ 0) (Eq t₀ 1)) (Membership.mem (Cube.boundary (Subtype fun j => Ne j i)) t)\n⊢ Membership.mem (Cube.boundary N) ((Cube.insertAt i) { fst := t₀, snd := t })","decl":"theorem insertAt_boundary (i : N) {t₀ : I} {t}\n    (H : (t₀ = 0 ∨ t₀ = 1) ∨ t ∈ boundary { j // j ≠ i }) : insertAt i ⟨t₀, t⟩ ∈ boundary N := by\n  obtain H | ⟨j, H⟩ := H\n  · use i; rwa [funSplitAt_symm_apply, dif_pos rfl]\n  · use j; rwa [funSplitAt_symm_apply, dif_neg j.prop, Subtype.coe_eta]\n\n"}
{"name":"GenLoop.ext_iff","module":"Mathlib.Topology.Homotopy.HomotopyGroup","initialProofState":"N : Type u_1\nX : Type u_2\ninst✝ : TopologicalSpace X\nx : X\nf g : ↑(GenLoop N X x)\n⊢ Iff (Eq f g) (∀ (y : N → ↑unitInterval), Eq (f y) (g y))","decl":"@[ext]\ntheorem ext (f g : Ω^ N X x) (H : ∀ y, f y = g y) : f = g :=\n  DFunLike.coe_injective' (funext H)\n\n"}
{"name":"GenLoop.ext","module":"Mathlib.Topology.Homotopy.HomotopyGroup","initialProofState":"N : Type u_1\nX : Type u_2\ninst✝ : TopologicalSpace X\nx : X\nf g : ↑(GenLoop N X x)\nH : ∀ (y : N → ↑unitInterval), Eq (f y) (g y)\n⊢ Eq f g","decl":"@[ext]\ntheorem ext (f g : Ω^ N X x) (H : ∀ y, f y = g y) : f = g :=\n  DFunLike.coe_injective' (funext H)\n\n"}
{"name":"GenLoop.mk_apply","module":"Mathlib.Topology.Homotopy.HomotopyGroup","initialProofState":"N : Type u_1\nX : Type u_2\ninst✝ : TopologicalSpace X\nx : X\nf : ContinuousMap (N → ↑unitInterval) X\nH : Membership.mem (GenLoop N X x) f\ny : N → ↑unitInterval\n⊢ Eq (⟨f, H⟩ y) (f y)","decl":"@[simp]\ntheorem mk_apply (f : C(I^N, X)) (H y) : (⟨f, H⟩ : Ω^ N X x) y = f y :=\n  rfl\n\n"}
{"name":"GenLoop.instContinuousEval","module":"Mathlib.Topology.Homotopy.HomotopyGroup","initialProofState":"N : Type u_1\nX : Type u_2\ninst✝ : TopologicalSpace X\nx : X\n⊢ ContinuousEval (↑(GenLoop N X x)) (N → ↑unitInterval) X","decl":"instance instContinuousEval : ContinuousEval (Ω^ N X x) (I^N) X :=\n  .of_continuous_forget continuous_subtype_val\n\n"}
{"name":"GenLoop.instContinuousEvalConst","module":"Mathlib.Topology.Homotopy.HomotopyGroup","initialProofState":"N : Type u_1\nX : Type u_2\ninst✝ : TopologicalSpace X\nx : X\n⊢ ContinuousEvalConst (↑(GenLoop N X x)) (N → ↑unitInterval) X","decl":"instance instContinuousEvalConst : ContinuousEvalConst (Ω^ N X x) (I^N) X := inferInstance\n\n"}
{"name":"GenLoop.coe_copy","module":"Mathlib.Topology.Homotopy.HomotopyGroup","initialProofState":"N : Type u_1\nX : Type u_2\ninst✝ : TopologicalSpace X\nx : X\nf : ↑(GenLoop N X x)\ng : (N → ↑unitInterval) → X\nh : Eq g ⇑f\n⊢ Eq (⇑(GenLoop.copy f g h)) g","decl":"theorem coe_copy (f : Ω^ N X x) {g : (I^N) → X} (h : g = f) : ⇑(copy f g h) = g :=\n  rfl\n\n"}
{"name":"GenLoop.copy_eq","module":"Mathlib.Topology.Homotopy.HomotopyGroup","initialProofState":"N : Type u_1\nX : Type u_2\ninst✝ : TopologicalSpace X\nx : X\nf : ↑(GenLoop N X x)\ng : (N → ↑unitInterval) → X\nh : Eq g ⇑f\n⊢ Eq (GenLoop.copy f g h) f","decl":"theorem copy_eq (f : Ω^ N X x) {g : (I^N) → X} (h : g = f) : copy f g h = f := by\n  ext x\n  exact congr_fun h x\n\n"}
{"name":"GenLoop.boundary","module":"Mathlib.Topology.Homotopy.HomotopyGroup","initialProofState":"N : Type u_1\nX : Type u_2\ninst✝ : TopologicalSpace X\nx : X\nf : ↑(GenLoop N X x)\ny : N → ↑unitInterval\na✝ : Membership.mem (Cube.boundary N) y\n⊢ Eq (f y) x","decl":"theorem boundary (f : Ω^ N X x) : ∀ y ∈ Cube.boundary N, f y = x :=\n  f.2\n\n"}
{"name":"GenLoop.const_apply","module":"Mathlib.Topology.Homotopy.HomotopyGroup","initialProofState":"N : Type u_1\nX : Type u_2\ninst✝ : TopologicalSpace X\nx : X\nt : N → ↑unitInterval\n⊢ Eq (GenLoop.const t) x","decl":"@[simp]\ntheorem const_apply {t} : (@const N X _ x) t = x :=\n  rfl\n\n"}
{"name":"GenLoop.Homotopic.refl","module":"Mathlib.Topology.Homotopy.HomotopyGroup","initialProofState":"N : Type u_1\nX : Type u_2\ninst✝ : TopologicalSpace X\nx : X\nf : ↑(GenLoop N X x)\n⊢ GenLoop.Homotopic f f","decl":"@[refl]\ntheorem refl (f : Ω^ N X x) : Homotopic f f :=\n  ContinuousMap.HomotopicRel.refl _\n\n"}
{"name":"GenLoop.Homotopic.symm","module":"Mathlib.Topology.Homotopy.HomotopyGroup","initialProofState":"N : Type u_1\nX : Type u_2\ninst✝ : TopologicalSpace X\nx : X\nf g : ↑(GenLoop N X x)\nH : GenLoop.Homotopic f g\n⊢ GenLoop.Homotopic g f","decl":"@[symm]\nnonrec theorem symm (H : Homotopic f g) : Homotopic g f :=\n  H.symm\n\n"}
{"name":"GenLoop.Homotopic.trans","module":"Mathlib.Topology.Homotopy.HomotopyGroup","initialProofState":"N : Type u_1\nX : Type u_2\ninst✝ : TopologicalSpace X\nx : X\nf g h : ↑(GenLoop N X x)\nH0 : GenLoop.Homotopic f g\nH1 : GenLoop.Homotopic g h\n⊢ GenLoop.Homotopic f h","decl":"@[trans]\nnonrec theorem trans (H0 : Homotopic f g) (H1 : Homotopic g h) : Homotopic f h :=\n  H0.trans H1\n\n"}
{"name":"GenLoop.Homotopic.equiv","module":"Mathlib.Topology.Homotopy.HomotopyGroup","initialProofState":"N : Type u_1\nX : Type u_2\ninst✝ : TopologicalSpace X\nx : X\n⊢ Equivalence GenLoop.Homotopic","decl":"theorem equiv : Equivalence (@Homotopic N X _ x) :=\n  ⟨Homotopic.refl, Homotopic.symm, Homotopic.trans⟩\n\n"}
{"name":"GenLoop.toLoop_apply_coe","module":"Mathlib.Topology.Homotopy.HomotopyGroup","initialProofState":"N : Type u_1\nX : Type u_2\ninst✝¹ : TopologicalSpace X\nx : X\ninst✝ : DecidableEq N\ni : N\np : ↑(GenLoop N X x)\nt : ↑unitInterval\n⊢ Eq (↑((GenLoop.toLoop i p) t)) (((↑p).comp ↑(Cube.insertAt i)).curry t)","decl":"/-- Loop from a generalized loop by currying $I^N → X$ into $I → (I^{N\\setminus\\{j\\}} → X)$. -/\n@[simps]\ndef toLoop (i : N) (p : Ω^ N X x) : Ω (Ω^ { j // j ≠ i } X x) const where\n  toFun t :=\n    ⟨(p.val.comp (Cube.insertAt i)).curry t, fun y yH =>\n      p.property (Cube.insertAt i (t, y)) (Cube.insertAt_boundary i <| Or.inr yH)⟩\n  source' := by ext t; refine p.property (Cube.insertAt i (0, t)) ⟨i, Or.inl ?_⟩; simp\n  target' := by ext t; refine p.property (Cube.insertAt i (1, t)) ⟨i, Or.inr ?_⟩; simp\n\n\n"}
{"name":"GenLoop.continuous_toLoop","module":"Mathlib.Topology.Homotopy.HomotopyGroup","initialProofState":"N : Type u_1\nX : Type u_2\ninst✝¹ : TopologicalSpace X\nx : X\ninst✝ : DecidableEq N\ni : N\n⊢ Continuous (GenLoop.toLoop i)","decl":"theorem continuous_toLoop (i : N) : Continuous (@toLoop N X _ x _ i) :=\n  Path.continuous_uncurry_iff.1 <|\n    Continuous.subtype_mk\n      (continuous_eval.comp <|\n        Continuous.prodMap\n          (ContinuousMap.continuous_curry.comp <|\n            (ContinuousMap.continuous_precomp _).comp continuous_subtype_val)\n          continuous_id)\n      _\n\n"}
{"name":"GenLoop.fromLoop_coe","module":"Mathlib.Topology.Homotopy.HomotopyGroup","initialProofState":"N : Type u_1\nX : Type u_2\ninst✝¹ : TopologicalSpace X\nx : X\ninst✝ : DecidableEq N\ni : N\np : LoopSpace (↑(GenLoop (Subtype fun j => Ne j i) X x)) GenLoop.const\n⊢ Eq (↑(GenLoop.fromLoop i p)) (({ toFun := Subtype.val, continuous_toFun := ⋯ }.comp p.toContinuousMap).uncurry.comp ↑(Cube.splitAt i))","decl":"/-- Generalized loop from a loop by uncurrying $I → (I^{N\\setminus\\{j\\}} → X)$ into $I^N → X$. -/\n@[simps]\ndef fromLoop (i : N) (p : Ω (Ω^ { j // j ≠ i } X x) const) : Ω^ N X x :=\n  ⟨(ContinuousMap.comp ⟨Subtype.val, by fun_prop⟩ p.toContinuousMap).uncurry.comp\n    (Cube.splitAt i),\n    by\n    rintro y ⟨j, Hj⟩\n    simp only [ContinuousMap.comp_apply, ContinuousMap.coe_coe,\n      funSplitAt_apply, ContinuousMap.uncurry_apply, ContinuousMap.coe_mk,\n      Function.uncurry_apply_pair]\n    obtain rfl | Hne := eq_or_ne j i\n    · cases' Hj with Hj Hj <;> simp only [Hj, p.coe_toContinuousMap, p.source, p.target] <;> rfl\n    · exact GenLoop.boundary _ _ ⟨⟨j, Hne⟩, Hj⟩⟩\n\n"}
{"name":"GenLoop.continuous_fromLoop","module":"Mathlib.Topology.Homotopy.HomotopyGroup","initialProofState":"N : Type u_1\nX : Type u_2\ninst✝¹ : TopologicalSpace X\nx : X\ninst✝ : DecidableEq N\ni : N\n⊢ Continuous (GenLoop.fromLoop i)","decl":"theorem continuous_fromLoop (i : N) : Continuous (@fromLoop N X _ x _ i) :=\n  ((ContinuousMap.continuous_precomp _).comp <|\n        ContinuousMap.continuous_uncurry.comp <|\n          (ContinuousMap.continuous_postcomp _).comp continuous_induced_dom).subtype_mk\n    _\n\n"}
{"name":"GenLoop.to_from","module":"Mathlib.Topology.Homotopy.HomotopyGroup","initialProofState":"N : Type u_1\nX : Type u_2\ninst✝¹ : TopologicalSpace X\nx : X\ninst✝ : DecidableEq N\ni : N\np : LoopSpace (↑(GenLoop (Subtype fun j => Ne j i) X x)) GenLoop.const\n⊢ Eq (GenLoop.toLoop i (GenLoop.fromLoop i p)) p","decl":"theorem to_from (i : N) (p : Ω (Ω^ { j // j ≠ i } X x) const) : toLoop i (fromLoop i p) = p := by\n  simp_rw [toLoop, fromLoop, ContinuousMap.comp_assoc,\n    toContinuousMap_comp_symm, ContinuousMap.comp_id]\n  ext; rfl\n\n"}
{"name":"GenLoop.loopHomeo_symm_apply","module":"Mathlib.Topology.Homotopy.HomotopyGroup","initialProofState":"N : Type u_1\nX : Type u_2\ninst✝¹ : TopologicalSpace X\nx : X\ninst✝ : DecidableEq N\ni : N\np : LoopSpace (↑(GenLoop (Subtype fun j => Ne j i) X x)) GenLoop.const\n⊢ Eq ((GenLoop.loopHomeo i).symm p) (GenLoop.fromLoop i p)","decl":"/-- The `n+1`-dimensional loops are in bijection with the loops in the space of\n  `n`-dimensional loops with base point `const`.\n  We allow an arbitrary indexing type `N` in place of `Fin n` here. -/\n@[simps]\ndef loopHomeo (i : N) : Ω^ N X x ≃ₜ Ω (Ω^ { j // j ≠ i } X x) const where\n  toFun := toLoop i\n  invFun := fromLoop i\n  left_inv p := by ext; exact congr_arg p (by dsimp; exact Equiv.apply_symm_apply _ _)\n  right_inv := to_from i\n  continuous_toFun := continuous_toLoop i\n  continuous_invFun := continuous_fromLoop i\n\n"}
{"name":"GenLoop.loopHomeo_apply","module":"Mathlib.Topology.Homotopy.HomotopyGroup","initialProofState":"N : Type u_1\nX : Type u_2\ninst✝¹ : TopologicalSpace X\nx : X\ninst✝ : DecidableEq N\ni : N\np : ↑(GenLoop N X x)\n⊢ Eq ((GenLoop.loopHomeo i) p) (GenLoop.toLoop i p)","decl":"/-- The `n+1`-dimensional loops are in bijection with the loops in the space of\n  `n`-dimensional loops with base point `const`.\n  We allow an arbitrary indexing type `N` in place of `Fin n` here. -/\n@[simps]\ndef loopHomeo (i : N) : Ω^ N X x ≃ₜ Ω (Ω^ { j // j ≠ i } X x) const where\n  toFun := toLoop i\n  invFun := fromLoop i\n  left_inv p := by ext; exact congr_arg p (by dsimp; exact Equiv.apply_symm_apply _ _)\n  right_inv := to_from i\n  continuous_toFun := continuous_toLoop i\n  continuous_invFun := continuous_fromLoop i\n\n"}
{"name":"GenLoop.toLoop_apply","module":"Mathlib.Topology.Homotopy.HomotopyGroup","initialProofState":"N : Type u_1\nX : Type u_2\ninst✝¹ : TopologicalSpace X\nx : X\ninst✝ : DecidableEq N\ni : N\np : ↑(GenLoop N X x)\nt : ↑unitInterval\ntn : (Subtype fun j => Ne j i) → ↑unitInterval\n⊢ Eq (((GenLoop.toLoop i p) t) tn) (p ((Cube.insertAt i) { fst := t, snd := tn }))","decl":"theorem toLoop_apply (i : N) {p : Ω^ N X x} {t} {tn} :\n    toLoop i p t tn = p (Cube.insertAt i ⟨t, tn⟩) :=\n  rfl\n\n"}
{"name":"GenLoop.fromLoop_apply","module":"Mathlib.Topology.Homotopy.HomotopyGroup","initialProofState":"N : Type u_1\nX : Type u_2\ninst✝¹ : TopologicalSpace X\nx : X\ninst✝ : DecidableEq N\ni : N\np : LoopSpace (↑(GenLoop (Subtype fun j => Ne j i) X x)) GenLoop.const\nt : N → ↑unitInterval\n⊢ Eq ((GenLoop.fromLoop i p) t) ((p (t i)) ((Cube.splitAt i) t).2)","decl":"theorem fromLoop_apply (i : N) {p : Ω (Ω^ { j // j ≠ i } X x) const} {t : I^N} :\n    fromLoop i p t = p (t i) (Cube.splitAt i t).snd :=\n  rfl\n\n"}
{"name":"GenLoop.homotopyTo_apply","module":"Mathlib.Topology.Homotopy.HomotopyGroup","initialProofState":"N : Type u_1\nX : Type u_2\ninst✝¹ : TopologicalSpace X\nx : X\ninst✝ : DecidableEq N\ni : N\np q : ↑(GenLoop N X x)\nH : (↑p).HomotopyRel (↑q) (Cube.boundary N)\nt : Prod ↑unitInterval ↑unitInterval\ntₙ : (Subtype fun j => Ne j i) → ↑unitInterval\n⊢ Eq (((GenLoop.homotopyTo i H) t) tₙ) (H { fst := t.1, snd := (Cube.insertAt i) { fst := t.2, snd := tₙ } })","decl":"theorem homotopyTo_apply (i : N) {p q : Ω^ N X x} (H : p.1.HomotopyRel q.1 <| Cube.boundary N)\n    (t : I × I) (tₙ : I^{ j // j ≠ i }) :\n    homotopyTo i H t tₙ = H (t.fst, Cube.insertAt i (t.snd, tₙ)) :=\n  rfl\n\n"}
{"name":"GenLoop.homotopicTo","module":"Mathlib.Topology.Homotopy.HomotopyGroup","initialProofState":"N : Type u_1\nX : Type u_2\ninst✝¹ : TopologicalSpace X\nx : X\ninst✝ : DecidableEq N\ni : N\np q : ↑(GenLoop N X x)\na✝ : GenLoop.Homotopic p q\n⊢ Path.Homotopic (GenLoop.toLoop i p) (GenLoop.toLoop i q)","decl":"theorem homotopicTo (i : N) {p q : Ω^ N X x} :\n    Homotopic p q → (toLoop i p).Homotopic (toLoop i q) := by\n  refine Nonempty.map fun H => ⟨⟨⟨fun t => ⟨homotopyTo i H t, ?_⟩, ?_⟩, ?_, ?_⟩, ?_⟩\n  · rintro y ⟨i, iH⟩\n    rw [homotopyTo_apply, H.eq_fst, p.2]\n    all_goals apply Cube.insertAt_boundary; right; exact ⟨i, iH⟩\n  · continuity\n  iterate 2 intro; ext; erw [homotopyTo_apply, toLoop_apply]; swap\n  · apply H.apply_zero\n  · apply H.apply_one\n  intro t y yH\n  ext; erw [homotopyTo_apply]\n  apply H.eq_fst; use i\n  rw [funSplitAt_symm_apply, dif_pos rfl]; exact yH\n\n"}
{"name":"GenLoop.homotopyFrom_apply","module":"Mathlib.Topology.Homotopy.HomotopyGroup","initialProofState":"N : Type u_1\nX : Type u_2\ninst✝¹ : TopologicalSpace X\nx : X\ninst✝ : DecidableEq N\ni : N\np q : ↑(GenLoop N X x)\nH : Path.Homotopy (GenLoop.toLoop i p) (GenLoop.toLoop i q)\na✝ : Prod (↑unitInterval) (N → ↑unitInterval)\n⊢ Eq ((GenLoop.homotopyFrom i H) a✝) (Function.uncurry (fun x_1 y => Function.uncurry (fun x_2 y => ↑(H { fst := x_1, snd := x_2 }) y) y) (Prod.map id (⇑(Cube.splitAt i)) a✝))","decl":"/-- The converse to `GenLoop.homotopyTo`: a homotopy between two loops in the space of\n  `n`-dimensional loops can be seen as a homotopy between two `n+1`-dimensional paths. -/\n@[simps!] def homotopyFrom (i : N) {p q : Ω^ N X x} (H : (toLoop i p).Homotopy (toLoop i q)) :\n    C(I × I^N, X) :=\n  (ContinuousMap.comp ⟨_, ContinuousMap.continuous_uncurry⟩\n          (ContinuousMap.comp ⟨Subtype.val, by continuity⟩ H.toContinuousMap).curry).uncurry.comp <|\n    (ContinuousMap.id I).prodMap (Cube.splitAt i)\n\n"}
{"name":"GenLoop.homotopicFrom","module":"Mathlib.Topology.Homotopy.HomotopyGroup","initialProofState":"N : Type u_1\nX : Type u_2\ninst✝¹ : TopologicalSpace X\nx : X\ninst✝ : DecidableEq N\ni : N\np q : ↑(GenLoop N X x)\na✝ : Path.Homotopic (GenLoop.toLoop i p) (GenLoop.toLoop i q)\n⊢ GenLoop.Homotopic p q","decl":"theorem homotopicFrom (i : N) {p q : Ω^ N X x} :\n    (toLoop i p).Homotopic (toLoop i q) → Homotopic p q := by\n  refine Nonempty.map fun H => ⟨⟨homotopyFrom i H, ?_, ?_⟩, ?_⟩\n  pick_goal 3\n  · rintro t y ⟨j, jH⟩\n    erw [homotopyFrom_apply]\n    obtain rfl | h := eq_or_ne j i\n    · simp only [Prod.map_apply, id_eq, funSplitAt_apply, Function.uncurry_apply_pair]\n      rw [H.eq_fst]\n      exacts [congr_arg p ((Cube.splitAt j).left_inv _), jH]\n    · rw [p.2 _ ⟨j, jH⟩]; apply boundary; exact ⟨⟨j, h⟩, jH⟩\n  all_goals\n    intro\n    apply (homotopyFrom_apply _ _ _).trans\n    simp only [Prod.map_apply, id_eq, funSplitAt_apply,\n      Function.uncurry_apply_pair, ContinuousMap.HomotopyWith.apply_zero,\n      ContinuousMap.HomotopyWith.apply_one, ne_eq, Path.coe_toContinuousMap, toLoop_apply_coe,\n      ContinuousMap.curry_apply, ContinuousMap.comp_apply]\n    first\n    | apply congr_arg p\n    | apply congr_arg q\n    apply (Cube.splitAt i).left_inv\n\n"}
{"name":"GenLoop.transAt_distrib","module":"Mathlib.Topology.Homotopy.HomotopyGroup","initialProofState":"N : Type u_1\nX : Type u_2\ninst✝¹ : TopologicalSpace X\nx : X\ninst✝ : DecidableEq N\ni j : N\nh : Ne i j\na b c d : ↑(GenLoop N X x)\n⊢ Eq (GenLoop.transAt i (GenLoop.transAt j a b) (GenLoop.transAt j c d)) (GenLoop.transAt j (GenLoop.transAt i a c) (GenLoop.transAt i b d))","decl":"theorem transAt_distrib {i j : N} (h : i ≠ j) (a b c d : Ω^ N X x) :\n    transAt i (transAt j a b) (transAt j c d) = transAt j (transAt i a c) (transAt i b d) := by\n  ext; simp_rw [transAt, coe_copy, Function.update_apply, if_neg h, if_neg h.symm]\n  split_ifs <;>\n    · congr 1; ext1; simp only [Function.update, eq_rec_constant, dite_eq_ite]\n      apply ite_ite_comm; rintro rfl; exact h.symm\n\n"}
{"name":"GenLoop.fromLoop_trans_toLoop","module":"Mathlib.Topology.Homotopy.HomotopyGroup","initialProofState":"N : Type u_1\nX : Type u_2\ninst✝¹ : TopologicalSpace X\nx : X\ninst✝ : DecidableEq N\ni : N\np q : ↑(GenLoop N X x)\n⊢ Eq (GenLoop.fromLoop i (Path.trans (GenLoop.toLoop i p) (GenLoop.toLoop i q))) (GenLoop.transAt i p q)","decl":"theorem fromLoop_trans_toLoop {i : N} {p q : Ω^ N X x} :\n    fromLoop i ((toLoop i p).trans <| toLoop i q) = transAt i p q :=\n  (copy_eq _ _).symm\n\n"}
{"name":"GenLoop.fromLoop_symm_toLoop","module":"Mathlib.Topology.Homotopy.HomotopyGroup","initialProofState":"N : Type u_1\nX : Type u_2\ninst✝¹ : TopologicalSpace X\nx : X\ninst✝ : DecidableEq N\ni : N\np : ↑(GenLoop N X x)\n⊢ Eq (GenLoop.fromLoop i (Path.symm (GenLoop.toLoop i p))) (GenLoop.symmAt i p)","decl":"theorem fromLoop_symm_toLoop {i : N} {p : Ω^ N X x} : fromLoop i (toLoop i p).symm = symmAt i p :=\n  (copy_eq _ _).symm\n\n"}
{"name":"HomotopyGroup.isUnital_auxGroup","module":"Mathlib.Topology.Homotopy.HomotopyGroup","initialProofState":"N : Type u_1\nX : Type u_2\ninst✝¹ : TopologicalSpace X\nx : X\ninst✝ : DecidableEq N\ni : N\n⊢ EckmannHilton.IsUnital Mul.mul (Quotient.mk (GenLoop.Homotopic.setoid N x) GenLoop.const)","decl":"theorem isUnital_auxGroup (i : N) :\n    EckmannHilton.IsUnital (auxGroup i).mul (⟦const⟧ : HomotopyGroup N X x) where\n  left_id := (auxGroup i).one_mul\n  right_id := (auxGroup i).mul_one\n\n"}
{"name":"HomotopyGroup.auxGroup_indep","module":"Mathlib.Topology.Homotopy.HomotopyGroup","initialProofState":"N : Type u_1\nX : Type u_2\ninst✝¹ : TopologicalSpace X\nx : X\ninst✝ : DecidableEq N\ni j : N\n⊢ Eq (HomotopyGroup.auxGroup i) (HomotopyGroup.auxGroup j)","decl":"theorem auxGroup_indep (i j : N) : (auxGroup i : Group (HomotopyGroup N X x)) = auxGroup j := by\n  by_cases h : i = j; · rw [h]\n  refine Group.ext (EckmannHilton.mul (isUnital_auxGroup i) (isUnital_auxGroup j) ?_)\n  rintro ⟨a⟩ ⟨b⟩ ⟨c⟩ ⟨d⟩\n  change Quotient.mk' _ = _\n  apply congr_arg Quotient.mk'\n  simp only [fromLoop_trans_toLoop, transAt_distrib h, coe_toEquiv, loopHomeo_apply,\n    coe_symm_toEquiv, loopHomeo_symm_apply]\n\n"}
{"name":"HomotopyGroup.transAt_indep","module":"Mathlib.Topology.Homotopy.HomotopyGroup","initialProofState":"N : Type u_1\nX : Type u_2\ninst✝¹ : TopologicalSpace X\nx : X\ninst✝ : DecidableEq N\ni j : N\nf g : ↑(GenLoop N X x)\n⊢ Eq (Quotient.mk (GenLoop.Homotopic.setoid N x) (GenLoop.transAt i f g)) (Quotient.mk (GenLoop.Homotopic.setoid N x) (GenLoop.transAt j f g))","decl":"theorem transAt_indep {i} (j) (f g : Ω^ N X x) :\n    (⟦transAt i f g⟧ : HomotopyGroup N X x) = ⟦transAt j f g⟧ := by\n  simp_rw [← fromLoop_trans_toLoop]\n  let m := fun (G) (_ : Group G) => ((· * ·) : G → G → G)\n  exact congr_fun₂ (congr_arg (m <| HomotopyGroup N X x) <| auxGroup_indep i j) ⟦g⟧ ⟦f⟧\n\n"}
{"name":"HomotopyGroup.symmAt_indep","module":"Mathlib.Topology.Homotopy.HomotopyGroup","initialProofState":"N : Type u_1\nX : Type u_2\ninst✝¹ : TopologicalSpace X\nx : X\ninst✝ : DecidableEq N\ni j : N\nf : ↑(GenLoop N X x)\n⊢ Eq (Quotient.mk (GenLoop.Homotopic.setoid N x) (GenLoop.symmAt i f)) (Quotient.mk (GenLoop.Homotopic.setoid N x) (GenLoop.symmAt j f))","decl":"theorem symmAt_indep {i} (j) (f : Ω^ N X x) :\n    (⟦symmAt i f⟧ : HomotopyGroup N X x) = ⟦symmAt j f⟧ := by\n  simp_rw [← fromLoop_symm_toLoop]\n  let inv := fun (G) (_ : Group G) => ((·⁻¹) : G → G)\n  exact congr_fun (congr_arg (inv <| HomotopyGroup N X x) <| auxGroup_indep i j) ⟦f⟧\n\n"}
{"name":"HomotopyGroup.one_def","module":"Mathlib.Topology.Homotopy.HomotopyGroup","initialProofState":"N : Type u_1\nX : Type u_2\ninst✝² : TopologicalSpace X\nx : X\ninst✝¹ : DecidableEq N\ninst✝ : Nonempty N\n⊢ Eq 1 (Quotient.mk (GenLoop.Homotopic.setoid N x) GenLoop.const)","decl":"/-- Characterization of multiplicative identity -/\ntheorem one_def [Nonempty N] : (1 : HomotopyGroup N X x) = ⟦const⟧ :=\n  rfl\n\n"}
{"name":"HomotopyGroup.mul_spec","module":"Mathlib.Topology.Homotopy.HomotopyGroup","initialProofState":"N : Type u_1\nX : Type u_2\ninst✝² : TopologicalSpace X\nx : X\ninst✝¹ : DecidableEq N\ninst✝ : Nonempty N\ni : N\np q : ↑(GenLoop N X x)\n⊢ Eq ((fun x1 x2 => HMul.hMul x1 x2) (Quotient.mk (GenLoop.Homotopic.setoid N x) p) (Quotient.mk (GenLoop.Homotopic.setoid N x) q)) (Quotient.mk (GenLoop.Homotopic.setoid N x) (GenLoop.transAt i q p))","decl":"/-- Characterization of multiplication -/\ntheorem mul_spec [Nonempty N] {i} {p q : Ω^ N X x} :\n    -- Porting note (https://github.com/leanprover-community/mathlib4/issues/11215): TODO: introduce `HomotopyGroup.mk` and remove defeq abuse.\n    ((· * ·) : _ → _ → HomotopyGroup N X x) ⟦p⟧ ⟦q⟧ = ⟦transAt i q p⟧ := by\n  rw [transAt_indep (Classical.arbitrary N) q, ← fromLoop_trans_toLoop]\n  apply Quotient.sound\n  rfl\n\n"}
{"name":"HomotopyGroup.inv_spec","module":"Mathlib.Topology.Homotopy.HomotopyGroup","initialProofState":"N : Type u_1\nX : Type u_2\ninst✝² : TopologicalSpace X\nx : X\ninst✝¹ : DecidableEq N\ninst✝ : Nonempty N\ni : N\np : ↑(GenLoop N X x)\n⊢ Eq (Inv.inv (Quotient.mk (GenLoop.Homotopic.setoid N x) p)) (Quotient.mk (GenLoop.Homotopic.setoid N x) (GenLoop.symmAt i p))","decl":"/-- Characterization of multiplicative inverse -/\ntheorem inv_spec [Nonempty N] {i} {p : Ω^ N X x} :\n    ((⟦p⟧)⁻¹ : HomotopyGroup N X x) = ⟦symmAt i p⟧ := by\n  rw [symmAt_indep (Classical.arbitrary N) p, ← fromLoop_symm_toLoop]\n  apply Quotient.sound\n  rfl\n\n"}
