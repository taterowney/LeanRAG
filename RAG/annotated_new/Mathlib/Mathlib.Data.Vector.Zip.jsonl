{"name":"List.Vector.zipWith_toList","module":"Mathlib.Data.Vector.Zip","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nn : Nat\nf : α → β → γ\nx : List.Vector α n\ny : List.Vector β n\n⊢ Eq (List.Vector.zipWith f x y).toList (List.zipWith f x.toList y.toList)","decl":"@[simp]\ntheorem zipWith_toList (x : Vector α n) (y : Vector β n) :\n    (Vector.zipWith f x y).toList = List.zipWith f x.toList y.toList :=\n  rfl\n\n"}
{"name":"List.Vector.zipWith_get","module":"Mathlib.Data.Vector.Zip","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nn : Nat\nf : α → β → γ\nx : List.Vector α n\ny : List.Vector β n\ni : Fin n\n⊢ Eq ((List.Vector.zipWith f x y).get i) (f (x.get i) (y.get i))","decl":"@[simp]\ntheorem zipWith_get (x : Vector α n) (y : Vector β n) (i) :\n    (Vector.zipWith f x y).get i = f (x.get i) (y.get i) := by\n  dsimp only [Vector.zipWith, Vector.get]\n  simp\n\n"}
{"name":"List.Vector.zipWith_tail","module":"Mathlib.Data.Vector.Zip","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nn : Nat\nf : α → β → γ\nx : List.Vector α n\ny : List.Vector β n\n⊢ Eq (List.Vector.zipWith f x y).tail (List.Vector.zipWith f x.tail y.tail)","decl":"@[simp]\ntheorem zipWith_tail (x : Vector α n) (y : Vector β n) :\n    (Vector.zipWith f x y).tail = Vector.zipWith f x.tail y.tail := by\n  ext\n  simp [get_tail]\n\n"}
{"name":"List.Vector.sum_add_sum_eq_sum_zipWith","module":"Mathlib.Data.Vector.Zip","initialProofState":"α : Type u_1\nn : Nat\ninst✝ : AddCommMonoid α\nx y : List.Vector α n\n⊢ Eq (HAdd.hAdd x.toList.sum y.toList.sum) (List.Vector.zipWith (fun x1 x2 => HAdd.hAdd x1 x2) x y).toList.sum","decl":"@[to_additive]\ntheorem prod_mul_prod_eq_prod_zipWith [CommMonoid α] (x y : Vector α n) :\n    x.toList.prod * y.toList.prod = (Vector.zipWith (· * ·) x y).toList.prod :=\n  List.prod_mul_prod_eq_prod_zipWith_of_length_eq x.toList y.toList\n    ((toList_length x).trans (toList_length y).symm)\n\n"}
{"name":"List.Vector.prod_mul_prod_eq_prod_zipWith","module":"Mathlib.Data.Vector.Zip","initialProofState":"α : Type u_1\nn : Nat\ninst✝ : CommMonoid α\nx y : List.Vector α n\n⊢ Eq (HMul.hMul x.toList.prod y.toList.prod) (List.Vector.zipWith (fun x1 x2 => HMul.hMul x1 x2) x y).toList.prod","decl":"@[to_additive]\ntheorem prod_mul_prod_eq_prod_zipWith [CommMonoid α] (x y : Vector α n) :\n    x.toList.prod * y.toList.prod = (Vector.zipWith (· * ·) x y).toList.prod :=\n  List.prod_mul_prod_eq_prod_zipWith_of_length_eq x.toList y.toList\n    ((toList_length x).trans (toList_length y).symm)\n\n"}
