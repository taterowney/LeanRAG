{"name":"CategoryTheory.Functor.ShiftSequence.induced.isoZero_hom_app_obj","module":"Mathlib.CategoryTheory.Shift.InducedShiftSequence","initialProofState":"C : Type u_1\nD : Type u_2\nA : Type u_3\ninst✝⁷ : CategoryTheory.Category.{u_7, u_1} C\ninst✝⁶ : CategoryTheory.Category.{u_6, u_2} D\ninst✝⁵ : CategoryTheory.Category.{u_5, u_3} A\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor D A\nG : CategoryTheory.Functor C A\ne : CategoryTheory.Iso (L.comp F) G\nM : Type u_4\ninst✝⁴ : AddMonoid M\ninst✝³ : CategoryTheory.HasShift C M\ninst✝² : G.ShiftSequence M\nF' : M → CategoryTheory.Functor D A\ne' : (m : M) → CategoryTheory.Iso (L.comp (F' m)) (G.shift m)\ninst✝¹ : ((CategoryTheory.whiskeringLeft C D A).obj L).Full\ninst✝ : ((CategoryTheory.whiskeringLeft C D A).obj L).Faithful\nX : C\n⊢ Eq ((CategoryTheory.Functor.ShiftSequence.induced.isoZero e M F' e').hom.app (L.obj X)) (CategoryTheory.CategoryStruct.comp ((e' 0).hom.app X) (CategoryTheory.CategoryStruct.comp ((G.isoShiftZero M).hom.app X) (e.inv.app X)))","decl":"lemma isoZero_hom_app_obj (X : C) :\n    (isoZero e M F' e').hom.app (L.obj X) =\n      (e' 0).hom.app X ≫ (isoShiftZero G M).hom.app X ≫ e.inv.app X :=\n  NatTrans.congr_app (((whiskeringLeft C D A).obj L).map_preimage _) X\n\n"}
{"name":"CategoryTheory.Functor.ShiftSequence.induced.shiftIso_hom_app_obj","module":"Mathlib.CategoryTheory.Shift.InducedShiftSequence","initialProofState":"C : Type u_1\nD : Type u_2\nA : Type u_3\ninst✝⁹ : CategoryTheory.Category.{u_7, u_1} C\ninst✝⁸ : CategoryTheory.Category.{u_6, u_2} D\ninst✝⁷ : CategoryTheory.Category.{u_5, u_3} A\nL : CategoryTheory.Functor C D\nG : CategoryTheory.Functor C A\nM : Type u_4\ninst✝⁶ : AddMonoid M\ninst✝⁵ : CategoryTheory.HasShift C M\ninst✝⁴ : G.ShiftSequence M\nF' : M → CategoryTheory.Functor D A\ne' : (m : M) → CategoryTheory.Iso (L.comp (F' m)) (G.shift m)\ninst✝³ : ((CategoryTheory.whiskeringLeft C D A).obj L).Full\ninst✝² : ((CategoryTheory.whiskeringLeft C D A).obj L).Faithful\ninst✝¹ : CategoryTheory.HasShift D M\ninst✝ : L.CommShift M\nn a a' : M\nha' : Eq (HAdd.hAdd n a) a'\nX : C\n⊢ Eq ((CategoryTheory.Functor.ShiftSequence.induced.shiftIso L G M F' e' n a a' ha').hom.app (L.obj X)) (CategoryTheory.CategoryStruct.comp ((F' a).map ((L.commShiftIso n).inv.app X)) (CategoryTheory.CategoryStruct.comp ((e' a).hom.app ((CategoryTheory.shiftFunctor C n).obj X)) (CategoryTheory.CategoryStruct.comp ((G.shiftIso n a a' ha').hom.app X) ((e' a').inv.app X))))","decl":"lemma shiftIso_hom_app_obj (n a a' : M) (ha' : n + a = a') (X : C) :\n    (shiftIso L G M F' e' n a a' ha').hom.app (L.obj X) =\n      (F' a).map ((L.commShiftIso n).inv.app X) ≫\n        (e' a).hom.app (X⟦n⟧) ≫ (G.shiftIso n a a' ha').hom.app X ≫ (e' a').inv.app X :=\n  (NatTrans.congr_app (((whiskeringLeft C D A).obj L).map_preimage _) X).trans (by simp)\n\n"}
{"name":"CategoryTheory.Functor.ShiftSequence.induced_isoShiftZero_hom_app_obj_assoc","module":"Mathlib.CategoryTheory.Shift.InducedShiftSequence","initialProofState":"C : Type u_1\nD : Type u_2\nA : Type u_3\ninst✝⁹ : CategoryTheory.Category.{u_7, u_1} C\ninst✝⁸ : CategoryTheory.Category.{u_6, u_2} D\ninst✝⁷ : CategoryTheory.Category.{u_5, u_3} A\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor D A\nG : CategoryTheory.Functor C A\ne : CategoryTheory.Iso (L.comp F) G\nM : Type u_4\ninst✝⁶ : AddMonoid M\ninst✝⁵ : CategoryTheory.HasShift C M\ninst✝⁴ : G.ShiftSequence M\nF' : M → CategoryTheory.Functor D A\ne' : (m : M) → CategoryTheory.Iso (L.comp (F' m)) (G.shift m)\ninst✝³ : ((CategoryTheory.whiskeringLeft C D A).obj L).Full\ninst✝² : ((CategoryTheory.whiskeringLeft C D A).obj L).Faithful\ninst✝¹ : CategoryTheory.HasShift D M\ninst✝ : L.CommShift M\nX : C\nZ : A\nh : Quiver.Hom (F.obj (L.obj X)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((F.isoShiftZero M).hom.app (L.obj X)) h) (CategoryTheory.CategoryStruct.comp ((e' 0).hom.app X) (CategoryTheory.CategoryStruct.comp ((G.isoShiftZero M).hom.app X) (CategoryTheory.CategoryStruct.comp (e.inv.app X) h)))","decl":"@[simp, reassoc]\nlemma induced_isoShiftZero_hom_app_obj (X : C) :\n    letI := (induced e M F' e')\n    (F.isoShiftZero M).hom.app (L.obj X) =\n      (e' 0).hom.app X ≫ (isoShiftZero G M).hom.app X ≫ e.inv.app X := by\n  apply induced.isoZero_hom_app_obj\n\n"}
{"name":"CategoryTheory.Functor.ShiftSequence.induced_isoShiftZero_hom_app_obj","module":"Mathlib.CategoryTheory.Shift.InducedShiftSequence","initialProofState":"C : Type u_1\nD : Type u_2\nA : Type u_3\ninst✝⁹ : CategoryTheory.Category.{u_7, u_1} C\ninst✝⁸ : CategoryTheory.Category.{u_6, u_2} D\ninst✝⁷ : CategoryTheory.Category.{u_5, u_3} A\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor D A\nG : CategoryTheory.Functor C A\ne : CategoryTheory.Iso (L.comp F) G\nM : Type u_4\ninst✝⁶ : AddMonoid M\ninst✝⁵ : CategoryTheory.HasShift C M\ninst✝⁴ : G.ShiftSequence M\nF' : M → CategoryTheory.Functor D A\ne' : (m : M) → CategoryTheory.Iso (L.comp (F' m)) (G.shift m)\ninst✝³ : ((CategoryTheory.whiskeringLeft C D A).obj L).Full\ninst✝² : ((CategoryTheory.whiskeringLeft C D A).obj L).Faithful\ninst✝¹ : CategoryTheory.HasShift D M\ninst✝ : L.CommShift M\nX : C\n⊢ Eq ((F.isoShiftZero M).hom.app (L.obj X)) (CategoryTheory.CategoryStruct.comp ((e' 0).hom.app X) (CategoryTheory.CategoryStruct.comp ((G.isoShiftZero M).hom.app X) (e.inv.app X)))","decl":"@[simp, reassoc]\nlemma induced_isoShiftZero_hom_app_obj (X : C) :\n    letI := (induced e M F' e')\n    (F.isoShiftZero M).hom.app (L.obj X) =\n      (e' 0).hom.app X ≫ (isoShiftZero G M).hom.app X ≫ e.inv.app X := by\n  apply induced.isoZero_hom_app_obj\n\n"}
{"name":"CategoryTheory.Functor.ShiftSequence.induced_shiftIso_hom_app_obj","module":"Mathlib.CategoryTheory.Shift.InducedShiftSequence","initialProofState":"C : Type u_1\nD : Type u_2\nA : Type u_3\ninst✝⁹ : CategoryTheory.Category.{u_7, u_1} C\ninst✝⁸ : CategoryTheory.Category.{u_6, u_2} D\ninst✝⁷ : CategoryTheory.Category.{u_5, u_3} A\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor D A\nG : CategoryTheory.Functor C A\ne : CategoryTheory.Iso (L.comp F) G\nM : Type u_4\ninst✝⁶ : AddMonoid M\ninst✝⁵ : CategoryTheory.HasShift C M\ninst✝⁴ : G.ShiftSequence M\nF' : M → CategoryTheory.Functor D A\ne' : (m : M) → CategoryTheory.Iso (L.comp (F' m)) (G.shift m)\ninst✝³ : ((CategoryTheory.whiskeringLeft C D A).obj L).Full\ninst✝² : ((CategoryTheory.whiskeringLeft C D A).obj L).Faithful\ninst✝¹ : CategoryTheory.HasShift D M\ninst✝ : L.CommShift M\nn a a' : M\nha' : Eq (HAdd.hAdd n a) a'\nX : C\n⊢ Eq ((F.shiftIso n a a' ha').hom.app (L.obj X)) (CategoryTheory.CategoryStruct.comp ((F.shift a).map ((L.commShiftIso n).inv.app X)) (CategoryTheory.CategoryStruct.comp ((e' a).hom.app ((CategoryTheory.shiftFunctor C n).obj X)) (CategoryTheory.CategoryStruct.comp ((G.shiftIso n a a' ha').hom.app X) ((e' a').inv.app X))))","decl":"@[simp, reassoc]\nlemma induced_shiftIso_hom_app_obj (n a a' : M) (ha' : n + a = a') (X : C) :\n    letI := (induced e M F' e')\n    (F.shiftIso n a a' ha').hom.app (L.obj X) =\n      (F.shift a).map ((L.commShiftIso n).inv.app X) ≫ (e' a).hom.app (X⟦n⟧) ≫\n        (G.shiftIso n a a' ha').hom.app X ≫ (e' a').inv.app X := by\n  apply induced.shiftIso_hom_app_obj\n\n"}
{"name":"CategoryTheory.Functor.ShiftSequence.induced_shiftIso_hom_app_obj_assoc","module":"Mathlib.CategoryTheory.Shift.InducedShiftSequence","initialProofState":"C : Type u_1\nD : Type u_2\nA : Type u_3\ninst✝⁹ : CategoryTheory.Category.{u_7, u_1} C\ninst✝⁸ : CategoryTheory.Category.{u_6, u_2} D\ninst✝⁷ : CategoryTheory.Category.{u_5, u_3} A\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor D A\nG : CategoryTheory.Functor C A\ne : CategoryTheory.Iso (L.comp F) G\nM : Type u_4\ninst✝⁶ : AddMonoid M\ninst✝⁵ : CategoryTheory.HasShift C M\ninst✝⁴ : G.ShiftSequence M\nF' : M → CategoryTheory.Functor D A\ne' : (m : M) → CategoryTheory.Iso (L.comp (F' m)) (G.shift m)\ninst✝³ : ((CategoryTheory.whiskeringLeft C D A).obj L).Full\ninst✝² : ((CategoryTheory.whiskeringLeft C D A).obj L).Faithful\ninst✝¹ : CategoryTheory.HasShift D M\ninst✝ : L.CommShift M\nn a a' : M\nha' : Eq (HAdd.hAdd n a) a'\nX : C\nZ : A\nh : Quiver.Hom ((F.shift a').obj (L.obj X)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((F.shiftIso n a a' ha').hom.app (L.obj X)) h) (CategoryTheory.CategoryStruct.comp ((F.shift a).map ((L.commShiftIso n).inv.app X)) (CategoryTheory.CategoryStruct.comp ((e' a).hom.app ((CategoryTheory.shiftFunctor C n).obj X)) (CategoryTheory.CategoryStruct.comp ((G.shiftIso n a a' ha').hom.app X) (CategoryTheory.CategoryStruct.comp ((e' a').inv.app X) h))))","decl":"@[simp, reassoc]\nlemma induced_shiftIso_hom_app_obj (n a a' : M) (ha' : n + a = a') (X : C) :\n    letI := (induced e M F' e')\n    (F.shiftIso n a a' ha').hom.app (L.obj X) =\n      (F.shift a).map ((L.commShiftIso n).inv.app X) ≫ (e' a).hom.app (X⟦n⟧) ≫\n        (G.shiftIso n a a' ha').hom.app X ≫ (e' a').inv.app X := by\n  apply induced.shiftIso_hom_app_obj\n\n"}
{"name":"CategoryTheory.Functor.ShiftSequence.induced_shiftMap_assoc","module":"Mathlib.CategoryTheory.Shift.InducedShiftSequence","initialProofState":"C : Type u_1\nD : Type u_2\nA : Type u_3\ninst✝⁹ : CategoryTheory.Category.{u_5, u_1} C\ninst✝⁸ : CategoryTheory.Category.{u_7, u_2} D\ninst✝⁷ : CategoryTheory.Category.{u_6, u_3} A\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor D A\nG : CategoryTheory.Functor C A\ne : CategoryTheory.Iso (L.comp F) G\nM : Type u_4\ninst✝⁶ : AddMonoid M\ninst✝⁵ : CategoryTheory.HasShift C M\ninst✝⁴ : G.ShiftSequence M\nF' : M → CategoryTheory.Functor D A\ne' : (m : M) → CategoryTheory.Iso (L.comp (F' m)) (G.shift m)\ninst✝³ : ((CategoryTheory.whiskeringLeft C D A).obj L).Full\ninst✝² : ((CategoryTheory.whiskeringLeft C D A).obj L).Faithful\ninst✝¹ : CategoryTheory.HasShift D M\ninst✝ : L.CommShift M\nn : M\nX Y : C\nf : Quiver.Hom X ((CategoryTheory.shiftFunctor C n).obj Y)\na a' : M\nh✝ : Eq (HAdd.hAdd n a) a'\nZ : A\nh : Quiver.Hom ((F.shift a').obj (L.obj Y)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (F.shiftMap (CategoryTheory.CategoryStruct.comp (L.map f) ((L.commShiftIso n).hom.app Y)) a a' h✝) h) (CategoryTheory.CategoryStruct.comp ((e' a).hom.app X) (CategoryTheory.CategoryStruct.comp (G.shiftMap f a a' h✝) (CategoryTheory.CategoryStruct.comp ((e' a').inv.app Y) h)))","decl":"@[reassoc]\nlemma induced_shiftMap {n : M} {X Y : C} (f : X ⟶ Y⟦n⟧) (a a' : M) (h : n + a = a') :\n    letI := induced e M F' e'\n    F.shiftMap (L.map f ≫ (L.commShiftIso n).hom.app _) a a' h =\n      (e' a).hom.app X ≫ G.shiftMap f a a' h ≫ (e' a').inv.app Y := by\n  dsimp [shiftMap]\n  rw [Functor.map_comp, induced_shiftIso_hom_app_obj, assoc, assoc]\n  nth_rw 2 [← Functor.map_comp_assoc]\n  simp only [comp_obj, Iso.hom_inv_id_app, map_id, id_comp]\n  rw [← NatTrans.naturality_assoc]\n  rfl\n\n"}
{"name":"CategoryTheory.Functor.ShiftSequence.induced_shiftMap","module":"Mathlib.CategoryTheory.Shift.InducedShiftSequence","initialProofState":"C : Type u_1\nD : Type u_2\nA : Type u_3\ninst✝⁹ : CategoryTheory.Category.{u_5, u_1} C\ninst✝⁸ : CategoryTheory.Category.{u_7, u_2} D\ninst✝⁷ : CategoryTheory.Category.{u_6, u_3} A\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor D A\nG : CategoryTheory.Functor C A\ne : CategoryTheory.Iso (L.comp F) G\nM : Type u_4\ninst✝⁶ : AddMonoid M\ninst✝⁵ : CategoryTheory.HasShift C M\ninst✝⁴ : G.ShiftSequence M\nF' : M → CategoryTheory.Functor D A\ne' : (m : M) → CategoryTheory.Iso (L.comp (F' m)) (G.shift m)\ninst✝³ : ((CategoryTheory.whiskeringLeft C D A).obj L).Full\ninst✝² : ((CategoryTheory.whiskeringLeft C D A).obj L).Faithful\ninst✝¹ : CategoryTheory.HasShift D M\ninst✝ : L.CommShift M\nn : M\nX Y : C\nf : Quiver.Hom X ((CategoryTheory.shiftFunctor C n).obj Y)\na a' : M\nh : Eq (HAdd.hAdd n a) a'\n⊢ Eq (F.shiftMap (CategoryTheory.CategoryStruct.comp (L.map f) ((L.commShiftIso n).hom.app Y)) a a' h) (CategoryTheory.CategoryStruct.comp ((e' a).hom.app X) (CategoryTheory.CategoryStruct.comp (G.shiftMap f a a' h) ((e' a').inv.app Y)))","decl":"@[reassoc]\nlemma induced_shiftMap {n : M} {X Y : C} (f : X ⟶ Y⟦n⟧) (a a' : M) (h : n + a = a') :\n    letI := induced e M F' e'\n    F.shiftMap (L.map f ≫ (L.commShiftIso n).hom.app _) a a' h =\n      (e' a).hom.app X ≫ G.shiftMap f a a' h ≫ (e' a').inv.app Y := by\n  dsimp [shiftMap]\n  rw [Functor.map_comp, induced_shiftIso_hom_app_obj, assoc, assoc]\n  nth_rw 2 [← Functor.map_comp_assoc]\n  simp only [comp_obj, Iso.hom_inv_id_app, map_id, id_comp]\n  rw [← NatTrans.naturality_assoc]\n  rfl\n\n"}
