{"name":"CategoryTheory.Functor.imageSieve_map","module":"Mathlib.CategoryTheory.Sites.LocallyFullyFaithful","initialProofState":"C : Type uC\ninst✝¹ : CategoryTheory.Category.{vC, uC} C\nD : Type uD\ninst✝ : CategoryTheory.Category.{vD, uD} D\nG : CategoryTheory.Functor C D\nU V : C\nf : Quiver.Hom U V\n⊢ Eq (G.imageSieve (G.map f)) Top.top","decl":"@[simp]\nlemma Functor.imageSieve_map {U V : C} (f : U ⟶ V) : G.imageSieve (G.map f) = ⊤ := by\n  ext W g; simpa using ⟨g ≫ f, by simp⟩\n\n"}
{"name":"CategoryTheory.Sieve.equalizer_apply","module":"Mathlib.CategoryTheory.Sites.LocallyFullyFaithful","initialProofState":"C : Type uC\ninst✝ : CategoryTheory.Category.{vC, uC} C\nU V : C\nf₁ f₂ : Quiver.Hom U V\nx✝ : C\ni : Quiver.Hom x✝ U\n⊢ Eq ((CategoryTheory.Sieve.equalizer f₁ f₂).arrows i) (Eq (CategoryTheory.CategoryStruct.comp i f₁) (CategoryTheory.CategoryStruct.comp i f₂))","decl":"/--\nFor two arrows `f₁ f₂ : U ⟶ V`, the arrows `i` such that `i ≫ f₁ = i ≫ f₂` forms a sieve.\n-/\n@[simps]\ndef Sieve.equalizer {U V : C} (f₁ f₂ : U ⟶ V) : Sieve U where\n  arrows _ i := i ≫ f₁ = i ≫ f₂\n  downward_closed := by aesop\n\n"}
{"name":"CategoryTheory.Sieve.equalizer_self","module":"Mathlib.CategoryTheory.Sites.LocallyFullyFaithful","initialProofState":"C : Type uC\ninst✝ : CategoryTheory.Category.{vC, uC} C\nU V : C\nf : Quiver.Hom U V\n⊢ Eq (CategoryTheory.Sieve.equalizer f f) Top.top","decl":"@[simp]\nlemma Sieve.equalizer_self {U V : C} (f : U ⟶ V) : equalizer f f = ⊤ := by ext; simp\n\n"}
{"name":"CategoryTheory.Sieve.equalizer_eq_equalizerSieve","module":"Mathlib.CategoryTheory.Sites.LocallyFullyFaithful","initialProofState":"C : Type uC\ninst✝ : CategoryTheory.Category.{vC, uC} C\nU V : C\nf₁ f₂ : Quiver.Hom U V\n⊢ Eq (CategoryTheory.Sieve.equalizer f₁ f₂) (CategoryTheory.Presheaf.equalizerSieve f₁ f₂)","decl":"lemma Sieve.equalizer_eq_equalizerSieve {U V : C} (f₁ f₂ : U ⟶ V) :\n    Sieve.equalizer f₁ f₂ = Presheaf.equalizerSieve (F := yoneda.obj _) f₁ f₂ := rfl\n\n"}
{"name":"CategoryTheory.Functor.imageSieve_eq_imageSieve","module":"Mathlib.CategoryTheory.Sites.LocallyFullyFaithful","initialProofState":"C : Type uC\ninst✝¹ : CategoryTheory.Category.{vC, uC} C\nD : Type uD\ninst✝ : CategoryTheory.Category.{vC, uD} D\nG : CategoryTheory.Functor C D\nU V : C\nf : Quiver.Hom (G.obj U) (G.obj V)\n⊢ Eq (G.imageSieve f) (CategoryTheory.Presheaf.imageSieve (CategoryTheory.yonedaMap G V) f)","decl":"lemma Functor.imageSieve_eq_imageSieve {D : Type uD} [Category.{vC} D] (G : C ⥤ D) {U V : C}\n    (f : G.obj U ⟶ G.obj V) :\n    G.imageSieve f = Presheaf.imageSieve (yonedaMap G V) f := rfl\n\n"}
{"name":"CategoryTheory.Functor.IsLocallyFull.functorPushforward_imageSieve_mem","module":"Mathlib.CategoryTheory.Sites.LocallyFullyFaithful","initialProofState":"C : Type uC\ninst✝¹ : CategoryTheory.Category.{vC, uC} C\nD : Type uD\ninst✝ : CategoryTheory.Category.{vD, uD} D\nG : CategoryTheory.Functor C D\nK : CategoryTheory.GrothendieckTopology D\nself : G.IsLocallyFull K\nU V : C\nf : Quiver.Hom (G.obj U) (G.obj V)\n⊢ Membership.mem (K (G.obj U)) (CategoryTheory.Sieve.functorPushforward G (G.imageSieve f))","decl":"/--\nA functor `G : C ⥤ D` is locally full wrt a topology on `D` if for every `f : G.obj U ⟶ G.obj V`,\nthe set of `G.map fᵢ : G.obj Wᵢ ⟶ G.obj U` such that `G.map fᵢ ≫ f` is\nin the image of `G` is a coverage of the topology on `D`.\n-/\nclass IsLocallyFull : Prop where\n  functorPushforward_imageSieve_mem : ∀ {U V} (f : G.obj U ⟶ G.obj V),\n    (G.imageSieve f).functorPushforward G ∈ K _\n\n"}
{"name":"CategoryTheory.Functor.IsLocallyFaithful.functorPushforward_equalizer_mem","module":"Mathlib.CategoryTheory.Sites.LocallyFullyFaithful","initialProofState":"C : Type uC\ninst✝¹ : CategoryTheory.Category.{vC, uC} C\nD : Type uD\ninst✝ : CategoryTheory.Category.{vD, uD} D\nG : CategoryTheory.Functor C D\nK : CategoryTheory.GrothendieckTopology D\nself : G.IsLocallyFaithful K\nU V : C\nf₁ f₂ : Quiver.Hom U V\na✝ : Eq (G.map f₁) (G.map f₂)\n⊢ Membership.mem (K (G.obj U)) (CategoryTheory.Sieve.functorPushforward G (CategoryTheory.Sieve.equalizer f₁ f₂))","decl":"/--\nA functor `G : C ⥤ D` is locally faithful wrt a topology on `D` if for every `f₁ f₂ : U ⟶ V` whose\nimage in `D` are equal, the set of `G.map gᵢ : G.obj Wᵢ ⟶ G.obj U` such that `gᵢ ≫ f₁ = gᵢ ≫ f₂`\nis a coverage of the topology on `D`.\n-/\nclass IsLocallyFaithful : Prop where\n  functorPushforward_equalizer_mem : ∀ {U V : C} (f₁ f₂ : U ⟶ V), G.map f₁ = G.map f₂ →\n    (Sieve.equalizer f₁ f₂).functorPushforward G ∈ K _\n\n"}
{"name":"CategoryTheory.Functor.functorPushforward_imageSieve_mem","module":"Mathlib.CategoryTheory.Sites.LocallyFullyFaithful","initialProofState":"C : Type uC\ninst✝² : CategoryTheory.Category.{vC, uC} C\nD : Type uD\ninst✝¹ : CategoryTheory.Category.{vD, uD} D\nG : CategoryTheory.Functor C D\nK : CategoryTheory.GrothendieckTopology D\ninst✝ : G.IsLocallyFull K\nU V : C\nf : Quiver.Hom (G.obj U) (G.obj V)\n⊢ Membership.mem (K (G.obj U)) (CategoryTheory.Sieve.functorPushforward G (G.imageSieve f))","decl":"lemma functorPushforward_imageSieve_mem [G.IsLocallyFull K] {U V} (f : G.obj U ⟶ G.obj V) :\n    (G.imageSieve f).functorPushforward G ∈ K _ :=\n  Functor.IsLocallyFull.functorPushforward_imageSieve_mem _\n\n"}
{"name":"CategoryTheory.Functor.functorPushforward_equalizer_mem","module":"Mathlib.CategoryTheory.Sites.LocallyFullyFaithful","initialProofState":"C : Type uC\ninst✝² : CategoryTheory.Category.{vC, uC} C\nD : Type uD\ninst✝¹ : CategoryTheory.Category.{vD, uD} D\nG : CategoryTheory.Functor C D\nK : CategoryTheory.GrothendieckTopology D\ninst✝ : G.IsLocallyFaithful K\nU V : C\nf₁ f₂ : Quiver.Hom U V\ne : Eq (G.map f₁) (G.map f₂)\n⊢ Membership.mem (K (G.obj U)) (CategoryTheory.Sieve.functorPushforward G (CategoryTheory.Sieve.equalizer f₁ f₂))","decl":"lemma functorPushforward_equalizer_mem\n    [G.IsLocallyFaithful K] {U V} (f₁ f₂ : U ⟶ V) (e : G.map f₁ = G.map f₂) :\n      (Sieve.equalizer f₁ f₂).functorPushforward G ∈ K _ :=\n  Functor.IsLocallyFaithful.functorPushforward_equalizer_mem _ _ e\n\n"}
{"name":"CategoryTheory.Functor.IsLocallyFull.ext","module":"Mathlib.CategoryTheory.Sites.LocallyFullyFaithful","initialProofState":"C : Type uC\ninst✝² : CategoryTheory.Category.{vC, uC} C\nD : Type uD\ninst✝¹ : CategoryTheory.Category.{vD, uD} D\nK : CategoryTheory.GrothendieckTopology D\nG : CategoryTheory.Functor C D\ninst✝ : G.IsLocallyFull K\nℱ : CategoryTheory.Sheaf K (Type u_2)\nX Y : C\ni : Quiver.Hom (G.obj X) (G.obj Y)\ns t : ℱ.val.obj { unop := G.obj X }\nh : ∀ ⦃Z : C⦄ (j : Quiver.Hom Z X) (f : Quiver.Hom Z Y), Eq (G.map f) (CategoryTheory.CategoryStruct.comp (G.map j) i) → Eq (ℱ.val.map (G.map j).op s) (ℱ.val.map (G.map j).op t)\n⊢ Eq s t","decl":"theorem IsLocallyFull.ext [G.IsLocallyFull K]\n    (ℱ : Sheaf K (Type _)) {X Y : C} (i : G.obj X ⟶ G.obj Y)\n    {s t : ℱ.val.obj (op (G.obj X))}\n    (h : ∀ ⦃Z : C⦄ (j : Z ⟶ X) (f : Z ⟶ Y), G.map f = G.map j ≫ i →\n      ℱ.1.map (G.map j).op s = ℱ.1.map (G.map j).op t) : s = t := by\n  apply (((isSheaf_iff_isSheaf_of_type _ _).1 ℱ.cond) _\n    (G.functorPushforward_imageSieve_mem K i)).isSeparatedFor.ext\n  rintro Z _ ⟨W, iWX, iZW, ⟨iWY, e⟩, rfl⟩\n  simp [h iWX iWY e]\n\n"}
{"name":"CategoryTheory.Functor.IsLocallyFaithful.ext","module":"Mathlib.CategoryTheory.Sites.LocallyFullyFaithful","initialProofState":"C : Type uC\ninst✝² : CategoryTheory.Category.{vC, uC} C\nD : Type uD\ninst✝¹ : CategoryTheory.Category.{vD, uD} D\nK : CategoryTheory.GrothendieckTopology D\nG : CategoryTheory.Functor C D\ninst✝ : G.IsLocallyFaithful K\nℱ : CategoryTheory.Sheaf K (Type u_2)\nX Y : C\ni₁ i₂ : Quiver.Hom X Y\ne : Eq (G.map i₁) (G.map i₂)\ns t : ℱ.val.obj { unop := G.obj X }\nh : ∀ ⦃Z : C⦄ (j : Quiver.Hom Z X), Eq (CategoryTheory.CategoryStruct.comp j i₁) (CategoryTheory.CategoryStruct.comp j i₂) → Eq (ℱ.val.map (G.map j).op s) (ℱ.val.map (G.map j).op t)\n⊢ Eq s t","decl":"theorem IsLocallyFaithful.ext [G.IsLocallyFaithful K] (ℱ : Sheaf K (Type _))\n    {X Y : C} (i₁ i₂ : X ⟶ Y) (e : G.map i₁ = G.map i₂)\n    {s t : ℱ.val.obj (op (G.obj X))}\n    (h : ∀ ⦃Z : C⦄ (j : Z ⟶ X), j ≫ i₁ = j ≫ i₂ →\n      ℱ.1.map (G.map j).op s = ℱ.1.map (G.map j).op t) : s = t := by\n  apply (((isSheaf_iff_isSheaf_of_type _ _).1 ℱ.cond) _\n    (G.functorPushforward_equalizer_mem K i₁ i₂ e)).isSeparatedFor.ext\n  rintro Z _ ⟨W, iWX, iZW, hiWX, rfl⟩\n  simp [h iWX hiWX]\n\n"}
{"name":"CategoryTheory.Functor.IsLocallyFull.of_full","module":"Mathlib.CategoryTheory.Sites.LocallyFullyFaithful","initialProofState":"C : Type uC\ninst✝² : CategoryTheory.Category.{vC, uC} C\nD : Type uD\ninst✝¹ : CategoryTheory.Category.{vD, uD} D\nK : CategoryTheory.GrothendieckTopology D\nG : CategoryTheory.Functor C D\ninst✝ : G.Full\n⊢ G.IsLocallyFull K","decl":"instance (priority := 900) IsLocallyFull.of_full [G.Full] : G.IsLocallyFull K where\n  functorPushforward_imageSieve_mem f := by\n    rw [← G.map_preimage f]\n    simp only [Functor.imageSieve_map, Sieve.functorPushforward_top, GrothendieckTopology.top_mem]\n\n"}
{"name":"CategoryTheory.Functor.IsLocallyFaithful.of_faithful","module":"Mathlib.CategoryTheory.Sites.LocallyFullyFaithful","initialProofState":"C : Type uC\ninst✝² : CategoryTheory.Category.{vC, uC} C\nD : Type uD\ninst✝¹ : CategoryTheory.Category.{vD, uD} D\nK : CategoryTheory.GrothendieckTopology D\nG : CategoryTheory.Functor C D\ninst✝ : G.Faithful\n⊢ G.IsLocallyFaithful K","decl":"instance (priority := 900) IsLocallyFaithful.of_faithful [G.Faithful] : G.IsLocallyFaithful K where\n  functorPushforward_equalizer_mem f₁ f₂ e := by obtain rfl := G.map_injective e; simp\n\n"}
