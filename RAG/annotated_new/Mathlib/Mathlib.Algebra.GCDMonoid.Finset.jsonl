{"name":"Finset.lcm_def","module":"Mathlib.Algebra.GCDMonoid.Finset","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : NormalizedGCDMonoid α\ns : Finset β\nf : β → α\n⊢ Eq (s.lcm f) (Multiset.map f s.val).lcm","decl":"theorem lcm_def : s.lcm f = (s.1.map f).lcm :=\n  rfl\n\n"}
{"name":"Finset.lcm_empty","module":"Mathlib.Algebra.GCDMonoid.Finset","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : NormalizedGCDMonoid α\nf : β → α\n⊢ Eq (EmptyCollection.emptyCollection.lcm f) 1","decl":"@[simp]\ntheorem lcm_empty : (∅ : Finset β).lcm f = 1 :=\n  fold_empty\n\n"}
{"name":"Finset.lcm_dvd_iff","module":"Mathlib.Algebra.GCDMonoid.Finset","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : NormalizedGCDMonoid α\ns : Finset β\nf : β → α\na : α\n⊢ Iff (Dvd.dvd (s.lcm f) a) (∀ (b : β), Membership.mem s b → Dvd.dvd (f b) a)","decl":"@[simp]\ntheorem lcm_dvd_iff {a : α} : s.lcm f ∣ a ↔ ∀ b ∈ s, f b ∣ a := by\n  apply Iff.trans Multiset.lcm_dvd\n  simp only [Multiset.mem_map, and_imp, exists_imp]\n  exact ⟨fun k b hb ↦ k _ _ hb rfl, fun k a' b hb h ↦ h ▸ k _ hb⟩\n\n"}
{"name":"Finset.lcm_dvd","module":"Mathlib.Algebra.GCDMonoid.Finset","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : NormalizedGCDMonoid α\ns : Finset β\nf : β → α\na : α\na✝ : ∀ (b : β), Membership.mem s b → Dvd.dvd (f b) a\n⊢ Dvd.dvd (s.lcm f) a","decl":"theorem lcm_dvd {a : α} : (∀ b ∈ s, f b ∣ a) → s.lcm f ∣ a :=\n  lcm_dvd_iff.2\n\n"}
{"name":"Finset.dvd_lcm","module":"Mathlib.Algebra.GCDMonoid.Finset","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : NormalizedGCDMonoid α\ns : Finset β\nf : β → α\nb : β\nhb : Membership.mem s b\n⊢ Dvd.dvd (f b) (s.lcm f)","decl":"theorem dvd_lcm {b : β} (hb : b ∈ s) : f b ∣ s.lcm f :=\n  lcm_dvd_iff.1 dvd_rfl _ hb\n\n"}
{"name":"Finset.lcm_insert","module":"Mathlib.Algebra.GCDMonoid.Finset","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝² : CancelCommMonoidWithZero α\ninst✝¹ : NormalizedGCDMonoid α\ns : Finset β\nf : β → α\ninst✝ : DecidableEq β\nb : β\n⊢ Eq ((Insert.insert b s).lcm f) (GCDMonoid.lcm (f b) (s.lcm f))","decl":"@[simp]\ntheorem lcm_insert [DecidableEq β] {b : β} :\n    (insert b s : Finset β).lcm f = GCDMonoid.lcm (f b) (s.lcm f) := by\n  by_cases h : b ∈ s\n  · rw [insert_eq_of_mem h,\n      (lcm_eq_right_iff (f b) (s.lcm f) (Multiset.normalize_lcm (s.1.map f))).2 (dvd_lcm h)]\n  apply fold_insert h\n\n"}
{"name":"Finset.lcm_singleton","module":"Mathlib.Algebra.GCDMonoid.Finset","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : NormalizedGCDMonoid α\nf : β → α\nb : β\n⊢ Eq ((Singleton.singleton b).lcm f) (normalize (f b))","decl":"@[simp]\ntheorem lcm_singleton {b : β} : ({b} : Finset β).lcm f = normalize (f b) :=\n  Multiset.lcm_singleton\n\n"}
{"name":"Finset.normalize_lcm","module":"Mathlib.Algebra.GCDMonoid.Finset","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : NormalizedGCDMonoid α\ns : Finset β\nf : β → α\n⊢ Eq (normalize (s.lcm f)) (s.lcm f)","decl":"@[local simp] -- This will later be provable by other `simp` lemmas.\ntheorem normalize_lcm : normalize (s.lcm f) = s.lcm f := by simp [lcm_def]\n\n"}
{"name":"Finset.lcm_union","module":"Mathlib.Algebra.GCDMonoid.Finset","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝² : CancelCommMonoidWithZero α\ninst✝¹ : NormalizedGCDMonoid α\ns₁ s₂ : Finset β\nf : β → α\ninst✝ : DecidableEq β\n⊢ Eq ((Union.union s₁ s₂).lcm f) (GCDMonoid.lcm (s₁.lcm f) (s₂.lcm f))","decl":"theorem lcm_union [DecidableEq β] : (s₁ ∪ s₂).lcm f = GCDMonoid.lcm (s₁.lcm f) (s₂.lcm f) :=\n  Finset.induction_on s₁ (by rw [empty_union, lcm_empty, lcm_one_left, normalize_lcm])\n    fun a s _ ih ↦ by rw [insert_union, lcm_insert, lcm_insert, ih, lcm_assoc]\n\n"}
{"name":"Finset.lcm_congr","module":"Mathlib.Algebra.GCDMonoid.Finset","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : NormalizedGCDMonoid α\ns₁ s₂ : Finset β\nf g : β → α\nhs : Eq s₁ s₂\nhfg : ∀ (a : β), Membership.mem s₂ a → Eq (f a) (g a)\n⊢ Eq (s₁.lcm f) (s₂.lcm g)","decl":"theorem lcm_congr {f g : β → α} (hs : s₁ = s₂) (hfg : ∀ a ∈ s₂, f a = g a) :\n    s₁.lcm f = s₂.lcm g := by\n  subst hs\n  exact Finset.fold_congr hfg\n\n"}
{"name":"Finset.lcm_mono_fun","module":"Mathlib.Algebra.GCDMonoid.Finset","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : NormalizedGCDMonoid α\ns : Finset β\nf g : β → α\nh : ∀ (b : β), Membership.mem s b → Dvd.dvd (f b) (g b)\n⊢ Dvd.dvd (s.lcm f) (s.lcm g)","decl":"theorem lcm_mono_fun {g : β → α} (h : ∀ b ∈ s, f b ∣ g b) : s.lcm f ∣ s.lcm g :=\n  lcm_dvd fun b hb ↦ (h b hb).trans (dvd_lcm hb)\n\n"}
{"name":"Finset.lcm_mono","module":"Mathlib.Algebra.GCDMonoid.Finset","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : NormalizedGCDMonoid α\ns₁ s₂ : Finset β\nf : β → α\nh : HasSubset.Subset s₁ s₂\n⊢ Dvd.dvd (s₁.lcm f) (s₂.lcm f)","decl":"theorem lcm_mono (h : s₁ ⊆ s₂) : s₁.lcm f ∣ s₂.lcm f :=\n  lcm_dvd fun _ hb ↦ dvd_lcm (h hb)\n\n"}
{"name":"Finset.lcm_image","module":"Mathlib.Algebra.GCDMonoid.Finset","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝² : CancelCommMonoidWithZero α\ninst✝¹ : NormalizedGCDMonoid α\nf : β → α\ninst✝ : DecidableEq β\ng : γ → β\ns : Finset γ\n⊢ Eq ((Finset.image g s).lcm f) (s.lcm (Function.comp f g))","decl":"theorem lcm_image [DecidableEq β] {g : γ → β} (s : Finset γ) :\n    (s.image g).lcm f = s.lcm (f ∘ g) := by\n  classical induction s using Finset.induction <;> simp [*]\n\n"}
{"name":"Finset.lcm_eq_lcm_image","module":"Mathlib.Algebra.GCDMonoid.Finset","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝² : CancelCommMonoidWithZero α\ninst✝¹ : NormalizedGCDMonoid α\ns : Finset β\nf : β → α\ninst✝ : DecidableEq α\n⊢ Eq (s.lcm f) ((Finset.image f s).lcm id)","decl":"theorem lcm_eq_lcm_image [DecidableEq α] : s.lcm f = (s.image f).lcm id :=\n  Eq.symm <| lcm_image _\n\n"}
{"name":"Finset.lcm_eq_zero_iff","module":"Mathlib.Algebra.GCDMonoid.Finset","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝² : CancelCommMonoidWithZero α\ninst✝¹ : NormalizedGCDMonoid α\ns : Finset β\nf : β → α\ninst✝ : Nontrivial α\n⊢ Iff (Eq (s.lcm f) 0) (Membership.mem (Set.image f ↑s) 0)","decl":"theorem lcm_eq_zero_iff [Nontrivial α] : s.lcm f = 0 ↔ 0 ∈ f '' s := by\n  simp only [Multiset.mem_map, lcm_def, Multiset.lcm_eq_zero_iff, Set.mem_image, mem_coe, ←\n    Finset.mem_def]\n\n"}
{"name":"Finset.gcd_def","module":"Mathlib.Algebra.GCDMonoid.Finset","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : NormalizedGCDMonoid α\ns : Finset β\nf : β → α\n⊢ Eq (s.gcd f) (Multiset.map f s.val).gcd","decl":"theorem gcd_def : s.gcd f = (s.1.map f).gcd :=\n  rfl\n\n"}
{"name":"Finset.gcd_empty","module":"Mathlib.Algebra.GCDMonoid.Finset","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : NormalizedGCDMonoid α\nf : β → α\n⊢ Eq (EmptyCollection.emptyCollection.gcd f) 0","decl":"@[simp]\ntheorem gcd_empty : (∅ : Finset β).gcd f = 0 :=\n  fold_empty\n\n"}
{"name":"Finset.dvd_gcd_iff","module":"Mathlib.Algebra.GCDMonoid.Finset","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : NormalizedGCDMonoid α\ns : Finset β\nf : β → α\na : α\n⊢ Iff (Dvd.dvd a (s.gcd f)) (∀ (b : β), Membership.mem s b → Dvd.dvd a (f b))","decl":"theorem dvd_gcd_iff {a : α} : a ∣ s.gcd f ↔ ∀ b ∈ s, a ∣ f b := by\n  apply Iff.trans Multiset.dvd_gcd\n  simp only [Multiset.mem_map, and_imp, exists_imp]\n  exact ⟨fun k b hb ↦ k _ _ hb rfl, fun k a' b hb h ↦ h ▸ k _ hb⟩\n\n"}
{"name":"Finset.gcd_dvd","module":"Mathlib.Algebra.GCDMonoid.Finset","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : NormalizedGCDMonoid α\ns : Finset β\nf : β → α\nb : β\nhb : Membership.mem s b\n⊢ Dvd.dvd (s.gcd f) (f b)","decl":"theorem gcd_dvd {b : β} (hb : b ∈ s) : s.gcd f ∣ f b :=\n  dvd_gcd_iff.1 dvd_rfl _ hb\n\n"}
{"name":"Finset.dvd_gcd","module":"Mathlib.Algebra.GCDMonoid.Finset","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : NormalizedGCDMonoid α\ns : Finset β\nf : β → α\na : α\na✝ : ∀ (b : β), Membership.mem s b → Dvd.dvd a (f b)\n⊢ Dvd.dvd a (s.gcd f)","decl":"theorem dvd_gcd {a : α} : (∀ b ∈ s, a ∣ f b) → a ∣ s.gcd f :=\n  dvd_gcd_iff.2\n\n"}
{"name":"Finset.gcd_insert","module":"Mathlib.Algebra.GCDMonoid.Finset","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝² : CancelCommMonoidWithZero α\ninst✝¹ : NormalizedGCDMonoid α\ns : Finset β\nf : β → α\ninst✝ : DecidableEq β\nb : β\n⊢ Eq ((Insert.insert b s).gcd f) (GCDMonoid.gcd (f b) (s.gcd f))","decl":"@[simp]\ntheorem gcd_insert [DecidableEq β] {b : β} :\n    (insert b s : Finset β).gcd f = GCDMonoid.gcd (f b) (s.gcd f) := by\n  by_cases h : b ∈ s\n  · rw [insert_eq_of_mem h,\n      (gcd_eq_right_iff (f b) (s.gcd f) (Multiset.normalize_gcd (s.1.map f))).2 (gcd_dvd h)]\n  apply fold_insert h\n\n"}
{"name":"Finset.gcd_singleton","module":"Mathlib.Algebra.GCDMonoid.Finset","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : NormalizedGCDMonoid α\nf : β → α\nb : β\n⊢ Eq ((Singleton.singleton b).gcd f) (normalize (f b))","decl":"@[simp]\ntheorem gcd_singleton {b : β} : ({b} : Finset β).gcd f = normalize (f b) :=\n  Multiset.gcd_singleton\n\n"}
{"name":"Finset.normalize_gcd","module":"Mathlib.Algebra.GCDMonoid.Finset","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : NormalizedGCDMonoid α\ns : Finset β\nf : β → α\n⊢ Eq (normalize (s.gcd f)) (s.gcd f)","decl":"@[local simp] -- This will later be provable by other `simp` lemmas.\ntheorem normalize_gcd : normalize (s.gcd f) = s.gcd f := by simp [gcd_def]\n\n"}
{"name":"Finset.gcd_union","module":"Mathlib.Algebra.GCDMonoid.Finset","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝² : CancelCommMonoidWithZero α\ninst✝¹ : NormalizedGCDMonoid α\ns₁ s₂ : Finset β\nf : β → α\ninst✝ : DecidableEq β\n⊢ Eq ((Union.union s₁ s₂).gcd f) (GCDMonoid.gcd (s₁.gcd f) (s₂.gcd f))","decl":"theorem gcd_union [DecidableEq β] : (s₁ ∪ s₂).gcd f = GCDMonoid.gcd (s₁.gcd f) (s₂.gcd f) :=\n  Finset.induction_on s₁ (by rw [empty_union, gcd_empty, gcd_zero_left, normalize_gcd])\n    fun a s _ ih ↦ by rw [insert_union, gcd_insert, gcd_insert, ih, gcd_assoc]\n\n"}
{"name":"Finset.gcd_congr","module":"Mathlib.Algebra.GCDMonoid.Finset","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : NormalizedGCDMonoid α\ns₁ s₂ : Finset β\nf g : β → α\nhs : Eq s₁ s₂\nhfg : ∀ (a : β), Membership.mem s₂ a → Eq (f a) (g a)\n⊢ Eq (s₁.gcd f) (s₂.gcd g)","decl":"theorem gcd_congr {f g : β → α} (hs : s₁ = s₂) (hfg : ∀ a ∈ s₂, f a = g a) :\n    s₁.gcd f = s₂.gcd g := by\n  subst hs\n  exact Finset.fold_congr hfg\n\n"}
{"name":"Finset.gcd_mono_fun","module":"Mathlib.Algebra.GCDMonoid.Finset","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : NormalizedGCDMonoid α\ns : Finset β\nf g : β → α\nh : ∀ (b : β), Membership.mem s b → Dvd.dvd (f b) (g b)\n⊢ Dvd.dvd (s.gcd f) (s.gcd g)","decl":"theorem gcd_mono_fun {g : β → α} (h : ∀ b ∈ s, f b ∣ g b) : s.gcd f ∣ s.gcd g :=\n  dvd_gcd fun b hb ↦ (gcd_dvd hb).trans (h b hb)\n\n"}
{"name":"Finset.gcd_mono","module":"Mathlib.Algebra.GCDMonoid.Finset","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : NormalizedGCDMonoid α\ns₁ s₂ : Finset β\nf : β → α\nh : HasSubset.Subset s₁ s₂\n⊢ Dvd.dvd (s₂.gcd f) (s₁.gcd f)","decl":"theorem gcd_mono (h : s₁ ⊆ s₂) : s₂.gcd f ∣ s₁.gcd f :=\n  dvd_gcd fun _ hb ↦ gcd_dvd (h hb)\n\n"}
{"name":"Finset.gcd_image","module":"Mathlib.Algebra.GCDMonoid.Finset","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝² : CancelCommMonoidWithZero α\ninst✝¹ : NormalizedGCDMonoid α\nf : β → α\ninst✝ : DecidableEq β\ng : γ → β\ns : Finset γ\n⊢ Eq ((Finset.image g s).gcd f) (s.gcd (Function.comp f g))","decl":"theorem gcd_image [DecidableEq β] {g : γ → β} (s : Finset γ) :\n    (s.image g).gcd f = s.gcd (f ∘ g) := by\n  classical induction s using Finset.induction <;> simp [*]\n\n"}
{"name":"Finset.gcd_eq_gcd_image","module":"Mathlib.Algebra.GCDMonoid.Finset","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝² : CancelCommMonoidWithZero α\ninst✝¹ : NormalizedGCDMonoid α\ns : Finset β\nf : β → α\ninst✝ : DecidableEq α\n⊢ Eq (s.gcd f) ((Finset.image f s).gcd id)","decl":"theorem gcd_eq_gcd_image [DecidableEq α] : s.gcd f = (s.image f).gcd id :=\n  Eq.symm <| gcd_image _\n\n"}
{"name":"Finset.gcd_eq_zero_iff","module":"Mathlib.Algebra.GCDMonoid.Finset","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : NormalizedGCDMonoid α\ns : Finset β\nf : β → α\n⊢ Iff (Eq (s.gcd f) 0) (∀ (x : β), Membership.mem s x → Eq (f x) 0)","decl":"theorem gcd_eq_zero_iff : s.gcd f = 0 ↔ ∀ x : β, x ∈ s → f x = 0 := by\n  rw [gcd_def, Multiset.gcd_eq_zero_iff]\n  constructor <;> intro h\n  · intro b bs\n    apply h (f b)\n    simp only [Multiset.mem_map, mem_def.1 bs]\n    use b\n    simp only [mem_def.1 bs, eq_self_iff_true, and_self]\n  · intro a as\n    rw [Multiset.mem_map] at as\n    rcases as with ⟨b, ⟨bs, rfl⟩⟩\n    apply h b (mem_def.1 bs)\n\n/- Porting note: The change from `p : α → Prop` to `p : α → Bool` made this slightly less nice with\nall the `decide`s around. -/\n"}
{"name":"Finset.gcd_eq_gcd_filter_ne_zero","module":"Mathlib.Algebra.GCDMonoid.Finset","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝² : CancelCommMonoidWithZero α\ninst✝¹ : NormalizedGCDMonoid α\ns : Finset β\nf : β → α\ninst✝ : DecidablePred fun x => Eq (f x) 0\n⊢ Eq (s.gcd f) ((Finset.filter (fun x => Ne (f x) 0) s).gcd f)","decl":"theorem gcd_eq_gcd_filter_ne_zero [DecidablePred fun x : β ↦ f x = 0] :\n    s.gcd f = (s.filter fun x ↦ f x ≠ 0).gcd f := by\n  classical\n    trans ((s.filter fun x ↦ f x = 0) ∪ s.filter fun x ↦ (f x ≠ 0)).gcd f\n    · rw [filter_union_filter_neg_eq]\n    rw [gcd_union]\n    refine Eq.trans (?_ : _ = GCDMonoid.gcd (0 : α) ?_) (?_ : GCDMonoid.gcd (0 : α) _ = _)\n    · exact (gcd (filter (fun x => (f x ≠ 0)) s) f)\n    · refine congr (congr rfl <| s.induction_on ?_ ?_) (by simp)\n      · simp\n      · intro a s _ h\n        rw [filter_insert]\n        split_ifs with h1 <;> simp [h, h1]\n    simp only [gcd_zero_left, normalize_gcd]\n\n"}
{"name":"Finset.gcd_mul_left","module":"Mathlib.Algebra.GCDMonoid.Finset","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : NormalizedGCDMonoid α\ns : Finset β\nf : β → α\na : α\n⊢ Eq (s.gcd fun x => HMul.hMul a (f x)) (HMul.hMul (normalize a) (s.gcd f))","decl":"nonrec theorem gcd_mul_left {a : α} : (s.gcd fun x ↦ a * f x) = normalize a * s.gcd f := by\n  classical\n    refine s.induction_on ?_ ?_\n    · simp\n    · intro b t _ h\n      rw [gcd_insert, gcd_insert, h, ← gcd_mul_left]\n      apply ((normalize_associated a).mul_right _).gcd_eq_right\n\n"}
{"name":"Finset.gcd_mul_right","module":"Mathlib.Algebra.GCDMonoid.Finset","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : NormalizedGCDMonoid α\ns : Finset β\nf : β → α\na : α\n⊢ Eq (s.gcd fun x => HMul.hMul (f x) a) (HMul.hMul (s.gcd f) (normalize a))","decl":"nonrec theorem gcd_mul_right {a : α} : (s.gcd fun x ↦ f x * a) = s.gcd f * normalize a := by\n  classical\n    refine s.induction_on ?_ ?_\n    · simp\n    · intro b t _ h\n      rw [gcd_insert, gcd_insert, h, ← gcd_mul_right]\n      apply ((normalize_associated a).mul_left _).gcd_eq_right\n\n"}
{"name":"Finset.extract_gcd'","module":"Mathlib.Algebra.GCDMonoid.Finset","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : NormalizedGCDMonoid α\ns : Finset β\nf g : β → α\nhs : Exists fun x => And (Membership.mem s x) (Ne (f x) 0)\nhg : ∀ (b : β), Membership.mem s b → Eq (f b) (HMul.hMul (s.gcd f) (g b))\n⊢ Eq (s.gcd g) 1","decl":"theorem extract_gcd' (f g : β → α) (hs : ∃ x, x ∈ s ∧ f x ≠ 0)\n    (hg : ∀ b ∈ s, f b = s.gcd f * g b) : s.gcd g = 1 :=\n  ((@mul_right_eq_self₀ _ _ (s.gcd f) _).1 <| by\n        conv_lhs => rw [← normalize_gcd, ← gcd_mul_left, ← gcd_congr rfl hg]).resolve_right <| by\n    contrapose! hs\n    exact gcd_eq_zero_iff.1 hs\n\n"}
{"name":"Finset.extract_gcd","module":"Mathlib.Algebra.GCDMonoid.Finset","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : NormalizedGCDMonoid α\ns : Finset β\nf : β → α\nhs : s.Nonempty\n⊢ Exists fun g => And (∀ (b : β), Membership.mem s b → Eq (f b) (HMul.hMul (s.gcd f) (g b))) (Eq (s.gcd g) 1)","decl":"theorem extract_gcd (f : β → α) (hs : s.Nonempty) :\n    ∃ g : β → α, (∀ b ∈ s, f b = s.gcd f * g b) ∧ s.gcd g = 1 := by\n  classical\n    by_cases h : ∀ x ∈ s, f x = (0 : α)\n    · refine ⟨fun _ ↦ 1, fun b hb ↦ by rw [h b hb, gcd_eq_zero_iff.2 h, mul_one], ?_⟩\n      rw [gcd_eq_gcd_image, image_const hs, gcd_singleton, id, normalize_one]\n    · choose g' hg using @gcd_dvd _ _ _ _ s f\n      push_neg at h\n      refine ⟨fun b ↦ if hb : b ∈ s then g' hb else 0, fun b hb ↦ ?_,\n          extract_gcd' f _ h fun b hb ↦ ?_⟩\n      · simp only [hb, hg, dite_true]\n      rw [dif_pos hb, hg hb]\n\n"}
{"name":"Finset.gcd_div_eq_one","module":"Mathlib.Algebra.GCDMonoid.Finset","initialProofState":"ι : Type u_1\nα : Type u_2\ninst✝³ : CancelCommMonoidWithZero α\ninst✝² : NormalizedGCDMonoid α\ninst✝¹ : Div α\ninst✝ : MulDivCancelClass α\nf : ι → α\ns : Finset ι\ni : ι\nhis : Membership.mem s i\nhfi : Ne (f i) 0\n⊢ Eq (s.gcd fun j => HDiv.hDiv (f j) (s.gcd f)) 1","decl":"/-- Given a nonempty Finset `s` and a function `f` from `s` to `ℕ`, if `d = s.gcd`,\nthen the `gcd` of `(f i) / d` is equal to `1`. -/\nlemma gcd_div_eq_one (his : i ∈ s) (hfi : f i ≠ 0) : s.gcd (fun j ↦ f j / s.gcd f) = 1 := by\n  obtain ⟨g, he, hg⟩ := Finset.extract_gcd f ⟨i, his⟩\n  refine (Finset.gcd_congr rfl fun a ha ↦ ?_).trans hg\n  rw [he a ha, mul_div_cancel_left₀]\n  exact mt Finset.gcd_eq_zero_iff.1 fun h ↦ hfi <| h i his\n\n"}
{"name":"Finset.gcd_div_id_eq_one","module":"Mathlib.Algebra.GCDMonoid.Finset","initialProofState":"α : Type u_2\ninst✝³ : CancelCommMonoidWithZero α\ninst✝² : NormalizedGCDMonoid α\ninst✝¹ : Div α\ninst✝ : MulDivCancelClass α\ns : Finset α\na : α\nhas : Membership.mem s a\nha : Ne a 0\n⊢ Eq (s.gcd fun b => HDiv.hDiv b (s.gcd id)) 1","decl":"lemma gcd_div_id_eq_one {s : Finset α} {a : α} (has : a ∈ s) (ha : a ≠ 0) :\n    s.gcd (fun b ↦ b / s.gcd id) = 1 := gcd_div_eq_one has ha\n\n"}
{"name":"Finset.gcd_eq_of_dvd_sub","module":"Mathlib.Algebra.GCDMonoid.Finset","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝² : CommRing α\ninst✝¹ : IsDomain α\ninst✝ : NormalizedGCDMonoid α\ns : Finset β\nf g : β → α\na : α\nh : ∀ (x : β), Membership.mem s x → Dvd.dvd a (HSub.hSub (f x) (g x))\n⊢ Eq (GCDMonoid.gcd a (s.gcd f)) (GCDMonoid.gcd a (s.gcd g))","decl":"theorem gcd_eq_of_dvd_sub {s : Finset β} {f g : β → α} {a : α}\n    (h : ∀ x : β, x ∈ s → a ∣ f x - g x) :\n    GCDMonoid.gcd a (s.gcd f) = GCDMonoid.gcd a (s.gcd g) := by\n  classical\n    revert h\n    refine s.induction_on ?_ ?_\n    · simp\n    intro b s _ hi h\n    rw [gcd_insert, gcd_insert, gcd_comm (f b), ← gcd_assoc,\n      hi fun x hx ↦ h _ (mem_insert_of_mem hx), gcd_comm a, gcd_assoc,\n      gcd_comm a (GCDMonoid.gcd _ _), gcd_comm (g b), gcd_assoc _ _ a, gcd_comm _ a]\n    exact congr_arg _ (gcd_eq_of_dvd_sub_right (h _ (mem_insert_self _ _)))\n\n"}
