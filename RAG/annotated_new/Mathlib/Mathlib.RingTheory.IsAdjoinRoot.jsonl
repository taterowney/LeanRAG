{"name":"IsAdjoinRoot.ker_map","module":"Mathlib.RingTheory.IsAdjoinRoot","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommSemiring R\ninst✝¹ : Semiring S\ninst✝ : Algebra R S\nf : Polynomial R\nself : IsAdjoinRoot S f\n⊢ Eq (RingHom.ker self.map) (Ideal.span (Singleton.singleton f))","decl":"/-- `IsAdjoinRoot S f` states that the ring `S` can be constructed by adjoining a specified root\nof the polynomial `f : R[X]` to `R`.\n\nCompare `PowerBasis R S`, which does not explicitly specify which polynomial we adjoin a root of\n(in particular `f` does not need to be the minimal polynomial of the root we adjoin),\nand `AdjoinRoot` which constructs a new type.\n\nThis is not a typeclass because the choice of root given `S` and `f` is not unique.\n-/\nstructure IsAdjoinRoot {R : Type u} (S : Type v) [CommSemiring R] [Semiring S] [Algebra R S]\n    (f : R[X]) : Type max u v where\n  map : R[X] →+* S\n  map_surjective : Function.Surjective map\n  ker_map : RingHom.ker map = Ideal.span {f}\n  algebraMap_eq : algebraMap R S = map.comp Polynomial.C\n\n-- This class doesn't really make sense on a predicate\n"}
{"name":"IsAdjoinRoot.algebraMap_eq","module":"Mathlib.RingTheory.IsAdjoinRoot","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommSemiring R\ninst✝¹ : Semiring S\ninst✝ : Algebra R S\nf : Polynomial R\nself : IsAdjoinRoot S f\n⊢ Eq (algebraMap R S) (self.map.comp Polynomial.C)","decl":"/-- `IsAdjoinRoot S f` states that the ring `S` can be constructed by adjoining a specified root\nof the polynomial `f : R[X]` to `R`.\n\nCompare `PowerBasis R S`, which does not explicitly specify which polynomial we adjoin a root of\n(in particular `f` does not need to be the minimal polynomial of the root we adjoin),\nand `AdjoinRoot` which constructs a new type.\n\nThis is not a typeclass because the choice of root given `S` and `f` is not unique.\n-/\nstructure IsAdjoinRoot {R : Type u} (S : Type v) [CommSemiring R] [Semiring S] [Algebra R S]\n    (f : R[X]) : Type max u v where\n  map : R[X] →+* S\n  map_surjective : Function.Surjective map\n  ker_map : RingHom.ker map = Ideal.span {f}\n  algebraMap_eq : algebraMap R S = map.comp Polynomial.C\n\n-- This class doesn't really make sense on a predicate\n"}
{"name":"IsAdjoinRoot.map_surjective","module":"Mathlib.RingTheory.IsAdjoinRoot","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommSemiring R\ninst✝¹ : Semiring S\ninst✝ : Algebra R S\nf : Polynomial R\nself : IsAdjoinRoot S f\n⊢ Function.Surjective ⇑self.map","decl":"/-- `IsAdjoinRoot S f` states that the ring `S` can be constructed by adjoining a specified root\nof the polynomial `f : R[X]` to `R`.\n\nCompare `PowerBasis R S`, which does not explicitly specify which polynomial we adjoin a root of\n(in particular `f` does not need to be the minimal polynomial of the root we adjoin),\nand `AdjoinRoot` which constructs a new type.\n\nThis is not a typeclass because the choice of root given `S` and `f` is not unique.\n-/\nstructure IsAdjoinRoot {R : Type u} (S : Type v) [CommSemiring R] [Semiring S] [Algebra R S]\n    (f : R[X]) : Type max u v where\n  map : R[X] →+* S\n  map_surjective : Function.Surjective map\n  ker_map : RingHom.ker map = Ideal.span {f}\n  algebraMap_eq : algebraMap R S = map.comp Polynomial.C\n\n-- This class doesn't really make sense on a predicate\n"}
{"name":"IsAdjoinRoot.mk.injEq","module":"Mathlib.RingTheory.IsAdjoinRoot","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommSemiring R\ninst✝¹ : Semiring S\ninst✝ : Algebra R S\nf : Polynomial R\nmap✝ : RingHom (Polynomial R) S\nmap_surjective✝ : Function.Surjective ⇑map✝\nker_map✝ : Eq (RingHom.ker map✝) (Ideal.span (Singleton.singleton f))\nalgebraMap_eq✝ : Eq (algebraMap R S) (map✝.comp Polynomial.C)\nmap : RingHom (Polynomial R) S\nmap_surjective : Function.Surjective ⇑map\nker_map : Eq (RingHom.ker map) (Ideal.span (Singleton.singleton f))\nalgebraMap_eq : Eq (algebraMap R S) (map.comp Polynomial.C)\n⊢ Eq (Eq { map := map✝, map_surjective := map_surjective✝, ker_map := ker_map✝, algebraMap_eq := algebraMap_eq✝ } { map := map, map_surjective := map_surjective, ker_map := ker_map, algebraMap_eq := algebraMap_eq }) (Eq map✝ map)","decl":"/-- `IsAdjoinRoot S f` states that the ring `S` can be constructed by adjoining a specified root\nof the polynomial `f : R[X]` to `R`.\n\nCompare `PowerBasis R S`, which does not explicitly specify which polynomial we adjoin a root of\n(in particular `f` does not need to be the minimal polynomial of the root we adjoin),\nand `AdjoinRoot` which constructs a new type.\n\nThis is not a typeclass because the choice of root given `S` and `f` is not unique.\n-/\nstructure IsAdjoinRoot {R : Type u} (S : Type v) [CommSemiring R] [Semiring S] [Algebra R S]\n    (f : R[X]) : Type max u v where\n  map : R[X] →+* S\n  map_surjective : Function.Surjective map\n  ker_map : RingHom.ker map = Ideal.span {f}\n  algebraMap_eq : algebraMap R S = map.comp Polynomial.C\n\n-- This class doesn't really make sense on a predicate\n"}
{"name":"IsAdjoinRoot.mk.sizeOf_spec","module":"Mathlib.RingTheory.IsAdjoinRoot","initialProofState":"R : Type u\nS : Type v\ninst✝⁴ : CommSemiring R\ninst✝³ : Semiring S\ninst✝² : Algebra R S\nf : Polynomial R\ninst✝¹ : SizeOf R\ninst✝ : SizeOf S\nmap : RingHom (Polynomial R) S\nmap_surjective : Function.Surjective ⇑map\nker_map : Eq (RingHom.ker map) (Ideal.span (Singleton.singleton f))\nalgebraMap_eq : Eq (algebraMap R S) (map.comp Polynomial.C)\n⊢ Eq (SizeOf.sizeOf { map := map, map_surjective := map_surjective, ker_map := ker_map, algebraMap_eq := algebraMap_eq }) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf map)) (SizeOf.sizeOf ker_map)) (SizeOf.sizeOf algebraMap_eq))","decl":"/-- `IsAdjoinRoot S f` states that the ring `S` can be constructed by adjoining a specified root\nof the polynomial `f : R[X]` to `R`.\n\nCompare `PowerBasis R S`, which does not explicitly specify which polynomial we adjoin a root of\n(in particular `f` does not need to be the minimal polynomial of the root we adjoin),\nand `AdjoinRoot` which constructs a new type.\n\nThis is not a typeclass because the choice of root given `S` and `f` is not unique.\n-/\nstructure IsAdjoinRoot {R : Type u} (S : Type v) [CommSemiring R] [Semiring S] [Algebra R S]\n    (f : R[X]) : Type max u v where\n  map : R[X] →+* S\n  map_surjective : Function.Surjective map\n  ker_map : RingHom.ker map = Ideal.span {f}\n  algebraMap_eq : algebraMap R S = map.comp Polynomial.C\n\n-- This class doesn't really make sense on a predicate\n"}
{"name":"IsAdjoinRoot.mk.inj","module":"Mathlib.RingTheory.IsAdjoinRoot","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommSemiring R\ninst✝¹ : Semiring S\ninst✝ : Algebra R S\nf : Polynomial R\nmap✝ : RingHom (Polynomial R) S\nmap_surjective✝ : Function.Surjective ⇑map✝\nker_map✝ : Eq (RingHom.ker map✝) (Ideal.span (Singleton.singleton f))\nalgebraMap_eq✝ : Eq (algebraMap R S) (map✝.comp Polynomial.C)\nmap : RingHom (Polynomial R) S\nmap_surjective : Function.Surjective ⇑map\nker_map : Eq (RingHom.ker map) (Ideal.span (Singleton.singleton f))\nalgebraMap_eq : Eq (algebraMap R S) (map.comp Polynomial.C)\nx✝ : Eq { map := map✝, map_surjective := map_surjective✝, ker_map := ker_map✝, algebraMap_eq := algebraMap_eq✝ } { map := map, map_surjective := map_surjective, ker_map := ker_map, algebraMap_eq := algebraMap_eq }\n⊢ Eq map✝ map","decl":"/-- `IsAdjoinRoot S f` states that the ring `S` can be constructed by adjoining a specified root\nof the polynomial `f : R[X]` to `R`.\n\nCompare `PowerBasis R S`, which does not explicitly specify which polynomial we adjoin a root of\n(in particular `f` does not need to be the minimal polynomial of the root we adjoin),\nand `AdjoinRoot` which constructs a new type.\n\nThis is not a typeclass because the choice of root given `S` and `f` is not unique.\n-/\nstructure IsAdjoinRoot {R : Type u} (S : Type v) [CommSemiring R] [Semiring S] [Algebra R S]\n    (f : R[X]) : Type max u v where\n  map : R[X] →+* S\n  map_surjective : Function.Surjective map\n  ker_map : RingHom.ker map = Ideal.span {f}\n  algebraMap_eq : algebraMap R S = map.comp Polynomial.C\n\n-- This class doesn't really make sense on a predicate\n"}
{"name":"IsAdjoinRootMonic.mk.inj","module":"Mathlib.RingTheory.IsAdjoinRoot","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommSemiring R\ninst✝¹ : Semiring S\ninst✝ : Algebra R S\nf : Polynomial R\ntoIsAdjoinRoot✝ : IsAdjoinRoot S f\nMonic✝ : f.Monic\ntoIsAdjoinRoot : IsAdjoinRoot S f\nMonic : f.Monic\nx✝ : Eq { toIsAdjoinRoot := toIsAdjoinRoot✝, Monic := Monic✝ } { toIsAdjoinRoot := toIsAdjoinRoot, Monic := Monic }\n⊢ Eq toIsAdjoinRoot✝ toIsAdjoinRoot","decl":"/-- `IsAdjoinRootMonic S f` states that the ring `S` can be constructed by adjoining a specified\nroot of the monic polynomial `f : R[X]` to `R`.\n\nAs long as `f` is monic, there is a well-defined representation of elements of `S` as polynomials\nin `R[X]` of degree lower than `deg f` (see `modByMonicHom` and `coeff`). In particular,\nwe have `IsAdjoinRootMonic.powerBasis`.\n\nBundling `Monic` into this structure is very useful when working with explicit `f`s such as\n`X^2 - C a * X - C b` since it saves you carrying around the proofs of monicity.\n-/\n-- @[nolint has_nonempty_instance] -- Porting note: This linter does not exist yet.\nstructure IsAdjoinRootMonic {R : Type u} (S : Type v) [CommSemiring R] [Semiring S] [Algebra R S]\n    (f : R[X]) extends IsAdjoinRoot S f where\n  Monic : Monic f\n\n"}
{"name":"IsAdjoinRootMonic.mk.sizeOf_spec","module":"Mathlib.RingTheory.IsAdjoinRoot","initialProofState":"R : Type u\nS : Type v\ninst✝⁴ : CommSemiring R\ninst✝³ : Semiring S\ninst✝² : Algebra R S\nf : Polynomial R\ninst✝¹ : SizeOf R\ninst✝ : SizeOf S\ntoIsAdjoinRoot : IsAdjoinRoot S f\nMonic : f.Monic\n⊢ Eq (SizeOf.sizeOf { toIsAdjoinRoot := toIsAdjoinRoot, Monic := Monic }) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf toIsAdjoinRoot)) (SizeOf.sizeOf Monic))","decl":"/-- `IsAdjoinRootMonic S f` states that the ring `S` can be constructed by adjoining a specified\nroot of the monic polynomial `f : R[X]` to `R`.\n\nAs long as `f` is monic, there is a well-defined representation of elements of `S` as polynomials\nin `R[X]` of degree lower than `deg f` (see `modByMonicHom` and `coeff`). In particular,\nwe have `IsAdjoinRootMonic.powerBasis`.\n\nBundling `Monic` into this structure is very useful when working with explicit `f`s such as\n`X^2 - C a * X - C b` since it saves you carrying around the proofs of monicity.\n-/\n-- @[nolint has_nonempty_instance] -- Porting note: This linter does not exist yet.\nstructure IsAdjoinRootMonic {R : Type u} (S : Type v) [CommSemiring R] [Semiring S] [Algebra R S]\n    (f : R[X]) extends IsAdjoinRoot S f where\n  Monic : Monic f\n\n"}
{"name":"IsAdjoinRootMonic.Monic","module":"Mathlib.RingTheory.IsAdjoinRoot","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommSemiring R\ninst✝¹ : Semiring S\ninst✝ : Algebra R S\nf : Polynomial R\nself : IsAdjoinRootMonic S f\n⊢ f.Monic","decl":"/-- `IsAdjoinRootMonic S f` states that the ring `S` can be constructed by adjoining a specified\nroot of the monic polynomial `f : R[X]` to `R`.\n\nAs long as `f` is monic, there is a well-defined representation of elements of `S` as polynomials\nin `R[X]` of degree lower than `deg f` (see `modByMonicHom` and `coeff`). In particular,\nwe have `IsAdjoinRootMonic.powerBasis`.\n\nBundling `Monic` into this structure is very useful when working with explicit `f`s such as\n`X^2 - C a * X - C b` since it saves you carrying around the proofs of monicity.\n-/\n-- @[nolint has_nonempty_instance] -- Porting note: This linter does not exist yet.\nstructure IsAdjoinRootMonic {R : Type u} (S : Type v) [CommSemiring R] [Semiring S] [Algebra R S]\n    (f : R[X]) extends IsAdjoinRoot S f where\n  Monic : Monic f\n\n"}
{"name":"IsAdjoinRootMonic.mk.injEq","module":"Mathlib.RingTheory.IsAdjoinRoot","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommSemiring R\ninst✝¹ : Semiring S\ninst✝ : Algebra R S\nf : Polynomial R\ntoIsAdjoinRoot✝ : IsAdjoinRoot S f\nMonic✝ : f.Monic\ntoIsAdjoinRoot : IsAdjoinRoot S f\nMonic : f.Monic\n⊢ Eq (Eq { toIsAdjoinRoot := toIsAdjoinRoot✝, Monic := Monic✝ } { toIsAdjoinRoot := toIsAdjoinRoot, Monic := Monic }) (Eq toIsAdjoinRoot✝ toIsAdjoinRoot)","decl":"/-- `IsAdjoinRootMonic S f` states that the ring `S` can be constructed by adjoining a specified\nroot of the monic polynomial `f : R[X]` to `R`.\n\nAs long as `f` is monic, there is a well-defined representation of elements of `S` as polynomials\nin `R[X]` of degree lower than `deg f` (see `modByMonicHom` and `coeff`). In particular,\nwe have `IsAdjoinRootMonic.powerBasis`.\n\nBundling `Monic` into this structure is very useful when working with explicit `f`s such as\n`X^2 - C a * X - C b` since it saves you carrying around the proofs of monicity.\n-/\n-- @[nolint has_nonempty_instance] -- Porting note: This linter does not exist yet.\nstructure IsAdjoinRootMonic {R : Type u} (S : Type v) [CommSemiring R] [Semiring S] [Algebra R S]\n    (f : R[X]) extends IsAdjoinRoot S f where\n  Monic : Monic f\n\n"}
{"name":"IsAdjoinRoot.subsingleton","module":"Mathlib.RingTheory.IsAdjoinRoot","initialProofState":"R : Type u\nS : Type v\ninst✝³ : CommRing R\ninst✝² : Ring S\nf : Polynomial R\ninst✝¹ : Algebra R S\nh : IsAdjoinRoot S f\ninst✝ : Subsingleton R\n⊢ Subsingleton S","decl":"theorem subsingleton (h : IsAdjoinRoot S f) [Subsingleton R] : Subsingleton S :=\n  h.map_surjective.subsingleton\n\n"}
{"name":"IsAdjoinRoot.algebraMap_apply","module":"Mathlib.RingTheory.IsAdjoinRoot","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : Ring S\nf : Polynomial R\ninst✝ : Algebra R S\nh : IsAdjoinRoot S f\nx : R\n⊢ Eq ((algebraMap R S) x) (h.map (Polynomial.C x))","decl":"theorem algebraMap_apply (h : IsAdjoinRoot S f) (x : R) :\n    algebraMap R S x = h.map (Polynomial.C x) := by rw [h.algebraMap_eq, RingHom.comp_apply]\n\n"}
{"name":"IsAdjoinRoot.mem_ker_map","module":"Mathlib.RingTheory.IsAdjoinRoot","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : Ring S\nf : Polynomial R\ninst✝ : Algebra R S\nh : IsAdjoinRoot S f\np : Polynomial R\n⊢ Iff (Membership.mem (RingHom.ker h.map) p) (Dvd.dvd f p)","decl":"theorem mem_ker_map (h : IsAdjoinRoot S f) {p} : p ∈ RingHom.ker h.map ↔ f ∣ p := by\n  rw [h.ker_map, Ideal.mem_span_singleton]\n\n"}
{"name":"IsAdjoinRoot.map_eq_zero_iff","module":"Mathlib.RingTheory.IsAdjoinRoot","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : Ring S\nf : Polynomial R\ninst✝ : Algebra R S\nh : IsAdjoinRoot S f\np : Polynomial R\n⊢ Iff (Eq (h.map p) 0) (Dvd.dvd f p)","decl":"@[simp]\ntheorem map_eq_zero_iff (h : IsAdjoinRoot S f) {p} : h.map p = 0 ↔ f ∣ p := by\n  rw [← h.mem_ker_map, RingHom.mem_ker]\n\n"}
{"name":"IsAdjoinRoot.map_X","module":"Mathlib.RingTheory.IsAdjoinRoot","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : Ring S\nf : Polynomial R\ninst✝ : Algebra R S\nh : IsAdjoinRoot S f\n⊢ Eq (h.map Polynomial.X) h.root","decl":"@[simp]\ntheorem map_X (h : IsAdjoinRoot S f) : h.map X = h.root := rfl\n\n"}
{"name":"IsAdjoinRoot.map_self","module":"Mathlib.RingTheory.IsAdjoinRoot","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : Ring S\nf : Polynomial R\ninst✝ : Algebra R S\nh : IsAdjoinRoot S f\n⊢ Eq (h.map f) 0","decl":"@[simp]\ntheorem map_self (h : IsAdjoinRoot S f) : h.map f = 0 := h.map_eq_zero_iff.mpr dvd_rfl\n\n"}
{"name":"IsAdjoinRoot.aeval_eq","module":"Mathlib.RingTheory.IsAdjoinRoot","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : Ring S\nf : Polynomial R\ninst✝ : Algebra R S\nh : IsAdjoinRoot S f\np : Polynomial R\n⊢ Eq ((Polynomial.aeval h.root) p) (h.map p)","decl":"@[simp]\ntheorem aeval_eq (h : IsAdjoinRoot S f) (p : R[X]) : aeval h.root p = h.map p :=\n  Polynomial.induction_on p (fun x => by rw [aeval_C, h.algebraMap_apply])\n    (fun p q ihp ihq => by rw [map_add, RingHom.map_add, ihp, ihq]) fun n x _ => by\n    rw [map_mul, aeval_C, map_pow, aeval_X, RingHom.map_mul, ← h.algebraMap_apply,\n      RingHom.map_pow, map_X]\n\n"}
{"name":"IsAdjoinRoot.aeval_root","module":"Mathlib.RingTheory.IsAdjoinRoot","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : Ring S\nf : Polynomial R\ninst✝ : Algebra R S\nh : IsAdjoinRoot S f\n⊢ Eq ((Polynomial.aeval h.root) f) 0","decl":"theorem aeval_root (h : IsAdjoinRoot S f) : aeval h.root f = 0 := by rw [aeval_eq, map_self]\n\n"}
{"name":"IsAdjoinRoot.map_repr","module":"Mathlib.RingTheory.IsAdjoinRoot","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : Ring S\nf : Polynomial R\ninst✝ : Algebra R S\nh : IsAdjoinRoot S f\nx : S\n⊢ Eq (h.map (h.repr x)) x","decl":"theorem map_repr (h : IsAdjoinRoot S f) (x : S) : h.map (h.repr x) = x :=\n  (h.map_surjective x).choose_spec\n\n"}
{"name":"IsAdjoinRoot.repr_zero_mem_span","module":"Mathlib.RingTheory.IsAdjoinRoot","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : Ring S\nf : Polynomial R\ninst✝ : Algebra R S\nh : IsAdjoinRoot S f\n⊢ Membership.mem (Ideal.span (Singleton.singleton f)) (h.repr 0)","decl":"/-- `repr` preserves zero, up to multiples of `f` -/\ntheorem repr_zero_mem_span (h : IsAdjoinRoot S f) : h.repr 0 ∈ Ideal.span ({f} : Set R[X]) := by\n  rw [← h.ker_map, RingHom.mem_ker, h.map_repr]\n\n"}
{"name":"IsAdjoinRoot.repr_add_sub_repr_add_repr_mem_span","module":"Mathlib.RingTheory.IsAdjoinRoot","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : Ring S\nf : Polynomial R\ninst✝ : Algebra R S\nh : IsAdjoinRoot S f\nx y : S\n⊢ Membership.mem (Ideal.span (Singleton.singleton f)) (HSub.hSub (h.repr (HAdd.hAdd x y)) (HAdd.hAdd (h.repr x) (h.repr y)))","decl":"/-- `repr` preserves addition, up to multiples of `f` -/\ntheorem repr_add_sub_repr_add_repr_mem_span (h : IsAdjoinRoot S f) (x y : S) :\n    h.repr (x + y) - (h.repr x + h.repr y) ∈ Ideal.span ({f} : Set R[X]) := by\n  rw [← h.ker_map, RingHom.mem_ker, map_sub, h.map_repr, map_add, h.map_repr, h.map_repr, sub_self]\n\n"}
{"name":"IsAdjoinRoot.ext_map","module":"Mathlib.RingTheory.IsAdjoinRoot","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : Ring S\nf : Polynomial R\ninst✝ : Algebra R S\nh h' : IsAdjoinRoot S f\neq : ∀ (x : Polynomial R), Eq (h.map x) (h'.map x)\n⊢ Eq h h'","decl":"/-- Extensionality of the `IsAdjoinRoot` structure itself. See `IsAdjoinRootMonic.ext_elem`\nfor extensionality of the ring elements. -/\ntheorem ext_map (h h' : IsAdjoinRoot S f) (eq : ∀ x, h.map x = h'.map x) : h = h' := by\n  cases h; cases h'; congr\n  exact RingHom.ext eq\n\n"}
{"name":"IsAdjoinRoot.ext_iff","module":"Mathlib.RingTheory.IsAdjoinRoot","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : Ring S\nf : Polynomial R\ninst✝ : Algebra R S\nh h' : IsAdjoinRoot S f\n⊢ Iff (Eq h h') (Eq h.root h'.root)","decl":"/-- Extensionality of the `IsAdjoinRoot` structure itself. See `IsAdjoinRootMonic.ext_elem`\nfor extensionality of the ring elements. -/\n@[ext]\ntheorem ext (h h' : IsAdjoinRoot S f) (eq : h.root = h'.root) : h = h' :=\n  h.ext_map h' fun x => by rw [← h.aeval_eq, ← h'.aeval_eq, eq]\n\n"}
{"name":"IsAdjoinRoot.ext","module":"Mathlib.RingTheory.IsAdjoinRoot","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : Ring S\nf : Polynomial R\ninst✝ : Algebra R S\nh h' : IsAdjoinRoot S f\neq : Eq h.root h'.root\n⊢ Eq h h'","decl":"/-- Extensionality of the `IsAdjoinRoot` structure itself. See `IsAdjoinRootMonic.ext_elem`\nfor extensionality of the ring elements. -/\n@[ext]\ntheorem ext (h h' : IsAdjoinRoot S f) (eq : h.root = h'.root) : h = h' :=\n  h.ext_map h' fun x => by rw [← h.aeval_eq, ← h'.aeval_eq, eq]\n\n"}
{"name":"IsAdjoinRoot.eval₂_repr_eq_eval₂_of_map_eq","module":"Mathlib.RingTheory.IsAdjoinRoot","initialProofState":"R : Type u\nS : Type v\ninst✝³ : CommRing R\ninst✝² : Ring S\nf : Polynomial R\ninst✝¹ : Algebra R S\nT : Type u_1\ninst✝ : CommRing T\ni : RingHom R T\nx : T\nhx : Eq (Polynomial.eval₂ i x f) 0\nh : IsAdjoinRoot S f\nz : S\nw : Polynomial R\nhzw : Eq (h.map w) z\n⊢ Eq (Polynomial.eval₂ i x (h.repr z)) (Polynomial.eval₂ i x w)","decl":"/-- Auxiliary lemma for `IsAdjoinRoot.lift` -/\ntheorem eval₂_repr_eq_eval₂_of_map_eq (h : IsAdjoinRoot S f) (z : S) (w : R[X])\n    (hzw : h.map w = z) : (h.repr z).eval₂ i x = w.eval₂ i x := by\n  rw [eq_comm, ← sub_eq_zero, ← h.map_repr z, ← map_sub, h.map_eq_zero_iff] at hzw\n  obtain ⟨y, hy⟩ := hzw\n  rw [← sub_eq_zero, ← eval₂_sub, hy, eval₂_mul, hx, zero_mul]\n\n"}
{"name":"IsAdjoinRoot.lift_map","module":"Mathlib.RingTheory.IsAdjoinRoot","initialProofState":"R : Type u\nS : Type v\ninst✝³ : CommRing R\ninst✝² : Ring S\nf : Polynomial R\ninst✝¹ : Algebra R S\nT : Type u_1\ninst✝ : CommRing T\ni : RingHom R T\nx : T\nhx : Eq (Polynomial.eval₂ i x f) 0\nh : IsAdjoinRoot S f\nz : Polynomial R\n⊢ Eq ((IsAdjoinRoot.lift i x h hx) (h.map z)) (Polynomial.eval₂ i x z)","decl":"@[simp]\ntheorem lift_map (h : IsAdjoinRoot S f) (z : R[X]) : h.lift i x hx (h.map z) = z.eval₂ i x := by\n  rw [lift, RingHom.coe_mk]\n  dsimp -- Porting note (https://github.com/leanprover-community/mathlib4/issues/11227):added a `dsimp`\n  rw [h.eval₂_repr_eq_eval₂_of_map_eq hx _ _ rfl]\n\n"}
{"name":"IsAdjoinRoot.lift_root","module":"Mathlib.RingTheory.IsAdjoinRoot","initialProofState":"R : Type u\nS : Type v\ninst✝³ : CommRing R\ninst✝² : Ring S\nf : Polynomial R\ninst✝¹ : Algebra R S\nT : Type u_1\ninst✝ : CommRing T\ni : RingHom R T\nx : T\nhx : Eq (Polynomial.eval₂ i x f) 0\nh : IsAdjoinRoot S f\n⊢ Eq ((IsAdjoinRoot.lift i x h hx) h.root) x","decl":"@[simp]\ntheorem lift_root (h : IsAdjoinRoot S f) : h.lift i x hx h.root = x := by\n  rw [← h.map_X, lift_map, eval₂_X]\n\n"}
{"name":"IsAdjoinRoot.lift_algebraMap","module":"Mathlib.RingTheory.IsAdjoinRoot","initialProofState":"R : Type u\nS : Type v\ninst✝³ : CommRing R\ninst✝² : Ring S\nf : Polynomial R\ninst✝¹ : Algebra R S\nT : Type u_1\ninst✝ : CommRing T\ni : RingHom R T\nx : T\nhx : Eq (Polynomial.eval₂ i x f) 0\nh : IsAdjoinRoot S f\na : R\n⊢ Eq ((IsAdjoinRoot.lift i x h hx) ((algebraMap R S) a)) (i a)","decl":"@[simp]\ntheorem lift_algebraMap (h : IsAdjoinRoot S f) (a : R) :\n    h.lift i x hx (algebraMap R S a) = i a := by rw [h.algebraMap_apply, lift_map, eval₂_C]\n\n"}
{"name":"IsAdjoinRoot.apply_eq_lift","module":"Mathlib.RingTheory.IsAdjoinRoot","initialProofState":"R : Type u\nS : Type v\ninst✝³ : CommRing R\ninst✝² : Ring S\nf : Polynomial R\ninst✝¹ : Algebra R S\nT : Type u_1\ninst✝ : CommRing T\ni : RingHom R T\nx : T\nhx : Eq (Polynomial.eval₂ i x f) 0\nh : IsAdjoinRoot S f\ng : RingHom S T\nhmap : ∀ (a : R), Eq (g ((algebraMap R S) a)) (i a)\nhroot : Eq (g h.root) x\na : S\n⊢ Eq (g a) ((IsAdjoinRoot.lift i x h hx) a)","decl":"/-- Auxiliary lemma for `apply_eq_lift` -/\ntheorem apply_eq_lift (h : IsAdjoinRoot S f) (g : S →+* T) (hmap : ∀ a, g (algebraMap R S a) = i a)\n    (hroot : g h.root = x) (a : S) : g a = h.lift i x hx a := by\n  rw [← h.map_repr a, Polynomial.as_sum_range_C_mul_X_pow (h.repr a)]\n  simp only [map_sum, map_mul, map_pow, h.map_X, hroot, ← h.algebraMap_apply, hmap, lift_root,\n    lift_algebraMap]\n\n"}
{"name":"IsAdjoinRoot.eq_lift","module":"Mathlib.RingTheory.IsAdjoinRoot","initialProofState":"R : Type u\nS : Type v\ninst✝³ : CommRing R\ninst✝² : Ring S\nf : Polynomial R\ninst✝¹ : Algebra R S\nT : Type u_1\ninst✝ : CommRing T\ni : RingHom R T\nx : T\nhx : Eq (Polynomial.eval₂ i x f) 0\nh : IsAdjoinRoot S f\ng : RingHom S T\nhmap : ∀ (a : R), Eq (g ((algebraMap R S) a)) (i a)\nhroot : Eq (g h.root) x\n⊢ Eq g (IsAdjoinRoot.lift i x h hx)","decl":"/-- Unicity of `lift`: a map that agrees on `R` and `h.root` agrees with `lift` everywhere. -/\ntheorem eq_lift (h : IsAdjoinRoot S f) (g : S →+* T) (hmap : ∀ a, g (algebraMap R S a) = i a)\n    (hroot : g h.root = x) : g = h.lift i x hx :=\n  RingHom.ext (h.apply_eq_lift hx g hmap hroot)\n\n"}
{"name":"IsAdjoinRoot.coe_liftHom","module":"Mathlib.RingTheory.IsAdjoinRoot","initialProofState":"R : Type u\nS : Type v\ninst✝⁴ : CommRing R\ninst✝³ : Ring S\nf : Polynomial R\ninst✝² : Algebra R S\nT : Type u_1\ninst✝¹ : CommRing T\nx : T\ninst✝ : Algebra R T\nhx' : Eq ((Polynomial.aeval x) f) 0\nh : IsAdjoinRoot S f\n⊢ Eq (↑(IsAdjoinRoot.liftHom x hx' h)) (IsAdjoinRoot.lift (algebraMap R T) x h hx')","decl":"@[simp]\ntheorem coe_liftHom (h : IsAdjoinRoot S f) :\n    (h.liftHom x hx' : S →+* T) = h.lift (algebraMap R T) x hx' := rfl\n\n"}
{"name":"IsAdjoinRoot.lift_algebraMap_apply","module":"Mathlib.RingTheory.IsAdjoinRoot","initialProofState":"R : Type u\nS : Type v\ninst✝⁴ : CommRing R\ninst✝³ : Ring S\nf : Polynomial R\ninst✝² : Algebra R S\nT : Type u_1\ninst✝¹ : CommRing T\nx : T\ninst✝ : Algebra R T\nhx' : Eq ((Polynomial.aeval x) f) 0\nh : IsAdjoinRoot S f\nz : S\n⊢ Eq ((IsAdjoinRoot.lift (algebraMap R T) x h hx') z) ((IsAdjoinRoot.liftHom x hx' h) z)","decl":"theorem lift_algebraMap_apply (h : IsAdjoinRoot S f) (z : S) :\n    h.lift (algebraMap R T) x hx' z = h.liftHom x hx' z := rfl\n\n"}
{"name":"IsAdjoinRoot.liftHom_map","module":"Mathlib.RingTheory.IsAdjoinRoot","initialProofState":"R : Type u\nS : Type v\ninst✝⁴ : CommRing R\ninst✝³ : Ring S\nf : Polynomial R\ninst✝² : Algebra R S\nT : Type u_1\ninst✝¹ : CommRing T\nx : T\ninst✝ : Algebra R T\nhx' : Eq ((Polynomial.aeval x) f) 0\nh : IsAdjoinRoot S f\nz : Polynomial R\n⊢ Eq ((IsAdjoinRoot.liftHom x hx' h) (h.map z)) ((Polynomial.aeval x) z)","decl":"@[simp]\ntheorem liftHom_map (h : IsAdjoinRoot S f) (z : R[X]) : h.liftHom x hx' (h.map z) = aeval x z := by\n  rw [← lift_algebraMap_apply, lift_map, aeval_def]\n\n"}
{"name":"IsAdjoinRoot.liftHom_root","module":"Mathlib.RingTheory.IsAdjoinRoot","initialProofState":"R : Type u\nS : Type v\ninst✝⁴ : CommRing R\ninst✝³ : Ring S\nf : Polynomial R\ninst✝² : Algebra R S\nT : Type u_1\ninst✝¹ : CommRing T\nx : T\ninst✝ : Algebra R T\nhx' : Eq ((Polynomial.aeval x) f) 0\nh : IsAdjoinRoot S f\n⊢ Eq ((IsAdjoinRoot.liftHom x hx' h) h.root) x","decl":"@[simp]\ntheorem liftHom_root (h : IsAdjoinRoot S f) : h.liftHom x hx' h.root = x := by\n  rw [← lift_algebraMap_apply, lift_root]\n\n"}
{"name":"IsAdjoinRoot.eq_liftHom","module":"Mathlib.RingTheory.IsAdjoinRoot","initialProofState":"R : Type u\nS : Type v\ninst✝⁴ : CommRing R\ninst✝³ : Ring S\nf : Polynomial R\ninst✝² : Algebra R S\nT : Type u_1\ninst✝¹ : CommRing T\nx : T\ninst✝ : Algebra R T\nhx' : Eq ((Polynomial.aeval x) f) 0\nh : IsAdjoinRoot S f\ng : AlgHom R S T\nhroot : Eq (g h.root) x\n⊢ Eq g (IsAdjoinRoot.liftHom x hx' h)","decl":"/-- Unicity of `liftHom`: a map that agrees on `h.root` agrees with `liftHom` everywhere. -/\ntheorem eq_liftHom (h : IsAdjoinRoot S f) (g : S →ₐ[R] T) (hroot : g h.root = x) :\n    g = h.liftHom x hx' :=\n  AlgHom.ext (h.apply_eq_lift hx' g g.commutes hroot)\n\n"}
{"name":"AdjoinRoot.isAdjoinRoot_map_eq_mk","module":"Mathlib.RingTheory.IsAdjoinRoot","initialProofState":"R : Type u\ninst✝ : CommRing R\nf : Polynomial R\n⊢ Eq (AdjoinRoot.isAdjoinRoot f).map (AdjoinRoot.mk f)","decl":"@[simp]\ntheorem isAdjoinRoot_map_eq_mk : (AdjoinRoot.isAdjoinRoot f).map = AdjoinRoot.mk f :=\n  rfl\n\n"}
{"name":"AdjoinRoot.isAdjoinRootMonic_map_eq_mk","module":"Mathlib.RingTheory.IsAdjoinRoot","initialProofState":"R : Type u\ninst✝ : CommRing R\nf : Polynomial R\nhf : f.Monic\n⊢ Eq (AdjoinRoot.isAdjoinRootMonic f hf).map (AdjoinRoot.mk f)","decl":"@[simp]\ntheorem isAdjoinRootMonic_map_eq_mk (hf : f.Monic) :\n    (AdjoinRoot.isAdjoinRootMonic f hf).map = AdjoinRoot.mk f :=\n  rfl\n\n"}
{"name":"AdjoinRoot.isAdjoinRoot_root_eq_root","module":"Mathlib.RingTheory.IsAdjoinRoot","initialProofState":"R : Type u\ninst✝ : CommRing R\nf : Polynomial R\n⊢ Eq (AdjoinRoot.isAdjoinRoot f).root (AdjoinRoot.root f)","decl":"@[simp]\ntheorem isAdjoinRoot_root_eq_root : (AdjoinRoot.isAdjoinRoot f).root = AdjoinRoot.root f := by\n  simp only [IsAdjoinRoot.root, AdjoinRoot.root, AdjoinRoot.isAdjoinRoot_map_eq_mk]\n\n"}
{"name":"AdjoinRoot.isAdjoinRootMonic_root_eq_root","module":"Mathlib.RingTheory.IsAdjoinRoot","initialProofState":"R : Type u\ninst✝ : CommRing R\nf : Polynomial R\nhf : f.Monic\n⊢ Eq (AdjoinRoot.isAdjoinRootMonic f hf).root (AdjoinRoot.root f)","decl":"@[simp]\ntheorem isAdjoinRootMonic_root_eq_root (hf : Monic f) :\n    (AdjoinRoot.isAdjoinRootMonic f hf).root = AdjoinRoot.root f := by\n  simp only [IsAdjoinRoot.root, AdjoinRoot.root, AdjoinRoot.isAdjoinRootMonic_map_eq_mk]\n\n"}
{"name":"IsAdjoinRootMonic.map_modByMonic","module":"Mathlib.RingTheory.IsAdjoinRoot","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : Ring S\nf : Polynomial R\ninst✝ : Algebra R S\nh : IsAdjoinRootMonic S f\ng : Polynomial R\n⊢ Eq (h.map (g.modByMonic f)) (h.map g)","decl":"theorem map_modByMonic (h : IsAdjoinRootMonic S f) (g : R[X]) : h.map (g %ₘ f) = h.map g := by\n  rw [← RingHom.sub_mem_ker_iff, mem_ker_map, modByMonic_eq_sub_mul_div _ h.Monic, sub_right_comm,\n    sub_self, zero_sub, dvd_neg]\n  exact ⟨_, rfl⟩\n\n"}
{"name":"IsAdjoinRootMonic.modByMonic_repr_map","module":"Mathlib.RingTheory.IsAdjoinRoot","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : Ring S\nf : Polynomial R\ninst✝ : Algebra R S\nh : IsAdjoinRootMonic S f\ng : Polynomial R\n⊢ Eq ((h.repr (h.map g)).modByMonic f) (g.modByMonic f)","decl":"theorem modByMonic_repr_map (h : IsAdjoinRootMonic S f) (g : R[X]) :\n    h.repr (h.map g) %ₘ f = g %ₘ f :=\n  modByMonic_eq_of_dvd_sub h.Monic <| by rw [← h.mem_ker_map, RingHom.sub_mem_ker_iff, map_repr]\n\n"}
{"name":"IsAdjoinRootMonic.modByMonicHom_map","module":"Mathlib.RingTheory.IsAdjoinRoot","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : Ring S\nf : Polynomial R\ninst✝ : Algebra R S\nh : IsAdjoinRootMonic S f\ng : Polynomial R\n⊢ Eq (h.modByMonicHom (h.map g)) (g.modByMonic f)","decl":"@[simp]\ntheorem modByMonicHom_map (h : IsAdjoinRootMonic S f) (g : R[X]) :\n    h.modByMonicHom (h.map g) = g %ₘ f := h.modByMonic_repr_map g\n\n"}
{"name":"IsAdjoinRootMonic.map_modByMonicHom","module":"Mathlib.RingTheory.IsAdjoinRoot","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : Ring S\nf : Polynomial R\ninst✝ : Algebra R S\nh : IsAdjoinRootMonic S f\nx : S\n⊢ Eq (h.map (h.modByMonicHom x)) x","decl":"@[simp]\ntheorem map_modByMonicHom (h : IsAdjoinRootMonic S f) (x : S) : h.map (h.modByMonicHom x) = x := by\n  rw [modByMonicHom, LinearMap.coe_mk]\n  dsimp -- Porting note (https://github.com/leanprover-community/mathlib4/issues/11227):added a `dsimp`\n  rw [map_modByMonic, map_repr]\n\n"}
{"name":"IsAdjoinRootMonic.modByMonicHom_root_pow","module":"Mathlib.RingTheory.IsAdjoinRoot","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : Ring S\nf : Polynomial R\ninst✝ : Algebra R S\nh : IsAdjoinRootMonic S f\nn : Nat\nhdeg : LT.lt n f.natDegree\n⊢ Eq (h.modByMonicHom (HPow.hPow h.root n)) (HPow.hPow Polynomial.X n)","decl":"@[simp]\ntheorem modByMonicHom_root_pow (h : IsAdjoinRootMonic S f) {n : ℕ} (hdeg : n < natDegree f) :\n    h.modByMonicHom (h.root ^ n) = X ^ n := by\n  nontriviality R\n  rw [← h.map_X, ← map_pow, modByMonicHom_map, modByMonic_eq_self_iff h.Monic, degree_X_pow]\n  contrapose! hdeg\n  simpa [natDegree_le_iff_degree_le] using hdeg\n\n"}
{"name":"IsAdjoinRootMonic.modByMonicHom_root","module":"Mathlib.RingTheory.IsAdjoinRoot","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : Ring S\nf : Polynomial R\ninst✝ : Algebra R S\nh : IsAdjoinRootMonic S f\nhdeg : LT.lt 1 f.natDegree\n⊢ Eq (h.modByMonicHom h.root) Polynomial.X","decl":"@[simp]\ntheorem modByMonicHom_root (h : IsAdjoinRootMonic S f) (hdeg : 1 < natDegree f) :\n    h.modByMonicHom h.root = X := by simpa using modByMonicHom_root_pow h hdeg\n\n"}
{"name":"IsAdjoinRootMonic.basis_apply","module":"Mathlib.RingTheory.IsAdjoinRoot","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : Ring S\nf : Polynomial R\ninst✝ : Algebra R S\nh : IsAdjoinRootMonic S f\ni : Fin f.natDegree\n⊢ Eq (h.basis i) (HPow.hPow h.root ↑i)","decl":"@[simp]\ntheorem basis_apply (h : IsAdjoinRootMonic S f) (i) : h.basis i = h.root ^ (i : ℕ) :=\n  Basis.apply_eq_iff.mpr <|\n    show (h.modByMonicHom (h.toIsAdjoinRoot.root ^ (i : ℕ))).toFinsupp.comapDomain _\n          Fin.val_injective.injOn = Finsupp.single _ _ by\n      ext j\n      rw [Finsupp.comapDomain_apply, modByMonicHom_root_pow]\n      · rw [X_pow_eq_monomial, toFinsupp_monomial, Finsupp.single_apply_left Fin.val_injective]\n      · exact i.is_lt\n\n"}
{"name":"IsAdjoinRootMonic.deg_pos","module":"Mathlib.RingTheory.IsAdjoinRoot","initialProofState":"R : Type u\nS : Type v\ninst✝³ : CommRing R\ninst✝² : Ring S\nf : Polynomial R\ninst✝¹ : Algebra R S\ninst✝ : Nontrivial S\nh : IsAdjoinRootMonic S f\n⊢ LT.lt 0 f.natDegree","decl":"theorem deg_pos [Nontrivial S] (h : IsAdjoinRootMonic S f) : 0 < natDegree f := by\n  rcases h.basis.index_nonempty with ⟨⟨i, hi⟩⟩\n  exact (Nat.zero_le _).trans_lt hi\n\n"}
{"name":"IsAdjoinRootMonic.deg_ne_zero","module":"Mathlib.RingTheory.IsAdjoinRoot","initialProofState":"R : Type u\nS : Type v\ninst✝³ : CommRing R\ninst✝² : Ring S\nf : Polynomial R\ninst✝¹ : Algebra R S\ninst✝ : Nontrivial S\nh : IsAdjoinRootMonic S f\n⊢ Ne f.natDegree 0","decl":"theorem deg_ne_zero [Nontrivial S] (h : IsAdjoinRootMonic S f) : natDegree f ≠ 0 :=\n  h.deg_pos.ne'\n\n"}
{"name":"IsAdjoinRootMonic.powerBasis_gen","module":"Mathlib.RingTheory.IsAdjoinRoot","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : Ring S\nf : Polynomial R\ninst✝ : Algebra R S\nh : IsAdjoinRootMonic S f\n⊢ Eq h.powerBasis.gen h.root","decl":"/-- If `f` is monic, the powers of `h.root` form a basis. -/\n@[simps! gen dim basis]\ndef powerBasis (h : IsAdjoinRootMonic S f) : PowerBasis R S where\n  gen := h.root\n  dim := natDegree f\n  basis := h.basis\n  basis_eq_pow := h.basis_apply\n\n"}
{"name":"IsAdjoinRootMonic.powerBasis_dim","module":"Mathlib.RingTheory.IsAdjoinRoot","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : Ring S\nf : Polynomial R\ninst✝ : Algebra R S\nh : IsAdjoinRootMonic S f\n⊢ Eq h.powerBasis.dim f.natDegree","decl":"/-- If `f` is monic, the powers of `h.root` form a basis. -/\n@[simps! gen dim basis]\ndef powerBasis (h : IsAdjoinRootMonic S f) : PowerBasis R S where\n  gen := h.root\n  dim := natDegree f\n  basis := h.basis\n  basis_eq_pow := h.basis_apply\n\n"}
{"name":"IsAdjoinRootMonic.powerBasis_basis","module":"Mathlib.RingTheory.IsAdjoinRoot","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : Ring S\nf : Polynomial R\ninst✝ : Algebra R S\nh : IsAdjoinRootMonic S f\n⊢ Eq h.powerBasis.basis h.basis","decl":"/-- If `f` is monic, the powers of `h.root` form a basis. -/\n@[simps! gen dim basis]\ndef powerBasis (h : IsAdjoinRootMonic S f) : PowerBasis R S where\n  gen := h.root\n  dim := natDegree f\n  basis := h.basis\n  basis_eq_pow := h.basis_apply\n\n"}
{"name":"IsAdjoinRootMonic.basis_repr","module":"Mathlib.RingTheory.IsAdjoinRoot","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : Ring S\nf : Polynomial R\ninst✝ : Algebra R S\nh : IsAdjoinRootMonic S f\nx : S\ni : Fin f.natDegree\n⊢ Eq ((h.basis.repr x) i) ((h.modByMonicHom x).coeff ↑i)","decl":"@[simp]\ntheorem basis_repr (h : IsAdjoinRootMonic S f) (x : S) (i : Fin (natDegree f)) :\n    h.basis.repr x i = (h.modByMonicHom x).coeff (i : ℕ) := by\n  change (h.modByMonicHom x).toFinsupp.comapDomain _ Fin.val_injective.injOn i = _\n  rw [Finsupp.comapDomain_apply, Polynomial.toFinsupp_apply]\n\n"}
{"name":"IsAdjoinRootMonic.basis_one","module":"Mathlib.RingTheory.IsAdjoinRoot","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : Ring S\nf : Polynomial R\ninst✝ : Algebra R S\nh : IsAdjoinRootMonic S f\nhdeg : LT.lt 1 f.natDegree\n⊢ Eq (h.basis ⟨1, hdeg⟩) h.root","decl":"theorem basis_one (h : IsAdjoinRootMonic S f) (hdeg : 1 < natDegree f) :\n    h.basis ⟨1, hdeg⟩ = h.root := by rw [h.basis_apply, Fin.val_mk, pow_one]\n\n"}
{"name":"IsAdjoinRootMonic.liftPolyₗ_apply","module":"Mathlib.RingTheory.IsAdjoinRoot","initialProofState":"R : Type u\nS : Type v\ninst✝⁴ : CommRing R\ninst✝³ : Ring S\nf : Polynomial R\ninst✝² : Algebra R S\nT : Type u_1\ninst✝¹ : AddCommGroup T\ninst✝ : Module R T\nh : IsAdjoinRootMonic S f\ng : LinearMap (RingHom.id R) (Polynomial R) T\na✝ : S\n⊢ Eq ((h.liftPolyₗ g) a✝) (g (h.modByMonicHom a✝))","decl":"/-- `IsAdjoinRootMonic.liftPolyₗ` lifts a linear map on polynomials to a linear map on `S`. -/\n@[simps!]\ndef liftPolyₗ {T : Type*} [AddCommGroup T] [Module R T] (h : IsAdjoinRootMonic S f)\n    (g : R[X] →ₗ[R] T) : S →ₗ[R] T :=\n  g.comp h.modByMonicHom\n\n"}
{"name":"IsAdjoinRootMonic.coeff_apply_lt","module":"Mathlib.RingTheory.IsAdjoinRoot","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : Ring S\nf : Polynomial R\ninst✝ : Algebra R S\nh : IsAdjoinRootMonic S f\nz : S\ni : Nat\nhi : LT.lt i f.natDegree\n⊢ Eq (h.coeff z i) ((h.basis.repr z) ⟨i, hi⟩)","decl":"theorem coeff_apply_lt (h : IsAdjoinRootMonic S f) (z : S) (i : ℕ) (hi : i < natDegree f) :\n    h.coeff z i = h.basis.repr z ⟨i, hi⟩ := by\n  simp only [coeff, LinearMap.comp_apply, Finsupp.lcoeFun_apply, Finsupp.lmapDomain_apply,\n    LinearEquiv.coe_coe, liftPolyₗ_apply, LinearMap.coe_mk, h.basis_repr]\n  rfl\n\n"}
{"name":"IsAdjoinRootMonic.coeff_apply_coe","module":"Mathlib.RingTheory.IsAdjoinRoot","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : Ring S\nf : Polynomial R\ninst✝ : Algebra R S\nh : IsAdjoinRootMonic S f\nz : S\ni : Fin f.natDegree\n⊢ Eq (h.coeff z ↑i) ((h.basis.repr z) i)","decl":"theorem coeff_apply_coe (h : IsAdjoinRootMonic S f) (z : S) (i : Fin (natDegree f)) :\n    h.coeff z i = h.basis.repr z i := h.coeff_apply_lt z i i.prop\n\n"}
{"name":"IsAdjoinRootMonic.coeff_apply_le","module":"Mathlib.RingTheory.IsAdjoinRoot","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : Ring S\nf : Polynomial R\ninst✝ : Algebra R S\nh : IsAdjoinRootMonic S f\nz : S\ni : Nat\nhi : LE.le f.natDegree i\n⊢ Eq (h.coeff z i) 0","decl":"theorem coeff_apply_le (h : IsAdjoinRootMonic S f) (z : S) (i : ℕ) (hi : natDegree f ≤ i) :\n    h.coeff z i = 0 := by\n  simp only [coeff, LinearMap.comp_apply, Finsupp.lcoeFun_apply, Finsupp.lmapDomain_apply,\n    LinearEquiv.coe_coe, liftPolyₗ_apply, LinearMap.coe_mk, h.basis_repr]\n  nontriviality R\n  exact\n    Polynomial.coeff_eq_zero_of_degree_lt\n      ((degree_modByMonic_lt _ h.Monic).trans_le (Polynomial.degree_le_of_natDegree_le hi))\n\n"}
{"name":"IsAdjoinRootMonic.coeff_apply","module":"Mathlib.RingTheory.IsAdjoinRoot","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : Ring S\nf : Polynomial R\ninst✝ : Algebra R S\nh : IsAdjoinRootMonic S f\nz : S\ni : Nat\n⊢ Eq (h.coeff z i) (dite (LT.lt i f.natDegree) (fun hi => (h.basis.repr z) ⟨i, hi⟩) fun hi => 0)","decl":"theorem coeff_apply (h : IsAdjoinRootMonic S f) (z : S) (i : ℕ) :\n    h.coeff z i = if hi : i < natDegree f then h.basis.repr z ⟨i, hi⟩ else 0 := by\n  split_ifs with hi\n  · exact h.coeff_apply_lt z i hi\n  · exact h.coeff_apply_le z i (le_of_not_lt hi)\n\n"}
{"name":"IsAdjoinRootMonic.coeff_root_pow","module":"Mathlib.RingTheory.IsAdjoinRoot","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : Ring S\nf : Polynomial R\ninst✝ : Algebra R S\nh : IsAdjoinRootMonic S f\nn : Nat\nhn : LT.lt n f.natDegree\n⊢ Eq (h.coeff (HPow.hPow h.root n)) (Pi.single n 1)","decl":"theorem coeff_root_pow (h : IsAdjoinRootMonic S f) {n} (hn : n < natDegree f) :\n    h.coeff (h.root ^ n) = Pi.single n 1 := by\n  ext i\n  rw [coeff_apply]\n  split_ifs with hi\n  · calc\n      h.basis.repr (h.root ^ n) ⟨i, _⟩ = h.basis.repr (h.basis ⟨n, hn⟩) ⟨i, hi⟩ := by\n        rw [h.basis_apply, Fin.val_mk]\n      _ = Pi.single (f := fun _ => R) ((⟨n, hn⟩ : Fin _) : ℕ) (1 : (fun _ => R) n)\n        ↑(⟨i, _⟩ : Fin _) := by\n        rw [h.basis.repr_self, ← Finsupp.single_eq_pi_single,\n          Finsupp.single_apply_left Fin.val_injective]\n      _ = Pi.single (f := fun _ => R) n 1 i := by rw [Fin.val_mk, Fin.val_mk]\n  · refine (Pi.single_eq_of_ne (f := fun _ => R) ?_ (1 : (fun _ => R) n)).symm\n    rintro rfl\n    simp [hi] at hn\n\n"}
{"name":"IsAdjoinRootMonic.coeff_one","module":"Mathlib.RingTheory.IsAdjoinRoot","initialProofState":"R : Type u\nS : Type v\ninst✝³ : CommRing R\ninst✝² : Ring S\nf : Polynomial R\ninst✝¹ : Algebra R S\ninst✝ : Nontrivial S\nh : IsAdjoinRootMonic S f\n⊢ Eq (h.coeff 1) (Pi.single 0 1)","decl":"theorem coeff_one [Nontrivial S] (h : IsAdjoinRootMonic S f) : h.coeff 1 = Pi.single 0 1 := by\n  rw [← h.coeff_root_pow h.deg_pos, pow_zero]\n\n"}
{"name":"IsAdjoinRootMonic.coeff_root","module":"Mathlib.RingTheory.IsAdjoinRoot","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : Ring S\nf : Polynomial R\ninst✝ : Algebra R S\nh : IsAdjoinRootMonic S f\nhdeg : LT.lt 1 f.natDegree\n⊢ Eq (h.coeff h.root) (Pi.single 1 1)","decl":"theorem coeff_root (h : IsAdjoinRootMonic S f) (hdeg : 1 < natDegree f) :\n    h.coeff h.root = Pi.single 1 1 := by rw [← h.coeff_root_pow hdeg, pow_one]\n\n"}
{"name":"IsAdjoinRootMonic.coeff_algebraMap","module":"Mathlib.RingTheory.IsAdjoinRoot","initialProofState":"R : Type u\nS : Type v\ninst✝³ : CommRing R\ninst✝² : Ring S\nf : Polynomial R\ninst✝¹ : Algebra R S\ninst✝ : Nontrivial S\nh : IsAdjoinRootMonic S f\nx : R\n⊢ Eq (h.coeff ((algebraMap R S) x)) (Pi.single 0 x)","decl":"theorem coeff_algebraMap [Nontrivial S] (h : IsAdjoinRootMonic S f) (x : R) :\n    h.coeff (algebraMap R S x) = Pi.single 0 x := by\n  ext i\n  rw [Algebra.algebraMap_eq_smul_one, map_smul, coeff_one, Pi.smul_apply, smul_eq_mul]\n  refine (Pi.apply_single (fun _ y => x * y) ?_ 0 1 i).trans (by simp)\n  simp\n\n"}
{"name":"IsAdjoinRootMonic.ext_elem","module":"Mathlib.RingTheory.IsAdjoinRoot","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : Ring S\nf : Polynomial R\ninst✝ : Algebra R S\nh : IsAdjoinRootMonic S f\nx y : S\nhxy : ∀ (i : Nat), LT.lt i f.natDegree → Eq (h.coeff x i) (h.coeff y i)\n⊢ Eq x y","decl":"theorem ext_elem (h : IsAdjoinRootMonic S f) ⦃x y : S⦄\n    (hxy : ∀ i < natDegree f, h.coeff x i = h.coeff y i) : x = y :=\n  EquivLike.injective h.basis.equivFun <|\n    funext fun i => by\n      rw [Basis.equivFun_apply, ← h.coeff_apply_coe, Basis.equivFun_apply, ← h.coeff_apply_coe,\n        hxy i i.prop]\n\n"}
{"name":"IsAdjoinRootMonic.ext_elem_iff","module":"Mathlib.RingTheory.IsAdjoinRoot","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : Ring S\nf : Polynomial R\ninst✝ : Algebra R S\nh : IsAdjoinRootMonic S f\nx y : S\n⊢ Iff (Eq x y) (∀ (i : Nat), LT.lt i f.natDegree → Eq (h.coeff x i) (h.coeff y i))","decl":"theorem ext_elem_iff (h : IsAdjoinRootMonic S f) {x y : S} :\n    x = y ↔ ∀ i < natDegree f, h.coeff x i = h.coeff y i :=\n  ⟨fun hxy _ _=> hxy ▸ rfl, fun hxy => h.ext_elem hxy⟩\n\n"}
{"name":"IsAdjoinRootMonic.coeff_injective","module":"Mathlib.RingTheory.IsAdjoinRoot","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : Ring S\nf : Polynomial R\ninst✝ : Algebra R S\nh : IsAdjoinRootMonic S f\n⊢ Function.Injective ⇑h.coeff","decl":"theorem coeff_injective (h : IsAdjoinRootMonic S f) : Function.Injective h.coeff := fun _ _ hxy =>\n  h.ext_elem fun _ _ => hxy ▸ rfl\n\n"}
{"name":"IsAdjoinRootMonic.isIntegral_root","module":"Mathlib.RingTheory.IsAdjoinRoot","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : Ring S\nf : Polynomial R\ninst✝ : Algebra R S\nh : IsAdjoinRootMonic S f\n⊢ IsIntegral R h.root","decl":"theorem isIntegral_root (h : IsAdjoinRootMonic S f) : IsIntegral R h.root :=\n  ⟨f, h.Monic, h.aeval_root⟩\n\n"}
{"name":"IsAdjoinRoot.lift_self_apply","module":"Mathlib.RingTheory.IsAdjoinRoot","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nf : Polynomial R\nh : IsAdjoinRoot S f\nx : S\n⊢ Eq ((IsAdjoinRoot.lift (algebraMap R S) h.root h ⋯) x) x","decl":"@[simp]\ntheorem lift_self_apply (h : IsAdjoinRoot S f) (x : S) :\n    h.lift (algebraMap R S) h.root h.aeval_root x = x := by\n  rw [← h.map_repr x, lift_map, ← aeval_def, h.aeval_eq]\n\n"}
{"name":"IsAdjoinRoot.lift_self","module":"Mathlib.RingTheory.IsAdjoinRoot","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nf : Polynomial R\nh : IsAdjoinRoot S f\n⊢ Eq (IsAdjoinRoot.lift (algebraMap R S) h.root h ⋯) (RingHom.id S)","decl":"theorem lift_self (h : IsAdjoinRoot S f) :\n    h.lift (algebraMap R S) h.root h.aeval_root = RingHom.id S :=\n  RingHom.ext h.lift_self_apply\n\n"}
{"name":"IsAdjoinRoot.aequiv_map","module":"Mathlib.RingTheory.IsAdjoinRoot","initialProofState":"R : Type u\nS : Type v\ninst✝⁴ : CommRing R\ninst✝³ : CommRing S\ninst✝² : Algebra R S\nf : Polynomial R\nT : Type u_1\ninst✝¹ : CommRing T\ninst✝ : Algebra R T\nh : IsAdjoinRoot S f\nh' : IsAdjoinRoot T f\nz : Polynomial R\n⊢ Eq ((h.aequiv h') (h.map z)) (h'.map z)","decl":"@[simp]\ntheorem aequiv_map (h : IsAdjoinRoot S f) (h' : IsAdjoinRoot T f) (z : R[X]) :\n    h.aequiv h' (h.map z) = h'.map z := by\n  rw [aequiv, AlgEquiv.coe_mk, Equiv.coe_fn_mk, liftHom_map, aeval_eq]\n\n"}
{"name":"IsAdjoinRoot.aequiv_root","module":"Mathlib.RingTheory.IsAdjoinRoot","initialProofState":"R : Type u\nS : Type v\ninst✝⁴ : CommRing R\ninst✝³ : CommRing S\ninst✝² : Algebra R S\nf : Polynomial R\nT : Type u_1\ninst✝¹ : CommRing T\ninst✝ : Algebra R T\nh : IsAdjoinRoot S f\nh' : IsAdjoinRoot T f\n⊢ Eq ((h.aequiv h') h.root) h'.root","decl":"@[simp]\ntheorem aequiv_root (h : IsAdjoinRoot S f) (h' : IsAdjoinRoot T f) :\n    h.aequiv h' h.root = h'.root := by\n  rw [aequiv, AlgEquiv.coe_mk, Equiv.coe_fn_mk, liftHom_root]\n\n"}
{"name":"IsAdjoinRoot.aequiv_self","module":"Mathlib.RingTheory.IsAdjoinRoot","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nf : Polynomial R\nh : IsAdjoinRoot S f\n⊢ Eq (h.aequiv h) AlgEquiv.refl","decl":"@[simp]\ntheorem aequiv_self (h : IsAdjoinRoot S f) : h.aequiv h = AlgEquiv.refl := by\n  ext a; exact h.lift_self_apply a\n\n"}
{"name":"IsAdjoinRoot.aequiv_symm","module":"Mathlib.RingTheory.IsAdjoinRoot","initialProofState":"R : Type u\nS : Type v\ninst✝⁴ : CommRing R\ninst✝³ : CommRing S\ninst✝² : Algebra R S\nf : Polynomial R\nT : Type u_1\ninst✝¹ : CommRing T\ninst✝ : Algebra R T\nh : IsAdjoinRoot S f\nh' : IsAdjoinRoot T f\n⊢ Eq (h.aequiv h').symm (h'.aequiv h)","decl":"@[simp]\ntheorem aequiv_symm (h : IsAdjoinRoot S f) (h' : IsAdjoinRoot T f) :\n    (h.aequiv h').symm = h'.aequiv h := by ext; rfl\n\n"}
{"name":"IsAdjoinRoot.lift_aequiv","module":"Mathlib.RingTheory.IsAdjoinRoot","initialProofState":"R : Type u\nS : Type v\ninst✝⁵ : CommRing R\ninst✝⁴ : CommRing S\ninst✝³ : Algebra R S\nf : Polynomial R\nT : Type u_1\ninst✝² : CommRing T\ninst✝¹ : Algebra R T\nU : Type u_2\ninst✝ : CommRing U\nh : IsAdjoinRoot S f\nh' : IsAdjoinRoot T f\ni : RingHom R U\nx : U\nhx : Eq (Polynomial.eval₂ i x f) 0\nz : S\n⊢ Eq ((IsAdjoinRoot.lift i x h' hx) ((h.aequiv h') z)) ((IsAdjoinRoot.lift i x h hx) z)","decl":"@[simp]\ntheorem lift_aequiv {U : Type*} [CommRing U] (h : IsAdjoinRoot S f) (h' : IsAdjoinRoot T f)\n    (i : R →+* U) (x hx z) : h'.lift i x hx (h.aequiv h' z) = h.lift i x hx z := by\n  rw [← h.map_repr z, aequiv_map, lift_map, lift_map]\n\n"}
{"name":"IsAdjoinRoot.liftHom_aequiv","module":"Mathlib.RingTheory.IsAdjoinRoot","initialProofState":"R : Type u\nS : Type v\ninst✝⁶ : CommRing R\ninst✝⁵ : CommRing S\ninst✝⁴ : Algebra R S\nf : Polynomial R\nT : Type u_1\ninst✝³ : CommRing T\ninst✝² : Algebra R T\nU : Type u_2\ninst✝¹ : CommRing U\ninst✝ : Algebra R U\nh : IsAdjoinRoot S f\nh' : IsAdjoinRoot T f\nx : U\nhx : Eq ((Polynomial.aeval x) f) 0\nz : S\n⊢ Eq ((IsAdjoinRoot.liftHom x hx h') ((h.aequiv h') z)) ((IsAdjoinRoot.liftHom x hx h) z)","decl":"@[simp]\ntheorem liftHom_aequiv {U : Type*} [CommRing U] [Algebra R U] (h : IsAdjoinRoot S f)\n    (h' : IsAdjoinRoot T f) (x : U) (hx z) : h'.liftHom x hx (h.aequiv h' z) = h.liftHom x hx z :=\n  h.lift_aequiv h' _ _ hx _\n\n"}
{"name":"IsAdjoinRoot.aequiv_aequiv","module":"Mathlib.RingTheory.IsAdjoinRoot","initialProofState":"R : Type u\nS : Type v\ninst✝⁶ : CommRing R\ninst✝⁵ : CommRing S\ninst✝⁴ : Algebra R S\nf : Polynomial R\nT : Type u_1\ninst✝³ : CommRing T\ninst✝² : Algebra R T\nU : Type u_2\ninst✝¹ : CommRing U\ninst✝ : Algebra R U\nh : IsAdjoinRoot S f\nh' : IsAdjoinRoot T f\nh'' : IsAdjoinRoot U f\nx : S\n⊢ Eq ((h'.aequiv h'') ((h.aequiv h') x)) ((h.aequiv h'') x)","decl":"@[simp]\ntheorem aequiv_aequiv {U : Type*} [CommRing U] [Algebra R U] (h : IsAdjoinRoot S f)\n    (h' : IsAdjoinRoot T f) (h'' : IsAdjoinRoot U f) (x) :\n    (h'.aequiv h'') (h.aequiv h' x) = h.aequiv h'' x :=\n  h.liftHom_aequiv _ _ h''.aeval_root _\n\n"}
{"name":"IsAdjoinRoot.aequiv_trans","module":"Mathlib.RingTheory.IsAdjoinRoot","initialProofState":"R : Type u\nS : Type v\ninst✝⁶ : CommRing R\ninst✝⁵ : CommRing S\ninst✝⁴ : Algebra R S\nf : Polynomial R\nT : Type u_1\ninst✝³ : CommRing T\ninst✝² : Algebra R T\nU : Type u_2\ninst✝¹ : CommRing U\ninst✝ : Algebra R U\nh : IsAdjoinRoot S f\nh' : IsAdjoinRoot T f\nh'' : IsAdjoinRoot U f\n⊢ Eq ((h.aequiv h').trans (h'.aequiv h'')) (h.aequiv h'')","decl":"@[simp]\ntheorem aequiv_trans {U : Type*} [CommRing U] [Algebra R U] (h : IsAdjoinRoot S f)\n    (h' : IsAdjoinRoot T f) (h'' : IsAdjoinRoot U f) :\n    (h.aequiv h').trans (h'.aequiv h'') = h.aequiv h'' := by ext z; exact h.aequiv_aequiv h' h'' z\n\n"}
{"name":"IsAdjoinRoot.ofEquiv_map_apply","module":"Mathlib.RingTheory.IsAdjoinRoot","initialProofState":"R : Type u\nS : Type v\ninst✝⁴ : CommRing R\ninst✝³ : CommRing S\ninst✝² : Algebra R S\nf : Polynomial R\nT : Type u_1\ninst✝¹ : CommRing T\ninst✝ : Algebra R T\nh : IsAdjoinRoot S f\ne : AlgEquiv R S T\na✝ : Polynomial R\n⊢ Eq ((h.ofEquiv e).map a✝) (e (h.map a✝))","decl":"/-- Transfer `IsAdjoinRoot` across an algebra isomorphism.\n\nThis is the converse of `IsAdjoinRoot.aequiv`: this turns an `AlgEquiv` into an `IsAdjoinRoot`,\nand `IsAdjoinRoot.aequiv` turns an `IsAdjoinRoot` into an `AlgEquiv`.\n-/\n@[simps! map_apply]\ndef ofEquiv (h : IsAdjoinRoot S f) (e : S ≃ₐ[R] T) : IsAdjoinRoot T f where\n  map := ((e : S ≃+* T) : S →+* T).comp h.map\n  map_surjective := e.surjective.comp h.map_surjective\n  ker_map := by\n    rw [← RingHom.comap_ker, RingHom.ker_coe_equiv, ← RingHom.ker_eq_comap_bot, h.ker_map]\n  algebraMap_eq := by\n    ext\n    simp only [AlgEquiv.commutes, RingHom.comp_apply, AlgEquiv.coe_ringEquiv,\n      RingEquiv.coe_toRingHom, ← h.algebraMap_apply]\n\n"}
{"name":"IsAdjoinRoot.ofEquiv_root","module":"Mathlib.RingTheory.IsAdjoinRoot","initialProofState":"R : Type u\nS : Type v\ninst✝⁴ : CommRing R\ninst✝³ : CommRing S\ninst✝² : Algebra R S\nf : Polynomial R\nT : Type u_1\ninst✝¹ : CommRing T\ninst✝ : Algebra R T\nh : IsAdjoinRoot S f\ne : AlgEquiv R S T\n⊢ Eq (h.ofEquiv e).root (e h.root)","decl":"@[simp]\ntheorem ofEquiv_root (h : IsAdjoinRoot S f) (e : S ≃ₐ[R] T) : (h.ofEquiv e).root = e h.root := rfl\n\n"}
{"name":"IsAdjoinRoot.aequiv_ofEquiv","module":"Mathlib.RingTheory.IsAdjoinRoot","initialProofState":"R : Type u\nS : Type v\ninst✝⁶ : CommRing R\ninst✝⁵ : CommRing S\ninst✝⁴ : Algebra R S\nf : Polynomial R\nT : Type u_1\ninst✝³ : CommRing T\ninst✝² : Algebra R T\nU : Type u_2\ninst✝¹ : CommRing U\ninst✝ : Algebra R U\nh : IsAdjoinRoot S f\nh' : IsAdjoinRoot T f\ne : AlgEquiv R T U\n⊢ Eq (h.aequiv (h'.ofEquiv e)) ((h.aequiv h').trans e)","decl":"@[simp]\ntheorem aequiv_ofEquiv {U : Type*} [CommRing U] [Algebra R U] (h : IsAdjoinRoot S f)\n    (h' : IsAdjoinRoot T f) (e : T ≃ₐ[R] U) : h.aequiv (h'.ofEquiv e) = (h.aequiv h').trans e := by\n  ext a; rw [← h.map_repr a, aequiv_map, AlgEquiv.trans_apply, aequiv_map, ofEquiv_map_apply]\n\n"}
{"name":"IsAdjoinRoot.ofEquiv_aequiv","module":"Mathlib.RingTheory.IsAdjoinRoot","initialProofState":"R : Type u\nS : Type v\ninst✝⁶ : CommRing R\ninst✝⁵ : CommRing S\ninst✝⁴ : Algebra R S\nf : Polynomial R\nT : Type u_1\ninst✝³ : CommRing T\ninst✝² : Algebra R T\nU : Type u_2\ninst✝¹ : CommRing U\ninst✝ : Algebra R U\nh : IsAdjoinRoot S f\nh' : IsAdjoinRoot U f\ne : AlgEquiv R S T\n⊢ Eq ((h.ofEquiv e).aequiv h') (e.symm.trans (h.aequiv h'))","decl":"@[simp]\ntheorem ofEquiv_aequiv {U : Type*} [CommRing U] [Algebra R U] (h : IsAdjoinRoot S f)\n    (h' : IsAdjoinRoot U f) (e : S ≃ₐ[R] T) :\n    (h.ofEquiv e).aequiv h' = e.symm.trans (h.aequiv h') := by\n  ext a\n  rw [← (h.ofEquiv e).map_repr a, aequiv_map, AlgEquiv.trans_apply, ofEquiv_map_apply,\n    e.symm_apply_apply, aequiv_map]\n\n"}
{"name":"IsAdjoinRootMonic.minpoly_eq","module":"Mathlib.RingTheory.IsAdjoinRoot","initialProofState":"R : Type u\nS : Type v\ninst✝⁶ : CommRing R\ninst✝⁵ : CommRing S\ninst✝⁴ : Algebra R S\nf : Polynomial R\ninst✝³ : IsDomain R\ninst✝² : IsDomain S\ninst✝¹ : NoZeroSMulDivisors R S\ninst✝ : IsIntegrallyClosed R\nh : IsAdjoinRootMonic S f\nhirr : Irreducible f\n⊢ Eq (minpoly R h.root) f","decl":"theorem minpoly_eq [IsDomain R] [IsDomain S] [NoZeroSMulDivisors R S] [IsIntegrallyClosed R]\n    (h : IsAdjoinRootMonic S f) (hirr : Irreducible f) : minpoly R h.root = f :=\n  let ⟨q, hq⟩ := minpoly.isIntegrallyClosed_dvd h.isIntegral_root h.aeval_root\n  symm <|\n    eq_of_monic_of_associated h.Monic (minpoly.monic h.isIntegral_root) <| by\n      convert\n        Associated.mul_left (minpoly R h.root) <|\n          associated_one_iff_isUnit.2 <|\n            (hirr.isUnit_or_isUnit hq).resolve_left <| minpoly.not_isUnit R h.root\n      rw [mul_one]\n\n"}
{"name":"Algebra.adjoin.powerBasis'_minpoly_gen","module":"Mathlib.RingTheory.IsAdjoinRoot","initialProofState":"R : Type u\nS : Type v\ninst✝⁶ : CommRing R\ninst✝⁵ : CommRing S\ninst✝⁴ : Algebra R S\ninst✝³ : IsDomain R\ninst✝² : IsDomain S\ninst✝¹ : NoZeroSMulDivisors R S\ninst✝ : IsIntegrallyClosed R\nx : S\nhx' : IsIntegral R x\n⊢ Eq (minpoly R x) (minpoly R (Algebra.adjoin.powerBasis' hx').gen)","decl":"theorem Algebra.adjoin.powerBasis'_minpoly_gen [IsDomain R] [IsDomain S] [NoZeroSMulDivisors R S]\n    [IsIntegrallyClosed R] {x : S} (hx' : IsIntegral R x) :\n    minpoly R x = minpoly R (Algebra.adjoin.powerBasis' hx').gen := by\n  haveI := isDomain_of_prime (prime_of_isIntegrallyClosed hx')\n  haveI :=\n    noZeroSMulDivisors_of_prime_of_degree_ne_zero (prime_of_isIntegrallyClosed hx')\n      (ne_of_lt (degree_pos hx')).symm\n  rw [← minpolyGen_eq, adjoin.powerBasis', minpolyGen_map, minpolyGen_eq,\n    AdjoinRoot.powerBasis'_gen, ← isAdjoinRootMonic_root_eq_root _ (monic hx'), minpoly_eq]\n  exact irreducible hx'\n\n"}
