{"name":"WittVector.le_coeff_eq_iff_le_sub_coeff_eq_zero","module":"Mathlib.RingTheory.WittVector.Complete","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nk : Type u_1\ninstâœ : CommRing k\nx y : WittVector p k\nn : Nat\nâŠ¢ Iff (âˆ€ (i : Nat), LT.lt i n â†’ Eq (x.coeff i) (y.coeff i)) (âˆ€ (i : Nat), LT.lt i n â†’ Eq ((HSub.hSub x y).coeff i) 0)","decl":"theorem le_coeff_eq_iff_le_sub_coeff_eq_zero {x y : ğ• k} {n : â„•} :\n    (âˆ€ i < n, x.coeff i = y.coeff i) â†” âˆ€ i < n, (x - y).coeff i = 0 := by\n  calc\n  _ â†” x.truncate n = y.truncate n := by\n    refine âŸ¨fun h => ?_, fun h i hi => ?_âŸ©\n    Â· ext i\n      simp [h i]\n    Â· rw [â† coeff_truncate x âŸ¨i, hiâŸ©, â† coeff_truncate y âŸ¨i, hiâŸ©, h]\n  _ â†” (x - y).truncate n = 0 := by\n    simp only [map_sub, sub_eq_zero]\n  _ â†” _ := by simp only [â† mem_ker_truncate, RingHom.mem_ker]\n\n"}
{"name":"WittVector.eq_zero_of_p_mul_eq_zero","module":"Mathlib.RingTheory.WittVector.Complete","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nk : Type u_1\ninstâœÂ² : CommRing k\ninstâœÂ¹ : CharP k p\ninstâœ : PerfectRing k p\nx : WittVector p k\nh : Eq (HMul.hMul x â†‘p) 0\nâŠ¢ Eq x 0","decl":"/--\nIf `k` is a perfect ring of characteristic `p`, then the ring of Witt vectors `ğ• k` is\n`p`-torsion free.\n-/\ntheorem eq_zero_of_p_mul_eq_zero (x : ğ• k) (h : x * p = 0) : x = 0 := by\n  rwa [â† frobenius_verschiebung, map_eq_zero_iff _ (frobenius_bijective p k).injective,\n      map_eq_zero_iff _ (verschiebung_injective p k)] at h\n\n"}
{"name":"WittVector.mem_span_p_iff_coeff_zero_eq_zero","module":"Mathlib.RingTheory.WittVector.Complete","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nk : Type u_1\ninstâœÂ² : CommRing k\ninstâœÂ¹ : CharP k p\ninstâœ : PerfectRing k p\nx : WittVector p k\nâŠ¢ Iff (Membership.mem (Ideal.span (Singleton.singleton â†‘p)) x) (Eq (x.coeff 0) 0)","decl":"/--\nIf `k` is a perfect ring of characteristic `p`, a Witt vector `x : ğ• k` falls in ideal generated by\n`p` if and only if its zeroth coefficient is `0`.\n-/\ntheorem mem_span_p_iff_coeff_zero_eq_zero (x : ğ• k) :\n    x âˆˆ (Ideal.span {(p : ğ• k)}) â†” x.coeff 0 = 0 := by\n  simp_rw [Ideal.mem_span_singleton, dvd_def, mul_comm]\n  refine âŸ¨fun âŸ¨u, huâŸ© â†¦ ?_, fun h â†¦ ?_âŸ©\n  Â· rw [hu, mul_charP_coeff_zero]\n  Â· use (frobeniusEquiv p k).symm (x.shift 1)\n    calc\n    _ = verschiebung (x.shift 1) := by\n      simpa using eq_iterate_verschiebung (n := 1) (by simp [h])\n    _ = _ := by\n      rw [â† verschiebung_frobenius, â† frobeniusEquiv_apply,\n          RingEquiv.apply_symm_apply (frobeniusEquiv p k) _]\n\n"}
{"name":"WittVector.mem_span_p_pow_iff_le_coeff_eq_zero","module":"Mathlib.RingTheory.WittVector.Complete","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nk : Type u_1\ninstâœÂ² : CommRing k\ninstâœÂ¹ : CharP k p\ninstâœ : PerfectRing k p\nx : WittVector p k\nn : Nat\nâŠ¢ Iff (Membership.mem (Ideal.span (Singleton.singleton (HPow.hPow (â†‘p) n))) x) (âˆ€ (m : Nat), LT.lt m n â†’ Eq (x.coeff m) 0)","decl":"/--\nIf `k` is a perfect ring of characteristic `p`, a Witt vector `x : ğ• k` falls in ideal generated by\n`p ^ n` if and only if its initial `n` coefficients are `0`.\n-/\ntheorem mem_span_p_pow_iff_le_coeff_eq_zero (x : ğ• k) (n : â„•) :\n    x âˆˆ (Ideal.span {(p ^ n : ğ• k)}) â†” âˆ€ m, m < n â†’ x.coeff m = 0 := by\n  simp_rw [Ideal.mem_span_singleton, dvd_def, mul_comm]\n  refine âŸ¨fun âŸ¨u, huâŸ© m hm â†¦ ?_, fun h â†¦ ?_âŸ©\n  Â· rw [hu, mul_pow_charP_coeff_zero _ hm]\n  Â· use (frobeniusEquiv p k).symm^[n] (x.shift n)\n    rw [â† iterate_verschiebung_iterate_frobenius]\n    calc\n    _ = verschiebung^[n] (x.shift n) := by\n      simpa using eq_iterate_verschiebung (x := x) (n := n) h\n    _ = _ := by\n      congr\n      rw [â† Function.comp_apply (f := frobenius^[n]), â† Function.Commute.comp_iterate]\n      Â· rw [â† WittVector.frobeniusEquiv_apply, â† RingEquiv.coe_trans]\n        simp\n      Â· rw [Function.Commute, Function.Semiconj, â† WittVector.frobeniusEquiv_apply]\n        simp only [RingEquiv.apply_symm_apply, RingEquiv.symm_apply_apply, implies_true]\n\n"}
{"name":"WittVector.isAdicCompleteIdealSpanP","module":"Mathlib.RingTheory.WittVector.Complete","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nk : Type u_1\ninstâœ : CommRing k\nâŠ¢ IsAdicComplete (Ideal.span (Singleton.singleton â†‘p)) (WittVector p k)","decl":"/--\nIf `k` is a perfect ring of characteristic `p`, then the ring of Witt vectors `ğ• k`\nis `p`-adically complete.\n-/\ninstance isAdicCompleteIdealSpanP : IsAdicComplete (Ideal.span {(p : ğ• k)}) (ğ• k) where\n  haus' := by\n    intro _ h\n    ext n\n    simp at h\n    have := h (n + 1)\n    simp only [Ideal.span_singleton_pow, smul_eq_mul, Ideal.mul_top, SModEq.zero,\n        mem_span_p_pow_iff_le_coeff_eq_zero] at this\n    simpa using this n\n  prec' := by\n    intro x h\n    -- construct the limit Witt vector w diagonally\n    use .mk p (fun n â†¦ (x (n + 1)).coeff n)\n    intro n\n    simp only [Ideal.span_singleton_pow, smul_eq_mul, Ideal.mul_top, SModEq.sub_mem,\n      mem_span_p_pow_iff_le_coeff_eq_zero, â† le_coeff_eq_iff_le_sub_coeff_eq_zero] at h âŠ¢\n    intro i hi\n    exact (h hi i (Nat.lt_succ_self i)).symm\n\n"}
