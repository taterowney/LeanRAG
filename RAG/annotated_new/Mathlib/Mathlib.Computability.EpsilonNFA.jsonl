{"name":"εNFA.mk.sizeOf_spec","module":"Mathlib.Computability.EpsilonNFA","initialProofState":"α : Type u\nσ : Type v\ninst✝¹ : SizeOf α\ninst✝ : SizeOf σ\nstep : σ → Option α → Set σ\nstart accept : Set σ\n⊢ Eq (SizeOf.sizeOf { step := step, start := start, accept := accept }) 1","decl":"/-- An `εNFA` is a set of states (`σ`), a transition function from state to state labelled by the\n  alphabet (`step`), a starting state (`start`) and a set of acceptance states (`accept`).\n  Note the transition function sends a state to a `Set` of states and can make ε-transitions by\n  inputting `none`.\n  Since this definition allows for Automata with infinite states, a `Fintype` instance must be\n  supplied for true `εNFA`'s. -/\nstructure εNFA (α : Type u) (σ : Type v) where\n  /-- Transition function. The automaton is rendered non-deterministic by this transition function\n  returning `Set σ` (rather than `σ`), and ε-transitions are made possible by taking `Option α`\n  (rather than `α`). -/\n  step : σ → Option α → Set σ\n  /-- Starting states. -/\n  start : Set σ\n  /-- Set of acceptance states. -/\n  accept : Set σ\n\n"}
{"name":"εNFA.mk.injEq","module":"Mathlib.Computability.EpsilonNFA","initialProofState":"α : Type u\nσ : Type v\nstep✝ : σ → Option α → Set σ\nstart✝ accept✝ : Set σ\nstep : σ → Option α → Set σ\nstart accept : Set σ\n⊢ Eq (Eq { step := step✝, start := start✝, accept := accept✝ } { step := step, start := start, accept := accept }) (And (Eq step✝ step) (And (Eq start✝ start) (Eq accept✝ accept)))","decl":"/-- An `εNFA` is a set of states (`σ`), a transition function from state to state labelled by the\n  alphabet (`step`), a starting state (`start`) and a set of acceptance states (`accept`).\n  Note the transition function sends a state to a `Set` of states and can make ε-transitions by\n  inputting `none`.\n  Since this definition allows for Automata with infinite states, a `Fintype` instance must be\n  supplied for true `εNFA`'s. -/\nstructure εNFA (α : Type u) (σ : Type v) where\n  /-- Transition function. The automaton is rendered non-deterministic by this transition function\n  returning `Set σ` (rather than `σ`), and ε-transitions are made possible by taking `Option α`\n  (rather than `α`). -/\n  step : σ → Option α → Set σ\n  /-- Starting states. -/\n  start : Set σ\n  /-- Set of acceptance states. -/\n  accept : Set σ\n\n"}
{"name":"εNFA.mk.inj","module":"Mathlib.Computability.EpsilonNFA","initialProofState":"α : Type u\nσ : Type v\nstep✝ : σ → Option α → Set σ\nstart✝ accept✝ : Set σ\nstep : σ → Option α → Set σ\nstart accept : Set σ\nx✝ : Eq { step := step✝, start := start✝, accept := accept✝ } { step := step, start := start, accept := accept }\n⊢ And (Eq step✝ step) (And (Eq start✝ start) (Eq accept✝ accept))","decl":"/-- An `εNFA` is a set of states (`σ`), a transition function from state to state labelled by the\n  alphabet (`step`), a starting state (`start`) and a set of acceptance states (`accept`).\n  Note the transition function sends a state to a `Set` of states and can make ε-transitions by\n  inputting `none`.\n  Since this definition allows for Automata with infinite states, a `Fintype` instance must be\n  supplied for true `εNFA`'s. -/\nstructure εNFA (α : Type u) (σ : Type v) where\n  /-- Transition function. The automaton is rendered non-deterministic by this transition function\n  returning `Set σ` (rather than `σ`), and ε-transitions are made possible by taking `Option α`\n  (rather than `α`). -/\n  step : σ → Option α → Set σ\n  /-- Starting states. -/\n  start : Set σ\n  /-- Set of acceptance states. -/\n  accept : Set σ\n\n"}
{"name":"εNFA.subset_εClosure","module":"Mathlib.Computability.EpsilonNFA","initialProofState":"α : Type u\nσ : Type v\nM : εNFA α σ\nS : Set σ\n⊢ HasSubset.Subset S (M.εClosure S)","decl":"@[simp]\ntheorem subset_εClosure (S : Set σ) : S ⊆ M.εClosure S :=\n  εClosure.base\n\n"}
{"name":"εNFA.εClosure_empty","module":"Mathlib.Computability.EpsilonNFA","initialProofState":"α : Type u\nσ : Type v\nM : εNFA α σ\n⊢ Eq (M.εClosure EmptyCollection.emptyCollection) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem εClosure_empty : M.εClosure ∅ = ∅ :=\n  eq_empty_of_forall_not_mem fun s hs ↦ by induction hs <;> assumption\n\n"}
{"name":"εNFA.εClosure_univ","module":"Mathlib.Computability.EpsilonNFA","initialProofState":"α : Type u\nσ : Type v\nM : εNFA α σ\n⊢ Eq (M.εClosure Set.univ) Set.univ","decl":"@[simp]\ntheorem εClosure_univ : M.εClosure univ = univ :=\n  eq_univ_of_univ_subset <| subset_εClosure _ _\n\n"}
{"name":"εNFA.mem_stepSet_iff","module":"Mathlib.Computability.EpsilonNFA","initialProofState":"α : Type u\nσ : Type v\nM : εNFA α σ\nS : Set σ\ns : σ\na : α\n⊢ Iff (Membership.mem (M.stepSet S a) s) (Exists fun t => And (Membership.mem S t) (Membership.mem (M.εClosure (M.step t (Option.some a))) s))","decl":"@[simp]\ntheorem mem_stepSet_iff : s ∈ M.stepSet S a ↔ ∃ t ∈ S, s ∈ M.εClosure (M.step t a) := by\n  simp_rw [stepSet, mem_iUnion₂, exists_prop]\n\n"}
{"name":"εNFA.stepSet_empty","module":"Mathlib.Computability.EpsilonNFA","initialProofState":"α : Type u\nσ : Type v\nM : εNFA α σ\na : α\n⊢ Eq (M.stepSet EmptyCollection.emptyCollection a) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem stepSet_empty (a : α) : M.stepSet ∅ a = ∅ := by\n  simp_rw [stepSet, mem_empty_iff_false, iUnion_false, iUnion_empty]\n\n"}
{"name":"εNFA.evalFrom_nil","module":"Mathlib.Computability.EpsilonNFA","initialProofState":"α : Type u\nσ : Type v\nM : εNFA α σ\nS : Set σ\n⊢ Eq (M.evalFrom S List.nil) (M.εClosure S)","decl":"@[simp]\ntheorem evalFrom_nil (S : Set σ) : M.evalFrom S [] = M.εClosure S :=\n  rfl\n\n"}
{"name":"εNFA.evalFrom_singleton","module":"Mathlib.Computability.EpsilonNFA","initialProofState":"α : Type u\nσ : Type v\nM : εNFA α σ\nS : Set σ\na : α\n⊢ Eq (M.evalFrom S (List.cons a List.nil)) (M.stepSet (M.εClosure S) a)","decl":"@[simp]\ntheorem evalFrom_singleton (S : Set σ) (a : α) : M.evalFrom S [a] = M.stepSet (M.εClosure S) a :=\n  rfl\n\n"}
{"name":"εNFA.evalFrom_append_singleton","module":"Mathlib.Computability.EpsilonNFA","initialProofState":"α : Type u\nσ : Type v\nM : εNFA α σ\nS : Set σ\nx : List α\na : α\n⊢ Eq (M.evalFrom S (HAppend.hAppend x (List.cons a List.nil))) (M.stepSet (M.evalFrom S x) a)","decl":"@[simp]\ntheorem evalFrom_append_singleton (S : Set σ) (x : List α) (a : α) :\n    M.evalFrom S (x ++ [a]) = M.stepSet (M.evalFrom S x) a := by\n  rw [evalFrom, List.foldl_append, List.foldl_cons, List.foldl_nil]\n\n"}
{"name":"εNFA.evalFrom_empty","module":"Mathlib.Computability.EpsilonNFA","initialProofState":"α : Type u\nσ : Type v\nM : εNFA α σ\nx : List α\n⊢ Eq (M.evalFrom EmptyCollection.emptyCollection x) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem evalFrom_empty (x : List α) : M.evalFrom ∅ x = ∅ := by\n  induction' x using List.reverseRecOn with x a ih\n  · rw [evalFrom_nil, εClosure_empty]\n  · rw [evalFrom_append_singleton, ih, stepSet_empty]\n\n"}
{"name":"εNFA.eval_nil","module":"Mathlib.Computability.EpsilonNFA","initialProofState":"α : Type u\nσ : Type v\nM : εNFA α σ\n⊢ Eq (M.eval List.nil) (M.εClosure M.start)","decl":"@[simp]\ntheorem eval_nil : M.eval [] = M.εClosure M.start :=\n  rfl\n\n"}
{"name":"εNFA.eval_singleton","module":"Mathlib.Computability.EpsilonNFA","initialProofState":"α : Type u\nσ : Type v\nM : εNFA α σ\na : α\n⊢ Eq (M.eval (List.cons a List.nil)) (M.stepSet (M.εClosure M.start) a)","decl":"@[simp]\ntheorem eval_singleton (a : α) : M.eval [a] = M.stepSet (M.εClosure M.start) a :=\n  rfl\n\n"}
{"name":"εNFA.eval_append_singleton","module":"Mathlib.Computability.EpsilonNFA","initialProofState":"α : Type u\nσ : Type v\nM : εNFA α σ\nx : List α\na : α\n⊢ Eq (M.eval (HAppend.hAppend x (List.cons a List.nil))) (M.stepSet (M.eval x) a)","decl":"@[simp]\ntheorem eval_append_singleton (x : List α) (a : α) : M.eval (x ++ [a]) = M.stepSet (M.eval x) a :=\n  evalFrom_append_singleton _ _ _ _\n\n"}
{"name":"εNFA.toNFA_evalFrom_match","module":"Mathlib.Computability.EpsilonNFA","initialProofState":"α : Type u\nσ : Type v\nM : εNFA α σ\nstart : Set σ\n⊢ Eq (M.toNFA.evalFrom (M.εClosure start)) (M.evalFrom start)","decl":"@[simp]\ntheorem toNFA_evalFrom_match (start : Set σ) :\n    M.toNFA.evalFrom (M.εClosure start) = M.evalFrom start :=\n  rfl\n\n"}
{"name":"εNFA.toNFA_correct","module":"Mathlib.Computability.EpsilonNFA","initialProofState":"α : Type u\nσ : Type v\nM : εNFA α σ\n⊢ Eq M.toNFA.accepts M.accepts","decl":"@[simp]\ntheorem toNFA_correct : M.toNFA.accepts = M.accepts :=\n  rfl\n\n"}
{"name":"εNFA.pumping_lemma","module":"Mathlib.Computability.EpsilonNFA","initialProofState":"α : Type u\nσ : Type v\nM : εNFA α σ\ninst✝ : Fintype σ\nx : List α\nhx : Membership.mem M.accepts x\nhlen : LE.le (Fintype.card (Set σ)) x.length\n⊢ Exists fun a => Exists fun b => Exists fun c => And (Eq x (HAppend.hAppend (HAppend.hAppend a b) c)) (And (LE.le (HAdd.hAdd a.length b.length) (Fintype.card (Set σ))) (And (Ne b List.nil) (LE.le (HMul.hMul (HMul.hMul (Singleton.singleton a) (KStar.kstar (Singleton.singleton b))) (Singleton.singleton c)) M.accepts)))","decl":"theorem pumping_lemma [Fintype σ] {x : List α} (hx : x ∈ M.accepts)\n    (hlen : Fintype.card (Set σ) ≤ List.length x) :\n    ∃ a b c, x = a ++ b ++ c ∧\n      a.length + b.length ≤ Fintype.card (Set σ) ∧ b ≠ [] ∧ {a} * {b}∗ * {c} ≤ M.accepts :=\n  M.toNFA.pumping_lemma hx hlen\n\n"}
{"name":"NFA.toεNFA_εClosure","module":"Mathlib.Computability.EpsilonNFA","initialProofState":"α : Type u\nσ : Type v\nM : NFA α σ\nS : Set σ\n⊢ Eq (M.toεNFA.εClosure S) S","decl":"@[simp]\ntheorem toεNFA_εClosure (M : NFA α σ) (S : Set σ) : M.toεNFA.εClosure S = S := by\n  ext a\n  refine ⟨?_, εNFA.εClosure.base _⟩\n  rintro (⟨_, h⟩ | ⟨_, _, h, _⟩)\n  · exact h\n  · cases h\n\n"}
{"name":"NFA.toεNFA_evalFrom_match","module":"Mathlib.Computability.EpsilonNFA","initialProofState":"α : Type u\nσ : Type v\nM : NFA α σ\nstart : Set σ\n⊢ Eq (M.toεNFA.evalFrom start) (M.evalFrom start)","decl":"@[simp]\ntheorem toεNFA_evalFrom_match (M : NFA α σ) (start : Set σ) :\n    M.toεNFA.evalFrom start = M.evalFrom start := by\n  rw [evalFrom, εNFA.evalFrom, toεNFA_εClosure]\n  suffices εNFA.stepSet (toεNFA M) = stepSet M by rw [this]\n  ext S s\n  simp only [stepSet, εNFA.stepSet, exists_prop, Set.mem_iUnion]\n  apply exists_congr\n  simp only [and_congr_right_iff]\n  intro _ _\n  rw [M.toεNFA_εClosure]\n  rfl\n\n"}
{"name":"NFA.toεNFA_correct","module":"Mathlib.Computability.EpsilonNFA","initialProofState":"α : Type u\nσ : Type v\nM : NFA α σ\n⊢ Eq M.toεNFA.accepts M.accepts","decl":"@[simp]\ntheorem toεNFA_correct (M : NFA α σ) : M.toεNFA.accepts = M.accepts := by\n  rw [εNFA.accepts, εNFA.eval, toεNFA_evalFrom_match]\n  rfl\n\n"}
{"name":"εNFA.step_zero","module":"Mathlib.Computability.EpsilonNFA","initialProofState":"α : Type u\nσ : Type v\ns : σ\na : Option α\n⊢ Eq (εNFA.step 0 s a) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem step_zero (s a) : (0 : εNFA α σ).step s a = ∅ :=\n  rfl\n\n"}
{"name":"εNFA.step_one","module":"Mathlib.Computability.EpsilonNFA","initialProofState":"α : Type u\nσ : Type v\ns : σ\na : Option α\n⊢ Eq (εNFA.step 1 s a) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem step_one (s a) : (1 : εNFA α σ).step s a = ∅ :=\n  rfl\n\n"}
{"name":"εNFA.start_zero","module":"Mathlib.Computability.EpsilonNFA","initialProofState":"α : Type u\nσ : Type v\n⊢ Eq (εNFA.start 0) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem start_zero : (0 : εNFA α σ).start = ∅ :=\n  rfl\n\n"}
{"name":"εNFA.start_one","module":"Mathlib.Computability.EpsilonNFA","initialProofState":"α : Type u\nσ : Type v\n⊢ Eq (εNFA.start 1) Set.univ","decl":"@[simp]\ntheorem start_one : (1 : εNFA α σ).start = univ :=\n  rfl\n\n"}
{"name":"εNFA.accept_zero","module":"Mathlib.Computability.EpsilonNFA","initialProofState":"α : Type u\nσ : Type v\n⊢ Eq (εNFA.accept 0) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem accept_zero : (0 : εNFA α σ).accept = ∅ :=\n  rfl\n\n"}
{"name":"εNFA.accept_one","module":"Mathlib.Computability.EpsilonNFA","initialProofState":"α : Type u\nσ : Type v\n⊢ Eq (εNFA.accept 1) Set.univ","decl":"@[simp]\ntheorem accept_one : (1 : εNFA α σ).accept = univ :=\n  rfl\n\n"}
