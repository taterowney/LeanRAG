{"name":"MvPowerSeries.ne_zero_iff_exists_coeff_ne_zero_and_weight","module":"Mathlib.RingTheory.MvPowerSeries.Order","initialProofState":"σ : Type u_1\nR : Type u_2\ninst✝ : Semiring R\nw : σ → Nat\nf : MvPowerSeries σ R\n⊢ Iff (Ne f 0) (Exists fun n => Exists fun d => And (Ne ((MvPowerSeries.coeff R d) f) 0) (Eq ((Finsupp.weight w) d) n))","decl":"theorem ne_zero_iff_exists_coeff_ne_zero_and_weight :\n    f ≠ 0 ↔ (∃ n : ℕ, ∃ d : σ →₀ ℕ, coeff R d f ≠ 0 ∧ weight w d = n) := by\n  refine not_iff_not.mp ?_\n  simp only [ne_eq, not_not, not_exists, not_and, forall_apply_eq_imp_iff₂, imp_false]\n  exact MvPowerSeries.ext_iff\n\n"}
{"name":"MvPowerSeries.weightedOrder_zero","module":"Mathlib.RingTheory.MvPowerSeries.Order","initialProofState":"σ : Type u_1\nR : Type u_2\ninst✝ : Semiring R\nw : σ → Nat\n⊢ Eq (MvPowerSeries.weightedOrder w 0) Top.top","decl":"@[simp] theorem weightedOrder_zero : (0 : MvPowerSeries σ R).weightedOrder w = ⊤ := by\n  rw [weightedOrder, dif_pos rfl]\n\n"}
{"name":"MvPowerSeries.ne_zero_iff_weightedOrder_finite","module":"Mathlib.RingTheory.MvPowerSeries.Order","initialProofState":"σ : Type u_1\nR : Type u_2\ninst✝ : Semiring R\nw : σ → Nat\nf : MvPowerSeries σ R\n⊢ Iff (Ne f 0) (Eq (↑(MvPowerSeries.weightedOrder w f).toNat) (MvPowerSeries.weightedOrder w f))","decl":"theorem ne_zero_iff_weightedOrder_finite :\n    f ≠ 0 ↔ (f.weightedOrder w).toNat = f.weightedOrder w := by\n  simp only [weightedOrder, ne_eq, coe_toNat_eq_self, dite_eq_left_iff,\n    ENat.coe_ne_top, imp_false, not_not]\n\n"}
{"name":"MvPowerSeries.weightedOrder_eq_top_iff","module":"Mathlib.RingTheory.MvPowerSeries.Order","initialProofState":"σ : Type u_1\nR : Type u_2\ninst✝ : Semiring R\nw : σ → Nat\nf : MvPowerSeries σ R\n⊢ Iff (Eq (MvPowerSeries.weightedOrder w f) Top.top) (Eq f 0)","decl":"/-- The `0` power series is the unique power series with infinite order.-/\n@[simp]\ntheorem weightedOrder_eq_top_iff :\n    f.weightedOrder w = ⊤ ↔ f = 0 := by\n  rw [← not_iff_not, ← ne_eq, ← ne_eq,   ne_zero_iff_weightedOrder_finite w, coe_toNat_eq_self]\n\n"}
{"name":"MvPowerSeries.exists_coeff_ne_zero_and_weightedOrder","module":"Mathlib.RingTheory.MvPowerSeries.Order","initialProofState":"σ : Type u_1\nR : Type u_2\ninst✝ : Semiring R\nw : σ → Nat\nf : MvPowerSeries σ R\nh : Eq (↑(MvPowerSeries.weightedOrder w f).toNat) (MvPowerSeries.weightedOrder w f)\n⊢ Exists fun d => And (Ne ((MvPowerSeries.coeff R d) f) 0) (Eq (↑((Finsupp.weight w) d)) (MvPowerSeries.weightedOrder w f))","decl":"/-- If the order of a formal power series `f` is finite,\nthen some coefficient of weight equal to the order of `f` is nonzero.-/\ntheorem exists_coeff_ne_zero_and_weightedOrder\n    (h : (toNat (f.weightedOrder w) : ℕ∞) = f.weightedOrder w) :\n    ∃ d, coeff R d f ≠ 0 ∧ weight w d = f.weightedOrder w := by\n  classical\n  simp_rw [weightedOrder, dif_neg ((ne_zero_iff_weightedOrder_finite w).mpr h), Nat.cast_inj]\n  generalize_proofs h1\n  exact Nat.find_spec h1\n\n"}
{"name":"MvPowerSeries.weightedOrder_le","module":"Mathlib.RingTheory.MvPowerSeries.Order","initialProofState":"σ : Type u_1\nR : Type u_2\ninst✝ : Semiring R\nw : σ → Nat\nf : MvPowerSeries σ R\nd : Finsupp σ Nat\nh : Ne ((MvPowerSeries.coeff R d) f) 0\n⊢ LE.le (MvPowerSeries.weightedOrder w f) ↑((Finsupp.weight w) d)","decl":"/-- If the `d`th coefficient of a formal power series is nonzero,\nthen the weighted order of the power series is less than or equal to `weight d w`.-/\ntheorem weightedOrder_le {d : σ →₀ ℕ} (h : coeff R d f ≠ 0) :\n    f.weightedOrder w ≤ weight w d := by\n  rw [weightedOrder, dif_neg]\n  · simp only [ne_eq, Nat.cast_le, Nat.find_le_iff]\n    exact ⟨weight w d, le_rfl, d, h, rfl⟩\n  · exact (f.ne_zero_iff_exists_coeff_ne_zero_and_weight w).mpr ⟨weight w d, d, h, rfl⟩\n\n"}
{"name":"MvPowerSeries.coeff_eq_zero_of_lt_weightedOrder","module":"Mathlib.RingTheory.MvPowerSeries.Order","initialProofState":"σ : Type u_1\nR : Type u_2\ninst✝ : Semiring R\nw : σ → Nat\nf : MvPowerSeries σ R\nd : Finsupp σ Nat\nh : LT.lt (↑((Finsupp.weight w) d)) (MvPowerSeries.weightedOrder w f)\n⊢ Eq ((MvPowerSeries.coeff R d) f) 0","decl":"/-- The `n`th coefficient of a formal power series is `0` if `n` is strictly\nsmaller than the order of the power series.-/\ntheorem coeff_eq_zero_of_lt_weightedOrder {d : σ →₀ ℕ} (h : (weight w d) < f.weightedOrder w) :\n    coeff R d f = 0 := by\n  contrapose! h; exact weightedOrder_le w h\n\n"}
{"name":"MvPowerSeries.nat_le_weightedOrder","module":"Mathlib.RingTheory.MvPowerSeries.Order","initialProofState":"σ : Type u_1\nR : Type u_2\ninst✝ : Semiring R\nw : σ → Nat\nf : MvPowerSeries σ R\nn : Nat\nh : ∀ (d : Finsupp σ Nat), LT.lt ((Finsupp.weight w) d) n → Eq ((MvPowerSeries.coeff R d) f) 0\n⊢ LE.le (↑n) (MvPowerSeries.weightedOrder w f)","decl":"/-- The order of a formal power series is at least `n` if\nthe `d`th coefficient is `0` for all `d` such that `weight w d < n`.-/\ntheorem nat_le_weightedOrder {n : ℕ} (h : ∀ d, weight w d < n → coeff R d f = 0) :\n    n ≤ f.weightedOrder w := by\n  by_contra! H\n  have : (f.weightedOrder w).toNat = f.weightedOrder w := by\n    rw [coe_toNat_eq_self]; exact ne_top_of_lt H\n  obtain ⟨d, hfd, hd⟩ := exists_coeff_ne_zero_and_weightedOrder w this\n  rw [← hd, Nat.cast_lt] at H\n  exact hfd (h d H)\n\n"}
{"name":"MvPowerSeries.le_weightedOrder","module":"Mathlib.RingTheory.MvPowerSeries.Order","initialProofState":"σ : Type u_1\nR : Type u_2\ninst✝ : Semiring R\nw : σ → Nat\nf : MvPowerSeries σ R\nn : ENat\nh : ∀ (d : Finsupp σ Nat), LT.lt (↑((Finsupp.weight w) d)) n → Eq ((MvPowerSeries.coeff R d) f) 0\n⊢ LE.le n (MvPowerSeries.weightedOrder w f)","decl":"/-- The order of a formal power series is at least `n` if\nthe `d`th coefficient is `0` for all `d` such that `weight w d < n`.-/\ntheorem le_weightedOrder {n : ℕ∞} (h : ∀ d : σ →₀ ℕ, weight w d < n → coeff R d f = 0) :\n    n ≤ f.weightedOrder w := by\n  cases n\n  · rw [top_le_iff, weightedOrder_eq_top_iff]\n    ext d; exact h d (ENat.coe_lt_top _)\n  · apply nat_le_weightedOrder;\n    simpa only [ENat.some_eq_coe, Nat.cast_lt] using h\n\n"}
{"name":"MvPowerSeries.weightedOrder_eq_nat","module":"Mathlib.RingTheory.MvPowerSeries.Order","initialProofState":"σ : Type u_1\nR : Type u_2\ninst✝ : Semiring R\nw : σ → Nat\nf : MvPowerSeries σ R\nn : Nat\n⊢ Iff (Eq (MvPowerSeries.weightedOrder w f) ↑n) (And (Exists fun d => And (Ne ((MvPowerSeries.coeff R d) f) 0) (Eq ((Finsupp.weight w) d) n)) (∀ (d : Finsupp σ Nat), LT.lt ((Finsupp.weight w) d) n → Eq ((MvPowerSeries.coeff R d) f) 0))","decl":"/-- The order of a formal power series is exactly `n` if and only if some coefficient of weight `n`\nis nonzero, and the `d`th coefficient is `0` for all `d` such that `weight w d < n`.-/\ntheorem weightedOrder_eq_nat {n : ℕ} :\n    f.weightedOrder w = n ↔\n      (∃ d, coeff R d f ≠ 0 ∧ weight w d = n) ∧ ∀ d, weight w d < n → coeff R d f = 0 := by\n  constructor\n  · intro h\n    obtain ⟨d, hd⟩ := f.exists_coeff_ne_zero_and_weightedOrder w (by simp only [h, toNat_coe])\n    exact ⟨⟨d, by simpa [h, Nat.cast_inj, ne_eq] using hd⟩,\n      fun e he ↦ f.coeff_eq_zero_of_lt_weightedOrder w (by simp only [h, Nat.cast_lt, he])⟩\n  · rintro ⟨⟨d, hd', hd⟩, h⟩\n    exact le_antisymm (hd.symm ▸ f.weightedOrder_le w hd') (nat_le_weightedOrder w h)\n\n"}
{"name":"MvPowerSeries.weightedOrder_monomial","module":"Mathlib.RingTheory.MvPowerSeries.Order","initialProofState":"σ : Type u_1\nR : Type u_2\ninst✝¹ : Semiring R\nw : σ → Nat\nd : Finsupp σ Nat\na : R\ninst✝ : Decidable (Eq a 0)\n⊢ Eq (MvPowerSeries.weightedOrder w ((MvPowerSeries.monomial R d) a)) (ite (Eq a 0) Top.top ↑((Finsupp.weight w) d))","decl":"/-- The weighted_order of the monomial `a*X^d` is infinite if `a = 0` and `weight w d` otherwise.-/\ntheorem weightedOrder_monomial {d : σ →₀ ℕ} {a : R} [Decidable (a = 0)] :\n    weightedOrder w (monomial R d a) = if a = 0 then (⊤ : ℕ∞) else weight w d := by\n  classical\n  split_ifs with h\n  · rw [h, weightedOrder_eq_top_iff, LinearMap.map_zero]\n  · rw [weightedOrder_eq_nat]\n    constructor\n    · use d\n      simp only [coeff_monomial_same, ne_eq, h, not_false_eq_true, and_self]\n    · intro b hb\n      rw [coeff_monomial, if_neg]\n      intro h\n      simp only [h, lt_self_iff_false] at hb\n\n"}
{"name":"MvPowerSeries.weightedOrder_monomial_of_ne_zero","module":"Mathlib.RingTheory.MvPowerSeries.Order","initialProofState":"σ : Type u_1\nR : Type u_2\ninst✝ : Semiring R\nw : σ → Nat\nd : Finsupp σ Nat\na : R\nh : Ne a 0\n⊢ Eq (MvPowerSeries.weightedOrder w ((MvPowerSeries.monomial R d) a)) ↑((Finsupp.weight w) d)","decl":"/-- The order of the monomial `a*X^n` is `n` if `a ≠ 0`.-/\ntheorem weightedOrder_monomial_of_ne_zero {d : σ →₀ ℕ} {a : R} (h : a ≠ 0) :\n    weightedOrder w (monomial R d a) = weight w d := by\n  classical\n  rw [weightedOrder_monomial, if_neg h]\n\n\n"}
{"name":"MvPowerSeries.min_weightedOrder_le_add","module":"Mathlib.RingTheory.MvPowerSeries.Order","initialProofState":"σ : Type u_1\nR : Type u_2\ninst✝ : Semiring R\nw : σ → Nat\nf g : MvPowerSeries σ R\n⊢ LE.le (Min.min (MvPowerSeries.weightedOrder w f) (MvPowerSeries.weightedOrder w g)) (MvPowerSeries.weightedOrder w (HAdd.hAdd f g))","decl":"/-- The order of the sum of two formal power series is at least the minimum of their orders.-/\ntheorem min_weightedOrder_le_add :\n    min (f.weightedOrder w) (g.weightedOrder w) ≤ (f + g).weightedOrder w := by\n  apply le_weightedOrder w\n  simp (config := { contextual := true }) only\n    [coeff_eq_zero_of_lt_weightedOrder w, lt_min_iff, map_add, add_zero,\n      eq_self_iff_true, imp_true_iff]\n\n"}
{"name":"MvPowerSeries.weightedOrder_add_of_weightedOrder_ne","module":"Mathlib.RingTheory.MvPowerSeries.Order","initialProofState":"σ : Type u_1\nR : Type u_2\ninst✝ : Semiring R\nw : σ → Nat\nf g : MvPowerSeries σ R\nh : Ne (MvPowerSeries.weightedOrder w f) (MvPowerSeries.weightedOrder w g)\n⊢ Eq (MvPowerSeries.weightedOrder w (HAdd.hAdd f g)) (Min.min (MvPowerSeries.weightedOrder w f) (MvPowerSeries.weightedOrder w g))","decl":"/-- The weighted_order of the sum of two formal power series\n is the minimum of their orders if their orders differ.-/\ntheorem weightedOrder_add_of_weightedOrder_ne (h : f.weightedOrder w ≠ g.weightedOrder w) :\n    weightedOrder w (f + g) = weightedOrder w f ⊓ weightedOrder w g := by\n  refine le_antisymm ?_ (min_weightedOrder_le_add w)\n  by_cases H₁ : f.weightedOrder w < g.weightedOrder w\n  · simp only [le_inf_iff, weightedOrder_add_of_weightedOrder_lt.aux w H₁]\n    exact ⟨le_rfl, le_of_lt H₁⟩\n  · by_cases H₂ : g.weightedOrder w < f.weightedOrder w\n    · simp only [add_comm f g, le_inf_iff, weightedOrder_add_of_weightedOrder_lt.aux w H₂]\n      exact ⟨le_of_lt H₂, le_rfl⟩\n    · exact absurd (le_antisymm (not_lt.1 H₂) (not_lt.1 H₁)) h\n\n"}
{"name":"MvPowerSeries.le_weightedOrder_mul","module":"Mathlib.RingTheory.MvPowerSeries.Order","initialProofState":"σ : Type u_1\nR : Type u_2\ninst✝ : Semiring R\nw : σ → Nat\nf g : MvPowerSeries σ R\n⊢ LE.le (HAdd.hAdd (MvPowerSeries.weightedOrder w f) (MvPowerSeries.weightedOrder w g)) (MvPowerSeries.weightedOrder w (HMul.hMul f g))","decl":"/-- The weighted_order of the product of two formal power series\n is at least the sum of their orders.-/\ntheorem le_weightedOrder_mul :\n    f.weightedOrder w + g.weightedOrder w ≤ weightedOrder w (f * g) := by\n  classical\n  apply le_weightedOrder\n  intro d hd\n  rw [coeff_mul, Finset.sum_eq_zero]\n  rintro ⟨i, j⟩ hij\n  by_cases hi : weight w i < f.weightedOrder w\n  · rw [coeff_eq_zero_of_lt_weightedOrder w hi, MulZeroClass.zero_mul]\n  · by_cases hj : weight w j < g.weightedOrder w\n    · rw [coeff_eq_zero_of_lt_weightedOrder w hj, MulZeroClass.mul_zero]\n    · rw [not_lt] at hi hj\n      simp only [Finset.mem_antidiagonal] at hij\n      exfalso\n      apply ne_of_lt (lt_of_lt_of_le hd <| add_le_add hi hj)\n      rw [← hij, map_add, Nat.cast_add]\n\n"}
{"name":"MvPowerSeries.weightedOrder_mul_ge","module":"Mathlib.RingTheory.MvPowerSeries.Order","initialProofState":"σ : Type u_1\nR : Type u_2\ninst✝ : Semiring R\nw : σ → Nat\nf g : MvPowerSeries σ R\n⊢ LE.le (HAdd.hAdd (MvPowerSeries.weightedOrder w f) (MvPowerSeries.weightedOrder w g)) (MvPowerSeries.weightedOrder w (HMul.hMul f g))","decl":"alias weightedOrder_mul_ge := le_weightedOrder_mul\n\n"}
{"name":"MvPowerSeries.coeff_mul_left_one_sub_of_lt_weightedOrder","module":"Mathlib.RingTheory.MvPowerSeries.Order","initialProofState":"σ : Type u_1\nw : σ → Nat\nR : Type u_3\ninst✝ : Ring R\nf g : MvPowerSeries σ R\nd : Finsupp σ Nat\nh : LT.lt (↑((Finsupp.weight w) d)) (MvPowerSeries.weightedOrder w g)\n⊢ Eq ((MvPowerSeries.coeff R d) (HMul.hMul f (HSub.hSub 1 g))) ((MvPowerSeries.coeff R d) f)","decl":"theorem coeff_mul_left_one_sub_of_lt_weightedOrder\n    {d : σ →₀ ℕ} (h : (weight w d) < g.weightedOrder w) :\n    coeff R d (f * (1 - g)) = coeff R d f := by\n  simp only [mul_sub, mul_one, _root_.map_sub, sub_eq_self]\n  apply coeff_eq_zero_of_lt_weightedOrder w\n  exact lt_of_lt_of_le (lt_of_lt_of_le h le_add_self) (le_weightedOrder_mul w)\n\n"}
{"name":"MvPowerSeries.coeff_mul_right_one_sub_of_lt_weightedOrder","module":"Mathlib.RingTheory.MvPowerSeries.Order","initialProofState":"σ : Type u_1\nw : σ → Nat\nR : Type u_3\ninst✝ : Ring R\nf g : MvPowerSeries σ R\nd : Finsupp σ Nat\nh : LT.lt (↑((Finsupp.weight w) d)) (MvPowerSeries.weightedOrder w g)\n⊢ Eq ((MvPowerSeries.coeff R d) (HMul.hMul (HSub.hSub 1 g) f)) ((MvPowerSeries.coeff R d) f)","decl":"theorem coeff_mul_right_one_sub_of_lt_weightedOrder\n    {d : σ →₀ ℕ} (h : (weight w d) < g.weightedOrder w) :\n    coeff R d ((1 - g) * f) = coeff R d f := by\n  simp only [sub_mul, one_mul, _root_.map_sub, sub_eq_self]\n  apply coeff_eq_zero_of_lt_weightedOrder w\n  apply lt_of_lt_of_le (lt_of_lt_of_le h le_self_add) (le_weightedOrder_mul w)\n\n"}
{"name":"MvPowerSeries.coeff_mul_prod_one_sub_of_lt_weightedOrder","module":"Mathlib.RingTheory.MvPowerSeries.Order","initialProofState":"σ : Type u_1\nw : σ → Nat\nR : Type u_4\nι : Type u_5\ninst✝ : CommRing R\nd : Finsupp σ Nat\ns : Finset ι\nf : MvPowerSeries σ R\ng : ι → MvPowerSeries σ R\na✝ : ∀ (i : ι), Membership.mem s i → LT.lt (↑((Finsupp.weight w) d)) (MvPowerSeries.weightedOrder w (g i))\n⊢ Eq ((MvPowerSeries.coeff R d) (HMul.hMul f (s.prod fun i => HSub.hSub 1 (g i)))) ((MvPowerSeries.coeff R d) f)","decl":"theorem coeff_mul_prod_one_sub_of_lt_weightedOrder {R ι : Type*} [CommRing R] (d : σ →₀ ℕ)\n    (s : Finset ι) (f : MvPowerSeries σ R) (g : ι → MvPowerSeries σ R) :\n    (∀ i ∈ s, (weight w d) < weightedOrder w (g i)) →\n      coeff R d (f * ∏ i ∈ s, (1 - g i)) = coeff R d f := by\n  classical\n  induction s using Finset.induction_on with\n  | empty => simp only [imp_true_iff, Finset.prod_empty, mul_one, eq_self_iff_true]\n  | @insert a s ha ih =>\n    intro h\n    simp only [Finset.mem_insert, forall_eq_or_imp] at h\n    rw [Finset.prod_insert ha, ← mul_assoc, mul_right_comm,\n      coeff_mul_left_one_sub_of_lt_weightedOrder w h.1, ih h.2]\n\n"}
{"name":"MvPowerSeries.eq_zero_iff_forall_coeff_eq_zero_and","module":"Mathlib.RingTheory.MvPowerSeries.Order","initialProofState":"σ : Type u_1\nR : Type u_2\ninst✝ : Semiring R\nf : MvPowerSeries σ R\n⊢ Iff (Eq f 0) (∀ (d : Finsupp σ Nat), Eq ((MvPowerSeries.coeff R d) f) 0)","decl":"theorem eq_zero_iff_forall_coeff_eq_zero_and :\n    f = 0 ↔ (∀ d : σ →₀ ℕ, coeff R d f = 0) :=\n  MvPowerSeries.ext_iff\n\n"}
{"name":"MvPowerSeries.ne_zero_iff_exists_coeff_ne_zero_and_degree","module":"Mathlib.RingTheory.MvPowerSeries.Order","initialProofState":"σ : Type u_1\nR : Type u_2\ninst✝ : Semiring R\nf : MvPowerSeries σ R\n⊢ Iff (Ne f 0) (Exists fun n => Exists fun d => And (Ne ((MvPowerSeries.coeff R d) f) 0) (Eq d.degree n))","decl":"theorem ne_zero_iff_exists_coeff_ne_zero_and_degree :\n    f ≠ 0 ↔ (∃ n : ℕ, ∃ d : σ →₀ ℕ, coeff R d f ≠ 0 ∧ degree d = n) := by\n  simp_rw [degree_eq_weight_one]\n  exact ne_zero_iff_exists_coeff_ne_zero_and_weight (fun _ => 1)\n\n"}
{"name":"MvPowerSeries.order_zero","module":"Mathlib.RingTheory.MvPowerSeries.Order","initialProofState":"σ : Type u_1\nR : Type u_2\ninst✝ : Semiring R\n⊢ Eq (MvPowerSeries.order 0) Top.top","decl":"@[simp]\ntheorem order_zero : (0 : MvPowerSeries σ R).order = ⊤ :=\n  weightedOrder_zero _\n\n"}
{"name":"MvPowerSeries.ne_zero_iff_order_finite","module":"Mathlib.RingTheory.MvPowerSeries.Order","initialProofState":"σ : Type u_1\nR : Type u_2\ninst✝ : Semiring R\nf : MvPowerSeries σ R\n⊢ Iff (Ne f 0) (Eq (↑f.order.toNat) f.order)","decl":"theorem ne_zero_iff_order_finite : f ≠ 0 ↔ f.order.toNat = f.order :=\n  ne_zero_iff_weightedOrder_finite 1\n\n"}
{"name":"MvPowerSeries.order_eq_top_iff","module":"Mathlib.RingTheory.MvPowerSeries.Order","initialProofState":"σ : Type u_1\nR : Type u_2\ninst✝ : Semiring R\nf : MvPowerSeries σ R\n⊢ Iff (Eq f.order Top.top) (Eq f 0)","decl":"/-- The `0` power series is the unique power series with infinite order.-/\n@[simp] theorem order_eq_top_iff : f.order = ⊤ ↔ f = 0 :=\n  weightedOrder_eq_top_iff _\n\n"}
{"name":"MvPowerSeries.exists_coeff_ne_zero_and_order","module":"Mathlib.RingTheory.MvPowerSeries.Order","initialProofState":"σ : Type u_1\nR : Type u_2\ninst✝ : Semiring R\nf : MvPowerSeries σ R\nh : Eq (↑f.order.toNat) f.order\n⊢ Exists fun d => And (Ne ((MvPowerSeries.coeff R d) f) 0) (Eq (↑d.degree) f.order)","decl":"/-- If the order of a formal power series `f` is finite,\nthen some coefficient of degree the order of `f` is nonzero.-/\ntheorem exists_coeff_ne_zero_and_order (h : f.order.toNat = f.order) :\n    ∃ d : σ →₀ ℕ, coeff R d f ≠ 0 ∧ degree d = f.order := by\n  simp_rw [degree_eq_weight_one]\n  exact exists_coeff_ne_zero_and_weightedOrder _ h\n\n"}
{"name":"MvPowerSeries.order_le","module":"Mathlib.RingTheory.MvPowerSeries.Order","initialProofState":"σ : Type u_1\nR : Type u_2\ninst✝ : Semiring R\nf : MvPowerSeries σ R\nd : Finsupp σ Nat\nh : Ne ((MvPowerSeries.coeff R d) f) 0\n⊢ LE.le f.order ↑d.degree","decl":"/-- If the `d`th coefficient of a formal power series is nonzero,\nthen the order of the power series is less than or equal to `degree d`. -/\ntheorem order_le {d : σ →₀ ℕ} (h : coeff R d f ≠ 0) : f.order ≤ degree d := by\n  rw [degree_eq_weight_one]\n  exact weightedOrder_le _ h\n\n"}
{"name":"MvPowerSeries.coeff_of_lt_order","module":"Mathlib.RingTheory.MvPowerSeries.Order","initialProofState":"σ : Type u_1\nR : Type u_2\ninst✝ : Semiring R\nf : MvPowerSeries σ R\nd : Finsupp σ Nat\nh : LT.lt (↑d.degree) f.order\n⊢ Eq ((MvPowerSeries.coeff R d) f) 0","decl":"/-- The `n`th coefficient of a formal power series is `0` if `n` is strictly\nsmaller than the order of the power series.-/\ntheorem coeff_of_lt_order {d : σ →₀ ℕ} (h : degree d < f.order) :\n    coeff R d f = 0 := by\n  rw [degree_eq_weight_one] at h\n  exact coeff_eq_zero_of_lt_weightedOrder _ h\n\n"}
{"name":"MvPowerSeries.nat_le_order","module":"Mathlib.RingTheory.MvPowerSeries.Order","initialProofState":"σ : Type u_1\nR : Type u_2\ninst✝ : Semiring R\nf : MvPowerSeries σ R\nn : Nat\nh : ∀ (d : Finsupp σ Nat), LT.lt d.degree n → Eq ((MvPowerSeries.coeff R d) f) 0\n⊢ LE.le (↑n) f.order","decl":"/-- The order of a formal power series is at least `n` if\nthe `d`th coefficient is `0` for all `d` such that `degree d < n`.-/\ntheorem nat_le_order {n : ℕ} (h : ∀ d, degree d < n → coeff R d f = 0) :\n    n ≤ f.order := by\n  simp_rw [degree_eq_weight_one] at h\n  exact nat_le_weightedOrder _ h\n\n"}
{"name":"MvPowerSeries.le_order","module":"Mathlib.RingTheory.MvPowerSeries.Order","initialProofState":"σ : Type u_1\nR : Type u_2\ninst✝ : Semiring R\nf : MvPowerSeries σ R\nn : ENat\nh : ∀ (d : Finsupp σ Nat), LT.lt (↑d.degree) n → Eq ((MvPowerSeries.coeff R d) f) 0\n⊢ LE.le n f.order","decl":"/-- The order of a formal power series is at least `n` if\nthe `d`th coefficient is `0` for all `d` such that `degree d < n`.-/\ntheorem le_order {n : ℕ∞} (h : ∀ d : σ →₀ ℕ, degree d < n → coeff R d f = 0) :\n    n ≤ f.order := by\n  simp_rw [degree_eq_weight_one] at h\n  exact le_weightedOrder _ h\n\n"}
{"name":"MvPowerSeries.order_eq_nat","module":"Mathlib.RingTheory.MvPowerSeries.Order","initialProofState":"σ : Type u_1\nR : Type u_2\ninst✝ : Semiring R\nf : MvPowerSeries σ R\nn : Nat\n⊢ Iff (Eq f.order ↑n) (And (Exists fun d => And (Ne ((MvPowerSeries.coeff R d) f) 0) (Eq d.degree n)) (∀ (d : Finsupp σ Nat), LT.lt d.degree n → Eq ((MvPowerSeries.coeff R d) f) 0))","decl":"/-- The order of a formal power series is exactly `n` some coefficient\nof degree `n` is nonzero,\nand the `d`th coefficient is `0` for all `d` such that `degree d < n`.-/\ntheorem order_eq_nat {n : ℕ} :\n    f.order = n ↔\n      (∃ d, coeff R d f ≠ 0 ∧ degree d = n) ∧ ∀ d, degree d < n → coeff R d f = 0 := by\n  simp_rw [degree_eq_weight_one]\n  exact weightedOrder_eq_nat _\n\n"}
{"name":"MvPowerSeries.order_monomial","module":"Mathlib.RingTheory.MvPowerSeries.Order","initialProofState":"σ : Type u_1\nR : Type u_2\ninst✝¹ : Semiring R\nd : Finsupp σ Nat\na : R\ninst✝ : Decidable (Eq a 0)\n⊢ Eq ((MvPowerSeries.monomial R d) a).order (ite (Eq a 0) Top.top ↑d.degree)","decl":"/-- The order of the monomial `a*X^d` is infinite if `a = 0` and `degree d` otherwise.-/\ntheorem order_monomial {d : σ →₀ ℕ} {a : R} [Decidable (a = 0)] :\n    order (monomial R d a) = if a = 0 then (⊤ : ℕ∞) else ↑(degree d) := by\n  rw [degree_eq_weight_one]\n  exact weightedOrder_monomial _\n\n"}
{"name":"MvPowerSeries.order_monomial_of_ne_zero","module":"Mathlib.RingTheory.MvPowerSeries.Order","initialProofState":"σ : Type u_1\nR : Type u_2\ninst✝ : Semiring R\nd : Finsupp σ Nat\na : R\nh : Ne a 0\n⊢ Eq ((MvPowerSeries.monomial R d) a).order ↑d.degree","decl":"/-- The order of the monomial `a*X^n` is `n` if `a ≠ 0`.-/\ntheorem order_monomial_of_ne_zero {d : σ →₀ ℕ} {a : R} (h : a ≠ 0) :\n    order (monomial R d a) = degree d := by\n  rw [degree_eq_weight_one]\n  exact weightedOrder_monomial_of_ne_zero _ h\n\n"}
{"name":"MvPowerSeries.min_order_le_add","module":"Mathlib.RingTheory.MvPowerSeries.Order","initialProofState":"σ : Type u_1\nR : Type u_2\ninst✝ : Semiring R\nf g : MvPowerSeries σ R\n⊢ LE.le (Min.min f.order g.order) (HAdd.hAdd f g).order","decl":"/-- The order of the sum of two formal power series\n is at least the minimum of their orders.-/\ntheorem min_order_le_add : min f.order g.order ≤ (f + g).order :=\n  min_weightedOrder_le_add _\n\n"}
{"name":"MvPowerSeries.order_add_of_order_ne","module":"Mathlib.RingTheory.MvPowerSeries.Order","initialProofState":"σ : Type u_1\nR : Type u_2\ninst✝ : Semiring R\nf g : MvPowerSeries σ R\nh : Ne f.order g.order\n⊢ Eq (HAdd.hAdd f g).order (Min.min f.order g.order)","decl":"/-- The order of the sum of two formal power series\n is the minimum of their orders if their orders differ.-/\ntheorem order_add_of_order_ne (h : f.order ≠ g.order) :\n    order (f + g) = order f ⊓ order g :=\n  weightedOrder_add_of_weightedOrder_ne _ h\n\n"}
{"name":"MvPowerSeries.le_order_mul","module":"Mathlib.RingTheory.MvPowerSeries.Order","initialProofState":"σ : Type u_1\nR : Type u_2\ninst✝ : Semiring R\nf g : MvPowerSeries σ R\n⊢ LE.le (HAdd.hAdd f.order g.order) (HMul.hMul f g).order","decl":"/-- The order of the product of two formal power series\n is at least the sum of their orders.-/\ntheorem le_order_mul : f.order + g.order ≤ order (f * g) :=\n  le_weightedOrder_mul _\n\n"}
{"name":"MvPowerSeries.order_mul_ge","module":"Mathlib.RingTheory.MvPowerSeries.Order","initialProofState":"σ : Type u_1\nR : Type u_2\ninst✝ : Semiring R\nf g : MvPowerSeries σ R\n⊢ LE.le (HAdd.hAdd f.order g.order) (HMul.hMul f g).order","decl":"alias order_mul_ge := le_order_mul\n\n"}
{"name":"MvPowerSeries.coeff_mul_left_one_sub_of_lt_order","module":"Mathlib.RingTheory.MvPowerSeries.Order","initialProofState":"σ : Type u_1\nR : Type u_3\ninst✝ : Ring R\nf g : MvPowerSeries σ R\nd : Finsupp σ Nat\nh : LT.lt (↑d.degree) g.order\n⊢ Eq ((MvPowerSeries.coeff R d) (HMul.hMul f (HSub.hSub 1 g))) ((MvPowerSeries.coeff R d) f)","decl":"theorem coeff_mul_left_one_sub_of_lt_order (d : σ →₀ ℕ) (h : degree d < g.order) :\n    coeff R d (f * (1 - g)) = coeff R d f := by\n  rw [degree_eq_weight_one] at h\n  exact coeff_mul_left_one_sub_of_lt_weightedOrder _ h\n\n"}
{"name":"MvPowerSeries.coeff_mul_right_one_sub_of_lt_order","module":"Mathlib.RingTheory.MvPowerSeries.Order","initialProofState":"σ : Type u_1\nR : Type u_3\ninst✝ : Ring R\nf g : MvPowerSeries σ R\nd : Finsupp σ Nat\nh : LT.lt (↑d.degree) g.order\n⊢ Eq ((MvPowerSeries.coeff R d) (HMul.hMul (HSub.hSub 1 g) f)) ((MvPowerSeries.coeff R d) f)","decl":"theorem coeff_mul_right_one_sub_of_lt_order (d : σ →₀ ℕ) (h : degree d < g.order) :\n    coeff R d ((1 - g) * f) = coeff R d f := by\n  rw [degree_eq_weight_one] at h\n  exact coeff_mul_right_one_sub_of_lt_weightedOrder _ h\n\n"}
{"name":"MvPowerSeries.coeff_mul_prod_one_sub_of_lt_order","module":"Mathlib.RingTheory.MvPowerSeries.Order","initialProofState":"σ : Type u_1\nR : Type u_4\nι : Type u_5\ninst✝ : CommRing R\nd : Finsupp σ Nat\ns : Finset ι\nf : MvPowerSeries σ R\ng : ι → MvPowerSeries σ R\na✝ : ∀ (i : ι), Membership.mem s i → LT.lt (↑d.degree) (g i).order\n⊢ Eq ((MvPowerSeries.coeff R d) (HMul.hMul f (s.prod fun i => HSub.hSub 1 (g i)))) ((MvPowerSeries.coeff R d) f)","decl":"theorem coeff_mul_prod_one_sub_of_lt_order {R ι : Type*} [CommRing R] (d : σ →₀ ℕ) (s : Finset ι)\n    (f : MvPowerSeries σ R) (g : ι → MvPowerSeries σ R) :\n    (∀ i ∈ s, degree d < order (g i)) → coeff R d (f * ∏ i ∈ s, (1 - g i)) = coeff R d f := by\n  rw [degree_eq_weight_one]\n  exact coeff_mul_prod_one_sub_of_lt_weightedOrder _ d s f g\n\n"}
{"name":"MvPowerSeries.coeff_weightedHomogeneousComponent","module":"Mathlib.RingTheory.MvPowerSeries.Order","initialProofState":"σ : Type u_1\nR : Type u_2\ninst✝ : Semiring R\nw : σ → Nat\np : Nat\nd : Finsupp σ Nat\nf : MvPowerSeries σ R\n⊢ Eq ((MvPowerSeries.coeff R d) ((MvPowerSeries.weightedHomogeneousComponent w p) f)) (ite (Eq ((Finsupp.weight w) d) p) ((MvPowerSeries.coeff R d) f) 0)","decl":"theorem coeff_weightedHomogeneousComponent (p : ℕ) (d : σ →₀ ℕ) (f : MvPowerSeries σ R) :\n    coeff R d (weightedHomogeneousComponent w p f) =\n      if weight w d = p then coeff R d f else 0 :=\n  rfl\n\n"}
{"name":"MvPowerSeries.coeff_homogeneousComponent","module":"Mathlib.RingTheory.MvPowerSeries.Order","initialProofState":"σ : Type u_1\nR : Type u_2\ninst✝ : Semiring R\np : Nat\nd : Finsupp σ Nat\nf : MvPowerSeries σ R\n⊢ Eq ((MvPowerSeries.coeff R d) ((MvPowerSeries.homogeneousComponent p) f)) (ite (Eq d.degree p) ((MvPowerSeries.coeff R d) f) 0)","decl":"theorem coeff_homogeneousComponent (p : ℕ) (d : σ →₀ ℕ) (f : MvPowerSeries σ R) :\n    coeff R d (homogeneousComponent p f) =\n      if degree d = p then coeff R d f else 0 := by\n  rw [degree_eq_weight_one]\n  exact coeff_weightedHomogeneousComponent 1 p d f\n\n"}
