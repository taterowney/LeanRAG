{"name":"SeparationQuotient.mk_vadd","module":"Mathlib.Topology.Algebra.SeparationQuotient.Basic","initialProofState":"M : Type u_1\nX : Type u_2\ninst✝² : TopologicalSpace X\ninst✝¹ : VAdd M X\ninst✝ : ContinuousConstVAdd M X\nc : M\nx : X\n⊢ Eq (SeparationQuotient.mk (HVAdd.hVAdd c x)) (HVAdd.hVAdd c (SeparationQuotient.mk x))","decl":"@[to_additive (attr := simp)]\ntheorem mk_smul (c : M) (x : X) : mk (c • x) = c • mk x := rfl\n\n"}
{"name":"SeparationQuotient.mk_smul","module":"Mathlib.Topology.Algebra.SeparationQuotient.Basic","initialProofState":"M : Type u_1\nX : Type u_2\ninst✝² : TopologicalSpace X\ninst✝¹ : SMul M X\ninst✝ : ContinuousConstSMul M X\nc : M\nx : X\n⊢ Eq (SeparationQuotient.mk (HSMul.hSMul c x)) (HSMul.hSMul c (SeparationQuotient.mk x))","decl":"@[to_additive (attr := simp)]\ntheorem mk_smul (c : M) (x : X) : mk (c • x) = c • mk x := rfl\n\n"}
{"name":"SeparationQuotient.instContinuousConstVAdd","module":"Mathlib.Topology.Algebra.SeparationQuotient.Basic","initialProofState":"M : Type u_1\nX : Type u_2\ninst✝² : TopologicalSpace X\ninst✝¹ : VAdd M X\ninst✝ : ContinuousConstVAdd M X\n⊢ ContinuousConstVAdd M (SeparationQuotient X)","decl":"@[to_additive]\ninstance instContinuousConstSMul : ContinuousConstSMul M (SeparationQuotient X) where\n  continuous_const_smul c := isQuotientMap_mk.continuous_iff.2 <|\n    continuous_mk.comp <| continuous_const_smul c\n\n"}
{"name":"SeparationQuotient.instContinuousConstSMul","module":"Mathlib.Topology.Algebra.SeparationQuotient.Basic","initialProofState":"M : Type u_1\nX : Type u_2\ninst✝² : TopologicalSpace X\ninst✝¹ : SMul M X\ninst✝ : ContinuousConstSMul M X\n⊢ ContinuousConstSMul M (SeparationQuotient X)","decl":"@[to_additive]\ninstance instContinuousConstSMul : ContinuousConstSMul M (SeparationQuotient X) where\n  continuous_const_smul c := isQuotientMap_mk.continuous_iff.2 <|\n    continuous_mk.comp <| continuous_const_smul c\n\n"}
{"name":"SeparationQuotient.instIsPretransitiveVAdd","module":"Mathlib.Topology.Algebra.SeparationQuotient.Basic","initialProofState":"M : Type u_1\nX : Type u_2\ninst✝³ : TopologicalSpace X\ninst✝² : VAdd M X\ninst✝¹ : ContinuousConstVAdd M X\ninst✝ : AddAction.IsPretransitive M X\n⊢ AddAction.IsPretransitive M (SeparationQuotient X)","decl":"@[to_additive]\ninstance instIsPretransitiveSMul [MulAction.IsPretransitive M X] :\n    MulAction.IsPretransitive M (SeparationQuotient X) where\n  exists_smul_eq := surjective_mk.forall₂.2 fun x y ↦\n    (MulAction.exists_smul_eq M x y).imp fun _ ↦ congr_arg mk\n\n"}
{"name":"SeparationQuotient.instIsPretransitiveSMul","module":"Mathlib.Topology.Algebra.SeparationQuotient.Basic","initialProofState":"M : Type u_1\nX : Type u_2\ninst✝³ : TopologicalSpace X\ninst✝² : SMul M X\ninst✝¹ : ContinuousConstSMul M X\ninst✝ : MulAction.IsPretransitive M X\n⊢ MulAction.IsPretransitive M (SeparationQuotient X)","decl":"@[to_additive]\ninstance instIsPretransitiveSMul [MulAction.IsPretransitive M X] :\n    MulAction.IsPretransitive M (SeparationQuotient X) where\n  exists_smul_eq := surjective_mk.forall₂.2 fun x y ↦\n    (MulAction.exists_smul_eq M x y).imp fun _ ↦ congr_arg mk\n\n"}
{"name":"SeparationQuotient.instIsCentralScalar","module":"Mathlib.Topology.Algebra.SeparationQuotient.Basic","initialProofState":"M : Type u_1\nX : Type u_2\ninst✝⁴ : TopologicalSpace X\ninst✝³ : SMul M X\ninst✝² : ContinuousConstSMul M X\ninst✝¹ : SMul (MulOpposite M) X\ninst✝ : IsCentralScalar M X\n⊢ IsCentralScalar M (SeparationQuotient X)","decl":"@[to_additive]\ninstance instIsCentralScalar [SMul Mᵐᵒᵖ X] [IsCentralScalar M X] :\n    IsCentralScalar M (SeparationQuotient X) where\n  op_smul_eq_smul a := surjective_mk.forall.2 (congr_arg mk <| op_smul_eq_smul a ·)\n\n"}
{"name":"SeparationQuotient.instIsCentralVAdd","module":"Mathlib.Topology.Algebra.SeparationQuotient.Basic","initialProofState":"M : Type u_1\nX : Type u_2\ninst✝⁴ : TopologicalSpace X\ninst✝³ : VAdd M X\ninst✝² : ContinuousConstVAdd M X\ninst✝¹ : VAdd (AddOpposite M) X\ninst✝ : IsCentralVAdd M X\n⊢ IsCentralVAdd M (SeparationQuotient X)","decl":"@[to_additive]\ninstance instIsCentralScalar [SMul Mᵐᵒᵖ X] [IsCentralScalar M X] :\n    IsCentralScalar M (SeparationQuotient X) where\n  op_smul_eq_smul a := surjective_mk.forall.2 (congr_arg mk <| op_smul_eq_smul a ·)\n\n"}
{"name":"SeparationQuotient.instVAddCommClass","module":"Mathlib.Topology.Algebra.SeparationQuotient.Basic","initialProofState":"M : Type u_1\nX : Type u_2\ninst✝⁵ : TopologicalSpace X\ninst✝⁴ : VAdd M X\ninst✝³ : ContinuousConstVAdd M X\nN : Type u_3\ninst✝² : VAdd N X\ninst✝¹ : ContinuousConstVAdd N X\ninst✝ : VAddCommClass M N X\n⊢ VAddCommClass M N (SeparationQuotient X)","decl":"@[to_additive]\ninstance instSMulCommClass [ContinuousConstSMul N X] [SMulCommClass M N X] :\n    SMulCommClass M N (SeparationQuotient X) :=\n  surjective_mk.smulCommClass mk_smul mk_smul\n\n"}
{"name":"SeparationQuotient.instSMulCommClass","module":"Mathlib.Topology.Algebra.SeparationQuotient.Basic","initialProofState":"M : Type u_1\nX : Type u_2\ninst✝⁵ : TopologicalSpace X\ninst✝⁴ : SMul M X\ninst✝³ : ContinuousConstSMul M X\nN : Type u_3\ninst✝² : SMul N X\ninst✝¹ : ContinuousConstSMul N X\ninst✝ : SMulCommClass M N X\n⊢ SMulCommClass M N (SeparationQuotient X)","decl":"@[to_additive]\ninstance instSMulCommClass [ContinuousConstSMul N X] [SMulCommClass M N X] :\n    SMulCommClass M N (SeparationQuotient X) :=\n  surjective_mk.smulCommClass mk_smul mk_smul\n\n"}
{"name":"SeparationQuotient.instIsScalarTower","module":"Mathlib.Topology.Algebra.SeparationQuotient.Basic","initialProofState":"M : Type u_1\nX : Type u_2\ninst✝⁶ : TopologicalSpace X\ninst✝⁵ : SMul M X\ninst✝⁴ : ContinuousConstSMul M X\nN : Type u_3\ninst✝³ : SMul N X\ninst✝² : SMul M N\ninst✝¹ : ContinuousConstSMul N X\ninst✝ : IsScalarTower M N X\n⊢ IsScalarTower M N (SeparationQuotient X)","decl":"@[to_additive instVAddAssocClass]\ninstance instIsScalarTower [SMul M N] [ContinuousConstSMul N X] [IsScalarTower M N X] :\n    IsScalarTower M N (SeparationQuotient X) where\n  smul_assoc a b := surjective_mk.forall.2 fun x ↦ congr_arg mk <| smul_assoc a b x\n\n"}
{"name":"SeparationQuotient.instVAddAssocClass","module":"Mathlib.Topology.Algebra.SeparationQuotient.Basic","initialProofState":"M : Type u_1\nX : Type u_2\ninst✝⁶ : TopologicalSpace X\ninst✝⁵ : VAdd M X\ninst✝⁴ : ContinuousConstVAdd M X\nN : Type u_3\ninst✝³ : VAdd N X\ninst✝² : VAdd M N\ninst✝¹ : ContinuousConstVAdd N X\ninst✝ : VAddAssocClass M N X\n⊢ VAddAssocClass M N (SeparationQuotient X)","decl":"@[to_additive instVAddAssocClass]\ninstance instIsScalarTower [SMul M N] [ContinuousConstSMul N X] [IsScalarTower M N X] :\n    IsScalarTower M N (SeparationQuotient X) where\n  smul_assoc a b := surjective_mk.forall.2 fun x ↦ congr_arg mk <| smul_assoc a b x\n\n"}
{"name":"SeparationQuotient.instContinuousSMul","module":"Mathlib.Topology.Algebra.SeparationQuotient.Basic","initialProofState":"M : Type u_1\nX : Type u_2\ninst✝³ : SMul M X\ninst✝² : TopologicalSpace M\ninst✝¹ : TopologicalSpace X\ninst✝ : ContinuousSMul M X\n⊢ ContinuousSMul M (SeparationQuotient X)","decl":"instance instContinuousSMul {M X : Type*} [SMul M X] [TopologicalSpace M] [TopologicalSpace X]\n    [ContinuousSMul M X] : ContinuousSMul M (SeparationQuotient X) where\n  continuous_smul := by\n    rw [(IsOpenQuotientMap.id.prodMap isOpenQuotientMap_mk).isQuotientMap.continuous_iff]\n    exact continuous_mk.comp continuous_smul\n\n"}
{"name":"SeparationQuotient.mk_mul","module":"Mathlib.Topology.Algebra.SeparationQuotient.Basic","initialProofState":"M : Type u_1\ninst✝² : TopologicalSpace M\ninst✝¹ : Mul M\ninst✝ : ContinuousMul M\na b : M\n⊢ Eq (SeparationQuotient.mk (HMul.hMul a b)) (HMul.hMul (SeparationQuotient.mk a) (SeparationQuotient.mk b))","decl":"@[to_additive (attr := simp)]\ntheorem mk_mul [Mul M] [ContinuousMul M] (a b : M) : mk (a * b) = mk a * mk b := rfl\n\n\n"}
{"name":"SeparationQuotient.mk_add","module":"Mathlib.Topology.Algebra.SeparationQuotient.Basic","initialProofState":"M : Type u_1\ninst✝² : TopologicalSpace M\ninst✝¹ : Add M\ninst✝ : ContinuousAdd M\na b : M\n⊢ Eq (SeparationQuotient.mk (HAdd.hAdd a b)) (HAdd.hAdd (SeparationQuotient.mk a) (SeparationQuotient.mk b))","decl":"@[to_additive (attr := simp)]\ntheorem mk_mul [Mul M] [ContinuousMul M] (a b : M) : mk (a * b) = mk a * mk b := rfl\n\n\n"}
{"name":"SeparationQuotient.instContinuousAdd","module":"Mathlib.Topology.Algebra.SeparationQuotient.Basic","initialProofState":"M : Type u_1\ninst✝² : TopologicalSpace M\ninst✝¹ : Add M\ninst✝ : ContinuousAdd M\n⊢ ContinuousAdd (SeparationQuotient M)","decl":"@[to_additive]\ninstance instContinuousMul [Mul M] [ContinuousMul M] : ContinuousMul (SeparationQuotient M) where\n  continuous_mul := isQuotientMap_prodMap_mk.continuous_iff.2 <| continuous_mk.comp continuous_mul\n\n"}
{"name":"SeparationQuotient.instContinuousMul","module":"Mathlib.Topology.Algebra.SeparationQuotient.Basic","initialProofState":"M : Type u_1\ninst✝² : TopologicalSpace M\ninst✝¹ : Mul M\ninst✝ : ContinuousMul M\n⊢ ContinuousMul (SeparationQuotient M)","decl":"@[to_additive]\ninstance instContinuousMul [Mul M] [ContinuousMul M] : ContinuousMul (SeparationQuotient M) where\n  continuous_mul := isQuotientMap_prodMap_mk.continuous_iff.2 <| continuous_mk.comp continuous_mul\n\n"}
{"name":"SeparationQuotient.mkAddMonoidHom_apply","module":"Mathlib.Topology.Algebra.SeparationQuotient.Basic","initialProofState":"M : Type u_1\ninst✝² : TopologicalSpace M\ninst✝¹ : AddZeroClass M\ninst✝ : ContinuousAdd M\na✝ : M\n⊢ Eq (SeparationQuotient.mkAddMonoidHom a✝) (SeparationQuotient.mk a✝)","decl":"/-- `SeparationQuotient.mk` as a `MonoidHom`. -/\n@[to_additive (attr := simps) \"`SeparationQuotient.mk` as an `AddMonoidHom`.\"]\ndef mkMonoidHom [MulOneClass M] [ContinuousMul M] : M →* SeparationQuotient M where\n  toFun := mk\n  map_mul' := mk_mul\n  map_one' := mk_one\n\n"}
{"name":"SeparationQuotient.mkMonoidHom_apply","module":"Mathlib.Topology.Algebra.SeparationQuotient.Basic","initialProofState":"M : Type u_1\ninst✝² : TopologicalSpace M\ninst✝¹ : MulOneClass M\ninst✝ : ContinuousMul M\na✝ : M\n⊢ Eq (SeparationQuotient.mkMonoidHom a✝) (SeparationQuotient.mk a✝)","decl":"/-- `SeparationQuotient.mk` as a `MonoidHom`. -/\n@[to_additive (attr := simps) \"`SeparationQuotient.mk` as an `AddMonoidHom`.\"]\ndef mkMonoidHom [MulOneClass M] [ContinuousMul M] : M →* SeparationQuotient M where\n  toFun := mk\n  map_mul' := mk_mul\n  map_one' := mk_one\n\n"}
{"name":"SeparationQuotient.mk_pow","module":"Mathlib.Topology.Algebra.SeparationQuotient.Basic","initialProofState":"M : Type u_1\ninst✝² : TopologicalSpace M\ninst✝¹ : Monoid M\ninst✝ : ContinuousMul M\nx : M\nn : Nat\n⊢ Eq (SeparationQuotient.mk (HPow.hPow x n)) (HPow.hPow (SeparationQuotient.mk x) n)","decl":"@[to_additive, simp] -- `mk_nsmul` is not a `simp` lemma because we have `mk_smul`\ntheorem mk_pow [Monoid M] [ContinuousMul M] (x : M) (n : ℕ) : mk (x ^ n) = (mk x) ^ n := rfl\n\n"}
{"name":"SeparationQuotient.mk_nsmul","module":"Mathlib.Topology.Algebra.SeparationQuotient.Basic","initialProofState":"M : Type u_1\ninst✝² : TopologicalSpace M\ninst✝¹ : AddMonoid M\ninst✝ : ContinuousAdd M\nx : M\nn : Nat\n⊢ Eq (SeparationQuotient.mk (HSMul.hSMul n x)) (HSMul.hSMul n (SeparationQuotient.mk x))","decl":"@[to_additive, simp] -- `mk_nsmul` is not a `simp` lemma because we have `mk_smul`\ntheorem mk_pow [Monoid M] [ContinuousMul M] (x : M) (n : ℕ) : mk (x ^ n) = (mk x) ^ n := rfl\n\n"}
{"name":"SeparationQuotient.mk_neg","module":"Mathlib.Topology.Algebra.SeparationQuotient.Basic","initialProofState":"G : Type u_1\ninst✝² : TopologicalSpace G\ninst✝¹ : Neg G\ninst✝ : ContinuousNeg G\nx : G\n⊢ Eq (SeparationQuotient.mk (Neg.neg x)) (Neg.neg (SeparationQuotient.mk x))","decl":"@[to_additive (attr := simp)]\ntheorem mk_inv [Inv G] [ContinuousInv G] (x : G) : mk x⁻¹ = (mk x)⁻¹ := rfl\n\n"}
{"name":"SeparationQuotient.mk_inv","module":"Mathlib.Topology.Algebra.SeparationQuotient.Basic","initialProofState":"G : Type u_1\ninst✝² : TopologicalSpace G\ninst✝¹ : Inv G\ninst✝ : ContinuousInv G\nx : G\n⊢ Eq (SeparationQuotient.mk (Inv.inv x)) (Inv.inv (SeparationQuotient.mk x))","decl":"@[to_additive (attr := simp)]\ntheorem mk_inv [Inv G] [ContinuousInv G] (x : G) : mk x⁻¹ = (mk x)⁻¹ := rfl\n\n"}
{"name":"SeparationQuotient.instContinuousInv","module":"Mathlib.Topology.Algebra.SeparationQuotient.Basic","initialProofState":"G : Type u_1\ninst✝² : TopologicalSpace G\ninst✝¹ : Inv G\ninst✝ : ContinuousInv G\n⊢ ContinuousInv (SeparationQuotient G)","decl":"@[to_additive]\ninstance instContinuousInv [Inv G] [ContinuousInv G] : ContinuousInv (SeparationQuotient G) where\n  continuous_inv := isQuotientMap_mk.continuous_iff.2 <| continuous_mk.comp continuous_inv\n\n"}
{"name":"SeparationQuotient.instContinuousNeg","module":"Mathlib.Topology.Algebra.SeparationQuotient.Basic","initialProofState":"G : Type u_1\ninst✝² : TopologicalSpace G\ninst✝¹ : Neg G\ninst✝ : ContinuousNeg G\n⊢ ContinuousNeg (SeparationQuotient G)","decl":"@[to_additive]\ninstance instContinuousInv [Inv G] [ContinuousInv G] : ContinuousInv (SeparationQuotient G) where\n  continuous_inv := isQuotientMap_mk.continuous_iff.2 <| continuous_mk.comp continuous_inv\n\n"}
{"name":"SeparationQuotient.mk_sub","module":"Mathlib.Topology.Algebra.SeparationQuotient.Basic","initialProofState":"G : Type u_1\ninst✝² : TopologicalSpace G\ninst✝¹ : Sub G\ninst✝ : ContinuousSub G\nx y : G\n⊢ Eq (SeparationQuotient.mk (HSub.hSub x y)) (HSub.hSub (SeparationQuotient.mk x) (SeparationQuotient.mk y))","decl":"@[to_additive (attr := simp)]\ntheorem mk_div [Div G] [ContinuousDiv G] (x y : G) : mk (x / y) = mk x / mk y := rfl\n\n"}
{"name":"SeparationQuotient.mk_div","module":"Mathlib.Topology.Algebra.SeparationQuotient.Basic","initialProofState":"G : Type u_1\ninst✝² : TopologicalSpace G\ninst✝¹ : Div G\ninst✝ : ContinuousDiv G\nx y : G\n⊢ Eq (SeparationQuotient.mk (HDiv.hDiv x y)) (HDiv.hDiv (SeparationQuotient.mk x) (SeparationQuotient.mk y))","decl":"@[to_additive (attr := simp)]\ntheorem mk_div [Div G] [ContinuousDiv G] (x y : G) : mk (x / y) = mk x / mk y := rfl\n\n"}
{"name":"SeparationQuotient.instContinuousDiv","module":"Mathlib.Topology.Algebra.SeparationQuotient.Basic","initialProofState":"G : Type u_1\ninst✝² : TopologicalSpace G\ninst✝¹ : Div G\ninst✝ : ContinuousDiv G\n⊢ ContinuousDiv (SeparationQuotient G)","decl":"@[to_additive]\ninstance instContinuousDiv [Div G] [ContinuousDiv G] : ContinuousDiv (SeparationQuotient G) where\n  continuous_div' := isQuotientMap_prodMap_mk.continuous_iff.2 <| continuous_mk.comp continuous_div'\n\n"}
{"name":"SeparationQuotient.instContinuousSub","module":"Mathlib.Topology.Algebra.SeparationQuotient.Basic","initialProofState":"G : Type u_1\ninst✝² : TopologicalSpace G\ninst✝¹ : Sub G\ninst✝ : ContinuousSub G\n⊢ ContinuousSub (SeparationQuotient G)","decl":"@[to_additive]\ninstance instContinuousDiv [Div G] [ContinuousDiv G] : ContinuousDiv (SeparationQuotient G) where\n  continuous_div' := isQuotientMap_prodMap_mk.continuous_iff.2 <| continuous_mk.comp continuous_div'\n\n"}
{"name":"SeparationQuotient.mk_zpow","module":"Mathlib.Topology.Algebra.SeparationQuotient.Basic","initialProofState":"G : Type u_1\ninst✝² : TopologicalSpace G\ninst✝¹ : Group G\ninst✝ : TopologicalGroup G\nx : G\nn : Int\n⊢ Eq (SeparationQuotient.mk (HPow.hPow x n)) (HPow.hPow (SeparationQuotient.mk x) n)","decl":"@[to_additive, simp] -- `mk_zsmul` is not a `simp` lemma because we have `mk_smul`\ntheorem mk_zpow [Group G] [TopologicalGroup G] (x : G) (n : ℤ) : mk (x ^ n) = (mk x) ^ n := rfl\n\n"}
{"name":"SeparationQuotient.mk_zsmul","module":"Mathlib.Topology.Algebra.SeparationQuotient.Basic","initialProofState":"G : Type u_1\ninst✝² : TopologicalSpace G\ninst✝¹ : AddGroup G\ninst✝ : TopologicalAddGroup G\nx : G\nn : Int\n⊢ Eq (SeparationQuotient.mk (HSMul.hSMul n x)) (HSMul.hSMul n (SeparationQuotient.mk x))","decl":"@[to_additive, simp] -- `mk_zsmul` is not a `simp` lemma because we have `mk_smul`\ntheorem mk_zpow [Group G] [TopologicalGroup G] (x : G) (n : ℤ) : mk (x ^ n) = (mk x) ^ n := rfl\n\n"}
{"name":"SeparationQuotient.instUniformAddGroup","module":"Mathlib.Topology.Algebra.SeparationQuotient.Basic","initialProofState":"G : Type u_1\ninst✝² : AddGroup G\ninst✝¹ : UniformSpace G\ninst✝ : UniformAddGroup G\n⊢ UniformAddGroup (SeparationQuotient G)","decl":"@[to_additive]\ninstance instUniformGroup {G : Type*} [Group G] [UniformSpace G] [UniformGroup G] :\n    UniformGroup (SeparationQuotient G) where\n  uniformContinuous_div := by\n    rw [uniformContinuous_dom₂]\n    exact uniformContinuous_mk.comp uniformContinuous_div\n\n"}
{"name":"SeparationQuotient.instUniformGroup","module":"Mathlib.Topology.Algebra.SeparationQuotient.Basic","initialProofState":"G : Type u_1\ninst✝² : Group G\ninst✝¹ : UniformSpace G\ninst✝ : UniformGroup G\n⊢ UniformGroup (SeparationQuotient G)","decl":"@[to_additive]\ninstance instUniformGroup {G : Type*} [Group G] [UniformSpace G] [UniformGroup G] :\n    UniformGroup (SeparationQuotient G) where\n  uniformContinuous_div := by\n    rw [uniformContinuous_dom₂]\n    exact uniformContinuous_mk.comp uniformContinuous_div\n\n"}
{"name":"SeparationQuotient.instLeftDistribClass","module":"Mathlib.Topology.Algebra.SeparationQuotient.Basic","initialProofState":"R : Type u_1\ninst✝⁵ : TopologicalSpace R\ninst✝⁴ : Mul R\ninst✝³ : Add R\ninst✝² : LeftDistribClass R\ninst✝¹ : ContinuousMul R\ninst✝ : ContinuousAdd R\n⊢ LeftDistribClass (SeparationQuotient R)","decl":"instance instLeftDistribClass [Mul R] [Add R] [LeftDistribClass R]\n    [ContinuousMul R] [ContinuousAdd R] :\n    LeftDistribClass (SeparationQuotient R) :=\n  surjective_mk.leftDistribClass mk mk_add mk_mul\n\n"}
{"name":"SeparationQuotient.instRightDistribClass","module":"Mathlib.Topology.Algebra.SeparationQuotient.Basic","initialProofState":"R : Type u_1\ninst✝⁵ : TopologicalSpace R\ninst✝⁴ : Mul R\ninst✝³ : Add R\ninst✝² : RightDistribClass R\ninst✝¹ : ContinuousMul R\ninst✝ : ContinuousAdd R\n⊢ RightDistribClass (SeparationQuotient R)","decl":"instance instRightDistribClass [Mul R] [Add R] [RightDistribClass R]\n    [ContinuousMul R] [ContinuousAdd R] :\n    RightDistribClass (SeparationQuotient R) :=\n  surjective_mk.rightDistribClass mk mk_add mk_mul\n\n"}
{"name":"SeparationQuotient.mk_natCast","module":"Mathlib.Topology.Algebra.SeparationQuotient.Basic","initialProofState":"R : Type u_1\ninst✝¹ : TopologicalSpace R\ninst✝ : NatCast R\nn : Nat\n⊢ Eq (SeparationQuotient.mk ↑n) ↑n","decl":"@[simp, norm_cast]\ntheorem mk_natCast [NatCast R] (n : ℕ) : mk (n : R) = n := rfl\n\n"}
{"name":"SeparationQuotient.mk_ofNat","module":"Mathlib.Topology.Algebra.SeparationQuotient.Basic","initialProofState":"R : Type u_1\ninst✝² : TopologicalSpace R\ninst✝¹ : NatCast R\nn : Nat\ninst✝ : n.AtLeastTwo\n⊢ Eq (SeparationQuotient.mk (OfNat.ofNat n)) (OfNat.ofNat n)","decl":"@[simp]\ntheorem mk_ofNat [NatCast R] (n : ℕ) [n.AtLeastTwo] :\n    mk (ofNat(n) : R) = OfNat.ofNat n :=\n  rfl\n\n"}
{"name":"SeparationQuotient.mk_intCast","module":"Mathlib.Topology.Algebra.SeparationQuotient.Basic","initialProofState":"R : Type u_1\ninst✝¹ : TopologicalSpace R\ninst✝ : IntCast R\nn : Int\n⊢ Eq (SeparationQuotient.mk ↑n) ↑n","decl":"@[simp, norm_cast]\ntheorem mk_intCast [IntCast R] (n : ℤ) : mk (n : R) = n := rfl\n\n"}
{"name":"SeparationQuotient.mkRingHom_apply","module":"Mathlib.Topology.Algebra.SeparationQuotient.Basic","initialProofState":"R : Type u_1\ninst✝² : TopologicalSpace R\ninst✝¹ : NonAssocSemiring R\ninst✝ : TopologicalSemiring R\na✝ : R\n⊢ Eq (SeparationQuotient.mkRingHom a✝) (SeparationQuotient.mk a✝)","decl":"/-- `SeparationQuotient.mk` as a `RingHom`. -/\n@[simps]\ndef mkRingHom [NonAssocSemiring R] [TopologicalSemiring R] : R →+* SeparationQuotient R where\n  toFun := mk\n  map_one' := mk_one; map_zero' := mk_zero; map_add' := mk_add; map_mul' := mk_mul\n\n"}
{"name":"SeparationQuotient.mkCLM_apply","module":"Mathlib.Topology.Algebra.SeparationQuotient.Basic","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝⁵ : Semiring R\ninst✝⁴ : AddCommMonoid M\ninst✝³ : Module R M\ninst✝² : TopologicalSpace M\ninst✝¹ : ContinuousAdd M\ninst✝ : ContinuousConstSMul R M\na✝ : M\n⊢ Eq ((SeparationQuotient.mkCLM R M) a✝) (SeparationQuotient.mk a✝)","decl":"/-- `SeparationQuotient.mk` as a continuous linear map. -/\n@[simps]\ndef mkCLM : M →L[R] SeparationQuotient M where\n  toFun := mk\n  map_add' := mk_add\n  map_smul' := mk_smul\n\n"}
{"name":"SeparationQuotient.mk_algebraMap","module":"Mathlib.Topology.Algebra.SeparationQuotient.Basic","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝⁵ : CommSemiring R\ninst✝⁴ : Semiring A\ninst✝³ : Algebra R A\ninst✝² : TopologicalSpace A\ninst✝¹ : TopologicalSemiring A\ninst✝ : ContinuousConstSMul R A\nr : R\n⊢ Eq (SeparationQuotient.mk ((algebraMap R A) r)) ((algebraMap R (SeparationQuotient A)) r)","decl":"@[simp]\ntheorem mk_algebraMap (r : R) : mk (algebraMap R A r) = algebraMap R (SeparationQuotient A) r :=\n  rfl\n\n"}
