{"name":"IsPoly.brecOn","module":"Mathlib.NumberTheory.Dioph","initialProofState":"α : Type u_1\nmotive✝ : (a : (α → Nat) → Int) → IsPoly a → Prop\na✝ : (α → Nat) → Int\nx✝ : IsPoly a✝\nih✝ : ∀ (a : (α → Nat) → Int) (x : IsPoly a), x.below → motive✝ a x\n⊢ motive✝ a✝ x✝","decl":"/-- A predicate asserting that a function is a multivariate integer polynomial.\n  (We are being a bit lazy here by allowing many representations for multiplication,\n  rather than only allowing monomials and addition, but the definition is equivalent\n  and this is easier to use.) -/\ninductive IsPoly : ((α → ℕ) → ℤ) → Prop\n  | proj : ∀ i, IsPoly fun x : α → ℕ => x i\n  | const : ∀ n : ℤ, IsPoly fun _ : α → ℕ => n\n  | sub : ∀ {f g : (α → ℕ) → ℤ}, IsPoly f → IsPoly g → IsPoly fun x => f x - g x\n  | mul : ∀ {f g : (α → ℕ) → ℤ}, IsPoly f → IsPoly g → IsPoly fun x => f x * g x\n\n"}
{"name":"IsPoly.neg","module":"Mathlib.NumberTheory.Dioph","initialProofState":"α : Type u_1\nf : (α → Nat) → Int\na✝ : IsPoly f\n⊢ IsPoly (Neg.neg f)","decl":"theorem IsPoly.neg {f : (α → ℕ) → ℤ} : IsPoly f → IsPoly (-f) := by\n  rw [← zero_sub]; exact (IsPoly.const 0).sub\n\n"}
{"name":"IsPoly.add","module":"Mathlib.NumberTheory.Dioph","initialProofState":"α : Type u_1\nf g : (α → Nat) → Int\nhf : IsPoly f\nhg : IsPoly g\n⊢ IsPoly (HAdd.hAdd f g)","decl":"theorem IsPoly.add {f g : (α → ℕ) → ℤ} (hf : IsPoly f) (hg : IsPoly g) : IsPoly (f + g) := by\n  rw [← sub_neg_eq_add]; exact hf.sub hg.neg\n\n"}
{"name":"Poly.isPoly","module":"Mathlib.NumberTheory.Dioph","initialProofState":"α : Type u_1\nf : Poly α\n⊢ IsPoly ⇑f","decl":"/-- The underlying function of a `Poly` is a polynomial -/\nprotected theorem isPoly (f : Poly α) : IsPoly f := f.2\n\n"}
{"name":"Poly.ext_iff","module":"Mathlib.NumberTheory.Dioph","initialProofState":"α : Type u_1\nf g : Poly α\n⊢ Iff (Eq f g) (∀ (x : α → Nat), Eq (f x) (g x))","decl":"/-- Extensionality for `Poly α` -/\n@[ext]\ntheorem ext {f g : Poly α} : (∀ x, f x = g x) → f = g := DFunLike.ext _ _\n\n"}
{"name":"Poly.ext","module":"Mathlib.NumberTheory.Dioph","initialProofState":"α : Type u_1\nf g : Poly α\na✝ : ∀ (x : α → Nat), Eq (f x) (g x)\n⊢ Eq f g","decl":"/-- Extensionality for `Poly α` -/\n@[ext]\ntheorem ext {f g : Poly α} : (∀ x, f x = g x) → f = g := DFunLike.ext _ _\n\n"}
{"name":"Poly.proj_apply","module":"Mathlib.NumberTheory.Dioph","initialProofState":"α : Type u_1\ni : α\nx : α → Nat\n⊢ Eq ((Poly.proj i) x) ↑(x i)","decl":"@[simp]\ntheorem proj_apply (i : α) (x) : proj i x = x i := rfl\n\n"}
{"name":"Poly.const_apply","module":"Mathlib.NumberTheory.Dioph","initialProofState":"α : Type u_1\nn : Int\nx : α → Nat\n⊢ Eq ((Poly.const n) x) n","decl":"@[simp]\ntheorem const_apply (n) (x : α → ℕ) : const n x = n := rfl\n\n"}
{"name":"Poly.coe_zero","module":"Mathlib.NumberTheory.Dioph","initialProofState":"α : Type u_1\n⊢ Eq ⇑0 ⇑(Poly.const 0)","decl":"@[simp]\ntheorem coe_zero : ⇑(0 : Poly α) = const 0 := rfl\n\n"}
{"name":"Poly.coe_one","module":"Mathlib.NumberTheory.Dioph","initialProofState":"α : Type u_1\n⊢ Eq ⇑1 ⇑(Poly.const 1)","decl":"@[simp]\ntheorem coe_one : ⇑(1 : Poly α) = const 1 := rfl\n\n"}
{"name":"Poly.coe_neg","module":"Mathlib.NumberTheory.Dioph","initialProofState":"α : Type u_1\nf : Poly α\n⊢ Eq (⇑(Neg.neg f)) (Neg.neg ⇑f)","decl":"@[simp]\ntheorem coe_neg (f : Poly α) : ⇑(-f) = -f := rfl\n\n"}
{"name":"Poly.coe_add","module":"Mathlib.NumberTheory.Dioph","initialProofState":"α : Type u_1\nf g : Poly α\n⊢ Eq (⇑(HAdd.hAdd f g)) (HAdd.hAdd ⇑f ⇑g)","decl":"@[simp]\ntheorem coe_add (f g : Poly α) : ⇑(f + g) = f + g := rfl\n\n"}
{"name":"Poly.coe_sub","module":"Mathlib.NumberTheory.Dioph","initialProofState":"α : Type u_1\nf g : Poly α\n⊢ Eq (⇑(HSub.hSub f g)) (HSub.hSub ⇑f ⇑g)","decl":"@[simp]\ntheorem coe_sub (f g : Poly α) : ⇑(f - g) = f - g := rfl\n\n"}
{"name":"Poly.coe_mul","module":"Mathlib.NumberTheory.Dioph","initialProofState":"α : Type u_1\nf g : Poly α\n⊢ Eq (⇑(HMul.hMul f g)) (HMul.hMul ⇑f ⇑g)","decl":"@[simp]\ntheorem coe_mul (f g : Poly α) : ⇑(f * g) = f * g := rfl\n\n"}
{"name":"Poly.zero_apply","module":"Mathlib.NumberTheory.Dioph","initialProofState":"α : Type u_1\nx : α → Nat\n⊢ Eq (0 x) 0","decl":"@[simp]\ntheorem zero_apply (x) : (0 : Poly α) x = 0 := rfl\n\n"}
{"name":"Poly.one_apply","module":"Mathlib.NumberTheory.Dioph","initialProofState":"α : Type u_1\nx : α → Nat\n⊢ Eq (1 x) 1","decl":"@[simp]\ntheorem one_apply (x) : (1 : Poly α) x = 1 := rfl\n\n"}
{"name":"Poly.neg_apply","module":"Mathlib.NumberTheory.Dioph","initialProofState":"α : Type u_1\nf : Poly α\nx : α → Nat\n⊢ Eq ((Neg.neg f) x) (Neg.neg (f x))","decl":"@[simp]\ntheorem neg_apply (f : Poly α) (x) : (-f) x = -f x := rfl\n\n"}
{"name":"Poly.add_apply","module":"Mathlib.NumberTheory.Dioph","initialProofState":"α : Type u_1\nf g : Poly α\nx : α → Nat\n⊢ Eq ((HAdd.hAdd f g) x) (HAdd.hAdd (f x) (g x))","decl":"@[simp]\ntheorem add_apply (f g : Poly α) (x : α → ℕ) : (f + g) x = f x + g x := rfl\n\n"}
{"name":"Poly.sub_apply","module":"Mathlib.NumberTheory.Dioph","initialProofState":"α : Type u_1\nf g : Poly α\nx : α → Nat\n⊢ Eq ((HSub.hSub f g) x) (HSub.hSub (f x) (g x))","decl":"@[simp]\ntheorem sub_apply (f g : Poly α) (x : α → ℕ) : (f - g) x = f x - g x := rfl\n\n"}
{"name":"Poly.mul_apply","module":"Mathlib.NumberTheory.Dioph","initialProofState":"α : Type u_1\nf g : Poly α\nx : α → Nat\n⊢ Eq ((HMul.hMul f g) x) (HMul.hMul (f x) (g x))","decl":"@[simp]\ntheorem mul_apply (f g : Poly α) (x : α → ℕ) : (f * g) x = f x * g x := rfl\n\n"}
{"name":"Poly.induction","module":"Mathlib.NumberTheory.Dioph","initialProofState":"α : Type u_1\nC : Poly α → Prop\nH1 : ∀ (i : α), C (Poly.proj i)\nH2 : ∀ (n : Int), C (Poly.const n)\nH3 : ∀ (f g : Poly α), C f → C g → C (HSub.hSub f g)\nH4 : ∀ (f g : Poly α), C f → C g → C (HMul.hMul f g)\nf : Poly α\n⊢ C f","decl":"theorem induction {C : Poly α → Prop} (H1 : ∀ i, C (proj i)) (H2 : ∀ n, C (const n))\n    (H3 : ∀ f g, C f → C g → C (f - g)) (H4 : ∀ f g, C f → C g → C (f * g)) (f : Poly α) : C f := by\n  cases' f with f pf\n  induction' pf with i n f g pf pg ihf ihg f g pf pg ihf ihg\n  · apply H1\n  · apply H2\n  · apply H3 _ _ ihf ihg\n  · apply H4 _ _ ihf ihg\n\n"}
{"name":"Poly.sumsq_nonneg","module":"Mathlib.NumberTheory.Dioph","initialProofState":"α : Type u_1\nx : α → Nat\nl : List (Poly α)\n⊢ LE.le 0 ((Poly.sumsq l) x)","decl":"theorem sumsq_nonneg (x : α → ℕ) : ∀ l, 0 ≤ sumsq l x\n  | [] => le_refl 0\n  | p::ps => by\n    rw [sumsq]\n    exact add_nonneg (mul_self_nonneg _) (sumsq_nonneg _ ps)\n\n"}
{"name":"Poly.sumsq_eq_zero","module":"Mathlib.NumberTheory.Dioph","initialProofState":"α : Type u_1\nx : α → Nat\nl : List (Poly α)\n⊢ Iff (Eq ((Poly.sumsq l) x) 0) (List.Forall (fun a => Eq (a x) 0) l)","decl":"theorem sumsq_eq_zero (x) : ∀ l, sumsq l x = 0 ↔ l.Forall fun a : Poly α => a x = 0\n  | [] => eq_self_iff_true _\n  | p::ps => by\n    rw [List.forall_cons, ← sumsq_eq_zero _ ps]; rw [sumsq]\n    exact\n      ⟨fun h : p x * p x + sumsq ps x = 0 =>\n        have : p x = 0 :=\n          eq_zero_of_mul_self_eq_zero <|\n            le_antisymm\n              (by\n                rw [← h]\n                have t := add_le_add_left (sumsq_nonneg x ps) (p x * p x)\n                rwa [add_zero] at t)\n              (mul_self_nonneg _)\n        ⟨this, by simpa [this] using h⟩,\n      fun ⟨h1, h2⟩ => by rw [add_apply, mul_apply, h1, h2]; rfl⟩\n\n"}
{"name":"Poly.map_apply","module":"Mathlib.NumberTheory.Dioph","initialProofState":"α : Type u_3\nβ : Type u_4\nf : α → β\ng : Poly α\nv : β → Nat\n⊢ Eq ((Poly.map f g) v) (g (Function.comp v f))","decl":"@[simp]\ntheorem map_apply {α β} (f : α → β) (g : Poly α) (v) : map f g v = g (v ∘ f) := rfl\n\n"}
{"name":"Dioph.ext","module":"Mathlib.NumberTheory.Dioph","initialProofState":"α : Type u\nS S' : Set (α → Nat)\nd : Dioph S\nH : ∀ (v : α → Nat), Iff (Membership.mem S v) (Membership.mem S' v)\n⊢ Dioph S'","decl":"theorem ext (d : Dioph S) (H : ∀ v, v ∈ S ↔ v ∈ S') : Dioph S' := by rwa [← Set.ext H]\n\n"}
{"name":"Dioph.of_no_dummies","module":"Mathlib.NumberTheory.Dioph","initialProofState":"α : Type u\nS : Set (α → Nat)\np : Poly α\nh : ∀ (v : α → Nat), Iff (S v) (Eq (p v) 0)\n⊢ Dioph S","decl":"theorem of_no_dummies (S : Set (α → ℕ)) (p : Poly α) (h : ∀ v, S v ↔ p v = 0) : Dioph S :=\n  ⟨PEmpty, ⟨p.map inl, fun v => (h v).trans ⟨fun h => ⟨PEmpty.elim, h⟩, fun ⟨_, ht⟩ => ht⟩⟩⟩\n\n"}
{"name":"Dioph.inject_dummies_lem","module":"Mathlib.NumberTheory.Dioph","initialProofState":"α β γ : Type u\nf : β → γ\ng : γ → Option β\ninv : ∀ (x : β), Eq (g (f x)) (Option.some x)\np : Poly (Sum α β)\nv : α → Nat\n⊢ Iff (Exists fun t => Eq (p (Sum.elim v t)) 0) (Exists fun t => Eq ((Poly.map (Sum.elim Sum.inl (Function.comp Sum.inr f)) p) (Sum.elim v t)) 0)","decl":"theorem inject_dummies_lem (f : β → γ) (g : γ → Option β) (inv : ∀ x, g (f x) = some x)\n    (p : Poly (α ⊕ β)) (v : α → ℕ) :\n    (∃ t, p (v ⊗ t) = 0) ↔ ∃ t, p.map (inl ⊗ inr ∘ f) (v ⊗ t) = 0 := by\n  dsimp; refine ⟨fun t => ?_, fun t => ?_⟩ <;> cases' t with t ht\n  · have : (v ⊗ (0 ::ₒ t) ∘ g) ∘ (inl ⊗ inr ∘ f) = v ⊗ t :=\n      funext fun s => by cases' s with a b <;> dsimp [(· ∘ ·)]; try rw [inv]; rfl\n    exact ⟨(0 ::ₒ t) ∘ g, by rwa [this]⟩\n  · have : v ⊗ t ∘ f = (v ⊗ t) ∘ (inl ⊗ inr ∘ f) := funext fun s => by cases' s with a b <;> rfl\n    exact ⟨t ∘ f, by rwa [this]⟩\n\n"}
{"name":"Dioph.inject_dummies","module":"Mathlib.NumberTheory.Dioph","initialProofState":"α β γ : Type u\nS : Set (α → Nat)\nf : β → γ\ng : γ → Option β\ninv : ∀ (x : β), Eq (g (f x)) (Option.some x)\np : Poly (Sum α β)\nh : ∀ (v : α → Nat), Iff (S v) (Exists fun t => Eq (p (Sum.elim v t)) 0)\n⊢ Exists fun q => ∀ (v : α → Nat), Iff (S v) (Exists fun t => Eq (q (Sum.elim v t)) 0)","decl":"theorem inject_dummies (f : β → γ) (g : γ → Option β) (inv : ∀ x, g (f x) = some x)\n    (p : Poly (α ⊕ β)) (h : ∀ v, S v ↔ ∃ t, p (v ⊗ t) = 0) :\n    ∃ q : Poly (α ⊕ γ), ∀ v, S v ↔ ∃ t, q (v ⊗ t) = 0 :=\n  ⟨p.map (inl ⊗ inr ∘ f), fun v => (h v).trans <| inject_dummies_lem f g inv _ _⟩\n\n"}
{"name":"Dioph.reindex_dioph","module":"Mathlib.NumberTheory.Dioph","initialProofState":"α β : Type u\nS : Set (α → Nat)\nf : α → β\na✝ : Dioph S\n⊢ Dioph (setOf fun v => Membership.mem S (Function.comp v f))","decl":"theorem reindex_dioph (f : α → β) : Dioph S → Dioph {v | v ∘ f ∈ S}\n  | ⟨γ, p, pe⟩ => ⟨γ, p.map (inl ∘ f ⊗ inr), fun v =>\n      (pe _).trans <|\n        exists_congr fun t =>\n          suffices v ∘ f ⊗ t = (v ⊗ t) ∘ (inl ∘ f ⊗ inr) by simp [this]\n          funext fun s => by cases' s with a b <;> rfl⟩\n\n"}
{"name":"Dioph.DiophList.forall","module":"Mathlib.NumberTheory.Dioph","initialProofState":"α : Type u\nl : List (Set (α → Nat))\nd : List.Forall Dioph l\n⊢ Dioph (setOf fun v => List.Forall (fun S => Membership.mem S v) l)","decl":"theorem DiophList.forall (l : List (Set <| α → ℕ)) (d : l.Forall Dioph) :\n    Dioph {v | l.Forall fun S : Set (α → ℕ) => v ∈ S} := by\n  suffices ∃ (β : _) (pl : List (Poly (α ⊕ β))), ∀ v, List.Forall (fun S : Set _ => S v) l ↔\n          ∃ t, List.Forall (fun p : Poly (α ⊕ β) => p (v ⊗ t) = 0) pl\n    from\n    let ⟨β, pl, h⟩ := this\n    ⟨β, Poly.sumsq pl, fun v => (h v).trans <| exists_congr fun t => (Poly.sumsq_eq_zero _ _).symm⟩\n  induction' l with S l IH\n  · exact ⟨ULift Empty, [], fun _ => by simp⟩\n  simp? at d says simp only [List.forall_cons] at d\n  exact\n    let ⟨⟨β, p, pe⟩, dl⟩ := d\n    let ⟨γ, pl, ple⟩ := IH dl\n    ⟨β ⊕ γ, p.map (inl ⊗ inr ∘ inl)::pl.map fun q => q.map (inl ⊗ inr ∘ inr),\n      fun v => by\n      simp; exact\n        Iff.trans (and_congr (pe v) (ple v))\n          ⟨fun ⟨⟨m, hm⟩, ⟨n, hn⟩⟩ =>\n            ⟨m ⊗ n, by\n              rw [show (v ⊗ m ⊗ n) ∘ (inl ⊗ inr ∘ inl) = v ⊗ m from\n                    funext fun s => by cases' s with a b <;> rfl]; exact hm, by\n              refine List.Forall.imp (fun q hq => ?_) hn; dsimp [Function.comp_def]\n              rw [show\n                    (fun x : α ⊕ γ => (v ⊗ m ⊗ n) ((inl ⊗ fun x : γ => inr (inr x)) x)) = v ⊗ n\n                    from funext fun s => by cases' s with a b <;> rfl]; exact hq⟩,\n            fun ⟨t, hl, hr⟩ =>\n            ⟨⟨t ∘ inl, by\n                rwa [show (v ⊗ t) ∘ (inl ⊗ inr ∘ inl) = v ⊗ t ∘ inl from\n                    funext fun s => by cases' s with a b <;> rfl] at hl⟩,\n              ⟨t ∘ inr, by\n                refine List.Forall.imp (fun q hq => ?_) hr; dsimp [Function.comp_def] at hq\n                rwa [show\n                    (fun x : α ⊕ γ => (v ⊗ t) ((inl ⊗ fun x : γ => inr (inr x)) x)) =\n                      v ⊗ t ∘ inr\n                    from funext fun s => by cases' s with a b <;> rfl] at hq ⟩⟩⟩⟩\n\n"}
{"name":"Dioph.inter","module":"Mathlib.NumberTheory.Dioph","initialProofState":"α : Type u\nS S' : Set (α → Nat)\nd : Dioph S\nd' : Dioph S'\n⊢ Dioph (Inter.inter S S')","decl":"theorem inter (d : Dioph S) (d' : Dioph S') : Dioph (S ∩ S') := DiophList.forall [S, S'] ⟨d, d'⟩\n\n"}
{"name":"Dioph.union","module":"Mathlib.NumberTheory.Dioph","initialProofState":"α : Type u\nS S' : Set (α → Nat)\nx✝¹ : Dioph S\nx✝ : Dioph S'\n⊢ Dioph (Union.union S S')","decl":"theorem union : ∀ (_ : Dioph S) (_ : Dioph S'), Dioph (S ∪ S')\n  | ⟨β, p, pe⟩, ⟨γ, q, qe⟩ =>\n    ⟨β ⊕ γ, p.map (inl ⊗ inr ∘ inl) * q.map (inl ⊗ inr ∘ inr), fun v => by\n      refine\n        Iff.trans (or_congr ((pe v).trans ?_) ((qe v).trans ?_))\n          (exists_or.symm.trans\n            (exists_congr fun t =>\n              (@mul_eq_zero _ _ _ (p ((v ⊗ t) ∘ (inl ⊗ inr ∘ inl)))\n                  (q ((v ⊗ t) ∘ (inl ⊗ inr ∘ inr)))).symm))\n      -- Porting note: putting everything on the same line fails\n      · refine inject_dummies_lem _ ?_ ?_ _ _\n        · exact some ⊗ fun _ => none\n        · exact fun _ => by simp only [elim_inl]\n      -- Porting note: putting everything on the same line fails\n      · refine inject_dummies_lem _ ?_ ?_ _ _\n        · exact (fun _ => none) ⊗ some\n        · exact fun _ => by simp only [elim_inr]⟩\n\n"}
{"name":"Dioph.reindex_diophFn","module":"Mathlib.NumberTheory.Dioph","initialProofState":"α β : Type u\nf : (α → Nat) → Nat\ng : α → β\nd : Dioph.DiophFn f\n⊢ Dioph.DiophFn fun v => f (Function.comp v g)","decl":"theorem reindex_diophFn {f : (α → ℕ) → ℕ} (g : α → β) (d : DiophFn f) :\n    DiophFn fun v => f (v ∘ g) := by convert reindex_dioph (Option β) (Option.map g) d\n\n"}
{"name":"Dioph.ex_dioph","module":"Mathlib.NumberTheory.Dioph","initialProofState":"α β : Type u\nS : Set (Sum α β → Nat)\na✝ : Dioph S\n⊢ Dioph (setOf fun v => Exists fun x => Membership.mem S (Sum.elim v x))","decl":"theorem ex_dioph {S : Set (α ⊕ β → ℕ)} : Dioph S → Dioph {v | ∃ x, v ⊗ x ∈ S}\n  | ⟨γ, p, pe⟩ =>\n    ⟨β ⊕ γ, p.map ((inl ⊗ inr ∘ inl) ⊗ inr ∘ inr), fun v =>\n      ⟨fun ⟨x, hx⟩ =>\n        let ⟨t, ht⟩ := (pe _).1 hx\n        ⟨x ⊗ t, by\n          simp; rw [show (v ⊗ x ⊗ t) ∘ ((inl ⊗ inr ∘ inl) ⊗ inr ∘ inr) = (v ⊗ x) ⊗ t from\n            funext fun s => by cases' s with a b <;> try { cases a <;> rfl }; rfl]\n          exact ht⟩,\n        fun ⟨t, ht⟩ =>\n        ⟨t ∘ inl,\n          (pe _).2\n            ⟨t ∘ inr, by\n              simp only [Poly.map_apply] at ht\n              rwa [show (v ⊗ t) ∘ ((inl ⊗ inr ∘ inl) ⊗ inr ∘ inr) = (v ⊗ t ∘ inl) ⊗ t ∘ inr from\n                funext fun s => by cases' s with a b <;> try { cases a <;> rfl }; rfl] at ht⟩⟩⟩⟩\n\n"}
{"name":"Dioph.ex1_dioph","module":"Mathlib.NumberTheory.Dioph","initialProofState":"α : Type u\nS : Set (Option α → Nat)\na✝ : Dioph S\n⊢ Dioph (setOf fun v => Exists fun x => Membership.mem S (Option.elim' x v))","decl":"theorem ex1_dioph {S : Set (Option α → ℕ)} : Dioph S → Dioph {v | ∃ x, x ::ₒ v ∈ S}\n  | ⟨β, p, pe⟩ =>\n    ⟨Option β, p.map (inr none ::ₒ inl ⊗ inr ∘ some), fun v =>\n      ⟨fun ⟨x, hx⟩ =>\n        let ⟨t, ht⟩ := (pe _).1 hx\n        ⟨x ::ₒ t, by\n          simp only [Poly.map_apply]\n          rw [show (v ⊗ x ::ₒ t) ∘ (inr none ::ₒ inl ⊗ inr ∘ some) = x ::ₒ v ⊗ t from\n            funext fun s => by cases' s with a b <;> try { cases a <;> rfl}; rfl]\n          exact ht⟩,\n        fun ⟨t, ht⟩ =>\n        ⟨t none,\n          (pe _).2\n            ⟨t ∘ some, by\n              simp only [Poly.map_apply] at ht\n              rwa [show (v ⊗ t) ∘ (inr none ::ₒ inl ⊗ inr ∘ some) = t none ::ₒ v ⊗ t ∘ some from\n                funext fun s => by cases' s with a b <;> try { cases a <;> rfl }; rfl] at ht ⟩⟩⟩⟩\n\n"}
{"name":"Dioph.dom_dioph","module":"Mathlib.NumberTheory.Dioph","initialProofState":"α : Type u\nf : PFun (α → Nat) Nat\nd : Dioph.DiophPFun f\n⊢ Dioph f.Dom","decl":"theorem dom_dioph {f : (α → ℕ) →. ℕ} (d : DiophPFun f) : Dioph f.Dom :=\n  cast (congr_arg Dioph <| Set.ext fun _ => (PFun.dom_iff_graph _ _).symm) (ex1_dioph d)\n\n"}
{"name":"Dioph.diophFn_iff_pFun","module":"Mathlib.NumberTheory.Dioph","initialProofState":"α : Type u\nf : (α → Nat) → Nat\n⊢ Eq (Dioph.DiophFn f) (Dioph.DiophPFun ↑f)","decl":"theorem diophFn_iff_pFun (f : (α → ℕ) → ℕ) : DiophFn f = @DiophPFun α f := by\n  refine congr_arg Dioph (Set.ext fun v => ?_); exact PFun.lift_graph.symm\n\n"}
{"name":"Dioph.abs_poly_dioph","module":"Mathlib.NumberTheory.Dioph","initialProofState":"α : Type u\np : Poly α\n⊢ Dioph.DiophFn fun v => (p v).natAbs","decl":"theorem abs_poly_dioph (p : Poly α) : DiophFn fun v => (p v).natAbs :=\n  of_no_dummies _ ((p.map some - Poly.proj none) * (p.map some + Poly.proj none))\n    fun v => (by dsimp; exact Int.eq_natAbs_iff_mul_eq_zero)\n\n"}
{"name":"Dioph.proj_dioph","module":"Mathlib.NumberTheory.Dioph","initialProofState":"α : Type u\ni : α\n⊢ Dioph.DiophFn fun v => v i","decl":"theorem proj_dioph (i : α) : DiophFn fun v => v i :=\n  abs_poly_dioph (Poly.proj i)\n\n"}
{"name":"Dioph.diophPFun_comp1","module":"Mathlib.NumberTheory.Dioph","initialProofState":"α : Type u\nS : Set (Option α → Nat)\nd : Dioph S\nf : PFun (α → Nat) Nat\ndf : Dioph.DiophPFun f\n⊢ Dioph (setOf fun v => Exists fun h => Membership.mem S (Option.elim' (f.fn v h) v))","decl":"theorem diophPFun_comp1 {S : Set (Option α → ℕ)} (d : Dioph S) {f} (df : DiophPFun f) :\n    Dioph {v : α → ℕ | ∃ h : f.Dom v, f.fn v h ::ₒ v ∈ S} :=\n  ext (ex1_dioph (d.inter df)) fun v =>\n    ⟨fun ⟨x, hS, (h : Exists _)⟩ => by\n      rw [show (x ::ₒ v) ∘ some = v from funext fun s => rfl] at h\n      cases' h with hf h; refine ⟨hf, ?_⟩; rw [PFun.fn, h]; exact hS,\n    fun ⟨x, hS⟩ =>\n      ⟨f.fn v x, hS, show Exists _ by\n        rw [show (f.fn v x ::ₒ v) ∘ some = v from funext fun s => rfl]; exact ⟨x, rfl⟩⟩⟩\n\n"}
{"name":"Dioph.diophFn_comp1","module":"Mathlib.NumberTheory.Dioph","initialProofState":"α : Type u\nS : Set (Option α → Nat)\nd : Dioph S\nf : (α → Nat) → Nat\ndf : Dioph.DiophFn f\n⊢ Dioph (setOf fun v => Membership.mem S (Option.elim' (f v) v))","decl":"theorem diophFn_comp1 {S : Set (Option α → ℕ)} (d : Dioph S) {f : (α → ℕ) → ℕ} (df : DiophFn f) :\n    Dioph {v | f v ::ₒ v ∈ S} :=\n  ext (diophPFun_comp1 d <| cast (diophFn_iff_pFun f) df)\n    fun _ => ⟨fun ⟨_, h⟩ => h, fun h => ⟨trivial, h⟩⟩\n\n"}
{"name":"Dioph.diophFn_vec_comp1","module":"Mathlib.NumberTheory.Dioph","initialProofState":"n : Nat\nS : Set (Vector3 Nat n.succ)\nd : Dioph S\nf : Vector3 Nat n → Nat\ndf : Dioph.DiophFn f\n⊢ Dioph (setOf fun v => Membership.mem S (Vector3.cons (f v) v))","decl":"theorem diophFn_vec_comp1 {S : Set (Vector3 ℕ (succ n))} (d : Dioph S) {f : Vector3 ℕ n → ℕ}\n    (df : DiophFn f) : Dioph {v : Vector3 ℕ n | (f v::v) ∈ S} :=\n  Dioph.ext (diophFn_comp1 (reindex_dioph _ (none::some) d) df) (fun v => by\n    dsimp\n    -- Porting note: `congr` use to be enough here\n    suffices ((f v ::ₒ v) ∘ none :: some) = f v :: v by rw [this]; rfl\n    ext x; cases x <;> rfl)\n\n"}
{"name":"Dioph.vec_ex1_dioph","module":"Mathlib.NumberTheory.Dioph","initialProofState":"n : Nat\nS : Set (Vector3 Nat n.succ)\nd : Dioph S\n⊢ Dioph (setOf fun v => Exists fun x => Membership.mem S (Vector3.cons x v))","decl":"theorem vec_ex1_dioph (n) {S : Set (Vector3 ℕ (succ n))} (d : Dioph S) :\n    Dioph {v : Fin2 n → ℕ | ∃ x, (x::v) ∈ S} :=\n  ext (ex1_dioph <| reindex_dioph _ (none::some) d) fun v =>\n    exists_congr fun x => by\n      dsimp\n      rw [show Option.elim' x v ∘ cons none some = x::v from\n          funext fun s => by cases' s with a b <;> rfl]\n\n"}
{"name":"Dioph.diophFn_vec","module":"Mathlib.NumberTheory.Dioph","initialProofState":"n : Nat\nf : Vector3 Nat n → Nat\n⊢ Iff (Dioph.DiophFn f) (Dioph (setOf fun v => Eq (f (Function.comp v Fin2.fs)) (v Fin2.fz)))","decl":"theorem diophFn_vec (f : Vector3 ℕ n → ℕ) : DiophFn f ↔ Dioph {v | f (v ∘ fs) = v fz} :=\n  ⟨reindex_dioph _ (fz ::ₒ fs), reindex_dioph _ (none::some)⟩\n\n"}
{"name":"Dioph.diophPFun_vec","module":"Mathlib.NumberTheory.Dioph","initialProofState":"n : Nat\nf : PFun (Vector3 Nat n) Nat\n⊢ Iff (Dioph.DiophPFun f) (Dioph (setOf fun v => f.graph { fst := Function.comp v Fin2.fs, snd := v Fin2.fz }))","decl":"theorem diophPFun_vec (f : Vector3 ℕ n →. ℕ) : DiophPFun f ↔ Dioph {v | f.graph (v ∘ fs, v fz)} :=\n  ⟨reindex_dioph _ (fz ::ₒ fs), reindex_dioph _ (none::some)⟩\n\n"}
{"name":"Dioph.diophFn_compn","module":"Mathlib.NumberTheory.Dioph","initialProofState":"α : Type\nn : Nat\nS : Set (Sum α (Fin2 n) → Nat)\nx✝¹ : Dioph S\nf : Vector3 ((α → Nat) → Nat) n\nx✝ : VectorAllP Dioph.DiophFn f\n⊢ Dioph (setOf fun v => Membership.mem S (Sum.elim v fun i => f i v))","decl":"theorem diophFn_compn :\n    ∀ {n} {S : Set (α ⊕ (Fin2 n) → ℕ)} (_ : Dioph S) {f : Vector3 ((α → ℕ) → ℕ) n}\n      (_ : VectorAllP DiophFn f), Dioph {v : α → ℕ | (v ⊗ fun i => f i v) ∈ S}\n  | 0, S, d, f => fun _ =>\n    ext (reindex_dioph _ (id ⊗ Fin2.elim0) d) fun v => by\n      dsimp\n      -- Porting note: `congr` use to be enough here\n      suffices v ∘ (id ⊗ elim0) = v ⊗ fun i ↦ f i v by rw [this]\n      ext x; obtain _ | _ | _ := x; rfl\n  | succ n, S, d, f =>\n    f.consElim fun f fl => by\n        simp only [vectorAllP_cons, and_imp]\n        exact fun df dfl =>\n          have : Dioph {v | (v ∘ inl ⊗ f (v ∘ inl)::v ∘ inr) ∈ S} :=\n            ext (diophFn_comp1 (reindex_dioph _ (some ∘ inl ⊗ none::some ∘ inr) d) <|\n                reindex_diophFn inl df)\n              fun v => by\n                dsimp\n                -- Porting note: `congr` use to be enough here\n                suffices (f (v ∘ inl) ::ₒ v) ∘ (some ∘ inl ⊗ none :: some ∘ inr) =\n                    v ∘ inl ⊗ f (v ∘ inl) :: v ∘ inr by rw [this]\n                ext x; obtain _ | _ | _ := x <;> rfl\n          have : Dioph {v | (v ⊗ f v::fun i : Fin2 n => fl i v) ∈ S} :=\n            @diophFn_compn n (fun v => S (v ∘ inl ⊗ f (v ∘ inl)::v ∘ inr)) this _ dfl\n          ext this fun v => by\n            dsimp\n            -- Porting note: `congr` use to be enough here\n            suffices (v ⊗ f v :: fun i ↦ fl i v) = v ⊗ fun i ↦ (f :: fl) i v by rw [this]\n            ext x; obtain _ | _ | _ := x <;> rfl\n\n"}
{"name":"Dioph.dioph_comp","module":"Mathlib.NumberTheory.Dioph","initialProofState":"α : Type\nn : Nat\nS : Set (Vector3 Nat n)\nd : Dioph S\nf : Vector3 ((α → Nat) → Nat) n\ndf : VectorAllP Dioph.DiophFn f\n⊢ Dioph (setOf fun v => Membership.mem S fun i => f i v)","decl":"theorem dioph_comp {S : Set (Vector3 ℕ n)} (d : Dioph S) (f : Vector3 ((α → ℕ) → ℕ) n)\n    (df : VectorAllP DiophFn f) : Dioph {v | (fun i => f i v) ∈ S} :=\n  diophFn_compn (reindex_dioph _ inr d) df\n\n"}
{"name":"Dioph.diophFn_comp","module":"Mathlib.NumberTheory.Dioph","initialProofState":"α : Type\nn : Nat\nf : Vector3 Nat n → Nat\ndf : Dioph.DiophFn f\ng : Vector3 ((α → Nat) → Nat) n\ndg : VectorAllP Dioph.DiophFn g\n⊢ Dioph.DiophFn fun v => f fun i => g i v","decl":"theorem diophFn_comp {f : Vector3 ℕ n → ℕ} (df : DiophFn f) (g : Vector3 ((α → ℕ) → ℕ) n)\n    (dg : VectorAllP DiophFn g) : DiophFn fun v => f fun i => g i v :=\n  dioph_comp ((diophFn_vec _).1 df) ((fun v => v none)::fun i v => g i (v ∘ some)) <| by\n    simp only [vectorAllP_cons]\n    exact ⟨proj_dioph none, (vectorAllP_iff_forall _ _).2 fun i =>\n          reindex_diophFn _ <| (vectorAllP_iff_forall _ _).1 dg _⟩\n\n"}
{"name":"Dioph.proj_dioph_of_nat","module":"Mathlib.NumberTheory.Dioph","initialProofState":"n m : Nat\ninst✝ : Fin2.IsLT m n\n⊢ Dioph.DiophFn fun v => v (Fin2.ofNat' m)","decl":"theorem proj_dioph_of_nat {n : ℕ} (m : ℕ) [IsLT m n] : DiophFn fun v : Vector3 ℕ n => v &m :=\n  proj_dioph &m\n\n"}
{"name":"Dioph.const_dioph","module":"Mathlib.NumberTheory.Dioph","initialProofState":"α : Type\nn : Nat\n⊢ Dioph.DiophFn (Function.const (α → Nat) n)","decl":"theorem const_dioph (n : ℕ) : DiophFn (const (α → ℕ) n) :=\n  abs_poly_dioph (Poly.const n)\n\n"}
{"name":"Dioph.dioph_comp2","module":"Mathlib.NumberTheory.Dioph","initialProofState":"α : Type\nf g : (α → Nat) → Nat\ndf : Dioph.DiophFn f\ndg : Dioph.DiophFn g\nS : Nat → Nat → Prop\nd : Dioph fun v => S (v (Fin2.ofNat' 0)) (v (Fin2.ofNat' 1))\n⊢ Dioph fun v => S (f v) (g v)","decl":"theorem dioph_comp2 {S : ℕ → ℕ → Prop} (d : Dioph fun v : Vector3 ℕ 2 => S (v &0) (v &1)) :\n    Dioph fun v => S (f v) (g v) := dioph_comp d [f, g] ⟨df, dg⟩\n\n"}
{"name":"Dioph.diophFn_comp2","module":"Mathlib.NumberTheory.Dioph","initialProofState":"α : Type\nf g : (α → Nat) → Nat\ndf : Dioph.DiophFn f\ndg : Dioph.DiophFn g\nh : Nat → Nat → Nat\nd : Dioph.DiophFn fun v => h (v (Fin2.ofNat' 0)) (v (Fin2.ofNat' 1))\n⊢ Dioph.DiophFn fun v => h (f v) (g v)","decl":"theorem diophFn_comp2 {h : ℕ → ℕ → ℕ} (d : DiophFn fun v : Vector3 ℕ 2 => h (v &0) (v &1)) :\n    DiophFn fun v => h (f v) (g v) := diophFn_comp d [f, g] ⟨df, dg⟩\n\n"}
{"name":"Dioph.eq_dioph","module":"Mathlib.NumberTheory.Dioph","initialProofState":"α : Type\nf g : (α → Nat) → Nat\ndf : Dioph.DiophFn f\ndg : Dioph.DiophFn g\n⊢ Dioph fun v => Eq (f v) (g v)","decl":"theorem eq_dioph : Dioph fun v => f v = g v :=\n  dioph_comp2 df dg <|\n    of_no_dummies _ (Poly.proj &0 - Poly.proj &1) fun v => by\n      exact Int.ofNat_inj.symm.trans ⟨@sub_eq_zero_of_eq ℤ _ (v &0) (v &1), eq_of_sub_eq_zero⟩\n\n"}
{"name":"Dioph.add_dioph","module":"Mathlib.NumberTheory.Dioph","initialProofState":"α : Type\nf g : (α → Nat) → Nat\ndf : Dioph.DiophFn f\ndg : Dioph.DiophFn g\n⊢ Dioph.DiophFn fun v => HAdd.hAdd (f v) (g v)","decl":"theorem add_dioph : DiophFn fun v => f v + g v :=\n  diophFn_comp2 df dg <| abs_poly_dioph (@Poly.proj (Fin2 2) &0 + @Poly.proj (Fin2 2) &1)\n\n"}
{"name":"Dioph.mul_dioph","module":"Mathlib.NumberTheory.Dioph","initialProofState":"α : Type\nf g : (α → Nat) → Nat\ndf : Dioph.DiophFn f\ndg : Dioph.DiophFn g\n⊢ Dioph.DiophFn fun v => HMul.hMul (f v) (g v)","decl":"theorem mul_dioph : DiophFn fun v => f v * g v :=\n  diophFn_comp2 df dg <| abs_poly_dioph (@Poly.proj (Fin2 2) &0 * @Poly.proj (Fin2 2) &1)\n\n"}
{"name":"Dioph.le_dioph","module":"Mathlib.NumberTheory.Dioph","initialProofState":"α : Type\nf g : (α → Nat) → Nat\ndf : Dioph.DiophFn f\ndg : Dioph.DiophFn g\n⊢ Dioph (setOf fun v => LE.le (f v) (g v))","decl":"theorem le_dioph : Dioph {v | f v ≤ g v} :=\n  dioph_comp2 df dg <|\n    ext ((D∃) 2 <| D&1 D+ D&0 D= D&2) fun _ => ⟨fun ⟨_, hx⟩ => le.intro hx, le.dest⟩\n\n"}
{"name":"Dioph.lt_dioph","module":"Mathlib.NumberTheory.Dioph","initialProofState":"α : Type\nf g : (α → Nat) → Nat\ndf : Dioph.DiophFn f\ndg : Dioph.DiophFn g\n⊢ Dioph (setOf fun v => LT.lt (f v) (g v))","decl":"theorem lt_dioph : Dioph {v | f v < g v} := df D+ D.1 D≤ dg\n\n"}
{"name":"Dioph.ne_dioph","module":"Mathlib.NumberTheory.Dioph","initialProofState":"α : Type\nf g : (α → Nat) → Nat\ndf : Dioph.DiophFn f\ndg : Dioph.DiophFn g\n⊢ Dioph (setOf fun v => Ne (f v) (g v))","decl":"theorem ne_dioph : Dioph {v | f v ≠ g v} :=\n  ext (df D< dg D∨ dg D< df) fun v => by dsimp; exact lt_or_lt_iff_ne (α := ℕ)\n\n"}
{"name":"Dioph.sub_dioph","module":"Mathlib.NumberTheory.Dioph","initialProofState":"α : Type\nf g : (α → Nat) → Nat\ndf : Dioph.DiophFn f\ndg : Dioph.DiophFn g\n⊢ Dioph.DiophFn fun v => HSub.hSub (f v) (g v)","decl":"theorem sub_dioph : DiophFn fun v => f v - g v :=\n  diophFn_comp2 df dg <|\n    (diophFn_vec _).2 <|\n      ext (D&1 D= D&0 D+ D&2 D∨ D&1 D≤ D&2 D∧ D&0 D= D.0) <|\n        (vectorAll_iff_forall _).1 fun x y z =>\n          show y = x + z ∨ y ≤ z ∧ x = 0 ↔ y - z = x from\n            ⟨fun o => by\n              rcases o with (ae | ⟨yz, x0⟩)\n              · rw [ae, add_tsub_cancel_right]\n              · rw [x0, tsub_eq_zero_iff_le.mpr yz], by\n              rintro rfl\n              rcases le_total y z with yz | zy\n              · exact Or.inr ⟨yz, tsub_eq_zero_iff_le.mpr yz⟩\n              · exact Or.inl (tsub_add_cancel_of_le zy).symm⟩\n\n"}
{"name":"Dioph.dvd_dioph","module":"Mathlib.NumberTheory.Dioph","initialProofState":"α : Type\nf g : (α → Nat) → Nat\ndf : Dioph.DiophFn f\ndg : Dioph.DiophFn g\n⊢ Dioph fun v => Dvd.dvd (f v) (g v)","decl":"theorem dvd_dioph : Dioph fun v => f v ∣ g v :=\n  dioph_comp ((D∃) 2 <| D&2 D= D&1 D* D&0) [f, g] ⟨df, dg⟩\n\n"}
{"name":"Dioph.mod_dioph","module":"Mathlib.NumberTheory.Dioph","initialProofState":"α : Type\nf g : (α → Nat) → Nat\ndf : Dioph.DiophFn f\ndg : Dioph.DiophFn g\n⊢ Dioph.DiophFn fun v => HMod.hMod (f v) (g v)","decl":"theorem mod_dioph : DiophFn fun v => f v % g v :=\n  have : Dioph fun v : Vector3 ℕ 3 => (v &2 = 0 ∨ v &0 < v &2) ∧ ∃ x : ℕ, v &0 + v &2 * x = v &1 :=\n    (D&2 D= D.0 D∨ D&0 D< D&2) D∧ (D∃) 3 <| D&1 D+ D&3 D* D&0 D= D&2\n  diophFn_comp2 df dg <|\n    (diophFn_vec _).2 <|\n      ext this <|\n        (vectorAll_iff_forall _).1 fun z x y =>\n          show ((y = 0 ∨ z < y) ∧ ∃ c, z + y * c = x) ↔ x % y = z from\n            ⟨fun ⟨h, c, hc⟩ => by\n              rw [← hc]; simp only [add_mul_mod_self_left]; cases' h with x0 hl\n              · rw [x0, mod_zero]\n              exact mod_eq_of_lt hl, fun e => by\n                rw [← e]\n                exact ⟨or_iff_not_imp_left.2 fun h => mod_lt _ (Nat.pos_of_ne_zero h), x / y,\n                  mod_add_div _ _⟩⟩\n\n"}
{"name":"Dioph.modEq_dioph","module":"Mathlib.NumberTheory.Dioph","initialProofState":"α : Type\nf g : (α → Nat) → Nat\ndf : Dioph.DiophFn f\ndg : Dioph.DiophFn g\nh : (α → Nat) → Nat\ndh : Dioph.DiophFn h\n⊢ Dioph fun v => (h v).ModEq (f v) (g v)","decl":"theorem modEq_dioph {h : (α → ℕ) → ℕ} (dh : DiophFn h) : Dioph fun v => f v ≡ g v [MOD h v] :=\n  df D% dh D= dg D% dh\n\n"}
{"name":"Dioph.div_dioph","module":"Mathlib.NumberTheory.Dioph","initialProofState":"α : Type\nf g : (α → Nat) → Nat\ndf : Dioph.DiophFn f\ndg : Dioph.DiophFn g\n⊢ Dioph.DiophFn fun v => HDiv.hDiv (f v) (g v)","decl":"theorem div_dioph : DiophFn fun v => f v / g v :=\n  have :\n    Dioph fun v : Vector3 ℕ 3 =>\n      v &2 = 0 ∧ v &0 = 0 ∨ v &0 * v &2 ≤ v &1 ∧ v &1 < (v &0 + 1) * v &2 :=\n    (D&2 D= D.0 D∧ D&0 D= D.0) D∨ D&0 D* D&2 D≤ D&1 D∧ D&1 D< (D&0 D+ D.1) D* D&2\n  diophFn_comp2 df dg <|\n    (diophFn_vec _).2 <|\n      ext this <|\n        (vectorAll_iff_forall _).1 fun z x y =>\n          show y = 0 ∧ z = 0 ∨ z * y ≤ x ∧ x < (z + 1) * y ↔ x / y = z by\n            refine Iff.trans ?_ eq_comm\n            exact y.eq_zero_or_pos.elim\n              (fun y0 => by\n                rw [y0, Nat.div_zero]\n                exact ⟨fun o => (o.resolve_right fun ⟨_, h2⟩ => Nat.not_lt_zero _ h2).right,\n                  fun z0 => Or.inl ⟨rfl, z0⟩⟩)\n              fun ypos =>\n                Iff.trans ⟨fun o => o.resolve_left fun ⟨h1, _⟩ => Nat.ne_of_gt ypos h1, Or.inr⟩\n                  (le_antisymm_iff.trans <| and_congr (Nat.le_div_iff_mul_le ypos) <|\n                    Iff.trans ⟨lt_succ_of_le, le_of_lt_succ⟩ (div_lt_iff_lt_mul ypos)).symm\n\n"}
{"name":"Dioph.pell_dioph","module":"Mathlib.NumberTheory.Dioph","initialProofState":"⊢ Dioph fun v => Exists fun h => And (Eq (Pell.xn h (v (Fin2.ofNat' 1))) (v (Fin2.ofNat' 2))) (Eq (Pell.yn h (v (Fin2.ofNat' 1))) (v (Fin2.ofNat' 3)))","decl":"theorem pell_dioph :\n    Dioph fun v : Vector3 ℕ 4 => ∃ h : 1 < v &0, xn h (v &1) = v &2 ∧ yn h (v &1) = v &3 := by\n  have proof := D.1 D< D&0 D∧ D&1 D≤ D&3 D∧\n      ((D&2 D= D.1 D∧ D&3 D= D.0) D∨\n      ((D∃) 4 <| (D∃) 5 <| (D∃) 6 <| (D∃) 7 <| (D∃) 8 <|\n      D&7 D* D&7 D- (D&5 D* D&5 D- D.1) D* D&8 D* D&8 D= D.1 D∧\n      D&4 D* D&4 D- (D&5 D* D&5 D- D.1) D* D&3 D* D&3 D= D.1 D∧\n      D&2 D* D&2 D- (D&0 D* D&0 D- D.1) D* D&1 D* D&1 D= D.1 D∧\n      D.1 D< D&0 D∧ (D≡ (D&0) (D.1) (D.4 D* D&8)) D∧ (D≡ (D&0) (D&5) (D&4)) D∧\n      D.0 D< D&3 D∧ D&8 D* D&8 D∣ D&3 D∧\n      (D≡ (D&2) (D&7) (D&4)) D∧\n      (D≡ (D&1) (D&6) (D.4 D* (D&8)))))\n  -- Porting note: copying directly `proof` in the proof of the following have fails\n  have : Dioph {v : Vector3 ℕ 4 |\n    1 < v &0 ∧ v &1 ≤ v &3 ∧\n    (v &2 = 1 ∧ v &3 = 0 ∨\n    ∃ u w s t b : ℕ,\n      v &2 * v &2 - (v &0 * v &0 - 1) * v &3 * v &3 = 1 ∧\n      u * u - (v &0 * v &0 - 1) * w * w = 1 ∧\n      s * s - (b * b - 1) * t * t = 1 ∧\n      1 < b ∧ b ≡ 1 [MOD 4 * v &3] ∧ b ≡ v &0 [MOD u] ∧\n      0 < w ∧ v &3 * v &3 ∣ w ∧\n      s ≡ v &2 [MOD u] ∧\n      t ≡ v &1 [MOD 4 * v &3])} := by\n    exact proof\n  exact Dioph.ext this fun v => matiyasevic.symm\n\n"}
{"name":"Dioph.xn_dioph","module":"Mathlib.NumberTheory.Dioph","initialProofState":"⊢ Dioph.DiophPFun fun v => { Dom := LT.lt 1 (v (Fin2.ofNat' 0)), get := fun h => Pell.xn h (v (Fin2.ofNat' 1)) }","decl":"theorem xn_dioph : DiophPFun fun v : Vector3 ℕ 2 => ⟨1 < v &0, fun h => xn h (v &1)⟩ :=\n  have : Dioph fun v : Vector3 ℕ 3 => ∃ y, ∃ h : 1 < v &1, xn h (v &2) = v &0 ∧ yn h (v &2) = y :=\n    let D_pell := pell_dioph.reindex_dioph (Fin2 4) [&2, &3, &1, &0]\n    (D∃) 3 D_pell\n  (diophPFun_vec _).2 <|\n    Dioph.ext this fun _ => ⟨fun ⟨_, h, xe, _⟩ => ⟨h, xe⟩, fun ⟨h, xe⟩ => ⟨_, h, xe, rfl⟩⟩\n\n"}
{"name":"Dioph.pow_dioph","module":"Mathlib.NumberTheory.Dioph","initialProofState":"α : Type\nf g : (α → Nat) → Nat\ndf : Dioph.DiophFn f\ndg : Dioph.DiophFn g\n⊢ Dioph.DiophFn fun v => HPow.hPow (f v) (g v)","decl":"/-- A version of **Matiyasevic's theorem** -/\ntheorem pow_dioph {f g : (α → ℕ) → ℕ} (df : DiophFn f) (dg : DiophFn g) :\n    DiophFn fun v => f v ^ g v := by\n  have proof :=\n    let D_pell := pell_dioph.reindex_dioph (Fin2 9) [&4, &8, &1, &0]\n    (D&2 D= D.0 D∧ D&0 D= D.1) D∨ (D.0 D< D&2 D∧\n    ((D&1 D= D.0 D∧ D&0 D= D.0) D∨ (D.0 D< D&1 D∧\n    ((D∃) 3 <| (D∃) 4 <| (D∃) 5 <| (D∃) 6 <| (D∃) 7 <| (D∃) 8 <| D_pell D∧\n    (D≡ (D&1) (D&0 D* (D&4 D- D&7) D+ D&6) (D&3)) D∧\n    D.2 D* D&4 D* D&7 D= D&3 D+ (D&7 D* D&7 D+ D.1) D∧\n    D&6 D< D&3 D∧ D&7 D≤ D&5 D∧ D&8 D≤ D&5 D∧\n    D&4 D* D&4 D- ((D&5 D+ D.1) D* (D&5 D+ D.1) D- D.1) D* (D&5 D* D&2) D* (D&5 D* D&2) D= D.1))))\n  -- Porting note: copying directly `proof` in the proof of the following have fails\n  have : Dioph {v : Vector3 ℕ 3 |\n    v &2 = 0 ∧ v &0 = 1 ∨ 0 < v &2 ∧\n    (v &1 = 0 ∧ v &0 = 0 ∨ 0 < v &1 ∧\n    ∃ w a t z x y : ℕ,\n      (∃ a1 : 1 < a, xn a1 (v &2) = x ∧ yn a1 (v &2) = y) ∧\n      x ≡ y * (a - v &1) + v &0 [MOD t] ∧\n      2 * a * v &1 = t + (v &1 * v &1 + 1) ∧\n      v &0 < t ∧ v &1 ≤ w ∧ v &2 ≤ w ∧\n      a * a - ((w + 1) * (w + 1) - 1) * (w * z) * (w * z) = 1)} := by\n    exact proof\n  exact diophFn_comp2 df dg <| (diophFn_vec _).2 <| Dioph.ext this fun v => Iff.symm <|\n    eq_pow_of_pell.trans <| or_congr Iff.rfl <| and_congr Iff.rfl <| or_congr Iff.rfl <|\n       and_congr Iff.rfl <|\n        ⟨fun ⟨w, a, t, z, a1, h⟩ => ⟨w, a, t, z, _, _, ⟨a1, rfl, rfl⟩, h⟩,\n        fun ⟨w, a, t, z, _, _, ⟨a1, rfl, rfl⟩, h⟩ => ⟨w, a, t, z, a1, h⟩⟩\n\n"}
