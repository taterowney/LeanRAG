{"name":"finsum_def'","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"M : Type u_7\nα : Sort u_8\ninst✝ : AddCommMonoid M\nf : α → M\n⊢ Eq (finsum f) (dite (Function.support (Function.comp f PLift.down)).Finite (fun h => h.toFinset.sum fun i => f i.down) fun h => 0)","decl":"open Classical in\n/-- Sum of `f x` as `x` ranges over the elements of the support of `f`, if it's finite. Zero\notherwise. -/\nnoncomputable irreducible_def finsum (lemma := finsum_def') [AddCommMonoid M] (f : α → M) : M :=\n  if h : (support (f ∘ PLift.down)).Finite then ∑ i ∈ h.toFinset, f i.down else 0\n\n"}
{"name":"finprod_def'","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"M : Type u_7\nα : Sort u_8\ninst✝ : CommMonoid M\nf : α → M\n⊢ Eq (finprod f) (dite (Function.mulSupport (Function.comp f PLift.down)).Finite (fun h => h.toFinset.prod fun i => f i.down) fun h => 1)","decl":"open Classical in\n/-- Product of `f x` as `x` ranges over the elements of the multiplicative support of `f`, if it's\nfinite. One otherwise. -/\n@[to_additive existing]\nnoncomputable irreducible_def finprod (lemma := finprod_def') (f : α → M) : M :=\n  if h : (mulSupport (f ∘ PLift.down)).Finite then ∏ i ∈ h.toFinset, f i.down else 1\n\n"}
{"name":"finprod_eq_prod_plift_of_mulSupport_toFinset_subset","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"M : Type u_2\nα : Sort u_4\ninst✝ : CommMonoid M\nf : α → M\nhf : (Function.mulSupport (Function.comp f PLift.down)).Finite\ns : Finset (PLift α)\nhs : HasSubset.Subset hf.toFinset s\n⊢ Eq (finprod fun i => f i) (s.prod fun i => f i.down)","decl":"@[to_additive]\ntheorem finprod_eq_prod_plift_of_mulSupport_toFinset_subset {f : α → M}\n    (hf : (mulSupport (f ∘ PLift.down)).Finite) {s : Finset (PLift α)} (hs : hf.toFinset ⊆ s) :\n    ∏ᶠ i, f i = ∏ i ∈ s, f i.down := by\n  rw [finprod, dif_pos]\n  refine Finset.prod_subset hs fun x _ hxf => ?_\n  rwa [hf.mem_toFinset, nmem_mulSupport] at hxf\n\n"}
{"name":"finsum_eq_sum_plift_of_support_toFinset_subset","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"M : Type u_2\nα : Sort u_4\ninst✝ : AddCommMonoid M\nf : α → M\nhf : (Function.support (Function.comp f PLift.down)).Finite\ns : Finset (PLift α)\nhs : HasSubset.Subset hf.toFinset s\n⊢ Eq (finsum fun i => f i) (s.sum fun i => f i.down)","decl":"@[to_additive]\ntheorem finprod_eq_prod_plift_of_mulSupport_toFinset_subset {f : α → M}\n    (hf : (mulSupport (f ∘ PLift.down)).Finite) {s : Finset (PLift α)} (hs : hf.toFinset ⊆ s) :\n    ∏ᶠ i, f i = ∏ i ∈ s, f i.down := by\n  rw [finprod, dif_pos]\n  refine Finset.prod_subset hs fun x _ hxf => ?_\n  rwa [hf.mem_toFinset, nmem_mulSupport] at hxf\n\n"}
{"name":"finprod_eq_prod_plift_of_mulSupport_subset","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"M : Type u_2\nα : Sort u_4\ninst✝ : CommMonoid M\nf : α → M\ns : Finset (PLift α)\nhs : HasSubset.Subset (Function.mulSupport (Function.comp f PLift.down)) ↑s\n⊢ Eq (finprod fun i => f i) (s.prod fun i => f i.down)","decl":"@[to_additive]\ntheorem finprod_eq_prod_plift_of_mulSupport_subset {f : α → M} {s : Finset (PLift α)}\n    (hs : mulSupport (f ∘ PLift.down) ⊆ s) : ∏ᶠ i, f i = ∏ i ∈ s, f i.down :=\n  finprod_eq_prod_plift_of_mulSupport_toFinset_subset (s.finite_toSet.subset hs) fun x hx => by\n    rw [Finite.mem_toFinset] at hx\n    exact hs hx\n\n"}
{"name":"finsum_eq_sum_plift_of_support_subset","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"M : Type u_2\nα : Sort u_4\ninst✝ : AddCommMonoid M\nf : α → M\ns : Finset (PLift α)\nhs : HasSubset.Subset (Function.support (Function.comp f PLift.down)) ↑s\n⊢ Eq (finsum fun i => f i) (s.sum fun i => f i.down)","decl":"@[to_additive]\ntheorem finprod_eq_prod_plift_of_mulSupport_subset {f : α → M} {s : Finset (PLift α)}\n    (hs : mulSupport (f ∘ PLift.down) ⊆ s) : ∏ᶠ i, f i = ∏ i ∈ s, f i.down :=\n  finprod_eq_prod_plift_of_mulSupport_toFinset_subset (s.finite_toSet.subset hs) fun x hx => by\n    rw [Finite.mem_toFinset] at hx\n    exact hs hx\n\n"}
{"name":"finprod_one","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"M : Type u_2\nα : Sort u_4\ninst✝ : CommMonoid M\n⊢ Eq (finprod fun x => 1) 1","decl":"@[to_additive (attr := simp)]\ntheorem finprod_one : (∏ᶠ _ : α, (1 : M)) = 1 := by\n  have : (mulSupport fun x : PLift α => (fun _ => 1 : α → M) x.down) ⊆ (∅ : Finset (PLift α)) :=\n    fun x h => by simp at h\n  rw [finprod_eq_prod_plift_of_mulSupport_subset this, Finset.prod_empty]\n\n"}
{"name":"finsum_zero","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"M : Type u_2\nα : Sort u_4\ninst✝ : AddCommMonoid M\n⊢ Eq (finsum fun x => 0) 0","decl":"@[to_additive (attr := simp)]\ntheorem finprod_one : (∏ᶠ _ : α, (1 : M)) = 1 := by\n  have : (mulSupport fun x : PLift α => (fun _ => 1 : α → M) x.down) ⊆ (∅ : Finset (PLift α)) :=\n    fun x h => by simp at h\n  rw [finprod_eq_prod_plift_of_mulSupport_subset this, Finset.prod_empty]\n\n"}
{"name":"finprod_of_isEmpty","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"M : Type u_2\nα : Sort u_4\ninst✝¹ : CommMonoid M\ninst✝ : IsEmpty α\nf : α → M\n⊢ Eq (finprod fun i => f i) 1","decl":"@[to_additive]\ntheorem finprod_of_isEmpty [IsEmpty α] (f : α → M) : ∏ᶠ i, f i = 1 := by\n  rw [← finprod_one]\n  congr\n  simp [eq_iff_true_of_subsingleton]\n\n"}
{"name":"finsum_of_isEmpty","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"M : Type u_2\nα : Sort u_4\ninst✝¹ : AddCommMonoid M\ninst✝ : IsEmpty α\nf : α → M\n⊢ Eq (finsum fun i => f i) 0","decl":"@[to_additive]\ntheorem finprod_of_isEmpty [IsEmpty α] (f : α → M) : ∏ᶠ i, f i = 1 := by\n  rw [← finprod_one]\n  congr\n  simp [eq_iff_true_of_subsingleton]\n\n"}
{"name":"finsum_false","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"M : Type u_2\ninst✝ : AddCommMonoid M\nf : False → M\n⊢ Eq (finsum fun i => f i) 0","decl":"@[to_additive (attr := simp)]\ntheorem finprod_false (f : False → M) : ∏ᶠ i, f i = 1 :=\n  finprod_of_isEmpty _\n\n"}
{"name":"finprod_false","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"M : Type u_2\ninst✝ : CommMonoid M\nf : False → M\n⊢ Eq (finprod fun i => f i) 1","decl":"@[to_additive (attr := simp)]\ntheorem finprod_false (f : False → M) : ∏ᶠ i, f i = 1 :=\n  finprod_of_isEmpty _\n\n"}
{"name":"finprod_eq_single","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"M : Type u_2\nα : Sort u_4\ninst✝ : CommMonoid M\nf : α → M\na : α\nha : ∀ (x : α), Ne x a → Eq (f x) 1\n⊢ Eq (finprod fun x => f x) (f a)","decl":"@[to_additive]\ntheorem finprod_eq_single (f : α → M) (a : α) (ha : ∀ x, x ≠ a → f x = 1) :\n    ∏ᶠ x, f x = f a := by\n  have : mulSupport (f ∘ PLift.down) ⊆ ({PLift.up a} : Finset (PLift α)) := by\n    intro x\n    contrapose\n    simpa [PLift.eq_up_iff_down_eq] using ha x.down\n  rw [finprod_eq_prod_plift_of_mulSupport_subset this, Finset.prod_singleton]\n\n"}
{"name":"finsum_eq_single","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"M : Type u_2\nα : Sort u_4\ninst✝ : AddCommMonoid M\nf : α → M\na : α\nha : ∀ (x : α), Ne x a → Eq (f x) 0\n⊢ Eq (finsum fun x => f x) (f a)","decl":"@[to_additive]\ntheorem finprod_eq_single (f : α → M) (a : α) (ha : ∀ x, x ≠ a → f x = 1) :\n    ∏ᶠ x, f x = f a := by\n  have : mulSupport (f ∘ PLift.down) ⊆ ({PLift.up a} : Finset (PLift α)) := by\n    intro x\n    contrapose\n    simpa [PLift.eq_up_iff_down_eq] using ha x.down\n  rw [finprod_eq_prod_plift_of_mulSupport_subset this, Finset.prod_singleton]\n\n"}
{"name":"finprod_unique","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"M : Type u_2\nα : Sort u_4\ninst✝¹ : CommMonoid M\ninst✝ : Unique α\nf : α → M\n⊢ Eq (finprod fun i => f i) (f Inhabited.default)","decl":"@[to_additive]\ntheorem finprod_unique [Unique α] (f : α → M) : ∏ᶠ i, f i = f default :=\n  finprod_eq_single f default fun _x hx => (hx <| Unique.eq_default _).elim\n\n"}
{"name":"finsum_unique","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"M : Type u_2\nα : Sort u_4\ninst✝¹ : AddCommMonoid M\ninst✝ : Unique α\nf : α → M\n⊢ Eq (finsum fun i => f i) (f Inhabited.default)","decl":"@[to_additive]\ntheorem finprod_unique [Unique α] (f : α → M) : ∏ᶠ i, f i = f default :=\n  finprod_eq_single f default fun _x hx => (hx <| Unique.eq_default _).elim\n\n"}
{"name":"finprod_true","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"M : Type u_2\ninst✝ : CommMonoid M\nf : True → M\n⊢ Eq (finprod fun i => f i) (f trivial)","decl":"@[to_additive (attr := simp)]\ntheorem finprod_true (f : True → M) : ∏ᶠ i, f i = f trivial :=\n  @finprod_unique M True _ ⟨⟨trivial⟩, fun _ => rfl⟩ f\n\n"}
{"name":"finsum_true","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"M : Type u_2\ninst✝ : AddCommMonoid M\nf : True → M\n⊢ Eq (finsum fun i => f i) (f trivial)","decl":"@[to_additive (attr := simp)]\ntheorem finprod_true (f : True → M) : ∏ᶠ i, f i = f trivial :=\n  @finprod_unique M True _ ⟨⟨trivial⟩, fun _ => rfl⟩ f\n\n"}
{"name":"finsum_eq_dif","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"M : Type u_2\ninst✝¹ : AddCommMonoid M\np : Prop\ninst✝ : Decidable p\nf : p → M\n⊢ Eq (finsum fun i => f i) (dite p (fun h => f h) fun h => 0)","decl":"@[to_additive]\ntheorem finprod_eq_dif {p : Prop} [Decidable p] (f : p → M) :\n    ∏ᶠ i, f i = if h : p then f h else 1 := by\n  split_ifs with h\n  · haveI : Unique p := ⟨⟨h⟩, fun _ => rfl⟩\n    exact finprod_unique f\n  · haveI : IsEmpty p := ⟨h⟩\n    exact finprod_of_isEmpty f\n\n"}
{"name":"finprod_eq_dif","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"M : Type u_2\ninst✝¹ : CommMonoid M\np : Prop\ninst✝ : Decidable p\nf : p → M\n⊢ Eq (finprod fun i => f i) (dite p (fun h => f h) fun h => 1)","decl":"@[to_additive]\ntheorem finprod_eq_dif {p : Prop} [Decidable p] (f : p → M) :\n    ∏ᶠ i, f i = if h : p then f h else 1 := by\n  split_ifs with h\n  · haveI : Unique p := ⟨⟨h⟩, fun _ => rfl⟩\n    exact finprod_unique f\n  · haveI : IsEmpty p := ⟨h⟩\n    exact finprod_of_isEmpty f\n\n"}
{"name":"finsum_eq_if","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"M : Type u_2\ninst✝¹ : AddCommMonoid M\np : Prop\ninst✝ : Decidable p\nx : M\n⊢ Eq (finsum fun x_1 => x) (ite p x 0)","decl":"@[to_additive]\ntheorem finprod_eq_if {p : Prop} [Decidable p] {x : M} : ∏ᶠ _ : p, x = if p then x else 1 :=\n  finprod_eq_dif fun _ => x\n\n"}
{"name":"finprod_eq_if","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"M : Type u_2\ninst✝¹ : CommMonoid M\np : Prop\ninst✝ : Decidable p\nx : M\n⊢ Eq (finprod fun x_1 => x) (ite p x 1)","decl":"@[to_additive]\ntheorem finprod_eq_if {p : Prop} [Decidable p] {x : M} : ∏ᶠ _ : p, x = if p then x else 1 :=\n  finprod_eq_dif fun _ => x\n\n"}
{"name":"finsum_congr","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"M : Type u_2\nα : Sort u_4\ninst✝ : AddCommMonoid M\nf g : α → M\nh : ∀ (x : α), Eq (f x) (g x)\n⊢ Eq (finsum f) (finsum g)","decl":"@[to_additive]\ntheorem finprod_congr {f g : α → M} (h : ∀ x, f x = g x) : finprod f = finprod g :=\n  congr_arg _ <| funext h\n\n"}
{"name":"finprod_congr","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"M : Type u_2\nα : Sort u_4\ninst✝ : CommMonoid M\nf g : α → M\nh : ∀ (x : α), Eq (f x) (g x)\n⊢ Eq (finprod f) (finprod g)","decl":"@[to_additive]\ntheorem finprod_congr {f g : α → M} (h : ∀ x, f x = g x) : finprod f = finprod g :=\n  congr_arg _ <| funext h\n\n"}
{"name":"finprod_congr_Prop","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"M : Type u_2\ninst✝ : CommMonoid M\np q : Prop\nf : p → M\ng : q → M\nhpq : Eq p q\nhfg : ∀ (h : q), Eq (f ⋯) (g h)\n⊢ Eq (finprod f) (finprod g)","decl":"@[to_additive (attr := congr)]\ntheorem finprod_congr_Prop {p q : Prop} {f : p → M} {g : q → M} (hpq : p = q)\n    (hfg : ∀ h : q, f (hpq.mpr h) = g h) : finprod f = finprod g := by\n  subst q\n  exact finprod_congr hfg\n\n"}
{"name":"finsum_congr_Prop","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"M : Type u_2\ninst✝ : AddCommMonoid M\np q : Prop\nf : p → M\ng : q → M\nhpq : Eq p q\nhfg : ∀ (h : q), Eq (f ⋯) (g h)\n⊢ Eq (finsum f) (finsum g)","decl":"@[to_additive (attr := congr)]\ntheorem finprod_congr_Prop {p q : Prop} {f : p → M} {g : q → M} (hpq : p = q)\n    (hfg : ∀ h : q, f (hpq.mpr h) = g h) : finprod f = finprod g := by\n  subst q\n  exact finprod_congr hfg\n\n"}
{"name":"finprod_induction","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"M : Type u_2\nα : Sort u_4\ninst✝ : CommMonoid M\nf : α → M\np : M → Prop\nhp₀ : p 1\nhp₁ : ∀ (x y : M), p x → p y → p (HMul.hMul x y)\nhp₂ : ∀ (i : α), p (f i)\n⊢ p (finprod fun i => f i)","decl":"/-- To prove a property of a finite product, it suffices to prove that the property is\nmultiplicative and holds on the factors. -/\n@[to_additive\n      \"To prove a property of a finite sum, it suffices to prove that the property is\n      additive and holds on the summands.\"]\ntheorem finprod_induction {f : α → M} (p : M → Prop) (hp₀ : p 1)\n    (hp₁ : ∀ x y, p x → p y → p (x * y)) (hp₂ : ∀ i, p (f i)) : p (∏ᶠ i, f i) := by\n  rw [finprod]\n  split_ifs\n  exacts [Finset.prod_induction _ _ hp₁ hp₀ fun i _ => hp₂ _, hp₀]\n\n"}
{"name":"finsum_induction","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"M : Type u_2\nα : Sort u_4\ninst✝ : AddCommMonoid M\nf : α → M\np : M → Prop\nhp₀ : p 0\nhp₁ : ∀ (x y : M), p x → p y → p (HAdd.hAdd x y)\nhp₂ : ∀ (i : α), p (f i)\n⊢ p (finsum fun i => f i)","decl":"/-- To prove a property of a finite product, it suffices to prove that the property is\nmultiplicative and holds on the factors. -/\n@[to_additive\n      \"To prove a property of a finite sum, it suffices to prove that the property is\n      additive and holds on the summands.\"]\ntheorem finprod_induction {f : α → M} (p : M → Prop) (hp₀ : p 1)\n    (hp₁ : ∀ x y, p x → p y → p (x * y)) (hp₂ : ∀ i, p (f i)) : p (∏ᶠ i, f i) := by\n  rw [finprod]\n  split_ifs\n  exacts [Finset.prod_induction _ _ hp₁ hp₀ fun i _ => hp₂ _, hp₀]\n\n"}
{"name":"finprod_nonneg","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Sort u_4\nR : Type u_7\ninst✝ : OrderedCommSemiring R\nf : α → R\nhf : ∀ (x : α), LE.le 0 (f x)\n⊢ LE.le 0 (finprod fun x => f x)","decl":"theorem finprod_nonneg {R : Type*} [OrderedCommSemiring R] {f : α → R} (hf : ∀ x, 0 ≤ f x) :\n    0 ≤ ∏ᶠ x, f x :=\n  finprod_induction (fun x => 0 ≤ x) zero_le_one (fun _ _ => mul_nonneg) hf\n\n"}
{"name":"finsum_nonneg","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Sort u_4\nM : Type u_7\ninst✝ : OrderedAddCommMonoid M\nf : α → M\nhf : ∀ (i : α), LE.le 0 (f i)\n⊢ LE.le 0 (finsum fun i => f i)","decl":"@[to_additive finsum_nonneg]\ntheorem one_le_finprod' {M : Type*} [OrderedCommMonoid M] {f : α → M} (hf : ∀ i, 1 ≤ f i) :\n    1 ≤ ∏ᶠ i, f i :=\n  finprod_induction _ le_rfl (fun _ _ => one_le_mul) hf\n\n"}
{"name":"one_le_finprod'","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Sort u_4\nM : Type u_7\ninst✝ : OrderedCommMonoid M\nf : α → M\nhf : ∀ (i : α), LE.le 1 (f i)\n⊢ LE.le 1 (finprod fun i => f i)","decl":"@[to_additive finsum_nonneg]\ntheorem one_le_finprod' {M : Type*} [OrderedCommMonoid M] {f : α → M} (hf : ∀ i, 1 ≤ f i) :\n    1 ≤ ∏ᶠ i, f i :=\n  finprod_induction _ le_rfl (fun _ _ => one_le_mul) hf\n\n"}
{"name":"AddMonoidHom.map_finsum_plift","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"M : Type u_2\nN : Type u_3\nα : Sort u_4\ninst✝¹ : AddCommMonoid M\ninst✝ : AddCommMonoid N\nf : AddMonoidHom M N\ng : α → M\nh : (Function.support (Function.comp g PLift.down)).Finite\n⊢ Eq (f (finsum fun x => g x)) (finsum fun x => f (g x))","decl":"@[to_additive]\ntheorem MonoidHom.map_finprod_plift (f : M →* N) (g : α → M)\n    (h : (mulSupport <| g ∘ PLift.down).Finite) : f (∏ᶠ x, g x) = ∏ᶠ x, f (g x) := by\n  rw [finprod_eq_prod_plift_of_mulSupport_subset h.coe_toFinset.ge,\n    finprod_eq_prod_plift_of_mulSupport_subset, map_prod]\n  rw [h.coe_toFinset]\n  exact mulSupport_comp_subset f.map_one (g ∘ PLift.down)\n\n"}
{"name":"MonoidHom.map_finprod_plift","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"M : Type u_2\nN : Type u_3\nα : Sort u_4\ninst✝¹ : CommMonoid M\ninst✝ : CommMonoid N\nf : MonoidHom M N\ng : α → M\nh : (Function.mulSupport (Function.comp g PLift.down)).Finite\n⊢ Eq (f (finprod fun x => g x)) (finprod fun x => f (g x))","decl":"@[to_additive]\ntheorem MonoidHom.map_finprod_plift (f : M →* N) (g : α → M)\n    (h : (mulSupport <| g ∘ PLift.down).Finite) : f (∏ᶠ x, g x) = ∏ᶠ x, f (g x) := by\n  rw [finprod_eq_prod_plift_of_mulSupport_subset h.coe_toFinset.ge,\n    finprod_eq_prod_plift_of_mulSupport_subset, map_prod]\n  rw [h.coe_toFinset]\n  exact mulSupport_comp_subset f.map_one (g ∘ PLift.down)\n\n"}
{"name":"MonoidHom.map_finprod_Prop","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"M : Type u_2\nN : Type u_3\ninst✝¹ : CommMonoid M\ninst✝ : CommMonoid N\np : Prop\nf : MonoidHom M N\ng : p → M\n⊢ Eq (f (finprod fun x => g x)) (finprod fun x => f (g x))","decl":"@[to_additive]\ntheorem MonoidHom.map_finprod_Prop {p : Prop} (f : M →* N) (g : p → M) :\n    f (∏ᶠ x, g x) = ∏ᶠ x, f (g x) :=\n  f.map_finprod_plift g (Set.toFinite _)\n\n"}
{"name":"AddMonoidHom.map_finsum_Prop","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"M : Type u_2\nN : Type u_3\ninst✝¹ : AddCommMonoid M\ninst✝ : AddCommMonoid N\np : Prop\nf : AddMonoidHom M N\ng : p → M\n⊢ Eq (f (finsum fun x => g x)) (finsum fun x => f (g x))","decl":"@[to_additive]\ntheorem MonoidHom.map_finprod_Prop {p : Prop} (f : M →* N) (g : p → M) :\n    f (∏ᶠ x, g x) = ∏ᶠ x, f (g x) :=\n  f.map_finprod_plift g (Set.toFinite _)\n\n"}
{"name":"MonoidHom.map_finprod_of_preimage_one","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"M : Type u_2\nN : Type u_3\nα : Sort u_4\ninst✝¹ : CommMonoid M\ninst✝ : CommMonoid N\nf : MonoidHom M N\nhf : ∀ (x : M), Eq (f x) 1 → Eq x 1\ng : α → M\n⊢ Eq (f (finprod fun i => g i)) (finprod fun i => f (g i))","decl":"@[to_additive]\ntheorem MonoidHom.map_finprod_of_preimage_one (f : M →* N) (hf : ∀ x, f x = 1 → x = 1) (g : α → M) :\n    f (∏ᶠ i, g i) = ∏ᶠ i, f (g i) := by\n  by_cases hg : (mulSupport <| g ∘ PLift.down).Finite; · exact f.map_finprod_plift g hg\n  rw [finprod, dif_neg, f.map_one, finprod, dif_neg]\n  exacts [Infinite.mono (fun x hx => mt (hf (g x.down)) hx) hg, hg]\n\n"}
{"name":"AddMonoidHom.map_finsum_of_preimage_zero","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"M : Type u_2\nN : Type u_3\nα : Sort u_4\ninst✝¹ : AddCommMonoid M\ninst✝ : AddCommMonoid N\nf : AddMonoidHom M N\nhf : ∀ (x : M), Eq (f x) 0 → Eq x 0\ng : α → M\n⊢ Eq (f (finsum fun i => g i)) (finsum fun i => f (g i))","decl":"@[to_additive]\ntheorem MonoidHom.map_finprod_of_preimage_one (f : M →* N) (hf : ∀ x, f x = 1 → x = 1) (g : α → M) :\n    f (∏ᶠ i, g i) = ∏ᶠ i, f (g i) := by\n  by_cases hg : (mulSupport <| g ∘ PLift.down).Finite; · exact f.map_finprod_plift g hg\n  rw [finprod, dif_neg, f.map_one, finprod, dif_neg]\n  exacts [Infinite.mono (fun x hx => mt (hf (g x.down)) hx) hg, hg]\n\n"}
{"name":"AddMonoidHom.map_finsum_of_injective","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"M : Type u_2\nN : Type u_3\nα : Sort u_4\ninst✝¹ : AddCommMonoid M\ninst✝ : AddCommMonoid N\ng : AddMonoidHom M N\nhg : Function.Injective ⇑g\nf : α → M\n⊢ Eq (g (finsum fun i => f i)) (finsum fun i => g (f i))","decl":"@[to_additive]\ntheorem MonoidHom.map_finprod_of_injective (g : M →* N) (hg : Injective g) (f : α → M) :\n    g (∏ᶠ i, f i) = ∏ᶠ i, g (f i) :=\n  g.map_finprod_of_preimage_one (fun _ => (hg.eq_iff' g.map_one).mp) f\n\n"}
{"name":"MonoidHom.map_finprod_of_injective","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"M : Type u_2\nN : Type u_3\nα : Sort u_4\ninst✝¹ : CommMonoid M\ninst✝ : CommMonoid N\ng : MonoidHom M N\nhg : Function.Injective ⇑g\nf : α → M\n⊢ Eq (g (finprod fun i => f i)) (finprod fun i => g (f i))","decl":"@[to_additive]\ntheorem MonoidHom.map_finprod_of_injective (g : M →* N) (hg : Injective g) (f : α → M) :\n    g (∏ᶠ i, f i) = ∏ᶠ i, g (f i) :=\n  g.map_finprod_of_preimage_one (fun _ => (hg.eq_iff' g.map_one).mp) f\n\n"}
{"name":"AddEquiv.map_finsum","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"M : Type u_2\nN : Type u_3\nα : Sort u_4\ninst✝¹ : AddCommMonoid M\ninst✝ : AddCommMonoid N\ng : AddEquiv M N\nf : α → M\n⊢ Eq (g (finsum fun i => f i)) (finsum fun i => g (f i))","decl":"@[to_additive]\ntheorem MulEquiv.map_finprod (g : M ≃* N) (f : α → M) : g (∏ᶠ i, f i) = ∏ᶠ i, g (f i) :=\n  g.toMonoidHom.map_finprod_of_injective (EquivLike.injective g) f\n\n"}
{"name":"MulEquiv.map_finprod","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"M : Type u_2\nN : Type u_3\nα : Sort u_4\ninst✝¹ : CommMonoid M\ninst✝ : CommMonoid N\ng : MulEquiv M N\nf : α → M\n⊢ Eq (g (finprod fun i => f i)) (finprod fun i => g (f i))","decl":"@[to_additive]\ntheorem MulEquiv.map_finprod (g : M ≃* N) (f : α → M) : g (∏ᶠ i, f i) = ∏ᶠ i, g (f i) :=\n  g.toMonoidHom.map_finprod_of_injective (EquivLike.injective g) f\n\n"}
{"name":"finsum_smul","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"ι : Sort u_6\nR : Type u_7\nM : Type u_8\ninst✝³ : Ring R\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : NoZeroSMulDivisors R M\nf : ι → R\nx : M\n⊢ Eq (HSMul.hSMul (finsum fun i => f i) x) (finsum fun i => HSMul.hSMul (f i) x)","decl":"/-- The `NoZeroSMulDivisors` makes sure that the result holds even when the support of `f` is\ninfinite. For a more usual version assuming `(support f).Finite` instead, see `finsum_smul'`. -/\ntheorem finsum_smul {R M : Type*} [Ring R] [AddCommGroup M] [Module R M] [NoZeroSMulDivisors R M]\n    (f : ι → R) (x : M) : (∑ᶠ i, f i) • x = ∑ᶠ i, f i • x := by\n  rcases eq_or_ne x 0 with (rfl | hx)\n  · simp\n  · exact ((smulAddHom R M).flip x).map_finsum_of_injective (smul_left_injective R hx) _\n\n"}
{"name":"smul_finsum","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"ι : Sort u_6\nR : Type u_7\nM : Type u_8\ninst✝³ : Ring R\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : NoZeroSMulDivisors R M\nc : R\nf : ι → M\n⊢ Eq (HSMul.hSMul c (finsum fun i => f i)) (finsum fun i => HSMul.hSMul c (f i))","decl":"/-- The `NoZeroSMulDivisors` makes sure that the result holds even when the support of `f` is\ninfinite. For a more usual version assuming `(support f).Finite` instead, see `smul_finsum'`. -/\ntheorem smul_finsum {R M : Type*} [Ring R] [AddCommGroup M] [Module R M] [NoZeroSMulDivisors R M]\n    (c : R) (f : ι → M) : (c • ∑ᶠ i, f i) = ∑ᶠ i, c • f i := by\n  rcases eq_or_ne c 0 with (rfl | hc)\n  · simp\n  · exact (smulAddHom R M c).map_finsum_of_injective (smul_right_injective M hc) _\n\n"}
{"name":"finprod_inv_distrib","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"G : Type u_1\nα : Sort u_4\ninst✝ : DivisionCommMonoid G\nf : α → G\n⊢ Eq (finprod fun x => Inv.inv (f x)) (Inv.inv (finprod fun x => f x))","decl":"@[to_additive]\ntheorem finprod_inv_distrib [DivisionCommMonoid G] (f : α → G) : (∏ᶠ x, (f x)⁻¹) = (∏ᶠ x, f x)⁻¹ :=\n  ((MulEquiv.inv G).map_finprod f).symm\n\n"}
{"name":"finsum_neg_distrib","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"G : Type u_1\nα : Sort u_4\ninst✝ : SubtractionCommMonoid G\nf : α → G\n⊢ Eq (finsum fun x => Neg.neg (f x)) (Neg.neg (finsum fun x => f x))","decl":"@[to_additive]\ntheorem finprod_inv_distrib [DivisionCommMonoid G] (f : α → G) : (∏ᶠ x, (f x)⁻¹) = (∏ᶠ x, f x)⁻¹ :=\n  ((MulEquiv.inv G).map_finprod f).symm\n\n"}
{"name":"finprod_eq_mulIndicator_apply","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : CommMonoid M\ns : Set α\nf : α → M\na : α\n⊢ Eq (finprod fun x => f a) (s.mulIndicator f a)","decl":"@[to_additive]\ntheorem finprod_eq_mulIndicator_apply (s : Set α) (f : α → M) (a : α) :\n    ∏ᶠ _ : a ∈ s, f a = mulIndicator s f a := by\n  classical convert finprod_eq_if (M := M) (p := a ∈ s) (x := f a)\n\n"}
{"name":"finsum_eq_indicator_apply","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : AddCommMonoid M\ns : Set α\nf : α → M\na : α\n⊢ Eq (finsum fun x => f a) (s.indicator f a)","decl":"@[to_additive]\ntheorem finprod_eq_mulIndicator_apply (s : Set α) (f : α → M) (a : α) :\n    ∏ᶠ _ : a ∈ s, f a = mulIndicator s f a := by\n  classical convert finprod_eq_if (M := M) (p := a ∈ s) (x := f a)\n\n"}
{"name":"finsum_apply_ne_zero","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : AddCommMonoid M\nf : α → M\na : α\n⊢ Eq (finsum fun x => f a) (f a)","decl":"@[to_additive (attr := simp)]\ntheorem finprod_apply_ne_one (f : α → M) (a : α) : ∏ᶠ _ : f a ≠ 1, f a = f a := by\n  rw [← mem_mulSupport, finprod_eq_mulIndicator_apply, mulIndicator_mulSupport]\n\n"}
{"name":"finprod_apply_ne_one","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : CommMonoid M\nf : α → M\na : α\n⊢ Eq (finprod fun x => f a) (f a)","decl":"@[to_additive (attr := simp)]\ntheorem finprod_apply_ne_one (f : α → M) (a : α) : ∏ᶠ _ : f a ≠ 1, f a = f a := by\n  rw [← mem_mulSupport, finprod_eq_mulIndicator_apply, mulIndicator_mulSupport]\n\n"}
{"name":"finprod_mem_def","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : CommMonoid M\ns : Set α\nf : α → M\n⊢ Eq (finprod fun a => finprod fun h => f a) (finprod fun a => s.mulIndicator f a)","decl":"@[to_additive]\ntheorem finprod_mem_def (s : Set α) (f : α → M) : ∏ᶠ a ∈ s, f a = ∏ᶠ a, mulIndicator s f a :=\n  finprod_congr <| finprod_eq_mulIndicator_apply s f\n\n"}
{"name":"finsum_mem_def","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : AddCommMonoid M\ns : Set α\nf : α → M\n⊢ Eq (finsum fun a => finsum fun h => f a) (finsum fun a => s.indicator f a)","decl":"@[to_additive]\ntheorem finprod_mem_def (s : Set α) (f : α → M) : ∏ᶠ a ∈ s, f a = ∏ᶠ a, mulIndicator s f a :=\n  finprod_congr <| finprod_eq_mulIndicator_apply s f\n\n"}
{"name":"finsum_mem_support","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : AddCommMonoid M\nf : α → M\n⊢ Eq (finsum fun a => finsum fun h => f a) (finsum fun a => f a)","decl":"@[to_additive]\nlemma finprod_mem_mulSupport (f : α → M) : ∏ᶠ a ∈ mulSupport f, f a = ∏ᶠ a, f a := by\n  rw [finprod_mem_def, mulIndicator_mulSupport]\n\n"}
{"name":"finprod_mem_mulSupport","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : CommMonoid M\nf : α → M\n⊢ Eq (finprod fun a => finprod fun h => f a) (finprod fun a => f a)","decl":"@[to_additive]\nlemma finprod_mem_mulSupport (f : α → M) : ∏ᶠ a ∈ mulSupport f, f a = ∏ᶠ a, f a := by\n  rw [finprod_mem_def, mulIndicator_mulSupport]\n\n"}
{"name":"finsum_eq_sum_of_support_subset","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : AddCommMonoid M\nf : α → M\ns : Finset α\nh : HasSubset.Subset (Function.support f) ↑s\n⊢ Eq (finsum fun i => f i) (s.sum fun i => f i)","decl":"@[to_additive]\ntheorem finprod_eq_prod_of_mulSupport_subset (f : α → M) {s : Finset α} (h : mulSupport f ⊆ s) :\n    ∏ᶠ i, f i = ∏ i ∈ s, f i := by\n  have A : mulSupport (f ∘ PLift.down) = Equiv.plift.symm '' mulSupport f := by\n    rw [mulSupport_comp_eq_preimage]\n    exact (Equiv.plift.symm.image_eq_preimage _).symm\n  have : mulSupport (f ∘ PLift.down) ⊆ s.map Equiv.plift.symm.toEmbedding := by\n    rw [A, Finset.coe_map]\n    exact image_subset _ h\n  rw [finprod_eq_prod_plift_of_mulSupport_subset this]\n  simp only [Finset.prod_map, Equiv.coe_toEmbedding]\n  congr\n\n"}
{"name":"finprod_eq_prod_of_mulSupport_subset","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : CommMonoid M\nf : α → M\ns : Finset α\nh : HasSubset.Subset (Function.mulSupport f) ↑s\n⊢ Eq (finprod fun i => f i) (s.prod fun i => f i)","decl":"@[to_additive]\ntheorem finprod_eq_prod_of_mulSupport_subset (f : α → M) {s : Finset α} (h : mulSupport f ⊆ s) :\n    ∏ᶠ i, f i = ∏ i ∈ s, f i := by\n  have A : mulSupport (f ∘ PLift.down) = Equiv.plift.symm '' mulSupport f := by\n    rw [mulSupport_comp_eq_preimage]\n    exact (Equiv.plift.symm.image_eq_preimage _).symm\n  have : mulSupport (f ∘ PLift.down) ⊆ s.map Equiv.plift.symm.toEmbedding := by\n    rw [A, Finset.coe_map]\n    exact image_subset _ h\n  rw [finprod_eq_prod_plift_of_mulSupport_subset this]\n  simp only [Finset.prod_map, Equiv.coe_toEmbedding]\n  congr\n\n"}
{"name":"finsum_eq_sum_of_support_toFinset_subset","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : AddCommMonoid M\nf : α → M\nhf : (Function.support f).Finite\ns : Finset α\nh : HasSubset.Subset hf.toFinset s\n⊢ Eq (finsum fun i => f i) (s.sum fun i => f i)","decl":"@[to_additive]\ntheorem finprod_eq_prod_of_mulSupport_toFinset_subset (f : α → M) (hf : (mulSupport f).Finite)\n    {s : Finset α} (h : hf.toFinset ⊆ s) : ∏ᶠ i, f i = ∏ i ∈ s, f i :=\n  finprod_eq_prod_of_mulSupport_subset _ fun _ hx => h <| hf.mem_toFinset.2 hx\n\n"}
{"name":"finprod_eq_prod_of_mulSupport_toFinset_subset","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : CommMonoid M\nf : α → M\nhf : (Function.mulSupport f).Finite\ns : Finset α\nh : HasSubset.Subset hf.toFinset s\n⊢ Eq (finprod fun i => f i) (s.prod fun i => f i)","decl":"@[to_additive]\ntheorem finprod_eq_prod_of_mulSupport_toFinset_subset (f : α → M) (hf : (mulSupport f).Finite)\n    {s : Finset α} (h : hf.toFinset ⊆ s) : ∏ᶠ i, f i = ∏ i ∈ s, f i :=\n  finprod_eq_prod_of_mulSupport_subset _ fun _ hx => h <| hf.mem_toFinset.2 hx\n\n"}
{"name":"finsum_eq_finset_sum_of_support_subset","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : AddCommMonoid M\nf : α → M\ns : Finset α\nh : HasSubset.Subset (Function.support f) ↑s\n⊢ Eq (finsum fun i => f i) (s.sum fun i => f i)","decl":"@[to_additive]\ntheorem finprod_eq_finset_prod_of_mulSupport_subset (f : α → M) {s : Finset α}\n    (h : mulSupport f ⊆ (s : Set α)) : ∏ᶠ i, f i = ∏ i ∈ s, f i :=\n  haveI h' : (s.finite_toSet.subset h).toFinset ⊆ s := by\n    simpa [← Finset.coe_subset, Set.coe_toFinset]\n  finprod_eq_prod_of_mulSupport_toFinset_subset _ _ h'\n\n"}
{"name":"finprod_eq_finset_prod_of_mulSupport_subset","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : CommMonoid M\nf : α → M\ns : Finset α\nh : HasSubset.Subset (Function.mulSupport f) ↑s\n⊢ Eq (finprod fun i => f i) (s.prod fun i => f i)","decl":"@[to_additive]\ntheorem finprod_eq_finset_prod_of_mulSupport_subset (f : α → M) {s : Finset α}\n    (h : mulSupport f ⊆ (s : Set α)) : ∏ᶠ i, f i = ∏ i ∈ s, f i :=\n  haveI h' : (s.finite_toSet.subset h).toFinset ⊆ s := by\n    simpa [← Finset.coe_subset, Set.coe_toFinset]\n  finprod_eq_prod_of_mulSupport_toFinset_subset _ _ h'\n\n"}
{"name":"finprod_def","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝¹ : CommMonoid M\nf : α → M\ninst✝ : Decidable (Function.mulSupport f).Finite\n⊢ Eq (finprod fun i => f i) (dite (Function.mulSupport f).Finite (fun h => h.toFinset.prod fun i => f i) fun h => 1)","decl":"@[to_additive]\ntheorem finprod_def (f : α → M) [Decidable (mulSupport f).Finite] :\n    ∏ᶠ i : α, f i = if h : (mulSupport f).Finite then ∏ i ∈ h.toFinset, f i else 1 := by\n  split_ifs with h\n  · exact finprod_eq_prod_of_mulSupport_toFinset_subset _ h (Finset.Subset.refl _)\n  · rw [finprod, dif_neg]\n    rw [mulSupport_comp_eq_preimage]\n    exact mt (fun hf => hf.of_preimage Equiv.plift.surjective) h\n\n"}
{"name":"finsum_def","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝¹ : AddCommMonoid M\nf : α → M\ninst✝ : Decidable (Function.support f).Finite\n⊢ Eq (finsum fun i => f i) (dite (Function.support f).Finite (fun h => h.toFinset.sum fun i => f i) fun h => 0)","decl":"@[to_additive]\ntheorem finprod_def (f : α → M) [Decidable (mulSupport f).Finite] :\n    ∏ᶠ i : α, f i = if h : (mulSupport f).Finite then ∏ i ∈ h.toFinset, f i else 1 := by\n  split_ifs with h\n  · exact finprod_eq_prod_of_mulSupport_toFinset_subset _ h (Finset.Subset.refl _)\n  · rw [finprod, dif_neg]\n    rw [mulSupport_comp_eq_preimage]\n    exact mt (fun hf => hf.of_preimage Equiv.plift.surjective) h\n\n"}
{"name":"finsum_of_infinite_support","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : AddCommMonoid M\nf : α → M\nhf : (Function.support f).Infinite\n⊢ Eq (finsum fun i => f i) 0","decl":"@[to_additive]\ntheorem finprod_of_infinite_mulSupport {f : α → M} (hf : (mulSupport f).Infinite) :\n    ∏ᶠ i, f i = 1 := by classical rw [finprod_def, dif_neg hf]\n\n"}
{"name":"finprod_of_infinite_mulSupport","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : CommMonoid M\nf : α → M\nhf : (Function.mulSupport f).Infinite\n⊢ Eq (finprod fun i => f i) 1","decl":"@[to_additive]\ntheorem finprod_of_infinite_mulSupport {f : α → M} (hf : (mulSupport f).Infinite) :\n    ∏ᶠ i, f i = 1 := by classical rw [finprod_def, dif_neg hf]\n\n"}
{"name":"finprod_eq_prod","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : CommMonoid M\nf : α → M\nhf : (Function.mulSupport f).Finite\n⊢ Eq (finprod fun i => f i) (hf.toFinset.prod fun i => f i)","decl":"@[to_additive]\ntheorem finprod_eq_prod (f : α → M) (hf : (mulSupport f).Finite) :\n    ∏ᶠ i : α, f i = ∏ i ∈ hf.toFinset, f i := by classical rw [finprod_def, dif_pos hf]\n\n"}
{"name":"finsum_eq_sum","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : AddCommMonoid M\nf : α → M\nhf : (Function.support f).Finite\n⊢ Eq (finsum fun i => f i) (hf.toFinset.sum fun i => f i)","decl":"@[to_additive]\ntheorem finprod_eq_prod (f : α → M) (hf : (mulSupport f).Finite) :\n    ∏ᶠ i : α, f i = ∏ i ∈ hf.toFinset, f i := by classical rw [finprod_def, dif_pos hf]\n\n"}
{"name":"finprod_eq_prod_of_fintype","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝¹ : CommMonoid M\ninst✝ : Fintype α\nf : α → M\n⊢ Eq (finprod fun i => f i) (Finset.univ.prod fun i => f i)","decl":"@[to_additive]\ntheorem finprod_eq_prod_of_fintype [Fintype α] (f : α → M) : ∏ᶠ i : α, f i = ∏ i, f i :=\n  finprod_eq_prod_of_mulSupport_toFinset_subset _ (Set.toFinite _) <| Finset.subset_univ _\n\n"}
{"name":"finsum_eq_sum_of_fintype","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝¹ : AddCommMonoid M\ninst✝ : Fintype α\nf : α → M\n⊢ Eq (finsum fun i => f i) (Finset.univ.sum fun i => f i)","decl":"@[to_additive]\ntheorem finprod_eq_prod_of_fintype [Fintype α] (f : α → M) : ∏ᶠ i : α, f i = ∏ i, f i :=\n  finprod_eq_prod_of_mulSupport_toFinset_subset _ (Set.toFinite _) <| Finset.subset_univ _\n\n"}
{"name":"finsum_cond_eq_sum_of_cond_iff","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : AddCommMonoid M\nf : α → M\np : α → Prop\nt : Finset α\nh : ∀ {x : α}, Ne (f x) 0 → Iff (p x) (Membership.mem t x)\n⊢ Eq (finsum fun i => finsum fun x => f i) (t.sum fun i => f i)","decl":"@[to_additive]\ntheorem finprod_cond_eq_prod_of_cond_iff (f : α → M) {p : α → Prop} {t : Finset α}\n    (h : ∀ {x}, f x ≠ 1 → (p x ↔ x ∈ t)) : (∏ᶠ (i) (_ : p i), f i) = ∏ i ∈ t, f i := by\n  set s := { x | p x }\n  change ∏ᶠ (i : α) (_ : i ∈ s), f i = ∏ i ∈ t, f i\n  have : mulSupport (s.mulIndicator f) ⊆ t := by\n    rw [Set.mulSupport_mulIndicator]\n    intro x hx\n    exact (h hx.2).1 hx.1\n  rw [finprod_mem_def, finprod_eq_prod_of_mulSupport_subset _ this]\n  refine Finset.prod_congr rfl fun x hx => mulIndicator_apply_eq_self.2 fun hxs => ?_\n  contrapose! hxs\n  exact (h hxs).2 hx\n\n"}
{"name":"finprod_cond_eq_prod_of_cond_iff","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : CommMonoid M\nf : α → M\np : α → Prop\nt : Finset α\nh : ∀ {x : α}, Ne (f x) 1 → Iff (p x) (Membership.mem t x)\n⊢ Eq (finprod fun i => finprod fun x => f i) (t.prod fun i => f i)","decl":"@[to_additive]\ntheorem finprod_cond_eq_prod_of_cond_iff (f : α → M) {p : α → Prop} {t : Finset α}\n    (h : ∀ {x}, f x ≠ 1 → (p x ↔ x ∈ t)) : (∏ᶠ (i) (_ : p i), f i) = ∏ i ∈ t, f i := by\n  set s := { x | p x }\n  change ∏ᶠ (i : α) (_ : i ∈ s), f i = ∏ i ∈ t, f i\n  have : mulSupport (s.mulIndicator f) ⊆ t := by\n    rw [Set.mulSupport_mulIndicator]\n    intro x hx\n    exact (h hx.2).1 hx.1\n  rw [finprod_mem_def, finprod_eq_prod_of_mulSupport_subset _ this]\n  refine Finset.prod_congr rfl fun x hx => mulIndicator_apply_eq_self.2 fun hxs => ?_\n  contrapose! hxs\n  exact (h hxs).2 hx\n\n"}
{"name":"finsum_cond_ne","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝¹ : AddCommMonoid M\nf : α → M\na : α\ninst✝ : DecidableEq α\nhf : (Function.support f).Finite\n⊢ Eq (finsum fun i => finsum fun x => f i) ((hf.toFinset.erase a).sum fun i => f i)","decl":"@[to_additive]\ntheorem finprod_cond_ne (f : α → M) (a : α) [DecidableEq α] (hf : (mulSupport f).Finite) :\n    (∏ᶠ (i) (_ : i ≠ a), f i) = ∏ i ∈ hf.toFinset.erase a, f i := by\n  apply finprod_cond_eq_prod_of_cond_iff\n  intro x hx\n  rw [Finset.mem_erase, Finite.mem_toFinset, mem_mulSupport]\n  exact ⟨fun h => And.intro h hx, fun h => h.1⟩\n\n"}
{"name":"finprod_cond_ne","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝¹ : CommMonoid M\nf : α → M\na : α\ninst✝ : DecidableEq α\nhf : (Function.mulSupport f).Finite\n⊢ Eq (finprod fun i => finprod fun x => f i) ((hf.toFinset.erase a).prod fun i => f i)","decl":"@[to_additive]\ntheorem finprod_cond_ne (f : α → M) (a : α) [DecidableEq α] (hf : (mulSupport f).Finite) :\n    (∏ᶠ (i) (_ : i ≠ a), f i) = ∏ i ∈ hf.toFinset.erase a, f i := by\n  apply finprod_cond_eq_prod_of_cond_iff\n  intro x hx\n  rw [Finset.mem_erase, Finite.mem_toFinset, mem_mulSupport]\n  exact ⟨fun h => And.intro h hx, fun h => h.1⟩\n\n"}
{"name":"finsum_mem_eq_sum_of_inter_support_eq","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : AddCommMonoid M\nf : α → M\ns : Set α\nt : Finset α\nh : Eq (Inter.inter s (Function.support f)) (Inter.inter (↑t) (Function.support f))\n⊢ Eq (finsum fun i => finsum fun h => f i) (t.sum fun i => f i)","decl":"@[to_additive]\ntheorem finprod_mem_eq_prod_of_inter_mulSupport_eq (f : α → M) {s : Set α} {t : Finset α}\n    (h : s ∩ mulSupport f = t.toSet ∩ mulSupport f) : ∏ᶠ i ∈ s, f i = ∏ i ∈ t, f i :=\n  finprod_cond_eq_prod_of_cond_iff _ <| by\n    intro x hxf\n    rw [← mem_mulSupport] at hxf\n    refine ⟨fun hx => ?_, fun hx => ?_⟩\n    · refine ((mem_inter_iff x t (mulSupport f)).mp ?_).1\n      rw [← Set.ext_iff.mp h x, mem_inter_iff]\n      exact ⟨hx, hxf⟩\n    · refine ((mem_inter_iff x s (mulSupport f)).mp ?_).1\n      rw [Set.ext_iff.mp h x, mem_inter_iff]\n      exact ⟨hx, hxf⟩\n\n"}
{"name":"finprod_mem_eq_prod_of_inter_mulSupport_eq","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : CommMonoid M\nf : α → M\ns : Set α\nt : Finset α\nh : Eq (Inter.inter s (Function.mulSupport f)) (Inter.inter (↑t) (Function.mulSupport f))\n⊢ Eq (finprod fun i => finprod fun h => f i) (t.prod fun i => f i)","decl":"@[to_additive]\ntheorem finprod_mem_eq_prod_of_inter_mulSupport_eq (f : α → M) {s : Set α} {t : Finset α}\n    (h : s ∩ mulSupport f = t.toSet ∩ mulSupport f) : ∏ᶠ i ∈ s, f i = ∏ i ∈ t, f i :=\n  finprod_cond_eq_prod_of_cond_iff _ <| by\n    intro x hxf\n    rw [← mem_mulSupport] at hxf\n    refine ⟨fun hx => ?_, fun hx => ?_⟩\n    · refine ((mem_inter_iff x t (mulSupport f)).mp ?_).1\n      rw [← Set.ext_iff.mp h x, mem_inter_iff]\n      exact ⟨hx, hxf⟩\n    · refine ((mem_inter_iff x s (mulSupport f)).mp ?_).1\n      rw [Set.ext_iff.mp h x, mem_inter_iff]\n      exact ⟨hx, hxf⟩\n\n"}
{"name":"finprod_mem_eq_prod_of_subset","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : CommMonoid M\nf : α → M\ns : Set α\nt : Finset α\nh₁ : HasSubset.Subset (Inter.inter s (Function.mulSupport f)) ↑t\nh₂ : HasSubset.Subset (↑t) s\n⊢ Eq (finprod fun i => finprod fun h => f i) (t.prod fun i => f i)","decl":"@[to_additive]\ntheorem finprod_mem_eq_prod_of_subset (f : α → M) {s : Set α} {t : Finset α}\n    (h₁ : s ∩ mulSupport f ⊆ t) (h₂ : ↑t ⊆ s) : ∏ᶠ i ∈ s, f i = ∏ i ∈ t, f i :=\n  finprod_cond_eq_prod_of_cond_iff _ fun hx => ⟨fun h => h₁ ⟨h, hx⟩, fun h => h₂ h⟩\n\n"}
{"name":"finsum_mem_eq_sum_of_subset","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : AddCommMonoid M\nf : α → M\ns : Set α\nt : Finset α\nh₁ : HasSubset.Subset (Inter.inter s (Function.support f)) ↑t\nh₂ : HasSubset.Subset (↑t) s\n⊢ Eq (finsum fun i => finsum fun h => f i) (t.sum fun i => f i)","decl":"@[to_additive]\ntheorem finprod_mem_eq_prod_of_subset (f : α → M) {s : Set α} {t : Finset α}\n    (h₁ : s ∩ mulSupport f ⊆ t) (h₂ : ↑t ⊆ s) : ∏ᶠ i ∈ s, f i = ∏ i ∈ t, f i :=\n  finprod_cond_eq_prod_of_cond_iff _ fun hx => ⟨fun h => h₁ ⟨h, hx⟩, fun h => h₂ h⟩\n\n"}
{"name":"finsum_mem_eq_sum","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : AddCommMonoid M\nf : α → M\ns : Set α\nhf : (Inter.inter s (Function.support f)).Finite\n⊢ Eq (finsum fun i => finsum fun h => f i) (hf.toFinset.sum fun i => f i)","decl":"@[to_additive]\ntheorem finprod_mem_eq_prod (f : α → M) {s : Set α} (hf : (s ∩ mulSupport f).Finite) :\n    ∏ᶠ i ∈ s, f i = ∏ i ∈ hf.toFinset, f i :=\n  finprod_mem_eq_prod_of_inter_mulSupport_eq _ <| by simp [inter_assoc]\n\n"}
{"name":"finprod_mem_eq_prod","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : CommMonoid M\nf : α → M\ns : Set α\nhf : (Inter.inter s (Function.mulSupport f)).Finite\n⊢ Eq (finprod fun i => finprod fun h => f i) (hf.toFinset.prod fun i => f i)","decl":"@[to_additive]\ntheorem finprod_mem_eq_prod (f : α → M) {s : Set α} (hf : (s ∩ mulSupport f).Finite) :\n    ∏ᶠ i ∈ s, f i = ∏ i ∈ hf.toFinset, f i :=\n  finprod_mem_eq_prod_of_inter_mulSupport_eq _ <| by simp [inter_assoc]\n\n"}
{"name":"finsum_mem_eq_sum_filter","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝¹ : AddCommMonoid M\nf : α → M\ns : Set α\ninst✝ : DecidablePred fun x => Membership.mem s x\nhf : (Function.support f).Finite\n⊢ Eq (finsum fun i => finsum fun h => f i) ((Finset.filter (fun x => Membership.mem s x) hf.toFinset).sum fun i => f i)","decl":"@[to_additive]\ntheorem finprod_mem_eq_prod_filter (f : α → M) (s : Set α) [DecidablePred (· ∈ s)]\n    (hf : (mulSupport f).Finite) :\n    ∏ᶠ i ∈ s, f i = ∏ i ∈ Finset.filter (· ∈ s) hf.toFinset, f i :=\n  finprod_mem_eq_prod_of_inter_mulSupport_eq _ <| by\n    ext x\n    simp [and_comm]\n\n"}
{"name":"finprod_mem_eq_prod_filter","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝¹ : CommMonoid M\nf : α → M\ns : Set α\ninst✝ : DecidablePred fun x => Membership.mem s x\nhf : (Function.mulSupport f).Finite\n⊢ Eq (finprod fun i => finprod fun h => f i) ((Finset.filter (fun x => Membership.mem s x) hf.toFinset).prod fun i => f i)","decl":"@[to_additive]\ntheorem finprod_mem_eq_prod_filter (f : α → M) (s : Set α) [DecidablePred (· ∈ s)]\n    (hf : (mulSupport f).Finite) :\n    ∏ᶠ i ∈ s, f i = ∏ i ∈ Finset.filter (· ∈ s) hf.toFinset, f i :=\n  finprod_mem_eq_prod_of_inter_mulSupport_eq _ <| by\n    ext x\n    simp [and_comm]\n\n"}
{"name":"finsum_mem_eq_toFinset_sum","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝¹ : AddCommMonoid M\nf : α → M\ns : Set α\ninst✝ : Fintype ↑s\n⊢ Eq (finsum fun i => finsum fun h => f i) (s.toFinset.sum fun i => f i)","decl":"@[to_additive]\ntheorem finprod_mem_eq_toFinset_prod (f : α → M) (s : Set α) [Fintype s] :\n    ∏ᶠ i ∈ s, f i = ∏ i ∈ s.toFinset, f i :=\n  finprod_mem_eq_prod_of_inter_mulSupport_eq _ <| by simp_rw [coe_toFinset s]\n\n"}
{"name":"finprod_mem_eq_toFinset_prod","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝¹ : CommMonoid M\nf : α → M\ns : Set α\ninst✝ : Fintype ↑s\n⊢ Eq (finprod fun i => finprod fun h => f i) (s.toFinset.prod fun i => f i)","decl":"@[to_additive]\ntheorem finprod_mem_eq_toFinset_prod (f : α → M) (s : Set α) [Fintype s] :\n    ∏ᶠ i ∈ s, f i = ∏ i ∈ s.toFinset, f i :=\n  finprod_mem_eq_prod_of_inter_mulSupport_eq _ <| by simp_rw [coe_toFinset s]\n\n"}
{"name":"finsum_mem_eq_finite_toFinset_sum","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : AddCommMonoid M\nf : α → M\ns : Set α\nhs : s.Finite\n⊢ Eq (finsum fun i => finsum fun h => f i) (hs.toFinset.sum fun i => f i)","decl":"@[to_additive]\ntheorem finprod_mem_eq_finite_toFinset_prod (f : α → M) {s : Set α} (hs : s.Finite) :\n    ∏ᶠ i ∈ s, f i = ∏ i ∈ hs.toFinset, f i :=\n  finprod_mem_eq_prod_of_inter_mulSupport_eq _ <| by rw [hs.coe_toFinset]\n\n"}
{"name":"finprod_mem_eq_finite_toFinset_prod","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : CommMonoid M\nf : α → M\ns : Set α\nhs : s.Finite\n⊢ Eq (finprod fun i => finprod fun h => f i) (hs.toFinset.prod fun i => f i)","decl":"@[to_additive]\ntheorem finprod_mem_eq_finite_toFinset_prod (f : α → M) {s : Set α} (hs : s.Finite) :\n    ∏ᶠ i ∈ s, f i = ∏ i ∈ hs.toFinset, f i :=\n  finprod_mem_eq_prod_of_inter_mulSupport_eq _ <| by rw [hs.coe_toFinset]\n\n"}
{"name":"finprod_mem_finset_eq_prod","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : CommMonoid M\nf : α → M\ns : Finset α\n⊢ Eq (finprod fun i => finprod fun h => f i) (s.prod fun i => f i)","decl":"@[to_additive]\ntheorem finprod_mem_finset_eq_prod (f : α → M) (s : Finset α) : ∏ᶠ i ∈ s, f i = ∏ i ∈ s, f i :=\n  finprod_mem_eq_prod_of_inter_mulSupport_eq _ rfl\n\n"}
{"name":"finsum_mem_finset_eq_sum","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : AddCommMonoid M\nf : α → M\ns : Finset α\n⊢ Eq (finsum fun i => finsum fun h => f i) (s.sum fun i => f i)","decl":"@[to_additive]\ntheorem finprod_mem_finset_eq_prod (f : α → M) (s : Finset α) : ∏ᶠ i ∈ s, f i = ∏ i ∈ s, f i :=\n  finprod_mem_eq_prod_of_inter_mulSupport_eq _ rfl\n\n"}
{"name":"finsum_mem_coe_finset","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : AddCommMonoid M\nf : α → M\ns : Finset α\n⊢ Eq (finsum fun i => finsum fun h => f i) (s.sum fun i => f i)","decl":"@[to_additive]\ntheorem finprod_mem_coe_finset (f : α → M) (s : Finset α) :\n    (∏ᶠ i ∈ (s : Set α), f i) = ∏ i ∈ s, f i :=\n  finprod_mem_eq_prod_of_inter_mulSupport_eq _ rfl\n\n"}
{"name":"finprod_mem_coe_finset","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : CommMonoid M\nf : α → M\ns : Finset α\n⊢ Eq (finprod fun i => finprod fun h => f i) (s.prod fun i => f i)","decl":"@[to_additive]\ntheorem finprod_mem_coe_finset (f : α → M) (s : Finset α) :\n    (∏ᶠ i ∈ (s : Set α), f i) = ∏ i ∈ s, f i :=\n  finprod_mem_eq_prod_of_inter_mulSupport_eq _ rfl\n\n"}
{"name":"finprod_mem_eq_one_of_infinite","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : CommMonoid M\nf : α → M\ns : Set α\nhs : (Inter.inter s (Function.mulSupport f)).Infinite\n⊢ Eq (finprod fun i => finprod fun h => f i) 1","decl":"@[to_additive]\ntheorem finprod_mem_eq_one_of_infinite {f : α → M} {s : Set α} (hs : (s ∩ mulSupport f).Infinite) :\n    ∏ᶠ i ∈ s, f i = 1 := by\n  rw [finprod_mem_def]\n  apply finprod_of_infinite_mulSupport\n  rwa [← mulSupport_mulIndicator] at hs\n\n"}
{"name":"finsum_mem_eq_zero_of_infinite","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : AddCommMonoid M\nf : α → M\ns : Set α\nhs : (Inter.inter s (Function.support f)).Infinite\n⊢ Eq (finsum fun i => finsum fun h => f i) 0","decl":"@[to_additive]\ntheorem finprod_mem_eq_one_of_infinite {f : α → M} {s : Set α} (hs : (s ∩ mulSupport f).Infinite) :\n    ∏ᶠ i ∈ s, f i = 1 := by\n  rw [finprod_mem_def]\n  apply finprod_of_infinite_mulSupport\n  rwa [← mulSupport_mulIndicator] at hs\n\n"}
{"name":"finsum_mem_eq_zero_of_forall_eq_zero","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : AddCommMonoid M\nf : α → M\ns : Set α\nh : ∀ (x : α), Membership.mem s x → Eq (f x) 0\n⊢ Eq (finsum fun i => finsum fun h => f i) 0","decl":"@[to_additive]\ntheorem finprod_mem_eq_one_of_forall_eq_one {f : α → M} {s : Set α} (h : ∀ x ∈ s, f x = 1) :\n    ∏ᶠ i ∈ s, f i = 1 := by simp +contextual [h]\n\n"}
{"name":"finprod_mem_eq_one_of_forall_eq_one","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : CommMonoid M\nf : α → M\ns : Set α\nh : ∀ (x : α), Membership.mem s x → Eq (f x) 1\n⊢ Eq (finprod fun i => finprod fun h => f i) 1","decl":"@[to_additive]\ntheorem finprod_mem_eq_one_of_forall_eq_one {f : α → M} {s : Set α} (h : ∀ x ∈ s, f x = 1) :\n    ∏ᶠ i ∈ s, f i = 1 := by simp +contextual [h]\n\n"}
{"name":"finsum_mem_inter_support","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : AddCommMonoid M\nf : α → M\ns : Set α\n⊢ Eq (finsum fun i => finsum fun h => f i) (finsum fun i => finsum fun h => f i)","decl":"@[to_additive]\ntheorem finprod_mem_inter_mulSupport (f : α → M) (s : Set α) :\n    ∏ᶠ i ∈ s ∩ mulSupport f, f i = ∏ᶠ i ∈ s, f i := by\n  rw [finprod_mem_def, finprod_mem_def, mulIndicator_inter_mulSupport]\n\n"}
{"name":"finprod_mem_inter_mulSupport","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : CommMonoid M\nf : α → M\ns : Set α\n⊢ Eq (finprod fun i => finprod fun h => f i) (finprod fun i => finprod fun h => f i)","decl":"@[to_additive]\ntheorem finprod_mem_inter_mulSupport (f : α → M) (s : Set α) :\n    ∏ᶠ i ∈ s ∩ mulSupport f, f i = ∏ᶠ i ∈ s, f i := by\n  rw [finprod_mem_def, finprod_mem_def, mulIndicator_inter_mulSupport]\n\n"}
{"name":"finsum_mem_inter_support_eq","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : AddCommMonoid M\nf : α → M\ns t : Set α\nh : Eq (Inter.inter s (Function.support f)) (Inter.inter t (Function.support f))\n⊢ Eq (finsum fun i => finsum fun h => f i) (finsum fun i => finsum fun h => f i)","decl":"@[to_additive]\ntheorem finprod_mem_inter_mulSupport_eq (f : α → M) (s t : Set α)\n    (h : s ∩ mulSupport f = t ∩ mulSupport f) : ∏ᶠ i ∈ s, f i = ∏ᶠ i ∈ t, f i := by\n  rw [← finprod_mem_inter_mulSupport, h, finprod_mem_inter_mulSupport]\n\n"}
{"name":"finprod_mem_inter_mulSupport_eq","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : CommMonoid M\nf : α → M\ns t : Set α\nh : Eq (Inter.inter s (Function.mulSupport f)) (Inter.inter t (Function.mulSupport f))\n⊢ Eq (finprod fun i => finprod fun h => f i) (finprod fun i => finprod fun h => f i)","decl":"@[to_additive]\ntheorem finprod_mem_inter_mulSupport_eq (f : α → M) (s t : Set α)\n    (h : s ∩ mulSupport f = t ∩ mulSupport f) : ∏ᶠ i ∈ s, f i = ∏ᶠ i ∈ t, f i := by\n  rw [← finprod_mem_inter_mulSupport, h, finprod_mem_inter_mulSupport]\n\n"}
{"name":"finsum_mem_inter_support_eq'","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : AddCommMonoid M\nf : α → M\ns t : Set α\nh : ∀ (x : α), Membership.mem (Function.support f) x → Iff (Membership.mem s x) (Membership.mem t x)\n⊢ Eq (finsum fun i => finsum fun h => f i) (finsum fun i => finsum fun h => f i)","decl":"@[to_additive]\ntheorem finprod_mem_inter_mulSupport_eq' (f : α → M) (s t : Set α)\n    (h : ∀ x ∈ mulSupport f, x ∈ s ↔ x ∈ t) : ∏ᶠ i ∈ s, f i = ∏ᶠ i ∈ t, f i := by\n  apply finprod_mem_inter_mulSupport_eq\n  ext x\n  exact and_congr_left (h x)\n\n"}
{"name":"finprod_mem_inter_mulSupport_eq'","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : CommMonoid M\nf : α → M\ns t : Set α\nh : ∀ (x : α), Membership.mem (Function.mulSupport f) x → Iff (Membership.mem s x) (Membership.mem t x)\n⊢ Eq (finprod fun i => finprod fun h => f i) (finprod fun i => finprod fun h => f i)","decl":"@[to_additive]\ntheorem finprod_mem_inter_mulSupport_eq' (f : α → M) (s t : Set α)\n    (h : ∀ x ∈ mulSupport f, x ∈ s ↔ x ∈ t) : ∏ᶠ i ∈ s, f i = ∏ᶠ i ∈ t, f i := by\n  apply finprod_mem_inter_mulSupport_eq\n  ext x\n  exact and_congr_left (h x)\n\n"}
{"name":"finprod_mem_univ","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : CommMonoid M\nf : α → M\n⊢ Eq (finprod fun i => finprod fun h => f i) (finprod fun i => f i)","decl":"@[to_additive]\ntheorem finprod_mem_univ (f : α → M) : ∏ᶠ i ∈ @Set.univ α, f i = ∏ᶠ i : α, f i :=\n  finprod_congr fun _ => finprod_true _\n\n"}
{"name":"finsum_mem_univ","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : AddCommMonoid M\nf : α → M\n⊢ Eq (finsum fun i => finsum fun h => f i) (finsum fun i => f i)","decl":"@[to_additive]\ntheorem finprod_mem_univ (f : α → M) : ∏ᶠ i ∈ @Set.univ α, f i = ∏ᶠ i : α, f i :=\n  finprod_congr fun _ => finprod_true _\n\n"}
{"name":"finsum_mem_congr","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : AddCommMonoid M\nf g : α → M\ns t : Set α\nh₀ : Eq s t\nh₁ : ∀ (x : α), Membership.mem t x → Eq (f x) (g x)\n⊢ Eq (finsum fun i => finsum fun h => f i) (finsum fun i => finsum fun h => g i)","decl":"@[to_additive]\ntheorem finprod_mem_congr (h₀ : s = t) (h₁ : ∀ x ∈ t, f x = g x) :\n    ∏ᶠ i ∈ s, f i = ∏ᶠ i ∈ t, g i :=\n  h₀.symm ▸ finprod_congr fun i => finprod_congr_Prop rfl (h₁ i)\n\n"}
{"name":"finprod_mem_congr","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : CommMonoid M\nf g : α → M\ns t : Set α\nh₀ : Eq s t\nh₁ : ∀ (x : α), Membership.mem t x → Eq (f x) (g x)\n⊢ Eq (finprod fun i => finprod fun h => f i) (finprod fun i => finprod fun h => g i)","decl":"@[to_additive]\ntheorem finprod_mem_congr (h₀ : s = t) (h₁ : ∀ x ∈ t, f x = g x) :\n    ∏ᶠ i ∈ s, f i = ∏ᶠ i ∈ t, g i :=\n  h₀.symm ▸ finprod_congr fun i => finprod_congr_Prop rfl (h₁ i)\n\n"}
{"name":"finsum_eq_zero_of_forall_eq_zero","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : AddCommMonoid M\nf : α → M\nh : ∀ (x : α), Eq (f x) 0\n⊢ Eq (finsum fun i => f i) 0","decl":"@[to_additive]\ntheorem finprod_eq_one_of_forall_eq_one {f : α → M} (h : ∀ x, f x = 1) : ∏ᶠ i, f i = 1 := by\n  simp +contextual [h]\n\n"}
{"name":"finprod_eq_one_of_forall_eq_one","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : CommMonoid M\nf : α → M\nh : ∀ (x : α), Eq (f x) 1\n⊢ Eq (finprod fun i => f i) 1","decl":"@[to_additive]\ntheorem finprod_eq_one_of_forall_eq_one {f : α → M} (h : ∀ x, f x = 1) : ∏ᶠ i, f i = 1 := by\n  simp +contextual [h]\n\n"}
{"name":"one_lt_finprod'","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"ι : Type u_3\nM : Type u_7\ninst✝ : OrderedCancelCommMonoid M\nf : ι → M\nh : ∀ (i : ι), LE.le 1 (f i)\nh' : Exists fun i => LT.lt 1 (f i)\nhf : (Function.mulSupport f).Finite\n⊢ LT.lt 1 (finprod fun i => f i)","decl":"@[to_additive finsum_pos']\ntheorem one_lt_finprod' {M : Type*} [OrderedCancelCommMonoid M] {f : ι → M}\n    (h : ∀ i, 1 ≤ f i) (h' : ∃ i, 1 < f i) (hf : (mulSupport f).Finite) : 1 < ∏ᶠ i, f i := by\n  rcases h' with ⟨i, hi⟩\n  rw [finprod_eq_prod _ hf]\n  refine Finset.one_lt_prod' (fun i _ ↦ h i) ⟨i, ?_, hi⟩\n  simpa only [Finite.mem_toFinset, mem_mulSupport] using ne_of_gt hi\n\n"}
{"name":"finsum_pos'","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"ι : Type u_3\nM : Type u_7\ninst✝ : OrderedCancelAddCommMonoid M\nf : ι → M\nh : ∀ (i : ι), LE.le 0 (f i)\nh' : Exists fun i => LT.lt 0 (f i)\nhf : (Function.support f).Finite\n⊢ LT.lt 0 (finsum fun i => f i)","decl":"@[to_additive finsum_pos']\ntheorem one_lt_finprod' {M : Type*} [OrderedCancelCommMonoid M] {f : ι → M}\n    (h : ∀ i, 1 ≤ f i) (h' : ∃ i, 1 < f i) (hf : (mulSupport f).Finite) : 1 < ∏ᶠ i, f i := by\n  rcases h' with ⟨i, hi⟩\n  rw [finprod_eq_prod _ hf]\n  refine Finset.one_lt_prod' (fun i _ ↦ h i) ⟨i, ?_, hi⟩\n  simpa only [Finite.mem_toFinset, mem_mulSupport] using ne_of_gt hi\n\n"}
{"name":"finprod_mul_distrib","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : CommMonoid M\nf g : α → M\nhf : (Function.mulSupport f).Finite\nhg : (Function.mulSupport g).Finite\n⊢ Eq (finprod fun i => HMul.hMul (f i) (g i)) (HMul.hMul (finprod fun i => f i) (finprod fun i => g i))","decl":"/-- If the multiplicative supports of `f` and `g` are finite, then the product of `f i * g i` equals\nthe product of `f i` multiplied by the product of `g i`. -/\n@[to_additive\n      \"If the additive supports of `f` and `g` are finite, then the sum of `f i + g i`\n      equals the sum of `f i` plus the sum of `g i`.\"]\ntheorem finprod_mul_distrib (hf : (mulSupport f).Finite) (hg : (mulSupport g).Finite) :\n    ∏ᶠ i, f i * g i = (∏ᶠ i, f i) * ∏ᶠ i, g i := by\n  classical\n    rw [finprod_eq_prod_of_mulSupport_toFinset_subset f hf Finset.subset_union_left,\n      finprod_eq_prod_of_mulSupport_toFinset_subset g hg Finset.subset_union_right, ←\n      Finset.prod_mul_distrib]\n    refine finprod_eq_prod_of_mulSupport_subset _ ?_\n    simp only [Finset.coe_union, Finite.coe_toFinset, mulSupport_subset_iff,\n      mem_union, mem_mulSupport]\n    intro x\n    contrapose!\n    rintro ⟨hf, hg⟩\n    simp [hf, hg]\n\n"}
{"name":"finsum_add_distrib","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : AddCommMonoid M\nf g : α → M\nhf : (Function.support f).Finite\nhg : (Function.support g).Finite\n⊢ Eq (finsum fun i => HAdd.hAdd (f i) (g i)) (HAdd.hAdd (finsum fun i => f i) (finsum fun i => g i))","decl":"/-- If the multiplicative supports of `f` and `g` are finite, then the product of `f i * g i` equals\nthe product of `f i` multiplied by the product of `g i`. -/\n@[to_additive\n      \"If the additive supports of `f` and `g` are finite, then the sum of `f i + g i`\n      equals the sum of `f i` plus the sum of `g i`.\"]\ntheorem finprod_mul_distrib (hf : (mulSupport f).Finite) (hg : (mulSupport g).Finite) :\n    ∏ᶠ i, f i * g i = (∏ᶠ i, f i) * ∏ᶠ i, g i := by\n  classical\n    rw [finprod_eq_prod_of_mulSupport_toFinset_subset f hf Finset.subset_union_left,\n      finprod_eq_prod_of_mulSupport_toFinset_subset g hg Finset.subset_union_right, ←\n      Finset.prod_mul_distrib]\n    refine finprod_eq_prod_of_mulSupport_subset _ ?_\n    simp only [Finset.coe_union, Finite.coe_toFinset, mulSupport_subset_iff,\n      mem_union, mem_mulSupport]\n    intro x\n    contrapose!\n    rintro ⟨hf, hg⟩\n    simp [hf, hg]\n\n"}
{"name":"finprod_div_distrib","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nG : Type u_4\ninst✝ : DivisionCommMonoid G\nf g : α → G\nhf : (Function.mulSupport f).Finite\nhg : (Function.mulSupport g).Finite\n⊢ Eq (finprod fun i => HDiv.hDiv (f i) (g i)) (HDiv.hDiv (finprod fun i => f i) (finprod fun i => g i))","decl":"/-- If the multiplicative supports of `f` and `g` are finite, then the product of `f i / g i`\nequals the product of `f i` divided by the product of `g i`. -/\n@[to_additive\n      \"If the additive supports of `f` and `g` are finite, then the sum of `f i - g i`\n      equals the sum of `f i` minus the sum of `g i`.\"]\ntheorem finprod_div_distrib [DivisionCommMonoid G] {f g : α → G} (hf : (mulSupport f).Finite)\n    (hg : (mulSupport g).Finite) : ∏ᶠ i, f i / g i = (∏ᶠ i, f i) / ∏ᶠ i, g i := by\n  simp only [div_eq_mul_inv, finprod_mul_distrib hf ((mulSupport_inv g).symm.rec hg),\n    finprod_inv_distrib]\n\n"}
{"name":"finsum_sub_distrib","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nG : Type u_4\ninst✝ : SubtractionCommMonoid G\nf g : α → G\nhf : (Function.support f).Finite\nhg : (Function.support g).Finite\n⊢ Eq (finsum fun i => HSub.hSub (f i) (g i)) (HSub.hSub (finsum fun i => f i) (finsum fun i => g i))","decl":"/-- If the multiplicative supports of `f` and `g` are finite, then the product of `f i / g i`\nequals the product of `f i` divided by the product of `g i`. -/\n@[to_additive\n      \"If the additive supports of `f` and `g` are finite, then the sum of `f i - g i`\n      equals the sum of `f i` minus the sum of `g i`.\"]\ntheorem finprod_div_distrib [DivisionCommMonoid G] {f g : α → G} (hf : (mulSupport f).Finite)\n    (hg : (mulSupport g).Finite) : ∏ᶠ i, f i / g i = (∏ᶠ i, f i) / ∏ᶠ i, g i := by\n  simp only [div_eq_mul_inv, finprod_mul_distrib hf ((mulSupport_inv g).symm.rec hg),\n    finprod_inv_distrib]\n\n"}
{"name":"finprod_mem_mul_distrib'","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : CommMonoid M\nf g : α → M\ns : Set α\nhf : (Inter.inter s (Function.mulSupport f)).Finite\nhg : (Inter.inter s (Function.mulSupport g)).Finite\n⊢ Eq (finprod fun i => finprod fun h => HMul.hMul (f i) (g i)) (HMul.hMul (finprod fun i => finprod fun h => f i) (finprod fun i => finprod fun h => g i))","decl":"/-- A more general version of `finprod_mem_mul_distrib` that only requires `s ∩ mulSupport f` and\n`s ∩ mulSupport g` rather than `s` to be finite. -/\n@[to_additive\n      \"A more general version of `finsum_mem_add_distrib` that only requires `s ∩ support f`\n      and `s ∩ support g` rather than `s` to be finite.\"]\ntheorem finprod_mem_mul_distrib' (hf : (s ∩ mulSupport f).Finite) (hg : (s ∩ mulSupport g).Finite) :\n    ∏ᶠ i ∈ s, f i * g i = (∏ᶠ i ∈ s, f i) * ∏ᶠ i ∈ s, g i := by\n  rw [← mulSupport_mulIndicator] at hf hg\n  simp only [finprod_mem_def, mulIndicator_mul, finprod_mul_distrib hf hg]\n\n"}
{"name":"finsum_mem_add_distrib'","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : AddCommMonoid M\nf g : α → M\ns : Set α\nhf : (Inter.inter s (Function.support f)).Finite\nhg : (Inter.inter s (Function.support g)).Finite\n⊢ Eq (finsum fun i => finsum fun h => HAdd.hAdd (f i) (g i)) (HAdd.hAdd (finsum fun i => finsum fun h => f i) (finsum fun i => finsum fun h => g i))","decl":"/-- A more general version of `finprod_mem_mul_distrib` that only requires `s ∩ mulSupport f` and\n`s ∩ mulSupport g` rather than `s` to be finite. -/\n@[to_additive\n      \"A more general version of `finsum_mem_add_distrib` that only requires `s ∩ support f`\n      and `s ∩ support g` rather than `s` to be finite.\"]\ntheorem finprod_mem_mul_distrib' (hf : (s ∩ mulSupport f).Finite) (hg : (s ∩ mulSupport g).Finite) :\n    ∏ᶠ i ∈ s, f i * g i = (∏ᶠ i ∈ s, f i) * ∏ᶠ i ∈ s, g i := by\n  rw [← mulSupport_mulIndicator] at hf hg\n  simp only [finprod_mem_def, mulIndicator_mul, finprod_mul_distrib hf hg]\n\n"}
{"name":"finsum_mem_zero","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : AddCommMonoid M\ns : Set α\n⊢ Eq (finsum fun i => finsum fun h => 0) 0","decl":"/-- The product of the constant function `1` over any set equals `1`. -/\n@[to_additive \"The sum of the constant function `0` over any set equals `0`.\"]\ntheorem finprod_mem_one (s : Set α) : (∏ᶠ i ∈ s, (1 : M)) = 1 := by simp\n\n"}
{"name":"finprod_mem_one","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : CommMonoid M\ns : Set α\n⊢ Eq (finprod fun i => finprod fun h => 1) 1","decl":"/-- The product of the constant function `1` over any set equals `1`. -/\n@[to_additive \"The sum of the constant function `0` over any set equals `0`.\"]\ntheorem finprod_mem_one (s : Set α) : (∏ᶠ i ∈ s, (1 : M)) = 1 := by simp\n\n"}
{"name":"finprod_mem_of_eqOn_one","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : CommMonoid M\nf : α → M\ns : Set α\nhf : Set.EqOn f 1 s\n⊢ Eq (finprod fun i => finprod fun h => f i) 1","decl":"/-- If a function `f` equals `1` on a set `s`, then the product of `f i` over `i ∈ s` equals `1`. -/\n@[to_additive\n      \"If a function `f` equals `0` on a set `s`, then the product of `f i` over `i ∈ s`\n      equals `0`.\"]\ntheorem finprod_mem_of_eqOn_one (hf : s.EqOn f 1) : ∏ᶠ i ∈ s, f i = 1 := by\n  rw [← finprod_mem_one s]\n  exact finprod_mem_congr rfl hf\n\n"}
{"name":"finsum_mem_of_eqOn_zero","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : AddCommMonoid M\nf : α → M\ns : Set α\nhf : Set.EqOn f 0 s\n⊢ Eq (finsum fun i => finsum fun h => f i) 0","decl":"/-- If a function `f` equals `1` on a set `s`, then the product of `f i` over `i ∈ s` equals `1`. -/\n@[to_additive\n      \"If a function `f` equals `0` on a set `s`, then the product of `f i` over `i ∈ s`\n      equals `0`.\"]\ntheorem finprod_mem_of_eqOn_one (hf : s.EqOn f 1) : ∏ᶠ i ∈ s, f i = 1 := by\n  rw [← finprod_mem_one s]\n  exact finprod_mem_congr rfl hf\n\n"}
{"name":"exists_ne_zero_of_finsum_mem_ne_zero","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : AddCommMonoid M\nf : α → M\ns : Set α\nh : Ne (finsum fun i => finsum fun h => f i) 0\n⊢ Exists fun x => And (Membership.mem s x) (Ne (f x) 0)","decl":"/-- If the product of `f i` over `i ∈ s` is not equal to `1`, then there is some `x ∈ s` such that\n`f x ≠ 1`. -/\n@[to_additive\n      \"If the product of `f i` over `i ∈ s` is not equal to `0`, then there is some `x ∈ s`\n      such that `f x ≠ 0`.\"]\ntheorem exists_ne_one_of_finprod_mem_ne_one (h : ∏ᶠ i ∈ s, f i ≠ 1) : ∃ x ∈ s, f x ≠ 1 := by\n  by_contra! h'\n  exact h (finprod_mem_of_eqOn_one h')\n\n"}
{"name":"exists_ne_one_of_finprod_mem_ne_one","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : CommMonoid M\nf : α → M\ns : Set α\nh : Ne (finprod fun i => finprod fun h => f i) 1\n⊢ Exists fun x => And (Membership.mem s x) (Ne (f x) 1)","decl":"/-- If the product of `f i` over `i ∈ s` is not equal to `1`, then there is some `x ∈ s` such that\n`f x ≠ 1`. -/\n@[to_additive\n      \"If the product of `f i` over `i ∈ s` is not equal to `0`, then there is some `x ∈ s`\n      such that `f x ≠ 0`.\"]\ntheorem exists_ne_one_of_finprod_mem_ne_one (h : ∏ᶠ i ∈ s, f i ≠ 1) : ∃ x ∈ s, f x ≠ 1 := by\n  by_contra! h'\n  exact h (finprod_mem_of_eqOn_one h')\n\n"}
{"name":"finsum_mem_add_distrib","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : AddCommMonoid M\nf g : α → M\ns : Set α\nhs : s.Finite\n⊢ Eq (finsum fun i => finsum fun h => HAdd.hAdd (f i) (g i)) (HAdd.hAdd (finsum fun i => finsum fun h => f i) (finsum fun i => finsum fun h => g i))","decl":"/-- Given a finite set `s`, the product of `f i * g i` over `i ∈ s` equals the product of `f i`\nover `i ∈ s` times the product of `g i` over `i ∈ s`. -/\n@[to_additive\n      \"Given a finite set `s`, the sum of `f i + g i` over `i ∈ s` equals the sum of `f i`\n      over `i ∈ s` plus the sum of `g i` over `i ∈ s`.\"]\ntheorem finprod_mem_mul_distrib (hs : s.Finite) :\n    ∏ᶠ i ∈ s, f i * g i = (∏ᶠ i ∈ s, f i) * ∏ᶠ i ∈ s, g i :=\n  finprod_mem_mul_distrib' (hs.inter_of_left _) (hs.inter_of_left _)\n\n"}
{"name":"finprod_mem_mul_distrib","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : CommMonoid M\nf g : α → M\ns : Set α\nhs : s.Finite\n⊢ Eq (finprod fun i => finprod fun h => HMul.hMul (f i) (g i)) (HMul.hMul (finprod fun i => finprod fun h => f i) (finprod fun i => finprod fun h => g i))","decl":"/-- Given a finite set `s`, the product of `f i * g i` over `i ∈ s` equals the product of `f i`\nover `i ∈ s` times the product of `g i` over `i ∈ s`. -/\n@[to_additive\n      \"Given a finite set `s`, the sum of `f i + g i` over `i ∈ s` equals the sum of `f i`\n      over `i ∈ s` plus the sum of `g i` over `i ∈ s`.\"]\ntheorem finprod_mem_mul_distrib (hs : s.Finite) :\n    ∏ᶠ i ∈ s, f i * g i = (∏ᶠ i ∈ s, f i) * ∏ᶠ i ∈ s, g i :=\n  finprod_mem_mul_distrib' (hs.inter_of_left _) (hs.inter_of_left _)\n\n"}
{"name":"MonoidHom.map_finprod","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nM : Type u_5\nN : Type u_6\ninst✝¹ : CommMonoid M\ninst✝ : CommMonoid N\nf : α → M\ng : MonoidHom M N\nhf : (Function.mulSupport f).Finite\n⊢ Eq (g (finprod fun i => f i)) (finprod fun i => g (f i))","decl":"@[to_additive]\ntheorem MonoidHom.map_finprod {f : α → M} (g : M →* N) (hf : (mulSupport f).Finite) :\n    g (∏ᶠ i, f i) = ∏ᶠ i, g (f i) :=\n  g.map_finprod_plift f <| hf.preimage Equiv.plift.injective.injOn\n\n"}
{"name":"AddMonoidHom.map_finsum","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nM : Type u_5\nN : Type u_6\ninst✝¹ : AddCommMonoid M\ninst✝ : AddCommMonoid N\nf : α → M\ng : AddMonoidHom M N\nhf : (Function.support f).Finite\n⊢ Eq (g (finsum fun i => f i)) (finsum fun i => g (f i))","decl":"@[to_additive]\ntheorem MonoidHom.map_finprod {f : α → M} (g : M →* N) (hf : (mulSupport f).Finite) :\n    g (∏ᶠ i, f i) = ∏ᶠ i, g (f i) :=\n  g.map_finprod_plift f <| hf.preimage Equiv.plift.injective.injOn\n\n"}
{"name":"finsum_nsmul","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : AddCommMonoid M\nf : α → M\nhf : (Function.support f).Finite\nn : Nat\n⊢ Eq (HSMul.hSMul n (finsum fun i => f i)) (finsum fun i => HSMul.hSMul n (f i))","decl":"@[to_additive]\ntheorem finprod_pow (hf : (mulSupport f).Finite) (n : ℕ) : (∏ᶠ i, f i) ^ n = ∏ᶠ i, f i ^ n :=\n  (powMonoidHom n).map_finprod hf\n\n"}
{"name":"finprod_pow","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : CommMonoid M\nf : α → M\nhf : (Function.mulSupport f).Finite\nn : Nat\n⊢ Eq (HPow.hPow (finprod fun i => f i) n) (finprod fun i => HPow.hPow (f i) n)","decl":"@[to_additive]\ntheorem finprod_pow (hf : (mulSupport f).Finite) (n : ℕ) : (∏ᶠ i, f i) ^ n = ∏ᶠ i, f i ^ n :=\n  (powMonoidHom n).map_finprod hf\n\n"}
{"name":"finsum_smul'","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"ι : Type u_3\nR : Type u_7\nM : Type u_8\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nf : ι → R\nhf : (Function.support f).Finite\nx : M\n⊢ Eq (HSMul.hSMul (finsum fun i => f i) x) (finsum fun i => HSMul.hSMul (f i) x)","decl":"/-- See also `finsum_smul` for a version that works even when the support of `f` is not finite,\nbut with slightly stronger typeclass requirements. -/\ntheorem finsum_smul' {R M : Type*} [Semiring R] [AddCommMonoid M] [Module R M] {f : ι → R}\n    (hf : (support f).Finite) (x : M) : (∑ᶠ i, f i) • x = ∑ᶠ i, f i • x :=\n  ((smulAddHom R M).flip x).map_finsum hf\n\n"}
{"name":"smul_finsum'","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"ι : Type u_3\nR : Type u_7\nM : Type u_8\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nc : R\nf : ι → M\nhf : (Function.support f).Finite\n⊢ Eq (HSMul.hSMul c (finsum fun i => f i)) (finsum fun i => HSMul.hSMul c (f i))","decl":"/-- See also `smul_finsum` for a version that works even when the support of `f` is not finite,\nbut with slightly stronger typeclass requirements. -/\ntheorem smul_finsum' {R M : Type*} [Semiring R] [AddCommMonoid M] [Module R M] (c : R) {f : ι → M}\n    (hf : (support f).Finite) : (c • ∑ᶠ i, f i) = ∑ᶠ i, c • f i :=\n  (smulAddHom R M c).map_finsum hf\n\n"}
{"name":"AddMonoidHom.map_finsum_mem'","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nM : Type u_5\nN : Type u_6\ninst✝¹ : AddCommMonoid M\ninst✝ : AddCommMonoid N\ns : Set α\nf : α → M\ng : AddMonoidHom M N\nh₀ : (Inter.inter s (Function.support f)).Finite\n⊢ Eq (g (finsum fun j => finsum fun h => f j)) (finsum fun i => finsum fun h => g (f i))","decl":"/-- A more general version of `MonoidHom.map_finprod_mem` that requires `s ∩ mulSupport f` rather\nthan `s` to be finite. -/\n@[to_additive\n      \"A more general version of `AddMonoidHom.map_finsum_mem` that requires\n      `s ∩ support f` rather than `s` to be finite.\"]\ntheorem MonoidHom.map_finprod_mem' {f : α → M} (g : M →* N) (h₀ : (s ∩ mulSupport f).Finite) :\n    g (∏ᶠ j ∈ s, f j) = ∏ᶠ i ∈ s, g (f i) := by\n  rw [g.map_finprod]\n  · simp only [g.map_finprod_Prop]\n  · simpa only [finprod_eq_mulIndicator_apply, mulSupport_mulIndicator]\n\n"}
{"name":"MonoidHom.map_finprod_mem'","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nM : Type u_5\nN : Type u_6\ninst✝¹ : CommMonoid M\ninst✝ : CommMonoid N\ns : Set α\nf : α → M\ng : MonoidHom M N\nh₀ : (Inter.inter s (Function.mulSupport f)).Finite\n⊢ Eq (g (finprod fun j => finprod fun h => f j)) (finprod fun i => finprod fun h => g (f i))","decl":"/-- A more general version of `MonoidHom.map_finprod_mem` that requires `s ∩ mulSupport f` rather\nthan `s` to be finite. -/\n@[to_additive\n      \"A more general version of `AddMonoidHom.map_finsum_mem` that requires\n      `s ∩ support f` rather than `s` to be finite.\"]\ntheorem MonoidHom.map_finprod_mem' {f : α → M} (g : M →* N) (h₀ : (s ∩ mulSupport f).Finite) :\n    g (∏ᶠ j ∈ s, f j) = ∏ᶠ i ∈ s, g (f i) := by\n  rw [g.map_finprod]\n  · simp only [g.map_finprod_Prop]\n  · simpa only [finprod_eq_mulIndicator_apply, mulSupport_mulIndicator]\n\n"}
{"name":"MonoidHom.map_finprod_mem","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nM : Type u_5\nN : Type u_6\ninst✝¹ : CommMonoid M\ninst✝ : CommMonoid N\ns : Set α\nf : α → M\ng : MonoidHom M N\nhs : s.Finite\n⊢ Eq (g (finprod fun j => finprod fun h => f j)) (finprod fun i => finprod fun h => g (f i))","decl":"/-- Given a monoid homomorphism `g : M →* N` and a function `f : α → M`, the value of `g` at the\nproduct of `f i` over `i ∈ s` equals the product of `g (f i)` over `s`. -/\n@[to_additive\n      \"Given an additive monoid homomorphism `g : M →* N` and a function `f : α → M`, the\n      value of `g` at the sum of `f i` over `i ∈ s` equals the sum of `g (f i)` over `s`.\"]\ntheorem MonoidHom.map_finprod_mem (f : α → M) (g : M →* N) (hs : s.Finite) :\n    g (∏ᶠ j ∈ s, f j) = ∏ᶠ i ∈ s, g (f i) :=\n  g.map_finprod_mem' (hs.inter_of_left _)\n\n"}
{"name":"AddMonoidHom.map_finsum_mem","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nM : Type u_5\nN : Type u_6\ninst✝¹ : AddCommMonoid M\ninst✝ : AddCommMonoid N\ns : Set α\nf : α → M\ng : AddMonoidHom M N\nhs : s.Finite\n⊢ Eq (g (finsum fun j => finsum fun h => f j)) (finsum fun i => finsum fun h => g (f i))","decl":"/-- Given a monoid homomorphism `g : M →* N` and a function `f : α → M`, the value of `g` at the\nproduct of `f i` over `i ∈ s` equals the product of `g (f i)` over `s`. -/\n@[to_additive\n      \"Given an additive monoid homomorphism `g : M →* N` and a function `f : α → M`, the\n      value of `g` at the sum of `f i` over `i ∈ s` equals the sum of `g (f i)` over `s`.\"]\ntheorem MonoidHom.map_finprod_mem (f : α → M) (g : M →* N) (hs : s.Finite) :\n    g (∏ᶠ j ∈ s, f j) = ∏ᶠ i ∈ s, g (f i) :=\n  g.map_finprod_mem' (hs.inter_of_left _)\n\n"}
{"name":"MulEquiv.map_finprod_mem","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nM : Type u_5\nN : Type u_6\ninst✝¹ : CommMonoid M\ninst✝ : CommMonoid N\ng : MulEquiv M N\nf : α → M\ns : Set α\nhs : s.Finite\n⊢ Eq (g (finprod fun i => finprod fun h => f i)) (finprod fun i => finprod fun h => g (f i))","decl":"@[to_additive]\ntheorem MulEquiv.map_finprod_mem (g : M ≃* N) (f : α → M) {s : Set α} (hs : s.Finite) :\n    g (∏ᶠ i ∈ s, f i) = ∏ᶠ i ∈ s, g (f i) :=\n  g.toMonoidHom.map_finprod_mem f hs\n\n"}
{"name":"AddEquiv.map_finsum_mem","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nM : Type u_5\nN : Type u_6\ninst✝¹ : AddCommMonoid M\ninst✝ : AddCommMonoid N\ng : AddEquiv M N\nf : α → M\ns : Set α\nhs : s.Finite\n⊢ Eq (g (finsum fun i => finsum fun h => f i)) (finsum fun i => finsum fun h => g (f i))","decl":"@[to_additive]\ntheorem MulEquiv.map_finprod_mem (g : M ≃* N) (f : α → M) {s : Set α} (hs : s.Finite) :\n    g (∏ᶠ i ∈ s, f i) = ∏ᶠ i ∈ s, g (f i) :=\n  g.toMonoidHom.map_finprod_mem f hs\n\n"}
{"name":"finprod_mem_inv_distrib","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nG : Type u_4\ns : Set α\ninst✝ : DivisionCommMonoid G\nf : α → G\nhs : s.Finite\n⊢ Eq (finprod fun x => finprod fun h => Inv.inv (f x)) (Inv.inv (finprod fun x => finprod fun h => f x))","decl":"@[to_additive]\ntheorem finprod_mem_inv_distrib [DivisionCommMonoid G] (f : α → G) (hs : s.Finite) :\n    (∏ᶠ x ∈ s, (f x)⁻¹) = (∏ᶠ x ∈ s, f x)⁻¹ :=\n  ((MulEquiv.inv G).map_finprod_mem f hs).symm\n\n"}
{"name":"finsum_mem_neg_distrib","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nG : Type u_4\ns : Set α\ninst✝ : SubtractionCommMonoid G\nf : α → G\nhs : s.Finite\n⊢ Eq (finsum fun x => finsum fun h => Neg.neg (f x)) (Neg.neg (finsum fun x => finsum fun h => f x))","decl":"@[to_additive]\ntheorem finprod_mem_inv_distrib [DivisionCommMonoid G] (f : α → G) (hs : s.Finite) :\n    (∏ᶠ x ∈ s, (f x)⁻¹) = (∏ᶠ x ∈ s, f x)⁻¹ :=\n  ((MulEquiv.inv G).map_finprod_mem f hs).symm\n\n"}
{"name":"finsum_mem_sub_distrib","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nG : Type u_4\ns : Set α\ninst✝ : SubtractionCommMonoid G\nf g : α → G\nhs : s.Finite\n⊢ Eq (finsum fun i => finsum fun h => HSub.hSub (f i) (g i)) (HSub.hSub (finsum fun i => finsum fun h => f i) (finsum fun i => finsum fun h => g i))","decl":"/-- Given a finite set `s`, the product of `f i / g i` over `i ∈ s` equals the product of `f i`\nover `i ∈ s` divided by the product of `g i` over `i ∈ s`. -/\n@[to_additive\n      \"Given a finite set `s`, the sum of `f i / g i` over `i ∈ s` equals the sum of `f i`\n      over `i ∈ s` minus the sum of `g i` over `i ∈ s`.\"]\ntheorem finprod_mem_div_distrib [DivisionCommMonoid G] (f g : α → G) (hs : s.Finite) :\n    ∏ᶠ i ∈ s, f i / g i = (∏ᶠ i ∈ s, f i) / ∏ᶠ i ∈ s, g i := by\n  simp only [div_eq_mul_inv, finprod_mem_mul_distrib hs, finprod_mem_inv_distrib g hs]\n\n"}
{"name":"finprod_mem_div_distrib","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nG : Type u_4\ns : Set α\ninst✝ : DivisionCommMonoid G\nf g : α → G\nhs : s.Finite\n⊢ Eq (finprod fun i => finprod fun h => HDiv.hDiv (f i) (g i)) (HDiv.hDiv (finprod fun i => finprod fun h => f i) (finprod fun i => finprod fun h => g i))","decl":"/-- Given a finite set `s`, the product of `f i / g i` over `i ∈ s` equals the product of `f i`\nover `i ∈ s` divided by the product of `g i` over `i ∈ s`. -/\n@[to_additive\n      \"Given a finite set `s`, the sum of `f i / g i` over `i ∈ s` equals the sum of `f i`\n      over `i ∈ s` minus the sum of `g i` over `i ∈ s`.\"]\ntheorem finprod_mem_div_distrib [DivisionCommMonoid G] (f g : α → G) (hs : s.Finite) :\n    ∏ᶠ i ∈ s, f i / g i = (∏ᶠ i ∈ s, f i) / ∏ᶠ i ∈ s, g i := by\n  simp only [div_eq_mul_inv, finprod_mem_mul_distrib hs, finprod_mem_inv_distrib g hs]\n\n"}
{"name":"finprod_mem_empty","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : CommMonoid M\nf : α → M\n⊢ Eq (finprod fun i => finprod fun h => f i) 1","decl":"/-- The product of any function over an empty set is `1`. -/\n@[to_additive \"The sum of any function over an empty set is `0`.\"]\ntheorem finprod_mem_empty : (∏ᶠ i ∈ (∅ : Set α), f i) = 1 := by simp\n\n"}
{"name":"finsum_mem_empty","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : AddCommMonoid M\nf : α → M\n⊢ Eq (finsum fun i => finsum fun h => f i) 0","decl":"/-- The product of any function over an empty set is `1`. -/\n@[to_additive \"The sum of any function over an empty set is `0`.\"]\ntheorem finprod_mem_empty : (∏ᶠ i ∈ (∅ : Set α), f i) = 1 := by simp\n\n"}
{"name":"nonempty_of_finprod_mem_ne_one","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : CommMonoid M\nf : α → M\ns : Set α\nh : Ne (finprod fun i => finprod fun h => f i) 1\n⊢ s.Nonempty","decl":"/-- A set `s` is nonempty if the product of some function over `s` is not equal to `1`. -/\n@[to_additive \"A set `s` is nonempty if the sum of some function over `s` is not equal to `0`.\"]\ntheorem nonempty_of_finprod_mem_ne_one (h : ∏ᶠ i ∈ s, f i ≠ 1) : s.Nonempty :=\n  nonempty_iff_ne_empty.2 fun h' => h <| h'.symm ▸ finprod_mem_empty\n\n"}
{"name":"nonempty_of_finsum_mem_ne_zero","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : AddCommMonoid M\nf : α → M\ns : Set α\nh : Ne (finsum fun i => finsum fun h => f i) 0\n⊢ s.Nonempty","decl":"/-- A set `s` is nonempty if the product of some function over `s` is not equal to `1`. -/\n@[to_additive \"A set `s` is nonempty if the sum of some function over `s` is not equal to `0`.\"]\ntheorem nonempty_of_finprod_mem_ne_one (h : ∏ᶠ i ∈ s, f i ≠ 1) : s.Nonempty :=\n  nonempty_iff_ne_empty.2 fun h' => h <| h'.symm ▸ finprod_mem_empty\n\n"}
{"name":"finprod_mem_union_inter","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : CommMonoid M\nf : α → M\ns t : Set α\nhs : s.Finite\nht : t.Finite\n⊢ Eq (HMul.hMul (finprod fun i => finprod fun h => f i) (finprod fun i => finprod fun h => f i)) (HMul.hMul (finprod fun i => finprod fun h => f i) (finprod fun i => finprod fun h => f i))","decl":"/-- Given finite sets `s` and `t`, the product of `f i` over `i ∈ s ∪ t` times the product of\n`f i` over `i ∈ s ∩ t` equals the product of `f i` over `i ∈ s` times the product of `f i`\nover `i ∈ t`. -/\n@[to_additive\n      \"Given finite sets `s` and `t`, the sum of `f i` over `i ∈ s ∪ t` plus the sum of\n      `f i` over `i ∈ s ∩ t` equals the sum of `f i` over `i ∈ s` plus the sum of `f i`\n      over `i ∈ t`.\"]\ntheorem finprod_mem_union_inter (hs : s.Finite) (ht : t.Finite) :\n    ((∏ᶠ i ∈ s ∪ t, f i) * ∏ᶠ i ∈ s ∩ t, f i) = (∏ᶠ i ∈ s, f i) * ∏ᶠ i ∈ t, f i := by\n  lift s to Finset α using hs; lift t to Finset α using ht\n  classical\n    rw [← Finset.coe_union, ← Finset.coe_inter]\n    simp only [finprod_mem_coe_finset, Finset.prod_union_inter]\n\n"}
{"name":"finsum_mem_union_inter","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : AddCommMonoid M\nf : α → M\ns t : Set α\nhs : s.Finite\nht : t.Finite\n⊢ Eq (HAdd.hAdd (finsum fun i => finsum fun h => f i) (finsum fun i => finsum fun h => f i)) (HAdd.hAdd (finsum fun i => finsum fun h => f i) (finsum fun i => finsum fun h => f i))","decl":"/-- Given finite sets `s` and `t`, the product of `f i` over `i ∈ s ∪ t` times the product of\n`f i` over `i ∈ s ∩ t` equals the product of `f i` over `i ∈ s` times the product of `f i`\nover `i ∈ t`. -/\n@[to_additive\n      \"Given finite sets `s` and `t`, the sum of `f i` over `i ∈ s ∪ t` plus the sum of\n      `f i` over `i ∈ s ∩ t` equals the sum of `f i` over `i ∈ s` plus the sum of `f i`\n      over `i ∈ t`.\"]\ntheorem finprod_mem_union_inter (hs : s.Finite) (ht : t.Finite) :\n    ((∏ᶠ i ∈ s ∪ t, f i) * ∏ᶠ i ∈ s ∩ t, f i) = (∏ᶠ i ∈ s, f i) * ∏ᶠ i ∈ t, f i := by\n  lift s to Finset α using hs; lift t to Finset α using ht\n  classical\n    rw [← Finset.coe_union, ← Finset.coe_inter]\n    simp only [finprod_mem_coe_finset, Finset.prod_union_inter]\n\n"}
{"name":"finprod_mem_union_inter'","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : CommMonoid M\nf : α → M\ns t : Set α\nhs : (Inter.inter s (Function.mulSupport f)).Finite\nht : (Inter.inter t (Function.mulSupport f)).Finite\n⊢ Eq (HMul.hMul (finprod fun i => finprod fun h => f i) (finprod fun i => finprod fun h => f i)) (HMul.hMul (finprod fun i => finprod fun h => f i) (finprod fun i => finprod fun h => f i))","decl":"/-- A more general version of `finprod_mem_union_inter` that requires `s ∩ mulSupport f` and\n`t ∩ mulSupport f` rather than `s` and `t` to be finite. -/\n@[to_additive\n      \"A more general version of `finsum_mem_union_inter` that requires `s ∩ support f` and\n      `t ∩ support f` rather than `s` and `t` to be finite.\"]\ntheorem finprod_mem_union_inter' (hs : (s ∩ mulSupport f).Finite) (ht : (t ∩ mulSupport f).Finite) :\n    ((∏ᶠ i ∈ s ∪ t, f i) * ∏ᶠ i ∈ s ∩ t, f i) = (∏ᶠ i ∈ s, f i) * ∏ᶠ i ∈ t, f i := by\n  rw [← finprod_mem_inter_mulSupport f s, ← finprod_mem_inter_mulSupport f t, ←\n    finprod_mem_union_inter hs ht, ← union_inter_distrib_right, finprod_mem_inter_mulSupport, ←\n    finprod_mem_inter_mulSupport f (s ∩ t)]\n  congr 2\n  rw [inter_left_comm, inter_assoc, inter_assoc, inter_self, inter_left_comm]\n\n"}
{"name":"finsum_mem_union_inter'","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : AddCommMonoid M\nf : α → M\ns t : Set α\nhs : (Inter.inter s (Function.support f)).Finite\nht : (Inter.inter t (Function.support f)).Finite\n⊢ Eq (HAdd.hAdd (finsum fun i => finsum fun h => f i) (finsum fun i => finsum fun h => f i)) (HAdd.hAdd (finsum fun i => finsum fun h => f i) (finsum fun i => finsum fun h => f i))","decl":"/-- A more general version of `finprod_mem_union_inter` that requires `s ∩ mulSupport f` and\n`t ∩ mulSupport f` rather than `s` and `t` to be finite. -/\n@[to_additive\n      \"A more general version of `finsum_mem_union_inter` that requires `s ∩ support f` and\n      `t ∩ support f` rather than `s` and `t` to be finite.\"]\ntheorem finprod_mem_union_inter' (hs : (s ∩ mulSupport f).Finite) (ht : (t ∩ mulSupport f).Finite) :\n    ((∏ᶠ i ∈ s ∪ t, f i) * ∏ᶠ i ∈ s ∩ t, f i) = (∏ᶠ i ∈ s, f i) * ∏ᶠ i ∈ t, f i := by\n  rw [← finprod_mem_inter_mulSupport f s, ← finprod_mem_inter_mulSupport f t, ←\n    finprod_mem_union_inter hs ht, ← union_inter_distrib_right, finprod_mem_inter_mulSupport, ←\n    finprod_mem_inter_mulSupport f (s ∩ t)]\n  congr 2\n  rw [inter_left_comm, inter_assoc, inter_assoc, inter_self, inter_left_comm]\n\n"}
{"name":"finprod_mem_union'","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : CommMonoid M\nf : α → M\ns t : Set α\nhst : Disjoint s t\nhs : (Inter.inter s (Function.mulSupport f)).Finite\nht : (Inter.inter t (Function.mulSupport f)).Finite\n⊢ Eq (finprod fun i => finprod fun h => f i) (HMul.hMul (finprod fun i => finprod fun h => f i) (finprod fun i => finprod fun h => f i))","decl":"/-- A more general version of `finprod_mem_union` that requires `s ∩ mulSupport f` and\n`t ∩ mulSupport f` rather than `s` and `t` to be finite. -/\n@[to_additive\n      \"A more general version of `finsum_mem_union` that requires `s ∩ support f` and\n      `t ∩ support f` rather than `s` and `t` to be finite.\"]\ntheorem finprod_mem_union' (hst : Disjoint s t) (hs : (s ∩ mulSupport f).Finite)\n    (ht : (t ∩ mulSupport f).Finite) : ∏ᶠ i ∈ s ∪ t, f i = (∏ᶠ i ∈ s, f i) * ∏ᶠ i ∈ t, f i := by\n  rw [← finprod_mem_union_inter' hs ht, disjoint_iff_inter_eq_empty.1 hst, finprod_mem_empty,\n    mul_one]\n\n"}
{"name":"finsum_mem_union'","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : AddCommMonoid M\nf : α → M\ns t : Set α\nhst : Disjoint s t\nhs : (Inter.inter s (Function.support f)).Finite\nht : (Inter.inter t (Function.support f)).Finite\n⊢ Eq (finsum fun i => finsum fun h => f i) (HAdd.hAdd (finsum fun i => finsum fun h => f i) (finsum fun i => finsum fun h => f i))","decl":"/-- A more general version of `finprod_mem_union` that requires `s ∩ mulSupport f` and\n`t ∩ mulSupport f` rather than `s` and `t` to be finite. -/\n@[to_additive\n      \"A more general version of `finsum_mem_union` that requires `s ∩ support f` and\n      `t ∩ support f` rather than `s` and `t` to be finite.\"]\ntheorem finprod_mem_union' (hst : Disjoint s t) (hs : (s ∩ mulSupport f).Finite)\n    (ht : (t ∩ mulSupport f).Finite) : ∏ᶠ i ∈ s ∪ t, f i = (∏ᶠ i ∈ s, f i) * ∏ᶠ i ∈ t, f i := by\n  rw [← finprod_mem_union_inter' hs ht, disjoint_iff_inter_eq_empty.1 hst, finprod_mem_empty,\n    mul_one]\n\n"}
{"name":"finprod_mem_union","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : CommMonoid M\nf : α → M\ns t : Set α\nhst : Disjoint s t\nhs : s.Finite\nht : t.Finite\n⊢ Eq (finprod fun i => finprod fun h => f i) (HMul.hMul (finprod fun i => finprod fun h => f i) (finprod fun i => finprod fun h => f i))","decl":"/-- Given two finite disjoint sets `s` and `t`, the product of `f i` over `i ∈ s ∪ t` equals the\nproduct of `f i` over `i ∈ s` times the product of `f i` over `i ∈ t`. -/\n@[to_additive\n      \"Given two finite disjoint sets `s` and `t`, the sum of `f i` over `i ∈ s ∪ t` equals\n      the sum of `f i` over `i ∈ s` plus the sum of `f i` over `i ∈ t`.\"]\ntheorem finprod_mem_union (hst : Disjoint s t) (hs : s.Finite) (ht : t.Finite) :\n    ∏ᶠ i ∈ s ∪ t, f i = (∏ᶠ i ∈ s, f i) * ∏ᶠ i ∈ t, f i :=\n  finprod_mem_union' hst (hs.inter_of_left _) (ht.inter_of_left _)\n\n"}
{"name":"finsum_mem_union","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : AddCommMonoid M\nf : α → M\ns t : Set α\nhst : Disjoint s t\nhs : s.Finite\nht : t.Finite\n⊢ Eq (finsum fun i => finsum fun h => f i) (HAdd.hAdd (finsum fun i => finsum fun h => f i) (finsum fun i => finsum fun h => f i))","decl":"/-- Given two finite disjoint sets `s` and `t`, the product of `f i` over `i ∈ s ∪ t` equals the\nproduct of `f i` over `i ∈ s` times the product of `f i` over `i ∈ t`. -/\n@[to_additive\n      \"Given two finite disjoint sets `s` and `t`, the sum of `f i` over `i ∈ s ∪ t` equals\n      the sum of `f i` over `i ∈ s` plus the sum of `f i` over `i ∈ t`.\"]\ntheorem finprod_mem_union (hst : Disjoint s t) (hs : s.Finite) (ht : t.Finite) :\n    ∏ᶠ i ∈ s ∪ t, f i = (∏ᶠ i ∈ s, f i) * ∏ᶠ i ∈ t, f i :=\n  finprod_mem_union' hst (hs.inter_of_left _) (ht.inter_of_left _)\n\n"}
{"name":"finprod_mem_union''","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : CommMonoid M\nf : α → M\ns t : Set α\nhst : Disjoint (Inter.inter s (Function.mulSupport f)) (Inter.inter t (Function.mulSupport f))\nhs : (Inter.inter s (Function.mulSupport f)).Finite\nht : (Inter.inter t (Function.mulSupport f)).Finite\n⊢ Eq (finprod fun i => finprod fun h => f i) (HMul.hMul (finprod fun i => finprod fun h => f i) (finprod fun i => finprod fun h => f i))","decl":"/-- A more general version of `finprod_mem_union'` that requires `s ∩ mulSupport f` and\n`t ∩ mulSupport f` rather than `s` and `t` to be disjoint -/\n@[to_additive\n      \"A more general version of `finsum_mem_union'` that requires `s ∩ support f` and\n      `t ∩ support f` rather than `s` and `t` to be disjoint\"]\ntheorem finprod_mem_union'' (hst : Disjoint (s ∩ mulSupport f) (t ∩ mulSupport f))\n    (hs : (s ∩ mulSupport f).Finite) (ht : (t ∩ mulSupport f).Finite) :\n    ∏ᶠ i ∈ s ∪ t, f i = (∏ᶠ i ∈ s, f i) * ∏ᶠ i ∈ t, f i := by\n  rw [← finprod_mem_inter_mulSupport f s, ← finprod_mem_inter_mulSupport f t, ←\n    finprod_mem_union hst hs ht, ← union_inter_distrib_right, finprod_mem_inter_mulSupport]\n\n"}
{"name":"finsum_mem_union''","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : AddCommMonoid M\nf : α → M\ns t : Set α\nhst : Disjoint (Inter.inter s (Function.support f)) (Inter.inter t (Function.support f))\nhs : (Inter.inter s (Function.support f)).Finite\nht : (Inter.inter t (Function.support f)).Finite\n⊢ Eq (finsum fun i => finsum fun h => f i) (HAdd.hAdd (finsum fun i => finsum fun h => f i) (finsum fun i => finsum fun h => f i))","decl":"/-- A more general version of `finprod_mem_union'` that requires `s ∩ mulSupport f` and\n`t ∩ mulSupport f` rather than `s` and `t` to be disjoint -/\n@[to_additive\n      \"A more general version of `finsum_mem_union'` that requires `s ∩ support f` and\n      `t ∩ support f` rather than `s` and `t` to be disjoint\"]\ntheorem finprod_mem_union'' (hst : Disjoint (s ∩ mulSupport f) (t ∩ mulSupport f))\n    (hs : (s ∩ mulSupport f).Finite) (ht : (t ∩ mulSupport f).Finite) :\n    ∏ᶠ i ∈ s ∪ t, f i = (∏ᶠ i ∈ s, f i) * ∏ᶠ i ∈ t, f i := by\n  rw [← finprod_mem_inter_mulSupport f s, ← finprod_mem_inter_mulSupport f t, ←\n    finprod_mem_union hst hs ht, ← union_inter_distrib_right, finprod_mem_inter_mulSupport]\n\n"}
{"name":"finsum_mem_singleton","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : AddCommMonoid M\nf : α → M\na : α\n⊢ Eq (finsum fun i => finsum fun h => f i) (f a)","decl":"/-- The product of `f i` over `i ∈ {a}` equals `f a`. -/\n@[to_additive \"The sum of `f i` over `i ∈ {a}` equals `f a`.\"]\ntheorem finprod_mem_singleton : (∏ᶠ i ∈ ({a} : Set α), f i) = f a := by\n  rw [← Finset.coe_singleton, finprod_mem_coe_finset, Finset.prod_singleton]\n\n"}
{"name":"finprod_mem_singleton","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : CommMonoid M\nf : α → M\na : α\n⊢ Eq (finprod fun i => finprod fun h => f i) (f a)","decl":"/-- The product of `f i` over `i ∈ {a}` equals `f a`. -/\n@[to_additive \"The sum of `f i` over `i ∈ {a}` equals `f a`.\"]\ntheorem finprod_mem_singleton : (∏ᶠ i ∈ ({a} : Set α), f i) = f a := by\n  rw [← Finset.coe_singleton, finprod_mem_coe_finset, Finset.prod_singleton]\n\n"}
{"name":"finprod_cond_eq_left","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : CommMonoid M\nf : α → M\na : α\n⊢ Eq (finprod fun i => finprod fun x => f i) (f a)","decl":"@[to_additive (attr := simp)]\ntheorem finprod_cond_eq_left : (∏ᶠ (i) (_ : i = a), f i) = f a :=\n  finprod_mem_singleton\n\n"}
{"name":"finsum_cond_eq_left","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : AddCommMonoid M\nf : α → M\na : α\n⊢ Eq (finsum fun i => finsum fun x => f i) (f a)","decl":"@[to_additive (attr := simp)]\ntheorem finprod_cond_eq_left : (∏ᶠ (i) (_ : i = a), f i) = f a :=\n  finprod_mem_singleton\n\n"}
{"name":"finprod_cond_eq_right","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : CommMonoid M\nf : α → M\na : α\n⊢ Eq (finprod fun i => finprod fun x => f i) (f a)","decl":"@[to_additive (attr := simp)]\ntheorem finprod_cond_eq_right : (∏ᶠ (i) (_ : a = i), f i) = f a := by simp [@eq_comm _ a]\n\n"}
{"name":"finsum_cond_eq_right","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : AddCommMonoid M\nf : α → M\na : α\n⊢ Eq (finsum fun i => finsum fun x => f i) (f a)","decl":"@[to_additive (attr := simp)]\ntheorem finprod_cond_eq_right : (∏ᶠ (i) (_ : a = i), f i) = f a := by simp [@eq_comm _ a]\n\n"}
{"name":"finsum_mem_insert'","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : AddCommMonoid M\na : α\ns : Set α\nf : α → M\nh : Not (Membership.mem s a)\nhs : (Inter.inter s (Function.support f)).Finite\n⊢ Eq (finsum fun i => finsum fun h => f i) (HAdd.hAdd (f a) (finsum fun i => finsum fun h => f i))","decl":"/-- A more general version of `finprod_mem_insert` that requires `s ∩ mulSupport f` rather than `s`\nto be finite. -/\n@[to_additive\n      \"A more general version of `finsum_mem_insert` that requires `s ∩ support f` rather\n      than `s` to be finite.\"]\ntheorem finprod_mem_insert' (f : α → M) (h : a ∉ s) (hs : (s ∩ mulSupport f).Finite) :\n    ∏ᶠ i ∈ insert a s, f i = f a * ∏ᶠ i ∈ s, f i := by\n  rw [insert_eq, finprod_mem_union' _ _ hs, finprod_mem_singleton]\n  · rwa [disjoint_singleton_left]\n  · exact (finite_singleton a).inter_of_left _\n\n"}
{"name":"finprod_mem_insert'","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : CommMonoid M\na : α\ns : Set α\nf : α → M\nh : Not (Membership.mem s a)\nhs : (Inter.inter s (Function.mulSupport f)).Finite\n⊢ Eq (finprod fun i => finprod fun h => f i) (HMul.hMul (f a) (finprod fun i => finprod fun h => f i))","decl":"/-- A more general version of `finprod_mem_insert` that requires `s ∩ mulSupport f` rather than `s`\nto be finite. -/\n@[to_additive\n      \"A more general version of `finsum_mem_insert` that requires `s ∩ support f` rather\n      than `s` to be finite.\"]\ntheorem finprod_mem_insert' (f : α → M) (h : a ∉ s) (hs : (s ∩ mulSupport f).Finite) :\n    ∏ᶠ i ∈ insert a s, f i = f a * ∏ᶠ i ∈ s, f i := by\n  rw [insert_eq, finprod_mem_union' _ _ hs, finprod_mem_singleton]\n  · rwa [disjoint_singleton_left]\n  · exact (finite_singleton a).inter_of_left _\n\n"}
{"name":"finprod_mem_insert","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : CommMonoid M\na : α\ns : Set α\nf : α → M\nh : Not (Membership.mem s a)\nhs : s.Finite\n⊢ Eq (finprod fun i => finprod fun h => f i) (HMul.hMul (f a) (finprod fun i => finprod fun h => f i))","decl":"/-- Given a finite set `s` and an element `a ∉ s`, the product of `f i` over `i ∈ insert a s` equals\n`f a` times the product of `f i` over `i ∈ s`. -/\n@[to_additive\n      \"Given a finite set `s` and an element `a ∉ s`, the sum of `f i` over `i ∈ insert a s`\n      equals `f a` plus the sum of `f i` over `i ∈ s`.\"]\ntheorem finprod_mem_insert (f : α → M) (h : a ∉ s) (hs : s.Finite) :\n    ∏ᶠ i ∈ insert a s, f i = f a * ∏ᶠ i ∈ s, f i :=\n  finprod_mem_insert' f h <| hs.inter_of_left _\n\n"}
{"name":"finsum_mem_insert","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : AddCommMonoid M\na : α\ns : Set α\nf : α → M\nh : Not (Membership.mem s a)\nhs : s.Finite\n⊢ Eq (finsum fun i => finsum fun h => f i) (HAdd.hAdd (f a) (finsum fun i => finsum fun h => f i))","decl":"/-- Given a finite set `s` and an element `a ∉ s`, the product of `f i` over `i ∈ insert a s` equals\n`f a` times the product of `f i` over `i ∈ s`. -/\n@[to_additive\n      \"Given a finite set `s` and an element `a ∉ s`, the sum of `f i` over `i ∈ insert a s`\n      equals `f a` plus the sum of `f i` over `i ∈ s`.\"]\ntheorem finprod_mem_insert (f : α → M) (h : a ∉ s) (hs : s.Finite) :\n    ∏ᶠ i ∈ insert a s, f i = f a * ∏ᶠ i ∈ s, f i :=\n  finprod_mem_insert' f h <| hs.inter_of_left _\n\n"}
{"name":"finsum_mem_insert_of_eq_zero_if_not_mem","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : AddCommMonoid M\nf : α → M\na : α\ns : Set α\nh : Not (Membership.mem s a) → Eq (f a) 0\n⊢ Eq (finsum fun i => finsum fun h => f i) (finsum fun i => finsum fun h => f i)","decl":"/-- If `f a = 1` when `a ∉ s`, then the product of `f i` over `i ∈ insert a s` equals the product of\n`f i` over `i ∈ s`. -/\n@[to_additive\n      \"If `f a = 0` when `a ∉ s`, then the sum of `f i` over `i ∈ insert a s` equals the sum\n      of `f i` over `i ∈ s`.\"]\ntheorem finprod_mem_insert_of_eq_one_if_not_mem (h : a ∉ s → f a = 1) :\n    ∏ᶠ i ∈ insert a s, f i = ∏ᶠ i ∈ s, f i := by\n  refine finprod_mem_inter_mulSupport_eq' _ _ _ fun x hx => ⟨?_, Or.inr⟩\n  rintro (rfl | hxs)\n  exacts [not_imp_comm.1 h hx, hxs]\n\n"}
{"name":"finprod_mem_insert_of_eq_one_if_not_mem","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : CommMonoid M\nf : α → M\na : α\ns : Set α\nh : Not (Membership.mem s a) → Eq (f a) 1\n⊢ Eq (finprod fun i => finprod fun h => f i) (finprod fun i => finprod fun h => f i)","decl":"/-- If `f a = 1` when `a ∉ s`, then the product of `f i` over `i ∈ insert a s` equals the product of\n`f i` over `i ∈ s`. -/\n@[to_additive\n      \"If `f a = 0` when `a ∉ s`, then the sum of `f i` over `i ∈ insert a s` equals the sum\n      of `f i` over `i ∈ s`.\"]\ntheorem finprod_mem_insert_of_eq_one_if_not_mem (h : a ∉ s → f a = 1) :\n    ∏ᶠ i ∈ insert a s, f i = ∏ᶠ i ∈ s, f i := by\n  refine finprod_mem_inter_mulSupport_eq' _ _ _ fun x hx => ⟨?_, Or.inr⟩\n  rintro (rfl | hxs)\n  exacts [not_imp_comm.1 h hx, hxs]\n\n"}
{"name":"finsum_mem_insert_zero","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : AddCommMonoid M\nf : α → M\na : α\ns : Set α\nh : Eq (f a) 0\n⊢ Eq (finsum fun i => finsum fun h => f i) (finsum fun i => finsum fun h => f i)","decl":"/-- If `f a = 1`, then the product of `f i` over `i ∈ insert a s` equals the product of `f i` over\n`i ∈ s`. -/\n@[to_additive\n      \"If `f a = 0`, then the sum of `f i` over `i ∈ insert a s` equals the sum of `f i`\n      over `i ∈ s`.\"]\ntheorem finprod_mem_insert_one (h : f a = 1) : ∏ᶠ i ∈ insert a s, f i = ∏ᶠ i ∈ s, f i :=\n  finprod_mem_insert_of_eq_one_if_not_mem fun _ => h\n\n"}
{"name":"finprod_mem_insert_one","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : CommMonoid M\nf : α → M\na : α\ns : Set α\nh : Eq (f a) 1\n⊢ Eq (finprod fun i => finprod fun h => f i) (finprod fun i => finprod fun h => f i)","decl":"/-- If `f a = 1`, then the product of `f i` over `i ∈ insert a s` equals the product of `f i` over\n`i ∈ s`. -/\n@[to_additive\n      \"If `f a = 0`, then the sum of `f i` over `i ∈ insert a s` equals the sum of `f i`\n      over `i ∈ s`.\"]\ntheorem finprod_mem_insert_one (h : f a = 1) : ∏ᶠ i ∈ insert a s, f i = ∏ᶠ i ∈ s, f i :=\n  finprod_mem_insert_of_eq_one_if_not_mem fun _ => h\n\n"}
{"name":"finprod_mem_dvd","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nN : Type u_6\ninst✝ : CommMonoid N\nf : α → N\na : α\nhf : (Function.mulSupport f).Finite\n⊢ Dvd.dvd (f a) (finprod f)","decl":"/-- If the multiplicative support of `f` is finite, then for every `x` in the domain of `f`, `f x`\ndivides `finprod f`. -/\ntheorem finprod_mem_dvd {f : α → N} (a : α) (hf : (mulSupport f).Finite) : f a ∣ finprod f := by\n  by_cases ha : a ∈ mulSupport f\n  · rw [finprod_eq_prod_of_mulSupport_toFinset_subset f hf (Set.Subset.refl _)]\n    exact Finset.dvd_prod_of_mem f ((Finite.mem_toFinset hf).mpr ha)\n  · rw [nmem_mulSupport.mp ha]\n    exact one_dvd (finprod f)\n\n"}
{"name":"finprod_mem_pair","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : CommMonoid M\nf : α → M\na b : α\nh : Ne a b\n⊢ Eq (finprod fun i => finprod fun h => f i) (HMul.hMul (f a) (f b))","decl":"/-- The product of `f i` over `i ∈ {a, b}`, `a ≠ b`, is equal to `f a * f b`. -/\n@[to_additive \"The sum of `f i` over `i ∈ {a, b}`, `a ≠ b`, is equal to `f a + f b`.\"]\ntheorem finprod_mem_pair (h : a ≠ b) : (∏ᶠ i ∈ ({a, b} : Set α), f i) = f a * f b := by\n  rw [finprod_mem_insert, finprod_mem_singleton]\n  exacts [h, finite_singleton b]\n\n"}
{"name":"finsum_mem_pair","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : AddCommMonoid M\nf : α → M\na b : α\nh : Ne a b\n⊢ Eq (finsum fun i => finsum fun h => f i) (HAdd.hAdd (f a) (f b))","decl":"/-- The product of `f i` over `i ∈ {a, b}`, `a ≠ b`, is equal to `f a * f b`. -/\n@[to_additive \"The sum of `f i` over `i ∈ {a, b}`, `a ≠ b`, is equal to `f a + f b`.\"]\ntheorem finprod_mem_pair (h : a ≠ b) : (∏ᶠ i ∈ ({a, b} : Set α), f i) = f a * f b := by\n  rw [finprod_mem_insert, finprod_mem_singleton]\n  exacts [h, finite_singleton b]\n\n"}
{"name":"finsum_mem_image'","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nβ : Type u_2\nM : Type u_5\ninst✝ : AddCommMonoid M\nf : α → M\ns : Set β\ng : β → α\nhg : Set.InjOn g (Inter.inter s (Function.support (Function.comp f g)))\n⊢ Eq (finsum fun i => finsum fun h => f i) (finsum fun j => finsum fun h => f (g j))","decl":"/-- The product of `f y` over `y ∈ g '' s` equals the product of `f (g i)` over `s`\nprovided that `g` is injective on `s ∩ mulSupport (f ∘ g)`. -/\n@[to_additive\n      \"The sum of `f y` over `y ∈ g '' s` equals the sum of `f (g i)` over `s` provided that\n      `g` is injective on `s ∩ support (f ∘ g)`.\"]\ntheorem finprod_mem_image' {s : Set β} {g : β → α} (hg : (s ∩ mulSupport (f ∘ g)).InjOn g) :\n    ∏ᶠ i ∈ g '' s, f i = ∏ᶠ j ∈ s, f (g j) := by\n  classical\n    by_cases hs : (s ∩ mulSupport (f ∘ g)).Finite\n    · have hg : ∀ x ∈ hs.toFinset, ∀ y ∈ hs.toFinset, g x = g y → x = y := by\n        simpa only [hs.mem_toFinset]\n      have := finprod_mem_eq_prod (comp f g) hs\n      unfold Function.comp at this\n      rw [this, ← Finset.prod_image hg]\n      refine finprod_mem_eq_prod_of_inter_mulSupport_eq f ?_\n      rw [Finset.coe_image, hs.coe_toFinset, ← image_inter_mulSupport_eq, inter_assoc, inter_self]\n    · unfold Function.comp at hs\n      rw [finprod_mem_eq_one_of_infinite hs, finprod_mem_eq_one_of_infinite]\n      rwa [image_inter_mulSupport_eq, infinite_image_iff hg]\n\n"}
{"name":"finprod_mem_image'","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nβ : Type u_2\nM : Type u_5\ninst✝ : CommMonoid M\nf : α → M\ns : Set β\ng : β → α\nhg : Set.InjOn g (Inter.inter s (Function.mulSupport (Function.comp f g)))\n⊢ Eq (finprod fun i => finprod fun h => f i) (finprod fun j => finprod fun h => f (g j))","decl":"/-- The product of `f y` over `y ∈ g '' s` equals the product of `f (g i)` over `s`\nprovided that `g` is injective on `s ∩ mulSupport (f ∘ g)`. -/\n@[to_additive\n      \"The sum of `f y` over `y ∈ g '' s` equals the sum of `f (g i)` over `s` provided that\n      `g` is injective on `s ∩ support (f ∘ g)`.\"]\ntheorem finprod_mem_image' {s : Set β} {g : β → α} (hg : (s ∩ mulSupport (f ∘ g)).InjOn g) :\n    ∏ᶠ i ∈ g '' s, f i = ∏ᶠ j ∈ s, f (g j) := by\n  classical\n    by_cases hs : (s ∩ mulSupport (f ∘ g)).Finite\n    · have hg : ∀ x ∈ hs.toFinset, ∀ y ∈ hs.toFinset, g x = g y → x = y := by\n        simpa only [hs.mem_toFinset]\n      have := finprod_mem_eq_prod (comp f g) hs\n      unfold Function.comp at this\n      rw [this, ← Finset.prod_image hg]\n      refine finprod_mem_eq_prod_of_inter_mulSupport_eq f ?_\n      rw [Finset.coe_image, hs.coe_toFinset, ← image_inter_mulSupport_eq, inter_assoc, inter_self]\n    · unfold Function.comp at hs\n      rw [finprod_mem_eq_one_of_infinite hs, finprod_mem_eq_one_of_infinite]\n      rwa [image_inter_mulSupport_eq, infinite_image_iff hg]\n\n"}
{"name":"finprod_mem_image","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nβ : Type u_2\nM : Type u_5\ninst✝ : CommMonoid M\nf : α → M\ns : Set β\ng : β → α\nhg : Set.InjOn g s\n⊢ Eq (finprod fun i => finprod fun h => f i) (finprod fun j => finprod fun h => f (g j))","decl":"/-- The product of `f y` over `y ∈ g '' s` equals the product of `f (g i)` over `s` provided that\n`g` is injective on `s`. -/\n@[to_additive\n      \"The sum of `f y` over `y ∈ g '' s` equals the sum of `f (g i)` over `s` provided that\n      `g` is injective on `s`.\"]\ntheorem finprod_mem_image {s : Set β} {g : β → α} (hg : s.InjOn g) :\n    ∏ᶠ i ∈ g '' s, f i = ∏ᶠ j ∈ s, f (g j) :=\n  finprod_mem_image' <| hg.mono inter_subset_left\n\n"}
{"name":"finsum_mem_image","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nβ : Type u_2\nM : Type u_5\ninst✝ : AddCommMonoid M\nf : α → M\ns : Set β\ng : β → α\nhg : Set.InjOn g s\n⊢ Eq (finsum fun i => finsum fun h => f i) (finsum fun j => finsum fun h => f (g j))","decl":"/-- The product of `f y` over `y ∈ g '' s` equals the product of `f (g i)` over `s` provided that\n`g` is injective on `s`. -/\n@[to_additive\n      \"The sum of `f y` over `y ∈ g '' s` equals the sum of `f (g i)` over `s` provided that\n      `g` is injective on `s`.\"]\ntheorem finprod_mem_image {s : Set β} {g : β → α} (hg : s.InjOn g) :\n    ∏ᶠ i ∈ g '' s, f i = ∏ᶠ j ∈ s, f (g j) :=\n  finprod_mem_image' <| hg.mono inter_subset_left\n\n"}
{"name":"finsum_mem_range'","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nβ : Type u_2\nM : Type u_5\ninst✝ : AddCommMonoid M\nf : α → M\ng : β → α\nhg : Set.InjOn g (Function.support (Function.comp f g))\n⊢ Eq (finsum fun i => finsum fun h => f i) (finsum fun j => f (g j))","decl":"/-- The product of `f y` over `y ∈ Set.range g` equals the product of `f (g i)` over all `i`\nprovided that `g` is injective on `mulSupport (f ∘ g)`. -/\n@[to_additive\n      \"The sum of `f y` over `y ∈ Set.range g` equals the sum of `f (g i)` over all `i`\n      provided that `g` is injective on `support (f ∘ g)`.\"]\ntheorem finprod_mem_range' {g : β → α} (hg : (mulSupport (f ∘ g)).InjOn g) :\n    ∏ᶠ i ∈ range g, f i = ∏ᶠ j, f (g j) := by\n  rw [← image_univ, finprod_mem_image', finprod_mem_univ]\n  rwa [univ_inter]\n\n"}
{"name":"finprod_mem_range'","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nβ : Type u_2\nM : Type u_5\ninst✝ : CommMonoid M\nf : α → M\ng : β → α\nhg : Set.InjOn g (Function.mulSupport (Function.comp f g))\n⊢ Eq (finprod fun i => finprod fun h => f i) (finprod fun j => f (g j))","decl":"/-- The product of `f y` over `y ∈ Set.range g` equals the product of `f (g i)` over all `i`\nprovided that `g` is injective on `mulSupport (f ∘ g)`. -/\n@[to_additive\n      \"The sum of `f y` over `y ∈ Set.range g` equals the sum of `f (g i)` over all `i`\n      provided that `g` is injective on `support (f ∘ g)`.\"]\ntheorem finprod_mem_range' {g : β → α} (hg : (mulSupport (f ∘ g)).InjOn g) :\n    ∏ᶠ i ∈ range g, f i = ∏ᶠ j, f (g j) := by\n  rw [← image_univ, finprod_mem_image', finprod_mem_univ]\n  rwa [univ_inter]\n\n"}
{"name":"finsum_mem_range","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nβ : Type u_2\nM : Type u_5\ninst✝ : AddCommMonoid M\nf : α → M\ng : β → α\nhg : Function.Injective g\n⊢ Eq (finsum fun i => finsum fun h => f i) (finsum fun j => f (g j))","decl":"/-- The product of `f y` over `y ∈ Set.range g` equals the product of `f (g i)` over all `i`\nprovided that `g` is injective. -/\n@[to_additive\n      \"The sum of `f y` over `y ∈ Set.range g` equals the sum of `f (g i)` over all `i`\n      provided that `g` is injective.\"]\ntheorem finprod_mem_range {g : β → α} (hg : Injective g) : ∏ᶠ i ∈ range g, f i = ∏ᶠ j, f (g j) :=\n  finprod_mem_range' hg.injOn\n\n"}
{"name":"finprod_mem_range","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nβ : Type u_2\nM : Type u_5\ninst✝ : CommMonoid M\nf : α → M\ng : β → α\nhg : Function.Injective g\n⊢ Eq (finprod fun i => finprod fun h => f i) (finprod fun j => f (g j))","decl":"/-- The product of `f y` over `y ∈ Set.range g` equals the product of `f (g i)` over all `i`\nprovided that `g` is injective. -/\n@[to_additive\n      \"The sum of `f y` over `y ∈ Set.range g` equals the sum of `f (g i)` over all `i`\n      provided that `g` is injective.\"]\ntheorem finprod_mem_range {g : β → α} (hg : Injective g) : ∏ᶠ i ∈ range g, f i = ∏ᶠ j, f (g j) :=\n  finprod_mem_range' hg.injOn\n\n"}
{"name":"finsum_mem_eq_of_bijOn","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nβ : Type u_2\nM : Type u_5\ninst✝ : AddCommMonoid M\ns : Set α\nt : Set β\nf : α → M\ng : β → M\ne : α → β\nhe₀ : Set.BijOn e s t\nhe₁ : ∀ (x : α), Membership.mem s x → Eq (f x) (g (e x))\n⊢ Eq (finsum fun i => finsum fun h => f i) (finsum fun j => finsum fun h => g j)","decl":"/-- See also `Finset.prod_bij`. -/\n@[to_additive \"See also `Finset.sum_bij`.\"]\ntheorem finprod_mem_eq_of_bijOn {s : Set α} {t : Set β} {f : α → M} {g : β → M} (e : α → β)\n    (he₀ : s.BijOn e t) (he₁ : ∀ x ∈ s, f x = g (e x)) : ∏ᶠ i ∈ s, f i = ∏ᶠ j ∈ t, g j := by\n  rw [← Set.BijOn.image_eq he₀, finprod_mem_image he₀.2.1]\n  exact finprod_mem_congr rfl he₁\n\n"}
{"name":"finprod_mem_eq_of_bijOn","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nβ : Type u_2\nM : Type u_5\ninst✝ : CommMonoid M\ns : Set α\nt : Set β\nf : α → M\ng : β → M\ne : α → β\nhe₀ : Set.BijOn e s t\nhe₁ : ∀ (x : α), Membership.mem s x → Eq (f x) (g (e x))\n⊢ Eq (finprod fun i => finprod fun h => f i) (finprod fun j => finprod fun h => g j)","decl":"/-- See also `Finset.prod_bij`. -/\n@[to_additive \"See also `Finset.sum_bij`.\"]\ntheorem finprod_mem_eq_of_bijOn {s : Set α} {t : Set β} {f : α → M} {g : β → M} (e : α → β)\n    (he₀ : s.BijOn e t) (he₁ : ∀ x ∈ s, f x = g (e x)) : ∏ᶠ i ∈ s, f i = ∏ᶠ j ∈ t, g j := by\n  rw [← Set.BijOn.image_eq he₀, finprod_mem_image he₀.2.1]\n  exact finprod_mem_congr rfl he₁\n\n"}
{"name":"finsum_eq_of_bijective","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nβ : Type u_2\nM : Type u_5\ninst✝ : AddCommMonoid M\nf : α → M\ng : β → M\ne : α → β\nhe₀ : Function.Bijective e\nhe₁ : ∀ (x : α), Eq (f x) (g (e x))\n⊢ Eq (finsum fun i => f i) (finsum fun j => g j)","decl":"/-- See `finprod_comp`, `Fintype.prod_bijective` and `Finset.prod_bij`. -/\n@[to_additive \"See `finsum_comp`, `Fintype.sum_bijective` and `Finset.sum_bij`.\"]\ntheorem finprod_eq_of_bijective {f : α → M} {g : β → M} (e : α → β) (he₀ : Bijective e)\n    (he₁ : ∀ x, f x = g (e x)) : ∏ᶠ i, f i = ∏ᶠ j, g j := by\n  rw [← finprod_mem_univ f, ← finprod_mem_univ g]\n  exact finprod_mem_eq_of_bijOn _ (bijective_iff_bijOn_univ.mp he₀) fun x _ => he₁ x\n\n"}
{"name":"finprod_eq_of_bijective","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nβ : Type u_2\nM : Type u_5\ninst✝ : CommMonoid M\nf : α → M\ng : β → M\ne : α → β\nhe₀ : Function.Bijective e\nhe₁ : ∀ (x : α), Eq (f x) (g (e x))\n⊢ Eq (finprod fun i => f i) (finprod fun j => g j)","decl":"/-- See `finprod_comp`, `Fintype.prod_bijective` and `Finset.prod_bij`. -/\n@[to_additive \"See `finsum_comp`, `Fintype.sum_bijective` and `Finset.sum_bij`.\"]\ntheorem finprod_eq_of_bijective {f : α → M} {g : β → M} (e : α → β) (he₀ : Bijective e)\n    (he₁ : ∀ x, f x = g (e x)) : ∏ᶠ i, f i = ∏ᶠ j, g j := by\n  rw [← finprod_mem_univ f, ← finprod_mem_univ g]\n  exact finprod_mem_eq_of_bijOn _ (bijective_iff_bijOn_univ.mp he₀) fun x _ => he₁ x\n\n"}
{"name":"finprod_comp","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nβ : Type u_2\nM : Type u_5\ninst✝ : CommMonoid M\ng : β → M\ne : α → β\nhe₀ : Function.Bijective e\n⊢ Eq (finprod fun i => g (e i)) (finprod fun j => g j)","decl":"/-- See also `finprod_eq_of_bijective`, `Fintype.prod_bijective` and `Finset.prod_bij`. -/\n@[to_additive \"See also `finsum_eq_of_bijective`, `Fintype.sum_bijective` and `Finset.sum_bij`.\"]\ntheorem finprod_comp {g : β → M} (e : α → β) (he₀ : Function.Bijective e) :\n    (∏ᶠ i, g (e i)) = ∏ᶠ j, g j :=\n  finprod_eq_of_bijective e he₀ fun _ => rfl\n\n"}
{"name":"finsum_comp","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nβ : Type u_2\nM : Type u_5\ninst✝ : AddCommMonoid M\ng : β → M\ne : α → β\nhe₀ : Function.Bijective e\n⊢ Eq (finsum fun i => g (e i)) (finsum fun j => g j)","decl":"/-- See also `finprod_eq_of_bijective`, `Fintype.prod_bijective` and `Finset.prod_bij`. -/\n@[to_additive \"See also `finsum_eq_of_bijective`, `Fintype.sum_bijective` and `Finset.sum_bij`.\"]\ntheorem finprod_comp {g : β → M} (e : α → β) (he₀ : Function.Bijective e) :\n    (∏ᶠ i, g (e i)) = ∏ᶠ j, g j :=\n  finprod_eq_of_bijective e he₀ fun _ => rfl\n\n"}
{"name":"finprod_comp_equiv","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nβ : Type u_2\nM : Type u_5\ninst✝ : CommMonoid M\ne : Equiv α β\nf : β → M\n⊢ Eq (finprod fun i => f (e i)) (finprod fun i' => f i')","decl":"@[to_additive]\ntheorem finprod_comp_equiv (e : α ≃ β) {f : β → M} : (∏ᶠ i, f (e i)) = ∏ᶠ i', f i' :=\n  finprod_comp e e.bijective\n\n"}
{"name":"finsum_comp_equiv","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nβ : Type u_2\nM : Type u_5\ninst✝ : AddCommMonoid M\ne : Equiv α β\nf : β → M\n⊢ Eq (finsum fun i => f (e i)) (finsum fun i' => f i')","decl":"@[to_additive]\ntheorem finprod_comp_equiv (e : α ≃ β) {f : β → M} : (∏ᶠ i, f (e i)) = ∏ᶠ i', f i' :=\n  finprod_comp e e.bijective\n\n"}
{"name":"finsum_set_coe_eq_finsum_mem","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : AddCommMonoid M\nf : α → M\ns : Set α\n⊢ Eq (finsum fun j => f ↑j) (finsum fun i => finsum fun h => f i)","decl":"@[to_additive]\ntheorem finprod_set_coe_eq_finprod_mem (s : Set α) : ∏ᶠ j : s, f j = ∏ᶠ i ∈ s, f i := by\n  rw [← finprod_mem_range, Subtype.range_coe]\n  exact Subtype.coe_injective\n\n"}
{"name":"finprod_set_coe_eq_finprod_mem","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : CommMonoid M\nf : α → M\ns : Set α\n⊢ Eq (finprod fun j => f ↑j) (finprod fun i => finprod fun h => f i)","decl":"@[to_additive]\ntheorem finprod_set_coe_eq_finprod_mem (s : Set α) : ∏ᶠ j : s, f j = ∏ᶠ i ∈ s, f i := by\n  rw [← finprod_mem_range, Subtype.range_coe]\n  exact Subtype.coe_injective\n\n"}
{"name":"finsum_subtype_eq_finsum_cond","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : AddCommMonoid M\nf : α → M\np : α → Prop\n⊢ Eq (finsum fun j => f ↑j) (finsum fun i => finsum fun x => f i)","decl":"@[to_additive]\ntheorem finprod_subtype_eq_finprod_cond (p : α → Prop) :\n    ∏ᶠ j : Subtype p, f j = ∏ᶠ (i) (_ : p i), f i :=\n  finprod_set_coe_eq_finprod_mem { i | p i }\n\n"}
{"name":"finprod_subtype_eq_finprod_cond","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : CommMonoid M\nf : α → M\np : α → Prop\n⊢ Eq (finprod fun j => f ↑j) (finprod fun i => finprod fun x => f i)","decl":"@[to_additive]\ntheorem finprod_subtype_eq_finprod_cond (p : α → Prop) :\n    ∏ᶠ j : Subtype p, f j = ∏ᶠ (i) (_ : p i), f i :=\n  finprod_set_coe_eq_finprod_mem { i | p i }\n\n"}
{"name":"finprod_mem_inter_mul_diff'","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : CommMonoid M\nf : α → M\ns t : Set α\nh : (Inter.inter s (Function.mulSupport f)).Finite\n⊢ Eq (HMul.hMul (finprod fun i => finprod fun h => f i) (finprod fun i => finprod fun h => f i)) (finprod fun i => finprod fun h => f i)","decl":"@[to_additive]\ntheorem finprod_mem_inter_mul_diff' (t : Set α) (h : (s ∩ mulSupport f).Finite) :\n    ((∏ᶠ i ∈ s ∩ t, f i) * ∏ᶠ i ∈ s \\ t, f i) = ∏ᶠ i ∈ s, f i := by\n  rw [← finprod_mem_union', inter_union_diff]\n  · rw [disjoint_iff_inf_le]\n    exact fun x hx => hx.2.2 hx.1.2\n  exacts [h.subset fun x hx => ⟨hx.1.1, hx.2⟩, h.subset fun x hx => ⟨hx.1.1, hx.2⟩]\n\n"}
{"name":"finsum_mem_inter_add_diff'","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : AddCommMonoid M\nf : α → M\ns t : Set α\nh : (Inter.inter s (Function.support f)).Finite\n⊢ Eq (HAdd.hAdd (finsum fun i => finsum fun h => f i) (finsum fun i => finsum fun h => f i)) (finsum fun i => finsum fun h => f i)","decl":"@[to_additive]\ntheorem finprod_mem_inter_mul_diff' (t : Set α) (h : (s ∩ mulSupport f).Finite) :\n    ((∏ᶠ i ∈ s ∩ t, f i) * ∏ᶠ i ∈ s \\ t, f i) = ∏ᶠ i ∈ s, f i := by\n  rw [← finprod_mem_union', inter_union_diff]\n  · rw [disjoint_iff_inf_le]\n    exact fun x hx => hx.2.2 hx.1.2\n  exacts [h.subset fun x hx => ⟨hx.1.1, hx.2⟩, h.subset fun x hx => ⟨hx.1.1, hx.2⟩]\n\n"}
{"name":"finprod_mem_inter_mul_diff","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : CommMonoid M\nf : α → M\ns t : Set α\nh : s.Finite\n⊢ Eq (HMul.hMul (finprod fun i => finprod fun h => f i) (finprod fun i => finprod fun h => f i)) (finprod fun i => finprod fun h => f i)","decl":"@[to_additive]\ntheorem finprod_mem_inter_mul_diff (t : Set α) (h : s.Finite) :\n    ((∏ᶠ i ∈ s ∩ t, f i) * ∏ᶠ i ∈ s \\ t, f i) = ∏ᶠ i ∈ s, f i :=\n  finprod_mem_inter_mul_diff' _ <| h.inter_of_left _\n\n"}
{"name":"finsum_mem_inter_add_diff","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : AddCommMonoid M\nf : α → M\ns t : Set α\nh : s.Finite\n⊢ Eq (HAdd.hAdd (finsum fun i => finsum fun h => f i) (finsum fun i => finsum fun h => f i)) (finsum fun i => finsum fun h => f i)","decl":"@[to_additive]\ntheorem finprod_mem_inter_mul_diff (t : Set α) (h : s.Finite) :\n    ((∏ᶠ i ∈ s ∩ t, f i) * ∏ᶠ i ∈ s \\ t, f i) = ∏ᶠ i ∈ s, f i :=\n  finprod_mem_inter_mul_diff' _ <| h.inter_of_left _\n\n"}
{"name":"finsum_mem_add_diff'","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : AddCommMonoid M\nf : α → M\ns t : Set α\nhst : HasSubset.Subset s t\nht : (Inter.inter t (Function.support f)).Finite\n⊢ Eq (HAdd.hAdd (finsum fun i => finsum fun h => f i) (finsum fun i => finsum fun h => f i)) (finsum fun i => finsum fun h => f i)","decl":"/-- A more general version of `finprod_mem_mul_diff` that requires `t ∩ mulSupport f` rather than\n`t` to be finite. -/\n@[to_additive\n      \"A more general version of `finsum_mem_add_diff` that requires `t ∩ support f` rather\n      than `t` to be finite.\"]\ntheorem finprod_mem_mul_diff' (hst : s ⊆ t) (ht : (t ∩ mulSupport f).Finite) :\n    ((∏ᶠ i ∈ s, f i) * ∏ᶠ i ∈ t \\ s, f i) = ∏ᶠ i ∈ t, f i := by\n  rw [← finprod_mem_inter_mul_diff' _ ht, inter_eq_self_of_subset_right hst]\n\n"}
{"name":"finprod_mem_mul_diff'","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : CommMonoid M\nf : α → M\ns t : Set α\nhst : HasSubset.Subset s t\nht : (Inter.inter t (Function.mulSupport f)).Finite\n⊢ Eq (HMul.hMul (finprod fun i => finprod fun h => f i) (finprod fun i => finprod fun h => f i)) (finprod fun i => finprod fun h => f i)","decl":"/-- A more general version of `finprod_mem_mul_diff` that requires `t ∩ mulSupport f` rather than\n`t` to be finite. -/\n@[to_additive\n      \"A more general version of `finsum_mem_add_diff` that requires `t ∩ support f` rather\n      than `t` to be finite.\"]\ntheorem finprod_mem_mul_diff' (hst : s ⊆ t) (ht : (t ∩ mulSupport f).Finite) :\n    ((∏ᶠ i ∈ s, f i) * ∏ᶠ i ∈ t \\ s, f i) = ∏ᶠ i ∈ t, f i := by\n  rw [← finprod_mem_inter_mul_diff' _ ht, inter_eq_self_of_subset_right hst]\n\n"}
{"name":"finsum_mem_add_diff","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : AddCommMonoid M\nf : α → M\ns t : Set α\nhst : HasSubset.Subset s t\nht : t.Finite\n⊢ Eq (HAdd.hAdd (finsum fun i => finsum fun h => f i) (finsum fun i => finsum fun h => f i)) (finsum fun i => finsum fun h => f i)","decl":"/-- Given a finite set `t` and a subset `s` of `t`, the product of `f i` over `i ∈ s`\ntimes the product of `f i` over `t \\ s` equals the product of `f i` over `i ∈ t`. -/\n@[to_additive\n      \"Given a finite set `t` and a subset `s` of `t`, the sum of `f i` over `i ∈ s` plus\n      the sum of `f i` over `t \\\\ s` equals the sum of `f i` over `i ∈ t`.\"]\ntheorem finprod_mem_mul_diff (hst : s ⊆ t) (ht : t.Finite) :\n    ((∏ᶠ i ∈ s, f i) * ∏ᶠ i ∈ t \\ s, f i) = ∏ᶠ i ∈ t, f i :=\n  finprod_mem_mul_diff' hst (ht.inter_of_left _)\n\n"}
{"name":"finprod_mem_mul_diff","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : CommMonoid M\nf : α → M\ns t : Set α\nhst : HasSubset.Subset s t\nht : t.Finite\n⊢ Eq (HMul.hMul (finprod fun i => finprod fun h => f i) (finprod fun i => finprod fun h => f i)) (finprod fun i => finprod fun h => f i)","decl":"/-- Given a finite set `t` and a subset `s` of `t`, the product of `f i` over `i ∈ s`\ntimes the product of `f i` over `t \\ s` equals the product of `f i` over `i ∈ t`. -/\n@[to_additive\n      \"Given a finite set `t` and a subset `s` of `t`, the sum of `f i` over `i ∈ s` plus\n      the sum of `f i` over `t \\\\ s` equals the sum of `f i` over `i ∈ t`.\"]\ntheorem finprod_mem_mul_diff (hst : s ⊆ t) (ht : t.Finite) :\n    ((∏ᶠ i ∈ s, f i) * ∏ᶠ i ∈ t \\ s, f i) = ∏ᶠ i ∈ t, f i :=\n  finprod_mem_mul_diff' hst (ht.inter_of_left _)\n\n"}
{"name":"finprod_mem_iUnion","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nι : Type u_3\nM : Type u_5\ninst✝¹ : CommMonoid M\nf : α → M\ninst✝ : Finite ι\nt : ι → Set α\nh : Pairwise (Function.onFun Disjoint t)\nht : ∀ (i : ι), (t i).Finite\n⊢ Eq (finprod fun a => finprod fun h => f a) (finprod fun i => finprod fun a => finprod fun h => f a)","decl":"/-- Given a family of pairwise disjoint finite sets `t i` indexed by a finite type, the product of\n`f a` over the union `⋃ i, t i` is equal to the product over all indexes `i` of the products of\n`f a` over `a ∈ t i`. -/\n@[to_additive\n      \"Given a family of pairwise disjoint finite sets `t i` indexed by a finite type, the\n      sum of `f a` over the union `⋃ i, t i` is equal to the sum over all indexes `i` of the\n      sums of `f a` over `a ∈ t i`.\"]\ntheorem finprod_mem_iUnion [Finite ι] {t : ι → Set α} (h : Pairwise (Disjoint on t))\n    (ht : ∀ i, (t i).Finite) : ∏ᶠ a ∈ ⋃ i : ι, t i, f a = ∏ᶠ i, ∏ᶠ a ∈ t i, f a := by\n  cases nonempty_fintype ι\n  lift t to ι → Finset α using ht\n  classical\n    rw [← biUnion_univ, ← Finset.coe_univ, ← Finset.coe_biUnion, finprod_mem_coe_finset,\n      Finset.prod_biUnion]\n    · simp only [finprod_mem_coe_finset, finprod_eq_prod_of_fintype]\n    · exact fun x _ y _ hxy => Finset.disjoint_coe.1 (h hxy)\n\n"}
{"name":"finsum_mem_iUnion","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nι : Type u_3\nM : Type u_5\ninst✝¹ : AddCommMonoid M\nf : α → M\ninst✝ : Finite ι\nt : ι → Set α\nh : Pairwise (Function.onFun Disjoint t)\nht : ∀ (i : ι), (t i).Finite\n⊢ Eq (finsum fun a => finsum fun h => f a) (finsum fun i => finsum fun a => finsum fun h => f a)","decl":"/-- Given a family of pairwise disjoint finite sets `t i` indexed by a finite type, the product of\n`f a` over the union `⋃ i, t i` is equal to the product over all indexes `i` of the products of\n`f a` over `a ∈ t i`. -/\n@[to_additive\n      \"Given a family of pairwise disjoint finite sets `t i` indexed by a finite type, the\n      sum of `f a` over the union `⋃ i, t i` is equal to the sum over all indexes `i` of the\n      sums of `f a` over `a ∈ t i`.\"]\ntheorem finprod_mem_iUnion [Finite ι] {t : ι → Set α} (h : Pairwise (Disjoint on t))\n    (ht : ∀ i, (t i).Finite) : ∏ᶠ a ∈ ⋃ i : ι, t i, f a = ∏ᶠ i, ∏ᶠ a ∈ t i, f a := by\n  cases nonempty_fintype ι\n  lift t to ι → Finset α using ht\n  classical\n    rw [← biUnion_univ, ← Finset.coe_univ, ← Finset.coe_biUnion, finprod_mem_coe_finset,\n      Finset.prod_biUnion]\n    · simp only [finprod_mem_coe_finset, finprod_eq_prod_of_fintype]\n    · exact fun x _ y _ hxy => Finset.disjoint_coe.1 (h hxy)\n\n"}
{"name":"finprod_mem_biUnion","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nι : Type u_3\nM : Type u_5\ninst✝ : CommMonoid M\nf : α → M\nI : Set ι\nt : ι → Set α\nh : I.PairwiseDisjoint t\nhI : I.Finite\nht : ∀ (i : ι), Membership.mem I i → (t i).Finite\n⊢ Eq (finprod fun a => finprod fun h => f a) (finprod fun i => finprod fun h => finprod fun j => finprod fun h => f j)","decl":"/-- Given a family of sets `t : ι → Set α`, a finite set `I` in the index type such that all sets\n`t i`, `i ∈ I`, are finite, if all `t i`, `i ∈ I`, are pairwise disjoint, then the product of `f a`\nover `a ∈ ⋃ i ∈ I, t i` is equal to the product over `i ∈ I` of the products of `f a` over\n`a ∈ t i`. -/\n@[to_additive\n      \"Given a family of sets `t : ι → Set α`, a finite set `I` in the index type such that\n      all sets `t i`, `i ∈ I`, are finite, if all `t i`, `i ∈ I`, are pairwise disjoint, then the\n      sum of `f a` over `a ∈ ⋃ i ∈ I, t i` is equal to the sum over `i ∈ I` of the sums of `f a`\n      over `a ∈ t i`.\"]\ntheorem finprod_mem_biUnion {I : Set ι} {t : ι → Set α} (h : I.PairwiseDisjoint t) (hI : I.Finite)\n    (ht : ∀ i ∈ I, (t i).Finite) : ∏ᶠ a ∈ ⋃ x ∈ I, t x, f a = ∏ᶠ i ∈ I, ∏ᶠ j ∈ t i, f j := by\n  haveI := hI.fintype\n  rw [biUnion_eq_iUnion, finprod_mem_iUnion, ← finprod_set_coe_eq_finprod_mem]\n  exacts [fun x y hxy => h x.2 y.2 (Subtype.coe_injective.ne hxy), fun b => ht b b.2]\n\n"}
{"name":"finsum_mem_biUnion","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nι : Type u_3\nM : Type u_5\ninst✝ : AddCommMonoid M\nf : α → M\nI : Set ι\nt : ι → Set α\nh : I.PairwiseDisjoint t\nhI : I.Finite\nht : ∀ (i : ι), Membership.mem I i → (t i).Finite\n⊢ Eq (finsum fun a => finsum fun h => f a) (finsum fun i => finsum fun h => finsum fun j => finsum fun h => f j)","decl":"/-- Given a family of sets `t : ι → Set α`, a finite set `I` in the index type such that all sets\n`t i`, `i ∈ I`, are finite, if all `t i`, `i ∈ I`, are pairwise disjoint, then the product of `f a`\nover `a ∈ ⋃ i ∈ I, t i` is equal to the product over `i ∈ I` of the products of `f a` over\n`a ∈ t i`. -/\n@[to_additive\n      \"Given a family of sets `t : ι → Set α`, a finite set `I` in the index type such that\n      all sets `t i`, `i ∈ I`, are finite, if all `t i`, `i ∈ I`, are pairwise disjoint, then the\n      sum of `f a` over `a ∈ ⋃ i ∈ I, t i` is equal to the sum over `i ∈ I` of the sums of `f a`\n      over `a ∈ t i`.\"]\ntheorem finprod_mem_biUnion {I : Set ι} {t : ι → Set α} (h : I.PairwiseDisjoint t) (hI : I.Finite)\n    (ht : ∀ i ∈ I, (t i).Finite) : ∏ᶠ a ∈ ⋃ x ∈ I, t x, f a = ∏ᶠ i ∈ I, ∏ᶠ j ∈ t i, f j := by\n  haveI := hI.fintype\n  rw [biUnion_eq_iUnion, finprod_mem_iUnion, ← finprod_set_coe_eq_finprod_mem]\n  exacts [fun x y hxy => h x.2 y.2 (Subtype.coe_injective.ne hxy), fun b => ht b b.2]\n\n"}
{"name":"finprod_mem_sUnion","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : CommMonoid M\nf : α → M\nt : Set (Set α)\nh : t.PairwiseDisjoint id\nht₀ : t.Finite\nht₁ : ∀ (x : Set α), Membership.mem t x → x.Finite\n⊢ Eq (finprod fun a => finprod fun h => f a) (finprod fun s => finprod fun h => finprod fun a => finprod fun h => f a)","decl":"/-- If `t` is a finite set of pairwise disjoint finite sets, then the product of `f a`\nover `a ∈ ⋃₀ t` is the product over `s ∈ t` of the products of `f a` over `a ∈ s`. -/\n@[to_additive\n      \"If `t` is a finite set of pairwise disjoint finite sets, then the sum of `f a` over\n      `a ∈ ⋃₀ t` is the sum over `s ∈ t` of the sums of `f a` over `a ∈ s`.\"]\ntheorem finprod_mem_sUnion {t : Set (Set α)} (h : t.PairwiseDisjoint id) (ht₀ : t.Finite)\n    (ht₁ : ∀ x ∈ t, Set.Finite x) : ∏ᶠ a ∈ ⋃₀ t, f a = ∏ᶠ s ∈ t, ∏ᶠ a ∈ s, f a := by\n  rw [Set.sUnion_eq_biUnion]\n  exact finprod_mem_biUnion h ht₀ ht₁\n\n"}
{"name":"finsum_mem_sUnion","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : AddCommMonoid M\nf : α → M\nt : Set (Set α)\nh : t.PairwiseDisjoint id\nht₀ : t.Finite\nht₁ : ∀ (x : Set α), Membership.mem t x → x.Finite\n⊢ Eq (finsum fun a => finsum fun h => f a) (finsum fun s => finsum fun h => finsum fun a => finsum fun h => f a)","decl":"/-- If `t` is a finite set of pairwise disjoint finite sets, then the product of `f a`\nover `a ∈ ⋃₀ t` is the product over `s ∈ t` of the products of `f a` over `a ∈ s`. -/\n@[to_additive\n      \"If `t` is a finite set of pairwise disjoint finite sets, then the sum of `f a` over\n      `a ∈ ⋃₀ t` is the sum over `s ∈ t` of the sums of `f a` over `a ∈ s`.\"]\ntheorem finprod_mem_sUnion {t : Set (Set α)} (h : t.PairwiseDisjoint id) (ht₀ : t.Finite)\n    (ht₁ : ∀ x ∈ t, Set.Finite x) : ∏ᶠ a ∈ ⋃₀ t, f a = ∏ᶠ s ∈ t, ∏ᶠ a ∈ s, f a := by\n  rw [Set.sUnion_eq_biUnion]\n  exact finprod_mem_biUnion h ht₀ ht₁\n\n"}
{"name":"finsum_option","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : AddCommMonoid M\nf : Option α → M\nhf : (Function.support (Function.comp f Option.some)).Finite\n⊢ Eq (finsum fun o => f o) (HAdd.hAdd (f Option.none) (finsum fun a => f (Option.some a)))","decl":"@[to_additive]\nlemma finprod_option {f : Option α → M} (hf : (mulSupport (f ∘ some)).Finite) :\n    ∏ᶠ o, f o = f none * ∏ᶠ a, f (some a) := by\n  replace hf : (mulSupport f).Finite := by simpa [finite_option]\n  convert finprod_mem_insert' f (show none ∉ Set.range Option.some by aesop)\n    (hf.subset inter_subset_right)\n  · aesop\n  · rw [finprod_mem_range]\n    exact Option.some_injective _\n\n"}
{"name":"finprod_option","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : CommMonoid M\nf : Option α → M\nhf : (Function.mulSupport (Function.comp f Option.some)).Finite\n⊢ Eq (finprod fun o => f o) (HMul.hMul (f Option.none) (finprod fun a => f (Option.some a)))","decl":"@[to_additive]\nlemma finprod_option {f : Option α → M} (hf : (mulSupport (f ∘ some)).Finite) :\n    ∏ᶠ o, f o = f none * ∏ᶠ a, f (some a) := by\n  replace hf : (mulSupport f).Finite := by simpa [finite_option]\n  convert finprod_mem_insert' f (show none ∉ Set.range Option.some by aesop)\n    (hf.subset inter_subset_right)\n  · aesop\n  · rw [finprod_mem_range]\n    exact Option.some_injective _\n\n"}
{"name":"mul_finprod_cond_ne","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : CommMonoid M\nf : α → M\na : α\nhf : (Function.mulSupport f).Finite\n⊢ Eq (HMul.hMul (f a) (finprod fun i => finprod fun x => f i)) (finprod fun i => f i)","decl":"@[to_additive]\ntheorem mul_finprod_cond_ne (a : α) (hf : (mulSupport f).Finite) :\n    (f a * ∏ᶠ (i) (_ : i ≠ a), f i) = ∏ᶠ i, f i := by\n  classical\n    rw [finprod_eq_prod _ hf]\n    have h : ∀ x : α, f x ≠ 1 → (x ≠ a ↔ x ∈ hf.toFinset \\ {a}) := by\n      intro x hx\n      rw [Finset.mem_sdiff, Finset.mem_singleton, Finite.mem_toFinset, mem_mulSupport]\n      exact ⟨fun h => And.intro hx h, fun h => h.2⟩\n    rw [finprod_cond_eq_prod_of_cond_iff f (fun hx => h _ hx), Finset.sdiff_singleton_eq_erase]\n    by_cases ha : a ∈ mulSupport f\n    · apply Finset.mul_prod_erase _ _ ((Finite.mem_toFinset _).mpr ha)\n    · rw [mem_mulSupport, not_not] at ha\n      rw [ha, one_mul]\n      apply Finset.prod_erase _ ha\n\n"}
{"name":"add_finsum_cond_ne","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : AddCommMonoid M\nf : α → M\na : α\nhf : (Function.support f).Finite\n⊢ Eq (HAdd.hAdd (f a) (finsum fun i => finsum fun x => f i)) (finsum fun i => f i)","decl":"@[to_additive]\ntheorem mul_finprod_cond_ne (a : α) (hf : (mulSupport f).Finite) :\n    (f a * ∏ᶠ (i) (_ : i ≠ a), f i) = ∏ᶠ i, f i := by\n  classical\n    rw [finprod_eq_prod _ hf]\n    have h : ∀ x : α, f x ≠ 1 → (x ≠ a ↔ x ∈ hf.toFinset \\ {a}) := by\n      intro x hx\n      rw [Finset.mem_sdiff, Finset.mem_singleton, Finite.mem_toFinset, mem_mulSupport]\n      exact ⟨fun h => And.intro hx h, fun h => h.2⟩\n    rw [finprod_cond_eq_prod_of_cond_iff f (fun hx => h _ hx), Finset.sdiff_singleton_eq_erase]\n    by_cases ha : a ∈ mulSupport f\n    · apply Finset.mul_prod_erase _ _ ((Finite.mem_toFinset _).mpr ha)\n    · rw [mem_mulSupport, not_not] at ha\n      rw [ha, one_mul]\n      apply Finset.prod_erase _ ha\n\n"}
{"name":"finsum_mem_comm","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nβ : Type u_2\nM : Type u_5\ninst✝ : AddCommMonoid M\ns : Set α\nt : Set β\nf : α → β → M\nhs : s.Finite\nht : t.Finite\n⊢ Eq (finsum fun i => finsum fun h => finsum fun j => finsum fun h => f i j) (finsum fun j => finsum fun h => finsum fun i => finsum fun h => f i j)","decl":"/-- If `s : Set α` and `t : Set β` are finite sets, then taking the product over `s` commutes with\ntaking the product over `t`. -/\n@[to_additive\n      \"If `s : Set α` and `t : Set β` are finite sets, then summing over `s` commutes with\n      summing over `t`.\"]\ntheorem finprod_mem_comm {s : Set α} {t : Set β} (f : α → β → M) (hs : s.Finite) (ht : t.Finite) :\n    (∏ᶠ i ∈ s, ∏ᶠ j ∈ t, f i j) = ∏ᶠ j ∈ t, ∏ᶠ i ∈ s, f i j := by\n  lift s to Finset α using hs; lift t to Finset β using ht\n  simp only [finprod_mem_coe_finset]\n  exact Finset.prod_comm\n\n"}
{"name":"finprod_mem_comm","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nβ : Type u_2\nM : Type u_5\ninst✝ : CommMonoid M\ns : Set α\nt : Set β\nf : α → β → M\nhs : s.Finite\nht : t.Finite\n⊢ Eq (finprod fun i => finprod fun h => finprod fun j => finprod fun h => f i j) (finprod fun j => finprod fun h => finprod fun i => finprod fun h => f i j)","decl":"/-- If `s : Set α` and `t : Set β` are finite sets, then taking the product over `s` commutes with\ntaking the product over `t`. -/\n@[to_additive\n      \"If `s : Set α` and `t : Set β` are finite sets, then summing over `s` commutes with\n      summing over `t`.\"]\ntheorem finprod_mem_comm {s : Set α} {t : Set β} (f : α → β → M) (hs : s.Finite) (ht : t.Finite) :\n    (∏ᶠ i ∈ s, ∏ᶠ j ∈ t, f i j) = ∏ᶠ j ∈ t, ∏ᶠ i ∈ s, f i j := by\n  lift s to Finset α using hs; lift t to Finset β using ht\n  simp only [finprod_mem_coe_finset]\n  exact Finset.prod_comm\n\n"}
{"name":"finsum_mem_induction","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : AddCommMonoid M\nf : α → M\ns : Set α\np : M → Prop\nhp₀ : p 0\nhp₁ : ∀ (x y : M), p x → p y → p (HAdd.hAdd x y)\nhp₂ : ∀ (x : α), Membership.mem s x → p (f x)\n⊢ p (finsum fun i => finsum fun h => f i)","decl":"/-- To prove a property of a finite product, it suffices to prove that the property is\nmultiplicative and holds on factors. -/\n@[to_additive\n      \"To prove a property of a finite sum, it suffices to prove that the property is\n      additive and holds on summands.\"]\ntheorem finprod_mem_induction (p : M → Prop) (hp₀ : p 1) (hp₁ : ∀ x y, p x → p y → p (x * y))\n    (hp₂ : ∀ x ∈ s, p <| f x) : p (∏ᶠ i ∈ s, f i) :=\n  finprod_induction _ hp₀ hp₁ fun x => finprod_induction _ hp₀ hp₁ <| hp₂ x\n\n"}
{"name":"finprod_mem_induction","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : CommMonoid M\nf : α → M\ns : Set α\np : M → Prop\nhp₀ : p 1\nhp₁ : ∀ (x y : M), p x → p y → p (HMul.hMul x y)\nhp₂ : ∀ (x : α), Membership.mem s x → p (f x)\n⊢ p (finprod fun i => finprod fun h => f i)","decl":"/-- To prove a property of a finite product, it suffices to prove that the property is\nmultiplicative and holds on factors. -/\n@[to_additive\n      \"To prove a property of a finite sum, it suffices to prove that the property is\n      additive and holds on summands.\"]\ntheorem finprod_mem_induction (p : M → Prop) (hp₀ : p 1) (hp₁ : ∀ x y, p x → p y → p (x * y))\n    (hp₂ : ∀ x ∈ s, p <| f x) : p (∏ᶠ i ∈ s, f i) :=\n  finprod_induction _ hp₀ hp₁ fun x => finprod_induction _ hp₀ hp₁ <| hp₂ x\n\n"}
{"name":"finprod_cond_nonneg","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nR : Type u_7\ninst✝ : OrderedCommSemiring R\np : α → Prop\nf : α → R\nhf : ∀ (x : α), p x → LE.le 0 (f x)\n⊢ LE.le 0 (finprod fun x => finprod fun x_1 => f x)","decl":"theorem finprod_cond_nonneg {R : Type*} [OrderedCommSemiring R] {p : α → Prop} {f : α → R}\n    (hf : ∀ x, p x → 0 ≤ f x) : 0 ≤ ∏ᶠ (x) (_ : p x), f x :=\n  finprod_nonneg fun x => finprod_nonneg <| hf x\n\n"}
{"name":"single_le_finprod","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nM : Type u_7\ninst✝ : OrderedCommMonoid M\ni : α\nf : α → M\nhf : (Function.mulSupport f).Finite\nh : ∀ (j : α), LE.le 1 (f j)\n⊢ LE.le (f i) (finprod fun j => f j)","decl":"@[to_additive]\ntheorem single_le_finprod {M : Type*} [OrderedCommMonoid M] (i : α) {f : α → M}\n    (hf : (mulSupport f).Finite) (h : ∀ j, 1 ≤ f j) : f i ≤ ∏ᶠ j, f j := by\n  classical calc\n      f i ≤ ∏ j ∈ insert i hf.toFinset, f j :=\n        Finset.single_le_prod' (fun j _ => h j) (Finset.mem_insert_self _ _)\n      _ = ∏ᶠ j, f j :=\n        (finprod_eq_prod_of_mulSupport_toFinset_subset _ hf (Finset.subset_insert _ _)).symm\n\n"}
{"name":"single_le_finsum","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nM : Type u_7\ninst✝ : OrderedAddCommMonoid M\ni : α\nf : α → M\nhf : (Function.support f).Finite\nh : ∀ (j : α), LE.le 0 (f j)\n⊢ LE.le (f i) (finsum fun j => f j)","decl":"@[to_additive]\ntheorem single_le_finprod {M : Type*} [OrderedCommMonoid M] (i : α) {f : α → M}\n    (hf : (mulSupport f).Finite) (h : ∀ j, 1 ≤ f j) : f i ≤ ∏ᶠ j, f j := by\n  classical calc\n      f i ≤ ∏ j ∈ insert i hf.toFinset, f j :=\n        Finset.single_le_prod' (fun j _ => h j) (Finset.mem_insert_self _ _)\n      _ = ∏ᶠ j, f j :=\n        (finprod_eq_prod_of_mulSupport_toFinset_subset _ hf (Finset.subset_insert _ _)).symm\n\n"}
{"name":"finprod_eq_zero","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nM₀ : Type u_7\ninst✝ : CommMonoidWithZero M₀\nf : α → M₀\nx : α\nhx : Eq (f x) 0\nhf : (Function.mulSupport f).Finite\n⊢ Eq (finprod fun x => f x) 0","decl":"theorem finprod_eq_zero {M₀ : Type*} [CommMonoidWithZero M₀] (f : α → M₀) (x : α) (hx : f x = 0)\n    (hf : (mulSupport f).Finite) : ∏ᶠ x, f x = 0 := by\n  nontriviality\n  rw [finprod_eq_prod f hf]\n  refine Finset.prod_eq_zero (hf.mem_toFinset.2 ?_) hx\n  simp [hx]\n\n"}
{"name":"finsum_sum_comm","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nβ : Type u_2\nM : Type u_5\ninst✝ : AddCommMonoid M\ns : Finset β\nf : α → β → M\nh : ∀ (b : β), Membership.mem s b → (Function.support fun a => f a b).Finite\n⊢ Eq (finsum fun a => s.sum fun b => f a b) (s.sum fun b => finsum fun a => f a b)","decl":"@[to_additive]\ntheorem finprod_prod_comm (s : Finset β) (f : α → β → M)\n    (h : ∀ b ∈ s, (mulSupport fun a => f a b).Finite) :\n    (∏ᶠ a : α, ∏ b ∈ s, f a b) = ∏ b ∈ s, ∏ᶠ a : α, f a b := by\n  have hU :\n    (mulSupport fun a => ∏ b ∈ s, f a b) ⊆\n      (s.finite_toSet.biUnion fun b hb => h b (Finset.mem_coe.1 hb)).toFinset := by\n    rw [Finite.coe_toFinset]\n    intro x hx\n    simp only [exists_prop, mem_iUnion, Ne, mem_mulSupport, Finset.mem_coe]\n    contrapose! hx\n    rw [mem_mulSupport, not_not, Finset.prod_congr rfl hx, Finset.prod_const_one]\n  rw [finprod_eq_prod_of_mulSupport_subset _ hU, Finset.prod_comm]\n  refine Finset.prod_congr rfl fun b hb => (finprod_eq_prod_of_mulSupport_subset _ ?_).symm\n  intro a ha\n  simp only [Finite.coe_toFinset, mem_iUnion]\n  exact ⟨b, hb, ha⟩\n\n"}
{"name":"finprod_prod_comm","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nβ : Type u_2\nM : Type u_5\ninst✝ : CommMonoid M\ns : Finset β\nf : α → β → M\nh : ∀ (b : β), Membership.mem s b → (Function.mulSupport fun a => f a b).Finite\n⊢ Eq (finprod fun a => s.prod fun b => f a b) (s.prod fun b => finprod fun a => f a b)","decl":"@[to_additive]\ntheorem finprod_prod_comm (s : Finset β) (f : α → β → M)\n    (h : ∀ b ∈ s, (mulSupport fun a => f a b).Finite) :\n    (∏ᶠ a : α, ∏ b ∈ s, f a b) = ∏ b ∈ s, ∏ᶠ a : α, f a b := by\n  have hU :\n    (mulSupport fun a => ∏ b ∈ s, f a b) ⊆\n      (s.finite_toSet.biUnion fun b hb => h b (Finset.mem_coe.1 hb)).toFinset := by\n    rw [Finite.coe_toFinset]\n    intro x hx\n    simp only [exists_prop, mem_iUnion, Ne, mem_mulSupport, Finset.mem_coe]\n    contrapose! hx\n    rw [mem_mulSupport, not_not, Finset.prod_congr rfl hx, Finset.prod_const_one]\n  rw [finprod_eq_prod_of_mulSupport_subset _ hU, Finset.prod_comm]\n  refine Finset.prod_congr rfl fun b hb => (finprod_eq_prod_of_mulSupport_subset _ ?_).symm\n  intro a ha\n  simp only [Finite.coe_toFinset, mem_iUnion]\n  exact ⟨b, hb, ha⟩\n\n"}
{"name":"prod_finprod_comm","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nβ : Type u_2\nM : Type u_5\ninst✝ : CommMonoid M\ns : Finset α\nf : α → β → M\nh : ∀ (a : α), Membership.mem s a → (Function.mulSupport (f a)).Finite\n⊢ Eq (s.prod fun a => finprod fun b => f a b) (finprod fun b => s.prod fun a => f a b)","decl":"@[to_additive]\ntheorem prod_finprod_comm (s : Finset α) (f : α → β → M) (h : ∀ a ∈ s, (mulSupport (f a)).Finite) :\n    (∏ a ∈ s, ∏ᶠ b : β, f a b) = ∏ᶠ b : β, ∏ a ∈ s, f a b :=\n  (finprod_prod_comm s (fun b a => f a b) h).symm\n\n"}
{"name":"sum_finsum_comm","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nβ : Type u_2\nM : Type u_5\ninst✝ : AddCommMonoid M\ns : Finset α\nf : α → β → M\nh : ∀ (a : α), Membership.mem s a → (Function.support (f a)).Finite\n⊢ Eq (s.sum fun a => finsum fun b => f a b) (finsum fun b => s.sum fun a => f a b)","decl":"@[to_additive]\ntheorem prod_finprod_comm (s : Finset α) (f : α → β → M) (h : ∀ a ∈ s, (mulSupport (f a)).Finite) :\n    (∏ a ∈ s, ∏ᶠ b : β, f a b) = ∏ᶠ b : β, ∏ a ∈ s, f a b :=\n  (finprod_prod_comm s (fun b a => f a b) h).symm\n\n"}
{"name":"mul_finsum","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nR : Type u_7\ninst✝ : Semiring R\nf : α → R\nr : R\nh : (Function.support f).Finite\n⊢ Eq (HMul.hMul r (finsum fun a => f a)) (finsum fun a => HMul.hMul r (f a))","decl":"theorem mul_finsum {R : Type*} [Semiring R] (f : α → R) (r : R) (h : (support f).Finite) :\n    (r * ∑ᶠ a : α, f a) = ∑ᶠ a : α, r * f a :=\n  (AddMonoidHom.mulLeft r).map_finsum h\n\n"}
{"name":"finsum_mul","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nR : Type u_7\ninst✝ : Semiring R\nf : α → R\nr : R\nh : (Function.support f).Finite\n⊢ Eq (HMul.hMul (finsum fun a => f a) r) (finsum fun a => HMul.hMul (f a) r)","decl":"theorem finsum_mul {R : Type*} [Semiring R] (f : α → R) (r : R) (h : (support f).Finite) :\n    (∑ᶠ a : α, f a) * r = ∑ᶠ a : α, f a * r :=\n  (AddMonoidHom.mulRight r).map_finsum h\n\n"}
{"name":"finprod_apply","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"N : Type u_6\ninst✝ : CommMonoid N\nα : Type u_7\nι : Type u_8\nf : ι → α → N\nhf : (Function.mulSupport f).Finite\na : α\n⊢ Eq (finprod (fun i => f i) a) (finprod fun i => f i a)","decl":"@[to_additive (attr := simp)]\nlemma finprod_apply {α ι : Type*} {f : ι → α → N} (hf : (mulSupport f).Finite) (a : α) :\n    (∏ᶠ i, f i) a = ∏ᶠ i, f i a := by\n  classical\n  have hf' : (mulSupport fun i ↦ f i a).Finite := hf.subset (by aesop)\n  simp only [finprod_def, dif_pos, hf, hf', Finset.prod_apply]\n  symm\n  apply Finset.prod_subset <;> aesop\n\n"}
{"name":"finsum_apply","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"N : Type u_6\ninst✝ : AddCommMonoid N\nα : Type u_7\nι : Type u_8\nf : ι → α → N\nhf : (Function.support f).Finite\na : α\n⊢ Eq (finsum (fun i => f i) a) (finsum fun i => f i a)","decl":"@[to_additive (attr := simp)]\nlemma finprod_apply {α ι : Type*} {f : ι → α → N} (hf : (mulSupport f).Finite) (a : α) :\n    (∏ᶠ i, f i) a = ∏ᶠ i, f i a := by\n  classical\n  have hf' : (mulSupport fun i ↦ f i a).Finite := hf.subset (by aesop)\n  simp only [finprod_def, dif_pos, hf, hf', Finset.prod_apply]\n  symm\n  apply Finset.prod_subset <;> aesop\n\n"}
{"name":"Finset.mulSupport_of_fiberwise_prod_subset_image","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nβ : Type u_2\nM : Type u_5\ninst✝¹ : CommMonoid M\ninst✝ : DecidableEq β\ns : Finset α\nf : α → M\ng : α → β\n⊢ HasSubset.Subset (Function.mulSupport fun b => (Finset.filter (fun a => Eq (g a) b) s).prod f) ↑(Finset.image g s)","decl":"@[to_additive]\ntheorem Finset.mulSupport_of_fiberwise_prod_subset_image [DecidableEq β] (s : Finset α) (f : α → M)\n    (g : α → β) : (mulSupport fun b => (s.filter fun a => g a = b).prod f) ⊆ s.image g := by\n  simp only [Finset.coe_image, Set.mem_image, Finset.mem_coe, Function.support_subset_iff]\n  intro b h\n  suffices (s.filter fun a : α => g a = b).Nonempty by\n    simpa only [fiber_nonempty_iff_mem_image, Finset.mem_image, exists_prop]\n  exact Finset.nonempty_of_prod_ne_one h\n\n"}
{"name":"Finset.support_of_fiberwise_sum_subset_image","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nβ : Type u_2\nM : Type u_5\ninst✝¹ : AddCommMonoid M\ninst✝ : DecidableEq β\ns : Finset α\nf : α → M\ng : α → β\n⊢ HasSubset.Subset (Function.support fun b => (Finset.filter (fun a => Eq (g a) b) s).sum f) ↑(Finset.image g s)","decl":"@[to_additive]\ntheorem Finset.mulSupport_of_fiberwise_prod_subset_image [DecidableEq β] (s : Finset α) (f : α → M)\n    (g : α → β) : (mulSupport fun b => (s.filter fun a => g a = b).prod f) ⊆ s.image g := by\n  simp only [Finset.coe_image, Set.mem_image, Finset.mem_coe, Function.support_subset_iff]\n  intro b h\n  suffices (s.filter fun a : α => g a = b).Nonempty by\n    simpa only [fiber_nonempty_iff_mem_image, Finset.mem_image, exists_prop]\n  exact Finset.nonempty_of_prod_ne_one h\n\n"}
{"name":"finprod_mem_finset_product'","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nβ : Type u_2\nM : Type u_5\ninst✝² : CommMonoid M\ninst✝¹ : DecidableEq α\ninst✝ : DecidableEq β\ns : Finset (Prod α β)\nf : Prod α β → M\n⊢ Eq (finprod fun ab => finprod fun x => f ab) (finprod fun a => finprod fun b => finprod fun x => f { fst := a, snd := b })","decl":"/-- Note that `b ∈ (s.filter (fun ab => Prod.fst ab = a)).image Prod.snd` iff `(a, b) ∈ s` so\nwe can simplify the right hand side of this lemma. However the form stated here is more useful for\niterating this lemma, e.g., if we have `f : α × β × γ → M`. -/\n@[to_additive\n      \"Note that `b ∈ (s.filter (fun ab => Prod.fst ab = a)).image Prod.snd` iff `(a, b) ∈ s` so\n      we can simplify the right hand side of this lemma. However the form stated here is more\n      useful for iterating this lemma, e.g., if we have `f : α × β × γ → M`.\"]\ntheorem finprod_mem_finset_product' [DecidableEq α] [DecidableEq β] (s : Finset (α × β))\n    (f : α × β → M) :\n    (∏ᶠ (ab) (_ : ab ∈ s), f ab) =\n      ∏ᶠ (a) (b) (_ : b ∈ (s.filter fun ab => Prod.fst ab = a).image Prod.snd), f (a, b) := by\n  have (a) :\n      ∏ i ∈ (s.filter fun ab => Prod.fst ab = a).image Prod.snd, f (a, i) =\n        (s.filter (Prod.fst · = a)).prod f := by\n    refine Finset.prod_nbij' (fun b ↦ (a, b)) Prod.snd ?_ ?_ ?_ ?_ ?_ <;> aesop\n  rw [finprod_mem_finset_eq_prod]\n  simp_rw [finprod_mem_finset_eq_prod, this]\n  rw [finprod_eq_prod_of_mulSupport_subset _\n      (s.mulSupport_of_fiberwise_prod_subset_image f Prod.fst),\n    ← Finset.prod_fiberwise_of_maps_to (t := Finset.image Prod.fst s) _ f]\n  -- `finish` could close the goal here\n  simp only [Finset.mem_image]\n  exact fun x hx => ⟨x, hx, rfl⟩\n\n"}
{"name":"finsum_mem_finset_product'","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nβ : Type u_2\nM : Type u_5\ninst✝² : AddCommMonoid M\ninst✝¹ : DecidableEq α\ninst✝ : DecidableEq β\ns : Finset (Prod α β)\nf : Prod α β → M\n⊢ Eq (finsum fun ab => finsum fun x => f ab) (finsum fun a => finsum fun b => finsum fun x => f { fst := a, snd := b })","decl":"/-- Note that `b ∈ (s.filter (fun ab => Prod.fst ab = a)).image Prod.snd` iff `(a, b) ∈ s` so\nwe can simplify the right hand side of this lemma. However the form stated here is more useful for\niterating this lemma, e.g., if we have `f : α × β × γ → M`. -/\n@[to_additive\n      \"Note that `b ∈ (s.filter (fun ab => Prod.fst ab = a)).image Prod.snd` iff `(a, b) ∈ s` so\n      we can simplify the right hand side of this lemma. However the form stated here is more\n      useful for iterating this lemma, e.g., if we have `f : α × β × γ → M`.\"]\ntheorem finprod_mem_finset_product' [DecidableEq α] [DecidableEq β] (s : Finset (α × β))\n    (f : α × β → M) :\n    (∏ᶠ (ab) (_ : ab ∈ s), f ab) =\n      ∏ᶠ (a) (b) (_ : b ∈ (s.filter fun ab => Prod.fst ab = a).image Prod.snd), f (a, b) := by\n  have (a) :\n      ∏ i ∈ (s.filter fun ab => Prod.fst ab = a).image Prod.snd, f (a, i) =\n        (s.filter (Prod.fst · = a)).prod f := by\n    refine Finset.prod_nbij' (fun b ↦ (a, b)) Prod.snd ?_ ?_ ?_ ?_ ?_ <;> aesop\n  rw [finprod_mem_finset_eq_prod]\n  simp_rw [finprod_mem_finset_eq_prod, this]\n  rw [finprod_eq_prod_of_mulSupport_subset _\n      (s.mulSupport_of_fiberwise_prod_subset_image f Prod.fst),\n    ← Finset.prod_fiberwise_of_maps_to (t := Finset.image Prod.fst s) _ f]\n  -- `finish` could close the goal here\n  simp only [Finset.mem_image]\n  exact fun x hx => ⟨x, hx, rfl⟩\n\n"}
{"name":"finprod_mem_finset_product","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nβ : Type u_2\nM : Type u_5\ninst✝ : CommMonoid M\ns : Finset (Prod α β)\nf : Prod α β → M\n⊢ Eq (finprod fun ab => finprod fun x => f ab) (finprod fun a => finprod fun b => finprod fun x => f { fst := a, snd := b })","decl":"/-- See also `finprod_mem_finset_product'`. -/\n@[to_additive \"See also `finsum_mem_finset_product'`.\"]\ntheorem finprod_mem_finset_product (s : Finset (α × β)) (f : α × β → M) :\n    (∏ᶠ (ab) (_ : ab ∈ s), f ab) = ∏ᶠ (a) (b) (_ : (a, b) ∈ s), f (a, b) := by\n  classical\n    rw [finprod_mem_finset_product']\n    simp\n\n"}
{"name":"finsum_mem_finset_product","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nβ : Type u_2\nM : Type u_5\ninst✝ : AddCommMonoid M\ns : Finset (Prod α β)\nf : Prod α β → M\n⊢ Eq (finsum fun ab => finsum fun x => f ab) (finsum fun a => finsum fun b => finsum fun x => f { fst := a, snd := b })","decl":"/-- See also `finprod_mem_finset_product'`. -/\n@[to_additive \"See also `finsum_mem_finset_product'`.\"]\ntheorem finprod_mem_finset_product (s : Finset (α × β)) (f : α × β → M) :\n    (∏ᶠ (ab) (_ : ab ∈ s), f ab) = ∏ᶠ (a) (b) (_ : (a, b) ∈ s), f (a, b) := by\n  classical\n    rw [finprod_mem_finset_product']\n    simp\n\n"}
{"name":"finsum_mem_finset_product₃","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nβ : Type u_2\nM : Type u_5\ninst✝ : AddCommMonoid M\nγ : Type u_7\ns : Finset (Prod α (Prod β γ))\nf : Prod α (Prod β γ) → M\n⊢ Eq (finsum fun abc => finsum fun x => f abc) (finsum fun a => finsum fun b => finsum fun c => finsum fun x => f { fst := a, snd := { fst := b, snd := c } })","decl":"@[to_additive]\ntheorem finprod_mem_finset_product₃ {γ : Type*} (s : Finset (α × β × γ)) (f : α × β × γ → M) :\n    (∏ᶠ (abc) (_ : abc ∈ s), f abc) = ∏ᶠ (a) (b) (c) (_ : (a, b, c) ∈ s), f (a, b, c) := by\n  classical\n    rw [finprod_mem_finset_product']\n    simp_rw [finprod_mem_finset_product']\n    simp\n\n"}
{"name":"finprod_mem_finset_product₃","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nβ : Type u_2\nM : Type u_5\ninst✝ : CommMonoid M\nγ : Type u_7\ns : Finset (Prod α (Prod β γ))\nf : Prod α (Prod β γ) → M\n⊢ Eq (finprod fun abc => finprod fun x => f abc) (finprod fun a => finprod fun b => finprod fun c => finprod fun x => f { fst := a, snd := { fst := b, snd := c } })","decl":"@[to_additive]\ntheorem finprod_mem_finset_product₃ {γ : Type*} (s : Finset (α × β × γ)) (f : α × β × γ → M) :\n    (∏ᶠ (abc) (_ : abc ∈ s), f abc) = ∏ᶠ (a) (b) (c) (_ : (a, b, c) ∈ s), f (a, b, c) := by\n  classical\n    rw [finprod_mem_finset_product']\n    simp_rw [finprod_mem_finset_product']\n    simp\n\n"}
{"name":"finsum_curry","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nβ : Type u_2\nM : Type u_5\ninst✝ : AddCommMonoid M\nf : Prod α β → M\nhf : (Function.support f).Finite\n⊢ Eq (finsum fun ab => f ab) (finsum fun a => finsum fun b => f { fst := a, snd := b })","decl":"@[to_additive]\ntheorem finprod_curry (f : α × β → M) (hf : (mulSupport f).Finite) :\n    ∏ᶠ ab, f ab = ∏ᶠ (a) (b), f (a, b) := by\n  have h₁ : ∀ a, ∏ᶠ _ : a ∈ hf.toFinset, f a = f a := by simp\n  have h₂ : ∏ᶠ a, f a = ∏ᶠ (a) (_ : a ∈ hf.toFinset), f a := by simp\n  simp_rw [h₂, finprod_mem_finset_product, h₁]\n\n"}
{"name":"finprod_curry","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nβ : Type u_2\nM : Type u_5\ninst✝ : CommMonoid M\nf : Prod α β → M\nhf : (Function.mulSupport f).Finite\n⊢ Eq (finprod fun ab => f ab) (finprod fun a => finprod fun b => f { fst := a, snd := b })","decl":"@[to_additive]\ntheorem finprod_curry (f : α × β → M) (hf : (mulSupport f).Finite) :\n    ∏ᶠ ab, f ab = ∏ᶠ (a) (b), f (a, b) := by\n  have h₁ : ∀ a, ∏ᶠ _ : a ∈ hf.toFinset, f a = f a := by simp\n  have h₂ : ∏ᶠ a, f a = ∏ᶠ (a) (_ : a ∈ hf.toFinset), f a := by simp\n  simp_rw [h₂, finprod_mem_finset_product, h₁]\n\n"}
{"name":"finprod_curry₃","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nβ : Type u_2\nM : Type u_5\ninst✝ : CommMonoid M\nγ : Type u_7\nf : Prod α (Prod β γ) → M\nh : (Function.mulSupport f).Finite\n⊢ Eq (finprod fun abc => f abc) (finprod fun a => finprod fun b => finprod fun c => f { fst := a, snd := { fst := b, snd := c } })","decl":"@[to_additive]\ntheorem finprod_curry₃ {γ : Type*} (f : α × β × γ → M) (h : (mulSupport f).Finite) :\n    ∏ᶠ abc, f abc = ∏ᶠ (a) (b) (c), f (a, b, c) := by\n  rw [finprod_curry f h]\n  congr\n  ext a\n  rw [finprod_curry]\n  simp [h]\n\n"}
{"name":"finsum_curry₃","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nβ : Type u_2\nM : Type u_5\ninst✝ : AddCommMonoid M\nγ : Type u_7\nf : Prod α (Prod β γ) → M\nh : (Function.support f).Finite\n⊢ Eq (finsum fun abc => f abc) (finsum fun a => finsum fun b => finsum fun c => f { fst := a, snd := { fst := b, snd := c } })","decl":"@[to_additive]\ntheorem finprod_curry₃ {γ : Type*} (f : α × β × γ → M) (h : (mulSupport f).Finite) :\n    ∏ᶠ abc, f abc = ∏ᶠ (a) (b) (c), f (a, b, c) := by\n  rw [finprod_curry f h]\n  congr\n  ext a\n  rw [finprod_curry]\n  simp [h]\n\n"}
{"name":"finsum_dmem","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝¹ : AddCommMonoid M\ns : Set α\ninst✝ : DecidablePred fun x => Membership.mem s x\nf : (a : α) → Membership.mem s a → M\n⊢ Eq (finsum fun a => finsum fun h => f a h) (finsum fun a => finsum fun x => dite (Membership.mem s a) (fun h' => f a h') fun h' => 0)","decl":"@[to_additive]\ntheorem finprod_dmem {s : Set α} [DecidablePred (· ∈ s)] (f : ∀ a : α, a ∈ s → M) :\n    (∏ᶠ (a : α) (h : a ∈ s), f a h) = ∏ᶠ (a : α) (_ : a ∈ s), if h' : a ∈ s then f a h' else 1 :=\n  finprod_congr fun _ => finprod_congr fun ha => (dif_pos ha).symm\n\n"}
{"name":"finprod_dmem","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝¹ : CommMonoid M\ns : Set α\ninst✝ : DecidablePred fun x => Membership.mem s x\nf : (a : α) → Membership.mem s a → M\n⊢ Eq (finprod fun a => finprod fun h => f a h) (finprod fun a => finprod fun x => dite (Membership.mem s a) (fun h' => f a h') fun h' => 1)","decl":"@[to_additive]\ntheorem finprod_dmem {s : Set α} [DecidablePred (· ∈ s)] (f : ∀ a : α, a ∈ s → M) :\n    (∏ᶠ (a : α) (h : a ∈ s), f a h) = ∏ᶠ (a : α) (_ : a ∈ s), if h' : a ∈ s then f a h' else 1 :=\n  finprod_congr fun _ => finprod_congr fun ha => (dif_pos ha).symm\n\n"}
{"name":"finsum_emb_domain'","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nβ : Type u_2\nM : Type u_5\ninst✝¹ : AddCommMonoid M\nf : α → β\nhf : Function.Injective f\ninst✝ : DecidablePred fun x => Membership.mem (Set.range f) x\ng : α → M\n⊢ Eq (finsum fun b => dite (Membership.mem (Set.range f) b) (fun h => g (Classical.choose h)) fun h => 0) (finsum fun a => g a)","decl":"@[to_additive]\ntheorem finprod_emb_domain' {f : α → β} (hf : Injective f) [DecidablePred (· ∈ Set.range f)]\n    (g : α → M) :\n    (∏ᶠ b : β, if h : b ∈ Set.range f then g (Classical.choose h) else 1) = ∏ᶠ a : α, g a := by\n  simp_rw [← finprod_eq_dif]\n  rw [finprod_dmem, finprod_mem_range hf, finprod_congr fun a => _]\n  intro a\n  rw [dif_pos (Set.mem_range_self a), hf (Classical.choose_spec (Set.mem_range_self a))]\n\n"}
{"name":"finprod_emb_domain'","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nβ : Type u_2\nM : Type u_5\ninst✝¹ : CommMonoid M\nf : α → β\nhf : Function.Injective f\ninst✝ : DecidablePred fun x => Membership.mem (Set.range f) x\ng : α → M\n⊢ Eq (finprod fun b => dite (Membership.mem (Set.range f) b) (fun h => g (Classical.choose h)) fun h => 1) (finprod fun a => g a)","decl":"@[to_additive]\ntheorem finprod_emb_domain' {f : α → β} (hf : Injective f) [DecidablePred (· ∈ Set.range f)]\n    (g : α → M) :\n    (∏ᶠ b : β, if h : b ∈ Set.range f then g (Classical.choose h) else 1) = ∏ᶠ a : α, g a := by\n  simp_rw [← finprod_eq_dif]\n  rw [finprod_dmem, finprod_mem_range hf, finprod_congr fun a => _]\n  intro a\n  rw [dif_pos (Set.mem_range_self a), hf (Classical.choose_spec (Set.mem_range_self a))]\n\n"}
{"name":"finprod_emb_domain","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nβ : Type u_2\nM : Type u_5\ninst✝¹ : CommMonoid M\nf : Function.Embedding α β\ninst✝ : DecidablePred fun x => Membership.mem (Set.range ⇑f) x\ng : α → M\n⊢ Eq (finprod fun b => dite (Membership.mem (Set.range ⇑f) b) (fun h => g (Classical.choose h)) fun h => 1) (finprod fun a => g a)","decl":"@[to_additive]\ntheorem finprod_emb_domain (f : α ↪ β) [DecidablePred (· ∈ Set.range f)] (g : α → M) :\n    (∏ᶠ b : β, if h : b ∈ Set.range f then g (Classical.choose h) else 1) = ∏ᶠ a : α, g a :=\n  finprod_emb_domain' f.injective g\n\n"}
{"name":"finsum_emb_domain","module":"Mathlib.Algebra.BigOperators.Finprod","initialProofState":"α : Type u_1\nβ : Type u_2\nM : Type u_5\ninst✝¹ : AddCommMonoid M\nf : Function.Embedding α β\ninst✝ : DecidablePred fun x => Membership.mem (Set.range ⇑f) x\ng : α → M\n⊢ Eq (finsum fun b => dite (Membership.mem (Set.range ⇑f) b) (fun h => g (Classical.choose h)) fun h => 0) (finsum fun a => g a)","decl":"@[to_additive]\ntheorem finprod_emb_domain (f : α ↪ β) [DecidablePred (· ∈ Set.range f)] (g : α → M) :\n    (∏ᶠ b : β, if h : b ∈ Set.range f then g (Classical.choose h) else 1) = ∏ᶠ a : α, g a :=\n  finprod_emb_domain' f.injective g\n\n"}
