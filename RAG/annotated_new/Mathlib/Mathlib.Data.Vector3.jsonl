{"name":"Vector3.cons_fz","module":"Mathlib.Data.Vector3","initialProofState":"α : Type u_1\nn : Nat\na : α\nv : Vector3 α n\n⊢ Eq (Vector3.cons a v Fin2.fz) a","decl":"@[simp]\ntheorem cons_fz (a : α) (v : Vector3 α n) : (a :: v) fz = a :=\n  rfl\n\n"}
{"name":"Vector3.cons_fs","module":"Mathlib.Data.Vector3","initialProofState":"α : Type u_1\nn : Nat\na : α\nv : Vector3 α n\ni : Fin2 n\n⊢ Eq (Vector3.cons a v i.fs) (v i)","decl":"@[simp]\ntheorem cons_fs (a : α) (v : Vector3 α n) (i) : (a :: v) (fs i) = v i :=\n  rfl\n\n"}
{"name":"Vector3.eq_nil","module":"Mathlib.Data.Vector3","initialProofState":"α : Type u_1\nv : Vector3 α 0\n⊢ Eq v Vector3.nil","decl":"theorem eq_nil (v : Vector3 α 0) : v = [] :=\n  funext fun i => nomatch i\n\n"}
{"name":"Vector3.cons_head_tail","module":"Mathlib.Data.Vector3","initialProofState":"α : Type u_1\nn : Nat\nv : Vector3 α (HAdd.hAdd n 1)\n⊢ Eq (Vector3.cons v.head v.tail) v","decl":"theorem cons_head_tail (v : Vector3 α (n + 1)) : (head v :: tail v) = v :=\n  funext fun i => Fin2.cases' rfl (fun _ => rfl) i\n\n"}
{"name":"Vector3.consElim_cons","module":"Mathlib.Data.Vector3","initialProofState":"α : Type u_1\nn : Nat\nC : Vector3 α (HAdd.hAdd n 1) → Sort u_2\nH : (a : α) → (t : Vector3 α n) → C (Vector3.cons a t)\na : α\nt : Vector3 α n\n⊢ Eq (Vector3.consElim H (Vector3.cons a t)) (H a t)","decl":"@[simp]\ntheorem consElim_cons {C H a t} : @consElim α n C H (a :: t) = H a t :=\n  rfl\n\n"}
{"name":"Vector3.recOn_nil","module":"Mathlib.Data.Vector3","initialProofState":"α : Type u_1\nC : {n : Nat} → Vector3 α n → Sort u_2\nH0 : C Vector3.nil\nHs : {n : Nat} → (a : α) → (w : Vector3 α n) → C w → C (Vector3.cons a w)\n⊢ Eq (Vector3.nil.recOn H0 Hs) H0","decl":"@[simp]\ntheorem recOn_nil {C H0 Hs} : @Vector3.recOn α (@C) 0 [] H0 @Hs = H0 :=\n  rfl\n\n"}
{"name":"Vector3.recOn_cons","module":"Mathlib.Data.Vector3","initialProofState":"α : Type u_1\nC : {n : Nat} → Vector3 α n → Sort u_2\nH0 : C Vector3.nil\nHs : {n : Nat} → (a : α) → (w : Vector3 α n) → C w → C (Vector3.cons a w)\nn : Nat\na : α\nv : Vector3 α n\n⊢ Eq ((Vector3.cons a v).recOn H0 Hs) (Hs a v (v.recOn H0 Hs))","decl":"@[simp]\ntheorem recOn_cons {C H0 Hs n a v} :\n    @Vector3.recOn α (@C) (n + 1) (a :: v) H0 @Hs = Hs a v (@Vector3.recOn α (@C) n v H0 @Hs) :=\n  rfl\n\n"}
{"name":"Vector3.append_nil","module":"Mathlib.Data.Vector3","initialProofState":"α : Type u_1\nn : Nat\nw : Vector3 α n\n⊢ Eq (Vector3.nil.append w) w","decl":"@[simp]\ntheorem append_nil (w : Vector3 α n) : [] +-+ w = w :=\n  rfl\n\n"}
{"name":"Vector3.append_cons","module":"Mathlib.Data.Vector3","initialProofState":"α : Type u_1\nm n : Nat\na : α\nv : Vector3 α m\nw : Vector3 α n\n⊢ Eq ((Vector3.cons a v).append w) (Vector3.cons a (v.append w))","decl":"@[simp]\ntheorem append_cons (a : α) (v : Vector3 α m) (w : Vector3 α n) : (a :: v) +-+ w = a :: v +-+ w :=\n  rfl\n\n"}
{"name":"Vector3.append_left","module":"Mathlib.Data.Vector3","initialProofState":"α : Type u_1\nm : Nat\ni : Fin2 m\nv : Vector3 α m\nn : Nat\nw : Vector3 α n\n⊢ Eq (v.append w (Fin2.left n i)) (v i)","decl":"@[simp]\ntheorem append_left :\n    ∀ {m} (i : Fin2 m) (v : Vector3 α m) {n} (w : Vector3 α n), (v +-+ w) (left n i) = v i\n  | _, @fz m, v, _, _ => v.consElim fun a _t => by simp [*, left]\n  | _, @fs m i, v, n, w => v.consElim fun _a t => by simp [append_left, left]\n\n"}
{"name":"Vector3.append_add","module":"Mathlib.Data.Vector3","initialProofState":"α : Type u_1\nm : Nat\nv : Vector3 α m\nn : Nat\nw : Vector3 α n\ni : Fin2 n\n⊢ Eq (v.append w (i.add m)) (w i)","decl":"@[simp]\ntheorem append_add :\n    ∀ {m} (v : Vector3 α m) {n} (w : Vector3 α n) (i : Fin2 n), (v +-+ w) (add i m) = w i\n  | 0, _, _, _, _ => rfl\n  | m + 1, v, n, w, i => v.consElim fun _a t => by simp [append_add, add]\n\n"}
{"name":"Vector3.insert_fz","module":"Mathlib.Data.Vector3","initialProofState":"α : Type u_1\nn : Nat\na : α\nv : Vector3 α n\n⊢ Eq (Vector3.insert a v Fin2.fz) (Vector3.cons a v)","decl":"@[simp]\ntheorem insert_fz (a : α) (v : Vector3 α n) : insert a v fz = a :: v := by\n  refine funext fun j => j.cases' ?_ ?_ <;> intros <;> rfl\n\n"}
{"name":"Vector3.insert_fs","module":"Mathlib.Data.Vector3","initialProofState":"α : Type u_1\nn : Nat\na b : α\nv : Vector3 α n\ni : Fin2 (HAdd.hAdd n 1)\n⊢ Eq (Vector3.insert a (Vector3.cons b v) i.fs) (Vector3.cons b (Vector3.insert a v i))","decl":"@[simp]\ntheorem insert_fs (a : α) (b : α) (v : Vector3 α n) (i : Fin2 (n + 1)) :\n    insert a (b :: v) (fs i) = b :: insert a v i :=\n  funext fun j => by\n    refine j.cases' ?_ fun j => ?_ <;> simp [insert, insertPerm]\n    refine Fin2.cases' ?_ ?_ (insertPerm i j) <;> simp [insertPerm]\n\n"}
{"name":"Vector3.append_insert","module":"Mathlib.Data.Vector3","initialProofState":"α : Type u_1\nm n : Nat\na : α\nt : Vector3 α m\nv : Vector3 α n\ni : Fin2 (HAdd.hAdd n 1)\ne : Eq (HAdd.hAdd (HAdd.hAdd n 1) m) (HAdd.hAdd (HAdd.hAdd n m) 1)\n⊢ Eq (Vector3.insert a (t.append v) (Eq.recOn e (i.add m))) (Eq.recOn e (t.append (Vector3.insert a v i)))","decl":"theorem append_insert (a : α) (t : Vector3 α m) (v : Vector3 α n) (i : Fin2 (n + 1))\n    (e : (n + 1) + m = (n + m) + 1) :\n    insert a (t +-+ v) (Eq.recOn e (i.add m)) = Eq.recOn e (t +-+ insert a v i) := by\n  refine Vector3.recOn t (fun e => ?_) (@fun k b t IH _ => ?_) e\n  · rfl\n  have e' : (n + 1) + k = (n + k) + 1 := by omega\n  change\n    insert a (b :: t +-+ v)\n      (Eq.recOn (congr_arg (· + 1) e' : _ + 1 = _) (fs (add i k))) =\n      Eq.recOn (congr_arg (· + 1) e' : _ + 1 = _) (b :: t +-+ insert a v i)\n  rw [← (Eq.recOn e' rfl :\n      fs (Eq.recOn e' (i.add k) : Fin2 ((n + k) + 1)) =\n        Eq.recOn (congr_arg (· + 1) e' : _ + 1 = _) (fs (i.add k)))]\n  simpa [IH] using Eq.recOn e' rfl\n\n"}
{"name":"exists_vector_zero","module":"Mathlib.Data.Vector3","initialProofState":"α : Type u_1\nf : Vector3 α 0 → Prop\n⊢ Iff (Exists f) (f Vector3.nil)","decl":"theorem exists_vector_zero (f : Vector3 α 0 → Prop) : Exists f ↔ f [] :=\n  ⟨fun ⟨v, fv⟩ => by rw [← eq_nil v]; exact fv, fun f0 => ⟨[], f0⟩⟩\n\n"}
{"name":"exists_vector_succ","module":"Mathlib.Data.Vector3","initialProofState":"α : Type u_1\nn : Nat\nf : Vector3 α n.succ → Prop\n⊢ Iff (Exists f) (Exists fun x => Exists fun v => f (Vector3.cons x v))","decl":"theorem exists_vector_succ (f : Vector3 α (succ n) → Prop) : Exists f ↔ ∃ x v, f (x :: v) :=\n  ⟨fun ⟨v, fv⟩ => ⟨_, _, by rw [cons_head_tail v]; exact fv⟩, fun ⟨_, _, fxv⟩ => ⟨_, fxv⟩⟩\n\n"}
{"name":"vectorEx_iff_exists","module":"Mathlib.Data.Vector3","initialProofState":"α : Type u_1\nn : Nat\nf : Vector3 α n → Prop\n⊢ Iff (VectorEx n f) (Exists f)","decl":"theorem vectorEx_iff_exists : ∀ {n} (f : Vector3 α n → Prop), VectorEx n f ↔ Exists f\n  | 0, f => (exists_vector_zero f).symm\n  | succ _, f =>\n    Iff.trans (exists_congr fun _ => vectorEx_iff_exists _) (exists_vector_succ f).symm\n\n"}
{"name":"vectorAll_iff_forall","module":"Mathlib.Data.Vector3","initialProofState":"α : Type u_1\nn : Nat\nf : Vector3 α n → Prop\n⊢ Iff (VectorAll n f) (∀ (v : Vector3 α n), f v)","decl":"theorem vectorAll_iff_forall : ∀ {n} (f : Vector3 α n → Prop), VectorAll n f ↔ ∀ v, f v\n  | 0, _ => ⟨fun f0 v => v.nilElim f0, fun al => al []⟩\n  | succ _, f =>\n    (forall_congr' fun x => vectorAll_iff_forall fun v => f (x :: v)).trans\n      ⟨fun al v => v.consElim al, fun al x v => al (x :: v)⟩\n\n"}
{"name":"vectorAllP_nil","module":"Mathlib.Data.Vector3","initialProofState":"α : Type u_1\np : α → Prop\n⊢ Eq (VectorAllP p Vector3.nil) True","decl":"@[simp]\ntheorem vectorAllP_nil (p : α → Prop) : VectorAllP p [] = True :=\n  rfl\n\n"}
{"name":"vectorAllP_singleton","module":"Mathlib.Data.Vector3","initialProofState":"α : Type u_1\np : α → Prop\nx : α\n⊢ Eq (VectorAllP p (Vector3.cons x Vector3.nil)) (p x)","decl":"@[simp]\ntheorem vectorAllP_singleton (p : α → Prop) (x : α) : VectorAllP p (cons x []) = p x :=\n  rfl\n\n"}
{"name":"vectorAllP_cons","module":"Mathlib.Data.Vector3","initialProofState":"α : Type u_1\nn : Nat\np : α → Prop\nx : α\nv : Vector3 α n\n⊢ Iff (VectorAllP p (Vector3.cons x v)) (And (p x) (VectorAllP p v))","decl":"@[simp]\ntheorem vectorAllP_cons (p : α → Prop) (x : α) (v : Vector3 α n) :\n    VectorAllP p (x :: v) ↔ p x ∧ VectorAllP p v :=\n  Vector3.recOn v (iff_of_eq (and_true _)).symm fun _ _ _ => Iff.rfl\n\n"}
{"name":"vectorAllP_iff_forall","module":"Mathlib.Data.Vector3","initialProofState":"α : Type u_1\nn : Nat\np : α → Prop\nv : Vector3 α n\n⊢ Iff (VectorAllP p v) (∀ (i : Fin2 n), p (v i))","decl":"theorem vectorAllP_iff_forall (p : α → Prop) (v : Vector3 α n) :\n    VectorAllP p v ↔ ∀ i, p (v i) := by\n  refine v.recOn ?_ ?_\n  · exact ⟨fun _ => Fin2.elim0, fun _ => trivial⟩\n  · simp only [vectorAllP_cons]\n    refine fun {n} a v IH =>\n      (and_congr_right fun _ => IH).trans\n        ⟨fun ⟨pa, h⟩ i => by\n          refine i.cases' ?_ ?_\n          exacts [pa, h], fun h => ⟨?_, fun i => ?_⟩⟩\n    · simpa using h fz\n    · simpa using h (fs i)\n\n"}
{"name":"VectorAllP.imp","module":"Mathlib.Data.Vector3","initialProofState":"α : Type u_1\nn : Nat\np q : α → Prop\nh : ∀ (x : α), p x → q x\nv : Vector3 α n\nal : VectorAllP p v\n⊢ VectorAllP q v","decl":"theorem VectorAllP.imp {p q : α → Prop} (h : ∀ x, p x → q x) {v : Vector3 α n}\n    (al : VectorAllP p v) : VectorAllP q v :=\n  (vectorAllP_iff_forall _ _).2 fun _ => h _ <| (vectorAllP_iff_forall _ _).1 al _\n\n"}
