{"name":"AlgebraicGeometry.isAffineHom_iff","module":"Mathlib.AlgebraicGeometry.Morphisms.Affine","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\n⊢ Iff (AlgebraicGeometry.IsAffineHom f) (∀ (U : Y.Opens), AlgebraicGeometry.IsAffineOpen U → AlgebraicGeometry.IsAffineOpen ((TopologicalSpace.Opens.map f.base).obj U))","decl":"/-- A morphism of schemes `X ⟶ Y` is affine if\nthe preimage of any affine open subset of `Y` is affine. -/\n@[mk_iff]\nclass IsAffineHom {X Y : Scheme} (f : X ⟶ Y) : Prop where\n  isAffine_preimage : ∀ U : Y.Opens, IsAffineOpen U → IsAffineOpen (f ⁻¹ᵁ U)\n\n"}
{"name":"AlgebraicGeometry.IsAffineHom.isAffine_preimage","module":"Mathlib.AlgebraicGeometry.Morphisms.Affine","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nself : AlgebraicGeometry.IsAffineHom f\nU : Y.Opens\na✝ : AlgebraicGeometry.IsAffineOpen U\n⊢ AlgebraicGeometry.IsAffineOpen ((TopologicalSpace.Opens.map f.base).obj U)","decl":"/-- A morphism of schemes `X ⟶ Y` is affine if\nthe preimage of any affine open subset of `Y` is affine. -/\n@[mk_iff]\nclass IsAffineHom {X Y : Scheme} (f : X ⟶ Y) : Prop where\n  isAffine_preimage : ∀ U : Y.Opens, IsAffineOpen U → IsAffineOpen (f ⁻¹ᵁ U)\n\n"}
{"name":"AlgebraicGeometry.IsAffineOpen.preimage","module":"Mathlib.AlgebraicGeometry.Morphisms.Affine","initialProofState":"X Y : AlgebraicGeometry.Scheme\nU : Y.Opens\nhU : AlgebraicGeometry.IsAffineOpen U\nf : Quiver.Hom X Y\ninst✝ : AlgebraicGeometry.IsAffineHom f\n⊢ AlgebraicGeometry.IsAffineOpen ((TopologicalSpace.Opens.map f.base).obj U)","decl":"lemma IsAffineOpen.preimage {X Y : Scheme} {U : Y.Opens} (hU : IsAffineOpen U)\n    (f : X ⟶ Y) [IsAffineHom f] :\n    IsAffineOpen (f ⁻¹ᵁ U) :=\n  IsAffineHom.isAffine_preimage _ hU\n\n"}
{"name":"AlgebraicGeometry.affinePreimage_coe","module":"Mathlib.AlgebraicGeometry.Morphisms.Affine","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\ninst✝ : AlgebraicGeometry.IsAffineHom f\nU : ↑Y.affineOpens\n⊢ Eq (↑(AlgebraicGeometry.affinePreimage f U)) ((TopologicalSpace.Opens.map f.base).obj ↑U)","decl":"/-- The preimage of an affine open as an `Scheme.affine_opens`. -/\n@[simps]\ndef affinePreimage {X Y : Scheme} (f : X ⟶ Y) [IsAffineHom f] (U : Y.affineOpens) :\n    X.affineOpens :=\n  ⟨f ⁻¹ᵁ U.1, IsAffineHom.isAffine_preimage _ U.prop⟩\n\n"}
{"name":"AlgebraicGeometry.instIsAffineHomOfIsIsoScheme","module":"Mathlib.AlgebraicGeometry.Morphisms.Affine","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.IsIso f\n⊢ AlgebraicGeometry.IsAffineHom f","decl":"instance (priority := 900) [IsIso f] : IsAffineHom f :=\n  ⟨fun _ hU ↦ hU.preimage_of_isIso f⟩\n\n"}
{"name":"AlgebraicGeometry.instQuasiCompactOfIsAffineHom","module":"Mathlib.AlgebraicGeometry.Morphisms.Affine","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\ninst✝ : AlgebraicGeometry.IsAffineHom f\n⊢ AlgebraicGeometry.QuasiCompact f","decl":"instance (priority := 900) [IsAffineHom f] : QuasiCompact f :=\n  (quasiCompact_iff_forall_affine f).mpr\n    (fun U hU ↦ (IsAffineHom.isAffine_preimage U hU).isCompact)\n\n"}
{"name":"AlgebraicGeometry.instIsAffineHomCompScheme","module":"Mathlib.AlgebraicGeometry.Morphisms.Affine","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\ninst✝¹ : AlgebraicGeometry.IsAffineHom f\ninst✝ : AlgebraicGeometry.IsAffineHom g\n⊢ AlgebraicGeometry.IsAffineHom (CategoryTheory.CategoryStruct.comp f g)","decl":"instance [IsAffineHom f] [IsAffineHom g] : IsAffineHom (f ≫ g) := by\n  constructor\n  intros U hU\n  rw [Scheme.comp_base, Opens.map_comp_obj]\n  apply IsAffineHom.isAffine_preimage\n  apply IsAffineHom.isAffine_preimage\n  exact hU\n\n"}
{"name":"AlgebraicGeometry.instIsMultiplicativeSchemeIsAffineHom","module":"Mathlib.AlgebraicGeometry.Morphisms.Affine","initialProofState":"⊢ CategoryTheory.MorphismProperty.IsMultiplicative @AlgebraicGeometry.IsAffineHom","decl":"instance : MorphismProperty.IsMultiplicative @IsAffineHom where\n  id_mem := inferInstance\n  comp_mem _ _ _ _ := inferInstance\n\n"}
{"name":"AlgebraicGeometry.instIsAffineHomιBasicOpen","module":"Mathlib.AlgebraicGeometry.Morphisms.Affine","initialProofState":"X : AlgebraicGeometry.Scheme\nr : ↑(X.presheaf.obj { unop := Top.top })\n⊢ AlgebraicGeometry.IsAffineHom (X.basicOpen r).ι","decl":"instance {X : Scheme} (r : Γ(X, ⊤)) :\n    IsAffineHom (X.basicOpen r).ι := by\n  constructor\n  intros U hU\n  fapply (Scheme.Hom.isAffineOpen_iff_of_isOpenImmersion (X.basicOpen r).ι).mp\n  convert hU.basicOpen (X.presheaf.map (homOfLE le_top).op r)\n  rw [X.basicOpen_res]\n  ext1\n  refine Set.image_preimage_eq_inter_range.trans ?_\n  simp\n\n"}
{"name":"AlgebraicGeometry.isAffineOpen_of_isAffineOpen_basicOpen_aux","module":"Mathlib.AlgebraicGeometry.Morphisms.Affine","initialProofState":"X : AlgebraicGeometry.Scheme\ns : Set ↑(X.presheaf.obj { unop := Top.top })\nhs : Eq (Ideal.span s) Top.top\nhs₂ : ∀ (i : ↑(X.presheaf.obj { unop := Top.top })), Membership.mem s i → AlgebraicGeometry.IsAffineOpen (X.basicOpen i)\n⊢ QuasiSeparatedSpace ↑↑X.toPresheafedSpace","decl":"lemma isAffineOpen_of_isAffineOpen_basicOpen_aux (s : Set Γ(X, ⊤))\n    (hs : Ideal.span s = ⊤) (hs₂ : ∀ i ∈ s, IsAffineOpen (X.basicOpen i)) :\n    QuasiSeparatedSpace X := by\n  rw [quasiSeparatedSpace_iff_affine]\n  intros U V\n  obtain ⟨s', hs', e⟩ := (Ideal.span_eq_top_iff_finite _).mp hs\n  rw [← Set.inter_univ (_ ∩ _), ← Opens.coe_top, ← iSup_basicOpen_of_span_eq_top _ _ e,\n    ← iSup_subtype'', Opens.coe_iSup, Set.inter_iUnion]\n  apply isCompact_iUnion\n  intro i\n  rw [Set.inter_inter_distrib_right]\n  refine (hs₂ i (hs' i.2)).isQuasiSeparated _ _ Set.inter_subset_right\n    (U.1.2.inter (X.basicOpen _).2) ?_ Set.inter_subset_right (V.1.2.inter (X.basicOpen _).2) ?_\n  · rw [← Opens.coe_inf, ← X.basicOpen_res _ (homOfLE le_top).op]\n    exact (U.2.basicOpen _).isCompact\n  · rw [← Opens.coe_inf, ← X.basicOpen_res _ (homOfLE le_top).op]\n    exact (V.2.basicOpen _).isCompact\n\n"}
{"name":"AlgebraicGeometry.isAffine_of_isAffineOpen_basicOpen","module":"Mathlib.AlgebraicGeometry.Morphisms.Affine","initialProofState":"X : AlgebraicGeometry.Scheme\ns : Set ↑(X.presheaf.obj { unop := Top.top })\nhs : Eq (Ideal.span s) Top.top\nhs₂ : ∀ (i : ↑(X.presheaf.obj { unop := Top.top })), Membership.mem s i → AlgebraicGeometry.IsAffineOpen (X.basicOpen i)\n⊢ AlgebraicGeometry.IsAffine X","decl":"lemma isAffine_of_isAffineOpen_basicOpen (s : Set Γ(X, ⊤))\n    (hs : Ideal.span s = ⊤) (hs₂ : ∀ i ∈ s, IsAffineOpen (X.basicOpen i)) :\n    IsAffine X := by\n  have : QuasiSeparatedSpace X := isAffineOpen_of_isAffineOpen_basicOpen_aux s hs hs₂\n  have : CompactSpace X := by\n    obtain ⟨s', hs', e⟩ := (Ideal.span_eq_top_iff_finite _).mp hs\n    rw [← isCompact_univ_iff, ← Opens.coe_top, ← iSup_basicOpen_of_span_eq_top _ _ e]\n    simp only [Finset.mem_coe, Opens.iSup_mk, Opens.carrier_eq_coe, Opens.coe_mk]\n    apply s'.isCompact_biUnion\n    exact fun i hi ↦ (hs₂ _ (hs' hi)).isCompact\n  constructor\n  refine HasAffineProperty.of_iSup_eq_top (P := MorphismProperty.isomorphisms Scheme)\n    (fun i : s ↦ ⟨PrimeSpectrum.basicOpen i.1, ?_⟩) ?_ (fun i ↦ ⟨?_, ?_⟩)\n  · show IsAffineOpen _\n    simp only [← basicOpen_eq_of_affine]\n    exact (isAffineOpen_top (Scheme.Spec.obj (op _))).basicOpen _\n  · rw [PrimeSpectrum.iSup_basicOpen_eq_top_iff, Subtype.range_coe_subtype, Set.setOf_mem_eq, hs]\n  · rw [Scheme.toSpecΓ_preimage_basicOpen]\n    exact hs₂ _ i.2\n  · simp only [Functor.comp_obj, Functor.rightOp_obj, Scheme.Γ_obj, Scheme.Spec_obj, id_eq,\n      eq_mpr_eq_cast, Functor.id_obj, Opens.map_top, morphismRestrict_app]\n    refine IsIso.comp_isIso' ?_ inferInstance\n    convert isIso_ΓSpec_adjunction_unit_app_basicOpen i.1 using 0\n    refine congr(IsIso ((ΓSpec.adjunction.unit.app X).app $(?_)))\n    rw [Opens.isOpenEmbedding_obj_top]\n\n"}
{"name":"AlgebraicGeometry.isAffineOpen_of_isAffineOpen_basicOpen","module":"Mathlib.AlgebraicGeometry.Morphisms.Affine","initialProofState":"X : AlgebraicGeometry.Scheme\nU : X.Opens\ns : Set ↑(X.presheaf.obj { unop := U })\nhs : Eq (Ideal.span s) Top.top\nhs₂ : ∀ (i : ↑(X.presheaf.obj { unop := U })), Membership.mem s i → AlgebraicGeometry.IsAffineOpen (X.basicOpen i)\n⊢ AlgebraicGeometry.IsAffineOpen U","decl":"/--\nIf `s` is a spanning set of `Γ(X, U)`, such that each `X.basicOpen i` is affine, then `U` is also\naffine.\n-/\nlemma isAffineOpen_of_isAffineOpen_basicOpen (U) (s : Set Γ(X, U))\n    (hs : Ideal.span s = ⊤) (hs₂ : ∀ i ∈ s, IsAffineOpen (X.basicOpen i)) :\n    IsAffineOpen U := by\n  apply isAffine_of_isAffineOpen_basicOpen (U.topIso.inv '' s)\n  · rw [← Ideal.map_span U.topIso.inv.hom, hs, Ideal.map_top]\n  · rintro _ ⟨j, hj, rfl⟩\n    rw [← (Scheme.Opens.ι _).isAffineOpen_iff_of_isOpenImmersion, Scheme.image_basicOpen]\n    simpa [Scheme.Opens.toScheme_presheaf_obj] using hs₂ j hj\n\n"}
{"name":"AlgebraicGeometry.instHasAffinePropertyIsAffineHomIsAffine","module":"Mathlib.AlgebraicGeometry.Morphisms.Affine","initialProofState":"⊢ AlgebraicGeometry.HasAffineProperty @AlgebraicGeometry.IsAffineHom fun X x x_1 x => AlgebraicGeometry.IsAffine X","decl":"instance : HasAffineProperty @IsAffineHom fun X _ _ _ ↦ IsAffine X where\n  isLocal_affineProperty := by\n    constructor\n    · apply AffineTargetMorphismProperty.respectsIso_mk\n      · rintro X Y Z e _ _ H\n        have : IsAffine _ := H\n        exact isAffine_of_isIso e.hom\n      · exact fun _ _ _ ↦ id\n    · intro X Y _ f r H\n      have : IsAffine X := H\n      show IsAffineOpen _\n      rw [Scheme.preimage_basicOpen]\n      exact (isAffineOpen_top X).basicOpen _\n    · intro X Y _ f S hS hS'\n      apply_fun Ideal.map (f.appTop).hom at hS\n      rw [Ideal.map_span, Ideal.map_top] at hS\n      apply isAffine_of_isAffineOpen_basicOpen _ hS\n      have : ∀ i : S, IsAffineOpen (f⁻¹ᵁ Y.basicOpen i.1) := hS'\n      simpa [Scheme.preimage_basicOpen] using this\n  eq_targetAffineLocally' := by\n    ext X Y f\n    simp only [targetAffineLocally, Scheme.affineOpens, Set.coe_setOf, Set.mem_setOf_eq,\n      Subtype.forall, isAffineHom_iff]\n    rfl\n\n"}
{"name":"AlgebraicGeometry.isAffineHom_isStableUnderBaseChange","module":"Mathlib.AlgebraicGeometry.Morphisms.Affine","initialProofState":"⊢ CategoryTheory.MorphismProperty.IsStableUnderBaseChange @AlgebraicGeometry.IsAffineHom","decl":"instance isAffineHom_isStableUnderBaseChange :\n    MorphismProperty.IsStableUnderBaseChange @IsAffineHom := by\n  apply HasAffineProperty.isStableUnderBaseChange\n  letI := HasAffineProperty.isLocal_affineProperty\n  apply AffineTargetMorphismProperty.IsStableUnderBaseChange.mk\n  introv X hX H\n  infer_instance\n\n"}
{"name":"AlgebraicGeometry.isAffineHom_of_isAffine","module":"Mathlib.AlgebraicGeometry.Morphisms.Affine","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\ninst✝¹ : AlgebraicGeometry.IsAffine X\ninst✝ : AlgebraicGeometry.IsAffine Y\n⊢ AlgebraicGeometry.IsAffineHom f","decl":"instance (priority := 100) isAffineHom_of_isAffine [IsAffine X] [IsAffine Y] : IsAffineHom f :=\n  (HasAffineProperty.iff_of_isAffine (P := @IsAffineHom)).mpr inferInstance\n\n"}
{"name":"AlgebraicGeometry.isAffine_of_isAffineHom","module":"Mathlib.AlgebraicGeometry.Morphisms.Affine","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\ninst✝¹ : AlgebraicGeometry.IsAffineHom f\ninst✝ : AlgebraicGeometry.IsAffine Y\n⊢ AlgebraicGeometry.IsAffine X","decl":"lemma isAffine_of_isAffineHom [IsAffineHom f] [IsAffine Y] : IsAffine X :=\n  (HasAffineProperty.iff_of_isAffine (P := @IsAffineHom) (f := f)).mp inferInstance\n\n"}
