{"name":"CategoryTheory.Subpresheaf.ofSection_obj","module":"Mathlib.CategoryTheory.Subpresheaf.OfSection","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor (Opposite C) (Type w)\nX : Opposite C\nx : F.obj X\nU : Opposite C\n‚ä¢ Eq ((CategoryTheory.Subpresheaf.ofSection x).obj U) (setOf fun u => Exists fun f => Eq (F.map f x) u)","decl":"/-- The subpresheaf of `F : C·µí·µñ ‚•§ Type w` that is generated\nby a section `x : F.obj X`. -/\n@[simps (config := .lemmasOnly)]\ndef ofSection : Subpresheaf F where\n  obj U := setOf (fun u ‚Ü¶ ‚àÉ (f : X ‚ü∂ U), F.map f x = u)\n  map {U V} g := by\n    rintro _ ‚ü®f, rfl‚ü©\n    exact ‚ü®f ‚â´ g, by simp‚ü©\n\n"}
{"name":"CategoryTheory.Subpresheaf.mem_ofSection_obj","module":"Mathlib.CategoryTheory.Subpresheaf.OfSection","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor (Opposite C) (Type w)\nX : Opposite C\nx : F.obj X\n‚ä¢ Membership.mem ((CategoryTheory.Subpresheaf.ofSection x).obj X) x","decl":"lemma mem_ofSection_obj : x ‚àà (ofSection x).obj X := ‚ü®ùüô _, by simp‚ü©\n\n"}
{"name":"CategoryTheory.Subpresheaf.ofSection_le_iff","module":"Mathlib.CategoryTheory.Subpresheaf.OfSection","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor (Opposite C) (Type w)\nX : Opposite C\nx : F.obj X\nG : CategoryTheory.Subpresheaf F\n‚ä¢ Iff (LE.le (CategoryTheory.Subpresheaf.ofSection x) G) (Membership.mem (G.obj X) x)","decl":"@[simp]\nlemma ofSection_le_iff (G : Subpresheaf F) :\n    ofSection x ‚â§ G ‚Üî x ‚àà G.obj X := by\n  constructor\n  ¬∑ intro hx\n    exact hx _ (mem_ofSection_obj x)\n  ¬∑ rintro hx U _ ‚ü®f, rfl‚ü©\n    exact G.map f hx\n\n"}
{"name":"CategoryTheory.Subpresheaf.ofSection_image","module":"Mathlib.CategoryTheory.Subpresheaf.OfSection","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor (Opposite C) (Type w)\nX : Opposite C\nx : F.obj X\nF' : CategoryTheory.Functor (Opposite C) (Type w)\nf : Quiver.Hom F F'\n‚ä¢ Eq ((CategoryTheory.Subpresheaf.ofSection x).image f) (CategoryTheory.Subpresheaf.ofSection (f.app X x))","decl":"@[simp]\nlemma ofSection_image {F' : C·µí·µñ ‚•§ Type w} (f : F ‚ü∂ F') :\n    (ofSection x).image f = ofSection (f.app _ x) := by\n  apply le_antisymm\n  ¬∑ rw [image_le_iff, ofSection_le_iff, preimage_obj, Set.mem_preimage]\n    exact ‚ü®ùüô X, by simp‚ü©\n  ¬∑ simp only [ofSection_le_iff, image_obj, Set.mem_image]\n    exact ‚ü®x, mem_ofSection_obj x, rfl‚ü©\n\n"}
{"name":"CategoryTheory.Subpresheaf.ofSection_eq_range","module":"Mathlib.CategoryTheory.Subpresheaf.OfSection","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor (Opposite C) (Type v)\nX : Opposite C\nx : F.obj X\n‚ä¢ Eq (CategoryTheory.Subpresheaf.ofSection x) (CategoryTheory.Subpresheaf.range (CategoryTheory.yonedaEquiv.symm x))","decl":"lemma ofSection_eq_range {X : C·µí·µñ} (x : F.obj X) :\n    ofSection x = range (yonedaEquiv.symm x) := by\n  ext U y\n  simp only [ofSection_obj, Set.mem_setOf_eq, Opposite.op_unop, range_obj, yoneda_obj_obj,\n    Set.mem_range]\n  constructor\n  ¬∑ rintro ‚ü®f, rfl‚ü©\n    exact ‚ü®f.unop, rfl‚ü©\n  ¬∑ rintro ‚ü®f, rfl‚ü©\n    exact ‚ü®f.op, rfl‚ü©\n\n"}
{"name":"CategoryTheory.Subpresheaf.range_eq_ofSection","module":"Mathlib.CategoryTheory.Subpresheaf.OfSection","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor (Opposite C) (Type v)\nX : C\nf : Quiver.Hom (CategoryTheory.yoneda.obj X) F\n‚ä¢ Eq (CategoryTheory.Subpresheaf.range f) (CategoryTheory.Subpresheaf.ofSection (CategoryTheory.yonedaEquiv f))","decl":"lemma range_eq_ofSection {X : C} (f : yoneda.obj X ‚ü∂ F) :\n    range f = ofSection (yonedaEquiv f) := by\n  rw [ofSection_eq_range, Equiv.symm_apply_apply]\n\n"}
{"name":"CategoryTheory.Subpresheaf.ofSection_eq_range'","module":"Mathlib.CategoryTheory.Subpresheaf.OfSection","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor (Opposite C) (Type (max v w))\nX : Opposite C\nx : F.obj X\n‚ä¢ Eq (CategoryTheory.Subpresheaf.ofSection x) (CategoryTheory.Subpresheaf.range ((CategoryTheory.yonedaCompUliftFunctorEquiv F (Opposite.unop X)).symm x))","decl":"lemma ofSection_eq_range' {X : C·µí·µñ} (x : F.obj X) :\n    ofSection x = range ((yonedaCompUliftFunctorEquiv F X.unop).symm x) := by\n  ext U y\n  simp only [Opposite.op_unop, range_obj, Functor.comp_obj, yoneda_obj_obj, uliftFunctor_obj,\n    Set.mem_range, ULift.exists]\n  constructor\n  ¬∑ rintro ‚ü®f, rfl‚ü©\n    exact ‚ü®f.unop, rfl‚ü©\n  ¬∑ rintro ‚ü®f, rfl‚ü©\n    exact ‚ü®f.op, rfl‚ü©\n\n"}
{"name":"CategoryTheory.Subpresheaf.range_eq_ofSection'","module":"Mathlib.CategoryTheory.Subpresheaf.OfSection","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor (Opposite C) (Type (max v w))\nX : C\nf : Quiver.Hom ((CategoryTheory.yoneda.obj X).comp CategoryTheory.uliftFunctor.{w, v}) F\n‚ä¢ Eq (CategoryTheory.Subpresheaf.range f) (CategoryTheory.Subpresheaf.ofSection ((CategoryTheory.yonedaCompUliftFunctorEquiv F X) f))","decl":"lemma range_eq_ofSection' {X : C} (f : yoneda.obj X ‚ãô uliftFunctor.{w} ‚ü∂ F) :\n    range f = ofSection ((yonedaCompUliftFunctorEquiv F X) f) := by\n  rw [ofSection_eq_range', Equiv.symm_apply_apply]\n\n"}
