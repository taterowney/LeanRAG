{"name":"Finsupp.toMultiset_zero","module":"Mathlib.Data.Finsupp.Multiset","initialProofState":"α : Type u_1\n⊢ Eq (Finsupp.toMultiset 0) 0","decl":"theorem toMultiset_zero : toMultiset (0 : α →₀ ℕ) = 0 :=\n  rfl\n\n"}
{"name":"Finsupp.toMultiset_add","module":"Mathlib.Data.Finsupp.Multiset","initialProofState":"α : Type u_1\nm n : Finsupp α Nat\n⊢ Eq (Finsupp.toMultiset (HAdd.hAdd m n)) (HAdd.hAdd (Finsupp.toMultiset m) (Finsupp.toMultiset n))","decl":"theorem toMultiset_add (m n : α →₀ ℕ) : toMultiset (m + n) = toMultiset m + toMultiset n :=\n  toMultiset.map_add m n\n\n"}
{"name":"Finsupp.toMultiset_apply","module":"Mathlib.Data.Finsupp.Multiset","initialProofState":"α : Type u_1\nf : Finsupp α Nat\n⊢ Eq (Finsupp.toMultiset f) (f.sum fun a n => HSMul.hSMul n (Singleton.singleton a))","decl":"theorem toMultiset_apply (f : α →₀ ℕ) : toMultiset f = f.sum fun a n => n • {a} :=\n  rfl\n\n"}
{"name":"Finsupp.toMultiset_single","module":"Mathlib.Data.Finsupp.Multiset","initialProofState":"α : Type u_1\na : α\nn : Nat\n⊢ Eq (Finsupp.toMultiset (Finsupp.single a n)) (HSMul.hSMul n (Singleton.singleton a))","decl":"@[simp]\ntheorem toMultiset_single (a : α) (n : ℕ) : toMultiset (single a n) = n • {a} := by\n  rw [toMultiset_apply, sum_single_index]; apply zero_nsmul\n\n"}
{"name":"Finsupp.toMultiset_sum","module":"Mathlib.Data.Finsupp.Multiset","initialProofState":"α : Type u_1\nι : Type u_3\nf : ι → Finsupp α Nat\ns : Finset ι\n⊢ Eq (Finsupp.toMultiset (s.sum fun i => f i)) (s.sum fun i => Finsupp.toMultiset (f i))","decl":"theorem toMultiset_sum {f : ι → α →₀ ℕ} (s : Finset ι) :\n    Finsupp.toMultiset (∑ i ∈ s, f i) = ∑ i ∈ s, Finsupp.toMultiset (f i) :=\n  map_sum Finsupp.toMultiset _ _\n\n"}
{"name":"Finsupp.toMultiset_sum_single","module":"Mathlib.Data.Finsupp.Multiset","initialProofState":"ι : Type u_3\ns : Finset ι\nn : Nat\n⊢ Eq (Finsupp.toMultiset (s.sum fun i => Finsupp.single i n)) (HSMul.hSMul n s.val)","decl":"theorem toMultiset_sum_single (s : Finset ι) (n : ℕ) :\n    Finsupp.toMultiset (∑ i ∈ s, single i n) = n • s.val := by\n  simp_rw [toMultiset_sum, Finsupp.toMultiset_single, Finset.sum_nsmul, sum_multiset_singleton]\n\n"}
{"name":"Finsupp.card_toMultiset","module":"Mathlib.Data.Finsupp.Multiset","initialProofState":"α : Type u_1\nf : Finsupp α Nat\n⊢ Eq (Finsupp.toMultiset f).card (f.sum fun x => id)","decl":"@[simp]\ntheorem card_toMultiset (f : α →₀ ℕ) : Multiset.card (toMultiset f) = f.sum fun _ => id := by\n  simp [toMultiset_apply, map_finsupp_sum, Function.id_def]\n\n"}
{"name":"Finsupp.toMultiset_map","module":"Mathlib.Data.Finsupp.Multiset","initialProofState":"α : Type u_1\nβ : Type u_2\nf : Finsupp α Nat\ng : α → β\n⊢ Eq (Multiset.map g (Finsupp.toMultiset f)) (Finsupp.toMultiset (Finsupp.mapDomain g f))","decl":"theorem toMultiset_map (f : α →₀ ℕ) (g : α → β) :\n    f.toMultiset.map g = toMultiset (f.mapDomain g) := by\n  refine f.induction ?_ ?_\n  · rw [toMultiset_zero, Multiset.map_zero, mapDomain_zero, toMultiset_zero]\n  · intro a n f _ _ ih\n    rw [toMultiset_add, Multiset.map_add, ih, mapDomain_add, mapDomain_single,\n      toMultiset_single, toMultiset_add, toMultiset_single, ← Multiset.coe_mapAddMonoidHom,\n      (Multiset.mapAddMonoidHom g).map_nsmul]\n    rfl\n\n"}
{"name":"Finsupp.prod_toMultiset","module":"Mathlib.Data.Finsupp.Multiset","initialProofState":"α : Type u_1\ninst✝ : CommMonoid α\nf : Finsupp α Nat\n⊢ Eq (Finsupp.toMultiset f).prod (f.prod fun a n => HPow.hPow a n)","decl":"@[to_additive (attr := simp)]\ntheorem prod_toMultiset [CommMonoid α] (f : α →₀ ℕ) :\n    f.toMultiset.prod = f.prod fun a n => a ^ n := by\n  refine f.induction ?_ ?_\n  · rw [toMultiset_zero, Multiset.prod_zero, Finsupp.prod_zero_index]\n  · intro a n f _ _ ih\n    rw [toMultiset_add, Multiset.prod_add, ih, toMultiset_single, Multiset.prod_nsmul,\n      Finsupp.prod_add_index' pow_zero pow_add, Finsupp.prod_single_index, Multiset.prod_singleton]\n    exact pow_zero a\n\n"}
{"name":"Finsupp.sum_toMultiset","module":"Mathlib.Data.Finsupp.Multiset","initialProofState":"α : Type u_1\ninst✝ : AddCommMonoid α\nf : Finsupp α Nat\n⊢ Eq (Finsupp.toMultiset f).sum (f.sum fun a n => HSMul.hSMul n a)","decl":"@[to_additive (attr := simp)]\ntheorem prod_toMultiset [CommMonoid α] (f : α →₀ ℕ) :\n    f.toMultiset.prod = f.prod fun a n => a ^ n := by\n  refine f.induction ?_ ?_\n  · rw [toMultiset_zero, Multiset.prod_zero, Finsupp.prod_zero_index]\n  · intro a n f _ _ ih\n    rw [toMultiset_add, Multiset.prod_add, ih, toMultiset_single, Multiset.prod_nsmul,\n      Finsupp.prod_add_index' pow_zero pow_add, Finsupp.prod_single_index, Multiset.prod_singleton]\n    exact pow_zero a\n\n"}
{"name":"Finsupp.toFinset_toMultiset","module":"Mathlib.Data.Finsupp.Multiset","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nf : Finsupp α Nat\n⊢ Eq (Finsupp.toMultiset f).toFinset f.support","decl":"@[simp]\ntheorem toFinset_toMultiset [DecidableEq α] (f : α →₀ ℕ) : f.toMultiset.toFinset = f.support := by\n  refine f.induction ?_ ?_\n  · rw [toMultiset_zero, Multiset.toFinset_zero, support_zero]\n  · intro a n f ha hn ih\n    rw [toMultiset_add, Multiset.toFinset_add, ih, toMultiset_single, support_add_eq,\n      support_single_ne_zero _ hn, Multiset.toFinset_nsmul _ _ hn, Multiset.toFinset_singleton]\n    refine Disjoint.mono_left support_single_subset ?_\n    rwa [Finset.disjoint_singleton_left]\n\n"}
{"name":"Finsupp.count_toMultiset","module":"Mathlib.Data.Finsupp.Multiset","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nf : Finsupp α Nat\na : α\n⊢ Eq (Multiset.count a (Finsupp.toMultiset f)) (f a)","decl":"@[simp]\ntheorem count_toMultiset [DecidableEq α] (f : α →₀ ℕ) (a : α) : (toMultiset f).count a = f a :=\n  calc\n    (toMultiset f).count a = Finsupp.sum f (fun x n => (n • {x} : Multiset α).count a) := by\n      rw [toMultiset_apply]; exact map_sum (Multiset.countAddMonoidHom a) _ f.support\n    _ = f.sum fun x n => n * ({x} : Multiset α).count a := by simp only [Multiset.count_nsmul]\n    _ = f a * ({a} : Multiset α).count a :=\n      sum_eq_single _\n        (fun a' _ H => by simp only [Multiset.count_singleton, if_false, H.symm, mul_zero])\n        (fun _ => zero_mul _)\n    _ = f a := by rw [Multiset.count_singleton_self, mul_one]\n\n"}
{"name":"Finsupp.toMultiset_sup","module":"Mathlib.Data.Finsupp.Multiset","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nf g : Finsupp α Nat\n⊢ Eq (Finsupp.toMultiset (Max.max f g)) (Union.union (Finsupp.toMultiset f) (Finsupp.toMultiset g))","decl":"theorem toMultiset_sup [DecidableEq α] (f g : α →₀ ℕ) :\n    toMultiset (f ⊔ g) = toMultiset f ∪ toMultiset g := by\n  ext\n  simp_rw [Multiset.count_union, Finsupp.count_toMultiset, Finsupp.sup_apply]\n\n"}
{"name":"Finsupp.toMultiset_inf","module":"Mathlib.Data.Finsupp.Multiset","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nf g : Finsupp α Nat\n⊢ Eq (Finsupp.toMultiset (Min.min f g)) (Inter.inter (Finsupp.toMultiset f) (Finsupp.toMultiset g))","decl":"theorem toMultiset_inf [DecidableEq α] (f g : α →₀ ℕ) :\n    toMultiset (f ⊓ g) = toMultiset f ∩ toMultiset g := by\n  ext\n  simp_rw [Multiset.count_inter, Finsupp.count_toMultiset, Finsupp.inf_apply]\n\n"}
{"name":"Finsupp.mem_toMultiset","module":"Mathlib.Data.Finsupp.Multiset","initialProofState":"α : Type u_1\nf : Finsupp α Nat\ni : α\n⊢ Iff (Membership.mem (Finsupp.toMultiset f) i) (Membership.mem f.support i)","decl":"@[simp]\ntheorem mem_toMultiset (f : α →₀ ℕ) (i : α) : i ∈ toMultiset f ↔ i ∈ f.support := by\n  classical\n  rw [← Multiset.count_ne_zero, Finsupp.count_toMultiset, Finsupp.mem_support_iff]\n\n"}
{"name":"Multiset.toFinsupp_symm_apply","module":"Mathlib.Data.Finsupp.Multiset","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nf : Finsupp α Nat\n⊢ Eq (Multiset.toFinsupp.symm f) (Finsupp.toMultiset f)","decl":"/-- Given a multiset `s`, `s.toFinsupp` returns the finitely supported function on `ℕ` given by\nthe multiplicities of the elements of `s`. -/\n@[simps symm_apply]\ndef toFinsupp : Multiset α ≃+ (α →₀ ℕ) where\n  toFun s := ⟨s.toFinset, fun a => s.count a, fun a => by simp⟩\n  invFun f := Finsupp.toMultiset f\n  map_add' _ _ := Finsupp.ext fun _ => count_add _ _ _\n  right_inv f :=\n    Finsupp.ext fun a => by\n      simp only [Finsupp.toMultiset_apply, Finsupp.sum, Multiset.count_sum',\n        Multiset.count_singleton, mul_boole, Finsupp.coe_mk, Finsupp.mem_support_iff,\n        Multiset.count_nsmul, Finset.sum_ite_eq, ite_not, ite_eq_right_iff]\n      exact Eq.symm\n  left_inv s := by simp only [Finsupp.toMultiset_apply, Finsupp.sum, Finsupp.coe_mk,\n    Multiset.toFinset_sum_count_nsmul_eq]\n\n"}
{"name":"Multiset.toFinsupp_support","module":"Mathlib.Data.Finsupp.Multiset","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : Multiset α\n⊢ Eq (Multiset.toFinsupp s).support s.toFinset","decl":"@[simp]\ntheorem toFinsupp_support (s : Multiset α) : s.toFinsupp.support = s.toFinset := rfl\n\n"}
{"name":"Multiset.toFinsupp_apply","module":"Mathlib.Data.Finsupp.Multiset","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : Multiset α\na : α\n⊢ Eq ((Multiset.toFinsupp s) a) (Multiset.count a s)","decl":"@[simp]\ntheorem toFinsupp_apply (s : Multiset α) (a : α) : toFinsupp s a = s.count a := rfl\n\n"}
{"name":"Multiset.toFinsupp_zero","module":"Mathlib.Data.Finsupp.Multiset","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\n⊢ Eq (Multiset.toFinsupp 0) 0","decl":"theorem toFinsupp_zero : toFinsupp (0 : Multiset α) = 0 := _root_.map_zero _\n\n"}
{"name":"Multiset.toFinsupp_add","module":"Mathlib.Data.Finsupp.Multiset","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t : Multiset α\n⊢ Eq (Multiset.toFinsupp (HAdd.hAdd s t)) (HAdd.hAdd (Multiset.toFinsupp s) (Multiset.toFinsupp t))","decl":"theorem toFinsupp_add (s t : Multiset α) : toFinsupp (s + t) = toFinsupp s + toFinsupp t :=\n  _root_.map_add toFinsupp s t\n\n"}
{"name":"Multiset.toFinsupp_singleton","module":"Mathlib.Data.Finsupp.Multiset","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na : α\n⊢ Eq (Multiset.toFinsupp (Singleton.singleton a)) (Finsupp.single a 1)","decl":"@[simp]\ntheorem toFinsupp_singleton (a : α) : toFinsupp ({a} : Multiset α) = Finsupp.single a 1 := by\n  ext; rw [toFinsupp_apply, count_singleton, Finsupp.single_eq_pi_single, Pi.single_apply]\n\n"}
{"name":"Multiset.toFinsupp_toMultiset","module":"Mathlib.Data.Finsupp.Multiset","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : Multiset α\n⊢ Eq (Finsupp.toMultiset (Multiset.toFinsupp s)) s","decl":"@[simp]\ntheorem toFinsupp_toMultiset (s : Multiset α) : Finsupp.toMultiset (toFinsupp s) = s :=\n  Multiset.toFinsupp.symm_apply_apply s\n\n"}
{"name":"Multiset.toFinsupp_eq_iff","module":"Mathlib.Data.Finsupp.Multiset","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : Multiset α\nf : Finsupp α Nat\n⊢ Iff (Eq (Multiset.toFinsupp s) f) (Eq s (Finsupp.toMultiset f))","decl":"theorem toFinsupp_eq_iff {s : Multiset α} {f : α →₀ ℕ} :\n    toFinsupp s = f ↔ s = Finsupp.toMultiset f :=\n  Multiset.toFinsupp.apply_eq_iff_symm_apply\n\n"}
{"name":"Multiset.toFinsupp_union","module":"Mathlib.Data.Finsupp.Multiset","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t : Multiset α\n⊢ Eq (Multiset.toFinsupp (Union.union s t)) (Max.max (Multiset.toFinsupp s) (Multiset.toFinsupp t))","decl":"theorem toFinsupp_union (s t : Multiset α) : toFinsupp (s ∪ t) = toFinsupp s ⊔ toFinsupp t := by\n  ext\n  simp\n\n"}
{"name":"Multiset.toFinsupp_inter","module":"Mathlib.Data.Finsupp.Multiset","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t : Multiset α\n⊢ Eq (Multiset.toFinsupp (Inter.inter s t)) (Min.min (Multiset.toFinsupp s) (Multiset.toFinsupp t))","decl":"theorem toFinsupp_inter (s t : Multiset α) : toFinsupp (s ∩ t) = toFinsupp s ⊓ toFinsupp t := by\n  ext\n  simp\n\n"}
{"name":"Multiset.toFinsupp_sum_eq","module":"Mathlib.Data.Finsupp.Multiset","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : Multiset α\n⊢ Eq ((Multiset.toFinsupp s).sum fun x => id) s.card","decl":"@[simp]\ntheorem toFinsupp_sum_eq (s : Multiset α) : s.toFinsupp.sum (fun _ ↦ id) = Multiset.card s := by\n  rw [← Finsupp.card_toMultiset, toFinsupp_toMultiset]\n\n"}
{"name":"Finsupp.toMultiset_toFinsupp","module":"Mathlib.Data.Finsupp.Multiset","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nf : Finsupp α Nat\n⊢ Eq (Multiset.toFinsupp (Finsupp.toMultiset f)) f","decl":"@[simp]\ntheorem Finsupp.toMultiset_toFinsupp [DecidableEq α] (f : α →₀ ℕ) :\n    Multiset.toFinsupp (Finsupp.toMultiset f) = f :=\n  Multiset.toFinsupp.apply_symm_apply _\n\n"}
{"name":"Finsupp.toMultiset_eq_iff","module":"Mathlib.Data.Finsupp.Multiset","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nf : Finsupp α Nat\ns : Multiset α\n⊢ Iff (Eq (Finsupp.toMultiset f) s) (Eq f (Multiset.toFinsupp s))","decl":"theorem Finsupp.toMultiset_eq_iff [DecidableEq α] {f : α →₀ ℕ} {s : Multiset α} :\n    Finsupp.toMultiset f = s ↔ f = Multiset.toFinsupp s :=\n  Multiset.toFinsupp.symm_apply_eq\n\n"}
{"name":"Finsupp.coe_orderIsoMultiset","module":"Mathlib.Data.Finsupp.Multiset","initialProofState":"ι : Type u_3\ninst✝ : DecidableEq ι\n⊢ Eq ⇑Finsupp.orderIsoMultiset ⇑Finsupp.toMultiset","decl":"@[simp]\ntheorem coe_orderIsoMultiset [DecidableEq ι] : ⇑(@orderIsoMultiset ι _) = toMultiset :=\n  rfl\n\n"}
{"name":"Finsupp.coe_orderIsoMultiset_symm","module":"Mathlib.Data.Finsupp.Multiset","initialProofState":"ι : Type u_3\ninst✝ : DecidableEq ι\n⊢ Eq ⇑Finsupp.orderIsoMultiset.symm ⇑Multiset.toFinsupp","decl":"@[simp]\ntheorem coe_orderIsoMultiset_symm [DecidableEq ι] :\n    ⇑(@orderIsoMultiset ι).symm = Multiset.toFinsupp :=\n  rfl\n\n"}
{"name":"Finsupp.toMultiset_strictMono","module":"Mathlib.Data.Finsupp.Multiset","initialProofState":"ι : Type u_3\n⊢ StrictMono ⇑Finsupp.toMultiset","decl":"theorem toMultiset_strictMono : StrictMono (@toMultiset ι) := by\n  classical exact (@orderIsoMultiset ι _).strictMono\n\n"}
{"name":"Finsupp.sum_id_lt_of_lt","module":"Mathlib.Data.Finsupp.Multiset","initialProofState":"ι : Type u_3\nm n : Finsupp ι Nat\nh : LT.lt m n\n⊢ LT.lt (m.sum fun x => id) (n.sum fun x => id)","decl":"theorem sum_id_lt_of_lt (m n : ι →₀ ℕ) (h : m < n) : (m.sum fun _ => id) < n.sum fun _ => id := by\n  rw [← card_toMultiset, ← card_toMultiset]\n  apply Multiset.card_lt_card\n  exact toMultiset_strictMono h\n\n"}
{"name":"Finsupp.lt_wf","module":"Mathlib.Data.Finsupp.Multiset","initialProofState":"ι : Type u_3\n⊢ WellFounded LT.lt","decl":"/-- The order on `ι →₀ ℕ` is well-founded. -/\ntheorem lt_wf : WellFounded (@LT.lt (ι →₀ ℕ) _) :=\n  Subrelation.wf (sum_id_lt_of_lt _ _) <| InvImage.wf _ Nat.lt_wfRel.2\n\n-- TODO: generalize to `[WellFoundedRelation α] → WellFoundedRelation (ι →₀ α)`\n"}
{"name":"Multiset.toFinsupp_strictMono","module":"Mathlib.Data.Finsupp.Multiset","initialProofState":"ι : Type u_3\ninst✝ : DecidableEq ι\n⊢ StrictMono ⇑Multiset.toFinsupp","decl":"theorem Multiset.toFinsupp_strictMono [DecidableEq ι] : StrictMono (@Multiset.toFinsupp ι _) :=\n  (@Finsupp.orderIsoMultiset ι).symm.strictMono\n\n"}
{"name":"Sym.coe_equivNatSum_apply_apply","module":"Mathlib.Data.Finsupp.Multiset","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nn : Nat\ns : Sym α n\na : α\n⊢ Eq (↑((Sym.equivNatSum α n) s) a) (Multiset.count a ↑s)","decl":"@[simp] lemma coe_equivNatSum_apply_apply (s : Sym α n) (a : α) :\n    (equivNatSum α n s : α →₀ ℕ) a = (s : Multiset α).count a :=\n  rfl\n\n"}
{"name":"Sym.coe_equivNatSum_symm_apply","module":"Mathlib.Data.Finsupp.Multiset","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nn : Nat\nP : Subtype fun P => Eq (P.sum fun x => id) n\n⊢ Eq (↑((Sym.equivNatSum α n).symm P)) (Finsupp.toMultiset ↑P)","decl":"@[simp] lemma coe_equivNatSum_symm_apply (P : {P : α →₀ ℕ // P.sum (fun _ ↦ id) = n}) :\n    ((equivNatSum α n).symm P : Multiset α) = Finsupp.toMultiset P :=\n  rfl\n\n"}
{"name":"Sym.coe_equivNatSumOfFintype_apply_apply","module":"Mathlib.Data.Finsupp.Multiset","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\nn : Nat\ninst✝ : Fintype α\ns : Sym α n\na : α\n⊢ Eq (↑((Sym.equivNatSumOfFintype α n) s) a) (Multiset.count a ↑s)","decl":"@[simp] lemma coe_equivNatSumOfFintype_apply_apply [Fintype α] (s : Sym α n) (a : α) :\n    (equivNatSumOfFintype α n s : α → ℕ) a = (s : Multiset α).count a :=\n  rfl\n\n"}
{"name":"Sym.coe_equivNatSumOfFintype_symm_apply","module":"Mathlib.Data.Finsupp.Multiset","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\nn : Nat\ninst✝ : Fintype α\nP : Subtype fun P => Eq (Finset.univ.sum fun i => P i) n\n⊢ Eq (↑((Sym.equivNatSumOfFintype α n).symm P)) (Finset.univ.sum fun a => HSMul.hSMul (↑P a) (Singleton.singleton a))","decl":"@[simp] lemma coe_equivNatSumOfFintype_symm_apply [Fintype α] (P : {P : α → ℕ // ∑ i, P i = n}) :\n    ((equivNatSumOfFintype α n).symm P : Multiset α) = ∑ a, ((P : α → ℕ) a) • {a} := by\n  obtain ⟨P, hP⟩ := P\n  change Finsupp.toMultiset (Finsupp.equivFunOnFinite.symm P) = Multiset.sum _\n  ext a\n  rw [Multiset.count_sum]\n  simp [Multiset.count_singleton]\n\n"}
