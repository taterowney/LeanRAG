{"name":"Alexandrov.self_mem_principalOpen","module":"Mathlib.Topology.Sheaves.Alexandrov","initialProofState":"X : Type v\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : Preorder X\ninst‚úù : Topology.IsUpperSet X\nx : X\n‚ä¢ Membership.mem (Alexandrov.principalOpen x) x","decl":"lemma self_mem_principalOpen (x : X) : x ‚àà principalOpen x := le_refl _\n\n"}
{"name":"Alexandrov.principalOpen_le_iff","module":"Mathlib.Topology.Sheaves.Alexandrov","initialProofState":"X : Type v\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : Preorder X\ninst‚úù : Topology.IsUpperSet X\nx : X\nU : TopologicalSpace.Opens X\n‚ä¢ Iff (LE.le (Alexandrov.principalOpen x) U) (Membership.mem U x)","decl":"@[simp]\nlemma principalOpen_le_iff {x : X} (U : Opens X) :\n    principalOpen x ‚â§ U ‚Üî x ‚àà U := by\n  refine ‚ü®fun h => h <| self_mem_principalOpen _, fun hx y hy => ?_‚ü©\n  ¬∑ have := U.isOpen\n    rw [IsUpperSet.isOpen_iff_isUpperSet] at this\n    exact this hy hx\n\n"}
{"name":"Alexandrov.principalOpen_le","module":"Mathlib.Topology.Sheaves.Alexandrov","initialProofState":"X : Type v\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : Preorder X\ninst‚úù : Topology.IsUpperSet X\nx y : X\nh : LE.le x y\n‚ä¢ LE.le (Alexandrov.principalOpen y) (Alexandrov.principalOpen x)","decl":"lemma principalOpen_le {x y : X} (h : x ‚â§ y) :\n    principalOpen y ‚â§ principalOpen x :=\n  fun _ hc => le_trans h hc\n\n"}
{"name":"Alexandrov.principals_obj","module":"Mathlib.Topology.Sheaves.Alexandrov","initialProofState":"X : Type v\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : Preorder X\ninst‚úù : Topology.IsUpperSet X\nx : X\n‚ä¢ Eq ((Alexandrov.principals X).obj x) { unop := Alexandrov.principalOpen x }","decl":"variable (X) in\n/-- The functor sending `x : X` to the principal open associated with `x`. -/\n@[simps]\ndef principals : X ‚•§ (Opens X)·µí·µñ where\n  obj x := .op <| principalOpen x\n  map {x y} f := .op <| principalOpen_le f.le |>.hom\n\n"}
{"name":"Alexandrov.principals_map","module":"Mathlib.Topology.Sheaves.Alexandrov","initialProofState":"X : Type v\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : Preorder X\ninst‚úù : Topology.IsUpperSet X\nx y : X\nf : Quiver.Hom x y\n‚ä¢ Eq ((Alexandrov.principals X).map f) ‚ãØ.hom.op","decl":"variable (X) in\n/-- The functor sending `x : X` to the principal open associated with `x`. -/\n@[simps]\ndef principals : X ‚•§ (Opens X)·µí·µñ where\n  obj x := .op <| principalOpen x\n  map {x y} f := .op <| principalOpen_le f.le |>.hom\n\n"}
{"name":"Alexandrov.exists_le_of_le_sup","module":"Mathlib.Topology.Sheaves.Alexandrov","initialProofState":"X : Type v\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : Preorder X\ninst‚úù : Topology.IsUpperSet X\nŒπ : Type v\nx : X\nUs : Œπ ‚Üí TopologicalSpace.Opens X\nh : LE.le (Alexandrov.principalOpen x) (iSup Us)\n‚ä¢ Exists fun i => LE.le (Alexandrov.principalOpen x) (Us i)","decl":"lemma exists_le_of_le_sup {Œπ : Type v} {x : X}\n    (Us : Œπ ‚Üí Opens X) (h : principalOpen x ‚â§ iSup Us) :\n    ‚àÉ i : Œπ, principalOpen x ‚â§ Us i := by\n  have : x ‚àà iSup Us := h <| self_mem_principalOpen x\n  simp only [Opens.mem_iSup] at this\n  obtain ‚ü®i, hi‚ü© := this\n  refine ‚ü®i, ?_‚ü©\n  simpa\n\n"}
{"name":"Alexandrov.projSup_obj","module":"Mathlib.Topology.Sheaves.Alexandrov","initialProofState":"X : Type v\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : Preorder X\ninst‚úù : Topology.IsUpperSet X\nŒπ : Type v\nUs : Œπ ‚Üí TopologicalSpace.Opens X\nf : CategoryTheory.StructuredArrow { unop := iSup Us } (Alexandrov.principals X)\n‚ä¢ Eq ((Alexandrov.projSup Us).obj f) { unop := { obj := Alexandrov.principalOpen f.right, property := ‚ãØ } }","decl":"/-- Given a structured arrow `f` with domain `iSup Us` over `principals X`,\nwhere `Us` is a family of `Opens X`, this functor sends `f` to the principal open\nassociated with it, considered as an object in the full subcategory of all `V : Opens X`\nsuch that `V ‚â§ Us i` for some `i`.\n\nThis definition is primarily meant to be used in `lowerCone`, and `isLimit` below.\n-/\n@[simps]\ndef projSup {Œπ : Type v} (Us : Œπ ‚Üí Opens X) :\n    StructuredArrow (.op <| iSup Us) (principals X) ‚•§\n      (FullSubcategory fun V => ‚àÉ i, V ‚â§ Us i)·µí·µñ where\n  obj f := .op <| .mk (principalOpen f.right) <| exists_le_of_le_sup Us f.hom.unop.le\n  map e := .op <| LE.le.hom <| principalOpen_le <| e.right.le\n\n"}
{"name":"Alexandrov.projSup_map","module":"Mathlib.Topology.Sheaves.Alexandrov","initialProofState":"X : Type v\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : Preorder X\ninst‚úù : Topology.IsUpperSet X\nŒπ : Type v\nUs : Œπ ‚Üí TopologicalSpace.Opens X\nX‚úù Y‚úù : CategoryTheory.StructuredArrow { unop := iSup Us } (Alexandrov.principals X)\ne : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((Alexandrov.projSup Us).map e) ‚ãØ.hom.op","decl":"/-- Given a structured arrow `f` with domain `iSup Us` over `principals X`,\nwhere `Us` is a family of `Opens X`, this functor sends `f` to the principal open\nassociated with it, considered as an object in the full subcategory of all `V : Opens X`\nsuch that `V ‚â§ Us i` for some `i`.\n\nThis definition is primarily meant to be used in `lowerCone`, and `isLimit` below.\n-/\n@[simps]\ndef projSup {Œπ : Type v} (Us : Œπ ‚Üí Opens X) :\n    StructuredArrow (.op <| iSup Us) (principals X) ‚•§\n      (FullSubcategory fun V => ‚àÉ i, V ‚â§ Us i)·µí·µñ where\n  obj f := .op <| .mk (principalOpen f.right) <| exists_le_of_le_sup Us f.hom.unop.le\n  map e := .op <| LE.le.hom <| principalOpen_le <| e.right.le\n\n"}
{"name":"Alexandrov.lowerCone_œÄ_app","module":"Mathlib.Topology.Sheaves.Alexandrov","initialProofState":"X : Type v\ninst‚úù‚Å¥ : TopologicalSpace X\ninst‚úù¬≥ : Preorder X\ninst‚úù¬≤ : Topology.IsUpperSet X\nC : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasLimits C\nF : CategoryTheory.Functor X C\nŒ± : Type v\nUs : Œ± ‚Üí TopologicalSpace.Opens X\nS : CategoryTheory.Limits.Cone ((CategoryTheory.fullSubcategoryInclusion fun V => Exists fun i => LE.le V (Us i)).op.comp (Alexandrov.principalsKanExtension F))\nf : CategoryTheory.StructuredArrow { unop := iSup Us } (Alexandrov.principals X)\n‚ä¢ Eq ((Alexandrov.lowerCone Us S).œÄ.app f) (CategoryTheory.CategoryStruct.comp (S.œÄ.app ((Alexandrov.projSup Us).obj f)) (CategoryTheory.Limits.limit.œÄ ((Alexandrov.generator (Alexandrov.principalOpen f.right)).comp F) { left := { as := PUnit.unit }, right := f.right, hom := CategoryTheory.CategoryStruct.id ((CategoryTheory.Functor.fromPUnit { unop := Alexandrov.principalOpen f.right }).obj { as := PUnit.unit }) }))","decl":"variable {F} in\n/-- This is an auxiliary definition which is only meant to be used in `isLimit` below. -/\n@[simps]\ndef lowerCone\n  {Œ± : Type v} (Us : Œ± ‚Üí Opens X)\n  (S : Cone ((fullSubcategoryInclusion fun V => ‚àÉ i, V ‚â§ Us i).op ‚ãô principalsKanExtension F)) :\n    Cone (generator (iSup Us) ‚ãô F) where\n  pt := S.pt\n  œÄ := {\n    app := fun f =>\n      S.œÄ.app ((projSup Us).obj f) ‚â´ limit.œÄ (generator (principalOpen f.right) ‚ãô F)\n        ‚ü®.mk .unit, f.right, ùüô _‚ü©\n    naturality := by\n      rintro x y e\n      simp only [Functor.const_obj_obj, Functor.comp_obj, Functor.const_obj_map, principals_obj,\n        Functor.op_obj, fullSubcategoryInclusion.obj, Functor.pointwiseRightKanExtension_obj,\n        Category.id_comp, Functor.comp_map, Category.assoc]\n      rw [‚Üê S.w ((projSup Us).map e), Category.assoc]\n      congr 1\n      simp only [projSup_obj, Functor.comp_obj, Functor.op_obj, fullSubcategoryInclusion.obj,\n        Functor.pointwiseRightKanExtension_obj, projSup_map, homOfLE_leOfHom, Functor.comp_map,\n        Functor.op_map, Quiver.Hom.unop_op, fullSubcategoryInclusion.map,\n        Functor.pointwiseRightKanExtension_map, limit.lift_œÄ]\n      let xx : StructuredArrow (Opposite.op (principalOpen x.right)) (principals X) :=\n        ‚ü®.mk .unit, x.right, ùüô _‚ü©\n      let yy : StructuredArrow (Opposite.op (principalOpen x.right)) (principals X) :=\n        ‚ü®.mk .unit, y.right, .op <| LE.le.hom <| principalOpen_le e.right.le‚ü©\n      let ee : xx ‚ü∂ yy := { left := ùüô _, right := e.right }\n      exact limit.w\n        (StructuredArrow.proj (Opposite.op (principalOpen x.right)) (principals X) ‚ãô F) ee\n        |>.symm\n  }\n\n"}
{"name":"Alexandrov.lowerCone_pt","module":"Mathlib.Topology.Sheaves.Alexandrov","initialProofState":"X : Type v\ninst‚úù‚Å¥ : TopologicalSpace X\ninst‚úù¬≥ : Preorder X\ninst‚úù¬≤ : Topology.IsUpperSet X\nC : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasLimits C\nF : CategoryTheory.Functor X C\nŒ± : Type v\nUs : Œ± ‚Üí TopologicalSpace.Opens X\nS : CategoryTheory.Limits.Cone ((CategoryTheory.fullSubcategoryInclusion fun V => Exists fun i => LE.le V (Us i)).op.comp (Alexandrov.principalsKanExtension F))\n‚ä¢ Eq (Alexandrov.lowerCone Us S).pt S.pt","decl":"variable {F} in\n/-- This is an auxiliary definition which is only meant to be used in `isLimit` below. -/\n@[simps]\ndef lowerCone\n  {Œ± : Type v} (Us : Œ± ‚Üí Opens X)\n  (S : Cone ((fullSubcategoryInclusion fun V => ‚àÉ i, V ‚â§ Us i).op ‚ãô principalsKanExtension F)) :\n    Cone (generator (iSup Us) ‚ãô F) where\n  pt := S.pt\n  œÄ := {\n    app := fun f =>\n      S.œÄ.app ((projSup Us).obj f) ‚â´ limit.œÄ (generator (principalOpen f.right) ‚ãô F)\n        ‚ü®.mk .unit, f.right, ùüô _‚ü©\n    naturality := by\n      rintro x y e\n      simp only [Functor.const_obj_obj, Functor.comp_obj, Functor.const_obj_map, principals_obj,\n        Functor.op_obj, fullSubcategoryInclusion.obj, Functor.pointwiseRightKanExtension_obj,\n        Category.id_comp, Functor.comp_map, Category.assoc]\n      rw [‚Üê S.w ((projSup Us).map e), Category.assoc]\n      congr 1\n      simp only [projSup_obj, Functor.comp_obj, Functor.op_obj, fullSubcategoryInclusion.obj,\n        Functor.pointwiseRightKanExtension_obj, projSup_map, homOfLE_leOfHom, Functor.comp_map,\n        Functor.op_map, Quiver.Hom.unop_op, fullSubcategoryInclusion.map,\n        Functor.pointwiseRightKanExtension_map, limit.lift_œÄ]\n      let xx : StructuredArrow (Opposite.op (principalOpen x.right)) (principals X) :=\n        ‚ü®.mk .unit, x.right, ùüô _‚ü©\n      let yy : StructuredArrow (Opposite.op (principalOpen x.right)) (principals X) :=\n        ‚ü®.mk .unit, y.right, .op <| LE.le.hom <| principalOpen_le e.right.le‚ü©\n      let ee : xx ‚ü∂ yy := { left := ùüô _, right := e.right }\n      exact limit.w\n        (StructuredArrow.proj (Opposite.op (principalOpen x.right)) (principals X) ‚ãô F) ee\n        |>.symm\n  }\n\n"}
{"name":"Alexandrov.isSheaf_principalsKanExtension","module":"Mathlib.Topology.Sheaves.Alexandrov","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\ninst‚úù¬≤ : CategoryTheory.Limits.HasLimits C\nX : TopCat\ninst‚úù¬π : Preorder ‚ÜëX\ninst‚úù : Topology.IsUpperSet ‚ÜëX\nF : CategoryTheory.Functor (‚ÜëX) C\n‚ä¢ TopCat.Presheaf.IsSheaf (Alexandrov.principalsKanExtension F)","decl":"theorem isSheaf_principalsKanExtension\n    {X : TopCat.{v}} [Preorder X] [Topology.IsUpperSet X] (F : X ‚•§ C) :\n    Presheaf.IsSheaf (principalsKanExtension F) := by\n  rw [isSheaf_iff_isSheafOpensLeCover]\n  intro Œπ Us\n  constructor\n  apply isLimit\n\n"}
{"name":"Topology.IsUpperSet.isSheaf_of_isRightKanExtension","module":"Mathlib.Topology.Sheaves.Alexandrov","initialProofState":"X : Type v\ninst‚úù‚Åµ : TopologicalSpace X\ninst‚úù‚Å¥ : Preorder X\ninst‚úù¬≥ : Topology.IsUpperSet X\nC : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasLimits C\nF : CategoryTheory.Functor X C\nP : CategoryTheory.Functor (Opposite (TopologicalSpace.Opens X)) C\nŒ∑ : Quiver.Hom ((Alexandrov.principals X).comp P) F\ninst‚úù : P.IsRightKanExtension Œ∑\n‚ä¢ CategoryTheory.Presheaf.IsSheaf (Opens.grothendieckTopology X) P","decl":"/--\nThe main theorem of this file.\nIf `X` is a topological space and preorder whose topology is the `UpperSet` topology associated\nwith the preorder, `F : X ‚•§ C` is a functor into a complete category from the preorder category,\nand `P : (Opens X)·µí·µñ ‚•§ C` denotes the right Kan extension of `F` along the\nfunctor `X ‚•§ (Open X)·µí·µñ` which sends `x : X` to `{y | x ‚â§ y}`, then `P` is a sheaf.\n-/\ntheorem Topology.IsUpperSet.isSheaf_of_isRightKanExtension\n    (P : (Opens X)·µí·µñ ‚•§ C)\n    (Œ∑ : Alexandrov.principals X ‚ãô P ‚ü∂ F)\n    [P.IsRightKanExtension Œ∑] :\n    Presheaf.IsSheaf (Opens.grothendieckTopology X) P := by\n  let Œ≥ : principals X ‚ãô principalsKanExtension F ‚ü∂ F :=\n    (principals X).pointwiseRightKanExtensionCounit F\n  let _ : (principalsKanExtension F).IsRightKanExtension Œ≥ := inferInstance\n  have : P ‚âÖ principalsKanExtension F :=\n    @rightKanExtensionUnique _ _ _ _ _ _ _ _ _ _ (by assumption) _ _ (by assumption)\n  change TopCat.Presheaf.IsSheaf (X := TopCat.of X) P\n  rw [isSheaf_iso_iff this]\n  let _ : Preorder (TopCat.of X) := inferInstanceAs <| Preorder X\n  have _ : Topology.IsUpperSet (TopCat.of X) := inferInstanceAs <| Topology.IsUpperSet X\n  exact isSheaf_principalsKanExtension (X := TopCat.of X) F\n"}
