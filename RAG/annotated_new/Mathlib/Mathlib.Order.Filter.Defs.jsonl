{"name":"Filter.inter_sets","module":"Mathlib.Order.Filter.Defs","initialProofState":"Î± : Type u_1\nself : Filter Î±\nx y : Set Î±\naâœÂ¹ : Membership.mem self.sets x\naâœ : Membership.mem self.sets y\nâŠ¢ Membership.mem self.sets (Inter.inter x y)","decl":"/-- A filter `F` on a type `Î±` is a collection of sets of `Î±` which contains the whole `Î±`,\nis upwards-closed, and is stable under intersection. We do not forbid this collection to be\nall sets of `Î±`. -/\nstructure Filter (Î± : Type*) where\n  /-- The set of sets that belong to the filter. -/\n  sets : Set (Set Î±)\n  /-- The set `Set.univ` belongs to any filter. -/\n  univ_sets : Set.univ âˆˆ sets\n  /-- If a set belongs to a filter, then its superset belongs to the filter as well. -/\n  sets_of_superset {x y} : x âˆˆ sets â†’ x âŠ† y â†’ y âˆˆ sets\n  /-- If two sets belong to a filter, then their intersection belongs to the filter as well. -/\n  inter_sets {x y} : x âˆˆ sets â†’ y âˆˆ sets â†’ x âˆ© y âˆˆ sets\n\n"}
{"name":"Filter.univ_sets","module":"Mathlib.Order.Filter.Defs","initialProofState":"Î± : Type u_1\nself : Filter Î±\nâŠ¢ Membership.mem self.sets Set.univ","decl":"/-- A filter `F` on a type `Î±` is a collection of sets of `Î±` which contains the whole `Î±`,\nis upwards-closed, and is stable under intersection. We do not forbid this collection to be\nall sets of `Î±`. -/\nstructure Filter (Î± : Type*) where\n  /-- The set of sets that belong to the filter. -/\n  sets : Set (Set Î±)\n  /-- The set `Set.univ` belongs to any filter. -/\n  univ_sets : Set.univ âˆˆ sets\n  /-- If a set belongs to a filter, then its superset belongs to the filter as well. -/\n  sets_of_superset {x y} : x âˆˆ sets â†’ x âŠ† y â†’ y âˆˆ sets\n  /-- If two sets belong to a filter, then their intersection belongs to the filter as well. -/\n  inter_sets {x y} : x âˆˆ sets â†’ y âˆˆ sets â†’ x âˆ© y âˆˆ sets\n\n"}
{"name":"Filter.mk.sizeOf_spec","module":"Mathlib.Order.Filter.Defs","initialProofState":"Î± : Type u_1\ninstâœ : SizeOf Î±\nsets : Set (Set Î±)\nuniv_sets : Membership.mem sets Set.univ\nsets_of_superset : âˆ€ {x y : Set Î±}, Membership.mem sets x â†’ HasSubset.Subset x y â†’ Membership.mem sets y\ninter_sets : âˆ€ {x y : Set Î±}, Membership.mem sets x â†’ Membership.mem sets y â†’ Membership.mem sets (Inter.inter x y)\nâŠ¢ Eq (SizeOf.sizeOf { sets := sets, univ_sets := univ_sets, sets_of_superset := sets_of_superset, inter_sets := inter_sets }) (HAdd.hAdd 1 (SizeOf.sizeOf univ_sets))","decl":"/-- A filter `F` on a type `Î±` is a collection of sets of `Î±` which contains the whole `Î±`,\nis upwards-closed, and is stable under intersection. We do not forbid this collection to be\nall sets of `Î±`. -/\nstructure Filter (Î± : Type*) where\n  /-- The set of sets that belong to the filter. -/\n  sets : Set (Set Î±)\n  /-- The set `Set.univ` belongs to any filter. -/\n  univ_sets : Set.univ âˆˆ sets\n  /-- If a set belongs to a filter, then its superset belongs to the filter as well. -/\n  sets_of_superset {x y} : x âˆˆ sets â†’ x âŠ† y â†’ y âˆˆ sets\n  /-- If two sets belong to a filter, then their intersection belongs to the filter as well. -/\n  inter_sets {x y} : x âˆˆ sets â†’ y âˆˆ sets â†’ x âˆ© y âˆˆ sets\n\n"}
{"name":"Filter.sets_of_superset","module":"Mathlib.Order.Filter.Defs","initialProofState":"Î± : Type u_1\nself : Filter Î±\nx y : Set Î±\naâœÂ¹ : Membership.mem self.sets x\naâœ : HasSubset.Subset x y\nâŠ¢ Membership.mem self.sets y","decl":"/-- A filter `F` on a type `Î±` is a collection of sets of `Î±` which contains the whole `Î±`,\nis upwards-closed, and is stable under intersection. We do not forbid this collection to be\nall sets of `Î±`. -/\nstructure Filter (Î± : Type*) where\n  /-- The set of sets that belong to the filter. -/\n  sets : Set (Set Î±)\n  /-- The set `Set.univ` belongs to any filter. -/\n  univ_sets : Set.univ âˆˆ sets\n  /-- If a set belongs to a filter, then its superset belongs to the filter as well. -/\n  sets_of_superset {x y} : x âˆˆ sets â†’ x âŠ† y â†’ y âˆˆ sets\n  /-- If two sets belong to a filter, then their intersection belongs to the filter as well. -/\n  inter_sets {x y} : x âˆˆ sets â†’ y âˆˆ sets â†’ x âˆ© y âˆˆ sets\n\n"}
{"name":"Filter.mk.injEq","module":"Mathlib.Order.Filter.Defs","initialProofState":"Î± : Type u_1\nsetsâœ : Set (Set Î±)\nuniv_setsâœ : Membership.mem setsâœ Set.univ\nsets_of_supersetâœ : âˆ€ {x y : Set Î±}, Membership.mem setsâœ x â†’ HasSubset.Subset x y â†’ Membership.mem setsâœ y\ninter_setsâœ : âˆ€ {x y : Set Î±}, Membership.mem setsâœ x â†’ Membership.mem setsâœ y â†’ Membership.mem setsâœ (Inter.inter x y)\nsets : Set (Set Î±)\nuniv_sets : Membership.mem sets Set.univ\nsets_of_superset : âˆ€ {x y : Set Î±}, Membership.mem sets x â†’ HasSubset.Subset x y â†’ Membership.mem sets y\ninter_sets : âˆ€ {x y : Set Î±}, Membership.mem sets x â†’ Membership.mem sets y â†’ Membership.mem sets (Inter.inter x y)\nâŠ¢ Eq (Eq { sets := setsâœ, univ_sets := univ_setsâœ, sets_of_superset := sets_of_supersetâœ, inter_sets := inter_setsâœ } { sets := sets, univ_sets := univ_sets, sets_of_superset := sets_of_superset, inter_sets := inter_sets }) (Eq setsâœ sets)","decl":"/-- A filter `F` on a type `Î±` is a collection of sets of `Î±` which contains the whole `Î±`,\nis upwards-closed, and is stable under intersection. We do not forbid this collection to be\nall sets of `Î±`. -/\nstructure Filter (Î± : Type*) where\n  /-- The set of sets that belong to the filter. -/\n  sets : Set (Set Î±)\n  /-- The set `Set.univ` belongs to any filter. -/\n  univ_sets : Set.univ âˆˆ sets\n  /-- If a set belongs to a filter, then its superset belongs to the filter as well. -/\n  sets_of_superset {x y} : x âˆˆ sets â†’ x âŠ† y â†’ y âˆˆ sets\n  /-- If two sets belong to a filter, then their intersection belongs to the filter as well. -/\n  inter_sets {x y} : x âˆˆ sets â†’ y âˆˆ sets â†’ x âˆ© y âˆˆ sets\n\n"}
{"name":"Filter.mk.inj","module":"Mathlib.Order.Filter.Defs","initialProofState":"Î± : Type u_1\nsetsâœ : Set (Set Î±)\nuniv_setsâœ : Membership.mem setsâœ Set.univ\nsets_of_supersetâœ : âˆ€ {x y : Set Î±}, Membership.mem setsâœ x â†’ HasSubset.Subset x y â†’ Membership.mem setsâœ y\ninter_setsâœ : âˆ€ {x y : Set Î±}, Membership.mem setsâœ x â†’ Membership.mem setsâœ y â†’ Membership.mem setsâœ (Inter.inter x y)\nsets : Set (Set Î±)\nuniv_sets : Membership.mem sets Set.univ\nsets_of_superset : âˆ€ {x y : Set Î±}, Membership.mem sets x â†’ HasSubset.Subset x y â†’ Membership.mem sets y\ninter_sets : âˆ€ {x y : Set Î±}, Membership.mem sets x â†’ Membership.mem sets y â†’ Membership.mem sets (Inter.inter x y)\nxâœ : Eq { sets := setsâœ, univ_sets := univ_setsâœ, sets_of_superset := sets_of_supersetâœ, inter_sets := inter_setsâœ } { sets := sets, univ_sets := univ_sets, sets_of_superset := sets_of_superset, inter_sets := inter_sets }\nâŠ¢ Eq setsâœ sets","decl":"/-- A filter `F` on a type `Î±` is a collection of sets of `Î±` which contains the whole `Î±`,\nis upwards-closed, and is stable under intersection. We do not forbid this collection to be\nall sets of `Î±`. -/\nstructure Filter (Î± : Type*) where\n  /-- The set of sets that belong to the filter. -/\n  sets : Set (Set Î±)\n  /-- The set `Set.univ` belongs to any filter. -/\n  univ_sets : Set.univ âˆˆ sets\n  /-- If a set belongs to a filter, then its superset belongs to the filter as well. -/\n  sets_of_superset {x y} : x âˆˆ sets â†’ x âŠ† y â†’ y âˆˆ sets\n  /-- If two sets belong to a filter, then their intersection belongs to the filter as well. -/\n  inter_sets {x y} : x âˆˆ sets â†’ y âˆˆ sets â†’ x âˆ© y âˆˆ sets\n\n"}
{"name":"Filter.filter_eq","module":"Mathlib.Order.Filter.Defs","initialProofState":"Î± : Type u_1\nf g : Filter Î±\naâœ : Eq f.sets g.sets\nâŠ¢ Eq f g","decl":"theorem filter_eq : âˆ€ {f g : Filter Î±}, f.sets = g.sets â†’ f = g\n  | âŸ¨_, _, _, _âŸ©, âŸ¨_, _, _, _âŸ©, rfl => rfl\n\n"}
{"name":"Filter.ext","module":"Mathlib.Order.Filter.Defs","initialProofState":"Î± : Type u_1\nf g : Filter Î±\nh : âˆ€ (s : Set Î±), Iff (Membership.mem f s) (Membership.mem g s)\nâŠ¢ Eq f g","decl":"@[ext]\nprotected theorem ext (h : âˆ€ s, s âˆˆ f â†” s âˆˆ g) : f = g := filter_eq <| Set.ext h\n\n"}
{"name":"Filter.ext_iff","module":"Mathlib.Order.Filter.Defs","initialProofState":"Î± : Type u_1\nf g : Filter Î±\nâŠ¢ Iff (Eq f g) (âˆ€ (s : Set Î±), Iff (Membership.mem f s) (Membership.mem g s))","decl":"@[ext]\nprotected theorem ext (h : âˆ€ s, s âˆˆ f â†” s âˆˆ g) : f = g := filter_eq <| Set.ext h\n\n"}
{"name":"Filter.mem_mk","module":"Mathlib.Order.Filter.Defs","initialProofState":"Î± : Type u_1\ns : Set Î±\nt : Set (Set Î±)\nhâ‚ : Membership.mem t Set.univ\nhâ‚‚ : âˆ€ {x y : Set Î±}, Membership.mem t x â†’ HasSubset.Subset x y â†’ Membership.mem t y\nhâ‚ƒ : âˆ€ {x y : Set Î±}, Membership.mem t x â†’ Membership.mem t y â†’ Membership.mem t (Inter.inter x y)\nâŠ¢ Iff (Membership.mem { sets := t, univ_sets := hâ‚, sets_of_superset := hâ‚‚, inter_sets := hâ‚ƒ } s) (Membership.mem t s)","decl":"@[simp]\nprotected theorem mem_mk {t : Set (Set Î±)} {hâ‚ hâ‚‚ hâ‚ƒ} : s âˆˆ mk t hâ‚ hâ‚‚ hâ‚ƒ â†” s âˆˆ t :=\n  Iff.rfl\n\n"}
{"name":"Filter.mem_sets","module":"Mathlib.Order.Filter.Defs","initialProofState":"Î± : Type u_1\nf : Filter Î±\ns : Set Î±\nâŠ¢ Iff (Membership.mem f.sets s) (Membership.mem f s)","decl":"@[simp]\nprotected theorem mem_sets : s âˆˆ f.sets â†” s âˆˆ f :=\n  Iff.rfl\n\n"}
{"name":"Filter.univ_mem","module":"Mathlib.Order.Filter.Defs","initialProofState":"Î± : Type u_1\nf : Filter Î±\nâŠ¢ Membership.mem f Set.univ","decl":"@[simp]\ntheorem univ_mem : univ âˆˆ f :=\n  f.univ_sets\n\n"}
{"name":"Filter.mem_of_superset","module":"Mathlib.Order.Filter.Defs","initialProofState":"Î± : Type u_1\nf : Filter Î±\nx y : Set Î±\nhx : Membership.mem f x\nhxy : HasSubset.Subset x y\nâŠ¢ Membership.mem f y","decl":"theorem mem_of_superset {x y : Set Î±} (hx : x âˆˆ f) (hxy : x âŠ† y) : y âˆˆ f :=\n  f.sets_of_superset hx hxy\n\n"}
{"name":"Filter.univ_mem'","module":"Mathlib.Order.Filter.Defs","initialProofState":"Î± : Type u_1\nf : Filter Î±\ns : Set Î±\nh : âˆ€ (a : Î±), Membership.mem s a\nâŠ¢ Membership.mem f s","decl":"theorem univ_mem' (h : âˆ€ a, a âˆˆ s) : s âˆˆ f :=\n  mem_of_superset univ_mem fun x _ => h x\n\n"}
{"name":"Filter.inter_mem","module":"Mathlib.Order.Filter.Defs","initialProofState":"Î± : Type u_1\nf : Filter Î±\ns t : Set Î±\nhs : Membership.mem f s\nht : Membership.mem f t\nâŠ¢ Membership.mem f (Inter.inter s t)","decl":"theorem inter_mem (hs : s âˆˆ f) (ht : t âˆˆ f) : s âˆ© t âˆˆ f :=\n  f.inter_sets hs ht\n\n"}
{"name":"Filter.mp_mem","module":"Mathlib.Order.Filter.Defs","initialProofState":"Î± : Type u_1\nf : Filter Î±\ns t : Set Î±\nhs : Membership.mem f s\nh : Membership.mem f (setOf fun x => Membership.mem s x â†’ Membership.mem t x)\nâŠ¢ Membership.mem f t","decl":"theorem mp_mem (hs : s âˆˆ f) (h : { x | x âˆˆ s â†’ x âˆˆ t } âˆˆ f) : t âˆˆ f :=\n  mem_of_superset (inter_mem hs h) fun _ âŸ¨hâ‚, hâ‚‚âŸ© => hâ‚‚ hâ‚\n\n"}
{"name":"Filter.mem_copy","module":"Mathlib.Order.Filter.Defs","initialProofState":"Î± : Type u_1\nf : Filter Î±\ns : Set Î±\nS : Set (Set Î±)\nhmem : âˆ€ (s : Set Î±), Iff (Membership.mem S s) (Membership.mem f s)\nâŠ¢ Iff (Membership.mem (f.copy S hmem) s) (Membership.mem S s)","decl":"@[simp] theorem mem_copy {S hmem} : s âˆˆ f.copy S hmem â†” s âˆˆ S := Iff.rfl\n\n"}
{"name":"Filter.mem_comk","module":"Mathlib.Order.Filter.Defs","initialProofState":"Î± : Type u_1\np : Set Î± â†’ Prop\nhe : p EmptyCollection.emptyCollection\nhmono : âˆ€ (t : Set Î±), p t â†’ âˆ€ (s : Set Î±), HasSubset.Subset s t â†’ p s\nhunion : âˆ€ (s : Set Î±), p s â†’ âˆ€ (t : Set Î±), p t â†’ p (Union.union s t)\ns : Set Î±\nâŠ¢ Iff (Membership.mem (Filter.comk p he hmono hunion) s) (p (HasCompl.compl s))","decl":"@[simp]\nlemma mem_comk {p : Set Î± â†’ Prop} {he hmono hunion s} :\n    s âˆˆ comk p he hmono hunion â†” p sá¶œ :=\n  .rfl\n\n"}
{"name":"Filter.mem_principal","module":"Mathlib.Order.Filter.Defs","initialProofState":"Î± : Type u_1\ns t : Set Î±\nâŠ¢ Iff (Membership.mem (Filter.principal t) s) (HasSubset.Subset t s)","decl":"@[simp] theorem mem_principal : s âˆˆ ð“Ÿ t â†” t âŠ† s := Iff.rfl\n\n"}
{"name":"Filter.mem_pure","module":"Mathlib.Order.Filter.Defs","initialProofState":"Î± : Type u_1\na : Î±\ns : Set Î±\nâŠ¢ Iff (Membership.mem (Pure.pure a) s) (Membership.mem s a)","decl":"@[simp]\ntheorem mem_pure {a : Î±} {s : Set Î±} : s âˆˆ (pure a : Filter Î±) â†” a âˆˆ s :=\n  Iff.rfl\n\n"}
{"name":"Filter.mem_join","module":"Mathlib.Order.Filter.Defs","initialProofState":"Î± : Type u_1\ns : Set Î±\nf : Filter (Filter Î±)\nâŠ¢ Iff (Membership.mem f.join s) (Membership.mem f (setOf fun t => Membership.mem t s))","decl":"@[simp]\ntheorem mem_join {s : Set Î±} {f : Filter (Filter Î±)} : s âˆˆ join f â†” { t | s âˆˆ t } âˆˆ f :=\n  Iff.rfl\n\n"}
{"name":"Filter.le_def","module":"Mathlib.Order.Filter.Defs","initialProofState":"Î± : Type u_1\nf g : Filter Î±\nâŠ¢ Iff (LE.le f g) (âˆ€ (x : Set Î±), Membership.mem g x â†’ Membership.mem f x)","decl":"theorem le_def : f â‰¤ g â†” âˆ€ x âˆˆ g, x âˆˆ f :=\n  Iff.rfl\n\n"}
{"name":"Filter.mem_sSup","module":"Mathlib.Order.Filter.Defs","initialProofState":"Î± : Type u_1\ns : Set Î±\nS : Set (Filter Î±)\nâŠ¢ Iff (Membership.mem (SupSet.sSup S) s) (âˆ€ (f : Filter Î±), Membership.mem S f â†’ Membership.mem f s)","decl":"@[simp] theorem mem_sSup {S : Set (Filter Î±)} : s âˆˆ sSup S â†” âˆ€ f âˆˆ S, s âˆˆ f := .rfl\n\n"}
{"name":"Filter.sSup_lowerBounds","module":"Mathlib.Order.Filter.Defs","initialProofState":"Î± : Type u_1\ns : Set (Filter Î±)\nâŠ¢ Eq (SupSet.sSup (lowerBounds s)) (InfSet.sInf s)","decl":"protected theorem sSup_lowerBounds (s : Set (Filter Î±)) : sSup (lowerBounds s) = sInf s := by\n  simp [sInf, Filter.sInf]\n\n"}
{"name":"Filter.mem_top_iff_forall","module":"Mathlib.Order.Filter.Defs","initialProofState":"Î± : Type u_1\ns : Set Î±\nâŠ¢ Iff (Membership.mem Top.top s) (âˆ€ (x : Î±), Membership.mem s x)","decl":"theorem mem_top_iff_forall {s : Set Î±} : s âˆˆ (âŠ¤ : Filter Î±) â†” âˆ€ x, x âˆˆ s :=\n  Iff.rfl\n\n"}
{"name":"Filter.mem_top","module":"Mathlib.Order.Filter.Defs","initialProofState":"Î± : Type u_1\ns : Set Î±\nâŠ¢ Iff (Membership.mem Top.top s) (Eq s Set.univ)","decl":"@[simp]\ntheorem mem_top {s : Set Î±} : s âˆˆ (âŠ¤ : Filter Î±) â†” s = univ := by\n  rw [mem_top_iff_forall, eq_univ_iff_forall]\n\n"}
{"name":"Filter.mem_bot","module":"Mathlib.Order.Filter.Defs","initialProofState":"Î± : Type u_1\ns : Set Î±\nâŠ¢ Membership.mem Bot.bot s","decl":"@[simp]\ntheorem mem_bot {s : Set Î±} : s âˆˆ (âŠ¥ : Filter Î±) :=\n  trivial\n\n"}
{"name":"Filter.NeBot.ne'","module":"Mathlib.Order.Filter.Defs","initialProofState":"Î± : Type u_1\nf : Filter Î±\nself : f.NeBot\nâŠ¢ Ne f Bot.bot","decl":"/-- A filter is `NeBot` if it is not equal to `âŠ¥`, or equivalently the empty set does not belong to\nthe filter. Bourbaki include this assumption in the definition of a filter but we prefer to have a\n`CompleteLattice` structure on `Filter _`, so we use a typeclass argument in lemmas instead. -/\nclass NeBot (f : Filter Î±) : Prop where\n  /-- The filter is nontrivial: `f â‰  âŠ¥` or equivalently, `âˆ… âˆ‰ f`. -/\n  ne' : f â‰  âŠ¥\n\n"}
{"name":"Filter.neBot_iff","module":"Mathlib.Order.Filter.Defs","initialProofState":"Î± : Type u_1\nf : Filter Î±\nâŠ¢ Iff f.NeBot (Ne f Bot.bot)","decl":"theorem neBot_iff {f : Filter Î±} : NeBot f â†” f â‰  âŠ¥ :=\n  âŸ¨fun h => h.1, fun h => âŸ¨hâŸ©âŸ©\n\n"}
{"name":"Filter.prod_eq_inf","module":"Mathlib.Order.Filter.Defs","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Filter Î±\ng : Filter Î²\nâŠ¢ Eq (SProd.sprod f g) (Min.min (Filter.comap Prod.fst f) (Filter.comap Prod.snd g))","decl":"theorem prod_eq_inf (f : Filter Î±) (g : Filter Î²) : f Ã—Ë¢ g = f.comap Prod.fst âŠ“ g.comap Prod.snd :=\n  rfl\n\n"}
