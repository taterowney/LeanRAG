{"name":"Filter.inter_sets","module":"Mathlib.Order.Filter.Defs","initialProofState":"α : Type u_1\nself : Filter α\nx y : Set α\na✝¹ : Membership.mem self.sets x\na✝ : Membership.mem self.sets y\n⊢ Membership.mem self.sets (Inter.inter x y)","decl":"/-- A filter `F` on a type `α` is a collection of sets of `α` which contains the whole `α`,\nis upwards-closed, and is stable under intersection. We do not forbid this collection to be\nall sets of `α`. -/\nstructure Filter (α : Type*) where\n  /-- The set of sets that belong to the filter. -/\n  sets : Set (Set α)\n  /-- The set `Set.univ` belongs to any filter. -/\n  univ_sets : Set.univ ∈ sets\n  /-- If a set belongs to a filter, then its superset belongs to the filter as well. -/\n  sets_of_superset {x y} : x ∈ sets → x ⊆ y → y ∈ sets\n  /-- If two sets belong to a filter, then their intersection belongs to the filter as well. -/\n  inter_sets {x y} : x ∈ sets → y ∈ sets → x ∩ y ∈ sets\n\n"}
{"name":"Filter.univ_sets","module":"Mathlib.Order.Filter.Defs","initialProofState":"α : Type u_1\nself : Filter α\n⊢ Membership.mem self.sets Set.univ","decl":"/-- A filter `F` on a type `α` is a collection of sets of `α` which contains the whole `α`,\nis upwards-closed, and is stable under intersection. We do not forbid this collection to be\nall sets of `α`. -/\nstructure Filter (α : Type*) where\n  /-- The set of sets that belong to the filter. -/\n  sets : Set (Set α)\n  /-- The set `Set.univ` belongs to any filter. -/\n  univ_sets : Set.univ ∈ sets\n  /-- If a set belongs to a filter, then its superset belongs to the filter as well. -/\n  sets_of_superset {x y} : x ∈ sets → x ⊆ y → y ∈ sets\n  /-- If two sets belong to a filter, then their intersection belongs to the filter as well. -/\n  inter_sets {x y} : x ∈ sets → y ∈ sets → x ∩ y ∈ sets\n\n"}
{"name":"Filter.mk.sizeOf_spec","module":"Mathlib.Order.Filter.Defs","initialProofState":"α : Type u_1\ninst✝ : SizeOf α\nsets : Set (Set α)\nuniv_sets : Membership.mem sets Set.univ\nsets_of_superset : ∀ {x y : Set α}, Membership.mem sets x → HasSubset.Subset x y → Membership.mem sets y\ninter_sets : ∀ {x y : Set α}, Membership.mem sets x → Membership.mem sets y → Membership.mem sets (Inter.inter x y)\n⊢ Eq (SizeOf.sizeOf { sets := sets, univ_sets := univ_sets, sets_of_superset := sets_of_superset, inter_sets := inter_sets }) (HAdd.hAdd 1 (SizeOf.sizeOf univ_sets))","decl":"/-- A filter `F` on a type `α` is a collection of sets of `α` which contains the whole `α`,\nis upwards-closed, and is stable under intersection. We do not forbid this collection to be\nall sets of `α`. -/\nstructure Filter (α : Type*) where\n  /-- The set of sets that belong to the filter. -/\n  sets : Set (Set α)\n  /-- The set `Set.univ` belongs to any filter. -/\n  univ_sets : Set.univ ∈ sets\n  /-- If a set belongs to a filter, then its superset belongs to the filter as well. -/\n  sets_of_superset {x y} : x ∈ sets → x ⊆ y → y ∈ sets\n  /-- If two sets belong to a filter, then their intersection belongs to the filter as well. -/\n  inter_sets {x y} : x ∈ sets → y ∈ sets → x ∩ y ∈ sets\n\n"}
{"name":"Filter.sets_of_superset","module":"Mathlib.Order.Filter.Defs","initialProofState":"α : Type u_1\nself : Filter α\nx y : Set α\na✝¹ : Membership.mem self.sets x\na✝ : HasSubset.Subset x y\n⊢ Membership.mem self.sets y","decl":"/-- A filter `F` on a type `α` is a collection of sets of `α` which contains the whole `α`,\nis upwards-closed, and is stable under intersection. We do not forbid this collection to be\nall sets of `α`. -/\nstructure Filter (α : Type*) where\n  /-- The set of sets that belong to the filter. -/\n  sets : Set (Set α)\n  /-- The set `Set.univ` belongs to any filter. -/\n  univ_sets : Set.univ ∈ sets\n  /-- If a set belongs to a filter, then its superset belongs to the filter as well. -/\n  sets_of_superset {x y} : x ∈ sets → x ⊆ y → y ∈ sets\n  /-- If two sets belong to a filter, then their intersection belongs to the filter as well. -/\n  inter_sets {x y} : x ∈ sets → y ∈ sets → x ∩ y ∈ sets\n\n"}
{"name":"Filter.mk.injEq","module":"Mathlib.Order.Filter.Defs","initialProofState":"α : Type u_1\nsets✝ : Set (Set α)\nuniv_sets✝ : Membership.mem sets✝ Set.univ\nsets_of_superset✝ : ∀ {x y : Set α}, Membership.mem sets✝ x → HasSubset.Subset x y → Membership.mem sets✝ y\ninter_sets✝ : ∀ {x y : Set α}, Membership.mem sets✝ x → Membership.mem sets✝ y → Membership.mem sets✝ (Inter.inter x y)\nsets : Set (Set α)\nuniv_sets : Membership.mem sets Set.univ\nsets_of_superset : ∀ {x y : Set α}, Membership.mem sets x → HasSubset.Subset x y → Membership.mem sets y\ninter_sets : ∀ {x y : Set α}, Membership.mem sets x → Membership.mem sets y → Membership.mem sets (Inter.inter x y)\n⊢ Eq (Eq { sets := sets✝, univ_sets := univ_sets✝, sets_of_superset := sets_of_superset✝, inter_sets := inter_sets✝ } { sets := sets, univ_sets := univ_sets, sets_of_superset := sets_of_superset, inter_sets := inter_sets }) (Eq sets✝ sets)","decl":"/-- A filter `F` on a type `α` is a collection of sets of `α` which contains the whole `α`,\nis upwards-closed, and is stable under intersection. We do not forbid this collection to be\nall sets of `α`. -/\nstructure Filter (α : Type*) where\n  /-- The set of sets that belong to the filter. -/\n  sets : Set (Set α)\n  /-- The set `Set.univ` belongs to any filter. -/\n  univ_sets : Set.univ ∈ sets\n  /-- If a set belongs to a filter, then its superset belongs to the filter as well. -/\n  sets_of_superset {x y} : x ∈ sets → x ⊆ y → y ∈ sets\n  /-- If two sets belong to a filter, then their intersection belongs to the filter as well. -/\n  inter_sets {x y} : x ∈ sets → y ∈ sets → x ∩ y ∈ sets\n\n"}
{"name":"Filter.mk.inj","module":"Mathlib.Order.Filter.Defs","initialProofState":"α : Type u_1\nsets✝ : Set (Set α)\nuniv_sets✝ : Membership.mem sets✝ Set.univ\nsets_of_superset✝ : ∀ {x y : Set α}, Membership.mem sets✝ x → HasSubset.Subset x y → Membership.mem sets✝ y\ninter_sets✝ : ∀ {x y : Set α}, Membership.mem sets✝ x → Membership.mem sets✝ y → Membership.mem sets✝ (Inter.inter x y)\nsets : Set (Set α)\nuniv_sets : Membership.mem sets Set.univ\nsets_of_superset : ∀ {x y : Set α}, Membership.mem sets x → HasSubset.Subset x y → Membership.mem sets y\ninter_sets : ∀ {x y : Set α}, Membership.mem sets x → Membership.mem sets y → Membership.mem sets (Inter.inter x y)\nx✝ : Eq { sets := sets✝, univ_sets := univ_sets✝, sets_of_superset := sets_of_superset✝, inter_sets := inter_sets✝ } { sets := sets, univ_sets := univ_sets, sets_of_superset := sets_of_superset, inter_sets := inter_sets }\n⊢ Eq sets✝ sets","decl":"/-- A filter `F` on a type `α` is a collection of sets of `α` which contains the whole `α`,\nis upwards-closed, and is stable under intersection. We do not forbid this collection to be\nall sets of `α`. -/\nstructure Filter (α : Type*) where\n  /-- The set of sets that belong to the filter. -/\n  sets : Set (Set α)\n  /-- The set `Set.univ` belongs to any filter. -/\n  univ_sets : Set.univ ∈ sets\n  /-- If a set belongs to a filter, then its superset belongs to the filter as well. -/\n  sets_of_superset {x y} : x ∈ sets → x ⊆ y → y ∈ sets\n  /-- If two sets belong to a filter, then their intersection belongs to the filter as well. -/\n  inter_sets {x y} : x ∈ sets → y ∈ sets → x ∩ y ∈ sets\n\n"}
{"name":"Filter.filter_eq","module":"Mathlib.Order.Filter.Defs","initialProofState":"α : Type u_1\nf g : Filter α\na✝ : Eq f.sets g.sets\n⊢ Eq f g","decl":"theorem filter_eq : ∀ {f g : Filter α}, f.sets = g.sets → f = g\n  | ⟨_, _, _, _⟩, ⟨_, _, _, _⟩, rfl => rfl\n\n"}
{"name":"Filter.ext","module":"Mathlib.Order.Filter.Defs","initialProofState":"α : Type u_1\nf g : Filter α\nh : ∀ (s : Set α), Iff (Membership.mem f s) (Membership.mem g s)\n⊢ Eq f g","decl":"@[ext]\nprotected theorem ext (h : ∀ s, s ∈ f ↔ s ∈ g) : f = g := filter_eq <| Set.ext h\n\n"}
{"name":"Filter.ext_iff","module":"Mathlib.Order.Filter.Defs","initialProofState":"α : Type u_1\nf g : Filter α\n⊢ Iff (Eq f g) (∀ (s : Set α), Iff (Membership.mem f s) (Membership.mem g s))","decl":"@[ext]\nprotected theorem ext (h : ∀ s, s ∈ f ↔ s ∈ g) : f = g := filter_eq <| Set.ext h\n\n"}
{"name":"Filter.mem_mk","module":"Mathlib.Order.Filter.Defs","initialProofState":"α : Type u_1\ns : Set α\nt : Set (Set α)\nh₁ : Membership.mem t Set.univ\nh₂ : ∀ {x y : Set α}, Membership.mem t x → HasSubset.Subset x y → Membership.mem t y\nh₃ : ∀ {x y : Set α}, Membership.mem t x → Membership.mem t y → Membership.mem t (Inter.inter x y)\n⊢ Iff (Membership.mem { sets := t, univ_sets := h₁, sets_of_superset := h₂, inter_sets := h₃ } s) (Membership.mem t s)","decl":"@[simp]\nprotected theorem mem_mk {t : Set (Set α)} {h₁ h₂ h₃} : s ∈ mk t h₁ h₂ h₃ ↔ s ∈ t :=\n  Iff.rfl\n\n"}
{"name":"Filter.mem_sets","module":"Mathlib.Order.Filter.Defs","initialProofState":"α : Type u_1\nf : Filter α\ns : Set α\n⊢ Iff (Membership.mem f.sets s) (Membership.mem f s)","decl":"@[simp]\nprotected theorem mem_sets : s ∈ f.sets ↔ s ∈ f :=\n  Iff.rfl\n\n"}
{"name":"Filter.univ_mem","module":"Mathlib.Order.Filter.Defs","initialProofState":"α : Type u_1\nf : Filter α\n⊢ Membership.mem f Set.univ","decl":"@[simp]\ntheorem univ_mem : univ ∈ f :=\n  f.univ_sets\n\n"}
{"name":"Filter.mem_of_superset","module":"Mathlib.Order.Filter.Defs","initialProofState":"α : Type u_1\nf : Filter α\nx y : Set α\nhx : Membership.mem f x\nhxy : HasSubset.Subset x y\n⊢ Membership.mem f y","decl":"theorem mem_of_superset {x y : Set α} (hx : x ∈ f) (hxy : x ⊆ y) : y ∈ f :=\n  f.sets_of_superset hx hxy\n\n"}
{"name":"Filter.univ_mem'","module":"Mathlib.Order.Filter.Defs","initialProofState":"α : Type u_1\nf : Filter α\ns : Set α\nh : ∀ (a : α), Membership.mem s a\n⊢ Membership.mem f s","decl":"theorem univ_mem' (h : ∀ a, a ∈ s) : s ∈ f :=\n  mem_of_superset univ_mem fun x _ => h x\n\n"}
{"name":"Filter.inter_mem","module":"Mathlib.Order.Filter.Defs","initialProofState":"α : Type u_1\nf : Filter α\ns t : Set α\nhs : Membership.mem f s\nht : Membership.mem f t\n⊢ Membership.mem f (Inter.inter s t)","decl":"theorem inter_mem (hs : s ∈ f) (ht : t ∈ f) : s ∩ t ∈ f :=\n  f.inter_sets hs ht\n\n"}
{"name":"Filter.mp_mem","module":"Mathlib.Order.Filter.Defs","initialProofState":"α : Type u_1\nf : Filter α\ns t : Set α\nhs : Membership.mem f s\nh : Membership.mem f (setOf fun x => Membership.mem s x → Membership.mem t x)\n⊢ Membership.mem f t","decl":"theorem mp_mem (hs : s ∈ f) (h : { x | x ∈ s → x ∈ t } ∈ f) : t ∈ f :=\n  mem_of_superset (inter_mem hs h) fun _ ⟨h₁, h₂⟩ => h₂ h₁\n\n"}
{"name":"Filter.mem_copy","module":"Mathlib.Order.Filter.Defs","initialProofState":"α : Type u_1\nf : Filter α\ns : Set α\nS : Set (Set α)\nhmem : ∀ (s : Set α), Iff (Membership.mem S s) (Membership.mem f s)\n⊢ Iff (Membership.mem (f.copy S hmem) s) (Membership.mem S s)","decl":"@[simp] theorem mem_copy {S hmem} : s ∈ f.copy S hmem ↔ s ∈ S := Iff.rfl\n\n"}
{"name":"Filter.mem_comk","module":"Mathlib.Order.Filter.Defs","initialProofState":"α : Type u_1\np : Set α → Prop\nhe : p EmptyCollection.emptyCollection\nhmono : ∀ (t : Set α), p t → ∀ (s : Set α), HasSubset.Subset s t → p s\nhunion : ∀ (s : Set α), p s → ∀ (t : Set α), p t → p (Union.union s t)\ns : Set α\n⊢ Iff (Membership.mem (Filter.comk p he hmono hunion) s) (p (HasCompl.compl s))","decl":"@[simp]\nlemma mem_comk {p : Set α → Prop} {he hmono hunion s} :\n    s ∈ comk p he hmono hunion ↔ p sᶜ :=\n  .rfl\n\n"}
{"name":"Filter.mem_principal","module":"Mathlib.Order.Filter.Defs","initialProofState":"α : Type u_1\ns t : Set α\n⊢ Iff (Membership.mem (Filter.principal t) s) (HasSubset.Subset t s)","decl":"@[simp] theorem mem_principal : s ∈ 𝓟 t ↔ t ⊆ s := Iff.rfl\n\n"}
{"name":"Filter.mem_pure","module":"Mathlib.Order.Filter.Defs","initialProofState":"α : Type u_1\na : α\ns : Set α\n⊢ Iff (Membership.mem (Pure.pure a) s) (Membership.mem s a)","decl":"@[simp]\ntheorem mem_pure {a : α} {s : Set α} : s ∈ (pure a : Filter α) ↔ a ∈ s :=\n  Iff.rfl\n\n"}
{"name":"Filter.mem_join","module":"Mathlib.Order.Filter.Defs","initialProofState":"α : Type u_1\ns : Set α\nf : Filter (Filter α)\n⊢ Iff (Membership.mem f.join s) (Membership.mem f (setOf fun t => Membership.mem t s))","decl":"@[simp]\ntheorem mem_join {s : Set α} {f : Filter (Filter α)} : s ∈ join f ↔ { t | s ∈ t } ∈ f :=\n  Iff.rfl\n\n"}
{"name":"Filter.le_def","module":"Mathlib.Order.Filter.Defs","initialProofState":"α : Type u_1\nf g : Filter α\n⊢ Iff (LE.le f g) (∀ (x : Set α), Membership.mem g x → Membership.mem f x)","decl":"theorem le_def : f ≤ g ↔ ∀ x ∈ g, x ∈ f :=\n  Iff.rfl\n\n"}
{"name":"Filter.mem_sSup","module":"Mathlib.Order.Filter.Defs","initialProofState":"α : Type u_1\ns : Set α\nS : Set (Filter α)\n⊢ Iff (Membership.mem (SupSet.sSup S) s) (∀ (f : Filter α), Membership.mem S f → Membership.mem f s)","decl":"@[simp] theorem mem_sSup {S : Set (Filter α)} : s ∈ sSup S ↔ ∀ f ∈ S, s ∈ f := .rfl\n\n"}
{"name":"Filter.sSup_lowerBounds","module":"Mathlib.Order.Filter.Defs","initialProofState":"α : Type u_1\ns : Set (Filter α)\n⊢ Eq (SupSet.sSup (lowerBounds s)) (InfSet.sInf s)","decl":"protected theorem sSup_lowerBounds (s : Set (Filter α)) : sSup (lowerBounds s) = sInf s := by\n  simp [sInf, Filter.sInf]\n\n"}
{"name":"Filter.mem_top_iff_forall","module":"Mathlib.Order.Filter.Defs","initialProofState":"α : Type u_1\ns : Set α\n⊢ Iff (Membership.mem Top.top s) (∀ (x : α), Membership.mem s x)","decl":"theorem mem_top_iff_forall {s : Set α} : s ∈ (⊤ : Filter α) ↔ ∀ x, x ∈ s :=\n  Iff.rfl\n\n"}
{"name":"Filter.mem_top","module":"Mathlib.Order.Filter.Defs","initialProofState":"α : Type u_1\ns : Set α\n⊢ Iff (Membership.mem Top.top s) (Eq s Set.univ)","decl":"@[simp]\ntheorem mem_top {s : Set α} : s ∈ (⊤ : Filter α) ↔ s = univ := by\n  rw [mem_top_iff_forall, eq_univ_iff_forall]\n\n"}
{"name":"Filter.mem_bot","module":"Mathlib.Order.Filter.Defs","initialProofState":"α : Type u_1\ns : Set α\n⊢ Membership.mem Bot.bot s","decl":"@[simp]\ntheorem mem_bot {s : Set α} : s ∈ (⊥ : Filter α) :=\n  trivial\n\n"}
{"name":"Filter.NeBot.ne'","module":"Mathlib.Order.Filter.Defs","initialProofState":"α : Type u_1\nf : Filter α\nself : f.NeBot\n⊢ Ne f Bot.bot","decl":"/-- A filter is `NeBot` if it is not equal to `⊥`, or equivalently the empty set does not belong to\nthe filter. Bourbaki include this assumption in the definition of a filter but we prefer to have a\n`CompleteLattice` structure on `Filter _`, so we use a typeclass argument in lemmas instead. -/\nclass NeBot (f : Filter α) : Prop where\n  /-- The filter is nontrivial: `f ≠ ⊥` or equivalently, `∅ ∉ f`. -/\n  ne' : f ≠ ⊥\n\n"}
{"name":"Filter.neBot_iff","module":"Mathlib.Order.Filter.Defs","initialProofState":"α : Type u_1\nf : Filter α\n⊢ Iff f.NeBot (Ne f Bot.bot)","decl":"theorem neBot_iff {f : Filter α} : NeBot f ↔ f ≠ ⊥ :=\n  ⟨fun h => h.1, fun h => ⟨h⟩⟩\n\n"}
{"name":"Filter.prod_eq_inf","module":"Mathlib.Order.Filter.Defs","initialProofState":"α : Type u_1\nβ : Type u_2\nf : Filter α\ng : Filter β\n⊢ Eq (SProd.sprod f g) (Min.min (Filter.comap Prod.fst f) (Filter.comap Prod.snd g))","decl":"theorem prod_eq_inf (f : Filter α) (g : Filter β) : f ×ˢ g = f.comap Prod.fst ⊓ g.comap Prod.snd :=\n  rfl\n\n"}
