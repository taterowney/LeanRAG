{"name":"Ideal.isIdempotentElem_iff_of_fg","module":"Mathlib.RingTheory.Ideal.IdempotentFG","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nI : Ideal R\nh : I.FG\n⊢ Iff (IsIdempotentElem I) (Exists fun e => And (IsIdempotentElem e) (Eq I (Submodule.span R (Singleton.singleton e))))","decl":"/-- A finitely generated idempotent ideal is generated by an idempotent element -/\ntheorem isIdempotentElem_iff_of_fg {R : Type*} [CommRing R] (I : Ideal R) (h : I.FG) :\n    IsIdempotentElem I ↔ ∃ e : R, IsIdempotentElem e ∧ I = R ∙ e := by\n  constructor\n  · intro e\n    obtain ⟨r, hr, hr'⟩ :=\n      Submodule.exists_mem_and_smul_eq_self_of_fg_of_le_smul I I h\n        (by\n          rw [smul_eq_mul]\n          exact e.ge)\n    simp_rw [smul_eq_mul] at hr'\n    refine ⟨r, hr' r hr, antisymm ?_ ((Submodule.span_singleton_le_iff_mem _ _).mpr hr)⟩\n    intro x hx\n    rw [← hr' x hx]\n    exact Ideal.mem_span_singleton'.mpr ⟨_, mul_comm _ _⟩\n  · rintro ⟨e, he, rfl⟩\n    simp [IsIdempotentElem, Ideal.span_singleton_mul_span_singleton, he.eq]\n\n"}
{"name":"Ideal.isIdempotentElem_iff_eq_bot_or_top","module":"Mathlib.RingTheory.Ideal.IdempotentFG","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\nI : Ideal R\nh : I.FG\n⊢ Iff (IsIdempotentElem I) (Or (Eq I Bot.bot) (Eq I Top.top))","decl":"theorem isIdempotentElem_iff_eq_bot_or_top {R : Type*} [CommRing R] [IsDomain R] (I : Ideal R)\n    (h : I.FG) : IsIdempotentElem I ↔ I = ⊥ ∨ I = ⊤ := by\n  constructor\n  · intro H\n    obtain ⟨e, he, rfl⟩ := (I.isIdempotentElem_iff_of_fg h).mp H\n    simp only [Ideal.submodule_span_eq, Ideal.span_singleton_eq_bot]\n    apply Or.imp id _ (IsIdempotentElem.iff_eq_zero_or_one.mp he)\n    rintro rfl\n    simp\n  · rintro (rfl | rfl) <;> simp [IsIdempotentElem]\n\n"}
