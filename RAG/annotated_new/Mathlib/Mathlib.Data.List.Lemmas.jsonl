{"name":"List.Nat.sum_eq_listSum","module":"Mathlib.Data.List.Lemmas","initialProofState":"l : List Nat\n⊢ Eq (Nat.sum l) l.sum","decl":"set_option linter.deprecated false in\n@[simp, deprecated \"No deprecation message was provided.\" (since := \"2024-10-17\")]\nlemma Nat.sum_eq_listSum (l : List ℕ) : Nat.sum l = l.sum := rfl\n\n"}
{"name":"List.getElem_reverse'","module":"Mathlib.Data.List.Lemmas","initialProofState":"α : Type u_1\nl : List α\ni : Nat\nh : LT.lt i l.reverse.length\n⊢ Eq (GetElem.getElem l.reverse i h) (GetElem.getElem l (HSub.hSub (HSub.hSub l.length 1) i) ⋯)","decl":"@[deprecated (since := \"2024-08-20\")] alias getElem_reverse' := getElem_reverse\n\n"}
{"name":"List.tail_reverse_eq_reverse_dropLast","module":"Mathlib.Data.List.Lemmas","initialProofState":"α : Type u_1\nl : List α\n⊢ Eq l.reverse.tail l.dropLast.reverse","decl":"@[deprecated (since := \"2024-12-10\")] alias tail_reverse_eq_reverse_dropLast := tail_reverse\n\n"}
{"name":"List.nthLe_tail","module":"Mathlib.Data.List.Lemmas","initialProofState":"α : Type u_1\nl : List α\ni : Nat\nh : LT.lt i l.tail.length\n⊢ Eq (GetElem.getElem l.tail i h) (GetElem.getElem l (HAdd.hAdd i 1) ⋯)","decl":"@[deprecated (since := \"2024-08-19\")] alias nthLe_tail := getElem_tail\n\n"}
{"name":"List.injOn_insertIdx_index_of_not_mem","module":"Mathlib.Data.List.Lemmas","initialProofState":"α : Type u_1\nl : List α\nx : α\nhx : Not (Membership.mem l x)\n⊢ Set.InjOn (fun k => List.insertIdx k x l) (setOf fun n => LE.le n l.length)","decl":"theorem injOn_insertIdx_index_of_not_mem (l : List α) (x : α) (hx : x ∉ l) :\n    Set.InjOn (fun k => insertIdx k x l) { n | n ≤ l.length } := by\n  induction' l with hd tl IH\n  · intro n hn m hm _\n    simp_all [Set.mem_singleton_iff, Set.setOf_eq_eq_singleton, length]\n  · intro n hn m hm h\n    simp only [length, Set.mem_setOf_eq] at hn hm\n    simp only [mem_cons, not_or] at hx\n    cases n <;> cases m\n    · rfl\n    · simp [hx.left] at h\n    · simp [Ne.symm hx.left] at h\n    · simp only [true_and, eq_self_iff_true, insertIdx_succ_cons] at h\n      rw [Nat.succ_inj']\n      refine IH hx.right ?_ ?_ (by injection h)\n      · simpa [Nat.succ_le_succ_iff] using hn\n      · simpa [Nat.succ_le_succ_iff] using hm\n\n"}
{"name":"List.injOn_insertNth_index_of_not_mem","module":"Mathlib.Data.List.Lemmas","initialProofState":"α : Type u_1\nl : List α\nx : α\nhx : Not (Membership.mem l x)\n⊢ Set.InjOn (fun k => List.insertIdx k x l) (setOf fun n => LE.le n l.length)","decl":"@[deprecated (since := \"2024-10-21\")]\nalias injOn_insertNth_index_of_not_mem := injOn_insertIdx_index_of_not_mem\n\n"}
{"name":"List.foldr_range_subset_of_range_subset","module":"Mathlib.Data.List.Lemmas","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nf : β → α → α\ng : γ → α → α\nhfg : HasSubset.Subset (Set.range f) (Set.range g)\na : α\n⊢ HasSubset.Subset (Set.range (List.foldr f a)) (Set.range (List.foldr g a))","decl":"theorem foldr_range_subset_of_range_subset {f : β → α → α} {g : γ → α → α}\n    (hfg : Set.range f ⊆ Set.range g) (a : α) : Set.range (foldr f a) ⊆ Set.range (foldr g a) := by\n  rintro _ ⟨l, rfl⟩\n  induction' l with b l H\n  · exact ⟨[], rfl⟩\n  · cases' hfg (Set.mem_range_self b) with c hgf\n    cases' H with m hgf'\n    rw [foldr_cons, ← hgf, ← hgf']\n    exact ⟨c :: m, rfl⟩\n\n"}
{"name":"List.foldl_range_subset_of_range_subset","module":"Mathlib.Data.List.Lemmas","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nf : α → β → α\ng : α → γ → α\nhfg : HasSubset.Subset (Set.range fun a c => f c a) (Set.range fun b c => g c b)\na : α\n⊢ HasSubset.Subset (Set.range (List.foldl f a)) (Set.range (List.foldl g a))","decl":"theorem foldl_range_subset_of_range_subset {f : α → β → α} {g : α → γ → α}\n    (hfg : (Set.range fun a c => f c a) ⊆ Set.range fun b c => g c b) (a : α) :\n    Set.range (foldl f a) ⊆ Set.range (foldl g a) := by\n  change (Set.range fun l => _) ⊆ Set.range fun l => _\n  -- Porting note: This was simply `simp_rw [← foldr_reverse]`\n  simp_rw [← foldr_reverse _ (fun z w => g w z), ← foldr_reverse _ (fun z w => f w z)]\n  -- Porting note: This `change` was not necessary in mathlib3\n  change (Set.range (foldr (fun z w => f w z) a ∘ reverse)) ⊆\n    Set.range (foldr (fun z w => g w z) a ∘ reverse)\n  simp_rw [Set.range_comp _ reverse, reverse_involutive.bijective.surjective.range_eq,\n    Set.image_univ]\n  exact foldr_range_subset_of_range_subset hfg a\n\n"}
{"name":"List.foldr_range_eq_of_range_eq","module":"Mathlib.Data.List.Lemmas","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nf : β → α → α\ng : γ → α → α\nhfg : Eq (Set.range f) (Set.range g)\na : α\n⊢ Eq (Set.range (List.foldr f a)) (Set.range (List.foldr g a))","decl":"theorem foldr_range_eq_of_range_eq {f : β → α → α} {g : γ → α → α} (hfg : Set.range f = Set.range g)\n    (a : α) : Set.range (foldr f a) = Set.range (foldr g a) :=\n  (foldr_range_subset_of_range_subset hfg.le a).antisymm\n    (foldr_range_subset_of_range_subset hfg.ge a)\n\n"}
{"name":"List.foldl_range_eq_of_range_eq","module":"Mathlib.Data.List.Lemmas","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nf : α → β → α\ng : α → γ → α\nhfg : Eq (Set.range fun a c => f c a) (Set.range fun b c => g c b)\na : α\n⊢ Eq (Set.range (List.foldl f a)) (Set.range (List.foldl g a))","decl":"theorem foldl_range_eq_of_range_eq {f : α → β → α} {g : α → γ → α}\n    (hfg : (Set.range fun a c => f c a) = Set.range fun b c => g c b) (a : α) :\n    Set.range (foldl f a) = Set.range (foldl g a) :=\n  (foldl_range_subset_of_range_subset hfg.le a).antisymm\n    (foldl_range_subset_of_range_subset hfg.ge a)\n\n\n\n"}
{"name":"List.mapAccumr_eq_foldr","module":"Mathlib.Data.List.Lemmas","initialProofState":"α : Type u_1\nβ : Type u_2\nσ : Type u_4\nf : α → σ → Prod σ β\nas : List α\ns : σ\n⊢ Eq (List.mapAccumr f as s)\n    (List.foldr\n      (fun a s =>\n        let r := f a s.1;\n        { fst := r.1, snd := List.cons r.2 s.2 })\n      { fst := s, snd := List.nil } as)","decl":"theorem mapAccumr_eq_foldr {σ : Type*} (f : α → σ → σ × β) : ∀ (as : List α) (s : σ),\n    mapAccumr f as s = List.foldr (fun a s =>\n                                    let r := f a s.1\n                                    (r.1, r.2 :: s.2)\n                                  ) (s, []) as\n  | [], _ => rfl\n  | a :: as, s => by\n    simp only [mapAccumr, foldr, mapAccumr_eq_foldr f as]\n\n"}
{"name":"List.mapAccumr₂_eq_foldr","module":"Mathlib.Data.List.Lemmas","initialProofState":"α : Type u_1\nβ : Type u_2\nσ : Type u_4\nφ : Type u_5\nf : α → β → σ → Prod σ φ\nas : List α\nbs : List β\ns : σ\n⊢ Eq (List.mapAccumr₂ f as bs s)\n    (List.foldr\n      (fun ab s =>\n        let r := f ab.1 ab.2 s.1;\n        { fst := r.1, snd := List.cons r.2 s.2 })\n      { fst := s, snd := List.nil } (as.zip bs))","decl":"theorem mapAccumr₂_eq_foldr {σ φ : Type*} (f : α → β → σ → σ × φ) :\n    ∀ (as : List α) (bs : List β) (s : σ),\n    mapAccumr₂ f as bs s = foldr (fun ab s =>\n                              let r := f ab.1 ab.2 s.1\n                              (r.1, r.2 :: s.2)\n                            ) (s, []) (as.zip bs)\n  | [], [], _ => rfl\n  | _ :: _, [], _ => rfl\n  | [], _ :: _, _ => rfl\n  | a :: as, b :: bs, s => by\n    simp only [mapAccumr₂, foldr, mapAccumr₂_eq_foldr f as]\n    rfl\n\n"}
