{"name":"IsBoundedLinearMap.toIsLinearMap","module":"Mathlib.Analysis.Normed.Operator.BoundedLinearMaps","initialProofState":"𝕜 : Type u_5\ninst✝⁴ : NormedField 𝕜\nE : Type u_6\ninst✝³ : SeminormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_7\ninst✝¹ : SeminormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nself : IsBoundedLinearMap 𝕜 f\n⊢ IsLinearMap 𝕜 f","decl":"/-- A function `f` satisfies `IsBoundedLinearMap 𝕜 f` if it is linear and satisfies the\ninequality `‖f x‖ ≤ M * ‖x‖` for some positive constant `M`. -/\nstructure IsBoundedLinearMap (𝕜 : Type*) [NormedField 𝕜] {E : Type*} [SeminormedAddCommGroup E]\n  [NormedSpace 𝕜 E] {F : Type*} [SeminormedAddCommGroup F] [NormedSpace 𝕜 F] (f : E → F) extends\n  IsLinearMap 𝕜 f : Prop where\n  bound : ∃ M, 0 < M ∧ ∀ x : E, ‖f x‖ ≤ M * ‖x‖\n\n"}
{"name":"IsBoundedLinearMap.bound","module":"Mathlib.Analysis.Normed.Operator.BoundedLinearMaps","initialProofState":"𝕜 : Type u_5\ninst✝⁴ : NormedField 𝕜\nE : Type u_6\ninst✝³ : SeminormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_7\ninst✝¹ : SeminormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nself : IsBoundedLinearMap 𝕜 f\n⊢ Exists fun M => And (LT.lt 0 M) (∀ (x : E), LE.le (Norm.norm (f x)) (HMul.hMul M (Norm.norm x)))","decl":"/-- A function `f` satisfies `IsBoundedLinearMap 𝕜 f` if it is linear and satisfies the\ninequality `‖f x‖ ≤ M * ‖x‖` for some positive constant `M`. -/\nstructure IsBoundedLinearMap (𝕜 : Type*) [NormedField 𝕜] {E : Type*} [SeminormedAddCommGroup E]\n  [NormedSpace 𝕜 E] {F : Type*} [SeminormedAddCommGroup F] [NormedSpace 𝕜 F] (f : E → F) extends\n  IsLinearMap 𝕜 f : Prop where\n  bound : ∃ M, 0 < M ∧ ∀ x : E, ‖f x‖ ≤ M * ‖x‖\n\n"}
{"name":"IsLinearMap.with_bound","module":"Mathlib.Analysis.Normed.Operator.BoundedLinearMaps","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : SeminormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : SeminormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nhf : IsLinearMap 𝕜 f\nM : Real\nh : ∀ (x : E), LE.le (Norm.norm (f x)) (HMul.hMul M (Norm.norm x))\n⊢ IsBoundedLinearMap 𝕜 f","decl":"theorem IsLinearMap.with_bound {f : E → F} (hf : IsLinearMap 𝕜 f) (M : ℝ)\n    (h : ∀ x : E, ‖f x‖ ≤ M * ‖x‖) : IsBoundedLinearMap 𝕜 f :=\n  ⟨hf,\n    by_cases\n      (fun (this : M ≤ 0) =>\n        ⟨1, zero_lt_one, fun x =>\n          (h x).trans <| mul_le_mul_of_nonneg_right (this.trans zero_le_one) (norm_nonneg x)⟩)\n      fun (this : ¬M ≤ 0) => ⟨M, lt_of_not_ge this, h⟩⟩\n\n"}
{"name":"ContinuousLinearMap.isBoundedLinearMap","module":"Mathlib.Analysis.Normed.Operator.BoundedLinearMaps","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : SeminormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : SeminormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : ContinuousLinearMap (RingHom.id 𝕜) E F\n⊢ IsBoundedLinearMap 𝕜 ⇑f","decl":"/-- A continuous linear map satisfies `IsBoundedLinearMap` -/\ntheorem ContinuousLinearMap.isBoundedLinearMap (f : E →L[𝕜] F) : IsBoundedLinearMap 𝕜 f :=\n  { f.toLinearMap.isLinear with bound := f.bound }\n\n"}
{"name":"IsBoundedLinearMap.zero","module":"Mathlib.Analysis.Normed.Operator.BoundedLinearMaps","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : SeminormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : SeminormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\n⊢ IsBoundedLinearMap 𝕜 fun x => 0","decl":"theorem zero : IsBoundedLinearMap 𝕜 fun _ : E => (0 : F) :=\n  (0 : E →ₗ[𝕜] F).isLinear.with_bound 0 <| by simp [le_refl]\n\n"}
{"name":"IsBoundedLinearMap.id","module":"Mathlib.Analysis.Normed.Operator.BoundedLinearMaps","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝¹ : SeminormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\n⊢ IsBoundedLinearMap 𝕜 fun x => x","decl":"theorem id : IsBoundedLinearMap 𝕜 fun x : E => x :=\n  LinearMap.id.isLinear.with_bound 1 <| by simp [le_refl]\n\n"}
{"name":"IsBoundedLinearMap.fst","module":"Mathlib.Analysis.Normed.Operator.BoundedLinearMaps","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : SeminormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : SeminormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\n⊢ IsBoundedLinearMap 𝕜 fun x => x.1","decl":"theorem fst : IsBoundedLinearMap 𝕜 fun x : E × F => x.1 := by\n  refine (LinearMap.fst 𝕜 E F).isLinear.with_bound 1 fun x => ?_\n  rw [one_mul]\n  exact le_max_left _ _\n\n"}
{"name":"IsBoundedLinearMap.snd","module":"Mathlib.Analysis.Normed.Operator.BoundedLinearMaps","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : SeminormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : SeminormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\n⊢ IsBoundedLinearMap 𝕜 fun x => x.2","decl":"theorem snd : IsBoundedLinearMap 𝕜 fun x : E × F => x.2 := by\n  refine (LinearMap.snd 𝕜 E F).isLinear.with_bound 1 fun x => ?_\n  rw [one_mul]\n  exact le_max_right _ _\n\n"}
{"name":"IsBoundedLinearMap.smul","module":"Mathlib.Analysis.Normed.Operator.BoundedLinearMaps","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : SeminormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : SeminormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nc : 𝕜\nhf : IsBoundedLinearMap 𝕜 f\n⊢ IsBoundedLinearMap 𝕜 (HSMul.hSMul c f)","decl":"theorem smul (c : 𝕜) (hf : IsBoundedLinearMap 𝕜 f) : IsBoundedLinearMap 𝕜 (c • f) :=\n  let ⟨hlf, M, _, hM⟩ := hf\n  (c • hlf.mk' f).isLinear.with_bound (‖c‖ * M) fun x =>\n    calc\n      ‖c • f x‖ = ‖c‖ * ‖f x‖ := norm_smul c (f x)\n      _ ≤ ‖c‖ * (M * ‖x‖) := mul_le_mul_of_nonneg_left (hM _) (norm_nonneg _)\n      _ = ‖c‖ * M * ‖x‖ := (mul_assoc _ _ _).symm\n\n"}
{"name":"IsBoundedLinearMap.neg","module":"Mathlib.Analysis.Normed.Operator.BoundedLinearMaps","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : SeminormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : SeminormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nhf : IsBoundedLinearMap 𝕜 f\n⊢ IsBoundedLinearMap 𝕜 fun e => Neg.neg (f e)","decl":"theorem neg (hf : IsBoundedLinearMap 𝕜 f) : IsBoundedLinearMap 𝕜 fun e => -f e := by\n  rw [show (fun e => -f e) = fun e => (-1 : 𝕜) • f e by funext; simp]\n  exact smul (-1) hf\n\n"}
{"name":"IsBoundedLinearMap.add","module":"Mathlib.Analysis.Normed.Operator.BoundedLinearMaps","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : SeminormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : SeminormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf g : E → F\nhf : IsBoundedLinearMap 𝕜 f\nhg : IsBoundedLinearMap 𝕜 g\n⊢ IsBoundedLinearMap 𝕜 fun e => HAdd.hAdd (f e) (g e)","decl":"theorem add (hf : IsBoundedLinearMap 𝕜 f) (hg : IsBoundedLinearMap 𝕜 g) :\n    IsBoundedLinearMap 𝕜 fun e => f e + g e :=\n  let ⟨hlf, Mf, _, hMf⟩ := hf\n  let ⟨hlg, Mg, _, hMg⟩ := hg\n  (hlf.mk' _ + hlg.mk' _).isLinear.with_bound (Mf + Mg) fun x =>\n    calc\n      ‖f x + g x‖ ≤ Mf * ‖x‖ + Mg * ‖x‖ := norm_add_le_of_le (hMf x) (hMg x)\n      _ ≤ (Mf + Mg) * ‖x‖ := by rw [add_mul]\n\n"}
{"name":"IsBoundedLinearMap.sub","module":"Mathlib.Analysis.Normed.Operator.BoundedLinearMaps","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : SeminormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : SeminormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf g : E → F\nhf : IsBoundedLinearMap 𝕜 f\nhg : IsBoundedLinearMap 𝕜 g\n⊢ IsBoundedLinearMap 𝕜 fun e => HSub.hSub (f e) (g e)","decl":"theorem sub (hf : IsBoundedLinearMap 𝕜 f) (hg : IsBoundedLinearMap 𝕜 g) :\n    IsBoundedLinearMap 𝕜 fun e => f e - g e := by simpa [sub_eq_add_neg] using add hf (neg hg)\n\n"}
{"name":"IsBoundedLinearMap.comp","module":"Mathlib.Analysis.Normed.Operator.BoundedLinearMaps","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁵ : SeminormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝³ : SeminormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type u_4\ninst✝¹ : SeminormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nf : E → F\ng : F → G\nhg : IsBoundedLinearMap 𝕜 g\nhf : IsBoundedLinearMap 𝕜 f\n⊢ IsBoundedLinearMap 𝕜 (Function.comp g f)","decl":"theorem comp {g : F → G} (hg : IsBoundedLinearMap 𝕜 g) (hf : IsBoundedLinearMap 𝕜 f) :\n    IsBoundedLinearMap 𝕜 (g ∘ f) :=\n  (hg.toContinuousLinearMap.comp hf.toContinuousLinearMap).isBoundedLinearMap\n\n"}
{"name":"IsBoundedLinearMap.tendsto","module":"Mathlib.Analysis.Normed.Operator.BoundedLinearMaps","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : SeminormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : SeminormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nx : E\nhf : IsBoundedLinearMap 𝕜 f\n⊢ Filter.Tendsto f (nhds x) (nhds (f x))","decl":"protected theorem tendsto (x : E) (hf : IsBoundedLinearMap 𝕜 f) : Tendsto f (𝓝 x) (𝓝 (f x)) :=\n  let ⟨hf, M, _, hM⟩ := hf\n  tendsto_iff_norm_sub_tendsto_zero.2 <|\n    squeeze_zero (fun _ => norm_nonneg _)\n      (fun e =>\n        calc\n          ‖f e - f x‖ = ‖hf.mk' f (e - x)‖ := by rw [(hf.mk' _).map_sub e x]; rfl\n          _ ≤ M * ‖e - x‖ := hM (e - x)\n          )\n      (suffices Tendsto (fun e : E => M * ‖e - x‖) (𝓝 x) (𝓝 (M * 0)) by simpa\n      tendsto_const_nhds.mul (tendsto_norm_sub_self _))\n\n"}
{"name":"IsBoundedLinearMap.continuous","module":"Mathlib.Analysis.Normed.Operator.BoundedLinearMaps","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : SeminormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : SeminormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nhf : IsBoundedLinearMap 𝕜 f\n⊢ Continuous f","decl":"theorem continuous (hf : IsBoundedLinearMap 𝕜 f) : Continuous f :=\n  continuous_iff_continuousAt.2 fun _ => hf.tendsto _\n\n"}
{"name":"IsBoundedLinearMap.lim_zero_bounded_linear_map","module":"Mathlib.Analysis.Normed.Operator.BoundedLinearMaps","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : SeminormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : SeminormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nhf : IsBoundedLinearMap 𝕜 f\n⊢ Filter.Tendsto f (nhds 0) (nhds 0)","decl":"theorem lim_zero_bounded_linear_map (hf : IsBoundedLinearMap 𝕜 f) : Tendsto f (𝓝 0) (𝓝 0) :=\n  (hf.1.mk' _).map_zero ▸ continuous_iff_continuousAt.1 hf.continuous 0\n\n"}
{"name":"IsBoundedLinearMap.isBigO_id","module":"Mathlib.Analysis.Normed.Operator.BoundedLinearMaps","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : SeminormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : SeminormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nh : IsBoundedLinearMap 𝕜 f\nl : Filter E\n⊢ Asymptotics.IsBigO l f fun x => x","decl":"theorem isBigO_id {f : E → F} (h : IsBoundedLinearMap 𝕜 f) (l : Filter E) : f =O[l] fun x => x :=\n  let ⟨_, _, hM⟩ := h.bound\n  IsBigO.of_bound _ (mem_of_superset univ_mem fun x _ => hM x)\n\n"}
{"name":"IsBoundedLinearMap.isBigO_comp","module":"Mathlib.Analysis.Normed.Operator.BoundedLinearMaps","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nF : Type u_3\ninst✝³ : SeminormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type u_4\ninst✝¹ : SeminormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nE : Type u_5\ng : F → G\nhg : IsBoundedLinearMap 𝕜 g\nf : E → F\nl : Filter E\n⊢ Asymptotics.IsBigO l (fun x' => g (f x')) f","decl":"theorem isBigO_comp {E : Type*} {g : F → G} (hg : IsBoundedLinearMap 𝕜 g) {f : E → F}\n    (l : Filter E) : (fun x' => g (f x')) =O[l] f :=\n  (hg.isBigO_id ⊤).comp_tendsto le_top\n\n"}
{"name":"IsBoundedLinearMap.isBigO_sub","module":"Mathlib.Analysis.Normed.Operator.BoundedLinearMaps","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : SeminormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : SeminormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nh : IsBoundedLinearMap 𝕜 f\nl : Filter E\nx : E\n⊢ Asymptotics.IsBigO l (fun x' => f (HSub.hSub x' x)) fun x' => HSub.hSub x' x","decl":"theorem isBigO_sub {f : E → F} (h : IsBoundedLinearMap 𝕜 f) (l : Filter E) (x : E) :\n    (fun x' => f (x' - x)) =O[l] fun x' => x' - x :=\n  isBigO_comp h l\n\n"}
{"name":"isBoundedLinearMap_prod_multilinear","module":"Mathlib.Analysis.Normed.Operator.BoundedLinearMaps","initialProofState":"𝕜 : Type u_1\ninst✝⁷ : NontriviallyNormedField 𝕜\nF : Type u_3\ninst✝⁶ : SeminormedAddCommGroup F\ninst✝⁵ : NormedSpace 𝕜 F\nG : Type u_4\ninst✝⁴ : SeminormedAddCommGroup G\ninst✝³ : NormedSpace 𝕜 G\nι : Type u_5\ninst✝² : Fintype ι\nE : ι → Type u_6\ninst✝¹ : (i : ι) → SeminormedAddCommGroup (E i)\ninst✝ : (i : ι) → NormedSpace 𝕜 (E i)\n⊢ IsBoundedLinearMap 𝕜 fun p => p.1.prod p.2","decl":"/-- Taking the cartesian product of two continuous multilinear maps is a bounded linear\noperation. -/\ntheorem isBoundedLinearMap_prod_multilinear {E : ι → Type*} [∀ i, SeminormedAddCommGroup (E i)]\n    [∀ i, NormedSpace 𝕜 (E i)] :\n    IsBoundedLinearMap 𝕜 fun p : ContinuousMultilinearMap 𝕜 E F × ContinuousMultilinearMap 𝕜 E G =>\n      p.1.prod p.2 :=\n  (ContinuousMultilinearMap.prodL 𝕜 E F G).toContinuousLinearEquiv\n    |>.toContinuousLinearMap.isBoundedLinearMap\n\n"}
{"name":"isBoundedLinearMap_continuousMultilinearMap_comp_linear","module":"Mathlib.Analysis.Normed.Operator.BoundedLinearMaps","initialProofState":"𝕜 : Type u_1\ninst✝⁷ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁶ : SeminormedAddCommGroup E\ninst✝⁵ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝⁴ : SeminormedAddCommGroup F\ninst✝³ : NormedSpace 𝕜 F\nG : Type u_4\ninst✝² : SeminormedAddCommGroup G\ninst✝¹ : NormedSpace 𝕜 G\nι : Type u_5\ninst✝ : Fintype ι\ng : ContinuousLinearMap (RingHom.id 𝕜) G E\n⊢ IsBoundedLinearMap 𝕜 fun f => f.compContinuousLinearMap fun x => g","decl":"/-- Given a fixed continuous linear map `g`, associating to a continuous multilinear map `f` the\ncontinuous multilinear map `f (g m₁, ..., g mₙ)` is a bounded linear operation. -/\ntheorem isBoundedLinearMap_continuousMultilinearMap_comp_linear (g : G →L[𝕜] E) :\n    IsBoundedLinearMap 𝕜 fun f : ContinuousMultilinearMap 𝕜 (fun _ : ι => E) F =>\n      f.compContinuousLinearMap fun _ => g :=\n  (ContinuousMultilinearMap.compContinuousLinearMapL (ι := ι) (G := F) (fun _ ↦ g))\n    |>.isBoundedLinearMap\n\n"}
{"name":"ContinuousLinearMap.map_add₂","module":"Mathlib.Analysis.Normed.Operator.BoundedLinearMaps","initialProofState":"𝕜 : Type u_1\ninst✝¹² : NontriviallyNormedField 𝕜\nF : Type u_3\ninst✝¹¹ : SeminormedAddCommGroup F\ninst✝¹⁰ : NormedSpace 𝕜 F\nR : Type u_5\n𝕜₂ : Type u_6\n𝕜' : Type u_7\ninst✝⁹ : NontriviallyNormedField 𝕜'\ninst✝⁸ : NontriviallyNormedField 𝕜₂\nM : Type u_8\ninst✝⁷ : TopologicalSpace M\nσ₁₂ : RingHom 𝕜 𝕜₂\nG' : Type u_9\ninst✝⁶ : SeminormedAddCommGroup G'\ninst✝⁵ : NormedSpace 𝕜₂ G'\ninst✝⁴ : NormedSpace 𝕜' G'\ninst✝³ : SMulCommClass 𝕜₂ 𝕜' G'\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nρ₁₂ : RingHom R 𝕜'\nf : ContinuousLinearMap ρ₁₂ M (ContinuousLinearMap σ₁₂ F G')\nx x' : M\ny : F\n⊢ Eq ((f (HAdd.hAdd x x')) y) (HAdd.hAdd ((f x) y) ((f x') y))","decl":"theorem map_add₂ (f : M →SL[ρ₁₂] F →SL[σ₁₂] G') (x x' : M) (y : F) :\n    f (x + x') y = f x y + f x' y := by rw [f.map_add, add_apply]\n\n"}
{"name":"ContinuousLinearMap.map_zero₂","module":"Mathlib.Analysis.Normed.Operator.BoundedLinearMaps","initialProofState":"𝕜 : Type u_1\ninst✝¹² : NontriviallyNormedField 𝕜\nF : Type u_3\ninst✝¹¹ : SeminormedAddCommGroup F\ninst✝¹⁰ : NormedSpace 𝕜 F\nR : Type u_5\n𝕜₂ : Type u_6\n𝕜' : Type u_7\ninst✝⁹ : NontriviallyNormedField 𝕜'\ninst✝⁸ : NontriviallyNormedField 𝕜₂\nM : Type u_8\ninst✝⁷ : TopologicalSpace M\nσ₁₂ : RingHom 𝕜 𝕜₂\nG' : Type u_9\ninst✝⁶ : SeminormedAddCommGroup G'\ninst✝⁵ : NormedSpace 𝕜₂ G'\ninst✝⁴ : NormedSpace 𝕜' G'\ninst✝³ : SMulCommClass 𝕜₂ 𝕜' G'\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nρ₁₂ : RingHom R 𝕜'\nf : ContinuousLinearMap ρ₁₂ M (ContinuousLinearMap σ₁₂ F G')\ny : F\n⊢ Eq ((f 0) y) 0","decl":"theorem map_zero₂ (f : M →SL[ρ₁₂] F →SL[σ₁₂] G') (y : F) : f 0 y = 0 := by\n  rw [f.map_zero, zero_apply]\n\n"}
{"name":"ContinuousLinearMap.map_smulₛₗ₂","module":"Mathlib.Analysis.Normed.Operator.BoundedLinearMaps","initialProofState":"𝕜 : Type u_1\ninst✝¹² : NontriviallyNormedField 𝕜\nF : Type u_3\ninst✝¹¹ : SeminormedAddCommGroup F\ninst✝¹⁰ : NormedSpace 𝕜 F\nR : Type u_5\n𝕜₂ : Type u_6\n𝕜' : Type u_7\ninst✝⁹ : NontriviallyNormedField 𝕜'\ninst✝⁸ : NontriviallyNormedField 𝕜₂\nM : Type u_8\ninst✝⁷ : TopologicalSpace M\nσ₁₂ : RingHom 𝕜 𝕜₂\nG' : Type u_9\ninst✝⁶ : SeminormedAddCommGroup G'\ninst✝⁵ : NormedSpace 𝕜₂ G'\ninst✝⁴ : NormedSpace 𝕜' G'\ninst✝³ : SMulCommClass 𝕜₂ 𝕜' G'\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nρ₁₂ : RingHom R 𝕜'\nf : ContinuousLinearMap ρ₁₂ M (ContinuousLinearMap σ₁₂ F G')\nc : R\nx : M\ny : F\n⊢ Eq ((f (HSMul.hSMul c x)) y) (HSMul.hSMul (ρ₁₂ c) ((f x) y))","decl":"theorem map_smulₛₗ₂ (f : M →SL[ρ₁₂] F →SL[σ₁₂] G') (c : R) (x : M) (y : F) :\n    f (c • x) y = ρ₁₂ c • f x y := by rw [f.map_smulₛₗ, smul_apply]\n\n"}
{"name":"ContinuousLinearMap.map_sub₂","module":"Mathlib.Analysis.Normed.Operator.BoundedLinearMaps","initialProofState":"𝕜 : Type u_1\ninst✝¹² : NontriviallyNormedField 𝕜\nF : Type u_3\ninst✝¹¹ : SeminormedAddCommGroup F\ninst✝¹⁰ : NormedSpace 𝕜 F\nR : Type u_5\n𝕜₂ : Type u_6\n𝕜' : Type u_7\ninst✝⁹ : NontriviallyNormedField 𝕜'\ninst✝⁸ : NontriviallyNormedField 𝕜₂\nM : Type u_8\ninst✝⁷ : TopologicalSpace M\nσ₁₂ : RingHom 𝕜 𝕜₂\nG' : Type u_9\ninst✝⁶ : SeminormedAddCommGroup G'\ninst✝⁵ : NormedSpace 𝕜₂ G'\ninst✝⁴ : NormedSpace 𝕜' G'\ninst✝³ : SMulCommClass 𝕜₂ 𝕜' G'\ninst✝² : Ring R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nρ₁₂ : RingHom R 𝕜'\nf : ContinuousLinearMap ρ₁₂ M (ContinuousLinearMap σ₁₂ F G')\nx x' : M\ny : F\n⊢ Eq ((f (HSub.hSub x x')) y) (HSub.hSub ((f x) y) ((f x') y))","decl":"theorem map_sub₂ (f : M →SL[ρ₁₂] F →SL[σ₁₂] G') (x x' : M) (y : F) :\n    f (x - x') y = f x y - f x' y := by rw [f.map_sub, sub_apply]\n\n"}
{"name":"ContinuousLinearMap.map_neg₂","module":"Mathlib.Analysis.Normed.Operator.BoundedLinearMaps","initialProofState":"𝕜 : Type u_1\ninst✝¹² : NontriviallyNormedField 𝕜\nF : Type u_3\ninst✝¹¹ : SeminormedAddCommGroup F\ninst✝¹⁰ : NormedSpace 𝕜 F\nR : Type u_5\n𝕜₂ : Type u_6\n𝕜' : Type u_7\ninst✝⁹ : NontriviallyNormedField 𝕜'\ninst✝⁸ : NontriviallyNormedField 𝕜₂\nM : Type u_8\ninst✝⁷ : TopologicalSpace M\nσ₁₂ : RingHom 𝕜 𝕜₂\nG' : Type u_9\ninst✝⁶ : SeminormedAddCommGroup G'\ninst✝⁵ : NormedSpace 𝕜₂ G'\ninst✝⁴ : NormedSpace 𝕜' G'\ninst✝³ : SMulCommClass 𝕜₂ 𝕜' G'\ninst✝² : Ring R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nρ₁₂ : RingHom R 𝕜'\nf : ContinuousLinearMap ρ₁₂ M (ContinuousLinearMap σ₁₂ F G')\nx : M\ny : F\n⊢ Eq ((f (Neg.neg x)) y) (Neg.neg ((f x) y))","decl":"theorem map_neg₂ (f : M →SL[ρ₁₂] F →SL[σ₁₂] G') (x : M) (y : F) : f (-x) y = -f x y := by\n  rw [f.map_neg, neg_apply]\n\n"}
{"name":"ContinuousLinearMap.map_smul₂","module":"Mathlib.Analysis.Normed.Operator.BoundedLinearMaps","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁵ : SeminormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝³ : SeminormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type u_4\ninst✝¹ : SeminormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nf : ContinuousLinearMap (RingHom.id 𝕜) E (ContinuousLinearMap (RingHom.id 𝕜) F G)\nc : 𝕜\nx : E\ny : F\n⊢ Eq ((f (HSMul.hSMul c x)) y) (HSMul.hSMul c ((f x) y))","decl":"theorem map_smul₂ (f : E →L[𝕜] F →L[𝕜] G) (c : 𝕜) (x : E) (y : F) : f (c • x) y = c • f x y := by\n  rw [f.map_smul, smul_apply]\n\n"}
{"name":"IsBoundedBilinearMap.bound","module":"Mathlib.Analysis.Normed.Operator.BoundedLinearMaps","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁵ : SeminormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝³ : SeminormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type u_4\ninst✝¹ : SeminormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nf : Prod E F → G\nself : IsBoundedBilinearMap 𝕜 f\n⊢ Exists fun C => And (GT.gt C 0) (∀ (x : E) (y : F), LE.le (Norm.norm (f { fst := x, snd := y })) (HMul.hMul (HMul.hMul C (Norm.norm x)) (Norm.norm y)))","decl":"/-- A map `f : E × F → G` satisfies `IsBoundedBilinearMap 𝕜 f` if it is bilinear and\ncontinuous. -/\nstructure IsBoundedBilinearMap (f : E × F → G) : Prop where\n  add_left : ∀ (x₁ x₂ : E) (y : F), f (x₁ + x₂, y) = f (x₁, y) + f (x₂, y)\n  smul_left : ∀ (c : 𝕜) (x : E) (y : F), f (c • x, y) = c • f (x, y)\n  add_right : ∀ (x : E) (y₁ y₂ : F), f (x, y₁ + y₂) = f (x, y₁) + f (x, y₂)\n  smul_right : ∀ (c : 𝕜) (x : E) (y : F), f (x, c • y) = c • f (x, y)\n  bound : ∃ C > 0, ∀ (x : E) (y : F), ‖f (x, y)‖ ≤ C * ‖x‖ * ‖y‖\n\n"}
{"name":"IsBoundedBilinearMap.smul_right","module":"Mathlib.Analysis.Normed.Operator.BoundedLinearMaps","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁵ : SeminormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝³ : SeminormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type u_4\ninst✝¹ : SeminormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nf : Prod E F → G\nself : IsBoundedBilinearMap 𝕜 f\nc : 𝕜\nx : E\ny : F\n⊢ Eq (f { fst := x, snd := HSMul.hSMul c y }) (HSMul.hSMul c (f { fst := x, snd := y }))","decl":"/-- A map `f : E × F → G` satisfies `IsBoundedBilinearMap 𝕜 f` if it is bilinear and\ncontinuous. -/\nstructure IsBoundedBilinearMap (f : E × F → G) : Prop where\n  add_left : ∀ (x₁ x₂ : E) (y : F), f (x₁ + x₂, y) = f (x₁, y) + f (x₂, y)\n  smul_left : ∀ (c : 𝕜) (x : E) (y : F), f (c • x, y) = c • f (x, y)\n  add_right : ∀ (x : E) (y₁ y₂ : F), f (x, y₁ + y₂) = f (x, y₁) + f (x, y₂)\n  smul_right : ∀ (c : 𝕜) (x : E) (y : F), f (x, c • y) = c • f (x, y)\n  bound : ∃ C > 0, ∀ (x : E) (y : F), ‖f (x, y)‖ ≤ C * ‖x‖ * ‖y‖\n\n"}
{"name":"IsBoundedBilinearMap.add_left","module":"Mathlib.Analysis.Normed.Operator.BoundedLinearMaps","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁵ : SeminormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝³ : SeminormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type u_4\ninst✝¹ : SeminormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nf : Prod E F → G\nself : IsBoundedBilinearMap 𝕜 f\nx₁ x₂ : E\ny : F\n⊢ Eq (f { fst := HAdd.hAdd x₁ x₂, snd := y }) (HAdd.hAdd (f { fst := x₁, snd := y }) (f { fst := x₂, snd := y }))","decl":"/-- A map `f : E × F → G` satisfies `IsBoundedBilinearMap 𝕜 f` if it is bilinear and\ncontinuous. -/\nstructure IsBoundedBilinearMap (f : E × F → G) : Prop where\n  add_left : ∀ (x₁ x₂ : E) (y : F), f (x₁ + x₂, y) = f (x₁, y) + f (x₂, y)\n  smul_left : ∀ (c : 𝕜) (x : E) (y : F), f (c • x, y) = c • f (x, y)\n  add_right : ∀ (x : E) (y₁ y₂ : F), f (x, y₁ + y₂) = f (x, y₁) + f (x, y₂)\n  smul_right : ∀ (c : 𝕜) (x : E) (y : F), f (x, c • y) = c • f (x, y)\n  bound : ∃ C > 0, ∀ (x : E) (y : F), ‖f (x, y)‖ ≤ C * ‖x‖ * ‖y‖\n\n"}
{"name":"IsBoundedBilinearMap.smul_left","module":"Mathlib.Analysis.Normed.Operator.BoundedLinearMaps","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁵ : SeminormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝³ : SeminormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type u_4\ninst✝¹ : SeminormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nf : Prod E F → G\nself : IsBoundedBilinearMap 𝕜 f\nc : 𝕜\nx : E\ny : F\n⊢ Eq (f { fst := HSMul.hSMul c x, snd := y }) (HSMul.hSMul c (f { fst := x, snd := y }))","decl":"/-- A map `f : E × F → G` satisfies `IsBoundedBilinearMap 𝕜 f` if it is bilinear and\ncontinuous. -/\nstructure IsBoundedBilinearMap (f : E × F → G) : Prop where\n  add_left : ∀ (x₁ x₂ : E) (y : F), f (x₁ + x₂, y) = f (x₁, y) + f (x₂, y)\n  smul_left : ∀ (c : 𝕜) (x : E) (y : F), f (c • x, y) = c • f (x, y)\n  add_right : ∀ (x : E) (y₁ y₂ : F), f (x, y₁ + y₂) = f (x, y₁) + f (x, y₂)\n  smul_right : ∀ (c : 𝕜) (x : E) (y : F), f (x, c • y) = c • f (x, y)\n  bound : ∃ C > 0, ∀ (x : E) (y : F), ‖f (x, y)‖ ≤ C * ‖x‖ * ‖y‖\n\n"}
{"name":"IsBoundedBilinearMap.add_right","module":"Mathlib.Analysis.Normed.Operator.BoundedLinearMaps","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁵ : SeminormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝³ : SeminormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type u_4\ninst✝¹ : SeminormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nf : Prod E F → G\nself : IsBoundedBilinearMap 𝕜 f\nx : E\ny₁ y₂ : F\n⊢ Eq (f { fst := x, snd := HAdd.hAdd y₁ y₂ }) (HAdd.hAdd (f { fst := x, snd := y₁ }) (f { fst := x, snd := y₂ }))","decl":"/-- A map `f : E × F → G` satisfies `IsBoundedBilinearMap 𝕜 f` if it is bilinear and\ncontinuous. -/\nstructure IsBoundedBilinearMap (f : E × F → G) : Prop where\n  add_left : ∀ (x₁ x₂ : E) (y : F), f (x₁ + x₂, y) = f (x₁, y) + f (x₂, y)\n  smul_left : ∀ (c : 𝕜) (x : E) (y : F), f (c • x, y) = c • f (x, y)\n  add_right : ∀ (x : E) (y₁ y₂ : F), f (x, y₁ + y₂) = f (x, y₁) + f (x, y₂)\n  smul_right : ∀ (c : 𝕜) (x : E) (y : F), f (x, c • y) = c • f (x, y)\n  bound : ∃ C > 0, ∀ (x : E) (y : F), ‖f (x, y)‖ ≤ C * ‖x‖ * ‖y‖\n\n"}
{"name":"ContinuousLinearMap.isBoundedBilinearMap","module":"Mathlib.Analysis.Normed.Operator.BoundedLinearMaps","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁵ : SeminormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝³ : SeminormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type u_4\ninst✝¹ : SeminormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nf : ContinuousLinearMap (RingHom.id 𝕜) E (ContinuousLinearMap (RingHom.id 𝕜) F G)\n⊢ IsBoundedBilinearMap 𝕜 fun x => (f x.1) x.2","decl":"theorem ContinuousLinearMap.isBoundedBilinearMap (f : E →L[𝕜] F →L[𝕜] G) :\n    IsBoundedBilinearMap 𝕜 fun x : E × F => f x.1 x.2 :=\n  { add_left := f.map_add₂\n    smul_left := f.map_smul₂\n    add_right := fun x => (f x).map_add\n    smul_right := fun c x => (f x).map_smul c\n    bound :=\n      ⟨max ‖f‖ 1, zero_lt_one.trans_le (le_max_right _ _), fun x y =>\n        (f.le_opNorm₂ x y).trans <| by\n          apply_rules [mul_le_mul_of_nonneg_right, norm_nonneg, le_max_left] ⟩ }\n\n-- Porting note (https://github.com/leanprover-community/mathlib4/issues/11445): new definition\n"}
{"name":"IsBoundedBilinearMap.isBigO","module":"Mathlib.Analysis.Normed.Operator.BoundedLinearMaps","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁵ : SeminormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝³ : SeminormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type u_4\ninst✝¹ : SeminormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nf : Prod E F → G\nh : IsBoundedBilinearMap 𝕜 f\n⊢ Asymptotics.IsBigO Top.top f fun p => HMul.hMul (Norm.norm p.1) (Norm.norm p.2)","decl":"protected theorem IsBoundedBilinearMap.isBigO (h : IsBoundedBilinearMap 𝕜 f) :\n    f =O[⊤] fun p : E × F => ‖p.1‖ * ‖p.2‖ :=\n  let ⟨C, _, hC⟩ := h.bound\n  Asymptotics.IsBigO.of_bound C <|\n    Filter.Eventually.of_forall fun ⟨x, y⟩ => by simpa [mul_assoc] using hC x y\n\n"}
{"name":"IsBoundedBilinearMap.isBigO_comp","module":"Mathlib.Analysis.Normed.Operator.BoundedLinearMaps","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁵ : SeminormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝³ : SeminormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type u_4\ninst✝¹ : SeminormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nf : Prod E F → G\nα : Type u_5\nH : IsBoundedBilinearMap 𝕜 f\ng : α → E\nh : α → F\nl : Filter α\n⊢ Asymptotics.IsBigO l (fun x => f { fst := g x, snd := h x }) fun x => HMul.hMul (Norm.norm (g x)) (Norm.norm (h x))","decl":"theorem IsBoundedBilinearMap.isBigO_comp {α : Type*} (H : IsBoundedBilinearMap 𝕜 f) {g : α → E}\n    {h : α → F} {l : Filter α} : (fun x => f (g x, h x)) =O[l] fun x => ‖g x‖ * ‖h x‖ :=\n  H.isBigO.comp_tendsto le_top\n\n"}
{"name":"IsBoundedBilinearMap.isBigO'","module":"Mathlib.Analysis.Normed.Operator.BoundedLinearMaps","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁵ : SeminormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝³ : SeminormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type u_4\ninst✝¹ : SeminormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nf : Prod E F → G\nh : IsBoundedBilinearMap 𝕜 f\n⊢ Asymptotics.IsBigO Top.top f fun p => HMul.hMul (Norm.norm p) (Norm.norm p)","decl":"protected theorem IsBoundedBilinearMap.isBigO' (h : IsBoundedBilinearMap 𝕜 f) :\n    f =O[⊤] fun p : E × F => ‖p‖ * ‖p‖ :=\n  h.isBigO.trans <|\n    (@Asymptotics.isBigO_fst_prod' _ E F _ _ _ _).norm_norm.mul\n      (@Asymptotics.isBigO_snd_prod' _ E F _ _ _ _).norm_norm\n\n"}
{"name":"IsBoundedBilinearMap.map_sub_left","module":"Mathlib.Analysis.Normed.Operator.BoundedLinearMaps","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁵ : SeminormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝³ : SeminormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type u_4\ninst✝¹ : SeminormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nf : Prod E F → G\nh : IsBoundedBilinearMap 𝕜 f\nx y : E\nz : F\n⊢ Eq (f { fst := HSub.hSub x y, snd := z }) (HSub.hSub (f { fst := x, snd := z }) (f { fst := y, snd := z }))","decl":"theorem IsBoundedBilinearMap.map_sub_left (h : IsBoundedBilinearMap 𝕜 f) {x y : E} {z : F} :\n    f (x - y, z) = f (x, z) - f (y, z) :=\n  (h.toContinuousLinearMap.flip z).map_sub x y\n\n"}
{"name":"IsBoundedBilinearMap.map_sub_right","module":"Mathlib.Analysis.Normed.Operator.BoundedLinearMaps","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁵ : SeminormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝³ : SeminormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type u_4\ninst✝¹ : SeminormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nf : Prod E F → G\nh : IsBoundedBilinearMap 𝕜 f\nx : E\ny z : F\n⊢ Eq (f { fst := x, snd := HSub.hSub y z }) (HSub.hSub (f { fst := x, snd := y }) (f { fst := x, snd := z }))","decl":"theorem IsBoundedBilinearMap.map_sub_right (h : IsBoundedBilinearMap 𝕜 f) {x : E} {y z : F} :\n    f (x, y - z) = f (x, y) - f (x, z) :=\n  (h.toContinuousLinearMap x).map_sub y z\n\n"}
{"name":"IsBoundedBilinearMap.continuous","module":"Mathlib.Analysis.Normed.Operator.BoundedLinearMaps","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁵ : SeminormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝³ : SeminormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type u_4\ninst✝¹ : SeminormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nf : Prod E F → G\nh : IsBoundedBilinearMap 𝕜 f\n⊢ Continuous f","decl":"open Asymptotics in\n/-- Useful to use together with `Continuous.comp₂`. -/\ntheorem IsBoundedBilinearMap.continuous (h : IsBoundedBilinearMap 𝕜 f) : Continuous f := by\n  refine continuous_iff_continuousAt.2 fun x ↦ tendsto_sub_nhds_zero_iff.1 ?_\n  suffices Tendsto (fun y : E × F ↦ f (y.1 - x.1, y.2) + f (x.1, y.2 - x.2)) (𝓝 x) (𝓝 (0 + 0)) by\n    simpa only [h.map_sub_left, h.map_sub_right, sub_add_sub_cancel, zero_add] using this\n  apply Tendsto.add\n  · rw [← isLittleO_one_iff ℝ, ← one_mul 1]\n    refine h.isBigO_comp.trans_isLittleO ?_\n    refine (IsLittleO.norm_left ?_).mul_isBigO (IsBigO.norm_left ?_)\n    · exact (isLittleO_one_iff _).2 (tendsto_sub_nhds_zero_iff.2 (continuous_fst.tendsto _))\n    · exact (continuous_snd.tendsto _).isBigO_one ℝ\n  · refine Continuous.tendsto' ?_ _ _ (by rw [h.map_sub_right, sub_self])\n    exact ((h.toContinuousLinearMap x.1).continuous).comp (continuous_snd.sub continuous_const)\n\n"}
{"name":"IsBoundedBilinearMap.continuous_left","module":"Mathlib.Analysis.Normed.Operator.BoundedLinearMaps","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁵ : SeminormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝³ : SeminormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type u_4\ninst✝¹ : SeminormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nf : Prod E F → G\nh : IsBoundedBilinearMap 𝕜 f\ne₂ : F\n⊢ Continuous fun e₁ => f { fst := e₁, snd := e₂ }","decl":"theorem IsBoundedBilinearMap.continuous_left (h : IsBoundedBilinearMap 𝕜 f) {e₂ : F} :\n    Continuous fun e₁ => f (e₁, e₂) :=\n  h.continuous.comp (continuous_id.prod_mk continuous_const)\n\n"}
{"name":"IsBoundedBilinearMap.continuous_right","module":"Mathlib.Analysis.Normed.Operator.BoundedLinearMaps","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁵ : SeminormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝³ : SeminormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type u_4\ninst✝¹ : SeminormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nf : Prod E F → G\nh : IsBoundedBilinearMap 𝕜 f\ne₁ : E\n⊢ Continuous fun e₂ => f { fst := e₁, snd := e₂ }","decl":"theorem IsBoundedBilinearMap.continuous_right (h : IsBoundedBilinearMap 𝕜 f) {e₁ : E} :\n    Continuous fun e₂ => f (e₁, e₂) :=\n  h.continuous.comp (continuous_const.prod_mk continuous_id)\n\n"}
{"name":"ContinuousLinearMap.continuous₂","module":"Mathlib.Analysis.Normed.Operator.BoundedLinearMaps","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁵ : SeminormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝³ : SeminormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type u_4\ninst✝¹ : SeminormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nf : ContinuousLinearMap (RingHom.id 𝕜) E (ContinuousLinearMap (RingHom.id 𝕜) F G)\n⊢ Continuous (Function.uncurry fun x y => (f x) y)","decl":"/-- Useful to use together with `Continuous.comp₂`. -/\ntheorem ContinuousLinearMap.continuous₂ (f : E →L[𝕜] F →L[𝕜] G) :\n    Continuous (Function.uncurry fun x y => f x y) :=\n  f.isBoundedBilinearMap.continuous\n\n"}
{"name":"IsBoundedBilinearMap.isBoundedLinearMap_left","module":"Mathlib.Analysis.Normed.Operator.BoundedLinearMaps","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁵ : SeminormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝³ : SeminormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type u_4\ninst✝¹ : SeminormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nf : Prod E F → G\nh : IsBoundedBilinearMap 𝕜 f\ny : F\n⊢ IsBoundedLinearMap 𝕜 fun x => f { fst := x, snd := y }","decl":"theorem IsBoundedBilinearMap.isBoundedLinearMap_left (h : IsBoundedBilinearMap 𝕜 f) (y : F) :\n    IsBoundedLinearMap 𝕜 fun x => f (x, y) :=\n  (h.toContinuousLinearMap.flip y).isBoundedLinearMap\n\n"}
{"name":"IsBoundedBilinearMap.isBoundedLinearMap_right","module":"Mathlib.Analysis.Normed.Operator.BoundedLinearMaps","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁵ : SeminormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝³ : SeminormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type u_4\ninst✝¹ : SeminormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nf : Prod E F → G\nh : IsBoundedBilinearMap 𝕜 f\nx : E\n⊢ IsBoundedLinearMap 𝕜 fun y => f { fst := x, snd := y }","decl":"theorem IsBoundedBilinearMap.isBoundedLinearMap_right (h : IsBoundedBilinearMap 𝕜 f) (x : E) :\n    IsBoundedLinearMap 𝕜 fun y => f (x, y) :=\n  (h.toContinuousLinearMap x).isBoundedLinearMap\n\n"}
{"name":"isBoundedBilinearMap_smul","module":"Mathlib.Analysis.Normed.Operator.BoundedLinearMaps","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\n𝕜' : Type u_5\ninst✝⁵ : NormedField 𝕜'\ninst✝⁴ : NormedAlgebra 𝕜 𝕜'\nE : Type u_6\ninst✝³ : SeminormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedSpace 𝕜' E\ninst✝ : IsScalarTower 𝕜 𝕜' E\n⊢ IsBoundedBilinearMap 𝕜 fun p => HSMul.hSMul p.1 p.2","decl":"theorem isBoundedBilinearMap_smul {𝕜' : Type*} [NormedField 𝕜'] [NormedAlgebra 𝕜 𝕜'] {E : Type*}\n    [SeminormedAddCommGroup E] [NormedSpace 𝕜 E] [NormedSpace 𝕜' E] [IsScalarTower 𝕜 𝕜' E] :\n    IsBoundedBilinearMap 𝕜 fun p : 𝕜' × E => p.1 • p.2 :=\n  (lsmul 𝕜 𝕜' : 𝕜' →L[𝕜] E →L[𝕜] E).isBoundedBilinearMap\n\n"}
{"name":"isBoundedBilinearMap_mul","module":"Mathlib.Analysis.Normed.Operator.BoundedLinearMaps","initialProofState":"𝕜 : Type u_1\ninst✝ : NontriviallyNormedField 𝕜\n⊢ IsBoundedBilinearMap 𝕜 fun p => HMul.hMul p.1 p.2","decl":"theorem isBoundedBilinearMap_mul : IsBoundedBilinearMap 𝕜 fun p : 𝕜 × 𝕜 => p.1 * p.2 := by\n  simp_rw [← smul_eq_mul]\n  exact isBoundedBilinearMap_smul\n\n"}
{"name":"isBoundedBilinearMap_comp","module":"Mathlib.Analysis.Normed.Operator.BoundedLinearMaps","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁵ : SeminormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝³ : SeminormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type u_4\ninst✝¹ : SeminormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\n⊢ IsBoundedBilinearMap 𝕜 fun p => p.1.comp p.2","decl":"theorem isBoundedBilinearMap_comp :\n    IsBoundedBilinearMap 𝕜 fun p : (F →L[𝕜] G) × (E →L[𝕜] F) => p.1.comp p.2 :=\n  (compL 𝕜 E F G).isBoundedBilinearMap\n\n"}
{"name":"ContinuousLinearMap.isBoundedLinearMap_comp_left","module":"Mathlib.Analysis.Normed.Operator.BoundedLinearMaps","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁵ : SeminormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝³ : SeminormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type u_4\ninst✝¹ : SeminormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\ng : ContinuousLinearMap (RingHom.id 𝕜) F G\n⊢ IsBoundedLinearMap 𝕜 fun f => g.comp f","decl":"theorem ContinuousLinearMap.isBoundedLinearMap_comp_left (g : F →L[𝕜] G) :\n    IsBoundedLinearMap 𝕜 fun f : E →L[𝕜] F => ContinuousLinearMap.comp g f :=\n  isBoundedBilinearMap_comp.isBoundedLinearMap_right _\n\n"}
{"name":"ContinuousLinearMap.isBoundedLinearMap_comp_right","module":"Mathlib.Analysis.Normed.Operator.BoundedLinearMaps","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁵ : SeminormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝³ : SeminormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type u_4\ninst✝¹ : SeminormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nf : ContinuousLinearMap (RingHom.id 𝕜) E F\n⊢ IsBoundedLinearMap 𝕜 fun g => g.comp f","decl":"theorem ContinuousLinearMap.isBoundedLinearMap_comp_right (f : E →L[𝕜] F) :\n    IsBoundedLinearMap 𝕜 fun g : F →L[𝕜] G => ContinuousLinearMap.comp g f :=\n  isBoundedBilinearMap_comp.isBoundedLinearMap_left _\n\n"}
{"name":"isBoundedBilinearMap_apply","module":"Mathlib.Analysis.Normed.Operator.BoundedLinearMaps","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : SeminormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : SeminormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\n⊢ IsBoundedBilinearMap 𝕜 fun p => p.1 p.2","decl":"theorem isBoundedBilinearMap_apply : IsBoundedBilinearMap 𝕜 fun p : (E →L[𝕜] F) × E => p.1 p.2 :=\n  (ContinuousLinearMap.flip (apply 𝕜 F : E →L[𝕜] (E →L[𝕜] F) →L[𝕜] F)).isBoundedBilinearMap\n\n"}
{"name":"isBoundedBilinearMap_smulRight","module":"Mathlib.Analysis.Normed.Operator.BoundedLinearMaps","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : SeminormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : SeminormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\n⊢ IsBoundedBilinearMap 𝕜 fun p => p.1.smulRight p.2","decl":"/-- The function `ContinuousLinearMap.smulRight`, associating to a continuous linear map\n`f : E → 𝕜` and a scalar `c : F` the tensor product `f ⊗ c` as a continuous linear map from `E` to\n`F`, is a bounded bilinear map. -/\ntheorem isBoundedBilinearMap_smulRight :\n    IsBoundedBilinearMap 𝕜 fun p =>\n      (ContinuousLinearMap.smulRight : (E →L[𝕜] 𝕜) → F → E →L[𝕜] F) p.1 p.2 :=\n  (smulRightL 𝕜 E F).isBoundedBilinearMap\n\n"}
{"name":"isBoundedBilinearMap_compMultilinear","module":"Mathlib.Analysis.Normed.Operator.BoundedLinearMaps","initialProofState":"𝕜 : Type u_1\ninst✝⁷ : NontriviallyNormedField 𝕜\nF : Type u_3\ninst✝⁶ : SeminormedAddCommGroup F\ninst✝⁵ : NormedSpace 𝕜 F\nG : Type u_4\ninst✝⁴ : SeminormedAddCommGroup G\ninst✝³ : NormedSpace 𝕜 G\nι : Type u_5\nE : ι → Type u_6\ninst✝² : Fintype ι\ninst✝¹ : (i : ι) → NormedAddCommGroup (E i)\ninst✝ : (i : ι) → NormedSpace 𝕜 (E i)\n⊢ IsBoundedBilinearMap 𝕜 fun p => p.1.compContinuousMultilinearMap p.2","decl":"/-- The composition of a continuous linear map with a continuous multilinear map is a bounded\nbilinear operation. -/\ntheorem isBoundedBilinearMap_compMultilinear {ι : Type*} {E : ι → Type*} [Fintype ι]\n    [∀ i, NormedAddCommGroup (E i)] [∀ i, NormedSpace 𝕜 (E i)] :\n    IsBoundedBilinearMap 𝕜 fun p : (F →L[𝕜] G) × ContinuousMultilinearMap 𝕜 E F =>\n      p.1.compContinuousMultilinearMap p.2 :=\n  (compContinuousMultilinearMapL 𝕜 E F G).isBoundedBilinearMap\n\n"}
{"name":"IsBoundedBilinearMap.deriv_apply","module":"Mathlib.Analysis.Normed.Operator.BoundedLinearMaps","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁵ : SeminormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝³ : SeminormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type u_4\ninst✝¹ : SeminormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nf : Prod E F → G\nh : IsBoundedBilinearMap 𝕜 f\np q : Prod E F\n⊢ Eq ((h.deriv p) q) (HAdd.hAdd (f { fst := p.1, snd := q.2 }) (f { fst := q.1, snd := p.2 }))","decl":"@[simp]\ntheorem IsBoundedBilinearMap.deriv_apply (h : IsBoundedBilinearMap 𝕜 f) (p q : E × F) :\n    h.deriv p q = f (p.1, q.2) + f (q.1, p.2) :=\n  rfl\n\n"}
{"name":"ContinuousLinearMap.mulLeftRight_isBoundedBilinear","module":"Mathlib.Analysis.Normed.Operator.BoundedLinearMaps","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\n𝕜' : Type u_5\ninst✝¹ : SeminormedRing 𝕜'\ninst✝ : NormedAlgebra 𝕜 𝕜'\n⊢ IsBoundedBilinearMap 𝕜 fun p => ((ContinuousLinearMap.mulLeftRight 𝕜 𝕜') p.1) p.2","decl":"/-- The function `ContinuousLinearMap.mulLeftRight : 𝕜' × 𝕜' → (𝕜' →L[𝕜] 𝕜')` is a bounded\nbilinear map. -/\ntheorem ContinuousLinearMap.mulLeftRight_isBoundedBilinear (𝕜' : Type*) [SeminormedRing 𝕜']\n    [NormedAlgebra 𝕜 𝕜'] :\n    IsBoundedBilinearMap 𝕜 fun p : 𝕜' × 𝕜' => ContinuousLinearMap.mulLeftRight 𝕜 𝕜' p.1 p.2 :=\n  (ContinuousLinearMap.mulLeftRight 𝕜 𝕜').isBoundedBilinearMap\n\n"}
{"name":"IsBoundedBilinearMap.isBoundedLinearMap_deriv","module":"Mathlib.Analysis.Normed.Operator.BoundedLinearMaps","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁵ : SeminormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝³ : SeminormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type u_4\ninst✝¹ : SeminormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nf : Prod E F → G\nh : IsBoundedBilinearMap 𝕜 f\n⊢ IsBoundedLinearMap 𝕜 fun p => h.deriv p","decl":"/-- Given a bounded bilinear map `f`, the map associating to a point `p` the derivative of `f` at\n`p` is itself a bounded linear map. -/\ntheorem IsBoundedBilinearMap.isBoundedLinearMap_deriv (h : IsBoundedBilinearMap 𝕜 f) :\n    IsBoundedLinearMap 𝕜 fun p : E × F => h.deriv p :=\n  h.toContinuousLinearMap.deriv₂.isBoundedLinearMap\n\n"}
{"name":"Continuous.clm_comp","module":"Mathlib.Analysis.Normed.Operator.BoundedLinearMaps","initialProofState":"𝕜 : Type u_1\ninst✝⁷ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁶ : SeminormedAddCommGroup E\ninst✝⁵ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝⁴ : SeminormedAddCommGroup F\ninst✝³ : NormedSpace 𝕜 F\nG : Type u_4\ninst✝² : SeminormedAddCommGroup G\ninst✝¹ : NormedSpace 𝕜 G\nX : Type u_5\ninst✝ : TopologicalSpace X\ng : X → ContinuousLinearMap (RingHom.id 𝕜) F G\nf : X → ContinuousLinearMap (RingHom.id 𝕜) E F\nhg : Continuous g\nhf : Continuous f\n⊢ Continuous fun x => (g x).comp (f x)","decl":"@[continuity, fun_prop]\ntheorem Continuous.clm_comp {X} [TopologicalSpace X] {g : X → F →L[𝕜] G} {f : X → E →L[𝕜] F}\n    (hg : Continuous g) (hf : Continuous f) : Continuous fun x => (g x).comp (f x) :=\n  (compL 𝕜 E F G).continuous₂.comp₂ hg hf\n\n"}
{"name":"ContinuousOn.clm_comp","module":"Mathlib.Analysis.Normed.Operator.BoundedLinearMaps","initialProofState":"𝕜 : Type u_1\ninst✝⁷ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁶ : SeminormedAddCommGroup E\ninst✝⁵ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝⁴ : SeminormedAddCommGroup F\ninst✝³ : NormedSpace 𝕜 F\nG : Type u_4\ninst✝² : SeminormedAddCommGroup G\ninst✝¹ : NormedSpace 𝕜 G\nX : Type u_5\ninst✝ : TopologicalSpace X\ng : X → ContinuousLinearMap (RingHom.id 𝕜) F G\nf : X → ContinuousLinearMap (RingHom.id 𝕜) E F\ns : Set X\nhg : ContinuousOn g s\nhf : ContinuousOn f s\n⊢ ContinuousOn (fun x => (g x).comp (f x)) s","decl":"theorem ContinuousOn.clm_comp {X} [TopologicalSpace X] {g : X → F →L[𝕜] G} {f : X → E →L[𝕜] F}\n    {s : Set X} (hg : ContinuousOn g s) (hf : ContinuousOn f s) :\n    ContinuousOn (fun x => (g x).comp (f x)) s :=\n  (compL 𝕜 E F G).continuous₂.comp_continuousOn (hg.prod hf)\n\n"}
{"name":"Continuous.clm_apply","module":"Mathlib.Analysis.Normed.Operator.BoundedLinearMaps","initialProofState":"𝕜 : Type u_1\ninst✝⁵ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁴ : SeminormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝² : SeminormedAddCommGroup F\ninst✝¹ : NormedSpace 𝕜 F\nX : Type u_5\ninst✝ : TopologicalSpace X\nf : X → ContinuousLinearMap (RingHom.id 𝕜) E F\ng : X → E\nhf : Continuous f\nhg : Continuous g\n⊢ Continuous fun x => (f x) (g x)","decl":"@[continuity, fun_prop]\ntheorem Continuous.clm_apply {X} [TopologicalSpace X] {f : X → (E →L[𝕜] F)} {g : X → E}\n    (hf : Continuous f) (hg : Continuous g) : Continuous (fun x ↦ (f x) (g x)) :=\n  isBoundedBilinearMap_apply.continuous.comp₂ hf hg\n\n"}
{"name":"ContinuousOn.clm_apply","module":"Mathlib.Analysis.Normed.Operator.BoundedLinearMaps","initialProofState":"𝕜 : Type u_1\ninst✝⁵ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁴ : SeminormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝² : SeminormedAddCommGroup F\ninst✝¹ : NormedSpace 𝕜 F\nX : Type u_5\ninst✝ : TopologicalSpace X\nf : X → ContinuousLinearMap (RingHom.id 𝕜) E F\ng : X → E\ns : Set X\nhf : ContinuousOn f s\nhg : ContinuousOn g s\n⊢ ContinuousOn (fun x => (f x) (g x)) s","decl":"theorem ContinuousOn.clm_apply {X} [TopologicalSpace X] {f : X → (E →L[𝕜] F)} {g : X → E}\n    {s : Set X} (hf : ContinuousOn f s) (hg : ContinuousOn g s) :\n    ContinuousOn (fun x ↦ f x (g x)) s :=\n  isBoundedBilinearMap_apply.continuous.comp_continuousOn (hf.prod hg)\n\n"}
{"name":"ContinuousLinearEquiv.isOpen","module":"Mathlib.Analysis.Normed.Operator.BoundedLinearMaps","initialProofState":"𝕜 : Type u_1\ninst✝⁵ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝² : SeminormedAddCommGroup F\ninst✝¹ : NormedSpace 𝕜 F\ninst✝ : CompleteSpace E\n⊢ IsOpen (Set.range ContinuousLinearEquiv.toContinuousLinearMap)","decl":"protected theorem isOpen [CompleteSpace E] : IsOpen (range ((↑) : (E ≃L[𝕜] F) → E →L[𝕜] F)) := by\n  rw [isOpen_iff_mem_nhds, forall_mem_range]\n  refine fun e => IsOpen.mem_nhds ?_ (mem_range_self _)\n  let O : (E →L[𝕜] F) → E →L[𝕜] E := fun f => (e.symm : F →L[𝕜] E).comp f\n  have h_O : Continuous O := isBoundedBilinearMap_comp.continuous_right\n  convert show IsOpen (O ⁻¹' { x | IsUnit x }) from Units.isOpen.preimage h_O using 1\n  ext f'\n  constructor\n  · rintro ⟨e', rfl⟩\n    exact ⟨(e'.trans e.symm).toUnit, rfl⟩\n  · rintro ⟨w, hw⟩\n    use (unitsEquiv 𝕜 E w).trans e\n    ext x\n    simp [O, hw]\n\n"}
{"name":"ContinuousLinearEquiv.nhds","module":"Mathlib.Analysis.Normed.Operator.BoundedLinearMaps","initialProofState":"𝕜 : Type u_1\ninst✝⁵ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝² : SeminormedAddCommGroup F\ninst✝¹ : NormedSpace 𝕜 F\ninst✝ : CompleteSpace E\ne : ContinuousLinearEquiv (RingHom.id 𝕜) E F\n⊢ Membership.mem (nhds ↑e) (Set.range ContinuousLinearEquiv.toContinuousLinearMap)","decl":"protected theorem nhds [CompleteSpace E] (e : E ≃L[𝕜] F) :\n    range ((↑) : (E ≃L[𝕜] F) → E →L[𝕜] F) ∈ 𝓝 (e : E →L[𝕜] F) :=\n  IsOpen.mem_nhds ContinuousLinearEquiv.isOpen (by simp)\n\n"}
