{"name":"IsBoundedLinearMap.toIsLinearMap","module":"Mathlib.Analysis.Normed.Operator.BoundedLinearMaps","initialProofState":"ğ•œ : Type u_5\ninstâœâ´ : NormedField ğ•œ\nE : Type u_6\ninstâœÂ³ : SeminormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_7\ninstâœÂ¹ : SeminormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nself : IsBoundedLinearMap ğ•œ f\nâŠ¢ IsLinearMap ğ•œ f","decl":"/-- A function `f` satisfies `IsBoundedLinearMap ğ•œ f` if it is linear and satisfies the\ninequality `â€–f xâ€– â‰¤ M * â€–xâ€–` for some positive constant `M`. -/\nstructure IsBoundedLinearMap (ğ•œ : Type*) [NormedField ğ•œ] {E : Type*} [SeminormedAddCommGroup E]\n  [NormedSpace ğ•œ E] {F : Type*} [SeminormedAddCommGroup F] [NormedSpace ğ•œ F] (f : E â†’ F) extends\n  IsLinearMap ğ•œ f : Prop where\n  bound : âˆƒ M, 0 < M âˆ§ âˆ€ x : E, â€–f xâ€– â‰¤ M * â€–xâ€–\n\n"}
{"name":"IsBoundedLinearMap.bound","module":"Mathlib.Analysis.Normed.Operator.BoundedLinearMaps","initialProofState":"ğ•œ : Type u_5\ninstâœâ´ : NormedField ğ•œ\nE : Type u_6\ninstâœÂ³ : SeminormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_7\ninstâœÂ¹ : SeminormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nself : IsBoundedLinearMap ğ•œ f\nâŠ¢ Exists fun M => And (LT.lt 0 M) (âˆ€ (x : E), LE.le (Norm.norm (f x)) (HMul.hMul M (Norm.norm x)))","decl":"/-- A function `f` satisfies `IsBoundedLinearMap ğ•œ f` if it is linear and satisfies the\ninequality `â€–f xâ€– â‰¤ M * â€–xâ€–` for some positive constant `M`. -/\nstructure IsBoundedLinearMap (ğ•œ : Type*) [NormedField ğ•œ] {E : Type*} [SeminormedAddCommGroup E]\n  [NormedSpace ğ•œ E] {F : Type*} [SeminormedAddCommGroup F] [NormedSpace ğ•œ F] (f : E â†’ F) extends\n  IsLinearMap ğ•œ f : Prop where\n  bound : âˆƒ M, 0 < M âˆ§ âˆ€ x : E, â€–f xâ€– â‰¤ M * â€–xâ€–\n\n"}
{"name":"IsLinearMap.with_bound","module":"Mathlib.Analysis.Normed.Operator.BoundedLinearMaps","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : SeminormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : SeminormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nhf : IsLinearMap ğ•œ f\nM : Real\nh : âˆ€ (x : E), LE.le (Norm.norm (f x)) (HMul.hMul M (Norm.norm x))\nâŠ¢ IsBoundedLinearMap ğ•œ f","decl":"theorem IsLinearMap.with_bound {f : E â†’ F} (hf : IsLinearMap ğ•œ f) (M : â„)\n    (h : âˆ€ x : E, â€–f xâ€– â‰¤ M * â€–xâ€–) : IsBoundedLinearMap ğ•œ f :=\n  âŸ¨hf,\n    by_cases\n      (fun (this : M â‰¤ 0) =>\n        âŸ¨1, zero_lt_one, fun x =>\n          (h x).trans <| mul_le_mul_of_nonneg_right (this.trans zero_le_one) (norm_nonneg x)âŸ©)\n      fun (this : Â¬M â‰¤ 0) => âŸ¨M, lt_of_not_ge this, hâŸ©âŸ©\n\n"}
{"name":"ContinuousLinearMap.isBoundedLinearMap","module":"Mathlib.Analysis.Normed.Operator.BoundedLinearMaps","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : SeminormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : SeminormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : ContinuousLinearMap (RingHom.id ğ•œ) E F\nâŠ¢ IsBoundedLinearMap ğ•œ â‡‘f","decl":"/-- A continuous linear map satisfies `IsBoundedLinearMap` -/\ntheorem ContinuousLinearMap.isBoundedLinearMap (f : E â†’L[ğ•œ] F) : IsBoundedLinearMap ğ•œ f :=\n  { f.toLinearMap.isLinear with bound := f.bound }\n\n"}
{"name":"IsBoundedLinearMap.zero","module":"Mathlib.Analysis.Normed.Operator.BoundedLinearMaps","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : SeminormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : SeminormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nâŠ¢ IsBoundedLinearMap ğ•œ fun x => 0","decl":"theorem zero : IsBoundedLinearMap ğ•œ fun _ : E => (0 : F) :=\n  (0 : E â†’â‚—[ğ•œ] F).isLinear.with_bound 0 <| by simp [le_refl]\n\n"}
{"name":"IsBoundedLinearMap.id","module":"Mathlib.Analysis.Normed.Operator.BoundedLinearMaps","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nâŠ¢ IsBoundedLinearMap ğ•œ fun x => x","decl":"theorem id : IsBoundedLinearMap ğ•œ fun x : E => x :=\n  LinearMap.id.isLinear.with_bound 1 <| by simp [le_refl]\n\n"}
{"name":"IsBoundedLinearMap.fst","module":"Mathlib.Analysis.Normed.Operator.BoundedLinearMaps","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : SeminormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : SeminormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nâŠ¢ IsBoundedLinearMap ğ•œ fun x => x.1","decl":"theorem fst : IsBoundedLinearMap ğ•œ fun x : E Ã— F => x.1 := by\n  refine (LinearMap.fst ğ•œ E F).isLinear.with_bound 1 fun x => ?_\n  rw [one_mul]\n  exact le_max_left _ _\n\n"}
{"name":"IsBoundedLinearMap.snd","module":"Mathlib.Analysis.Normed.Operator.BoundedLinearMaps","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : SeminormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : SeminormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nâŠ¢ IsBoundedLinearMap ğ•œ fun x => x.2","decl":"theorem snd : IsBoundedLinearMap ğ•œ fun x : E Ã— F => x.2 := by\n  refine (LinearMap.snd ğ•œ E F).isLinear.with_bound 1 fun x => ?_\n  rw [one_mul]\n  exact le_max_right _ _\n\n"}
{"name":"IsBoundedLinearMap.smul","module":"Mathlib.Analysis.Normed.Operator.BoundedLinearMaps","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : SeminormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : SeminormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nc : ğ•œ\nhf : IsBoundedLinearMap ğ•œ f\nâŠ¢ IsBoundedLinearMap ğ•œ (HSMul.hSMul c f)","decl":"theorem smul (c : ğ•œ) (hf : IsBoundedLinearMap ğ•œ f) : IsBoundedLinearMap ğ•œ (c â€¢ f) :=\n  let âŸ¨hlf, M, _, hMâŸ© := hf\n  (c â€¢ hlf.mk' f).isLinear.with_bound (â€–câ€– * M) fun x =>\n    calc\n      â€–c â€¢ f xâ€– = â€–câ€– * â€–f xâ€– := norm_smul c (f x)\n      _ â‰¤ â€–câ€– * (M * â€–xâ€–) := mul_le_mul_of_nonneg_left (hM _) (norm_nonneg _)\n      _ = â€–câ€– * M * â€–xâ€– := (mul_assoc _ _ _).symm\n\n"}
{"name":"IsBoundedLinearMap.neg","module":"Mathlib.Analysis.Normed.Operator.BoundedLinearMaps","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : SeminormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : SeminormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nhf : IsBoundedLinearMap ğ•œ f\nâŠ¢ IsBoundedLinearMap ğ•œ fun e => Neg.neg (f e)","decl":"theorem neg (hf : IsBoundedLinearMap ğ•œ f) : IsBoundedLinearMap ğ•œ fun e => -f e := by\n  rw [show (fun e => -f e) = fun e => (-1 : ğ•œ) â€¢ f e by funext; simp]\n  exact smul (-1) hf\n\n"}
{"name":"IsBoundedLinearMap.add","module":"Mathlib.Analysis.Normed.Operator.BoundedLinearMaps","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : SeminormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : SeminormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf g : E â†’ F\nhf : IsBoundedLinearMap ğ•œ f\nhg : IsBoundedLinearMap ğ•œ g\nâŠ¢ IsBoundedLinearMap ğ•œ fun e => HAdd.hAdd (f e) (g e)","decl":"theorem add (hf : IsBoundedLinearMap ğ•œ f) (hg : IsBoundedLinearMap ğ•œ g) :\n    IsBoundedLinearMap ğ•œ fun e => f e + g e :=\n  let âŸ¨hlf, Mf, _, hMfâŸ© := hf\n  let âŸ¨hlg, Mg, _, hMgâŸ© := hg\n  (hlf.mk' _ + hlg.mk' _).isLinear.with_bound (Mf + Mg) fun x =>\n    calc\n      â€–f x + g xâ€– â‰¤ Mf * â€–xâ€– + Mg * â€–xâ€– := norm_add_le_of_le (hMf x) (hMg x)\n      _ â‰¤ (Mf + Mg) * â€–xâ€– := by rw [add_mul]\n\n"}
{"name":"IsBoundedLinearMap.sub","module":"Mathlib.Analysis.Normed.Operator.BoundedLinearMaps","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : SeminormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : SeminormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf g : E â†’ F\nhf : IsBoundedLinearMap ğ•œ f\nhg : IsBoundedLinearMap ğ•œ g\nâŠ¢ IsBoundedLinearMap ğ•œ fun e => HSub.hSub (f e) (g e)","decl":"theorem sub (hf : IsBoundedLinearMap ğ•œ f) (hg : IsBoundedLinearMap ğ•œ g) :\n    IsBoundedLinearMap ğ•œ fun e => f e - g e := by simpa [sub_eq_add_neg] using add hf (neg hg)\n\n"}
{"name":"IsBoundedLinearMap.comp","module":"Mathlib.Analysis.Normed.Operator.BoundedLinearMaps","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâµ : SeminormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ³ : SeminormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type u_4\ninstâœÂ¹ : SeminormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nf : E â†’ F\ng : F â†’ G\nhg : IsBoundedLinearMap ğ•œ g\nhf : IsBoundedLinearMap ğ•œ f\nâŠ¢ IsBoundedLinearMap ğ•œ (Function.comp g f)","decl":"theorem comp {g : F â†’ G} (hg : IsBoundedLinearMap ğ•œ g) (hf : IsBoundedLinearMap ğ•œ f) :\n    IsBoundedLinearMap ğ•œ (g âˆ˜ f) :=\n  (hg.toContinuousLinearMap.comp hf.toContinuousLinearMap).isBoundedLinearMap\n\n"}
{"name":"IsBoundedLinearMap.tendsto","module":"Mathlib.Analysis.Normed.Operator.BoundedLinearMaps","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : SeminormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : SeminormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nx : E\nhf : IsBoundedLinearMap ğ•œ f\nâŠ¢ Filter.Tendsto f (nhds x) (nhds (f x))","decl":"protected theorem tendsto (x : E) (hf : IsBoundedLinearMap ğ•œ f) : Tendsto f (ğ“ x) (ğ“ (f x)) :=\n  let âŸ¨hf, M, _, hMâŸ© := hf\n  tendsto_iff_norm_sub_tendsto_zero.2 <|\n    squeeze_zero (fun _ => norm_nonneg _)\n      (fun e =>\n        calc\n          â€–f e - f xâ€– = â€–hf.mk' f (e - x)â€– := by rw [(hf.mk' _).map_sub e x]; rfl\n          _ â‰¤ M * â€–e - xâ€– := hM (e - x)\n          )\n      (suffices Tendsto (fun e : E => M * â€–e - xâ€–) (ğ“ x) (ğ“ (M * 0)) by simpa\n      tendsto_const_nhds.mul (tendsto_norm_sub_self _))\n\n"}
{"name":"IsBoundedLinearMap.continuous","module":"Mathlib.Analysis.Normed.Operator.BoundedLinearMaps","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : SeminormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : SeminormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nhf : IsBoundedLinearMap ğ•œ f\nâŠ¢ Continuous f","decl":"theorem continuous (hf : IsBoundedLinearMap ğ•œ f) : Continuous f :=\n  continuous_iff_continuousAt.2 fun _ => hf.tendsto _\n\n"}
{"name":"IsBoundedLinearMap.lim_zero_bounded_linear_map","module":"Mathlib.Analysis.Normed.Operator.BoundedLinearMaps","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : SeminormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : SeminormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nhf : IsBoundedLinearMap ğ•œ f\nâŠ¢ Filter.Tendsto f (nhds 0) (nhds 0)","decl":"theorem lim_zero_bounded_linear_map (hf : IsBoundedLinearMap ğ•œ f) : Tendsto f (ğ“ 0) (ğ“ 0) :=\n  (hf.1.mk' _).map_zero â–¸ continuous_iff_continuousAt.1 hf.continuous 0\n\n"}
{"name":"IsBoundedLinearMap.isBigO_id","module":"Mathlib.Analysis.Normed.Operator.BoundedLinearMaps","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : SeminormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : SeminormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nh : IsBoundedLinearMap ğ•œ f\nl : Filter E\nâŠ¢ Asymptotics.IsBigO l f fun x => x","decl":"theorem isBigO_id {f : E â†’ F} (h : IsBoundedLinearMap ğ•œ f) (l : Filter E) : f =O[l] fun x => x :=\n  let âŸ¨_, _, hMâŸ© := h.bound\n  IsBigO.of_bound _ (mem_of_superset univ_mem fun x _ => hM x)\n\n"}
{"name":"IsBoundedLinearMap.isBigO_comp","module":"Mathlib.Analysis.Normed.Operator.BoundedLinearMaps","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nF : Type u_3\ninstâœÂ³ : SeminormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type u_4\ninstâœÂ¹ : SeminormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nE : Type u_5\ng : F â†’ G\nhg : IsBoundedLinearMap ğ•œ g\nf : E â†’ F\nl : Filter E\nâŠ¢ Asymptotics.IsBigO l (fun x' => g (f x')) f","decl":"theorem isBigO_comp {E : Type*} {g : F â†’ G} (hg : IsBoundedLinearMap ğ•œ g) {f : E â†’ F}\n    (l : Filter E) : (fun x' => g (f x')) =O[l] f :=\n  (hg.isBigO_id âŠ¤).comp_tendsto le_top\n\n"}
{"name":"IsBoundedLinearMap.isBigO_sub","module":"Mathlib.Analysis.Normed.Operator.BoundedLinearMaps","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : SeminormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : SeminormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nh : IsBoundedLinearMap ğ•œ f\nl : Filter E\nx : E\nâŠ¢ Asymptotics.IsBigO l (fun x' => f (HSub.hSub x' x)) fun x' => HSub.hSub x' x","decl":"theorem isBigO_sub {f : E â†’ F} (h : IsBoundedLinearMap ğ•œ f) (l : Filter E) (x : E) :\n    (fun x' => f (x' - x)) =O[l] fun x' => x' - x :=\n  isBigO_comp h l\n\n"}
{"name":"isBoundedLinearMap_prod_multilinear","module":"Mathlib.Analysis.Normed.Operator.BoundedLinearMaps","initialProofState":"ğ•œ : Type u_1\ninstâœâ· : NontriviallyNormedField ğ•œ\nF : Type u_3\ninstâœâ¶ : SeminormedAddCommGroup F\ninstâœâµ : NormedSpace ğ•œ F\nG : Type u_4\ninstâœâ´ : SeminormedAddCommGroup G\ninstâœÂ³ : NormedSpace ğ•œ G\nÎ¹ : Type u_5\ninstâœÂ² : Fintype Î¹\nE : Î¹ â†’ Type u_6\ninstâœÂ¹ : (i : Î¹) â†’ SeminormedAddCommGroup (E i)\ninstâœ : (i : Î¹) â†’ NormedSpace ğ•œ (E i)\nâŠ¢ IsBoundedLinearMap ğ•œ fun p => p.1.prod p.2","decl":"/-- Taking the cartesian product of two continuous multilinear maps is a bounded linear\noperation. -/\ntheorem isBoundedLinearMap_prod_multilinear {E : Î¹ â†’ Type*} [âˆ€ i, SeminormedAddCommGroup (E i)]\n    [âˆ€ i, NormedSpace ğ•œ (E i)] :\n    IsBoundedLinearMap ğ•œ fun p : ContinuousMultilinearMap ğ•œ E F Ã— ContinuousMultilinearMap ğ•œ E G =>\n      p.1.prod p.2 :=\n  (ContinuousMultilinearMap.prodL ğ•œ E F G).toContinuousLinearEquiv\n    |>.toContinuousLinearMap.isBoundedLinearMap\n\n"}
{"name":"isBoundedLinearMap_continuousMultilinearMap_comp_linear","module":"Mathlib.Analysis.Normed.Operator.BoundedLinearMaps","initialProofState":"ğ•œ : Type u_1\ninstâœâ· : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ¶ : SeminormedAddCommGroup E\ninstâœâµ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœâ´ : SeminormedAddCommGroup F\ninstâœÂ³ : NormedSpace ğ•œ F\nG : Type u_4\ninstâœÂ² : SeminormedAddCommGroup G\ninstâœÂ¹ : NormedSpace ğ•œ G\nÎ¹ : Type u_5\ninstâœ : Fintype Î¹\ng : ContinuousLinearMap (RingHom.id ğ•œ) G E\nâŠ¢ IsBoundedLinearMap ğ•œ fun f => f.compContinuousLinearMap fun x => g","decl":"/-- Given a fixed continuous linear map `g`, associating to a continuous multilinear map `f` the\ncontinuous multilinear map `f (g mâ‚, ..., g mâ‚™)` is a bounded linear operation. -/\ntheorem isBoundedLinearMap_continuousMultilinearMap_comp_linear (g : G â†’L[ğ•œ] E) :\n    IsBoundedLinearMap ğ•œ fun f : ContinuousMultilinearMap ğ•œ (fun _ : Î¹ => E) F =>\n      f.compContinuousLinearMap fun _ => g :=\n  (ContinuousMultilinearMap.compContinuousLinearMapL (Î¹ := Î¹) (G := F) (fun _ â†¦ g))\n    |>.isBoundedLinearMap\n\n"}
{"name":"ContinuousLinearMap.map_addâ‚‚","module":"Mathlib.Analysis.Normed.Operator.BoundedLinearMaps","initialProofState":"ğ•œ : Type u_1\ninstâœÂ¹Â² : NontriviallyNormedField ğ•œ\nF : Type u_3\ninstâœÂ¹Â¹ : SeminormedAddCommGroup F\ninstâœÂ¹â° : NormedSpace ğ•œ F\nR : Type u_5\nğ•œâ‚‚ : Type u_6\nğ•œ' : Type u_7\ninstâœâ¹ : NontriviallyNormedField ğ•œ'\ninstâœâ¸ : NontriviallyNormedField ğ•œâ‚‚\nM : Type u_8\ninstâœâ· : TopologicalSpace M\nÏƒâ‚â‚‚ : RingHom ğ•œ ğ•œâ‚‚\nG' : Type u_9\ninstâœâ¶ : SeminormedAddCommGroup G'\ninstâœâµ : NormedSpace ğ•œâ‚‚ G'\ninstâœâ´ : NormedSpace ğ•œ' G'\ninstâœÂ³ : SMulCommClass ğ•œâ‚‚ ğ•œ' G'\ninstâœÂ² : Semiring R\ninstâœÂ¹ : AddCommMonoid M\ninstâœ : Module R M\nÏâ‚â‚‚ : RingHom R ğ•œ'\nf : ContinuousLinearMap Ïâ‚â‚‚ M (ContinuousLinearMap Ïƒâ‚â‚‚ F G')\nx x' : M\ny : F\nâŠ¢ Eq ((f (HAdd.hAdd x x')) y) (HAdd.hAdd ((f x) y) ((f x') y))","decl":"theorem map_addâ‚‚ (f : M â†’SL[Ïâ‚â‚‚] F â†’SL[Ïƒâ‚â‚‚] G') (x x' : M) (y : F) :\n    f (x + x') y = f x y + f x' y := by rw [f.map_add, add_apply]\n\n"}
{"name":"ContinuousLinearMap.map_zeroâ‚‚","module":"Mathlib.Analysis.Normed.Operator.BoundedLinearMaps","initialProofState":"ğ•œ : Type u_1\ninstâœÂ¹Â² : NontriviallyNormedField ğ•œ\nF : Type u_3\ninstâœÂ¹Â¹ : SeminormedAddCommGroup F\ninstâœÂ¹â° : NormedSpace ğ•œ F\nR : Type u_5\nğ•œâ‚‚ : Type u_6\nğ•œ' : Type u_7\ninstâœâ¹ : NontriviallyNormedField ğ•œ'\ninstâœâ¸ : NontriviallyNormedField ğ•œâ‚‚\nM : Type u_8\ninstâœâ· : TopologicalSpace M\nÏƒâ‚â‚‚ : RingHom ğ•œ ğ•œâ‚‚\nG' : Type u_9\ninstâœâ¶ : SeminormedAddCommGroup G'\ninstâœâµ : NormedSpace ğ•œâ‚‚ G'\ninstâœâ´ : NormedSpace ğ•œ' G'\ninstâœÂ³ : SMulCommClass ğ•œâ‚‚ ğ•œ' G'\ninstâœÂ² : Semiring R\ninstâœÂ¹ : AddCommMonoid M\ninstâœ : Module R M\nÏâ‚â‚‚ : RingHom R ğ•œ'\nf : ContinuousLinearMap Ïâ‚â‚‚ M (ContinuousLinearMap Ïƒâ‚â‚‚ F G')\ny : F\nâŠ¢ Eq ((f 0) y) 0","decl":"theorem map_zeroâ‚‚ (f : M â†’SL[Ïâ‚â‚‚] F â†’SL[Ïƒâ‚â‚‚] G') (y : F) : f 0 y = 0 := by\n  rw [f.map_zero, zero_apply]\n\n"}
{"name":"ContinuousLinearMap.map_smulâ‚›â‚—â‚‚","module":"Mathlib.Analysis.Normed.Operator.BoundedLinearMaps","initialProofState":"ğ•œ : Type u_1\ninstâœÂ¹Â² : NontriviallyNormedField ğ•œ\nF : Type u_3\ninstâœÂ¹Â¹ : SeminormedAddCommGroup F\ninstâœÂ¹â° : NormedSpace ğ•œ F\nR : Type u_5\nğ•œâ‚‚ : Type u_6\nğ•œ' : Type u_7\ninstâœâ¹ : NontriviallyNormedField ğ•œ'\ninstâœâ¸ : NontriviallyNormedField ğ•œâ‚‚\nM : Type u_8\ninstâœâ· : TopologicalSpace M\nÏƒâ‚â‚‚ : RingHom ğ•œ ğ•œâ‚‚\nG' : Type u_9\ninstâœâ¶ : SeminormedAddCommGroup G'\ninstâœâµ : NormedSpace ğ•œâ‚‚ G'\ninstâœâ´ : NormedSpace ğ•œ' G'\ninstâœÂ³ : SMulCommClass ğ•œâ‚‚ ğ•œ' G'\ninstâœÂ² : Semiring R\ninstâœÂ¹ : AddCommMonoid M\ninstâœ : Module R M\nÏâ‚â‚‚ : RingHom R ğ•œ'\nf : ContinuousLinearMap Ïâ‚â‚‚ M (ContinuousLinearMap Ïƒâ‚â‚‚ F G')\nc : R\nx : M\ny : F\nâŠ¢ Eq ((f (HSMul.hSMul c x)) y) (HSMul.hSMul (Ïâ‚â‚‚ c) ((f x) y))","decl":"theorem map_smulâ‚›â‚—â‚‚ (f : M â†’SL[Ïâ‚â‚‚] F â†’SL[Ïƒâ‚â‚‚] G') (c : R) (x : M) (y : F) :\n    f (c â€¢ x) y = Ïâ‚â‚‚ c â€¢ f x y := by rw [f.map_smulâ‚›â‚—, smul_apply]\n\n"}
{"name":"ContinuousLinearMap.map_subâ‚‚","module":"Mathlib.Analysis.Normed.Operator.BoundedLinearMaps","initialProofState":"ğ•œ : Type u_1\ninstâœÂ¹Â² : NontriviallyNormedField ğ•œ\nF : Type u_3\ninstâœÂ¹Â¹ : SeminormedAddCommGroup F\ninstâœÂ¹â° : NormedSpace ğ•œ F\nR : Type u_5\nğ•œâ‚‚ : Type u_6\nğ•œ' : Type u_7\ninstâœâ¹ : NontriviallyNormedField ğ•œ'\ninstâœâ¸ : NontriviallyNormedField ğ•œâ‚‚\nM : Type u_8\ninstâœâ· : TopologicalSpace M\nÏƒâ‚â‚‚ : RingHom ğ•œ ğ•œâ‚‚\nG' : Type u_9\ninstâœâ¶ : SeminormedAddCommGroup G'\ninstâœâµ : NormedSpace ğ•œâ‚‚ G'\ninstâœâ´ : NormedSpace ğ•œ' G'\ninstâœÂ³ : SMulCommClass ğ•œâ‚‚ ğ•œ' G'\ninstâœÂ² : Ring R\ninstâœÂ¹ : AddCommGroup M\ninstâœ : Module R M\nÏâ‚â‚‚ : RingHom R ğ•œ'\nf : ContinuousLinearMap Ïâ‚â‚‚ M (ContinuousLinearMap Ïƒâ‚â‚‚ F G')\nx x' : M\ny : F\nâŠ¢ Eq ((f (HSub.hSub x x')) y) (HSub.hSub ((f x) y) ((f x') y))","decl":"theorem map_subâ‚‚ (f : M â†’SL[Ïâ‚â‚‚] F â†’SL[Ïƒâ‚â‚‚] G') (x x' : M) (y : F) :\n    f (x - x') y = f x y - f x' y := by rw [f.map_sub, sub_apply]\n\n"}
{"name":"ContinuousLinearMap.map_negâ‚‚","module":"Mathlib.Analysis.Normed.Operator.BoundedLinearMaps","initialProofState":"ğ•œ : Type u_1\ninstâœÂ¹Â² : NontriviallyNormedField ğ•œ\nF : Type u_3\ninstâœÂ¹Â¹ : SeminormedAddCommGroup F\ninstâœÂ¹â° : NormedSpace ğ•œ F\nR : Type u_5\nğ•œâ‚‚ : Type u_6\nğ•œ' : Type u_7\ninstâœâ¹ : NontriviallyNormedField ğ•œ'\ninstâœâ¸ : NontriviallyNormedField ğ•œâ‚‚\nM : Type u_8\ninstâœâ· : TopologicalSpace M\nÏƒâ‚â‚‚ : RingHom ğ•œ ğ•œâ‚‚\nG' : Type u_9\ninstâœâ¶ : SeminormedAddCommGroup G'\ninstâœâµ : NormedSpace ğ•œâ‚‚ G'\ninstâœâ´ : NormedSpace ğ•œ' G'\ninstâœÂ³ : SMulCommClass ğ•œâ‚‚ ğ•œ' G'\ninstâœÂ² : Ring R\ninstâœÂ¹ : AddCommGroup M\ninstâœ : Module R M\nÏâ‚â‚‚ : RingHom R ğ•œ'\nf : ContinuousLinearMap Ïâ‚â‚‚ M (ContinuousLinearMap Ïƒâ‚â‚‚ F G')\nx : M\ny : F\nâŠ¢ Eq ((f (Neg.neg x)) y) (Neg.neg ((f x) y))","decl":"theorem map_negâ‚‚ (f : M â†’SL[Ïâ‚â‚‚] F â†’SL[Ïƒâ‚â‚‚] G') (x : M) (y : F) : f (-x) y = -f x y := by\n  rw [f.map_neg, neg_apply]\n\n"}
{"name":"ContinuousLinearMap.map_smulâ‚‚","module":"Mathlib.Analysis.Normed.Operator.BoundedLinearMaps","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâµ : SeminormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ³ : SeminormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type u_4\ninstâœÂ¹ : SeminormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nf : ContinuousLinearMap (RingHom.id ğ•œ) E (ContinuousLinearMap (RingHom.id ğ•œ) F G)\nc : ğ•œ\nx : E\ny : F\nâŠ¢ Eq ((f (HSMul.hSMul c x)) y) (HSMul.hSMul c ((f x) y))","decl":"theorem map_smulâ‚‚ (f : E â†’L[ğ•œ] F â†’L[ğ•œ] G) (c : ğ•œ) (x : E) (y : F) : f (c â€¢ x) y = c â€¢ f x y := by\n  rw [f.map_smul, smul_apply]\n\n"}
{"name":"IsBoundedBilinearMap.bound","module":"Mathlib.Analysis.Normed.Operator.BoundedLinearMaps","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâµ : SeminormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ³ : SeminormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type u_4\ninstâœÂ¹ : SeminormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nf : Prod E F â†’ G\nself : IsBoundedBilinearMap ğ•œ f\nâŠ¢ Exists fun C => And (GT.gt C 0) (âˆ€ (x : E) (y : F), LE.le (Norm.norm (f { fst := x, snd := y })) (HMul.hMul (HMul.hMul C (Norm.norm x)) (Norm.norm y)))","decl":"/-- A map `f : E Ã— F â†’ G` satisfies `IsBoundedBilinearMap ğ•œ f` if it is bilinear and\ncontinuous. -/\nstructure IsBoundedBilinearMap (f : E Ã— F â†’ G) : Prop where\n  add_left : âˆ€ (xâ‚ xâ‚‚ : E) (y : F), f (xâ‚ + xâ‚‚, y) = f (xâ‚, y) + f (xâ‚‚, y)\n  smul_left : âˆ€ (c : ğ•œ) (x : E) (y : F), f (c â€¢ x, y) = c â€¢ f (x, y)\n  add_right : âˆ€ (x : E) (yâ‚ yâ‚‚ : F), f (x, yâ‚ + yâ‚‚) = f (x, yâ‚) + f (x, yâ‚‚)\n  smul_right : âˆ€ (c : ğ•œ) (x : E) (y : F), f (x, c â€¢ y) = c â€¢ f (x, y)\n  bound : âˆƒ C > 0, âˆ€ (x : E) (y : F), â€–f (x, y)â€– â‰¤ C * â€–xâ€– * â€–yâ€–\n\n"}
{"name":"IsBoundedBilinearMap.smul_right","module":"Mathlib.Analysis.Normed.Operator.BoundedLinearMaps","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâµ : SeminormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ³ : SeminormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type u_4\ninstâœÂ¹ : SeminormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nf : Prod E F â†’ G\nself : IsBoundedBilinearMap ğ•œ f\nc : ğ•œ\nx : E\ny : F\nâŠ¢ Eq (f { fst := x, snd := HSMul.hSMul c y }) (HSMul.hSMul c (f { fst := x, snd := y }))","decl":"/-- A map `f : E Ã— F â†’ G` satisfies `IsBoundedBilinearMap ğ•œ f` if it is bilinear and\ncontinuous. -/\nstructure IsBoundedBilinearMap (f : E Ã— F â†’ G) : Prop where\n  add_left : âˆ€ (xâ‚ xâ‚‚ : E) (y : F), f (xâ‚ + xâ‚‚, y) = f (xâ‚, y) + f (xâ‚‚, y)\n  smul_left : âˆ€ (c : ğ•œ) (x : E) (y : F), f (c â€¢ x, y) = c â€¢ f (x, y)\n  add_right : âˆ€ (x : E) (yâ‚ yâ‚‚ : F), f (x, yâ‚ + yâ‚‚) = f (x, yâ‚) + f (x, yâ‚‚)\n  smul_right : âˆ€ (c : ğ•œ) (x : E) (y : F), f (x, c â€¢ y) = c â€¢ f (x, y)\n  bound : âˆƒ C > 0, âˆ€ (x : E) (y : F), â€–f (x, y)â€– â‰¤ C * â€–xâ€– * â€–yâ€–\n\n"}
{"name":"IsBoundedBilinearMap.add_left","module":"Mathlib.Analysis.Normed.Operator.BoundedLinearMaps","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâµ : SeminormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ³ : SeminormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type u_4\ninstâœÂ¹ : SeminormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nf : Prod E F â†’ G\nself : IsBoundedBilinearMap ğ•œ f\nxâ‚ xâ‚‚ : E\ny : F\nâŠ¢ Eq (f { fst := HAdd.hAdd xâ‚ xâ‚‚, snd := y }) (HAdd.hAdd (f { fst := xâ‚, snd := y }) (f { fst := xâ‚‚, snd := y }))","decl":"/-- A map `f : E Ã— F â†’ G` satisfies `IsBoundedBilinearMap ğ•œ f` if it is bilinear and\ncontinuous. -/\nstructure IsBoundedBilinearMap (f : E Ã— F â†’ G) : Prop where\n  add_left : âˆ€ (xâ‚ xâ‚‚ : E) (y : F), f (xâ‚ + xâ‚‚, y) = f (xâ‚, y) + f (xâ‚‚, y)\n  smul_left : âˆ€ (c : ğ•œ) (x : E) (y : F), f (c â€¢ x, y) = c â€¢ f (x, y)\n  add_right : âˆ€ (x : E) (yâ‚ yâ‚‚ : F), f (x, yâ‚ + yâ‚‚) = f (x, yâ‚) + f (x, yâ‚‚)\n  smul_right : âˆ€ (c : ğ•œ) (x : E) (y : F), f (x, c â€¢ y) = c â€¢ f (x, y)\n  bound : âˆƒ C > 0, âˆ€ (x : E) (y : F), â€–f (x, y)â€– â‰¤ C * â€–xâ€– * â€–yâ€–\n\n"}
{"name":"IsBoundedBilinearMap.smul_left","module":"Mathlib.Analysis.Normed.Operator.BoundedLinearMaps","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâµ : SeminormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ³ : SeminormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type u_4\ninstâœÂ¹ : SeminormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nf : Prod E F â†’ G\nself : IsBoundedBilinearMap ğ•œ f\nc : ğ•œ\nx : E\ny : F\nâŠ¢ Eq (f { fst := HSMul.hSMul c x, snd := y }) (HSMul.hSMul c (f { fst := x, snd := y }))","decl":"/-- A map `f : E Ã— F â†’ G` satisfies `IsBoundedBilinearMap ğ•œ f` if it is bilinear and\ncontinuous. -/\nstructure IsBoundedBilinearMap (f : E Ã— F â†’ G) : Prop where\n  add_left : âˆ€ (xâ‚ xâ‚‚ : E) (y : F), f (xâ‚ + xâ‚‚, y) = f (xâ‚, y) + f (xâ‚‚, y)\n  smul_left : âˆ€ (c : ğ•œ) (x : E) (y : F), f (c â€¢ x, y) = c â€¢ f (x, y)\n  add_right : âˆ€ (x : E) (yâ‚ yâ‚‚ : F), f (x, yâ‚ + yâ‚‚) = f (x, yâ‚) + f (x, yâ‚‚)\n  smul_right : âˆ€ (c : ğ•œ) (x : E) (y : F), f (x, c â€¢ y) = c â€¢ f (x, y)\n  bound : âˆƒ C > 0, âˆ€ (x : E) (y : F), â€–f (x, y)â€– â‰¤ C * â€–xâ€– * â€–yâ€–\n\n"}
{"name":"IsBoundedBilinearMap.add_right","module":"Mathlib.Analysis.Normed.Operator.BoundedLinearMaps","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâµ : SeminormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ³ : SeminormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type u_4\ninstâœÂ¹ : SeminormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nf : Prod E F â†’ G\nself : IsBoundedBilinearMap ğ•œ f\nx : E\nyâ‚ yâ‚‚ : F\nâŠ¢ Eq (f { fst := x, snd := HAdd.hAdd yâ‚ yâ‚‚ }) (HAdd.hAdd (f { fst := x, snd := yâ‚ }) (f { fst := x, snd := yâ‚‚ }))","decl":"/-- A map `f : E Ã— F â†’ G` satisfies `IsBoundedBilinearMap ğ•œ f` if it is bilinear and\ncontinuous. -/\nstructure IsBoundedBilinearMap (f : E Ã— F â†’ G) : Prop where\n  add_left : âˆ€ (xâ‚ xâ‚‚ : E) (y : F), f (xâ‚ + xâ‚‚, y) = f (xâ‚, y) + f (xâ‚‚, y)\n  smul_left : âˆ€ (c : ğ•œ) (x : E) (y : F), f (c â€¢ x, y) = c â€¢ f (x, y)\n  add_right : âˆ€ (x : E) (yâ‚ yâ‚‚ : F), f (x, yâ‚ + yâ‚‚) = f (x, yâ‚) + f (x, yâ‚‚)\n  smul_right : âˆ€ (c : ğ•œ) (x : E) (y : F), f (x, c â€¢ y) = c â€¢ f (x, y)\n  bound : âˆƒ C > 0, âˆ€ (x : E) (y : F), â€–f (x, y)â€– â‰¤ C * â€–xâ€– * â€–yâ€–\n\n"}
{"name":"ContinuousLinearMap.isBoundedBilinearMap","module":"Mathlib.Analysis.Normed.Operator.BoundedLinearMaps","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâµ : SeminormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ³ : SeminormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type u_4\ninstâœÂ¹ : SeminormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nf : ContinuousLinearMap (RingHom.id ğ•œ) E (ContinuousLinearMap (RingHom.id ğ•œ) F G)\nâŠ¢ IsBoundedBilinearMap ğ•œ fun x => (f x.1) x.2","decl":"theorem ContinuousLinearMap.isBoundedBilinearMap (f : E â†’L[ğ•œ] F â†’L[ğ•œ] G) :\n    IsBoundedBilinearMap ğ•œ fun x : E Ã— F => f x.1 x.2 :=\n  { add_left := f.map_addâ‚‚\n    smul_left := f.map_smulâ‚‚\n    add_right := fun x => (f x).map_add\n    smul_right := fun c x => (f x).map_smul c\n    bound :=\n      âŸ¨max â€–fâ€– 1, zero_lt_one.trans_le (le_max_right _ _), fun x y =>\n        (f.le_opNormâ‚‚ x y).trans <| by\n          apply_rules [mul_le_mul_of_nonneg_right, norm_nonneg, le_max_left] âŸ© }\n\n-- Porting note (https://github.com/leanprover-community/mathlib4/issues/11445): new definition\n"}
{"name":"IsBoundedBilinearMap.isBigO","module":"Mathlib.Analysis.Normed.Operator.BoundedLinearMaps","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâµ : SeminormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ³ : SeminormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type u_4\ninstâœÂ¹ : SeminormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nf : Prod E F â†’ G\nh : IsBoundedBilinearMap ğ•œ f\nâŠ¢ Asymptotics.IsBigO Top.top f fun p => HMul.hMul (Norm.norm p.1) (Norm.norm p.2)","decl":"protected theorem IsBoundedBilinearMap.isBigO (h : IsBoundedBilinearMap ğ•œ f) :\n    f =O[âŠ¤] fun p : E Ã— F => â€–p.1â€– * â€–p.2â€– :=\n  let âŸ¨C, _, hCâŸ© := h.bound\n  Asymptotics.IsBigO.of_bound C <|\n    Filter.Eventually.of_forall fun âŸ¨x, yâŸ© => by simpa [mul_assoc] using hC x y\n\n"}
{"name":"IsBoundedBilinearMap.isBigO_comp","module":"Mathlib.Analysis.Normed.Operator.BoundedLinearMaps","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâµ : SeminormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ³ : SeminormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type u_4\ninstâœÂ¹ : SeminormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nf : Prod E F â†’ G\nÎ± : Type u_5\nH : IsBoundedBilinearMap ğ•œ f\ng : Î± â†’ E\nh : Î± â†’ F\nl : Filter Î±\nâŠ¢ Asymptotics.IsBigO l (fun x => f { fst := g x, snd := h x }) fun x => HMul.hMul (Norm.norm (g x)) (Norm.norm (h x))","decl":"theorem IsBoundedBilinearMap.isBigO_comp {Î± : Type*} (H : IsBoundedBilinearMap ğ•œ f) {g : Î± â†’ E}\n    {h : Î± â†’ F} {l : Filter Î±} : (fun x => f (g x, h x)) =O[l] fun x => â€–g xâ€– * â€–h xâ€– :=\n  H.isBigO.comp_tendsto le_top\n\n"}
{"name":"IsBoundedBilinearMap.isBigO'","module":"Mathlib.Analysis.Normed.Operator.BoundedLinearMaps","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâµ : SeminormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ³ : SeminormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type u_4\ninstâœÂ¹ : SeminormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nf : Prod E F â†’ G\nh : IsBoundedBilinearMap ğ•œ f\nâŠ¢ Asymptotics.IsBigO Top.top f fun p => HMul.hMul (Norm.norm p) (Norm.norm p)","decl":"protected theorem IsBoundedBilinearMap.isBigO' (h : IsBoundedBilinearMap ğ•œ f) :\n    f =O[âŠ¤] fun p : E Ã— F => â€–pâ€– * â€–pâ€– :=\n  h.isBigO.trans <|\n    (@Asymptotics.isBigO_fst_prod' _ E F _ _ _ _).norm_norm.mul\n      (@Asymptotics.isBigO_snd_prod' _ E F _ _ _ _).norm_norm\n\n"}
{"name":"IsBoundedBilinearMap.map_sub_left","module":"Mathlib.Analysis.Normed.Operator.BoundedLinearMaps","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâµ : SeminormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ³ : SeminormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type u_4\ninstâœÂ¹ : SeminormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nf : Prod E F â†’ G\nh : IsBoundedBilinearMap ğ•œ f\nx y : E\nz : F\nâŠ¢ Eq (f { fst := HSub.hSub x y, snd := z }) (HSub.hSub (f { fst := x, snd := z }) (f { fst := y, snd := z }))","decl":"theorem IsBoundedBilinearMap.map_sub_left (h : IsBoundedBilinearMap ğ•œ f) {x y : E} {z : F} :\n    f (x - y, z) = f (x, z) - f (y, z) :=\n  (h.toContinuousLinearMap.flip z).map_sub x y\n\n"}
{"name":"IsBoundedBilinearMap.map_sub_right","module":"Mathlib.Analysis.Normed.Operator.BoundedLinearMaps","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâµ : SeminormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ³ : SeminormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type u_4\ninstâœÂ¹ : SeminormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nf : Prod E F â†’ G\nh : IsBoundedBilinearMap ğ•œ f\nx : E\ny z : F\nâŠ¢ Eq (f { fst := x, snd := HSub.hSub y z }) (HSub.hSub (f { fst := x, snd := y }) (f { fst := x, snd := z }))","decl":"theorem IsBoundedBilinearMap.map_sub_right (h : IsBoundedBilinearMap ğ•œ f) {x : E} {y z : F} :\n    f (x, y - z) = f (x, y) - f (x, z) :=\n  (h.toContinuousLinearMap x).map_sub y z\n\n"}
{"name":"IsBoundedBilinearMap.continuous","module":"Mathlib.Analysis.Normed.Operator.BoundedLinearMaps","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâµ : SeminormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ³ : SeminormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type u_4\ninstâœÂ¹ : SeminormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nf : Prod E F â†’ G\nh : IsBoundedBilinearMap ğ•œ f\nâŠ¢ Continuous f","decl":"open Asymptotics in\n/-- Useful to use together with `Continuous.compâ‚‚`. -/\ntheorem IsBoundedBilinearMap.continuous (h : IsBoundedBilinearMap ğ•œ f) : Continuous f := by\n  refine continuous_iff_continuousAt.2 fun x â†¦ tendsto_sub_nhds_zero_iff.1 ?_\n  suffices Tendsto (fun y : E Ã— F â†¦ f (y.1 - x.1, y.2) + f (x.1, y.2 - x.2)) (ğ“ x) (ğ“ (0 + 0)) by\n    simpa only [h.map_sub_left, h.map_sub_right, sub_add_sub_cancel, zero_add] using this\n  apply Tendsto.add\n  Â· rw [â† isLittleO_one_iff â„, â† one_mul 1]\n    refine h.isBigO_comp.trans_isLittleO ?_\n    refine (IsLittleO.norm_left ?_).mul_isBigO (IsBigO.norm_left ?_)\n    Â· exact (isLittleO_one_iff _).2 (tendsto_sub_nhds_zero_iff.2 (continuous_fst.tendsto _))\n    Â· exact (continuous_snd.tendsto _).isBigO_one â„\n  Â· refine Continuous.tendsto' ?_ _ _ (by rw [h.map_sub_right, sub_self])\n    exact ((h.toContinuousLinearMap x.1).continuous).comp (continuous_snd.sub continuous_const)\n\n"}
{"name":"IsBoundedBilinearMap.continuous_left","module":"Mathlib.Analysis.Normed.Operator.BoundedLinearMaps","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâµ : SeminormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ³ : SeminormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type u_4\ninstâœÂ¹ : SeminormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nf : Prod E F â†’ G\nh : IsBoundedBilinearMap ğ•œ f\neâ‚‚ : F\nâŠ¢ Continuous fun eâ‚ => f { fst := eâ‚, snd := eâ‚‚ }","decl":"theorem IsBoundedBilinearMap.continuous_left (h : IsBoundedBilinearMap ğ•œ f) {eâ‚‚ : F} :\n    Continuous fun eâ‚ => f (eâ‚, eâ‚‚) :=\n  h.continuous.comp (continuous_id.prod_mk continuous_const)\n\n"}
{"name":"IsBoundedBilinearMap.continuous_right","module":"Mathlib.Analysis.Normed.Operator.BoundedLinearMaps","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâµ : SeminormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ³ : SeminormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type u_4\ninstâœÂ¹ : SeminormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nf : Prod E F â†’ G\nh : IsBoundedBilinearMap ğ•œ f\neâ‚ : E\nâŠ¢ Continuous fun eâ‚‚ => f { fst := eâ‚, snd := eâ‚‚ }","decl":"theorem IsBoundedBilinearMap.continuous_right (h : IsBoundedBilinearMap ğ•œ f) {eâ‚ : E} :\n    Continuous fun eâ‚‚ => f (eâ‚, eâ‚‚) :=\n  h.continuous.comp (continuous_const.prod_mk continuous_id)\n\n"}
{"name":"ContinuousLinearMap.continuousâ‚‚","module":"Mathlib.Analysis.Normed.Operator.BoundedLinearMaps","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâµ : SeminormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ³ : SeminormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type u_4\ninstâœÂ¹ : SeminormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nf : ContinuousLinearMap (RingHom.id ğ•œ) E (ContinuousLinearMap (RingHom.id ğ•œ) F G)\nâŠ¢ Continuous (Function.uncurry fun x y => (f x) y)","decl":"/-- Useful to use together with `Continuous.compâ‚‚`. -/\ntheorem ContinuousLinearMap.continuousâ‚‚ (f : E â†’L[ğ•œ] F â†’L[ğ•œ] G) :\n    Continuous (Function.uncurry fun x y => f x y) :=\n  f.isBoundedBilinearMap.continuous\n\n"}
{"name":"IsBoundedBilinearMap.isBoundedLinearMap_left","module":"Mathlib.Analysis.Normed.Operator.BoundedLinearMaps","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâµ : SeminormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ³ : SeminormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type u_4\ninstâœÂ¹ : SeminormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nf : Prod E F â†’ G\nh : IsBoundedBilinearMap ğ•œ f\ny : F\nâŠ¢ IsBoundedLinearMap ğ•œ fun x => f { fst := x, snd := y }","decl":"theorem IsBoundedBilinearMap.isBoundedLinearMap_left (h : IsBoundedBilinearMap ğ•œ f) (y : F) :\n    IsBoundedLinearMap ğ•œ fun x => f (x, y) :=\n  (h.toContinuousLinearMap.flip y).isBoundedLinearMap\n\n"}
{"name":"IsBoundedBilinearMap.isBoundedLinearMap_right","module":"Mathlib.Analysis.Normed.Operator.BoundedLinearMaps","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâµ : SeminormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ³ : SeminormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type u_4\ninstâœÂ¹ : SeminormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nf : Prod E F â†’ G\nh : IsBoundedBilinearMap ğ•œ f\nx : E\nâŠ¢ IsBoundedLinearMap ğ•œ fun y => f { fst := x, snd := y }","decl":"theorem IsBoundedBilinearMap.isBoundedLinearMap_right (h : IsBoundedBilinearMap ğ•œ f) (x : E) :\n    IsBoundedLinearMap ğ•œ fun y => f (x, y) :=\n  (h.toContinuousLinearMap x).isBoundedLinearMap\n\n"}
{"name":"isBoundedBilinearMap_smul","module":"Mathlib.Analysis.Normed.Operator.BoundedLinearMaps","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nğ•œ' : Type u_5\ninstâœâµ : NormedField ğ•œ'\ninstâœâ´ : NormedAlgebra ğ•œ ğ•œ'\nE : Type u_6\ninstâœÂ³ : SeminormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedSpace ğ•œ' E\ninstâœ : IsScalarTower ğ•œ ğ•œ' E\nâŠ¢ IsBoundedBilinearMap ğ•œ fun p => HSMul.hSMul p.1 p.2","decl":"theorem isBoundedBilinearMap_smul {ğ•œ' : Type*} [NormedField ğ•œ'] [NormedAlgebra ğ•œ ğ•œ'] {E : Type*}\n    [SeminormedAddCommGroup E] [NormedSpace ğ•œ E] [NormedSpace ğ•œ' E] [IsScalarTower ğ•œ ğ•œ' E] :\n    IsBoundedBilinearMap ğ•œ fun p : ğ•œ' Ã— E => p.1 â€¢ p.2 :=\n  (lsmul ğ•œ ğ•œ' : ğ•œ' â†’L[ğ•œ] E â†’L[ğ•œ] E).isBoundedBilinearMap\n\n"}
{"name":"isBoundedBilinearMap_mul","module":"Mathlib.Analysis.Normed.Operator.BoundedLinearMaps","initialProofState":"ğ•œ : Type u_1\ninstâœ : NontriviallyNormedField ğ•œ\nâŠ¢ IsBoundedBilinearMap ğ•œ fun p => HMul.hMul p.1 p.2","decl":"theorem isBoundedBilinearMap_mul : IsBoundedBilinearMap ğ•œ fun p : ğ•œ Ã— ğ•œ => p.1 * p.2 := by\n  simp_rw [â† smul_eq_mul]\n  exact isBoundedBilinearMap_smul\n\n"}
{"name":"isBoundedBilinearMap_comp","module":"Mathlib.Analysis.Normed.Operator.BoundedLinearMaps","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâµ : SeminormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ³ : SeminormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type u_4\ninstâœÂ¹ : SeminormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nâŠ¢ IsBoundedBilinearMap ğ•œ fun p => p.1.comp p.2","decl":"theorem isBoundedBilinearMap_comp :\n    IsBoundedBilinearMap ğ•œ fun p : (F â†’L[ğ•œ] G) Ã— (E â†’L[ğ•œ] F) => p.1.comp p.2 :=\n  (compL ğ•œ E F G).isBoundedBilinearMap\n\n"}
{"name":"ContinuousLinearMap.isBoundedLinearMap_comp_left","module":"Mathlib.Analysis.Normed.Operator.BoundedLinearMaps","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâµ : SeminormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ³ : SeminormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type u_4\ninstâœÂ¹ : SeminormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\ng : ContinuousLinearMap (RingHom.id ğ•œ) F G\nâŠ¢ IsBoundedLinearMap ğ•œ fun f => g.comp f","decl":"theorem ContinuousLinearMap.isBoundedLinearMap_comp_left (g : F â†’L[ğ•œ] G) :\n    IsBoundedLinearMap ğ•œ fun f : E â†’L[ğ•œ] F => ContinuousLinearMap.comp g f :=\n  isBoundedBilinearMap_comp.isBoundedLinearMap_right _\n\n"}
{"name":"ContinuousLinearMap.isBoundedLinearMap_comp_right","module":"Mathlib.Analysis.Normed.Operator.BoundedLinearMaps","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâµ : SeminormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ³ : SeminormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type u_4\ninstâœÂ¹ : SeminormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nf : ContinuousLinearMap (RingHom.id ğ•œ) E F\nâŠ¢ IsBoundedLinearMap ğ•œ fun g => g.comp f","decl":"theorem ContinuousLinearMap.isBoundedLinearMap_comp_right (f : E â†’L[ğ•œ] F) :\n    IsBoundedLinearMap ğ•œ fun g : F â†’L[ğ•œ] G => ContinuousLinearMap.comp g f :=\n  isBoundedBilinearMap_comp.isBoundedLinearMap_left _\n\n"}
{"name":"isBoundedBilinearMap_apply","module":"Mathlib.Analysis.Normed.Operator.BoundedLinearMaps","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : SeminormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : SeminormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nâŠ¢ IsBoundedBilinearMap ğ•œ fun p => p.1 p.2","decl":"theorem isBoundedBilinearMap_apply : IsBoundedBilinearMap ğ•œ fun p : (E â†’L[ğ•œ] F) Ã— E => p.1 p.2 :=\n  (ContinuousLinearMap.flip (apply ğ•œ F : E â†’L[ğ•œ] (E â†’L[ğ•œ] F) â†’L[ğ•œ] F)).isBoundedBilinearMap\n\n"}
{"name":"isBoundedBilinearMap_smulRight","module":"Mathlib.Analysis.Normed.Operator.BoundedLinearMaps","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : SeminormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : SeminormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nâŠ¢ IsBoundedBilinearMap ğ•œ fun p => p.1.smulRight p.2","decl":"/-- The function `ContinuousLinearMap.smulRight`, associating to a continuous linear map\n`f : E â†’ ğ•œ` and a scalar `c : F` the tensor product `f âŠ— c` as a continuous linear map from `E` to\n`F`, is a bounded bilinear map. -/\ntheorem isBoundedBilinearMap_smulRight :\n    IsBoundedBilinearMap ğ•œ fun p =>\n      (ContinuousLinearMap.smulRight : (E â†’L[ğ•œ] ğ•œ) â†’ F â†’ E â†’L[ğ•œ] F) p.1 p.2 :=\n  (smulRightL ğ•œ E F).isBoundedBilinearMap\n\n"}
{"name":"isBoundedBilinearMap_compMultilinear","module":"Mathlib.Analysis.Normed.Operator.BoundedLinearMaps","initialProofState":"ğ•œ : Type u_1\ninstâœâ· : NontriviallyNormedField ğ•œ\nF : Type u_3\ninstâœâ¶ : SeminormedAddCommGroup F\ninstâœâµ : NormedSpace ğ•œ F\nG : Type u_4\ninstâœâ´ : SeminormedAddCommGroup G\ninstâœÂ³ : NormedSpace ğ•œ G\nÎ¹ : Type u_5\nE : Î¹ â†’ Type u_6\ninstâœÂ² : Fintype Î¹\ninstâœÂ¹ : (i : Î¹) â†’ NormedAddCommGroup (E i)\ninstâœ : (i : Î¹) â†’ NormedSpace ğ•œ (E i)\nâŠ¢ IsBoundedBilinearMap ğ•œ fun p => p.1.compContinuousMultilinearMap p.2","decl":"/-- The composition of a continuous linear map with a continuous multilinear map is a bounded\nbilinear operation. -/\ntheorem isBoundedBilinearMap_compMultilinear {Î¹ : Type*} {E : Î¹ â†’ Type*} [Fintype Î¹]\n    [âˆ€ i, NormedAddCommGroup (E i)] [âˆ€ i, NormedSpace ğ•œ (E i)] :\n    IsBoundedBilinearMap ğ•œ fun p : (F â†’L[ğ•œ] G) Ã— ContinuousMultilinearMap ğ•œ E F =>\n      p.1.compContinuousMultilinearMap p.2 :=\n  (compContinuousMultilinearMapL ğ•œ E F G).isBoundedBilinearMap\n\n"}
{"name":"IsBoundedBilinearMap.deriv_apply","module":"Mathlib.Analysis.Normed.Operator.BoundedLinearMaps","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâµ : SeminormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ³ : SeminormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type u_4\ninstâœÂ¹ : SeminormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nf : Prod E F â†’ G\nh : IsBoundedBilinearMap ğ•œ f\np q : Prod E F\nâŠ¢ Eq ((h.deriv p) q) (HAdd.hAdd (f { fst := p.1, snd := q.2 }) (f { fst := q.1, snd := p.2 }))","decl":"@[simp]\ntheorem IsBoundedBilinearMap.deriv_apply (h : IsBoundedBilinearMap ğ•œ f) (p q : E Ã— F) :\n    h.deriv p q = f (p.1, q.2) + f (q.1, p.2) :=\n  rfl\n\n"}
{"name":"ContinuousLinearMap.mulLeftRight_isBoundedBilinear","module":"Mathlib.Analysis.Normed.Operator.BoundedLinearMaps","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nğ•œ' : Type u_5\ninstâœÂ¹ : SeminormedRing ğ•œ'\ninstâœ : NormedAlgebra ğ•œ ğ•œ'\nâŠ¢ IsBoundedBilinearMap ğ•œ fun p => ((ContinuousLinearMap.mulLeftRight ğ•œ ğ•œ') p.1) p.2","decl":"/-- The function `ContinuousLinearMap.mulLeftRight : ğ•œ' Ã— ğ•œ' â†’ (ğ•œ' â†’L[ğ•œ] ğ•œ')` is a bounded\nbilinear map. -/\ntheorem ContinuousLinearMap.mulLeftRight_isBoundedBilinear (ğ•œ' : Type*) [SeminormedRing ğ•œ']\n    [NormedAlgebra ğ•œ ğ•œ'] :\n    IsBoundedBilinearMap ğ•œ fun p : ğ•œ' Ã— ğ•œ' => ContinuousLinearMap.mulLeftRight ğ•œ ğ•œ' p.1 p.2 :=\n  (ContinuousLinearMap.mulLeftRight ğ•œ ğ•œ').isBoundedBilinearMap\n\n"}
{"name":"IsBoundedBilinearMap.isBoundedLinearMap_deriv","module":"Mathlib.Analysis.Normed.Operator.BoundedLinearMaps","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâµ : SeminormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ³ : SeminormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type u_4\ninstâœÂ¹ : SeminormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nf : Prod E F â†’ G\nh : IsBoundedBilinearMap ğ•œ f\nâŠ¢ IsBoundedLinearMap ğ•œ fun p => h.deriv p","decl":"/-- Given a bounded bilinear map `f`, the map associating to a point `p` the derivative of `f` at\n`p` is itself a bounded linear map. -/\ntheorem IsBoundedBilinearMap.isBoundedLinearMap_deriv (h : IsBoundedBilinearMap ğ•œ f) :\n    IsBoundedLinearMap ğ•œ fun p : E Ã— F => h.deriv p :=\n  h.toContinuousLinearMap.derivâ‚‚.isBoundedLinearMap\n\n"}
{"name":"Continuous.clm_comp","module":"Mathlib.Analysis.Normed.Operator.BoundedLinearMaps","initialProofState":"ğ•œ : Type u_1\ninstâœâ· : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ¶ : SeminormedAddCommGroup E\ninstâœâµ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœâ´ : SeminormedAddCommGroup F\ninstâœÂ³ : NormedSpace ğ•œ F\nG : Type u_4\ninstâœÂ² : SeminormedAddCommGroup G\ninstâœÂ¹ : NormedSpace ğ•œ G\nX : Type u_5\ninstâœ : TopologicalSpace X\ng : X â†’ ContinuousLinearMap (RingHom.id ğ•œ) F G\nf : X â†’ ContinuousLinearMap (RingHom.id ğ•œ) E F\nhg : Continuous g\nhf : Continuous f\nâŠ¢ Continuous fun x => (g x).comp (f x)","decl":"@[continuity, fun_prop]\ntheorem Continuous.clm_comp {X} [TopologicalSpace X] {g : X â†’ F â†’L[ğ•œ] G} {f : X â†’ E â†’L[ğ•œ] F}\n    (hg : Continuous g) (hf : Continuous f) : Continuous fun x => (g x).comp (f x) :=\n  (compL ğ•œ E F G).continuousâ‚‚.compâ‚‚ hg hf\n\n"}
{"name":"ContinuousOn.clm_comp","module":"Mathlib.Analysis.Normed.Operator.BoundedLinearMaps","initialProofState":"ğ•œ : Type u_1\ninstâœâ· : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ¶ : SeminormedAddCommGroup E\ninstâœâµ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœâ´ : SeminormedAddCommGroup F\ninstâœÂ³ : NormedSpace ğ•œ F\nG : Type u_4\ninstâœÂ² : SeminormedAddCommGroup G\ninstâœÂ¹ : NormedSpace ğ•œ G\nX : Type u_5\ninstâœ : TopologicalSpace X\ng : X â†’ ContinuousLinearMap (RingHom.id ğ•œ) F G\nf : X â†’ ContinuousLinearMap (RingHom.id ğ•œ) E F\ns : Set X\nhg : ContinuousOn g s\nhf : ContinuousOn f s\nâŠ¢ ContinuousOn (fun x => (g x).comp (f x)) s","decl":"theorem ContinuousOn.clm_comp {X} [TopologicalSpace X] {g : X â†’ F â†’L[ğ•œ] G} {f : X â†’ E â†’L[ğ•œ] F}\n    {s : Set X} (hg : ContinuousOn g s) (hf : ContinuousOn f s) :\n    ContinuousOn (fun x => (g x).comp (f x)) s :=\n  (compL ğ•œ E F G).continuousâ‚‚.comp_continuousOn (hg.prod hf)\n\n"}
{"name":"Continuous.clm_apply","module":"Mathlib.Analysis.Normed.Operator.BoundedLinearMaps","initialProofState":"ğ•œ : Type u_1\ninstâœâµ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ´ : SeminormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ² : SeminormedAddCommGroup F\ninstâœÂ¹ : NormedSpace ğ•œ F\nX : Type u_5\ninstâœ : TopologicalSpace X\nf : X â†’ ContinuousLinearMap (RingHom.id ğ•œ) E F\ng : X â†’ E\nhf : Continuous f\nhg : Continuous g\nâŠ¢ Continuous fun x => (f x) (g x)","decl":"@[continuity, fun_prop]\ntheorem Continuous.clm_apply {X} [TopologicalSpace X] {f : X â†’ (E â†’L[ğ•œ] F)} {g : X â†’ E}\n    (hf : Continuous f) (hg : Continuous g) : Continuous (fun x â†¦ (f x) (g x)) :=\n  isBoundedBilinearMap_apply.continuous.compâ‚‚ hf hg\n\n"}
{"name":"ContinuousOn.clm_apply","module":"Mathlib.Analysis.Normed.Operator.BoundedLinearMaps","initialProofState":"ğ•œ : Type u_1\ninstâœâµ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ´ : SeminormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ² : SeminormedAddCommGroup F\ninstâœÂ¹ : NormedSpace ğ•œ F\nX : Type u_5\ninstâœ : TopologicalSpace X\nf : X â†’ ContinuousLinearMap (RingHom.id ğ•œ) E F\ng : X â†’ E\ns : Set X\nhf : ContinuousOn f s\nhg : ContinuousOn g s\nâŠ¢ ContinuousOn (fun x => (f x) (g x)) s","decl":"theorem ContinuousOn.clm_apply {X} [TopologicalSpace X] {f : X â†’ (E â†’L[ğ•œ] F)} {g : X â†’ E}\n    {s : Set X} (hf : ContinuousOn f s) (hg : ContinuousOn g s) :\n    ContinuousOn (fun x â†¦ f x (g x)) s :=\n  isBoundedBilinearMap_apply.continuous.comp_continuousOn (hf.prod hg)\n\n"}
{"name":"ContinuousLinearEquiv.isOpen","module":"Mathlib.Analysis.Normed.Operator.BoundedLinearMaps","initialProofState":"ğ•œ : Type u_1\ninstâœâµ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ² : SeminormedAddCommGroup F\ninstâœÂ¹ : NormedSpace ğ•œ F\ninstâœ : CompleteSpace E\nâŠ¢ IsOpen (Set.range ContinuousLinearEquiv.toContinuousLinearMap)","decl":"protected theorem isOpen [CompleteSpace E] : IsOpen (range ((â†‘) : (E â‰ƒL[ğ•œ] F) â†’ E â†’L[ğ•œ] F)) := by\n  rw [isOpen_iff_mem_nhds, forall_mem_range]\n  refine fun e => IsOpen.mem_nhds ?_ (mem_range_self _)\n  let O : (E â†’L[ğ•œ] F) â†’ E â†’L[ğ•œ] E := fun f => (e.symm : F â†’L[ğ•œ] E).comp f\n  have h_O : Continuous O := isBoundedBilinearMap_comp.continuous_right\n  convert show IsOpen (O â»Â¹' { x | IsUnit x }) from Units.isOpen.preimage h_O using 1\n  ext f'\n  constructor\n  Â· rintro âŸ¨e', rflâŸ©\n    exact âŸ¨(e'.trans e.symm).toUnit, rflâŸ©\n  Â· rintro âŸ¨w, hwâŸ©\n    use (unitsEquiv ğ•œ E w).trans e\n    ext x\n    simp [O, hw]\n\n"}
{"name":"ContinuousLinearEquiv.nhds","module":"Mathlib.Analysis.Normed.Operator.BoundedLinearMaps","initialProofState":"ğ•œ : Type u_1\ninstâœâµ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ² : SeminormedAddCommGroup F\ninstâœÂ¹ : NormedSpace ğ•œ F\ninstâœ : CompleteSpace E\ne : ContinuousLinearEquiv (RingHom.id ğ•œ) E F\nâŠ¢ Membership.mem (nhds â†‘e) (Set.range ContinuousLinearEquiv.toContinuousLinearMap)","decl":"protected theorem nhds [CompleteSpace E] (e : E â‰ƒL[ğ•œ] F) :\n    range ((â†‘) : (E â‰ƒL[ğ•œ] F) â†’ E â†’L[ğ•œ] F) âˆˆ ğ“ (e : E â†’L[ğ•œ] F) :=\n  IsOpen.mem_nhds ContinuousLinearEquiv.isOpen (by simp)\n\n"}
