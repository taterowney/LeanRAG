{"name":"ContinuousLinearMap.IsPositive.spectrumRestricts","module":"Mathlib.Analysis.InnerProductSpace.StarOrder","initialProofState":"𝕜 : Type u_1\nH : Type u_2\ninst✝⁵ : RCLike 𝕜\ninst✝⁴ : NormedAddCommGroup H\ninst✝³ : InnerProductSpace 𝕜 H\ninst✝² : CompleteSpace H\ninst✝¹ : Algebra Real (ContinuousLinearMap (RingHom.id 𝕜) H H)\ninst✝ : IsScalarTower Real 𝕜 (ContinuousLinearMap (RingHom.id 𝕜) H H)\nf : ContinuousLinearMap (RingHom.id 𝕜) H H\nhf : f.IsPositive\n⊢ SpectrumRestricts f ⇑ContinuousMap.realToNNReal","decl":"open scoped InnerProductSpace in\nlemma IsPositive.spectrumRestricts {f : H →L[𝕜] H} (hf : f.IsPositive) :\n    SpectrumRestricts f ContinuousMap.realToNNReal := by\n  rw [SpectrumRestricts.nnreal_iff]\n  intro c hc\n  contrapose! hc\n  rw [spectrum.not_mem_iff, IsUnit.sub_iff, sub_eq_add_neg, ← map_neg]\n  rw [← neg_pos] at hc\n  set c := -c\n  exact isUnit_of_forall_le_norm_inner_map _ (c := ⟨c, hc.le⟩) hc fun x ↦ calc\n    ‖x‖ ^ 2 * c = re ⟪algebraMap ℝ (H →L[𝕜] H) c x, x⟫_𝕜 := by\n      rw [Algebra.algebraMap_eq_smul_one, ← algebraMap_smul 𝕜 c (1 : (H →L[𝕜] H)), coe_smul',\n        Pi.smul_apply, one_apply, inner_smul_left, RCLike.algebraMap_eq_ofReal, conj_ofReal,\n        re_ofReal_mul, inner_self_eq_norm_sq, mul_comm]\n    _ ≤ re ⟪(f + (algebraMap ℝ (H →L[𝕜] H)) c) x, x⟫_𝕜 := by\n      simpa only [add_apply, inner_add_left, map_add, le_add_iff_nonneg_left]\n        using hf.inner_nonneg_left x\n    _ ≤ ‖⟪(f + (algebraMap ℝ (H →L[𝕜] H)) c) x, x⟫_𝕜‖ := RCLike.re_le_norm _\n\n"}
{"name":"ContinuousLinearMap.instNonnegSpectrumClassRealId","module":"Mathlib.Analysis.InnerProductSpace.StarOrder","initialProofState":"𝕜 : Type u_1\nH : Type u_2\ninst✝⁵ : RCLike 𝕜\ninst✝⁴ : NormedAddCommGroup H\ninst✝³ : InnerProductSpace 𝕜 H\ninst✝² : CompleteSpace H\ninst✝¹ : Algebra Real (ContinuousLinearMap (RingHom.id 𝕜) H H)\ninst✝ : IsScalarTower Real 𝕜 (ContinuousLinearMap (RingHom.id 𝕜) H H)\n⊢ NonnegSpectrumClass Real (ContinuousLinearMap (RingHom.id 𝕜) H H)","decl":"instance : NonnegSpectrumClass ℝ (H →L[𝕜] H) where\n  quasispectrum_nonneg_of_nonneg f hf :=\n    QuasispectrumRestricts.nnreal_iff.mp <| sub_zero f ▸ hf.spectrumRestricts\n\n"}
{"name":"ContinuousLinearMap.instStarOrderedRingRCLike","module":"Mathlib.Analysis.InnerProductSpace.StarOrder","initialProofState":"𝕜 : Type u_1\nH : Type u_2\ninst✝⁶ : RCLike 𝕜\ninst✝⁵ : NormedAddCommGroup H\ninst✝⁴ : InnerProductSpace 𝕜 H\ninst✝³ : CompleteSpace H\ninst✝² : Algebra Real (ContinuousLinearMap (RingHom.id 𝕜) H H)\ninst✝¹ : IsScalarTower Real 𝕜 (ContinuousLinearMap (RingHom.id 𝕜) H H)\ninst✝ : ContinuousFunctionalCalculus Real IsSelfAdjoint\n⊢ StarOrderedRing (ContinuousLinearMap (RingHom.id 𝕜) H H)","decl":"/-- Because this takes `ContinuousFunctionalCalculus ℝ IsSelfAdjoint` as an argument, and for\nthe moment we only have this for `𝕜 := ℂ`, this is not registered as an instance. -/\nlemma instStarOrderedRingRCLike\n    [ContinuousFunctionalCalculus ℝ (IsSelfAdjoint : (H →L[𝕜] H) → Prop)] :\n    StarOrderedRing (H →L[𝕜] H) where\n  le_iff f g := by\n    constructor\n    · intro h\n      rw [le_def] at h\n      obtain ⟨p, hp₁, -, hp₃⟩ :=\n        CFC.exists_sqrt_of_isSelfAdjoint_of_spectrumRestricts h.1 h.spectrumRestricts\n      refine ⟨p ^ 2, ?_, by symm; rwa [add_comm, ← eq_sub_iff_add_eq]⟩\n      exact AddSubmonoid.subset_closure ⟨p, by simp only [hp₁.star_eq, sq]⟩\n    · rintro ⟨p, hp, rfl⟩\n      rw [le_def, add_sub_cancel_left]\n      induction hp using AddSubmonoid.closure_induction with\n      | mem _ hf =>\n        obtain ⟨f, rfl⟩ := hf\n        simpa using ContinuousLinearMap.IsPositive.adjoint_conj isPositive_one f\n      | one => exact isPositive_zero\n      | mul f g _ _ hf hg => exact hf.add hg\n\n"}
{"name":"ContinuousLinearMap.instStarOrderedRing","module":"Mathlib.Analysis.InnerProductSpace.StarOrder","initialProofState":"H : Type u_3\ninst✝² : NormedAddCommGroup H\ninst✝¹ : InnerProductSpace Complex H\ninst✝ : CompleteSpace H\n⊢ StarOrderedRing (ContinuousLinearMap (RingHom.id Complex) H H)","decl":"instance instStarOrderedRing {H : Type*} [NormedAddCommGroup H]\n    [InnerProductSpace ℂ H] [CompleteSpace H] : StarOrderedRing (H →L[ℂ] H) :=\n  instStarOrderedRingRCLike\n\n"}
