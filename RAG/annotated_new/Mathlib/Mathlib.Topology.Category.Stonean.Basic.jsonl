{"name":"CompHaus.instExtremallyDisconnectedŒ±TopologicalSpaceToTopTrueOfProjective","module":"Mathlib.Topology.Category.Stonean.Basic","initialProofState":"X : CompHaus\ninst‚úù : CategoryTheory.Projective X\n‚ä¢ ExtremallyDisconnected ‚ÜëX.toTop","decl":"/-- `Projective` implies `ExtremallyDisconnected`. -/\ninstance (X : CompHaus.{u}) [Projective X] : ExtremallyDisconnected X := by\n  apply CompactT2.Projective.extremallyDisconnected\n  intro A B _ _ _ _ _ _ f g hf hg hsurj\n  let A' : CompHaus := CompHaus.of A\n  let B' : CompHaus := CompHaus.of B\n  let f' : X ‚ü∂ B' := ‚ü®f, hf‚ü©\n  let g' : A' ‚ü∂ B' := ‚ü®g,hg‚ü©\n  have : Epi g' := by\n    rw [CompHaus.epi_iff_surjective]\n    assumption\n  obtain ‚ü®h, hh‚ü© := Projective.factors f' g'\n  refine ‚ü®h, h.2, ?_‚ü©\n  ext t\n  apply_fun (fun e => e t) at hh\n  exact hh\n\n"}
{"name":"CompHaus.toStonean_toTop","module":"Mathlib.Topology.Category.Stonean.Basic","initialProofState":"X : CompHaus\ninst‚úù : CategoryTheory.Projective X\n‚ä¢ Eq X.toStonean.toTop X.toTop","decl":"/-- `Projective` implies `Stonean`. -/\n@[simps!]\ndef toStonean (X : CompHaus.{u}) [Projective X] :\n    Stonean where\n  toTop := X.toTop\n  prop := inferInstance\n\n"}
{"name":"Stonean.instHasPropExtremallyDisconnectedŒ±TopologicalSpace","module":"Mathlib.Topology.Category.Stonean.Basic","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : ExtremallyDisconnected X\n‚ä¢ CompHausLike.HasProp (fun Y => ExtremallyDisconnected ‚ÜëY) X","decl":"instance (X : Type*) [TopologicalSpace X]\n    [ExtremallyDisconnected X] : HasProp (fun Y ‚Ü¶ ExtremallyDisconnected Y) X :=\n  ‚ü®(inferInstance : ExtremallyDisconnected X)‚ü©\n\n"}
{"name":"Stonean.instExtremallyDisconnectedŒ±TopologicalSpaceToTop","module":"Mathlib.Topology.Category.Stonean.Basic","initialProofState":"X : Stonean\n‚ä¢ ExtremallyDisconnected ‚ÜëX.toTop","decl":"instance (X : Stonean.{u}) : ExtremallyDisconnected X := X.prop\n\n"}
{"name":"Stonean.instExtremallyDisconnectedObjForget","module":"Mathlib.Topology.Category.Stonean.Basic","initialProofState":"X : Stonean\n‚ä¢ ExtremallyDisconnected ((CategoryTheory.forget Stonean).obj X)","decl":"instance (X : Stonean.{u}) : ExtremallyDisconnected ((forget _).obj X) := X.prop\n\n"}
{"name":"Stonean.instTotallyDisconnectedSpaceObjForget","module":"Mathlib.Topology.Category.Stonean.Basic","initialProofState":"X : Stonean\n‚ä¢ TotallyDisconnectedSpace ((CategoryTheory.forget Stonean).obj X)","decl":"instance (X : Stonean.{u}) : TotallyDisconnectedSpace ((forget _).obj X) :=\n  show TotallyDisconnectedSpace X from inferInstance\n\n"}
{"name":"Stonean.epi_iff_surjective","module":"Mathlib.Topology.Category.Stonean.Basic","initialProofState":"X Y : Stonean\nf : Quiver.Hom X Y\n‚ä¢ Iff (CategoryTheory.Epi f) (Function.Surjective ‚áëf)","decl":"/--\nA morphism in `Stonean` is an epi iff it is surjective.\n-/\nlemma epi_iff_surjective {X Y : Stonean} (f : X ‚ü∂ Y) :\n    Epi f ‚Üî Function.Surjective f := by\n  refine ‚ü®?_, ConcreteCategory.epi_of_surjective _‚ü©\n  dsimp [Function.Surjective]\n  intro h y\n  by_contra! hy\n  let C := Set.range f\n  have hC : IsClosed C := (isCompact_range f.continuous).isClosed\n  let U := C·∂ú\n  have hUy : U ‚àà ùìù y := by\n    simp only [U, C, Set.mem_range, hy, exists_false, not_false_eq_true, hC.compl_mem_nhds]\n  obtain ‚ü®V, hV, hyV, hVU‚ü© := isTopologicalBasis_isClopen.mem_nhds_iff.mp hUy\n  classical\n  let g : Y ‚ü∂ mkFinite (ULift (Fin 2)) :=\n    ‚ü®(LocallyConstant.ofIsClopen hV).map ULift.up, LocallyConstant.continuous _‚ü©\n  let h : Y ‚ü∂ mkFinite (ULift (Fin 2)) := ‚ü®fun _ => ‚ü®1‚ü©, continuous_const‚ü©\n  have H : h = g := by\n    rw [‚Üê cancel_epi f]\n    ext x\n    apply ULift.ext -- why is `ext` not doing this automatically?\n    change 1 = ite _ _ _ -- why is `dsimp` not getting me here?\n    rw [if_neg]\n    refine mt (hVU ¬∑) ?_ -- what would be an idiomatic tactic for this step?\n    simpa only [U, Set.mem_compl_iff, Set.mem_range, not_exists, not_forall, not_not]\n      using exists_apply_eq_apply f x\n  apply_fun fun e => (e y).down at H\n  change 1 = ite _ _ _ at H -- why is `dsimp at H` not getting me here?\n  rw [if_pos hyV] at H\n  exact one_ne_zero H\n\n"}
{"name":"Stonean.instProjectiveCompHausCompHaus","module":"Mathlib.Topology.Category.Stonean.Basic","initialProofState":"X : Stonean\n‚ä¢ CategoryTheory.Projective (Stonean.toCompHaus.obj X)","decl":"/-- Every Stonean space is projective in `CompHaus` -/\ninstance instProjectiveCompHausCompHaus (X : Stonean) : Projective (toCompHaus.obj X) where\n  factors := by\n    intro B C œÜ f _\n    haveI : ExtremallyDisconnected (toCompHaus.obj X).toTop := X.prop\n    have hf : Function.Surjective f := by rwa [‚Üê CompHaus.epi_iff_surjective]\n    obtain ‚ü®f', h‚ü© := CompactT2.ExtremallyDisconnected.projective œÜ.continuous f.continuous hf\n    use ‚ü®f', h.left‚ü©\n    ext\n    exact congr_fun h.right _\n\n"}
{"name":"Stonean.instProjectiveProfiniteObjToProfinite","module":"Mathlib.Topology.Category.Stonean.Basic","initialProofState":"X : Stonean\n‚ä¢ CategoryTheory.Projective (Stonean.toProfinite.obj X)","decl":"/-- Every Stonean space is projective in `Profinite` -/\ninstance (X : Stonean) : Projective (toProfinite.obj X) where\n  factors := by\n    intro B C œÜ f _\n    haveI : ExtremallyDisconnected (toProfinite.obj X) := X.prop\n    have hf : Function.Surjective f := by rwa [‚Üê Profinite.epi_iff_surjective]\n    obtain ‚ü®f', h‚ü© := CompactT2.ExtremallyDisconnected.projective œÜ.continuous f.continuous hf\n    use ‚ü®f', h.left‚ü©\n    ext\n    exact congr_fun h.right _\n\n"}
{"name":"Stonean.instProjective","module":"Mathlib.Topology.Category.Stonean.Basic","initialProofState":"X : Stonean\n‚ä¢ CategoryTheory.Projective X","decl":"/-- Every Stonean space is projective in `Stonean`. -/\ninstance (X : Stonean) : Projective X where\n  factors := by\n    intro B C œÜ f _\n    haveI : ExtremallyDisconnected X.toTop := X.prop\n    have hf : Function.Surjective f := by rwa [‚Üê Stonean.epi_iff_surjective]\n    obtain ‚ü®f', h‚ü© := CompactT2.ExtremallyDisconnected.projective œÜ.continuous f.continuous hf\n    use ‚ü®f', h.left‚ü©\n    ext\n    exact congr_fun h.right _\n\n"}
{"name":"CompHaus.presentation.epi_œÄ","module":"Mathlib.Topology.Category.Stonean.Basic","initialProofState":"X : CompHaus\n‚ä¢ CategoryTheory.Epi (CompHaus.presentation.œÄ X)","decl":"/-- The morphism from `presentation X` to `X` is an epimorphism. -/\nnoncomputable\ninstance presentation.epi_œÄ (X : CompHaus) : Epi (œÄ X) :=\n  (projectivePresentation X).epi\n\n"}
{"name":"CompHaus.lift_lifts","module":"Mathlib.Topology.Category.Stonean.Basic","initialProofState":"X Y : CompHaus\nZ : Stonean\ne : Quiver.Hom Z.compHaus Y\nf : Quiver.Hom X Y\ninst‚úù : CategoryTheory.Epi f\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CompHaus.lift e f) f) e","decl":"@[simp, reassoc]\nlemma lift_lifts {X Y : CompHaus} {Z : Stonean} (e : Z.compHaus ‚ü∂ Y) (f : X ‚ü∂ Y) [Epi f] :\n    lift e f ‚â´ f = e := by simp [lift]\n\n"}
{"name":"CompHaus.lift_lifts_assoc","module":"Mathlib.Topology.Category.Stonean.Basic","initialProofState":"X Y : CompHaus\nZ‚úù : Stonean\ne : Quiver.Hom Z‚úù.compHaus Y\nf : Quiver.Hom X Y\ninst‚úù : CategoryTheory.Epi f\nZ : CompHaus\nh : Quiver.Hom Y Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CompHaus.lift e f) (CategoryTheory.CategoryStruct.comp f h)) (CategoryTheory.CategoryStruct.comp e h)","decl":"@[simp, reassoc]\nlemma lift_lifts {X Y : CompHaus} {Z : Stonean} (e : Z.compHaus ‚ü∂ Y) (f : X ‚ü∂ Y) [Epi f] :\n    lift e f ‚â´ f = e := by simp [lift]\n\n"}
{"name":"CompHaus.Gleason","module":"Mathlib.Topology.Category.Stonean.Basic","initialProofState":"X : CompHaus\n‚ä¢ Iff (CategoryTheory.Projective X) (ExtremallyDisconnected ‚ÜëX.toTop)","decl":"lemma Gleason (X : CompHaus.{u}) :\n    Projective X ‚Üî ExtremallyDisconnected X := by\n  constructor\n  ¬∑ intro h\n    show ExtremallyDisconnected X.toStonean\n    infer_instance\n  ¬∑ intro h\n    let X' : Stonean := ‚ü®X.toTop, inferInstance‚ü©\n    show Projective X'.compHaus\n    apply Stonean.instProjectiveCompHausCompHaus\n\n"}
{"name":"Profinite.presentation.epi_œÄ","module":"Mathlib.Topology.Category.Stonean.Basic","initialProofState":"X : Profinite\n‚ä¢ CategoryTheory.Epi (Profinite.presentation.œÄ X)","decl":"/-- The morphism from `presentation X` to `X` is an epimorphism. -/\nnoncomputable\ninstance presentation.epi_œÄ (X : Profinite) : Epi (œÄ X) := by\n  have := (profiniteToCompHaus.obj X).projectivePresentation.epi\n  rw [CompHaus.epi_iff_surjective] at this\n  rw [epi_iff_surjective]\n  exact this\n\n"}
{"name":"Profinite.lift_lifts_assoc","module":"Mathlib.Topology.Category.Stonean.Basic","initialProofState":"X Y : Profinite\nZ‚úù : Stonean\ne : Quiver.Hom (Stonean.toProfinite.obj Z‚úù) Y\nf : Quiver.Hom X Y\ninst‚úù : CategoryTheory.Epi f\nZ : Profinite\nh : Quiver.Hom Y Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (Profinite.lift e f) (CategoryTheory.CategoryStruct.comp f h)) (CategoryTheory.CategoryStruct.comp e h)","decl":"@[simp, reassoc]\nlemma lift_lifts {X Y : Profinite} {Z : Stonean} (e : Stonean.toProfinite.obj Z ‚ü∂ Y) (f : X ‚ü∂ Y)\n    [Epi f] : lift e f ‚â´ f = e := by simp [lift]\n\n"}
{"name":"Profinite.lift_lifts","module":"Mathlib.Topology.Category.Stonean.Basic","initialProofState":"X Y : Profinite\nZ : Stonean\ne : Quiver.Hom (Stonean.toProfinite.obj Z) Y\nf : Quiver.Hom X Y\ninst‚úù : CategoryTheory.Epi f\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (Profinite.lift e f) f) e","decl":"@[simp, reassoc]\nlemma lift_lifts {X Y : Profinite} {Z : Stonean} (e : Stonean.toProfinite.obj Z ‚ü∂ Y) (f : X ‚ü∂ Y)\n    [Epi f] : lift e f ‚â´ f = e := by simp [lift]\n\n"}
{"name":"Profinite.projective_of_extrDisc","module":"Mathlib.Topology.Category.Stonean.Basic","initialProofState":"X : Profinite\nhX : ExtremallyDisconnected ‚ÜëX.toTop\n‚ä¢ CategoryTheory.Projective X","decl":"lemma projective_of_extrDisc {X : Profinite.{u}} (hX : ExtremallyDisconnected X) :\n    Projective X := by\n  show Projective (Stonean.toProfinite.obj ‚ü®X.toTop, inferInstance‚ü©)\n  exact inferInstance\n\n"}
