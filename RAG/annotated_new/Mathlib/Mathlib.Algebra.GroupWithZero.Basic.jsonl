{"name":"left_ne_zero_of_mul","module":"Mathlib.Algebra.GroupWithZero.Basic","initialProofState":"M₀ : Type u_1\ninst✝ : MulZeroClass M₀\na b : M₀\na✝ : Ne (HMul.hMul a b) 0\n⊢ Ne a 0","decl":"theorem left_ne_zero_of_mul : a * b ≠ 0 → a ≠ 0 :=\n  mt fun h => mul_eq_zero_of_left h b\n\n"}
{"name":"right_ne_zero_of_mul","module":"Mathlib.Algebra.GroupWithZero.Basic","initialProofState":"M₀ : Type u_1\ninst✝ : MulZeroClass M₀\na b : M₀\na✝ : Ne (HMul.hMul a b) 0\n⊢ Ne b 0","decl":"theorem right_ne_zero_of_mul : a * b ≠ 0 → b ≠ 0 :=\n  mt (mul_eq_zero_of_right a)\n\n"}
{"name":"ne_zero_and_ne_zero_of_mul","module":"Mathlib.Algebra.GroupWithZero.Basic","initialProofState":"M₀ : Type u_1\ninst✝ : MulZeroClass M₀\na b : M₀\nh : Ne (HMul.hMul a b) 0\n⊢ And (Ne a 0) (Ne b 0)","decl":"theorem ne_zero_and_ne_zero_of_mul (h : a * b ≠ 0) : a ≠ 0 ∧ b ≠ 0 :=\n  ⟨left_ne_zero_of_mul h, right_ne_zero_of_mul h⟩\n\n"}
{"name":"mul_eq_zero_of_ne_zero_imp_eq_zero","module":"Mathlib.Algebra.GroupWithZero.Basic","initialProofState":"M₀ : Type u_1\ninst✝ : MulZeroClass M₀\na b : M₀\nh : Ne a 0 → Eq b 0\n⊢ Eq (HMul.hMul a b) 0","decl":"theorem mul_eq_zero_of_ne_zero_imp_eq_zero {a b : M₀} (h : a ≠ 0 → b = 0) : a * b = 0 := by\n  have : Decidable (a = 0) := Classical.propDecidable (a = 0)\n  exact if ha : a = 0 then by rw [ha, zero_mul] else by rw [h ha, mul_zero]\n\n"}
{"name":"zero_mul_eq_const","module":"Mathlib.Algebra.GroupWithZero.Basic","initialProofState":"M₀ : Type u_1\ninst✝ : MulZeroClass M₀\n⊢ Eq (fun x => HMul.hMul 0 x) (Function.const M₀ 0)","decl":"/-- To match `one_mul_eq_id`. -/\ntheorem zero_mul_eq_const : ((0 : M₀) * ·) = Function.const _ 0 :=\n  funext zero_mul\n\n"}
{"name":"mul_zero_eq_const","module":"Mathlib.Algebra.GroupWithZero.Basic","initialProofState":"M₀ : Type u_1\ninst✝ : MulZeroClass M₀\n⊢ Eq (fun x => HMul.hMul x 0) (Function.const M₀ 0)","decl":"/-- To match `mul_one_eq_id`. -/\ntheorem mul_zero_eq_const : (· * (0 : M₀)) = Function.const _ 0 :=\n  funext mul_zero\n\n"}
{"name":"eq_zero_of_mul_self_eq_zero","module":"Mathlib.Algebra.GroupWithZero.Basic","initialProofState":"M₀ : Type u_1\ninst✝² : Mul M₀\ninst✝¹ : Zero M₀\ninst✝ : NoZeroDivisors M₀\na : M₀\nh : Eq (HMul.hMul a a) 0\n⊢ Eq a 0","decl":"theorem eq_zero_of_mul_self_eq_zero (h : a * a = 0) : a = 0 :=\n  (eq_zero_or_eq_zero_of_mul_eq_zero h).elim id id\n\n"}
{"name":"mul_ne_zero","module":"Mathlib.Algebra.GroupWithZero.Basic","initialProofState":"M₀ : Type u_1\ninst✝² : Mul M₀\ninst✝¹ : Zero M₀\ninst✝ : NoZeroDivisors M₀\na b : M₀\nha : Ne a 0\nhb : Ne b 0\n⊢ Ne (HMul.hMul a b) 0","decl":"@[field_simps]\ntheorem mul_ne_zero (ha : a ≠ 0) (hb : b ≠ 0) : a * b ≠ 0 :=\n  mt eq_zero_or_eq_zero_of_mul_eq_zero <| not_or.mpr ⟨ha, hb⟩\n\n"}
{"name":"NeZero.mul","module":"Mathlib.Algebra.GroupWithZero.Basic","initialProofState":"M₀ : Type u_1\ninst✝⁴ : Zero M₀\ninst✝³ : Mul M₀\ninst✝² : NoZeroDivisors M₀\nx y : M₀\ninst✝¹ : NeZero x\ninst✝ : NeZero y\n⊢ NeZero (HMul.hMul x y)","decl":"instance mul [Zero M₀] [Mul M₀] [NoZeroDivisors M₀] {x y : M₀} [NeZero x] [NeZero y] :\n    NeZero (x * y) :=\n  ⟨mul_ne_zero out out⟩\n\n"}
{"name":"eq_zero_of_zero_eq_one","module":"Mathlib.Algebra.GroupWithZero.Basic","initialProofState":"M₀ : Type u_1\ninst✝ : MulZeroOneClass M₀\nh : Eq 0 1\na : M₀\n⊢ Eq a 0","decl":"/-- In a monoid with zero, if zero equals one, then zero is the only element. -/\ntheorem eq_zero_of_zero_eq_one (h : (0 : M₀) = 1) (a : M₀) : a = 0 := by\n  rw [← mul_one a, ← h, mul_zero]\n\n"}
{"name":"subsingleton_iff_zero_eq_one","module":"Mathlib.Algebra.GroupWithZero.Basic","initialProofState":"M₀ : Type u_1\ninst✝ : MulZeroOneClass M₀\n⊢ Iff (Eq 0 1) (Subsingleton M₀)","decl":"/-- In a monoid with zero, zero equals one if and only if all elements of that semiring\nare equal. -/\ntheorem subsingleton_iff_zero_eq_one : (0 : M₀) = 1 ↔ Subsingleton M₀ :=\n  ⟨fun h => haveI := uniqueOfZeroEqOne h; inferInstance, fun h => @Subsingleton.elim _ h _ _⟩\n\n"}
{"name":"subsingleton_of_zero_eq_one","module":"Mathlib.Algebra.GroupWithZero.Basic","initialProofState":"M₀ : Type u_1\ninst✝ : MulZeroOneClass M₀\na✝ : Eq 0 1\n⊢ Subsingleton M₀","decl":"alias ⟨subsingleton_of_zero_eq_one, _⟩ := subsingleton_iff_zero_eq_one\n\n"}
{"name":"eq_of_zero_eq_one","module":"Mathlib.Algebra.GroupWithZero.Basic","initialProofState":"M₀ : Type u_1\ninst✝ : MulZeroOneClass M₀\nh : Eq 0 1\na b : M₀\n⊢ Eq a b","decl":"theorem eq_of_zero_eq_one (h : (0 : M₀) = 1) (a b : M₀) : a = b :=\n  @Subsingleton.elim _ (subsingleton_of_zero_eq_one h) a b\n\n"}
{"name":"zero_ne_one_or_forall_eq_0","module":"Mathlib.Algebra.GroupWithZero.Basic","initialProofState":"M₀ : Type u_1\ninst✝ : MulZeroOneClass M₀\n⊢ Or (Ne 0 1) (∀ (a : M₀), Eq a 0)","decl":"/-- In a monoid with zero, either zero and one are nonequal, or zero is the only element. -/\ntheorem zero_ne_one_or_forall_eq_0 : (0 : M₀) ≠ 1 ∨ ∀ a : M₀, a = 0 :=\n  not_or_of_imp eq_zero_of_zero_eq_one\n\n"}
{"name":"left_ne_zero_of_mul_eq_one","module":"Mathlib.Algebra.GroupWithZero.Basic","initialProofState":"M₀ : Type u_1\ninst✝¹ : MulZeroOneClass M₀\ninst✝ : Nontrivial M₀\na b : M₀\nh : Eq (HMul.hMul a b) 1\n⊢ Ne a 0","decl":"theorem left_ne_zero_of_mul_eq_one (h : a * b = 1) : a ≠ 0 :=\n  left_ne_zero_of_mul <| ne_zero_of_eq_one h\n\n"}
{"name":"right_ne_zero_of_mul_eq_one","module":"Mathlib.Algebra.GroupWithZero.Basic","initialProofState":"M₀ : Type u_1\ninst✝¹ : MulZeroOneClass M₀\ninst✝ : Nontrivial M₀\na b : M₀\nh : Eq (HMul.hMul a b) 1\n⊢ Ne b 0","decl":"theorem right_ne_zero_of_mul_eq_one (h : a * b = 1) : b ≠ 0 :=\n  right_ne_zero_of_mul <| ne_zero_of_eq_one h\n\n"}
{"name":"zero_pow","module":"Mathlib.Algebra.GroupWithZero.Basic","initialProofState":"M₀ : Type u_1\ninst✝ : MonoidWithZero M₀\nn : Nat\na✝ : Ne n 0\n⊢ Eq (HPow.hPow 0 n) 0","decl":"@[simp] lemma zero_pow : ∀ {n : ℕ}, n ≠ 0 → (0 : M₀) ^ n = 0\n  | n + 1, _ => by rw [pow_succ, mul_zero]\n\n"}
{"name":"zero_pow_eq","module":"Mathlib.Algebra.GroupWithZero.Basic","initialProofState":"M₀ : Type u_1\ninst✝ : MonoidWithZero M₀\nn : Nat\n⊢ Eq (HPow.hPow 0 n) (ite (Eq n 0) 1 0)","decl":"lemma zero_pow_eq (n : ℕ) : (0 : M₀) ^ n = if n = 0 then 1 else 0 := by\n  split_ifs with h\n  · rw [h, pow_zero]\n  · rw [zero_pow h]\n\n"}
{"name":"zero_pow_eq_one₀","module":"Mathlib.Algebra.GroupWithZero.Basic","initialProofState":"M₀ : Type u_1\ninst✝¹ : MonoidWithZero M₀\nn : Nat\ninst✝ : Nontrivial M₀\n⊢ Iff (Eq (HPow.hPow 0 n) 1) (Eq n 0)","decl":"lemma zero_pow_eq_one₀ [Nontrivial M₀] : (0 : M₀) ^ n = 1 ↔ n = 0 := by\n  rw [zero_pow_eq, one_ne_zero.ite_eq_left_iff]\n\n"}
{"name":"pow_eq_zero_of_le","module":"Mathlib.Algebra.GroupWithZero.Basic","initialProofState":"M₀ : Type u_1\ninst✝ : MonoidWithZero M₀\na : M₀\nm n : Nat\na✝¹ : LE.le m n\na✝ : Eq (HPow.hPow a m) 0\n⊢ Eq (HPow.hPow a n) 0","decl":"lemma pow_eq_zero_of_le : ∀ {m n}, m ≤ n → a ^ m = 0 → a ^ n = 0\n  | _, _, Nat.le.refl, ha => ha\n  | _, _, Nat.le.step hmn, ha => by rw [pow_succ, pow_eq_zero_of_le hmn ha, zero_mul]\n\n"}
{"name":"ne_zero_pow","module":"Mathlib.Algebra.GroupWithZero.Basic","initialProofState":"M₀ : Type u_1\ninst✝ : MonoidWithZero M₀\na : M₀\nn : Nat\nhn : Ne n 0\nha : Ne (HPow.hPow a n) 0\n⊢ Ne a 0","decl":"lemma ne_zero_pow (hn : n ≠ 0) (ha : a ^ n ≠ 0) : a ≠ 0 := by rintro rfl; exact ha <| zero_pow hn\n\n"}
{"name":"zero_pow_eq_zero","module":"Mathlib.Algebra.GroupWithZero.Basic","initialProofState":"M₀ : Type u_1\ninst✝¹ : MonoidWithZero M₀\nn : Nat\ninst✝ : Nontrivial M₀\n⊢ Iff (Eq (HPow.hPow 0 n) 0) (Ne n 0)","decl":"@[simp]\nlemma zero_pow_eq_zero [Nontrivial M₀] : (0 : M₀) ^ n = 0 ↔ n ≠ 0 :=\n  ⟨by rintro h rfl; simp at h, zero_pow⟩\n\n"}
{"name":"pow_mul_eq_zero_of_le","module":"Mathlib.Algebra.GroupWithZero.Basic","initialProofState":"M₀ : Type u_1\ninst✝ : MonoidWithZero M₀\na b : M₀\nm n : Nat\nhmn : LE.le m n\nh : Eq (HMul.hMul (HPow.hPow a m) b) 0\n⊢ Eq (HMul.hMul (HPow.hPow a n) b) 0","decl":"lemma pow_mul_eq_zero_of_le {a b : M₀} {m n : ℕ} (hmn : m ≤ n)\n    (h : a ^ m * b = 0) : a ^ n * b = 0 := by\n  rw [show n = n - m + m by omega, pow_add, mul_assoc, h]\n  simp\n\n"}
{"name":"pow_eq_zero","module":"Mathlib.Algebra.GroupWithZero.Basic","initialProofState":"M₀ : Type u_1\ninst✝¹ : MonoidWithZero M₀\na : M₀\ninst✝ : NoZeroDivisors M₀\nn : Nat\na✝ : Eq (HPow.hPow a n) 0\n⊢ Eq a 0","decl":"lemma pow_eq_zero : ∀ {n}, a ^ n = 0 → a = 0\n  | 0, ha => by simpa using congr_arg (a * ·) ha\n  | n + 1, ha => by rw [pow_succ, mul_eq_zero] at ha; exact ha.elim pow_eq_zero id\n\n"}
{"name":"pow_eq_zero_iff","module":"Mathlib.Algebra.GroupWithZero.Basic","initialProofState":"M₀ : Type u_1\ninst✝¹ : MonoidWithZero M₀\na : M₀\nn : Nat\ninst✝ : NoZeroDivisors M₀\nhn : Ne n 0\n⊢ Iff (Eq (HPow.hPow a n) 0) (Eq a 0)","decl":"@[simp] lemma pow_eq_zero_iff (hn : n ≠ 0) : a ^ n = 0 ↔ a = 0 :=\n  ⟨pow_eq_zero, by rintro rfl; exact zero_pow hn⟩\n\n"}
{"name":"pow_ne_zero_iff","module":"Mathlib.Algebra.GroupWithZero.Basic","initialProofState":"M₀ : Type u_1\ninst✝¹ : MonoidWithZero M₀\na : M₀\nn : Nat\ninst✝ : NoZeroDivisors M₀\nhn : Ne n 0\n⊢ Iff (Ne (HPow.hPow a n) 0) (Ne a 0)","decl":"lemma pow_ne_zero_iff (hn : n ≠ 0) : a ^ n ≠ 0 ↔ a ≠ 0 := (pow_eq_zero_iff hn).not\n\n"}
{"name":"pow_ne_zero","module":"Mathlib.Algebra.GroupWithZero.Basic","initialProofState":"M₀ : Type u_1\ninst✝¹ : MonoidWithZero M₀\na : M₀\ninst✝ : NoZeroDivisors M₀\nn : Nat\nh : Ne a 0\n⊢ Ne (HPow.hPow a n) 0","decl":"@[field_simps]\nlemma pow_ne_zero (n : ℕ) (h : a ≠ 0) : a ^ n ≠ 0 := mt pow_eq_zero h\n\n"}
{"name":"NeZero.pow","module":"Mathlib.Algebra.GroupWithZero.Basic","initialProofState":"M₀ : Type u_1\ninst✝² : MonoidWithZero M₀\na : M₀\nn : Nat\ninst✝¹ : NoZeroDivisors M₀\ninst✝ : NeZero a\n⊢ NeZero (HPow.hPow a n)","decl":"instance NeZero.pow [NeZero a] : NeZero (a ^ n) := ⟨pow_ne_zero n NeZero.out⟩\n\n"}
{"name":"sq_eq_zero_iff","module":"Mathlib.Algebra.GroupWithZero.Basic","initialProofState":"M₀ : Type u_1\ninst✝¹ : MonoidWithZero M₀\na : M₀\ninst✝ : NoZeroDivisors M₀\n⊢ Iff (Eq (HPow.hPow a 2) 0) (Eq a 0)","decl":"lemma sq_eq_zero_iff : a ^ 2 = 0 ↔ a = 0 := pow_eq_zero_iff two_ne_zero\n\n"}
{"name":"pow_eq_zero_iff'","module":"Mathlib.Algebra.GroupWithZero.Basic","initialProofState":"M₀ : Type u_1\ninst✝² : MonoidWithZero M₀\na : M₀\nn : Nat\ninst✝¹ : NoZeroDivisors M₀\ninst✝ : Nontrivial M₀\n⊢ Iff (Eq (HPow.hPow a n) 0) (And (Eq a 0) (Ne n 0))","decl":"@[simp] lemma pow_eq_zero_iff' [Nontrivial M₀] : a ^ n = 0 ↔ a = 0 ∧ n ≠ 0 := by\n  obtain rfl | hn := eq_or_ne n 0 <;> simp [*]\n\n"}
{"name":"CancelMonoidWithZero.to_noZeroDivisors","module":"Mathlib.Algebra.GroupWithZero.Basic","initialProofState":"M₀ : Type u_1\ninst✝ : CancelMonoidWithZero M₀\n⊢ NoZeroDivisors M₀","decl":"instance (priority := 10) CancelMonoidWithZero.to_noZeroDivisors : NoZeroDivisors M₀ :=\n  ⟨fun ab0 => or_iff_not_imp_left.mpr fun ha => mul_left_cancel₀ ha <|\n    ab0.trans (mul_zero _).symm⟩\n\n"}
{"name":"mul_eq_mul_right_iff","module":"Mathlib.Algebra.GroupWithZero.Basic","initialProofState":"M₀ : Type u_1\ninst✝ : CancelMonoidWithZero M₀\na b c : M₀\n⊢ Iff (Eq (HMul.hMul a c) (HMul.hMul b c)) (Or (Eq a b) (Eq c 0))","decl":"@[simp]\ntheorem mul_eq_mul_right_iff : a * c = b * c ↔ a = b ∨ c = 0 := by\n  by_cases hc : c = 0 <;> [simp only [hc, mul_zero, or_true]; simp [mul_left_inj', hc]]\n\n"}
{"name":"mul_eq_mul_left_iff","module":"Mathlib.Algebra.GroupWithZero.Basic","initialProofState":"M₀ : Type u_1\ninst✝ : CancelMonoidWithZero M₀\na b c : M₀\n⊢ Iff (Eq (HMul.hMul a b) (HMul.hMul a c)) (Or (Eq b c) (Eq a 0))","decl":"@[simp]\ntheorem mul_eq_mul_left_iff : a * b = a * c ↔ b = c ∨ a = 0 := by\n  by_cases ha : a = 0 <;> [simp only [ha, zero_mul, or_true]; simp [mul_right_inj', ha]]\n\n"}
{"name":"mul_right_eq_self₀","module":"Mathlib.Algebra.GroupWithZero.Basic","initialProofState":"M₀ : Type u_1\ninst✝ : CancelMonoidWithZero M₀\na b : M₀\n⊢ Iff (Eq (HMul.hMul a b) a) (Or (Eq b 1) (Eq a 0))","decl":"theorem mul_right_eq_self₀ : a * b = a ↔ b = 1 ∨ a = 0 :=\n  calc\n    a * b = a ↔ a * b = a * 1 := by rw [mul_one]\n    _ ↔ b = 1 ∨ a = 0 := mul_eq_mul_left_iff\n\n"}
{"name":"mul_left_eq_self₀","module":"Mathlib.Algebra.GroupWithZero.Basic","initialProofState":"M₀ : Type u_1\ninst✝ : CancelMonoidWithZero M₀\na b : M₀\n⊢ Iff (Eq (HMul.hMul a b) b) (Or (Eq a 1) (Eq b 0))","decl":"theorem mul_left_eq_self₀ : a * b = b ↔ a = 1 ∨ b = 0 :=\n  calc\n    a * b = b ↔ a * b = 1 * b := by rw [one_mul]\n    _ ↔ a = 1 ∨ b = 0 := mul_eq_mul_right_iff\n\n"}
{"name":"mul_eq_left₀","module":"Mathlib.Algebra.GroupWithZero.Basic","initialProofState":"M₀ : Type u_1\ninst✝ : CancelMonoidWithZero M₀\na b : M₀\nha : Ne a 0\n⊢ Iff (Eq (HMul.hMul a b) a) (Eq b 1)","decl":"@[simp]\ntheorem mul_eq_left₀ (ha : a ≠ 0) : a * b = a ↔ b = 1 := by\n  rw [Iff.comm, ← mul_right_inj' ha, mul_one]\n\n"}
{"name":"mul_eq_right₀","module":"Mathlib.Algebra.GroupWithZero.Basic","initialProofState":"M₀ : Type u_1\ninst✝ : CancelMonoidWithZero M₀\na b : M₀\nhb : Ne b 0\n⊢ Iff (Eq (HMul.hMul a b) b) (Eq a 1)","decl":"@[simp]\ntheorem mul_eq_right₀ (hb : b ≠ 0) : a * b = b ↔ a = 1 := by\n  rw [Iff.comm, ← mul_left_inj' hb, one_mul]\n\n"}
{"name":"left_eq_mul₀","module":"Mathlib.Algebra.GroupWithZero.Basic","initialProofState":"M₀ : Type u_1\ninst✝ : CancelMonoidWithZero M₀\na b : M₀\nha : Ne a 0\n⊢ Iff (Eq a (HMul.hMul a b)) (Eq b 1)","decl":"@[simp]\ntheorem left_eq_mul₀ (ha : a ≠ 0) : a = a * b ↔ b = 1 := by rw [eq_comm, mul_eq_left₀ ha]\n\n"}
{"name":"right_eq_mul₀","module":"Mathlib.Algebra.GroupWithZero.Basic","initialProofState":"M₀ : Type u_1\ninst✝ : CancelMonoidWithZero M₀\na b : M₀\nhb : Ne b 0\n⊢ Iff (Eq b (HMul.hMul a b)) (Eq a 1)","decl":"@[simp]\ntheorem right_eq_mul₀ (hb : b ≠ 0) : b = a * b ↔ a = 1 := by rw [eq_comm, mul_eq_right₀ hb]\n\n"}
{"name":"eq_zero_of_mul_eq_self_right","module":"Mathlib.Algebra.GroupWithZero.Basic","initialProofState":"M₀ : Type u_1\ninst✝ : CancelMonoidWithZero M₀\na b : M₀\nh₁ : Ne b 1\nh₂ : Eq (HMul.hMul a b) a\n⊢ Eq a 0","decl":"/-- An element of a `CancelMonoidWithZero` fixed by right multiplication by an element other\nthan one must be zero. -/\ntheorem eq_zero_of_mul_eq_self_right (h₁ : b ≠ 1) (h₂ : a * b = a) : a = 0 :=\n  Classical.byContradiction fun ha => h₁ <| mul_left_cancel₀ ha <| h₂.symm ▸ (mul_one a).symm\n\n"}
{"name":"eq_zero_of_mul_eq_self_left","module":"Mathlib.Algebra.GroupWithZero.Basic","initialProofState":"M₀ : Type u_1\ninst✝ : CancelMonoidWithZero M₀\na b : M₀\nh₁ : Ne b 1\nh₂ : Eq (HMul.hMul b a) a\n⊢ Eq a 0","decl":"/-- An element of a `CancelMonoidWithZero` fixed by left multiplication by an element other\nthan one must be zero. -/\ntheorem eq_zero_of_mul_eq_self_left (h₁ : b ≠ 1) (h₂ : b * a = a) : a = 0 :=\n  Classical.byContradiction fun ha => h₁ <| mul_right_cancel₀ ha <| h₂.symm ▸ (one_mul a).symm\n\n"}
{"name":"GroupWithZero.mul_right_injective","module":"Mathlib.Algebra.GroupWithZero.Basic","initialProofState":"G₀ : Type u_2\ninst✝ : GroupWithZero G₀\nx : G₀\nh : Ne x 0\n⊢ Function.Injective fun y => HMul.hMul x y","decl":"theorem GroupWithZero.mul_right_injective (h : x ≠ 0) :\n    Function.Injective fun y => x * y := fun y y' w => by\n  simpa only [← mul_assoc, inv_mul_cancel₀ h, one_mul] using congr_arg (fun y => x⁻¹ * y) w\n\n"}
{"name":"GroupWithZero.mul_left_injective","module":"Mathlib.Algebra.GroupWithZero.Basic","initialProofState":"G₀ : Type u_2\ninst✝ : GroupWithZero G₀\nx : G₀\nh : Ne x 0\n⊢ Function.Injective fun y => HMul.hMul y x","decl":"theorem GroupWithZero.mul_left_injective (h : x ≠ 0) :\n    Function.Injective fun y => y * x := fun y y' w => by\n  simpa only [mul_assoc, mul_inv_cancel₀ h, mul_one] using congr_arg (fun y => y * x⁻¹) w\n\n"}
{"name":"inv_mul_cancel_right₀","module":"Mathlib.Algebra.GroupWithZero.Basic","initialProofState":"G₀ : Type u_2\ninst✝ : GroupWithZero G₀\nb : G₀\nh : Ne b 0\na : G₀\n⊢ Eq (HMul.hMul (HMul.hMul a (Inv.inv b)) b) a","decl":"@[simp]\ntheorem inv_mul_cancel_right₀ (h : b ≠ 0) (a : G₀) : a * b⁻¹ * b = a :=\n  calc\n    a * b⁻¹ * b = a * (b⁻¹ * b) := mul_assoc _ _ _\n    _ = a := by simp [h]\n\n\n"}
{"name":"inv_mul_cancel_left₀","module":"Mathlib.Algebra.GroupWithZero.Basic","initialProofState":"G₀ : Type u_2\ninst✝ : GroupWithZero G₀\na : G₀\nh : Ne a 0\nb : G₀\n⊢ Eq (HMul.hMul (Inv.inv a) (HMul.hMul a b)) b","decl":"@[simp]\ntheorem inv_mul_cancel_left₀ (h : a ≠ 0) (b : G₀) : a⁻¹ * (a * b) = b :=\n  calc\n    a⁻¹ * (a * b) = a⁻¹ * a * b := (mul_assoc _ _ _).symm\n    _ = b := by simp [h]\n\n\n"}
{"name":"zero_div","module":"Mathlib.Algebra.GroupWithZero.Basic","initialProofState":"G₀ : Type u_2\ninst✝ : GroupWithZero G₀\na : G₀\n⊢ Eq (HDiv.hDiv 0 a) 0","decl":"@[simp]\ntheorem zero_div (a : G₀) : 0 / a = 0 := by rw [div_eq_mul_inv, zero_mul]\n\n"}
{"name":"div_zero","module":"Mathlib.Algebra.GroupWithZero.Basic","initialProofState":"G₀ : Type u_2\ninst✝ : GroupWithZero G₀\na : G₀\n⊢ Eq (HDiv.hDiv a 0) 0","decl":"@[simp]\ntheorem div_zero (a : G₀) : a / 0 = 0 := by rw [div_eq_mul_inv, inv_zero, mul_zero]\n\n"}
{"name":"mul_self_mul_inv","module":"Mathlib.Algebra.GroupWithZero.Basic","initialProofState":"G₀ : Type u_2\ninst✝ : GroupWithZero G₀\na : G₀\n⊢ Eq (HMul.hMul (HMul.hMul a a) (Inv.inv a)) a","decl":"/-- Multiplying `a` by itself and then by its inverse results in `a`\n(whether or not `a` is zero). -/\n@[simp]\ntheorem mul_self_mul_inv (a : G₀) : a * a * a⁻¹ = a := by\n  by_cases h : a = 0\n  · rw [h, inv_zero, mul_zero]\n  · rw [mul_assoc, mul_inv_cancel₀ h, mul_one]\n\n\n"}
{"name":"mul_inv_mul_cancel","module":"Mathlib.Algebra.GroupWithZero.Basic","initialProofState":"G₀ : Type u_2\ninst✝ : GroupWithZero G₀\na : G₀\n⊢ Eq (HMul.hMul (HMul.hMul a (Inv.inv a)) a) a","decl":"/-- Multiplying `a` by its inverse and then by itself results in `a`\n(whether or not `a` is zero). -/\n@[simp]\ntheorem mul_inv_mul_cancel (a : G₀) : a * a⁻¹ * a = a := by\n  by_cases h : a = 0\n  · rw [h, inv_zero, mul_zero]\n  · rw [mul_inv_cancel₀ h, one_mul]\n\n\n"}
{"name":"inv_mul_mul_self","module":"Mathlib.Algebra.GroupWithZero.Basic","initialProofState":"G₀ : Type u_2\ninst✝ : GroupWithZero G₀\na : G₀\n⊢ Eq (HMul.hMul (HMul.hMul (Inv.inv a) a) a) a","decl":"/-- Multiplying `a⁻¹` by `a` twice results in `a` (whether or not `a`\nis zero). -/\n@[simp]\ntheorem inv_mul_mul_self (a : G₀) : a⁻¹ * a * a = a := by\n  by_cases h : a = 0\n  · rw [h, inv_zero, mul_zero]\n  · rw [inv_mul_cancel₀ h, one_mul]\n\n\n"}
{"name":"mul_self_div_self","module":"Mathlib.Algebra.GroupWithZero.Basic","initialProofState":"G₀ : Type u_2\ninst✝ : GroupWithZero G₀\na : G₀\n⊢ Eq (HDiv.hDiv (HMul.hMul a a) a) a","decl":"/-- Multiplying `a` by itself and then dividing by itself results in `a`, whether or not `a` is\nzero. -/\n@[simp]\ntheorem mul_self_div_self (a : G₀) : a * a / a = a := by rw [div_eq_mul_inv, mul_self_mul_inv a]\n\n"}
{"name":"div_self_mul_self","module":"Mathlib.Algebra.GroupWithZero.Basic","initialProofState":"G₀ : Type u_2\ninst✝ : GroupWithZero G₀\na : G₀\n⊢ Eq (HMul.hMul (HDiv.hDiv a a) a) a","decl":"/-- Dividing `a` by itself and then multiplying by itself results in `a`, whether or not `a` is\nzero. -/\n@[simp]\ntheorem div_self_mul_self (a : G₀) : a / a * a = a := by rw [div_eq_mul_inv, mul_inv_mul_cancel a]\n\n"}
{"name":"div_self_mul_self'","module":"Mathlib.Algebra.GroupWithZero.Basic","initialProofState":"G₀ : Type u_2\ninst✝ : GroupWithZero G₀\na : G₀\n⊢ Eq (HDiv.hDiv a (HMul.hMul a a)) (Inv.inv a)","decl":"@[simp]\ntheorem div_self_mul_self' (a : G₀) : a / (a * a) = a⁻¹ :=\n  calc\n    a / (a * a) = a⁻¹⁻¹ * a⁻¹ * a⁻¹ := by simp [mul_inv_rev]\n    _ = a⁻¹ := inv_mul_mul_self _\n\n\n"}
{"name":"one_div_ne_zero","module":"Mathlib.Algebra.GroupWithZero.Basic","initialProofState":"G₀ : Type u_2\ninst✝ : GroupWithZero G₀\na : G₀\nh : Ne a 0\n⊢ Ne (HDiv.hDiv 1 a) 0","decl":"theorem one_div_ne_zero {a : G₀} (h : a ≠ 0) : 1 / a ≠ 0 := by\n  simpa only [one_div] using inv_ne_zero h\n\n"}
{"name":"inv_eq_zero","module":"Mathlib.Algebra.GroupWithZero.Basic","initialProofState":"G₀ : Type u_2\ninst✝ : GroupWithZero G₀\na : G₀\n⊢ Iff (Eq (Inv.inv a) 0) (Eq a 0)","decl":"@[simp]\ntheorem inv_eq_zero {a : G₀} : a⁻¹ = 0 ↔ a = 0 := by rw [inv_eq_iff_eq_inv, inv_zero]\n\n"}
{"name":"zero_eq_inv","module":"Mathlib.Algebra.GroupWithZero.Basic","initialProofState":"G₀ : Type u_2\ninst✝ : GroupWithZero G₀\na : G₀\n⊢ Iff (Eq 0 (Inv.inv a)) (Eq 0 a)","decl":"@[simp]\ntheorem zero_eq_inv {a : G₀} : 0 = a⁻¹ ↔ 0 = a :=\n  eq_comm.trans <| inv_eq_zero.trans eq_comm\n\n"}
{"name":"div_div_self","module":"Mathlib.Algebra.GroupWithZero.Basic","initialProofState":"G₀ : Type u_2\ninst✝ : GroupWithZero G₀\na : G₀\n⊢ Eq (HDiv.hDiv a (HDiv.hDiv a a)) a","decl":"/-- Dividing `a` by the result of dividing `a` by itself results in\n`a` (whether or not `a` is zero). -/\n@[simp]\ntheorem div_div_self (a : G₀) : a / (a / a) = a := by\n  rw [div_div_eq_mul_div]\n  exact mul_self_div_self a\n\n"}
{"name":"ne_zero_of_one_div_ne_zero","module":"Mathlib.Algebra.GroupWithZero.Basic","initialProofState":"G₀ : Type u_2\ninst✝ : GroupWithZero G₀\na : G₀\nh : Ne (HDiv.hDiv 1 a) 0\n⊢ Ne a 0","decl":"theorem ne_zero_of_one_div_ne_zero {a : G₀} (h : 1 / a ≠ 0) : a ≠ 0 := fun ha : a = 0 => by\n  rw [ha, div_zero] at h\n  contradiction\n\n"}
{"name":"eq_zero_of_one_div_eq_zero","module":"Mathlib.Algebra.GroupWithZero.Basic","initialProofState":"G₀ : Type u_2\ninst✝ : GroupWithZero G₀\na : G₀\nh : Eq (HDiv.hDiv 1 a) 0\n⊢ Eq a 0","decl":"theorem eq_zero_of_one_div_eq_zero {a : G₀} (h : 1 / a = 0) : a = 0 :=\n  Classical.byCases (fun ha => ha) fun ha => ((one_div_ne_zero ha) h).elim\n\n"}
{"name":"mul_left_surjective₀","module":"Mathlib.Algebra.GroupWithZero.Basic","initialProofState":"G₀ : Type u_2\ninst✝ : GroupWithZero G₀\na : G₀\nh : Ne a 0\n⊢ Function.Surjective fun g => HMul.hMul a g","decl":"theorem mul_left_surjective₀ {a : G₀} (h : a ≠ 0) : Surjective fun g => a * g := fun g =>\n  ⟨a⁻¹ * g, by simp [← mul_assoc, mul_inv_cancel₀ h]⟩\n\n"}
{"name":"mul_right_surjective₀","module":"Mathlib.Algebra.GroupWithZero.Basic","initialProofState":"G₀ : Type u_2\ninst✝ : GroupWithZero G₀\na : G₀\nh : Ne a 0\n⊢ Function.Surjective fun g => HMul.hMul g a","decl":"theorem mul_right_surjective₀ {a : G₀} (h : a ≠ 0) : Surjective fun g => g * a := fun g =>\n  ⟨g * a⁻¹, by simp [mul_assoc, inv_mul_cancel₀ h]⟩\n\n"}
{"name":"zero_zpow","module":"Mathlib.Algebra.GroupWithZero.Basic","initialProofState":"G₀ : Type u_2\ninst✝ : GroupWithZero G₀\nn : Int\na✝ : Ne n 0\n⊢ Eq (HPow.hPow 0 n) 0","decl":"lemma zero_zpow : ∀ n : ℤ, n ≠ 0 → (0 : G₀) ^ n = 0\n  | (n : ℕ), h => by rw [zpow_natCast, zero_pow]; simpa [Int.natCast_eq_zero] using h\n  | .negSucc n, _ => by simp\n\n"}
{"name":"zero_zpow_eq","module":"Mathlib.Algebra.GroupWithZero.Basic","initialProofState":"G₀ : Type u_2\ninst✝ : GroupWithZero G₀\nn : Int\n⊢ Eq (HPow.hPow 0 n) (ite (Eq n 0) 1 0)","decl":"lemma zero_zpow_eq (n : ℤ) : (0 : G₀) ^ n = if n = 0 then 1 else 0 := by\n  split_ifs with h\n  · rw [h, zpow_zero]\n  · rw [zero_zpow _ h]\n\n"}
{"name":"zero_zpow_eq_one₀","module":"Mathlib.Algebra.GroupWithZero.Basic","initialProofState":"G₀ : Type u_2\ninst✝ : GroupWithZero G₀\nn : Int\n⊢ Iff (Eq (HPow.hPow 0 n) 1) (Eq n 0)","decl":"lemma zero_zpow_eq_one₀ {n : ℤ} : (0 : G₀) ^ n = 1 ↔ n = 0 := by\n  rw [zero_zpow_eq, one_ne_zero.ite_eq_left_iff]\n\n"}
{"name":"zpow_add_one₀","module":"Mathlib.Algebra.GroupWithZero.Basic","initialProofState":"G₀ : Type u_2\ninst✝ : GroupWithZero G₀\na : G₀\nha : Ne a 0\nn : Int\n⊢ Eq (HPow.hPow a (HAdd.hAdd n 1)) (HMul.hMul (HPow.hPow a n) a)","decl":"lemma zpow_add_one₀ (ha : a ≠ 0) : ∀ n : ℤ, a ^ (n + 1) = a ^ n * a\n  | (n : ℕ) => by simp only [← Int.ofNat_succ, zpow_natCast, pow_succ]\n  | .negSucc 0 => by simp [ha]\n  | .negSucc (n + 1) => by\n    rw [Int.negSucc_eq, zpow_neg, Int.neg_add, Int.neg_add_cancel_right, zpow_neg, ← Int.ofNat_succ,\n      zpow_natCast, zpow_natCast, pow_succ' _ (n + 1), mul_inv_rev, mul_assoc, inv_mul_cancel₀ ha,\n      mul_one]\n\n"}
{"name":"zpow_sub_one₀","module":"Mathlib.Algebra.GroupWithZero.Basic","initialProofState":"G₀ : Type u_2\ninst✝ : GroupWithZero G₀\na : G₀\nha : Ne a 0\nn : Int\n⊢ Eq (HPow.hPow a (HSub.hSub n 1)) (HMul.hMul (HPow.hPow a n) (Inv.inv a))","decl":"lemma zpow_sub_one₀ (ha : a ≠ 0) (n : ℤ) : a ^ (n - 1) = a ^ n * a⁻¹ :=\n  calc\n    a ^ (n - 1) = a ^ (n - 1) * a * a⁻¹ := by rw [mul_assoc, mul_inv_cancel₀ ha, mul_one]\n    _ = a ^ n * a⁻¹ := by rw [← zpow_add_one₀ ha, Int.sub_add_cancel]\n\n"}
{"name":"zpow_add₀","module":"Mathlib.Algebra.GroupWithZero.Basic","initialProofState":"G₀ : Type u_2\ninst✝ : GroupWithZero G₀\na : G₀\nha : Ne a 0\nm n : Int\n⊢ Eq (HPow.hPow a (HAdd.hAdd m n)) (HMul.hMul (HPow.hPow a m) (HPow.hPow a n))","decl":"lemma zpow_add₀ (ha : a ≠ 0) (m n : ℤ) : a ^ (m + n) = a ^ m * a ^ n := by\n  induction n using Int.induction_on with\n  | hz => simp\n  | hp n ihn => simp only [← Int.add_assoc, zpow_add_one₀ ha, ihn, mul_assoc]\n  | hn n ihn => rw [zpow_sub_one₀ ha, ← mul_assoc, ← ihn, ← zpow_sub_one₀ ha, Int.add_sub_assoc]\n\n"}
{"name":"zpow_add'","module":"Mathlib.Algebra.GroupWithZero.Basic","initialProofState":"G₀ : Type u_2\ninst✝ : GroupWithZero G₀\na : G₀\nm n : Int\nh : Or (Ne a 0) (Or (Ne (HAdd.hAdd m n) 0) (And (Eq m 0) (Eq n 0)))\n⊢ Eq (HPow.hPow a (HAdd.hAdd m n)) (HMul.hMul (HPow.hPow a m) (HPow.hPow a n))","decl":"lemma zpow_add' {m n : ℤ} (h : a ≠ 0 ∨ m + n ≠ 0 ∨ m = 0 ∧ n = 0) :\n    a ^ (m + n) = a ^ m * a ^ n := by\n  by_cases hm : m = 0\n  · simp [hm]\n  by_cases hn : n = 0\n  · simp [hn]\n  by_cases ha : a = 0\n  · subst a\n    simp only [false_or, eq_self_iff_true, not_true, Ne, hm, hn, false_and, or_false] at h\n    rw [zero_zpow _ h, zero_zpow _ hm, zero_mul]\n  · exact zpow_add₀ ha m n\n\n"}
{"name":"zpow_one_add₀","module":"Mathlib.Algebra.GroupWithZero.Basic","initialProofState":"G₀ : Type u_2\ninst✝ : GroupWithZero G₀\na : G₀\nh : Ne a 0\ni : Int\n⊢ Eq (HPow.hPow a (HAdd.hAdd 1 i)) (HMul.hMul a (HPow.hPow a i))","decl":"lemma zpow_one_add₀ (h : a ≠ 0) (i : ℤ) : a ^ (1 + i) = a * a ^ i := by rw [zpow_add₀ h, zpow_one]\n\n"}
{"name":"div_mul_eq_mul_div₀","module":"Mathlib.Algebra.GroupWithZero.Basic","initialProofState":"G₀ : Type u_2\ninst✝ : CommGroupWithZero G₀\na b c : G₀\n⊢ Eq (HMul.hMul (HDiv.hDiv a c) b) (HDiv.hDiv (HMul.hMul a b) c)","decl":"theorem div_mul_eq_mul_div₀ (a b c : G₀) : a / c * b = a * b / c := by\n  simp_rw [div_eq_mul_inv, mul_assoc, mul_comm c⁻¹]\n\n"}
{"name":"div_sq_cancel","module":"Mathlib.Algebra.GroupWithZero.Basic","initialProofState":"G₀ : Type u_2\ninst✝ : CommGroupWithZero G₀\na b : G₀\n⊢ Eq (HDiv.hDiv (HMul.hMul (HPow.hPow a 2) b) a) (HMul.hMul a b)","decl":"lemma div_sq_cancel (a b : G₀) : a ^ 2 * b / a = a * b := by\n  obtain rfl | ha := eq_or_ne a 0\n  · simp\n  · rw [sq, mul_assoc, mul_div_cancel_left₀ _ ha]\n\n"}
