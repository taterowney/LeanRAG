{"name":"CategoryTheory.RelCat.hom_ext_iff","module":"Mathlib.CategoryTheory.Category.RelCat","initialProofState":"X Y : CategoryTheory.RelCat\nf g : Quiver.Hom X Y\n‚ä¢ Iff (Eq f g) (‚àÄ (a : X) (b : Y), Iff (f a b) (g a b))","decl":"@[ext] theorem hom_ext {X Y : RelCat} (f g : X ‚ü∂ Y) (h : ‚àÄ a b, f a b ‚Üî g a b) : f = g :=\n  funext‚ÇÇ (fun a b => propext (h a b))\n\n"}
{"name":"CategoryTheory.RelCat.hom_ext","module":"Mathlib.CategoryTheory.Category.RelCat","initialProofState":"X Y : CategoryTheory.RelCat\nf g : Quiver.Hom X Y\nh : ‚àÄ (a : X) (b : Y), Iff (f a b) (g a b)\n‚ä¢ Eq f g","decl":"@[ext] theorem hom_ext {X Y : RelCat} (f g : X ‚ü∂ Y) (h : ‚àÄ a b, f a b ‚Üî g a b) : f = g :=\n  funext‚ÇÇ (fun a b => propext (h a b))\n\n"}
{"name":"CategoryTheory.RelCat.Hom.rel_id","module":"Mathlib.CategoryTheory.Category.RelCat","initialProofState":"X : CategoryTheory.RelCat\n‚ä¢ Eq (CategoryTheory.CategoryStruct.id X) fun x1 x2 => Eq x1 x2","decl":"protected theorem rel_id (X : RelCat) : ùüô X = (¬∑ = ¬∑) := rfl\n\n"}
{"name":"CategoryTheory.RelCat.Hom.rel_comp","module":"Mathlib.CategoryTheory.Category.RelCat","initialProofState":"X Y Z : CategoryTheory.RelCat\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp f g) (Rel.comp f g)","decl":"protected theorem rel_comp {X Y Z : RelCat} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) : f ‚â´ g = Rel.comp f g := rfl\n\n"}
{"name":"CategoryTheory.RelCat.Hom.rel_id_apply‚ÇÇ","module":"Mathlib.CategoryTheory.Category.RelCat","initialProofState":"X : CategoryTheory.RelCat\nx y : X\n‚ä¢ Iff (CategoryTheory.CategoryStruct.id X x y) (Eq x y)","decl":"theorem rel_id_apply‚ÇÇ (X : RelCat) (x y : X) : (ùüô X) x y ‚Üî x = y := by\n  rw [RelCat.Hom.rel_id]\n\n"}
{"name":"CategoryTheory.RelCat.Hom.rel_comp_apply‚ÇÇ","module":"Mathlib.CategoryTheory.Category.RelCat","initialProofState":"X Y Z : CategoryTheory.RelCat\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\nx : X\nz : Z\n‚ä¢ Iff (CategoryTheory.CategoryStruct.comp f g x z) (Exists fun y => And (f x y) (g y z))","decl":"theorem rel_comp_apply‚ÇÇ {X Y Z : RelCat} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) (x : X) (z : Z) :\n    (f ‚â´ g) x z ‚Üî ‚àÉ y, f x y ‚àß g y z := by rfl\n\n"}
{"name":"CategoryTheory.RelCat.graphFunctor_map","module":"Mathlib.CategoryTheory.Category.RelCat","initialProofState":"X Y : Type u\nf : Quiver.Hom X Y\nx : X\ny : Y\n‚ä¢ Iff (CategoryTheory.RelCat.graphFunctor.map f x y) (Eq (f x) y)","decl":"@[simp] theorem graphFunctor_map {X Y : Type u} (f : X ‚ü∂ Y) (x : X) (y : Y) :\n    graphFunctor.map f x y ‚Üî f x = y := f.graph_def x y\n\n"}
{"name":"CategoryTheory.RelCat.graphFunctor_faithful","module":"Mathlib.CategoryTheory.Category.RelCat","initialProofState":"‚ä¢ CategoryTheory.RelCat.graphFunctor.Faithful","decl":"instance graphFunctor_faithful : graphFunctor.Faithful where\n  map_injective h := Function.graph_injective h\n\n"}
{"name":"CategoryTheory.RelCat.graphFunctor_essSurj","module":"Mathlib.CategoryTheory.Category.RelCat","initialProofState":"‚ä¢ CategoryTheory.RelCat.graphFunctor.EssSurj","decl":"instance graphFunctor_essSurj : graphFunctor.EssSurj :=\n    graphFunctor.essSurj_of_surj Function.surjective_id\n\n"}
{"name":"CategoryTheory.RelCat.rel_iso_iff","module":"Mathlib.CategoryTheory.Category.RelCat","initialProofState":"X Y : CategoryTheory.RelCat\nr : Quiver.Hom X Y\n‚ä¢ Iff (CategoryTheory.IsIso r) (Exists fun f => Eq (CategoryTheory.RelCat.graphFunctor.map f.hom) r)","decl":"/-- A relation is an isomorphism in `RelCat` iff it is the image of an isomorphism in\n`Type u`. -/\ntheorem rel_iso_iff {X Y : RelCat} (r : X ‚ü∂ Y) :\n    IsIso (C := RelCat) r ‚Üî ‚àÉ f : (Iso (C := Type u) X Y), graphFunctor.map f.hom = r := by\n  constructor\n  ¬∑ intro h\n    have h1 := congr_fun‚ÇÇ h.hom_inv_id\n    have h2 := congr_fun‚ÇÇ h.inv_hom_id\n    simp only [RelCat.Hom.rel_comp_apply‚ÇÇ, RelCat.Hom.rel_id_apply‚ÇÇ, eq_iff_iff] at h1 h2\n    obtain ‚ü®f, hf‚ü© := Classical.axiomOfChoice (fun a => (h1 a a).mpr rfl)\n    obtain ‚ü®g, hg‚ü© := Classical.axiomOfChoice (fun a => (h2 a a).mpr rfl)\n    suffices hif : IsIso (C := Type u) f by\n      use asIso f\n      ext x y\n      simp only [asIso_hom, graphFunctor_map]\n      constructor\n      ¬∑ rintro rfl\n        exact (hf x).1\n      ¬∑ intro hr\n        specialize h2 (f x) y\n        rw [‚Üê h2]\n        use x, (hf x).2, hr\n    use g\n    constructor\n    ¬∑ ext x\n      apply (h1 _ _).mp\n      use f x, (hg _).2, (hf _).2\n    ¬∑ ext y\n      apply (h2 _ _).mp\n      use g y, (hf (g y)).2, (hg y).2\n  ¬∑ rintro ‚ü®f, rfl‚ü©\n    apply graphFunctor.map_isIso\n\n"}
{"name":"CategoryTheory.RelCat.opFunctor_comp_unopFunctor_eq","module":"Mathlib.CategoryTheory.Category.RelCat","initialProofState":"‚ä¢ Eq (CategoryTheory.RelCat.opFunctor.comp CategoryTheory.RelCat.unopFunctor) (CategoryTheory.Functor.id CategoryTheory.RelCat)","decl":"@[simp] theorem opFunctor_comp_unopFunctor_eq :\n    Functor.comp opFunctor unopFunctor = Functor.id _ := rfl\n\n"}
{"name":"CategoryTheory.RelCat.unopFunctor_comp_opFunctor_eq","module":"Mathlib.CategoryTheory.Category.RelCat","initialProofState":"‚ä¢ Eq (CategoryTheory.RelCat.unopFunctor.comp CategoryTheory.RelCat.opFunctor) (CategoryTheory.Functor.id (Opposite CategoryTheory.RelCat))","decl":"@[simp] theorem unopFunctor_comp_opFunctor_eq :\n    Functor.comp unopFunctor opFunctor = Functor.id _ := rfl\n\n"}
{"name":"CategoryTheory.RelCat.opEquivalence_unitIso","module":"Mathlib.CategoryTheory.Category.RelCat","initialProofState":"‚ä¢ Eq CategoryTheory.RelCat.opEquivalence.unitIso (CategoryTheory.Iso.refl (CategoryTheory.Functor.id CategoryTheory.RelCat))","decl":"/-- `RelCat` is self-dual: The map that swaps the argument order of a\n    relation induces an equivalence between `RelCat` and its opposite. -/\n@[simps]\ndef opEquivalence : Equivalence RelCat RelCat·µí·µñ where\n  functor := opFunctor\n  inverse := unopFunctor\n  unitIso := Iso.refl _\n  counitIso := Iso.refl _\n\n"}
{"name":"CategoryTheory.RelCat.opEquivalence_inverse","module":"Mathlib.CategoryTheory.Category.RelCat","initialProofState":"‚ä¢ Eq CategoryTheory.RelCat.opEquivalence.inverse CategoryTheory.RelCat.unopFunctor","decl":"/-- `RelCat` is self-dual: The map that swaps the argument order of a\n    relation induces an equivalence between `RelCat` and its opposite. -/\n@[simps]\ndef opEquivalence : Equivalence RelCat RelCat·µí·µñ where\n  functor := opFunctor\n  inverse := unopFunctor\n  unitIso := Iso.refl _\n  counitIso := Iso.refl _\n\n"}
{"name":"CategoryTheory.RelCat.opEquivalence_functor","module":"Mathlib.CategoryTheory.Category.RelCat","initialProofState":"‚ä¢ Eq CategoryTheory.RelCat.opEquivalence.functor CategoryTheory.RelCat.opFunctor","decl":"/-- `RelCat` is self-dual: The map that swaps the argument order of a\n    relation induces an equivalence between `RelCat` and its opposite. -/\n@[simps]\ndef opEquivalence : Equivalence RelCat RelCat·µí·µñ where\n  functor := opFunctor\n  inverse := unopFunctor\n  unitIso := Iso.refl _\n  counitIso := Iso.refl _\n\n"}
{"name":"CategoryTheory.RelCat.opEquivalence_counitIso","module":"Mathlib.CategoryTheory.Category.RelCat","initialProofState":"‚ä¢ Eq CategoryTheory.RelCat.opEquivalence.counitIso (CategoryTheory.Iso.refl (CategoryTheory.RelCat.unopFunctor.comp CategoryTheory.RelCat.opFunctor))","decl":"/-- `RelCat` is self-dual: The map that swaps the argument order of a\n    relation induces an equivalence between `RelCat` and its opposite. -/\n@[simps]\ndef opEquivalence : Equivalence RelCat RelCat·µí·µñ where\n  functor := opFunctor\n  inverse := unopFunctor\n  unitIso := Iso.refl _\n  counitIso := Iso.refl _\n\n"}
{"name":"CategoryTheory.RelCat.instIsEquivalenceOppositeOpFunctor","module":"Mathlib.CategoryTheory.Category.RelCat","initialProofState":"‚ä¢ CategoryTheory.RelCat.opFunctor.IsEquivalence","decl":"instance : opFunctor.IsEquivalence := by\n  change opEquivalence.functor.IsEquivalence\n  infer_instance\n\n"}
{"name":"CategoryTheory.RelCat.instIsEquivalenceOppositeUnopFunctor","module":"Mathlib.CategoryTheory.Category.RelCat","initialProofState":"‚ä¢ CategoryTheory.RelCat.unopFunctor.IsEquivalence","decl":"instance : unopFunctor.IsEquivalence := by\n  change opEquivalence.inverse.IsEquivalence\n  infer_instance\n\n"}
