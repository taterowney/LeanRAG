{"name":"Ideal.finite_factors","module":"Mathlib.RingTheory.DedekindDomain.Factorization","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\ninst✝ : IsDedekindDomain R\nI : Ideal R\nhI : Ne I 0\n⊢ (setOf fun v => Dvd.dvd v.asIdeal I).Finite","decl":"/-- Only finitely many maximal ideals of `R` divide a given nonzero ideal. -/\ntheorem Ideal.finite_factors {I : Ideal R} (hI : I ≠ 0) :\n    {v : HeightOneSpectrum R | v.asIdeal ∣ I}.Finite := by\n  rw [← Set.finite_coe_iff, Set.coe_setOf]\n  haveI h_fin := fintypeSubtypeDvd I hI\n  refine\n    Finite.of_injective (fun v => (⟨(v : HeightOneSpectrum R).asIdeal, v.2⟩ : { x // x ∣ I })) ?_\n  intro v w hvw\n  simp? at hvw says simp only [Subtype.mk.injEq] at hvw\n  exact Subtype.coe_injective (HeightOneSpectrum.ext hvw)\n\n"}
{"name":"Associates.finite_factors","module":"Mathlib.RingTheory.DedekindDomain.Factorization","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\ninst✝ : IsDedekindDomain R\nI : Ideal R\nhI : Ne I 0\n⊢ Filter.Eventually (fun v => Eq (↑((Associates.mk v.asIdeal).count (Associates.mk I).factors)) 0) Filter.cofinite","decl":"/-- For every nonzero ideal `I` of `v`, there are finitely many maximal ideals `v` such that the\n  multiplicity of `v` in the factorization of `I`, denoted `val_v(I)`, is nonzero. -/\ntheorem Associates.finite_factors {I : Ideal R} (hI : I ≠ 0) :\n    ∀ᶠ v : HeightOneSpectrum R in Filter.cofinite,\n      ((Associates.mk v.asIdeal).count (Associates.mk I).factors : ℤ) = 0 := by\n  have h_supp : {v : HeightOneSpectrum R | ¬((Associates.mk v.asIdeal).count\n      (Associates.mk I).factors : ℤ) = 0} = {v : HeightOneSpectrum R | v.asIdeal ∣ I} := by\n    ext v\n    simp_rw [Int.natCast_eq_zero]\n    exact Associates.count_ne_zero_iff_dvd hI v.irreducible\n  rw [Filter.eventually_cofinite, h_supp]\n  exact Ideal.finite_factors hI\n\n"}
{"name":"Ideal.finite_mulSupport","module":"Mathlib.RingTheory.DedekindDomain.Factorization","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\ninst✝ : IsDedekindDomain R\nI : Ideal R\nhI : Ne I 0\n⊢ (Function.mulSupport fun v => v.maxPowDividing I).Finite","decl":"/-- For every nonzero ideal `I` of `v`, there are finitely many maximal ideals `v` such that\n  `v^(val_v(I))` is not the unit ideal. -/\ntheorem finite_mulSupport {I : Ideal R} (hI : I ≠ 0) :\n    (mulSupport fun v : HeightOneSpectrum R => v.maxPowDividing I).Finite :=\n  haveI h_subset : {v : HeightOneSpectrum R | v.maxPowDividing I ≠ 1} ⊆\n      {v : HeightOneSpectrum R |\n        ((Associates.mk v.asIdeal).count (Associates.mk I).factors : ℤ) ≠ 0} := by\n    intro v hv h_zero\n    have hv' : v.maxPowDividing I = 1 := by\n      rw [IsDedekindDomain.HeightOneSpectrum.maxPowDividing, Int.natCast_eq_zero.mp h_zero,\n        pow_zero _]\n    exact hv hv'\n  Finite.subset (Filter.eventually_cofinite.mp (Associates.finite_factors hI)) h_subset\n\n"}
{"name":"Ideal.finite_mulSupport_coe","module":"Mathlib.RingTheory.DedekindDomain.Factorization","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\nK : Type u_2\ninst✝³ : Field K\ninst✝² : Algebra R K\ninst✝¹ : IsFractionRing R K\ninst✝ : IsDedekindDomain R\nI : Ideal R\nhI : Ne I 0\n⊢ (Function.mulSupport fun v => HPow.hPow ↑v.asIdeal ↑((Associates.mk v.asIdeal).count (Associates.mk I).factors)).Finite","decl":"/-- For every nonzero ideal `I` of `v`, there are finitely many maximal ideals `v` such that\n`v^(val_v(I))`, regarded as a fractional ideal, is not `(1)`. -/\ntheorem finite_mulSupport_coe {I : Ideal R} (hI : I ≠ 0) :\n    (mulSupport fun v : HeightOneSpectrum R => (v.asIdeal : FractionalIdeal R⁰ K) ^\n      ((Associates.mk v.asIdeal).count (Associates.mk I).factors : ℤ)).Finite := by\n  rw [mulSupport]\n  simp_rw [Ne, zpow_natCast, ← FractionalIdeal.coeIdeal_pow, FractionalIdeal.coeIdeal_eq_one]\n  exact finite_mulSupport hI\n\n"}
{"name":"Ideal.finite_mulSupport_inv","module":"Mathlib.RingTheory.DedekindDomain.Factorization","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\nK : Type u_2\ninst✝³ : Field K\ninst✝² : Algebra R K\ninst✝¹ : IsFractionRing R K\ninst✝ : IsDedekindDomain R\nI : Ideal R\nhI : Ne I 0\n⊢ (Function.mulSupport fun v => HPow.hPow (↑v.asIdeal) (Neg.neg ↑((Associates.mk v.asIdeal).count (Associates.mk I).factors))).Finite","decl":"/-- For every nonzero ideal `I` of `v`, there are finitely many maximal ideals `v` such that\n`v^-(val_v(I))` is not the unit ideal. -/\ntheorem finite_mulSupport_inv {I : Ideal R} (hI : I ≠ 0) :\n    (mulSupport fun v : HeightOneSpectrum R => (v.asIdeal : FractionalIdeal R⁰ K) ^\n      (-((Associates.mk v.asIdeal).count (Associates.mk I).factors : ℤ))).Finite := by\n  rw [mulSupport]\n  simp_rw [zpow_neg, Ne, inv_eq_one]\n  exact finite_mulSupport_coe hI\n\n"}
{"name":"Ideal.finprod_not_dvd","module":"Mathlib.RingTheory.DedekindDomain.Factorization","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\ninst✝ : IsDedekindDomain R\nv : IsDedekindDomain.HeightOneSpectrum R\nI : Ideal R\nhI : Ne I 0\n⊢ Not (Dvd.dvd (HPow.hPow v.asIdeal (HAdd.hAdd ((Associates.mk v.asIdeal).count (Associates.mk I).factors) 1)) (finprod fun v => v.maxPowDividing I))","decl":"/-- For every nonzero ideal `I` of `v`, `v^(val_v(I) + 1)` does not divide `∏_v v^(val_v(I))`. -/\ntheorem finprod_not_dvd (I : Ideal R) (hI : I ≠ 0) :\n    ¬v.asIdeal ^ ((Associates.mk v.asIdeal).count (Associates.mk I).factors + 1) ∣\n        ∏ᶠ v : HeightOneSpectrum R, v.maxPowDividing I := by\n  have hf := finite_mulSupport hI\n  have h_ne_zero : v.maxPowDividing I ≠ 0 := pow_ne_zero _ v.ne_bot\n  rw [← mul_finprod_cond_ne v hf, pow_add, pow_one, finprod_cond_ne _ _ hf]\n  intro h_contr\n  have hv_prime : Prime v.asIdeal := Ideal.prime_of_isPrime v.ne_bot v.isPrime\n  obtain ⟨w, hw, hvw'⟩ :=\n    Prime.exists_mem_finset_dvd hv_prime ((mul_dvd_mul_iff_left h_ne_zero).mp h_contr)\n  have hw_prime : Prime w.asIdeal := Ideal.prime_of_isPrime w.ne_bot w.isPrime\n  have hvw := Prime.dvd_of_dvd_pow hv_prime hvw'\n  rw [Prime.dvd_prime_iff_associated hv_prime hw_prime, associated_iff_eq] at hvw\n  exact (Finset.mem_erase.mp hw).1 (HeightOneSpectrum.ext hvw.symm)\n\n"}
{"name":"Associates.finprod_ne_zero","module":"Mathlib.RingTheory.DedekindDomain.Factorization","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\ninst✝ : IsDedekindDomain R\nI : Ideal R\n⊢ Ne (Associates.mk (finprod fun v => v.maxPowDividing I)) 0","decl":"theorem Associates.finprod_ne_zero (I : Ideal R) :\n    Associates.mk (∏ᶠ v : HeightOneSpectrum R, v.maxPowDividing I) ≠ 0 := by\n  rw [Associates.mk_ne_zero, finprod_def]\n  split_ifs\n  · rw [Finset.prod_ne_zero_iff]\n    intro v _\n    apply pow_ne_zero _ v.ne_bot\n  · exact one_ne_zero\n\n"}
{"name":"Ideal.finprod_count","module":"Mathlib.RingTheory.DedekindDomain.Factorization","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\ninst✝ : IsDedekindDomain R\nv : IsDedekindDomain.HeightOneSpectrum R\nI : Ideal R\nhI : Ne I 0\n⊢ Eq ((Associates.mk v.asIdeal).count (Associates.mk (finprod fun v => v.maxPowDividing I)).factors) ((Associates.mk v.asIdeal).count (Associates.mk I).factors)","decl":"/-- The multiplicity of `v` in `∏_v v^(val_v(I))` equals `val_v(I)`. -/\ntheorem finprod_count (I : Ideal R) (hI : I ≠ 0) : (Associates.mk v.asIdeal).count\n    (Associates.mk (∏ᶠ v : HeightOneSpectrum R, v.maxPowDividing I)).factors =\n    (Associates.mk v.asIdeal).count (Associates.mk I).factors := by\n  have h_ne_zero := Associates.finprod_ne_zero I\n  have hv : Irreducible (Associates.mk v.asIdeal) := v.associates_irreducible\n  have h_dvd := finprod_mem_dvd v (Ideal.finite_mulSupport hI)\n  have h_not_dvd := Ideal.finprod_not_dvd v I hI\n  simp only [IsDedekindDomain.HeightOneSpectrum.maxPowDividing] at h_dvd h_ne_zero h_not_dvd\n  rw [← Associates.mk_dvd_mk] at h_dvd h_not_dvd\n  simp only [Associates.dvd_eq_le] at h_dvd h_not_dvd\n  rw [Associates.mk_pow, Associates.prime_pow_dvd_iff_le h_ne_zero hv] at h_dvd h_not_dvd\n  rw [not_le] at h_not_dvd\n  apply Nat.eq_of_le_of_lt_succ h_dvd h_not_dvd\n\n"}
{"name":"Ideal.finprod_heightOneSpectrum_factorization","module":"Mathlib.RingTheory.DedekindDomain.Factorization","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\ninst✝ : IsDedekindDomain R\nI : Ideal R\nhI : Ne I 0\n⊢ Eq (finprod fun v => v.maxPowDividing I) I","decl":"/-- The ideal `I` equals the finprod `∏_v v^(val_v(I))`. -/\ntheorem finprod_heightOneSpectrum_factorization {I : Ideal R} (hI : I ≠ 0) :\n    ∏ᶠ v : HeightOneSpectrum R, v.maxPowDividing I = I := by\n  rw [← associated_iff_eq, ← Associates.mk_eq_mk_iff_associated]\n  apply Associates.eq_of_eq_counts\n  · apply Associates.finprod_ne_zero I\n  · apply Associates.mk_ne_zero.mpr hI\n  intro v hv\n  obtain ⟨J, hJv⟩ := Associates.exists_rep v\n  rw [← hJv, Associates.irreducible_mk] at hv\n  rw [← hJv]\n  apply Ideal.finprod_count\n    ⟨J, Ideal.isPrime_of_prime (irreducible_iff_prime.mp hv), Irreducible.ne_zero hv⟩ I hI\n\n"}
{"name":"Ideal.finprod_heightOneSpectrum_factorization_coe","module":"Mathlib.RingTheory.DedekindDomain.Factorization","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\nK : Type u_2\ninst✝³ : Field K\ninst✝² : Algebra R K\ninst✝¹ : IsFractionRing R K\ninst✝ : IsDedekindDomain R\nI : Ideal R\nhI : Ne I 0\n⊢ Eq (finprod fun v => HPow.hPow ↑v.asIdeal ↑((Associates.mk v.asIdeal).count (Associates.mk I).factors)) ↑I","decl":"/-- The ideal `I` equals the finprod `∏_v v^(val_v(I))`, when both sides are regarded as fractional\nideals of `R`. -/\ntheorem finprod_heightOneSpectrum_factorization_coe {I : Ideal R} (hI : I ≠ 0) :\n    (∏ᶠ v : HeightOneSpectrum R, (v.asIdeal : FractionalIdeal R⁰ K) ^\n      ((Associates.mk v.asIdeal).count (Associates.mk I).factors : ℤ)) = I := by\n  conv_rhs => rw [← Ideal.finprod_heightOneSpectrum_factorization hI]\n  rw [FractionalIdeal.coeIdeal_finprod R⁰ K (le_refl _)]\n  simp_rw [IsDedekindDomain.HeightOneSpectrum.maxPowDividing, FractionalIdeal.coeIdeal_pow,\n    zpow_natCast]\n\n"}
{"name":"FractionalIdeal.finprod_heightOneSpectrum_factorization","module":"Mathlib.RingTheory.DedekindDomain.Factorization","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\nK : Type u_2\ninst✝³ : Field K\ninst✝² : Algebra R K\ninst✝¹ : IsFractionRing R K\ninst✝ : IsDedekindDomain R\nI : FractionalIdeal (nonZeroDivisors R) K\nhI : Ne I 0\na : R\nJ : Ideal R\nhaJ : Eq I (HMul.hMul (FractionalIdeal.spanSingleton (nonZeroDivisors R) (Inv.inv ((algebraMap R K) a))) ↑J)\n⊢ Eq (finprod fun v => HPow.hPow (↑v.asIdeal) (HSub.hSub ↑((Associates.mk v.asIdeal).count (Associates.mk J).factors) ↑((Associates.mk v.asIdeal).count (Associates.mk (Ideal.span (Singleton.singleton a))).factors))) I","decl":"/-- If `I` is a nonzero fractional ideal, `a ∈ R`, and `J` is an ideal of `R` such that\n`I = a⁻¹J`, then `I` is equal to the product `∏_v v^(val_v(J) - val_v(a))`. -/\ntheorem finprod_heightOneSpectrum_factorization {I : FractionalIdeal R⁰ K} (hI : I ≠ 0) {a : R}\n    {J : Ideal R} (haJ : I = spanSingleton R⁰ ((algebraMap R K) a)⁻¹ * ↑J) :\n    ∏ᶠ v : HeightOneSpectrum R, (v.asIdeal : FractionalIdeal R⁰ K) ^\n      ((Associates.mk v.asIdeal).count (Associates.mk J).factors -\n        (Associates.mk v.asIdeal).count (Associates.mk (Ideal.span {a})).factors : ℤ) = I := by\n  have hJ_ne_zero : J ≠ 0 := ideal_factor_ne_zero hI haJ\n  have hJ := Ideal.finprod_heightOneSpectrum_factorization_coe K hJ_ne_zero\n  have ha_ne_zero : Ideal.span {a} ≠ 0 := constant_factor_ne_zero hI haJ\n  have ha := Ideal.finprod_heightOneSpectrum_factorization_coe K ha_ne_zero\n  rw [haJ, ← div_spanSingleton, div_eq_mul_inv, ← coeIdeal_span_singleton, ← hJ, ← ha,\n    ← finprod_inv_distrib]\n  simp_rw [← zpow_neg]\n  rw [← finprod_mul_distrib (Ideal.finite_mulSupport_coe hJ_ne_zero)\n    (Ideal.finite_mulSupport_inv ha_ne_zero)]\n  apply finprod_congr\n  intro v\n  rw [← zpow_add₀ ((@coeIdeal_ne_zero R _ K _ _ _ _).mpr v.ne_bot), sub_eq_add_neg]\n\n"}
{"name":"FractionalIdeal.finprod_heightOneSpectrum_factorization_principal_fraction","module":"Mathlib.RingTheory.DedekindDomain.Factorization","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\nK : Type u_2\ninst✝³ : Field K\ninst✝² : Algebra R K\ninst✝¹ : IsFractionRing R K\ninst✝ : IsDedekindDomain R\nn : R\nhn : Ne n 0\nd : Subtype fun x => Membership.mem (nonZeroDivisors R) x\n⊢ Eq (finprod fun v => HPow.hPow (↑v.asIdeal) (HSub.hSub ↑((Associates.mk v.asIdeal).count (Associates.mk (Ideal.span (Singleton.singleton n))).factors) ↑((Associates.mk v.asIdeal).count (Associates.mk (Ideal.span (Singleton.singleton ↑d))).factors))) (FractionalIdeal.spanSingleton (nonZeroDivisors R) (IsLocalization.mk' K n d))","decl":"/-- For a nonzero `k = r/s ∈ K`, the fractional ideal `(k)` is equal to the product\n`∏_v v^(val_v(r) - val_v(s))`. -/\ntheorem finprod_heightOneSpectrum_factorization_principal_fraction {n : R} (hn : n ≠ 0) (d : ↥R⁰) :\n    ∏ᶠ v : HeightOneSpectrum R, (v.asIdeal : FractionalIdeal R⁰ K) ^\n      ((Associates.mk v.asIdeal).count (Associates.mk (Ideal.span {n} : Ideal R)).factors -\n        (Associates.mk v.asIdeal).count (Associates.mk ((Ideal.span {(↑d : R)}) :\n        Ideal R)).factors : ℤ) = spanSingleton R⁰ (mk' K n d) := by\n  have hd_ne_zero : (algebraMap R K) (d : R) ≠ 0 :=\n    map_ne_zero_of_mem_nonZeroDivisors _ (IsFractionRing.injective R K) d.property\n  have h0 : spanSingleton R⁰ (mk' K n d) ≠ 0 := by\n    rw [spanSingleton_ne_zero_iff, IsFractionRing.mk'_eq_div, ne_eq, div_eq_zero_iff, not_or]\n    exact ⟨(map_ne_zero_iff (algebraMap R K) (IsFractionRing.injective R K)).mpr hn, hd_ne_zero⟩\n  have hI : spanSingleton R⁰ (mk' K n d) =\n      spanSingleton R⁰ ((algebraMap R K) d)⁻¹ * ↑(Ideal.span {n} : Ideal R) := by\n    rw [coeIdeal_span_singleton, spanSingleton_mul_spanSingleton]\n    apply congr_arg\n    rw [IsFractionRing.mk'_eq_div, div_eq_mul_inv, mul_comm]\n  exact finprod_heightOneSpectrum_factorization h0 hI\n\n"}
{"name":"FractionalIdeal.finprod_heightOneSpectrum_factorization_principal","module":"Mathlib.RingTheory.DedekindDomain.Factorization","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\nK : Type u_2\ninst✝³ : Field K\ninst✝² : Algebra R K\ninst✝¹ : IsFractionRing R K\ninst✝ : IsDedekindDomain R\nI : FractionalIdeal (nonZeroDivisors R) K\nhI : Ne I 0\nk : K\nhk : Eq I (FractionalIdeal.spanSingleton (nonZeroDivisors R) k)\n⊢ Eq (finprod fun v => HPow.hPow (↑v.asIdeal) (HSub.hSub ↑((Associates.mk v.asIdeal).count (Associates.mk (Ideal.span (Singleton.singleton (Classical.choose ⋯)))).factors) ↑((Associates.mk v.asIdeal).count (Associates.mk (Ideal.span (Singleton.singleton ↑(Classical.choose ⋯)))).factors))) I","decl":"/-- For a nonzero `k = r/s ∈ K`, the fractional ideal `(k)` is equal to the product\n`∏_v v^(val_v(r) - val_v(s))`. -/\ntheorem finprod_heightOneSpectrum_factorization_principal {I : FractionalIdeal R⁰ K} (hI : I ≠ 0)\n    (k : K) (hk : I = spanSingleton R⁰ k) :\n    ∏ᶠ v : HeightOneSpectrum R, (v.asIdeal : FractionalIdeal R⁰ K) ^\n      ((Associates.mk v.asIdeal).count (Associates.mk (Ideal.span {choose\n          (mk'_surjective R⁰ k)} : Ideal R)).factors -\n        (Associates.mk v.asIdeal).count (Associates.mk ((Ideal.span {(↑(choose\n          (choose_spec (mk'_surjective R⁰ k)) : ↥R⁰) : R)}) : Ideal R)).factors : ℤ) = I := by\n  set n : R := choose (mk'_surjective R⁰ k)\n  set d : ↥R⁰ := choose (choose_spec (mk'_surjective R⁰ k))\n  have hnd : mk' K n d = k := choose_spec (choose_spec (mk'_surjective R⁰ k))\n  have hn0 : n ≠ 0 := by\n    by_contra h\n    rw [← hnd, h, IsFractionRing.mk'_eq_div, _root_.map_zero,\n      zero_div, spanSingleton_zero] at hk\n    exact hI hk\n  rw [finprod_heightOneSpectrum_factorization_principal_fraction hn0 d, hk, hnd]\n\n"}
{"name":"FractionalIdeal.count_zero","module":"Mathlib.RingTheory.DedekindDomain.Factorization","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\nK : Type u_2\ninst✝³ : Field K\ninst✝² : Algebra R K\ninst✝¹ : IsFractionRing R K\ninst✝ : IsDedekindDomain R\nv : IsDedekindDomain.HeightOneSpectrum R\n⊢ Eq (FractionalIdeal.count K v 0) 0","decl":"/-- val_v(0) = 0. -/\nlemma count_zero : count K v (0 : FractionalIdeal R⁰ K) = 0 := by simp only [count, dif_pos]\n\n"}
{"name":"FractionalIdeal.count_ne_zero","module":"Mathlib.RingTheory.DedekindDomain.Factorization","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\nK : Type u_2\ninst✝³ : Field K\ninst✝² : Algebra R K\ninst✝¹ : IsFractionRing R K\ninst✝ : IsDedekindDomain R\nv : IsDedekindDomain.HeightOneSpectrum R\nI : FractionalIdeal (nonZeroDivisors R) K\nhI : Ne I 0\n⊢ Eq (FractionalIdeal.count K v I) (HSub.hSub ↑((Associates.mk v.asIdeal).count (Associates.mk (Classical.choose ⋯)).factors) ↑((Associates.mk v.asIdeal).count (Associates.mk (Ideal.span (Singleton.singleton (Classical.choose ⋯)))).factors))","decl":"lemma count_ne_zero {I : FractionalIdeal R⁰ K} (hI : I ≠ 0) :\n    count K v I = ((Associates.mk v.asIdeal).count (Associates.mk\n      (choose (choose_spec (exists_eq_spanSingleton_mul I)))).factors -\n      (Associates.mk v.asIdeal).count\n        (Associates.mk (Ideal.span {choose (exists_eq_spanSingleton_mul I)})).factors : ℤ) := by\n  simp only [count, dif_neg hI]\n\n"}
{"name":"FractionalIdeal.count_well_defined","module":"Mathlib.RingTheory.DedekindDomain.Factorization","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\nK : Type u_2\ninst✝³ : Field K\ninst✝² : Algebra R K\ninst✝¹ : IsFractionRing R K\ninst✝ : IsDedekindDomain R\nv : IsDedekindDomain.HeightOneSpectrum R\nI : FractionalIdeal (nonZeroDivisors R) K\nhI : Ne I 0\na : R\nJ : Ideal R\nh_aJ : Eq I (HMul.hMul (FractionalIdeal.spanSingleton (nonZeroDivisors R) (Inv.inv ((algebraMap R K) a))) ↑J)\n⊢ Eq (FractionalIdeal.count K v I) (HSub.hSub ↑((Associates.mk v.asIdeal).count (Associates.mk J).factors) ↑((Associates.mk v.asIdeal).count (Associates.mk (Ideal.span (Singleton.singleton a))).factors))","decl":"/-- `val_v(I)` does not depend on the choice of `a` and `J` used to represent `I`. -/\ntheorem count_well_defined {I : FractionalIdeal R⁰ K} (hI : I ≠ 0) {a : R}\n    {J : Ideal R} (h_aJ : I = spanSingleton R⁰ ((algebraMap R K) a)⁻¹ * ↑J) :\n    count K v I = ((Associates.mk v.asIdeal).count (Associates.mk J).factors -\n      (Associates.mk v.asIdeal).count (Associates.mk (Ideal.span {a})).factors : ℤ) := by\n  set a₁ := choose (exists_eq_spanSingleton_mul I)\n  set J₁ := choose (choose_spec (exists_eq_spanSingleton_mul I))\n  have h_a₁J₁ : I = spanSingleton R⁰ ((algebraMap R K) a₁)⁻¹ * ↑J₁ :=\n    (choose_spec (choose_spec (exists_eq_spanSingleton_mul I))).2\n  have h_a₁_ne_zero : a₁ ≠ 0 := (choose_spec (choose_spec (exists_eq_spanSingleton_mul I))).1\n  have h_J₁_ne_zero : J₁ ≠ 0 := ideal_factor_ne_zero hI h_a₁J₁\n  have h_a_ne_zero : Ideal.span {a} ≠ 0 := constant_factor_ne_zero hI h_aJ\n  have h_J_ne_zero : J ≠ 0 := ideal_factor_ne_zero hI h_aJ\n  have h_a₁' : spanSingleton R⁰ ((algebraMap R K) a₁) ≠ 0 := by\n    rw [ne_eq, spanSingleton_eq_zero_iff, ← (algebraMap R K).map_zero,\n      Injective.eq_iff (IsLocalization.injective K (le_refl R⁰))]\n    exact h_a₁_ne_zero\n  have h_a' : spanSingleton R⁰ ((algebraMap R K) a) ≠ 0 := by\n    rw [ne_eq, spanSingleton_eq_zero_iff, ← (algebraMap R K).map_zero,\n      Injective.eq_iff (IsLocalization.injective K (le_refl R⁰))]\n    rw [ne_eq, Ideal.zero_eq_bot, Ideal.span_singleton_eq_bot] at h_a_ne_zero\n    exact h_a_ne_zero\n  have hv : Irreducible (Associates.mk v.asIdeal) := by\n    exact Associates.irreducible_mk.mpr v.irreducible\n  rw [h_a₁J₁, ← div_spanSingleton, ← div_spanSingleton, div_eq_div_iff h_a₁' h_a',\n    ← coeIdeal_span_singleton, ← coeIdeal_span_singleton, ← coeIdeal_mul, ← coeIdeal_mul] at h_aJ\n  rw [count, dif_neg hI, sub_eq_sub_iff_add_eq_add, ← ofNat_add, ← ofNat_add, natCast_inj,\n    ← Associates.count_mul _ _ hv, ← Associates.count_mul _ _ hv, Associates.mk_mul_mk,\n    Associates.mk_mul_mk, coeIdeal_injective h_aJ]\n  · rw [ne_eq, Associates.mk_eq_zero]; exact h_J_ne_zero\n  · rw [ne_eq, Associates.mk_eq_zero, Ideal.zero_eq_bot, Ideal.span_singleton_eq_bot]\n    exact h_a₁_ne_zero\n  · rw [ne_eq, Associates.mk_eq_zero]; exact h_J₁_ne_zero\n  · rw [ne_eq, Associates.mk_eq_zero]; exact h_a_ne_zero\n\n"}
{"name":"FractionalIdeal.count_mul","module":"Mathlib.RingTheory.DedekindDomain.Factorization","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\nK : Type u_2\ninst✝³ : Field K\ninst✝² : Algebra R K\ninst✝¹ : IsFractionRing R K\ninst✝ : IsDedekindDomain R\nv : IsDedekindDomain.HeightOneSpectrum R\nI I' : FractionalIdeal (nonZeroDivisors R) K\nhI : Ne I 0\nhI' : Ne I' 0\n⊢ Eq (FractionalIdeal.count K v (HMul.hMul I I')) (HAdd.hAdd (FractionalIdeal.count K v I) (FractionalIdeal.count K v I'))","decl":"/-- For nonzero `I, I'`, `val_v(I*I') = val_v(I) + val_v(I')`. -/\ntheorem count_mul {I I' : FractionalIdeal R⁰ K} (hI : I ≠ 0) (hI' : I' ≠ 0) :\n    count K v (I * I') = count K v I + count K v I' := by\n  have hv : Irreducible (Associates.mk v.asIdeal) := by apply v.associates_irreducible\n  obtain ⟨a, J, ha, haJ⟩ := exists_eq_spanSingleton_mul I\n  have ha_ne_zero : Associates.mk (Ideal.span {a} : Ideal R) ≠ 0 := by\n    rw [ne_eq, Associates.mk_eq_zero, Ideal.zero_eq_bot, Ideal.span_singleton_eq_bot]; exact ha\n  have hJ_ne_zero : Associates.mk J ≠ 0 := Associates.mk_ne_zero.mpr (ideal_factor_ne_zero hI haJ)\n  obtain ⟨a', J', ha', haJ'⟩ := exists_eq_spanSingleton_mul I'\n  have ha'_ne_zero : Associates.mk (Ideal.span {a'} : Ideal R) ≠ 0 := by\n    rw [ne_eq, Associates.mk_eq_zero, Ideal.zero_eq_bot, Ideal.span_singleton_eq_bot]; exact ha'\n  have hJ'_ne_zero : Associates.mk J' ≠ 0 :=\n    Associates.mk_ne_zero.mpr (ideal_factor_ne_zero hI' haJ')\n  have h_prod : I * I' = spanSingleton R⁰ ((algebraMap R K) (a * a'))⁻¹ * ↑(J * J') := by\n    rw [haJ, haJ', mul_assoc, mul_comm (J : FractionalIdeal R⁰ K), mul_assoc, ← mul_assoc,\n      spanSingleton_mul_spanSingleton, coeIdeal_mul, RingHom.map_mul, mul_inv,\n      mul_comm (J : FractionalIdeal R⁰ K)]\n  rw [count_well_defined K v hI haJ, count_well_defined K v hI' haJ',\n    count_well_defined K v (mul_ne_zero hI hI') h_prod, ← Associates.mk_mul_mk,\n    Associates.count_mul hJ_ne_zero hJ'_ne_zero hv, ← Ideal.span_singleton_mul_span_singleton,\n    ← Associates.mk_mul_mk, Associates.count_mul ha_ne_zero ha'_ne_zero hv]\n  push_cast\n  ring\n\n"}
{"name":"FractionalIdeal.count_mul'","module":"Mathlib.RingTheory.DedekindDomain.Factorization","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\nK : Type u_2\ninst✝³ : Field K\ninst✝² : Algebra R K\ninst✝¹ : IsFractionRing R K\ninst✝ : IsDedekindDomain R\nv : IsDedekindDomain.HeightOneSpectrum R\nI I' : FractionalIdeal (nonZeroDivisors R) K\n⊢ Eq (FractionalIdeal.count K v (HMul.hMul I I')) (ite (And (Ne I 0) (Ne I' 0)) (HAdd.hAdd (FractionalIdeal.count K v I) (FractionalIdeal.count K v I')) 0)","decl":"/-- For nonzero `I, I'`, `val_v(I*I') = val_v(I) + val_v(I')`. If `I` or `I'` is zero, then\n`val_v(I*I') = 0`. -/\ntheorem count_mul' (I I' : FractionalIdeal R⁰ K) :\n    count K v (I * I') = if I ≠ 0 ∧ I' ≠ 0 then count K v I + count K v I' else 0 := by\n  split_ifs with h\n  · exact count_mul K v h.1 h.2\n  · push_neg at h\n    by_cases hI : I = 0\n    · rw [hI, MulZeroClass.zero_mul, count, dif_pos (Eq.refl _)]\n    · rw [h hI, MulZeroClass.mul_zero, count, dif_pos (Eq.refl _)]\n\n"}
{"name":"FractionalIdeal.count_one","module":"Mathlib.RingTheory.DedekindDomain.Factorization","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\nK : Type u_2\ninst✝³ : Field K\ninst✝² : Algebra R K\ninst✝¹ : IsFractionRing R K\ninst✝ : IsDedekindDomain R\nv : IsDedekindDomain.HeightOneSpectrum R\n⊢ Eq (FractionalIdeal.count K v 1) 0","decl":"/-- val_v(1) = 0. -/\ntheorem count_one : count K v (1 : FractionalIdeal R⁰ K) = 0 := by\n  have h1 : (1 : FractionalIdeal R⁰ K) =\n      spanSingleton R⁰ ((algebraMap R K) 1)⁻¹ * ↑(1 : Ideal R) := by\n    rw [(algebraMap R K).map_one, Ideal.one_eq_top, coeIdeal_top, mul_one, inv_one,\n      spanSingleton_one]\n  rw [count_well_defined K v one_ne_zero h1, Ideal.span_singleton_one, Ideal.one_eq_top, sub_self]\n\n"}
{"name":"FractionalIdeal.count_prod","module":"Mathlib.RingTheory.DedekindDomain.Factorization","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\nK : Type u_2\ninst✝³ : Field K\ninst✝² : Algebra R K\ninst✝¹ : IsFractionRing R K\ninst✝ : IsDedekindDomain R\nv : IsDedekindDomain.HeightOneSpectrum R\nι : Type u_3\ns : Finset ι\nI : ι → FractionalIdeal (nonZeroDivisors R) K\nhS : ∀ (i : ι), Membership.mem s i → Ne (I i) 0\n⊢ Eq (FractionalIdeal.count K v (s.prod fun i => I i)) (s.sum fun i => FractionalIdeal.count K v (I i))","decl":"theorem count_prod {ι} (s : Finset ι) (I : ι → FractionalIdeal R⁰ K) (hS : ∀ i ∈ s, I i ≠ 0) :\n    count K v (∏ i ∈ s, I i) = ∑ i ∈ s, count K v (I i) := by\n  induction' s using Finset.induction with i s hi hrec\n  · rw [Finset.prod_empty, Finset.sum_empty, count_one]\n  · have hS' : ∀ i ∈ s, I i ≠ 0 := fun j hj => hS j (Finset.mem_insert_of_mem hj)\n    have hS0 : ∏ i ∈ s, I i ≠ 0 := Finset.prod_ne_zero_iff.mpr hS'\n    have hi0 : I i ≠ 0 := hS i (Finset.mem_insert_self i s)\n    rw [Finset.prod_insert hi, Finset.sum_insert hi, count_mul K v hi0 hS0, hrec hS']\n\n"}
{"name":"FractionalIdeal.count_pow","module":"Mathlib.RingTheory.DedekindDomain.Factorization","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\nK : Type u_2\ninst✝³ : Field K\ninst✝² : Algebra R K\ninst✝¹ : IsFractionRing R K\ninst✝ : IsDedekindDomain R\nv : IsDedekindDomain.HeightOneSpectrum R\nn : Nat\nI : FractionalIdeal (nonZeroDivisors R) K\n⊢ Eq (FractionalIdeal.count K v (HPow.hPow I n)) (HMul.hMul (↑n) (FractionalIdeal.count K v I))","decl":"/-- For every `n ∈ ℕ` and every ideal `I`, `val_v(I^n) = n*val_v(I)`. -/\ntheorem count_pow (n : ℕ) (I : FractionalIdeal R⁰ K) :\n    count K v (I ^ n) = n * count K v I := by\n  induction' n with n h\n  · rw [pow_zero, ofNat_zero, MulZeroClass.zero_mul, count_one]\n  · rw [pow_succ, count_mul']\n    by_cases hI : I = 0\n    · have h_neg : ¬(I ^ n ≠ 0 ∧ I ≠ 0) := by\n        rw [not_and', not_not, ne_eq]\n        intro h\n        exact absurd hI h\n      rw [if_neg h_neg, hI, count_zero, MulZeroClass.mul_zero]\n    · rw [if_pos (And.intro (pow_ne_zero n hI) hI), h, Nat.cast_add,\n        Nat.cast_one]\n      ring\n\n"}
{"name":"FractionalIdeal.count_self","module":"Mathlib.RingTheory.DedekindDomain.Factorization","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\nK : Type u_2\ninst✝³ : Field K\ninst✝² : Algebra R K\ninst✝¹ : IsFractionRing R K\ninst✝ : IsDedekindDomain R\nv : IsDedekindDomain.HeightOneSpectrum R\n⊢ Eq (FractionalIdeal.count K v ↑v.asIdeal) 1","decl":"/-- `val_v(v) = 1`, when `v` is regarded as a fractional ideal. -/\ntheorem count_self : count K v (v.asIdeal : FractionalIdeal R⁰ K) = 1 := by\n  have hv : (v.asIdeal : FractionalIdeal R⁰ K) ≠ 0 := coeIdeal_ne_zero.mpr v.ne_bot\n  have h_self : (v.asIdeal : FractionalIdeal R⁰ K) =\n      spanSingleton R⁰ ((algebraMap R K) 1)⁻¹ * ↑v.asIdeal := by\n    rw [(algebraMap R K).map_one, inv_one, spanSingleton_one, one_mul]\n  have hv_irred : Irreducible (Associates.mk v.asIdeal) := by apply v.associates_irreducible\n  rw [count_well_defined K v hv h_self, Associates.count_self hv_irred, Ideal.span_singleton_one,\n    ← Ideal.one_eq_top, Associates.mk_one, Associates.factors_one, Associates.count_zero hv_irred,\n    ofNat_zero, sub_zero, ofNat_one]\n\n"}
{"name":"FractionalIdeal.count_pow_self","module":"Mathlib.RingTheory.DedekindDomain.Factorization","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\nK : Type u_2\ninst✝³ : Field K\ninst✝² : Algebra R K\ninst✝¹ : IsFractionRing R K\ninst✝ : IsDedekindDomain R\nv : IsDedekindDomain.HeightOneSpectrum R\nn : Nat\n⊢ Eq (FractionalIdeal.count K v (HPow.hPow (↑v.asIdeal) n)) ↑n","decl":"/-- `val_v(v^n) = n` for every `n ∈ ℕ`. -/\ntheorem count_pow_self (n : ℕ) :\n    count K v ((v.asIdeal : FractionalIdeal R⁰ K) ^ n) = n := by\n  rw [count_pow, count_self, mul_one]\n\n"}
{"name":"FractionalIdeal.count_neg_zpow","module":"Mathlib.RingTheory.DedekindDomain.Factorization","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\nK : Type u_2\ninst✝³ : Field K\ninst✝² : Algebra R K\ninst✝¹ : IsFractionRing R K\ninst✝ : IsDedekindDomain R\nv : IsDedekindDomain.HeightOneSpectrum R\nn : Int\nI : FractionalIdeal (nonZeroDivisors R) K\n⊢ Eq (FractionalIdeal.count K v (HPow.hPow I (Neg.neg n))) (Neg.neg (FractionalIdeal.count K v (HPow.hPow I n)))","decl":"/-- `val_v(I⁻ⁿ) = -val_v(Iⁿ)` for every `n ∈ ℤ`. -/\ntheorem count_neg_zpow (n : ℤ) (I : FractionalIdeal R⁰ K) :\n    count K v (I ^ (-n)) = - count K v (I ^ n) := by\n  by_cases hI : I = 0\n  · by_cases hn : n = 0\n    · rw [hn, neg_zero, zpow_zero, count_one, neg_zero]\n    · rw [hI, zero_zpow n hn, zero_zpow (-n) (neg_ne_zero.mpr hn), count_zero, neg_zero]\n  · rw [eq_neg_iff_add_eq_zero, ← count_mul K v (zpow_ne_zero _ hI) (zpow_ne_zero _ hI),\n      ← zpow_add₀ hI, neg_add_cancel, zpow_zero]\n    exact count_one K v\n\n"}
{"name":"FractionalIdeal.count_inv","module":"Mathlib.RingTheory.DedekindDomain.Factorization","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\nK : Type u_2\ninst✝³ : Field K\ninst✝² : Algebra R K\ninst✝¹ : IsFractionRing R K\ninst✝ : IsDedekindDomain R\nv : IsDedekindDomain.HeightOneSpectrum R\nI : FractionalIdeal (nonZeroDivisors R) K\n⊢ Eq (FractionalIdeal.count K v (Inv.inv I)) (Neg.neg (FractionalIdeal.count K v I))","decl":"theorem count_inv (I : FractionalIdeal R⁰ K) :\n    count K v (I⁻¹) = - count K v I := by\n  rw [← zpow_neg_one, count_neg_zpow K v (1 : ℤ) I, zpow_one]\n\n"}
{"name":"FractionalIdeal.count_zpow","module":"Mathlib.RingTheory.DedekindDomain.Factorization","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\nK : Type u_2\ninst✝³ : Field K\ninst✝² : Algebra R K\ninst✝¹ : IsFractionRing R K\ninst✝ : IsDedekindDomain R\nv : IsDedekindDomain.HeightOneSpectrum R\nn : Int\nI : FractionalIdeal (nonZeroDivisors R) K\n⊢ Eq (FractionalIdeal.count K v (HPow.hPow I n)) (HMul.hMul n (FractionalIdeal.count K v I))","decl":"/-- `val_v(Iⁿ) = n*val_v(I)` for every `n ∈ ℤ`. -/\ntheorem count_zpow (n : ℤ) (I : FractionalIdeal R⁰ K) :\n    count K v (I ^ n) = n * count K v I := by\n  cases' n with n\n  · rw [ofNat_eq_coe, zpow_natCast]\n    exact count_pow K v n I\n  · rw [negSucc_coe, count_neg_zpow, zpow_natCast, count_pow]\n    ring\n\n"}
{"name":"FractionalIdeal.count_zpow_self","module":"Mathlib.RingTheory.DedekindDomain.Factorization","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\nK : Type u_2\ninst✝³ : Field K\ninst✝² : Algebra R K\ninst✝¹ : IsFractionRing R K\ninst✝ : IsDedekindDomain R\nv : IsDedekindDomain.HeightOneSpectrum R\nn : Int\n⊢ Eq (FractionalIdeal.count K v (HPow.hPow (↑v.asIdeal) n)) n","decl":"/-- `val_v(v^n) = n` for every `n ∈ ℤ`. -/\ntheorem count_zpow_self (n : ℤ) :\n    count K v ((v.asIdeal : FractionalIdeal R⁰ K) ^ n) = n := by\n  rw [count_zpow, count_self, mul_one]\n\n"}
{"name":"FractionalIdeal.count_maximal_coprime","module":"Mathlib.RingTheory.DedekindDomain.Factorization","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\nK : Type u_2\ninst✝³ : Field K\ninst✝² : Algebra R K\ninst✝¹ : IsFractionRing R K\ninst✝ : IsDedekindDomain R\nv w : IsDedekindDomain.HeightOneSpectrum R\nhw : Ne w v\n⊢ Eq (FractionalIdeal.count K v ↑w.asIdeal) 0","decl":"/-- If `v ≠ w` are two maximal ideals of `R`, then `val_v(w) = 0`. -/\ntheorem count_maximal_coprime {w : HeightOneSpectrum R} (hw : w ≠ v) :\n    count K v (w.asIdeal : FractionalIdeal R⁰ K) = 0 := by\n  have hw_fact : (w.asIdeal : FractionalIdeal R⁰ K) =\n      spanSingleton R⁰ ((algebraMap R K) 1)⁻¹ * ↑w.asIdeal := by\n    rw [(algebraMap R K).map_one, inv_one, spanSingleton_one, one_mul]\n  have hw_ne_zero : (w.asIdeal : FractionalIdeal R⁰ K) ≠ 0 :=\n    coeIdeal_ne_zero.mpr w.ne_bot\n  have hv : Irreducible (Associates.mk v.asIdeal) := by apply v.associates_irreducible\n  have hw' : Irreducible (Associates.mk w.asIdeal) := by apply w.associates_irreducible\n  rw [count_well_defined K v hw_ne_zero hw_fact, Ideal.span_singleton_one, ← Ideal.one_eq_top,\n    Associates.mk_one, Associates.factors_one, Associates.count_zero hv, ofNat_zero, sub_zero,\n    natCast_eq_zero, ← pow_one (Associates.mk w.asIdeal), Associates.factors_prime_pow hw',\n    Associates.count_some hv, Multiset.replicate_one, Multiset.count_eq_zero,\n    Multiset.mem_singleton]\n  simp only [Subtype.mk.injEq]\n  rw [Associates.mk_eq_mk_iff_associated, associated_iff_eq, ← HeightOneSpectrum.ext_iff]\n  exact Ne.symm hw\n\n"}
{"name":"FractionalIdeal.count_maximal","module":"Mathlib.RingTheory.DedekindDomain.Factorization","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\nK : Type u_2\ninst✝³ : Field K\ninst✝² : Algebra R K\ninst✝¹ : IsFractionRing R K\ninst✝ : IsDedekindDomain R\nv w : IsDedekindDomain.HeightOneSpectrum R\n⊢ Eq (FractionalIdeal.count K v ↑w.asIdeal) (ite (Eq w v) 1 0)","decl":"theorem count_maximal (w : HeightOneSpectrum R) :\n    count K v (w.asIdeal : FractionalIdeal R⁰ K) = if w = v then 1 else 0 := by\n  split_ifs with h\n  · rw [h, count_self]\n  · exact count_maximal_coprime K v h\n\n"}
{"name":"FractionalIdeal.count_finprod_coprime","module":"Mathlib.RingTheory.DedekindDomain.Factorization","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\nK : Type u_2\ninst✝³ : Field K\ninst✝² : Algebra R K\ninst✝¹ : IsFractionRing R K\ninst✝ : IsDedekindDomain R\nv : IsDedekindDomain.HeightOneSpectrum R\nexps : IsDedekindDomain.HeightOneSpectrum R → Int\n⊢ Eq (FractionalIdeal.count K v (finprod fun w => finprod fun x => HPow.hPow (↑w.asIdeal) (exps w))) 0","decl":"/-- `val_v(∏_{w ≠ v} w^{exps w}) = 0`. -/\ntheorem count_finprod_coprime (exps : HeightOneSpectrum R → ℤ) :\n    count K v (∏ᶠ (w : HeightOneSpectrum R) (_ : w ≠ v),\n      (w.asIdeal : (FractionalIdeal R⁰ K)) ^ exps w) = 0 := by\n  apply finprod_mem_induction fun I => count K v I = 0\n  · exact count_one K v\n  · intro I I' hI hI'\n    by_cases h : I ≠ 0 ∧ I' ≠ 0\n    · rw [count_mul' K v, if_pos h, hI, hI', add_zero]\n    · rw [count_mul' K v, if_neg h]\n  · intro w hw\n    rw [count_zpow, count_maximal_coprime K v hw, MulZeroClass.mul_zero]\n\n"}
{"name":"FractionalIdeal.count_finsupp_prod","module":"Mathlib.RingTheory.DedekindDomain.Factorization","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\nK : Type u_2\ninst✝³ : Field K\ninst✝² : Algebra R K\ninst✝¹ : IsFractionRing R K\ninst✝ : IsDedekindDomain R\nv : IsDedekindDomain.HeightOneSpectrum R\nexps : Finsupp (IsDedekindDomain.HeightOneSpectrum R) Int\n⊢ Eq (FractionalIdeal.count K v (exps.prod fun x1 x2 => HPow.hPow (↑x1.asIdeal) x2)) (exps v)","decl":"theorem count_finsupp_prod (exps : HeightOneSpectrum R →₀ ℤ) :\n    count K v (exps.prod (HeightOneSpectrum.asIdeal · ^ ·)) = exps v := by\n  rw [Finsupp.prod, count_prod]\n  · simp only [count_zpow, count_maximal, mul_ite, mul_one, mul_zero, Finset.sum_ite_eq',\n      exps.mem_support_iff, ne_eq, ite_not, ite_eq_right_iff, @eq_comm ℤ 0, imp_self]\n  · exact fun v hv ↦ zpow_ne_zero _ (coeIdeal_ne_zero.mpr v.ne_bot)\n\n"}
{"name":"FractionalIdeal.count_finprod","module":"Mathlib.RingTheory.DedekindDomain.Factorization","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\nK : Type u_2\ninst✝³ : Field K\ninst✝² : Algebra R K\ninst✝¹ : IsFractionRing R K\ninst✝ : IsDedekindDomain R\nv : IsDedekindDomain.HeightOneSpectrum R\nexps : IsDedekindDomain.HeightOneSpectrum R → Int\nh_exps : Filter.Eventually (fun v => Eq (exps v) 0) Filter.cofinite\n⊢ Eq (FractionalIdeal.count K v (finprod fun v => HPow.hPow (↑v.asIdeal) (exps v))) (exps v)","decl":"/-- If `exps` is finitely supported, then `val_v(∏_w w^{exps w}) = exps v`. -/\ntheorem count_finprod (exps : HeightOneSpectrum R → ℤ)\n    (h_exps : ∀ᶠ v : HeightOneSpectrum R in Filter.cofinite, exps v = 0) :\n    count K v (∏ᶠ v : HeightOneSpectrum R,\n      (v.asIdeal : FractionalIdeal R⁰ K) ^ exps v) = exps v := by\n  convert count_finsupp_prod K v (Finsupp.mk h_exps.toFinset exps (fun _ ↦ h_exps.mem_toFinset))\n  rw [finprod_eq_finset_prod_of_mulSupport_subset (s := h_exps.toFinset), Finsupp.prod]\n  · rfl\n  · rw [Finite.coe_toFinset]\n    intro v hv h\n    rw [mem_mulSupport, h, zpow_zero] at hv\n    exact hv (Eq.refl 1)\n\n"}
{"name":"FractionalIdeal.count_coe","module":"Mathlib.RingTheory.DedekindDomain.Factorization","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\nK : Type u_2\ninst✝³ : Field K\ninst✝² : Algebra R K\ninst✝¹ : IsFractionRing R K\ninst✝ : IsDedekindDomain R\nv : IsDedekindDomain.HeightOneSpectrum R\nJ : Ideal R\nhJ : Ne J 0\n⊢ Eq (FractionalIdeal.count K v ↑J) ↑((Associates.mk v.asIdeal).count (Associates.mk J).factors)","decl":"theorem count_coe {J : Ideal R} (hJ : J ≠ 0) :\n    count K v J = (Associates.mk v.asIdeal).count (Associates.mk J).factors := by\n  rw [count_well_defined K (J := J) (a := 1), Ideal.span_singleton_one, sub_eq_self,\n    Nat.cast_eq_zero, ← Ideal.one_eq_top, Associates.mk_one, Associates.factors_one,\n    Associates.count_zero v.associates_irreducible]\n  · simpa only [ne_eq, coeIdeal_eq_zero]\n  · simp only [_root_.map_one, inv_one, spanSingleton_one, one_mul]\n\n"}
{"name":"FractionalIdeal.count_coe_nonneg","module":"Mathlib.RingTheory.DedekindDomain.Factorization","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\nK : Type u_2\ninst✝³ : Field K\ninst✝² : Algebra R K\ninst✝¹ : IsFractionRing R K\ninst✝ : IsDedekindDomain R\nv : IsDedekindDomain.HeightOneSpectrum R\nJ : Ideal R\n⊢ LE.le 0 (FractionalIdeal.count K v ↑J)","decl":"theorem count_coe_nonneg (J : Ideal R) : 0 ≤ count K v J := by\n  by_cases hJ : J = 0\n  · simp only [hJ, Submodule.zero_eq_bot, coeIdeal_bot, count_zero, le_refl]\n  · simp only [count_coe K v hJ, Nat.cast_nonneg]\n\n"}
{"name":"FractionalIdeal.count_mono","module":"Mathlib.RingTheory.DedekindDomain.Factorization","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\nK : Type u_2\ninst✝³ : Field K\ninst✝² : Algebra R K\ninst✝¹ : IsFractionRing R K\ninst✝ : IsDedekindDomain R\nv : IsDedekindDomain.HeightOneSpectrum R\nI J : FractionalIdeal (nonZeroDivisors R) K\nhI : Ne I 0\nh : LE.le I J\n⊢ LE.le (FractionalIdeal.count K v J) (FractionalIdeal.count K v I)","decl":"theorem count_mono {I J} (hI : I ≠ 0) (h : I ≤ J) : count K v J ≤ count K v I := by\n  by_cases hJ : J = 0\n  · exact (hI (FractionalIdeal.le_zero_iff.mp (h.trans hJ.le))).elim\n  have := FractionalIdeal.mul_le_mul_left h J⁻¹\n  rw [inv_mul_cancel₀ hJ, FractionalIdeal.le_one_iff_exists_coeIdeal] at this\n  obtain ⟨J', hJ'⟩ := this\n  rw [← mul_inv_cancel_left₀ hJ I, ← hJ', count_mul K v hJ, le_add_iff_nonneg_right]\n  · exact count_coe_nonneg K v J'\n  · exact hJ' ▸ mul_ne_zero (inv_ne_zero hJ) hI\n\n"}
{"name":"FractionalIdeal.finprod_heightOneSpectrum_factorization'","module":"Mathlib.RingTheory.DedekindDomain.Factorization","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\nK : Type u_2\ninst✝³ : Field K\ninst✝² : Algebra R K\ninst✝¹ : IsFractionRing R K\ninst✝ : IsDedekindDomain R\nI : FractionalIdeal (nonZeroDivisors R) K\nhI : Ne I 0\n⊢ Eq (finprod fun v => HPow.hPow (↑v.asIdeal) (FractionalIdeal.count K v I)) I","decl":"/-- If `I` is a nonzero fractional ideal, then `I` is equal to the product `∏_v v^(count K v I)`. -/\ntheorem finprod_heightOneSpectrum_factorization' {I : FractionalIdeal R⁰ K} (hI : I ≠ 0) :\n    ∏ᶠ v : HeightOneSpectrum R, (v.asIdeal : FractionalIdeal R⁰ K) ^ (count K v I) = I := by\n  have h := (choose_spec (choose_spec (exists_eq_spanSingleton_mul I))).2\n  conv_rhs => rw [← finprod_heightOneSpectrum_factorization hI h]\n  apply finprod_congr\n  intro w\n  apply congr_arg\n  rw [count_ne_zero K w hI]\n\n"}
{"name":"FractionalIdeal.finite_factors'","module":"Mathlib.RingTheory.DedekindDomain.Factorization","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\nK : Type u_2\ninst✝³ : Field K\ninst✝² : Algebra R K\ninst✝¹ : IsFractionRing R K\ninst✝ : IsDedekindDomain R\nI : FractionalIdeal (nonZeroDivisors R) K\nhI : Ne I 0\na : R\nJ : Ideal R\nhaJ : Eq I (HMul.hMul (FractionalIdeal.spanSingleton (nonZeroDivisors R) (Inv.inv ((algebraMap R K) a))) ↑J)\n⊢ Filter.Eventually (fun v => Eq (HSub.hSub ↑((Associates.mk v.asIdeal).count (Associates.mk J).factors) ↑((Associates.mk v.asIdeal).count (Associates.mk (Ideal.span (Singleton.singleton a))).factors)) 0) Filter.cofinite","decl":"/-- If `I ≠ 0`, then `val_v(I) = 0` for all but finitely many maximal ideals of `R`. -/\ntheorem finite_factors' {I : FractionalIdeal R⁰ K} (hI : I ≠ 0) {a : R}\n    {J : Ideal R} (haJ : I = spanSingleton R⁰ ((algebraMap R K) a)⁻¹ * ↑J) :\n    ∀ᶠ v : HeightOneSpectrum R in Filter.cofinite,\n      ((Associates.mk v.asIdeal).count (Associates.mk J).factors : ℤ) -\n        (Associates.mk v.asIdeal).count (Associates.mk (Ideal.span {a})).factors = 0 := by\n  have ha_ne_zero : Ideal.span {a} ≠ 0 := constant_factor_ne_zero hI haJ\n  have hJ_ne_zero : J ≠ 0 := ideal_factor_ne_zero hI haJ\n  have h_subset :\n    {v : HeightOneSpectrum R | ¬((Associates.mk v.asIdeal).count (Associates.mk J).factors : ℤ) -\n      ↑((Associates.mk v.asIdeal).count (Associates.mk (Ideal.span {a})).factors) = 0} ⊆\n    {v : HeightOneSpectrum R | v.asIdeal ∣ J} ∪\n      {v : HeightOneSpectrum R | v.asIdeal ∣ Ideal.span {a}} := by\n    intro v hv\n    have hv_irred : Irreducible v.asIdeal := v.irreducible\n    by_contra h_nmem\n    rw [mem_union, mem_setOf_eq, mem_setOf_eq] at h_nmem\n    push_neg at h_nmem\n    rw [← Associates.count_ne_zero_iff_dvd ha_ne_zero hv_irred, not_not,\n      ← Associates.count_ne_zero_iff_dvd hJ_ne_zero hv_irred, not_not] at h_nmem\n    rw [mem_setOf_eq, h_nmem.1, h_nmem.2, sub_self] at hv\n    exact hv (Eq.refl 0)\n  exact Finite.subset (Finite.union (Ideal.finite_factors (ideal_factor_ne_zero hI haJ))\n    (Ideal.finite_factors (constant_factor_ne_zero hI haJ))) h_subset\n\n"}
{"name":"FractionalIdeal.finite_factors","module":"Mathlib.RingTheory.DedekindDomain.Factorization","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\nK : Type u_2\ninst✝³ : Field K\ninst✝² : Algebra R K\ninst✝¹ : IsFractionRing R K\ninst✝ : IsDedekindDomain R\nI : FractionalIdeal (nonZeroDivisors R) K\n⊢ Filter.Eventually (fun v => Eq (FractionalIdeal.count K v I) 0) Filter.cofinite","decl":"/-- `val_v(I) = 0` for all but finitely many maximal ideals of `R`. -/\ntheorem finite_factors (I : FractionalIdeal R⁰ K) :\n    ∀ᶠ v : HeightOneSpectrum R in Filter.cofinite, count K v I = 0 := by\n  by_cases hI : I = 0\n  · simp only [hI, count_zero, Filter.eventually_cofinite, not_true_eq_false, setOf_false,\n      finite_empty]\n  · convert finite_factors' hI (choose_spec (choose_spec (exists_eq_spanSingleton_mul I))).2\n    rw [count_ne_zero K _ hI]\n\n"}
