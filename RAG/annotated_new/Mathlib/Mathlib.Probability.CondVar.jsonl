{"name":"ProbabilityTheory.condVar_of_not_le","module":"Mathlib.Probability.CondVar","initialProofState":"Ω : Type u_1\nm₀ m : MeasurableSpace Ω\nX : Ω → Real\nμ : MeasureTheory.Measure Ω\nhm : Not (LE.le m m₀)\n⊢ Eq (ProbabilityTheory.condVar m X μ) 0","decl":"lemma condVar_of_not_le (hm : ¬m ≤ m₀) : Var[X ; μ | m] = 0 := by rw [condVar, condExp_of_not_le hm]\n\n"}
{"name":"ProbabilityTheory.condVar_of_not_sigmaFinite","module":"Mathlib.Probability.CondVar","initialProofState":"Ω : Type u_1\nm₀ m : MeasurableSpace Ω\nhm : LE.le m m₀\nX : Ω → Real\nμ : MeasureTheory.Measure Ω\nhμm : Not (MeasureTheory.SigmaFinite (μ.trim hm))\n⊢ Eq (ProbabilityTheory.condVar m X μ) 0","decl":"lemma condVar_of_not_sigmaFinite (hμm : ¬SigmaFinite (μ.trim hm)) :\n    Var[X ; μ | m] = 0 := by rw [condVar, condExp_of_not_sigmaFinite hm hμm]\n\n"}
{"name":"ProbabilityTheory.condVar_of_sigmaFinite","module":"Mathlib.Probability.CondVar","initialProofState":"Ω : Type u_1\nm₀ m : MeasurableSpace Ω\nhm : LE.le m m₀\nX : Ω → Real\nμ : MeasureTheory.Measure Ω\ninst✝ : MeasureTheory.SigmaFinite (μ.trim hm)\n⊢ Eq (ProbabilityTheory.condVar m X μ) (ite (MeasureTheory.Integrable (fun ω => HPow.hPow (HSub.hSub (X ω) (MeasureTheory.condExp m μ X ω)) 2) μ) (ite (MeasureTheory.StronglyMeasurable fun ω => HPow.hPow (HSub.hSub (X ω) (MeasureTheory.condExp m μ X ω)) 2) (fun ω => HPow.hPow (HSub.hSub (X ω) (MeasureTheory.condExp m μ X ω)) 2) (MeasureTheory.AEStronglyMeasurable.mk ↑↑(MeasureTheory.condExpL1 hm μ fun ω => HPow.hPow (HSub.hSub (X ω) (MeasureTheory.condExp m μ X ω)) 2) ⋯)) 0)","decl":"open scoped Classical in\nlemma condVar_of_sigmaFinite [SigmaFinite (μ.trim hm)] :\n    Var[X ; μ | m] =\n      if Integrable (fun ω ↦ (X ω - (μ[X | m]) ω) ^ 2) μ then\n        if StronglyMeasurable[m] (fun ω ↦ (X ω - (μ[X | m]) ω) ^ 2) then\n          fun ω ↦ (X ω - (μ[X | m]) ω) ^ 2\n        else aestronglyMeasurable_condExpL1.mk (condExpL1 hm μ fun ω ↦ (X ω - (μ[X | m]) ω) ^ 2)\n      else 0 := condExp_of_sigmaFinite _\n\n"}
{"name":"ProbabilityTheory.condVar_of_stronglyMeasurable","module":"Mathlib.Probability.CondVar","initialProofState":"Ω : Type u_1\nm₀ m : MeasurableSpace Ω\nhm : LE.le m m₀\nX : Ω → Real\nμ : MeasureTheory.Measure Ω\ninst✝ : MeasureTheory.SigmaFinite (μ.trim hm)\nhX : MeasureTheory.StronglyMeasurable X\nhXint : MeasureTheory.Integrable (HPow.hPow (HSub.hSub X (MeasureTheory.condExp m μ X)) 2) μ\n⊢ Eq (ProbabilityTheory.condVar m X μ) fun ω => HPow.hPow (HSub.hSub (X ω) (MeasureTheory.condExp m μ X ω)) 2","decl":"lemma condVar_of_stronglyMeasurable [SigmaFinite (μ.trim hm)]\n    (hX : StronglyMeasurable[m] X) (hXint : Integrable ((X - μ[X | m]) ^ 2) μ) :\n    Var[X ; μ | m] = fun ω ↦ (X ω - (μ[X | m]) ω) ^ 2 :=\n  condExp_of_stronglyMeasurable _ ((hX.sub stronglyMeasurable_condExp).pow _) hXint\n\n"}
{"name":"ProbabilityTheory.condVar_of_not_integrable","module":"Mathlib.Probability.CondVar","initialProofState":"Ω : Type u_1\nm₀ m : MeasurableSpace Ω\nX : Ω → Real\nμ : MeasureTheory.Measure Ω\nhXint : Not (MeasureTheory.Integrable (fun ω => HPow.hPow (HSub.hSub (X ω) (MeasureTheory.condExp m μ X ω)) 2) μ)\n⊢ Eq (ProbabilityTheory.condVar m X μ) 0","decl":"lemma condVar_of_not_integrable (hXint : ¬ Integrable (fun ω ↦ (X ω - (μ[X | m]) ω) ^ 2) μ) :\n    Var[X ; μ | m] = 0 := condExp_of_not_integrable hXint\n\n"}
{"name":"ProbabilityTheory.condVar_zero","module":"Mathlib.Probability.CondVar","initialProofState":"Ω : Type u_1\nm₀ m : MeasurableSpace Ω\nμ : MeasureTheory.Measure Ω\n⊢ Eq (ProbabilityTheory.condVar m 0 μ) 0","decl":"@[simp] lemma condVar_zero : Var[0 ; μ | m] = 0 := by simp [condVar]\n\n"}
{"name":"ProbabilityTheory.condVar_const","module":"Mathlib.Probability.CondVar","initialProofState":"Ω : Type u_1\nm₀ m : MeasurableSpace Ω\nμ : MeasureTheory.Measure Ω\nhm : LE.le m m₀\nc : Real\n⊢ Eq (ProbabilityTheory.condVar m (fun x => c) μ) 0","decl":"@[simp]\nlemma condVar_const (hm : m ≤ m₀) (c : ℝ) : Var[fun _ ↦ c ; μ | m] = 0 := by\n  obtain rfl | hc := eq_or_ne c 0\n  · simp [← Pi.zero_def]\n  by_cases hμm : IsFiniteMeasure μ\n  · simp [condVar, hm, Pi.pow_def]\n  · simp [condVar, condExp_of_not_integrable, integrable_const_iff_isFiniteMeasure hc,\n      integrable_const_iff_isFiniteMeasure <| pow_ne_zero _ hc, hμm, Pi.pow_def]\n\n"}
{"name":"ProbabilityTheory.stronglyMeasurable_condVar","module":"Mathlib.Probability.CondVar","initialProofState":"Ω : Type u_1\nm₀ m : MeasurableSpace Ω\nX : Ω → Real\nμ : MeasureTheory.Measure Ω\n⊢ MeasureTheory.StronglyMeasurable (ProbabilityTheory.condVar m X μ)","decl":"lemma stronglyMeasurable_condVar : StronglyMeasurable[m] (Var[X ; μ | m]) :=\n  stronglyMeasurable_condExp\n\n"}
{"name":"ProbabilityTheory.condVar_congr_ae","module":"Mathlib.Probability.CondVar","initialProofState":"Ω : Type u_1\nm₀ m : MeasurableSpace Ω\nX Y : Ω → Real\nμ : MeasureTheory.Measure Ω\nh : (MeasureTheory.ae μ).EventuallyEq X Y\n⊢ (MeasureTheory.ae μ).EventuallyEq (ProbabilityTheory.condVar m X μ) (ProbabilityTheory.condVar m Y μ)","decl":"lemma condVar_congr_ae (h : X =ᵐ[μ] Y) : Var[X ; μ | m] =ᵐ[μ] Var[Y ; μ | m] :=\n  condExp_congr_ae <| by filter_upwards [h, condExp_congr_ae h] with ω hω hω'; dsimp; rw [hω, hω']\n\n"}
{"name":"ProbabilityTheory.condVar_of_aestronglyMeasurable","module":"Mathlib.Probability.CondVar","initialProofState":"Ω : Type u_1\nm₀ m : MeasurableSpace Ω\nhm : LE.le m m₀\nX : Ω → Real\nμ : MeasureTheory.Measure Ω\nhμm : MeasureTheory.SigmaFinite (μ.trim hm)\nhX : MeasureTheory.AEStronglyMeasurable X μ\nhXint : MeasureTheory.Integrable (HPow.hPow (HSub.hSub X (MeasureTheory.condExp m μ X)) 2) μ\n⊢ (MeasureTheory.ae μ).EventuallyEq (ProbabilityTheory.condVar m X μ) (HPow.hPow (HSub.hSub X (MeasureTheory.condExp m μ X)) 2)","decl":"lemma condVar_of_aestronglyMeasurable [hμm : SigmaFinite (μ.trim hm)]\n    (hX : AEStronglyMeasurable[m] X μ) (hXint : Integrable ((X - μ[X | m]) ^ 2) μ) :\n    Var[X ; μ | m] =ᵐ[μ] (X - μ[X | m]) ^ 2 :=\n  condExp_of_aestronglyMeasurable' _ ((continuous_pow _).comp_aestronglyMeasurable\n    (hX.sub stronglyMeasurable_condExp.aestronglyMeasurable)) hXint\n\n"}
{"name":"ProbabilityTheory.integrable_condVar","module":"Mathlib.Probability.CondVar","initialProofState":"Ω : Type u_1\nm₀ m : MeasurableSpace Ω\nX : Ω → Real\nμ : MeasureTheory.Measure Ω\n⊢ MeasureTheory.Integrable (ProbabilityTheory.condVar m X μ) μ","decl":"lemma integrable_condVar : Integrable Var[X ; μ | m] μ := integrable_condExp\n\n"}
{"name":"ProbabilityTheory.setIntegral_condVar","module":"Mathlib.Probability.CondVar","initialProofState":"Ω : Type u_1\nm₀ m : MeasurableSpace Ω\nhm : LE.le m m₀\nX : Ω → Real\nμ : MeasureTheory.Measure Ω\ns : Set Ω\ninst✝ : MeasureTheory.SigmaFinite (μ.trim hm)\nhX : MeasureTheory.Integrable (HPow.hPow (HSub.hSub X (MeasureTheory.condExp m μ X)) 2) μ\nhs : MeasurableSet s\n⊢ Eq (MeasureTheory.integral (μ.restrict s) fun ω => ProbabilityTheory.condVar m X μ ω) (MeasureTheory.integral (μ.restrict s) fun ω => HPow.hPow (HSub.hSub (X ω) (MeasureTheory.condExp m μ X ω)) 2)","decl":"/-- The integral of the conditional variance `Var[X | m]` over an `m`-measurable set is equal to\nthe integral of `(X - μ[X | m]) ^ 2` on that set. -/\nlemma setIntegral_condVar [SigmaFinite (μ.trim hm)] (hX : Integrable ((X - μ[X | m]) ^ 2) μ)\n    (hs : MeasurableSet[m] s) :\n    ∫ ω in s, (Var[X ; μ | m]) ω ∂μ = ∫ ω in s, (X ω - (μ[X | m]) ω) ^ 2 ∂μ :=\n  setIntegral_condExp _ hX hs\n\n-- `(· ^ 2)` is a postfix operator called `_sq` in lemma names, but\n-- `condVar_ae_eq_condExp_sq_sub_condExp_sq` is a bit ridiculous, so we exceptionally denote it by\n-- `sq_` as it were a prefix.\n"}
{"name":"ProbabilityTheory.condVar_ae_eq_condExp_sq_sub_sq_condExp","module":"Mathlib.Probability.CondVar","initialProofState":"Ω : Type u_1\nm₀ m : MeasurableSpace Ω\nX : Ω → Real\nμ : MeasureTheory.Measure Ω\nhm : LE.le m m₀\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nhX : MeasureTheory.Memℒp X 2 μ\n⊢ (MeasureTheory.ae μ).EventuallyEq (ProbabilityTheory.condVar m X μ) (HSub.hSub (MeasureTheory.condExp m μ (HPow.hPow X 2)) (HPow.hPow (MeasureTheory.condExp m μ X) 2))","decl":"lemma condVar_ae_eq_condExp_sq_sub_sq_condExp (hm : m ≤ m₀) [IsFiniteMeasure μ] (hX : Memℒp X 2 μ) :\n    Var[X ; μ | m] =ᵐ[μ] μ[X ^ 2 | m] - μ[X | m] ^ 2 := by\n  calc\n    Var[X ; μ | m]\n    _ = μ[X ^ 2 - 2 * X * μ[X | m] + μ[X | m] ^ 2 | m] := by rw [condVar, sub_sq]\n    _ =ᵐ[μ] μ[X ^ 2 | m] - 2 * μ[X | m] ^ 2 + μ[X | m] ^ 2 := by\n      have aux₀ : Integrable (X ^ 2) μ := hX.integrable_sq\n      have aux₁ : Integrable (2 * X * μ[X | m]) μ := by\n        rw [mul_assoc]\n        refine (memℒp_one_iff_integrable.1 <| hX.condExp.mul hX ?_).const_mul _\n        simp [ENNReal.inv_two_add_inv_two]\n      have aux₂ : Integrable (μ[X | m] ^ 2) μ := hX.condExp.integrable_sq\n      filter_upwards [condExp_add (m := m) (aux₀.sub aux₁) aux₂, condExp_sub (m := m) aux₀ aux₁,\n        condExp_mul_of_stronglyMeasurable_right stronglyMeasurable_condExp aux₁\n          ((hX.integrable one_le_two).const_mul _), condExp_ofNat (m := m) 2 X]\n        with ω hω₀ hω₁ hω₂ hω₃\n      simp [hω₀, hω₁, hω₂, hω₃, condExp_const,\n        condExp_of_stronglyMeasurable hm (stronglyMeasurable_condExp.pow _) aux₂]\n      simp [mul_assoc, sq]\n    _ = μ[X ^ 2 | m] - μ[X | m] ^ 2 := by ring\n\n"}
{"name":"ProbabilityTheory.condVar_ae_le_condExp_sq","module":"Mathlib.Probability.CondVar","initialProofState":"Ω : Type u_1\nm₀ m : MeasurableSpace Ω\nX : Ω → Real\nμ : MeasureTheory.Measure Ω\nhm : LE.le m m₀\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nhX : MeasureTheory.Memℒp X 2 μ\n⊢ (MeasureTheory.ae μ).EventuallyLE (ProbabilityTheory.condVar m X μ) (MeasureTheory.condExp m μ (HPow.hPow X 2))","decl":"lemma condVar_ae_le_condExp_sq (hm : m ≤ m₀) [IsFiniteMeasure μ] (hX : Memℒp X 2 μ) :\n    Var[X ; μ | m] ≤ᵐ[μ] μ[X ^ 2 | m] := by\n  filter_upwards [condVar_ae_eq_condExp_sq_sub_sq_condExp hm hX] with ω hω\n  dsimp at hω\n  nlinarith\n\n"}
{"name":"ProbabilityTheory.integral_condVar_add_variance_condExp","module":"Mathlib.Probability.CondVar","initialProofState":"Ω : Type u_1\nm₀ m : MeasurableSpace Ω\nX : Ω → Real\nμ : MeasureTheory.Measure Ω\nhm : LE.le m m₀\ninst✝ : MeasureTheory.IsProbabilityMeasure μ\nhX : MeasureTheory.Memℒp X 2 μ\n⊢ Eq (HAdd.hAdd (MeasureTheory.integral μ fun x => ProbabilityTheory.condVar m X μ x) (ProbabilityTheory.variance (MeasureTheory.condExp m μ X) μ)) (ProbabilityTheory.variance X μ)","decl":"/-- **Law of total variance** -/\nlemma integral_condVar_add_variance_condExp (hm : m ≤ m₀) [IsProbabilityMeasure μ]\n    (hX : Memℒp X 2 μ) : μ[Var[X ; μ | m]] + Var[μ[X | m] ; μ] = Var[X ; μ] := by\n  calc\n    μ[Var[X ; μ | m]] + Var[μ[X | m] ; μ]\n    _ = μ[(μ[X ^ 2 | m] - μ[X | m] ^ 2 : Ω → ℝ)] + (μ[μ[X | m] ^ 2] - μ[μ[X | m]] ^ 2) := by\n      congr 1\n      · exact integral_congr_ae <| condVar_ae_eq_condExp_sq_sub_sq_condExp hm hX\n      · exact variance_def' hX.condExp\n    _ = μ[X ^ 2] - μ[μ[X | m] ^ 2] + (μ[μ[X | m] ^ 2] - μ[X] ^ 2) := by\n      rw [integral_sub' integrable_condExp, integral_condExp hm, integral_condExp hm]\n      exact hX.condExp.integrable_sq\n    _ = Var[X ; μ] := by rw [variance_def' hX]; ring\n\n"}
{"name":"ProbabilityTheory.condVar_bot'","module":"Mathlib.Probability.CondVar","initialProofState":"Ω : Type u_1\nm₀ : MeasurableSpace Ω\nμ : MeasureTheory.Measure Ω\ninst✝ : NeZero μ\nX : Ω → Real\n⊢ Eq (ProbabilityTheory.condVar Bot.bot X μ) fun x => MeasureTheory.average μ fun ω => HPow.hPow (HSub.hSub (X ω) (MeasureTheory.average μ fun ω' => X ω')) 2","decl":"lemma condVar_bot' [NeZero μ] (X : Ω → ℝ) :\n    Var[X ; μ | ⊥] = fun _ => ⨍ ω, (X ω - ⨍ ω', X ω' ∂μ) ^ 2 ∂μ := by\n  ext ω; simp [condVar, condExp_bot', average]\n\n"}
{"name":"ProbabilityTheory.condVar_bot_ae_eq","module":"Mathlib.Probability.CondVar","initialProofState":"Ω : Type u_1\nm₀ : MeasurableSpace Ω\nμ : MeasureTheory.Measure Ω\nX : Ω → Real\n⊢ (MeasureTheory.ae μ).EventuallyEq (ProbabilityTheory.condVar Bot.bot X μ) fun x => MeasureTheory.average μ fun ω => HPow.hPow (HSub.hSub (X ω) (MeasureTheory.average μ fun ω' => X ω')) 2","decl":"lemma condVar_bot_ae_eq (X : Ω → ℝ) :\n    Var[X ; μ | ⊥] =ᵐ[μ] fun _ ↦ ⨍ ω, (X ω - ⨍ ω', X ω' ∂μ) ^ 2 ∂μ := by\n  obtain rfl | hμ := eq_zero_or_neZero μ\n  · rw [ae_zero]\n    exact eventually_bot\n  · exact .of_forall <| congr_fun (condVar_bot' X)\n\n"}
{"name":"ProbabilityTheory.condVar_bot","module":"Mathlib.Probability.CondVar","initialProofState":"Ω : Type u_1\nm₀ : MeasurableSpace Ω\nX : Ω → Real\nμ : MeasureTheory.Measure Ω\ninst✝ : MeasureTheory.IsProbabilityMeasure μ\nhX : AEMeasurable X μ\n⊢ Eq (ProbabilityTheory.condVar Bot.bot X μ) fun _ω => ProbabilityTheory.variance X μ","decl":"lemma condVar_bot [IsProbabilityMeasure μ] (hX : AEMeasurable X μ) :\n    Var[X ; μ | ⊥] = fun _ω ↦ Var[X ; μ] := by\n  simp [condVar_bot', average_eq_integral, variance_eq_integral hX]\n\n"}
{"name":"ProbabilityTheory.condVar_smul","module":"Mathlib.Probability.CondVar","initialProofState":"Ω : Type u_1\nm₀ m : MeasurableSpace Ω\nμ : MeasureTheory.Measure Ω\nc : Real\nX : Ω → Real\n⊢ (MeasureTheory.ae μ).EventuallyEq (ProbabilityTheory.condVar m (HSMul.hSMul c X) μ) (HSMul.hSMul (HPow.hPow c 2) (ProbabilityTheory.condVar m X μ))","decl":"lemma condVar_smul (c : ℝ) (X : Ω → ℝ) : Var[c • X ; μ | m] =ᵐ[μ] c ^ 2 • Var[X ; μ | m] := by\n  calc\n    Var[c • X ; μ | m]\n    _ =ᵐ[μ] μ[c ^ 2 • (X - μ[X | m]) ^ 2 | m] := by\n      rw [condVar]\n      refine condExp_congr_ae ?_\n      filter_upwards [condExp_smul (m := m) c X] with ω hω\n      simp [hω, ← mul_sub, mul_pow]\n    _ =ᵐ[μ] c ^ 2 • Var[X ; μ | m] := condExp_smul ..\n\n"}
{"name":"ProbabilityTheory.condVar_neg","module":"Mathlib.Probability.CondVar","initialProofState":"Ω : Type u_1\nm₀ m : MeasurableSpace Ω\nμ : MeasureTheory.Measure Ω\nX : Ω → Real\n⊢ (MeasureTheory.ae μ).EventuallyEq (ProbabilityTheory.condVar m (Neg.neg X) μ) (ProbabilityTheory.condVar m X μ)","decl":"@[simp] lemma condVar_neg (X : Ω → ℝ) : Var[-X ; μ | m] =ᵐ[μ] Var[X ; μ | m] := by\n  refine condExp_congr_ae ?_\n  filter_upwards [condExp_neg (m := m) X] with ω hω\n  simp [condVar, hω]\n  ring\n\n"}
