{"name":"Profinite.exists_hom","module":"Mathlib.Topology.Category.Profinite.Extend","initialProofState":"I : Type u\ninst‚úù¬π : CategoryTheory.SmallCategory I\ninst‚úù : CategoryTheory.IsCofiltered I\nF : CategoryTheory.Functor I FintypeCat\nc : CategoryTheory.Limits.Cone (F.comp FintypeCat.toProfinite)\nhc : CategoryTheory.Limits.IsLimit c\nX : FintypeCat\nf : Quiver.Hom c.pt (FintypeCat.toProfinite.obj X)\n‚ä¢ Exists fun i => Exists fun g => Eq f (CategoryTheory.CategoryStruct.comp (c.œÄ.app i) (FintypeCat.toProfinite.map g))","decl":"/--\nA continuous map from a profinite set to a finite set factors through one of the components of\nthe profinite set when written as a cofiltered limit of finite sets.\n-/\nlemma exists_hom (hc : IsLimit c) {X : FintypeCat} (f : c.pt ‚ü∂ toProfinite.obj X) :\n    ‚àÉ (i : I) (g : F.obj i ‚ü∂ X), f = c.œÄ.app i ‚â´ toProfinite.map g := by\n  let _ : TopologicalSpace X := ‚ä•\n  have : DiscreteTopology (toProfinite.obj X) := ‚ü®rfl‚ü©\n  let f' : LocallyConstant c.pt (toProfinite.obj X) :=\n    ‚ü®f, (IsLocallyConstant.iff_continuous _).mpr f.continuous‚ü©\n  obtain ‚ü®i, g, h‚ü© := exists_locallyConstant.{_, u} c hc f'\n  refine ‚ü®i, (g : _ ‚Üí _), ?_‚ü©\n  ext x\n  exact LocallyConstant.congr_fun h x\n\n"}
{"name":"Profinite.Extend.functor_obj","module":"Mathlib.Topology.Category.Profinite.Extend","initialProofState":"I : Type u\ninst‚úù : CategoryTheory.SmallCategory I\nF : CategoryTheory.Functor I FintypeCat\nc : CategoryTheory.Limits.Cone (F.comp FintypeCat.toProfinite)\ni : I\n‚ä¢ Eq ((Profinite.Extend.functor c).obj i) (CategoryTheory.StructuredArrow.mk (c.œÄ.app i))","decl":"/--\nGiven a cone in `Profinite`, consisting of finite sets and indexed by a cofiltered category,\nwe obtain a functor from the indexing category to `StructuredArrow c.pt toProfinite`.\n-/\n@[simps]\ndef functor : I ‚•§ StructuredArrow c.pt toProfinite where\n  obj i := StructuredArrow.mk (c.œÄ.app i)\n  map f := StructuredArrow.homMk (F.map f) (c.w f)\n\n-- We check that the original diagram factors through `Profinite.Extend.functor`.\n"}
{"name":"Profinite.Extend.functor_map","module":"Mathlib.Topology.Category.Profinite.Extend","initialProofState":"I : Type u\ninst‚úù : CategoryTheory.SmallCategory I\nF : CategoryTheory.Functor I FintypeCat\nc : CategoryTheory.Limits.Cone (F.comp FintypeCat.toProfinite)\nX‚úù Y‚úù : I\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((Profinite.Extend.functor c).map f) (CategoryTheory.StructuredArrow.homMk (F.map f) ‚ãØ)","decl":"/--\nGiven a cone in `Profinite`, consisting of finite sets and indexed by a cofiltered category,\nwe obtain a functor from the indexing category to `StructuredArrow c.pt toProfinite`.\n-/\n@[simps]\ndef functor : I ‚•§ StructuredArrow c.pt toProfinite where\n  obj i := StructuredArrow.mk (c.œÄ.app i)\n  map f := StructuredArrow.homMk (F.map f) (c.w f)\n\n-- We check that the original diagram factors through `Profinite.Extend.functor`.\n"}
{"name":"Profinite.Extend.functorOp_obj","module":"Mathlib.Topology.Category.Profinite.Extend","initialProofState":"I : Type u\ninst‚úù : CategoryTheory.SmallCategory I\nF : CategoryTheory.Functor I FintypeCat\nc : CategoryTheory.Limits.Cone (F.comp FintypeCat.toProfinite)\nX : Opposite I\n‚ä¢ Eq ((Profinite.Extend.functorOp c).obj X) (CategoryTheory.CostructuredArrow.mk (c.œÄ.app (Opposite.unop X)).op)","decl":"/--\nGiven a cone in `Profinite`, consisting of finite sets and indexed by a cofiltered category,\nwe obtain a functor from the opposite of the indexing category to\n`CostructuredArrow toProfinite.op ‚ü®c.pt‚ü©`.\n-/\n@[simps! obj map]\ndef functorOp : I·µí·µñ ‚•§ CostructuredArrow toProfinite.op ‚ü®c.pt‚ü© :=\n  (functor c).op ‚ãô StructuredArrow.toCostructuredArrow _ _\n\n-- We check that the opposite of the original diagram factors through `Profinite.Extend.functorOp`.\n"}
{"name":"Profinite.Extend.functorOp_map","module":"Mathlib.Topology.Category.Profinite.Extend","initialProofState":"I : Type u\ninst‚úù : CategoryTheory.SmallCategory I\nF : CategoryTheory.Functor I FintypeCat\nc : CategoryTheory.Limits.Cone (F.comp FintypeCat.toProfinite)\nX‚úù Y‚úù : Opposite I\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((Profinite.Extend.functorOp c).map f) (CategoryTheory.CostructuredArrow.homMk (F.map f.unop).op ‚ãØ)","decl":"/--\nGiven a cone in `Profinite`, consisting of finite sets and indexed by a cofiltered category,\nwe obtain a functor from the opposite of the indexing category to\n`CostructuredArrow toProfinite.op ‚ü®c.pt‚ü©`.\n-/\n@[simps! obj map]\ndef functorOp : I·µí·µñ ‚•§ CostructuredArrow toProfinite.op ‚ü®c.pt‚ü© :=\n  (functor c).op ‚ãô StructuredArrow.toCostructuredArrow _ _\n\n-- We check that the opposite of the original diagram factors through `Profinite.Extend.functorOp`.\n"}
{"name":"Profinite.Extend.functor_initial","module":"Mathlib.Topology.Category.Profinite.Extend","initialProofState":"I : Type u\ninst‚úù¬≤ : CategoryTheory.SmallCategory I\ninst‚úù¬π : CategoryTheory.IsCofiltered I\nF : CategoryTheory.Functor I FintypeCat\nc : CategoryTheory.Limits.Cone (F.comp FintypeCat.toProfinite)\nhc : CategoryTheory.Limits.IsLimit c\ninst‚úù : ‚àÄ (i : I), CategoryTheory.Epi (c.œÄ.app i)\n‚ä¢ (Profinite.Extend.functor c).Initial","decl":"/--\nIf the projection maps in the cone are epimorphic and the cone is limiting, then\n`Profinite.Extend.functor` is initial.\n\nTODO: investigate how to weaken the assumption `‚àÄ i, Epi (c.œÄ.app i)` to\n`‚àÄ i, ‚àÉ j (_ : j ‚ü∂ i), Epi (c.œÄ.app j)`.\n-/\nlemma functor_initial (hc : IsLimit c) [‚àÄ i, Epi (c.œÄ.app i)] : Initial (functor c) := by\n  let e : I ‚âå ULiftHom.{w} (ULift.{w} I) := ULiftHomULiftCategory.equiv _\n  suffices (e.inverse ‚ãô functor c).Initial from initial_of_equivalence_comp e.inverse (functor c)\n  rw [initial_iff_of_isCofiltered (F := e.inverse ‚ãô functor c)]\n  constructor\n  ¬∑ intro ‚ü®_, X, (f : c.pt ‚ü∂ _)‚ü©\n    obtain ‚ü®i, g, h‚ü© := exists_hom c hc f\n    refine ‚ü®‚ü®i‚ü©, ‚ü®StructuredArrow.homMk g h.symm‚ü©‚ü©\n  ¬∑ intro ‚ü®_, X, (f : c.pt ‚ü∂ _)‚ü© ‚ü®i‚ü© ‚ü®_, (s : F.obj i ‚ü∂ X), (w : f = c.œÄ.app i ‚â´ _)‚ü©\n      ‚ü®_, (s' : F.obj i ‚ü∂ X), (w' : f = c.œÄ.app i ‚â´ _)‚ü©\n    simp only [functor_obj, functor_map, StructuredArrow.hom_eq_iff, StructuredArrow.mk_right,\n      StructuredArrow.comp_right, StructuredArrow.homMk_right]\n    refine ‚ü®‚ü®i‚ü©, ùüô _, ?_‚ü©\n    simp only [CategoryTheory.Functor.map_id, Category.id_comp]\n    rw [w] at w'\n    exact toProfinite.map_injective <| Epi.left_cancellation _ _ w'\n\n"}
{"name":"Profinite.Extend.functorOp_final","module":"Mathlib.Topology.Category.Profinite.Extend","initialProofState":"I : Type u\ninst‚úù¬≤ : CategoryTheory.SmallCategory I\ninst‚úù¬π : CategoryTheory.IsCofiltered I\nF : CategoryTheory.Functor I FintypeCat\nc : CategoryTheory.Limits.Cone (F.comp FintypeCat.toProfinite)\nhc : CategoryTheory.Limits.IsLimit c\ninst‚úù : ‚àÄ (i : I), CategoryTheory.Epi (c.œÄ.app i)\n‚ä¢ (Profinite.Extend.functorOp c).Final","decl":"/--\nIf the projection maps in the cone are epimorphic and the cone is limiting, then\n`Profinite.Extend.functorOp` is final.\n-/\nlemma functorOp_final (hc : IsLimit c) [‚àÄ i, Epi (c.œÄ.app i)] : Final (functorOp c) := by\n  have := functor_initial c hc\n  have : ((StructuredArrow.toCostructuredArrow toProfinite c.pt)).IsEquivalence  :=\n    (inferInstance : (structuredArrowOpEquivalence _ _).functor.IsEquivalence )\n  exact Functor.final_comp (functor c).op _\n\n"}
{"name":"Profinite.Extend.cone_pt","module":"Mathlib.Topology.Category.Profinite.Extend","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nG : CategoryTheory.Functor Profinite C\nS : Profinite\n‚ä¢ Eq (Profinite.Extend.cone G S).pt (G.obj S)","decl":"/--\nGiven a functor `G` from `Profinite` and `S : Profinite`, we obtain a cone on\n`(StructuredArrow.proj S toProfinite ‚ãô toProfinite ‚ãô G)` with cone point `G.obj S`.\n\nWhiskering this cone with `Profinite.Extend.functor c` gives `G.mapCone c` as we check in the\nexample below.\n-/\n@[simps]\ndef cone (S : Profinite) :\n    Cone (StructuredArrow.proj S toProfinite ‚ãô toProfinite ‚ãô G) where\n  pt := G.obj S\n  œÄ := {\n    app := fun i ‚Ü¶ G.map i.hom\n    naturality := fun _ _ f ‚Ü¶ (by simp [‚Üê map_comp]) }\n\n"}
{"name":"Profinite.Extend.cone_œÄ_app","module":"Mathlib.Topology.Category.Profinite.Extend","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nG : CategoryTheory.Functor Profinite C\nS : Profinite\ni : CategoryTheory.StructuredArrow S FintypeCat.toProfinite\n‚ä¢ Eq ((Profinite.Extend.cone G S).œÄ.app i) (G.map i.hom)","decl":"/--\nGiven a functor `G` from `Profinite` and `S : Profinite`, we obtain a cone on\n`(StructuredArrow.proj S toProfinite ‚ãô toProfinite ‚ãô G)` with cone point `G.obj S`.\n\nWhiskering this cone with `Profinite.Extend.functor c` gives `G.mapCone c` as we check in the\nexample below.\n-/\n@[simps]\ndef cone (S : Profinite) :\n    Cone (StructuredArrow.proj S toProfinite ‚ãô toProfinite ‚ãô G) where\n  pt := G.obj S\n  œÄ := {\n    app := fun i ‚Ü¶ G.map i.hom\n    naturality := fun _ _ f ‚Ü¶ (by simp [‚Üê map_comp]) }\n\n"}
{"name":"Profinite.Extend.cocone_Œπ_app","module":"Mathlib.Topology.Category.Profinite.Extend","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nG : CategoryTheory.Functor (Opposite Profinite) C\nS : Profinite\ni : CategoryTheory.CostructuredArrow FintypeCat.toProfinite.op { unop := S }\n‚ä¢ Eq ((Profinite.Extend.cocone G S).Œπ.app i) (G.map i.hom)","decl":"/--\nGiven a functor `G` from `Profinite·µí·µñ` and `S : Profinite`, we obtain a cocone on\n`(CostructuredArrow.proj toProfinite.op ‚ü®S‚ü© ‚ãô toProfinite.op ‚ãô G)` with cocone point `G.obj ‚ü®S‚ü©`.\n\nWhiskering this cocone with `Profinite.Extend.functorOp c` gives `G.mapCocone c.op` as we check in\nthe example below.\n-/\n@[simps]\ndef cocone (S : Profinite) :\n    Cocone (CostructuredArrow.proj toProfinite.op ‚ü®S‚ü© ‚ãô toProfinite.op ‚ãô G) where\n  pt := G.obj ‚ü®S‚ü©\n  Œπ := {\n    app := fun i ‚Ü¶ G.map i.hom\n    naturality := fun _ _ f ‚Ü¶ (by\n      have := f.w\n      simp only [op_obj, const_obj_obj, op_map, CostructuredArrow.right_eq_id, const_obj_map,\n        Category.comp_id] at this\n      simp [‚Üê map_comp, this]) }\n\n"}
{"name":"Profinite.Extend.cocone_pt","module":"Mathlib.Topology.Category.Profinite.Extend","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nG : CategoryTheory.Functor (Opposite Profinite) C\nS : Profinite\n‚ä¢ Eq (Profinite.Extend.cocone G S).pt (G.obj { unop := S })","decl":"/--\nGiven a functor `G` from `Profinite·µí·µñ` and `S : Profinite`, we obtain a cocone on\n`(CostructuredArrow.proj toProfinite.op ‚ü®S‚ü© ‚ãô toProfinite.op ‚ãô G)` with cocone point `G.obj ‚ü®S‚ü©`.\n\nWhiskering this cocone with `Profinite.Extend.functorOp c` gives `G.mapCocone c.op` as we check in\nthe example below.\n-/\n@[simps]\ndef cocone (S : Profinite) :\n    Cocone (CostructuredArrow.proj toProfinite.op ‚ü®S‚ü© ‚ãô toProfinite.op ‚ãô G) where\n  pt := G.obj ‚ü®S‚ü©\n  Œπ := {\n    app := fun i ‚Ü¶ G.map i.hom\n    naturality := fun _ _ f ‚Ü¶ (by\n      have := f.w\n      simp only [op_obj, const_obj_obj, op_map, CostructuredArrow.right_eq_id, const_obj_map,\n        Category.comp_id] at this\n      simp [‚Üê map_comp, this]) }\n\n"}
{"name":"Profinite.instEpiAppDiscreteQuotientŒ±TopologicalSpaceToTopTotallyDisconnectedSpaceœÄAsLimitCone","module":"Mathlib.Topology.Category.Profinite.Extend","initialProofState":"S : Profinite\ni : DiscreteQuotient ‚ÜëS.toTop\n‚ä¢ CategoryTheory.Epi (S.asLimitCone.œÄ.app i)","decl":"instance (i : DiscreteQuotient S) : Epi (S.asLimitCone.œÄ.app i) :=\n  (epi_iff_surjective _).mpr i.proj_surjective\n\n"}
