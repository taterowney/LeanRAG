{"name":"VitaliFamily.mk.injEq","module":"Mathlib.MeasureTheory.Covering.VitaliFamily","initialProofState":"X : Type u_1\ninst‚úù : PseudoMetricSpace X\nm : MeasurableSpace X\nŒº : MeasureTheory.Measure X\nsetsAt‚úù : X ‚Üí Set (Set X)\nmeasurableSet‚úù : ‚àÄ (x : X) (s : Set X), Membership.mem (setsAt‚úù x) s ‚Üí MeasurableSet s\nnonempty_interior‚úù : ‚àÄ (x : X) (s : Set X), Membership.mem (setsAt‚úù x) s ‚Üí (interior s).Nonempty\nnontrivial‚úù : ‚àÄ (x : X) (Œµ : Real), GT.gt Œµ 0 ‚Üí Exists fun s => And (Membership.mem (setsAt‚úù x) s) (HasSubset.Subset s (Metric.closedBall x Œµ))\ncovering‚úù : ‚àÄ (s : Set X) (f : X ‚Üí Set (Set X)), (‚àÄ (x : X), Membership.mem s x ‚Üí HasSubset.Subset (f x) (setsAt‚úù x)) ‚Üí (‚àÄ (x : X), Membership.mem s x ‚Üí ‚àÄ (Œµ : Real), GT.gt Œµ 0 ‚Üí Exists fun t => And (Membership.mem (f x) t) (HasSubset.Subset t (Metric.closedBall x Œµ))) ‚Üí Exists fun t => And (‚àÄ (p : Prod X (Set X)), Membership.mem t p ‚Üí Membership.mem s p.1) (And (t.PairwiseDisjoint fun p => p.2) (And (‚àÄ (p : Prod X (Set X)), Membership.mem t p ‚Üí Membership.mem (f p.1) p.2) (Eq (Œº (SDiff.sdiff s (Set.iUnion fun p => Set.iUnion fun h => p.2))) 0)))\nsetsAt : X ‚Üí Set (Set X)\nmeasurableSet : ‚àÄ (x : X) (s : Set X), Membership.mem (setsAt x) s ‚Üí MeasurableSet s\nnonempty_interior : ‚àÄ (x : X) (s : Set X), Membership.mem (setsAt x) s ‚Üí (interior s).Nonempty\nnontrivial : ‚àÄ (x : X) (Œµ : Real), GT.gt Œµ 0 ‚Üí Exists fun s => And (Membership.mem (setsAt x) s) (HasSubset.Subset s (Metric.closedBall x Œµ))\ncovering : ‚àÄ (s : Set X) (f : X ‚Üí Set (Set X)), (‚àÄ (x : X), Membership.mem s x ‚Üí HasSubset.Subset (f x) (setsAt x)) ‚Üí (‚àÄ (x : X), Membership.mem s x ‚Üí ‚àÄ (Œµ : Real), GT.gt Œµ 0 ‚Üí Exists fun t => And (Membership.mem (f x) t) (HasSubset.Subset t (Metric.closedBall x Œµ))) ‚Üí Exists fun t => And (‚àÄ (p : Prod X (Set X)), Membership.mem t p ‚Üí Membership.mem s p.1) (And (t.PairwiseDisjoint fun p => p.2) (And (‚àÄ (p : Prod X (Set X)), Membership.mem t p ‚Üí Membership.mem (f p.1) p.2) (Eq (Œº (SDiff.sdiff s (Set.iUnion fun p => Set.iUnion fun h => p.2))) 0)))\n‚ä¢ Eq (Eq { setsAt := setsAt‚úù, measurableSet := measurableSet‚úù, nonempty_interior := nonempty_interior‚úù, nontrivial := nontrivial‚úù, covering := covering‚úù } { setsAt := setsAt, measurableSet := measurableSet, nonempty_interior := nonempty_interior, nontrivial := nontrivial, covering := covering }) (Eq setsAt‚úù setsAt)","decl":"/-- On a metric space `X` with a measure `Œº`, consider for each `x : X` a family of measurable sets\nwith nonempty interiors, called `setsAt x`. This family is a Vitali family if it satisfies the\nfollowing property: consider a (possibly non-measurable) set `s`, and for any `x` in `s` a\nsubfamily `f x` of `setsAt x` containing sets of arbitrarily small diameter. Then one can extract\na disjoint subfamily covering almost all `s`.\n\nVitali families are provided by covering theorems such as the Besicovitch covering theorem or the\nVitali covering theorem. They make it possible to formulate general versions of theorems on\ndifferentiations of measure that apply in both contexts.\n-/\nstructure VitaliFamily {m : MeasurableSpace X} (Œº : Measure X) where\n  /-- Sets of the family \"centered\" at a given point. -/\n  setsAt :  X ‚Üí Set (Set X)\n  /-- All sets of the family are measurable. -/\n  measurableSet : ‚àÄ x : X, ‚àÄ s ‚àà setsAt x, MeasurableSet s\n  /-- All sets of the family have nonempty interior. -/\n  nonempty_interior : ‚àÄ x : X, ‚àÄ s ‚àà setsAt x, (interior s).Nonempty\n  /-- For any closed ball around `x`, there exists a set of the family contained in this ball. -/\n  nontrivial : ‚àÄ (x : X), ‚àÄ Œµ > (0 : ‚Ñù), ‚àÉ s ‚àà setsAt x, s ‚äÜ closedBall x Œµ\n  /-- Consider a (possibly non-measurable) set `s`,\n  and for any `x` in `s` a subfamily `f x` of `setsAt x`\n  containing sets of arbitrarily small diameter.\n  Then one can extract a disjoint subfamily covering almost all `s`. -/\n  covering : ‚àÄ (s : Set X) (f : X ‚Üí Set (Set X)),\n    (‚àÄ x ‚àà s, f x ‚äÜ setsAt x) ‚Üí (‚àÄ x ‚àà s, ‚àÄ Œµ > (0 : ‚Ñù), ‚àÉ t ‚àà f x, t ‚äÜ closedBall x Œµ) ‚Üí\n    ‚àÉ t : Set (X √ó Set X), (‚àÄ p ‚àà t, p.1 ‚àà s) ‚àß (t.PairwiseDisjoint fun p ‚Ü¶ p.2) ‚àß\n      (‚àÄ p ‚àà t, p.2 ‚àà f p.1) ‚àß Œº (s \\ ‚ãÉ p ‚àà t, p.2) = 0\n\n"}
{"name":"VitaliFamily.mk.inj","module":"Mathlib.MeasureTheory.Covering.VitaliFamily","initialProofState":"X : Type u_1\ninst‚úù : PseudoMetricSpace X\nm : MeasurableSpace X\nŒº : MeasureTheory.Measure X\nsetsAt‚úù : X ‚Üí Set (Set X)\nmeasurableSet‚úù : ‚àÄ (x : X) (s : Set X), Membership.mem (setsAt‚úù x) s ‚Üí MeasurableSet s\nnonempty_interior‚úù : ‚àÄ (x : X) (s : Set X), Membership.mem (setsAt‚úù x) s ‚Üí (interior s).Nonempty\nnontrivial‚úù : ‚àÄ (x : X) (Œµ : Real), GT.gt Œµ 0 ‚Üí Exists fun s => And (Membership.mem (setsAt‚úù x) s) (HasSubset.Subset s (Metric.closedBall x Œµ))\ncovering‚úù : ‚àÄ (s : Set X) (f : X ‚Üí Set (Set X)), (‚àÄ (x : X), Membership.mem s x ‚Üí HasSubset.Subset (f x) (setsAt‚úù x)) ‚Üí (‚àÄ (x : X), Membership.mem s x ‚Üí ‚àÄ (Œµ : Real), GT.gt Œµ 0 ‚Üí Exists fun t => And (Membership.mem (f x) t) (HasSubset.Subset t (Metric.closedBall x Œµ))) ‚Üí Exists fun t => And (‚àÄ (p : Prod X (Set X)), Membership.mem t p ‚Üí Membership.mem s p.1) (And (t.PairwiseDisjoint fun p => p.2) (And (‚àÄ (p : Prod X (Set X)), Membership.mem t p ‚Üí Membership.mem (f p.1) p.2) (Eq (Œº (SDiff.sdiff s (Set.iUnion fun p => Set.iUnion fun h => p.2))) 0)))\nsetsAt : X ‚Üí Set (Set X)\nmeasurableSet : ‚àÄ (x : X) (s : Set X), Membership.mem (setsAt x) s ‚Üí MeasurableSet s\nnonempty_interior : ‚àÄ (x : X) (s : Set X), Membership.mem (setsAt x) s ‚Üí (interior s).Nonempty\nnontrivial : ‚àÄ (x : X) (Œµ : Real), GT.gt Œµ 0 ‚Üí Exists fun s => And (Membership.mem (setsAt x) s) (HasSubset.Subset s (Metric.closedBall x Œµ))\ncovering : ‚àÄ (s : Set X) (f : X ‚Üí Set (Set X)), (‚àÄ (x : X), Membership.mem s x ‚Üí HasSubset.Subset (f x) (setsAt x)) ‚Üí (‚àÄ (x : X), Membership.mem s x ‚Üí ‚àÄ (Œµ : Real), GT.gt Œµ 0 ‚Üí Exists fun t => And (Membership.mem (f x) t) (HasSubset.Subset t (Metric.closedBall x Œµ))) ‚Üí Exists fun t => And (‚àÄ (p : Prod X (Set X)), Membership.mem t p ‚Üí Membership.mem s p.1) (And (t.PairwiseDisjoint fun p => p.2) (And (‚àÄ (p : Prod X (Set X)), Membership.mem t p ‚Üí Membership.mem (f p.1) p.2) (Eq (Œº (SDiff.sdiff s (Set.iUnion fun p => Set.iUnion fun h => p.2))) 0)))\nx‚úù : Eq { setsAt := setsAt‚úù, measurableSet := measurableSet‚úù, nonempty_interior := nonempty_interior‚úù, nontrivial := nontrivial‚úù, covering := covering‚úù } { setsAt := setsAt, measurableSet := measurableSet, nonempty_interior := nonempty_interior, nontrivial := nontrivial, covering := covering }\n‚ä¢ Eq setsAt‚úù setsAt","decl":"/-- On a metric space `X` with a measure `Œº`, consider for each `x : X` a family of measurable sets\nwith nonempty interiors, called `setsAt x`. This family is a Vitali family if it satisfies the\nfollowing property: consider a (possibly non-measurable) set `s`, and for any `x` in `s` a\nsubfamily `f x` of `setsAt x` containing sets of arbitrarily small diameter. Then one can extract\na disjoint subfamily covering almost all `s`.\n\nVitali families are provided by covering theorems such as the Besicovitch covering theorem or the\nVitali covering theorem. They make it possible to formulate general versions of theorems on\ndifferentiations of measure that apply in both contexts.\n-/\nstructure VitaliFamily {m : MeasurableSpace X} (Œº : Measure X) where\n  /-- Sets of the family \"centered\" at a given point. -/\n  setsAt :  X ‚Üí Set (Set X)\n  /-- All sets of the family are measurable. -/\n  measurableSet : ‚àÄ x : X, ‚àÄ s ‚àà setsAt x, MeasurableSet s\n  /-- All sets of the family have nonempty interior. -/\n  nonempty_interior : ‚àÄ x : X, ‚àÄ s ‚àà setsAt x, (interior s).Nonempty\n  /-- For any closed ball around `x`, there exists a set of the family contained in this ball. -/\n  nontrivial : ‚àÄ (x : X), ‚àÄ Œµ > (0 : ‚Ñù), ‚àÉ s ‚àà setsAt x, s ‚äÜ closedBall x Œµ\n  /-- Consider a (possibly non-measurable) set `s`,\n  and for any `x` in `s` a subfamily `f x` of `setsAt x`\n  containing sets of arbitrarily small diameter.\n  Then one can extract a disjoint subfamily covering almost all `s`. -/\n  covering : ‚àÄ (s : Set X) (f : X ‚Üí Set (Set X)),\n    (‚àÄ x ‚àà s, f x ‚äÜ setsAt x) ‚Üí (‚àÄ x ‚àà s, ‚àÄ Œµ > (0 : ‚Ñù), ‚àÉ t ‚àà f x, t ‚äÜ closedBall x Œµ) ‚Üí\n    ‚àÉ t : Set (X √ó Set X), (‚àÄ p ‚àà t, p.1 ‚àà s) ‚àß (t.PairwiseDisjoint fun p ‚Ü¶ p.2) ‚àß\n      (‚àÄ p ‚àà t, p.2 ‚àà f p.1) ‚àß Œº (s \\ ‚ãÉ p ‚àà t, p.2) = 0\n\n"}
{"name":"VitaliFamily.measurableSet","module":"Mathlib.MeasureTheory.Covering.VitaliFamily","initialProofState":"X : Type u_1\ninst‚úù : PseudoMetricSpace X\nm : MeasurableSpace X\nŒº : MeasureTheory.Measure X\nself : VitaliFamily Œº\nx : X\ns : Set X\na‚úù : Membership.mem (self.setsAt x) s\n‚ä¢ MeasurableSet s","decl":"/-- On a metric space `X` with a measure `Œº`, consider for each `x : X` a family of measurable sets\nwith nonempty interiors, called `setsAt x`. This family is a Vitali family if it satisfies the\nfollowing property: consider a (possibly non-measurable) set `s`, and for any `x` in `s` a\nsubfamily `f x` of `setsAt x` containing sets of arbitrarily small diameter. Then one can extract\na disjoint subfamily covering almost all `s`.\n\nVitali families are provided by covering theorems such as the Besicovitch covering theorem or the\nVitali covering theorem. They make it possible to formulate general versions of theorems on\ndifferentiations of measure that apply in both contexts.\n-/\nstructure VitaliFamily {m : MeasurableSpace X} (Œº : Measure X) where\n  /-- Sets of the family \"centered\" at a given point. -/\n  setsAt :  X ‚Üí Set (Set X)\n  /-- All sets of the family are measurable. -/\n  measurableSet : ‚àÄ x : X, ‚àÄ s ‚àà setsAt x, MeasurableSet s\n  /-- All sets of the family have nonempty interior. -/\n  nonempty_interior : ‚àÄ x : X, ‚àÄ s ‚àà setsAt x, (interior s).Nonempty\n  /-- For any closed ball around `x`, there exists a set of the family contained in this ball. -/\n  nontrivial : ‚àÄ (x : X), ‚àÄ Œµ > (0 : ‚Ñù), ‚àÉ s ‚àà setsAt x, s ‚äÜ closedBall x Œµ\n  /-- Consider a (possibly non-measurable) set `s`,\n  and for any `x` in `s` a subfamily `f x` of `setsAt x`\n  containing sets of arbitrarily small diameter.\n  Then one can extract a disjoint subfamily covering almost all `s`. -/\n  covering : ‚àÄ (s : Set X) (f : X ‚Üí Set (Set X)),\n    (‚àÄ x ‚àà s, f x ‚äÜ setsAt x) ‚Üí (‚àÄ x ‚àà s, ‚àÄ Œµ > (0 : ‚Ñù), ‚àÉ t ‚àà f x, t ‚äÜ closedBall x Œµ) ‚Üí\n    ‚àÉ t : Set (X √ó Set X), (‚àÄ p ‚àà t, p.1 ‚àà s) ‚àß (t.PairwiseDisjoint fun p ‚Ü¶ p.2) ‚àß\n      (‚àÄ p ‚àà t, p.2 ‚àà f p.1) ‚àß Œº (s \\ ‚ãÉ p ‚àà t, p.2) = 0\n\n"}
{"name":"VitaliFamily.nontrivial","module":"Mathlib.MeasureTheory.Covering.VitaliFamily","initialProofState":"X : Type u_1\ninst‚úù : PseudoMetricSpace X\nm : MeasurableSpace X\nŒº : MeasureTheory.Measure X\nself : VitaliFamily Œº\nx : X\nŒµ : Real\na‚úù : GT.gt Œµ 0\n‚ä¢ Exists fun s => And (Membership.mem (self.setsAt x) s) (HasSubset.Subset s (Metric.closedBall x Œµ))","decl":"/-- On a metric space `X` with a measure `Œº`, consider for each `x : X` a family of measurable sets\nwith nonempty interiors, called `setsAt x`. This family is a Vitali family if it satisfies the\nfollowing property: consider a (possibly non-measurable) set `s`, and for any `x` in `s` a\nsubfamily `f x` of `setsAt x` containing sets of arbitrarily small diameter. Then one can extract\na disjoint subfamily covering almost all `s`.\n\nVitali families are provided by covering theorems such as the Besicovitch covering theorem or the\nVitali covering theorem. They make it possible to formulate general versions of theorems on\ndifferentiations of measure that apply in both contexts.\n-/\nstructure VitaliFamily {m : MeasurableSpace X} (Œº : Measure X) where\n  /-- Sets of the family \"centered\" at a given point. -/\n  setsAt :  X ‚Üí Set (Set X)\n  /-- All sets of the family are measurable. -/\n  measurableSet : ‚àÄ x : X, ‚àÄ s ‚àà setsAt x, MeasurableSet s\n  /-- All sets of the family have nonempty interior. -/\n  nonempty_interior : ‚àÄ x : X, ‚àÄ s ‚àà setsAt x, (interior s).Nonempty\n  /-- For any closed ball around `x`, there exists a set of the family contained in this ball. -/\n  nontrivial : ‚àÄ (x : X), ‚àÄ Œµ > (0 : ‚Ñù), ‚àÉ s ‚àà setsAt x, s ‚äÜ closedBall x Œµ\n  /-- Consider a (possibly non-measurable) set `s`,\n  and for any `x` in `s` a subfamily `f x` of `setsAt x`\n  containing sets of arbitrarily small diameter.\n  Then one can extract a disjoint subfamily covering almost all `s`. -/\n  covering : ‚àÄ (s : Set X) (f : X ‚Üí Set (Set X)),\n    (‚àÄ x ‚àà s, f x ‚äÜ setsAt x) ‚Üí (‚àÄ x ‚àà s, ‚àÄ Œµ > (0 : ‚Ñù), ‚àÉ t ‚àà f x, t ‚äÜ closedBall x Œµ) ‚Üí\n    ‚àÉ t : Set (X √ó Set X), (‚àÄ p ‚àà t, p.1 ‚àà s) ‚àß (t.PairwiseDisjoint fun p ‚Ü¶ p.2) ‚àß\n      (‚àÄ p ‚àà t, p.2 ‚àà f p.1) ‚àß Œº (s \\ ‚ãÉ p ‚àà t, p.2) = 0\n\n"}
{"name":"VitaliFamily.nonempty_interior","module":"Mathlib.MeasureTheory.Covering.VitaliFamily","initialProofState":"X : Type u_1\ninst‚úù : PseudoMetricSpace X\nm : MeasurableSpace X\nŒº : MeasureTheory.Measure X\nself : VitaliFamily Œº\nx : X\ns : Set X\na‚úù : Membership.mem (self.setsAt x) s\n‚ä¢ (interior s).Nonempty","decl":"/-- On a metric space `X` with a measure `Œº`, consider for each `x : X` a family of measurable sets\nwith nonempty interiors, called `setsAt x`. This family is a Vitali family if it satisfies the\nfollowing property: consider a (possibly non-measurable) set `s`, and for any `x` in `s` a\nsubfamily `f x` of `setsAt x` containing sets of arbitrarily small diameter. Then one can extract\na disjoint subfamily covering almost all `s`.\n\nVitali families are provided by covering theorems such as the Besicovitch covering theorem or the\nVitali covering theorem. They make it possible to formulate general versions of theorems on\ndifferentiations of measure that apply in both contexts.\n-/\nstructure VitaliFamily {m : MeasurableSpace X} (Œº : Measure X) where\n  /-- Sets of the family \"centered\" at a given point. -/\n  setsAt :  X ‚Üí Set (Set X)\n  /-- All sets of the family are measurable. -/\n  measurableSet : ‚àÄ x : X, ‚àÄ s ‚àà setsAt x, MeasurableSet s\n  /-- All sets of the family have nonempty interior. -/\n  nonempty_interior : ‚àÄ x : X, ‚àÄ s ‚àà setsAt x, (interior s).Nonempty\n  /-- For any closed ball around `x`, there exists a set of the family contained in this ball. -/\n  nontrivial : ‚àÄ (x : X), ‚àÄ Œµ > (0 : ‚Ñù), ‚àÉ s ‚àà setsAt x, s ‚äÜ closedBall x Œµ\n  /-- Consider a (possibly non-measurable) set `s`,\n  and for any `x` in `s` a subfamily `f x` of `setsAt x`\n  containing sets of arbitrarily small diameter.\n  Then one can extract a disjoint subfamily covering almost all `s`. -/\n  covering : ‚àÄ (s : Set X) (f : X ‚Üí Set (Set X)),\n    (‚àÄ x ‚àà s, f x ‚äÜ setsAt x) ‚Üí (‚àÄ x ‚àà s, ‚àÄ Œµ > (0 : ‚Ñù), ‚àÉ t ‚àà f x, t ‚äÜ closedBall x Œµ) ‚Üí\n    ‚àÉ t : Set (X √ó Set X), (‚àÄ p ‚àà t, p.1 ‚àà s) ‚àß (t.PairwiseDisjoint fun p ‚Ü¶ p.2) ‚àß\n      (‚àÄ p ‚àà t, p.2 ‚àà f p.1) ‚àß Œº (s \\ ‚ãÉ p ‚àà t, p.2) = 0\n\n"}
{"name":"VitaliFamily.mk.sizeOf_spec","module":"Mathlib.MeasureTheory.Covering.VitaliFamily","initialProofState":"X : Type u_1\ninst‚úù¬π : PseudoMetricSpace X\nm : MeasurableSpace X\nŒº : MeasureTheory.Measure X\ninst‚úù : SizeOf X\nsetsAt : X ‚Üí Set (Set X)\nmeasurableSet : ‚àÄ (x : X) (s : Set X), Membership.mem (setsAt x) s ‚Üí MeasurableSet s\nnonempty_interior : ‚àÄ (x : X) (s : Set X), Membership.mem (setsAt x) s ‚Üí (interior s).Nonempty\nnontrivial : ‚àÄ (x : X) (Œµ : Real), GT.gt Œµ 0 ‚Üí Exists fun s => And (Membership.mem (setsAt x) s) (HasSubset.Subset s (Metric.closedBall x Œµ))\ncovering : ‚àÄ (s : Set X) (f : X ‚Üí Set (Set X)), (‚àÄ (x : X), Membership.mem s x ‚Üí HasSubset.Subset (f x) (setsAt x)) ‚Üí (‚àÄ (x : X), Membership.mem s x ‚Üí ‚àÄ (Œµ : Real), GT.gt Œµ 0 ‚Üí Exists fun t => And (Membership.mem (f x) t) (HasSubset.Subset t (Metric.closedBall x Œµ))) ‚Üí Exists fun t => And (‚àÄ (p : Prod X (Set X)), Membership.mem t p ‚Üí Membership.mem s p.1) (And (t.PairwiseDisjoint fun p => p.2) (And (‚àÄ (p : Prod X (Set X)), Membership.mem t p ‚Üí Membership.mem (f p.1) p.2) (Eq (Œº (SDiff.sdiff s (Set.iUnion fun p => Set.iUnion fun h => p.2))) 0)))\n‚ä¢ Eq (SizeOf.sizeOf { setsAt := setsAt, measurableSet := measurableSet, nonempty_interior := nonempty_interior, nontrivial := nontrivial, covering := covering }) 1","decl":"/-- On a metric space `X` with a measure `Œº`, consider for each `x : X` a family of measurable sets\nwith nonempty interiors, called `setsAt x`. This family is a Vitali family if it satisfies the\nfollowing property: consider a (possibly non-measurable) set `s`, and for any `x` in `s` a\nsubfamily `f x` of `setsAt x` containing sets of arbitrarily small diameter. Then one can extract\na disjoint subfamily covering almost all `s`.\n\nVitali families are provided by covering theorems such as the Besicovitch covering theorem or the\nVitali covering theorem. They make it possible to formulate general versions of theorems on\ndifferentiations of measure that apply in both contexts.\n-/\nstructure VitaliFamily {m : MeasurableSpace X} (Œº : Measure X) where\n  /-- Sets of the family \"centered\" at a given point. -/\n  setsAt :  X ‚Üí Set (Set X)\n  /-- All sets of the family are measurable. -/\n  measurableSet : ‚àÄ x : X, ‚àÄ s ‚àà setsAt x, MeasurableSet s\n  /-- All sets of the family have nonempty interior. -/\n  nonempty_interior : ‚àÄ x : X, ‚àÄ s ‚àà setsAt x, (interior s).Nonempty\n  /-- For any closed ball around `x`, there exists a set of the family contained in this ball. -/\n  nontrivial : ‚àÄ (x : X), ‚àÄ Œµ > (0 : ‚Ñù), ‚àÉ s ‚àà setsAt x, s ‚äÜ closedBall x Œµ\n  /-- Consider a (possibly non-measurable) set `s`,\n  and for any `x` in `s` a subfamily `f x` of `setsAt x`\n  containing sets of arbitrarily small diameter.\n  Then one can extract a disjoint subfamily covering almost all `s`. -/\n  covering : ‚àÄ (s : Set X) (f : X ‚Üí Set (Set X)),\n    (‚àÄ x ‚àà s, f x ‚äÜ setsAt x) ‚Üí (‚àÄ x ‚àà s, ‚àÄ Œµ > (0 : ‚Ñù), ‚àÉ t ‚àà f x, t ‚äÜ closedBall x Œµ) ‚Üí\n    ‚àÉ t : Set (X √ó Set X), (‚àÄ p ‚àà t, p.1 ‚àà s) ‚àß (t.PairwiseDisjoint fun p ‚Ü¶ p.2) ‚àß\n      (‚àÄ p ‚àà t, p.2 ‚àà f p.1) ‚àß Œº (s \\ ‚ãÉ p ‚àà t, p.2) = 0\n\n"}
{"name":"VitaliFamily.covering","module":"Mathlib.MeasureTheory.Covering.VitaliFamily","initialProofState":"X : Type u_1\ninst‚úù : PseudoMetricSpace X\nm : MeasurableSpace X\nŒº : MeasureTheory.Measure X\nself : VitaliFamily Œº\ns : Set X\nf : X ‚Üí Set (Set X)\na‚úù¬π : ‚àÄ (x : X), Membership.mem s x ‚Üí HasSubset.Subset (f x) (self.setsAt x)\na‚úù : ‚àÄ (x : X), Membership.mem s x ‚Üí ‚àÄ (Œµ : Real), GT.gt Œµ 0 ‚Üí Exists fun t => And (Membership.mem (f x) t) (HasSubset.Subset t (Metric.closedBall x Œµ))\n‚ä¢ Exists fun t => And (‚àÄ (p : Prod X (Set X)), Membership.mem t p ‚Üí Membership.mem s p.1) (And (t.PairwiseDisjoint fun p => p.2) (And (‚àÄ (p : Prod X (Set X)), Membership.mem t p ‚Üí Membership.mem (f p.1) p.2) (Eq (Œº (SDiff.sdiff s (Set.iUnion fun p => Set.iUnion fun h => p.2))) 0)))","decl":"/-- On a metric space `X` with a measure `Œº`, consider for each `x : X` a family of measurable sets\nwith nonempty interiors, called `setsAt x`. This family is a Vitali family if it satisfies the\nfollowing property: consider a (possibly non-measurable) set `s`, and for any `x` in `s` a\nsubfamily `f x` of `setsAt x` containing sets of arbitrarily small diameter. Then one can extract\na disjoint subfamily covering almost all `s`.\n\nVitali families are provided by covering theorems such as the Besicovitch covering theorem or the\nVitali covering theorem. They make it possible to formulate general versions of theorems on\ndifferentiations of measure that apply in both contexts.\n-/\nstructure VitaliFamily {m : MeasurableSpace X} (Œº : Measure X) where\n  /-- Sets of the family \"centered\" at a given point. -/\n  setsAt :  X ‚Üí Set (Set X)\n  /-- All sets of the family are measurable. -/\n  measurableSet : ‚àÄ x : X, ‚àÄ s ‚àà setsAt x, MeasurableSet s\n  /-- All sets of the family have nonempty interior. -/\n  nonempty_interior : ‚àÄ x : X, ‚àÄ s ‚àà setsAt x, (interior s).Nonempty\n  /-- For any closed ball around `x`, there exists a set of the family contained in this ball. -/\n  nontrivial : ‚àÄ (x : X), ‚àÄ Œµ > (0 : ‚Ñù), ‚àÉ s ‚àà setsAt x, s ‚äÜ closedBall x Œµ\n  /-- Consider a (possibly non-measurable) set `s`,\n  and for any `x` in `s` a subfamily `f x` of `setsAt x`\n  containing sets of arbitrarily small diameter.\n  Then one can extract a disjoint subfamily covering almost all `s`. -/\n  covering : ‚àÄ (s : Set X) (f : X ‚Üí Set (Set X)),\n    (‚àÄ x ‚àà s, f x ‚äÜ setsAt x) ‚Üí (‚àÄ x ‚àà s, ‚àÄ Œµ > (0 : ‚Ñù), ‚àÉ t ‚àà f x, t ‚äÜ closedBall x Œµ) ‚Üí\n    ‚àÉ t : Set (X √ó Set X), (‚àÄ p ‚àà t, p.1 ‚àà s) ‚àß (t.PairwiseDisjoint fun p ‚Ü¶ p.2) ‚àß\n      (‚àÄ p ‚àà t, p.2 ‚àà f p.1) ‚àß Œº (s \\ ‚ãÉ p ‚àà t, p.2) = 0\n\n"}
{"name":"VitaliFamily.FineSubfamilyOn.exists_disjoint_covering_ae","module":"Mathlib.MeasureTheory.Covering.VitaliFamily","initialProofState":"X : Type u_1\ninst‚úù : PseudoMetricSpace X\nm0 : MeasurableSpace X\nŒº : MeasureTheory.Measure X\nv : VitaliFamily Œº\nf : X ‚Üí Set (Set X)\ns : Set X\nh : v.FineSubfamilyOn f s\n‚ä¢ Exists fun t => And (‚àÄ (p : Prod X (Set X)), Membership.mem t p ‚Üí Membership.mem s p.1) (And (t.PairwiseDisjoint fun p => p.2) (And (‚àÄ (p : Prod X (Set X)), Membership.mem t p ‚Üí Membership.mem (Inter.inter (v.setsAt p.1) (f p.1)) p.2) (Eq (Œº (SDiff.sdiff s (Set.iUnion fun p => Set.iUnion fun x => p.2))) 0)))","decl":"theorem exists_disjoint_covering_ae :\n    ‚àÉ t : Set (X √ó Set X),\n      (‚àÄ p : X √ó Set X, p ‚àà t ‚Üí p.1 ‚àà s) ‚àß\n      (t.PairwiseDisjoint fun p => p.2) ‚àß\n      (‚àÄ p : X √ó Set X, p ‚àà t ‚Üí p.2 ‚àà v.setsAt p.1 ‚à© f p.1) ‚àß\n      Œº (s \\ ‚ãÉ (p : X √ó Set X) (_ : p ‚àà t), p.2) = 0 :=\n  v.covering s (fun x => v.setsAt x ‚à© f x) (fun _ _ => inter_subset_left) h\n\n"}
{"name":"VitaliFamily.FineSubfamilyOn.index_subset","module":"Mathlib.MeasureTheory.Covering.VitaliFamily","initialProofState":"X : Type u_1\ninst‚úù : PseudoMetricSpace X\nm0 : MeasurableSpace X\nŒº : MeasureTheory.Measure X\nv : VitaliFamily Œº\nf : X ‚Üí Set (Set X)\ns : Set X\nh : v.FineSubfamilyOn f s\np : Prod X (Set X)\na‚úù : Membership.mem h.index p\n‚ä¢ Membership.mem s p.1","decl":"theorem index_subset : ‚àÄ p : X √ó Set X, p ‚àà h.index ‚Üí p.1 ‚àà s :=\n  h.exists_disjoint_covering_ae.choose_spec.1\n\n"}
{"name":"VitaliFamily.FineSubfamilyOn.covering_disjoint","module":"Mathlib.MeasureTheory.Covering.VitaliFamily","initialProofState":"X : Type u_1\ninst‚úù : PseudoMetricSpace X\nm0 : MeasurableSpace X\nŒº : MeasureTheory.Measure X\nv : VitaliFamily Œº\nf : X ‚Üí Set (Set X)\ns : Set X\nh : v.FineSubfamilyOn f s\n‚ä¢ h.index.PairwiseDisjoint h.covering","decl":"theorem covering_disjoint : h.index.PairwiseDisjoint h.covering :=\n  h.exists_disjoint_covering_ae.choose_spec.2.1\n\n"}
{"name":"VitaliFamily.FineSubfamilyOn.covering_disjoint_subtype","module":"Mathlib.MeasureTheory.Covering.VitaliFamily","initialProofState":"X : Type u_1\ninst‚úù : PseudoMetricSpace X\nm0 : MeasurableSpace X\nŒº : MeasureTheory.Measure X\nv : VitaliFamily Œº\nf : X ‚Üí Set (Set X)\ns : Set X\nh : v.FineSubfamilyOn f s\n‚ä¢ Pairwise (Function.onFun Disjoint fun x => h.covering ‚Üëx)","decl":"open scoped Function in -- required for scoped `on` notation\ntheorem covering_disjoint_subtype : Pairwise (Disjoint on fun x : h.index => h.covering x) :=\n  (pairwise_subtype_iff_pairwise_set _ _).2 h.covering_disjoint\n\n"}
{"name":"VitaliFamily.FineSubfamilyOn.covering_mem","module":"Mathlib.MeasureTheory.Covering.VitaliFamily","initialProofState":"X : Type u_1\ninst‚úù : PseudoMetricSpace X\nm0 : MeasurableSpace X\nŒº : MeasureTheory.Measure X\nv : VitaliFamily Œº\nf : X ‚Üí Set (Set X)\ns : Set X\nh : v.FineSubfamilyOn f s\np : Prod X (Set X)\nhp : Membership.mem h.index p\n‚ä¢ Membership.mem (f p.1) (h.covering p)","decl":"theorem covering_mem {p : X √ó Set X} (hp : p ‚àà h.index) : h.covering p ‚àà f p.1 :=\n  (h.exists_disjoint_covering_ae.choose_spec.2.2.1 p hp).2\n\n"}
{"name":"VitaliFamily.FineSubfamilyOn.covering_mem_family","module":"Mathlib.MeasureTheory.Covering.VitaliFamily","initialProofState":"X : Type u_1\ninst‚úù : PseudoMetricSpace X\nm0 : MeasurableSpace X\nŒº : MeasureTheory.Measure X\nv : VitaliFamily Œº\nf : X ‚Üí Set (Set X)\ns : Set X\nh : v.FineSubfamilyOn f s\np : Prod X (Set X)\nhp : Membership.mem h.index p\n‚ä¢ Membership.mem (v.setsAt p.1) (h.covering p)","decl":"theorem covering_mem_family {p : X √ó Set X} (hp : p ‚àà h.index) : h.covering p ‚àà v.setsAt p.1 :=\n  (h.exists_disjoint_covering_ae.choose_spec.2.2.1 p hp).1\n\n"}
{"name":"VitaliFamily.FineSubfamilyOn.measure_diff_biUnion","module":"Mathlib.MeasureTheory.Covering.VitaliFamily","initialProofState":"X : Type u_1\ninst‚úù : PseudoMetricSpace X\nm0 : MeasurableSpace X\nŒº : MeasureTheory.Measure X\nv : VitaliFamily Œº\nf : X ‚Üí Set (Set X)\ns : Set X\nh : v.FineSubfamilyOn f s\n‚ä¢ Eq (Œº (SDiff.sdiff s (Set.iUnion fun p => Set.iUnion fun h_1 => h.covering p))) 0","decl":"theorem measure_diff_biUnion : Œº (s \\ ‚ãÉ p ‚àà h.index, h.covering p) = 0 :=\n  h.exists_disjoint_covering_ae.choose_spec.2.2.2\n\n"}
{"name":"VitaliFamily.FineSubfamilyOn.index_countable","module":"Mathlib.MeasureTheory.Covering.VitaliFamily","initialProofState":"X : Type u_1\ninst‚úù¬π : PseudoMetricSpace X\nm0 : MeasurableSpace X\nŒº : MeasureTheory.Measure X\nv : VitaliFamily Œº\nf : X ‚Üí Set (Set X)\ns : Set X\nh : v.FineSubfamilyOn f s\ninst‚úù : SecondCountableTopology X\n‚ä¢ h.index.Countable","decl":"theorem index_countable [SecondCountableTopology X] : h.index.Countable :=\n  h.covering_disjoint.countable_of_nonempty_interior fun _ hx =>\n    v.nonempty_interior _ _ (h.covering_mem_family hx)\n\n"}
{"name":"VitaliFamily.FineSubfamilyOn.measurableSet_u","module":"Mathlib.MeasureTheory.Covering.VitaliFamily","initialProofState":"X : Type u_1\ninst‚úù : PseudoMetricSpace X\nm0 : MeasurableSpace X\nŒº : MeasureTheory.Measure X\nv : VitaliFamily Œº\nf : X ‚Üí Set (Set X)\ns : Set X\nh : v.FineSubfamilyOn f s\np : Prod X (Set X)\nhp : Membership.mem h.index p\n‚ä¢ MeasurableSet (h.covering p)","decl":"protected theorem measurableSet_u {p : X √ó Set X} (hp : p ‚àà h.index) :\n    MeasurableSet (h.covering p) :=\n  v.measurableSet p.1 _ (h.covering_mem_family hp)\n\n"}
{"name":"VitaliFamily.FineSubfamilyOn.measure_le_tsum_of_absolutelyContinuous","module":"Mathlib.MeasureTheory.Covering.VitaliFamily","initialProofState":"X : Type u_1\ninst‚úù¬π : PseudoMetricSpace X\nm0 : MeasurableSpace X\nŒº : MeasureTheory.Measure X\nv : VitaliFamily Œº\nf : X ‚Üí Set (Set X)\ns : Set X\nh : v.FineSubfamilyOn f s\ninst‚úù : SecondCountableTopology X\nœÅ : MeasureTheory.Measure X\nhœÅ : œÅ.AbsolutelyContinuous Œº\n‚ä¢ LE.le (œÅ s) (tsum fun p => œÅ (h.covering ‚Üëp))","decl":"theorem measure_le_tsum_of_absolutelyContinuous [SecondCountableTopology X] {œÅ : Measure X}\n    (hœÅ : œÅ ‚â™ Œº) : œÅ s ‚â§ ‚àë' p : h.index, œÅ (h.covering p) :=\n  calc\n    œÅ s ‚â§ œÅ ((s \\ ‚ãÉ p ‚àà h.index, h.covering p) ‚à™ ‚ãÉ p ‚àà h.index, h.covering p) :=\n      measure_mono (by simp only [subset_union_left, diff_union_self])\n    _ ‚â§ œÅ (s \\ ‚ãÉ p ‚àà h.index, h.covering p) + œÅ (‚ãÉ p ‚àà h.index, h.covering p) :=\n      (measure_union_le _ _)\n    _ = ‚àë' p : h.index, œÅ (h.covering p) := by\n      rw [hœÅ h.measure_diff_biUnion, zero_add,\n        measure_biUnion h.index_countable h.covering_disjoint fun x hx => h.measurableSet_u hx]\n\n"}
{"name":"VitaliFamily.FineSubfamilyOn.measure_le_tsum","module":"Mathlib.MeasureTheory.Covering.VitaliFamily","initialProofState":"X : Type u_1\ninst‚úù¬π : PseudoMetricSpace X\nm0 : MeasurableSpace X\nŒº : MeasureTheory.Measure X\nv : VitaliFamily Œº\nf : X ‚Üí Set (Set X)\ns : Set X\nh : v.FineSubfamilyOn f s\ninst‚úù : SecondCountableTopology X\n‚ä¢ LE.le (Œº s) (tsum fun x => Œº (h.covering ‚Üëx))","decl":"theorem measure_le_tsum [SecondCountableTopology X] : Œº s ‚â§ ‚àë' x : h.index, Œº (h.covering x) :=\n  h.measure_le_tsum_of_absolutelyContinuous Measure.AbsolutelyContinuous.rfl\n\n"}
{"name":"Filter.HasBasis.vitaliFamily","module":"Mathlib.MeasureTheory.Covering.VitaliFamily","initialProofState":"X : Type u_1\ninst‚úù : PseudoMetricSpace X\nm0 : MeasurableSpace X\nŒº : MeasureTheory.Measure X\nv : VitaliFamily Œº\nŒπ : Sort u_2\np : Œπ ‚Üí Prop\ns : Œπ ‚Üí Set X\nx : X\nh : (nhds x).HasBasis p s\n‚ä¢ (v.filterAt x).HasBasis p fun i => setOf fun t => And (Membership.mem (v.setsAt x) t) (HasSubset.Subset t (s i))","decl":"theorem _root_.Filter.HasBasis.vitaliFamily {Œπ : Sort*} {p : Œπ ‚Üí Prop} {s : Œπ ‚Üí Set X} {x : X}\n    (h : (ùìù x).HasBasis p s) : (v.filterAt x).HasBasis p (fun i ‚Ü¶ {t ‚àà v.setsAt x | t ‚äÜ s i}) := by\n  simpa only [‚Üê Set.setOf_inter_eq_sep] using h.smallSets.inf_principal _\n\n"}
{"name":"VitaliFamily.filterAt_basis_closedBall","module":"Mathlib.MeasureTheory.Covering.VitaliFamily","initialProofState":"X : Type u_1\ninst‚úù : PseudoMetricSpace X\nm0 : MeasurableSpace X\nŒº : MeasureTheory.Measure X\nv : VitaliFamily Œº\nx : X\n‚ä¢ (v.filterAt x).HasBasis (fun x => LT.lt 0 x) fun x_1 => setOf fun t => And (Membership.mem (v.setsAt x) t) (HasSubset.Subset t (Metric.closedBall x x_1))","decl":"theorem filterAt_basis_closedBall (x : X) :\n    (v.filterAt x).HasBasis (0 < ¬∑) ({t ‚àà v.setsAt x | t ‚äÜ closedBall x ¬∑}) :=\n  nhds_basis_closedBall.vitaliFamily v\n\n"}
{"name":"VitaliFamily.mem_filterAt_iff","module":"Mathlib.MeasureTheory.Covering.VitaliFamily","initialProofState":"X : Type u_1\ninst‚úù : PseudoMetricSpace X\nm0 : MeasurableSpace X\nŒº : MeasureTheory.Measure X\nv : VitaliFamily Œº\nx : X\ns : Set (Set X)\n‚ä¢ Iff (Membership.mem (v.filterAt x) s) (Exists fun Œµ => And (GT.gt Œµ 0) (‚àÄ (t : Set X), Membership.mem (v.setsAt x) t ‚Üí HasSubset.Subset t (Metric.closedBall x Œµ) ‚Üí Membership.mem s t))","decl":"theorem mem_filterAt_iff {x : X} {s : Set (Set X)} :\n    s ‚àà v.filterAt x ‚Üî ‚àÉ Œµ > (0 : ‚Ñù), ‚àÄ t ‚àà v.setsAt x, t ‚äÜ closedBall x Œµ ‚Üí t ‚àà s := by\n  simp only [(v.filterAt_basis_closedBall x).mem_iff, ‚Üê and_imp, subset_def, mem_setOf]\n\n"}
{"name":"VitaliFamily.filterAt_neBot","module":"Mathlib.MeasureTheory.Covering.VitaliFamily","initialProofState":"X : Type u_1\ninst‚úù : PseudoMetricSpace X\nm0 : MeasurableSpace X\nŒº : MeasureTheory.Measure X\nv : VitaliFamily Œº\nx : X\n‚ä¢ (v.filterAt x).NeBot","decl":"instance filterAt_neBot (x : X) : (v.filterAt x).NeBot :=\n  (v.filterAt_basis_closedBall x).neBot_iff.2 <| v.nontrivial _ _\n\n"}
{"name":"VitaliFamily.eventually_filterAt_iff","module":"Mathlib.MeasureTheory.Covering.VitaliFamily","initialProofState":"X : Type u_1\ninst‚úù : PseudoMetricSpace X\nm0 : MeasurableSpace X\nŒº : MeasureTheory.Measure X\nv : VitaliFamily Œº\nx : X\nP : Set X ‚Üí Prop\n‚ä¢ Iff (Filter.Eventually (fun t => P t) (v.filterAt x)) (Exists fun Œµ => And (GT.gt Œµ 0) (‚àÄ (t : Set X), Membership.mem (v.setsAt x) t ‚Üí HasSubset.Subset t (Metric.closedBall x Œµ) ‚Üí P t))","decl":"theorem eventually_filterAt_iff {x : X} {P : Set X ‚Üí Prop} :\n    (‚àÄ·∂† t in v.filterAt x, P t) ‚Üî ‚àÉ Œµ > (0 : ‚Ñù), ‚àÄ t ‚àà v.setsAt x, t ‚äÜ closedBall x Œµ ‚Üí P t :=\n  v.mem_filterAt_iff\n\n"}
{"name":"VitaliFamily.tendsto_filterAt_iff","module":"Mathlib.MeasureTheory.Covering.VitaliFamily","initialProofState":"X : Type u_1\ninst‚úù : PseudoMetricSpace X\nm0 : MeasurableSpace X\nŒº : MeasureTheory.Measure X\nv : VitaliFamily Œº\nŒπ : Type u_2\nl : Filter Œπ\nf : Œπ ‚Üí Set X\nx : X\n‚ä¢ Iff (Filter.Tendsto f l (v.filterAt x)) (And (Filter.Eventually (fun i => Membership.mem (v.setsAt x) (f i)) l) (‚àÄ (Œµ : Real), GT.gt Œµ 0 ‚Üí Filter.Eventually (fun i => HasSubset.Subset (f i) (Metric.closedBall x Œµ)) l))","decl":"theorem tendsto_filterAt_iff {Œπ : Type*} {l : Filter Œπ} {f : Œπ ‚Üí Set X} {x : X} :\n    Tendsto f l (v.filterAt x) ‚Üî\n      (‚àÄ·∂† i in l, f i ‚àà v.setsAt x) ‚àß ‚àÄ Œµ > (0 : ‚Ñù), ‚àÄ·∂† i in l, f i ‚äÜ closedBall x Œµ := by\n  simp only [filterAt, tendsto_inf, nhds_basis_closedBall.smallSets.tendsto_right_iff,\n    tendsto_principal, and_comm, mem_powerset_iff]\n\n"}
{"name":"VitaliFamily.eventually_filterAt_mem_setsAt","module":"Mathlib.MeasureTheory.Covering.VitaliFamily","initialProofState":"X : Type u_1\ninst‚úù : PseudoMetricSpace X\nm0 : MeasurableSpace X\nŒº : MeasureTheory.Measure X\nv : VitaliFamily Œº\nx : X\n‚ä¢ Filter.Eventually (fun t => Membership.mem (v.setsAt x) t) (v.filterAt x)","decl":"theorem eventually_filterAt_mem_setsAt (x : X) : ‚àÄ·∂† t in v.filterAt x, t ‚àà v.setsAt x :=\n  (v.tendsto_filterAt_iff.mp tendsto_id).1\n\n"}
{"name":"VitaliFamily.eventually_filterAt_subset_closedBall","module":"Mathlib.MeasureTheory.Covering.VitaliFamily","initialProofState":"X : Type u_1\ninst‚úù : PseudoMetricSpace X\nm0 : MeasurableSpace X\nŒº : MeasureTheory.Measure X\nv : VitaliFamily Œº\nx : X\nŒµ : Real\nhŒµ : LT.lt 0 Œµ\n‚ä¢ Filter.Eventually (fun t => HasSubset.Subset t (Metric.closedBall x Œµ)) (v.filterAt x)","decl":"theorem eventually_filterAt_subset_closedBall (x : X) {Œµ : ‚Ñù} (hŒµ : 0 < Œµ) :\n    ‚àÄ·∂† t : Set X in v.filterAt x, t ‚äÜ closedBall x Œµ :=\n  (v.tendsto_filterAt_iff.mp tendsto_id).2 Œµ hŒµ\n\n"}
{"name":"VitaliFamily.eventually_filterAt_measurableSet","module":"Mathlib.MeasureTheory.Covering.VitaliFamily","initialProofState":"X : Type u_1\ninst‚úù : PseudoMetricSpace X\nm0 : MeasurableSpace X\nŒº : MeasureTheory.Measure X\nv : VitaliFamily Œº\nx : X\n‚ä¢ Filter.Eventually (fun t => MeasurableSet t) (v.filterAt x)","decl":"theorem eventually_filterAt_measurableSet (x : X) : ‚àÄ·∂† t in v.filterAt x, MeasurableSet t := by\n  filter_upwards [v.eventually_filterAt_mem_setsAt x] with _ ha using v.measurableSet _ _ ha\n\n"}
{"name":"VitaliFamily.frequently_filterAt_iff","module":"Mathlib.MeasureTheory.Covering.VitaliFamily","initialProofState":"X : Type u_1\ninst‚úù : PseudoMetricSpace X\nm0 : MeasurableSpace X\nŒº : MeasureTheory.Measure X\nv : VitaliFamily Œº\nx : X\nP : Set X ‚Üí Prop\n‚ä¢ Iff (Filter.Frequently (fun t => P t) (v.filterAt x)) (‚àÄ (Œµ : Real), GT.gt Œµ 0 ‚Üí Exists fun t => And (Membership.mem (v.setsAt x) t) (And (HasSubset.Subset t (Metric.closedBall x Œµ)) (P t)))","decl":"theorem frequently_filterAt_iff {x : X} {P : Set X ‚Üí Prop} :\n    (‚àÉ·∂† t in v.filterAt x, P t) ‚Üî ‚àÄ Œµ > (0 : ‚Ñù), ‚àÉ t ‚àà v.setsAt x, t ‚äÜ closedBall x Œµ ‚àß P t := by\n  simp only [(v.filterAt_basis_closedBall x).frequently_iff, ‚Üê and_assoc, subset_def, mem_setOf]\n\n"}
{"name":"VitaliFamily.eventually_filterAt_subset_of_nhds","module":"Mathlib.MeasureTheory.Covering.VitaliFamily","initialProofState":"X : Type u_1\ninst‚úù : PseudoMetricSpace X\nm0 : MeasurableSpace X\nŒº : MeasureTheory.Measure X\nv : VitaliFamily Œº\nx : X\no : Set X\nhx : Membership.mem (nhds x) o\n‚ä¢ Filter.Eventually (fun t => HasSubset.Subset t o) (v.filterAt x)","decl":"theorem eventually_filterAt_subset_of_nhds {x : X} {o : Set X} (hx : o ‚àà ùìù x) :\n    ‚àÄ·∂† t in v.filterAt x, t ‚äÜ o :=\n  (eventually_smallSets_subset.2 hx).filter_mono inf_le_left\n\n"}
{"name":"VitaliFamily.fineSubfamilyOn_of_frequently","module":"Mathlib.MeasureTheory.Covering.VitaliFamily","initialProofState":"X : Type u_1\ninst‚úù : PseudoMetricSpace X\nm0 : MeasurableSpace X\nŒº : MeasureTheory.Measure X\nv : VitaliFamily Œº\nf : X ‚Üí Set (Set X)\ns : Set X\nh : ‚àÄ (x : X), Membership.mem s x ‚Üí Filter.Frequently (fun t => Membership.mem (f x) t) (v.filterAt x)\n‚ä¢ v.FineSubfamilyOn f s","decl":"theorem fineSubfamilyOn_of_frequently (v : VitaliFamily Œº) (f : X ‚Üí Set (Set X)) (s : Set X)\n    (h : ‚àÄ x ‚àà s, ‚àÉ·∂† t in v.filterAt x, t ‚àà f x) : v.FineSubfamilyOn f s := by\n  intro x hx Œµ Œµpos\n  obtain ‚ü®t, tv, ht, tf‚ü© : ‚àÉ t ‚àà v.setsAt x, t ‚äÜ closedBall x Œµ ‚àß t ‚àà f x :=\n    v.frequently_filterAt_iff.1 (h x hx) Œµ Œµpos\n  exact ‚ü®t, ‚ü®tv, tf‚ü©, ht‚ü©\n\n"}
