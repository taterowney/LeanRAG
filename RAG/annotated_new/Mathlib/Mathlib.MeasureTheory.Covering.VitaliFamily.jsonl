{"name":"VitaliFamily.mk.injEq","module":"Mathlib.MeasureTheory.Covering.VitaliFamily","initialProofState":"X : Type u_1\ninst✝ : PseudoMetricSpace X\nm : MeasurableSpace X\nμ : MeasureTheory.Measure X\nsetsAt✝ : X → Set (Set X)\nmeasurableSet✝ : ∀ (x : X) (s : Set X), Membership.mem (setsAt✝ x) s → MeasurableSet s\nnonempty_interior✝ : ∀ (x : X) (s : Set X), Membership.mem (setsAt✝ x) s → (interior s).Nonempty\nnontrivial✝ : ∀ (x : X) (ε : Real), GT.gt ε 0 → Exists fun s => And (Membership.mem (setsAt✝ x) s) (HasSubset.Subset s (Metric.closedBall x ε))\ncovering✝ : ∀ (s : Set X) (f : X → Set (Set X)), (∀ (x : X), Membership.mem s x → HasSubset.Subset (f x) (setsAt✝ x)) → (∀ (x : X), Membership.mem s x → ∀ (ε : Real), GT.gt ε 0 → Exists fun t => And (Membership.mem (f x) t) (HasSubset.Subset t (Metric.closedBall x ε))) → Exists fun t => And (∀ (p : Prod X (Set X)), Membership.mem t p → Membership.mem s p.1) (And (t.PairwiseDisjoint fun p => p.2) (And (∀ (p : Prod X (Set X)), Membership.mem t p → Membership.mem (f p.1) p.2) (Eq (μ (SDiff.sdiff s (Set.iUnion fun p => Set.iUnion fun h => p.2))) 0)))\nsetsAt : X → Set (Set X)\nmeasurableSet : ∀ (x : X) (s : Set X), Membership.mem (setsAt x) s → MeasurableSet s\nnonempty_interior : ∀ (x : X) (s : Set X), Membership.mem (setsAt x) s → (interior s).Nonempty\nnontrivial : ∀ (x : X) (ε : Real), GT.gt ε 0 → Exists fun s => And (Membership.mem (setsAt x) s) (HasSubset.Subset s (Metric.closedBall x ε))\ncovering : ∀ (s : Set X) (f : X → Set (Set X)), (∀ (x : X), Membership.mem s x → HasSubset.Subset (f x) (setsAt x)) → (∀ (x : X), Membership.mem s x → ∀ (ε : Real), GT.gt ε 0 → Exists fun t => And (Membership.mem (f x) t) (HasSubset.Subset t (Metric.closedBall x ε))) → Exists fun t => And (∀ (p : Prod X (Set X)), Membership.mem t p → Membership.mem s p.1) (And (t.PairwiseDisjoint fun p => p.2) (And (∀ (p : Prod X (Set X)), Membership.mem t p → Membership.mem (f p.1) p.2) (Eq (μ (SDiff.sdiff s (Set.iUnion fun p => Set.iUnion fun h => p.2))) 0)))\n⊢ Eq (Eq { setsAt := setsAt✝, measurableSet := measurableSet✝, nonempty_interior := nonempty_interior✝, nontrivial := nontrivial✝, covering := covering✝ } { setsAt := setsAt, measurableSet := measurableSet, nonempty_interior := nonempty_interior, nontrivial := nontrivial, covering := covering }) (Eq setsAt✝ setsAt)","decl":"/-- On a metric space `X` with a measure `μ`, consider for each `x : X` a family of measurable sets\nwith nonempty interiors, called `setsAt x`. This family is a Vitali family if it satisfies the\nfollowing property: consider a (possibly non-measurable) set `s`, and for any `x` in `s` a\nsubfamily `f x` of `setsAt x` containing sets of arbitrarily small diameter. Then one can extract\na disjoint subfamily covering almost all `s`.\n\nVitali families are provided by covering theorems such as the Besicovitch covering theorem or the\nVitali covering theorem. They make it possible to formulate general versions of theorems on\ndifferentiations of measure that apply in both contexts.\n-/\nstructure VitaliFamily {m : MeasurableSpace X} (μ : Measure X) where\n  /-- Sets of the family \"centered\" at a given point. -/\n  setsAt :  X → Set (Set X)\n  /-- All sets of the family are measurable. -/\n  measurableSet : ∀ x : X, ∀ s ∈ setsAt x, MeasurableSet s\n  /-- All sets of the family have nonempty interior. -/\n  nonempty_interior : ∀ x : X, ∀ s ∈ setsAt x, (interior s).Nonempty\n  /-- For any closed ball around `x`, there exists a set of the family contained in this ball. -/\n  nontrivial : ∀ (x : X), ∀ ε > (0 : ℝ), ∃ s ∈ setsAt x, s ⊆ closedBall x ε\n  /-- Consider a (possibly non-measurable) set `s`,\n  and for any `x` in `s` a subfamily `f x` of `setsAt x`\n  containing sets of arbitrarily small diameter.\n  Then one can extract a disjoint subfamily covering almost all `s`. -/\n  covering : ∀ (s : Set X) (f : X → Set (Set X)),\n    (∀ x ∈ s, f x ⊆ setsAt x) → (∀ x ∈ s, ∀ ε > (0 : ℝ), ∃ t ∈ f x, t ⊆ closedBall x ε) →\n    ∃ t : Set (X × Set X), (∀ p ∈ t, p.1 ∈ s) ∧ (t.PairwiseDisjoint fun p ↦ p.2) ∧\n      (∀ p ∈ t, p.2 ∈ f p.1) ∧ μ (s \\ ⋃ p ∈ t, p.2) = 0\n\n"}
{"name":"VitaliFamily.mk.inj","module":"Mathlib.MeasureTheory.Covering.VitaliFamily","initialProofState":"X : Type u_1\ninst✝ : PseudoMetricSpace X\nm : MeasurableSpace X\nμ : MeasureTheory.Measure X\nsetsAt✝ : X → Set (Set X)\nmeasurableSet✝ : ∀ (x : X) (s : Set X), Membership.mem (setsAt✝ x) s → MeasurableSet s\nnonempty_interior✝ : ∀ (x : X) (s : Set X), Membership.mem (setsAt✝ x) s → (interior s).Nonempty\nnontrivial✝ : ∀ (x : X) (ε : Real), GT.gt ε 0 → Exists fun s => And (Membership.mem (setsAt✝ x) s) (HasSubset.Subset s (Metric.closedBall x ε))\ncovering✝ : ∀ (s : Set X) (f : X → Set (Set X)), (∀ (x : X), Membership.mem s x → HasSubset.Subset (f x) (setsAt✝ x)) → (∀ (x : X), Membership.mem s x → ∀ (ε : Real), GT.gt ε 0 → Exists fun t => And (Membership.mem (f x) t) (HasSubset.Subset t (Metric.closedBall x ε))) → Exists fun t => And (∀ (p : Prod X (Set X)), Membership.mem t p → Membership.mem s p.1) (And (t.PairwiseDisjoint fun p => p.2) (And (∀ (p : Prod X (Set X)), Membership.mem t p → Membership.mem (f p.1) p.2) (Eq (μ (SDiff.sdiff s (Set.iUnion fun p => Set.iUnion fun h => p.2))) 0)))\nsetsAt : X → Set (Set X)\nmeasurableSet : ∀ (x : X) (s : Set X), Membership.mem (setsAt x) s → MeasurableSet s\nnonempty_interior : ∀ (x : X) (s : Set X), Membership.mem (setsAt x) s → (interior s).Nonempty\nnontrivial : ∀ (x : X) (ε : Real), GT.gt ε 0 → Exists fun s => And (Membership.mem (setsAt x) s) (HasSubset.Subset s (Metric.closedBall x ε))\ncovering : ∀ (s : Set X) (f : X → Set (Set X)), (∀ (x : X), Membership.mem s x → HasSubset.Subset (f x) (setsAt x)) → (∀ (x : X), Membership.mem s x → ∀ (ε : Real), GT.gt ε 0 → Exists fun t => And (Membership.mem (f x) t) (HasSubset.Subset t (Metric.closedBall x ε))) → Exists fun t => And (∀ (p : Prod X (Set X)), Membership.mem t p → Membership.mem s p.1) (And (t.PairwiseDisjoint fun p => p.2) (And (∀ (p : Prod X (Set X)), Membership.mem t p → Membership.mem (f p.1) p.2) (Eq (μ (SDiff.sdiff s (Set.iUnion fun p => Set.iUnion fun h => p.2))) 0)))\nx✝ : Eq { setsAt := setsAt✝, measurableSet := measurableSet✝, nonempty_interior := nonempty_interior✝, nontrivial := nontrivial✝, covering := covering✝ } { setsAt := setsAt, measurableSet := measurableSet, nonempty_interior := nonempty_interior, nontrivial := nontrivial, covering := covering }\n⊢ Eq setsAt✝ setsAt","decl":"/-- On a metric space `X` with a measure `μ`, consider for each `x : X` a family of measurable sets\nwith nonempty interiors, called `setsAt x`. This family is a Vitali family if it satisfies the\nfollowing property: consider a (possibly non-measurable) set `s`, and for any `x` in `s` a\nsubfamily `f x` of `setsAt x` containing sets of arbitrarily small diameter. Then one can extract\na disjoint subfamily covering almost all `s`.\n\nVitali families are provided by covering theorems such as the Besicovitch covering theorem or the\nVitali covering theorem. They make it possible to formulate general versions of theorems on\ndifferentiations of measure that apply in both contexts.\n-/\nstructure VitaliFamily {m : MeasurableSpace X} (μ : Measure X) where\n  /-- Sets of the family \"centered\" at a given point. -/\n  setsAt :  X → Set (Set X)\n  /-- All sets of the family are measurable. -/\n  measurableSet : ∀ x : X, ∀ s ∈ setsAt x, MeasurableSet s\n  /-- All sets of the family have nonempty interior. -/\n  nonempty_interior : ∀ x : X, ∀ s ∈ setsAt x, (interior s).Nonempty\n  /-- For any closed ball around `x`, there exists a set of the family contained in this ball. -/\n  nontrivial : ∀ (x : X), ∀ ε > (0 : ℝ), ∃ s ∈ setsAt x, s ⊆ closedBall x ε\n  /-- Consider a (possibly non-measurable) set `s`,\n  and for any `x` in `s` a subfamily `f x` of `setsAt x`\n  containing sets of arbitrarily small diameter.\n  Then one can extract a disjoint subfamily covering almost all `s`. -/\n  covering : ∀ (s : Set X) (f : X → Set (Set X)),\n    (∀ x ∈ s, f x ⊆ setsAt x) → (∀ x ∈ s, ∀ ε > (0 : ℝ), ∃ t ∈ f x, t ⊆ closedBall x ε) →\n    ∃ t : Set (X × Set X), (∀ p ∈ t, p.1 ∈ s) ∧ (t.PairwiseDisjoint fun p ↦ p.2) ∧\n      (∀ p ∈ t, p.2 ∈ f p.1) ∧ μ (s \\ ⋃ p ∈ t, p.2) = 0\n\n"}
{"name":"VitaliFamily.measurableSet","module":"Mathlib.MeasureTheory.Covering.VitaliFamily","initialProofState":"X : Type u_1\ninst✝ : PseudoMetricSpace X\nm : MeasurableSpace X\nμ : MeasureTheory.Measure X\nself : VitaliFamily μ\nx : X\ns : Set X\na✝ : Membership.mem (self.setsAt x) s\n⊢ MeasurableSet s","decl":"/-- On a metric space `X` with a measure `μ`, consider for each `x : X` a family of measurable sets\nwith nonempty interiors, called `setsAt x`. This family is a Vitali family if it satisfies the\nfollowing property: consider a (possibly non-measurable) set `s`, and for any `x` in `s` a\nsubfamily `f x` of `setsAt x` containing sets of arbitrarily small diameter. Then one can extract\na disjoint subfamily covering almost all `s`.\n\nVitali families are provided by covering theorems such as the Besicovitch covering theorem or the\nVitali covering theorem. They make it possible to formulate general versions of theorems on\ndifferentiations of measure that apply in both contexts.\n-/\nstructure VitaliFamily {m : MeasurableSpace X} (μ : Measure X) where\n  /-- Sets of the family \"centered\" at a given point. -/\n  setsAt :  X → Set (Set X)\n  /-- All sets of the family are measurable. -/\n  measurableSet : ∀ x : X, ∀ s ∈ setsAt x, MeasurableSet s\n  /-- All sets of the family have nonempty interior. -/\n  nonempty_interior : ∀ x : X, ∀ s ∈ setsAt x, (interior s).Nonempty\n  /-- For any closed ball around `x`, there exists a set of the family contained in this ball. -/\n  nontrivial : ∀ (x : X), ∀ ε > (0 : ℝ), ∃ s ∈ setsAt x, s ⊆ closedBall x ε\n  /-- Consider a (possibly non-measurable) set `s`,\n  and for any `x` in `s` a subfamily `f x` of `setsAt x`\n  containing sets of arbitrarily small diameter.\n  Then one can extract a disjoint subfamily covering almost all `s`. -/\n  covering : ∀ (s : Set X) (f : X → Set (Set X)),\n    (∀ x ∈ s, f x ⊆ setsAt x) → (∀ x ∈ s, ∀ ε > (0 : ℝ), ∃ t ∈ f x, t ⊆ closedBall x ε) →\n    ∃ t : Set (X × Set X), (∀ p ∈ t, p.1 ∈ s) ∧ (t.PairwiseDisjoint fun p ↦ p.2) ∧\n      (∀ p ∈ t, p.2 ∈ f p.1) ∧ μ (s \\ ⋃ p ∈ t, p.2) = 0\n\n"}
{"name":"VitaliFamily.nontrivial","module":"Mathlib.MeasureTheory.Covering.VitaliFamily","initialProofState":"X : Type u_1\ninst✝ : PseudoMetricSpace X\nm : MeasurableSpace X\nμ : MeasureTheory.Measure X\nself : VitaliFamily μ\nx : X\nε : Real\na✝ : GT.gt ε 0\n⊢ Exists fun s => And (Membership.mem (self.setsAt x) s) (HasSubset.Subset s (Metric.closedBall x ε))","decl":"/-- On a metric space `X` with a measure `μ`, consider for each `x : X` a family of measurable sets\nwith nonempty interiors, called `setsAt x`. This family is a Vitali family if it satisfies the\nfollowing property: consider a (possibly non-measurable) set `s`, and for any `x` in `s` a\nsubfamily `f x` of `setsAt x` containing sets of arbitrarily small diameter. Then one can extract\na disjoint subfamily covering almost all `s`.\n\nVitali families are provided by covering theorems such as the Besicovitch covering theorem or the\nVitali covering theorem. They make it possible to formulate general versions of theorems on\ndifferentiations of measure that apply in both contexts.\n-/\nstructure VitaliFamily {m : MeasurableSpace X} (μ : Measure X) where\n  /-- Sets of the family \"centered\" at a given point. -/\n  setsAt :  X → Set (Set X)\n  /-- All sets of the family are measurable. -/\n  measurableSet : ∀ x : X, ∀ s ∈ setsAt x, MeasurableSet s\n  /-- All sets of the family have nonempty interior. -/\n  nonempty_interior : ∀ x : X, ∀ s ∈ setsAt x, (interior s).Nonempty\n  /-- For any closed ball around `x`, there exists a set of the family contained in this ball. -/\n  nontrivial : ∀ (x : X), ∀ ε > (0 : ℝ), ∃ s ∈ setsAt x, s ⊆ closedBall x ε\n  /-- Consider a (possibly non-measurable) set `s`,\n  and for any `x` in `s` a subfamily `f x` of `setsAt x`\n  containing sets of arbitrarily small diameter.\n  Then one can extract a disjoint subfamily covering almost all `s`. -/\n  covering : ∀ (s : Set X) (f : X → Set (Set X)),\n    (∀ x ∈ s, f x ⊆ setsAt x) → (∀ x ∈ s, ∀ ε > (0 : ℝ), ∃ t ∈ f x, t ⊆ closedBall x ε) →\n    ∃ t : Set (X × Set X), (∀ p ∈ t, p.1 ∈ s) ∧ (t.PairwiseDisjoint fun p ↦ p.2) ∧\n      (∀ p ∈ t, p.2 ∈ f p.1) ∧ μ (s \\ ⋃ p ∈ t, p.2) = 0\n\n"}
{"name":"VitaliFamily.nonempty_interior","module":"Mathlib.MeasureTheory.Covering.VitaliFamily","initialProofState":"X : Type u_1\ninst✝ : PseudoMetricSpace X\nm : MeasurableSpace X\nμ : MeasureTheory.Measure X\nself : VitaliFamily μ\nx : X\ns : Set X\na✝ : Membership.mem (self.setsAt x) s\n⊢ (interior s).Nonempty","decl":"/-- On a metric space `X` with a measure `μ`, consider for each `x : X` a family of measurable sets\nwith nonempty interiors, called `setsAt x`. This family is a Vitali family if it satisfies the\nfollowing property: consider a (possibly non-measurable) set `s`, and for any `x` in `s` a\nsubfamily `f x` of `setsAt x` containing sets of arbitrarily small diameter. Then one can extract\na disjoint subfamily covering almost all `s`.\n\nVitali families are provided by covering theorems such as the Besicovitch covering theorem or the\nVitali covering theorem. They make it possible to formulate general versions of theorems on\ndifferentiations of measure that apply in both contexts.\n-/\nstructure VitaliFamily {m : MeasurableSpace X} (μ : Measure X) where\n  /-- Sets of the family \"centered\" at a given point. -/\n  setsAt :  X → Set (Set X)\n  /-- All sets of the family are measurable. -/\n  measurableSet : ∀ x : X, ∀ s ∈ setsAt x, MeasurableSet s\n  /-- All sets of the family have nonempty interior. -/\n  nonempty_interior : ∀ x : X, ∀ s ∈ setsAt x, (interior s).Nonempty\n  /-- For any closed ball around `x`, there exists a set of the family contained in this ball. -/\n  nontrivial : ∀ (x : X), ∀ ε > (0 : ℝ), ∃ s ∈ setsAt x, s ⊆ closedBall x ε\n  /-- Consider a (possibly non-measurable) set `s`,\n  and for any `x` in `s` a subfamily `f x` of `setsAt x`\n  containing sets of arbitrarily small diameter.\n  Then one can extract a disjoint subfamily covering almost all `s`. -/\n  covering : ∀ (s : Set X) (f : X → Set (Set X)),\n    (∀ x ∈ s, f x ⊆ setsAt x) → (∀ x ∈ s, ∀ ε > (0 : ℝ), ∃ t ∈ f x, t ⊆ closedBall x ε) →\n    ∃ t : Set (X × Set X), (∀ p ∈ t, p.1 ∈ s) ∧ (t.PairwiseDisjoint fun p ↦ p.2) ∧\n      (∀ p ∈ t, p.2 ∈ f p.1) ∧ μ (s \\ ⋃ p ∈ t, p.2) = 0\n\n"}
{"name":"VitaliFamily.mk.sizeOf_spec","module":"Mathlib.MeasureTheory.Covering.VitaliFamily","initialProofState":"X : Type u_1\ninst✝¹ : PseudoMetricSpace X\nm : MeasurableSpace X\nμ : MeasureTheory.Measure X\ninst✝ : SizeOf X\nsetsAt : X → Set (Set X)\nmeasurableSet : ∀ (x : X) (s : Set X), Membership.mem (setsAt x) s → MeasurableSet s\nnonempty_interior : ∀ (x : X) (s : Set X), Membership.mem (setsAt x) s → (interior s).Nonempty\nnontrivial : ∀ (x : X) (ε : Real), GT.gt ε 0 → Exists fun s => And (Membership.mem (setsAt x) s) (HasSubset.Subset s (Metric.closedBall x ε))\ncovering : ∀ (s : Set X) (f : X → Set (Set X)), (∀ (x : X), Membership.mem s x → HasSubset.Subset (f x) (setsAt x)) → (∀ (x : X), Membership.mem s x → ∀ (ε : Real), GT.gt ε 0 → Exists fun t => And (Membership.mem (f x) t) (HasSubset.Subset t (Metric.closedBall x ε))) → Exists fun t => And (∀ (p : Prod X (Set X)), Membership.mem t p → Membership.mem s p.1) (And (t.PairwiseDisjoint fun p => p.2) (And (∀ (p : Prod X (Set X)), Membership.mem t p → Membership.mem (f p.1) p.2) (Eq (μ (SDiff.sdiff s (Set.iUnion fun p => Set.iUnion fun h => p.2))) 0)))\n⊢ Eq (SizeOf.sizeOf { setsAt := setsAt, measurableSet := measurableSet, nonempty_interior := nonempty_interior, nontrivial := nontrivial, covering := covering }) 1","decl":"/-- On a metric space `X` with a measure `μ`, consider for each `x : X` a family of measurable sets\nwith nonempty interiors, called `setsAt x`. This family is a Vitali family if it satisfies the\nfollowing property: consider a (possibly non-measurable) set `s`, and for any `x` in `s` a\nsubfamily `f x` of `setsAt x` containing sets of arbitrarily small diameter. Then one can extract\na disjoint subfamily covering almost all `s`.\n\nVitali families are provided by covering theorems such as the Besicovitch covering theorem or the\nVitali covering theorem. They make it possible to formulate general versions of theorems on\ndifferentiations of measure that apply in both contexts.\n-/\nstructure VitaliFamily {m : MeasurableSpace X} (μ : Measure X) where\n  /-- Sets of the family \"centered\" at a given point. -/\n  setsAt :  X → Set (Set X)\n  /-- All sets of the family are measurable. -/\n  measurableSet : ∀ x : X, ∀ s ∈ setsAt x, MeasurableSet s\n  /-- All sets of the family have nonempty interior. -/\n  nonempty_interior : ∀ x : X, ∀ s ∈ setsAt x, (interior s).Nonempty\n  /-- For any closed ball around `x`, there exists a set of the family contained in this ball. -/\n  nontrivial : ∀ (x : X), ∀ ε > (0 : ℝ), ∃ s ∈ setsAt x, s ⊆ closedBall x ε\n  /-- Consider a (possibly non-measurable) set `s`,\n  and for any `x` in `s` a subfamily `f x` of `setsAt x`\n  containing sets of arbitrarily small diameter.\n  Then one can extract a disjoint subfamily covering almost all `s`. -/\n  covering : ∀ (s : Set X) (f : X → Set (Set X)),\n    (∀ x ∈ s, f x ⊆ setsAt x) → (∀ x ∈ s, ∀ ε > (0 : ℝ), ∃ t ∈ f x, t ⊆ closedBall x ε) →\n    ∃ t : Set (X × Set X), (∀ p ∈ t, p.1 ∈ s) ∧ (t.PairwiseDisjoint fun p ↦ p.2) ∧\n      (∀ p ∈ t, p.2 ∈ f p.1) ∧ μ (s \\ ⋃ p ∈ t, p.2) = 0\n\n"}
{"name":"VitaliFamily.covering","module":"Mathlib.MeasureTheory.Covering.VitaliFamily","initialProofState":"X : Type u_1\ninst✝ : PseudoMetricSpace X\nm : MeasurableSpace X\nμ : MeasureTheory.Measure X\nself : VitaliFamily μ\ns : Set X\nf : X → Set (Set X)\na✝¹ : ∀ (x : X), Membership.mem s x → HasSubset.Subset (f x) (self.setsAt x)\na✝ : ∀ (x : X), Membership.mem s x → ∀ (ε : Real), GT.gt ε 0 → Exists fun t => And (Membership.mem (f x) t) (HasSubset.Subset t (Metric.closedBall x ε))\n⊢ Exists fun t => And (∀ (p : Prod X (Set X)), Membership.mem t p → Membership.mem s p.1) (And (t.PairwiseDisjoint fun p => p.2) (And (∀ (p : Prod X (Set X)), Membership.mem t p → Membership.mem (f p.1) p.2) (Eq (μ (SDiff.sdiff s (Set.iUnion fun p => Set.iUnion fun h => p.2))) 0)))","decl":"/-- On a metric space `X` with a measure `μ`, consider for each `x : X` a family of measurable sets\nwith nonempty interiors, called `setsAt x`. This family is a Vitali family if it satisfies the\nfollowing property: consider a (possibly non-measurable) set `s`, and for any `x` in `s` a\nsubfamily `f x` of `setsAt x` containing sets of arbitrarily small diameter. Then one can extract\na disjoint subfamily covering almost all `s`.\n\nVitali families are provided by covering theorems such as the Besicovitch covering theorem or the\nVitali covering theorem. They make it possible to formulate general versions of theorems on\ndifferentiations of measure that apply in both contexts.\n-/\nstructure VitaliFamily {m : MeasurableSpace X} (μ : Measure X) where\n  /-- Sets of the family \"centered\" at a given point. -/\n  setsAt :  X → Set (Set X)\n  /-- All sets of the family are measurable. -/\n  measurableSet : ∀ x : X, ∀ s ∈ setsAt x, MeasurableSet s\n  /-- All sets of the family have nonempty interior. -/\n  nonempty_interior : ∀ x : X, ∀ s ∈ setsAt x, (interior s).Nonempty\n  /-- For any closed ball around `x`, there exists a set of the family contained in this ball. -/\n  nontrivial : ∀ (x : X), ∀ ε > (0 : ℝ), ∃ s ∈ setsAt x, s ⊆ closedBall x ε\n  /-- Consider a (possibly non-measurable) set `s`,\n  and for any `x` in `s` a subfamily `f x` of `setsAt x`\n  containing sets of arbitrarily small diameter.\n  Then one can extract a disjoint subfamily covering almost all `s`. -/\n  covering : ∀ (s : Set X) (f : X → Set (Set X)),\n    (∀ x ∈ s, f x ⊆ setsAt x) → (∀ x ∈ s, ∀ ε > (0 : ℝ), ∃ t ∈ f x, t ⊆ closedBall x ε) →\n    ∃ t : Set (X × Set X), (∀ p ∈ t, p.1 ∈ s) ∧ (t.PairwiseDisjoint fun p ↦ p.2) ∧\n      (∀ p ∈ t, p.2 ∈ f p.1) ∧ μ (s \\ ⋃ p ∈ t, p.2) = 0\n\n"}
{"name":"VitaliFamily.FineSubfamilyOn.exists_disjoint_covering_ae","module":"Mathlib.MeasureTheory.Covering.VitaliFamily","initialProofState":"X : Type u_1\ninst✝ : PseudoMetricSpace X\nm0 : MeasurableSpace X\nμ : MeasureTheory.Measure X\nv : VitaliFamily μ\nf : X → Set (Set X)\ns : Set X\nh : v.FineSubfamilyOn f s\n⊢ Exists fun t => And (∀ (p : Prod X (Set X)), Membership.mem t p → Membership.mem s p.1) (And (t.PairwiseDisjoint fun p => p.2) (And (∀ (p : Prod X (Set X)), Membership.mem t p → Membership.mem (Inter.inter (v.setsAt p.1) (f p.1)) p.2) (Eq (μ (SDiff.sdiff s (Set.iUnion fun p => Set.iUnion fun x => p.2))) 0)))","decl":"theorem exists_disjoint_covering_ae :\n    ∃ t : Set (X × Set X),\n      (∀ p : X × Set X, p ∈ t → p.1 ∈ s) ∧\n      (t.PairwiseDisjoint fun p => p.2) ∧\n      (∀ p : X × Set X, p ∈ t → p.2 ∈ v.setsAt p.1 ∩ f p.1) ∧\n      μ (s \\ ⋃ (p : X × Set X) (_ : p ∈ t), p.2) = 0 :=\n  v.covering s (fun x => v.setsAt x ∩ f x) (fun _ _ => inter_subset_left) h\n\n"}
{"name":"VitaliFamily.FineSubfamilyOn.index_subset","module":"Mathlib.MeasureTheory.Covering.VitaliFamily","initialProofState":"X : Type u_1\ninst✝ : PseudoMetricSpace X\nm0 : MeasurableSpace X\nμ : MeasureTheory.Measure X\nv : VitaliFamily μ\nf : X → Set (Set X)\ns : Set X\nh : v.FineSubfamilyOn f s\np : Prod X (Set X)\na✝ : Membership.mem h.index p\n⊢ Membership.mem s p.1","decl":"theorem index_subset : ∀ p : X × Set X, p ∈ h.index → p.1 ∈ s :=\n  h.exists_disjoint_covering_ae.choose_spec.1\n\n"}
{"name":"VitaliFamily.FineSubfamilyOn.covering_disjoint","module":"Mathlib.MeasureTheory.Covering.VitaliFamily","initialProofState":"X : Type u_1\ninst✝ : PseudoMetricSpace X\nm0 : MeasurableSpace X\nμ : MeasureTheory.Measure X\nv : VitaliFamily μ\nf : X → Set (Set X)\ns : Set X\nh : v.FineSubfamilyOn f s\n⊢ h.index.PairwiseDisjoint h.covering","decl":"theorem covering_disjoint : h.index.PairwiseDisjoint h.covering :=\n  h.exists_disjoint_covering_ae.choose_spec.2.1\n\n"}
{"name":"VitaliFamily.FineSubfamilyOn.covering_disjoint_subtype","module":"Mathlib.MeasureTheory.Covering.VitaliFamily","initialProofState":"X : Type u_1\ninst✝ : PseudoMetricSpace X\nm0 : MeasurableSpace X\nμ : MeasureTheory.Measure X\nv : VitaliFamily μ\nf : X → Set (Set X)\ns : Set X\nh : v.FineSubfamilyOn f s\n⊢ Pairwise (Function.onFun Disjoint fun x => h.covering ↑x)","decl":"open scoped Function in -- required for scoped `on` notation\ntheorem covering_disjoint_subtype : Pairwise (Disjoint on fun x : h.index => h.covering x) :=\n  (pairwise_subtype_iff_pairwise_set _ _).2 h.covering_disjoint\n\n"}
{"name":"VitaliFamily.FineSubfamilyOn.covering_mem","module":"Mathlib.MeasureTheory.Covering.VitaliFamily","initialProofState":"X : Type u_1\ninst✝ : PseudoMetricSpace X\nm0 : MeasurableSpace X\nμ : MeasureTheory.Measure X\nv : VitaliFamily μ\nf : X → Set (Set X)\ns : Set X\nh : v.FineSubfamilyOn f s\np : Prod X (Set X)\nhp : Membership.mem h.index p\n⊢ Membership.mem (f p.1) (h.covering p)","decl":"theorem covering_mem {p : X × Set X} (hp : p ∈ h.index) : h.covering p ∈ f p.1 :=\n  (h.exists_disjoint_covering_ae.choose_spec.2.2.1 p hp).2\n\n"}
{"name":"VitaliFamily.FineSubfamilyOn.covering_mem_family","module":"Mathlib.MeasureTheory.Covering.VitaliFamily","initialProofState":"X : Type u_1\ninst✝ : PseudoMetricSpace X\nm0 : MeasurableSpace X\nμ : MeasureTheory.Measure X\nv : VitaliFamily μ\nf : X → Set (Set X)\ns : Set X\nh : v.FineSubfamilyOn f s\np : Prod X (Set X)\nhp : Membership.mem h.index p\n⊢ Membership.mem (v.setsAt p.1) (h.covering p)","decl":"theorem covering_mem_family {p : X × Set X} (hp : p ∈ h.index) : h.covering p ∈ v.setsAt p.1 :=\n  (h.exists_disjoint_covering_ae.choose_spec.2.2.1 p hp).1\n\n"}
{"name":"VitaliFamily.FineSubfamilyOn.measure_diff_biUnion","module":"Mathlib.MeasureTheory.Covering.VitaliFamily","initialProofState":"X : Type u_1\ninst✝ : PseudoMetricSpace X\nm0 : MeasurableSpace X\nμ : MeasureTheory.Measure X\nv : VitaliFamily μ\nf : X → Set (Set X)\ns : Set X\nh : v.FineSubfamilyOn f s\n⊢ Eq (μ (SDiff.sdiff s (Set.iUnion fun p => Set.iUnion fun h_1 => h.covering p))) 0","decl":"theorem measure_diff_biUnion : μ (s \\ ⋃ p ∈ h.index, h.covering p) = 0 :=\n  h.exists_disjoint_covering_ae.choose_spec.2.2.2\n\n"}
{"name":"VitaliFamily.FineSubfamilyOn.index_countable","module":"Mathlib.MeasureTheory.Covering.VitaliFamily","initialProofState":"X : Type u_1\ninst✝¹ : PseudoMetricSpace X\nm0 : MeasurableSpace X\nμ : MeasureTheory.Measure X\nv : VitaliFamily μ\nf : X → Set (Set X)\ns : Set X\nh : v.FineSubfamilyOn f s\ninst✝ : SecondCountableTopology X\n⊢ h.index.Countable","decl":"theorem index_countable [SecondCountableTopology X] : h.index.Countable :=\n  h.covering_disjoint.countable_of_nonempty_interior fun _ hx =>\n    v.nonempty_interior _ _ (h.covering_mem_family hx)\n\n"}
{"name":"VitaliFamily.FineSubfamilyOn.measurableSet_u","module":"Mathlib.MeasureTheory.Covering.VitaliFamily","initialProofState":"X : Type u_1\ninst✝ : PseudoMetricSpace X\nm0 : MeasurableSpace X\nμ : MeasureTheory.Measure X\nv : VitaliFamily μ\nf : X → Set (Set X)\ns : Set X\nh : v.FineSubfamilyOn f s\np : Prod X (Set X)\nhp : Membership.mem h.index p\n⊢ MeasurableSet (h.covering p)","decl":"protected theorem measurableSet_u {p : X × Set X} (hp : p ∈ h.index) :\n    MeasurableSet (h.covering p) :=\n  v.measurableSet p.1 _ (h.covering_mem_family hp)\n\n"}
{"name":"VitaliFamily.FineSubfamilyOn.measure_le_tsum_of_absolutelyContinuous","module":"Mathlib.MeasureTheory.Covering.VitaliFamily","initialProofState":"X : Type u_1\ninst✝¹ : PseudoMetricSpace X\nm0 : MeasurableSpace X\nμ : MeasureTheory.Measure X\nv : VitaliFamily μ\nf : X → Set (Set X)\ns : Set X\nh : v.FineSubfamilyOn f s\ninst✝ : SecondCountableTopology X\nρ : MeasureTheory.Measure X\nhρ : ρ.AbsolutelyContinuous μ\n⊢ LE.le (ρ s) (tsum fun p => ρ (h.covering ↑p))","decl":"theorem measure_le_tsum_of_absolutelyContinuous [SecondCountableTopology X] {ρ : Measure X}\n    (hρ : ρ ≪ μ) : ρ s ≤ ∑' p : h.index, ρ (h.covering p) :=\n  calc\n    ρ s ≤ ρ ((s \\ ⋃ p ∈ h.index, h.covering p) ∪ ⋃ p ∈ h.index, h.covering p) :=\n      measure_mono (by simp only [subset_union_left, diff_union_self])\n    _ ≤ ρ (s \\ ⋃ p ∈ h.index, h.covering p) + ρ (⋃ p ∈ h.index, h.covering p) :=\n      (measure_union_le _ _)\n    _ = ∑' p : h.index, ρ (h.covering p) := by\n      rw [hρ h.measure_diff_biUnion, zero_add,\n        measure_biUnion h.index_countable h.covering_disjoint fun x hx => h.measurableSet_u hx]\n\n"}
{"name":"VitaliFamily.FineSubfamilyOn.measure_le_tsum","module":"Mathlib.MeasureTheory.Covering.VitaliFamily","initialProofState":"X : Type u_1\ninst✝¹ : PseudoMetricSpace X\nm0 : MeasurableSpace X\nμ : MeasureTheory.Measure X\nv : VitaliFamily μ\nf : X → Set (Set X)\ns : Set X\nh : v.FineSubfamilyOn f s\ninst✝ : SecondCountableTopology X\n⊢ LE.le (μ s) (tsum fun x => μ (h.covering ↑x))","decl":"theorem measure_le_tsum [SecondCountableTopology X] : μ s ≤ ∑' x : h.index, μ (h.covering x) :=\n  h.measure_le_tsum_of_absolutelyContinuous Measure.AbsolutelyContinuous.rfl\n\n"}
{"name":"Filter.HasBasis.vitaliFamily","module":"Mathlib.MeasureTheory.Covering.VitaliFamily","initialProofState":"X : Type u_1\ninst✝ : PseudoMetricSpace X\nm0 : MeasurableSpace X\nμ : MeasureTheory.Measure X\nv : VitaliFamily μ\nι : Sort u_2\np : ι → Prop\ns : ι → Set X\nx : X\nh : (nhds x).HasBasis p s\n⊢ (v.filterAt x).HasBasis p fun i => setOf fun t => And (Membership.mem (v.setsAt x) t) (HasSubset.Subset t (s i))","decl":"theorem _root_.Filter.HasBasis.vitaliFamily {ι : Sort*} {p : ι → Prop} {s : ι → Set X} {x : X}\n    (h : (𝓝 x).HasBasis p s) : (v.filterAt x).HasBasis p (fun i ↦ {t ∈ v.setsAt x | t ⊆ s i}) := by\n  simpa only [← Set.setOf_inter_eq_sep] using h.smallSets.inf_principal _\n\n"}
{"name":"VitaliFamily.filterAt_basis_closedBall","module":"Mathlib.MeasureTheory.Covering.VitaliFamily","initialProofState":"X : Type u_1\ninst✝ : PseudoMetricSpace X\nm0 : MeasurableSpace X\nμ : MeasureTheory.Measure X\nv : VitaliFamily μ\nx : X\n⊢ (v.filterAt x).HasBasis (fun x => LT.lt 0 x) fun x_1 => setOf fun t => And (Membership.mem (v.setsAt x) t) (HasSubset.Subset t (Metric.closedBall x x_1))","decl":"theorem filterAt_basis_closedBall (x : X) :\n    (v.filterAt x).HasBasis (0 < ·) ({t ∈ v.setsAt x | t ⊆ closedBall x ·}) :=\n  nhds_basis_closedBall.vitaliFamily v\n\n"}
{"name":"VitaliFamily.mem_filterAt_iff","module":"Mathlib.MeasureTheory.Covering.VitaliFamily","initialProofState":"X : Type u_1\ninst✝ : PseudoMetricSpace X\nm0 : MeasurableSpace X\nμ : MeasureTheory.Measure X\nv : VitaliFamily μ\nx : X\ns : Set (Set X)\n⊢ Iff (Membership.mem (v.filterAt x) s) (Exists fun ε => And (GT.gt ε 0) (∀ (t : Set X), Membership.mem (v.setsAt x) t → HasSubset.Subset t (Metric.closedBall x ε) → Membership.mem s t))","decl":"theorem mem_filterAt_iff {x : X} {s : Set (Set X)} :\n    s ∈ v.filterAt x ↔ ∃ ε > (0 : ℝ), ∀ t ∈ v.setsAt x, t ⊆ closedBall x ε → t ∈ s := by\n  simp only [(v.filterAt_basis_closedBall x).mem_iff, ← and_imp, subset_def, mem_setOf]\n\n"}
{"name":"VitaliFamily.filterAt_neBot","module":"Mathlib.MeasureTheory.Covering.VitaliFamily","initialProofState":"X : Type u_1\ninst✝ : PseudoMetricSpace X\nm0 : MeasurableSpace X\nμ : MeasureTheory.Measure X\nv : VitaliFamily μ\nx : X\n⊢ (v.filterAt x).NeBot","decl":"instance filterAt_neBot (x : X) : (v.filterAt x).NeBot :=\n  (v.filterAt_basis_closedBall x).neBot_iff.2 <| v.nontrivial _ _\n\n"}
{"name":"VitaliFamily.eventually_filterAt_iff","module":"Mathlib.MeasureTheory.Covering.VitaliFamily","initialProofState":"X : Type u_1\ninst✝ : PseudoMetricSpace X\nm0 : MeasurableSpace X\nμ : MeasureTheory.Measure X\nv : VitaliFamily μ\nx : X\nP : Set X → Prop\n⊢ Iff (Filter.Eventually (fun t => P t) (v.filterAt x)) (Exists fun ε => And (GT.gt ε 0) (∀ (t : Set X), Membership.mem (v.setsAt x) t → HasSubset.Subset t (Metric.closedBall x ε) → P t))","decl":"theorem eventually_filterAt_iff {x : X} {P : Set X → Prop} :\n    (∀ᶠ t in v.filterAt x, P t) ↔ ∃ ε > (0 : ℝ), ∀ t ∈ v.setsAt x, t ⊆ closedBall x ε → P t :=\n  v.mem_filterAt_iff\n\n"}
{"name":"VitaliFamily.tendsto_filterAt_iff","module":"Mathlib.MeasureTheory.Covering.VitaliFamily","initialProofState":"X : Type u_1\ninst✝ : PseudoMetricSpace X\nm0 : MeasurableSpace X\nμ : MeasureTheory.Measure X\nv : VitaliFamily μ\nι : Type u_2\nl : Filter ι\nf : ι → Set X\nx : X\n⊢ Iff (Filter.Tendsto f l (v.filterAt x)) (And (Filter.Eventually (fun i => Membership.mem (v.setsAt x) (f i)) l) (∀ (ε : Real), GT.gt ε 0 → Filter.Eventually (fun i => HasSubset.Subset (f i) (Metric.closedBall x ε)) l))","decl":"theorem tendsto_filterAt_iff {ι : Type*} {l : Filter ι} {f : ι → Set X} {x : X} :\n    Tendsto f l (v.filterAt x) ↔\n      (∀ᶠ i in l, f i ∈ v.setsAt x) ∧ ∀ ε > (0 : ℝ), ∀ᶠ i in l, f i ⊆ closedBall x ε := by\n  simp only [filterAt, tendsto_inf, nhds_basis_closedBall.smallSets.tendsto_right_iff,\n    tendsto_principal, and_comm, mem_powerset_iff]\n\n"}
{"name":"VitaliFamily.eventually_filterAt_mem_setsAt","module":"Mathlib.MeasureTheory.Covering.VitaliFamily","initialProofState":"X : Type u_1\ninst✝ : PseudoMetricSpace X\nm0 : MeasurableSpace X\nμ : MeasureTheory.Measure X\nv : VitaliFamily μ\nx : X\n⊢ Filter.Eventually (fun t => Membership.mem (v.setsAt x) t) (v.filterAt x)","decl":"theorem eventually_filterAt_mem_setsAt (x : X) : ∀ᶠ t in v.filterAt x, t ∈ v.setsAt x :=\n  (v.tendsto_filterAt_iff.mp tendsto_id).1\n\n"}
{"name":"VitaliFamily.eventually_filterAt_subset_closedBall","module":"Mathlib.MeasureTheory.Covering.VitaliFamily","initialProofState":"X : Type u_1\ninst✝ : PseudoMetricSpace X\nm0 : MeasurableSpace X\nμ : MeasureTheory.Measure X\nv : VitaliFamily μ\nx : X\nε : Real\nhε : LT.lt 0 ε\n⊢ Filter.Eventually (fun t => HasSubset.Subset t (Metric.closedBall x ε)) (v.filterAt x)","decl":"theorem eventually_filterAt_subset_closedBall (x : X) {ε : ℝ} (hε : 0 < ε) :\n    ∀ᶠ t : Set X in v.filterAt x, t ⊆ closedBall x ε :=\n  (v.tendsto_filterAt_iff.mp tendsto_id).2 ε hε\n\n"}
{"name":"VitaliFamily.eventually_filterAt_measurableSet","module":"Mathlib.MeasureTheory.Covering.VitaliFamily","initialProofState":"X : Type u_1\ninst✝ : PseudoMetricSpace X\nm0 : MeasurableSpace X\nμ : MeasureTheory.Measure X\nv : VitaliFamily μ\nx : X\n⊢ Filter.Eventually (fun t => MeasurableSet t) (v.filterAt x)","decl":"theorem eventually_filterAt_measurableSet (x : X) : ∀ᶠ t in v.filterAt x, MeasurableSet t := by\n  filter_upwards [v.eventually_filterAt_mem_setsAt x] with _ ha using v.measurableSet _ _ ha\n\n"}
{"name":"VitaliFamily.frequently_filterAt_iff","module":"Mathlib.MeasureTheory.Covering.VitaliFamily","initialProofState":"X : Type u_1\ninst✝ : PseudoMetricSpace X\nm0 : MeasurableSpace X\nμ : MeasureTheory.Measure X\nv : VitaliFamily μ\nx : X\nP : Set X → Prop\n⊢ Iff (Filter.Frequently (fun t => P t) (v.filterAt x)) (∀ (ε : Real), GT.gt ε 0 → Exists fun t => And (Membership.mem (v.setsAt x) t) (And (HasSubset.Subset t (Metric.closedBall x ε)) (P t)))","decl":"theorem frequently_filterAt_iff {x : X} {P : Set X → Prop} :\n    (∃ᶠ t in v.filterAt x, P t) ↔ ∀ ε > (0 : ℝ), ∃ t ∈ v.setsAt x, t ⊆ closedBall x ε ∧ P t := by\n  simp only [(v.filterAt_basis_closedBall x).frequently_iff, ← and_assoc, subset_def, mem_setOf]\n\n"}
{"name":"VitaliFamily.eventually_filterAt_subset_of_nhds","module":"Mathlib.MeasureTheory.Covering.VitaliFamily","initialProofState":"X : Type u_1\ninst✝ : PseudoMetricSpace X\nm0 : MeasurableSpace X\nμ : MeasureTheory.Measure X\nv : VitaliFamily μ\nx : X\no : Set X\nhx : Membership.mem (nhds x) o\n⊢ Filter.Eventually (fun t => HasSubset.Subset t o) (v.filterAt x)","decl":"theorem eventually_filterAt_subset_of_nhds {x : X} {o : Set X} (hx : o ∈ 𝓝 x) :\n    ∀ᶠ t in v.filterAt x, t ⊆ o :=\n  (eventually_smallSets_subset.2 hx).filter_mono inf_le_left\n\n"}
{"name":"VitaliFamily.fineSubfamilyOn_of_frequently","module":"Mathlib.MeasureTheory.Covering.VitaliFamily","initialProofState":"X : Type u_1\ninst✝ : PseudoMetricSpace X\nm0 : MeasurableSpace X\nμ : MeasureTheory.Measure X\nv : VitaliFamily μ\nf : X → Set (Set X)\ns : Set X\nh : ∀ (x : X), Membership.mem s x → Filter.Frequently (fun t => Membership.mem (f x) t) (v.filterAt x)\n⊢ v.FineSubfamilyOn f s","decl":"theorem fineSubfamilyOn_of_frequently (v : VitaliFamily μ) (f : X → Set (Set X)) (s : Set X)\n    (h : ∀ x ∈ s, ∃ᶠ t in v.filterAt x, t ∈ f x) : v.FineSubfamilyOn f s := by\n  intro x hx ε εpos\n  obtain ⟨t, tv, ht, tf⟩ : ∃ t ∈ v.setsAt x, t ⊆ closedBall x ε ∧ t ∈ f x :=\n    v.frequently_filterAt_iff.1 (h x hx) ε εpos\n  exact ⟨t, ⟨tv, tf⟩, ht⟩\n\n"}
