{"name":"Finite.instProd","module":"Mathlib.Data.Finite.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Finite α\ninst✝ : Finite β\n⊢ Finite (Prod α β)","decl":"instance [Finite α] [Finite β] : Finite (α × β) := by\n  haveI := Fintype.ofFinite α\n  haveI := Fintype.ofFinite β\n  infer_instance\n\n"}
{"name":"Finite.instPProd","module":"Mathlib.Data.Finite.Prod","initialProofState":"α : Sort u_3\nβ : Sort u_4\ninst✝¹ : Finite α\ninst✝ : Finite β\n⊢ Finite (PProd α β)","decl":"instance {α β : Sort*} [Finite α] [Finite β] : Finite (PProd α β) :=\n  of_equiv _ Equiv.pprodEquivProdPLift.symm\n\n"}
{"name":"Finite.prod_left","module":"Mathlib.Data.Finite.Prod","initialProofState":"α : Type u_1\nβ : Type u_3\ninst✝¹ : Finite (Prod α β)\ninst✝ : Nonempty β\n⊢ Finite α","decl":"theorem prod_left (β) [Finite (α × β)] [Nonempty β] : Finite α :=\n  of_surjective (Prod.fst : α × β → α) Prod.fst_surjective\n\n"}
{"name":"Finite.prod_right","module":"Mathlib.Data.Finite.Prod","initialProofState":"β : Type u_2\nα : Type u_3\ninst✝¹ : Finite (Prod α β)\ninst✝ : Nonempty α\n⊢ Finite β","decl":"theorem prod_right (α) [Finite (α × β)] [Nonempty α] : Finite β :=\n  of_surjective (Prod.snd : α × β → β) Prod.snd_surjective\n\n"}
{"name":"Pi.finite","module":"Mathlib.Data.Finite.Prod","initialProofState":"α : Sort u_3\nβ : α → Sort u_4\ninst✝¹ : Finite α\ninst✝ : ∀ (a : α), Finite (β a)\n⊢ Finite ((a : α) → β a)","decl":"instance Pi.finite {α : Sort*} {β : α → Sort*} [Finite α] [∀ a, Finite (β a)] :\n    Finite (∀ a, β a) := by\n  classical\n  haveI := Fintype.ofFinite (PLift α)\n  haveI := fun a => Fintype.ofFinite (PLift (β a))\n  exact\n    Finite.of_equiv (∀ a : PLift α, PLift (β (Equiv.plift a)))\n      (Equiv.piCongr Equiv.plift fun _ => Equiv.plift)\n\n"}
{"name":"instFiniteSym","module":"Mathlib.Data.Finite.Prod","initialProofState":"α : Type u_1\ninst✝ : Finite α\nn : Nat\n⊢ Finite (Sym α n)","decl":"instance [Finite α] {n : ℕ} : Finite (Sym α n) := by\n  classical\n  haveI := Fintype.ofFinite α\n  infer_instance\n\n"}
{"name":"Function.Embedding.finite","module":"Mathlib.Data.Finite.Prod","initialProofState":"α : Sort u_3\nβ : Sort u_4\ninst✝ : Finite β\n⊢ Finite (Function.Embedding α β)","decl":"instance Function.Embedding.finite {α β : Sort*} [Finite β] : Finite (α ↪ β) := by\n  cases' isEmpty_or_nonempty (α ↪ β) with _ h\n  · -- Porting note: infer_instance fails because it applies `Finite.of_fintype` and produces a\n    -- \"stuck at solving universe constraint\" error.\n    apply Finite.of_subsingleton\n\n  · refine h.elim fun f => ?_\n    haveI : Finite α := Finite.of_injective _ f.injective\n    exact Finite.of_injective _ DFunLike.coe_injective\n\n"}
{"name":"Equiv.finite_right","module":"Mathlib.Data.Finite.Prod","initialProofState":"α : Sort u_3\nβ : Sort u_4\ninst✝ : Finite β\n⊢ Finite (Equiv α β)","decl":"instance Equiv.finite_right {α β : Sort*} [Finite β] : Finite (α ≃ β) :=\n  Finite.of_injective Equiv.toEmbedding fun e₁ e₂ h => Equiv.ext <| by\n    convert DFunLike.congr_fun h using 0\n\n"}
{"name":"Equiv.finite_left","module":"Mathlib.Data.Finite.Prod","initialProofState":"α : Sort u_3\nβ : Sort u_4\ninst✝ : Finite α\n⊢ Finite (Equiv α β)","decl":"instance Equiv.finite_left {α β : Sort*} [Finite α] : Finite (α ≃ β) :=\n  Finite.of_equiv _ ⟨Equiv.symm, Equiv.symm, Equiv.symm_symm, Equiv.symm_symm⟩\n\n"}
{"name":"AddEquiv.finite_left","module":"Mathlib.Data.Finite.Prod","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝² : Add α\ninst✝¹ : Add β\ninst✝ : Finite α\n⊢ Finite (AddEquiv α β)","decl":"@[to_additive]\ninstance MulEquiv.finite_left {α β : Type*} [Mul α] [Mul β] [Finite α] : Finite (α ≃* β) :=\n  Finite.of_injective toEquiv toEquiv_injective\n\n"}
{"name":"MulEquiv.finite_left","module":"Mathlib.Data.Finite.Prod","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝² : Mul α\ninst✝¹ : Mul β\ninst✝ : Finite α\n⊢ Finite (MulEquiv α β)","decl":"@[to_additive]\ninstance MulEquiv.finite_left {α β : Type*} [Mul α] [Mul β] [Finite α] : Finite (α ≃* β) :=\n  Finite.of_injective toEquiv toEquiv_injective\n\n"}
{"name":"AddEquiv.finite_right","module":"Mathlib.Data.Finite.Prod","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝² : Add α\ninst✝¹ : Add β\ninst✝ : Finite β\n⊢ Finite (AddEquiv α β)","decl":"@[to_additive]\ninstance MulEquiv.finite_right {α β : Type*} [Mul α] [Mul β] [Finite β] : Finite (α ≃* β) :=\n  Finite.of_injective toEquiv toEquiv_injective\n\n"}
{"name":"MulEquiv.finite_right","module":"Mathlib.Data.Finite.Prod","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝² : Mul α\ninst✝¹ : Mul β\ninst✝ : Finite β\n⊢ Finite (MulEquiv α β)","decl":"@[to_additive]\ninstance MulEquiv.finite_right {α β : Type*} [Mul α] [Mul β] [Finite β] : Finite (α ≃* β) :=\n  Finite.of_injective toEquiv toEquiv_injective\n\n"}
{"name":"Finite.Set.finite_prod","module":"Mathlib.Data.Finite.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nt : Set β\ninst✝¹ : Finite ↑s\ninst✝ : Finite ↑t\n⊢ Finite ↑(SProd.sprod s t)","decl":"instance finite_prod (s : Set α) (t : Set β) [Finite s] [Finite t] :\n    Finite (s ×ˢ t : Set (α × β)) :=\n  Finite.of_equiv _ (Equiv.Set.prod s t).symm\n\n"}
{"name":"Finite.Set.finite_image2","module":"Mathlib.Data.Finite.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nf : α → β → γ\ns : Set α\nt : Set β\ninst✝¹ : Finite ↑s\ninst✝ : Finite ↑t\n⊢ Finite ↑(Set.image2 f s t)","decl":"instance finite_image2 (f : α → β → γ) (s : Set α) (t : Set β) [Finite s] [Finite t] :\n    Finite (image2 f s t : Set γ) := by\n  rw [← image_prod]\n  infer_instance\n\n"}
{"name":"Set.Finite.prod","module":"Mathlib.Data.Finite.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nt : Set β\nhs : s.Finite\nht : t.Finite\n⊢ (SProd.sprod s t).Finite","decl":"protected theorem Finite.prod (hs : s.Finite) (ht : t.Finite) : (s ×ˢ t : Set (α × β)).Finite := by\n  have := hs.to_subtype\n  have := ht.to_subtype\n  apply toFinite\n\n"}
{"name":"Set.Finite.of_prod_left","module":"Mathlib.Data.Finite.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nt : Set β\nh : (SProd.sprod s t).Finite\na✝ : t.Nonempty\n⊢ s.Finite","decl":"theorem Finite.of_prod_left (h : (s ×ˢ t : Set (α × β)).Finite) : t.Nonempty → s.Finite :=\n  fun ⟨b, hb⟩ => (h.image Prod.fst).subset fun a ha => ⟨(a, b), ⟨ha, hb⟩, rfl⟩\n\n"}
{"name":"Set.Finite.of_prod_right","module":"Mathlib.Data.Finite.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nt : Set β\nh : (SProd.sprod s t).Finite\na✝ : s.Nonempty\n⊢ t.Finite","decl":"theorem Finite.of_prod_right (h : (s ×ˢ t : Set (α × β)).Finite) : s.Nonempty → t.Finite :=\n  fun ⟨a, ha⟩ => (h.image Prod.snd).subset fun b hb => ⟨(a, b), ⟨ha, hb⟩, rfl⟩\n\n"}
{"name":"Set.Infinite.prod_left","module":"Mathlib.Data.Finite.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nt : Set β\nhs : s.Infinite\nht : t.Nonempty\n⊢ (SProd.sprod s t).Infinite","decl":"protected theorem Infinite.prod_left (hs : s.Infinite) (ht : t.Nonempty) : (s ×ˢ t).Infinite :=\n  fun h => hs <| h.of_prod_left ht\n\n"}
{"name":"Set.Infinite.prod_right","module":"Mathlib.Data.Finite.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nt : Set β\nht : t.Infinite\nhs : s.Nonempty\n⊢ (SProd.sprod s t).Infinite","decl":"protected theorem Infinite.prod_right (ht : t.Infinite) (hs : s.Nonempty) : (s ×ˢ t).Infinite :=\n  fun h => ht <| h.of_prod_right hs\n\n"}
{"name":"Set.infinite_prod","module":"Mathlib.Data.Finite.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nt : Set β\n⊢ Iff (SProd.sprod s t).Infinite (Or (And s.Infinite t.Nonempty) (And t.Infinite s.Nonempty))","decl":"protected theorem infinite_prod :\n    (s ×ˢ t).Infinite ↔ s.Infinite ∧ t.Nonempty ∨ t.Infinite ∧ s.Nonempty := by\n  refine ⟨fun h => ?_, ?_⟩\n  · simp_rw [Set.Infinite, @and_comm ¬_, ← Classical.not_imp]\n    by_contra!\n    exact h ((this.1 h.nonempty.snd).prod <| this.2 h.nonempty.fst)\n  · rintro (h | h)\n    · exact h.1.prod_left h.2\n    · exact h.1.prod_right h.2\n\n"}
{"name":"Set.finite_prod","module":"Mathlib.Data.Finite.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nt : Set β\n⊢ Iff (SProd.sprod s t).Finite (And (Or s.Finite (Eq t EmptyCollection.emptyCollection)) (Or t.Finite (Eq s EmptyCollection.emptyCollection)))","decl":"theorem finite_prod : (s ×ˢ t).Finite ↔ (s.Finite ∨ t = ∅) ∧ (t.Finite ∨ s = ∅) := by\n  simp only [← not_infinite, Set.infinite_prod, not_or, not_and_or, not_nonempty_iff_eq_empty]\n\n"}
{"name":"Set.Finite.offDiag","module":"Mathlib.Data.Finite.Prod","initialProofState":"α : Type u_1\ns : Set α\nhs : s.Finite\n⊢ s.offDiag.Finite","decl":"protected theorem Finite.offDiag {s : Set α} (hs : s.Finite) : s.offDiag.Finite :=\n  (hs.prod hs).subset s.offDiag_subset_prod\n\n"}
{"name":"Set.Finite.image2","module":"Mathlib.Data.Finite.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ns : Set α\nt : Set β\nf : α → β → γ\nhs : s.Finite\nht : t.Finite\n⊢ (Set.image2 f s t).Finite","decl":"protected theorem Finite.image2 (f : α → β → γ) (hs : s.Finite) (ht : t.Finite) :\n    (image2 f s t).Finite := by\n  have := hs.to_subtype\n  have := ht.to_subtype\n  apply toFinite\n\n"}
{"name":"Set.Finite.toFinset_prod","module":"Mathlib.Data.Finite.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nt : Set β\nhs : s.Finite\nht : t.Finite\n⊢ Eq (SProd.sprod hs.toFinset ht.toFinset) ⋯.toFinset","decl":"theorem Finite.toFinset_prod {s : Set α} {t : Set β} (hs : s.Finite) (ht : t.Finite) :\n    hs.toFinset ×ˢ ht.toFinset = (hs.prod ht).toFinset :=\n  Finset.ext <| by simp\n\n"}
{"name":"Set.Finite.toFinset_offDiag","module":"Mathlib.Data.Finite.Prod","initialProofState":"α : Type u_1\ns : Set α\ninst✝ : DecidableEq α\nhs : s.Finite\n⊢ Eq ⋯.toFinset hs.toFinset.offDiag","decl":"theorem Finite.toFinset_offDiag {s : Set α} [DecidableEq α] (hs : s.Finite) :\n    hs.offDiag.toFinset = hs.toFinset.offDiag :=\n  Finset.ext <| by simp\n\n"}
{"name":"Set.finite_image_fst_and_snd_iff","module":"Mathlib.Data.Finite.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set (Prod α β)\n⊢ Iff (And (Set.image Prod.fst s).Finite (Set.image Prod.snd s).Finite) s.Finite","decl":"theorem finite_image_fst_and_snd_iff {s : Set (α × β)} :\n    (Prod.fst '' s).Finite ∧ (Prod.snd '' s).Finite ↔ s.Finite :=\n  ⟨fun h => (h.1.prod h.2).subset fun _ h => ⟨mem_image_of_mem _ h, mem_image_of_mem _ h⟩,\n    fun h => ⟨h.image _, h.image _⟩⟩\n\n"}
{"name":"Set.Infinite.image2_left","module":"Mathlib.Data.Finite.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nf : α → β → γ\ns : Set α\nt : Set β\nb : β\nhs : s.Infinite\nhb : Membership.mem t b\nhf : Set.InjOn (fun a => f a b) s\n⊢ (Set.image2 f s t).Infinite","decl":"protected theorem Infinite.image2_left (hs : s.Infinite) (hb : b ∈ t)\n    (hf : InjOn (fun a => f a b) s) : (image2 f s t).Infinite :=\n  (hs.image hf).mono <| image_subset_image2_left hb\n\n"}
{"name":"Set.Infinite.image2_right","module":"Mathlib.Data.Finite.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nf : α → β → γ\ns : Set α\nt : Set β\na : α\nht : t.Infinite\nha : Membership.mem s a\nhf : Set.InjOn (f a) t\n⊢ (Set.image2 f s t).Infinite","decl":"protected theorem Infinite.image2_right (ht : t.Infinite) (ha : a ∈ s) (hf : InjOn (f a) t) :\n    (image2 f s t).Infinite :=\n  (ht.image hf).mono <| image_subset_image2_right ha\n\n"}
{"name":"Set.infinite_image2","module":"Mathlib.Data.Finite.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nf : α → β → γ\ns : Set α\nt : Set β\nhfs : ∀ (b : β), Membership.mem t b → Set.InjOn (fun a => f a b) s\nhft : ∀ (a : α), Membership.mem s a → Set.InjOn (f a) t\n⊢ Iff (Set.image2 f s t).Infinite (Or (And s.Infinite t.Nonempty) (And t.Infinite s.Nonempty))","decl":"theorem infinite_image2 (hfs : ∀ b ∈ t, InjOn (fun a => f a b) s) (hft : ∀ a ∈ s, InjOn (f a) t) :\n    (image2 f s t).Infinite ↔ s.Infinite ∧ t.Nonempty ∨ t.Infinite ∧ s.Nonempty := by\n  refine ⟨fun h => Set.infinite_prod.1 ?_, ?_⟩\n  · rw [← image_uncurry_prod] at h\n    exact h.of_image _\n  · rintro (⟨hs, b, hb⟩ | ⟨ht, a, ha⟩)\n    · exact hs.image2_left hb (hfs _ hb)\n    · exact ht.image2_right ha (hft _ ha)\n\n"}
{"name":"Set.finite_image2","module":"Mathlib.Data.Finite.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nf : α → β → γ\ns : Set α\nt : Set β\nhfs : ∀ (b : β), Membership.mem t b → Set.InjOn (fun x => f x b) s\nhft : ∀ (a : α), Membership.mem s a → Set.InjOn (f a) t\n⊢ Iff (Set.image2 f s t).Finite (Or (And s.Finite t.Finite) (Or (Eq s EmptyCollection.emptyCollection) (Eq t EmptyCollection.emptyCollection)))","decl":"lemma finite_image2 (hfs : ∀ b ∈ t, InjOn (f · b) s) (hft : ∀ a ∈ s, InjOn (f a) t) :\n    (image2 f s t).Finite ↔ s.Finite ∧ t.Finite ∨ s = ∅ ∨ t = ∅ := by\n  rw [← not_infinite, infinite_image2 hfs hft]\n  simp [not_or, -not_and, not_and_or, not_nonempty_iff_eq_empty]\n  aesop\n\n"}
