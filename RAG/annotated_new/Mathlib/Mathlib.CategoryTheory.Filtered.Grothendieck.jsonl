{"name":"CategoryTheory.instIsFilteredOrEmptyGrothendieckOfαCategoryObjCat","module":"Mathlib.CategoryTheory.Filtered.Grothendieck","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor C CategoryTheory.Cat\ninst✝¹ : CategoryTheory.IsFilteredOrEmpty C\ninst✝ : ∀ (c : C), CategoryTheory.IsFilteredOrEmpty ↑(F.obj c)\n⊢ CategoryTheory.IsFilteredOrEmpty (CategoryTheory.Grothendieck F)","decl":"instance [IsFilteredOrEmpty C] [∀ c, IsFilteredOrEmpty (F.obj c)] :\n    IsFilteredOrEmpty (Grothendieck F) := by\n  refine ⟨?_, ?_⟩\n  · rintro ⟨c, f⟩ ⟨d, g⟩\n    exact ⟨⟨max c d, max ((F.map (leftToMax c d)).obj f) ((F.map (rightToMax c d)).obj g)⟩,\n      ⟨leftToMax c d, leftToMax _ _⟩, ⟨rightToMax c d, rightToMax _ _⟩, trivial⟩\n  · rintro ⟨c, f⟩ ⟨d, g⟩ ⟨u, x⟩ ⟨v, y⟩\n    refine ⟨⟨coeq u v, coeq (eqToHom ?_ ≫\n        (F.map (coeqHom u v)).map x) ((F.map (coeqHom u v)).map y)⟩, ⟨coeqHom u v, coeqHom _ _⟩, ?_⟩\n    · conv_rhs => rw [← Cat.comp_obj, ← F.map_comp, coeq_condition, F.map_comp, Cat.comp_obj]\n    · apply Grothendieck.ext _ _ (coeq_condition u v)\n      refine Eq.trans ?_ (eqToHom _ ≫= coeq_condition _ _)\n      simp\n\n"}
{"name":"CategoryTheory.instIsFilteredGrothendieckOfαCategoryObjCat","module":"Mathlib.CategoryTheory.Filtered.Grothendieck","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor C CategoryTheory.Cat\ninst✝¹ : CategoryTheory.IsFiltered C\ninst✝ : ∀ (c : C), CategoryTheory.IsFiltered ↑(F.obj c)\n⊢ CategoryTheory.IsFiltered (CategoryTheory.Grothendieck F)","decl":"instance [IsFiltered C] [∀ c, IsFiltered (F.obj c)] : IsFiltered (Grothendieck F) := by\n  have : Nonempty (Grothendieck F) := by\n    obtain ⟨c⟩ : Nonempty C := IsFiltered.nonempty\n    obtain ⟨f⟩ : Nonempty (F.obj c) := IsFiltered.nonempty\n    exact ⟨⟨c, f⟩⟩\n  apply IsFiltered.mk\n\n"}
