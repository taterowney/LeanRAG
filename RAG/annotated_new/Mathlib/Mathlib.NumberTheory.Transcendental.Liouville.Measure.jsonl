{"name":"setOf_liouvilleWith_subset_aux","module":"Mathlib.NumberTheory.Transcendental.Liouville.Measure","initialProofState":"⊢ HasSubset.Subset (setOf fun x => Exists fun p => And (GT.gt p 2) (LiouvilleWith p x)) (Set.iUnion fun m => Set.preimage (fun x => HAdd.hAdd x ↑m) (Set.iUnion fun n => Set.iUnion fun h => setOf fun x => Filter.Frequently (fun b => Exists fun a => And (Membership.mem (Finset.Icc 0 ↑b) a) (LT.lt (abs (HSub.hSub x (HDiv.hDiv ↑a ↑b))) (HDiv.hDiv 1 (HPow.hPow (↑b) (HAdd.hAdd 2 (HDiv.hDiv 1 ↑n)))))) Filter.atTop))","decl":"theorem setOf_liouvilleWith_subset_aux :\n    { x : ℝ | ∃ p > 2, LiouvilleWith p x } ⊆\n      ⋃ m : ℤ, (· + (m : ℝ)) ⁻¹' ⋃ n > (0 : ℕ),\n        { x : ℝ | ∃ᶠ b : ℕ in atTop, ∃ a ∈ Finset.Icc (0 : ℤ) b,\n          |x - (a : ℤ) / b| < 1 / (b : ℝ) ^ (2 + 1 / n : ℝ) } := by\n  rintro x ⟨p, hp, hxp⟩\n  rcases exists_nat_one_div_lt (sub_pos.2 hp) with ⟨n, hn⟩\n  rw [lt_sub_iff_add_lt'] at hn\n  suffices ∀ y : ℝ, LiouvilleWith p y → y ∈ Ico (0 : ℝ) 1 → ∃ᶠ b : ℕ in atTop,\n      ∃ a ∈ Finset.Icc (0 : ℤ) b, |y - a / b| < 1 / (b : ℝ) ^ (2 + 1 / (n + 1 : ℕ) : ℝ) by\n    simp only [mem_iUnion, mem_preimage]\n    have hx : x + ↑(-⌊x⌋) ∈ Ico (0 : ℝ) 1 := by\n      simp only [Int.floor_le, Int.lt_floor_add_one, add_neg_lt_iff_le_add', zero_add, and_self_iff,\n        mem_Ico, Int.cast_neg, le_add_neg_iff_add_le]\n    exact ⟨-⌊x⌋, n + 1, n.succ_pos, this _ (hxp.add_int _) hx⟩\n  clear hxp x; intro x hxp hx01\n  refine ((hxp.frequently_lt_rpow_neg hn).and_eventually (eventually_ge_atTop 1)).mono ?_\n  rintro b ⟨⟨a, -, hlt⟩, hb⟩\n  rw [rpow_neg b.cast_nonneg, ← one_div, ← Nat.cast_succ] at hlt\n  refine ⟨a, ?_, hlt⟩\n  replace hb : (1 : ℝ) ≤ b := Nat.one_le_cast.2 hb\n  have hb0 : (0 : ℝ) < b := zero_lt_one.trans_le hb\n  replace hlt : |x - a / b| < 1 / b := by\n    refine hlt.trans_le (one_div_le_one_div_of_le hb0 ?_)\n    calc\n      (b : ℝ) = (b : ℝ) ^ (1 : ℝ) := (rpow_one _).symm\n      _ ≤ (b : ℝ) ^ (2 + 1 / (n + 1 : ℕ) : ℝ) :=\n        rpow_le_rpow_of_exponent_le hb (one_le_two.trans ?_)\n    simpa using n.cast_add_one_pos.le\n  rw [sub_div' _ _ _ hb0.ne', abs_div, abs_of_pos hb0, div_lt_div_iff_of_pos_right hb0,\n    abs_sub_lt_iff, sub_lt_iff_lt_add, sub_lt_iff_lt_add, ← sub_lt_iff_lt_add'] at hlt\n  rw [Finset.mem_Icc, ← Int.lt_add_one_iff, ← Int.lt_add_one_iff, ← neg_lt_iff_pos_add, add_comm, ←\n    @Int.cast_lt ℝ, ← @Int.cast_lt ℝ]\n  push_cast\n  refine ⟨lt_of_le_of_lt ?_ hlt.1, hlt.2.trans_le ?_⟩\n  · simp only [mul_nonneg hx01.left b.cast_nonneg, neg_le_sub_iff_le_add, le_add_iff_nonneg_left]\n  · rw [add_le_add_iff_left]\n    exact mul_le_of_le_one_left hb0.le hx01.2.le\n\n"}
{"name":"volume_iUnion_setOf_liouvilleWith","module":"Mathlib.NumberTheory.Transcendental.Liouville.Measure","initialProofState":"⊢ Eq (MeasureTheory.MeasureSpace.volume (Set.iUnion fun p => Set.iUnion fun _hp => setOf fun x => LiouvilleWith p x)) 0","decl":"/-- The set of numbers satisfying the Liouville condition with some exponent `p > 2` has Lebesgue\nmeasure zero. -/\n@[simp]\ntheorem volume_iUnion_setOf_liouvilleWith :\n    volume (⋃ (p : ℝ) (_hp : 2 < p), { x : ℝ | LiouvilleWith p x }) = 0 := by\n  simp only [← setOf_exists, exists_prop]\n  refine measure_mono_null setOf_liouvilleWith_subset_aux ?_\n  rw [measure_iUnion_null_iff]; intro m; rw [measure_preimage_add_right]; clear m\n  refine (measure_biUnion_null_iff <| to_countable _).2 fun n (hn : 1 ≤ n) => ?_\n  generalize hr : (2 + 1 / n : ℝ) = r\n  replace hr : 2 < r := by simp [← hr, zero_lt_one.trans_le hn]\n  clear hn n\n  refine measure_setOf_frequently_eq_zero ?_\n  simp only [setOf_exists, ← exists_prop, ← Real.dist_eq, ← mem_ball, setOf_mem_eq]\n  set B : ℤ → ℕ → Set ℝ := fun a b => ball (a / b) (1 / (b : ℝ) ^ r)\n  have hB : ∀ a b, volume (B a b) = ↑((2 : ℝ≥0) / (b : ℝ≥0) ^ r) := fun a b ↦ by\n    rw [Real.volume_ball, mul_one_div, ← NNReal.coe_two, ← NNReal.coe_natCast, ← NNReal.coe_rpow,\n      ← NNReal.coe_div, ENNReal.ofReal_coe_nnreal]\n  have : ∀ b : ℕ, volume (⋃ a ∈ Finset.Icc (0 : ℤ) b, B a b) ≤\n      ↑(2 * ((b : ℝ≥0) ^ (1 - r) + (b : ℝ≥0) ^ (-r))) := fun b ↦\n    calc\n      volume (⋃ a ∈ Finset.Icc (0 : ℤ) b, B a b) ≤ ∑ a ∈ Finset.Icc (0 : ℤ) b, volume (B a b) :=\n        measure_biUnion_finset_le _ _\n      _ = ↑((b + 1) * (2 / (b : ℝ≥0) ^ r)) := by\n        simp only [hB, Int.card_Icc, Finset.sum_const, nsmul_eq_mul, sub_zero, ← Int.ofNat_succ,\n          Int.toNat_natCast, ← Nat.cast_succ, ENNReal.coe_mul, ENNReal.coe_natCast]\n      _ = _ := by\n        have : 1 - r ≠ 0 := by linarith\n        rw [ENNReal.coe_inj]\n        simp [add_mul, div_eq_mul_inv, NNReal.rpow_neg, NNReal.rpow_sub' this, mul_add,\n          mul_left_comm]\n  refine ne_top_of_le_ne_top (ENNReal.tsum_coe_ne_top_iff_summable.2 ?_) (ENNReal.tsum_le_tsum this)\n  refine (Summable.add ?_ ?_).mul_left _ <;> simp only [NNReal.summable_rpow] <;> linarith\n\n"}
{"name":"ae_not_liouvilleWith","module":"Mathlib.NumberTheory.Transcendental.Liouville.Measure","initialProofState":"⊢ Filter.Eventually (fun x => ∀ (p : Real), GT.gt p 2 → Not (LiouvilleWith p x)) (MeasureTheory.ae MeasureTheory.MeasureSpace.volume)","decl":"theorem ae_not_liouvilleWith : ∀ᵐ x, ∀ p > (2 : ℝ), ¬LiouvilleWith p x := by\n  simpa only [ae_iff, not_forall, Classical.not_not, setOf_exists] using\n    volume_iUnion_setOf_liouvilleWith\n\n"}
{"name":"ae_not_liouville","module":"Mathlib.NumberTheory.Transcendental.Liouville.Measure","initialProofState":"⊢ Filter.Eventually (fun x => Not (Liouville x)) (MeasureTheory.ae MeasureTheory.MeasureSpace.volume)","decl":"theorem ae_not_liouville : ∀ᵐ x, ¬Liouville x :=\n  ae_not_liouvilleWith.mono fun _ h₁ h₂ => h₁ 3 (by norm_num) (h₂.liouvilleWith 3)\n\n"}
{"name":"volume_setOf_liouville","module":"Mathlib.NumberTheory.Transcendental.Liouville.Measure","initialProofState":"⊢ Eq (MeasureTheory.MeasureSpace.volume (setOf fun x => Liouville x)) 0","decl":"/-- The set of Liouville numbers has Lebesgue measure zero. -/\n@[simp]\ntheorem volume_setOf_liouville : volume { x : ℝ | Liouville x } = 0 := by\n  simpa only [ae_iff, Classical.not_not] using ae_not_liouville\n\n"}
{"name":"Real.disjoint_residual_ae","module":"Mathlib.NumberTheory.Transcendental.Liouville.Measure","initialProofState":"⊢ Disjoint (residual Real) (MeasureTheory.ae MeasureTheory.MeasureSpace.volume)","decl":"/-- The filters `residual ℝ` and `ae volume` are disjoint. This means that there exists a residual\nset of Lebesgue measure zero (e.g., the set of Liouville numbers). -/\ntheorem Real.disjoint_residual_ae : Disjoint (residual ℝ) (ae volume) :=\n  disjoint_of_disjoint_of_mem disjoint_compl_right eventually_residual_liouville ae_not_liouville\n"}
