{"name":"Polynomial.Monic.irreducible_of_irreducible_map_of_isPrime_nilradical","module":"Mathlib.RingTheory.Polynomial.IrreducibleRing","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝³ : CommRing R\ninst✝² : (nilradical R).IsPrime\ninst✝¹ : CommRing S\ninst✝ : IsDomain S\nφ : RingHom R S\nf : Polynomial R\nhm : f.Monic\nhi : Irreducible (Polynomial.map φ f)\n⊢ Irreducible f","decl":"/-- A polynomial over an irreducible ring `R` is irreducible if it is monic and irreducible after\nmapping into an integral domain `S` (https://math.stackexchange.com/a/4843432/235999).\nA generalization to `Polynomial.Monic.irreducible_of_irreducible_map`. -/\ntheorem Polynomial.Monic.irreducible_of_irreducible_map_of_isPrime_nilradical\n    {R S : Type*} [CommRing R] [(nilradical R).IsPrime] [CommRing S] [IsDomain S]\n    (φ : R →+* S) (f : R[X]) (hm : f.Monic) (hi : Irreducible (f.map φ)) : Irreducible f := by\n  let R' := R ⧸ nilradical R\n  let ψ : R' →+* S := Ideal.Quotient.lift (nilradical R) φ\n    (haveI := RingHom.ker_isPrime φ; nilradical_le_prime (RingHom.ker φ))\n  let ι := algebraMap R R'\n  rw [show φ = ψ.comp ι from rfl, ← map_map] at hi\n  replace hi := hm.map ι |>.irreducible_of_irreducible_map _ _ hi\n  refine ⟨fun h ↦ hi.1 <| (mapRingHom ι).isUnit_map h, fun a b h ↦ ?_⟩\n  wlog hb : IsUnit (b.map ι) generalizing a b\n  · exact (this b a (mul_comm a b ▸ h)\n      (hi.2 _ _ (by rw [h, Polynomial.map_mul]) |>.resolve_right hb)).symm\n  have hn (i : ℕ) (hi : i ≠ 0) : IsNilpotent (b.coeff i) := by\n    obtain ⟨_, _, h⟩ := Polynomial.isUnit_iff.1 hb\n    simpa only [coeff_map, coeff_C, hi, ite_false, ← RingHom.mem_ker,\n      show RingHom.ker ι = nilradical R from Ideal.mk_ker] using congr(coeff $(h.symm) i)\n  refine .inr <| isUnit_of_coeff_isUnit_isNilpotent (isUnit_of_mul_isUnit_right\n    (x := a.coeff f.natDegree) <| (IsUnit.neg_iff _).1 ?_) hn\n  have hc : f.leadingCoeff = _ := congr(coeff $h f.natDegree)\n  rw [hm, coeff_mul, Finset.Nat.sum_antidiagonal_eq_sum_range_succ fun i j ↦ a.coeff i * b.coeff j,\n    Finset.sum_range_succ, ← sub_eq_iff_eq_add, Nat.sub_self] at hc\n  rw [← add_sub_cancel_left 1 (-(_ * _)), ← sub_eq_add_neg, hc]\n  exact IsNilpotent.isUnit_sub_one <| show _ ∈ nilradical R from sum_mem fun i hi ↦\n    Ideal.mul_mem_left _ _ <| hn _ <| Nat.sub_ne_zero_of_lt (List.mem_range.1 hi)\n"}
