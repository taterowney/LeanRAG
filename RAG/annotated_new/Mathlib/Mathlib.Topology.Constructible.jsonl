{"name":"IsRetrocompact.empty","module":"Mathlib.Topology.Constructible","initialProofState":"X : Type u_2\ninst✝ : TopologicalSpace X\n⊢ IsRetrocompact EmptyCollection.emptyCollection","decl":"@[simp] lemma IsRetrocompact.empty : IsRetrocompact (∅ : Set X) := by simp [IsRetrocompact]\n"}
{"name":"IsRetrocompact.univ","module":"Mathlib.Topology.Constructible","initialProofState":"X : Type u_2\ninst✝ : TopologicalSpace X\n⊢ IsRetrocompact Set.univ","decl":"@[simp] lemma IsRetrocompact.univ : IsRetrocompact (univ : Set X) := by\n  simp +contextual [IsRetrocompact]\n\n"}
{"name":"IsRetrocompact.singleton","module":"Mathlib.Topology.Constructible","initialProofState":"X : Type u_2\ninst✝ : TopologicalSpace X\na : X\n⊢ IsRetrocompact (Singleton.singleton a)","decl":"@[simp] lemma IsRetrocompact.singleton : IsRetrocompact {a} :=\n  fun _ _ _ ↦ Subsingleton.singleton_inter.isCompact\n\n"}
{"name":"IsRetrocompact.union","module":"Mathlib.Topology.Constructible","initialProofState":"X : Type u_2\ninst✝ : TopologicalSpace X\ns t : Set X\nhs : IsRetrocompact s\nht : IsRetrocompact t\n⊢ IsRetrocompact (Union.union s t)","decl":"lemma IsRetrocompact.union (hs : IsRetrocompact s) (ht : IsRetrocompact t) :\n    IsRetrocompact (s ∪ t : Set X) :=\n  fun _U hUcomp hUopen ↦ union_inter_distrib_right .. ▸ (hs hUcomp hUopen).union (ht hUcomp hUopen)\n\n"}
{"name":"IsRetrocompact.finsetSup","module":"Mathlib.Topology.Constructible","initialProofState":"X : Type u_2\ninst✝ : TopologicalSpace X\nι : Type u_4\ns : Finset ι\nt : ι → Set X\nht : ∀ (i : ι), Membership.mem s i → IsRetrocompact (t i)\n⊢ IsRetrocompact (s.sup t)","decl":"lemma IsRetrocompact.finsetSup {ι : Type*} {s : Finset ι} {t : ι → Set X}\n    (ht : ∀ i ∈ s, IsRetrocompact (t i)) : IsRetrocompact (s.sup t) := by\n  induction' s using Finset.cons_induction with i s ih hi\n  · simp\n  · rw [Finset.sup_cons]\n    exact (ht _ <| by simp).union <| hi <| Finset.forall_of_forall_cons ht\n\n"}
{"name":"IsRetrocompact.finsetSup'","module":"Mathlib.Topology.Constructible","initialProofState":"X : Type u_2\ninst✝ : TopologicalSpace X\nι : Type u_4\ns : Finset ι\nhs : s.Nonempty\nt : ι → Set X\nht : ∀ (i : ι), Membership.mem s i → IsRetrocompact (t i)\n⊢ IsRetrocompact (s.sup' hs t)","decl":"set_option linter.docPrime false in\nlemma IsRetrocompact.finsetSup' {ι : Type*} {s : Finset ι} {hs} {t : ι → Set X}\n    (ht : ∀ i ∈ s, IsRetrocompact (t i)) : IsRetrocompact (s.sup' hs t) := by\n  rw [Finset.sup'_eq_sup]; exact .finsetSup ht\n\n"}
{"name":"IsRetrocompact.iUnion","module":"Mathlib.Topology.Constructible","initialProofState":"ι : Sort u_1\nX : Type u_2\ninst✝¹ : TopologicalSpace X\ninst✝ : Finite ι\nf : ι → Set X\nhf : ∀ (i : ι), IsRetrocompact (f i)\n⊢ IsRetrocompact (Set.iUnion fun i => f i)","decl":"lemma IsRetrocompact.iUnion [Finite ι] {f : ι → Set X} (hf : ∀ i, IsRetrocompact (f i)) :\n    IsRetrocompact (⋃ i, f i) := supClosed_isRetrocompact.iSup_mem .empty hf\n\n"}
{"name":"IsRetrocompact.sUnion","module":"Mathlib.Topology.Constructible","initialProofState":"X : Type u_2\ninst✝ : TopologicalSpace X\nS : Set (Set X)\nhS : S.Finite\nhS' : ∀ (s : Set X), Membership.mem S s → IsRetrocompact s\n⊢ IsRetrocompact S.sUnion","decl":"lemma IsRetrocompact.sUnion {S : Set (Set X)} (hS : S.Finite) (hS' : ∀ s ∈ S, IsRetrocompact s) :\n    IsRetrocompact (⋃₀ S) := supClosed_isRetrocompact.sSup_mem hS .empty hS'\n\n"}
{"name":"IsRetrocompact.biUnion","module":"Mathlib.Topology.Constructible","initialProofState":"X : Type u_2\ninst✝ : TopologicalSpace X\nι : Type u_4\nf : ι → Set X\nt : Set ι\nht : t.Finite\nhf : ∀ (i : ι), Membership.mem t i → IsRetrocompact (f i)\n⊢ IsRetrocompact (Set.iUnion fun i => Set.iUnion fun h => f i)","decl":"lemma IsRetrocompact.biUnion {ι : Type*} {f : ι → Set X} {t : Set ι} (ht : t.Finite)\n    (hf : ∀ i ∈ t, IsRetrocompact (f i)) : IsRetrocompact (⋃ i ∈ t, f i) :=\n  supClosed_isRetrocompact.biSup_mem ht .empty hf\n\n"}
{"name":"IsRetrocompact.inter","module":"Mathlib.Topology.Constructible","initialProofState":"X : Type u_2\ninst✝¹ : TopologicalSpace X\ns t : Set X\ninst✝ : T2Space X\nhs : IsRetrocompact s\nht : IsRetrocompact t\n⊢ IsRetrocompact (Inter.inter s t)","decl":"lemma IsRetrocompact.inter (hs : IsRetrocompact s) (ht : IsRetrocompact t) :\n    IsRetrocompact (s ∩ t : Set X) :=\n  fun _U hUcomp hUopen ↦ inter_inter_distrib_right .. ▸ (hs hUcomp hUopen).inter (ht hUcomp hUopen)\n\n"}
{"name":"IsRetrocompact.finsetInf","module":"Mathlib.Topology.Constructible","initialProofState":"X : Type u_2\ninst✝¹ : TopologicalSpace X\ninst✝ : T2Space X\nι : Type u_4\ns : Finset ι\nt : ι → Set X\nht : ∀ (i : ι), Membership.mem s i → IsRetrocompact (t i)\n⊢ IsRetrocompact (s.inf t)","decl":"lemma IsRetrocompact.finsetInf {ι : Type*} {s : Finset ι} {t : ι → Set X}\n    (ht : ∀ i ∈ s, IsRetrocompact (t i)) : IsRetrocompact (s.inf t) := by\n  induction' s using Finset.cons_induction with i s ih hi\n  · simp\n  · rw [Finset.inf_cons]\n    exact (ht _ <| by simp).inter <| hi <| Finset.forall_of_forall_cons ht\n\n"}
{"name":"IsRetrocompact.finsetInf'","module":"Mathlib.Topology.Constructible","initialProofState":"X : Type u_2\ninst✝¹ : TopologicalSpace X\ninst✝ : T2Space X\nι : Type u_4\ns : Finset ι\nhs : s.Nonempty\nt : ι → Set X\nht : ∀ (i : ι), Membership.mem s i → IsRetrocompact (t i)\n⊢ IsRetrocompact (s.inf' hs t)","decl":"set_option linter.docPrime false in\nlemma IsRetrocompact.finsetInf' {ι : Type*} {s : Finset ι} {hs} {t : ι → Set X}\n    (ht : ∀ i ∈ s, IsRetrocompact (t i)) : IsRetrocompact (s.inf' hs t) := by\n  rw [Finset.inf'_eq_inf]; exact .finsetInf ht\n\n"}
{"name":"IsRetrocompact.iInter","module":"Mathlib.Topology.Constructible","initialProofState":"ι : Sort u_1\nX : Type u_2\ninst✝² : TopologicalSpace X\ninst✝¹ : T2Space X\ninst✝ : Finite ι\nf : ι → Set X\nhf : ∀ (i : ι), IsRetrocompact (f i)\n⊢ IsRetrocompact (Set.iInter fun i => f i)","decl":"lemma IsRetrocompact.iInter [Finite ι] {f : ι → Set X} (hf : ∀ i, IsRetrocompact (f i)) :\n    IsRetrocompact (⋂ i, f i) := infClosed_isRetrocompact.iInf_mem .univ hf\n\n"}
{"name":"IsRetrocompact.sInter","module":"Mathlib.Topology.Constructible","initialProofState":"X : Type u_2\ninst✝¹ : TopologicalSpace X\ninst✝ : T2Space X\nS : Set (Set X)\nhS : S.Finite\nhS' : ∀ (s : Set X), Membership.mem S s → IsRetrocompact s\n⊢ IsRetrocompact S.sInter","decl":"lemma IsRetrocompact.sInter {S : Set (Set X)} (hS : S.Finite) (hS' : ∀ s ∈ S, IsRetrocompact s) :\n    IsRetrocompact (⋂₀ S) := infClosed_isRetrocompact.sInf_mem hS .univ hS'\n\n"}
{"name":"IsRetrocompact.biInter","module":"Mathlib.Topology.Constructible","initialProofState":"X : Type u_2\ninst✝¹ : TopologicalSpace X\ninst✝ : T2Space X\nι : Type u_4\nf : ι → Set X\nt : Set ι\nht : t.Finite\nhf : ∀ (i : ι), Membership.mem t i → IsRetrocompact (f i)\n⊢ IsRetrocompact (Set.iInter fun i => Set.iInter fun h => f i)","decl":"lemma IsRetrocompact.biInter {ι : Type*} {f : ι → Set X} {t : Set ι} (ht : t.Finite)\n    (hf : ∀ i ∈ t, IsRetrocompact (f i)) : IsRetrocompact (⋂ i ∈ t, f i) :=\n  infClosed_isRetrocompact.biInf_mem ht .univ hf\n\n"}
{"name":"IsRetrocompact.inter_isOpen","module":"Mathlib.Topology.Constructible","initialProofState":"X : Type u_2\ninst✝ : TopologicalSpace X\ns t : Set X\nhs : IsRetrocompact s\nht : IsRetrocompact t\nhtopen : IsOpen t\n⊢ IsRetrocompact (Inter.inter s t)","decl":"lemma IsRetrocompact.inter_isOpen (hs : IsRetrocompact s) (ht : IsRetrocompact t)\n    (htopen : IsOpen t) : IsRetrocompact (s ∩ t : Set X) :=\n  fun _U hUcomp hUopen ↦ inter_assoc .. ▸ hs (ht hUcomp hUopen) (htopen.inter hUopen)\n\n"}
{"name":"IsRetrocompact.isOpen_inter","module":"Mathlib.Topology.Constructible","initialProofState":"X : Type u_2\ninst✝ : TopologicalSpace X\ns t : Set X\nhs : IsRetrocompact s\nht : IsRetrocompact t\nhsopen : IsOpen s\n⊢ IsRetrocompact (Inter.inter s t)","decl":"lemma IsRetrocompact.isOpen_inter (hs : IsRetrocompact s) (ht : IsRetrocompact t)\n    (hsopen : IsOpen s) : IsRetrocompact (s ∩ t : Set X) :=\n  inter_comm .. ▸ ht.inter_isOpen hs hsopen\n\n"}
{"name":"IsRetrocompact_iff_isSpectralMap_subtypeVal","module":"Mathlib.Topology.Constructible","initialProofState":"X : Type u_2\ninst✝ : TopologicalSpace X\ns : Set X\n⊢ Iff (IsRetrocompact s) (IsSpectralMap Subtype.val)","decl":"lemma IsRetrocompact_iff_isSpectralMap_subtypeVal :\n    IsRetrocompact s ↔ IsSpectralMap (Subtype.val : s → X) := by\n  refine ⟨fun hs ↦ ⟨continuous_subtype_val, fun t htopen htcomp ↦ ?_⟩, fun hs t htcomp htopen ↦ ?_⟩\n  · rw [IsEmbedding.subtypeVal.isCompact_iff, image_preimage_eq_inter_range,\n      Subtype.range_coe_subtype, setOf_mem_eq, inter_comm]\n    exact hs htcomp htopen\n  · simpa using (hs.isCompact_preimage_of_isOpen htopen htcomp).image continuous_subtype_val\n\n"}
{"name":"IsRetrocompact.image_of_isEmbedding","module":"Mathlib.Topology.Constructible","initialProofState":"X : Type u_2\nY : Type u_3\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf : X → Y\ns : Set X\nhs : IsRetrocompact s\nhfemb : Topology.IsEmbedding f\nhfcomp : IsRetrocompact (Set.range f)\n⊢ IsRetrocompact (Set.image f s)","decl":"@[stacks 005B]\nlemma IsRetrocompact.image_of_isEmbedding (hs : IsRetrocompact s) (hfemb : IsEmbedding f)\n    (hfcomp : IsRetrocompact (range f)) : IsRetrocompact (f '' s) := by\n  rintro U hUcomp hUopen\n  rw [← image_inter_preimage, ← hfemb.isCompact_iff]\n  refine hs ?_ <| hUopen.preimage hfemb.continuous\n  rw [hfemb.isCompact_iff, image_preimage_eq_inter_range, inter_comm]\n  exact hfcomp hUcomp hUopen\n\n"}
{"name":"IsRetrocompact.preimage_of_isOpenEmbedding","module":"Mathlib.Topology.Constructible","initialProofState":"X : Type u_2\nY : Type u_3\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf : X → Y\ns : Set Y\nhf : Topology.IsOpenEmbedding f\nhs : IsRetrocompact s\n⊢ IsRetrocompact (Set.preimage f s)","decl":"@[stacks 005J \"Extracted from the proof\"]\nlemma IsRetrocompact.preimage_of_isOpenEmbedding {s : Set Y} (hf : IsOpenEmbedding f)\n    (hs : IsRetrocompact s) : IsRetrocompact (f ⁻¹' s) := by\n  rintro U hUcomp hUopen\n  rw [hf.isCompact_iff, image_preimage_inter]\n  exact hs (hUcomp.image hf.continuous) <| hf.isOpenMap _ hUopen\n\n"}
{"name":"IsRetrocompact.preimage_of_isClosedEmbedding","module":"Mathlib.Topology.Constructible","initialProofState":"X : Type u_2\nY : Type u_3\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf : X → Y\ns : Set Y\nhf : Topology.IsClosedEmbedding f\nhf' : IsCompact (HasCompl.compl (Set.range f))\nhs : IsRetrocompact s\n⊢ IsRetrocompact (Set.preimage f s)","decl":"@[stacks 09YE \"Extracted from the proof\"]\nlemma IsRetrocompact.preimage_of_isClosedEmbedding {s : Set Y} (hf : IsClosedEmbedding f)\n    (hf' : IsCompact (range f)ᶜ) (hs : IsRetrocompact s) : IsRetrocompact (f ⁻¹' s) := by\n  rintro U hUcomp hUopen\n  have hfUopen : IsOpen (f '' U ∪ (range f)ᶜ) := by\n    simpa [← range_diff_image hf.injective, sdiff_eq, compl_inter, union_comm]\n      using (hf.isClosedMap _ hUopen.isClosed_compl).isOpen_compl\n  have hfUcomp : IsCompact (f '' U ∪ (range f)ᶜ) := (hUcomp.image hf.continuous).union hf'\n  simpa [inter_union_distrib_left, inter_left_comm, inter_eq_right.2 (image_subset_range ..),\n    hf.isCompact_iff, image_preimage_inter] using (hs hfUcomp hfUopen).inter_left hf.isClosed_range\n\n"}
{"name":"Topology.IsConstructible.empty","module":"Mathlib.Topology.Constructible","initialProofState":"X : Type u_2\ninst✝ : TopologicalSpace X\n⊢ Topology.IsConstructible EmptyCollection.emptyCollection","decl":"@[simp]\nprotected lemma IsConstructible.empty : IsConstructible (∅ : Set X) := BooleanSubalgebra.bot_mem\n\n"}
{"name":"Topology.IsConstructible.univ","module":"Mathlib.Topology.Constructible","initialProofState":"X : Type u_2\ninst✝ : TopologicalSpace X\n⊢ Topology.IsConstructible Set.univ","decl":"@[simp]\nprotected lemma IsConstructible.univ : IsConstructible (univ : Set X) := BooleanSubalgebra.top_mem\n\n"}
{"name":"Topology.IsConstructible.union","module":"Mathlib.Topology.Constructible","initialProofState":"X : Type u_2\ninst✝ : TopologicalSpace X\ns t : Set X\na✝¹ : Topology.IsConstructible s\na✝ : Topology.IsConstructible t\n⊢ Topology.IsConstructible (Union.union s t)","decl":"lemma IsConstructible.union : IsConstructible s → IsConstructible t → IsConstructible (s ∪ t) :=\n  BooleanSubalgebra.sup_mem\n\n"}
{"name":"Topology.IsConstructible.inter","module":"Mathlib.Topology.Constructible","initialProofState":"X : Type u_2\ninst✝ : TopologicalSpace X\ns t : Set X\na✝¹ : Topology.IsConstructible s\na✝ : Topology.IsConstructible t\n⊢ Topology.IsConstructible (Inter.inter s t)","decl":"lemma IsConstructible.inter : IsConstructible s → IsConstructible t → IsConstructible (s ∩ t) :=\n  BooleanSubalgebra.inf_mem\n\n"}
{"name":"Topology.IsConstructible.sdiff","module":"Mathlib.Topology.Constructible","initialProofState":"X : Type u_2\ninst✝ : TopologicalSpace X\ns t : Set X\na✝¹ : Topology.IsConstructible s\na✝ : Topology.IsConstructible t\n⊢ Topology.IsConstructible (SDiff.sdiff s t)","decl":"lemma IsConstructible.sdiff : IsConstructible s → IsConstructible t → IsConstructible (s \\ t) :=\n  BooleanSubalgebra.sdiff_mem\n\n"}
{"name":"Topology.IsConstructible.himp","module":"Mathlib.Topology.Constructible","initialProofState":"X : Type u_2\ninst✝ : TopologicalSpace X\ns t : Set X\na✝¹ : Topology.IsConstructible s\na✝ : Topology.IsConstructible t\n⊢ Topology.IsConstructible (HImp.himp s t)","decl":"lemma IsConstructible.himp : IsConstructible s → IsConstructible t → IsConstructible (s ⇨ t) :=\n  BooleanSubalgebra.himp_mem\n\n"}
{"name":"Topology.isConstructible_compl","module":"Mathlib.Topology.Constructible","initialProofState":"X : Type u_2\ninst✝ : TopologicalSpace X\ns : Set X\n⊢ Iff (Topology.IsConstructible (HasCompl.compl s)) (Topology.IsConstructible s)","decl":"@[simp] lemma isConstructible_compl : IsConstructible sᶜ ↔ IsConstructible s :=\n  BooleanSubalgebra.compl_mem_iff\n\n"}
{"name":"Topology.IsConstructible.compl","module":"Mathlib.Topology.Constructible","initialProofState":"X : Type u_2\ninst✝ : TopologicalSpace X\ns : Set X\na✝ : Topology.IsConstructible s\n⊢ Topology.IsConstructible (HasCompl.compl s)","decl":"alias ⟨IsConstructible.of_compl, IsConstructible.compl⟩ := isConstructible_compl\n\n"}
{"name":"Topology.IsConstructible.of_compl","module":"Mathlib.Topology.Constructible","initialProofState":"X : Type u_2\ninst✝ : TopologicalSpace X\ns : Set X\na✝ : Topology.IsConstructible (HasCompl.compl s)\n⊢ Topology.IsConstructible s","decl":"alias ⟨IsConstructible.of_compl, IsConstructible.compl⟩ := isConstructible_compl\n\n"}
{"name":"Topology.IsConstructible.iUnion","module":"Mathlib.Topology.Constructible","initialProofState":"ι : Sort u_1\nX : Type u_2\ninst✝¹ : TopologicalSpace X\ninst✝ : Finite ι\nf : ι → Set X\nhf : ∀ (i : ι), Topology.IsConstructible (f i)\n⊢ Topology.IsConstructible (Set.iUnion fun i => f i)","decl":"lemma IsConstructible.iUnion [Finite ι] {f : ι → Set X} (hf : ∀ i, IsConstructible (f i)) :\n    IsConstructible (⋃ i, f i) := BooleanSubalgebra.iSup_mem hf\n\n"}
{"name":"Topology.IsConstructible.iInter","module":"Mathlib.Topology.Constructible","initialProofState":"ι : Sort u_1\nX : Type u_2\ninst✝¹ : TopologicalSpace X\ninst✝ : Finite ι\nf : ι → Set X\nhf : ∀ (i : ι), Topology.IsConstructible (f i)\n⊢ Topology.IsConstructible (Set.iInter fun i => f i)","decl":"lemma IsConstructible.iInter [Finite ι] {f : ι → Set X} (hf : ∀ i, IsConstructible (f i)) :\n    IsConstructible (⋂ i, f i) := BooleanSubalgebra.iInf_mem hf\n\n"}
{"name":"Topology.IsConstructible.sUnion","module":"Mathlib.Topology.Constructible","initialProofState":"X : Type u_2\ninst✝ : TopologicalSpace X\nS : Set (Set X)\nhS : S.Finite\nhS' : ∀ (s : Set X), Membership.mem S s → Topology.IsConstructible s\n⊢ Topology.IsConstructible S.sUnion","decl":"lemma IsConstructible.sUnion {S : Set (Set X)} (hS : S.Finite) (hS' : ∀ s ∈ S, IsConstructible s) :\n    IsConstructible (⋃₀ S) := BooleanSubalgebra.sSup_mem hS hS'\n\n"}
{"name":"Topology.IsConstructible.sInter","module":"Mathlib.Topology.Constructible","initialProofState":"X : Type u_2\ninst✝ : TopologicalSpace X\nS : Set (Set X)\nhS : S.Finite\nhS' : ∀ (s : Set X), Membership.mem S s → Topology.IsConstructible s\n⊢ Topology.IsConstructible S.sInter","decl":"lemma IsConstructible.sInter {S : Set (Set X)} (hS : S.Finite) (hS' : ∀ s ∈ S, IsConstructible s) :\n    IsConstructible (⋂₀ S) := BooleanSubalgebra.sInf_mem hS hS'\n\n"}
{"name":"Topology.IsConstructible.biUnion","module":"Mathlib.Topology.Constructible","initialProofState":"X : Type u_2\ninst✝ : TopologicalSpace X\nι : Type u_4\nf : ι → Set X\nt : Set ι\nht : t.Finite\nhf : ∀ (i : ι), Membership.mem t i → Topology.IsConstructible (f i)\n⊢ Topology.IsConstructible (Set.iUnion fun i => Set.iUnion fun h => f i)","decl":"lemma IsConstructible.biUnion {ι : Type*} {f : ι → Set X} {t : Set ι} (ht : t.Finite)\n    (hf : ∀ i ∈ t, IsConstructible (f i)) : IsConstructible (⋃ i ∈ t, f i) :=\n  BooleanSubalgebra.biSup_mem ht hf\n\n"}
{"name":"Topology.IsConstructible.biInter","module":"Mathlib.Topology.Constructible","initialProofState":"X : Type u_2\ninst✝ : TopologicalSpace X\nι : Type u_4\nf : ι → Set X\nt : Set ι\nht : t.Finite\nhf : ∀ (i : ι), Membership.mem t i → Topology.IsConstructible (f i)\n⊢ Topology.IsConstructible (Set.iInter fun i => Set.iInter fun h => f i)","decl":"lemma IsConstructible.biInter {ι : Type*} {f : ι → Set X} {t : Set ι} (ht : t.Finite)\n    (hf : ∀ i ∈ t, IsConstructible (f i)) : IsConstructible (⋂ i ∈ t, f i) :=\n  BooleanSubalgebra.biInf_mem ht hf\n\n"}
{"name":"IsRetrocompact.isConstructible","module":"Mathlib.Topology.Constructible","initialProofState":"X : Type u_2\ninst✝ : TopologicalSpace X\nU : Set X\nhUopen : IsOpen U\nhUcomp : IsRetrocompact U\n⊢ Topology.IsConstructible U","decl":"lemma _root_.IsRetrocompact.isConstructible (hUopen : IsOpen U) (hUcomp : IsRetrocompact U) :\n    IsConstructible U := BooleanSubalgebra.subset_closure ⟨hUopen, hUcomp⟩\n\n"}
{"name":"Topology.IsConstructible.empty_union_induction","module":"Mathlib.Topology.Constructible","initialProofState":"X : Type u_2\ninst✝ : TopologicalSpace X\np : (s : Set X) → Topology.IsConstructible s → Prop\nopen_retrocompact : ∀ (U : Set X) (hUopen : IsOpen U) (hUcomp : IsRetrocompact U), p U ⋯\nunion : ∀ (s : Set X) (hs : Topology.IsConstructible s) (t : Set X) (ht : Topology.IsConstructible t), p s hs → p t ht → p (Union.union s t) ⋯\ncompl : ∀ (s : Set X) (hs : Topology.IsConstructible s), p s hs → p (HasCompl.compl s) ⋯\ns : Set X\nhs : Topology.IsConstructible s\n⊢ p s hs","decl":"/-- An induction principle for constructible sets. If `p` holds for all open retrocompact\nsets, and is preserved under union and complement, then `p` holds for all constructible sets. -/\n@[elab_as_elim]\nlemma IsConstructible.empty_union_induction {p : ∀ s : Set X, IsConstructible s → Prop}\n    (open_retrocompact : ∀ U (hUopen : IsOpen U) (hUcomp : IsRetrocompact U),\n      p U (BooleanSubalgebra.subset_closure ⟨hUopen, hUcomp⟩))\n    (union : ∀ s hs t ht, p s hs → p t ht → p (s ∪ t) (hs.union ht))\n    (compl : ∀ s hs, p s hs → p sᶜ hs.compl) {s} (hs : IsConstructible s) : p s hs := by\n  induction hs using BooleanSubalgebra.closure_bot_sup_induction with\n  | mem U hU => exact open_retrocompact _ hU.1 hU.2\n  | bot => exact open_retrocompact _ isOpen_empty .empty\n  | sup s hs t ht hs' ht' => exact union _ _ _ _ hs' ht'\n  | compl s hs hs' => exact compl _ _ hs'\n\n"}
{"name":"Topology.IsConstructible.preimage","module":"Mathlib.Topology.Constructible","initialProofState":"X : Type u_2\nY : Type u_3\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf : X → Y\ns : Set Y\nhfcont : Continuous f\nhf : ∀ (s : Set Y), IsRetrocompact s → IsRetrocompact (Set.preimage f s)\nhs : Topology.IsConstructible s\n⊢ Topology.IsConstructible (Set.preimage f s)","decl":"/-- If `f` is continuous and is such that preimages of retrocompact sets are retrocompact, then\npreimages of constructible sets are constructible. -/\n@[stacks 005I]\nlemma IsConstructible.preimage {s : Set Y} (hfcont : Continuous f)\n    (hf : ∀ s, IsRetrocompact s → IsRetrocompact (f ⁻¹' s)) (hs : IsConstructible s) :\n    IsConstructible (f ⁻¹' s) := by\n  induction hs using IsConstructible.empty_union_induction with\n  | open_retrocompact U hUopen hUcomp =>\n    exact (hf _ hUcomp).isConstructible <| hUopen.preimage hfcont\n  | union s hs t ht hs' ht' => rw [preimage_union]; exact hs'.union ht'\n  | compl s hs hs' => rw [preimage_compl]; exact hs'.compl\n\n"}
{"name":"Topology.IsConstructible.preimage_of_isOpenEmbedding","module":"Mathlib.Topology.Constructible","initialProofState":"X : Type u_2\nY : Type u_3\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf : X → Y\ns : Set Y\nhf : Topology.IsOpenEmbedding f\nhs : Topology.IsConstructible s\n⊢ Topology.IsConstructible (Set.preimage f s)","decl":"@[stacks 005J]\nlemma IsConstructible.preimage_of_isOpenEmbedding {s : Set Y} (hf : IsOpenEmbedding f)\n    (hs : IsConstructible s) : IsConstructible (f ⁻¹' s) :=\n  hs.preimage hf.continuous fun _t ht ↦ ht.preimage_of_isOpenEmbedding hf\n\n"}
{"name":"Topology.IsConstructible.preimage_of_isClosedEmbedding","module":"Mathlib.Topology.Constructible","initialProofState":"X : Type u_2\nY : Type u_3\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf : X → Y\ns : Set Y\nhf : Topology.IsClosedEmbedding f\nhf' : IsCompact (HasCompl.compl (Set.range f))\nhs : Topology.IsConstructible s\n⊢ Topology.IsConstructible (Set.preimage f s)","decl":"@[stacks 09YE]\nlemma IsConstructible.preimage_of_isClosedEmbedding {s : Set Y} (hf : IsClosedEmbedding f)\n    (hf' : IsCompact (range f)ᶜ) (hs : IsConstructible s) : IsConstructible (f ⁻¹' s) :=\n  hs.preimage hf.continuous fun _t ht ↦ ht.preimage_of_isClosedEmbedding hf hf'\n\n"}
{"name":"Topology.IsConstructible.image_of_isOpenEmbedding","module":"Mathlib.Topology.Constructible","initialProofState":"X : Type u_2\nY : Type u_3\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf : X → Y\ns : Set X\nhfopen : Topology.IsOpenEmbedding f\nhfcomp : IsRetrocompact (Set.range f)\nhs : Topology.IsConstructible s\n⊢ Topology.IsConstructible (Set.image f s)","decl":"@[stacks 09YD]\nlemma IsConstructible.image_of_isOpenEmbedding (hfopen : IsOpenEmbedding f)\n    (hfcomp : IsRetrocompact (range f)) (hs : IsConstructible s) : IsConstructible (f '' s) := by\n  induction hs using IsConstructible.empty_union_induction with\n  | open_retrocompact U hUopen hUcomp =>\n    exact (hUcomp.image_of_isEmbedding hfopen.isEmbedding hfcomp).isConstructible <|\n      hfopen.isOpenMap _ hUopen\n  | union s hs t ht hs' ht' => rw [image_union]; exact hs'.union ht'\n  | compl s hs hs' =>\n    rw [← range_diff_image hfopen.injective]\n    exact (hfcomp.isConstructible hfopen.isOpen_range).sdiff hs'\n\n"}
{"name":"Topology.IsConstructible.image_of_isClosedEmbedding","module":"Mathlib.Topology.Constructible","initialProofState":"X : Type u_2\nY : Type u_3\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf : X → Y\ns : Set X\nhf : Topology.IsClosedEmbedding f\nhfcomp : IsRetrocompact (HasCompl.compl (Set.range f))\nhs : Topology.IsConstructible s\n⊢ Topology.IsConstructible (Set.image f s)","decl":"@[stacks 09YG]\nlemma IsConstructible.image_of_isClosedEmbedding (hf : IsClosedEmbedding f)\n    (hfcomp : IsRetrocompact (range f)ᶜ) (hs : IsConstructible s) : IsConstructible (f '' s) := by\n  induction hs using IsConstructible.empty_union_induction with\n  | open_retrocompact U hUopen hUcomp =>\n    have hfU : IsOpen (f '' U ∪ (range f)ᶜ) := by\n      simpa [← range_diff_image hf.injective, sdiff_eq, compl_inter, union_comm]\n        using (hf.isClosedMap _ hUopen.isClosed_compl).isOpen_compl\n    suffices h : IsRetrocompact (f '' U ∪ (range f)ᶜ) by\n      simpa [union_inter_distrib_right, inter_eq_left.2 (image_subset_range ..)]\n        using (h.isConstructible hfU).sdiff (hfcomp.isConstructible hf.isClosed_range.isOpen_compl)\n    rintro V hVcomp hVopen\n    rw [union_inter_distrib_right, ← image_inter_preimage]\n    exact ((hUcomp (hf.isCompact_preimage hVcomp) (hVopen.preimage hf.continuous)).image\n      hf.continuous).union <| hfcomp hVcomp hVopen\n  | union s hs t ht hs' ht' => rw [image_union]; exact hs'.union ht'\n  | compl s hs hs' =>\n    rw [← range_diff_image hf.injective]\n    exact (hfcomp.isConstructible hf.isClosed_range.isOpen_compl).of_compl.sdiff hs'\n\n"}
{"name":"Topology.isConstructible_preimage_iff_of_isOpenEmbedding","module":"Mathlib.Topology.Constructible","initialProofState":"X : Type u_2\nY : Type u_3\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf : X → Y\ns : Set Y\nhf : Topology.IsOpenEmbedding f\nhfcomp : IsRetrocompact (Set.range f)\nhsf : HasSubset.Subset s (Set.range f)\n⊢ Iff (Topology.IsConstructible (Set.preimage f s)) (Topology.IsConstructible s)","decl":"lemma isConstructible_preimage_iff_of_isOpenEmbedding {s : Set Y} (hf : IsOpenEmbedding f)\n    (hfcomp : IsRetrocompact (range f)) (hsf : s ⊆ range f) :\n    IsConstructible (f ⁻¹' s) ↔ IsConstructible s where\n  mp hs := by simpa [image_preimage_eq_range_inter, inter_eq_right.2 hsf]\n    using hs.image_of_isOpenEmbedding hf hfcomp\n  mpr := .preimage_of_isOpenEmbedding hf\n\n"}
{"name":"IsRetrocompact.isCompact","module":"Mathlib.Topology.Constructible","initialProofState":"X : Type u_2\ninst✝¹ : TopologicalSpace X\ns : Set X\ninst✝ : CompactSpace X\nhs : IsRetrocompact s\n⊢ IsCompact s","decl":"lemma _root_.IsRetrocompact.isCompact (hs : IsRetrocompact s) : IsCompact s := by\n  simpa using hs CompactSpace.isCompact_univ\n\n"}
{"name":"TopologicalSpace.IsTopologicalBasis.isRetrocompact_iff_isCompact'","module":"Mathlib.Topology.Constructible","initialProofState":"X : Type u_2\ninst✝² : TopologicalSpace X\nU : Set X\ninst✝¹ : CompactSpace X\nB : Set (Set X)\ninst✝ : QuasiSeparatedSpace X\nbasis : TopologicalSpace.IsTopologicalBasis B\nisCompact_basis : ∀ (U : Set X), Membership.mem B U → IsCompact U\nhU : IsOpen U\n⊢ Iff (IsRetrocompact U) (IsCompact U)","decl":"/-- Variant of `TopologicalSpace.IsTopologicalBasis.isRetrocompact_iff_isCompact` for a\nnon-indexed topological basis. -/\n@[stacks 0069 \"Iff form of (2). Note that Stacks doesn't define quasi-separated spaces.\"]\nlemma _root_.TopologicalSpace.IsTopologicalBasis.isRetrocompact_iff_isCompact'\n    (basis : IsTopologicalBasis B) (isCompact_basis : ∀ U ∈ B, IsCompact U)\n    (hU : IsOpen U) : IsRetrocompact U ↔ IsCompact U := by\n  refine ⟨IsRetrocompact.isCompact, fun hU' {V} hV' hV ↦ ?_⟩\n  obtain ⟨s, rfl⟩ := eq_sUnion_finset_of_isTopologicalBasis_of_isCompact_open _ basis _ hU' hU\n  obtain ⟨t, rfl⟩ := eq_sUnion_finset_of_isTopologicalBasis_of_isCompact_open _ basis _ hV' hV\n  rw [Set.sUnion_inter_sUnion]\n  refine ((s.finite_toSet.image _).prod (t.finite_toSet.image _)).isCompact_biUnion ?_\n  simp only [mem_prod, mem_image, Finset.mem_coe, Subtype.exists, exists_and_right, exists_eq_right,\n    and_imp, forall_exists_index, Prod.forall]\n  exact fun u v hu _ hv _ ↦ (isCompact_basis _ hu).inter_of_isOpen (isCompact_basis _ hv)\n    (basis.isOpen hu) (basis.isOpen hv)\n\n"}
{"name":"TopologicalSpace.IsTopologicalBasis.isRetrocompact_iff_isCompact","module":"Mathlib.Topology.Constructible","initialProofState":"ι : Sort u_1\nX : Type u_2\ninst✝² : TopologicalSpace X\nU : Set X\ninst✝¹ : CompactSpace X\nb : ι → Set X\ninst✝ : QuasiSeparatedSpace X\nbasis : TopologicalSpace.IsTopologicalBasis (Set.range b)\nisCompact_basis : ∀ (i : ι), IsCompact (b i)\nhU : IsOpen U\n⊢ Iff (IsRetrocompact U) (IsCompact U)","decl":"@[stacks 0069 \"Iff form of (2). Note that Stacks doesn't define quasi-separated spaces.\"]\nlemma _root_.TopologicalSpace.IsTopologicalBasis.isRetrocompact_iff_isCompact\n    (basis : IsTopologicalBasis (range b)) (isCompact_basis : ∀ i, IsCompact (b i))\n    (hU : IsOpen U) : IsRetrocompact U ↔ IsCompact U :=\n  basis.isRetrocompact_iff_isCompact' (by simpa using isCompact_basis) hU\n\n"}
{"name":"TopologicalSpace.IsTopologicalBasis.isRetrocompact'","module":"Mathlib.Topology.Constructible","initialProofState":"X : Type u_2\ninst✝² : TopologicalSpace X\nU : Set X\ninst✝¹ : CompactSpace X\nB : Set (Set X)\ninst✝ : QuasiSeparatedSpace X\nbasis : TopologicalSpace.IsTopologicalBasis B\nisCompact_basis : ∀ (U : Set X), Membership.mem B U → IsCompact U\nhU : Membership.mem B U\n⊢ IsRetrocompact U","decl":"/-- Variant of `TopologicalSpace.IsTopologicalBasis.isRetrocompact` for a non-indexed topological\nbasis. -/\nlemma _root_.TopologicalSpace.IsTopologicalBasis.isRetrocompact' (basis : IsTopologicalBasis B)\n    (isCompact_basis : ∀ U ∈ B, IsCompact U) (hU : U ∈ B) : IsRetrocompact U :=\n  (basis.isRetrocompact_iff_isCompact' isCompact_basis <| basis.isOpen hU).2 <| isCompact_basis _ hU\n\n"}
{"name":"TopologicalSpace.IsTopologicalBasis.isRetrocompact","module":"Mathlib.Topology.Constructible","initialProofState":"ι : Sort u_1\nX : Type u_2\ninst✝² : TopologicalSpace X\ninst✝¹ : CompactSpace X\nb : ι → Set X\ninst✝ : QuasiSeparatedSpace X\nbasis : TopologicalSpace.IsTopologicalBasis (Set.range b)\nisCompact_basis : ∀ (i : ι), IsCompact (b i)\ni : ι\n⊢ IsRetrocompact (b i)","decl":"lemma _root_.TopologicalSpace.IsTopologicalBasis.isRetrocompact\n    (basis : IsTopologicalBasis (range b)) (isCompact_basis : ∀ i, IsCompact (b i)) (i : ι) :\n    IsRetrocompact (b i) :=\n  (basis.isRetrocompact_iff_isCompact isCompact_basis <| basis.isOpen <| mem_range_self _).2 <|\n    isCompact_basis _\n\n"}
{"name":"TopologicalSpace.IsTopologicalBasis.isConstructible'","module":"Mathlib.Topology.Constructible","initialProofState":"X : Type u_2\ninst✝² : TopologicalSpace X\nU : Set X\ninst✝¹ : CompactSpace X\nB : Set (Set X)\ninst✝ : QuasiSeparatedSpace X\nbasis : TopologicalSpace.IsTopologicalBasis B\nisCompact_basis : ∀ (U : Set X), Membership.mem B U → IsCompact U\nhU : Membership.mem B U\n⊢ Topology.IsConstructible U","decl":"/-- Variant of `TopologicalSpace.IsTopologicalBasis.isConstructible` for a non-indexed topological\nbasis. -/\nlemma _root_.TopologicalSpace.IsTopologicalBasis.isConstructible' (basis : IsTopologicalBasis B)\n    (isCompact_basis : ∀ U ∈ B, IsCompact U) (hU : U ∈ B) : IsConstructible U :=\n  (basis.isRetrocompact' isCompact_basis hU).isConstructible <| basis.isOpen hU\n\n"}
{"name":"TopologicalSpace.IsTopologicalBasis.isConstructible","module":"Mathlib.Topology.Constructible","initialProofState":"ι : Sort u_1\nX : Type u_2\ninst✝² : TopologicalSpace X\ninst✝¹ : CompactSpace X\nb : ι → Set X\ninst✝ : QuasiSeparatedSpace X\nbasis : TopologicalSpace.IsTopologicalBasis (Set.range b)\nisCompact_basis : ∀ (i : ι), IsCompact (b i)\ni : ι\n⊢ Topology.IsConstructible (b i)","decl":"lemma _root_.TopologicalSpace.IsTopologicalBasis.isConstructible\n    (basis : IsTopologicalBasis (range b)) (isCompact_basis : ∀ i, IsCompact (b i)) (i : ι) :\n    IsConstructible (b i) :=\n  (basis.isRetrocompact isCompact_basis _).isConstructible <| basis.isOpen <| mem_range_self _\n\n"}
{"name":"Topology.IsConstructible.induction_of_isTopologicalBasis","module":"Mathlib.Topology.Constructible","initialProofState":"X : Type u_2\ninst✝³ : TopologicalSpace X\ninst✝² : CompactSpace X\nP : (s : Set X) → Topology.IsConstructible s → Prop\ninst✝¹ : QuasiSeparatedSpace X\nι : Type u_4\ninst✝ : Nonempty ι\nb : ι → Set X\nbasis : TopologicalSpace.IsTopologicalBasis (Set.range b)\nisCompact_basis : ∀ (i : ι), IsCompact (b i)\nsdiff : ∀ (i : ι) (s : Set ι) (hs : s.Finite), P (SDiff.sdiff (b i) (Set.iUnion fun j => Set.iUnion fun h => b j)) ⋯\nunion : ∀ (s : Set X) (hs : Topology.IsConstructible s) (t : Set X) (ht : Topology.IsConstructible t), P s hs → P t ht → P (Union.union s t) ⋯\ns : Set X\nhs : Topology.IsConstructible s\n⊢ P s hs","decl":"@[elab_as_elim]\nlemma IsConstructible.induction_of_isTopologicalBasis {ι : Type*} [Nonempty ι] (b : ι → Set X)\n    (basis : IsTopologicalBasis (range b)) (isCompact_basis : ∀ i, IsCompact (b i))\n    (sdiff : ∀ i s (hs : Set.Finite s), P (b i \\ ⋃ j ∈ s, b j)\n      ((basis.isConstructible isCompact_basis _).sdiff <| .biUnion hs fun _ _ ↦\n        basis.isConstructible isCompact_basis _))\n    (union : ∀ s hs t ht, P s hs → P t ht → P (s ∪ t) (hs.union ht))\n    (s : Set X) (hs : IsConstructible s) : P s hs := by\n  induction s, hs using BooleanSubalgebra.closure_sdiff_sup_induction with\n  | isSublattice =>\n    exact ⟨fun s hs t ht ↦ ⟨hs.1.union ht.1, hs.2.union ht.2⟩,\n      fun s hs t ht ↦ ⟨hs.1.inter ht.1, hs.2.inter_isOpen ht.2 ht.1⟩⟩\n  | bot_mem => exact ⟨isOpen_empty, .empty⟩\n  | top_mem => exact ⟨isOpen_univ, .univ⟩\n  | sdiff U hU V hV =>\n    have := isCompact_open_iff_eq_finite_iUnion_of_isTopologicalBasis _ basis isCompact_basis\n    obtain ⟨s, hs, rfl⟩ := (this _).1 ⟨hU.2.isCompact, hU.1⟩\n    obtain ⟨t, ht, rfl⟩ := (this _).1 ⟨hV.2.isCompact, hV.1⟩\n    simp_rw [iUnion_diff]\n    induction s, hs using Set.Finite.induction_on with\n    | empty => simpa using sdiff (Classical.arbitrary _) {Classical.arbitrary _}\n    | @insert i s hi hs ih =>\n      simp_rw [biUnion_insert]\n      exact union _ _ _\n        (.biUnion hs fun i _ ↦ (basis.isConstructible isCompact_basis _).sdiff <|\n          .biUnion ht fun j _ ↦ basis.isConstructible isCompact_basis _)\n        (sdiff _ _ ht)\n        (ih ⟨isOpen_biUnion fun  _ _ ↦ basis.isOpen ⟨_, rfl⟩, .biUnion hs\n          fun i _ ↦ basis.isRetrocompact isCompact_basis _⟩)\n  | sup s _ t _ hs' ht' => exact union _ _ _ _ hs' ht'\n\n"}
{"name":"Topology.IsConstructible.isLocallyConstructible","module":"Mathlib.Topology.Constructible","initialProofState":"X : Type u_2\ninst✝ : TopologicalSpace X\ns : Set X\nhs : Topology.IsConstructible s\n⊢ Topology.IsLocallyConstructible s","decl":"lemma IsConstructible.isLocallyConstructible (hs : IsConstructible s) : IsLocallyConstructible s :=\n  fun _ ↦ ⟨univ, by simp, by simp,\n    (isConstructible_preimage_iff_of_isOpenEmbedding isOpen_univ.isOpenEmbedding_subtypeVal\n      (by simp) (by simp)).2 hs⟩\n\n"}
{"name":"IsRetrocompact.isLocallyConstructible","module":"Mathlib.Topology.Constructible","initialProofState":"X : Type u_2\ninst✝ : TopologicalSpace X\nU : Set X\nhUopen : IsOpen U\nhUcomp : IsRetrocompact U\n⊢ Topology.IsLocallyConstructible U","decl":"lemma _root_.IsRetrocompact.isLocallyConstructible (hUopen : IsOpen U) (hUcomp : IsRetrocompact U) :\n    IsLocallyConstructible U := (hUcomp.isConstructible hUopen).isLocallyConstructible\n\n"}
{"name":"Topology.IsLocallyConstructible.empty","module":"Mathlib.Topology.Constructible","initialProofState":"X : Type u_2\ninst✝ : TopologicalSpace X\n⊢ Topology.IsLocallyConstructible EmptyCollection.emptyCollection","decl":"@[simp] protected lemma IsLocallyConstructible.empty : IsLocallyConstructible (∅ : Set X) :=\n  IsConstructible.empty.isLocallyConstructible\n\n"}
{"name":"Topology.IsLocallyConstructible.univ","module":"Mathlib.Topology.Constructible","initialProofState":"X : Type u_2\ninst✝ : TopologicalSpace X\n⊢ Topology.IsLocallyConstructible Set.univ","decl":"@[simp] protected lemma IsLocallyConstructible.univ : IsLocallyConstructible (univ : Set X) :=\n  IsConstructible.univ.isLocallyConstructible\n\n"}
{"name":"Topology.IsLocallyConstructible.inter","module":"Mathlib.Topology.Constructible","initialProofState":"X : Type u_2\ninst✝ : TopologicalSpace X\ns t : Set X\nhs : Topology.IsLocallyConstructible s\nht : Topology.IsLocallyConstructible t\n⊢ Topology.IsLocallyConstructible (Inter.inter s t)","decl":"lemma IsLocallyConstructible.inter (hs : IsLocallyConstructible s) (ht : IsLocallyConstructible t) :\n    IsLocallyConstructible (s ∩ t) := by\n  rintro x\n  obtain ⟨U, hxU, hU, hsU⟩ := hs x\n  obtain ⟨V, hxV, hV, htV⟩ := ht x\n  refine ⟨U ∩ V, Filter.inter_mem hxU hxV, hU.inter hV, ?_⟩\n  change IsConstructible\n    (inclusion inter_subset_left ⁻¹' (U ↓∩ s) ∩ inclusion inter_subset_right ⁻¹' (V ↓∩ t))\n  exact .inter (hsU.preimage_of_isOpenEmbedding <| .inclusion _ <|\n      .preimage continuous_subtype_val <| hU.inter hV)\n    (htV.preimage_of_isOpenEmbedding <| .inclusion _ <|\n      .preimage continuous_subtype_val <| hU.inter hV )\n\n"}
{"name":"Topology.IsLocallyConstructible.finsetInf","module":"Mathlib.Topology.Constructible","initialProofState":"X : Type u_2\ninst✝ : TopologicalSpace X\nι : Type u_4\ns : Finset ι\nt : ι → Set X\nht : ∀ (i : ι), Membership.mem s i → Topology.IsLocallyConstructible (t i)\n⊢ Topology.IsLocallyConstructible (s.inf t)","decl":"lemma IsLocallyConstructible.finsetInf {ι : Type*} {s : Finset ι} {t : ι → Set X}\n    (ht : ∀ i ∈ s, IsLocallyConstructible (t i)) : IsLocallyConstructible (s.inf t) := by\n  induction' s using Finset.cons_induction with i s ih hi\n  · simp\n  · rw [Finset.inf_cons]\n    exact (ht _ <| by simp).inter <| hi <| Finset.forall_of_forall_cons ht\n\n"}
{"name":"Topology.IsLocallyConstructible.finsetInf'","module":"Mathlib.Topology.Constructible","initialProofState":"X : Type u_2\ninst✝ : TopologicalSpace X\nι : Type u_4\ns : Finset ι\nhs : s.Nonempty\nt : ι → Set X\nht : ∀ (i : ι), Membership.mem s i → Topology.IsLocallyConstructible (t i)\n⊢ Topology.IsLocallyConstructible (s.inf' hs t)","decl":"set_option linter.docPrime false in\nlemma IsLocallyConstructible.finsetInf' {ι : Type*} {s : Finset ι} {hs} {t : ι → Set X}\n    (ht : ∀ i ∈ s, IsLocallyConstructible (t i)) : IsLocallyConstructible (s.inf' hs t) := by\n  rw [Finset.inf'_eq_inf]; exact .finsetInf ht\n\n"}
{"name":"Topology.IsLocallyConstructible.iInter","module":"Mathlib.Topology.Constructible","initialProofState":"ι : Sort u_1\nX : Type u_2\ninst✝¹ : TopologicalSpace X\ninst✝ : Finite ι\nf : ι → Set X\nhf : ∀ (i : ι), Topology.IsLocallyConstructible (f i)\n⊢ Topology.IsLocallyConstructible (Set.iInter fun i => f i)","decl":"lemma IsLocallyConstructible.iInter [Finite ι] {f : ι → Set X}\n    (hf : ∀ i, IsLocallyConstructible (f i)) : IsLocallyConstructible (⋂ i, f i) :=\n  infClosed_isLocallyConstructible.iInf_mem .univ hf\n\n"}
{"name":"Topology.IsLocallyConstructible.sInter","module":"Mathlib.Topology.Constructible","initialProofState":"X : Type u_2\ninst✝ : TopologicalSpace X\nS : Set (Set X)\nhS : S.Finite\nhS' : ∀ (s : Set X), Membership.mem S s → Topology.IsLocallyConstructible s\n⊢ Topology.IsLocallyConstructible S.sInter","decl":"lemma IsLocallyConstructible.sInter {S : Set (Set X)} (hS : S.Finite)\n    (hS' : ∀ s ∈ S, IsLocallyConstructible s) : IsLocallyConstructible (⋂₀ S) :=\n  infClosed_isLocallyConstructible.sInf_mem hS .univ hS'\n\n"}
