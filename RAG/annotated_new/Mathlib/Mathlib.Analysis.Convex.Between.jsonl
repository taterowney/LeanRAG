{"name":"affineSegment_eq_segment","module":"Mathlib.Analysis.Convex.Between","initialProofState":"R : Type u_1\nV : Type u_2\ninst✝² : OrderedRing R\ninst✝¹ : AddCommGroup V\ninst✝ : Module R V\nx y : V\n⊢ Eq (affineSegment R x y) (segment R x y)","decl":"theorem affineSegment_eq_segment (x y : V) : affineSegment R x y = segment R x y := by\n  rw [segment_eq_image_lineMap, affineSegment]\n\n"}
{"name":"affineSegment_comm","module":"Mathlib.Analysis.Convex.Between","initialProofState":"R : Type u_1\nV : Type u_2\nP : Type u_4\ninst✝³ : OrderedRing R\ninst✝² : AddCommGroup V\ninst✝¹ : Module R V\ninst✝ : AddTorsor V P\nx y : P\n⊢ Eq (affineSegment R x y) (affineSegment R y x)","decl":"theorem affineSegment_comm (x y : P) : affineSegment R x y = affineSegment R y x := by\n  refine Set.ext fun z => ?_\n  constructor <;>\n    · rintro ⟨t, ht, hxy⟩\n      refine ⟨1 - t, ?_, ?_⟩\n      · rwa [Set.sub_mem_Icc_iff_right, sub_self, sub_zero]\n      · rwa [lineMap_apply_one_sub]\n\n"}
{"name":"left_mem_affineSegment","module":"Mathlib.Analysis.Convex.Between","initialProofState":"R : Type u_1\nV : Type u_2\nP : Type u_4\ninst✝³ : OrderedRing R\ninst✝² : AddCommGroup V\ninst✝¹ : Module R V\ninst✝ : AddTorsor V P\nx y : P\n⊢ Membership.mem (affineSegment R x y) x","decl":"theorem left_mem_affineSegment (x y : P) : x ∈ affineSegment R x y :=\n  ⟨0, Set.left_mem_Icc.2 zero_le_one, lineMap_apply_zero _ _⟩\n\n"}
{"name":"right_mem_affineSegment","module":"Mathlib.Analysis.Convex.Between","initialProofState":"R : Type u_1\nV : Type u_2\nP : Type u_4\ninst✝³ : OrderedRing R\ninst✝² : AddCommGroup V\ninst✝¹ : Module R V\ninst✝ : AddTorsor V P\nx y : P\n⊢ Membership.mem (affineSegment R x y) y","decl":"theorem right_mem_affineSegment (x y : P) : y ∈ affineSegment R x y :=\n  ⟨1, Set.right_mem_Icc.2 zero_le_one, lineMap_apply_one _ _⟩\n\n"}
{"name":"affineSegment_same","module":"Mathlib.Analysis.Convex.Between","initialProofState":"R : Type u_1\nV : Type u_2\nP : Type u_4\ninst✝³ : OrderedRing R\ninst✝² : AddCommGroup V\ninst✝¹ : Module R V\ninst✝ : AddTorsor V P\nx : P\n⊢ Eq (affineSegment R x x) (Singleton.singleton x)","decl":"@[simp]\ntheorem affineSegment_same (x : P) : affineSegment R x x = {x} := by\n  simp_rw [affineSegment, lineMap_same, AffineMap.coe_const, Function.const,\n    (Set.nonempty_Icc.mpr zero_le_one).image_const]\n\n"}
{"name":"affineSegment_image","module":"Mathlib.Analysis.Convex.Between","initialProofState":"R : Type u_1\nV : Type u_2\nV' : Type u_3\nP : Type u_4\nP' : Type u_5\ninst✝⁶ : OrderedRing R\ninst✝⁵ : AddCommGroup V\ninst✝⁴ : Module R V\ninst✝³ : AddTorsor V P\ninst✝² : AddCommGroup V'\ninst✝¹ : Module R V'\ninst✝ : AddTorsor V' P'\nf : AffineMap R P P'\nx y : P\n⊢ Eq (Set.image (⇑f) (affineSegment R x y)) (affineSegment R (f x) (f y))","decl":"@[simp]\ntheorem affineSegment_image (f : P →ᵃ[R] P') (x y : P) :\n    f '' affineSegment R x y = affineSegment R (f x) (f y) := by\n  rw [affineSegment, affineSegment, Set.image_image, ← comp_lineMap]\n  rfl\n\n"}
{"name":"affineSegment_const_vadd_image","module":"Mathlib.Analysis.Convex.Between","initialProofState":"R : Type u_1\nV : Type u_2\nP : Type u_4\ninst✝³ : OrderedRing R\ninst✝² : AddCommGroup V\ninst✝¹ : Module R V\ninst✝ : AddTorsor V P\nx y : P\nv : V\n⊢ Eq (Set.image (fun x => HVAdd.hVAdd v x) (affineSegment R x y)) (affineSegment R (HVAdd.hVAdd v x) (HVAdd.hVAdd v y))","decl":"@[simp]\ntheorem affineSegment_const_vadd_image (x y : P) (v : V) :\n    (v +ᵥ ·) '' affineSegment R x y = affineSegment R (v +ᵥ x) (v +ᵥ y) :=\n  affineSegment_image (AffineEquiv.constVAdd R P v : P →ᵃ[R] P) x y\n\n"}
{"name":"affineSegment_vadd_const_image","module":"Mathlib.Analysis.Convex.Between","initialProofState":"R : Type u_1\nV : Type u_2\nP : Type u_4\ninst✝³ : OrderedRing R\ninst✝² : AddCommGroup V\ninst✝¹ : Module R V\ninst✝ : AddTorsor V P\nx y : V\np : P\n⊢ Eq (Set.image (fun x => HVAdd.hVAdd x p) (affineSegment R x y)) (affineSegment R (HVAdd.hVAdd x p) (HVAdd.hVAdd y p))","decl":"@[simp]\ntheorem affineSegment_vadd_const_image (x y : V) (p : P) :\n    (· +ᵥ p) '' affineSegment R x y = affineSegment R (x +ᵥ p) (y +ᵥ p) :=\n  affineSegment_image (AffineEquiv.vaddConst R p : V →ᵃ[R] P) x y\n\n"}
{"name":"affineSegment_const_vsub_image","module":"Mathlib.Analysis.Convex.Between","initialProofState":"R : Type u_1\nV : Type u_2\nP : Type u_4\ninst✝³ : OrderedRing R\ninst✝² : AddCommGroup V\ninst✝¹ : Module R V\ninst✝ : AddTorsor V P\nx y p : P\n⊢ Eq (Set.image (fun x => VSub.vsub p x) (affineSegment R x y)) (affineSegment R (VSub.vsub p x) (VSub.vsub p y))","decl":"@[simp]\ntheorem affineSegment_const_vsub_image (x y p : P) :\n    (p -ᵥ ·) '' affineSegment R x y = affineSegment R (p -ᵥ x) (p -ᵥ y) :=\n  affineSegment_image (AffineEquiv.constVSub R p : P →ᵃ[R] V) x y\n\n"}
{"name":"affineSegment_vsub_const_image","module":"Mathlib.Analysis.Convex.Between","initialProofState":"R : Type u_1\nV : Type u_2\nP : Type u_4\ninst✝³ : OrderedRing R\ninst✝² : AddCommGroup V\ninst✝¹ : Module R V\ninst✝ : AddTorsor V P\nx y p : P\n⊢ Eq (Set.image (fun x => VSub.vsub x p) (affineSegment R x y)) (affineSegment R (VSub.vsub x p) (VSub.vsub y p))","decl":"@[simp]\ntheorem affineSegment_vsub_const_image (x y p : P) :\n    (· -ᵥ p) '' affineSegment R x y = affineSegment R (x -ᵥ p) (y -ᵥ p) :=\n  affineSegment_image ((AffineEquiv.vaddConst R p).symm : P →ᵃ[R] V) x y\n\n"}
{"name":"mem_const_vadd_affineSegment","module":"Mathlib.Analysis.Convex.Between","initialProofState":"R : Type u_1\nV : Type u_2\nP : Type u_4\ninst✝³ : OrderedRing R\ninst✝² : AddCommGroup V\ninst✝¹ : Module R V\ninst✝ : AddTorsor V P\nx y z : P\nv : V\n⊢ Iff (Membership.mem (affineSegment R (HVAdd.hVAdd v x) (HVAdd.hVAdd v y)) (HVAdd.hVAdd v z)) (Membership.mem (affineSegment R x y) z)","decl":"@[simp]\ntheorem mem_const_vadd_affineSegment {x y z : P} (v : V) :\n    v +ᵥ z ∈ affineSegment R (v +ᵥ x) (v +ᵥ y) ↔ z ∈ affineSegment R x y := by\n  rw [← affineSegment_const_vadd_image, (AddAction.injective v).mem_set_image]\n\n"}
{"name":"mem_vadd_const_affineSegment","module":"Mathlib.Analysis.Convex.Between","initialProofState":"R : Type u_1\nV : Type u_2\nP : Type u_4\ninst✝³ : OrderedRing R\ninst✝² : AddCommGroup V\ninst✝¹ : Module R V\ninst✝ : AddTorsor V P\nx y z : V\np : P\n⊢ Iff (Membership.mem (affineSegment R (HVAdd.hVAdd x p) (HVAdd.hVAdd y p)) (HVAdd.hVAdd z p)) (Membership.mem (affineSegment R x y) z)","decl":"@[simp]\ntheorem mem_vadd_const_affineSegment {x y z : V} (p : P) :\n    z +ᵥ p ∈ affineSegment R (x +ᵥ p) (y +ᵥ p) ↔ z ∈ affineSegment R x y := by\n  rw [← affineSegment_vadd_const_image, (vadd_right_injective p).mem_set_image]\n\n"}
{"name":"mem_const_vsub_affineSegment","module":"Mathlib.Analysis.Convex.Between","initialProofState":"R : Type u_1\nV : Type u_2\nP : Type u_4\ninst✝³ : OrderedRing R\ninst✝² : AddCommGroup V\ninst✝¹ : Module R V\ninst✝ : AddTorsor V P\nx y z p : P\n⊢ Iff (Membership.mem (affineSegment R (VSub.vsub p x) (VSub.vsub p y)) (VSub.vsub p z)) (Membership.mem (affineSegment R x y) z)","decl":"@[simp]\ntheorem mem_const_vsub_affineSegment {x y z : P} (p : P) :\n    p -ᵥ z ∈ affineSegment R (p -ᵥ x) (p -ᵥ y) ↔ z ∈ affineSegment R x y := by\n  rw [← affineSegment_const_vsub_image, (vsub_right_injective p).mem_set_image]\n\n"}
{"name":"mem_vsub_const_affineSegment","module":"Mathlib.Analysis.Convex.Between","initialProofState":"R : Type u_1\nV : Type u_2\nP : Type u_4\ninst✝³ : OrderedRing R\ninst✝² : AddCommGroup V\ninst✝¹ : Module R V\ninst✝ : AddTorsor V P\nx y z p : P\n⊢ Iff (Membership.mem (affineSegment R (VSub.vsub x p) (VSub.vsub y p)) (VSub.vsub z p)) (Membership.mem (affineSegment R x y) z)","decl":"@[simp]\ntheorem mem_vsub_const_affineSegment {x y z : P} (p : P) :\n    z -ᵥ p ∈ affineSegment R (x -ᵥ p) (y -ᵥ p) ↔ z ∈ affineSegment R x y := by\n  rw [← affineSegment_vsub_const_image, (vsub_left_injective p).mem_set_image]\n\n"}
{"name":"mem_segment_iff_wbtw","module":"Mathlib.Analysis.Convex.Between","initialProofState":"R : Type u_1\nV : Type u_2\ninst✝² : OrderedRing R\ninst✝¹ : AddCommGroup V\ninst✝ : Module R V\nx y z : V\n⊢ Iff (Membership.mem (segment R x z) y) (Wbtw R x y z)","decl":"lemma mem_segment_iff_wbtw {x y z : V} : y ∈ segment R x z ↔ Wbtw R x y z := by\n  rw [Wbtw, affineSegment_eq_segment]\n\n"}
{"name":"Wbtw.mem_segment","module":"Mathlib.Analysis.Convex.Between","initialProofState":"R : Type u_1\nV : Type u_2\ninst✝² : OrderedRing R\ninst✝¹ : AddCommGroup V\ninst✝ : Module R V\nx y z : V\na✝ : Wbtw R x y z\n⊢ Membership.mem (segment R x z) y","decl":"alias ⟨_, Wbtw.mem_segment⟩ := mem_segment_iff_wbtw\n\n"}
{"name":"Convex.mem_of_wbtw","module":"Mathlib.Analysis.Convex.Between","initialProofState":"R : Type u_1\nV : Type u_2\ninst✝² : OrderedRing R\ninst✝¹ : AddCommGroup V\ninst✝ : Module R V\np₀ p₁ p₂ : V\ns : Set V\nhs : Convex R s\nh₀₁₂ : Wbtw R p₀ p₁ p₂\nh₀ : Membership.mem s p₀\nh₂ : Membership.mem s p₂\n⊢ Membership.mem s p₁","decl":"lemma Convex.mem_of_wbtw {p₀ p₁ p₂ : V} {s : Set V} (hs : Convex R s) (h₀₁₂ : Wbtw R p₀ p₁ p₂)\n    (h₀ : p₀ ∈ s) (h₂ : p₂ ∈ s) : p₁ ∈ s := hs.segment_subset h₀ h₂ h₀₁₂.mem_segment\n\n"}
{"name":"AffineSubspace.mem_of_wbtw","module":"Mathlib.Analysis.Convex.Between","initialProofState":"R : Type u_1\nV : Type u_2\nP : Type u_4\ninst✝³ : OrderedRing R\ninst✝² : AddCommGroup V\ninst✝¹ : Module R V\ninst✝ : AddTorsor V P\ns : AffineSubspace R P\nx y z : P\nhxyz : Wbtw R x y z\nhx : Membership.mem s x\nhz : Membership.mem s z\n⊢ Membership.mem s y","decl":"lemma AffineSubspace.mem_of_wbtw {s : AffineSubspace R P} {x y z : P} (hxyz : Wbtw R x y z)\n    (hx : x ∈ s) (hz : z ∈ s) : y ∈ s := by obtain ⟨ε, -, rfl⟩ := hxyz; exact lineMap_mem _ hx hz\n\n"}
{"name":"Wbtw.map","module":"Mathlib.Analysis.Convex.Between","initialProofState":"R : Type u_1\nV : Type u_2\nV' : Type u_3\nP : Type u_4\nP' : Type u_5\ninst✝⁶ : OrderedRing R\ninst✝⁵ : AddCommGroup V\ninst✝⁴ : Module R V\ninst✝³ : AddTorsor V P\ninst✝² : AddCommGroup V'\ninst✝¹ : Module R V'\ninst✝ : AddTorsor V' P'\nx y z : P\nh : Wbtw R x y z\nf : AffineMap R P P'\n⊢ Wbtw R (f x) (f y) (f z)","decl":"theorem Wbtw.map {x y z : P} (h : Wbtw R x y z) (f : P →ᵃ[R] P') : Wbtw R (f x) (f y) (f z) := by\n  rw [Wbtw, ← affineSegment_image]\n  exact Set.mem_image_of_mem _ h\n\n"}
{"name":"Function.Injective.wbtw_map_iff","module":"Mathlib.Analysis.Convex.Between","initialProofState":"R : Type u_1\nV : Type u_2\nV' : Type u_3\nP : Type u_4\nP' : Type u_5\ninst✝⁶ : OrderedRing R\ninst✝⁵ : AddCommGroup V\ninst✝⁴ : Module R V\ninst✝³ : AddTorsor V P\ninst✝² : AddCommGroup V'\ninst✝¹ : Module R V'\ninst✝ : AddTorsor V' P'\nx y z : P\nf : AffineMap R P P'\nhf : Function.Injective ⇑f\n⊢ Iff (Wbtw R (f x) (f y) (f z)) (Wbtw R x y z)","decl":"theorem Function.Injective.wbtw_map_iff {x y z : P} {f : P →ᵃ[R] P'} (hf : Function.Injective f) :\n    Wbtw R (f x) (f y) (f z) ↔ Wbtw R x y z := by\n  refine ⟨fun h => ?_, fun h => h.map _⟩\n  rwa [Wbtw, ← affineSegment_image, hf.mem_set_image] at h\n\n"}
{"name":"Function.Injective.sbtw_map_iff","module":"Mathlib.Analysis.Convex.Between","initialProofState":"R : Type u_1\nV : Type u_2\nV' : Type u_3\nP : Type u_4\nP' : Type u_5\ninst✝⁶ : OrderedRing R\ninst✝⁵ : AddCommGroup V\ninst✝⁴ : Module R V\ninst✝³ : AddTorsor V P\ninst✝² : AddCommGroup V'\ninst✝¹ : Module R V'\ninst✝ : AddTorsor V' P'\nx y z : P\nf : AffineMap R P P'\nhf : Function.Injective ⇑f\n⊢ Iff (Sbtw R (f x) (f y) (f z)) (Sbtw R x y z)","decl":"theorem Function.Injective.sbtw_map_iff {x y z : P} {f : P →ᵃ[R] P'} (hf : Function.Injective f) :\n    Sbtw R (f x) (f y) (f z) ↔ Sbtw R x y z := by\n  simp_rw [Sbtw, hf.wbtw_map_iff, hf.ne_iff]\n\n"}
{"name":"AffineEquiv.wbtw_map_iff","module":"Mathlib.Analysis.Convex.Between","initialProofState":"R : Type u_1\nV : Type u_2\nV' : Type u_3\nP : Type u_4\nP' : Type u_5\ninst✝⁶ : OrderedRing R\ninst✝⁵ : AddCommGroup V\ninst✝⁴ : Module R V\ninst✝³ : AddTorsor V P\ninst✝² : AddCommGroup V'\ninst✝¹ : Module R V'\ninst✝ : AddTorsor V' P'\nx y z : P\nf : AffineEquiv R P P'\n⊢ Iff (Wbtw R (f x) (f y) (f z)) (Wbtw R x y z)","decl":"@[simp]\ntheorem AffineEquiv.wbtw_map_iff {x y z : P} (f : P ≃ᵃ[R] P') :\n    Wbtw R (f x) (f y) (f z) ↔ Wbtw R x y z := by\n  have : Function.Injective f.toAffineMap := f.injective\n  -- `refine` or `exact` are very slow, `apply` is fast. Please check before golfing.\n  apply this.wbtw_map_iff\n\n"}
{"name":"AffineEquiv.sbtw_map_iff","module":"Mathlib.Analysis.Convex.Between","initialProofState":"R : Type u_1\nV : Type u_2\nV' : Type u_3\nP : Type u_4\nP' : Type u_5\ninst✝⁶ : OrderedRing R\ninst✝⁵ : AddCommGroup V\ninst✝⁴ : Module R V\ninst✝³ : AddTorsor V P\ninst✝² : AddCommGroup V'\ninst✝¹ : Module R V'\ninst✝ : AddTorsor V' P'\nx y z : P\nf : AffineEquiv R P P'\n⊢ Iff (Sbtw R (f x) (f y) (f z)) (Sbtw R x y z)","decl":"@[simp]\ntheorem AffineEquiv.sbtw_map_iff {x y z : P} (f : P ≃ᵃ[R] P') :\n    Sbtw R (f x) (f y) (f z) ↔ Sbtw R x y z := by\n  have : Function.Injective f.toAffineMap := f.injective\n  -- `refine` or `exact` are very slow, `apply` is fast. Please check before golfing.\n  apply this.sbtw_map_iff\n\n"}
{"name":"wbtw_const_vadd_iff","module":"Mathlib.Analysis.Convex.Between","initialProofState":"R : Type u_1\nV : Type u_2\nP : Type u_4\ninst✝³ : OrderedRing R\ninst✝² : AddCommGroup V\ninst✝¹ : Module R V\ninst✝ : AddTorsor V P\nx y z : P\nv : V\n⊢ Iff (Wbtw R (HVAdd.hVAdd v x) (HVAdd.hVAdd v y) (HVAdd.hVAdd v z)) (Wbtw R x y z)","decl":"@[simp]\ntheorem wbtw_const_vadd_iff {x y z : P} (v : V) :\n    Wbtw R (v +ᵥ x) (v +ᵥ y) (v +ᵥ z) ↔ Wbtw R x y z :=\n  mem_const_vadd_affineSegment _\n\n"}
{"name":"wbtw_vadd_const_iff","module":"Mathlib.Analysis.Convex.Between","initialProofState":"R : Type u_1\nV : Type u_2\nP : Type u_4\ninst✝³ : OrderedRing R\ninst✝² : AddCommGroup V\ninst✝¹ : Module R V\ninst✝ : AddTorsor V P\nx y z : V\np : P\n⊢ Iff (Wbtw R (HVAdd.hVAdd x p) (HVAdd.hVAdd y p) (HVAdd.hVAdd z p)) (Wbtw R x y z)","decl":"@[simp]\ntheorem wbtw_vadd_const_iff {x y z : V} (p : P) :\n    Wbtw R (x +ᵥ p) (y +ᵥ p) (z +ᵥ p) ↔ Wbtw R x y z :=\n  mem_vadd_const_affineSegment _\n\n"}
{"name":"wbtw_const_vsub_iff","module":"Mathlib.Analysis.Convex.Between","initialProofState":"R : Type u_1\nV : Type u_2\nP : Type u_4\ninst✝³ : OrderedRing R\ninst✝² : AddCommGroup V\ninst✝¹ : Module R V\ninst✝ : AddTorsor V P\nx y z p : P\n⊢ Iff (Wbtw R (VSub.vsub p x) (VSub.vsub p y) (VSub.vsub p z)) (Wbtw R x y z)","decl":"@[simp]\ntheorem wbtw_const_vsub_iff {x y z : P} (p : P) :\n    Wbtw R (p -ᵥ x) (p -ᵥ y) (p -ᵥ z) ↔ Wbtw R x y z :=\n  mem_const_vsub_affineSegment _\n\n"}
{"name":"wbtw_vsub_const_iff","module":"Mathlib.Analysis.Convex.Between","initialProofState":"R : Type u_1\nV : Type u_2\nP : Type u_4\ninst✝³ : OrderedRing R\ninst✝² : AddCommGroup V\ninst✝¹ : Module R V\ninst✝ : AddTorsor V P\nx y z p : P\n⊢ Iff (Wbtw R (VSub.vsub x p) (VSub.vsub y p) (VSub.vsub z p)) (Wbtw R x y z)","decl":"@[simp]\ntheorem wbtw_vsub_const_iff {x y z : P} (p : P) :\n    Wbtw R (x -ᵥ p) (y -ᵥ p) (z -ᵥ p) ↔ Wbtw R x y z :=\n  mem_vsub_const_affineSegment _\n\n"}
{"name":"sbtw_const_vadd_iff","module":"Mathlib.Analysis.Convex.Between","initialProofState":"R : Type u_1\nV : Type u_2\nP : Type u_4\ninst✝³ : OrderedRing R\ninst✝² : AddCommGroup V\ninst✝¹ : Module R V\ninst✝ : AddTorsor V P\nx y z : P\nv : V\n⊢ Iff (Sbtw R (HVAdd.hVAdd v x) (HVAdd.hVAdd v y) (HVAdd.hVAdd v z)) (Sbtw R x y z)","decl":"@[simp]\ntheorem sbtw_const_vadd_iff {x y z : P} (v : V) :\n    Sbtw R (v +ᵥ x) (v +ᵥ y) (v +ᵥ z) ↔ Sbtw R x y z := by\n  rw [Sbtw, Sbtw, wbtw_const_vadd_iff, (AddAction.injective v).ne_iff,\n    (AddAction.injective v).ne_iff]\n\n"}
{"name":"sbtw_vadd_const_iff","module":"Mathlib.Analysis.Convex.Between","initialProofState":"R : Type u_1\nV : Type u_2\nP : Type u_4\ninst✝³ : OrderedRing R\ninst✝² : AddCommGroup V\ninst✝¹ : Module R V\ninst✝ : AddTorsor V P\nx y z : V\np : P\n⊢ Iff (Sbtw R (HVAdd.hVAdd x p) (HVAdd.hVAdd y p) (HVAdd.hVAdd z p)) (Sbtw R x y z)","decl":"@[simp]\ntheorem sbtw_vadd_const_iff {x y z : V} (p : P) :\n    Sbtw R (x +ᵥ p) (y +ᵥ p) (z +ᵥ p) ↔ Sbtw R x y z := by\n  rw [Sbtw, Sbtw, wbtw_vadd_const_iff, (vadd_right_injective p).ne_iff,\n    (vadd_right_injective p).ne_iff]\n\n"}
{"name":"sbtw_const_vsub_iff","module":"Mathlib.Analysis.Convex.Between","initialProofState":"R : Type u_1\nV : Type u_2\nP : Type u_4\ninst✝³ : OrderedRing R\ninst✝² : AddCommGroup V\ninst✝¹ : Module R V\ninst✝ : AddTorsor V P\nx y z p : P\n⊢ Iff (Sbtw R (VSub.vsub p x) (VSub.vsub p y) (VSub.vsub p z)) (Sbtw R x y z)","decl":"@[simp]\ntheorem sbtw_const_vsub_iff {x y z : P} (p : P) :\n    Sbtw R (p -ᵥ x) (p -ᵥ y) (p -ᵥ z) ↔ Sbtw R x y z := by\n  rw [Sbtw, Sbtw, wbtw_const_vsub_iff, (vsub_right_injective p).ne_iff,\n    (vsub_right_injective p).ne_iff]\n\n"}
{"name":"sbtw_vsub_const_iff","module":"Mathlib.Analysis.Convex.Between","initialProofState":"R : Type u_1\nV : Type u_2\nP : Type u_4\ninst✝³ : OrderedRing R\ninst✝² : AddCommGroup V\ninst✝¹ : Module R V\ninst✝ : AddTorsor V P\nx y z p : P\n⊢ Iff (Sbtw R (VSub.vsub x p) (VSub.vsub y p) (VSub.vsub z p)) (Sbtw R x y z)","decl":"@[simp]\ntheorem sbtw_vsub_const_iff {x y z : P} (p : P) :\n    Sbtw R (x -ᵥ p) (y -ᵥ p) (z -ᵥ p) ↔ Sbtw R x y z := by\n  rw [Sbtw, Sbtw, wbtw_vsub_const_iff, (vsub_left_injective p).ne_iff,\n    (vsub_left_injective p).ne_iff]\n\n"}
{"name":"Sbtw.wbtw","module":"Mathlib.Analysis.Convex.Between","initialProofState":"R : Type u_1\nV : Type u_2\nP : Type u_4\ninst✝³ : OrderedRing R\ninst✝² : AddCommGroup V\ninst✝¹ : Module R V\ninst✝ : AddTorsor V P\nx y z : P\nh : Sbtw R x y z\n⊢ Wbtw R x y z","decl":"theorem Sbtw.wbtw {x y z : P} (h : Sbtw R x y z) : Wbtw R x y z :=\n  h.1\n\n"}
{"name":"Sbtw.ne_left","module":"Mathlib.Analysis.Convex.Between","initialProofState":"R : Type u_1\nV : Type u_2\nP : Type u_4\ninst✝³ : OrderedRing R\ninst✝² : AddCommGroup V\ninst✝¹ : Module R V\ninst✝ : AddTorsor V P\nx y z : P\nh : Sbtw R x y z\n⊢ Ne y x","decl":"theorem Sbtw.ne_left {x y z : P} (h : Sbtw R x y z) : y ≠ x :=\n  h.2.1\n\n"}
{"name":"Sbtw.left_ne","module":"Mathlib.Analysis.Convex.Between","initialProofState":"R : Type u_1\nV : Type u_2\nP : Type u_4\ninst✝³ : OrderedRing R\ninst✝² : AddCommGroup V\ninst✝¹ : Module R V\ninst✝ : AddTorsor V P\nx y z : P\nh : Sbtw R x y z\n⊢ Ne x y","decl":"theorem Sbtw.left_ne {x y z : P} (h : Sbtw R x y z) : x ≠ y :=\n  h.2.1.symm\n\n"}
{"name":"Sbtw.ne_right","module":"Mathlib.Analysis.Convex.Between","initialProofState":"R : Type u_1\nV : Type u_2\nP : Type u_4\ninst✝³ : OrderedRing R\ninst✝² : AddCommGroup V\ninst✝¹ : Module R V\ninst✝ : AddTorsor V P\nx y z : P\nh : Sbtw R x y z\n⊢ Ne y z","decl":"theorem Sbtw.ne_right {x y z : P} (h : Sbtw R x y z) : y ≠ z :=\n  h.2.2\n\n"}
{"name":"Sbtw.right_ne","module":"Mathlib.Analysis.Convex.Between","initialProofState":"R : Type u_1\nV : Type u_2\nP : Type u_4\ninst✝³ : OrderedRing R\ninst✝² : AddCommGroup V\ninst✝¹ : Module R V\ninst✝ : AddTorsor V P\nx y z : P\nh : Sbtw R x y z\n⊢ Ne z y","decl":"theorem Sbtw.right_ne {x y z : P} (h : Sbtw R x y z) : z ≠ y :=\n  h.2.2.symm\n\n"}
{"name":"Sbtw.mem_image_Ioo","module":"Mathlib.Analysis.Convex.Between","initialProofState":"R : Type u_1\nV : Type u_2\nP : Type u_4\ninst✝³ : OrderedRing R\ninst✝² : AddCommGroup V\ninst✝¹ : Module R V\ninst✝ : AddTorsor V P\nx y z : P\nh : Sbtw R x y z\n⊢ Membership.mem (Set.image (⇑(AffineMap.lineMap x z)) (Set.Ioo 0 1)) y","decl":"theorem Sbtw.mem_image_Ioo {x y z : P} (h : Sbtw R x y z) :\n    y ∈ lineMap x z '' Set.Ioo (0 : R) 1 := by\n  rcases h with ⟨⟨t, ht, rfl⟩, hyx, hyz⟩\n  rcases Set.eq_endpoints_or_mem_Ioo_of_mem_Icc ht with (rfl | rfl | ho)\n  · exfalso\n    exact hyx (lineMap_apply_zero _ _)\n  · exfalso\n    exact hyz (lineMap_apply_one _ _)\n  · exact ⟨t, ho, rfl⟩\n\n"}
{"name":"Wbtw.mem_affineSpan","module":"Mathlib.Analysis.Convex.Between","initialProofState":"R : Type u_1\nV : Type u_2\nP : Type u_4\ninst✝³ : OrderedRing R\ninst✝² : AddCommGroup V\ninst✝¹ : Module R V\ninst✝ : AddTorsor V P\nx y z : P\nh : Wbtw R x y z\n⊢ Membership.mem (affineSpan R (Insert.insert x (Singleton.singleton z))) y","decl":"theorem Wbtw.mem_affineSpan {x y z : P} (h : Wbtw R x y z) : y ∈ line[R, x, z] := by\n  rcases h with ⟨r, ⟨-, rfl⟩⟩\n  exact lineMap_mem_affineSpan_pair _ _ _\n\n"}
{"name":"wbtw_comm","module":"Mathlib.Analysis.Convex.Between","initialProofState":"R : Type u_1\nV : Type u_2\nP : Type u_4\ninst✝³ : OrderedRing R\ninst✝² : AddCommGroup V\ninst✝¹ : Module R V\ninst✝ : AddTorsor V P\nx y z : P\n⊢ Iff (Wbtw R x y z) (Wbtw R z y x)","decl":"theorem wbtw_comm {x y z : P} : Wbtw R x y z ↔ Wbtw R z y x := by\n  rw [Wbtw, Wbtw, affineSegment_comm]\n\n"}
{"name":"Wbtw.symm","module":"Mathlib.Analysis.Convex.Between","initialProofState":"R : Type u_1\nV : Type u_2\nP : Type u_4\ninst✝³ : OrderedRing R\ninst✝² : AddCommGroup V\ninst✝¹ : Module R V\ninst✝ : AddTorsor V P\nx y z : P\na✝ : Wbtw R x y z\n⊢ Wbtw R z y x","decl":"alias ⟨Wbtw.symm, _⟩ := wbtw_comm\n\n"}
{"name":"sbtw_comm","module":"Mathlib.Analysis.Convex.Between","initialProofState":"R : Type u_1\nV : Type u_2\nP : Type u_4\ninst✝³ : OrderedRing R\ninst✝² : AddCommGroup V\ninst✝¹ : Module R V\ninst✝ : AddTorsor V P\nx y z : P\n⊢ Iff (Sbtw R x y z) (Sbtw R z y x)","decl":"theorem sbtw_comm {x y z : P} : Sbtw R x y z ↔ Sbtw R z y x := by\n  rw [Sbtw, Sbtw, wbtw_comm, ← and_assoc, ← and_assoc, and_right_comm]\n\n"}
{"name":"Sbtw.symm","module":"Mathlib.Analysis.Convex.Between","initialProofState":"R : Type u_1\nV : Type u_2\nP : Type u_4\ninst✝³ : OrderedRing R\ninst✝² : AddCommGroup V\ninst✝¹ : Module R V\ninst✝ : AddTorsor V P\nx y z : P\na✝ : Sbtw R x y z\n⊢ Sbtw R z y x","decl":"alias ⟨Sbtw.symm, _⟩ := sbtw_comm\n\n"}
{"name":"wbtw_self_left","module":"Mathlib.Analysis.Convex.Between","initialProofState":"R : Type u_1\nV : Type u_2\nP : Type u_4\ninst✝³ : OrderedRing R\ninst✝² : AddCommGroup V\ninst✝¹ : Module R V\ninst✝ : AddTorsor V P\nx y : P\n⊢ Wbtw R x x y","decl":"@[simp]\ntheorem wbtw_self_left (x y : P) : Wbtw R x x y :=\n  left_mem_affineSegment _ _ _\n\n"}
{"name":"wbtw_self_right","module":"Mathlib.Analysis.Convex.Between","initialProofState":"R : Type u_1\nV : Type u_2\nP : Type u_4\ninst✝³ : OrderedRing R\ninst✝² : AddCommGroup V\ninst✝¹ : Module R V\ninst✝ : AddTorsor V P\nx y : P\n⊢ Wbtw R x y y","decl":"@[simp]\ntheorem wbtw_self_right (x y : P) : Wbtw R x y y :=\n  right_mem_affineSegment _ _ _\n\n"}
{"name":"wbtw_self_iff","module":"Mathlib.Analysis.Convex.Between","initialProofState":"R : Type u_1\nV : Type u_2\nP : Type u_4\ninst✝³ : OrderedRing R\ninst✝² : AddCommGroup V\ninst✝¹ : Module R V\ninst✝ : AddTorsor V P\nx y : P\n⊢ Iff (Wbtw R x y x) (Eq y x)","decl":"@[simp]\ntheorem wbtw_self_iff {x y : P} : Wbtw R x y x ↔ y = x := by\n  refine ⟨fun h => ?_, fun h => ?_⟩\n  · -- Porting note: Originally `simpa [Wbtw, affineSegment] using h`\n    have ⟨_, _, h₂⟩ := h\n    rw [h₂.symm, lineMap_same_apply]\n  · rw [h]\n    exact wbtw_self_left R x x\n\n"}
{"name":"not_sbtw_self_left","module":"Mathlib.Analysis.Convex.Between","initialProofState":"R : Type u_1\nV : Type u_2\nP : Type u_4\ninst✝³ : OrderedRing R\ninst✝² : AddCommGroup V\ninst✝¹ : Module R V\ninst✝ : AddTorsor V P\nx y : P\n⊢ Not (Sbtw R x x y)","decl":"@[simp]\ntheorem not_sbtw_self_left (x y : P) : ¬Sbtw R x x y :=\n  fun h => h.ne_left rfl\n\n"}
{"name":"not_sbtw_self_right","module":"Mathlib.Analysis.Convex.Between","initialProofState":"R : Type u_1\nV : Type u_2\nP : Type u_4\ninst✝³ : OrderedRing R\ninst✝² : AddCommGroup V\ninst✝¹ : Module R V\ninst✝ : AddTorsor V P\nx y : P\n⊢ Not (Sbtw R x y y)","decl":"@[simp]\ntheorem not_sbtw_self_right (x y : P) : ¬Sbtw R x y y :=\n  fun h => h.ne_right rfl\n\n"}
{"name":"Wbtw.left_ne_right_of_ne_left","module":"Mathlib.Analysis.Convex.Between","initialProofState":"R : Type u_1\nV : Type u_2\nP : Type u_4\ninst✝³ : OrderedRing R\ninst✝² : AddCommGroup V\ninst✝¹ : Module R V\ninst✝ : AddTorsor V P\nx y z : P\nh : Wbtw R x y z\nhne : Ne y x\n⊢ Ne x z","decl":"theorem Wbtw.left_ne_right_of_ne_left {x y z : P} (h : Wbtw R x y z) (hne : y ≠ x) : x ≠ z := by\n  rintro rfl\n  rw [wbtw_self_iff] at h\n  exact hne h\n\n"}
{"name":"Wbtw.left_ne_right_of_ne_right","module":"Mathlib.Analysis.Convex.Between","initialProofState":"R : Type u_1\nV : Type u_2\nP : Type u_4\ninst✝³ : OrderedRing R\ninst✝² : AddCommGroup V\ninst✝¹ : Module R V\ninst✝ : AddTorsor V P\nx y z : P\nh : Wbtw R x y z\nhne : Ne y z\n⊢ Ne x z","decl":"theorem Wbtw.left_ne_right_of_ne_right {x y z : P} (h : Wbtw R x y z) (hne : y ≠ z) : x ≠ z := by\n  rintro rfl\n  rw [wbtw_self_iff] at h\n  exact hne h\n\n"}
{"name":"Sbtw.left_ne_right","module":"Mathlib.Analysis.Convex.Between","initialProofState":"R : Type u_1\nV : Type u_2\nP : Type u_4\ninst✝³ : OrderedRing R\ninst✝² : AddCommGroup V\ninst✝¹ : Module R V\ninst✝ : AddTorsor V P\nx y z : P\nh : Sbtw R x y z\n⊢ Ne x z","decl":"theorem Sbtw.left_ne_right {x y z : P} (h : Sbtw R x y z) : x ≠ z :=\n  h.wbtw.left_ne_right_of_ne_left h.2.1\n\n"}
{"name":"sbtw_iff_mem_image_Ioo_and_ne","module":"Mathlib.Analysis.Convex.Between","initialProofState":"R : Type u_1\nV : Type u_2\nP : Type u_4\ninst✝⁴ : OrderedRing R\ninst✝³ : AddCommGroup V\ninst✝² : Module R V\ninst✝¹ : AddTorsor V P\ninst✝ : NoZeroSMulDivisors R V\nx y z : P\n⊢ Iff (Sbtw R x y z) (And (Membership.mem (Set.image (⇑(AffineMap.lineMap x z)) (Set.Ioo 0 1)) y) (Ne x z))","decl":"theorem sbtw_iff_mem_image_Ioo_and_ne [NoZeroSMulDivisors R V] {x y z : P} :\n    Sbtw R x y z ↔ y ∈ lineMap x z '' Set.Ioo (0 : R) 1 ∧ x ≠ z := by\n  refine ⟨fun h => ⟨h.mem_image_Ioo, h.left_ne_right⟩, fun h => ?_⟩\n  rcases h with ⟨⟨t, ht, rfl⟩, hxz⟩\n  refine ⟨⟨t, Set.mem_Icc_of_Ioo ht, rfl⟩, ?_⟩\n  rw [lineMap_apply, ← @vsub_ne_zero V, ← @vsub_ne_zero V _ _ _ _ z, vadd_vsub_assoc, vsub_self,\n    vadd_vsub_assoc, ← neg_vsub_eq_vsub_rev z x, ← @neg_one_smul R, ← add_smul, ← sub_eq_add_neg]\n  simp [smul_ne_zero, sub_eq_zero, ht.1.ne.symm, ht.2.ne, hxz.symm]\n\n"}
{"name":"not_sbtw_self","module":"Mathlib.Analysis.Convex.Between","initialProofState":"R : Type u_1\nV : Type u_2\nP : Type u_4\ninst✝³ : OrderedRing R\ninst✝² : AddCommGroup V\ninst✝¹ : Module R V\ninst✝ : AddTorsor V P\nx y : P\n⊢ Not (Sbtw R x y x)","decl":"@[simp]\ntheorem not_sbtw_self (x y : P) : ¬Sbtw R x y x :=\n  fun h => h.left_ne_right rfl\n\n"}
{"name":"wbtw_swap_left_iff","module":"Mathlib.Analysis.Convex.Between","initialProofState":"R : Type u_1\nV : Type u_2\nP : Type u_4\ninst✝⁴ : OrderedRing R\ninst✝³ : AddCommGroup V\ninst✝² : Module R V\ninst✝¹ : AddTorsor V P\ninst✝ : NoZeroSMulDivisors R V\nx y z : P\n⊢ Iff (And (Wbtw R x y z) (Wbtw R y x z)) (Eq x y)","decl":"theorem wbtw_swap_left_iff [NoZeroSMulDivisors R V] {x y : P} (z : P) :\n    Wbtw R x y z ∧ Wbtw R y x z ↔ x = y := by\n  constructor\n  · rintro ⟨hxyz, hyxz⟩\n    rcases hxyz with ⟨ty, hty, rfl⟩\n    rcases hyxz with ⟨tx, htx, hx⟩\n    rw [lineMap_apply, lineMap_apply, ← add_vadd] at hx\n    rw [← @vsub_eq_zero_iff_eq V, vadd_vsub, vsub_vadd_eq_vsub_sub, smul_sub, smul_smul, ← sub_smul,\n      ← add_smul, smul_eq_zero] at hx\n    rcases hx with (h | h)\n    · nth_rw 1 [← mul_one tx] at h\n      rw [← mul_sub, add_eq_zero_iff_neg_eq] at h\n      have h' : ty = 0 := by\n        refine le_antisymm ?_ hty.1\n        rw [← h, Left.neg_nonpos_iff]\n        exact mul_nonneg htx.1 (sub_nonneg.2 hty.2)\n      simp [h']\n    · rw [vsub_eq_zero_iff_eq] at h\n      rw [h, lineMap_same_apply]\n  · rintro rfl\n    exact ⟨wbtw_self_left _ _ _, wbtw_self_left _ _ _⟩\n\n"}
{"name":"wbtw_swap_right_iff","module":"Mathlib.Analysis.Convex.Between","initialProofState":"R : Type u_1\nV : Type u_2\nP : Type u_4\ninst✝⁴ : OrderedRing R\ninst✝³ : AddCommGroup V\ninst✝² : Module R V\ninst✝¹ : AddTorsor V P\ninst✝ : NoZeroSMulDivisors R V\nx y z : P\n⊢ Iff (And (Wbtw R x y z) (Wbtw R x z y)) (Eq y z)","decl":"theorem wbtw_swap_right_iff [NoZeroSMulDivisors R V] (x : P) {y z : P} :\n    Wbtw R x y z ∧ Wbtw R x z y ↔ y = z := by\n  rw [wbtw_comm, wbtw_comm (z := y), eq_comm]\n  exact wbtw_swap_left_iff R x\n\n"}
{"name":"wbtw_rotate_iff","module":"Mathlib.Analysis.Convex.Between","initialProofState":"R : Type u_1\nV : Type u_2\nP : Type u_4\ninst✝⁴ : OrderedRing R\ninst✝³ : AddCommGroup V\ninst✝² : Module R V\ninst✝¹ : AddTorsor V P\ninst✝ : NoZeroSMulDivisors R V\nx y z : P\n⊢ Iff (And (Wbtw R x y z) (Wbtw R z x y)) (Eq x y)","decl":"theorem wbtw_rotate_iff [NoZeroSMulDivisors R V] (x : P) {y z : P} :\n    Wbtw R x y z ∧ Wbtw R z x y ↔ x = y := by rw [wbtw_comm, wbtw_swap_right_iff, eq_comm]\n\n"}
{"name":"Wbtw.swap_left_iff","module":"Mathlib.Analysis.Convex.Between","initialProofState":"R : Type u_1\nV : Type u_2\nP : Type u_4\ninst✝⁴ : OrderedRing R\ninst✝³ : AddCommGroup V\ninst✝² : Module R V\ninst✝¹ : AddTorsor V P\ninst✝ : NoZeroSMulDivisors R V\nx y z : P\nh : Wbtw R x y z\n⊢ Iff (Wbtw R y x z) (Eq x y)","decl":"theorem Wbtw.swap_left_iff [NoZeroSMulDivisors R V] {x y z : P} (h : Wbtw R x y z) :\n    Wbtw R y x z ↔ x = y := by rw [← wbtw_swap_left_iff R z, and_iff_right h]\n\n"}
{"name":"Wbtw.swap_right_iff","module":"Mathlib.Analysis.Convex.Between","initialProofState":"R : Type u_1\nV : Type u_2\nP : Type u_4\ninst✝⁴ : OrderedRing R\ninst✝³ : AddCommGroup V\ninst✝² : Module R V\ninst✝¹ : AddTorsor V P\ninst✝ : NoZeroSMulDivisors R V\nx y z : P\nh : Wbtw R x y z\n⊢ Iff (Wbtw R x z y) (Eq y z)","decl":"theorem Wbtw.swap_right_iff [NoZeroSMulDivisors R V] {x y z : P} (h : Wbtw R x y z) :\n    Wbtw R x z y ↔ y = z := by rw [← wbtw_swap_right_iff R x, and_iff_right h]\n\n"}
{"name":"Wbtw.rotate_iff","module":"Mathlib.Analysis.Convex.Between","initialProofState":"R : Type u_1\nV : Type u_2\nP : Type u_4\ninst✝⁴ : OrderedRing R\ninst✝³ : AddCommGroup V\ninst✝² : Module R V\ninst✝¹ : AddTorsor V P\ninst✝ : NoZeroSMulDivisors R V\nx y z : P\nh : Wbtw R x y z\n⊢ Iff (Wbtw R z x y) (Eq x y)","decl":"theorem Wbtw.rotate_iff [NoZeroSMulDivisors R V] {x y z : P} (h : Wbtw R x y z) :\n    Wbtw R z x y ↔ x = y := by rw [← wbtw_rotate_iff R x, and_iff_right h]\n\n"}
{"name":"Sbtw.not_swap_left","module":"Mathlib.Analysis.Convex.Between","initialProofState":"R : Type u_1\nV : Type u_2\nP : Type u_4\ninst✝⁴ : OrderedRing R\ninst✝³ : AddCommGroup V\ninst✝² : Module R V\ninst✝¹ : AddTorsor V P\ninst✝ : NoZeroSMulDivisors R V\nx y z : P\nh : Sbtw R x y z\n⊢ Not (Wbtw R y x z)","decl":"theorem Sbtw.not_swap_left [NoZeroSMulDivisors R V] {x y z : P} (h : Sbtw R x y z) :\n    ¬Wbtw R y x z := fun hs => h.left_ne (h.wbtw.swap_left_iff.1 hs)\n\n"}
{"name":"Sbtw.not_swap_right","module":"Mathlib.Analysis.Convex.Between","initialProofState":"R : Type u_1\nV : Type u_2\nP : Type u_4\ninst✝⁴ : OrderedRing R\ninst✝³ : AddCommGroup V\ninst✝² : Module R V\ninst✝¹ : AddTorsor V P\ninst✝ : NoZeroSMulDivisors R V\nx y z : P\nh : Sbtw R x y z\n⊢ Not (Wbtw R x z y)","decl":"theorem Sbtw.not_swap_right [NoZeroSMulDivisors R V] {x y z : P} (h : Sbtw R x y z) :\n    ¬Wbtw R x z y := fun hs => h.ne_right (h.wbtw.swap_right_iff.1 hs)\n\n"}
{"name":"Sbtw.not_rotate","module":"Mathlib.Analysis.Convex.Between","initialProofState":"R : Type u_1\nV : Type u_2\nP : Type u_4\ninst✝⁴ : OrderedRing R\ninst✝³ : AddCommGroup V\ninst✝² : Module R V\ninst✝¹ : AddTorsor V P\ninst✝ : NoZeroSMulDivisors R V\nx y z : P\nh : Sbtw R x y z\n⊢ Not (Wbtw R z x y)","decl":"theorem Sbtw.not_rotate [NoZeroSMulDivisors R V] {x y z : P} (h : Sbtw R x y z) : ¬Wbtw R z x y :=\n  fun hs => h.left_ne (h.wbtw.rotate_iff.1 hs)\n\n"}
{"name":"wbtw_lineMap_iff","module":"Mathlib.Analysis.Convex.Between","initialProofState":"R : Type u_1\nV : Type u_2\nP : Type u_4\ninst✝⁴ : OrderedRing R\ninst✝³ : AddCommGroup V\ninst✝² : Module R V\ninst✝¹ : AddTorsor V P\ninst✝ : NoZeroSMulDivisors R V\nx y : P\nr : R\n⊢ Iff (Wbtw R x ((AffineMap.lineMap x y) r) y) (Or (Eq x y) (Membership.mem (Set.Icc 0 1) r))","decl":"@[simp]\ntheorem wbtw_lineMap_iff [NoZeroSMulDivisors R V] {x y : P} {r : R} :\n    Wbtw R x (lineMap x y r) y ↔ x = y ∨ r ∈ Set.Icc (0 : R) 1 := by\n  by_cases hxy : x = y\n  · rw [hxy, lineMap_same_apply]\n    simp\n  rw [or_iff_right hxy, Wbtw, affineSegment, (lineMap_injective R hxy).mem_set_image]\n\n"}
{"name":"sbtw_lineMap_iff","module":"Mathlib.Analysis.Convex.Between","initialProofState":"R : Type u_1\nV : Type u_2\nP : Type u_4\ninst✝⁴ : OrderedRing R\ninst✝³ : AddCommGroup V\ninst✝² : Module R V\ninst✝¹ : AddTorsor V P\ninst✝ : NoZeroSMulDivisors R V\nx y : P\nr : R\n⊢ Iff (Sbtw R x ((AffineMap.lineMap x y) r) y) (And (Ne x y) (Membership.mem (Set.Ioo 0 1) r))","decl":"@[simp]\ntheorem sbtw_lineMap_iff [NoZeroSMulDivisors R V] {x y : P} {r : R} :\n    Sbtw R x (lineMap x y r) y ↔ x ≠ y ∧ r ∈ Set.Ioo (0 : R) 1 := by\n  rw [sbtw_iff_mem_image_Ioo_and_ne, and_comm, and_congr_right]\n  intro hxy\n  rw [(lineMap_injective R hxy).mem_set_image]\n\n"}
{"name":"wbtw_mul_sub_add_iff","module":"Mathlib.Analysis.Convex.Between","initialProofState":"R : Type u_1\ninst✝¹ : OrderedRing R\ninst✝ : NoZeroDivisors R\nx y r : R\n⊢ Iff (Wbtw R x (HAdd.hAdd (HMul.hMul r (HSub.hSub y x)) x) y) (Or (Eq x y) (Membership.mem (Set.Icc 0 1) r))","decl":"@[simp]\ntheorem wbtw_mul_sub_add_iff [NoZeroDivisors R] {x y r : R} :\n    Wbtw R x (r * (y - x) + x) y ↔ x = y ∨ r ∈ Set.Icc (0 : R) 1 :=\n  wbtw_lineMap_iff\n\n"}
{"name":"sbtw_mul_sub_add_iff","module":"Mathlib.Analysis.Convex.Between","initialProofState":"R : Type u_1\ninst✝¹ : OrderedRing R\ninst✝ : NoZeroDivisors R\nx y r : R\n⊢ Iff (Sbtw R x (HAdd.hAdd (HMul.hMul r (HSub.hSub y x)) x) y) (And (Ne x y) (Membership.mem (Set.Ioo 0 1) r))","decl":"@[simp]\ntheorem sbtw_mul_sub_add_iff [NoZeroDivisors R] {x y r : R} :\n    Sbtw R x (r * (y - x) + x) y ↔ x ≠ y ∧ r ∈ Set.Ioo (0 : R) 1 :=\n  sbtw_lineMap_iff\n\n"}
{"name":"wbtw_zero_one_iff","module":"Mathlib.Analysis.Convex.Between","initialProofState":"R : Type u_1\ninst✝ : OrderedRing R\nx : R\n⊢ Iff (Wbtw R 0 x 1) (Membership.mem (Set.Icc 0 1) x)","decl":"@[simp]\ntheorem wbtw_zero_one_iff {x : R} : Wbtw R 0 x 1 ↔ x ∈ Set.Icc (0 : R) 1 := by\n  rw [Wbtw, affineSegment, Set.mem_image]\n  simp_rw [lineMap_apply_ring]\n  simp\n\n"}
{"name":"wbtw_one_zero_iff","module":"Mathlib.Analysis.Convex.Between","initialProofState":"R : Type u_1\ninst✝ : OrderedRing R\nx : R\n⊢ Iff (Wbtw R 1 x 0) (Membership.mem (Set.Icc 0 1) x)","decl":"@[simp]\ntheorem wbtw_one_zero_iff {x : R} : Wbtw R 1 x 0 ↔ x ∈ Set.Icc (0 : R) 1 := by\n  rw [wbtw_comm, wbtw_zero_one_iff]\n\n"}
{"name":"sbtw_zero_one_iff","module":"Mathlib.Analysis.Convex.Between","initialProofState":"R : Type u_1\ninst✝ : OrderedRing R\nx : R\n⊢ Iff (Sbtw R 0 x 1) (Membership.mem (Set.Ioo 0 1) x)","decl":"@[simp]\ntheorem sbtw_zero_one_iff {x : R} : Sbtw R 0 x 1 ↔ x ∈ Set.Ioo (0 : R) 1 := by\n  rw [Sbtw, wbtw_zero_one_iff, Set.mem_Icc, Set.mem_Ioo]\n  exact\n    ⟨fun h => ⟨h.1.1.lt_of_ne (Ne.symm h.2.1), h.1.2.lt_of_ne h.2.2⟩, fun h =>\n      ⟨⟨h.1.le, h.2.le⟩, h.1.ne', h.2.ne⟩⟩\n\n"}
{"name":"sbtw_one_zero_iff","module":"Mathlib.Analysis.Convex.Between","initialProofState":"R : Type u_1\ninst✝ : OrderedRing R\nx : R\n⊢ Iff (Sbtw R 1 x 0) (Membership.mem (Set.Ioo 0 1) x)","decl":"@[simp]\ntheorem sbtw_one_zero_iff {x : R} : Sbtw R 1 x 0 ↔ x ∈ Set.Ioo (0 : R) 1 := by\n  rw [sbtw_comm, sbtw_zero_one_iff]\n\n"}
{"name":"Wbtw.trans_left","module":"Mathlib.Analysis.Convex.Between","initialProofState":"R : Type u_1\nV : Type u_2\nP : Type u_4\ninst✝³ : OrderedRing R\ninst✝² : AddCommGroup V\ninst✝¹ : Module R V\ninst✝ : AddTorsor V P\nw x y z : P\nh₁ : Wbtw R w y z\nh₂ : Wbtw R w x y\n⊢ Wbtw R w x z","decl":"theorem Wbtw.trans_left {w x y z : P} (h₁ : Wbtw R w y z) (h₂ : Wbtw R w x y) : Wbtw R w x z := by\n  rcases h₁ with ⟨t₁, ht₁, rfl⟩\n  rcases h₂ with ⟨t₂, ht₂, rfl⟩\n  refine ⟨t₂ * t₁, ⟨mul_nonneg ht₂.1 ht₁.1, mul_le_one₀ ht₂.2 ht₁.1 ht₁.2⟩, ?_⟩\n  rw [lineMap_apply, lineMap_apply, lineMap_vsub_left, smul_smul]\n\n"}
{"name":"Wbtw.trans_right","module":"Mathlib.Analysis.Convex.Between","initialProofState":"R : Type u_1\nV : Type u_2\nP : Type u_4\ninst✝³ : OrderedRing R\ninst✝² : AddCommGroup V\ninst✝¹ : Module R V\ninst✝ : AddTorsor V P\nw x y z : P\nh₁ : Wbtw R w x z\nh₂ : Wbtw R x y z\n⊢ Wbtw R w y z","decl":"theorem Wbtw.trans_right {w x y z : P} (h₁ : Wbtw R w x z) (h₂ : Wbtw R x y z) : Wbtw R w y z := by\n  rw [wbtw_comm] at *\n  exact h₁.trans_left h₂\n\n"}
{"name":"Wbtw.trans_sbtw_left","module":"Mathlib.Analysis.Convex.Between","initialProofState":"R : Type u_1\nV : Type u_2\nP : Type u_4\ninst✝⁴ : OrderedRing R\ninst✝³ : AddCommGroup V\ninst✝² : Module R V\ninst✝¹ : AddTorsor V P\ninst✝ : NoZeroSMulDivisors R V\nw x y z : P\nh₁ : Wbtw R w y z\nh₂ : Sbtw R w x y\n⊢ Sbtw R w x z","decl":"theorem Wbtw.trans_sbtw_left [NoZeroSMulDivisors R V] {w x y z : P} (h₁ : Wbtw R w y z)\n    (h₂ : Sbtw R w x y) : Sbtw R w x z := by\n  refine ⟨h₁.trans_left h₂.wbtw, h₂.ne_left, ?_⟩\n  rintro rfl\n  exact h₂.right_ne ((wbtw_swap_right_iff R w).1 ⟨h₁, h₂.wbtw⟩)\n\n"}
{"name":"Wbtw.trans_sbtw_right","module":"Mathlib.Analysis.Convex.Between","initialProofState":"R : Type u_1\nV : Type u_2\nP : Type u_4\ninst✝⁴ : OrderedRing R\ninst✝³ : AddCommGroup V\ninst✝² : Module R V\ninst✝¹ : AddTorsor V P\ninst✝ : NoZeroSMulDivisors R V\nw x y z : P\nh₁ : Wbtw R w x z\nh₂ : Sbtw R x y z\n⊢ Sbtw R w y z","decl":"theorem Wbtw.trans_sbtw_right [NoZeroSMulDivisors R V] {w x y z : P} (h₁ : Wbtw R w x z)\n    (h₂ : Sbtw R x y z) : Sbtw R w y z := by\n  rw [wbtw_comm] at *\n  rw [sbtw_comm] at *\n  exact h₁.trans_sbtw_left h₂\n\n"}
{"name":"Sbtw.trans_left","module":"Mathlib.Analysis.Convex.Between","initialProofState":"R : Type u_1\nV : Type u_2\nP : Type u_4\ninst✝⁴ : OrderedRing R\ninst✝³ : AddCommGroup V\ninst✝² : Module R V\ninst✝¹ : AddTorsor V P\ninst✝ : NoZeroSMulDivisors R V\nw x y z : P\nh₁ : Sbtw R w y z\nh₂ : Sbtw R w x y\n⊢ Sbtw R w x z","decl":"theorem Sbtw.trans_left [NoZeroSMulDivisors R V] {w x y z : P} (h₁ : Sbtw R w y z)\n    (h₂ : Sbtw R w x y) : Sbtw R w x z :=\n  h₁.wbtw.trans_sbtw_left h₂\n\n"}
{"name":"Sbtw.trans_right","module":"Mathlib.Analysis.Convex.Between","initialProofState":"R : Type u_1\nV : Type u_2\nP : Type u_4\ninst✝⁴ : OrderedRing R\ninst✝³ : AddCommGroup V\ninst✝² : Module R V\ninst✝¹ : AddTorsor V P\ninst✝ : NoZeroSMulDivisors R V\nw x y z : P\nh₁ : Sbtw R w x z\nh₂ : Sbtw R x y z\n⊢ Sbtw R w y z","decl":"theorem Sbtw.trans_right [NoZeroSMulDivisors R V] {w x y z : P} (h₁ : Sbtw R w x z)\n    (h₂ : Sbtw R x y z) : Sbtw R w y z :=\n  h₁.wbtw.trans_sbtw_right h₂\n\n"}
{"name":"Wbtw.trans_left_ne","module":"Mathlib.Analysis.Convex.Between","initialProofState":"R : Type u_1\nV : Type u_2\nP : Type u_4\ninst✝⁴ : OrderedRing R\ninst✝³ : AddCommGroup V\ninst✝² : Module R V\ninst✝¹ : AddTorsor V P\ninst✝ : NoZeroSMulDivisors R V\nw x y z : P\nh₁ : Wbtw R w y z\nh₂ : Wbtw R w x y\nh : Ne y z\n⊢ Ne x z","decl":"theorem Wbtw.trans_left_ne [NoZeroSMulDivisors R V] {w x y z : P} (h₁ : Wbtw R w y z)\n    (h₂ : Wbtw R w x y) (h : y ≠ z) : x ≠ z := by\n  rintro rfl\n  exact h (h₁.swap_right_iff.1 h₂)\n\n"}
{"name":"Wbtw.trans_right_ne","module":"Mathlib.Analysis.Convex.Between","initialProofState":"R : Type u_1\nV : Type u_2\nP : Type u_4\ninst✝⁴ : OrderedRing R\ninst✝³ : AddCommGroup V\ninst✝² : Module R V\ninst✝¹ : AddTorsor V P\ninst✝ : NoZeroSMulDivisors R V\nw x y z : P\nh₁ : Wbtw R w x z\nh₂ : Wbtw R x y z\nh : Ne w x\n⊢ Ne w y","decl":"theorem Wbtw.trans_right_ne [NoZeroSMulDivisors R V] {w x y z : P} (h₁ : Wbtw R w x z)\n    (h₂ : Wbtw R x y z) (h : w ≠ x) : w ≠ y := by\n  rintro rfl\n  exact h (h₁.swap_left_iff.1 h₂)\n\n"}
{"name":"Sbtw.trans_wbtw_left_ne","module":"Mathlib.Analysis.Convex.Between","initialProofState":"R : Type u_1\nV : Type u_2\nP : Type u_4\ninst✝⁴ : OrderedRing R\ninst✝³ : AddCommGroup V\ninst✝² : Module R V\ninst✝¹ : AddTorsor V P\ninst✝ : NoZeroSMulDivisors R V\nw x y z : P\nh₁ : Sbtw R w y z\nh₂ : Wbtw R w x y\n⊢ Ne x z","decl":"theorem Sbtw.trans_wbtw_left_ne [NoZeroSMulDivisors R V] {w x y z : P} (h₁ : Sbtw R w y z)\n    (h₂ : Wbtw R w x y) : x ≠ z :=\n  h₁.wbtw.trans_left_ne h₂ h₁.ne_right\n\n"}
{"name":"Sbtw.trans_wbtw_right_ne","module":"Mathlib.Analysis.Convex.Between","initialProofState":"R : Type u_1\nV : Type u_2\nP : Type u_4\ninst✝⁴ : OrderedRing R\ninst✝³ : AddCommGroup V\ninst✝² : Module R V\ninst✝¹ : AddTorsor V P\ninst✝ : NoZeroSMulDivisors R V\nw x y z : P\nh₁ : Sbtw R w x z\nh₂ : Wbtw R x y z\n⊢ Ne w y","decl":"theorem Sbtw.trans_wbtw_right_ne [NoZeroSMulDivisors R V] {w x y z : P} (h₁ : Sbtw R w x z)\n    (h₂ : Wbtw R x y z) : w ≠ y :=\n  h₁.wbtw.trans_right_ne h₂ h₁.left_ne\n\n"}
{"name":"Sbtw.affineCombination_of_mem_affineSpan_pair","module":"Mathlib.Analysis.Convex.Between","initialProofState":"R : Type u_1\nV : Type u_2\nP : Type u_4\ninst✝⁵ : OrderedRing R\ninst✝⁴ : AddCommGroup V\ninst✝³ : Module R V\ninst✝² : AddTorsor V P\ninst✝¹ : NoZeroDivisors R\ninst✝ : NoZeroSMulDivisors R V\nι : Type u_6\np : ι → P\nha : AffineIndependent R p\nw w₁ w₂ : ι → R\ns : Finset ι\nhw : Eq (s.sum fun i => w i) 1\nhw₁ : Eq (s.sum fun i => w₁ i) 1\nhw₂ : Eq (s.sum fun i => w₂ i) 1\nh : Membership.mem (affineSpan R (Insert.insert ((Finset.affineCombination R s p) w₁) (Singleton.singleton ((Finset.affineCombination R s p) w₂)))) ((Finset.affineCombination R s p) w)\ni : ι\nhis : Membership.mem s i\nhs : Sbtw R (w₁ i) (w i) (w₂ i)\n⊢ Sbtw R ((Finset.affineCombination R s p) w₁) ((Finset.affineCombination R s p) w) ((Finset.affineCombination R s p) w₂)","decl":"theorem Sbtw.affineCombination_of_mem_affineSpan_pair [NoZeroDivisors R] [NoZeroSMulDivisors R V]\n    {ι : Type*} {p : ι → P} (ha : AffineIndependent R p) {w w₁ w₂ : ι → R} {s : Finset ι}\n    (hw : ∑ i ∈ s, w i = 1) (hw₁ : ∑ i ∈ s, w₁ i = 1) (hw₂ : ∑ i ∈ s, w₂ i = 1)\n    (h : s.affineCombination R p w ∈\n      line[R, s.affineCombination R p w₁, s.affineCombination R p w₂])\n    {i : ι} (his : i ∈ s) (hs : Sbtw R (w₁ i) (w i) (w₂ i)) :\n    Sbtw R (s.affineCombination R p w₁) (s.affineCombination R p w)\n      (s.affineCombination R p w₂) := by\n  rw [affineCombination_mem_affineSpan_pair ha hw hw₁ hw₂] at h\n  rcases h with ⟨r, hr⟩\n  rw [hr i his, sbtw_mul_sub_add_iff] at hs\n  change ∀ i ∈ s, w i = (r • (w₂ - w₁) + w₁) i at hr\n  rw [s.affineCombination_congr hr fun _ _ => rfl]\n  rw [← s.weightedVSub_vadd_affineCombination, s.weightedVSub_const_smul,\n    ← s.affineCombination_vsub, ← lineMap_apply, sbtw_lineMap_iff, and_iff_left hs.2,\n    ← @vsub_ne_zero V, s.affineCombination_vsub]\n  intro hz\n  have hw₁w₂ : (∑ i ∈ s, (w₁ - w₂) i) = 0 := by\n    simp_rw [Pi.sub_apply, Finset.sum_sub_distrib, hw₁, hw₂, sub_self]\n  refine hs.1 ?_\n  have ha' := ha s (w₁ - w₂) hw₁w₂ hz i his\n  rwa [Pi.sub_apply, sub_eq_zero] at ha'\n\n"}
{"name":"Wbtw.sameRay_vsub","module":"Mathlib.Analysis.Convex.Between","initialProofState":"R : Type u_1\nV : Type u_2\nP : Type u_4\ninst✝³ : StrictOrderedCommRing R\ninst✝² : AddCommGroup V\ninst✝¹ : Module R V\ninst✝ : AddTorsor V P\nx y z : P\nh : Wbtw R x y z\n⊢ SameRay R (VSub.vsub y x) (VSub.vsub z y)","decl":"theorem Wbtw.sameRay_vsub {x y z : P} (h : Wbtw R x y z) : SameRay R (y -ᵥ x) (z -ᵥ y) := by\n  rcases h with ⟨t, ⟨ht0, ht1⟩, rfl⟩\n  simp_rw [lineMap_apply]\n  rcases ht0.lt_or_eq with (ht0' | rfl); swap; · simp\n  rcases ht1.lt_or_eq with (ht1' | rfl); swap; · simp\n  refine Or.inr (Or.inr ⟨1 - t, t, sub_pos.2 ht1', ht0', ?_⟩)\n  simp only [vadd_vsub, smul_smul, vsub_vadd_eq_vsub_sub, smul_sub, ← sub_smul]\n  ring_nf\n\n"}
{"name":"Wbtw.sameRay_vsub_left","module":"Mathlib.Analysis.Convex.Between","initialProofState":"R : Type u_1\nV : Type u_2\nP : Type u_4\ninst✝³ : StrictOrderedCommRing R\ninst✝² : AddCommGroup V\ninst✝¹ : Module R V\ninst✝ : AddTorsor V P\nx y z : P\nh : Wbtw R x y z\n⊢ SameRay R (VSub.vsub y x) (VSub.vsub z x)","decl":"theorem Wbtw.sameRay_vsub_left {x y z : P} (h : Wbtw R x y z) : SameRay R (y -ᵥ x) (z -ᵥ x) := by\n  rcases h with ⟨t, ⟨ht0, _⟩, rfl⟩\n  simpa [lineMap_apply] using SameRay.sameRay_nonneg_smul_left (z -ᵥ x) ht0\n\n"}
{"name":"Wbtw.sameRay_vsub_right","module":"Mathlib.Analysis.Convex.Between","initialProofState":"R : Type u_1\nV : Type u_2\nP : Type u_4\ninst✝³ : StrictOrderedCommRing R\ninst✝² : AddCommGroup V\ninst✝¹ : Module R V\ninst✝ : AddTorsor V P\nx y z : P\nh : Wbtw R x y z\n⊢ SameRay R (VSub.vsub z x) (VSub.vsub z y)","decl":"theorem Wbtw.sameRay_vsub_right {x y z : P} (h : Wbtw R x y z) : SameRay R (z -ᵥ x) (z -ᵥ y) := by\n  rcases h with ⟨t, ⟨_, ht1⟩, rfl⟩\n  simpa [lineMap_apply, vsub_vadd_eq_vsub_sub, sub_smul] using\n    SameRay.sameRay_nonneg_smul_right (z -ᵥ x) (sub_nonneg.2 ht1)\n\n"}
{"name":"sbtw_of_sbtw_of_sbtw_of_mem_affineSpan_pair","module":"Mathlib.Analysis.Convex.Between","initialProofState":"R : Type u_1\nV : Type u_2\nP : Type u_4\ninst✝⁴ : LinearOrderedRing R\ninst✝³ : AddCommGroup V\ninst✝² : Module R V\ninst✝¹ : AddTorsor V P\ninst✝ : NoZeroSMulDivisors R V\nt : Affine.Triangle R P\ni₁ i₂ i₃ : Fin 3\nh₁₂ : Ne i₁ i₂\np₁ p₂ p : P\nh₁ : Sbtw R (t.points i₂) p₁ (t.points i₃)\nh₂ : Sbtw R (t.points i₁) p₂ (t.points i₃)\nh₁' : Membership.mem (affineSpan R (Insert.insert (t.points i₁) (Singleton.singleton p₁))) p\nh₂' : Membership.mem (affineSpan R (Insert.insert (t.points i₂) (Singleton.singleton p₂))) p\n⊢ Sbtw R (t.points i₁) p p₁","decl":"/-- Suppose lines from two vertices of a triangle to interior points of the opposite side meet at\n`p`. Then `p` lies in the interior of the first (and by symmetry the other) segment from a\nvertex to the point on the opposite side. -/\ntheorem sbtw_of_sbtw_of_sbtw_of_mem_affineSpan_pair [NoZeroSMulDivisors R V]\n    {t : Affine.Triangle R P} {i₁ i₂ i₃ : Fin 3} (h₁₂ : i₁ ≠ i₂) {p₁ p₂ p : P}\n    (h₁ : Sbtw R (t.points i₂) p₁ (t.points i₃)) (h₂ : Sbtw R (t.points i₁) p₂ (t.points i₃))\n    (h₁' : p ∈ line[R, t.points i₁, p₁]) (h₂' : p ∈ line[R, t.points i₂, p₂]) :\n    Sbtw R (t.points i₁) p p₁ := by\n  -- Should not be needed; see comments on local instances in `Data.Sign`.\n  letI : DecidableRel ((· < ·) : R → R → Prop) := LinearOrderedRing.decidableLT\n  have h₁₃ : i₁ ≠ i₃ := by\n    rintro rfl\n    simp at h₂\n  have h₂₃ : i₂ ≠ i₃ := by\n    rintro rfl\n    simp at h₁\n  have h3 : ∀ i : Fin 3, i = i₁ ∨ i = i₂ ∨ i = i₃ := by omega\n  have hu : (Finset.univ : Finset (Fin 3)) = {i₁, i₂, i₃} := by\n    clear h₁ h₂ h₁' h₂'\n    -- Porting note: Originally `decide!`\n    revert i₁ i₂ i₃; decide\n  have hp : p ∈ affineSpan R (Set.range t.points) := by\n    have hle : line[R, t.points i₁, p₁] ≤ affineSpan R (Set.range t.points) := by\n      refine affineSpan_pair_le_of_mem_of_mem (mem_affineSpan R (Set.mem_range_self _)) ?_\n      have hle : line[R, t.points i₂, t.points i₃] ≤ affineSpan R (Set.range t.points) := by\n        refine affineSpan_mono R ?_\n        simp [Set.insert_subset_iff]\n      rw [AffineSubspace.le_def'] at hle\n      exact hle _ h₁.wbtw.mem_affineSpan\n    rw [AffineSubspace.le_def'] at hle\n    exact hle _ h₁'\n  have h₁i := h₁.mem_image_Ioo\n  have h₂i := h₂.mem_image_Ioo\n  rw [Set.mem_image] at h₁i h₂i\n  rcases h₁i with ⟨r₁, ⟨hr₁0, hr₁1⟩, rfl⟩\n  rcases h₂i with ⟨r₂, ⟨hr₂0, hr₂1⟩, rfl⟩\n  rcases eq_affineCombination_of_mem_affineSpan_of_fintype hp with ⟨w, hw, rfl⟩\n  have h₁s :=\n    sign_eq_of_affineCombination_mem_affineSpan_single_lineMap t.independent hw (Finset.mem_univ _)\n      (Finset.mem_univ _) (Finset.mem_univ _) h₁₂ h₁₃ h₂₃ hr₁0 hr₁1 h₁'\n  have h₂s :=\n    sign_eq_of_affineCombination_mem_affineSpan_single_lineMap t.independent hw (Finset.mem_univ _)\n      (Finset.mem_univ _) (Finset.mem_univ _) h₁₂.symm h₂₃ h₁₃ hr₂0 hr₂1 h₂'\n  rw [← Finset.univ.affineCombination_affineCombinationSingleWeights R t.points\n      (Finset.mem_univ i₁),\n    ← Finset.univ.affineCombination_affineCombinationLineMapWeights t.points (Finset.mem_univ _)\n      (Finset.mem_univ _)] at h₁' ⊢\n  refine\n    Sbtw.affineCombination_of_mem_affineSpan_pair t.independent hw\n      (Finset.univ.sum_affineCombinationSingleWeights R (Finset.mem_univ _))\n      (Finset.univ.sum_affineCombinationLineMapWeights (Finset.mem_univ _) (Finset.mem_univ _) _)\n      h₁' (Finset.mem_univ i₁) ?_\n  rw [Finset.affineCombinationSingleWeights_apply_self,\n    Finset.affineCombinationLineMapWeights_apply_of_ne h₁₂ h₁₃, sbtw_one_zero_iff]\n  have hs : ∀ i : Fin 3, SignType.sign (w i) = SignType.sign (w i₃) := by\n    intro i\n    rcases h3 i with (rfl | rfl | rfl)\n    · exact h₂s\n    · exact h₁s\n    · rfl\n  have hss : SignType.sign (∑ i, w i) = 1 := by simp [hw]\n  have hs' := sign_sum Finset.univ_nonempty (SignType.sign (w i₃)) fun i _ => hs i\n  rw [hs'] at hss\n  simp_rw [hss, sign_eq_one_iff] at hs\n  refine ⟨hs i₁, ?_⟩\n  rw [hu] at hw\n  rw [Finset.sum_insert, Finset.sum_insert, Finset.sum_singleton] at hw\n  · by_contra hle\n    rw [not_lt] at hle\n    exact (hle.trans_lt (lt_add_of_pos_right _ (Left.add_pos (hs i₂) (hs i₃)))).ne' hw\n  · simpa using h₂₃\n  · simpa [not_or] using ⟨h₁₂, h₁₃⟩\n\n"}
{"name":"wbtw_iff_left_eq_or_right_mem_image_Ici","module":"Mathlib.Analysis.Convex.Between","initialProofState":"R : Type u_1\nV : Type u_2\nP : Type u_4\ninst✝³ : LinearOrderedField R\ninst✝² : AddCommGroup V\ninst✝¹ : Module R V\ninst✝ : AddTorsor V P\nx y z : P\n⊢ Iff (Wbtw R x y z) (Or (Eq x y) (Membership.mem (Set.image (⇑(AffineMap.lineMap x y)) (Set.Ici 1)) z))","decl":"theorem wbtw_iff_left_eq_or_right_mem_image_Ici {x y z : P} :\n    Wbtw R x y z ↔ x = y ∨ z ∈ lineMap x y '' Set.Ici (1 : R) := by\n  refine ⟨fun h => ?_, fun h => ?_⟩\n  · rcases h with ⟨r, ⟨hr0, hr1⟩, rfl⟩\n    rcases hr0.lt_or_eq with (hr0' | rfl)\n    · rw [Set.mem_image]\n      refine .inr ⟨r⁻¹, (one_le_inv₀ hr0').2 hr1, ?_⟩\n      simp only [lineMap_apply, smul_smul, vadd_vsub]\n      rw [inv_mul_cancel₀ hr0'.ne', one_smul, vsub_vadd]\n    · simp\n  · rcases h with (rfl | ⟨r, ⟨hr, rfl⟩⟩)\n    · exact wbtw_self_left _ _ _\n    · rw [Set.mem_Ici] at hr\n      refine ⟨r⁻¹, ⟨inv_nonneg.2 (zero_le_one.trans hr), inv_le_one_of_one_le₀ hr⟩, ?_⟩\n      simp only [lineMap_apply, smul_smul, vadd_vsub]\n      rw [inv_mul_cancel₀ (one_pos.trans_le hr).ne', one_smul, vsub_vadd]\n\n"}
{"name":"Wbtw.right_mem_image_Ici_of_left_ne","module":"Mathlib.Analysis.Convex.Between","initialProofState":"R : Type u_1\nV : Type u_2\nP : Type u_4\ninst✝³ : LinearOrderedField R\ninst✝² : AddCommGroup V\ninst✝¹ : Module R V\ninst✝ : AddTorsor V P\nx y z : P\nh : Wbtw R x y z\nhne : Ne x y\n⊢ Membership.mem (Set.image (⇑(AffineMap.lineMap x y)) (Set.Ici 1)) z","decl":"theorem Wbtw.right_mem_image_Ici_of_left_ne {x y z : P} (h : Wbtw R x y z) (hne : x ≠ y) :\n    z ∈ lineMap x y '' Set.Ici (1 : R) :=\n  (wbtw_iff_left_eq_or_right_mem_image_Ici.1 h).resolve_left hne\n\n"}
{"name":"Wbtw.right_mem_affineSpan_of_left_ne","module":"Mathlib.Analysis.Convex.Between","initialProofState":"R : Type u_1\nV : Type u_2\nP : Type u_4\ninst✝³ : LinearOrderedField R\ninst✝² : AddCommGroup V\ninst✝¹ : Module R V\ninst✝ : AddTorsor V P\nx y z : P\nh : Wbtw R x y z\nhne : Ne x y\n⊢ Membership.mem (affineSpan R (Insert.insert x (Singleton.singleton y))) z","decl":"theorem Wbtw.right_mem_affineSpan_of_left_ne {x y z : P} (h : Wbtw R x y z) (hne : x ≠ y) :\n    z ∈ line[R, x, y] := by\n  rcases h.right_mem_image_Ici_of_left_ne hne with ⟨r, ⟨-, rfl⟩⟩\n  exact lineMap_mem_affineSpan_pair _ _ _\n\n"}
{"name":"sbtw_iff_left_ne_and_right_mem_image_Ioi","module":"Mathlib.Analysis.Convex.Between","initialProofState":"R : Type u_1\nV : Type u_2\nP : Type u_4\ninst✝³ : LinearOrderedField R\ninst✝² : AddCommGroup V\ninst✝¹ : Module R V\ninst✝ : AddTorsor V P\nx y z : P\n⊢ Iff (Sbtw R x y z) (And (Ne x y) (Membership.mem (Set.image (⇑(AffineMap.lineMap x y)) (Set.Ioi 1)) z))","decl":"theorem sbtw_iff_left_ne_and_right_mem_image_Ioi {x y z : P} :\n    Sbtw R x y z ↔ x ≠ y ∧ z ∈ lineMap x y '' Set.Ioi (1 : R) := by\n  refine ⟨fun h => ⟨h.left_ne, ?_⟩, fun h => ?_⟩\n  · obtain ⟨r, ⟨hr, rfl⟩⟩ := h.wbtw.right_mem_image_Ici_of_left_ne h.left_ne\n    rw [Set.mem_Ici] at hr\n    rcases hr.lt_or_eq with (hrlt | rfl)\n    · exact Set.mem_image_of_mem _ hrlt\n    · exfalso\n      simp at h\n  · rcases h with ⟨hne, r, hr, rfl⟩\n    rw [Set.mem_Ioi] at hr\n    refine\n      ⟨wbtw_iff_left_eq_or_right_mem_image_Ici.2\n          (Or.inr (Set.mem_image_of_mem _ (Set.mem_of_mem_of_subset hr Set.Ioi_subset_Ici_self))),\n        hne.symm, ?_⟩\n    rw [lineMap_apply, ← @vsub_ne_zero V, vsub_vadd_eq_vsub_sub]\n    nth_rw 1 [← one_smul R (y -ᵥ x)]\n    rw [← sub_smul, smul_ne_zero_iff, vsub_ne_zero, sub_ne_zero]\n    exact ⟨hr.ne, hne.symm⟩\n\n"}
{"name":"Sbtw.right_mem_image_Ioi","module":"Mathlib.Analysis.Convex.Between","initialProofState":"R : Type u_1\nV : Type u_2\nP : Type u_4\ninst✝³ : LinearOrderedField R\ninst✝² : AddCommGroup V\ninst✝¹ : Module R V\ninst✝ : AddTorsor V P\nx y z : P\nh : Sbtw R x y z\n⊢ Membership.mem (Set.image (⇑(AffineMap.lineMap x y)) (Set.Ioi 1)) z","decl":"theorem Sbtw.right_mem_image_Ioi {x y z : P} (h : Sbtw R x y z) :\n    z ∈ lineMap x y '' Set.Ioi (1 : R) :=\n  (sbtw_iff_left_ne_and_right_mem_image_Ioi.1 h).2\n\n"}
{"name":"Sbtw.right_mem_affineSpan","module":"Mathlib.Analysis.Convex.Between","initialProofState":"R : Type u_1\nV : Type u_2\nP : Type u_4\ninst✝³ : LinearOrderedField R\ninst✝² : AddCommGroup V\ninst✝¹ : Module R V\ninst✝ : AddTorsor V P\nx y z : P\nh : Sbtw R x y z\n⊢ Membership.mem (affineSpan R (Insert.insert x (Singleton.singleton y))) z","decl":"theorem Sbtw.right_mem_affineSpan {x y z : P} (h : Sbtw R x y z) : z ∈ line[R, x, y] :=\n  h.wbtw.right_mem_affineSpan_of_left_ne h.left_ne\n\n"}
{"name":"wbtw_iff_right_eq_or_left_mem_image_Ici","module":"Mathlib.Analysis.Convex.Between","initialProofState":"R : Type u_1\nV : Type u_2\nP : Type u_4\ninst✝³ : LinearOrderedField R\ninst✝² : AddCommGroup V\ninst✝¹ : Module R V\ninst✝ : AddTorsor V P\nx y z : P\n⊢ Iff (Wbtw R x y z) (Or (Eq z y) (Membership.mem (Set.image (⇑(AffineMap.lineMap z y)) (Set.Ici 1)) x))","decl":"theorem wbtw_iff_right_eq_or_left_mem_image_Ici {x y z : P} :\n    Wbtw R x y z ↔ z = y ∨ x ∈ lineMap z y '' Set.Ici (1 : R) := by\n  rw [wbtw_comm, wbtw_iff_left_eq_or_right_mem_image_Ici]\n\n"}
{"name":"Wbtw.left_mem_image_Ici_of_right_ne","module":"Mathlib.Analysis.Convex.Between","initialProofState":"R : Type u_1\nV : Type u_2\nP : Type u_4\ninst✝³ : LinearOrderedField R\ninst✝² : AddCommGroup V\ninst✝¹ : Module R V\ninst✝ : AddTorsor V P\nx y z : P\nh : Wbtw R x y z\nhne : Ne z y\n⊢ Membership.mem (Set.image (⇑(AffineMap.lineMap z y)) (Set.Ici 1)) x","decl":"theorem Wbtw.left_mem_image_Ici_of_right_ne {x y z : P} (h : Wbtw R x y z) (hne : z ≠ y) :\n    x ∈ lineMap z y '' Set.Ici (1 : R) :=\n  h.symm.right_mem_image_Ici_of_left_ne hne\n\n"}
{"name":"Wbtw.left_mem_affineSpan_of_right_ne","module":"Mathlib.Analysis.Convex.Between","initialProofState":"R : Type u_1\nV : Type u_2\nP : Type u_4\ninst✝³ : LinearOrderedField R\ninst✝² : AddCommGroup V\ninst✝¹ : Module R V\ninst✝ : AddTorsor V P\nx y z : P\nh : Wbtw R x y z\nhne : Ne z y\n⊢ Membership.mem (affineSpan R (Insert.insert z (Singleton.singleton y))) x","decl":"theorem Wbtw.left_mem_affineSpan_of_right_ne {x y z : P} (h : Wbtw R x y z) (hne : z ≠ y) :\n    x ∈ line[R, z, y] :=\n  h.symm.right_mem_affineSpan_of_left_ne hne\n\n"}
{"name":"sbtw_iff_right_ne_and_left_mem_image_Ioi","module":"Mathlib.Analysis.Convex.Between","initialProofState":"R : Type u_1\nV : Type u_2\nP : Type u_4\ninst✝³ : LinearOrderedField R\ninst✝² : AddCommGroup V\ninst✝¹ : Module R V\ninst✝ : AddTorsor V P\nx y z : P\n⊢ Iff (Sbtw R x y z) (And (Ne z y) (Membership.mem (Set.image (⇑(AffineMap.lineMap z y)) (Set.Ioi 1)) x))","decl":"theorem sbtw_iff_right_ne_and_left_mem_image_Ioi {x y z : P} :\n    Sbtw R x y z ↔ z ≠ y ∧ x ∈ lineMap z y '' Set.Ioi (1 : R) := by\n  rw [sbtw_comm, sbtw_iff_left_ne_and_right_mem_image_Ioi]\n\n"}
{"name":"Sbtw.left_mem_image_Ioi","module":"Mathlib.Analysis.Convex.Between","initialProofState":"R : Type u_1\nV : Type u_2\nP : Type u_4\ninst✝³ : LinearOrderedField R\ninst✝² : AddCommGroup V\ninst✝¹ : Module R V\ninst✝ : AddTorsor V P\nx y z : P\nh : Sbtw R x y z\n⊢ Membership.mem (Set.image (⇑(AffineMap.lineMap z y)) (Set.Ioi 1)) x","decl":"theorem Sbtw.left_mem_image_Ioi {x y z : P} (h : Sbtw R x y z) :\n    x ∈ lineMap z y '' Set.Ioi (1 : R) :=\n  h.symm.right_mem_image_Ioi\n\n"}
{"name":"Sbtw.left_mem_affineSpan","module":"Mathlib.Analysis.Convex.Between","initialProofState":"R : Type u_1\nV : Type u_2\nP : Type u_4\ninst✝³ : LinearOrderedField R\ninst✝² : AddCommGroup V\ninst✝¹ : Module R V\ninst✝ : AddTorsor V P\nx y z : P\nh : Sbtw R x y z\n⊢ Membership.mem (affineSpan R (Insert.insert z (Singleton.singleton y))) x","decl":"theorem Sbtw.left_mem_affineSpan {x y z : P} (h : Sbtw R x y z) : x ∈ line[R, z, y] :=\n  h.symm.right_mem_affineSpan\n\n"}
{"name":"AffineSubspace.right_mem_of_wbtw","module":"Mathlib.Analysis.Convex.Between","initialProofState":"R : Type u_1\nV : Type u_2\nP : Type u_4\ninst✝³ : LinearOrderedField R\ninst✝² : AddCommGroup V\ninst✝¹ : Module R V\ninst✝ : AddTorsor V P\nx y z : P\ns : AffineSubspace R P\nhxyz : Wbtw R x y z\nhx : Membership.mem s x\nhy : Membership.mem s y\nhxy : Ne x y\n⊢ Membership.mem s z","decl":"lemma AffineSubspace.right_mem_of_wbtw {s : AffineSubspace R P} (hxyz : Wbtw R x y z) (hx : x ∈ s)\n    (hy : y ∈ s) (hxy : x ≠ y) : z ∈ s := by\n  obtain ⟨ε, -, rfl⟩ := hxyz\n  have hε : ε ≠ 0 := by rintro rfl; simp at hxy\n  simpa [hε] using lineMap_mem ε⁻¹ hx hy\n\n"}
{"name":"wbtw_smul_vadd_smul_vadd_of_nonneg_of_le","module":"Mathlib.Analysis.Convex.Between","initialProofState":"R : Type u_1\nV : Type u_2\nP : Type u_4\ninst✝³ : LinearOrderedField R\ninst✝² : AddCommGroup V\ninst✝¹ : Module R V\ninst✝ : AddTorsor V P\nx : P\nv : V\nr₁ r₂ : R\nhr₁ : LE.le 0 r₁\nhr₂ : LE.le r₁ r₂\n⊢ Wbtw R x (HVAdd.hVAdd (HSMul.hSMul r₁ v) x) (HVAdd.hVAdd (HSMul.hSMul r₂ v) x)","decl":"theorem wbtw_smul_vadd_smul_vadd_of_nonneg_of_le (x : P) (v : V) {r₁ r₂ : R} (hr₁ : 0 ≤ r₁)\n    (hr₂ : r₁ ≤ r₂) : Wbtw R x (r₁ • v +ᵥ x) (r₂ • v +ᵥ x) := by\n  refine ⟨r₁ / r₂, ⟨div_nonneg hr₁ (hr₁.trans hr₂), div_le_one_of_le₀ hr₂ (hr₁.trans hr₂)⟩, ?_⟩\n  by_cases h : r₁ = 0; · simp [h]\n  simp [lineMap_apply, smul_smul, ((hr₁.lt_of_ne' h).trans_le hr₂).ne.symm]\n\n"}
{"name":"wbtw_or_wbtw_smul_vadd_of_nonneg","module":"Mathlib.Analysis.Convex.Between","initialProofState":"R : Type u_1\nV : Type u_2\nP : Type u_4\ninst✝³ : LinearOrderedField R\ninst✝² : AddCommGroup V\ninst✝¹ : Module R V\ninst✝ : AddTorsor V P\nx : P\nv : V\nr₁ r₂ : R\nhr₁ : LE.le 0 r₁\nhr₂ : LE.le 0 r₂\n⊢ Or (Wbtw R x (HVAdd.hVAdd (HSMul.hSMul r₁ v) x) (HVAdd.hVAdd (HSMul.hSMul r₂ v) x)) (Wbtw R x (HVAdd.hVAdd (HSMul.hSMul r₂ v) x) (HVAdd.hVAdd (HSMul.hSMul r₁ v) x))","decl":"theorem wbtw_or_wbtw_smul_vadd_of_nonneg (x : P) (v : V) {r₁ r₂ : R} (hr₁ : 0 ≤ r₁) (hr₂ : 0 ≤ r₂) :\n    Wbtw R x (r₁ • v +ᵥ x) (r₂ • v +ᵥ x) ∨ Wbtw R x (r₂ • v +ᵥ x) (r₁ • v +ᵥ x) := by\n  rcases le_total r₁ r₂ with (h | h)\n  · exact Or.inl (wbtw_smul_vadd_smul_vadd_of_nonneg_of_le x v hr₁ h)\n  · exact Or.inr (wbtw_smul_vadd_smul_vadd_of_nonneg_of_le x v hr₂ h)\n\n"}
{"name":"wbtw_smul_vadd_smul_vadd_of_nonpos_of_le","module":"Mathlib.Analysis.Convex.Between","initialProofState":"R : Type u_1\nV : Type u_2\nP : Type u_4\ninst✝³ : LinearOrderedField R\ninst✝² : AddCommGroup V\ninst✝¹ : Module R V\ninst✝ : AddTorsor V P\nx : P\nv : V\nr₁ r₂ : R\nhr₁ : LE.le r₁ 0\nhr₂ : LE.le r₂ r₁\n⊢ Wbtw R x (HVAdd.hVAdd (HSMul.hSMul r₁ v) x) (HVAdd.hVAdd (HSMul.hSMul r₂ v) x)","decl":"theorem wbtw_smul_vadd_smul_vadd_of_nonpos_of_le (x : P) (v : V) {r₁ r₂ : R} (hr₁ : r₁ ≤ 0)\n    (hr₂ : r₂ ≤ r₁) : Wbtw R x (r₁ • v +ᵥ x) (r₂ • v +ᵥ x) := by\n  convert wbtw_smul_vadd_smul_vadd_of_nonneg_of_le x (-v) (Left.nonneg_neg_iff.2 hr₁)\n      (neg_le_neg_iff.2 hr₂) using 1 <;>\n    rw [neg_smul_neg]\n\n"}
{"name":"wbtw_or_wbtw_smul_vadd_of_nonpos","module":"Mathlib.Analysis.Convex.Between","initialProofState":"R : Type u_1\nV : Type u_2\nP : Type u_4\ninst✝³ : LinearOrderedField R\ninst✝² : AddCommGroup V\ninst✝¹ : Module R V\ninst✝ : AddTorsor V P\nx : P\nv : V\nr₁ r₂ : R\nhr₁ : LE.le r₁ 0\nhr₂ : LE.le r₂ 0\n⊢ Or (Wbtw R x (HVAdd.hVAdd (HSMul.hSMul r₁ v) x) (HVAdd.hVAdd (HSMul.hSMul r₂ v) x)) (Wbtw R x (HVAdd.hVAdd (HSMul.hSMul r₂ v) x) (HVAdd.hVAdd (HSMul.hSMul r₁ v) x))","decl":"theorem wbtw_or_wbtw_smul_vadd_of_nonpos (x : P) (v : V) {r₁ r₂ : R} (hr₁ : r₁ ≤ 0) (hr₂ : r₂ ≤ 0) :\n    Wbtw R x (r₁ • v +ᵥ x) (r₂ • v +ᵥ x) ∨ Wbtw R x (r₂ • v +ᵥ x) (r₁ • v +ᵥ x) := by\n  rcases le_total r₁ r₂ with (h | h)\n  · exact Or.inr (wbtw_smul_vadd_smul_vadd_of_nonpos_of_le x v hr₂ h)\n  · exact Or.inl (wbtw_smul_vadd_smul_vadd_of_nonpos_of_le x v hr₁ h)\n\n"}
{"name":"wbtw_smul_vadd_smul_vadd_of_nonpos_of_nonneg","module":"Mathlib.Analysis.Convex.Between","initialProofState":"R : Type u_1\nV : Type u_2\nP : Type u_4\ninst✝³ : LinearOrderedField R\ninst✝² : AddCommGroup V\ninst✝¹ : Module R V\ninst✝ : AddTorsor V P\nx : P\nv : V\nr₁ r₂ : R\nhr₁ : LE.le r₁ 0\nhr₂ : LE.le 0 r₂\n⊢ Wbtw R (HVAdd.hVAdd (HSMul.hSMul r₁ v) x) x (HVAdd.hVAdd (HSMul.hSMul r₂ v) x)","decl":"theorem wbtw_smul_vadd_smul_vadd_of_nonpos_of_nonneg (x : P) (v : V) {r₁ r₂ : R} (hr₁ : r₁ ≤ 0)\n    (hr₂ : 0 ≤ r₂) : Wbtw R (r₁ • v +ᵥ x) x (r₂ • v +ᵥ x) := by\n  convert wbtw_smul_vadd_smul_vadd_of_nonneg_of_le (r₁ • v +ᵥ x) v (Left.nonneg_neg_iff.2 hr₁)\n      (neg_le_sub_iff_le_add.2 ((le_add_iff_nonneg_left r₁).2 hr₂)) using 1 <;>\n    simp [sub_smul, ← add_vadd]\n\n"}
{"name":"wbtw_smul_vadd_smul_vadd_of_nonneg_of_nonpos","module":"Mathlib.Analysis.Convex.Between","initialProofState":"R : Type u_1\nV : Type u_2\nP : Type u_4\ninst✝³ : LinearOrderedField R\ninst✝² : AddCommGroup V\ninst✝¹ : Module R V\ninst✝ : AddTorsor V P\nx : P\nv : V\nr₁ r₂ : R\nhr₁ : LE.le 0 r₁\nhr₂ : LE.le r₂ 0\n⊢ Wbtw R (HVAdd.hVAdd (HSMul.hSMul r₁ v) x) x (HVAdd.hVAdd (HSMul.hSMul r₂ v) x)","decl":"theorem wbtw_smul_vadd_smul_vadd_of_nonneg_of_nonpos (x : P) (v : V) {r₁ r₂ : R} (hr₁ : 0 ≤ r₁)\n    (hr₂ : r₂ ≤ 0) : Wbtw R (r₁ • v +ᵥ x) x (r₂ • v +ᵥ x) := by\n  rw [wbtw_comm]\n  exact wbtw_smul_vadd_smul_vadd_of_nonpos_of_nonneg x v hr₂ hr₁\n\n"}
{"name":"Wbtw.trans_left_right","module":"Mathlib.Analysis.Convex.Between","initialProofState":"R : Type u_1\nV : Type u_2\nP : Type u_4\ninst✝³ : LinearOrderedField R\ninst✝² : AddCommGroup V\ninst✝¹ : Module R V\ninst✝ : AddTorsor V P\nw x y z : P\nh₁ : Wbtw R w y z\nh₂ : Wbtw R w x y\n⊢ Wbtw R x y z","decl":"theorem Wbtw.trans_left_right {w x y z : P} (h₁ : Wbtw R w y z) (h₂ : Wbtw R w x y) :\n    Wbtw R x y z := by\n  rcases h₁ with ⟨t₁, ht₁, rfl⟩\n  rcases h₂ with ⟨t₂, ht₂, rfl⟩\n  refine\n    ⟨(t₁ - t₂ * t₁) / (1 - t₂ * t₁),\n      ⟨div_nonneg (sub_nonneg.2 (mul_le_of_le_one_left ht₁.1 ht₂.2))\n          (sub_nonneg.2 (mul_le_one₀ ht₂.2 ht₁.1 ht₁.2)), div_le_one_of_le₀\n            (sub_le_sub_right ht₁.2 _) (sub_nonneg.2 (mul_le_one₀ ht₂.2 ht₁.1 ht₁.2))⟩,\n      ?_⟩\n  simp only [lineMap_apply, smul_smul, ← add_vadd, vsub_vadd_eq_vsub_sub, smul_sub, ← sub_smul,\n    ← add_smul, vadd_vsub, vadd_right_cancel_iff, div_mul_eq_mul_div, div_sub_div_same]\n  nth_rw 1 [← mul_one (t₁ - t₂ * t₁)]\n  rw [← mul_sub, mul_div_assoc]\n  by_cases h : 1 - t₂ * t₁ = 0\n  · rw [sub_eq_zero, eq_comm] at h\n    rw [h]\n    suffices t₁ = 1 by simp [this]\n    exact\n      eq_of_le_of_not_lt ht₁.2 fun ht₁lt =>\n        (mul_lt_one_of_nonneg_of_lt_one_right ht₂.2 ht₁.1 ht₁lt).ne h\n  · rw [div_self h]\n    ring_nf\n\n"}
{"name":"Wbtw.trans_right_left","module":"Mathlib.Analysis.Convex.Between","initialProofState":"R : Type u_1\nV : Type u_2\nP : Type u_4\ninst✝³ : LinearOrderedField R\ninst✝² : AddCommGroup V\ninst✝¹ : Module R V\ninst✝ : AddTorsor V P\nw x y z : P\nh₁ : Wbtw R w x z\nh₂ : Wbtw R x y z\n⊢ Wbtw R w x y","decl":"theorem Wbtw.trans_right_left {w x y z : P} (h₁ : Wbtw R w x z) (h₂ : Wbtw R x y z) :\n    Wbtw R w x y := by\n  rw [wbtw_comm] at *\n  exact h₁.trans_left_right h₂\n\n"}
{"name":"Sbtw.trans_left_right","module":"Mathlib.Analysis.Convex.Between","initialProofState":"R : Type u_1\nV : Type u_2\nP : Type u_4\ninst✝³ : LinearOrderedField R\ninst✝² : AddCommGroup V\ninst✝¹ : Module R V\ninst✝ : AddTorsor V P\nw x y z : P\nh₁ : Sbtw R w y z\nh₂ : Sbtw R w x y\n⊢ Sbtw R x y z","decl":"theorem Sbtw.trans_left_right {w x y z : P} (h₁ : Sbtw R w y z) (h₂ : Sbtw R w x y) :\n    Sbtw R x y z :=\n  ⟨h₁.wbtw.trans_left_right h₂.wbtw, h₂.right_ne, h₁.ne_right⟩\n\n"}
{"name":"Sbtw.trans_right_left","module":"Mathlib.Analysis.Convex.Between","initialProofState":"R : Type u_1\nV : Type u_2\nP : Type u_4\ninst✝³ : LinearOrderedField R\ninst✝² : AddCommGroup V\ninst✝¹ : Module R V\ninst✝ : AddTorsor V P\nw x y z : P\nh₁ : Sbtw R w x z\nh₂ : Sbtw R x y z\n⊢ Sbtw R w x y","decl":"theorem Sbtw.trans_right_left {w x y z : P} (h₁ : Sbtw R w x z) (h₂ : Sbtw R x y z) :\n    Sbtw R w x y :=\n  ⟨h₁.wbtw.trans_right_left h₂.wbtw, h₁.ne_left, h₂.left_ne⟩\n\n"}
{"name":"Wbtw.collinear","module":"Mathlib.Analysis.Convex.Between","initialProofState":"R : Type u_1\nV : Type u_2\nP : Type u_4\ninst✝³ : LinearOrderedField R\ninst✝² : AddCommGroup V\ninst✝¹ : Module R V\ninst✝ : AddTorsor V P\nx y z : P\nh : Wbtw R x y z\n⊢ Collinear R (Insert.insert x (Insert.insert y (Singleton.singleton z)))","decl":"theorem Wbtw.collinear {x y z : P} (h : Wbtw R x y z) : Collinear R ({x, y, z} : Set P) := by\n  rw [collinear_iff_exists_forall_eq_smul_vadd]\n  refine ⟨x, z -ᵥ x, ?_⟩\n  intro p hp\n  simp_rw [Set.mem_insert_iff, Set.mem_singleton_iff] at hp\n  rcases hp with (rfl | rfl | rfl)\n  · refine ⟨0, ?_⟩\n    simp\n  · rcases h with ⟨t, -, rfl⟩\n    exact ⟨t, rfl⟩\n  · refine ⟨1, ?_⟩\n    simp\n\n"}
{"name":"Collinear.wbtw_or_wbtw_or_wbtw","module":"Mathlib.Analysis.Convex.Between","initialProofState":"R : Type u_1\nV : Type u_2\nP : Type u_4\ninst✝³ : LinearOrderedField R\ninst✝² : AddCommGroup V\ninst✝¹ : Module R V\ninst✝ : AddTorsor V P\nx y z : P\nh : Collinear R (Insert.insert x (Insert.insert y (Singleton.singleton z)))\n⊢ Or (Wbtw R x y z) (Or (Wbtw R y z x) (Wbtw R z x y))","decl":"theorem Collinear.wbtw_or_wbtw_or_wbtw {x y z : P} (h : Collinear R ({x, y, z} : Set P)) :\n    Wbtw R x y z ∨ Wbtw R y z x ∨ Wbtw R z x y := by\n  rw [collinear_iff_of_mem (Set.mem_insert _ _)] at h\n  rcases h with ⟨v, h⟩\n  simp_rw [Set.mem_insert_iff, Set.mem_singleton_iff] at h\n  have hy := h y (Or.inr (Or.inl rfl))\n  have hz := h z (Or.inr (Or.inr rfl))\n  rcases hy with ⟨ty, rfl⟩\n  rcases hz with ⟨tz, rfl⟩\n  rcases lt_trichotomy ty 0 with (hy0 | rfl | hy0)\n  · rcases lt_trichotomy tz 0 with (hz0 | rfl | hz0)\n    · rw [wbtw_comm (z := x)]\n      rw [← or_assoc]\n      exact Or.inl (wbtw_or_wbtw_smul_vadd_of_nonpos _ _ hy0.le hz0.le)\n    · simp\n    · exact Or.inr (Or.inr (wbtw_smul_vadd_smul_vadd_of_nonneg_of_nonpos _ _ hz0.le hy0.le))\n  · simp\n  · rcases lt_trichotomy tz 0 with (hz0 | rfl | hz0)\n    · refine Or.inr (Or.inr (wbtw_smul_vadd_smul_vadd_of_nonpos_of_nonneg _ _ hz0.le hy0.le))\n    · simp\n    · rw [wbtw_comm (z := x)]\n      rw [← or_assoc]\n      exact Or.inl (wbtw_or_wbtw_smul_vadd_of_nonneg _ _ hy0.le hz0.le)\n\n"}
{"name":"wbtw_iff_sameRay_vsub","module":"Mathlib.Analysis.Convex.Between","initialProofState":"R : Type u_1\nV : Type u_2\nP : Type u_4\ninst✝³ : LinearOrderedField R\ninst✝² : AddCommGroup V\ninst✝¹ : Module R V\ninst✝ : AddTorsor V P\nx y z : P\n⊢ Iff (Wbtw R x y z) (SameRay R (VSub.vsub y x) (VSub.vsub z y))","decl":"theorem wbtw_iff_sameRay_vsub {x y z : P} : Wbtw R x y z ↔ SameRay R (y -ᵥ x) (z -ᵥ y) := by\n  refine ⟨Wbtw.sameRay_vsub, fun h => ?_⟩\n  rcases h with (h | h | ⟨r₁, r₂, hr₁, hr₂, h⟩)\n  · rw [vsub_eq_zero_iff_eq] at h\n    simp [h]\n  · rw [vsub_eq_zero_iff_eq] at h\n    simp [h]\n  · refine\n      ⟨r₂ / (r₁ + r₂),\n        ⟨div_nonneg hr₂.le (add_nonneg hr₁.le hr₂.le),\n          div_le_one_of_le₀ (le_add_of_nonneg_left hr₁.le) (add_nonneg hr₁.le hr₂.le)⟩,\n        ?_⟩\n    have h' : z = r₂⁻¹ • r₁ • (y -ᵥ x) +ᵥ y := by simp [h, hr₂.ne']\n    rw [eq_comm]\n    simp only [lineMap_apply, h', vadd_vsub_assoc, smul_smul, ← add_smul, eq_vadd_iff_vsub_eq,\n      smul_add]\n    convert (one_smul R (y -ᵥ x)).symm\n    field_simp [(add_pos hr₁ hr₂).ne', hr₂.ne']\n    ring\n\n"}
{"name":"wbtw_pointReflection","module":"Mathlib.Analysis.Convex.Between","initialProofState":"R : Type u_1\nV : Type u_2\nP : Type u_4\ninst✝³ : LinearOrderedField R\ninst✝² : AddCommGroup V\ninst✝¹ : Module R V\ninst✝ : AddTorsor V P\nx y : P\n⊢ Wbtw R y x ((AffineEquiv.pointReflection R x) y)","decl":"theorem wbtw_pointReflection (x y : P) : Wbtw R y x (pointReflection R x y) := by\n  refine ⟨2⁻¹, ⟨by norm_num, by norm_num⟩, ?_⟩\n  rw [lineMap_apply, pointReflection_apply, vadd_vsub_assoc, ← two_smul R (x -ᵥ y)]\n  simp\n\n"}
{"name":"sbtw_pointReflection_of_ne","module":"Mathlib.Analysis.Convex.Between","initialProofState":"R : Type u_1\nV : Type u_2\nP : Type u_4\ninst✝³ : LinearOrderedField R\ninst✝² : AddCommGroup V\ninst✝¹ : Module R V\ninst✝ : AddTorsor V P\nx y : P\nh : Ne x y\n⊢ Sbtw R y x ((AffineEquiv.pointReflection R x) y)","decl":"theorem sbtw_pointReflection_of_ne {x y : P} (h : x ≠ y) : Sbtw R y x (pointReflection R x y) := by\n  refine ⟨wbtw_pointReflection _ _ _, h, ?_⟩\n  nth_rw 1 [← pointReflection_self R x]\n  exact (pointReflection_involutive R x).injective.ne h\n\n"}
{"name":"wbtw_midpoint","module":"Mathlib.Analysis.Convex.Between","initialProofState":"R : Type u_1\nV : Type u_2\nP : Type u_4\ninst✝³ : LinearOrderedField R\ninst✝² : AddCommGroup V\ninst✝¹ : Module R V\ninst✝ : AddTorsor V P\nx y : P\n⊢ Wbtw R x (midpoint R x y) y","decl":"theorem wbtw_midpoint (x y : P) : Wbtw R x (midpoint R x y) y := by\n  convert wbtw_pointReflection R (midpoint R x y) x\n  rw [pointReflection_midpoint_left]\n\n"}
{"name":"sbtw_midpoint_of_ne","module":"Mathlib.Analysis.Convex.Between","initialProofState":"R : Type u_1\nV : Type u_2\nP : Type u_4\ninst✝³ : LinearOrderedField R\ninst✝² : AddCommGroup V\ninst✝¹ : Module R V\ninst✝ : AddTorsor V P\nx y : P\nh : Ne x y\n⊢ Sbtw R x (midpoint R x y) y","decl":"theorem sbtw_midpoint_of_ne {x y : P} (h : x ≠ y) : Sbtw R x (midpoint R x y) y := by\n  have h : midpoint R x y ≠ x := by simp [h]\n  convert sbtw_pointReflection_of_ne R h\n  rw [pointReflection_midpoint_left]\n\n"}
