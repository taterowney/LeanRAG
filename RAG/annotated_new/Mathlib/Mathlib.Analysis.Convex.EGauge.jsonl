{"name":"egauge_anti","module":"Mathlib.Analysis.Convex.EGauge","initialProofState":"𝕜 : Type u_1\ninst✝¹ : NNNorm 𝕜\nE : Type u_2\ninst✝ : SMul 𝕜 E\ns t : Set E\nh : HasSubset.Subset s t\nx : E\n⊢ LE.le (egauge 𝕜 t x) (egauge 𝕜 s x)","decl":"@[mono, gcongr]\nlemma egauge_anti (h : s ⊆ t) (x : E) : egauge 𝕜 t x ≤ egauge 𝕜 s x :=\n  iInf_mono fun _c ↦ iInf_mono' fun hc ↦ ⟨smul_set_mono h hc, le_rfl⟩\n\n"}
{"name":"egauge_empty","module":"Mathlib.Analysis.Convex.EGauge","initialProofState":"𝕜 : Type u_1\ninst✝¹ : NNNorm 𝕜\nE : Type u_2\ninst✝ : SMul 𝕜 E\nx : E\n⊢ Eq (egauge 𝕜 EmptyCollection.emptyCollection x) Top.top","decl":"@[simp] lemma egauge_empty (x : E) : egauge 𝕜 ∅ x = ∞ := by simp [egauge]\n\n"}
{"name":"egauge_le_of_mem_smul","module":"Mathlib.Analysis.Convex.EGauge","initialProofState":"𝕜 : Type u_1\ninst✝¹ : NNNorm 𝕜\nE : Type u_2\ninst✝ : SMul 𝕜 E\nc : 𝕜\ns : Set E\nx : E\nh : Membership.mem (HSMul.hSMul c s) x\n⊢ LE.le (egauge 𝕜 s x) (ENorm.enorm c)","decl":"lemma egauge_le_of_mem_smul (h : x ∈ c • s) : egauge 𝕜 s x ≤ ‖c‖ₑ := iInf₂_le c h\n\n"}
{"name":"le_egauge_iff","module":"Mathlib.Analysis.Convex.EGauge","initialProofState":"𝕜 : Type u_1\ninst✝¹ : NNNorm 𝕜\nE : Type u_2\ninst✝ : SMul 𝕜 E\ns : Set E\nx : E\nr : ENNReal\n⊢ Iff (LE.le r (egauge 𝕜 s x)) (∀ (c : 𝕜), Membership.mem (HSMul.hSMul c s) x → LE.le r (ENorm.enorm c))","decl":"lemma le_egauge_iff : r ≤ egauge 𝕜 s x ↔ ∀ c : 𝕜, x ∈ c • s → r ≤ ‖c‖ₑ := le_iInf₂_iff\n\n"}
{"name":"egauge_eq_top","module":"Mathlib.Analysis.Convex.EGauge","initialProofState":"𝕜 : Type u_1\ninst✝¹ : NNNorm 𝕜\nE : Type u_2\ninst✝ : SMul 𝕜 E\ns : Set E\nx : E\n⊢ Iff (Eq (egauge 𝕜 s x) Top.top) (∀ (c : 𝕜), Not (Membership.mem (HSMul.hSMul c s) x))","decl":"lemma egauge_eq_top : egauge 𝕜 s x = ∞ ↔ ∀ c : 𝕜, x ∉ c • s := by simp [egauge]\n\n"}
{"name":"egauge_lt_iff","module":"Mathlib.Analysis.Convex.EGauge","initialProofState":"𝕜 : Type u_1\ninst✝¹ : NNNorm 𝕜\nE : Type u_2\ninst✝ : SMul 𝕜 E\ns : Set E\nx : E\nr : ENNReal\n⊢ Iff (LT.lt (egauge 𝕜 s x) r) (Exists fun c => And (Membership.mem (HSMul.hSMul c s) x) (LT.lt (ENorm.enorm c) r))","decl":"lemma egauge_lt_iff : egauge 𝕜 s x < r ↔ ∃ c : 𝕜, x ∈ c • s ∧ ‖c‖ₑ < r := by\n  simp [egauge, iInf_lt_iff]\n\n"}
{"name":"egauge_union","module":"Mathlib.Analysis.Convex.EGauge","initialProofState":"𝕜 : Type u_1\ninst✝¹ : NNNorm 𝕜\nE : Type u_2\ninst✝ : SMul 𝕜 E\ns t : Set E\nx : E\n⊢ Eq (egauge 𝕜 (Union.union s t) x) (Min.min (egauge 𝕜 s x) (egauge 𝕜 t x))","decl":"lemma egauge_union (s t : Set E) (x : E) : egauge 𝕜 (s ∪ t) x = egauge 𝕜 s x ⊓ egauge 𝕜 t x := by\n  unfold egauge\n  simp [smul_set_union, iInf_or, iInf_inf_eq]\n\n"}
{"name":"le_egauge_inter","module":"Mathlib.Analysis.Convex.EGauge","initialProofState":"𝕜 : Type u_1\ninst✝¹ : NNNorm 𝕜\nE : Type u_2\ninst✝ : SMul 𝕜 E\ns t : Set E\nx : E\n⊢ LE.le (Max.max (egauge 𝕜 s x) (egauge 𝕜 t x)) (egauge 𝕜 (Inter.inter s t) x)","decl":"lemma le_egauge_inter (s t : Set E) (x : E) :\n    egauge 𝕜 s x ⊔ egauge 𝕜 t x ≤ egauge 𝕜 (s ∩ t) x :=\n  max_le (egauge_anti _ inter_subset_left _) (egauge_anti _ inter_subset_right _)\n\n"}
{"name":"egauge_zero_left_eq_top","module":"Mathlib.Analysis.Convex.EGauge","initialProofState":"𝕜 : Type u_1\ninst✝³ : NNNorm 𝕜\ninst✝² : Nonempty 𝕜\nE : Type u_2\ninst✝¹ : Zero E\ninst✝ : SMulZeroClass 𝕜 E\nx : E\n⊢ Iff (Eq (egauge 𝕜 0 x) Top.top) (Ne x 0)","decl":"@[simp] lemma egauge_zero_left_eq_top : egauge 𝕜 0 x = ∞ ↔ x ≠ 0 := by\n  simp [egauge_eq_top]\n\n"}
{"name":"egauge_zero_left","module":"Mathlib.Analysis.Convex.EGauge","initialProofState":"𝕜 : Type u_1\ninst✝³ : NNNorm 𝕜\ninst✝² : Nonempty 𝕜\nE : Type u_2\ninst✝¹ : Zero E\ninst✝ : SMulZeroClass 𝕜 E\nx : E\na✝ : Ne x 0\n⊢ Eq (egauge 𝕜 0 x) Top.top","decl":"@[simp] alias ⟨_, egauge_zero_left⟩ := egauge_zero_left_eq_top\n\n"}
{"name":"egauge_le_of_smul_mem_of_ne","module":"Mathlib.Analysis.Convex.EGauge","initialProofState":"𝕜 : Type u_1\ninst✝² : NormedDivisionRing 𝕜\nE : Type u_2\ninst✝¹ : AddCommGroup E\ninst✝ : Module 𝕜 E\nc : 𝕜\ns : Set E\nx : E\nh : Membership.mem s (HSMul.hSMul c x)\nhc : Ne c 0\n⊢ LE.le (egauge 𝕜 s x) ↑(Inv.inv (NNNorm.nnnorm c))","decl":"/-- If `c • x ∈ s` and `c ≠ 0`, then `egauge 𝕜 s x` is at most `(‖c‖₊⁻¹ : ℝ≥0)`.\n\nSee also `egauge_le_of_smul_mem`. -/\nlemma egauge_le_of_smul_mem_of_ne (h : c • x ∈ s) (hc : c ≠ 0) : egauge 𝕜 s x ≤ (‖c‖₊⁻¹ : ℝ≥0) := by\n  rw [← nnnorm_inv]\n  exact egauge_le_of_mem_smul <| (mem_inv_smul_set_iff₀ hc _ _).2 h\n\n"}
{"name":"egauge_le_of_smul_mem","module":"Mathlib.Analysis.Convex.EGauge","initialProofState":"𝕜 : Type u_1\ninst✝² : NormedDivisionRing 𝕜\nE : Type u_2\ninst✝¹ : AddCommGroup E\ninst✝ : Module 𝕜 E\nc : 𝕜\ns : Set E\nx : E\nh : Membership.mem s (HSMul.hSMul c x)\n⊢ LE.le (egauge 𝕜 s x) (Inv.inv (ENorm.enorm c))","decl":"/-- If `c • x ∈ s`, then `egauge 𝕜 s x` is at most `‖c‖ₑ⁻¹`.\n\nSee also `egauge_le_of_smul_mem_of_ne`. -/\nlemma egauge_le_of_smul_mem (h : c • x ∈ s) : egauge 𝕜 s x ≤ ‖c‖ₑ⁻¹ := by\n  rcases eq_or_ne c 0 with rfl | hc\n  · simp\n  · exact (egauge_le_of_smul_mem_of_ne h hc).trans ENNReal.coe_inv_le\n\n"}
{"name":"mem_of_egauge_lt_one","module":"Mathlib.Analysis.Convex.EGauge","initialProofState":"𝕜 : Type u_1\ninst✝² : NormedDivisionRing 𝕜\nE : Type u_2\ninst✝¹ : AddCommGroup E\ninst✝ : Module 𝕜 E\ns : Set E\nx : E\nhs : Balanced 𝕜 s\nhx : LT.lt (egauge 𝕜 s x) 1\n⊢ Membership.mem s x","decl":"lemma mem_of_egauge_lt_one (hs : Balanced 𝕜 s) (hx : egauge 𝕜 s x < 1) : x ∈ s :=\n  let ⟨c, hxc, hc⟩ := egauge_lt_iff.1 hx\n  hs c (by simpa [enorm] using hc.le) hxc\n\n"}
{"name":"egauge_eq_zero_iff","module":"Mathlib.Analysis.Convex.EGauge","initialProofState":"𝕜 : Type u_1\ninst✝² : NormedDivisionRing 𝕜\nE : Type u_2\ninst✝¹ : AddCommGroup E\ninst✝ : Module 𝕜 E\ns : Set E\nx : E\n⊢ Iff (Eq (egauge 𝕜 s x) 0) (Filter.Frequently (fun c => Membership.mem (HSMul.hSMul c s) x) (nhds 0))","decl":"lemma egauge_eq_zero_iff : egauge 𝕜 s x = 0 ↔ ∃ᶠ c : 𝕜 in 𝓝 0, x ∈ c • s := by\n  refine (iInf₂_eq_bot _).trans ?_\n  rw [(nhds_basis_uniformity uniformity_basis_edist).frequently_iff]\n  simp [and_comm]\n\n"}
{"name":"egauge_zero_right","module":"Mathlib.Analysis.Convex.EGauge","initialProofState":"𝕜 : Type u_1\ninst✝² : NormedDivisionRing 𝕜\nE : Type u_2\ninst✝¹ : AddCommGroup E\ninst✝ : Module 𝕜 E\ns : Set E\nhs : s.Nonempty\n⊢ Eq (egauge 𝕜 s 0) 0","decl":"@[simp]\nlemma egauge_zero_right (hs : s.Nonempty) : egauge 𝕜 s 0 = 0 := by\n  have : 0 ∈ (0 : 𝕜) • s := by simp [zero_smul_set hs]\n  simpa using egauge_le_of_mem_smul this\n\n"}
{"name":"egauge_zero_zero","module":"Mathlib.Analysis.Convex.EGauge","initialProofState":"𝕜 : Type u_1\ninst✝² : NormedDivisionRing 𝕜\nE : Type u_2\ninst✝¹ : AddCommGroup E\ninst✝ : Module 𝕜 E\n⊢ Eq (egauge 𝕜 0 0) 0","decl":"lemma egauge_zero_zero : egauge 𝕜 (0 : Set E) 0 = 0 := by simp\n\n"}
{"name":"egauge_le_one","module":"Mathlib.Analysis.Convex.EGauge","initialProofState":"𝕜 : Type u_1\ninst✝² : NormedDivisionRing 𝕜\nE : Type u_2\ninst✝¹ : AddCommGroup E\ninst✝ : Module 𝕜 E\ns : Set E\nx : E\nh : Membership.mem s x\n⊢ LE.le (egauge 𝕜 s x) 1","decl":"lemma egauge_le_one (h : x ∈ s) : egauge 𝕜 s x ≤ 1 := by\n  rw [← one_smul 𝕜 s] at h\n  simpa using egauge_le_of_mem_smul h\n\n"}
{"name":"le_egauge_smul_left","module":"Mathlib.Analysis.Convex.EGauge","initialProofState":"𝕜 : Type u_1\ninst✝² : NormedDivisionRing 𝕜\nE : Type u_2\ninst✝¹ : AddCommGroup E\ninst✝ : Module 𝕜 E\nc : 𝕜\ns : Set E\nx : E\n⊢ LE.le (HDiv.hDiv (egauge 𝕜 s x) (ENorm.enorm c)) (egauge 𝕜 (HSMul.hSMul c s) x)","decl":"lemma le_egauge_smul_left (c : 𝕜) (s : Set E) (x : E) :\n    egauge 𝕜 s x / ‖c‖ₑ ≤ egauge 𝕜 (c • s) x := by\n  simp_rw [le_egauge_iff, smul_smul]\n  rintro a ⟨x, hx, rfl⟩\n  apply ENNReal.div_le_of_le_mul\n  rw [← enorm_mul]\n  exact egauge_le_of_mem_smul <| smul_mem_smul_set hx\n\n"}
{"name":"egauge_smul_left","module":"Mathlib.Analysis.Convex.EGauge","initialProofState":"𝕜 : Type u_1\ninst✝² : NormedDivisionRing 𝕜\nE : Type u_2\ninst✝¹ : AddCommGroup E\ninst✝ : Module 𝕜 E\nc : 𝕜\nhc : Ne c 0\ns : Set E\nx : E\n⊢ Eq (egauge 𝕜 (HSMul.hSMul c s) x) (HDiv.hDiv (egauge 𝕜 s x) (ENorm.enorm c))","decl":"lemma egauge_smul_left (hc : c ≠ 0) (s : Set E) (x : E) :\n    egauge 𝕜 (c • s) x = egauge 𝕜 s x / ‖c‖ₑ := by\n  refine le_antisymm ?_ (le_egauge_smul_left _ _ _)\n  rw [ENNReal.le_div_iff_mul_le (by simp [*]) (by simp)]\n  calc\n    egauge 𝕜 (c • s) x * ‖c‖ₑ = egauge 𝕜 (c • s) x / ‖c⁻¹‖ₑ := by\n      rw [enorm_inv (by simpa), div_eq_mul_inv, inv_inv]\n    _ ≤ egauge 𝕜 (c⁻¹ • c • s) x := le_egauge_smul_left _ _ _\n    _ = egauge 𝕜 s x := by rw [inv_smul_smul₀ hc]\n\n"}
{"name":"le_egauge_smul_right","module":"Mathlib.Analysis.Convex.EGauge","initialProofState":"𝕜 : Type u_1\ninst✝² : NormedDivisionRing 𝕜\nE : Type u_2\ninst✝¹ : AddCommGroup E\ninst✝ : Module 𝕜 E\nc : 𝕜\ns : Set E\nx : E\n⊢ LE.le (HMul.hMul (ENorm.enorm c) (egauge 𝕜 s x)) (egauge 𝕜 s (HSMul.hSMul c x))","decl":"lemma le_egauge_smul_right (c : 𝕜) (s : Set E) (x : E) :\n    ‖c‖ₑ * egauge 𝕜 s x ≤ egauge 𝕜 s (c • x) := by\n  rw [le_egauge_iff]\n  rintro a ⟨y, hy, hxy⟩\n  rcases eq_or_ne c 0 with rfl | hc\n  · simp\n  · refine ENNReal.mul_le_of_le_div' <| le_trans ?_ ENNReal.coe_div_le\n    rw [div_eq_inv_mul, ← nnnorm_inv, ← nnnorm_mul]\n    refine egauge_le_of_mem_smul ⟨y, hy, ?_⟩\n    simp only [mul_smul, hxy, inv_smul_smul₀ hc]\n\n"}
{"name":"egauge_smul_right","module":"Mathlib.Analysis.Convex.EGauge","initialProofState":"𝕜 : Type u_1\ninst✝² : NormedDivisionRing 𝕜\nE : Type u_2\ninst✝¹ : AddCommGroup E\ninst✝ : Module 𝕜 E\nc : 𝕜\ns : Set E\nh : Eq c 0 → s.Nonempty\nx : E\n⊢ Eq (egauge 𝕜 s (HSMul.hSMul c x)) (HMul.hMul (ENorm.enorm c) (egauge 𝕜 s x))","decl":"lemma egauge_smul_right (h : c = 0 → s.Nonempty) (x : E) :\n    egauge 𝕜 s (c • x) = ‖c‖ₑ * egauge 𝕜 s x := by\n  refine le_antisymm ?_ (le_egauge_smul_right c s x)\n  rcases eq_or_ne c 0 with rfl | hc\n  · simp [egauge_zero_right _ (h rfl)]\n  · rw [mul_comm, ← ENNReal.div_le_iff_le_mul (.inl <| by simpa) (.inl enorm_ne_top),\n      ENNReal.div_eq_inv_mul, ← enorm_inv (by simpa)]\n    refine (le_egauge_smul_right _ _ _).trans_eq ?_\n    rw [inv_smul_smul₀ hc]\n\n"}
{"name":"egauge_add_add_le","module":"Mathlib.Analysis.Convex.EGauge","initialProofState":"𝕜 : Type u_1\ninst✝² : NormedField 𝕜\nE : Type u_2\ninst✝¹ : AddCommGroup E\ninst✝ : Module 𝕜 E\nU V : Set E\nhU : Balanced 𝕜 U\nhV : Balanced 𝕜 V\na b : E\n⊢ LE.le (egauge 𝕜 (HAdd.hAdd U V) (HAdd.hAdd a b)) (Max.max (egauge 𝕜 U a) (egauge 𝕜 V b))","decl":"theorem egauge_add_add_le {U V : Set E} (hU : Balanced 𝕜 U) (hV : Balanced 𝕜 V) (a b : E) :\n    egauge 𝕜 (U + V) (a + b) ≤ max (egauge 𝕜 U a) (egauge 𝕜 V b) := by\n  refine le_of_forall_lt' fun c hc ↦ ?_\n  simp only [max_lt_iff, egauge_lt_iff] at hc ⊢\n  rcases hc with ⟨⟨x, hx, hxc⟩, ⟨y, hy, hyc⟩⟩\n  wlog hxy : ‖x‖ ≤ ‖y‖ generalizing a b x y U V\n  · simpa only [add_comm] using this hV hU b a y hy hyc x hx hxc (le_of_not_le hxy)\n  refine ⟨y, ?_, hyc⟩\n  rw [smul_add]\n  exact add_mem_add (hU.smul_mono hxy hx) hy\n\n"}
{"name":"div_le_egauge_closedBall","module":"Mathlib.Analysis.Convex.EGauge","initialProofState":"𝕜 : Type u_1\ninst✝² : NormedField 𝕜\nE : Type u_2\ninst✝¹ : SeminormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\nr : NNReal\nx : E\n⊢ LE.le (HDiv.hDiv (ENorm.enorm x) ↑r) (egauge 𝕜 (Metric.closedBall 0 ↑r) x)","decl":"lemma div_le_egauge_closedBall (r : ℝ≥0) (x : E) : ‖x‖ₑ / r ≤ egauge 𝕜 (closedBall 0 r) x := by\n  rw [le_egauge_iff]\n  rintro c ⟨y, hy, rfl⟩\n  rw [mem_closedBall_zero_iff, ← coe_nnnorm, NNReal.coe_le_coe] at hy\n  rw [enorm_smul]\n  apply ENNReal.div_le_of_le_mul\n  gcongr\n  rwa [enorm_le_coe]\n\n"}
{"name":"le_egauge_closedBall_one","module":"Mathlib.Analysis.Convex.EGauge","initialProofState":"𝕜 : Type u_1\ninst✝² : NormedField 𝕜\nE : Type u_2\ninst✝¹ : SeminormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\nx : E\n⊢ LE.le (ENorm.enorm x) (egauge 𝕜 (Metric.closedBall 0 1) x)","decl":"lemma le_egauge_closedBall_one (x : E) : ‖x‖ₑ ≤ egauge 𝕜 (closedBall 0 1) x := by\n  simpa using div_le_egauge_closedBall 𝕜 1 x\n\n"}
{"name":"div_le_egauge_ball","module":"Mathlib.Analysis.Convex.EGauge","initialProofState":"𝕜 : Type u_1\ninst✝² : NormedField 𝕜\nE : Type u_2\ninst✝¹ : SeminormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\nr : NNReal\nx : E\n⊢ LE.le (HDiv.hDiv (ENorm.enorm x) ↑r) (egauge 𝕜 (Metric.ball 0 ↑r) x)","decl":"lemma div_le_egauge_ball (r : ℝ≥0) (x : E) : ‖x‖ₑ / r ≤ egauge 𝕜 (ball 0 r) x :=\n  (div_le_egauge_closedBall 𝕜 r x).trans <| egauge_anti _ ball_subset_closedBall _\n\n"}
{"name":"le_egauge_ball_one","module":"Mathlib.Analysis.Convex.EGauge","initialProofState":"𝕜 : Type u_1\ninst✝² : NormedField 𝕜\nE : Type u_2\ninst✝¹ : SeminormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\nx : E\n⊢ LE.le (ENorm.enorm x) (egauge 𝕜 (Metric.ball 0 1) x)","decl":"lemma le_egauge_ball_one (x : E) : ‖x‖ₑ ≤ egauge 𝕜 (ball 0 1) x := by\n  simpa using div_le_egauge_ball 𝕜 1 x\n\n"}
{"name":"egauge_ball_le_of_one_lt_norm","module":"Mathlib.Analysis.Convex.EGauge","initialProofState":"𝕜 : Type u_1\ninst✝² : NormedField 𝕜\nE : Type u_2\ninst✝¹ : SeminormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\nc : 𝕜\nx : E\nr : NNReal\nhc : LT.lt 1 (Norm.norm c)\nh₀ : Or (Ne r 0) (Ne (Norm.norm x) 0)\n⊢ LE.le (egauge 𝕜 (Metric.ball 0 ↑r) x) (HDiv.hDiv (HMul.hMul (ENorm.enorm c) (ENorm.enorm x)) ↑r)","decl":"lemma egauge_ball_le_of_one_lt_norm (hc : 1 < ‖c‖) (h₀ : r ≠ 0 ∨ ‖x‖ ≠ 0) :\n    egauge 𝕜 (ball 0 r) x ≤ ‖c‖ₑ * ‖x‖ₑ / r := by\n  letI : NontriviallyNormedField 𝕜 := ⟨c, hc⟩\n  rcases (zero_le r).eq_or_lt with rfl | hr\n  · rw [ENNReal.coe_zero, ENNReal.div_zero (mul_ne_zero _ _)]\n    · apply le_top\n    · simpa using one_pos.trans hc\n    · simpa [enorm, ← NNReal.coe_eq_zero] using h₀\n  · rcases eq_or_ne ‖x‖ 0 with hx | hx\n    · have hx' : ‖x‖ₑ = 0 := by simpa [enorm, ← coe_nnnorm, NNReal.coe_eq_zero] using hx\n      simp [egauge_eq_zero_iff, hx']\n      refine (frequently_iff_neBot.2 (inferInstance : NeBot (𝓝[≠] (0 : 𝕜)))).mono fun c hc ↦ ?_\n      simp [mem_smul_set_iff_inv_smul_mem₀ hc, norm_smul, hx, hr]\n    · rcases rescale_to_shell_semi_normed hc hr hx with ⟨a, ha₀, har, -, hainv⟩\n      calc\n        egauge 𝕜 (ball 0 r) x ≤ ↑(‖a‖₊⁻¹) :=\n          egauge_le_of_smul_mem_of_ne (mem_ball_zero_iff.2 har) ha₀\n        _ ≤ ↑(‖c‖₊ * ‖x‖₊ / r) := by rwa [ENNReal.coe_le_coe, div_eq_inv_mul, ← mul_assoc]\n        _ ≤ ‖c‖ₑ * ‖x‖ₑ / r := ENNReal.coe_div_le.trans <| by simp [ENNReal.coe_mul, enorm]\n\n"}
{"name":"egauge_ball_one_le_of_one_lt_norm","module":"Mathlib.Analysis.Convex.EGauge","initialProofState":"𝕜 : Type u_1\ninst✝² : NormedField 𝕜\nE : Type u_2\ninst✝¹ : SeminormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\nc : 𝕜\nhc : LT.lt 1 (Norm.norm c)\nx : E\n⊢ LE.le (egauge 𝕜 (Metric.ball 0 1) x) (HMul.hMul (ENorm.enorm c) (ENorm.enorm x))","decl":"lemma egauge_ball_one_le_of_one_lt_norm (hc : 1 < ‖c‖) (x : E) :\n    egauge 𝕜 (ball 0 1) x ≤ ‖c‖ₑ * ‖x‖ₑ := by\n  simpa using egauge_ball_le_of_one_lt_norm hc (.inl one_ne_zero)\n\n"}
