{"name":"NormedAddGroupHom.map_add'","module":"Mathlib.Analysis.Normed.Group.Hom","initialProofState":"V : Type u_1\nW : Type u_2\ninst✝¹ : SeminormedAddCommGroup V\ninst✝ : SeminormedAddCommGroup W\nself : NormedAddGroupHom V W\nv₁ v₂ : V\n⊢ Eq (self.toFun (HAdd.hAdd v₁ v₂)) (HAdd.hAdd (self.toFun v₁) (self.toFun v₂))","decl":"/-- A morphism of seminormed abelian groups is a bounded group homomorphism. -/\nstructure NormedAddGroupHom (V W : Type*) [SeminormedAddCommGroup V]\n  [SeminormedAddCommGroup W] where\n  /-- The function underlying a `NormedAddGroupHom` -/\n  toFun : V → W\n  /-- A `NormedAddGroupHom` is additive. -/\n  map_add' : ∀ v₁ v₂, toFun (v₁ + v₂) = toFun v₁ + toFun v₂\n  /-- A `NormedAddGroupHom` is bounded. -/\n  bound' : ∃ C, ∀ v, ‖toFun v‖ ≤ C * ‖v‖\n\n"}
{"name":"NormedAddGroupHom.mk.injEq","module":"Mathlib.Analysis.Normed.Group.Hom","initialProofState":"V : Type u_1\nW : Type u_2\ninst✝¹ : SeminormedAddCommGroup V\ninst✝ : SeminormedAddCommGroup W\ntoFun✝ : V → W\nmap_add'✝ : ∀ (v₁ v₂ : V), Eq (toFun✝ (HAdd.hAdd v₁ v₂)) (HAdd.hAdd (toFun✝ v₁) (toFun✝ v₂))\nbound'✝ : Exists fun C => ∀ (v : V), LE.le (Norm.norm (toFun✝ v)) (HMul.hMul C (Norm.norm v))\ntoFun : V → W\nmap_add' : ∀ (v₁ v₂ : V), Eq (toFun (HAdd.hAdd v₁ v₂)) (HAdd.hAdd (toFun v₁) (toFun v₂))\nbound' : Exists fun C => ∀ (v : V), LE.le (Norm.norm (toFun v)) (HMul.hMul C (Norm.norm v))\n⊢ Eq (Eq { toFun := toFun✝, map_add' := map_add'✝, bound' := bound'✝ } { toFun := toFun, map_add' := map_add', bound' := bound' }) (Eq toFun✝ toFun)","decl":"/-- A morphism of seminormed abelian groups is a bounded group homomorphism. -/\nstructure NormedAddGroupHom (V W : Type*) [SeminormedAddCommGroup V]\n  [SeminormedAddCommGroup W] where\n  /-- The function underlying a `NormedAddGroupHom` -/\n  toFun : V → W\n  /-- A `NormedAddGroupHom` is additive. -/\n  map_add' : ∀ v₁ v₂, toFun (v₁ + v₂) = toFun v₁ + toFun v₂\n  /-- A `NormedAddGroupHom` is bounded. -/\n  bound' : ∃ C, ∀ v, ‖toFun v‖ ≤ C * ‖v‖\n\n"}
{"name":"NormedAddGroupHom.bound'","module":"Mathlib.Analysis.Normed.Group.Hom","initialProofState":"V : Type u_1\nW : Type u_2\ninst✝¹ : SeminormedAddCommGroup V\ninst✝ : SeminormedAddCommGroup W\nself : NormedAddGroupHom V W\n⊢ Exists fun C => ∀ (v : V), LE.le (Norm.norm (self.toFun v)) (HMul.hMul C (Norm.norm v))","decl":"/-- A morphism of seminormed abelian groups is a bounded group homomorphism. -/\nstructure NormedAddGroupHom (V W : Type*) [SeminormedAddCommGroup V]\n  [SeminormedAddCommGroup W] where\n  /-- The function underlying a `NormedAddGroupHom` -/\n  toFun : V → W\n  /-- A `NormedAddGroupHom` is additive. -/\n  map_add' : ∀ v₁ v₂, toFun (v₁ + v₂) = toFun v₁ + toFun v₂\n  /-- A `NormedAddGroupHom` is bounded. -/\n  bound' : ∃ C, ∀ v, ‖toFun v‖ ≤ C * ‖v‖\n\n"}
{"name":"NormedAddGroupHom.mk.sizeOf_spec","module":"Mathlib.Analysis.Normed.Group.Hom","initialProofState":"V : Type u_1\nW : Type u_2\ninst✝³ : SeminormedAddCommGroup V\ninst✝² : SeminormedAddCommGroup W\ninst✝¹ : SizeOf V\ninst✝ : SizeOf W\ntoFun : V → W\nmap_add' : ∀ (v₁ v₂ : V), Eq (toFun (HAdd.hAdd v₁ v₂)) (HAdd.hAdd (toFun v₁) (toFun v₂))\nbound' : Exists fun C => ∀ (v : V), LE.le (Norm.norm (toFun v)) (HMul.hMul C (Norm.norm v))\n⊢ Eq (SizeOf.sizeOf { toFun := toFun, map_add' := map_add', bound' := bound' }) (HAdd.hAdd 1 (SizeOf.sizeOf bound'))","decl":"/-- A morphism of seminormed abelian groups is a bounded group homomorphism. -/\nstructure NormedAddGroupHom (V W : Type*) [SeminormedAddCommGroup V]\n  [SeminormedAddCommGroup W] where\n  /-- The function underlying a `NormedAddGroupHom` -/\n  toFun : V → W\n  /-- A `NormedAddGroupHom` is additive. -/\n  map_add' : ∀ v₁ v₂, toFun (v₁ + v₂) = toFun v₁ + toFun v₂\n  /-- A `NormedAddGroupHom` is bounded. -/\n  bound' : ∃ C, ∀ v, ‖toFun v‖ ≤ C * ‖v‖\n\n"}
{"name":"NormedAddGroupHom.mk.inj","module":"Mathlib.Analysis.Normed.Group.Hom","initialProofState":"V : Type u_1\nW : Type u_2\ninst✝¹ : SeminormedAddCommGroup V\ninst✝ : SeminormedAddCommGroup W\ntoFun✝ : V → W\nmap_add'✝ : ∀ (v₁ v₂ : V), Eq (toFun✝ (HAdd.hAdd v₁ v₂)) (HAdd.hAdd (toFun✝ v₁) (toFun✝ v₂))\nbound'✝ : Exists fun C => ∀ (v : V), LE.le (Norm.norm (toFun✝ v)) (HMul.hMul C (Norm.norm v))\ntoFun : V → W\nmap_add' : ∀ (v₁ v₂ : V), Eq (toFun (HAdd.hAdd v₁ v₂)) (HAdd.hAdd (toFun v₁) (toFun v₂))\nbound' : Exists fun C => ∀ (v : V), LE.le (Norm.norm (toFun v)) (HMul.hMul C (Norm.norm v))\nx✝ : Eq { toFun := toFun✝, map_add' := map_add'✝, bound' := bound'✝ } { toFun := toFun, map_add' := map_add', bound' := bound' }\n⊢ Eq toFun✝ toFun","decl":"/-- A morphism of seminormed abelian groups is a bounded group homomorphism. -/\nstructure NormedAddGroupHom (V W : Type*) [SeminormedAddCommGroup V]\n  [SeminormedAddCommGroup W] where\n  /-- The function underlying a `NormedAddGroupHom` -/\n  toFun : V → W\n  /-- A `NormedAddGroupHom` is additive. -/\n  map_add' : ∀ v₁ v₂, toFun (v₁ + v₂) = toFun v₁ + toFun v₂\n  /-- A `NormedAddGroupHom` is bounded. -/\n  bound' : ∃ C, ∀ v, ‖toFun v‖ ≤ C * ‖v‖\n\n"}
{"name":"exists_pos_bound_of_bound","module":"Mathlib.Analysis.Normed.Group.Hom","initialProofState":"V : Type u_1\nW : Type u_2\ninst✝¹ : SeminormedAddCommGroup V\ninst✝ : SeminormedAddCommGroup W\nf : V → W\nM : Real\nh : ∀ (x : V), LE.le (Norm.norm (f x)) (HMul.hMul M (Norm.norm x))\n⊢ Exists fun N => And (LT.lt 0 N) (∀ (x : V), LE.le (Norm.norm (f x)) (HMul.hMul N (Norm.norm x)))","decl":"theorem exists_pos_bound_of_bound {V W : Type*} [SeminormedAddCommGroup V]\n    [SeminormedAddCommGroup W] {f : V → W} (M : ℝ) (h : ∀ x, ‖f x‖ ≤ M * ‖x‖) :\n    ∃ N, 0 < N ∧ ∀ x, ‖f x‖ ≤ N * ‖x‖ :=\n  ⟨max M 1, lt_of_lt_of_le zero_lt_one (le_max_right _ _), fun x =>\n    calc\n      ‖f x‖ ≤ M * ‖x‖ := h x\n      _ ≤ max M 1 * ‖x‖ := by gcongr; apply le_max_left\n      ⟩\n\n"}
{"name":"NormedAddGroupHom.toAddMonoidHomClass","module":"Mathlib.Analysis.Normed.Group.Hom","initialProofState":"V₁ : Type u_2\nV₂ : Type u_3\ninst✝¹ : SeminormedAddCommGroup V₁\ninst✝ : SeminormedAddCommGroup V₂\n⊢ AddMonoidHomClass (NormedAddGroupHom V₁ V₂) V₁ V₂","decl":"instance toAddMonoidHomClass : AddMonoidHomClass (NormedAddGroupHom V₁ V₂) V₁ V₂ where\n  map_add f := f.map_add'\n  map_zero f := (AddMonoidHom.mk' f.toFun f.map_add').map_zero\n\n"}
{"name":"NormedAddGroupHom.coe_inj","module":"Mathlib.Analysis.Normed.Group.Hom","initialProofState":"V₁ : Type u_2\nV₂ : Type u_3\ninst✝¹ : SeminormedAddCommGroup V₁\ninst✝ : SeminormedAddCommGroup V₂\nf g : NormedAddGroupHom V₁ V₂\nH : Eq ⇑f ⇑g\n⊢ Eq f g","decl":"theorem coe_inj (H : (f : V₁ → V₂) = g) : f = g := by\n  cases f; cases g; congr\n\n"}
{"name":"NormedAddGroupHom.coe_injective","module":"Mathlib.Analysis.Normed.Group.Hom","initialProofState":"V₁ : Type u_2\nV₂ : Type u_3\ninst✝¹ : SeminormedAddCommGroup V₁\ninst✝ : SeminormedAddCommGroup V₂\n⊢ Function.Injective NormedAddGroupHom.toFun","decl":"theorem coe_injective : @Function.Injective (NormedAddGroupHom V₁ V₂) (V₁ → V₂) toFun := by\n  apply coe_inj\n\n"}
{"name":"NormedAddGroupHom.coe_inj_iff","module":"Mathlib.Analysis.Normed.Group.Hom","initialProofState":"V₁ : Type u_2\nV₂ : Type u_3\ninst✝¹ : SeminormedAddCommGroup V₁\ninst✝ : SeminormedAddCommGroup V₂\nf g : NormedAddGroupHom V₁ V₂\n⊢ Iff (Eq f g) (Eq ⇑f ⇑g)","decl":"theorem coe_inj_iff : f = g ↔ (f : V₁ → V₂) = g :=\n  ⟨congr_arg _, coe_inj⟩\n\n"}
{"name":"NormedAddGroupHom.ext","module":"Mathlib.Analysis.Normed.Group.Hom","initialProofState":"V₁ : Type u_2\nV₂ : Type u_3\ninst✝¹ : SeminormedAddCommGroup V₁\ninst✝ : SeminormedAddCommGroup V₂\nf g : NormedAddGroupHom V₁ V₂\nH : ∀ (x : V₁), Eq (f x) (g x)\n⊢ Eq f g","decl":"@[ext]\ntheorem ext (H : ∀ x, f x = g x) : f = g :=\n  coe_inj <| funext H\n\n"}
{"name":"NormedAddGroupHom.ext_iff","module":"Mathlib.Analysis.Normed.Group.Hom","initialProofState":"V₁ : Type u_2\nV₂ : Type u_3\ninst✝¹ : SeminormedAddCommGroup V₁\ninst✝ : SeminormedAddCommGroup V₂\nf g : NormedAddGroupHom V₁ V₂\n⊢ Iff (Eq f g) (∀ (x : V₁), Eq (f x) (g x))","decl":"@[ext]\ntheorem ext (H : ∀ x, f x = g x) : f = g :=\n  coe_inj <| funext H\n\n"}
{"name":"NormedAddGroupHom.toFun_eq_coe","module":"Mathlib.Analysis.Normed.Group.Hom","initialProofState":"V₁ : Type u_2\nV₂ : Type u_3\ninst✝¹ : SeminormedAddCommGroup V₁\ninst✝ : SeminormedAddCommGroup V₂\nf : NormedAddGroupHom V₁ V₂\n⊢ Eq f.toFun ⇑f","decl":"@[simp]\ntheorem toFun_eq_coe : f.toFun = f :=\n  rfl\n\n"}
{"name":"NormedAddGroupHom.coe_mk","module":"Mathlib.Analysis.Normed.Group.Hom","initialProofState":"V₁ : Type u_2\nV₂ : Type u_3\ninst✝¹ : SeminormedAddCommGroup V₁\ninst✝ : SeminormedAddCommGroup V₂\nf : V₁ → V₂\nh₁ : ∀ (v₁ v₂ : V₁), Eq (f (HAdd.hAdd v₁ v₂)) (HAdd.hAdd (f v₁) (f v₂))\nh₂ : Real\nh₃ : ∀ (v : V₁), LE.le (Norm.norm (f v)) (HMul.hMul h₂ (Norm.norm v))\n⊢ Eq (⇑{ toFun := f, map_add' := h₁, bound' := ⋯ }) f","decl":"theorem coe_mk (f) (h₁) (h₂) (h₃) : ⇑(⟨f, h₁, h₂, h₃⟩ : NormedAddGroupHom V₁ V₂) = f :=\n  rfl\n\n"}
{"name":"NormedAddGroupHom.coe_mkNormedAddGroupHom","module":"Mathlib.Analysis.Normed.Group.Hom","initialProofState":"V₁ : Type u_2\nV₂ : Type u_3\ninst✝¹ : SeminormedAddCommGroup V₁\ninst✝ : SeminormedAddCommGroup V₂\nf : AddMonoidHom V₁ V₂\nC : Real\nhC : ∀ (v : V₁), LE.le (Norm.norm (f v)) (HMul.hMul C (Norm.norm v))\n⊢ Eq ⇑(f.mkNormedAddGroupHom C hC) ⇑f","decl":"@[simp]\ntheorem coe_mkNormedAddGroupHom (f : V₁ →+ V₂) (C) (hC) : ⇑(f.mkNormedAddGroupHom C hC) = f :=\n  rfl\n\n"}
{"name":"NormedAddGroupHom.coe_mkNormedAddGroupHom'","module":"Mathlib.Analysis.Normed.Group.Hom","initialProofState":"V₁ : Type u_2\nV₂ : Type u_3\ninst✝¹ : SeminormedAddCommGroup V₁\ninst✝ : SeminormedAddCommGroup V₂\nf : AddMonoidHom V₁ V₂\nC : NNReal\nhC : ∀ (x : V₁), LE.le (NNNorm.nnnorm (f x)) (HMul.hMul C (NNNorm.nnnorm x))\n⊢ Eq ⇑(f.mkNormedAddGroupHom' C hC) ⇑f","decl":"@[simp]\ntheorem coe_mkNormedAddGroupHom' (f : V₁ →+ V₂) (C) (hC) : ⇑(f.mkNormedAddGroupHom' C hC) = f :=\n  rfl\n\n"}
{"name":"NormedAddGroupHom.coe_toAddMonoidHom","module":"Mathlib.Analysis.Normed.Group.Hom","initialProofState":"V₁ : Type u_2\nV₂ : Type u_3\ninst✝¹ : SeminormedAddCommGroup V₁\ninst✝ : SeminormedAddCommGroup V₂\nf : NormedAddGroupHom V₁ V₂\n⊢ Eq ⇑f.toAddMonoidHom ⇑f","decl":"@[simp]\ntheorem coe_toAddMonoidHom : ⇑f.toAddMonoidHom = f :=\n  rfl\n\n"}
{"name":"NormedAddGroupHom.toAddMonoidHom_injective","module":"Mathlib.Analysis.Normed.Group.Hom","initialProofState":"V₁ : Type u_2\nV₂ : Type u_3\ninst✝¹ : SeminormedAddCommGroup V₁\ninst✝ : SeminormedAddCommGroup V₂\n⊢ Function.Injective NormedAddGroupHom.toAddMonoidHom","decl":"theorem toAddMonoidHom_injective :\n    Function.Injective (@NormedAddGroupHom.toAddMonoidHom V₁ V₂ _ _) := fun f g h =>\n  coe_inj <| by rw [← coe_toAddMonoidHom f, ← coe_toAddMonoidHom g, h]\n\n"}
{"name":"NormedAddGroupHom.mk_toAddMonoidHom","module":"Mathlib.Analysis.Normed.Group.Hom","initialProofState":"V₁ : Type u_2\nV₂ : Type u_3\ninst✝¹ : SeminormedAddCommGroup V₁\ninst✝ : SeminormedAddCommGroup V₂\nf : V₁ → V₂\nh₁ : ∀ (v₁ v₂ : V₁), Eq (f (HAdd.hAdd v₁ v₂)) (HAdd.hAdd (f v₁) (f v₂))\nh₂ : Exists fun C => ∀ (v : V₁), LE.le (Norm.norm (f v)) (HMul.hMul C (Norm.norm v))\n⊢ Eq { toFun := f, map_add' := h₁, bound' := h₂ }.toAddMonoidHom (AddMonoidHom.mk' f h₁)","decl":"@[simp]\ntheorem mk_toAddMonoidHom (f) (h₁) (h₂) :\n    (⟨f, h₁, h₂⟩ : NormedAddGroupHom V₁ V₂).toAddMonoidHom = AddMonoidHom.mk' f h₁ :=\n  rfl\n\n"}
{"name":"NormedAddGroupHom.bound","module":"Mathlib.Analysis.Normed.Group.Hom","initialProofState":"V₁ : Type u_2\nV₂ : Type u_3\ninst✝¹ : SeminormedAddCommGroup V₁\ninst✝ : SeminormedAddCommGroup V₂\nf : NormedAddGroupHom V₁ V₂\n⊢ Exists fun C => And (LT.lt 0 C) (∀ (x : V₁), LE.le (Norm.norm (f x)) (HMul.hMul C (Norm.norm x)))","decl":"theorem bound : ∃ C, 0 < C ∧ ∀ x, ‖f x‖ ≤ C * ‖x‖ :=\n  let ⟨_C, hC⟩ := f.bound'\n  exists_pos_bound_of_bound _ hC\n\n"}
{"name":"NormedAddGroupHom.antilipschitz_of_norm_ge","module":"Mathlib.Analysis.Normed.Group.Hom","initialProofState":"V₁ : Type u_2\nV₂ : Type u_3\ninst✝¹ : SeminormedAddCommGroup V₁\ninst✝ : SeminormedAddCommGroup V₂\nf : NormedAddGroupHom V₁ V₂\nK : NNReal\nh : ∀ (x : V₁), LE.le (Norm.norm x) (HMul.hMul (↑K) (Norm.norm (f x)))\n⊢ AntilipschitzWith K ⇑f","decl":"theorem antilipschitz_of_norm_ge {K : ℝ≥0} (h : ∀ x, ‖x‖ ≤ K * ‖f x‖) : AntilipschitzWith K f :=\n  AntilipschitzWith.of_le_mul_dist fun x y => by simpa only [dist_eq_norm, map_sub] using h (x - y)\n\n"}
{"name":"NormedAddGroupHom.SurjectiveOnWith.mono","module":"Mathlib.Analysis.Normed.Group.Hom","initialProofState":"V₁ : Type u_2\nV₂ : Type u_3\ninst✝¹ : SeminormedAddCommGroup V₁\ninst✝ : SeminormedAddCommGroup V₂\nf : NormedAddGroupHom V₁ V₂\nK : AddSubgroup V₂\nC C' : Real\nh : f.SurjectiveOnWith K C\nH : LE.le C C'\n⊢ f.SurjectiveOnWith K C'","decl":"theorem SurjectiveOnWith.mono {f : NormedAddGroupHom V₁ V₂} {K : AddSubgroup V₂} {C C' : ℝ}\n    (h : f.SurjectiveOnWith K C) (H : C ≤ C') : f.SurjectiveOnWith K C' := by\n  intro k k_in\n  rcases h k k_in with ⟨g, rfl, hg⟩\n  use g, rfl\n  by_cases Hg : ‖f g‖ = 0\n  · simpa [Hg] using hg\n  · exact hg.trans (by gcongr)\n\n"}
{"name":"NormedAddGroupHom.SurjectiveOnWith.exists_pos","module":"Mathlib.Analysis.Normed.Group.Hom","initialProofState":"V₁ : Type u_2\nV₂ : Type u_3\ninst✝¹ : SeminormedAddCommGroup V₁\ninst✝ : SeminormedAddCommGroup V₂\nf : NormedAddGroupHom V₁ V₂\nK : AddSubgroup V₂\nC : Real\nh : f.SurjectiveOnWith K C\n⊢ Exists fun C' => And (GT.gt C' 0) (f.SurjectiveOnWith K C')","decl":"theorem SurjectiveOnWith.exists_pos {f : NormedAddGroupHom V₁ V₂} {K : AddSubgroup V₂} {C : ℝ}\n    (h : f.SurjectiveOnWith K C) : ∃ C' > 0, f.SurjectiveOnWith K C' := by\n  refine ⟨|C| + 1, ?_, ?_⟩\n  · linarith [abs_nonneg C]\n  · apply h.mono\n    linarith [le_abs_self C]\n\n"}
{"name":"NormedAddGroupHom.SurjectiveOnWith.surjOn","module":"Mathlib.Analysis.Normed.Group.Hom","initialProofState":"V₁ : Type u_2\nV₂ : Type u_3\ninst✝¹ : SeminormedAddCommGroup V₁\ninst✝ : SeminormedAddCommGroup V₂\nf : NormedAddGroupHom V₁ V₂\nK : AddSubgroup V₂\nC : Real\nh : f.SurjectiveOnWith K C\n⊢ Set.SurjOn (⇑f) Set.univ ↑K","decl":"theorem SurjectiveOnWith.surjOn {f : NormedAddGroupHom V₁ V₂} {K : AddSubgroup V₂} {C : ℝ}\n    (h : f.SurjectiveOnWith K C) : Set.SurjOn f Set.univ K := fun x hx =>\n  (h x hx).imp fun _a ⟨ha, _⟩ => ⟨Set.mem_univ _, ha⟩\n\n"}
{"name":"NormedAddGroupHom.norm_def","module":"Mathlib.Analysis.Normed.Group.Hom","initialProofState":"V₁ : Type u_2\nV₂ : Type u_3\ninst✝¹ : SeminormedAddCommGroup V₁\ninst✝ : SeminormedAddCommGroup V₂\nf : NormedAddGroupHom V₁ V₂\n⊢ Eq (Norm.norm f) (InfSet.sInf (setOf fun c => And (LE.le 0 c) (∀ (x : V₁), LE.le (Norm.norm (f x)) (HMul.hMul c (Norm.norm x)))))","decl":"theorem norm_def : ‖f‖ = sInf { c | 0 ≤ c ∧ ∀ x, ‖f x‖ ≤ c * ‖x‖ } :=\n  rfl\n\n-- So that invocations of `le_csInf` make sense: we show that the set of\n-- bounds is nonempty and bounded below.\n"}
{"name":"NormedAddGroupHom.bounds_nonempty","module":"Mathlib.Analysis.Normed.Group.Hom","initialProofState":"V₁ : Type u_2\nV₂ : Type u_3\ninst✝¹ : SeminormedAddCommGroup V₁\ninst✝ : SeminormedAddCommGroup V₂\nf : NormedAddGroupHom V₁ V₂\n⊢ Exists fun c => Membership.mem (setOf fun c => And (LE.le 0 c) (∀ (x : V₁), LE.le (Norm.norm (f x)) (HMul.hMul c (Norm.norm x)))) c","decl":"theorem bounds_nonempty {f : NormedAddGroupHom V₁ V₂} :\n    ∃ c, c ∈ { c | 0 ≤ c ∧ ∀ x, ‖f x‖ ≤ c * ‖x‖ } :=\n  let ⟨M, hMp, hMb⟩ := f.bound\n  ⟨M, le_of_lt hMp, hMb⟩\n\n"}
{"name":"NormedAddGroupHom.bounds_bddBelow","module":"Mathlib.Analysis.Normed.Group.Hom","initialProofState":"V₁ : Type u_2\nV₂ : Type u_3\ninst✝¹ : SeminormedAddCommGroup V₁\ninst✝ : SeminormedAddCommGroup V₂\nf : NormedAddGroupHom V₁ V₂\n⊢ BddBelow (setOf fun c => And (LE.le 0 c) (∀ (x : V₁), LE.le (Norm.norm (f x)) (HMul.hMul c (Norm.norm x))))","decl":"theorem bounds_bddBelow {f : NormedAddGroupHom V₁ V₂} :\n    BddBelow { c | 0 ≤ c ∧ ∀ x, ‖f x‖ ≤ c * ‖x‖ } :=\n  ⟨0, fun _ ⟨hn, _⟩ => hn⟩\n\n"}
{"name":"NormedAddGroupHom.opNorm_nonneg","module":"Mathlib.Analysis.Normed.Group.Hom","initialProofState":"V₁ : Type u_2\nV₂ : Type u_3\ninst✝¹ : SeminormedAddCommGroup V₁\ninst✝ : SeminormedAddCommGroup V₂\nf : NormedAddGroupHom V₁ V₂\n⊢ LE.le 0 (Norm.norm f)","decl":"theorem opNorm_nonneg : 0 ≤ ‖f‖ :=\n  le_csInf bounds_nonempty fun _ ⟨hx, _⟩ => hx\n\n"}
{"name":"NormedAddGroupHom.le_opNorm","module":"Mathlib.Analysis.Normed.Group.Hom","initialProofState":"V₁ : Type u_2\nV₂ : Type u_3\ninst✝¹ : SeminormedAddCommGroup V₁\ninst✝ : SeminormedAddCommGroup V₂\nf : NormedAddGroupHom V₁ V₂\nx : V₁\n⊢ LE.le (Norm.norm (f x)) (HMul.hMul (Norm.norm f) (Norm.norm x))","decl":"/-- The fundamental property of the operator norm: `‖f x‖ ≤ ‖f‖ * ‖x‖`. -/\ntheorem le_opNorm (x : V₁) : ‖f x‖ ≤ ‖f‖ * ‖x‖ := by\n  obtain ⟨C, _Cpos, hC⟩ := f.bound\n  replace hC := hC x\n  by_cases h : ‖x‖ = 0\n  · rwa [h, mul_zero] at hC ⊢\n  have hlt : 0 < ‖x‖ := lt_of_le_of_ne (norm_nonneg x) (Ne.symm h)\n  exact\n    (div_le_iff₀ hlt).mp\n      (le_csInf bounds_nonempty fun c ⟨_, hc⟩ => (div_le_iff₀ hlt).mpr <| by apply hc)\n\n"}
{"name":"NormedAddGroupHom.le_opNorm_of_le","module":"Mathlib.Analysis.Normed.Group.Hom","initialProofState":"V₁ : Type u_2\nV₂ : Type u_3\ninst✝¹ : SeminormedAddCommGroup V₁\ninst✝ : SeminormedAddCommGroup V₂\nf : NormedAddGroupHom V₁ V₂\nc : Real\nx : V₁\nh : LE.le (Norm.norm x) c\n⊢ LE.le (Norm.norm (f x)) (HMul.hMul (Norm.norm f) c)","decl":"theorem le_opNorm_of_le {c : ℝ} {x} (h : ‖x‖ ≤ c) : ‖f x‖ ≤ ‖f‖ * c :=\n  le_trans (f.le_opNorm x) (by gcongr; exact f.opNorm_nonneg)\n\n"}
{"name":"NormedAddGroupHom.le_of_opNorm_le","module":"Mathlib.Analysis.Normed.Group.Hom","initialProofState":"V₁ : Type u_2\nV₂ : Type u_3\ninst✝¹ : SeminormedAddCommGroup V₁\ninst✝ : SeminormedAddCommGroup V₂\nf : NormedAddGroupHom V₁ V₂\nc : Real\nh : LE.le (Norm.norm f) c\nx : V₁\n⊢ LE.le (Norm.norm (f x)) (HMul.hMul c (Norm.norm x))","decl":"theorem le_of_opNorm_le {c : ℝ} (h : ‖f‖ ≤ c) (x : V₁) : ‖f x‖ ≤ c * ‖x‖ :=\n  (f.le_opNorm x).trans (by gcongr)\n\n"}
{"name":"NormedAddGroupHom.lipschitz","module":"Mathlib.Analysis.Normed.Group.Hom","initialProofState":"V₁ : Type u_2\nV₂ : Type u_3\ninst✝¹ : SeminormedAddCommGroup V₁\ninst✝ : SeminormedAddCommGroup V₂\nf : NormedAddGroupHom V₁ V₂\n⊢ LipschitzWith ⟨Norm.norm f, ⋯⟩ ⇑f","decl":"/-- continuous linear maps are Lipschitz continuous. -/\ntheorem lipschitz : LipschitzWith ⟨‖f‖, opNorm_nonneg f⟩ f :=\n  LipschitzWith.of_dist_le_mul fun x y => by\n    rw [dist_eq_norm, dist_eq_norm, ← map_sub]\n    apply le_opNorm\n\n"}
{"name":"NormedAddGroupHom.uniformContinuous","module":"Mathlib.Analysis.Normed.Group.Hom","initialProofState":"V₁ : Type u_2\nV₂ : Type u_3\ninst✝¹ : SeminormedAddCommGroup V₁\ninst✝ : SeminormedAddCommGroup V₂\nf : NormedAddGroupHom V₁ V₂\n⊢ UniformContinuous ⇑f","decl":"protected theorem uniformContinuous (f : NormedAddGroupHom V₁ V₂) : UniformContinuous f :=\n  f.lipschitz.uniformContinuous\n\n"}
{"name":"NormedAddGroupHom.continuous","module":"Mathlib.Analysis.Normed.Group.Hom","initialProofState":"V₁ : Type u_2\nV₂ : Type u_3\ninst✝¹ : SeminormedAddCommGroup V₁\ninst✝ : SeminormedAddCommGroup V₂\nf : NormedAddGroupHom V₁ V₂\n⊢ Continuous ⇑f","decl":"@[continuity]\nprotected theorem continuous (f : NormedAddGroupHom V₁ V₂) : Continuous f :=\n  f.uniformContinuous.continuous\n\n"}
{"name":"NormedAddGroupHom.ratio_le_opNorm","module":"Mathlib.Analysis.Normed.Group.Hom","initialProofState":"V₁ : Type u_2\nV₂ : Type u_3\ninst✝¹ : SeminormedAddCommGroup V₁\ninst✝ : SeminormedAddCommGroup V₂\nf : NormedAddGroupHom V₁ V₂\nx : V₁\n⊢ LE.le (HDiv.hDiv (Norm.norm (f x)) (Norm.norm x)) (Norm.norm f)","decl":"theorem ratio_le_opNorm (x : V₁) : ‖f x‖ / ‖x‖ ≤ ‖f‖ :=\n  div_le_of_le_mul₀ (norm_nonneg _) f.opNorm_nonneg (le_opNorm _ _)\n\n"}
{"name":"NormedAddGroupHom.opNorm_le_bound","module":"Mathlib.Analysis.Normed.Group.Hom","initialProofState":"V₁ : Type u_2\nV₂ : Type u_3\ninst✝¹ : SeminormedAddCommGroup V₁\ninst✝ : SeminormedAddCommGroup V₂\nf : NormedAddGroupHom V₁ V₂\nM : Real\nhMp : LE.le 0 M\nhM : ∀ (x : V₁), LE.le (Norm.norm (f x)) (HMul.hMul M (Norm.norm x))\n⊢ LE.le (Norm.norm f) M","decl":"/-- If one controls the norm of every `f x`, then one controls the norm of `f`. -/\ntheorem opNorm_le_bound {M : ℝ} (hMp : 0 ≤ M) (hM : ∀ x, ‖f x‖ ≤ M * ‖x‖) : ‖f‖ ≤ M :=\n  csInf_le bounds_bddBelow ⟨hMp, hM⟩\n\n"}
{"name":"NormedAddGroupHom.opNorm_eq_of_bounds","module":"Mathlib.Analysis.Normed.Group.Hom","initialProofState":"V₁ : Type u_2\nV₂ : Type u_3\ninst✝¹ : SeminormedAddCommGroup V₁\ninst✝ : SeminormedAddCommGroup V₂\nf : NormedAddGroupHom V₁ V₂\nM : Real\nM_nonneg : LE.le 0 M\nh_above : ∀ (x : V₁), LE.le (Norm.norm (f x)) (HMul.hMul M (Norm.norm x))\nh_below : ∀ (N : Real), GE.ge N 0 → (∀ (x : V₁), LE.le (Norm.norm (f x)) (HMul.hMul N (Norm.norm x))) → LE.le M N\n⊢ Eq (Norm.norm f) M","decl":"theorem opNorm_eq_of_bounds {M : ℝ} (M_nonneg : 0 ≤ M) (h_above : ∀ x, ‖f x‖ ≤ M * ‖x‖)\n    (h_below : ∀ N ≥ 0, (∀ x, ‖f x‖ ≤ N * ‖x‖) → M ≤ N) : ‖f‖ = M :=\n  le_antisymm (f.opNorm_le_bound M_nonneg h_above)\n    ((le_csInf_iff NormedAddGroupHom.bounds_bddBelow ⟨M, M_nonneg, h_above⟩).mpr\n      fun N ⟨N_nonneg, hN⟩ => h_below N N_nonneg hN)\n\n"}
{"name":"NormedAddGroupHom.opNorm_le_of_lipschitz","module":"Mathlib.Analysis.Normed.Group.Hom","initialProofState":"V₁ : Type u_2\nV₂ : Type u_3\ninst✝¹ : SeminormedAddCommGroup V₁\ninst✝ : SeminormedAddCommGroup V₂\nf : NormedAddGroupHom V₁ V₂\nK : NNReal\nhf : LipschitzWith K ⇑f\n⊢ LE.le (Norm.norm f) ↑K","decl":"theorem opNorm_le_of_lipschitz {f : NormedAddGroupHom V₁ V₂} {K : ℝ≥0} (hf : LipschitzWith K f) :\n    ‖f‖ ≤ K :=\n  f.opNorm_le_bound K.2 fun x => by simpa only [dist_zero_right, map_zero] using hf.dist_le_mul x 0\n\n"}
{"name":"NormedAddGroupHom.mkNormedAddGroupHom_norm_le","module":"Mathlib.Analysis.Normed.Group.Hom","initialProofState":"V₁ : Type u_2\nV₂ : Type u_3\ninst✝¹ : SeminormedAddCommGroup V₁\ninst✝ : SeminormedAddCommGroup V₂\nf : AddMonoidHom V₁ V₂\nC : Real\nhC : LE.le 0 C\nh : ∀ (x : V₁), LE.le (Norm.norm (f x)) (HMul.hMul C (Norm.norm x))\n⊢ LE.le (Norm.norm (f.mkNormedAddGroupHom C h)) C","decl":"/-- If a bounded group homomorphism map is constructed from a group homomorphism via the constructor\n`AddMonoidHom.mkNormedAddGroupHom`, then its norm is bounded by the bound given to the constructor\nif it is nonnegative. -/\ntheorem mkNormedAddGroupHom_norm_le (f : V₁ →+ V₂) {C : ℝ} (hC : 0 ≤ C) (h : ∀ x, ‖f x‖ ≤ C * ‖x‖) :\n    ‖f.mkNormedAddGroupHom C h‖ ≤ C :=\n  opNorm_le_bound _ hC h\n\n"}
{"name":"NormedAddGroupHom.ofLipschitz_norm_le","module":"Mathlib.Analysis.Normed.Group.Hom","initialProofState":"V₁ : Type u_2\nV₂ : Type u_3\ninst✝¹ : SeminormedAddCommGroup V₁\ninst✝ : SeminormedAddCommGroup V₂\nf : AddMonoidHom V₁ V₂\nK : NNReal\nh : LipschitzWith K ⇑f\n⊢ LE.le (Norm.norm (NormedAddGroupHom.ofLipschitz f h)) ↑K","decl":"/-- If a bounded group homomorphism map is constructed from a group homomorphism via the constructor\n`NormedAddGroupHom.ofLipschitz`, then its norm is bounded by the bound given to the constructor. -/\ntheorem ofLipschitz_norm_le (f : V₁ →+ V₂) {K : ℝ≥0} (h : LipschitzWith K f) :\n    ‖ofLipschitz f h‖ ≤ K :=\n  mkNormedAddGroupHom_norm_le f K.coe_nonneg _\n\n"}
{"name":"NormedAddGroupHom.mkNormedAddGroupHom_norm_le'","module":"Mathlib.Analysis.Normed.Group.Hom","initialProofState":"V₁ : Type u_2\nV₂ : Type u_3\ninst✝¹ : SeminormedAddCommGroup V₁\ninst✝ : SeminormedAddCommGroup V₂\nf : AddMonoidHom V₁ V₂\nC : Real\nh : ∀ (x : V₁), LE.le (Norm.norm (f x)) (HMul.hMul C (Norm.norm x))\n⊢ LE.le (Norm.norm (f.mkNormedAddGroupHom C h)) (Max.max C 0)","decl":"/-- If a bounded group homomorphism map is constructed from a group homomorphism\nvia the constructor `AddMonoidHom.mkNormedAddGroupHom`, then its norm is bounded by the bound\ngiven to the constructor or zero if this bound is negative. -/\ntheorem mkNormedAddGroupHom_norm_le' (f : V₁ →+ V₂) {C : ℝ} (h : ∀ x, ‖f x‖ ≤ C * ‖x‖) :\n    ‖f.mkNormedAddGroupHom C h‖ ≤ max C 0 :=\n  opNorm_le_bound _ (le_max_right _ _) fun x =>\n    (h x).trans <| by gcongr; apply le_max_left\n\n"}
{"name":"AddMonoidHom.mkNormedAddGroupHom_norm_le","module":"Mathlib.Analysis.Normed.Group.Hom","initialProofState":"V₁ : Type u_2\nV₂ : Type u_3\ninst✝¹ : SeminormedAddCommGroup V₁\ninst✝ : SeminormedAddCommGroup V₂\nf : AddMonoidHom V₁ V₂\nC : Real\nhC : LE.le 0 C\nh : ∀ (x : V₁), LE.le (Norm.norm (f x)) (HMul.hMul C (Norm.norm x))\n⊢ LE.le (Norm.norm (f.mkNormedAddGroupHom C h)) C","decl":"alias _root_.AddMonoidHom.mkNormedAddGroupHom_norm_le := mkNormedAddGroupHom_norm_le\n\n"}
{"name":"AddMonoidHom.mkNormedAddGroupHom_norm_le'","module":"Mathlib.Analysis.Normed.Group.Hom","initialProofState":"V₁ : Type u_2\nV₂ : Type u_3\ninst✝¹ : SeminormedAddCommGroup V₁\ninst✝ : SeminormedAddCommGroup V₂\nf : AddMonoidHom V₁ V₂\nC : Real\nh : ∀ (x : V₁), LE.le (Norm.norm (f x)) (HMul.hMul C (Norm.norm x))\n⊢ LE.le (Norm.norm (f.mkNormedAddGroupHom C h)) (Max.max C 0)","decl":"alias _root_.AddMonoidHom.mkNormedAddGroupHom_norm_le' := mkNormedAddGroupHom_norm_le'\n\n"}
{"name":"NormedAddGroupHom.opNorm_add_le","module":"Mathlib.Analysis.Normed.Group.Hom","initialProofState":"V₁ : Type u_2\nV₂ : Type u_3\ninst✝¹ : SeminormedAddCommGroup V₁\ninst✝ : SeminormedAddCommGroup V₂\nf g : NormedAddGroupHom V₁ V₂\n⊢ LE.le (Norm.norm (HAdd.hAdd f g)) (HAdd.hAdd (Norm.norm f) (Norm.norm g))","decl":"/-- The operator norm satisfies the triangle inequality. -/\ntheorem opNorm_add_le : ‖f + g‖ ≤ ‖f‖ + ‖g‖ :=\n  mkNormedAddGroupHom_norm_le _ (add_nonneg (opNorm_nonneg _) (opNorm_nonneg _)) _\n\n-- Porting note: this library note doesn't seem to apply anymore\n/-\nlibrary_note \"addition on function coercions\"/--\nTerms containing `@has_add.add (has_coe_to_fun.F ...) pi.has_add`\nseem to cause leanchecker to [crash due to an out-of-memory\ncondition](https://github.com/leanprover-community/lean/issues/543).\nAs a workaround, we add a type annotation: `(f + g : V₁ → V₂)`\n-/\n-/\n\n"}
{"name":"NormedAddGroupHom.coe_add","module":"Mathlib.Analysis.Normed.Group.Hom","initialProofState":"V₁ : Type u_2\nV₂ : Type u_3\ninst✝¹ : SeminormedAddCommGroup V₁\ninst✝ : SeminormedAddCommGroup V₂\nf g : NormedAddGroupHom V₁ V₂\n⊢ Eq (⇑(HAdd.hAdd f g)) (HAdd.hAdd ⇑f ⇑g)","decl":"@[simp]\ntheorem coe_add (f g : NormedAddGroupHom V₁ V₂) : ⇑(f + g) = f + g :=\n  rfl\n\n"}
{"name":"NormedAddGroupHom.add_apply","module":"Mathlib.Analysis.Normed.Group.Hom","initialProofState":"V₁ : Type u_2\nV₂ : Type u_3\ninst✝¹ : SeminormedAddCommGroup V₁\ninst✝ : SeminormedAddCommGroup V₂\nf g : NormedAddGroupHom V₁ V₂\nv : V₁\n⊢ Eq ((HAdd.hAdd f g) v) (HAdd.hAdd (f v) (g v))","decl":"@[simp]\ntheorem add_apply (f g : NormedAddGroupHom V₁ V₂) (v : V₁) :\n    (f + g) v = f v + g v :=\n  rfl\n\n"}
{"name":"NormedAddGroupHom.opNorm_zero","module":"Mathlib.Analysis.Normed.Group.Hom","initialProofState":"V₁ : Type u_2\nV₂ : Type u_3\ninst✝¹ : SeminormedAddCommGroup V₁\ninst✝ : SeminormedAddCommGroup V₂\n⊢ Eq (Norm.norm 0) 0","decl":"/-- The norm of the `0` operator is `0`. -/\ntheorem opNorm_zero : ‖(0 : NormedAddGroupHom V₁ V₂)‖ = 0 :=\n  le_antisymm\n    (csInf_le bounds_bddBelow\n      ⟨ge_of_eq rfl, fun _ =>\n        le_of_eq\n          (by\n            rw [zero_mul]\n            exact norm_zero)⟩)\n    (opNorm_nonneg _)\n\n"}
{"name":"NormedAddGroupHom.opNorm_zero_iff","module":"Mathlib.Analysis.Normed.Group.Hom","initialProofState":"V₁ : Type u_5\nV₂ : Type u_6\ninst✝¹ : NormedAddCommGroup V₁\ninst✝ : NormedAddCommGroup V₂\nf : NormedAddGroupHom V₁ V₂\n⊢ Iff (Eq (Norm.norm f) 0) (Eq f 0)","decl":"/-- For normed groups, an operator is zero iff its norm vanishes. -/\ntheorem opNorm_zero_iff {V₁ V₂ : Type*} [NormedAddCommGroup V₁] [NormedAddCommGroup V₂]\n    {f : NormedAddGroupHom V₁ V₂} : ‖f‖ = 0 ↔ f = 0 :=\n  Iff.intro\n    (fun hn =>\n      ext fun x =>\n        norm_le_zero_iff.1\n          (calc\n            _ ≤ ‖f‖ * ‖x‖ := le_opNorm _ _\n            _ = _ := by rw [hn, zero_mul]\n            ))\n    fun hf => by rw [hf, opNorm_zero]\n\n"}
{"name":"NormedAddGroupHom.coe_zero","module":"Mathlib.Analysis.Normed.Group.Hom","initialProofState":"V₁ : Type u_2\nV₂ : Type u_3\ninst✝¹ : SeminormedAddCommGroup V₁\ninst✝ : SeminormedAddCommGroup V₂\n⊢ Eq (⇑0) 0","decl":"@[simp]\ntheorem coe_zero : ⇑(0 : NormedAddGroupHom V₁ V₂) = 0 :=\n  rfl\n\n"}
{"name":"NormedAddGroupHom.zero_apply","module":"Mathlib.Analysis.Normed.Group.Hom","initialProofState":"V₁ : Type u_2\nV₂ : Type u_3\ninst✝¹ : SeminormedAddCommGroup V₁\ninst✝ : SeminormedAddCommGroup V₂\nv : V₁\n⊢ Eq (0 v) 0","decl":"@[simp]\ntheorem zero_apply (v : V₁) : (0 : NormedAddGroupHom V₁ V₂) v = 0 :=\n  rfl\n\n"}
{"name":"NormedAddGroupHom.id_apply","module":"Mathlib.Analysis.Normed.Group.Hom","initialProofState":"V : Type u_1\ninst✝ : SeminormedAddCommGroup V\na✝ : V\n⊢ Eq ((NormedAddGroupHom.id V) a✝) a✝","decl":"/-- The identity as a continuous normed group hom. -/\n@[simps!]\ndef id : NormedAddGroupHom V V :=\n  (AddMonoidHom.id V).mkNormedAddGroupHom 1 (by simp [le_refl])\n\n"}
{"name":"NormedAddGroupHom.norm_id_le","module":"Mathlib.Analysis.Normed.Group.Hom","initialProofState":"V : Type u_1\ninst✝ : SeminormedAddCommGroup V\n⊢ LE.le (Norm.norm (NormedAddGroupHom.id V)) 1","decl":"/-- The norm of the identity is at most `1`. It is in fact `1`, except when the norm of every\nelement vanishes, where it is `0`. (Since we are working with seminorms this can happen even if the\nspace is non-trivial.) It means that one can not do better than an inequality in general. -/\ntheorem norm_id_le : ‖(id V : NormedAddGroupHom V V)‖ ≤ 1 :=\n  opNorm_le_bound _ zero_le_one fun x => by simp\n\n"}
{"name":"NormedAddGroupHom.norm_id_of_nontrivial_seminorm","module":"Mathlib.Analysis.Normed.Group.Hom","initialProofState":"V : Type u_1\ninst✝ : SeminormedAddCommGroup V\nh : Exists fun x => Ne (Norm.norm x) 0\n⊢ Eq (Norm.norm (NormedAddGroupHom.id V)) 1","decl":"/-- If there is an element with norm different from `0`, then the norm of the identity equals `1`.\n(Since we are working with seminorms supposing that the space is non-trivial is not enough.) -/\ntheorem norm_id_of_nontrivial_seminorm (h : ∃ x : V, ‖x‖ ≠ 0) : ‖id V‖ = 1 :=\n  le_antisymm (norm_id_le V) <| by\n    let ⟨x, hx⟩ := h\n    have := (id V).ratio_le_opNorm x\n    rwa [id_apply, div_self hx] at this\n\n"}
{"name":"NormedAddGroupHom.norm_id","module":"Mathlib.Analysis.Normed.Group.Hom","initialProofState":"V : Type u_5\ninst✝¹ : NormedAddCommGroup V\ninst✝ : Nontrivial V\n⊢ Eq (Norm.norm (NormedAddGroupHom.id V)) 1","decl":"/-- If a normed space is non-trivial, then the norm of the identity equals `1`. -/\ntheorem norm_id {V : Type*} [NormedAddCommGroup V] [Nontrivial V] : ‖id V‖ = 1 := by\n  refine norm_id_of_nontrivial_seminorm V ?_\n  obtain ⟨x, hx⟩ := exists_ne (0 : V)\n  exact ⟨x, ne_of_gt (norm_pos_iff.2 hx)⟩\n\n"}
{"name":"NormedAddGroupHom.coe_id","module":"Mathlib.Analysis.Normed.Group.Hom","initialProofState":"V : Type u_1\ninst✝ : SeminormedAddCommGroup V\n⊢ Eq (⇑(NormedAddGroupHom.id V)) id","decl":"theorem coe_id : (NormedAddGroupHom.id V : V → V) = _root_.id :=\n  rfl\n\n"}
{"name":"NormedAddGroupHom.coe_neg","module":"Mathlib.Analysis.Normed.Group.Hom","initialProofState":"V₁ : Type u_2\nV₂ : Type u_3\ninst✝¹ : SeminormedAddCommGroup V₁\ninst✝ : SeminormedAddCommGroup V₂\nf : NormedAddGroupHom V₁ V₂\n⊢ Eq (⇑(Neg.neg f)) (Neg.neg ⇑f)","decl":"@[simp]\ntheorem coe_neg (f : NormedAddGroupHom V₁ V₂) : ⇑(-f) = -f :=\n  rfl\n\n"}
{"name":"NormedAddGroupHom.neg_apply","module":"Mathlib.Analysis.Normed.Group.Hom","initialProofState":"V₁ : Type u_2\nV₂ : Type u_3\ninst✝¹ : SeminormedAddCommGroup V₁\ninst✝ : SeminormedAddCommGroup V₂\nf : NormedAddGroupHom V₁ V₂\nv : V₁\n⊢ Eq ((Neg.neg f) v) (Neg.neg (f v))","decl":"@[simp]\ntheorem neg_apply (f : NormedAddGroupHom V₁ V₂) (v : V₁) :\n    (-f : NormedAddGroupHom V₁ V₂) v = -f v :=\n  rfl\n\n"}
{"name":"NormedAddGroupHom.opNorm_neg","module":"Mathlib.Analysis.Normed.Group.Hom","initialProofState":"V₁ : Type u_2\nV₂ : Type u_3\ninst✝¹ : SeminormedAddCommGroup V₁\ninst✝ : SeminormedAddCommGroup V₂\nf : NormedAddGroupHom V₁ V₂\n⊢ Eq (Norm.norm (Neg.neg f)) (Norm.norm f)","decl":"theorem opNorm_neg (f : NormedAddGroupHom V₁ V₂) : ‖-f‖ = ‖f‖ := by\n  simp only [norm_def, coe_neg, norm_neg, Pi.neg_apply]\n\n"}
{"name":"NormedAddGroupHom.coe_sub","module":"Mathlib.Analysis.Normed.Group.Hom","initialProofState":"V₁ : Type u_2\nV₂ : Type u_3\ninst✝¹ : SeminormedAddCommGroup V₁\ninst✝ : SeminormedAddCommGroup V₂\nf g : NormedAddGroupHom V₁ V₂\n⊢ Eq (⇑(HSub.hSub f g)) (HSub.hSub ⇑f ⇑g)","decl":"@[simp]\ntheorem coe_sub (f g : NormedAddGroupHom V₁ V₂) : ⇑(f - g) = f - g :=\n  rfl\n\n"}
{"name":"NormedAddGroupHom.sub_apply","module":"Mathlib.Analysis.Normed.Group.Hom","initialProofState":"V₁ : Type u_2\nV₂ : Type u_3\ninst✝¹ : SeminormedAddCommGroup V₁\ninst✝ : SeminormedAddCommGroup V₂\nf g : NormedAddGroupHom V₁ V₂\nv : V₁\n⊢ Eq ((HSub.hSub f g) v) (HSub.hSub (f v) (g v))","decl":"@[simp]\ntheorem sub_apply (f g : NormedAddGroupHom V₁ V₂) (v : V₁) :\n    (f - g : NormedAddGroupHom V₁ V₂) v = f v - g v :=\n  rfl\n\n"}
{"name":"NormedAddGroupHom.coe_smul","module":"Mathlib.Analysis.Normed.Group.Hom","initialProofState":"V₁ : Type u_2\nV₂ : Type u_3\ninst✝⁵ : SeminormedAddCommGroup V₁\ninst✝⁴ : SeminormedAddCommGroup V₂\nR : Type u_5\ninst✝³ : MonoidWithZero R\ninst✝² : DistribMulAction R V₂\ninst✝¹ : PseudoMetricSpace R\ninst✝ : BoundedSMul R V₂\nr : R\nf : NormedAddGroupHom V₁ V₂\n⊢ Eq (⇑(HSMul.hSMul r f)) (HSMul.hSMul r ⇑f)","decl":"@[simp]\ntheorem coe_smul (r : R) (f : NormedAddGroupHom V₁ V₂) : ⇑(r • f) = r • ⇑f :=\n  rfl\n\n"}
{"name":"NormedAddGroupHom.smul_apply","module":"Mathlib.Analysis.Normed.Group.Hom","initialProofState":"V₁ : Type u_2\nV₂ : Type u_3\ninst✝⁵ : SeminormedAddCommGroup V₁\ninst✝⁴ : SeminormedAddCommGroup V₂\nR : Type u_5\ninst✝³ : MonoidWithZero R\ninst✝² : DistribMulAction R V₂\ninst✝¹ : PseudoMetricSpace R\ninst✝ : BoundedSMul R V₂\nr : R\nf : NormedAddGroupHom V₁ V₂\nv : V₁\n⊢ Eq ((HSMul.hSMul r f) v) (HSMul.hSMul r (f v))","decl":"@[simp]\ntheorem smul_apply (r : R) (f : NormedAddGroupHom V₁ V₂) (v : V₁) : (r • f) v = r • f v :=\n  rfl\n\n"}
{"name":"NormedAddGroupHom.smulCommClass","module":"Mathlib.Analysis.Normed.Group.Hom","initialProofState":"V₁ : Type u_2\nV₂ : Type u_3\ninst✝⁸ : SeminormedAddCommGroup V₁\ninst✝⁷ : SeminormedAddCommGroup V₂\nR : Type u_5\nR' : Type u_6\ninst✝⁶ : MonoidWithZero R\ninst✝⁵ : DistribMulAction R V₂\ninst✝⁴ : PseudoMetricSpace R\ninst✝³ : MonoidWithZero R'\ninst✝² : DistribMulAction R' V₂\ninst✝¹ : PseudoMetricSpace R'\ninst✝ : SMulCommClass R R' V₂\n⊢ SMulCommClass R R' (NormedAddGroupHom V₁ V₂)","decl":"instance smulCommClass [SMulCommClass R R' V₂] :\n    SMulCommClass R R' (NormedAddGroupHom V₁ V₂) where\n  smul_comm _ _ _ := ext fun _ => smul_comm _ _ _\n\n"}
{"name":"NormedAddGroupHom.isScalarTower","module":"Mathlib.Analysis.Normed.Group.Hom","initialProofState":"V₁ : Type u_2\nV₂ : Type u_3\ninst✝⁹ : SeminormedAddCommGroup V₁\ninst✝⁸ : SeminormedAddCommGroup V₂\nR : Type u_5\nR' : Type u_6\ninst✝⁷ : MonoidWithZero R\ninst✝⁶ : DistribMulAction R V₂\ninst✝⁵ : PseudoMetricSpace R\ninst✝⁴ : MonoidWithZero R'\ninst✝³ : DistribMulAction R' V₂\ninst✝² : PseudoMetricSpace R'\ninst✝¹ : SMul R R'\ninst✝ : IsScalarTower R R' V₂\n⊢ IsScalarTower R R' (NormedAddGroupHom V₁ V₂)","decl":"instance isScalarTower [SMul R R'] [IsScalarTower R R' V₂] :\n    IsScalarTower R R' (NormedAddGroupHom V₁ V₂) where\n  smul_assoc _ _ _ := ext fun _ => smul_assoc _ _ _\n\n"}
{"name":"NormedAddGroupHom.isCentralScalar","module":"Mathlib.Analysis.Normed.Group.Hom","initialProofState":"V₁ : Type u_2\nV₂ : Type u_3\ninst✝⁶ : SeminormedAddCommGroup V₁\ninst✝⁵ : SeminormedAddCommGroup V₂\nR : Type u_5\ninst✝⁴ : MonoidWithZero R\ninst✝³ : DistribMulAction R V₂\ninst✝² : PseudoMetricSpace R\ninst✝¹ : DistribMulAction (MulOpposite R) V₂\ninst✝ : IsCentralScalar R V₂\n⊢ IsCentralScalar R (NormedAddGroupHom V₁ V₂)","decl":"instance isCentralScalar [DistribMulAction Rᵐᵒᵖ V₂] [IsCentralScalar R V₂] :\n    IsCentralScalar R (NormedAddGroupHom V₁ V₂) where\n  op_smul_eq_smul _ _ := ext fun _ => op_smul_eq_smul _ _\n\n"}
{"name":"NormedAddGroupHom.coe_nsmul","module":"Mathlib.Analysis.Normed.Group.Hom","initialProofState":"V₁ : Type u_2\nV₂ : Type u_3\ninst✝¹ : SeminormedAddCommGroup V₁\ninst✝ : SeminormedAddCommGroup V₂\nr : Nat\nf : NormedAddGroupHom V₁ V₂\n⊢ Eq (⇑(HSMul.hSMul r f)) (HSMul.hSMul r ⇑f)","decl":"@[simp]\ntheorem coe_nsmul (r : ℕ) (f : NormedAddGroupHom V₁ V₂) : ⇑(r • f) = r • ⇑f :=\n  rfl\n\n"}
{"name":"NormedAddGroupHom.nsmul_apply","module":"Mathlib.Analysis.Normed.Group.Hom","initialProofState":"V₁ : Type u_2\nV₂ : Type u_3\ninst✝¹ : SeminormedAddCommGroup V₁\ninst✝ : SeminormedAddCommGroup V₂\nr : Nat\nf : NormedAddGroupHom V₁ V₂\nv : V₁\n⊢ Eq ((HSMul.hSMul r f) v) (HSMul.hSMul r (f v))","decl":"@[simp]\ntheorem nsmul_apply (r : ℕ) (f : NormedAddGroupHom V₁ V₂) (v : V₁) : (r • f) v = r • f v :=\n  rfl\n\n"}
{"name":"NormedAddGroupHom.coe_zsmul","module":"Mathlib.Analysis.Normed.Group.Hom","initialProofState":"V₁ : Type u_2\nV₂ : Type u_3\ninst✝¹ : SeminormedAddCommGroup V₁\ninst✝ : SeminormedAddCommGroup V₂\nr : Int\nf : NormedAddGroupHom V₁ V₂\n⊢ Eq (⇑(HSMul.hSMul r f)) (HSMul.hSMul r ⇑f)","decl":"@[simp]\ntheorem coe_zsmul (r : ℤ) (f : NormedAddGroupHom V₁ V₂) : ⇑(r • f) = r • ⇑f :=\n  rfl\n\n"}
{"name":"NormedAddGroupHom.zsmul_apply","module":"Mathlib.Analysis.Normed.Group.Hom","initialProofState":"V₁ : Type u_2\nV₂ : Type u_3\ninst✝¹ : SeminormedAddCommGroup V₁\ninst✝ : SeminormedAddCommGroup V₂\nr : Int\nf : NormedAddGroupHom V₁ V₂\nv : V₁\n⊢ Eq ((HSMul.hSMul r f) v) (HSMul.hSMul r (f v))","decl":"@[simp]\ntheorem zsmul_apply (r : ℤ) (f : NormedAddGroupHom V₁ V₂) (v : V₁) : (r • f) v = r • f v :=\n  rfl\n\n"}
{"name":"NormedAddGroupHom.coeAddHom_apply","module":"Mathlib.Analysis.Normed.Group.Hom","initialProofState":"V₁ : Type u_2\nV₂ : Type u_3\ninst✝¹ : SeminormedAddCommGroup V₁\ninst✝ : SeminormedAddCommGroup V₂\na✝ : NormedAddGroupHom V₁ V₂\na : V₁\n⊢ Eq (NormedAddGroupHom.coeAddHom a✝ a) (a✝ a)","decl":"/-- Coercion of a `NormedAddGroupHom` is an `AddMonoidHom`. Similar to `AddMonoidHom.coeFn`. -/\n@[simps]\ndef coeAddHom : NormedAddGroupHom V₁ V₂ →+ V₁ → V₂ where\n  toFun := DFunLike.coe\n  map_zero' := coe_zero\n  map_add' := coe_add\n\n"}
{"name":"NormedAddGroupHom.coe_sum","module":"Mathlib.Analysis.Normed.Group.Hom","initialProofState":"V₁ : Type u_2\nV₂ : Type u_3\ninst✝¹ : SeminormedAddCommGroup V₁\ninst✝ : SeminormedAddCommGroup V₂\nι : Type u_5\ns : Finset ι\nf : ι → NormedAddGroupHom V₁ V₂\n⊢ Eq (⇑(s.sum fun i => f i)) (s.sum fun i => ⇑(f i))","decl":"@[simp]\ntheorem coe_sum {ι : Type*} (s : Finset ι) (f : ι → NormedAddGroupHom V₁ V₂) :\n    ⇑(∑ i ∈ s, f i) = ∑ i ∈ s, (f i : V₁ → V₂) :=\n  map_sum coeAddHom f s\n\n"}
{"name":"NormedAddGroupHom.sum_apply","module":"Mathlib.Analysis.Normed.Group.Hom","initialProofState":"V₁ : Type u_2\nV₂ : Type u_3\ninst✝¹ : SeminormedAddCommGroup V₁\ninst✝ : SeminormedAddCommGroup V₂\nι : Type u_5\ns : Finset ι\nf : ι → NormedAddGroupHom V₁ V₂\nv : V₁\n⊢ Eq ((s.sum fun i => f i) v) (s.sum fun i => (f i) v)","decl":"theorem sum_apply {ι : Type*} (s : Finset ι) (f : ι → NormedAddGroupHom V₁ V₂) (v : V₁) :\n    (∑ i ∈ s, f i) v = ∑ i ∈ s, f i v := by simp only [coe_sum, Finset.sum_apply]\n\n"}
{"name":"NormedAddGroupHom.comp_apply","module":"Mathlib.Analysis.Normed.Group.Hom","initialProofState":"V₁ : Type u_2\nV₂ : Type u_3\nV₃ : Type u_4\ninst✝² : SeminormedAddCommGroup V₁\ninst✝¹ : SeminormedAddCommGroup V₂\ninst✝ : SeminormedAddCommGroup V₃\ng : NormedAddGroupHom V₂ V₃\nf : NormedAddGroupHom V₁ V₂\na✝ : V₁\n⊢ Eq ((g.comp f) a✝) (g (f a✝))","decl":"/-- The composition of continuous normed group homs. -/\n@[simps!]\nprotected def comp (g : NormedAddGroupHom V₂ V₃) (f : NormedAddGroupHom V₁ V₂) :\n    NormedAddGroupHom V₁ V₃ :=\n  (g.toAddMonoidHom.comp f.toAddMonoidHom).mkNormedAddGroupHom (‖g‖ * ‖f‖) fun v =>\n    calc\n      ‖g (f v)‖ ≤ ‖g‖ * ‖f v‖ := le_opNorm _ _\n      _ ≤ ‖g‖ * (‖f‖ * ‖v‖) := by gcongr; apply le_opNorm\n      _ = ‖g‖ * ‖f‖ * ‖v‖ := by rw [mul_assoc]\n\n"}
{"name":"NormedAddGroupHom.norm_comp_le","module":"Mathlib.Analysis.Normed.Group.Hom","initialProofState":"V₁ : Type u_2\nV₂ : Type u_3\nV₃ : Type u_4\ninst✝² : SeminormedAddCommGroup V₁\ninst✝¹ : SeminormedAddCommGroup V₂\ninst✝ : SeminormedAddCommGroup V₃\ng : NormedAddGroupHom V₂ V₃\nf : NormedAddGroupHom V₁ V₂\n⊢ LE.le (Norm.norm (g.comp f)) (HMul.hMul (Norm.norm g) (Norm.norm f))","decl":"theorem norm_comp_le (g : NormedAddGroupHom V₂ V₃) (f : NormedAddGroupHom V₁ V₂) :\n    ‖g.comp f‖ ≤ ‖g‖ * ‖f‖ :=\n  mkNormedAddGroupHom_norm_le _ (mul_nonneg (opNorm_nonneg _) (opNorm_nonneg _)) _\n\n"}
{"name":"NormedAddGroupHom.norm_comp_le_of_le","module":"Mathlib.Analysis.Normed.Group.Hom","initialProofState":"V₁ : Type u_2\nV₂ : Type u_3\nV₃ : Type u_4\ninst✝² : SeminormedAddCommGroup V₁\ninst✝¹ : SeminormedAddCommGroup V₂\ninst✝ : SeminormedAddCommGroup V₃\nf : NormedAddGroupHom V₁ V₂\ng : NormedAddGroupHom V₂ V₃\nC₁ C₂ : Real\nhg : LE.le (Norm.norm g) C₂\nhf : LE.le (Norm.norm f) C₁\n⊢ LE.le (Norm.norm (g.comp f)) (HMul.hMul C₂ C₁)","decl":"theorem norm_comp_le_of_le {g : NormedAddGroupHom V₂ V₃} {C₁ C₂ : ℝ} (hg : ‖g‖ ≤ C₂)\n    (hf : ‖f‖ ≤ C₁) : ‖g.comp f‖ ≤ C₂ * C₁ :=\n  le_trans (norm_comp_le g f) <| by gcongr; exact le_trans (norm_nonneg _) hg\n\n"}
{"name":"NormedAddGroupHom.norm_comp_le_of_le'","module":"Mathlib.Analysis.Normed.Group.Hom","initialProofState":"V₁ : Type u_2\nV₂ : Type u_3\nV₃ : Type u_4\ninst✝² : SeminormedAddCommGroup V₁\ninst✝¹ : SeminormedAddCommGroup V₂\ninst✝ : SeminormedAddCommGroup V₃\nf : NormedAddGroupHom V₁ V₂\ng : NormedAddGroupHom V₂ V₃\nC₁ C₂ C₃ : Real\nh : Eq C₃ (HMul.hMul C₂ C₁)\nhg : LE.le (Norm.norm g) C₂\nhf : LE.le (Norm.norm f) C₁\n⊢ LE.le (Norm.norm (g.comp f)) C₃","decl":"theorem norm_comp_le_of_le' {g : NormedAddGroupHom V₂ V₃} (C₁ C₂ C₃ : ℝ) (h : C₃ = C₂ * C₁)\n    (hg : ‖g‖ ≤ C₂) (hf : ‖f‖ ≤ C₁) : ‖g.comp f‖ ≤ C₃ := by\n  rw [h]\n  exact norm_comp_le_of_le hg hf\n\n"}
{"name":"NormedAddGroupHom.comp_zero","module":"Mathlib.Analysis.Normed.Group.Hom","initialProofState":"V₁ : Type u_2\nV₂ : Type u_3\nV₃ : Type u_4\ninst✝² : SeminormedAddCommGroup V₁\ninst✝¹ : SeminormedAddCommGroup V₂\ninst✝ : SeminormedAddCommGroup V₃\nf : NormedAddGroupHom V₂ V₃\n⊢ Eq (f.comp 0) 0","decl":"@[simp]\ntheorem comp_zero (f : NormedAddGroupHom V₂ V₃) : f.comp (0 : NormedAddGroupHom V₁ V₂) = 0 := by\n  ext\n  exact map_zero f\n\n"}
{"name":"NormedAddGroupHom.zero_comp","module":"Mathlib.Analysis.Normed.Group.Hom","initialProofState":"V₁ : Type u_2\nV₂ : Type u_3\nV₃ : Type u_4\ninst✝² : SeminormedAddCommGroup V₁\ninst✝¹ : SeminormedAddCommGroup V₂\ninst✝ : SeminormedAddCommGroup V₃\nf : NormedAddGroupHom V₁ V₂\n⊢ Eq (NormedAddGroupHom.comp 0 f) 0","decl":"@[simp]\ntheorem zero_comp (f : NormedAddGroupHom V₁ V₂) : (0 : NormedAddGroupHom V₂ V₃).comp f = 0 := by\n  ext\n  rfl\n\n"}
{"name":"NormedAddGroupHom.comp_assoc","module":"Mathlib.Analysis.Normed.Group.Hom","initialProofState":"V₁ : Type u_2\nV₂ : Type u_3\nV₃ : Type u_4\ninst✝³ : SeminormedAddCommGroup V₁\ninst✝² : SeminormedAddCommGroup V₂\ninst✝¹ : SeminormedAddCommGroup V₃\nV₄ : Type u_5\ninst✝ : SeminormedAddCommGroup V₄\nh : NormedAddGroupHom V₃ V₄\ng : NormedAddGroupHom V₂ V₃\nf : NormedAddGroupHom V₁ V₂\n⊢ Eq ((h.comp g).comp f) (h.comp (g.comp f))","decl":"theorem comp_assoc {V₄ : Type*} [SeminormedAddCommGroup V₄] (h : NormedAddGroupHom V₃ V₄)\n    (g : NormedAddGroupHom V₂ V₃) (f : NormedAddGroupHom V₁ V₂) :\n    (h.comp g).comp f = h.comp (g.comp f) := by\n  ext\n  rfl\n\n"}
{"name":"NormedAddGroupHom.coe_comp","module":"Mathlib.Analysis.Normed.Group.Hom","initialProofState":"V₁ : Type u_2\nV₂ : Type u_3\nV₃ : Type u_4\ninst✝² : SeminormedAddCommGroup V₁\ninst✝¹ : SeminormedAddCommGroup V₂\ninst✝ : SeminormedAddCommGroup V₃\nf : NormedAddGroupHom V₁ V₂\ng : NormedAddGroupHom V₂ V₃\n⊢ Eq (⇑(g.comp f)) (Function.comp ⇑g ⇑f)","decl":"theorem coe_comp (f : NormedAddGroupHom V₁ V₂) (g : NormedAddGroupHom V₂ V₃) :\n    (g.comp f : V₁ → V₃) = (g : V₂ → V₃) ∘ (f : V₁ → V₂) :=\n  rfl\n\n"}
{"name":"NormedAddGroupHom.incl_apply","module":"Mathlib.Analysis.Normed.Group.Hom","initialProofState":"V : Type u_1\ninst✝ : SeminormedAddCommGroup V\ns : AddSubgroup V\nself : Subtype fun x => Membership.mem s x\n⊢ Eq ((NormedAddGroupHom.incl s) self) ↑self","decl":"/-- The inclusion of an `AddSubgroup`, as bounded group homomorphism. -/\n@[simps!]\ndef incl (s : AddSubgroup V) : NormedAddGroupHom s V where\n  toFun := (Subtype.val : s → V)\n  map_add' _ _ := AddSubgroup.coe_add _ _ _\n  bound' := ⟨1, fun v => by rw [one_mul, AddSubgroup.coe_norm]⟩\n\n"}
{"name":"NormedAddGroupHom.norm_incl","module":"Mathlib.Analysis.Normed.Group.Hom","initialProofState":"V : Type u_1\ninst✝ : SeminormedAddCommGroup V\nV' : AddSubgroup V\nx : Subtype fun x => Membership.mem V' x\n⊢ Eq (Norm.norm ((NormedAddGroupHom.incl V') x)) (Norm.norm x)","decl":"theorem norm_incl {V' : AddSubgroup V} (x : V') : ‖incl _ x‖ = ‖x‖ :=\n  rfl\n\n"}
{"name":"NormedAddGroupHom.mem_ker","module":"Mathlib.Analysis.Normed.Group.Hom","initialProofState":"V₁ : Type u_3\nV₂ : Type u_4\ninst✝¹ : SeminormedAddCommGroup V₁\ninst✝ : SeminormedAddCommGroup V₂\nf : NormedAddGroupHom V₁ V₂\nv : V₁\n⊢ Iff (Membership.mem f.ker v) (Eq (f v) 0)","decl":"theorem mem_ker (v : V₁) : v ∈ f.ker ↔ f v = 0 := by\n  erw [f.toAddMonoidHom.mem_ker, coe_toAddMonoidHom]\n\n"}
{"name":"NormedAddGroupHom.ker.lift_apply_coe","module":"Mathlib.Analysis.Normed.Group.Hom","initialProofState":"V₁ : Type u_3\nV₂ : Type u_4\nV₃ : Type u_5\ninst✝² : SeminormedAddCommGroup V₁\ninst✝¹ : SeminormedAddCommGroup V₂\ninst✝ : SeminormedAddCommGroup V₃\nf : NormedAddGroupHom V₁ V₂\ng : NormedAddGroupHom V₂ V₃\nh : Eq (g.comp f) 0\nv : V₁\n⊢ Eq (↑((NormedAddGroupHom.ker.lift f g h) v)) (f v)","decl":"/-- Given a normed group hom `f : V₁ → V₂` satisfying `g.comp f = 0` for some `g : V₂ → V₃`,\n    the corestriction of `f` to the kernel of `g`. -/\n@[simps]\ndef ker.lift (h : g.comp f = 0) : NormedAddGroupHom V₁ g.ker where\n  toFun v := ⟨f v, by rw [g.mem_ker, ← comp_apply g f, h, zero_apply]⟩\n  map_add' v w := by simp only [map_add, AddMemClass.mk_add_mk]\n  bound' := f.bound'\n\n"}
{"name":"NormedAddGroupHom.ker.incl_comp_lift","module":"Mathlib.Analysis.Normed.Group.Hom","initialProofState":"V₁ : Type u_3\nV₂ : Type u_4\nV₃ : Type u_5\ninst✝² : SeminormedAddCommGroup V₁\ninst✝¹ : SeminormedAddCommGroup V₂\ninst✝ : SeminormedAddCommGroup V₃\nf : NormedAddGroupHom V₁ V₂\ng : NormedAddGroupHom V₂ V₃\nh : Eq (g.comp f) 0\n⊢ Eq ((NormedAddGroupHom.incl g.ker).comp (NormedAddGroupHom.ker.lift f g h)) f","decl":"@[simp]\ntheorem ker.incl_comp_lift (h : g.comp f = 0) : (incl g.ker).comp (ker.lift f g h) = f := by\n  ext\n  rfl\n\n"}
{"name":"NormedAddGroupHom.ker_zero","module":"Mathlib.Analysis.Normed.Group.Hom","initialProofState":"V₁ : Type u_3\nV₂ : Type u_4\ninst✝¹ : SeminormedAddCommGroup V₁\ninst✝ : SeminormedAddCommGroup V₂\n⊢ Eq (NormedAddGroupHom.ker 0) Top.top","decl":"@[simp]\ntheorem ker_zero : (0 : NormedAddGroupHom V₁ V₂).ker = ⊤ := by\n  ext\n  simp [mem_ker]\n\n"}
{"name":"NormedAddGroupHom.coe_ker","module":"Mathlib.Analysis.Normed.Group.Hom","initialProofState":"V₁ : Type u_3\nV₂ : Type u_4\ninst✝¹ : SeminormedAddCommGroup V₁\ninst✝ : SeminormedAddCommGroup V₂\nf : NormedAddGroupHom V₁ V₂\n⊢ Eq (↑f.ker) (Set.preimage (⇑f) (Singleton.singleton 0))","decl":"theorem coe_ker : (f.ker : Set V₁) = (f : V₁ → V₂) ⁻¹' {0} :=\n  rfl\n\n"}
{"name":"NormedAddGroupHom.isClosed_ker","module":"Mathlib.Analysis.Normed.Group.Hom","initialProofState":"V₁ : Type u_3\ninst✝¹ : SeminormedAddCommGroup V₁\nV₂ : Type u_6\ninst✝ : NormedAddCommGroup V₂\nf : NormedAddGroupHom V₁ V₂\n⊢ IsClosed ↑f.ker","decl":"theorem isClosed_ker {V₂ : Type*} [NormedAddCommGroup V₂] (f : NormedAddGroupHom V₁ V₂) :\n    IsClosed (f.ker : Set V₁) :=\n  f.coe_ker ▸ IsClosed.preimage f.continuous (T1Space.t1 0)\n\n"}
{"name":"NormedAddGroupHom.mem_range","module":"Mathlib.Analysis.Normed.Group.Hom","initialProofState":"V₁ : Type u_3\nV₂ : Type u_4\ninst✝¹ : SeminormedAddCommGroup V₁\ninst✝ : SeminormedAddCommGroup V₂\nf : NormedAddGroupHom V₁ V₂\nv : V₂\n⊢ Iff (Membership.mem f.range v) (Exists fun w => Eq (f w) v)","decl":"theorem mem_range (v : V₂) : v ∈ f.range ↔ ∃ w, f w = v := Iff.rfl\n\n"}
{"name":"NormedAddGroupHom.mem_range_self","module":"Mathlib.Analysis.Normed.Group.Hom","initialProofState":"V₁ : Type u_3\nV₂ : Type u_4\ninst✝¹ : SeminormedAddCommGroup V₁\ninst✝ : SeminormedAddCommGroup V₂\nf : NormedAddGroupHom V₁ V₂\nv : V₁\n⊢ Membership.mem f.range (f v)","decl":"@[simp]\ntheorem mem_range_self (v : V₁) : f v ∈ f.range :=\n  ⟨v, rfl⟩\n\n"}
{"name":"NormedAddGroupHom.comp_range","module":"Mathlib.Analysis.Normed.Group.Hom","initialProofState":"V₁ : Type u_3\nV₂ : Type u_4\nV₃ : Type u_5\ninst✝² : SeminormedAddCommGroup V₁\ninst✝¹ : SeminormedAddCommGroup V₂\ninst✝ : SeminormedAddCommGroup V₃\nf : NormedAddGroupHom V₁ V₂\ng : NormedAddGroupHom V₂ V₃\n⊢ Eq (g.comp f).range (AddSubgroup.map g.toAddMonoidHom f.range)","decl":"theorem comp_range : (g.comp f).range = AddSubgroup.map g.toAddMonoidHom f.range := by\n  erw [AddMonoidHom.map_range]\n  rfl\n\n"}
{"name":"NormedAddGroupHom.incl_range","module":"Mathlib.Analysis.Normed.Group.Hom","initialProofState":"V₁ : Type u_3\ninst✝ : SeminormedAddCommGroup V₁\ns : AddSubgroup V₁\n⊢ Eq (NormedAddGroupHom.incl s).range s","decl":"theorem incl_range (s : AddSubgroup V₁) : (incl s).range = s := by\n  ext x\n  exact ⟨fun ⟨y, hy⟩ => by rw [← hy]; simp, fun hx => ⟨⟨x, hx⟩, by simp⟩⟩\n\n"}
{"name":"NormedAddGroupHom.range_comp_incl_top","module":"Mathlib.Analysis.Normed.Group.Hom","initialProofState":"V₁ : Type u_3\nV₂ : Type u_4\ninst✝¹ : SeminormedAddCommGroup V₁\ninst✝ : SeminormedAddCommGroup V₂\nf : NormedAddGroupHom V₁ V₂\n⊢ Eq (f.comp (NormedAddGroupHom.incl Top.top)).range f.range","decl":"@[simp]\ntheorem range_comp_incl_top : (f.comp (incl (⊤ : AddSubgroup V₁))).range = f.range := by\n  simp [comp_range, incl_range, ← AddMonoidHom.range_eq_map]; rfl\n\n"}
{"name":"NormedAddGroupHom.NormNoninc.normNoninc_iff_norm_le_one","module":"Mathlib.Analysis.Normed.Group.Hom","initialProofState":"V : Type u_1\nW : Type u_2\ninst✝¹ : SeminormedAddCommGroup V\ninst✝ : SeminormedAddCommGroup W\nf : NormedAddGroupHom V W\n⊢ Iff f.NormNoninc (LE.le (Norm.norm f) 1)","decl":"theorem normNoninc_iff_norm_le_one : f.NormNoninc ↔ ‖f‖ ≤ 1 := by\n  refine ⟨fun h => ?_, fun h => fun v => ?_⟩\n  · refine opNorm_le_bound _ zero_le_one fun v => ?_\n    simpa [one_mul] using h v\n  · simpa using le_of_opNorm_le f h v\n\n"}
{"name":"NormedAddGroupHom.NormNoninc.zero","module":"Mathlib.Analysis.Normed.Group.Hom","initialProofState":"V₁ : Type u_3\nV₂ : Type u_4\ninst✝¹ : SeminormedAddCommGroup V₁\ninst✝ : SeminormedAddCommGroup V₂\n⊢ NormedAddGroupHom.NormNoninc 0","decl":"theorem zero : (0 : NormedAddGroupHom V₁ V₂).NormNoninc := fun v => by simp\n\n"}
{"name":"NormedAddGroupHom.NormNoninc.id","module":"Mathlib.Analysis.Normed.Group.Hom","initialProofState":"V : Type u_1\ninst✝ : SeminormedAddCommGroup V\n⊢ (NormedAddGroupHom.id V).NormNoninc","decl":"theorem id : (id V).NormNoninc := fun _v => le_rfl\n\n"}
{"name":"NormedAddGroupHom.NormNoninc.comp","module":"Mathlib.Analysis.Normed.Group.Hom","initialProofState":"V₁ : Type u_3\nV₂ : Type u_4\nV₃ : Type u_5\ninst✝² : SeminormedAddCommGroup V₁\ninst✝¹ : SeminormedAddCommGroup V₂\ninst✝ : SeminormedAddCommGroup V₃\ng : NormedAddGroupHom V₂ V₃\nf : NormedAddGroupHom V₁ V₂\nhg : g.NormNoninc\nhf : f.NormNoninc\n⊢ (g.comp f).NormNoninc","decl":"theorem comp {g : NormedAddGroupHom V₂ V₃} {f : NormedAddGroupHom V₁ V₂} (hg : g.NormNoninc)\n    (hf : f.NormNoninc) : (g.comp f).NormNoninc := fun v => (hg (f v)).trans (hf v)\n\n"}
{"name":"NormedAddGroupHom.NormNoninc.neg_iff","module":"Mathlib.Analysis.Normed.Group.Hom","initialProofState":"V₁ : Type u_3\nV₂ : Type u_4\ninst✝¹ : SeminormedAddCommGroup V₁\ninst✝ : SeminormedAddCommGroup V₂\nf : NormedAddGroupHom V₁ V₂\n⊢ Iff (Neg.neg f).NormNoninc f.NormNoninc","decl":"@[simp]\ntheorem neg_iff {f : NormedAddGroupHom V₁ V₂} : (-f).NormNoninc ↔ f.NormNoninc :=\n  ⟨fun h x => by simpa using h x, fun h x => (norm_neg (f x)).le.trans (h x)⟩\n\n"}
{"name":"NormedAddGroupHom.norm_eq_of_isometry","module":"Mathlib.Analysis.Normed.Group.Hom","initialProofState":"V : Type u_1\nW : Type u_2\ninst✝¹ : SeminormedAddCommGroup V\ninst✝ : SeminormedAddCommGroup W\nf : NormedAddGroupHom V W\nhf : Isometry ⇑f\nv : V\n⊢ Eq (Norm.norm (f v)) (Norm.norm v)","decl":"theorem norm_eq_of_isometry {f : NormedAddGroupHom V W} (hf : Isometry f) (v : V) : ‖f v‖ = ‖v‖ :=\n  (AddMonoidHomClass.isometry_iff_norm f).mp hf v\n\n"}
{"name":"NormedAddGroupHom.isometry_id","module":"Mathlib.Analysis.Normed.Group.Hom","initialProofState":"V : Type u_1\ninst✝ : SeminormedAddCommGroup V\n⊢ Isometry ⇑(NormedAddGroupHom.id V)","decl":"theorem isometry_id : @Isometry V V _ _ (id V) :=\n  _root_.isometry_id\n\n"}
{"name":"NormedAddGroupHom.isometry_comp","module":"Mathlib.Analysis.Normed.Group.Hom","initialProofState":"V₁ : Type u_3\nV₂ : Type u_4\nV₃ : Type u_5\ninst✝² : SeminormedAddCommGroup V₁\ninst✝¹ : SeminormedAddCommGroup V₂\ninst✝ : SeminormedAddCommGroup V₃\ng : NormedAddGroupHom V₂ V₃\nf : NormedAddGroupHom V₁ V₂\nhg : Isometry ⇑g\nhf : Isometry ⇑f\n⊢ Isometry ⇑(g.comp f)","decl":"theorem isometry_comp {g : NormedAddGroupHom V₂ V₃} {f : NormedAddGroupHom V₁ V₂} (hg : Isometry g)\n    (hf : Isometry f) : Isometry (g.comp f) :=\n  hg.comp hf\n\n"}
{"name":"NormedAddGroupHom.normNoninc_of_isometry","module":"Mathlib.Analysis.Normed.Group.Hom","initialProofState":"V : Type u_1\nW : Type u_2\ninst✝¹ : SeminormedAddCommGroup V\ninst✝ : SeminormedAddCommGroup W\nf : NormedAddGroupHom V W\nhf : Isometry ⇑f\n⊢ f.NormNoninc","decl":"theorem normNoninc_of_isometry (hf : Isometry f) : f.NormNoninc := fun v =>\n  le_of_eq <| norm_eq_of_isometry hf v\n\n"}
{"name":"NormedAddGroupHom.Equalizer.comp_ι_eq","module":"Mathlib.Analysis.Normed.Group.Hom","initialProofState":"V : Type u_1\nW : Type u_2\ninst✝¹ : SeminormedAddCommGroup V\ninst✝ : SeminormedAddCommGroup W\nf g : NormedAddGroupHom V W\n⊢ Eq (f.comp (NormedAddGroupHom.Equalizer.ι f g)) (g.comp (NormedAddGroupHom.Equalizer.ι f g))","decl":"theorem comp_ι_eq : f.comp (ι f g) = g.comp (ι f g) := by\n  ext x\n  rw [comp_apply, comp_apply, ← sub_eq_zero, ← NormedAddGroupHom.sub_apply]\n  exact x.2\n\n"}
{"name":"NormedAddGroupHom.Equalizer.lift_apply_coe","module":"Mathlib.Analysis.Normed.Group.Hom","initialProofState":"V : Type u_1\nW : Type u_2\nV₁ : Type u_3\ninst✝² : SeminormedAddCommGroup V\ninst✝¹ : SeminormedAddCommGroup W\ninst✝ : SeminormedAddCommGroup V₁\nf g : NormedAddGroupHom V W\nφ : NormedAddGroupHom V₁ V\nh : Eq (f.comp φ) (g.comp φ)\nv : V₁\n⊢ Eq (↑((NormedAddGroupHom.Equalizer.lift φ h) v)) (φ v)","decl":"/-- If `φ : NormedAddGroupHom V₁ V` is such that `f.comp φ = g.comp φ`, the induced morphism\n`NormedAddGroupHom V₁ (f.equalizer g)`. -/\n@[simps]\ndef lift (φ : NormedAddGroupHom V₁ V) (h : f.comp φ = g.comp φ) :\n    NormedAddGroupHom V₁ (f.equalizer g) where\n  toFun v :=\n    ⟨φ v,\n      show (f - g) (φ v) = 0 by\n        rw [NormedAddGroupHom.sub_apply, sub_eq_zero, ← comp_apply, h, comp_apply]⟩\n  map_add' v₁ v₂ := by\n    ext\n    simp only [map_add, AddSubgroup.coe_add, Subtype.coe_mk]\n  bound' := by\n    obtain ⟨C, _C_pos, hC⟩ := φ.bound\n    exact ⟨C, hC⟩\n\n"}
{"name":"NormedAddGroupHom.Equalizer.ι_comp_lift","module":"Mathlib.Analysis.Normed.Group.Hom","initialProofState":"V : Type u_1\nW : Type u_2\nV₁ : Type u_3\ninst✝² : SeminormedAddCommGroup V\ninst✝¹ : SeminormedAddCommGroup W\ninst✝ : SeminormedAddCommGroup V₁\nf g : NormedAddGroupHom V W\nφ : NormedAddGroupHom V₁ V\nh : Eq (f.comp φ) (g.comp φ)\n⊢ Eq ((NormedAddGroupHom.Equalizer.ι f g).comp (NormedAddGroupHom.Equalizer.lift φ h)) φ","decl":"@[simp]\ntheorem ι_comp_lift (φ : NormedAddGroupHom V₁ V) (h : f.comp φ = g.comp φ) :\n    (ι _ _).comp (lift φ h) = φ := by\n  ext\n  rfl\n\n"}
{"name":"NormedAddGroupHom.Equalizer.liftEquiv_apply","module":"Mathlib.Analysis.Normed.Group.Hom","initialProofState":"V : Type u_1\nW : Type u_2\nV₁ : Type u_3\ninst✝² : SeminormedAddCommGroup V\ninst✝¹ : SeminormedAddCommGroup W\ninst✝ : SeminormedAddCommGroup V₁\nf g : NormedAddGroupHom V W\nφ : Subtype fun φ => Eq (f.comp φ) (g.comp φ)\n⊢ Eq (NormedAddGroupHom.Equalizer.liftEquiv φ) (NormedAddGroupHom.Equalizer.lift ↑φ ⋯)","decl":"/-- The lifting property of the equalizer as an equivalence. -/\n@[simps]\ndef liftEquiv :\n    { φ : NormedAddGroupHom V₁ V // f.comp φ = g.comp φ } ≃\n      NormedAddGroupHom V₁ (f.equalizer g) where\n  toFun φ := lift φ φ.prop\n  invFun ψ := ⟨(ι f g).comp ψ, by rw [← comp_assoc, ← comp_assoc, comp_ι_eq]⟩\n  left_inv φ := by simp\n  right_inv ψ := by\n    ext\n    rfl\n\n"}
{"name":"NormedAddGroupHom.Equalizer.liftEquiv_symm_apply_coe","module":"Mathlib.Analysis.Normed.Group.Hom","initialProofState":"V : Type u_1\nW : Type u_2\nV₁ : Type u_3\ninst✝² : SeminormedAddCommGroup V\ninst✝¹ : SeminormedAddCommGroup W\ninst✝ : SeminormedAddCommGroup V₁\nf g : NormedAddGroupHom V W\nψ : NormedAddGroupHom V₁ (Subtype fun x => Membership.mem (f.equalizer g) x)\n⊢ Eq (↑(NormedAddGroupHom.Equalizer.liftEquiv.symm ψ)) ((NormedAddGroupHom.Equalizer.ι f g).comp ψ)","decl":"/-- The lifting property of the equalizer as an equivalence. -/\n@[simps]\ndef liftEquiv :\n    { φ : NormedAddGroupHom V₁ V // f.comp φ = g.comp φ } ≃\n      NormedAddGroupHom V₁ (f.equalizer g) where\n  toFun φ := lift φ φ.prop\n  invFun ψ := ⟨(ι f g).comp ψ, by rw [← comp_assoc, ← comp_assoc, comp_ι_eq]⟩\n  left_inv φ := by simp\n  right_inv ψ := by\n    ext\n    rfl\n\n"}
{"name":"NormedAddGroupHom.Equalizer.ι_comp_map","module":"Mathlib.Analysis.Normed.Group.Hom","initialProofState":"V₁ : Type u_3\nV₂ : Type u_4\ninst✝³ : SeminormedAddCommGroup V₁\ninst✝² : SeminormedAddCommGroup V₂\nW₁ : Type u_6\nW₂ : Type u_7\ninst✝¹ : SeminormedAddCommGroup W₁\ninst✝ : SeminormedAddCommGroup W₂\nf₁ g₁ : NormedAddGroupHom V₁ W₁\nf₂ g₂ : NormedAddGroupHom V₂ W₂\nφ : NormedAddGroupHom V₁ V₂\nψ : NormedAddGroupHom W₁ W₂\nhf : Eq (ψ.comp f₁) (f₂.comp φ)\nhg : Eq (ψ.comp g₁) (g₂.comp φ)\n⊢ Eq ((NormedAddGroupHom.Equalizer.ι f₂ g₂).comp (NormedAddGroupHom.Equalizer.map φ ψ hf hg)) (φ.comp (NormedAddGroupHom.Equalizer.ι f₁ g₁))","decl":"@[simp]\ntheorem ι_comp_map (hf : ψ.comp f₁ = f₂.comp φ) (hg : ψ.comp g₁ = g₂.comp φ) :\n    (ι f₂ g₂).comp (map φ ψ hf hg) = φ.comp (ι f₁ g₁) :=\n  ι_comp_lift _ _\n\n"}
{"name":"NormedAddGroupHom.Equalizer.map_id","module":"Mathlib.Analysis.Normed.Group.Hom","initialProofState":"V₁ : Type u_3\ninst✝¹ : SeminormedAddCommGroup V₁\nW₁ : Type u_6\ninst✝ : SeminormedAddCommGroup W₁\nf₁ g₁ : NormedAddGroupHom V₁ W₁\n⊢ Eq (NormedAddGroupHom.Equalizer.map (NormedAddGroupHom.id V₁) (NormedAddGroupHom.id W₁) ⋯ ⋯) (NormedAddGroupHom.id (Subtype fun x => Membership.mem (f₁.equalizer g₁) x))","decl":"@[simp]\ntheorem map_id : map (f₂ := f₁) (g₂ := g₁) (id V₁) (id W₁) rfl rfl = id (f₁.equalizer g₁) := by\n  ext\n  rfl\n\n"}
{"name":"NormedAddGroupHom.Equalizer.comm_sq₂","module":"Mathlib.Analysis.Normed.Group.Hom","initialProofState":"V₁ : Type u_3\nV₂ : Type u_4\nV₃ : Type u_5\ninst✝⁵ : SeminormedAddCommGroup V₁\ninst✝⁴ : SeminormedAddCommGroup V₂\ninst✝³ : SeminormedAddCommGroup V₃\nW₁ : Type u_6\nW₂ : Type u_7\nW₃ : Type u_8\ninst✝² : SeminormedAddCommGroup W₁\ninst✝¹ : SeminormedAddCommGroup W₂\ninst✝ : SeminormedAddCommGroup W₃\nf₁ : NormedAddGroupHom V₁ W₁\nf₂ : NormedAddGroupHom V₂ W₂\nf₃ : NormedAddGroupHom V₃ W₃\nφ : NormedAddGroupHom V₁ V₂\nψ : NormedAddGroupHom W₁ W₂\nφ' : NormedAddGroupHom V₂ V₃\nψ' : NormedAddGroupHom W₂ W₃\nhf : Eq (ψ.comp f₁) (f₂.comp φ)\nhf' : Eq (ψ'.comp f₂) (f₃.comp φ')\n⊢ Eq ((ψ'.comp ψ).comp f₁) (f₃.comp (φ'.comp φ))","decl":"theorem comm_sq₂ (hf : ψ.comp f₁ = f₂.comp φ) (hf' : ψ'.comp f₂ = f₃.comp φ') :\n    (ψ'.comp ψ).comp f₁ = f₃.comp (φ'.comp φ) := by\n  rw [comp_assoc, hf, ← comp_assoc, hf', comp_assoc]\n\n"}
{"name":"NormedAddGroupHom.Equalizer.map_comp_map","module":"Mathlib.Analysis.Normed.Group.Hom","initialProofState":"V₁ : Type u_3\nV₂ : Type u_4\nV₃ : Type u_5\ninst✝⁵ : SeminormedAddCommGroup V₁\ninst✝⁴ : SeminormedAddCommGroup V₂\ninst✝³ : SeminormedAddCommGroup V₃\nW₁ : Type u_6\nW₂ : Type u_7\nW₃ : Type u_8\ninst✝² : SeminormedAddCommGroup W₁\ninst✝¹ : SeminormedAddCommGroup W₂\ninst✝ : SeminormedAddCommGroup W₃\nf₁ g₁ : NormedAddGroupHom V₁ W₁\nf₂ g₂ : NormedAddGroupHom V₂ W₂\nf₃ g₃ : NormedAddGroupHom V₃ W₃\nφ : NormedAddGroupHom V₁ V₂\nψ : NormedAddGroupHom W₁ W₂\nφ' : NormedAddGroupHom V₂ V₃\nψ' : NormedAddGroupHom W₂ W₃\nhf : Eq (ψ.comp f₁) (f₂.comp φ)\nhg : Eq (ψ.comp g₁) (g₂.comp φ)\nhf' : Eq (ψ'.comp f₂) (f₃.comp φ')\nhg' : Eq (ψ'.comp g₂) (g₃.comp φ')\n⊢ Eq ((NormedAddGroupHom.Equalizer.map φ' ψ' hf' hg').comp (NormedAddGroupHom.Equalizer.map φ ψ hf hg)) (NormedAddGroupHom.Equalizer.map (φ'.comp φ) (ψ'.comp ψ) ⋯ ⋯)","decl":"theorem map_comp_map (hf : ψ.comp f₁ = f₂.comp φ) (hg : ψ.comp g₁ = g₂.comp φ)\n    (hf' : ψ'.comp f₂ = f₃.comp φ') (hg' : ψ'.comp g₂ = g₃.comp φ') :\n    (map φ' ψ' hf' hg').comp (map φ ψ hf hg) =\n      map (φ'.comp φ) (ψ'.comp ψ) (comm_sq₂ hf hf') (comm_sq₂ hg hg') := by\n  ext\n  rfl\n\n"}
{"name":"NormedAddGroupHom.Equalizer.ι_normNoninc","module":"Mathlib.Analysis.Normed.Group.Hom","initialProofState":"V : Type u_1\nW : Type u_2\ninst✝¹ : SeminormedAddCommGroup V\ninst✝ : SeminormedAddCommGroup W\nf g : NormedAddGroupHom V W\n⊢ (NormedAddGroupHom.Equalizer.ι f g).NormNoninc","decl":"theorem ι_normNoninc : (ι f g).NormNoninc := fun _v => le_rfl\n\n"}
{"name":"NormedAddGroupHom.Equalizer.lift_normNoninc","module":"Mathlib.Analysis.Normed.Group.Hom","initialProofState":"V : Type u_1\nW : Type u_2\nV₁ : Type u_3\ninst✝² : SeminormedAddCommGroup V\ninst✝¹ : SeminormedAddCommGroup W\ninst✝ : SeminormedAddCommGroup V₁\nf g : NormedAddGroupHom V W\nφ : NormedAddGroupHom V₁ V\nh : Eq (f.comp φ) (g.comp φ)\nhφ : φ.NormNoninc\n⊢ (NormedAddGroupHom.Equalizer.lift φ h).NormNoninc","decl":"/-- The lifting of a norm nonincreasing morphism is norm nonincreasing. -/\ntheorem lift_normNoninc (φ : NormedAddGroupHom V₁ V) (h : f.comp φ = g.comp φ) (hφ : φ.NormNoninc) :\n    (lift φ h).NormNoninc :=\n  hφ\n\n"}
{"name":"NormedAddGroupHom.Equalizer.norm_lift_le","module":"Mathlib.Analysis.Normed.Group.Hom","initialProofState":"V : Type u_1\nW : Type u_2\nV₁ : Type u_3\ninst✝² : SeminormedAddCommGroup V\ninst✝¹ : SeminormedAddCommGroup W\ninst✝ : SeminormedAddCommGroup V₁\nf g : NormedAddGroupHom V W\nφ : NormedAddGroupHom V₁ V\nh : Eq (f.comp φ) (g.comp φ)\nC : Real\nhφ : LE.le (Norm.norm φ) C\n⊢ LE.le (Norm.norm (NormedAddGroupHom.Equalizer.lift φ h)) C","decl":"/-- If `φ` satisfies `‖φ‖ ≤ C`, then the same is true for the lifted morphism. -/\ntheorem norm_lift_le (φ : NormedAddGroupHom V₁ V) (h : f.comp φ = g.comp φ) (C : ℝ) (hφ : ‖φ‖ ≤ C) :\n    ‖lift φ h‖ ≤ C :=\n  hφ\n\n"}
{"name":"NormedAddGroupHom.Equalizer.map_normNoninc","module":"Mathlib.Analysis.Normed.Group.Hom","initialProofState":"V₁ : Type u_3\nV₂ : Type u_4\ninst✝³ : SeminormedAddCommGroup V₁\ninst✝² : SeminormedAddCommGroup V₂\nW₁ : Type u_6\nW₂ : Type u_7\ninst✝¹ : SeminormedAddCommGroup W₁\ninst✝ : SeminormedAddCommGroup W₂\nf₁ g₁ : NormedAddGroupHom V₁ W₁\nf₂ g₂ : NormedAddGroupHom V₂ W₂\nφ : NormedAddGroupHom V₁ V₂\nψ : NormedAddGroupHom W₁ W₂\nhf : Eq (ψ.comp f₁) (f₂.comp φ)\nhg : Eq (ψ.comp g₁) (g₂.comp φ)\nhφ : φ.NormNoninc\n⊢ (NormedAddGroupHom.Equalizer.map φ ψ hf hg).NormNoninc","decl":"theorem map_normNoninc (hf : ψ.comp f₁ = f₂.comp φ) (hg : ψ.comp g₁ = g₂.comp φ)\n    (hφ : φ.NormNoninc) : (map φ ψ hf hg).NormNoninc :=\n  lift_normNoninc _ _ <| hφ.comp ι_normNoninc\n\n"}
{"name":"NormedAddGroupHom.Equalizer.norm_map_le","module":"Mathlib.Analysis.Normed.Group.Hom","initialProofState":"V₁ : Type u_3\nV₂ : Type u_4\ninst✝³ : SeminormedAddCommGroup V₁\ninst✝² : SeminormedAddCommGroup V₂\nW₁ : Type u_6\nW₂ : Type u_7\ninst✝¹ : SeminormedAddCommGroup W₁\ninst✝ : SeminormedAddCommGroup W₂\nf₁ g₁ : NormedAddGroupHom V₁ W₁\nf₂ g₂ : NormedAddGroupHom V₂ W₂\nφ : NormedAddGroupHom V₁ V₂\nψ : NormedAddGroupHom W₁ W₂\nhf : Eq (ψ.comp f₁) (f₂.comp φ)\nhg : Eq (ψ.comp g₁) (g₂.comp φ)\nC : Real\nhφ : LE.le (Norm.norm (φ.comp (NormedAddGroupHom.Equalizer.ι f₁ g₁))) C\n⊢ LE.le (Norm.norm (NormedAddGroupHom.Equalizer.map φ ψ hf hg)) C","decl":"theorem norm_map_le (hf : ψ.comp f₁ = f₂.comp φ) (hg : ψ.comp g₁ = g₂.comp φ) (C : ℝ)\n    (hφ : ‖φ.comp (ι f₁ g₁)‖ ≤ C) : ‖map φ ψ hf hg‖ ≤ C :=\n  norm_lift_le _ _ _ hφ\n\n"}
