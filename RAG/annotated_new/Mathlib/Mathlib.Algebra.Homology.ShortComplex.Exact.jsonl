{"name":"CategoryTheory.ShortComplex.Exact.condition","module":"Mathlib.Algebra.Homology.ShortComplex.Exact","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_3, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nself : S.Exact\n⊢ Exists fun h => CategoryTheory.Limits.IsZero h.left.H","decl":"/-- The assertion that the short complex `S : ShortComplex C` is exact. -/\nstructure Exact : Prop where\n  /-- the condition that there exists an homology data whose `left.H` field is zero -/\n  condition : ∃ (h : S.HomologyData), IsZero h.left.H\n\n"}
{"name":"CategoryTheory.ShortComplex.Exact.hasHomology","module":"Mathlib.Algebra.Homology.ShortComplex.Exact","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_3, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nh : S.Exact\n⊢ S.HasHomology","decl":"lemma Exact.hasHomology (h : S.Exact) : S.HasHomology :=\n  HasHomology.mk' h.condition.choose\n\n"}
{"name":"CategoryTheory.ShortComplex.Exact.hasZeroObject","module":"Mathlib.Algebra.Homology.ShortComplex.Exact","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_3, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nh : S.Exact\n⊢ CategoryTheory.Limits.HasZeroObject C","decl":"lemma Exact.hasZeroObject (h : S.Exact) : HasZeroObject C :=\n  ⟨h.condition.choose.left.H, h.condition.choose_spec⟩\n\n"}
{"name":"CategoryTheory.ShortComplex.exact_iff_isZero_homology","module":"Mathlib.Algebra.Homology.ShortComplex.Exact","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst✝ : S.HasHomology\n⊢ Iff S.Exact (CategoryTheory.Limits.IsZero S.homology)","decl":"lemma exact_iff_isZero_homology [S.HasHomology] :\n    S.Exact ↔ IsZero S.homology := by\n  constructor\n  · rintro ⟨⟨h', z⟩⟩\n    exact IsZero.of_iso z h'.left.homologyIso\n  · intro h\n    exact ⟨⟨_, h⟩⟩\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.exact_iff","module":"Mathlib.Algebra.Homology.ShortComplex.Exact","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst✝ : S.HasHomology\nh : S.LeftHomologyData\n⊢ Iff S.Exact (CategoryTheory.Limits.IsZero h.H)","decl":"lemma LeftHomologyData.exact_iff [S.HasHomology]\n    (h : S.LeftHomologyData) :\n    S.Exact ↔ IsZero h.H := by\n  rw [S.exact_iff_isZero_homology]\n  exact Iso.isZero_iff h.homologyIso\n\n"}
{"name":"CategoryTheory.ShortComplex.RightHomologyData.exact_iff","module":"Mathlib.Algebra.Homology.ShortComplex.Exact","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst✝ : S.HasHomology\nh : S.RightHomologyData\n⊢ Iff S.Exact (CategoryTheory.Limits.IsZero h.H)","decl":"lemma RightHomologyData.exact_iff [S.HasHomology]\n    (h : S.RightHomologyData) :\n    S.Exact ↔ IsZero h.H := by\n  rw [S.exact_iff_isZero_homology]\n  exact Iso.isZero_iff h.homologyIso\n\n"}
{"name":"CategoryTheory.ShortComplex.exact_iff_isZero_leftHomology","module":"Mathlib.Algebra.Homology.ShortComplex.Exact","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst✝ : S.HasHomology\n⊢ Iff S.Exact (CategoryTheory.Limits.IsZero S.leftHomology)","decl":"lemma exact_iff_isZero_leftHomology [S.HasHomology] :\n    S.Exact ↔ IsZero S.leftHomology :=\n  LeftHomologyData.exact_iff _\n\n"}
{"name":"CategoryTheory.ShortComplex.exact_iff_isZero_rightHomology","module":"Mathlib.Algebra.Homology.ShortComplex.Exact","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst✝ : S.HasHomology\n⊢ Iff S.Exact (CategoryTheory.Limits.IsZero S.rightHomology)","decl":"lemma exact_iff_isZero_rightHomology [S.HasHomology] :\n    S.Exact ↔ IsZero S.rightHomology :=\n  RightHomologyData.exact_iff _\n\n"}
{"name":"CategoryTheory.ShortComplex.HomologyData.exact_iff","module":"Mathlib.Algebra.Homology.ShortComplex.Exact","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_3, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nh : S.HomologyData\n⊢ Iff S.Exact (CategoryTheory.Limits.IsZero h.left.H)","decl":"lemma HomologyData.exact_iff (h : S.HomologyData) :\n    S.Exact ↔ IsZero h.left.H := by\n  haveI := HasHomology.mk' h\n  exact LeftHomologyData.exact_iff h.left\n\n"}
{"name":"CategoryTheory.ShortComplex.HomologyData.exact_iff'","module":"Mathlib.Algebra.Homology.ShortComplex.Exact","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_3, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nh : S.HomologyData\n⊢ Iff S.Exact (CategoryTheory.Limits.IsZero h.right.H)","decl":"lemma HomologyData.exact_iff' (h : S.HomologyData) :\n    S.Exact ↔ IsZero h.right.H := by\n  haveI := HasHomology.mk' h\n  exact RightHomologyData.exact_iff h.right\n\n"}
{"name":"CategoryTheory.ShortComplex.exact_iff_homology_iso_zero","module":"Mathlib.Algebra.Homology.ShortComplex.Exact","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_3, u_1} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst✝¹ : S.HasHomology\ninst✝ : CategoryTheory.Limits.HasZeroObject C\n⊢ Iff S.Exact (Nonempty (CategoryTheory.Iso S.homology 0))","decl":"lemma exact_iff_homology_iso_zero [S.HasHomology] [HasZeroObject C] :\n    S.Exact ↔ Nonempty (S.homology ≅ 0) := by\n  rw [exact_iff_isZero_homology]\n  constructor\n  · intro h\n    exact ⟨h.isoZero⟩\n  · rintro ⟨e⟩\n    exact IsZero.of_iso (isZero_zero C) e\n\n"}
{"name":"CategoryTheory.ShortComplex.exact_of_iso","module":"Mathlib.Algebra.Homology.ShortComplex.Exact","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_3, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\ne : CategoryTheory.Iso S₁ S₂\nh : S₁.Exact\n⊢ S₂.Exact","decl":"lemma exact_of_iso (e : S₁ ≅ S₂) (h : S₁.Exact) : S₂.Exact := by\n  obtain ⟨⟨h, z⟩⟩ := h\n  exact ⟨⟨HomologyData.ofIso e h, z⟩⟩\n\n"}
{"name":"CategoryTheory.ShortComplex.exact_iff_of_iso","module":"Mathlib.Algebra.Homology.ShortComplex.Exact","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_3, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\ne : CategoryTheory.Iso S₁ S₂\n⊢ Iff S₁.Exact S₂.Exact","decl":"lemma exact_iff_of_iso (e : S₁ ≅ S₂) : S₁.Exact ↔ S₂.Exact :=\n  ⟨exact_of_iso e, exact_of_iso e.symm⟩\n\n"}
{"name":"CategoryTheory.ShortComplex.exact_and_mono_f_iff_of_iso","module":"Mathlib.Algebra.Homology.ShortComplex.Exact","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_3, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\ne : CategoryTheory.Iso S₁ S₂\n⊢ Iff (And S₁.Exact (CategoryTheory.Mono S₁.f)) (And S₂.Exact (CategoryTheory.Mono S₂.f))","decl":"lemma exact_and_mono_f_iff_of_iso (e : S₁ ≅ S₂) :\n    S₁.Exact ∧ Mono S₁.f ↔ S₂.Exact ∧ Mono S₂.f := by\n  have : Mono S₁.f ↔ Mono S₂.f :=\n    (MorphismProperty.monomorphisms C).arrow_mk_iso_iff\n      (Arrow.isoMk (ShortComplex.π₁.mapIso e) (ShortComplex.π₂.mapIso e) e.hom.comm₁₂)\n  rw [exact_iff_of_iso e, this]\n\n"}
{"name":"CategoryTheory.ShortComplex.exact_and_epi_g_iff_of_iso","module":"Mathlib.Algebra.Homology.ShortComplex.Exact","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_3, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\ne : CategoryTheory.Iso S₁ S₂\n⊢ Iff (And S₁.Exact (CategoryTheory.Epi S₁.g)) (And S₂.Exact (CategoryTheory.Epi S₂.g))","decl":"lemma exact_and_epi_g_iff_of_iso (e : S₁ ≅ S₂) :\n    S₁.Exact ∧ Epi S₁.g ↔ S₂.Exact ∧ Epi S₂.g := by\n  have : Epi S₁.g ↔ Epi S₂.g :=\n    (MorphismProperty.epimorphisms C).arrow_mk_iso_iff\n      (Arrow.isoMk (ShortComplex.π₂.mapIso e) (ShortComplex.π₃.mapIso e) e.hom.comm₂₃)\n  rw [exact_iff_of_iso e, this]\n\n"}
{"name":"CategoryTheory.ShortComplex.exact_of_isZero_X₂","module":"Mathlib.Algebra.Homology.ShortComplex.Exact","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_3, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nh : CategoryTheory.Limits.IsZero S.X₂\n⊢ S.Exact","decl":"lemma exact_of_isZero_X₂ (h : IsZero S.X₂) : S.Exact := by\n  rw [(HomologyData.ofZeros S (IsZero.eq_of_tgt h _ _) (IsZero.eq_of_src h _ _)).exact_iff]\n  exact h\n\n"}
{"name":"CategoryTheory.ShortComplex.exact_iff_of_epi_of_isIso_of_mono","module":"Mathlib.Algebra.Homology.ShortComplex.Exact","initialProofState":"C : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_3, u_1} C\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\ninst✝² : CategoryTheory.Epi φ.τ₁\ninst✝¹ : CategoryTheory.IsIso φ.τ₂\ninst✝ : CategoryTheory.Mono φ.τ₃\n⊢ Iff S₁.Exact S₂.Exact","decl":"lemma exact_iff_of_epi_of_isIso_of_mono (φ : S₁ ⟶ S₂) [Epi φ.τ₁] [IsIso φ.τ₂] [Mono φ.τ₃] :\n    S₁.Exact ↔ S₂.Exact := by\n  constructor\n  · rintro ⟨h₁, z₁⟩\n    exact ⟨HomologyData.ofEpiOfIsIsoOfMono φ h₁, z₁⟩\n  · rintro ⟨h₂, z₂⟩\n    exact ⟨HomologyData.ofEpiOfIsIsoOfMono' φ h₂, z₂⟩\n\n"}
{"name":"CategoryTheory.ShortComplex.HomologyData.exact_iff_i_p_zero","module":"Mathlib.Algebra.Homology.ShortComplex.Exact","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_3, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nh : S.HomologyData\n⊢ Iff S.Exact (Eq (CategoryTheory.CategoryStruct.comp h.left.i h.right.p) 0)","decl":"lemma HomologyData.exact_iff_i_p_zero (h : S.HomologyData) :\n    S.Exact ↔ h.left.i ≫ h.right.p = 0 := by\n  haveI := HasHomology.mk' h\n  rw [h.left.exact_iff, ← h.comm]\n  constructor\n  · intro z\n    rw [IsZero.eq_of_src z h.iso.hom 0, zero_comp, comp_zero]\n  · intro eq\n    simp only [IsZero.iff_id_eq_zero, ← cancel_mono h.iso.hom, id_comp, ← cancel_mono h.right.ι,\n      ← cancel_epi h.left.π, eq, zero_comp, comp_zero]\n\n"}
{"name":"CategoryTheory.ShortComplex.exact_iff_i_p_zero","module":"Mathlib.Algebra.Homology.ShortComplex.Exact","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst✝ : S.HasHomology\nh₁ : S.LeftHomologyData\nh₂ : S.RightHomologyData\n⊢ Iff S.Exact (Eq (CategoryTheory.CategoryStruct.comp h₁.i h₂.p) 0)","decl":"lemma exact_iff_i_p_zero [S.HasHomology] (h₁ : S.LeftHomologyData)\n    (h₂ : S.RightHomologyData) :\n    S.Exact ↔ h₁.i ≫ h₂.p = 0 :=\n  (HomologyData.ofIsIsoLeftRightHomologyComparison' h₁ h₂).exact_iff_i_p_zero\n\n"}
{"name":"CategoryTheory.ShortComplex.exact_iff_iCycles_pOpcycles_zero","module":"Mathlib.Algebra.Homology.ShortComplex.Exact","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst✝ : S.HasHomology\n⊢ Iff S.Exact (Eq (CategoryTheory.CategoryStruct.comp S.iCycles S.pOpcycles) 0)","decl":"lemma exact_iff_iCycles_pOpcycles_zero [S.HasHomology] :\n    S.Exact ↔ S.iCycles ≫ S.pOpcycles = 0 :=\n  S.exact_iff_i_p_zero _ _\n\n"}
{"name":"CategoryTheory.ShortComplex.exact_iff_kernel_ι_comp_cokernel_π_zero","module":"Mathlib.Algebra.Homology.ShortComplex.Exact","initialProofState":"C : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_3, u_1} C\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst✝² : S.HasHomology\ninst✝¹ : CategoryTheory.Limits.HasKernel S.g\ninst✝ : CategoryTheory.Limits.HasCokernel S.f\n⊢ Iff S.Exact (Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.kernel.ι S.g) (CategoryTheory.Limits.cokernel.π S.f)) 0)","decl":"lemma exact_iff_kernel_ι_comp_cokernel_π_zero [S.HasHomology]\n    [HasKernel S.g] [HasCokernel S.f] :\n    S.Exact ↔ kernel.ι S.g ≫ cokernel.π S.f = 0 := by\n  haveI := HasLeftHomology.hasCokernel S\n  haveI := HasRightHomology.hasKernel S\n  exact S.exact_iff_i_p_zero (LeftHomologyData.ofHasKernelOfHasCokernel S)\n    (RightHomologyData.ofHasCokernelOfHasKernel S)\n\n"}
{"name":"CategoryTheory.ShortComplex.Exact.op","module":"Mathlib.Algebra.Homology.ShortComplex.Exact","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_3, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nh : S.Exact\n⊢ S.op.Exact","decl":"lemma Exact.op (h : S.Exact) : S.op.Exact := by\n  obtain ⟨h, z⟩ := h\n  exact ⟨⟨h.op, (IsZero.of_iso z h.iso.symm).op⟩⟩\n\n"}
{"name":"CategoryTheory.ShortComplex.Exact.unop","module":"Mathlib.Algebra.Homology.ShortComplex.Exact","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_3, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex (Opposite C)\nh : S.Exact\n⊢ S.unop.Exact","decl":"lemma Exact.unop {S : ShortComplex Cᵒᵖ} (h : S.Exact) : S.unop.Exact := by\n  obtain ⟨h, z⟩ := h\n  exact ⟨⟨h.unop, (IsZero.of_iso z h.iso.symm).unop⟩⟩\n\n"}
{"name":"CategoryTheory.ShortComplex.exact_op_iff","module":"Mathlib.Algebra.Homology.ShortComplex.Exact","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_3, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\n⊢ Iff S.op.Exact S.Exact","decl":"@[simp]\nlemma exact_op_iff : S.op.Exact ↔ S.Exact :=\n  ⟨Exact.unop, Exact.op⟩\n\n"}
{"name":"CategoryTheory.ShortComplex.exact_unop_iff","module":"Mathlib.Algebra.Homology.ShortComplex.Exact","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_3, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex (Opposite C)\n⊢ Iff S.unop.Exact S.Exact","decl":"@[simp]\nlemma exact_unop_iff (S : ShortComplex Cᵒᵖ) : S.unop.Exact ↔ S.Exact :=\n  S.unop.exact_op_iff.symm\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.exact_map_iff","module":"Mathlib.Algebra.Homology.ShortComplex.Exact","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁶ : CategoryTheory.Category.{u_3, u_1} C\ninst✝⁵ : CategoryTheory.Category.{u_4, u_2} D\ninst✝⁴ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms D\nS : CategoryTheory.ShortComplex C\nh : S.LeftHomologyData\nF : CategoryTheory.Functor C D\ninst✝² : F.PreservesZeroMorphisms\ninst✝¹ : h.IsPreservedBy F\ninst✝ : (S.map F).HasHomology\n⊢ Iff (S.map F).Exact (CategoryTheory.Limits.IsZero (F.obj h.H))","decl":"lemma LeftHomologyData.exact_map_iff (h : S.LeftHomologyData) (F : C ⥤ D)\n    [F.PreservesZeroMorphisms] [h.IsPreservedBy F] [(S.map F).HasHomology] :\n    (S.map F).Exact ↔ IsZero (F.obj h.H) :=\n  (h.map F).exact_iff\n\n"}
{"name":"CategoryTheory.ShortComplex.RightHomologyData.exact_map_iff","module":"Mathlib.Algebra.Homology.ShortComplex.Exact","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁶ : CategoryTheory.Category.{u_3, u_1} C\ninst✝⁵ : CategoryTheory.Category.{u_4, u_2} D\ninst✝⁴ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms D\nS : CategoryTheory.ShortComplex C\nh : S.RightHomologyData\nF : CategoryTheory.Functor C D\ninst✝² : F.PreservesZeroMorphisms\ninst✝¹ : h.IsPreservedBy F\ninst✝ : (S.map F).HasHomology\n⊢ Iff (S.map F).Exact (CategoryTheory.Limits.IsZero (F.obj h.H))","decl":"lemma RightHomologyData.exact_map_iff (h : S.RightHomologyData) (F : C ⥤ D)\n    [F.PreservesZeroMorphisms] [h.IsPreservedBy F] [(S.map F).HasHomology] :\n    (S.map F).Exact ↔ IsZero (F.obj h.H) :=\n  (h.map F).exact_iff\n\n"}
{"name":"CategoryTheory.ShortComplex.Exact.map_of_preservesLeftHomologyOf","module":"Mathlib.Algebra.Homology.ShortComplex.Exact","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁶ : CategoryTheory.Category.{u_3, u_1} C\ninst✝⁵ : CategoryTheory.Category.{u_4, u_2} D\ninst✝⁴ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms D\nS : CategoryTheory.ShortComplex C\nh : S.Exact\nF : CategoryTheory.Functor C D\ninst✝² : F.PreservesZeroMorphisms\ninst✝¹ : F.PreservesLeftHomologyOf S\ninst✝ : (S.map F).HasHomology\n⊢ (S.map F).Exact","decl":"lemma Exact.map_of_preservesLeftHomologyOf (h : S.Exact) (F : C ⥤ D)\n    [F.PreservesZeroMorphisms] [F.PreservesLeftHomologyOf S]\n    [(S.map F).HasHomology] : (S.map F).Exact := by\n  have := h.hasHomology\n  rw [S.leftHomologyData.exact_iff, IsZero.iff_id_eq_zero] at h\n  rw [S.leftHomologyData.exact_map_iff F, IsZero.iff_id_eq_zero,\n    ← F.map_id, h, F.map_zero]\n\n"}
{"name":"CategoryTheory.ShortComplex.Exact.map_of_preservesRightHomologyOf","module":"Mathlib.Algebra.Homology.ShortComplex.Exact","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁶ : CategoryTheory.Category.{u_3, u_1} C\ninst✝⁵ : CategoryTheory.Category.{u_4, u_2} D\ninst✝⁴ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms D\nS : CategoryTheory.ShortComplex C\nh : S.Exact\nF : CategoryTheory.Functor C D\ninst✝² : F.PreservesZeroMorphisms\ninst✝¹ : F.PreservesRightHomologyOf S\ninst✝ : (S.map F).HasHomology\n⊢ (S.map F).Exact","decl":"lemma Exact.map_of_preservesRightHomologyOf (h : S.Exact) (F : C ⥤ D)\n    [F.PreservesZeroMorphisms] [F.PreservesRightHomologyOf S]\n    [(S.map F).HasHomology] : (S.map F).Exact := by\n  have : S.HasHomology := h.hasHomology\n  rw [S.rightHomologyData.exact_iff, IsZero.iff_id_eq_zero] at h\n  rw [S.rightHomologyData.exact_map_iff F, IsZero.iff_id_eq_zero,\n    ← F.map_id, h, F.map_zero]\n\n"}
{"name":"CategoryTheory.ShortComplex.Exact.map","module":"Mathlib.Algebra.Homology.ShortComplex.Exact","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁶ : CategoryTheory.Category.{u_3, u_1} C\ninst✝⁵ : CategoryTheory.Category.{u_4, u_2} D\ninst✝⁴ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms D\nS : CategoryTheory.ShortComplex C\nh : S.Exact\nF : CategoryTheory.Functor C D\ninst✝² : F.PreservesZeroMorphisms\ninst✝¹ : F.PreservesLeftHomologyOf S\ninst✝ : F.PreservesRightHomologyOf S\n⊢ (S.map F).Exact","decl":"lemma Exact.map (h : S.Exact) (F : C ⥤ D)\n    [F.PreservesZeroMorphisms] [F.PreservesLeftHomologyOf S]\n    [F.PreservesRightHomologyOf S] : (S.map F).Exact := by\n  have := h.hasHomology\n  exact h.map_of_preservesLeftHomologyOf F\n\n"}
{"name":"CategoryTheory.ShortComplex.exact_map_iff_of_faithful","module":"Mathlib.Algebra.Homology.ShortComplex.Exact","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁸ : CategoryTheory.Category.{u_3, u_1} C\ninst✝⁷ : CategoryTheory.Category.{u_4, u_2} D\ninst✝⁶ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝⁵ : CategoryTheory.Limits.HasZeroMorphisms D\nS : CategoryTheory.ShortComplex C\ninst✝⁴ : S.HasHomology\nF : CategoryTheory.Functor C D\ninst✝³ : F.PreservesZeroMorphisms\ninst✝² : F.PreservesLeftHomologyOf S\ninst✝¹ : F.PreservesRightHomologyOf S\ninst✝ : F.Faithful\n⊢ Iff (S.map F).Exact S.Exact","decl":"lemma exact_map_iff_of_faithful [S.HasHomology]\n    (F : C ⥤ D) [F.PreservesZeroMorphisms] [F.PreservesLeftHomologyOf S]\n    [F.PreservesRightHomologyOf S] [F.Faithful] :\n    (S.map F).Exact ↔ S.Exact := by\n  constructor\n  · intro h\n    rw [S.leftHomologyData.exact_iff, IsZero.iff_id_eq_zero]\n    rw [(S.leftHomologyData.map F).exact_iff, IsZero.iff_id_eq_zero,\n      LeftHomologyData.map_H] at h\n    apply F.map_injective\n    rw [F.map_id, F.map_zero, h]\n  · intro h\n    exact h.map F\n\n"}
{"name":"CategoryTheory.ShortComplex.Exact.comp_eq_zero","module":"Mathlib.Algebra.Homology.ShortComplex.Exact","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_3, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nh : S.Exact\nX Y : C\na : Quiver.Hom X S.X₂\nha : Eq (CategoryTheory.CategoryStruct.comp a S.g) 0\nb : Quiver.Hom S.X₂ Y\nhb : Eq (CategoryTheory.CategoryStruct.comp S.f b) 0\n⊢ Eq (CategoryTheory.CategoryStruct.comp a b) 0","decl":"@[reassoc]\nlemma Exact.comp_eq_zero (h : S.Exact) {X Y : C} {a : X ⟶ S.X₂} (ha : a ≫ S.g = 0)\n    {b : S.X₂ ⟶ Y} (hb : S.f ≫ b = 0) : a ≫ b = 0 := by\n  have := h.hasHomology\n  have eq := h\n  rw [exact_iff_iCycles_pOpcycles_zero] at eq\n  rw [← S.liftCycles_i a ha, ← S.p_descOpcycles b hb, assoc, reassoc_of% eq,\n    zero_comp, comp_zero]\n\n"}
{"name":"CategoryTheory.ShortComplex.Exact.comp_eq_zero_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.Exact","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_3, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nh✝ : S.Exact\nX Y : C\na : Quiver.Hom X S.X₂\nha : Eq (CategoryTheory.CategoryStruct.comp a S.g) 0\nb : Quiver.Hom S.X₂ Y\nhb : Eq (CategoryTheory.CategoryStruct.comp S.f b) 0\nZ : C\nh : Quiver.Hom Y Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp a (CategoryTheory.CategoryStruct.comp b h)) (CategoryTheory.CategoryStruct.comp 0 h)","decl":"@[reassoc]\nlemma Exact.comp_eq_zero (h : S.Exact) {X Y : C} {a : X ⟶ S.X₂} (ha : a ≫ S.g = 0)\n    {b : S.X₂ ⟶ Y} (hb : S.f ≫ b = 0) : a ≫ b = 0 := by\n  have := h.hasHomology\n  have eq := h\n  rw [exact_iff_iCycles_pOpcycles_zero] at eq\n  rw [← S.liftCycles_i a ha, ← S.p_descOpcycles b hb, assoc, reassoc_of% eq,\n    zero_comp, comp_zero]\n\n"}
{"name":"CategoryTheory.ShortComplex.Exact.isZero_of_both_zeros","module":"Mathlib.Algebra.Homology.ShortComplex.Exact","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_3, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nex : S.Exact\nhf : Eq S.f 0\nhg : Eq S.g 0\n⊢ CategoryTheory.Limits.IsZero S.X₂","decl":"lemma Exact.isZero_of_both_zeros (ex : S.Exact) (hf : S.f = 0) (hg : S.g = 0) :\n    IsZero S.X₂ :=\n  (ShortComplex.HomologyData.ofZeros S hf hg).exact_iff.1 ex\n\n"}
{"name":"CategoryTheory.ShortComplex.exact_iff_mono","module":"Mathlib.Algebra.Homology.ShortComplex.Exact","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\nS : CategoryTheory.ShortComplex C\ninst✝ : CategoryTheory.Limits.HasZeroObject C\nhf : Eq S.f 0\n⊢ Iff S.Exact (CategoryTheory.Mono S.g)","decl":"lemma exact_iff_mono [HasZeroObject C] (hf : S.f = 0) :\n    S.Exact ↔ Mono S.g := by\n  constructor\n  · intro h\n    have := h.hasHomology\n    simp only [exact_iff_isZero_homology] at h\n    have := S.isIso_pOpcycles hf\n    have := mono_of_isZero_kernel' _ S.homologyIsKernel h\n    rw [← S.p_fromOpcycles]\n    apply mono_comp\n  · intro\n    rw [(HomologyData.ofIsLimitKernelFork S hf _\n      (KernelFork.IsLimit.ofMonoOfIsZero (KernelFork.ofι (0 : 0 ⟶ S.X₂) zero_comp)\n        inferInstance (isZero_zero C))).exact_iff]\n    exact isZero_zero C\n\n"}
{"name":"CategoryTheory.ShortComplex.exact_iff_epi","module":"Mathlib.Algebra.Homology.ShortComplex.Exact","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\nS : CategoryTheory.ShortComplex C\ninst✝ : CategoryTheory.Limits.HasZeroObject C\nhg : Eq S.g 0\n⊢ Iff S.Exact (CategoryTheory.Epi S.f)","decl":"lemma exact_iff_epi [HasZeroObject C] (hg : S.g = 0) :\n    S.Exact ↔ Epi S.f := by\n  constructor\n  · intro h\n    have := h.hasHomology\n    simp only [exact_iff_isZero_homology] at h\n    haveI := S.isIso_iCycles hg\n    haveI : Epi S.toCycles := epi_of_isZero_cokernel' _ S.homologyIsCokernel h\n    rw [← S.toCycles_i]\n    apply epi_comp\n  · intro\n    rw [(HomologyData.ofIsColimitCokernelCofork S hg _\n      (CokernelCofork.IsColimit.ofEpiOfIsZero (CokernelCofork.ofπ (0 : S.X₂ ⟶ 0) comp_zero)\n        inferInstance (isZero_zero C))).exact_iff]\n    exact isZero_zero C\n\n"}
{"name":"CategoryTheory.ShortComplex.Exact.epi_f'","module":"Mathlib.Algebra.Homology.ShortComplex.Exact","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_3, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nS : CategoryTheory.ShortComplex C\nhS : S.Exact\nh : S.LeftHomologyData\n⊢ CategoryTheory.Epi h.f'","decl":"lemma Exact.epi_f' (hS : S.Exact) (h : LeftHomologyData S) : Epi h.f' :=\n  epi_of_isZero_cokernel' _ h.hπ (by\n    haveI := hS.hasHomology\n    dsimp\n    simpa only [← h.exact_iff] using hS)\n\n"}
{"name":"CategoryTheory.ShortComplex.Exact.mono_g'","module":"Mathlib.Algebra.Homology.ShortComplex.Exact","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_3, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nS : CategoryTheory.ShortComplex C\nhS : S.Exact\nh : S.RightHomologyData\n⊢ CategoryTheory.Mono h.g'","decl":"lemma Exact.mono_g' (hS : S.Exact) (h : RightHomologyData S) : Mono h.g' :=\n  mono_of_isZero_kernel' _ h.hι (by\n    haveI := hS.hasHomology\n    dsimp\n    simpa only [← h.exact_iff] using hS)\n\n"}
{"name":"CategoryTheory.ShortComplex.Exact.epi_toCycles","module":"Mathlib.Algebra.Homology.ShortComplex.Exact","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\nS : CategoryTheory.ShortComplex C\nhS : S.Exact\ninst✝ : S.HasLeftHomology\n⊢ CategoryTheory.Epi S.toCycles","decl":"lemma Exact.epi_toCycles (hS : S.Exact) [S.HasLeftHomology] : Epi S.toCycles :=\n  hS.epi_f' _\n\n"}
{"name":"CategoryTheory.ShortComplex.Exact.mono_fromOpcycles","module":"Mathlib.Algebra.Homology.ShortComplex.Exact","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\nS : CategoryTheory.ShortComplex C\nhS : S.Exact\ninst✝ : S.HasRightHomology\n⊢ CategoryTheory.Mono S.fromOpcycles","decl":"lemma Exact.mono_fromOpcycles (hS : S.Exact) [S.HasRightHomology] : Mono S.fromOpcycles :=\n  hS.mono_g' _\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.exact_iff_epi_f'","module":"Mathlib.Algebra.Homology.ShortComplex.Exact","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\nS : CategoryTheory.ShortComplex C\ninst✝ : S.HasHomology\nh : S.LeftHomologyData\n⊢ Iff S.Exact (CategoryTheory.Epi h.f')","decl":"lemma LeftHomologyData.exact_iff_epi_f' [S.HasHomology] (h : LeftHomologyData S) :\n    S.Exact ↔ Epi h.f' := by\n  constructor\n  · intro hS\n    exact hS.epi_f' h\n  · intro\n    simp only [h.exact_iff, IsZero.iff_id_eq_zero, ← cancel_epi h.π, ← cancel_epi h.f',\n      comp_id, h.f'_π, comp_zero]\n\n"}
{"name":"CategoryTheory.ShortComplex.RightHomologyData.exact_iff_mono_g'","module":"Mathlib.Algebra.Homology.ShortComplex.Exact","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\nS : CategoryTheory.ShortComplex C\ninst✝ : S.HasHomology\nh : S.RightHomologyData\n⊢ Iff S.Exact (CategoryTheory.Mono h.g')","decl":"lemma RightHomologyData.exact_iff_mono_g' [S.HasHomology] (h : RightHomologyData S) :\n    S.Exact ↔ Mono h.g' := by\n  constructor\n  · intro hS\n    exact hS.mono_g' h\n  · intro\n    simp only [h.exact_iff, IsZero.iff_id_eq_zero, ← cancel_mono h.ι, ← cancel_mono h.g',\n      id_comp, h.ι_g', zero_comp]\n\n"}
{"name":"CategoryTheory.ShortComplex.Exact.leftHomologyDataOfIsLimitKernelFork_i","module":"Mathlib.Algebra.Homology.ShortComplex.Exact","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\nS : CategoryTheory.ShortComplex C\nhS : S.Exact\ninst✝ : CategoryTheory.Limits.HasZeroObject C\nkf : CategoryTheory.Limits.KernelFork S.g\nhkf : CategoryTheory.Limits.IsLimit kf\n⊢ Eq (hS.leftHomologyDataOfIsLimitKernelFork kf hkf).i (CategoryTheory.Limits.Fork.ι kf)","decl":"/-- Given an exact short complex `S` and a limit kernel fork `kf` for `S.g`, this is the\nleft homology data for `S` with `K := kf.pt` and `H := 0`. -/\n@[simps]\nnoncomputable def Exact.leftHomologyDataOfIsLimitKernelFork\n    (hS : S.Exact) [HasZeroObject C] (kf : KernelFork S.g) (hkf : IsLimit kf) :\n    S.LeftHomologyData where\n  K := kf.pt\n  H := 0\n  i := kf.ι\n  π := 0\n  wi := kf.condition\n  hi := IsLimit.ofIsoLimit hkf (Fork.ext (Iso.refl _) (by simp))\n  wπ := comp_zero\n  hπ := CokernelCofork.IsColimit.ofEpiOfIsZero _ (by\n    have := hS.hasHomology\n    refine ((MorphismProperty.epimorphisms C).arrow_mk_iso_iff ?_).1\n      hS.epi_toCycles\n    refine Arrow.isoMk (Iso.refl _)\n      (IsLimit.conePointUniqueUpToIso S.cyclesIsKernel hkf) ?_\n    apply Fork.IsLimit.hom_ext hkf\n    simp [IsLimit.conePointUniqueUpToIso]) (isZero_zero C)\n\n"}
{"name":"CategoryTheory.ShortComplex.Exact.leftHomologyDataOfIsLimitKernelFork_K","module":"Mathlib.Algebra.Homology.ShortComplex.Exact","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\nS : CategoryTheory.ShortComplex C\nhS : S.Exact\ninst✝ : CategoryTheory.Limits.HasZeroObject C\nkf : CategoryTheory.Limits.KernelFork S.g\nhkf : CategoryTheory.Limits.IsLimit kf\n⊢ Eq (hS.leftHomologyDataOfIsLimitKernelFork kf hkf).K kf.pt","decl":"/-- Given an exact short complex `S` and a limit kernel fork `kf` for `S.g`, this is the\nleft homology data for `S` with `K := kf.pt` and `H := 0`. -/\n@[simps]\nnoncomputable def Exact.leftHomologyDataOfIsLimitKernelFork\n    (hS : S.Exact) [HasZeroObject C] (kf : KernelFork S.g) (hkf : IsLimit kf) :\n    S.LeftHomologyData where\n  K := kf.pt\n  H := 0\n  i := kf.ι\n  π := 0\n  wi := kf.condition\n  hi := IsLimit.ofIsoLimit hkf (Fork.ext (Iso.refl _) (by simp))\n  wπ := comp_zero\n  hπ := CokernelCofork.IsColimit.ofEpiOfIsZero _ (by\n    have := hS.hasHomology\n    refine ((MorphismProperty.epimorphisms C).arrow_mk_iso_iff ?_).1\n      hS.epi_toCycles\n    refine Arrow.isoMk (Iso.refl _)\n      (IsLimit.conePointUniqueUpToIso S.cyclesIsKernel hkf) ?_\n    apply Fork.IsLimit.hom_ext hkf\n    simp [IsLimit.conePointUniqueUpToIso]) (isZero_zero C)\n\n"}
{"name":"CategoryTheory.ShortComplex.Exact.leftHomologyDataOfIsLimitKernelFork_π","module":"Mathlib.Algebra.Homology.ShortComplex.Exact","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\nS : CategoryTheory.ShortComplex C\nhS : S.Exact\ninst✝ : CategoryTheory.Limits.HasZeroObject C\nkf : CategoryTheory.Limits.KernelFork S.g\nhkf : CategoryTheory.Limits.IsLimit kf\n⊢ Eq (hS.leftHomologyDataOfIsLimitKernelFork kf hkf).π 0","decl":"/-- Given an exact short complex `S` and a limit kernel fork `kf` for `S.g`, this is the\nleft homology data for `S` with `K := kf.pt` and `H := 0`. -/\n@[simps]\nnoncomputable def Exact.leftHomologyDataOfIsLimitKernelFork\n    (hS : S.Exact) [HasZeroObject C] (kf : KernelFork S.g) (hkf : IsLimit kf) :\n    S.LeftHomologyData where\n  K := kf.pt\n  H := 0\n  i := kf.ι\n  π := 0\n  wi := kf.condition\n  hi := IsLimit.ofIsoLimit hkf (Fork.ext (Iso.refl _) (by simp))\n  wπ := comp_zero\n  hπ := CokernelCofork.IsColimit.ofEpiOfIsZero _ (by\n    have := hS.hasHomology\n    refine ((MorphismProperty.epimorphisms C).arrow_mk_iso_iff ?_).1\n      hS.epi_toCycles\n    refine Arrow.isoMk (Iso.refl _)\n      (IsLimit.conePointUniqueUpToIso S.cyclesIsKernel hkf) ?_\n    apply Fork.IsLimit.hom_ext hkf\n    simp [IsLimit.conePointUniqueUpToIso]) (isZero_zero C)\n\n"}
{"name":"CategoryTheory.ShortComplex.Exact.leftHomologyDataOfIsLimitKernelFork_H","module":"Mathlib.Algebra.Homology.ShortComplex.Exact","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\nS : CategoryTheory.ShortComplex C\nhS : S.Exact\ninst✝ : CategoryTheory.Limits.HasZeroObject C\nkf : CategoryTheory.Limits.KernelFork S.g\nhkf : CategoryTheory.Limits.IsLimit kf\n⊢ Eq (hS.leftHomologyDataOfIsLimitKernelFork kf hkf).H 0","decl":"/-- Given an exact short complex `S` and a limit kernel fork `kf` for `S.g`, this is the\nleft homology data for `S` with `K := kf.pt` and `H := 0`. -/\n@[simps]\nnoncomputable def Exact.leftHomologyDataOfIsLimitKernelFork\n    (hS : S.Exact) [HasZeroObject C] (kf : KernelFork S.g) (hkf : IsLimit kf) :\n    S.LeftHomologyData where\n  K := kf.pt\n  H := 0\n  i := kf.ι\n  π := 0\n  wi := kf.condition\n  hi := IsLimit.ofIsoLimit hkf (Fork.ext (Iso.refl _) (by simp))\n  wπ := comp_zero\n  hπ := CokernelCofork.IsColimit.ofEpiOfIsZero _ (by\n    have := hS.hasHomology\n    refine ((MorphismProperty.epimorphisms C).arrow_mk_iso_iff ?_).1\n      hS.epi_toCycles\n    refine Arrow.isoMk (Iso.refl _)\n      (IsLimit.conePointUniqueUpToIso S.cyclesIsKernel hkf) ?_\n    apply Fork.IsLimit.hom_ext hkf\n    simp [IsLimit.conePointUniqueUpToIso]) (isZero_zero C)\n\n"}
{"name":"CategoryTheory.ShortComplex.Exact.rightHomologyDataOfIsColimitCokernelCofork_H","module":"Mathlib.Algebra.Homology.ShortComplex.Exact","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\nS : CategoryTheory.ShortComplex C\nhS : S.Exact\ninst✝ : CategoryTheory.Limits.HasZeroObject C\ncc : CategoryTheory.Limits.CokernelCofork S.f\nhcc : CategoryTheory.Limits.IsColimit cc\n⊢ Eq (hS.rightHomologyDataOfIsColimitCokernelCofork cc hcc).H 0","decl":"/-- Given an exact short complex `S` and a colimit cokernel cofork `cc` for `S.f`, this is the\nright homology data for `S` with `Q := cc.pt` and `H := 0`. -/\n@[simps]\nnoncomputable def Exact.rightHomologyDataOfIsColimitCokernelCofork\n    (hS : S.Exact) [HasZeroObject C] (cc : CokernelCofork S.f) (hcc : IsColimit cc) :\n    S.RightHomologyData where\n  Q := cc.pt\n  H := 0\n  p := cc.π\n  ι := 0\n  wp := cc.condition\n  hp := IsColimit.ofIsoColimit hcc (Cofork.ext (Iso.refl _) (by simp))\n  wι := zero_comp\n  hι := KernelFork.IsLimit.ofMonoOfIsZero _ (by\n    have := hS.hasHomology\n    refine ((MorphismProperty.monomorphisms C).arrow_mk_iso_iff ?_).2\n      hS.mono_fromOpcycles\n    refine Arrow.isoMk (IsColimit.coconePointUniqueUpToIso hcc S.opcyclesIsCokernel)\n      (Iso.refl _) ?_\n    apply Cofork.IsColimit.hom_ext hcc\n    simp [IsColimit.coconePointUniqueUpToIso]) (isZero_zero C)\n\n"}
{"name":"CategoryTheory.ShortComplex.Exact.rightHomologyDataOfIsColimitCokernelCofork_ι","module":"Mathlib.Algebra.Homology.ShortComplex.Exact","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\nS : CategoryTheory.ShortComplex C\nhS : S.Exact\ninst✝ : CategoryTheory.Limits.HasZeroObject C\ncc : CategoryTheory.Limits.CokernelCofork S.f\nhcc : CategoryTheory.Limits.IsColimit cc\n⊢ Eq (hS.rightHomologyDataOfIsColimitCokernelCofork cc hcc).ι 0","decl":"/-- Given an exact short complex `S` and a colimit cokernel cofork `cc` for `S.f`, this is the\nright homology data for `S` with `Q := cc.pt` and `H := 0`. -/\n@[simps]\nnoncomputable def Exact.rightHomologyDataOfIsColimitCokernelCofork\n    (hS : S.Exact) [HasZeroObject C] (cc : CokernelCofork S.f) (hcc : IsColimit cc) :\n    S.RightHomologyData where\n  Q := cc.pt\n  H := 0\n  p := cc.π\n  ι := 0\n  wp := cc.condition\n  hp := IsColimit.ofIsoColimit hcc (Cofork.ext (Iso.refl _) (by simp))\n  wι := zero_comp\n  hι := KernelFork.IsLimit.ofMonoOfIsZero _ (by\n    have := hS.hasHomology\n    refine ((MorphismProperty.monomorphisms C).arrow_mk_iso_iff ?_).2\n      hS.mono_fromOpcycles\n    refine Arrow.isoMk (IsColimit.coconePointUniqueUpToIso hcc S.opcyclesIsCokernel)\n      (Iso.refl _) ?_\n    apply Cofork.IsColimit.hom_ext hcc\n    simp [IsColimit.coconePointUniqueUpToIso]) (isZero_zero C)\n\n"}
{"name":"CategoryTheory.ShortComplex.Exact.rightHomologyDataOfIsColimitCokernelCofork_Q","module":"Mathlib.Algebra.Homology.ShortComplex.Exact","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\nS : CategoryTheory.ShortComplex C\nhS : S.Exact\ninst✝ : CategoryTheory.Limits.HasZeroObject C\ncc : CategoryTheory.Limits.CokernelCofork S.f\nhcc : CategoryTheory.Limits.IsColimit cc\n⊢ Eq (hS.rightHomologyDataOfIsColimitCokernelCofork cc hcc).Q cc.pt","decl":"/-- Given an exact short complex `S` and a colimit cokernel cofork `cc` for `S.f`, this is the\nright homology data for `S` with `Q := cc.pt` and `H := 0`. -/\n@[simps]\nnoncomputable def Exact.rightHomologyDataOfIsColimitCokernelCofork\n    (hS : S.Exact) [HasZeroObject C] (cc : CokernelCofork S.f) (hcc : IsColimit cc) :\n    S.RightHomologyData where\n  Q := cc.pt\n  H := 0\n  p := cc.π\n  ι := 0\n  wp := cc.condition\n  hp := IsColimit.ofIsoColimit hcc (Cofork.ext (Iso.refl _) (by simp))\n  wι := zero_comp\n  hι := KernelFork.IsLimit.ofMonoOfIsZero _ (by\n    have := hS.hasHomology\n    refine ((MorphismProperty.monomorphisms C).arrow_mk_iso_iff ?_).2\n      hS.mono_fromOpcycles\n    refine Arrow.isoMk (IsColimit.coconePointUniqueUpToIso hcc S.opcyclesIsCokernel)\n      (Iso.refl _) ?_\n    apply Cofork.IsColimit.hom_ext hcc\n    simp [IsColimit.coconePointUniqueUpToIso]) (isZero_zero C)\n\n"}
{"name":"CategoryTheory.ShortComplex.Exact.rightHomologyDataOfIsColimitCokernelCofork_p","module":"Mathlib.Algebra.Homology.ShortComplex.Exact","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\nS : CategoryTheory.ShortComplex C\nhS : S.Exact\ninst✝ : CategoryTheory.Limits.HasZeroObject C\ncc : CategoryTheory.Limits.CokernelCofork S.f\nhcc : CategoryTheory.Limits.IsColimit cc\n⊢ Eq (hS.rightHomologyDataOfIsColimitCokernelCofork cc hcc).p (CategoryTheory.Limits.Cofork.π cc)","decl":"/-- Given an exact short complex `S` and a colimit cokernel cofork `cc` for `S.f`, this is the\nright homology data for `S` with `Q := cc.pt` and `H := 0`. -/\n@[simps]\nnoncomputable def Exact.rightHomologyDataOfIsColimitCokernelCofork\n    (hS : S.Exact) [HasZeroObject C] (cc : CokernelCofork S.f) (hcc : IsColimit cc) :\n    S.RightHomologyData where\n  Q := cc.pt\n  H := 0\n  p := cc.π\n  ι := 0\n  wp := cc.condition\n  hp := IsColimit.ofIsoColimit hcc (Cofork.ext (Iso.refl _) (by simp))\n  wι := zero_comp\n  hι := KernelFork.IsLimit.ofMonoOfIsZero _ (by\n    have := hS.hasHomology\n    refine ((MorphismProperty.monomorphisms C).arrow_mk_iso_iff ?_).2\n      hS.mono_fromOpcycles\n    refine Arrow.isoMk (IsColimit.coconePointUniqueUpToIso hcc S.opcyclesIsCokernel)\n      (Iso.refl _) ?_\n    apply Cofork.IsColimit.hom_ext hcc\n    simp [IsColimit.coconePointUniqueUpToIso]) (isZero_zero C)\n\n"}
{"name":"CategoryTheory.ShortComplex.exact_iff_epi_toCycles","module":"Mathlib.Algebra.Homology.ShortComplex.Exact","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\nS : CategoryTheory.ShortComplex C\ninst✝ : S.HasHomology\n⊢ Iff S.Exact (CategoryTheory.Epi S.toCycles)","decl":"lemma exact_iff_epi_toCycles [S.HasHomology] : S.Exact ↔ Epi S.toCycles :=\n  S.leftHomologyData.exact_iff_epi_f'\n\n"}
{"name":"CategoryTheory.ShortComplex.exact_iff_mono_fromOpcycles","module":"Mathlib.Algebra.Homology.ShortComplex.Exact","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\nS : CategoryTheory.ShortComplex C\ninst✝ : S.HasHomology\n⊢ Iff S.Exact (CategoryTheory.Mono S.fromOpcycles)","decl":"lemma exact_iff_mono_fromOpcycles [S.HasHomology] : S.Exact ↔ Mono S.fromOpcycles :=\n  S.rightHomologyData.exact_iff_mono_g'\n\n"}
{"name":"CategoryTheory.ShortComplex.exact_iff_epi_kernel_lift","module":"Mathlib.Algebra.Homology.ShortComplex.Exact","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_3, u_1} C\ninst✝² : CategoryTheory.Preadditive C\nS : CategoryTheory.ShortComplex C\ninst✝¹ : S.HasHomology\ninst✝ : CategoryTheory.Limits.HasKernel S.g\n⊢ Iff S.Exact (CategoryTheory.Epi (CategoryTheory.Limits.kernel.lift S.g S.f ⋯))","decl":"lemma exact_iff_epi_kernel_lift [S.HasHomology] [HasKernel S.g] :\n    S.Exact ↔ Epi (kernel.lift S.g S.f S.zero) := by\n  rw [exact_iff_epi_toCycles]\n  apply (MorphismProperty.epimorphisms C).arrow_mk_iso_iff\n  exact Arrow.isoMk (Iso.refl _) S.cyclesIsoKernel (by aesop_cat)\n\n"}
{"name":"CategoryTheory.ShortComplex.exact_iff_mono_cokernel_desc","module":"Mathlib.Algebra.Homology.ShortComplex.Exact","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_3, u_1} C\ninst✝² : CategoryTheory.Preadditive C\nS : CategoryTheory.ShortComplex C\ninst✝¹ : S.HasHomology\ninst✝ : CategoryTheory.Limits.HasCokernel S.f\n⊢ Iff S.Exact (CategoryTheory.Mono (CategoryTheory.Limits.cokernel.desc S.f S.g ⋯))","decl":"lemma exact_iff_mono_cokernel_desc [S.HasHomology] [HasCokernel S.f] :\n    S.Exact ↔ Mono (cokernel.desc S.f S.g S.zero) := by\n  rw [exact_iff_mono_fromOpcycles]\n  refine (MorphismProperty.monomorphisms C).arrow_mk_iso_iff (Iso.symm ?_)\n  exact Arrow.isoMk S.opcyclesIsoCokernel.symm (Iso.refl _) (by aesop_cat)\n\n"}
{"name":"CategoryTheory.ShortComplex.QuasiIso.exact_iff","module":"Mathlib.Algebra.Homology.ShortComplex.Exact","initialProofState":"C : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_3, u_1} C\ninst✝³ : CategoryTheory.Preadditive C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\ninst✝² : S₁.HasHomology\ninst✝¹ : S₂.HasHomology\ninst✝ : CategoryTheory.ShortComplex.QuasiIso φ\n⊢ Iff S₁.Exact S₂.Exact","decl":"lemma QuasiIso.exact_iff {S₁ S₂ : ShortComplex C} (φ : S₁ ⟶ S₂)\n    [S₁.HasHomology] [S₂.HasHomology] [QuasiIso φ] : S₁.Exact ↔ S₂.Exact := by\n  simp only [exact_iff_isZero_homology]\n  exact Iso.isZero_iff (asIso (homologyMap φ))\n\n"}
{"name":"CategoryTheory.ShortComplex.exact_of_f_is_kernel","module":"Mathlib.Algebra.Homology.ShortComplex.Exact","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\nS : CategoryTheory.ShortComplex C\nhS : CategoryTheory.Limits.IsLimit (CategoryTheory.Limits.KernelFork.ofι S.f ⋯)\ninst✝ : S.HasHomology\n⊢ S.Exact","decl":"lemma exact_of_f_is_kernel (hS : IsLimit (KernelFork.ofι S.f S.zero))\n    [S.HasHomology] : S.Exact := by\n  rw [exact_iff_epi_toCycles]\n  have : IsSplitEpi S.toCycles :=\n    ⟨⟨{ section_ := hS.lift (KernelFork.ofι S.iCycles S.iCycles_g)\n        id := by\n          rw [← cancel_mono S.iCycles, assoc, toCycles_i, id_comp]\n          exact Fork.IsLimit.lift_ι hS }⟩⟩\n  infer_instance\n\n"}
{"name":"CategoryTheory.ShortComplex.exact_of_g_is_cokernel","module":"Mathlib.Algebra.Homology.ShortComplex.Exact","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\nS : CategoryTheory.ShortComplex C\nhS : CategoryTheory.Limits.IsColimit (CategoryTheory.Limits.CokernelCofork.ofπ S.g ⋯)\ninst✝ : S.HasHomology\n⊢ S.Exact","decl":"lemma exact_of_g_is_cokernel (hS : IsColimit (CokernelCofork.ofπ S.g S.zero))\n    [S.HasHomology] : S.Exact := by\n  rw [exact_iff_mono_fromOpcycles]\n  have : IsSplitMono S.fromOpcycles :=\n    ⟨⟨{ retraction := hS.desc (CokernelCofork.ofπ S.pOpcycles S.f_pOpcycles)\n        id := by\n          rw [← cancel_epi S.pOpcycles, p_fromOpcycles_assoc, comp_id]\n          exact Cofork.IsColimit.π_desc hS }⟩⟩\n  infer_instance\n\n"}
{"name":"CategoryTheory.ShortComplex.Exact.mono_g","module":"Mathlib.Algebra.Homology.ShortComplex.Exact","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_3, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nS : CategoryTheory.ShortComplex C\nhS : S.Exact\nhf : Eq S.f 0\n⊢ CategoryTheory.Mono S.g","decl":"lemma Exact.mono_g (hS : S.Exact) (hf : S.f = 0) : Mono S.g := by\n  have := hS.hasHomology\n  have := hS.epi_toCycles\n  have : S.iCycles = 0 := by rw [← cancel_epi S.toCycles, comp_zero, toCycles_i, hf]\n  apply Preadditive.mono_of_cancel_zero\n  intro A x₂ hx₂\n  rw [← S.liftCycles_i x₂ hx₂, this, comp_zero]\n\n"}
{"name":"CategoryTheory.ShortComplex.Exact.epi_f","module":"Mathlib.Algebra.Homology.ShortComplex.Exact","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_3, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nS : CategoryTheory.ShortComplex C\nhS : S.Exact\nhg : Eq S.g 0\n⊢ CategoryTheory.Epi S.f","decl":"lemma Exact.epi_f (hS : S.Exact) (hg : S.g = 0) : Epi S.f := by\n  have := hS.hasHomology\n  have := hS.mono_fromOpcycles\n  have : S.pOpcycles = 0 := by rw [← cancel_mono S.fromOpcycles, zero_comp, p_fromOpcycles, hg]\n  apply Preadditive.epi_of_cancel_zero\n  intro A x₂ hx₂\n  rw [← S.p_descOpcycles x₂ hx₂, this, zero_comp]\n\n"}
{"name":"CategoryTheory.ShortComplex.Exact.mono_g_iff","module":"Mathlib.Algebra.Homology.ShortComplex.Exact","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_3, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nS : CategoryTheory.ShortComplex C\nhS : S.Exact\n⊢ Iff (CategoryTheory.Mono S.g) (Eq S.f 0)","decl":"lemma Exact.mono_g_iff (hS : S.Exact) : Mono S.g ↔ S.f = 0 := by\n  constructor\n  · intro\n    rw [← cancel_mono S.g, zero, zero_comp]\n  · exact hS.mono_g\n\n"}
{"name":"CategoryTheory.ShortComplex.Exact.epi_f_iff","module":"Mathlib.Algebra.Homology.ShortComplex.Exact","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_3, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nS : CategoryTheory.ShortComplex C\nhS : S.Exact\n⊢ Iff (CategoryTheory.Epi S.f) (Eq S.g 0)","decl":"lemma Exact.epi_f_iff (hS : S.Exact) : Epi S.f ↔ S.g = 0 := by\n  constructor\n  · intro\n    rw [← cancel_epi S.f, zero, comp_zero]\n  · exact hS.epi_f\n\n"}
{"name":"CategoryTheory.ShortComplex.Exact.isZero_X₂","module":"Mathlib.Algebra.Homology.ShortComplex.Exact","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_3, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nS : CategoryTheory.ShortComplex C\nhS : S.Exact\nhf : Eq S.f 0\nhg : Eq S.g 0\n⊢ CategoryTheory.Limits.IsZero S.X₂","decl":"lemma Exact.isZero_X₂ (hS : S.Exact) (hf : S.f = 0) (hg : S.g = 0) : IsZero S.X₂ := by\n  have := hS.mono_g hf\n  rw [IsZero.iff_id_eq_zero, ← cancel_mono S.g, hg, comp_zero, comp_zero]\n\n"}
{"name":"CategoryTheory.ShortComplex.Exact.isZero_X₂_iff","module":"Mathlib.Algebra.Homology.ShortComplex.Exact","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_3, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nS : CategoryTheory.ShortComplex C\nhS : S.Exact\n⊢ Iff (CategoryTheory.Limits.IsZero S.X₂) (And (Eq S.f 0) (Eq S.g 0))","decl":"lemma Exact.isZero_X₂_iff (hS : S.Exact) : IsZero S.X₂ ↔ S.f = 0 ∧ S.g = 0 := by\n  constructor\n  · intro h\n    exact ⟨h.eq_of_tgt _ _, h.eq_of_src _ _⟩\n  · rintro ⟨hf, hg⟩\n    exact hS.isZero_X₂ hf hg\n\n"}
{"name":"CategoryTheory.ShortComplex.Splitting.mk.injEq","module":"Mathlib.Algebra.Homology.ShortComplex.Exact","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_3, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nS : CategoryTheory.ShortComplex C\nr✝ : Quiver.Hom S.X₂ S.X₁\ns✝ : Quiver.Hom S.X₃ S.X₂\nf_r✝ : autoParam (Eq (CategoryTheory.CategoryStruct.comp S.f r✝) (CategoryTheory.CategoryStruct.id S.X₁)) _auto✝\ns_g✝ : autoParam (Eq (CategoryTheory.CategoryStruct.comp s✝ S.g) (CategoryTheory.CategoryStruct.id S.X₃)) _auto✝\nid✝ : autoParam (Eq (HAdd.hAdd (CategoryTheory.CategoryStruct.comp r✝ S.f) (CategoryTheory.CategoryStruct.comp S.g s✝)) (CategoryTheory.CategoryStruct.id S.X₂)) _auto✝\nr : Quiver.Hom S.X₂ S.X₁\ns : Quiver.Hom S.X₃ S.X₂\nf_r : autoParam (Eq (CategoryTheory.CategoryStruct.comp S.f r) (CategoryTheory.CategoryStruct.id S.X₁)) _auto✝\ns_g : autoParam (Eq (CategoryTheory.CategoryStruct.comp s S.g) (CategoryTheory.CategoryStruct.id S.X₃)) _auto✝\nid : autoParam (Eq (HAdd.hAdd (CategoryTheory.CategoryStruct.comp r S.f) (CategoryTheory.CategoryStruct.comp S.g s)) (CategoryTheory.CategoryStruct.id S.X₂)) _auto✝\n⊢ Eq (Eq { r := r✝, s := s✝, f_r := f_r✝, s_g := s_g✝, id := id✝ } { r := r, s := s, f_r := f_r, s_g := s_g, id := id }) (And (Eq r✝ r) (Eq s✝ s))","decl":"/-- A splitting for a short complex `S` consists of the data of a retraction `r : X₂ ⟶ X₁`\nof `S.f` and section `s : X₃ ⟶ X₂` of `S.g` which satisfy `r ≫ S.f + S.g ≫ s = 𝟙 _` -/\nstructure Splitting (S : ShortComplex C) where\n  /-- a retraction of `S.f` -/\n  r : S.X₂ ⟶ S.X₁\n  /-- a section of `S.g` -/\n  s : S.X₃ ⟶ S.X₂\n  /-- the condition that `r` is a retraction of `S.f` -/\n  f_r : S.f ≫ r = 𝟙 _ := by aesop_cat\n  /-- the condition that `s` is a section of `S.g` -/\n  s_g : s ≫ S.g = 𝟙 _ := by aesop_cat\n  /-- the compatibility between the given section and retraction -/\n  id : r ≫ S.f + S.g ≫ s = 𝟙 _ := by aesop_cat\n\n"}
{"name":"CategoryTheory.ShortComplex.Splitting.s_g","module":"Mathlib.Algebra.Homology.ShortComplex.Exact","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_3, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nS : CategoryTheory.ShortComplex C\nself : S.Splitting\n⊢ Eq (CategoryTheory.CategoryStruct.comp self.s S.g) (CategoryTheory.CategoryStruct.id S.X₃)","decl":"/-- A splitting for a short complex `S` consists of the data of a retraction `r : X₂ ⟶ X₁`\nof `S.f` and section `s : X₃ ⟶ X₂` of `S.g` which satisfy `r ≫ S.f + S.g ≫ s = 𝟙 _` -/\nstructure Splitting (S : ShortComplex C) where\n  /-- a retraction of `S.f` -/\n  r : S.X₂ ⟶ S.X₁\n  /-- a section of `S.g` -/\n  s : S.X₃ ⟶ S.X₂\n  /-- the condition that `r` is a retraction of `S.f` -/\n  f_r : S.f ≫ r = 𝟙 _ := by aesop_cat\n  /-- the condition that `s` is a section of `S.g` -/\n  s_g : s ≫ S.g = 𝟙 _ := by aesop_cat\n  /-- the compatibility between the given section and retraction -/\n  id : r ≫ S.f + S.g ≫ s = 𝟙 _ := by aesop_cat\n\n"}
{"name":"CategoryTheory.ShortComplex.Splitting.f_r","module":"Mathlib.Algebra.Homology.ShortComplex.Exact","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_3, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nS : CategoryTheory.ShortComplex C\nself : S.Splitting\n⊢ Eq (CategoryTheory.CategoryStruct.comp S.f self.r) (CategoryTheory.CategoryStruct.id S.X₁)","decl":"/-- A splitting for a short complex `S` consists of the data of a retraction `r : X₂ ⟶ X₁`\nof `S.f` and section `s : X₃ ⟶ X₂` of `S.g` which satisfy `r ≫ S.f + S.g ≫ s = 𝟙 _` -/\nstructure Splitting (S : ShortComplex C) where\n  /-- a retraction of `S.f` -/\n  r : S.X₂ ⟶ S.X₁\n  /-- a section of `S.g` -/\n  s : S.X₃ ⟶ S.X₂\n  /-- the condition that `r` is a retraction of `S.f` -/\n  f_r : S.f ≫ r = 𝟙 _ := by aesop_cat\n  /-- the condition that `s` is a section of `S.g` -/\n  s_g : s ≫ S.g = 𝟙 _ := by aesop_cat\n  /-- the compatibility between the given section and retraction -/\n  id : r ≫ S.f + S.g ≫ s = 𝟙 _ := by aesop_cat\n\n"}
{"name":"CategoryTheory.ShortComplex.Splitting.mk.sizeOf_spec","module":"Mathlib.Algebra.Homology.ShortComplex.Exact","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\nS : CategoryTheory.ShortComplex C\ninst✝ : SizeOf C\nr : Quiver.Hom S.X₂ S.X₁\ns : Quiver.Hom S.X₃ S.X₂\nf_r : autoParam (Eq (CategoryTheory.CategoryStruct.comp S.f r) (CategoryTheory.CategoryStruct.id S.X₁)) _auto✝\ns_g : autoParam (Eq (CategoryTheory.CategoryStruct.comp s S.g) (CategoryTheory.CategoryStruct.id S.X₃)) _auto✝\nid : autoParam (Eq (HAdd.hAdd (CategoryTheory.CategoryStruct.comp r S.f) (CategoryTheory.CategoryStruct.comp S.g s)) (CategoryTheory.CategoryStruct.id S.X₂)) _auto✝\n⊢ Eq (SizeOf.sizeOf { r := r, s := s, f_r := f_r, s_g := s_g, id := id }) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf r)) (SizeOf.sizeOf s)) (SizeOf.sizeOf f_r)) (SizeOf.sizeOf s_g)) (SizeOf.sizeOf id))","decl":"/-- A splitting for a short complex `S` consists of the data of a retraction `r : X₂ ⟶ X₁`\nof `S.f` and section `s : X₃ ⟶ X₂` of `S.g` which satisfy `r ≫ S.f + S.g ≫ s = 𝟙 _` -/\nstructure Splitting (S : ShortComplex C) where\n  /-- a retraction of `S.f` -/\n  r : S.X₂ ⟶ S.X₁\n  /-- a section of `S.g` -/\n  s : S.X₃ ⟶ S.X₂\n  /-- the condition that `r` is a retraction of `S.f` -/\n  f_r : S.f ≫ r = 𝟙 _ := by aesop_cat\n  /-- the condition that `s` is a section of `S.g` -/\n  s_g : s ≫ S.g = 𝟙 _ := by aesop_cat\n  /-- the compatibility between the given section and retraction -/\n  id : r ≫ S.f + S.g ≫ s = 𝟙 _ := by aesop_cat\n\n"}
{"name":"CategoryTheory.ShortComplex.Splitting.mk.inj","module":"Mathlib.Algebra.Homology.ShortComplex.Exact","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_3, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nS : CategoryTheory.ShortComplex C\nr✝ : Quiver.Hom S.X₂ S.X₁\ns✝ : Quiver.Hom S.X₃ S.X₂\nf_r✝ : autoParam (Eq (CategoryTheory.CategoryStruct.comp S.f r✝) (CategoryTheory.CategoryStruct.id S.X₁)) _auto✝\ns_g✝ : autoParam (Eq (CategoryTheory.CategoryStruct.comp s✝ S.g) (CategoryTheory.CategoryStruct.id S.X₃)) _auto✝\nid✝ : autoParam (Eq (HAdd.hAdd (CategoryTheory.CategoryStruct.comp r✝ S.f) (CategoryTheory.CategoryStruct.comp S.g s✝)) (CategoryTheory.CategoryStruct.id S.X₂)) _auto✝\nr : Quiver.Hom S.X₂ S.X₁\ns : Quiver.Hom S.X₃ S.X₂\nf_r : autoParam (Eq (CategoryTheory.CategoryStruct.comp S.f r) (CategoryTheory.CategoryStruct.id S.X₁)) _auto✝\ns_g : autoParam (Eq (CategoryTheory.CategoryStruct.comp s S.g) (CategoryTheory.CategoryStruct.id S.X₃)) _auto✝\nid : autoParam (Eq (HAdd.hAdd (CategoryTheory.CategoryStruct.comp r S.f) (CategoryTheory.CategoryStruct.comp S.g s)) (CategoryTheory.CategoryStruct.id S.X₂)) _auto✝\nx✝ : Eq { r := r✝, s := s✝, f_r := f_r✝, s_g := s_g✝, id := id✝ } { r := r, s := s, f_r := f_r, s_g := s_g, id := id }\n⊢ And (Eq r✝ r) (Eq s✝ s)","decl":"/-- A splitting for a short complex `S` consists of the data of a retraction `r : X₂ ⟶ X₁`\nof `S.f` and section `s : X₃ ⟶ X₂` of `S.g` which satisfy `r ≫ S.f + S.g ≫ s = 𝟙 _` -/\nstructure Splitting (S : ShortComplex C) where\n  /-- a retraction of `S.f` -/\n  r : S.X₂ ⟶ S.X₁\n  /-- a section of `S.g` -/\n  s : S.X₃ ⟶ S.X₂\n  /-- the condition that `r` is a retraction of `S.f` -/\n  f_r : S.f ≫ r = 𝟙 _ := by aesop_cat\n  /-- the condition that `s` is a section of `S.g` -/\n  s_g : s ≫ S.g = 𝟙 _ := by aesop_cat\n  /-- the compatibility between the given section and retraction -/\n  id : r ≫ S.f + S.g ≫ s = 𝟙 _ := by aesop_cat\n\n"}
{"name":"CategoryTheory.ShortComplex.Splitting.id","module":"Mathlib.Algebra.Homology.ShortComplex.Exact","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_3, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nS : CategoryTheory.ShortComplex C\nself : S.Splitting\n⊢ Eq (HAdd.hAdd (CategoryTheory.CategoryStruct.comp self.r S.f) (CategoryTheory.CategoryStruct.comp S.g self.s)) (CategoryTheory.CategoryStruct.id S.X₂)","decl":"/-- A splitting for a short complex `S` consists of the data of a retraction `r : X₂ ⟶ X₁`\nof `S.f` and section `s : X₃ ⟶ X₂` of `S.g` which satisfy `r ≫ S.f + S.g ≫ s = 𝟙 _` -/\nstructure Splitting (S : ShortComplex C) where\n  /-- a retraction of `S.f` -/\n  r : S.X₂ ⟶ S.X₁\n  /-- a section of `S.g` -/\n  s : S.X₃ ⟶ S.X₂\n  /-- the condition that `r` is a retraction of `S.f` -/\n  f_r : S.f ≫ r = 𝟙 _ := by aesop_cat\n  /-- the condition that `s` is a section of `S.g` -/\n  s_g : s ≫ S.g = 𝟙 _ := by aesop_cat\n  /-- the compatibility between the given section and retraction -/\n  id : r ≫ S.f + S.g ≫ s = 𝟙 _ := by aesop_cat\n\n"}
{"name":"CategoryTheory.ShortComplex.Splitting.s_g_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.Exact","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_3, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nS : CategoryTheory.ShortComplex C\nself : S.Splitting\nZ : C\nh : Quiver.Hom S.X₃ Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp self.s (CategoryTheory.CategoryStruct.comp S.g h)) h","decl":"attribute [reassoc (attr := simp)] f_r s_g\n\n"}
{"name":"CategoryTheory.ShortComplex.Splitting.f_r_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.Exact","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_3, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nS : CategoryTheory.ShortComplex C\nself : S.Splitting\nZ : C\nh : Quiver.Hom S.X₁ Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp S.f (CategoryTheory.CategoryStruct.comp self.r h)) h","decl":"attribute [reassoc (attr := simp)] f_r s_g\n\n"}
{"name":"CategoryTheory.ShortComplex.Splitting.r_f_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.Exact","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_3, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nS : CategoryTheory.ShortComplex C\ns : S.Splitting\nZ : C\nh : Quiver.Hom S.X₂ Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp s.r (CategoryTheory.CategoryStruct.comp S.f h)) (CategoryTheory.CategoryStruct.comp (HSub.hSub (CategoryTheory.CategoryStruct.id S.X₂) (CategoryTheory.CategoryStruct.comp S.g s.s)) h)","decl":"@[reassoc]\nlemma r_f (s : S.Splitting) : s.r ≫ S.f = 𝟙 _ - S.g ≫ s.s := by rw [← s.id, add_sub_cancel_right]\n\n"}
{"name":"CategoryTheory.ShortComplex.Splitting.r_f","module":"Mathlib.Algebra.Homology.ShortComplex.Exact","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_3, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nS : CategoryTheory.ShortComplex C\ns : S.Splitting\n⊢ Eq (CategoryTheory.CategoryStruct.comp s.r S.f) (HSub.hSub (CategoryTheory.CategoryStruct.id S.X₂) (CategoryTheory.CategoryStruct.comp S.g s.s))","decl":"@[reassoc]\nlemma r_f (s : S.Splitting) : s.r ≫ S.f = 𝟙 _ - S.g ≫ s.s := by rw [← s.id, add_sub_cancel_right]\n\n"}
{"name":"CategoryTheory.ShortComplex.Splitting.g_s","module":"Mathlib.Algebra.Homology.ShortComplex.Exact","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_3, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nS : CategoryTheory.ShortComplex C\ns : S.Splitting\n⊢ Eq (CategoryTheory.CategoryStruct.comp S.g s.s) (HSub.hSub (CategoryTheory.CategoryStruct.id S.X₂) (CategoryTheory.CategoryStruct.comp s.r S.f))","decl":"@[reassoc]\nlemma g_s (s : S.Splitting) : S.g ≫ s.s = 𝟙 _ - s.r ≫ S.f := by rw [← s.id, add_sub_cancel_left]\n\n"}
{"name":"CategoryTheory.ShortComplex.Splitting.g_s_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.Exact","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_3, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nS : CategoryTheory.ShortComplex C\ns : S.Splitting\nZ : C\nh : Quiver.Hom S.X₂ Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp S.g (CategoryTheory.CategoryStruct.comp s.s h)) (CategoryTheory.CategoryStruct.comp (HSub.hSub (CategoryTheory.CategoryStruct.id S.X₂) (CategoryTheory.CategoryStruct.comp s.r S.f)) h)","decl":"@[reassoc]\nlemma g_s (s : S.Splitting) : S.g ≫ s.s = 𝟙 _ - s.r ≫ S.f := by rw [← s.id, add_sub_cancel_left]\n\n"}
{"name":"CategoryTheory.ShortComplex.Splitting.splitMono_f_retraction","module":"Mathlib.Algebra.Homology.ShortComplex.Exact","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_3, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nS : CategoryTheory.ShortComplex C\ns : S.Splitting\n⊢ Eq s.splitMono_f.retraction s.r","decl":"/-- Given a splitting of a short complex `S`, this shows that `S.f` is a split monomorphism. -/\n@[simps] def splitMono_f (s : S.Splitting) : SplitMono S.f := ⟨s.r, s.f_r⟩\n\n"}
{"name":"CategoryTheory.ShortComplex.Splitting.isSplitMono_f","module":"Mathlib.Algebra.Homology.ShortComplex.Exact","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_3, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nS : CategoryTheory.ShortComplex C\ns : S.Splitting\n⊢ CategoryTheory.IsSplitMono S.f","decl":"lemma isSplitMono_f (s : S.Splitting) : IsSplitMono S.f := ⟨⟨s.splitMono_f⟩⟩\n\n"}
{"name":"CategoryTheory.ShortComplex.Splitting.mono_f","module":"Mathlib.Algebra.Homology.ShortComplex.Exact","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_3, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nS : CategoryTheory.ShortComplex C\ns : S.Splitting\n⊢ CategoryTheory.Mono S.f","decl":"lemma mono_f (s : S.Splitting) : Mono S.f := by\n  have := s.isSplitMono_f\n  infer_instance\n\n"}
{"name":"CategoryTheory.ShortComplex.Splitting.splitEpi_g_section_","module":"Mathlib.Algebra.Homology.ShortComplex.Exact","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_3, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nS : CategoryTheory.ShortComplex C\ns : S.Splitting\n⊢ Eq s.splitEpi_g.section_ s.s","decl":"/-- Given a splitting of a short complex `S`, this shows that `S.g` is a split epimorphism. -/\n@[simps] def splitEpi_g (s : S.Splitting) : SplitEpi S.g := ⟨s.s, s.s_g⟩\n\n"}
{"name":"CategoryTheory.ShortComplex.Splitting.isSplitEpi_g","module":"Mathlib.Algebra.Homology.ShortComplex.Exact","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_3, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nS : CategoryTheory.ShortComplex C\ns : S.Splitting\n⊢ CategoryTheory.IsSplitEpi S.g","decl":"lemma isSplitEpi_g (s : S.Splitting) : IsSplitEpi S.g := ⟨⟨s.splitEpi_g⟩⟩\n\n"}
{"name":"CategoryTheory.ShortComplex.Splitting.epi_g","module":"Mathlib.Algebra.Homology.ShortComplex.Exact","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_3, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nS : CategoryTheory.ShortComplex C\ns : S.Splitting\n⊢ CategoryTheory.Epi S.g","decl":"lemma epi_g (s : S.Splitting) : Epi S.g := by\n  have := s.isSplitEpi_g\n  infer_instance\n\n"}
{"name":"CategoryTheory.ShortComplex.Splitting.s_r","module":"Mathlib.Algebra.Homology.ShortComplex.Exact","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_3, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nS : CategoryTheory.ShortComplex C\ns : S.Splitting\n⊢ Eq (CategoryTheory.CategoryStruct.comp s.s s.r) 0","decl":"@[reassoc (attr := simp)]\nlemma s_r (s : S.Splitting) : s.s ≫ s.r = 0 := by\n  have := s.epi_g\n  simp only [← cancel_epi S.g, comp_zero, g_s_assoc, sub_comp, id_comp,\n    assoc, f_r, comp_id, sub_self]\n\n"}
{"name":"CategoryTheory.ShortComplex.Splitting.s_r_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.Exact","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_3, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nS : CategoryTheory.ShortComplex C\ns : S.Splitting\nZ : C\nh : Quiver.Hom S.X₁ Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp s.s (CategoryTheory.CategoryStruct.comp s.r h)) (CategoryTheory.CategoryStruct.comp 0 h)","decl":"@[reassoc (attr := simp)]\nlemma s_r (s : S.Splitting) : s.s ≫ s.r = 0 := by\n  have := s.epi_g\n  simp only [← cancel_epi S.g, comp_zero, g_s_assoc, sub_comp, id_comp,\n    assoc, f_r, comp_id, sub_self]\n\n"}
{"name":"CategoryTheory.ShortComplex.Splitting.ext_r","module":"Mathlib.Algebra.Homology.ShortComplex.Exact","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_3, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nS : CategoryTheory.ShortComplex C\ns s' : S.Splitting\nh : Eq s.r s'.r\n⊢ Eq s s'","decl":"lemma ext_r (s s' : S.Splitting) (h : s.r = s'.r) : s = s' := by\n  have := s.epi_g\n  have eq := s.id\n  rw [← s'.id, h, add_right_inj, cancel_epi S.g] at eq\n  cases s\n  cases s'\n  obtain rfl := eq\n  obtain rfl := h\n  rfl\n\n"}
{"name":"CategoryTheory.ShortComplex.Splitting.ext_s","module":"Mathlib.Algebra.Homology.ShortComplex.Exact","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_3, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nS : CategoryTheory.ShortComplex C\ns s' : S.Splitting\nh : Eq s.s s'.s\n⊢ Eq s s'","decl":"lemma ext_s (s s' : S.Splitting) (h : s.s = s'.s) : s = s' := by\n  have := s.mono_f\n  have eq := s.id\n  rw [← s'.id, h, add_left_inj, cancel_mono S.f] at eq\n  cases s\n  cases s'\n  obtain rfl := eq\n  obtain rfl := h\n  rfl\n\n"}
{"name":"CategoryTheory.ShortComplex.Splitting.leftHomologyData_H","module":"Mathlib.Algebra.Homology.ShortComplex.Exact","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\nS : CategoryTheory.ShortComplex C\ninst✝ : CategoryTheory.Limits.HasZeroObject C\ns : S.Splitting\n⊢ Eq s.leftHomologyData.H 0","decl":"/-- The left homology data on a short complex equipped with a splitting. -/\n@[simps]\nnoncomputable def leftHomologyData [HasZeroObject C] (s : S.Splitting) :\n    LeftHomologyData S := by\n  have hi := KernelFork.IsLimit.ofι S.f S.zero\n    (fun x _ => x ≫ s.r)\n    (fun x hx => by simp only [assoc, s.r_f, comp_sub, comp_id,\n      sub_eq_self, reassoc_of% hx, zero_comp])\n    (fun x _ b hb => by simp only [← hb, assoc, f_r, comp_id])\n  let f' := hi.lift (KernelFork.ofι S.f S.zero)\n  have hf' : f' = 𝟙 _ := by\n    apply Fork.IsLimit.hom_ext hi\n    dsimp\n    erw [Fork.IsLimit.lift_ι hi]\n    simp only [Fork.ι_ofι, id_comp]\n  have wπ : f' ≫ (0 : S.X₁ ⟶ 0) = 0 := comp_zero\n  have hπ : IsColimit (CokernelCofork.ofπ 0 wπ) := CokernelCofork.IsColimit.ofEpiOfIsZero _\n      (by rw [hf']; infer_instance) (isZero_zero _)\n  exact\n    { K := S.X₁\n      H := 0\n      i := S.f\n      wi := S.zero\n      hi := hi\n      π := 0\n      wπ := wπ\n      hπ := hπ }\n\n"}
{"name":"CategoryTheory.ShortComplex.Splitting.leftHomologyData_K","module":"Mathlib.Algebra.Homology.ShortComplex.Exact","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\nS : CategoryTheory.ShortComplex C\ninst✝ : CategoryTheory.Limits.HasZeroObject C\ns : S.Splitting\n⊢ Eq s.leftHomologyData.K S.X₁","decl":"/-- The left homology data on a short complex equipped with a splitting. -/\n@[simps]\nnoncomputable def leftHomologyData [HasZeroObject C] (s : S.Splitting) :\n    LeftHomologyData S := by\n  have hi := KernelFork.IsLimit.ofι S.f S.zero\n    (fun x _ => x ≫ s.r)\n    (fun x hx => by simp only [assoc, s.r_f, comp_sub, comp_id,\n      sub_eq_self, reassoc_of% hx, zero_comp])\n    (fun x _ b hb => by simp only [← hb, assoc, f_r, comp_id])\n  let f' := hi.lift (KernelFork.ofι S.f S.zero)\n  have hf' : f' = 𝟙 _ := by\n    apply Fork.IsLimit.hom_ext hi\n    dsimp\n    erw [Fork.IsLimit.lift_ι hi]\n    simp only [Fork.ι_ofι, id_comp]\n  have wπ : f' ≫ (0 : S.X₁ ⟶ 0) = 0 := comp_zero\n  have hπ : IsColimit (CokernelCofork.ofπ 0 wπ) := CokernelCofork.IsColimit.ofEpiOfIsZero _\n      (by rw [hf']; infer_instance) (isZero_zero _)\n  exact\n    { K := S.X₁\n      H := 0\n      i := S.f\n      wi := S.zero\n      hi := hi\n      π := 0\n      wπ := wπ\n      hπ := hπ }\n\n"}
{"name":"CategoryTheory.ShortComplex.Splitting.leftHomologyData_i","module":"Mathlib.Algebra.Homology.ShortComplex.Exact","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\nS : CategoryTheory.ShortComplex C\ninst✝ : CategoryTheory.Limits.HasZeroObject C\ns : S.Splitting\n⊢ Eq s.leftHomologyData.i S.f","decl":"/-- The left homology data on a short complex equipped with a splitting. -/\n@[simps]\nnoncomputable def leftHomologyData [HasZeroObject C] (s : S.Splitting) :\n    LeftHomologyData S := by\n  have hi := KernelFork.IsLimit.ofι S.f S.zero\n    (fun x _ => x ≫ s.r)\n    (fun x hx => by simp only [assoc, s.r_f, comp_sub, comp_id,\n      sub_eq_self, reassoc_of% hx, zero_comp])\n    (fun x _ b hb => by simp only [← hb, assoc, f_r, comp_id])\n  let f' := hi.lift (KernelFork.ofι S.f S.zero)\n  have hf' : f' = 𝟙 _ := by\n    apply Fork.IsLimit.hom_ext hi\n    dsimp\n    erw [Fork.IsLimit.lift_ι hi]\n    simp only [Fork.ι_ofι, id_comp]\n  have wπ : f' ≫ (0 : S.X₁ ⟶ 0) = 0 := comp_zero\n  have hπ : IsColimit (CokernelCofork.ofπ 0 wπ) := CokernelCofork.IsColimit.ofEpiOfIsZero _\n      (by rw [hf']; infer_instance) (isZero_zero _)\n  exact\n    { K := S.X₁\n      H := 0\n      i := S.f\n      wi := S.zero\n      hi := hi\n      π := 0\n      wπ := wπ\n      hπ := hπ }\n\n"}
{"name":"CategoryTheory.ShortComplex.Splitting.leftHomologyData_π","module":"Mathlib.Algebra.Homology.ShortComplex.Exact","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\nS : CategoryTheory.ShortComplex C\ninst✝ : CategoryTheory.Limits.HasZeroObject C\ns : S.Splitting\n⊢ Eq s.leftHomologyData.π 0","decl":"/-- The left homology data on a short complex equipped with a splitting. -/\n@[simps]\nnoncomputable def leftHomologyData [HasZeroObject C] (s : S.Splitting) :\n    LeftHomologyData S := by\n  have hi := KernelFork.IsLimit.ofι S.f S.zero\n    (fun x _ => x ≫ s.r)\n    (fun x hx => by simp only [assoc, s.r_f, comp_sub, comp_id,\n      sub_eq_self, reassoc_of% hx, zero_comp])\n    (fun x _ b hb => by simp only [← hb, assoc, f_r, comp_id])\n  let f' := hi.lift (KernelFork.ofι S.f S.zero)\n  have hf' : f' = 𝟙 _ := by\n    apply Fork.IsLimit.hom_ext hi\n    dsimp\n    erw [Fork.IsLimit.lift_ι hi]\n    simp only [Fork.ι_ofι, id_comp]\n  have wπ : f' ≫ (0 : S.X₁ ⟶ 0) = 0 := comp_zero\n  have hπ : IsColimit (CokernelCofork.ofπ 0 wπ) := CokernelCofork.IsColimit.ofEpiOfIsZero _\n      (by rw [hf']; infer_instance) (isZero_zero _)\n  exact\n    { K := S.X₁\n      H := 0\n      i := S.f\n      wi := S.zero\n      hi := hi\n      π := 0\n      wπ := wπ\n      hπ := hπ }\n\n"}
{"name":"CategoryTheory.ShortComplex.Splitting.rightHomologyData_Q","module":"Mathlib.Algebra.Homology.ShortComplex.Exact","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\nS : CategoryTheory.ShortComplex C\ninst✝ : CategoryTheory.Limits.HasZeroObject C\ns : S.Splitting\n⊢ Eq s.rightHomologyData.Q S.X₃","decl":"/-- The right homology data on a short complex equipped with a splitting. -/\n@[simps]\nnoncomputable def rightHomologyData [HasZeroObject C] (s : S.Splitting) :\n    RightHomologyData S := by\n  have hp := CokernelCofork.IsColimit.ofπ S.g S.zero\n    (fun x _ => s.s ≫ x)\n    (fun x hx => by simp only [s.g_s_assoc, sub_comp, id_comp, sub_eq_self, assoc, hx, comp_zero])\n    (fun x _ b hb => by simp only [← hb, s.s_g_assoc])\n  let g' := hp.desc (CokernelCofork.ofπ S.g S.zero)\n  have hg' : g' = 𝟙 _ := by\n    apply Cofork.IsColimit.hom_ext hp\n    dsimp\n    erw [Cofork.IsColimit.π_desc hp]\n    simp only [Cofork.π_ofπ, comp_id]\n  have wι : (0 : 0 ⟶ S.X₃) ≫ g' = 0 := zero_comp\n  have hι : IsLimit (KernelFork.ofι 0 wι) := KernelFork.IsLimit.ofMonoOfIsZero _\n      (by rw [hg']; dsimp; infer_instance) (isZero_zero _)\n  exact\n    { Q := S.X₃\n      H := 0\n      p := S.g\n      wp := S.zero\n      hp := hp\n      ι := 0\n      wι := wι\n      hι := hι }\n\n"}
{"name":"CategoryTheory.ShortComplex.Splitting.rightHomologyData_p","module":"Mathlib.Algebra.Homology.ShortComplex.Exact","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\nS : CategoryTheory.ShortComplex C\ninst✝ : CategoryTheory.Limits.HasZeroObject C\ns : S.Splitting\n⊢ Eq s.rightHomologyData.p S.g","decl":"/-- The right homology data on a short complex equipped with a splitting. -/\n@[simps]\nnoncomputable def rightHomologyData [HasZeroObject C] (s : S.Splitting) :\n    RightHomologyData S := by\n  have hp := CokernelCofork.IsColimit.ofπ S.g S.zero\n    (fun x _ => s.s ≫ x)\n    (fun x hx => by simp only [s.g_s_assoc, sub_comp, id_comp, sub_eq_self, assoc, hx, comp_zero])\n    (fun x _ b hb => by simp only [← hb, s.s_g_assoc])\n  let g' := hp.desc (CokernelCofork.ofπ S.g S.zero)\n  have hg' : g' = 𝟙 _ := by\n    apply Cofork.IsColimit.hom_ext hp\n    dsimp\n    erw [Cofork.IsColimit.π_desc hp]\n    simp only [Cofork.π_ofπ, comp_id]\n  have wι : (0 : 0 ⟶ S.X₃) ≫ g' = 0 := zero_comp\n  have hι : IsLimit (KernelFork.ofι 0 wι) := KernelFork.IsLimit.ofMonoOfIsZero _\n      (by rw [hg']; dsimp; infer_instance) (isZero_zero _)\n  exact\n    { Q := S.X₃\n      H := 0\n      p := S.g\n      wp := S.zero\n      hp := hp\n      ι := 0\n      wι := wι\n      hι := hι }\n\n"}
{"name":"CategoryTheory.ShortComplex.Splitting.rightHomologyData_H","module":"Mathlib.Algebra.Homology.ShortComplex.Exact","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\nS : CategoryTheory.ShortComplex C\ninst✝ : CategoryTheory.Limits.HasZeroObject C\ns : S.Splitting\n⊢ Eq s.rightHomologyData.H 0","decl":"/-- The right homology data on a short complex equipped with a splitting. -/\n@[simps]\nnoncomputable def rightHomologyData [HasZeroObject C] (s : S.Splitting) :\n    RightHomologyData S := by\n  have hp := CokernelCofork.IsColimit.ofπ S.g S.zero\n    (fun x _ => s.s ≫ x)\n    (fun x hx => by simp only [s.g_s_assoc, sub_comp, id_comp, sub_eq_self, assoc, hx, comp_zero])\n    (fun x _ b hb => by simp only [← hb, s.s_g_assoc])\n  let g' := hp.desc (CokernelCofork.ofπ S.g S.zero)\n  have hg' : g' = 𝟙 _ := by\n    apply Cofork.IsColimit.hom_ext hp\n    dsimp\n    erw [Cofork.IsColimit.π_desc hp]\n    simp only [Cofork.π_ofπ, comp_id]\n  have wι : (0 : 0 ⟶ S.X₃) ≫ g' = 0 := zero_comp\n  have hι : IsLimit (KernelFork.ofι 0 wι) := KernelFork.IsLimit.ofMonoOfIsZero _\n      (by rw [hg']; dsimp; infer_instance) (isZero_zero _)\n  exact\n    { Q := S.X₃\n      H := 0\n      p := S.g\n      wp := S.zero\n      hp := hp\n      ι := 0\n      wι := wι\n      hι := hι }\n\n"}
{"name":"CategoryTheory.ShortComplex.Splitting.rightHomologyData_ι","module":"Mathlib.Algebra.Homology.ShortComplex.Exact","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\nS : CategoryTheory.ShortComplex C\ninst✝ : CategoryTheory.Limits.HasZeroObject C\ns : S.Splitting\n⊢ Eq s.rightHomologyData.ι 0","decl":"/-- The right homology data on a short complex equipped with a splitting. -/\n@[simps]\nnoncomputable def rightHomologyData [HasZeroObject C] (s : S.Splitting) :\n    RightHomologyData S := by\n  have hp := CokernelCofork.IsColimit.ofπ S.g S.zero\n    (fun x _ => s.s ≫ x)\n    (fun x hx => by simp only [s.g_s_assoc, sub_comp, id_comp, sub_eq_self, assoc, hx, comp_zero])\n    (fun x _ b hb => by simp only [← hb, s.s_g_assoc])\n  let g' := hp.desc (CokernelCofork.ofπ S.g S.zero)\n  have hg' : g' = 𝟙 _ := by\n    apply Cofork.IsColimit.hom_ext hp\n    dsimp\n    erw [Cofork.IsColimit.π_desc hp]\n    simp only [Cofork.π_ofπ, comp_id]\n  have wι : (0 : 0 ⟶ S.X₃) ≫ g' = 0 := zero_comp\n  have hι : IsLimit (KernelFork.ofι 0 wι) := KernelFork.IsLimit.ofMonoOfIsZero _\n      (by rw [hg']; dsimp; infer_instance) (isZero_zero _)\n  exact\n    { Q := S.X₃\n      H := 0\n      p := S.g\n      wp := S.zero\n      hp := hp\n      ι := 0\n      wι := wι\n      hι := hι }\n\n"}
{"name":"CategoryTheory.ShortComplex.Splitting.homologyData_iso","module":"Mathlib.Algebra.Homology.ShortComplex.Exact","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\nS : CategoryTheory.ShortComplex C\ninst✝ : CategoryTheory.Limits.HasZeroObject C\ns : S.Splitting\n⊢ Eq s.homologyData.iso (CategoryTheory.Iso.refl 0)","decl":"/-- The homology data on a short complex equipped with a splitting. -/\n@[simps]\nnoncomputable def homologyData [HasZeroObject C] (s : S.Splitting) : S.HomologyData where\n  left := s.leftHomologyData\n  right := s.rightHomologyData\n  iso := Iso.refl 0\n\n"}
{"name":"CategoryTheory.ShortComplex.Splitting.homologyData_right","module":"Mathlib.Algebra.Homology.ShortComplex.Exact","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\nS : CategoryTheory.ShortComplex C\ninst✝ : CategoryTheory.Limits.HasZeroObject C\ns : S.Splitting\n⊢ Eq s.homologyData.right s.rightHomologyData","decl":"/-- The homology data on a short complex equipped with a splitting. -/\n@[simps]\nnoncomputable def homologyData [HasZeroObject C] (s : S.Splitting) : S.HomologyData where\n  left := s.leftHomologyData\n  right := s.rightHomologyData\n  iso := Iso.refl 0\n\n"}
{"name":"CategoryTheory.ShortComplex.Splitting.homologyData_left","module":"Mathlib.Algebra.Homology.ShortComplex.Exact","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\nS : CategoryTheory.ShortComplex C\ninst✝ : CategoryTheory.Limits.HasZeroObject C\ns : S.Splitting\n⊢ Eq s.homologyData.left s.leftHomologyData","decl":"/-- The homology data on a short complex equipped with a splitting. -/\n@[simps]\nnoncomputable def homologyData [HasZeroObject C] (s : S.Splitting) : S.HomologyData where\n  left := s.leftHomologyData\n  right := s.rightHomologyData\n  iso := Iso.refl 0\n\n"}
{"name":"CategoryTheory.ShortComplex.Splitting.exact","module":"Mathlib.Algebra.Homology.ShortComplex.Exact","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\nS : CategoryTheory.ShortComplex C\ninst✝ : CategoryTheory.Limits.HasZeroObject C\ns : S.Splitting\n⊢ S.Exact","decl":"/-- A short complex equipped with a splitting is exact. -/\nlemma exact [HasZeroObject C] (s : S.Splitting) : S.Exact :=\n  ⟨s.homologyData, isZero_zero _⟩\n\n"}
{"name":"CategoryTheory.ShortComplex.Splitting.map_s","module":"Mathlib.Algebra.Homology.ShortComplex.Exact","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁴ : CategoryTheory.Category.{u_3, u_1} C\ninst✝³ : CategoryTheory.Category.{u_4, u_2} D\ninst✝² : CategoryTheory.Preadditive C\ninst✝¹ : CategoryTheory.Preadditive D\nS : CategoryTheory.ShortComplex C\ns : S.Splitting\nF : CategoryTheory.Functor C D\ninst✝ : F.Additive\n⊢ Eq (s.map F).s (F.map s.s)","decl":"/-- If a short complex `S` has a splitting and `F` is an additive functor, then\n`S.map F` also has a splitting. -/\n@[simps]\ndef map (s : S.Splitting) (F : C ⥤ D) [F.Additive] : (S.map F).Splitting where\n  r := F.map s.r\n  s := F.map s.s\n  f_r := by\n    dsimp [ShortComplex.map]\n    rw [← F.map_comp, f_r, F.map_id]\n  s_g := by\n    dsimp [ShortComplex.map]\n    simp only [← F.map_comp, s_g, F.map_id]\n  id := by\n    dsimp [ShortComplex.map]\n    simp only [← F.map_id, ← s.id, Functor.map_comp, Functor.map_add]\n\n"}
{"name":"CategoryTheory.ShortComplex.Splitting.map_r","module":"Mathlib.Algebra.Homology.ShortComplex.Exact","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁴ : CategoryTheory.Category.{u_3, u_1} C\ninst✝³ : CategoryTheory.Category.{u_4, u_2} D\ninst✝² : CategoryTheory.Preadditive C\ninst✝¹ : CategoryTheory.Preadditive D\nS : CategoryTheory.ShortComplex C\ns : S.Splitting\nF : CategoryTheory.Functor C D\ninst✝ : F.Additive\n⊢ Eq (s.map F).r (F.map s.r)","decl":"/-- If a short complex `S` has a splitting and `F` is an additive functor, then\n`S.map F` also has a splitting. -/\n@[simps]\ndef map (s : S.Splitting) (F : C ⥤ D) [F.Additive] : (S.map F).Splitting where\n  r := F.map s.r\n  s := F.map s.s\n  f_r := by\n    dsimp [ShortComplex.map]\n    rw [← F.map_comp, f_r, F.map_id]\n  s_g := by\n    dsimp [ShortComplex.map]\n    simp only [← F.map_comp, s_g, F.map_id]\n  id := by\n    dsimp [ShortComplex.map]\n    simp only [← F.map_id, ← s.id, Functor.map_comp, Functor.map_add]\n\n"}
{"name":"CategoryTheory.ShortComplex.Splitting.ofIso_r","module":"Mathlib.Algebra.Homology.ShortComplex.Exact","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_3, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nS₁ S₂ : CategoryTheory.ShortComplex C\ns : S₁.Splitting\ne : CategoryTheory.Iso S₁ S₂\n⊢ Eq (s.ofIso e).r (CategoryTheory.CategoryStruct.comp e.inv.τ₂ (CategoryTheory.CategoryStruct.comp s.r e.hom.τ₁))","decl":"/-- A splitting on a short complex induces splittings on isomorphic short complexes. -/\n@[simps]\ndef ofIso {S₁ S₂ : ShortComplex C} (s : S₁.Splitting) (e : S₁ ≅ S₂) : S₂.Splitting where\n  r := e.inv.τ₂ ≫ s.r ≫ e.hom.τ₁\n  s := e.inv.τ₃ ≫ s.s ≫ e.hom.τ₂\n  f_r := by rw [← e.inv.comm₁₂_assoc, s.f_r_assoc, ← comp_τ₁, e.inv_hom_id, id_τ₁]\n  s_g := by rw [assoc, assoc, e.hom.comm₂₃, s.s_g_assoc, ← comp_τ₃, e.inv_hom_id, id_τ₃]\n  id := by\n    have eq := e.inv.τ₂ ≫= s.id =≫ e.hom.τ₂\n    rw [id_comp, ← comp_τ₂, e.inv_hom_id, id_τ₂] at eq\n    rw [← eq, assoc, assoc, add_comp, assoc, assoc, comp_add,\n      e.hom.comm₁₂, e.inv.comm₂₃_assoc]\n\n"}
{"name":"CategoryTheory.ShortComplex.Splitting.ofIso_s","module":"Mathlib.Algebra.Homology.ShortComplex.Exact","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_3, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nS₁ S₂ : CategoryTheory.ShortComplex C\ns : S₁.Splitting\ne : CategoryTheory.Iso S₁ S₂\n⊢ Eq (s.ofIso e).s (CategoryTheory.CategoryStruct.comp e.inv.τ₃ (CategoryTheory.CategoryStruct.comp s.s e.hom.τ₂))","decl":"/-- A splitting on a short complex induces splittings on isomorphic short complexes. -/\n@[simps]\ndef ofIso {S₁ S₂ : ShortComplex C} (s : S₁.Splitting) (e : S₁ ≅ S₂) : S₂.Splitting where\n  r := e.inv.τ₂ ≫ s.r ≫ e.hom.τ₁\n  s := e.inv.τ₃ ≫ s.s ≫ e.hom.τ₂\n  f_r := by rw [← e.inv.comm₁₂_assoc, s.f_r_assoc, ← comp_τ₁, e.inv_hom_id, id_τ₁]\n  s_g := by rw [assoc, assoc, e.hom.comm₂₃, s.s_g_assoc, ← comp_τ₃, e.inv_hom_id, id_τ₃]\n  id := by\n    have eq := e.inv.τ₂ ≫= s.id =≫ e.hom.τ₂\n    rw [id_comp, ← comp_τ₂, e.inv_hom_id, id_τ₂] at eq\n    rw [← eq, assoc, assoc, add_comp, assoc, assoc, comp_add,\n      e.hom.comm₁₂, e.inv.comm₂₃_assoc]\n\n"}
{"name":"CategoryTheory.ShortComplex.Splitting.op_r","module":"Mathlib.Algebra.Homology.ShortComplex.Exact","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_3, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nS : CategoryTheory.ShortComplex C\nh : S.Splitting\n⊢ Eq h.op.r h.s.op","decl":"/-- The splitting of the short complex `S.op` deduced from a splitting of `S`. -/\n@[simps]\ndef op (h : Splitting S) : Splitting S.op where\n  r := h.s.op\n  s := h.r.op\n  f_r := Quiver.Hom.unop_inj (by simp)\n  s_g := Quiver.Hom.unop_inj (by simp)\n  id := Quiver.Hom.unop_inj (by\n    simp only [op_X₂, Opposite.unop_op, op_X₁, op_f, op_X₃, op_g, unop_add, unop_comp,\n      Quiver.Hom.unop_op, unop_id, ← h.id]\n    abel)\n\n"}
{"name":"CategoryTheory.ShortComplex.Splitting.op_s","module":"Mathlib.Algebra.Homology.ShortComplex.Exact","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_3, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nS : CategoryTheory.ShortComplex C\nh : S.Splitting\n⊢ Eq h.op.s h.r.op","decl":"/-- The splitting of the short complex `S.op` deduced from a splitting of `S`. -/\n@[simps]\ndef op (h : Splitting S) : Splitting S.op where\n  r := h.s.op\n  s := h.r.op\n  f_r := Quiver.Hom.unop_inj (by simp)\n  s_g := Quiver.Hom.unop_inj (by simp)\n  id := Quiver.Hom.unop_inj (by\n    simp only [op_X₂, Opposite.unop_op, op_X₁, op_f, op_X₃, op_g, unop_add, unop_comp,\n      Quiver.Hom.unop_op, unop_id, ← h.id]\n    abel)\n\n"}
{"name":"CategoryTheory.ShortComplex.Splitting.unop_r","module":"Mathlib.Algebra.Homology.ShortComplex.Exact","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_3, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nS : CategoryTheory.ShortComplex (Opposite C)\nh : S.Splitting\n⊢ Eq h.unop.r h.s.unop","decl":"/-- The splitting of the short complex `S.unop` deduced from a splitting of `S`. -/\n@[simps]\ndef unop {S : ShortComplex Cᵒᵖ} (h : Splitting S) : Splitting S.unop where\n  r := h.s.unop\n  s := h.r.unop\n  f_r := Quiver.Hom.op_inj (by simp)\n  s_g := Quiver.Hom.op_inj (by simp)\n  id := Quiver.Hom.op_inj (by\n    simp only [unop_X₂, Opposite.op_unop, unop_X₁, unop_f, unop_X₃, unop_g, op_add,\n      op_comp, Quiver.Hom.op_unop, op_id, ← h.id]\n    abel)\n\n"}
{"name":"CategoryTheory.ShortComplex.Splitting.unop_s","module":"Mathlib.Algebra.Homology.ShortComplex.Exact","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_3, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nS : CategoryTheory.ShortComplex (Opposite C)\nh : S.Splitting\n⊢ Eq h.unop.s h.r.unop","decl":"/-- The splitting of the short complex `S.unop` deduced from a splitting of `S`. -/\n@[simps]\ndef unop {S : ShortComplex Cᵒᵖ} (h : Splitting S) : Splitting S.unop where\n  r := h.s.unop\n  s := h.r.unop\n  f_r := Quiver.Hom.op_inj (by simp)\n  s_g := Quiver.Hom.op_inj (by simp)\n  id := Quiver.Hom.op_inj (by\n    simp only [unop_X₂, Opposite.op_unop, unop_X₁, unop_f, unop_X₃, unop_g, op_add,\n      op_comp, Quiver.Hom.op_unop, op_id, ← h.id]\n    abel)\n\n"}
{"name":"CategoryTheory.ShortComplex.Splitting.isoBinaryBiproduct_hom","module":"Mathlib.Algebra.Homology.ShortComplex.Exact","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\nS : CategoryTheory.ShortComplex C\nh : S.Splitting\ninst✝ : CategoryTheory.Limits.HasBinaryBiproduct S.X₁ S.X₃\n⊢ Eq h.isoBinaryBiproduct.hom (CategoryTheory.Limits.biprod.lift h.r S.g)","decl":"/-- The isomorphism `S.X₂ ≅ S.X₁ ⊞ S.X₃` induced by a splitting of the short complex `S`. -/\n@[simps]\nnoncomputable def isoBinaryBiproduct (h : Splitting S) [HasBinaryBiproduct S.X₁ S.X₃] :\n    S.X₂ ≅ S.X₁ ⊞ S.X₃ where\n  hom := biprod.lift h.r S.g\n  inv := biprod.desc S.f h.s\n  hom_inv_id := by simp [h.id]\n\n"}
{"name":"CategoryTheory.ShortComplex.Splitting.isoBinaryBiproduct_inv","module":"Mathlib.Algebra.Homology.ShortComplex.Exact","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\nS : CategoryTheory.ShortComplex C\nh : S.Splitting\ninst✝ : CategoryTheory.Limits.HasBinaryBiproduct S.X₁ S.X₃\n⊢ Eq h.isoBinaryBiproduct.inv (CategoryTheory.Limits.biprod.desc S.f h.s)","decl":"/-- The isomorphism `S.X₂ ≅ S.X₁ ⊞ S.X₃` induced by a splitting of the short complex `S`. -/\n@[simps]\nnoncomputable def isoBinaryBiproduct (h : Splitting S) [HasBinaryBiproduct S.X₁ S.X₃] :\n    S.X₂ ≅ S.X₁ ⊞ S.X₃ where\n  hom := biprod.lift h.r S.g\n  inv := biprod.desc S.f h.s\n  hom_inv_id := by simp [h.id]\n\n"}
{"name":"CategoryTheory.ShortComplex.Exact.isIso_f'","module":"Mathlib.Algebra.Homology.ShortComplex.Exact","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_3, u_1} C\ninst✝² : CategoryTheory.Preadditive C\nS : CategoryTheory.ShortComplex C\ninst✝¹ : CategoryTheory.Balanced C\nhS : S.Exact\nh : S.LeftHomologyData\ninst✝ : CategoryTheory.Mono S.f\n⊢ CategoryTheory.IsIso h.f'","decl":"lemma isIso_f' (hS : S.Exact) (h : S.LeftHomologyData) [Mono S.f] :\n    IsIso h.f' := by\n  have := hS.epi_f' h\n  have := mono_of_mono_fac h.f'_i\n  exact isIso_of_mono_of_epi h.f'\n\n"}
{"name":"CategoryTheory.ShortComplex.Exact.isIso_toCycles","module":"Mathlib.Algebra.Homology.ShortComplex.Exact","initialProofState":"C : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_3, u_1} C\ninst✝³ : CategoryTheory.Preadditive C\nS : CategoryTheory.ShortComplex C\ninst✝² : CategoryTheory.Balanced C\nhS : S.Exact\ninst✝¹ : CategoryTheory.Mono S.f\ninst✝ : S.HasLeftHomology\n⊢ CategoryTheory.IsIso S.toCycles","decl":"lemma isIso_toCycles (hS : S.Exact) [Mono S.f] [S.HasLeftHomology]:\n    IsIso S.toCycles :=\n  hS.isIso_f' _\n\n"}
{"name":"CategoryTheory.ShortComplex.Exact.isIso_g'","module":"Mathlib.Algebra.Homology.ShortComplex.Exact","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_3, u_1} C\ninst✝² : CategoryTheory.Preadditive C\nS : CategoryTheory.ShortComplex C\ninst✝¹ : CategoryTheory.Balanced C\nhS : S.Exact\nh : S.RightHomologyData\ninst✝ : CategoryTheory.Epi S.g\n⊢ CategoryTheory.IsIso h.g'","decl":"lemma isIso_g' (hS : S.Exact) (h : S.RightHomologyData) [Epi S.g] :\n    IsIso h.g' := by\n  have := hS.mono_g' h\n  have := epi_of_epi_fac h.p_g'\n  exact isIso_of_mono_of_epi h.g'\n\n"}
{"name":"CategoryTheory.ShortComplex.Exact.isIso_fromOpcycles","module":"Mathlib.Algebra.Homology.ShortComplex.Exact","initialProofState":"C : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_3, u_1} C\ninst✝³ : CategoryTheory.Preadditive C\nS : CategoryTheory.ShortComplex C\ninst✝² : CategoryTheory.Balanced C\nhS : S.Exact\ninst✝¹ : CategoryTheory.Epi S.g\ninst✝ : S.HasRightHomology\n⊢ CategoryTheory.IsIso S.fromOpcycles","decl":"lemma isIso_fromOpcycles (hS : S.Exact) [Epi S.g] [S.HasRightHomology] :\n    IsIso S.fromOpcycles :=\n  hS.isIso_g' _\n\n"}
{"name":"CategoryTheory.ShortComplex.Exact.map_of_mono_of_preservesKernel","module":"Mathlib.Algebra.Homology.ShortComplex.Exact","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁶ : CategoryTheory.Category.{u_3, u_1} C\ninst✝⁵ : CategoryTheory.Category.{u_4, u_2} D\ninst✝⁴ : CategoryTheory.Preadditive C\ninst✝³ : CategoryTheory.Preadditive D\nS : CategoryTheory.ShortComplex C\ninst✝² : CategoryTheory.Balanced C\nhS : S.Exact\nF : CategoryTheory.Functor C D\ninst✝¹ : F.PreservesZeroMorphisms\ninst✝ : (S.map F).HasHomology\nx✝¹ : CategoryTheory.Mono S.f\nx✝ : CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.parallelPair S.g 0) F\n⊢ (S.map F).Exact","decl":"lemma map_of_mono_of_preservesKernel (hS : S.Exact) (F : C ⥤ D)\n    [F.PreservesZeroMorphisms] [(S.map F).HasHomology] (_ : Mono S.f)\n    (_ : PreservesLimit (parallelPair S.g 0) F) :\n    (S.map F).Exact :=\n  exact_of_f_is_kernel _ (KernelFork.mapIsLimit _ hS.fIsKernel F)\n\n"}
{"name":"CategoryTheory.ShortComplex.Exact.map_of_epi_of_preservesCokernel","module":"Mathlib.Algebra.Homology.ShortComplex.Exact","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁶ : CategoryTheory.Category.{u_3, u_1} C\ninst✝⁵ : CategoryTheory.Category.{u_4, u_2} D\ninst✝⁴ : CategoryTheory.Preadditive C\ninst✝³ : CategoryTheory.Preadditive D\nS : CategoryTheory.ShortComplex C\ninst✝² : CategoryTheory.Balanced C\nhS : S.Exact\nF : CategoryTheory.Functor C D\ninst✝¹ : F.PreservesZeroMorphisms\ninst✝ : (S.map F).HasHomology\nx✝¹ : CategoryTheory.Epi S.g\nx✝ : CategoryTheory.Limits.PreservesColimit (CategoryTheory.Limits.parallelPair S.f 0) F\n⊢ (S.map F).Exact","decl":"lemma map_of_epi_of_preservesCokernel (hS : S.Exact) (F : C ⥤ D)\n    [F.PreservesZeroMorphisms] [(S.map F).HasHomology] (_ : Epi S.g)\n    (_ : PreservesColimit (parallelPair S.f 0) F) :\n    (S.map F).Exact :=\n  exact_of_g_is_cokernel _ (CokernelCofork.mapIsColimit _ hS.gIsCokernel F)\n\n"}
{"name":"CategoryTheory.ShortComplex.Exact.lift_f","module":"Mathlib.Algebra.Homology.ShortComplex.Exact","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_3, u_1} C\ninst✝² : CategoryTheory.Preadditive C\nS : CategoryTheory.ShortComplex C\ninst✝¹ : CategoryTheory.Balanced C\nhS : S.Exact\nA : C\nk : Quiver.Hom A S.X₂\nhk : Eq (CategoryTheory.CategoryStruct.comp k S.g) 0\ninst✝ : CategoryTheory.Mono S.f\n⊢ Eq (CategoryTheory.CategoryStruct.comp (hS.lift k hk) S.f) k","decl":"@[reassoc (attr := simp)]\nlemma lift_f (hS : S.Exact) {A : C} (k : A ⟶ S.X₂) (hk : k ≫ S.g = 0) [Mono S.f] :\n    hS.lift k hk ≫ S.f = k :=\n  Fork.IsLimit.lift_ι _\n\n"}
{"name":"CategoryTheory.ShortComplex.Exact.lift_f_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.Exact","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_3, u_1} C\ninst✝² : CategoryTheory.Preadditive C\nS : CategoryTheory.ShortComplex C\ninst✝¹ : CategoryTheory.Balanced C\nhS : S.Exact\nA : C\nk : Quiver.Hom A S.X₂\nhk : Eq (CategoryTheory.CategoryStruct.comp k S.g) 0\ninst✝ : CategoryTheory.Mono S.f\nZ : C\nh : Quiver.Hom S.X₂ Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (hS.lift k hk) (CategoryTheory.CategoryStruct.comp S.f h)) (CategoryTheory.CategoryStruct.comp k h)","decl":"@[reassoc (attr := simp)]\nlemma lift_f (hS : S.Exact) {A : C} (k : A ⟶ S.X₂) (hk : k ≫ S.g = 0) [Mono S.f] :\n    hS.lift k hk ≫ S.f = k :=\n  Fork.IsLimit.lift_ι _\n\n"}
{"name":"CategoryTheory.ShortComplex.Exact.lift'","module":"Mathlib.Algebra.Homology.ShortComplex.Exact","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_3, u_1} C\ninst✝² : CategoryTheory.Preadditive C\nS : CategoryTheory.ShortComplex C\ninst✝¹ : CategoryTheory.Balanced C\nhS : S.Exact\nA : C\nk : Quiver.Hom A S.X₂\nhk : Eq (CategoryTheory.CategoryStruct.comp k S.g) 0\ninst✝ : CategoryTheory.Mono S.f\n⊢ Exists fun l => Eq (CategoryTheory.CategoryStruct.comp l S.f) k","decl":"lemma lift' (hS : S.Exact) {A : C} (k : A ⟶ S.X₂) (hk : k ≫ S.g = 0) [Mono S.f] :\n    ∃ (l : A ⟶ S.X₁), l ≫ S.f = k :=\n  ⟨hS.lift k hk, by simp⟩\n\n"}
{"name":"CategoryTheory.ShortComplex.Exact.g_desc","module":"Mathlib.Algebra.Homology.ShortComplex.Exact","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_3, u_1} C\ninst✝² : CategoryTheory.Preadditive C\nS : CategoryTheory.ShortComplex C\ninst✝¹ : CategoryTheory.Balanced C\nhS : S.Exact\nA : C\nk : Quiver.Hom S.X₂ A\nhk : Eq (CategoryTheory.CategoryStruct.comp S.f k) 0\ninst✝ : CategoryTheory.Epi S.g\n⊢ Eq (CategoryTheory.CategoryStruct.comp S.g (hS.desc k hk)) k","decl":"@[reassoc (attr := simp)]\nlemma g_desc (hS : S.Exact) {A : C} (k : S.X₂ ⟶ A) (hk : S.f ≫ k = 0) [Epi S.g] :\n    S.g ≫ hS.desc k hk = k :=\n  Cofork.IsColimit.π_desc (hS.gIsCokernel)\n\n"}
{"name":"CategoryTheory.ShortComplex.Exact.g_desc_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.Exact","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_3, u_1} C\ninst✝² : CategoryTheory.Preadditive C\nS : CategoryTheory.ShortComplex C\ninst✝¹ : CategoryTheory.Balanced C\nhS : S.Exact\nA : C\nk : Quiver.Hom S.X₂ A\nhk : Eq (CategoryTheory.CategoryStruct.comp S.f k) 0\ninst✝ : CategoryTheory.Epi S.g\nZ : C\nh : Quiver.Hom A Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp S.g (CategoryTheory.CategoryStruct.comp (hS.desc k hk) h)) (CategoryTheory.CategoryStruct.comp k h)","decl":"@[reassoc (attr := simp)]\nlemma g_desc (hS : S.Exact) {A : C} (k : S.X₂ ⟶ A) (hk : S.f ≫ k = 0) [Epi S.g] :\n    S.g ≫ hS.desc k hk = k :=\n  Cofork.IsColimit.π_desc (hS.gIsCokernel)\n\n"}
{"name":"CategoryTheory.ShortComplex.Exact.desc'","module":"Mathlib.Algebra.Homology.ShortComplex.Exact","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_3, u_1} C\ninst✝² : CategoryTheory.Preadditive C\nS : CategoryTheory.ShortComplex C\ninst✝¹ : CategoryTheory.Balanced C\nhS : S.Exact\nA : C\nk : Quiver.Hom S.X₂ A\nhk : Eq (CategoryTheory.CategoryStruct.comp S.f k) 0\ninst✝ : CategoryTheory.Epi S.g\n⊢ Exists fun l => Eq (CategoryTheory.CategoryStruct.comp S.g l) k","decl":"lemma desc' (hS : S.Exact) {A : C} (k : S.X₂ ⟶ A) (hk : S.f ≫ k = 0) [Epi S.g] :\n    ∃ (l : S.X₃ ⟶ A), S.g ≫ l = k :=\n  ⟨hS.desc k hk, by simp⟩\n\n"}
{"name":"CategoryTheory.ShortComplex.mono_τ₂_of_exact_of_mono","module":"Mathlib.Algebra.Homology.ShortComplex.Exact","initialProofState":"C : Type u_1\ninst✝⁶ : CategoryTheory.Category.{u_3, u_1} C\ninst✝⁵ : CategoryTheory.Preadditive C\ninst✝⁴ : CategoryTheory.Balanced C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nh₁ : S₁.Exact\ninst✝³ : CategoryTheory.Mono S₁.f\ninst✝² : CategoryTheory.Mono S₂.f\ninst✝¹ : CategoryTheory.Mono φ.τ₁\ninst✝ : CategoryTheory.Mono φ.τ₃\n⊢ CategoryTheory.Mono φ.τ₂","decl":"lemma mono_τ₂_of_exact_of_mono {S₁ S₂ : ShortComplex C} (φ : S₁ ⟶ S₂)\n    (h₁ : S₁.Exact) [Mono S₁.f] [Mono S₂.f] [Mono φ.τ₁] [Mono φ.τ₃] : Mono φ.τ₂ := by\n  rw [mono_iff_cancel_zero]\n  intro A x₂ hx₂\n  obtain ⟨x₁, hx₁⟩ : ∃ x₁, x₁ ≫ S₁.f = x₂ := ⟨_, h₁.lift_f x₂\n    (by simp only [← cancel_mono φ.τ₃, assoc, zero_comp, ← φ.comm₂₃, reassoc_of% hx₂])⟩\n  suffices x₁ = 0 by rw [← hx₁, this, zero_comp]\n  simp only [← cancel_mono φ.τ₁, ← cancel_mono S₂.f, assoc, φ.comm₁₂, zero_comp,\n    reassoc_of% hx₁, hx₂]\n\n"}
{"name":"CategoryTheory.ShortComplex.epi_τ₂_of_exact_of_epi","module":"Mathlib.Algebra.Homology.ShortComplex.Exact","initialProofState":"C : Type u_1\ninst✝⁶ : CategoryTheory.Category.{u_3, u_1} C\ninst✝⁵ : CategoryTheory.Preadditive C\ninst✝⁴ : CategoryTheory.Balanced C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nh₂ : S₂.Exact\ninst✝³ : CategoryTheory.Epi S₁.g\ninst✝² : CategoryTheory.Epi S₂.g\ninst✝¹ : CategoryTheory.Epi φ.τ₁\ninst✝ : CategoryTheory.Epi φ.τ₃\n⊢ CategoryTheory.Epi φ.τ₂","decl":"lemma epi_τ₂_of_exact_of_epi {S₁ S₂ : ShortComplex C} (φ : S₁ ⟶ S₂)\n    (h₂ : S₂.Exact) [Epi S₁.g] [Epi S₂.g] [Epi φ.τ₁] [Epi φ.τ₃] : Epi φ.τ₂ := by\n  have : Mono S₁.op.f := by dsimp; infer_instance\n  have : Mono S₂.op.f := by dsimp; infer_instance\n  have : Mono (opMap φ).τ₁ := by dsimp; infer_instance\n  have : Mono (opMap φ).τ₃ := by dsimp; infer_instance\n  have := mono_τ₂_of_exact_of_mono (opMap φ) h₂.op\n  exact unop_epi_of_mono (opMap φ).τ₂\n\n"}
{"name":"CategoryTheory.ShortComplex.exact_and_mono_f_iff_f_is_kernel","module":"Mathlib.Algebra.Homology.ShortComplex.Exact","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_3, u_1} C\ninst✝² : CategoryTheory.Preadditive C\nS : CategoryTheory.ShortComplex C\ninst✝¹ : CategoryTheory.Balanced C\ninst✝ : S.HasHomology\n⊢ Iff (And S.Exact (CategoryTheory.Mono S.f)) (Nonempty (CategoryTheory.Limits.IsLimit (CategoryTheory.Limits.KernelFork.ofι S.f ⋯)))","decl":"lemma exact_and_mono_f_iff_f_is_kernel [S.HasHomology] :\n    S.Exact ∧ Mono S.f ↔ Nonempty (IsLimit (KernelFork.ofι S.f S.zero)) := by\n  constructor\n  · intro ⟨hS, _⟩\n    exact ⟨hS.fIsKernel⟩\n  · intro ⟨hS⟩\n    exact ⟨S.exact_of_f_is_kernel hS, mono_of_isLimit_fork hS⟩\n\n"}
{"name":"CategoryTheory.ShortComplex.exact_and_epi_g_iff_g_is_cokernel","module":"Mathlib.Algebra.Homology.ShortComplex.Exact","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_3, u_1} C\ninst✝² : CategoryTheory.Preadditive C\nS : CategoryTheory.ShortComplex C\ninst✝¹ : CategoryTheory.Balanced C\ninst✝ : S.HasHomology\n⊢ Iff (And S.Exact (CategoryTheory.Epi S.g)) (Nonempty (CategoryTheory.Limits.IsColimit (CategoryTheory.Limits.CokernelCofork.ofπ S.g ⋯)))","decl":"lemma exact_and_epi_g_iff_g_is_cokernel [S.HasHomology] :\n    S.Exact ∧ Epi S.g ↔ Nonempty (IsColimit (CokernelCofork.ofπ S.g S.zero)) := by\n  constructor\n  · intro ⟨hS, _⟩\n    exact ⟨hS.gIsCokernel⟩\n  · intro ⟨hS⟩\n    exact ⟨S.exact_of_g_is_cokernel hS, epi_of_isColimit_cofork hS⟩\n\n"}
{"name":"CategoryTheory.ShortComplex.quasiIso_iff_of_zeros","module":"Mathlib.Algebra.Homology.ShortComplex.Exact","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_3, u_1} C\ninst✝ : CategoryTheory.Abelian C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nhf₁ : Eq S₁.f 0\nhg₁ : Eq S₁.g 0\nhf₂ : Eq S₂.f 0\n⊢ Iff (CategoryTheory.ShortComplex.QuasiIso φ) (And (CategoryTheory.ShortComplex.mk φ.τ₂ S₂.g ⋯).Exact (CategoryTheory.Mono φ.τ₂))","decl":"/-- Given a morphism of short complexes `φ : S₁ ⟶ S₂` in an abelian category, if `S₁.f`\nand `S₁.g` are zero (e.g. when `S₁` is of the form `0 ⟶ S₁.X₂ ⟶ 0`) and `S₂.f = 0`\n(e.g when `S₂` is of the form `0 ⟶ S₂.X₂ ⟶ S₂.X₃`), then `φ` is a quasi-isomorphism iff\nthe obvious short complex `S₁.X₂ ⟶ S₂.X₂ ⟶ S₂.X₃` is exact and `φ.τ₂` is a mono). -/\nlemma quasiIso_iff_of_zeros {S₁ S₂ : ShortComplex C} (φ : S₁ ⟶ S₂)\n    (hf₁ : S₁.f = 0) (hg₁ : S₁.g = 0) (hf₂ : S₂.f = 0) :\n    QuasiIso φ ↔\n      (ShortComplex.mk φ.τ₂ S₂.g (by rw [φ.comm₂₃, hg₁, zero_comp])).Exact ∧ Mono φ.τ₂ := by\n  have w : φ.τ₂ ≫ S₂.g = 0 := by rw [φ.comm₂₃, hg₁, zero_comp]\n  rw [quasiIso_iff_isIso_liftCycles φ hf₁ hg₁ hf₂]\n  constructor\n  · intro h\n    have : Mono φ.τ₂ := by\n      rw [← S₂.liftCycles_i φ.τ₂ w]\n      apply mono_comp\n    refine ⟨?_, this⟩\n    apply exact_of_f_is_kernel\n    exact IsLimit.ofIsoLimit S₂.cyclesIsKernel\n      (Fork.ext (asIso (S₂.liftCycles φ.τ₂ w)).symm (by simp))\n  · rintro ⟨h₁, h₂⟩\n    refine ⟨⟨h₁.lift S₂.iCycles (by simp), ?_, ?_⟩⟩\n    · rw [← cancel_mono φ.τ₂, assoc, h₁.lift_f, liftCycles_i, id_comp]\n    · rw [← cancel_mono S₂.iCycles, assoc, liftCycles_i, h₁.lift_f, id_comp]\n\n"}
{"name":"CategoryTheory.ShortComplex.quasiIso_iff_of_zeros'","module":"Mathlib.Algebra.Homology.ShortComplex.Exact","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_3, u_1} C\ninst✝ : CategoryTheory.Abelian C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nhg₁ : Eq S₁.g 0\nhf₂ : Eq S₂.f 0\nhg₂ : Eq S₂.g 0\n⊢ Iff (CategoryTheory.ShortComplex.QuasiIso φ) (And (CategoryTheory.ShortComplex.mk S₁.f φ.τ₂ ⋯).Exact (CategoryTheory.Epi φ.τ₂))","decl":"/-- Given a morphism of short complexes `φ : S₁ ⟶ S₂` in an abelian category, if `S₁.g = 0`\n(e.g when `S₁` is of the form `S₁.X₁ ⟶ S₁.X₂ ⟶ 0`) and both `S₂.f` and `S₂.g` are zero\n(e.g when `S₂` is of the form `0 ⟶ S₂.X₂ ⟶ 0`), then `φ` is a quasi-isomorphism iff\nthe obvious short complex `S₁.X₂ ⟶ S₁.X₂ ⟶ S₂.X₂` is exact and `φ.τ₂` is an epi). -/\nlemma quasiIso_iff_of_zeros' {S₁ S₂ : ShortComplex C} (φ : S₁ ⟶ S₂)\n    (hg₁ : S₁.g = 0) (hf₂ : S₂.f = 0) (hg₂ : S₂.g = 0) :\n    QuasiIso φ ↔\n      (ShortComplex.mk S₁.f φ.τ₂ (by rw [← φ.comm₁₂, hf₂, comp_zero])).Exact ∧ Epi φ.τ₂ := by\n  rw [← quasiIso_opMap_iff, quasiIso_iff_of_zeros]\n  rotate_left\n  · dsimp\n    rw [hg₂, op_zero]\n  · dsimp\n    rw [hf₂, op_zero]\n  · dsimp\n    rw [hg₁, op_zero]\n  rw [← exact_unop_iff]\n  have : Mono φ.τ₂.op ↔ Epi φ.τ₂ :=\n    ⟨fun _ => unop_epi_of_mono φ.τ₂.op, fun _ => op_mono_of_epi _⟩\n  tauto\n\n"}
{"name":"CategoryTheory.ShortComplex.Exact.comp_descToInjective_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.Exact","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹ : CategoryTheory.Abelian C\nS : CategoryTheory.ShortComplex C\nhS : S.Exact\nJ : C\nf : Quiver.Hom S.X₂ J\ninst✝ : CategoryTheory.Injective J\nhf : Eq (CategoryTheory.CategoryStruct.comp S.f f) 0\nZ : C\nh : Quiver.Hom J Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp S.g (CategoryTheory.CategoryStruct.comp (hS.descToInjective f hf) h)) (CategoryTheory.CategoryStruct.comp f h)","decl":"@[reassoc (attr := simp, nolint unusedHavesSuffices)]\nlemma Exact.comp_descToInjective\n    (hS : S.Exact) {J : C} (f : S.X₂ ⟶ J) [Injective J] (hf : S.f ≫ f = 0) :\n    S.g ≫ hS.descToInjective f hf = f := by\n  have := hS.mono_fromOpcycles\n  dsimp [descToInjective]\n  simp only [← p_fromOpcycles, assoc, Injective.comp_factorThru, p_descOpcycles]\n\n"}
{"name":"CategoryTheory.ShortComplex.Exact.comp_descToInjective","module":"Mathlib.Algebra.Homology.ShortComplex.Exact","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹ : CategoryTheory.Abelian C\nS : CategoryTheory.ShortComplex C\nhS : S.Exact\nJ : C\nf : Quiver.Hom S.X₂ J\ninst✝ : CategoryTheory.Injective J\nhf : Eq (CategoryTheory.CategoryStruct.comp S.f f) 0\n⊢ Eq (CategoryTheory.CategoryStruct.comp S.g (hS.descToInjective f hf)) f","decl":"@[reassoc (attr := simp, nolint unusedHavesSuffices)]\nlemma Exact.comp_descToInjective\n    (hS : S.Exact) {J : C} (f : S.X₂ ⟶ J) [Injective J] (hf : S.f ≫ f = 0) :\n    S.g ≫ hS.descToInjective f hf = f := by\n  have := hS.mono_fromOpcycles\n  dsimp [descToInjective]\n  simp only [← p_fromOpcycles, assoc, Injective.comp_factorThru, p_descOpcycles]\n\n"}
{"name":"CategoryTheory.ShortComplex.Exact.liftFromProjective_comp_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.Exact","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹ : CategoryTheory.Abelian C\nS : CategoryTheory.ShortComplex C\nhS : S.Exact\nP : C\nf : Quiver.Hom P S.X₂\ninst✝ : CategoryTheory.Projective P\nhf : Eq (CategoryTheory.CategoryStruct.comp f S.g) 0\nZ : C\nh : Quiver.Hom S.X₂ Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (hS.liftFromProjective f hf) (CategoryTheory.CategoryStruct.comp S.f h)) (CategoryTheory.CategoryStruct.comp f h)","decl":"@[reassoc (attr := simp, nolint unusedHavesSuffices)]\nlemma Exact.liftFromProjective_comp\n    (hS : S.Exact) {P : C} (f : P ⟶ S.X₂) [Projective P] (hf : f ≫ S.g = 0) :\n    hS.liftFromProjective f hf ≫ S.f = f := by\n  have := hS.epi_toCycles\n  dsimp [liftFromProjective]\n  rw [← toCycles_i, Projective.factorThru_comp_assoc, liftCycles_i]\n\n\n"}
{"name":"CategoryTheory.ShortComplex.Exact.liftFromProjective_comp","module":"Mathlib.Algebra.Homology.ShortComplex.Exact","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹ : CategoryTheory.Abelian C\nS : CategoryTheory.ShortComplex C\nhS : S.Exact\nP : C\nf : Quiver.Hom P S.X₂\ninst✝ : CategoryTheory.Projective P\nhf : Eq (CategoryTheory.CategoryStruct.comp f S.g) 0\n⊢ Eq (CategoryTheory.CategoryStruct.comp (hS.liftFromProjective f hf) S.f) f","decl":"@[reassoc (attr := simp, nolint unusedHavesSuffices)]\nlemma Exact.liftFromProjective_comp\n    (hS : S.Exact) {P : C} (f : P ⟶ S.X₂) [Projective P] (hf : f ≫ S.g = 0) :\n    hS.liftFromProjective f hf ≫ S.f = f := by\n  have := hS.epi_toCycles\n  dsimp [liftFromProjective]\n  rw [← toCycles_i, Projective.factorThru_comp_assoc, liftCycles_i]\n\n\n"}
{"name":"CategoryTheory.Functor.instPreservesMonomorphisms","module":"Mathlib.Algebra.Homology.ShortComplex.Exact","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_3, u_1} C\ninst✝ : CategoryTheory.Category.{u_4, u_2} D\nF : CategoryTheory.Functor C D\n⊢ F.PreservesMonomorphisms","decl":"instance : F.PreservesMonomorphisms where\n  preserves {X Y} f hf := by\n    let S := ShortComplex.mk (0 : X ⟶ X) f zero_comp\n    exact ((S.map F).exact_iff_mono (by simp [S])).1\n      (((S.exact_iff_mono rfl).2 hf).map F)\n\n\n"}
{"name":"CategoryTheory.Functor.instPreservesEpimorphisms","module":"Mathlib.Algebra.Homology.ShortComplex.Exact","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_3, u_1} C\ninst✝ : CategoryTheory.Category.{u_4, u_2} D\nF : CategoryTheory.Functor C D\n⊢ F.PreservesEpimorphisms","decl":"instance : F.PreservesEpimorphisms where\n  preserves {X Y} f hf := by\n    let S := ShortComplex.mk f (0 : Y ⟶ Y) comp_zero\n    exact ((S.map F).exact_iff_epi (by simp [S])).1\n      (((S.exact_iff_epi rfl).2 hf).map F)\n\n\n"}
