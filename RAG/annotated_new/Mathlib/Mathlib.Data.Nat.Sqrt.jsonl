{"name":"Nat.sqrt.iter_sq_le","module":"Mathlib.Data.Nat.Sqrt","initialProofState":"n guess : Nat\n⊢ LE.le (HMul.hMul (Nat.sqrt.iter n guess) (Nat.sqrt.iter n guess)) n","decl":"lemma sqrt.iter_sq_le (n guess : ℕ) : sqrt.iter n guess * sqrt.iter n guess ≤ n := by\n  unfold sqrt.iter\n  let next := (guess + n / guess) / 2\n  if h : next < guess then\n    simpa only [next, dif_pos h] using sqrt.iter_sq_le n next\n  else\n    simp only [next, dif_neg h]\n    apply Nat.mul_le_of_le_div\n    apply Nat.le_of_add_le_add_left (a := guess)\n    rw [← Nat.mul_two, ← le_div_iff_mul_le]\n    · exact Nat.le_of_not_lt h\n    · exact Nat.zero_lt_two\n\n"}
{"name":"Nat.sqrt.lt_iter_succ_sq","module":"Mathlib.Data.Nat.Sqrt","initialProofState":"n guess : Nat\nhn : LT.lt n (HMul.hMul (HAdd.hAdd guess 1) (HAdd.hAdd guess 1))\n⊢ LT.lt n (HMul.hMul (HAdd.hAdd (Nat.sqrt.iter n guess) 1) (HAdd.hAdd (Nat.sqrt.iter n guess) 1))","decl":"lemma sqrt.lt_iter_succ_sq (n guess : ℕ) (hn : n < (guess + 1) * (guess + 1)) :\n    n < (sqrt.iter n guess + 1) * (sqrt.iter n guess + 1) := by\n  unfold sqrt.iter\n  -- m was `next`\n  let m := (guess + n / guess) / 2\n  dsimp\n  split_ifs with h\n  · suffices n < (m + 1) * (m + 1) by\n      simpa only [dif_pos h] using sqrt.lt_iter_succ_sq n m this\n    refine Nat.lt_of_mul_lt_mul_left ?_ (a := 4 * (guess * guess))\n    apply Nat.lt_of_le_of_lt AM_GM\n    rw [show (4 : ℕ) = 2 * 2 from rfl]\n    rw [Nat.mul_mul_mul_comm 2, Nat.mul_mul_mul_comm (2 * guess)]\n    refine Nat.mul_self_lt_mul_self (?_ : _ < _ * ((_ / 2) + 1))\n    rw [← add_div_right _ (by decide), Nat.mul_comm 2, Nat.mul_assoc,\n      show guess + n / guess + 2 = (guess + n / guess + 1) + 1 from rfl]\n    have aux_lemma {a : ℕ} : a ≤ 2 * ((a + 1) / 2) := by omega\n    refine lt_of_lt_of_le ?_ (Nat.mul_le_mul_left _ aux_lemma)\n    rw [Nat.add_assoc, Nat.mul_add]\n    exact Nat.add_lt_add_left (lt_mul_div_succ _ (lt_of_le_of_lt (Nat.zero_le m) h)) _\n  · simpa only [dif_neg h] using hn\n-- Porting note: the implementation of `Nat.sqrt` in `Batteries` no longer needs `sqrt_aux`.\n"}
{"name":"Nat.sqrt_le","module":"Mathlib.Data.Nat.Sqrt","initialProofState":"n : Nat\n⊢ LE.le (HMul.hMul n.sqrt n.sqrt) n","decl":"lemma sqrt_le (n : ℕ) : sqrt n * sqrt n ≤ n := (sqrt_isSqrt n).left\n\n"}
{"name":"Nat.sqrt_le'","module":"Mathlib.Data.Nat.Sqrt","initialProofState":"n : Nat\n⊢ LE.le (HPow.hPow n.sqrt 2) n","decl":"lemma sqrt_le' (n : ℕ) : sqrt n ^ 2 ≤ n := by simpa [Nat.pow_two] using sqrt_le n\n\n"}
{"name":"Nat.lt_succ_sqrt","module":"Mathlib.Data.Nat.Sqrt","initialProofState":"n : Nat\n⊢ LT.lt n (HMul.hMul n.sqrt.succ n.sqrt.succ)","decl":"lemma lt_succ_sqrt (n : ℕ) : n < succ (sqrt n) * succ (sqrt n) := (sqrt_isSqrt n).right\n\n"}
{"name":"Nat.lt_succ_sqrt'","module":"Mathlib.Data.Nat.Sqrt","initialProofState":"n : Nat\n⊢ LT.lt n (HPow.hPow n.sqrt.succ 2)","decl":"lemma lt_succ_sqrt' (n : ℕ) : n < succ (sqrt n) ^ 2 := by simpa [Nat.pow_two] using lt_succ_sqrt n\n\n"}
{"name":"Nat.sqrt_le_add","module":"Mathlib.Data.Nat.Sqrt","initialProofState":"n : Nat\n⊢ LE.le n (HAdd.hAdd (HAdd.hAdd (HMul.hMul n.sqrt n.sqrt) n.sqrt) n.sqrt)","decl":"lemma sqrt_le_add (n : ℕ) : n ≤ sqrt n * sqrt n + sqrt n + sqrt n := by\n  rw [← succ_mul]; exact le_of_lt_succ (lt_succ_sqrt n)\n\n"}
{"name":"Nat.le_sqrt","module":"Mathlib.Data.Nat.Sqrt","initialProofState":"m n : Nat\n⊢ Iff (LE.le m n.sqrt) (LE.le (HMul.hMul m m) n)","decl":"lemma le_sqrt : m ≤ sqrt n ↔ m * m ≤ n :=\n  ⟨fun h ↦ le_trans (mul_self_le_mul_self h) (sqrt_le n),\n    fun h ↦ le_of_lt_succ <| Nat.mul_self_lt_mul_self_iff.1 <| lt_of_le_of_lt h (lt_succ_sqrt n)⟩\n\n"}
{"name":"Nat.le_sqrt'","module":"Mathlib.Data.Nat.Sqrt","initialProofState":"m n : Nat\n⊢ Iff (LE.le m n.sqrt) (LE.le (HPow.hPow m 2) n)","decl":"lemma le_sqrt' : m ≤ sqrt n ↔ m ^ 2 ≤ n := by simpa only [Nat.pow_two] using le_sqrt\n\n"}
{"name":"Nat.sqrt_lt","module":"Mathlib.Data.Nat.Sqrt","initialProofState":"m n : Nat\n⊢ Iff (LT.lt m.sqrt n) (LT.lt m (HMul.hMul n n))","decl":"lemma sqrt_lt : sqrt m < n ↔ m < n * n := by simp only [← not_le, le_sqrt]\n\n"}
{"name":"Nat.sqrt_lt'","module":"Mathlib.Data.Nat.Sqrt","initialProofState":"m n : Nat\n⊢ Iff (LT.lt m.sqrt n) (LT.lt m (HPow.hPow n 2))","decl":"lemma sqrt_lt' : sqrt m < n ↔ m < n ^ 2 := by simp only [← not_le, le_sqrt']\n\n"}
{"name":"Nat.sqrt_le_self","module":"Mathlib.Data.Nat.Sqrt","initialProofState":"n : Nat\n⊢ LE.le n.sqrt n","decl":"lemma sqrt_le_self (n : ℕ) : sqrt n ≤ n := le_trans (le_mul_self _) (sqrt_le n)\n\n"}
{"name":"Nat.sqrt_le_sqrt","module":"Mathlib.Data.Nat.Sqrt","initialProofState":"m n : Nat\nh : LE.le m n\n⊢ LE.le m.sqrt n.sqrt","decl":"lemma sqrt_le_sqrt (h : m ≤ n) : sqrt m ≤ sqrt n := le_sqrt.2 (le_trans (sqrt_le _) h)\n\n"}
{"name":"Nat.sqrt_zero","module":"Mathlib.Data.Nat.Sqrt","initialProofState":"⊢ Eq (Nat.sqrt 0) 0","decl":"@[simp] lemma sqrt_zero : sqrt 0 = 0 := rfl\n\n"}
{"name":"Nat.sqrt_one","module":"Mathlib.Data.Nat.Sqrt","initialProofState":"⊢ Eq (Nat.sqrt 1) 1","decl":"@[simp] lemma sqrt_one : sqrt 1 = 1 := rfl\n\n"}
{"name":"Nat.sqrt_eq_zero","module":"Mathlib.Data.Nat.Sqrt","initialProofState":"n : Nat\n⊢ Iff (Eq n.sqrt 0) (Eq n 0)","decl":"lemma sqrt_eq_zero : sqrt n = 0 ↔ n = 0 :=\n  ⟨fun h ↦\n      Nat.eq_zero_of_le_zero <| le_of_lt_succ <| (@sqrt_lt n 1).1 <| by rw [h]; decide,\n    by rintro rfl; simp⟩\n\n"}
{"name":"Nat.eq_sqrt","module":"Mathlib.Data.Nat.Sqrt","initialProofState":"n a : Nat\n⊢ Iff (Eq a n.sqrt) (And (LE.le (HMul.hMul a a) n) (LT.lt n (HMul.hMul (HAdd.hAdd a 1) (HAdd.hAdd a 1))))","decl":"lemma eq_sqrt : a = sqrt n ↔ a * a ≤ n ∧ n < (a + 1) * (a + 1) :=\n  ⟨fun e ↦ e.symm ▸ sqrt_isSqrt n,\n   fun ⟨h₁, h₂⟩ ↦ le_antisymm (le_sqrt.2 h₁) (le_of_lt_succ <| sqrt_lt.2 h₂)⟩\n\n"}
{"name":"Nat.eq_sqrt'","module":"Mathlib.Data.Nat.Sqrt","initialProofState":"n a : Nat\n⊢ Iff (Eq a n.sqrt) (And (LE.le (HPow.hPow a 2) n) (LT.lt n (HPow.hPow (HAdd.hAdd a 1) 2)))","decl":"lemma eq_sqrt' : a = sqrt n ↔ a ^ 2 ≤ n ∧ n < (a + 1) ^ 2 := by\n  simpa only [Nat.pow_two] using eq_sqrt\n\n"}
{"name":"Nat.le_three_of_sqrt_eq_one","module":"Mathlib.Data.Nat.Sqrt","initialProofState":"n : Nat\nh : Eq n.sqrt 1\n⊢ LE.le n 3","decl":"lemma le_three_of_sqrt_eq_one (h : sqrt n = 1) : n ≤ 3 :=\n  le_of_lt_succ <| (@sqrt_lt n 2).1 <| by rw [h]; decide\n\n"}
{"name":"Nat.sqrt_lt_self","module":"Mathlib.Data.Nat.Sqrt","initialProofState":"n : Nat\nh : LT.lt 1 n\n⊢ LT.lt n.sqrt n","decl":"lemma sqrt_lt_self (h : 1 < n) : sqrt n < n :=\n  sqrt_lt.2 <| by have := Nat.mul_lt_mul_of_pos_left h (lt_of_succ_lt h); rwa [Nat.mul_one] at this\n\n"}
{"name":"Nat.sqrt_pos","module":"Mathlib.Data.Nat.Sqrt","initialProofState":"n : Nat\n⊢ Iff (LT.lt 0 n.sqrt) (LT.lt 0 n)","decl":"lemma sqrt_pos : 0 < sqrt n ↔ 0 < n :=\n  le_sqrt\n\n"}
{"name":"Nat.sqrt_add_eq","module":"Mathlib.Data.Nat.Sqrt","initialProofState":"a n : Nat\nh : LE.le a (HAdd.hAdd n n)\n⊢ Eq (HAdd.hAdd (HMul.hMul n n) a).sqrt n","decl":"lemma sqrt_add_eq (n : ℕ) (h : a ≤ n + n) : sqrt (n * n + a) = n :=\n  le_antisymm\n    (le_of_lt_succ <|\n      sqrt_lt.2 <| by\n        rw [succ_mul, mul_succ, add_succ, Nat.add_assoc]\n        exact lt_succ_of_le (Nat.add_le_add_left h _))\n    (le_sqrt.2 <| Nat.le_add_right _ _)\n\n"}
{"name":"Nat.sqrt_add_eq'","module":"Mathlib.Data.Nat.Sqrt","initialProofState":"a n : Nat\nh : LE.le a (HAdd.hAdd n n)\n⊢ Eq (HAdd.hAdd (HPow.hPow n 2) a).sqrt n","decl":"lemma sqrt_add_eq' (n : ℕ) (h : a ≤ n + n) : sqrt (n ^ 2 + a) = n := by\n  simpa [Nat.pow_two] using sqrt_add_eq n h\n\n"}
{"name":"Nat.sqrt_eq","module":"Mathlib.Data.Nat.Sqrt","initialProofState":"n : Nat\n⊢ Eq (HMul.hMul n n).sqrt n","decl":"lemma sqrt_eq (n : ℕ) : sqrt (n * n) = n := sqrt_add_eq n (zero_le _)\n\n"}
{"name":"Nat.sqrt_eq'","module":"Mathlib.Data.Nat.Sqrt","initialProofState":"n : Nat\n⊢ Eq (HPow.hPow n 2).sqrt n","decl":"lemma sqrt_eq' (n : ℕ) : sqrt (n ^ 2) = n := sqrt_add_eq' n (zero_le _)\n\n"}
{"name":"Nat.sqrt_succ_le_succ_sqrt","module":"Mathlib.Data.Nat.Sqrt","initialProofState":"n : Nat\n⊢ LE.le n.succ.sqrt n.sqrt.succ","decl":"lemma sqrt_succ_le_succ_sqrt (n : ℕ) : sqrt n.succ ≤ n.sqrt.succ :=\n  le_of_lt_succ <| sqrt_lt.2 <| lt_succ_of_le <|\n  succ_le_succ <| le_trans (sqrt_le_add n) <| Nat.add_le_add_right\n    (by refine add_le_add (Nat.mul_le_mul_right _ ?_) ?_ <;> exact Nat.le_add_right _ 2) _\n\n"}
{"name":"Nat.exists_mul_self","module":"Mathlib.Data.Nat.Sqrt","initialProofState":"x : Nat\n⊢ Iff (Exists fun n => Eq (HMul.hMul n n) x) (Eq (HMul.hMul x.sqrt x.sqrt) x)","decl":"lemma exists_mul_self (x : ℕ) : (∃ n, n * n = x) ↔ sqrt x * sqrt x = x :=\n  ⟨fun ⟨n, hn⟩ ↦ by rw [← hn, sqrt_eq], fun h ↦ ⟨sqrt x, h⟩⟩\n\n"}
{"name":"Nat.exists_mul_self'","module":"Mathlib.Data.Nat.Sqrt","initialProofState":"x : Nat\n⊢ Iff (Exists fun n => Eq (HPow.hPow n 2) x) (Eq (HPow.hPow x.sqrt 2) x)","decl":"lemma exists_mul_self' (x : ℕ) : (∃ n, n ^ 2 = x) ↔ sqrt x ^ 2 = x := by\n  simpa only [Nat.pow_two] using exists_mul_self x\n\n"}
{"name":"Nat.sqrt_mul_sqrt_lt_succ","module":"Mathlib.Data.Nat.Sqrt","initialProofState":"n : Nat\n⊢ LT.lt (HMul.hMul n.sqrt n.sqrt) (HAdd.hAdd n 1)","decl":"lemma sqrt_mul_sqrt_lt_succ (n : ℕ) : sqrt n * sqrt n < n + 1 :=\n  Nat.lt_succ_iff.mpr (sqrt_le _)\n\n"}
{"name":"Nat.sqrt_mul_sqrt_lt_succ'","module":"Mathlib.Data.Nat.Sqrt","initialProofState":"n : Nat\n⊢ LT.lt (HPow.hPow n.sqrt 2) (HAdd.hAdd n 1)","decl":"lemma sqrt_mul_sqrt_lt_succ' (n : ℕ) : sqrt n ^ 2 < n + 1 :=\n  Nat.lt_succ_iff.mpr (sqrt_le' _)\n\n"}
{"name":"Nat.succ_le_succ_sqrt","module":"Mathlib.Data.Nat.Sqrt","initialProofState":"n : Nat\n⊢ LE.le (HAdd.hAdd n 1) (HMul.hMul (HAdd.hAdd n.sqrt 1) (HAdd.hAdd n.sqrt 1))","decl":"lemma succ_le_succ_sqrt (n : ℕ) : n + 1 ≤ (sqrt n + 1) * (sqrt n + 1) :=\n  le_of_pred_lt (lt_succ_sqrt _)\n\n"}
{"name":"Nat.succ_le_succ_sqrt'","module":"Mathlib.Data.Nat.Sqrt","initialProofState":"n : Nat\n⊢ LE.le (HAdd.hAdd n 1) (HPow.hPow (HAdd.hAdd n.sqrt 1) 2)","decl":"lemma succ_le_succ_sqrt' (n : ℕ) : n + 1 ≤ (sqrt n + 1) ^ 2 :=\n  le_of_pred_lt (lt_succ_sqrt' _)\n\n"}
{"name":"Nat.not_exists_sq","module":"Mathlib.Data.Nat.Sqrt","initialProofState":"m n : Nat\nhl : LT.lt (HMul.hMul m m) n\nhr : LT.lt n (HMul.hMul (HAdd.hAdd m 1) (HAdd.hAdd m 1))\n⊢ Not (Exists fun t => Eq (HMul.hMul t t) n)","decl":"/-- There are no perfect squares strictly between m² and (m+1)² -/\nlemma not_exists_sq (hl : m * m < n) (hr : n < (m + 1) * (m + 1)) : ¬∃ t, t * t = n := by\n  rintro ⟨t, rfl⟩\n  have h1 : m < t := Nat.mul_self_lt_mul_self_iff.1 hl\n  have h2 : t < m + 1 := Nat.mul_self_lt_mul_self_iff.1 hr\n  exact (not_lt_of_ge <| le_of_lt_succ h2) h1\n\n"}
{"name":"Nat.not_exists_sq'","module":"Mathlib.Data.Nat.Sqrt","initialProofState":"m n : Nat\na✝¹ : LT.lt (HPow.hPow m 2) n\na✝ : LT.lt n (HPow.hPow (HAdd.hAdd m 1) 2)\n⊢ Not (Exists fun t => Eq (HPow.hPow t 2) n)","decl":"lemma not_exists_sq' : m ^ 2 < n → n < (m + 1) ^ 2 → ¬∃ t, t ^ 2 = n := by\n  simpa only [Nat.pow_two] using not_exists_sq\n\n"}
