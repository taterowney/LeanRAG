{"name":"SemiconjBy.eq","module":"Mathlib.Algebra.Group.Semiconj.Defs","initialProofState":"S : Type u_1\ninst✝ : Mul S\na x y : S\nh : SemiconjBy a x y\n⊢ Eq (HMul.hMul a x) (HMul.hMul y a)","decl":"/-- Equality behind `SemiconjBy a x y`; useful for rewriting. -/\n@[to_additive \"Equality behind `AddSemiconjBy a x y`; useful for rewriting.\"]\nprotected theorem eq [Mul S] {a x y : S} (h : SemiconjBy a x y) : a * x = y * a :=\n  h\n\n"}
{"name":"AddSemiconjBy.eq","module":"Mathlib.Algebra.Group.Semiconj.Defs","initialProofState":"S : Type u_1\ninst✝ : Add S\na x y : S\nh : AddSemiconjBy a x y\n⊢ Eq (HAdd.hAdd a x) (HAdd.hAdd y a)","decl":"/-- Equality behind `SemiconjBy a x y`; useful for rewriting. -/\n@[to_additive \"Equality behind `AddSemiconjBy a x y`; useful for rewriting.\"]\nprotected theorem eq [Mul S] {a x y : S} (h : SemiconjBy a x y) : a * x = y * a :=\n  h\n\n"}
{"name":"SemiconjBy.mul_right","module":"Mathlib.Algebra.Group.Semiconj.Defs","initialProofState":"S : Type u_1\ninst✝ : Semigroup S\na x y x' y' : S\nh : SemiconjBy a x y\nh' : SemiconjBy a x' y'\n⊢ SemiconjBy a (HMul.hMul x x') (HMul.hMul y y')","decl":"/-- If `a` semiconjugates `x` to `y` and `x'` to `y'`,\nthen it semiconjugates `x * x'` to `y * y'`. -/\n@[to_additive (attr := simp) \"If `a` semiconjugates `x` to `y` and `x'` to `y'`,\nthen it semiconjugates `x + x'` to `y + y'`.\"]\ntheorem mul_right (h : SemiconjBy a x y) (h' : SemiconjBy a x' y') :\n    SemiconjBy a (x * x') (y * y') := by\n  unfold SemiconjBy\n  -- TODO this could be done using `assoc_rw` if/when this is ported to mathlib4\n  rw [← mul_assoc, h.eq, mul_assoc, h'.eq, ← mul_assoc]\n\n"}
{"name":"AddSemiconjBy.add_right","module":"Mathlib.Algebra.Group.Semiconj.Defs","initialProofState":"S : Type u_1\ninst✝ : AddSemigroup S\na x y x' y' : S\nh : AddSemiconjBy a x y\nh' : AddSemiconjBy a x' y'\n⊢ AddSemiconjBy a (HAdd.hAdd x x') (HAdd.hAdd y y')","decl":"/-- If `a` semiconjugates `x` to `y` and `x'` to `y'`,\nthen it semiconjugates `x * x'` to `y * y'`. -/\n@[to_additive (attr := simp) \"If `a` semiconjugates `x` to `y` and `x'` to `y'`,\nthen it semiconjugates `x + x'` to `y + y'`.\"]\ntheorem mul_right (h : SemiconjBy a x y) (h' : SemiconjBy a x' y') :\n    SemiconjBy a (x * x') (y * y') := by\n  unfold SemiconjBy\n  -- TODO this could be done using `assoc_rw` if/when this is ported to mathlib4\n  rw [← mul_assoc, h.eq, mul_assoc, h'.eq, ← mul_assoc]\n\n"}
{"name":"SemiconjBy.mul_left","module":"Mathlib.Algebra.Group.Semiconj.Defs","initialProofState":"S : Type u_1\ninst✝ : Semigroup S\na b x y z : S\nha : SemiconjBy a y z\nhb : SemiconjBy b x y\n⊢ SemiconjBy (HMul.hMul a b) x z","decl":"/-- If `b` semiconjugates `x` to `y` and `a` semiconjugates `y` to `z`, then `a * b`\nsemiconjugates `x` to `z`. -/\n@[to_additive \"If `b` semiconjugates `x` to `y` and `a` semiconjugates `y` to `z`, then `a + b`\nsemiconjugates `x` to `z`.\"]\ntheorem mul_left (ha : SemiconjBy a y z) (hb : SemiconjBy b x y) : SemiconjBy (a * b) x z := by\n  unfold SemiconjBy\n  rw [mul_assoc, hb.eq, ← mul_assoc, ha.eq, mul_assoc]\n\n"}
{"name":"AddSemiconjBy.add_left","module":"Mathlib.Algebra.Group.Semiconj.Defs","initialProofState":"S : Type u_1\ninst✝ : AddSemigroup S\na b x y z : S\nha : AddSemiconjBy a y z\nhb : AddSemiconjBy b x y\n⊢ AddSemiconjBy (HAdd.hAdd a b) x z","decl":"/-- If `b` semiconjugates `x` to `y` and `a` semiconjugates `y` to `z`, then `a * b`\nsemiconjugates `x` to `z`. -/\n@[to_additive \"If `b` semiconjugates `x` to `y` and `a` semiconjugates `y` to `z`, then `a + b`\nsemiconjugates `x` to `z`.\"]\ntheorem mul_left (ha : SemiconjBy a y z) (hb : SemiconjBy b x y) : SemiconjBy (a * b) x z := by\n  unfold SemiconjBy\n  rw [mul_assoc, hb.eq, ← mul_assoc, ha.eq, mul_assoc]\n\n"}
{"name":"AddSemiconjBy.transitive","module":"Mathlib.Algebra.Group.Semiconj.Defs","initialProofState":"S : Type u_1\ninst✝ : AddSemigroup S\n⊢ Transitive fun a b => Exists fun c => AddSemiconjBy c a b","decl":"/-- The relation “there exists an element that semiconjugates `a` to `b`” on a semigroup\nis transitive. -/\n@[to_additive \"The relation “there exists an element that semiconjugates `a` to `b`” on an additive\nsemigroup is transitive.\"]\nprotected theorem transitive : Transitive fun a b : S ↦ ∃ c, SemiconjBy c a b\n  | _, _, _, ⟨x, hx⟩, ⟨y, hy⟩ => ⟨y * x, hy.mul_left hx⟩\n\n"}
{"name":"SemiconjBy.transitive","module":"Mathlib.Algebra.Group.Semiconj.Defs","initialProofState":"S : Type u_1\ninst✝ : Semigroup S\n⊢ Transitive fun a b => Exists fun c => SemiconjBy c a b","decl":"/-- The relation “there exists an element that semiconjugates `a` to `b`” on a semigroup\nis transitive. -/\n@[to_additive \"The relation “there exists an element that semiconjugates `a` to `b`” on an additive\nsemigroup is transitive.\"]\nprotected theorem transitive : Transitive fun a b : S ↦ ∃ c, SemiconjBy c a b\n  | _, _, _, ⟨x, hx⟩, ⟨y, hy⟩ => ⟨y * x, hy.mul_left hx⟩\n\n"}
{"name":"AddSemiconjBy.zero_right","module":"Mathlib.Algebra.Group.Semiconj.Defs","initialProofState":"M : Type u_2\ninst✝ : AddZeroClass M\na : M\n⊢ AddSemiconjBy a 0 0","decl":"/-- Any element semiconjugates `1` to `1`. -/\n@[to_additive (attr := simp) \"Any element semiconjugates `0` to `0`.\"]\ntheorem one_right (a : M) : SemiconjBy a 1 1 := by rw [SemiconjBy, mul_one, one_mul]\n\n"}
{"name":"SemiconjBy.one_right","module":"Mathlib.Algebra.Group.Semiconj.Defs","initialProofState":"M : Type u_2\ninst✝ : MulOneClass M\na : M\n⊢ SemiconjBy a 1 1","decl":"/-- Any element semiconjugates `1` to `1`. -/\n@[to_additive (attr := simp) \"Any element semiconjugates `0` to `0`.\"]\ntheorem one_right (a : M) : SemiconjBy a 1 1 := by rw [SemiconjBy, mul_one, one_mul]\n\n"}
{"name":"AddSemiconjBy.zero_left","module":"Mathlib.Algebra.Group.Semiconj.Defs","initialProofState":"M : Type u_2\ninst✝ : AddZeroClass M\nx : M\n⊢ AddSemiconjBy 0 x x","decl":"/-- One semiconjugates any element to itself. -/\n@[to_additive (attr := simp) \"Zero semiconjugates any element to itself.\"]\ntheorem one_left (x : M) : SemiconjBy 1 x x :=\n  Eq.symm <| one_right x\n\n"}
{"name":"SemiconjBy.one_left","module":"Mathlib.Algebra.Group.Semiconj.Defs","initialProofState":"M : Type u_2\ninst✝ : MulOneClass M\nx : M\n⊢ SemiconjBy 1 x x","decl":"/-- One semiconjugates any element to itself. -/\n@[to_additive (attr := simp) \"Zero semiconjugates any element to itself.\"]\ntheorem one_left (x : M) : SemiconjBy 1 x x :=\n  Eq.symm <| one_right x\n\n"}
{"name":"AddSemiconjBy.reflexive","module":"Mathlib.Algebra.Group.Semiconj.Defs","initialProofState":"M : Type u_2\ninst✝ : AddZeroClass M\n⊢ Reflexive fun a b => Exists fun c => AddSemiconjBy c a b","decl":"/-- The relation “there exists an element that semiconjugates `a` to `b`” on a monoid (or, more\ngenerally, on `MulOneClass` type) is reflexive. -/\n@[to_additive \"The relation “there exists an element that semiconjugates `a` to `b`” on an additive\nmonoid (or, more generally, on an `AddZeroClass` type) is reflexive.\"]\nprotected theorem reflexive : Reflexive fun a b : M ↦ ∃ c, SemiconjBy c a b\n  | a => ⟨1, one_left a⟩\n\n"}
{"name":"SemiconjBy.reflexive","module":"Mathlib.Algebra.Group.Semiconj.Defs","initialProofState":"M : Type u_2\ninst✝ : MulOneClass M\n⊢ Reflexive fun a b => Exists fun c => SemiconjBy c a b","decl":"/-- The relation “there exists an element that semiconjugates `a` to `b`” on a monoid (or, more\ngenerally, on `MulOneClass` type) is reflexive. -/\n@[to_additive \"The relation “there exists an element that semiconjugates `a` to `b`” on an additive\nmonoid (or, more generally, on an `AddZeroClass` type) is reflexive.\"]\nprotected theorem reflexive : Reflexive fun a b : M ↦ ∃ c, SemiconjBy c a b\n  | a => ⟨1, one_left a⟩\n\n"}
{"name":"AddSemiconjBy.nsmul_right","module":"Mathlib.Algebra.Group.Semiconj.Defs","initialProofState":"M : Type u_2\ninst✝ : AddMonoid M\na x y : M\nh : AddSemiconjBy a x y\nn : Nat\n⊢ AddSemiconjBy a (HSMul.hSMul n x) (HSMul.hSMul n y)","decl":"@[to_additive (attr := simp)]\ntheorem pow_right {a x y : M} (h : SemiconjBy a x y) (n : ℕ) : SemiconjBy a (x ^ n) (y ^ n) := by\n  induction n with\n  | zero =>\n    rw [pow_zero, pow_zero]\n    exact SemiconjBy.one_right _\n  | succ n ih =>\n    rw [pow_succ, pow_succ]\n    exact ih.mul_right h\n\n"}
{"name":"SemiconjBy.pow_right","module":"Mathlib.Algebra.Group.Semiconj.Defs","initialProofState":"M : Type u_2\ninst✝ : Monoid M\na x y : M\nh : SemiconjBy a x y\nn : Nat\n⊢ SemiconjBy a (HPow.hPow x n) (HPow.hPow y n)","decl":"@[to_additive (attr := simp)]\ntheorem pow_right {a x y : M} (h : SemiconjBy a x y) (n : ℕ) : SemiconjBy a (x ^ n) (y ^ n) := by\n  induction n with\n  | zero =>\n    rw [pow_zero, pow_zero]\n    exact SemiconjBy.one_right _\n  | succ n ih =>\n    rw [pow_succ, pow_succ]\n    exact ih.mul_right h\n\n"}
{"name":"SemiconjBy.conj_mk","module":"Mathlib.Algebra.Group.Semiconj.Defs","initialProofState":"G : Type u_3\ninst✝ : Group G\na x : G\n⊢ SemiconjBy a x (HMul.hMul (HMul.hMul a x) (Inv.inv a))","decl":"/-- `a` semiconjugates `x` to `a * x * a⁻¹`. -/\n@[to_additive \"`a` semiconjugates `x` to `a + x + -a`.\"]\ntheorem conj_mk (a x : G) : SemiconjBy a x (a * x * a⁻¹) := by\n  unfold SemiconjBy; rw [mul_assoc, inv_mul_cancel, mul_one]\n\n"}
{"name":"AddSemiconjBy.conj_mk","module":"Mathlib.Algebra.Group.Semiconj.Defs","initialProofState":"G : Type u_3\ninst✝ : AddGroup G\na x : G\n⊢ AddSemiconjBy a x (HAdd.hAdd (HAdd.hAdd a x) (Neg.neg a))","decl":"/-- `a` semiconjugates `x` to `a * x * a⁻¹`. -/\n@[to_additive \"`a` semiconjugates `x` to `a + x + -a`.\"]\ntheorem conj_mk (a x : G) : SemiconjBy a x (a * x * a⁻¹) := by\n  unfold SemiconjBy; rw [mul_assoc, inv_mul_cancel, mul_one]\n\n"}
{"name":"SemiconjBy.conj_iff","module":"Mathlib.Algebra.Group.Semiconj.Defs","initialProofState":"G : Type u_3\ninst✝ : Group G\na x y b : G\n⊢ Iff (SemiconjBy (HMul.hMul (HMul.hMul b a) (Inv.inv b)) (HMul.hMul (HMul.hMul b x) (Inv.inv b)) (HMul.hMul (HMul.hMul b y) (Inv.inv b))) (SemiconjBy a x y)","decl":"@[to_additive (attr := simp)]\ntheorem conj_iff {a x y b : G} :\n    SemiconjBy (b * a * b⁻¹) (b * x * b⁻¹) (b * y * b⁻¹) ↔ SemiconjBy a x y := by\n  unfold SemiconjBy\n  simp only [← mul_assoc, inv_mul_cancel_right]\n  repeat rw [mul_assoc]\n  rw [mul_left_cancel_iff, ← mul_assoc, ← mul_assoc, mul_right_cancel_iff]\n\n"}
{"name":"AddSemiconjBy.conj_iff","module":"Mathlib.Algebra.Group.Semiconj.Defs","initialProofState":"G : Type u_3\ninst✝ : AddGroup G\na x y b : G\n⊢ Iff (AddSemiconjBy (HAdd.hAdd (HAdd.hAdd b a) (Neg.neg b)) (HAdd.hAdd (HAdd.hAdd b x) (Neg.neg b)) (HAdd.hAdd (HAdd.hAdd b y) (Neg.neg b))) (AddSemiconjBy a x y)","decl":"@[to_additive (attr := simp)]\ntheorem conj_iff {a x y b : G} :\n    SemiconjBy (b * a * b⁻¹) (b * x * b⁻¹) (b * y * b⁻¹) ↔ SemiconjBy a x y := by\n  unfold SemiconjBy\n  simp only [← mul_assoc, inv_mul_cancel_right]\n  repeat rw [mul_assoc]\n  rw [mul_left_cancel_iff, ← mul_assoc, ← mul_assoc, mul_right_cancel_iff]\n\n"}
{"name":"addSemiconjBy_iff_eq","module":"Mathlib.Algebra.Group.Semiconj.Defs","initialProofState":"M : Type u_2\ninst✝ : AddCancelCommMonoid M\na x y : M\n⊢ Iff (AddSemiconjBy a x y) (Eq x y)","decl":"@[to_additive (attr := simp)]\ntheorem semiconjBy_iff_eq [CancelCommMonoid M] {a x y : M} : SemiconjBy a x y ↔ x = y :=\n  ⟨fun h => mul_left_cancel (h.trans (mul_comm _ _)), fun h => by rw [h, SemiconjBy, mul_comm]⟩\n"}
{"name":"semiconjBy_iff_eq","module":"Mathlib.Algebra.Group.Semiconj.Defs","initialProofState":"M : Type u_2\ninst✝ : CancelCommMonoid M\na x y : M\n⊢ Iff (SemiconjBy a x y) (Eq x y)","decl":"@[to_additive (attr := simp)]\ntheorem semiconjBy_iff_eq [CancelCommMonoid M] {a x y : M} : SemiconjBy a x y ↔ x = y :=\n  ⟨fun h => mul_left_cancel (h.trans (mul_comm _ _)), fun h => by rw [h, SemiconjBy, mul_comm]⟩\n"}
