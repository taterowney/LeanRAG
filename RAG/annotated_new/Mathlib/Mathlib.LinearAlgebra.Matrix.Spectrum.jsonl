{"name":"Matrix.IsHermitian.mulVec_eigenvectorBasis","module":"Mathlib.LinearAlgebra.Matrix.Spectrum","initialProofState":"𝕜 : Type u_1\ninst✝² : RCLike 𝕜\nn : Type u_2\ninst✝¹ : Fintype n\nA : Matrix n n 𝕜\ninst✝ : DecidableEq n\nhA : A.IsHermitian\nj : n\n⊢ Eq (A.mulVec ((WithLp.equiv 2 ((i : n) → (fun x => 𝕜) i)) (hA.eigenvectorBasis j))) (HSMul.hSMul (hA.eigenvalues j) ((WithLp.equiv 2 ((i : n) → (fun x => 𝕜) i)) (hA.eigenvectorBasis j)))","decl":"lemma mulVec_eigenvectorBasis (j : n) :\n    A *ᵥ ⇑(hA.eigenvectorBasis j) = (hA.eigenvalues j) • ⇑(hA.eigenvectorBasis j) := by\n  simpa only [eigenvectorBasis, OrthonormalBasis.reindex_apply, toEuclideanLin_apply,\n    RCLike.real_smul_eq_coe_smul (K := 𝕜)] using\n      congr(⇑$((isHermitian_iff_isSymmetric.1 hA).apply_eigenvectorBasis\n        finrank_euclideanSpace ((Fintype.equivOfCardEq (Fintype.card_fin _)).symm j)))\n\n"}
{"name":"Matrix.IsHermitian.spectrum_toEuclideanLin","module":"Mathlib.LinearAlgebra.Matrix.Spectrum","initialProofState":"𝕜 : Type u_1\ninst✝² : RCLike 𝕜\nn : Type u_2\ninst✝¹ : Fintype n\nA : Matrix n n 𝕜\ninst✝ : DecidableEq n\n⊢ Eq (spectrum 𝕜 (Matrix.toEuclideanLin A)) (spectrum 𝕜 A)","decl":"/-- The spectrum of a Hermitian matrix `A` coincides with the spectrum of `toEuclideanLin A`. -/\ntheorem spectrum_toEuclideanLin : spectrum 𝕜 (toEuclideanLin A) = spectrum 𝕜 A :=\n  AlgEquiv.spectrum_eq (Matrix.toLinAlgEquiv (PiLp.basisFun 2 𝕜 n)) _\n\n"}
{"name":"Matrix.IsHermitian.eigenvalues_mem_spectrum_real","module":"Mathlib.LinearAlgebra.Matrix.Spectrum","initialProofState":"𝕜 : Type u_1\ninst✝² : RCLike 𝕜\nn : Type u_2\ninst✝¹ : Fintype n\nA : Matrix n n 𝕜\ninst✝ : DecidableEq n\nhA : A.IsHermitian\ni : n\n⊢ Membership.mem (spectrum Real A) (hA.eigenvalues i)","decl":"/-- Eigenvalues of a hermitian matrix A are in the ℝ spectrum of A. -/\ntheorem eigenvalues_mem_spectrum_real (i : n) : hA.eigenvalues i ∈ spectrum ℝ A := by\n  apply spectrum.of_algebraMap_mem 𝕜\n  rw [← spectrum_toEuclideanLin]\n  exact LinearMap.IsSymmetric.hasEigenvalue_eigenvalues _ _ _ |>.mem_spectrum\n\n"}
{"name":"Matrix.IsHermitian.eigenvectorUnitary_coe","module":"Mathlib.LinearAlgebra.Matrix.Spectrum","initialProofState":"𝕜 : Type u_3\ninst✝² : RCLike 𝕜\nn : Type u_4\ninst✝¹ : Fintype n\nA : Matrix n n 𝕜\ninst✝ : DecidableEq n\nhA : A.IsHermitian\n⊢ Eq (↑hA.eigenvectorUnitary) ((EuclideanSpace.basisFun n 𝕜).toBasis.toMatrix ⇑hA.eigenvectorBasis.toBasis)","decl":"lemma eigenvectorUnitary_coe {𝕜 : Type*} [RCLike 𝕜] {n : Type*} [Fintype n]\n    {A : Matrix n n 𝕜} [DecidableEq n] (hA : Matrix.IsHermitian A) :\n    eigenvectorUnitary hA =\n      (EuclideanSpace.basisFun n 𝕜).toBasis.toMatrix (hA.eigenvectorBasis).toBasis :=\n  rfl\n\n"}
{"name":"Matrix.IsHermitian.eigenvectorUnitary_transpose_apply","module":"Mathlib.LinearAlgebra.Matrix.Spectrum","initialProofState":"𝕜 : Type u_1\ninst✝² : RCLike 𝕜\nn : Type u_2\ninst✝¹ : Fintype n\nA : Matrix n n 𝕜\ninst✝ : DecidableEq n\nhA : A.IsHermitian\nj : n\n⊢ Eq ((↑hA.eigenvectorUnitary).transpose j) ((WithLp.equiv 2 ((i : n) → (fun x => 𝕜) i)) (hA.eigenvectorBasis j))","decl":"@[simp]\ntheorem eigenvectorUnitary_transpose_apply (j : n) :\n    (eigenvectorUnitary hA)ᵀ j = ⇑(hA.eigenvectorBasis j) :=\n  rfl\n\n"}
{"name":"Matrix.IsHermitian.eigenvectorUnitary_apply","module":"Mathlib.LinearAlgebra.Matrix.Spectrum","initialProofState":"𝕜 : Type u_1\ninst✝² : RCLike 𝕜\nn : Type u_2\ninst✝¹ : Fintype n\nA : Matrix n n 𝕜\ninst✝ : DecidableEq n\nhA : A.IsHermitian\ni j : n\n⊢ Eq (↑hA.eigenvectorUnitary i j) ((WithLp.equiv 2 ((i : n) → (fun x => 𝕜) i)) (hA.eigenvectorBasis j) i)","decl":"@[simp]\ntheorem eigenvectorUnitary_apply (i j : n) :\n    eigenvectorUnitary hA i j = ⇑(hA.eigenvectorBasis j) i :=\n  rfl\n\n"}
{"name":"Matrix.IsHermitian.eigenvectorUnitary_mulVec","module":"Mathlib.LinearAlgebra.Matrix.Spectrum","initialProofState":"𝕜 : Type u_1\ninst✝² : RCLike 𝕜\nn : Type u_2\ninst✝¹ : Fintype n\nA : Matrix n n 𝕜\ninst✝ : DecidableEq n\nhA : A.IsHermitian\nj : n\n⊢ Eq ((↑hA.eigenvectorUnitary).mulVec (Pi.single j 1)) ((WithLp.equiv 2 ((i : n) → (fun x => 𝕜) i)) (hA.eigenvectorBasis j))","decl":"theorem eigenvectorUnitary_mulVec (j : n) :\n    eigenvectorUnitary hA *ᵥ Pi.single j 1 = ⇑(hA.eigenvectorBasis j) := by\n  simp_rw [mulVec_single_one, eigenvectorUnitary_transpose_apply]\n\n"}
{"name":"Matrix.IsHermitian.star_eigenvectorUnitary_mulVec","module":"Mathlib.LinearAlgebra.Matrix.Spectrum","initialProofState":"𝕜 : Type u_1\ninst✝² : RCLike 𝕜\nn : Type u_2\ninst✝¹ : Fintype n\nA : Matrix n n 𝕜\ninst✝ : DecidableEq n\nhA : A.IsHermitian\nj : n\n⊢ Eq ((Star.star ↑hA.eigenvectorUnitary).mulVec ((WithLp.equiv 2 ((i : n) → (fun x => 𝕜) i)) (hA.eigenvectorBasis j))) (Pi.single j 1)","decl":"theorem star_eigenvectorUnitary_mulVec (j : n) :\n    (star (eigenvectorUnitary hA : Matrix n n 𝕜)) *ᵥ ⇑(hA.eigenvectorBasis j) = Pi.single j 1 := by\n  rw [← eigenvectorUnitary_mulVec, mulVec_mulVec, unitary.coe_star_mul_self, one_mulVec]\n\n"}
{"name":"Matrix.IsHermitian.star_mul_self_mul_eq_diagonal","module":"Mathlib.LinearAlgebra.Matrix.Spectrum","initialProofState":"𝕜 : Type u_1\ninst✝² : RCLike 𝕜\nn : Type u_2\ninst✝¹ : Fintype n\nA : Matrix n n 𝕜\ninst✝ : DecidableEq n\nhA : A.IsHermitian\n⊢ Eq (HMul.hMul (HMul.hMul (Star.star ↑hA.eigenvectorUnitary) A) ↑hA.eigenvectorUnitary) (Matrix.diagonal (Function.comp RCLike.ofReal hA.eigenvalues))","decl":"/-- Unitary diagonalization of a Hermitian matrix. -/\ntheorem star_mul_self_mul_eq_diagonal :\n    (star (eigenvectorUnitary hA : Matrix n n 𝕜)) * A * (eigenvectorUnitary hA : Matrix n n 𝕜)\n      = diagonal (RCLike.ofReal ∘ hA.eigenvalues) := by\n  apply Matrix.toEuclideanLin.injective\n  apply Basis.ext (EuclideanSpace.basisFun n 𝕜).toBasis\n  intro i\n  simp only [toEuclideanLin_apply, OrthonormalBasis.coe_toBasis, EuclideanSpace.basisFun_apply,\n    WithLp.equiv_single, ← mulVec_mulVec, eigenvectorUnitary_mulVec, ← mulVec_mulVec,\n    mulVec_eigenvectorBasis, Matrix.diagonal_mulVec_single, mulVec_smul,\n    star_eigenvectorUnitary_mulVec, RCLike.real_smul_eq_coe_smul (K := 𝕜), WithLp.equiv_symm_smul,\n    WithLp.equiv_symm_single, Function.comp_apply, mul_one, WithLp.equiv_symm_single]\n  apply PiLp.ext\n  intro j\n  simp only [PiLp.smul_apply, EuclideanSpace.single_apply, smul_eq_mul, mul_ite, mul_one, mul_zero]\n\n\n"}
{"name":"Matrix.IsHermitian.spectral_theorem","module":"Mathlib.LinearAlgebra.Matrix.Spectrum","initialProofState":"𝕜 : Type u_1\ninst✝² : RCLike 𝕜\nn : Type u_2\ninst✝¹ : Fintype n\nA : Matrix n n 𝕜\ninst✝ : DecidableEq n\nhA : A.IsHermitian\n⊢ Eq A (HMul.hMul (HMul.hMul (↑hA.eigenvectorUnitary) (Matrix.diagonal (Function.comp RCLike.ofReal hA.eigenvalues))) (Star.star ↑hA.eigenvectorUnitary))","decl":"/-- **Diagonalization theorem**, **spectral theorem** for matrices; A hermitian matrix can be\ndiagonalized by a change of basis. For the spectral theorem on linear maps, see\n`LinearMap.IsSymmetric.eigenvectorBasis_apply_self_apply`.-/\ntheorem spectral_theorem :\n    A = (eigenvectorUnitary hA : Matrix n n 𝕜) * diagonal (RCLike.ofReal ∘ hA.eigenvalues)\n      * (star (eigenvectorUnitary hA : Matrix n n 𝕜)) := by\n  rw [← star_mul_self_mul_eq_diagonal, mul_assoc, mul_assoc,\n    (Matrix.mem_unitaryGroup_iff).mp (eigenvectorUnitary hA).2, mul_one,\n    ← mul_assoc, (Matrix.mem_unitaryGroup_iff).mp (eigenvectorUnitary hA).2, one_mul]\n\n"}
{"name":"Matrix.IsHermitian.eigenvalues_eq","module":"Mathlib.LinearAlgebra.Matrix.Spectrum","initialProofState":"𝕜 : Type u_1\ninst✝² : RCLike 𝕜\nn : Type u_2\ninst✝¹ : Fintype n\nA : Matrix n n 𝕜\ninst✝ : DecidableEq n\nhA : A.IsHermitian\ni : n\n⊢ Eq (hA.eigenvalues i) (RCLike.re (dotProduct (Star.star ((WithLp.equiv 2 ((i : n) → (fun x => 𝕜) i)) (hA.eigenvectorBasis i))) (A.mulVec ((WithLp.equiv 2 ((i : n) → (fun x => 𝕜) i)) (hA.eigenvectorBasis i)))))","decl":"theorem eigenvalues_eq (i : n) :\n    (hA.eigenvalues i) = RCLike.re (dotProduct (star ⇑(hA.eigenvectorBasis i))\n    (A *ᵥ ⇑(hA.eigenvectorBasis i))) := by\n  simp only [mulVec_eigenvectorBasis, dotProduct_smul,← EuclideanSpace.inner_eq_star_dotProduct,\n    inner_self_eq_norm_sq_to_K, RCLike.smul_re, hA.eigenvectorBasis.orthonormal.1 i,\n    mul_one, algebraMap.coe_one, one_pow, RCLike.one_re]\n\n"}
{"name":"Matrix.IsHermitian.det_eq_prod_eigenvalues","module":"Mathlib.LinearAlgebra.Matrix.Spectrum","initialProofState":"𝕜 : Type u_1\ninst✝² : RCLike 𝕜\nn : Type u_2\ninst✝¹ : Fintype n\nA : Matrix n n 𝕜\ninst✝ : DecidableEq n\nhA : A.IsHermitian\n⊢ Eq A.det (Finset.univ.prod fun i => ↑(hA.eigenvalues i))","decl":"/-- The determinant of a hermitian matrix is the product of its eigenvalues. -/\ntheorem det_eq_prod_eigenvalues : det A = ∏ i, (hA.eigenvalues i : 𝕜) := by\n  convert congr_arg det hA.spectral_theorem\n  rw [det_mul_right_comm]\n  simp\n\n"}
{"name":"Matrix.IsHermitian.rank_eq_rank_diagonal","module":"Mathlib.LinearAlgebra.Matrix.Spectrum","initialProofState":"𝕜 : Type u_1\ninst✝² : RCLike 𝕜\nn : Type u_2\ninst✝¹ : Fintype n\nA : Matrix n n 𝕜\ninst✝ : DecidableEq n\nhA : A.IsHermitian\n⊢ Eq A.rank (Matrix.diagonal hA.eigenvalues).rank","decl":"/-- rank of a hermitian matrix is the rank of after diagonalization by the eigenvector unitary -/\nlemma rank_eq_rank_diagonal : A.rank = (Matrix.diagonal hA.eigenvalues).rank := by\n  conv_lhs => rw [hA.spectral_theorem, ← unitary.coe_star]\n  simp [-isUnit_iff_ne_zero, -unitary.coe_star, rank_diagonal]\n\n"}
{"name":"Matrix.IsHermitian.rank_eq_card_non_zero_eigs","module":"Mathlib.LinearAlgebra.Matrix.Spectrum","initialProofState":"𝕜 : Type u_1\ninst✝² : RCLike 𝕜\nn : Type u_2\ninst✝¹ : Fintype n\nA : Matrix n n 𝕜\ninst✝ : DecidableEq n\nhA : A.IsHermitian\n⊢ Eq A.rank (Fintype.card (Subtype fun i => Ne (hA.eigenvalues i) 0))","decl":"/-- rank of a hermitian matrix is the number of nonzero eigenvalues of the hermitian matrix -/\nlemma rank_eq_card_non_zero_eigs : A.rank = Fintype.card {i // hA.eigenvalues i ≠ 0} := by\n  rw [rank_eq_rank_diagonal hA, Matrix.rank_diagonal]\n\n"}
{"name":"Matrix.IsHermitian.exists_eigenvector_of_ne_zero","module":"Mathlib.LinearAlgebra.Matrix.Spectrum","initialProofState":"𝕜 : Type u_1\ninst✝¹ : RCLike 𝕜\nn : Type u_2\ninst✝ : Fintype n\nA : Matrix n n 𝕜\nhA : A.IsHermitian\nh_ne : Ne A 0\n⊢ Exists fun v => Exists fun t => And (Ne t 0) (And (Ne v 0) (Eq (A.mulVec v) (HSMul.hSMul t v)))","decl":"/-- A nonzero Hermitian matrix has an eigenvector with nonzero eigenvalue. -/\nlemma exists_eigenvector_of_ne_zero (hA : IsHermitian A) (h_ne : A ≠ 0) :\n    ∃ (v : n → 𝕜) (t : ℝ), t ≠ 0 ∧ v ≠ 0 ∧ A *ᵥ v = t • v := by\n  classical\n  have : hA.eigenvalues ≠ 0 := by\n    contrapose! h_ne\n    have := hA.spectral_theorem\n    rwa [h_ne, Pi.comp_zero, RCLike.ofReal_zero, (by rfl : Function.const n (0 : 𝕜) = fun _ ↦ 0),\n      diagonal_zero, mul_zero, zero_mul] at this\n  obtain ⟨i, hi⟩ := Function.ne_iff.mp this\n  exact ⟨_, _, hi, hA.eigenvectorBasis.orthonormal.ne_zero i, hA.mulVec_eigenvectorBasis i⟩\n\n"}
