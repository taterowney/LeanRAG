{"name":"Matrix.IsHermitian.mulVec_eigenvectorBasis","module":"Mathlib.LinearAlgebra.Matrix.Spectrum","initialProofState":"ùïú : Type u_1\ninst‚úù¬≤ : RCLike ùïú\nn : Type u_2\ninst‚úù¬π : Fintype n\nA : Matrix n n ùïú\ninst‚úù : DecidableEq n\nhA : A.IsHermitian\nj : n\n‚ä¢ Eq (A.mulVec ((WithLp.equiv 2 ((i : n) ‚Üí (fun x => ùïú) i)) (hA.eigenvectorBasis j))) (HSMul.hSMul (hA.eigenvalues j) ((WithLp.equiv 2 ((i : n) ‚Üí (fun x => ùïú) i)) (hA.eigenvectorBasis j)))","decl":"lemma mulVec_eigenvectorBasis (j : n) :\n    A *·µ• ‚áë(hA.eigenvectorBasis j) = (hA.eigenvalues j) ‚Ä¢ ‚áë(hA.eigenvectorBasis j) := by\n  simpa only [eigenvectorBasis, OrthonormalBasis.reindex_apply, toEuclideanLin_apply,\n    RCLike.real_smul_eq_coe_smul (K := ùïú)] using\n      congr(‚áë$((isHermitian_iff_isSymmetric.1 hA).apply_eigenvectorBasis\n        finrank_euclideanSpace ((Fintype.equivOfCardEq (Fintype.card_fin _)).symm j)))\n\n"}
{"name":"Matrix.IsHermitian.spectrum_toEuclideanLin","module":"Mathlib.LinearAlgebra.Matrix.Spectrum","initialProofState":"ùïú : Type u_1\ninst‚úù¬≤ : RCLike ùïú\nn : Type u_2\ninst‚úù¬π : Fintype n\nA : Matrix n n ùïú\ninst‚úù : DecidableEq n\n‚ä¢ Eq (spectrum ùïú (Matrix.toEuclideanLin A)) (spectrum ùïú A)","decl":"/-- The spectrum of a Hermitian matrix `A` coincides with the spectrum of `toEuclideanLin A`. -/\ntheorem spectrum_toEuclideanLin : spectrum ùïú (toEuclideanLin A) = spectrum ùïú A :=\n  AlgEquiv.spectrum_eq (Matrix.toLinAlgEquiv (PiLp.basisFun 2 ùïú n)) _\n\n"}
{"name":"Matrix.IsHermitian.eigenvalues_mem_spectrum_real","module":"Mathlib.LinearAlgebra.Matrix.Spectrum","initialProofState":"ùïú : Type u_1\ninst‚úù¬≤ : RCLike ùïú\nn : Type u_2\ninst‚úù¬π : Fintype n\nA : Matrix n n ùïú\ninst‚úù : DecidableEq n\nhA : A.IsHermitian\ni : n\n‚ä¢ Membership.mem (spectrum Real A) (hA.eigenvalues i)","decl":"/-- Eigenvalues of a hermitian matrix A are in the ‚Ñù spectrum of A. -/\ntheorem eigenvalues_mem_spectrum_real (i : n) : hA.eigenvalues i ‚àà spectrum ‚Ñù A := by\n  apply spectrum.of_algebraMap_mem ùïú\n  rw [‚Üê spectrum_toEuclideanLin]\n  exact LinearMap.IsSymmetric.hasEigenvalue_eigenvalues _ _ _ |>.mem_spectrum\n\n"}
{"name":"Matrix.IsHermitian.eigenvectorUnitary_coe","module":"Mathlib.LinearAlgebra.Matrix.Spectrum","initialProofState":"ùïú : Type u_3\ninst‚úù¬≤ : RCLike ùïú\nn : Type u_4\ninst‚úù¬π : Fintype n\nA : Matrix n n ùïú\ninst‚úù : DecidableEq n\nhA : A.IsHermitian\n‚ä¢ Eq (‚ÜëhA.eigenvectorUnitary) ((EuclideanSpace.basisFun n ùïú).toBasis.toMatrix ‚áëhA.eigenvectorBasis.toBasis)","decl":"lemma eigenvectorUnitary_coe {ùïú : Type*} [RCLike ùïú] {n : Type*} [Fintype n]\n    {A : Matrix n n ùïú} [DecidableEq n] (hA : Matrix.IsHermitian A) :\n    eigenvectorUnitary hA =\n      (EuclideanSpace.basisFun n ùïú).toBasis.toMatrix (hA.eigenvectorBasis).toBasis :=\n  rfl\n\n"}
{"name":"Matrix.IsHermitian.eigenvectorUnitary_transpose_apply","module":"Mathlib.LinearAlgebra.Matrix.Spectrum","initialProofState":"ùïú : Type u_1\ninst‚úù¬≤ : RCLike ùïú\nn : Type u_2\ninst‚úù¬π : Fintype n\nA : Matrix n n ùïú\ninst‚úù : DecidableEq n\nhA : A.IsHermitian\nj : n\n‚ä¢ Eq ((‚ÜëhA.eigenvectorUnitary).transpose j) ((WithLp.equiv 2 ((i : n) ‚Üí (fun x => ùïú) i)) (hA.eigenvectorBasis j))","decl":"@[simp]\ntheorem eigenvectorUnitary_transpose_apply (j : n) :\n    (eigenvectorUnitary hA)·µÄ j = ‚áë(hA.eigenvectorBasis j) :=\n  rfl\n\n"}
{"name":"Matrix.IsHermitian.eigenvectorUnitary_apply","module":"Mathlib.LinearAlgebra.Matrix.Spectrum","initialProofState":"ùïú : Type u_1\ninst‚úù¬≤ : RCLike ùïú\nn : Type u_2\ninst‚úù¬π : Fintype n\nA : Matrix n n ùïú\ninst‚úù : DecidableEq n\nhA : A.IsHermitian\ni j : n\n‚ä¢ Eq (‚ÜëhA.eigenvectorUnitary i j) ((WithLp.equiv 2 ((i : n) ‚Üí (fun x => ùïú) i)) (hA.eigenvectorBasis j) i)","decl":"@[simp]\ntheorem eigenvectorUnitary_apply (i j : n) :\n    eigenvectorUnitary hA i j = ‚áë(hA.eigenvectorBasis j) i :=\n  rfl\n\n"}
{"name":"Matrix.IsHermitian.eigenvectorUnitary_mulVec","module":"Mathlib.LinearAlgebra.Matrix.Spectrum","initialProofState":"ùïú : Type u_1\ninst‚úù¬≤ : RCLike ùïú\nn : Type u_2\ninst‚úù¬π : Fintype n\nA : Matrix n n ùïú\ninst‚úù : DecidableEq n\nhA : A.IsHermitian\nj : n\n‚ä¢ Eq ((‚ÜëhA.eigenvectorUnitary).mulVec (Pi.single j 1)) ((WithLp.equiv 2 ((i : n) ‚Üí (fun x => ùïú) i)) (hA.eigenvectorBasis j))","decl":"theorem eigenvectorUnitary_mulVec (j : n) :\n    eigenvectorUnitary hA *·µ• Pi.single j 1 = ‚áë(hA.eigenvectorBasis j) := by\n  simp_rw [mulVec_single_one, eigenvectorUnitary_transpose_apply]\n\n"}
{"name":"Matrix.IsHermitian.star_eigenvectorUnitary_mulVec","module":"Mathlib.LinearAlgebra.Matrix.Spectrum","initialProofState":"ùïú : Type u_1\ninst‚úù¬≤ : RCLike ùïú\nn : Type u_2\ninst‚úù¬π : Fintype n\nA : Matrix n n ùïú\ninst‚úù : DecidableEq n\nhA : A.IsHermitian\nj : n\n‚ä¢ Eq ((Star.star ‚ÜëhA.eigenvectorUnitary).mulVec ((WithLp.equiv 2 ((i : n) ‚Üí (fun x => ùïú) i)) (hA.eigenvectorBasis j))) (Pi.single j 1)","decl":"theorem star_eigenvectorUnitary_mulVec (j : n) :\n    (star (eigenvectorUnitary hA : Matrix n n ùïú)) *·µ• ‚áë(hA.eigenvectorBasis j) = Pi.single j 1 := by\n  rw [‚Üê eigenvectorUnitary_mulVec, mulVec_mulVec, unitary.coe_star_mul_self, one_mulVec]\n\n"}
{"name":"Matrix.IsHermitian.star_mul_self_mul_eq_diagonal","module":"Mathlib.LinearAlgebra.Matrix.Spectrum","initialProofState":"ùïú : Type u_1\ninst‚úù¬≤ : RCLike ùïú\nn : Type u_2\ninst‚úù¬π : Fintype n\nA : Matrix n n ùïú\ninst‚úù : DecidableEq n\nhA : A.IsHermitian\n‚ä¢ Eq (HMul.hMul (HMul.hMul (Star.star ‚ÜëhA.eigenvectorUnitary) A) ‚ÜëhA.eigenvectorUnitary) (Matrix.diagonal (Function.comp RCLike.ofReal hA.eigenvalues))","decl":"/-- Unitary diagonalization of a Hermitian matrix. -/\ntheorem star_mul_self_mul_eq_diagonal :\n    (star (eigenvectorUnitary hA : Matrix n n ùïú)) * A * (eigenvectorUnitary hA : Matrix n n ùïú)\n      = diagonal (RCLike.ofReal ‚àò hA.eigenvalues) := by\n  apply Matrix.toEuclideanLin.injective\n  apply Basis.ext (EuclideanSpace.basisFun n ùïú).toBasis\n  intro i\n  simp only [toEuclideanLin_apply, OrthonormalBasis.coe_toBasis, EuclideanSpace.basisFun_apply,\n    WithLp.equiv_single, ‚Üê mulVec_mulVec, eigenvectorUnitary_mulVec, ‚Üê mulVec_mulVec,\n    mulVec_eigenvectorBasis, Matrix.diagonal_mulVec_single, mulVec_smul,\n    star_eigenvectorUnitary_mulVec, RCLike.real_smul_eq_coe_smul (K := ùïú), WithLp.equiv_symm_smul,\n    WithLp.equiv_symm_single, Function.comp_apply, mul_one, WithLp.equiv_symm_single]\n  apply PiLp.ext\n  intro j\n  simp only [PiLp.smul_apply, EuclideanSpace.single_apply, smul_eq_mul, mul_ite, mul_one, mul_zero]\n\n\n"}
{"name":"Matrix.IsHermitian.spectral_theorem","module":"Mathlib.LinearAlgebra.Matrix.Spectrum","initialProofState":"ùïú : Type u_1\ninst‚úù¬≤ : RCLike ùïú\nn : Type u_2\ninst‚úù¬π : Fintype n\nA : Matrix n n ùïú\ninst‚úù : DecidableEq n\nhA : A.IsHermitian\n‚ä¢ Eq A (HMul.hMul (HMul.hMul (‚ÜëhA.eigenvectorUnitary) (Matrix.diagonal (Function.comp RCLike.ofReal hA.eigenvalues))) (Star.star ‚ÜëhA.eigenvectorUnitary))","decl":"/-- **Diagonalization theorem**, **spectral theorem** for matrices; A hermitian matrix can be\ndiagonalized by a change of basis. For the spectral theorem on linear maps, see\n`LinearMap.IsSymmetric.eigenvectorBasis_apply_self_apply`.-/\ntheorem spectral_theorem :\n    A = (eigenvectorUnitary hA : Matrix n n ùïú) * diagonal (RCLike.ofReal ‚àò hA.eigenvalues)\n      * (star (eigenvectorUnitary hA : Matrix n n ùïú)) := by\n  rw [‚Üê star_mul_self_mul_eq_diagonal, mul_assoc, mul_assoc,\n    (Matrix.mem_unitaryGroup_iff).mp (eigenvectorUnitary hA).2, mul_one,\n    ‚Üê mul_assoc, (Matrix.mem_unitaryGroup_iff).mp (eigenvectorUnitary hA).2, one_mul]\n\n"}
{"name":"Matrix.IsHermitian.eigenvalues_eq","module":"Mathlib.LinearAlgebra.Matrix.Spectrum","initialProofState":"ùïú : Type u_1\ninst‚úù¬≤ : RCLike ùïú\nn : Type u_2\ninst‚úù¬π : Fintype n\nA : Matrix n n ùïú\ninst‚úù : DecidableEq n\nhA : A.IsHermitian\ni : n\n‚ä¢ Eq (hA.eigenvalues i) (RCLike.re (dotProduct (Star.star ((WithLp.equiv 2 ((i : n) ‚Üí (fun x => ùïú) i)) (hA.eigenvectorBasis i))) (A.mulVec ((WithLp.equiv 2 ((i : n) ‚Üí (fun x => ùïú) i)) (hA.eigenvectorBasis i)))))","decl":"theorem eigenvalues_eq (i : n) :\n    (hA.eigenvalues i) = RCLike.re (dotProduct (star ‚áë(hA.eigenvectorBasis i))\n    (A *·µ• ‚áë(hA.eigenvectorBasis i))) := by\n  simp only [mulVec_eigenvectorBasis, dotProduct_smul,‚Üê EuclideanSpace.inner_eq_star_dotProduct,\n    inner_self_eq_norm_sq_to_K, RCLike.smul_re, hA.eigenvectorBasis.orthonormal.1 i,\n    mul_one, algebraMap.coe_one, one_pow, RCLike.one_re]\n\n"}
{"name":"Matrix.IsHermitian.det_eq_prod_eigenvalues","module":"Mathlib.LinearAlgebra.Matrix.Spectrum","initialProofState":"ùïú : Type u_1\ninst‚úù¬≤ : RCLike ùïú\nn : Type u_2\ninst‚úù¬π : Fintype n\nA : Matrix n n ùïú\ninst‚úù : DecidableEq n\nhA : A.IsHermitian\n‚ä¢ Eq A.det (Finset.univ.prod fun i => ‚Üë(hA.eigenvalues i))","decl":"/-- The determinant of a hermitian matrix is the product of its eigenvalues. -/\ntheorem det_eq_prod_eigenvalues : det A = ‚àè i, (hA.eigenvalues i : ùïú) := by\n  convert congr_arg det hA.spectral_theorem\n  rw [det_mul_right_comm]\n  simp\n\n"}
{"name":"Matrix.IsHermitian.rank_eq_rank_diagonal","module":"Mathlib.LinearAlgebra.Matrix.Spectrum","initialProofState":"ùïú : Type u_1\ninst‚úù¬≤ : RCLike ùïú\nn : Type u_2\ninst‚úù¬π : Fintype n\nA : Matrix n n ùïú\ninst‚úù : DecidableEq n\nhA : A.IsHermitian\n‚ä¢ Eq A.rank (Matrix.diagonal hA.eigenvalues).rank","decl":"/-- rank of a hermitian matrix is the rank of after diagonalization by the eigenvector unitary -/\nlemma rank_eq_rank_diagonal : A.rank = (Matrix.diagonal hA.eigenvalues).rank := by\n  conv_lhs => rw [hA.spectral_theorem, ‚Üê unitary.coe_star]\n  simp [-isUnit_iff_ne_zero, -unitary.coe_star, rank_diagonal]\n\n"}
{"name":"Matrix.IsHermitian.rank_eq_card_non_zero_eigs","module":"Mathlib.LinearAlgebra.Matrix.Spectrum","initialProofState":"ùïú : Type u_1\ninst‚úù¬≤ : RCLike ùïú\nn : Type u_2\ninst‚úù¬π : Fintype n\nA : Matrix n n ùïú\ninst‚úù : DecidableEq n\nhA : A.IsHermitian\n‚ä¢ Eq A.rank (Fintype.card (Subtype fun i => Ne (hA.eigenvalues i) 0))","decl":"/-- rank of a hermitian matrix is the number of nonzero eigenvalues of the hermitian matrix -/\nlemma rank_eq_card_non_zero_eigs : A.rank = Fintype.card {i // hA.eigenvalues i ‚â† 0} := by\n  rw [rank_eq_rank_diagonal hA, Matrix.rank_diagonal]\n\n"}
{"name":"Matrix.IsHermitian.exists_eigenvector_of_ne_zero","module":"Mathlib.LinearAlgebra.Matrix.Spectrum","initialProofState":"ùïú : Type u_1\ninst‚úù¬π : RCLike ùïú\nn : Type u_2\ninst‚úù : Fintype n\nA : Matrix n n ùïú\nhA : A.IsHermitian\nh_ne : Ne A 0\n‚ä¢ Exists fun v => Exists fun t => And (Ne t 0) (And (Ne v 0) (Eq (A.mulVec v) (HSMul.hSMul t v)))","decl":"/-- A nonzero Hermitian matrix has an eigenvector with nonzero eigenvalue. -/\nlemma exists_eigenvector_of_ne_zero (hA : IsHermitian A) (h_ne : A ‚â† 0) :\n    ‚àÉ (v : n ‚Üí ùïú) (t : ‚Ñù), t ‚â† 0 ‚àß v ‚â† 0 ‚àß A *·µ• v = t ‚Ä¢ v := by\n  classical\n  have : hA.eigenvalues ‚â† 0 := by\n    contrapose! h_ne\n    have := hA.spectral_theorem\n    rwa [h_ne, Pi.comp_zero, RCLike.ofReal_zero, (by rfl : Function.const n (0 : ùïú) = fun _ ‚Ü¶ 0),\n      diagonal_zero, mul_zero, zero_mul] at this\n  obtain ‚ü®i, hi‚ü© := Function.ne_iff.mp this\n  exact ‚ü®_, _, hi, hA.eigenvectorBasis.orthonormal.ne_zero i, hA.mulVec_eigenvectorBasis i‚ü©\n\n"}
