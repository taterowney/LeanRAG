{"name":"MeasureTheory.unifTight_iff_ennreal","module":"Mathlib.MeasureTheory.Function.UnifTight","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ¹ : Type u_3\ninstâœ : NormedAddCommGroup Î²\nxâœ : MeasurableSpace Î±\nf : Î¹ â†’ Î± â†’ Î²\np : ENNReal\nÎ¼ : MeasureTheory.Measure Î±\nâŠ¢ Iff (MeasureTheory.UnifTight f p Î¼) (âˆ€ â¦ƒÎµ : ENNRealâ¦„, LT.lt 0 Îµ â†’ Exists fun s => And (Ne (Î¼ s) Top.top) (âˆ€ (i : Î¹), LE.le (MeasureTheory.eLpNorm ((HasCompl.compl s).indicator (f i)) p Î¼) Îµ))","decl":"theorem unifTight_iff_ennreal {_ : MeasurableSpace Î±} (f : Î¹ â†’ Î± â†’ Î²) (p : â„â‰¥0âˆ) (Î¼ : Measure Î±) :\n    UnifTight f p Î¼ â†” âˆ€ â¦ƒÎµ : â„â‰¥0âˆâ¦„, 0 < Îµ â†’ âˆƒ s : Set Î±,\n      Î¼ s â‰  âˆ âˆ§ âˆ€ i, eLpNorm (sá¶œ.indicator (f i)) p Î¼ â‰¤ Îµ := by\n  simp only [ENNReal.forall_ennreal, ENNReal.coe_pos]\n  refine (and_iff_left ?_).symm\n  simp only [zero_lt_top, le_top, implies_true, and_true, true_implies]\n  use âˆ…; simpa only [measure_empty] using zero_ne_top\n\n"}
{"name":"MeasureTheory.unifTight_iff_real","module":"Mathlib.MeasureTheory.Function.UnifTight","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ¹ : Type u_3\ninstâœ : NormedAddCommGroup Î²\nxâœ : MeasurableSpace Î±\nf : Î¹ â†’ Î± â†’ Î²\np : ENNReal\nÎ¼ : MeasureTheory.Measure Î±\nâŠ¢ Iff (MeasureTheory.UnifTight f p Î¼) (âˆ€ â¦ƒÎµ : Realâ¦„, LT.lt 0 Îµ â†’ Exists fun s => And (Ne (Î¼ s) Top.top) (âˆ€ (i : Î¹), LE.le (MeasureTheory.eLpNorm ((HasCompl.compl s).indicator (f i)) p Î¼) (ENNReal.ofReal Îµ)))","decl":"theorem unifTight_iff_real {_ : MeasurableSpace Î±} (f : Î¹ â†’ Î± â†’ Î²) (p : â„â‰¥0âˆ) (Î¼ : Measure Î±) :\n    UnifTight f p Î¼ â†” âˆ€ â¦ƒÎµ : â„â¦„, 0 < Îµ â†’ âˆƒ s : Set Î±,\n      Î¼ s â‰  âˆ âˆ§ âˆ€ i, eLpNorm (sá¶œ.indicator (f i)) p Î¼ â‰¤ .ofReal Îµ := by\n  refine âŸ¨fun hut rÎµ hrÎµ â†¦ hut (Real.toNNReal_pos.mpr hrÎµ), fun hut Îµ hÎµ â†¦ ?_âŸ©\n  obtain âŸ¨s, hÎ¼s, hfÎµâŸ© := hut hÎµ\n  use s, hÎ¼s; intro i\n  exact (hfÎµ i).trans_eq (ofReal_coe_nnreal (p := Îµ))\n\n"}
{"name":"MeasureTheory.UnifTight.eventually_cofinite_indicator","module":"Mathlib.MeasureTheory.Function.UnifTight","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ¹ : Type u_3\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : NormedAddCommGroup Î²\nf : Î¹ â†’ Î± â†’ Î²\np : ENNReal\nhf : MeasureTheory.UnifTight f p Î¼\nÎµ : ENNReal\nhÎµ : Ne Îµ 0\nâŠ¢ Filter.Eventually (fun s => âˆ€ (i : Î¹), LE.le (MeasureTheory.eLpNorm (s.indicator (f i)) p Î¼) Îµ) Î¼.cofinite.smallSets","decl":"theorem eventually_cofinite_indicator (hf : UnifTight f p Î¼) {Îµ : â„â‰¥0âˆ} (hÎµ : Îµ â‰  0) :\n    âˆ€á¶  s in Î¼.cofinite.smallSets, âˆ€ i, eLpNorm (s.indicator (f i)) p Î¼ â‰¤ Îµ := by\n  by_cases hÎµ_top : Îµ = âˆ\n  Â· subst hÎµ_top; simp\n  rcases hf (pos_iff_ne_zero.2 (toNNReal_ne_zero.mpr âŸ¨hÎµ,hÎµ_topâŸ©)) with âŸ¨s, hÎ¼s, hfsâŸ©\n  refine (eventually_smallSets' ?_).2 âŸ¨sá¶œ, ?_, fun i â†¦ (coe_toNNReal hÎµ_top) â–¸ hfs iâŸ©\n  Â· intro s t hst ht i\n    exact (eLpNorm_mono <| norm_indicator_le_of_subset hst _).trans (ht i)\n  Â· rwa [Measure.compl_mem_cofinite, lt_top_iff_ne_top]\n\n"}
{"name":"MeasureTheory.UnifTight.exists_measurableSet_indicator","module":"Mathlib.MeasureTheory.Function.UnifTight","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ¹ : Type u_3\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : NormedAddCommGroup Î²\nf : Î¹ â†’ Î± â†’ Î²\np : ENNReal\nhf : MeasureTheory.UnifTight f p Î¼\nÎµ : ENNReal\nhÎµ : Ne Îµ 0\nâŠ¢ Exists fun s => And (MeasurableSet s) (And (LT.lt (Î¼ s) Top.top) (âˆ€ (i : Î¹), LE.le (MeasureTheory.eLpNorm ((HasCompl.compl s).indicator (f i)) p Î¼) Îµ))","decl":"protected theorem exists_measurableSet_indicator (hf : UnifTight f p Î¼) {Îµ : â„â‰¥0âˆ} (hÎµ : Îµ â‰  0) :\n    âˆƒ s, MeasurableSet s âˆ§ Î¼ s < âˆ âˆ§ âˆ€ i, eLpNorm (sá¶œ.indicator (f i)) p Î¼ â‰¤ Îµ :=\n  let âŸ¨s, hÎ¼s, hsm, hfsâŸ© := (hf.eventually_cofinite_indicator hÎµ).exists_measurable_mem_of_smallSets\n  âŸ¨sá¶œ, hsm.compl, hÎ¼s, by rwa [compl_compl s]âŸ©\n\n"}
{"name":"MeasureTheory.UnifTight.add","module":"Mathlib.MeasureTheory.Function.UnifTight","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ¹ : Type u_3\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : NormedAddCommGroup Î²\nf g : Î¹ â†’ Î± â†’ Î²\np : ENNReal\nhf : MeasureTheory.UnifTight f p Î¼\nhg : MeasureTheory.UnifTight g p Î¼\nhf_meas : âˆ€ (i : Î¹), MeasureTheory.AEStronglyMeasurable (f i) Î¼\nhg_meas : âˆ€ (i : Î¹), MeasureTheory.AEStronglyMeasurable (g i) Î¼\nâŠ¢ MeasureTheory.UnifTight (HAdd.hAdd f g) p Î¼","decl":"protected theorem add (hf : UnifTight f p Î¼) (hg : UnifTight g p Î¼)\n    (hf_meas : âˆ€ i, AEStronglyMeasurable (f i) Î¼) (hg_meas : âˆ€ i, AEStronglyMeasurable (g i) Î¼) :\n    UnifTight (f + g) p Î¼ := fun Îµ hÎµ â†¦ by\n  rcases exists_Lp_half Î² Î¼ p (coe_ne_zero.mpr hÎµ.ne') with âŸ¨Î·, hÎ·_pos, hÎ·âŸ©\n  by_cases hÎ·_top : Î· = âˆ\n  Â· replace hÎ· := hÎ·_top â–¸ hÎ·\n    refine âŸ¨âˆ…, (by measurability), fun i â†¦ ?_âŸ©\n    simp only [compl_empty, indicator_univ, Pi.add_apply]\n    exact (hÎ· (f i) (g i) (hf_meas i) (hg_meas i) le_top le_top).le\n  obtain âŸ¨s, hÎ¼s, hsm, hfs, hgsâŸ© :\n      âˆƒ s âˆˆ Î¼.cofinite, MeasurableSet s âˆ§\n        (âˆ€ i, eLpNorm (s.indicator (f i)) p Î¼ â‰¤ Î·) âˆ§\n        (âˆ€ i, eLpNorm (s.indicator (g i)) p Î¼ â‰¤ Î·) :=\n    ((hf.eventually_cofinite_indicator hÎ·_pos.ne').and\n      (hg.eventually_cofinite_indicator hÎ·_pos.ne')).exists_measurable_mem_of_smallSets\n  refine âŸ¨sá¶œ, ne_of_lt hÎ¼s, fun i â†¦ ?_âŸ©\n  have Î·_cast : â†‘Î·.toNNReal = Î· := coe_toNNReal hÎ·_top\n  calc\n    eLpNorm (indicator sá¶œá¶œ (f i + g i)) p Î¼\n      = eLpNorm (indicator s (f i) + indicator s (g i)) p Î¼ := by rw [compl_compl, indicator_add']\n    _ â‰¤ Îµ := le_of_lt <|\n      hÎ· _ _ ((hf_meas i).indicator hsm) ((hg_meas i).indicator hsm)\n        (Î·_cast â–¸ hfs i) (Î·_cast â–¸ hgs i)\n\n"}
{"name":"MeasureTheory.UnifTight.neg","module":"Mathlib.MeasureTheory.Function.UnifTight","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ¹ : Type u_3\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : NormedAddCommGroup Î²\nf : Î¹ â†’ Î± â†’ Î²\np : ENNReal\nhf : MeasureTheory.UnifTight f p Î¼\nâŠ¢ MeasureTheory.UnifTight (Neg.neg f) p Î¼","decl":"protected theorem neg (hf : UnifTight f p Î¼) : UnifTight (-f) p Î¼ := by\n  simp_rw [UnifTight, Pi.neg_apply, Set.indicator_neg', eLpNorm_neg]\n  exact hf\n\n"}
{"name":"MeasureTheory.UnifTight.sub","module":"Mathlib.MeasureTheory.Function.UnifTight","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ¹ : Type u_3\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : NormedAddCommGroup Î²\nf g : Î¹ â†’ Î± â†’ Î²\np : ENNReal\nhf : MeasureTheory.UnifTight f p Î¼\nhg : MeasureTheory.UnifTight g p Î¼\nhf_meas : âˆ€ (i : Î¹), MeasureTheory.AEStronglyMeasurable (f i) Î¼\nhg_meas : âˆ€ (i : Î¹), MeasureTheory.AEStronglyMeasurable (g i) Î¼\nâŠ¢ MeasureTheory.UnifTight (HSub.hSub f g) p Î¼","decl":"protected theorem sub (hf : UnifTight f p Î¼) (hg : UnifTight g p Î¼)\n    (hf_meas : âˆ€ i, AEStronglyMeasurable (f i) Î¼) (hg_meas : âˆ€ i, AEStronglyMeasurable (g i) Î¼) :\n    UnifTight (f - g) p Î¼ := by\n  rw [sub_eq_add_neg]\n  exact hf.add hg.neg hf_meas fun i => (hg_meas i).neg\n\n"}
{"name":"MeasureTheory.UnifTight.aeeq","module":"Mathlib.MeasureTheory.Function.UnifTight","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ¹ : Type u_3\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : NormedAddCommGroup Î²\nf g : Î¹ â†’ Î± â†’ Î²\np : ENNReal\nhf : MeasureTheory.UnifTight f p Î¼\nhfg : âˆ€ (n : Î¹), (MeasureTheory.ae Î¼).EventuallyEq (f n) (g n)\nâŠ¢ MeasureTheory.UnifTight g p Î¼","decl":"protected theorem aeeq (hf : UnifTight f p Î¼) (hfg : âˆ€ n, f n =áµ[Î¼] g n) :\n    UnifTight g p Î¼ := by\n  intro Îµ hÎµ\n  obtain âŸ¨s, hÎ¼s, hfÎµâŸ© := hf hÎµ\n  refine âŸ¨s, hÎ¼s, fun n => (le_of_eq <| eLpNorm_congr_ae ?_).trans (hfÎµ n)âŸ©\n  filter_upwards [hfg n] with x hx\n  simp only [indicator, mem_compl_iff, ite_not, hx]\n\n"}
{"name":"MeasureTheory.unifTight_congr_ae","module":"Mathlib.MeasureTheory.Function.UnifTight","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ¹ : Type u_3\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : NormedAddCommGroup Î²\nf : Î¹ â†’ Î± â†’ Î²\np : ENNReal\ng : Î¹ â†’ Î± â†’ Î²\nhfg : âˆ€ (n : Î¹), (MeasureTheory.ae Î¼).EventuallyEq (f n) (g n)\nâŠ¢ Iff (MeasureTheory.UnifTight f p Î¼) (MeasureTheory.UnifTight g p Î¼)","decl":"/-- If two functions agree a.e., then one is tight iff the other is tight. -/\ntheorem unifTight_congr_ae {g : Î¹ â†’ Î± â†’ Î²} (hfg : âˆ€ n, f n =áµ[Î¼] g n) :\n    UnifTight f p Î¼ â†” UnifTight g p Î¼ :=\n  âŸ¨fun h => h.aeeq hfg, fun h => h.aeeq fun i => (hfg i).symmâŸ©\n\n"}
{"name":"MeasureTheory.unifTight_const","module":"Mathlib.MeasureTheory.Function.UnifTight","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ¹ : Type u_3\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : NormedAddCommGroup Î²\np : ENNReal\ng : Î± â†’ Î²\nhp_ne_top : Ne p Top.top\nhg : MeasureTheory.Memâ„’p g p Î¼\nâŠ¢ MeasureTheory.UnifTight (fun x => g) p Î¼","decl":"/-- A constant sequence is tight. -/\ntheorem unifTight_const {g : Î± â†’ Î²} (hp_ne_top : p â‰  âˆ) (hg : Memâ„’p g p Î¼) :\n    UnifTight (fun _ : Î¹ => g) p Î¼ := by\n  intro Îµ hÎµ\n  by_cases hÎµ_top : Îµ = âˆ\n  Â· exact âŸ¨âˆ…, (by measurability), fun _ => hÎµ_top.symm â–¸ le_topâŸ©\n  obtain âŸ¨s, _, hÎ¼s, hgÎµâŸ© := hg.exists_eLpNorm_indicator_compl_lt hp_ne_top (coe_ne_zero.mpr hÎµ.ne')\n  exact âŸ¨s, ne_of_lt hÎ¼s, fun _ => hgÎµ.leâŸ©\n\n"}
{"name":"MeasureTheory.unifTight_of_subsingleton","module":"Mathlib.MeasureTheory.Function.UnifTight","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ¹ : Type u_3\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœÂ¹ : NormedAddCommGroup Î²\np : ENNReal\ninstâœ : Subsingleton Î¹\nhp_top : Ne p Top.top\nf : Î¹ â†’ Î± â†’ Î²\nhf : âˆ€ (i : Î¹), MeasureTheory.Memâ„’p (f i) p Î¼\nâŠ¢ MeasureTheory.UnifTight f p Î¼","decl":"/-- A single function is tight. -/\ntheorem unifTight_of_subsingleton [Subsingleton Î¹] (hp_top : p â‰  âˆ)\n    {f : Î¹ â†’ Î± â†’ Î²} (hf : âˆ€ i, Memâ„’p (f i) p Î¼) : UnifTight f p Î¼ := fun Îµ hÎµ â†¦ by\n  by_cases hÎµ_top : Îµ = âˆ\n  Â· exact âŸ¨âˆ…, by measurability, fun _ => hÎµ_top.symm â–¸ le_topâŸ©\n  by_cases hÎ¹ : Nonempty Î¹\n  case neg => exact âŸ¨âˆ…, (by measurability), fun i => False.elim <| hÎ¹ <| Nonempty.intro iâŸ©\n  cases' hÎ¹ with i\n  obtain âŸ¨s, _, hÎ¼s, hfÎµâŸ© := (hf i).exists_eLpNorm_indicator_compl_lt hp_top (coe_ne_zero.2 hÎµ.ne')\n  refine âŸ¨s, ne_of_lt hÎ¼s, fun j => ?_âŸ©\n  convert hfÎµ.le\n\n"}
{"name":"MeasureTheory.unifTight_finite","module":"Mathlib.MeasureTheory.Function.UnifTight","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ¹ : Type u_3\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœÂ¹ : NormedAddCommGroup Î²\np : ENNReal\ninstâœ : Finite Î¹\nhp_top : Ne p Top.top\nf : Î¹ â†’ Î± â†’ Î²\nhf : âˆ€ (i : Î¹), MeasureTheory.Memâ„’p (f i) p Î¼\nâŠ¢ MeasureTheory.UnifTight f p Î¼","decl":"/-- A finite sequence of Lp functions is uniformly tight. -/\ntheorem unifTight_finite [Finite Î¹] (hp_top : p â‰  âˆ) {f : Î¹ â†’ Î± â†’ Î²}\n    (hf : âˆ€ i, Memâ„’p (f i) p Î¼) : UnifTight f p Î¼ := fun Îµ hÎµ â†¦ by\n  obtain âŸ¨n, hnâŸ© := Finite.exists_equiv_fin Î¹\n  set g : Fin n â†’ Î± â†’ Î² := f âˆ˜ hn.some.symm\n  have hg : âˆ€ i, Memâ„’p (g i) p Î¼ := fun _ => hf _\n  obtain âŸ¨s, hÎ¼s, hfÎµâŸ© := unifTight_fin hp_top hg hÎµ\n  refine âŸ¨s, hÎ¼s, fun i => ?_âŸ©\n  simpa only [g, Function.comp_apply, Equiv.symm_apply_apply] using hfÎµ (hn.some i)\n\n"}
{"name":"MeasureTheory.tendsto_Lp_of_tendsto_ae","module":"Mathlib.MeasureTheory.Function.UnifTight","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nm : MeasurableSpace Î±\ninstâœ : NormedAddCommGroup Î²\nÎ¼ : MeasureTheory.Measure Î±\np : ENNReal\nhp : LE.le 1 p\nhp' : Ne p Top.top\nf : Nat â†’ Î± â†’ Î²\ng : Î± â†’ Î²\nhaef : âˆ€ (n : Nat), MeasureTheory.AEStronglyMeasurable (f n) Î¼\nhg' : MeasureTheory.Memâ„’p g p Î¼\nhui : MeasureTheory.UnifIntegrable f p Î¼\nhut : MeasureTheory.UnifTight f p Î¼\nhfg : Filter.Eventually (fun x => Filter.Tendsto (fun n => f n x) Filter.atTop (nhds (g x))) (MeasureTheory.ae Î¼)\nâŠ¢ Filter.Tendsto (fun n => MeasureTheory.eLpNorm (HSub.hSub (f n) g) p Î¼) Filter.atTop (nhds 0)","decl":"/-- Forward direction of Vitali's convergnece theorem, with a.e. instead of InMeasure convergence.-/\ntheorem tendsto_Lp_of_tendsto_ae (hp : 1 â‰¤ p) (hp' : p â‰  âˆ)\n    {f : â„• â†’ Î± â†’ Î²} {g : Î± â†’ Î²} (haef : âˆ€ n, AEStronglyMeasurable (f n) Î¼)\n    (hg' : Memâ„’p g p Î¼) (hui : UnifIntegrable f p Î¼) (hut : UnifTight f p Î¼)\n    (hfg : âˆ€áµ x âˆ‚Î¼, Tendsto (fun n => f n x) atTop (ğ“ (g x))) :\n    Tendsto (fun n => eLpNorm (f n - g) p Î¼) atTop (ğ“ 0) := by\n  -- come up with an a.e. equal strongly measurable replacement `f` for `g`\n  have hf := fun n => (haef n).stronglyMeasurable_mk\n  have hff' := fun n => (haef n).ae_eq_mk (Î¼ := Î¼)\n  have hui' := hui.ae_eq hff'\n  have hut' := hut.aeeq hff'\n  have hg := hg'.aestronglyMeasurable.stronglyMeasurable_mk\n  have hgg' := hg'.aestronglyMeasurable.ae_eq_mk (Î¼ := Î¼)\n  have hg'' := hg'.ae_eq hgg'\n  have haefg' := ae_tendsto_ae_congr hff' hgg' hfg\n  set f' := fun n => (haef n).mk (Î¼ := Î¼)\n  set g' := hg'.aestronglyMeasurable.mk (Î¼ := Î¼)\n  have haefg (n : â„•) : f n - g =áµ[Î¼] f' n - g' := (hff' n).sub hgg'\n  have hsnfg (n : â„•) := eLpNorm_congr_ae (p := p) (haefg n)\n  apply Filter.Tendsto.congr (fun n => (hsnfg n).symm)\n  exact tendsto_Lp_of_tendsto_ae_of_meas hp hp' hf hg hg'' hui' hut' haefg'\n\n"}
{"name":"MeasureTheory.tendsto_Lp_of_tendstoInMeasure","module":"Mathlib.MeasureTheory.Function.UnifTight","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nm : MeasurableSpace Î±\ninstâœ : NormedAddCommGroup Î²\nÎ¼ : MeasureTheory.Measure Î±\np : ENNReal\nf : Nat â†’ Î± â†’ Î²\ng : Î± â†’ Î²\nhp : LE.le 1 p\nhp' : Ne p Top.top\nhf : âˆ€ (n : Nat), MeasureTheory.AEStronglyMeasurable (f n) Î¼\nhg : MeasureTheory.Memâ„’p g p Î¼\nhui : MeasureTheory.UnifIntegrable f p Î¼\nhut : MeasureTheory.UnifTight f p Î¼\nhfg : MeasureTheory.TendstoInMeasure Î¼ f Filter.atTop g\nâŠ¢ Filter.Tendsto (fun n => MeasureTheory.eLpNorm (HSub.hSub (f n) g) p Î¼) Filter.atTop (nhds 0)","decl":"/-- Forward direction of Vitali's convergence theorem:\nif `f` is a sequence of uniformly integrable, uniformly tight functions that converge in\nmeasure to some function `g` in a finite measure space, then `f` converge in Lp to `g`. -/\ntheorem tendsto_Lp_of_tendstoInMeasure (hp : 1 â‰¤ p) (hp' : p â‰  âˆ)\n    (hf : âˆ€ n, AEStronglyMeasurable (f n) Î¼) (hg : Memâ„’p g p Î¼)\n    (hui : UnifIntegrable f p Î¼) (hut : UnifTight f p Î¼)\n    (hfg : TendstoInMeasure Î¼ f atTop g) : Tendsto (fun n â†¦ eLpNorm (f n - g) p Î¼) atTop (ğ“ 0) := by\n  refine tendsto_of_subseq_tendsto fun ns hns => ?_\n  obtain âŸ¨ms, _, hms'âŸ© := TendstoInMeasure.exists_seq_tendsto_ae fun Îµ hÎµ => (hfg Îµ hÎµ).comp hns\n  exact âŸ¨ms,\n    tendsto_Lp_of_tendsto_ae hp hp' (fun _ => hf _) hg\n      (fun Îµ hÎµ => -- `UnifIntegrable` on a subsequence\n        let âŸ¨Î´, hÎ´, hÎ´'âŸ© := hui hÎµ\n        âŸ¨Î´, hÎ´, fun i s hs hÎ¼s => hÎ´' _ s hs hÎ¼sâŸ©)\n      (fun Îµ hÎµ => -- `UnifTight` on a subsequence\n        let âŸ¨s, hÎ¼s, hfÎµâŸ© := hut hÎµ\n        âŸ¨s, hÎ¼s, fun i => hfÎµ _âŸ©)\n      hms'âŸ©\n\n"}
{"name":"MeasureTheory.tendstoInMeasure_iff_tendsto_Lp","module":"Mathlib.MeasureTheory.Function.UnifTight","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nm : MeasurableSpace Î±\ninstâœ : NormedAddCommGroup Î²\nÎ¼ : MeasureTheory.Measure Î±\np : ENNReal\nf : Nat â†’ Î± â†’ Î²\ng : Î± â†’ Î²\nhp : LE.le 1 p\nhp' : Ne p Top.top\nhf : âˆ€ (n : Nat), MeasureTheory.Memâ„’p (f n) p Î¼\nhg : MeasureTheory.Memâ„’p g p Î¼\nâŠ¢ Iff (And (MeasureTheory.TendstoInMeasure Î¼ f Filter.atTop g) (And (MeasureTheory.UnifIntegrable f p Î¼) (MeasureTheory.UnifTight f p Î¼))) (Filter.Tendsto (fun n => MeasureTheory.eLpNorm (HSub.hSub (f n) g) p Î¼) Filter.atTop (nhds 0))","decl":"/-- **Vitali's convergence theorem** (non-finite measure version).\n\nA sequence of functions `f` converges to `g` in Lp\nif and only if it is uniformly integrable, uniformly tight and converges to `g` in measure. -/\ntheorem tendstoInMeasure_iff_tendsto_Lp (hp : 1 â‰¤ p) (hp' : p â‰  âˆ)\n    (hf : âˆ€ n, Memâ„’p (f n) p Î¼) (hg : Memâ„’p g p Î¼) :\n    TendstoInMeasure Î¼ f atTop g âˆ§ UnifIntegrable f p Î¼ âˆ§ UnifTight f p Î¼\n      â†” Tendsto (fun n => eLpNorm (f n - g) p Î¼) atTop (ğ“ 0) where\n  mp h := tendsto_Lp_of_tendstoInMeasure hp hp' (fun n => (hf n).1) hg h.2.1 h.2.2 h.1\n  mpr h := âŸ¨tendstoInMeasure_of_tendsto_eLpNorm (lt_of_lt_of_le zero_lt_one hp).ne'\n        (fun n => (hf n).aestronglyMeasurable) hg.aestronglyMeasurable h,\n      unifIntegrable_of_tendsto_Lp hp hp' hf hg h,\n      unifTight_of_tendsto_Lp hp' hf hg hâŸ©\n\n"}
