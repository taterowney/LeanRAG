{"name":"MeasureTheory.unifTight_iff_ennreal","module":"Mathlib.MeasureTheory.Function.UnifTight","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Type u_3\ninst✝ : NormedAddCommGroup β\nx✝ : MeasurableSpace α\nf : ι → α → β\np : ENNReal\nμ : MeasureTheory.Measure α\n⊢ Iff (MeasureTheory.UnifTight f p μ) (∀ ⦃ε : ENNReal⦄, LT.lt 0 ε → Exists fun s => And (Ne (μ s) Top.top) (∀ (i : ι), LE.le (MeasureTheory.eLpNorm ((HasCompl.compl s).indicator (f i)) p μ) ε))","decl":"theorem unifTight_iff_ennreal {_ : MeasurableSpace α} (f : ι → α → β) (p : ℝ≥0∞) (μ : Measure α) :\n    UnifTight f p μ ↔ ∀ ⦃ε : ℝ≥0∞⦄, 0 < ε → ∃ s : Set α,\n      μ s ≠ ∞ ∧ ∀ i, eLpNorm (sᶜ.indicator (f i)) p μ ≤ ε := by\n  simp only [ENNReal.forall_ennreal, ENNReal.coe_pos]\n  refine (and_iff_left ?_).symm\n  simp only [zero_lt_top, le_top, implies_true, and_true, true_implies]\n  use ∅; simpa only [measure_empty] using zero_ne_top\n\n"}
{"name":"MeasureTheory.unifTight_iff_real","module":"Mathlib.MeasureTheory.Function.UnifTight","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Type u_3\ninst✝ : NormedAddCommGroup β\nx✝ : MeasurableSpace α\nf : ι → α → β\np : ENNReal\nμ : MeasureTheory.Measure α\n⊢ Iff (MeasureTheory.UnifTight f p μ) (∀ ⦃ε : Real⦄, LT.lt 0 ε → Exists fun s => And (Ne (μ s) Top.top) (∀ (i : ι), LE.le (MeasureTheory.eLpNorm ((HasCompl.compl s).indicator (f i)) p μ) (ENNReal.ofReal ε)))","decl":"theorem unifTight_iff_real {_ : MeasurableSpace α} (f : ι → α → β) (p : ℝ≥0∞) (μ : Measure α) :\n    UnifTight f p μ ↔ ∀ ⦃ε : ℝ⦄, 0 < ε → ∃ s : Set α,\n      μ s ≠ ∞ ∧ ∀ i, eLpNorm (sᶜ.indicator (f i)) p μ ≤ .ofReal ε := by\n  refine ⟨fun hut rε hrε ↦ hut (Real.toNNReal_pos.mpr hrε), fun hut ε hε ↦ ?_⟩\n  obtain ⟨s, hμs, hfε⟩ := hut hε\n  use s, hμs; intro i\n  exact (hfε i).trans_eq (ofReal_coe_nnreal (p := ε))\n\n"}
{"name":"MeasureTheory.UnifTight.eventually_cofinite_indicator","module":"Mathlib.MeasureTheory.Function.UnifTight","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Type u_3\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup β\nf : ι → α → β\np : ENNReal\nhf : MeasureTheory.UnifTight f p μ\nε : ENNReal\nhε : Ne ε 0\n⊢ Filter.Eventually (fun s => ∀ (i : ι), LE.le (MeasureTheory.eLpNorm (s.indicator (f i)) p μ) ε) μ.cofinite.smallSets","decl":"theorem eventually_cofinite_indicator (hf : UnifTight f p μ) {ε : ℝ≥0∞} (hε : ε ≠ 0) :\n    ∀ᶠ s in μ.cofinite.smallSets, ∀ i, eLpNorm (s.indicator (f i)) p μ ≤ ε := by\n  by_cases hε_top : ε = ∞\n  · subst hε_top; simp\n  rcases hf (pos_iff_ne_zero.2 (toNNReal_ne_zero.mpr ⟨hε,hε_top⟩)) with ⟨s, hμs, hfs⟩\n  refine (eventually_smallSets' ?_).2 ⟨sᶜ, ?_, fun i ↦ (coe_toNNReal hε_top) ▸ hfs i⟩\n  · intro s t hst ht i\n    exact (eLpNorm_mono <| norm_indicator_le_of_subset hst _).trans (ht i)\n  · rwa [Measure.compl_mem_cofinite, lt_top_iff_ne_top]\n\n"}
{"name":"MeasureTheory.UnifTight.exists_measurableSet_indicator","module":"Mathlib.MeasureTheory.Function.UnifTight","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Type u_3\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup β\nf : ι → α → β\np : ENNReal\nhf : MeasureTheory.UnifTight f p μ\nε : ENNReal\nhε : Ne ε 0\n⊢ Exists fun s => And (MeasurableSet s) (And (LT.lt (μ s) Top.top) (∀ (i : ι), LE.le (MeasureTheory.eLpNorm ((HasCompl.compl s).indicator (f i)) p μ) ε))","decl":"protected theorem exists_measurableSet_indicator (hf : UnifTight f p μ) {ε : ℝ≥0∞} (hε : ε ≠ 0) :\n    ∃ s, MeasurableSet s ∧ μ s < ∞ ∧ ∀ i, eLpNorm (sᶜ.indicator (f i)) p μ ≤ ε :=\n  let ⟨s, hμs, hsm, hfs⟩ := (hf.eventually_cofinite_indicator hε).exists_measurable_mem_of_smallSets\n  ⟨sᶜ, hsm.compl, hμs, by rwa [compl_compl s]⟩\n\n"}
{"name":"MeasureTheory.UnifTight.add","module":"Mathlib.MeasureTheory.Function.UnifTight","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Type u_3\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup β\nf g : ι → α → β\np : ENNReal\nhf : MeasureTheory.UnifTight f p μ\nhg : MeasureTheory.UnifTight g p μ\nhf_meas : ∀ (i : ι), MeasureTheory.AEStronglyMeasurable (f i) μ\nhg_meas : ∀ (i : ι), MeasureTheory.AEStronglyMeasurable (g i) μ\n⊢ MeasureTheory.UnifTight (HAdd.hAdd f g) p μ","decl":"protected theorem add (hf : UnifTight f p μ) (hg : UnifTight g p μ)\n    (hf_meas : ∀ i, AEStronglyMeasurable (f i) μ) (hg_meas : ∀ i, AEStronglyMeasurable (g i) μ) :\n    UnifTight (f + g) p μ := fun ε hε ↦ by\n  rcases exists_Lp_half β μ p (coe_ne_zero.mpr hε.ne') with ⟨η, hη_pos, hη⟩\n  by_cases hη_top : η = ∞\n  · replace hη := hη_top ▸ hη\n    refine ⟨∅, (by measurability), fun i ↦ ?_⟩\n    simp only [compl_empty, indicator_univ, Pi.add_apply]\n    exact (hη (f i) (g i) (hf_meas i) (hg_meas i) le_top le_top).le\n  obtain ⟨s, hμs, hsm, hfs, hgs⟩ :\n      ∃ s ∈ μ.cofinite, MeasurableSet s ∧\n        (∀ i, eLpNorm (s.indicator (f i)) p μ ≤ η) ∧\n        (∀ i, eLpNorm (s.indicator (g i)) p μ ≤ η) :=\n    ((hf.eventually_cofinite_indicator hη_pos.ne').and\n      (hg.eventually_cofinite_indicator hη_pos.ne')).exists_measurable_mem_of_smallSets\n  refine ⟨sᶜ, ne_of_lt hμs, fun i ↦ ?_⟩\n  have η_cast : ↑η.toNNReal = η := coe_toNNReal hη_top\n  calc\n    eLpNorm (indicator sᶜᶜ (f i + g i)) p μ\n      = eLpNorm (indicator s (f i) + indicator s (g i)) p μ := by rw [compl_compl, indicator_add']\n    _ ≤ ε := le_of_lt <|\n      hη _ _ ((hf_meas i).indicator hsm) ((hg_meas i).indicator hsm)\n        (η_cast ▸ hfs i) (η_cast ▸ hgs i)\n\n"}
{"name":"MeasureTheory.UnifTight.neg","module":"Mathlib.MeasureTheory.Function.UnifTight","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Type u_3\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup β\nf : ι → α → β\np : ENNReal\nhf : MeasureTheory.UnifTight f p μ\n⊢ MeasureTheory.UnifTight (Neg.neg f) p μ","decl":"protected theorem neg (hf : UnifTight f p μ) : UnifTight (-f) p μ := by\n  simp_rw [UnifTight, Pi.neg_apply, Set.indicator_neg', eLpNorm_neg]\n  exact hf\n\n"}
{"name":"MeasureTheory.UnifTight.sub","module":"Mathlib.MeasureTheory.Function.UnifTight","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Type u_3\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup β\nf g : ι → α → β\np : ENNReal\nhf : MeasureTheory.UnifTight f p μ\nhg : MeasureTheory.UnifTight g p μ\nhf_meas : ∀ (i : ι), MeasureTheory.AEStronglyMeasurable (f i) μ\nhg_meas : ∀ (i : ι), MeasureTheory.AEStronglyMeasurable (g i) μ\n⊢ MeasureTheory.UnifTight (HSub.hSub f g) p μ","decl":"protected theorem sub (hf : UnifTight f p μ) (hg : UnifTight g p μ)\n    (hf_meas : ∀ i, AEStronglyMeasurable (f i) μ) (hg_meas : ∀ i, AEStronglyMeasurable (g i) μ) :\n    UnifTight (f - g) p μ := by\n  rw [sub_eq_add_neg]\n  exact hf.add hg.neg hf_meas fun i => (hg_meas i).neg\n\n"}
{"name":"MeasureTheory.UnifTight.aeeq","module":"Mathlib.MeasureTheory.Function.UnifTight","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Type u_3\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup β\nf g : ι → α → β\np : ENNReal\nhf : MeasureTheory.UnifTight f p μ\nhfg : ∀ (n : ι), (MeasureTheory.ae μ).EventuallyEq (f n) (g n)\n⊢ MeasureTheory.UnifTight g p μ","decl":"protected theorem aeeq (hf : UnifTight f p μ) (hfg : ∀ n, f n =ᵐ[μ] g n) :\n    UnifTight g p μ := by\n  intro ε hε\n  obtain ⟨s, hμs, hfε⟩ := hf hε\n  refine ⟨s, hμs, fun n => (le_of_eq <| eLpNorm_congr_ae ?_).trans (hfε n)⟩\n  filter_upwards [hfg n] with x hx\n  simp only [indicator, mem_compl_iff, ite_not, hx]\n\n"}
{"name":"MeasureTheory.unifTight_congr_ae","module":"Mathlib.MeasureTheory.Function.UnifTight","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Type u_3\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup β\nf : ι → α → β\np : ENNReal\ng : ι → α → β\nhfg : ∀ (n : ι), (MeasureTheory.ae μ).EventuallyEq (f n) (g n)\n⊢ Iff (MeasureTheory.UnifTight f p μ) (MeasureTheory.UnifTight g p μ)","decl":"/-- If two functions agree a.e., then one is tight iff the other is tight. -/\ntheorem unifTight_congr_ae {g : ι → α → β} (hfg : ∀ n, f n =ᵐ[μ] g n) :\n    UnifTight f p μ ↔ UnifTight g p μ :=\n  ⟨fun h => h.aeeq hfg, fun h => h.aeeq fun i => (hfg i).symm⟩\n\n"}
{"name":"MeasureTheory.unifTight_const","module":"Mathlib.MeasureTheory.Function.UnifTight","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Type u_3\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup β\np : ENNReal\ng : α → β\nhp_ne_top : Ne p Top.top\nhg : MeasureTheory.Memℒp g p μ\n⊢ MeasureTheory.UnifTight (fun x => g) p μ","decl":"/-- A constant sequence is tight. -/\ntheorem unifTight_const {g : α → β} (hp_ne_top : p ≠ ∞) (hg : Memℒp g p μ) :\n    UnifTight (fun _ : ι => g) p μ := by\n  intro ε hε\n  by_cases hε_top : ε = ∞\n  · exact ⟨∅, (by measurability), fun _ => hε_top.symm ▸ le_top⟩\n  obtain ⟨s, _, hμs, hgε⟩ := hg.exists_eLpNorm_indicator_compl_lt hp_ne_top (coe_ne_zero.mpr hε.ne')\n  exact ⟨s, ne_of_lt hμs, fun _ => hgε.le⟩\n\n"}
{"name":"MeasureTheory.unifTight_of_subsingleton","module":"Mathlib.MeasureTheory.Function.UnifTight","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Type u_3\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝¹ : NormedAddCommGroup β\np : ENNReal\ninst✝ : Subsingleton ι\nhp_top : Ne p Top.top\nf : ι → α → β\nhf : ∀ (i : ι), MeasureTheory.Memℒp (f i) p μ\n⊢ MeasureTheory.UnifTight f p μ","decl":"/-- A single function is tight. -/\ntheorem unifTight_of_subsingleton [Subsingleton ι] (hp_top : p ≠ ∞)\n    {f : ι → α → β} (hf : ∀ i, Memℒp (f i) p μ) : UnifTight f p μ := fun ε hε ↦ by\n  by_cases hε_top : ε = ∞\n  · exact ⟨∅, by measurability, fun _ => hε_top.symm ▸ le_top⟩\n  by_cases hι : Nonempty ι\n  case neg => exact ⟨∅, (by measurability), fun i => False.elim <| hι <| Nonempty.intro i⟩\n  cases' hι with i\n  obtain ⟨s, _, hμs, hfε⟩ := (hf i).exists_eLpNorm_indicator_compl_lt hp_top (coe_ne_zero.2 hε.ne')\n  refine ⟨s, ne_of_lt hμs, fun j => ?_⟩\n  convert hfε.le\n\n"}
{"name":"MeasureTheory.unifTight_finite","module":"Mathlib.MeasureTheory.Function.UnifTight","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Type u_3\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝¹ : NormedAddCommGroup β\np : ENNReal\ninst✝ : Finite ι\nhp_top : Ne p Top.top\nf : ι → α → β\nhf : ∀ (i : ι), MeasureTheory.Memℒp (f i) p μ\n⊢ MeasureTheory.UnifTight f p μ","decl":"/-- A finite sequence of Lp functions is uniformly tight. -/\ntheorem unifTight_finite [Finite ι] (hp_top : p ≠ ∞) {f : ι → α → β}\n    (hf : ∀ i, Memℒp (f i) p μ) : UnifTight f p μ := fun ε hε ↦ by\n  obtain ⟨n, hn⟩ := Finite.exists_equiv_fin ι\n  set g : Fin n → α → β := f ∘ hn.some.symm\n  have hg : ∀ i, Memℒp (g i) p μ := fun _ => hf _\n  obtain ⟨s, hμs, hfε⟩ := unifTight_fin hp_top hg hε\n  refine ⟨s, hμs, fun i => ?_⟩\n  simpa only [g, Function.comp_apply, Equiv.symm_apply_apply] using hfε (hn.some i)\n\n"}
{"name":"MeasureTheory.tendsto_Lp_of_tendsto_ae","module":"Mathlib.MeasureTheory.Function.UnifTight","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\ninst✝ : NormedAddCommGroup β\nμ : MeasureTheory.Measure α\np : ENNReal\nhp : LE.le 1 p\nhp' : Ne p Top.top\nf : Nat → α → β\ng : α → β\nhaef : ∀ (n : Nat), MeasureTheory.AEStronglyMeasurable (f n) μ\nhg' : MeasureTheory.Memℒp g p μ\nhui : MeasureTheory.UnifIntegrable f p μ\nhut : MeasureTheory.UnifTight f p μ\nhfg : Filter.Eventually (fun x => Filter.Tendsto (fun n => f n x) Filter.atTop (nhds (g x))) (MeasureTheory.ae μ)\n⊢ Filter.Tendsto (fun n => MeasureTheory.eLpNorm (HSub.hSub (f n) g) p μ) Filter.atTop (nhds 0)","decl":"/-- Forward direction of Vitali's convergnece theorem, with a.e. instead of InMeasure convergence.-/\ntheorem tendsto_Lp_of_tendsto_ae (hp : 1 ≤ p) (hp' : p ≠ ∞)\n    {f : ℕ → α → β} {g : α → β} (haef : ∀ n, AEStronglyMeasurable (f n) μ)\n    (hg' : Memℒp g p μ) (hui : UnifIntegrable f p μ) (hut : UnifTight f p μ)\n    (hfg : ∀ᵐ x ∂μ, Tendsto (fun n => f n x) atTop (𝓝 (g x))) :\n    Tendsto (fun n => eLpNorm (f n - g) p μ) atTop (𝓝 0) := by\n  -- come up with an a.e. equal strongly measurable replacement `f` for `g`\n  have hf := fun n => (haef n).stronglyMeasurable_mk\n  have hff' := fun n => (haef n).ae_eq_mk (μ := μ)\n  have hui' := hui.ae_eq hff'\n  have hut' := hut.aeeq hff'\n  have hg := hg'.aestronglyMeasurable.stronglyMeasurable_mk\n  have hgg' := hg'.aestronglyMeasurable.ae_eq_mk (μ := μ)\n  have hg'' := hg'.ae_eq hgg'\n  have haefg' := ae_tendsto_ae_congr hff' hgg' hfg\n  set f' := fun n => (haef n).mk (μ := μ)\n  set g' := hg'.aestronglyMeasurable.mk (μ := μ)\n  have haefg (n : ℕ) : f n - g =ᵐ[μ] f' n - g' := (hff' n).sub hgg'\n  have hsnfg (n : ℕ) := eLpNorm_congr_ae (p := p) (haefg n)\n  apply Filter.Tendsto.congr (fun n => (hsnfg n).symm)\n  exact tendsto_Lp_of_tendsto_ae_of_meas hp hp' hf hg hg'' hui' hut' haefg'\n\n"}
{"name":"MeasureTheory.tendsto_Lp_of_tendstoInMeasure","module":"Mathlib.MeasureTheory.Function.UnifTight","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\ninst✝ : NormedAddCommGroup β\nμ : MeasureTheory.Measure α\np : ENNReal\nf : Nat → α → β\ng : α → β\nhp : LE.le 1 p\nhp' : Ne p Top.top\nhf : ∀ (n : Nat), MeasureTheory.AEStronglyMeasurable (f n) μ\nhg : MeasureTheory.Memℒp g p μ\nhui : MeasureTheory.UnifIntegrable f p μ\nhut : MeasureTheory.UnifTight f p μ\nhfg : MeasureTheory.TendstoInMeasure μ f Filter.atTop g\n⊢ Filter.Tendsto (fun n => MeasureTheory.eLpNorm (HSub.hSub (f n) g) p μ) Filter.atTop (nhds 0)","decl":"/-- Forward direction of Vitali's convergence theorem:\nif `f` is a sequence of uniformly integrable, uniformly tight functions that converge in\nmeasure to some function `g` in a finite measure space, then `f` converge in Lp to `g`. -/\ntheorem tendsto_Lp_of_tendstoInMeasure (hp : 1 ≤ p) (hp' : p ≠ ∞)\n    (hf : ∀ n, AEStronglyMeasurable (f n) μ) (hg : Memℒp g p μ)\n    (hui : UnifIntegrable f p μ) (hut : UnifTight f p μ)\n    (hfg : TendstoInMeasure μ f atTop g) : Tendsto (fun n ↦ eLpNorm (f n - g) p μ) atTop (𝓝 0) := by\n  refine tendsto_of_subseq_tendsto fun ns hns => ?_\n  obtain ⟨ms, _, hms'⟩ := TendstoInMeasure.exists_seq_tendsto_ae fun ε hε => (hfg ε hε).comp hns\n  exact ⟨ms,\n    tendsto_Lp_of_tendsto_ae hp hp' (fun _ => hf _) hg\n      (fun ε hε => -- `UnifIntegrable` on a subsequence\n        let ⟨δ, hδ, hδ'⟩ := hui hε\n        ⟨δ, hδ, fun i s hs hμs => hδ' _ s hs hμs⟩)\n      (fun ε hε => -- `UnifTight` on a subsequence\n        let ⟨s, hμs, hfε⟩ := hut hε\n        ⟨s, hμs, fun i => hfε _⟩)\n      hms'⟩\n\n"}
{"name":"MeasureTheory.tendstoInMeasure_iff_tendsto_Lp","module":"Mathlib.MeasureTheory.Function.UnifTight","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\ninst✝ : NormedAddCommGroup β\nμ : MeasureTheory.Measure α\np : ENNReal\nf : Nat → α → β\ng : α → β\nhp : LE.le 1 p\nhp' : Ne p Top.top\nhf : ∀ (n : Nat), MeasureTheory.Memℒp (f n) p μ\nhg : MeasureTheory.Memℒp g p μ\n⊢ Iff (And (MeasureTheory.TendstoInMeasure μ f Filter.atTop g) (And (MeasureTheory.UnifIntegrable f p μ) (MeasureTheory.UnifTight f p μ))) (Filter.Tendsto (fun n => MeasureTheory.eLpNorm (HSub.hSub (f n) g) p μ) Filter.atTop (nhds 0))","decl":"/-- **Vitali's convergence theorem** (non-finite measure version).\n\nA sequence of functions `f` converges to `g` in Lp\nif and only if it is uniformly integrable, uniformly tight and converges to `g` in measure. -/\ntheorem tendstoInMeasure_iff_tendsto_Lp (hp : 1 ≤ p) (hp' : p ≠ ∞)\n    (hf : ∀ n, Memℒp (f n) p μ) (hg : Memℒp g p μ) :\n    TendstoInMeasure μ f atTop g ∧ UnifIntegrable f p μ ∧ UnifTight f p μ\n      ↔ Tendsto (fun n => eLpNorm (f n - g) p μ) atTop (𝓝 0) where\n  mp h := tendsto_Lp_of_tendstoInMeasure hp hp' (fun n => (hf n).1) hg h.2.1 h.2.2 h.1\n  mpr h := ⟨tendstoInMeasure_of_tendsto_eLpNorm (lt_of_lt_of_le zero_lt_one hp).ne'\n        (fun n => (hf n).aestronglyMeasurable) hg.aestronglyMeasurable h,\n      unifIntegrable_of_tendsto_Lp hp hp' hf hg h,\n      unifTight_of_tendsto_Lp hp' hf hg h⟩\n\n"}
