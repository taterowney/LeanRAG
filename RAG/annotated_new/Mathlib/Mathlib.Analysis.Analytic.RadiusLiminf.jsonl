{"name":"FormalMultilinearSeries.radius_eq_liminf","module":"Mathlib.Analysis.Analytic.RadiusLiminf","initialProofState":"ùïú : Type u_1\ninst‚úù‚Å¥ : NontriviallyNormedField ùïú\nE : Type u_2\ninst‚úù¬≥ : NormedAddCommGroup E\ninst‚úù¬≤ : NormedSpace ùïú E\nF : Type u_3\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : NormedSpace ùïú F\np : FormalMultilinearSeries ùïú E F\n‚ä¢ Eq p.radius (Filter.liminf (fun n => HDiv.hDiv 1 ‚Üë(HPow.hPow (NNNorm.nnnorm (p n)) (HDiv.hDiv 1 ‚Üën))) Filter.atTop)","decl":"/-- The radius of a formal multilinear series is equal to\n$\\liminf_{n\\to\\infty} \\frac{1}{\\sqrt[n]{‚Äñp n‚Äñ}}$. The actual statement uses `‚Ñù‚â•0` and some\ncoercions. -/\ntheorem radius_eq_liminf :\n    p.radius = liminf (fun n => (1 / (‚Äñp n‚Äñ‚Çä ^ (1 / (n : ‚Ñù)) : ‚Ñù‚â•0) : ‚Ñù‚â•0‚àû)) atTop := by\n  -- Porting note: added type ascription to make elaborated statement match Lean 3 version\n  have :\n    ‚àÄ (r : ‚Ñù‚â•0) {n : ‚Ñï},\n      0 < n ‚Üí ((r : ‚Ñù‚â•0‚àû) ‚â§ 1 / ‚Üë(‚Äñp n‚Äñ‚Çä ^ (1 / (n : ‚Ñù))) ‚Üî ‚Äñp n‚Äñ‚Çä * r ^ n ‚â§ 1) := by\n    intro r n hn\n    have : 0 < (n : ‚Ñù) := Nat.cast_pos.2 hn\n    conv_lhs =>\n      rw [one_div, ENNReal.le_inv_iff_mul_le, ‚Üê ENNReal.coe_mul, ENNReal.coe_le_one_iff, one_div, ‚Üê\n        NNReal.rpow_one r, ‚Üê mul_inv_cancel‚ÇÄ this.ne', NNReal.rpow_mul, ‚Üê NNReal.mul_rpow, ‚Üê\n        NNReal.one_rpow n‚Åª¬π, NNReal.rpow_le_rpow_iff (inv_pos.2 this), mul_comm,\n        NNReal.rpow_natCast]\n  apply le_antisymm <;> refine ENNReal.le_of_forall_nnreal_lt fun r hr => ?_\n  ¬∑ have := ((TFAE_exists_lt_isLittleO_pow (fun n => ‚Äñp n‚Äñ * r ^ n) 1).out 1 7).1\n      (p.isLittleO_of_lt_radius hr)\n    obtain ‚ü®a, ha, H‚ü© := this\n    apply le_liminf_of_le\n    ¬∑ infer_param\n    ¬∑ rw [‚Üê eventually_map]\n      refine\n        H.mp ((eventually_gt_atTop 0).mono fun n hn‚ÇÄ hn => (this _ hn‚ÇÄ).2 (NNReal.coe_le_coe.1 ?_))\n      push_cast\n      exact (le_abs_self _).trans (hn.trans (pow_le_one‚ÇÄ ha.1.le ha.2.le))\n  ¬∑ refine p.le_radius_of_isBigO <| .of_norm_eventuallyLE ?_\n    filter_upwards [eventually_lt_of_lt_liminf hr, eventually_gt_atTop 0] with n hn hn‚ÇÄ\n    simpa using NNReal.coe_le_coe.2 ((this _ hn‚ÇÄ).1 hn.le)\n\n"}
