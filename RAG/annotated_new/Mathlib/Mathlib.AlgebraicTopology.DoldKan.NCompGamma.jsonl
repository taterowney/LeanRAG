{"name":"AlgebraicTopology.DoldKan.PInfty_comp_map_mono_eq_zero","module":"Mathlib.AlgebraicTopology.DoldKan.NCompGamma","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nX : CategoryTheory.SimplicialObject C\nn : Nat\nΔ' : SimplexCategory\ni : Quiver.Hom Δ' (SimplexCategory.mk n)\nhi : CategoryTheory.Mono i\nh₁ : Ne Δ'.len n\nh₂ : Not (AlgebraicTopology.DoldKan.Isδ₀ i)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicTopology.DoldKan.PInfty.f n) (X.map i.op)) 0","decl":"theorem PInfty_comp_map_mono_eq_zero (X : SimplicialObject C) {n : ℕ} {Δ' : SimplexCategory}\n    (i : Δ' ⟶ [n]) [hi : Mono i] (h₁ : Δ'.len ≠ n) (h₂ : ¬Isδ₀ i) :\n    PInfty.f n ≫ X.map i.op = 0 := by\n  induction' Δ' using SimplexCategory.rec with m\n  obtain ⟨k, hk⟩ := Nat.exists_eq_add_of_lt (len_lt_of_mono i fun h => by\n        rw [← h] at h₁\n        exact h₁ rfl)\n  simp only [len_mk] at hk\n  rcases k with _|k\n  · change n = m + 1 at hk\n    subst hk\n    obtain ⟨j, rfl⟩ := eq_δ_of_mono i\n    rw [Isδ₀.iff] at h₂\n    have h₃ : 1 ≤ (j : ℕ) := by\n      by_contra h\n      exact h₂ (by simpa only [Fin.ext_iff, not_le, Nat.lt_one_iff] using h)\n    exact (HigherFacesVanish.of_P (m + 1) m).comp_δ_eq_zero j h₂ (by omega)\n  · simp only [Nat.succ_eq_add_one, ← add_assoc] at hk\n    clear h₂ hi\n    subst hk\n    obtain ⟨j₁ : Fin (_ + 1), i, rfl⟩ :=\n      eq_comp_δ_of_not_surjective i fun h => by\n        have h' := len_le_of_epi (SimplexCategory.epi_iff_surjective.2 h)\n        dsimp at h'\n        omega\n    obtain ⟨j₂, i, rfl⟩ :=\n      eq_comp_δ_of_not_surjective i fun h => by\n        have h' := len_le_of_epi (SimplexCategory.epi_iff_surjective.2 h)\n        dsimp at h'\n        omega\n    by_cases hj₁ : j₁ = 0\n    · subst hj₁\n      rw [assoc, ← SimplexCategory.δ_comp_δ'' (Fin.zero_le _)]\n      simp only [op_comp, X.map_comp, assoc, PInfty_f]\n      erw [(HigherFacesVanish.of_P _ _).comp_δ_eq_zero_assoc _ j₂.succ_ne_zero, zero_comp]\n      simp only [Nat.succ_eq_add_one, Nat.add, Fin.succ]\n      omega\n    · simp only [op_comp, X.map_comp, assoc, PInfty_f]\n      erw [(HigherFacesVanish.of_P _ _).comp_δ_eq_zero_assoc _ hj₁, zero_comp]\n      by_contra\n      exact hj₁ (by simp only [Fin.ext_iff, Fin.val_zero]; omega)\n\n"}
{"name":"AlgebraicTopology.DoldKan.Γ₀_obj_termwise_mapMono_comp_PInfty_assoc","module":"Mathlib.AlgebraicTopology.DoldKan.NCompGamma","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\nX : CategoryTheory.SimplicialObject C\nΔ Δ' : SimplexCategory\ni : Quiver.Hom Δ Δ'\ninst✝ : CategoryTheory.Mono i\nZ : C\nh : Quiver.Hom ((AlgebraicTopology.AlternatingFaceMapComplex.obj X).X Δ.len) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicTopology.DoldKan.Γ₀.Obj.Termwise.mapMono (AlgebraicTopology.AlternatingFaceMapComplex.obj X) i) (CategoryTheory.CategoryStruct.comp (AlgebraicTopology.DoldKan.PInfty.f Δ.len) h)) (CategoryTheory.CategoryStruct.comp (AlgebraicTopology.DoldKan.PInfty.f Δ'.len) (CategoryTheory.CategoryStruct.comp (X.map i.op) h))","decl":"@[reassoc]\ntheorem Γ₀_obj_termwise_mapMono_comp_PInfty (X : SimplicialObject C) {Δ Δ' : SimplexCategory}\n    (i : Δ ⟶ Δ') [Mono i] :\n    Γ₀.Obj.Termwise.mapMono (AlternatingFaceMapComplex.obj X) i ≫ PInfty.f Δ.len =\n      PInfty.f Δ'.len ≫ X.map i.op := by\n  induction' Δ using SimplexCategory.rec with n\n  induction' Δ' using SimplexCategory.rec with n'\n  dsimp\n  -- We start with the case `i` is an identity\n  by_cases h : n = n'\n  · subst h\n    simp only [SimplexCategory.eq_id_of_mono i, Γ₀.Obj.Termwise.mapMono_id, op_id, X.map_id]\n    dsimp\n    simp only [id_comp, comp_id]\n  by_cases hi : Isδ₀ i\n  -- The case `i = δ 0`\n  · have h' : n' = n + 1 := hi.left\n    subst h'\n    simp only [Γ₀.Obj.Termwise.mapMono_δ₀' _ i hi]\n    dsimp\n    rw [← PInfty.comm _ n, AlternatingFaceMapComplex.obj_d_eq]\n    simp only [eq_self_iff_true, id_comp, if_true, Preadditive.comp_sum]\n    rw [Finset.sum_eq_single (0 : Fin (n + 2))]\n    rotate_left\n    · intro b _ hb\n      rw [Preadditive.comp_zsmul]\n      erw [PInfty_comp_map_mono_eq_zero X (SimplexCategory.δ b) h\n          (by\n            rw [Isδ₀.iff]\n            exact hb),\n        zsmul_zero]\n    · simp only [Finset.mem_univ, not_true, IsEmpty.forall_iff]\n    · simp only [hi.eq_δ₀, Fin.val_zero, pow_zero, one_zsmul]\n      rfl\n  -- The case `i ≠ δ 0`\n  · rw [Γ₀.Obj.Termwise.mapMono_eq_zero _ i _ hi, zero_comp]\n    swap\n    · by_contra h'\n      exact h (congr_arg SimplexCategory.len h'.symm)\n    rw [PInfty_comp_map_mono_eq_zero]\n    · exact h\n    · by_contra h'\n      exact hi h'\n\n"}
{"name":"AlgebraicTopology.DoldKan.Γ₀_obj_termwise_mapMono_comp_PInfty","module":"Mathlib.AlgebraicTopology.DoldKan.NCompGamma","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\nX : CategoryTheory.SimplicialObject C\nΔ Δ' : SimplexCategory\ni : Quiver.Hom Δ Δ'\ninst✝ : CategoryTheory.Mono i\n⊢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicTopology.DoldKan.Γ₀.Obj.Termwise.mapMono (AlgebraicTopology.AlternatingFaceMapComplex.obj X) i) (AlgebraicTopology.DoldKan.PInfty.f Δ.len)) (CategoryTheory.CategoryStruct.comp (AlgebraicTopology.DoldKan.PInfty.f Δ'.len) (X.map i.op))","decl":"@[reassoc]\ntheorem Γ₀_obj_termwise_mapMono_comp_PInfty (X : SimplicialObject C) {Δ Δ' : SimplexCategory}\n    (i : Δ ⟶ Δ') [Mono i] :\n    Γ₀.Obj.Termwise.mapMono (AlternatingFaceMapComplex.obj X) i ≫ PInfty.f Δ.len =\n      PInfty.f Δ'.len ≫ X.map i.op := by\n  induction' Δ using SimplexCategory.rec with n\n  induction' Δ' using SimplexCategory.rec with n'\n  dsimp\n  -- We start with the case `i` is an identity\n  by_cases h : n = n'\n  · subst h\n    simp only [SimplexCategory.eq_id_of_mono i, Γ₀.Obj.Termwise.mapMono_id, op_id, X.map_id]\n    dsimp\n    simp only [id_comp, comp_id]\n  by_cases hi : Isδ₀ i\n  -- The case `i = δ 0`\n  · have h' : n' = n + 1 := hi.left\n    subst h'\n    simp only [Γ₀.Obj.Termwise.mapMono_δ₀' _ i hi]\n    dsimp\n    rw [← PInfty.comm _ n, AlternatingFaceMapComplex.obj_d_eq]\n    simp only [eq_self_iff_true, id_comp, if_true, Preadditive.comp_sum]\n    rw [Finset.sum_eq_single (0 : Fin (n + 2))]\n    rotate_left\n    · intro b _ hb\n      rw [Preadditive.comp_zsmul]\n      erw [PInfty_comp_map_mono_eq_zero X (SimplexCategory.δ b) h\n          (by\n            rw [Isδ₀.iff]\n            exact hb),\n        zsmul_zero]\n    · simp only [Finset.mem_univ, not_true, IsEmpty.forall_iff]\n    · simp only [hi.eq_δ₀, Fin.val_zero, pow_zero, one_zsmul]\n      rfl\n  -- The case `i ≠ δ 0`\n  · rw [Γ₀.Obj.Termwise.mapMono_eq_zero _ i _ hi, zero_comp]\n    swap\n    · by_contra h'\n      exact h (congr_arg SimplexCategory.len h'.symm)\n    rw [PInfty_comp_map_mono_eq_zero]\n    · exact h\n    · by_contra h'\n      exact hi h'\n\n"}
{"name":"AlgebraicTopology.DoldKan.Γ₂N₁.natTrans_app_f_app","module":"Mathlib.AlgebraicTopology.DoldKan.NCompGamma","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.Limits.HasFiniteCoproducts C\nX : CategoryTheory.SimplicialObject C\nΔ : Opposite SimplexCategory\n⊢ Eq ((AlgebraicTopology.DoldKan.Γ₂N₁.natTrans.app X).f.app Δ) ((AlgebraicTopology.DoldKan.Γ₀.splitting (AlgebraicTopology.AlternatingFaceMapComplex.obj X)).desc Δ fun A => CategoryTheory.CategoryStruct.comp (AlgebraicTopology.DoldKan.PInfty.f (Opposite.unop A.fst).len) (X.map A.e.op))","decl":"/-- The natural transformation `N₁ ⋙ Γ₂ ⟶ toKaroubi (SimplicialObject C)`. -/\n@[simps]\ndef natTrans : (N₁ : SimplicialObject C ⥤ _) ⋙ Γ₂ ⟶ toKaroubi _ where\n  app X :=\n    { f :=\n        { app := fun Δ => (Γ₀.splitting K[X]).desc Δ fun A => PInfty.f A.1.unop.len ≫ X.map A.e.op\n          naturality := fun Δ Δ' θ => by\n            apply (Γ₀.splitting K[X]).hom_ext'\n            intro A\n            change _ ≫ (Γ₀.obj K[X]).map θ ≫ _ = _\n            simp only [Splitting.ι_desc_assoc, assoc, Γ₀.Obj.map_on_summand'_assoc,\n              Splitting.ι_desc]\n            erw [Γ₀_obj_termwise_mapMono_comp_PInfty_assoc X (image.ι (θ.unop ≫ A.e))]\n            dsimp only [toKaroubi]\n            simp only [← X.map_comp]\n            congr 2\n            simp only [eqToHom_refl, id_comp, comp_id, ← op_comp]\n            exact Quiver.Hom.unop_inj (A.fac_pull θ) }\n      comm := by\n        apply (Γ₀.splitting K[X]).hom_ext\n        intro n\n        dsimp [N₁]\n        simp only [← Splitting.cofan_inj_id, Splitting.ι_desc, comp_id, Splitting.ι_desc_assoc,\n          assoc, PInfty_f_idem_assoc] }\n  naturality {X Y} f := by\n    ext1\n    apply (Γ₀.splitting K[X]).hom_ext\n    intro n\n    dsimp [N₁, toKaroubi]\n    simp only [← Splitting.cofan_inj_id, Splitting.ι_desc, Splitting.ι_desc_assoc, assoc,\n      PInfty_f_idem_assoc, Karoubi.comp_f, NatTrans.comp_app, Γ₂_map_f_app,\n      HomologicalComplex.comp_f, AlternatingFaceMapComplex.map_f, PInfty_f_naturality_assoc,\n      NatTrans.naturality, Splitting.IndexSet.id_fst, unop_op, len_mk]\n\n"}
{"name":"AlgebraicTopology.DoldKan.Γ₂N₂ToKaroubiIso_inv_app","module":"Mathlib.AlgebraicTopology.DoldKan.NCompGamma","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.Limits.HasFiniteCoproducts C\nX : CategoryTheory.SimplicialObject C\n⊢ Eq (AlgebraicTopology.DoldKan.Γ₂N₂ToKaroubiIso.inv.app X) (AlgebraicTopology.DoldKan.Γ₂.map (AlgebraicTopology.DoldKan.toKaroubiCompN₂IsoN₁.inv.app X))","decl":"/-- The compatibility isomorphism relating `N₂ ⋙ Γ₂` and `N₁ ⋙ Γ₂`. -/\n@[simps! hom_app inv_app]\ndef Γ₂N₂ToKaroubiIso : toKaroubi (SimplicialObject C) ⋙ N₂ ⋙ Γ₂ ≅ N₁ ⋙ Γ₂ :=\n  (Functor.associator _ _ _).symm ≪≫ isoWhiskerRight toKaroubiCompN₂IsoN₁ Γ₂\n\n"}
{"name":"AlgebraicTopology.DoldKan.Γ₂N₂ToKaroubiIso_hom_app","module":"Mathlib.AlgebraicTopology.DoldKan.NCompGamma","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.Limits.HasFiniteCoproducts C\nX : CategoryTheory.SimplicialObject C\n⊢ Eq (AlgebraicTopology.DoldKan.Γ₂N₂ToKaroubiIso.hom.app X) (AlgebraicTopology.DoldKan.Γ₂.map (AlgebraicTopology.DoldKan.toKaroubiCompN₂IsoN₁.hom.app X))","decl":"/-- The compatibility isomorphism relating `N₂ ⋙ Γ₂` and `N₁ ⋙ Γ₂`. -/\n@[simps! hom_app inv_app]\ndef Γ₂N₂ToKaroubiIso : toKaroubi (SimplicialObject C) ⋙ N₂ ⋙ Γ₂ ≅ N₁ ⋙ Γ₂ :=\n  (Functor.associator _ _ _).symm ≪≫ isoWhiskerRight toKaroubiCompN₂IsoN₁ Γ₂\n\n"}
{"name":"AlgebraicTopology.DoldKan.Γ₂N₂.natTrans_app_f_app","module":"Mathlib.AlgebraicTopology.DoldKan.NCompGamma","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.Limits.HasFiniteCoproducts C\nP : CategoryTheory.Idempotents.Karoubi (CategoryTheory.SimplicialObject C)\n⊢ Eq (AlgebraicTopology.DoldKan.Γ₂N₂.natTrans.app P) (CategoryTheory.CategoryStruct.comp ((AlgebraicTopology.DoldKan.N₂.comp AlgebraicTopology.DoldKan.Γ₂).map P.decompId_i) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.CategoryStruct.comp AlgebraicTopology.DoldKan.Γ₂N₂ToKaroubiIso.hom AlgebraicTopology.DoldKan.Γ₂N₁.natTrans).app P.X) P.decompId_p))","decl":"theorem natTrans_app_f_app (P : Karoubi (SimplicialObject C)) :\n    Γ₂N₂.natTrans.app P =\n      (N₂ ⋙ Γ₂).map P.decompId_i ≫\n        (Γ₂N₂ToKaroubiIso.hom ≫ Γ₂N₁.natTrans).app P.X ≫ P.decompId_p := by\n  dsimp only [natTrans]\n  simp only [whiskeringLeft_obj_preimage_app, Functor.id_map, assoc]\n\n"}
{"name":"AlgebraicTopology.DoldKan.compatibility_Γ₂N₁_Γ₂N₂_natTrans","module":"Mathlib.AlgebraicTopology.DoldKan.NCompGamma","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.Limits.HasFiniteCoproducts C\nX : CategoryTheory.SimplicialObject C\n⊢ Eq (AlgebraicTopology.DoldKan.Γ₂N₁.natTrans.app X) (CategoryTheory.CategoryStruct.comp (AlgebraicTopology.DoldKan.Γ₂N₂ToKaroubiIso.app X).inv (AlgebraicTopology.DoldKan.Γ₂N₂.natTrans.app ((CategoryTheory.Idempotents.toKaroubi (CategoryTheory.SimplicialObject C)).obj X)))","decl":"theorem compatibility_Γ₂N₁_Γ₂N₂_natTrans (X : SimplicialObject C) :\n    Γ₂N₁.natTrans.app X =\n      (Γ₂N₂ToKaroubiIso.app X).inv ≫\n        Γ₂N₂.natTrans.app ((toKaroubi (SimplicialObject C)).obj X) := by\n  rw [Γ₂N₂.natTrans_app_f_app]\n  dsimp only [Karoubi.decompId_i_toKaroubi, Karoubi.decompId_p_toKaroubi, Functor.comp_map,\n    NatTrans.comp_app]\n  rw [N₂.map_id, Γ₂.map_id, Iso.app_inv]\n  dsimp only [toKaroubi]\n  erw [id_comp]\n  rw [comp_id, Iso.inv_hom_id_app_assoc]\n\n"}
{"name":"AlgebraicTopology.DoldKan.identity_N₂_objectwise","module":"Mathlib.AlgebraicTopology.DoldKan.NCompGamma","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.Limits.HasFiniteCoproducts C\nP : CategoryTheory.Idempotents.Karoubi (CategoryTheory.SimplicialObject C)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicTopology.DoldKan.N₂Γ₂.inv.app (AlgebraicTopology.DoldKan.N₂.obj P)) (AlgebraicTopology.DoldKan.N₂.map (AlgebraicTopology.DoldKan.Γ₂N₂.natTrans.app P))) (CategoryTheory.CategoryStruct.id (AlgebraicTopology.DoldKan.N₂.obj P))","decl":"theorem identity_N₂_objectwise (P : Karoubi (SimplicialObject C)) :\n    (N₂Γ₂.inv.app (N₂.obj P) : N₂.obj P ⟶ N₂.obj (Γ₂.obj (N₂.obj P))) ≫\n    N₂.map (Γ₂N₂.natTrans.app P) = 𝟙 (N₂.obj P) := by\n  ext n\n  have eq₁ : (N₂Γ₂.inv.app (N₂.obj P)).f.f n = PInfty.f n ≫ P.p.app (op [n]) ≫\n      ((Γ₀.splitting (N₂.obj P).X).cofan _).inj (Splitting.IndexSet.id (op [n])) := by\n    simp only [N₂Γ₂_inv_app_f_f, N₂_obj_p_f, assoc]\n  have eq₂ : ((Γ₀.splitting (N₂.obj P).X).cofan _).inj (Splitting.IndexSet.id (op [n])) ≫\n      (N₂.map (Γ₂N₂.natTrans.app P)).f.f n = PInfty.f n ≫ P.p.app (op [n]) := by\n    dsimp\n    rw [PInfty_on_Γ₀_splitting_summand_eq_self_assoc, Γ₂N₂.natTrans_app_f_app]\n    dsimp\n    rw [Γ₂N₂ToKaroubiIso_hom_app, assoc, Splitting.ι_desc_assoc, assoc, assoc]\n    dsimp [toKaroubi]\n    rw [Splitting.ι_desc_assoc]\n    dsimp\n    simp only [assoc, Splitting.ι_desc_assoc, unop_op, Splitting.IndexSet.id_fst,\n      len_mk, NatTrans.naturality, PInfty_f_idem_assoc,\n      PInfty_f_naturality_assoc, app_idem_assoc]\n    erw [P.X.map_id, comp_id]\n  simp only [Karoubi.comp_f, HomologicalComplex.comp_f, Karoubi.id_f, N₂_obj_p_f, assoc,\n    eq₁, eq₂, PInfty_f_naturality_assoc, app_idem, PInfty_f_idem_assoc]\n\n-- Porting note: `Functor.associator` was added to the statement in order to prevent a timeout\n"}
{"name":"AlgebraicTopology.DoldKan.identity_N₂","module":"Mathlib.AlgebraicTopology.DoldKan.NCompGamma","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.Limits.HasFiniteCoproducts C\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.NatTrans.hcomp (CategoryTheory.CategoryStruct.id AlgebraicTopology.DoldKan.N₂) AlgebraicTopology.DoldKan.N₂Γ₂.inv) (CategoryTheory.CategoryStruct.comp (AlgebraicTopology.DoldKan.N₂.associator AlgebraicTopology.DoldKan.Γ₂ AlgebraicTopology.DoldKan.N₂).inv (CategoryTheory.NatTrans.hcomp AlgebraicTopology.DoldKan.Γ₂N₂.natTrans (CategoryTheory.CategoryStruct.id AlgebraicTopology.DoldKan.N₂)))) (CategoryTheory.CategoryStruct.id AlgebraicTopology.DoldKan.N₂)","decl":"theorem identity_N₂ :\n    (𝟙 (N₂ : Karoubi (SimplicialObject C) ⥤ _) ◫ N₂Γ₂.inv) ≫\n    (Functor.associator _ _ _).inv ≫ Γ₂N₂.natTrans ◫ 𝟙 (@N₂ C _ _) = 𝟙 N₂ := by\n  ext P : 2\n  dsimp only [NatTrans.comp_app, NatTrans.hcomp_app, Functor.comp_map, Functor.associator,\n    NatTrans.id_app, Functor.comp_obj]\n  rw [Γ₂.map_id, N₂.map_id, comp_id, id_comp, id_comp, identity_N₂_objectwise P]\n\n"}
{"name":"AlgebraicTopology.DoldKan.instIsIsoFunctorKaroubiSimplicialObjectNatTrans","module":"Mathlib.AlgebraicTopology.DoldKan.NCompGamma","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.Limits.HasFiniteCoproducts C\n⊢ CategoryTheory.IsIso AlgebraicTopology.DoldKan.Γ₂N₂.natTrans","decl":"instance : IsIso (Γ₂N₂.natTrans : (N₂ : Karoubi (SimplicialObject C) ⥤ _) ⋙ _ ⟶ _) := by\n  have : ∀ P : Karoubi (SimplicialObject C), IsIso (Γ₂N₂.natTrans.app P) := by\n    intro P\n    have : IsIso (N₂.map (Γ₂N₂.natTrans.app P)) := by\n      have h := identity_N₂_objectwise P\n      erw [hom_comp_eq_id] at h\n      rw [h]\n      infer_instance\n    exact isIso_of_reflects_iso _ N₂\n  apply NatIso.isIso_of_isIso_app\n\n"}
{"name":"AlgebraicTopology.DoldKan.instIsIsoFunctorSimplicialObjectKaroubiNatTrans","module":"Mathlib.AlgebraicTopology.DoldKan.NCompGamma","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.Limits.HasFiniteCoproducts C\n⊢ CategoryTheory.IsIso AlgebraicTopology.DoldKan.Γ₂N₁.natTrans","decl":"instance : IsIso (Γ₂N₁.natTrans : (N₁ : SimplicialObject C ⥤ _) ⋙ _ ⟶ _) := by\n  have : ∀ X : SimplicialObject C, IsIso (Γ₂N₁.natTrans.app X) := by\n    intro X\n    rw [compatibility_Γ₂N₁_Γ₂N₂_natTrans]\n    infer_instance\n  apply NatIso.isIso_of_isIso_app\n\n"}
{"name":"AlgebraicTopology.DoldKan.Γ₂N₂_inv","module":"Mathlib.AlgebraicTopology.DoldKan.NCompGamma","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.Limits.HasFiniteCoproducts C\n⊢ Eq AlgebraicTopology.DoldKan.Γ₂N₂.inv AlgebraicTopology.DoldKan.Γ₂N₂.natTrans","decl":"/-- The unit isomorphism of the Dold-Kan equivalence. -/\n@[simps! inv]\ndef Γ₂N₂ : 𝟭 _ ≅ (N₂ : Karoubi (SimplicialObject C) ⥤ _) ⋙ Γ₂ :=\n  (asIso Γ₂N₂.natTrans).symm\n\n"}
{"name":"AlgebraicTopology.DoldKan.Γ₂N₁_inv","module":"Mathlib.AlgebraicTopology.DoldKan.NCompGamma","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.Limits.HasFiniteCoproducts C\n⊢ Eq AlgebraicTopology.DoldKan.Γ₂N₁.inv AlgebraicTopology.DoldKan.Γ₂N₁.natTrans","decl":"/-- The natural isomorphism `toKaroubi (SimplicialObject C) ≅ N₁ ⋙ Γ₂`. -/\n@[simps! inv]\ndef Γ₂N₁ : toKaroubi _ ≅ (N₁ : SimplicialObject C ⥤ _) ⋙ Γ₂ :=\n  (asIso Γ₂N₁.natTrans).symm\n\n"}
