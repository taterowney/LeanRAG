{"name":"AlgebraicTopology.DoldKan.PInfty_comp_map_mono_eq_zero","module":"Mathlib.AlgebraicTopology.DoldKan.NCompGamma","initialProofState":"C : Type u_1\ninstâœÂ¹ : CategoryTheory.Category.{u_2, u_1} C\ninstâœ : CategoryTheory.Preadditive C\nX : CategoryTheory.SimplicialObject C\nn : Nat\nÎ”' : SimplexCategory\ni : Quiver.Hom Î”' (SimplexCategory.mk n)\nhi : CategoryTheory.Mono i\nhâ‚ : Ne Î”'.len n\nhâ‚‚ : Not (AlgebraicTopology.DoldKan.IsÎ´â‚€ i)\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicTopology.DoldKan.PInfty.f n) (X.map i.op)) 0","decl":"theorem PInfty_comp_map_mono_eq_zero (X : SimplicialObject C) {n : â„•} {Î”' : SimplexCategory}\n    (i : Î”' âŸ¶ [n]) [hi : Mono i] (hâ‚ : Î”'.len â‰  n) (hâ‚‚ : Â¬IsÎ´â‚€ i) :\n    PInfty.f n â‰« X.map i.op = 0 := by\n  induction' Î”' using SimplexCategory.rec with m\n  obtain âŸ¨k, hkâŸ© := Nat.exists_eq_add_of_lt (len_lt_of_mono i fun h => by\n        rw [â† h] at hâ‚\n        exact hâ‚ rfl)\n  simp only [len_mk] at hk\n  rcases k with _|k\n  Â· change n = m + 1 at hk\n    subst hk\n    obtain âŸ¨j, rflâŸ© := eq_Î´_of_mono i\n    rw [IsÎ´â‚€.iff] at hâ‚‚\n    have hâ‚ƒ : 1 â‰¤ (j : â„•) := by\n      by_contra h\n      exact hâ‚‚ (by simpa only [Fin.ext_iff, not_le, Nat.lt_one_iff] using h)\n    exact (HigherFacesVanish.of_P (m + 1) m).comp_Î´_eq_zero j hâ‚‚ (by omega)\n  Â· simp only [Nat.succ_eq_add_one, â† add_assoc] at hk\n    clear hâ‚‚ hi\n    subst hk\n    obtain âŸ¨jâ‚ : Fin (_ + 1), i, rflâŸ© :=\n      eq_comp_Î´_of_not_surjective i fun h => by\n        have h' := len_le_of_epi (SimplexCategory.epi_iff_surjective.2 h)\n        dsimp at h'\n        omega\n    obtain âŸ¨jâ‚‚, i, rflâŸ© :=\n      eq_comp_Î´_of_not_surjective i fun h => by\n        have h' := len_le_of_epi (SimplexCategory.epi_iff_surjective.2 h)\n        dsimp at h'\n        omega\n    by_cases hjâ‚ : jâ‚ = 0\n    Â· subst hjâ‚\n      rw [assoc, â† SimplexCategory.Î´_comp_Î´'' (Fin.zero_le _)]\n      simp only [op_comp, X.map_comp, assoc, PInfty_f]\n      erw [(HigherFacesVanish.of_P _ _).comp_Î´_eq_zero_assoc _ jâ‚‚.succ_ne_zero, zero_comp]\n      simp only [Nat.succ_eq_add_one, Nat.add, Fin.succ]\n      omega\n    Â· simp only [op_comp, X.map_comp, assoc, PInfty_f]\n      erw [(HigherFacesVanish.of_P _ _).comp_Î´_eq_zero_assoc _ hjâ‚, zero_comp]\n      by_contra\n      exact hjâ‚ (by simp only [Fin.ext_iff, Fin.val_zero]; omega)\n\n"}
{"name":"AlgebraicTopology.DoldKan.Î“â‚€_obj_termwise_mapMono_comp_PInfty_assoc","module":"Mathlib.AlgebraicTopology.DoldKan.NCompGamma","initialProofState":"C : Type u_1\ninstâœÂ² : CategoryTheory.Category.{u_2, u_1} C\ninstâœÂ¹ : CategoryTheory.Preadditive C\nX : CategoryTheory.SimplicialObject C\nÎ” Î”' : SimplexCategory\ni : Quiver.Hom Î” Î”'\ninstâœ : CategoryTheory.Mono i\nZ : C\nh : Quiver.Hom ((AlgebraicTopology.AlternatingFaceMapComplex.obj X).X Î”.len) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicTopology.DoldKan.Î“â‚€.Obj.Termwise.mapMono (AlgebraicTopology.AlternatingFaceMapComplex.obj X) i) (CategoryTheory.CategoryStruct.comp (AlgebraicTopology.DoldKan.PInfty.f Î”.len) h)) (CategoryTheory.CategoryStruct.comp (AlgebraicTopology.DoldKan.PInfty.f Î”'.len) (CategoryTheory.CategoryStruct.comp (X.map i.op) h))","decl":"@[reassoc]\ntheorem Î“â‚€_obj_termwise_mapMono_comp_PInfty (X : SimplicialObject C) {Î” Î”' : SimplexCategory}\n    (i : Î” âŸ¶ Î”') [Mono i] :\n    Î“â‚€.Obj.Termwise.mapMono (AlternatingFaceMapComplex.obj X) i â‰« PInfty.f Î”.len =\n      PInfty.f Î”'.len â‰« X.map i.op := by\n  induction' Î” using SimplexCategory.rec with n\n  induction' Î”' using SimplexCategory.rec with n'\n  dsimp\n  -- We start with the case `i` is an identity\n  by_cases h : n = n'\n  Â· subst h\n    simp only [SimplexCategory.eq_id_of_mono i, Î“â‚€.Obj.Termwise.mapMono_id, op_id, X.map_id]\n    dsimp\n    simp only [id_comp, comp_id]\n  by_cases hi : IsÎ´â‚€ i\n  -- The case `i = Î´ 0`\n  Â· have h' : n' = n + 1 := hi.left\n    subst h'\n    simp only [Î“â‚€.Obj.Termwise.mapMono_Î´â‚€' _ i hi]\n    dsimp\n    rw [â† PInfty.comm _ n, AlternatingFaceMapComplex.obj_d_eq]\n    simp only [eq_self_iff_true, id_comp, if_true, Preadditive.comp_sum]\n    rw [Finset.sum_eq_single (0 : Fin (n + 2))]\n    rotate_left\n    Â· intro b _ hb\n      rw [Preadditive.comp_zsmul]\n      erw [PInfty_comp_map_mono_eq_zero X (SimplexCategory.Î´ b) h\n          (by\n            rw [IsÎ´â‚€.iff]\n            exact hb),\n        zsmul_zero]\n    Â· simp only [Finset.mem_univ, not_true, IsEmpty.forall_iff]\n    Â· simp only [hi.eq_Î´â‚€, Fin.val_zero, pow_zero, one_zsmul]\n      rfl\n  -- The case `i â‰  Î´ 0`\n  Â· rw [Î“â‚€.Obj.Termwise.mapMono_eq_zero _ i _ hi, zero_comp]\n    swap\n    Â· by_contra h'\n      exact h (congr_arg SimplexCategory.len h'.symm)\n    rw [PInfty_comp_map_mono_eq_zero]\n    Â· exact h\n    Â· by_contra h'\n      exact hi h'\n\n"}
{"name":"AlgebraicTopology.DoldKan.Î“â‚€_obj_termwise_mapMono_comp_PInfty","module":"Mathlib.AlgebraicTopology.DoldKan.NCompGamma","initialProofState":"C : Type u_1\ninstâœÂ² : CategoryTheory.Category.{u_2, u_1} C\ninstâœÂ¹ : CategoryTheory.Preadditive C\nX : CategoryTheory.SimplicialObject C\nÎ” Î”' : SimplexCategory\ni : Quiver.Hom Î” Î”'\ninstâœ : CategoryTheory.Mono i\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicTopology.DoldKan.Î“â‚€.Obj.Termwise.mapMono (AlgebraicTopology.AlternatingFaceMapComplex.obj X) i) (AlgebraicTopology.DoldKan.PInfty.f Î”.len)) (CategoryTheory.CategoryStruct.comp (AlgebraicTopology.DoldKan.PInfty.f Î”'.len) (X.map i.op))","decl":"@[reassoc]\ntheorem Î“â‚€_obj_termwise_mapMono_comp_PInfty (X : SimplicialObject C) {Î” Î”' : SimplexCategory}\n    (i : Î” âŸ¶ Î”') [Mono i] :\n    Î“â‚€.Obj.Termwise.mapMono (AlternatingFaceMapComplex.obj X) i â‰« PInfty.f Î”.len =\n      PInfty.f Î”'.len â‰« X.map i.op := by\n  induction' Î” using SimplexCategory.rec with n\n  induction' Î”' using SimplexCategory.rec with n'\n  dsimp\n  -- We start with the case `i` is an identity\n  by_cases h : n = n'\n  Â· subst h\n    simp only [SimplexCategory.eq_id_of_mono i, Î“â‚€.Obj.Termwise.mapMono_id, op_id, X.map_id]\n    dsimp\n    simp only [id_comp, comp_id]\n  by_cases hi : IsÎ´â‚€ i\n  -- The case `i = Î´ 0`\n  Â· have h' : n' = n + 1 := hi.left\n    subst h'\n    simp only [Î“â‚€.Obj.Termwise.mapMono_Î´â‚€' _ i hi]\n    dsimp\n    rw [â† PInfty.comm _ n, AlternatingFaceMapComplex.obj_d_eq]\n    simp only [eq_self_iff_true, id_comp, if_true, Preadditive.comp_sum]\n    rw [Finset.sum_eq_single (0 : Fin (n + 2))]\n    rotate_left\n    Â· intro b _ hb\n      rw [Preadditive.comp_zsmul]\n      erw [PInfty_comp_map_mono_eq_zero X (SimplexCategory.Î´ b) h\n          (by\n            rw [IsÎ´â‚€.iff]\n            exact hb),\n        zsmul_zero]\n    Â· simp only [Finset.mem_univ, not_true, IsEmpty.forall_iff]\n    Â· simp only [hi.eq_Î´â‚€, Fin.val_zero, pow_zero, one_zsmul]\n      rfl\n  -- The case `i â‰  Î´ 0`\n  Â· rw [Î“â‚€.Obj.Termwise.mapMono_eq_zero _ i _ hi, zero_comp]\n    swap\n    Â· by_contra h'\n      exact h (congr_arg SimplexCategory.len h'.symm)\n    rw [PInfty_comp_map_mono_eq_zero]\n    Â· exact h\n    Â· by_contra h'\n      exact hi h'\n\n"}
{"name":"AlgebraicTopology.DoldKan.Î“â‚‚Nâ‚.natTrans_app_f_app","module":"Mathlib.AlgebraicTopology.DoldKan.NCompGamma","initialProofState":"C : Type u_1\ninstâœÂ² : CategoryTheory.Category.{u_2, u_1} C\ninstâœÂ¹ : CategoryTheory.Preadditive C\ninstâœ : CategoryTheory.Limits.HasFiniteCoproducts C\nX : CategoryTheory.SimplicialObject C\nÎ” : Opposite SimplexCategory\nâŠ¢ Eq ((AlgebraicTopology.DoldKan.Î“â‚‚Nâ‚.natTrans.app X).f.app Î”) ((AlgebraicTopology.DoldKan.Î“â‚€.splitting (AlgebraicTopology.AlternatingFaceMapComplex.obj X)).desc Î” fun A => CategoryTheory.CategoryStruct.comp (AlgebraicTopology.DoldKan.PInfty.f (Opposite.unop A.fst).len) (X.map A.e.op))","decl":"/-- The natural transformation `Nâ‚ â‹™ Î“â‚‚ âŸ¶ toKaroubi (SimplicialObject C)`. -/\n@[simps]\ndef natTrans : (Nâ‚ : SimplicialObject C â¥¤ _) â‹™ Î“â‚‚ âŸ¶ toKaroubi _ where\n  app X :=\n    { f :=\n        { app := fun Î” => (Î“â‚€.splitting K[X]).desc Î” fun A => PInfty.f A.1.unop.len â‰« X.map A.e.op\n          naturality := fun Î” Î”' Î¸ => by\n            apply (Î“â‚€.splitting K[X]).hom_ext'\n            intro A\n            change _ â‰« (Î“â‚€.obj K[X]).map Î¸ â‰« _ = _\n            simp only [Splitting.Î¹_desc_assoc, assoc, Î“â‚€.Obj.map_on_summand'_assoc,\n              Splitting.Î¹_desc]\n            erw [Î“â‚€_obj_termwise_mapMono_comp_PInfty_assoc X (image.Î¹ (Î¸.unop â‰« A.e))]\n            dsimp only [toKaroubi]\n            simp only [â† X.map_comp]\n            congr 2\n            simp only [eqToHom_refl, id_comp, comp_id, â† op_comp]\n            exact Quiver.Hom.unop_inj (A.fac_pull Î¸) }\n      comm := by\n        apply (Î“â‚€.splitting K[X]).hom_ext\n        intro n\n        dsimp [Nâ‚]\n        simp only [â† Splitting.cofan_inj_id, Splitting.Î¹_desc, comp_id, Splitting.Î¹_desc_assoc,\n          assoc, PInfty_f_idem_assoc] }\n  naturality {X Y} f := by\n    ext1\n    apply (Î“â‚€.splitting K[X]).hom_ext\n    intro n\n    dsimp [Nâ‚, toKaroubi]\n    simp only [â† Splitting.cofan_inj_id, Splitting.Î¹_desc, Splitting.Î¹_desc_assoc, assoc,\n      PInfty_f_idem_assoc, Karoubi.comp_f, NatTrans.comp_app, Î“â‚‚_map_f_app,\n      HomologicalComplex.comp_f, AlternatingFaceMapComplex.map_f, PInfty_f_naturality_assoc,\n      NatTrans.naturality, Splitting.IndexSet.id_fst, unop_op, len_mk]\n\n"}
{"name":"AlgebraicTopology.DoldKan.Î“â‚‚Nâ‚‚ToKaroubiIso_inv_app","module":"Mathlib.AlgebraicTopology.DoldKan.NCompGamma","initialProofState":"C : Type u_1\ninstâœÂ² : CategoryTheory.Category.{u_2, u_1} C\ninstâœÂ¹ : CategoryTheory.Preadditive C\ninstâœ : CategoryTheory.Limits.HasFiniteCoproducts C\nX : CategoryTheory.SimplicialObject C\nâŠ¢ Eq (AlgebraicTopology.DoldKan.Î“â‚‚Nâ‚‚ToKaroubiIso.inv.app X) (AlgebraicTopology.DoldKan.Î“â‚‚.map (AlgebraicTopology.DoldKan.toKaroubiCompNâ‚‚IsoNâ‚.inv.app X))","decl":"/-- The compatibility isomorphism relating `Nâ‚‚ â‹™ Î“â‚‚` and `Nâ‚ â‹™ Î“â‚‚`. -/\n@[simps! hom_app inv_app]\ndef Î“â‚‚Nâ‚‚ToKaroubiIso : toKaroubi (SimplicialObject C) â‹™ Nâ‚‚ â‹™ Î“â‚‚ â‰… Nâ‚ â‹™ Î“â‚‚ :=\n  (Functor.associator _ _ _).symm â‰ªâ‰« isoWhiskerRight toKaroubiCompNâ‚‚IsoNâ‚ Î“â‚‚\n\n"}
{"name":"AlgebraicTopology.DoldKan.Î“â‚‚Nâ‚‚ToKaroubiIso_hom_app","module":"Mathlib.AlgebraicTopology.DoldKan.NCompGamma","initialProofState":"C : Type u_1\ninstâœÂ² : CategoryTheory.Category.{u_2, u_1} C\ninstâœÂ¹ : CategoryTheory.Preadditive C\ninstâœ : CategoryTheory.Limits.HasFiniteCoproducts C\nX : CategoryTheory.SimplicialObject C\nâŠ¢ Eq (AlgebraicTopology.DoldKan.Î“â‚‚Nâ‚‚ToKaroubiIso.hom.app X) (AlgebraicTopology.DoldKan.Î“â‚‚.map (AlgebraicTopology.DoldKan.toKaroubiCompNâ‚‚IsoNâ‚.hom.app X))","decl":"/-- The compatibility isomorphism relating `Nâ‚‚ â‹™ Î“â‚‚` and `Nâ‚ â‹™ Î“â‚‚`. -/\n@[simps! hom_app inv_app]\ndef Î“â‚‚Nâ‚‚ToKaroubiIso : toKaroubi (SimplicialObject C) â‹™ Nâ‚‚ â‹™ Î“â‚‚ â‰… Nâ‚ â‹™ Î“â‚‚ :=\n  (Functor.associator _ _ _).symm â‰ªâ‰« isoWhiskerRight toKaroubiCompNâ‚‚IsoNâ‚ Î“â‚‚\n\n"}
{"name":"AlgebraicTopology.DoldKan.Î“â‚‚Nâ‚‚.natTrans_app_f_app","module":"Mathlib.AlgebraicTopology.DoldKan.NCompGamma","initialProofState":"C : Type u_1\ninstâœÂ² : CategoryTheory.Category.{u_2, u_1} C\ninstâœÂ¹ : CategoryTheory.Preadditive C\ninstâœ : CategoryTheory.Limits.HasFiniteCoproducts C\nP : CategoryTheory.Idempotents.Karoubi (CategoryTheory.SimplicialObject C)\nâŠ¢ Eq (AlgebraicTopology.DoldKan.Î“â‚‚Nâ‚‚.natTrans.app P) (CategoryTheory.CategoryStruct.comp ((AlgebraicTopology.DoldKan.Nâ‚‚.comp AlgebraicTopology.DoldKan.Î“â‚‚).map P.decompId_i) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.CategoryStruct.comp AlgebraicTopology.DoldKan.Î“â‚‚Nâ‚‚ToKaroubiIso.hom AlgebraicTopology.DoldKan.Î“â‚‚Nâ‚.natTrans).app P.X) P.decompId_p))","decl":"theorem natTrans_app_f_app (P : Karoubi (SimplicialObject C)) :\n    Î“â‚‚Nâ‚‚.natTrans.app P =\n      (Nâ‚‚ â‹™ Î“â‚‚).map P.decompId_i â‰«\n        (Î“â‚‚Nâ‚‚ToKaroubiIso.hom â‰« Î“â‚‚Nâ‚.natTrans).app P.X â‰« P.decompId_p := by\n  dsimp only [natTrans]\n  simp only [whiskeringLeft_obj_preimage_app, Functor.id_map, assoc]\n\n"}
{"name":"AlgebraicTopology.DoldKan.compatibility_Î“â‚‚Nâ‚_Î“â‚‚Nâ‚‚_natTrans","module":"Mathlib.AlgebraicTopology.DoldKan.NCompGamma","initialProofState":"C : Type u_1\ninstâœÂ² : CategoryTheory.Category.{u_2, u_1} C\ninstâœÂ¹ : CategoryTheory.Preadditive C\ninstâœ : CategoryTheory.Limits.HasFiniteCoproducts C\nX : CategoryTheory.SimplicialObject C\nâŠ¢ Eq (AlgebraicTopology.DoldKan.Î“â‚‚Nâ‚.natTrans.app X) (CategoryTheory.CategoryStruct.comp (AlgebraicTopology.DoldKan.Î“â‚‚Nâ‚‚ToKaroubiIso.app X).inv (AlgebraicTopology.DoldKan.Î“â‚‚Nâ‚‚.natTrans.app ((CategoryTheory.Idempotents.toKaroubi (CategoryTheory.SimplicialObject C)).obj X)))","decl":"theorem compatibility_Î“â‚‚Nâ‚_Î“â‚‚Nâ‚‚_natTrans (X : SimplicialObject C) :\n    Î“â‚‚Nâ‚.natTrans.app X =\n      (Î“â‚‚Nâ‚‚ToKaroubiIso.app X).inv â‰«\n        Î“â‚‚Nâ‚‚.natTrans.app ((toKaroubi (SimplicialObject C)).obj X) := by\n  rw [Î“â‚‚Nâ‚‚.natTrans_app_f_app]\n  dsimp only [Karoubi.decompId_i_toKaroubi, Karoubi.decompId_p_toKaroubi, Functor.comp_map,\n    NatTrans.comp_app]\n  rw [Nâ‚‚.map_id, Î“â‚‚.map_id, Iso.app_inv]\n  dsimp only [toKaroubi]\n  erw [id_comp]\n  rw [comp_id, Iso.inv_hom_id_app_assoc]\n\n"}
{"name":"AlgebraicTopology.DoldKan.identity_Nâ‚‚_objectwise","module":"Mathlib.AlgebraicTopology.DoldKan.NCompGamma","initialProofState":"C : Type u_1\ninstâœÂ² : CategoryTheory.Category.{u_2, u_1} C\ninstâœÂ¹ : CategoryTheory.Preadditive C\ninstâœ : CategoryTheory.Limits.HasFiniteCoproducts C\nP : CategoryTheory.Idempotents.Karoubi (CategoryTheory.SimplicialObject C)\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicTopology.DoldKan.Nâ‚‚Î“â‚‚.inv.app (AlgebraicTopology.DoldKan.Nâ‚‚.obj P)) (AlgebraicTopology.DoldKan.Nâ‚‚.map (AlgebraicTopology.DoldKan.Î“â‚‚Nâ‚‚.natTrans.app P))) (CategoryTheory.CategoryStruct.id (AlgebraicTopology.DoldKan.Nâ‚‚.obj P))","decl":"theorem identity_Nâ‚‚_objectwise (P : Karoubi (SimplicialObject C)) :\n    (Nâ‚‚Î“â‚‚.inv.app (Nâ‚‚.obj P) : Nâ‚‚.obj P âŸ¶ Nâ‚‚.obj (Î“â‚‚.obj (Nâ‚‚.obj P))) â‰«\n    Nâ‚‚.map (Î“â‚‚Nâ‚‚.natTrans.app P) = ğŸ™ (Nâ‚‚.obj P) := by\n  ext n\n  have eqâ‚ : (Nâ‚‚Î“â‚‚.inv.app (Nâ‚‚.obj P)).f.f n = PInfty.f n â‰« P.p.app (op [n]) â‰«\n      ((Î“â‚€.splitting (Nâ‚‚.obj P).X).cofan _).inj (Splitting.IndexSet.id (op [n])) := by\n    simp only [Nâ‚‚Î“â‚‚_inv_app_f_f, Nâ‚‚_obj_p_f, assoc]\n  have eqâ‚‚ : ((Î“â‚€.splitting (Nâ‚‚.obj P).X).cofan _).inj (Splitting.IndexSet.id (op [n])) â‰«\n      (Nâ‚‚.map (Î“â‚‚Nâ‚‚.natTrans.app P)).f.f n = PInfty.f n â‰« P.p.app (op [n]) := by\n    dsimp\n    rw [PInfty_on_Î“â‚€_splitting_summand_eq_self_assoc, Î“â‚‚Nâ‚‚.natTrans_app_f_app]\n    dsimp\n    rw [Î“â‚‚Nâ‚‚ToKaroubiIso_hom_app, assoc, Splitting.Î¹_desc_assoc, assoc, assoc]\n    dsimp [toKaroubi]\n    rw [Splitting.Î¹_desc_assoc]\n    dsimp\n    simp only [assoc, Splitting.Î¹_desc_assoc, unop_op, Splitting.IndexSet.id_fst,\n      len_mk, NatTrans.naturality, PInfty_f_idem_assoc,\n      PInfty_f_naturality_assoc, app_idem_assoc]\n    erw [P.X.map_id, comp_id]\n  simp only [Karoubi.comp_f, HomologicalComplex.comp_f, Karoubi.id_f, Nâ‚‚_obj_p_f, assoc,\n    eqâ‚, eqâ‚‚, PInfty_f_naturality_assoc, app_idem, PInfty_f_idem_assoc]\n\n-- Porting note: `Functor.associator` was added to the statement in order to prevent a timeout\n"}
{"name":"AlgebraicTopology.DoldKan.identity_Nâ‚‚","module":"Mathlib.AlgebraicTopology.DoldKan.NCompGamma","initialProofState":"C : Type u_1\ninstâœÂ² : CategoryTheory.Category.{u_2, u_1} C\ninstâœÂ¹ : CategoryTheory.Preadditive C\ninstâœ : CategoryTheory.Limits.HasFiniteCoproducts C\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.NatTrans.hcomp (CategoryTheory.CategoryStruct.id AlgebraicTopology.DoldKan.Nâ‚‚) AlgebraicTopology.DoldKan.Nâ‚‚Î“â‚‚.inv) (CategoryTheory.CategoryStruct.comp (AlgebraicTopology.DoldKan.Nâ‚‚.associator AlgebraicTopology.DoldKan.Î“â‚‚ AlgebraicTopology.DoldKan.Nâ‚‚).inv (CategoryTheory.NatTrans.hcomp AlgebraicTopology.DoldKan.Î“â‚‚Nâ‚‚.natTrans (CategoryTheory.CategoryStruct.id AlgebraicTopology.DoldKan.Nâ‚‚)))) (CategoryTheory.CategoryStruct.id AlgebraicTopology.DoldKan.Nâ‚‚)","decl":"theorem identity_Nâ‚‚ :\n    (ğŸ™ (Nâ‚‚ : Karoubi (SimplicialObject C) â¥¤ _) â—« Nâ‚‚Î“â‚‚.inv) â‰«\n    (Functor.associator _ _ _).inv â‰« Î“â‚‚Nâ‚‚.natTrans â—« ğŸ™ (@Nâ‚‚ C _ _) = ğŸ™ Nâ‚‚ := by\n  ext P : 2\n  dsimp only [NatTrans.comp_app, NatTrans.hcomp_app, Functor.comp_map, Functor.associator,\n    NatTrans.id_app, Functor.comp_obj]\n  rw [Î“â‚‚.map_id, Nâ‚‚.map_id, comp_id, id_comp, id_comp, identity_Nâ‚‚_objectwise P]\n\n"}
{"name":"AlgebraicTopology.DoldKan.instIsIsoFunctorKaroubiSimplicialObjectNatTrans","module":"Mathlib.AlgebraicTopology.DoldKan.NCompGamma","initialProofState":"C : Type u_1\ninstâœÂ² : CategoryTheory.Category.{u_2, u_1} C\ninstâœÂ¹ : CategoryTheory.Preadditive C\ninstâœ : CategoryTheory.Limits.HasFiniteCoproducts C\nâŠ¢ CategoryTheory.IsIso AlgebraicTopology.DoldKan.Î“â‚‚Nâ‚‚.natTrans","decl":"instance : IsIso (Î“â‚‚Nâ‚‚.natTrans : (Nâ‚‚ : Karoubi (SimplicialObject C) â¥¤ _) â‹™ _ âŸ¶ _) := by\n  have : âˆ€ P : Karoubi (SimplicialObject C), IsIso (Î“â‚‚Nâ‚‚.natTrans.app P) := by\n    intro P\n    have : IsIso (Nâ‚‚.map (Î“â‚‚Nâ‚‚.natTrans.app P)) := by\n      have h := identity_Nâ‚‚_objectwise P\n      erw [hom_comp_eq_id] at h\n      rw [h]\n      infer_instance\n    exact isIso_of_reflects_iso _ Nâ‚‚\n  apply NatIso.isIso_of_isIso_app\n\n"}
{"name":"AlgebraicTopology.DoldKan.instIsIsoFunctorSimplicialObjectKaroubiNatTrans","module":"Mathlib.AlgebraicTopology.DoldKan.NCompGamma","initialProofState":"C : Type u_1\ninstâœÂ² : CategoryTheory.Category.{u_2, u_1} C\ninstâœÂ¹ : CategoryTheory.Preadditive C\ninstâœ : CategoryTheory.Limits.HasFiniteCoproducts C\nâŠ¢ CategoryTheory.IsIso AlgebraicTopology.DoldKan.Î“â‚‚Nâ‚.natTrans","decl":"instance : IsIso (Î“â‚‚Nâ‚.natTrans : (Nâ‚ : SimplicialObject C â¥¤ _) â‹™ _ âŸ¶ _) := by\n  have : âˆ€ X : SimplicialObject C, IsIso (Î“â‚‚Nâ‚.natTrans.app X) := by\n    intro X\n    rw [compatibility_Î“â‚‚Nâ‚_Î“â‚‚Nâ‚‚_natTrans]\n    infer_instance\n  apply NatIso.isIso_of_isIso_app\n\n"}
{"name":"AlgebraicTopology.DoldKan.Î“â‚‚Nâ‚‚_inv","module":"Mathlib.AlgebraicTopology.DoldKan.NCompGamma","initialProofState":"C : Type u_1\ninstâœÂ² : CategoryTheory.Category.{u_2, u_1} C\ninstâœÂ¹ : CategoryTheory.Preadditive C\ninstâœ : CategoryTheory.Limits.HasFiniteCoproducts C\nâŠ¢ Eq AlgebraicTopology.DoldKan.Î“â‚‚Nâ‚‚.inv AlgebraicTopology.DoldKan.Î“â‚‚Nâ‚‚.natTrans","decl":"/-- The unit isomorphism of the Dold-Kan equivalence. -/\n@[simps! inv]\ndef Î“â‚‚Nâ‚‚ : ğŸ­ _ â‰… (Nâ‚‚ : Karoubi (SimplicialObject C) â¥¤ _) â‹™ Î“â‚‚ :=\n  (asIso Î“â‚‚Nâ‚‚.natTrans).symm\n\n"}
{"name":"AlgebraicTopology.DoldKan.Î“â‚‚Nâ‚_inv","module":"Mathlib.AlgebraicTopology.DoldKan.NCompGamma","initialProofState":"C : Type u_1\ninstâœÂ² : CategoryTheory.Category.{u_2, u_1} C\ninstâœÂ¹ : CategoryTheory.Preadditive C\ninstâœ : CategoryTheory.Limits.HasFiniteCoproducts C\nâŠ¢ Eq AlgebraicTopology.DoldKan.Î“â‚‚Nâ‚.inv AlgebraicTopology.DoldKan.Î“â‚‚Nâ‚.natTrans","decl":"/-- The natural isomorphism `toKaroubi (SimplicialObject C) â‰… Nâ‚ â‹™ Î“â‚‚`. -/\n@[simps! inv]\ndef Î“â‚‚Nâ‚ : toKaroubi _ â‰… (Nâ‚ : SimplicialObject C â¥¤ _) â‹™ Î“â‚‚ :=\n  (asIso Î“â‚‚Nâ‚.natTrans).symm\n\n"}
