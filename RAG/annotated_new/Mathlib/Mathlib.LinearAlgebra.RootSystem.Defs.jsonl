{"name":"RootPairing.reflection_perm_root","module":"Mathlib.LinearAlgebra.RootSystem.Defs","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nself : RootPairing ι R M N\ni j : ι\n⊢ Eq (HSub.hSub (self.root j) (HSMul.hSMul ((self.toPerfectPairing (self.root j)) (self.coroot i)) (self.root i))) (self.root ((self.reflection_perm i) j))","decl":"/-- Given two perfectly-paired `R`-modules `M` and `N`, a root pairing with indexing set `ι`\nis the data of an `ι`-indexed subset of `M` (\"the roots\"), an `ι`-indexed subset of `N`\n(\"the coroots\"), and an `ι`-indexed set of permutations of `ι`, such that each root-coroot pair\nevaluates to `2`, and the permutation attached to each element of `ι` is compatible with the\nreflections on the corresponding roots and coroots.\n\nIt exists to allow for a convenient unification of the theories of root systems and root data. -/\nstructure RootPairing extends PerfectPairing R M N where\n  /-- A parametrized family of vectors, called roots. -/\n  root : ι ↪ M\n  /-- A parametrized family of dual vectors, called coroots. -/\n  coroot : ι ↪ N\n  root_coroot_two : ∀ i, toLin (root i) (coroot i) = 2\n  /-- A parametrized family of permutations, induced by reflections. This corresponds to the\n      classical requirement that the symmetry attached to each root (later defined in\n      `RootPairing.reflection`) leave the whole set of roots stable: as explained above, we\n      formalize this stability by fixing the image of the roots through each reflection (whence the\n      permutation); and similarly for coroots. -/\n  reflection_perm : ι → (ι ≃ ι)\n  reflection_perm_root : ∀ i j,\n    root j - toPerfectPairing (root j) (coroot i) • root i = root (reflection_perm i j)\n  reflection_perm_coroot : ∀ i j,\n    coroot j - toPerfectPairing (root i) (coroot j) • coroot i = coroot (reflection_perm i j)\n\n"}
{"name":"RootPairing.reflection_perm_coroot","module":"Mathlib.LinearAlgebra.RootSystem.Defs","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nself : RootPairing ι R M N\ni j : ι\n⊢ Eq (HSub.hSub (self.coroot j) (HSMul.hSMul ((self.toPerfectPairing (self.root i)) (self.coroot j)) (self.coroot i))) (self.coroot ((self.reflection_perm i) j))","decl":"/-- Given two perfectly-paired `R`-modules `M` and `N`, a root pairing with indexing set `ι`\nis the data of an `ι`-indexed subset of `M` (\"the roots\"), an `ι`-indexed subset of `N`\n(\"the coroots\"), and an `ι`-indexed set of permutations of `ι`, such that each root-coroot pair\nevaluates to `2`, and the permutation attached to each element of `ι` is compatible with the\nreflections on the corresponding roots and coroots.\n\nIt exists to allow for a convenient unification of the theories of root systems and root data. -/\nstructure RootPairing extends PerfectPairing R M N where\n  /-- A parametrized family of vectors, called roots. -/\n  root : ι ↪ M\n  /-- A parametrized family of dual vectors, called coroots. -/\n  coroot : ι ↪ N\n  root_coroot_two : ∀ i, toLin (root i) (coroot i) = 2\n  /-- A parametrized family of permutations, induced by reflections. This corresponds to the\n      classical requirement that the symmetry attached to each root (later defined in\n      `RootPairing.reflection`) leave the whole set of roots stable: as explained above, we\n      formalize this stability by fixing the image of the roots through each reflection (whence the\n      permutation); and similarly for coroots. -/\n  reflection_perm : ι → (ι ≃ ι)\n  reflection_perm_root : ∀ i j,\n    root j - toPerfectPairing (root j) (coroot i) • root i = root (reflection_perm i j)\n  reflection_perm_coroot : ∀ i j,\n    coroot j - toPerfectPairing (root i) (coroot j) • coroot i = coroot (reflection_perm i j)\n\n"}
{"name":"RootPairing.root_coroot_two","module":"Mathlib.LinearAlgebra.RootSystem.Defs","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nself : RootPairing ι R M N\ni : ι\n⊢ Eq ((self.toLin (self.root i)) (self.coroot i)) 2","decl":"/-- Given two perfectly-paired `R`-modules `M` and `N`, a root pairing with indexing set `ι`\nis the data of an `ι`-indexed subset of `M` (\"the roots\"), an `ι`-indexed subset of `N`\n(\"the coroots\"), and an `ι`-indexed set of permutations of `ι`, such that each root-coroot pair\nevaluates to `2`, and the permutation attached to each element of `ι` is compatible with the\nreflections on the corresponding roots and coroots.\n\nIt exists to allow for a convenient unification of the theories of root systems and root data. -/\nstructure RootPairing extends PerfectPairing R M N where\n  /-- A parametrized family of vectors, called roots. -/\n  root : ι ↪ M\n  /-- A parametrized family of dual vectors, called coroots. -/\n  coroot : ι ↪ N\n  root_coroot_two : ∀ i, toLin (root i) (coroot i) = 2\n  /-- A parametrized family of permutations, induced by reflections. This corresponds to the\n      classical requirement that the symmetry attached to each root (later defined in\n      `RootPairing.reflection`) leave the whole set of roots stable: as explained above, we\n      formalize this stability by fixing the image of the roots through each reflection (whence the\n      permutation); and similarly for coroots. -/\n  reflection_perm : ι → (ι ≃ ι)\n  reflection_perm_root : ∀ i j,\n    root j - toPerfectPairing (root j) (coroot i) • root i = root (reflection_perm i j)\n  reflection_perm_coroot : ∀ i j,\n    coroot j - toPerfectPairing (root i) (coroot j) • coroot i = coroot (reflection_perm i j)\n\n"}
{"name":"RootPairing.mk.injEq","module":"Mathlib.LinearAlgebra.RootSystem.Defs","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\ntoPerfectPairing✝ : PerfectPairing R M N\nroot✝ : Function.Embedding ι M\ncoroot✝ : Function.Embedding ι N\nroot_coroot_two✝ : ∀ (i : ι), Eq ((toPerfectPairing✝.toLin (root✝ i)) (coroot✝ i)) 2\nreflection_perm✝ : ι → Equiv ι ι\nreflection_perm_root✝ : ∀ (i j : ι), Eq (HSub.hSub (root✝ j) (HSMul.hSMul ((toPerfectPairing✝ (root✝ j)) (coroot✝ i)) (root✝ i))) (root✝ ((reflection_perm✝ i) j))\nreflection_perm_coroot✝ : ∀ (i j : ι), Eq (HSub.hSub (coroot✝ j) (HSMul.hSMul ((toPerfectPairing✝ (root✝ i)) (coroot✝ j)) (coroot✝ i))) (coroot✝ ((reflection_perm✝ i) j))\ntoPerfectPairing : PerfectPairing R M N\nroot : Function.Embedding ι M\ncoroot : Function.Embedding ι N\nroot_coroot_two : ∀ (i : ι), Eq ((toPerfectPairing.toLin (root i)) (coroot i)) 2\nreflection_perm : ι → Equiv ι ι\nreflection_perm_root : ∀ (i j : ι), Eq (HSub.hSub (root j) (HSMul.hSMul ((toPerfectPairing (root j)) (coroot i)) (root i))) (root ((reflection_perm i) j))\nreflection_perm_coroot : ∀ (i j : ι), Eq (HSub.hSub (coroot j) (HSMul.hSMul ((toPerfectPairing (root i)) (coroot j)) (coroot i))) (coroot ((reflection_perm i) j))\n⊢ Eq (Eq { toPerfectPairing := toPerfectPairing✝, root := root✝, coroot := coroot✝, root_coroot_two := root_coroot_two✝, reflection_perm := reflection_perm✝, reflection_perm_root := reflection_perm_root✝, reflection_perm_coroot := reflection_perm_coroot✝ } { toPerfectPairing := toPerfectPairing, root := root, coroot := coroot, root_coroot_two := root_coroot_two, reflection_perm := reflection_perm, reflection_perm_root := reflection_perm_root, reflection_perm_coroot := reflection_perm_coroot }) (And (Eq toPerfectPairing✝ toPerfectPairing) (And (Eq root✝ root) (And (Eq coroot✝ coroot) (Eq reflection_perm✝ reflection_perm))))","decl":"/-- Given two perfectly-paired `R`-modules `M` and `N`, a root pairing with indexing set `ι`\nis the data of an `ι`-indexed subset of `M` (\"the roots\"), an `ι`-indexed subset of `N`\n(\"the coroots\"), and an `ι`-indexed set of permutations of `ι`, such that each root-coroot pair\nevaluates to `2`, and the permutation attached to each element of `ι` is compatible with the\nreflections on the corresponding roots and coroots.\n\nIt exists to allow for a convenient unification of the theories of root systems and root data. -/\nstructure RootPairing extends PerfectPairing R M N where\n  /-- A parametrized family of vectors, called roots. -/\n  root : ι ↪ M\n  /-- A parametrized family of dual vectors, called coroots. -/\n  coroot : ι ↪ N\n  root_coroot_two : ∀ i, toLin (root i) (coroot i) = 2\n  /-- A parametrized family of permutations, induced by reflections. This corresponds to the\n      classical requirement that the symmetry attached to each root (later defined in\n      `RootPairing.reflection`) leave the whole set of roots stable: as explained above, we\n      formalize this stability by fixing the image of the roots through each reflection (whence the\n      permutation); and similarly for coroots. -/\n  reflection_perm : ι → (ι ≃ ι)\n  reflection_perm_root : ∀ i j,\n    root j - toPerfectPairing (root j) (coroot i) • root i = root (reflection_perm i j)\n  reflection_perm_coroot : ∀ i j,\n    coroot j - toPerfectPairing (root i) (coroot j) • coroot i = coroot (reflection_perm i j)\n\n"}
{"name":"RootPairing.mk.sizeOf_spec","module":"Mathlib.LinearAlgebra.RootSystem.Defs","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁸ : CommRing R\ninst✝⁷ : AddCommGroup M\ninst✝⁶ : Module R M\ninst✝⁵ : AddCommGroup N\ninst✝⁴ : Module R N\ninst✝³ : SizeOf ι\ninst✝² : SizeOf R\ninst✝¹ : SizeOf M\ninst✝ : SizeOf N\ntoPerfectPairing : PerfectPairing R M N\nroot : Function.Embedding ι M\ncoroot : Function.Embedding ι N\nroot_coroot_two : ∀ (i : ι), Eq ((toPerfectPairing.toLin (root i)) (coroot i)) 2\nreflection_perm : ι → Equiv ι ι\nreflection_perm_root : ∀ (i j : ι), Eq (HSub.hSub (root j) (HSMul.hSMul ((toPerfectPairing (root j)) (coroot i)) (root i))) (root ((reflection_perm i) j))\nreflection_perm_coroot : ∀ (i j : ι), Eq (HSub.hSub (coroot j) (HSMul.hSMul ((toPerfectPairing (root i)) (coroot j)) (coroot i))) (coroot ((reflection_perm i) j))\n⊢ Eq (SizeOf.sizeOf { toPerfectPairing := toPerfectPairing, root := root, coroot := coroot, root_coroot_two := root_coroot_two, reflection_perm := reflection_perm, reflection_perm_root := reflection_perm_root, reflection_perm_coroot := reflection_perm_coroot }) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf toPerfectPairing)) (SizeOf.sizeOf root)) (SizeOf.sizeOf coroot))","decl":"/-- Given two perfectly-paired `R`-modules `M` and `N`, a root pairing with indexing set `ι`\nis the data of an `ι`-indexed subset of `M` (\"the roots\"), an `ι`-indexed subset of `N`\n(\"the coroots\"), and an `ι`-indexed set of permutations of `ι`, such that each root-coroot pair\nevaluates to `2`, and the permutation attached to each element of `ι` is compatible with the\nreflections on the corresponding roots and coroots.\n\nIt exists to allow for a convenient unification of the theories of root systems and root data. -/\nstructure RootPairing extends PerfectPairing R M N where\n  /-- A parametrized family of vectors, called roots. -/\n  root : ι ↪ M\n  /-- A parametrized family of dual vectors, called coroots. -/\n  coroot : ι ↪ N\n  root_coroot_two : ∀ i, toLin (root i) (coroot i) = 2\n  /-- A parametrized family of permutations, induced by reflections. This corresponds to the\n      classical requirement that the symmetry attached to each root (later defined in\n      `RootPairing.reflection`) leave the whole set of roots stable: as explained above, we\n      formalize this stability by fixing the image of the roots through each reflection (whence the\n      permutation); and similarly for coroots. -/\n  reflection_perm : ι → (ι ≃ ι)\n  reflection_perm_root : ∀ i j,\n    root j - toPerfectPairing (root j) (coroot i) • root i = root (reflection_perm i j)\n  reflection_perm_coroot : ∀ i j,\n    coroot j - toPerfectPairing (root i) (coroot j) • coroot i = coroot (reflection_perm i j)\n\n"}
{"name":"RootPairing.mk.inj","module":"Mathlib.LinearAlgebra.RootSystem.Defs","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\ntoPerfectPairing✝ : PerfectPairing R M N\nroot✝ : Function.Embedding ι M\ncoroot✝ : Function.Embedding ι N\nroot_coroot_two✝ : ∀ (i : ι), Eq ((toPerfectPairing✝.toLin (root✝ i)) (coroot✝ i)) 2\nreflection_perm✝ : ι → Equiv ι ι\nreflection_perm_root✝ : ∀ (i j : ι), Eq (HSub.hSub (root✝ j) (HSMul.hSMul ((toPerfectPairing✝ (root✝ j)) (coroot✝ i)) (root✝ i))) (root✝ ((reflection_perm✝ i) j))\nreflection_perm_coroot✝ : ∀ (i j : ι), Eq (HSub.hSub (coroot✝ j) (HSMul.hSMul ((toPerfectPairing✝ (root✝ i)) (coroot✝ j)) (coroot✝ i))) (coroot✝ ((reflection_perm✝ i) j))\ntoPerfectPairing : PerfectPairing R M N\nroot : Function.Embedding ι M\ncoroot : Function.Embedding ι N\nroot_coroot_two : ∀ (i : ι), Eq ((toPerfectPairing.toLin (root i)) (coroot i)) 2\nreflection_perm : ι → Equiv ι ι\nreflection_perm_root : ∀ (i j : ι), Eq (HSub.hSub (root j) (HSMul.hSMul ((toPerfectPairing (root j)) (coroot i)) (root i))) (root ((reflection_perm i) j))\nreflection_perm_coroot : ∀ (i j : ι), Eq (HSub.hSub (coroot j) (HSMul.hSMul ((toPerfectPairing (root i)) (coroot j)) (coroot i))) (coroot ((reflection_perm i) j))\nx✝ : Eq { toPerfectPairing := toPerfectPairing✝, root := root✝, coroot := coroot✝, root_coroot_two := root_coroot_two✝, reflection_perm := reflection_perm✝, reflection_perm_root := reflection_perm_root✝, reflection_perm_coroot := reflection_perm_coroot✝ } { toPerfectPairing := toPerfectPairing, root := root, coroot := coroot, root_coroot_two := root_coroot_two, reflection_perm := reflection_perm, reflection_perm_root := reflection_perm_root, reflection_perm_coroot := reflection_perm_coroot }\n⊢ And (Eq toPerfectPairing✝ toPerfectPairing) (And (Eq root✝ root) (And (Eq coroot✝ coroot) (Eq reflection_perm✝ reflection_perm)))","decl":"/-- Given two perfectly-paired `R`-modules `M` and `N`, a root pairing with indexing set `ι`\nis the data of an `ι`-indexed subset of `M` (\"the roots\"), an `ι`-indexed subset of `N`\n(\"the coroots\"), and an `ι`-indexed set of permutations of `ι`, such that each root-coroot pair\nevaluates to `2`, and the permutation attached to each element of `ι` is compatible with the\nreflections on the corresponding roots and coroots.\n\nIt exists to allow for a convenient unification of the theories of root systems and root data. -/\nstructure RootPairing extends PerfectPairing R M N where\n  /-- A parametrized family of vectors, called roots. -/\n  root : ι ↪ M\n  /-- A parametrized family of dual vectors, called coroots. -/\n  coroot : ι ↪ N\n  root_coroot_two : ∀ i, toLin (root i) (coroot i) = 2\n  /-- A parametrized family of permutations, induced by reflections. This corresponds to the\n      classical requirement that the symmetry attached to each root (later defined in\n      `RootPairing.reflection`) leave the whole set of roots stable: as explained above, we\n      formalize this stability by fixing the image of the roots through each reflection (whence the\n      permutation); and similarly for coroots. -/\n  reflection_perm : ι → (ι ≃ ι)\n  reflection_perm_root : ∀ i j,\n    root j - toPerfectPairing (root j) (coroot i) • root i = root (reflection_perm i j)\n  reflection_perm_coroot : ∀ i j,\n    coroot j - toPerfectPairing (root i) (coroot j) • coroot i = coroot (reflection_perm i j)\n\n"}
{"name":"RootSystem.span_root_eq_top","module":"Mathlib.LinearAlgebra.RootSystem.Defs","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nself : RootSystem ι R M N\n⊢ Eq (Submodule.span R (Set.range ⇑self.root)) Top.top","decl":"/-- A root system is a root pairing for which the roots and coroots span their ambient modules.\n\nNote that this is slightly more general than the usual definition in the sense that `N` is not\nrequired to be the dual of `M`. -/\nstructure RootSystem extends RootPairing ι R M N where\n  span_root_eq_top : span R (range root) = ⊤\n  span_coroot_eq_top : span R (range coroot) = ⊤\n\n"}
{"name":"RootSystem.mk.inj","module":"Mathlib.LinearAlgebra.RootSystem.Defs","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\ntoRootPairing✝ : RootPairing ι R M N\nspan_root_eq_top✝ : Eq (Submodule.span R (Set.range ⇑toRootPairing✝.root)) Top.top\nspan_coroot_eq_top✝ : Eq (Submodule.span R (Set.range ⇑toRootPairing✝.coroot)) Top.top\ntoRootPairing : RootPairing ι R M N\nspan_root_eq_top : Eq (Submodule.span R (Set.range ⇑toRootPairing.root)) Top.top\nspan_coroot_eq_top : Eq (Submodule.span R (Set.range ⇑toRootPairing.coroot)) Top.top\nx✝ : Eq { toRootPairing := toRootPairing✝, span_root_eq_top := span_root_eq_top✝, span_coroot_eq_top := span_coroot_eq_top✝ } { toRootPairing := toRootPairing, span_root_eq_top := span_root_eq_top, span_coroot_eq_top := span_coroot_eq_top }\n⊢ Eq toRootPairing✝ toRootPairing","decl":"/-- A root system is a root pairing for which the roots and coroots span their ambient modules.\n\nNote that this is slightly more general than the usual definition in the sense that `N` is not\nrequired to be the dual of `M`. -/\nstructure RootSystem extends RootPairing ι R M N where\n  span_root_eq_top : span R (range root) = ⊤\n  span_coroot_eq_top : span R (range coroot) = ⊤\n\n"}
{"name":"RootSystem.span_coroot_eq_top","module":"Mathlib.LinearAlgebra.RootSystem.Defs","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nself : RootSystem ι R M N\n⊢ Eq (Submodule.span R (Set.range ⇑self.coroot)) Top.top","decl":"/-- A root system is a root pairing for which the roots and coroots span their ambient modules.\n\nNote that this is slightly more general than the usual definition in the sense that `N` is not\nrequired to be the dual of `M`. -/\nstructure RootSystem extends RootPairing ι R M N where\n  span_root_eq_top : span R (range root) = ⊤\n  span_coroot_eq_top : span R (range coroot) = ⊤\n\n"}
{"name":"RootSystem.mk.injEq","module":"Mathlib.LinearAlgebra.RootSystem.Defs","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\ntoRootPairing✝ : RootPairing ι R M N\nspan_root_eq_top✝ : Eq (Submodule.span R (Set.range ⇑toRootPairing✝.root)) Top.top\nspan_coroot_eq_top✝ : Eq (Submodule.span R (Set.range ⇑toRootPairing✝.coroot)) Top.top\ntoRootPairing : RootPairing ι R M N\nspan_root_eq_top : Eq (Submodule.span R (Set.range ⇑toRootPairing.root)) Top.top\nspan_coroot_eq_top : Eq (Submodule.span R (Set.range ⇑toRootPairing.coroot)) Top.top\n⊢ Eq (Eq { toRootPairing := toRootPairing✝, span_root_eq_top := span_root_eq_top✝, span_coroot_eq_top := span_coroot_eq_top✝ } { toRootPairing := toRootPairing, span_root_eq_top := span_root_eq_top, span_coroot_eq_top := span_coroot_eq_top }) (Eq toRootPairing✝ toRootPairing)","decl":"/-- A root system is a root pairing for which the roots and coroots span their ambient modules.\n\nNote that this is slightly more general than the usual definition in the sense that `N` is not\nrequired to be the dual of `M`. -/\nstructure RootSystem extends RootPairing ι R M N where\n  span_root_eq_top : span R (range root) = ⊤\n  span_coroot_eq_top : span R (range coroot) = ⊤\n\n"}
{"name":"RootSystem.mk.sizeOf_spec","module":"Mathlib.LinearAlgebra.RootSystem.Defs","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁸ : CommRing R\ninst✝⁷ : AddCommGroup M\ninst✝⁶ : Module R M\ninst✝⁵ : AddCommGroup N\ninst✝⁴ : Module R N\ninst✝³ : SizeOf ι\ninst✝² : SizeOf R\ninst✝¹ : SizeOf M\ninst✝ : SizeOf N\ntoRootPairing : RootPairing ι R M N\nspan_root_eq_top : Eq (Submodule.span R (Set.range ⇑toRootPairing.root)) Top.top\nspan_coroot_eq_top : Eq (Submodule.span R (Set.range ⇑toRootPairing.coroot)) Top.top\n⊢ Eq (SizeOf.sizeOf { toRootPairing := toRootPairing, span_root_eq_top := span_root_eq_top, span_coroot_eq_top := span_coroot_eq_top }) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf toRootPairing)) (SizeOf.sizeOf span_root_eq_top)) (SizeOf.sizeOf span_coroot_eq_top))","decl":"/-- A root system is a root pairing for which the roots and coroots span their ambient modules.\n\nNote that this is slightly more general than the usual definition in the sense that `N` is not\nrequired to be the dual of `M`. -/\nstructure RootSystem extends RootPairing ι R M N where\n  span_root_eq_top : span R (range root) = ⊤\n  span_coroot_eq_top : span R (range coroot) = ⊤\n\n"}
{"name":"RootPairing.ne_zero","module":"Mathlib.LinearAlgebra.RootSystem.Defs","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁵ : CommRing R\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\ninst✝² : AddCommGroup N\ninst✝¹ : Module R N\nP : RootPairing ι R M N\ni : ι\ninst✝ : CharZero R\n⊢ Ne (P.root i) 0","decl":"lemma ne_zero [CharZero R] : (P.root i : M) ≠ 0 :=\n  fun h ↦ by simpa [h, map_zero] using P.root_coroot_two i\n\n"}
{"name":"RootPairing.ne_zero'","module":"Mathlib.LinearAlgebra.RootSystem.Defs","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁵ : CommRing R\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\ninst✝² : AddCommGroup N\ninst✝¹ : Module R N\nP : RootPairing ι R M N\ni : ι\ninst✝ : CharZero R\n⊢ Ne (P.coroot i) 0","decl":"lemma ne_zero' [CharZero R] : (P.coroot i : N) ≠ 0 :=\n  fun h ↦ by simpa [h] using P.root_coroot_two i\n\n"}
{"name":"RootPairing.toLin_toPerfectPairing","module":"Mathlib.LinearAlgebra.RootSystem.Defs","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nP : RootPairing ι R M N\nx : M\ny : N\n⊢ Eq ((P.toLin x) y) ((P.toPerfectPairing x) y)","decl":"@[simp]\nlemma toLin_toPerfectPairing (x : M) (y : N) : P.toLin x y = P.toPerfectPairing x y :=\n  rfl\n\n"}
{"name":"RootPairing.flip_flip","module":"Mathlib.LinearAlgebra.RootSystem.Defs","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nP : RootPairing ι R M N\n⊢ Eq P.flip.flip P","decl":"@[simp]\nlemma flip_flip : P.flip.flip = P :=\n  rfl\n\n"}
{"name":"RootPairing.flipEquiv_apply","module":"Mathlib.LinearAlgebra.RootSystem.Defs","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nP : RootPairing ι R N M\n⊢ Eq ((RootPairing.flipEquiv ι R M N) P) P.flip","decl":"variable (ι R M N) in\n/-- `RootPairing.flip` as an equivalence. -/\n@[simps] def flipEquiv : RootPairing ι R N M ≃ RootPairing ι R M N where\n  toFun P := P.flip\n  invFun P := P.flip\n  left_inv _ := rfl\n  right_inv _ := rfl\n\n"}
{"name":"RootPairing.flipEquiv_symm_apply","module":"Mathlib.LinearAlgebra.RootSystem.Defs","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nP : RootPairing ι R M N\n⊢ Eq ((RootPairing.flipEquiv ι R M N).symm P) P.flip","decl":"variable (ι R M N) in\n/-- `RootPairing.flip` as an equivalence. -/\n@[simps] def flipEquiv : RootPairing ι R N M ≃ RootPairing ι R M N where\n  toFun P := P.flip\n  invFun P := P.flip\n  left_inv _ := rfl\n  right_inv _ := rfl\n\n"}
{"name":"RootSystem.flip_flip","module":"Mathlib.LinearAlgebra.RootSystem.Defs","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nP : RootSystem ι R M N\n⊢ Eq P.flip.flip P","decl":"@[simp]\nprotected lemma _root_.RootSystem.flip_flip (P : RootSystem ι R M N) :\n    P.flip.flip = P :=\n  rfl\n\n"}
{"name":"RootSystem.flipEquiv_apply","module":"Mathlib.LinearAlgebra.RootSystem.Defs","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nP : RootSystem ι R N M\n⊢ Eq ((RootSystem.flipEquiv ι R M N) P) P.flip","decl":"variable (ι R M N) in\n/-- `RootSystem.flip` as an equivalence. -/\n@[simps] def _root_.RootSystem.flipEquiv : RootSystem ι R N M ≃ RootSystem ι R M N where\n  toFun P := P.flip\n  invFun P := P.flip\n  left_inv _ := rfl\n  right_inv _ := rfl\n\n"}
{"name":"RootSystem.flipEquiv_symm_apply","module":"Mathlib.LinearAlgebra.RootSystem.Defs","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nP : RootSystem ι R M N\n⊢ Eq ((RootSystem.flipEquiv ι R M N).symm P) P.flip","decl":"variable (ι R M N) in\n/-- `RootSystem.flip` as an equivalence. -/\n@[simps] def _root_.RootSystem.flipEquiv : RootSystem ι R N M ≃ RootSystem ι R M N where\n  toFun P := P.flip\n  invFun P := P.flip\n  left_inv _ := rfl\n  right_inv _ := rfl\n\n"}
{"name":"RootPairing.root_coroot_eq_pairing","module":"Mathlib.LinearAlgebra.RootSystem.Defs","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nP : RootPairing ι R M N\ni j : ι\n⊢ Eq ((P.toPerfectPairing (P.root i)) (P.coroot j)) (P.pairing i j)","decl":"@[simp]\nlemma root_coroot_eq_pairing : P.toPerfectPairing (P.root i) (P.coroot j) = P.pairing i j :=\n  rfl\n\n"}
{"name":"RootPairing.root'_coroot_eq_pairing","module":"Mathlib.LinearAlgebra.RootSystem.Defs","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nP : RootPairing ι R M N\ni j : ι\n⊢ Eq ((P.root' i) (P.coroot j)) (P.pairing i j)","decl":"@[simp]\nlemma root'_coroot_eq_pairing : P.root' i (P.coroot j) = P.pairing i j :=\n  rfl\n\n"}
{"name":"RootPairing.root_coroot'_eq_pairing","module":"Mathlib.LinearAlgebra.RootSystem.Defs","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nP : RootPairing ι R M N\ni j : ι\n⊢ Eq ((P.coroot' i) (P.root j)) (P.pairing j i)","decl":"@[simp]\nlemma root_coroot'_eq_pairing : P.coroot' i (P.root j) = P.pairing j i :=\n  rfl\n\n"}
{"name":"RootPairing.coroot_root_eq_pairing","module":"Mathlib.LinearAlgebra.RootSystem.Defs","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nP : RootPairing ι R M N\ni j : ι\n⊢ Eq ((P.toLin.flip (P.coroot i)) (P.root j)) (P.pairing j i)","decl":"lemma coroot_root_eq_pairing : P.toLin.flip (P.coroot i) (P.root j) = P.pairing j i := by\n  simp\n\n"}
{"name":"RootPairing.pairing_same","module":"Mathlib.LinearAlgebra.RootSystem.Defs","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nP : RootPairing ι R M N\ni : ι\n⊢ Eq (P.pairing i i) 2","decl":"@[simp]\nlemma pairing_same : P.pairing i i = 2 := P.root_coroot_two i\n\n"}
{"name":"RootPairing.coroot_root_two","module":"Mathlib.LinearAlgebra.RootSystem.Defs","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nP : RootPairing ι R M N\ni : ι\n⊢ Eq ((P.toLin.flip (P.coroot i)) (P.root i)) 2","decl":"lemma coroot_root_two :\n    P.toLin.flip (P.coroot i) (P.root i) = 2 := by\n  simp\n\n"}
{"name":"RootPairing.root_reflection_perm","module":"Mathlib.LinearAlgebra.RootSystem.Defs","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nP : RootPairing ι R M N\ni j : ι\n⊢ Eq (P.root ((P.reflection_perm i) j)) ((P.reflection i) (P.root j))","decl":"@[simp]\nlemma root_reflection_perm (j : ι) :\n    P.root (P.reflection_perm i j) = (P.reflection i) (P.root j) :=\n  (P.reflection_perm_root i j).symm\n\n"}
{"name":"RootPairing.mapsTo_reflection_root","module":"Mathlib.LinearAlgebra.RootSystem.Defs","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nP : RootPairing ι R M N\ni : ι\n⊢ Set.MapsTo (⇑(P.reflection i)) (Set.range ⇑P.root) (Set.range ⇑P.root)","decl":"theorem mapsTo_reflection_root :\n    MapsTo (P.reflection i) (range P.root) (range P.root) := by\n  rintro - ⟨j, rfl⟩\n  exact P.root_reflection_perm i j ▸ mem_range_self (P.reflection_perm i j)\n\n"}
{"name":"RootPairing.reflection_apply","module":"Mathlib.LinearAlgebra.RootSystem.Defs","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nP : RootPairing ι R M N\ni : ι\nx : M\n⊢ Eq ((P.reflection i) x) (HSub.hSub x (HSMul.hSMul ((P.coroot' i) x) (P.root i)))","decl":"lemma reflection_apply (x : M) :\n    P.reflection i x = x - (P.coroot' i x) • P.root i :=\n  rfl\n\n"}
{"name":"RootPairing.reflection_apply_root","module":"Mathlib.LinearAlgebra.RootSystem.Defs","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nP : RootPairing ι R M N\ni j : ι\n⊢ Eq ((P.reflection i) (P.root j)) (HSub.hSub (P.root j) (HSMul.hSMul (P.pairing j i) (P.root i)))","decl":"lemma reflection_apply_root :\n    P.reflection i (P.root j) = P.root j - (P.pairing j i) • P.root i :=\n  rfl\n\n"}
{"name":"RootPairing.reflection_apply_self","module":"Mathlib.LinearAlgebra.RootSystem.Defs","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nP : RootPairing ι R M N\ni : ι\n⊢ Eq ((P.reflection i) (P.root i)) (Neg.neg (P.root i))","decl":"@[simp]\nlemma reflection_apply_self :\n    P.reflection i (P.root i) = - P.root i :=\n  Module.reflection_apply_self (P.coroot_root_two i)\n\n"}
{"name":"RootPairing.reflection_same","module":"Mathlib.LinearAlgebra.RootSystem.Defs","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nP : RootPairing ι R M N\ni : ι\nx : M\n⊢ Eq ((P.reflection i) ((P.reflection i) x)) x","decl":"@[simp]\nlemma reflection_same (x : M) :\n    P.reflection i (P.reflection i x) = x :=\n  Module.involutive_reflection (P.coroot_root_two i) x\n\n"}
{"name":"RootPairing.reflection_inv","module":"Mathlib.LinearAlgebra.RootSystem.Defs","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nP : RootPairing ι R M N\ni : ι\n⊢ Eq (Inv.inv (P.reflection i)) (P.reflection i)","decl":"@[simp]\nlemma reflection_inv :\n    (P.reflection i)⁻¹ = P.reflection i :=\n  rfl\n\n"}
{"name":"RootPairing.reflection_sq","module":"Mathlib.LinearAlgebra.RootSystem.Defs","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nP : RootPairing ι R M N\ni : ι\n⊢ Eq (HPow.hPow (P.reflection i) 2) 1","decl":"@[simp]\nlemma reflection_sq :\n    P.reflection i ^ 2 = 1 :=\n  mul_eq_one_iff_eq_inv.mpr rfl\n\n"}
{"name":"RootPairing.reflection_perm_sq","module":"Mathlib.LinearAlgebra.RootSystem.Defs","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nP : RootPairing ι R M N\ni : ι\n⊢ Eq (HPow.hPow (P.reflection_perm i) 2) 1","decl":"@[simp]\nlemma reflection_perm_sq :\n    P.reflection_perm i ^ 2 = 1 := by\n  ext j\n  apply P.root.injective\n  simp only [sq, Equiv.Perm.mul_apply, root_reflection_perm, reflection_same, Equiv.Perm.one_apply]\n\n"}
{"name":"RootPairing.reflection_perm_inv","module":"Mathlib.LinearAlgebra.RootSystem.Defs","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nP : RootPairing ι R M N\ni : ι\n⊢ Eq (Inv.inv (P.reflection_perm i)) (P.reflection_perm i)","decl":"@[simp]\nlemma reflection_perm_inv :\n    (P.reflection_perm i)⁻¹ = P.reflection_perm i :=\n  (mul_eq_one_iff_eq_inv.mp <| P.reflection_perm_sq i).symm\n\n"}
{"name":"RootPairing.reflection_perm_self","module":"Mathlib.LinearAlgebra.RootSystem.Defs","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nP : RootPairing ι R M N\ni j : ι\n⊢ Eq ((P.reflection_perm i) ((P.reflection_perm i) j)) j","decl":"@[simp]\nlemma reflection_perm_self : P.reflection_perm i (P.reflection_perm i j) = j := by\n  apply P.root.injective\n  simp only [root_reflection_perm, reflection_same]\n\n"}
{"name":"RootPairing.reflection_perm_involutive","module":"Mathlib.LinearAlgebra.RootSystem.Defs","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nP : RootPairing ι R M N\ni : ι\n⊢ Function.Involutive ⇑(P.reflection_perm i)","decl":"lemma reflection_perm_involutive : Involutive (P.reflection_perm i) :=\n  involutive_iff_iter_2_eq_id.mpr (by ext; simp)\n\n"}
{"name":"RootPairing.reflection_perm_symm","module":"Mathlib.LinearAlgebra.RootSystem.Defs","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nP : RootPairing ι R M N\ni : ι\n⊢ Eq (P.reflection_perm i).symm (P.reflection_perm i)","decl":"@[simp]\nlemma reflection_perm_symm : (P.reflection_perm i).symm = P.reflection_perm i :=\n  Involutive.symm_eq_self_of_involutive (P.reflection_perm i) <| P.reflection_perm_involutive i\n\n"}
{"name":"RootPairing.bijOn_reflection_root","module":"Mathlib.LinearAlgebra.RootSystem.Defs","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nP : RootPairing ι R M N\ni : ι\n⊢ Set.BijOn (⇑(P.reflection i)) (Set.range ⇑P.root) (Set.range ⇑P.root)","decl":"lemma bijOn_reflection_root :\n    BijOn (P.reflection i) (range P.root) (range P.root) :=\n  Module.bijOn_reflection_of_mapsTo _ <| P.mapsTo_reflection_root i\n\n"}
{"name":"RootPairing.reflection_image_eq","module":"Mathlib.LinearAlgebra.RootSystem.Defs","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nP : RootPairing ι R M N\ni : ι\n⊢ Eq (Set.image (⇑(P.reflection i)) (Set.range ⇑P.root)) (Set.range ⇑P.root)","decl":"@[simp]\nlemma reflection_image_eq :\n    P.reflection i '' (range P.root) = range P.root :=\n  (P.bijOn_reflection_root i).image_eq\n\n"}
{"name":"RootPairing.coroot_reflection_perm","module":"Mathlib.LinearAlgebra.RootSystem.Defs","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nP : RootPairing ι R M N\ni j : ι\n⊢ Eq (P.coroot ((P.reflection_perm i) j)) ((P.coreflection i) (P.coroot j))","decl":"@[simp]\nlemma coroot_reflection_perm (j : ι) :\n    P.coroot (P.reflection_perm i j) = (P.coreflection i) (P.coroot j) :=\n  (P.reflection_perm_coroot i j).symm\n\n"}
{"name":"RootPairing.mapsTo_coreflection_coroot","module":"Mathlib.LinearAlgebra.RootSystem.Defs","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nP : RootPairing ι R M N\ni : ι\n⊢ Set.MapsTo (⇑(P.coreflection i)) (Set.range ⇑P.coroot) (Set.range ⇑P.coroot)","decl":"theorem mapsTo_coreflection_coroot :\n    MapsTo (P.coreflection i) (range P.coroot) (range P.coroot) := by\n  rintro - ⟨j, rfl⟩\n  exact P.coroot_reflection_perm i j ▸ mem_range_self (P.reflection_perm i j)\n\n"}
{"name":"RootPairing.coreflection_apply","module":"Mathlib.LinearAlgebra.RootSystem.Defs","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nP : RootPairing ι R M N\ni : ι\nf : N\n⊢ Eq ((P.coreflection i) f) (HSub.hSub f (HSMul.hSMul ((P.root' i) f) (P.coroot i)))","decl":"lemma coreflection_apply (f : N) :\n    P.coreflection i f = f - (P.root' i) f • P.coroot i :=\n  rfl\n\n"}
{"name":"RootPairing.coreflection_apply_coroot","module":"Mathlib.LinearAlgebra.RootSystem.Defs","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nP : RootPairing ι R M N\ni j : ι\n⊢ Eq ((P.coreflection i) (P.coroot j)) (HSub.hSub (P.coroot j) (HSMul.hSMul (P.pairing i j) (P.coroot i)))","decl":"lemma coreflection_apply_coroot :\n    P.coreflection i (P.coroot j) = P.coroot j - (P.pairing i j) • P.coroot i :=\n  rfl\n\n"}
{"name":"RootPairing.coreflection_apply_self","module":"Mathlib.LinearAlgebra.RootSystem.Defs","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nP : RootPairing ι R M N\ni : ι\n⊢ Eq ((P.coreflection i) (P.coroot i)) (Neg.neg (P.coroot i))","decl":"@[simp]\nlemma coreflection_apply_self :\n    P.coreflection i (P.coroot i) = - P.coroot i :=\n  Module.reflection_apply_self (P.flip.coroot_root_two i)\n\n"}
{"name":"RootPairing.coreflection_same","module":"Mathlib.LinearAlgebra.RootSystem.Defs","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nP : RootPairing ι R M N\ni : ι\nx : N\n⊢ Eq ((P.coreflection i) ((P.coreflection i) x)) x","decl":"@[simp]\nlemma coreflection_same (x : N) :\n    P.coreflection i (P.coreflection i x) = x :=\n  Module.involutive_reflection (P.flip.coroot_root_two i) x\n\n"}
{"name":"RootPairing.coreflection_inv","module":"Mathlib.LinearAlgebra.RootSystem.Defs","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nP : RootPairing ι R M N\ni : ι\n⊢ Eq (Inv.inv (P.coreflection i)) (P.coreflection i)","decl":"@[simp]\nlemma coreflection_inv :\n    (P.coreflection i)⁻¹ = P.coreflection i :=\n  rfl\n\n"}
{"name":"RootPairing.coreflection_sq","module":"Mathlib.LinearAlgebra.RootSystem.Defs","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nP : RootPairing ι R M N\ni : ι\n⊢ Eq (HPow.hPow (P.coreflection i) 2) 1","decl":"@[simp]\nlemma coreflection_sq :\n    P.coreflection i ^ 2 = 1 :=\n  mul_eq_one_iff_eq_inv.mpr rfl\n\n"}
{"name":"RootPairing.bijOn_coreflection_coroot","module":"Mathlib.LinearAlgebra.RootSystem.Defs","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nP : RootPairing ι R M N\ni : ι\n⊢ Set.BijOn (⇑(P.coreflection i)) (Set.range ⇑P.coroot) (Set.range ⇑P.coroot)","decl":"lemma bijOn_coreflection_coroot : BijOn (P.coreflection i) (range P.coroot) (range P.coroot) :=\n  bijOn_reflection_root P.flip i\n\n"}
{"name":"RootPairing.coreflection_image_eq","module":"Mathlib.LinearAlgebra.RootSystem.Defs","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nP : RootPairing ι R M N\ni : ι\n⊢ Eq (Set.image (⇑(P.coreflection i)) (Set.range ⇑P.coroot)) (Set.range ⇑P.coroot)","decl":"@[simp]\nlemma coreflection_image_eq :\n    P.coreflection i '' (range P.coroot) = range P.coroot :=\n  (P.bijOn_coreflection_coroot i).image_eq\n\n"}
{"name":"RootPairing.coreflection_eq_flip_reflection","module":"Mathlib.LinearAlgebra.RootSystem.Defs","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nP : RootPairing ι R M N\ni : ι\n⊢ Eq (P.coreflection i) (P.flip.reflection i)","decl":"lemma coreflection_eq_flip_reflection :\n    P.coreflection i = P.flip.reflection i :=\n  rfl\n\n"}
{"name":"RootPairing.reflection_dualMap_eq_coreflection","module":"Mathlib.LinearAlgebra.RootSystem.Defs","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nP : RootPairing ι R M N\ni : ι\n⊢ Eq ((↑(P.reflection i).dualMap).comp P.toLin.flip) (P.toLin.flip.comp ↑(P.coreflection i))","decl":"lemma reflection_dualMap_eq_coreflection :\n    (P.reflection i).dualMap ∘ₗ P.toLin.flip = P.toLin.flip ∘ₗ P.coreflection i := by\n  ext n m\n  simp [map_sub, coreflection_apply, reflection_apply, mul_comm (P.toPerfectPairing m (P.coroot i))]\n\n"}
{"name":"RootPairing.coroot_eq_coreflection_of_root_eq","module":"Mathlib.LinearAlgebra.RootSystem.Defs","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nP : RootPairing ι R M N\ni j k : ι\nhk : Eq (P.root k) ((P.reflection i) (P.root j))\n⊢ Eq (P.coroot k) ((P.coreflection i) (P.coroot j))","decl":"lemma coroot_eq_coreflection_of_root_eq\n    {i j k : ι} (hk : P.root k = P.reflection i (P.root j)) :\n    P.coroot k = P.coreflection i (P.coroot j) := by\n  rw [← P.root_reflection_perm, EmbeddingLike.apply_eq_iff_eq] at hk\n  rw [← P.coroot_reflection_perm, hk]\n\n"}
{"name":"RootPairing.coroot'_reflection_perm","module":"Mathlib.LinearAlgebra.RootSystem.Defs","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nP : RootPairing ι R M N\ni j : ι\n⊢ Eq (P.coroot' ((P.reflection_perm i) j)) (LinearMap.comp (P.coroot' j) ↑(P.reflection i))","decl":"lemma coroot'_reflection_perm {i j : ι} :\n    P.coroot' (P.reflection_perm i j) = P.coroot' j ∘ₗ P.reflection i := by\n  ext y\n  simp [coreflection_apply_coroot, reflection_apply, map_sub, mul_comm]\n\n"}
{"name":"RootPairing.coroot'_reflection","module":"Mathlib.LinearAlgebra.RootSystem.Defs","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nP : RootPairing ι R M N\ni j : ι\ny : M\n⊢ Eq ((P.coroot' j) ((P.reflection i) y)) ((P.coroot' ((P.reflection_perm i) j)) y)","decl":"lemma coroot'_reflection {i j : ι} (y : M) :\n    P.coroot' j (P.reflection i y) = P.coroot' (P.reflection_perm i j) y :=\n  (LinearMap.congr_fun P.coroot'_reflection_perm y).symm\n\n"}
{"name":"RootPairing.pairing_reflection_perm","module":"Mathlib.LinearAlgebra.RootSystem.Defs","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nP : RootPairing ι R M N\ni j k : ι\n⊢ Eq (P.pairing j ((P.reflection_perm i) k)) (P.pairing ((P.reflection_perm i) j) k)","decl":"lemma pairing_reflection_perm (i j k : ι) :\n    P.pairing j (P.reflection_perm i k) = P.pairing (P.reflection_perm i j) k := by\n  simp only [pairing, root', coroot_reflection_perm, root_reflection_perm]\n  simp only [coreflection_apply_coroot, map_sub, map_smul, smul_eq_mul,\n    reflection_apply_root]\n  simp only [← toLin_toPerfectPairing, map_smul, LinearMap.smul_apply, map_sub, map_smul,\n    LinearMap.sub_apply, smul_eq_mul]\n  simp only [PerfectPairing.toLin_apply, root'_coroot_eq_pairing, sub_right_inj, mul_comm]\n\n"}
{"name":"RootPairing.pairing_reflection_perm_self_left","module":"Mathlib.LinearAlgebra.RootSystem.Defs","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nP : RootPairing ι R M N\ni j : ι\n⊢ Eq (P.pairing ((P.reflection_perm i) i) j) (Neg.neg (P.pairing i j))","decl":"@[simp]\nlemma pairing_reflection_perm_self_left (P : RootPairing ι R M N) (i j : ι) :\n    P.pairing (P.reflection_perm i i) j = - P.pairing i j := by\n  rw [pairing, root', ← reflection_perm_root, root'_coroot_eq_pairing, pairing_same, two_smul,\n    sub_add_cancel_left, ← toLin_toPerfectPairing, LinearMap.map_neg₂, toLin_toPerfectPairing,\n    root'_coroot_eq_pairing]\n\n"}
{"name":"RootPairing.pairing_reflection_perm_self_right","module":"Mathlib.LinearAlgebra.RootSystem.Defs","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nP : RootPairing ι R M N\ni j : ι\n⊢ Eq (P.pairing i ((P.reflection_perm j) j)) (Neg.neg (P.pairing i j))","decl":"@[simp]\nlemma pairing_reflection_perm_self_right (i j : ι) :\n    P.pairing i (P.reflection_perm j j) = - P.pairing i j := by\n  rw [pairing, ← reflection_perm_coroot, root_coroot_eq_pairing, pairing_same, two_smul,\n    sub_add_cancel_left, ← toLin_toPerfectPairing, map_neg, toLin_toPerfectPairing,\n    root_coroot_eq_pairing]\n\n"}
{"name":"RootPairing.IsValuedIn.exists_value","module":"Mathlib.LinearAlgebra.RootSystem.Defs","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁶ : CommRing R\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\ninst✝³ : AddCommGroup N\ninst✝² : Module R N\nP : RootPairing ι R M N\nS : Type u_5\ninst✝¹ : CommRing S\ninst✝ : Algebra S R\nself : P.IsValuedIn S\ni j : ι\n⊢ Exists fun s => Eq ((algebraMap S R) s) (P.pairing i j)","decl":"/-- If `R` is an `S`-algebra, a root pairing over `R` is said to be valued in `S` if the pairing\nbetween a root and coroot always belongs to `S`.\n\nOf particular interest is the case `S = ℤ`. See `RootPairing.IsCrystallographic`. -/\n@[mk_iff]\nclass IsValuedIn (S : Type*) [CommRing S] [Algebra S R] : Prop where\n  exists_value : ∀ i j, ∃ s, algebraMap S R s = P.pairing i j\n\n"}
{"name":"RootPairing.isValuedIn_iff","module":"Mathlib.LinearAlgebra.RootSystem.Defs","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁶ : CommRing R\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\ninst✝³ : AddCommGroup N\ninst✝² : Module R N\nP : RootPairing ι R M N\nS : Type u_5\ninst✝¹ : CommRing S\ninst✝ : Algebra S R\n⊢ Iff (P.IsValuedIn S) (∀ (i j : ι), Exists fun s => Eq ((algebraMap S R) s) (P.pairing i j))","decl":"/-- If `R` is an `S`-algebra, a root pairing over `R` is said to be valued in `S` if the pairing\nbetween a root and coroot always belongs to `S`.\n\nOf particular interest is the case `S = ℤ`. See `RootPairing.IsCrystallographic`. -/\n@[mk_iff]\nclass IsValuedIn (S : Type*) [CommRing S] [Algebra S R] : Prop where\n  exists_value : ∀ i j, ∃ s, algebraMap S R s = P.pairing i j\n\n"}
{"name":"RootPairing.exists_value","module":"Mathlib.LinearAlgebra.RootSystem.Defs","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁶ : CommRing R\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\ninst✝³ : AddCommGroup N\ninst✝² : Module R N\nP : RootPairing ι R M N\nS : Type u_5\ninst✝¹ : CommRing S\ninst✝ : Algebra S R\nself : P.IsValuedIn S\ni j : ι\n⊢ Exists fun s => Eq ((algebraMap S R) s) (P.pairing i j)","decl":"protected alias exists_value := IsValuedIn.exists_value\n\n"}
{"name":"RootPairing.instIsValuedIn","module":"Mathlib.LinearAlgebra.RootSystem.Defs","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nP : RootPairing ι R M N\n⊢ P.IsValuedIn R","decl":"instance : P.IsValuedIn R where\n  exists_value i j := by simp\n\n"}
{"name":"RootPairing.isValuedIn_iff_mem_range","module":"Mathlib.LinearAlgebra.RootSystem.Defs","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁶ : CommRing R\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\ninst✝³ : AddCommGroup N\ninst✝² : Module R N\nP : RootPairing ι R M N\nS : Type u_5\ninst✝¹ : CommRing S\ninst✝ : Algebra S R\n⊢ Iff (P.IsValuedIn S) (∀ (i j : ι), Membership.mem (Set.range ⇑(algebraMap S R)) (P.pairing i j))","decl":"variable {S} in\nlemma isValuedIn_iff_mem_range :\n    P.IsValuedIn S ↔ ∀ i j, P.pairing i j ∈ range (algebraMap S R) := by\n  simp only [isValuedIn_iff, mem_range]\n\n"}
{"name":"RootPairing.instIsValuedIn_1","module":"Mathlib.LinearAlgebra.RootSystem.Defs","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nP : RootPairing ι R M N\n⊢ P.IsValuedIn R","decl":"instance : P.IsValuedIn R where\n  exists_value := by simp\n\n"}
{"name":"RootPairing.instIsValuedInFlip","module":"Mathlib.LinearAlgebra.RootSystem.Defs","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁷ : CommRing R\ninst✝⁶ : AddCommGroup M\ninst✝⁵ : Module R M\ninst✝⁴ : AddCommGroup N\ninst✝³ : Module R N\nP : RootPairing ι R M N\nS : Type u_5\ninst✝² : CommRing S\ninst✝¹ : Algebra S R\ninst✝ : P.IsValuedIn S\n⊢ P.flip.IsValuedIn S","decl":"instance [P.IsValuedIn S] : P.flip.IsValuedIn S := by\n  rw [isValuedIn_iff, forall_comm]\n  exact P.exists_value\n\n"}
{"name":"RootPairing.algebraMap_pairingIn","module":"Mathlib.LinearAlgebra.RootSystem.Defs","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁷ : CommRing R\ninst✝⁶ : AddCommGroup M\ninst✝⁵ : Module R M\ninst✝⁴ : AddCommGroup N\ninst✝³ : Module R N\nP : RootPairing ι R M N\nS : Type u_5\ninst✝² : CommRing S\ninst✝¹ : Algebra S R\ninst✝ : P.IsValuedIn S\ni j : ι\n⊢ Eq ((algebraMap S R) (P.pairingIn S i j)) (P.pairing i j)","decl":"@[simp]\nlemma algebraMap_pairingIn [P.IsValuedIn S] (i j : ι) :\n    algebraMap S R (P.pairingIn S i j) = P.pairing i j :=\n  (P.exists_value i j).choose_spec\n\n"}
{"name":"RootPairing.IsValuedIn.trans","module":"Mathlib.LinearAlgebra.RootSystem.Defs","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝¹¹ : CommRing R\ninst✝¹⁰ : AddCommGroup M\ninst✝⁹ : Module R M\ninst✝⁸ : AddCommGroup N\ninst✝⁷ : Module R N\nP : RootPairing ι R M N\nS : Type u_5\ninst✝⁶ : CommRing S\ninst✝⁵ : Algebra S R\nT : Type u_6\ninst✝⁴ : CommRing T\ninst✝³ : Algebra T S\ninst✝² : Algebra T R\ninst✝¹ : IsScalarTower T S R\ninst✝ : P.IsValuedIn T\n⊢ P.IsValuedIn S","decl":"lemma IsValuedIn.trans (T : Type*) [CommRing T] [Algebra T S] [Algebra T R] [IsScalarTower T S R]\n    [P.IsValuedIn T] :\n    P.IsValuedIn S where\n  exists_value i j := by\n    use algebraMap T S (P.pairingIn T i j)\n    simp [← RingHom.comp_apply, ← IsScalarTower.algebraMap_eq T S R]\n\n"}
{"name":"RootPairing.isReduced_iff","module":"Mathlib.LinearAlgebra.RootSystem.Defs","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nP : RootPairing ι R M N\n⊢ Iff P.IsReduced (∀ (i j : ι), Ne i j → Not (LinearIndependent R (Matrix.vecCons (P.root i) (Matrix.vecCons (P.root j) Matrix.vecEmpty))) → Eq (P.root i) (Neg.neg (P.root j)))","decl":"lemma isReduced_iff : P.IsReduced ↔ ∀ i j : ι, i ≠ j →\n    ¬ LinearIndependent R ![P.root i, P.root j] → P.root i = - P.root j := by\n  rw [IsReduced]\n  refine ⟨fun h i j hij hLin ↦ ?_, fun h i j hLin  ↦ ?_⟩\n  · specialize h i j hLin\n    simp_all only [ne_eq, EmbeddingLike.apply_eq_iff_eq, false_or]\n  · by_cases h' : i = j\n    · exact Or.inl (congrArg P.root h')\n    · exact Or.inr (h i j h' hLin)\n\n"}
{"name":"RootPairing.smul_coroot_eq_of_root_eq_smul","module":"Mathlib.LinearAlgebra.RootSystem.Defs","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁶ : CommRing R\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\ninst✝³ : AddCommGroup N\ninst✝² : Module R N\nP : RootPairing ι R M N\ninst✝¹ : Finite ι\ninst✝ : NoZeroSMulDivisors Int N\ni j : ι\nt : R\nh : Eq (P.root j) (HSMul.hSMul t (P.root i))\n⊢ Eq (HSMul.hSMul t (P.coroot j)) (P.coroot i)","decl":"variable {P} in\nlemma smul_coroot_eq_of_root_eq_smul [Finite ι] [NoZeroSMulDivisors ℤ N] (i j : ι) (t : R)\n    (h : P.root j = t • P.root i) :\n    t • P.coroot j = P.coroot i := by\n  have hij : t * P.pairing i j = 2 := by simpa using ((P.coroot' j).congr_arg h).symm\n  refine Module.eq_of_mapsTo_reflection_of_mem (f := P.root' i) (g := P.root' i)\n    (finite_range P.coroot) (by simp [hij]) (by simp) (by simp [hij]) (by simp) ?_\n    (P.mapsTo_coreflection_coroot i) (mem_range_self i)\n  convert P.mapsTo_coreflection_coroot j\n  ext x\n  replace h : P.root' j = t • P.root' i := by ext; simp [h, root']\n  simp [Module.preReflection_apply, coreflection_apply, h, smul_comm _ t, mul_smul]\n\n"}
{"name":"RootPairing.coroot_eq_smul_coroot_iff","module":"Mathlib.LinearAlgebra.RootSystem.Defs","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁷ : CommRing R\ninst✝⁶ : AddCommGroup M\ninst✝⁵ : Module R M\ninst✝⁴ : AddCommGroup N\ninst✝³ : Module R N\nP : RootPairing ι R M N\ninst✝² : Finite ι\ninst✝¹ : NoZeroSMulDivisors Int M\ninst✝ : NoZeroSMulDivisors Int N\ni j : ι\nt : R\n⊢ Iff (Eq (P.coroot i) (HSMul.hSMul t (P.coroot j))) (Eq (P.root j) (HSMul.hSMul t (P.root i)))","decl":"variable {P} in\n@[simp] lemma coroot_eq_smul_coroot_iff [Finite ι] [NoZeroSMulDivisors ℤ M] [NoZeroSMulDivisors ℤ N]\n    {i j : ι} {t : R} :\n    P.coroot i = t • P.coroot j ↔ P.root j = t • P.root i :=\n  ⟨fun h ↦ (P.flip.smul_coroot_eq_of_root_eq_smul j i t h).symm,\n    fun h ↦ (P.smul_coroot_eq_of_root_eq_smul i j t h).symm⟩\n\n"}
{"name":"RootPairing.coe_rootSpan_dualAnnihilator_map","module":"Mathlib.LinearAlgebra.RootSystem.Defs","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nP : RootPairing ι R M N\n⊢ Eq (↑(Submodule.map P.toDualRight.symm P.rootSpan.dualAnnihilator)) (setOf fun x => ∀ (i : ι), Eq ((P.root' i) x) 0)","decl":"lemma coe_rootSpan_dualAnnihilator_map :\n    P.rootSpan.dualAnnihilator.map P.toDualRight.symm = {x | ∀ i, P.root' i x = 0} := by\n  ext x\n  rw [rootSpan, Submodule.map_coe, Submodule.coe_dualAnnihilator_span]\n  change x ∈ P.toDualRight.toEquiv.symm '' _ ↔ _\n  rw [← Equiv.setOf_apply_symm_eq_image_setOf, Equiv.symm_symm]\n  simp [Set.range_subset_iff]\n\n"}
{"name":"RootPairing.coe_corootSpan_dualAnnihilator_map","module":"Mathlib.LinearAlgebra.RootSystem.Defs","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nP : RootPairing ι R M N\n⊢ Eq (↑(Submodule.map P.toDualLeft.symm P.corootSpan.dualAnnihilator)) (setOf fun x => ∀ (i : ι), Eq ((P.coroot' i) x) 0)","decl":"lemma coe_corootSpan_dualAnnihilator_map :\n    P.corootSpan.dualAnnihilator.map P.toDualLeft.symm = {x | ∀ i, P.coroot' i x = 0} :=\n  P.flip.coe_rootSpan_dualAnnihilator_map\n\n"}
{"name":"RootPairing.rootSpan_dualAnnihilator_map_eq","module":"Mathlib.LinearAlgebra.RootSystem.Defs","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nP : RootPairing ι R M N\n⊢ Eq (Submodule.map P.toDualRight.symm P.rootSpan.dualAnnihilator) (Submodule.span R (Set.range P.root')).dualCoannihilator","decl":"lemma rootSpan_dualAnnihilator_map_eq :\n    P.rootSpan.dualAnnihilator.map P.toDualRight.symm =\n      (span R (range P.root')).dualCoannihilator := by\n  apply SetLike.coe_injective\n  rw [Submodule.coe_dualCoannihilator_span, coe_rootSpan_dualAnnihilator_map]\n  simp\n\n"}
{"name":"RootPairing.corootSpan_dualAnnihilator_map_eq","module":"Mathlib.LinearAlgebra.RootSystem.Defs","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nP : RootPairing ι R M N\n⊢ Eq (Submodule.map P.toDualLeft.symm P.corootSpan.dualAnnihilator) (Submodule.span R (Set.range P.coroot')).dualCoannihilator","decl":"lemma corootSpan_dualAnnihilator_map_eq :\n    P.corootSpan.dualAnnihilator.map P.toDualLeft.symm =\n      (span R (range P.coroot')).dualCoannihilator :=\n  P.flip.rootSpan_dualAnnihilator_map_eq\n\n"}
{"name":"RootPairing.mem_range_root_of_mem_range_reflection_of_mem_range_root","module":"Mathlib.LinearAlgebra.RootSystem.Defs","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nP : RootPairing ι R M N\nr : LinearEquiv (RingHom.id R) M M\nα : M\nhr : Membership.mem (Set.range P.reflection) r\nhα : Membership.mem (Set.range ⇑P.root) α\n⊢ Membership.mem (Set.range ⇑P.root) (HSMul.hSMul r α)","decl":"lemma mem_range_root_of_mem_range_reflection_of_mem_range_root\n    {r : M ≃ₗ[R] M} {α : M} (hr : r ∈ range P.reflection) (hα : α ∈ range P.root) :\n    r • α ∈ range P.root := by\n  obtain ⟨i, rfl⟩ := hr\n  obtain ⟨j, rfl⟩ := hα\n  exact ⟨P.reflection_perm i j, P.root_reflection_perm i j⟩\n\n"}
{"name":"RootPairing.mem_range_coroot_of_mem_range_coreflection_of_mem_range_coroot","module":"Mathlib.LinearAlgebra.RootSystem.Defs","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nP : RootPairing ι R M N\nr : LinearEquiv (RingHom.id R) N N\nα : N\nhr : Membership.mem (Set.range P.coreflection) r\nhα : Membership.mem (Set.range ⇑P.coroot) α\n⊢ Membership.mem (Set.range ⇑P.coroot) (HSMul.hSMul r α)","decl":"lemma mem_range_coroot_of_mem_range_coreflection_of_mem_range_coroot\n    {r : N ≃ₗ[R] N} {α : N} (hr : r ∈ range P.coreflection) (hα : α ∈ range P.coroot) :\n    r • α ∈ range P.coroot := by\n  obtain ⟨i, rfl⟩ := hr\n  obtain ⟨j, rfl⟩ := hα\n  exact ⟨P.reflection_perm i j, P.coroot_reflection_perm i j⟩\n\n"}
{"name":"RootPairing.pairing_smul_root_eq","module":"Mathlib.LinearAlgebra.RootSystem.Defs","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nP : RootPairing ι R M N\ni j k : ι\nhij : Eq (P.reflection_perm i) (P.reflection_perm j)\n⊢ Eq (HSMul.hSMul (P.pairing k i) (P.root i)) (HSMul.hSMul (P.pairing k j) (P.root j))","decl":"lemma pairing_smul_root_eq (k : ι) (hij : P.reflection_perm i = P.reflection_perm j) :\n    P.pairing k i • P.root i = P.pairing k j • P.root j := by\n  have h : P.reflection i (P.root k) = P.reflection j (P.root k) := by\n    simp only [← root_reflection_perm, hij]\n  simpa only [reflection_apply_root, sub_right_inj] using h\n\n"}
{"name":"RootPairing.pairing_smul_coroot_eq","module":"Mathlib.LinearAlgebra.RootSystem.Defs","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nP : RootPairing ι R M N\ni j k : ι\nhij : Eq (P.reflection_perm i) (P.reflection_perm j)\n⊢ Eq (HSMul.hSMul (P.pairing i k) (P.coroot i)) (HSMul.hSMul (P.pairing j k) (P.coroot j))","decl":"lemma pairing_smul_coroot_eq (k : ι) (hij : P.reflection_perm i = P.reflection_perm j) :\n    P.pairing i k • P.coroot i = P.pairing j k • P.coroot j := by\n  have h : P.coreflection i (P.coroot k) = P.coreflection j (P.coroot k) := by\n    simp only [← coroot_reflection_perm, hij]\n  simpa only [coreflection_apply_coroot, sub_right_inj] using h\n\n"}
{"name":"RootPairing.two_nsmul_reflection_eq_of_perm_eq","module":"Mathlib.LinearAlgebra.RootSystem.Defs","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nP : RootPairing ι R M N\ni j : ι\nhij : Eq (P.reflection_perm i) (P.reflection_perm j)\n⊢ Eq (HSMul.hSMul 2 ⇑(P.reflection i)) (HSMul.hSMul 2 ⇑(P.reflection j))","decl":"lemma two_nsmul_reflection_eq_of_perm_eq (hij : P.reflection_perm i = P.reflection_perm j) :\n    2 • ⇑(P.reflection i) = 2 • P.reflection j := by\n  ext x\n  suffices 2 • P.toLin x (P.coroot i) • P.root i = 2 • P.toLin x (P.coroot j) • P.root j by\n    simpa [reflection_apply, smul_sub]\n  calc 2 • P.toLin x (P.coroot i) • P.root i\n      = P.toLin x (P.coroot i) • ((2 : R) • P.root i) := ?_\n    _ = P.toLin x (P.coroot i) • (P.pairing i j • P.root j) := ?_\n    _ = P.toLin x (P.pairing i j • P.coroot i) • (P.root j) := ?_\n    _ = P.toLin x ((2 : R) • P.coroot j) • (P.root j) := ?_\n    _ = 2 • P.toLin x (P.coroot j) • P.root j := ?_\n  · rw [smul_comm, ← Nat.cast_smul_eq_nsmul R, Nat.cast_ofNat]\n  · rw [P.pairing_smul_root_eq j i i hij.symm, pairing_same]\n  · rw [← smul_comm, ← smul_assoc, map_smul]\n  · rw [← P.pairing_smul_coroot_eq j i j hij.symm, pairing_same]\n  · rw [map_smul, smul_assoc, ← Nat.cast_smul_eq_nsmul R, Nat.cast_ofNat]\n\n"}
{"name":"RootPairing.reflection_perm_eq_reflection_perm_iff_of_isSMulRegular","module":"Mathlib.LinearAlgebra.RootSystem.Defs","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nP : RootPairing ι R M N\ni j : ι\nh2 : IsSMulRegular M 2\n⊢ Iff (Eq (P.reflection_perm i) (P.reflection_perm j)) (Eq (P.reflection i) (P.reflection j))","decl":"lemma reflection_perm_eq_reflection_perm_iff_of_isSMulRegular (h2 : IsSMulRegular M 2) :\n    P.reflection_perm i = P.reflection_perm j ↔ P.reflection i = P.reflection j := by\n  refine ⟨fun h ↦ ?_, fun h ↦ Equiv.ext fun k ↦ P.root.injective <| by simp [h]⟩\n  suffices ⇑(P.reflection i) = ⇑(P.reflection j) from DFunLike.coe_injective this\n  replace h2 : IsSMulRegular (M → M) 2 := IsSMulRegular.pi fun _ ↦ h2\n  exact h2 <| P.two_nsmul_reflection_eq_of_perm_eq i j h\n\n"}
{"name":"RootPairing.reflection_perm_eq_reflection_perm_iff_of_span","module":"Mathlib.LinearAlgebra.RootSystem.Defs","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nP : RootPairing ι R M N\ni j : ι\n⊢ Iff (Eq (P.reflection_perm i) (P.reflection_perm j)) (∀ (x : M), Membership.mem (Submodule.span R (Set.range ⇑P.root)) x → Eq ((P.reflection i) x) ((P.reflection j) x))","decl":"lemma reflection_perm_eq_reflection_perm_iff_of_span :\n    P.reflection_perm i = P.reflection_perm j ↔\n    ∀ x ∈ span R (range P.root), P.reflection i x = P.reflection j x := by\n  refine ⟨fun h x hx ↦ ?_, fun h ↦ ?_⟩\n  · induction hx using Submodule.span_induction with\n    | mem x hx =>\n      obtain ⟨k, rfl⟩ := hx\n      simp only [← root_reflection_perm, h]\n    | zero => simp\n    | add x y _ _ hx hy => simp [hx, hy]\n    | smul t x _ hx => simp [hx]\n  · ext k\n    apply P.root.injective\n    simp [h (P.root k) (Submodule.subset_span <| mem_range_self k)]\n\n"}
{"name":"RootSystem.reflection_perm_eq_reflection_perm_iff","module":"Mathlib.LinearAlgebra.RootSystem.Defs","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nP : RootSystem ι R M N\ni j : ι\n⊢ Iff (Eq (P.reflection_perm i) (P.reflection_perm j)) (Eq (P.reflection i) (P.reflection j))","decl":"lemma _root_.RootSystem.reflection_perm_eq_reflection_perm_iff (P : RootSystem ι R M N) (i j : ι) :\n    P.reflection_perm i = P.reflection_perm j ↔ P.reflection i = P.reflection j := by\n  refine ⟨fun h ↦ ?_, fun h ↦ Equiv.ext fun k ↦ P.root.injective <| by simp [h]⟩\n  ext x\n  exact (P.reflection_perm_eq_reflection_perm_iff_of_span i j).mp h x <| by simp\n\n"}
{"name":"RootPairing.coxeterWeight_swap","module":"Mathlib.LinearAlgebra.RootSystem.Defs","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nP : RootPairing ι R M N\ni j : ι\n⊢ Eq (P.coxeterWeight i j) (P.coxeterWeight j i)","decl":"lemma coxeterWeight_swap : coxeterWeight P i j = coxeterWeight P j i := by\n  simp only [coxeterWeight, mul_comm]\n\n"}
{"name":"RootPairing.algebraMap_coxeterWeightIn","module":"Mathlib.LinearAlgebra.RootSystem.Defs","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁷ : CommRing R\ninst✝⁶ : AddCommGroup M\ninst✝⁵ : Module R M\ninst✝⁴ : AddCommGroup N\ninst✝³ : Module R N\nP : RootPairing ι R M N\nS : Type u_5\ninst✝² : CommRing S\ninst✝¹ : Algebra S R\ninst✝ : P.IsValuedIn S\ni j : ι\n⊢ Eq ((algebraMap S R) (P.coxeterWeightIn S i j)) (P.coxeterWeight i j)","decl":"@[simp] lemma algebraMap_coxeterWeightIn (S : Type*) [CommRing S] [Algebra S R] [P.IsValuedIn S]\n    (i j : ι) :\n    algebraMap S R (P.coxeterWeightIn S i j) = P.coxeterWeight i j := by\n  simp [coxeterWeightIn, coxeterWeight]\n\n"}
{"name":"RootPairing.isOrthogonal_symm","module":"Mathlib.LinearAlgebra.RootSystem.Defs","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nP : RootPairing ι R M N\ni j : ι\n⊢ Iff (P.IsOrthogonal i j) (P.IsOrthogonal j i)","decl":"lemma isOrthogonal_symm : IsOrthogonal P i j ↔ IsOrthogonal P j i := by\n  simp only [IsOrthogonal, and_comm]\n\n"}
{"name":"RootPairing.IsOrthogonal.symm","module":"Mathlib.LinearAlgebra.RootSystem.Defs","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nP : RootPairing ι R M N\ni j : ι\nh : P.IsOrthogonal i j\n⊢ P.IsOrthogonal j i","decl":"lemma IsOrthogonal.symm (h : IsOrthogonal P i j) : IsOrthogonal P j i :=\n  ⟨h.2, h.1⟩\n\n"}
{"name":"RootPairing.isOrthogonal_comm","module":"Mathlib.LinearAlgebra.RootSystem.Defs","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nP : RootPairing ι R M N\ni j : ι\nh : P.IsOrthogonal i j\n⊢ Commute (P.reflection i) (P.reflection j)","decl":"lemma isOrthogonal_comm (h : IsOrthogonal P i j) : Commute (P.reflection i) (P.reflection j) := by\n  rw [commute_iff_eq]\n  ext v\n  replace h : P.pairing i j = 0 ∧ P.pairing j i = 0 := by simpa [IsOrthogonal] using h\n  erw [LinearMap.mul_apply, LinearMap.mul_apply]\n  simp only [LinearEquiv.coe_coe, reflection_apply, PerfectPairing.flip_apply_apply, map_sub,\n    map_smul, root_coroot_eq_pairing, h, zero_smul, sub_zero]\n  abel\n\n"}
