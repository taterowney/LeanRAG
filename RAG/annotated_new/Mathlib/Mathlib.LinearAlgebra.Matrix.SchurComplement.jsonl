{"name":"Matrix.fromBlocks_eq_of_invertibleâ‚â‚","module":"Mathlib.LinearAlgebra.Matrix.SchurComplement","initialProofState":"l : Type u_1\nm : Type u_2\nn : Type u_3\nÎ± : Type u_4\ninstâœâ· : Fintype l\ninstâœâ¶ : Fintype m\ninstâœâµ : Fintype n\ninstâœâ´ : DecidableEq l\ninstâœÂ³ : DecidableEq m\ninstâœÂ² : DecidableEq n\ninstâœÂ¹ : CommRing Î±\nA : Matrix m m Î±\nB : Matrix m n Î±\nC : Matrix l m Î±\nD : Matrix l n Î±\ninstâœ : Invertible A\nâŠ¢ Eq (Matrix.fromBlocks A B C D) (HMul.hMul (HMul.hMul (Matrix.fromBlocks 1 0 (HMul.hMul C (Invertible.invOf A)) 1) (Matrix.fromBlocks A 0 0 (HSub.hSub D (HMul.hMul (HMul.hMul C (Invertible.invOf A)) B)))) (Matrix.fromBlocks 1 (HMul.hMul (Invertible.invOf A) B) 0 1))","decl":"/-- LDU decomposition of a block matrix with an invertible top-left corner, using the\nSchur complement. -/\ntheorem fromBlocks_eq_of_invertibleâ‚â‚ (A : Matrix m m Î±) (B : Matrix m n Î±) (C : Matrix l m Î±)\n    (D : Matrix l n Î±) [Invertible A] :\n    fromBlocks A B C D =\n      fromBlocks 1 0 (C * â…Ÿ A) 1 * fromBlocks A 0 0 (D - C * â…Ÿ A * B) *\n        fromBlocks 1 (â…Ÿ A * B) 0 1 := by\n  simp only [fromBlocks_multiply, Matrix.mul_zero, Matrix.zero_mul, add_zero, zero_add,\n    Matrix.one_mul, Matrix.mul_one, invOf_mul_self, Matrix.mul_invOf_cancel_left,\n    Matrix.invOf_mul_cancel_right, Matrix.mul_assoc, add_sub_cancel]\n\n"}
{"name":"Matrix.fromBlocks_eq_of_invertibleâ‚‚â‚‚","module":"Mathlib.LinearAlgebra.Matrix.SchurComplement","initialProofState":"l : Type u_1\nm : Type u_2\nn : Type u_3\nÎ± : Type u_4\ninstâœâ· : Fintype l\ninstâœâ¶ : Fintype m\ninstâœâµ : Fintype n\ninstâœâ´ : DecidableEq l\ninstâœÂ³ : DecidableEq m\ninstâœÂ² : DecidableEq n\ninstâœÂ¹ : CommRing Î±\nA : Matrix l m Î±\nB : Matrix l n Î±\nC : Matrix n m Î±\nD : Matrix n n Î±\ninstâœ : Invertible D\nâŠ¢ Eq (Matrix.fromBlocks A B C D) (HMul.hMul (HMul.hMul (Matrix.fromBlocks 1 (HMul.hMul B (Invertible.invOf D)) 0 1) (Matrix.fromBlocks (HSub.hSub A (HMul.hMul (HMul.hMul B (Invertible.invOf D)) C)) 0 0 D)) (Matrix.fromBlocks 1 0 (HMul.hMul (Invertible.invOf D) C) 1))","decl":"/-- LDU decomposition of a block matrix with an invertible bottom-right corner, using the\nSchur complement. -/\ntheorem fromBlocks_eq_of_invertibleâ‚‚â‚‚ (A : Matrix l m Î±) (B : Matrix l n Î±) (C : Matrix n m Î±)\n    (D : Matrix n n Î±) [Invertible D] :\n    fromBlocks A B C D =\n      fromBlocks 1 (B * â…Ÿ D) 0 1 * fromBlocks (A - B * â…Ÿ D * C) 0 0 D *\n        fromBlocks 1 0 (â…Ÿ D * C) 1 :=\n  (Matrix.reindex (Equiv.sumComm _ _) (Equiv.sumComm _ _)).injective <| by\n    simpa [reindex_apply, Equiv.sumComm_symm, â† submatrix_mul_equiv _ _ _ (Equiv.sumComm n m), â†\n      submatrix_mul_equiv _ _ _ (Equiv.sumComm n l), Equiv.sumComm_apply,\n      fromBlocks_submatrix_sum_swap_sum_swap] using fromBlocks_eq_of_invertibleâ‚â‚ D C B A\n\n"}
{"name":"Matrix.invOf_fromBlocks_zeroâ‚‚â‚_eq","module":"Mathlib.LinearAlgebra.Matrix.SchurComplement","initialProofState":"m : Type u_2\nn : Type u_3\nÎ± : Type u_4\ninstâœâ· : Fintype m\ninstâœâ¶ : Fintype n\ninstâœâµ : DecidableEq m\ninstâœâ´ : DecidableEq n\ninstâœÂ³ : CommRing Î±\nA : Matrix m m Î±\nB : Matrix m n Î±\nD : Matrix n n Î±\ninstâœÂ² : Invertible A\ninstâœÂ¹ : Invertible D\ninstâœ : Invertible (Matrix.fromBlocks A B 0 D)\nâŠ¢ Eq (Invertible.invOf (Matrix.fromBlocks A B 0 D)) (Matrix.fromBlocks (Invertible.invOf A) (Neg.neg (HMul.hMul (HMul.hMul (Invertible.invOf A) B) (Invertible.invOf D))) 0 (Invertible.invOf D))","decl":"theorem invOf_fromBlocks_zeroâ‚‚â‚_eq (A : Matrix m m Î±) (B : Matrix m n Î±) (D : Matrix n n Î±)\n    [Invertible A] [Invertible D] [Invertible (fromBlocks A B 0 D)] :\n    â…Ÿ (fromBlocks A B 0 D) = fromBlocks (â…Ÿ A) (-(â…Ÿ A * B * â…Ÿ D)) 0 (â…Ÿ D) := by\n  letI := fromBlocksZeroâ‚‚â‚Invertible A B D\n  convert (rfl : â…Ÿ (fromBlocks A B 0 D) = _)\n\n"}
{"name":"Matrix.invOf_fromBlocks_zeroâ‚â‚‚_eq","module":"Mathlib.LinearAlgebra.Matrix.SchurComplement","initialProofState":"m : Type u_2\nn : Type u_3\nÎ± : Type u_4\ninstâœâ· : Fintype m\ninstâœâ¶ : Fintype n\ninstâœâµ : DecidableEq m\ninstâœâ´ : DecidableEq n\ninstâœÂ³ : CommRing Î±\nA : Matrix m m Î±\nC : Matrix n m Î±\nD : Matrix n n Î±\ninstâœÂ² : Invertible A\ninstâœÂ¹ : Invertible D\ninstâœ : Invertible (Matrix.fromBlocks A 0 C D)\nâŠ¢ Eq (Invertible.invOf (Matrix.fromBlocks A 0 C D)) (Matrix.fromBlocks (Invertible.invOf A) 0 (Neg.neg (HMul.hMul (HMul.hMul (Invertible.invOf D) C) (Invertible.invOf A))) (Invertible.invOf D))","decl":"theorem invOf_fromBlocks_zeroâ‚â‚‚_eq (A : Matrix m m Î±) (C : Matrix n m Î±) (D : Matrix n n Î±)\n    [Invertible A] [Invertible D] [Invertible (fromBlocks A 0 C D)] :\n    â…Ÿ (fromBlocks A 0 C D) = fromBlocks (â…Ÿ A) 0 (-(â…Ÿ D * C * â…Ÿ A)) (â…Ÿ D) := by\n  letI := fromBlocksZeroâ‚â‚‚Invertible A C D\n  convert (rfl : â…Ÿ (fromBlocks A 0 C D) = _)\n\n"}
{"name":"Matrix.isUnit_fromBlocks_zeroâ‚‚â‚","module":"Mathlib.LinearAlgebra.Matrix.SchurComplement","initialProofState":"m : Type u_2\nn : Type u_3\nÎ± : Type u_4\ninstâœâ´ : Fintype m\ninstâœÂ³ : Fintype n\ninstâœÂ² : DecidableEq m\ninstâœÂ¹ : DecidableEq n\ninstâœ : CommRing Î±\nA : Matrix m m Î±\nB : Matrix m n Î±\nD : Matrix n n Î±\nâŠ¢ Iff (IsUnit (Matrix.fromBlocks A B 0 D)) (And (IsUnit A) (IsUnit D))","decl":"/-- An upper block-triangular matrix is invertible iff both elements of its diagonal are.\n\nThis is a propositional form of `Matrix.fromBlocksZeroâ‚‚â‚InvertibleEquiv`. -/\n@[simp]\ntheorem isUnit_fromBlocks_zeroâ‚‚â‚ {A : Matrix m m Î±} {B : Matrix m n Î±} {D : Matrix n n Î±} :\n    IsUnit (fromBlocks A B 0 D) â†” IsUnit A âˆ§ IsUnit D := by\n  simp only [â† nonempty_invertible_iff_isUnit, â† nonempty_prod,\n    (fromBlocksZeroâ‚‚â‚InvertibleEquiv _ _ _).nonempty_congr]\n\n"}
{"name":"Matrix.isUnit_fromBlocks_zeroâ‚â‚‚","module":"Mathlib.LinearAlgebra.Matrix.SchurComplement","initialProofState":"m : Type u_2\nn : Type u_3\nÎ± : Type u_4\ninstâœâ´ : Fintype m\ninstâœÂ³ : Fintype n\ninstâœÂ² : DecidableEq m\ninstâœÂ¹ : DecidableEq n\ninstâœ : CommRing Î±\nA : Matrix m m Î±\nC : Matrix n m Î±\nD : Matrix n n Î±\nâŠ¢ Iff (IsUnit (Matrix.fromBlocks A 0 C D)) (And (IsUnit A) (IsUnit D))","decl":"/-- A lower block-triangular matrix is invertible iff both elements of its diagonal are.\n\nThis is a propositional form of `Matrix.fromBlocksZeroâ‚â‚‚InvertibleEquiv` forms an `iff`. -/\n@[simp]\ntheorem isUnit_fromBlocks_zeroâ‚â‚‚ {A : Matrix m m Î±} {C : Matrix n m Î±} {D : Matrix n n Î±} :\n    IsUnit (fromBlocks A 0 C D) â†” IsUnit A âˆ§ IsUnit D := by\n  simp only [â† nonempty_invertible_iff_isUnit, â† nonempty_prod,\n    (fromBlocksZeroâ‚â‚‚InvertibleEquiv _ _ _).nonempty_congr]\n\n"}
{"name":"Matrix.inv_fromBlocks_zeroâ‚‚â‚_of_isUnit_iff","module":"Mathlib.LinearAlgebra.Matrix.SchurComplement","initialProofState":"m : Type u_2\nn : Type u_3\nÎ± : Type u_4\ninstâœâ´ : Fintype m\ninstâœÂ³ : Fintype n\ninstâœÂ² : DecidableEq m\ninstâœÂ¹ : DecidableEq n\ninstâœ : CommRing Î±\nA : Matrix m m Î±\nB : Matrix m n Î±\nD : Matrix n n Î±\nhAD : Iff (IsUnit A) (IsUnit D)\nâŠ¢ Eq (Inv.inv (Matrix.fromBlocks A B 0 D)) (Matrix.fromBlocks (Inv.inv A) (Neg.neg (HMul.hMul (HMul.hMul (Inv.inv A) B) (Inv.inv D))) 0 (Inv.inv D))","decl":"/-- An expression for the inverse of an upper block-triangular matrix, when either both elements of\ndiagonal are invertible, or both are not. -/\ntheorem inv_fromBlocks_zeroâ‚‚â‚_of_isUnit_iff (A : Matrix m m Î±) (B : Matrix m n Î±) (D : Matrix n n Î±)\n    (hAD : IsUnit A â†” IsUnit D) :\n    (fromBlocks A B 0 D)â»Â¹ = fromBlocks Aâ»Â¹ (-(Aâ»Â¹ * B * Dâ»Â¹)) 0 Dâ»Â¹ := by\n  by_cases hA : IsUnit A\n  Â· have hD := hAD.mp hA\n    cases hA.nonempty_invertible\n    cases hD.nonempty_invertible\n    letI := fromBlocksZeroâ‚‚â‚Invertible A B D\n    simp_rw [â† invOf_eq_nonsing_inv, invOf_fromBlocks_zeroâ‚‚â‚_eq]\n  Â· have hD := hAD.not.mp hA\n    have : Â¬IsUnit (fromBlocks A B 0 D) :=\n      isUnit_fromBlocks_zeroâ‚‚â‚.not.mpr (not_and'.mpr fun _ => hA)\n    simp_rw [nonsing_inv_eq_ring_inverse, Ring.inverse_non_unit _ hA, Ring.inverse_non_unit _ hD,\n      Ring.inverse_non_unit _ this, Matrix.zero_mul, neg_zero, fromBlocks_zero]\n\n"}
{"name":"Matrix.inv_fromBlocks_zeroâ‚â‚‚_of_isUnit_iff","module":"Mathlib.LinearAlgebra.Matrix.SchurComplement","initialProofState":"m : Type u_2\nn : Type u_3\nÎ± : Type u_4\ninstâœâ´ : Fintype m\ninstâœÂ³ : Fintype n\ninstâœÂ² : DecidableEq m\ninstâœÂ¹ : DecidableEq n\ninstâœ : CommRing Î±\nA : Matrix m m Î±\nC : Matrix n m Î±\nD : Matrix n n Î±\nhAD : Iff (IsUnit A) (IsUnit D)\nâŠ¢ Eq (Inv.inv (Matrix.fromBlocks A 0 C D)) (Matrix.fromBlocks (Inv.inv A) 0 (Neg.neg (HMul.hMul (HMul.hMul (Inv.inv D) C) (Inv.inv A))) (Inv.inv D))","decl":"/-- An expression for the inverse of a lower block-triangular matrix, when either both elements of\ndiagonal are invertible, or both are not. -/\ntheorem inv_fromBlocks_zeroâ‚â‚‚_of_isUnit_iff (A : Matrix m m Î±) (C : Matrix n m Î±) (D : Matrix n n Î±)\n    (hAD : IsUnit A â†” IsUnit D) :\n    (fromBlocks A 0 C D)â»Â¹ = fromBlocks Aâ»Â¹ 0 (-(Dâ»Â¹ * C * Aâ»Â¹)) Dâ»Â¹ := by\n  by_cases hA : IsUnit A\n  Â· have hD := hAD.mp hA\n    cases hA.nonempty_invertible\n    cases hD.nonempty_invertible\n    letI := fromBlocksZeroâ‚â‚‚Invertible A C D\n    simp_rw [â† invOf_eq_nonsing_inv, invOf_fromBlocks_zeroâ‚â‚‚_eq]\n  Â· have hD := hAD.not.mp hA\n    have : Â¬IsUnit (fromBlocks A 0 C D) :=\n      isUnit_fromBlocks_zeroâ‚â‚‚.not.mpr (not_and'.mpr fun _ => hA)\n    simp_rw [nonsing_inv_eq_ring_inverse, Ring.inverse_non_unit _ hA, Ring.inverse_non_unit _ hD,\n      Ring.inverse_non_unit _ this, Matrix.zero_mul, neg_zero, fromBlocks_zero]\n\n"}
{"name":"Matrix.invOf_fromBlocksâ‚‚â‚‚_eq","module":"Mathlib.LinearAlgebra.Matrix.SchurComplement","initialProofState":"m : Type u_2\nn : Type u_3\nÎ± : Type u_4\ninstâœâ· : Fintype m\ninstâœâ¶ : Fintype n\ninstâœâµ : DecidableEq m\ninstâœâ´ : DecidableEq n\ninstâœÂ³ : CommRing Î±\nA : Matrix m m Î±\nB : Matrix m n Î±\nC : Matrix n m Î±\nD : Matrix n n Î±\ninstâœÂ² : Invertible D\ninstâœÂ¹ : Invertible (HSub.hSub A (HMul.hMul (HMul.hMul B (Invertible.invOf D)) C))\ninstâœ : Invertible (Matrix.fromBlocks A B C D)\nâŠ¢ Eq (Invertible.invOf (Matrix.fromBlocks A B C D)) (Matrix.fromBlocks (Invertible.invOf (HSub.hSub A (HMul.hMul (HMul.hMul B (Invertible.invOf D)) C))) (Neg.neg (HMul.hMul (HMul.hMul (Invertible.invOf (HSub.hSub A (HMul.hMul (HMul.hMul B (Invertible.invOf D)) C))) B) (Invertible.invOf D))) (Neg.neg (HMul.hMul (HMul.hMul (Invertible.invOf D) C) (Invertible.invOf (HSub.hSub A (HMul.hMul (HMul.hMul B (Invertible.invOf D)) C))))) (HAdd.hAdd (Invertible.invOf D) (HMul.hMul (HMul.hMul (HMul.hMul (HMul.hMul (Invertible.invOf D) C) (Invertible.invOf (HSub.hSub A (HMul.hMul (HMul.hMul B (Invertible.invOf D)) C)))) B) (Invertible.invOf D))))","decl":"theorem invOf_fromBlocksâ‚‚â‚‚_eq (A : Matrix m m Î±) (B : Matrix m n Î±) (C : Matrix n m Î±)\n    (D : Matrix n n Î±) [Invertible D] [Invertible (A - B * â…Ÿ D * C)]\n    [Invertible (fromBlocks A B C D)] :\n    â…Ÿ (fromBlocks A B C D) =\n      fromBlocks (â…Ÿ (A - B * â…Ÿ D * C)) (-(â…Ÿ (A - B * â…Ÿ D * C) * B * â…Ÿ D))\n        (-(â…Ÿ D * C * â…Ÿ (A - B * â…Ÿ D * C))) (â…Ÿ D + â…Ÿ D * C * â…Ÿ (A - B * â…Ÿ D * C) * B * â…Ÿ D) := by\n  letI := fromBlocksâ‚‚â‚‚Invertible A B C D\n  convert (rfl : â…Ÿ (fromBlocks A B C D) = _)\n\n"}
{"name":"Matrix.invOf_fromBlocksâ‚â‚_eq","module":"Mathlib.LinearAlgebra.Matrix.SchurComplement","initialProofState":"m : Type u_2\nn : Type u_3\nÎ± : Type u_4\ninstâœâ· : Fintype m\ninstâœâ¶ : Fintype n\ninstâœâµ : DecidableEq m\ninstâœâ´ : DecidableEq n\ninstâœÂ³ : CommRing Î±\nA : Matrix m m Î±\nB : Matrix m n Î±\nC : Matrix n m Î±\nD : Matrix n n Î±\ninstâœÂ² : Invertible A\ninstâœÂ¹ : Invertible (HSub.hSub D (HMul.hMul (HMul.hMul C (Invertible.invOf A)) B))\ninstâœ : Invertible (Matrix.fromBlocks A B C D)\nâŠ¢ Eq (Invertible.invOf (Matrix.fromBlocks A B C D)) (Matrix.fromBlocks (HAdd.hAdd (Invertible.invOf A) (HMul.hMul (HMul.hMul (HMul.hMul (HMul.hMul (Invertible.invOf A) B) (Invertible.invOf (HSub.hSub D (HMul.hMul (HMul.hMul C (Invertible.invOf A)) B)))) C) (Invertible.invOf A))) (Neg.neg (HMul.hMul (HMul.hMul (Invertible.invOf A) B) (Invertible.invOf (HSub.hSub D (HMul.hMul (HMul.hMul C (Invertible.invOf A)) B))))) (Neg.neg (HMul.hMul (HMul.hMul (Invertible.invOf (HSub.hSub D (HMul.hMul (HMul.hMul C (Invertible.invOf A)) B))) C) (Invertible.invOf A))) (Invertible.invOf (HSub.hSub D (HMul.hMul (HMul.hMul C (Invertible.invOf A)) B))))","decl":"theorem invOf_fromBlocksâ‚â‚_eq (A : Matrix m m Î±) (B : Matrix m n Î±) (C : Matrix n m Î±)\n    (D : Matrix n n Î±) [Invertible A] [Invertible (D - C * â…Ÿ A * B)]\n    [Invertible (fromBlocks A B C D)] :\n    â…Ÿ (fromBlocks A B C D) =\n      fromBlocks (â…Ÿ A + â…Ÿ A * B * â…Ÿ (D - C * â…Ÿ A * B) * C * â…Ÿ A) (-(â…Ÿ A * B * â…Ÿ (D - C * â…Ÿ A * B)))\n        (-(â…Ÿ (D - C * â…Ÿ A * B) * C * â…Ÿ A)) (â…Ÿ (D - C * â…Ÿ A * B)) := by\n  letI := fromBlocksâ‚â‚Invertible A B C D\n  convert (rfl : â…Ÿ (fromBlocks A B C D) = _)\n\n"}
{"name":"Matrix.isUnit_fromBlocks_iff_of_invertibleâ‚‚â‚‚","module":"Mathlib.LinearAlgebra.Matrix.SchurComplement","initialProofState":"m : Type u_2\nn : Type u_3\nÎ± : Type u_4\ninstâœâµ : Fintype m\ninstâœâ´ : Fintype n\ninstâœÂ³ : DecidableEq m\ninstâœÂ² : DecidableEq n\ninstâœÂ¹ : CommRing Î±\nA : Matrix m m Î±\nB : Matrix m n Î±\nC : Matrix n m Î±\nD : Matrix n n Î±\ninstâœ : Invertible D\nâŠ¢ Iff (IsUnit (Matrix.fromBlocks A B C D)) (IsUnit (HSub.hSub A (HMul.hMul (HMul.hMul B (Invertible.invOf D)) C)))","decl":"/-- If the bottom-left element of a block matrix is invertible, then the whole matrix is invertible\niff the corresponding schur complement is. -/\ntheorem isUnit_fromBlocks_iff_of_invertibleâ‚‚â‚‚ {A : Matrix m m Î±} {B : Matrix m n Î±}\n    {C : Matrix n m Î±} {D : Matrix n n Î±} [Invertible D] :\n    IsUnit (fromBlocks A B C D) â†” IsUnit (A - B * â…Ÿ D * C) := by\n  simp only [â† nonempty_invertible_iff_isUnit,\n    (invertibleEquivFromBlocksâ‚‚â‚‚Invertible A B C D).nonempty_congr]\n\n"}
{"name":"Matrix.isUnit_fromBlocks_iff_of_invertibleâ‚â‚","module":"Mathlib.LinearAlgebra.Matrix.SchurComplement","initialProofState":"m : Type u_2\nn : Type u_3\nÎ± : Type u_4\ninstâœâµ : Fintype m\ninstâœâ´ : Fintype n\ninstâœÂ³ : DecidableEq m\ninstâœÂ² : DecidableEq n\ninstâœÂ¹ : CommRing Î±\nA : Matrix m m Î±\nB : Matrix m n Î±\nC : Matrix n m Î±\nD : Matrix n n Î±\ninstâœ : Invertible A\nâŠ¢ Iff (IsUnit (Matrix.fromBlocks A B C D)) (IsUnit (HSub.hSub D (HMul.hMul (HMul.hMul C (Invertible.invOf A)) B)))","decl":"/-- If the top-right element of a block matrix is invertible, then the whole matrix is invertible\niff the corresponding schur complement is. -/\ntheorem isUnit_fromBlocks_iff_of_invertibleâ‚â‚ {A : Matrix m m Î±} {B : Matrix m n Î±}\n    {C : Matrix n m Î±} {D : Matrix n n Î±} [Invertible A] :\n    IsUnit (fromBlocks A B C D) â†” IsUnit (D - C * â…Ÿ A * B) := by\n  simp only [â† nonempty_invertible_iff_isUnit,\n    (invertibleEquivFromBlocksâ‚â‚Invertible A B C D).nonempty_congr]\n\n"}
{"name":"Matrix.det_fromBlocksâ‚â‚","module":"Mathlib.LinearAlgebra.Matrix.SchurComplement","initialProofState":"m : Type u_2\nn : Type u_3\nÎ± : Type u_4\ninstâœâµ : Fintype m\ninstâœâ´ : Fintype n\ninstâœÂ³ : DecidableEq m\ninstâœÂ² : DecidableEq n\ninstâœÂ¹ : CommRing Î±\nA : Matrix m m Î±\nB : Matrix m n Î±\nC : Matrix n m Î±\nD : Matrix n n Î±\ninstâœ : Invertible A\nâŠ¢ Eq (Matrix.fromBlocks A B C D).det (HMul.hMul A.det (HSub.hSub D (HMul.hMul (HMul.hMul C (Invertible.invOf A)) B)).det)","decl":"/-- Determinant of a 2Ã—2 block matrix, expanded around an invertible top left element in terms of\nthe Schur complement. -/\ntheorem det_fromBlocksâ‚â‚ (A : Matrix m m Î±) (B : Matrix m n Î±) (C : Matrix n m Î±)\n    (D : Matrix n n Î±) [Invertible A] :\n    (Matrix.fromBlocks A B C D).det = det A * det (D - C * â…Ÿ A * B) := by\n  rw [fromBlocks_eq_of_invertibleâ‚â‚ (A := A), det_mul, det_mul, det_fromBlocks_zeroâ‚‚â‚,\n    det_fromBlocks_zeroâ‚‚â‚, det_fromBlocks_zeroâ‚â‚‚, det_one, det_one, one_mul, one_mul, mul_one]\n\n"}
{"name":"Matrix.det_fromBlocks_oneâ‚â‚","module":"Mathlib.LinearAlgebra.Matrix.SchurComplement","initialProofState":"m : Type u_2\nn : Type u_3\nÎ± : Type u_4\ninstâœâ´ : Fintype m\ninstâœÂ³ : Fintype n\ninstâœÂ² : DecidableEq m\ninstâœÂ¹ : DecidableEq n\ninstâœ : CommRing Î±\nB : Matrix m n Î±\nC : Matrix n m Î±\nD : Matrix n n Î±\nâŠ¢ Eq (Matrix.fromBlocks 1 B C D).det (HSub.hSub D (HMul.hMul C B)).det","decl":"@[simp]\ntheorem det_fromBlocks_oneâ‚â‚ (B : Matrix m n Î±) (C : Matrix n m Î±) (D : Matrix n n Î±) :\n    (Matrix.fromBlocks 1 B C D).det = det (D - C * B) := by\n  haveI : Invertible (1 : Matrix m m Î±) := invertibleOne\n  rw [det_fromBlocksâ‚â‚, invOf_one, Matrix.mul_one, det_one, one_mul]\n\n"}
{"name":"Matrix.det_fromBlocksâ‚‚â‚‚","module":"Mathlib.LinearAlgebra.Matrix.SchurComplement","initialProofState":"m : Type u_2\nn : Type u_3\nÎ± : Type u_4\ninstâœâµ : Fintype m\ninstâœâ´ : Fintype n\ninstâœÂ³ : DecidableEq m\ninstâœÂ² : DecidableEq n\ninstâœÂ¹ : CommRing Î±\nA : Matrix m m Î±\nB : Matrix m n Î±\nC : Matrix n m Î±\nD : Matrix n n Î±\ninstâœ : Invertible D\nâŠ¢ Eq (Matrix.fromBlocks A B C D).det (HMul.hMul D.det (HSub.hSub A (HMul.hMul (HMul.hMul B (Invertible.invOf D)) C)).det)","decl":"/-- Determinant of a 2Ã—2 block matrix, expanded around an invertible bottom right element in terms\nof the Schur complement. -/\ntheorem det_fromBlocksâ‚‚â‚‚ (A : Matrix m m Î±) (B : Matrix m n Î±) (C : Matrix n m Î±)\n    (D : Matrix n n Î±) [Invertible D] :\n    (Matrix.fromBlocks A B C D).det = det D * det (A - B * â…Ÿ D * C) := by\n  have : fromBlocks A B C D =\n      (fromBlocks D C B A).submatrix (Equiv.sumComm _ _) (Equiv.sumComm _ _) := by\n    ext (i j)\n    cases i <;> cases j <;> rfl\n  rw [this, det_submatrix_equiv_self, det_fromBlocksâ‚â‚]\n\n"}
{"name":"Matrix.det_fromBlocks_oneâ‚‚â‚‚","module":"Mathlib.LinearAlgebra.Matrix.SchurComplement","initialProofState":"m : Type u_2\nn : Type u_3\nÎ± : Type u_4\ninstâœâ´ : Fintype m\ninstâœÂ³ : Fintype n\ninstâœÂ² : DecidableEq m\ninstâœÂ¹ : DecidableEq n\ninstâœ : CommRing Î±\nA : Matrix m m Î±\nB : Matrix m n Î±\nC : Matrix n m Î±\nâŠ¢ Eq (Matrix.fromBlocks A B C 1).det (HSub.hSub A (HMul.hMul B C)).det","decl":"@[simp]\ntheorem det_fromBlocks_oneâ‚‚â‚‚ (A : Matrix m m Î±) (B : Matrix m n Î±) (C : Matrix n m Î±) :\n    (Matrix.fromBlocks A B C 1).det = det (A - B * C) := by\n  haveI : Invertible (1 : Matrix n n Î±) := invertibleOne\n  rw [det_fromBlocksâ‚‚â‚‚, invOf_one, Matrix.mul_one, det_one, one_mul]\n\n"}
{"name":"Matrix.det_one_add_mul_comm","module":"Mathlib.LinearAlgebra.Matrix.SchurComplement","initialProofState":"m : Type u_2\nn : Type u_3\nÎ± : Type u_4\ninstâœâ´ : Fintype m\ninstâœÂ³ : Fintype n\ninstâœÂ² : DecidableEq m\ninstâœÂ¹ : DecidableEq n\ninstâœ : CommRing Î±\nA : Matrix m n Î±\nB : Matrix n m Î±\nâŠ¢ Eq (HAdd.hAdd 1 (HMul.hMul A B)).det (HAdd.hAdd 1 (HMul.hMul B A)).det","decl":"/-- The **Weinsteinâ€“Aronszajn identity**. Note the `1` on the LHS is of shape mÃ—m, while the `1` on\nthe RHS is of shape nÃ—n. -/\ntheorem det_one_add_mul_comm (A : Matrix m n Î±) (B : Matrix n m Î±) :\n    det (1 + A * B) = det (1 + B * A) :=\n  calc\n    det (1 + A * B) = det (fromBlocks 1 (-A) B 1) := by\n      rw [det_fromBlocks_oneâ‚‚â‚‚, Matrix.neg_mul, sub_neg_eq_add]\n    _ = det (1 + B * A) := by rw [det_fromBlocks_oneâ‚â‚, Matrix.mul_neg, sub_neg_eq_add]\n\n"}
{"name":"Matrix.det_mul_add_one_comm","module":"Mathlib.LinearAlgebra.Matrix.SchurComplement","initialProofState":"m : Type u_2\nn : Type u_3\nÎ± : Type u_4\ninstâœâ´ : Fintype m\ninstâœÂ³ : Fintype n\ninstâœÂ² : DecidableEq m\ninstâœÂ¹ : DecidableEq n\ninstâœ : CommRing Î±\nA : Matrix m n Î±\nB : Matrix n m Î±\nâŠ¢ Eq (HAdd.hAdd (HMul.hMul A B) 1).det (HAdd.hAdd (HMul.hMul B A) 1).det","decl":"/-- Alternate statement of the **Weinsteinâ€“Aronszajn identity** -/\ntheorem det_mul_add_one_comm (A : Matrix m n Î±) (B : Matrix n m Î±) :\n    det (A * B + 1) = det (B * A + 1) := by rw [add_comm, det_one_add_mul_comm, add_comm]\n\n"}
{"name":"Matrix.det_one_sub_mul_comm","module":"Mathlib.LinearAlgebra.Matrix.SchurComplement","initialProofState":"m : Type u_2\nn : Type u_3\nÎ± : Type u_4\ninstâœâ´ : Fintype m\ninstâœÂ³ : Fintype n\ninstâœÂ² : DecidableEq m\ninstâœÂ¹ : DecidableEq n\ninstâœ : CommRing Î±\nA : Matrix m n Î±\nB : Matrix n m Î±\nâŠ¢ Eq (HSub.hSub 1 (HMul.hMul A B)).det (HSub.hSub 1 (HMul.hMul B A)).det","decl":"theorem det_one_sub_mul_comm (A : Matrix m n Î±) (B : Matrix n m Î±) :\n    det (1 - A * B) = det (1 - B * A) := by\n  rw [sub_eq_add_neg, â† Matrix.neg_mul, det_one_add_mul_comm, Matrix.mul_neg, â† sub_eq_add_neg]\n\n"}
{"name":"Matrix.det_one_add_col_mul_row","module":"Mathlib.LinearAlgebra.Matrix.SchurComplement","initialProofState":"m : Type u_2\nÎ± : Type u_4\ninstâœÂ³ : Fintype m\ninstâœÂ² : DecidableEq m\ninstâœÂ¹ : CommRing Î±\nÎ¹ : Type u_5\ninstâœ : Unique Î¹\nu v : m â†’ Î±\nâŠ¢ Eq (HAdd.hAdd 1 (HMul.hMul (Matrix.col Î¹ u) (Matrix.row Î¹ v))).det (HAdd.hAdd 1 (dotProduct v u))","decl":"/-- A special case of the **Matrix determinant lemma** for when `A = I`. -/\ntheorem det_one_add_col_mul_row {Î¹ : Type*} [Unique Î¹] (u v : m â†’ Î±) :\n    det (1 + col Î¹ u * row Î¹ v) = 1 + v â¬áµ¥ u := by\n  rw [det_one_add_mul_comm, det_unique, Pi.add_apply, Pi.add_apply, Matrix.one_apply_eq,\n    Matrix.row_mul_col_apply]\n\n"}
{"name":"Matrix.det_add_col_mul_row","module":"Mathlib.LinearAlgebra.Matrix.SchurComplement","initialProofState":"m : Type u_2\nÎ± : Type u_4\ninstâœÂ³ : Fintype m\ninstâœÂ² : DecidableEq m\ninstâœÂ¹ : CommRing Î±\nÎ¹ : Type u_5\ninstâœ : Unique Î¹\nA : Matrix m m Î±\nhA : IsUnit A.det\nu v : m â†’ Î±\nâŠ¢ Eq (HAdd.hAdd A (HMul.hMul (Matrix.col Î¹ u) (Matrix.row Î¹ v))).det (HMul.hMul A.det (HAdd.hAdd 1 (HMul.hMul (HMul.hMul (Matrix.row Î¹ v) (Inv.inv A)) (Matrix.col Î¹ u))).det)","decl":"/-- The **Matrix determinant lemma**\n\nTODO: show the more general version without `hA : IsUnit A.det` as\n`(A + col u * row v).det = A.det + v â¬áµ¥ (adjugate A) *áµ¥ u`.\n-/\ntheorem det_add_col_mul_row {Î¹ : Type*} [Unique Î¹]\n    {A : Matrix m m Î±} (hA : IsUnit A.det) (u v : m â†’ Î±) :\n    (A + col Î¹ u * row Î¹ v).det = A.det * (1 + row Î¹ v * Aâ»Â¹ * col Î¹ u).det := by\n  nth_rewrite 1 [â† Matrix.mul_one A]\n  rwa [â† Matrix.mul_nonsing_inv_cancel_left A (col Î¹ u * row Î¹ v),\n    â† Matrix.mul_add, det_mul, â† Matrix.mul_assoc, det_one_add_mul_comm,\n    â† Matrix.mul_assoc]\n\n"}
{"name":"Matrix.det_add_mul","module":"Mathlib.LinearAlgebra.Matrix.SchurComplement","initialProofState":"m : Type u_2\nn : Type u_3\nÎ± : Type u_4\ninstâœâ´ : Fintype m\ninstâœÂ³ : Fintype n\ninstâœÂ² : DecidableEq m\ninstâœÂ¹ : DecidableEq n\ninstâœ : CommRing Î±\nA : Matrix m m Î±\nU : Matrix m n Î±\nV : Matrix n m Î±\nhA : IsUnit A.det\nâŠ¢ Eq (HAdd.hAdd A (HMul.hMul U V)).det (HMul.hMul A.det (HAdd.hAdd 1 (HMul.hMul (HMul.hMul V (Inv.inv A)) U)).det)","decl":"/-- A generalization of the **Matrix determinant lemma** -/\ntheorem det_add_mul {A : Matrix m m Î±} (U : Matrix m n Î±)\n    (V : Matrix n m Î±) (hA : IsUnit A.det) :\n    (A + U * V).det = A.det * (1 + V * Aâ»Â¹ * U).det := by\n  nth_rewrite 1 [â† Matrix.mul_one A]\n  rwa [â† Matrix.mul_nonsing_inv_cancel_left A (U * V), â† Matrix.mul_add,\n    det_mul, â† Matrix.mul_assoc, det_one_add_mul_comm, â† Matrix.mul_assoc]\n\n"}
{"name":"Matrix.schur_complement_eqâ‚â‚","module":"Mathlib.LinearAlgebra.Matrix.SchurComplement","initialProofState":"m : Type u_2\nn : Type u_3\nğ•œ : Type u_5\ninstâœâµ : CommRing ğ•œ\ninstâœâ´ : StarRing ğ•œ\ninstâœÂ³ : Fintype m\ninstâœÂ² : DecidableEq m\ninstâœÂ¹ : Fintype n\nA : Matrix m m ğ•œ\nB : Matrix m n ğ•œ\nD : Matrix n n ğ•œ\nx : m â†’ ğ•œ\ny : n â†’ ğ•œ\ninstâœ : Invertible A\nhA : A.IsHermitian\nâŠ¢ Eq (dotProduct (Matrix.vecMul (Star.star (Sum.elim x y)) (Matrix.fromBlocks A B B.conjTranspose D)) (Sum.elim x y)) (HAdd.hAdd (dotProduct (Matrix.vecMul (Star.star (HAdd.hAdd x ((HMul.hMul (Inv.inv A) B).mulVec y))) A) (HAdd.hAdd x ((HMul.hMul (Inv.inv A) B).mulVec y))) (dotProduct (Matrix.vecMul (Star.star y) (HSub.hSub D (HMul.hMul (HMul.hMul B.conjTranspose (Inv.inv A)) B))) y))","decl":"theorem schur_complement_eqâ‚â‚ [Fintype m] [DecidableEq m] [Fintype n] {A : Matrix m m ğ•œ}\n    (B : Matrix m n ğ•œ) (D : Matrix n n ğ•œ) (x : m â†’ ğ•œ) (y : n â†’ ğ•œ) [Invertible A]\n    (hA : A.IsHermitian) :\n    (star (x âŠ•áµ¥ y)) áµ¥* (fromBlocks A B Bá´´ D) â¬áµ¥ (x âŠ•áµ¥ y) =\n      (star (x + (Aâ»Â¹ * B) *áµ¥ y)) áµ¥* A â¬áµ¥ (x + (Aâ»Â¹ * B) *áµ¥ y) +\n        (star y) áµ¥* (D - Bá´´ * Aâ»Â¹ * B) â¬áµ¥ y := by\n  simp [Function.star_sum_elim, fromBlocks_mulVec, vecMul_fromBlocks, add_vecMul,\n    dotProduct_mulVec, vecMul_sub, Matrix.mul_assoc, vecMul_mulVec, hA.eq,\n    conjTranspose_nonsing_inv, star_mulVec]\n  abel\n\n"}
{"name":"Matrix.schur_complement_eqâ‚‚â‚‚","module":"Mathlib.LinearAlgebra.Matrix.SchurComplement","initialProofState":"m : Type u_2\nn : Type u_3\nğ•œ : Type u_5\ninstâœâµ : CommRing ğ•œ\ninstâœâ´ : StarRing ğ•œ\ninstâœÂ³ : Fintype m\ninstâœÂ² : Fintype n\ninstâœÂ¹ : DecidableEq n\nA : Matrix m m ğ•œ\nB : Matrix m n ğ•œ\nD : Matrix n n ğ•œ\nx : m â†’ ğ•œ\ny : n â†’ ğ•œ\ninstâœ : Invertible D\nhD : D.IsHermitian\nâŠ¢ Eq (dotProduct (Matrix.vecMul (Star.star (Sum.elim x y)) (Matrix.fromBlocks A B B.conjTranspose D)) (Sum.elim x y)) (HAdd.hAdd (dotProduct (Matrix.vecMul (Star.star (HAdd.hAdd ((HMul.hMul (Inv.inv D) B.conjTranspose).mulVec x) y)) D) (HAdd.hAdd ((HMul.hMul (Inv.inv D) B.conjTranspose).mulVec x) y)) (dotProduct (Matrix.vecMul (Star.star x) (HSub.hSub A (HMul.hMul (HMul.hMul B (Inv.inv D)) B.conjTranspose))) x))","decl":"theorem schur_complement_eqâ‚‚â‚‚ [Fintype m] [Fintype n] [DecidableEq n] (A : Matrix m m ğ•œ)\n    (B : Matrix m n ğ•œ) {D : Matrix n n ğ•œ} (x : m â†’ ğ•œ) (y : n â†’ ğ•œ) [Invertible D]\n    (hD : D.IsHermitian) :\n    (star (x âŠ•áµ¥ y)) áµ¥* (fromBlocks A B Bá´´ D) â¬áµ¥ (x âŠ•áµ¥ y) =\n      (star ((Dâ»Â¹ * Bá´´) *áµ¥ x + y)) áµ¥* D â¬áµ¥ ((Dâ»Â¹ * Bá´´) *áµ¥ x + y) +\n        (star x) áµ¥* (A - B * Dâ»Â¹ * Bá´´) â¬áµ¥ x := by\n  simp [Function.star_sum_elim, fromBlocks_mulVec, vecMul_fromBlocks, add_vecMul,\n    dotProduct_mulVec, vecMul_sub, Matrix.mul_assoc, vecMul_mulVec, hD.eq,\n    conjTranspose_nonsing_inv, star_mulVec]\n  abel\n\n"}
{"name":"Matrix.IsHermitian.fromBlocksâ‚â‚","module":"Mathlib.LinearAlgebra.Matrix.SchurComplement","initialProofState":"m : Type u_2\nn : Type u_3\nğ•œ : Type u_5\ninstâœÂ³ : CommRing ğ•œ\ninstâœÂ² : StarRing ğ•œ\ninstâœÂ¹ : Fintype m\ninstâœ : DecidableEq m\nA : Matrix m m ğ•œ\nB : Matrix m n ğ•œ\nD : Matrix n n ğ•œ\nhA : A.IsHermitian\nâŠ¢ Iff (Matrix.fromBlocks A B B.conjTranspose D).IsHermitian (HSub.hSub D (HMul.hMul (HMul.hMul B.conjTranspose (Inv.inv A)) B)).IsHermitian","decl":"theorem IsHermitian.fromBlocksâ‚â‚ [Fintype m] [DecidableEq m] {A : Matrix m m ğ•œ} (B : Matrix m n ğ•œ)\n    (D : Matrix n n ğ•œ) (hA : A.IsHermitian) :\n    (Matrix.fromBlocks A B Bá´´ D).IsHermitian â†” (D - Bá´´ * Aâ»Â¹ * B).IsHermitian := by\n  have hBAB : (Bá´´ * Aâ»Â¹ * B).IsHermitian := by\n    apply isHermitian_conjTranspose_mul_mul\n    apply hA.inv\n  rw [isHermitian_fromBlocks_iff]\n  constructor\n  Â· intro h\n    apply IsHermitian.sub h.2.2.2 hBAB\n  Â· intro h\n    refine âŸ¨hA, rfl, conjTranspose_conjTranspose B, ?_âŸ©\n    rw [â† sub_add_cancel D]\n    apply IsHermitian.add h hBAB\n\n"}
{"name":"Matrix.IsHermitian.fromBlocksâ‚‚â‚‚","module":"Mathlib.LinearAlgebra.Matrix.SchurComplement","initialProofState":"m : Type u_2\nn : Type u_3\nğ•œ : Type u_5\ninstâœÂ³ : CommRing ğ•œ\ninstâœÂ² : StarRing ğ•œ\ninstâœÂ¹ : Fintype n\ninstâœ : DecidableEq n\nA : Matrix m m ğ•œ\nB : Matrix m n ğ•œ\nD : Matrix n n ğ•œ\nhD : D.IsHermitian\nâŠ¢ Iff (Matrix.fromBlocks A B B.conjTranspose D).IsHermitian (HSub.hSub A (HMul.hMul (HMul.hMul B (Inv.inv D)) B.conjTranspose)).IsHermitian","decl":"theorem IsHermitian.fromBlocksâ‚‚â‚‚ [Fintype n] [DecidableEq n] (A : Matrix m m ğ•œ) (B : Matrix m n ğ•œ)\n    {D : Matrix n n ğ•œ} (hD : D.IsHermitian) :\n    (Matrix.fromBlocks A B Bá´´ D).IsHermitian â†” (A - B * Dâ»Â¹ * Bá´´).IsHermitian := by\n  rw [â† isHermitian_submatrix_equiv (Equiv.sumComm n m), Equiv.sumComm_apply,\n    fromBlocks_submatrix_sum_swap_sum_swap]\n  convert IsHermitian.fromBlocksâ‚â‚ _ _ hD <;> simp\n\n"}
{"name":"Matrix.PosSemidef.fromBlocksâ‚â‚","module":"Mathlib.LinearAlgebra.Matrix.SchurComplement","initialProofState":"m : Type u_2\nn : Type u_3\nğ•œ : Type u_5\ninstâœâ· : CommRing ğ•œ\ninstâœâ¶ : StarRing ğ•œ\ninstâœâµ : PartialOrder ğ•œ\ninstâœâ´ : StarOrderedRing ğ•œ\ninstâœÂ³ : Fintype m\ninstâœÂ² : DecidableEq m\ninstâœÂ¹ : Fintype n\nA : Matrix m m ğ•œ\nB : Matrix m n ğ•œ\nD : Matrix n n ğ•œ\nhA : A.PosDef\ninstâœ : Invertible A\nâŠ¢ Iff (Matrix.fromBlocks A B B.conjTranspose D).PosSemidef (HSub.hSub D (HMul.hMul (HMul.hMul B.conjTranspose (Inv.inv A)) B)).PosSemidef","decl":"theorem PosSemidef.fromBlocksâ‚â‚ [Fintype m] [DecidableEq m] [Fintype n] {A : Matrix m m ğ•œ}\n    (B : Matrix m n ğ•œ) (D : Matrix n n ğ•œ) (hA : A.PosDef) [Invertible A] :\n    (fromBlocks A B Bá´´ D).PosSemidef â†” (D - Bá´´ * Aâ»Â¹ * B).PosSemidef := by\n  rw [PosSemidef, IsHermitian.fromBlocksâ‚â‚ _ _ hA.1]\n  constructor\n  Â· refine fun h => âŸ¨h.1, fun x => ?_âŸ©\n    have := h.2 (-((Aâ»Â¹ * B) *áµ¥ x) âŠ•áµ¥ x)\n    rw [dotProduct_mulVec, schur_complement_eqâ‚â‚ B D _ _ hA.1, neg_add_cancel, dotProduct_zero,\n      zero_add] at this\n    rw [dotProduct_mulVec]; exact this\n  Â· refine fun h => âŸ¨h.1, fun x => ?_âŸ©\n    rw [dotProduct_mulVec, â† Sum.elim_comp_inl_inr x, schur_complement_eqâ‚â‚ B D _ _ hA.1]\n    apply le_add_of_nonneg_of_le\n    Â· rw [â† dotProduct_mulVec]\n      apply hA.posSemidef.2\n    Â· rw [â† dotProduct_mulVec (star (x âˆ˜ Sum.inr))]\n      apply h.2\n\n"}
{"name":"Matrix.PosSemidef.fromBlocksâ‚‚â‚‚","module":"Mathlib.LinearAlgebra.Matrix.SchurComplement","initialProofState":"m : Type u_2\nn : Type u_3\nğ•œ : Type u_5\ninstâœâ· : CommRing ğ•œ\ninstâœâ¶ : StarRing ğ•œ\ninstâœâµ : PartialOrder ğ•œ\ninstâœâ´ : StarOrderedRing ğ•œ\ninstâœÂ³ : Fintype m\ninstâœÂ² : Fintype n\ninstâœÂ¹ : DecidableEq n\nA : Matrix m m ğ•œ\nB : Matrix m n ğ•œ\nD : Matrix n n ğ•œ\nhD : D.PosDef\ninstâœ : Invertible D\nâŠ¢ Iff (Matrix.fromBlocks A B B.conjTranspose D).PosSemidef (HSub.hSub A (HMul.hMul (HMul.hMul B (Inv.inv D)) B.conjTranspose)).PosSemidef","decl":"theorem PosSemidef.fromBlocksâ‚‚â‚‚ [Fintype m] [Fintype n] [DecidableEq n] (A : Matrix m m ğ•œ)\n    (B : Matrix m n ğ•œ) {D : Matrix n n ğ•œ} (hD : D.PosDef) [Invertible D] :\n    (fromBlocks A B Bá´´ D).PosSemidef â†” (A - B * Dâ»Â¹ * Bá´´).PosSemidef := by\n  rw [â† posSemidef_submatrix_equiv (Equiv.sumComm n m), Equiv.sumComm_apply,\n    fromBlocks_submatrix_sum_swap_sum_swap]\n  convert PosSemidef.fromBlocksâ‚â‚ Bá´´ A hD <;>\n    simp\n\n"}
