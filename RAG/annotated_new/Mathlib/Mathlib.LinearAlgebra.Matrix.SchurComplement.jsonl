{"name":"Matrix.fromBlocks_eq_of_invertible₁₁","module":"Mathlib.LinearAlgebra.Matrix.SchurComplement","initialProofState":"l : Type u_1\nm : Type u_2\nn : Type u_3\nα : Type u_4\ninst✝⁷ : Fintype l\ninst✝⁶ : Fintype m\ninst✝⁵ : Fintype n\ninst✝⁴ : DecidableEq l\ninst✝³ : DecidableEq m\ninst✝² : DecidableEq n\ninst✝¹ : CommRing α\nA : Matrix m m α\nB : Matrix m n α\nC : Matrix l m α\nD : Matrix l n α\ninst✝ : Invertible A\n⊢ Eq (Matrix.fromBlocks A B C D) (HMul.hMul (HMul.hMul (Matrix.fromBlocks 1 0 (HMul.hMul C (Invertible.invOf A)) 1) (Matrix.fromBlocks A 0 0 (HSub.hSub D (HMul.hMul (HMul.hMul C (Invertible.invOf A)) B)))) (Matrix.fromBlocks 1 (HMul.hMul (Invertible.invOf A) B) 0 1))","decl":"/-- LDU decomposition of a block matrix with an invertible top-left corner, using the\nSchur complement. -/\ntheorem fromBlocks_eq_of_invertible₁₁ (A : Matrix m m α) (B : Matrix m n α) (C : Matrix l m α)\n    (D : Matrix l n α) [Invertible A] :\n    fromBlocks A B C D =\n      fromBlocks 1 0 (C * ⅟ A) 1 * fromBlocks A 0 0 (D - C * ⅟ A * B) *\n        fromBlocks 1 (⅟ A * B) 0 1 := by\n  simp only [fromBlocks_multiply, Matrix.mul_zero, Matrix.zero_mul, add_zero, zero_add,\n    Matrix.one_mul, Matrix.mul_one, invOf_mul_self, Matrix.mul_invOf_cancel_left,\n    Matrix.invOf_mul_cancel_right, Matrix.mul_assoc, add_sub_cancel]\n\n"}
{"name":"Matrix.fromBlocks_eq_of_invertible₂₂","module":"Mathlib.LinearAlgebra.Matrix.SchurComplement","initialProofState":"l : Type u_1\nm : Type u_2\nn : Type u_3\nα : Type u_4\ninst✝⁷ : Fintype l\ninst✝⁶ : Fintype m\ninst✝⁵ : Fintype n\ninst✝⁴ : DecidableEq l\ninst✝³ : DecidableEq m\ninst✝² : DecidableEq n\ninst✝¹ : CommRing α\nA : Matrix l m α\nB : Matrix l n α\nC : Matrix n m α\nD : Matrix n n α\ninst✝ : Invertible D\n⊢ Eq (Matrix.fromBlocks A B C D) (HMul.hMul (HMul.hMul (Matrix.fromBlocks 1 (HMul.hMul B (Invertible.invOf D)) 0 1) (Matrix.fromBlocks (HSub.hSub A (HMul.hMul (HMul.hMul B (Invertible.invOf D)) C)) 0 0 D)) (Matrix.fromBlocks 1 0 (HMul.hMul (Invertible.invOf D) C) 1))","decl":"/-- LDU decomposition of a block matrix with an invertible bottom-right corner, using the\nSchur complement. -/\ntheorem fromBlocks_eq_of_invertible₂₂ (A : Matrix l m α) (B : Matrix l n α) (C : Matrix n m α)\n    (D : Matrix n n α) [Invertible D] :\n    fromBlocks A B C D =\n      fromBlocks 1 (B * ⅟ D) 0 1 * fromBlocks (A - B * ⅟ D * C) 0 0 D *\n        fromBlocks 1 0 (⅟ D * C) 1 :=\n  (Matrix.reindex (Equiv.sumComm _ _) (Equiv.sumComm _ _)).injective <| by\n    simpa [reindex_apply, Equiv.sumComm_symm, ← submatrix_mul_equiv _ _ _ (Equiv.sumComm n m), ←\n      submatrix_mul_equiv _ _ _ (Equiv.sumComm n l), Equiv.sumComm_apply,\n      fromBlocks_submatrix_sum_swap_sum_swap] using fromBlocks_eq_of_invertible₁₁ D C B A\n\n"}
{"name":"Matrix.invOf_fromBlocks_zero₂₁_eq","module":"Mathlib.LinearAlgebra.Matrix.SchurComplement","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type u_4\ninst✝⁷ : Fintype m\ninst✝⁶ : Fintype n\ninst✝⁵ : DecidableEq m\ninst✝⁴ : DecidableEq n\ninst✝³ : CommRing α\nA : Matrix m m α\nB : Matrix m n α\nD : Matrix n n α\ninst✝² : Invertible A\ninst✝¹ : Invertible D\ninst✝ : Invertible (Matrix.fromBlocks A B 0 D)\n⊢ Eq (Invertible.invOf (Matrix.fromBlocks A B 0 D)) (Matrix.fromBlocks (Invertible.invOf A) (Neg.neg (HMul.hMul (HMul.hMul (Invertible.invOf A) B) (Invertible.invOf D))) 0 (Invertible.invOf D))","decl":"theorem invOf_fromBlocks_zero₂₁_eq (A : Matrix m m α) (B : Matrix m n α) (D : Matrix n n α)\n    [Invertible A] [Invertible D] [Invertible (fromBlocks A B 0 D)] :\n    ⅟ (fromBlocks A B 0 D) = fromBlocks (⅟ A) (-(⅟ A * B * ⅟ D)) 0 (⅟ D) := by\n  letI := fromBlocksZero₂₁Invertible A B D\n  convert (rfl : ⅟ (fromBlocks A B 0 D) = _)\n\n"}
{"name":"Matrix.invOf_fromBlocks_zero₁₂_eq","module":"Mathlib.LinearAlgebra.Matrix.SchurComplement","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type u_4\ninst✝⁷ : Fintype m\ninst✝⁶ : Fintype n\ninst✝⁵ : DecidableEq m\ninst✝⁴ : DecidableEq n\ninst✝³ : CommRing α\nA : Matrix m m α\nC : Matrix n m α\nD : Matrix n n α\ninst✝² : Invertible A\ninst✝¹ : Invertible D\ninst✝ : Invertible (Matrix.fromBlocks A 0 C D)\n⊢ Eq (Invertible.invOf (Matrix.fromBlocks A 0 C D)) (Matrix.fromBlocks (Invertible.invOf A) 0 (Neg.neg (HMul.hMul (HMul.hMul (Invertible.invOf D) C) (Invertible.invOf A))) (Invertible.invOf D))","decl":"theorem invOf_fromBlocks_zero₁₂_eq (A : Matrix m m α) (C : Matrix n m α) (D : Matrix n n α)\n    [Invertible A] [Invertible D] [Invertible (fromBlocks A 0 C D)] :\n    ⅟ (fromBlocks A 0 C D) = fromBlocks (⅟ A) 0 (-(⅟ D * C * ⅟ A)) (⅟ D) := by\n  letI := fromBlocksZero₁₂Invertible A C D\n  convert (rfl : ⅟ (fromBlocks A 0 C D) = _)\n\n"}
{"name":"Matrix.isUnit_fromBlocks_zero₂₁","module":"Mathlib.LinearAlgebra.Matrix.SchurComplement","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type u_4\ninst✝⁴ : Fintype m\ninst✝³ : Fintype n\ninst✝² : DecidableEq m\ninst✝¹ : DecidableEq n\ninst✝ : CommRing α\nA : Matrix m m α\nB : Matrix m n α\nD : Matrix n n α\n⊢ Iff (IsUnit (Matrix.fromBlocks A B 0 D)) (And (IsUnit A) (IsUnit D))","decl":"/-- An upper block-triangular matrix is invertible iff both elements of its diagonal are.\n\nThis is a propositional form of `Matrix.fromBlocksZero₂₁InvertibleEquiv`. -/\n@[simp]\ntheorem isUnit_fromBlocks_zero₂₁ {A : Matrix m m α} {B : Matrix m n α} {D : Matrix n n α} :\n    IsUnit (fromBlocks A B 0 D) ↔ IsUnit A ∧ IsUnit D := by\n  simp only [← nonempty_invertible_iff_isUnit, ← nonempty_prod,\n    (fromBlocksZero₂₁InvertibleEquiv _ _ _).nonempty_congr]\n\n"}
{"name":"Matrix.isUnit_fromBlocks_zero₁₂","module":"Mathlib.LinearAlgebra.Matrix.SchurComplement","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type u_4\ninst✝⁴ : Fintype m\ninst✝³ : Fintype n\ninst✝² : DecidableEq m\ninst✝¹ : DecidableEq n\ninst✝ : CommRing α\nA : Matrix m m α\nC : Matrix n m α\nD : Matrix n n α\n⊢ Iff (IsUnit (Matrix.fromBlocks A 0 C D)) (And (IsUnit A) (IsUnit D))","decl":"/-- A lower block-triangular matrix is invertible iff both elements of its diagonal are.\n\nThis is a propositional form of `Matrix.fromBlocksZero₁₂InvertibleEquiv` forms an `iff`. -/\n@[simp]\ntheorem isUnit_fromBlocks_zero₁₂ {A : Matrix m m α} {C : Matrix n m α} {D : Matrix n n α} :\n    IsUnit (fromBlocks A 0 C D) ↔ IsUnit A ∧ IsUnit D := by\n  simp only [← nonempty_invertible_iff_isUnit, ← nonempty_prod,\n    (fromBlocksZero₁₂InvertibleEquiv _ _ _).nonempty_congr]\n\n"}
{"name":"Matrix.inv_fromBlocks_zero₂₁_of_isUnit_iff","module":"Mathlib.LinearAlgebra.Matrix.SchurComplement","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type u_4\ninst✝⁴ : Fintype m\ninst✝³ : Fintype n\ninst✝² : DecidableEq m\ninst✝¹ : DecidableEq n\ninst✝ : CommRing α\nA : Matrix m m α\nB : Matrix m n α\nD : Matrix n n α\nhAD : Iff (IsUnit A) (IsUnit D)\n⊢ Eq (Inv.inv (Matrix.fromBlocks A B 0 D)) (Matrix.fromBlocks (Inv.inv A) (Neg.neg (HMul.hMul (HMul.hMul (Inv.inv A) B) (Inv.inv D))) 0 (Inv.inv D))","decl":"/-- An expression for the inverse of an upper block-triangular matrix, when either both elements of\ndiagonal are invertible, or both are not. -/\ntheorem inv_fromBlocks_zero₂₁_of_isUnit_iff (A : Matrix m m α) (B : Matrix m n α) (D : Matrix n n α)\n    (hAD : IsUnit A ↔ IsUnit D) :\n    (fromBlocks A B 0 D)⁻¹ = fromBlocks A⁻¹ (-(A⁻¹ * B * D⁻¹)) 0 D⁻¹ := by\n  by_cases hA : IsUnit A\n  · have hD := hAD.mp hA\n    cases hA.nonempty_invertible\n    cases hD.nonempty_invertible\n    letI := fromBlocksZero₂₁Invertible A B D\n    simp_rw [← invOf_eq_nonsing_inv, invOf_fromBlocks_zero₂₁_eq]\n  · have hD := hAD.not.mp hA\n    have : ¬IsUnit (fromBlocks A B 0 D) :=\n      isUnit_fromBlocks_zero₂₁.not.mpr (not_and'.mpr fun _ => hA)\n    simp_rw [nonsing_inv_eq_ring_inverse, Ring.inverse_non_unit _ hA, Ring.inverse_non_unit _ hD,\n      Ring.inverse_non_unit _ this, Matrix.zero_mul, neg_zero, fromBlocks_zero]\n\n"}
{"name":"Matrix.inv_fromBlocks_zero₁₂_of_isUnit_iff","module":"Mathlib.LinearAlgebra.Matrix.SchurComplement","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type u_4\ninst✝⁴ : Fintype m\ninst✝³ : Fintype n\ninst✝² : DecidableEq m\ninst✝¹ : DecidableEq n\ninst✝ : CommRing α\nA : Matrix m m α\nC : Matrix n m α\nD : Matrix n n α\nhAD : Iff (IsUnit A) (IsUnit D)\n⊢ Eq (Inv.inv (Matrix.fromBlocks A 0 C D)) (Matrix.fromBlocks (Inv.inv A) 0 (Neg.neg (HMul.hMul (HMul.hMul (Inv.inv D) C) (Inv.inv A))) (Inv.inv D))","decl":"/-- An expression for the inverse of a lower block-triangular matrix, when either both elements of\ndiagonal are invertible, or both are not. -/\ntheorem inv_fromBlocks_zero₁₂_of_isUnit_iff (A : Matrix m m α) (C : Matrix n m α) (D : Matrix n n α)\n    (hAD : IsUnit A ↔ IsUnit D) :\n    (fromBlocks A 0 C D)⁻¹ = fromBlocks A⁻¹ 0 (-(D⁻¹ * C * A⁻¹)) D⁻¹ := by\n  by_cases hA : IsUnit A\n  · have hD := hAD.mp hA\n    cases hA.nonempty_invertible\n    cases hD.nonempty_invertible\n    letI := fromBlocksZero₁₂Invertible A C D\n    simp_rw [← invOf_eq_nonsing_inv, invOf_fromBlocks_zero₁₂_eq]\n  · have hD := hAD.not.mp hA\n    have : ¬IsUnit (fromBlocks A 0 C D) :=\n      isUnit_fromBlocks_zero₁₂.not.mpr (not_and'.mpr fun _ => hA)\n    simp_rw [nonsing_inv_eq_ring_inverse, Ring.inverse_non_unit _ hA, Ring.inverse_non_unit _ hD,\n      Ring.inverse_non_unit _ this, Matrix.zero_mul, neg_zero, fromBlocks_zero]\n\n"}
{"name":"Matrix.invOf_fromBlocks₂₂_eq","module":"Mathlib.LinearAlgebra.Matrix.SchurComplement","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type u_4\ninst✝⁷ : Fintype m\ninst✝⁶ : Fintype n\ninst✝⁵ : DecidableEq m\ninst✝⁴ : DecidableEq n\ninst✝³ : CommRing α\nA : Matrix m m α\nB : Matrix m n α\nC : Matrix n m α\nD : Matrix n n α\ninst✝² : Invertible D\ninst✝¹ : Invertible (HSub.hSub A (HMul.hMul (HMul.hMul B (Invertible.invOf D)) C))\ninst✝ : Invertible (Matrix.fromBlocks A B C D)\n⊢ Eq (Invertible.invOf (Matrix.fromBlocks A B C D)) (Matrix.fromBlocks (Invertible.invOf (HSub.hSub A (HMul.hMul (HMul.hMul B (Invertible.invOf D)) C))) (Neg.neg (HMul.hMul (HMul.hMul (Invertible.invOf (HSub.hSub A (HMul.hMul (HMul.hMul B (Invertible.invOf D)) C))) B) (Invertible.invOf D))) (Neg.neg (HMul.hMul (HMul.hMul (Invertible.invOf D) C) (Invertible.invOf (HSub.hSub A (HMul.hMul (HMul.hMul B (Invertible.invOf D)) C))))) (HAdd.hAdd (Invertible.invOf D) (HMul.hMul (HMul.hMul (HMul.hMul (HMul.hMul (Invertible.invOf D) C) (Invertible.invOf (HSub.hSub A (HMul.hMul (HMul.hMul B (Invertible.invOf D)) C)))) B) (Invertible.invOf D))))","decl":"theorem invOf_fromBlocks₂₂_eq (A : Matrix m m α) (B : Matrix m n α) (C : Matrix n m α)\n    (D : Matrix n n α) [Invertible D] [Invertible (A - B * ⅟ D * C)]\n    [Invertible (fromBlocks A B C D)] :\n    ⅟ (fromBlocks A B C D) =\n      fromBlocks (⅟ (A - B * ⅟ D * C)) (-(⅟ (A - B * ⅟ D * C) * B * ⅟ D))\n        (-(⅟ D * C * ⅟ (A - B * ⅟ D * C))) (⅟ D + ⅟ D * C * ⅟ (A - B * ⅟ D * C) * B * ⅟ D) := by\n  letI := fromBlocks₂₂Invertible A B C D\n  convert (rfl : ⅟ (fromBlocks A B C D) = _)\n\n"}
{"name":"Matrix.invOf_fromBlocks₁₁_eq","module":"Mathlib.LinearAlgebra.Matrix.SchurComplement","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type u_4\ninst✝⁷ : Fintype m\ninst✝⁶ : Fintype n\ninst✝⁵ : DecidableEq m\ninst✝⁴ : DecidableEq n\ninst✝³ : CommRing α\nA : Matrix m m α\nB : Matrix m n α\nC : Matrix n m α\nD : Matrix n n α\ninst✝² : Invertible A\ninst✝¹ : Invertible (HSub.hSub D (HMul.hMul (HMul.hMul C (Invertible.invOf A)) B))\ninst✝ : Invertible (Matrix.fromBlocks A B C D)\n⊢ Eq (Invertible.invOf (Matrix.fromBlocks A B C D)) (Matrix.fromBlocks (HAdd.hAdd (Invertible.invOf A) (HMul.hMul (HMul.hMul (HMul.hMul (HMul.hMul (Invertible.invOf A) B) (Invertible.invOf (HSub.hSub D (HMul.hMul (HMul.hMul C (Invertible.invOf A)) B)))) C) (Invertible.invOf A))) (Neg.neg (HMul.hMul (HMul.hMul (Invertible.invOf A) B) (Invertible.invOf (HSub.hSub D (HMul.hMul (HMul.hMul C (Invertible.invOf A)) B))))) (Neg.neg (HMul.hMul (HMul.hMul (Invertible.invOf (HSub.hSub D (HMul.hMul (HMul.hMul C (Invertible.invOf A)) B))) C) (Invertible.invOf A))) (Invertible.invOf (HSub.hSub D (HMul.hMul (HMul.hMul C (Invertible.invOf A)) B))))","decl":"theorem invOf_fromBlocks₁₁_eq (A : Matrix m m α) (B : Matrix m n α) (C : Matrix n m α)\n    (D : Matrix n n α) [Invertible A] [Invertible (D - C * ⅟ A * B)]\n    [Invertible (fromBlocks A B C D)] :\n    ⅟ (fromBlocks A B C D) =\n      fromBlocks (⅟ A + ⅟ A * B * ⅟ (D - C * ⅟ A * B) * C * ⅟ A) (-(⅟ A * B * ⅟ (D - C * ⅟ A * B)))\n        (-(⅟ (D - C * ⅟ A * B) * C * ⅟ A)) (⅟ (D - C * ⅟ A * B)) := by\n  letI := fromBlocks₁₁Invertible A B C D\n  convert (rfl : ⅟ (fromBlocks A B C D) = _)\n\n"}
{"name":"Matrix.isUnit_fromBlocks_iff_of_invertible₂₂","module":"Mathlib.LinearAlgebra.Matrix.SchurComplement","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type u_4\ninst✝⁵ : Fintype m\ninst✝⁴ : Fintype n\ninst✝³ : DecidableEq m\ninst✝² : DecidableEq n\ninst✝¹ : CommRing α\nA : Matrix m m α\nB : Matrix m n α\nC : Matrix n m α\nD : Matrix n n α\ninst✝ : Invertible D\n⊢ Iff (IsUnit (Matrix.fromBlocks A B C D)) (IsUnit (HSub.hSub A (HMul.hMul (HMul.hMul B (Invertible.invOf D)) C)))","decl":"/-- If the bottom-left element of a block matrix is invertible, then the whole matrix is invertible\niff the corresponding schur complement is. -/\ntheorem isUnit_fromBlocks_iff_of_invertible₂₂ {A : Matrix m m α} {B : Matrix m n α}\n    {C : Matrix n m α} {D : Matrix n n α} [Invertible D] :\n    IsUnit (fromBlocks A B C D) ↔ IsUnit (A - B * ⅟ D * C) := by\n  simp only [← nonempty_invertible_iff_isUnit,\n    (invertibleEquivFromBlocks₂₂Invertible A B C D).nonempty_congr]\n\n"}
{"name":"Matrix.isUnit_fromBlocks_iff_of_invertible₁₁","module":"Mathlib.LinearAlgebra.Matrix.SchurComplement","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type u_4\ninst✝⁵ : Fintype m\ninst✝⁴ : Fintype n\ninst✝³ : DecidableEq m\ninst✝² : DecidableEq n\ninst✝¹ : CommRing α\nA : Matrix m m α\nB : Matrix m n α\nC : Matrix n m α\nD : Matrix n n α\ninst✝ : Invertible A\n⊢ Iff (IsUnit (Matrix.fromBlocks A B C D)) (IsUnit (HSub.hSub D (HMul.hMul (HMul.hMul C (Invertible.invOf A)) B)))","decl":"/-- If the top-right element of a block matrix is invertible, then the whole matrix is invertible\niff the corresponding schur complement is. -/\ntheorem isUnit_fromBlocks_iff_of_invertible₁₁ {A : Matrix m m α} {B : Matrix m n α}\n    {C : Matrix n m α} {D : Matrix n n α} [Invertible A] :\n    IsUnit (fromBlocks A B C D) ↔ IsUnit (D - C * ⅟ A * B) := by\n  simp only [← nonempty_invertible_iff_isUnit,\n    (invertibleEquivFromBlocks₁₁Invertible A B C D).nonempty_congr]\n\n"}
{"name":"Matrix.det_fromBlocks₁₁","module":"Mathlib.LinearAlgebra.Matrix.SchurComplement","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type u_4\ninst✝⁵ : Fintype m\ninst✝⁴ : Fintype n\ninst✝³ : DecidableEq m\ninst✝² : DecidableEq n\ninst✝¹ : CommRing α\nA : Matrix m m α\nB : Matrix m n α\nC : Matrix n m α\nD : Matrix n n α\ninst✝ : Invertible A\n⊢ Eq (Matrix.fromBlocks A B C D).det (HMul.hMul A.det (HSub.hSub D (HMul.hMul (HMul.hMul C (Invertible.invOf A)) B)).det)","decl":"/-- Determinant of a 2×2 block matrix, expanded around an invertible top left element in terms of\nthe Schur complement. -/\ntheorem det_fromBlocks₁₁ (A : Matrix m m α) (B : Matrix m n α) (C : Matrix n m α)\n    (D : Matrix n n α) [Invertible A] :\n    (Matrix.fromBlocks A B C D).det = det A * det (D - C * ⅟ A * B) := by\n  rw [fromBlocks_eq_of_invertible₁₁ (A := A), det_mul, det_mul, det_fromBlocks_zero₂₁,\n    det_fromBlocks_zero₂₁, det_fromBlocks_zero₁₂, det_one, det_one, one_mul, one_mul, mul_one]\n\n"}
{"name":"Matrix.det_fromBlocks_one₁₁","module":"Mathlib.LinearAlgebra.Matrix.SchurComplement","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type u_4\ninst✝⁴ : Fintype m\ninst✝³ : Fintype n\ninst✝² : DecidableEq m\ninst✝¹ : DecidableEq n\ninst✝ : CommRing α\nB : Matrix m n α\nC : Matrix n m α\nD : Matrix n n α\n⊢ Eq (Matrix.fromBlocks 1 B C D).det (HSub.hSub D (HMul.hMul C B)).det","decl":"@[simp]\ntheorem det_fromBlocks_one₁₁ (B : Matrix m n α) (C : Matrix n m α) (D : Matrix n n α) :\n    (Matrix.fromBlocks 1 B C D).det = det (D - C * B) := by\n  haveI : Invertible (1 : Matrix m m α) := invertibleOne\n  rw [det_fromBlocks₁₁, invOf_one, Matrix.mul_one, det_one, one_mul]\n\n"}
{"name":"Matrix.det_fromBlocks₂₂","module":"Mathlib.LinearAlgebra.Matrix.SchurComplement","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type u_4\ninst✝⁵ : Fintype m\ninst✝⁴ : Fintype n\ninst✝³ : DecidableEq m\ninst✝² : DecidableEq n\ninst✝¹ : CommRing α\nA : Matrix m m α\nB : Matrix m n α\nC : Matrix n m α\nD : Matrix n n α\ninst✝ : Invertible D\n⊢ Eq (Matrix.fromBlocks A B C D).det (HMul.hMul D.det (HSub.hSub A (HMul.hMul (HMul.hMul B (Invertible.invOf D)) C)).det)","decl":"/-- Determinant of a 2×2 block matrix, expanded around an invertible bottom right element in terms\nof the Schur complement. -/\ntheorem det_fromBlocks₂₂ (A : Matrix m m α) (B : Matrix m n α) (C : Matrix n m α)\n    (D : Matrix n n α) [Invertible D] :\n    (Matrix.fromBlocks A B C D).det = det D * det (A - B * ⅟ D * C) := by\n  have : fromBlocks A B C D =\n      (fromBlocks D C B A).submatrix (Equiv.sumComm _ _) (Equiv.sumComm _ _) := by\n    ext (i j)\n    cases i <;> cases j <;> rfl\n  rw [this, det_submatrix_equiv_self, det_fromBlocks₁₁]\n\n"}
{"name":"Matrix.det_fromBlocks_one₂₂","module":"Mathlib.LinearAlgebra.Matrix.SchurComplement","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type u_4\ninst✝⁴ : Fintype m\ninst✝³ : Fintype n\ninst✝² : DecidableEq m\ninst✝¹ : DecidableEq n\ninst✝ : CommRing α\nA : Matrix m m α\nB : Matrix m n α\nC : Matrix n m α\n⊢ Eq (Matrix.fromBlocks A B C 1).det (HSub.hSub A (HMul.hMul B C)).det","decl":"@[simp]\ntheorem det_fromBlocks_one₂₂ (A : Matrix m m α) (B : Matrix m n α) (C : Matrix n m α) :\n    (Matrix.fromBlocks A B C 1).det = det (A - B * C) := by\n  haveI : Invertible (1 : Matrix n n α) := invertibleOne\n  rw [det_fromBlocks₂₂, invOf_one, Matrix.mul_one, det_one, one_mul]\n\n"}
{"name":"Matrix.det_one_add_mul_comm","module":"Mathlib.LinearAlgebra.Matrix.SchurComplement","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type u_4\ninst✝⁴ : Fintype m\ninst✝³ : Fintype n\ninst✝² : DecidableEq m\ninst✝¹ : DecidableEq n\ninst✝ : CommRing α\nA : Matrix m n α\nB : Matrix n m α\n⊢ Eq (HAdd.hAdd 1 (HMul.hMul A B)).det (HAdd.hAdd 1 (HMul.hMul B A)).det","decl":"/-- The **Weinstein–Aronszajn identity**. Note the `1` on the LHS is of shape m×m, while the `1` on\nthe RHS is of shape n×n. -/\ntheorem det_one_add_mul_comm (A : Matrix m n α) (B : Matrix n m α) :\n    det (1 + A * B) = det (1 + B * A) :=\n  calc\n    det (1 + A * B) = det (fromBlocks 1 (-A) B 1) := by\n      rw [det_fromBlocks_one₂₂, Matrix.neg_mul, sub_neg_eq_add]\n    _ = det (1 + B * A) := by rw [det_fromBlocks_one₁₁, Matrix.mul_neg, sub_neg_eq_add]\n\n"}
{"name":"Matrix.det_mul_add_one_comm","module":"Mathlib.LinearAlgebra.Matrix.SchurComplement","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type u_4\ninst✝⁴ : Fintype m\ninst✝³ : Fintype n\ninst✝² : DecidableEq m\ninst✝¹ : DecidableEq n\ninst✝ : CommRing α\nA : Matrix m n α\nB : Matrix n m α\n⊢ Eq (HAdd.hAdd (HMul.hMul A B) 1).det (HAdd.hAdd (HMul.hMul B A) 1).det","decl":"/-- Alternate statement of the **Weinstein–Aronszajn identity** -/\ntheorem det_mul_add_one_comm (A : Matrix m n α) (B : Matrix n m α) :\n    det (A * B + 1) = det (B * A + 1) := by rw [add_comm, det_one_add_mul_comm, add_comm]\n\n"}
{"name":"Matrix.det_one_sub_mul_comm","module":"Mathlib.LinearAlgebra.Matrix.SchurComplement","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type u_4\ninst✝⁴ : Fintype m\ninst✝³ : Fintype n\ninst✝² : DecidableEq m\ninst✝¹ : DecidableEq n\ninst✝ : CommRing α\nA : Matrix m n α\nB : Matrix n m α\n⊢ Eq (HSub.hSub 1 (HMul.hMul A B)).det (HSub.hSub 1 (HMul.hMul B A)).det","decl":"theorem det_one_sub_mul_comm (A : Matrix m n α) (B : Matrix n m α) :\n    det (1 - A * B) = det (1 - B * A) := by\n  rw [sub_eq_add_neg, ← Matrix.neg_mul, det_one_add_mul_comm, Matrix.mul_neg, ← sub_eq_add_neg]\n\n"}
{"name":"Matrix.det_one_add_col_mul_row","module":"Mathlib.LinearAlgebra.Matrix.SchurComplement","initialProofState":"m : Type u_2\nα : Type u_4\ninst✝³ : Fintype m\ninst✝² : DecidableEq m\ninst✝¹ : CommRing α\nι : Type u_5\ninst✝ : Unique ι\nu v : m → α\n⊢ Eq (HAdd.hAdd 1 (HMul.hMul (Matrix.col ι u) (Matrix.row ι v))).det (HAdd.hAdd 1 (dotProduct v u))","decl":"/-- A special case of the **Matrix determinant lemma** for when `A = I`. -/\ntheorem det_one_add_col_mul_row {ι : Type*} [Unique ι] (u v : m → α) :\n    det (1 + col ι u * row ι v) = 1 + v ⬝ᵥ u := by\n  rw [det_one_add_mul_comm, det_unique, Pi.add_apply, Pi.add_apply, Matrix.one_apply_eq,\n    Matrix.row_mul_col_apply]\n\n"}
{"name":"Matrix.det_add_col_mul_row","module":"Mathlib.LinearAlgebra.Matrix.SchurComplement","initialProofState":"m : Type u_2\nα : Type u_4\ninst✝³ : Fintype m\ninst✝² : DecidableEq m\ninst✝¹ : CommRing α\nι : Type u_5\ninst✝ : Unique ι\nA : Matrix m m α\nhA : IsUnit A.det\nu v : m → α\n⊢ Eq (HAdd.hAdd A (HMul.hMul (Matrix.col ι u) (Matrix.row ι v))).det (HMul.hMul A.det (HAdd.hAdd 1 (HMul.hMul (HMul.hMul (Matrix.row ι v) (Inv.inv A)) (Matrix.col ι u))).det)","decl":"/-- The **Matrix determinant lemma**\n\nTODO: show the more general version without `hA : IsUnit A.det` as\n`(A + col u * row v).det = A.det + v ⬝ᵥ (adjugate A) *ᵥ u`.\n-/\ntheorem det_add_col_mul_row {ι : Type*} [Unique ι]\n    {A : Matrix m m α} (hA : IsUnit A.det) (u v : m → α) :\n    (A + col ι u * row ι v).det = A.det * (1 + row ι v * A⁻¹ * col ι u).det := by\n  nth_rewrite 1 [← Matrix.mul_one A]\n  rwa [← Matrix.mul_nonsing_inv_cancel_left A (col ι u * row ι v),\n    ← Matrix.mul_add, det_mul, ← Matrix.mul_assoc, det_one_add_mul_comm,\n    ← Matrix.mul_assoc]\n\n"}
{"name":"Matrix.det_add_mul","module":"Mathlib.LinearAlgebra.Matrix.SchurComplement","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type u_4\ninst✝⁴ : Fintype m\ninst✝³ : Fintype n\ninst✝² : DecidableEq m\ninst✝¹ : DecidableEq n\ninst✝ : CommRing α\nA : Matrix m m α\nU : Matrix m n α\nV : Matrix n m α\nhA : IsUnit A.det\n⊢ Eq (HAdd.hAdd A (HMul.hMul U V)).det (HMul.hMul A.det (HAdd.hAdd 1 (HMul.hMul (HMul.hMul V (Inv.inv A)) U)).det)","decl":"/-- A generalization of the **Matrix determinant lemma** -/\ntheorem det_add_mul {A : Matrix m m α} (U : Matrix m n α)\n    (V : Matrix n m α) (hA : IsUnit A.det) :\n    (A + U * V).det = A.det * (1 + V * A⁻¹ * U).det := by\n  nth_rewrite 1 [← Matrix.mul_one A]\n  rwa [← Matrix.mul_nonsing_inv_cancel_left A (U * V), ← Matrix.mul_add,\n    det_mul, ← Matrix.mul_assoc, det_one_add_mul_comm, ← Matrix.mul_assoc]\n\n"}
{"name":"Matrix.schur_complement_eq₁₁","module":"Mathlib.LinearAlgebra.Matrix.SchurComplement","initialProofState":"m : Type u_2\nn : Type u_3\n𝕜 : Type u_5\ninst✝⁵ : CommRing 𝕜\ninst✝⁴ : StarRing 𝕜\ninst✝³ : Fintype m\ninst✝² : DecidableEq m\ninst✝¹ : Fintype n\nA : Matrix m m 𝕜\nB : Matrix m n 𝕜\nD : Matrix n n 𝕜\nx : m → 𝕜\ny : n → 𝕜\ninst✝ : Invertible A\nhA : A.IsHermitian\n⊢ Eq (dotProduct (Matrix.vecMul (Star.star (Sum.elim x y)) (Matrix.fromBlocks A B B.conjTranspose D)) (Sum.elim x y)) (HAdd.hAdd (dotProduct (Matrix.vecMul (Star.star (HAdd.hAdd x ((HMul.hMul (Inv.inv A) B).mulVec y))) A) (HAdd.hAdd x ((HMul.hMul (Inv.inv A) B).mulVec y))) (dotProduct (Matrix.vecMul (Star.star y) (HSub.hSub D (HMul.hMul (HMul.hMul B.conjTranspose (Inv.inv A)) B))) y))","decl":"theorem schur_complement_eq₁₁ [Fintype m] [DecidableEq m] [Fintype n] {A : Matrix m m 𝕜}\n    (B : Matrix m n 𝕜) (D : Matrix n n 𝕜) (x : m → 𝕜) (y : n → 𝕜) [Invertible A]\n    (hA : A.IsHermitian) :\n    (star (x ⊕ᵥ y)) ᵥ* (fromBlocks A B Bᴴ D) ⬝ᵥ (x ⊕ᵥ y) =\n      (star (x + (A⁻¹ * B) *ᵥ y)) ᵥ* A ⬝ᵥ (x + (A⁻¹ * B) *ᵥ y) +\n        (star y) ᵥ* (D - Bᴴ * A⁻¹ * B) ⬝ᵥ y := by\n  simp [Function.star_sum_elim, fromBlocks_mulVec, vecMul_fromBlocks, add_vecMul,\n    dotProduct_mulVec, vecMul_sub, Matrix.mul_assoc, vecMul_mulVec, hA.eq,\n    conjTranspose_nonsing_inv, star_mulVec]\n  abel\n\n"}
{"name":"Matrix.schur_complement_eq₂₂","module":"Mathlib.LinearAlgebra.Matrix.SchurComplement","initialProofState":"m : Type u_2\nn : Type u_3\n𝕜 : Type u_5\ninst✝⁵ : CommRing 𝕜\ninst✝⁴ : StarRing 𝕜\ninst✝³ : Fintype m\ninst✝² : Fintype n\ninst✝¹ : DecidableEq n\nA : Matrix m m 𝕜\nB : Matrix m n 𝕜\nD : Matrix n n 𝕜\nx : m → 𝕜\ny : n → 𝕜\ninst✝ : Invertible D\nhD : D.IsHermitian\n⊢ Eq (dotProduct (Matrix.vecMul (Star.star (Sum.elim x y)) (Matrix.fromBlocks A B B.conjTranspose D)) (Sum.elim x y)) (HAdd.hAdd (dotProduct (Matrix.vecMul (Star.star (HAdd.hAdd ((HMul.hMul (Inv.inv D) B.conjTranspose).mulVec x) y)) D) (HAdd.hAdd ((HMul.hMul (Inv.inv D) B.conjTranspose).mulVec x) y)) (dotProduct (Matrix.vecMul (Star.star x) (HSub.hSub A (HMul.hMul (HMul.hMul B (Inv.inv D)) B.conjTranspose))) x))","decl":"theorem schur_complement_eq₂₂ [Fintype m] [Fintype n] [DecidableEq n] (A : Matrix m m 𝕜)\n    (B : Matrix m n 𝕜) {D : Matrix n n 𝕜} (x : m → 𝕜) (y : n → 𝕜) [Invertible D]\n    (hD : D.IsHermitian) :\n    (star (x ⊕ᵥ y)) ᵥ* (fromBlocks A B Bᴴ D) ⬝ᵥ (x ⊕ᵥ y) =\n      (star ((D⁻¹ * Bᴴ) *ᵥ x + y)) ᵥ* D ⬝ᵥ ((D⁻¹ * Bᴴ) *ᵥ x + y) +\n        (star x) ᵥ* (A - B * D⁻¹ * Bᴴ) ⬝ᵥ x := by\n  simp [Function.star_sum_elim, fromBlocks_mulVec, vecMul_fromBlocks, add_vecMul,\n    dotProduct_mulVec, vecMul_sub, Matrix.mul_assoc, vecMul_mulVec, hD.eq,\n    conjTranspose_nonsing_inv, star_mulVec]\n  abel\n\n"}
{"name":"Matrix.IsHermitian.fromBlocks₁₁","module":"Mathlib.LinearAlgebra.Matrix.SchurComplement","initialProofState":"m : Type u_2\nn : Type u_3\n𝕜 : Type u_5\ninst✝³ : CommRing 𝕜\ninst✝² : StarRing 𝕜\ninst✝¹ : Fintype m\ninst✝ : DecidableEq m\nA : Matrix m m 𝕜\nB : Matrix m n 𝕜\nD : Matrix n n 𝕜\nhA : A.IsHermitian\n⊢ Iff (Matrix.fromBlocks A B B.conjTranspose D).IsHermitian (HSub.hSub D (HMul.hMul (HMul.hMul B.conjTranspose (Inv.inv A)) B)).IsHermitian","decl":"theorem IsHermitian.fromBlocks₁₁ [Fintype m] [DecidableEq m] {A : Matrix m m 𝕜} (B : Matrix m n 𝕜)\n    (D : Matrix n n 𝕜) (hA : A.IsHermitian) :\n    (Matrix.fromBlocks A B Bᴴ D).IsHermitian ↔ (D - Bᴴ * A⁻¹ * B).IsHermitian := by\n  have hBAB : (Bᴴ * A⁻¹ * B).IsHermitian := by\n    apply isHermitian_conjTranspose_mul_mul\n    apply hA.inv\n  rw [isHermitian_fromBlocks_iff]\n  constructor\n  · intro h\n    apply IsHermitian.sub h.2.2.2 hBAB\n  · intro h\n    refine ⟨hA, rfl, conjTranspose_conjTranspose B, ?_⟩\n    rw [← sub_add_cancel D]\n    apply IsHermitian.add h hBAB\n\n"}
{"name":"Matrix.IsHermitian.fromBlocks₂₂","module":"Mathlib.LinearAlgebra.Matrix.SchurComplement","initialProofState":"m : Type u_2\nn : Type u_3\n𝕜 : Type u_5\ninst✝³ : CommRing 𝕜\ninst✝² : StarRing 𝕜\ninst✝¹ : Fintype n\ninst✝ : DecidableEq n\nA : Matrix m m 𝕜\nB : Matrix m n 𝕜\nD : Matrix n n 𝕜\nhD : D.IsHermitian\n⊢ Iff (Matrix.fromBlocks A B B.conjTranspose D).IsHermitian (HSub.hSub A (HMul.hMul (HMul.hMul B (Inv.inv D)) B.conjTranspose)).IsHermitian","decl":"theorem IsHermitian.fromBlocks₂₂ [Fintype n] [DecidableEq n] (A : Matrix m m 𝕜) (B : Matrix m n 𝕜)\n    {D : Matrix n n 𝕜} (hD : D.IsHermitian) :\n    (Matrix.fromBlocks A B Bᴴ D).IsHermitian ↔ (A - B * D⁻¹ * Bᴴ).IsHermitian := by\n  rw [← isHermitian_submatrix_equiv (Equiv.sumComm n m), Equiv.sumComm_apply,\n    fromBlocks_submatrix_sum_swap_sum_swap]\n  convert IsHermitian.fromBlocks₁₁ _ _ hD <;> simp\n\n"}
{"name":"Matrix.PosSemidef.fromBlocks₁₁","module":"Mathlib.LinearAlgebra.Matrix.SchurComplement","initialProofState":"m : Type u_2\nn : Type u_3\n𝕜 : Type u_5\ninst✝⁷ : CommRing 𝕜\ninst✝⁶ : StarRing 𝕜\ninst✝⁵ : PartialOrder 𝕜\ninst✝⁴ : StarOrderedRing 𝕜\ninst✝³ : Fintype m\ninst✝² : DecidableEq m\ninst✝¹ : Fintype n\nA : Matrix m m 𝕜\nB : Matrix m n 𝕜\nD : Matrix n n 𝕜\nhA : A.PosDef\ninst✝ : Invertible A\n⊢ Iff (Matrix.fromBlocks A B B.conjTranspose D).PosSemidef (HSub.hSub D (HMul.hMul (HMul.hMul B.conjTranspose (Inv.inv A)) B)).PosSemidef","decl":"theorem PosSemidef.fromBlocks₁₁ [Fintype m] [DecidableEq m] [Fintype n] {A : Matrix m m 𝕜}\n    (B : Matrix m n 𝕜) (D : Matrix n n 𝕜) (hA : A.PosDef) [Invertible A] :\n    (fromBlocks A B Bᴴ D).PosSemidef ↔ (D - Bᴴ * A⁻¹ * B).PosSemidef := by\n  rw [PosSemidef, IsHermitian.fromBlocks₁₁ _ _ hA.1]\n  constructor\n  · refine fun h => ⟨h.1, fun x => ?_⟩\n    have := h.2 (-((A⁻¹ * B) *ᵥ x) ⊕ᵥ x)\n    rw [dotProduct_mulVec, schur_complement_eq₁₁ B D _ _ hA.1, neg_add_cancel, dotProduct_zero,\n      zero_add] at this\n    rw [dotProduct_mulVec]; exact this\n  · refine fun h => ⟨h.1, fun x => ?_⟩\n    rw [dotProduct_mulVec, ← Sum.elim_comp_inl_inr x, schur_complement_eq₁₁ B D _ _ hA.1]\n    apply le_add_of_nonneg_of_le\n    · rw [← dotProduct_mulVec]\n      apply hA.posSemidef.2\n    · rw [← dotProduct_mulVec (star (x ∘ Sum.inr))]\n      apply h.2\n\n"}
{"name":"Matrix.PosSemidef.fromBlocks₂₂","module":"Mathlib.LinearAlgebra.Matrix.SchurComplement","initialProofState":"m : Type u_2\nn : Type u_3\n𝕜 : Type u_5\ninst✝⁷ : CommRing 𝕜\ninst✝⁶ : StarRing 𝕜\ninst✝⁵ : PartialOrder 𝕜\ninst✝⁴ : StarOrderedRing 𝕜\ninst✝³ : Fintype m\ninst✝² : Fintype n\ninst✝¹ : DecidableEq n\nA : Matrix m m 𝕜\nB : Matrix m n 𝕜\nD : Matrix n n 𝕜\nhD : D.PosDef\ninst✝ : Invertible D\n⊢ Iff (Matrix.fromBlocks A B B.conjTranspose D).PosSemidef (HSub.hSub A (HMul.hMul (HMul.hMul B (Inv.inv D)) B.conjTranspose)).PosSemidef","decl":"theorem PosSemidef.fromBlocks₂₂ [Fintype m] [Fintype n] [DecidableEq n] (A : Matrix m m 𝕜)\n    (B : Matrix m n 𝕜) {D : Matrix n n 𝕜} (hD : D.PosDef) [Invertible D] :\n    (fromBlocks A B Bᴴ D).PosSemidef ↔ (A - B * D⁻¹ * Bᴴ).PosSemidef := by\n  rw [← posSemidef_submatrix_equiv (Equiv.sumComm n m), Equiv.sumComm_apply,\n    fromBlocks_submatrix_sum_swap_sum_swap]\n  convert PosSemidef.fromBlocks₁₁ Bᴴ A hD <;>\n    simp\n\n"}
