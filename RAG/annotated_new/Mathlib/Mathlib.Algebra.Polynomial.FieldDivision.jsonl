{"name":"Polynomial.rootMultiplicity_sub_one_le_derivative_rootMultiplicity_of_ne_zero","module":"Mathlib.Algebra.Polynomial.FieldDivision","initialProofState":"R : Type u\ninst✝ : CommRing R\np : Polynomial R\nt : R\nhnezero : Ne (Polynomial.derivative p) 0\n⊢ LE.le (HSub.hSub (Polynomial.rootMultiplicity t p) 1) (Polynomial.rootMultiplicity t (Polynomial.derivative p))","decl":"theorem rootMultiplicity_sub_one_le_derivative_rootMultiplicity_of_ne_zero\n    (p : R[X]) (t : R) (hnezero : derivative p ≠ 0) :\n    p.rootMultiplicity t - 1 ≤ p.derivative.rootMultiplicity t :=\n  (le_rootMultiplicity_iff hnezero).2 <|\n    pow_sub_one_dvd_derivative_of_pow_dvd (p.pow_rootMultiplicity_dvd t)\n\n"}
{"name":"Polynomial.derivative_rootMultiplicity_of_root_of_mem_nonZeroDivisors","module":"Mathlib.Algebra.Polynomial.FieldDivision","initialProofState":"R : Type u\ninst✝ : CommRing R\np : Polynomial R\nt : R\nhpt : p.IsRoot t\nhnzd : Membership.mem (nonZeroDivisors R) ↑(Polynomial.rootMultiplicity t p)\n⊢ Eq (Polynomial.rootMultiplicity t (Polynomial.derivative p)) (HSub.hSub (Polynomial.rootMultiplicity t p) 1)","decl":"theorem derivative_rootMultiplicity_of_root_of_mem_nonZeroDivisors\n    {p : R[X]} {t : R} (hpt : Polynomial.IsRoot p t)\n    (hnzd : (p.rootMultiplicity t : R) ∈ nonZeroDivisors R) :\n    (derivative p).rootMultiplicity t = p.rootMultiplicity t - 1 := by\n  by_cases h : p = 0\n  · simp only [h, map_zero, rootMultiplicity_zero]\n  obtain ⟨g, hp, hndvd⟩ := p.exists_eq_pow_rootMultiplicity_mul_and_not_dvd h t\n  set m := p.rootMultiplicity t\n  have hm : m - 1 + 1 = m := Nat.sub_add_cancel <| (rootMultiplicity_pos h).2 hpt\n  have hndvd : ¬(X - C t) ^ m ∣ derivative p := by\n    rw [hp, derivative_mul, dvd_add_left (dvd_mul_right _ _),\n      derivative_X_sub_C_pow, ← hm, pow_succ, hm, mul_comm (C _), mul_assoc,\n      dvd_cancel_left_mem_nonZeroDivisors (monic_X_sub_C t |>.pow _ |>.mem_nonZeroDivisors)]\n    rw [dvd_iff_isRoot, IsRoot] at hndvd ⊢\n    rwa [eval_mul, eval_C, mul_left_mem_nonZeroDivisors_eq_zero_iff hnzd]\n  have hnezero : derivative p ≠ 0 := fun h ↦ hndvd (by rw [h]; exact dvd_zero _)\n  exact le_antisymm (by rwa [rootMultiplicity_le_iff hnezero, hm])\n    (rootMultiplicity_sub_one_le_derivative_rootMultiplicity_of_ne_zero _ t hnezero)\n\n"}
{"name":"Polynomial.isRoot_iterate_derivative_of_lt_rootMultiplicity","module":"Mathlib.Algebra.Polynomial.FieldDivision","initialProofState":"R : Type u\ninst✝ : CommRing R\np : Polynomial R\nt : R\nn : Nat\nhn : LT.lt n (Polynomial.rootMultiplicity t p)\n⊢ (Nat.iterate (⇑Polynomial.derivative) n p).IsRoot t","decl":"theorem isRoot_iterate_derivative_of_lt_rootMultiplicity {p : R[X]} {t : R} {n : ℕ}\n    (hn : n < p.rootMultiplicity t) : (derivative^[n] p).IsRoot t :=\n  dvd_iff_isRoot.mp <| (dvd_pow_self _ <| Nat.sub_ne_zero_of_lt hn).trans\n    (pow_sub_dvd_iterate_derivative_of_pow_dvd _ <| p.pow_rootMultiplicity_dvd t)\n\n"}
{"name":"Polynomial.eval_iterate_derivative_rootMultiplicity","module":"Mathlib.Algebra.Polynomial.FieldDivision","initialProofState":"R : Type u\ninst✝ : CommRing R\np : Polynomial R\nt : R\n⊢ Eq (Polynomial.eval t (Nat.iterate (⇑Polynomial.derivative) (Polynomial.rootMultiplicity t p) p)) (HSMul.hSMul (Polynomial.rootMultiplicity t p).factorial (Polynomial.eval t (p.divByMonic (HPow.hPow (HSub.hSub Polynomial.X (Polynomial.C t)) (Polynomial.rootMultiplicity t p)))))","decl":"open Finset in\ntheorem eval_iterate_derivative_rootMultiplicity {p : R[X]} {t : R} :\n    (derivative^[p.rootMultiplicity t] p).eval t =\n      (p.rootMultiplicity t).factorial • (p /ₘ (X - C t) ^ p.rootMultiplicity t).eval t := by\n  set m := p.rootMultiplicity t with hm\n  conv_lhs => rw [← p.pow_mul_divByMonic_rootMultiplicity_eq t, ← hm]\n  rw [iterate_derivative_mul, eval_finset_sum, sum_eq_single_of_mem _ (mem_range.mpr m.succ_pos)]\n  · rw [m.choose_zero_right, one_smul, eval_mul, m.sub_zero, iterate_derivative_X_sub_pow_self,\n      eval_natCast, nsmul_eq_mul]; rfl\n  · intro b hb hb0\n    rw [iterate_derivative_X_sub_pow, eval_smul, eval_mul, eval_smul, eval_pow,\n      Nat.sub_sub_self (mem_range_succ_iff.mp hb), eval_sub, eval_X, eval_C, sub_self,\n      zero_pow hb0, smul_zero, zero_mul, smul_zero]\n\n"}
{"name":"Polynomial.lt_rootMultiplicity_of_isRoot_iterate_derivative_of_mem_nonZeroDivisors","module":"Mathlib.Algebra.Polynomial.FieldDivision","initialProofState":"R : Type u\ninst✝ : CommRing R\np : Polynomial R\nt : R\nn : Nat\nh : Ne p 0\nhroot : ∀ (m : Nat), LE.le m n → (Nat.iterate (⇑Polynomial.derivative) m p).IsRoot t\nhnzd : Membership.mem (nonZeroDivisors R) ↑n.factorial\n⊢ LT.lt n (Polynomial.rootMultiplicity t p)","decl":"theorem lt_rootMultiplicity_of_isRoot_iterate_derivative_of_mem_nonZeroDivisors\n    {p : R[X]} {t : R} {n : ℕ} (h : p ≠ 0)\n    (hroot : ∀ m ≤ n, (derivative^[m] p).IsRoot t)\n    (hnzd : (n.factorial : R) ∈ nonZeroDivisors R) :\n    n < p.rootMultiplicity t := by\n  by_contra! h'\n  replace hroot := hroot _ h'\n  simp only [IsRoot, eval_iterate_derivative_rootMultiplicity] at hroot\n  obtain ⟨q, hq⟩ := Nat.cast_dvd_cast (α := R) <| Nat.factorial_dvd_factorial h'\n  rw [hq, mul_mem_nonZeroDivisors] at hnzd\n  rw [nsmul_eq_mul, mul_left_mem_nonZeroDivisors_eq_zero_iff hnzd.1] at hroot\n  exact eval_divByMonic_pow_rootMultiplicity_ne_zero t h hroot\n\n"}
{"name":"Polynomial.lt_rootMultiplicity_of_isRoot_iterate_derivative_of_mem_nonZeroDivisors'","module":"Mathlib.Algebra.Polynomial.FieldDivision","initialProofState":"R : Type u\ninst✝ : CommRing R\np : Polynomial R\nt : R\nn : Nat\nh : Ne p 0\nhroot : ∀ (m : Nat), LE.le m n → (Nat.iterate (⇑Polynomial.derivative) m p).IsRoot t\nhnzd : ∀ (m : Nat), LE.le m n → Ne m 0 → Membership.mem (nonZeroDivisors R) ↑m\n⊢ LT.lt n (Polynomial.rootMultiplicity t p)","decl":"theorem lt_rootMultiplicity_of_isRoot_iterate_derivative_of_mem_nonZeroDivisors'\n    {p : R[X]} {t : R} {n : ℕ} (h : p ≠ 0)\n    (hroot : ∀ m ≤ n, (derivative^[m] p).IsRoot t)\n    (hnzd : ∀ m ≤ n, m ≠ 0 → (m : R) ∈ nonZeroDivisors R) :\n    n < p.rootMultiplicity t := by\n  apply lt_rootMultiplicity_of_isRoot_iterate_derivative_of_mem_nonZeroDivisors h hroot\n  clear hroot\n  induction n with\n  | zero =>\n    simp only [Nat.factorial_zero, Nat.cast_one]\n    exact Submonoid.one_mem _\n  | succ n ih =>\n    rw [Nat.factorial_succ, Nat.cast_mul, mul_mem_nonZeroDivisors]\n    exact ⟨hnzd _ le_rfl n.succ_ne_zero, ih fun m h ↦ hnzd m (h.trans n.le_succ)⟩\n\n"}
{"name":"Polynomial.lt_rootMultiplicity_iff_isRoot_iterate_derivative_of_mem_nonZeroDivisors","module":"Mathlib.Algebra.Polynomial.FieldDivision","initialProofState":"R : Type u\ninst✝ : CommRing R\np : Polynomial R\nt : R\nn : Nat\nh : Ne p 0\nhnzd : Membership.mem (nonZeroDivisors R) ↑n.factorial\n⊢ Iff (LT.lt n (Polynomial.rootMultiplicity t p)) (∀ (m : Nat), LE.le m n → (Nat.iterate (⇑Polynomial.derivative) m p).IsRoot t)","decl":"theorem lt_rootMultiplicity_iff_isRoot_iterate_derivative_of_mem_nonZeroDivisors\n    {p : R[X]} {t : R} {n : ℕ} (h : p ≠ 0)\n    (hnzd : (n.factorial : R) ∈ nonZeroDivisors R) :\n    n < p.rootMultiplicity t ↔ ∀ m ≤ n, (derivative^[m] p).IsRoot t :=\n  ⟨fun hn _ hm ↦ isRoot_iterate_derivative_of_lt_rootMultiplicity <| hm.trans_lt hn,\n    fun hr ↦ lt_rootMultiplicity_of_isRoot_iterate_derivative_of_mem_nonZeroDivisors h hr hnzd⟩\n\n"}
{"name":"Polynomial.lt_rootMultiplicity_iff_isRoot_iterate_derivative_of_mem_nonZeroDivisors'","module":"Mathlib.Algebra.Polynomial.FieldDivision","initialProofState":"R : Type u\ninst✝ : CommRing R\np : Polynomial R\nt : R\nn : Nat\nh : Ne p 0\nhnzd : ∀ (m : Nat), LE.le m n → Ne m 0 → Membership.mem (nonZeroDivisors R) ↑m\n⊢ Iff (LT.lt n (Polynomial.rootMultiplicity t p)) (∀ (m : Nat), LE.le m n → (Nat.iterate (⇑Polynomial.derivative) m p).IsRoot t)","decl":"theorem lt_rootMultiplicity_iff_isRoot_iterate_derivative_of_mem_nonZeroDivisors'\n    {p : R[X]} {t : R} {n : ℕ} (h : p ≠ 0)\n    (hnzd : ∀ m ≤ n, m ≠ 0 → (m : R) ∈ nonZeroDivisors R) :\n    n < p.rootMultiplicity t ↔ ∀ m ≤ n, (derivative^[m] p).IsRoot t :=\n  ⟨fun hn _ hm ↦ isRoot_iterate_derivative_of_lt_rootMultiplicity <| Nat.lt_of_le_of_lt hm hn,\n    fun hr ↦ lt_rootMultiplicity_of_isRoot_iterate_derivative_of_mem_nonZeroDivisors' h hr hnzd⟩\n\n"}
{"name":"Polynomial.one_lt_rootMultiplicity_iff_isRoot_iterate_derivative","module":"Mathlib.Algebra.Polynomial.FieldDivision","initialProofState":"R : Type u\ninst✝ : CommRing R\np : Polynomial R\nt : R\nh : Ne p 0\n⊢ Iff (LT.lt 1 (Polynomial.rootMultiplicity t p)) (∀ (m : Nat), LE.le m 1 → (Nat.iterate (⇑Polynomial.derivative) m p).IsRoot t)","decl":"theorem one_lt_rootMultiplicity_iff_isRoot_iterate_derivative\n    {p : R[X]} {t : R} (h : p ≠ 0) :\n    1 < p.rootMultiplicity t ↔ ∀ m ≤ 1, (derivative^[m] p).IsRoot t :=\n  lt_rootMultiplicity_iff_isRoot_iterate_derivative_of_mem_nonZeroDivisors h\n    (by rw [Nat.factorial_one, Nat.cast_one]; exact Submonoid.one_mem _)\n\n"}
{"name":"Polynomial.one_lt_rootMultiplicity_iff_isRoot","module":"Mathlib.Algebra.Polynomial.FieldDivision","initialProofState":"R : Type u\ninst✝ : CommRing R\np : Polynomial R\nt : R\nh : Ne p 0\n⊢ Iff (LT.lt 1 (Polynomial.rootMultiplicity t p)) (And (p.IsRoot t) ((Polynomial.derivative p).IsRoot t))","decl":"theorem one_lt_rootMultiplicity_iff_isRoot\n    {p : R[X]} {t : R} (h : p ≠ 0) :\n    1 < p.rootMultiplicity t ↔ p.IsRoot t ∧ (derivative p).IsRoot t := by\n  rw [one_lt_rootMultiplicity_iff_isRoot_iterate_derivative h]\n  refine ⟨fun h ↦ ⟨h 0 (by norm_num), h 1 (by norm_num)⟩, fun ⟨h0, h1⟩ m hm ↦ ?_⟩\n  obtain (_|_|m) := m\n  exacts [h0, h1, by omega]\n\n"}
{"name":"Polynomial.one_lt_rootMultiplicity_iff_isRoot_gcd","module":"Mathlib.Algebra.Polynomial.FieldDivision","initialProofState":"R : Type u\ninst✝² : CommRing R\ninst✝¹ : IsDomain R\ninst✝ : GCDMonoid (Polynomial R)\np : Polynomial R\nt : R\nh : Ne p 0\n⊢ Iff (LT.lt 1 (Polynomial.rootMultiplicity t p)) ((GCDMonoid.gcd p (Polynomial.derivative p)).IsRoot t)","decl":"theorem one_lt_rootMultiplicity_iff_isRoot_gcd\n    [GCDMonoid R[X]] {p : R[X]} {t : R} (h : p ≠ 0) :\n    1 < p.rootMultiplicity t ↔ (gcd p (derivative p)).IsRoot t := by\n  simp_rw [one_lt_rootMultiplicity_iff_isRoot h, ← dvd_iff_isRoot, dvd_gcd_iff]\n\n"}
{"name":"Polynomial.derivative_rootMultiplicity_of_root","module":"Mathlib.Algebra.Polynomial.FieldDivision","initialProofState":"R : Type u\ninst✝² : CommRing R\ninst✝¹ : IsDomain R\ninst✝ : CharZero R\np : Polynomial R\nt : R\nhpt : p.IsRoot t\n⊢ Eq (Polynomial.rootMultiplicity t (Polynomial.derivative p)) (HSub.hSub (Polynomial.rootMultiplicity t p) 1)","decl":"theorem derivative_rootMultiplicity_of_root [CharZero R] {p : R[X]} {t : R} (hpt : p.IsRoot t) :\n    p.derivative.rootMultiplicity t = p.rootMultiplicity t - 1 := by\n  by_cases h : p = 0\n  · rw [h, map_zero, rootMultiplicity_zero]\n  exact derivative_rootMultiplicity_of_root_of_mem_nonZeroDivisors hpt <|\n    mem_nonZeroDivisors_of_ne_zero <| Nat.cast_ne_zero.2 ((rootMultiplicity_pos h).2 hpt).ne'\n\n"}
{"name":"Polynomial.rootMultiplicity_sub_one_le_derivative_rootMultiplicity","module":"Mathlib.Algebra.Polynomial.FieldDivision","initialProofState":"R : Type u\ninst✝² : CommRing R\ninst✝¹ : IsDomain R\ninst✝ : CharZero R\np : Polynomial R\nt : R\n⊢ LE.le (HSub.hSub (Polynomial.rootMultiplicity t p) 1) (Polynomial.rootMultiplicity t (Polynomial.derivative p))","decl":"theorem rootMultiplicity_sub_one_le_derivative_rootMultiplicity [CharZero R] (p : R[X]) (t : R) :\n    p.rootMultiplicity t - 1 ≤ p.derivative.rootMultiplicity t := by\n  by_cases h : p.IsRoot t\n  · exact (derivative_rootMultiplicity_of_root h).symm.le\n  · rw [rootMultiplicity_eq_zero h, zero_tsub]\n    exact zero_le _\n\n"}
{"name":"Polynomial.lt_rootMultiplicity_of_isRoot_iterate_derivative","module":"Mathlib.Algebra.Polynomial.FieldDivision","initialProofState":"R : Type u\ninst✝² : CommRing R\ninst✝¹ : IsDomain R\ninst✝ : CharZero R\np : Polynomial R\nt : R\nn : Nat\nh : Ne p 0\nhroot : ∀ (m : Nat), LE.le m n → (Nat.iterate (⇑Polynomial.derivative) m p).IsRoot t\n⊢ LT.lt n (Polynomial.rootMultiplicity t p)","decl":"theorem lt_rootMultiplicity_of_isRoot_iterate_derivative\n    [CharZero R] {p : R[X]} {t : R} {n : ℕ} (h : p ≠ 0)\n    (hroot : ∀ m ≤ n, (derivative^[m] p).IsRoot t) :\n    n < p.rootMultiplicity t :=\n  lt_rootMultiplicity_of_isRoot_iterate_derivative_of_mem_nonZeroDivisors h hroot <|\n    mem_nonZeroDivisors_of_ne_zero <| Nat.cast_ne_zero.2 <| Nat.factorial_ne_zero n\n\n"}
{"name":"Polynomial.lt_rootMultiplicity_iff_isRoot_iterate_derivative","module":"Mathlib.Algebra.Polynomial.FieldDivision","initialProofState":"R : Type u\ninst✝² : CommRing R\ninst✝¹ : IsDomain R\ninst✝ : CharZero R\np : Polynomial R\nt : R\nn : Nat\nh : Ne p 0\n⊢ Iff (LT.lt n (Polynomial.rootMultiplicity t p)) (∀ (m : Nat), LE.le m n → (Nat.iterate (⇑Polynomial.derivative) m p).IsRoot t)","decl":"theorem lt_rootMultiplicity_iff_isRoot_iterate_derivative\n    [CharZero R] {p : R[X]} {t : R} {n : ℕ} (h : p ≠ 0) :\n    n < p.rootMultiplicity t ↔ ∀ m ≤ n, (derivative^[m] p).IsRoot t :=\n  ⟨fun hn _ hm ↦ isRoot_iterate_derivative_of_lt_rootMultiplicity <| Nat.lt_of_le_of_lt hm hn,\n    fun hr ↦ lt_rootMultiplicity_of_isRoot_iterate_derivative h hr⟩\n\n"}
{"name":"Polynomial.isRoot_of_isRoot_of_dvd_derivative_mul","module":"Mathlib.Algebra.Polynomial.FieldDivision","initialProofState":"R : Type u\ninst✝² : CommRing R\ninst✝¹ : IsDomain R\ninst✝ : CharZero R\nf g : Polynomial R\nhf0 : Ne f 0\nhfd : Dvd.dvd f (HMul.hMul (Polynomial.derivative f) g)\na : R\nhaf : f.IsRoot a\n⊢ g.IsRoot a","decl":"/-- A sufficient condition for the set of roots of a nonzero polynomial `f` to be a subset of the\nset of roots of `g` is that `f` divides `f.derivative * g`. Over an algebraically closed field of\ncharacteristic zero, this is also a necessary condition.\nSee `isRoot_of_isRoot_iff_dvd_derivative_mul` -/\ntheorem isRoot_of_isRoot_of_dvd_derivative_mul [CharZero R] {f g : R[X]} (hf0 : f ≠ 0)\n    (hfd : f ∣ f.derivative * g) {a : R} (haf : f.IsRoot a) : g.IsRoot a := by\n  rcases hfd with ⟨r, hr⟩\n  have hdf0 : derivative f ≠ 0 := by\n    contrapose! haf\n    rw [eq_C_of_derivative_eq_zero haf] at hf0 ⊢\n    exact not_isRoot_C _ _ <| C_ne_zero.mp hf0\n  by_contra hg\n  have hdfg0 : f.derivative * g ≠ 0 := mul_ne_zero hdf0 (by rintro rfl; simp at hg)\n  have hr' := congr_arg (rootMultiplicity a) hr\n  rw [rootMultiplicity_mul hdfg0, derivative_rootMultiplicity_of_root haf,\n    rootMultiplicity_eq_zero hg, add_zero, rootMultiplicity_mul (hr ▸ hdfg0), add_comm,\n    Nat.sub_eq_iff_eq_add (Nat.succ_le_iff.2 ((rootMultiplicity_pos hf0).2 haf))] at hr'\n  omega\n\n"}
{"name":"Polynomial.coe_normUnit","module":"Mathlib.Algebra.Polynomial.FieldDivision","initialProofState":"R : Type u\ninst✝² : CommRing R\ninst✝¹ : IsDomain R\ninst✝ : NormalizationMonoid R\np : Polynomial R\n⊢ Eq (↑(NormalizationMonoid.normUnit p)) (Polynomial.C ↑(NormalizationMonoid.normUnit p.leadingCoeff))","decl":"@[simp]\ntheorem coe_normUnit {p : R[X]} : (normUnit p : R[X]) = C ↑(normUnit p.leadingCoeff) := by\n  simp [normUnit]\n\n"}
{"name":"Polynomial.leadingCoeff_normalize","module":"Mathlib.Algebra.Polynomial.FieldDivision","initialProofState":"R : Type u\ninst✝² : CommRing R\ninst✝¹ : IsDomain R\ninst✝ : NormalizationMonoid R\np : Polynomial R\n⊢ Eq (normalize p).leadingCoeff (normalize p.leadingCoeff)","decl":"@[simp]\ntheorem leadingCoeff_normalize (p : R[X]) :\n    leadingCoeff (normalize p) = normalize (leadingCoeff p) := by simp [normalize_apply]\n\n"}
{"name":"Polynomial.Monic.normalize_eq_self","module":"Mathlib.Algebra.Polynomial.FieldDivision","initialProofState":"R : Type u\ninst✝² : CommRing R\ninst✝¹ : IsDomain R\ninst✝ : NormalizationMonoid R\np : Polynomial R\nhp : p.Monic\n⊢ Eq (normalize p) p","decl":"theorem Monic.normalize_eq_self {p : R[X]} (hp : p.Monic) : normalize p = p := by\n  simp only [Polynomial.coe_normUnit, normalize_apply, hp.leadingCoeff, normUnit_one,\n    Units.val_one, Polynomial.C.map_one, mul_one]\n\n"}
{"name":"Polynomial.normalize_monic","module":"Mathlib.Algebra.Polynomial.FieldDivision","initialProofState":"R : Type u\ninst✝² : CommRing R\ninst✝¹ : IsDomain R\ninst✝ : NormalizationMonoid R\np : Polynomial R\nhp : p.Monic\n⊢ Eq (normalize p) p","decl":"@[deprecated Polynomial.Monic.normalize_eq_self (since := \"2024-10-21\")]\nalias normalize_monic := Monic.normalize_eq_self\n\n"}
{"name":"Polynomial.roots_normalize","module":"Mathlib.Algebra.Polynomial.FieldDivision","initialProofState":"R : Type u\ninst✝² : CommRing R\ninst✝¹ : IsDomain R\ninst✝ : NormalizationMonoid R\np : Polynomial R\n⊢ Eq (normalize p).roots p.roots","decl":"theorem roots_normalize {p : R[X]} : (normalize p).roots = p.roots := by\n  rw [normalize_apply, mul_comm, coe_normUnit, roots_C_mul _ (normUnit (leadingCoeff p)).ne_zero]\n\n"}
{"name":"Polynomial.normUnit_X","module":"Mathlib.Algebra.Polynomial.FieldDivision","initialProofState":"R : Type u\ninst✝² : CommRing R\ninst✝¹ : IsDomain R\ninst✝ : NormalizationMonoid R\n⊢ Eq (NormalizationMonoid.normUnit Polynomial.X) 1","decl":"theorem normUnit_X : normUnit (X : Polynomial R) = 1 := by\n  have := coe_normUnit (R := R) (p := X)\n  rwa [leadingCoeff_X, normUnit_one, Units.val_one, map_one, Units.val_eq_one] at this\n\n"}
{"name":"Polynomial.X_eq_normalize","module":"Mathlib.Algebra.Polynomial.FieldDivision","initialProofState":"R : Type u\ninst✝² : CommRing R\ninst✝¹ : IsDomain R\ninst✝ : NormalizationMonoid R\n⊢ Eq Polynomial.X (normalize Polynomial.X)","decl":"theorem X_eq_normalize : (X : Polynomial R) = normalize X := by\n  simp only [normalize_apply, normUnit_X, Units.val_one, mul_one]\n\n"}
{"name":"Polynomial.degree_pos_of_ne_zero_of_nonunit","module":"Mathlib.Algebra.Polynomial.FieldDivision","initialProofState":"R : Type u\ninst✝ : DivisionRing R\np : Polynomial R\nhp0 : Ne p 0\nhp : Not (IsUnit p)\n⊢ LT.lt 0 p.degree","decl":"theorem degree_pos_of_ne_zero_of_nonunit (hp0 : p ≠ 0) (hp : ¬IsUnit p) : 0 < degree p :=\n  lt_of_not_ge fun h => by\n    rw [eq_C_of_degree_le_zero h] at hp0 hp\n    exact hp (IsUnit.map C (IsUnit.mk0 (coeff p 0) (mt C_inj.2 (by simpa using hp0))))\n\n"}
{"name":"Polynomial.map_eq_zero","module":"Mathlib.Algebra.Polynomial.FieldDivision","initialProofState":"R : Type u\nS : Type v\ninst✝² : DivisionRing R\np : Polynomial R\ninst✝¹ : Semiring S\ninst✝ : Nontrivial S\nf : RingHom R S\n⊢ Iff (Eq (Polynomial.map f p) 0) (Eq p 0)","decl":"@[simp]\nprotected theorem map_eq_zero [Semiring S] [Nontrivial S] (f : R →+* S) : p.map f = 0 ↔ p = 0 := by\n  simp only [Polynomial.ext_iff]\n  congr!\n  simp [map_eq_zero, coeff_map, coeff_zero]\n\n"}
{"name":"Polynomial.map_ne_zero","module":"Mathlib.Algebra.Polynomial.FieldDivision","initialProofState":"R : Type u\nS : Type v\ninst✝² : DivisionRing R\np : Polynomial R\ninst✝¹ : Semiring S\ninst✝ : Nontrivial S\nf : RingHom R S\nhp : Ne p 0\n⊢ Ne (Polynomial.map f p) 0","decl":"theorem map_ne_zero [Semiring S] [Nontrivial S] {f : R →+* S} (hp : p ≠ 0) : p.map f ≠ 0 :=\n  mt (Polynomial.map_eq_zero f).1 hp\n\n"}
{"name":"Polynomial.degree_map","module":"Mathlib.Algebra.Polynomial.FieldDivision","initialProofState":"R : Type u\nS : Type v\ninst✝² : DivisionRing R\ninst✝¹ : Semiring S\ninst✝ : Nontrivial S\np : Polynomial R\nf : RingHom R S\n⊢ Eq (Polynomial.map f p).degree p.degree","decl":"@[simp]\ntheorem degree_map [Semiring S] [Nontrivial S] (p : R[X]) (f : R →+* S) :\n    degree (p.map f) = degree p :=\n  p.degree_map_eq_of_injective f.injective\n\n"}
{"name":"Polynomial.natDegree_map","module":"Mathlib.Algebra.Polynomial.FieldDivision","initialProofState":"R : Type u\nS : Type v\ninst✝² : DivisionRing R\np : Polynomial R\ninst✝¹ : Semiring S\ninst✝ : Nontrivial S\nf : RingHom R S\n⊢ Eq (Polynomial.map f p).natDegree p.natDegree","decl":"@[simp]\ntheorem natDegree_map [Semiring S] [Nontrivial S] (f : R →+* S) :\n    natDegree (p.map f) = natDegree p :=\n  natDegree_eq_of_degree_eq (degree_map _ f)\n\n"}
{"name":"Polynomial.leadingCoeff_map","module":"Mathlib.Algebra.Polynomial.FieldDivision","initialProofState":"R : Type u\nS : Type v\ninst✝² : DivisionRing R\np : Polynomial R\ninst✝¹ : Semiring S\ninst✝ : Nontrivial S\nf : RingHom R S\n⊢ Eq (Polynomial.map f p).leadingCoeff (f p.leadingCoeff)","decl":"@[simp]\ntheorem leadingCoeff_map [Semiring S] [Nontrivial S] (f : R →+* S) :\n    leadingCoeff (p.map f) = f (leadingCoeff p) := by\n  simp only [← coeff_natDegree, coeff_map f, natDegree_map]\n\n"}
{"name":"Polynomial.monic_map_iff","module":"Mathlib.Algebra.Polynomial.FieldDivision","initialProofState":"R : Type u\nS : Type v\ninst✝² : DivisionRing R\ninst✝¹ : Semiring S\ninst✝ : Nontrivial S\nf : RingHom R S\np : Polynomial R\n⊢ Iff (Polynomial.map f p).Monic p.Monic","decl":"theorem monic_map_iff [Semiring S] [Nontrivial S] {f : R →+* S} {p : R[X]} :\n    (p.map f).Monic ↔ p.Monic := by\n  rw [Monic, leadingCoeff_map, ← f.map_one, Function.Injective.eq_iff f.injective, Monic]\n\n"}
{"name":"Polynomial.isUnit_iff_degree_eq_zero","module":"Mathlib.Algebra.Polynomial.FieldDivision","initialProofState":"R : Type u\ninst✝ : Field R\np : Polynomial R\n⊢ Iff (IsUnit p) (Eq p.degree 0)","decl":"theorem isUnit_iff_degree_eq_zero : IsUnit p ↔ degree p = 0 :=\n  ⟨degree_eq_zero_of_isUnit, fun h =>\n    have : degree p ≤ 0 := by simp [*, le_refl]\n    have hc : coeff p 0 ≠ 0 := fun hc => by\n      rw [eq_C_of_degree_le_zero this, hc] at h; simp only [map_zero] at h; contradiction\n    isUnit_iff_dvd_one.2\n      ⟨C (coeff p 0)⁻¹, by\n        conv in p => rw [eq_C_of_degree_le_zero this]\n        rw [← C_mul, mul_inv_cancel₀ hc, C_1]⟩⟩\n\n"}
{"name":"Polynomial.div_def","module":"Mathlib.Algebra.Polynomial.FieldDivision","initialProofState":"R : Type u\ninst✝ : Field R\np q : Polynomial R\n⊢ Eq (HDiv.hDiv p q) (HMul.hMul (Polynomial.C (Inv.inv q.leadingCoeff)) (p.divByMonic (HMul.hMul q (Polynomial.C (Inv.inv q.leadingCoeff)))))","decl":"theorem div_def : p / q = C (leadingCoeff q)⁻¹ * (p /ₘ (q * C (leadingCoeff q)⁻¹)) :=\n  rfl\n\n"}
{"name":"Polynomial.mod_def","module":"Mathlib.Algebra.Polynomial.FieldDivision","initialProofState":"R : Type u\ninst✝ : Field R\np q : Polynomial R\n⊢ Eq (HMod.hMod p q) (p.modByMonic (HMul.hMul q (Polynomial.C (Inv.inv q.leadingCoeff))))","decl":"theorem mod_def : p % q = p %ₘ (q * C (leadingCoeff q)⁻¹) := rfl\n\n"}
{"name":"Polynomial.modByMonic_eq_mod","module":"Mathlib.Algebra.Polynomial.FieldDivision","initialProofState":"R : Type u\ninst✝ : Field R\nq p : Polynomial R\nhq : q.Monic\n⊢ Eq (p.modByMonic q) (HMod.hMod p q)","decl":"theorem modByMonic_eq_mod (p : R[X]) (hq : Monic q) : p %ₘ q = p % q :=\n  show p %ₘ q = p %ₘ (q * C (leadingCoeff q)⁻¹) by\n    simp only [Monic.def.1 hq, inv_one, mul_one, C_1]\n\n"}
{"name":"Polynomial.divByMonic_eq_div","module":"Mathlib.Algebra.Polynomial.FieldDivision","initialProofState":"R : Type u\ninst✝ : Field R\nq p : Polynomial R\nhq : q.Monic\n⊢ Eq (p.divByMonic q) (HDiv.hDiv p q)","decl":"theorem divByMonic_eq_div (p : R[X]) (hq : Monic q) : p /ₘ q = p / q :=\n  show p /ₘ q = C (leadingCoeff q)⁻¹ * (p /ₘ (q * C (leadingCoeff q)⁻¹)) by\n    simp only [Monic.def.1 hq, inv_one, C_1, one_mul, mul_one]\n\n"}
{"name":"Polynomial.mod_X_sub_C_eq_C_eval","module":"Mathlib.Algebra.Polynomial.FieldDivision","initialProofState":"R : Type u\ninst✝ : Field R\np : Polynomial R\na : R\n⊢ Eq (HMod.hMod p (HSub.hSub Polynomial.X (Polynomial.C a))) (Polynomial.C (Polynomial.eval a p))","decl":"theorem mod_X_sub_C_eq_C_eval (p : R[X]) (a : R) : p % (X - C a) = C (p.eval a) :=\n  modByMonic_eq_mod p (monic_X_sub_C a) ▸ modByMonic_X_sub_C_eq_C_eval _ _\n\n"}
{"name":"Polynomial.mul_div_eq_iff_isRoot","module":"Mathlib.Algebra.Polynomial.FieldDivision","initialProofState":"R : Type u\na : R\ninst✝ : Field R\np : Polynomial R\n⊢ Iff (Eq (HMul.hMul (HSub.hSub Polynomial.X (Polynomial.C a)) (HDiv.hDiv p (HSub.hSub Polynomial.X (Polynomial.C a)))) p) (p.IsRoot a)","decl":"theorem mul_div_eq_iff_isRoot : (X - C a) * (p / (X - C a)) = p ↔ IsRoot p a :=\n  divByMonic_eq_div p (monic_X_sub_C a) ▸ mul_divByMonic_eq_iff_isRoot\n\n"}
{"name":"Polynomial.mod_eq_self_iff","module":"Mathlib.Algebra.Polynomial.FieldDivision","initialProofState":"R : Type u\ninst✝ : Field R\np q : Polynomial R\nhq0 : Ne q 0\n⊢ Iff (Eq (HMod.hMod p q) p) (LT.lt p.degree q.degree)","decl":"theorem mod_eq_self_iff (hq0 : q ≠ 0) : p % q = p ↔ degree p < degree q :=\n  ⟨fun h => h ▸ EuclideanDomain.mod_lt _ hq0, fun h => by\n    classical\n    have : ¬degree (q * C (leadingCoeff q)⁻¹) ≤ degree p :=\n      not_le_of_gt <| by rwa [degree_mul_leadingCoeff_inv q hq0]\n    rw [mod_def, modByMonic, dif_pos (monic_mul_leadingCoeff_inv hq0)]\n    unfold divModByMonicAux\n    dsimp\n    simp only [this, false_and, if_false]⟩\n\n"}
{"name":"Polynomial.div_eq_zero_iff","module":"Mathlib.Algebra.Polynomial.FieldDivision","initialProofState":"R : Type u\ninst✝ : Field R\np q : Polynomial R\nhq0 : Ne q 0\n⊢ Iff (Eq (HDiv.hDiv p q) 0) (LT.lt p.degree q.degree)","decl":"theorem div_eq_zero_iff (hq0 : q ≠ 0) : p / q = 0 ↔ degree p < degree q :=\n  ⟨fun h => by\n    have := EuclideanDomain.div_add_mod p q\n    rwa [h, mul_zero, zero_add, mod_eq_self_iff hq0] at this,\n  fun h => by\n    have hlt : degree p < degree (q * C (leadingCoeff q)⁻¹) := by\n      rwa [degree_mul_leadingCoeff_inv q hq0]\n    have hm : Monic (q * C (leadingCoeff q)⁻¹) := monic_mul_leadingCoeff_inv hq0\n    rw [div_def, (divByMonic_eq_zero_iff hm).2 hlt, mul_zero]⟩\n\n"}
{"name":"Polynomial.degree_add_div","module":"Mathlib.Algebra.Polynomial.FieldDivision","initialProofState":"R : Type u\ninst✝ : Field R\np q : Polynomial R\nhq0 : Ne q 0\nhpq : LE.le q.degree p.degree\n⊢ Eq (HAdd.hAdd q.degree (HDiv.hDiv p q).degree) p.degree","decl":"theorem degree_add_div (hq0 : q ≠ 0) (hpq : degree q ≤ degree p) :\n    degree q + degree (p / q) = degree p := by\n  have : degree (p % q) < degree (q * (p / q)) :=\n    calc\n      degree (p % q) < degree q := EuclideanDomain.mod_lt _ hq0\n      _ ≤ _ := degree_le_mul_left _ (mt (div_eq_zero_iff hq0).1 (not_lt_of_ge hpq))\n\n  conv_rhs =>\n    rw [← EuclideanDomain.div_add_mod p q, degree_add_eq_left_of_degree_lt this, degree_mul]\n\n"}
{"name":"Polynomial.degree_div_le","module":"Mathlib.Algebra.Polynomial.FieldDivision","initialProofState":"R : Type u\ninst✝ : Field R\np q : Polynomial R\n⊢ LE.le (HDiv.hDiv p q).degree p.degree","decl":"theorem degree_div_le (p q : R[X]) : degree (p / q) ≤ degree p := by\n  by_cases hq : q = 0\n  · simp [hq]\n  · rw [div_def, mul_comm, degree_mul_leadingCoeff_inv _ hq]; exact degree_divByMonic_le _ _\n\n"}
{"name":"Polynomial.degree_div_lt","module":"Mathlib.Algebra.Polynomial.FieldDivision","initialProofState":"R : Type u\ninst✝ : Field R\np q : Polynomial R\nhp : Ne p 0\nhq : LT.lt 0 q.degree\n⊢ LT.lt (HDiv.hDiv p q).degree p.degree","decl":"theorem degree_div_lt (hp : p ≠ 0) (hq : 0 < degree q) : degree (p / q) < degree p := by\n  have hq0 : q ≠ 0 := fun hq0 => by simp [hq0] at hq\n  rw [div_def, mul_comm, degree_mul_leadingCoeff_inv _ hq0]\n  exact degree_divByMonic_lt _ (monic_mul_leadingCoeff_inv hq0) hp\n    (by rw [degree_mul_leadingCoeff_inv _ hq0]; exact hq)\n\n"}
{"name":"Polynomial.isUnit_map","module":"Mathlib.Algebra.Polynomial.FieldDivision","initialProofState":"R : Type u\nk : Type y\ninst✝¹ : Field R\np : Polynomial R\ninst✝ : Field k\nf : RingHom R k\n⊢ Iff (IsUnit (Polynomial.map f p)) (IsUnit p)","decl":"theorem isUnit_map [Field k] (f : R →+* k) : IsUnit (p.map f) ↔ IsUnit p := by\n  simp_rw [isUnit_iff_degree_eq_zero, degree_map]\n\n"}
{"name":"Polynomial.map_div","module":"Mathlib.Algebra.Polynomial.FieldDivision","initialProofState":"R : Type u\nk : Type y\ninst✝¹ : Field R\np q : Polynomial R\ninst✝ : Field k\nf : RingHom R k\n⊢ Eq (Polynomial.map f (HDiv.hDiv p q)) (HDiv.hDiv (Polynomial.map f p) (Polynomial.map f q))","decl":"theorem map_div [Field k] (f : R →+* k) : (p / q).map f = p.map f / q.map f := by\n  if hq0 : q = 0 then simp [hq0]\n  else\n    rw [div_def, div_def, Polynomial.map_mul, map_divByMonic f (monic_mul_leadingCoeff_inv hq0),\n      Polynomial.map_mul, map_C, leadingCoeff_map, map_inv₀]\n\n"}
{"name":"Polynomial.map_mod","module":"Mathlib.Algebra.Polynomial.FieldDivision","initialProofState":"R : Type u\nk : Type y\ninst✝¹ : Field R\np q : Polynomial R\ninst✝ : Field k\nf : RingHom R k\n⊢ Eq (Polynomial.map f (HMod.hMod p q)) (HMod.hMod (Polynomial.map f p) (Polynomial.map f q))","decl":"theorem map_mod [Field k] (f : R →+* k) : (p % q).map f = p.map f % q.map f := by\n  by_cases hq0 : q = 0\n  · simp [hq0]\n  · rw [mod_def, mod_def, leadingCoeff_map f, ← map_inv₀ f, ← map_C f, ← Polynomial.map_mul f,\n      map_modByMonic f (monic_mul_leadingCoeff_inv hq0)]\n\n"}
{"name":"Polynomial.natDegree_mod_lt","module":"Mathlib.Algebra.Polynomial.FieldDivision","initialProofState":"k : Type y\ninst✝ : Field k\np q : Polynomial k\nhq : Ne q.natDegree 0\n⊢ LT.lt (HMod.hMod p q).natDegree q.natDegree","decl":"lemma natDegree_mod_lt [Field k] (p : k[X]) {q : k[X]} (hq : q.natDegree ≠ 0) :\n    (p % q).natDegree < q.natDegree := by\n  have hq' : q.leadingCoeff ≠ 0 := by\n    rw [leadingCoeff_ne_zero]\n    contrapose! hq\n    simp [hq]\n  rw [mod_def]\n  refine (natDegree_modByMonic_lt p ?_ ?_).trans_le ?_\n  · refine monic_mul_C_of_leadingCoeff_mul_eq_one ?_\n    rw [mul_inv_eq_one₀ hq']\n  · contrapose! hq\n    rw [← natDegree_mul_C_eq_of_mul_eq_one ((inv_mul_eq_one₀ hq').mpr rfl)]\n    simp [hq]\n  · exact natDegree_mul_C_le q q.leadingCoeff⁻¹\n\n"}
{"name":"Polynomial.gcd_map","module":"Mathlib.Algebra.Polynomial.FieldDivision","initialProofState":"R : Type u\nk : Type y\ninst✝³ : Field R\np q : Polynomial R\ninst✝² : Field k\ninst✝¹ : DecidableEq R\ninst✝ : DecidableEq k\nf : RingHom R k\n⊢ Eq (EuclideanDomain.gcd (Polynomial.map f p) (Polynomial.map f q)) (Polynomial.map f (EuclideanDomain.gcd p q))","decl":"theorem gcd_map [Field k] [DecidableEq R] [DecidableEq k] (f : R →+* k) :\n    gcd (p.map f) (q.map f) = (gcd p q).map f :=\n  GCD.induction p q (fun x => by simp_rw [Polynomial.map_zero, EuclideanDomain.gcd_zero_left])\n    fun x y _ ih => by rw [gcd_val, ← map_mod, ih, ← gcd_val]\n\n"}
{"name":"Polynomial.eval₂_gcd_eq_zero","module":"Mathlib.Algebra.Polynomial.FieldDivision","initialProofState":"R : Type u\nk : Type y\ninst✝² : Field R\ninst✝¹ : CommSemiring k\ninst✝ : DecidableEq R\nϕ : RingHom R k\nf g : Polynomial R\nα : k\nhf : Eq (Polynomial.eval₂ ϕ α f) 0\nhg : Eq (Polynomial.eval₂ ϕ α g) 0\n⊢ Eq (Polynomial.eval₂ ϕ α (EuclideanDomain.gcd f g)) 0","decl":"theorem eval₂_gcd_eq_zero [CommSemiring k] [DecidableEq R]\n    {ϕ : R →+* k} {f g : R[X]} {α : k} (hf : f.eval₂ ϕ α = 0)\n    (hg : g.eval₂ ϕ α = 0) : (EuclideanDomain.gcd f g).eval₂ ϕ α = 0 := by\n  rw [EuclideanDomain.gcd_eq_gcd_ab f g, Polynomial.eval₂_add, Polynomial.eval₂_mul,\n    Polynomial.eval₂_mul, hf, hg, zero_mul, zero_mul, zero_add]\n\n"}
{"name":"Polynomial.eval_gcd_eq_zero","module":"Mathlib.Algebra.Polynomial.FieldDivision","initialProofState":"R : Type u\ninst✝¹ : Field R\ninst✝ : DecidableEq R\nf g : Polynomial R\nα : R\nhf : Eq (Polynomial.eval α f) 0\nhg : Eq (Polynomial.eval α g) 0\n⊢ Eq (Polynomial.eval α (EuclideanDomain.gcd f g)) 0","decl":"theorem eval_gcd_eq_zero [DecidableEq R] {f g : R[X]} {α : R}\n    (hf : f.eval α = 0) (hg : g.eval α = 0) : (EuclideanDomain.gcd f g).eval α = 0 :=\n  eval₂_gcd_eq_zero hf hg\n\n"}
{"name":"Polynomial.root_left_of_root_gcd","module":"Mathlib.Algebra.Polynomial.FieldDivision","initialProofState":"R : Type u\nk : Type y\ninst✝² : Field R\ninst✝¹ : CommSemiring k\ninst✝ : DecidableEq R\nϕ : RingHom R k\nf g : Polynomial R\nα : k\nhα : Eq (Polynomial.eval₂ ϕ α (EuclideanDomain.gcd f g)) 0\n⊢ Eq (Polynomial.eval₂ ϕ α f) 0","decl":"theorem root_left_of_root_gcd [CommSemiring k] [DecidableEq R] {ϕ : R →+* k} {f g : R[X]} {α : k}\n    (hα : (EuclideanDomain.gcd f g).eval₂ ϕ α = 0) : f.eval₂ ϕ α = 0 := by\n  cases' EuclideanDomain.gcd_dvd_left f g with p hp\n  rw [hp, Polynomial.eval₂_mul, hα, zero_mul]\n\n"}
{"name":"Polynomial.root_right_of_root_gcd","module":"Mathlib.Algebra.Polynomial.FieldDivision","initialProofState":"R : Type u\nk : Type y\ninst✝² : Field R\ninst✝¹ : CommSemiring k\ninst✝ : DecidableEq R\nϕ : RingHom R k\nf g : Polynomial R\nα : k\nhα : Eq (Polynomial.eval₂ ϕ α (EuclideanDomain.gcd f g)) 0\n⊢ Eq (Polynomial.eval₂ ϕ α g) 0","decl":"theorem root_right_of_root_gcd [CommSemiring k] [DecidableEq R] {ϕ : R →+* k} {f g : R[X]} {α : k}\n    (hα : (EuclideanDomain.gcd f g).eval₂ ϕ α = 0) : g.eval₂ ϕ α = 0 := by\n  cases' EuclideanDomain.gcd_dvd_right f g with p hp\n  rw [hp, Polynomial.eval₂_mul, hα, zero_mul]\n\n"}
{"name":"Polynomial.root_gcd_iff_root_left_right","module":"Mathlib.Algebra.Polynomial.FieldDivision","initialProofState":"R : Type u\nk : Type y\ninst✝² : Field R\ninst✝¹ : CommSemiring k\ninst✝ : DecidableEq R\nϕ : RingHom R k\nf g : Polynomial R\nα : k\n⊢ Iff (Eq (Polynomial.eval₂ ϕ α (EuclideanDomain.gcd f g)) 0) (And (Eq (Polynomial.eval₂ ϕ α f) 0) (Eq (Polynomial.eval₂ ϕ α g) 0))","decl":"theorem root_gcd_iff_root_left_right [CommSemiring k] [DecidableEq R]\n    {ϕ : R →+* k} {f g : R[X]} {α : k} :\n    (EuclideanDomain.gcd f g).eval₂ ϕ α = 0 ↔ f.eval₂ ϕ α = 0 ∧ g.eval₂ ϕ α = 0 :=\n  ⟨fun h => ⟨root_left_of_root_gcd h, root_right_of_root_gcd h⟩, fun h => eval₂_gcd_eq_zero h.1 h.2⟩\n\n"}
{"name":"Polynomial.isRoot_gcd_iff_isRoot_left_right","module":"Mathlib.Algebra.Polynomial.FieldDivision","initialProofState":"R : Type u\ninst✝¹ : Field R\ninst✝ : DecidableEq R\nf g : Polynomial R\nα : R\n⊢ Iff ((EuclideanDomain.gcd f g).IsRoot α) (And (f.IsRoot α) (g.IsRoot α))","decl":"theorem isRoot_gcd_iff_isRoot_left_right [DecidableEq R] {f g : R[X]} {α : R} :\n    (EuclideanDomain.gcd f g).IsRoot α ↔ f.IsRoot α ∧ g.IsRoot α :=\n  root_gcd_iff_root_left_right\n\n"}
{"name":"Polynomial.isCoprime_map","module":"Mathlib.Algebra.Polynomial.FieldDivision","initialProofState":"R : Type u\nk : Type y\ninst✝¹ : Field R\np q : Polynomial R\ninst✝ : Field k\nf : RingHom R k\n⊢ Iff (IsCoprime (Polynomial.map f p) (Polynomial.map f q)) (IsCoprime p q)","decl":"theorem isCoprime_map [Field k] (f : R →+* k) : IsCoprime (p.map f) (q.map f) ↔ IsCoprime p q := by\n  classical\n  rw [← EuclideanDomain.gcd_isUnit_iff, ← EuclideanDomain.gcd_isUnit_iff, gcd_map, isUnit_map]\n\n"}
{"name":"Polynomial.mem_roots_map","module":"Mathlib.Algebra.Polynomial.FieldDivision","initialProofState":"R : Type u\nk : Type y\ninst✝² : Field R\np : Polynomial R\ninst✝¹ : CommRing k\ninst✝ : IsDomain k\nf : RingHom R k\nx : k\nhp : Ne p 0\n⊢ Iff (Membership.mem (Polynomial.map f p).roots x) (Eq (Polynomial.eval₂ f x p) 0)","decl":"theorem mem_roots_map [CommRing k] [IsDomain k] {f : R →+* k} {x : k} (hp : p ≠ 0) :\n    x ∈ (p.map f).roots ↔ p.eval₂ f x = 0 := by\n  rw [mem_roots (map_ne_zero hp), IsRoot, Polynomial.eval_map]\n\n"}
{"name":"Polynomial.rootSet_monomial","module":"Mathlib.Algebra.Polynomial.FieldDivision","initialProofState":"R : Type u\nS : Type v\ninst✝³ : Field R\ninst✝² : CommRing S\ninst✝¹ : IsDomain S\ninst✝ : Algebra R S\nn : Nat\nhn : Ne n 0\na : R\nha : Ne a 0\n⊢ Eq (((Polynomial.monomial n) a).rootSet S) (Singleton.singleton 0)","decl":"theorem rootSet_monomial [CommRing S] [IsDomain S] [Algebra R S] {n : ℕ} (hn : n ≠ 0) {a : R}\n    (ha : a ≠ 0) : (monomial n a).rootSet S = {0} := by\n  classical\n  rw [rootSet, aroots_monomial ha,\n    Multiset.toFinset_nsmul _ _ hn, Multiset.toFinset_singleton, Finset.coe_singleton]\n\n"}
{"name":"Polynomial.rootSet_C_mul_X_pow","module":"Mathlib.Algebra.Polynomial.FieldDivision","initialProofState":"R : Type u\nS : Type v\ninst✝³ : Field R\ninst✝² : CommRing S\ninst✝¹ : IsDomain S\ninst✝ : Algebra R S\nn : Nat\nhn : Ne n 0\na : R\nha : Ne a 0\n⊢ Eq ((HMul.hMul (Polynomial.C a) (HPow.hPow Polynomial.X n)).rootSet S) (Singleton.singleton 0)","decl":"theorem rootSet_C_mul_X_pow [CommRing S] [IsDomain S] [Algebra R S] {n : ℕ} (hn : n ≠ 0) {a : R}\n    (ha : a ≠ 0) : rootSet (C a * X ^ n) S = {0} := by\n  rw [C_mul_X_pow_eq_monomial, rootSet_monomial hn ha]\n\n"}
{"name":"Polynomial.rootSet_X_pow","module":"Mathlib.Algebra.Polynomial.FieldDivision","initialProofState":"R : Type u\nS : Type v\ninst✝³ : Field R\ninst✝² : CommRing S\ninst✝¹ : IsDomain S\ninst✝ : Algebra R S\nn : Nat\nhn : Ne n 0\n⊢ Eq ((HPow.hPow Polynomial.X n).rootSet S) (Singleton.singleton 0)","decl":"theorem rootSet_X_pow [CommRing S] [IsDomain S] [Algebra R S] {n : ℕ} (hn : n ≠ 0) :\n    (X ^ n : R[X]).rootSet S = {0} := by\n  rw [← one_mul (X ^ n : R[X]), ← C_1, rootSet_C_mul_X_pow hn]\n  exact one_ne_zero\n\n"}
{"name":"Polynomial.rootSet_prod","module":"Mathlib.Algebra.Polynomial.FieldDivision","initialProofState":"R : Type u\nS : Type v\ninst✝³ : Field R\ninst✝² : CommRing S\ninst✝¹ : IsDomain S\ninst✝ : Algebra R S\nι : Type u_1\nf : ι → Polynomial R\ns : Finset ι\nh : Ne (s.prod f) 0\n⊢ Eq ((s.prod f).rootSet S) (Set.iUnion fun i => Set.iUnion fun h => (f i).rootSet S)","decl":"theorem rootSet_prod [CommRing S] [IsDomain S] [Algebra R S] {ι : Type*} (f : ι → R[X])\n    (s : Finset ι) (h : s.prod f ≠ 0) : (s.prod f).rootSet S = ⋃ i ∈ s, (f i).rootSet S := by\n  classical\n  simp only [rootSet, aroots, ← Finset.mem_coe]\n  rw [Polynomial.map_prod, roots_prod, Finset.bind_toFinset, s.val_toFinset, Finset.coe_biUnion]\n  rwa [← Polynomial.map_prod, Ne, Polynomial.map_eq_zero]\n\n"}
{"name":"Polynomial.roots_C_mul_X_sub_C","module":"Mathlib.Algebra.Polynomial.FieldDivision","initialProofState":"R : Type u\na : R\ninst✝ : Field R\nb : R\nha : Ne a 0\n⊢ Eq (HSub.hSub (HMul.hMul (Polynomial.C a) Polynomial.X) (Polynomial.C b)).roots (Singleton.singleton (HMul.hMul (Inv.inv a) b))","decl":"theorem roots_C_mul_X_sub_C (b : R) (ha : a ≠ 0) : (C a * X - C b).roots = {a⁻¹ * b} := by\n  simp [roots_C_mul_X_sub_C_of_IsUnit b ⟨a, a⁻¹, mul_inv_cancel₀ ha, inv_mul_cancel₀ ha⟩]\n\n"}
{"name":"Polynomial.roots_C_mul_X_add_C","module":"Mathlib.Algebra.Polynomial.FieldDivision","initialProofState":"R : Type u\na : R\ninst✝ : Field R\nb : R\nha : Ne a 0\n⊢ Eq (HAdd.hAdd (HMul.hMul (Polynomial.C a) Polynomial.X) (Polynomial.C b)).roots (Singleton.singleton (Neg.neg (HMul.hMul (Inv.inv a) b)))","decl":"theorem roots_C_mul_X_add_C (b : R) (ha : a ≠ 0) : (C a * X + C b).roots = {-(a⁻¹ * b)} := by\n  simp [roots_C_mul_X_add_C_of_IsUnit b ⟨a, a⁻¹, mul_inv_cancel₀ ha, inv_mul_cancel₀ ha⟩]\n\n"}
{"name":"Polynomial.roots_degree_eq_one","module":"Mathlib.Algebra.Polynomial.FieldDivision","initialProofState":"R : Type u\ninst✝ : Field R\np : Polynomial R\nh : Eq p.degree 1\n⊢ Eq p.roots (Singleton.singleton (Neg.neg (HMul.hMul (Inv.inv (p.coeff 1)) (p.coeff 0))))","decl":"theorem roots_degree_eq_one (h : degree p = 1) : p.roots = {-((p.coeff 1)⁻¹ * p.coeff 0)} := by\n  rw [eq_X_add_C_of_degree_le_one (show degree p ≤ 1 by rw [h])]\n  have : p.coeff 1 ≠ 0 := coeff_ne_zero_of_eq_degree h\n  simp [roots_C_mul_X_add_C _ this]\n\n"}
{"name":"Polynomial.exists_root_of_degree_eq_one","module":"Mathlib.Algebra.Polynomial.FieldDivision","initialProofState":"R : Type u\ninst✝ : Field R\np : Polynomial R\nh : Eq p.degree 1\n⊢ Exists fun x => p.IsRoot x","decl":"theorem exists_root_of_degree_eq_one (h : degree p = 1) : ∃ x, IsRoot p x :=\n  ⟨-((p.coeff 1)⁻¹ * p.coeff 0), by\n    rw [← mem_roots (by simp [← zero_le_degree_iff, h])]\n    simp [roots_degree_eq_one h]⟩\n\n"}
{"name":"Polynomial.coeff_inv_units","module":"Mathlib.Algebra.Polynomial.FieldDivision","initialProofState":"R : Type u\ninst✝ : Field R\nu : Units (Polynomial R)\nn : Nat\n⊢ Eq (Inv.inv ((↑u).coeff n)) ((↑(Inv.inv u)).coeff n)","decl":"theorem coeff_inv_units (u : R[X]ˣ) (n : ℕ) : ((↑u : R[X]).coeff n)⁻¹ = (↑u⁻¹ : R[X]).coeff n := by\n  rw [eq_C_of_degree_eq_zero (degree_coe_units u), eq_C_of_degree_eq_zero (degree_coe_units u⁻¹),\n    coeff_C, coeff_C, inv_eq_one_div]\n  split_ifs\n  · rw [div_eq_iff_mul_eq (coeff_coe_units_zero_ne_zero u), coeff_zero_eq_eval_zero,\n        coeff_zero_eq_eval_zero, ← eval_mul, ← Units.val_mul, inv_mul_cancel]\n    simp\n  · simp\n\n"}
{"name":"Polynomial.monic_normalize","module":"Mathlib.Algebra.Polynomial.FieldDivision","initialProofState":"R : Type u\ninst✝¹ : Field R\np : Polynomial R\ninst✝ : DecidableEq R\nhp0 : Ne p 0\n⊢ (normalize p).Monic","decl":"theorem monic_normalize [DecidableEq R] (hp0 : p ≠ 0) : Monic (normalize p) := by\n  rw [Ne, ← leadingCoeff_eq_zero, ← Ne, ← isUnit_iff_ne_zero] at hp0\n  rw [Monic, leadingCoeff_normalize, normalize_eq_one]\n  apply hp0\n\n"}
{"name":"Polynomial.leadingCoeff_div","module":"Mathlib.Algebra.Polynomial.FieldDivision","initialProofState":"R : Type u\ninst✝ : Field R\np q : Polynomial R\nhpq : LE.le q.degree p.degree\n⊢ Eq (HDiv.hDiv p q).leadingCoeff (HDiv.hDiv p.leadingCoeff q.leadingCoeff)","decl":"theorem leadingCoeff_div (hpq : q.degree ≤ p.degree) :\n    (p / q).leadingCoeff = p.leadingCoeff / q.leadingCoeff := by\n  by_cases hq : q = 0\n  · simp [hq]\n  rw [div_def, leadingCoeff_mul, leadingCoeff_C,\n    leadingCoeff_divByMonic_of_monic (monic_mul_leadingCoeff_inv hq) _, mul_comm,\n    div_eq_mul_inv]\n  rwa [degree_mul_leadingCoeff_inv q hq]\n\n"}
{"name":"Polynomial.div_C_mul","module":"Mathlib.Algebra.Polynomial.FieldDivision","initialProofState":"R : Type u\na : R\ninst✝ : Field R\np q : Polynomial R\n⊢ Eq (HDiv.hDiv p (HMul.hMul (Polynomial.C a) q)) (HMul.hMul (Polynomial.C (Inv.inv a)) (HDiv.hDiv p q))","decl":"theorem div_C_mul : p / (C a * q) = C a⁻¹ * (p / q) := by\n  by_cases ha : a = 0\n  · simp [ha]\n  simp only [div_def, leadingCoeff_mul, mul_inv, leadingCoeff_C, C.map_mul, mul_assoc]\n  congr 3\n  rw [mul_left_comm q, ← mul_assoc, ← C.map_mul, mul_inv_cancel₀ ha, C.map_one, one_mul]\n\n"}
{"name":"Polynomial.C_mul_dvd","module":"Mathlib.Algebra.Polynomial.FieldDivision","initialProofState":"R : Type u\na : R\ninst✝ : Field R\np q : Polynomial R\nha : Ne a 0\n⊢ Iff (Dvd.dvd (HMul.hMul (Polynomial.C a) p) q) (Dvd.dvd p q)","decl":"theorem C_mul_dvd (ha : a ≠ 0) : C a * p ∣ q ↔ p ∣ q :=\n  ⟨fun h => dvd_trans (dvd_mul_left _ _) h, fun ⟨r, hr⟩ =>\n    ⟨C a⁻¹ * r, by\n      rw [mul_assoc, mul_left_comm p, ← mul_assoc, ← C.map_mul, mul_inv_cancel₀ ha, C.map_one,\n        one_mul, hr]⟩⟩\n\n"}
{"name":"Polynomial.dvd_C_mul","module":"Mathlib.Algebra.Polynomial.FieldDivision","initialProofState":"R : Type u\na : R\ninst✝ : Field R\np q : Polynomial R\nha : Ne a 0\n⊢ Iff (Dvd.dvd p (HMul.hMul (Polynomial.C a) q)) (Dvd.dvd p q)","decl":"theorem dvd_C_mul (ha : a ≠ 0) : p ∣ Polynomial.C a * q ↔ p ∣ q :=\n  ⟨fun ⟨r, hr⟩ =>\n    ⟨C a⁻¹ * r, by\n      rw [mul_left_comm p, ← hr, ← mul_assoc, ← C.map_mul, inv_mul_cancel₀ ha, C.map_one,\n        one_mul]⟩,\n    fun h => dvd_trans h (dvd_mul_left _ _)⟩\n\n"}
{"name":"Polynomial.coe_normUnit_of_ne_zero","module":"Mathlib.Algebra.Polynomial.FieldDivision","initialProofState":"R : Type u\ninst✝¹ : Field R\np : Polynomial R\ninst✝ : DecidableEq R\nhp : Ne p 0\n⊢ Eq (↑(NormalizationMonoid.normUnit p)) (Polynomial.C (Inv.inv p.leadingCoeff))","decl":"theorem coe_normUnit_of_ne_zero [DecidableEq R] (hp : p ≠ 0) :\n    (normUnit p : R[X]) = C p.leadingCoeff⁻¹ := by\n  have : p.leadingCoeff ≠ 0 := mt leadingCoeff_eq_zero.mp hp\n  simp [CommGroupWithZero.coe_normUnit _ this]\n\n"}
{"name":"Polynomial.map_dvd_map'","module":"Mathlib.Algebra.Polynomial.FieldDivision","initialProofState":"R : Type u\nk : Type y\ninst✝¹ : Field R\ninst✝ : Field k\nf : RingHom R k\nx y : Polynomial R\n⊢ Iff (Dvd.dvd (Polynomial.map f x) (Polynomial.map f y)) (Dvd.dvd x y)","decl":"theorem map_dvd_map' [Field k] (f : R →+* k) {x y : R[X]} : x.map f ∣ y.map f ↔ x ∣ y := by\n  by_cases H : x = 0\n  · rw [H, Polynomial.map_zero, zero_dvd_iff, zero_dvd_iff, Polynomial.map_eq_zero]\n  · classical\n    rw [← normalize_dvd_iff, ← @normalize_dvd_iff R[X], normalize_apply, normalize_apply,\n      coe_normUnit_of_ne_zero H, coe_normUnit_of_ne_zero (mt (Polynomial.map_eq_zero f).1 H),\n      leadingCoeff_map, ← map_inv₀ f, ← map_C, ← Polynomial.map_mul,\n      map_dvd_map _ f.injective (monic_mul_leadingCoeff_inv H)]\n\n"}
{"name":"Polynomial.degree_normalize","module":"Mathlib.Algebra.Polynomial.FieldDivision","initialProofState":"R : Type u\ninst✝¹ : Field R\np : Polynomial R\ninst✝ : DecidableEq R\n⊢ Eq (normalize p).degree p.degree","decl":"@[simp]\ntheorem degree_normalize [DecidableEq R] : degree (normalize p) = degree p := by\n  simp [normalize_apply]\n\n"}
{"name":"Polynomial.prime_of_degree_eq_one","module":"Mathlib.Algebra.Polynomial.FieldDivision","initialProofState":"R : Type u\ninst✝ : Field R\np : Polynomial R\nhp1 : Eq p.degree 1\n⊢ Prime p","decl":"theorem prime_of_degree_eq_one (hp1 : degree p = 1) : Prime p := by\n  classical\n  have : Prime (normalize p) :=\n    Monic.prime_of_degree_eq_one (hp1 ▸ degree_normalize)\n      (monic_normalize fun hp0 => absurd hp1 (hp0.symm ▸ by simp [degree_zero]))\n  exact (normalize_associated _).prime this\n\n"}
{"name":"Polynomial.irreducible_of_degree_eq_one","module":"Mathlib.Algebra.Polynomial.FieldDivision","initialProofState":"R : Type u\ninst✝ : Field R\np : Polynomial R\nhp1 : Eq p.degree 1\n⊢ Irreducible p","decl":"theorem irreducible_of_degree_eq_one (hp1 : degree p = 1) : Irreducible p :=\n  (prime_of_degree_eq_one hp1).irreducible\n\n"}
{"name":"Polynomial.not_irreducible_C","module":"Mathlib.Algebra.Polynomial.FieldDivision","initialProofState":"R : Type u\ninst✝ : Field R\nx : R\n⊢ Not (Irreducible (Polynomial.C x))","decl":"theorem not_irreducible_C (x : R) : ¬Irreducible (C x) := by\n  by_cases H : x = 0\n  · rw [H, C_0]\n    exact not_irreducible_zero\n  · exact fun hx => Irreducible.not_unit hx <| isUnit_C.2 <| isUnit_iff_ne_zero.2 H\n\n"}
{"name":"Polynomial.degree_pos_of_irreducible","module":"Mathlib.Algebra.Polynomial.FieldDivision","initialProofState":"R : Type u\ninst✝ : Field R\np : Polynomial R\nhp : Irreducible p\n⊢ LT.lt 0 p.degree","decl":"theorem degree_pos_of_irreducible (hp : Irreducible p) : 0 < p.degree :=\n  lt_of_not_ge fun hp0 =>\n    have := eq_C_of_degree_le_zero hp0\n    not_irreducible_C (p.coeff 0) <| this ▸ hp\n\n/- Porting note: factored out a have statement from isCoprime_of_is_root_of_eval_derivative_ne_zero\ninto multiple decls because the original proof was timing out -/\n"}
{"name":"Polynomial.X_sub_C_mul_divByMonic_eq_sub_modByMonic","module":"Mathlib.Algebra.Polynomial.FieldDivision","initialProofState":"K : Type u_1\ninst✝ : Field K\nf : Polynomial K\na : K\n⊢ Eq (HMul.hMul (HSub.hSub Polynomial.X (Polynomial.C a)) (f.divByMonic (HSub.hSub Polynomial.X (Polynomial.C a)))) (HSub.hSub f (f.modByMonic (HSub.hSub Polynomial.X (Polynomial.C a))))","decl":"theorem X_sub_C_mul_divByMonic_eq_sub_modByMonic {K : Type*} [Field K] (f : K[X]) (a : K) :\n    (X - C a) * (f /ₘ (X - C a)) = f - f %ₘ (X - C a) := by\n  rw [eq_sub_iff_add_eq, ← eq_sub_iff_add_eq', modByMonic_eq_sub_mul_div]\n  exact monic_X_sub_C a\n\n/- Porting note: factored out a have statement from isCoprime_of_is_root_of_eval_derivative_ne_zero\nbecause the original proof was timing out -/\n"}
{"name":"Polynomial.divByMonic_add_X_sub_C_mul_derivate_divByMonic_eq_derivative","module":"Mathlib.Algebra.Polynomial.FieldDivision","initialProofState":"K : Type u_1\ninst✝ : Field K\nf : Polynomial K\na : K\n⊢ Eq (HAdd.hAdd (f.divByMonic (HSub.hSub Polynomial.X (Polynomial.C a))) (HMul.hMul (HSub.hSub Polynomial.X (Polynomial.C a)) (Polynomial.derivative (f.divByMonic (HSub.hSub Polynomial.X (Polynomial.C a)))))) (Polynomial.derivative f)","decl":"theorem divByMonic_add_X_sub_C_mul_derivate_divByMonic_eq_derivative\n    {K : Type*} [Field K] (f : K[X]) (a : K) :\n    f /ₘ (X - C a) + (X - C a) * derivative (f /ₘ (X - C a)) = derivative f := by\n  have key := by apply congrArg derivative <| X_sub_C_mul_divByMonic_eq_sub_modByMonic f a\n  rw [modByMonic_X_sub_C_eq_C_eval] at key\n  rw [derivative_mul,derivative_sub,derivative_X,derivative_sub] at key\n  rw [derivative_C,sub_zero,one_mul] at key\n  rw [derivative_C,sub_zero] at key\n  assumption\n\n/- Porting note: factored out another have statement from\nisCoprime_of_is_root_of_eval_derivative_ne_zero because the original proof was timing out -/\n"}
{"name":"Polynomial.X_sub_C_dvd_derivative_of_X_sub_C_dvd_divByMonic","module":"Mathlib.Algebra.Polynomial.FieldDivision","initialProofState":"K : Type u_1\ninst✝ : Field K\nf : Polynomial K\na : K\nhf : Dvd.dvd (HSub.hSub Polynomial.X (Polynomial.C a)) (f.divByMonic (HSub.hSub Polynomial.X (Polynomial.C a)))\n⊢ Dvd.dvd (HSub.hSub Polynomial.X (Polynomial.C a)) (Polynomial.derivative f)","decl":"theorem X_sub_C_dvd_derivative_of_X_sub_C_dvd_divByMonic {K : Type*} [Field K] (f : K[X]) {a : K}\n    (hf : (X - C a) ∣ f /ₘ (X - C a)) : X - C a ∣ derivative f := by\n  have key := divByMonic_add_X_sub_C_mul_derivate_divByMonic_eq_derivative f a\n  have ⟨u,hu⟩ := hf\n  rw [← key, hu, ← mul_add (X - C a) u _]\n  use (u + derivative ((X - C a) * u))\n\n"}
{"name":"Polynomial.isCoprime_of_is_root_of_eval_derivative_ne_zero","module":"Mathlib.Algebra.Polynomial.FieldDivision","initialProofState":"K : Type u_1\ninst✝ : Field K\nf : Polynomial K\na : K\nhf' : Ne (Polynomial.eval a (Polynomial.derivative f)) 0\n⊢ IsCoprime (HSub.hSub Polynomial.X (Polynomial.C a)) (f.divByMonic (HSub.hSub Polynomial.X (Polynomial.C a)))","decl":"/-- If `f` is a polynomial over a field, and `a : K` satisfies `f' a ≠ 0`,\nthen `f / (X - a)` is coprime with `X - a`.\nNote that we do not assume `f a = 0`, because `f / (X - a) = (f - f a) / (X - a)`. -/\ntheorem isCoprime_of_is_root_of_eval_derivative_ne_zero {K : Type*} [Field K] (f : K[X]) (a : K)\n    (hf' : f.derivative.eval a ≠ 0) : IsCoprime (X - C a : K[X]) (f /ₘ (X - C a)) := by\n  classical\n  refine Or.resolve_left\n      (EuclideanDomain.dvd_or_coprime (X - C a) (f /ₘ (X - C a))\n        (irreducible_of_degree_eq_one (Polynomial.degree_X_sub_C a))) ?_\n  contrapose! hf' with h\n  have : X - C a ∣ derivative f := X_sub_C_dvd_derivative_of_X_sub_C_dvd_divByMonic f h\n  rw [← modByMonic_eq_zero_iff_dvd (monic_X_sub_C _), modByMonic_X_sub_C_eq_C_eval] at this\n  rwa [← C_inj, C_0]\n\n"}
{"name":"Polynomial.irreducible_iff_degree_lt","module":"Mathlib.Algebra.Polynomial.FieldDivision","initialProofState":"R : Type u\ninst✝ : Field R\np : Polynomial R\nhp0 : Ne p 0\nhpu : Not (IsUnit p)\n⊢ Iff (Irreducible p) (∀ (q : Polynomial R), LE.le q.degree ↑(HDiv.hDiv p.natDegree 2) → Dvd.dvd q p → IsUnit q)","decl":"/-- To check a polynomial over a field is irreducible, it suffices to check only for\ndivisors that have smaller degree.\n\nSee also: `Polynomial.Monic.irreducible_iff_natDegree`.\n-/\ntheorem irreducible_iff_degree_lt (p : R[X]) (hp0 : p ≠ 0) (hpu : ¬ IsUnit p) :\n    Irreducible p ↔ ∀ q, q.degree ≤ ↑(natDegree p / 2) → q ∣ p → IsUnit q := by\n  rw [← irreducible_mul_leadingCoeff_inv,\n      (monic_mul_leadingCoeff_inv hp0).irreducible_iff_degree_lt]\n  · simp [hp0, natDegree_mul_leadingCoeff_inv]\n  · contrapose! hpu\n    exact isUnit_of_mul_eq_one _ _ hpu\n\n"}
{"name":"Polynomial.irreducible_iff_lt_natDegree_lt","module":"Mathlib.Algebra.Polynomial.FieldDivision","initialProofState":"R : Type u\ninst✝ : Field R\np : Polynomial R\nhp0 : Ne p 0\nhpu : Not (IsUnit p)\n⊢ Iff (Irreducible p) (∀ (q : Polynomial R), q.Monic → Membership.mem (Finset.Ioc 0 (HDiv.hDiv p.natDegree 2)) q.natDegree → Not (Dvd.dvd q p))","decl":"/-- To check a polynomial `p` over a field is irreducible, it suffices to check there are no\ndivisors of degree `0 < d ≤ degree p / 2`.\n\nSee also: `Polynomial.Monic.irreducible_iff_natDegree'`.\n-/\ntheorem irreducible_iff_lt_natDegree_lt {p : R[X]} (hp0 : p ≠ 0) (hpu : ¬ IsUnit p) :\n    Irreducible p ↔ ∀ q, Monic q → natDegree q ∈ Finset.Ioc 0 (natDegree p / 2) → ¬ q ∣ p := by\n  have : p * C (leadingCoeff p)⁻¹ ≠ 1 := by\n    contrapose! hpu\n    exact isUnit_of_mul_eq_one _ _ hpu\n  rw [← irreducible_mul_leadingCoeff_inv,\n      (monic_mul_leadingCoeff_inv hp0).irreducible_iff_lt_natDegree_lt this,\n      natDegree_mul_leadingCoeff_inv _ hp0]\n  simp only [IsUnit.dvd_mul_right\n    (isUnit_C.mpr (IsUnit.mk0 (leadingCoeff p)⁻¹ (inv_ne_zero (leadingCoeff_ne_zero.mpr hp0))))]\n\n"}
{"name":"Polynomial.leadingCoeff_mul_prod_normalizedFactors","module":"Mathlib.Algebra.Polynomial.FieldDivision","initialProofState":"R : Type u\ninst✝¹ : Field R\ninst✝ : DecidableEq R\na : Polynomial R\n⊢ Eq (HMul.hMul (Polynomial.C a.leadingCoeff) (UniqueFactorizationMonoid.normalizedFactors a).prod) a","decl":"open UniqueFactorizationMonoid in\n/--\nThe normalized factors of a polynomial over a field times its leading coefficient give\nthe polynomial.\n-/\ntheorem leadingCoeff_mul_prod_normalizedFactors [DecidableEq R] (a : R[X]) :\n    C a.leadingCoeff * (normalizedFactors a).prod = a := by\n  by_cases ha : a = 0\n  · simp [ha]\n  rw [prod_normalizedFactors_eq, normalize_apply, coe_normUnit, CommGroupWithZero.coe_normUnit,\n    mul_comm, mul_assoc, ← map_mul, inv_mul_cancel₀] <;>\n  simp_all\n\n"}
{"name":"Irreducible.natDegree_pos","module":"Mathlib.Algebra.Polynomial.FieldDivision","initialProofState":"F : Type u_1\ninst✝ : Field F\nf : Polynomial F\nh : Irreducible f\n⊢ LT.lt 0 f.natDegree","decl":"/-- An irreducible polynomial over a field must have positive degree. -/\ntheorem Irreducible.natDegree_pos {F : Type*} [Field F] {f : F[X]} (h : Irreducible f) :\n    0 < f.natDegree := Nat.pos_of_ne_zero fun H ↦ by\n  obtain ⟨x, hf⟩ := natDegree_eq_zero.1 H\n  by_cases hx : x = 0\n  · rw [← hf, hx, map_zero] at h; exact not_irreducible_zero h\n  exact h.1 (hf ▸ isUnit_C.2 (Ne.isUnit hx))\n"}
