{"name":"Module.Flat.ker_lTensor_eq","module":"Mathlib.RingTheory.Flat.Equalizer","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝¹¹ : CommRing R\ninst✝¹⁰ : CommRing S\ninst✝⁹ : Algebra R S\nM : Type u_3\ninst✝⁸ : AddCommGroup M\ninst✝⁷ : Module R M\ninst✝⁶ : Module S M\ninst✝⁵ : IsScalarTower R S M\nN : Type u_4\nP : Type u_5\ninst✝⁴ : AddCommGroup N\ninst✝³ : AddCommGroup P\ninst✝² : Module R N\ninst✝¹ : Module R P\nf : LinearMap (RingHom.id R) N P\ninst✝ : Module.Flat R M\n⊢ Eq (LinearMap.ker ((TensorProduct.AlgebraTensorModule.lTensor S M) f)) (LinearMap.range ((TensorProduct.AlgebraTensorModule.lTensor S M) (LinearMap.ker f).subtype))","decl":"lemma Module.Flat.ker_lTensor_eq [Module.Flat R M] :\n    LinearMap.ker (AlgebraTensorModule.lTensor S M f) =\n      LinearMap.range (AlgebraTensorModule.lTensor S M (LinearMap.ker f).subtype) := by\n  rw [← LinearMap.exact_iff]\n  exact Module.Flat.lTensor_exact M (LinearMap.exact_subtype_ker_map f)\n\n"}
{"name":"Module.Flat.eqLocus_lTensor_eq","module":"Mathlib.RingTheory.Flat.Equalizer","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝¹¹ : CommRing R\ninst✝¹⁰ : CommRing S\ninst✝⁹ : Algebra R S\nM : Type u_3\ninst✝⁸ : AddCommGroup M\ninst✝⁷ : Module R M\ninst✝⁶ : Module S M\ninst✝⁵ : IsScalarTower R S M\nN : Type u_4\nP : Type u_5\ninst✝⁴ : AddCommGroup N\ninst✝³ : AddCommGroup P\ninst✝² : Module R N\ninst✝¹ : Module R P\nf g : LinearMap (RingHom.id R) N P\ninst✝ : Module.Flat R M\n⊢ Eq (LinearMap.eqLocus ((TensorProduct.AlgebraTensorModule.lTensor S M) f) ((TensorProduct.AlgebraTensorModule.lTensor S M) g)) (LinearMap.range ((TensorProduct.AlgebraTensorModule.lTensor S M) (LinearMap.eqLocus f g).subtype))","decl":"lemma Module.Flat.eqLocus_lTensor_eq [Module.Flat R M] :\n    LinearMap.eqLocus (AlgebraTensorModule.lTensor S M f)\n      (AlgebraTensorModule.lTensor S M g) =\n      LinearMap.range (AlgebraTensorModule.lTensor S M (LinearMap.eqLocus f g).subtype) := by\n  rw [LinearMap.eqLocus_eq_ker_sub, LinearMap.eqLocus_eq_ker_sub]\n  rw [← map_sub, ker_lTensor_eq]\n\n"}
{"name":"LinearMap.tensorKer_tmul","module":"Mathlib.RingTheory.Flat.Equalizer","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝¹⁰ : CommRing R\ninst✝⁹ : CommRing S\ninst✝⁸ : Algebra R S\nM : Type u_3\ninst✝⁷ : AddCommGroup M\ninst✝⁶ : Module R M\ninst✝⁵ : Module S M\ninst✝⁴ : IsScalarTower R S M\nN : Type u_4\nP : Type u_5\ninst✝³ : AddCommGroup N\ninst✝² : AddCommGroup P\ninst✝¹ : Module R N\ninst✝ : Module R P\nf : LinearMap (RingHom.id R) N P\nm : M\nx : Subtype fun x => Membership.mem (LinearMap.ker f) x\n⊢ Eq (↑((LinearMap.tensorKer S M f) (TensorProduct.tmul R m x))) (TensorProduct.tmul R m ↑x)","decl":"@[simp]\nlemma LinearMap.tensorKer_tmul (m : M) (x : LinearMap.ker f) :\n    (tensorKer S M f (m ⊗ₜ[R] x) : M ⊗[R] N) = m ⊗ₜ[R] (x : N) :=\n  rfl\n\n"}
{"name":"LinearMap.tensorKer_coe","module":"Mathlib.RingTheory.Flat.Equalizer","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝¹⁰ : CommRing R\ninst✝⁹ : CommRing S\ninst✝⁸ : Algebra R S\nM : Type u_3\ninst✝⁷ : AddCommGroup M\ninst✝⁶ : Module R M\ninst✝⁵ : Module S M\ninst✝⁴ : IsScalarTower R S M\nN : Type u_4\nP : Type u_5\ninst✝³ : AddCommGroup N\ninst✝² : AddCommGroup P\ninst✝¹ : Module R N\ninst✝ : Module R P\nf : LinearMap (RingHom.id R) N P\nx : TensorProduct R M (Subtype fun x => Membership.mem (LinearMap.ker f) x)\n⊢ Eq (↑((LinearMap.tensorKer S M f) x)) ((LinearMap.lTensor M (LinearMap.ker f).subtype) x)","decl":"@[simp]\nlemma LinearMap.tensorKer_coe (x : M ⊗[R] (LinearMap.ker f)) :\n    (tensorKer S M f x : M ⊗[R] N) = (ker f).subtype.lTensor M x := by\n  induction x <;> simp_all\n\n"}
{"name":"LinearMap.tensorEqLocus_tmul","module":"Mathlib.RingTheory.Flat.Equalizer","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝¹⁰ : CommRing R\ninst✝⁹ : CommRing S\ninst✝⁸ : Algebra R S\nM : Type u_3\ninst✝⁷ : AddCommGroup M\ninst✝⁶ : Module R M\ninst✝⁵ : Module S M\ninst✝⁴ : IsScalarTower R S M\nN : Type u_4\nP : Type u_5\ninst✝³ : AddCommGroup N\ninst✝² : AddCommGroup P\ninst✝¹ : Module R N\ninst✝ : Module R P\nf g : LinearMap (RingHom.id R) N P\nm : M\nx : Subtype fun x => Membership.mem (LinearMap.eqLocus f g) x\n⊢ Eq (↑((LinearMap.tensorEqLocus S M f g) (TensorProduct.tmul R m x))) (TensorProduct.tmul R m ↑x)","decl":"@[simp]\nlemma LinearMap.tensorEqLocus_tmul (m : M) (x : LinearMap.eqLocus f g) :\n    (tensorEqLocus S M f g (m ⊗ₜ[R] x) : M ⊗[R] N) = m ⊗ₜ[R] (x : N) :=\n  rfl\n\n"}
{"name":"LinearMap.tensorEqLocus_coe","module":"Mathlib.RingTheory.Flat.Equalizer","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝¹⁰ : CommRing R\ninst✝⁹ : CommRing S\ninst✝⁸ : Algebra R S\nM : Type u_3\ninst✝⁷ : AddCommGroup M\ninst✝⁶ : Module R M\ninst✝⁵ : Module S M\ninst✝⁴ : IsScalarTower R S M\nN : Type u_4\nP : Type u_5\ninst✝³ : AddCommGroup N\ninst✝² : AddCommGroup P\ninst✝¹ : Module R N\ninst✝ : Module R P\nf g : LinearMap (RingHom.id R) N P\nx : TensorProduct R M (Subtype fun x => Membership.mem (LinearMap.eqLocus f g) x)\n⊢ Eq (↑((LinearMap.tensorEqLocus S M f g) x)) ((LinearMap.lTensor M (LinearMap.eqLocus f g).subtype) x)","decl":"@[simp]\nlemma LinearMap.tensorEqLocus_coe (x : M ⊗[R] (LinearMap.eqLocus f g)) :\n    (tensorEqLocus S M f g x : M ⊗[R] N) = (eqLocus f g).subtype.lTensor M x := by\n  induction x <;> simp_all\n\n"}
{"name":"LinearMap.tensorKerEquiv_apply","module":"Mathlib.RingTheory.Flat.Equalizer","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝¹¹ : CommRing R\ninst✝¹⁰ : CommRing S\ninst✝⁹ : Algebra R S\nM : Type u_3\ninst✝⁸ : AddCommGroup M\ninst✝⁷ : Module R M\ninst✝⁶ : Module S M\ninst✝⁵ : IsScalarTower R S M\nN : Type u_4\nP : Type u_5\ninst✝⁴ : AddCommGroup N\ninst✝³ : AddCommGroup P\ninst✝² : Module R N\ninst✝¹ : Module R P\nf : LinearMap (RingHom.id R) N P\ninst✝ : Module.Flat R M\nx : TensorProduct R M (Subtype fun x => Membership.mem (LinearMap.ker f) x)\n⊢ Eq ((LinearMap.tensorKerEquiv S M f) x) ((LinearMap.tensorKer S M f) x)","decl":"@[simp]\nlemma LinearMap.tensorKerEquiv_apply [Module.Flat R M] (x : M ⊗[R] ker f) :\n    tensorKerEquiv S M f x = tensorKer S M f x :=\n  rfl\n\n"}
{"name":"LinearMap.lTensor_ker_subtype_tensorKerEquiv_symm","module":"Mathlib.RingTheory.Flat.Equalizer","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝¹¹ : CommRing R\ninst✝¹⁰ : CommRing S\ninst✝⁹ : Algebra R S\nM : Type u_3\ninst✝⁸ : AddCommGroup M\ninst✝⁷ : Module R M\ninst✝⁶ : Module S M\ninst✝⁵ : IsScalarTower R S M\nN : Type u_4\nP : Type u_5\ninst✝⁴ : AddCommGroup N\ninst✝³ : AddCommGroup P\ninst✝² : Module R N\ninst✝¹ : Module R P\nf : LinearMap (RingHom.id R) N P\ninst✝ : Module.Flat R M\nx : Subtype fun x => Membership.mem (LinearMap.ker ((TensorProduct.AlgebraTensorModule.lTensor S M) f)) x\n⊢ Eq ((LinearMap.lTensor M (LinearMap.ker f).subtype) ((LinearMap.tensorKerEquiv S M f).symm x)) ↑x","decl":"@[simp]\nlemma LinearMap.lTensor_ker_subtype_tensorKerEquiv_symm [Module.Flat R M]\n    (x : ker (AlgebraTensorModule.lTensor S M f)) :\n    (lTensor M (ker f).subtype) ((tensorKerEquiv S M f).symm x) = x :=\n  lTensor_ker_subtype_tensorKerInv S M f x\n\n"}
{"name":"LinearMap.tensorEqLocusEquiv_apply","module":"Mathlib.RingTheory.Flat.Equalizer","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝¹¹ : CommRing R\ninst✝¹⁰ : CommRing S\ninst✝⁹ : Algebra R S\nM : Type u_3\ninst✝⁸ : AddCommGroup M\ninst✝⁷ : Module R M\ninst✝⁶ : Module S M\ninst✝⁵ : IsScalarTower R S M\nN : Type u_4\nP : Type u_5\ninst✝⁴ : AddCommGroup N\ninst✝³ : AddCommGroup P\ninst✝² : Module R N\ninst✝¹ : Module R P\nf g : LinearMap (RingHom.id R) N P\ninst✝ : Module.Flat R M\nx : TensorProduct R M (Subtype fun x => Membership.mem (LinearMap.eqLocus f g) x)\n⊢ Eq ((LinearMap.tensorEqLocusEquiv S M f g) x) ((LinearMap.tensorEqLocus S M f g) x)","decl":"@[simp]\nlemma LinearMap.tensorEqLocusEquiv_apply [Module.Flat R M] (x : M ⊗[R] LinearMap.eqLocus f g) :\n    LinearMap.tensorEqLocusEquiv S M f g x = LinearMap.tensorEqLocus S M f g x :=\n  rfl\n\n"}
{"name":"LinearMap.lTensor_eqLocus_subtype_tensoreqLocusEquiv_symm","module":"Mathlib.RingTheory.Flat.Equalizer","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝¹¹ : CommRing R\ninst✝¹⁰ : CommRing S\ninst✝⁹ : Algebra R S\nM : Type u_3\ninst✝⁸ : AddCommGroup M\ninst✝⁷ : Module R M\ninst✝⁶ : Module S M\ninst✝⁵ : IsScalarTower R S M\nN : Type u_4\nP : Type u_5\ninst✝⁴ : AddCommGroup N\ninst✝³ : AddCommGroup P\ninst✝² : Module R N\ninst✝¹ : Module R P\nf g : LinearMap (RingHom.id R) N P\ninst✝ : Module.Flat R M\nx : Subtype fun x => Membership.mem (LinearMap.eqLocus ((TensorProduct.AlgebraTensorModule.lTensor S M) f) ((TensorProduct.AlgebraTensorModule.lTensor S M) g)) x\n⊢ Eq ((LinearMap.lTensor M (LinearMap.eqLocus f g).subtype) ((LinearMap.tensorEqLocusEquiv S M f g).symm x)) ↑x","decl":"@[simp]\nlemma LinearMap.lTensor_eqLocus_subtype_tensoreqLocusEquiv_symm [Module.Flat R M]\n    (x : eqLocus (AlgebraTensorModule.lTensor S M f) (AlgebraTensorModule.lTensor S M g)) :\n    (lTensor M (eqLocus f g).subtype) ((tensorEqLocusEquiv S M f g).symm x) = x :=\n  lTensor_eqLocus_subtype_tensorEqLocusInv S M f g x\n\n"}
{"name":"AlgHom.coe_tensorEqualizer","module":"Mathlib.RingTheory.Flat.Equalizer","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝¹⁰ : CommRing R\ninst✝⁹ : CommRing S\ninst✝⁸ : Algebra R S\nT : Type u_3\ninst✝⁷ : CommRing T\ninst✝⁶ : Algebra R T\ninst✝⁵ : Algebra S T\ninst✝⁴ : IsScalarTower R S T\nA : Type u_4\nB : Type u_5\ninst✝³ : CommRing A\ninst✝² : CommRing B\ninst✝¹ : Algebra R A\ninst✝ : Algebra R B\nf g : AlgHom R A B\nx : TensorProduct R T (Subtype fun x => Membership.mem (AlgHom.equalizer f g) x)\n⊢ Eq (↑((AlgHom.tensorEqualizer S T f g) x)) ((Algebra.TensorProduct.map (AlgHom.id S T) (AlgHom.equalizer f g).val) x)","decl":"@[simp]\nlemma AlgHom.coe_tensorEqualizer (x : T ⊗[R] AlgHom.equalizer f g) :\n    (AlgHom.tensorEqualizer S T f g x : T ⊗[R] A) =\n      Algebra.TensorProduct.map (AlgHom.id S T) (AlgHom.equalizer f g).val x :=\n  AlgHom.coe_tensorEqualizerAux S T f g x\n\n"}
{"name":"AlgHom.tensorEqualizerEquiv_apply","module":"Mathlib.RingTheory.Flat.Equalizer","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝¹¹ : CommRing R\ninst✝¹⁰ : CommRing S\ninst✝⁹ : Algebra R S\nT : Type u_3\ninst✝⁸ : CommRing T\ninst✝⁷ : Algebra R T\ninst✝⁶ : Algebra S T\ninst✝⁵ : IsScalarTower R S T\nA : Type u_4\nB : Type u_5\ninst✝⁴ : CommRing A\ninst✝³ : CommRing B\ninst✝² : Algebra R A\ninst✝¹ : Algebra R B\nf g : AlgHom R A B\ninst✝ : Module.Flat R T\nx : TensorProduct R T (Subtype fun x => Membership.mem (AlgHom.equalizer f g) x)\n⊢ Eq ((AlgHom.tensorEqualizerEquiv S T f g) x) ((AlgHom.tensorEqualizer S T f g) x)","decl":"@[simp]\nlemma AlgHom.tensorEqualizerEquiv_apply [Module.Flat R T]\n    (x : T ⊗[R] AlgHom.equalizer f g) :\n    AlgHom.tensorEqualizerEquiv S T f g x = AlgHom.tensorEqualizer S T f g x :=\n  rfl\n\n"}
