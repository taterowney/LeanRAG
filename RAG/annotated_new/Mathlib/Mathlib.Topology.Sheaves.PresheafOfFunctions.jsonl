{"name":"TopCat.presheafToTypes_obj","module":"Mathlib.Topology.Sheaves.PresheafOfFunctions","initialProofState":"X : TopCat\nT : ↑X → Type v\nU : Opposite (TopologicalSpace.Opens ↑X)\n⊢ Eq ((X.presheafToTypes T).obj U) ((x : Subtype fun x => Membership.mem (Opposite.unop U) x) → T ↑x)","decl":"@[simp]\ntheorem presheafToTypes_obj {T : X → Type v} {U : (Opens X)ᵒᵖ} :\n    (presheafToTypes X T).obj U = ∀ x : U.unop, T x :=\n  rfl\n\n"}
{"name":"TopCat.presheafToTypes_map","module":"Mathlib.Topology.Sheaves.PresheafOfFunctions","initialProofState":"X : TopCat\nT : ↑X → Type v\nU V : Opposite (TopologicalSpace.Opens ↑X)\ni : Quiver.Hom U V\nf : (X.presheafToTypes T).obj U\n⊢ Eq ((X.presheafToTypes T).map i f) fun x => f ((fun x => ⟨↑x, ⋯⟩) x)","decl":"@[simp]\ntheorem presheafToTypes_map {T : X → Type v} {U V : (Opens X)ᵒᵖ} {i : U ⟶ V} {f} :\n    (presheafToTypes X T).map i f = fun x => f (i.unop x) :=\n  rfl\n\n-- We don't just define this in terms of `presheafToTypes`,\n-- as it's helpful later to see (at a syntactic level) that `(presheafToType X T).obj U`\n-- is a non-dependent function.\n-- We don't use `@[simps]` to generate the projection lemmas here,\n-- as it turns out to be useful to have `presheafToType_map`\n-- written as an equality of functions (rather than being applied to some argument).\n"}
{"name":"TopCat.presheafToType_obj","module":"Mathlib.Topology.Sheaves.PresheafOfFunctions","initialProofState":"X : TopCat\nT : Type v\nU : Opposite (TopologicalSpace.Opens ↑X)\n⊢ Eq ((X.presheafToType T).obj U) ((Subtype fun x => Membership.mem (Opposite.unop U) x) → T)","decl":"@[simp]\ntheorem presheafToType_obj {T : Type v} {U : (Opens X)ᵒᵖ} :\n    (presheafToType X T).obj U = (U.unop → T) :=\n  rfl\n\n"}
{"name":"TopCat.presheafToType_map","module":"Mathlib.Topology.Sheaves.PresheafOfFunctions","initialProofState":"X : TopCat\nT : Type v\nU V : Opposite (TopologicalSpace.Opens ↑X)\ni : Quiver.Hom U V\nf : (X.presheafToType T).obj U\n⊢ Eq ((X.presheafToType T).map i f) (Function.comp f fun x => ⟨↑x, ⋯⟩)","decl":"@[simp]\ntheorem presheafToType_map {T : Type v} {U V : (Opens X)ᵒᵖ} {i : U ⟶ V} {f} :\n    (presheafToType X T).map i f = f ∘ i.unop :=\n  rfl\n\n"}
{"name":"TopCat.presheafToTop_obj","module":"Mathlib.Topology.Sheaves.PresheafOfFunctions","initialProofState":"X T : TopCat\nU : Opposite (TopologicalSpace.Opens ↑X)\n⊢ Eq ((X.presheafToTop T).obj U) (Quiver.Hom ((TopologicalSpace.Opens.toTopCat X).obj (Opposite.unop U)) T)","decl":"@[simp]\ntheorem presheafToTop_obj (T : TopCat.{v}) (U : (Opens X)ᵒᵖ) :\n    (presheafToTop X T).obj U = ((Opens.toTopCat X).obj (unop U) ⟶ T) :=\n  rfl\n\n"}
