{"name":"CategoryTheory.Functor.instIsLeftKanExtensionObjLanAppLanUnit","module":"Mathlib.CategoryTheory.Functor.KanExtension.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœÂ³ : CategoryTheory.Category.{u_4, u_1} C\ninstâœÂ² : CategoryTheory.Category.{u_6, u_2} D\nL : CategoryTheory.Functor C D\nH : Type u_3\ninstâœÂ¹ : CategoryTheory.Category.{u_5, u_3} H\ninstâœ : âˆ€ (F : CategoryTheory.Functor C H), L.HasLeftKanExtension F\nF : CategoryTheory.Functor C H\nâŠ¢ (L.lan.obj F).IsLeftKanExtension (L.lanUnit.app F)","decl":"instance (F : C â¥¤ H) : (L.lan.obj F).IsLeftKanExtension (L.lanUnit.app F) := by\n  dsimp [lan, lanUnit]\n  infer_instance\n\n"}
{"name":"CategoryTheory.Functor.Î¹_leftKanExtensionObjIsoColimit_inv","module":"Mathlib.CategoryTheory.Functor.KanExtension.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœâ´ : CategoryTheory.Category.{u_4, u_1} C\ninstâœÂ³ : CategoryTheory.Category.{u_6, u_2} D\nL : CategoryTheory.Functor C D\nH : Type u_3\ninstâœÂ² : CategoryTheory.Category.{u_5, u_3} H\nF : CategoryTheory.Functor C H\ninstâœÂ¹ : L.HasPointwiseLeftKanExtension F\ninstâœ : L.HasLeftKanExtension F\nX : D\nf : CategoryTheory.CostructuredArrow L X\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.Î¹ ((CategoryTheory.CostructuredArrow.proj L X).comp F) f) (L.leftKanExtensionObjIsoColimit F X).inv) (CategoryTheory.CategoryStruct.comp ((L.leftKanExtensionUnit F).app f.left) ((L.leftKanExtension F).map f.hom))","decl":"@[reassoc (attr := simp)]\nlemma Î¹_leftKanExtensionObjIsoColimit_inv [HasLeftKanExtension L F] (X : D)\n    (f : CostructuredArrow L X) :\n    colimit.Î¹ _ f â‰« (L.leftKanExtensionObjIsoColimit F X).inv =\n    (L.leftKanExtensionUnit F).app f.left â‰« (L.leftKanExtension F).map f.hom := by\n  simp [leftKanExtensionObjIsoColimit, lanUnit]\n\n"}
{"name":"CategoryTheory.Functor.Î¹_leftKanExtensionObjIsoColimit_inv_assoc","module":"Mathlib.CategoryTheory.Functor.KanExtension.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœâ´ : CategoryTheory.Category.{u_4, u_1} C\ninstâœÂ³ : CategoryTheory.Category.{u_6, u_2} D\nL : CategoryTheory.Functor C D\nH : Type u_3\ninstâœÂ² : CategoryTheory.Category.{u_5, u_3} H\nF : CategoryTheory.Functor C H\ninstâœÂ¹ : L.HasPointwiseLeftKanExtension F\ninstâœ : L.HasLeftKanExtension F\nX : D\nf : CategoryTheory.CostructuredArrow L X\nZ : H\nh : Quiver.Hom ((L.leftKanExtension F).obj X) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.Î¹ ((CategoryTheory.CostructuredArrow.proj L X).comp F) f) (CategoryTheory.CategoryStruct.comp (L.leftKanExtensionObjIsoColimit F X).inv h)) (CategoryTheory.CategoryStruct.comp ((L.leftKanExtensionUnit F).app f.left) (CategoryTheory.CategoryStruct.comp ((L.leftKanExtension F).map f.hom) h))","decl":"@[reassoc (attr := simp)]\nlemma Î¹_leftKanExtensionObjIsoColimit_inv [HasLeftKanExtension L F] (X : D)\n    (f : CostructuredArrow L X) :\n    colimit.Î¹ _ f â‰« (L.leftKanExtensionObjIsoColimit F X).inv =\n    (L.leftKanExtensionUnit F).app f.left â‰« (L.leftKanExtension F).map f.hom := by\n  simp [leftKanExtensionObjIsoColimit, lanUnit]\n\n"}
{"name":"CategoryTheory.Functor.Î¹_leftKanExtensionObjIsoColimit_hom","module":"Mathlib.CategoryTheory.Functor.KanExtension.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœÂ³ : CategoryTheory.Category.{u_4, u_1} C\ninstâœÂ² : CategoryTheory.Category.{u_5, u_2} D\nL : CategoryTheory.Functor C D\nH : Type u_3\ninstâœÂ¹ : CategoryTheory.Category.{u_6, u_3} H\nF : CategoryTheory.Functor C H\ninstâœ : L.HasPointwiseLeftKanExtension F\nX : D\nf : CategoryTheory.CostructuredArrow L X\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp ((L.leftKanExtensionUnit F).app f.left) (CategoryTheory.CategoryStruct.comp ((L.leftKanExtension F).map f.hom) (L.leftKanExtensionObjIsoColimit F X).hom)) (CategoryTheory.Limits.colimit.Î¹ ((CategoryTheory.CostructuredArrow.proj L X).comp F) f)","decl":"@[reassoc (attr := simp)]\nlemma Î¹_leftKanExtensionObjIsoColimit_hom (X : D) (f : CostructuredArrow L X) :\n    (L.leftKanExtensionUnit F).app f.left â‰« (L.leftKanExtension F).map f.hom â‰«\n      (L.leftKanExtensionObjIsoColimit F X).hom =\n    colimit.Î¹ (proj L X â‹™ F) f :=\n  LeftExtension.IsPointwiseLeftKanExtensionAt.Î¹_isoColimit_hom (F := F)\n    (isPointwiseLeftKanExtensionLeftKanExtensionUnit L F X) f\n\n"}
{"name":"CategoryTheory.Functor.Î¹_leftKanExtensionObjIsoColimit_hom_assoc","module":"Mathlib.CategoryTheory.Functor.KanExtension.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœÂ³ : CategoryTheory.Category.{u_4, u_1} C\ninstâœÂ² : CategoryTheory.Category.{u_5, u_2} D\nL : CategoryTheory.Functor C D\nH : Type u_3\ninstâœÂ¹ : CategoryTheory.Category.{u_6, u_3} H\nF : CategoryTheory.Functor C H\ninstâœ : L.HasPointwiseLeftKanExtension F\nX : D\nf : CategoryTheory.CostructuredArrow L X\nZ : H\nh : Quiver.Hom (CategoryTheory.Limits.colimit ((CategoryTheory.CostructuredArrow.proj L X).comp F)) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp ((L.leftKanExtensionUnit F).app f.left) (CategoryTheory.CategoryStruct.comp ((L.leftKanExtension F).map f.hom) (CategoryTheory.CategoryStruct.comp (L.leftKanExtensionObjIsoColimit F X).hom h))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.Î¹ ((CategoryTheory.CostructuredArrow.proj L X).comp F) f) h)","decl":"@[reassoc (attr := simp)]\nlemma Î¹_leftKanExtensionObjIsoColimit_hom (X : D) (f : CostructuredArrow L X) :\n    (L.leftKanExtensionUnit F).app f.left â‰« (L.leftKanExtension F).map f.hom â‰«\n      (L.leftKanExtensionObjIsoColimit F X).hom =\n    colimit.Î¹ (proj L X â‹™ F) f :=\n  LeftExtension.IsPointwiseLeftKanExtensionAt.Î¹_isoColimit_hom (F := F)\n    (isPointwiseLeftKanExtensionLeftKanExtensionUnit L F X) f\n\n"}
{"name":"CategoryTheory.Functor.leftKanExtensionUnit_leftKanExtension_map_leftKanExtensionObjIsoColimit_hom","module":"Mathlib.CategoryTheory.Functor.KanExtension.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœÂ³ : CategoryTheory.Category.{u_4, u_1} C\ninstâœÂ² : CategoryTheory.Category.{u_5, u_2} D\nL : CategoryTheory.Functor C D\nH : Type u_3\ninstâœÂ¹ : CategoryTheory.Category.{u_6, u_3} H\nF : CategoryTheory.Functor C H\ninstâœ : L.HasPointwiseLeftKanExtension F\nX : D\nf : CategoryTheory.CostructuredArrow L X\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp ((L.leftKanExtensionUnit F).app f.left) (CategoryTheory.CategoryStruct.comp ((L.leftKanExtension F).map f.hom) (L.leftKanExtensionObjIsoColimit F X).hom)) (CategoryTheory.Limits.colimit.Î¹ ((CategoryTheory.CostructuredArrow.proj L X).comp F) f)","decl":"lemma leftKanExtensionUnit_leftKanExtension_map_leftKanExtensionObjIsoColimit_hom (X : D)\n    (f : CostructuredArrow L X) :\n    (leftKanExtensionUnit L F).app f.left â‰« (leftKanExtension L F).map f.hom â‰«\n       (L.leftKanExtensionObjIsoColimit F X).hom =\n    colimit.Î¹ (proj L X â‹™ F) f :=\n  LeftExtension.IsPointwiseLeftKanExtensionAt.Î¹_isoColimit_hom (F := F)\n    (isPointwiseLeftKanExtensionLeftKanExtensionUnit L F X) f\n\n"}
{"name":"CategoryTheory.Functor.leftKanExtensionUnit_leftKanExtensionObjIsoColimit_hom","module":"Mathlib.CategoryTheory.Functor.KanExtension.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœÂ³ : CategoryTheory.Category.{u_5, u_1} C\ninstâœÂ² : CategoryTheory.Category.{u_6, u_2} D\nL : CategoryTheory.Functor C D\nH : Type u_3\ninstâœÂ¹ : CategoryTheory.Category.{u_4, u_3} H\nF : CategoryTheory.Functor C H\ninstâœ : L.HasPointwiseLeftKanExtension F\nX : C\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp ((L.leftKanExtensionUnit F).app X) (L.leftKanExtensionObjIsoColimit F (L.obj X)).hom) (CategoryTheory.Limits.colimit.Î¹ ((CategoryTheory.CostructuredArrow.proj L (L.obj X)).comp F) (CategoryTheory.CostructuredArrow.mk (CategoryTheory.CategoryStruct.id (L.obj X))))","decl":"@[reassoc (attr := simp)]\nlemma leftKanExtensionUnit_leftKanExtensionObjIsoColimit_hom (X : C) :\n    (L.leftKanExtensionUnit F).app X â‰« (L.leftKanExtensionObjIsoColimit F (L.obj X)).hom =\n    colimit.Î¹ (proj L (L.obj X) â‹™ F) (CostructuredArrow.mk (ğŸ™ _)) := by\n  simpa using leftKanExtensionUnit_leftKanExtension_map_leftKanExtensionObjIsoColimit_hom L F\n    (L.obj X) (CostructuredArrow.mk (ğŸ™ _))\n\n"}
{"name":"CategoryTheory.Functor.leftKanExtensionUnit_leftKanExtensionObjIsoColimit_hom_assoc","module":"Mathlib.CategoryTheory.Functor.KanExtension.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœÂ³ : CategoryTheory.Category.{u_5, u_1} C\ninstâœÂ² : CategoryTheory.Category.{u_6, u_2} D\nL : CategoryTheory.Functor C D\nH : Type u_3\ninstâœÂ¹ : CategoryTheory.Category.{u_4, u_3} H\nF : CategoryTheory.Functor C H\ninstâœ : L.HasPointwiseLeftKanExtension F\nX : C\nZ : H\nh : Quiver.Hom (CategoryTheory.Limits.colimit ((CategoryTheory.CostructuredArrow.proj L (L.obj X)).comp F)) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp ((L.leftKanExtensionUnit F).app X) (CategoryTheory.CategoryStruct.comp (L.leftKanExtensionObjIsoColimit F (L.obj X)).hom h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.Î¹ ((CategoryTheory.CostructuredArrow.proj L (L.obj X)).comp F) (CategoryTheory.CostructuredArrow.mk (CategoryTheory.CategoryStruct.id (L.obj X)))) h)","decl":"@[reassoc (attr := simp)]\nlemma leftKanExtensionUnit_leftKanExtensionObjIsoColimit_hom (X : C) :\n    (L.leftKanExtensionUnit F).app X â‰« (L.leftKanExtensionObjIsoColimit F (L.obj X)).hom =\n    colimit.Î¹ (proj L (L.obj X) â‹™ F) (CostructuredArrow.mk (ğŸ™ _)) := by\n  simpa using leftKanExtensionUnit_leftKanExtension_map_leftKanExtensionObjIsoColimit_hom L F\n    (L.obj X) (CostructuredArrow.mk (ğŸ™ _))\n\n"}
{"name":"CategoryTheory.Functor.hasColimit_map_comp_Î¹_comp_grotendieckProj","module":"Mathlib.CategoryTheory.Functor.KanExtension.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœÂ³ : CategoryTheory.Category.{u_5, u_1} C\ninstâœÂ² : CategoryTheory.Category.{u_4, u_2} D\nL : CategoryTheory.Functor C D\nH : Type u_3\ninstâœÂ¹ : CategoryTheory.Category.{u_6, u_3} H\nF : CategoryTheory.Functor C H\ninstâœ : L.HasPointwiseLeftKanExtension F\nX Y : D\nf : Quiver.Hom X Y\nâŠ¢ CategoryTheory.Limits.HasColimit (CategoryTheory.Functor.comp ((CategoryTheory.CostructuredArrow.functor L).map f) ((CategoryTheory.Grothendieck.Î¹ (CategoryTheory.CostructuredArrow.functor L) Y).comp ((CategoryTheory.CostructuredArrow.grothendieckProj L).comp F)))","decl":"@[instance]\ntheorem hasColimit_map_comp_Î¹_comp_grotendieckProj {X Y : D} (f : X âŸ¶ Y) :\n    HasColimit ((functor L).map f â‹™ Grothendieck.Î¹ (functor L) Y â‹™ grothendieckProj L â‹™ F) :=\n  hasColimitOfIso (isoWhiskerRight (mapCompÎ¹CompGrothendieckProj L f) F)\n\n"}
{"name":"CategoryTheory.Functor.leftKanExtensionIsoFiberwiseColimit_inv_app","module":"Mathlib.CategoryTheory.Functor.KanExtension.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœâ´ : CategoryTheory.Category.{u_4, u_1} C\ninstâœÂ³ : CategoryTheory.Category.{u_5, u_2} D\nL : CategoryTheory.Functor C D\nH : Type u_3\ninstâœÂ² : CategoryTheory.Category.{u_6, u_3} H\nF : CategoryTheory.Functor C H\ninstâœÂ¹ : L.HasPointwiseLeftKanExtension F\ninstâœ : L.HasLeftKanExtension F\nX : D\nâŠ¢ Eq ((L.leftKanExtensionIsoFiberwiseColimit F).inv.app X) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.HasColimit.isoOfNatIso (CategoryTheory.isoWhiskerRight (CategoryTheory.CostructuredArrow.Î¹CompGrothendieckProj L X) F)).hom (L.leftKanExtensionObjIsoColimit F X).inv)","decl":"/-- The left Kan extension of `F : C â¥¤ H` along a functor `L : C â¥¤ D` is isomorphic to the\nfiberwise colimit of the projection functor on the Grothendieck construction of the costructured\narrow category composed with `F`. -/\n@[simps!]\nnoncomputable def leftKanExtensionIsoFiberwiseColimit [HasLeftKanExtension L F] :\n    leftKanExtension L F â‰… fiberwiseColimit (grothendieckProj L â‹™ F) :=\n  letI : âˆ€ X, HasColimit (Grothendieck.Î¹ (functor L) X â‹™ grothendieckProj L â‹™ F) :=\n      fun X => hasColimitOfIso <| Iso.symm <| isoWhiskerRight (eqToIso ((functor L).map_id X)) _ â‰ªâ‰«\n      Functor.leftUnitor (Grothendieck.Î¹ (functor L) X â‹™ grothendieckProj L â‹™ F)\n  Iso.symm <| NatIso.ofComponents\n    (fun X => HasColimit.isoOfNatIso (isoWhiskerRight (Î¹CompGrothendieckProj L X) F) â‰ªâ‰«\n      (leftKanExtensionObjIsoColimit L F X).symm)\n    fun f => colimit.hom_ext (by simp)\n\n"}
{"name":"CategoryTheory.Functor.leftKanExtensionIsoFiberwiseColimit_hom_app","module":"Mathlib.CategoryTheory.Functor.KanExtension.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœâ´ : CategoryTheory.Category.{u_4, u_1} C\ninstâœÂ³ : CategoryTheory.Category.{u_5, u_2} D\nL : CategoryTheory.Functor C D\nH : Type u_3\ninstâœÂ² : CategoryTheory.Category.{u_6, u_3} H\nF : CategoryTheory.Functor C H\ninstâœÂ¹ : L.HasPointwiseLeftKanExtension F\ninstâœ : L.HasLeftKanExtension F\nX : D\nâŠ¢ Eq ((L.leftKanExtensionIsoFiberwiseColimit F).hom.app X) (CategoryTheory.CategoryStruct.comp (L.leftKanExtensionObjIsoColimit F X).hom (CategoryTheory.Limits.HasColimit.isoOfNatIso (CategoryTheory.isoWhiskerRight (CategoryTheory.CostructuredArrow.Î¹CompGrothendieckProj L X) F)).inv)","decl":"/-- The left Kan extension of `F : C â¥¤ H` along a functor `L : C â¥¤ D` is isomorphic to the\nfiberwise colimit of the projection functor on the Grothendieck construction of the costructured\narrow category composed with `F`. -/\n@[simps!]\nnoncomputable def leftKanExtensionIsoFiberwiseColimit [HasLeftKanExtension L F] :\n    leftKanExtension L F â‰… fiberwiseColimit (grothendieckProj L â‹™ F) :=\n  letI : âˆ€ X, HasColimit (Grothendieck.Î¹ (functor L) X â‹™ grothendieckProj L â‹™ F) :=\n      fun X => hasColimitOfIso <| Iso.symm <| isoWhiskerRight (eqToIso ((functor L).map_id X)) _ â‰ªâ‰«\n      Functor.leftUnitor (Grothendieck.Î¹ (functor L) X â‹™ grothendieckProj L â‹™ F)\n  Iso.symm <| NatIso.ofComponents\n    (fun X => HasColimit.isoOfNatIso (isoWhiskerRight (Î¹CompGrothendieckProj L X) F) â‰ªâ‰«\n      (leftKanExtensionObjIsoColimit L F X).symm)\n    fun f => colimit.hom_ext (by simp)\n\n"}
{"name":"CategoryTheory.Functor.lanAdjunction_unit","module":"Mathlib.CategoryTheory.Functor.KanExtension.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœÂ³ : CategoryTheory.Category.{u_4, u_1} C\ninstâœÂ² : CategoryTheory.Category.{u_6, u_2} D\nL : CategoryTheory.Functor C D\nH : Type u_3\ninstâœÂ¹ : CategoryTheory.Category.{u_5, u_3} H\ninstâœ : âˆ€ (F : CategoryTheory.Functor C H), L.HasLeftKanExtension F\nâŠ¢ Eq (L.lanAdjunction H).unit L.lanUnit","decl":"variable (H) in\n@[simp]\nlemma lanAdjunction_unit : (L.lanAdjunction H).unit = L.lanUnit := by\n  ext F : 2\n  dsimp [lanAdjunction, homEquivOfIsLeftKanExtension]\n  simp\n\n"}
{"name":"CategoryTheory.Functor.lanAdjunction_counit_app","module":"Mathlib.CategoryTheory.Functor.KanExtension.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœÂ³ : CategoryTheory.Category.{u_6, u_1} C\ninstâœÂ² : CategoryTheory.Category.{u_4, u_2} D\nL : CategoryTheory.Functor C D\nH : Type u_3\ninstâœÂ¹ : CategoryTheory.Category.{u_5, u_3} H\ninstâœ : âˆ€ (F : CategoryTheory.Functor C H), L.HasLeftKanExtension F\nG : CategoryTheory.Functor D H\nâŠ¢ Eq ((L.lanAdjunction H).counit.app G) ((L.lan.obj (L.comp G)).descOfIsLeftKanExtension (L.lanUnit.app (L.comp G)) G (CategoryTheory.CategoryStruct.id (L.comp G)))","decl":"lemma lanAdjunction_counit_app (G : D â¥¤ H) :\n    (L.lanAdjunction H).counit.app G =\n      descOfIsLeftKanExtension (L.lan.obj (L â‹™ G)) (L.lanUnit.app (L â‹™ G)) G (ğŸ™ (L â‹™ G)) :=\n  rfl\n\n"}
{"name":"CategoryTheory.Functor.lanUnit_app_whiskerLeft_lanAdjunction_counit_app_assoc","module":"Mathlib.CategoryTheory.Functor.KanExtension.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœÂ³ : CategoryTheory.Category.{u_6, u_1} C\ninstâœÂ² : CategoryTheory.Category.{u_4, u_2} D\nL : CategoryTheory.Functor C D\nH : Type u_3\ninstâœÂ¹ : CategoryTheory.Category.{u_5, u_3} H\ninstâœ : âˆ€ (F : CategoryTheory.Functor C H), L.HasLeftKanExtension F\nG : CategoryTheory.Functor D H\nZ : CategoryTheory.Functor C H\nh : Quiver.Hom (L.comp G) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (L.lanUnit.app (L.comp G)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerLeft L ((L.lanAdjunction H).counit.app G)) h)) h","decl":"@[reassoc (attr := simp)]\nlemma lanUnit_app_whiskerLeft_lanAdjunction_counit_app (G : D â¥¤ H) :\n    L.lanUnit.app (L â‹™ G) â‰« whiskerLeft L ((L.lanAdjunction H).counit.app G) = ğŸ™ (L â‹™ G) := by\n  simp [lanAdjunction_counit_app]\n\n"}
{"name":"CategoryTheory.Functor.lanUnit_app_whiskerLeft_lanAdjunction_counit_app","module":"Mathlib.CategoryTheory.Functor.KanExtension.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœÂ³ : CategoryTheory.Category.{u_6, u_1} C\ninstâœÂ² : CategoryTheory.Category.{u_4, u_2} D\nL : CategoryTheory.Functor C D\nH : Type u_3\ninstâœÂ¹ : CategoryTheory.Category.{u_5, u_3} H\ninstâœ : âˆ€ (F : CategoryTheory.Functor C H), L.HasLeftKanExtension F\nG : CategoryTheory.Functor D H\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (L.lanUnit.app (L.comp G)) (CategoryTheory.whiskerLeft L ((L.lanAdjunction H).counit.app G))) (CategoryTheory.CategoryStruct.id (L.comp G))","decl":"@[reassoc (attr := simp)]\nlemma lanUnit_app_whiskerLeft_lanAdjunction_counit_app (G : D â¥¤ H) :\n    L.lanUnit.app (L â‹™ G) â‰« whiskerLeft L ((L.lanAdjunction H).counit.app G) = ğŸ™ (L â‹™ G) := by\n  simp [lanAdjunction_counit_app]\n\n"}
{"name":"CategoryTheory.Functor.lanUnit_app_app_lanAdjunction_counit_app_app","module":"Mathlib.CategoryTheory.Functor.KanExtension.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœÂ³ : CategoryTheory.Category.{u_6, u_1} C\ninstâœÂ² : CategoryTheory.Category.{u_4, u_2} D\nL : CategoryTheory.Functor C D\nH : Type u_3\ninstâœÂ¹ : CategoryTheory.Category.{u_5, u_3} H\ninstâœ : âˆ€ (F : CategoryTheory.Functor C H), L.HasLeftKanExtension F\nG : CategoryTheory.Functor D H\nX : C\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp ((L.lanUnit.app (L.comp G)).app X) (((L.lanAdjunction H).counit.app G).app (L.obj X))) (CategoryTheory.CategoryStruct.id (((CategoryTheory.Functor.id (CategoryTheory.Functor C H)).obj (L.comp G)).obj X))","decl":"@[reassoc (attr := simp)]\nlemma lanUnit_app_app_lanAdjunction_counit_app_app (G : D â¥¤ H) (X : C) :\n    (L.lanUnit.app (L â‹™ G)).app X â‰« ((L.lanAdjunction H).counit.app G).app (L.obj X) = ğŸ™ _ :=\n  congr_app (L.lanUnit_app_whiskerLeft_lanAdjunction_counit_app G) X\n\n"}
{"name":"CategoryTheory.Functor.lanUnit_app_app_lanAdjunction_counit_app_app_assoc","module":"Mathlib.CategoryTheory.Functor.KanExtension.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœÂ³ : CategoryTheory.Category.{u_6, u_1} C\ninstâœÂ² : CategoryTheory.Category.{u_4, u_2} D\nL : CategoryTheory.Functor C D\nH : Type u_3\ninstâœÂ¹ : CategoryTheory.Category.{u_5, u_3} H\ninstâœ : âˆ€ (F : CategoryTheory.Functor C H), L.HasLeftKanExtension F\nG : CategoryTheory.Functor D H\nX : C\nZ : H\nh : Quiver.Hom (G.obj (L.obj X)) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp ((L.lanUnit.app (L.comp G)).app X) (CategoryTheory.CategoryStruct.comp (((L.lanAdjunction H).counit.app G).app (L.obj X)) h)) h","decl":"@[reassoc (attr := simp)]\nlemma lanUnit_app_app_lanAdjunction_counit_app_app (G : D â¥¤ H) (X : C) :\n    (L.lanUnit.app (L â‹™ G)).app X â‰« ((L.lanAdjunction H).counit.app G).app (L.obj X) = ğŸ™ _ :=\n  congr_app (L.lanUnit_app_whiskerLeft_lanAdjunction_counit_app G) X\n\n"}
{"name":"CategoryTheory.Functor.isIso_lanAdjunction_counit_app_iff","module":"Mathlib.CategoryTheory.Functor.KanExtension.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœÂ³ : CategoryTheory.Category.{u_6, u_1} C\ninstâœÂ² : CategoryTheory.Category.{u_4, u_2} D\nL : CategoryTheory.Functor C D\nH : Type u_3\ninstâœÂ¹ : CategoryTheory.Category.{u_5, u_3} H\ninstâœ : âˆ€ (F : CategoryTheory.Functor C H), L.HasLeftKanExtension F\nG : CategoryTheory.Functor D H\nâŠ¢ Iff (CategoryTheory.IsIso ((L.lanAdjunction H).counit.app G)) (G.IsLeftKanExtension (CategoryTheory.CategoryStruct.id (L.comp G)))","decl":"lemma isIso_lanAdjunction_counit_app_iff (G : D â¥¤ H) :\n    IsIso ((L.lanAdjunction H).counit.app G) â†” G.IsLeftKanExtension (ğŸ™ (L â‹™ G)) :=\n  (isLeftKanExtension_iff_isIso _ (L.lanUnit.app (L â‹™ G)) _ (by simp)).symm\n\n"}
{"name":"CategoryTheory.Functor.lanCompColimIso_inv_app","module":"Mathlib.CategoryTheory.Functor.KanExtension.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœâµ : CategoryTheory.Category.{u_4, u_1} C\ninstâœâ´ : CategoryTheory.Category.{u_5, u_2} D\nL : CategoryTheory.Functor C D\nH : Type u_3\ninstâœÂ³ : CategoryTheory.Category.{u_6, u_3} H\ninstâœÂ² : âˆ€ (F : CategoryTheory.Functor C H), L.HasLeftKanExtension F\ninstâœÂ¹ : CategoryTheory.Limits.HasColimitsOfShape C H\ninstâœ : CategoryTheory.Limits.HasColimitsOfShape D H\nX : CategoryTheory.Functor C H\nâŠ¢ Eq (L.lanCompColimIso.inv.app X) ((L.lan.obj X).colimitIsoOfIsLeftKanExtension (L.lanUnit.app X)).inv","decl":"/-- Composing the left Kan extension of `L : C â¥¤ D` with `colim` on shapes `D` is isomorphic\nto `colim` on shapes `C`. -/\n@[simps!]\nnoncomputable def lanCompColimIso [HasColimitsOfShape C H] [HasColimitsOfShape D H] :\n    L.lan â‹™ colim â‰… colim (C := H) :=\n  Iso.symm <| NatIso.ofComponents\n    (fun G â†¦ (colimitIsoOfIsLeftKanExtension _ (L.lanUnit.app G)).symm)\n    (fun f â†¦ colimit.hom_ext (fun i â†¦ by\n      dsimp\n      rw [Î¹_colimMap_assoc, Î¹_colimitIsoOfIsLeftKanExtension_inv,\n        Î¹_colimitIsoOfIsLeftKanExtension_inv_assoc, Î¹_colimMap, â† assoc, â† assoc]\n      congr 1\n      exact congr_app (L.lanUnit.naturality f) i))\n\n"}
{"name":"CategoryTheory.Functor.lanCompColimIso_hom_app","module":"Mathlib.CategoryTheory.Functor.KanExtension.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœâµ : CategoryTheory.Category.{u_4, u_1} C\ninstâœâ´ : CategoryTheory.Category.{u_5, u_2} D\nL : CategoryTheory.Functor C D\nH : Type u_3\ninstâœÂ³ : CategoryTheory.Category.{u_6, u_3} H\ninstâœÂ² : âˆ€ (F : CategoryTheory.Functor C H), L.HasLeftKanExtension F\ninstâœÂ¹ : CategoryTheory.Limits.HasColimitsOfShape C H\ninstâœ : CategoryTheory.Limits.HasColimitsOfShape D H\nX : CategoryTheory.Functor C H\nâŠ¢ Eq (L.lanCompColimIso.hom.app X) ((L.lan.obj X).colimitIsoOfIsLeftKanExtension (L.lanUnit.app X)).hom","decl":"/-- Composing the left Kan extension of `L : C â¥¤ D` with `colim` on shapes `D` is isomorphic\nto `colim` on shapes `C`. -/\n@[simps!]\nnoncomputable def lanCompColimIso [HasColimitsOfShape C H] [HasColimitsOfShape D H] :\n    L.lan â‹™ colim â‰… colim (C := H) :=\n  Iso.symm <| NatIso.ofComponents\n    (fun G â†¦ (colimitIsoOfIsLeftKanExtension _ (L.lanUnit.app G)).symm)\n    (fun f â†¦ colimit.hom_ext (fun i â†¦ by\n      dsimp\n      rw [Î¹_colimMap_assoc, Î¹_colimitIsoOfIsLeftKanExtension_inv,\n        Î¹_colimitIsoOfIsLeftKanExtension_inv_assoc, Î¹_colimMap, â† assoc, â† assoc]\n      congr 1\n      exact congr_app (L.lanUnit.naturality f) i))\n\n"}
{"name":"CategoryTheory.Functor.instHasColimitGrothendieckFunctorCompGrothendieckProj","module":"Mathlib.CategoryTheory.Functor.KanExtension.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœâ´ : CategoryTheory.Category.{u_4, u_1} C\ninstâœÂ³ : CategoryTheory.Category.{u_5, u_2} D\nL : CategoryTheory.Functor C D\nH : Type u_3\ninstâœÂ² : CategoryTheory.Category.{u_6, u_3} H\nG : CategoryTheory.Functor C H\ninstâœÂ¹ : L.HasPointwiseLeftKanExtension G\ninstâœ : CategoryTheory.Limits.HasColimitsOfShape D H\nâŠ¢ CategoryTheory.Limits.HasColimit ((CategoryTheory.CostructuredArrow.grothendieckProj L).comp G)","decl":"instance : HasColimit (CostructuredArrow.grothendieckProj L â‹™ G) :=\n  hasColimit_of_hasColimit_fiberwiseColimit_of_hasColimit _\n\n"}
{"name":"CategoryTheory.Functor.Î¹_colimitIsoColimitGrothendieck_inv","module":"Mathlib.CategoryTheory.Functor.KanExtension.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœâµ : CategoryTheory.Category.{u_5, u_1} C\ninstâœâ´ : CategoryTheory.Category.{u_4, u_2} D\nL : CategoryTheory.Functor C D\nH : Type u_3\ninstâœÂ³ : CategoryTheory.Category.{u_6, u_3} H\nG : CategoryTheory.Functor C H\ninstâœÂ² : L.HasPointwiseLeftKanExtension G\ninstâœÂ¹ : CategoryTheory.Limits.HasColimitsOfShape D H\ninstâœ : CategoryTheory.Limits.HasColimitsOfShape C H\nX : CategoryTheory.Grothendieck (CategoryTheory.CostructuredArrow.functor L)\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.Î¹ ((CategoryTheory.CostructuredArrow.grothendieckProj L).comp G) X) (L.colimitIsoColimitGrothendieck G).inv) (CategoryTheory.Limits.colimit.Î¹ G ((CategoryTheory.CostructuredArrow.proj L X.base).obj X.fiber))","decl":"@[reassoc (attr := simp)]\nlemma Î¹_colimitIsoColimitGrothendieck_inv (X : Grothendieck (CostructuredArrow.functor L)) :\n    colimit.Î¹ (CostructuredArrow.grothendieckProj L â‹™ G) X â‰«\n      (colimitIsoColimitGrothendieck L G).inv =\n    colimit.Î¹ G ((CostructuredArrow.proj L X.base).obj X.fiber) := by\n  simp [colimitIsoColimitGrothendieck]\n\n"}
{"name":"CategoryTheory.Functor.Î¹_colimitIsoColimitGrothendieck_inv_assoc","module":"Mathlib.CategoryTheory.Functor.KanExtension.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœâµ : CategoryTheory.Category.{u_5, u_1} C\ninstâœâ´ : CategoryTheory.Category.{u_4, u_2} D\nL : CategoryTheory.Functor C D\nH : Type u_3\ninstâœÂ³ : CategoryTheory.Category.{u_6, u_3} H\nG : CategoryTheory.Functor C H\ninstâœÂ² : L.HasPointwiseLeftKanExtension G\ninstâœÂ¹ : CategoryTheory.Limits.HasColimitsOfShape D H\ninstâœ : CategoryTheory.Limits.HasColimitsOfShape C H\nX : CategoryTheory.Grothendieck (CategoryTheory.CostructuredArrow.functor L)\nZ : H\nh : Quiver.Hom (CategoryTheory.Limits.colimit G) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.Î¹ ((CategoryTheory.CostructuredArrow.grothendieckProj L).comp G) X) (CategoryTheory.CategoryStruct.comp (L.colimitIsoColimitGrothendieck G).inv h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.Î¹ G ((CategoryTheory.CostructuredArrow.proj L X.base).obj X.fiber)) h)","decl":"@[reassoc (attr := simp)]\nlemma Î¹_colimitIsoColimitGrothendieck_inv (X : Grothendieck (CostructuredArrow.functor L)) :\n    colimit.Î¹ (CostructuredArrow.grothendieckProj L â‹™ G) X â‰«\n      (colimitIsoColimitGrothendieck L G).inv =\n    colimit.Î¹ G ((CostructuredArrow.proj L X.base).obj X.fiber) := by\n  simp [colimitIsoColimitGrothendieck]\n\n"}
{"name":"CategoryTheory.Functor.Î¹_colimitIsoColimitGrothendieck_hom","module":"Mathlib.CategoryTheory.Functor.KanExtension.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœâµ : CategoryTheory.Category.{u_5, u_1} C\ninstâœâ´ : CategoryTheory.Category.{u_6, u_2} D\nL : CategoryTheory.Functor C D\nH : Type u_3\ninstâœÂ³ : CategoryTheory.Category.{u_4, u_3} H\nG : CategoryTheory.Functor C H\ninstâœÂ² : L.HasPointwiseLeftKanExtension G\ninstâœÂ¹ : CategoryTheory.Limits.HasColimitsOfShape D H\ninstâœ : CategoryTheory.Limits.HasColimitsOfShape C H\nX : C\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.Î¹ G X) (L.colimitIsoColimitGrothendieck G).hom) (CategoryTheory.Limits.colimit.Î¹ ((CategoryTheory.CostructuredArrow.grothendieckProj L).comp G) { base := L.obj X, fiber := CategoryTheory.CostructuredArrow.mk (CategoryTheory.CategoryStruct.id (L.obj X)) })","decl":"@[reassoc (attr := simp)]\nlemma Î¹_colimitIsoColimitGrothendieck_hom (X : C) :\n    colimit.Î¹ G X â‰« (colimitIsoColimitGrothendieck L G).hom =\n    colimit.Î¹ (CostructuredArrow.grothendieckProj L â‹™ G) âŸ¨L.obj X, .mk (ğŸ™ _)âŸ© := by\n  rw [â† Iso.eq_comp_inv]\n  exact (Î¹_colimitIsoColimitGrothendieck_inv L G âŸ¨L.obj X, .mk (ğŸ™ _)âŸ©).symm\n\n"}
{"name":"CategoryTheory.Functor.Î¹_colimitIsoColimitGrothendieck_hom_assoc","module":"Mathlib.CategoryTheory.Functor.KanExtension.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœâµ : CategoryTheory.Category.{u_5, u_1} C\ninstâœâ´ : CategoryTheory.Category.{u_6, u_2} D\nL : CategoryTheory.Functor C D\nH : Type u_3\ninstâœÂ³ : CategoryTheory.Category.{u_4, u_3} H\nG : CategoryTheory.Functor C H\ninstâœÂ² : L.HasPointwiseLeftKanExtension G\ninstâœÂ¹ : CategoryTheory.Limits.HasColimitsOfShape D H\ninstâœ : CategoryTheory.Limits.HasColimitsOfShape C H\nX : C\nZ : H\nh : Quiver.Hom (CategoryTheory.Limits.colimit ((CategoryTheory.CostructuredArrow.grothendieckProj L).comp G)) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.Î¹ G X) (CategoryTheory.CategoryStruct.comp (L.colimitIsoColimitGrothendieck G).hom h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.Î¹ ((CategoryTheory.CostructuredArrow.grothendieckProj L).comp G) { base := L.obj X, fiber := CategoryTheory.CostructuredArrow.mk (CategoryTheory.CategoryStruct.id (L.obj X)) }) h)","decl":"@[reassoc (attr := simp)]\nlemma Î¹_colimitIsoColimitGrothendieck_hom (X : C) :\n    colimit.Î¹ G X â‰« (colimitIsoColimitGrothendieck L G).hom =\n    colimit.Î¹ (CostructuredArrow.grothendieckProj L â‹™ G) âŸ¨L.obj X, .mk (ğŸ™ _)âŸ© := by\n  rw [â† Iso.eq_comp_inv]\n  exact (Î¹_colimitIsoColimitGrothendieck_inv L G âŸ¨L.obj X, .mk (ğŸ™ _)âŸ©).symm\n\n"}
{"name":"CategoryTheory.Functor.instIsIsoAppLanUnit","module":"Mathlib.CategoryTheory.Functor.KanExtension.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœâ¶ : CategoryTheory.Category.{u_4, u_1} C\ninstâœâµ : CategoryTheory.Category.{u_6, u_2} D\nL : CategoryTheory.Functor C D\nH : Type u_3\ninstâœâ´ : CategoryTheory.Category.{u_5, u_3} H\ninstâœÂ³ : L.Full\ninstâœÂ² : L.Faithful\nF : CategoryTheory.Functor C H\nX : C\ninstâœÂ¹ : L.HasPointwiseLeftKanExtension F\ninstâœ : âˆ€ (F : CategoryTheory.Functor C H), L.HasLeftKanExtension F\nâŠ¢ CategoryTheory.IsIso ((L.lanUnit.app F).app X)","decl":"instance (F : C â¥¤ H) (X : C) [HasPointwiseLeftKanExtension L F]\n    [âˆ€ (F : C â¥¤ H), HasLeftKanExtension L F] :\n    IsIso ((L.lanUnit.app F).app X) :=\n  (isPointwiseLeftKanExtensionLeftKanExtensionUnit L F (L.obj X)).isIso_hom_app\n\n"}
{"name":"CategoryTheory.Functor.instIsIsoAppLanUnit_1","module":"Mathlib.CategoryTheory.Functor.KanExtension.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœâ¶ : CategoryTheory.Category.{u_4, u_1} C\ninstâœâµ : CategoryTheory.Category.{u_6, u_2} D\nL : CategoryTheory.Functor C D\nH : Type u_3\ninstâœâ´ : CategoryTheory.Category.{u_5, u_3} H\ninstâœÂ³ : L.Full\ninstâœÂ² : L.Faithful\nF : CategoryTheory.Functor C H\ninstâœÂ¹ : L.HasPointwiseLeftKanExtension F\ninstâœ : âˆ€ (F : CategoryTheory.Functor C H), L.HasLeftKanExtension F\nâŠ¢ CategoryTheory.IsIso (L.lanUnit.app F)","decl":"instance (F : C â¥¤ H) [HasPointwiseLeftKanExtension L F]\n    [âˆ€ (F : C â¥¤ H), HasLeftKanExtension L F] :\n    IsIso (L.lanUnit.app F) :=\n  NatIso.isIso_of_isIso_app _\n\n"}
{"name":"CategoryTheory.Functor.coreflective","module":"Mathlib.CategoryTheory.Functor.KanExtension.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœÂ³ : CategoryTheory.Category.{u_4, u_1} C\ninstâœÂ² : CategoryTheory.Category.{u_6, u_2} D\nL : CategoryTheory.Functor C D\nH : Type u_3\ninstâœÂ¹ : CategoryTheory.Category.{u_5, u_3} H\ninstâœ : âˆ€ (F : CategoryTheory.Functor C H), L.HasPointwiseLeftKanExtension F\nâŠ¢ CategoryTheory.IsIso L.lanUnit","decl":"instance coreflective [âˆ€ (F : C â¥¤ H), HasPointwiseLeftKanExtension L F] :\n    IsIso (L.lanUnit (H := H)) := by\n  apply NatIso.isIso_of_isIso_app _\n\n"}
{"name":"CategoryTheory.Functor.instIsIsoAppUnitLanAdjunctionOfHasPointwiseLeftKanExtension","module":"Mathlib.CategoryTheory.Functor.KanExtension.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœâ´ : CategoryTheory.Category.{u_4, u_1} C\ninstâœÂ³ : CategoryTheory.Category.{u_6, u_2} D\nL : CategoryTheory.Functor C D\nH : Type u_3\ninstâœÂ² : CategoryTheory.Category.{u_5, u_3} H\nF : CategoryTheory.Functor C H\ninstâœÂ¹ : L.HasPointwiseLeftKanExtension F\ninstâœ : âˆ€ (F : CategoryTheory.Functor C H), L.HasLeftKanExtension F\nâŠ¢ CategoryTheory.IsIso ((L.lanAdjunction H).unit.app F)","decl":"instance (F : C â¥¤ H) [HasPointwiseLeftKanExtension L F]\n    [âˆ€ (F : C â¥¤ H), HasLeftKanExtension L F] :\n    IsIso ((L.lanAdjunction H).unit.app F) := by\n  rw [lanAdjunction_unit]\n  infer_instance\n\n"}
{"name":"CategoryTheory.Functor.coreflective'","module":"Mathlib.CategoryTheory.Functor.KanExtension.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœÂ³ : CategoryTheory.Category.{u_4, u_1} C\ninstâœÂ² : CategoryTheory.Category.{u_6, u_2} D\nL : CategoryTheory.Functor C D\nH : Type u_3\ninstâœÂ¹ : CategoryTheory.Category.{u_5, u_3} H\ninstâœ : âˆ€ (F : CategoryTheory.Functor C H), L.HasPointwiseLeftKanExtension F\nâŠ¢ CategoryTheory.IsIso (L.lanAdjunction H).unit","decl":"instance coreflective' [âˆ€ (F : C â¥¤ H), HasPointwiseLeftKanExtension L F] :\n    IsIso (L.lanAdjunction H).unit := by\n  apply NatIso.isIso_of_isIso_app _\n\n"}
{"name":"CategoryTheory.Functor.instIsRightKanExtensionObjRanAppRanCounit","module":"Mathlib.CategoryTheory.Functor.KanExtension.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœÂ³ : CategoryTheory.Category.{u_4, u_1} C\ninstâœÂ² : CategoryTheory.Category.{u_6, u_2} D\nL : CategoryTheory.Functor C D\nH : Type u_3\ninstâœÂ¹ : CategoryTheory.Category.{u_5, u_3} H\ninstâœ : âˆ€ (F : CategoryTheory.Functor C H), L.HasRightKanExtension F\nF : CategoryTheory.Functor C H\nâŠ¢ (L.ran.obj F).IsRightKanExtension (L.ranCounit.app F)","decl":"instance (F : C â¥¤ H) : (L.ran.obj F).IsRightKanExtension (L.ranCounit.app F) := by\n  dsimp [ran, ranCounit]\n  infer_instance\n\n"}
{"name":"CategoryTheory.Functor.ranObjObjIsoLimit_hom_Ï€","module":"Mathlib.CategoryTheory.Functor.KanExtension.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœâ´ : CategoryTheory.Category.{u_4, u_1} C\ninstâœÂ³ : CategoryTheory.Category.{u_6, u_2} D\nL : CategoryTheory.Functor C D\nH : Type u_3\ninstâœÂ² : CategoryTheory.Category.{u_5, u_3} H\ninstâœÂ¹ : âˆ€ (F : CategoryTheory.Functor C H), L.HasRightKanExtension F\nF : CategoryTheory.Functor C H\ninstâœ : L.HasPointwiseRightKanExtension F\nX : D\nf : CategoryTheory.StructuredArrow X L\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (L.ranObjObjIsoLimit F X).hom (CategoryTheory.Limits.limit.Ï€ ((CategoryTheory.StructuredArrow.proj X L).comp F) f)) (CategoryTheory.CategoryStruct.comp ((L.ran.obj F).map f.hom) ((L.ranCounit.app F).app f.right))","decl":"@[reassoc (attr := simp)]\nlemma ranObjObjIsoLimit_hom_Ï€\n    (F : C â¥¤ H) [HasPointwiseRightKanExtension L F] (X : D) (f : StructuredArrow X L) :\n    (L.ranObjObjIsoLimit F X).hom â‰« limit.Ï€ _ f =\n    (L.ran.obj F).map f.hom â‰« (L.ranCounit.app F).app f.right := by\n  simp [ranObjObjIsoLimit, ran, ranCounit]\n\n"}
{"name":"CategoryTheory.Functor.ranObjObjIsoLimit_hom_Ï€_assoc","module":"Mathlib.CategoryTheory.Functor.KanExtension.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœâ´ : CategoryTheory.Category.{u_4, u_1} C\ninstâœÂ³ : CategoryTheory.Category.{u_6, u_2} D\nL : CategoryTheory.Functor C D\nH : Type u_3\ninstâœÂ² : CategoryTheory.Category.{u_5, u_3} H\ninstâœÂ¹ : âˆ€ (F : CategoryTheory.Functor C H), L.HasRightKanExtension F\nF : CategoryTheory.Functor C H\ninstâœ : L.HasPointwiseRightKanExtension F\nX : D\nf : CategoryTheory.StructuredArrow X L\nZ : H\nh : Quiver.Hom (F.obj ((CategoryTheory.StructuredArrow.proj X L).obj f)) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (L.ranObjObjIsoLimit F X).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.Ï€ ((CategoryTheory.StructuredArrow.proj X L).comp F) f) h)) (CategoryTheory.CategoryStruct.comp ((L.ran.obj F).map f.hom) (CategoryTheory.CategoryStruct.comp ((L.ranCounit.app F).app f.right) h))","decl":"@[reassoc (attr := simp)]\nlemma ranObjObjIsoLimit_hom_Ï€\n    (F : C â¥¤ H) [HasPointwiseRightKanExtension L F] (X : D) (f : StructuredArrow X L) :\n    (L.ranObjObjIsoLimit F X).hom â‰« limit.Ï€ _ f =\n    (L.ran.obj F).map f.hom â‰« (L.ranCounit.app F).app f.right := by\n  simp [ranObjObjIsoLimit, ran, ranCounit]\n\n"}
{"name":"CategoryTheory.Functor.ranObjObjIsoLimit_inv_Ï€_assoc","module":"Mathlib.CategoryTheory.Functor.KanExtension.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœâ´ : CategoryTheory.Category.{u_4, u_1} C\ninstâœÂ³ : CategoryTheory.Category.{u_6, u_2} D\nL : CategoryTheory.Functor C D\nH : Type u_3\ninstâœÂ² : CategoryTheory.Category.{u_5, u_3} H\ninstâœÂ¹ : âˆ€ (F : CategoryTheory.Functor C H), L.HasRightKanExtension F\nF : CategoryTheory.Functor C H\ninstâœ : L.HasPointwiseRightKanExtension F\nX : D\nf : CategoryTheory.StructuredArrow X L\nZ : H\nh : Quiver.Hom (F.obj f.right) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (L.ranObjObjIsoLimit F X).inv (CategoryTheory.CategoryStruct.comp ((L.ran.obj F).map f.hom) (CategoryTheory.CategoryStruct.comp ((L.ranCounit.app F).app f.right) h))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.Ï€ ((CategoryTheory.StructuredArrow.proj X L).comp F) f) h)","decl":"@[reassoc (attr := simp)]\nlemma ranObjObjIsoLimit_inv_Ï€\n    (F : C â¥¤ H) [HasPointwiseRightKanExtension L F] (X : D) (f : StructuredArrow X L) :\n    (L.ranObjObjIsoLimit F X).inv â‰« (L.ran.obj F).map f.hom â‰« (L.ranCounit.app F).app f.right =\n    limit.Ï€ _ f :=\n  RightExtension.IsPointwiseRightKanExtensionAt.isoLimit_inv_Ï€ (F := F)\n    (isPointwiseRightKanExtensionRanCounit L F X) f\n\n"}
{"name":"CategoryTheory.Functor.ranObjObjIsoLimit_inv_Ï€","module":"Mathlib.CategoryTheory.Functor.KanExtension.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœâ´ : CategoryTheory.Category.{u_4, u_1} C\ninstâœÂ³ : CategoryTheory.Category.{u_6, u_2} D\nL : CategoryTheory.Functor C D\nH : Type u_3\ninstâœÂ² : CategoryTheory.Category.{u_5, u_3} H\ninstâœÂ¹ : âˆ€ (F : CategoryTheory.Functor C H), L.HasRightKanExtension F\nF : CategoryTheory.Functor C H\ninstâœ : L.HasPointwiseRightKanExtension F\nX : D\nf : CategoryTheory.StructuredArrow X L\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (L.ranObjObjIsoLimit F X).inv (CategoryTheory.CategoryStruct.comp ((L.ran.obj F).map f.hom) ((L.ranCounit.app F).app f.right))) (CategoryTheory.Limits.limit.Ï€ ((CategoryTheory.StructuredArrow.proj X L).comp F) f)","decl":"@[reassoc (attr := simp)]\nlemma ranObjObjIsoLimit_inv_Ï€\n    (F : C â¥¤ H) [HasPointwiseRightKanExtension L F] (X : D) (f : StructuredArrow X L) :\n    (L.ranObjObjIsoLimit F X).inv â‰« (L.ran.obj F).map f.hom â‰« (L.ranCounit.app F).app f.right =\n    limit.Ï€ _ f :=\n  RightExtension.IsPointwiseRightKanExtensionAt.isoLimit_inv_Ï€ (F := F)\n    (isPointwiseRightKanExtensionRanCounit L F X) f\n\n"}
{"name":"CategoryTheory.Functor.ranAdjunction_counit","module":"Mathlib.CategoryTheory.Functor.KanExtension.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœÂ³ : CategoryTheory.Category.{u_4, u_1} C\ninstâœÂ² : CategoryTheory.Category.{u_6, u_2} D\nL : CategoryTheory.Functor C D\nH : Type u_3\ninstâœÂ¹ : CategoryTheory.Category.{u_5, u_3} H\ninstâœ : âˆ€ (F : CategoryTheory.Functor C H), L.HasRightKanExtension F\nâŠ¢ Eq (L.ranAdjunction H).counit L.ranCounit","decl":"variable (H) in\n@[simp]\nlemma ranAdjunction_counit : (L.ranAdjunction H).counit = L.ranCounit := by\n  ext F : 2\n  dsimp [ranAdjunction, homEquivOfIsRightKanExtension]\n  simp\n\n"}
{"name":"CategoryTheory.Functor.ranAdjunction_unit_app","module":"Mathlib.CategoryTheory.Functor.KanExtension.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœÂ³ : CategoryTheory.Category.{u_6, u_1} C\ninstâœÂ² : CategoryTheory.Category.{u_4, u_2} D\nL : CategoryTheory.Functor C D\nH : Type u_3\ninstâœÂ¹ : CategoryTheory.Category.{u_5, u_3} H\ninstâœ : âˆ€ (F : CategoryTheory.Functor C H), L.HasRightKanExtension F\nG : CategoryTheory.Functor D H\nâŠ¢ Eq ((L.ranAdjunction H).unit.app G) ((L.ran.obj (L.comp G)).liftOfIsRightKanExtension (L.ranCounit.app (L.comp G)) G (CategoryTheory.CategoryStruct.id (L.comp G)))","decl":"lemma ranAdjunction_unit_app (G : D â¥¤ H) :\n    (L.ranAdjunction H).unit.app G =\n      liftOfIsRightKanExtension (L.ran.obj (L â‹™ G)) (L.ranCounit.app (L â‹™ G)) G (ğŸ™ (L â‹™ G)) :=\n  rfl\n\n"}
{"name":"CategoryTheory.Functor.ranCounit_app_whiskerLeft_ranAdjunction_unit_app_assoc","module":"Mathlib.CategoryTheory.Functor.KanExtension.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœÂ³ : CategoryTheory.Category.{u_6, u_1} C\ninstâœÂ² : CategoryTheory.Category.{u_4, u_2} D\nL : CategoryTheory.Functor C D\nH : Type u_3\ninstâœÂ¹ : CategoryTheory.Category.{u_5, u_3} H\ninstâœ : âˆ€ (F : CategoryTheory.Functor C H), L.HasRightKanExtension F\nG : CategoryTheory.Functor D H\nZ : CategoryTheory.Functor C H\nh : Quiver.Hom (L.comp G) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerLeft L ((L.ranAdjunction H).unit.app G)) (CategoryTheory.CategoryStruct.comp (L.ranCounit.app (L.comp G)) h)) h","decl":"@[reassoc (attr := simp)]\nlemma ranCounit_app_whiskerLeft_ranAdjunction_unit_app (G : D â¥¤ H) :\n    whiskerLeft L ((L.ranAdjunction H).unit.app G) â‰« L.ranCounit.app (L â‹™ G) = ğŸ™ (L â‹™ G) := by\n  simp [ranAdjunction_unit_app]\n\n"}
{"name":"CategoryTheory.Functor.ranCounit_app_whiskerLeft_ranAdjunction_unit_app","module":"Mathlib.CategoryTheory.Functor.KanExtension.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœÂ³ : CategoryTheory.Category.{u_6, u_1} C\ninstâœÂ² : CategoryTheory.Category.{u_4, u_2} D\nL : CategoryTheory.Functor C D\nH : Type u_3\ninstâœÂ¹ : CategoryTheory.Category.{u_5, u_3} H\ninstâœ : âˆ€ (F : CategoryTheory.Functor C H), L.HasRightKanExtension F\nG : CategoryTheory.Functor D H\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerLeft L ((L.ranAdjunction H).unit.app G)) (L.ranCounit.app (L.comp G))) (CategoryTheory.CategoryStruct.id (L.comp G))","decl":"@[reassoc (attr := simp)]\nlemma ranCounit_app_whiskerLeft_ranAdjunction_unit_app (G : D â¥¤ H) :\n    whiskerLeft L ((L.ranAdjunction H).unit.app G) â‰« L.ranCounit.app (L â‹™ G) = ğŸ™ (L â‹™ G) := by\n  simp [ranAdjunction_unit_app]\n\n"}
{"name":"CategoryTheory.Functor.ranCounit_app_app_ranAdjunction_unit_app_app_assoc","module":"Mathlib.CategoryTheory.Functor.KanExtension.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœÂ³ : CategoryTheory.Category.{u_6, u_1} C\ninstâœÂ² : CategoryTheory.Category.{u_4, u_2} D\nL : CategoryTheory.Functor C D\nH : Type u_3\ninstâœÂ¹ : CategoryTheory.Category.{u_5, u_3} H\ninstâœ : âˆ€ (F : CategoryTheory.Functor C H), L.HasRightKanExtension F\nG : CategoryTheory.Functor D H\nX : C\nZ : H\nh : Quiver.Hom (G.obj (L.obj X)) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (((L.ranAdjunction H).unit.app G).app (L.obj X)) (CategoryTheory.CategoryStruct.comp ((L.ranCounit.app (L.comp G)).app X) h)) h","decl":"@[reassoc (attr := simp)]\nlemma ranCounit_app_app_ranAdjunction_unit_app_app (G : D â¥¤ H) (X : C) :\n    ((L.ranAdjunction H).unit.app G).app (L.obj X) â‰« (L.ranCounit.app (L â‹™ G)).app X = ğŸ™ _ :=\n  congr_app (L.ranCounit_app_whiskerLeft_ranAdjunction_unit_app G) X\n\n"}
{"name":"CategoryTheory.Functor.ranCounit_app_app_ranAdjunction_unit_app_app","module":"Mathlib.CategoryTheory.Functor.KanExtension.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœÂ³ : CategoryTheory.Category.{u_6, u_1} C\ninstâœÂ² : CategoryTheory.Category.{u_4, u_2} D\nL : CategoryTheory.Functor C D\nH : Type u_3\ninstâœÂ¹ : CategoryTheory.Category.{u_5, u_3} H\ninstâœ : âˆ€ (F : CategoryTheory.Functor C H), L.HasRightKanExtension F\nG : CategoryTheory.Functor D H\nX : C\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (((L.ranAdjunction H).unit.app G).app (L.obj X)) ((L.ranCounit.app (L.comp G)).app X)) (CategoryTheory.CategoryStruct.id (((CategoryTheory.Functor.id (CategoryTheory.Functor D H)).obj G).obj (L.obj X)))","decl":"@[reassoc (attr := simp)]\nlemma ranCounit_app_app_ranAdjunction_unit_app_app (G : D â¥¤ H) (X : C) :\n    ((L.ranAdjunction H).unit.app G).app (L.obj X) â‰« (L.ranCounit.app (L â‹™ G)).app X = ğŸ™ _ :=\n  congr_app (L.ranCounit_app_whiskerLeft_ranAdjunction_unit_app G) X\n\n"}
{"name":"CategoryTheory.Functor.isIso_ranAdjunction_unit_app_iff","module":"Mathlib.CategoryTheory.Functor.KanExtension.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœÂ³ : CategoryTheory.Category.{u_6, u_1} C\ninstâœÂ² : CategoryTheory.Category.{u_4, u_2} D\nL : CategoryTheory.Functor C D\nH : Type u_3\ninstâœÂ¹ : CategoryTheory.Category.{u_5, u_3} H\ninstâœ : âˆ€ (F : CategoryTheory.Functor C H), L.HasRightKanExtension F\nG : CategoryTheory.Functor D H\nâŠ¢ Iff (CategoryTheory.IsIso ((L.ranAdjunction H).unit.app G)) (G.IsRightKanExtension (CategoryTheory.CategoryStruct.id (L.comp G)))","decl":"lemma isIso_ranAdjunction_unit_app_iff (G : D â¥¤ H) :\n    IsIso ((L.ranAdjunction H).unit.app G) â†” G.IsRightKanExtension (ğŸ™ (L â‹™ G)) :=\n  (isRightKanExtension_iff_isIso _ (L.ranCounit.app (L â‹™ G)) _ (by simp)).symm\n\n"}
{"name":"CategoryTheory.Functor.ranCompLimIso_hom_app","module":"Mathlib.CategoryTheory.Functor.KanExtension.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœâµ : CategoryTheory.Category.{u_4, u_1} C\ninstâœâ´ : CategoryTheory.Category.{u_5, u_2} D\nH : Type u_3\ninstâœÂ³ : CategoryTheory.Category.{u_6, u_3} H\nL : CategoryTheory.Functor C D\ninstâœÂ² : âˆ€ (G : CategoryTheory.Functor C H), L.HasRightKanExtension G\ninstâœÂ¹ : CategoryTheory.Limits.HasLimitsOfShape C H\ninstâœ : CategoryTheory.Limits.HasLimitsOfShape D H\nX : CategoryTheory.Functor C H\nâŠ¢ Eq (L.ranCompLimIso.hom.app X) ((L.ran.obj X).limitIsoOfIsRightKanExtension (L.ranCounit.app X)).hom","decl":"/-- Composing the right Kan extension of `L : C â¥¤ D` with `lim` on shapes `D` is isomorphic\nto `lim` on shapes `C`. -/\n@[simps!]\nnoncomputable def ranCompLimIso (L : C â¥¤ D) [âˆ€ (G : C â¥¤ H), L.HasRightKanExtension G]\n    [HasLimitsOfShape C H] [HasLimitsOfShape D H] : L.ran â‹™ lim â‰… lim (C := H) :=\n  NatIso.ofComponents\n    (fun G â†¦ limitIsoOfIsRightKanExtension _ (L.ranCounit.app G))\n    (fun f â†¦ limit.hom_ext (fun i â†¦ by\n      dsimp\n      rw [assoc, assoc, limMap_Ï€, limitIsoOfIsRightKanExtension_hom_Ï€_assoc,\n        limitIsoOfIsRightKanExtension_hom_Ï€, limMap_Ï€_assoc]\n      congr 1\n      exact congr_app (L.ranCounit.naturality f) i))\n\n"}
{"name":"CategoryTheory.Functor.ranCompLimIso_inv_app","module":"Mathlib.CategoryTheory.Functor.KanExtension.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœâµ : CategoryTheory.Category.{u_4, u_1} C\ninstâœâ´ : CategoryTheory.Category.{u_5, u_2} D\nH : Type u_3\ninstâœÂ³ : CategoryTheory.Category.{u_6, u_3} H\nL : CategoryTheory.Functor C D\ninstâœÂ² : âˆ€ (G : CategoryTheory.Functor C H), L.HasRightKanExtension G\ninstâœÂ¹ : CategoryTheory.Limits.HasLimitsOfShape C H\ninstâœ : CategoryTheory.Limits.HasLimitsOfShape D H\nX : CategoryTheory.Functor C H\nâŠ¢ Eq (L.ranCompLimIso.inv.app X) ((L.ran.obj X).limitIsoOfIsRightKanExtension (L.ranCounit.app X)).inv","decl":"/-- Composing the right Kan extension of `L : C â¥¤ D` with `lim` on shapes `D` is isomorphic\nto `lim` on shapes `C`. -/\n@[simps!]\nnoncomputable def ranCompLimIso (L : C â¥¤ D) [âˆ€ (G : C â¥¤ H), L.HasRightKanExtension G]\n    [HasLimitsOfShape C H] [HasLimitsOfShape D H] : L.ran â‹™ lim â‰… lim (C := H) :=\n  NatIso.ofComponents\n    (fun G â†¦ limitIsoOfIsRightKanExtension _ (L.ranCounit.app G))\n    (fun f â†¦ limit.hom_ext (fun i â†¦ by\n      dsimp\n      rw [assoc, assoc, limMap_Ï€, limitIsoOfIsRightKanExtension_hom_Ï€_assoc,\n        limitIsoOfIsRightKanExtension_hom_Ï€, limMap_Ï€_assoc]\n      congr 1\n      exact congr_app (L.ranCounit.naturality f) i))\n\n"}
{"name":"CategoryTheory.Functor.instIsIsoAppRanCounit","module":"Mathlib.CategoryTheory.Functor.KanExtension.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœâ¶ : CategoryTheory.Category.{u_4, u_1} C\ninstâœâµ : CategoryTheory.Category.{u_6, u_2} D\nL : CategoryTheory.Functor C D\nH : Type u_3\ninstâœâ´ : CategoryTheory.Category.{u_5, u_3} H\ninstâœÂ³ : L.Full\ninstâœÂ² : L.Faithful\nF : CategoryTheory.Functor C H\nX : C\ninstâœÂ¹ : L.HasPointwiseRightKanExtension F\ninstâœ : âˆ€ (F : CategoryTheory.Functor C H), L.HasRightKanExtension F\nâŠ¢ CategoryTheory.IsIso ((L.ranCounit.app F).app X)","decl":"instance (F : C â¥¤ H) (X : C) [HasPointwiseRightKanExtension L F]\n    [âˆ€ (F : C â¥¤ H), HasRightKanExtension L F] :\n    IsIso ((L.ranCounit.app F).app X) :=\n  (isPointwiseRightKanExtensionRanCounit L F (L.obj X)).isIso_hom_app\n\n"}
{"name":"CategoryTheory.Functor.instIsIsoAppRanCounit_1","module":"Mathlib.CategoryTheory.Functor.KanExtension.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœâ¶ : CategoryTheory.Category.{u_4, u_1} C\ninstâœâµ : CategoryTheory.Category.{u_6, u_2} D\nL : CategoryTheory.Functor C D\nH : Type u_3\ninstâœâ´ : CategoryTheory.Category.{u_5, u_3} H\ninstâœÂ³ : L.Full\ninstâœÂ² : L.Faithful\nF : CategoryTheory.Functor C H\ninstâœÂ¹ : L.HasPointwiseRightKanExtension F\ninstâœ : âˆ€ (F : CategoryTheory.Functor C H), L.HasRightKanExtension F\nâŠ¢ CategoryTheory.IsIso (L.ranCounit.app F)","decl":"instance (F : C â¥¤ H) [HasPointwiseRightKanExtension L F]\n    [âˆ€ (F : C â¥¤ H), HasRightKanExtension L F] :\n    IsIso (L.ranCounit.app F) :=\n  NatIso.isIso_of_isIso_app _\n\n"}
{"name":"CategoryTheory.Functor.reflective","module":"Mathlib.CategoryTheory.Functor.KanExtension.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœÂ³ : CategoryTheory.Category.{u_4, u_1} C\ninstâœÂ² : CategoryTheory.Category.{u_6, u_2} D\nL : CategoryTheory.Functor C D\nH : Type u_3\ninstâœÂ¹ : CategoryTheory.Category.{u_5, u_3} H\ninstâœ : âˆ€ (F : CategoryTheory.Functor C H), L.HasPointwiseRightKanExtension F\nâŠ¢ CategoryTheory.IsIso L.ranCounit","decl":"instance reflective [âˆ€ (F : C â¥¤ H), HasPointwiseRightKanExtension L F] :\n    IsIso (L.ranCounit (H := H)) := by\n  apply NatIso.isIso_of_isIso_app _\n\n"}
{"name":"CategoryTheory.Functor.instIsIsoAppCounitRanAdjunctionOfHasPointwiseRightKanExtension","module":"Mathlib.CategoryTheory.Functor.KanExtension.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœâ´ : CategoryTheory.Category.{u_4, u_1} C\ninstâœÂ³ : CategoryTheory.Category.{u_6, u_2} D\nL : CategoryTheory.Functor C D\nH : Type u_3\ninstâœÂ² : CategoryTheory.Category.{u_5, u_3} H\nF : CategoryTheory.Functor C H\ninstâœÂ¹ : L.HasPointwiseRightKanExtension F\ninstâœ : âˆ€ (F : CategoryTheory.Functor C H), L.HasRightKanExtension F\nâŠ¢ CategoryTheory.IsIso ((L.ranAdjunction H).counit.app F)","decl":"instance (F : C â¥¤ H) [HasPointwiseRightKanExtension L F]\n    [âˆ€ (F : C â¥¤ H), HasRightKanExtension L F] :\n    IsIso ((L.ranAdjunction H).counit.app F) := by\n  rw [ranAdjunction_counit]\n  infer_instance\n\n"}
{"name":"CategoryTheory.Functor.reflective'","module":"Mathlib.CategoryTheory.Functor.KanExtension.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœÂ³ : CategoryTheory.Category.{u_4, u_1} C\ninstâœÂ² : CategoryTheory.Category.{u_6, u_2} D\nL : CategoryTheory.Functor C D\nH : Type u_3\ninstâœÂ¹ : CategoryTheory.Category.{u_5, u_3} H\ninstâœ : âˆ€ (F : CategoryTheory.Functor C H), L.HasPointwiseRightKanExtension F\nâŠ¢ CategoryTheory.IsIso (L.ranAdjunction H).counit","decl":"instance reflective' [âˆ€ (F : C â¥¤ H), HasPointwiseRightKanExtension L F] :\n    IsIso (L.ranAdjunction H).counit := by\n  apply NatIso.isIso_of_isIso_app _\n\n"}
