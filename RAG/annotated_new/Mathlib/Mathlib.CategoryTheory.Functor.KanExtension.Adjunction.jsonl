{"name":"CategoryTheory.Functor.instIsLeftKanExtensionObjLanAppLanUnit","module":"Mathlib.CategoryTheory.Functor.KanExtension.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù¬≥ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù¬≤ : CategoryTheory.Category.{u_6, u_2} D\nL : CategoryTheory.Functor C D\nH : Type u_3\ninst‚úù¬π : CategoryTheory.Category.{u_5, u_3} H\ninst‚úù : ‚àÄ (F : CategoryTheory.Functor C H), L.HasLeftKanExtension F\nF : CategoryTheory.Functor C H\n‚ä¢ (L.lan.obj F).IsLeftKanExtension (L.lanUnit.app F)","decl":"instance (F : C ‚•§ H) : (L.lan.obj F).IsLeftKanExtension (L.lanUnit.app F) := by\n  dsimp [lan, lanUnit]\n  infer_instance\n\n"}
{"name":"CategoryTheory.Functor.Œπ_leftKanExtensionObjIsoColimit_inv","module":"Mathlib.CategoryTheory.Functor.KanExtension.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù¬≥ : CategoryTheory.Category.{u_6, u_2} D\nL : CategoryTheory.Functor C D\nH : Type u_3\ninst‚úù¬≤ : CategoryTheory.Category.{u_5, u_3} H\nF : CategoryTheory.Functor C H\ninst‚úù¬π : L.HasPointwiseLeftKanExtension F\ninst‚úù : L.HasLeftKanExtension F\nX : D\nf : CategoryTheory.CostructuredArrow L X\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.Œπ ((CategoryTheory.CostructuredArrow.proj L X).comp F) f) (L.leftKanExtensionObjIsoColimit F X).inv) (CategoryTheory.CategoryStruct.comp ((L.leftKanExtensionUnit F).app f.left) ((L.leftKanExtension F).map f.hom))","decl":"@[reassoc (attr := simp)]\nlemma Œπ_leftKanExtensionObjIsoColimit_inv [HasLeftKanExtension L F] (X : D)\n    (f : CostructuredArrow L X) :\n    colimit.Œπ _ f ‚â´ (L.leftKanExtensionObjIsoColimit F X).inv =\n    (L.leftKanExtensionUnit F).app f.left ‚â´ (L.leftKanExtension F).map f.hom := by\n  simp [leftKanExtensionObjIsoColimit, lanUnit]\n\n"}
{"name":"CategoryTheory.Functor.Œπ_leftKanExtensionObjIsoColimit_inv_assoc","module":"Mathlib.CategoryTheory.Functor.KanExtension.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù¬≥ : CategoryTheory.Category.{u_6, u_2} D\nL : CategoryTheory.Functor C D\nH : Type u_3\ninst‚úù¬≤ : CategoryTheory.Category.{u_5, u_3} H\nF : CategoryTheory.Functor C H\ninst‚úù¬π : L.HasPointwiseLeftKanExtension F\ninst‚úù : L.HasLeftKanExtension F\nX : D\nf : CategoryTheory.CostructuredArrow L X\nZ : H\nh : Quiver.Hom ((L.leftKanExtension F).obj X) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.Œπ ((CategoryTheory.CostructuredArrow.proj L X).comp F) f) (CategoryTheory.CategoryStruct.comp (L.leftKanExtensionObjIsoColimit F X).inv h)) (CategoryTheory.CategoryStruct.comp ((L.leftKanExtensionUnit F).app f.left) (CategoryTheory.CategoryStruct.comp ((L.leftKanExtension F).map f.hom) h))","decl":"@[reassoc (attr := simp)]\nlemma Œπ_leftKanExtensionObjIsoColimit_inv [HasLeftKanExtension L F] (X : D)\n    (f : CostructuredArrow L X) :\n    colimit.Œπ _ f ‚â´ (L.leftKanExtensionObjIsoColimit F X).inv =\n    (L.leftKanExtensionUnit F).app f.left ‚â´ (L.leftKanExtension F).map f.hom := by\n  simp [leftKanExtensionObjIsoColimit, lanUnit]\n\n"}
{"name":"CategoryTheory.Functor.Œπ_leftKanExtensionObjIsoColimit_hom","module":"Mathlib.CategoryTheory.Functor.KanExtension.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù¬≥ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù¬≤ : CategoryTheory.Category.{u_5, u_2} D\nL : CategoryTheory.Functor C D\nH : Type u_3\ninst‚úù¬π : CategoryTheory.Category.{u_6, u_3} H\nF : CategoryTheory.Functor C H\ninst‚úù : L.HasPointwiseLeftKanExtension F\nX : D\nf : CategoryTheory.CostructuredArrow L X\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((L.leftKanExtensionUnit F).app f.left) (CategoryTheory.CategoryStruct.comp ((L.leftKanExtension F).map f.hom) (L.leftKanExtensionObjIsoColimit F X).hom)) (CategoryTheory.Limits.colimit.Œπ ((CategoryTheory.CostructuredArrow.proj L X).comp F) f)","decl":"@[reassoc (attr := simp)]\nlemma Œπ_leftKanExtensionObjIsoColimit_hom (X : D) (f : CostructuredArrow L X) :\n    (L.leftKanExtensionUnit F).app f.left ‚â´ (L.leftKanExtension F).map f.hom ‚â´\n      (L.leftKanExtensionObjIsoColimit F X).hom =\n    colimit.Œπ (proj L X ‚ãô F) f :=\n  LeftExtension.IsPointwiseLeftKanExtensionAt.Œπ_isoColimit_hom (F := F)\n    (isPointwiseLeftKanExtensionLeftKanExtensionUnit L F X) f\n\n"}
{"name":"CategoryTheory.Functor.Œπ_leftKanExtensionObjIsoColimit_hom_assoc","module":"Mathlib.CategoryTheory.Functor.KanExtension.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù¬≥ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù¬≤ : CategoryTheory.Category.{u_5, u_2} D\nL : CategoryTheory.Functor C D\nH : Type u_3\ninst‚úù¬π : CategoryTheory.Category.{u_6, u_3} H\nF : CategoryTheory.Functor C H\ninst‚úù : L.HasPointwiseLeftKanExtension F\nX : D\nf : CategoryTheory.CostructuredArrow L X\nZ : H\nh : Quiver.Hom (CategoryTheory.Limits.colimit ((CategoryTheory.CostructuredArrow.proj L X).comp F)) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((L.leftKanExtensionUnit F).app f.left) (CategoryTheory.CategoryStruct.comp ((L.leftKanExtension F).map f.hom) (CategoryTheory.CategoryStruct.comp (L.leftKanExtensionObjIsoColimit F X).hom h))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.Œπ ((CategoryTheory.CostructuredArrow.proj L X).comp F) f) h)","decl":"@[reassoc (attr := simp)]\nlemma Œπ_leftKanExtensionObjIsoColimit_hom (X : D) (f : CostructuredArrow L X) :\n    (L.leftKanExtensionUnit F).app f.left ‚â´ (L.leftKanExtension F).map f.hom ‚â´\n      (L.leftKanExtensionObjIsoColimit F X).hom =\n    colimit.Œπ (proj L X ‚ãô F) f :=\n  LeftExtension.IsPointwiseLeftKanExtensionAt.Œπ_isoColimit_hom (F := F)\n    (isPointwiseLeftKanExtensionLeftKanExtensionUnit L F X) f\n\n"}
{"name":"CategoryTheory.Functor.leftKanExtensionUnit_leftKanExtension_map_leftKanExtensionObjIsoColimit_hom","module":"Mathlib.CategoryTheory.Functor.KanExtension.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù¬≥ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù¬≤ : CategoryTheory.Category.{u_5, u_2} D\nL : CategoryTheory.Functor C D\nH : Type u_3\ninst‚úù¬π : CategoryTheory.Category.{u_6, u_3} H\nF : CategoryTheory.Functor C H\ninst‚úù : L.HasPointwiseLeftKanExtension F\nX : D\nf : CategoryTheory.CostructuredArrow L X\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((L.leftKanExtensionUnit F).app f.left) (CategoryTheory.CategoryStruct.comp ((L.leftKanExtension F).map f.hom) (L.leftKanExtensionObjIsoColimit F X).hom)) (CategoryTheory.Limits.colimit.Œπ ((CategoryTheory.CostructuredArrow.proj L X).comp F) f)","decl":"lemma leftKanExtensionUnit_leftKanExtension_map_leftKanExtensionObjIsoColimit_hom (X : D)\n    (f : CostructuredArrow L X) :\n    (leftKanExtensionUnit L F).app f.left ‚â´ (leftKanExtension L F).map f.hom ‚â´\n       (L.leftKanExtensionObjIsoColimit F X).hom =\n    colimit.Œπ (proj L X ‚ãô F) f :=\n  LeftExtension.IsPointwiseLeftKanExtensionAt.Œπ_isoColimit_hom (F := F)\n    (isPointwiseLeftKanExtensionLeftKanExtensionUnit L F X) f\n\n"}
{"name":"CategoryTheory.Functor.leftKanExtensionUnit_leftKanExtensionObjIsoColimit_hom","module":"Mathlib.CategoryTheory.Functor.KanExtension.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù¬≥ : CategoryTheory.Category.{u_5, u_1} C\ninst‚úù¬≤ : CategoryTheory.Category.{u_6, u_2} D\nL : CategoryTheory.Functor C D\nH : Type u_3\ninst‚úù¬π : CategoryTheory.Category.{u_4, u_3} H\nF : CategoryTheory.Functor C H\ninst‚úù : L.HasPointwiseLeftKanExtension F\nX : C\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((L.leftKanExtensionUnit F).app X) (L.leftKanExtensionObjIsoColimit F (L.obj X)).hom) (CategoryTheory.Limits.colimit.Œπ ((CategoryTheory.CostructuredArrow.proj L (L.obj X)).comp F) (CategoryTheory.CostructuredArrow.mk (CategoryTheory.CategoryStruct.id (L.obj X))))","decl":"@[reassoc (attr := simp)]\nlemma leftKanExtensionUnit_leftKanExtensionObjIsoColimit_hom (X : C) :\n    (L.leftKanExtensionUnit F).app X ‚â´ (L.leftKanExtensionObjIsoColimit F (L.obj X)).hom =\n    colimit.Œπ (proj L (L.obj X) ‚ãô F) (CostructuredArrow.mk (ùüô _)) := by\n  simpa using leftKanExtensionUnit_leftKanExtension_map_leftKanExtensionObjIsoColimit_hom L F\n    (L.obj X) (CostructuredArrow.mk (ùüô _))\n\n"}
{"name":"CategoryTheory.Functor.leftKanExtensionUnit_leftKanExtensionObjIsoColimit_hom_assoc","module":"Mathlib.CategoryTheory.Functor.KanExtension.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù¬≥ : CategoryTheory.Category.{u_5, u_1} C\ninst‚úù¬≤ : CategoryTheory.Category.{u_6, u_2} D\nL : CategoryTheory.Functor C D\nH : Type u_3\ninst‚úù¬π : CategoryTheory.Category.{u_4, u_3} H\nF : CategoryTheory.Functor C H\ninst‚úù : L.HasPointwiseLeftKanExtension F\nX : C\nZ : H\nh : Quiver.Hom (CategoryTheory.Limits.colimit ((CategoryTheory.CostructuredArrow.proj L (L.obj X)).comp F)) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((L.leftKanExtensionUnit F).app X) (CategoryTheory.CategoryStruct.comp (L.leftKanExtensionObjIsoColimit F (L.obj X)).hom h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.Œπ ((CategoryTheory.CostructuredArrow.proj L (L.obj X)).comp F) (CategoryTheory.CostructuredArrow.mk (CategoryTheory.CategoryStruct.id (L.obj X)))) h)","decl":"@[reassoc (attr := simp)]\nlemma leftKanExtensionUnit_leftKanExtensionObjIsoColimit_hom (X : C) :\n    (L.leftKanExtensionUnit F).app X ‚â´ (L.leftKanExtensionObjIsoColimit F (L.obj X)).hom =\n    colimit.Œπ (proj L (L.obj X) ‚ãô F) (CostructuredArrow.mk (ùüô _)) := by\n  simpa using leftKanExtensionUnit_leftKanExtension_map_leftKanExtensionObjIsoColimit_hom L F\n    (L.obj X) (CostructuredArrow.mk (ùüô _))\n\n"}
{"name":"CategoryTheory.Functor.hasColimit_map_comp_Œπ_comp_grotendieckProj","module":"Mathlib.CategoryTheory.Functor.KanExtension.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù¬≥ : CategoryTheory.Category.{u_5, u_1} C\ninst‚úù¬≤ : CategoryTheory.Category.{u_4, u_2} D\nL : CategoryTheory.Functor C D\nH : Type u_3\ninst‚úù¬π : CategoryTheory.Category.{u_6, u_3} H\nF : CategoryTheory.Functor C H\ninst‚úù : L.HasPointwiseLeftKanExtension F\nX Y : D\nf : Quiver.Hom X Y\n‚ä¢ CategoryTheory.Limits.HasColimit (CategoryTheory.Functor.comp ((CategoryTheory.CostructuredArrow.functor L).map f) ((CategoryTheory.Grothendieck.Œπ (CategoryTheory.CostructuredArrow.functor L) Y).comp ((CategoryTheory.CostructuredArrow.grothendieckProj L).comp F)))","decl":"@[instance]\ntheorem hasColimit_map_comp_Œπ_comp_grotendieckProj {X Y : D} (f : X ‚ü∂ Y) :\n    HasColimit ((functor L).map f ‚ãô Grothendieck.Œπ (functor L) Y ‚ãô grothendieckProj L ‚ãô F) :=\n  hasColimitOfIso (isoWhiskerRight (mapCompŒπCompGrothendieckProj L f) F)\n\n"}
{"name":"CategoryTheory.Functor.leftKanExtensionIsoFiberwiseColimit_inv_app","module":"Mathlib.CategoryTheory.Functor.KanExtension.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù¬≥ : CategoryTheory.Category.{u_5, u_2} D\nL : CategoryTheory.Functor C D\nH : Type u_3\ninst‚úù¬≤ : CategoryTheory.Category.{u_6, u_3} H\nF : CategoryTheory.Functor C H\ninst‚úù¬π : L.HasPointwiseLeftKanExtension F\ninst‚úù : L.HasLeftKanExtension F\nX : D\n‚ä¢ Eq ((L.leftKanExtensionIsoFiberwiseColimit F).inv.app X) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.HasColimit.isoOfNatIso (CategoryTheory.isoWhiskerRight (CategoryTheory.CostructuredArrow.ŒπCompGrothendieckProj L X) F)).hom (L.leftKanExtensionObjIsoColimit F X).inv)","decl":"/-- The left Kan extension of `F : C ‚•§ H` along a functor `L : C ‚•§ D` is isomorphic to the\nfiberwise colimit of the projection functor on the Grothendieck construction of the costructured\narrow category composed with `F`. -/\n@[simps!]\nnoncomputable def leftKanExtensionIsoFiberwiseColimit [HasLeftKanExtension L F] :\n    leftKanExtension L F ‚âÖ fiberwiseColimit (grothendieckProj L ‚ãô F) :=\n  letI : ‚àÄ X, HasColimit (Grothendieck.Œπ (functor L) X ‚ãô grothendieckProj L ‚ãô F) :=\n      fun X => hasColimitOfIso <| Iso.symm <| isoWhiskerRight (eqToIso ((functor L).map_id X)) _ ‚â™‚â´\n      Functor.leftUnitor (Grothendieck.Œπ (functor L) X ‚ãô grothendieckProj L ‚ãô F)\n  Iso.symm <| NatIso.ofComponents\n    (fun X => HasColimit.isoOfNatIso (isoWhiskerRight (ŒπCompGrothendieckProj L X) F) ‚â™‚â´\n      (leftKanExtensionObjIsoColimit L F X).symm)\n    fun f => colimit.hom_ext (by simp)\n\n"}
{"name":"CategoryTheory.Functor.leftKanExtensionIsoFiberwiseColimit_hom_app","module":"Mathlib.CategoryTheory.Functor.KanExtension.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù¬≥ : CategoryTheory.Category.{u_5, u_2} D\nL : CategoryTheory.Functor C D\nH : Type u_3\ninst‚úù¬≤ : CategoryTheory.Category.{u_6, u_3} H\nF : CategoryTheory.Functor C H\ninst‚úù¬π : L.HasPointwiseLeftKanExtension F\ninst‚úù : L.HasLeftKanExtension F\nX : D\n‚ä¢ Eq ((L.leftKanExtensionIsoFiberwiseColimit F).hom.app X) (CategoryTheory.CategoryStruct.comp (L.leftKanExtensionObjIsoColimit F X).hom (CategoryTheory.Limits.HasColimit.isoOfNatIso (CategoryTheory.isoWhiskerRight (CategoryTheory.CostructuredArrow.ŒπCompGrothendieckProj L X) F)).inv)","decl":"/-- The left Kan extension of `F : C ‚•§ H` along a functor `L : C ‚•§ D` is isomorphic to the\nfiberwise colimit of the projection functor on the Grothendieck construction of the costructured\narrow category composed with `F`. -/\n@[simps!]\nnoncomputable def leftKanExtensionIsoFiberwiseColimit [HasLeftKanExtension L F] :\n    leftKanExtension L F ‚âÖ fiberwiseColimit (grothendieckProj L ‚ãô F) :=\n  letI : ‚àÄ X, HasColimit (Grothendieck.Œπ (functor L) X ‚ãô grothendieckProj L ‚ãô F) :=\n      fun X => hasColimitOfIso <| Iso.symm <| isoWhiskerRight (eqToIso ((functor L).map_id X)) _ ‚â™‚â´\n      Functor.leftUnitor (Grothendieck.Œπ (functor L) X ‚ãô grothendieckProj L ‚ãô F)\n  Iso.symm <| NatIso.ofComponents\n    (fun X => HasColimit.isoOfNatIso (isoWhiskerRight (ŒπCompGrothendieckProj L X) F) ‚â™‚â´\n      (leftKanExtensionObjIsoColimit L F X).symm)\n    fun f => colimit.hom_ext (by simp)\n\n"}
{"name":"CategoryTheory.Functor.lanAdjunction_unit","module":"Mathlib.CategoryTheory.Functor.KanExtension.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù¬≥ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù¬≤ : CategoryTheory.Category.{u_6, u_2} D\nL : CategoryTheory.Functor C D\nH : Type u_3\ninst‚úù¬π : CategoryTheory.Category.{u_5, u_3} H\ninst‚úù : ‚àÄ (F : CategoryTheory.Functor C H), L.HasLeftKanExtension F\n‚ä¢ Eq (L.lanAdjunction H).unit L.lanUnit","decl":"variable (H) in\n@[simp]\nlemma lanAdjunction_unit : (L.lanAdjunction H).unit = L.lanUnit := by\n  ext F : 2\n  dsimp [lanAdjunction, homEquivOfIsLeftKanExtension]\n  simp\n\n"}
{"name":"CategoryTheory.Functor.lanAdjunction_counit_app","module":"Mathlib.CategoryTheory.Functor.KanExtension.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù¬≥ : CategoryTheory.Category.{u_6, u_1} C\ninst‚úù¬≤ : CategoryTheory.Category.{u_4, u_2} D\nL : CategoryTheory.Functor C D\nH : Type u_3\ninst‚úù¬π : CategoryTheory.Category.{u_5, u_3} H\ninst‚úù : ‚àÄ (F : CategoryTheory.Functor C H), L.HasLeftKanExtension F\nG : CategoryTheory.Functor D H\n‚ä¢ Eq ((L.lanAdjunction H).counit.app G) ((L.lan.obj (L.comp G)).descOfIsLeftKanExtension (L.lanUnit.app (L.comp G)) G (CategoryTheory.CategoryStruct.id (L.comp G)))","decl":"lemma lanAdjunction_counit_app (G : D ‚•§ H) :\n    (L.lanAdjunction H).counit.app G =\n      descOfIsLeftKanExtension (L.lan.obj (L ‚ãô G)) (L.lanUnit.app (L ‚ãô G)) G (ùüô (L ‚ãô G)) :=\n  rfl\n\n"}
{"name":"CategoryTheory.Functor.lanUnit_app_whiskerLeft_lanAdjunction_counit_app_assoc","module":"Mathlib.CategoryTheory.Functor.KanExtension.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù¬≥ : CategoryTheory.Category.{u_6, u_1} C\ninst‚úù¬≤ : CategoryTheory.Category.{u_4, u_2} D\nL : CategoryTheory.Functor C D\nH : Type u_3\ninst‚úù¬π : CategoryTheory.Category.{u_5, u_3} H\ninst‚úù : ‚àÄ (F : CategoryTheory.Functor C H), L.HasLeftKanExtension F\nG : CategoryTheory.Functor D H\nZ : CategoryTheory.Functor C H\nh : Quiver.Hom (L.comp G) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (L.lanUnit.app (L.comp G)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerLeft L ((L.lanAdjunction H).counit.app G)) h)) h","decl":"@[reassoc (attr := simp)]\nlemma lanUnit_app_whiskerLeft_lanAdjunction_counit_app (G : D ‚•§ H) :\n    L.lanUnit.app (L ‚ãô G) ‚â´ whiskerLeft L ((L.lanAdjunction H).counit.app G) = ùüô (L ‚ãô G) := by\n  simp [lanAdjunction_counit_app]\n\n"}
{"name":"CategoryTheory.Functor.lanUnit_app_whiskerLeft_lanAdjunction_counit_app","module":"Mathlib.CategoryTheory.Functor.KanExtension.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù¬≥ : CategoryTheory.Category.{u_6, u_1} C\ninst‚úù¬≤ : CategoryTheory.Category.{u_4, u_2} D\nL : CategoryTheory.Functor C D\nH : Type u_3\ninst‚úù¬π : CategoryTheory.Category.{u_5, u_3} H\ninst‚úù : ‚àÄ (F : CategoryTheory.Functor C H), L.HasLeftKanExtension F\nG : CategoryTheory.Functor D H\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (L.lanUnit.app (L.comp G)) (CategoryTheory.whiskerLeft L ((L.lanAdjunction H).counit.app G))) (CategoryTheory.CategoryStruct.id (L.comp G))","decl":"@[reassoc (attr := simp)]\nlemma lanUnit_app_whiskerLeft_lanAdjunction_counit_app (G : D ‚•§ H) :\n    L.lanUnit.app (L ‚ãô G) ‚â´ whiskerLeft L ((L.lanAdjunction H).counit.app G) = ùüô (L ‚ãô G) := by\n  simp [lanAdjunction_counit_app]\n\n"}
{"name":"CategoryTheory.Functor.lanUnit_app_app_lanAdjunction_counit_app_app","module":"Mathlib.CategoryTheory.Functor.KanExtension.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù¬≥ : CategoryTheory.Category.{u_6, u_1} C\ninst‚úù¬≤ : CategoryTheory.Category.{u_4, u_2} D\nL : CategoryTheory.Functor C D\nH : Type u_3\ninst‚úù¬π : CategoryTheory.Category.{u_5, u_3} H\ninst‚úù : ‚àÄ (F : CategoryTheory.Functor C H), L.HasLeftKanExtension F\nG : CategoryTheory.Functor D H\nX : C\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((L.lanUnit.app (L.comp G)).app X) (((L.lanAdjunction H).counit.app G).app (L.obj X))) (CategoryTheory.CategoryStruct.id (((CategoryTheory.Functor.id (CategoryTheory.Functor C H)).obj (L.comp G)).obj X))","decl":"@[reassoc (attr := simp)]\nlemma lanUnit_app_app_lanAdjunction_counit_app_app (G : D ‚•§ H) (X : C) :\n    (L.lanUnit.app (L ‚ãô G)).app X ‚â´ ((L.lanAdjunction H).counit.app G).app (L.obj X) = ùüô _ :=\n  congr_app (L.lanUnit_app_whiskerLeft_lanAdjunction_counit_app G) X\n\n"}
{"name":"CategoryTheory.Functor.lanUnit_app_app_lanAdjunction_counit_app_app_assoc","module":"Mathlib.CategoryTheory.Functor.KanExtension.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù¬≥ : CategoryTheory.Category.{u_6, u_1} C\ninst‚úù¬≤ : CategoryTheory.Category.{u_4, u_2} D\nL : CategoryTheory.Functor C D\nH : Type u_3\ninst‚úù¬π : CategoryTheory.Category.{u_5, u_3} H\ninst‚úù : ‚àÄ (F : CategoryTheory.Functor C H), L.HasLeftKanExtension F\nG : CategoryTheory.Functor D H\nX : C\nZ : H\nh : Quiver.Hom (G.obj (L.obj X)) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((L.lanUnit.app (L.comp G)).app X) (CategoryTheory.CategoryStruct.comp (((L.lanAdjunction H).counit.app G).app (L.obj X)) h)) h","decl":"@[reassoc (attr := simp)]\nlemma lanUnit_app_app_lanAdjunction_counit_app_app (G : D ‚•§ H) (X : C) :\n    (L.lanUnit.app (L ‚ãô G)).app X ‚â´ ((L.lanAdjunction H).counit.app G).app (L.obj X) = ùüô _ :=\n  congr_app (L.lanUnit_app_whiskerLeft_lanAdjunction_counit_app G) X\n\n"}
{"name":"CategoryTheory.Functor.isIso_lanAdjunction_counit_app_iff","module":"Mathlib.CategoryTheory.Functor.KanExtension.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù¬≥ : CategoryTheory.Category.{u_6, u_1} C\ninst‚úù¬≤ : CategoryTheory.Category.{u_4, u_2} D\nL : CategoryTheory.Functor C D\nH : Type u_3\ninst‚úù¬π : CategoryTheory.Category.{u_5, u_3} H\ninst‚úù : ‚àÄ (F : CategoryTheory.Functor C H), L.HasLeftKanExtension F\nG : CategoryTheory.Functor D H\n‚ä¢ Iff (CategoryTheory.IsIso ((L.lanAdjunction H).counit.app G)) (G.IsLeftKanExtension (CategoryTheory.CategoryStruct.id (L.comp G)))","decl":"lemma isIso_lanAdjunction_counit_app_iff (G : D ‚•§ H) :\n    IsIso ((L.lanAdjunction H).counit.app G) ‚Üî G.IsLeftKanExtension (ùüô (L ‚ãô G)) :=\n  (isLeftKanExtension_iff_isIso _ (L.lanUnit.app (L ‚ãô G)) _ (by simp)).symm\n\n"}
{"name":"CategoryTheory.Functor.lanCompColimIso_inv_app","module":"Mathlib.CategoryTheory.Functor.KanExtension.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù‚Åµ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_5, u_2} D\nL : CategoryTheory.Functor C D\nH : Type u_3\ninst‚úù¬≥ : CategoryTheory.Category.{u_6, u_3} H\ninst‚úù¬≤ : ‚àÄ (F : CategoryTheory.Functor C H), L.HasLeftKanExtension F\ninst‚úù¬π : CategoryTheory.Limits.HasColimitsOfShape C H\ninst‚úù : CategoryTheory.Limits.HasColimitsOfShape D H\nX : CategoryTheory.Functor C H\n‚ä¢ Eq (L.lanCompColimIso.inv.app X) ((L.lan.obj X).colimitIsoOfIsLeftKanExtension (L.lanUnit.app X)).inv","decl":"/-- Composing the left Kan extension of `L : C ‚•§ D` with `colim` on shapes `D` is isomorphic\nto `colim` on shapes `C`. -/\n@[simps!]\nnoncomputable def lanCompColimIso [HasColimitsOfShape C H] [HasColimitsOfShape D H] :\n    L.lan ‚ãô colim ‚âÖ colim (C := H) :=\n  Iso.symm <| NatIso.ofComponents\n    (fun G ‚Ü¶ (colimitIsoOfIsLeftKanExtension _ (L.lanUnit.app G)).symm)\n    (fun f ‚Ü¶ colimit.hom_ext (fun i ‚Ü¶ by\n      dsimp\n      rw [Œπ_colimMap_assoc, Œπ_colimitIsoOfIsLeftKanExtension_inv,\n        Œπ_colimitIsoOfIsLeftKanExtension_inv_assoc, Œπ_colimMap, ‚Üê assoc, ‚Üê assoc]\n      congr 1\n      exact congr_app (L.lanUnit.naturality f) i))\n\n"}
{"name":"CategoryTheory.Functor.lanCompColimIso_hom_app","module":"Mathlib.CategoryTheory.Functor.KanExtension.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù‚Åµ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_5, u_2} D\nL : CategoryTheory.Functor C D\nH : Type u_3\ninst‚úù¬≥ : CategoryTheory.Category.{u_6, u_3} H\ninst‚úù¬≤ : ‚àÄ (F : CategoryTheory.Functor C H), L.HasLeftKanExtension F\ninst‚úù¬π : CategoryTheory.Limits.HasColimitsOfShape C H\ninst‚úù : CategoryTheory.Limits.HasColimitsOfShape D H\nX : CategoryTheory.Functor C H\n‚ä¢ Eq (L.lanCompColimIso.hom.app X) ((L.lan.obj X).colimitIsoOfIsLeftKanExtension (L.lanUnit.app X)).hom","decl":"/-- Composing the left Kan extension of `L : C ‚•§ D` with `colim` on shapes `D` is isomorphic\nto `colim` on shapes `C`. -/\n@[simps!]\nnoncomputable def lanCompColimIso [HasColimitsOfShape C H] [HasColimitsOfShape D H] :\n    L.lan ‚ãô colim ‚âÖ colim (C := H) :=\n  Iso.symm <| NatIso.ofComponents\n    (fun G ‚Ü¶ (colimitIsoOfIsLeftKanExtension _ (L.lanUnit.app G)).symm)\n    (fun f ‚Ü¶ colimit.hom_ext (fun i ‚Ü¶ by\n      dsimp\n      rw [Œπ_colimMap_assoc, Œπ_colimitIsoOfIsLeftKanExtension_inv,\n        Œπ_colimitIsoOfIsLeftKanExtension_inv_assoc, Œπ_colimMap, ‚Üê assoc, ‚Üê assoc]\n      congr 1\n      exact congr_app (L.lanUnit.naturality f) i))\n\n"}
{"name":"CategoryTheory.Functor.instHasColimitGrothendieckFunctorCompGrothendieckProj","module":"Mathlib.CategoryTheory.Functor.KanExtension.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù¬≥ : CategoryTheory.Category.{u_5, u_2} D\nL : CategoryTheory.Functor C D\nH : Type u_3\ninst‚úù¬≤ : CategoryTheory.Category.{u_6, u_3} H\nG : CategoryTheory.Functor C H\ninst‚úù¬π : L.HasPointwiseLeftKanExtension G\ninst‚úù : CategoryTheory.Limits.HasColimitsOfShape D H\n‚ä¢ CategoryTheory.Limits.HasColimit ((CategoryTheory.CostructuredArrow.grothendieckProj L).comp G)","decl":"instance : HasColimit (CostructuredArrow.grothendieckProj L ‚ãô G) :=\n  hasColimit_of_hasColimit_fiberwiseColimit_of_hasColimit _\n\n"}
{"name":"CategoryTheory.Functor.Œπ_colimitIsoColimitGrothendieck_inv","module":"Mathlib.CategoryTheory.Functor.KanExtension.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù‚Åµ : CategoryTheory.Category.{u_5, u_1} C\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_4, u_2} D\nL : CategoryTheory.Functor C D\nH : Type u_3\ninst‚úù¬≥ : CategoryTheory.Category.{u_6, u_3} H\nG : CategoryTheory.Functor C H\ninst‚úù¬≤ : L.HasPointwiseLeftKanExtension G\ninst‚úù¬π : CategoryTheory.Limits.HasColimitsOfShape D H\ninst‚úù : CategoryTheory.Limits.HasColimitsOfShape C H\nX : CategoryTheory.Grothendieck (CategoryTheory.CostructuredArrow.functor L)\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.Œπ ((CategoryTheory.CostructuredArrow.grothendieckProj L).comp G) X) (L.colimitIsoColimitGrothendieck G).inv) (CategoryTheory.Limits.colimit.Œπ G ((CategoryTheory.CostructuredArrow.proj L X.base).obj X.fiber))","decl":"@[reassoc (attr := simp)]\nlemma Œπ_colimitIsoColimitGrothendieck_inv (X : Grothendieck (CostructuredArrow.functor L)) :\n    colimit.Œπ (CostructuredArrow.grothendieckProj L ‚ãô G) X ‚â´\n      (colimitIsoColimitGrothendieck L G).inv =\n    colimit.Œπ G ((CostructuredArrow.proj L X.base).obj X.fiber) := by\n  simp [colimitIsoColimitGrothendieck]\n\n"}
{"name":"CategoryTheory.Functor.Œπ_colimitIsoColimitGrothendieck_inv_assoc","module":"Mathlib.CategoryTheory.Functor.KanExtension.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù‚Åµ : CategoryTheory.Category.{u_5, u_1} C\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_4, u_2} D\nL : CategoryTheory.Functor C D\nH : Type u_3\ninst‚úù¬≥ : CategoryTheory.Category.{u_6, u_3} H\nG : CategoryTheory.Functor C H\ninst‚úù¬≤ : L.HasPointwiseLeftKanExtension G\ninst‚úù¬π : CategoryTheory.Limits.HasColimitsOfShape D H\ninst‚úù : CategoryTheory.Limits.HasColimitsOfShape C H\nX : CategoryTheory.Grothendieck (CategoryTheory.CostructuredArrow.functor L)\nZ : H\nh : Quiver.Hom (CategoryTheory.Limits.colimit G) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.Œπ ((CategoryTheory.CostructuredArrow.grothendieckProj L).comp G) X) (CategoryTheory.CategoryStruct.comp (L.colimitIsoColimitGrothendieck G).inv h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.Œπ G ((CategoryTheory.CostructuredArrow.proj L X.base).obj X.fiber)) h)","decl":"@[reassoc (attr := simp)]\nlemma Œπ_colimitIsoColimitGrothendieck_inv (X : Grothendieck (CostructuredArrow.functor L)) :\n    colimit.Œπ (CostructuredArrow.grothendieckProj L ‚ãô G) X ‚â´\n      (colimitIsoColimitGrothendieck L G).inv =\n    colimit.Œπ G ((CostructuredArrow.proj L X.base).obj X.fiber) := by\n  simp [colimitIsoColimitGrothendieck]\n\n"}
{"name":"CategoryTheory.Functor.Œπ_colimitIsoColimitGrothendieck_hom","module":"Mathlib.CategoryTheory.Functor.KanExtension.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù‚Åµ : CategoryTheory.Category.{u_5, u_1} C\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_6, u_2} D\nL : CategoryTheory.Functor C D\nH : Type u_3\ninst‚úù¬≥ : CategoryTheory.Category.{u_4, u_3} H\nG : CategoryTheory.Functor C H\ninst‚úù¬≤ : L.HasPointwiseLeftKanExtension G\ninst‚úù¬π : CategoryTheory.Limits.HasColimitsOfShape D H\ninst‚úù : CategoryTheory.Limits.HasColimitsOfShape C H\nX : C\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.Œπ G X) (L.colimitIsoColimitGrothendieck G).hom) (CategoryTheory.Limits.colimit.Œπ ((CategoryTheory.CostructuredArrow.grothendieckProj L).comp G) { base := L.obj X, fiber := CategoryTheory.CostructuredArrow.mk (CategoryTheory.CategoryStruct.id (L.obj X)) })","decl":"@[reassoc (attr := simp)]\nlemma Œπ_colimitIsoColimitGrothendieck_hom (X : C) :\n    colimit.Œπ G X ‚â´ (colimitIsoColimitGrothendieck L G).hom =\n    colimit.Œπ (CostructuredArrow.grothendieckProj L ‚ãô G) ‚ü®L.obj X, .mk (ùüô _)‚ü© := by\n  rw [‚Üê Iso.eq_comp_inv]\n  exact (Œπ_colimitIsoColimitGrothendieck_inv L G ‚ü®L.obj X, .mk (ùüô _)‚ü©).symm\n\n"}
{"name":"CategoryTheory.Functor.Œπ_colimitIsoColimitGrothendieck_hom_assoc","module":"Mathlib.CategoryTheory.Functor.KanExtension.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù‚Åµ : CategoryTheory.Category.{u_5, u_1} C\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_6, u_2} D\nL : CategoryTheory.Functor C D\nH : Type u_3\ninst‚úù¬≥ : CategoryTheory.Category.{u_4, u_3} H\nG : CategoryTheory.Functor C H\ninst‚úù¬≤ : L.HasPointwiseLeftKanExtension G\ninst‚úù¬π : CategoryTheory.Limits.HasColimitsOfShape D H\ninst‚úù : CategoryTheory.Limits.HasColimitsOfShape C H\nX : C\nZ : H\nh : Quiver.Hom (CategoryTheory.Limits.colimit ((CategoryTheory.CostructuredArrow.grothendieckProj L).comp G)) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.Œπ G X) (CategoryTheory.CategoryStruct.comp (L.colimitIsoColimitGrothendieck G).hom h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.Œπ ((CategoryTheory.CostructuredArrow.grothendieckProj L).comp G) { base := L.obj X, fiber := CategoryTheory.CostructuredArrow.mk (CategoryTheory.CategoryStruct.id (L.obj X)) }) h)","decl":"@[reassoc (attr := simp)]\nlemma Œπ_colimitIsoColimitGrothendieck_hom (X : C) :\n    colimit.Œπ G X ‚â´ (colimitIsoColimitGrothendieck L G).hom =\n    colimit.Œπ (CostructuredArrow.grothendieckProj L ‚ãô G) ‚ü®L.obj X, .mk (ùüô _)‚ü© := by\n  rw [‚Üê Iso.eq_comp_inv]\n  exact (Œπ_colimitIsoColimitGrothendieck_inv L G ‚ü®L.obj X, .mk (ùüô _)‚ü©).symm\n\n"}
{"name":"CategoryTheory.Functor.instIsIsoAppLanUnit","module":"Mathlib.CategoryTheory.Functor.KanExtension.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù‚Å∂ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù‚Åµ : CategoryTheory.Category.{u_6, u_2} D\nL : CategoryTheory.Functor C D\nH : Type u_3\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_5, u_3} H\ninst‚úù¬≥ : L.Full\ninst‚úù¬≤ : L.Faithful\nF : CategoryTheory.Functor C H\nX : C\ninst‚úù¬π : L.HasPointwiseLeftKanExtension F\ninst‚úù : ‚àÄ (F : CategoryTheory.Functor C H), L.HasLeftKanExtension F\n‚ä¢ CategoryTheory.IsIso ((L.lanUnit.app F).app X)","decl":"instance (F : C ‚•§ H) (X : C) [HasPointwiseLeftKanExtension L F]\n    [‚àÄ (F : C ‚•§ H), HasLeftKanExtension L F] :\n    IsIso ((L.lanUnit.app F).app X) :=\n  (isPointwiseLeftKanExtensionLeftKanExtensionUnit L F (L.obj X)).isIso_hom_app\n\n"}
{"name":"CategoryTheory.Functor.instIsIsoAppLanUnit_1","module":"Mathlib.CategoryTheory.Functor.KanExtension.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù‚Å∂ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù‚Åµ : CategoryTheory.Category.{u_6, u_2} D\nL : CategoryTheory.Functor C D\nH : Type u_3\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_5, u_3} H\ninst‚úù¬≥ : L.Full\ninst‚úù¬≤ : L.Faithful\nF : CategoryTheory.Functor C H\ninst‚úù¬π : L.HasPointwiseLeftKanExtension F\ninst‚úù : ‚àÄ (F : CategoryTheory.Functor C H), L.HasLeftKanExtension F\n‚ä¢ CategoryTheory.IsIso (L.lanUnit.app F)","decl":"instance (F : C ‚•§ H) [HasPointwiseLeftKanExtension L F]\n    [‚àÄ (F : C ‚•§ H), HasLeftKanExtension L F] :\n    IsIso (L.lanUnit.app F) :=\n  NatIso.isIso_of_isIso_app _\n\n"}
{"name":"CategoryTheory.Functor.coreflective","module":"Mathlib.CategoryTheory.Functor.KanExtension.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù¬≥ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù¬≤ : CategoryTheory.Category.{u_6, u_2} D\nL : CategoryTheory.Functor C D\nH : Type u_3\ninst‚úù¬π : CategoryTheory.Category.{u_5, u_3} H\ninst‚úù : ‚àÄ (F : CategoryTheory.Functor C H), L.HasPointwiseLeftKanExtension F\n‚ä¢ CategoryTheory.IsIso L.lanUnit","decl":"instance coreflective [‚àÄ (F : C ‚•§ H), HasPointwiseLeftKanExtension L F] :\n    IsIso (L.lanUnit (H := H)) := by\n  apply NatIso.isIso_of_isIso_app _\n\n"}
{"name":"CategoryTheory.Functor.instIsIsoAppUnitLanAdjunctionOfHasPointwiseLeftKanExtension","module":"Mathlib.CategoryTheory.Functor.KanExtension.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù¬≥ : CategoryTheory.Category.{u_6, u_2} D\nL : CategoryTheory.Functor C D\nH : Type u_3\ninst‚úù¬≤ : CategoryTheory.Category.{u_5, u_3} H\nF : CategoryTheory.Functor C H\ninst‚úù¬π : L.HasPointwiseLeftKanExtension F\ninst‚úù : ‚àÄ (F : CategoryTheory.Functor C H), L.HasLeftKanExtension F\n‚ä¢ CategoryTheory.IsIso ((L.lanAdjunction H).unit.app F)","decl":"instance (F : C ‚•§ H) [HasPointwiseLeftKanExtension L F]\n    [‚àÄ (F : C ‚•§ H), HasLeftKanExtension L F] :\n    IsIso ((L.lanAdjunction H).unit.app F) := by\n  rw [lanAdjunction_unit]\n  infer_instance\n\n"}
{"name":"CategoryTheory.Functor.coreflective'","module":"Mathlib.CategoryTheory.Functor.KanExtension.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù¬≥ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù¬≤ : CategoryTheory.Category.{u_6, u_2} D\nL : CategoryTheory.Functor C D\nH : Type u_3\ninst‚úù¬π : CategoryTheory.Category.{u_5, u_3} H\ninst‚úù : ‚àÄ (F : CategoryTheory.Functor C H), L.HasPointwiseLeftKanExtension F\n‚ä¢ CategoryTheory.IsIso (L.lanAdjunction H).unit","decl":"instance coreflective' [‚àÄ (F : C ‚•§ H), HasPointwiseLeftKanExtension L F] :\n    IsIso (L.lanAdjunction H).unit := by\n  apply NatIso.isIso_of_isIso_app _\n\n"}
{"name":"CategoryTheory.Functor.instIsRightKanExtensionObjRanAppRanCounit","module":"Mathlib.CategoryTheory.Functor.KanExtension.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù¬≥ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù¬≤ : CategoryTheory.Category.{u_6, u_2} D\nL : CategoryTheory.Functor C D\nH : Type u_3\ninst‚úù¬π : CategoryTheory.Category.{u_5, u_3} H\ninst‚úù : ‚àÄ (F : CategoryTheory.Functor C H), L.HasRightKanExtension F\nF : CategoryTheory.Functor C H\n‚ä¢ (L.ran.obj F).IsRightKanExtension (L.ranCounit.app F)","decl":"instance (F : C ‚•§ H) : (L.ran.obj F).IsRightKanExtension (L.ranCounit.app F) := by\n  dsimp [ran, ranCounit]\n  infer_instance\n\n"}
{"name":"CategoryTheory.Functor.ranObjObjIsoLimit_hom_œÄ","module":"Mathlib.CategoryTheory.Functor.KanExtension.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù¬≥ : CategoryTheory.Category.{u_6, u_2} D\nL : CategoryTheory.Functor C D\nH : Type u_3\ninst‚úù¬≤ : CategoryTheory.Category.{u_5, u_3} H\ninst‚úù¬π : ‚àÄ (F : CategoryTheory.Functor C H), L.HasRightKanExtension F\nF : CategoryTheory.Functor C H\ninst‚úù : L.HasPointwiseRightKanExtension F\nX : D\nf : CategoryTheory.StructuredArrow X L\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (L.ranObjObjIsoLimit F X).hom (CategoryTheory.Limits.limit.œÄ ((CategoryTheory.StructuredArrow.proj X L).comp F) f)) (CategoryTheory.CategoryStruct.comp ((L.ran.obj F).map f.hom) ((L.ranCounit.app F).app f.right))","decl":"@[reassoc (attr := simp)]\nlemma ranObjObjIsoLimit_hom_œÄ\n    (F : C ‚•§ H) [HasPointwiseRightKanExtension L F] (X : D) (f : StructuredArrow X L) :\n    (L.ranObjObjIsoLimit F X).hom ‚â´ limit.œÄ _ f =\n    (L.ran.obj F).map f.hom ‚â´ (L.ranCounit.app F).app f.right := by\n  simp [ranObjObjIsoLimit, ran, ranCounit]\n\n"}
{"name":"CategoryTheory.Functor.ranObjObjIsoLimit_hom_œÄ_assoc","module":"Mathlib.CategoryTheory.Functor.KanExtension.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù¬≥ : CategoryTheory.Category.{u_6, u_2} D\nL : CategoryTheory.Functor C D\nH : Type u_3\ninst‚úù¬≤ : CategoryTheory.Category.{u_5, u_3} H\ninst‚úù¬π : ‚àÄ (F : CategoryTheory.Functor C H), L.HasRightKanExtension F\nF : CategoryTheory.Functor C H\ninst‚úù : L.HasPointwiseRightKanExtension F\nX : D\nf : CategoryTheory.StructuredArrow X L\nZ : H\nh : Quiver.Hom (F.obj ((CategoryTheory.StructuredArrow.proj X L).obj f)) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (L.ranObjObjIsoLimit F X).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.œÄ ((CategoryTheory.StructuredArrow.proj X L).comp F) f) h)) (CategoryTheory.CategoryStruct.comp ((L.ran.obj F).map f.hom) (CategoryTheory.CategoryStruct.comp ((L.ranCounit.app F).app f.right) h))","decl":"@[reassoc (attr := simp)]\nlemma ranObjObjIsoLimit_hom_œÄ\n    (F : C ‚•§ H) [HasPointwiseRightKanExtension L F] (X : D) (f : StructuredArrow X L) :\n    (L.ranObjObjIsoLimit F X).hom ‚â´ limit.œÄ _ f =\n    (L.ran.obj F).map f.hom ‚â´ (L.ranCounit.app F).app f.right := by\n  simp [ranObjObjIsoLimit, ran, ranCounit]\n\n"}
{"name":"CategoryTheory.Functor.ranObjObjIsoLimit_inv_œÄ_assoc","module":"Mathlib.CategoryTheory.Functor.KanExtension.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù¬≥ : CategoryTheory.Category.{u_6, u_2} D\nL : CategoryTheory.Functor C D\nH : Type u_3\ninst‚úù¬≤ : CategoryTheory.Category.{u_5, u_3} H\ninst‚úù¬π : ‚àÄ (F : CategoryTheory.Functor C H), L.HasRightKanExtension F\nF : CategoryTheory.Functor C H\ninst‚úù : L.HasPointwiseRightKanExtension F\nX : D\nf : CategoryTheory.StructuredArrow X L\nZ : H\nh : Quiver.Hom (F.obj f.right) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (L.ranObjObjIsoLimit F X).inv (CategoryTheory.CategoryStruct.comp ((L.ran.obj F).map f.hom) (CategoryTheory.CategoryStruct.comp ((L.ranCounit.app F).app f.right) h))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.œÄ ((CategoryTheory.StructuredArrow.proj X L).comp F) f) h)","decl":"@[reassoc (attr := simp)]\nlemma ranObjObjIsoLimit_inv_œÄ\n    (F : C ‚•§ H) [HasPointwiseRightKanExtension L F] (X : D) (f : StructuredArrow X L) :\n    (L.ranObjObjIsoLimit F X).inv ‚â´ (L.ran.obj F).map f.hom ‚â´ (L.ranCounit.app F).app f.right =\n    limit.œÄ _ f :=\n  RightExtension.IsPointwiseRightKanExtensionAt.isoLimit_inv_œÄ (F := F)\n    (isPointwiseRightKanExtensionRanCounit L F X) f\n\n"}
{"name":"CategoryTheory.Functor.ranObjObjIsoLimit_inv_œÄ","module":"Mathlib.CategoryTheory.Functor.KanExtension.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù¬≥ : CategoryTheory.Category.{u_6, u_2} D\nL : CategoryTheory.Functor C D\nH : Type u_3\ninst‚úù¬≤ : CategoryTheory.Category.{u_5, u_3} H\ninst‚úù¬π : ‚àÄ (F : CategoryTheory.Functor C H), L.HasRightKanExtension F\nF : CategoryTheory.Functor C H\ninst‚úù : L.HasPointwiseRightKanExtension F\nX : D\nf : CategoryTheory.StructuredArrow X L\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (L.ranObjObjIsoLimit F X).inv (CategoryTheory.CategoryStruct.comp ((L.ran.obj F).map f.hom) ((L.ranCounit.app F).app f.right))) (CategoryTheory.Limits.limit.œÄ ((CategoryTheory.StructuredArrow.proj X L).comp F) f)","decl":"@[reassoc (attr := simp)]\nlemma ranObjObjIsoLimit_inv_œÄ\n    (F : C ‚•§ H) [HasPointwiseRightKanExtension L F] (X : D) (f : StructuredArrow X L) :\n    (L.ranObjObjIsoLimit F X).inv ‚â´ (L.ran.obj F).map f.hom ‚â´ (L.ranCounit.app F).app f.right =\n    limit.œÄ _ f :=\n  RightExtension.IsPointwiseRightKanExtensionAt.isoLimit_inv_œÄ (F := F)\n    (isPointwiseRightKanExtensionRanCounit L F X) f\n\n"}
{"name":"CategoryTheory.Functor.ranAdjunction_counit","module":"Mathlib.CategoryTheory.Functor.KanExtension.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù¬≥ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù¬≤ : CategoryTheory.Category.{u_6, u_2} D\nL : CategoryTheory.Functor C D\nH : Type u_3\ninst‚úù¬π : CategoryTheory.Category.{u_5, u_3} H\ninst‚úù : ‚àÄ (F : CategoryTheory.Functor C H), L.HasRightKanExtension F\n‚ä¢ Eq (L.ranAdjunction H).counit L.ranCounit","decl":"variable (H) in\n@[simp]\nlemma ranAdjunction_counit : (L.ranAdjunction H).counit = L.ranCounit := by\n  ext F : 2\n  dsimp [ranAdjunction, homEquivOfIsRightKanExtension]\n  simp\n\n"}
{"name":"CategoryTheory.Functor.ranAdjunction_unit_app","module":"Mathlib.CategoryTheory.Functor.KanExtension.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù¬≥ : CategoryTheory.Category.{u_6, u_1} C\ninst‚úù¬≤ : CategoryTheory.Category.{u_4, u_2} D\nL : CategoryTheory.Functor C D\nH : Type u_3\ninst‚úù¬π : CategoryTheory.Category.{u_5, u_3} H\ninst‚úù : ‚àÄ (F : CategoryTheory.Functor C H), L.HasRightKanExtension F\nG : CategoryTheory.Functor D H\n‚ä¢ Eq ((L.ranAdjunction H).unit.app G) ((L.ran.obj (L.comp G)).liftOfIsRightKanExtension (L.ranCounit.app (L.comp G)) G (CategoryTheory.CategoryStruct.id (L.comp G)))","decl":"lemma ranAdjunction_unit_app (G : D ‚•§ H) :\n    (L.ranAdjunction H).unit.app G =\n      liftOfIsRightKanExtension (L.ran.obj (L ‚ãô G)) (L.ranCounit.app (L ‚ãô G)) G (ùüô (L ‚ãô G)) :=\n  rfl\n\n"}
{"name":"CategoryTheory.Functor.ranCounit_app_whiskerLeft_ranAdjunction_unit_app_assoc","module":"Mathlib.CategoryTheory.Functor.KanExtension.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù¬≥ : CategoryTheory.Category.{u_6, u_1} C\ninst‚úù¬≤ : CategoryTheory.Category.{u_4, u_2} D\nL : CategoryTheory.Functor C D\nH : Type u_3\ninst‚úù¬π : CategoryTheory.Category.{u_5, u_3} H\ninst‚úù : ‚àÄ (F : CategoryTheory.Functor C H), L.HasRightKanExtension F\nG : CategoryTheory.Functor D H\nZ : CategoryTheory.Functor C H\nh : Quiver.Hom (L.comp G) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerLeft L ((L.ranAdjunction H).unit.app G)) (CategoryTheory.CategoryStruct.comp (L.ranCounit.app (L.comp G)) h)) h","decl":"@[reassoc (attr := simp)]\nlemma ranCounit_app_whiskerLeft_ranAdjunction_unit_app (G : D ‚•§ H) :\n    whiskerLeft L ((L.ranAdjunction H).unit.app G) ‚â´ L.ranCounit.app (L ‚ãô G) = ùüô (L ‚ãô G) := by\n  simp [ranAdjunction_unit_app]\n\n"}
{"name":"CategoryTheory.Functor.ranCounit_app_whiskerLeft_ranAdjunction_unit_app","module":"Mathlib.CategoryTheory.Functor.KanExtension.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù¬≥ : CategoryTheory.Category.{u_6, u_1} C\ninst‚úù¬≤ : CategoryTheory.Category.{u_4, u_2} D\nL : CategoryTheory.Functor C D\nH : Type u_3\ninst‚úù¬π : CategoryTheory.Category.{u_5, u_3} H\ninst‚úù : ‚àÄ (F : CategoryTheory.Functor C H), L.HasRightKanExtension F\nG : CategoryTheory.Functor D H\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerLeft L ((L.ranAdjunction H).unit.app G)) (L.ranCounit.app (L.comp G))) (CategoryTheory.CategoryStruct.id (L.comp G))","decl":"@[reassoc (attr := simp)]\nlemma ranCounit_app_whiskerLeft_ranAdjunction_unit_app (G : D ‚•§ H) :\n    whiskerLeft L ((L.ranAdjunction H).unit.app G) ‚â´ L.ranCounit.app (L ‚ãô G) = ùüô (L ‚ãô G) := by\n  simp [ranAdjunction_unit_app]\n\n"}
{"name":"CategoryTheory.Functor.ranCounit_app_app_ranAdjunction_unit_app_app_assoc","module":"Mathlib.CategoryTheory.Functor.KanExtension.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù¬≥ : CategoryTheory.Category.{u_6, u_1} C\ninst‚úù¬≤ : CategoryTheory.Category.{u_4, u_2} D\nL : CategoryTheory.Functor C D\nH : Type u_3\ninst‚úù¬π : CategoryTheory.Category.{u_5, u_3} H\ninst‚úù : ‚àÄ (F : CategoryTheory.Functor C H), L.HasRightKanExtension F\nG : CategoryTheory.Functor D H\nX : C\nZ : H\nh : Quiver.Hom (G.obj (L.obj X)) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (((L.ranAdjunction H).unit.app G).app (L.obj X)) (CategoryTheory.CategoryStruct.comp ((L.ranCounit.app (L.comp G)).app X) h)) h","decl":"@[reassoc (attr := simp)]\nlemma ranCounit_app_app_ranAdjunction_unit_app_app (G : D ‚•§ H) (X : C) :\n    ((L.ranAdjunction H).unit.app G).app (L.obj X) ‚â´ (L.ranCounit.app (L ‚ãô G)).app X = ùüô _ :=\n  congr_app (L.ranCounit_app_whiskerLeft_ranAdjunction_unit_app G) X\n\n"}
{"name":"CategoryTheory.Functor.ranCounit_app_app_ranAdjunction_unit_app_app","module":"Mathlib.CategoryTheory.Functor.KanExtension.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù¬≥ : CategoryTheory.Category.{u_6, u_1} C\ninst‚úù¬≤ : CategoryTheory.Category.{u_4, u_2} D\nL : CategoryTheory.Functor C D\nH : Type u_3\ninst‚úù¬π : CategoryTheory.Category.{u_5, u_3} H\ninst‚úù : ‚àÄ (F : CategoryTheory.Functor C H), L.HasRightKanExtension F\nG : CategoryTheory.Functor D H\nX : C\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (((L.ranAdjunction H).unit.app G).app (L.obj X)) ((L.ranCounit.app (L.comp G)).app X)) (CategoryTheory.CategoryStruct.id (((CategoryTheory.Functor.id (CategoryTheory.Functor D H)).obj G).obj (L.obj X)))","decl":"@[reassoc (attr := simp)]\nlemma ranCounit_app_app_ranAdjunction_unit_app_app (G : D ‚•§ H) (X : C) :\n    ((L.ranAdjunction H).unit.app G).app (L.obj X) ‚â´ (L.ranCounit.app (L ‚ãô G)).app X = ùüô _ :=\n  congr_app (L.ranCounit_app_whiskerLeft_ranAdjunction_unit_app G) X\n\n"}
{"name":"CategoryTheory.Functor.isIso_ranAdjunction_unit_app_iff","module":"Mathlib.CategoryTheory.Functor.KanExtension.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù¬≥ : CategoryTheory.Category.{u_6, u_1} C\ninst‚úù¬≤ : CategoryTheory.Category.{u_4, u_2} D\nL : CategoryTheory.Functor C D\nH : Type u_3\ninst‚úù¬π : CategoryTheory.Category.{u_5, u_3} H\ninst‚úù : ‚àÄ (F : CategoryTheory.Functor C H), L.HasRightKanExtension F\nG : CategoryTheory.Functor D H\n‚ä¢ Iff (CategoryTheory.IsIso ((L.ranAdjunction H).unit.app G)) (G.IsRightKanExtension (CategoryTheory.CategoryStruct.id (L.comp G)))","decl":"lemma isIso_ranAdjunction_unit_app_iff (G : D ‚•§ H) :\n    IsIso ((L.ranAdjunction H).unit.app G) ‚Üî G.IsRightKanExtension (ùüô (L ‚ãô G)) :=\n  (isRightKanExtension_iff_isIso _ (L.ranCounit.app (L ‚ãô G)) _ (by simp)).symm\n\n"}
{"name":"CategoryTheory.Functor.ranCompLimIso_hom_app","module":"Mathlib.CategoryTheory.Functor.KanExtension.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù‚Åµ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_5, u_2} D\nH : Type u_3\ninst‚úù¬≥ : CategoryTheory.Category.{u_6, u_3} H\nL : CategoryTheory.Functor C D\ninst‚úù¬≤ : ‚àÄ (G : CategoryTheory.Functor C H), L.HasRightKanExtension G\ninst‚úù¬π : CategoryTheory.Limits.HasLimitsOfShape C H\ninst‚úù : CategoryTheory.Limits.HasLimitsOfShape D H\nX : CategoryTheory.Functor C H\n‚ä¢ Eq (L.ranCompLimIso.hom.app X) ((L.ran.obj X).limitIsoOfIsRightKanExtension (L.ranCounit.app X)).hom","decl":"/-- Composing the right Kan extension of `L : C ‚•§ D` with `lim` on shapes `D` is isomorphic\nto `lim` on shapes `C`. -/\n@[simps!]\nnoncomputable def ranCompLimIso (L : C ‚•§ D) [‚àÄ (G : C ‚•§ H), L.HasRightKanExtension G]\n    [HasLimitsOfShape C H] [HasLimitsOfShape D H] : L.ran ‚ãô lim ‚âÖ lim (C := H) :=\n  NatIso.ofComponents\n    (fun G ‚Ü¶ limitIsoOfIsRightKanExtension _ (L.ranCounit.app G))\n    (fun f ‚Ü¶ limit.hom_ext (fun i ‚Ü¶ by\n      dsimp\n      rw [assoc, assoc, limMap_œÄ, limitIsoOfIsRightKanExtension_hom_œÄ_assoc,\n        limitIsoOfIsRightKanExtension_hom_œÄ, limMap_œÄ_assoc]\n      congr 1\n      exact congr_app (L.ranCounit.naturality f) i))\n\n"}
{"name":"CategoryTheory.Functor.ranCompLimIso_inv_app","module":"Mathlib.CategoryTheory.Functor.KanExtension.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù‚Åµ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_5, u_2} D\nH : Type u_3\ninst‚úù¬≥ : CategoryTheory.Category.{u_6, u_3} H\nL : CategoryTheory.Functor C D\ninst‚úù¬≤ : ‚àÄ (G : CategoryTheory.Functor C H), L.HasRightKanExtension G\ninst‚úù¬π : CategoryTheory.Limits.HasLimitsOfShape C H\ninst‚úù : CategoryTheory.Limits.HasLimitsOfShape D H\nX : CategoryTheory.Functor C H\n‚ä¢ Eq (L.ranCompLimIso.inv.app X) ((L.ran.obj X).limitIsoOfIsRightKanExtension (L.ranCounit.app X)).inv","decl":"/-- Composing the right Kan extension of `L : C ‚•§ D` with `lim` on shapes `D` is isomorphic\nto `lim` on shapes `C`. -/\n@[simps!]\nnoncomputable def ranCompLimIso (L : C ‚•§ D) [‚àÄ (G : C ‚•§ H), L.HasRightKanExtension G]\n    [HasLimitsOfShape C H] [HasLimitsOfShape D H] : L.ran ‚ãô lim ‚âÖ lim (C := H) :=\n  NatIso.ofComponents\n    (fun G ‚Ü¶ limitIsoOfIsRightKanExtension _ (L.ranCounit.app G))\n    (fun f ‚Ü¶ limit.hom_ext (fun i ‚Ü¶ by\n      dsimp\n      rw [assoc, assoc, limMap_œÄ, limitIsoOfIsRightKanExtension_hom_œÄ_assoc,\n        limitIsoOfIsRightKanExtension_hom_œÄ, limMap_œÄ_assoc]\n      congr 1\n      exact congr_app (L.ranCounit.naturality f) i))\n\n"}
{"name":"CategoryTheory.Functor.instIsIsoAppRanCounit","module":"Mathlib.CategoryTheory.Functor.KanExtension.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù‚Å∂ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù‚Åµ : CategoryTheory.Category.{u_6, u_2} D\nL : CategoryTheory.Functor C D\nH : Type u_3\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_5, u_3} H\ninst‚úù¬≥ : L.Full\ninst‚úù¬≤ : L.Faithful\nF : CategoryTheory.Functor C H\nX : C\ninst‚úù¬π : L.HasPointwiseRightKanExtension F\ninst‚úù : ‚àÄ (F : CategoryTheory.Functor C H), L.HasRightKanExtension F\n‚ä¢ CategoryTheory.IsIso ((L.ranCounit.app F).app X)","decl":"instance (F : C ‚•§ H) (X : C) [HasPointwiseRightKanExtension L F]\n    [‚àÄ (F : C ‚•§ H), HasRightKanExtension L F] :\n    IsIso ((L.ranCounit.app F).app X) :=\n  (isPointwiseRightKanExtensionRanCounit L F (L.obj X)).isIso_hom_app\n\n"}
{"name":"CategoryTheory.Functor.instIsIsoAppRanCounit_1","module":"Mathlib.CategoryTheory.Functor.KanExtension.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù‚Å∂ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù‚Åµ : CategoryTheory.Category.{u_6, u_2} D\nL : CategoryTheory.Functor C D\nH : Type u_3\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_5, u_3} H\ninst‚úù¬≥ : L.Full\ninst‚úù¬≤ : L.Faithful\nF : CategoryTheory.Functor C H\ninst‚úù¬π : L.HasPointwiseRightKanExtension F\ninst‚úù : ‚àÄ (F : CategoryTheory.Functor C H), L.HasRightKanExtension F\n‚ä¢ CategoryTheory.IsIso (L.ranCounit.app F)","decl":"instance (F : C ‚•§ H) [HasPointwiseRightKanExtension L F]\n    [‚àÄ (F : C ‚•§ H), HasRightKanExtension L F] :\n    IsIso (L.ranCounit.app F) :=\n  NatIso.isIso_of_isIso_app _\n\n"}
{"name":"CategoryTheory.Functor.reflective","module":"Mathlib.CategoryTheory.Functor.KanExtension.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù¬≥ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù¬≤ : CategoryTheory.Category.{u_6, u_2} D\nL : CategoryTheory.Functor C D\nH : Type u_3\ninst‚úù¬π : CategoryTheory.Category.{u_5, u_3} H\ninst‚úù : ‚àÄ (F : CategoryTheory.Functor C H), L.HasPointwiseRightKanExtension F\n‚ä¢ CategoryTheory.IsIso L.ranCounit","decl":"instance reflective [‚àÄ (F : C ‚•§ H), HasPointwiseRightKanExtension L F] :\n    IsIso (L.ranCounit (H := H)) := by\n  apply NatIso.isIso_of_isIso_app _\n\n"}
{"name":"CategoryTheory.Functor.instIsIsoAppCounitRanAdjunctionOfHasPointwiseRightKanExtension","module":"Mathlib.CategoryTheory.Functor.KanExtension.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù¬≥ : CategoryTheory.Category.{u_6, u_2} D\nL : CategoryTheory.Functor C D\nH : Type u_3\ninst‚úù¬≤ : CategoryTheory.Category.{u_5, u_3} H\nF : CategoryTheory.Functor C H\ninst‚úù¬π : L.HasPointwiseRightKanExtension F\ninst‚úù : ‚àÄ (F : CategoryTheory.Functor C H), L.HasRightKanExtension F\n‚ä¢ CategoryTheory.IsIso ((L.ranAdjunction H).counit.app F)","decl":"instance (F : C ‚•§ H) [HasPointwiseRightKanExtension L F]\n    [‚àÄ (F : C ‚•§ H), HasRightKanExtension L F] :\n    IsIso ((L.ranAdjunction H).counit.app F) := by\n  rw [ranAdjunction_counit]\n  infer_instance\n\n"}
{"name":"CategoryTheory.Functor.reflective'","module":"Mathlib.CategoryTheory.Functor.KanExtension.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù¬≥ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù¬≤ : CategoryTheory.Category.{u_6, u_2} D\nL : CategoryTheory.Functor C D\nH : Type u_3\ninst‚úù¬π : CategoryTheory.Category.{u_5, u_3} H\ninst‚úù : ‚àÄ (F : CategoryTheory.Functor C H), L.HasPointwiseRightKanExtension F\n‚ä¢ CategoryTheory.IsIso (L.ranAdjunction H).counit","decl":"instance reflective' [‚àÄ (F : C ‚•§ H), HasPointwiseRightKanExtension L F] :\n    IsIso (L.ranAdjunction H).counit := by\n  apply NatIso.isIso_of_isIso_app _\n\n"}
