{"name":"NonUnitalRingHom.inverse_apply","module":"Mathlib.Algebra.Ring.Equiv","initialProofState":"R : Type u_4\nS : Type u_5\ninst✝¹ : NonUnitalNonAssocSemiring R\ninst✝ : NonUnitalNonAssocSemiring S\nf : NonUnitalRingHom R S\ng : S → R\nh₁ : Function.LeftInverse g ⇑f\nh₂ : Function.RightInverse g ⇑f\na✝ : S\n⊢ Eq ((f.inverse g h₁ h₂) a✝) (g a✝)","decl":"/-- makes a `NonUnitalRingHom` from the bijective inverse of a `NonUnitalRingHom` -/\n@[simps] def NonUnitalRingHom.inverse\n    [NonUnitalNonAssocSemiring R] [NonUnitalNonAssocSemiring S]\n    (f : R →ₙ+* S) (g : S → R)\n    (h₁ : Function.LeftInverse g f) (h₂ : Function.RightInverse g f) : S →ₙ+* R :=\n  { (f : R →+ S).inverse g h₁ h₂, (f : R →ₙ* S).inverse g h₁ h₂ with toFun := g }\n\n"}
{"name":"RingHom.inverse_apply","module":"Mathlib.Algebra.Ring.Equiv","initialProofState":"R : Type u_4\nS : Type u_5\ninst✝¹ : NonAssocSemiring R\ninst✝ : NonAssocSemiring S\nf : RingHom R S\ng : S → R\nh₁ : Function.LeftInverse g ⇑f\nh₂ : Function.RightInverse g ⇑f\na✝ : S\n⊢ Eq ((f.inverse g h₁ h₂) a✝) (g a✝)","decl":"/-- makes a `RingHom` from the bijective inverse of a `RingHom` -/\n@[simps] def RingHom.inverse [NonAssocSemiring R] [NonAssocSemiring S]\n    (f : RingHom R S) (g : S → R)\n    (h₁ : Function.LeftInverse g f) (h₂ : Function.RightInverse g f) : S →+* R :=\n  { (f : OneHom R S).inverse g h₁,\n    (f : MulHom R S).inverse g h₁ h₂,\n    (f : R →+ S).inverse g h₁ h₂ with toFun := g }\n\n"}
{"name":"RingEquiv.mk.sizeOf_spec","module":"Mathlib.Algebra.Ring.Equiv","initialProofState":"R : Type u_7\nS : Type u_8\ninst✝⁵ : Mul R\ninst✝⁴ : Mul S\ninst✝³ : Add R\ninst✝² : Add S\ninst✝¹ : SizeOf R\ninst✝ : SizeOf S\ntoEquiv : Equiv R S\nmap_mul' : ∀ (x y : R), Eq (toEquiv.toFun (HMul.hMul x y)) (HMul.hMul (toEquiv.toFun x) (toEquiv.toFun y))\nmap_add' : ∀ (x y : R), Eq (toEquiv.toFun (HAdd.hAdd x y)) (HAdd.hAdd (toEquiv.toFun x) (toEquiv.toFun y))\n⊢ Eq (SizeOf.sizeOf { toEquiv := toEquiv, map_mul' := map_mul', map_add' := map_add' }) (HAdd.hAdd 1 (SizeOf.sizeOf toEquiv))","decl":"/-- An equivalence between two (non-unital non-associative semi)rings that preserves the\nalgebraic structure. -/\nstructure RingEquiv (R S : Type*) [Mul R] [Mul S] [Add R] [Add S] extends R ≃ S, R ≃* S, R ≃+ S\n\n"}
{"name":"RingEquiv.mk.injEq","module":"Mathlib.Algebra.Ring.Equiv","initialProofState":"R : Type u_7\nS : Type u_8\ninst✝³ : Mul R\ninst✝² : Mul S\ninst✝¹ : Add R\ninst✝ : Add S\ntoEquiv✝ : Equiv R S\nmap_mul'✝ : ∀ (x y : R), Eq (toEquiv✝.toFun (HMul.hMul x y)) (HMul.hMul (toEquiv✝.toFun x) (toEquiv✝.toFun y))\nmap_add'✝ : ∀ (x y : R), Eq (toEquiv✝.toFun (HAdd.hAdd x y)) (HAdd.hAdd (toEquiv✝.toFun x) (toEquiv✝.toFun y))\ntoEquiv : Equiv R S\nmap_mul' : ∀ (x y : R), Eq (toEquiv.toFun (HMul.hMul x y)) (HMul.hMul (toEquiv.toFun x) (toEquiv.toFun y))\nmap_add' : ∀ (x y : R), Eq (toEquiv.toFun (HAdd.hAdd x y)) (HAdd.hAdd (toEquiv.toFun x) (toEquiv.toFun y))\n⊢ Eq (Eq { toEquiv := toEquiv✝, map_mul' := map_mul'✝, map_add' := map_add'✝ } { toEquiv := toEquiv, map_mul' := map_mul', map_add' := map_add' }) (Eq toEquiv✝ toEquiv)","decl":"/-- An equivalence between two (non-unital non-associative semi)rings that preserves the\nalgebraic structure. -/\nstructure RingEquiv (R S : Type*) [Mul R] [Mul S] [Add R] [Add S] extends R ≃ S, R ≃* S, R ≃+ S\n\n"}
{"name":"RingEquiv.map_mul'","module":"Mathlib.Algebra.Ring.Equiv","initialProofState":"R : Type u_7\nS : Type u_8\ninst✝³ : Mul R\ninst✝² : Mul S\ninst✝¹ : Add R\ninst✝ : Add S\nself : RingEquiv R S\nx y : R\n⊢ Eq (self.toFun (HMul.hMul x y)) (HMul.hMul (self.toFun x) (self.toFun y))","decl":"/-- An equivalence between two (non-unital non-associative semi)rings that preserves the\nalgebraic structure. -/\nstructure RingEquiv (R S : Type*) [Mul R] [Mul S] [Add R] [Add S] extends R ≃ S, R ≃* S, R ≃+ S\n\n"}
{"name":"RingEquiv.map_add'","module":"Mathlib.Algebra.Ring.Equiv","initialProofState":"R : Type u_7\nS : Type u_8\ninst✝³ : Mul R\ninst✝² : Mul S\ninst✝¹ : Add R\ninst✝ : Add S\nself : RingEquiv R S\nx y : R\n⊢ Eq (self.toFun (HAdd.hAdd x y)) (HAdd.hAdd (self.toFun x) (self.toFun y))","decl":"/-- An equivalence between two (non-unital non-associative semi)rings that preserves the\nalgebraic structure. -/\nstructure RingEquiv (R S : Type*) [Mul R] [Mul S] [Add R] [Add S] extends R ≃ S, R ≃* S, R ≃+ S\n\n"}
{"name":"RingEquiv.mk.inj","module":"Mathlib.Algebra.Ring.Equiv","initialProofState":"R : Type u_7\nS : Type u_8\ninst✝³ : Mul R\ninst✝² : Mul S\ninst✝¹ : Add R\ninst✝ : Add S\ntoEquiv✝ : Equiv R S\nmap_mul'✝ : ∀ (x y : R), Eq (toEquiv✝.toFun (HMul.hMul x y)) (HMul.hMul (toEquiv✝.toFun x) (toEquiv✝.toFun y))\nmap_add'✝ : ∀ (x y : R), Eq (toEquiv✝.toFun (HAdd.hAdd x y)) (HAdd.hAdd (toEquiv✝.toFun x) (toEquiv✝.toFun y))\ntoEquiv : Equiv R S\nmap_mul' : ∀ (x y : R), Eq (toEquiv.toFun (HMul.hMul x y)) (HMul.hMul (toEquiv.toFun x) (toEquiv.toFun y))\nmap_add' : ∀ (x y : R), Eq (toEquiv.toFun (HAdd.hAdd x y)) (HAdd.hAdd (toEquiv.toFun x) (toEquiv.toFun y))\nx✝ : Eq { toEquiv := toEquiv✝, map_mul' := map_mul'✝, map_add' := map_add'✝ } { toEquiv := toEquiv, map_mul' := map_mul', map_add' := map_add' }\n⊢ Eq toEquiv✝ toEquiv","decl":"/-- An equivalence between two (non-unital non-associative semi)rings that preserves the\nalgebraic structure. -/\nstructure RingEquiv (R S : Type*) [Mul R] [Mul S] [Add R] [Add S] extends R ≃ S, R ≃* S, R ≃+ S\n\n"}
{"name":"RingEquivClass.toMulEquivClass","module":"Mathlib.Algebra.Ring.Equiv","initialProofState":"F : Type u_7\nR : Type u_8\nS : Type u_9\ninst✝⁴ : Mul R\ninst✝³ : Add R\ninst✝² : Mul S\ninst✝¹ : Add S\ninst✝ : EquivLike F R S\nself : RingEquivClass F R S\n⊢ MulEquivClass F R S","decl":"/-- `RingEquivClass F R S` states that `F` is a type of ring structure preserving equivalences.\nYou should extend this class when you extend `RingEquiv`. -/\nclass RingEquivClass (F R S : Type*) [Mul R] [Add R] [Mul S] [Add S] [EquivLike F R S]\n  extends MulEquivClass F R S : Prop where\n  /-- By definition, a ring isomorphism preserves the additive structure. -/\n  map_add : ∀ (f : F) (a b), f (a + b) = f a + f b\n\n"}
{"name":"RingEquivClass.map_add","module":"Mathlib.Algebra.Ring.Equiv","initialProofState":"F : Type u_7\nR : Type u_8\nS : Type u_9\ninst✝⁴ : Mul R\ninst✝³ : Add R\ninst✝² : Mul S\ninst✝¹ : Add S\ninst✝ : EquivLike F R S\nself : RingEquivClass F R S\nf : F\na b : R\n⊢ Eq (f (HAdd.hAdd a b)) (HAdd.hAdd (f a) (f b))","decl":"/-- `RingEquivClass F R S` states that `F` is a type of ring structure preserving equivalences.\nYou should extend this class when you extend `RingEquiv`. -/\nclass RingEquivClass (F R S : Type*) [Mul R] [Add R] [Mul S] [Add S] [EquivLike F R S]\n  extends MulEquivClass F R S : Prop where\n  /-- By definition, a ring isomorphism preserves the additive structure. -/\n  map_add : ∀ (f : F) (a b), f (a + b) = f a + f b\n\n"}
{"name":"RingEquivClass.toAddEquivClass","module":"Mathlib.Algebra.Ring.Equiv","initialProofState":"F : Type u_1\nR : Type u_4\nS : Type u_5\ninst✝⁴ : EquivLike F R S\ninst✝³ : Mul R\ninst✝² : Add R\ninst✝¹ : Mul S\ninst✝ : Add S\nh : RingEquivClass F R S\n⊢ AddEquivClass F R S","decl":"instance (priority := 100) toAddEquivClass [Mul R] [Add R]\n    [Mul S] [Add S] [h : RingEquivClass F R S] : AddEquivClass F R S :=\n  { h with }\n\n-- See note [lower instance priority]\n"}
{"name":"RingEquivClass.toRingHomClass","module":"Mathlib.Algebra.Ring.Equiv","initialProofState":"F : Type u_1\nR : Type u_4\nS : Type u_5\ninst✝² : EquivLike F R S\ninst✝¹ : NonAssocSemiring R\ninst✝ : NonAssocSemiring S\nh : RingEquivClass F R S\n⊢ RingHomClass F R S","decl":"instance (priority := 100) toRingHomClass [NonAssocSemiring R] [NonAssocSemiring S]\n    [h : RingEquivClass F R S] : RingHomClass F R S :=\n  { h with\n    map_zero := map_zero\n    map_one := map_one }\n\n-- See note [lower instance priority]\n"}
{"name":"RingEquivClass.toNonUnitalRingHomClass","module":"Mathlib.Algebra.Ring.Equiv","initialProofState":"F : Type u_1\nR : Type u_4\nS : Type u_5\ninst✝² : EquivLike F R S\ninst✝¹ : NonUnitalNonAssocSemiring R\ninst✝ : NonUnitalNonAssocSemiring S\nh : RingEquivClass F R S\n⊢ NonUnitalRingHomClass F R S","decl":"instance (priority := 100) toNonUnitalRingHomClass [NonUnitalNonAssocSemiring R]\n    [NonUnitalNonAssocSemiring S] [h : RingEquivClass F R S] : NonUnitalRingHomClass F R S :=\n  { h with\n    map_zero := map_zero }\n\n"}
{"name":"RingEquiv.instRingEquivClass","module":"Mathlib.Algebra.Ring.Equiv","initialProofState":"R : Type u_4\nS : Type u_5\ninst✝³ : Mul R\ninst✝² : Mul S\ninst✝¹ : Add R\ninst✝ : Add S\n⊢ RingEquivClass (RingEquiv R S) R S","decl":"instance : RingEquivClass (R ≃+* S) R S where\n  map_add f := f.map_add'\n  map_mul f := f.map_mul'\n\n"}
{"name":"RingEquiv.ext_iff","module":"Mathlib.Algebra.Ring.Equiv","initialProofState":"R : Type u_4\nS : Type u_5\ninst✝³ : Mul R\ninst✝² : Mul S\ninst✝¹ : Add R\ninst✝ : Add S\nf g : RingEquiv R S\n⊢ Iff (Eq f g) (∀ (x : R), Eq (f x) (g x))","decl":"/-- Two ring isomorphisms agree if they are defined by the\n    same underlying function. -/\n@[ext]\ntheorem ext {f g : R ≃+* S} (h : ∀ x, f x = g x) : f = g :=\n  DFunLike.ext f g h\n\n"}
{"name":"RingEquiv.ext","module":"Mathlib.Algebra.Ring.Equiv","initialProofState":"R : Type u_4\nS : Type u_5\ninst✝³ : Mul R\ninst✝² : Mul S\ninst✝¹ : Add R\ninst✝ : Add S\nf g : RingEquiv R S\nh : ∀ (x : R), Eq (f x) (g x)\n⊢ Eq f g","decl":"/-- Two ring isomorphisms agree if they are defined by the\n    same underlying function. -/\n@[ext]\ntheorem ext {f g : R ≃+* S} (h : ∀ x, f x = g x) : f = g :=\n  DFunLike.ext f g h\n\n"}
{"name":"RingEquiv.congr_arg","module":"Mathlib.Algebra.Ring.Equiv","initialProofState":"R : Type u_4\nS : Type u_5\ninst✝³ : Mul R\ninst✝² : Mul S\ninst✝¹ : Add R\ninst✝ : Add S\nf : RingEquiv R S\nx x' : R\na✝ : Eq x x'\n⊢ Eq (f x) (f x')","decl":"protected theorem congr_arg {f : R ≃+* S} {x x' : R} : x = x' → f x = f x' :=\n  DFunLike.congr_arg f\n\n"}
{"name":"RingEquiv.congr_fun","module":"Mathlib.Algebra.Ring.Equiv","initialProofState":"R : Type u_4\nS : Type u_5\ninst✝³ : Mul R\ninst✝² : Mul S\ninst✝¹ : Add R\ninst✝ : Add S\nf g : RingEquiv R S\nh : Eq f g\nx : R\n⊢ Eq (f x) (g x)","decl":"protected theorem congr_fun {f g : R ≃+* S} (h : f = g) (x : R) : f x = g x :=\n  DFunLike.congr_fun h x\n\n"}
{"name":"RingEquiv.coe_mk","module":"Mathlib.Algebra.Ring.Equiv","initialProofState":"R : Type u_4\nS : Type u_5\ninst✝³ : Mul R\ninst✝² : Mul S\ninst✝¹ : Add R\ninst✝ : Add S\ne : Equiv R S\nh₃ : ∀ (x y : R), Eq (e.toFun (HMul.hMul x y)) (HMul.hMul (e.toFun x) (e.toFun y))\nh₄ : ∀ (x y : R), Eq (e.toFun (HAdd.hAdd x y)) (HAdd.hAdd (e.toFun x) (e.toFun y))\n⊢ Eq ⇑{ toEquiv := e, map_mul' := h₃, map_add' := h₄ } ⇑e","decl":"@[simp]\ntheorem coe_mk (e h₃ h₄) : ⇑(⟨e, h₃, h₄⟩ : R ≃+* S) = e :=\n  rfl\n\n-- Porting note: `toEquiv_mk` no longer needed in Lean4\n\n"}
{"name":"RingEquiv.mk_coe","module":"Mathlib.Algebra.Ring.Equiv","initialProofState":"R : Type u_4\nS : Type u_5\ninst✝³ : Mul R\ninst✝² : Mul S\ninst✝¹ : Add R\ninst✝ : Add S\ne : RingEquiv R S\ne' : S → R\nh₁ : Function.LeftInverse e' ⇑e\nh₂ : Function.RightInverse e' ⇑e\nh₃ : ∀ (x y : R), Eq ({ toFun := ⇑e, invFun := e', left_inv := h₁, right_inv := h₂ }.toFun (HMul.hMul x y)) (HMul.hMul ({ toFun := ⇑e, invFun := e', left_inv := h₁, right_inv := h₂ }.toFun x) ({ toFun := ⇑e, invFun := e', left_inv := h₁, right_inv := h₂ }.toFun y))\nh₄ : ∀ (x y : R), Eq ({ toFun := ⇑e, invFun := e', left_inv := h₁, right_inv := h₂ }.toFun (HAdd.hAdd x y)) (HAdd.hAdd ({ toFun := ⇑e, invFun := e', left_inv := h₁, right_inv := h₂ }.toFun x) ({ toFun := ⇑e, invFun := e', left_inv := h₁, right_inv := h₂ }.toFun y))\n⊢ Eq { toFun := ⇑e, invFun := e', left_inv := h₁, right_inv := h₂, map_mul' := h₃, map_add' := h₄ } e","decl":"@[simp]\ntheorem mk_coe (e : R ≃+* S) (e' h₁ h₂ h₃ h₄) : (⟨⟨e, e', h₁, h₂⟩, h₃, h₄⟩ : R ≃+* S) = e :=\n  ext fun _ => rfl\n\n"}
{"name":"RingEquiv.toEquiv_eq_coe","module":"Mathlib.Algebra.Ring.Equiv","initialProofState":"R : Type u_4\nS : Type u_5\ninst✝³ : Mul R\ninst✝² : Mul S\ninst✝¹ : Add R\ninst✝ : Add S\nf : RingEquiv R S\n⊢ Eq f.toEquiv ↑f","decl":"@[simp]\ntheorem toEquiv_eq_coe (f : R ≃+* S) : f.toEquiv = f :=\n  rfl\n\n"}
{"name":"RingEquiv.coe_toEquiv","module":"Mathlib.Algebra.Ring.Equiv","initialProofState":"R : Type u_4\nS : Type u_5\ninst✝³ : Mul R\ninst✝² : Mul S\ninst✝¹ : Add R\ninst✝ : Add S\nf : RingEquiv R S\n⊢ Eq ⇑↑f ⇑f","decl":"@[simp]\ntheorem coe_toEquiv (f : R ≃+* S) : ⇑(f : R ≃ S) = f :=\n  rfl\n\n"}
{"name":"RingEquiv.toAddEquiv_eq_coe","module":"Mathlib.Algebra.Ring.Equiv","initialProofState":"R : Type u_4\nS : Type u_5\ninst✝³ : Mul R\ninst✝² : Mul S\ninst✝¹ : Add R\ninst✝ : Add S\nf : RingEquiv R S\n⊢ Eq f.toAddEquiv ↑f","decl":"@[simp]\ntheorem toAddEquiv_eq_coe (f : R ≃+* S) : f.toAddEquiv = ↑f :=\n  rfl\n\n"}
{"name":"RingEquiv.toMulEquiv_eq_coe","module":"Mathlib.Algebra.Ring.Equiv","initialProofState":"R : Type u_4\nS : Type u_5\ninst✝³ : Mul R\ninst✝² : Mul S\ninst✝¹ : Add R\ninst✝ : Add S\nf : RingEquiv R S\n⊢ Eq f.toMulEquiv ↑f","decl":"@[simp]\ntheorem toMulEquiv_eq_coe (f : R ≃+* S) : f.toMulEquiv = ↑f :=\n  rfl\n\n"}
{"name":"RingEquiv.coe_toMulEquiv","module":"Mathlib.Algebra.Ring.Equiv","initialProofState":"R : Type u_4\nS : Type u_5\ninst✝³ : Mul R\ninst✝² : Mul S\ninst✝¹ : Add R\ninst✝ : Add S\nf : RingEquiv R S\n⊢ Eq ⇑↑f ⇑f","decl":"@[simp, norm_cast]\ntheorem coe_toMulEquiv (f : R ≃+* S) : ⇑(f : R ≃* S) = f :=\n  rfl\n\n"}
{"name":"RingEquiv.coe_toAddEquiv","module":"Mathlib.Algebra.Ring.Equiv","initialProofState":"R : Type u_4\nS : Type u_5\ninst✝³ : Mul R\ninst✝² : Mul S\ninst✝¹ : Add R\ninst✝ : Add S\nf : RingEquiv R S\n⊢ Eq ⇑↑f ⇑f","decl":"@[simp]\ntheorem coe_toAddEquiv (f : R ≃+* S) : ⇑(f : R ≃+ S) = f :=\n  rfl\n\n"}
{"name":"RingEquiv.map_mul","module":"Mathlib.Algebra.Ring.Equiv","initialProofState":"R : Type u_4\nS : Type u_5\ninst✝³ : Mul R\ninst✝² : Mul S\ninst✝¹ : Add R\ninst✝ : Add S\ne : RingEquiv R S\nx y : R\n⊢ Eq (e (HMul.hMul x y)) (HMul.hMul (e x) (e y))","decl":"/-- A ring isomorphism preserves multiplication. -/\nprotected theorem map_mul (e : R ≃+* S) (x y : R) : e (x * y) = e x * e y :=\n  map_mul e x y\n\n"}
{"name":"RingEquiv.map_add","module":"Mathlib.Algebra.Ring.Equiv","initialProofState":"R : Type u_4\nS : Type u_5\ninst✝³ : Mul R\ninst✝² : Mul S\ninst✝¹ : Add R\ninst✝ : Add S\ne : RingEquiv R S\nx y : R\n⊢ Eq (e (HAdd.hAdd x y)) (HAdd.hAdd (e x) (e y))","decl":"/-- A ring isomorphism preserves addition. -/\nprotected theorem map_add (e : R ≃+* S) (x y : R) : e (x + y) = e x + e y :=\n  map_add e x y\n\n"}
{"name":"RingEquiv.bijective","module":"Mathlib.Algebra.Ring.Equiv","initialProofState":"R : Type u_4\nS : Type u_5\ninst✝³ : Mul R\ninst✝² : Mul S\ninst✝¹ : Add R\ninst✝ : Add S\ne : RingEquiv R S\n⊢ Function.Bijective ⇑e","decl":"protected theorem bijective (e : R ≃+* S) : Function.Bijective e :=\n  EquivLike.bijective e\n\n"}
{"name":"RingEquiv.injective","module":"Mathlib.Algebra.Ring.Equiv","initialProofState":"R : Type u_4\nS : Type u_5\ninst✝³ : Mul R\ninst✝² : Mul S\ninst✝¹ : Add R\ninst✝ : Add S\ne : RingEquiv R S\n⊢ Function.Injective ⇑e","decl":"protected theorem injective (e : R ≃+* S) : Function.Injective e :=\n  EquivLike.injective e\n\n"}
{"name":"RingEquiv.surjective","module":"Mathlib.Algebra.Ring.Equiv","initialProofState":"R : Type u_4\nS : Type u_5\ninst✝³ : Mul R\ninst✝² : Mul S\ninst✝¹ : Add R\ninst✝ : Add S\ne : RingEquiv R S\n⊢ Function.Surjective ⇑e","decl":"protected theorem surjective (e : R ≃+* S) : Function.Surjective e :=\n  EquivLike.surjective e\n\n"}
{"name":"RingEquiv.refl_apply","module":"Mathlib.Algebra.Ring.Equiv","initialProofState":"R : Type u_4\ninst✝¹ : Mul R\ninst✝ : Add R\nx : R\n⊢ Eq ((RingEquiv.refl R) x) x","decl":"@[simp]\ntheorem refl_apply (x : R) : RingEquiv.refl R x = x :=\n  rfl\n\n"}
{"name":"RingEquiv.coe_refl_id","module":"Mathlib.Algebra.Ring.Equiv","initialProofState":"R : Type u_7\ninst✝¹ : Mul R\ninst✝ : Add R\n⊢ Eq (⇑(RingEquiv.refl R)) id","decl":"@[simp]\ntheorem coe_refl_id (R : Type*) [Mul R] [Add R] :\n⇑(RingEquiv.refl R) = id := rfl\n\n"}
{"name":"RingEquiv.coe_addEquiv_refl","module":"Mathlib.Algebra.Ring.Equiv","initialProofState":"R : Type u_4\ninst✝¹ : Mul R\ninst✝ : Add R\n⊢ Eq (↑(RingEquiv.refl R)) (AddEquiv.refl R)","decl":"@[simp]\ntheorem coe_addEquiv_refl : (RingEquiv.refl R : R ≃+ R) = AddEquiv.refl R :=\n  rfl\n\n"}
{"name":"RingEquiv.coe_mulEquiv_refl","module":"Mathlib.Algebra.Ring.Equiv","initialProofState":"R : Type u_4\ninst✝¹ : Mul R\ninst✝ : Add R\n⊢ Eq (↑(RingEquiv.refl R)) (MulEquiv.refl R)","decl":"@[simp]\ntheorem coe_mulEquiv_refl : (RingEquiv.refl R : R ≃* R) = MulEquiv.refl R :=\n  rfl\n\n"}
{"name":"RingEquiv.invFun_eq_symm","module":"Mathlib.Algebra.Ring.Equiv","initialProofState":"R : Type u_4\nS : Type u_5\ninst✝³ : Mul R\ninst✝² : Mul S\ninst✝¹ : Add R\ninst✝ : Add S\nf : RingEquiv R S\n⊢ Eq (EquivLike.inv f) ⇑f.symm","decl":"@[simp]\ntheorem invFun_eq_symm (f : R ≃+* S) : EquivLike.inv f = f.symm :=\n  rfl\n\n"}
{"name":"RingEquiv.symm_symm","module":"Mathlib.Algebra.Ring.Equiv","initialProofState":"R : Type u_4\nS : Type u_5\ninst✝³ : Mul R\ninst✝² : Mul S\ninst✝¹ : Add R\ninst✝ : Add S\ne : RingEquiv R S\n⊢ Eq e.symm.symm e","decl":"@[simp]\ntheorem symm_symm (e : R ≃+* S) : e.symm.symm = e := rfl\n\n"}
{"name":"RingEquiv.symm_bijective","module":"Mathlib.Algebra.Ring.Equiv","initialProofState":"R : Type u_4\nS : Type u_5\ninst✝³ : Mul R\ninst✝² : Mul S\ninst✝¹ : Add R\ninst✝ : Add S\n⊢ Function.Bijective RingEquiv.symm","decl":"theorem symm_bijective : Function.Bijective (RingEquiv.symm : (R ≃+* S) → S ≃+* R) :=\n  Function.bijective_iff_has_inverse.mpr ⟨_, symm_symm, symm_symm⟩\n\n"}
{"name":"RingEquiv.mk_coe'","module":"Mathlib.Algebra.Ring.Equiv","initialProofState":"R : Type u_4\nS : Type u_5\ninst✝³ : Mul R\ninst✝² : Mul S\ninst✝¹ : Add R\ninst✝ : Add S\ne : RingEquiv R S\nf : S → R\nh₁ : Function.LeftInverse (⇑e) f\nh₂ : Function.RightInverse (⇑e) f\nh₃ : ∀ (x y : S), Eq ({ toFun := f, invFun := ⇑e, left_inv := h₁, right_inv := h₂ }.toFun (HMul.hMul x y)) (HMul.hMul ({ toFun := f, invFun := ⇑e, left_inv := h₁, right_inv := h₂ }.toFun x) ({ toFun := f, invFun := ⇑e, left_inv := h₁, right_inv := h₂ }.toFun y))\nh₄ : ∀ (x y : S), Eq ({ toFun := f, invFun := ⇑e, left_inv := h₁, right_inv := h₂ }.toFun (HAdd.hAdd x y)) (HAdd.hAdd ({ toFun := f, invFun := ⇑e, left_inv := h₁, right_inv := h₂ }.toFun x) ({ toFun := f, invFun := ⇑e, left_inv := h₁, right_inv := h₂ }.toFun y))\n⊢ Eq { toFun := f, invFun := ⇑e, left_inv := h₁, right_inv := h₂, map_mul' := h₃, map_add' := h₄ } e.symm","decl":"@[simp]\ntheorem mk_coe' (e : R ≃+* S) (f h₁ h₂ h₃ h₄) :\n    (⟨⟨f, ⇑e, h₁, h₂⟩, h₃, h₄⟩ : S ≃+* R) = e.symm :=\n  symm_bijective.injective <| ext fun _ => rfl\n\n"}
{"name":"RingEquiv.symm_mk","module":"Mathlib.Algebra.Ring.Equiv","initialProofState":"R : Type u_4\nS : Type u_5\ninst✝³ : Mul R\ninst✝² : Mul S\ninst✝¹ : Add R\ninst✝ : Add S\nf : R → S\ng : S → R\nh₁ : Function.LeftInverse g f\nh₂ : Function.RightInverse g f\nh₃ : ∀ (x y : R), Eq ({ toFun := f, invFun := g, left_inv := h₁, right_inv := h₂ }.toFun (HMul.hMul x y)) (HMul.hMul ({ toFun := f, invFun := g, left_inv := h₁, right_inv := h₂ }.toFun x) ({ toFun := f, invFun := g, left_inv := h₁, right_inv := h₂ }.toFun y))\nh₄ : ∀ (x y : R), Eq ({ toFun := f, invFun := g, left_inv := h₁, right_inv := h₂ }.toFun (HAdd.hAdd x y)) (HAdd.hAdd ({ toFun := f, invFun := g, left_inv := h₁, right_inv := h₂ }.toFun x) ({ toFun := f, invFun := g, left_inv := h₁, right_inv := h₂ }.toFun y))\n⊢ Eq { toFun := f, invFun := g, left_inv := h₁, right_inv := h₂, map_mul' := h₃, map_add' := h₄ }.symm\n    (let __src := RingEquiv.symm_mk.aux f g h₁ h₂ h₃ h₄;\n    { toFun := g, invFun := f, left_inv := ⋯, right_inv := ⋯, map_mul' := ⋯, map_add' := ⋯ })","decl":"@[simp]\ntheorem symm_mk (f : R → S) (g h₁ h₂ h₃ h₄) :\n    (mk ⟨f, g, h₁, h₂⟩ h₃ h₄).symm =\n      { symm_mk.aux f g h₁ h₂ h₃ h₄ with\n        toFun := g\n        invFun := f } :=\n  rfl\n\n"}
{"name":"RingEquiv.symm_refl","module":"Mathlib.Algebra.Ring.Equiv","initialProofState":"R : Type u_4\ninst✝¹ : Mul R\ninst✝ : Add R\n⊢ Eq (RingEquiv.refl R).symm (RingEquiv.refl R)","decl":"@[simp]\ntheorem symm_refl : (RingEquiv.refl R).symm = RingEquiv.refl R :=\n  rfl\n\n"}
{"name":"RingEquiv.coe_toEquiv_symm","module":"Mathlib.Algebra.Ring.Equiv","initialProofState":"R : Type u_4\nS : Type u_5\ninst✝³ : Mul R\ninst✝² : Mul S\ninst✝¹ : Add R\ninst✝ : Add S\ne : RingEquiv R S\n⊢ Eq (↑e.symm) (↑e).symm","decl":"@[simp]\ntheorem coe_toEquiv_symm (e : R ≃+* S) : (e.symm : S ≃ R) = (e : R ≃ S).symm :=\n  rfl\n\n"}
{"name":"RingEquiv.apply_symm_apply","module":"Mathlib.Algebra.Ring.Equiv","initialProofState":"R : Type u_4\nS : Type u_5\ninst✝³ : Mul R\ninst✝² : Mul S\ninst✝¹ : Add R\ninst✝ : Add S\ne : RingEquiv R S\nx : S\n⊢ Eq (e (e.symm x)) x","decl":"@[simp]\ntheorem apply_symm_apply (e : R ≃+* S) : ∀ x, e (e.symm x) = x :=\n  e.toEquiv.apply_symm_apply\n\n"}
{"name":"RingEquiv.symm_apply_apply","module":"Mathlib.Algebra.Ring.Equiv","initialProofState":"R : Type u_4\nS : Type u_5\ninst✝³ : Mul R\ninst✝² : Mul S\ninst✝¹ : Add R\ninst✝ : Add S\ne : RingEquiv R S\nx : R\n⊢ Eq (e.symm (e x)) x","decl":"@[simp]\ntheorem symm_apply_apply (e : R ≃+* S) : ∀ x, e.symm (e x) = x :=\n  e.toEquiv.symm_apply_apply\n\n"}
{"name":"RingEquiv.image_eq_preimage","module":"Mathlib.Algebra.Ring.Equiv","initialProofState":"R : Type u_4\nS : Type u_5\ninst✝³ : Mul R\ninst✝² : Mul S\ninst✝¹ : Add R\ninst✝ : Add S\ne : RingEquiv R S\ns : Set R\n⊢ Eq (Set.image (⇑e) s) (Set.preimage (⇑e.symm) s)","decl":"theorem image_eq_preimage (e : R ≃+* S) (s : Set R) : e '' s = e.symm ⁻¹' s :=\n  e.toEquiv.image_eq_preimage s\n\n"}
{"name":"RingEquiv.coe_trans","module":"Mathlib.Algebra.Ring.Equiv","initialProofState":"R : Type u_4\nS : Type u_5\nS' : Type u_6\ninst✝⁵ : Mul R\ninst✝⁴ : Mul S\ninst✝³ : Add R\ninst✝² : Add S\ninst✝¹ : Mul S'\ninst✝ : Add S'\ne₁ : RingEquiv R S\ne₂ : RingEquiv S S'\n⊢ Eq (⇑(e₁.trans e₂)) (Function.comp ⇑e₂ ⇑e₁)","decl":"@[simp]\ntheorem coe_trans (e₁ : R ≃+* S) (e₂ : S ≃+* S') : (e₁.trans e₂ : R → S') = e₂ ∘ e₁ :=\n  rfl\n\n"}
{"name":"RingEquiv.trans_apply","module":"Mathlib.Algebra.Ring.Equiv","initialProofState":"R : Type u_4\nS : Type u_5\nS' : Type u_6\ninst✝⁵ : Mul R\ninst✝⁴ : Mul S\ninst✝³ : Add R\ninst✝² : Add S\ninst✝¹ : Mul S'\ninst✝ : Add S'\ne₁ : RingEquiv R S\ne₂ : RingEquiv S S'\na : R\n⊢ Eq ((e₁.trans e₂) a) (e₂ (e₁ a))","decl":"theorem trans_apply (e₁ : R ≃+* S) (e₂ : S ≃+* S') (a : R) : e₁.trans e₂ a = e₂ (e₁ a) :=\n  rfl\n\n"}
{"name":"RingEquiv.symm_trans_apply","module":"Mathlib.Algebra.Ring.Equiv","initialProofState":"R : Type u_4\nS : Type u_5\nS' : Type u_6\ninst✝⁵ : Mul R\ninst✝⁴ : Mul S\ninst✝³ : Add R\ninst✝² : Add S\ninst✝¹ : Mul S'\ninst✝ : Add S'\ne₁ : RingEquiv R S\ne₂ : RingEquiv S S'\na : S'\n⊢ Eq ((e₁.trans e₂).symm a) (e₁.symm (e₂.symm a))","decl":"@[simp]\ntheorem symm_trans_apply (e₁ : R ≃+* S) (e₂ : S ≃+* S') (a : S') :\n    (e₁.trans e₂).symm a = e₁.symm (e₂.symm a) :=\n  rfl\n\n"}
{"name":"RingEquiv.symm_trans","module":"Mathlib.Algebra.Ring.Equiv","initialProofState":"R : Type u_4\nS : Type u_5\nS' : Type u_6\ninst✝⁵ : Mul R\ninst✝⁴ : Mul S\ninst✝³ : Add R\ninst✝² : Add S\ninst✝¹ : Mul S'\ninst✝ : Add S'\ne₁ : RingEquiv R S\ne₂ : RingEquiv S S'\n⊢ Eq (e₁.trans e₂).symm (e₂.symm.trans e₁.symm)","decl":"theorem symm_trans (e₁ : R ≃+* S) (e₂ : S ≃+* S') : (e₁.trans e₂).symm = e₂.symm.trans e₁.symm :=\n  rfl\n\n"}
{"name":"RingEquiv.coe_mulEquiv_trans","module":"Mathlib.Algebra.Ring.Equiv","initialProofState":"R : Type u_4\nS : Type u_5\nS' : Type u_6\ninst✝⁵ : Mul R\ninst✝⁴ : Mul S\ninst✝³ : Add R\ninst✝² : Add S\ninst✝¹ : Mul S'\ninst✝ : Add S'\ne₁ : RingEquiv R S\ne₂ : RingEquiv S S'\n⊢ Eq (↑(e₁.trans e₂)) ((↑e₁).trans ↑e₂)","decl":"@[simp]\ntheorem coe_mulEquiv_trans (e₁ : R ≃+* S) (e₂ : S ≃+* S') :\n    (e₁.trans e₂ : R ≃* S') = (e₁ : R ≃* S).trans ↑e₂ :=\n  rfl\n\n"}
{"name":"RingEquiv.coe_addEquiv_trans","module":"Mathlib.Algebra.Ring.Equiv","initialProofState":"R : Type u_4\nS : Type u_5\nS' : Type u_6\ninst✝⁵ : Mul R\ninst✝⁴ : Mul S\ninst✝³ : Add R\ninst✝² : Add S\ninst✝¹ : Mul S'\ninst✝ : Add S'\ne₁ : RingEquiv R S\ne₂ : RingEquiv S S'\n⊢ Eq (↑(e₁.trans e₂)) ((↑e₁).trans ↑e₂)","decl":"@[simp]\ntheorem coe_addEquiv_trans (e₁ : R ≃+* S) (e₂ : S ≃+* S') :\n    (e₁.trans e₂ : R ≃+ S') = (e₁ : R ≃+ S).trans ↑e₂ :=\n  rfl\n\n"}
{"name":"RingEquiv.op_symm_apply_apply","module":"Mathlib.Algebra.Ring.Equiv","initialProofState":"α : Type u_7\nβ : Type u_8\ninst✝³ : Add α\ninst✝² : Mul α\ninst✝¹ : Add β\ninst✝ : Mul β\nf : RingEquiv (MulOpposite α) (MulOpposite β)\na✝ : α\n⊢ Eq ((RingEquiv.op.symm f) a✝) (MulOpposite.unop (f (MulOpposite.op a✝)))","decl":"/-- A ring iso `α ≃+* β` can equivalently be viewed as a ring iso `αᵐᵒᵖ ≃+* βᵐᵒᵖ`. -/\n@[simps! symm_apply_apply symm_apply_symm_apply apply_apply apply_symm_apply]\nprotected def op {α β} [Add α] [Mul α] [Add β] [Mul β] :\n    α ≃+* β ≃ (αᵐᵒᵖ ≃+* βᵐᵒᵖ) where\n  toFun f := { AddEquiv.mulOp f.toAddEquiv, MulEquiv.op f.toMulEquiv with }\n  invFun f := { AddEquiv.mulOp.symm f.toAddEquiv, MulEquiv.op.symm f.toMulEquiv with }\n  left_inv f := by\n    ext\n    rfl\n  right_inv f := by\n    ext\n    rfl\n\n"}
{"name":"RingEquiv.op_apply_apply","module":"Mathlib.Algebra.Ring.Equiv","initialProofState":"α : Type u_7\nβ : Type u_8\ninst✝³ : Add α\ninst✝² : Mul α\ninst✝¹ : Add β\ninst✝ : Mul β\nf : RingEquiv α β\na✝ : MulOpposite α\n⊢ Eq ((RingEquiv.op f) a✝) (MulOpposite.op (f (MulOpposite.unop a✝)))","decl":"/-- A ring iso `α ≃+* β` can equivalently be viewed as a ring iso `αᵐᵒᵖ ≃+* βᵐᵒᵖ`. -/\n@[simps! symm_apply_apply symm_apply_symm_apply apply_apply apply_symm_apply]\nprotected def op {α β} [Add α] [Mul α] [Add β] [Mul β] :\n    α ≃+* β ≃ (αᵐᵒᵖ ≃+* βᵐᵒᵖ) where\n  toFun f := { AddEquiv.mulOp f.toAddEquiv, MulEquiv.op f.toMulEquiv with }\n  invFun f := { AddEquiv.mulOp.symm f.toAddEquiv, MulEquiv.op.symm f.toMulEquiv with }\n  left_inv f := by\n    ext\n    rfl\n  right_inv f := by\n    ext\n    rfl\n\n"}
{"name":"RingEquiv.op_symm_apply_symm_apply","module":"Mathlib.Algebra.Ring.Equiv","initialProofState":"α : Type u_7\nβ : Type u_8\ninst✝³ : Add α\ninst✝² : Mul α\ninst✝¹ : Add β\ninst✝ : Mul β\nf : RingEquiv (MulOpposite α) (MulOpposite β)\na✝ : β\n⊢ Eq ((RingEquiv.op.symm f).symm a✝) (MulOpposite.unop ((↑f).symm (MulOpposite.op a✝)))","decl":"/-- A ring iso `α ≃+* β` can equivalently be viewed as a ring iso `αᵐᵒᵖ ≃+* βᵐᵒᵖ`. -/\n@[simps! symm_apply_apply symm_apply_symm_apply apply_apply apply_symm_apply]\nprotected def op {α β} [Add α] [Mul α] [Add β] [Mul β] :\n    α ≃+* β ≃ (αᵐᵒᵖ ≃+* βᵐᵒᵖ) where\n  toFun f := { AddEquiv.mulOp f.toAddEquiv, MulEquiv.op f.toMulEquiv with }\n  invFun f := { AddEquiv.mulOp.symm f.toAddEquiv, MulEquiv.op.symm f.toMulEquiv with }\n  left_inv f := by\n    ext\n    rfl\n  right_inv f := by\n    ext\n    rfl\n\n"}
{"name":"RingEquiv.op_apply_symm_apply","module":"Mathlib.Algebra.Ring.Equiv","initialProofState":"α : Type u_7\nβ : Type u_8\ninst✝³ : Add α\ninst✝² : Mul α\ninst✝¹ : Add β\ninst✝ : Mul β\nf : RingEquiv α β\na✝ : MulOpposite β\n⊢ Eq ((RingEquiv.op f).symm a✝) (MulOpposite.op ((↑f).symm (MulOpposite.unop a✝)))","decl":"/-- A ring iso `α ≃+* β` can equivalently be viewed as a ring iso `αᵐᵒᵖ ≃+* βᵐᵒᵖ`. -/\n@[simps! symm_apply_apply symm_apply_symm_apply apply_apply apply_symm_apply]\nprotected def op {α β} [Add α] [Mul α] [Add β] [Mul β] :\n    α ≃+* β ≃ (αᵐᵒᵖ ≃+* βᵐᵒᵖ) where\n  toFun f := { AddEquiv.mulOp f.toAddEquiv, MulEquiv.op f.toMulEquiv with }\n  invFun f := { AddEquiv.mulOp.symm f.toAddEquiv, MulEquiv.op.symm f.toMulEquiv with }\n  left_inv f := by\n    ext\n    rfl\n  right_inv f := by\n    ext\n    rfl\n\n"}
{"name":"RingEquiv.opOp_symm_apply","module":"Mathlib.Algebra.Ring.Equiv","initialProofState":"R : Type u_7\ninst✝¹ : Add R\ninst✝ : Mul R\na✝ : MulOpposite (MulOpposite R)\n⊢ Eq ((RingEquiv.opOp R).symm a✝) (MulOpposite.unop (MulOpposite.unop a✝))","decl":"/-- A ring is isomorphic to the opposite of its opposite. -/\n@[simps!]\ndef opOp (R : Type*) [Add R] [Mul R] : R ≃+* Rᵐᵒᵖᵐᵒᵖ where\n  __ := MulEquiv.opOp R\n  map_add' _ _ := rfl\n\n"}
{"name":"RingEquiv.opOp_apply","module":"Mathlib.Algebra.Ring.Equiv","initialProofState":"R : Type u_7\ninst✝¹ : Add R\ninst✝ : Mul R\na✝ : R\n⊢ Eq ((RingEquiv.opOp R) a✝) (MulOpposite.op (MulOpposite.op a✝))","decl":"/-- A ring is isomorphic to the opposite of its opposite. -/\n@[simps!]\ndef opOp (R : Type*) [Add R] [Mul R] : R ≃+* Rᵐᵒᵖᵐᵒᵖ where\n  __ := MulEquiv.opOp R\n  map_add' _ _ := rfl\n\n"}
{"name":"RingEquiv.toOpposite_apply","module":"Mathlib.Algebra.Ring.Equiv","initialProofState":"R : Type u_4\ninst✝ : NonUnitalCommSemiring R\nr : R\n⊢ Eq ((RingEquiv.toOpposite R) r) (MulOpposite.op r)","decl":"@[simp]\ntheorem toOpposite_apply (r : R) : toOpposite R r = op r :=\n  rfl\n\n"}
{"name":"RingEquiv.toOpposite_symm_apply","module":"Mathlib.Algebra.Ring.Equiv","initialProofState":"R : Type u_4\ninst✝ : NonUnitalCommSemiring R\nr : MulOpposite R\n⊢ Eq ((RingEquiv.toOpposite R).symm r) (MulOpposite.unop r)","decl":"@[simp]\ntheorem toOpposite_symm_apply (r : Rᵐᵒᵖ) : (toOpposite R).symm r = unop r :=\n  rfl\n\n"}
{"name":"RingEquiv.map_zero","module":"Mathlib.Algebra.Ring.Equiv","initialProofState":"R : Type u_4\nS : Type u_5\ninst✝¹ : NonUnitalNonAssocSemiring R\ninst✝ : NonUnitalNonAssocSemiring S\nf : RingEquiv R S\n⊢ Eq (f 0) 0","decl":"/-- A ring isomorphism sends zero to zero. -/\nprotected theorem map_zero : f 0 = 0 :=\n  map_zero f\n\n"}
{"name":"RingEquiv.map_eq_zero_iff","module":"Mathlib.Algebra.Ring.Equiv","initialProofState":"R : Type u_4\nS : Type u_5\ninst✝¹ : NonUnitalNonAssocSemiring R\ninst✝ : NonUnitalNonAssocSemiring S\nf : RingEquiv R S\nx : R\n⊢ Iff (Eq (f x) 0) (Eq x 0)","decl":"protected theorem map_eq_zero_iff : f x = 0 ↔ x = 0 :=\n  EmbeddingLike.map_eq_zero_iff\n\n"}
{"name":"RingEquiv.map_ne_zero_iff","module":"Mathlib.Algebra.Ring.Equiv","initialProofState":"R : Type u_4\nS : Type u_5\ninst✝¹ : NonUnitalNonAssocSemiring R\ninst✝ : NonUnitalNonAssocSemiring S\nf : RingEquiv R S\nx : R\n⊢ Iff (Ne (f x) 0) (Ne x 0)","decl":"theorem map_ne_zero_iff : f x ≠ 0 ↔ x ≠ 0 :=\n  EmbeddingLike.map_ne_zero_iff\n\n"}
{"name":"RingEquiv.coe_ofBijective","module":"Mathlib.Algebra.Ring.Equiv","initialProofState":"F : Type u_1\nR : Type u_4\nS : Type u_5\ninst✝³ : NonUnitalNonAssocSemiring R\ninst✝² : NonUnitalNonAssocSemiring S\ninst✝¹ : FunLike F R S\ninst✝ : NonUnitalRingHomClass F R S\nf : F\nhf : Function.Bijective ⇑f\n⊢ Eq ⇑(RingEquiv.ofBijective f hf) ⇑f","decl":"@[simp]\ntheorem coe_ofBijective [NonUnitalRingHomClass F R S] (f : F) (hf : Function.Bijective f) :\n    (ofBijective f hf : R → S) = f :=\n  rfl\n\n"}
{"name":"RingEquiv.ofBijective_apply","module":"Mathlib.Algebra.Ring.Equiv","initialProofState":"F : Type u_1\nR : Type u_4\nS : Type u_5\ninst✝³ : NonUnitalNonAssocSemiring R\ninst✝² : NonUnitalNonAssocSemiring S\ninst✝¹ : FunLike F R S\ninst✝ : NonUnitalRingHomClass F R S\nf : F\nhf : Function.Bijective ⇑f\nx : R\n⊢ Eq ((RingEquiv.ofBijective f hf) x) (f x)","decl":"theorem ofBijective_apply [NonUnitalRingHomClass F R S] (f : F) (hf : Function.Bijective f)\n    (x : R) : ofBijective f hf x = f x :=\n  rfl\n\n"}
{"name":"RingEquiv.piUnique_symm_apply","module":"Mathlib.Algebra.Ring.Equiv","initialProofState":"ι : Type u_7\nR : ι → Type u_8\ninst✝¹ : Unique ι\ninst✝ : (i : ι) → NonUnitalNonAssocSemiring (R i)\n⊢ Eq (⇑(RingEquiv.piUnique R).symm) uniqueElim","decl":"/-- Product of a singleton family of (non-unital non-associative semi)rings is isomorphic\nto the only member of this family. -/\n@[simps! (config := .asFn)]\ndef piUnique {ι : Type*} (R : ι → Type*) [Unique ι] [∀ i, NonUnitalNonAssocSemiring (R i)] :\n    (∀ i, R i) ≃+* R default where\n  __ := Equiv.piUnique R\n  map_add' _ _ := rfl\n  map_mul' _ _ := rfl\n\n"}
{"name":"RingEquiv.piUnique_apply","module":"Mathlib.Algebra.Ring.Equiv","initialProofState":"ι : Type u_7\nR : ι → Type u_8\ninst✝¹ : Unique ι\ninst✝ : (i : ι) → NonUnitalNonAssocSemiring (R i)\n⊢ Eq ⇑(RingEquiv.piUnique R) fun f => f Inhabited.default","decl":"/-- Product of a singleton family of (non-unital non-associative semi)rings is isomorphic\nto the only member of this family. -/\n@[simps! (config := .asFn)]\ndef piUnique {ι : Type*} (R : ι → Type*) [Unique ι] [∀ i, NonUnitalNonAssocSemiring (R i)] :\n    (∀ i, R i) ≃+* R default where\n  __ := Equiv.piUnique R\n  map_add' _ _ := rfl\n  map_mul' _ _ := rfl\n\n"}
{"name":"RingEquiv.piCongrRight_apply","module":"Mathlib.Algebra.Ring.Equiv","initialProofState":"ι : Type u_7\nR : ι → Type u_8\nS : ι → Type u_9\ninst✝¹ : (i : ι) → NonUnitalNonAssocSemiring (R i)\ninst✝ : (i : ι) → NonUnitalNonAssocSemiring (S i)\ne : (i : ι) → RingEquiv (R i) (S i)\nx : (i : ι) → R i\nj : ι\n⊢ Eq ((RingEquiv.piCongrRight e) x j) ((e j) (x j))","decl":"/-- A family of ring isomorphisms `∀ j, (R j ≃+* S j)` generates a\nring isomorphisms between `∀ j, R j` and `∀ j, S j`.\n\nThis is the `RingEquiv` version of `Equiv.piCongrRight`, and the dependent version of\n`RingEquiv.arrowCongr`.\n-/\n@[simps apply]\ndef piCongrRight {ι : Type*} {R S : ι → Type*} [∀ i, NonUnitalNonAssocSemiring (R i)]\n    [∀ i, NonUnitalNonAssocSemiring (S i)] (e : ∀ i, R i ≃+* S i) : (∀ i, R i) ≃+* ∀ i, S i :=\n  { @MulEquiv.piCongrRight ι R S _ _ fun i => (e i).toMulEquiv,\n    @AddEquiv.piCongrRight ι R S _ _ fun i => (e i).toAddEquiv with\n    toFun := fun x j => e j (x j)\n    invFun := fun x j => (e j).symm (x j) }\n\n"}
{"name":"RingEquiv.piCongrRight_refl","module":"Mathlib.Algebra.Ring.Equiv","initialProofState":"ι : Type u_7\nR : ι → Type u_8\ninst✝ : (i : ι) → NonUnitalNonAssocSemiring (R i)\n⊢ Eq (RingEquiv.piCongrRight fun i => RingEquiv.refl (R i)) (RingEquiv.refl ((i : ι) → R i))","decl":"@[simp]\ntheorem piCongrRight_refl {ι : Type*} {R : ι → Type*} [∀ i, NonUnitalNonAssocSemiring (R i)] :\n    (piCongrRight fun i => RingEquiv.refl (R i)) = RingEquiv.refl _ :=\n  rfl\n\n"}
{"name":"RingEquiv.piCongrRight_symm","module":"Mathlib.Algebra.Ring.Equiv","initialProofState":"ι : Type u_7\nR : ι → Type u_8\nS : ι → Type u_9\ninst✝¹ : (i : ι) → NonUnitalNonAssocSemiring (R i)\ninst✝ : (i : ι) → NonUnitalNonAssocSemiring (S i)\ne : (i : ι) → RingEquiv (R i) (S i)\n⊢ Eq (RingEquiv.piCongrRight e).symm (RingEquiv.piCongrRight fun i => (e i).symm)","decl":"@[simp]\ntheorem piCongrRight_symm {ι : Type*} {R S : ι → Type*} [∀ i, NonUnitalNonAssocSemiring (R i)]\n    [∀ i, NonUnitalNonAssocSemiring (S i)] (e : ∀ i, R i ≃+* S i) :\n    (piCongrRight e).symm = piCongrRight fun i => (e i).symm :=\n  rfl\n\n"}
{"name":"RingEquiv.piCongrRight_trans","module":"Mathlib.Algebra.Ring.Equiv","initialProofState":"ι : Type u_7\nR : ι → Type u_8\nS : ι → Type u_9\nT : ι → Type u_10\ninst✝² : (i : ι) → NonUnitalNonAssocSemiring (R i)\ninst✝¹ : (i : ι) → NonUnitalNonAssocSemiring (S i)\ninst✝ : (i : ι) → NonUnitalNonAssocSemiring (T i)\ne : (i : ι) → RingEquiv (R i) (S i)\nf : (i : ι) → RingEquiv (S i) (T i)\n⊢ Eq ((RingEquiv.piCongrRight e).trans (RingEquiv.piCongrRight f)) (RingEquiv.piCongrRight fun i => (e i).trans (f i))","decl":"@[simp]\ntheorem piCongrRight_trans {ι : Type*} {R S T : ι → Type*}\n    [∀ i, NonUnitalNonAssocSemiring (R i)] [∀ i, NonUnitalNonAssocSemiring (S i)]\n    [∀ i, NonUnitalNonAssocSemiring (T i)] (e : ∀ i, R i ≃+* S i) (f : ∀ i, S i ≃+* T i) :\n    (piCongrRight e).trans (piCongrRight f) = piCongrRight fun i => (e i).trans (f i) :=\n  rfl\n\n"}
{"name":"RingEquiv.piCongrLeft'_apply","module":"Mathlib.Algebra.Ring.Equiv","initialProofState":"ι : Type u_7\nι' : Type u_8\nR : ι → Type u_9\ne : Equiv ι ι'\ninst✝ : (i : ι) → NonUnitalNonAssocSemiring (R i)\nf : (a : ι) → R a\nx : ι'\n⊢ Eq ((RingEquiv.piCongrLeft' R e) f x) (f (e.symm x))","decl":"/-- Transport dependent functions through an equivalence of the base space.\n\nThis is `Equiv.piCongrLeft'` as a `RingEquiv`. -/\n@[simps!]\ndef piCongrLeft' {ι ι' : Type*} (R : ι → Type*) (e : ι ≃ ι')\n    [∀ i, NonUnitalNonAssocSemiring (R i)] :\n    ((i : ι) → R i) ≃+* ((i : ι') → R (e.symm i)) where\n  toEquiv := Equiv.piCongrLeft' R e\n  map_mul' _ _ := rfl\n  map_add' _ _ := rfl\n\n"}
{"name":"RingEquiv.piCongrLeft'_symm_apply","module":"Mathlib.Algebra.Ring.Equiv","initialProofState":"ι : Type u_7\nι' : Type u_8\nR : ι → Type u_9\ne : Equiv ι ι'\ninst✝ : (i : ι) → NonUnitalNonAssocSemiring (R i)\nf : (b : ι') → R (e.symm b)\nx : ι\n⊢ Eq ((RingEquiv.piCongrLeft' R e).symm f x) (Eq.rec (f (e x)) ⋯)","decl":"/-- Transport dependent functions through an equivalence of the base space.\n\nThis is `Equiv.piCongrLeft'` as a `RingEquiv`. -/\n@[simps!]\ndef piCongrLeft' {ι ι' : Type*} (R : ι → Type*) (e : ι ≃ ι')\n    [∀ i, NonUnitalNonAssocSemiring (R i)] :\n    ((i : ι) → R i) ≃+* ((i : ι') → R (e.symm i)) where\n  toEquiv := Equiv.piCongrLeft' R e\n  map_mul' _ _ := rfl\n  map_add' _ _ := rfl\n\n"}
{"name":"RingEquiv.piCongrLeft'_symm","module":"Mathlib.Algebra.Ring.Equiv","initialProofState":"α : Type u_2\nβ : Type u_3\nR : Type u_7\ninst✝ : NonUnitalNonAssocSemiring R\ne : Equiv α β\n⊢ Eq (RingEquiv.piCongrLeft' (fun x => R) e).symm (RingEquiv.piCongrLeft' (fun i => R) e.symm)","decl":"@[simp]\ntheorem piCongrLeft'_symm {R : Type*} [NonUnitalNonAssocSemiring R] (e : α ≃ β) :\n    (RingEquiv.piCongrLeft' (fun _ => R) e).symm = RingEquiv.piCongrLeft' _ e.symm := by\n  simp only [piCongrLeft', RingEquiv.symm, MulEquiv.symm, Equiv.piCongrLeft'_symm]\n\n"}
{"name":"RingEquiv.piCongrLeft_symm_apply","module":"Mathlib.Algebra.Ring.Equiv","initialProofState":"ι : Type u_7\nι' : Type u_8\nS : ι' → Type u_9\ne : Equiv ι ι'\ninst✝ : (i : ι') → NonUnitalNonAssocSemiring (S i)\na✝ : (i : ι') → S i\ni : ι\n⊢ Eq ((RingEquiv.piCongrLeft S e).symm a✝ i) ((RingEquiv.piCongrLeft' S e.symm) a✝ i)","decl":"/-- Transport dependent functions through an equivalence of the base space.\n\nThis is `Equiv.piCongrLeft` as a `RingEquiv`. -/\n@[simps!]\ndef piCongrLeft {ι ι' : Type*} (S : ι' → Type*) (e : ι ≃ ι')\n    [∀ i, NonUnitalNonAssocSemiring (S i)] :\n    ((i : ι) → S (e i)) ≃+* ((i : ι') → S i) :=\n  (RingEquiv.piCongrLeft' S e.symm).symm\n\n"}
{"name":"RingEquiv.piCongrLeft_apply","module":"Mathlib.Algebra.Ring.Equiv","initialProofState":"ι : Type u_7\nι' : Type u_8\nS : ι' → Type u_9\ne : Equiv ι ι'\ninst✝ : (i : ι') → NonUnitalNonAssocSemiring (S i)\na✝ : (i : ι) → S (e.symm.symm i)\ni : ι'\n⊢ Eq ((RingEquiv.piCongrLeft S e) a✝ i) ((↑(RingEquiv.piCongrLeft' S e.symm)).symm a✝ i)","decl":"/-- Transport dependent functions through an equivalence of the base space.\n\nThis is `Equiv.piCongrLeft` as a `RingEquiv`. -/\n@[simps!]\ndef piCongrLeft {ι ι' : Type*} (S : ι' → Type*) (e : ι ≃ ι')\n    [∀ i, NonUnitalNonAssocSemiring (S i)] :\n    ((i : ι) → S (e i)) ≃+* ((i : ι') → S i) :=\n  (RingEquiv.piCongrLeft' S e.symm).symm\n\n"}
{"name":"RingEquiv.piEquivPiSubtypeProd_apply","module":"Mathlib.Algebra.Ring.Equiv","initialProofState":"ι : Type u_7\np : ι → Prop\ninst✝¹ : DecidablePred p\nY : ι → Type u_8\ninst✝ : (i : ι) → NonUnitalNonAssocSemiring (Y i)\nf : (i : ι) → Y i\n⊢ Eq ((RingEquiv.piEquivPiSubtypeProd p Y) f) { fst := fun x => f ↑x, snd := fun x => f ↑x }","decl":"/-- Splits the indices of ring `∀ (i : ι), Y i` along the predicate `p`. This is\n`Equiv.piEquivPiSubtypeProd` as a `RingEquiv`. -/\n@[simps!]\ndef piEquivPiSubtypeProd {ι : Type*} (p : ι → Prop) [DecidablePred p] (Y : ι → Type*)\n    [∀ i, NonUnitalNonAssocSemiring (Y i)] :\n    ((i : ι) → Y i) ≃+* ((i : { x : ι // p x }) → Y i) × ((i : { x : ι // ¬p x }) → Y i) where\n  toEquiv := Equiv.piEquivPiSubtypeProd p Y\n  map_mul' _ _ := rfl\n  map_add' _ _ := rfl\n\n"}
{"name":"RingEquiv.piEquivPiSubtypeProd_symm_apply","module":"Mathlib.Algebra.Ring.Equiv","initialProofState":"ι : Type u_7\np : ι → Prop\ninst✝¹ : DecidablePred p\nY : ι → Type u_8\ninst✝ : (i : ι) → NonUnitalNonAssocSemiring (Y i)\nf : Prod ((i : Subtype fun x => p x) → Y ↑i) ((i : Subtype fun x => Not (p x)) → Y ↑i)\nx : ι\n⊢ Eq ((RingEquiv.piEquivPiSubtypeProd p Y).symm f x) (dite (p x) (fun h => f.1 ⟨x, h⟩) fun h => f.2 ⟨x, h⟩)","decl":"/-- Splits the indices of ring `∀ (i : ι), Y i` along the predicate `p`. This is\n`Equiv.piEquivPiSubtypeProd` as a `RingEquiv`. -/\n@[simps!]\ndef piEquivPiSubtypeProd {ι : Type*} (p : ι → Prop) [DecidablePred p] (Y : ι → Type*)\n    [∀ i, NonUnitalNonAssocSemiring (Y i)] :\n    ((i : ι) → Y i) ≃+* ((i : { x : ι // p x }) → Y i) × ((i : { x : ι // ¬p x }) → Y i) where\n  toEquiv := Equiv.piEquivPiSubtypeProd p Y\n  map_mul' _ _ := rfl\n  map_add' _ _ := rfl\n\n"}
{"name":"RingEquiv.prodCongr_symm_apply","module":"Mathlib.Algebra.Ring.Equiv","initialProofState":"R : Type u_7\nR' : Type u_8\nS : Type u_9\nS' : Type u_10\ninst✝³ : NonUnitalNonAssocSemiring R\ninst✝² : NonUnitalNonAssocSemiring R'\ninst✝¹ : NonUnitalNonAssocSemiring S\ninst✝ : NonUnitalNonAssocSemiring S'\nf : RingEquiv R R'\ng : RingEquiv S S'\na✝ : Prod R' S'\n⊢ Eq ((f.prodCongr g).symm a✝) (Prod.map (⇑(↑f).symm) (⇑(↑g).symm) a✝)","decl":"/-- Product of ring equivalences. This is `Equiv.prodCongr` as a `RingEquiv`. -/\n@[simps!]\ndef prodCongr {R R' S S' : Type*} [NonUnitalNonAssocSemiring R] [NonUnitalNonAssocSemiring R']\n    [NonUnitalNonAssocSemiring S] [NonUnitalNonAssocSemiring S']\n    (f : R ≃+* R') (g : S ≃+* S') :\n    R × S ≃+* R' × S' where\n  toEquiv := Equiv.prodCongr f g\n  map_mul' _ _ := by\n    simp only [Equiv.toFun_as_coe, Equiv.prodCongr_apply, EquivLike.coe_coe,\n      Prod.map, Prod.fst_mul, map_mul, Prod.snd_mul, Prod.mk_mul_mk]\n  map_add' _ _ := by\n    simp only [Equiv.toFun_as_coe, Equiv.prodCongr_apply, EquivLike.coe_coe,\n      Prod.map, Prod.fst_add, map_add, Prod.snd_add, Prod.mk_add_mk]\n\n"}
{"name":"RingEquiv.prodCongr_apply","module":"Mathlib.Algebra.Ring.Equiv","initialProofState":"R : Type u_7\nR' : Type u_8\nS : Type u_9\nS' : Type u_10\ninst✝³ : NonUnitalNonAssocSemiring R\ninst✝² : NonUnitalNonAssocSemiring R'\ninst✝¹ : NonUnitalNonAssocSemiring S\ninst✝ : NonUnitalNonAssocSemiring S'\nf : RingEquiv R R'\ng : RingEquiv S S'\na✝ : Prod R S\n⊢ Eq ((f.prodCongr g) a✝) (Prod.map (⇑f) (⇑g) a✝)","decl":"/-- Product of ring equivalences. This is `Equiv.prodCongr` as a `RingEquiv`. -/\n@[simps!]\ndef prodCongr {R R' S S' : Type*} [NonUnitalNonAssocSemiring R] [NonUnitalNonAssocSemiring R']\n    [NonUnitalNonAssocSemiring S] [NonUnitalNonAssocSemiring S']\n    (f : R ≃+* R') (g : S ≃+* S') :\n    R × S ≃+* R' × S' where\n  toEquiv := Equiv.prodCongr f g\n  map_mul' _ _ := by\n    simp only [Equiv.toFun_as_coe, Equiv.prodCongr_apply, EquivLike.coe_coe,\n      Prod.map, Prod.fst_mul, map_mul, Prod.snd_mul, Prod.mk_mul_mk]\n  map_add' _ _ := by\n    simp only [Equiv.toFun_as_coe, Equiv.prodCongr_apply, EquivLike.coe_coe,\n      Prod.map, Prod.fst_add, map_add, Prod.snd_add, Prod.mk_add_mk]\n\n"}
{"name":"RingEquiv.coe_prodCongr","module":"Mathlib.Algebra.Ring.Equiv","initialProofState":"R : Type u_7\nR' : Type u_8\nS : Type u_9\nS' : Type u_10\ninst✝³ : NonUnitalNonAssocSemiring R\ninst✝² : NonUnitalNonAssocSemiring R'\ninst✝¹ : NonUnitalNonAssocSemiring S\ninst✝ : NonUnitalNonAssocSemiring S'\nf : RingEquiv R R'\ng : RingEquiv S S'\n⊢ Eq (⇑(f.prodCongr g)) (Prod.map ⇑f ⇑g)","decl":"@[simp]\ntheorem coe_prodCongr {R R' S S' : Type*} [NonUnitalNonAssocSemiring R]\n    [NonUnitalNonAssocSemiring R'] [NonUnitalNonAssocSemiring S] [NonUnitalNonAssocSemiring S']\n    (f : R ≃+* R') (g : S ≃+* S') :\n    ⇑(RingEquiv.prodCongr f g) = Prod.map f g :=\n  rfl\n\n"}
{"name":"RingEquiv.piOptionEquivProd_symm_apply","module":"Mathlib.Algebra.Ring.Equiv","initialProofState":"ι : Type u_7\nR : Option ι → Type u_8\ninst✝ : (i : Option ι) → NonUnitalNonAssocSemiring (R i)\nx : Prod (R Option.none) ((a : ι) → R (Option.some a))\na : Option ι\n⊢ Eq (RingEquiv.piOptionEquivProd.symm x a) (Option.rec x.1 (fun val => x.2 val) a)","decl":"/-- This is `Equiv.piOptionEquivProd` as a `RingEquiv`. -/\n@[simps!]\ndef piOptionEquivProd {ι : Type*} {R : Option ι → Type*} [Π i, NonUnitalNonAssocSemiring (R i)] :\n    (Π i, R i) ≃+* R none × (Π i, R (some i)) where\n  toEquiv := Equiv.piOptionEquivProd\n  map_add' _ _ := rfl\n  map_mul' _ _ := rfl\n\n"}
{"name":"RingEquiv.piOptionEquivProd_apply","module":"Mathlib.Algebra.Ring.Equiv","initialProofState":"ι : Type u_7\nR : Option ι → Type u_8\ninst✝ : (i : Option ι) → NonUnitalNonAssocSemiring (R i)\nf : (a : Option ι) → R a\n⊢ Eq (RingEquiv.piOptionEquivProd f) { fst := f Option.none, snd := fun a => f (Option.some a) }","decl":"/-- This is `Equiv.piOptionEquivProd` as a `RingEquiv`. -/\n@[simps!]\ndef piOptionEquivProd {ι : Type*} {R : Option ι → Type*} [Π i, NonUnitalNonAssocSemiring (R i)] :\n    (Π i, R i) ≃+* R none × (Π i, R (some i)) where\n  toEquiv := Equiv.piOptionEquivProd\n  map_add' _ _ := rfl\n  map_mul' _ _ := rfl\n\n"}
{"name":"RingEquiv.map_one","module":"Mathlib.Algebra.Ring.Equiv","initialProofState":"R : Type u_4\nS : Type u_5\ninst✝¹ : NonAssocSemiring R\ninst✝ : NonAssocSemiring S\nf : RingEquiv R S\n⊢ Eq (f 1) 1","decl":"/-- A ring isomorphism sends one to one. -/\nprotected theorem map_one : f 1 = 1 :=\n  map_one f\n\n"}
{"name":"RingEquiv.map_eq_one_iff","module":"Mathlib.Algebra.Ring.Equiv","initialProofState":"R : Type u_4\nS : Type u_5\ninst✝¹ : NonAssocSemiring R\ninst✝ : NonAssocSemiring S\nf : RingEquiv R S\nx : R\n⊢ Iff (Eq (f x) 1) (Eq x 1)","decl":"protected theorem map_eq_one_iff : f x = 1 ↔ x = 1 :=\n  EmbeddingLike.map_eq_one_iff\n\n"}
{"name":"RingEquiv.map_ne_one_iff","module":"Mathlib.Algebra.Ring.Equiv","initialProofState":"R : Type u_4\nS : Type u_5\ninst✝¹ : NonAssocSemiring R\ninst✝ : NonAssocSemiring S\nf : RingEquiv R S\nx : R\n⊢ Iff (Ne (f x) 1) (Ne x 1)","decl":"theorem map_ne_one_iff : f x ≠ 1 ↔ x ≠ 1 :=\n  EmbeddingLike.map_ne_one_iff\n\n"}
{"name":"RingEquiv.coe_monoidHom_refl","module":"Mathlib.Algebra.Ring.Equiv","initialProofState":"R : Type u_4\ninst✝ : NonAssocSemiring R\n⊢ Eq (↑(RingEquiv.refl R)) (MonoidHom.id R)","decl":"theorem coe_monoidHom_refl : (RingEquiv.refl R : R →* R) = MonoidHom.id R :=\n  rfl\n\n"}
{"name":"RingEquiv.coe_addMonoidHom_refl","module":"Mathlib.Algebra.Ring.Equiv","initialProofState":"R : Type u_4\ninst✝ : NonAssocSemiring R\n⊢ Eq (↑(RingEquiv.refl R)) (AddMonoidHom.id R)","decl":"@[simp]\ntheorem coe_addMonoidHom_refl : (RingEquiv.refl R : R →+ R) = AddMonoidHom.id R :=\n  rfl\n\n"}
{"name":"RingEquiv.coe_ringHom_refl","module":"Mathlib.Algebra.Ring.Equiv","initialProofState":"R : Type u_4\ninst✝ : NonAssocSemiring R\n⊢ Eq (↑(RingEquiv.refl R)) (RingHom.id R)","decl":"@[simp]\ntheorem coe_ringHom_refl : (RingEquiv.refl R : R →+* R) = RingHom.id R :=\n  rfl\n\n"}
{"name":"RingEquiv.coe_monoidHom_trans","module":"Mathlib.Algebra.Ring.Equiv","initialProofState":"R : Type u_4\nS : Type u_5\nS' : Type u_6\ninst✝² : NonAssocSemiring R\ninst✝¹ : NonAssocSemiring S\ninst✝ : NonAssocSemiring S'\ne₁ : RingEquiv R S\ne₂ : RingEquiv S S'\n⊢ Eq (↑(e₁.trans e₂)) ((↑e₂).comp ↑e₁)","decl":"@[simp]\ntheorem coe_monoidHom_trans [NonAssocSemiring S'] (e₁ : R ≃+* S) (e₂ : S ≃+* S') :\n    (e₁.trans e₂ : R →* S') = (e₂ : S →* S').comp ↑e₁ :=\n  rfl\n\n"}
{"name":"RingEquiv.coe_addMonoidHom_trans","module":"Mathlib.Algebra.Ring.Equiv","initialProofState":"R : Type u_4\nS : Type u_5\nS' : Type u_6\ninst✝² : NonAssocSemiring R\ninst✝¹ : NonAssocSemiring S\ninst✝ : NonAssocSemiring S'\ne₁ : RingEquiv R S\ne₂ : RingEquiv S S'\n⊢ Eq (↑(e₁.trans e₂)) ((↑e₂).comp ↑e₁)","decl":"@[simp]\ntheorem coe_addMonoidHom_trans [NonAssocSemiring S'] (e₁ : R ≃+* S) (e₂ : S ≃+* S') :\n    (e₁.trans e₂ : R →+ S') = (e₂ : S →+ S').comp ↑e₁ :=\n  rfl\n\n"}
{"name":"RingEquiv.coe_ringHom_trans","module":"Mathlib.Algebra.Ring.Equiv","initialProofState":"R : Type u_4\nS : Type u_5\nS' : Type u_6\ninst✝² : NonAssocSemiring R\ninst✝¹ : NonAssocSemiring S\ninst✝ : NonAssocSemiring S'\ne₁ : RingEquiv R S\ne₂ : RingEquiv S S'\n⊢ Eq (↑(e₁.trans e₂)) ((↑e₂).comp ↑e₁)","decl":"@[simp]\ntheorem coe_ringHom_trans [NonAssocSemiring S'] (e₁ : R ≃+* S) (e₂ : S ≃+* S') :\n    (e₁.trans e₂ : R →+* S') = (e₂ : S →+* S').comp ↑e₁ :=\n  rfl\n\n"}
{"name":"RingEquiv.comp_symm","module":"Mathlib.Algebra.Ring.Equiv","initialProofState":"R : Type u_4\nS : Type u_5\ninst✝¹ : NonAssocSemiring R\ninst✝ : NonAssocSemiring S\ne : RingEquiv R S\n⊢ Eq ((↑e).comp ↑e.symm) (RingHom.id S)","decl":"@[simp]\ntheorem comp_symm (e : R ≃+* S) : (e : R →+* S).comp (e.symm : S →+* R) = RingHom.id S :=\n  RingHom.ext e.apply_symm_apply\n\n"}
{"name":"RingEquiv.symm_comp","module":"Mathlib.Algebra.Ring.Equiv","initialProofState":"R : Type u_4\nS : Type u_5\ninst✝¹ : NonAssocSemiring R\ninst✝ : NonAssocSemiring S\ne : RingEquiv R S\n⊢ Eq ((↑e.symm).comp ↑e) (RingHom.id R)","decl":"@[simp]\ntheorem symm_comp (e : R ≃+* S) : (e.symm : S →+* R).comp (e : R →+* S) = RingHom.id R :=\n  RingHom.ext e.symm_apply_apply\n\n"}
{"name":"RingEquiv.map_neg","module":"Mathlib.Algebra.Ring.Equiv","initialProofState":"R : Type u_4\nS : Type u_5\ninst✝¹ : NonUnitalNonAssocRing R\ninst✝ : NonUnitalNonAssocRing S\nf : RingEquiv R S\nx : R\n⊢ Eq (f (Neg.neg x)) (Neg.neg (f x))","decl":"protected theorem map_neg : f (-x) = -f x :=\n  map_neg f x\n\n"}
{"name":"RingEquiv.map_sub","module":"Mathlib.Algebra.Ring.Equiv","initialProofState":"R : Type u_4\nS : Type u_5\ninst✝¹ : NonUnitalNonAssocRing R\ninst✝ : NonUnitalNonAssocRing S\nf : RingEquiv R S\nx y : R\n⊢ Eq (f (HSub.hSub x y)) (HSub.hSub (f x) (f y))","decl":"protected theorem map_sub : f (x - y) = f x - f y :=\n  map_sub f x y\n\n"}
{"name":"RingEquiv.map_neg_one","module":"Mathlib.Algebra.Ring.Equiv","initialProofState":"R : Type u_4\nS : Type u_5\ninst✝¹ : NonAssocRing R\ninst✝ : NonAssocRing S\nf : RingEquiv R S\n⊢ Eq (f (-1)) (-1)","decl":"@[simp]\ntheorem map_neg_one : f (-1) = -1 :=\n  f.map_one ▸ f.map_neg 1\n\n"}
{"name":"RingEquiv.map_eq_neg_one_iff","module":"Mathlib.Algebra.Ring.Equiv","initialProofState":"R : Type u_4\nS : Type u_5\ninst✝¹ : NonAssocRing R\ninst✝ : NonAssocRing S\nf : RingEquiv R S\nx : R\n⊢ Iff (Eq (f x) (-1)) (Eq x (-1))","decl":"theorem map_eq_neg_one_iff {x : R} : f x = -1 ↔ x = -1 := by\n  rw [← neg_eq_iff_eq_neg, ← neg_eq_iff_eq_neg, ← map_neg, RingEquiv.map_eq_one_iff]\n\n"}
{"name":"RingEquiv.toNonUnitalRingHom_injective","module":"Mathlib.Algebra.Ring.Equiv","initialProofState":"R : Type u_4\nS : Type u_5\ninst✝¹ : NonUnitalNonAssocSemiring R\ninst✝ : NonUnitalNonAssocSemiring S\n⊢ Function.Injective RingEquiv.toNonUnitalRingHom","decl":"theorem toNonUnitalRingHom_injective :\n    Function.Injective (toNonUnitalRingHom : R ≃+* S → R →ₙ+* S) := fun _ _ h =>\n  RingEquiv.ext (NonUnitalRingHom.ext_iff.1 h)\n\n"}
{"name":"RingEquiv.toNonUnitalRingHom_eq_coe","module":"Mathlib.Algebra.Ring.Equiv","initialProofState":"R : Type u_4\nS : Type u_5\ninst✝¹ : NonUnitalNonAssocSemiring R\ninst✝ : NonUnitalNonAssocSemiring S\nf : RingEquiv R S\n⊢ Eq f.toNonUnitalRingHom ↑f","decl":"theorem toNonUnitalRingHom_eq_coe (f : R ≃+* S) : f.toNonUnitalRingHom = ↑f :=\n  rfl\n\n"}
{"name":"RingEquiv.coe_toNonUnitalRingHom","module":"Mathlib.Algebra.Ring.Equiv","initialProofState":"R : Type u_4\nS : Type u_5\ninst✝¹ : NonUnitalNonAssocSemiring R\ninst✝ : NonUnitalNonAssocSemiring S\nf : RingEquiv R S\n⊢ Eq ⇑↑f ⇑f","decl":"@[simp, norm_cast]\ntheorem coe_toNonUnitalRingHom (f : R ≃+* S) : ⇑(f : R →ₙ+* S) = f :=\n  rfl\n\n"}
{"name":"RingEquiv.coe_nonUnitalRingHom_inj_iff","module":"Mathlib.Algebra.Ring.Equiv","initialProofState":"R : Type u_7\nS : Type u_8\ninst✝¹ : NonUnitalNonAssocSemiring R\ninst✝ : NonUnitalNonAssocSemiring S\nf g : RingEquiv R S\n⊢ Iff (Eq f g) (Eq ↑f ↑g)","decl":"theorem coe_nonUnitalRingHom_inj_iff {R S : Type*} [NonUnitalNonAssocSemiring R]\n    [NonUnitalNonAssocSemiring S] (f g : R ≃+* S) : f = g ↔ (f : R →ₙ+* S) = g :=\n  ⟨fun h => by rw [h], fun h => ext <| NonUnitalRingHom.ext_iff.mp h⟩\n\n"}
{"name":"RingEquiv.toNonUnitalRingHom_refl","module":"Mathlib.Algebra.Ring.Equiv","initialProofState":"R : Type u_4\ninst✝ : NonUnitalNonAssocSemiring R\n⊢ Eq (RingEquiv.refl R).toNonUnitalRingHom (NonUnitalRingHom.id R)","decl":"@[simp]\ntheorem toNonUnitalRingHom_refl :\n    (RingEquiv.refl R).toNonUnitalRingHom = NonUnitalRingHom.id R :=\n  rfl\n\n"}
{"name":"RingEquiv.toNonUnitalRingHom_apply_symm_toNonUnitalRingHom_apply","module":"Mathlib.Algebra.Ring.Equiv","initialProofState":"R : Type u_4\nS : Type u_5\ninst✝¹ : NonUnitalNonAssocSemiring R\ninst✝ : NonUnitalNonAssocSemiring S\ne : RingEquiv R S\ny : S\n⊢ Eq (e.toNonUnitalRingHom (e.symm.toNonUnitalRingHom y)) y","decl":"@[simp]\ntheorem toNonUnitalRingHom_apply_symm_toNonUnitalRingHom_apply (e : R ≃+* S) :\n    ∀ y : S, e.toNonUnitalRingHom (e.symm.toNonUnitalRingHom y) = y :=\n  e.toEquiv.apply_symm_apply\n\n"}
{"name":"RingEquiv.symm_toNonUnitalRingHom_apply_toNonUnitalRingHom_apply","module":"Mathlib.Algebra.Ring.Equiv","initialProofState":"R : Type u_4\nS : Type u_5\ninst✝¹ : NonUnitalNonAssocSemiring R\ninst✝ : NonUnitalNonAssocSemiring S\ne : RingEquiv R S\nx : R\n⊢ Eq (e.symm.toNonUnitalRingHom (e.toNonUnitalRingHom x)) x","decl":"@[simp]\ntheorem symm_toNonUnitalRingHom_apply_toNonUnitalRingHom_apply (e : R ≃+* S) :\n    ∀ x : R, e.symm.toNonUnitalRingHom (e.toNonUnitalRingHom x) = x :=\n  Equiv.symm_apply_apply e.toEquiv\n\n"}
{"name":"RingEquiv.toNonUnitalRingHom_trans","module":"Mathlib.Algebra.Ring.Equiv","initialProofState":"R : Type u_4\nS : Type u_5\nS' : Type u_6\ninst✝² : NonUnitalNonAssocSemiring R\ninst✝¹ : NonUnitalNonAssocSemiring S\ninst✝ : NonUnitalNonAssocSemiring S'\ne₁ : RingEquiv R S\ne₂ : RingEquiv S S'\n⊢ Eq (e₁.trans e₂).toNonUnitalRingHom (e₂.toNonUnitalRingHom.comp e₁.toNonUnitalRingHom)","decl":"@[simp]\ntheorem toNonUnitalRingHom_trans (e₁ : R ≃+* S) (e₂ : S ≃+* S') :\n    (e₁.trans e₂).toNonUnitalRingHom = e₂.toNonUnitalRingHom.comp e₁.toNonUnitalRingHom :=\n  rfl\n\n"}
{"name":"RingEquiv.toNonUnitalRingHomm_comp_symm_toNonUnitalRingHom","module":"Mathlib.Algebra.Ring.Equiv","initialProofState":"R : Type u_4\nS : Type u_5\ninst✝¹ : NonUnitalNonAssocSemiring R\ninst✝ : NonUnitalNonAssocSemiring S\ne : RingEquiv R S\n⊢ Eq (e.toNonUnitalRingHom.comp e.symm.toNonUnitalRingHom) (NonUnitalRingHom.id S)","decl":"@[simp]\ntheorem toNonUnitalRingHomm_comp_symm_toNonUnitalRingHom (e : R ≃+* S) :\n    e.toNonUnitalRingHom.comp e.symm.toNonUnitalRingHom = NonUnitalRingHom.id _ := by\n  ext\n  simp\n\n"}
{"name":"RingEquiv.symm_toNonUnitalRingHom_comp_toNonUnitalRingHom","module":"Mathlib.Algebra.Ring.Equiv","initialProofState":"R : Type u_4\nS : Type u_5\ninst✝¹ : NonUnitalNonAssocSemiring R\ninst✝ : NonUnitalNonAssocSemiring S\ne : RingEquiv R S\n⊢ Eq (e.symm.toNonUnitalRingHom.comp e.toNonUnitalRingHom) (NonUnitalRingHom.id R)","decl":"@[simp]\ntheorem symm_toNonUnitalRingHom_comp_toNonUnitalRingHom (e : R ≃+* S) :\n    e.symm.toNonUnitalRingHom.comp e.toNonUnitalRingHom = NonUnitalRingHom.id _ := by\n  ext\n  simp\n\n"}
{"name":"RingEquiv.toRingHom_injective","module":"Mathlib.Algebra.Ring.Equiv","initialProofState":"R : Type u_4\nS : Type u_5\ninst✝¹ : NonAssocSemiring R\ninst✝ : NonAssocSemiring S\n⊢ Function.Injective RingEquiv.toRingHom","decl":"theorem toRingHom_injective : Function.Injective (toRingHom : R ≃+* S → R →+* S) := fun _ _ h =>\n  RingEquiv.ext (RingHom.ext_iff.1 h)\n\n"}
{"name":"RingEquiv.toRingHom_eq_coe","module":"Mathlib.Algebra.Ring.Equiv","initialProofState":"R : Type u_4\nS : Type u_5\ninst✝¹ : NonAssocSemiring R\ninst✝ : NonAssocSemiring S\nf : RingEquiv R S\n⊢ Eq f.toRingHom ↑f","decl":"@[simp] theorem toRingHom_eq_coe (f : R ≃+* S) : f.toRingHom = ↑f :=\n  rfl\n\n"}
{"name":"RingEquiv.coe_toRingHom","module":"Mathlib.Algebra.Ring.Equiv","initialProofState":"R : Type u_4\nS : Type u_5\ninst✝¹ : NonAssocSemiring R\ninst✝ : NonAssocSemiring S\nf : RingEquiv R S\n⊢ Eq ⇑↑f ⇑f","decl":"@[simp, norm_cast]\ntheorem coe_toRingHom (f : R ≃+* S) : ⇑(f : R →+* S) = f :=\n  rfl\n\n"}
{"name":"RingEquiv.coe_ringHom_inj_iff","module":"Mathlib.Algebra.Ring.Equiv","initialProofState":"R : Type u_7\nS : Type u_8\ninst✝¹ : NonAssocSemiring R\ninst✝ : NonAssocSemiring S\nf g : RingEquiv R S\n⊢ Iff (Eq f g) (Eq ↑f ↑g)","decl":"theorem coe_ringHom_inj_iff {R S : Type*} [NonAssocSemiring R] [NonAssocSemiring S]\n    (f g : R ≃+* S) : f = g ↔ (f : R →+* S) = g :=\n  ⟨fun h => by rw [h], fun h => ext <| RingHom.ext_iff.mp h⟩\n\n"}
{"name":"RingEquiv.toNonUnitalRingHom_commutes","module":"Mathlib.Algebra.Ring.Equiv","initialProofState":"R : Type u_4\nS : Type u_5\ninst✝¹ : NonAssocSemiring R\ninst✝ : NonAssocSemiring S\nf : RingEquiv R S\n⊢ Eq ↑↑f ↑f","decl":"/-- The two paths coercion can take to a `NonUnitalRingEquiv` are equivalent -/\n@[simp, norm_cast]\ntheorem toNonUnitalRingHom_commutes (f : R ≃+* S) :\n    ((f : R →+* S) : R →ₙ+* S) = (f : R →ₙ+* S) :=\n  rfl\n\n"}
{"name":"RingEquiv.toAddMonoidMom_commutes","module":"Mathlib.Algebra.Ring.Equiv","initialProofState":"R : Type u_4\nS : Type u_5\ninst✝¹ : NonAssocSemiring R\ninst✝ : NonAssocSemiring S\nf : RingEquiv R S\n⊢ Eq (↑f).toAddMonoidHom (↑f).toAddMonoidHom","decl":"/-- The two paths coercion can take to an `AddMonoidHom` are equivalent -/\ntheorem toAddMonoidMom_commutes (f : R ≃+* S) :\n    (f : R →+* S).toAddMonoidHom = (f : R ≃+ S).toAddMonoidHom :=\n  rfl\n\n"}
{"name":"RingEquiv.toMonoidHom_commutes","module":"Mathlib.Algebra.Ring.Equiv","initialProofState":"R : Type u_4\nS : Type u_5\ninst✝¹ : NonAssocSemiring R\ninst✝ : NonAssocSemiring S\nf : RingEquiv R S\n⊢ Eq (↑↑f) (↑f).toMonoidHom","decl":"/-- The two paths coercion can take to a `MonoidHom` are equivalent -/\ntheorem toMonoidHom_commutes (f : R ≃+* S) :\n    (f : R →+* S).toMonoidHom = (f : R ≃* S).toMonoidHom :=\n  rfl\n\n"}
{"name":"RingEquiv.toEquiv_commutes","module":"Mathlib.Algebra.Ring.Equiv","initialProofState":"R : Type u_4\nS : Type u_5\ninst✝¹ : NonAssocSemiring R\ninst✝ : NonAssocSemiring S\nf : RingEquiv R S\n⊢ Eq (↑f).toEquiv (↑f).toEquiv","decl":"/-- The two paths coercion can take to an `Equiv` are equivalent -/\ntheorem toEquiv_commutes (f : R ≃+* S) : (f : R ≃+ S).toEquiv = (f : R ≃* S).toEquiv :=\n  rfl\n\n"}
{"name":"RingEquiv.toRingHom_refl","module":"Mathlib.Algebra.Ring.Equiv","initialProofState":"R : Type u_4\ninst✝ : NonAssocSemiring R\n⊢ Eq (RingEquiv.refl R).toRingHom (RingHom.id R)","decl":"@[simp]\ntheorem toRingHom_refl : (RingEquiv.refl R).toRingHom = RingHom.id R :=\n  rfl\n\n"}
{"name":"RingEquiv.toMonoidHom_refl","module":"Mathlib.Algebra.Ring.Equiv","initialProofState":"R : Type u_4\ninst✝ : NonAssocSemiring R\n⊢ Eq (RingEquiv.refl R).toMonoidHom (MonoidHom.id R)","decl":"@[simp]\ntheorem toMonoidHom_refl : (RingEquiv.refl R).toMonoidHom = MonoidHom.id R :=\n  rfl\n\n"}
{"name":"RingEquiv.toAddMonoidHom_refl","module":"Mathlib.Algebra.Ring.Equiv","initialProofState":"R : Type u_4\ninst✝ : NonAssocSemiring R\n⊢ Eq (RingEquiv.refl R).toAddMonoidHom (AddMonoidHom.id R)","decl":"@[simp]\ntheorem toAddMonoidHom_refl : (RingEquiv.refl R).toAddMonoidHom = AddMonoidHom.id R :=\n  rfl\n\n"}
{"name":"RingEquiv.toRingHom_apply_symm_toRingHom_apply","module":"Mathlib.Algebra.Ring.Equiv","initialProofState":"R : Type u_4\nS : Type u_5\ninst✝¹ : NonAssocSemiring R\ninst✝ : NonAssocSemiring S\ne : RingEquiv R S\ny : S\n⊢ Eq (e.toRingHom (e.symm.toRingHom y)) y","decl":"theorem toRingHom_apply_symm_toRingHom_apply (e : R ≃+* S) :\n    ∀ y : S, e.toRingHom (e.symm.toRingHom y) = y :=\n  e.toEquiv.apply_symm_apply\n\n"}
{"name":"RingEquiv.symm_toRingHom_apply_toRingHom_apply","module":"Mathlib.Algebra.Ring.Equiv","initialProofState":"R : Type u_4\nS : Type u_5\ninst✝¹ : NonAssocSemiring R\ninst✝ : NonAssocSemiring S\ne : RingEquiv R S\nx : R\n⊢ Eq (e.symm.toRingHom (e.toRingHom x)) x","decl":"theorem symm_toRingHom_apply_toRingHom_apply (e : R ≃+* S) :\n    ∀ x : R, e.symm.toRingHom (e.toRingHom x) = x :=\n  Equiv.symm_apply_apply e.toEquiv\n\n"}
{"name":"RingEquiv.toRingHom_trans","module":"Mathlib.Algebra.Ring.Equiv","initialProofState":"R : Type u_4\nS : Type u_5\nS' : Type u_6\ninst✝² : NonAssocSemiring R\ninst✝¹ : NonAssocSemiring S\ninst✝ : NonAssocSemiring S'\ne₁ : RingEquiv R S\ne₂ : RingEquiv S S'\n⊢ Eq (e₁.trans e₂).toRingHom (e₂.toRingHom.comp e₁.toRingHom)","decl":"@[simp]\ntheorem toRingHom_trans (e₁ : R ≃+* S) (e₂ : S ≃+* S') :\n    (e₁.trans e₂).toRingHom = e₂.toRingHom.comp e₁.toRingHom :=\n  rfl\n\n"}
{"name":"RingEquiv.toRingHom_comp_symm_toRingHom","module":"Mathlib.Algebra.Ring.Equiv","initialProofState":"R : Type u_4\nS : Type u_5\ninst✝¹ : NonAssocSemiring R\ninst✝ : NonAssocSemiring S\ne : RingEquiv R S\n⊢ Eq (e.toRingHom.comp e.symm.toRingHom) (RingHom.id S)","decl":"theorem toRingHom_comp_symm_toRingHom (e : R ≃+* S) :\n    e.toRingHom.comp e.symm.toRingHom = RingHom.id _ := by\n  ext\n  simp\n\n"}
{"name":"RingEquiv.symm_toRingHom_comp_toRingHom","module":"Mathlib.Algebra.Ring.Equiv","initialProofState":"R : Type u_4\nS : Type u_5\ninst✝¹ : NonAssocSemiring R\ninst✝ : NonAssocSemiring S\ne : RingEquiv R S\n⊢ Eq (e.symm.toRingHom.comp e.toRingHom) (RingHom.id R)","decl":"theorem symm_toRingHom_comp_toRingHom (e : R ≃+* S) :\n    e.symm.toRingHom.comp e.toRingHom = RingHom.id _ := by\n  ext\n  simp\n\n"}
{"name":"RingEquiv.ofHomInv'_apply","module":"Mathlib.Algebra.Ring.Equiv","initialProofState":"R : Type u_7\nS : Type u_8\nF : Type u_9\nG : Type u_10\ninst✝⁵ : NonUnitalNonAssocSemiring R\ninst✝⁴ : NonUnitalNonAssocSemiring S\ninst✝³ : FunLike F R S\ninst✝² : FunLike G S R\ninst✝¹ : NonUnitalRingHomClass F R S\ninst✝ : NonUnitalRingHomClass G S R\nhom : F\ninv : G\nhom_inv_id : Eq ((↑inv).comp ↑hom) (NonUnitalRingHom.id R)\ninv_hom_id : Eq ((↑hom).comp ↑inv) (NonUnitalRingHom.id S)\na : R\n⊢ Eq ((RingEquiv.ofHomInv' hom inv hom_inv_id inv_hom_id) a) (hom a)","decl":"/-- Construct an equivalence of rings from homomorphisms in both directions, which are inverses.\n-/\n@[simps]\ndef ofHomInv' {R S F G : Type*} [NonUnitalNonAssocSemiring R] [NonUnitalNonAssocSemiring S]\n    [FunLike F R S] [FunLike G S R]\n    [NonUnitalRingHomClass F R S] [NonUnitalRingHomClass G S R] (hom : F) (inv : G)\n    (hom_inv_id : (inv : S →ₙ+* R).comp (hom : R →ₙ+* S) = NonUnitalRingHom.id R)\n    (inv_hom_id : (hom : R →ₙ+* S).comp (inv : S →ₙ+* R) = NonUnitalRingHom.id S) :\n    R ≃+* S where\n  toFun := hom\n  invFun := inv\n  left_inv := DFunLike.congr_fun hom_inv_id\n  right_inv := DFunLike.congr_fun inv_hom_id\n  map_mul' := map_mul hom\n  map_add' := map_add hom\n\n"}
{"name":"RingEquiv.ofHomInv'_symm_apply","module":"Mathlib.Algebra.Ring.Equiv","initialProofState":"R : Type u_7\nS : Type u_8\nF : Type u_9\nG : Type u_10\ninst✝⁵ : NonUnitalNonAssocSemiring R\ninst✝⁴ : NonUnitalNonAssocSemiring S\ninst✝³ : FunLike F R S\ninst✝² : FunLike G S R\ninst✝¹ : NonUnitalRingHomClass F R S\ninst✝ : NonUnitalRingHomClass G S R\nhom : F\ninv : G\nhom_inv_id : Eq ((↑inv).comp ↑hom) (NonUnitalRingHom.id R)\ninv_hom_id : Eq ((↑hom).comp ↑inv) (NonUnitalRingHom.id S)\na : S\n⊢ Eq ((RingEquiv.ofHomInv' hom inv hom_inv_id inv_hom_id).symm a) (inv a)","decl":"/-- Construct an equivalence of rings from homomorphisms in both directions, which are inverses.\n-/\n@[simps]\ndef ofHomInv' {R S F G : Type*} [NonUnitalNonAssocSemiring R] [NonUnitalNonAssocSemiring S]\n    [FunLike F R S] [FunLike G S R]\n    [NonUnitalRingHomClass F R S] [NonUnitalRingHomClass G S R] (hom : F) (inv : G)\n    (hom_inv_id : (inv : S →ₙ+* R).comp (hom : R →ₙ+* S) = NonUnitalRingHom.id R)\n    (inv_hom_id : (hom : R →ₙ+* S).comp (inv : S →ₙ+* R) = NonUnitalRingHom.id S) :\n    R ≃+* S where\n  toFun := hom\n  invFun := inv\n  left_inv := DFunLike.congr_fun hom_inv_id\n  right_inv := DFunLike.congr_fun inv_hom_id\n  map_mul' := map_mul hom\n  map_add' := map_add hom\n\n"}
{"name":"RingEquiv.ofHomInv_apply","module":"Mathlib.Algebra.Ring.Equiv","initialProofState":"R : Type u_7\nS : Type u_8\nF : Type u_9\nG : Type u_10\ninst✝⁵ : NonAssocSemiring R\ninst✝⁴ : NonAssocSemiring S\ninst✝³ : FunLike F R S\ninst✝² : FunLike G S R\ninst✝¹ : RingHomClass F R S\ninst✝ : RingHomClass G S R\nhom : F\ninv : G\nhom_inv_id : Eq ((↑inv).comp ↑hom) (RingHom.id R)\ninv_hom_id : Eq ((↑hom).comp ↑inv) (RingHom.id S)\na : R\n⊢ Eq ((RingEquiv.ofHomInv hom inv hom_inv_id inv_hom_id) a) (hom a)","decl":"/--\nConstruct an equivalence of rings from unital homomorphisms in both directions, which are inverses.\n-/\n@[simps]\ndef ofHomInv {R S F G : Type*} [NonAssocSemiring R] [NonAssocSemiring S]\n    [FunLike F R S] [FunLike G S R] [RingHomClass F R S]\n    [RingHomClass G S R] (hom : F) (inv : G)\n    (hom_inv_id : (inv : S →+* R).comp (hom : R →+* S) = RingHom.id R)\n    (inv_hom_id : (hom : R →+* S).comp (inv : S →+* R) = RingHom.id S) :\n    R ≃+* S where\n  toFun := hom\n  invFun := inv\n  left_inv := DFunLike.congr_fun hom_inv_id\n  right_inv := DFunLike.congr_fun inv_hom_id\n  map_mul' := map_mul hom\n  map_add' := map_add hom\n\n"}
{"name":"RingEquiv.ofHomInv_symm_apply","module":"Mathlib.Algebra.Ring.Equiv","initialProofState":"R : Type u_7\nS : Type u_8\nF : Type u_9\nG : Type u_10\ninst✝⁵ : NonAssocSemiring R\ninst✝⁴ : NonAssocSemiring S\ninst✝³ : FunLike F R S\ninst✝² : FunLike G S R\ninst✝¹ : RingHomClass F R S\ninst✝ : RingHomClass G S R\nhom : F\ninv : G\nhom_inv_id : Eq ((↑inv).comp ↑hom) (RingHom.id R)\ninv_hom_id : Eq ((↑hom).comp ↑inv) (RingHom.id S)\na : S\n⊢ Eq ((RingEquiv.ofHomInv hom inv hom_inv_id inv_hom_id).symm a) (inv a)","decl":"/--\nConstruct an equivalence of rings from unital homomorphisms in both directions, which are inverses.\n-/\n@[simps]\ndef ofHomInv {R S F G : Type*} [NonAssocSemiring R] [NonAssocSemiring S]\n    [FunLike F R S] [FunLike G S R] [RingHomClass F R S]\n    [RingHomClass G S R] (hom : F) (inv : G)\n    (hom_inv_id : (inv : S →+* R).comp (hom : R →+* S) = RingHom.id R)\n    (inv_hom_id : (hom : R →+* S).comp (inv : S →+* R) = RingHom.id S) :\n    R ≃+* S where\n  toFun := hom\n  invFun := inv\n  left_inv := DFunLike.congr_fun hom_inv_id\n  right_inv := DFunLike.congr_fun inv_hom_id\n  map_mul' := map_mul hom\n  map_add' := map_add hom\n\n"}
{"name":"RingEquiv.map_pow","module":"Mathlib.Algebra.Ring.Equiv","initialProofState":"R : Type u_4\nS : Type u_5\ninst✝¹ : Semiring R\ninst✝ : Semiring S\nf : RingEquiv R S\na : R\nn : Nat\n⊢ Eq (f (HPow.hPow a n)) (HPow.hPow (f a) n)","decl":"protected theorem map_pow (f : R ≃+* S) (a) : ∀ n : ℕ, f (a ^ n) = f a ^ n :=\n  map_pow f a\n\n"}
{"name":"RingEquiv.self_trans_symm","module":"Mathlib.Algebra.Ring.Equiv","initialProofState":"R : Type u_4\nS : Type u_5\ninst✝³ : Add R\ninst✝² : Add S\ninst✝¹ : Mul R\ninst✝ : Mul S\ne : RingEquiv R S\n⊢ Eq (e.trans e.symm) (RingEquiv.refl R)","decl":"@[simp]\ntheorem self_trans_symm (e : R ≃+* S) : e.trans e.symm = RingEquiv.refl R :=\n  ext e.left_inv\n\n"}
{"name":"RingEquiv.symm_trans_self","module":"Mathlib.Algebra.Ring.Equiv","initialProofState":"R : Type u_4\nS : Type u_5\ninst✝³ : Add R\ninst✝² : Add S\ninst✝¹ : Mul R\ninst✝ : Mul S\ne : RingEquiv R S\n⊢ Eq (e.symm.trans e) (RingEquiv.refl S)","decl":"@[simp]\ntheorem symm_trans_self (e : R ≃+* S) : e.symm.trans e = RingEquiv.refl S :=\n  ext e.right_inv\n\n"}
{"name":"RingEquiv.ofRingHom_symm_apply","module":"Mathlib.Algebra.Ring.Equiv","initialProofState":"R : Type u_4\nS : Type u_5\ninst✝¹ : NonAssocSemiring R\ninst✝ : NonAssocSemiring S\nf : RingHom R S\ng : RingHom S R\nh₁ : Eq (f.comp g) (RingHom.id S)\nh₂ : Eq (g.comp f) (RingHom.id R)\na : S\n⊢ Eq ((RingEquiv.ofRingHom f g h₁ h₂).symm a) (g a)","decl":"/-- If a ring homomorphism has an inverse, it is a ring isomorphism. -/\n@[simps]\ndef ofRingHom (f : R →+* S) (g : S →+* R) (h₁ : f.comp g = RingHom.id S)\n    (h₂ : g.comp f = RingHom.id R) : R ≃+* S :=\n  { f with\n    toFun := f\n    invFun := g\n    left_inv := RingHom.ext_iff.1 h₂\n    right_inv := RingHom.ext_iff.1 h₁ }\n\n"}
{"name":"RingEquiv.ofRingHom_apply","module":"Mathlib.Algebra.Ring.Equiv","initialProofState":"R : Type u_4\nS : Type u_5\ninst✝¹ : NonAssocSemiring R\ninst✝ : NonAssocSemiring S\nf : RingHom R S\ng : RingHom S R\nh₁ : Eq (f.comp g) (RingHom.id S)\nh₂ : Eq (g.comp f) (RingHom.id R)\na : R\n⊢ Eq ((RingEquiv.ofRingHom f g h₁ h₂) a) (f a)","decl":"/-- If a ring homomorphism has an inverse, it is a ring isomorphism. -/\n@[simps]\ndef ofRingHom (f : R →+* S) (g : S →+* R) (h₁ : f.comp g = RingHom.id S)\n    (h₂ : g.comp f = RingHom.id R) : R ≃+* S :=\n  { f with\n    toFun := f\n    invFun := g\n    left_inv := RingHom.ext_iff.1 h₂\n    right_inv := RingHom.ext_iff.1 h₁ }\n\n"}
{"name":"RingEquiv.coe_ringHom_ofRingHom","module":"Mathlib.Algebra.Ring.Equiv","initialProofState":"R : Type u_4\nS : Type u_5\ninst✝¹ : NonAssocSemiring R\ninst✝ : NonAssocSemiring S\nf : RingHom R S\ng : RingHom S R\nh₁ : Eq (f.comp g) (RingHom.id S)\nh₂ : Eq (g.comp f) (RingHom.id R)\n⊢ Eq (↑(RingEquiv.ofRingHom f g h₁ h₂)) f","decl":"theorem coe_ringHom_ofRingHom (f : R →+* S) (g : S →+* R) (h₁ h₂) : ofRingHom f g h₁ h₂ = f :=\n  rfl\n\n"}
{"name":"RingEquiv.ofRingHom_coe_ringHom","module":"Mathlib.Algebra.Ring.Equiv","initialProofState":"R : Type u_4\nS : Type u_5\ninst✝¹ : NonAssocSemiring R\ninst✝ : NonAssocSemiring S\nf : RingEquiv R S\ng : RingHom S R\nh₁ : Eq ((↑f).comp g) (RingHom.id S)\nh₂ : Eq (g.comp ↑f) (RingHom.id R)\n⊢ Eq (RingEquiv.ofRingHom (↑f) g h₁ h₂) f","decl":"@[simp]\ntheorem ofRingHom_coe_ringHom (f : R ≃+* S) (g : S →+* R) (h₁ h₂) : ofRingHom (↑f) g h₁ h₂ = f :=\n  ext fun _ ↦ rfl\n\n"}
{"name":"RingEquiv.ofRingHom_symm","module":"Mathlib.Algebra.Ring.Equiv","initialProofState":"R : Type u_4\nS : Type u_5\ninst✝¹ : NonAssocSemiring R\ninst✝ : NonAssocSemiring S\nf : RingHom R S\ng : RingHom S R\nh₁ : Eq (f.comp g) (RingHom.id S)\nh₂ : Eq (g.comp f) (RingHom.id R)\n⊢ Eq (RingEquiv.ofRingHom f g h₁ h₂).symm (RingEquiv.ofRingHom g f h₂ h₁)","decl":"theorem ofRingHom_symm (f : R →+* S) (g : S →+* R) (h₁ h₂) :\n    (ofRingHom f g h₁ h₂).symm = ofRingHom g f h₂ h₁ :=\n  rfl\n\n"}
{"name":"MulEquiv.noZeroDivisors","module":"Mathlib.Algebra.Ring.Equiv","initialProofState":"A : Type u_7\nB : Type u_8\ninst✝² : MulZeroClass A\ninst✝¹ : MulZeroClass B\ninst✝ : NoZeroDivisors B\ne : MulEquiv A B\n⊢ NoZeroDivisors A","decl":"/-- If two rings are isomorphic, and the second doesn't have zero divisors,\nthen so does the first. -/\nprotected theorem noZeroDivisors {A : Type*} (B : Type*) [MulZeroClass A] [MulZeroClass B]\n    [NoZeroDivisors B] (e : A ≃* B) : NoZeroDivisors A :=\n  e.injective.noZeroDivisors e (map_zero e) (map_mul e)\n\n"}
{"name":"MulEquiv.isDomain","module":"Mathlib.Algebra.Ring.Equiv","initialProofState":"A : Type u_7\nB : Type u_8\ninst✝² : Semiring A\ninst✝¹ : Semiring B\ninst✝ : IsDomain B\ne : MulEquiv A B\n⊢ IsDomain A","decl":"/-- If two rings are isomorphic, and the second is a domain, then so is the first. -/\nprotected theorem isDomain {A : Type*} (B : Type*) [Semiring A] [Semiring B] [IsDomain B]\n    (e : A ≃* B) : IsDomain A :=\n  { e.injective.isLeftCancelMulZero e (map_zero e) (map_mul e),\n    e.injective.isRightCancelMulZero e (map_zero e) (map_mul e) with\n    exists_pair_ne := ⟨e.symm 0, e.symm 1, e.symm.injective.ne zero_ne_one⟩ }\n\n"}
