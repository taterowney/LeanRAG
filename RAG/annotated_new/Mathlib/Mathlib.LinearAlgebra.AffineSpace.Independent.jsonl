{"name":"affineIndependent_def","module":"Mathlib.LinearAlgebra.AffineSpace.Independent","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\nι : Type u_4\np : ι → P\n⊢ Iff (AffineIndependent k p) (∀ (s : Finset ι) (w : ι → k), Eq (s.sum fun i => w i) 0 → Eq ((s.weightedVSub p) w) 0 → ∀ (i : ι), Membership.mem s i → Eq (w i) 0)","decl":"/-- The definition of `AffineIndependent`. -/\ntheorem affineIndependent_def (p : ι → P) :\n    AffineIndependent k p ↔\n      ∀ (s : Finset ι) (w : ι → k),\n        ∑ i ∈ s, w i = 0 → s.weightedVSub p w = (0 : V) → ∀ i ∈ s, w i = 0 :=\n  Iff.rfl\n\n"}
{"name":"affineIndependent_of_subsingleton","module":"Mathlib.LinearAlgebra.AffineSpace.Independent","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝⁴ : Ring k\ninst✝³ : AddCommGroup V\ninst✝² : Module k V\ninst✝¹ : AddTorsor V P\nι : Type u_4\ninst✝ : Subsingleton ι\np : ι → P\n⊢ AffineIndependent k p","decl":"/-- A family with at most one point is affinely independent. -/\ntheorem affineIndependent_of_subsingleton [Subsingleton ι] (p : ι → P) : AffineIndependent k p :=\n  fun _ _ h _ i hi => Fintype.eq_of_subsingleton_of_sum_eq h i hi\n\n"}
{"name":"affineIndependent_iff_of_fintype","module":"Mathlib.LinearAlgebra.AffineSpace.Independent","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝⁴ : Ring k\ninst✝³ : AddCommGroup V\ninst✝² : Module k V\ninst✝¹ : AddTorsor V P\nι : Type u_4\ninst✝ : Fintype ι\np : ι → P\n⊢ Iff (AffineIndependent k p) (∀ (w : ι → k), Eq (Finset.univ.sum fun i => w i) 0 → Eq ((Finset.univ.weightedVSub p) w) 0 → ∀ (i : ι), Eq (w i) 0)","decl":"/-- A family indexed by a `Fintype` is affinely independent if and\nonly if no nontrivial weighted subtractions over `Finset.univ` (where\nthe sum of the weights is 0) are 0. -/\ntheorem affineIndependent_iff_of_fintype [Fintype ι] (p : ι → P) :\n    AffineIndependent k p ↔\n      ∀ w : ι → k, ∑ i, w i = 0 → Finset.univ.weightedVSub p w = (0 : V) → ∀ i, w i = 0 := by\n  constructor\n  · exact fun h w hw hs i => h Finset.univ w hw hs i (Finset.mem_univ _)\n  · intro h s w hw hs i hi\n    rw [Finset.weightedVSub_indicator_subset _ _ (Finset.subset_univ s)] at hs\n    rw [← Finset.sum_indicator_subset _ (Finset.subset_univ s)] at hw\n    replace h := h ((↑s : Set ι).indicator w) hw hs i\n    simpa [hi] using h\n\n"}
{"name":"affineIndependent_vadd","module":"Mathlib.LinearAlgebra.AffineSpace.Independent","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\nι : Type u_4\np : ι → P\nv : V\n⊢ Iff (AffineIndependent k (HVAdd.hVAdd v p)) (AffineIndependent k p)","decl":"@[simp] lemma affineIndependent_vadd {p : ι → P} {v : V} :\n    AffineIndependent k (v +ᵥ p) ↔ AffineIndependent k p := by\n  simp +contextual [AffineIndependent, weightedVSub_vadd]\n\n"}
{"name":"AffineIndependent.of_vadd","module":"Mathlib.LinearAlgebra.AffineSpace.Independent","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\nι : Type u_4\np : ι → P\nv : V\na✝ : AffineIndependent k (HVAdd.hVAdd v p)\n⊢ AffineIndependent k p","decl":"protected alias ⟨AffineIndependent.of_vadd, AffineIndependent.vadd⟩ := affineIndependent_vadd\n\n"}
{"name":"AffineIndependent.vadd","module":"Mathlib.LinearAlgebra.AffineSpace.Independent","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\nι : Type u_4\np : ι → P\nv : V\na✝ : AffineIndependent k p\n⊢ AffineIndependent k (HVAdd.hVAdd v p)","decl":"protected alias ⟨AffineIndependent.of_vadd, AffineIndependent.vadd⟩ := affineIndependent_vadd\n\n"}
{"name":"affineIndependent_smul","module":"Mathlib.LinearAlgebra.AffineSpace.Independent","initialProofState":"k : Type u_1\nV : Type u_2\ninst✝⁵ : Ring k\ninst✝⁴ : AddCommGroup V\ninst✝³ : Module k V\nι : Type u_4\nG : Type u_5\ninst✝² : Group G\ninst✝¹ : DistribMulAction G V\ninst✝ : SMulCommClass G k V\np : ι → V\na : G\n⊢ Iff (AffineIndependent k (HSMul.hSMul a p)) (AffineIndependent k p)","decl":"@[simp] lemma affineIndependent_smul {G : Type*} [Group G] [DistribMulAction G V]\n    [SMulCommClass G k V] {p : ι → V} {a : G} :\n    AffineIndependent k (a • p) ↔ AffineIndependent k p := by\n  simp +contextual [AffineIndependent, weightedVSub_smul,\n    ← smul_comm (α := V) a, ← smul_sum, smul_eq_zero_iff_eq]\n\n"}
{"name":"AffineIndependent.smul","module":"Mathlib.LinearAlgebra.AffineSpace.Independent","initialProofState":"k : Type u_1\nV : Type u_2\ninst✝⁵ : Ring k\ninst✝⁴ : AddCommGroup V\ninst✝³ : Module k V\nι : Type u_4\nG : Type u_5\ninst✝² : Group G\ninst✝¹ : DistribMulAction G V\ninst✝ : SMulCommClass G k V\np : ι → V\na : G\na✝ : AffineIndependent k p\n⊢ AffineIndependent k (HSMul.hSMul a p)","decl":"protected alias ⟨AffineIndependent.of_smul, AffineIndependent.smul⟩ := affineIndependent_smul\n\n"}
{"name":"AffineIndependent.of_smul","module":"Mathlib.LinearAlgebra.AffineSpace.Independent","initialProofState":"k : Type u_1\nV : Type u_2\ninst✝⁵ : Ring k\ninst✝⁴ : AddCommGroup V\ninst✝³ : Module k V\nι : Type u_4\nG : Type u_5\ninst✝² : Group G\ninst✝¹ : DistribMulAction G V\ninst✝ : SMulCommClass G k V\np : ι → V\na : G\na✝ : AffineIndependent k (HSMul.hSMul a p)\n⊢ AffineIndependent k p","decl":"protected alias ⟨AffineIndependent.of_smul, AffineIndependent.smul⟩ := affineIndependent_smul\n\n"}
{"name":"affineIndependent_iff_linearIndependent_vsub","module":"Mathlib.LinearAlgebra.AffineSpace.Independent","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\nι : Type u_4\np : ι → P\ni1 : ι\n⊢ Iff (AffineIndependent k p) (LinearIndependent k fun i => VSub.vsub (p ↑i) (p i1))","decl":"/-- A family is affinely independent if and only if the differences\nfrom a base point in that family are linearly independent. -/\ntheorem affineIndependent_iff_linearIndependent_vsub (p : ι → P) (i1 : ι) :\n    AffineIndependent k p ↔ LinearIndependent k fun i : { x // x ≠ i1 } => (p i -ᵥ p i1 : V) := by\n  classical\n    constructor\n    · intro h\n      rw [linearIndependent_iff']\n      intro s g hg i hi\n      set f : ι → k := fun x => if hx : x = i1 then -∑ y ∈ s, g y else g ⟨x, hx⟩ with hfdef\n      let s2 : Finset ι := insert i1 (s.map (Embedding.subtype _))\n      have hfg : ∀ x : { x // x ≠ i1 }, g x = f x := by\n        intro x\n        rw [hfdef]\n        dsimp only\n        rw [dif_neg x.property, Subtype.coe_eta]\n      rw [hfg]\n      have hf : ∑ ι ∈ s2, f ι = 0 := by\n        rw [Finset.sum_insert\n            (Finset.not_mem_map_subtype_of_not_property s (Classical.not_not.2 rfl)),\n          Finset.sum_subtype_map_embedding fun x _ => (hfg x).symm]\n        rw [hfdef]\n        dsimp only\n        rw [dif_pos rfl]\n        exact neg_add_cancel _\n      have hs2 : s2.weightedVSub p f = (0 : V) := by\n        set f2 : ι → V := fun x => f x • (p x -ᵥ p i1) with hf2def\n        set g2 : { x // x ≠ i1 } → V := fun x => g x • (p x -ᵥ p i1)\n        have hf2g2 : ∀ x : { x // x ≠ i1 }, f2 x = g2 x := by\n          simp only [g2, hf2def]\n          refine fun x => ?_\n          rw [hfg]\n        rw [Finset.weightedVSub_eq_weightedVSubOfPoint_of_sum_eq_zero s2 f p hf (p i1),\n          Finset.weightedVSubOfPoint_insert, Finset.weightedVSubOfPoint_apply,\n          Finset.sum_subtype_map_embedding fun x _ => hf2g2 x]\n        exact hg\n      exact h s2 f hf hs2 i (Finset.mem_insert_of_mem (Finset.mem_map.2 ⟨i, hi, rfl⟩))\n    · intro h\n      rw [linearIndependent_iff'] at h\n      intro s w hw hs i hi\n      rw [Finset.weightedVSub_eq_weightedVSubOfPoint_of_sum_eq_zero s w p hw (p i1), ←\n        s.weightedVSubOfPoint_erase w p i1, Finset.weightedVSubOfPoint_apply] at hs\n      let f : ι → V := fun i => w i • (p i -ᵥ p i1)\n      have hs2 : (∑ i ∈ (s.erase i1).subtype fun i => i ≠ i1, f i) = 0 := by\n        rw [← hs]\n        convert Finset.sum_subtype_of_mem f fun x => Finset.ne_of_mem_erase\n      have h2 := h ((s.erase i1).subtype fun i => i ≠ i1) (fun x => w x) hs2\n      simp_rw [Finset.mem_subtype] at h2\n      have h2b : ∀ i ∈ s, i ≠ i1 → w i = 0 := fun i his hi =>\n        h2 ⟨i, hi⟩ (Finset.mem_erase_of_ne_of_mem hi his)\n      exact Finset.eq_zero_of_sum_eq_zero hw h2b i hi\n\n"}
{"name":"affineIndependent_set_iff_linearIndependent_vsub","module":"Mathlib.LinearAlgebra.AffineSpace.Independent","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\ns : Set P\np₁ : P\nhp₁ : Membership.mem s p₁\n⊢ Iff (AffineIndependent k fun p => ↑p) (LinearIndependent k fun v => ↑v)","decl":"/-- A set is affinely independent if and only if the differences from\na base point in that set are linearly independent. -/\ntheorem affineIndependent_set_iff_linearIndependent_vsub {s : Set P} {p₁ : P} (hp₁ : p₁ ∈ s) :\n    AffineIndependent k (fun p => p : s → P) ↔\n      LinearIndependent k (fun v => v : (fun p => (p -ᵥ p₁ : V)) '' (s \\ {p₁}) → V) := by\n  rw [affineIndependent_iff_linearIndependent_vsub k (fun p => p : s → P) ⟨p₁, hp₁⟩]\n  constructor\n  · intro h\n    have hv : ∀ v : (fun p => (p -ᵥ p₁ : V)) '' (s \\ {p₁}), (v : V) +ᵥ p₁ ∈ s \\ {p₁} := fun v =>\n      (vsub_left_injective p₁).mem_set_image.1 ((vadd_vsub (v : V) p₁).symm ▸ v.property)\n    let f : (fun p : P => (p -ᵥ p₁ : V)) '' (s \\ {p₁}) → { x : s // x ≠ ⟨p₁, hp₁⟩ } := fun x =>\n      ⟨⟨(x : V) +ᵥ p₁, Set.mem_of_mem_diff (hv x)⟩, fun hx =>\n        Set.not_mem_of_mem_diff (hv x) (Subtype.ext_iff.1 hx)⟩\n    convert h.comp f fun x1 x2 hx =>\n        Subtype.ext (vadd_right_cancel p₁ (Subtype.ext_iff.1 (Subtype.ext_iff.1 hx)))\n    ext v\n    exact (vadd_vsub (v : V) p₁).symm\n  · intro h\n    let f : { x : s // x ≠ ⟨p₁, hp₁⟩ } → (fun p : P => (p -ᵥ p₁ : V)) '' (s \\ {p₁}) := fun x =>\n      ⟨((x : s) : P) -ᵥ p₁, ⟨x, ⟨⟨(x : s).property, fun hx => x.property (Subtype.ext hx)⟩, rfl⟩⟩⟩\n    convert h.comp f fun x1 x2 hx =>\n        Subtype.ext (Subtype.ext (vsub_left_cancel (Subtype.ext_iff.1 hx)))\n\n"}
{"name":"linearIndependent_set_iff_affineIndependent_vadd_union_singleton","module":"Mathlib.LinearAlgebra.AffineSpace.Independent","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\ns : Set V\nhs : ∀ (v : V), Membership.mem s v → Ne v 0\np₁ : P\n⊢ Iff (LinearIndependent k fun v => ↑v) (AffineIndependent k fun p => ↑p)","decl":"/-- A set of nonzero vectors is linearly independent if and only if,\ngiven a point `p₁`, the vectors added to `p₁` and `p₁` itself are\naffinely independent. -/\ntheorem linearIndependent_set_iff_affineIndependent_vadd_union_singleton {s : Set V}\n    (hs : ∀ v ∈ s, v ≠ (0 : V)) (p₁ : P) : LinearIndependent k (fun v => v : s → V) ↔\n    AffineIndependent k (fun p => p : ({p₁} ∪ (fun v => v +ᵥ p₁) '' s : Set P) → P) := by\n  rw [affineIndependent_set_iff_linearIndependent_vsub k\n      (Set.mem_union_left _ (Set.mem_singleton p₁))]\n  have h : (fun p => (p -ᵥ p₁ : V)) '' (({p₁} ∪ (fun v => v +ᵥ p₁) '' s) \\ {p₁}) = s := by\n    simp_rw [Set.union_diff_left, Set.image_diff (vsub_left_injective p₁), Set.image_image,\n      Set.image_singleton, vsub_self, vadd_vsub, Set.image_id']\n    exact Set.diff_singleton_eq_self fun h => hs 0 h rfl\n  rw [h]\n\n"}
{"name":"affineIndependent_iff_indicator_eq_of_affineCombination_eq","module":"Mathlib.LinearAlgebra.AffineSpace.Independent","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\nι : Type u_4\np : ι → P\n⊢ Iff (AffineIndependent k p) (∀ (s1 s2 : Finset ι) (w1 w2 : ι → k), Eq (s1.sum fun i => w1 i) 1 → Eq (s2.sum fun i => w2 i) 1 → Eq ((Finset.affineCombination k s1 p) w1) ((Finset.affineCombination k s2 p) w2) → Eq ((↑s1).indicator w1) ((↑s2).indicator w2))","decl":"/-- A family is affinely independent if and only if any affine\ncombinations (with sum of weights 1) that evaluate to the same point\nhave equal `Set.indicator`. -/\ntheorem affineIndependent_iff_indicator_eq_of_affineCombination_eq (p : ι → P) :\n    AffineIndependent k p ↔\n      ∀ (s1 s2 : Finset ι) (w1 w2 : ι → k),\n        ∑ i ∈ s1, w1 i = 1 →\n          ∑ i ∈ s2, w2 i = 1 →\n            s1.affineCombination k p w1 = s2.affineCombination k p w2 →\n              Set.indicator (↑s1) w1 = Set.indicator (↑s2) w2 := by\n  classical\n    constructor\n    · intro ha s1 s2 w1 w2 hw1 hw2 heq\n      ext i\n      by_cases hi : i ∈ s1 ∪ s2\n      · rw [← sub_eq_zero]\n        rw [← Finset.sum_indicator_subset w1 (s1.subset_union_left (s₂ := s2))] at hw1\n        rw [← Finset.sum_indicator_subset w2 (s1.subset_union_right)] at hw2\n        have hws : (∑ i ∈ s1 ∪ s2, (Set.indicator (↑s1) w1 - Set.indicator (↑s2) w2) i) = 0 := by\n          simp [hw1, hw2]\n        rw [Finset.affineCombination_indicator_subset w1 p (s1.subset_union_left (s₂ := s2)),\n          Finset.affineCombination_indicator_subset w2 p s1.subset_union_right,\n          ← @vsub_eq_zero_iff_eq V, Finset.affineCombination_vsub] at heq\n        exact ha (s1 ∪ s2) (Set.indicator (↑s1) w1 - Set.indicator (↑s2) w2) hws heq i hi\n      · rw [← Finset.mem_coe, Finset.coe_union] at hi\n        have h₁ : Set.indicator (↑s1) w1 i = 0 := by\n          simp only [Set.indicator, Finset.mem_coe, ite_eq_right_iff]\n          intro h\n          by_contra\n          exact (mt (@Set.mem_union_left _ i ↑s1 ↑s2) hi) h\n        have h₂ : Set.indicator (↑s2) w2 i = 0 := by\n          simp only [Set.indicator, Finset.mem_coe, ite_eq_right_iff]\n          intro h\n          by_contra\n          exact (mt (@Set.mem_union_right _ i ↑s2 ↑s1) hi) h\n        simp [h₁, h₂]\n    · intro ha s w hw hs i0 hi0\n      let w1 : ι → k := Function.update (Function.const ι 0) i0 1\n      have hw1 : ∑ i ∈ s, w1 i = 1 := by\n        rw [Finset.sum_update_of_mem hi0]\n        simp only [Finset.sum_const_zero, add_zero, const_apply]\n      have hw1s : s.affineCombination k p w1 = p i0 :=\n        s.affineCombination_of_eq_one_of_eq_zero w1 p hi0 (Function.update_self ..)\n          fun _ _ hne => Function.update_of_ne hne ..\n      let w2 := w + w1\n      have hw2 : ∑ i ∈ s, w2 i = 1 := by\n        simp_all only [w2, Pi.add_apply, Finset.sum_add_distrib, zero_add]\n      have hw2s : s.affineCombination k p w2 = p i0 := by\n        simp_all only [w2, ← Finset.weightedVSub_vadd_affineCombination, zero_vadd]\n      replace ha := ha s s w2 w1 hw2 hw1 (hw1s.symm ▸ hw2s)\n      have hws : w2 i0 - w1 i0 = 0 := by\n        rw [← Finset.mem_coe] at hi0\n        rw [← Set.indicator_of_mem hi0 w2, ← Set.indicator_of_mem hi0 w1, ha, sub_self]\n      simpa [w2] using hws\n\n"}
{"name":"affineIndependent_iff_eq_of_fintype_affineCombination_eq","module":"Mathlib.LinearAlgebra.AffineSpace.Independent","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝⁴ : Ring k\ninst✝³ : AddCommGroup V\ninst✝² : Module k V\ninst✝¹ : AddTorsor V P\nι : Type u_4\ninst✝ : Fintype ι\np : ι → P\n⊢ Iff (AffineIndependent k p) (∀ (w1 w2 : ι → k), Eq (Finset.univ.sum fun i => w1 i) 1 → Eq (Finset.univ.sum fun i => w2 i) 1 → Eq ((Finset.affineCombination k Finset.univ p) w1) ((Finset.affineCombination k Finset.univ p) w2) → Eq w1 w2)","decl":"/-- A finite family is affinely independent if and only if any affine\ncombinations (with sum of weights 1) that evaluate to the same point are equal. -/\ntheorem affineIndependent_iff_eq_of_fintype_affineCombination_eq [Fintype ι] (p : ι → P) :\n    AffineIndependent k p ↔ ∀ w1 w2 : ι → k, ∑ i, w1 i = 1 → ∑ i, w2 i = 1 →\n    Finset.univ.affineCombination k p w1 = Finset.univ.affineCombination k p w2 → w1 = w2 := by\n  rw [affineIndependent_iff_indicator_eq_of_affineCombination_eq]\n  constructor\n  · intro h w1 w2 hw1 hw2 hweq\n    simpa only [Set.indicator_univ, Finset.coe_univ] using h _ _ w1 w2 hw1 hw2 hweq\n  · intro h s1 s2 w1 w2 hw1 hw2 hweq\n    have hw1' : (∑ i, (s1 : Set ι).indicator w1 i) = 1 := by\n      rwa [Finset.sum_indicator_subset _ (Finset.subset_univ s1)]\n    have hw2' : (∑ i, (s2 : Set ι).indicator w2 i) = 1 := by\n      rwa [Finset.sum_indicator_subset _ (Finset.subset_univ s2)]\n    rw [Finset.affineCombination_indicator_subset w1 p (Finset.subset_univ s1),\n      Finset.affineCombination_indicator_subset w2 p (Finset.subset_univ s2)] at hweq\n    exact h _ _ hw1' hw2' hweq\n\n"}
{"name":"AffineIndependent.units_lineMap","module":"Mathlib.LinearAlgebra.AffineSpace.Independent","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\nι : Type u_4\np : ι → P\nhp : AffineIndependent k p\nj : ι\nw : ι → Units k\n⊢ AffineIndependent k fun i => (AffineMap.lineMap (p j) (p i)) ↑(w i)","decl":"/-- If we single out one member of an affine-independent family of points and affinely transport\nall others along the line joining them to this member, the resulting new family of points is affine-\nindependent.\n\nThis is the affine version of `LinearIndependent.units_smul`. -/\ntheorem AffineIndependent.units_lineMap {p : ι → P} (hp : AffineIndependent k p) (j : ι)\n    (w : ι → Units k) : AffineIndependent k fun i => AffineMap.lineMap (p j) (p i) (w i : k) := by\n  rw [affineIndependent_iff_linearIndependent_vsub k _ j] at hp ⊢\n  simp only [AffineMap.lineMap_vsub_left, AffineMap.coe_const, AffineMap.lineMap_same, const_apply]\n  exact hp.units_smul fun i => w i\n\n"}
{"name":"AffineIndependent.indicator_eq_of_affineCombination_eq","module":"Mathlib.LinearAlgebra.AffineSpace.Independent","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\nι : Type u_4\np : ι → P\nha : AffineIndependent k p\ns₁ s₂ : Finset ι\nw₁ w₂ : ι → k\nhw₁ : Eq (s₁.sum fun i => w₁ i) 1\nhw₂ : Eq (s₂.sum fun i => w₂ i) 1\nh : Eq ((Finset.affineCombination k s₁ p) w₁) ((Finset.affineCombination k s₂ p) w₂)\n⊢ Eq ((↑s₁).indicator w₁) ((↑s₂).indicator w₂)","decl":"theorem AffineIndependent.indicator_eq_of_affineCombination_eq {p : ι → P}\n    (ha : AffineIndependent k p) (s₁ s₂ : Finset ι) (w₁ w₂ : ι → k) (hw₁ : ∑ i ∈ s₁, w₁ i = 1)\n    (hw₂ : ∑ i ∈ s₂, w₂ i = 1) (h : s₁.affineCombination k p w₁ = s₂.affineCombination k p w₂) :\n    Set.indicator (↑s₁) w₁ = Set.indicator (↑s₂) w₂ :=\n  (affineIndependent_iff_indicator_eq_of_affineCombination_eq k p).1 ha s₁ s₂ w₁ w₂ hw₁ hw₂ h\n\n"}
{"name":"AffineIndependent.injective","module":"Mathlib.LinearAlgebra.AffineSpace.Independent","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝⁴ : Ring k\ninst✝³ : AddCommGroup V\ninst✝² : Module k V\ninst✝¹ : AddTorsor V P\nι : Type u_4\ninst✝ : Nontrivial k\np : ι → P\nha : AffineIndependent k p\n⊢ Function.Injective p","decl":"/-- An affinely independent family is injective, if the underlying\nring is nontrivial. -/\nprotected theorem AffineIndependent.injective [Nontrivial k] {p : ι → P}\n    (ha : AffineIndependent k p) : Function.Injective p := by\n  intro i j hij\n  rw [affineIndependent_iff_linearIndependent_vsub _ _ j] at ha\n  by_contra hij'\n  refine ha.ne_zero ⟨i, hij'⟩ (vsub_eq_zero_iff_eq.mpr ?_)\n  simp_all only [ne_eq]\n\n"}
{"name":"AffineIndependent.comp_embedding","module":"Mathlib.LinearAlgebra.AffineSpace.Independent","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\nι : Type u_4\nι2 : Type u_5\nf : Function.Embedding ι2 ι\np : ι → P\nha : AffineIndependent k p\n⊢ AffineIndependent k (Function.comp p ⇑f)","decl":"/-- If a family is affinely independent, so is any subfamily given by\ncomposition of an embedding into index type with the original\nfamily. -/\ntheorem AffineIndependent.comp_embedding {ι2 : Type*} (f : ι2 ↪ ι) {p : ι → P}\n    (ha : AffineIndependent k p) : AffineIndependent k (p ∘ f) := by\n  classical\n    intro fs w hw hs i0 hi0\n    let fs' := fs.map f\n    let w' i := if h : ∃ i2, f i2 = i then w h.choose else 0\n    have hw' : ∀ i2 : ι2, w' (f i2) = w i2 := by\n      intro i2\n      have h : ∃ i : ι2, f i = f i2 := ⟨i2, rfl⟩\n      have hs : h.choose = i2 := f.injective h.choose_spec\n      simp_rw [w', dif_pos h, hs]\n    have hw's : ∑ i ∈ fs', w' i = 0 := by\n      rw [← hw, Finset.sum_map]\n      simp [hw']\n    have hs' : fs'.weightedVSub p w' = (0 : V) := by\n      rw [← hs, Finset.weightedVSub_map]\n      congr with i\n      simp_all only [comp_apply, EmbeddingLike.apply_eq_iff_eq, exists_eq, dite_true]\n    rw [← ha fs' w' hw's hs' (f i0) ((Finset.mem_map' _).2 hi0), hw']\n\n"}
{"name":"AffineIndependent.subtype","module":"Mathlib.LinearAlgebra.AffineSpace.Independent","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\nι : Type u_4\np : ι → P\nha : AffineIndependent k p\ns : Set ι\n⊢ AffineIndependent k fun i => p ↑i","decl":"/-- If a family is affinely independent, so is any subfamily indexed\nby a subtype of the index type. -/\nprotected theorem AffineIndependent.subtype {p : ι → P} (ha : AffineIndependent k p) (s : Set ι) :\n    AffineIndependent k fun i : s => p i :=\n  ha.comp_embedding (Embedding.subtype _)\n\n"}
{"name":"AffineIndependent.range","module":"Mathlib.LinearAlgebra.AffineSpace.Independent","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\nι : Type u_4\np : ι → P\nha : AffineIndependent k p\n⊢ AffineIndependent k fun x => ↑x","decl":"/-- If an indexed family of points is affinely independent, so is the\ncorresponding set of points. -/\nprotected theorem AffineIndependent.range {p : ι → P} (ha : AffineIndependent k p) :\n    AffineIndependent k (fun x => x : Set.range p → P) := by\n  let f : Set.range p → ι := fun x => x.property.choose\n  have hf : ∀ x, p (f x) = x := fun x => x.property.choose_spec\n  let fe : Set.range p ↪ ι := ⟨f, fun x₁ x₂ he => Subtype.ext (hf x₁ ▸ hf x₂ ▸ he ▸ rfl)⟩\n  convert ha.comp_embedding fe\n  ext\n  simp [fe, hf]\n\n"}
{"name":"affineIndependent_equiv","module":"Mathlib.LinearAlgebra.AffineSpace.Independent","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\nι : Type u_4\nι' : Type u_5\ne : Equiv ι ι'\np : ι' → P\n⊢ Iff (AffineIndependent k (Function.comp p ⇑e)) (AffineIndependent k p)","decl":"theorem affineIndependent_equiv {ι' : Type*} (e : ι ≃ ι') {p : ι' → P} :\n    AffineIndependent k (p ∘ e) ↔ AffineIndependent k p := by\n  refine ⟨?_, AffineIndependent.comp_embedding e.toEmbedding⟩\n  intro h\n  have : p = p ∘ e ∘ e.symm.toEmbedding := by\n    ext\n    simp\n  rw [this]\n  exact h.comp_embedding e.symm.toEmbedding\n\n"}
{"name":"AffineIndependent.mono","module":"Mathlib.LinearAlgebra.AffineSpace.Independent","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\ns t : Set P\nha : AffineIndependent k fun x => ↑x\nhs : HasSubset.Subset s t\n⊢ AffineIndependent k fun x => ↑x","decl":"/-- If a set of points is affinely independent, so is any subset. -/\nprotected theorem AffineIndependent.mono {s t : Set P}\n    (ha : AffineIndependent k (fun x => x : t → P)) (hs : s ⊆ t) :\n    AffineIndependent k (fun x => x : s → P) :=\n  ha.comp_embedding (s.embeddingOfSubset t hs)\n\n"}
{"name":"AffineIndependent.of_set_of_injective","module":"Mathlib.LinearAlgebra.AffineSpace.Independent","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\nι : Type u_4\np : ι → P\nha : AffineIndependent k fun x => ↑x\nhi : Function.Injective p\n⊢ AffineIndependent k p","decl":"/-- If the range of an injective indexed family of points is affinely\nindependent, so is that family. -/\ntheorem AffineIndependent.of_set_of_injective {p : ι → P}\n    (ha : AffineIndependent k (fun x => x : Set.range p → P)) (hi : Function.Injective p) :\n    AffineIndependent k p :=\n  ha.comp_embedding\n    (⟨fun i => ⟨p i, Set.mem_range_self _⟩, fun _ _ h => hi (Subtype.mk_eq_mk.1 h)⟩ :\n      ι ↪ Set.range p)\n\n"}
{"name":"AffineIndependent.of_comp","module":"Mathlib.LinearAlgebra.AffineSpace.Independent","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝⁶ : Ring k\ninst✝⁵ : AddCommGroup V\ninst✝⁴ : Module k V\ninst✝³ : AddTorsor V P\nι : Type u_4\nV₂ : Type u_5\nP₂ : Type u_6\ninst✝² : AddCommGroup V₂\ninst✝¹ : Module k V₂\ninst✝ : AddTorsor V₂ P₂\np : ι → P\nf : AffineMap k P P₂\nhai : AffineIndependent k (Function.comp (⇑f) p)\n⊢ AffineIndependent k p","decl":"/-- If the image of a family of points in affine space under an affine transformation is affine-\nindependent, then the original family of points is also affine-independent. -/\ntheorem AffineIndependent.of_comp {p : ι → P} (f : P →ᵃ[k] P₂) (hai : AffineIndependent k (f ∘ p)) :\n    AffineIndependent k p := by\n  cases' isEmpty_or_nonempty ι with h h\n  · haveI := h\n    apply affineIndependent_of_subsingleton\n  obtain ⟨i⟩ := h\n  rw [affineIndependent_iff_linearIndependent_vsub k p i]\n  simp_rw [affineIndependent_iff_linearIndependent_vsub k (f ∘ p) i, Function.comp_apply, ←\n    f.linearMap_vsub] at hai\n  exact LinearIndependent.of_comp f.linear hai\n\n"}
{"name":"AffineIndependent.map'","module":"Mathlib.LinearAlgebra.AffineSpace.Independent","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝⁶ : Ring k\ninst✝⁵ : AddCommGroup V\ninst✝⁴ : Module k V\ninst✝³ : AddTorsor V P\nι : Type u_4\nV₂ : Type u_5\nP₂ : Type u_6\ninst✝² : AddCommGroup V₂\ninst✝¹ : Module k V₂\ninst✝ : AddTorsor V₂ P₂\np : ι → P\nhai : AffineIndependent k p\nf : AffineMap k P P₂\nhf : Function.Injective ⇑f\n⊢ AffineIndependent k (Function.comp (⇑f) p)","decl":"/-- The image of a family of points in affine space, under an injective affine transformation, is\naffine-independent. -/\ntheorem AffineIndependent.map' {p : ι → P} (hai : AffineIndependent k p) (f : P →ᵃ[k] P₂)\n    (hf : Function.Injective f) : AffineIndependent k (f ∘ p) := by\n  cases' isEmpty_or_nonempty ι with h h\n  · haveI := h\n    apply affineIndependent_of_subsingleton\n  obtain ⟨i⟩ := h\n  rw [affineIndependent_iff_linearIndependent_vsub k p i] at hai\n  simp_rw [affineIndependent_iff_linearIndependent_vsub k (f ∘ p) i, Function.comp_apply, ←\n    f.linearMap_vsub]\n  have hf' : LinearMap.ker f.linear = ⊥ := by rwa [LinearMap.ker_eq_bot, f.linear_injective_iff]\n  exact LinearIndependent.map' hai f.linear hf'\n\n"}
{"name":"AffineMap.affineIndependent_iff","module":"Mathlib.LinearAlgebra.AffineSpace.Independent","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝⁶ : Ring k\ninst✝⁵ : AddCommGroup V\ninst✝⁴ : Module k V\ninst✝³ : AddTorsor V P\nι : Type u_4\nV₂ : Type u_5\nP₂ : Type u_6\ninst✝² : AddCommGroup V₂\ninst✝¹ : Module k V₂\ninst✝ : AddTorsor V₂ P₂\np : ι → P\nf : AffineMap k P P₂\nhf : Function.Injective ⇑f\n⊢ Iff (AffineIndependent k (Function.comp (⇑f) p)) (AffineIndependent k p)","decl":"/-- Injective affine maps preserve affine independence. -/\ntheorem AffineMap.affineIndependent_iff {p : ι → P} (f : P →ᵃ[k] P₂) (hf : Function.Injective f) :\n    AffineIndependent k (f ∘ p) ↔ AffineIndependent k p :=\n  ⟨AffineIndependent.of_comp f, fun hai => AffineIndependent.map' hai f hf⟩\n\n"}
{"name":"AffineEquiv.affineIndependent_iff","module":"Mathlib.LinearAlgebra.AffineSpace.Independent","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝⁶ : Ring k\ninst✝⁵ : AddCommGroup V\ninst✝⁴ : Module k V\ninst✝³ : AddTorsor V P\nι : Type u_4\nV₂ : Type u_5\nP₂ : Type u_6\ninst✝² : AddCommGroup V₂\ninst✝¹ : Module k V₂\ninst✝ : AddTorsor V₂ P₂\np : ι → P\ne : AffineEquiv k P P₂\n⊢ Iff (AffineIndependent k (Function.comp (⇑e) p)) (AffineIndependent k p)","decl":"/-- Affine equivalences preserve affine independence of families of points. -/\ntheorem AffineEquiv.affineIndependent_iff {p : ι → P} (e : P ≃ᵃ[k] P₂) :\n    AffineIndependent k (e ∘ p) ↔ AffineIndependent k p :=\n  e.toAffineMap.affineIndependent_iff e.toEquiv.injective\n\n"}
{"name":"AffineEquiv.affineIndependent_set_of_eq_iff","module":"Mathlib.LinearAlgebra.AffineSpace.Independent","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝⁶ : Ring k\ninst✝⁵ : AddCommGroup V\ninst✝⁴ : Module k V\ninst✝³ : AddTorsor V P\nV₂ : Type u_5\nP₂ : Type u_6\ninst✝² : AddCommGroup V₂\ninst✝¹ : Module k V₂\ninst✝ : AddTorsor V₂ P₂\ns : Set P\ne : AffineEquiv k P P₂\n⊢ Iff (AffineIndependent k Subtype.val) (AffineIndependent k Subtype.val)","decl":"/-- Affine equivalences preserve affine independence of subsets. -/\ntheorem AffineEquiv.affineIndependent_set_of_eq_iff {s : Set P} (e : P ≃ᵃ[k] P₂) :\n    AffineIndependent k ((↑) : e '' s → P₂) ↔ AffineIndependent k ((↑) : s → P) := by\n  have : e ∘ ((↑) : s → P) = ((↑) : e '' s → P₂) ∘ (e : P ≃ P₂).image s := rfl\n  -- This used to be `rw`, but we need `erw` after https://github.com/leanprover/lean4/pull/2644\n  erw [← e.affineIndependent_iff, this, affineIndependent_equiv]\n\n"}
{"name":"AffineIndependent.exists_mem_inter_of_exists_mem_inter_affineSpan","module":"Mathlib.LinearAlgebra.AffineSpace.Independent","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝⁴ : Ring k\ninst✝³ : AddCommGroup V\ninst✝² : Module k V\ninst✝¹ : AddTorsor V P\nι : Type u_4\ninst✝ : Nontrivial k\np : ι → P\nha : AffineIndependent k p\ns1 s2 : Set ι\np0 : P\nhp0s1 : Membership.mem (affineSpan k (Set.image p s1)) p0\nhp0s2 : Membership.mem (affineSpan k (Set.image p s2)) p0\n⊢ Exists fun i => Membership.mem (Inter.inter s1 s2) i","decl":"/-- If a family is affinely independent, and the spans of points\nindexed by two subsets of the index type have a point in common, those\nsubsets of the index type have an element in common, if the underlying\nring is nontrivial. -/\ntheorem AffineIndependent.exists_mem_inter_of_exists_mem_inter_affineSpan [Nontrivial k] {p : ι → P}\n    (ha : AffineIndependent k p) {s1 s2 : Set ι} {p0 : P} (hp0s1 : p0 ∈ affineSpan k (p '' s1))\n    (hp0s2 : p0 ∈ affineSpan k (p '' s2)) : ∃ i : ι, i ∈ s1 ∩ s2 := by\n  rw [Set.image_eq_range] at hp0s1 hp0s2\n  rw [mem_affineSpan_iff_eq_affineCombination, ←\n    Finset.eq_affineCombination_subset_iff_eq_affineCombination_subtype] at hp0s1 hp0s2\n  rcases hp0s1 with ⟨fs1, hfs1, w1, hw1, hp0s1⟩\n  rcases hp0s2 with ⟨fs2, hfs2, w2, hw2, hp0s2⟩\n  rw [affineIndependent_iff_indicator_eq_of_affineCombination_eq] at ha\n  replace ha := ha fs1 fs2 w1 w2 hw1 hw2 (hp0s1 ▸ hp0s2)\n  have hnz : ∑ i ∈ fs1, w1 i ≠ 0 := hw1.symm ▸ one_ne_zero\n  rcases Finset.exists_ne_zero_of_sum_ne_zero hnz with ⟨i, hifs1, hinz⟩\n  simp_rw [← Set.indicator_of_mem (Finset.mem_coe.2 hifs1) w1, ha] at hinz\n  use i, hfs1 hifs1\n  exact hfs2 (Set.mem_of_indicator_ne_zero hinz)\n\n"}
{"name":"AffineIndependent.affineSpan_disjoint_of_disjoint","module":"Mathlib.LinearAlgebra.AffineSpace.Independent","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝⁴ : Ring k\ninst✝³ : AddCommGroup V\ninst✝² : Module k V\ninst✝¹ : AddTorsor V P\nι : Type u_4\ninst✝ : Nontrivial k\np : ι → P\nha : AffineIndependent k p\ns1 s2 : Set ι\nhd : Disjoint s1 s2\n⊢ Disjoint ↑(affineSpan k (Set.image p s1)) ↑(affineSpan k (Set.image p s2))","decl":"/-- If a family is affinely independent, the spans of points indexed\nby disjoint subsets of the index type are disjoint, if the underlying\nring is nontrivial. -/\ntheorem AffineIndependent.affineSpan_disjoint_of_disjoint [Nontrivial k] {p : ι → P}\n    (ha : AffineIndependent k p) {s1 s2 : Set ι} (hd : Disjoint s1 s2) :\n    Disjoint (affineSpan k (p '' s1) : Set P) (affineSpan k (p '' s2)) := by\n  refine Set.disjoint_left.2 fun p0 hp0s1 hp0s2 => ?_\n  cases' ha.exists_mem_inter_of_exists_mem_inter_affineSpan hp0s1 hp0s2 with i hi\n  exact Set.disjoint_iff.1 hd hi\n\n"}
{"name":"AffineIndependent.mem_affineSpan_iff","module":"Mathlib.LinearAlgebra.AffineSpace.Independent","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝⁴ : Ring k\ninst✝³ : AddCommGroup V\ninst✝² : Module k V\ninst✝¹ : AddTorsor V P\nι : Type u_4\ninst✝ : Nontrivial k\np : ι → P\nha : AffineIndependent k p\ni : ι\ns : Set ι\n⊢ Iff (Membership.mem (affineSpan k (Set.image p s)) (p i)) (Membership.mem s i)","decl":"/-- If a family is affinely independent, a point in the family is in\nthe span of some of the points given by a subset of the index type if\nand only if that point's index is in the subset, if the underlying\nring is nontrivial. -/\n@[simp]\nprotected theorem AffineIndependent.mem_affineSpan_iff [Nontrivial k] {p : ι → P}\n    (ha : AffineIndependent k p) (i : ι) (s : Set ι) : p i ∈ affineSpan k (p '' s) ↔ i ∈ s := by\n  constructor\n  · intro hs\n    have h :=\n      AffineIndependent.exists_mem_inter_of_exists_mem_inter_affineSpan ha hs\n        (mem_affineSpan k (Set.mem_image_of_mem _ (Set.mem_singleton _)))\n    rwa [← Set.nonempty_def, Set.inter_singleton_nonempty] at h\n  · exact fun h => mem_affineSpan k (Set.mem_image_of_mem p h)\n\n"}
{"name":"AffineIndependent.not_mem_affineSpan_diff","module":"Mathlib.LinearAlgebra.AffineSpace.Independent","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝⁴ : Ring k\ninst✝³ : AddCommGroup V\ninst✝² : Module k V\ninst✝¹ : AddTorsor V P\nι : Type u_4\ninst✝ : Nontrivial k\np : ι → P\nha : AffineIndependent k p\ni : ι\ns : Set ι\n⊢ Not (Membership.mem (affineSpan k (Set.image p (SDiff.sdiff s (Singleton.singleton i)))) (p i))","decl":"/-- If a family is affinely independent, a point in the family is not\nin the affine span of the other points, if the underlying ring is\nnontrivial. -/\ntheorem AffineIndependent.not_mem_affineSpan_diff [Nontrivial k] {p : ι → P}\n    (ha : AffineIndependent k p) (i : ι) (s : Set ι) : p i ∉ affineSpan k (p '' (s \\ {i})) := by\n  simp [ha]\n\n"}
{"name":"exists_nontrivial_relation_sum_zero_of_not_affine_ind","module":"Mathlib.LinearAlgebra.AffineSpace.Independent","initialProofState":"k : Type u_1\nV : Type u_2\ninst✝² : Ring k\ninst✝¹ : AddCommGroup V\ninst✝ : Module k V\nt : Finset V\nh : Not (AffineIndependent k Subtype.val)\n⊢ Exists fun f => And (Eq (t.sum fun e => HSMul.hSMul (f e) e) 0) (And (Eq (t.sum fun e => f e) 0) (Exists fun x => And (Membership.mem t x) (Ne (f x) 0)))","decl":"theorem exists_nontrivial_relation_sum_zero_of_not_affine_ind {t : Finset V}\n    (h : ¬AffineIndependent k ((↑) : t → V)) :\n    ∃ f : V → k, ∑ e ∈ t, f e • e = 0 ∧ ∑ e ∈ t, f e = 0 ∧ ∃ x ∈ t, f x ≠ 0 := by\n  classical\n    rw [affineIndependent_iff_of_fintype] at h\n    simp only [exists_prop, not_forall] at h\n    obtain ⟨w, hw, hwt, i, hi⟩ := h\n    simp only [Finset.weightedVSub_eq_weightedVSubOfPoint_of_sum_eq_zero _ w ((↑) : t → V) hw 0,\n      vsub_eq_sub, Finset.weightedVSubOfPoint_apply, sub_zero] at hwt\n    let f : ∀ x : V, x ∈ t → k := fun x hx => w ⟨x, hx⟩\n    refine ⟨fun x => if hx : x ∈ t then f x hx else (0 : k), ?_, ?_, by use i; simp [f, hi]⟩\n    on_goal 1 =>\n      suffices (∑ e ∈ t, dite (e ∈ t) (fun hx => f e hx • e) fun _ => 0) = 0 by\n        convert this\n        rename V => x\n        by_cases hx : x ∈ t <;> simp [hx]\n    all_goals\n      simp only [f, Finset.sum_dite_of_true fun _ h => h, Finset.mk_coe, hwt, hw]\n\n"}
{"name":"affineIndependent_iff","module":"Mathlib.LinearAlgebra.AffineSpace.Independent","initialProofState":"k : Type u_1\nV : Type u_2\ninst✝² : Ring k\ninst✝¹ : AddCommGroup V\ninst✝ : Module k V\nι : Type u_5\np : ι → V\n⊢ Iff (AffineIndependent k p) (∀ (s : Finset ι) (w : ι → k), Eq (s.sum w) 0 → Eq (s.sum fun e => HSMul.hSMul (w e) (p e)) 0 → ∀ (e : ι), Membership.mem s e → Eq (w e) 0)","decl":"/-- Viewing a module as an affine space modelled on itself, we can characterise affine independence\nin terms of linear combinations. -/\ntheorem affineIndependent_iff {ι} {p : ι → V} :\n    AffineIndependent k p ↔\n      ∀ (s : Finset ι) (w : ι → k), s.sum w = 0 → ∑ e ∈ s, w e • p e = 0 → ∀ e ∈ s, w e = 0 :=\n  forall₃_congr fun s w hw => by simp [s.weightedVSub_eq_linear_combination hw]\n\n"}
{"name":"AffineIndependent.eq_zero_of_sum_eq_zero","module":"Mathlib.LinearAlgebra.AffineSpace.Independent","initialProofState":"k : Type u_1\nV : Type u_2\ninst✝² : Ring k\ninst✝¹ : AddCommGroup V\ninst✝ : Module k V\nι : Type u_4\ns : Finset ι\nw : ι → k\np : ι → V\nhp : AffineIndependent k p\nhw₀ : Eq (s.sum fun i => w i) 0\nhw₁ : Eq (s.sum fun i => HSMul.hSMul (w i) (p i)) 0\ni : ι\na✝ : Membership.mem s i\n⊢ Eq (w i) 0","decl":"lemma AffineIndependent.eq_zero_of_sum_eq_zero (hp : AffineIndependent k p)\n    (hw₀ : ∑ i ∈ s, w i = 0) (hw₁ : ∑ i ∈ s, w i • p i = 0) : ∀ i ∈ s, w i = 0 :=\n  affineIndependent_iff.1 hp _ _ hw₀ hw₁\n\n"}
{"name":"AffineIndependent.eq_of_sum_eq_sum","module":"Mathlib.LinearAlgebra.AffineSpace.Independent","initialProofState":"k : Type u_1\nV : Type u_2\ninst✝² : Ring k\ninst✝¹ : AddCommGroup V\ninst✝ : Module k V\nι : Type u_4\ns : Finset ι\nw₁ w₂ : ι → k\np : ι → V\nhp : AffineIndependent k p\nhw : Eq (s.sum fun i => w₁ i) (s.sum fun i => w₂ i)\nhwp : Eq (s.sum fun i => HSMul.hSMul (w₁ i) (p i)) (s.sum fun i => HSMul.hSMul (w₂ i) (p i))\ni : ι\na✝ : Membership.mem s i\n⊢ Eq (w₁ i) (w₂ i)","decl":"lemma AffineIndependent.eq_of_sum_eq_sum (hp : AffineIndependent k p)\n    (hw : ∑ i ∈ s, w₁ i = ∑ i ∈ s, w₂ i) (hwp : ∑ i ∈ s, w₁ i • p i = ∑ i ∈ s, w₂ i • p i) :\n    ∀ i ∈ s, w₁ i = w₂ i := by\n  refine fun i hi ↦ sub_eq_zero.1 (hp.eq_zero_of_sum_eq_zero (w := w₁ - w₂) ?_ ?_ _ hi) <;>\n    simpa [sub_mul, sub_smul, sub_eq_zero]\n\n"}
{"name":"AffineIndependent.eq_zero_of_sum_eq_zero_subtype","module":"Mathlib.LinearAlgebra.AffineSpace.Independent","initialProofState":"k : Type u_1\nV : Type u_2\ninst✝² : Ring k\ninst✝¹ : AddCommGroup V\ninst✝ : Module k V\ns : Finset V\nhp : AffineIndependent k Subtype.val\nw : V → k\nhw₀ : Eq (s.sum fun x => w x) 0\nhw₁ : Eq (s.sum fun x => HSMul.hSMul (w x) x) 0\nx : V\na✝ : Membership.mem s x\n⊢ Eq (w x) 0","decl":"lemma AffineIndependent.eq_zero_of_sum_eq_zero_subtype {s : Finset V}\n    (hp : AffineIndependent k ((↑) : s → V)) {w : V → k} (hw₀ : ∑ x ∈ s, w x = 0)\n    (hw₁ : ∑ x ∈ s, w x • x = 0) : ∀ x ∈ s, w x = 0 := by\n  rw [← sum_attach] at hw₀ hw₁\n  exact fun x hx ↦ hp.eq_zero_of_sum_eq_zero hw₀ hw₁ ⟨x, hx⟩ (mem_univ _)\n\n"}
{"name":"AffineIndependent.eq_of_sum_eq_sum_subtype","module":"Mathlib.LinearAlgebra.AffineSpace.Independent","initialProofState":"k : Type u_1\nV : Type u_2\ninst✝² : Ring k\ninst✝¹ : AddCommGroup V\ninst✝ : Module k V\ns : Finset V\nhp : AffineIndependent k Subtype.val\nw₁ w₂ : V → k\nhw : Eq (s.sum fun i => w₁ i) (s.sum fun i => w₂ i)\nhwp : Eq (s.sum fun i => HSMul.hSMul (w₁ i) i) (s.sum fun i => HSMul.hSMul (w₂ i) i)\ni : V\na✝ : Membership.mem s i\n⊢ Eq (w₁ i) (w₂ i)","decl":"lemma AffineIndependent.eq_of_sum_eq_sum_subtype {s : Finset V}\n    (hp : AffineIndependent k ((↑) : s → V)) {w₁ w₂ : V → k} (hw : ∑ i ∈ s, w₁ i = ∑ i ∈ s, w₂ i)\n    (hwp : ∑ i ∈ s, w₁ i • i = ∑ i ∈ s, w₂ i • i) : ∀ i ∈ s, w₁ i = w₂ i := by\n  refine fun i hi => sub_eq_zero.1 (hp.eq_zero_of_sum_eq_zero_subtype (w := w₁ - w₂) ?_ ?_ _ hi) <;>\n    simpa [sub_mul, sub_smul, sub_eq_zero]\n\n"}
{"name":"weightedVSub_mem_vectorSpan_pair","module":"Mathlib.LinearAlgebra.AffineSpace.Independent","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\nι : Type u_4\np : ι → P\nh : AffineIndependent k p\nw w₁ w₂ : ι → k\ns : Finset ι\nhw : Eq (s.sum fun i => w i) 0\nhw₁ : Eq (s.sum fun i => w₁ i) 1\nhw₂ : Eq (s.sum fun i => w₂ i) 1\n⊢ Iff (Membership.mem (vectorSpan k (Insert.insert ((Finset.affineCombination k s p) w₁) (Singleton.singleton ((Finset.affineCombination k s p) w₂)))) ((s.weightedVSub p) w)) (Exists fun r => ∀ (i : ι), Membership.mem s i → Eq (w i) (HMul.hMul r (HSub.hSub (w₁ i) (w₂ i))))","decl":"/-- Given an affinely independent family of points, a weighted subtraction lies in the\n`vectorSpan` of two points given as affine combinations if and only if it is a weighted\nsubtraction with weights a multiple of the difference between the weights of the two points. -/\ntheorem weightedVSub_mem_vectorSpan_pair {p : ι → P} (h : AffineIndependent k p) {w w₁ w₂ : ι → k}\n    {s : Finset ι} (hw : ∑ i ∈ s, w i = 0) (hw₁ : ∑ i ∈ s, w₁ i = 1)\n    (hw₂ : ∑ i ∈ s, w₂ i = 1) :\n    s.weightedVSub p w ∈\n        vectorSpan k ({s.affineCombination k p w₁, s.affineCombination k p w₂} : Set P) ↔\n      ∃ r : k, ∀ i ∈ s, w i = r * (w₁ i - w₂ i) := by\n  rw [mem_vectorSpan_pair]\n  refine ⟨fun h => ?_, fun h => ?_⟩\n  · rcases h with ⟨r, hr⟩\n    refine ⟨r, fun i hi => ?_⟩\n    rw [s.affineCombination_vsub, ← s.weightedVSub_const_smul, ← sub_eq_zero, ← map_sub] at hr\n    have hw' : (∑ j ∈ s, (r • (w₁ - w₂) - w) j) = 0 := by\n      simp_rw [Pi.sub_apply, Pi.smul_apply, Pi.sub_apply, smul_sub, Finset.sum_sub_distrib, ←\n        Finset.smul_sum, hw, hw₁, hw₂, sub_self]\n    have hr' := h s _ hw' hr i hi\n    rw [eq_comm, ← sub_eq_zero, ← smul_eq_mul]\n    exact hr'\n  · rcases h with ⟨r, hr⟩\n    refine ⟨r, ?_⟩\n    let w' i := r * (w₁ i - w₂ i)\n    change ∀ i ∈ s, w i = w' i at hr\n    rw [s.weightedVSub_congr hr fun _ _ => rfl, s.affineCombination_vsub, ←\n      s.weightedVSub_const_smul]\n    congr\n\n"}
{"name":"affineCombination_mem_affineSpan_pair","module":"Mathlib.LinearAlgebra.AffineSpace.Independent","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\nι : Type u_4\np : ι → P\nh : AffineIndependent k p\nw w₁ w₂ : ι → k\ns : Finset ι\nx✝ : Eq (s.sum fun i => w i) 1\nhw₁ : Eq (s.sum fun i => w₁ i) 1\nhw₂ : Eq (s.sum fun i => w₂ i) 1\n⊢ Iff (Membership.mem (affineSpan k (Insert.insert ((Finset.affineCombination k s p) w₁) (Singleton.singleton ((Finset.affineCombination k s p) w₂)))) ((Finset.affineCombination k s p) w)) (Exists fun r => ∀ (i : ι), Membership.mem s i → Eq (w i) (HAdd.hAdd (HMul.hMul r (HSub.hSub (w₂ i) (w₁ i))) (w₁ i)))","decl":"/-- Given an affinely independent family of points, an affine combination lies in the\nspan of two points given as affine combinations if and only if it is an affine combination\nwith weights those of one point plus a multiple of the difference between the weights of the\ntwo points. -/\ntheorem affineCombination_mem_affineSpan_pair {p : ι → P} (h : AffineIndependent k p)\n    {w w₁ w₂ : ι → k} {s : Finset ι} (_ : ∑ i ∈ s, w i = 1) (hw₁ : ∑ i ∈ s, w₁ i = 1)\n    (hw₂ : ∑ i ∈ s, w₂ i = 1) :\n    s.affineCombination k p w ∈ line[k, s.affineCombination k p w₁, s.affineCombination k p w₂] ↔\n      ∃ r : k, ∀ i ∈ s, w i = r * (w₂ i - w₁ i) + w₁ i := by\n  rw [← vsub_vadd (s.affineCombination k p w) (s.affineCombination k p w₁),\n    AffineSubspace.vadd_mem_iff_mem_direction _ (left_mem_affineSpan_pair _ _ _),\n    direction_affineSpan, s.affineCombination_vsub, Set.pair_comm,\n    weightedVSub_mem_vectorSpan_pair h _ hw₂ hw₁]\n  · simp only [Pi.sub_apply, sub_eq_iff_eq_add]\n  · simp_all only [Pi.sub_apply, Finset.sum_sub_distrib, sub_self]\n\n"}
{"name":"exists_subset_affineIndependent_affineSpan_eq_top","module":"Mathlib.LinearAlgebra.AffineSpace.Independent","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : DivisionRing k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\ns : Set P\nh : AffineIndependent k fun p => ↑p\n⊢ Exists fun t => And (HasSubset.Subset s t) (And (AffineIndependent k fun p => ↑p) (Eq (affineSpan k t) Top.top))","decl":"/-- An affinely independent set of points can be extended to such a\nset that spans the whole space. -/\ntheorem exists_subset_affineIndependent_affineSpan_eq_top {s : Set P}\n    (h : AffineIndependent k (fun p => p : s → P)) :\n    ∃ t : Set P, s ⊆ t ∧ AffineIndependent k (fun p => p : t → P) ∧ affineSpan k t = ⊤ := by\n  rcases s.eq_empty_or_nonempty with (rfl | ⟨p₁, hp₁⟩)\n  · have p₁ : P := AddTorsor.nonempty.some\n    let hsv := Basis.ofVectorSpace k V\n    have hsvi := hsv.linearIndependent\n    have hsvt := hsv.span_eq\n    rw [Basis.coe_ofVectorSpace] at hsvi hsvt\n    have h0 : ∀ v : V, v ∈ Basis.ofVectorSpaceIndex k V → v ≠ 0 := by\n      intro v hv\n      simpa [hsv] using hsv.ne_zero ⟨v, hv⟩\n    rw [linearIndependent_set_iff_affineIndependent_vadd_union_singleton k h0 p₁] at hsvi\n    exact\n      ⟨{p₁} ∪ (fun v => v +ᵥ p₁) '' _, Set.empty_subset _, hsvi,\n        affineSpan_singleton_union_vadd_eq_top_of_span_eq_top p₁ hsvt⟩\n  · rw [affineIndependent_set_iff_linearIndependent_vsub k hp₁] at h\n    let bsv := Basis.extend h\n    have hsvi := bsv.linearIndependent\n    have hsvt := bsv.span_eq\n    rw [Basis.coe_extend] at hsvi hsvt\n    have hsv := h.subset_extend (Set.subset_univ _)\n    have h0 : ∀ v : V, v ∈ h.extend (Set.subset_univ _) → v ≠ 0 := by\n      intro v hv\n      simpa [bsv] using bsv.ne_zero ⟨v, hv⟩\n    rw [linearIndependent_set_iff_affineIndependent_vadd_union_singleton k h0 p₁] at hsvi\n    refine ⟨{p₁} ∪ (fun v => v +ᵥ p₁) '' h.extend (Set.subset_univ _), ?_, ?_⟩\n    · refine Set.Subset.trans ?_ (Set.union_subset_union_right _ (Set.image_subset _ hsv))\n      simp [Set.image_image]\n    · use hsvi\n      exact affineSpan_singleton_union_vadd_eq_top_of_span_eq_top p₁ hsvt\n\n"}
{"name":"exists_affineIndependent","module":"Mathlib.LinearAlgebra.AffineSpace.Independent","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : DivisionRing k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\ns : Set P\n⊢ Exists fun t => And (HasSubset.Subset t s) (And (Eq (affineSpan k t) (affineSpan k s)) (AffineIndependent k Subtype.val))","decl":"theorem exists_affineIndependent (s : Set P) :\n    ∃ t ⊆ s, affineSpan k t = affineSpan k s ∧ AffineIndependent k ((↑) : t → P) := by\n  rcases s.eq_empty_or_nonempty with (rfl | ⟨p, hp⟩)\n  · exact ⟨∅, Set.empty_subset ∅, rfl, affineIndependent_of_subsingleton k _⟩\n  obtain ⟨b, hb₁, hb₂, hb₃⟩ := exists_linearIndependent k ((Equiv.vaddConst p).symm '' s)\n  have hb₀ : ∀ v : V, v ∈ b → v ≠ 0 := fun v hv => hb₃.ne_zero (⟨v, hv⟩ : b)\n  rw [linearIndependent_set_iff_affineIndependent_vadd_union_singleton k hb₀ p] at hb₃\n  refine ⟨{p} ∪ Equiv.vaddConst p '' b, ?_, ?_, hb₃⟩\n  · apply Set.union_subset (Set.singleton_subset_iff.mpr hp)\n    rwa [← (Equiv.vaddConst p).subset_symm_image b s]\n  · rw [Equiv.coe_vaddConst_symm, ← vectorSpan_eq_span_vsub_set_right k hp] at hb₂\n    apply AffineSubspace.ext_of_direction_eq\n    · have : Submodule.span k b = Submodule.span k (insert 0 b) := by simp\n      simp only [direction_affineSpan, ← hb₂, Equiv.coe_vaddConst, Set.singleton_union,\n        vectorSpan_eq_span_vsub_set_right k (Set.mem_insert p _), this]\n      congr\n      change (Equiv.vaddConst p).symm '' insert p (Equiv.vaddConst p '' b) = _\n      rw [Set.image_insert_eq, ← Set.image_comp]\n      simp\n    · use p\n      simp only [Equiv.coe_vaddConst, Set.singleton_union, Set.mem_inter_iff, coe_affineSpan]\n      exact ⟨mem_spanPoints k _ _ (Set.mem_insert p _), mem_spanPoints k _ _ hp⟩\n\n"}
{"name":"affineIndependent_of_ne","module":"Mathlib.LinearAlgebra.AffineSpace.Independent","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : DivisionRing k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\np₁ p₂ : P\nh : Ne p₁ p₂\n⊢ AffineIndependent k (Matrix.vecCons p₁ (Matrix.vecCons p₂ Matrix.vecEmpty))","decl":"/-- Two different points are affinely independent. -/\ntheorem affineIndependent_of_ne {p₁ p₂ : P} (h : p₁ ≠ p₂) : AffineIndependent k ![p₁, p₂] := by\n  rw [affineIndependent_iff_linearIndependent_vsub k ![p₁, p₂] 0]\n  let i₁ : { x // x ≠ (0 : Fin 2) } := ⟨1, by norm_num⟩\n  have he' : ∀ i, i = i₁ := by\n    rintro ⟨i, hi⟩\n    ext\n    fin_cases i\n    · simp at hi\n    · simp [i₁]\n  haveI : Unique { x // x ≠ (0 : Fin 2) } := ⟨⟨i₁⟩, he'⟩\n  apply linearIndependent_unique\n  rw [he' default]\n  simpa using h.symm\n\n"}
{"name":"AffineIndependent.affineIndependent_of_not_mem_span","module":"Mathlib.LinearAlgebra.AffineSpace.Independent","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : DivisionRing k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\nι : Type u_4\np : ι → P\ni : ι\nha : AffineIndependent k fun x => p ↑x\nhi : Not (Membership.mem (affineSpan k (Set.image p (setOf fun x => Ne x i))) (p i))\n⊢ AffineIndependent k p","decl":"/-- If all but one point of a family are affinely independent, and that point does not lie in\nthe affine span of that family, the family is affinely independent. -/\ntheorem AffineIndependent.affineIndependent_of_not_mem_span {p : ι → P} {i : ι}\n    (ha : AffineIndependent k fun x : { y // y ≠ i } => p x)\n    (hi : p i ∉ affineSpan k (p '' { x | x ≠ i })) : AffineIndependent k p := by\n  classical\n    intro s w hw hs\n    let s' : Finset { y // y ≠ i } := s.subtype (· ≠ i)\n    let p' : { y // y ≠ i } → P := fun x => p x\n    by_cases his : i ∈ s ∧ w i ≠ 0\n    · refine False.elim (hi ?_)\n      let wm : ι → k := -(w i)⁻¹ • w\n      have hms : s.weightedVSub p wm = (0 : V) := by simp [wm, hs]\n      have hwm : ∑ i ∈ s, wm i = 0 := by simp [wm, ← Finset.mul_sum, hw]\n      have hwmi : wm i = -1 := by simp [wm, his.2]\n      let w' : { y // y ≠ i } → k := fun x => wm x\n      have hw' : ∑ x ∈ s', w' x = 1 := by\n        simp_rw [w', s', Finset.sum_subtype_eq_sum_filter]\n        rw [← s.sum_filter_add_sum_filter_not (· ≠ i)] at hwm\n        simp_rw [Classical.not_not] at hwm\n        -- Porting note: this `erw` used to be part of the `simp_rw`\n        erw [Finset.filter_eq'] at hwm\n        simp_rw [if_pos his.1, Finset.sum_singleton, hwmi, ← sub_eq_add_neg, sub_eq_zero] at hwm\n        exact hwm\n      rw [← s.affineCombination_eq_of_weightedVSub_eq_zero_of_eq_neg_one hms his.1 hwmi, ←\n        (Subtype.range_coe : _ = { x | x ≠ i }), ← Set.range_comp, ←\n        s.affineCombination_subtype_eq_filter]\n      exact affineCombination_mem_affineSpan hw' p'\n    · rw [not_and_or, Classical.not_not] at his\n      let w' : { y // y ≠ i } → k := fun x => w x\n      have hw' : ∑ x ∈ s', w' x = 0 := by\n        simp_rw [w', s', Finset.sum_subtype_eq_sum_filter]\n        rw [Finset.sum_filter_of_ne, hw]\n        rintro x hxs hwx rfl\n        exact hwx (his.neg_resolve_left hxs)\n      have hs' : s'.weightedVSub p' w' = (0 : V) := by\n        simp_rw [w', s', p', Finset.weightedVSub_subtype_eq_filter]\n        rw [Finset.weightedVSub_filter_of_ne, hs]\n        rintro x hxs hwx rfl\n        exact hwx (his.neg_resolve_left hxs)\n      intro j hj\n      by_cases hji : j = i\n      · rw [hji] at hj\n        exact hji.symm ▸ his.neg_resolve_left hj\n      · exact ha s' w' hw' hs' ⟨j, hji⟩ (Finset.mem_subtype.2 hj)\n\n"}
{"name":"affineIndependent_of_ne_of_mem_of_mem_of_not_mem","module":"Mathlib.LinearAlgebra.AffineSpace.Independent","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : DivisionRing k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\ns : AffineSubspace k P\np₁ p₂ p₃ : P\nhp₁p₂ : Ne p₁ p₂\nhp₁ : Membership.mem s p₁\nhp₂ : Membership.mem s p₂\nhp₃ : Not (Membership.mem s p₃)\n⊢ AffineIndependent k (Matrix.vecCons p₁ (Matrix.vecCons p₂ (Matrix.vecCons p₃ Matrix.vecEmpty)))","decl":"/-- If distinct points `p₁` and `p₂` lie in `s` but `p₃` does not, the three points are affinely\nindependent. -/\ntheorem affineIndependent_of_ne_of_mem_of_mem_of_not_mem {s : AffineSubspace k P} {p₁ p₂ p₃ : P}\n    (hp₁p₂ : p₁ ≠ p₂) (hp₁ : p₁ ∈ s) (hp₂ : p₂ ∈ s) (hp₃ : p₃ ∉ s) :\n    AffineIndependent k ![p₁, p₂, p₃] := by\n  have ha : AffineIndependent k fun x : { x : Fin 3 // x ≠ 2 } => ![p₁, p₂, p₃] x := by\n    rw [← affineIndependent_equiv (finSuccAboveEquiv (2 : Fin 3))]\n    convert affineIndependent_of_ne k hp₁p₂\n    ext x\n    fin_cases x <;> rfl\n  refine ha.affineIndependent_of_not_mem_span ?_\n  intro h\n  refine hp₃ ((AffineSubspace.le_def' _ s).1 ?_ p₃ h)\n  simp_rw [affineSpan_le, Set.image_subset_iff, Set.subset_def, Set.mem_preimage]\n  intro x\n  fin_cases x <;> simp +decide [hp₁, hp₂]\n\n"}
{"name":"affineIndependent_of_ne_of_mem_of_not_mem_of_mem","module":"Mathlib.LinearAlgebra.AffineSpace.Independent","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : DivisionRing k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\ns : AffineSubspace k P\np₁ p₂ p₃ : P\nhp₁p₃ : Ne p₁ p₃\nhp₁ : Membership.mem s p₁\nhp₂ : Not (Membership.mem s p₂)\nhp₃ : Membership.mem s p₃\n⊢ AffineIndependent k (Matrix.vecCons p₁ (Matrix.vecCons p₂ (Matrix.vecCons p₃ Matrix.vecEmpty)))","decl":"/-- If distinct points `p₁` and `p₃` lie in `s` but `p₂` does not, the three points are affinely\nindependent. -/\ntheorem affineIndependent_of_ne_of_mem_of_not_mem_of_mem {s : AffineSubspace k P} {p₁ p₂ p₃ : P}\n    (hp₁p₃ : p₁ ≠ p₃) (hp₁ : p₁ ∈ s) (hp₂ : p₂ ∉ s) (hp₃ : p₃ ∈ s) :\n    AffineIndependent k ![p₁, p₂, p₃] := by\n  rw [← affineIndependent_equiv (Equiv.swap (1 : Fin 3) 2)]\n  convert affineIndependent_of_ne_of_mem_of_mem_of_not_mem hp₁p₃ hp₁ hp₃ hp₂ using 1\n  ext x\n  fin_cases x <;> rfl\n\n"}
{"name":"affineIndependent_of_ne_of_not_mem_of_mem_of_mem","module":"Mathlib.LinearAlgebra.AffineSpace.Independent","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : DivisionRing k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\ns : AffineSubspace k P\np₁ p₂ p₃ : P\nhp₂p₃ : Ne p₂ p₃\nhp₁ : Not (Membership.mem s p₁)\nhp₂ : Membership.mem s p₂\nhp₃ : Membership.mem s p₃\n⊢ AffineIndependent k (Matrix.vecCons p₁ (Matrix.vecCons p₂ (Matrix.vecCons p₃ Matrix.vecEmpty)))","decl":"/-- If distinct points `p₂` and `p₃` lie in `s` but `p₁` does not, the three points are affinely\nindependent. -/\ntheorem affineIndependent_of_ne_of_not_mem_of_mem_of_mem {s : AffineSubspace k P} {p₁ p₂ p₃ : P}\n    (hp₂p₃ : p₂ ≠ p₃) (hp₁ : p₁ ∉ s) (hp₂ : p₂ ∈ s) (hp₃ : p₃ ∈ s) :\n    AffineIndependent k ![p₁, p₂, p₃] := by\n  rw [← affineIndependent_equiv (Equiv.swap (0 : Fin 3) 2)]\n  convert affineIndependent_of_ne_of_mem_of_mem_of_not_mem hp₂p₃.symm hp₃ hp₂ hp₁ using 1\n  ext x\n  fin_cases x <;> rfl\n\n"}
{"name":"sign_eq_of_affineCombination_mem_affineSpan_pair","module":"Mathlib.LinearAlgebra.AffineSpace.Independent","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : LinearOrderedRing k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\nι : Type u_4\np : ι → P\nh : AffineIndependent k p\nw w₁ w₂ : ι → k\ns : Finset ι\nhw : Eq (s.sum fun i => w i) 1\nhw₁ : Eq (s.sum fun i => w₁ i) 1\nhw₂ : Eq (s.sum fun i => w₂ i) 1\nhs : Membership.mem (affineSpan k (Insert.insert ((Finset.affineCombination k s p) w₁) (Singleton.singleton ((Finset.affineCombination k s p) w₂)))) ((Finset.affineCombination k s p) w)\ni j : ι\nhi : Membership.mem s i\nhj : Membership.mem s j\nhi0 : Eq (w₁ i) 0\nhj0 : Eq (w₁ j) 0\nhij : Eq (SignType.sign (w₂ i)) (SignType.sign (w₂ j))\n⊢ Eq (SignType.sign (w i)) (SignType.sign (w j))","decl":"/-- Given an affinely independent family of points, suppose that an affine combination lies in\nthe span of two points given as affine combinations, and suppose that, for two indices, the\ncoefficients in the first point in the span are zero and those in the second point in the span\nhave the same sign. Then the coefficients in the combination lying in the span have the same\nsign. -/\ntheorem sign_eq_of_affineCombination_mem_affineSpan_pair {p : ι → P} (h : AffineIndependent k p)\n    {w w₁ w₂ : ι → k} {s : Finset ι} (hw : ∑ i ∈ s, w i = 1) (hw₁ : ∑ i ∈ s, w₁ i = 1)\n    (hw₂ : ∑ i ∈ s, w₂ i = 1)\n    (hs :\n      s.affineCombination k p w ∈ line[k, s.affineCombination k p w₁, s.affineCombination k p w₂])\n    {i j : ι} (hi : i ∈ s) (hj : j ∈ s) (hi0 : w₁ i = 0) (hj0 : w₁ j = 0)\n    (hij : SignType.sign (w₂ i) = SignType.sign (w₂ j)) :\n    SignType.sign (w i) = SignType.sign (w j) := by\n  rw [affineCombination_mem_affineSpan_pair h hw hw₁ hw₂] at hs\n  rcases hs with ⟨r, hr⟩\n  rw [hr i hi, hr j hj, hi0, hj0, add_zero, add_zero, sub_zero, sub_zero, sign_mul, sign_mul, hij]\n\n"}
{"name":"sign_eq_of_affineCombination_mem_affineSpan_single_lineMap","module":"Mathlib.LinearAlgebra.AffineSpace.Independent","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : LinearOrderedRing k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\nι : Type u_4\np : ι → P\nh : AffineIndependent k p\nw : ι → k\ns : Finset ι\nhw : Eq (s.sum fun i => w i) 1\ni₁ i₂ i₃ : ι\nh₁ : Membership.mem s i₁\nh₂ : Membership.mem s i₂\nh₃ : Membership.mem s i₃\nh₁₂ : Ne i₁ i₂\nh₁₃ : Ne i₁ i₃\nh₂₃ : Ne i₂ i₃\nc : k\nhc0 : LT.lt 0 c\nhc1 : LT.lt c 1\nhs : Membership.mem (affineSpan k (Insert.insert (p i₁) (Singleton.singleton ((AffineMap.lineMap (p i₂) (p i₃)) c)))) ((Finset.affineCombination k s p) w)\n⊢ Eq (SignType.sign (w i₂)) (SignType.sign (w i₃))","decl":"/-- Given an affinely independent family of points, suppose that an affine combination lies in\nthe span of one point of that family and a combination of another two points of that family given\nby `lineMap` with coefficient between 0 and 1. Then the coefficients of those two points in the\ncombination lying in the span have the same sign. -/\ntheorem sign_eq_of_affineCombination_mem_affineSpan_single_lineMap {p : ι → P}\n    (h : AffineIndependent k p) {w : ι → k} {s : Finset ι} (hw : ∑ i ∈ s, w i = 1) {i₁ i₂ i₃ : ι}\n    (h₁ : i₁ ∈ s) (h₂ : i₂ ∈ s) (h₃ : i₃ ∈ s) (h₁₂ : i₁ ≠ i₂) (h₁₃ : i₁ ≠ i₃) (h₂₃ : i₂ ≠ i₃)\n    {c : k} (hc0 : 0 < c) (hc1 : c < 1)\n    (hs : s.affineCombination k p w ∈ line[k, p i₁, AffineMap.lineMap (p i₂) (p i₃) c]) :\n    SignType.sign (w i₂) = SignType.sign (w i₃) := by\n  classical\n    rw [← s.affineCombination_affineCombinationSingleWeights k p h₁, ←\n      s.affineCombination_affineCombinationLineMapWeights p h₂ h₃ c] at hs\n    refine\n      sign_eq_of_affineCombination_mem_affineSpan_pair h hw\n        (s.sum_affineCombinationSingleWeights k h₁)\n        (s.sum_affineCombinationLineMapWeights h₂ h₃ c) hs h₂ h₃\n        (Finset.affineCombinationSingleWeights_apply_of_ne k h₁₂.symm)\n        (Finset.affineCombinationSingleWeights_apply_of_ne k h₁₃.symm) ?_\n    rw [Finset.affineCombinationLineMapWeights_apply_left h₂₃,\n      Finset.affineCombinationLineMapWeights_apply_right h₂₃]\n    simp_all only [sub_pos, sign_pos]\n\n"}
{"name":"Affine.Simplex.independent","module":"Mathlib.LinearAlgebra.AffineSpace.Independent","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\nn : Nat\nself : Affine.Simplex k P n\n⊢ AffineIndependent k self.points","decl":"/-- A `Simplex k P n` is a collection of `n + 1` affinely\nindependent points. -/\nstructure Simplex (n : ℕ) where\n  points : Fin (n + 1) → P\n  independent : AffineIndependent k points\n\n"}
{"name":"Affine.Simplex.mk.inj","module":"Mathlib.LinearAlgebra.AffineSpace.Independent","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\nn : Nat\npoints✝ : Fin (HAdd.hAdd n 1) → P\nindependent✝ : AffineIndependent k points✝\npoints : Fin (HAdd.hAdd n 1) → P\nindependent : AffineIndependent k points\nx✝ : Eq { points := points✝, independent := independent✝ } { points := points, independent := independent }\n⊢ Eq points✝ points","decl":"/-- A `Simplex k P n` is a collection of `n + 1` affinely\nindependent points. -/\nstructure Simplex (n : ℕ) where\n  points : Fin (n + 1) → P\n  independent : AffineIndependent k points\n\n"}
{"name":"Affine.Simplex.mk.injEq","module":"Mathlib.LinearAlgebra.AffineSpace.Independent","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\nn : Nat\npoints✝ : Fin (HAdd.hAdd n 1) → P\nindependent✝ : AffineIndependent k points✝\npoints : Fin (HAdd.hAdd n 1) → P\nindependent : AffineIndependent k points\n⊢ Eq (Eq { points := points✝, independent := independent✝ } { points := points, independent := independent }) (Eq points✝ points)","decl":"/-- A `Simplex k P n` is a collection of `n + 1` affinely\nindependent points. -/\nstructure Simplex (n : ℕ) where\n  points : Fin (n + 1) → P\n  independent : AffineIndependent k points\n\n"}
{"name":"Affine.Simplex.mk.sizeOf_spec","module":"Mathlib.LinearAlgebra.AffineSpace.Independent","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝⁶ : Ring k\ninst✝⁵ : AddCommGroup V\ninst✝⁴ : Module k V\ninst✝³ : AddTorsor V P\nn : Nat\ninst✝² : SizeOf k\ninst✝¹ : SizeOf V\ninst✝ : SizeOf P\npoints : Fin (HAdd.hAdd n 1) → P\nindependent : AffineIndependent k points\n⊢ Eq (SizeOf.sizeOf { points := points, independent := independent }) 1","decl":"/-- A `Simplex k P n` is a collection of `n + 1` affinely\nindependent points. -/\nstructure Simplex (n : ℕ) where\n  points : Fin (n + 1) → P\n  independent : AffineIndependent k points\n\n"}
{"name":"Affine.Simplex.mkOfPoint_points","module":"Mathlib.LinearAlgebra.AffineSpace.Independent","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\np : P\ni : Fin 1\n⊢ Eq ((Affine.Simplex.mkOfPoint k p).points i) p","decl":"/-- The point in a simplex constructed with `mkOfPoint`. -/\n@[simp]\ntheorem mkOfPoint_points (p : P) (i : Fin 1) : (mkOfPoint k p).points i = p :=\n  rfl\n\n"}
{"name":"Affine.Simplex.nonempty","module":"Mathlib.LinearAlgebra.AffineSpace.Independent","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\n⊢ Nonempty (Affine.Simplex k P 0)","decl":"instance nonempty : Nonempty (Simplex k P 0) :=\n  ⟨mkOfPoint k <| AddTorsor.nonempty.some⟩\n\n"}
{"name":"Affine.Simplex.ext_iff","module":"Mathlib.LinearAlgebra.AffineSpace.Independent","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\nn : Nat\ns1 s2 : Affine.Simplex k P n\n⊢ Iff (Eq s1 s2) (∀ (i : Fin (HAdd.hAdd n 1)), Eq (s1.points i) (s2.points i))","decl":"/-- Two simplices are equal if they have the same points. -/\n@[ext]\ntheorem ext {n : ℕ} {s1 s2 : Simplex k P n} (h : ∀ i, s1.points i = s2.points i) : s1 = s2 := by\n  cases s1\n  cases s2\n  congr with i\n  exact h i\n\n"}
{"name":"Affine.Simplex.ext","module":"Mathlib.LinearAlgebra.AffineSpace.Independent","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\nn : Nat\ns1 s2 : Affine.Simplex k P n\nh : ∀ (i : Fin (HAdd.hAdd n 1)), Eq (s1.points i) (s2.points i)\n⊢ Eq s1 s2","decl":"/-- Two simplices are equal if they have the same points. -/\n@[ext]\ntheorem ext {n : ℕ} {s1 s2 : Simplex k P n} (h : ∀ i, s1.points i = s2.points i) : s1 = s2 := by\n  cases s1\n  cases s2\n  congr with i\n  exact h i\n\n"}
{"name":"Affine.Simplex.face_points","module":"Mathlib.LinearAlgebra.AffineSpace.Independent","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\nn : Nat\ns : Affine.Simplex k P n\nfs : Finset (Fin (HAdd.hAdd n 1))\nm : Nat\nh : Eq fs.card (HAdd.hAdd m 1)\ni : Fin (HAdd.hAdd m 1)\n⊢ Eq ((s.face h).points i) (s.points ((fs.orderEmbOfFin h) i))","decl":"/-- The points of a face of a simplex are given by `mono_of_fin`. -/\ntheorem face_points {n : ℕ} (s : Simplex k P n) {fs : Finset (Fin (n + 1))} {m : ℕ}\n    (h : #fs = m + 1) (i : Fin (m + 1)) :\n    (s.face h).points i = s.points (fs.orderEmbOfFin h i) :=\n  rfl\n\n"}
{"name":"Affine.Simplex.face_points'","module":"Mathlib.LinearAlgebra.AffineSpace.Independent","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\nn : Nat\ns : Affine.Simplex k P n\nfs : Finset (Fin (HAdd.hAdd n 1))\nm : Nat\nh : Eq fs.card (HAdd.hAdd m 1)\n⊢ Eq (s.face h).points (Function.comp s.points ⇑(fs.orderEmbOfFin h))","decl":"/-- The points of a face of a simplex are given by `mono_of_fin`. -/\ntheorem face_points' {n : ℕ} (s : Simplex k P n) {fs : Finset (Fin (n + 1))} {m : ℕ}\n    (h : #fs = m + 1) : (s.face h).points = s.points ∘ fs.orderEmbOfFin h :=\n  rfl\n\n"}
{"name":"Affine.Simplex.face_eq_mkOfPoint","module":"Mathlib.LinearAlgebra.AffineSpace.Independent","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\nn : Nat\ns : Affine.Simplex k P n\ni : Fin (HAdd.hAdd n 1)\n⊢ Eq (s.face ⋯) (Affine.Simplex.mkOfPoint k (s.points i))","decl":"/-- A single-point face equals the 0-simplex constructed with\n`mkOfPoint`. -/\n@[simp]\ntheorem face_eq_mkOfPoint {n : ℕ} (s : Simplex k P n) (i : Fin (n + 1)) :\n    s.face (Finset.card_singleton i) = mkOfPoint k (s.points i) := by\n  ext\n  simp only [Affine.Simplex.mkOfPoint_points, Affine.Simplex.face_points]\n  -- Porting note: `simp` can't use the next lemma\n  rw [Finset.orderEmbOfFin_singleton]\n\n"}
{"name":"Affine.Simplex.range_face_points","module":"Mathlib.LinearAlgebra.AffineSpace.Independent","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\nn : Nat\ns : Affine.Simplex k P n\nfs : Finset (Fin (HAdd.hAdd n 1))\nm : Nat\nh : Eq fs.card (HAdd.hAdd m 1)\n⊢ Eq (Set.range (s.face h).points) (Set.image s.points ↑fs)","decl":"/-- The set of points of a face. -/\n@[simp]\ntheorem range_face_points {n : ℕ} (s : Simplex k P n) {fs : Finset (Fin (n + 1))} {m : ℕ}\n    (h : #fs = m + 1) : Set.range (s.face h).points = s.points '' ↑fs := by\n  rw [face_points', Set.range_comp, Finset.range_orderEmbOfFin]\n\n"}
{"name":"Affine.Simplex.reindex_points","module":"Mathlib.LinearAlgebra.AffineSpace.Independent","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\nm n : Nat\ns : Affine.Simplex k P m\ne : Equiv (Fin (HAdd.hAdd m 1)) (Fin (HAdd.hAdd n 1))\na✝ : Fin (HAdd.hAdd n 1)\n⊢ Eq ((s.reindex e).points a✝) (Function.comp s.points (⇑e.symm) a✝)","decl":"/-- Remap a simplex along an `Equiv` of index types. -/\n@[simps]\ndef reindex {m n : ℕ} (s : Simplex k P m) (e : Fin (m + 1) ≃ Fin (n + 1)) : Simplex k P n :=\n  ⟨s.points ∘ e.symm, (affineIndependent_equiv e.symm).2 s.independent⟩\n\n"}
{"name":"Affine.Simplex.reindex_refl","module":"Mathlib.LinearAlgebra.AffineSpace.Independent","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\nn : Nat\ns : Affine.Simplex k P n\n⊢ Eq (s.reindex (Equiv.refl (Fin (HAdd.hAdd n 1)))) s","decl":"/-- Reindexing by `Equiv.refl` yields the original simplex. -/\n@[simp]\ntheorem reindex_refl {n : ℕ} (s : Simplex k P n) : s.reindex (Equiv.refl (Fin (n + 1))) = s :=\n  ext fun _ => rfl\n\n"}
{"name":"Affine.Simplex.reindex_trans","module":"Mathlib.LinearAlgebra.AffineSpace.Independent","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\nn₁ n₂ n₃ : Nat\ne₁₂ : Equiv (Fin (HAdd.hAdd n₁ 1)) (Fin (HAdd.hAdd n₂ 1))\ne₂₃ : Equiv (Fin (HAdd.hAdd n₂ 1)) (Fin (HAdd.hAdd n₃ 1))\ns : Affine.Simplex k P n₁\n⊢ Eq (s.reindex (e₁₂.trans e₂₃)) ((s.reindex e₁₂).reindex e₂₃)","decl":"/-- Reindexing by the composition of two equivalences is the same as reindexing twice. -/\n@[simp]\ntheorem reindex_trans {n₁ n₂ n₃ : ℕ} (e₁₂ : Fin (n₁ + 1) ≃ Fin (n₂ + 1))\n    (e₂₃ : Fin (n₂ + 1) ≃ Fin (n₃ + 1)) (s : Simplex k P n₁) :\n    s.reindex (e₁₂.trans e₂₃) = (s.reindex e₁₂).reindex e₂₃ :=\n  rfl\n\n"}
{"name":"Affine.Simplex.reindex_reindex_symm","module":"Mathlib.LinearAlgebra.AffineSpace.Independent","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\nm n : Nat\ns : Affine.Simplex k P m\ne : Equiv (Fin (HAdd.hAdd m 1)) (Fin (HAdd.hAdd n 1))\n⊢ Eq ((s.reindex e).reindex e.symm) s","decl":"/-- Reindexing by an equivalence and its inverse yields the original simplex. -/\n@[simp]\ntheorem reindex_reindex_symm {m n : ℕ} (s : Simplex k P m) (e : Fin (m + 1) ≃ Fin (n + 1)) :\n    (s.reindex e).reindex e.symm = s := by rw [← reindex_trans, Equiv.self_trans_symm, reindex_refl]\n\n"}
{"name":"Affine.Simplex.reindex_symm_reindex","module":"Mathlib.LinearAlgebra.AffineSpace.Independent","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\nm n : Nat\ns : Affine.Simplex k P m\ne : Equiv (Fin (HAdd.hAdd n 1)) (Fin (HAdd.hAdd m 1))\n⊢ Eq ((s.reindex e.symm).reindex e) s","decl":"/-- Reindexing by the inverse of an equivalence and that equivalence yields the original simplex. -/\n@[simp]\ntheorem reindex_symm_reindex {m n : ℕ} (s : Simplex k P m) (e : Fin (n + 1) ≃ Fin (m + 1)) :\n    (s.reindex e.symm).reindex e = s := by rw [← reindex_trans, Equiv.symm_trans_self, reindex_refl]\n\n"}
{"name":"Affine.Simplex.reindex_range_points","module":"Mathlib.LinearAlgebra.AffineSpace.Independent","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\nm n : Nat\ns : Affine.Simplex k P m\ne : Equiv (Fin (HAdd.hAdd m 1)) (Fin (HAdd.hAdd n 1))\n⊢ Eq (Set.range (s.reindex e).points) (Set.range s.points)","decl":"/-- Reindexing a simplex produces one with the same set of points. -/\n@[simp]\ntheorem reindex_range_points {m n : ℕ} (s : Simplex k P m) (e : Fin (m + 1) ≃ Fin (n + 1)) :\n    Set.range (s.reindex e).points = Set.range s.points := by\n  rw [reindex, Set.range_comp, Equiv.range_eq_univ, Set.image_univ]\n\n"}
{"name":"Affine.Simplex.face_centroid_eq_centroid","module":"Mathlib.LinearAlgebra.AffineSpace.Independent","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : DivisionRing k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\nn : Nat\ns : Affine.Simplex k P n\nfs : Finset (Fin (HAdd.hAdd n 1))\nm : Nat\nh : Eq fs.card (HAdd.hAdd m 1)\n⊢ Eq (Finset.centroid k Finset.univ (s.face h).points) (Finset.centroid k fs s.points)","decl":"/-- The centroid of a face of a simplex as the centroid of a subset of\nthe points. -/\n@[simp]\ntheorem face_centroid_eq_centroid {n : ℕ} (s : Simplex k P n) {fs : Finset (Fin (n + 1))} {m : ℕ}\n    (h : #fs = m + 1) : Finset.univ.centroid k (s.face h).points = fs.centroid k s.points := by\n  convert (Finset.univ.centroid_map k (fs.orderEmbOfFin h).toEmbedding s.points).symm\n  rw [← Finset.coe_inj, Finset.coe_map, Finset.coe_univ, Set.image_univ]\n  simp\n\n"}
{"name":"Affine.Simplex.centroid_eq_iff","module":"Mathlib.LinearAlgebra.AffineSpace.Independent","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝⁴ : DivisionRing k\ninst✝³ : AddCommGroup V\ninst✝² : Module k V\ninst✝¹ : AddTorsor V P\ninst✝ : CharZero k\nn : Nat\ns : Affine.Simplex k P n\nfs₁ fs₂ : Finset (Fin (HAdd.hAdd n 1))\nm₁ m₂ : Nat\nh₁ : Eq fs₁.card (HAdd.hAdd m₁ 1)\nh₂ : Eq fs₂.card (HAdd.hAdd m₂ 1)\n⊢ Iff (Eq (Finset.centroid k fs₁ s.points) (Finset.centroid k fs₂ s.points)) (Eq fs₁ fs₂)","decl":"/-- Over a characteristic-zero division ring, the centroids given by\ntwo subsets of the points of a simplex are equal if and only if those\nfaces are given by the same subset of points. -/\n@[simp]\ntheorem centroid_eq_iff [CharZero k] {n : ℕ} (s : Simplex k P n) {fs₁ fs₂ : Finset (Fin (n + 1))}\n    {m₁ m₂ : ℕ} (h₁ : #fs₁ = m₁ + 1) (h₂ : #fs₂ = m₂ + 1) :\n    fs₁.centroid k s.points = fs₂.centroid k s.points ↔ fs₁ = fs₂ := by\n  refine ⟨fun h => ?_, @congrArg _ _ fs₁ fs₂ (fun z => Finset.centroid k z s.points)⟩\n  rw [Finset.centroid_eq_affineCombination_fintype,\n    Finset.centroid_eq_affineCombination_fintype] at h\n  have ha :=\n    (affineIndependent_iff_indicator_eq_of_affineCombination_eq k s.points).1 s.independent _ _ _ _\n      (fs₁.sum_centroidWeightsIndicator_eq_one_of_card_eq_add_one k h₁)\n      (fs₂.sum_centroidWeightsIndicator_eq_one_of_card_eq_add_one k h₂) h\n  simp_rw [Finset.coe_univ, Set.indicator_univ, funext_iff,\n    Finset.centroidWeightsIndicator_def, Finset.centroidWeights, h₁, h₂] at ha\n  ext i\n  specialize ha i\n  have key : ∀ n : ℕ, (n : k) + 1 ≠ 0 := fun n h => by norm_cast at h\n  -- we should be able to golf this to\n  -- `refine ⟨fun hi ↦ decidable.by_contradiction (fun hni ↦ ?_), ...⟩`,\n  -- but for some unknown reason it doesn't work.\n  constructor <;> intro hi <;> by_contra hni\n  · simp [hni, hi, key] at ha\n  · simpa [hni, hi, key] using ha.symm\n\n"}
{"name":"Affine.Simplex.face_centroid_eq_iff","module":"Mathlib.LinearAlgebra.AffineSpace.Independent","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝⁴ : DivisionRing k\ninst✝³ : AddCommGroup V\ninst✝² : Module k V\ninst✝¹ : AddTorsor V P\ninst✝ : CharZero k\nn : Nat\ns : Affine.Simplex k P n\nfs₁ fs₂ : Finset (Fin (HAdd.hAdd n 1))\nm₁ m₂ : Nat\nh₁ : Eq fs₁.card (HAdd.hAdd m₁ 1)\nh₂ : Eq fs₂.card (HAdd.hAdd m₂ 1)\n⊢ Iff (Eq (Finset.centroid k Finset.univ (s.face h₁).points) (Finset.centroid k Finset.univ (s.face h₂).points)) (Eq fs₁ fs₂)","decl":"/-- Over a characteristic-zero division ring, the centroids of two\nfaces of a simplex are equal if and only if those faces are given by\nthe same subset of points. -/\ntheorem face_centroid_eq_iff [CharZero k] {n : ℕ} (s : Simplex k P n)\n    {fs₁ fs₂ : Finset (Fin (n + 1))} {m₁ m₂ : ℕ} (h₁ : #fs₁ = m₁ + 1) (h₂ : #fs₂ = m₂ + 1) :\n    Finset.univ.centroid k (s.face h₁).points = Finset.univ.centroid k (s.face h₂).points ↔\n      fs₁ = fs₂ := by\n  rw [face_centroid_eq_centroid, face_centroid_eq_centroid]\n  exact s.centroid_eq_iff h₁ h₂\n\n"}
{"name":"Affine.Simplex.centroid_eq_of_range_eq","module":"Mathlib.LinearAlgebra.AffineSpace.Independent","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : DivisionRing k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\nn : Nat\ns₁ s₂ : Affine.Simplex k P n\nh : Eq (Set.range s₁.points) (Set.range s₂.points)\n⊢ Eq (Finset.centroid k Finset.univ s₁.points) (Finset.centroid k Finset.univ s₂.points)","decl":"/-- Two simplices with the same points have the same centroid. -/\ntheorem centroid_eq_of_range_eq {n : ℕ} {s₁ s₂ : Simplex k P n}\n    (h : Set.range s₁.points = Set.range s₂.points) :\n    Finset.univ.centroid k s₁.points = Finset.univ.centroid k s₂.points := by\n  rw [← Set.image_univ, ← Set.image_univ, ← Finset.coe_univ] at h\n  exact\n    Finset.univ.centroid_eq_of_inj_on_of_image_eq k _\n      (fun _ _ _ _ he => AffineIndependent.injective s₁.independent he)\n      (fun _ _ _ _ he => AffineIndependent.injective s₂.independent he) h\n\n"}
