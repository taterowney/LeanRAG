{"name":"CategoryTheory.NoetherianObject.subobject_gt_wellFounded'","module":"Mathlib.CategoryTheory.Noetherian","initialProofState":"C : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} C\nX : C\nself : CategoryTheory.NoetherianObject X\n⊢ WellFounded fun x1 x2 => GT.gt x1 x2","decl":"/-- A noetherian object is an object\nwhich does not have infinite increasing sequences of subobjects. -/\n@[stacks 0FCG]\nclass NoetherianObject (X : C) : Prop where\n  subobject_gt_wellFounded' : WellFounded ((· > ·) : Subobject X → Subobject X → Prop)\n\n"}
{"name":"CategoryTheory.NoetherianObject.subobject_gt_wellFounded","module":"Mathlib.CategoryTheory.Noetherian","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\nX : C\ninst✝ : CategoryTheory.NoetherianObject X\n⊢ WellFounded fun x1 x2 => GT.gt x1 x2","decl":"lemma NoetherianObject.subobject_gt_wellFounded (X : C) [NoetherianObject X] :\n    WellFounded ((· > ·) : Subobject X → Subobject X → Prop) :=\n  NoetherianObject.subobject_gt_wellFounded'\n\n"}
{"name":"CategoryTheory.ArtinianObject.subobject_lt_wellFounded'","module":"Mathlib.CategoryTheory.Noetherian","initialProofState":"C : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} C\nX : C\nself : CategoryTheory.ArtinianObject X\n⊢ WellFounded fun x1 x2 => LT.lt x1 x2","decl":"/-- An artinian object is an object\nwhich does not have infinite decreasing sequences of subobjects. -/\n@[stacks 0FCF]\nclass ArtinianObject (X : C) : Prop where\n  subobject_lt_wellFounded' : WellFounded ((· < ·) : Subobject X → Subobject X → Prop)\n\n"}
{"name":"CategoryTheory.ArtinianObject.subobject_lt_wellFounded","module":"Mathlib.CategoryTheory.Noetherian","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\nX : C\ninst✝ : CategoryTheory.ArtinianObject X\n⊢ WellFounded fun x1 x2 => LT.lt x1 x2","decl":"lemma ArtinianObject.subobject_lt_wellFounded (X : C) [ArtinianObject X] :\n    WellFounded ((· < ·) : Subobject X → Subobject X → Prop) :=\n  ArtinianObject.subobject_lt_wellFounded'\n\n"}
{"name":"CategoryTheory.Noetherian.noetherianObject","module":"Mathlib.CategoryTheory.Noetherian","initialProofState":"C : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} C\nself : CategoryTheory.Noetherian C\nX : C\n⊢ CategoryTheory.NoetherianObject X","decl":"/-- A category is noetherian if it is essentially small and all objects are noetherian. -/\nclass Noetherian extends EssentiallySmall C : Prop where\n  noetherianObject : ∀ X : C, NoetherianObject X\n\n"}
{"name":"CategoryTheory.Noetherian.toEssentiallySmall","module":"Mathlib.CategoryTheory.Noetherian","initialProofState":"C : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} C\nself : CategoryTheory.Noetherian C\n⊢ CategoryTheory.EssentiallySmall.{u_3, u_2, u_1} C","decl":"/-- A category is noetherian if it is essentially small and all objects are noetherian. -/\nclass Noetherian extends EssentiallySmall C : Prop where\n  noetherianObject : ∀ X : C, NoetherianObject X\n\n"}
{"name":"CategoryTheory.Artinian.artinianObject","module":"Mathlib.CategoryTheory.Noetherian","initialProofState":"C : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} C\nself : CategoryTheory.Artinian C\nX : C\n⊢ CategoryTheory.ArtinianObject X","decl":"/-- A category is artinian if it is essentially small and all objects are artinian. -/\nclass Artinian extends EssentiallySmall C : Prop where\n  artinianObject : ∀ X : C, ArtinianObject X\n\n"}
{"name":"CategoryTheory.Artinian.toEssentiallySmall","module":"Mathlib.CategoryTheory.Noetherian","initialProofState":"C : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} C\nself : CategoryTheory.Artinian C\n⊢ CategoryTheory.EssentiallySmall.{u_3, u_2, u_1} C","decl":"/-- A category is artinian if it is essentially small and all objects are artinian. -/\nclass Artinian extends EssentiallySmall C : Prop where\n  artinianObject : ∀ X : C, ArtinianObject X\n\n"}
{"name":"CategoryTheory.exists_simple_subobject","module":"Mathlib.CategoryTheory.Noetherian","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_2, u_1} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝¹ : CategoryTheory.Limits.HasZeroObject C\nX : C\ninst✝ : CategoryTheory.ArtinianObject X\nh : Not (CategoryTheory.Limits.IsZero X)\n⊢ Exists fun Y => CategoryTheory.Simple (CategoryTheory.Subobject.underlying.obj Y)","decl":"theorem exists_simple_subobject {X : C} [ArtinianObject X] (h : ¬IsZero X) :\n    ∃ Y : Subobject X, Simple (Y : C) := by\n  haveI : Nontrivial (Subobject X) := nontrivial_of_not_isZero h\n  haveI := isAtomic_of_orderBot_wellFounded_lt (ArtinianObject.subobject_lt_wellFounded X)\n  obtain ⟨Y, s⟩ := (IsAtomic.eq_bot_or_exists_atom_le (⊤ : Subobject X)).resolve_left top_ne_bot\n  exact ⟨Y, (subobject_simple_iff_isAtom _).mpr s.1⟩\n\n"}
{"name":"CategoryTheory.mono_simpleSubobjectArrow","module":"Mathlib.CategoryTheory.Noetherian","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_2, u_1} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝¹ : CategoryTheory.Limits.HasZeroObject C\nX : C\ninst✝ : CategoryTheory.ArtinianObject X\nh : Not (CategoryTheory.Limits.IsZero X)\n⊢ CategoryTheory.Mono (CategoryTheory.simpleSubobjectArrow h)","decl":"instance mono_simpleSubobjectArrow {X : C} [ArtinianObject X] (h : ¬IsZero X) :\n    Mono (simpleSubobjectArrow h) := by\n  dsimp only [simpleSubobjectArrow]\n  infer_instance\n\n"}
{"name":"CategoryTheory.instSimpleSimpleSubobject","module":"Mathlib.CategoryTheory.Noetherian","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_2, u_1} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝¹ : CategoryTheory.Limits.HasZeroObject C\nX : C\ninst✝ : CategoryTheory.ArtinianObject X\nh : Not (CategoryTheory.Limits.IsZero X)\n⊢ CategoryTheory.Simple (CategoryTheory.simpleSubobject h)","decl":"instance {X : C} [ArtinianObject X] (h : ¬IsZero X) : Simple (simpleSubobject h) :=\n  (exists_simple_subobject h).choose_spec\n\n"}
