{"name":"LinearOrder.isPredArchimedean_of_isSuccArchimedean","module":"Mathlib.Order.SuccPred.LinearLocallyFinite","initialProofState":"ι : Type u_1\ninst✝³ : LinearOrder ι\ninst✝² : SuccOrder ι\ninst✝¹ : PredOrder ι\ninst✝ : IsSuccArchimedean ι\n⊢ IsPredArchimedean ι","decl":"instance (priority := 100) isPredArchimedean_of_isSuccArchimedean [IsSuccArchimedean ι] :\n    IsPredArchimedean ι where\n  exists_pred_iterate_of_le {i j} hij := by\n    have h_exists := exists_succ_iterate_of_le hij\n    obtain ⟨n, hn_eq, hn_lt_ne⟩ : ∃ n, succ^[n] i = j ∧ ∀ m < n, succ^[m] i ≠ j :=\n      ⟨Nat.find h_exists, Nat.find_spec h_exists, fun m hmn ↦ Nat.find_min h_exists hmn⟩\n    refine ⟨n, ?_⟩\n    rw [← hn_eq]\n    cases n with\n    | zero => simp only [Function.iterate_zero, id]\n    | succ n =>\n      rw [pred_succ_iterate_of_not_isMax]\n      rw [Nat.succ_sub_succ_eq_sub, tsub_zero]\n      suffices succ^[n] i < succ^[n.succ] i from not_isMax_of_lt this\n      refine lt_of_le_of_ne ?_ ?_\n      · rw [Function.iterate_succ_apply']\n        exact le_succ _\n      · rw [hn_eq]\n        exact hn_lt_ne _ (Nat.lt_succ_self n)\n\n"}
{"name":"LinearOrder.isSuccArchimedean_of_isPredArchimedean","module":"Mathlib.Order.SuccPred.LinearLocallyFinite","initialProofState":"ι : Type u_1\ninst✝³ : LinearOrder ι\ninst✝² : SuccOrder ι\ninst✝¹ : PredOrder ι\ninst✝ : IsPredArchimedean ι\n⊢ IsSuccArchimedean ι","decl":"instance isSuccArchimedean_of_isPredArchimedean [IsPredArchimedean ι] : IsSuccArchimedean ι :=\n  inferInstanceAs (IsSuccArchimedean ιᵒᵈᵒᵈ)\n\n"}
{"name":"LinearOrder.isSuccArchimedean_iff_isPredArchimedean","module":"Mathlib.Order.SuccPred.LinearLocallyFinite","initialProofState":"ι : Type u_1\ninst✝² : LinearOrder ι\ninst✝¹ : SuccOrder ι\ninst✝ : PredOrder ι\n⊢ Iff (IsSuccArchimedean ι) (IsPredArchimedean ι)","decl":"/-- In a linear `SuccOrder` that's also a `PredOrder`, `IsSuccArchimedean` and `IsPredArchimedean`\nare equivalent. -/\ntheorem isSuccArchimedean_iff_isPredArchimedean : IsSuccArchimedean ι ↔ IsPredArchimedean ι where\n  mp _ := isPredArchimedean_of_isSuccArchimedean\n  mpr _ := isSuccArchimedean_of_isPredArchimedean\n\n"}
{"name":"LinearLocallyFiniteOrder.succFn_spec","module":"Mathlib.Order.SuccPred.LinearLocallyFinite","initialProofState":"ι : Type u_1\ninst✝ : LinearOrder ι\ni : ι\n⊢ IsGLB (Set.Ioi i) (LinearLocallyFiniteOrder.succFn i)","decl":"theorem succFn_spec (i : ι) : IsGLB (Set.Ioi i) (succFn i) :=\n  (exists_glb_Ioi i).choose_spec\n\n"}
{"name":"LinearLocallyFiniteOrder.le_succFn","module":"Mathlib.Order.SuccPred.LinearLocallyFinite","initialProofState":"ι : Type u_1\ninst✝ : LinearOrder ι\ni : ι\n⊢ LE.le i (LinearLocallyFiniteOrder.succFn i)","decl":"theorem le_succFn (i : ι) : i ≤ succFn i := by\n  rw [le_isGLB_iff (succFn_spec i), mem_lowerBounds]\n  exact fun x hx ↦ le_of_lt hx\n\n"}
{"name":"LinearLocallyFiniteOrder.isGLB_Ioc_of_isGLB_Ioi","module":"Mathlib.Order.SuccPred.LinearLocallyFinite","initialProofState":"ι : Type u_1\ninst✝ : LinearOrder ι\ni j k : ι\nhij_lt : LT.lt i j\nh : IsGLB (Set.Ioi i) k\n⊢ IsGLB (Set.Ioc i j) k","decl":"theorem isGLB_Ioc_of_isGLB_Ioi {i j k : ι} (hij_lt : i < j) (h : IsGLB (Set.Ioi i) k) :\n    IsGLB (Set.Ioc i j) k := by\n  simp_rw [IsGLB, IsGreatest, mem_upperBounds, mem_lowerBounds] at h ⊢\n  refine ⟨fun x hx ↦ h.1 x hx.1, fun x hx ↦ h.2 x ?_⟩\n  intro y hy\n  rcases le_or_lt y j with h_le | h_lt\n  · exact hx y ⟨hy, h_le⟩\n  · exact le_trans (hx j ⟨hij_lt, le_rfl⟩) h_lt.le\n\n"}
{"name":"LinearLocallyFiniteOrder.isMax_of_succFn_le","module":"Mathlib.Order.SuccPred.LinearLocallyFinite","initialProofState":"ι : Type u_1\ninst✝¹ : LinearOrder ι\ninst✝ : LocallyFiniteOrder ι\ni : ι\nhi : LE.le (LinearLocallyFiniteOrder.succFn i) i\n⊢ IsMax i","decl":"theorem isMax_of_succFn_le [LocallyFiniteOrder ι] (i : ι) (hi : succFn i ≤ i) : IsMax i := by\n  refine fun j _ ↦ not_lt.mp fun hij_lt ↦ ?_\n  have h_succFn_eq : succFn i = i := le_antisymm hi (le_succFn i)\n  have h_glb : IsGLB (Finset.Ioc i j : Set ι) i := by\n    rw [Finset.coe_Ioc]\n    have h := succFn_spec i\n    rw [h_succFn_eq] at h\n    exact isGLB_Ioc_of_isGLB_Ioi hij_lt h\n  have hi_mem : i ∈ Finset.Ioc i j := by\n    refine Finset.isGLB_mem _ h_glb ?_\n    exact ⟨_, Finset.mem_Ioc.mpr ⟨hij_lt, le_rfl⟩⟩\n  rw [Finset.mem_Ioc] at hi_mem\n  exact lt_irrefl i hi_mem.1\n\n"}
{"name":"LinearLocallyFiniteOrder.succFn_le_of_lt","module":"Mathlib.Order.SuccPred.LinearLocallyFinite","initialProofState":"ι : Type u_1\ninst✝ : LinearOrder ι\ni j : ι\nhij : LT.lt i j\n⊢ LE.le (LinearLocallyFiniteOrder.succFn i) j","decl":"theorem succFn_le_of_lt (i j : ι) (hij : i < j) : succFn i ≤ j := by\n  have h := succFn_spec i\n  rw [IsGLB, IsGreatest, mem_lowerBounds] at h\n  exact h.1 j hij\n\n"}
{"name":"LinearLocallyFiniteOrder.le_of_lt_succFn","module":"Mathlib.Order.SuccPred.LinearLocallyFinite","initialProofState":"ι : Type u_1\ninst✝ : LinearOrder ι\nj i : ι\nhij : LT.lt j (LinearLocallyFiniteOrder.succFn i)\n⊢ LE.le j i","decl":"theorem le_of_lt_succFn (j i : ι) (hij : j < succFn i) : j ≤ i := by\n  rw [lt_isGLB_iff (succFn_spec i)] at hij\n  obtain ⟨k, hk_lb, hk⟩ := hij\n  rw [mem_lowerBounds] at hk_lb\n  exact not_lt.mp fun hi_lt_j ↦ not_le.mpr hk (hk_lb j hi_lt_j)\n\n"}
{"name":"LinearLocallyFiniteOrder.instIsSuccArchimedeanOfLocallyFiniteOrder","module":"Mathlib.Order.SuccPred.LinearLocallyFinite","initialProofState":"ι : Type u_1\ninst✝² : LinearOrder ι\ninst✝¹ : LocallyFiniteOrder ι\ninst✝ : SuccOrder ι\n⊢ IsSuccArchimedean ι","decl":"instance (priority := 100) [LocallyFiniteOrder ι] [SuccOrder ι] : IsSuccArchimedean ι where\n  exists_succ_iterate_of_le := by\n    intro i j hij\n    rw [le_iff_lt_or_eq] at hij\n    cases' hij with hij hij\n    swap\n    · refine ⟨0, ?_⟩\n      simpa only [Function.iterate_zero, id] using hij\n    by_contra! h\n    have h_lt : ∀ n, succ^[n] i < j := by\n      intro n\n      induction' n with n hn\n      · simpa only [Function.iterate_zero, id] using hij\n      · refine lt_of_le_of_ne ?_ (h _)\n        rw [Function.iterate_succ', Function.comp_apply]\n        exact succ_le_of_lt hn\n    have h_mem : ∀ n, succ^[n] i ∈ Finset.Icc i j :=\n      fun n ↦ Finset.mem_Icc.mpr ⟨le_succ_iterate n i, (h_lt n).le⟩\n    obtain ⟨n, m, hnm, h_eq⟩ : ∃ n m, n < m ∧ succ^[n] i = succ^[m] i := by\n      let f : ℕ → Finset.Icc i j := fun n ↦ ⟨succ^[n] i, h_mem n⟩\n      obtain ⟨n, m, hnm_ne, hfnm⟩ : ∃ n m, n ≠ m ∧ f n = f m :=\n        Finite.exists_ne_map_eq_of_infinite f\n      have hnm_eq : succ^[n] i = succ^[m] i := by simpa only [f, Subtype.mk_eq_mk] using hfnm\n      rcases le_total n m with h_le | h_le\n      · exact ⟨n, m, lt_of_le_of_ne h_le hnm_ne, hnm_eq⟩\n      · exact ⟨m, n, lt_of_le_of_ne h_le hnm_ne.symm, hnm_eq.symm⟩\n    have h_max : IsMax (succ^[n] i) := isMax_iterate_succ_of_eq_of_ne h_eq hnm.ne\n    exact not_le.mpr (h_lt n) (h_max (h_lt n).le)\n\n"}
{"name":"LinearLocallyFiniteOrder.instIsPredArchimedeanOfLocallyFiniteOrder","module":"Mathlib.Order.SuccPred.LinearLocallyFinite","initialProofState":"ι : Type u_1\ninst✝² : LinearOrder ι\ninst✝¹ : LocallyFiniteOrder ι\ninst✝ : PredOrder ι\n⊢ IsPredArchimedean ι","decl":"instance (priority := 100) [LocallyFiniteOrder ι] [PredOrder ι] : IsPredArchimedean ι :=\n  inferInstanceAs (IsPredArchimedean ιᵒᵈᵒᵈ)\n\n"}
{"name":"toZ_of_ge","module":"Mathlib.Order.SuccPred.LinearLocallyFinite","initialProofState":"ι : Type u_1\ninst✝³ : LinearOrder ι\ninst✝² : SuccOrder ι\ninst✝¹ : IsSuccArchimedean ι\ninst✝ : PredOrder ι\ni0 i : ι\nhi : LE.le i0 i\n⊢ Eq (toZ i0 i) ↑(Nat.find ⋯)","decl":"theorem toZ_of_ge (hi : i0 ≤ i) : toZ i0 i = Nat.find (exists_succ_iterate_of_le hi) :=\n  dif_pos hi\n\n"}
{"name":"toZ_of_lt","module":"Mathlib.Order.SuccPred.LinearLocallyFinite","initialProofState":"ι : Type u_1\ninst✝³ : LinearOrder ι\ninst✝² : SuccOrder ι\ninst✝¹ : IsSuccArchimedean ι\ninst✝ : PredOrder ι\ni0 i : ι\nhi : LT.lt i i0\n⊢ Eq (toZ i0 i) (Neg.neg ↑(Nat.find ⋯))","decl":"theorem toZ_of_lt (hi : i < i0) :\n    toZ i0 i = -Nat.find (exists_pred_iterate_of_le (α := ι) hi.le) :=\n  dif_neg (not_le.mpr hi)\n\n"}
{"name":"toZ_of_eq","module":"Mathlib.Order.SuccPred.LinearLocallyFinite","initialProofState":"ι : Type u_1\ninst✝³ : LinearOrder ι\ninst✝² : SuccOrder ι\ninst✝¹ : IsSuccArchimedean ι\ninst✝ : PredOrder ι\ni0 : ι\n⊢ Eq (toZ i0 i0) 0","decl":"@[simp]\ntheorem toZ_of_eq : toZ i0 i0 = 0 := by\n  rw [toZ_of_ge le_rfl]\n  norm_cast\n  refine le_antisymm (Nat.find_le ?_) (zero_le _)\n  rw [Function.iterate_zero, id]\n\n"}
{"name":"iterate_succ_toZ","module":"Mathlib.Order.SuccPred.LinearLocallyFinite","initialProofState":"ι : Type u_1\ninst✝³ : LinearOrder ι\ninst✝² : SuccOrder ι\ninst✝¹ : IsSuccArchimedean ι\ninst✝ : PredOrder ι\ni0 i : ι\nhi : LE.le i0 i\n⊢ Eq (Nat.iterate Order.succ (toZ i0 i).toNat i0) i","decl":"theorem iterate_succ_toZ (i : ι) (hi : i0 ≤ i) : succ^[(toZ i0 i).toNat] i0 = i := by\n  rw [toZ_of_ge hi, Int.toNat_natCast]\n  exact Nat.find_spec (exists_succ_iterate_of_le hi)\n\n"}
{"name":"iterate_pred_toZ","module":"Mathlib.Order.SuccPred.LinearLocallyFinite","initialProofState":"ι : Type u_1\ninst✝³ : LinearOrder ι\ninst✝² : SuccOrder ι\ninst✝¹ : IsSuccArchimedean ι\ninst✝ : PredOrder ι\ni0 i : ι\nhi : LT.lt i i0\n⊢ Eq (Nat.iterate Order.pred (Neg.neg (toZ i0 i)).toNat i0) i","decl":"theorem iterate_pred_toZ (i : ι) (hi : i < i0) : pred^[(-toZ i0 i).toNat] i0 = i := by\n  rw [toZ_of_lt hi, neg_neg, Int.toNat_natCast]\n  exact Nat.find_spec (exists_pred_iterate_of_le hi.le)\n\n"}
{"name":"toZ_nonneg","module":"Mathlib.Order.SuccPred.LinearLocallyFinite","initialProofState":"ι : Type u_1\ninst✝³ : LinearOrder ι\ninst✝² : SuccOrder ι\ninst✝¹ : IsSuccArchimedean ι\ninst✝ : PredOrder ι\ni0 i : ι\nhi : LE.le i0 i\n⊢ LE.le 0 (toZ i0 i)","decl":"lemma toZ_nonneg (hi : i0 ≤ i) : 0 ≤ toZ i0 i := by rw [toZ_of_ge hi]; exact Int.natCast_nonneg _\n\n"}
{"name":"toZ_neg","module":"Mathlib.Order.SuccPred.LinearLocallyFinite","initialProofState":"ι : Type u_1\ninst✝³ : LinearOrder ι\ninst✝² : SuccOrder ι\ninst✝¹ : IsSuccArchimedean ι\ninst✝ : PredOrder ι\ni0 i : ι\nhi : LT.lt i i0\n⊢ LT.lt (toZ i0 i) 0","decl":"theorem toZ_neg (hi : i < i0) : toZ i0 i < 0 := by\n  refine lt_of_le_of_ne ?_ ?_\n  · rw [toZ_of_lt hi]\n    omega\n  · by_contra h\n    have h_eq := iterate_pred_toZ i hi\n    rw [← h_eq, h] at hi\n    simp only [neg_zero, Int.toNat_zero, Function.iterate_zero, id, lt_self_iff_false] at hi\n\n"}
{"name":"toZ_iterate_succ_le","module":"Mathlib.Order.SuccPred.LinearLocallyFinite","initialProofState":"ι : Type u_1\ninst✝³ : LinearOrder ι\ninst✝² : SuccOrder ι\ninst✝¹ : IsSuccArchimedean ι\ninst✝ : PredOrder ι\ni0 : ι\nn : Nat\n⊢ LE.le (toZ i0 (Nat.iterate Order.succ n i0)) ↑n","decl":"theorem toZ_iterate_succ_le (n : ℕ) : toZ i0 (succ^[n] i0) ≤ n := by\n  rw [toZ_of_ge (le_succ_iterate _ _)]\n  norm_cast\n  exact Nat.find_min' _ rfl\n\n"}
{"name":"toZ_iterate_pred_ge","module":"Mathlib.Order.SuccPred.LinearLocallyFinite","initialProofState":"ι : Type u_1\ninst✝³ : LinearOrder ι\ninst✝² : SuccOrder ι\ninst✝¹ : IsSuccArchimedean ι\ninst✝ : PredOrder ι\ni0 : ι\nn : Nat\n⊢ LE.le (Neg.neg ↑n) (toZ i0 (Nat.iterate Order.pred n i0))","decl":"theorem toZ_iterate_pred_ge (n : ℕ) : -(n : ℤ) ≤ toZ i0 (pred^[n] i0) := by\n  rcases le_or_lt i0 (pred^[n] i0) with h | h\n  · have h_eq : pred^[n] i0 = i0 := le_antisymm (pred_iterate_le _ _) h\n    rw [h_eq, toZ_of_eq]\n    omega\n  · rw [toZ_of_lt h]\n    refine Int.neg_le_neg ?_\n    norm_cast\n    exact Nat.find_min' _ rfl\n\n"}
{"name":"toZ_iterate_succ_of_not_isMax","module":"Mathlib.Order.SuccPred.LinearLocallyFinite","initialProofState":"ι : Type u_1\ninst✝³ : LinearOrder ι\ninst✝² : SuccOrder ι\ninst✝¹ : IsSuccArchimedean ι\ninst✝ : PredOrder ι\ni0 : ι\nn : Nat\nhn : Not (IsMax (Nat.iterate Order.succ n i0))\n⊢ Eq (toZ i0 (Nat.iterate Order.succ n i0)) ↑n","decl":"theorem toZ_iterate_succ_of_not_isMax (n : ℕ) (hn : ¬IsMax (succ^[n] i0)) :\n    toZ i0 (succ^[n] i0) = n := by\n  let m := (toZ i0 (succ^[n] i0)).toNat\n  have h_eq : succ^[m] i0 = succ^[n] i0 := iterate_succ_toZ _ (le_succ_iterate _ _)\n  by_cases hmn : m = n\n  · nth_rw 2 [← hmn]\n    rw [Int.toNat_eq_max, toZ_of_ge (le_succ_iterate _ _), max_eq_left]\n    exact Int.natCast_nonneg _\n  suffices IsMax (succ^[n] i0) from absurd this hn\n  exact isMax_iterate_succ_of_eq_of_ne h_eq.symm (Ne.symm hmn)\n\n"}
{"name":"toZ_iterate_pred_of_not_isMin","module":"Mathlib.Order.SuccPred.LinearLocallyFinite","initialProofState":"ι : Type u_1\ninst✝³ : LinearOrder ι\ninst✝² : SuccOrder ι\ninst✝¹ : IsSuccArchimedean ι\ninst✝ : PredOrder ι\ni0 : ι\nn : Nat\nhn : Not (IsMin (Nat.iterate Order.pred n i0))\n⊢ Eq (toZ i0 (Nat.iterate Order.pred n i0)) (Neg.neg ↑n)","decl":"theorem toZ_iterate_pred_of_not_isMin (n : ℕ) (hn : ¬IsMin (pred^[n] i0)) :\n    toZ i0 (pred^[n] i0) = -n := by\n  cases' n with n\n  · simp\n  have : pred^[n.succ] i0 < i0 := by\n    refine lt_of_le_of_ne (pred_iterate_le _ _) fun h_pred_iterate_eq ↦ hn ?_\n    have h_pred_eq_pred : pred^[n.succ] i0 = pred^[0] i0 := by\n      rwa [Function.iterate_zero, id]\n    exact isMin_iterate_pred_of_eq_of_ne h_pred_eq_pred (Nat.succ_ne_zero n)\n  let m := (-toZ i0 (pred^[n.succ] i0)).toNat\n  have h_eq : pred^[m] i0 = pred^[n.succ] i0 := iterate_pred_toZ _ this\n  by_cases hmn : m = n + 1\n  · nth_rw 2 [← hmn]\n    rw [Int.toNat_eq_max, toZ_of_lt this, max_eq_left, neg_neg]\n    rw [neg_neg]\n    exact Int.natCast_nonneg _\n  · suffices IsMin (pred^[n.succ] i0) from absurd this hn\n    exact isMin_iterate_pred_of_eq_of_ne h_eq.symm (Ne.symm hmn)\n\n"}
{"name":"le_of_toZ_le","module":"Mathlib.Order.SuccPred.LinearLocallyFinite","initialProofState":"ι : Type u_1\ninst✝³ : LinearOrder ι\ninst✝² : SuccOrder ι\ninst✝¹ : IsSuccArchimedean ι\ninst✝ : PredOrder ι\ni0 i j : ι\nh_le : LE.le (toZ i0 i) (toZ i0 j)\n⊢ LE.le i j","decl":"theorem le_of_toZ_le {j : ι} (h_le : toZ i0 i ≤ toZ i0 j) : i ≤ j := by\n  rcases le_or_lt i0 i with hi | hi <;> rcases le_or_lt i0 j with hj | hj\n  · rw [← iterate_succ_toZ i hi, ← iterate_succ_toZ j hj]\n    exact Monotone.monotone_iterate_of_le_map succ_mono (le_succ _) (Int.toNat_le_toNat h_le)\n  · exact absurd ((toZ_neg hj).trans_le (toZ_nonneg hi)) (not_lt.mpr h_le)\n  · exact hi.le.trans hj\n  · rw [← iterate_pred_toZ i hi, ← iterate_pred_toZ j hj]\n    refine Monotone.antitone_iterate_of_map_le pred_mono (pred_le _) (Int.toNat_le_toNat ?_)\n    exact Int.neg_le_neg h_le\n\n"}
{"name":"toZ_mono","module":"Mathlib.Order.SuccPred.LinearLocallyFinite","initialProofState":"ι : Type u_1\ninst✝³ : LinearOrder ι\ninst✝² : SuccOrder ι\ninst✝¹ : IsSuccArchimedean ι\ninst✝ : PredOrder ι\ni0 i j : ι\nh_le : LE.le i j\n⊢ LE.le (toZ i0 i) (toZ i0 j)","decl":"theorem toZ_mono {i j : ι} (h_le : i ≤ j) : toZ i0 i ≤ toZ i0 j := by\n  by_cases hi_max : IsMax i\n  · rw [le_antisymm h_le (hi_max h_le)]\n  by_cases hj_min : IsMin j\n  · rw [le_antisymm h_le (hj_min h_le)]\n  rcases le_or_lt i0 i with hi | hi <;> rcases le_or_lt i0 j with hj | hj\n  · let m := Nat.find (exists_succ_iterate_of_le h_le)\n    have hm : succ^[m] i = j := Nat.find_spec (exists_succ_iterate_of_le h_le)\n    have hj_eq : j = succ^[(toZ i0 i).toNat + m] i0 := by\n      rw [← hm, add_comm]\n      nth_rw 1 [← iterate_succ_toZ i hi]\n      rw [Function.iterate_add]\n      rfl\n    by_contra h\n    by_cases hm0 : m = 0\n    · rw [hm0, Function.iterate_zero, id] at hm\n      rw [hm] at h\n      exact h (le_of_eq rfl)\n    refine hi_max (max_of_succ_le (le_trans ?_ (@le_of_toZ_le _ _ _ _ _ i0 j i ?_)))\n    · have h_succ_le : succ^[(toZ i0 i).toNat + 1] i0 ≤ j := by\n        rw [hj_eq]\n        refine Monotone.monotone_iterate_of_le_map succ_mono (le_succ i0) (add_le_add_left ?_ _)\n        exact Nat.one_le_iff_ne_zero.mpr hm0\n      rwa [Function.iterate_succ', Function.comp_apply, iterate_succ_toZ i hi] at h_succ_le\n    · exact le_of_not_le h\n  · exact absurd h_le (not_le.mpr (hj.trans_le hi))\n  · exact (toZ_neg hi).le.trans (toZ_nonneg hj)\n  · let m := Nat.find (exists_pred_iterate_of_le (α := ι) h_le)\n    have hm : pred^[m] j = i := Nat.find_spec (exists_pred_iterate_of_le (α := ι) h_le)\n    have hj_eq : i = pred^[(-toZ i0 j).toNat + m] i0 := by\n      rw [← hm, add_comm]\n      nth_rw 1 [← iterate_pred_toZ j hj]\n      rw [Function.iterate_add]\n      rfl\n    by_contra h\n    by_cases hm0 : m = 0\n    · rw [hm0, Function.iterate_zero, id] at hm\n      rw [hm] at h\n      exact h (le_of_eq rfl)\n    refine hj_min (min_of_le_pred ?_)\n    refine (@le_of_toZ_le _ _ _ _ _ i0 j i ?_).trans ?_\n    · exact le_of_not_le h\n    · have h_le_pred : i ≤ pred^[(-toZ i0 j).toNat + 1] i0 := by\n        rw [hj_eq]\n        refine Monotone.antitone_iterate_of_map_le pred_mono (pred_le i0) (add_le_add_left ?_ _)\n        exact Nat.one_le_iff_ne_zero.mpr hm0\n      rwa [Function.iterate_succ', Function.comp_apply, iterate_pred_toZ j hj] at h_le_pred\n\n"}
{"name":"toZ_le_iff","module":"Mathlib.Order.SuccPred.LinearLocallyFinite","initialProofState":"ι : Type u_1\ninst✝³ : LinearOrder ι\ninst✝² : SuccOrder ι\ninst✝¹ : IsSuccArchimedean ι\ninst✝ : PredOrder ι\ni0 i j : ι\n⊢ Iff (LE.le (toZ i0 i) (toZ i0 j)) (LE.le i j)","decl":"theorem toZ_le_iff (i j : ι) : toZ i0 i ≤ toZ i0 j ↔ i ≤ j :=\n  ⟨le_of_toZ_le, toZ_mono⟩\n\n"}
{"name":"toZ_iterate_succ","module":"Mathlib.Order.SuccPred.LinearLocallyFinite","initialProofState":"ι : Type u_1\ninst✝⁴ : LinearOrder ι\ninst✝³ : SuccOrder ι\ninst✝² : IsSuccArchimedean ι\ninst✝¹ : PredOrder ι\ni0 : ι\ninst✝ : NoMaxOrder ι\nn : Nat\n⊢ Eq (toZ i0 (Nat.iterate Order.succ n i0)) ↑n","decl":"theorem toZ_iterate_succ [NoMaxOrder ι] (n : ℕ) : toZ i0 (succ^[n] i0) = n :=\n  toZ_iterate_succ_of_not_isMax n (not_isMax _)\n\n"}
{"name":"toZ_iterate_pred","module":"Mathlib.Order.SuccPred.LinearLocallyFinite","initialProofState":"ι : Type u_1\ninst✝⁴ : LinearOrder ι\ninst✝³ : SuccOrder ι\ninst✝² : IsSuccArchimedean ι\ninst✝¹ : PredOrder ι\ni0 : ι\ninst✝ : NoMinOrder ι\nn : Nat\n⊢ Eq (toZ i0 (Nat.iterate Order.pred n i0)) (Neg.neg ↑n)","decl":"theorem toZ_iterate_pred [NoMinOrder ι] (n : ℕ) : toZ i0 (pred^[n] i0) = -n :=\n  toZ_iterate_pred_of_not_isMin n (not_isMin _)\n\n"}
{"name":"injective_toZ","module":"Mathlib.Order.SuccPred.LinearLocallyFinite","initialProofState":"ι : Type u_1\ninst✝³ : LinearOrder ι\ninst✝² : SuccOrder ι\ninst✝¹ : IsSuccArchimedean ι\ninst✝ : PredOrder ι\ni0 : ι\n⊢ Function.Injective (toZ i0)","decl":"theorem injective_toZ : Function.Injective (toZ i0) :=\n  fun _ _ h ↦ le_antisymm (le_of_toZ_le h.le) (le_of_toZ_le h.symm.le)\n\n"}
{"name":"countable_of_linear_succ_pred_arch","module":"Mathlib.Order.SuccPred.LinearLocallyFinite","initialProofState":"ι : Type u_1\n⊢ Countable ι","decl":"instance (priority := 100) countable_of_linear_succ_pred_arch : Countable ι := by\n  cases' isEmpty_or_nonempty ι with _ hι\n  · infer_instance\n  · exact Countable.of_equiv _ orderIsoRangeToZOfLinearSuccPredArch.symm.toEquiv\n\n"}
{"name":"Countable.of_linearOrder_locallyFiniteOrder","module":"Mathlib.Order.SuccPred.LinearLocallyFinite","initialProofState":"ι : Type u_1\ninst✝¹ : LinearOrder ι\ninst✝ : LocallyFiniteOrder ι\n⊢ Countable ι","decl":"instance (priority := 100) Countable.of_linearOrder_locallyFiniteOrder [LocallyFiniteOrder ι] :\n    Countable ι :=\n  have := LinearLocallyFiniteOrder.succOrder ι\n  have := LinearLocallyFiniteOrder.predOrder ι\n  countable_of_linear_succ_pred_arch\n"}
