{"name":"Real.Wallis.W_succ","module":"Mathlib.Data.Real.Pi.Wallis","initialProofState":"k : Nat\n‚ä¢ Eq (Real.Wallis.W (HAdd.hAdd k 1)) (HMul.hMul (Real.Wallis.W k) (HMul.hMul (HDiv.hDiv (HAdd.hAdd (HMul.hMul 2 ‚Üëk) 2) (HAdd.hAdd (HMul.hMul 2 ‚Üëk) 1)) (HDiv.hDiv (HAdd.hAdd (HMul.hMul 2 ‚Üëk) 2) (HAdd.hAdd (HMul.hMul 2 ‚Üëk) 3))))","decl":"theorem W_succ (k : ‚Ñï) :\n    W (k + 1) = W k * ((2 * k + 2) / (2 * k + 1) * ((2 * k + 2) / (2 * k + 3))) :=\n  prod_range_succ _ _\n\n"}
{"name":"Real.Wallis.W_pos","module":"Mathlib.Data.Real.Pi.Wallis","initialProofState":"k : Nat\n‚ä¢ LT.lt 0 (Real.Wallis.W k)","decl":"theorem W_pos (k : ‚Ñï) : 0 < W k := by\n  induction' k with k hk\n  ¬∑ unfold W; simp\n  ¬∑ rw [W_succ]\n    refine mul_pos hk (mul_pos (div_pos ?_ ?_) (div_pos ?_ ?_)) <;> positivity\n\n"}
{"name":"Real.Wallis.W_eq_factorial_ratio","module":"Mathlib.Data.Real.Pi.Wallis","initialProofState":"n : Nat\n‚ä¢ Eq (Real.Wallis.W n) (HDiv.hDiv (HMul.hMul (HPow.hPow 2 (HMul.hMul 4 n)) (HPow.hPow (‚Üën.factorial) 4)) (HMul.hMul (HPow.hPow (‚Üë(HMul.hMul 2 n).factorial) 2) (HAdd.hAdd (HMul.hMul 2 ‚Üën) 1)))","decl":"theorem W_eq_factorial_ratio (n : ‚Ñï) :\n    W n = 2 ^ (4 * n) * n ! ^ 4 / ((2 * n)! ^ 2 * (2 * n + 1)) := by\n  induction' n with n IH\n  ¬∑ simp only [W, prod_range_zero, Nat.factorial_zero, mul_zero, pow_zero,\n      algebraMap.coe_one, one_pow, mul_one, algebraMap.coe_zero, zero_add, div_self, Ne,\n      one_ne_zero, not_false_iff]\n    norm_num\n  ¬∑ unfold W at IH ‚ä¢\n    rw [prod_range_succ, IH, _root_.div_mul_div_comm, _root_.div_mul_div_comm]\n    refine (div_eq_div_iff ?_ ?_).mpr ?_\n    any_goals exact ne_of_gt (by positivity)\n    simp_rw [Nat.mul_succ, Nat.factorial_succ, pow_succ]\n    push_cast\n    ring_nf\n\n"}
{"name":"Real.Wallis.W_eq_integral_sin_pow_div_integral_sin_pow","module":"Mathlib.Data.Real.Pi.Wallis","initialProofState":"k : Nat\n‚ä¢ Eq (HMul.hMul (Inv.inv (HDiv.hDiv Real.pi 2)) (Real.Wallis.W k)) (HDiv.hDiv (intervalIntegral (fun x => HPow.hPow (Real.sin x) (HAdd.hAdd (HMul.hMul 2 k) 1)) 0 Real.pi MeasureTheory.MeasureSpace.volume) (intervalIntegral (fun x => HPow.hPow (Real.sin x) (HMul.hMul 2 k)) 0 Real.pi MeasureTheory.MeasureSpace.volume))","decl":"theorem W_eq_integral_sin_pow_div_integral_sin_pow (k : ‚Ñï) : (œÄ / 2)‚Åª¬π * W k =\n    (‚à´ x : ‚Ñù in (0)..œÄ, sin x ^ (2 * k + 1)) / ‚à´ x : ‚Ñù in (0)..œÄ, sin x ^ (2 * k) := by\n  rw [integral_sin_pow_even, integral_sin_pow_odd, mul_div_mul_comm, ‚Üê prod_div_distrib, inv_div]\n  simp_rw [div_div_div_comm, div_div_eq_mul_div, mul_div_assoc]\n  rfl\n\n"}
{"name":"Real.Wallis.W_le","module":"Mathlib.Data.Real.Pi.Wallis","initialProofState":"k : Nat\n‚ä¢ LE.le (Real.Wallis.W k) (HDiv.hDiv Real.pi 2)","decl":"theorem W_le (k : ‚Ñï) : W k ‚â§ œÄ / 2 := by\n  rw [‚Üê div_le_one pi_div_two_pos, div_eq_inv_mul]\n  rw [W_eq_integral_sin_pow_div_integral_sin_pow, div_le_one (integral_sin_pow_pos _)]\n  apply integral_sin_pow_succ_le\n\n"}
{"name":"Real.Wallis.le_W","module":"Mathlib.Data.Real.Pi.Wallis","initialProofState":"k : Nat\n‚ä¢ LE.le (HMul.hMul (HDiv.hDiv (HAdd.hAdd (HMul.hMul 2 ‚Üëk) 1) (HAdd.hAdd (HMul.hMul 2 ‚Üëk) 2)) (HDiv.hDiv Real.pi 2)) (Real.Wallis.W k)","decl":"theorem le_W (k : ‚Ñï) : ((2 : ‚Ñù) * k + 1) / (2 * k + 2) * (œÄ / 2) ‚â§ W k := by\n  rw [‚Üê le_div_iff‚ÇÄ pi_div_two_pos, div_eq_inv_mul (W k) _]\n  rw [W_eq_integral_sin_pow_div_integral_sin_pow, le_div_iff‚ÇÄ (integral_sin_pow_pos _)]\n  convert integral_sin_pow_succ_le (2 * k + 1)\n  rw [integral_sin_pow (2 * k)]\n  simp\n\n"}
{"name":"Real.Wallis.tendsto_W_nhds_pi_div_two","module":"Mathlib.Data.Real.Pi.Wallis","initialProofState":"‚ä¢ Filter.Tendsto Real.Wallis.W Filter.atTop (nhds (HDiv.hDiv Real.pi 2))","decl":"theorem tendsto_W_nhds_pi_div_two : Tendsto W atTop (ùìù <| œÄ / 2) := by\n  refine tendsto_of_tendsto_of_tendsto_of_le_of_le ?_ tendsto_const_nhds le_W W_le\n  have : ùìù (œÄ / 2) = ùìù ((1 - 0) * (œÄ / 2)) := by rw [sub_zero, one_mul]\n  rw [this]\n  refine Tendsto.mul ?_ tendsto_const_nhds\n  have h : ‚àÄ n : ‚Ñï, ((2 : ‚Ñù) * n + 1) / (2 * n + 2) = 1 - 1 / (2 * n + 2) := by\n    intro n\n    rw [sub_div' _ _ _ (ne_of_gt (add_pos_of_nonneg_of_pos (mul_nonneg\n      (two_pos : 0 < (2 : ‚Ñù)).le (Nat.cast_nonneg _)) two_pos)), one_mul]\n    congr 1; ring\n  simp_rw [h]\n  refine (tendsto_const_nhds.div_atTop ?_).const_sub _\n  refine Tendsto.atTop_add ?_ tendsto_const_nhds\n  exact tendsto_natCast_atTop_atTop.const_mul_atTop two_pos\n\n"}
{"name":"Real.tendsto_prod_pi_div_two","module":"Mathlib.Data.Real.Pi.Wallis","initialProofState":"‚ä¢ Filter.Tendsto (fun k => (Finset.range k).prod fun i => HMul.hMul (HDiv.hDiv (HAdd.hAdd (HMul.hMul 2 ‚Üëi) 2) (HAdd.hAdd (HMul.hMul 2 ‚Üëi) 1)) (HDiv.hDiv (HAdd.hAdd (HMul.hMul 2 ‚Üëi) 2) (HAdd.hAdd (HMul.hMul 2 ‚Üëi) 3))) Filter.atTop (nhds (HDiv.hDiv Real.pi 2))","decl":"/-- Wallis' product formula for `œÄ / 2`. -/\ntheorem Real.tendsto_prod_pi_div_two :\n    Tendsto (fun k => ‚àè i ‚àà range k, ((2 : ‚Ñù) * i + 2) / (2 * i + 1) * ((2 * i + 2) / (2 * i + 3)))\n      atTop (ùìù (œÄ / 2)) :=\n  Real.Wallis.tendsto_W_nhds_pi_div_two\n"}
