{"name":"Quiver.Hom.op_inj","module":"Mathlib.CategoryTheory.Opposites","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : Quiver C\nX Y : C\n‚ä¢ Function.Injective Quiver.Hom.op","decl":"theorem Quiver.Hom.op_inj {X Y : C} :\n    Function.Injective (Quiver.Hom.op : (X ‚ü∂ Y) ‚Üí (Opposite.op Y ‚ü∂ Opposite.op X)) := fun _ _ H =>\n  congr_arg Quiver.Hom.unop H\n\n"}
{"name":"Quiver.Hom.unop_inj","module":"Mathlib.CategoryTheory.Opposites","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : Quiver C\nX Y : Opposite C\n‚ä¢ Function.Injective Quiver.Hom.unop","decl":"theorem Quiver.Hom.unop_inj {X Y : C·µí·µñ} :\n    Function.Injective (Quiver.Hom.unop : (X ‚ü∂ Y) ‚Üí (Opposite.unop Y ‚ü∂ Opposite.unop X)) :=\n  fun _ _ H => congr_arg Quiver.Hom.op H\n\n"}
{"name":"Quiver.Hom.unop_op","module":"Mathlib.CategoryTheory.Opposites","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : Quiver C\nX Y : C\nf : Quiver.Hom X Y\n‚ä¢ Eq f.op.unop f","decl":"@[simp]\ntheorem Quiver.Hom.unop_op {X Y : C} (f : X ‚ü∂ Y) : f.op.unop = f :=\n  rfl\n\n"}
{"name":"Quiver.Hom.unop_op'","module":"Mathlib.CategoryTheory.Opposites","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : Quiver C\nX Y : Opposite C\nx : Quiver.Hom (Opposite.unop Y) (Opposite.unop X)\n‚ä¢ Eq (Quiver.Hom.unop { unop := x }) x","decl":"@[simp]\ntheorem Quiver.Hom.unop_op' {X Y : C·µí·µñ} {x} :\n    @Quiver.Hom.unop C _ X Y no_index (Opposite.op (unop := x)) = x := rfl\n\n"}
{"name":"Quiver.Hom.op_unop","module":"Mathlib.CategoryTheory.Opposites","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : Quiver C\nX Y : Opposite C\nf : Quiver.Hom X Y\n‚ä¢ Eq f.unop.op f","decl":"@[simp]\ntheorem Quiver.Hom.op_unop {X Y : C·µí·µñ} (f : X ‚ü∂ Y) : f.unop.op = f :=\n  rfl\n\n"}
{"name":"Quiver.Hom.unop_mk","module":"Mathlib.CategoryTheory.Opposites","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : Quiver C\nX Y : Opposite C\nf : Quiver.Hom X Y\n‚ä¢ Eq (Quiver.Hom.unop { unop := f }) f","decl":"@[simp] theorem Quiver.Hom.unop_mk {X Y : C·µí·µñ} (f : X ‚ü∂ Y) : Quiver.Hom.unop {unop := f} = f := rfl\n\n"}
{"name":"CategoryTheory.op_comp","module":"Mathlib.CategoryTheory.Opposites","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y Z : C\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp f g).op (CategoryTheory.CategoryStruct.comp g.op f.op)","decl":"@[simp, reassoc]\ntheorem op_comp {X Y Z : C} {f : X ‚ü∂ Y} {g : Y ‚ü∂ Z} : (f ‚â´ g).op = g.op ‚â´ f.op :=\n  rfl\n\n"}
{"name":"CategoryTheory.op_comp_assoc","module":"Mathlib.CategoryTheory.Opposites","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y Z‚úù : C\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z‚úù\nZ : Opposite C\nh : Quiver.Hom { unop := X } Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.CategoryStruct.comp f g).op h) (CategoryTheory.CategoryStruct.comp g.op (CategoryTheory.CategoryStruct.comp f.op h))","decl":"@[simp, reassoc]\ntheorem op_comp {X Y Z : C} {f : X ‚ü∂ Y} {g : Y ‚ü∂ Z} : (f ‚â´ g).op = g.op ‚â´ f.op :=\n  rfl\n\n"}
{"name":"CategoryTheory.op_id","module":"Mathlib.CategoryTheory.Opposites","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX : C\n‚ä¢ Eq (CategoryTheory.CategoryStruct.id X).op (CategoryTheory.CategoryStruct.id { unop := X })","decl":"@[simp]\ntheorem op_id {X : C} : (ùüô X).op = ùüô (op X) :=\n  rfl\n\n"}
{"name":"CategoryTheory.unop_comp_assoc","module":"Mathlib.CategoryTheory.Opposites","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y Z‚úù : Opposite C\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z‚úù\nZ : C\nh : Quiver.Hom (Opposite.unop X) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.CategoryStruct.comp f g).unop h) (CategoryTheory.CategoryStruct.comp g.unop (CategoryTheory.CategoryStruct.comp f.unop h))","decl":"@[simp, reassoc]\ntheorem unop_comp {X Y Z : C·µí·µñ} {f : X ‚ü∂ Y} {g : Y ‚ü∂ Z} : (f ‚â´ g).unop = g.unop ‚â´ f.unop :=\n  rfl\n\n"}
{"name":"CategoryTheory.unop_comp","module":"Mathlib.CategoryTheory.Opposites","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y Z : Opposite C\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp f g).unop (CategoryTheory.CategoryStruct.comp g.unop f.unop)","decl":"@[simp, reassoc]\ntheorem unop_comp {X Y Z : C·µí·µñ} {f : X ‚ü∂ Y} {g : Y ‚ü∂ Z} : (f ‚â´ g).unop = g.unop ‚â´ f.unop :=\n  rfl\n\n"}
{"name":"CategoryTheory.unop_id","module":"Mathlib.CategoryTheory.Opposites","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX : Opposite C\n‚ä¢ Eq (CategoryTheory.CategoryStruct.id X).unop (CategoryTheory.CategoryStruct.id (Opposite.unop X))","decl":"@[simp]\ntheorem unop_id {X : C·µí·µñ} : (ùüô X).unop = ùüô (unop X) :=\n  rfl\n\n"}
{"name":"CategoryTheory.unop_id_op","module":"Mathlib.CategoryTheory.Opposites","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX : C\n‚ä¢ Eq (CategoryTheory.CategoryStruct.id { unop := X }).unop (CategoryTheory.CategoryStruct.id X)","decl":"@[simp]\ntheorem unop_id_op {X : C} : (ùüô (op X)).unop = ùüô X :=\n  rfl\n\n"}
{"name":"CategoryTheory.op_id_unop","module":"Mathlib.CategoryTheory.Opposites","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX : Opposite C\n‚ä¢ Eq (CategoryTheory.CategoryStruct.id (Opposite.unop X)).op (CategoryTheory.CategoryStruct.id X)","decl":"@[simp]\ntheorem op_id_unop {X : C·µí·µñ} : (ùüô (unop X)).op = ùüô X :=\n  rfl\n\n"}
{"name":"CategoryTheory.unopUnop_obj","module":"Mathlib.CategoryTheory.Opposites","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX : Opposite (Opposite C)\n‚ä¢ Eq ((CategoryTheory.unopUnop C).obj X) (Opposite.unop (Opposite.unop X))","decl":"/-- The functor from the double-opposite of a category to the underlying category. -/\n@[simps]\ndef unopUnop : C·µí·µñ·µí·µñ ‚•§ C where\n  obj X := unop (unop X)\n  map f := f.unop.unop\n\n"}
{"name":"CategoryTheory.unopUnop_map","module":"Mathlib.CategoryTheory.Opposites","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX‚úù Y‚úù : Opposite (Opposite C)\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.unopUnop C).map f) f.unop.unop","decl":"/-- The functor from the double-opposite of a category to the underlying category. -/\n@[simps]\ndef unopUnop : C·µí·µñ·µí·µñ ‚•§ C where\n  obj X := unop (unop X)\n  map f := f.unop.unop\n\n"}
{"name":"CategoryTheory.opOp_map","module":"Mathlib.CategoryTheory.Opposites","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX‚úù Y‚úù : C\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.opOp C).map f) f.op.op","decl":"/-- The functor from a category to its double-opposite. -/\n@[simps]\ndef opOp : C ‚•§ C·µí·µñ·µí·µñ where\n  obj X := op (op X)\n  map f := f.op.op\n\n"}
{"name":"CategoryTheory.opOp_obj","module":"Mathlib.CategoryTheory.Opposites","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX : C\n‚ä¢ Eq ((CategoryTheory.opOp C).obj X) { unop := { unop := X } }","decl":"/-- The functor from a category to its double-opposite. -/\n@[simps]\ndef opOp : C ‚•§ C·µí·µñ·µí·µñ where\n  obj X := op (op X)\n  map f := f.op.op\n\n"}
{"name":"CategoryTheory.opOpEquivalence_inverse","module":"Mathlib.CategoryTheory.Opposites","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\n‚ä¢ Eq (CategoryTheory.opOpEquivalence C).inverse (CategoryTheory.opOp C)","decl":"/-- The double opposite category is equivalent to the original. -/\n@[simps]\ndef opOpEquivalence : C·µí·µñ·µí·µñ ‚âå C where\n  functor := unopUnop C\n  inverse := opOp C\n  unitIso := Iso.refl (ùü≠ C·µí·µñ·µí·µñ)\n  counitIso := Iso.refl (opOp C ‚ãô unopUnop C)\n\n"}
{"name":"CategoryTheory.opOpEquivalence_unitIso","module":"Mathlib.CategoryTheory.Opposites","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\n‚ä¢ Eq (CategoryTheory.opOpEquivalence C).unitIso (CategoryTheory.Iso.refl (CategoryTheory.Functor.id (Opposite (Opposite C))))","decl":"/-- The double opposite category is equivalent to the original. -/\n@[simps]\ndef opOpEquivalence : C·µí·µñ·µí·µñ ‚âå C where\n  functor := unopUnop C\n  inverse := opOp C\n  unitIso := Iso.refl (ùü≠ C·µí·µñ·µí·µñ)\n  counitIso := Iso.refl (opOp C ‚ãô unopUnop C)\n\n"}
{"name":"CategoryTheory.opOpEquivalence_counitIso","module":"Mathlib.CategoryTheory.Opposites","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\n‚ä¢ Eq (CategoryTheory.opOpEquivalence C).counitIso (CategoryTheory.Iso.refl ((CategoryTheory.opOp C).comp (CategoryTheory.unopUnop C)))","decl":"/-- The double opposite category is equivalent to the original. -/\n@[simps]\ndef opOpEquivalence : C·µí·µñ·µí·µñ ‚âå C where\n  functor := unopUnop C\n  inverse := opOp C\n  unitIso := Iso.refl (ùü≠ C·µí·µñ·µí·µñ)\n  counitIso := Iso.refl (opOp C ‚ãô unopUnop C)\n\n"}
{"name":"CategoryTheory.opOpEquivalence_functor","module":"Mathlib.CategoryTheory.Opposites","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\n‚ä¢ Eq (CategoryTheory.opOpEquivalence C).functor (CategoryTheory.unopUnop C)","decl":"/-- The double opposite category is equivalent to the original. -/\n@[simps]\ndef opOpEquivalence : C·µí·µñ·µí·µñ ‚âå C where\n  functor := unopUnop C\n  inverse := opOp C\n  unitIso := Iso.refl (ùü≠ C·µí·µñ·µí·µñ)\n  counitIso := Iso.refl (opOp C ‚ãô unopUnop C)\n\n"}
{"name":"CategoryTheory.isIso_op","module":"Mathlib.CategoryTheory.Opposites","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y : C\nf : Quiver.Hom X Y\ninst‚úù : CategoryTheory.IsIso f\n‚ä¢ CategoryTheory.IsIso f.op","decl":"/-- If `f` is an isomorphism, so is `f.op` -/\ninstance isIso_op {X Y : C} (f : X ‚ü∂ Y) [IsIso f] : IsIso f.op :=\n  ‚ü®‚ü®(inv f).op, ‚ü®Quiver.Hom.unop_inj (by simp), Quiver.Hom.unop_inj (by simp)‚ü©‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.isIso_of_op","module":"Mathlib.CategoryTheory.Opposites","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y : C\nf : Quiver.Hom X Y\ninst‚úù : CategoryTheory.IsIso f.op\n‚ä¢ CategoryTheory.IsIso f","decl":"/-- If `f.op` is an isomorphism `f` must be too.\n(This cannot be an instance as it would immediately loop!)\n-/\ntheorem isIso_of_op {X Y : C} (f : X ‚ü∂ Y) [IsIso f.op] : IsIso f :=\n  ‚ü®‚ü®(inv f.op).unop, ‚ü®Quiver.Hom.op_inj (by simp), Quiver.Hom.op_inj (by simp)‚ü©‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.isIso_op_iff","module":"Mathlib.CategoryTheory.Opposites","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y : C\nf : Quiver.Hom X Y\n‚ä¢ Iff (CategoryTheory.IsIso f.op) (CategoryTheory.IsIso f)","decl":"theorem isIso_op_iff {X Y : C} (f : X ‚ü∂ Y) : IsIso f.op ‚Üî IsIso f :=\n  ‚ü®fun _ => isIso_of_op _, fun _ => inferInstance‚ü©\n\n"}
{"name":"CategoryTheory.isIso_unop_iff","module":"Mathlib.CategoryTheory.Opposites","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y : Opposite C\nf : Quiver.Hom X Y\n‚ä¢ Iff (CategoryTheory.IsIso f.unop) (CategoryTheory.IsIso f)","decl":"theorem isIso_unop_iff {X Y : C·µí·µñ} (f : X ‚ü∂ Y) : IsIso f.unop ‚Üî IsIso f := by\n  rw [‚Üê isIso_op_iff f.unop, Quiver.Hom.op_unop]\n\n"}
{"name":"CategoryTheory.isIso_unop","module":"Mathlib.CategoryTheory.Opposites","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y : Opposite C\nf : Quiver.Hom X Y\ninst‚úù : CategoryTheory.IsIso f\n‚ä¢ CategoryTheory.IsIso f.unop","decl":"instance isIso_unop {X Y : C·µí·µñ} (f : X ‚ü∂ Y) [IsIso f] : IsIso f.unop :=\n  (isIso_unop_iff _).2 inferInstance\n\n"}
{"name":"CategoryTheory.op_inv","module":"Mathlib.CategoryTheory.Opposites","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y : C\nf : Quiver.Hom X Y\ninst‚úù : CategoryTheory.IsIso f\n‚ä¢ Eq (CategoryTheory.inv f).op (CategoryTheory.inv f.op)","decl":"@[simp]\ntheorem op_inv {X Y : C} (f : X ‚ü∂ Y) [IsIso f] : (inv f).op = inv f.op := by\n  apply IsIso.eq_inv_of_hom_inv_id\n  rw [‚Üê op_comp, IsIso.inv_hom_id, op_id]\n\n"}
{"name":"CategoryTheory.unop_inv","module":"Mathlib.CategoryTheory.Opposites","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y : Opposite C\nf : Quiver.Hom X Y\ninst‚úù : CategoryTheory.IsIso f\n‚ä¢ Eq (CategoryTheory.inv f).unop (CategoryTheory.inv f.unop)","decl":"@[simp]\ntheorem unop_inv {X Y : C·µí·µñ} (f : X ‚ü∂ Y) [IsIso f] : (inv f).unop = inv f.unop := by\n  apply IsIso.eq_inv_of_hom_inv_id\n  rw [‚Üê unop_comp, IsIso.inv_hom_id, unop_id]\n\n"}
{"name":"CategoryTheory.Functor.op_obj","module":"Mathlib.CategoryTheory.Opposites","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nX : Opposite C\n‚ä¢ Eq (F.op.obj X) { unop := F.obj (Opposite.unop X) }","decl":"/-- The opposite of a functor, i.e. considering a functor `F : C ‚•§ D` as a functor `C·µí·µñ ‚•§ D·µí·µñ`.\nIn informal mathematics no distinction is made between these. -/\n@[simps]\nprotected def op (F : C ‚•§ D) : C·µí·µñ ‚•§ D·µí·µñ where\n  obj X := op (F.obj (unop X))\n  map f := (F.map f.unop).op\n\n"}
{"name":"CategoryTheory.Functor.op_map","module":"Mathlib.CategoryTheory.Opposites","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nX‚úù Y‚úù : Opposite C\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq (F.op.map f) (F.map f.unop).op","decl":"/-- The opposite of a functor, i.e. considering a functor `F : C ‚•§ D` as a functor `C·µí·µñ ‚•§ D·µí·µñ`.\nIn informal mathematics no distinction is made between these. -/\n@[simps]\nprotected def op (F : C ‚•§ D) : C·µí·µñ ‚•§ D·µí·µñ where\n  obj X := op (F.obj (unop X))\n  map f := (F.map f.unop).op\n\n"}
{"name":"CategoryTheory.Functor.unop_map","module":"Mathlib.CategoryTheory.Opposites","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor (Opposite C) (Opposite D)\nX‚úù Y‚úù : C\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq (F.unop.map f) (F.map f.op).unop","decl":"/-- Given a functor `F : C·µí·µñ ‚•§ D·µí·µñ` we can take the \"unopposite\" functor `F : C ‚•§ D`.\nIn informal mathematics no distinction is made between these.\n-/\n@[simps]\nprotected def unop (F : C·µí·µñ ‚•§ D·µí·µñ) : C ‚•§ D where\n  obj X := unop (F.obj (op X))\n  map f := (F.map f.op).unop\n\n"}
{"name":"CategoryTheory.Functor.unop_obj","module":"Mathlib.CategoryTheory.Opposites","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor (Opposite C) (Opposite D)\nX : C\n‚ä¢ Eq (F.unop.obj X) (Opposite.unop (F.obj { unop := X }))","decl":"/-- Given a functor `F : C·µí·µñ ‚•§ D·µí·µñ` we can take the \"unopposite\" functor `F : C ‚•§ D`.\nIn informal mathematics no distinction is made between these.\n-/\n@[simps]\nprotected def unop (F : C·µí·µñ ‚•§ D·µí·µñ) : C ‚•§ D where\n  obj X := unop (F.obj (op X))\n  map f := (F.map f.op).unop\n\n"}
{"name":"CategoryTheory.Functor.opUnopIso_hom_app","module":"Mathlib.CategoryTheory.Opposites","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nX : C\n‚ä¢ Eq (F.opUnopIso.hom.app X) (CategoryTheory.CategoryStruct.id (F.obj X))","decl":"/-- The isomorphism between `F.op.unop` and `F`. -/\n@[simps!]\ndef opUnopIso (F : C ‚•§ D) : F.op.unop ‚âÖ F :=\n  NatIso.ofComponents fun _ => Iso.refl _\n\n"}
{"name":"CategoryTheory.Functor.opUnopIso_inv_app","module":"Mathlib.CategoryTheory.Opposites","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nX : C\n‚ä¢ Eq (F.opUnopIso.inv.app X) (CategoryTheory.CategoryStruct.id (F.obj X))","decl":"/-- The isomorphism between `F.op.unop` and `F`. -/\n@[simps!]\ndef opUnopIso (F : C ‚•§ D) : F.op.unop ‚âÖ F :=\n  NatIso.ofComponents fun _ => Iso.refl _\n\n"}
{"name":"CategoryTheory.Functor.unopOpIso_hom_app","module":"Mathlib.CategoryTheory.Opposites","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor (Opposite C) (Opposite D)\nX : Opposite C\n‚ä¢ Eq (F.unopOpIso.hom.app X) (CategoryTheory.CategoryStruct.id (F.obj X))","decl":"/-- The isomorphism between `F.unop.op` and `F`. -/\n@[simps!]\ndef unopOpIso (F : C·µí·µñ ‚•§ D·µí·µñ) : F.unop.op ‚âÖ F :=\n  NatIso.ofComponents fun _ => Iso.refl _\n\n"}
{"name":"CategoryTheory.Functor.unopOpIso_inv_app","module":"Mathlib.CategoryTheory.Opposites","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor (Opposite C) (Opposite D)\nX : Opposite C\n‚ä¢ Eq (F.unopOpIso.inv.app X) (CategoryTheory.CategoryStruct.id (F.obj X))","decl":"/-- The isomorphism between `F.unop.op` and `F`. -/\n@[simps!]\ndef unopOpIso (F : C·µí·µñ ‚•§ D·µí·µñ) : F.unop.op ‚âÖ F :=\n  NatIso.ofComponents fun _ => Iso.refl _\n\n"}
{"name":"CategoryTheory.Functor.opHom_map_app","module":"Mathlib.CategoryTheory.Opposites","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nX‚úù Y‚úù : Opposite (CategoryTheory.Functor C D)\nŒ± : Quiver.Hom X‚úù Y‚úù\nX : Opposite C\n‚ä¢ Eq (((CategoryTheory.Functor.opHom C D).map Œ±).app X) (Œ±.unop.app (Opposite.unop X)).op","decl":"/-- Taking the opposite of a functor is functorial.\n-/\n@[simps]\ndef opHom : (C ‚•§ D)·µí·µñ ‚•§ C·µí·µñ ‚•§ D·µí·µñ where\n  obj F := (unop F).op\n  map Œ± :=\n    { app := fun X => (Œ±.unop.app (unop X)).op\n      naturality := fun _ _ f => Quiver.Hom.unop_inj (Œ±.unop.naturality f.unop).symm }\n\n"}
{"name":"CategoryTheory.Functor.opHom_obj","module":"Mathlib.CategoryTheory.Opposites","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : Opposite (CategoryTheory.Functor C D)\n‚ä¢ Eq ((CategoryTheory.Functor.opHom C D).obj F) (Opposite.unop F).op","decl":"/-- Taking the opposite of a functor is functorial.\n-/\n@[simps]\ndef opHom : (C ‚•§ D)·µí·µñ ‚•§ C·µí·µñ ‚•§ D·µí·µñ where\n  obj F := (unop F).op\n  map Œ± :=\n    { app := fun X => (Œ±.unop.app (unop X)).op\n      naturality := fun _ _ f => Quiver.Hom.unop_inj (Œ±.unop.naturality f.unop).symm }\n\n"}
{"name":"CategoryTheory.Functor.opInv_map","module":"Mathlib.CategoryTheory.Opposites","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nX‚úù Y‚úù : CategoryTheory.Functor (Opposite C) (Opposite D)\nŒ± : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.Functor.opInv C D).map Œ±) (Quiver.Hom.op { app := fun X => (Œ±.app { unop := X }).unop, naturality := ‚ãØ })","decl":"/-- Take the \"unopposite\" of a functor is functorial.\n-/\n@[simps]\ndef opInv : (C·µí·µñ ‚•§ D·µí·µñ) ‚•§ (C ‚•§ D)·µí·µñ where\n  obj F := op F.unop\n  map Œ± :=\n    Quiver.Hom.op\n      { app := fun X => (Œ±.app (op X)).unop\n        naturality := fun _ _ f => Quiver.Hom.op_inj <| (Œ±.naturality f.op).symm }\n\n"}
{"name":"CategoryTheory.Functor.opInv_obj","module":"Mathlib.CategoryTheory.Opposites","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor (Opposite C) (Opposite D)\n‚ä¢ Eq ((CategoryTheory.Functor.opInv C D).obj F) { unop := F.unop }","decl":"/-- Take the \"unopposite\" of a functor is functorial.\n-/\n@[simps]\ndef opInv : (C·µí·µñ ‚•§ D·µí·µñ) ‚•§ (C ‚•§ D)·µí·µñ where\n  obj F := op F.unop\n  map Œ± :=\n    Quiver.Hom.op\n      { app := fun X => (Œ±.app (op X)).unop\n        naturality := fun _ _ f => Quiver.Hom.op_inj <| (Œ±.naturality f.op).symm }\n\n"}
{"name":"CategoryTheory.Functor.leftOp_map","module":"Mathlib.CategoryTheory.Opposites","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C (Opposite D)\nX‚úù Y‚úù : Opposite C\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq (F.leftOp.map f) (F.map f.unop).unop","decl":"/--\nAnother variant of the opposite of functor, turning a functor `C ‚•§ D·µí·µñ` into a functor `C·µí·µñ ‚•§ D`.\nIn informal mathematics no distinction is made.\n-/\n@[simps]\nprotected def leftOp (F : C ‚•§ D·µí·µñ) : C·µí·µñ ‚•§ D where\n  obj X := unop (F.obj (unop X))\n  map f := (F.map f.unop).unop\n\n"}
{"name":"CategoryTheory.Functor.leftOp_obj","module":"Mathlib.CategoryTheory.Opposites","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C (Opposite D)\nX : Opposite C\n‚ä¢ Eq (F.leftOp.obj X) (Opposite.unop (F.obj (Opposite.unop X)))","decl":"/--\nAnother variant of the opposite of functor, turning a functor `C ‚•§ D·µí·µñ` into a functor `C·µí·µñ ‚•§ D`.\nIn informal mathematics no distinction is made.\n-/\n@[simps]\nprotected def leftOp (F : C ‚•§ D·µí·µñ) : C·µí·µñ ‚•§ D where\n  obj X := unop (F.obj (unop X))\n  map f := (F.map f.unop).unop\n\n"}
{"name":"CategoryTheory.Functor.rightOp_obj","module":"Mathlib.CategoryTheory.Opposites","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor (Opposite C) D\nX : C\n‚ä¢ Eq (F.rightOp.obj X) { unop := F.obj { unop := X } }","decl":"/--\nAnother variant of the opposite of functor, turning a functor `C·µí·µñ ‚•§ D` into a functor `C ‚•§ D·µí·µñ`.\nIn informal mathematics no distinction is made.\n-/\n@[simps]\nprotected def rightOp (F : C·µí·µñ ‚•§ D) : C ‚•§ D·µí·µñ where\n  obj X := op (F.obj (op X))\n  map f := (F.map f.op).op\n\n"}
{"name":"CategoryTheory.Functor.rightOp_map","module":"Mathlib.CategoryTheory.Opposites","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor (Opposite C) D\nX‚úù Y‚úù : C\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq (F.rightOp.map f) (F.map f.op).op","decl":"/--\nAnother variant of the opposite of functor, turning a functor `C·µí·µñ ‚•§ D` into a functor `C ‚•§ D·µí·µñ`.\nIn informal mathematics no distinction is made.\n-/\n@[simps]\nprotected def rightOp (F : C·µí·µñ ‚•§ D) : C ‚•§ D·µí·µñ where\n  obj X := op (F.obj (op X))\n  map f := (F.map f.op).op\n\n"}
{"name":"CategoryTheory.Functor.rightOp_map_unop","module":"Mathlib.CategoryTheory.Opposites","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor (Opposite C) D\nX Y : C\nf : Quiver.Hom X Y\n‚ä¢ Eq (F.rightOp.map f).unop (F.map f.op)","decl":"lemma rightOp_map_unop {F : C·µí·µñ ‚•§ D} {X Y} (f : X ‚ü∂ Y) :\n    (F.rightOp.map f).unop = F.map f.op := rfl\n\n"}
{"name":"CategoryTheory.Functor.instFullOppositeOp","module":"Mathlib.CategoryTheory.Opposites","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\ninst‚úù : F.Full\n‚ä¢ F.op.Full","decl":"instance {F : C ‚•§ D} [Full F] : Full F.op where\n  map_surjective f := ‚ü®(F.preimage f.unop).op, by simp‚ü©\n\n"}
{"name":"CategoryTheory.Functor.instFaithfulOppositeOp","module":"Mathlib.CategoryTheory.Opposites","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\ninst‚úù : F.Faithful\n‚ä¢ F.op.Faithful","decl":"instance {F : C ‚•§ D} [Faithful F] : Faithful F.op where\n  map_injective h := Quiver.Hom.unop_inj <| by simpa using map_injective F (Quiver.Hom.op_inj h)\n\n"}
{"name":"CategoryTheory.Functor.rightOp_faithful","module":"Mathlib.CategoryTheory.Opposites","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor (Opposite C) D\ninst‚úù : F.Faithful\n‚ä¢ F.rightOp.Faithful","decl":"/-- If F is faithful then the right_op of F is also faithful. -/\ninstance rightOp_faithful {F : C·µí·µñ ‚•§ D} [Faithful F] : Faithful F.rightOp where\n  map_injective h := Quiver.Hom.op_inj (map_injective F (Quiver.Hom.op_inj h))\n\n"}
{"name":"CategoryTheory.Functor.leftOp_faithful","module":"Mathlib.CategoryTheory.Opposites","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C (Opposite D)\ninst‚úù : F.Faithful\n‚ä¢ F.leftOp.Faithful","decl":"/-- If F is faithful then the left_op of F is also faithful. -/\ninstance leftOp_faithful {F : C ‚•§ D·µí·µñ} [Faithful F] : Faithful F.leftOp where\n  map_injective h := Quiver.Hom.unop_inj (map_injective F (Quiver.Hom.unop_inj h))\n\n"}
{"name":"CategoryTheory.Functor.rightOp_full","module":"Mathlib.CategoryTheory.Opposites","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor (Opposite C) D\ninst‚úù : F.Full\n‚ä¢ F.rightOp.Full","decl":"instance rightOp_full {F : C·µí·µñ ‚•§ D} [Full F] : Full F.rightOp where\n  map_surjective f := ‚ü®(F.preimage f.unop).unop, by simp‚ü©\n\n"}
{"name":"CategoryTheory.Functor.leftOp_full","module":"Mathlib.CategoryTheory.Opposites","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C (Opposite D)\ninst‚úù : F.Full\n‚ä¢ F.leftOp.Full","decl":"instance leftOp_full {F : C ‚•§ D·µí·µñ} [Full F] : Full F.leftOp where\n  map_surjective f := ‚ü®(F.preimage f.op).op, by simp‚ü©\n\n\n"}
{"name":"CategoryTheory.Functor.leftOpRightOpIso_hom_app","module":"Mathlib.CategoryTheory.Opposites","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C (Opposite D)\nX : C\n‚ä¢ Eq (F.leftOpRightOpIso.hom.app X) (CategoryTheory.CategoryStruct.id (F.obj X))","decl":"/-- The isomorphism between `F.leftOp.rightOp` and `F`. -/\n@[simps!]\ndef leftOpRightOpIso (F : C ‚•§ D·µí·µñ) : F.leftOp.rightOp ‚âÖ F :=\n  NatIso.ofComponents fun _ => Iso.refl _\n\n"}
{"name":"CategoryTheory.Functor.leftOpRightOpIso_inv_app","module":"Mathlib.CategoryTheory.Opposites","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C (Opposite D)\nX : C\n‚ä¢ Eq (F.leftOpRightOpIso.inv.app X) (CategoryTheory.CategoryStruct.id (F.obj X))","decl":"/-- The isomorphism between `F.leftOp.rightOp` and `F`. -/\n@[simps!]\ndef leftOpRightOpIso (F : C ‚•§ D·µí·µñ) : F.leftOp.rightOp ‚âÖ F :=\n  NatIso.ofComponents fun _ => Iso.refl _\n\n"}
{"name":"CategoryTheory.Functor.rightOpLeftOpIso_inv_app","module":"Mathlib.CategoryTheory.Opposites","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor (Opposite C) D\nX : Opposite C\n‚ä¢ Eq (F.rightOpLeftOpIso.inv.app X) (CategoryTheory.CategoryStruct.id (F.obj X))","decl":"/-- The isomorphism between `F.rightOp.leftOp` and `F`. -/\n@[simps!]\ndef rightOpLeftOpIso (F : C·µí·µñ ‚•§ D) : F.rightOp.leftOp ‚âÖ F :=\n  NatIso.ofComponents fun _ => Iso.refl _\n\n"}
{"name":"CategoryTheory.Functor.rightOpLeftOpIso_hom_app","module":"Mathlib.CategoryTheory.Opposites","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor (Opposite C) D\nX : Opposite C\n‚ä¢ Eq (F.rightOpLeftOpIso.hom.app X) (CategoryTheory.CategoryStruct.id (F.obj X))","decl":"/-- The isomorphism between `F.rightOp.leftOp` and `F`. -/\n@[simps!]\ndef rightOpLeftOpIso (F : C·µí·µñ ‚•§ D) : F.rightOp.leftOp ‚âÖ F :=\n  NatIso.ofComponents fun _ => Iso.refl _\n\n"}
{"name":"CategoryTheory.Functor.rightOp_leftOp_eq","module":"Mathlib.CategoryTheory.Opposites","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor (Opposite C) D\n‚ä¢ Eq F.rightOp.leftOp F","decl":"/-- Whenever possible, it is advisable to use the isomorphism `rightOpLeftOpIso`\ninstead of this equality of functors. -/\ntheorem rightOp_leftOp_eq (F : C·µí·µñ ‚•§ D) : F.rightOp.leftOp = F := by\n  cases F\n  rfl\n\n"}
{"name":"CategoryTheory.NatTrans.op_app","module":"Mathlib.CategoryTheory.Opposites","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF G : CategoryTheory.Functor C D\nŒ± : Quiver.Hom F G\nX : Opposite C\n‚ä¢ Eq ((CategoryTheory.NatTrans.op Œ±).app X) (Œ±.app (Opposite.unop X)).op","decl":"/-- The opposite of a natural transformation. -/\n@[simps]\nprotected def op (Œ± : F ‚ü∂ G) : G.op ‚ü∂ F.op where\n  app X := (Œ±.app (unop X)).op\n  naturality X Y f := Quiver.Hom.unop_inj (by simp)\n\n"}
{"name":"CategoryTheory.NatTrans.op_id","module":"Mathlib.CategoryTheory.Opposites","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\n‚ä¢ Eq (CategoryTheory.NatTrans.op (CategoryTheory.CategoryStruct.id F)) (CategoryTheory.CategoryStruct.id F.op)","decl":"@[simp]\ntheorem op_id (F : C ‚•§ D) : NatTrans.op (ùüô F) = ùüô F.op :=\n  rfl\n\n"}
{"name":"CategoryTheory.NatTrans.unop_app","module":"Mathlib.CategoryTheory.Opposites","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF G : CategoryTheory.Functor (Opposite C) (Opposite D)\nŒ± : Quiver.Hom F G\nX : C\n‚ä¢ Eq ((CategoryTheory.NatTrans.unop Œ±).app X) (Œ±.app { unop := X }).unop","decl":"/-- The \"unopposite\" of a natural transformation. -/\n@[simps]\nprotected def unop {F G : C·µí·µñ ‚•§ D·µí·µñ} (Œ± : F ‚ü∂ G) : G.unop ‚ü∂ F.unop where\n  app X := (Œ±.app (op X)).unop\n  naturality X Y f := Quiver.Hom.op_inj (by simp)\n\n"}
{"name":"CategoryTheory.NatTrans.unop_id","module":"Mathlib.CategoryTheory.Opposites","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor (Opposite C) (Opposite D)\n‚ä¢ Eq (CategoryTheory.NatTrans.unop (CategoryTheory.CategoryStruct.id F)) (CategoryTheory.CategoryStruct.id F.unop)","decl":"@[simp]\ntheorem unop_id (F : C·µí·µñ ‚•§ D·µí·µñ) : NatTrans.unop (ùüô F) = ùüô F.unop :=\n  rfl\n\n"}
{"name":"CategoryTheory.NatTrans.removeOp_app","module":"Mathlib.CategoryTheory.Opposites","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF G : CategoryTheory.Functor C D\nŒ± : Quiver.Hom F.op G.op\nX : C\n‚ä¢ Eq ((CategoryTheory.NatTrans.removeOp Œ±).app X) (Œ±.app { unop := X }).unop","decl":"/-- Given a natural transformation `Œ± : F.op ‚ü∂ G.op`,\nwe can take the \"unopposite\" of each component obtaining a natural transformation `G ‚ü∂ F`.\n-/\n@[simps]\nprotected def removeOp (Œ± : F.op ‚ü∂ G.op) : G ‚ü∂ F where\n  app X := (Œ±.app (op X)).unop\n  naturality X Y f :=\n    Quiver.Hom.op_inj <| by simpa only [Functor.op_map] using (Œ±.naturality f.op).symm\n\n"}
{"name":"CategoryTheory.NatTrans.removeOp_id","module":"Mathlib.CategoryTheory.Opposites","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\n‚ä¢ Eq (CategoryTheory.NatTrans.removeOp (CategoryTheory.CategoryStruct.id F.op)) (CategoryTheory.CategoryStruct.id F)","decl":"@[simp]\ntheorem removeOp_id (F : C ‚•§ D) : NatTrans.removeOp (ùüô F.op) = ùüô F :=\n  rfl\n\n"}
{"name":"CategoryTheory.NatTrans.removeUnop_app","module":"Mathlib.CategoryTheory.Opposites","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF G : CategoryTheory.Functor (Opposite C) (Opposite D)\nŒ± : Quiver.Hom F.unop G.unop\nX : Opposite C\n‚ä¢ Eq ((CategoryTheory.NatTrans.removeUnop Œ±).app X) (Œ±.app (Opposite.unop X)).op","decl":"/-- Given a natural transformation `Œ± : F.unop ‚ü∂ G.unop`, we can take the opposite of each\ncomponent obtaining a natural transformation `G ‚ü∂ F`. -/\n@[simps]\nprotected def removeUnop {F G : C·µí·µñ ‚•§ D·µí·µñ} (Œ± : F.unop ‚ü∂ G.unop) : G ‚ü∂ F where\n  app X := (Œ±.app (unop X)).op\n  naturality X Y f :=\n    Quiver.Hom.unop_inj <| by simpa only [Functor.unop_map] using (Œ±.naturality f.unop).symm\n\n"}
{"name":"CategoryTheory.NatTrans.removeUnop_id","module":"Mathlib.CategoryTheory.Opposites","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor (Opposite C) (Opposite D)\n‚ä¢ Eq (CategoryTheory.NatTrans.removeUnop (CategoryTheory.CategoryStruct.id F.unop)) (CategoryTheory.CategoryStruct.id F)","decl":"@[simp]\ntheorem removeUnop_id (F : C·µí·µñ ‚•§ D·µí·µñ) : NatTrans.removeUnop (ùüô F.unop) = ùüô F :=\n  rfl\n\n"}
{"name":"CategoryTheory.NatTrans.leftOp_app","module":"Mathlib.CategoryTheory.Opposites","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF G : CategoryTheory.Functor C (Opposite D)\nŒ± : Quiver.Hom F G\nX : Opposite C\n‚ä¢ Eq ((CategoryTheory.NatTrans.leftOp Œ±).app X) (Œ±.app (Opposite.unop X)).unop","decl":"/-- Given a natural transformation `Œ± : F ‚ü∂ G`, for `F G : C ‚•§ D·µí·µñ`,\ntaking `unop` of each component gives a natural transformation `G.leftOp ‚ü∂ F.leftOp`.\n-/\n@[simps]\nprotected def leftOp (Œ± : F ‚ü∂ G) : G.leftOp ‚ü∂ F.leftOp where\n  app X := (Œ±.app (unop X)).unop\n  naturality X Y f := Quiver.Hom.op_inj (by simp)\n\n"}
{"name":"CategoryTheory.NatTrans.leftOp_id","module":"Mathlib.CategoryTheory.Opposites","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C (Opposite D)\n‚ä¢ Eq (CategoryTheory.NatTrans.leftOp (CategoryTheory.CategoryStruct.id F)) (CategoryTheory.CategoryStruct.id F.leftOp)","decl":"@[simp]\ntheorem leftOp_id : NatTrans.leftOp (ùüô F : F ‚ü∂ F) = ùüô F.leftOp :=\n  rfl\n\n"}
{"name":"CategoryTheory.NatTrans.leftOp_comp","module":"Mathlib.CategoryTheory.Opposites","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF G H : CategoryTheory.Functor C (Opposite D)\nŒ± : Quiver.Hom F G\nŒ≤ : Quiver.Hom G H\n‚ä¢ Eq (CategoryTheory.NatTrans.leftOp (CategoryTheory.CategoryStruct.comp Œ± Œ≤)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.NatTrans.leftOp Œ≤) (CategoryTheory.NatTrans.leftOp Œ±))","decl":"@[simp]\ntheorem leftOp_comp (Œ± : F ‚ü∂ G) (Œ≤ : G ‚ü∂ H) : NatTrans.leftOp (Œ± ‚â´ Œ≤) =\n    NatTrans.leftOp Œ≤ ‚â´ NatTrans.leftOp Œ± :=\n  rfl\n\n"}
{"name":"CategoryTheory.NatTrans.removeLeftOp_app","module":"Mathlib.CategoryTheory.Opposites","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF G : CategoryTheory.Functor C (Opposite D)\nŒ± : Quiver.Hom F.leftOp G.leftOp\nX : C\n‚ä¢ Eq ((CategoryTheory.NatTrans.removeLeftOp Œ±).app X) (Œ±.app { unop := X }).op","decl":"/-- Given a natural transformation `Œ± : F.leftOp ‚ü∂ G.leftOp`, for `F G : C ‚•§ D·µí·µñ`,\ntaking `op` of each component gives a natural transformation `G ‚ü∂ F`.\n-/\n@[simps]\nprotected def removeLeftOp (Œ± : F.leftOp ‚ü∂ G.leftOp) : G ‚ü∂ F where\n  app X := (Œ±.app (op X)).op\n  naturality X Y f :=\n    Quiver.Hom.unop_inj <| by simpa only [Functor.leftOp_map] using (Œ±.naturality f.op).symm\n\n"}
{"name":"CategoryTheory.NatTrans.removeLeftOp_id","module":"Mathlib.CategoryTheory.Opposites","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C (Opposite D)\n‚ä¢ Eq (CategoryTheory.NatTrans.removeLeftOp (CategoryTheory.CategoryStruct.id F.leftOp)) (CategoryTheory.CategoryStruct.id F)","decl":"@[simp]\ntheorem removeLeftOp_id : NatTrans.removeLeftOp (ùüô F.leftOp) = ùüô F :=\n  rfl\n\n"}
{"name":"CategoryTheory.NatTrans.rightOp_app","module":"Mathlib.CategoryTheory.Opposites","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF G : CategoryTheory.Functor (Opposite C) D\nŒ± : Quiver.Hom F G\nx‚úù : C\n‚ä¢ Eq ((CategoryTheory.NatTrans.rightOp Œ±).app x‚úù) (Œ±.app { unop := x‚úù }).op","decl":"/-- Given a natural transformation `Œ± : F ‚ü∂ G`, for `F G : C·µí·µñ ‚•§ D`,\ntaking `op` of each component gives a natural transformation `G.rightOp ‚ü∂ F.rightOp`.\n-/\n@[simps]\nprotected def rightOp (Œ± : F ‚ü∂ G) : G.rightOp ‚ü∂ F.rightOp where\n  app _ := (Œ±.app _).op\n  naturality X Y f := Quiver.Hom.unop_inj (by simp)\n\n"}
{"name":"CategoryTheory.NatTrans.rightOp_id","module":"Mathlib.CategoryTheory.Opposites","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor (Opposite C) D\n‚ä¢ Eq (CategoryTheory.NatTrans.rightOp (CategoryTheory.CategoryStruct.id F)) (CategoryTheory.CategoryStruct.id F.rightOp)","decl":"@[simp]\ntheorem rightOp_id : NatTrans.rightOp (ùüô F : F ‚ü∂ F) = ùüô F.rightOp :=\n  rfl\n\n"}
{"name":"CategoryTheory.NatTrans.rightOp_comp","module":"Mathlib.CategoryTheory.Opposites","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF G H : CategoryTheory.Functor (Opposite C) D\nŒ± : Quiver.Hom F G\nŒ≤ : Quiver.Hom G H\n‚ä¢ Eq (CategoryTheory.NatTrans.rightOp (CategoryTheory.CategoryStruct.comp Œ± Œ≤)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.NatTrans.rightOp Œ≤) (CategoryTheory.NatTrans.rightOp Œ±))","decl":"@[simp]\ntheorem rightOp_comp (Œ± : F ‚ü∂ G) (Œ≤ : G ‚ü∂ H) : NatTrans.rightOp (Œ± ‚â´ Œ≤) =\n    NatTrans.rightOp Œ≤ ‚â´ NatTrans.rightOp Œ± :=\n  rfl\n\n"}
{"name":"CategoryTheory.NatTrans.removeRightOp_app","module":"Mathlib.CategoryTheory.Opposites","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF G : CategoryTheory.Functor (Opposite C) D\nŒ± : Quiver.Hom F.rightOp G.rightOp\nX : Opposite C\n‚ä¢ Eq ((CategoryTheory.NatTrans.removeRightOp Œ±).app X) (Œ±.app (Opposite.unop X)).unop","decl":"/-- Given a natural transformation `Œ± : F.rightOp ‚ü∂ G.rightOp`, for `F G : C·µí·µñ ‚•§ D`,\ntaking `unop` of each component gives a natural transformation `G ‚ü∂ F`.\n-/\n@[simps]\nprotected def removeRightOp (Œ± : F.rightOp ‚ü∂ G.rightOp) : G ‚ü∂ F where\n  app X := (Œ±.app X.unop).unop\n  naturality X Y f :=\n    Quiver.Hom.op_inj <| by simpa only [Functor.rightOp_map] using (Œ±.naturality f.unop).symm\n\n"}
{"name":"CategoryTheory.NatTrans.removeRightOp_id","module":"Mathlib.CategoryTheory.Opposites","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor (Opposite C) D\n‚ä¢ Eq (CategoryTheory.NatTrans.removeRightOp (CategoryTheory.CategoryStruct.id F.rightOp)) (CategoryTheory.CategoryStruct.id F)","decl":"@[simp]\ntheorem removeRightOp_id : NatTrans.removeRightOp (ùüô F.rightOp) = ùüô F :=\n  rfl\n\n"}
{"name":"CategoryTheory.Iso.op_inv","module":"Mathlib.CategoryTheory.Opposites","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y : C\nŒ± : CategoryTheory.Iso X Y\n‚ä¢ Eq Œ±.op.inv Œ±.inv.op","decl":"/-- The opposite isomorphism.\n-/\n@[simps]\nprotected def op (Œ± : X ‚âÖ Y) : op Y ‚âÖ op X where\n  hom := Œ±.hom.op\n  inv := Œ±.inv.op\n  hom_inv_id := Quiver.Hom.unop_inj Œ±.inv_hom_id\n  inv_hom_id := Quiver.Hom.unop_inj Œ±.hom_inv_id\n\n"}
{"name":"CategoryTheory.Iso.op_hom","module":"Mathlib.CategoryTheory.Opposites","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y : C\nŒ± : CategoryTheory.Iso X Y\n‚ä¢ Eq Œ±.op.hom Œ±.hom.op","decl":"/-- The opposite isomorphism.\n-/\n@[simps]\nprotected def op (Œ± : X ‚âÖ Y) : op Y ‚âÖ op X where\n  hom := Œ±.hom.op\n  inv := Œ±.inv.op\n  hom_inv_id := Quiver.Hom.unop_inj Œ±.inv_hom_id\n  inv_hom_id := Quiver.Hom.unop_inj Œ±.hom_inv_id\n\n"}
{"name":"CategoryTheory.Iso.unop_hom","module":"Mathlib.CategoryTheory.Opposites","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y : Opposite C\nf : CategoryTheory.Iso X Y\n‚ä¢ Eq f.unop.hom f.hom.unop","decl":"/-- The isomorphism obtained from an isomorphism in the opposite category. -/\n@[simps]\ndef unop {X Y : C·µí·µñ} (f : X ‚âÖ Y) : Y.unop ‚âÖ X.unop where\n  hom := f.hom.unop\n  inv := f.inv.unop\n  hom_inv_id := by simp only [‚Üê unop_comp, f.inv_hom_id, unop_id]\n  inv_hom_id := by simp only [‚Üê unop_comp, f.hom_inv_id, unop_id]\n\n"}
{"name":"CategoryTheory.Iso.unop_inv","module":"Mathlib.CategoryTheory.Opposites","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y : Opposite C\nf : CategoryTheory.Iso X Y\n‚ä¢ Eq f.unop.inv f.inv.unop","decl":"/-- The isomorphism obtained from an isomorphism in the opposite category. -/\n@[simps]\ndef unop {X Y : C·µí·µñ} (f : X ‚âÖ Y) : Y.unop ‚âÖ X.unop where\n  hom := f.hom.unop\n  inv := f.inv.unop\n  hom_inv_id := by simp only [‚Üê unop_comp, f.inv_hom_id, unop_id]\n  inv_hom_id := by simp only [‚Üê unop_comp, f.hom_inv_id, unop_id]\n\n"}
{"name":"CategoryTheory.Iso.unop_op","module":"Mathlib.CategoryTheory.Opposites","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y : Opposite C\nf : CategoryTheory.Iso X Y\n‚ä¢ Eq f.unop.op f","decl":"@[simp]\ntheorem unop_op {X Y : C·µí·µñ} (f : X ‚âÖ Y) : f.unop.op = f := by (ext; rfl)\n\n"}
{"name":"CategoryTheory.Iso.op_unop","module":"Mathlib.CategoryTheory.Opposites","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y : C\nf : CategoryTheory.Iso X Y\n‚ä¢ Eq f.op.unop f","decl":"@[simp]\ntheorem op_unop {X Y : C} (f : X ‚âÖ Y) : f.op.unop = f := by (ext; rfl)\n\n"}
{"name":"CategoryTheory.Iso.unop_hom_inv_id_app","module":"Mathlib.CategoryTheory.Opposites","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} D\nF G : CategoryTheory.Functor C (Opposite D)\ne : CategoryTheory.Iso F G\nX : C\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (e.hom.app X).unop (e.inv.app X).unop) (CategoryTheory.CategoryStruct.id (Opposite.unop (G.obj X)))","decl":"@[reassoc (attr := simp)]\nlemma unop_hom_inv_id_app : (e.hom.app X).unop ‚â´ (e.inv.app X).unop = ùüô _ := by\n  rw [‚Üê unop_comp, inv_hom_id_app, unop_id]\n\n"}
{"name":"CategoryTheory.Iso.unop_hom_inv_id_app_assoc","module":"Mathlib.CategoryTheory.Opposites","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} D\nF G : CategoryTheory.Functor C (Opposite D)\ne : CategoryTheory.Iso F G\nX : C\nZ : D\nh : Quiver.Hom (Opposite.unop (G.obj X)) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (e.hom.app X).unop (CategoryTheory.CategoryStruct.comp (e.inv.app X).unop h)) h","decl":"@[reassoc (attr := simp)]\nlemma unop_hom_inv_id_app : (e.hom.app X).unop ‚â´ (e.inv.app X).unop = ùüô _ := by\n  rw [‚Üê unop_comp, inv_hom_id_app, unop_id]\n\n"}
{"name":"CategoryTheory.Iso.unop_inv_hom_id_app_assoc","module":"Mathlib.CategoryTheory.Opposites","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} D\nF G : CategoryTheory.Functor C (Opposite D)\ne : CategoryTheory.Iso F G\nX : C\nZ : D\nh : Quiver.Hom (Opposite.unop (F.obj X)) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (e.inv.app X).unop (CategoryTheory.CategoryStruct.comp (e.hom.app X).unop h)) h","decl":"@[reassoc (attr := simp)]\nlemma unop_inv_hom_id_app : (e.inv.app X).unop ‚â´ (e.hom.app X).unop = ùüô _ := by\n  rw [‚Üê unop_comp, hom_inv_id_app, unop_id]\n\n"}
{"name":"CategoryTheory.Iso.unop_inv_hom_id_app","module":"Mathlib.CategoryTheory.Opposites","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} D\nF G : CategoryTheory.Functor C (Opposite D)\ne : CategoryTheory.Iso F G\nX : C\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (e.inv.app X).unop (e.hom.app X).unop) (CategoryTheory.CategoryStruct.id (Opposite.unop (F.obj X)))","decl":"@[reassoc (attr := simp)]\nlemma unop_inv_hom_id_app : (e.inv.app X).unop ‚â´ (e.hom.app X).unop = ùüô _ := by\n  rw [‚Üê unop_comp, hom_inv_id_app, unop_id]\n\n"}
{"name":"CategoryTheory.NatIso.op_inv","module":"Mathlib.CategoryTheory.Opposites","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF G : CategoryTheory.Functor C D\nŒ± : CategoryTheory.Iso F G\n‚ä¢ Eq (CategoryTheory.NatIso.op Œ±).inv (CategoryTheory.NatTrans.op Œ±.inv)","decl":"/-- The natural isomorphism between opposite functors `G.op ‚âÖ F.op` induced by a natural\nisomorphism between the original functors `F ‚âÖ G`. -/\n@[simps]\nprotected def op (Œ± : F ‚âÖ G) : G.op ‚âÖ F.op where\n  hom := NatTrans.op Œ±.hom\n  inv := NatTrans.op Œ±.inv\n  hom_inv_id := by ext; dsimp; rw [‚Üê op_comp]; rw [Œ±.inv_hom_id_app]; rfl\n  inv_hom_id := by ext; dsimp; rw [‚Üê op_comp]; rw [Œ±.hom_inv_id_app]; rfl\n\n"}
{"name":"CategoryTheory.NatIso.op_hom","module":"Mathlib.CategoryTheory.Opposites","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF G : CategoryTheory.Functor C D\nŒ± : CategoryTheory.Iso F G\n‚ä¢ Eq (CategoryTheory.NatIso.op Œ±).hom (CategoryTheory.NatTrans.op Œ±.hom)","decl":"/-- The natural isomorphism between opposite functors `G.op ‚âÖ F.op` induced by a natural\nisomorphism between the original functors `F ‚âÖ G`. -/\n@[simps]\nprotected def op (Œ± : F ‚âÖ G) : G.op ‚âÖ F.op where\n  hom := NatTrans.op Œ±.hom\n  inv := NatTrans.op Œ±.inv\n  hom_inv_id := by ext; dsimp; rw [‚Üê op_comp]; rw [Œ±.inv_hom_id_app]; rfl\n  inv_hom_id := by ext; dsimp; rw [‚Üê op_comp]; rw [Œ±.hom_inv_id_app]; rfl\n\n"}
{"name":"CategoryTheory.NatIso.removeOp_inv","module":"Mathlib.CategoryTheory.Opposites","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF G : CategoryTheory.Functor C D\nŒ± : CategoryTheory.Iso F.op G.op\n‚ä¢ Eq (CategoryTheory.NatIso.removeOp Œ±).inv (CategoryTheory.NatTrans.removeOp Œ±.inv)","decl":"/-- The natural isomorphism between functors `G ‚âÖ F` induced by a natural isomorphism\nbetween the opposite functors `F.op ‚âÖ G.op`. -/\n@[simps]\nprotected def removeOp (Œ± : F.op ‚âÖ G.op) : G ‚âÖ F where\n  hom := NatTrans.removeOp Œ±.hom\n  inv := NatTrans.removeOp Œ±.inv\n\n"}
{"name":"CategoryTheory.NatIso.removeOp_hom","module":"Mathlib.CategoryTheory.Opposites","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF G : CategoryTheory.Functor C D\nŒ± : CategoryTheory.Iso F.op G.op\n‚ä¢ Eq (CategoryTheory.NatIso.removeOp Œ±).hom (CategoryTheory.NatTrans.removeOp Œ±.hom)","decl":"/-- The natural isomorphism between functors `G ‚âÖ F` induced by a natural isomorphism\nbetween the opposite functors `F.op ‚âÖ G.op`. -/\n@[simps]\nprotected def removeOp (Œ± : F.op ‚âÖ G.op) : G ‚âÖ F where\n  hom := NatTrans.removeOp Œ±.hom\n  inv := NatTrans.removeOp Œ±.inv\n\n"}
{"name":"CategoryTheory.NatIso.unop_hom","module":"Mathlib.CategoryTheory.Opposites","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF G : CategoryTheory.Functor (Opposite C) (Opposite D)\nŒ± : CategoryTheory.Iso F G\n‚ä¢ Eq (CategoryTheory.NatIso.unop Œ±).hom (CategoryTheory.NatTrans.unop Œ±.hom)","decl":"/-- The natural isomorphism between functors `G.unop ‚âÖ F.unop` induced by a natural isomorphism\nbetween the original functors `F ‚âÖ G`. -/\n@[simps]\nprotected def unop {F G : C·µí·µñ ‚•§ D·µí·µñ} (Œ± : F ‚âÖ G) : G.unop ‚âÖ F.unop where\n  hom := NatTrans.unop Œ±.hom\n  inv := NatTrans.unop Œ±.inv\n\n"}
{"name":"CategoryTheory.NatIso.unop_inv","module":"Mathlib.CategoryTheory.Opposites","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF G : CategoryTheory.Functor (Opposite C) (Opposite D)\nŒ± : CategoryTheory.Iso F G\n‚ä¢ Eq (CategoryTheory.NatIso.unop Œ±).inv (CategoryTheory.NatTrans.unop Œ±.inv)","decl":"/-- The natural isomorphism between functors `G.unop ‚âÖ F.unop` induced by a natural isomorphism\nbetween the original functors `F ‚âÖ G`. -/\n@[simps]\nprotected def unop {F G : C·µí·µñ ‚•§ D·µí·µñ} (Œ± : F ‚âÖ G) : G.unop ‚âÖ F.unop where\n  hom := NatTrans.unop Œ±.hom\n  inv := NatTrans.unop Œ±.inv\n\n"}
{"name":"CategoryTheory.Equivalence.op_counitIso","module":"Mathlib.CategoryTheory.Opposites","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ne : CategoryTheory.Equivalence C D\n‚ä¢ Eq e.op.counitIso (CategoryTheory.NatIso.op e.counitIso).symm","decl":"/-- An equivalence between categories gives an equivalence between the opposite categories.\n-/\n@[simps]\ndef op (e : C ‚âå D) : C·µí·µñ ‚âå D·µí·µñ where\n  functor := e.functor.op\n  inverse := e.inverse.op\n  unitIso := (NatIso.op e.unitIso).symm\n  counitIso := (NatIso.op e.counitIso).symm\n  functor_unitIso_comp X := by\n    apply Quiver.Hom.unop_inj\n    dsimp\n    simp\n\n"}
{"name":"CategoryTheory.Equivalence.op_inverse","module":"Mathlib.CategoryTheory.Opposites","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ne : CategoryTheory.Equivalence C D\n‚ä¢ Eq e.op.inverse e.inverse.op","decl":"/-- An equivalence between categories gives an equivalence between the opposite categories.\n-/\n@[simps]\ndef op (e : C ‚âå D) : C·µí·µñ ‚âå D·µí·µñ where\n  functor := e.functor.op\n  inverse := e.inverse.op\n  unitIso := (NatIso.op e.unitIso).symm\n  counitIso := (NatIso.op e.counitIso).symm\n  functor_unitIso_comp X := by\n    apply Quiver.Hom.unop_inj\n    dsimp\n    simp\n\n"}
{"name":"CategoryTheory.Equivalence.op_unitIso","module":"Mathlib.CategoryTheory.Opposites","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ne : CategoryTheory.Equivalence C D\n‚ä¢ Eq e.op.unitIso (CategoryTheory.NatIso.op e.unitIso).symm","decl":"/-- An equivalence between categories gives an equivalence between the opposite categories.\n-/\n@[simps]\ndef op (e : C ‚âå D) : C·µí·µñ ‚âå D·µí·µñ where\n  functor := e.functor.op\n  inverse := e.inverse.op\n  unitIso := (NatIso.op e.unitIso).symm\n  counitIso := (NatIso.op e.counitIso).symm\n  functor_unitIso_comp X := by\n    apply Quiver.Hom.unop_inj\n    dsimp\n    simp\n\n"}
{"name":"CategoryTheory.Equivalence.op_functor","module":"Mathlib.CategoryTheory.Opposites","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ne : CategoryTheory.Equivalence C D\n‚ä¢ Eq e.op.functor e.functor.op","decl":"/-- An equivalence between categories gives an equivalence between the opposite categories.\n-/\n@[simps]\ndef op (e : C ‚âå D) : C·µí·µñ ‚âå D·µí·µñ where\n  functor := e.functor.op\n  inverse := e.inverse.op\n  unitIso := (NatIso.op e.unitIso).symm\n  counitIso := (NatIso.op e.counitIso).symm\n  functor_unitIso_comp X := by\n    apply Quiver.Hom.unop_inj\n    dsimp\n    simp\n\n"}
{"name":"CategoryTheory.Equivalence.unop_inverse","module":"Mathlib.CategoryTheory.Opposites","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ne : CategoryTheory.Equivalence (Opposite C) (Opposite D)\n‚ä¢ Eq e.unop.inverse e.inverse.unop","decl":"/-- An equivalence between opposite categories gives an equivalence between the original categories.\n-/\n@[simps]\ndef unop (e : C·µí·µñ ‚âå D·µí·µñ) : C ‚âå D where\n  functor := e.functor.unop\n  inverse := e.inverse.unop\n  unitIso := (NatIso.unop e.unitIso).symm\n  counitIso := (NatIso.unop e.counitIso).symm\n  functor_unitIso_comp X := by\n    apply Quiver.Hom.op_inj\n    dsimp\n    simp\n\n"}
{"name":"CategoryTheory.Equivalence.unop_counitIso","module":"Mathlib.CategoryTheory.Opposites","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ne : CategoryTheory.Equivalence (Opposite C) (Opposite D)\n‚ä¢ Eq e.unop.counitIso (CategoryTheory.NatIso.unop e.counitIso).symm","decl":"/-- An equivalence between opposite categories gives an equivalence between the original categories.\n-/\n@[simps]\ndef unop (e : C·µí·µñ ‚âå D·µí·µñ) : C ‚âå D where\n  functor := e.functor.unop\n  inverse := e.inverse.unop\n  unitIso := (NatIso.unop e.unitIso).symm\n  counitIso := (NatIso.unop e.counitIso).symm\n  functor_unitIso_comp X := by\n    apply Quiver.Hom.op_inj\n    dsimp\n    simp\n\n"}
{"name":"CategoryTheory.Equivalence.unop_functor","module":"Mathlib.CategoryTheory.Opposites","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ne : CategoryTheory.Equivalence (Opposite C) (Opposite D)\n‚ä¢ Eq e.unop.functor e.functor.unop","decl":"/-- An equivalence between opposite categories gives an equivalence between the original categories.\n-/\n@[simps]\ndef unop (e : C·µí·µñ ‚âå D·µí·µñ) : C ‚âå D where\n  functor := e.functor.unop\n  inverse := e.inverse.unop\n  unitIso := (NatIso.unop e.unitIso).symm\n  counitIso := (NatIso.unop e.counitIso).symm\n  functor_unitIso_comp X := by\n    apply Quiver.Hom.op_inj\n    dsimp\n    simp\n\n"}
{"name":"CategoryTheory.Equivalence.unop_unitIso","module":"Mathlib.CategoryTheory.Opposites","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ne : CategoryTheory.Equivalence (Opposite C) (Opposite D)\n‚ä¢ Eq e.unop.unitIso (CategoryTheory.NatIso.unop e.unitIso).symm","decl":"/-- An equivalence between opposite categories gives an equivalence between the original categories.\n-/\n@[simps]\ndef unop (e : C·µí·µñ ‚âå D·µí·µñ) : C ‚âå D where\n  functor := e.functor.unop\n  inverse := e.inverse.unop\n  unitIso := (NatIso.unop e.unitIso).symm\n  counitIso := (NatIso.unop e.counitIso).symm\n  functor_unitIso_comp X := by\n    apply Quiver.Hom.op_inj\n    dsimp\n    simp\n\n"}
{"name":"CategoryTheory.opEquiv_apply","module":"Mathlib.CategoryTheory.Opposites","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nA B : Opposite C\nf : Quiver.Hom A B\n‚ä¢ Eq ((CategoryTheory.opEquiv A B) f) f.unop","decl":"/-- The equivalence between arrows of the form `A ‚ü∂ B` and `B.unop ‚ü∂ A.unop`. Useful for building\nadjunctions.\nNote that this (definitionally) gives variants\n```\ndef opEquiv' (A : C) (B : C·µí·µñ) : (Opposite.op A ‚ü∂ B) ‚âÉ (B.unop ‚ü∂ A) :=\n  opEquiv _ _\n\ndef opEquiv'' (A : C·µí·µñ) (B : C) : (A ‚ü∂ Opposite.op B) ‚âÉ (B ‚ü∂ A.unop) :=\n  opEquiv _ _\n\ndef opEquiv''' (A B : C) : (Opposite.op A ‚ü∂ Opposite.op B) ‚âÉ (B ‚ü∂ A) :=\n  opEquiv _ _\n```\n-/\n@[simps]\ndef opEquiv (A B : C·µí·µñ) : (A ‚ü∂ B) ‚âÉ (B.unop ‚ü∂ A.unop) where\n  toFun f := f.unop\n  invFun g := g.op\n  left_inv _ := rfl\n  right_inv _ := rfl\n\n"}
{"name":"CategoryTheory.opEquiv_symm_apply","module":"Mathlib.CategoryTheory.Opposites","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nA B : Opposite C\ng : Quiver.Hom (Opposite.unop B) (Opposite.unop A)\n‚ä¢ Eq ((CategoryTheory.opEquiv A B).symm g) g.op","decl":"/-- The equivalence between arrows of the form `A ‚ü∂ B` and `B.unop ‚ü∂ A.unop`. Useful for building\nadjunctions.\nNote that this (definitionally) gives variants\n```\ndef opEquiv' (A : C) (B : C·µí·µñ) : (Opposite.op A ‚ü∂ B) ‚âÉ (B.unop ‚ü∂ A) :=\n  opEquiv _ _\n\ndef opEquiv'' (A : C·µí·µñ) (B : C) : (A ‚ü∂ Opposite.op B) ‚âÉ (B ‚ü∂ A.unop) :=\n  opEquiv _ _\n\ndef opEquiv''' (A B : C) : (Opposite.op A ‚ü∂ Opposite.op B) ‚âÉ (B ‚ü∂ A) :=\n  opEquiv _ _\n```\n-/\n@[simps]\ndef opEquiv (A B : C·µí·µñ) : (A ‚ü∂ B) ‚âÉ (B.unop ‚ü∂ A.unop) where\n  toFun f := f.unop\n  invFun g := g.op\n  left_inv _ := rfl\n  right_inv _ := rfl\n\n"}
{"name":"CategoryTheory.subsingleton_of_unop","module":"Mathlib.CategoryTheory.Opposites","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nA B : Opposite C\ninst‚úù : Subsingleton (Quiver.Hom (Opposite.unop B) (Opposite.unop A))\n‚ä¢ Subsingleton (Quiver.Hom A B)","decl":"instance subsingleton_of_unop (A B : C·µí·µñ) [Subsingleton (unop B ‚ü∂ unop A)] : Subsingleton (A ‚ü∂ B) :=\n  (opEquiv A B).subsingleton\n\n"}
{"name":"CategoryTheory.isoOpEquiv_apply","module":"Mathlib.CategoryTheory.Opposites","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nA B : Opposite C\nf : CategoryTheory.Iso A B\n‚ä¢ Eq ((CategoryTheory.isoOpEquiv A B) f) f.unop","decl":"/-- The equivalence between isomorphisms of the form `A ‚âÖ B` and `B.unop ‚âÖ A.unop`.\n\nNote this is definitionally the same as the other three variants:\n* `(Opposite.op A ‚âÖ B) ‚âÉ (B.unop ‚âÖ A)`\n* `(A ‚âÖ Opposite.op B) ‚âÉ (B ‚âÖ A.unop)`\n* `(Opposite.op A ‚âÖ Opposite.op B) ‚âÉ (B ‚âÖ A)`\n-/\n@[simps]\ndef isoOpEquiv (A B : C·µí·µñ) : (A ‚âÖ B) ‚âÉ (B.unop ‚âÖ A.unop) where\n  toFun f := f.unop\n  invFun g := g.op\n  left_inv _ := by\n    ext\n    rfl\n  right_inv _ := by\n    ext\n    rfl\n\n"}
{"name":"CategoryTheory.isoOpEquiv_symm_apply","module":"Mathlib.CategoryTheory.Opposites","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nA B : Opposite C\ng : CategoryTheory.Iso (Opposite.unop B) (Opposite.unop A)\n‚ä¢ Eq ((CategoryTheory.isoOpEquiv A B).symm g) g.op","decl":"/-- The equivalence between isomorphisms of the form `A ‚âÖ B` and `B.unop ‚âÖ A.unop`.\n\nNote this is definitionally the same as the other three variants:\n* `(Opposite.op A ‚âÖ B) ‚âÉ (B.unop ‚âÖ A)`\n* `(A ‚âÖ Opposite.op B) ‚âÉ (B ‚âÖ A.unop)`\n* `(Opposite.op A ‚âÖ Opposite.op B) ‚âÉ (B ‚âÖ A)`\n-/\n@[simps]\ndef isoOpEquiv (A B : C·µí·µñ) : (A ‚âÖ B) ‚âÉ (B.unop ‚âÖ A.unop) where\n  toFun f := f.unop\n  invFun g := g.op\n  left_inv _ := by\n    ext\n    rfl\n  right_inv _ := by\n    ext\n    rfl\n\n"}
{"name":"CategoryTheory.Functor.opUnopEquiv_unitIso","module":"Mathlib.CategoryTheory.Opposites","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\n‚ä¢ Eq (CategoryTheory.Functor.opUnopEquiv C D).unitIso (CategoryTheory.NatIso.ofComponents (fun F => (Opposite.unop F).opUnopIso.op) ‚ãØ)","decl":"/-- The equivalence of functor categories induced by `op` and `unop`.\n-/\n@[simps]\ndef opUnopEquiv : (C ‚•§ D)·µí·µñ ‚âå C·µí·µñ ‚•§ D·µí·µñ where\n  functor := opHom _ _\n  inverse := opInv _ _\n  unitIso :=\n    NatIso.ofComponents (fun F => F.unop.opUnopIso.op)\n      (by\n        intro F G f\n        dsimp [opUnopIso]\n        rw [show f = f.unop.op by simp, ‚Üê op_comp, ‚Üê op_comp]\n        congr 1\n        aesop_cat)\n  counitIso := NatIso.ofComponents fun F => F.unopOpIso\n\n"}
{"name":"CategoryTheory.Functor.opUnopEquiv_inverse","module":"Mathlib.CategoryTheory.Opposites","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\n‚ä¢ Eq (CategoryTheory.Functor.opUnopEquiv C D).inverse (CategoryTheory.Functor.opInv C D)","decl":"/-- The equivalence of functor categories induced by `op` and `unop`.\n-/\n@[simps]\ndef opUnopEquiv : (C ‚•§ D)·µí·µñ ‚âå C·µí·µñ ‚•§ D·µí·µñ where\n  functor := opHom _ _\n  inverse := opInv _ _\n  unitIso :=\n    NatIso.ofComponents (fun F => F.unop.opUnopIso.op)\n      (by\n        intro F G f\n        dsimp [opUnopIso]\n        rw [show f = f.unop.op by simp, ‚Üê op_comp, ‚Üê op_comp]\n        congr 1\n        aesop_cat)\n  counitIso := NatIso.ofComponents fun F => F.unopOpIso\n\n"}
{"name":"CategoryTheory.Functor.opUnopEquiv_counitIso","module":"Mathlib.CategoryTheory.Opposites","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\n‚ä¢ Eq (CategoryTheory.Functor.opUnopEquiv C D).counitIso (CategoryTheory.NatIso.ofComponents (fun F => F.unopOpIso) ‚ãØ)","decl":"/-- The equivalence of functor categories induced by `op` and `unop`.\n-/\n@[simps]\ndef opUnopEquiv : (C ‚•§ D)·µí·µñ ‚âå C·µí·µñ ‚•§ D·µí·µñ where\n  functor := opHom _ _\n  inverse := opInv _ _\n  unitIso :=\n    NatIso.ofComponents (fun F => F.unop.opUnopIso.op)\n      (by\n        intro F G f\n        dsimp [opUnopIso]\n        rw [show f = f.unop.op by simp, ‚Üê op_comp, ‚Üê op_comp]\n        congr 1\n        aesop_cat)\n  counitIso := NatIso.ofComponents fun F => F.unopOpIso\n\n"}
{"name":"CategoryTheory.Functor.opUnopEquiv_functor","module":"Mathlib.CategoryTheory.Opposites","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\n‚ä¢ Eq (CategoryTheory.Functor.opUnopEquiv C D).functor (CategoryTheory.Functor.opHom C D)","decl":"/-- The equivalence of functor categories induced by `op` and `unop`.\n-/\n@[simps]\ndef opUnopEquiv : (C ‚•§ D)·µí·µñ ‚âå C·µí·µñ ‚•§ D·µí·µñ where\n  functor := opHom _ _\n  inverse := opInv _ _\n  unitIso :=\n    NatIso.ofComponents (fun F => F.unop.opUnopIso.op)\n      (by\n        intro F G f\n        dsimp [opUnopIso]\n        rw [show f = f.unop.op by simp, ‚Üê op_comp, ‚Üê op_comp]\n        congr 1\n        aesop_cat)\n  counitIso := NatIso.ofComponents fun F => F.unopOpIso\n\n"}
{"name":"CategoryTheory.Functor.leftOpRightOpEquiv_unitIso_hom_app","module":"Mathlib.CategoryTheory.Opposites","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nX : Opposite (CategoryTheory.Functor (Opposite C) D)\n‚ä¢ Eq ((CategoryTheory.Functor.leftOpRightOpEquiv C D).unitIso.hom.app X) (Opposite.unop X).rightOpLeftOpIso.hom.op","decl":"/-- The equivalence of functor categories induced by `leftOp` and `rightOp`.\n-/\n@[simps!]\ndef leftOpRightOpEquiv : (C·µí·µñ ‚•§ D)·µí·µñ ‚âå C ‚•§ D·µí·µñ where\n  functor :=\n    { obj := fun F => F.unop.rightOp\n      map := fun Œ∑ => NatTrans.rightOp Œ∑.unop }\n  inverse :=\n    { obj := fun F => op F.leftOp\n      map := fun Œ∑ => Œ∑.leftOp.op }\n  unitIso :=\n    NatIso.ofComponents (fun F => F.unop.rightOpLeftOpIso.op)\n      (by\n        intro F G Œ∑\n        dsimp\n        rw [show Œ∑ = Œ∑.unop.op by simp, ‚Üê op_comp, ‚Üê op_comp]\n        congr 1\n        aesop_cat)\n  counitIso := NatIso.ofComponents fun F => F.leftOpRightOpIso\n\n"}
{"name":"CategoryTheory.Functor.leftOpRightOpEquiv_functor_obj_map","module":"Mathlib.CategoryTheory.Opposites","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : Opposite (CategoryTheory.Functor (Opposite C) D)\nX‚úù Y‚úù : C\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq (((CategoryTheory.Functor.leftOpRightOpEquiv C D).functor.obj F).map f) ((Opposite.unop F).map f.op).op","decl":"/-- The equivalence of functor categories induced by `leftOp` and `rightOp`.\n-/\n@[simps!]\ndef leftOpRightOpEquiv : (C·µí·µñ ‚•§ D)·µí·µñ ‚âå C ‚•§ D·µí·µñ where\n  functor :=\n    { obj := fun F => F.unop.rightOp\n      map := fun Œ∑ => NatTrans.rightOp Œ∑.unop }\n  inverse :=\n    { obj := fun F => op F.leftOp\n      map := fun Œ∑ => Œ∑.leftOp.op }\n  unitIso :=\n    NatIso.ofComponents (fun F => F.unop.rightOpLeftOpIso.op)\n      (by\n        intro F G Œ∑\n        dsimp\n        rw [show Œ∑ = Œ∑.unop.op by simp, ‚Üê op_comp, ‚Üê op_comp]\n        congr 1\n        aesop_cat)\n  counitIso := NatIso.ofComponents fun F => F.leftOpRightOpIso\n\n"}
{"name":"CategoryTheory.Functor.leftOpRightOpEquiv_functor_map_app","module":"Mathlib.CategoryTheory.Opposites","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nX‚úù Y‚úù : Opposite (CategoryTheory.Functor (Opposite C) D)\nŒ∑ : Quiver.Hom X‚úù Y‚úù\nx‚úù : C\n‚ä¢ Eq (((CategoryTheory.Functor.leftOpRightOpEquiv C D).functor.map Œ∑).app x‚úù) (Œ∑.unop.app { unop := x‚úù }).op","decl":"/-- The equivalence of functor categories induced by `leftOp` and `rightOp`.\n-/\n@[simps!]\ndef leftOpRightOpEquiv : (C·µí·µñ ‚•§ D)·µí·µñ ‚âå C ‚•§ D·µí·µñ where\n  functor :=\n    { obj := fun F => F.unop.rightOp\n      map := fun Œ∑ => NatTrans.rightOp Œ∑.unop }\n  inverse :=\n    { obj := fun F => op F.leftOp\n      map := fun Œ∑ => Œ∑.leftOp.op }\n  unitIso :=\n    NatIso.ofComponents (fun F => F.unop.rightOpLeftOpIso.op)\n      (by\n        intro F G Œ∑\n        dsimp\n        rw [show Œ∑ = Œ∑.unop.op by simp, ‚Üê op_comp, ‚Üê op_comp]\n        congr 1\n        aesop_cat)\n  counitIso := NatIso.ofComponents fun F => F.leftOpRightOpIso\n\n"}
{"name":"CategoryTheory.Functor.leftOpRightOpEquiv_functor_obj_obj","module":"Mathlib.CategoryTheory.Opposites","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : Opposite (CategoryTheory.Functor (Opposite C) D)\nX : C\n‚ä¢ Eq (((CategoryTheory.Functor.leftOpRightOpEquiv C D).functor.obj F).obj X) { unop := (Opposite.unop F).obj { unop := X } }","decl":"/-- The equivalence of functor categories induced by `leftOp` and `rightOp`.\n-/\n@[simps!]\ndef leftOpRightOpEquiv : (C·µí·µñ ‚•§ D)·µí·µñ ‚âå C ‚•§ D·µí·µñ where\n  functor :=\n    { obj := fun F => F.unop.rightOp\n      map := fun Œ∑ => NatTrans.rightOp Œ∑.unop }\n  inverse :=\n    { obj := fun F => op F.leftOp\n      map := fun Œ∑ => Œ∑.leftOp.op }\n  unitIso :=\n    NatIso.ofComponents (fun F => F.unop.rightOpLeftOpIso.op)\n      (by\n        intro F G Œ∑\n        dsimp\n        rw [show Œ∑ = Œ∑.unop.op by simp, ‚Üê op_comp, ‚Üê op_comp]\n        congr 1\n        aesop_cat)\n  counitIso := NatIso.ofComponents fun F => F.leftOpRightOpIso\n\n"}
{"name":"CategoryTheory.Functor.leftOpRightOpEquiv_inverse_map","module":"Mathlib.CategoryTheory.Opposites","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nX‚úù Y‚úù : CategoryTheory.Functor C (Opposite D)\nŒ∑ : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.Functor.leftOpRightOpEquiv C D).inverse.map Œ∑) (CategoryTheory.NatTrans.leftOp Œ∑).op","decl":"/-- The equivalence of functor categories induced by `leftOp` and `rightOp`.\n-/\n@[simps!]\ndef leftOpRightOpEquiv : (C·µí·µñ ‚•§ D)·µí·µñ ‚âå C ‚•§ D·µí·µñ where\n  functor :=\n    { obj := fun F => F.unop.rightOp\n      map := fun Œ∑ => NatTrans.rightOp Œ∑.unop }\n  inverse :=\n    { obj := fun F => op F.leftOp\n      map := fun Œ∑ => Œ∑.leftOp.op }\n  unitIso :=\n    NatIso.ofComponents (fun F => F.unop.rightOpLeftOpIso.op)\n      (by\n        intro F G Œ∑\n        dsimp\n        rw [show Œ∑ = Œ∑.unop.op by simp, ‚Üê op_comp, ‚Üê op_comp]\n        congr 1\n        aesop_cat)\n  counitIso := NatIso.ofComponents fun F => F.leftOpRightOpIso\n\n"}
{"name":"CategoryTheory.Functor.leftOpRightOpEquiv_counitIso_hom_app_app","module":"Mathlib.CategoryTheory.Opposites","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nX‚úù : CategoryTheory.Functor C (Opposite D)\nX : C\n‚ä¢ Eq (((CategoryTheory.Functor.leftOpRightOpEquiv C D).counitIso.hom.app X‚úù).app X) (CategoryTheory.CategoryStruct.id (X‚úù.obj X))","decl":"/-- The equivalence of functor categories induced by `leftOp` and `rightOp`.\n-/\n@[simps!]\ndef leftOpRightOpEquiv : (C·µí·µñ ‚•§ D)·µí·µñ ‚âå C ‚•§ D·µí·µñ where\n  functor :=\n    { obj := fun F => F.unop.rightOp\n      map := fun Œ∑ => NatTrans.rightOp Œ∑.unop }\n  inverse :=\n    { obj := fun F => op F.leftOp\n      map := fun Œ∑ => Œ∑.leftOp.op }\n  unitIso :=\n    NatIso.ofComponents (fun F => F.unop.rightOpLeftOpIso.op)\n      (by\n        intro F G Œ∑\n        dsimp\n        rw [show Œ∑ = Œ∑.unop.op by simp, ‚Üê op_comp, ‚Üê op_comp]\n        congr 1\n        aesop_cat)\n  counitIso := NatIso.ofComponents fun F => F.leftOpRightOpIso\n\n"}
{"name":"CategoryTheory.Functor.leftOpRightOpEquiv_unitIso_inv_app","module":"Mathlib.CategoryTheory.Opposites","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nX : Opposite (CategoryTheory.Functor (Opposite C) D)\n‚ä¢ Eq ((CategoryTheory.Functor.leftOpRightOpEquiv C D).unitIso.inv.app X) (Opposite.unop X).rightOpLeftOpIso.inv.op","decl":"/-- The equivalence of functor categories induced by `leftOp` and `rightOp`.\n-/\n@[simps!]\ndef leftOpRightOpEquiv : (C·µí·µñ ‚•§ D)·µí·µñ ‚âå C ‚•§ D·µí·µñ where\n  functor :=\n    { obj := fun F => F.unop.rightOp\n      map := fun Œ∑ => NatTrans.rightOp Œ∑.unop }\n  inverse :=\n    { obj := fun F => op F.leftOp\n      map := fun Œ∑ => Œ∑.leftOp.op }\n  unitIso :=\n    NatIso.ofComponents (fun F => F.unop.rightOpLeftOpIso.op)\n      (by\n        intro F G Œ∑\n        dsimp\n        rw [show Œ∑ = Œ∑.unop.op by simp, ‚Üê op_comp, ‚Üê op_comp]\n        congr 1\n        aesop_cat)\n  counitIso := NatIso.ofComponents fun F => F.leftOpRightOpIso\n\n"}
{"name":"CategoryTheory.Functor.leftOpRightOpEquiv_inverse_obj","module":"Mathlib.CategoryTheory.Opposites","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C (Opposite D)\n‚ä¢ Eq ((CategoryTheory.Functor.leftOpRightOpEquiv C D).inverse.obj F) { unop := F.leftOp }","decl":"/-- The equivalence of functor categories induced by `leftOp` and `rightOp`.\n-/\n@[simps!]\ndef leftOpRightOpEquiv : (C·µí·µñ ‚•§ D)·µí·µñ ‚âå C ‚•§ D·µí·µñ where\n  functor :=\n    { obj := fun F => F.unop.rightOp\n      map := fun Œ∑ => NatTrans.rightOp Œ∑.unop }\n  inverse :=\n    { obj := fun F => op F.leftOp\n      map := fun Œ∑ => Œ∑.leftOp.op }\n  unitIso :=\n    NatIso.ofComponents (fun F => F.unop.rightOpLeftOpIso.op)\n      (by\n        intro F G Œ∑\n        dsimp\n        rw [show Œ∑ = Œ∑.unop.op by simp, ‚Üê op_comp, ‚Üê op_comp]\n        congr 1\n        aesop_cat)\n  counitIso := NatIso.ofComponents fun F => F.leftOpRightOpIso\n\n"}
{"name":"CategoryTheory.Functor.leftOpRightOpEquiv_counitIso_inv_app_app","module":"Mathlib.CategoryTheory.Opposites","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nX‚úù : CategoryTheory.Functor C (Opposite D)\nX : C\n‚ä¢ Eq (((CategoryTheory.Functor.leftOpRightOpEquiv C D).counitIso.inv.app X‚úù).app X) (CategoryTheory.CategoryStruct.id (X‚úù.obj X))","decl":"/-- The equivalence of functor categories induced by `leftOp` and `rightOp`.\n-/\n@[simps!]\ndef leftOpRightOpEquiv : (C·µí·µñ ‚•§ D)·µí·µñ ‚âå C ‚•§ D·µí·µñ where\n  functor :=\n    { obj := fun F => F.unop.rightOp\n      map := fun Œ∑ => NatTrans.rightOp Œ∑.unop }\n  inverse :=\n    { obj := fun F => op F.leftOp\n      map := fun Œ∑ => Œ∑.leftOp.op }\n  unitIso :=\n    NatIso.ofComponents (fun F => F.unop.rightOpLeftOpIso.op)\n      (by\n        intro F G Œ∑\n        dsimp\n        rw [show Œ∑ = Œ∑.unop.op by simp, ‚Üê op_comp, ‚Üê op_comp]\n        congr 1\n        aesop_cat)\n  counitIso := NatIso.ofComponents fun F => F.leftOpRightOpIso\n\n"}
{"name":"CategoryTheory.Functor.instEssSurjOppositeOp","module":"Mathlib.CategoryTheory.Opposites","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\ninst‚úù : F.EssSurj\n‚ä¢ F.op.EssSurj","decl":"instance {F : C ‚•§ D} [EssSurj F] : EssSurj F.op where\n  mem_essImage X := ‚ü®op _, ‚ü®(F.objObjPreimageIso X.unop).op.symm‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.Functor.instEssSurjOppositeRightOp","module":"Mathlib.CategoryTheory.Opposites","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor (Opposite C) D\ninst‚úù : F.EssSurj\n‚ä¢ F.rightOp.EssSurj","decl":"instance {F : C·µí·µñ ‚•§ D} [EssSurj F] : EssSurj F.rightOp where\n  mem_essImage X := ‚ü®_, ‚ü®(F.objObjPreimageIso X.unop).op.symm‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.Functor.instEssSurjOppositeLeftOp","module":"Mathlib.CategoryTheory.Opposites","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C (Opposite D)\ninst‚úù : F.EssSurj\n‚ä¢ F.leftOp.EssSurj","decl":"instance {F : C ‚•§ D·µí·µñ} [EssSurj F] : EssSurj F.leftOp where\n  mem_essImage X := ‚ü®op _, ‚ü®(F.objObjPreimageIso (op X)).unop.symm‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.Functor.instIsEquivalenceOppositeOp","module":"Mathlib.CategoryTheory.Opposites","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\ninst‚úù : F.IsEquivalence\n‚ä¢ F.op.IsEquivalence","decl":"instance {F : C ‚•§ D} [IsEquivalence F] : IsEquivalence F.op where\n\n"}
{"name":"CategoryTheory.Functor.instIsEquivalenceOppositeRightOp","module":"Mathlib.CategoryTheory.Opposites","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor (Opposite C) D\ninst‚úù : F.IsEquivalence\n‚ä¢ F.rightOp.IsEquivalence","decl":"instance {F : C·µí·µñ ‚•§ D} [IsEquivalence F] : IsEquivalence F.rightOp where\n\n"}
{"name":"CategoryTheory.Functor.instIsEquivalenceOppositeLeftOp","module":"Mathlib.CategoryTheory.Opposites","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C (Opposite D)\ninst‚úù : F.IsEquivalence\n‚ä¢ F.leftOp.IsEquivalence","decl":"instance {F : C ‚•§ D·µí·µñ} [IsEquivalence F] : IsEquivalence F.leftOp where\n\n"}
