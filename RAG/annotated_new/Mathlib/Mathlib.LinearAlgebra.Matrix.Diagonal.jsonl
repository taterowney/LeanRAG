{"name":"Matrix.proj_diagonal","module":"Mathlib.LinearAlgebra.Matrix.Diagonal","initialProofState":"n : Type u_1\ninst✝² : Fintype n\ninst✝¹ : DecidableEq n\nR : Type v\ninst✝ : CommSemiring R\ni : n\nw : n → R\n⊢ Eq ((LinearMap.proj i).comp (Matrix.toLin' (Matrix.diagonal w))) (HSMul.hSMul (w i) (LinearMap.proj i))","decl":"theorem proj_diagonal (i : n) (w : n → R) : (proj i).comp (toLin' (diagonal w)) = w i • proj i :=\n  LinearMap.ext fun _ => mulVec_diagonal _ _ _\n\n"}
{"name":"Matrix.diagonal_comp_single","module":"Mathlib.LinearAlgebra.Matrix.Diagonal","initialProofState":"n : Type u_1\ninst✝² : Fintype n\ninst✝¹ : DecidableEq n\nR : Type v\ninst✝ : CommSemiring R\nw : n → R\ni : n\n⊢ Eq ((Matrix.toLin' (Matrix.diagonal w)).comp (LinearMap.single R (fun x => R) i)) (HSMul.hSMul (w i) (LinearMap.single R (fun x => R) i))","decl":"theorem diagonal_comp_single (w : n → R) (i : n) :\n    (diagonal w).toLin'.comp (LinearMap.single R (fun _ : n => R) i) =\n      w i • LinearMap.single R (fun _ : n => R) i :=\n  LinearMap.ext fun x => (diagonal_mulVec_single w _ _).trans (Pi.single_smul' i (w i) x)\n\n"}
{"name":"Matrix.diagonal_comp_stdBasis","module":"Mathlib.LinearAlgebra.Matrix.Diagonal","initialProofState":"n : Type u_1\ninst✝² : Fintype n\ninst✝¹ : DecidableEq n\nR : Type v\ninst✝ : CommSemiring R\nw : n → R\ni : n\n⊢ Eq ((Matrix.toLin' (Matrix.diagonal w)).comp (LinearMap.stdBasis R (fun x => R) i)) (HSMul.hSMul (w i) (LinearMap.stdBasis R (fun x => R) i))","decl":"set_option linter.deprecated false in\n@[deprecated diagonal_comp_single (since := \"2024-08-09\")]\ntheorem diagonal_comp_stdBasis (w : n → R) (i : n) :\n    (diagonal w).toLin'.comp (LinearMap.stdBasis R (fun _ : n => R) i) =\n      w i • LinearMap.stdBasis R (fun _ : n => R) i :=\n  LinearMap.ext fun x => (diagonal_mulVec_single w _ _).trans (Pi.single_smul' i (w i) x)\n\n"}
{"name":"Matrix.diagonal_toLin'","module":"Mathlib.LinearAlgebra.Matrix.Diagonal","initialProofState":"n : Type u_1\ninst✝² : Fintype n\ninst✝¹ : DecidableEq n\nR : Type v\ninst✝ : CommSemiring R\nw : n → R\n⊢ Eq (Matrix.toLin' (Matrix.diagonal w)) (LinearMap.pi fun i => HSMul.hSMul (w i) (LinearMap.proj i))","decl":"theorem diagonal_toLin' (w : n → R) :\n    toLin' (diagonal w) = LinearMap.pi fun i => w i • LinearMap.proj i :=\n  LinearMap.ext fun _ => funext fun _ => mulVec_diagonal _ _ _\n\n"}
{"name":"Matrix.ker_diagonal_toLin'","module":"Mathlib.LinearAlgebra.Matrix.Diagonal","initialProofState":"m : Type u_1\ninst✝² : Fintype m\nK : Type u\ninst✝¹ : Semifield K\ninst✝ : DecidableEq m\nw : m → K\n⊢ Eq (LinearMap.ker (Matrix.toLin' (Matrix.diagonal w))) (iSup fun i => iSup fun h => LinearMap.range (LinearMap.single K (fun x => K) i))","decl":"theorem ker_diagonal_toLin' [DecidableEq m] (w : m → K) :\n    ker (toLin' (diagonal w)) =\n      ⨆ i ∈ { i | w i = 0 }, LinearMap.range (LinearMap.single K (fun _ => K) i) := by\n  rw [← comap_bot, ← iInf_ker_proj, comap_iInf]\n  have := fun i : m => ker_comp (toLin' (diagonal w)) (proj i)\n  simp only [comap_iInf, ← this, proj_diagonal, ker_smul']\n  have : univ ⊆ { i : m | w i = 0 } ∪ { i : m | w i = 0 }ᶜ := by rw [Set.union_compl_self]\n  exact (iSup_range_single_eq_iInf_ker_proj K (fun _ : m => K) disjoint_compl_right this\n    (Set.toFinite _)).symm\n\n"}
{"name":"Matrix.range_diagonal","module":"Mathlib.LinearAlgebra.Matrix.Diagonal","initialProofState":"m : Type u_1\ninst✝² : Fintype m\nK : Type u\ninst✝¹ : Semifield K\ninst✝ : DecidableEq m\nw : m → K\n⊢ Eq (LinearMap.range (Matrix.toLin' (Matrix.diagonal w))) (iSup fun i => iSup fun h => LinearMap.range (LinearMap.single K (fun x => K) i))","decl":"theorem range_diagonal [DecidableEq m] (w : m → K) :\n    LinearMap.range (toLin' (diagonal w)) =\n      ⨆ i ∈ { i | w i ≠ 0 }, LinearMap.range (LinearMap.single K (fun _ => K) i) := by\n  dsimp only [mem_setOf_eq]\n  rw [← Submodule.map_top, ← iSup_range_single, Submodule.map_iSup]\n  congr; funext i\n  rw [← LinearMap.range_comp, diagonal_comp_single, ← range_smul']\n\n"}
{"name":"LinearMap.rank_diagonal","module":"Mathlib.LinearAlgebra.Matrix.Diagonal","initialProofState":"m : Type u_1\ninst✝³ : Fintype m\nK : Type u\ninst✝² : Field K\ninst✝¹ : DecidableEq m\ninst✝ : DecidableEq K\nw : m → K\n⊢ Eq (Matrix.toLin' (Matrix.diagonal w)).rank ↑(Fintype.card (Subtype fun i => Ne (w i) 0))","decl":"theorem rank_diagonal [DecidableEq m] [DecidableEq K] (w : m → K) :\n    LinearMap.rank (toLin' (diagonal w)) = Fintype.card { i // w i ≠ 0 } := by\n  have hu : univ ⊆ { i : m | w i = 0 }ᶜ ∪ { i : m | w i = 0 } := by rw [Set.compl_union_self]\n  have hd : Disjoint { i : m | w i ≠ 0 } { i : m | w i = 0 } := disjoint_compl_left\n  have B₁ := iSup_range_single_eq_iInf_ker_proj K (fun _ : m => K) hd hu (Set.toFinite _)\n  have B₂ := iInfKerProjEquiv K (fun _ ↦ K) hd hu\n  rw [LinearMap.rank, range_diagonal, B₁, ← @rank_fun' K]\n  apply LinearEquiv.rank_eq\n  apply B₂\n\n"}
