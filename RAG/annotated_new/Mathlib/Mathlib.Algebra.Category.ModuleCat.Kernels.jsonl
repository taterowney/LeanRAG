{"name":"ModuleCat.hasKernels_moduleCat","module":"Mathlib.Algebra.Category.ModuleCat.Kernels","initialProofState":"R : Type u\ninst✝ : Ring R\n⊢ CategoryTheory.Limits.HasKernels (ModuleCat R)","decl":"/-- The category of R-modules has kernels, given by the inclusion of the kernel submodule. -/\ntheorem hasKernels_moduleCat : HasKernels (ModuleCat R) :=\n  ⟨fun f => HasLimit.mk ⟨_, kernelIsLimit f⟩⟩\n\n"}
{"name":"ModuleCat.hasCokernels_moduleCat","module":"Mathlib.Algebra.Category.ModuleCat.Kernels","initialProofState":"R : Type u\ninst✝ : Ring R\n⊢ CategoryTheory.Limits.HasCokernels (ModuleCat R)","decl":"/-- The category of R-modules has cokernels, given by the projection onto the quotient. -/\ntheorem hasCokernels_moduleCat : HasCokernels (ModuleCat R) :=\n  ⟨fun f => HasColimit.mk ⟨_, cokernelIsColimit f⟩⟩\n\n"}
{"name":"ModuleCat.kernelIsoKer_inv_kernel_ι_apply","module":"Mathlib.Algebra.Category.ModuleCat.Kernels","initialProofState":"R : Type u\ninst✝ : Ring R\nG H : ModuleCat R\nf : Quiver.Hom G H\nx : CategoryTheory.ToType (ModuleCat.of R (Subtype fun x => Membership.mem (LinearMap.ker (ModuleCat.Hom.hom f)) x))\n⊢ Eq ((CategoryTheory.ConcreteCategory.hom (CategoryTheory.Limits.kernel.ι f)) ((CategoryTheory.ConcreteCategory.hom (ModuleCat.kernelIsoKer f).inv) x)) ↑x","decl":"@[simp, elementwise]\n    -- Porting note (https://github.com/leanprover-community/mathlib4/pull/11036): broken dot notation\ntheorem kernelIsoKer_inv_kernel_ι : (kernelIsoKer f).inv ≫ kernel.ι f =\n    ofHom (LinearMap.ker f.hom).subtype :=\n  limit.isoLimitCone_inv_π _ _\n\n"}
{"name":"ModuleCat.kernelIsoKer_inv_kernel_ι","module":"Mathlib.Algebra.Category.ModuleCat.Kernels","initialProofState":"R : Type u\ninst✝ : Ring R\nG H : ModuleCat R\nf : Quiver.Hom G H\n⊢ Eq (CategoryTheory.CategoryStruct.comp (ModuleCat.kernelIsoKer f).inv (CategoryTheory.Limits.kernel.ι f)) (ModuleCat.ofHom (LinearMap.ker (ModuleCat.Hom.hom f)).subtype)","decl":"@[simp, elementwise]\n    -- Porting note (https://github.com/leanprover-community/mathlib4/pull/11036): broken dot notation\ntheorem kernelIsoKer_inv_kernel_ι : (kernelIsoKer f).inv ≫ kernel.ι f =\n    ofHom (LinearMap.ker f.hom).subtype :=\n  limit.isoLimitCone_inv_π _ _\n\n"}
{"name":"ModuleCat.kernelIsoKer_hom_ker_subtype_apply","module":"Mathlib.Algebra.Category.ModuleCat.Kernels","initialProofState":"R : Type u\ninst✝ : Ring R\nG H : ModuleCat R\nf : Quiver.Hom G H\nx : CategoryTheory.ToType (CategoryTheory.Limits.kernel f)\n⊢ Eq (↑((CategoryTheory.ConcreteCategory.hom (ModuleCat.kernelIsoKer f).hom) x)) ((CategoryTheory.ConcreteCategory.hom (CategoryTheory.Limits.kernel.ι f)) x)","decl":"@[simp, elementwise]\ntheorem kernelIsoKer_hom_ker_subtype :\n    -- Porting note (https://github.com/leanprover-community/mathlib4/pull/11036): broken dot notation\n    (kernelIsoKer f).hom ≫ ofHom (LinearMap.ker f.hom).subtype = kernel.ι f :=\n  IsLimit.conePointUniqueUpToIso_inv_comp _ (limit.isLimit _) WalkingParallelPair.zero\n\n"}
{"name":"ModuleCat.kernelIsoKer_hom_ker_subtype","module":"Mathlib.Algebra.Category.ModuleCat.Kernels","initialProofState":"R : Type u\ninst✝ : Ring R\nG H : ModuleCat R\nf : Quiver.Hom G H\n⊢ Eq (CategoryTheory.CategoryStruct.comp (ModuleCat.kernelIsoKer f).hom (ModuleCat.ofHom (LinearMap.ker (ModuleCat.Hom.hom f)).subtype)) (CategoryTheory.Limits.kernel.ι f)","decl":"@[simp, elementwise]\ntheorem kernelIsoKer_hom_ker_subtype :\n    -- Porting note (https://github.com/leanprover-community/mathlib4/pull/11036): broken dot notation\n    (kernelIsoKer f).hom ≫ ofHom (LinearMap.ker f.hom).subtype = kernel.ι f :=\n  IsLimit.conePointUniqueUpToIso_inv_comp _ (limit.isLimit _) WalkingParallelPair.zero\n\n"}
{"name":"ModuleCat.cokernel_π_cokernelIsoRangeQuotient_hom","module":"Mathlib.Algebra.Category.ModuleCat.Kernels","initialProofState":"R : Type u\ninst✝ : Ring R\nG H : ModuleCat R\nf : Quiver.Hom G H\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.cokernel.π f) (ModuleCat.cokernelIsoRangeQuotient f).hom) (ModuleCat.ofHom (LinearMap.range (ModuleCat.Hom.hom f)).mkQ)","decl":"@[simp, elementwise]\ntheorem cokernel_π_cokernelIsoRangeQuotient_hom :\n    cokernel.π f ≫ (cokernelIsoRangeQuotient f).hom = ofHom f.hom.range.mkQ :=\n  colimit.isoColimitCocone_ι_hom _ _\n\n"}
{"name":"ModuleCat.cokernel_π_cokernelIsoRangeQuotient_hom_apply","module":"Mathlib.Algebra.Category.ModuleCat.Kernels","initialProofState":"R : Type u\ninst✝ : Ring R\nG H : ModuleCat R\nf : Quiver.Hom G H\nx : CategoryTheory.ToType H\n⊢ Eq ((CategoryTheory.ConcreteCategory.hom (ModuleCat.cokernelIsoRangeQuotient f).hom) ((CategoryTheory.ConcreteCategory.hom (CategoryTheory.Limits.cokernel.π f)) x)) (Submodule.Quotient.mk x)","decl":"@[simp, elementwise]\ntheorem cokernel_π_cokernelIsoRangeQuotient_hom :\n    cokernel.π f ≫ (cokernelIsoRangeQuotient f).hom = ofHom f.hom.range.mkQ :=\n  colimit.isoColimitCocone_ι_hom _ _\n\n"}
{"name":"ModuleCat.range_mkQ_cokernelIsoRangeQuotient_inv_apply","module":"Mathlib.Algebra.Category.ModuleCat.Kernels","initialProofState":"R : Type u\ninst✝ : Ring R\nG H : ModuleCat R\nf : Quiver.Hom G H\nx : CategoryTheory.ToType (ModuleCat.of R ↑H)\n⊢ Eq ((CategoryTheory.ConcreteCategory.hom (ModuleCat.cokernelIsoRangeQuotient f).inv) (Submodule.Quotient.mk x)) ((CategoryTheory.ConcreteCategory.hom (CategoryTheory.Limits.cokernel.π f)) x)","decl":"@[simp, elementwise]\ntheorem range_mkQ_cokernelIsoRangeQuotient_inv :\n    ofHom f.hom.range.mkQ ≫ (cokernelIsoRangeQuotient f).inv = cokernel.π f :=\n  colimit.isoColimitCocone_ι_inv ⟨_, cokernelIsColimit f⟩ WalkingParallelPair.one\n\n"}
{"name":"ModuleCat.range_mkQ_cokernelIsoRangeQuotient_inv","module":"Mathlib.Algebra.Category.ModuleCat.Kernels","initialProofState":"R : Type u\ninst✝ : Ring R\nG H : ModuleCat R\nf : Quiver.Hom G H\n⊢ Eq (CategoryTheory.CategoryStruct.comp (ModuleCat.ofHom (LinearMap.range (ModuleCat.Hom.hom f)).mkQ) (ModuleCat.cokernelIsoRangeQuotient f).inv) (CategoryTheory.Limits.cokernel.π f)","decl":"@[simp, elementwise]\ntheorem range_mkQ_cokernelIsoRangeQuotient_inv :\n    ofHom f.hom.range.mkQ ≫ (cokernelIsoRangeQuotient f).inv = cokernel.π f :=\n  colimit.isoColimitCocone_ι_inv ⟨_, cokernelIsColimit f⟩ WalkingParallelPair.one\n\n"}
{"name":"ModuleCat.cokernel_π_ext","module":"Mathlib.Algebra.Category.ModuleCat.Kernels","initialProofState":"R : Type u\ninst✝ : Ring R\nM N : ModuleCat R\nf : Quiver.Hom M N\nx y : ↑N\nm : ↑M\nw : Eq x (HAdd.hAdd y ((CategoryTheory.ConcreteCategory.hom f) m))\n⊢ Eq ((CategoryTheory.ConcreteCategory.hom (CategoryTheory.Limits.cokernel.π f)) x) ((CategoryTheory.ConcreteCategory.hom (CategoryTheory.Limits.cokernel.π f)) y)","decl":"theorem cokernel_π_ext {M N : ModuleCat.{u} R} (f : M ⟶ N) {x y : N} (m : M) (w : x = y + f m) :\n    cokernel.π f x = cokernel.π f y := by\n  subst w\n  simpa only [map_add, add_right_eq_self] using cokernel.condition_apply f m\n\n"}
