{"name":"MeasureTheory.map_add_left_eq_self","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_1\ninst✝² : MeasurableSpace G\ninst✝¹ : Add G\nμ : MeasureTheory.Measure G\ninst✝ : μ.IsAddLeftInvariant\ng : G\n⊢ Eq (MeasureTheory.Measure.map (fun x => HAdd.hAdd g x) μ) μ","decl":"@[to_additive]\ntheorem map_mul_left_eq_self (μ : Measure G) [IsMulLeftInvariant μ] (g : G) :\n    map (g * ·) μ = μ :=\n  IsMulLeftInvariant.map_mul_left_eq_self g\n\n"}
{"name":"MeasureTheory.map_mul_left_eq_self","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_1\ninst✝² : MeasurableSpace G\ninst✝¹ : Mul G\nμ : MeasureTheory.Measure G\ninst✝ : μ.IsMulLeftInvariant\ng : G\n⊢ Eq (MeasureTheory.Measure.map (fun x => HMul.hMul g x) μ) μ","decl":"@[to_additive]\ntheorem map_mul_left_eq_self (μ : Measure G) [IsMulLeftInvariant μ] (g : G) :\n    map (g * ·) μ = μ :=\n  IsMulLeftInvariant.map_mul_left_eq_self g\n\n"}
{"name":"MeasureTheory.map_mul_right_eq_self","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_1\ninst✝² : MeasurableSpace G\ninst✝¹ : Mul G\nμ : MeasureTheory.Measure G\ninst✝ : μ.IsMulRightInvariant\ng : G\n⊢ Eq (MeasureTheory.Measure.map (fun x => HMul.hMul x g) μ) μ","decl":"@[to_additive]\ntheorem map_mul_right_eq_self (μ : Measure G) [IsMulRightInvariant μ] (g : G) : map (· * g) μ = μ :=\n  IsMulRightInvariant.map_mul_right_eq_self g\n\n"}
{"name":"MeasureTheory.map_add_right_eq_self","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_1\ninst✝² : MeasurableSpace G\ninst✝¹ : Add G\nμ : MeasureTheory.Measure G\ninst✝ : μ.IsAddRightInvariant\ng : G\n⊢ Eq (MeasureTheory.Measure.map (fun x => HAdd.hAdd x g) μ) μ","decl":"@[to_additive]\ntheorem map_mul_right_eq_self (μ : Measure G) [IsMulRightInvariant μ] (g : G) : map (· * g) μ = μ :=\n  IsMulRightInvariant.map_mul_right_eq_self g\n\n"}
{"name":"MeasureTheory.isAddLeftInvariant_smul","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_1\ninst✝² : MeasurableSpace G\ninst✝¹ : Add G\nμ : MeasureTheory.Measure G\ninst✝ : μ.IsAddLeftInvariant\nc : ENNReal\n⊢ (HSMul.hSMul c μ).IsAddLeftInvariant","decl":"@[to_additive MeasureTheory.isAddLeftInvariant_smul]\ninstance isMulLeftInvariant_smul [IsMulLeftInvariant μ] (c : ℝ≥0∞) : IsMulLeftInvariant (c • μ) :=\n  ⟨fun g => by rw [Measure.map_smul, map_mul_left_eq_self]⟩\n\n"}
{"name":"MeasureTheory.isMulLeftInvariant_smul","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_1\ninst✝² : MeasurableSpace G\ninst✝¹ : Mul G\nμ : MeasureTheory.Measure G\ninst✝ : μ.IsMulLeftInvariant\nc : ENNReal\n⊢ (HSMul.hSMul c μ).IsMulLeftInvariant","decl":"@[to_additive MeasureTheory.isAddLeftInvariant_smul]\ninstance isMulLeftInvariant_smul [IsMulLeftInvariant μ] (c : ℝ≥0∞) : IsMulLeftInvariant (c • μ) :=\n  ⟨fun g => by rw [Measure.map_smul, map_mul_left_eq_self]⟩\n\n"}
{"name":"MeasureTheory.isAddRightInvariant_smul","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_1\ninst✝² : MeasurableSpace G\ninst✝¹ : Add G\nμ : MeasureTheory.Measure G\ninst✝ : μ.IsAddRightInvariant\nc : ENNReal\n⊢ (HSMul.hSMul c μ).IsAddRightInvariant","decl":"@[to_additive MeasureTheory.isAddRightInvariant_smul]\ninstance isMulRightInvariant_smul [IsMulRightInvariant μ] (c : ℝ≥0∞) :\n    IsMulRightInvariant (c • μ) :=\n  ⟨fun g => by rw [Measure.map_smul, map_mul_right_eq_self]⟩\n\n"}
{"name":"MeasureTheory.isMulRightInvariant_smul","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_1\ninst✝² : MeasurableSpace G\ninst✝¹ : Mul G\nμ : MeasureTheory.Measure G\ninst✝ : μ.IsMulRightInvariant\nc : ENNReal\n⊢ (HSMul.hSMul c μ).IsMulRightInvariant","decl":"@[to_additive MeasureTheory.isAddRightInvariant_smul]\ninstance isMulRightInvariant_smul [IsMulRightInvariant μ] (c : ℝ≥0∞) :\n    IsMulRightInvariant (c • μ) :=\n  ⟨fun g => by rw [Measure.map_smul, map_mul_right_eq_self]⟩\n\n"}
{"name":"MeasureTheory.isAddLeftInvariant_smul_nnreal","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_1\ninst✝² : MeasurableSpace G\ninst✝¹ : Add G\nμ : MeasureTheory.Measure G\ninst✝ : μ.IsAddLeftInvariant\nc : NNReal\n⊢ (HSMul.hSMul c μ).IsAddLeftInvariant","decl":"@[to_additive MeasureTheory.isAddLeftInvariant_smul_nnreal]\ninstance isMulLeftInvariant_smul_nnreal [IsMulLeftInvariant μ] (c : ℝ≥0) :\n    IsMulLeftInvariant (c • μ) :=\n  MeasureTheory.isMulLeftInvariant_smul (c : ℝ≥0∞)\n\n"}
{"name":"MeasureTheory.isMulLeftInvariant_smul_nnreal","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_1\ninst✝² : MeasurableSpace G\ninst✝¹ : Mul G\nμ : MeasureTheory.Measure G\ninst✝ : μ.IsMulLeftInvariant\nc : NNReal\n⊢ (HSMul.hSMul c μ).IsMulLeftInvariant","decl":"@[to_additive MeasureTheory.isAddLeftInvariant_smul_nnreal]\ninstance isMulLeftInvariant_smul_nnreal [IsMulLeftInvariant μ] (c : ℝ≥0) :\n    IsMulLeftInvariant (c • μ) :=\n  MeasureTheory.isMulLeftInvariant_smul (c : ℝ≥0∞)\n\n"}
{"name":"MeasureTheory.isAddRightInvariant_smul_nnreal","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_1\ninst✝² : MeasurableSpace G\ninst✝¹ : Add G\nμ : MeasureTheory.Measure G\ninst✝ : μ.IsAddRightInvariant\nc : NNReal\n⊢ (HSMul.hSMul c μ).IsAddRightInvariant","decl":"@[to_additive MeasureTheory.isAddRightInvariant_smul_nnreal]\ninstance isMulRightInvariant_smul_nnreal [IsMulRightInvariant μ] (c : ℝ≥0) :\n    IsMulRightInvariant (c • μ) :=\n  MeasureTheory.isMulRightInvariant_smul (c : ℝ≥0∞)\n\n"}
{"name":"MeasureTheory.isMulRightInvariant_smul_nnreal","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_1\ninst✝² : MeasurableSpace G\ninst✝¹ : Mul G\nμ : MeasureTheory.Measure G\ninst✝ : μ.IsMulRightInvariant\nc : NNReal\n⊢ (HSMul.hSMul c μ).IsMulRightInvariant","decl":"@[to_additive MeasureTheory.isAddRightInvariant_smul_nnreal]\ninstance isMulRightInvariant_smul_nnreal [IsMulRightInvariant μ] (c : ℝ≥0) :\n    IsMulRightInvariant (c • μ) :=\n  MeasureTheory.isMulRightInvariant_smul (c : ℝ≥0∞)\n\n"}
{"name":"MeasureTheory.measurePreserving_add_left","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_1\ninst✝³ : MeasurableSpace G\ninst✝² : Add G\ninst✝¹ : MeasurableAdd G\nμ : MeasureTheory.Measure G\ninst✝ : μ.IsAddLeftInvariant\ng : G\n⊢ MeasureTheory.MeasurePreserving (fun x => HAdd.hAdd g x) μ μ","decl":"@[to_additive]\ntheorem measurePreserving_mul_left (μ : Measure G) [IsMulLeftInvariant μ] (g : G) :\n    MeasurePreserving (g * ·) μ μ :=\n  ⟨measurable_const_mul g, map_mul_left_eq_self μ g⟩\n\n"}
{"name":"MeasureTheory.measurePreserving_mul_left","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_1\ninst✝³ : MeasurableSpace G\ninst✝² : Mul G\ninst✝¹ : MeasurableMul G\nμ : MeasureTheory.Measure G\ninst✝ : μ.IsMulLeftInvariant\ng : G\n⊢ MeasureTheory.MeasurePreserving (fun x => HMul.hMul g x) μ μ","decl":"@[to_additive]\ntheorem measurePreserving_mul_left (μ : Measure G) [IsMulLeftInvariant μ] (g : G) :\n    MeasurePreserving (g * ·) μ μ :=\n  ⟨measurable_const_mul g, map_mul_left_eq_self μ g⟩\n\n"}
{"name":"MeasureTheory.MeasurePreserving.add_left","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_1\ninst✝⁴ : MeasurableSpace G\ninst✝³ : Add G\ninst✝² : MeasurableAdd G\nμ : MeasureTheory.Measure G\ninst✝¹ : μ.IsAddLeftInvariant\ng : G\nX : Type u_3\ninst✝ : MeasurableSpace X\nμ' : MeasureTheory.Measure X\nf : X → G\nhf : MeasureTheory.MeasurePreserving f μ' μ\n⊢ MeasureTheory.MeasurePreserving (fun x => HAdd.hAdd g (f x)) μ' μ","decl":"@[to_additive]\ntheorem MeasurePreserving.mul_left (μ : Measure G) [IsMulLeftInvariant μ] (g : G) {X : Type*}\n    [MeasurableSpace X] {μ' : Measure X} {f : X → G} (hf : MeasurePreserving f μ' μ) :\n    MeasurePreserving (fun x => g * f x) μ' μ :=\n  (measurePreserving_mul_left μ g).comp hf\n\n"}
{"name":"MeasureTheory.MeasurePreserving.mul_left","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_1\ninst✝⁴ : MeasurableSpace G\ninst✝³ : Mul G\ninst✝² : MeasurableMul G\nμ : MeasureTheory.Measure G\ninst✝¹ : μ.IsMulLeftInvariant\ng : G\nX : Type u_3\ninst✝ : MeasurableSpace X\nμ' : MeasureTheory.Measure X\nf : X → G\nhf : MeasureTheory.MeasurePreserving f μ' μ\n⊢ MeasureTheory.MeasurePreserving (fun x => HMul.hMul g (f x)) μ' μ","decl":"@[to_additive]\ntheorem MeasurePreserving.mul_left (μ : Measure G) [IsMulLeftInvariant μ] (g : G) {X : Type*}\n    [MeasurableSpace X] {μ' : Measure X} {f : X → G} (hf : MeasurePreserving f μ' μ) :\n    MeasurePreserving (fun x => g * f x) μ' μ :=\n  (measurePreserving_mul_left μ g).comp hf\n\n"}
{"name":"MeasureTheory.measurePreserving_add_right","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_1\ninst✝³ : MeasurableSpace G\ninst✝² : Add G\ninst✝¹ : MeasurableAdd G\nμ : MeasureTheory.Measure G\ninst✝ : μ.IsAddRightInvariant\ng : G\n⊢ MeasureTheory.MeasurePreserving (fun x => HAdd.hAdd x g) μ μ","decl":"@[to_additive]\ntheorem measurePreserving_mul_right (μ : Measure G) [IsMulRightInvariant μ] (g : G) :\n    MeasurePreserving (· * g) μ μ :=\n  ⟨measurable_mul_const g, map_mul_right_eq_self μ g⟩\n\n"}
{"name":"MeasureTheory.measurePreserving_mul_right","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_1\ninst✝³ : MeasurableSpace G\ninst✝² : Mul G\ninst✝¹ : MeasurableMul G\nμ : MeasureTheory.Measure G\ninst✝ : μ.IsMulRightInvariant\ng : G\n⊢ MeasureTheory.MeasurePreserving (fun x => HMul.hMul x g) μ μ","decl":"@[to_additive]\ntheorem measurePreserving_mul_right (μ : Measure G) [IsMulRightInvariant μ] (g : G) :\n    MeasurePreserving (· * g) μ μ :=\n  ⟨measurable_mul_const g, map_mul_right_eq_self μ g⟩\n\n"}
{"name":"MeasureTheory.MeasurePreserving.add_right","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_1\ninst✝⁴ : MeasurableSpace G\ninst✝³ : Add G\ninst✝² : MeasurableAdd G\nμ : MeasureTheory.Measure G\ninst✝¹ : μ.IsAddRightInvariant\ng : G\nX : Type u_3\ninst✝ : MeasurableSpace X\nμ' : MeasureTheory.Measure X\nf : X → G\nhf : MeasureTheory.MeasurePreserving f μ' μ\n⊢ MeasureTheory.MeasurePreserving (fun x => HAdd.hAdd (f x) g) μ' μ","decl":"@[to_additive]\ntheorem MeasurePreserving.mul_right (μ : Measure G) [IsMulRightInvariant μ] (g : G) {X : Type*}\n    [MeasurableSpace X] {μ' : Measure X} {f : X → G} (hf : MeasurePreserving f μ' μ) :\n    MeasurePreserving (fun x => f x * g) μ' μ :=\n  (measurePreserving_mul_right μ g).comp hf\n\n"}
{"name":"MeasureTheory.MeasurePreserving.mul_right","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_1\ninst✝⁴ : MeasurableSpace G\ninst✝³ : Mul G\ninst✝² : MeasurableMul G\nμ : MeasureTheory.Measure G\ninst✝¹ : μ.IsMulRightInvariant\ng : G\nX : Type u_3\ninst✝ : MeasurableSpace X\nμ' : MeasureTheory.Measure X\nf : X → G\nhf : MeasureTheory.MeasurePreserving f μ' μ\n⊢ MeasureTheory.MeasurePreserving (fun x => HMul.hMul (f x) g) μ' μ","decl":"@[to_additive]\ntheorem MeasurePreserving.mul_right (μ : Measure G) [IsMulRightInvariant μ] (g : G) {X : Type*}\n    [MeasurableSpace X] {μ' : Measure X} {f : X → G} (hf : MeasurePreserving f μ' μ) :\n    MeasurePreserving (fun x => f x * g) μ' μ :=\n  (measurePreserving_mul_right μ g).comp hf\n\n"}
{"name":"MeasureTheory.Subgroup.smulInvariantMeasure","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_3\nα : Type u_4\ninst✝³ : Group G\ninst✝² : MulAction G α\ninst✝¹ : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.SMulInvariantMeasure G α μ\nH : Subgroup G\n⊢ MeasureTheory.SMulInvariantMeasure (Subtype fun x => Membership.mem H x) α μ","decl":"@[to_additive]\ninstance Subgroup.smulInvariantMeasure {G α : Type*} [Group G] [MulAction G α] [MeasurableSpace α]\n    {μ : Measure α} [SMulInvariantMeasure G α μ] (H : Subgroup G) : SMulInvariantMeasure H α μ :=\n  ⟨fun y s hs => by convert SMulInvariantMeasure.measure_preimage_smul (μ := μ) (y : G) hs⟩\n\n"}
{"name":"MeasureTheory.Subgroup.vaddInvariantMeasure","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_3\nα : Type u_4\ninst✝³ : AddGroup G\ninst✝² : AddAction G α\ninst✝¹ : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.VAddInvariantMeasure G α μ\nH : AddSubgroup G\n⊢ MeasureTheory.VAddInvariantMeasure (Subtype fun x => Membership.mem H x) α μ","decl":"@[to_additive]\ninstance Subgroup.smulInvariantMeasure {G α : Type*} [Group G] [MulAction G α] [MeasurableSpace α]\n    {μ : Measure α} [SMulInvariantMeasure G α μ] (H : Subgroup G) : SMulInvariantMeasure H α μ :=\n  ⟨fun y s hs => by convert SMulInvariantMeasure.measure_preimage_smul (μ := μ) (y : G) hs⟩\n\n"}
{"name":"MeasureTheory.forall_measure_preimage_add_iff","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_1\ninst✝² : MeasurableSpace G\ninst✝¹ : Add G\ninst✝ : MeasurableAdd G\nμ : MeasureTheory.Measure G\n⊢ Iff (∀ (g : G) (A : Set G), MeasurableSet A → Eq (μ (Set.preimage (fun h => HAdd.hAdd g h) A)) (μ A)) μ.IsAddLeftInvariant","decl":"/-- An alternative way to prove that `μ` is left invariant under multiplication. -/\n@[to_additive \" An alternative way to prove that `μ` is left invariant under addition. \"]\ntheorem forall_measure_preimage_mul_iff (μ : Measure G) :\n    (∀ (g : G) (A : Set G), MeasurableSet A → μ ((fun h => g * h) ⁻¹' A) = μ A) ↔\n      IsMulLeftInvariant μ := by\n  trans ∀ g, map (g * ·) μ = μ\n  · simp_rw [Measure.ext_iff]\n    refine forall_congr' fun g => forall_congr' fun A => forall_congr' fun hA => ?_\n    rw [map_apply (measurable_const_mul g) hA]\n  exact ⟨fun h => ⟨h⟩, fun h => h.1⟩\n\n"}
{"name":"MeasureTheory.forall_measure_preimage_mul_iff","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_1\ninst✝² : MeasurableSpace G\ninst✝¹ : Mul G\ninst✝ : MeasurableMul G\nμ : MeasureTheory.Measure G\n⊢ Iff (∀ (g : G) (A : Set G), MeasurableSet A → Eq (μ (Set.preimage (fun h => HMul.hMul g h) A)) (μ A)) μ.IsMulLeftInvariant","decl":"/-- An alternative way to prove that `μ` is left invariant under multiplication. -/\n@[to_additive \" An alternative way to prove that `μ` is left invariant under addition. \"]\ntheorem forall_measure_preimage_mul_iff (μ : Measure G) :\n    (∀ (g : G) (A : Set G), MeasurableSet A → μ ((fun h => g * h) ⁻¹' A) = μ A) ↔\n      IsMulLeftInvariant μ := by\n  trans ∀ g, map (g * ·) μ = μ\n  · simp_rw [Measure.ext_iff]\n    refine forall_congr' fun g => forall_congr' fun A => forall_congr' fun hA => ?_\n    rw [map_apply (measurable_const_mul g) hA]\n  exact ⟨fun h => ⟨h⟩, fun h => h.1⟩\n\n"}
{"name":"MeasureTheory.forall_measure_preimage_add_right_iff","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_1\ninst✝² : MeasurableSpace G\ninst✝¹ : Add G\ninst✝ : MeasurableAdd G\nμ : MeasureTheory.Measure G\n⊢ Iff (∀ (g : G) (A : Set G), MeasurableSet A → Eq (μ (Set.preimage (fun h => HAdd.hAdd h g) A)) (μ A)) μ.IsAddRightInvariant","decl":"/-- An alternative way to prove that `μ` is right invariant under multiplication. -/\n@[to_additive \" An alternative way to prove that `μ` is right invariant under addition. \"]\ntheorem forall_measure_preimage_mul_right_iff (μ : Measure G) :\n    (∀ (g : G) (A : Set G), MeasurableSet A → μ ((fun h => h * g) ⁻¹' A) = μ A) ↔\n      IsMulRightInvariant μ := by\n  trans ∀ g, map (· * g) μ = μ\n  · simp_rw [Measure.ext_iff]\n    refine forall_congr' fun g => forall_congr' fun A => forall_congr' fun hA => ?_\n    rw [map_apply (measurable_mul_const g) hA]\n  exact ⟨fun h => ⟨h⟩, fun h => h.1⟩\n\n"}
{"name":"MeasureTheory.forall_measure_preimage_mul_right_iff","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_1\ninst✝² : MeasurableSpace G\ninst✝¹ : Mul G\ninst✝ : MeasurableMul G\nμ : MeasureTheory.Measure G\n⊢ Iff (∀ (g : G) (A : Set G), MeasurableSet A → Eq (μ (Set.preimage (fun h => HMul.hMul h g) A)) (μ A)) μ.IsMulRightInvariant","decl":"/-- An alternative way to prove that `μ` is right invariant under multiplication. -/\n@[to_additive \" An alternative way to prove that `μ` is right invariant under addition. \"]\ntheorem forall_measure_preimage_mul_right_iff (μ : Measure G) :\n    (∀ (g : G) (A : Set G), MeasurableSet A → μ ((fun h => h * g) ⁻¹' A) = μ A) ↔\n      IsMulRightInvariant μ := by\n  trans ∀ g, map (· * g) μ = μ\n  · simp_rw [Measure.ext_iff]\n    refine forall_congr' fun g => forall_congr' fun A => forall_congr' fun hA => ?_\n    rw [map_apply (measurable_mul_const g) hA]\n  exact ⟨fun h => ⟨h⟩, fun h => h.1⟩\n\n"}
{"name":"MeasureTheory.Measure.prod.instIsAddLeftInvariant","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_1\ninst✝⁷ : MeasurableSpace G\ninst✝⁶ : Add G\nμ : MeasureTheory.Measure G\ninst✝⁵ : μ.IsAddLeftInvariant\ninst✝⁴ : MeasureTheory.SFinite μ\nH : Type u_3\ninst✝³ : Add H\nmH : MeasurableSpace H\nν : MeasureTheory.Measure H\ninst✝² : MeasurableAdd H\ninst✝¹ : ν.IsAddLeftInvariant\ninst✝ : MeasureTheory.SFinite ν\n⊢ (μ.prod ν).IsAddLeftInvariant","decl":"@[to_additive]\ninstance Measure.prod.instIsMulLeftInvariant [IsMulLeftInvariant μ] [SFinite μ] {H : Type*}\n    [Mul H] {mH : MeasurableSpace H} {ν : Measure H} [MeasurableMul H] [IsMulLeftInvariant ν]\n    [SFinite ν] : IsMulLeftInvariant (μ.prod ν) := by\n  constructor\n  rintro ⟨g, h⟩\n  change map (Prod.map (g * ·) (h * ·)) (μ.prod ν) = μ.prod ν\n  rw [← map_prod_map _ _ (measurable_const_mul g) (measurable_const_mul h),\n    map_mul_left_eq_self μ g, map_mul_left_eq_self ν h]\n\n"}
{"name":"MeasureTheory.Measure.prod.instIsMulLeftInvariant","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_1\ninst✝⁷ : MeasurableSpace G\ninst✝⁶ : Mul G\nμ : MeasureTheory.Measure G\ninst✝⁵ : μ.IsMulLeftInvariant\ninst✝⁴ : MeasureTheory.SFinite μ\nH : Type u_3\ninst✝³ : Mul H\nmH : MeasurableSpace H\nν : MeasureTheory.Measure H\ninst✝² : MeasurableMul H\ninst✝¹ : ν.IsMulLeftInvariant\ninst✝ : MeasureTheory.SFinite ν\n⊢ (μ.prod ν).IsMulLeftInvariant","decl":"@[to_additive]\ninstance Measure.prod.instIsMulLeftInvariant [IsMulLeftInvariant μ] [SFinite μ] {H : Type*}\n    [Mul H] {mH : MeasurableSpace H} {ν : Measure H} [MeasurableMul H] [IsMulLeftInvariant ν]\n    [SFinite ν] : IsMulLeftInvariant (μ.prod ν) := by\n  constructor\n  rintro ⟨g, h⟩\n  change map (Prod.map (g * ·) (h * ·)) (μ.prod ν) = μ.prod ν\n  rw [← map_prod_map _ _ (measurable_const_mul g) (measurable_const_mul h),\n    map_mul_left_eq_self μ g, map_mul_left_eq_self ν h]\n\n"}
{"name":"MeasureTheory.Measure.prod.instIsAddRightInvariant","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_1\ninst✝⁷ : MeasurableSpace G\ninst✝⁶ : Add G\nμ : MeasureTheory.Measure G\ninst✝⁵ : μ.IsAddRightInvariant\ninst✝⁴ : MeasureTheory.SFinite μ\nH : Type u_3\ninst✝³ : Add H\nmH : MeasurableSpace H\nν : MeasureTheory.Measure H\ninst✝² : MeasurableAdd H\ninst✝¹ : ν.IsAddRightInvariant\ninst✝ : MeasureTheory.SFinite ν\n⊢ (μ.prod ν).IsAddRightInvariant","decl":"@[to_additive]\ninstance Measure.prod.instIsMulRightInvariant [IsMulRightInvariant μ] [SFinite μ] {H : Type*}\n    [Mul H] {mH : MeasurableSpace H} {ν : Measure H} [MeasurableMul H] [IsMulRightInvariant ν]\n    [SFinite ν] : IsMulRightInvariant (μ.prod ν) := by\n  constructor\n  rintro ⟨g, h⟩\n  change map (Prod.map (· * g) (· * h)) (μ.prod ν) = μ.prod ν\n  rw [← map_prod_map _ _ (measurable_mul_const g) (measurable_mul_const h),\n    map_mul_right_eq_self μ g, map_mul_right_eq_self ν h]\n\n"}
{"name":"MeasureTheory.Measure.prod.instIsMulRightInvariant","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_1\ninst✝⁷ : MeasurableSpace G\ninst✝⁶ : Mul G\nμ : MeasureTheory.Measure G\ninst✝⁵ : μ.IsMulRightInvariant\ninst✝⁴ : MeasureTheory.SFinite μ\nH : Type u_3\ninst✝³ : Mul H\nmH : MeasurableSpace H\nν : MeasureTheory.Measure H\ninst✝² : MeasurableMul H\ninst✝¹ : ν.IsMulRightInvariant\ninst✝ : MeasureTheory.SFinite ν\n⊢ (μ.prod ν).IsMulRightInvariant","decl":"@[to_additive]\ninstance Measure.prod.instIsMulRightInvariant [IsMulRightInvariant μ] [SFinite μ] {H : Type*}\n    [Mul H] {mH : MeasurableSpace H} {ν : Measure H} [MeasurableMul H] [IsMulRightInvariant ν]\n    [SFinite ν] : IsMulRightInvariant (μ.prod ν) := by\n  constructor\n  rintro ⟨g, h⟩\n  change map (Prod.map (· * g) (· * h)) (μ.prod ν) = μ.prod ν\n  rw [← map_prod_map _ _ (measurable_mul_const g) (measurable_mul_const h),\n    map_mul_right_eq_self μ g, map_mul_right_eq_self ν h]\n\n"}
{"name":"MeasureTheory.isMulLeftInvariant_map","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_1\ninst✝⁶ : MeasurableSpace G\ninst✝⁵ : Mul G\nμ : MeasureTheory.Measure G\ninst✝⁴ : MeasurableMul G\nH : Type u_3\ninst✝³ : MeasurableSpace H\ninst✝² : Mul H\ninst✝¹ : MeasurableMul H\ninst✝ : μ.IsMulLeftInvariant\nf : MulHom G H\nhf : Measurable ⇑f\nh_surj : Function.Surjective ⇑f\n⊢ (MeasureTheory.Measure.map (⇑f) μ).IsMulLeftInvariant","decl":"@[to_additive]\ntheorem isMulLeftInvariant_map {H : Type*} [MeasurableSpace H] [Mul H] [MeasurableMul H]\n    [IsMulLeftInvariant μ] (f : G →ₙ* H) (hf : Measurable f) (h_surj : Surjective f) :\n    IsMulLeftInvariant (Measure.map f μ) := by\n  refine ⟨fun h => ?_⟩\n  rw [map_map (measurable_const_mul _) hf]\n  obtain ⟨g, rfl⟩ := h_surj h\n  conv_rhs => rw [← map_mul_left_eq_self μ g]\n  rw [map_map hf (measurable_const_mul _)]\n  congr 2\n  ext y\n  simp only [comp_apply, map_mul]\n\n"}
{"name":"MeasureTheory.isAddLeftInvariant_map","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_1\ninst✝⁶ : MeasurableSpace G\ninst✝⁵ : Add G\nμ : MeasureTheory.Measure G\ninst✝⁴ : MeasurableAdd G\nH : Type u_3\ninst✝³ : MeasurableSpace H\ninst✝² : Add H\ninst✝¹ : MeasurableAdd H\ninst✝ : μ.IsAddLeftInvariant\nf : AddHom G H\nhf : Measurable ⇑f\nh_surj : Function.Surjective ⇑f\n⊢ (MeasureTheory.Measure.map (⇑f) μ).IsAddLeftInvariant","decl":"@[to_additive]\ntheorem isMulLeftInvariant_map {H : Type*} [MeasurableSpace H] [Mul H] [MeasurableMul H]\n    [IsMulLeftInvariant μ] (f : G →ₙ* H) (hf : Measurable f) (h_surj : Surjective f) :\n    IsMulLeftInvariant (Measure.map f μ) := by\n  refine ⟨fun h => ?_⟩\n  rw [map_map (measurable_const_mul _) hf]\n  obtain ⟨g, rfl⟩ := h_surj h\n  conv_rhs => rw [← map_mul_left_eq_self μ g]\n  rw [map_map hf (measurable_const_mul _)]\n  congr 2\n  ext y\n  simp only [comp_apply, map_mul]\n\n"}
{"name":"MeasureTheory.isMulLeftInvariant_map_smul","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_1\ninst✝⁷ : MeasurableSpace G\ninst✝⁶ : Semigroup G\ninst✝⁵ : MeasurableMul G\nμ : MeasureTheory.Measure G\nα : Type u_3\ninst✝⁴ : SMul α G\ninst✝³ : SMulCommClass α G G\ninst✝² : MeasurableSpace α\ninst✝¹ : MeasurableSMul α G\ninst✝ : μ.IsMulLeftInvariant\na : α\n⊢ (MeasureTheory.Measure.map (fun x => HSMul.hSMul a x) μ).IsMulLeftInvariant","decl":"/-- The image of a left invariant measure under a left action is left invariant, assuming that\nthe action preserves multiplication. -/\n@[to_additive \"The image of a left invariant measure under a left additive action is left invariant,\nassuming that the action preserves addition.\"]\ntheorem isMulLeftInvariant_map_smul\n    {α} [SMul α G] [SMulCommClass α G G] [MeasurableSpace α] [MeasurableSMul α G]\n    [IsMulLeftInvariant μ] (a : α) :\n    IsMulLeftInvariant (map (a • · : G → G) μ) :=\n  (forall_measure_preimage_mul_iff _).1 fun x _ hs =>\n    (smulInvariantMeasure_map_smul μ a).measure_preimage_smul x hs\n\n"}
{"name":"MeasureTheory.isAddLeftInvariant_map_vadd","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_1\ninst✝⁷ : MeasurableSpace G\ninst✝⁶ : AddSemigroup G\ninst✝⁵ : MeasurableAdd G\nμ : MeasureTheory.Measure G\nα : Type u_3\ninst✝⁴ : VAdd α G\ninst✝³ : VAddCommClass α G G\ninst✝² : MeasurableSpace α\ninst✝¹ : MeasurableVAdd α G\ninst✝ : μ.IsAddLeftInvariant\na : α\n⊢ (MeasureTheory.Measure.map (fun x => HVAdd.hVAdd a x) μ).IsAddLeftInvariant","decl":"/-- The image of a left invariant measure under a left action is left invariant, assuming that\nthe action preserves multiplication. -/\n@[to_additive \"The image of a left invariant measure under a left additive action is left invariant,\nassuming that the action preserves addition.\"]\ntheorem isMulLeftInvariant_map_smul\n    {α} [SMul α G] [SMulCommClass α G G] [MeasurableSpace α] [MeasurableSMul α G]\n    [IsMulLeftInvariant μ] (a : α) :\n    IsMulLeftInvariant (map (a • · : G → G) μ) :=\n  (forall_measure_preimage_mul_iff _).1 fun x _ hs =>\n    (smulInvariantMeasure_map_smul μ a).measure_preimage_smul x hs\n\n"}
{"name":"MeasureTheory.isAddRightInvariant_map_vadd","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_1\ninst✝⁷ : MeasurableSpace G\ninst✝⁶ : AddSemigroup G\ninst✝⁵ : MeasurableAdd G\nμ : MeasureTheory.Measure G\nα : Type u_3\ninst✝⁴ : VAdd α G\ninst✝³ : VAddCommClass α (AddOpposite G) G\ninst✝² : MeasurableSpace α\ninst✝¹ : MeasurableVAdd α G\ninst✝ : μ.IsAddRightInvariant\na : α\n⊢ (MeasureTheory.Measure.map (fun x => HVAdd.hVAdd a x) μ).IsAddRightInvariant","decl":"/-- The image of a right invariant measure under a left action is right invariant, assuming that\nthe action preserves multiplication. -/\n@[to_additive \"The image of a right invariant measure under a left additive action is right\n invariant, assuming that the action preserves addition.\"]\ntheorem isMulRightInvariant_map_smul\n    {α} [SMul α G] [SMulCommClass α Gᵐᵒᵖ G] [MeasurableSpace α] [MeasurableSMul α G]\n    [IsMulRightInvariant μ] (a : α) :\n    IsMulRightInvariant (map (a • · : G → G) μ) :=\n  (forall_measure_preimage_mul_right_iff _).1 fun x _ hs =>\n    (smulInvariantMeasure_map_smul μ a).measure_preimage_smul (MulOpposite.op x) hs\n\n"}
{"name":"MeasureTheory.isMulRightInvariant_map_smul","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_1\ninst✝⁷ : MeasurableSpace G\ninst✝⁶ : Semigroup G\ninst✝⁵ : MeasurableMul G\nμ : MeasureTheory.Measure G\nα : Type u_3\ninst✝⁴ : SMul α G\ninst✝³ : SMulCommClass α (MulOpposite G) G\ninst✝² : MeasurableSpace α\ninst✝¹ : MeasurableSMul α G\ninst✝ : μ.IsMulRightInvariant\na : α\n⊢ (MeasureTheory.Measure.map (fun x => HSMul.hSMul a x) μ).IsMulRightInvariant","decl":"/-- The image of a right invariant measure under a left action is right invariant, assuming that\nthe action preserves multiplication. -/\n@[to_additive \"The image of a right invariant measure under a left additive action is right\n invariant, assuming that the action preserves addition.\"]\ntheorem isMulRightInvariant_map_smul\n    {α} [SMul α G] [SMulCommClass α Gᵐᵒᵖ G] [MeasurableSpace α] [MeasurableSMul α G]\n    [IsMulRightInvariant μ] (a : α) :\n    IsMulRightInvariant (map (a • · : G → G) μ) :=\n  (forall_measure_preimage_mul_right_iff _).1 fun x _ hs =>\n    (smulInvariantMeasure_map_smul μ a).measure_preimage_smul (MulOpposite.op x) hs\n\n"}
{"name":"MeasureTheory.isMulLeftInvariant_map_add_right","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_1\ninst✝³ : MeasurableSpace G\ninst✝² : AddSemigroup G\ninst✝¹ : MeasurableAdd G\nμ : MeasureTheory.Measure G\ninst✝ : μ.IsAddLeftInvariant\ng : G\n⊢ (MeasureTheory.Measure.map (fun x => HAdd.hAdd x g) μ).IsAddLeftInvariant","decl":"/-- The image of a left invariant measure under right multiplication is left invariant. -/\n@[to_additive isMulLeftInvariant_map_add_right\n\"The image of a left invariant measure under right addition is left invariant.\"]\ninstance isMulLeftInvariant_map_mul_right [IsMulLeftInvariant μ] (g : G) :\n    IsMulLeftInvariant (map (· * g) μ) :=\n  isMulLeftInvariant_map_smul (MulOpposite.op g)\n\n"}
{"name":"MeasureTheory.isMulLeftInvariant_map_mul_right","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_1\ninst✝³ : MeasurableSpace G\ninst✝² : Semigroup G\ninst✝¹ : MeasurableMul G\nμ : MeasureTheory.Measure G\ninst✝ : μ.IsMulLeftInvariant\ng : G\n⊢ (MeasureTheory.Measure.map (fun x => HMul.hMul x g) μ).IsMulLeftInvariant","decl":"/-- The image of a left invariant measure under right multiplication is left invariant. -/\n@[to_additive isMulLeftInvariant_map_add_right\n\"The image of a left invariant measure under right addition is left invariant.\"]\ninstance isMulLeftInvariant_map_mul_right [IsMulLeftInvariant μ] (g : G) :\n    IsMulLeftInvariant (map (· * g) μ) :=\n  isMulLeftInvariant_map_smul (MulOpposite.op g)\n\n"}
{"name":"MeasureTheory.isMulRightInvariant_map_add_left","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_1\ninst✝³ : MeasurableSpace G\ninst✝² : AddSemigroup G\ninst✝¹ : MeasurableAdd G\nμ : MeasureTheory.Measure G\ninst✝ : μ.IsAddRightInvariant\ng : G\n⊢ (MeasureTheory.Measure.map (fun x => HAdd.hAdd g x) μ).IsAddRightInvariant","decl":"/-- The image of a right invariant measure under left multiplication is right invariant. -/\n@[to_additive isMulRightInvariant_map_add_left\n\"The image of a right invariant measure under left addition is right invariant.\"]\ninstance isMulRightInvariant_map_mul_left [IsMulRightInvariant μ] (g : G) :\n    IsMulRightInvariant (map (g * ·) μ) :=\n  isMulRightInvariant_map_smul g\n\n"}
{"name":"MeasureTheory.isMulRightInvariant_map_mul_left","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_1\ninst✝³ : MeasurableSpace G\ninst✝² : Semigroup G\ninst✝¹ : MeasurableMul G\nμ : MeasureTheory.Measure G\ninst✝ : μ.IsMulRightInvariant\ng : G\n⊢ (MeasureTheory.Measure.map (fun x => HMul.hMul g x) μ).IsMulRightInvariant","decl":"/-- The image of a right invariant measure under left multiplication is right invariant. -/\n@[to_additive isMulRightInvariant_map_add_left\n\"The image of a right invariant measure under left addition is right invariant.\"]\ninstance isMulRightInvariant_map_mul_left [IsMulRightInvariant μ] (g : G) :\n    IsMulRightInvariant (map (g * ·) μ) :=\n  isMulRightInvariant_map_smul g\n\n"}
{"name":"MeasureTheory.map_sub_right_eq_self","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_1\ninst✝² : MeasurableSpace G\ninst✝¹ : SubNegMonoid G\nμ : MeasureTheory.Measure G\ninst✝ : μ.IsAddRightInvariant\ng : G\n⊢ Eq (MeasureTheory.Measure.map (fun x => HSub.hSub x g) μ) μ","decl":"@[to_additive]\ntheorem map_div_right_eq_self (μ : Measure G) [IsMulRightInvariant μ] (g : G) :\n    map (· / g) μ = μ := by simp_rw [div_eq_mul_inv, map_mul_right_eq_self μ g⁻¹]\n\n"}
{"name":"MeasureTheory.map_div_right_eq_self","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_1\ninst✝² : MeasurableSpace G\ninst✝¹ : DivInvMonoid G\nμ : MeasureTheory.Measure G\ninst✝ : μ.IsMulRightInvariant\ng : G\n⊢ Eq (MeasureTheory.Measure.map (fun x => HDiv.hDiv x g) μ) μ","decl":"@[to_additive]\ntheorem map_div_right_eq_self (μ : Measure G) [IsMulRightInvariant μ] (g : G) :\n    map (· / g) μ = μ := by simp_rw [div_eq_mul_inv, map_mul_right_eq_self μ g⁻¹]\n\n"}
{"name":"MeasureTheory.measurePreserving_sub_right","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_1\ninst✝³ : MeasurableSpace G\ninst✝² : AddGroup G\ninst✝¹ : MeasurableAdd G\nμ : MeasureTheory.Measure G\ninst✝ : μ.IsAddRightInvariant\ng : G\n⊢ MeasureTheory.MeasurePreserving (fun x => HSub.hSub x g) μ μ","decl":"@[to_additive]\ntheorem measurePreserving_div_right (μ : Measure G) [IsMulRightInvariant μ] (g : G) :\n    MeasurePreserving (· / g) μ μ := by simp_rw [div_eq_mul_inv, measurePreserving_mul_right μ g⁻¹]\n\n"}
{"name":"MeasureTheory.measurePreserving_div_right","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_1\ninst✝³ : MeasurableSpace G\ninst✝² : Group G\ninst✝¹ : MeasurableMul G\nμ : MeasureTheory.Measure G\ninst✝ : μ.IsMulRightInvariant\ng : G\n⊢ MeasureTheory.MeasurePreserving (fun x => HDiv.hDiv x g) μ μ","decl":"@[to_additive]\ntheorem measurePreserving_div_right (μ : Measure G) [IsMulRightInvariant μ] (g : G) :\n    MeasurePreserving (· / g) μ μ := by simp_rw [div_eq_mul_inv, measurePreserving_mul_right μ g⁻¹]\n\n"}
{"name":"MeasureTheory.measure_preimage_mul","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_1\ninst✝³ : MeasurableSpace G\ninst✝² : Group G\ninst✝¹ : MeasurableMul G\nμ : MeasureTheory.Measure G\ninst✝ : μ.IsMulLeftInvariant\ng : G\nA : Set G\n⊢ Eq (μ (Set.preimage (fun h => HMul.hMul g h) A)) (μ A)","decl":"/-- We shorten this from `measure_preimage_mul_left`, since left invariant is the preferred option\n  for measures in this formalization. -/\n@[to_additive (attr := simp)\n\"We shorten this from `measure_preimage_add_left`, since left invariant is the preferred option for\nmeasures in this formalization.\"]\ntheorem measure_preimage_mul (μ : Measure G) [IsMulLeftInvariant μ] (g : G) (A : Set G) :\n    μ ((fun h => g * h) ⁻¹' A) = μ A :=\n  calc\n    μ ((fun h => g * h) ⁻¹' A) = map (fun h => g * h) μ A :=\n      ((MeasurableEquiv.mulLeft g).map_apply A).symm\n    _ = μ A := by rw [map_mul_left_eq_self μ g]\n\n"}
{"name":"MeasureTheory.measure_preimage_add","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_1\ninst✝³ : MeasurableSpace G\ninst✝² : AddGroup G\ninst✝¹ : MeasurableAdd G\nμ : MeasureTheory.Measure G\ninst✝ : μ.IsAddLeftInvariant\ng : G\nA : Set G\n⊢ Eq (μ (Set.preimage (fun h => HAdd.hAdd g h) A)) (μ A)","decl":"/-- We shorten this from `measure_preimage_mul_left`, since left invariant is the preferred option\n  for measures in this formalization. -/\n@[to_additive (attr := simp)\n\"We shorten this from `measure_preimage_add_left`, since left invariant is the preferred option for\nmeasures in this formalization.\"]\ntheorem measure_preimage_mul (μ : Measure G) [IsMulLeftInvariant μ] (g : G) (A : Set G) :\n    μ ((fun h => g * h) ⁻¹' A) = μ A :=\n  calc\n    μ ((fun h => g * h) ⁻¹' A) = map (fun h => g * h) μ A :=\n      ((MeasurableEquiv.mulLeft g).map_apply A).symm\n    _ = μ A := by rw [map_mul_left_eq_self μ g]\n\n"}
{"name":"MeasureTheory.measure_preimage_add_right","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_1\ninst✝³ : MeasurableSpace G\ninst✝² : AddGroup G\ninst✝¹ : MeasurableAdd G\nμ : MeasureTheory.Measure G\ninst✝ : μ.IsAddRightInvariant\ng : G\nA : Set G\n⊢ Eq (μ (Set.preimage (fun h => HAdd.hAdd h g) A)) (μ A)","decl":"@[to_additive (attr := simp)]\ntheorem measure_preimage_mul_right (μ : Measure G) [IsMulRightInvariant μ] (g : G) (A : Set G) :\n    μ ((fun h => h * g) ⁻¹' A) = μ A :=\n  calc\n    μ ((fun h => h * g) ⁻¹' A) = map (fun h => h * g) μ A :=\n      ((MeasurableEquiv.mulRight g).map_apply A).symm\n    _ = μ A := by rw [map_mul_right_eq_self μ g]\n\n"}
{"name":"MeasureTheory.measure_preimage_mul_right","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_1\ninst✝³ : MeasurableSpace G\ninst✝² : Group G\ninst✝¹ : MeasurableMul G\nμ : MeasureTheory.Measure G\ninst✝ : μ.IsMulRightInvariant\ng : G\nA : Set G\n⊢ Eq (μ (Set.preimage (fun h => HMul.hMul h g) A)) (μ A)","decl":"@[to_additive (attr := simp)]\ntheorem measure_preimage_mul_right (μ : Measure G) [IsMulRightInvariant μ] (g : G) (A : Set G) :\n    μ ((fun h => h * g) ⁻¹' A) = μ A :=\n  calc\n    μ ((fun h => h * g) ⁻¹' A) = map (fun h => h * g) μ A :=\n      ((MeasurableEquiv.mulRight g).map_apply A).symm\n    _ = μ A := by rw [map_mul_right_eq_self μ g]\n\n"}
{"name":"MeasureTheory.map_add_left_ae","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_1\ninst✝³ : MeasurableSpace G\ninst✝² : AddGroup G\ninst✝¹ : MeasurableAdd G\nμ : MeasureTheory.Measure G\ninst✝ : μ.IsAddLeftInvariant\nx : G\n⊢ Eq (Filter.map (fun h => HAdd.hAdd x h) (MeasureTheory.ae μ)) (MeasureTheory.ae μ)","decl":"@[to_additive]\ntheorem map_mul_left_ae (μ : Measure G) [IsMulLeftInvariant μ] (x : G) :\n    Filter.map (fun h => x * h) (ae μ) = ae μ :=\n  ((MeasurableEquiv.mulLeft x).map_ae μ).trans <| congr_arg ae <| map_mul_left_eq_self μ x\n\n"}
{"name":"MeasureTheory.map_mul_left_ae","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_1\ninst✝³ : MeasurableSpace G\ninst✝² : Group G\ninst✝¹ : MeasurableMul G\nμ : MeasureTheory.Measure G\ninst✝ : μ.IsMulLeftInvariant\nx : G\n⊢ Eq (Filter.map (fun h => HMul.hMul x h) (MeasureTheory.ae μ)) (MeasureTheory.ae μ)","decl":"@[to_additive]\ntheorem map_mul_left_ae (μ : Measure G) [IsMulLeftInvariant μ] (x : G) :\n    Filter.map (fun h => x * h) (ae μ) = ae μ :=\n  ((MeasurableEquiv.mulLeft x).map_ae μ).trans <| congr_arg ae <| map_mul_left_eq_self μ x\n\n"}
{"name":"MeasureTheory.map_add_right_ae","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_1\ninst✝³ : MeasurableSpace G\ninst✝² : AddGroup G\ninst✝¹ : MeasurableAdd G\nμ : MeasureTheory.Measure G\ninst✝ : μ.IsAddRightInvariant\nx : G\n⊢ Eq (Filter.map (fun h => HAdd.hAdd h x) (MeasureTheory.ae μ)) (MeasureTheory.ae μ)","decl":"@[to_additive]\ntheorem map_mul_right_ae (μ : Measure G) [IsMulRightInvariant μ] (x : G) :\n    Filter.map (fun h => h * x) (ae μ) = ae μ :=\n  ((MeasurableEquiv.mulRight x).map_ae μ).trans <| congr_arg ae <| map_mul_right_eq_self μ x\n\n"}
{"name":"MeasureTheory.map_mul_right_ae","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_1\ninst✝³ : MeasurableSpace G\ninst✝² : Group G\ninst✝¹ : MeasurableMul G\nμ : MeasureTheory.Measure G\ninst✝ : μ.IsMulRightInvariant\nx : G\n⊢ Eq (Filter.map (fun h => HMul.hMul h x) (MeasureTheory.ae μ)) (MeasureTheory.ae μ)","decl":"@[to_additive]\ntheorem map_mul_right_ae (μ : Measure G) [IsMulRightInvariant μ] (x : G) :\n    Filter.map (fun h => h * x) (ae μ) = ae μ :=\n  ((MeasurableEquiv.mulRight x).map_ae μ).trans <| congr_arg ae <| map_mul_right_eq_self μ x\n\n"}
{"name":"MeasureTheory.map_div_right_ae","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_1\ninst✝³ : MeasurableSpace G\ninst✝² : Group G\ninst✝¹ : MeasurableMul G\nμ : MeasureTheory.Measure G\ninst✝ : μ.IsMulRightInvariant\nx : G\n⊢ Eq (Filter.map (fun t => HDiv.hDiv t x) (MeasureTheory.ae μ)) (MeasureTheory.ae μ)","decl":"@[to_additive]\ntheorem map_div_right_ae (μ : Measure G) [IsMulRightInvariant μ] (x : G) :\n    Filter.map (fun t => t / x) (ae μ) = ae μ :=\n  ((MeasurableEquiv.divRight x).map_ae μ).trans <| congr_arg ae <| map_div_right_eq_self μ x\n\n"}
{"name":"MeasureTheory.map_sub_right_ae","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_1\ninst✝³ : MeasurableSpace G\ninst✝² : AddGroup G\ninst✝¹ : MeasurableAdd G\nμ : MeasureTheory.Measure G\ninst✝ : μ.IsAddRightInvariant\nx : G\n⊢ Eq (Filter.map (fun t => HSub.hSub t x) (MeasureTheory.ae μ)) (MeasureTheory.ae μ)","decl":"@[to_additive]\ntheorem map_div_right_ae (μ : Measure G) [IsMulRightInvariant μ] (x : G) :\n    Filter.map (fun t => t / x) (ae μ) = ae μ :=\n  ((MeasurableEquiv.divRight x).map_ae μ).trans <| congr_arg ae <| map_div_right_eq_self μ x\n\n"}
{"name":"MeasureTheory.eventually_add_left_iff","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_1\ninst✝³ : MeasurableSpace G\ninst✝² : AddGroup G\ninst✝¹ : MeasurableAdd G\nμ : MeasureTheory.Measure G\ninst✝ : μ.IsAddLeftInvariant\nt : G\np : G → Prop\n⊢ Iff (Filter.Eventually (fun x => p (HAdd.hAdd t x)) (MeasureTheory.ae μ)) (Filter.Eventually (fun x => p x) (MeasureTheory.ae μ))","decl":"@[to_additive]\ntheorem eventually_mul_left_iff (μ : Measure G) [IsMulLeftInvariant μ] (t : G) {p : G → Prop} :\n    (∀ᵐ x ∂μ, p (t * x)) ↔ ∀ᵐ x ∂μ, p x := by\n  conv_rhs => rw [Filter.Eventually, ← map_mul_left_ae μ t]\n  rfl\n\n"}
{"name":"MeasureTheory.eventually_mul_left_iff","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_1\ninst✝³ : MeasurableSpace G\ninst✝² : Group G\ninst✝¹ : MeasurableMul G\nμ : MeasureTheory.Measure G\ninst✝ : μ.IsMulLeftInvariant\nt : G\np : G → Prop\n⊢ Iff (Filter.Eventually (fun x => p (HMul.hMul t x)) (MeasureTheory.ae μ)) (Filter.Eventually (fun x => p x) (MeasureTheory.ae μ))","decl":"@[to_additive]\ntheorem eventually_mul_left_iff (μ : Measure G) [IsMulLeftInvariant μ] (t : G) {p : G → Prop} :\n    (∀ᵐ x ∂μ, p (t * x)) ↔ ∀ᵐ x ∂μ, p x := by\n  conv_rhs => rw [Filter.Eventually, ← map_mul_left_ae μ t]\n  rfl\n\n"}
{"name":"MeasureTheory.eventually_mul_right_iff","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_1\ninst✝³ : MeasurableSpace G\ninst✝² : Group G\ninst✝¹ : MeasurableMul G\nμ : MeasureTheory.Measure G\ninst✝ : μ.IsMulRightInvariant\nt : G\np : G → Prop\n⊢ Iff (Filter.Eventually (fun x => p (HMul.hMul x t)) (MeasureTheory.ae μ)) (Filter.Eventually (fun x => p x) (MeasureTheory.ae μ))","decl":"@[to_additive]\ntheorem eventually_mul_right_iff (μ : Measure G) [IsMulRightInvariant μ] (t : G) {p : G → Prop} :\n    (∀ᵐ x ∂μ, p (x * t)) ↔ ∀ᵐ x ∂μ, p x := by\n  conv_rhs => rw [Filter.Eventually, ← map_mul_right_ae μ t]\n  rfl\n\n"}
{"name":"MeasureTheory.eventually_add_right_iff","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_1\ninst✝³ : MeasurableSpace G\ninst✝² : AddGroup G\ninst✝¹ : MeasurableAdd G\nμ : MeasureTheory.Measure G\ninst✝ : μ.IsAddRightInvariant\nt : G\np : G → Prop\n⊢ Iff (Filter.Eventually (fun x => p (HAdd.hAdd x t)) (MeasureTheory.ae μ)) (Filter.Eventually (fun x => p x) (MeasureTheory.ae μ))","decl":"@[to_additive]\ntheorem eventually_mul_right_iff (μ : Measure G) [IsMulRightInvariant μ] (t : G) {p : G → Prop} :\n    (∀ᵐ x ∂μ, p (x * t)) ↔ ∀ᵐ x ∂μ, p x := by\n  conv_rhs => rw [Filter.Eventually, ← map_mul_right_ae μ t]\n  rfl\n\n"}
{"name":"MeasureTheory.eventually_div_right_iff","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_1\ninst✝³ : MeasurableSpace G\ninst✝² : Group G\ninst✝¹ : MeasurableMul G\nμ : MeasureTheory.Measure G\ninst✝ : μ.IsMulRightInvariant\nt : G\np : G → Prop\n⊢ Iff (Filter.Eventually (fun x => p (HDiv.hDiv x t)) (MeasureTheory.ae μ)) (Filter.Eventually (fun x => p x) (MeasureTheory.ae μ))","decl":"@[to_additive]\ntheorem eventually_div_right_iff (μ : Measure G) [IsMulRightInvariant μ] (t : G) {p : G → Prop} :\n    (∀ᵐ x ∂μ, p (x / t)) ↔ ∀ᵐ x ∂μ, p x := by\n  conv_rhs => rw [Filter.Eventually, ← map_div_right_ae μ t]\n  rfl\n\n"}
{"name":"MeasureTheory.eventually_sub_right_iff","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_1\ninst✝³ : MeasurableSpace G\ninst✝² : AddGroup G\ninst✝¹ : MeasurableAdd G\nμ : MeasureTheory.Measure G\ninst✝ : μ.IsAddRightInvariant\nt : G\np : G → Prop\n⊢ Iff (Filter.Eventually (fun x => p (HSub.hSub x t)) (MeasureTheory.ae μ)) (Filter.Eventually (fun x => p x) (MeasureTheory.ae μ))","decl":"@[to_additive]\ntheorem eventually_div_right_iff (μ : Measure G) [IsMulRightInvariant μ] (t : G) {p : G → Prop} :\n    (∀ᵐ x ∂μ, p (x / t)) ↔ ∀ᵐ x ∂μ, p x := by\n  conv_rhs => rw [Filter.Eventually, ← map_div_right_ae μ t]\n  rfl\n\n"}
{"name":"MeasureTheory.Measure.IsNegInvariant.neg_eq_self","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_1\ninst✝¹ : MeasurableSpace G\ninst✝ : Neg G\nμ : MeasureTheory.Measure G\nself : μ.IsNegInvariant\n⊢ Eq μ.neg μ","decl":"/-- A measure is invariant under negation if `- μ = μ`. Equivalently, this means that for all\nmeasurable `A` we have `μ (- A) = μ A`, where `- A` is the pointwise negation of `A`. -/\nclass IsNegInvariant [Neg G] (μ : Measure G) : Prop where\n  neg_eq_self : μ.neg = μ\n\n"}
{"name":"MeasureTheory.Measure.IsInvInvariant.inv_eq_self","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_1\ninst✝¹ : MeasurableSpace G\ninst✝ : Inv G\nμ : MeasureTheory.Measure G\nself : μ.IsInvInvariant\n⊢ Eq μ.inv μ","decl":"/-- A measure is invariant under inversion if `μ⁻¹ = μ`. Equivalently, this means that for all\nmeasurable `A` we have `μ (A⁻¹) = μ A`, where `A⁻¹` is the pointwise inverse of `A`. -/\n@[to_additive existing]\nclass IsInvInvariant [Inv G] (μ : Measure G) : Prop where\n  inv_eq_self : μ.inv = μ\n\n"}
{"name":"MeasureTheory.Measure.inv_def","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_1\ninst✝¹ : MeasurableSpace G\ninst✝ : Inv G\nμ : MeasureTheory.Measure G\n⊢ Eq μ.inv (MeasureTheory.Measure.map Inv.inv μ)","decl":"@[to_additive]\ntheorem inv_def (μ : Measure G) : μ.inv = Measure.map inv μ := rfl\n\n"}
{"name":"MeasureTheory.Measure.neg_def","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_1\ninst✝¹ : MeasurableSpace G\ninst✝ : Neg G\nμ : MeasureTheory.Measure G\n⊢ Eq μ.neg (MeasureTheory.Measure.map Neg.neg μ)","decl":"@[to_additive]\ntheorem inv_def (μ : Measure G) : μ.inv = Measure.map inv μ := rfl\n\n"}
{"name":"MeasureTheory.Measure.inv_eq_self","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_1\ninst✝² : MeasurableSpace G\ninst✝¹ : Inv G\nμ : MeasureTheory.Measure G\ninst✝ : μ.IsInvInvariant\n⊢ Eq μ.inv μ","decl":"@[to_additive (attr := simp)]\ntheorem inv_eq_self (μ : Measure G) [IsInvInvariant μ] : μ.inv = μ :=\n  IsInvInvariant.inv_eq_self\n\n"}
{"name":"MeasureTheory.Measure.neg_eq_self","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_1\ninst✝² : MeasurableSpace G\ninst✝¹ : Neg G\nμ : MeasureTheory.Measure G\ninst✝ : μ.IsNegInvariant\n⊢ Eq μ.neg μ","decl":"@[to_additive (attr := simp)]\ntheorem inv_eq_self (μ : Measure G) [IsInvInvariant μ] : μ.inv = μ :=\n  IsInvInvariant.inv_eq_self\n\n"}
{"name":"MeasureTheory.Measure.map_inv_eq_self","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_1\ninst✝² : MeasurableSpace G\ninst✝¹ : Inv G\nμ : MeasureTheory.Measure G\ninst✝ : μ.IsInvInvariant\n⊢ Eq (MeasureTheory.Measure.map Inv.inv μ) μ","decl":"@[to_additive (attr := simp)]\ntheorem map_inv_eq_self (μ : Measure G) [IsInvInvariant μ] : map Inv.inv μ = μ :=\n  IsInvInvariant.inv_eq_self\n\n"}
{"name":"MeasureTheory.Measure.map_neg_eq_self","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_1\ninst✝² : MeasurableSpace G\ninst✝¹ : Neg G\nμ : MeasureTheory.Measure G\ninst✝ : μ.IsNegInvariant\n⊢ Eq (MeasureTheory.Measure.map Neg.neg μ) μ","decl":"@[to_additive (attr := simp)]\ntheorem map_inv_eq_self (μ : Measure G) [IsInvInvariant μ] : map Inv.inv μ = μ :=\n  IsInvInvariant.inv_eq_self\n\n"}
{"name":"MeasureTheory.Measure.measurePreserving_inv","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_1\ninst✝³ : MeasurableSpace G\ninst✝² : Inv G\ninst✝¹ : MeasurableInv G\nμ : MeasureTheory.Measure G\ninst✝ : μ.IsInvInvariant\n⊢ MeasureTheory.MeasurePreserving Inv.inv μ μ","decl":"@[to_additive]\ntheorem measurePreserving_inv (μ : Measure G) [IsInvInvariant μ] : MeasurePreserving Inv.inv μ μ :=\n  ⟨measurable_inv, map_inv_eq_self μ⟩\n\n"}
{"name":"MeasureTheory.Measure.measurePreserving_neg","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_1\ninst✝³ : MeasurableSpace G\ninst✝² : Neg G\ninst✝¹ : MeasurableNeg G\nμ : MeasureTheory.Measure G\ninst✝ : μ.IsNegInvariant\n⊢ MeasureTheory.MeasurePreserving Neg.neg μ μ","decl":"@[to_additive]\ntheorem measurePreserving_inv (μ : Measure G) [IsInvInvariant μ] : MeasurePreserving Inv.inv μ μ :=\n  ⟨measurable_inv, map_inv_eq_self μ⟩\n\n"}
{"name":"MeasureTheory.Measure.neg.instSFinite","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_1\ninst✝² : MeasurableSpace G\ninst✝¹ : Neg G\nμ : MeasureTheory.Measure G\ninst✝ : MeasureTheory.SFinite μ\n⊢ MeasureTheory.SFinite μ.neg","decl":"@[to_additive]\ninstance inv.instSFinite (μ : Measure G) [SFinite μ] : SFinite μ.inv := by\n  rw [Measure.inv]; infer_instance\n\n"}
{"name":"MeasureTheory.Measure.inv.instSFinite","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_1\ninst✝² : MeasurableSpace G\ninst✝¹ : Inv G\nμ : MeasureTheory.Measure G\ninst✝ : MeasureTheory.SFinite μ\n⊢ MeasureTheory.SFinite μ.inv","decl":"@[to_additive]\ninstance inv.instSFinite (μ : Measure G) [SFinite μ] : SFinite μ.inv := by\n  rw [Measure.inv]; infer_instance\n\n"}
{"name":"MeasureTheory.Measure.neg_apply","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_1\ninst✝² : MeasurableSpace G\ninst✝¹ : InvolutiveNeg G\ninst✝ : MeasurableNeg G\nμ : MeasureTheory.Measure G\ns : Set G\n⊢ Eq (μ.neg s) (μ (Neg.neg s))","decl":"@[to_additive (attr := simp)]\ntheorem inv_apply (μ : Measure G) (s : Set G) : μ.inv s = μ s⁻¹ :=\n  (MeasurableEquiv.inv G).map_apply s\n\n"}
{"name":"MeasureTheory.Measure.inv_apply","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_1\ninst✝² : MeasurableSpace G\ninst✝¹ : InvolutiveInv G\ninst✝ : MeasurableInv G\nμ : MeasureTheory.Measure G\ns : Set G\n⊢ Eq (μ.inv s) (μ (Inv.inv s))","decl":"@[to_additive (attr := simp)]\ntheorem inv_apply (μ : Measure G) (s : Set G) : μ.inv s = μ s⁻¹ :=\n  (MeasurableEquiv.inv G).map_apply s\n\n"}
{"name":"MeasureTheory.Measure.neg_neg","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_1\ninst✝² : MeasurableSpace G\ninst✝¹ : InvolutiveNeg G\ninst✝ : MeasurableNeg G\nμ : MeasureTheory.Measure G\n⊢ Eq μ.neg.neg μ","decl":"@[to_additive (attr := simp)]\nprotected theorem inv_inv (μ : Measure G) : μ.inv.inv = μ :=\n  (MeasurableEquiv.inv G).map_symm_map\n\n"}
{"name":"MeasureTheory.Measure.inv_inv","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_1\ninst✝² : MeasurableSpace G\ninst✝¹ : InvolutiveInv G\ninst✝ : MeasurableInv G\nμ : MeasureTheory.Measure G\n⊢ Eq μ.inv.inv μ","decl":"@[to_additive (attr := simp)]\nprotected theorem inv_inv (μ : Measure G) : μ.inv.inv = μ :=\n  (MeasurableEquiv.inv G).map_symm_map\n\n"}
{"name":"MeasureTheory.Measure.measure_inv","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_1\ninst✝³ : MeasurableSpace G\ninst✝² : InvolutiveInv G\ninst✝¹ : MeasurableInv G\nμ : MeasureTheory.Measure G\ninst✝ : μ.IsInvInvariant\nA : Set G\n⊢ Eq (μ (Inv.inv A)) (μ A)","decl":"@[to_additive (attr := simp)]\ntheorem measure_inv (μ : Measure G) [IsInvInvariant μ] (A : Set G) : μ A⁻¹ = μ A := by\n  rw [← inv_apply, inv_eq_self]\n\n"}
{"name":"MeasureTheory.Measure.measure_neg","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_1\ninst✝³ : MeasurableSpace G\ninst✝² : InvolutiveNeg G\ninst✝¹ : MeasurableNeg G\nμ : MeasureTheory.Measure G\ninst✝ : μ.IsNegInvariant\nA : Set G\n⊢ Eq (μ (Neg.neg A)) (μ A)","decl":"@[to_additive (attr := simp)]\ntheorem measure_inv (μ : Measure G) [IsInvInvariant μ] (A : Set G) : μ A⁻¹ = μ A := by\n  rw [← inv_apply, inv_eq_self]\n\n"}
{"name":"MeasureTheory.Measure.measure_preimage_inv","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_1\ninst✝³ : MeasurableSpace G\ninst✝² : InvolutiveInv G\ninst✝¹ : MeasurableInv G\nμ : MeasureTheory.Measure G\ninst✝ : μ.IsInvInvariant\nA : Set G\n⊢ Eq (μ (Set.preimage Inv.inv A)) (μ A)","decl":"@[to_additive]\ntheorem measure_preimage_inv (μ : Measure G) [IsInvInvariant μ] (A : Set G) :\n    μ (Inv.inv ⁻¹' A) = μ A :=\n  μ.measure_inv A\n\n"}
{"name":"MeasureTheory.Measure.measure_preimage_neg","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_1\ninst✝³ : MeasurableSpace G\ninst✝² : InvolutiveNeg G\ninst✝¹ : MeasurableNeg G\nμ : MeasureTheory.Measure G\ninst✝ : μ.IsNegInvariant\nA : Set G\n⊢ Eq (μ (Set.preimage Neg.neg A)) (μ A)","decl":"@[to_additive]\ntheorem measure_preimage_inv (μ : Measure G) [IsInvInvariant μ] (A : Set G) :\n    μ (Inv.inv ⁻¹' A) = μ A :=\n  μ.measure_inv A\n\n"}
{"name":"MeasureTheory.Measure.neg.instSigmaFinite","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_1\ninst✝³ : MeasurableSpace G\ninst✝² : InvolutiveNeg G\ninst✝¹ : MeasurableNeg G\nμ : MeasureTheory.Measure G\ninst✝ : MeasureTheory.SigmaFinite μ\n⊢ MeasureTheory.SigmaFinite μ.neg","decl":"@[to_additive]\ninstance inv.instSigmaFinite (μ : Measure G) [SigmaFinite μ] : SigmaFinite μ.inv :=\n  (MeasurableEquiv.inv G).sigmaFinite_map\n\n"}
{"name":"MeasureTheory.Measure.inv.instSigmaFinite","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_1\ninst✝³ : MeasurableSpace G\ninst✝² : InvolutiveInv G\ninst✝¹ : MeasurableInv G\nμ : MeasureTheory.Measure G\ninst✝ : MeasureTheory.SigmaFinite μ\n⊢ MeasureTheory.SigmaFinite μ.inv","decl":"@[to_additive]\ninstance inv.instSigmaFinite (μ : Measure G) [SigmaFinite μ] : SigmaFinite μ.inv :=\n  (MeasurableEquiv.inv G).sigmaFinite_map\n\n"}
{"name":"MeasureTheory.Measure.neg.instIsAddRightInvariant","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_1\ninst✝² : MeasurableSpace G\ninst✝¹ : SubtractionMonoid G\nμ : MeasureTheory.Measure G\ninst✝ : μ.IsAddLeftInvariant\n⊢ μ.neg.IsAddRightInvariant","decl":"@[to_additive]\ninstance inv.instIsMulRightInvariant [IsMulLeftInvariant μ] : IsMulRightInvariant μ.inv := by\n  constructor\n  intro g\n  conv_rhs => rw [← map_mul_left_eq_self μ g⁻¹]\n  simp_rw [Measure.inv, map_map (measurable_mul_const g) measurable_inv,\n    map_map measurable_inv (measurable_const_mul g⁻¹), Function.comp_def, mul_inv_rev, inv_inv]\n\n"}
{"name":"MeasureTheory.Measure.inv.instIsMulRightInvariant","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_1\ninst✝² : MeasurableSpace G\ninst✝¹ : DivisionMonoid G\nμ : MeasureTheory.Measure G\ninst✝ : μ.IsMulLeftInvariant\n⊢ μ.inv.IsMulRightInvariant","decl":"@[to_additive]\ninstance inv.instIsMulRightInvariant [IsMulLeftInvariant μ] : IsMulRightInvariant μ.inv := by\n  constructor\n  intro g\n  conv_rhs => rw [← map_mul_left_eq_self μ g⁻¹]\n  simp_rw [Measure.inv, map_map (measurable_mul_const g) measurable_inv,\n    map_map measurable_inv (measurable_const_mul g⁻¹), Function.comp_def, mul_inv_rev, inv_inv]\n\n"}
{"name":"MeasureTheory.Measure.neg.instIsAddLeftInvariant","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_1\ninst✝² : MeasurableSpace G\ninst✝¹ : SubtractionMonoid G\nμ : MeasureTheory.Measure G\ninst✝ : μ.IsAddRightInvariant\n⊢ μ.neg.IsAddLeftInvariant","decl":"@[to_additive]\ninstance inv.instIsMulLeftInvariant [IsMulRightInvariant μ] : IsMulLeftInvariant μ.inv := by\n  constructor\n  intro g\n  conv_rhs => rw [← map_mul_right_eq_self μ g⁻¹]\n  simp_rw [Measure.inv, map_map (measurable_const_mul g) measurable_inv,\n    map_map measurable_inv (measurable_mul_const g⁻¹), Function.comp_def, mul_inv_rev, inv_inv]\n\n"}
{"name":"MeasureTheory.Measure.inv.instIsMulLeftInvariant","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_1\ninst✝² : MeasurableSpace G\ninst✝¹ : DivisionMonoid G\nμ : MeasureTheory.Measure G\ninst✝ : μ.IsMulRightInvariant\n⊢ μ.inv.IsMulLeftInvariant","decl":"@[to_additive]\ninstance inv.instIsMulLeftInvariant [IsMulRightInvariant μ] : IsMulLeftInvariant μ.inv := by\n  constructor\n  intro g\n  conv_rhs => rw [← map_mul_right_eq_self μ g⁻¹]\n  simp_rw [Measure.inv, map_map (measurable_const_mul g) measurable_inv,\n    map_map measurable_inv (measurable_mul_const g⁻¹), Function.comp_def, mul_inv_rev, inv_inv]\n\n"}
{"name":"MeasureTheory.Measure.measurePreserving_div_left","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_1\ninst✝⁵ : MeasurableSpace G\ninst✝⁴ : DivisionMonoid G\ninst✝³ : MeasurableMul G\ninst✝² : MeasurableInv G\nμ : MeasureTheory.Measure G\ninst✝¹ : μ.IsInvInvariant\ninst✝ : μ.IsMulLeftInvariant\ng : G\n⊢ MeasureTheory.MeasurePreserving (fun t => HDiv.hDiv g t) μ μ","decl":"@[to_additive]\ntheorem measurePreserving_div_left (μ : Measure G) [IsInvInvariant μ] [IsMulLeftInvariant μ]\n    (g : G) : MeasurePreserving (fun t => g / t) μ μ := by\n  simp_rw [div_eq_mul_inv]\n  exact (measurePreserving_mul_left μ g).comp (measurePreserving_inv μ)\n\n"}
{"name":"MeasureTheory.Measure.measurePreserving_sub_left","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_1\ninst✝⁵ : MeasurableSpace G\ninst✝⁴ : SubtractionMonoid G\ninst✝³ : MeasurableAdd G\ninst✝² : MeasurableNeg G\nμ : MeasureTheory.Measure G\ninst✝¹ : μ.IsNegInvariant\ninst✝ : μ.IsAddLeftInvariant\ng : G\n⊢ MeasureTheory.MeasurePreserving (fun t => HSub.hSub g t) μ μ","decl":"@[to_additive]\ntheorem measurePreserving_div_left (μ : Measure G) [IsInvInvariant μ] [IsMulLeftInvariant μ]\n    (g : G) : MeasurePreserving (fun t => g / t) μ μ := by\n  simp_rw [div_eq_mul_inv]\n  exact (measurePreserving_mul_left μ g).comp (measurePreserving_inv μ)\n\n"}
{"name":"MeasureTheory.Measure.map_sub_left_eq_self","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_1\ninst✝⁵ : MeasurableSpace G\ninst✝⁴ : SubtractionMonoid G\ninst✝³ : MeasurableAdd G\ninst✝² : MeasurableNeg G\nμ : MeasureTheory.Measure G\ninst✝¹ : μ.IsNegInvariant\ninst✝ : μ.IsAddLeftInvariant\ng : G\n⊢ Eq (MeasureTheory.Measure.map (fun t => HSub.hSub g t) μ) μ","decl":"@[to_additive]\ntheorem map_div_left_eq_self (μ : Measure G) [IsInvInvariant μ] [IsMulLeftInvariant μ] (g : G) :\n    map (fun t => g / t) μ = μ :=\n  (measurePreserving_div_left μ g).map_eq\n\n"}
{"name":"MeasureTheory.Measure.map_div_left_eq_self","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_1\ninst✝⁵ : MeasurableSpace G\ninst✝⁴ : DivisionMonoid G\ninst✝³ : MeasurableMul G\ninst✝² : MeasurableInv G\nμ : MeasureTheory.Measure G\ninst✝¹ : μ.IsInvInvariant\ninst✝ : μ.IsMulLeftInvariant\ng : G\n⊢ Eq (MeasureTheory.Measure.map (fun t => HDiv.hDiv g t) μ) μ","decl":"@[to_additive]\ntheorem map_div_left_eq_self (μ : Measure G) [IsInvInvariant μ] [IsMulLeftInvariant μ] (g : G) :\n    map (fun t => g / t) μ = μ :=\n  (measurePreserving_div_left μ g).map_eq\n\n"}
{"name":"MeasureTheory.Measure.measurePreserving_add_right_neg","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_1\ninst✝⁵ : MeasurableSpace G\ninst✝⁴ : SubtractionMonoid G\ninst✝³ : MeasurableAdd G\ninst✝² : MeasurableNeg G\nμ : MeasureTheory.Measure G\ninst✝¹ : μ.IsNegInvariant\ninst✝ : μ.IsAddLeftInvariant\ng : G\n⊢ MeasureTheory.MeasurePreserving (fun t => Neg.neg (HAdd.hAdd g t)) μ μ","decl":"@[to_additive]\ntheorem measurePreserving_mul_right_inv (μ : Measure G) [IsInvInvariant μ] [IsMulLeftInvariant μ]\n    (g : G) : MeasurePreserving (fun t => (g * t)⁻¹) μ μ :=\n  (measurePreserving_inv μ).comp <| measurePreserving_mul_left μ g\n\n"}
{"name":"MeasureTheory.Measure.measurePreserving_mul_right_inv","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_1\ninst✝⁵ : MeasurableSpace G\ninst✝⁴ : DivisionMonoid G\ninst✝³ : MeasurableMul G\ninst✝² : MeasurableInv G\nμ : MeasureTheory.Measure G\ninst✝¹ : μ.IsInvInvariant\ninst✝ : μ.IsMulLeftInvariant\ng : G\n⊢ MeasureTheory.MeasurePreserving (fun t => Inv.inv (HMul.hMul g t)) μ μ","decl":"@[to_additive]\ntheorem measurePreserving_mul_right_inv (μ : Measure G) [IsInvInvariant μ] [IsMulLeftInvariant μ]\n    (g : G) : MeasurePreserving (fun t => (g * t)⁻¹) μ μ :=\n  (measurePreserving_inv μ).comp <| measurePreserving_mul_left μ g\n\n"}
{"name":"MeasureTheory.Measure.map_mul_right_inv_eq_self","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_1\ninst✝⁵ : MeasurableSpace G\ninst✝⁴ : DivisionMonoid G\ninst✝³ : MeasurableMul G\ninst✝² : MeasurableInv G\nμ : MeasureTheory.Measure G\ninst✝¹ : μ.IsInvInvariant\ninst✝ : μ.IsMulLeftInvariant\ng : G\n⊢ Eq (MeasureTheory.Measure.map (fun t => Inv.inv (HMul.hMul g t)) μ) μ","decl":"@[to_additive]\ntheorem map_mul_right_inv_eq_self (μ : Measure G) [IsInvInvariant μ] [IsMulLeftInvariant μ]\n    (g : G) : map (fun t => (g * t)⁻¹) μ = μ :=\n  (measurePreserving_mul_right_inv μ g).map_eq\n\n"}
{"name":"MeasureTheory.Measure.map_add_right_neg_eq_self","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_1\ninst✝⁵ : MeasurableSpace G\ninst✝⁴ : SubtractionMonoid G\ninst✝³ : MeasurableAdd G\ninst✝² : MeasurableNeg G\nμ : MeasureTheory.Measure G\ninst✝¹ : μ.IsNegInvariant\ninst✝ : μ.IsAddLeftInvariant\ng : G\n⊢ Eq (MeasureTheory.Measure.map (fun t => Neg.neg (HAdd.hAdd g t)) μ) μ","decl":"@[to_additive]\ntheorem map_mul_right_inv_eq_self (μ : Measure G) [IsInvInvariant μ] [IsMulLeftInvariant μ]\n    (g : G) : map (fun t => (g * t)⁻¹) μ = μ :=\n  (measurePreserving_mul_right_inv μ g).map_eq\n\n"}
{"name":"MeasureTheory.Measure.map_sub_left_ae","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_1\ninst✝⁵ : MeasurableSpace G\ninst✝⁴ : AddGroup G\ninst✝³ : MeasurableAdd G\ninst✝² : MeasurableNeg G\nμ : MeasureTheory.Measure G\ninst✝¹ : μ.IsAddLeftInvariant\ninst✝ : μ.IsNegInvariant\nx : G\n⊢ Eq (Filter.map (fun t => HSub.hSub x t) (MeasureTheory.ae μ)) (MeasureTheory.ae μ)","decl":"@[to_additive]\ntheorem map_div_left_ae (μ : Measure G) [IsMulLeftInvariant μ] [IsInvInvariant μ] (x : G) :\n    Filter.map (fun t => x / t) (ae μ) = ae μ :=\n  ((MeasurableEquiv.divLeft x).map_ae μ).trans <| congr_arg ae <| map_div_left_eq_self μ x\n\n"}
{"name":"MeasureTheory.Measure.map_div_left_ae","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_1\ninst✝⁵ : MeasurableSpace G\ninst✝⁴ : Group G\ninst✝³ : MeasurableMul G\ninst✝² : MeasurableInv G\nμ : MeasureTheory.Measure G\ninst✝¹ : μ.IsMulLeftInvariant\ninst✝ : μ.IsInvInvariant\nx : G\n⊢ Eq (Filter.map (fun t => HDiv.hDiv x t) (MeasureTheory.ae μ)) (MeasureTheory.ae μ)","decl":"@[to_additive]\ntheorem map_div_left_ae (μ : Measure G) [IsMulLeftInvariant μ] [IsInvInvariant μ] (x : G) :\n    Filter.map (fun t => x / t) (ae μ) = ae μ :=\n  ((MeasurableEquiv.divLeft x).map_ae μ).trans <| congr_arg ae <| map_div_left_eq_self μ x\n\n"}
{"name":"MeasureTheory.Measure.IsFiniteMeasureOnCompacts.inv","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_1\ninst✝⁵ : MeasurableSpace G\ninst✝⁴ : TopologicalSpace G\ninst✝³ : BorelSpace G\nμ : MeasureTheory.Measure G\ninst✝² : Group G\ninst✝¹ : ContinuousInv G\ninst✝ : MeasureTheory.IsFiniteMeasureOnCompacts μ\n⊢ MeasureTheory.IsFiniteMeasureOnCompacts μ.inv","decl":"@[to_additive]\ninstance Measure.IsFiniteMeasureOnCompacts.inv [ContinuousInv G] [IsFiniteMeasureOnCompacts μ] :\n    IsFiniteMeasureOnCompacts μ.inv :=\n  IsFiniteMeasureOnCompacts.map μ (Homeomorph.inv G)\n\n"}
{"name":"MeasureTheory.Measure.IsFiniteMeasureOnCompacts.neg","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_1\ninst✝⁵ : MeasurableSpace G\ninst✝⁴ : TopologicalSpace G\ninst✝³ : BorelSpace G\nμ : MeasureTheory.Measure G\ninst✝² : AddGroup G\ninst✝¹ : ContinuousNeg G\ninst✝ : MeasureTheory.IsFiniteMeasureOnCompacts μ\n⊢ MeasureTheory.IsFiniteMeasureOnCompacts μ.neg","decl":"@[to_additive]\ninstance Measure.IsFiniteMeasureOnCompacts.inv [ContinuousInv G] [IsFiniteMeasureOnCompacts μ] :\n    IsFiniteMeasureOnCompacts μ.inv :=\n  IsFiniteMeasureOnCompacts.map μ (Homeomorph.inv G)\n\n"}
{"name":"MeasureTheory.Measure.IsOpenPosMeasure.inv","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_1\ninst✝⁵ : MeasurableSpace G\ninst✝⁴ : TopologicalSpace G\ninst✝³ : BorelSpace G\nμ : MeasureTheory.Measure G\ninst✝² : Group G\ninst✝¹ : ContinuousInv G\ninst✝ : μ.IsOpenPosMeasure\n⊢ μ.inv.IsOpenPosMeasure","decl":"@[to_additive]\ninstance Measure.IsOpenPosMeasure.inv [ContinuousInv G] [IsOpenPosMeasure μ] :\n    IsOpenPosMeasure μ.inv :=\n  (Homeomorph.inv G).continuous.isOpenPosMeasure_map (Homeomorph.inv G).surjective\n\n"}
{"name":"MeasureTheory.Measure.IsOpenPosMeasure.neg","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_1\ninst✝⁵ : MeasurableSpace G\ninst✝⁴ : TopologicalSpace G\ninst✝³ : BorelSpace G\nμ : MeasureTheory.Measure G\ninst✝² : AddGroup G\ninst✝¹ : ContinuousNeg G\ninst✝ : μ.IsOpenPosMeasure\n⊢ μ.neg.IsOpenPosMeasure","decl":"@[to_additive]\ninstance Measure.IsOpenPosMeasure.inv [ContinuousInv G] [IsOpenPosMeasure μ] :\n    IsOpenPosMeasure μ.inv :=\n  (Homeomorph.inv G).continuous.isOpenPosMeasure_map (Homeomorph.inv G).surjective\n\n"}
{"name":"MeasureTheory.Measure.Regular.neg","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_1\ninst✝⁵ : MeasurableSpace G\ninst✝⁴ : TopologicalSpace G\ninst✝³ : BorelSpace G\nμ : MeasureTheory.Measure G\ninst✝² : AddGroup G\ninst✝¹ : ContinuousNeg G\ninst✝ : μ.Regular\n⊢ μ.neg.Regular","decl":"@[to_additive]\ninstance Measure.Regular.inv [ContinuousInv G] [Regular μ] : Regular μ.inv :=\n  Regular.map (Homeomorph.inv G)\n\n"}
{"name":"MeasureTheory.Measure.Regular.inv","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_1\ninst✝⁵ : MeasurableSpace G\ninst✝⁴ : TopologicalSpace G\ninst✝³ : BorelSpace G\nμ : MeasureTheory.Measure G\ninst✝² : Group G\ninst✝¹ : ContinuousInv G\ninst✝ : μ.Regular\n⊢ μ.inv.Regular","decl":"@[to_additive]\ninstance Measure.Regular.inv [ContinuousInv G] [Regular μ] : Regular μ.inv :=\n  Regular.map (Homeomorph.inv G)\n\n"}
{"name":"MeasureTheory.Measure.InnerRegular.inv","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_1\ninst✝⁵ : MeasurableSpace G\ninst✝⁴ : TopologicalSpace G\ninst✝³ : BorelSpace G\nμ : MeasureTheory.Measure G\ninst✝² : Group G\ninst✝¹ : ContinuousInv G\ninst✝ : μ.InnerRegular\n⊢ μ.inv.InnerRegular","decl":"@[to_additive]\ninstance Measure.InnerRegular.inv [ContinuousInv G] [InnerRegular μ] : InnerRegular μ.inv :=\n  InnerRegular.map (Homeomorph.inv G)\n\n"}
{"name":"MeasureTheory.Measure.InnerRegular.neg","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_1\ninst✝⁵ : MeasurableSpace G\ninst✝⁴ : TopologicalSpace G\ninst✝³ : BorelSpace G\nμ : MeasureTheory.Measure G\ninst✝² : AddGroup G\ninst✝¹ : ContinuousNeg G\ninst✝ : μ.InnerRegular\n⊢ μ.neg.InnerRegular","decl":"@[to_additive]\ninstance Measure.InnerRegular.inv [ContinuousInv G] [InnerRegular μ] : InnerRegular μ.inv :=\n  InnerRegular.map (Homeomorph.inv G)\n\n"}
{"name":"MeasureTheory.innerRegular_map_vadd","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_1\ninst✝⁶ : MeasurableSpace G\ninst✝⁵ : TopologicalSpace G\ninst✝⁴ : BorelSpace G\nμ : MeasureTheory.Measure G\nα : Type u_3\ninst✝³ : AddMonoid α\ninst✝² : AddAction α G\ninst✝¹ : ContinuousConstVAdd α G\ninst✝ : μ.InnerRegular\na : α\n⊢ (MeasureTheory.Measure.map (fun x => HVAdd.hVAdd a x) μ).InnerRegular","decl":"/-- The image of an inner regular measure under map of a left action is again inner regular. -/\n@[to_additive\n   \"The image of a inner regular measure under map of a left additive action is again\n    inner regular\"]\ninstance innerRegular_map_smul {α} [Monoid α] [MulAction α G] [ContinuousConstSMul α G]\n    [InnerRegular μ] (a : α) : InnerRegular (Measure.map (a • · : G → G) μ) :=\n  InnerRegular.map_of_continuous (continuous_const_smul a)\n\n"}
{"name":"MeasureTheory.innerRegular_map_smul","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_1\ninst✝⁶ : MeasurableSpace G\ninst✝⁵ : TopologicalSpace G\ninst✝⁴ : BorelSpace G\nμ : MeasureTheory.Measure G\nα : Type u_3\ninst✝³ : Monoid α\ninst✝² : MulAction α G\ninst✝¹ : ContinuousConstSMul α G\ninst✝ : μ.InnerRegular\na : α\n⊢ (MeasureTheory.Measure.map (fun x => HSMul.hSMul a x) μ).InnerRegular","decl":"/-- The image of an inner regular measure under map of a left action is again inner regular. -/\n@[to_additive\n   \"The image of a inner regular measure under map of a left additive action is again\n    inner regular\"]\ninstance innerRegular_map_smul {α} [Monoid α] [MulAction α G] [ContinuousConstSMul α G]\n    [InnerRegular μ] (a : α) : InnerRegular (Measure.map (a • · : G → G) μ) :=\n  InnerRegular.map_of_continuous (continuous_const_smul a)\n\n"}
{"name":"MeasureTheory.innerRegular_map_mul_left","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_1\ninst✝⁵ : MeasurableSpace G\ninst✝⁴ : TopologicalSpace G\ninst✝³ : BorelSpace G\nμ : MeasureTheory.Measure G\ninst✝² : Group G\ninst✝¹ : TopologicalGroup G\ninst✝ : μ.InnerRegular\ng : G\n⊢ (MeasureTheory.Measure.map (fun x => HMul.hMul g x) μ).InnerRegular","decl":"/-- The image of an inner regular measure under left multiplication is again inner regular. -/\n@[to_additive \"The image of an inner regular measure under left addition is again inner regular.\"]\ninstance innerRegular_map_mul_left [TopologicalGroup G] [InnerRegular μ] (g : G) :\n    InnerRegular (Measure.map (g * ·) μ) := InnerRegular.map_of_continuous (continuous_mul_left g)\n\n"}
{"name":"MeasureTheory.innerRegular_map_add_left","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_1\ninst✝⁵ : MeasurableSpace G\ninst✝⁴ : TopologicalSpace G\ninst✝³ : BorelSpace G\nμ : MeasureTheory.Measure G\ninst✝² : AddGroup G\ninst✝¹ : TopologicalAddGroup G\ninst✝ : μ.InnerRegular\ng : G\n⊢ (MeasureTheory.Measure.map (fun x => HAdd.hAdd g x) μ).InnerRegular","decl":"/-- The image of an inner regular measure under left multiplication is again inner regular. -/\n@[to_additive \"The image of an inner regular measure under left addition is again inner regular.\"]\ninstance innerRegular_map_mul_left [TopologicalGroup G] [InnerRegular μ] (g : G) :\n    InnerRegular (Measure.map (g * ·) μ) := InnerRegular.map_of_continuous (continuous_mul_left g)\n\n"}
{"name":"MeasureTheory.innerRegular_map_mul_right","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_1\ninst✝⁵ : MeasurableSpace G\ninst✝⁴ : TopologicalSpace G\ninst✝³ : BorelSpace G\nμ : MeasureTheory.Measure G\ninst✝² : Group G\ninst✝¹ : TopologicalGroup G\ninst✝ : μ.InnerRegular\ng : G\n⊢ (MeasureTheory.Measure.map (fun x => HMul.hMul x g) μ).InnerRegular","decl":"/-- The image of an inner regular measure under right multiplication is again inner regular. -/\n@[to_additive \"The image of an inner regular measure under right addition is again inner regular.\"]\ninstance innerRegular_map_mul_right [TopologicalGroup G] [InnerRegular μ] (g : G) :\n    InnerRegular (Measure.map (· * g) μ) := InnerRegular.map_of_continuous (continuous_mul_right g)\n\n"}
{"name":"MeasureTheory.innerRegular_map_add_right","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_1\ninst✝⁵ : MeasurableSpace G\ninst✝⁴ : TopologicalSpace G\ninst✝³ : BorelSpace G\nμ : MeasureTheory.Measure G\ninst✝² : AddGroup G\ninst✝¹ : TopologicalAddGroup G\ninst✝ : μ.InnerRegular\ng : G\n⊢ (MeasureTheory.Measure.map (fun x => HAdd.hAdd x g) μ).InnerRegular","decl":"/-- The image of an inner regular measure under right multiplication is again inner regular. -/\n@[to_additive \"The image of an inner regular measure under right addition is again inner regular.\"]\ninstance innerRegular_map_mul_right [TopologicalGroup G] [InnerRegular μ] (g : G) :\n    InnerRegular (Measure.map (· * g) μ) := InnerRegular.map_of_continuous (continuous_mul_right g)\n\n"}
{"name":"MeasureTheory.regular_inv_iff","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_1\ninst✝⁴ : MeasurableSpace G\ninst✝³ : TopologicalSpace G\ninst✝² : BorelSpace G\nμ : MeasureTheory.Measure G\ninst✝¹ : Group G\ninst✝ : TopologicalGroup G\n⊢ Iff μ.inv.Regular μ.Regular","decl":"@[to_additive]\ntheorem regular_inv_iff : μ.inv.Regular ↔ μ.Regular :=\n  Regular.map_iff (Homeomorph.inv G)\n\n"}
{"name":"MeasureTheory.regular_neg_iff","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_1\ninst✝⁴ : MeasurableSpace G\ninst✝³ : TopologicalSpace G\ninst✝² : BorelSpace G\nμ : MeasureTheory.Measure G\ninst✝¹ : AddGroup G\ninst✝ : TopologicalAddGroup G\n⊢ Iff μ.neg.Regular μ.Regular","decl":"@[to_additive]\ntheorem regular_inv_iff : μ.inv.Regular ↔ μ.Regular :=\n  Regular.map_iff (Homeomorph.inv G)\n\n"}
{"name":"MeasureTheory.innerRegular_inv_iff","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_1\ninst✝⁴ : MeasurableSpace G\ninst✝³ : TopologicalSpace G\ninst✝² : BorelSpace G\nμ : MeasureTheory.Measure G\ninst✝¹ : Group G\ninst✝ : TopologicalGroup G\n⊢ Iff μ.inv.InnerRegular μ.InnerRegular","decl":"@[to_additive]\ntheorem innerRegular_inv_iff : μ.inv.InnerRegular ↔ μ.InnerRegular :=\n  InnerRegular.map_iff (Homeomorph.inv G)\n\n"}
{"name":"MeasureTheory.innerRegular_neg_iff","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_1\ninst✝⁴ : MeasurableSpace G\ninst✝³ : TopologicalSpace G\ninst✝² : BorelSpace G\nμ : MeasureTheory.Measure G\ninst✝¹ : AddGroup G\ninst✝ : TopologicalAddGroup G\n⊢ Iff μ.neg.InnerRegular μ.InnerRegular","decl":"@[to_additive]\ntheorem innerRegular_inv_iff : μ.inv.InnerRegular ↔ μ.InnerRegular :=\n  InnerRegular.map_iff (Homeomorph.inv G)\n\n"}
{"name":"MeasureTheory.eventually_nhds_zero_measure_vadd_diff_lt","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_1\ninst✝⁷ : MeasurableSpace G\ninst✝⁶ : TopologicalSpace G\ninst✝⁵ : BorelSpace G\nμ : MeasureTheory.Measure G\ninst✝⁴ : AddGroup G\ninst✝³ : TopologicalAddGroup G\ninst✝² : LocallyCompactSpace G\ninst✝¹ : MeasureTheory.IsFiniteMeasureOnCompacts μ\ninst✝ : μ.InnerRegularCompactLTTop\nk : Set G\nhk : IsCompact k\nh'k : IsClosed k\nε : ENNReal\nhε : Ne ε 0\n⊢ Filter.Eventually (fun g => LT.lt (μ (SDiff.sdiff (HVAdd.hVAdd g k) k)) ε) (nhds 0)","decl":"/-- Continuity of the measure of translates of a compact set: Given a compact set `k` in a\ntopological group, for `g` close enough to the origin, `μ (g • k \\ k)` is arbitrarily small. -/\n@[to_additive]\nlemma eventually_nhds_one_measure_smul_diff_lt [LocallyCompactSpace G]\n    [IsFiniteMeasureOnCompacts μ] [InnerRegularCompactLTTop μ] {k : Set G}\n    (hk : IsCompact k) (h'k : IsClosed k) {ε : ℝ≥0∞} (hε : ε ≠ 0) :\n    ∀ᶠ g in 𝓝 (1 : G), μ (g • k \\ k) < ε := by\n  obtain ⟨U, hUk, hU, hμUk⟩ : ∃ (U : Set G), k ⊆ U ∧ IsOpen U ∧ μ U < μ k + ε :=\n    hk.exists_isOpen_lt_add hε\n  obtain ⟨V, hV1, hVkU⟩ : ∃ V ∈ 𝓝 (1 : G), V * k ⊆ U := compact_open_separated_mul_left hk hU hUk\n  filter_upwards [hV1] with g hg\n  calc\n    μ (g • k \\ k) ≤ μ (U \\ k) := by\n      gcongr\n      exact (smul_set_subset_smul hg).trans hVkU\n    _ < ε := measure_diff_lt_of_lt_add h'k.nullMeasurableSet hUk hk.measure_lt_top.ne hμUk\n\n"}
{"name":"MeasureTheory.eventually_nhds_one_measure_smul_diff_lt","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_1\ninst✝⁷ : MeasurableSpace G\ninst✝⁶ : TopologicalSpace G\ninst✝⁵ : BorelSpace G\nμ : MeasureTheory.Measure G\ninst✝⁴ : Group G\ninst✝³ : TopologicalGroup G\ninst✝² : LocallyCompactSpace G\ninst✝¹ : MeasureTheory.IsFiniteMeasureOnCompacts μ\ninst✝ : μ.InnerRegularCompactLTTop\nk : Set G\nhk : IsCompact k\nh'k : IsClosed k\nε : ENNReal\nhε : Ne ε 0\n⊢ Filter.Eventually (fun g => LT.lt (μ (SDiff.sdiff (HSMul.hSMul g k) k)) ε) (nhds 1)","decl":"/-- Continuity of the measure of translates of a compact set: Given a compact set `k` in a\ntopological group, for `g` close enough to the origin, `μ (g • k \\ k)` is arbitrarily small. -/\n@[to_additive]\nlemma eventually_nhds_one_measure_smul_diff_lt [LocallyCompactSpace G]\n    [IsFiniteMeasureOnCompacts μ] [InnerRegularCompactLTTop μ] {k : Set G}\n    (hk : IsCompact k) (h'k : IsClosed k) {ε : ℝ≥0∞} (hε : ε ≠ 0) :\n    ∀ᶠ g in 𝓝 (1 : G), μ (g • k \\ k) < ε := by\n  obtain ⟨U, hUk, hU, hμUk⟩ : ∃ (U : Set G), k ⊆ U ∧ IsOpen U ∧ μ U < μ k + ε :=\n    hk.exists_isOpen_lt_add hε\n  obtain ⟨V, hV1, hVkU⟩ : ∃ V ∈ 𝓝 (1 : G), V * k ⊆ U := compact_open_separated_mul_left hk hU hUk\n  filter_upwards [hV1] with g hg\n  calc\n    μ (g • k \\ k) ≤ μ (U \\ k) := by\n      gcongr\n      exact (smul_set_subset_smul hg).trans hVkU\n    _ < ε := measure_diff_lt_of_lt_add h'k.nullMeasurableSet hUk hk.measure_lt_top.ne hμUk\n\n"}
{"name":"MeasureTheory.tendsto_measure_smul_diff_isCompact_isClosed","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_1\ninst✝⁷ : MeasurableSpace G\ninst✝⁶ : TopologicalSpace G\ninst✝⁵ : BorelSpace G\nμ : MeasureTheory.Measure G\ninst✝⁴ : Group G\ninst✝³ : TopologicalGroup G\ninst✝² : LocallyCompactSpace G\ninst✝¹ : MeasureTheory.IsFiniteMeasureOnCompacts μ\ninst✝ : μ.InnerRegularCompactLTTop\nk : Set G\nhk : IsCompact k\nh'k : IsClosed k\n⊢ Filter.Tendsto (fun g => μ (SDiff.sdiff (HSMul.hSMul g k) k)) (nhds 1) (nhds 0)","decl":"/-- Continuity of the measure of translates of a compact set:\nGiven a closed compact set `k` in a topological group,\nthe measure of `g • k \\ k` tends to zero as `g` tends to `1`. -/\n@[to_additive]\nlemma tendsto_measure_smul_diff_isCompact_isClosed [LocallyCompactSpace G]\n    [IsFiniteMeasureOnCompacts μ] [InnerRegularCompactLTTop μ] {k : Set G}\n    (hk : IsCompact k) (h'k : IsClosed k) :\n    Tendsto (fun g : G ↦ μ (g • k \\ k)) (𝓝 1) (𝓝 0) :=\n  ENNReal.nhds_zero_basis.tendsto_right_iff.mpr <| fun _ h ↦\n    eventually_nhds_one_measure_smul_diff_lt hk h'k h.ne'\n\n"}
{"name":"MeasureTheory.tendsto_measure_vadd_diff_isCompact_isClosed","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_1\ninst✝⁷ : MeasurableSpace G\ninst✝⁶ : TopologicalSpace G\ninst✝⁵ : BorelSpace G\nμ : MeasureTheory.Measure G\ninst✝⁴ : AddGroup G\ninst✝³ : TopologicalAddGroup G\ninst✝² : LocallyCompactSpace G\ninst✝¹ : MeasureTheory.IsFiniteMeasureOnCompacts μ\ninst✝ : μ.InnerRegularCompactLTTop\nk : Set G\nhk : IsCompact k\nh'k : IsClosed k\n⊢ Filter.Tendsto (fun g => μ (SDiff.sdiff (HVAdd.hVAdd g k) k)) (nhds 0) (nhds 0)","decl":"/-- Continuity of the measure of translates of a compact set:\nGiven a closed compact set `k` in a topological group,\nthe measure of `g • k \\ k` tends to zero as `g` tends to `1`. -/\n@[to_additive]\nlemma tendsto_measure_smul_diff_isCompact_isClosed [LocallyCompactSpace G]\n    [IsFiniteMeasureOnCompacts μ] [InnerRegularCompactLTTop μ] {k : Set G}\n    (hk : IsCompact k) (h'k : IsClosed k) :\n    Tendsto (fun g : G ↦ μ (g • k \\ k)) (𝓝 1) (𝓝 0) :=\n  ENNReal.nhds_zero_basis.tendsto_right_iff.mpr <| fun _ h ↦\n    eventually_nhds_one_measure_smul_diff_lt hk h'k h.ne'\n\n"}
{"name":"MeasureTheory.isOpenPosMeasure_of_mulLeftInvariant_of_compact","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_1\ninst✝⁵ : MeasurableSpace G\ninst✝⁴ : TopologicalSpace G\ninst✝³ : BorelSpace G\nμ : MeasureTheory.Measure G\ninst✝² : Group G\ninst✝¹ : TopologicalGroup G\ninst✝ : μ.IsMulLeftInvariant\nK : Set G\nhK : IsCompact K\nh : Ne (μ K) 0\n⊢ μ.IsOpenPosMeasure","decl":"/-- If a left-invariant measure gives positive mass to a compact set, then it gives positive mass to\nany open set. -/\n@[to_additive\n\"If a left-invariant measure gives positive mass to a compact set, then it gives positive mass to\nany open set.\"]\ntheorem isOpenPosMeasure_of_mulLeftInvariant_of_compact (K : Set G) (hK : IsCompact K)\n    (h : μ K ≠ 0) : IsOpenPosMeasure μ := by\n  refine ⟨fun U hU hne => ?_⟩\n  contrapose! h\n  rw [← nonpos_iff_eq_zero]\n  rw [← hU.interior_eq] at hne\n  obtain ⟨t, hKt⟩ : ∃ t : Finset G, K ⊆ ⋃ (g : G) (_ : g ∈ t), (fun h : G => g * h) ⁻¹' U :=\n    compact_covered_by_mul_left_translates hK hne\n  calc\n    μ K ≤ μ (⋃ (g : G) (_ : g ∈ t), (fun h : G => g * h) ⁻¹' U) := measure_mono hKt\n    _ ≤ ∑ g ∈ t, μ ((fun h : G => g * h) ⁻¹' U) := measure_biUnion_finset_le _ _\n    _ = 0 := by simp [measure_preimage_mul, h]\n\n"}
{"name":"MeasureTheory.isOpenPosMeasure_of_addLeftInvariant_of_compact","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_1\ninst✝⁵ : MeasurableSpace G\ninst✝⁴ : TopologicalSpace G\ninst✝³ : BorelSpace G\nμ : MeasureTheory.Measure G\ninst✝² : AddGroup G\ninst✝¹ : TopologicalAddGroup G\ninst✝ : μ.IsAddLeftInvariant\nK : Set G\nhK : IsCompact K\nh : Ne (μ K) 0\n⊢ μ.IsOpenPosMeasure","decl":"/-- If a left-invariant measure gives positive mass to a compact set, then it gives positive mass to\nany open set. -/\n@[to_additive\n\"If a left-invariant measure gives positive mass to a compact set, then it gives positive mass to\nany open set.\"]\ntheorem isOpenPosMeasure_of_mulLeftInvariant_of_compact (K : Set G) (hK : IsCompact K)\n    (h : μ K ≠ 0) : IsOpenPosMeasure μ := by\n  refine ⟨fun U hU hne => ?_⟩\n  contrapose! h\n  rw [← nonpos_iff_eq_zero]\n  rw [← hU.interior_eq] at hne\n  obtain ⟨t, hKt⟩ : ∃ t : Finset G, K ⊆ ⋃ (g : G) (_ : g ∈ t), (fun h : G => g * h) ⁻¹' U :=\n    compact_covered_by_mul_left_translates hK hne\n  calc\n    μ K ≤ μ (⋃ (g : G) (_ : g ∈ t), (fun h : G => g * h) ⁻¹' U) := measure_mono hKt\n    _ ≤ ∑ g ∈ t, μ ((fun h : G => g * h) ⁻¹' U) := measure_biUnion_finset_le _ _\n    _ = 0 := by simp [measure_preimage_mul, h]\n\n"}
{"name":"MeasureTheory.isOpenPosMeasure_of_addLeftInvariant_of_regular","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_1\ninst✝⁷ : MeasurableSpace G\ninst✝⁶ : TopologicalSpace G\ninst✝⁵ : BorelSpace G\nμ : MeasureTheory.Measure G\ninst✝⁴ : AddGroup G\ninst✝³ : TopologicalAddGroup G\ninst✝² : μ.IsAddLeftInvariant\ninst✝¹ : μ.Regular\ninst✝ : NeZero μ\n⊢ μ.IsOpenPosMeasure","decl":"/-- A nonzero left-invariant regular measure gives positive mass to any open set. -/\n@[to_additive \"A nonzero left-invariant regular measure gives positive mass to any open set.\"]\ninstance (priority := 80) isOpenPosMeasure_of_mulLeftInvariant_of_regular [Regular μ] [NeZero μ] :\n    IsOpenPosMeasure μ :=\n  let ⟨K, hK, h2K⟩ := Regular.exists_isCompact_not_null.mpr (NeZero.ne μ)\n  isOpenPosMeasure_of_mulLeftInvariant_of_compact K hK h2K\n\n"}
{"name":"MeasureTheory.isOpenPosMeasure_of_mulLeftInvariant_of_regular","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_1\ninst✝⁷ : MeasurableSpace G\ninst✝⁶ : TopologicalSpace G\ninst✝⁵ : BorelSpace G\nμ : MeasureTheory.Measure G\ninst✝⁴ : Group G\ninst✝³ : TopologicalGroup G\ninst✝² : μ.IsMulLeftInvariant\ninst✝¹ : μ.Regular\ninst✝ : NeZero μ\n⊢ μ.IsOpenPosMeasure","decl":"/-- A nonzero left-invariant regular measure gives positive mass to any open set. -/\n@[to_additive \"A nonzero left-invariant regular measure gives positive mass to any open set.\"]\ninstance (priority := 80) isOpenPosMeasure_of_mulLeftInvariant_of_regular [Regular μ] [NeZero μ] :\n    IsOpenPosMeasure μ :=\n  let ⟨K, hK, h2K⟩ := Regular.exists_isCompact_not_null.mpr (NeZero.ne μ)\n  isOpenPosMeasure_of_mulLeftInvariant_of_compact K hK h2K\n\n"}
{"name":"MeasureTheory.isOpenPosMeasure_of_mulLeftInvariant_of_innerRegular","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_1\ninst✝⁷ : MeasurableSpace G\ninst✝⁶ : TopologicalSpace G\ninst✝⁵ : BorelSpace G\nμ : MeasureTheory.Measure G\ninst✝⁴ : Group G\ninst✝³ : TopologicalGroup G\ninst✝² : μ.IsMulLeftInvariant\ninst✝¹ : μ.InnerRegular\ninst✝ : NeZero μ\n⊢ μ.IsOpenPosMeasure","decl":"/-- A nonzero left-invariant inner regular measure gives positive mass to any open set. -/\n@[to_additive \"A nonzero left-invariant inner regular measure gives positive mass to any open set.\"]\ninstance (priority := 80) isOpenPosMeasure_of_mulLeftInvariant_of_innerRegular\n    [InnerRegular μ] [NeZero μ] :\n    IsOpenPosMeasure μ :=\n  let ⟨K, hK, h2K⟩ := InnerRegular.exists_isCompact_not_null.mpr (NeZero.ne μ)\n  isOpenPosMeasure_of_mulLeftInvariant_of_compact K hK h2K\n\n"}
{"name":"MeasureTheory.isOpenPosMeasure_of_addLeftInvariant_of_innerRegular","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_1\ninst✝⁷ : MeasurableSpace G\ninst✝⁶ : TopologicalSpace G\ninst✝⁵ : BorelSpace G\nμ : MeasureTheory.Measure G\ninst✝⁴ : AddGroup G\ninst✝³ : TopologicalAddGroup G\ninst✝² : μ.IsAddLeftInvariant\ninst✝¹ : μ.InnerRegular\ninst✝ : NeZero μ\n⊢ μ.IsOpenPosMeasure","decl":"/-- A nonzero left-invariant inner regular measure gives positive mass to any open set. -/\n@[to_additive \"A nonzero left-invariant inner regular measure gives positive mass to any open set.\"]\ninstance (priority := 80) isOpenPosMeasure_of_mulLeftInvariant_of_innerRegular\n    [InnerRegular μ] [NeZero μ] :\n    IsOpenPosMeasure μ :=\n  let ⟨K, hK, h2K⟩ := InnerRegular.exists_isCompact_not_null.mpr (NeZero.ne μ)\n  isOpenPosMeasure_of_mulLeftInvariant_of_compact K hK h2K\n\n"}
{"name":"MeasureTheory.null_iff_of_isAddLeftInvariant","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_1\ninst✝⁶ : MeasurableSpace G\ninst✝⁵ : TopologicalSpace G\ninst✝⁴ : BorelSpace G\nμ : MeasureTheory.Measure G\ninst✝³ : AddGroup G\ninst✝² : TopologicalAddGroup G\ninst✝¹ : μ.IsAddLeftInvariant\ninst✝ : μ.Regular\ns : Set G\nhs : IsOpen s\n⊢ Iff (Eq (μ s) 0) (Or (Eq s EmptyCollection.emptyCollection) (Eq μ 0))","decl":"@[to_additive]\ntheorem null_iff_of_isMulLeftInvariant [Regular μ] {s : Set G} (hs : IsOpen s) :\n    μ s = 0 ↔ s = ∅ ∨ μ = 0 := by\n  rcases eq_zero_or_neZero μ with rfl|hμ\n  · simp\n  · simp only [or_false, hs.measure_eq_zero_iff μ, NeZero.ne μ]\n\n"}
{"name":"MeasureTheory.null_iff_of_isMulLeftInvariant","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_1\ninst✝⁶ : MeasurableSpace G\ninst✝⁵ : TopologicalSpace G\ninst✝⁴ : BorelSpace G\nμ : MeasureTheory.Measure G\ninst✝³ : Group G\ninst✝² : TopologicalGroup G\ninst✝¹ : μ.IsMulLeftInvariant\ninst✝ : μ.Regular\ns : Set G\nhs : IsOpen s\n⊢ Iff (Eq (μ s) 0) (Or (Eq s EmptyCollection.emptyCollection) (Eq μ 0))","decl":"@[to_additive]\ntheorem null_iff_of_isMulLeftInvariant [Regular μ] {s : Set G} (hs : IsOpen s) :\n    μ s = 0 ↔ s = ∅ ∨ μ = 0 := by\n  rcases eq_zero_or_neZero μ with rfl|hμ\n  · simp\n  · simp only [or_false, hs.measure_eq_zero_iff μ, NeZero.ne μ]\n\n"}
{"name":"MeasureTheory.measure_ne_zero_iff_nonempty_of_isMulLeftInvariant","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_1\ninst✝⁶ : MeasurableSpace G\ninst✝⁵ : TopologicalSpace G\ninst✝⁴ : BorelSpace G\nμ : MeasureTheory.Measure G\ninst✝³ : Group G\ninst✝² : TopologicalGroup G\ninst✝¹ : μ.IsMulLeftInvariant\ninst✝ : μ.Regular\nhμ : Ne μ 0\ns : Set G\nhs : IsOpen s\n⊢ Iff (Ne (μ s) 0) s.Nonempty","decl":"@[to_additive]\ntheorem measure_ne_zero_iff_nonempty_of_isMulLeftInvariant [Regular μ] (hμ : μ ≠ 0) {s : Set G}\n    (hs : IsOpen s) : μ s ≠ 0 ↔ s.Nonempty := by\n  simpa [null_iff_of_isMulLeftInvariant (μ := μ) hs, hμ] using nonempty_iff_ne_empty.symm\n\n"}
{"name":"MeasureTheory.measure_ne_zero_iff_nonempty_of_isAddLeftInvariant","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_1\ninst✝⁶ : MeasurableSpace G\ninst✝⁵ : TopologicalSpace G\ninst✝⁴ : BorelSpace G\nμ : MeasureTheory.Measure G\ninst✝³ : AddGroup G\ninst✝² : TopologicalAddGroup G\ninst✝¹ : μ.IsAddLeftInvariant\ninst✝ : μ.Regular\nhμ : Ne μ 0\ns : Set G\nhs : IsOpen s\n⊢ Iff (Ne (μ s) 0) s.Nonempty","decl":"@[to_additive]\ntheorem measure_ne_zero_iff_nonempty_of_isMulLeftInvariant [Regular μ] (hμ : μ ≠ 0) {s : Set G}\n    (hs : IsOpen s) : μ s ≠ 0 ↔ s.Nonempty := by\n  simpa [null_iff_of_isMulLeftInvariant (μ := μ) hs, hμ] using nonempty_iff_ne_empty.symm\n\n"}
{"name":"MeasureTheory.measure_pos_iff_nonempty_of_isMulLeftInvariant","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_1\ninst✝⁶ : MeasurableSpace G\ninst✝⁵ : TopologicalSpace G\ninst✝⁴ : BorelSpace G\nμ : MeasureTheory.Measure G\ninst✝³ : Group G\ninst✝² : TopologicalGroup G\ninst✝¹ : μ.IsMulLeftInvariant\ninst✝ : μ.Regular\nh3μ : Ne μ 0\ns : Set G\nhs : IsOpen s\n⊢ Iff (LT.lt 0 (μ s)) s.Nonempty","decl":"@[to_additive]\ntheorem measure_pos_iff_nonempty_of_isMulLeftInvariant [Regular μ] (h3μ : μ ≠ 0) {s : Set G}\n    (hs : IsOpen s) : 0 < μ s ↔ s.Nonempty :=\n  pos_iff_ne_zero.trans <| measure_ne_zero_iff_nonempty_of_isMulLeftInvariant h3μ hs\n\n"}
{"name":"MeasureTheory.measure_pos_iff_nonempty_of_isAddLeftInvariant","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_1\ninst✝⁶ : MeasurableSpace G\ninst✝⁵ : TopologicalSpace G\ninst✝⁴ : BorelSpace G\nμ : MeasureTheory.Measure G\ninst✝³ : AddGroup G\ninst✝² : TopologicalAddGroup G\ninst✝¹ : μ.IsAddLeftInvariant\ninst✝ : μ.Regular\nh3μ : Ne μ 0\ns : Set G\nhs : IsOpen s\n⊢ Iff (LT.lt 0 (μ s)) s.Nonempty","decl":"@[to_additive]\ntheorem measure_pos_iff_nonempty_of_isMulLeftInvariant [Regular μ] (h3μ : μ ≠ 0) {s : Set G}\n    (hs : IsOpen s) : 0 < μ s ↔ s.Nonempty :=\n  pos_iff_ne_zero.trans <| measure_ne_zero_iff_nonempty_of_isMulLeftInvariant h3μ hs\n\n"}
{"name":"MeasureTheory.measure_lt_top_of_isCompact_of_isMulLeftInvariant","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_1\ninst✝⁵ : MeasurableSpace G\ninst✝⁴ : TopologicalSpace G\ninst✝³ : BorelSpace G\nμ : MeasureTheory.Measure G\ninst✝² : Group G\ninst✝¹ : TopologicalGroup G\ninst✝ : μ.IsMulLeftInvariant\nU : Set G\nhU : IsOpen U\nh'U : U.Nonempty\nh : Ne (μ U) Top.top\nK : Set G\nhK : IsCompact K\n⊢ LT.lt (μ K) Top.top","decl":"/-- If a left-invariant measure gives finite mass to a nonempty open set, then it gives finite mass\nto any compact set. -/\n@[to_additive\n\"If a left-invariant measure gives finite mass to a nonempty open set, then it gives finite mass to\nany compact set.\"]\ntheorem measure_lt_top_of_isCompact_of_isMulLeftInvariant (U : Set G) (hU : IsOpen U)\n    (h'U : U.Nonempty) (h : μ U ≠ ∞) {K : Set G} (hK : IsCompact K) : μ K < ∞ := by\n  rw [← hU.interior_eq] at h'U\n  obtain ⟨t, hKt⟩ : ∃ t : Finset G, K ⊆ ⋃ g ∈ t, (fun h : G => g * h) ⁻¹' U :=\n    compact_covered_by_mul_left_translates hK h'U\n  exact (measure_mono hKt).trans_lt <| measure_biUnion_lt_top t.finite_toSet <| by simp [h.lt_top]\n\n"}
{"name":"MeasureTheory.measure_lt_top_of_isCompact_of_isAddLeftInvariant","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_1\ninst✝⁵ : MeasurableSpace G\ninst✝⁴ : TopologicalSpace G\ninst✝³ : BorelSpace G\nμ : MeasureTheory.Measure G\ninst✝² : AddGroup G\ninst✝¹ : TopologicalAddGroup G\ninst✝ : μ.IsAddLeftInvariant\nU : Set G\nhU : IsOpen U\nh'U : U.Nonempty\nh : Ne (μ U) Top.top\nK : Set G\nhK : IsCompact K\n⊢ LT.lt (μ K) Top.top","decl":"/-- If a left-invariant measure gives finite mass to a nonempty open set, then it gives finite mass\nto any compact set. -/\n@[to_additive\n\"If a left-invariant measure gives finite mass to a nonempty open set, then it gives finite mass to\nany compact set.\"]\ntheorem measure_lt_top_of_isCompact_of_isMulLeftInvariant (U : Set G) (hU : IsOpen U)\n    (h'U : U.Nonempty) (h : μ U ≠ ∞) {K : Set G} (hK : IsCompact K) : μ K < ∞ := by\n  rw [← hU.interior_eq] at h'U\n  obtain ⟨t, hKt⟩ : ∃ t : Finset G, K ⊆ ⋃ g ∈ t, (fun h : G => g * h) ⁻¹' U :=\n    compact_covered_by_mul_left_translates hK h'U\n  exact (measure_mono hKt).trans_lt <| measure_biUnion_lt_top t.finite_toSet <| by simp [h.lt_top]\n\n"}
{"name":"MeasureTheory.measure_lt_top_of_isCompact_of_isMulLeftInvariant'","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_1\ninst✝⁵ : MeasurableSpace G\ninst✝⁴ : TopologicalSpace G\ninst✝³ : BorelSpace G\nμ : MeasureTheory.Measure G\ninst✝² : Group G\ninst✝¹ : TopologicalGroup G\ninst✝ : μ.IsMulLeftInvariant\nU : Set G\nhU : (interior U).Nonempty\nh : Ne (μ U) Top.top\nK : Set G\nhK : IsCompact K\n⊢ LT.lt (μ K) Top.top","decl":"/-- If a left-invariant measure gives finite mass to a set with nonempty interior, then\nit gives finite mass to any compact set. -/\n@[to_additive\n\"If a left-invariant measure gives finite mass to a set with nonempty interior, then it gives finite\nmass to any compact set.\"]\ntheorem measure_lt_top_of_isCompact_of_isMulLeftInvariant' {U : Set G}\n    (hU : (interior U).Nonempty) (h : μ U ≠ ∞) {K : Set G} (hK : IsCompact K) : μ K < ∞ :=\n  measure_lt_top_of_isCompact_of_isMulLeftInvariant (interior U) isOpen_interior hU\n    ((measure_mono interior_subset).trans_lt (lt_top_iff_ne_top.2 h)).ne hK\n\n"}
{"name":"MeasureTheory.measure_lt_top_of_isCompact_of_isAddLeftInvariant'","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_1\ninst✝⁵ : MeasurableSpace G\ninst✝⁴ : TopologicalSpace G\ninst✝³ : BorelSpace G\nμ : MeasureTheory.Measure G\ninst✝² : AddGroup G\ninst✝¹ : TopologicalAddGroup G\ninst✝ : μ.IsAddLeftInvariant\nU : Set G\nhU : (interior U).Nonempty\nh : Ne (μ U) Top.top\nK : Set G\nhK : IsCompact K\n⊢ LT.lt (μ K) Top.top","decl":"/-- If a left-invariant measure gives finite mass to a set with nonempty interior, then\nit gives finite mass to any compact set. -/\n@[to_additive\n\"If a left-invariant measure gives finite mass to a set with nonempty interior, then it gives finite\nmass to any compact set.\"]\ntheorem measure_lt_top_of_isCompact_of_isMulLeftInvariant' {U : Set G}\n    (hU : (interior U).Nonempty) (h : μ U ≠ ∞) {K : Set G} (hK : IsCompact K) : μ K < ∞ :=\n  measure_lt_top_of_isCompact_of_isMulLeftInvariant (interior U) isOpen_interior hU\n    ((measure_mono interior_subset).trans_lt (lt_top_iff_ne_top.2 h)).ne hK\n\n"}
{"name":"MeasureTheory.measure_univ_of_isMulLeftInvariant","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_1\ninst✝⁸ : MeasurableSpace G\ninst✝⁷ : TopologicalSpace G\ninst✝⁶ : BorelSpace G\ninst✝⁵ : Group G\ninst✝⁴ : TopologicalGroup G\ninst✝³ : WeaklyLocallyCompactSpace G\ninst✝² : NoncompactSpace G\nμ : MeasureTheory.Measure G\ninst✝¹ : μ.IsOpenPosMeasure\ninst✝ : μ.IsMulLeftInvariant\n⊢ Eq (μ Set.univ) Top.top","decl":"/-- In a noncompact locally compact group, a left-invariant measure which is positive\non open sets has infinite mass. -/\n@[to_additive (attr := simp)\n\"In a noncompact locally compact additive group, a left-invariant measure which is positive on open\nsets has infinite mass.\"]\ntheorem measure_univ_of_isMulLeftInvariant [WeaklyLocallyCompactSpace G] [NoncompactSpace G]\n    (μ : Measure G) [IsOpenPosMeasure μ] [μ.IsMulLeftInvariant] : μ univ = ∞ := by\n  /- Consider a closed compact set `K` with nonempty interior. For any compact set `L`, one may\n    find `g = g (L)` such that `L` is disjoint from `g • K`. Iterating this, one finds\n    infinitely many translates of `K` which are disjoint from each other. As they all have the\n    same positive mass, it follows that the space has infinite measure. -/\n  obtain ⟨K, K1, hK, Kclosed⟩ : ∃ K ∈ 𝓝 (1 : G), IsCompact K ∧ IsClosed K :=\n    exists_mem_nhds_isCompact_isClosed 1\n  have K_pos : 0 < μ K := measure_pos_of_mem_nhds μ K1\n  have A : ∀ L : Set G, IsCompact L → ∃ g : G, Disjoint L (g • K) := fun L hL =>\n    exists_disjoint_smul_of_isCompact hL hK\n  choose! g hg using A\n  set L : ℕ → Set G := fun n => (fun T => T ∪ g T • K)^[n] K\n  have Lcompact : ∀ n, IsCompact (L n) := by\n    intro n\n    induction' n with n IH\n    · exact hK\n    · simp_rw [L, iterate_succ']\n      apply IsCompact.union IH (hK.smul (g (L n)))\n  have Lclosed : ∀ n, IsClosed (L n) := by\n    intro n\n    induction' n with n IH\n    · exact Kclosed\n    · simp_rw [L, iterate_succ']\n      apply IsClosed.union IH (Kclosed.smul (g (L n)))\n  have M : ∀ n, μ (L n) = (n + 1 : ℕ) * μ K := by\n    intro n\n    induction' n with n IH\n    · simp only [L, one_mul, Nat.cast_one, iterate_zero, id, Nat.zero_add]\n    · calc\n        μ (L (n + 1)) = μ (L n) + μ (g (L n) • K) := by\n          simp_rw [L, iterate_succ']\n          exact measure_union' (hg _ (Lcompact _)) (Lclosed _).measurableSet\n        _ = (n + 1 + 1 : ℕ) * μ K := by\n          simp only [IH, measure_smul, add_mul, Nat.cast_add, Nat.cast_one, one_mul]\n  have N : Tendsto (fun n => μ (L n)) atTop (𝓝 (∞ * μ K)) := by\n    simp_rw [M]\n    apply ENNReal.Tendsto.mul_const _ (Or.inl ENNReal.top_ne_zero)\n    exact ENNReal.tendsto_nat_nhds_top.comp (tendsto_add_atTop_nat _)\n  simp only [ENNReal.top_mul', K_pos.ne', if_false] at N\n  apply top_le_iff.1\n  exact le_of_tendsto' N fun n => measure_mono (subset_univ _)\n\n"}
{"name":"MeasureTheory.measure_univ_of_isAddLeftInvariant","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_1\ninst✝⁸ : MeasurableSpace G\ninst✝⁷ : TopologicalSpace G\ninst✝⁶ : BorelSpace G\ninst✝⁵ : AddGroup G\ninst✝⁴ : TopologicalAddGroup G\ninst✝³ : WeaklyLocallyCompactSpace G\ninst✝² : NoncompactSpace G\nμ : MeasureTheory.Measure G\ninst✝¹ : μ.IsOpenPosMeasure\ninst✝ : μ.IsAddLeftInvariant\n⊢ Eq (μ Set.univ) Top.top","decl":"/-- In a noncompact locally compact group, a left-invariant measure which is positive\non open sets has infinite mass. -/\n@[to_additive (attr := simp)\n\"In a noncompact locally compact additive group, a left-invariant measure which is positive on open\nsets has infinite mass.\"]\ntheorem measure_univ_of_isMulLeftInvariant [WeaklyLocallyCompactSpace G] [NoncompactSpace G]\n    (μ : Measure G) [IsOpenPosMeasure μ] [μ.IsMulLeftInvariant] : μ univ = ∞ := by\n  /- Consider a closed compact set `K` with nonempty interior. For any compact set `L`, one may\n    find `g = g (L)` such that `L` is disjoint from `g • K`. Iterating this, one finds\n    infinitely many translates of `K` which are disjoint from each other. As they all have the\n    same positive mass, it follows that the space has infinite measure. -/\n  obtain ⟨K, K1, hK, Kclosed⟩ : ∃ K ∈ 𝓝 (1 : G), IsCompact K ∧ IsClosed K :=\n    exists_mem_nhds_isCompact_isClosed 1\n  have K_pos : 0 < μ K := measure_pos_of_mem_nhds μ K1\n  have A : ∀ L : Set G, IsCompact L → ∃ g : G, Disjoint L (g • K) := fun L hL =>\n    exists_disjoint_smul_of_isCompact hL hK\n  choose! g hg using A\n  set L : ℕ → Set G := fun n => (fun T => T ∪ g T • K)^[n] K\n  have Lcompact : ∀ n, IsCompact (L n) := by\n    intro n\n    induction' n with n IH\n    · exact hK\n    · simp_rw [L, iterate_succ']\n      apply IsCompact.union IH (hK.smul (g (L n)))\n  have Lclosed : ∀ n, IsClosed (L n) := by\n    intro n\n    induction' n with n IH\n    · exact Kclosed\n    · simp_rw [L, iterate_succ']\n      apply IsClosed.union IH (Kclosed.smul (g (L n)))\n  have M : ∀ n, μ (L n) = (n + 1 : ℕ) * μ K := by\n    intro n\n    induction' n with n IH\n    · simp only [L, one_mul, Nat.cast_one, iterate_zero, id, Nat.zero_add]\n    · calc\n        μ (L (n + 1)) = μ (L n) + μ (g (L n) • K) := by\n          simp_rw [L, iterate_succ']\n          exact measure_union' (hg _ (Lcompact _)) (Lclosed _).measurableSet\n        _ = (n + 1 + 1 : ℕ) * μ K := by\n          simp only [IH, measure_smul, add_mul, Nat.cast_add, Nat.cast_one, one_mul]\n  have N : Tendsto (fun n => μ (L n)) atTop (𝓝 (∞ * μ K)) := by\n    simp_rw [M]\n    apply ENNReal.Tendsto.mul_const _ (Or.inl ENNReal.top_ne_zero)\n    exact ENNReal.tendsto_nat_nhds_top.comp (tendsto_add_atTop_nat _)\n  simp only [ENNReal.top_mul', K_pos.ne', if_false] at N\n  apply top_le_iff.1\n  exact le_of_tendsto' N fun n => measure_mono (subset_univ _)\n\n"}
{"name":"MeasurableSet.add_closure_zero_eq","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_1\ninst✝⁴ : MeasurableSpace G\ninst✝³ : TopologicalSpace G\ninst✝² : BorelSpace G\ninst✝¹ : AddGroup G\ninst✝ : TopologicalAddGroup G\ns : Set G\nhs : MeasurableSet s\n⊢ Eq (HAdd.hAdd s (closure (Singleton.singleton 0))) s","decl":"@[to_additive]\nlemma _root_.MeasurableSet.mul_closure_one_eq {s : Set G} (hs : MeasurableSet s) :\n    s * (closure {1} : Set G) = s := by\n  induction s, hs using MeasurableSet.induction_on_open with\n  | isOpen U hU => exact hU.mul_closure_one_eq\n  | compl t _ iht => exact compl_mul_closure_one_eq_iff.2 iht\n  | iUnion f _ _ ihf => simp_rw [iUnion_mul f, ihf]\n\n"}
{"name":"MeasurableSet.mul_closure_one_eq","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_1\ninst✝⁴ : MeasurableSpace G\ninst✝³ : TopologicalSpace G\ninst✝² : BorelSpace G\ninst✝¹ : Group G\ninst✝ : TopologicalGroup G\ns : Set G\nhs : MeasurableSet s\n⊢ Eq (HMul.hMul s (closure (Singleton.singleton 1))) s","decl":"@[to_additive]\nlemma _root_.MeasurableSet.mul_closure_one_eq {s : Set G} (hs : MeasurableSet s) :\n    s * (closure {1} : Set G) = s := by\n  induction s, hs using MeasurableSet.induction_on_open with\n  | isOpen U hU => exact hU.mul_closure_one_eq\n  | compl t _ iht => exact compl_mul_closure_one_eq_iff.2 iht\n  | iUnion f _ _ ihf => simp_rw [iUnion_mul f, ihf]\n\n"}
{"name":"MeasureTheory.measure_mul_closure_one","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_1\ninst✝⁴ : MeasurableSpace G\ninst✝³ : TopologicalSpace G\ninst✝² : BorelSpace G\ninst✝¹ : Group G\ninst✝ : TopologicalGroup G\ns : Set G\nμ : MeasureTheory.Measure G\n⊢ Eq (μ (HMul.hMul s (closure (Singleton.singleton 1)))) (μ s)","decl":"@[to_additive (attr := simp)]\nlemma measure_mul_closure_one (s : Set G) (μ : Measure G) :\n    μ (s * (closure {1} : Set G)) = μ s := by\n  apply le_antisymm ?_ (measure_mono (subset_mul_closure_one s))\n  conv_rhs => rw [measure_eq_iInf]\n  simp only [le_iInf_iff]\n  intro t kt t_meas\n  apply measure_mono\n  rw [← t_meas.mul_closure_one_eq]\n  exact smul_subset_smul_right kt\n\n"}
{"name":"MeasureTheory.measure_add_closure_zero","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_1\ninst✝⁴ : MeasurableSpace G\ninst✝³ : TopologicalSpace G\ninst✝² : BorelSpace G\ninst✝¹ : AddGroup G\ninst✝ : TopologicalAddGroup G\ns : Set G\nμ : MeasureTheory.Measure G\n⊢ Eq (μ (HAdd.hAdd s (closure (Singleton.singleton 0)))) (μ s)","decl":"@[to_additive (attr := simp)]\nlemma measure_mul_closure_one (s : Set G) (μ : Measure G) :\n    μ (s * (closure {1} : Set G)) = μ s := by\n  apply le_antisymm ?_ (measure_mono (subset_mul_closure_one s))\n  conv_rhs => rw [measure_eq_iInf]\n  simp only [le_iInf_iff]\n  intro t kt t_meas\n  apply measure_mono\n  rw [← t_meas.mul_closure_one_eq]\n  exact smul_subset_smul_right kt\n\n"}
{"name":"MeasureTheory.innerRegularWRT_isCompact_isClosed_measure_ne_top_of_addGroup","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_1\ninst✝⁴ : MeasurableSpace G\ninst✝³ : TopologicalSpace G\ninst✝² : BorelSpace G\nμ : MeasureTheory.Measure G\ninst✝¹ : AddGroup G\ninst✝ : TopologicalAddGroup G\nh : μ.InnerRegularCompactLTTop\n⊢ μ.InnerRegularWRT (fun s => And (IsCompact s) (IsClosed s)) fun s => And (MeasurableSet s) (Ne (μ s) Top.top)","decl":"@[to_additive]\nlemma innerRegularWRT_isCompact_isClosed_measure_ne_top_of_group [h : InnerRegularCompactLTTop μ] :\n    InnerRegularWRT μ (fun s ↦ IsCompact s ∧ IsClosed s) (fun s ↦ MeasurableSet s ∧ μ s ≠ ∞) := by\n  intro s ⟨s_meas, μs⟩ r hr\n  rcases h.innerRegular ⟨s_meas, μs⟩ r hr with ⟨K, Ks, K_comp, hK⟩\n  refine ⟨closure K, ?_, ⟨K_comp.closure, isClosed_closure⟩, ?_⟩\n  · exact IsCompact.closure_subset_measurableSet K_comp s_meas Ks\n  · rwa [K_comp.measure_closure]\n\n"}
{"name":"MeasureTheory.innerRegularWRT_isCompact_isClosed_measure_ne_top_of_group","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_1\ninst✝⁴ : MeasurableSpace G\ninst✝³ : TopologicalSpace G\ninst✝² : BorelSpace G\nμ : MeasureTheory.Measure G\ninst✝¹ : Group G\ninst✝ : TopologicalGroup G\nh : μ.InnerRegularCompactLTTop\n⊢ μ.InnerRegularWRT (fun s => And (IsCompact s) (IsClosed s)) fun s => And (MeasurableSet s) (Ne (μ s) Top.top)","decl":"@[to_additive]\nlemma innerRegularWRT_isCompact_isClosed_measure_ne_top_of_group [h : InnerRegularCompactLTTop μ] :\n    InnerRegularWRT μ (fun s ↦ IsCompact s ∧ IsClosed s) (fun s ↦ MeasurableSet s ∧ μ s ≠ ∞) := by\n  intro s ⟨s_meas, μs⟩ r hr\n  rcases h.innerRegular ⟨s_meas, μs⟩ r hr with ⟨K, Ks, K_comp, hK⟩\n  refine ⟨closure K, ?_, ⟨K_comp.closure, isClosed_closure⟩, ?_⟩\n  · exact IsCompact.closure_subset_measurableSet K_comp s_meas Ks\n  · rwa [K_comp.measure_closure]\n\n"}
{"name":"MeasureTheory.IsMulLeftInvariant.isMulRightInvariant","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_1\ninst✝² : MeasurableSpace G\ninst✝¹ : CommSemigroup G\nμ : MeasureTheory.Measure G\ninst✝ : μ.IsMulLeftInvariant\n⊢ μ.IsMulRightInvariant","decl":"/-- In an abelian group every left invariant measure is also right-invariant.\n  We don't declare the converse as an instance, since that would loop type-class inference, and\n  we use `IsMulLeftInvariant` as the default hypothesis in abelian groups. -/\n@[to_additive IsAddLeftInvariant.isAddRightInvariant\n\"In an abelian additive group every left invariant measure is also right-invariant. We don't declare\nthe converse as an instance, since that would loop type-class inference, and we use\n`IsAddLeftInvariant` as the default hypothesis in abelian groups.\"]\ninstance (priority := 100) IsMulLeftInvariant.isMulRightInvariant {μ : Measure G}\n    [IsMulLeftInvariant μ] : IsMulRightInvariant μ :=\n  ⟨fun g => by simp_rw [mul_comm, map_mul_left_eq_self]⟩\n\n"}
{"name":"MeasureTheory.IsAddLeftInvariant.isAddRightInvariant","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_1\ninst✝² : MeasurableSpace G\ninst✝¹ : AddCommSemigroup G\nμ : MeasureTheory.Measure G\ninst✝ : μ.IsAddLeftInvariant\n⊢ μ.IsAddRightInvariant","decl":"/-- In an abelian group every left invariant measure is also right-invariant.\n  We don't declare the converse as an instance, since that would loop type-class inference, and\n  we use `IsMulLeftInvariant` as the default hypothesis in abelian groups. -/\n@[to_additive IsAddLeftInvariant.isAddRightInvariant\n\"In an abelian additive group every left invariant measure is also right-invariant. We don't declare\nthe converse as an instance, since that would loop type-class inference, and we use\n`IsAddLeftInvariant` as the default hypothesis in abelian groups.\"]\ninstance (priority := 100) IsMulLeftInvariant.isMulRightInvariant {μ : Measure G}\n    [IsMulLeftInvariant μ] : IsMulRightInvariant μ :=\n  ⟨fun g => by simp_rw [mul_comm, map_mul_left_eq_self]⟩\n\n"}
{"name":"MeasureTheory.Measure.IsAddHaarMeasure.toIsAddLeftInvariant","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_3\ninst✝² : AddGroup G\ninst✝¹ : TopologicalSpace G\ninst✝ : MeasurableSpace G\nμ : MeasureTheory.Measure G\nself : μ.IsAddHaarMeasure\n⊢ μ.IsAddLeftInvariant","decl":"/-- A measure on an additive group is an additive Haar measure if it is left-invariant, and\ngives finite mass to compact sets and positive mass to open sets.\n\nTextbooks generally require an additional regularity assumption to ensure nice behavior on\narbitrary locally compact groups. Use `[IsAddHaarMeasure μ] [Regular μ]` or\n`[IsAddHaarMeasure μ] [InnerRegular μ]` in these situations. Note that a Haar measure in our\nsense is automatically regular and inner regular on second countable locally compact groups, as\nchecked just below this definition. -/\nclass IsAddHaarMeasure {G : Type*} [AddGroup G] [TopologicalSpace G] [MeasurableSpace G]\n  (μ : Measure G) extends IsFiniteMeasureOnCompacts μ, IsAddLeftInvariant μ, IsOpenPosMeasure μ :\n  Prop\n\n"}
{"name":"MeasureTheory.Measure.IsAddHaarMeasure.toIsFiniteMeasureOnCompacts","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_3\ninst✝² : AddGroup G\ninst✝¹ : TopologicalSpace G\ninst✝ : MeasurableSpace G\nμ : MeasureTheory.Measure G\nself : μ.IsAddHaarMeasure\n⊢ MeasureTheory.IsFiniteMeasureOnCompacts μ","decl":"/-- A measure on an additive group is an additive Haar measure if it is left-invariant, and\ngives finite mass to compact sets and positive mass to open sets.\n\nTextbooks generally require an additional regularity assumption to ensure nice behavior on\narbitrary locally compact groups. Use `[IsAddHaarMeasure μ] [Regular μ]` or\n`[IsAddHaarMeasure μ] [InnerRegular μ]` in these situations. Note that a Haar measure in our\nsense is automatically regular and inner regular on second countable locally compact groups, as\nchecked just below this definition. -/\nclass IsAddHaarMeasure {G : Type*} [AddGroup G] [TopologicalSpace G] [MeasurableSpace G]\n  (μ : Measure G) extends IsFiniteMeasureOnCompacts μ, IsAddLeftInvariant μ, IsOpenPosMeasure μ :\n  Prop\n\n"}
{"name":"MeasureTheory.Measure.IsAddHaarMeasure.toIsOpenPosMeasure","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_3\ninst✝² : AddGroup G\ninst✝¹ : TopologicalSpace G\ninst✝ : MeasurableSpace G\nμ : MeasureTheory.Measure G\nself : μ.IsAddHaarMeasure\n⊢ μ.IsOpenPosMeasure","decl":"/-- A measure on an additive group is an additive Haar measure if it is left-invariant, and\ngives finite mass to compact sets and positive mass to open sets.\n\nTextbooks generally require an additional regularity assumption to ensure nice behavior on\narbitrary locally compact groups. Use `[IsAddHaarMeasure μ] [Regular μ]` or\n`[IsAddHaarMeasure μ] [InnerRegular μ]` in these situations. Note that a Haar measure in our\nsense is automatically regular and inner regular on second countable locally compact groups, as\nchecked just below this definition. -/\nclass IsAddHaarMeasure {G : Type*} [AddGroup G] [TopologicalSpace G] [MeasurableSpace G]\n  (μ : Measure G) extends IsFiniteMeasureOnCompacts μ, IsAddLeftInvariant μ, IsOpenPosMeasure μ :\n  Prop\n\n"}
{"name":"MeasureTheory.Measure.IsHaarMeasure.toIsOpenPosMeasure","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_3\ninst✝² : Group G\ninst✝¹ : TopologicalSpace G\ninst✝ : MeasurableSpace G\nμ : MeasureTheory.Measure G\nself : μ.IsHaarMeasure\n⊢ μ.IsOpenPosMeasure","decl":"/-- A measure on a group is a Haar measure if it is left-invariant, and gives finite mass to\ncompact sets and positive mass to open sets.\n\nTextbooks generally require an additional regularity assumption to ensure nice behavior on\narbitrary locally compact groups. Use `[IsHaarMeasure μ] [Regular μ]` or\n`[IsHaarMeasure μ] [InnerRegular μ]` in these situations. Note that a Haar measure in our\nsense is automatically regular and inner regular on second countable locally compact groups, as\nchecked just below this definition. -/\n@[to_additive existing]\nclass IsHaarMeasure {G : Type*} [Group G] [TopologicalSpace G] [MeasurableSpace G]\n  (μ : Measure G) extends IsFiniteMeasureOnCompacts μ, IsMulLeftInvariant μ, IsOpenPosMeasure μ :\n  Prop\n\n"}
{"name":"MeasureTheory.Measure.IsHaarMeasure.toIsFiniteMeasureOnCompacts","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_3\ninst✝² : Group G\ninst✝¹ : TopologicalSpace G\ninst✝ : MeasurableSpace G\nμ : MeasureTheory.Measure G\nself : μ.IsHaarMeasure\n⊢ MeasureTheory.IsFiniteMeasureOnCompacts μ","decl":"/-- A measure on a group is a Haar measure if it is left-invariant, and gives finite mass to\ncompact sets and positive mass to open sets.\n\nTextbooks generally require an additional regularity assumption to ensure nice behavior on\narbitrary locally compact groups. Use `[IsHaarMeasure μ] [Regular μ]` or\n`[IsHaarMeasure μ] [InnerRegular μ]` in these situations. Note that a Haar measure in our\nsense is automatically regular and inner regular on second countable locally compact groups, as\nchecked just below this definition. -/\n@[to_additive existing]\nclass IsHaarMeasure {G : Type*} [Group G] [TopologicalSpace G] [MeasurableSpace G]\n  (μ : Measure G) extends IsFiniteMeasureOnCompacts μ, IsMulLeftInvariant μ, IsOpenPosMeasure μ :\n  Prop\n\n"}
{"name":"MeasureTheory.Measure.IsHaarMeasure.toIsMulLeftInvariant","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_3\ninst✝² : Group G\ninst✝¹ : TopologicalSpace G\ninst✝ : MeasurableSpace G\nμ : MeasureTheory.Measure G\nself : μ.IsHaarMeasure\n⊢ μ.IsMulLeftInvariant","decl":"/-- A measure on a group is a Haar measure if it is left-invariant, and gives finite mass to\ncompact sets and positive mass to open sets.\n\nTextbooks generally require an additional regularity assumption to ensure nice behavior on\narbitrary locally compact groups. Use `[IsHaarMeasure μ] [Regular μ]` or\n`[IsHaarMeasure μ] [InnerRegular μ]` in these situations. Note that a Haar measure in our\nsense is automatically regular and inner regular on second countable locally compact groups, as\nchecked just below this definition. -/\n@[to_additive existing]\nclass IsHaarMeasure {G : Type*} [Group G] [TopologicalSpace G] [MeasurableSpace G]\n  (μ : Measure G) extends IsFiniteMeasureOnCompacts μ, IsMulLeftInvariant μ, IsOpenPosMeasure μ :\n  Prop\n\n"}
{"name":"MeasureTheory.Measure.haar_singleton","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_1\ninst✝⁵ : MeasurableSpace G\ninst✝⁴ : Group G\ninst✝³ : TopologicalSpace G\nμ : MeasureTheory.Measure G\ninst✝² : μ.IsHaarMeasure\ninst✝¹ : TopologicalGroup G\ninst✝ : BorelSpace G\ng : G\n⊢ Eq (μ (Singleton.singleton g)) (μ (Singleton.singleton 1))","decl":"@[to_additive (attr := simp)]\ntheorem haar_singleton [TopologicalGroup G] [BorelSpace G] (g : G) : μ {g} = μ {(1 : G)} := by\n  convert measure_preimage_mul μ g⁻¹ _\n  simp only [mul_one, preimage_mul_left_singleton, inv_inv]\n\n"}
{"name":"MeasureTheory.Measure.addHaar_singleton","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_1\ninst✝⁵ : MeasurableSpace G\ninst✝⁴ : AddGroup G\ninst✝³ : TopologicalSpace G\nμ : MeasureTheory.Measure G\ninst✝² : μ.IsAddHaarMeasure\ninst✝¹ : TopologicalAddGroup G\ninst✝ : BorelSpace G\ng : G\n⊢ Eq (μ (Singleton.singleton g)) (μ (Singleton.singleton 0))","decl":"@[to_additive (attr := simp)]\ntheorem haar_singleton [TopologicalGroup G] [BorelSpace G] (g : G) : μ {g} = μ {(1 : G)} := by\n  convert measure_preimage_mul μ g⁻¹ _\n  simp only [mul_one, preimage_mul_left_singleton, inv_inv]\n\n"}
{"name":"MeasureTheory.Measure.IsAddHaarMeasure.smul","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_1\ninst✝³ : MeasurableSpace G\ninst✝² : AddGroup G\ninst✝¹ : TopologicalSpace G\nμ : MeasureTheory.Measure G\ninst✝ : μ.IsAddHaarMeasure\nc : ENNReal\ncpos : Ne c 0\nctop : Ne c Top.top\n⊢ (HSMul.hSMul c μ).IsAddHaarMeasure","decl":"@[to_additive IsAddHaarMeasure.smul]\ntheorem IsHaarMeasure.smul {c : ℝ≥0∞} (cpos : c ≠ 0) (ctop : c ≠ ∞) : IsHaarMeasure (c • μ) :=\n  { lt_top_of_isCompact := fun _K hK => ENNReal.mul_lt_top ctop.lt_top hK.measure_lt_top\n    toIsOpenPosMeasure := isOpenPosMeasure_smul μ cpos }\n\n"}
{"name":"MeasureTheory.Measure.IsHaarMeasure.smul","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_1\ninst✝³ : MeasurableSpace G\ninst✝² : Group G\ninst✝¹ : TopologicalSpace G\nμ : MeasureTheory.Measure G\ninst✝ : μ.IsHaarMeasure\nc : ENNReal\ncpos : Ne c 0\nctop : Ne c Top.top\n⊢ (HSMul.hSMul c μ).IsHaarMeasure","decl":"@[to_additive IsAddHaarMeasure.smul]\ntheorem IsHaarMeasure.smul {c : ℝ≥0∞} (cpos : c ≠ 0) (ctop : c ≠ ∞) : IsHaarMeasure (c • μ) :=\n  { lt_top_of_isCompact := fun _K hK => ENNReal.mul_lt_top ctop.lt_top hK.measure_lt_top\n    toIsOpenPosMeasure := isOpenPosMeasure_smul μ cpos }\n\n"}
{"name":"MeasureTheory.Measure.isHaarMeasure_of_isCompact_nonempty_interior","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_1\ninst✝⁵ : MeasurableSpace G\ninst✝⁴ : Group G\ninst✝³ : TopologicalSpace G\ninst✝² : TopologicalGroup G\ninst✝¹ : BorelSpace G\nμ : MeasureTheory.Measure G\ninst✝ : μ.IsMulLeftInvariant\nK : Set G\nhK : IsCompact K\nh'K : (interior K).Nonempty\nh : Ne (μ K) 0\nh' : Ne (μ K) Top.top\n⊢ μ.IsHaarMeasure","decl":"/-- If a left-invariant measure gives positive mass to some compact set with nonempty interior, then\nit is a Haar measure. -/\n@[to_additive\n\"If a left-invariant measure gives positive mass to some compact set with nonempty interior, then\nit is an additive Haar measure.\"]\ntheorem isHaarMeasure_of_isCompact_nonempty_interior [TopologicalGroup G] [BorelSpace G]\n    (μ : Measure G) [IsMulLeftInvariant μ] (K : Set G) (hK : IsCompact K)\n    (h'K : (interior K).Nonempty) (h : μ K ≠ 0) (h' : μ K ≠ ∞) : IsHaarMeasure μ :=\n  { lt_top_of_isCompact := fun _L hL =>\n      measure_lt_top_of_isCompact_of_isMulLeftInvariant' h'K h' hL\n    toIsOpenPosMeasure := isOpenPosMeasure_of_mulLeftInvariant_of_compact K hK h }\n\n"}
{"name":"MeasureTheory.Measure.isAddHaarMeasure_of_isCompact_nonempty_interior","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_1\ninst✝⁵ : MeasurableSpace G\ninst✝⁴ : AddGroup G\ninst✝³ : TopologicalSpace G\ninst✝² : TopologicalAddGroup G\ninst✝¹ : BorelSpace G\nμ : MeasureTheory.Measure G\ninst✝ : μ.IsAddLeftInvariant\nK : Set G\nhK : IsCompact K\nh'K : (interior K).Nonempty\nh : Ne (μ K) 0\nh' : Ne (μ K) Top.top\n⊢ μ.IsAddHaarMeasure","decl":"/-- If a left-invariant measure gives positive mass to some compact set with nonempty interior, then\nit is a Haar measure. -/\n@[to_additive\n\"If a left-invariant measure gives positive mass to some compact set with nonempty interior, then\nit is an additive Haar measure.\"]\ntheorem isHaarMeasure_of_isCompact_nonempty_interior [TopologicalGroup G] [BorelSpace G]\n    (μ : Measure G) [IsMulLeftInvariant μ] (K : Set G) (hK : IsCompact K)\n    (h'K : (interior K).Nonempty) (h : μ K ≠ 0) (h' : μ K ≠ ∞) : IsHaarMeasure μ :=\n  { lt_top_of_isCompact := fun _L hL =>\n      measure_lt_top_of_isCompact_of_isMulLeftInvariant' h'K h' hL\n    toIsOpenPosMeasure := isOpenPosMeasure_of_mulLeftInvariant_of_compact K hK h }\n\n"}
{"name":"MeasureTheory.Measure.isHaarMeasure_map","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_1\ninst✝¹⁰ : MeasurableSpace G\ninst✝⁹ : Group G\ninst✝⁸ : TopologicalSpace G\nμ : MeasureTheory.Measure G\ninst✝⁷ : μ.IsHaarMeasure\ninst✝⁶ : BorelSpace G\ninst✝⁵ : TopologicalGroup G\nH : Type u_3\ninst✝⁴ : Group H\ninst✝³ : TopologicalSpace H\ninst✝² : MeasurableSpace H\ninst✝¹ : BorelSpace H\ninst✝ : TopologicalGroup H\nf : MonoidHom G H\nhf : Continuous ⇑f\nh_surj : Function.Surjective ⇑f\nh_prop : Filter.Tendsto (⇑f) (Filter.cocompact G) (Filter.cocompact H)\n⊢ (MeasureTheory.Measure.map (⇑f) μ).IsHaarMeasure","decl":"/-- The image of a Haar measure under a continuous surjective proper group homomorphism is again\na Haar measure. See also `MulEquiv.isHaarMeasure_map` and `ContinuousMulEquiv.isHaarMeasure_map`. -/\n@[to_additive\n\"The image of an additive Haar measure under a continuous surjective proper additive group\nhomomorphism is again an additive Haar measure. See also `AddEquiv.isAddHaarMeasure_map`,\n`ContinuousAddEquiv.isAddHaarMeasure_map` and `ContinuousLinearEquiv.isAddHaarMeasure_map`.\"]\ntheorem isHaarMeasure_map [BorelSpace G] [TopologicalGroup G] {H : Type*} [Group H]\n    [TopologicalSpace H] [MeasurableSpace H] [BorelSpace H] [TopologicalGroup H]\n    (f : G →* H) (hf : Continuous f) (h_surj : Surjective f)\n    (h_prop : Tendsto f (cocompact G) (cocompact H)) : IsHaarMeasure (Measure.map f μ) :=\n  { toIsMulLeftInvariant := isMulLeftInvariant_map f.toMulHom hf.measurable h_surj\n    lt_top_of_isCompact := by\n      intro K hK\n      rw [← hK.measure_closure, map_apply hf.measurable isClosed_closure.measurableSet]\n      set g : CocompactMap G H := ⟨⟨f, hf⟩, h_prop⟩\n      exact IsCompact.measure_lt_top (g.isCompact_preimage_of_isClosed hK.closure isClosed_closure)\n    toIsOpenPosMeasure := hf.isOpenPosMeasure_map h_surj }\n\n"}
{"name":"MeasureTheory.Measure.isAddHaarMeasure_map","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_1\ninst✝¹⁰ : MeasurableSpace G\ninst✝⁹ : AddGroup G\ninst✝⁸ : TopologicalSpace G\nμ : MeasureTheory.Measure G\ninst✝⁷ : μ.IsAddHaarMeasure\ninst✝⁶ : BorelSpace G\ninst✝⁵ : TopologicalAddGroup G\nH : Type u_3\ninst✝⁴ : AddGroup H\ninst✝³ : TopologicalSpace H\ninst✝² : MeasurableSpace H\ninst✝¹ : BorelSpace H\ninst✝ : TopologicalAddGroup H\nf : AddMonoidHom G H\nhf : Continuous ⇑f\nh_surj : Function.Surjective ⇑f\nh_prop : Filter.Tendsto (⇑f) (Filter.cocompact G) (Filter.cocompact H)\n⊢ (MeasureTheory.Measure.map (⇑f) μ).IsAddHaarMeasure","decl":"/-- The image of a Haar measure under a continuous surjective proper group homomorphism is again\na Haar measure. See also `MulEquiv.isHaarMeasure_map` and `ContinuousMulEquiv.isHaarMeasure_map`. -/\n@[to_additive\n\"The image of an additive Haar measure under a continuous surjective proper additive group\nhomomorphism is again an additive Haar measure. See also `AddEquiv.isAddHaarMeasure_map`,\n`ContinuousAddEquiv.isAddHaarMeasure_map` and `ContinuousLinearEquiv.isAddHaarMeasure_map`.\"]\ntheorem isHaarMeasure_map [BorelSpace G] [TopologicalGroup G] {H : Type*} [Group H]\n    [TopologicalSpace H] [MeasurableSpace H] [BorelSpace H] [TopologicalGroup H]\n    (f : G →* H) (hf : Continuous f) (h_surj : Surjective f)\n    (h_prop : Tendsto f (cocompact G) (cocompact H)) : IsHaarMeasure (Measure.map f μ) :=\n  { toIsMulLeftInvariant := isMulLeftInvariant_map f.toMulHom hf.measurable h_surj\n    lt_top_of_isCompact := by\n      intro K hK\n      rw [← hK.measure_closure, map_apply hf.measurable isClosed_closure.measurableSet]\n      set g : CocompactMap G H := ⟨⟨f, hf⟩, h_prop⟩\n      exact IsCompact.measure_lt_top (g.isCompact_preimage_of_isClosed hK.closure isClosed_closure)\n    toIsOpenPosMeasure := hf.isOpenPosMeasure_map h_surj }\n\n"}
{"name":"MeasureTheory.Measure.isHaarMeasure_map_of_isFiniteMeasure","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_1\ninst✝¹¹ : MeasurableSpace G\ninst✝¹⁰ : Group G\ninst✝⁹ : TopologicalSpace G\nμ : MeasureTheory.Measure G\ninst✝⁸ : μ.IsHaarMeasure\ninst✝⁷ : BorelSpace G\ninst✝⁶ : TopologicalGroup G\nH : Type u_3\ninst✝⁵ : Group H\ninst✝⁴ : TopologicalSpace H\ninst✝³ : MeasurableSpace H\ninst✝² : BorelSpace H\ninst✝¹ : TopologicalGroup H\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nf : MonoidHom G H\nhf : Continuous ⇑f\nh_surj : Function.Surjective ⇑f\n⊢ (MeasureTheory.Measure.map (⇑f) μ).IsHaarMeasure","decl":"/-- The image of a finite Haar measure under a continuous surjective group homomorphism is again\na Haar measure. See also `isHaarMeasure_map`. -/\n@[to_additive\n\"The image of a finite additive Haar measure under a continuous surjective additive group\nhomomorphism is again an additive Haar measure. See also `isAddHaarMeasure_map`.\"]\ntheorem isHaarMeasure_map_of_isFiniteMeasure\n    [BorelSpace G] [TopologicalGroup G] {H : Type*} [Group H]\n    [TopologicalSpace H] [MeasurableSpace H] [BorelSpace H] [TopologicalGroup H] [IsFiniteMeasure μ]\n    (f : G →* H) (hf : Continuous f) (h_surj : Surjective f) :\n    IsHaarMeasure (Measure.map f μ) where\n  toIsMulLeftInvariant := isMulLeftInvariant_map f.toMulHom hf.measurable h_surj\n  toIsOpenPosMeasure := hf.isOpenPosMeasure_map h_surj\n\n"}
{"name":"MeasureTheory.Measure.isAddHaarMeasure_map_of_isFiniteMeasure","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_1\ninst✝¹¹ : MeasurableSpace G\ninst✝¹⁰ : AddGroup G\ninst✝⁹ : TopologicalSpace G\nμ : MeasureTheory.Measure G\ninst✝⁸ : μ.IsAddHaarMeasure\ninst✝⁷ : BorelSpace G\ninst✝⁶ : TopologicalAddGroup G\nH : Type u_3\ninst✝⁵ : AddGroup H\ninst✝⁴ : TopologicalSpace H\ninst✝³ : MeasurableSpace H\ninst✝² : BorelSpace H\ninst✝¹ : TopologicalAddGroup H\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nf : AddMonoidHom G H\nhf : Continuous ⇑f\nh_surj : Function.Surjective ⇑f\n⊢ (MeasureTheory.Measure.map (⇑f) μ).IsAddHaarMeasure","decl":"/-- The image of a finite Haar measure under a continuous surjective group homomorphism is again\na Haar measure. See also `isHaarMeasure_map`. -/\n@[to_additive\n\"The image of a finite additive Haar measure under a continuous surjective additive group\nhomomorphism is again an additive Haar measure. See also `isAddHaarMeasure_map`.\"]\ntheorem isHaarMeasure_map_of_isFiniteMeasure\n    [BorelSpace G] [TopologicalGroup G] {H : Type*} [Group H]\n    [TopologicalSpace H] [MeasurableSpace H] [BorelSpace H] [TopologicalGroup H] [IsFiniteMeasure μ]\n    (f : G →* H) (hf : Continuous f) (h_surj : Surjective f) :\n    IsHaarMeasure (Measure.map f μ) where\n  toIsMulLeftInvariant := isMulLeftInvariant_map f.toMulHom hf.measurable h_surj\n  toIsOpenPosMeasure := hf.isOpenPosMeasure_map h_surj\n\n"}
{"name":"MeasureTheory.Measure.isHaarMeasure_map_smul","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_1\ninst✝¹¹ : MeasurableSpace G\ninst✝¹⁰ : Group G\ninst✝⁹ : TopologicalSpace G\nμ : MeasureTheory.Measure G\ninst✝⁸ : μ.IsHaarMeasure\nα : Type u_3\ninst✝⁷ : BorelSpace G\ninst✝⁶ : TopologicalGroup G\ninst✝⁵ : Group α\ninst✝⁴ : MulAction α G\ninst✝³ : SMulCommClass α G G\ninst✝² : MeasurableSpace α\ninst✝¹ : MeasurableSMul α G\ninst✝ : ContinuousConstSMul α G\na : α\n⊢ (MeasureTheory.Measure.map (fun x => HSMul.hSMul a x) μ).IsHaarMeasure","decl":"/-- The image of a Haar measure under map of a left action is again a Haar measure. -/\n@[to_additive\n   \"The image of a Haar measure under map of a left additive action is again a Haar measure\"]\ninstance isHaarMeasure_map_smul {α} [BorelSpace G] [TopologicalGroup G]\n    [Group α] [MulAction α G] [SMulCommClass α G G] [MeasurableSpace α] [MeasurableSMul α G]\n    [ContinuousConstSMul α G] (a : α) : IsHaarMeasure (Measure.map (a • · : G → G) μ) where\n  toIsMulLeftInvariant := isMulLeftInvariant_map_smul _\n  lt_top_of_isCompact K hK := by\n    let F := (Homeomorph.smul a (α := G)).toMeasurableEquiv\n    change map F μ K < ∞\n    rw [F.map_apply K]\n    exact IsCompact.measure_lt_top <| (Homeomorph.isCompact_preimage (Homeomorph.smul a)).2 hK\n  toIsOpenPosMeasure :=\n    (continuous_const_smul a).isOpenPosMeasure_map (MulAction.surjective a)\n\n"}
{"name":"MeasureTheory.Measure.isAddHaarMeasure_map_vadd","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_1\ninst✝¹¹ : MeasurableSpace G\ninst✝¹⁰ : AddGroup G\ninst✝⁹ : TopologicalSpace G\nμ : MeasureTheory.Measure G\ninst✝⁸ : μ.IsAddHaarMeasure\nα : Type u_3\ninst✝⁷ : BorelSpace G\ninst✝⁶ : TopologicalAddGroup G\ninst✝⁵ : AddGroup α\ninst✝⁴ : AddAction α G\ninst✝³ : VAddCommClass α G G\ninst✝² : MeasurableSpace α\ninst✝¹ : MeasurableVAdd α G\ninst✝ : ContinuousConstVAdd α G\na : α\n⊢ (MeasureTheory.Measure.map (fun x => HVAdd.hVAdd a x) μ).IsAddHaarMeasure","decl":"/-- The image of a Haar measure under map of a left action is again a Haar measure. -/\n@[to_additive\n   \"The image of a Haar measure under map of a left additive action is again a Haar measure\"]\ninstance isHaarMeasure_map_smul {α} [BorelSpace G] [TopologicalGroup G]\n    [Group α] [MulAction α G] [SMulCommClass α G G] [MeasurableSpace α] [MeasurableSMul α G]\n    [ContinuousConstSMul α G] (a : α) : IsHaarMeasure (Measure.map (a • · : G → G) μ) where\n  toIsMulLeftInvariant := isMulLeftInvariant_map_smul _\n  lt_top_of_isCompact K hK := by\n    let F := (Homeomorph.smul a (α := G)).toMeasurableEquiv\n    change map F μ K < ∞\n    rw [F.map_apply K]\n    exact IsCompact.measure_lt_top <| (Homeomorph.isCompact_preimage (Homeomorph.smul a)).2 hK\n  toIsOpenPosMeasure :=\n    (continuous_const_smul a).isOpenPosMeasure_map (MulAction.surjective a)\n\n"}
{"name":"MeasureTheory.Measure.isHaarMeasure_map_mul_right","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_1\ninst✝⁵ : MeasurableSpace G\ninst✝⁴ : Group G\ninst✝³ : TopologicalSpace G\nμ : MeasureTheory.Measure G\ninst✝² : μ.IsHaarMeasure\ninst✝¹ : BorelSpace G\ninst✝ : TopologicalGroup G\ng : G\n⊢ (MeasureTheory.Measure.map (fun x => HMul.hMul x g) μ).IsHaarMeasure","decl":"/-- The image of a Haar measure under right multiplication is again a Haar measure. -/\n@[to_additive isHaarMeasure_map_add_right\n  \"The image of a Haar measure under right addition is again a Haar measure.\"]\ninstance isHaarMeasure_map_mul_right [BorelSpace G] [TopologicalGroup G] (g : G) :\n    IsHaarMeasure (Measure.map (· * g) μ) :=\n  isHaarMeasure_map_smul μ (MulOpposite.op g)\n\n"}
{"name":"MeasureTheory.Measure.isHaarMeasure_map_add_right","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_1\ninst✝⁵ : MeasurableSpace G\ninst✝⁴ : AddGroup G\ninst✝³ : TopologicalSpace G\nμ : MeasureTheory.Measure G\ninst✝² : μ.IsAddHaarMeasure\ninst✝¹ : BorelSpace G\ninst✝ : TopologicalAddGroup G\ng : G\n⊢ (MeasureTheory.Measure.map (fun x => HAdd.hAdd x g) μ).IsAddHaarMeasure","decl":"/-- The image of a Haar measure under right multiplication is again a Haar measure. -/\n@[to_additive isHaarMeasure_map_add_right\n  \"The image of a Haar measure under right addition is again a Haar measure.\"]\ninstance isHaarMeasure_map_mul_right [BorelSpace G] [TopologicalGroup G] (g : G) :\n    IsHaarMeasure (Measure.map (· * g) μ) :=\n  isHaarMeasure_map_smul μ (MulOpposite.op g)\n\n"}
{"name":"MulEquiv.isHaarMeasure_map","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_1\ninst✝¹⁰ : MeasurableSpace G\ninst✝⁹ : Group G\ninst✝⁸ : TopologicalSpace G\nμ : MeasureTheory.Measure G\ninst✝⁷ : μ.IsHaarMeasure\ninst✝⁶ : BorelSpace G\ninst✝⁵ : TopologicalGroup G\nH : Type u_3\ninst✝⁴ : Group H\ninst✝³ : TopologicalSpace H\ninst✝² : MeasurableSpace H\ninst✝¹ : BorelSpace H\ninst✝ : TopologicalGroup H\ne : MulEquiv G H\nhe : Continuous ⇑e\nhesymm : Continuous ⇑e.symm\n⊢ (MeasureTheory.Measure.map (⇑e) μ).IsHaarMeasure","decl":"/-- A convenience wrapper for `MeasureTheory.Measure.isHaarMeasure_map`. -/\n@[to_additive \"A convenience wrapper for `MeasureTheory.Measure.isAddHaarMeasure_map`.\"]\nnonrec theorem _root_.MulEquiv.isHaarMeasure_map [BorelSpace G] [TopologicalGroup G] {H : Type*}\n    [Group H] [TopologicalSpace H] [MeasurableSpace H] [BorelSpace H]\n    [TopologicalGroup H] (e : G ≃* H) (he : Continuous e) (hesymm : Continuous e.symm) :\n    IsHaarMeasure (Measure.map e μ) :=\n  let f : G ≃ₜ H := .mk e\n  #adaptation_note /-- https://github.com/leanprover/lean4/pull/6024\n  we needed to write `e.toMonoidHom` instead of just `e`, to avoid unification issues.\n  -/\n  isHaarMeasure_map μ e.toMonoidHom he e.surjective f.isClosedEmbedding.tendsto_cocompact\n\n"}
{"name":"AddEquiv.isAddHaarMeasure_map","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_1\ninst✝¹⁰ : MeasurableSpace G\ninst✝⁹ : AddGroup G\ninst✝⁸ : TopologicalSpace G\nμ : MeasureTheory.Measure G\ninst✝⁷ : μ.IsAddHaarMeasure\ninst✝⁶ : BorelSpace G\ninst✝⁵ : TopologicalAddGroup G\nH : Type u_3\ninst✝⁴ : AddGroup H\ninst✝³ : TopologicalSpace H\ninst✝² : MeasurableSpace H\ninst✝¹ : BorelSpace H\ninst✝ : TopologicalAddGroup H\ne : AddEquiv G H\nhe : Continuous ⇑e\nhesymm : Continuous ⇑e.symm\n⊢ (MeasureTheory.Measure.map (⇑e) μ).IsAddHaarMeasure","decl":"/-- A convenience wrapper for `MeasureTheory.Measure.isHaarMeasure_map`. -/\n@[to_additive \"A convenience wrapper for `MeasureTheory.Measure.isAddHaarMeasure_map`.\"]\nnonrec theorem _root_.MulEquiv.isHaarMeasure_map [BorelSpace G] [TopologicalGroup G] {H : Type*}\n    [Group H] [TopologicalSpace H] [MeasurableSpace H] [BorelSpace H]\n    [TopologicalGroup H] (e : G ≃* H) (he : Continuous e) (hesymm : Continuous e.symm) :\n    IsHaarMeasure (Measure.map e μ) :=\n  let f : G ≃ₜ H := .mk e\n  #adaptation_note /-- https://github.com/leanprover/lean4/pull/6024\n  we needed to write `e.toMonoidHom` instead of just `e`, to avoid unification issues.\n  -/\n  isHaarMeasure_map μ e.toMonoidHom he e.surjective f.isClosedEmbedding.tendsto_cocompact\n\n"}
{"name":"ContinuousMulEquiv.isHaarMeasure_map","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_1\ninst✝¹⁰ : MeasurableSpace G\ninst✝⁹ : Group G\ninst✝⁸ : TopologicalSpace G\nμ : MeasureTheory.Measure G\ninst✝⁷ : μ.IsHaarMeasure\ninst✝⁶ : BorelSpace G\ninst✝⁵ : TopologicalGroup G\nH : Type u_3\ninst✝⁴ : Group H\ninst✝³ : TopologicalSpace H\ninst✝² : MeasurableSpace H\ninst✝¹ : BorelSpace H\ninst✝ : TopologicalGroup H\ne : ContinuousMulEquiv G H\n⊢ (MeasureTheory.Measure.map (⇑e) μ).IsHaarMeasure","decl":"/--\nA convenience wrapper for MeasureTheory.Measure.isHaarMeasure_map.\n-/\n@[to_additive \"A convenience wrapper for MeasureTheory.Measure.isAddHaarMeasure_map.\n\"]\ninstance _root_.ContinuousMulEquiv.isHaarMeasure_map [BorelSpace G] [TopologicalGroup G] {H : Type*}\n    [Group H] [TopologicalSpace H] [MeasurableSpace H] [BorelSpace H]\n    [TopologicalGroup H] (e : G ≃ₜ* H) : (μ.map e).IsHaarMeasure :=\n  e.toMulEquiv.isHaarMeasure_map μ e.continuous e.symm.continuous\n\n"}
{"name":"ContinuousAddEquiv.isAddHaarMeasure_map","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_1\ninst✝¹⁰ : MeasurableSpace G\ninst✝⁹ : AddGroup G\ninst✝⁸ : TopologicalSpace G\nμ : MeasureTheory.Measure G\ninst✝⁷ : μ.IsAddHaarMeasure\ninst✝⁶ : BorelSpace G\ninst✝⁵ : TopologicalAddGroup G\nH : Type u_3\ninst✝⁴ : AddGroup H\ninst✝³ : TopologicalSpace H\ninst✝² : MeasurableSpace H\ninst✝¹ : BorelSpace H\ninst✝ : TopologicalAddGroup H\ne : ContinuousAddEquiv G H\n⊢ (MeasureTheory.Measure.map (⇑e) μ).IsAddHaarMeasure","decl":"/--\nA convenience wrapper for MeasureTheory.Measure.isHaarMeasure_map.\n-/\n@[to_additive \"A convenience wrapper for MeasureTheory.Measure.isAddHaarMeasure_map.\n\"]\ninstance _root_.ContinuousMulEquiv.isHaarMeasure_map [BorelSpace G] [TopologicalGroup G] {H : Type*}\n    [Group H] [TopologicalSpace H] [MeasurableSpace H] [BorelSpace H]\n    [TopologicalGroup H] (e : G ≃ₜ* H) : (μ.map e).IsHaarMeasure :=\n  e.toMulEquiv.isHaarMeasure_map μ e.continuous e.symm.continuous\n\n"}
{"name":"ContinuousLinearEquiv.isAddHaarMeasure_map","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"E : Type u_3\nF : Type u_4\nR : Type u_5\nS : Type u_6\ninst✝¹⁶ : Semiring R\ninst✝¹⁵ : Semiring S\ninst✝¹⁴ : AddCommGroup E\ninst✝¹³ : Module R E\ninst✝¹² : AddCommGroup F\ninst✝¹¹ : Module S F\ninst✝¹⁰ : TopologicalSpace E\ninst✝⁹ : TopologicalAddGroup E\ninst✝⁸ : TopologicalSpace F\ninst✝⁷ : TopologicalAddGroup F\nσ : RingHom R S\nσ' : RingHom S R\ninst✝⁶ : RingHomInvPair σ σ'\ninst✝⁵ : RingHomInvPair σ' σ\ninst✝⁴ : MeasurableSpace E\ninst✝³ : BorelSpace E\ninst✝² : MeasurableSpace F\ninst✝¹ : BorelSpace F\nL : ContinuousLinearEquiv σ E F\nμ : MeasureTheory.Measure E\ninst✝ : μ.IsAddHaarMeasure\n⊢ (MeasureTheory.Measure.map (⇑L) μ).IsAddHaarMeasure","decl":"/-- A convenience wrapper for MeasureTheory.Measure.isAddHaarMeasure_map`. -/\ninstance _root_.ContinuousLinearEquiv.isAddHaarMeasure_map\n    {E F R S : Type*} [Semiring R] [Semiring S]\n    [AddCommGroup E] [Module R E] [AddCommGroup F] [Module S F]\n    [TopologicalSpace E] [TopologicalAddGroup E] [TopologicalSpace F]\n    [TopologicalAddGroup F]\n    {σ : R →+* S} {σ' : S →+* R} [RingHomInvPair σ σ'] [RingHomInvPair σ' σ]\n    [MeasurableSpace E] [BorelSpace E] [MeasurableSpace F] [BorelSpace F]\n    (L : E ≃SL[σ] F) (μ : Measure E) [IsAddHaarMeasure μ] :\n    IsAddHaarMeasure (μ.map L) :=\n  AddEquiv.isAddHaarMeasure_map _ (L : E ≃+ F) L.continuous L.symm.continuous\n\n"}
{"name":"MeasureTheory.Measure.IsHaarMeasure.sigmaFinite","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_1\ninst✝⁴ : MeasurableSpace G\ninst✝³ : Group G\ninst✝² : TopologicalSpace G\nμ : MeasureTheory.Measure G\ninst✝¹ : μ.IsHaarMeasure\ninst✝ : SigmaCompactSpace G\n⊢ MeasureTheory.SigmaFinite μ","decl":"/-- A Haar measure on a σ-compact space is σ-finite.\n\nSee Note [lower instance priority] -/\n@[to_additive\n\"A Haar measure on a σ-compact space is σ-finite.\n\nSee Note [lower instance priority]\"]\ninstance (priority := 100) IsHaarMeasure.sigmaFinite [SigmaCompactSpace G] : SigmaFinite μ :=\n  ⟨⟨{   set := compactCovering G\n        set_mem := fun _ => mem_univ _\n        finite := fun n => IsCompact.measure_lt_top <| isCompact_compactCovering G n\n        spanning := iUnion_compactCovering G }⟩⟩\n\n"}
{"name":"MeasureTheory.Measure.IsAddHaarMeasure.sigmaFinite","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_1\ninst✝⁴ : MeasurableSpace G\ninst✝³ : AddGroup G\ninst✝² : TopologicalSpace G\nμ : MeasureTheory.Measure G\ninst✝¹ : μ.IsAddHaarMeasure\ninst✝ : SigmaCompactSpace G\n⊢ MeasureTheory.SigmaFinite μ","decl":"/-- A Haar measure on a σ-compact space is σ-finite.\n\nSee Note [lower instance priority] -/\n@[to_additive\n\"A Haar measure on a σ-compact space is σ-finite.\n\nSee Note [lower instance priority]\"]\ninstance (priority := 100) IsHaarMeasure.sigmaFinite [SigmaCompactSpace G] : SigmaFinite μ :=\n  ⟨⟨{   set := compactCovering G\n        set_mem := fun _ => mem_univ _\n        finite := fun n => IsCompact.measure_lt_top <| isCompact_compactCovering G n\n        spanning := iUnion_compactCovering G }⟩⟩\n\n"}
{"name":"MeasureTheory.Measure.prod.instIsHaarMeasure","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_3\ninst✝⁹ : Group G\ninst✝⁸ : TopologicalSpace G\nx✝¹ : MeasurableSpace G\nH : Type u_4\ninst✝⁷ : Group H\ninst✝⁶ : TopologicalSpace H\nx✝ : MeasurableSpace H\nμ : MeasureTheory.Measure G\nν : MeasureTheory.Measure H\ninst✝⁵ : μ.IsHaarMeasure\ninst✝⁴ : ν.IsHaarMeasure\ninst✝³ : MeasureTheory.SFinite μ\ninst✝² : MeasureTheory.SFinite ν\ninst✝¹ : MeasurableMul G\ninst✝ : MeasurableMul H\n⊢ (μ.prod ν).IsHaarMeasure","decl":"@[to_additive]\ninstance prod.instIsHaarMeasure {G : Type*} [Group G] [TopologicalSpace G] {_ : MeasurableSpace G}\n    {H : Type*} [Group H] [TopologicalSpace H] {_ : MeasurableSpace H} (μ : Measure G)\n    (ν : Measure H) [IsHaarMeasure μ] [IsHaarMeasure ν] [SFinite μ] [SFinite ν]\n    [MeasurableMul G] [MeasurableMul H] : IsHaarMeasure (μ.prod ν) where\n\n"}
{"name":"MeasureTheory.Measure.prod.instIsAddHaarMeasure","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_3\ninst✝⁹ : AddGroup G\ninst✝⁸ : TopologicalSpace G\nx✝¹ : MeasurableSpace G\nH : Type u_4\ninst✝⁷ : AddGroup H\ninst✝⁶ : TopologicalSpace H\nx✝ : MeasurableSpace H\nμ : MeasureTheory.Measure G\nν : MeasureTheory.Measure H\ninst✝⁵ : μ.IsAddHaarMeasure\ninst✝⁴ : ν.IsAddHaarMeasure\ninst✝³ : MeasureTheory.SFinite μ\ninst✝² : MeasureTheory.SFinite ν\ninst✝¹ : MeasurableAdd G\ninst✝ : MeasurableAdd H\n⊢ (μ.prod ν).IsAddHaarMeasure","decl":"@[to_additive]\ninstance prod.instIsHaarMeasure {G : Type*} [Group G] [TopologicalSpace G] {_ : MeasurableSpace G}\n    {H : Type*} [Group H] [TopologicalSpace H] {_ : MeasurableSpace H} (μ : Measure G)\n    (ν : Measure H) [IsHaarMeasure μ] [IsHaarMeasure ν] [SFinite μ] [SFinite ν]\n    [MeasurableMul G] [MeasurableMul H] : IsHaarMeasure (μ.prod ν) where\n\n"}
{"name":"MeasureTheory.Measure.IsHaarMeasure.noAtoms","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_1\ninst✝⁸ : MeasurableSpace G\ninst✝⁷ : Group G\ninst✝⁶ : TopologicalSpace G\ninst✝⁵ : TopologicalGroup G\ninst✝⁴ : BorelSpace G\ninst✝³ : T1Space G\ninst✝² : WeaklyLocallyCompactSpace G\ninst✝¹ : (nhdsWithin 1 (HasCompl.compl (Singleton.singleton 1))).NeBot\nμ : MeasureTheory.Measure G\ninst✝ : μ.IsHaarMeasure\n⊢ MeasureTheory.NoAtoms μ","decl":"/-- If the neutral element of a group is not isolated, then a Haar measure on this group has\nno atoms.\n\nThe additive version of this instance applies in particular to show that an additive Haar\nmeasure on a nontrivial finite-dimensional real vector space has no atom. -/\n@[to_additive\n\"If the zero element of an additive group is not isolated, then an additive Haar measure on this\ngroup has no atoms.\n\nThis applies in particular to show that an additive Haar measure on a nontrivial\nfinite-dimensional real vector space has no atom.\"]\ninstance (priority := 100) IsHaarMeasure.noAtoms [TopologicalGroup G] [BorelSpace G] [T1Space G]\n    [WeaklyLocallyCompactSpace G] [(𝓝[≠] (1 : G)).NeBot] (μ : Measure G) [μ.IsHaarMeasure] :\n    NoAtoms μ := by\n  cases eq_or_ne (μ 1) 0 with\n  | inl h => constructor; simpa\n  | inr h =>\n    obtain ⟨K, K_compact, K_nhds⟩ : ∃ K : Set G, IsCompact K ∧ K ∈ 𝓝 1 := exists_compact_mem_nhds 1\n    have K_inf : Set.Infinite K := infinite_of_mem_nhds (1 : G) K_nhds\n    exact absurd (K_inf.meas_eq_top ⟨_, h, fun x _ ↦ (haar_singleton _ _).ge⟩)\n      K_compact.measure_lt_top.ne\n\n"}
{"name":"MeasureTheory.Measure.IsAddHaarMeasure.noAtoms","module":"Mathlib.MeasureTheory.Group.Measure","initialProofState":"G : Type u_1\ninst✝⁸ : MeasurableSpace G\ninst✝⁷ : AddGroup G\ninst✝⁶ : TopologicalSpace G\ninst✝⁵ : TopologicalAddGroup G\ninst✝⁴ : BorelSpace G\ninst✝³ : T1Space G\ninst✝² : WeaklyLocallyCompactSpace G\ninst✝¹ : (nhdsWithin 0 (HasCompl.compl (Singleton.singleton 0))).NeBot\nμ : MeasureTheory.Measure G\ninst✝ : μ.IsAddHaarMeasure\n⊢ MeasureTheory.NoAtoms μ","decl":"/-- If the neutral element of a group is not isolated, then a Haar measure on this group has\nno atoms.\n\nThe additive version of this instance applies in particular to show that an additive Haar\nmeasure on a nontrivial finite-dimensional real vector space has no atom. -/\n@[to_additive\n\"If the zero element of an additive group is not isolated, then an additive Haar measure on this\ngroup has no atoms.\n\nThis applies in particular to show that an additive Haar measure on a nontrivial\nfinite-dimensional real vector space has no atom.\"]\ninstance (priority := 100) IsHaarMeasure.noAtoms [TopologicalGroup G] [BorelSpace G] [T1Space G]\n    [WeaklyLocallyCompactSpace G] [(𝓝[≠] (1 : G)).NeBot] (μ : Measure G) [μ.IsHaarMeasure] :\n    NoAtoms μ := by\n  cases eq_or_ne (μ 1) 0 with\n  | inl h => constructor; simpa\n  | inr h =>\n    obtain ⟨K, K_compact, K_nhds⟩ : ∃ K : Set G, IsCompact K ∧ K ∈ 𝓝 1 := exists_compact_mem_nhds 1\n    have K_inf : Set.Infinite K := infinite_of_mem_nhds (1 : G) K_nhds\n    exact absurd (K_inf.meas_eq_top ⟨_, h, fun x _ ↦ (haar_singleton _ _).ge⟩)\n      K_compact.measure_lt_top.ne\n\n"}
