{"name":"ContDiffBump.convolution_eq_right","module":"Mathlib.Analysis.Calculus.BumpFunction.Convolution","initialProofState":"G : Type uG\nE' : Type uE'\ninstâœâ¶ : NormedAddCommGroup E'\ng : G â†’ E'\ninstâœâµ : MeasurableSpace G\nÎ¼ : MeasureTheory.Measure G\ninstâœâ´ : NormedSpace Real E'\ninstâœÂ³ : NormedAddCommGroup G\ninstâœÂ² : NormedSpace Real G\ninstâœÂ¹ : HasContDiffBump G\ninstâœ : CompleteSpace E'\nÏ† : ContDiffBump 0\nxâ‚€ : G\nhg : âˆ€ (x : G), Membership.mem (Metric.ball xâ‚€ Ï†.rOut) x â†’ Eq (g x) (g xâ‚€)\nâŠ¢ Eq (MeasureTheory.convolution (â†‘Ï†) g (ContinuousLinearMap.lsmul Real Real) Î¼ xâ‚€) (HSMul.hSMul (MeasureTheory.integral Î¼ â†‘Ï†) (g xâ‚€))","decl":"/-- If `Ï†` is a bump function, compute `(Ï† â‹† g) xâ‚€`\nif `g` is constant on `Metric.ball xâ‚€ Ï†.rOut`. -/\ntheorem convolution_eq_right {xâ‚€ : G} (hg : âˆ€ x âˆˆ ball xâ‚€ Ï†.rOut, g x = g xâ‚€) :\n    (Ï† â‹†[lsmul â„ â„, Î¼] g : G â†’ E') xâ‚€ = integral Î¼ Ï† â€¢ g xâ‚€ := by\n  simp_rw [convolution_eq_right' _ Ï†.support_eq.subset hg, lsmul_apply, integral_smul_const]\n\n"}
{"name":"ContDiffBump.normed_convolution_eq_right","module":"Mathlib.Analysis.Calculus.BumpFunction.Convolution","initialProofState":"G : Type uG\nE' : Type uE'\ninstâœÂ¹â° : NormedAddCommGroup E'\ng : G â†’ E'\ninstâœâ¹ : MeasurableSpace G\nÎ¼ : MeasureTheory.Measure G\ninstâœâ¸ : NormedSpace Real E'\ninstâœâ· : NormedAddCommGroup G\ninstâœâ¶ : NormedSpace Real G\ninstâœâµ : HasContDiffBump G\ninstâœâ´ : CompleteSpace E'\nÏ† : ContDiffBump 0\ninstâœÂ³ : BorelSpace G\ninstâœÂ² : MeasureTheory.IsLocallyFiniteMeasure Î¼\ninstâœÂ¹ : Î¼.IsOpenPosMeasure\ninstâœ : FiniteDimensional Real G\nxâ‚€ : G\nhg : âˆ€ (x : G), Membership.mem (Metric.ball xâ‚€ Ï†.rOut) x â†’ Eq (g x) (g xâ‚€)\nâŠ¢ Eq (MeasureTheory.convolution (Ï†.normed Î¼) g (ContinuousLinearMap.lsmul Real Real) Î¼ xâ‚€) (g xâ‚€)","decl":"/-- If `Ï†` is a normed bump function, compute `Ï† â‹† g`\nif `g` is constant on `Metric.ball xâ‚€ Ï†.rOut`. -/\ntheorem normed_convolution_eq_right {xâ‚€ : G} (hg : âˆ€ x âˆˆ ball xâ‚€ Ï†.rOut, g x = g xâ‚€) :\n    (Ï†.normed Î¼ â‹†[lsmul â„ â„, Î¼] g : G â†’ E') xâ‚€ = g xâ‚€ := by\n  rw [convolution_eq_right' _ Ï†.support_normed_eq.subset hg]\n  exact integral_normed_smul Ï† Î¼ (g xâ‚€)\n\n"}
{"name":"ContDiffBump.dist_normed_convolution_le","module":"Mathlib.Analysis.Calculus.BumpFunction.Convolution","initialProofState":"G : Type uG\nE' : Type uE'\ninstâœÂ¹Â¹ : NormedAddCommGroup E'\ng : G â†’ E'\ninstâœÂ¹â° : MeasurableSpace G\nÎ¼ : MeasureTheory.Measure G\ninstâœâ¹ : NormedSpace Real E'\ninstâœâ¸ : NormedAddCommGroup G\ninstâœâ· : NormedSpace Real G\ninstâœâ¶ : HasContDiffBump G\ninstâœâµ : CompleteSpace E'\nÏ† : ContDiffBump 0\ninstâœâ´ : BorelSpace G\ninstâœÂ³ : MeasureTheory.IsLocallyFiniteMeasure Î¼\ninstâœÂ² : Î¼.IsOpenPosMeasure\ninstâœÂ¹ : FiniteDimensional Real G\ninstâœ : Î¼.IsAddLeftInvariant\nxâ‚€ : G\nÎµ : Real\nhmg : MeasureTheory.AEStronglyMeasurable g Î¼\nhg : âˆ€ (x : G), Membership.mem (Metric.ball xâ‚€ Ï†.rOut) x â†’ LE.le (Dist.dist (g x) (g xâ‚€)) Îµ\nâŠ¢ LE.le (Dist.dist (MeasureTheory.convolution (Ï†.normed Î¼) g (ContinuousLinearMap.lsmul Real Real) Î¼ xâ‚€) (g xâ‚€)) Îµ","decl":"/-- If `Ï†` is a normed bump function, approximate `(Ï† â‹† g) xâ‚€`\nif `g` is near `g xâ‚€` on a ball with radius `Ï†.rOut` around `xâ‚€`. -/\ntheorem dist_normed_convolution_le {xâ‚€ : G} {Îµ : â„} (hmg : AEStronglyMeasurable g Î¼)\n    (hg : âˆ€ x âˆˆ ball xâ‚€ Ï†.rOut, dist (g x) (g xâ‚€) â‰¤ Îµ) :\n    dist ((Ï†.normed Î¼ â‹†[lsmul â„ â„, Î¼] g : G â†’ E') xâ‚€) (g xâ‚€) â‰¤ Îµ :=\n  dist_convolution_le (by simp_rw [â† dist_self (g xâ‚€), hg xâ‚€ (mem_ball_self Ï†.rOut_pos)])\n    Ï†.support_normed_eq.subset Ï†.nonneg_normed Ï†.integral_normed hmg hg\n\n"}
{"name":"ContDiffBump.convolution_tendsto_right","module":"Mathlib.Analysis.Calculus.BumpFunction.Convolution","initialProofState":"G : Type uG\nE' : Type uE'\ninstâœÂ¹Â¹ : NormedAddCommGroup E'\ninstâœÂ¹â° : MeasurableSpace G\nÎ¼ : MeasureTheory.Measure G\ninstâœâ¹ : NormedSpace Real E'\ninstâœâ¸ : NormedAddCommGroup G\ninstâœâ· : NormedSpace Real G\ninstâœâ¶ : HasContDiffBump G\ninstâœâµ : CompleteSpace E'\ninstâœâ´ : BorelSpace G\ninstâœÂ³ : MeasureTheory.IsLocallyFiniteMeasure Î¼\ninstâœÂ² : Î¼.IsOpenPosMeasure\ninstâœÂ¹ : FiniteDimensional Real G\ninstâœ : Î¼.IsAddLeftInvariant\nÎ¹ : Type u_1\nÏ† : Î¹ â†’ ContDiffBump 0\ng : Î¹ â†’ G â†’ E'\nk : Î¹ â†’ G\nxâ‚€ : G\nzâ‚€ : E'\nl : Filter Î¹\nhÏ† : Filter.Tendsto (fun i => (Ï† i).rOut) l (nhds 0)\nhig : Filter.Eventually (fun i => MeasureTheory.AEStronglyMeasurable (g i) Î¼) l\nhcg : Filter.Tendsto (Function.uncurry g) (SProd.sprod l (nhds xâ‚€)) (nhds zâ‚€)\nhk : Filter.Tendsto k l (nhds xâ‚€)\nâŠ¢ Filter.Tendsto (fun i => MeasureTheory.convolution ((Ï† i).normed Î¼) (g i) (ContinuousLinearMap.lsmul Real Real) Î¼ (k i)) l (nhds zâ‚€)","decl":"/-- `(Ï† i â‹† g i) (k i)` tends to `zâ‚€` as `i` tends to some filter `l` if\n* `Ï†` is a sequence of normed bump functions\n  such that `(Ï† i).rOut` tends to `0` as `i` tends to `l`;\n* `g i` is `Î¼`-a.e. strongly measurable as `i` tends to `l`;\n* `g i x` tends to `zâ‚€` as `(i, x)` tends to `l Ã—Ë¢ ğ“ xâ‚€`;\n* `k i` tends to `xâ‚€`. -/\nnonrec theorem convolution_tendsto_right {Î¹} {Ï† : Î¹ â†’ ContDiffBump (0 : G)} {g : Î¹ â†’ G â†’ E'}\n    {k : Î¹ â†’ G} {xâ‚€ : G} {zâ‚€ : E'} {l : Filter Î¹} (hÏ† : Tendsto (fun i => (Ï† i).rOut) l (ğ“ 0))\n    (hig : âˆ€á¶  i in l, AEStronglyMeasurable (g i) Î¼) (hcg : Tendsto (uncurry g) (l Ã—Ë¢ ğ“ xâ‚€) (ğ“ zâ‚€))\n    (hk : Tendsto k l (ğ“ xâ‚€)) :\n    Tendsto (fun i => ((Ï† i).normed Î¼ â‹†[lsmul â„ â„, Î¼] g i) (k i)) l (ğ“ zâ‚€) :=\n  convolution_tendsto_right (Eventually.of_forall fun i => (Ï† i).nonneg_normed)\n    (Eventually.of_forall fun i => (Ï† i).integral_normed) (tendsto_support_normed_smallSets hÏ†) hig\n    hcg hk\n\n"}
{"name":"ContDiffBump.convolution_tendsto_right_of_continuous","module":"Mathlib.Analysis.Calculus.BumpFunction.Convolution","initialProofState":"G : Type uG\nE' : Type uE'\ninstâœÂ¹Â¹ : NormedAddCommGroup E'\ng : G â†’ E'\ninstâœÂ¹â° : MeasurableSpace G\nÎ¼ : MeasureTheory.Measure G\ninstâœâ¹ : NormedSpace Real E'\ninstâœâ¸ : NormedAddCommGroup G\ninstâœâ· : NormedSpace Real G\ninstâœâ¶ : HasContDiffBump G\ninstâœâµ : CompleteSpace E'\ninstâœâ´ : BorelSpace G\ninstâœÂ³ : MeasureTheory.IsLocallyFiniteMeasure Î¼\ninstâœÂ² : Î¼.IsOpenPosMeasure\ninstâœÂ¹ : FiniteDimensional Real G\ninstâœ : Î¼.IsAddLeftInvariant\nÎ¹ : Type u_1\nÏ† : Î¹ â†’ ContDiffBump 0\nl : Filter Î¹\nhÏ† : Filter.Tendsto (fun i => (Ï† i).rOut) l (nhds 0)\nhg : Continuous g\nxâ‚€ : G\nâŠ¢ Filter.Tendsto (fun i => MeasureTheory.convolution ((Ï† i).normed Î¼) g (ContinuousLinearMap.lsmul Real Real) Î¼ xâ‚€) l (nhds (g xâ‚€))","decl":"/-- Special case of `ContDiffBump.convolution_tendsto_right` where `g` is continuous,\n  and the limit is taken only in the first function. -/\ntheorem convolution_tendsto_right_of_continuous {Î¹} {Ï† : Î¹ â†’ ContDiffBump (0 : G)} {l : Filter Î¹}\n    (hÏ† : Tendsto (fun i => (Ï† i).rOut) l (ğ“ 0)) (hg : Continuous g) (xâ‚€ : G) :\n    Tendsto (fun i => ((Ï† i).normed Î¼ â‹†[lsmul â„ â„, Î¼] g) xâ‚€) l (ğ“ (g xâ‚€)) :=\n  convolution_tendsto_right hÏ† (Eventually.of_forall fun _ => hg.aestronglyMeasurable)\n    ((hg.tendsto xâ‚€).comp tendsto_snd) tendsto_const_nhds\n\n"}
{"name":"ContDiffBump.ae_convolution_tendsto_right_of_locallyIntegrable","module":"Mathlib.Analysis.Calculus.BumpFunction.Convolution","initialProofState":"G : Type uG\nE' : Type uE'\ninstâœÂ¹Â¹ : NormedAddCommGroup E'\ng : G â†’ E'\ninstâœÂ¹â° : MeasurableSpace G\nÎ¼ : MeasureTheory.Measure G\ninstâœâ¹ : NormedSpace Real E'\ninstâœâ¸ : NormedAddCommGroup G\ninstâœâ· : NormedSpace Real G\ninstâœâ¶ : HasContDiffBump G\ninstâœâµ : CompleteSpace E'\ninstâœâ´ : BorelSpace G\ninstâœÂ³ : MeasureTheory.IsLocallyFiniteMeasure Î¼\ninstâœÂ² : Î¼.IsOpenPosMeasure\ninstâœÂ¹ : FiniteDimensional Real G\ninstâœ : Î¼.IsAddLeftInvariant\nÎ¹ : Type u_1\nÏ† : Î¹ â†’ ContDiffBump 0\nl : Filter Î¹\nK : Real\nhÏ† : Filter.Tendsto (fun i => (Ï† i).rOut) l (nhds 0)\nh'Ï† : Filter.Eventually (fun i => LE.le (Ï† i).rOut (HMul.hMul K (Ï† i).rIn)) l\nhg : MeasureTheory.LocallyIntegrable g Î¼\nâŠ¢ Filter.Eventually (fun xâ‚€ => Filter.Tendsto (fun i => MeasureTheory.convolution ((Ï† i).normed Î¼) g (ContinuousLinearMap.lsmul Real Real) Î¼ xâ‚€) l (nhds (g xâ‚€))) (MeasureTheory.ae Î¼)","decl":"/-- If a function `g` is locally integrable, then the convolution `Ï† i * g` converges almost\neverywhere to `g` if `Ï† i` is a sequence of bump functions with support tending to `0`, provided\nthat the ratio between the inner and outer radii of `Ï† i` remains bounded. -/\ntheorem ae_convolution_tendsto_right_of_locallyIntegrable\n    {Î¹} {Ï† : Î¹ â†’ ContDiffBump (0 : G)} {l : Filter Î¹} {K : â„}\n    (hÏ† : Tendsto (fun i â†¦ (Ï† i).rOut) l (ğ“ 0))\n    (h'Ï† : âˆ€á¶  i in l, (Ï† i).rOut â‰¤ K * (Ï† i).rIn) (hg : LocallyIntegrable g Î¼) : âˆ€áµ xâ‚€ âˆ‚Î¼,\n    Tendsto (fun i â†¦ ((Ï† i).normed Î¼ â‹†[lsmul â„ â„, Î¼] g) xâ‚€) l (ğ“ (g xâ‚€)) := by\n  have : IsAddHaarMeasure Î¼ := âŸ¨âŸ©\n  -- By Lebesgue differentiation theorem, the average of `g` on a small ball converges\n  -- almost everywhere to the value of `g` as the radius shrinks to zero.\n  -- We will see that this set of points satisfies the desired conclusion.\n  filter_upwards [(Besicovitch.vitaliFamily Î¼).ae_tendsto_average_norm_sub hg] with xâ‚€ hâ‚€\n  simp only [convolution_eq_swap, lsmul_apply]\n  have hÏ†' : Tendsto (fun i â†¦ (Ï† i).rOut) l (ğ“[>] 0) :=\n    tendsto_nhdsWithin_iff.2 âŸ¨hÏ†, Eventually.of_forall (fun i â†¦ (Ï† i).rOut_pos)âŸ©\n  have := (hâ‚€.comp (Besicovitch.tendsto_filterAt Î¼ xâ‚€)).comp hÏ†'\n  simp only [Function.comp] at this\n  apply tendsto_integral_smul_of_tendsto_average_norm_sub (K ^ (Module.finrank â„ G)) this\n  Â· filter_upwards with i using\n      hg.integrableOn_isCompact (isCompact_closedBall _ _)\n  Â· apply tendsto_const_nhds.congr (fun i â†¦ ?_)\n    rw [â† integral_neg_eq_self]\n    simp only [sub_neg_eq_add, integral_add_left_eq_self, integral_normed]\n  Â· filter_upwards with i\n    change support ((ContDiffBump.normed (Ï† i) Î¼) âˆ˜ (fun y â†¦ xâ‚€ - y)) âŠ† closedBall xâ‚€ (Ï† i).rOut\n    simp only [support_comp_eq_preimage, support_normed_eq]\n    intro x hx\n    simp only [mem_preimage, mem_ball, dist_zero_right] at hx\n    simpa [dist_eq_norm_sub'] using hx.le\n  Â· filter_upwards [h'Ï†] with i hi x\n    rw [abs_of_nonneg (nonneg_normed _ _), addHaar_closedBall_center]\n    exact (Ï† i).normed_le_div_measure_closedBall_rOut _ _ hi _\n\n"}
