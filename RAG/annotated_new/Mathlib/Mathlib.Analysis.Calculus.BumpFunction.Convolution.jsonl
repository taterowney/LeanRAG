{"name":"ContDiffBump.convolution_eq_right","module":"Mathlib.Analysis.Calculus.BumpFunction.Convolution","initialProofState":"G : Type uG\nE' : Type uE'\ninst‚úù‚Å∂ : NormedAddCommGroup E'\ng : G ‚Üí E'\ninst‚úù‚Åµ : MeasurableSpace G\nŒº : MeasureTheory.Measure G\ninst‚úù‚Å¥ : NormedSpace Real E'\ninst‚úù¬≥ : NormedAddCommGroup G\ninst‚úù¬≤ : NormedSpace Real G\ninst‚úù¬π : HasContDiffBump G\ninst‚úù : CompleteSpace E'\nœÜ : ContDiffBump 0\nx‚ÇÄ : G\nhg : ‚àÄ (x : G), Membership.mem (Metric.ball x‚ÇÄ œÜ.rOut) x ‚Üí Eq (g x) (g x‚ÇÄ)\n‚ä¢ Eq (MeasureTheory.convolution (‚ÜëœÜ) g (ContinuousLinearMap.lsmul Real Real) Œº x‚ÇÄ) (HSMul.hSMul (MeasureTheory.integral Œº ‚ÜëœÜ) (g x‚ÇÄ))","decl":"/-- If `œÜ` is a bump function, compute `(œÜ ‚ãÜ g) x‚ÇÄ`\nif `g` is constant on `Metric.ball x‚ÇÄ œÜ.rOut`. -/\ntheorem convolution_eq_right {x‚ÇÄ : G} (hg : ‚àÄ x ‚àà ball x‚ÇÄ œÜ.rOut, g x = g x‚ÇÄ) :\n    (œÜ ‚ãÜ[lsmul ‚Ñù ‚Ñù, Œº] g : G ‚Üí E') x‚ÇÄ = integral Œº œÜ ‚Ä¢ g x‚ÇÄ := by\n  simp_rw [convolution_eq_right' _ œÜ.support_eq.subset hg, lsmul_apply, integral_smul_const]\n\n"}
{"name":"ContDiffBump.normed_convolution_eq_right","module":"Mathlib.Analysis.Calculus.BumpFunction.Convolution","initialProofState":"G : Type uG\nE' : Type uE'\ninst‚úù¬π‚Å∞ : NormedAddCommGroup E'\ng : G ‚Üí E'\ninst‚úù‚Åπ : MeasurableSpace G\nŒº : MeasureTheory.Measure G\ninst‚úù‚Å∏ : NormedSpace Real E'\ninst‚úù‚Å∑ : NormedAddCommGroup G\ninst‚úù‚Å∂ : NormedSpace Real G\ninst‚úù‚Åµ : HasContDiffBump G\ninst‚úù‚Å¥ : CompleteSpace E'\nœÜ : ContDiffBump 0\ninst‚úù¬≥ : BorelSpace G\ninst‚úù¬≤ : MeasureTheory.IsLocallyFiniteMeasure Œº\ninst‚úù¬π : Œº.IsOpenPosMeasure\ninst‚úù : FiniteDimensional Real G\nx‚ÇÄ : G\nhg : ‚àÄ (x : G), Membership.mem (Metric.ball x‚ÇÄ œÜ.rOut) x ‚Üí Eq (g x) (g x‚ÇÄ)\n‚ä¢ Eq (MeasureTheory.convolution (œÜ.normed Œº) g (ContinuousLinearMap.lsmul Real Real) Œº x‚ÇÄ) (g x‚ÇÄ)","decl":"/-- If `œÜ` is a normed bump function, compute `œÜ ‚ãÜ g`\nif `g` is constant on `Metric.ball x‚ÇÄ œÜ.rOut`. -/\ntheorem normed_convolution_eq_right {x‚ÇÄ : G} (hg : ‚àÄ x ‚àà ball x‚ÇÄ œÜ.rOut, g x = g x‚ÇÄ) :\n    (œÜ.normed Œº ‚ãÜ[lsmul ‚Ñù ‚Ñù, Œº] g : G ‚Üí E') x‚ÇÄ = g x‚ÇÄ := by\n  rw [convolution_eq_right' _ œÜ.support_normed_eq.subset hg]\n  exact integral_normed_smul œÜ Œº (g x‚ÇÄ)\n\n"}
{"name":"ContDiffBump.dist_normed_convolution_le","module":"Mathlib.Analysis.Calculus.BumpFunction.Convolution","initialProofState":"G : Type uG\nE' : Type uE'\ninst‚úù¬π¬π : NormedAddCommGroup E'\ng : G ‚Üí E'\ninst‚úù¬π‚Å∞ : MeasurableSpace G\nŒº : MeasureTheory.Measure G\ninst‚úù‚Åπ : NormedSpace Real E'\ninst‚úù‚Å∏ : NormedAddCommGroup G\ninst‚úù‚Å∑ : NormedSpace Real G\ninst‚úù‚Å∂ : HasContDiffBump G\ninst‚úù‚Åµ : CompleteSpace E'\nœÜ : ContDiffBump 0\ninst‚úù‚Å¥ : BorelSpace G\ninst‚úù¬≥ : MeasureTheory.IsLocallyFiniteMeasure Œº\ninst‚úù¬≤ : Œº.IsOpenPosMeasure\ninst‚úù¬π : FiniteDimensional Real G\ninst‚úù : Œº.IsAddLeftInvariant\nx‚ÇÄ : G\nŒµ : Real\nhmg : MeasureTheory.AEStronglyMeasurable g Œº\nhg : ‚àÄ (x : G), Membership.mem (Metric.ball x‚ÇÄ œÜ.rOut) x ‚Üí LE.le (Dist.dist (g x) (g x‚ÇÄ)) Œµ\n‚ä¢ LE.le (Dist.dist (MeasureTheory.convolution (œÜ.normed Œº) g (ContinuousLinearMap.lsmul Real Real) Œº x‚ÇÄ) (g x‚ÇÄ)) Œµ","decl":"/-- If `œÜ` is a normed bump function, approximate `(œÜ ‚ãÜ g) x‚ÇÄ`\nif `g` is near `g x‚ÇÄ` on a ball with radius `œÜ.rOut` around `x‚ÇÄ`. -/\ntheorem dist_normed_convolution_le {x‚ÇÄ : G} {Œµ : ‚Ñù} (hmg : AEStronglyMeasurable g Œº)\n    (hg : ‚àÄ x ‚àà ball x‚ÇÄ œÜ.rOut, dist (g x) (g x‚ÇÄ) ‚â§ Œµ) :\n    dist ((œÜ.normed Œº ‚ãÜ[lsmul ‚Ñù ‚Ñù, Œº] g : G ‚Üí E') x‚ÇÄ) (g x‚ÇÄ) ‚â§ Œµ :=\n  dist_convolution_le (by simp_rw [‚Üê dist_self (g x‚ÇÄ), hg x‚ÇÄ (mem_ball_self œÜ.rOut_pos)])\n    œÜ.support_normed_eq.subset œÜ.nonneg_normed œÜ.integral_normed hmg hg\n\n"}
{"name":"ContDiffBump.convolution_tendsto_right","module":"Mathlib.Analysis.Calculus.BumpFunction.Convolution","initialProofState":"G : Type uG\nE' : Type uE'\ninst‚úù¬π¬π : NormedAddCommGroup E'\ninst‚úù¬π‚Å∞ : MeasurableSpace G\nŒº : MeasureTheory.Measure G\ninst‚úù‚Åπ : NormedSpace Real E'\ninst‚úù‚Å∏ : NormedAddCommGroup G\ninst‚úù‚Å∑ : NormedSpace Real G\ninst‚úù‚Å∂ : HasContDiffBump G\ninst‚úù‚Åµ : CompleteSpace E'\ninst‚úù‚Å¥ : BorelSpace G\ninst‚úù¬≥ : MeasureTheory.IsLocallyFiniteMeasure Œº\ninst‚úù¬≤ : Œº.IsOpenPosMeasure\ninst‚úù¬π : FiniteDimensional Real G\ninst‚úù : Œº.IsAddLeftInvariant\nŒπ : Type u_1\nœÜ : Œπ ‚Üí ContDiffBump 0\ng : Œπ ‚Üí G ‚Üí E'\nk : Œπ ‚Üí G\nx‚ÇÄ : G\nz‚ÇÄ : E'\nl : Filter Œπ\nhœÜ : Filter.Tendsto (fun i => (œÜ i).rOut) l (nhds 0)\nhig : Filter.Eventually (fun i => MeasureTheory.AEStronglyMeasurable (g i) Œº) l\nhcg : Filter.Tendsto (Function.uncurry g) (SProd.sprod l (nhds x‚ÇÄ)) (nhds z‚ÇÄ)\nhk : Filter.Tendsto k l (nhds x‚ÇÄ)\n‚ä¢ Filter.Tendsto (fun i => MeasureTheory.convolution ((œÜ i).normed Œº) (g i) (ContinuousLinearMap.lsmul Real Real) Œº (k i)) l (nhds z‚ÇÄ)","decl":"/-- `(œÜ i ‚ãÜ g i) (k i)` tends to `z‚ÇÄ` as `i` tends to some filter `l` if\n* `œÜ` is a sequence of normed bump functions\n  such that `(œÜ i).rOut` tends to `0` as `i` tends to `l`;\n* `g i` is `Œº`-a.e. strongly measurable as `i` tends to `l`;\n* `g i x` tends to `z‚ÇÄ` as `(i, x)` tends to `l √óÀ¢ ùìù x‚ÇÄ`;\n* `k i` tends to `x‚ÇÄ`. -/\nnonrec theorem convolution_tendsto_right {Œπ} {œÜ : Œπ ‚Üí ContDiffBump (0 : G)} {g : Œπ ‚Üí G ‚Üí E'}\n    {k : Œπ ‚Üí G} {x‚ÇÄ : G} {z‚ÇÄ : E'} {l : Filter Œπ} (hœÜ : Tendsto (fun i => (œÜ i).rOut) l (ùìù 0))\n    (hig : ‚àÄ·∂† i in l, AEStronglyMeasurable (g i) Œº) (hcg : Tendsto (uncurry g) (l √óÀ¢ ùìù x‚ÇÄ) (ùìù z‚ÇÄ))\n    (hk : Tendsto k l (ùìù x‚ÇÄ)) :\n    Tendsto (fun i => ((œÜ i).normed Œº ‚ãÜ[lsmul ‚Ñù ‚Ñù, Œº] g i) (k i)) l (ùìù z‚ÇÄ) :=\n  convolution_tendsto_right (Eventually.of_forall fun i => (œÜ i).nonneg_normed)\n    (Eventually.of_forall fun i => (œÜ i).integral_normed) (tendsto_support_normed_smallSets hœÜ) hig\n    hcg hk\n\n"}
{"name":"ContDiffBump.convolution_tendsto_right_of_continuous","module":"Mathlib.Analysis.Calculus.BumpFunction.Convolution","initialProofState":"G : Type uG\nE' : Type uE'\ninst‚úù¬π¬π : NormedAddCommGroup E'\ng : G ‚Üí E'\ninst‚úù¬π‚Å∞ : MeasurableSpace G\nŒº : MeasureTheory.Measure G\ninst‚úù‚Åπ : NormedSpace Real E'\ninst‚úù‚Å∏ : NormedAddCommGroup G\ninst‚úù‚Å∑ : NormedSpace Real G\ninst‚úù‚Å∂ : HasContDiffBump G\ninst‚úù‚Åµ : CompleteSpace E'\ninst‚úù‚Å¥ : BorelSpace G\ninst‚úù¬≥ : MeasureTheory.IsLocallyFiniteMeasure Œº\ninst‚úù¬≤ : Œº.IsOpenPosMeasure\ninst‚úù¬π : FiniteDimensional Real G\ninst‚úù : Œº.IsAddLeftInvariant\nŒπ : Type u_1\nœÜ : Œπ ‚Üí ContDiffBump 0\nl : Filter Œπ\nhœÜ : Filter.Tendsto (fun i => (œÜ i).rOut) l (nhds 0)\nhg : Continuous g\nx‚ÇÄ : G\n‚ä¢ Filter.Tendsto (fun i => MeasureTheory.convolution ((œÜ i).normed Œº) g (ContinuousLinearMap.lsmul Real Real) Œº x‚ÇÄ) l (nhds (g x‚ÇÄ))","decl":"/-- Special case of `ContDiffBump.convolution_tendsto_right` where `g` is continuous,\n  and the limit is taken only in the first function. -/\ntheorem convolution_tendsto_right_of_continuous {Œπ} {œÜ : Œπ ‚Üí ContDiffBump (0 : G)} {l : Filter Œπ}\n    (hœÜ : Tendsto (fun i => (œÜ i).rOut) l (ùìù 0)) (hg : Continuous g) (x‚ÇÄ : G) :\n    Tendsto (fun i => ((œÜ i).normed Œº ‚ãÜ[lsmul ‚Ñù ‚Ñù, Œº] g) x‚ÇÄ) l (ùìù (g x‚ÇÄ)) :=\n  convolution_tendsto_right hœÜ (Eventually.of_forall fun _ => hg.aestronglyMeasurable)\n    ((hg.tendsto x‚ÇÄ).comp tendsto_snd) tendsto_const_nhds\n\n"}
{"name":"ContDiffBump.ae_convolution_tendsto_right_of_locallyIntegrable","module":"Mathlib.Analysis.Calculus.BumpFunction.Convolution","initialProofState":"G : Type uG\nE' : Type uE'\ninst‚úù¬π¬π : NormedAddCommGroup E'\ng : G ‚Üí E'\ninst‚úù¬π‚Å∞ : MeasurableSpace G\nŒº : MeasureTheory.Measure G\ninst‚úù‚Åπ : NormedSpace Real E'\ninst‚úù‚Å∏ : NormedAddCommGroup G\ninst‚úù‚Å∑ : NormedSpace Real G\ninst‚úù‚Å∂ : HasContDiffBump G\ninst‚úù‚Åµ : CompleteSpace E'\ninst‚úù‚Å¥ : BorelSpace G\ninst‚úù¬≥ : MeasureTheory.IsLocallyFiniteMeasure Œº\ninst‚úù¬≤ : Œº.IsOpenPosMeasure\ninst‚úù¬π : FiniteDimensional Real G\ninst‚úù : Œº.IsAddLeftInvariant\nŒπ : Type u_1\nœÜ : Œπ ‚Üí ContDiffBump 0\nl : Filter Œπ\nK : Real\nhœÜ : Filter.Tendsto (fun i => (œÜ i).rOut) l (nhds 0)\nh'œÜ : Filter.Eventually (fun i => LE.le (œÜ i).rOut (HMul.hMul K (œÜ i).rIn)) l\nhg : MeasureTheory.LocallyIntegrable g Œº\n‚ä¢ Filter.Eventually (fun x‚ÇÄ => Filter.Tendsto (fun i => MeasureTheory.convolution ((œÜ i).normed Œº) g (ContinuousLinearMap.lsmul Real Real) Œº x‚ÇÄ) l (nhds (g x‚ÇÄ))) (MeasureTheory.ae Œº)","decl":"/-- If a function `g` is locally integrable, then the convolution `œÜ i * g` converges almost\neverywhere to `g` if `œÜ i` is a sequence of bump functions with support tending to `0`, provided\nthat the ratio between the inner and outer radii of `œÜ i` remains bounded. -/\ntheorem ae_convolution_tendsto_right_of_locallyIntegrable\n    {Œπ} {œÜ : Œπ ‚Üí ContDiffBump (0 : G)} {l : Filter Œπ} {K : ‚Ñù}\n    (hœÜ : Tendsto (fun i ‚Ü¶ (œÜ i).rOut) l (ùìù 0))\n    (h'œÜ : ‚àÄ·∂† i in l, (œÜ i).rOut ‚â§ K * (œÜ i).rIn) (hg : LocallyIntegrable g Œº) : ‚àÄ·µê x‚ÇÄ ‚àÇŒº,\n    Tendsto (fun i ‚Ü¶ ((œÜ i).normed Œº ‚ãÜ[lsmul ‚Ñù ‚Ñù, Œº] g) x‚ÇÄ) l (ùìù (g x‚ÇÄ)) := by\n  have : IsAddHaarMeasure Œº := ‚ü®‚ü©\n  -- By Lebesgue differentiation theorem, the average of `g` on a small ball converges\n  -- almost everywhere to the value of `g` as the radius shrinks to zero.\n  -- We will see that this set of points satisfies the desired conclusion.\n  filter_upwards [(Besicovitch.vitaliFamily Œº).ae_tendsto_average_norm_sub hg] with x‚ÇÄ h‚ÇÄ\n  simp only [convolution_eq_swap, lsmul_apply]\n  have hœÜ' : Tendsto (fun i ‚Ü¶ (œÜ i).rOut) l (ùìù[>] 0) :=\n    tendsto_nhdsWithin_iff.2 ‚ü®hœÜ, Eventually.of_forall (fun i ‚Ü¶ (œÜ i).rOut_pos)‚ü©\n  have := (h‚ÇÄ.comp (Besicovitch.tendsto_filterAt Œº x‚ÇÄ)).comp hœÜ'\n  simp only [Function.comp] at this\n  apply tendsto_integral_smul_of_tendsto_average_norm_sub (K ^ (Module.finrank ‚Ñù G)) this\n  ¬∑ filter_upwards with i using\n      hg.integrableOn_isCompact (isCompact_closedBall _ _)\n  ¬∑ apply tendsto_const_nhds.congr (fun i ‚Ü¶ ?_)\n    rw [‚Üê integral_neg_eq_self]\n    simp only [sub_neg_eq_add, integral_add_left_eq_self, integral_normed]\n  ¬∑ filter_upwards with i\n    change support ((ContDiffBump.normed (œÜ i) Œº) ‚àò (fun y ‚Ü¶ x‚ÇÄ - y)) ‚äÜ closedBall x‚ÇÄ (œÜ i).rOut\n    simp only [support_comp_eq_preimage, support_normed_eq]\n    intro x hx\n    simp only [mem_preimage, mem_ball, dist_zero_right] at hx\n    simpa [dist_eq_norm_sub'] using hx.le\n  ¬∑ filter_upwards [h'œÜ] with i hi x\n    rw [abs_of_nonneg (nonneg_normed _ _), addHaar_closedBall_center]\n    exact (œÜ i).normed_le_div_measure_closedBall_rOut _ _ hi _\n\n"}
