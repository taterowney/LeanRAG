{"name":"Ring.mul_inverse_rev'","module":"Mathlib.Algebra.GroupWithZero.Commute","initialProofState":"M₀ : Type u_1\ninst✝ : MonoidWithZero M₀\na b : M₀\nh : Commute a b\n⊢ Eq (Ring.inverse (HMul.hMul a b)) (HMul.hMul (Ring.inverse b) (Ring.inverse a))","decl":"theorem mul_inverse_rev' {a b : M₀} (h : Commute a b) :\n    inverse (a * b) = inverse b * inverse a := by\n  by_cases hab : IsUnit (a * b)\n  · obtain ⟨⟨a, rfl⟩, b, rfl⟩ := h.isUnit_mul_iff.mp hab\n    rw [← Units.val_mul, inverse_unit, inverse_unit, inverse_unit, ← Units.val_mul, mul_inv_rev]\n  obtain ha | hb := not_and_or.mp (mt h.isUnit_mul_iff.mpr hab)\n  · rw [inverse_non_unit _ hab, inverse_non_unit _ ha, mul_zero]\n  · rw [inverse_non_unit _ hab, inverse_non_unit _ hb, zero_mul]\n\n"}
{"name":"Ring.mul_inverse_rev","module":"Mathlib.Algebra.GroupWithZero.Commute","initialProofState":"M₀ : Type u_3\ninst✝ : CommMonoidWithZero M₀\na b : M₀\n⊢ Eq (Ring.inverse (HMul.hMul a b)) (HMul.hMul (Ring.inverse b) (Ring.inverse a))","decl":"theorem mul_inverse_rev {M₀} [CommMonoidWithZero M₀] (a b : M₀) :\n    Ring.inverse (a * b) = inverse b * inverse a :=\n  mul_inverse_rev' (Commute.all _ _)\n\n"}
{"name":"Ring.inverse_pow","module":"Mathlib.Algebra.GroupWithZero.Commute","initialProofState":"M₀ : Type u_1\ninst✝ : MonoidWithZero M₀\nr : M₀\nn : Nat\n⊢ Eq (HPow.hPow (Ring.inverse r) n) (Ring.inverse (HPow.hPow r n))","decl":"lemma inverse_pow (r : M₀) : ∀ n : ℕ, Ring.inverse r ^ n = Ring.inverse (r ^ n)\n  | 0 => by rw [pow_zero, pow_zero, Ring.inverse_one]\n  | n + 1 => by\n    rw [pow_succ', pow_succ, Ring.mul_inverse_rev' ((Commute.refl r).pow_left n),\n      Ring.inverse_pow r n]\n\n"}
{"name":"Commute.ring_inverse_ring_inverse","module":"Mathlib.Algebra.GroupWithZero.Commute","initialProofState":"M₀ : Type u_1\ninst✝ : MonoidWithZero M₀\na b : M₀\nh : Commute a b\n⊢ Commute (Ring.inverse a) (Ring.inverse b)","decl":"theorem Commute.ring_inverse_ring_inverse {a b : M₀} (h : Commute a b) :\n    Commute (Ring.inverse a) (Ring.inverse b) :=\n  (Ring.mul_inverse_rev' h.symm).symm.trans <| (congr_arg _ h.symm.eq).trans <|\n    Ring.mul_inverse_rev' h\n\n"}
{"name":"Commute.zero_right","module":"Mathlib.Algebra.GroupWithZero.Commute","initialProofState":"G₀ : Type u_2\ninst✝ : MulZeroClass G₀\na : G₀\n⊢ Commute a 0","decl":"@[simp]\ntheorem zero_right [MulZeroClass G₀] (a : G₀) : Commute a 0 :=\n  SemiconjBy.zero_right a\n\n"}
{"name":"Commute.zero_left","module":"Mathlib.Algebra.GroupWithZero.Commute","initialProofState":"G₀ : Type u_2\ninst✝ : MulZeroClass G₀\na : G₀\n⊢ Commute 0 a","decl":"@[simp]\ntheorem zero_left [MulZeroClass G₀] (a : G₀) : Commute 0 a :=\n  SemiconjBy.zero_left a a\n\n"}
{"name":"Commute.inv_left_iff₀","module":"Mathlib.Algebra.GroupWithZero.Commute","initialProofState":"G₀ : Type u_2\ninst✝ : GroupWithZero G₀\na b : G₀\n⊢ Iff (Commute (Inv.inv a) b) (Commute a b)","decl":"@[simp]\ntheorem inv_left_iff₀ : Commute a⁻¹ b ↔ Commute a b :=\n  SemiconjBy.inv_symm_left_iff₀\n\n"}
{"name":"Commute.inv_left₀","module":"Mathlib.Algebra.GroupWithZero.Commute","initialProofState":"G₀ : Type u_2\ninst✝ : GroupWithZero G₀\na b : G₀\nh : Commute a b\n⊢ Commute (Inv.inv a) b","decl":"theorem inv_left₀ (h : Commute a b) : Commute a⁻¹ b :=\n  inv_left_iff₀.2 h\n\n"}
{"name":"Commute.inv_right_iff₀","module":"Mathlib.Algebra.GroupWithZero.Commute","initialProofState":"G₀ : Type u_2\ninst✝ : GroupWithZero G₀\na b : G₀\n⊢ Iff (Commute a (Inv.inv b)) (Commute a b)","decl":"@[simp]\ntheorem inv_right_iff₀ : Commute a b⁻¹ ↔ Commute a b :=\n  SemiconjBy.inv_right_iff₀\n\n"}
{"name":"Commute.inv_right₀","module":"Mathlib.Algebra.GroupWithZero.Commute","initialProofState":"G₀ : Type u_2\ninst✝ : GroupWithZero G₀\na b : G₀\nh : Commute a b\n⊢ Commute a (Inv.inv b)","decl":"theorem inv_right₀ (h : Commute a b) : Commute a b⁻¹ :=\n  inv_right_iff₀.2 h\n\n"}
{"name":"Commute.div_right","module":"Mathlib.Algebra.GroupWithZero.Commute","initialProofState":"G₀ : Type u_2\ninst✝ : GroupWithZero G₀\na b c : G₀\nhab : Commute a b\nhac : Commute a c\n⊢ Commute a (HDiv.hDiv b c)","decl":"@[simp]\ntheorem div_right (hab : Commute a b) (hac : Commute a c) : Commute a (b / c) :=\n  SemiconjBy.div_right hab hac\n\n"}
{"name":"Commute.div_left","module":"Mathlib.Algebra.GroupWithZero.Commute","initialProofState":"G₀ : Type u_2\ninst✝ : GroupWithZero G₀\na b c : G₀\nhac : Commute a c\nhbc : Commute b c\n⊢ Commute (HDiv.hDiv a b) c","decl":"@[simp]\ntheorem div_left (hac : Commute a c) (hbc : Commute b c) : Commute (a / b) c := by\n  rw [div_eq_mul_inv]\n  exact hac.mul_left hbc.inv_left₀\n\n"}
{"name":"pow_inv_comm₀","module":"Mathlib.Algebra.GroupWithZero.Commute","initialProofState":"G₀ : Type u_2\ninst✝ : GroupWithZero G₀\na : G₀\nm n : Nat\n⊢ Eq (HMul.hMul (HPow.hPow (Inv.inv a) m) (HPow.hPow a n)) (HMul.hMul (HPow.hPow a n) (HPow.hPow (Inv.inv a) m))","decl":"theorem pow_inv_comm₀ (a : G₀) (m n : ℕ) : a⁻¹ ^ m * a ^ n = a ^ n * a⁻¹ ^ m :=\n  (Commute.refl a).inv_left₀.pow_pow m n\n\n"}
