{"name":"MeasureTheory.AEStronglyMeasurable.truncation","module":"Mathlib.Probability.StrongLaw","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ Real\nhf : MeasureTheory.AEStronglyMeasurable f Î¼\nA : Real\nâŠ¢ MeasureTheory.AEStronglyMeasurable (ProbabilityTheory.truncation f A) Î¼","decl":"theorem _root_.MeasureTheory.AEStronglyMeasurable.truncation (hf : AEStronglyMeasurable f Î¼)\n    {A : â„} : AEStronglyMeasurable (truncation f A) Î¼ := by\n  apply AEStronglyMeasurable.comp_aemeasurable _ hf.aemeasurable\n  exact (stronglyMeasurable_id.indicator measurableSet_Ioc).aestronglyMeasurable\n\n"}
{"name":"ProbabilityTheory.abs_truncation_le_bound","module":"Mathlib.Probability.StrongLaw","initialProofState":"Î± : Type u_1\nf : Î± â†’ Real\nA : Real\nx : Î±\nâŠ¢ LE.le (abs (ProbabilityTheory.truncation f A x)) (abs A)","decl":"theorem abs_truncation_le_bound (f : Î± â†’ â„) (A : â„) (x : Î±) : |truncation f A x| â‰¤ |A| := by\n  simp only [truncation, Set.indicator, Set.mem_Icc, id, Function.comp_apply]\n  split_ifs with h\n  Â· exact abs_le_abs h.2 (neg_le.2 h.1.le)\n  Â· simp [abs_nonneg]\n\n"}
{"name":"ProbabilityTheory.truncation_zero","module":"Mathlib.Probability.StrongLaw","initialProofState":"Î± : Type u_1\nf : Î± â†’ Real\nâŠ¢ Eq (ProbabilityTheory.truncation f 0) 0","decl":"@[simp]\ntheorem truncation_zero (f : Î± â†’ â„) : truncation f 0 = 0 := by simp [truncation]; rfl\n\n"}
{"name":"ProbabilityTheory.abs_truncation_le_abs_self","module":"Mathlib.Probability.StrongLaw","initialProofState":"Î± : Type u_1\nf : Î± â†’ Real\nA : Real\nx : Î±\nâŠ¢ LE.le (abs (ProbabilityTheory.truncation f A x)) (abs (f x))","decl":"theorem abs_truncation_le_abs_self (f : Î± â†’ â„) (A : â„) (x : Î±) : |truncation f A x| â‰¤ |f x| := by\n  simp only [truncation, indicator, Set.mem_Icc, id, Function.comp_apply]\n  split_ifs\n  Â· exact le_rfl\n  Â· simp [abs_nonneg]\n\n"}
{"name":"ProbabilityTheory.truncation_eq_self","module":"Mathlib.Probability.StrongLaw","initialProofState":"Î± : Type u_1\nf : Î± â†’ Real\nA : Real\nx : Î±\nh : LT.lt (abs (f x)) A\nâŠ¢ Eq (ProbabilityTheory.truncation f A x) (f x)","decl":"theorem truncation_eq_self {f : Î± â†’ â„} {A : â„} {x : Î±} (h : |f x| < A) :\n    truncation f A x = f x := by\n  simp only [truncation, indicator, Set.mem_Icc, id, Function.comp_apply, ite_eq_left_iff]\n  intro H\n  apply H.elim\n  simp [(abs_lt.1 h).1, (abs_lt.1 h).2.le]\n\n"}
{"name":"ProbabilityTheory.truncation_eq_of_nonneg","module":"Mathlib.Probability.StrongLaw","initialProofState":"Î± : Type u_1\nf : Î± â†’ Real\nA : Real\nh : âˆ€ (x : Î±), LE.le 0 (f x)\nâŠ¢ Eq (ProbabilityTheory.truncation f A) (Function.comp ((Set.Ioc 0 A).indicator id) f)","decl":"theorem truncation_eq_of_nonneg {f : Î± â†’ â„} {A : â„} (h : âˆ€ x, 0 â‰¤ f x) :\n    truncation f A = indicator (Set.Ioc 0 A) id âˆ˜ f := by\n  ext x\n  rcases (h x).lt_or_eq with (hx | hx)\n  Â· simp only [truncation, indicator, hx, Set.mem_Ioc, id, Function.comp_apply]\n    by_cases h'x : f x â‰¤ A\n    Â· have : -A < f x := by linarith [h x]\n      simp only [this, true_and]\n    Â· simp only [h'x, and_false]\n  Â· simp only [truncation, indicator, hx, id, Function.comp_apply, ite_self]\n\n"}
{"name":"ProbabilityTheory.truncation_nonneg","module":"Mathlib.Probability.StrongLaw","initialProofState":"Î± : Type u_1\nf : Î± â†’ Real\nA : Real\nx : Î±\nh : LE.le 0 (f x)\nâŠ¢ LE.le 0 (ProbabilityTheory.truncation f A x)","decl":"theorem truncation_nonneg {f : Î± â†’ â„} (A : â„) {x : Î±} (h : 0 â‰¤ f x) : 0 â‰¤ truncation f A x :=\n  Set.indicator_apply_nonneg fun _ => h\n\n"}
{"name":"MeasureTheory.AEStronglyMeasurable.memâ„’p_truncation","module":"Mathlib.Probability.StrongLaw","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ Real\ninstâœ : MeasureTheory.IsFiniteMeasure Î¼\nhf : MeasureTheory.AEStronglyMeasurable f Î¼\nA : Real\np : ENNReal\nâŠ¢ MeasureTheory.Memâ„’p (ProbabilityTheory.truncation f A) p Î¼","decl":"theorem _root_.MeasureTheory.AEStronglyMeasurable.memâ„’p_truncation [IsFiniteMeasure Î¼]\n    (hf : AEStronglyMeasurable f Î¼) {A : â„} {p : â„â‰¥0âˆ} : Memâ„’p (truncation f A) p Î¼ :=\n  Memâ„’p.of_bound hf.truncation |A| (Eventually.of_forall fun _ => abs_truncation_le_bound _ _ _)\n\n"}
{"name":"MeasureTheory.AEStronglyMeasurable.integrable_truncation","module":"Mathlib.Probability.StrongLaw","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ Real\ninstâœ : MeasureTheory.IsFiniteMeasure Î¼\nhf : MeasureTheory.AEStronglyMeasurable f Î¼\nA : Real\nâŠ¢ MeasureTheory.Integrable (ProbabilityTheory.truncation f A) Î¼","decl":"theorem _root_.MeasureTheory.AEStronglyMeasurable.integrable_truncation [IsFiniteMeasure Î¼]\n    (hf : AEStronglyMeasurable f Î¼) {A : â„} : Integrable (truncation f A) Î¼ := by\n  rw [â† memâ„’p_one_iff_integrable]; exact hf.memâ„’p_truncation\n\n"}
{"name":"ProbabilityTheory.moment_truncation_eq_intervalIntegral","module":"Mathlib.Probability.StrongLaw","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ Real\nhf : MeasureTheory.AEStronglyMeasurable f Î¼\nA : Real\nhA : LE.le 0 A\nn : Nat\nhn : Ne n 0\nâŠ¢ Eq (MeasureTheory.integral Î¼ fun x => HPow.hPow (ProbabilityTheory.truncation f A x) n) (intervalIntegral (fun y => HPow.hPow y n) (Neg.neg A) A (MeasureTheory.Measure.map f Î¼))","decl":"theorem moment_truncation_eq_intervalIntegral (hf : AEStronglyMeasurable f Î¼) {A : â„} (hA : 0 â‰¤ A)\n    {n : â„•} (hn : n â‰  0) : âˆ« x, truncation f A x ^ n âˆ‚Î¼ = âˆ« y in -A..A, y ^ n âˆ‚Measure.map f Î¼ := by\n  have M : MeasurableSet (Set.Ioc (-A) A) := measurableSet_Ioc\n  change âˆ« x, (fun z => indicator (Set.Ioc (-A) A) id z ^ n) (f x) âˆ‚Î¼ = _\n  rw [â† integral_map (f := fun z => _ ^ n) hf.aemeasurable, intervalIntegral.integral_of_le,\n    â† integral_indicator M]\n  Â· simp only [indicator, zero_pow hn, id, ite_pow]\n  Â· linarith\n  Â· exact ((measurable_id.indicator M).pow_const n).aestronglyMeasurable\n\n"}
{"name":"ProbabilityTheory.moment_truncation_eq_intervalIntegral_of_nonneg","module":"Mathlib.Probability.StrongLaw","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ Real\nhf : MeasureTheory.AEStronglyMeasurable f Î¼\nA : Real\nn : Nat\nhn : Ne n 0\nh'f : LE.le 0 f\nâŠ¢ Eq (MeasureTheory.integral Î¼ fun x => HPow.hPow (ProbabilityTheory.truncation f A x) n) (intervalIntegral (fun y => HPow.hPow y n) 0 A (MeasureTheory.Measure.map f Î¼))","decl":"theorem moment_truncation_eq_intervalIntegral_of_nonneg (hf : AEStronglyMeasurable f Î¼) {A : â„}\n    {n : â„•} (hn : n â‰  0) (h'f : 0 â‰¤ f) :\n    âˆ« x, truncation f A x ^ n âˆ‚Î¼ = âˆ« y in (0)..A, y ^ n âˆ‚Measure.map f Î¼ := by\n  have M : MeasurableSet (Set.Ioc 0 A) := measurableSet_Ioc\n  have M' : MeasurableSet (Set.Ioc A 0) := measurableSet_Ioc\n  rw [truncation_eq_of_nonneg h'f]\n  change âˆ« x, (fun z => indicator (Set.Ioc 0 A) id z ^ n) (f x) âˆ‚Î¼ = _\n  rcases le_or_lt 0 A with (hA | hA)\n  Â· rw [â† integral_map (f := fun z => _ ^ n) hf.aemeasurable, intervalIntegral.integral_of_le hA,\n      â† integral_indicator M]\n    Â· simp only [indicator, zero_pow hn, id, ite_pow]\n    Â· exact ((measurable_id.indicator M).pow_const n).aestronglyMeasurable\n  Â· rw [â† integral_map (f := fun z => _ ^ n) hf.aemeasurable, intervalIntegral.integral_of_ge hA.le,\n      â† integral_indicator M']\n    Â· simp only [Set.Ioc_eq_empty_of_le hA.le, zero_pow hn, Set.indicator_empty, integral_zero,\n        zero_eq_neg]\n      apply integral_eq_zero_of_ae\n      have : âˆ€áµ x âˆ‚Measure.map f Î¼, (0 : â„) â‰¤ x :=\n        (ae_map_iff hf.aemeasurable measurableSet_Ici).2 (Eventually.of_forall h'f)\n      filter_upwards [this] with x hx\n      simp only [indicator, Set.mem_Ioc, Pi.zero_apply, ite_eq_right_iff, and_imp]\n      intro _ h''x\n      have : x = 0 := by linarith\n      simp [this, zero_pow hn]\n    Â· exact ((measurable_id.indicator M).pow_const n).aestronglyMeasurable\n\n"}
{"name":"ProbabilityTheory.integral_truncation_eq_intervalIntegral","module":"Mathlib.Probability.StrongLaw","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ Real\nhf : MeasureTheory.AEStronglyMeasurable f Î¼\nA : Real\nhA : LE.le 0 A\nâŠ¢ Eq (MeasureTheory.integral Î¼ fun x => ProbabilityTheory.truncation f A x) (intervalIntegral (fun y => y) (Neg.neg A) A (MeasureTheory.Measure.map f Î¼))","decl":"theorem integral_truncation_eq_intervalIntegral (hf : AEStronglyMeasurable f Î¼) {A : â„}\n    (hA : 0 â‰¤ A) : âˆ« x, truncation f A x âˆ‚Î¼ = âˆ« y in -A..A, y âˆ‚Measure.map f Î¼ := by\n  simpa using moment_truncation_eq_intervalIntegral hf hA one_ne_zero\n\n"}
{"name":"ProbabilityTheory.integral_truncation_eq_intervalIntegral_of_nonneg","module":"Mathlib.Probability.StrongLaw","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ Real\nhf : MeasureTheory.AEStronglyMeasurable f Î¼\nA : Real\nh'f : LE.le 0 f\nâŠ¢ Eq (MeasureTheory.integral Î¼ fun x => ProbabilityTheory.truncation f A x) (intervalIntegral (fun y => y) 0 A (MeasureTheory.Measure.map f Î¼))","decl":"theorem integral_truncation_eq_intervalIntegral_of_nonneg (hf : AEStronglyMeasurable f Î¼) {A : â„}\n    (h'f : 0 â‰¤ f) : âˆ« x, truncation f A x âˆ‚Î¼ = âˆ« y in (0)..A, y âˆ‚Measure.map f Î¼ := by\n  simpa using moment_truncation_eq_intervalIntegral_of_nonneg hf one_ne_zero h'f\n\n"}
{"name":"ProbabilityTheory.integral_truncation_le_integral_of_nonneg","module":"Mathlib.Probability.StrongLaw","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ Real\nhf : MeasureTheory.Integrable f Î¼\nh'f : LE.le 0 f\nA : Real\nâŠ¢ LE.le (MeasureTheory.integral Î¼ fun x => ProbabilityTheory.truncation f A x) (MeasureTheory.integral Î¼ fun x => f x)","decl":"theorem integral_truncation_le_integral_of_nonneg (hf : Integrable f Î¼) (h'f : 0 â‰¤ f) {A : â„} :\n    âˆ« x, truncation f A x âˆ‚Î¼ â‰¤ âˆ« x, f x âˆ‚Î¼ := by\n  apply integral_mono_of_nonneg\n    (Eventually.of_forall fun x => ?_) hf (Eventually.of_forall fun x => ?_)\n  Â· exact truncation_nonneg _ (h'f x)\n  Â· calc\n      truncation f A x â‰¤ |truncation f A x| := le_abs_self _\n      _ â‰¤ |f x| := abs_truncation_le_abs_self _ _ _\n      _ = f x := abs_of_nonneg (h'f x)\n\n"}
{"name":"ProbabilityTheory.tendsto_integral_truncation","module":"Mathlib.Probability.StrongLaw","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ Real\nhf : MeasureTheory.Integrable f Î¼\nâŠ¢ Filter.Tendsto (fun A => MeasureTheory.integral Î¼ fun x => ProbabilityTheory.truncation f A x) Filter.atTop (nhds (MeasureTheory.integral Î¼ fun x => f x))","decl":"/-- If a function is integrable, then the integral of its truncated versions converges to the\nintegral of the whole function. -/\ntheorem tendsto_integral_truncation {f : Î± â†’ â„} (hf : Integrable f Î¼) :\n    Tendsto (fun A => âˆ« x, truncation f A x âˆ‚Î¼) atTop (ğ“ (âˆ« x, f x âˆ‚Î¼)) := by\n  refine tendsto_integral_filter_of_dominated_convergence (fun x => abs (f x)) ?_ ?_ ?_ ?_\n  Â· exact Eventually.of_forall fun A â†¦ hf.aestronglyMeasurable.truncation\n  Â· filter_upwards with A\n    filter_upwards with x\n    rw [Real.norm_eq_abs]\n    exact abs_truncation_le_abs_self _ _ _\n  Â· exact hf.abs\n  Â· filter_upwards with x\n    apply tendsto_const_nhds.congr' _\n    filter_upwards [Ioi_mem_atTop (abs (f x))] with A hA\n    exact (truncation_eq_self hA).symm\n\n"}
{"name":"ProbabilityTheory.IdentDistrib.truncation","module":"Mathlib.Probability.StrongLaw","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nÎ² : Type u_2\ninstâœ : MeasurableSpace Î²\nÎ½ : MeasureTheory.Measure Î²\nf : Î± â†’ Real\ng : Î² â†’ Real\nh : ProbabilityTheory.IdentDistrib f g Î¼ Î½\nA : Real\nâŠ¢ ProbabilityTheory.IdentDistrib (ProbabilityTheory.truncation f A) (ProbabilityTheory.truncation g A) Î¼ Î½","decl":"theorem IdentDistrib.truncation {Î² : Type*} [MeasurableSpace Î²] {Î½ : Measure Î²} {f : Î± â†’ â„}\n    {g : Î² â†’ â„} (h : IdentDistrib f g Î¼ Î½) {A : â„} :\n    IdentDistrib (truncation f A) (truncation g A) Î¼ Î½ :=\n  h.comp (measurable_id.indicator measurableSet_Ioc)\n\n"}
{"name":"ProbabilityTheory.sum_prob_mem_Ioc_le","module":"Mathlib.Probability.StrongLaw","initialProofState":"Î© : Type u_1\ninstâœÂ¹ : MeasureTheory.MeasureSpace Î©\ninstâœ : MeasureTheory.IsProbabilityMeasure MeasureTheory.MeasureSpace.volume\nX : Î© â†’ Real\nhint : MeasureTheory.Integrable X MeasureTheory.MeasureSpace.volume\nhnonneg : LE.le 0 X\nK N : Nat\nhKN : LE.le K N\nâŠ¢ LE.le ((Finset.range K).sum fun j => MeasureTheory.MeasureSpace.volume (setOf fun Ï‰ => Membership.mem (Set.Ioc â†‘j â†‘N) (X Ï‰))) (ENNReal.ofReal (HAdd.hAdd (MeasureTheory.integral MeasureTheory.MeasureSpace.volume fun a => X a) 1))","decl":"theorem sum_prob_mem_Ioc_le {X : Î© â†’ â„} (hint : Integrable X) (hnonneg : 0 â‰¤ X) {K : â„•} {N : â„•}\n    (hKN : K â‰¤ N) :\n    âˆ‘ j âˆˆ range K, â„™ {Ï‰ | X Ï‰ âˆˆ Set.Ioc (j : â„) N} â‰¤ ENNReal.ofReal (ğ”¼[X] + 1) := by\n  let Ï : Measure â„ := Measure.map X â„™\n  haveI : IsProbabilityMeasure Ï := isProbabilityMeasure_map hint.aemeasurable\n  have A : âˆ‘ j âˆˆ range K, âˆ« _ in j..N, (1 : â„) âˆ‚Ï â‰¤ ğ”¼[X] + 1 :=\n    calc\n      âˆ‘ j âˆˆ range K, âˆ« _ in j..N, (1 : â„) âˆ‚Ï =\n          âˆ‘ j âˆˆ range K, âˆ‘ i âˆˆ Ico j N, âˆ« _ in i..(i + 1 : â„•), (1 : â„) âˆ‚Ï := by\n        apply sum_congr rfl fun j hj => ?_\n        rw [intervalIntegral.sum_integral_adjacent_intervals_Ico ((mem_range.1 hj).le.trans hKN)]\n        intro k _\n        exact continuous_const.intervalIntegrable _ _\n      _ = âˆ‘ i âˆˆ range N, âˆ‘ j âˆˆ range (min (i + 1) K), âˆ« _ in i..(i + 1 : â„•), (1 : â„) âˆ‚Ï := by\n        simp_rw [sum_sigma']\n        refine sum_nbij' (fun p â†¦ âŸ¨p.2, p.1âŸ©) (fun p â†¦ âŸ¨p.2, p.1âŸ©) ?_ ?_ ?_ ?_ ?_ <;>\n          aesop (add simp Nat.lt_succ_iff)\n      _ â‰¤ âˆ‘ i âˆˆ range N, (i + 1) * âˆ« _ in i..(i + 1 : â„•), (1 : â„) âˆ‚Ï := by\n        apply sum_le_sum fun i _ => ?_\n        simp only [Nat.cast_add, Nat.cast_one, sum_const, card_range, nsmul_eq_mul, Nat.cast_min]\n        refine mul_le_mul_of_nonneg_right (min_le_left _ _) ?_\n        apply intervalIntegral.integral_nonneg\n        Â· simp only [le_add_iff_nonneg_right, zero_le_one]\n        Â· simp only [zero_le_one, imp_true_iff]\n      _ â‰¤ âˆ‘ i âˆˆ range N, âˆ« x in i..(i + 1 : â„•), x + 1 âˆ‚Ï := by\n        apply sum_le_sum fun i _ => ?_\n        have I : (i : â„) â‰¤ (i + 1 : â„•) := by\n          simp only [Nat.cast_add, Nat.cast_one, le_add_iff_nonneg_right, zero_le_one]\n        simp_rw [intervalIntegral.integral_of_le I, â† integral_mul_left]\n        apply setIntegral_mono_on\n        Â· exact continuous_const.integrableOn_Ioc\n        Â· exact (continuous_id.add continuous_const).integrableOn_Ioc\n        Â· exact measurableSet_Ioc\n        Â· intro x hx\n          simp only [Nat.cast_add, Nat.cast_one, Set.mem_Ioc] at hx\n          simp [hx.1.le]\n      _ = âˆ« x in (0)..N, x + 1 âˆ‚Ï := by\n        rw [intervalIntegral.sum_integral_adjacent_intervals fun k _ => ?_]\n        Â· norm_cast\n        Â· exact (continuous_id.add continuous_const).intervalIntegrable _ _\n      _ = âˆ« x in (0)..N, x âˆ‚Ï + âˆ« x in (0)..N, 1 âˆ‚Ï := by\n        rw [intervalIntegral.integral_add]\n        Â· exact continuous_id.intervalIntegrable _ _\n        Â· exact continuous_const.intervalIntegrable _ _\n      _ = ğ”¼[truncation X N] + âˆ« x in (0)..N, 1 âˆ‚Ï := by\n        rw [integral_truncation_eq_intervalIntegral_of_nonneg hint.1 hnonneg]\n      _ â‰¤ ğ”¼[X] + âˆ« x in (0)..N, 1 âˆ‚Ï :=\n        (add_le_add_right (integral_truncation_le_integral_of_nonneg hint hnonneg) _)\n      _ â‰¤ ğ”¼[X] + 1 := by\n        refine add_le_add le_rfl ?_\n        rw [intervalIntegral.integral_of_le (Nat.cast_nonneg _)]\n        simp only [integral_const, Measure.restrict_apply', measurableSet_Ioc, Set.univ_inter,\n          Algebra.id.smul_eq_mul, mul_one]\n        rw [â† ENNReal.one_toReal]\n        exact ENNReal.toReal_mono ENNReal.one_ne_top prob_le_one\n  have B : âˆ€ a b, â„™ {Ï‰ | X Ï‰ âˆˆ Set.Ioc a b} = ENNReal.ofReal (âˆ« _ in Set.Ioc a b, (1 : â„) âˆ‚Ï) := by\n    intro a b\n    rw [ofReal_setIntegral_one Ï _,\n      Measure.map_apply_of_aemeasurable hint.aemeasurable measurableSet_Ioc]\n    rfl\n  calc\n    âˆ‘ j âˆˆ range K, â„™ {Ï‰ | X Ï‰ âˆˆ Set.Ioc (j : â„) N} =\n        âˆ‘ j âˆˆ range K, ENNReal.ofReal (âˆ« _ in Set.Ioc (j : â„) N, (1 : â„) âˆ‚Ï) := by simp_rw [B]\n    _ = ENNReal.ofReal (âˆ‘ j âˆˆ range K, âˆ« _ in Set.Ioc (j : â„) N, (1 : â„) âˆ‚Ï) := by\n      rw [ENNReal.ofReal_sum_of_nonneg]\n      simp only [integral_const, Algebra.id.smul_eq_mul, mul_one, ENNReal.toReal_nonneg,\n        imp_true_iff]\n    _ = ENNReal.ofReal (âˆ‘ j âˆˆ range K, âˆ« _ in (j : â„)..N, (1 : â„) âˆ‚Ï) := by\n      congr 1\n      refine sum_congr rfl fun j hj => ?_\n      rw [intervalIntegral.integral_of_le (Nat.cast_le.2 ((mem_range.1 hj).le.trans hKN))]\n    _ â‰¤ ENNReal.ofReal (ğ”¼[X] + 1) := ENNReal.ofReal_le_ofReal A\n\n"}
{"name":"ProbabilityTheory.tsum_prob_mem_Ioi_lt_top","module":"Mathlib.Probability.StrongLaw","initialProofState":"Î© : Type u_1\ninstâœÂ¹ : MeasureTheory.MeasureSpace Î©\ninstâœ : MeasureTheory.IsProbabilityMeasure MeasureTheory.MeasureSpace.volume\nX : Î© â†’ Real\nhint : MeasureTheory.Integrable X MeasureTheory.MeasureSpace.volume\nhnonneg : LE.le 0 X\nâŠ¢ LT.lt (tsum fun j => MeasureTheory.MeasureSpace.volume (setOf fun Ï‰ => Membership.mem (Set.Ioi â†‘j) (X Ï‰))) Top.top","decl":"theorem tsum_prob_mem_Ioi_lt_top {X : Î© â†’ â„} (hint : Integrable X) (hnonneg : 0 â‰¤ X) :\n    (âˆ‘' j : â„•, â„™ {Ï‰ | X Ï‰ âˆˆ Set.Ioi (j : â„)}) < âˆ := by\n  suffices âˆ€ K : â„•, âˆ‘ j âˆˆ range K, â„™ {Ï‰ | X Ï‰ âˆˆ Set.Ioi (j : â„)} â‰¤ ENNReal.ofReal (ğ”¼[X] + 1) from\n    (le_of_tendsto_of_tendsto (ENNReal.tendsto_nat_tsum _) tendsto_const_nhds\n      (Eventually.of_forall this)).trans_lt ENNReal.ofReal_lt_top\n  intro K\n  have A : Tendsto (fun N : â„• => âˆ‘ j âˆˆ range K, â„™ {Ï‰ | X Ï‰ âˆˆ Set.Ioc (j : â„) N}) atTop\n      (ğ“ (âˆ‘ j âˆˆ range K, â„™ {Ï‰ | X Ï‰ âˆˆ Set.Ioi (j : â„)})) := by\n    refine tendsto_finset_sum _ fun i _ => ?_\n    have : {Ï‰ | X Ï‰ âˆˆ Set.Ioi (i : â„)} = â‹ƒ N : â„•, {Ï‰ | X Ï‰ âˆˆ Set.Ioc (i : â„) N} := by\n      apply Set.Subset.antisymm _ _\n      Â· intro Ï‰ hÏ‰\n        obtain âŸ¨N, hNâŸ© : âˆƒ N : â„•, X Ï‰ â‰¤ N := exists_nat_ge (X Ï‰)\n        exact Set.mem_iUnion.2 âŸ¨N, hÏ‰, hNâŸ©\n      Â· simp (config := {contextual := true}) only [Set.mem_Ioc, Set.mem_Ioi,\n          Set.iUnion_subset_iff, Set.setOf_subset_setOf, imp_true_iff]\n    rw [this]\n    apply tendsto_measure_iUnion_atTop\n    intro m n hmn x hx\n    exact âŸ¨hx.1, hx.2.trans (Nat.cast_le.2 hmn)âŸ©\n  apply le_of_tendsto_of_tendsto A tendsto_const_nhds\n  filter_upwards [Ici_mem_atTop K] with N hN\n  exact sum_prob_mem_Ioc_le hint hnonneg hN\n\n"}
{"name":"ProbabilityTheory.sum_variance_truncation_le","module":"Mathlib.Probability.StrongLaw","initialProofState":"Î© : Type u_1\ninstâœÂ¹ : MeasureTheory.MeasureSpace Î©\ninstâœ : MeasureTheory.IsProbabilityMeasure MeasureTheory.MeasureSpace.volume\nX : Î© â†’ Real\nhint : MeasureTheory.Integrable X MeasureTheory.MeasureSpace.volume\nhnonneg : LE.le 0 X\nK : Nat\nâŠ¢ LE.le ((Finset.range K).sum fun j => HMul.hMul (Inv.inv (HPow.hPow (â†‘j) 2)) (MeasureTheory.integral MeasureTheory.MeasureSpace.volume fun a => HPow.hPow (ProbabilityTheory.truncation X â†‘j) 2 a)) (HMul.hMul 2 (MeasureTheory.integral MeasureTheory.MeasureSpace.volume fun a => X a))","decl":"theorem sum_variance_truncation_le {X : Î© â†’ â„} (hint : Integrable X) (hnonneg : 0 â‰¤ X) (K : â„•) :\n    âˆ‘ j âˆˆ range K, ((j : â„) ^ 2)â»Â¹ * ğ”¼[truncation X j ^ 2] â‰¤ 2 * ğ”¼[X] := by\n  set Y := fun n : â„• => truncation X n\n  let Ï : Measure â„ := Measure.map X â„™\n  have Y2 : âˆ€ n, ğ”¼[Y n ^ 2] = âˆ« x in (0)..n, x ^ 2 âˆ‚Ï := by\n    intro n\n    change ğ”¼[fun x => Y n x ^ 2] = _\n    rw [moment_truncation_eq_intervalIntegral_of_nonneg hint.1 two_ne_zero hnonneg]\n  calc\n    âˆ‘ j âˆˆ range K, ((j : â„) ^ 2)â»Â¹ * ğ”¼[Y j ^ 2] =\n        âˆ‘ j âˆˆ range K, ((j : â„) ^ 2)â»Â¹ * âˆ« x in (0)..j, x ^ 2 âˆ‚Ï := by simp_rw [Y2]\n    _ = âˆ‘ j âˆˆ range K, ((j : â„) ^ 2)â»Â¹ * âˆ‘ k âˆˆ range j, âˆ« x in k..(k + 1 : â„•), x ^ 2 âˆ‚Ï := by\n      congr 1 with j\n      congr 1\n      rw [intervalIntegral.sum_integral_adjacent_intervals]\n      Â· norm_cast\n      intro k _\n      exact (continuous_id.pow _).intervalIntegrable _ _\n    _ = âˆ‘ k âˆˆ range K, (âˆ‘ j âˆˆ Ioo k K, ((j : â„) ^ 2)â»Â¹) * âˆ« x in k..(k + 1 : â„•), x ^ 2 âˆ‚Ï := by\n      simp_rw [mul_sum, sum_mul, sum_sigma']\n      refine sum_nbij' (fun p â†¦ âŸ¨p.2, p.1âŸ©) (fun p â†¦ âŸ¨p.2, p.1âŸ©) ?_ ?_ ?_ ?_ ?_ <;>\n        aesop (add unsafe lt_trans)\n    _ â‰¤ âˆ‘ k âˆˆ range K, 2 / (k + 1 : â„) * âˆ« x in k..(k + 1 : â„•), x ^ 2 âˆ‚Ï := by\n      apply sum_le_sum fun k _ => ?_\n      refine mul_le_mul_of_nonneg_right (sum_Ioo_inv_sq_le _ _) ?_\n      refine intervalIntegral.integral_nonneg_of_forall ?_ fun u => sq_nonneg _\n      simp only [Nat.cast_add, Nat.cast_one, le_add_iff_nonneg_right, zero_le_one]\n    _ â‰¤ âˆ‘ k âˆˆ range K, âˆ« x in k..(k + 1 : â„•), 2 * x âˆ‚Ï := by\n      apply sum_le_sum fun k _ => ?_\n      have Ik : (k : â„) â‰¤ (k + 1 : â„•) := by simp\n      rw [â† intervalIntegral.integral_const_mul, intervalIntegral.integral_of_le Ik,\n        intervalIntegral.integral_of_le Ik]\n      refine setIntegral_mono_on ?_ ?_ measurableSet_Ioc fun x hx => ?_\n      Â· apply Continuous.integrableOn_Ioc\n        exact continuous_const.mul (continuous_pow 2)\n      Â· apply Continuous.integrableOn_Ioc\n        exact continuous_const.mul continuous_id'\n      Â· calc\n          â†‘2 / (â†‘k + â†‘1) * x ^ 2 = x / (k + 1) * (2 * x) := by ring\n          _ â‰¤ 1 * (2 * x) :=\n            (mul_le_mul_of_nonneg_right (by\n              convert (div_le_one _).2 hx.2\n              Â· norm_cast\n              simp only [Nat.cast_add, Nat.cast_one]\n              linarith only [show (0 : â„) â‰¤ k from Nat.cast_nonneg k])\n              (mul_nonneg zero_le_two ((Nat.cast_nonneg k).trans hx.1.le)))\n          _ = 2 * x := by rw [one_mul]\n    _ = 2 * âˆ« x in (0 : â„)..K, x âˆ‚Ï := by\n      rw [intervalIntegral.sum_integral_adjacent_intervals fun k _ => ?_]\n      swap; Â· exact (continuous_const.mul continuous_id').intervalIntegrable _ _\n      rw [intervalIntegral.integral_const_mul]\n      norm_cast\n    _ â‰¤ 2 * ğ”¼[X] := mul_le_mul_of_nonneg_left (by\n      rw [â† integral_truncation_eq_intervalIntegral_of_nonneg hint.1 hnonneg]\n      exact integral_truncation_le_integral_of_nonneg hint hnonneg) zero_le_two\n\n"}
{"name":"ProbabilityTheory.strong_law_aux1","module":"Mathlib.Probability.StrongLaw","initialProofState":"Î© : Type u_1\ninstâœÂ¹ : MeasureTheory.MeasureSpace Î©\ninstâœ : MeasureTheory.IsProbabilityMeasure MeasureTheory.MeasureSpace.volume\nX : Nat â†’ Î© â†’ Real\nhint : MeasureTheory.Integrable (X 0) MeasureTheory.MeasureSpace.volume\nhindep : Pairwise (Function.onFun (fun f g => ProbabilityTheory.IndepFun f g MeasureTheory.MeasureSpace.volume) X)\nhident : âˆ€ (i : Nat), ProbabilityTheory.IdentDistrib (X i) (X 0) MeasureTheory.MeasureSpace.volume MeasureTheory.MeasureSpace.volume\nhnonneg : âˆ€ (i : Nat) (Ï‰ : Î©), LE.le 0 (X i Ï‰)\nc : Real\nc_one : LT.lt 1 c\nÎµ : Real\nÎµpos : LT.lt 0 Îµ\nâŠ¢ Filter.Eventually (fun Ï‰ => Filter.Eventually (fun n => LT.lt (abs (HSub.hSub ((Finset.range (Nat.floor (HPow.hPow c n))).sum fun i => ProbabilityTheory.truncation (X i) (â†‘i) Ï‰) (MeasureTheory.integral MeasureTheory.MeasureSpace.volume fun a => (Finset.range (Nat.floor (HPow.hPow c n))).sum (fun i => ProbabilityTheory.truncation (X i) â†‘i) a))) (HMul.hMul Îµ â†‘(Nat.floor (HPow.hPow c n)))) Filter.atTop) (MeasureTheory.ae MeasureTheory.MeasureSpace.volume)","decl":"include hint hindep hident hnonneg in\n/-- The truncation of `Xáµ¢` up to `i` satisfies the strong law of large numbers (with respect to\nthe truncated expectation) along the sequence `c^n`, for any `c > 1`, up to a given `Îµ > 0`.\nThis follows from a variance control. -/\ntheorem strong_law_aux1 {c : â„} (c_one : 1 < c) {Îµ : â„} (Îµpos : 0 < Îµ) : âˆ€áµ Ï‰, âˆ€á¶  n : â„• in atTop,\n    |âˆ‘ i âˆˆ range âŒŠc ^ nâŒ‹â‚Š, truncation (X i) i Ï‰ - ğ”¼[âˆ‘ i âˆˆ range âŒŠc ^ nâŒ‹â‚Š, truncation (X i) i]| <\n    Îµ * âŒŠc ^ nâŒ‹â‚Š := by\n  /- Let `S n = âˆ‘ i âˆˆ range n, Y i` where `Y i = truncation (X i) i`. We should show that\n    `|S k - ğ”¼[S k]| / k â‰¤ Îµ` along the sequence of powers of `c`. For this, we apply Borel-Cantelli:\n    it suffices to show that the converse probabilities are summable. From Chebyshev inequality,\n    this will follow from a variance control `âˆ‘' Var[S (c^i)] / (c^i)^2 < âˆ`. This is checked in\n    `I2` using pairwise independence to expand the variance of the sum as the sum of the variances,\n    and then a straightforward but tedious computation (essentially boiling down to the fact that\n    the sum of `1/(c ^ i)^2` beyond a threshold `j` is comparable to `1/j^2`).\n    Note that we have written `c^i` in the above proof sketch, but rigorously one should put integer\n    parts everywhere, making things more painful. We write `u i = âŒŠc^iâŒ‹â‚Š` for brevity. -/\n  have c_pos : 0 < c := zero_lt_one.trans c_one\n  have hX : âˆ€ i, AEStronglyMeasurable (X i) â„™ := fun i =>\n    (hident i).symm.aestronglyMeasurable_snd hint.1\n  have A : âˆ€ i, StronglyMeasurable (indicator (Set.Ioc (-i : â„) i) id) := fun i =>\n    stronglyMeasurable_id.indicator measurableSet_Ioc\n  set Y := fun n : â„• => truncation (X n) n\n  set S := fun n => âˆ‘ i âˆˆ range n, Y i with hS\n  let u : â„• â†’ â„• := fun n => âŒŠc ^ nâŒ‹â‚Š\n  have u_mono : Monotone u := fun i j hij => Nat.floor_mono (pow_right_monoâ‚€ c_one.le hij)\n  have I1 : âˆ€ K, âˆ‘ j âˆˆ range K, ((j : â„) ^ 2)â»Â¹ * Var[Y j] â‰¤ 2 * ğ”¼[X 0] := by\n    intro K\n    calc\n      âˆ‘ j âˆˆ range K, ((j : â„) ^ 2)â»Â¹ * Var[Y j] â‰¤\n          âˆ‘ j âˆˆ range K, ((j : â„) ^ 2)â»Â¹ * ğ”¼[truncation (X 0) j ^ 2] := by\n        apply sum_le_sum fun j _ => ?_\n        refine mul_le_mul_of_nonneg_left ?_ (inv_nonneg.2 (sq_nonneg _))\n        rw [(hident j).truncation.variance_eq]\n        exact variance_le_expectation_sq (hX 0).truncation\n      _ â‰¤ 2 * ğ”¼[X 0] := sum_variance_truncation_le hint (hnonneg 0) K\n  let C := c ^ 5 * (c - 1)â»Â¹ ^ 3 * (2 * ğ”¼[X 0])\n  have I2 : âˆ€ N, âˆ‘ i âˆˆ range N, ((u i : â„) ^ 2)â»Â¹ * Var[S (u i)] â‰¤ C := by\n    intro N\n    calc\n      âˆ‘ i âˆˆ range N, ((u i : â„) ^ 2)â»Â¹ * Var[S (u i)] =\n          âˆ‘ i âˆˆ range N, ((u i : â„) ^ 2)â»Â¹ * âˆ‘ j âˆˆ range (u i), Var[Y j] := by\n        congr 1 with i\n        congr 1\n        rw [hS, IndepFun.variance_sum]\n        Â· intro j _\n          exact (hident j).aestronglyMeasurable_fst.memâ„’p_truncation\n        Â· intro k _ l _ hkl\n          exact (hindep hkl).comp (A k).measurable (A l).measurable\n      _ = âˆ‘ j âˆˆ range (u (N - 1)), (âˆ‘ i âˆˆ range N with j < u i, ((u i : â„) ^ 2)â»Â¹) * Var[Y j] := by\n        simp_rw [mul_sum, sum_mul, sum_sigma']\n        refine sum_nbij' (fun p â†¦ âŸ¨p.2, p.1âŸ©) (fun p â†¦ âŸ¨p.2, p.1âŸ©) ?_ ?_ ?_ ?_ ?_\n        Â· simp only [mem_sigma, mem_range, filter_congr_decidable, mem_filter, and_imp,\n            Sigma.forall]\n          exact fun a b haN hb â†¦ âŸ¨hb.trans_le <| u_mono <| Nat.le_pred_of_lt haN, haN, hbâŸ©\n        all_goals simp\n      _ â‰¤ âˆ‘ j âˆˆ range (u (N - 1)), c ^ 5 * (c - 1)â»Â¹ ^ 3 / â†‘j ^ 2 * Var[Y j] := by\n        apply sum_le_sum fun j hj => ?_\n        rcases eq_zero_or_pos j with (rfl | hj)\n        Â· simp only [Nat.cast_zero, zero_pow, Ne, Nat.one_ne_zero,\n            not_false_iff, div_zero, zero_mul]\n          simp only [Y, Nat.cast_zero, truncation_zero, variance_zero, mul_zero, le_rfl]\n        apply mul_le_mul_of_nonneg_right _ (variance_nonneg _ _)\n        convert sum_div_nat_floor_pow_sq_le_div_sq N (Nat.cast_pos.2 hj) c_one using 2\n        Â· simp only [u, Nat.cast_lt]\n        Â· simp only [Y, S, u, C, one_div]\n      _ = c ^ 5 * (c - 1)â»Â¹ ^ 3 * âˆ‘ j âˆˆ range (u (N - 1)), ((j : â„) ^ 2)â»Â¹ * Var[Y j] := by\n        simp_rw [mul_sum, div_eq_mul_inv, mul_assoc]\n      _ â‰¤ c ^ 5 * (c - 1)â»Â¹ ^ 3 * (2 * ğ”¼[X 0]) := by\n        apply mul_le_mul_of_nonneg_left (I1 _)\n        apply mul_nonneg (pow_nonneg c_pos.le _)\n        exact pow_nonneg (inv_nonneg.2 (sub_nonneg.2 c_one.le)) _\n  have I3 : âˆ€ N, âˆ‘ i âˆˆ range N, â„™ {Ï‰ | (u i * Îµ : â„) â‰¤ |S (u i) Ï‰ - ğ”¼[S (u i)]|} â‰¤\n      ENNReal.ofReal (Îµâ»Â¹ ^ 2 * C) := by\n    intro N\n    calc\n      âˆ‘ i âˆˆ range N, â„™ {Ï‰ | (u i * Îµ : â„) â‰¤ |S (u i) Ï‰ - ğ”¼[S (u i)]|} â‰¤\n          âˆ‘ i âˆˆ range N, ENNReal.ofReal (Var[S (u i)] / (u i * Îµ) ^ 2) := by\n        refine sum_le_sum fun i _ => ?_\n        apply meas_ge_le_variance_div_sq\n        Â· exact memâ„’p_finset_sum' _ fun j _ => (hident j).aestronglyMeasurable_fst.memâ„’p_truncation\n        Â· apply mul_pos (Nat.cast_pos.2 _) Îµpos\n          refine zero_lt_one.trans_le ?_\n          apply Nat.le_floor\n          rw [Nat.cast_one]\n          apply one_le_powâ‚€ c_one.le\n      _ = ENNReal.ofReal (âˆ‘ i âˆˆ range N, Var[S (u i)] / (u i * Îµ) ^ 2) := by\n        rw [ENNReal.ofReal_sum_of_nonneg fun i _ => ?_]\n        exact div_nonneg (variance_nonneg _ _) (sq_nonneg _)\n      _ â‰¤ ENNReal.ofReal (Îµâ»Â¹ ^ 2 * C) := by\n        apply ENNReal.ofReal_le_ofReal\n        -- Porting note: do most of the rewrites under `conv` so as not to expand `variance`\n        conv_lhs =>\n          enter [2, i]\n          rw [div_eq_inv_mul, â† inv_pow, mul_inv, mul_comm _ Îµâ»Â¹, mul_pow, mul_assoc]\n        rw [â† mul_sum]\n        refine mul_le_mul_of_nonneg_left ?_ (sq_nonneg _)\n        conv_lhs => enter [2, i]; rw [inv_pow]\n        exact I2 N\n  have I4 : (âˆ‘' i, â„™ {Ï‰ | (u i * Îµ : â„) â‰¤ |S (u i) Ï‰ - ğ”¼[S (u i)]|}) < âˆ :=\n    (le_of_tendsto_of_tendsto' (ENNReal.tendsto_nat_tsum _) tendsto_const_nhds I3).trans_lt\n      ENNReal.ofReal_lt_top\n  filter_upwards [ae_eventually_not_mem I4.ne] with Ï‰ hÏ‰\n  simp_rw [S, not_le, mul_comm, sum_apply] at hÏ‰\n  convert hÏ‰; simp only [Y, S, u, C, sum_apply]\n\n"}
{"name":"ProbabilityTheory.strong_law_aux2","module":"Mathlib.Probability.StrongLaw","initialProofState":"Î© : Type u_1\ninstâœÂ¹ : MeasureTheory.MeasureSpace Î©\ninstâœ : MeasureTheory.IsProbabilityMeasure MeasureTheory.MeasureSpace.volume\nX : Nat â†’ Î© â†’ Real\nhint : MeasureTheory.Integrable (X 0) MeasureTheory.MeasureSpace.volume\nhindep : Pairwise (Function.onFun (fun f g => ProbabilityTheory.IndepFun f g MeasureTheory.MeasureSpace.volume) X)\nhident : âˆ€ (i : Nat), ProbabilityTheory.IdentDistrib (X i) (X 0) MeasureTheory.MeasureSpace.volume MeasureTheory.MeasureSpace.volume\nhnonneg : âˆ€ (i : Nat) (Ï‰ : Î©), LE.le 0 (X i Ï‰)\nc : Real\nc_one : LT.lt 1 c\nâŠ¢ Filter.Eventually (fun Ï‰ => Asymptotics.IsLittleO Filter.atTop (fun n => HSub.hSub ((Finset.range (Nat.floor (HPow.hPow c n))).sum fun i => ProbabilityTheory.truncation (X i) (â†‘i) Ï‰) (MeasureTheory.integral MeasureTheory.MeasureSpace.volume fun a => (Finset.range (Nat.floor (HPow.hPow c n))).sum (fun i => ProbabilityTheory.truncation (X i) â†‘i) a)) fun n => â†‘(Nat.floor (HPow.hPow c n))) (MeasureTheory.ae MeasureTheory.MeasureSpace.volume)","decl":"include hint hindep hident hnonneg in\n/- The truncation of `Xáµ¢` up to `i` satisfies the strong law of large numbers\n(with respect to the truncated expectation) along the sequence\n`c^n`, for any `c > 1`. This follows from `strong_law_aux1` by varying `Îµ`. -/\ntheorem strong_law_aux2 {c : â„} (c_one : 1 < c) :\n    âˆ€áµ Ï‰, (fun n : â„• => âˆ‘ i âˆˆ range âŒŠc ^ nâŒ‹â‚Š, truncation (X i) i Ï‰ -\n      ğ”¼[âˆ‘ i âˆˆ range âŒŠc ^ nâŒ‹â‚Š, truncation (X i) i]) =o[atTop] fun n : â„• => (âŒŠc ^ nâŒ‹â‚Š : â„) := by\n  obtain âŸ¨v, -, v_pos, v_limâŸ© :\n      âˆƒ v : â„• â†’ â„, StrictAnti v âˆ§ (âˆ€ n : â„•, 0 < v n) âˆ§ Tendsto v atTop (ğ“ 0) :=\n    exists_seq_strictAnti_tendsto (0 : â„)\n  have := fun i => strong_law_aux1 X hint hindep hident hnonneg c_one (v_pos i)\n  filter_upwards [ae_all_iff.2 this] with Ï‰ hÏ‰\n  apply Asymptotics.isLittleO_iff.2 fun Îµ Îµpos => ?_\n  obtain âŸ¨i, hiâŸ© : âˆƒ i, v i < Îµ := ((tendsto_order.1 v_lim).2 Îµ Îµpos).exists\n  filter_upwards [hÏ‰ i] with n hn\n  simp only [Real.norm_eq_abs, abs_abs, Nat.abs_cast]\n  exact hn.le.trans (mul_le_mul_of_nonneg_right hi.le (Nat.cast_nonneg _))\n\n"}
{"name":"ProbabilityTheory.strong_law_aux3","module":"Mathlib.Probability.StrongLaw","initialProofState":"Î© : Type u_1\ninstâœÂ¹ : MeasureTheory.MeasureSpace Î©\ninstâœ : MeasureTheory.IsProbabilityMeasure MeasureTheory.MeasureSpace.volume\nX : Nat â†’ Î© â†’ Real\nhint : MeasureTheory.Integrable (X 0) MeasureTheory.MeasureSpace.volume\nhident : âˆ€ (i : Nat), ProbabilityTheory.IdentDistrib (X i) (X 0) MeasureTheory.MeasureSpace.volume MeasureTheory.MeasureSpace.volume\nâŠ¢ Asymptotics.IsLittleO Filter.atTop (fun n => HSub.hSub (MeasureTheory.integral MeasureTheory.MeasureSpace.volume fun a => (Finset.range n).sum (fun i => ProbabilityTheory.truncation (X i) â†‘i) a) (HMul.hMul (â†‘n) (MeasureTheory.integral MeasureTheory.MeasureSpace.volume fun a => X 0 a))) Nat.cast","decl":"include hint hident in\n/-- The expectation of the truncated version of `Xáµ¢` behaves asymptotically like the whole\nexpectation. This follows from convergence and CesÃ ro averaging. -/\ntheorem strong_law_aux3 :\n    (fun n => ğ”¼[âˆ‘ i âˆˆ range n, truncation (X i) i] - n * ğ”¼[X 0]) =o[atTop] ((â†‘) : â„• â†’ â„) := by\n  have A : Tendsto (fun i => ğ”¼[truncation (X i) i]) atTop (ğ“ ğ”¼[X 0]) := by\n    convert (tendsto_integral_truncation hint).comp tendsto_natCast_atTop_atTop using 1\n    ext i\n    exact (hident i).truncation.integral_eq\n  convert Asymptotics.isLittleO_sum_range_of_tendsto_zero (tendsto_sub_nhds_zero_iff.2 A) using 1\n  ext1 n\n  simp only [sum_sub_distrib, sum_const, card_range, nsmul_eq_mul, sum_apply, sub_left_inj]\n  rw [integral_finset_sum _ fun i _ => ?_]\n  exact ((hident i).symm.integrable_snd hint).1.integrable_truncation\n\n"}
{"name":"ProbabilityTheory.strong_law_aux4","module":"Mathlib.Probability.StrongLaw","initialProofState":"Î© : Type u_1\ninstâœÂ¹ : MeasureTheory.MeasureSpace Î©\ninstâœ : MeasureTheory.IsProbabilityMeasure MeasureTheory.MeasureSpace.volume\nX : Nat â†’ Î© â†’ Real\nhint : MeasureTheory.Integrable (X 0) MeasureTheory.MeasureSpace.volume\nhindep : Pairwise (Function.onFun (fun f g => ProbabilityTheory.IndepFun f g MeasureTheory.MeasureSpace.volume) X)\nhident : âˆ€ (i : Nat), ProbabilityTheory.IdentDistrib (X i) (X 0) MeasureTheory.MeasureSpace.volume MeasureTheory.MeasureSpace.volume\nhnonneg : âˆ€ (i : Nat) (Ï‰ : Î©), LE.le 0 (X i Ï‰)\nc : Real\nc_one : LT.lt 1 c\nâŠ¢ Filter.Eventually (fun Ï‰ => Asymptotics.IsLittleO Filter.atTop (fun n => HSub.hSub ((Finset.range (Nat.floor (HPow.hPow c n))).sum fun i => ProbabilityTheory.truncation (X i) (â†‘i) Ï‰) (HMul.hMul (â†‘(Nat.floor (HPow.hPow c n))) (MeasureTheory.integral MeasureTheory.MeasureSpace.volume fun a => X 0 a))) fun n => â†‘(Nat.floor (HPow.hPow c n))) (MeasureTheory.ae MeasureTheory.MeasureSpace.volume)","decl":"include hint hindep hident hnonneg in\n/- The truncation of `Xáµ¢` up to `i` satisfies the strong law of large numbers\n(with respect to the original expectation) along the sequence\n`c^n`, for any `c > 1`. This follows from the version from the truncated expectation, and the\nfact that the truncated and the original expectations have the same asymptotic behavior. -/\ntheorem strong_law_aux4 {c : â„} (c_one : 1 < c) :\n    âˆ€áµ Ï‰, (fun n : â„• => âˆ‘ i âˆˆ range âŒŠc ^ nâŒ‹â‚Š, truncation (X i) i Ï‰ - âŒŠc ^ nâŒ‹â‚Š * ğ”¼[X 0]) =o[atTop]\n    fun n : â„• => (âŒŠc ^ nâŒ‹â‚Š : â„) := by\n  filter_upwards [strong_law_aux2 X hint hindep hident hnonneg c_one] with Ï‰ hÏ‰\n  have A : Tendsto (fun n : â„• => âŒŠc ^ nâŒ‹â‚Š) atTop atTop :=\n    tendsto_nat_floor_atTop.comp (tendsto_pow_atTop_atTop_of_one_lt c_one)\n  convert hÏ‰.add ((strong_law_aux3 X hint hident).comp_tendsto A) using 1\n  ext1 n\n  simp\n\n"}
{"name":"ProbabilityTheory.strong_law_aux5","module":"Mathlib.Probability.StrongLaw","initialProofState":"Î© : Type u_1\ninstâœÂ¹ : MeasureTheory.MeasureSpace Î©\ninstâœ : MeasureTheory.IsProbabilityMeasure MeasureTheory.MeasureSpace.volume\nX : Nat â†’ Î© â†’ Real\nhint : MeasureTheory.Integrable (X 0) MeasureTheory.MeasureSpace.volume\nhident : âˆ€ (i : Nat), ProbabilityTheory.IdentDistrib (X i) (X 0) MeasureTheory.MeasureSpace.volume MeasureTheory.MeasureSpace.volume\nhnonneg : âˆ€ (i : Nat) (Ï‰ : Î©), LE.le 0 (X i Ï‰)\nâŠ¢ Filter.Eventually (fun Ï‰ => Asymptotics.IsLittleO Filter.atTop (fun n => HSub.hSub ((Finset.range n).sum fun i => ProbabilityTheory.truncation (X i) (â†‘i) Ï‰) ((Finset.range n).sum fun i => X i Ï‰)) fun n => â†‘n) (MeasureTheory.ae MeasureTheory.MeasureSpace.volume)","decl":"include hint hident hnonneg in\n/-- The truncated and non-truncated versions of `Xáµ¢` have the same asymptotic behavior, as they\nalmost surely coincide at all but finitely many steps. This follows from a probability computation\nand Borel-Cantelli. -/\ntheorem strong_law_aux5 :\n    âˆ€áµ Ï‰, (fun n : â„• => âˆ‘ i âˆˆ range n, truncation (X i) i Ï‰ - âˆ‘ i âˆˆ range n, X i Ï‰) =o[atTop]\n    fun n : â„• => (n : â„) := by\n  have A : (âˆ‘' j : â„•, â„™ {Ï‰ | X j Ï‰ âˆˆ Set.Ioi (j : â„)}) < âˆ := by\n    convert tsum_prob_mem_Ioi_lt_top hint (hnonneg 0) using 2\n    ext1 j\n    exact (hident j).measure_mem_eq measurableSet_Ioi\n  have B : âˆ€áµ Ï‰, Tendsto (fun n : â„• => truncation (X n) n Ï‰ - X n Ï‰) atTop (ğ“ 0) := by\n    filter_upwards [ae_eventually_not_mem A.ne] with Ï‰ hÏ‰\n    apply tendsto_const_nhds.congr' _\n    filter_upwards [hÏ‰, Ioi_mem_atTop 0] with n hn npos\n    simp only [truncation, indicator, Set.mem_Ioc, id, Function.comp_apply]\n    split_ifs with h\n    Â· exact (sub_self _).symm\n    Â· have : -(n : â„) < X n Ï‰ := by\n        apply lt_of_lt_of_le _ (hnonneg n Ï‰)\n        simpa only [Right.neg_neg_iff, Nat.cast_pos] using npos\n      simp only [this, true_and, not_le] at h\n      exact (hn h).elim\n  filter_upwards [B] with Ï‰ hÏ‰\n  convert isLittleO_sum_range_of_tendsto_zero hÏ‰ using 1\n  ext n\n  rw [sum_sub_distrib]\n\n"}
{"name":"ProbabilityTheory.strong_law_aux6","module":"Mathlib.Probability.StrongLaw","initialProofState":"Î© : Type u_1\ninstâœÂ¹ : MeasureTheory.MeasureSpace Î©\ninstâœ : MeasureTheory.IsProbabilityMeasure MeasureTheory.MeasureSpace.volume\nX : Nat â†’ Î© â†’ Real\nhint : MeasureTheory.Integrable (X 0) MeasureTheory.MeasureSpace.volume\nhindep : Pairwise (Function.onFun (fun f g => ProbabilityTheory.IndepFun f g MeasureTheory.MeasureSpace.volume) X)\nhident : âˆ€ (i : Nat), ProbabilityTheory.IdentDistrib (X i) (X 0) MeasureTheory.MeasureSpace.volume MeasureTheory.MeasureSpace.volume\nhnonneg : âˆ€ (i : Nat) (Ï‰ : Î©), LE.le 0 (X i Ï‰)\nc : Real\nc_one : LT.lt 1 c\nâŠ¢ Filter.Eventually (fun Ï‰ => Filter.Tendsto (fun n => HDiv.hDiv ((Finset.range (Nat.floor (HPow.hPow c n))).sum fun i => X i Ï‰) â†‘(Nat.floor (HPow.hPow c n))) Filter.atTop (nhds (MeasureTheory.integral MeasureTheory.MeasureSpace.volume fun a => X 0 a))) (MeasureTheory.ae MeasureTheory.MeasureSpace.volume)","decl":"include hint hindep hident hnonneg in\n/- `Xáµ¢` satisfies the strong law of large numbers along the sequence\n`c^n`, for any `c > 1`. This follows from the version for the truncated `Xáµ¢`, and the fact that\n`Xáµ¢` and its truncated version have the same asymptotic behavior. -/\ntheorem strong_law_aux6 {c : â„} (c_one : 1 < c) :\n    âˆ€áµ Ï‰, Tendsto (fun n : â„• => (âˆ‘ i âˆˆ range âŒŠc ^ nâŒ‹â‚Š, X i Ï‰) / âŒŠc ^ nâŒ‹â‚Š) atTop (ğ“ ğ”¼[X 0]) := by\n  have H : âˆ€ n : â„•, (0 : â„) < âŒŠc ^ nâŒ‹â‚Š := by\n    intro n\n    refine zero_lt_one.trans_le ?_\n    simp only [Nat.one_le_cast, Nat.one_le_floor_iff, one_le_powâ‚€ c_one.le]\n  filter_upwards [strong_law_aux4 X hint hindep hident hnonneg c_one,\n    strong_law_aux5 X hint hident hnonneg] with Ï‰ hÏ‰ h'Ï‰\n  rw [â† tendsto_sub_nhds_zero_iff, â† Asymptotics.isLittleO_one_iff â„]\n  have L : (fun n : â„• => âˆ‘ i âˆˆ range âŒŠc ^ nâŒ‹â‚Š, X i Ï‰ - âŒŠc ^ nâŒ‹â‚Š * ğ”¼[X 0]) =o[atTop] fun n =>\n      (âŒŠc ^ nâŒ‹â‚Š : â„) := by\n    have A : Tendsto (fun n : â„• => âŒŠc ^ nâŒ‹â‚Š) atTop atTop :=\n      tendsto_nat_floor_atTop.comp (tendsto_pow_atTop_atTop_of_one_lt c_one)\n    convert hÏ‰.sub (h'Ï‰.comp_tendsto A) using 1\n    ext1 n\n    simp only [Function.comp_apply, sub_sub_sub_cancel_left]\n  convert L.mul_isBigO (isBigO_refl (fun n : â„• => (âŒŠc ^ nâŒ‹â‚Š : â„)â»Â¹) atTop) using 1 <;>\n  (ext1 n; field_simp [(H n).ne'])\n\n"}
{"name":"ProbabilityTheory.strong_law_aux7","module":"Mathlib.Probability.StrongLaw","initialProofState":"Î© : Type u_1\ninstâœÂ¹ : MeasureTheory.MeasureSpace Î©\ninstâœ : MeasureTheory.IsProbabilityMeasure MeasureTheory.MeasureSpace.volume\nX : Nat â†’ Î© â†’ Real\nhint : MeasureTheory.Integrable (X 0) MeasureTheory.MeasureSpace.volume\nhindep : Pairwise (Function.onFun (fun f g => ProbabilityTheory.IndepFun f g MeasureTheory.MeasureSpace.volume) X)\nhident : âˆ€ (i : Nat), ProbabilityTheory.IdentDistrib (X i) (X 0) MeasureTheory.MeasureSpace.volume MeasureTheory.MeasureSpace.volume\nhnonneg : âˆ€ (i : Nat) (Ï‰ : Î©), LE.le 0 (X i Ï‰)\nâŠ¢ Filter.Eventually (fun Ï‰ => Filter.Tendsto (fun n => HDiv.hDiv ((Finset.range n).sum fun i => X i Ï‰) â†‘n) Filter.atTop (nhds (MeasureTheory.integral MeasureTheory.MeasureSpace.volume fun a => X 0 a))) (MeasureTheory.ae MeasureTheory.MeasureSpace.volume)","decl":"include hint hindep hident hnonneg in\n/-- `Xáµ¢` satisfies the strong law of large numbers along all integers. This follows from the\ncorresponding fact along the sequences `c^n`, and the fact that any integer can be sandwiched\nbetween `c^n` and `c^(n+1)` with comparably small error if `c` is close enough to `1`\n(which is formalized in `tendsto_div_of_monotone_of_tendsto_div_floor_pow`). -/\ntheorem strong_law_aux7 :\n    âˆ€áµ Ï‰, Tendsto (fun n : â„• => (âˆ‘ i âˆˆ range n, X i Ï‰) / n) atTop (ğ“ ğ”¼[X 0]) := by\n  obtain âŸ¨c, -, cone, climâŸ© :\n      âˆƒ c : â„• â†’ â„, StrictAnti c âˆ§ (âˆ€ n : â„•, 1 < c n) âˆ§ Tendsto c atTop (ğ“ 1) :=\n    exists_seq_strictAnti_tendsto (1 : â„)\n  have : âˆ€ k, âˆ€áµ Ï‰,\n      Tendsto (fun n : â„• => (âˆ‘ i âˆˆ range âŒŠc k ^ nâŒ‹â‚Š, X i Ï‰) / âŒŠc k ^ nâŒ‹â‚Š) atTop (ğ“ ğ”¼[X 0]) :=\n    fun k => strong_law_aux6 X hint hindep hident hnonneg (cone k)\n  filter_upwards [ae_all_iff.2 this] with Ï‰ hÏ‰\n  apply tendsto_div_of_monotone_of_tendsto_div_floor_pow _ _ _ c cone clim _\n  Â· intro m n hmn\n    exact sum_le_sum_of_subset_of_nonneg (range_mono hmn) fun i _ _ => hnonneg i Ï‰\n  Â· exact hÏ‰\n\n"}
{"name":"ProbabilityTheory.strong_law_ae_real","module":"Mathlib.Probability.StrongLaw","initialProofState":"Î© : Type u_2\nm : MeasurableSpace Î©\nÎ¼ : MeasureTheory.Measure Î©\nX : Nat â†’ Î© â†’ Real\nhint : MeasureTheory.Integrable (X 0) Î¼\nhindep : Pairwise (Function.onFun (fun x1 x2 => ProbabilityTheory.IndepFun x1 x2 Î¼) X)\nhident : âˆ€ (i : Nat), ProbabilityTheory.IdentDistrib (X i) (X 0) Î¼ Î¼\nâŠ¢ Filter.Eventually (fun Ï‰ => Filter.Tendsto (fun n => HDiv.hDiv ((Finset.range n).sum fun i => X i Ï‰) â†‘n) Filter.atTop (nhds (MeasureTheory.integral Î¼ fun x => X 0 x))) (MeasureTheory.ae Î¼)","decl":"/-- **Strong law of large numbers**, almost sure version: if `X n` is a sequence of independent\nidentically distributed integrable real-valued random variables, then `âˆ‘ i âˆˆ range n, X i / n`\nconverges almost surely to `ğ”¼[X 0]`. We give here the strong version, due to Etemadi, that only\nrequires pairwise independence. Superseded by `strong_law_ae`, which works for random variables\ntaking values in any Banach space. -/\ntheorem strong_law_ae_real {Î© : Type*} {m : MeasurableSpace Î©} {Î¼ : Measure Î©}\n    (X : â„• â†’ Î© â†’ â„) (hint : Integrable (X 0) Î¼)\n    (hindep : Pairwise ((IndepFun Â· Â· Î¼) on X))\n    (hident : âˆ€ i, IdentDistrib (X i) (X 0) Î¼ Î¼) :\n    âˆ€áµ Ï‰ âˆ‚Î¼, Tendsto (fun n : â„• => (âˆ‘ i âˆˆ range n, X i Ï‰) / n) atTop (ğ“ Î¼[X 0]) := by\n  let mÎ© : MeasureSpace Î© := âŸ¨Î¼âŸ©\n  -- first get rid of the trivial case where the space is not a probability space\n  by_cases h : âˆ€áµ Ï‰, X 0 Ï‰ = 0\n  Â· have I : âˆ€áµ Ï‰, âˆ€ i, X i Ï‰ = 0 := by\n      rw [ae_all_iff]\n      intro i\n      exact (hident i).symm.ae_snd (p := fun x â†¦ x = 0) measurableSet_eq h\n    filter_upwards [I] with Ï‰ hÏ‰\n    simpa [hÏ‰] using (integral_eq_zero_of_ae h).symm\n  have : IsProbabilityMeasure Î¼ :=\n    hint.isProbabilityMeasure_of_indepFun (X 0) (X 1) h (hindep zero_ne_one)\n  -- then consider separately the positive and the negative part, and apply the result\n  -- for nonnegative functions to them.\n  let pos : â„ â†’ â„ := fun x => max x 0\n  let neg : â„ â†’ â„ := fun x => max (-x) 0\n  have posm : Measurable pos := measurable_id'.max measurable_const\n  have negm : Measurable neg := measurable_id'.neg.max measurable_const\n  have A : âˆ€áµ Ï‰, Tendsto (fun n : â„• => (âˆ‘ i âˆˆ range n, (pos âˆ˜ X i) Ï‰) / n) atTop (ğ“ ğ”¼[pos âˆ˜ X 0]) :=\n    strong_law_aux7 _ hint.pos_part (fun i j hij => (hindep hij).comp posm posm)\n      (fun i => (hident i).comp posm) fun i Ï‰ => le_max_right _ _\n  have B : âˆ€áµ Ï‰, Tendsto (fun n : â„• => (âˆ‘ i âˆˆ range n, (neg âˆ˜ X i) Ï‰) / n) atTop (ğ“ ğ”¼[neg âˆ˜ X 0]) :=\n    strong_law_aux7 _ hint.neg_part (fun i j hij => (hindep hij).comp negm negm)\n      (fun i => (hident i).comp negm) fun i Ï‰ => le_max_right _ _\n  filter_upwards [A, B] with Ï‰ hÏ‰pos hÏ‰neg\n  convert hÏ‰pos.sub hÏ‰neg using 2\n  Â· simp only [pos, neg, â† sub_div, â† sum_sub_distrib, max_zero_sub_max_neg_zero_eq_self,\n      Function.comp_apply]\n  Â· simp only [pos, neg, â† integral_sub hint.pos_part hint.neg_part,\n      max_zero_sub_max_neg_zero_eq_self, Function.comp_apply, mÎ©]\n\n"}
{"name":"ProbabilityTheory.strong_law_ae_simpleFunc_comp","module":"Mathlib.Probability.StrongLaw","initialProofState":"Î© : Type u_1\nmÎ© : MeasurableSpace Î©\nÎ¼ : MeasureTheory.Measure Î©\ninstâœâ´ : MeasureTheory.IsProbabilityMeasure Î¼\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace Real E\ninstâœÂ¹ : CompleteSpace E\ninstâœ : MeasurableSpace E\nX : Nat â†’ Î© â†’ E\nh' : Measurable (X 0)\nhindep : Pairwise (Function.onFun (fun x1 x2 => ProbabilityTheory.IndepFun x1 x2 Î¼) X)\nhident : âˆ€ (i : Nat), ProbabilityTheory.IdentDistrib (X i) (X 0) Î¼ Î¼\nÏ† : MeasureTheory.SimpleFunc E E\nâŠ¢ Filter.Eventually (fun Ï‰ => Filter.Tendsto (fun n => HSMul.hSMul (Inv.inv â†‘n) ((Finset.range n).sum fun i => Ï† (X i Ï‰))) Filter.atTop (nhds (MeasureTheory.integral Î¼ fun x => Function.comp (â‡‘Ï†) (X 0) x))) (MeasureTheory.ae Î¼)","decl":"/-- Preliminary lemma for the strong law of large numbers for vector-valued random variables:\nthe composition of the random variables with a simple function satisfies the strong law of large\nnumbers. -/\nlemma strong_law_ae_simpleFunc_comp (X : â„• â†’ Î© â†’ E) (h' : Measurable (X 0))\n    (hindep : Pairwise ((IndepFun Â· Â· Î¼) on X))\n    (hident : âˆ€ i, IdentDistrib (X i) (X 0) Î¼ Î¼) (Ï† : SimpleFunc E E) :\n    âˆ€áµ Ï‰ âˆ‚Î¼,\n      Tendsto (fun n : â„• â†¦ (n : â„) â»Â¹ â€¢ (âˆ‘ i âˆˆ range n, Ï† (X i Ï‰))) atTop (ğ“ Î¼[Ï† âˆ˜ (X 0)]) := by\n  -- this follows from the one-dimensional version when `Ï†` takes a single value, and is then\n  -- extended to the general case by linearity.\n  classical\n  refine SimpleFunc.induction (P := fun Ïˆ â†¦ âˆ€áµ Ï‰ âˆ‚Î¼,\n    Tendsto (fun n : â„• â†¦ (n : â„) â»Â¹ â€¢ (âˆ‘ i âˆˆ range n, Ïˆ (X i Ï‰))) atTop (ğ“ Î¼[Ïˆ âˆ˜ (X 0)])) ?_ ?_ Ï†\n  Â· intro c s hs\n    simp only [SimpleFunc.const_zero, SimpleFunc.coe_piecewise, SimpleFunc.coe_const,\n      SimpleFunc.coe_zero, piecewise_eq_indicator, Function.comp_apply]\n    let F : E â†’ â„ := indicator s 1\n    have F_meas : Measurable F := (measurable_indicator_const_iff 1).2 hs\n    let Y : â„• â†’ Î© â†’ â„ := fun n â†¦ F âˆ˜ (X n)\n    have : âˆ€áµ (Ï‰ : Î©) âˆ‚Î¼, Tendsto (fun (n : â„•) â†¦ (n : â„)â»Â¹ â€¢ âˆ‘ i âˆˆ Finset.range n, Y i Ï‰)\n        atTop (ğ“ Î¼[Y 0]) := by\n      simp only [Function.const_one, smul_eq_mul, â† div_eq_inv_mul]\n      apply strong_law_ae_real\n      Â· exact SimpleFunc.integrable_of_isFiniteMeasure\n          ((SimpleFunc.piecewise s hs (SimpleFunc.const _ (1 : â„))\n            (SimpleFunc.const _ (0 : â„))).comp (X 0) h')\n      Â· exact fun i j hij â†¦ IndepFun.comp (hindep hij) F_meas F_meas\n      Â· exact fun i â†¦ (hident i).comp F_meas\n    filter_upwards [this] with Ï‰ hÏ‰\n    have I : indicator s (Function.const E c) = (fun x â†¦ (indicator s (1 : E â†’ â„) x) â€¢ c) := by\n      ext\n      rw [â† indicator_smul_const_apply]\n      congr! 1\n      ext\n      simp\n    simp only [I, integral_smul_const]\n    convert Tendsto.smul_const hÏ‰ c using 1\n    simp [F, Y, â† sum_smul, smul_smul]\n  Â· rintro Ï† Ïˆ - hÏ† hÏˆ\n    filter_upwards [hÏ†, hÏˆ] with Ï‰ hÏ‰Ï† hÏ‰Ïˆ\n    convert hÏ‰Ï†.add hÏ‰Ïˆ using 1\n    Â· simp [sum_add_distrib]\n    Â· congr 1\n      rw [â† integral_add]\n      Â· rfl\n      Â· exact (Ï†.comp (X 0) h').integrable_of_isFiniteMeasure\n      Â· exact (Ïˆ.comp (X 0) h').integrable_of_isFiniteMeasure\n\n"}
{"name":"ProbabilityTheory.strong_law_ae_of_measurable","module":"Mathlib.Probability.StrongLaw","initialProofState":"Î© : Type u_1\nmÎ© : MeasurableSpace Î©\nÎ¼ : MeasureTheory.Measure Î©\ninstâœâµ : MeasureTheory.IsProbabilityMeasure Î¼\nE : Type u_2\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace Real E\ninstâœÂ² : CompleteSpace E\ninstâœÂ¹ : MeasurableSpace E\ninstâœ : BorelSpace E\nX : Nat â†’ Î© â†’ E\nhint : MeasureTheory.Integrable (X 0) Î¼\nh' : MeasureTheory.StronglyMeasurable (X 0)\nhindep : Pairwise (Function.onFun (fun x1 x2 => ProbabilityTheory.IndepFun x1 x2 Î¼) X)\nhident : âˆ€ (i : Nat), ProbabilityTheory.IdentDistrib (X i) (X 0) Î¼ Î¼\nâŠ¢ Filter.Eventually (fun Ï‰ => Filter.Tendsto (fun n => HSMul.hSMul (Inv.inv â†‘n) ((Finset.range n).sum fun i => X i Ï‰)) Filter.atTop (nhds (MeasureTheory.integral Î¼ fun x => X 0 x))) (MeasureTheory.ae Î¼)","decl":"/-- Preliminary lemma for the strong law of large numbers for vector-valued random variables,\nassuming measurability in addition to integrability. This is weakened to ae measurability in\nthe full version `ProbabilityTheory.strong_law_ae`. -/\nlemma strong_law_ae_of_measurable\n    (X : â„• â†’ Î© â†’ E) (hint : Integrable (X 0) Î¼) (h' : StronglyMeasurable (X 0))\n    (hindep : Pairwise ((IndepFun Â· Â· Î¼) on X))\n    (hident : âˆ€ i, IdentDistrib (X i) (X 0) Î¼ Î¼) :\n    âˆ€áµ Ï‰ âˆ‚Î¼, Tendsto (fun n : â„• â†¦ (n : â„) â»Â¹ â€¢ (âˆ‘ i âˆˆ range n, X i Ï‰)) atTop (ğ“ Î¼[X 0]) := by\n  /- Choose a simple function `Ï†` such that `Ï† (X 0)` approximates well enough `X 0` -- this is\n  possible as `X 0` is strongly measurable. Then `Ï† (X n)` approximates well `X n`.\n  Then the strong law for `Ï† (X n)` implies the strong law for `X n`, up to a small\n  error controlled by `nâ»Â¹ âˆ‘_{i=0}^{n-1} â€–X i - Ï† (X i)â€–`. This one is also controlled thanks\n  to the one-dimensional law of large numbers: it converges ae to `ğ”¼[â€–X 0 - Ï† (X 0)â€–]`, which\n  is arbitrarily small for well chosen `Ï†`. -/\n  let s : Set E := Set.range (X 0) âˆª {0}\n  have zero_s : 0 âˆˆ s := by simp [s]\n  have : SeparableSpace s := h'.separableSpace_range_union_singleton\n  have : Nonempty s := âŸ¨0, zero_sâŸ©\n  -- sequence of approximating simple functions.\n  let Ï† : â„• â†’ SimpleFunc E E :=\n    SimpleFunc.nearestPt (fun k => Nat.casesOn k 0 ((â†‘) âˆ˜ denseSeq s) : â„• â†’ E)\n  let Y : â„• â†’ â„• â†’ Î© â†’ E := fun k i â†¦ (Ï† k) âˆ˜ (X i)\n  -- strong law for `Ï† (X n)`\n  have A : âˆ€áµ Ï‰ âˆ‚Î¼, âˆ€ k,\n      Tendsto (fun n : â„• â†¦ (n : â„) â»Â¹ â€¢ (âˆ‘ i âˆˆ range n, Y k i Ï‰)) atTop (ğ“ Î¼[Y k 0]) :=\n    ae_all_iff.2 (fun k â†¦ strong_law_ae_simpleFunc_comp X h'.measurable hindep hident (Ï† k))\n  -- strong law for the error `â€–X i - Ï† (X i)â€–`\n  have B : âˆ€áµ Ï‰ âˆ‚Î¼, âˆ€ k, Tendsto (fun n : â„• â†¦ (âˆ‘ i âˆˆ range n, â€–(X i - Y k i) Ï‰â€–) / n)\n        atTop (ğ“ Î¼[(fun Ï‰ â†¦ â€–(X 0 - Y k 0) Ï‰â€–)]) := by\n    apply ae_all_iff.2 (fun k â†¦ ?_)\n    let G : â„• â†’ E â†’ â„ := fun k x â†¦ â€–x - Ï† k xâ€–\n    have G_meas : âˆ€ k, Measurable (G k) :=\n      fun k â†¦ (measurable_id.sub_stronglyMeasurable (Ï† k).stronglyMeasurable).norm\n    have I : âˆ€ k i, (fun Ï‰ â†¦ â€–(X i - Y k i) Ï‰â€–) = (G k) âˆ˜ (X i) := fun k i â†¦ rfl\n    apply strong_law_ae_real (fun i Ï‰ â†¦ â€–(X i - Y k i) Ï‰â€–)\n    Â· exact (hint.sub ((Ï† k).comp (X 0) h'.measurable).integrable_of_isFiniteMeasure).norm\n    Â· unfold Function.onFun\n      simp_rw [I]\n      intro i j hij\n      exact (hindep hij).comp (G_meas k) (G_meas k)\n    Â· intro i\n      simp_rw [I]\n      apply (hident i).comp (G_meas k)\n  -- check that, when both convergences above hold, then the strong law is satisfied\n  filter_upwards [A, B] with Ï‰ hÏ‰ h'Ï‰\n  rw [tendsto_iff_norm_sub_tendsto_zero, tendsto_order]\n  refine âŸ¨fun c hc â†¦ Eventually.of_forall (fun n â†¦ hc.trans_le (norm_nonneg _)), ?_âŸ©\n  -- start with some positive `Îµ` (the desired precision), and fix `Î´` with `3 Î´ < Îµ`.\n  intro Îµ (Îµpos : 0 < Îµ)\n  obtain âŸ¨Î´, Î´pos, hÎ´âŸ© : âˆƒ Î´, 0 < Î´ âˆ§ Î´ + Î´ + Î´ < Îµ := âŸ¨Îµ/4, by positivity, by linarithâŸ©\n  -- choose `k` large enough so that `Ï†â‚– (X 0)` approximates well enough `X 0`, up to the\n  -- precision `Î´`.\n  obtain âŸ¨k, hkâŸ© : âˆƒ k, âˆ« Ï‰, â€–(X 0 - Y k 0) Ï‰â€– âˆ‚Î¼ < Î´ := by\n    simp_rw [Pi.sub_apply, norm_sub_rev (X 0 _)]\n    exact ((tendsto_order.1 (tendsto_integral_norm_approxOn_sub h'.measurable hint)).2 Î´\n      Î´pos).exists\n  have : â€–Î¼[Y k 0] - Î¼[X 0]â€– < Î´ := by\n    rw [norm_sub_rev, â† integral_sub hint]\n    Â· exact (norm_integral_le_integral_norm _).trans_lt hk\n    Â· exact ((Ï† k).comp (X 0) h'.measurable).integrable_of_isFiniteMeasure\n  -- consider `n` large enough for which the above convergences have taken place within `Î´`.\n  have I : âˆ€á¶  n in atTop, (âˆ‘ i âˆˆ range n, â€–(X i - Y k i) Ï‰â€–) / n < Î´ :=\n    (tendsto_order.1 (h'Ï‰ k)).2 Î´ hk\n  have J : âˆ€á¶  (n : â„•) in atTop, â€–(n : â„) â»Â¹ â€¢ (âˆ‘ i âˆˆ range n, Y k i Ï‰) - Î¼[Y k 0]â€– < Î´ := by\n    specialize hÏ‰ k\n    rw [tendsto_iff_norm_sub_tendsto_zero] at hÏ‰\n    exact (tendsto_order.1 hÏ‰).2 Î´ Î´pos\n  filter_upwards [I, J] with n hn h'n\n  -- at such an `n`, the strong law is realized up to `Îµ`.\n  calc\n  â€–(n : â„)â»Â¹ â€¢ âˆ‘ i âˆˆ Finset.range n, X i Ï‰ - Î¼[X 0]â€–\n    = â€–(n : â„)â»Â¹ â€¢ âˆ‘ i âˆˆ Finset.range n, (X i Ï‰ - Y k i Ï‰) +\n        ((n : â„)â»Â¹ â€¢ âˆ‘ i âˆˆ Finset.range n, Y k i Ï‰ - Î¼[Y k 0]) + (Î¼[Y k 0] - Î¼[X 0])â€– := by\n      congr\n      simp only [Function.comp_apply, sum_sub_distrib, smul_sub]\n      abel\n  _ â‰¤ â€–(n : â„)â»Â¹ â€¢ âˆ‘ i âˆˆ Finset.range n, (X i Ï‰ - Y k i Ï‰)â€– +\n        â€–(n : â„)â»Â¹ â€¢ âˆ‘ i âˆˆ Finset.range n, Y k i Ï‰ - Î¼[Y k 0]â€– + â€–Î¼[Y k 0] - Î¼[X 0]â€– :=\n      norm_addâ‚ƒ_le\n  _ â‰¤ (âˆ‘ i âˆˆ Finset.range n, â€–X i Ï‰ - Y k i Ï‰â€–) / n + Î´ + Î´ := by\n      gcongr\n      simp only [Function.comp_apply, norm_smul, norm_inv, RCLike.norm_natCast,\n        div_eq_inv_mul, inv_pos, Nat.cast_pos, inv_lt_zero]\n      gcongr\n      exact norm_sum_le _ _\n  _ â‰¤ Î´ + Î´ + Î´ := by\n      gcongr\n      exact hn.le\n  _ < Îµ := hÎ´\n\n"}
{"name":"ProbabilityTheory.strong_law_ae","module":"Mathlib.Probability.StrongLaw","initialProofState":"Î© : Type u_1\nmÎ© : MeasurableSpace Î©\nÎ¼ : MeasureTheory.Measure Î©\nE : Type u_2\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace Real E\ninstâœÂ² : CompleteSpace E\ninstâœÂ¹ : MeasurableSpace E\ninstâœ : BorelSpace E\nX : Nat â†’ Î© â†’ E\nhint : MeasureTheory.Integrable (X 0) Î¼\nhindep : Pairwise (Function.onFun (fun x1 x2 => ProbabilityTheory.IndepFun x1 x2 Î¼) X)\nhident : âˆ€ (i : Nat), ProbabilityTheory.IdentDistrib (X i) (X 0) Î¼ Î¼\nâŠ¢ Filter.Eventually (fun Ï‰ => Filter.Tendsto (fun n => HSMul.hSMul (Inv.inv â†‘n) ((Finset.range n).sum fun i => X i Ï‰)) Filter.atTop (nhds (MeasureTheory.integral Î¼ fun x => X 0 x))) (MeasureTheory.ae Î¼)","decl":"omit [IsProbabilityMeasure Î¼] in\n/-- **Strong law of large numbers**, almost sure version: if `X n` is a sequence of independent\nidentically distributed integrable random variables taking values in a Banach space,\nthen `nâ»Â¹ â€¢ âˆ‘ i âˆˆ range n, X i` converges almost surely to `ğ”¼[X 0]`. We give here the strong\nversion, due to Etemadi, that only requires pairwise independence. -/\ntheorem strong_law_ae (X : â„• â†’ Î© â†’ E) (hint : Integrable (X 0) Î¼)\n    (hindep : Pairwise ((IndepFun Â· Â· Î¼) on X))\n    (hident : âˆ€ i, IdentDistrib (X i) (X 0) Î¼ Î¼) :\n    âˆ€áµ Ï‰ âˆ‚Î¼, Tendsto (fun n : â„• â†¦ (n : â„) â»Â¹ â€¢ (âˆ‘ i âˆˆ range n, X i Ï‰)) atTop (ğ“ Î¼[X 0]) := by\n  -- First exclude the trivial case where the space is not a probability space\n  by_cases h : âˆ€áµ Ï‰ âˆ‚Î¼, X 0 Ï‰ = 0\n  Â· have I : âˆ€áµ Ï‰ âˆ‚Î¼, âˆ€ i, X i Ï‰ = 0 := by\n      rw [ae_all_iff]\n      intro i\n      exact (hident i).symm.ae_snd (p := fun x â†¦ x = 0) measurableSet_eq h\n    filter_upwards [I] with Ï‰ hÏ‰\n    simpa [hÏ‰] using (integral_eq_zero_of_ae h).symm\n  have : IsProbabilityMeasure Î¼ :=\n    hint.isProbabilityMeasure_of_indepFun (X 0) (X 1) h (hindep zero_ne_one)\n  -- we reduce to the case of strongly measurable random variables, by using `Y i` which is strongly\n  -- measurable and ae equal to `X i`.\n  have A : âˆ€ i, Integrable (X i) Î¼ := fun i â†¦ (hident i).integrable_iff.2 hint\n  let Y : â„• â†’ Î© â†’ E := fun i â†¦ (A i).1.mk (X i)\n  have B : âˆ€áµ Ï‰ âˆ‚Î¼, âˆ€ n, X n Ï‰ = Y n Ï‰ :=\n    ae_all_iff.2 (fun i â†¦ AEStronglyMeasurable.ae_eq_mk (A i).1)\n  have Yint : Integrable (Y 0) Î¼ := Integrable.congr hint (AEStronglyMeasurable.ae_eq_mk (A 0).1)\n  have C : âˆ€áµ Ï‰ âˆ‚Î¼,\n      Tendsto (fun n : â„• â†¦ (n : â„) â»Â¹ â€¢ (âˆ‘ i âˆˆ range n, Y i Ï‰)) atTop (ğ“ Î¼[Y 0]) := by\n    apply strong_law_ae_of_measurable Y Yint ((A 0).1.stronglyMeasurable_mk)\n      (fun i j hij â†¦ IndepFun.ae_eq (hindep hij) (A i).1.ae_eq_mk (A j).1.ae_eq_mk)\n      (fun i â†¦ ((A i).1.identDistrib_mk.symm.trans (hident i)).trans (A 0).1.identDistrib_mk)\n  filter_upwards [B, C] with Ï‰ hâ‚ hâ‚‚\n  have : Î¼[X 0] = Î¼[Y 0] := integral_congr_ae (AEStronglyMeasurable.ae_eq_mk (A 0).1)\n  rw [this]\n  apply Tendsto.congr (fun n â†¦ ?_) hâ‚‚\n  congr with i\n  exact (hâ‚ i).symm\n\n"}
{"name":"ProbabilityTheory.strong_law_Lp","module":"Mathlib.Probability.StrongLaw","initialProofState":"Î© : Type u_1\nmÎ© : MeasurableSpace Î©\nÎ¼ : MeasureTheory.Measure Î©\nE : Type u_2\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace Real E\ninstâœÂ² : CompleteSpace E\ninstâœÂ¹ : MeasurableSpace E\ninstâœ : BorelSpace E\np : ENNReal\nhp : LE.le 1 p\nhp' : Ne p Top.top\nX : Nat â†’ Î© â†’ E\nhâ„’p : MeasureTheory.Memâ„’p (X 0) p Î¼\nhindep : Pairwise (Function.onFun (fun x1 x2 => ProbabilityTheory.IndepFun x1 x2 Î¼) X)\nhident : âˆ€ (i : Nat), ProbabilityTheory.IdentDistrib (X i) (X 0) Î¼ Î¼\nâŠ¢ Filter.Tendsto (fun n => MeasureTheory.eLpNorm (fun Ï‰ => HSub.hSub (HSMul.hSMul (Inv.inv â†‘n) ((Finset.range n).sum fun i => X i Ï‰)) (MeasureTheory.integral Î¼ fun x => X 0 x)) p Î¼) Filter.atTop (nhds 0)","decl":"/-- **Strong law of large numbers**, Láµ– version: if `X n` is a sequence of independent\nidentically distributed random variables in Láµ–, then `nâ»Â¹ â€¢ âˆ‘ i âˆˆ range n, X i`\nconverges in `Láµ–` to `ğ”¼[X 0]`. -/\ntheorem strong_law_Lp {p : â„â‰¥0âˆ} (hp : 1 â‰¤ p) (hp' : p â‰  âˆ) (X : â„• â†’ Î© â†’ E)\n    (hâ„’p : Memâ„’p (X 0) p Î¼) (hindep : Pairwise ((IndepFun Â· Â· Î¼) on X))\n    (hident : âˆ€ i, IdentDistrib (X i) (X 0) Î¼ Î¼) :\n    Tendsto (fun (n : â„•) => eLpNorm (fun Ï‰ => (n : â„) â»Â¹ â€¢ (âˆ‘ i âˆˆ range n, X i Ï‰) - Î¼[X 0]) p Î¼)\n      atTop (ğ“ 0) := by\n  -- First exclude the trivial case where the space is not a probability space\n  by_cases h : âˆ€áµ Ï‰ âˆ‚Î¼, X 0 Ï‰ = 0\n  Â· have I : âˆ€áµ Ï‰ âˆ‚Î¼, âˆ€ i, X i Ï‰ = 0 := by\n      rw [ae_all_iff]\n      intro i\n      exact (hident i).symm.ae_snd (p := fun x â†¦ x = 0) measurableSet_eq h\n    have A (n : â„•) : eLpNorm (fun Ï‰ => (n : â„) â»Â¹ â€¢ (âˆ‘ i âˆˆ range n, X i Ï‰) - Î¼[X 0]) p Î¼ = 0 := by\n      simp only [integral_eq_zero_of_ae h, sub_zero]\n      apply eLpNorm_eq_zero_of_ae_zero\n      filter_upwards [I] with Ï‰ hÏ‰\n      simp [hÏ‰]\n    simp [A]\n  -- Then use ae convergence and uniform integrability\n  have : IsProbabilityMeasure Î¼ := Memâ„’p.isProbabilityMeasure_of_indepFun\n    (X 0) (X 1) (zero_lt_one.trans_le hp).ne' hp' hâ„’p h (hindep zero_ne_one)\n  have hmeas : âˆ€ i, AEStronglyMeasurable (X i) Î¼ := fun i =>\n    (hident i).aestronglyMeasurable_iff.2 hâ„’p.1\n  have hint : Integrable (X 0) Î¼ := hâ„’p.integrable hp\n  have havg (n : â„•) :\n      AEStronglyMeasurable (fun Ï‰ => (n : â„) â»Â¹ â€¢ (âˆ‘ i âˆˆ range n, X i Ï‰)) Î¼ :=\n    AEStronglyMeasurable.const_smul (aestronglyMeasurable_sum _ fun i _ => hmeas i) _\n  refine tendsto_Lp_finite_of_tendstoInMeasure hp hp' havg (memâ„’p_const _) ?_\n    (tendstoInMeasure_of_tendsto_ae havg (strong_law_ae _ hint hindep hident))\n  rw [(_ : (fun (n : â„•) Ï‰ => (n : â„)â»Â¹ â€¢ (âˆ‘ i âˆˆ range n, X i Ï‰))\n            = fun (n : â„•) => (n : â„)â»Â¹ â€¢ (âˆ‘ i âˆˆ range n, X i))]\n  Â· apply UniformIntegrable.unifIntegrable\n    apply uniformIntegrable_average hp\n    exact Memâ„’p.uniformIntegrable_of_identDistrib hp hp' hâ„’p hident\n  Â· ext n Ï‰\n    simp only [Pi.smul_apply, sum_apply]\n\n"}
