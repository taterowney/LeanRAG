{"name":"MeasureTheory.AEStronglyMeasurable.truncation","module":"Mathlib.Probability.StrongLaw","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : α → Real\nhf : MeasureTheory.AEStronglyMeasurable f μ\nA : Real\n⊢ MeasureTheory.AEStronglyMeasurable (ProbabilityTheory.truncation f A) μ","decl":"theorem _root_.MeasureTheory.AEStronglyMeasurable.truncation (hf : AEStronglyMeasurable f μ)\n    {A : ℝ} : AEStronglyMeasurable (truncation f A) μ := by\n  apply AEStronglyMeasurable.comp_aemeasurable _ hf.aemeasurable\n  exact (stronglyMeasurable_id.indicator measurableSet_Ioc).aestronglyMeasurable\n\n"}
{"name":"ProbabilityTheory.abs_truncation_le_bound","module":"Mathlib.Probability.StrongLaw","initialProofState":"α : Type u_1\nf : α → Real\nA : Real\nx : α\n⊢ LE.le (abs (ProbabilityTheory.truncation f A x)) (abs A)","decl":"theorem abs_truncation_le_bound (f : α → ℝ) (A : ℝ) (x : α) : |truncation f A x| ≤ |A| := by\n  simp only [truncation, Set.indicator, Set.mem_Icc, id, Function.comp_apply]\n  split_ifs with h\n  · exact abs_le_abs h.2 (neg_le.2 h.1.le)\n  · simp [abs_nonneg]\n\n"}
{"name":"ProbabilityTheory.truncation_zero","module":"Mathlib.Probability.StrongLaw","initialProofState":"α : Type u_1\nf : α → Real\n⊢ Eq (ProbabilityTheory.truncation f 0) 0","decl":"@[simp]\ntheorem truncation_zero (f : α → ℝ) : truncation f 0 = 0 := by simp [truncation]; rfl\n\n"}
{"name":"ProbabilityTheory.abs_truncation_le_abs_self","module":"Mathlib.Probability.StrongLaw","initialProofState":"α : Type u_1\nf : α → Real\nA : Real\nx : α\n⊢ LE.le (abs (ProbabilityTheory.truncation f A x)) (abs (f x))","decl":"theorem abs_truncation_le_abs_self (f : α → ℝ) (A : ℝ) (x : α) : |truncation f A x| ≤ |f x| := by\n  simp only [truncation, indicator, Set.mem_Icc, id, Function.comp_apply]\n  split_ifs\n  · exact le_rfl\n  · simp [abs_nonneg]\n\n"}
{"name":"ProbabilityTheory.truncation_eq_self","module":"Mathlib.Probability.StrongLaw","initialProofState":"α : Type u_1\nf : α → Real\nA : Real\nx : α\nh : LT.lt (abs (f x)) A\n⊢ Eq (ProbabilityTheory.truncation f A x) (f x)","decl":"theorem truncation_eq_self {f : α → ℝ} {A : ℝ} {x : α} (h : |f x| < A) :\n    truncation f A x = f x := by\n  simp only [truncation, indicator, Set.mem_Icc, id, Function.comp_apply, ite_eq_left_iff]\n  intro H\n  apply H.elim\n  simp [(abs_lt.1 h).1, (abs_lt.1 h).2.le]\n\n"}
{"name":"ProbabilityTheory.truncation_eq_of_nonneg","module":"Mathlib.Probability.StrongLaw","initialProofState":"α : Type u_1\nf : α → Real\nA : Real\nh : ∀ (x : α), LE.le 0 (f x)\n⊢ Eq (ProbabilityTheory.truncation f A) (Function.comp ((Set.Ioc 0 A).indicator id) f)","decl":"theorem truncation_eq_of_nonneg {f : α → ℝ} {A : ℝ} (h : ∀ x, 0 ≤ f x) :\n    truncation f A = indicator (Set.Ioc 0 A) id ∘ f := by\n  ext x\n  rcases (h x).lt_or_eq with (hx | hx)\n  · simp only [truncation, indicator, hx, Set.mem_Ioc, id, Function.comp_apply]\n    by_cases h'x : f x ≤ A\n    · have : -A < f x := by linarith [h x]\n      simp only [this, true_and]\n    · simp only [h'x, and_false]\n  · simp only [truncation, indicator, hx, id, Function.comp_apply, ite_self]\n\n"}
{"name":"ProbabilityTheory.truncation_nonneg","module":"Mathlib.Probability.StrongLaw","initialProofState":"α : Type u_1\nf : α → Real\nA : Real\nx : α\nh : LE.le 0 (f x)\n⊢ LE.le 0 (ProbabilityTheory.truncation f A x)","decl":"theorem truncation_nonneg {f : α → ℝ} (A : ℝ) {x : α} (h : 0 ≤ f x) : 0 ≤ truncation f A x :=\n  Set.indicator_apply_nonneg fun _ => h\n\n"}
{"name":"MeasureTheory.AEStronglyMeasurable.memℒp_truncation","module":"Mathlib.Probability.StrongLaw","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : α → Real\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nhf : MeasureTheory.AEStronglyMeasurable f μ\nA : Real\np : ENNReal\n⊢ MeasureTheory.Memℒp (ProbabilityTheory.truncation f A) p μ","decl":"theorem _root_.MeasureTheory.AEStronglyMeasurable.memℒp_truncation [IsFiniteMeasure μ]\n    (hf : AEStronglyMeasurable f μ) {A : ℝ} {p : ℝ≥0∞} : Memℒp (truncation f A) p μ :=\n  Memℒp.of_bound hf.truncation |A| (Eventually.of_forall fun _ => abs_truncation_le_bound _ _ _)\n\n"}
{"name":"MeasureTheory.AEStronglyMeasurable.integrable_truncation","module":"Mathlib.Probability.StrongLaw","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : α → Real\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nhf : MeasureTheory.AEStronglyMeasurable f μ\nA : Real\n⊢ MeasureTheory.Integrable (ProbabilityTheory.truncation f A) μ","decl":"theorem _root_.MeasureTheory.AEStronglyMeasurable.integrable_truncation [IsFiniteMeasure μ]\n    (hf : AEStronglyMeasurable f μ) {A : ℝ} : Integrable (truncation f A) μ := by\n  rw [← memℒp_one_iff_integrable]; exact hf.memℒp_truncation\n\n"}
{"name":"ProbabilityTheory.moment_truncation_eq_intervalIntegral","module":"Mathlib.Probability.StrongLaw","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : α → Real\nhf : MeasureTheory.AEStronglyMeasurable f μ\nA : Real\nhA : LE.le 0 A\nn : Nat\nhn : Ne n 0\n⊢ Eq (MeasureTheory.integral μ fun x => HPow.hPow (ProbabilityTheory.truncation f A x) n) (intervalIntegral (fun y => HPow.hPow y n) (Neg.neg A) A (MeasureTheory.Measure.map f μ))","decl":"theorem moment_truncation_eq_intervalIntegral (hf : AEStronglyMeasurable f μ) {A : ℝ} (hA : 0 ≤ A)\n    {n : ℕ} (hn : n ≠ 0) : ∫ x, truncation f A x ^ n ∂μ = ∫ y in -A..A, y ^ n ∂Measure.map f μ := by\n  have M : MeasurableSet (Set.Ioc (-A) A) := measurableSet_Ioc\n  change ∫ x, (fun z => indicator (Set.Ioc (-A) A) id z ^ n) (f x) ∂μ = _\n  rw [← integral_map (f := fun z => _ ^ n) hf.aemeasurable, intervalIntegral.integral_of_le,\n    ← integral_indicator M]\n  · simp only [indicator, zero_pow hn, id, ite_pow]\n  · linarith\n  · exact ((measurable_id.indicator M).pow_const n).aestronglyMeasurable\n\n"}
{"name":"ProbabilityTheory.moment_truncation_eq_intervalIntegral_of_nonneg","module":"Mathlib.Probability.StrongLaw","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : α → Real\nhf : MeasureTheory.AEStronglyMeasurable f μ\nA : Real\nn : Nat\nhn : Ne n 0\nh'f : LE.le 0 f\n⊢ Eq (MeasureTheory.integral μ fun x => HPow.hPow (ProbabilityTheory.truncation f A x) n) (intervalIntegral (fun y => HPow.hPow y n) 0 A (MeasureTheory.Measure.map f μ))","decl":"theorem moment_truncation_eq_intervalIntegral_of_nonneg (hf : AEStronglyMeasurable f μ) {A : ℝ}\n    {n : ℕ} (hn : n ≠ 0) (h'f : 0 ≤ f) :\n    ∫ x, truncation f A x ^ n ∂μ = ∫ y in (0)..A, y ^ n ∂Measure.map f μ := by\n  have M : MeasurableSet (Set.Ioc 0 A) := measurableSet_Ioc\n  have M' : MeasurableSet (Set.Ioc A 0) := measurableSet_Ioc\n  rw [truncation_eq_of_nonneg h'f]\n  change ∫ x, (fun z => indicator (Set.Ioc 0 A) id z ^ n) (f x) ∂μ = _\n  rcases le_or_lt 0 A with (hA | hA)\n  · rw [← integral_map (f := fun z => _ ^ n) hf.aemeasurable, intervalIntegral.integral_of_le hA,\n      ← integral_indicator M]\n    · simp only [indicator, zero_pow hn, id, ite_pow]\n    · exact ((measurable_id.indicator M).pow_const n).aestronglyMeasurable\n  · rw [← integral_map (f := fun z => _ ^ n) hf.aemeasurable, intervalIntegral.integral_of_ge hA.le,\n      ← integral_indicator M']\n    · simp only [Set.Ioc_eq_empty_of_le hA.le, zero_pow hn, Set.indicator_empty, integral_zero,\n        zero_eq_neg]\n      apply integral_eq_zero_of_ae\n      have : ∀ᵐ x ∂Measure.map f μ, (0 : ℝ) ≤ x :=\n        (ae_map_iff hf.aemeasurable measurableSet_Ici).2 (Eventually.of_forall h'f)\n      filter_upwards [this] with x hx\n      simp only [indicator, Set.mem_Ioc, Pi.zero_apply, ite_eq_right_iff, and_imp]\n      intro _ h''x\n      have : x = 0 := by linarith\n      simp [this, zero_pow hn]\n    · exact ((measurable_id.indicator M).pow_const n).aestronglyMeasurable\n\n"}
{"name":"ProbabilityTheory.integral_truncation_eq_intervalIntegral","module":"Mathlib.Probability.StrongLaw","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : α → Real\nhf : MeasureTheory.AEStronglyMeasurable f μ\nA : Real\nhA : LE.le 0 A\n⊢ Eq (MeasureTheory.integral μ fun x => ProbabilityTheory.truncation f A x) (intervalIntegral (fun y => y) (Neg.neg A) A (MeasureTheory.Measure.map f μ))","decl":"theorem integral_truncation_eq_intervalIntegral (hf : AEStronglyMeasurable f μ) {A : ℝ}\n    (hA : 0 ≤ A) : ∫ x, truncation f A x ∂μ = ∫ y in -A..A, y ∂Measure.map f μ := by\n  simpa using moment_truncation_eq_intervalIntegral hf hA one_ne_zero\n\n"}
{"name":"ProbabilityTheory.integral_truncation_eq_intervalIntegral_of_nonneg","module":"Mathlib.Probability.StrongLaw","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : α → Real\nhf : MeasureTheory.AEStronglyMeasurable f μ\nA : Real\nh'f : LE.le 0 f\n⊢ Eq (MeasureTheory.integral μ fun x => ProbabilityTheory.truncation f A x) (intervalIntegral (fun y => y) 0 A (MeasureTheory.Measure.map f μ))","decl":"theorem integral_truncation_eq_intervalIntegral_of_nonneg (hf : AEStronglyMeasurable f μ) {A : ℝ}\n    (h'f : 0 ≤ f) : ∫ x, truncation f A x ∂μ = ∫ y in (0)..A, y ∂Measure.map f μ := by\n  simpa using moment_truncation_eq_intervalIntegral_of_nonneg hf one_ne_zero h'f\n\n"}
{"name":"ProbabilityTheory.integral_truncation_le_integral_of_nonneg","module":"Mathlib.Probability.StrongLaw","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : α → Real\nhf : MeasureTheory.Integrable f μ\nh'f : LE.le 0 f\nA : Real\n⊢ LE.le (MeasureTheory.integral μ fun x => ProbabilityTheory.truncation f A x) (MeasureTheory.integral μ fun x => f x)","decl":"theorem integral_truncation_le_integral_of_nonneg (hf : Integrable f μ) (h'f : 0 ≤ f) {A : ℝ} :\n    ∫ x, truncation f A x ∂μ ≤ ∫ x, f x ∂μ := by\n  apply integral_mono_of_nonneg\n    (Eventually.of_forall fun x => ?_) hf (Eventually.of_forall fun x => ?_)\n  · exact truncation_nonneg _ (h'f x)\n  · calc\n      truncation f A x ≤ |truncation f A x| := le_abs_self _\n      _ ≤ |f x| := abs_truncation_le_abs_self _ _ _\n      _ = f x := abs_of_nonneg (h'f x)\n\n"}
{"name":"ProbabilityTheory.tendsto_integral_truncation","module":"Mathlib.Probability.StrongLaw","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : α → Real\nhf : MeasureTheory.Integrable f μ\n⊢ Filter.Tendsto (fun A => MeasureTheory.integral μ fun x => ProbabilityTheory.truncation f A x) Filter.atTop (nhds (MeasureTheory.integral μ fun x => f x))","decl":"/-- If a function is integrable, then the integral of its truncated versions converges to the\nintegral of the whole function. -/\ntheorem tendsto_integral_truncation {f : α → ℝ} (hf : Integrable f μ) :\n    Tendsto (fun A => ∫ x, truncation f A x ∂μ) atTop (𝓝 (∫ x, f x ∂μ)) := by\n  refine tendsto_integral_filter_of_dominated_convergence (fun x => abs (f x)) ?_ ?_ ?_ ?_\n  · exact Eventually.of_forall fun A ↦ hf.aestronglyMeasurable.truncation\n  · filter_upwards with A\n    filter_upwards with x\n    rw [Real.norm_eq_abs]\n    exact abs_truncation_le_abs_self _ _ _\n  · exact hf.abs\n  · filter_upwards with x\n    apply tendsto_const_nhds.congr' _\n    filter_upwards [Ioi_mem_atTop (abs (f x))] with A hA\n    exact (truncation_eq_self hA).symm\n\n"}
{"name":"ProbabilityTheory.IdentDistrib.truncation","module":"Mathlib.Probability.StrongLaw","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nβ : Type u_2\ninst✝ : MeasurableSpace β\nν : MeasureTheory.Measure β\nf : α → Real\ng : β → Real\nh : ProbabilityTheory.IdentDistrib f g μ ν\nA : Real\n⊢ ProbabilityTheory.IdentDistrib (ProbabilityTheory.truncation f A) (ProbabilityTheory.truncation g A) μ ν","decl":"theorem IdentDistrib.truncation {β : Type*} [MeasurableSpace β] {ν : Measure β} {f : α → ℝ}\n    {g : β → ℝ} (h : IdentDistrib f g μ ν) {A : ℝ} :\n    IdentDistrib (truncation f A) (truncation g A) μ ν :=\n  h.comp (measurable_id.indicator measurableSet_Ioc)\n\n"}
{"name":"ProbabilityTheory.sum_prob_mem_Ioc_le","module":"Mathlib.Probability.StrongLaw","initialProofState":"Ω : Type u_1\ninst✝¹ : MeasureTheory.MeasureSpace Ω\ninst✝ : MeasureTheory.IsProbabilityMeasure MeasureTheory.MeasureSpace.volume\nX : Ω → Real\nhint : MeasureTheory.Integrable X MeasureTheory.MeasureSpace.volume\nhnonneg : LE.le 0 X\nK N : Nat\nhKN : LE.le K N\n⊢ LE.le ((Finset.range K).sum fun j => MeasureTheory.MeasureSpace.volume (setOf fun ω => Membership.mem (Set.Ioc ↑j ↑N) (X ω))) (ENNReal.ofReal (HAdd.hAdd (MeasureTheory.integral MeasureTheory.MeasureSpace.volume fun a => X a) 1))","decl":"theorem sum_prob_mem_Ioc_le {X : Ω → ℝ} (hint : Integrable X) (hnonneg : 0 ≤ X) {K : ℕ} {N : ℕ}\n    (hKN : K ≤ N) :\n    ∑ j ∈ range K, ℙ {ω | X ω ∈ Set.Ioc (j : ℝ) N} ≤ ENNReal.ofReal (𝔼[X] + 1) := by\n  let ρ : Measure ℝ := Measure.map X ℙ\n  haveI : IsProbabilityMeasure ρ := isProbabilityMeasure_map hint.aemeasurable\n  have A : ∑ j ∈ range K, ∫ _ in j..N, (1 : ℝ) ∂ρ ≤ 𝔼[X] + 1 :=\n    calc\n      ∑ j ∈ range K, ∫ _ in j..N, (1 : ℝ) ∂ρ =\n          ∑ j ∈ range K, ∑ i ∈ Ico j N, ∫ _ in i..(i + 1 : ℕ), (1 : ℝ) ∂ρ := by\n        apply sum_congr rfl fun j hj => ?_\n        rw [intervalIntegral.sum_integral_adjacent_intervals_Ico ((mem_range.1 hj).le.trans hKN)]\n        intro k _\n        exact continuous_const.intervalIntegrable _ _\n      _ = ∑ i ∈ range N, ∑ j ∈ range (min (i + 1) K), ∫ _ in i..(i + 1 : ℕ), (1 : ℝ) ∂ρ := by\n        simp_rw [sum_sigma']\n        refine sum_nbij' (fun p ↦ ⟨p.2, p.1⟩) (fun p ↦ ⟨p.2, p.1⟩) ?_ ?_ ?_ ?_ ?_ <;>\n          aesop (add simp Nat.lt_succ_iff)\n      _ ≤ ∑ i ∈ range N, (i + 1) * ∫ _ in i..(i + 1 : ℕ), (1 : ℝ) ∂ρ := by\n        apply sum_le_sum fun i _ => ?_\n        simp only [Nat.cast_add, Nat.cast_one, sum_const, card_range, nsmul_eq_mul, Nat.cast_min]\n        refine mul_le_mul_of_nonneg_right (min_le_left _ _) ?_\n        apply intervalIntegral.integral_nonneg\n        · simp only [le_add_iff_nonneg_right, zero_le_one]\n        · simp only [zero_le_one, imp_true_iff]\n      _ ≤ ∑ i ∈ range N, ∫ x in i..(i + 1 : ℕ), x + 1 ∂ρ := by\n        apply sum_le_sum fun i _ => ?_\n        have I : (i : ℝ) ≤ (i + 1 : ℕ) := by\n          simp only [Nat.cast_add, Nat.cast_one, le_add_iff_nonneg_right, zero_le_one]\n        simp_rw [intervalIntegral.integral_of_le I, ← integral_mul_left]\n        apply setIntegral_mono_on\n        · exact continuous_const.integrableOn_Ioc\n        · exact (continuous_id.add continuous_const).integrableOn_Ioc\n        · exact measurableSet_Ioc\n        · intro x hx\n          simp only [Nat.cast_add, Nat.cast_one, Set.mem_Ioc] at hx\n          simp [hx.1.le]\n      _ = ∫ x in (0)..N, x + 1 ∂ρ := by\n        rw [intervalIntegral.sum_integral_adjacent_intervals fun k _ => ?_]\n        · norm_cast\n        · exact (continuous_id.add continuous_const).intervalIntegrable _ _\n      _ = ∫ x in (0)..N, x ∂ρ + ∫ x in (0)..N, 1 ∂ρ := by\n        rw [intervalIntegral.integral_add]\n        · exact continuous_id.intervalIntegrable _ _\n        · exact continuous_const.intervalIntegrable _ _\n      _ = 𝔼[truncation X N] + ∫ x in (0)..N, 1 ∂ρ := by\n        rw [integral_truncation_eq_intervalIntegral_of_nonneg hint.1 hnonneg]\n      _ ≤ 𝔼[X] + ∫ x in (0)..N, 1 ∂ρ :=\n        (add_le_add_right (integral_truncation_le_integral_of_nonneg hint hnonneg) _)\n      _ ≤ 𝔼[X] + 1 := by\n        refine add_le_add le_rfl ?_\n        rw [intervalIntegral.integral_of_le (Nat.cast_nonneg _)]\n        simp only [integral_const, Measure.restrict_apply', measurableSet_Ioc, Set.univ_inter,\n          Algebra.id.smul_eq_mul, mul_one]\n        rw [← ENNReal.one_toReal]\n        exact ENNReal.toReal_mono ENNReal.one_ne_top prob_le_one\n  have B : ∀ a b, ℙ {ω | X ω ∈ Set.Ioc a b} = ENNReal.ofReal (∫ _ in Set.Ioc a b, (1 : ℝ) ∂ρ) := by\n    intro a b\n    rw [ofReal_setIntegral_one ρ _,\n      Measure.map_apply_of_aemeasurable hint.aemeasurable measurableSet_Ioc]\n    rfl\n  calc\n    ∑ j ∈ range K, ℙ {ω | X ω ∈ Set.Ioc (j : ℝ) N} =\n        ∑ j ∈ range K, ENNReal.ofReal (∫ _ in Set.Ioc (j : ℝ) N, (1 : ℝ) ∂ρ) := by simp_rw [B]\n    _ = ENNReal.ofReal (∑ j ∈ range K, ∫ _ in Set.Ioc (j : ℝ) N, (1 : ℝ) ∂ρ) := by\n      rw [ENNReal.ofReal_sum_of_nonneg]\n      simp only [integral_const, Algebra.id.smul_eq_mul, mul_one, ENNReal.toReal_nonneg,\n        imp_true_iff]\n    _ = ENNReal.ofReal (∑ j ∈ range K, ∫ _ in (j : ℝ)..N, (1 : ℝ) ∂ρ) := by\n      congr 1\n      refine sum_congr rfl fun j hj => ?_\n      rw [intervalIntegral.integral_of_le (Nat.cast_le.2 ((mem_range.1 hj).le.trans hKN))]\n    _ ≤ ENNReal.ofReal (𝔼[X] + 1) := ENNReal.ofReal_le_ofReal A\n\n"}
{"name":"ProbabilityTheory.tsum_prob_mem_Ioi_lt_top","module":"Mathlib.Probability.StrongLaw","initialProofState":"Ω : Type u_1\ninst✝¹ : MeasureTheory.MeasureSpace Ω\ninst✝ : MeasureTheory.IsProbabilityMeasure MeasureTheory.MeasureSpace.volume\nX : Ω → Real\nhint : MeasureTheory.Integrable X MeasureTheory.MeasureSpace.volume\nhnonneg : LE.le 0 X\n⊢ LT.lt (tsum fun j => MeasureTheory.MeasureSpace.volume (setOf fun ω => Membership.mem (Set.Ioi ↑j) (X ω))) Top.top","decl":"theorem tsum_prob_mem_Ioi_lt_top {X : Ω → ℝ} (hint : Integrable X) (hnonneg : 0 ≤ X) :\n    (∑' j : ℕ, ℙ {ω | X ω ∈ Set.Ioi (j : ℝ)}) < ∞ := by\n  suffices ∀ K : ℕ, ∑ j ∈ range K, ℙ {ω | X ω ∈ Set.Ioi (j : ℝ)} ≤ ENNReal.ofReal (𝔼[X] + 1) from\n    (le_of_tendsto_of_tendsto (ENNReal.tendsto_nat_tsum _) tendsto_const_nhds\n      (Eventually.of_forall this)).trans_lt ENNReal.ofReal_lt_top\n  intro K\n  have A : Tendsto (fun N : ℕ => ∑ j ∈ range K, ℙ {ω | X ω ∈ Set.Ioc (j : ℝ) N}) atTop\n      (𝓝 (∑ j ∈ range K, ℙ {ω | X ω ∈ Set.Ioi (j : ℝ)})) := by\n    refine tendsto_finset_sum _ fun i _ => ?_\n    have : {ω | X ω ∈ Set.Ioi (i : ℝ)} = ⋃ N : ℕ, {ω | X ω ∈ Set.Ioc (i : ℝ) N} := by\n      apply Set.Subset.antisymm _ _\n      · intro ω hω\n        obtain ⟨N, hN⟩ : ∃ N : ℕ, X ω ≤ N := exists_nat_ge (X ω)\n        exact Set.mem_iUnion.2 ⟨N, hω, hN⟩\n      · simp (config := {contextual := true}) only [Set.mem_Ioc, Set.mem_Ioi,\n          Set.iUnion_subset_iff, Set.setOf_subset_setOf, imp_true_iff]\n    rw [this]\n    apply tendsto_measure_iUnion_atTop\n    intro m n hmn x hx\n    exact ⟨hx.1, hx.2.trans (Nat.cast_le.2 hmn)⟩\n  apply le_of_tendsto_of_tendsto A tendsto_const_nhds\n  filter_upwards [Ici_mem_atTop K] with N hN\n  exact sum_prob_mem_Ioc_le hint hnonneg hN\n\n"}
{"name":"ProbabilityTheory.sum_variance_truncation_le","module":"Mathlib.Probability.StrongLaw","initialProofState":"Ω : Type u_1\ninst✝¹ : MeasureTheory.MeasureSpace Ω\ninst✝ : MeasureTheory.IsProbabilityMeasure MeasureTheory.MeasureSpace.volume\nX : Ω → Real\nhint : MeasureTheory.Integrable X MeasureTheory.MeasureSpace.volume\nhnonneg : LE.le 0 X\nK : Nat\n⊢ LE.le ((Finset.range K).sum fun j => HMul.hMul (Inv.inv (HPow.hPow (↑j) 2)) (MeasureTheory.integral MeasureTheory.MeasureSpace.volume fun a => HPow.hPow (ProbabilityTheory.truncation X ↑j) 2 a)) (HMul.hMul 2 (MeasureTheory.integral MeasureTheory.MeasureSpace.volume fun a => X a))","decl":"theorem sum_variance_truncation_le {X : Ω → ℝ} (hint : Integrable X) (hnonneg : 0 ≤ X) (K : ℕ) :\n    ∑ j ∈ range K, ((j : ℝ) ^ 2)⁻¹ * 𝔼[truncation X j ^ 2] ≤ 2 * 𝔼[X] := by\n  set Y := fun n : ℕ => truncation X n\n  let ρ : Measure ℝ := Measure.map X ℙ\n  have Y2 : ∀ n, 𝔼[Y n ^ 2] = ∫ x in (0)..n, x ^ 2 ∂ρ := by\n    intro n\n    change 𝔼[fun x => Y n x ^ 2] = _\n    rw [moment_truncation_eq_intervalIntegral_of_nonneg hint.1 two_ne_zero hnonneg]\n  calc\n    ∑ j ∈ range K, ((j : ℝ) ^ 2)⁻¹ * 𝔼[Y j ^ 2] =\n        ∑ j ∈ range K, ((j : ℝ) ^ 2)⁻¹ * ∫ x in (0)..j, x ^ 2 ∂ρ := by simp_rw [Y2]\n    _ = ∑ j ∈ range K, ((j : ℝ) ^ 2)⁻¹ * ∑ k ∈ range j, ∫ x in k..(k + 1 : ℕ), x ^ 2 ∂ρ := by\n      congr 1 with j\n      congr 1\n      rw [intervalIntegral.sum_integral_adjacent_intervals]\n      · norm_cast\n      intro k _\n      exact (continuous_id.pow _).intervalIntegrable _ _\n    _ = ∑ k ∈ range K, (∑ j ∈ Ioo k K, ((j : ℝ) ^ 2)⁻¹) * ∫ x in k..(k + 1 : ℕ), x ^ 2 ∂ρ := by\n      simp_rw [mul_sum, sum_mul, sum_sigma']\n      refine sum_nbij' (fun p ↦ ⟨p.2, p.1⟩) (fun p ↦ ⟨p.2, p.1⟩) ?_ ?_ ?_ ?_ ?_ <;>\n        aesop (add unsafe lt_trans)\n    _ ≤ ∑ k ∈ range K, 2 / (k + 1 : ℝ) * ∫ x in k..(k + 1 : ℕ), x ^ 2 ∂ρ := by\n      apply sum_le_sum fun k _ => ?_\n      refine mul_le_mul_of_nonneg_right (sum_Ioo_inv_sq_le _ _) ?_\n      refine intervalIntegral.integral_nonneg_of_forall ?_ fun u => sq_nonneg _\n      simp only [Nat.cast_add, Nat.cast_one, le_add_iff_nonneg_right, zero_le_one]\n    _ ≤ ∑ k ∈ range K, ∫ x in k..(k + 1 : ℕ), 2 * x ∂ρ := by\n      apply sum_le_sum fun k _ => ?_\n      have Ik : (k : ℝ) ≤ (k + 1 : ℕ) := by simp\n      rw [← intervalIntegral.integral_const_mul, intervalIntegral.integral_of_le Ik,\n        intervalIntegral.integral_of_le Ik]\n      refine setIntegral_mono_on ?_ ?_ measurableSet_Ioc fun x hx => ?_\n      · apply Continuous.integrableOn_Ioc\n        exact continuous_const.mul (continuous_pow 2)\n      · apply Continuous.integrableOn_Ioc\n        exact continuous_const.mul continuous_id'\n      · calc\n          ↑2 / (↑k + ↑1) * x ^ 2 = x / (k + 1) * (2 * x) := by ring\n          _ ≤ 1 * (2 * x) :=\n            (mul_le_mul_of_nonneg_right (by\n              convert (div_le_one _).2 hx.2\n              · norm_cast\n              simp only [Nat.cast_add, Nat.cast_one]\n              linarith only [show (0 : ℝ) ≤ k from Nat.cast_nonneg k])\n              (mul_nonneg zero_le_two ((Nat.cast_nonneg k).trans hx.1.le)))\n          _ = 2 * x := by rw [one_mul]\n    _ = 2 * ∫ x in (0 : ℝ)..K, x ∂ρ := by\n      rw [intervalIntegral.sum_integral_adjacent_intervals fun k _ => ?_]\n      swap; · exact (continuous_const.mul continuous_id').intervalIntegrable _ _\n      rw [intervalIntegral.integral_const_mul]\n      norm_cast\n    _ ≤ 2 * 𝔼[X] := mul_le_mul_of_nonneg_left (by\n      rw [← integral_truncation_eq_intervalIntegral_of_nonneg hint.1 hnonneg]\n      exact integral_truncation_le_integral_of_nonneg hint hnonneg) zero_le_two\n\n"}
{"name":"ProbabilityTheory.strong_law_aux1","module":"Mathlib.Probability.StrongLaw","initialProofState":"Ω : Type u_1\ninst✝¹ : MeasureTheory.MeasureSpace Ω\ninst✝ : MeasureTheory.IsProbabilityMeasure MeasureTheory.MeasureSpace.volume\nX : Nat → Ω → Real\nhint : MeasureTheory.Integrable (X 0) MeasureTheory.MeasureSpace.volume\nhindep : Pairwise (Function.onFun (fun f g => ProbabilityTheory.IndepFun f g MeasureTheory.MeasureSpace.volume) X)\nhident : ∀ (i : Nat), ProbabilityTheory.IdentDistrib (X i) (X 0) MeasureTheory.MeasureSpace.volume MeasureTheory.MeasureSpace.volume\nhnonneg : ∀ (i : Nat) (ω : Ω), LE.le 0 (X i ω)\nc : Real\nc_one : LT.lt 1 c\nε : Real\nεpos : LT.lt 0 ε\n⊢ Filter.Eventually (fun ω => Filter.Eventually (fun n => LT.lt (abs (HSub.hSub ((Finset.range (Nat.floor (HPow.hPow c n))).sum fun i => ProbabilityTheory.truncation (X i) (↑i) ω) (MeasureTheory.integral MeasureTheory.MeasureSpace.volume fun a => (Finset.range (Nat.floor (HPow.hPow c n))).sum (fun i => ProbabilityTheory.truncation (X i) ↑i) a))) (HMul.hMul ε ↑(Nat.floor (HPow.hPow c n)))) Filter.atTop) (MeasureTheory.ae MeasureTheory.MeasureSpace.volume)","decl":"include hint hindep hident hnonneg in\n/-- The truncation of `Xᵢ` up to `i` satisfies the strong law of large numbers (with respect to\nthe truncated expectation) along the sequence `c^n`, for any `c > 1`, up to a given `ε > 0`.\nThis follows from a variance control. -/\ntheorem strong_law_aux1 {c : ℝ} (c_one : 1 < c) {ε : ℝ} (εpos : 0 < ε) : ∀ᵐ ω, ∀ᶠ n : ℕ in atTop,\n    |∑ i ∈ range ⌊c ^ n⌋₊, truncation (X i) i ω - 𝔼[∑ i ∈ range ⌊c ^ n⌋₊, truncation (X i) i]| <\n    ε * ⌊c ^ n⌋₊ := by\n  /- Let `S n = ∑ i ∈ range n, Y i` where `Y i = truncation (X i) i`. We should show that\n    `|S k - 𝔼[S k]| / k ≤ ε` along the sequence of powers of `c`. For this, we apply Borel-Cantelli:\n    it suffices to show that the converse probabilities are summable. From Chebyshev inequality,\n    this will follow from a variance control `∑' Var[S (c^i)] / (c^i)^2 < ∞`. This is checked in\n    `I2` using pairwise independence to expand the variance of the sum as the sum of the variances,\n    and then a straightforward but tedious computation (essentially boiling down to the fact that\n    the sum of `1/(c ^ i)^2` beyond a threshold `j` is comparable to `1/j^2`).\n    Note that we have written `c^i` in the above proof sketch, but rigorously one should put integer\n    parts everywhere, making things more painful. We write `u i = ⌊c^i⌋₊` for brevity. -/\n  have c_pos : 0 < c := zero_lt_one.trans c_one\n  have hX : ∀ i, AEStronglyMeasurable (X i) ℙ := fun i =>\n    (hident i).symm.aestronglyMeasurable_snd hint.1\n  have A : ∀ i, StronglyMeasurable (indicator (Set.Ioc (-i : ℝ) i) id) := fun i =>\n    stronglyMeasurable_id.indicator measurableSet_Ioc\n  set Y := fun n : ℕ => truncation (X n) n\n  set S := fun n => ∑ i ∈ range n, Y i with hS\n  let u : ℕ → ℕ := fun n => ⌊c ^ n⌋₊\n  have u_mono : Monotone u := fun i j hij => Nat.floor_mono (pow_right_mono₀ c_one.le hij)\n  have I1 : ∀ K, ∑ j ∈ range K, ((j : ℝ) ^ 2)⁻¹ * Var[Y j] ≤ 2 * 𝔼[X 0] := by\n    intro K\n    calc\n      ∑ j ∈ range K, ((j : ℝ) ^ 2)⁻¹ * Var[Y j] ≤\n          ∑ j ∈ range K, ((j : ℝ) ^ 2)⁻¹ * 𝔼[truncation (X 0) j ^ 2] := by\n        apply sum_le_sum fun j _ => ?_\n        refine mul_le_mul_of_nonneg_left ?_ (inv_nonneg.2 (sq_nonneg _))\n        rw [(hident j).truncation.variance_eq]\n        exact variance_le_expectation_sq (hX 0).truncation\n      _ ≤ 2 * 𝔼[X 0] := sum_variance_truncation_le hint (hnonneg 0) K\n  let C := c ^ 5 * (c - 1)⁻¹ ^ 3 * (2 * 𝔼[X 0])\n  have I2 : ∀ N, ∑ i ∈ range N, ((u i : ℝ) ^ 2)⁻¹ * Var[S (u i)] ≤ C := by\n    intro N\n    calc\n      ∑ i ∈ range N, ((u i : ℝ) ^ 2)⁻¹ * Var[S (u i)] =\n          ∑ i ∈ range N, ((u i : ℝ) ^ 2)⁻¹ * ∑ j ∈ range (u i), Var[Y j] := by\n        congr 1 with i\n        congr 1\n        rw [hS, IndepFun.variance_sum]\n        · intro j _\n          exact (hident j).aestronglyMeasurable_fst.memℒp_truncation\n        · intro k _ l _ hkl\n          exact (hindep hkl).comp (A k).measurable (A l).measurable\n      _ = ∑ j ∈ range (u (N - 1)), (∑ i ∈ range N with j < u i, ((u i : ℝ) ^ 2)⁻¹) * Var[Y j] := by\n        simp_rw [mul_sum, sum_mul, sum_sigma']\n        refine sum_nbij' (fun p ↦ ⟨p.2, p.1⟩) (fun p ↦ ⟨p.2, p.1⟩) ?_ ?_ ?_ ?_ ?_\n        · simp only [mem_sigma, mem_range, filter_congr_decidable, mem_filter, and_imp,\n            Sigma.forall]\n          exact fun a b haN hb ↦ ⟨hb.trans_le <| u_mono <| Nat.le_pred_of_lt haN, haN, hb⟩\n        all_goals simp\n      _ ≤ ∑ j ∈ range (u (N - 1)), c ^ 5 * (c - 1)⁻¹ ^ 3 / ↑j ^ 2 * Var[Y j] := by\n        apply sum_le_sum fun j hj => ?_\n        rcases eq_zero_or_pos j with (rfl | hj)\n        · simp only [Nat.cast_zero, zero_pow, Ne, Nat.one_ne_zero,\n            not_false_iff, div_zero, zero_mul]\n          simp only [Y, Nat.cast_zero, truncation_zero, variance_zero, mul_zero, le_rfl]\n        apply mul_le_mul_of_nonneg_right _ (variance_nonneg _ _)\n        convert sum_div_nat_floor_pow_sq_le_div_sq N (Nat.cast_pos.2 hj) c_one using 2\n        · simp only [u, Nat.cast_lt]\n        · simp only [Y, S, u, C, one_div]\n      _ = c ^ 5 * (c - 1)⁻¹ ^ 3 * ∑ j ∈ range (u (N - 1)), ((j : ℝ) ^ 2)⁻¹ * Var[Y j] := by\n        simp_rw [mul_sum, div_eq_mul_inv, mul_assoc]\n      _ ≤ c ^ 5 * (c - 1)⁻¹ ^ 3 * (2 * 𝔼[X 0]) := by\n        apply mul_le_mul_of_nonneg_left (I1 _)\n        apply mul_nonneg (pow_nonneg c_pos.le _)\n        exact pow_nonneg (inv_nonneg.2 (sub_nonneg.2 c_one.le)) _\n  have I3 : ∀ N, ∑ i ∈ range N, ℙ {ω | (u i * ε : ℝ) ≤ |S (u i) ω - 𝔼[S (u i)]|} ≤\n      ENNReal.ofReal (ε⁻¹ ^ 2 * C) := by\n    intro N\n    calc\n      ∑ i ∈ range N, ℙ {ω | (u i * ε : ℝ) ≤ |S (u i) ω - 𝔼[S (u i)]|} ≤\n          ∑ i ∈ range N, ENNReal.ofReal (Var[S (u i)] / (u i * ε) ^ 2) := by\n        refine sum_le_sum fun i _ => ?_\n        apply meas_ge_le_variance_div_sq\n        · exact memℒp_finset_sum' _ fun j _ => (hident j).aestronglyMeasurable_fst.memℒp_truncation\n        · apply mul_pos (Nat.cast_pos.2 _) εpos\n          refine zero_lt_one.trans_le ?_\n          apply Nat.le_floor\n          rw [Nat.cast_one]\n          apply one_le_pow₀ c_one.le\n      _ = ENNReal.ofReal (∑ i ∈ range N, Var[S (u i)] / (u i * ε) ^ 2) := by\n        rw [ENNReal.ofReal_sum_of_nonneg fun i _ => ?_]\n        exact div_nonneg (variance_nonneg _ _) (sq_nonneg _)\n      _ ≤ ENNReal.ofReal (ε⁻¹ ^ 2 * C) := by\n        apply ENNReal.ofReal_le_ofReal\n        -- Porting note: do most of the rewrites under `conv` so as not to expand `variance`\n        conv_lhs =>\n          enter [2, i]\n          rw [div_eq_inv_mul, ← inv_pow, mul_inv, mul_comm _ ε⁻¹, mul_pow, mul_assoc]\n        rw [← mul_sum]\n        refine mul_le_mul_of_nonneg_left ?_ (sq_nonneg _)\n        conv_lhs => enter [2, i]; rw [inv_pow]\n        exact I2 N\n  have I4 : (∑' i, ℙ {ω | (u i * ε : ℝ) ≤ |S (u i) ω - 𝔼[S (u i)]|}) < ∞ :=\n    (le_of_tendsto_of_tendsto' (ENNReal.tendsto_nat_tsum _) tendsto_const_nhds I3).trans_lt\n      ENNReal.ofReal_lt_top\n  filter_upwards [ae_eventually_not_mem I4.ne] with ω hω\n  simp_rw [S, not_le, mul_comm, sum_apply] at hω\n  convert hω; simp only [Y, S, u, C, sum_apply]\n\n"}
{"name":"ProbabilityTheory.strong_law_aux2","module":"Mathlib.Probability.StrongLaw","initialProofState":"Ω : Type u_1\ninst✝¹ : MeasureTheory.MeasureSpace Ω\ninst✝ : MeasureTheory.IsProbabilityMeasure MeasureTheory.MeasureSpace.volume\nX : Nat → Ω → Real\nhint : MeasureTheory.Integrable (X 0) MeasureTheory.MeasureSpace.volume\nhindep : Pairwise (Function.onFun (fun f g => ProbabilityTheory.IndepFun f g MeasureTheory.MeasureSpace.volume) X)\nhident : ∀ (i : Nat), ProbabilityTheory.IdentDistrib (X i) (X 0) MeasureTheory.MeasureSpace.volume MeasureTheory.MeasureSpace.volume\nhnonneg : ∀ (i : Nat) (ω : Ω), LE.le 0 (X i ω)\nc : Real\nc_one : LT.lt 1 c\n⊢ Filter.Eventually (fun ω => Asymptotics.IsLittleO Filter.atTop (fun n => HSub.hSub ((Finset.range (Nat.floor (HPow.hPow c n))).sum fun i => ProbabilityTheory.truncation (X i) (↑i) ω) (MeasureTheory.integral MeasureTheory.MeasureSpace.volume fun a => (Finset.range (Nat.floor (HPow.hPow c n))).sum (fun i => ProbabilityTheory.truncation (X i) ↑i) a)) fun n => ↑(Nat.floor (HPow.hPow c n))) (MeasureTheory.ae MeasureTheory.MeasureSpace.volume)","decl":"include hint hindep hident hnonneg in\n/- The truncation of `Xᵢ` up to `i` satisfies the strong law of large numbers\n(with respect to the truncated expectation) along the sequence\n`c^n`, for any `c > 1`. This follows from `strong_law_aux1` by varying `ε`. -/\ntheorem strong_law_aux2 {c : ℝ} (c_one : 1 < c) :\n    ∀ᵐ ω, (fun n : ℕ => ∑ i ∈ range ⌊c ^ n⌋₊, truncation (X i) i ω -\n      𝔼[∑ i ∈ range ⌊c ^ n⌋₊, truncation (X i) i]) =o[atTop] fun n : ℕ => (⌊c ^ n⌋₊ : ℝ) := by\n  obtain ⟨v, -, v_pos, v_lim⟩ :\n      ∃ v : ℕ → ℝ, StrictAnti v ∧ (∀ n : ℕ, 0 < v n) ∧ Tendsto v atTop (𝓝 0) :=\n    exists_seq_strictAnti_tendsto (0 : ℝ)\n  have := fun i => strong_law_aux1 X hint hindep hident hnonneg c_one (v_pos i)\n  filter_upwards [ae_all_iff.2 this] with ω hω\n  apply Asymptotics.isLittleO_iff.2 fun ε εpos => ?_\n  obtain ⟨i, hi⟩ : ∃ i, v i < ε := ((tendsto_order.1 v_lim).2 ε εpos).exists\n  filter_upwards [hω i] with n hn\n  simp only [Real.norm_eq_abs, abs_abs, Nat.abs_cast]\n  exact hn.le.trans (mul_le_mul_of_nonneg_right hi.le (Nat.cast_nonneg _))\n\n"}
{"name":"ProbabilityTheory.strong_law_aux3","module":"Mathlib.Probability.StrongLaw","initialProofState":"Ω : Type u_1\ninst✝¹ : MeasureTheory.MeasureSpace Ω\ninst✝ : MeasureTheory.IsProbabilityMeasure MeasureTheory.MeasureSpace.volume\nX : Nat → Ω → Real\nhint : MeasureTheory.Integrable (X 0) MeasureTheory.MeasureSpace.volume\nhident : ∀ (i : Nat), ProbabilityTheory.IdentDistrib (X i) (X 0) MeasureTheory.MeasureSpace.volume MeasureTheory.MeasureSpace.volume\n⊢ Asymptotics.IsLittleO Filter.atTop (fun n => HSub.hSub (MeasureTheory.integral MeasureTheory.MeasureSpace.volume fun a => (Finset.range n).sum (fun i => ProbabilityTheory.truncation (X i) ↑i) a) (HMul.hMul (↑n) (MeasureTheory.integral MeasureTheory.MeasureSpace.volume fun a => X 0 a))) Nat.cast","decl":"include hint hident in\n/-- The expectation of the truncated version of `Xᵢ` behaves asymptotically like the whole\nexpectation. This follows from convergence and Cesàro averaging. -/\ntheorem strong_law_aux3 :\n    (fun n => 𝔼[∑ i ∈ range n, truncation (X i) i] - n * 𝔼[X 0]) =o[atTop] ((↑) : ℕ → ℝ) := by\n  have A : Tendsto (fun i => 𝔼[truncation (X i) i]) atTop (𝓝 𝔼[X 0]) := by\n    convert (tendsto_integral_truncation hint).comp tendsto_natCast_atTop_atTop using 1\n    ext i\n    exact (hident i).truncation.integral_eq\n  convert Asymptotics.isLittleO_sum_range_of_tendsto_zero (tendsto_sub_nhds_zero_iff.2 A) using 1\n  ext1 n\n  simp only [sum_sub_distrib, sum_const, card_range, nsmul_eq_mul, sum_apply, sub_left_inj]\n  rw [integral_finset_sum _ fun i _ => ?_]\n  exact ((hident i).symm.integrable_snd hint).1.integrable_truncation\n\n"}
{"name":"ProbabilityTheory.strong_law_aux4","module":"Mathlib.Probability.StrongLaw","initialProofState":"Ω : Type u_1\ninst✝¹ : MeasureTheory.MeasureSpace Ω\ninst✝ : MeasureTheory.IsProbabilityMeasure MeasureTheory.MeasureSpace.volume\nX : Nat → Ω → Real\nhint : MeasureTheory.Integrable (X 0) MeasureTheory.MeasureSpace.volume\nhindep : Pairwise (Function.onFun (fun f g => ProbabilityTheory.IndepFun f g MeasureTheory.MeasureSpace.volume) X)\nhident : ∀ (i : Nat), ProbabilityTheory.IdentDistrib (X i) (X 0) MeasureTheory.MeasureSpace.volume MeasureTheory.MeasureSpace.volume\nhnonneg : ∀ (i : Nat) (ω : Ω), LE.le 0 (X i ω)\nc : Real\nc_one : LT.lt 1 c\n⊢ Filter.Eventually (fun ω => Asymptotics.IsLittleO Filter.atTop (fun n => HSub.hSub ((Finset.range (Nat.floor (HPow.hPow c n))).sum fun i => ProbabilityTheory.truncation (X i) (↑i) ω) (HMul.hMul (↑(Nat.floor (HPow.hPow c n))) (MeasureTheory.integral MeasureTheory.MeasureSpace.volume fun a => X 0 a))) fun n => ↑(Nat.floor (HPow.hPow c n))) (MeasureTheory.ae MeasureTheory.MeasureSpace.volume)","decl":"include hint hindep hident hnonneg in\n/- The truncation of `Xᵢ` up to `i` satisfies the strong law of large numbers\n(with respect to the original expectation) along the sequence\n`c^n`, for any `c > 1`. This follows from the version from the truncated expectation, and the\nfact that the truncated and the original expectations have the same asymptotic behavior. -/\ntheorem strong_law_aux4 {c : ℝ} (c_one : 1 < c) :\n    ∀ᵐ ω, (fun n : ℕ => ∑ i ∈ range ⌊c ^ n⌋₊, truncation (X i) i ω - ⌊c ^ n⌋₊ * 𝔼[X 0]) =o[atTop]\n    fun n : ℕ => (⌊c ^ n⌋₊ : ℝ) := by\n  filter_upwards [strong_law_aux2 X hint hindep hident hnonneg c_one] with ω hω\n  have A : Tendsto (fun n : ℕ => ⌊c ^ n⌋₊) atTop atTop :=\n    tendsto_nat_floor_atTop.comp (tendsto_pow_atTop_atTop_of_one_lt c_one)\n  convert hω.add ((strong_law_aux3 X hint hident).comp_tendsto A) using 1\n  ext1 n\n  simp\n\n"}
{"name":"ProbabilityTheory.strong_law_aux5","module":"Mathlib.Probability.StrongLaw","initialProofState":"Ω : Type u_1\ninst✝¹ : MeasureTheory.MeasureSpace Ω\ninst✝ : MeasureTheory.IsProbabilityMeasure MeasureTheory.MeasureSpace.volume\nX : Nat → Ω → Real\nhint : MeasureTheory.Integrable (X 0) MeasureTheory.MeasureSpace.volume\nhident : ∀ (i : Nat), ProbabilityTheory.IdentDistrib (X i) (X 0) MeasureTheory.MeasureSpace.volume MeasureTheory.MeasureSpace.volume\nhnonneg : ∀ (i : Nat) (ω : Ω), LE.le 0 (X i ω)\n⊢ Filter.Eventually (fun ω => Asymptotics.IsLittleO Filter.atTop (fun n => HSub.hSub ((Finset.range n).sum fun i => ProbabilityTheory.truncation (X i) (↑i) ω) ((Finset.range n).sum fun i => X i ω)) fun n => ↑n) (MeasureTheory.ae MeasureTheory.MeasureSpace.volume)","decl":"include hint hident hnonneg in\n/-- The truncated and non-truncated versions of `Xᵢ` have the same asymptotic behavior, as they\nalmost surely coincide at all but finitely many steps. This follows from a probability computation\nand Borel-Cantelli. -/\ntheorem strong_law_aux5 :\n    ∀ᵐ ω, (fun n : ℕ => ∑ i ∈ range n, truncation (X i) i ω - ∑ i ∈ range n, X i ω) =o[atTop]\n    fun n : ℕ => (n : ℝ) := by\n  have A : (∑' j : ℕ, ℙ {ω | X j ω ∈ Set.Ioi (j : ℝ)}) < ∞ := by\n    convert tsum_prob_mem_Ioi_lt_top hint (hnonneg 0) using 2\n    ext1 j\n    exact (hident j).measure_mem_eq measurableSet_Ioi\n  have B : ∀ᵐ ω, Tendsto (fun n : ℕ => truncation (X n) n ω - X n ω) atTop (𝓝 0) := by\n    filter_upwards [ae_eventually_not_mem A.ne] with ω hω\n    apply tendsto_const_nhds.congr' _\n    filter_upwards [hω, Ioi_mem_atTop 0] with n hn npos\n    simp only [truncation, indicator, Set.mem_Ioc, id, Function.comp_apply]\n    split_ifs with h\n    · exact (sub_self _).symm\n    · have : -(n : ℝ) < X n ω := by\n        apply lt_of_lt_of_le _ (hnonneg n ω)\n        simpa only [Right.neg_neg_iff, Nat.cast_pos] using npos\n      simp only [this, true_and, not_le] at h\n      exact (hn h).elim\n  filter_upwards [B] with ω hω\n  convert isLittleO_sum_range_of_tendsto_zero hω using 1\n  ext n\n  rw [sum_sub_distrib]\n\n"}
{"name":"ProbabilityTheory.strong_law_aux6","module":"Mathlib.Probability.StrongLaw","initialProofState":"Ω : Type u_1\ninst✝¹ : MeasureTheory.MeasureSpace Ω\ninst✝ : MeasureTheory.IsProbabilityMeasure MeasureTheory.MeasureSpace.volume\nX : Nat → Ω → Real\nhint : MeasureTheory.Integrable (X 0) MeasureTheory.MeasureSpace.volume\nhindep : Pairwise (Function.onFun (fun f g => ProbabilityTheory.IndepFun f g MeasureTheory.MeasureSpace.volume) X)\nhident : ∀ (i : Nat), ProbabilityTheory.IdentDistrib (X i) (X 0) MeasureTheory.MeasureSpace.volume MeasureTheory.MeasureSpace.volume\nhnonneg : ∀ (i : Nat) (ω : Ω), LE.le 0 (X i ω)\nc : Real\nc_one : LT.lt 1 c\n⊢ Filter.Eventually (fun ω => Filter.Tendsto (fun n => HDiv.hDiv ((Finset.range (Nat.floor (HPow.hPow c n))).sum fun i => X i ω) ↑(Nat.floor (HPow.hPow c n))) Filter.atTop (nhds (MeasureTheory.integral MeasureTheory.MeasureSpace.volume fun a => X 0 a))) (MeasureTheory.ae MeasureTheory.MeasureSpace.volume)","decl":"include hint hindep hident hnonneg in\n/- `Xᵢ` satisfies the strong law of large numbers along the sequence\n`c^n`, for any `c > 1`. This follows from the version for the truncated `Xᵢ`, and the fact that\n`Xᵢ` and its truncated version have the same asymptotic behavior. -/\ntheorem strong_law_aux6 {c : ℝ} (c_one : 1 < c) :\n    ∀ᵐ ω, Tendsto (fun n : ℕ => (∑ i ∈ range ⌊c ^ n⌋₊, X i ω) / ⌊c ^ n⌋₊) atTop (𝓝 𝔼[X 0]) := by\n  have H : ∀ n : ℕ, (0 : ℝ) < ⌊c ^ n⌋₊ := by\n    intro n\n    refine zero_lt_one.trans_le ?_\n    simp only [Nat.one_le_cast, Nat.one_le_floor_iff, one_le_pow₀ c_one.le]\n  filter_upwards [strong_law_aux4 X hint hindep hident hnonneg c_one,\n    strong_law_aux5 X hint hident hnonneg] with ω hω h'ω\n  rw [← tendsto_sub_nhds_zero_iff, ← Asymptotics.isLittleO_one_iff ℝ]\n  have L : (fun n : ℕ => ∑ i ∈ range ⌊c ^ n⌋₊, X i ω - ⌊c ^ n⌋₊ * 𝔼[X 0]) =o[atTop] fun n =>\n      (⌊c ^ n⌋₊ : ℝ) := by\n    have A : Tendsto (fun n : ℕ => ⌊c ^ n⌋₊) atTop atTop :=\n      tendsto_nat_floor_atTop.comp (tendsto_pow_atTop_atTop_of_one_lt c_one)\n    convert hω.sub (h'ω.comp_tendsto A) using 1\n    ext1 n\n    simp only [Function.comp_apply, sub_sub_sub_cancel_left]\n  convert L.mul_isBigO (isBigO_refl (fun n : ℕ => (⌊c ^ n⌋₊ : ℝ)⁻¹) atTop) using 1 <;>\n  (ext1 n; field_simp [(H n).ne'])\n\n"}
{"name":"ProbabilityTheory.strong_law_aux7","module":"Mathlib.Probability.StrongLaw","initialProofState":"Ω : Type u_1\ninst✝¹ : MeasureTheory.MeasureSpace Ω\ninst✝ : MeasureTheory.IsProbabilityMeasure MeasureTheory.MeasureSpace.volume\nX : Nat → Ω → Real\nhint : MeasureTheory.Integrable (X 0) MeasureTheory.MeasureSpace.volume\nhindep : Pairwise (Function.onFun (fun f g => ProbabilityTheory.IndepFun f g MeasureTheory.MeasureSpace.volume) X)\nhident : ∀ (i : Nat), ProbabilityTheory.IdentDistrib (X i) (X 0) MeasureTheory.MeasureSpace.volume MeasureTheory.MeasureSpace.volume\nhnonneg : ∀ (i : Nat) (ω : Ω), LE.le 0 (X i ω)\n⊢ Filter.Eventually (fun ω => Filter.Tendsto (fun n => HDiv.hDiv ((Finset.range n).sum fun i => X i ω) ↑n) Filter.atTop (nhds (MeasureTheory.integral MeasureTheory.MeasureSpace.volume fun a => X 0 a))) (MeasureTheory.ae MeasureTheory.MeasureSpace.volume)","decl":"include hint hindep hident hnonneg in\n/-- `Xᵢ` satisfies the strong law of large numbers along all integers. This follows from the\ncorresponding fact along the sequences `c^n`, and the fact that any integer can be sandwiched\nbetween `c^n` and `c^(n+1)` with comparably small error if `c` is close enough to `1`\n(which is formalized in `tendsto_div_of_monotone_of_tendsto_div_floor_pow`). -/\ntheorem strong_law_aux7 :\n    ∀ᵐ ω, Tendsto (fun n : ℕ => (∑ i ∈ range n, X i ω) / n) atTop (𝓝 𝔼[X 0]) := by\n  obtain ⟨c, -, cone, clim⟩ :\n      ∃ c : ℕ → ℝ, StrictAnti c ∧ (∀ n : ℕ, 1 < c n) ∧ Tendsto c atTop (𝓝 1) :=\n    exists_seq_strictAnti_tendsto (1 : ℝ)\n  have : ∀ k, ∀ᵐ ω,\n      Tendsto (fun n : ℕ => (∑ i ∈ range ⌊c k ^ n⌋₊, X i ω) / ⌊c k ^ n⌋₊) atTop (𝓝 𝔼[X 0]) :=\n    fun k => strong_law_aux6 X hint hindep hident hnonneg (cone k)\n  filter_upwards [ae_all_iff.2 this] with ω hω\n  apply tendsto_div_of_monotone_of_tendsto_div_floor_pow _ _ _ c cone clim _\n  · intro m n hmn\n    exact sum_le_sum_of_subset_of_nonneg (range_mono hmn) fun i _ _ => hnonneg i ω\n  · exact hω\n\n"}
{"name":"ProbabilityTheory.strong_law_ae_real","module":"Mathlib.Probability.StrongLaw","initialProofState":"Ω : Type u_2\nm : MeasurableSpace Ω\nμ : MeasureTheory.Measure Ω\nX : Nat → Ω → Real\nhint : MeasureTheory.Integrable (X 0) μ\nhindep : Pairwise (Function.onFun (fun x1 x2 => ProbabilityTheory.IndepFun x1 x2 μ) X)\nhident : ∀ (i : Nat), ProbabilityTheory.IdentDistrib (X i) (X 0) μ μ\n⊢ Filter.Eventually (fun ω => Filter.Tendsto (fun n => HDiv.hDiv ((Finset.range n).sum fun i => X i ω) ↑n) Filter.atTop (nhds (MeasureTheory.integral μ fun x => X 0 x))) (MeasureTheory.ae μ)","decl":"/-- **Strong law of large numbers**, almost sure version: if `X n` is a sequence of independent\nidentically distributed integrable real-valued random variables, then `∑ i ∈ range n, X i / n`\nconverges almost surely to `𝔼[X 0]`. We give here the strong version, due to Etemadi, that only\nrequires pairwise independence. Superseded by `strong_law_ae`, which works for random variables\ntaking values in any Banach space. -/\ntheorem strong_law_ae_real {Ω : Type*} {m : MeasurableSpace Ω} {μ : Measure Ω}\n    (X : ℕ → Ω → ℝ) (hint : Integrable (X 0) μ)\n    (hindep : Pairwise ((IndepFun · · μ) on X))\n    (hident : ∀ i, IdentDistrib (X i) (X 0) μ μ) :\n    ∀ᵐ ω ∂μ, Tendsto (fun n : ℕ => (∑ i ∈ range n, X i ω) / n) atTop (𝓝 μ[X 0]) := by\n  let mΩ : MeasureSpace Ω := ⟨μ⟩\n  -- first get rid of the trivial case where the space is not a probability space\n  by_cases h : ∀ᵐ ω, X 0 ω = 0\n  · have I : ∀ᵐ ω, ∀ i, X i ω = 0 := by\n      rw [ae_all_iff]\n      intro i\n      exact (hident i).symm.ae_snd (p := fun x ↦ x = 0) measurableSet_eq h\n    filter_upwards [I] with ω hω\n    simpa [hω] using (integral_eq_zero_of_ae h).symm\n  have : IsProbabilityMeasure μ :=\n    hint.isProbabilityMeasure_of_indepFun (X 0) (X 1) h (hindep zero_ne_one)\n  -- then consider separately the positive and the negative part, and apply the result\n  -- for nonnegative functions to them.\n  let pos : ℝ → ℝ := fun x => max x 0\n  let neg : ℝ → ℝ := fun x => max (-x) 0\n  have posm : Measurable pos := measurable_id'.max measurable_const\n  have negm : Measurable neg := measurable_id'.neg.max measurable_const\n  have A : ∀ᵐ ω, Tendsto (fun n : ℕ => (∑ i ∈ range n, (pos ∘ X i) ω) / n) atTop (𝓝 𝔼[pos ∘ X 0]) :=\n    strong_law_aux7 _ hint.pos_part (fun i j hij => (hindep hij).comp posm posm)\n      (fun i => (hident i).comp posm) fun i ω => le_max_right _ _\n  have B : ∀ᵐ ω, Tendsto (fun n : ℕ => (∑ i ∈ range n, (neg ∘ X i) ω) / n) atTop (𝓝 𝔼[neg ∘ X 0]) :=\n    strong_law_aux7 _ hint.neg_part (fun i j hij => (hindep hij).comp negm negm)\n      (fun i => (hident i).comp negm) fun i ω => le_max_right _ _\n  filter_upwards [A, B] with ω hωpos hωneg\n  convert hωpos.sub hωneg using 2\n  · simp only [pos, neg, ← sub_div, ← sum_sub_distrib, max_zero_sub_max_neg_zero_eq_self,\n      Function.comp_apply]\n  · simp only [pos, neg, ← integral_sub hint.pos_part hint.neg_part,\n      max_zero_sub_max_neg_zero_eq_self, Function.comp_apply, mΩ]\n\n"}
{"name":"ProbabilityTheory.strong_law_ae_simpleFunc_comp","module":"Mathlib.Probability.StrongLaw","initialProofState":"Ω : Type u_1\nmΩ : MeasurableSpace Ω\nμ : MeasureTheory.Measure Ω\ninst✝⁴ : MeasureTheory.IsProbabilityMeasure μ\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace Real E\ninst✝¹ : CompleteSpace E\ninst✝ : MeasurableSpace E\nX : Nat → Ω → E\nh' : Measurable (X 0)\nhindep : Pairwise (Function.onFun (fun x1 x2 => ProbabilityTheory.IndepFun x1 x2 μ) X)\nhident : ∀ (i : Nat), ProbabilityTheory.IdentDistrib (X i) (X 0) μ μ\nφ : MeasureTheory.SimpleFunc E E\n⊢ Filter.Eventually (fun ω => Filter.Tendsto (fun n => HSMul.hSMul (Inv.inv ↑n) ((Finset.range n).sum fun i => φ (X i ω))) Filter.atTop (nhds (MeasureTheory.integral μ fun x => Function.comp (⇑φ) (X 0) x))) (MeasureTheory.ae μ)","decl":"/-- Preliminary lemma for the strong law of large numbers for vector-valued random variables:\nthe composition of the random variables with a simple function satisfies the strong law of large\nnumbers. -/\nlemma strong_law_ae_simpleFunc_comp (X : ℕ → Ω → E) (h' : Measurable (X 0))\n    (hindep : Pairwise ((IndepFun · · μ) on X))\n    (hident : ∀ i, IdentDistrib (X i) (X 0) μ μ) (φ : SimpleFunc E E) :\n    ∀ᵐ ω ∂μ,\n      Tendsto (fun n : ℕ ↦ (n : ℝ) ⁻¹ • (∑ i ∈ range n, φ (X i ω))) atTop (𝓝 μ[φ ∘ (X 0)]) := by\n  -- this follows from the one-dimensional version when `φ` takes a single value, and is then\n  -- extended to the general case by linearity.\n  classical\n  refine SimpleFunc.induction (P := fun ψ ↦ ∀ᵐ ω ∂μ,\n    Tendsto (fun n : ℕ ↦ (n : ℝ) ⁻¹ • (∑ i ∈ range n, ψ (X i ω))) atTop (𝓝 μ[ψ ∘ (X 0)])) ?_ ?_ φ\n  · intro c s hs\n    simp only [SimpleFunc.const_zero, SimpleFunc.coe_piecewise, SimpleFunc.coe_const,\n      SimpleFunc.coe_zero, piecewise_eq_indicator, Function.comp_apply]\n    let F : E → ℝ := indicator s 1\n    have F_meas : Measurable F := (measurable_indicator_const_iff 1).2 hs\n    let Y : ℕ → Ω → ℝ := fun n ↦ F ∘ (X n)\n    have : ∀ᵐ (ω : Ω) ∂μ, Tendsto (fun (n : ℕ) ↦ (n : ℝ)⁻¹ • ∑ i ∈ Finset.range n, Y i ω)\n        atTop (𝓝 μ[Y 0]) := by\n      simp only [Function.const_one, smul_eq_mul, ← div_eq_inv_mul]\n      apply strong_law_ae_real\n      · exact SimpleFunc.integrable_of_isFiniteMeasure\n          ((SimpleFunc.piecewise s hs (SimpleFunc.const _ (1 : ℝ))\n            (SimpleFunc.const _ (0 : ℝ))).comp (X 0) h')\n      · exact fun i j hij ↦ IndepFun.comp (hindep hij) F_meas F_meas\n      · exact fun i ↦ (hident i).comp F_meas\n    filter_upwards [this] with ω hω\n    have I : indicator s (Function.const E c) = (fun x ↦ (indicator s (1 : E → ℝ) x) • c) := by\n      ext\n      rw [← indicator_smul_const_apply]\n      congr! 1\n      ext\n      simp\n    simp only [I, integral_smul_const]\n    convert Tendsto.smul_const hω c using 1\n    simp [F, Y, ← sum_smul, smul_smul]\n  · rintro φ ψ - hφ hψ\n    filter_upwards [hφ, hψ] with ω hωφ hωψ\n    convert hωφ.add hωψ using 1\n    · simp [sum_add_distrib]\n    · congr 1\n      rw [← integral_add]\n      · rfl\n      · exact (φ.comp (X 0) h').integrable_of_isFiniteMeasure\n      · exact (ψ.comp (X 0) h').integrable_of_isFiniteMeasure\n\n"}
{"name":"ProbabilityTheory.strong_law_ae_of_measurable","module":"Mathlib.Probability.StrongLaw","initialProofState":"Ω : Type u_1\nmΩ : MeasurableSpace Ω\nμ : MeasureTheory.Measure Ω\ninst✝⁵ : MeasureTheory.IsProbabilityMeasure μ\nE : Type u_2\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace Real E\ninst✝² : CompleteSpace E\ninst✝¹ : MeasurableSpace E\ninst✝ : BorelSpace E\nX : Nat → Ω → E\nhint : MeasureTheory.Integrable (X 0) μ\nh' : MeasureTheory.StronglyMeasurable (X 0)\nhindep : Pairwise (Function.onFun (fun x1 x2 => ProbabilityTheory.IndepFun x1 x2 μ) X)\nhident : ∀ (i : Nat), ProbabilityTheory.IdentDistrib (X i) (X 0) μ μ\n⊢ Filter.Eventually (fun ω => Filter.Tendsto (fun n => HSMul.hSMul (Inv.inv ↑n) ((Finset.range n).sum fun i => X i ω)) Filter.atTop (nhds (MeasureTheory.integral μ fun x => X 0 x))) (MeasureTheory.ae μ)","decl":"/-- Preliminary lemma for the strong law of large numbers for vector-valued random variables,\nassuming measurability in addition to integrability. This is weakened to ae measurability in\nthe full version `ProbabilityTheory.strong_law_ae`. -/\nlemma strong_law_ae_of_measurable\n    (X : ℕ → Ω → E) (hint : Integrable (X 0) μ) (h' : StronglyMeasurable (X 0))\n    (hindep : Pairwise ((IndepFun · · μ) on X))\n    (hident : ∀ i, IdentDistrib (X i) (X 0) μ μ) :\n    ∀ᵐ ω ∂μ, Tendsto (fun n : ℕ ↦ (n : ℝ) ⁻¹ • (∑ i ∈ range n, X i ω)) atTop (𝓝 μ[X 0]) := by\n  /- Choose a simple function `φ` such that `φ (X 0)` approximates well enough `X 0` -- this is\n  possible as `X 0` is strongly measurable. Then `φ (X n)` approximates well `X n`.\n  Then the strong law for `φ (X n)` implies the strong law for `X n`, up to a small\n  error controlled by `n⁻¹ ∑_{i=0}^{n-1} ‖X i - φ (X i)‖`. This one is also controlled thanks\n  to the one-dimensional law of large numbers: it converges ae to `𝔼[‖X 0 - φ (X 0)‖]`, which\n  is arbitrarily small for well chosen `φ`. -/\n  let s : Set E := Set.range (X 0) ∪ {0}\n  have zero_s : 0 ∈ s := by simp [s]\n  have : SeparableSpace s := h'.separableSpace_range_union_singleton\n  have : Nonempty s := ⟨0, zero_s⟩\n  -- sequence of approximating simple functions.\n  let φ : ℕ → SimpleFunc E E :=\n    SimpleFunc.nearestPt (fun k => Nat.casesOn k 0 ((↑) ∘ denseSeq s) : ℕ → E)\n  let Y : ℕ → ℕ → Ω → E := fun k i ↦ (φ k) ∘ (X i)\n  -- strong law for `φ (X n)`\n  have A : ∀ᵐ ω ∂μ, ∀ k,\n      Tendsto (fun n : ℕ ↦ (n : ℝ) ⁻¹ • (∑ i ∈ range n, Y k i ω)) atTop (𝓝 μ[Y k 0]) :=\n    ae_all_iff.2 (fun k ↦ strong_law_ae_simpleFunc_comp X h'.measurable hindep hident (φ k))\n  -- strong law for the error `‖X i - φ (X i)‖`\n  have B : ∀ᵐ ω ∂μ, ∀ k, Tendsto (fun n : ℕ ↦ (∑ i ∈ range n, ‖(X i - Y k i) ω‖) / n)\n        atTop (𝓝 μ[(fun ω ↦ ‖(X 0 - Y k 0) ω‖)]) := by\n    apply ae_all_iff.2 (fun k ↦ ?_)\n    let G : ℕ → E → ℝ := fun k x ↦ ‖x - φ k x‖\n    have G_meas : ∀ k, Measurable (G k) :=\n      fun k ↦ (measurable_id.sub_stronglyMeasurable (φ k).stronglyMeasurable).norm\n    have I : ∀ k i, (fun ω ↦ ‖(X i - Y k i) ω‖) = (G k) ∘ (X i) := fun k i ↦ rfl\n    apply strong_law_ae_real (fun i ω ↦ ‖(X i - Y k i) ω‖)\n    · exact (hint.sub ((φ k).comp (X 0) h'.measurable).integrable_of_isFiniteMeasure).norm\n    · unfold Function.onFun\n      simp_rw [I]\n      intro i j hij\n      exact (hindep hij).comp (G_meas k) (G_meas k)\n    · intro i\n      simp_rw [I]\n      apply (hident i).comp (G_meas k)\n  -- check that, when both convergences above hold, then the strong law is satisfied\n  filter_upwards [A, B] with ω hω h'ω\n  rw [tendsto_iff_norm_sub_tendsto_zero, tendsto_order]\n  refine ⟨fun c hc ↦ Eventually.of_forall (fun n ↦ hc.trans_le (norm_nonneg _)), ?_⟩\n  -- start with some positive `ε` (the desired precision), and fix `δ` with `3 δ < ε`.\n  intro ε (εpos : 0 < ε)\n  obtain ⟨δ, δpos, hδ⟩ : ∃ δ, 0 < δ ∧ δ + δ + δ < ε := ⟨ε/4, by positivity, by linarith⟩\n  -- choose `k` large enough so that `φₖ (X 0)` approximates well enough `X 0`, up to the\n  -- precision `δ`.\n  obtain ⟨k, hk⟩ : ∃ k, ∫ ω, ‖(X 0 - Y k 0) ω‖ ∂μ < δ := by\n    simp_rw [Pi.sub_apply, norm_sub_rev (X 0 _)]\n    exact ((tendsto_order.1 (tendsto_integral_norm_approxOn_sub h'.measurable hint)).2 δ\n      δpos).exists\n  have : ‖μ[Y k 0] - μ[X 0]‖ < δ := by\n    rw [norm_sub_rev, ← integral_sub hint]\n    · exact (norm_integral_le_integral_norm _).trans_lt hk\n    · exact ((φ k).comp (X 0) h'.measurable).integrable_of_isFiniteMeasure\n  -- consider `n` large enough for which the above convergences have taken place within `δ`.\n  have I : ∀ᶠ n in atTop, (∑ i ∈ range n, ‖(X i - Y k i) ω‖) / n < δ :=\n    (tendsto_order.1 (h'ω k)).2 δ hk\n  have J : ∀ᶠ (n : ℕ) in atTop, ‖(n : ℝ) ⁻¹ • (∑ i ∈ range n, Y k i ω) - μ[Y k 0]‖ < δ := by\n    specialize hω k\n    rw [tendsto_iff_norm_sub_tendsto_zero] at hω\n    exact (tendsto_order.1 hω).2 δ δpos\n  filter_upwards [I, J] with n hn h'n\n  -- at such an `n`, the strong law is realized up to `ε`.\n  calc\n  ‖(n : ℝ)⁻¹ • ∑ i ∈ Finset.range n, X i ω - μ[X 0]‖\n    = ‖(n : ℝ)⁻¹ • ∑ i ∈ Finset.range n, (X i ω - Y k i ω) +\n        ((n : ℝ)⁻¹ • ∑ i ∈ Finset.range n, Y k i ω - μ[Y k 0]) + (μ[Y k 0] - μ[X 0])‖ := by\n      congr\n      simp only [Function.comp_apply, sum_sub_distrib, smul_sub]\n      abel\n  _ ≤ ‖(n : ℝ)⁻¹ • ∑ i ∈ Finset.range n, (X i ω - Y k i ω)‖ +\n        ‖(n : ℝ)⁻¹ • ∑ i ∈ Finset.range n, Y k i ω - μ[Y k 0]‖ + ‖μ[Y k 0] - μ[X 0]‖ :=\n      norm_add₃_le\n  _ ≤ (∑ i ∈ Finset.range n, ‖X i ω - Y k i ω‖) / n + δ + δ := by\n      gcongr\n      simp only [Function.comp_apply, norm_smul, norm_inv, RCLike.norm_natCast,\n        div_eq_inv_mul, inv_pos, Nat.cast_pos, inv_lt_zero]\n      gcongr\n      exact norm_sum_le _ _\n  _ ≤ δ + δ + δ := by\n      gcongr\n      exact hn.le\n  _ < ε := hδ\n\n"}
{"name":"ProbabilityTheory.strong_law_ae","module":"Mathlib.Probability.StrongLaw","initialProofState":"Ω : Type u_1\nmΩ : MeasurableSpace Ω\nμ : MeasureTheory.Measure Ω\nE : Type u_2\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace Real E\ninst✝² : CompleteSpace E\ninst✝¹ : MeasurableSpace E\ninst✝ : BorelSpace E\nX : Nat → Ω → E\nhint : MeasureTheory.Integrable (X 0) μ\nhindep : Pairwise (Function.onFun (fun x1 x2 => ProbabilityTheory.IndepFun x1 x2 μ) X)\nhident : ∀ (i : Nat), ProbabilityTheory.IdentDistrib (X i) (X 0) μ μ\n⊢ Filter.Eventually (fun ω => Filter.Tendsto (fun n => HSMul.hSMul (Inv.inv ↑n) ((Finset.range n).sum fun i => X i ω)) Filter.atTop (nhds (MeasureTheory.integral μ fun x => X 0 x))) (MeasureTheory.ae μ)","decl":"omit [IsProbabilityMeasure μ] in\n/-- **Strong law of large numbers**, almost sure version: if `X n` is a sequence of independent\nidentically distributed integrable random variables taking values in a Banach space,\nthen `n⁻¹ • ∑ i ∈ range n, X i` converges almost surely to `𝔼[X 0]`. We give here the strong\nversion, due to Etemadi, that only requires pairwise independence. -/\ntheorem strong_law_ae (X : ℕ → Ω → E) (hint : Integrable (X 0) μ)\n    (hindep : Pairwise ((IndepFun · · μ) on X))\n    (hident : ∀ i, IdentDistrib (X i) (X 0) μ μ) :\n    ∀ᵐ ω ∂μ, Tendsto (fun n : ℕ ↦ (n : ℝ) ⁻¹ • (∑ i ∈ range n, X i ω)) atTop (𝓝 μ[X 0]) := by\n  -- First exclude the trivial case where the space is not a probability space\n  by_cases h : ∀ᵐ ω ∂μ, X 0 ω = 0\n  · have I : ∀ᵐ ω ∂μ, ∀ i, X i ω = 0 := by\n      rw [ae_all_iff]\n      intro i\n      exact (hident i).symm.ae_snd (p := fun x ↦ x = 0) measurableSet_eq h\n    filter_upwards [I] with ω hω\n    simpa [hω] using (integral_eq_zero_of_ae h).symm\n  have : IsProbabilityMeasure μ :=\n    hint.isProbabilityMeasure_of_indepFun (X 0) (X 1) h (hindep zero_ne_one)\n  -- we reduce to the case of strongly measurable random variables, by using `Y i` which is strongly\n  -- measurable and ae equal to `X i`.\n  have A : ∀ i, Integrable (X i) μ := fun i ↦ (hident i).integrable_iff.2 hint\n  let Y : ℕ → Ω → E := fun i ↦ (A i).1.mk (X i)\n  have B : ∀ᵐ ω ∂μ, ∀ n, X n ω = Y n ω :=\n    ae_all_iff.2 (fun i ↦ AEStronglyMeasurable.ae_eq_mk (A i).1)\n  have Yint : Integrable (Y 0) μ := Integrable.congr hint (AEStronglyMeasurable.ae_eq_mk (A 0).1)\n  have C : ∀ᵐ ω ∂μ,\n      Tendsto (fun n : ℕ ↦ (n : ℝ) ⁻¹ • (∑ i ∈ range n, Y i ω)) atTop (𝓝 μ[Y 0]) := by\n    apply strong_law_ae_of_measurable Y Yint ((A 0).1.stronglyMeasurable_mk)\n      (fun i j hij ↦ IndepFun.ae_eq (hindep hij) (A i).1.ae_eq_mk (A j).1.ae_eq_mk)\n      (fun i ↦ ((A i).1.identDistrib_mk.symm.trans (hident i)).trans (A 0).1.identDistrib_mk)\n  filter_upwards [B, C] with ω h₁ h₂\n  have : μ[X 0] = μ[Y 0] := integral_congr_ae (AEStronglyMeasurable.ae_eq_mk (A 0).1)\n  rw [this]\n  apply Tendsto.congr (fun n ↦ ?_) h₂\n  congr with i\n  exact (h₁ i).symm\n\n"}
{"name":"ProbabilityTheory.strong_law_Lp","module":"Mathlib.Probability.StrongLaw","initialProofState":"Ω : Type u_1\nmΩ : MeasurableSpace Ω\nμ : MeasureTheory.Measure Ω\nE : Type u_2\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace Real E\ninst✝² : CompleteSpace E\ninst✝¹ : MeasurableSpace E\ninst✝ : BorelSpace E\np : ENNReal\nhp : LE.le 1 p\nhp' : Ne p Top.top\nX : Nat → Ω → E\nhℒp : MeasureTheory.Memℒp (X 0) p μ\nhindep : Pairwise (Function.onFun (fun x1 x2 => ProbabilityTheory.IndepFun x1 x2 μ) X)\nhident : ∀ (i : Nat), ProbabilityTheory.IdentDistrib (X i) (X 0) μ μ\n⊢ Filter.Tendsto (fun n => MeasureTheory.eLpNorm (fun ω => HSub.hSub (HSMul.hSMul (Inv.inv ↑n) ((Finset.range n).sum fun i => X i ω)) (MeasureTheory.integral μ fun x => X 0 x)) p μ) Filter.atTop (nhds 0)","decl":"/-- **Strong law of large numbers**, Lᵖ version: if `X n` is a sequence of independent\nidentically distributed random variables in Lᵖ, then `n⁻¹ • ∑ i ∈ range n, X i`\nconverges in `Lᵖ` to `𝔼[X 0]`. -/\ntheorem strong_law_Lp {p : ℝ≥0∞} (hp : 1 ≤ p) (hp' : p ≠ ∞) (X : ℕ → Ω → E)\n    (hℒp : Memℒp (X 0) p μ) (hindep : Pairwise ((IndepFun · · μ) on X))\n    (hident : ∀ i, IdentDistrib (X i) (X 0) μ μ) :\n    Tendsto (fun (n : ℕ) => eLpNorm (fun ω => (n : ℝ) ⁻¹ • (∑ i ∈ range n, X i ω) - μ[X 0]) p μ)\n      atTop (𝓝 0) := by\n  -- First exclude the trivial case where the space is not a probability space\n  by_cases h : ∀ᵐ ω ∂μ, X 0 ω = 0\n  · have I : ∀ᵐ ω ∂μ, ∀ i, X i ω = 0 := by\n      rw [ae_all_iff]\n      intro i\n      exact (hident i).symm.ae_snd (p := fun x ↦ x = 0) measurableSet_eq h\n    have A (n : ℕ) : eLpNorm (fun ω => (n : ℝ) ⁻¹ • (∑ i ∈ range n, X i ω) - μ[X 0]) p μ = 0 := by\n      simp only [integral_eq_zero_of_ae h, sub_zero]\n      apply eLpNorm_eq_zero_of_ae_zero\n      filter_upwards [I] with ω hω\n      simp [hω]\n    simp [A]\n  -- Then use ae convergence and uniform integrability\n  have : IsProbabilityMeasure μ := Memℒp.isProbabilityMeasure_of_indepFun\n    (X 0) (X 1) (zero_lt_one.trans_le hp).ne' hp' hℒp h (hindep zero_ne_one)\n  have hmeas : ∀ i, AEStronglyMeasurable (X i) μ := fun i =>\n    (hident i).aestronglyMeasurable_iff.2 hℒp.1\n  have hint : Integrable (X 0) μ := hℒp.integrable hp\n  have havg (n : ℕ) :\n      AEStronglyMeasurable (fun ω => (n : ℝ) ⁻¹ • (∑ i ∈ range n, X i ω)) μ :=\n    AEStronglyMeasurable.const_smul (aestronglyMeasurable_sum _ fun i _ => hmeas i) _\n  refine tendsto_Lp_finite_of_tendstoInMeasure hp hp' havg (memℒp_const _) ?_\n    (tendstoInMeasure_of_tendsto_ae havg (strong_law_ae _ hint hindep hident))\n  rw [(_ : (fun (n : ℕ) ω => (n : ℝ)⁻¹ • (∑ i ∈ range n, X i ω))\n            = fun (n : ℕ) => (n : ℝ)⁻¹ • (∑ i ∈ range n, X i))]\n  · apply UniformIntegrable.unifIntegrable\n    apply uniformIntegrable_average hp\n    exact Memℒp.uniformIntegrable_of_identDistrib hp hp' hℒp hident\n  · ext n ω\n    simp only [Pi.smul_apply, sum_apply]\n\n"}
