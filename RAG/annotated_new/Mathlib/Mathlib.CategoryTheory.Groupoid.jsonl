{"name":"CategoryTheory.Groupoid.comp_inv","module":"Mathlib.CategoryTheory.Groupoid","initialProofState":"obj : Type u\nself : CategoryTheory.Groupoid obj\nX Y : obj\nf : Quiver.Hom X Y\n⊢ Eq (CategoryTheory.CategoryStruct.comp f (CategoryTheory.Groupoid.inv f)) (CategoryTheory.CategoryStruct.id X)","decl":"/-- A `Groupoid` is a category such that all morphisms are isomorphisms. -/\nclass Groupoid (obj : Type u) extends Category.{v} obj : Type max u (v + 1) where\n  /-- The inverse morphism -/\n  inv : ∀ {X Y : obj}, (X ⟶ Y) → (Y ⟶ X)\n  /-- `inv f` composed `f` is the identity -/\n  inv_comp : ∀ {X Y : obj} (f : X ⟶ Y), comp (inv f) f = id Y := by aesop_cat\n  /-- `f` composed with `inv f` is the identity -/\n  comp_inv : ∀ {X Y : obj} (f : X ⟶ Y), comp f (inv f) = id X := by aesop_cat\n\n"}
{"name":"CategoryTheory.Groupoid.inv_comp","module":"Mathlib.CategoryTheory.Groupoid","initialProofState":"obj : Type u\nself : CategoryTheory.Groupoid obj\nX Y : obj\nf : Quiver.Hom X Y\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Groupoid.inv f) f) (CategoryTheory.CategoryStruct.id Y)","decl":"/-- A `Groupoid` is a category such that all morphisms are isomorphisms. -/\nclass Groupoid (obj : Type u) extends Category.{v} obj : Type max u (v + 1) where\n  /-- The inverse morphism -/\n  inv : ∀ {X Y : obj}, (X ⟶ Y) → (Y ⟶ X)\n  /-- `inv f` composed `f` is the identity -/\n  inv_comp : ∀ {X Y : obj} (f : X ⟶ Y), comp (inv f) f = id Y := by aesop_cat\n  /-- `f` composed with `inv f` is the identity -/\n  comp_inv : ∀ {X Y : obj} (f : X ⟶ Y), comp f (inv f) = id X := by aesop_cat\n\n"}
{"name":"CategoryTheory.IsIso.of_groupoid","module":"Mathlib.CategoryTheory.Groupoid","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Groupoid C\nX Y : C\nf : Quiver.Hom X Y\n⊢ CategoryTheory.IsIso f","decl":"instance (priority := 100) IsIso.of_groupoid (f : X ⟶ Y) : IsIso f :=\n  ⟨⟨Groupoid.inv f, Groupoid.comp_inv f, Groupoid.inv_comp f⟩⟩\n\n"}
{"name":"CategoryTheory.Groupoid.inv_eq_inv","module":"Mathlib.CategoryTheory.Groupoid","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Groupoid C\nX Y : C\nf : Quiver.Hom X Y\n⊢ Eq (CategoryTheory.Groupoid.inv f) (CategoryTheory.inv f)","decl":"@[simp]\ntheorem Groupoid.inv_eq_inv (f : X ⟶ Y) : Groupoid.inv f = CategoryTheory.inv f :=\n  IsIso.eq_inv_of_hom_inv_id <| Groupoid.comp_inv f\n\n"}
{"name":"CategoryTheory.Groupoid.invEquiv_symm_apply","module":"Mathlib.CategoryTheory.Groupoid","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Groupoid C\nX Y : C\na✝ : Quiver.Hom Y X\n⊢ Eq (CategoryTheory.Groupoid.invEquiv.symm a✝) (CategoryTheory.Groupoid.inv a✝)","decl":"/-- `Groupoid.inv` is involutive. -/\n@[simps]\ndef Groupoid.invEquiv : (X ⟶ Y) ≃ (Y ⟶ X) :=\n  ⟨Groupoid.inv, Groupoid.inv, fun f => by simp, fun f => by simp⟩\n\n"}
{"name":"CategoryTheory.Groupoid.invEquiv_apply","module":"Mathlib.CategoryTheory.Groupoid","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Groupoid C\nX Y : C\na✝ : Quiver.Hom X Y\n⊢ Eq (CategoryTheory.Groupoid.invEquiv a✝) (CategoryTheory.Groupoid.inv a✝)","decl":"/-- `Groupoid.inv` is involutive. -/\n@[simps]\ndef Groupoid.invEquiv : (X ⟶ Y) ≃ (Y ⟶ X) :=\n  ⟨Groupoid.inv, Groupoid.inv, fun f => by simp, fun f => by simp⟩\n\n"}
{"name":"CategoryTheory.Groupoid.reverse_eq_inv","module":"Mathlib.CategoryTheory.Groupoid","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Groupoid C\nX Y : C\nf : Quiver.Hom X Y\n⊢ Eq (Quiver.reverse f) (CategoryTheory.Groupoid.inv f)","decl":"@[simp]\ntheorem Groupoid.reverse_eq_inv (f : X ⟶ Y) : Quiver.reverse f = Groupoid.inv f :=\n  rfl\n\n"}
{"name":"CategoryTheory.functorMapReverse","module":"Mathlib.CategoryTheory.Groupoid","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Groupoid C\nD : Type u_1\ninst✝ : CategoryTheory.Groupoid D\nF : CategoryTheory.Functor C D\n⊢ F.MapReverse","decl":"instance functorMapReverse {D : Type*} [Groupoid D] (F : C ⥤ D) : F.toPrefunctor.MapReverse where\n  map_reverse' f := by\n    simp only [Quiver.reverse, Quiver.HasReverse.reverse', Groupoid.inv_eq_inv,\n      Functor.map_inv]\n\n"}
{"name":"CategoryTheory.Groupoid.invFunctor_obj","module":"Mathlib.CategoryTheory.Groupoid","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Groupoid C\nunop : C\n⊢ Eq ((CategoryTheory.Groupoid.invFunctor C).obj unop) { unop := unop }","decl":"/-- The functor from a groupoid `C` to its opposite sending every morphism to its inverse. -/\n@[simps]\nnoncomputable def Groupoid.invFunctor : C ⥤ Cᵒᵖ where\n  obj := Opposite.op\n  map {_ _} f := (inv f).op\n\n"}
{"name":"CategoryTheory.Groupoid.invFunctor_map","module":"Mathlib.CategoryTheory.Groupoid","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Groupoid C\nx✝¹ x✝ : C\nf : Quiver.Hom x✝¹ x✝\n⊢ Eq ((CategoryTheory.Groupoid.invFunctor C).map f) (CategoryTheory.Groupoid.inv f).op","decl":"/-- The functor from a groupoid `C` to its opposite sending every morphism to its inverse. -/\n@[simps]\nnoncomputable def Groupoid.invFunctor : C ⥤ Cᵒᵖ where\n  obj := Opposite.op\n  map {_ _} f := (inv f).op\n\n"}
