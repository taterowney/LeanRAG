{"name":"CategoryTheory.Presheaf.restrictedYoneda_map_app","module":"Mathlib.CategoryTheory.Limits.Presheaf","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\nâ„° : Type uâ‚‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚‚} â„°\nA : CategoryTheory.Functor C â„°\nXâœ Yâœ : â„°\nf : Quiver.Hom Xâœ Yâœ\nX : Opposite C\naâœ : (CategoryTheory.yoneda.obj Xâœ).obj (A.op.obj X)\nâŠ¢ Eq (((CategoryTheory.Presheaf.restrictedYoneda A).map f).app X aâœ) (CategoryTheory.CategoryStruct.comp aâœ f)","decl":"/--\nThe functor taking `(E : â„°) (c : Cáµ’áµ–)` to the homset `(A.obj C âŸ¶ E)`. It is shown in `L_adjunction`\nthat this functor has a left adjoint (provided `E` has colimits) given by taking colimits over\ncategories of elements.\nIn the case where `â„° = Cáµ’áµ– â¥¤ Type u` and `A = yoneda`, this functor is isomorphic to the identity.\n\nDefined as in [MM92], Chapter I, Section 5, Theorem 2.\n-/\n@[simps!]\ndef restrictedYoneda : â„° â¥¤ Cáµ’áµ– â¥¤ Type vâ‚ :=\n  yoneda â‹™ (whiskeringLeft _ _ (Type vâ‚)).obj (Functor.op A)\n\n"}
{"name":"CategoryTheory.Presheaf.restrictedYoneda_obj_obj","module":"Mathlib.CategoryTheory.Limits.Presheaf","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\nâ„° : Type uâ‚‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚‚} â„°\nA : CategoryTheory.Functor C â„°\nXâœ : â„°\nX : Opposite C\nâŠ¢ Eq (((CategoryTheory.Presheaf.restrictedYoneda A).obj Xâœ).obj X) (Quiver.Hom (A.obj (Opposite.unop X)) Xâœ)","decl":"/--\nThe functor taking `(E : â„°) (c : Cáµ’áµ–)` to the homset `(A.obj C âŸ¶ E)`. It is shown in `L_adjunction`\nthat this functor has a left adjoint (provided `E` has colimits) given by taking colimits over\ncategories of elements.\nIn the case where `â„° = Cáµ’áµ– â¥¤ Type u` and `A = yoneda`, this functor is isomorphic to the identity.\n\nDefined as in [MM92], Chapter I, Section 5, Theorem 2.\n-/\n@[simps!]\ndef restrictedYoneda : â„° â¥¤ Cáµ’áµ– â¥¤ Type vâ‚ :=\n  yoneda â‹™ (whiskeringLeft _ _ (Type vâ‚)).obj (Functor.op A)\n\n"}
{"name":"CategoryTheory.Presheaf.restrictedYoneda_obj_map","module":"Mathlib.CategoryTheory.Limits.Presheaf","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\nâ„° : Type uâ‚‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚‚} â„°\nA : CategoryTheory.Functor C â„°\nX : â„°\nXâœ Yâœ : Opposite C\nf : Quiver.Hom Xâœ Yâœ\naâœ : (CategoryTheory.yoneda.obj X).obj (A.op.obj Xâœ)\nâŠ¢ Eq (((CategoryTheory.Presheaf.restrictedYoneda A).obj X).map f aâœ) (CategoryTheory.CategoryStruct.comp (A.map f.unop) aâœ)","decl":"/--\nThe functor taking `(E : â„°) (c : Cáµ’áµ–)` to the homset `(A.obj C âŸ¶ E)`. It is shown in `L_adjunction`\nthat this functor has a left adjoint (provided `E` has colimits) given by taking colimits over\ncategories of elements.\nIn the case where `â„° = Cáµ’áµ– â¥¤ Type u` and `A = yoneda`, this functor is isomorphic to the identity.\n\nDefined as in [MM92], Chapter I, Section 5, Theorem 2.\n-/\n@[simps!]\ndef restrictedYoneda : â„° â¥¤ Cáµ’áµ– â¥¤ Type vâ‚ :=\n  yoneda â‹™ (whiskeringLeft _ _ (Type vâ‚)).obj (Functor.op A)\n\n"}
{"name":"CategoryTheory.Presheaf.preservesColimitsOfSize_of_isLeftKanExtension","module":"Mathlib.CategoryTheory.Limits.Presheaf","initialProofState":"C : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} C\nâ„° : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚‚} â„°\nA : CategoryTheory.Functor C â„°\ninstâœÂ¹ : CategoryTheory.yoneda.HasPointwiseLeftKanExtension A\nL : CategoryTheory.Functor (CategoryTheory.Functor (Opposite C) (Type vâ‚)) â„°\nÎ± : Quiver.Hom A (CategoryTheory.yoneda.comp L)\ninstâœ : L.IsLeftKanExtension Î±\nâŠ¢ CategoryTheory.Limits.PreservesColimitsOfSize.{vâ‚ƒ, uâ‚ƒ, max uâ‚ vâ‚, vâ‚, max uâ‚ (vâ‚ + 1), uâ‚‚} L","decl":"include Î± in\n/-- Any left Kan extension along the Yoneda embedding preserves colimits. -/\nlemma preservesColimitsOfSize_of_isLeftKanExtension :\n    PreservesColimitsOfSize.{vâ‚ƒ, uâ‚ƒ} L :=\n  (yonedaAdjunction L Î±).leftAdjoint_preservesColimits\n\n"}
{"name":"CategoryTheory.Presheaf.isIso_of_isLeftKanExtension","module":"Mathlib.CategoryTheory.Limits.Presheaf","initialProofState":"C : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} C\nâ„° : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚‚} â„°\nA : CategoryTheory.Functor C â„°\ninstâœÂ¹ : CategoryTheory.yoneda.HasPointwiseLeftKanExtension A\nL : CategoryTheory.Functor (CategoryTheory.Functor (Opposite C) (Type vâ‚)) â„°\nÎ± : Quiver.Hom A (CategoryTheory.yoneda.comp L)\ninstâœ : L.IsLeftKanExtension Î±\nâŠ¢ CategoryTheory.IsIso Î±","decl":"lemma isIso_of_isLeftKanExtension : IsIso Î± :=\n  (Functor.isPointwiseLeftKanExtensionOfIsLeftKanExtension _ Î±).isIso_hom\n\n"}
{"name":"CategoryTheory.Presheaf.preservesColimitsOfSize_leftKanExtension","module":"Mathlib.CategoryTheory.Limits.Presheaf","initialProofState":"C : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} C\nâ„° : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚‚} â„°\nA : CategoryTheory.Functor C â„°\ninstâœ : CategoryTheory.yoneda.HasPointwiseLeftKanExtension A\nâŠ¢ CategoryTheory.Limits.PreservesColimitsOfSize.{vâ‚ƒ, uâ‚ƒ, max vâ‚ uâ‚, vâ‚, max (vâ‚ + 1) uâ‚, uâ‚‚} (CategoryTheory.yoneda.leftKanExtension A)","decl":"/-- See Property 2 of https://ncatlab.org/nlab/show/Yoneda+extension#properties. -/\nnoncomputable instance preservesColimitsOfSize_leftKanExtension :\n    PreservesColimitsOfSize.{vâ‚ƒ, uâ‚ƒ} (yoneda.leftKanExtension A) :=\n  (yonedaAdjunction _ (yoneda.leftKanExtensionUnit A)).leftAdjoint_preservesColimits\n\n"}
{"name":"CategoryTheory.Presheaf.instIsIsoFunctorLeftKanExtensionUnitOppositeTypeYoneda","module":"Mathlib.CategoryTheory.Limits.Presheaf","initialProofState":"C : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} C\nâ„° : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚‚} â„°\nA : CategoryTheory.Functor C â„°\ninstâœ : CategoryTheory.yoneda.HasPointwiseLeftKanExtension A\nâŠ¢ CategoryTheory.IsIso (CategoryTheory.yoneda.leftKanExtensionUnit A)","decl":"instance : IsIso (yoneda.leftKanExtensionUnit A) :=\n  isIso_of_isLeftKanExtension _ (yoneda.leftKanExtensionUnit A)\n\n"}
{"name":"CategoryTheory.Presheaf.coconeOfRepresentable_pt","module":"Mathlib.CategoryTheory.Limits.Presheaf","initialProofState":"C : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} C\nP : CategoryTheory.Functor (Opposite C) (Type vâ‚)\nâŠ¢ Eq (CategoryTheory.Presheaf.coconeOfRepresentable P).pt P","decl":"/-- This is a cocone with point `P` for the functor `functorToRepresentables P`. It is shown in\n`colimitOfRepresentable P` that this cocone is a colimit: that is, we have exhibited an arbitrary\npresheaf `P` as a colimit of representables.\n\nThe construction of [MM92], Chapter I, Section 5, Corollary 3.\n-/\n@[simps]\nnoncomputable def coconeOfRepresentable (P : Cáµ’áµ– â¥¤ Type vâ‚) :\n    Cocone (functorToRepresentables P) where\n  pt := P\n  Î¹ :=\n    { app := fun x => yonedaEquiv.symm x.unop.2\n      naturality := fun {xâ‚ xâ‚‚} f => by\n        dsimp\n        rw [comp_id, â† yonedaEquiv_symm_map]\n        congr 1\n        rw [f.unop.2] }\n\n"}
{"name":"CategoryTheory.Presheaf.coconeOfRepresentable_Î¹_app","module":"Mathlib.CategoryTheory.Limits.Presheaf","initialProofState":"C : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} C\nP : CategoryTheory.Functor (Opposite C) (Type vâ‚)\nx : Opposite P.Elements\nâŠ¢ Eq ((CategoryTheory.Presheaf.coconeOfRepresentable P).Î¹.app x) (CategoryTheory.yonedaEquiv.symm (Opposite.unop x).snd)","decl":"/-- This is a cocone with point `P` for the functor `functorToRepresentables P`. It is shown in\n`colimitOfRepresentable P` that this cocone is a colimit: that is, we have exhibited an arbitrary\npresheaf `P` as a colimit of representables.\n\nThe construction of [MM92], Chapter I, Section 5, Corollary 3.\n-/\n@[simps]\nnoncomputable def coconeOfRepresentable (P : Cáµ’áµ– â¥¤ Type vâ‚) :\n    Cocone (functorToRepresentables P) where\n  pt := P\n  Î¹ :=\n    { app := fun x => yonedaEquiv.symm x.unop.2\n      naturality := fun {xâ‚ xâ‚‚} f => by\n        dsimp\n        rw [comp_id, â† yonedaEquiv_symm_map]\n        congr 1\n        rw [f.unop.2] }\n\n"}
{"name":"CategoryTheory.Presheaf.coconeOfRepresentable_naturality","module":"Mathlib.CategoryTheory.Limits.Presheaf","initialProofState":"C : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} C\nPâ‚ Pâ‚‚ : CategoryTheory.Functor (Opposite C) (Type vâ‚)\nÎ± : Quiver.Hom Pâ‚ Pâ‚‚\nj : Opposite Pâ‚.Elements\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Presheaf.coconeOfRepresentable Pâ‚).Î¹.app j) Î±) ((CategoryTheory.Presheaf.coconeOfRepresentable Pâ‚‚).Î¹.app ((CategoryTheory.CategoryOfElements.map Î±).op.obj j))","decl":"/-- The legs of the cocone `coconeOfRepresentable` are natural in the choice of presheaf. -/\ntheorem coconeOfRepresentable_naturality {Pâ‚ Pâ‚‚ : Cáµ’áµ– â¥¤ Type vâ‚} (Î± : Pâ‚ âŸ¶ Pâ‚‚) (j : Pâ‚.Elementsáµ’áµ–) :\n    (coconeOfRepresentable Pâ‚).Î¹.app j â‰« Î± =\n      (coconeOfRepresentable Pâ‚‚).Î¹.app ((CategoryOfElements.map Î±).op.obj j) := by\n  ext T f\n  simpa [coconeOfRepresentable_Î¹_app] using FunctorToTypes.naturality _ _ Î± f.op _\n\n"}
{"name":"CategoryTheory.Presheaf.instIsIsoFunctorOfIsLeftKanExtensionOppositeType","module":"Mathlib.CategoryTheory.Limits.Presheaf","initialProofState":"C : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} C\nâ„° : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚‚} â„°\nA : CategoryTheory.Functor C â„°\ninstâœÂ¹ : CategoryTheory.yoneda.HasPointwiseLeftKanExtension A\nL : CategoryTheory.Functor (CategoryTheory.Functor (Opposite C) (Type vâ‚)) â„°\nÎ± : Quiver.Hom A (CategoryTheory.yoneda.comp L)\ninstâœ : L.IsLeftKanExtension Î±\nâŠ¢ CategoryTheory.IsIso Î±","decl":"instance [L.IsLeftKanExtension Î±] : IsIso Î± :=\n  (Functor.isPointwiseLeftKanExtensionOfIsLeftKanExtension L Î±).isIso_hom\n\n"}
{"name":"CategoryTheory.Presheaf.isLeftKanExtension_along_yoneda_iff","module":"Mathlib.CategoryTheory.Limits.Presheaf","initialProofState":"C : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} C\nâ„° : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚‚} â„°\nA : CategoryTheory.Functor C â„°\ninstâœ : CategoryTheory.yoneda.HasPointwiseLeftKanExtension A\nL : CategoryTheory.Functor (CategoryTheory.Functor (Opposite C) (Type vâ‚)) â„°\nÎ± : Quiver.Hom A (CategoryTheory.yoneda.comp L)\nâŠ¢ Iff (L.IsLeftKanExtension Î±) (And (CategoryTheory.IsIso Î±) (CategoryTheory.Limits.PreservesColimitsOfSize.{vâ‚, max uâ‚ vâ‚, max uâ‚ vâ‚, vâ‚, max uâ‚ (vâ‚ + 1), uâ‚‚} L))","decl":"lemma isLeftKanExtension_along_yoneda_iff :\n    L.IsLeftKanExtension Î± â†”\n      (IsIso Î± âˆ§ PreservesColimitsOfSize.{vâ‚, max uâ‚ vâ‚} L) := by\n  constructor\n  Â· intro\n    exact âŸ¨inferInstance, preservesColimits_of_natIso\n      (Functor.leftKanExtensionUnique _ (yoneda.leftKanExtensionUnit A) _ Î±)âŸ©\n  Â· rintro âŸ¨_, _âŸ©\n    apply Functor.LeftExtension.IsPointwiseLeftKanExtension.isLeftKanExtension\n      (E := Functor.LeftExtension.mk _ Î±)\n    intro P\n    dsimp [Functor.LeftExtension.IsPointwiseLeftKanExtensionAt]\n    apply IsColimit.ofWhiskerEquivalence (CategoryOfElements.costructuredArrowYonedaEquivalence _)\n    let e : CategoryOfElements.toCostructuredArrow P â‹™ CostructuredArrow.proj yoneda P â‹™ A â‰…\n        functorToRepresentables P â‹™ L :=\n      isoWhiskerLeft _ (isoWhiskerLeft _ (asIso Î±)) â‰ªâ‰«\n        isoWhiskerLeft _ (Functor.associator _ _ _).symm â‰ªâ‰«\n        (Functor.associator _ _ _).symm â‰ªâ‰« isoWhiskerRight (Iso.refl _) L\n    apply (IsColimit.precomposeHomEquiv e.symm _).1\n    exact IsColimit.ofIsoColimit (isColimitOfPreserves L (colimitOfRepresentable P))\n      (Cocones.ext (Iso.refl _))\n\n"}
{"name":"CategoryTheory.Presheaf.isLeftKanExtension_of_preservesColimits","module":"Mathlib.CategoryTheory.Limits.Presheaf","initialProofState":"C : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} C\nâ„° : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚‚} â„°\nA : CategoryTheory.Functor C â„°\ninstâœÂ¹ : CategoryTheory.yoneda.HasPointwiseLeftKanExtension A\nL : CategoryTheory.Functor (CategoryTheory.Functor (Opposite C) (Type vâ‚)) â„°\ne : CategoryTheory.Iso A (CategoryTheory.yoneda.comp L)\ninstâœ : CategoryTheory.Limits.PreservesColimitsOfSize.{vâ‚, max uâ‚ vâ‚, max uâ‚ vâ‚, vâ‚, max uâ‚ (vâ‚ + 1), uâ‚‚} L\nâŠ¢ L.IsLeftKanExtension e.hom","decl":"lemma isLeftKanExtension_of_preservesColimits\n    (L : (Cáµ’áµ– â¥¤ Type vâ‚) â¥¤ â„°) (e : A â‰… yoneda â‹™ L)\n    [PreservesColimitsOfSize.{vâ‚, max uâ‚ vâ‚} L] :\n    L.IsLeftKanExtension e.hom := by\n  rw [isLeftKanExtension_along_yoneda_iff]\n  exact âŸ¨inferInstance, âŸ¨inferInstanceâŸ©âŸ©\n\n"}
{"name":"CategoryTheory.Presheaf.instIsLeftKanExtensionFunctorOppositeTypeIdCompYonedaOfPreservesColimitsOfSizeOfHasPointwiseLeftKanExtension","module":"Mathlib.CategoryTheory.Limits.Presheaf","initialProofState":"C : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} C\nâ„° : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚‚} â„°\nL : CategoryTheory.Functor (CategoryTheory.Functor (Opposite C) (Type vâ‚)) â„°\ninstâœÂ¹ : CategoryTheory.Limits.PreservesColimitsOfSize.{vâ‚, max uâ‚ vâ‚, max uâ‚ vâ‚, vâ‚, max uâ‚ (vâ‚ + 1), uâ‚‚} L\ninstâœ : CategoryTheory.yoneda.HasPointwiseLeftKanExtension (CategoryTheory.yoneda.comp L)\nâŠ¢ L.IsLeftKanExtension (CategoryTheory.CategoryStruct.id (CategoryTheory.yoneda.comp L))","decl":"instance (L : (Cáµ’áµ– â¥¤ Type vâ‚) â¥¤ â„°) [PreservesColimitsOfSize.{vâ‚, max uâ‚ vâ‚} L]\n    [yoneda.HasPointwiseLeftKanExtension (yoneda â‹™ L)] :\n    L.IsLeftKanExtension (ðŸ™ _ : yoneda â‹™ L âŸ¶ _) :=\n  isLeftKanExtension_of_preservesColimits _ (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Presheaf.isLeftAdjoint_of_preservesColimits","module":"Mathlib.CategoryTheory.Limits.Presheaf","initialProofState":"C : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} C\nâ„° : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚‚} â„°\nL : CategoryTheory.Functor (CategoryTheory.Functor C (Type vâ‚)) â„°\ninstâœÂ¹ : CategoryTheory.Limits.PreservesColimitsOfSize.{vâ‚, max uâ‚ vâ‚, max uâ‚ vâ‚, vâ‚, max uâ‚ (vâ‚ + 1), uâ‚‚} L\ninstâœ : CategoryTheory.yoneda.HasPointwiseLeftKanExtension (CategoryTheory.yoneda.comp ((CategoryTheory.opOpEquivalence C).congrLeft.functor.comp L))\nâŠ¢ L.IsLeftAdjoint","decl":"/-- If `L` preserves colimits and `â„°` has them, then it is a left adjoint. Note this is a (partial)\nconverse to `leftAdjointPreservesColimits`.\n-/\nlemma isLeftAdjoint_of_preservesColimits (L : (C â¥¤ Type vâ‚) â¥¤ â„°)\n    [PreservesColimitsOfSize.{vâ‚, max uâ‚ vâ‚} L]\n    [yoneda.HasPointwiseLeftKanExtension\n      (yoneda â‹™ (opOpEquivalence C).congrLeft.functor.comp L)] :\n    L.IsLeftAdjoint :=\n  âŸ¨_, âŸ¨((opOpEquivalence C).congrLeft.symm.toAdjunction.comp\n    (yonedaAdjunction _ (ðŸ™ _))).ofNatIsoLeft ((opOpEquivalence C).congrLeft.invFunIdAssoc L)âŸ©âŸ©\n\n"}
{"name":"CategoryTheory.Presheaf.instIsLeftKanExtensionOppositeObjFunctorTypeYonedaYonedaMap","module":"Mathlib.CategoryTheory.Limits.Presheaf","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚‚} D\nF : CategoryTheory.Functor C D\nX : C\nâŠ¢ (CategoryTheory.yoneda.obj (F.obj X)).IsLeftKanExtension (CategoryTheory.yonedaMap F X)","decl":"/-- Given `F : C â¥¤ D` and `X : C`, `yoneda.obj (F.obj X) : Dáµ’áµ– â¥¤ Type _` is the\nleft Kan extension of `yoneda.obj X : Cáµ’áµ– â¥¤ Type _` along `F.op`. -/\ninstance (X : C) : (yoneda.obj (F.obj X)).IsLeftKanExtension (yonedaMap F X) :=\n  âŸ¨âŸ¨Limits.IsInitial.ofUnique _âŸ©âŸ©\n\n"}
{"name":"CategoryTheory.Presheaf.compYonedaIsoYonedaCompLan_inv_app_app_apply_eq_id","module":"Mathlib.CategoryTheory.Limits.Presheaf","initialProofState":"C : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚‚} D\nF : CategoryTheory.Functor C D\ninstâœ : âˆ€ (P : CategoryTheory.Functor (Opposite C) (Type vâ‚)), F.op.HasLeftKanExtension P\nX : C\nâŠ¢ Eq (((CategoryTheory.Presheaf.compYonedaIsoYonedaCompLan F).inv.app X).app { unop := F.obj X } ((F.op.lanUnit.app (CategoryTheory.yoneda.obj X)).app { unop := X } (CategoryTheory.CategoryStruct.id X))) (CategoryTheory.CategoryStruct.id (Opposite.unop { unop := F.obj X }))","decl":"@[simp]\nlemma compYonedaIsoYonedaCompLan_inv_app_app_apply_eq_id (X : C) :\n    ((compYonedaIsoYonedaCompLan F).inv.app X).app (Opposite.op (F.obj X))\n      ((F.op.lanUnit.app (yoneda.obj X)).app _ (ðŸ™ X)) = ðŸ™ _ :=\n  (congr_fun (Functor.descOfIsLeftKanExtension_fac_app _\n    (F.op.lanUnit.app (yoneda.obj X)) _ (yonedaMap F X) (Opposite.op X)) (ðŸ™ _)).trans (by simp)\n\n"}
{"name":"CategoryTheory.Presheaf.compYonedaIsoYonedaCompLan.coconeApp_naturality_assoc","module":"Mathlib.CategoryTheory.Limits.Presheaf","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚‚} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor (CategoryTheory.Functor (Opposite C) (Type vâ‚)) (CategoryTheory.Functor (Opposite D) (Type vâ‚))\nÏ† : Quiver.Hom (F.comp CategoryTheory.yoneda) (CategoryTheory.yoneda.comp G)\nP : CategoryTheory.Functor (Opposite C) (Type vâ‚)\nx y : P.Elements\nf : Quiver.Hom x y\nZ : CategoryTheory.Functor (Opposite C) (Type vâ‚)\nh : Quiver.Hom (F.op.comp (G.obj P)) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.yoneda.map (â†‘f).unop) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Presheaf.compYonedaIsoYonedaCompLan.coconeApp Ï† x) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Presheaf.compYonedaIsoYonedaCompLan.coconeApp Ï† y) h)","decl":"@[reassoc (attr := simp)]\nlemma coconeApp_naturality {P : Cáµ’áµ– â¥¤ Type vâ‚} {x y : P.Elements} (f : x âŸ¶ y) :\n    yoneda.map f.1.unop â‰« coconeApp Ï† x = coconeApp Ï† y := by\n  have eqâ‚ : yoneda.map f.1.unop â‰« yonedaEquiv.symm x.2 = yonedaEquiv.symm y.2 :=\n    yonedaEquiv.injective\n      (by simpa only [Equiv.apply_symm_apply, â† yonedaEquiv_naturality] using f.2)\n  have eqâ‚‚ := congr_fun ((G.map (yonedaEquiv.symm x.2)).naturality (F.map f.1.unop).op)\n    ((Ï†.app x.1.unop).app _ (ðŸ™ _))\n  have eqâ‚ƒ := congr_fun (congr_app (Ï†.naturality f.1.unop) _) (ðŸ™ _)\n  have eqâ‚„ := congr_fun ((Ï†.app x.1.unop).naturality (F.map f.1.unop).op)\n  dsimp at eqâ‚‚ eqâ‚ƒ eqâ‚„\n  apply yonedaEquiv.injective\n  dsimp only [coconeApp]\n  rw [Equiv.apply_symm_apply, â† yonedaEquiv_naturality, Equiv.apply_symm_apply]\n  simp [â† eqâ‚, â† eqâ‚‚, â† eqâ‚ƒ, â† eqâ‚„, Functor.map_comp, FunctorToTypes.comp, id_comp, comp_id]\n\n"}
{"name":"CategoryTheory.Presheaf.compYonedaIsoYonedaCompLan.coconeApp_naturality","module":"Mathlib.CategoryTheory.Limits.Presheaf","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚‚} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor (CategoryTheory.Functor (Opposite C) (Type vâ‚)) (CategoryTheory.Functor (Opposite D) (Type vâ‚))\nÏ† : Quiver.Hom (F.comp CategoryTheory.yoneda) (CategoryTheory.yoneda.comp G)\nP : CategoryTheory.Functor (Opposite C) (Type vâ‚)\nx y : P.Elements\nf : Quiver.Hom x y\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.yoneda.map (â†‘f).unop) (CategoryTheory.Presheaf.compYonedaIsoYonedaCompLan.coconeApp Ï† x)) (CategoryTheory.Presheaf.compYonedaIsoYonedaCompLan.coconeApp Ï† y)","decl":"@[reassoc (attr := simp)]\nlemma coconeApp_naturality {P : Cáµ’áµ– â¥¤ Type vâ‚} {x y : P.Elements} (f : x âŸ¶ y) :\n    yoneda.map f.1.unop â‰« coconeApp Ï† x = coconeApp Ï† y := by\n  have eqâ‚ : yoneda.map f.1.unop â‰« yonedaEquiv.symm x.2 = yonedaEquiv.symm y.2 :=\n    yonedaEquiv.injective\n      (by simpa only [Equiv.apply_symm_apply, â† yonedaEquiv_naturality] using f.2)\n  have eqâ‚‚ := congr_fun ((G.map (yonedaEquiv.symm x.2)).naturality (F.map f.1.unop).op)\n    ((Ï†.app x.1.unop).app _ (ðŸ™ _))\n  have eqâ‚ƒ := congr_fun (congr_app (Ï†.naturality f.1.unop) _) (ðŸ™ _)\n  have eqâ‚„ := congr_fun ((Ï†.app x.1.unop).naturality (F.map f.1.unop).op)\n  dsimp at eqâ‚‚ eqâ‚ƒ eqâ‚„\n  apply yonedaEquiv.injective\n  dsimp only [coconeApp]\n  rw [Equiv.apply_symm_apply, â† yonedaEquiv_naturality, Equiv.apply_symm_apply]\n  simp [â† eqâ‚, â† eqâ‚‚, â† eqâ‚ƒ, â† eqâ‚„, Functor.map_comp, FunctorToTypes.comp, id_comp, comp_id]\n\n"}
{"name":"CategoryTheory.Presheaf.compYonedaIsoYonedaCompLan.yonedaEquiv_Î¹_presheafHom","module":"Mathlib.CategoryTheory.Limits.Presheaf","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚‚} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor (CategoryTheory.Functor (Opposite C) (Type vâ‚)) (CategoryTheory.Functor (Opposite D) (Type vâ‚))\nÏ† : Quiver.Hom (F.comp CategoryTheory.yoneda) (CategoryTheory.yoneda.comp G)\nP : CategoryTheory.Functor (Opposite C) (Type vâ‚)\nX : C\nf : Quiver.Hom (CategoryTheory.yoneda.obj X) P\nâŠ¢ Eq (CategoryTheory.yonedaEquiv (CategoryTheory.CategoryStruct.comp f (CategoryTheory.Presheaf.compYonedaIsoYonedaCompLan.presheafHom Ï† P))) ((G.map f).app { unop := F.obj X } ((Ï†.app X).app { unop := F.obj X } (CategoryTheory.CategoryStruct.id (Opposite.unop { unop := F.obj X }))))","decl":"lemma yonedaEquiv_Î¹_presheafHom (P : Cáµ’áµ– â¥¤ Type vâ‚) {X : C} (f : yoneda.obj X âŸ¶ P) :\n    yonedaEquiv (f â‰« presheafHom Ï† P) =\n      (G.map f).app (Opposite.op (F.obj X)) ((Ï†.app X).app _ (ðŸ™ _)) := by\n  obtain âŸ¨x, rflâŸ© := yonedaEquiv.symm.surjective f\n  erw [(colimitOfRepresentable P).fac _ (Opposite.op (P.elementsMk _ x))]\n  dsimp only [coconeApp]\n  apply Equiv.apply_symm_apply\n\n"}
{"name":"CategoryTheory.Presheaf.compYonedaIsoYonedaCompLan.yonedaEquiv_presheafHom_yoneda_obj","module":"Mathlib.CategoryTheory.Limits.Presheaf","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚‚} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor (CategoryTheory.Functor (Opposite C) (Type vâ‚)) (CategoryTheory.Functor (Opposite D) (Type vâ‚))\nÏ† : Quiver.Hom (F.comp CategoryTheory.yoneda) (CategoryTheory.yoneda.comp G)\nX : C\nâŠ¢ Eq (CategoryTheory.yonedaEquiv (CategoryTheory.Presheaf.compYonedaIsoYonedaCompLan.presheafHom Ï† (CategoryTheory.yoneda.obj X))) ((Ï†.app X).app (F.op.obj { unop := X }) (CategoryTheory.CategoryStruct.id (Opposite.unop (F.op.obj { unop := X }))))","decl":"lemma yonedaEquiv_presheafHom_yoneda_obj (X : C) :\n    yonedaEquiv (presheafHom Ï† (yoneda.obj X)) =\n      ((Ï†.app X).app (F.op.obj (Opposite.op X)) (ðŸ™ _)) := by\n  simpa using yonedaEquiv_Î¹_presheafHom Ï† (yoneda.obj X) (ðŸ™ _)\n\n"}
{"name":"CategoryTheory.Presheaf.compYonedaIsoYonedaCompLan.presheafHom_naturality_assoc","module":"Mathlib.CategoryTheory.Limits.Presheaf","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚‚} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor (CategoryTheory.Functor (Opposite C) (Type vâ‚)) (CategoryTheory.Functor (Opposite D) (Type vâ‚))\nÏ† : Quiver.Hom (F.comp CategoryTheory.yoneda) (CategoryTheory.yoneda.comp G)\nP Q : CategoryTheory.Functor (Opposite C) (Type vâ‚)\nf : Quiver.Hom P Q\nZ : CategoryTheory.Functor (Opposite C) (Type vâ‚)\nh : Quiver.Hom (F.op.comp (G.obj Q)) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Presheaf.compYonedaIsoYonedaCompLan.presheafHom Ï† P) (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerLeft F.op (G.map f)) h)) (CategoryTheory.CategoryStruct.comp f (CategoryTheory.CategoryStruct.comp (CategoryTheory.Presheaf.compYonedaIsoYonedaCompLan.presheafHom Ï† Q) h))","decl":"@[reassoc (attr := simp)]\nlemma presheafHom_naturality {P Q : Cáµ’áµ– â¥¤ Type vâ‚} (f : P âŸ¶ Q) :\n    presheafHom Ï† P â‰« whiskerLeft F.op (G.map f) = f â‰« presheafHom Ï† Q :=\n  hom_ext_yoneda (fun X p => yonedaEquiv.injective (by\n    rw [â† assoc p f, yonedaEquiv_Î¹_presheafHom, â† assoc,\n      yonedaEquiv_comp, yonedaEquiv_Î¹_presheafHom,\n      whiskerLeft_app, Functor.map_comp, FunctorToTypes.comp]\n    dsimp))\n\n"}
{"name":"CategoryTheory.Presheaf.compYonedaIsoYonedaCompLan.presheafHom_naturality","module":"Mathlib.CategoryTheory.Limits.Presheaf","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚‚} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor (CategoryTheory.Functor (Opposite C) (Type vâ‚)) (CategoryTheory.Functor (Opposite D) (Type vâ‚))\nÏ† : Quiver.Hom (F.comp CategoryTheory.yoneda) (CategoryTheory.yoneda.comp G)\nP Q : CategoryTheory.Functor (Opposite C) (Type vâ‚)\nf : Quiver.Hom P Q\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Presheaf.compYonedaIsoYonedaCompLan.presheafHom Ï† P) (CategoryTheory.whiskerLeft F.op (G.map f))) (CategoryTheory.CategoryStruct.comp f (CategoryTheory.Presheaf.compYonedaIsoYonedaCompLan.presheafHom Ï† Q))","decl":"@[reassoc (attr := simp)]\nlemma presheafHom_naturality {P Q : Cáµ’áµ– â¥¤ Type vâ‚} (f : P âŸ¶ Q) :\n    presheafHom Ï† P â‰« whiskerLeft F.op (G.map f) = f â‰« presheafHom Ï† Q :=\n  hom_ext_yoneda (fun X p => yonedaEquiv.injective (by\n    rw [â† assoc p f, yonedaEquiv_Î¹_presheafHom, â† assoc,\n      yonedaEquiv_comp, yonedaEquiv_Î¹_presheafHom,\n      whiskerLeft_app, Functor.map_comp, FunctorToTypes.comp]\n    dsimp))\n\n"}
{"name":"CategoryTheory.Presheaf.compYonedaIsoYonedaCompLan.natTrans_app_yoneda_obj","module":"Mathlib.CategoryTheory.Limits.Presheaf","initialProofState":"C : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚‚} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor (CategoryTheory.Functor (Opposite C) (Type vâ‚)) (CategoryTheory.Functor (Opposite D) (Type vâ‚))\nÏ† : Quiver.Hom (F.comp CategoryTheory.yoneda) (CategoryTheory.yoneda.comp G)\ninstâœ : âˆ€ (P : CategoryTheory.Functor (Opposite C) (Type vâ‚)), F.op.HasLeftKanExtension P\nX : C\nâŠ¢ Eq ((CategoryTheory.Presheaf.compYonedaIsoYonedaCompLan.natTrans Ï†).app (CategoryTheory.yoneda.obj X)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Presheaf.compYonedaIsoYonedaCompLan F).inv.app X) (Ï†.app X))","decl":"lemma natTrans_app_yoneda_obj (X : C) : (natTrans Ï†).app (yoneda.obj X) =\n    (compYonedaIsoYonedaCompLan F).inv.app X â‰« Ï†.app X := by\n  dsimp [natTrans]\n  apply (F.op.lan.obj (yoneda.obj X)).hom_ext_of_isLeftKanExtension (F.op.lanUnit.app _)\n  rw [Functor.descOfIsLeftKanExtension_fac]\n  apply yonedaEquiv.injective\n  rw [yonedaEquiv_presheafHom_yoneda_obj]\n  exact congr_arg _ (compYonedaIsoYonedaCompLan_inv_app_app_apply_eq_id F X).symm\n\n"}
{"name":"CategoryTheory.Presheaf.compYonedaIsoYonedaCompLan.hom_ext","module":"Mathlib.CategoryTheory.Limits.Presheaf","initialProofState":"C : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚‚} D\nF : CategoryTheory.Functor C D\ninstâœ : âˆ€ (P : CategoryTheory.Functor (Opposite C) (Type vâ‚)), F.op.HasLeftKanExtension P\nÎ¦ : CategoryTheory.yoneda.LeftExtension (F.comp CategoryTheory.yoneda)\nf g : Quiver.Hom (CategoryTheory.Functor.LeftExtension.mk F.op.lan (CategoryTheory.Presheaf.compYonedaIsoYonedaCompLan F).hom) Î¦\nâŠ¢ Eq f g","decl":"@[ext]\nlemma hom_ext {Î¦ : yoneda.LeftExtension (F â‹™ yoneda)}\n    (f g : Functor.LeftExtension.mk F.op.lan (compYonedaIsoYonedaCompLan F).hom âŸ¶ Î¦) :\n    f = g := by\n  ext P : 3\n  apply (F.op.lan.obj P).hom_ext_of_isLeftKanExtension (F.op.lanUnit.app P)\n  apply (colimitOfRepresentable P).hom_ext\n  intro x\n  have eq := F.op.lanUnit.naturality (yonedaEquiv.symm x.unop.2)\n  have eqâ‚ := congr_fun (congr_app (congr_app (StructuredArrow.w f) x.unop.1.unop)\n    (F.op.obj x.unop.1)) (ðŸ™ _)\n  have eqâ‚‚ := congr_fun (congr_app (congr_app (StructuredArrow.w g) x.unop.1.unop)\n    (F.op.obj x.unop.1)) (ðŸ™ _)\n  dsimp at eqâ‚ eqâ‚‚ eq âŠ¢\n  simp only [reassoc_of% eq, â† whiskerLeft_comp]\n  congr 2\n  simp only [â† cancel_epi ((compYonedaIsoYonedaCompLan F).hom.app x.unop.1.unop),\n    NatTrans.naturality]\n  apply yonedaEquiv.injective\n  dsimp [yonedaEquiv_apply]\n  rw [eqâ‚, eqâ‚‚]\n\n"}
{"name":"CategoryTheory.Presheaf.compYonedaIsoYonedaCompLan.hom_ext_iff","module":"Mathlib.CategoryTheory.Limits.Presheaf","initialProofState":"C : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚‚} D\nF : CategoryTheory.Functor C D\ninstâœ : âˆ€ (P : CategoryTheory.Functor (Opposite C) (Type vâ‚)), F.op.HasLeftKanExtension P\nÎ¦ : CategoryTheory.yoneda.LeftExtension (F.comp CategoryTheory.yoneda)\nf g : Quiver.Hom (CategoryTheory.Functor.LeftExtension.mk F.op.lan (CategoryTheory.Presheaf.compYonedaIsoYonedaCompLan F).hom) Î¦\nâŠ¢ Iff (Eq f g) True","decl":"@[ext]\nlemma hom_ext {Î¦ : yoneda.LeftExtension (F â‹™ yoneda)}\n    (f g : Functor.LeftExtension.mk F.op.lan (compYonedaIsoYonedaCompLan F).hom âŸ¶ Î¦) :\n    f = g := by\n  ext P : 3\n  apply (F.op.lan.obj P).hom_ext_of_isLeftKanExtension (F.op.lanUnit.app P)\n  apply (colimitOfRepresentable P).hom_ext\n  intro x\n  have eq := F.op.lanUnit.naturality (yonedaEquiv.symm x.unop.2)\n  have eqâ‚ := congr_fun (congr_app (congr_app (StructuredArrow.w f) x.unop.1.unop)\n    (F.op.obj x.unop.1)) (ðŸ™ _)\n  have eqâ‚‚ := congr_fun (congr_app (congr_app (StructuredArrow.w g) x.unop.1.unop)\n    (F.op.obj x.unop.1)) (ðŸ™ _)\n  dsimp at eqâ‚ eqâ‚‚ eq âŠ¢\n  simp only [reassoc_of% eq, â† whiskerLeft_comp]\n  congr 2\n  simp only [â† cancel_epi ((compYonedaIsoYonedaCompLan F).hom.app x.unop.1.unop),\n    NatTrans.naturality]\n  apply yonedaEquiv.injective\n  dsimp [yonedaEquiv_apply]\n  rw [eqâ‚, eqâ‚‚]\n\n"}
{"name":"CategoryTheory.Presheaf.instIsLeftKanExtensionFunctorOppositeTypeLanOpHomCompYonedaIsoYonedaCompLan","module":"Mathlib.CategoryTheory.Limits.Presheaf","initialProofState":"C : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚‚} D\nF : CategoryTheory.Functor C D\ninstâœ : âˆ€ (P : CategoryTheory.Functor (Opposite C) (Type vâ‚)), F.op.HasLeftKanExtension P\nâŠ¢ F.op.lan.IsLeftKanExtension (CategoryTheory.Presheaf.compYonedaIsoYonedaCompLan F).hom","decl":"/-- Given a functor `F : C â¥¤ D`, `F.op.lan : (Cáµ’áµ– â¥¤ Type vâ‚) â¥¤ Dáµ’áµ– â¥¤ Type vâ‚` is the\nleft Kan extension of `F â‹™ yoneda : C â¥¤ Dáµ’áµ– â¥¤ Type vâ‚` along `yoneda : C â¥¤ Cáµ’áµ– â¥¤ Type vâ‚`. -/\ninstance : F.op.lan.IsLeftKanExtension (compYonedaIsoYonedaCompLan F).hom :=\n  âŸ¨âŸ¨Limits.IsInitial.ofUnique _âŸ©âŸ©\n\n"}
{"name":"CategoryTheory.Presheaf.tautologicalCocone_Î¹_app","module":"Mathlib.CategoryTheory.Limits.Presheaf","initialProofState":"C : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} C\nP : CategoryTheory.Functor (Opposite C) (Type vâ‚)\nX : CategoryTheory.CostructuredArrow CategoryTheory.yoneda P\nâŠ¢ Eq ((CategoryTheory.Presheaf.tautologicalCocone P).Î¹.app X) X.hom","decl":"/-- For a presheaf `P`, consider the forgetful functor from the category of representable\n    presheaves over `P` to the category of presheaves. There is a tautological cocone over this\n    functor whose leg for a natural transformation `V âŸ¶ P` with `V` representable is just that\n    natural transformation. -/\n@[simps]\ndef tautologicalCocone : Cocone (CostructuredArrow.proj yoneda P â‹™ yoneda) where\n  pt := P\n  Î¹ := { app := fun X => X.hom }\n\n"}
{"name":"CategoryTheory.Presheaf.tautologicalCocone_pt","module":"Mathlib.CategoryTheory.Limits.Presheaf","initialProofState":"C : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} C\nP : CategoryTheory.Functor (Opposite C) (Type vâ‚)\nâŠ¢ Eq (CategoryTheory.Presheaf.tautologicalCocone P).pt P","decl":"/-- For a presheaf `P`, consider the forgetful functor from the category of representable\n    presheaves over `P` to the category of presheaves. There is a tautological cocone over this\n    functor whose leg for a natural transformation `V âŸ¶ P` with `V` representable is just that\n    natural transformation. -/\n@[simps]\ndef tautologicalCocone : Cocone (CostructuredArrow.proj yoneda P â‹™ yoneda) where\n  pt := P\n  Î¹ := { app := fun X => X.hom }\n\n"}
{"name":"CategoryTheory.Presheaf.final_toCostructuredArrow_comp_pre","module":"Mathlib.CategoryTheory.Limits.Presheaf","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\nI : Type vâ‚\ninstâœ : CategoryTheory.SmallCategory I\nF : CategoryTheory.Functor I C\nc : CategoryTheory.Limits.Cocone (F.comp CategoryTheory.yoneda)\nhc : CategoryTheory.Limits.IsColimit c\nâŠ¢ (c.toCostructuredArrow.comp (CategoryTheory.CostructuredArrow.pre F CategoryTheory.yoneda c.pt)).Final","decl":"/-- Given a functor `F : I â¥¤ C`, a cocone `c` on `F â‹™ yoneda : I â¥¤ Cáµ’áµ– â¥¤ Type vâ‚` induces a\n    functor `I â¥¤ CostructuredArrow yoneda c.pt` which maps `i : I` to the leg\n    `yoneda.obj (F.obj i) âŸ¶ c.pt`. If `c` is a colimit cocone, then that functor is\n    final.\n\n    Proposition 2.6.3(ii) in [Kashiwara2006] -/\ntheorem final_toCostructuredArrow_comp_pre {c : Cocone (F â‹™ yoneda)} (hc : IsColimit c) :\n    Functor.Final (c.toCostructuredArrow â‹™ CostructuredArrow.pre F yoneda c.pt) := by\n  apply Functor.final_of_isTerminal_colimit_comp_yoneda\n\n  suffices IsTerminal (colimit ((c.toCostructuredArrow â‹™ CostructuredArrow.pre F yoneda c.pt) â‹™\n      CostructuredArrow.toOver yoneda c.pt)) by\n    apply IsTerminal.isTerminalOfObj (overEquivPresheafCostructuredArrow c.pt).inverse\n    apply IsTerminal.ofIso this\n    refine ?_ â‰ªâ‰« (preservesColimitIso (overEquivPresheafCostructuredArrow c.pt).inverse _).symm\n    apply HasColimit.isoOfNatIso\n    exact isoWhiskerLeft _\n      (CostructuredArrow.toOverCompOverEquivPresheafCostructuredArrow c.pt).isoCompInverse\n\n  apply IsTerminal.ofIso Over.mkIdTerminal\n  let isc : IsColimit ((Over.forget _).mapCocone _) := isColimitOfPreserves _\n    (colimit.isColimit ((c.toCostructuredArrow â‹™ CostructuredArrow.pre F yoneda c.pt) â‹™\n      CostructuredArrow.toOver yoneda c.pt))\n  exact Over.isoMk (hc.coconePointUniqueUpToIso isc) (hc.hom_ext fun i => by simp)\n\n"}
