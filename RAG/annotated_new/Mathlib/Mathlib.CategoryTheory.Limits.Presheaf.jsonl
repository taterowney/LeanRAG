{"name":"CategoryTheory.Presheaf.restrictedYoneda_map_app","module":"Mathlib.CategoryTheory.Limits.Presheaf","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nℰ : Type u₂\ninst✝ : CategoryTheory.Category.{v₁, u₂} ℰ\nA : CategoryTheory.Functor C ℰ\nX✝ Y✝ : ℰ\nf : Quiver.Hom X✝ Y✝\nX : Opposite C\na✝ : (CategoryTheory.yoneda.obj X✝).obj (A.op.obj X)\n⊢ Eq (((CategoryTheory.Presheaf.restrictedYoneda A).map f).app X a✝) (CategoryTheory.CategoryStruct.comp a✝ f)","decl":"/--\nThe functor taking `(E : ℰ) (c : Cᵒᵖ)` to the homset `(A.obj C ⟶ E)`. It is shown in `L_adjunction`\nthat this functor has a left adjoint (provided `E` has colimits) given by taking colimits over\ncategories of elements.\nIn the case where `ℰ = Cᵒᵖ ⥤ Type u` and `A = yoneda`, this functor is isomorphic to the identity.\n\nDefined as in [MM92], Chapter I, Section 5, Theorem 2.\n-/\n@[simps!]\ndef restrictedYoneda : ℰ ⥤ Cᵒᵖ ⥤ Type v₁ :=\n  yoneda ⋙ (whiskeringLeft _ _ (Type v₁)).obj (Functor.op A)\n\n"}
{"name":"CategoryTheory.Presheaf.restrictedYoneda_obj_obj","module":"Mathlib.CategoryTheory.Limits.Presheaf","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nℰ : Type u₂\ninst✝ : CategoryTheory.Category.{v₁, u₂} ℰ\nA : CategoryTheory.Functor C ℰ\nX✝ : ℰ\nX : Opposite C\n⊢ Eq (((CategoryTheory.Presheaf.restrictedYoneda A).obj X✝).obj X) (Quiver.Hom (A.obj (Opposite.unop X)) X✝)","decl":"/--\nThe functor taking `(E : ℰ) (c : Cᵒᵖ)` to the homset `(A.obj C ⟶ E)`. It is shown in `L_adjunction`\nthat this functor has a left adjoint (provided `E` has colimits) given by taking colimits over\ncategories of elements.\nIn the case where `ℰ = Cᵒᵖ ⥤ Type u` and `A = yoneda`, this functor is isomorphic to the identity.\n\nDefined as in [MM92], Chapter I, Section 5, Theorem 2.\n-/\n@[simps!]\ndef restrictedYoneda : ℰ ⥤ Cᵒᵖ ⥤ Type v₁ :=\n  yoneda ⋙ (whiskeringLeft _ _ (Type v₁)).obj (Functor.op A)\n\n"}
{"name":"CategoryTheory.Presheaf.restrictedYoneda_obj_map","module":"Mathlib.CategoryTheory.Limits.Presheaf","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nℰ : Type u₂\ninst✝ : CategoryTheory.Category.{v₁, u₂} ℰ\nA : CategoryTheory.Functor C ℰ\nX : ℰ\nX✝ Y✝ : Opposite C\nf : Quiver.Hom X✝ Y✝\na✝ : (CategoryTheory.yoneda.obj X).obj (A.op.obj X✝)\n⊢ Eq (((CategoryTheory.Presheaf.restrictedYoneda A).obj X).map f a✝) (CategoryTheory.CategoryStruct.comp (A.map f.unop) a✝)","decl":"/--\nThe functor taking `(E : ℰ) (c : Cᵒᵖ)` to the homset `(A.obj C ⟶ E)`. It is shown in `L_adjunction`\nthat this functor has a left adjoint (provided `E` has colimits) given by taking colimits over\ncategories of elements.\nIn the case where `ℰ = Cᵒᵖ ⥤ Type u` and `A = yoneda`, this functor is isomorphic to the identity.\n\nDefined as in [MM92], Chapter I, Section 5, Theorem 2.\n-/\n@[simps!]\ndef restrictedYoneda : ℰ ⥤ Cᵒᵖ ⥤ Type v₁ :=\n  yoneda ⋙ (whiskeringLeft _ _ (Type v₁)).obj (Functor.op A)\n\n"}
{"name":"CategoryTheory.Presheaf.preservesColimitsOfSize_of_isLeftKanExtension","module":"Mathlib.CategoryTheory.Limits.Presheaf","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nℰ : Type u₂\ninst✝² : CategoryTheory.Category.{v₁, u₂} ℰ\nA : CategoryTheory.Functor C ℰ\ninst✝¹ : CategoryTheory.yoneda.HasPointwiseLeftKanExtension A\nL : CategoryTheory.Functor (CategoryTheory.Functor (Opposite C) (Type v₁)) ℰ\nα : Quiver.Hom A (CategoryTheory.yoneda.comp L)\ninst✝ : L.IsLeftKanExtension α\n⊢ CategoryTheory.Limits.PreservesColimitsOfSize.{v₃, u₃, max u₁ v₁, v₁, max u₁ (v₁ + 1), u₂} L","decl":"include α in\n/-- Any left Kan extension along the Yoneda embedding preserves colimits. -/\nlemma preservesColimitsOfSize_of_isLeftKanExtension :\n    PreservesColimitsOfSize.{v₃, u₃} L :=\n  (yonedaAdjunction L α).leftAdjoint_preservesColimits\n\n"}
{"name":"CategoryTheory.Presheaf.isIso_of_isLeftKanExtension","module":"Mathlib.CategoryTheory.Limits.Presheaf","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nℰ : Type u₂\ninst✝² : CategoryTheory.Category.{v₁, u₂} ℰ\nA : CategoryTheory.Functor C ℰ\ninst✝¹ : CategoryTheory.yoneda.HasPointwiseLeftKanExtension A\nL : CategoryTheory.Functor (CategoryTheory.Functor (Opposite C) (Type v₁)) ℰ\nα : Quiver.Hom A (CategoryTheory.yoneda.comp L)\ninst✝ : L.IsLeftKanExtension α\n⊢ CategoryTheory.IsIso α","decl":"lemma isIso_of_isLeftKanExtension : IsIso α :=\n  (Functor.isPointwiseLeftKanExtensionOfIsLeftKanExtension _ α).isIso_hom\n\n"}
{"name":"CategoryTheory.Presheaf.preservesColimitsOfSize_leftKanExtension","module":"Mathlib.CategoryTheory.Limits.Presheaf","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nℰ : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₁, u₂} ℰ\nA : CategoryTheory.Functor C ℰ\ninst✝ : CategoryTheory.yoneda.HasPointwiseLeftKanExtension A\n⊢ CategoryTheory.Limits.PreservesColimitsOfSize.{v₃, u₃, max v₁ u₁, v₁, max (v₁ + 1) u₁, u₂} (CategoryTheory.yoneda.leftKanExtension A)","decl":"/-- See Property 2 of https://ncatlab.org/nlab/show/Yoneda+extension#properties. -/\nnoncomputable instance preservesColimitsOfSize_leftKanExtension :\n    PreservesColimitsOfSize.{v₃, u₃} (yoneda.leftKanExtension A) :=\n  (yonedaAdjunction _ (yoneda.leftKanExtensionUnit A)).leftAdjoint_preservesColimits\n\n"}
{"name":"CategoryTheory.Presheaf.instIsIsoFunctorLeftKanExtensionUnitOppositeTypeYoneda","module":"Mathlib.CategoryTheory.Limits.Presheaf","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nℰ : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₁, u₂} ℰ\nA : CategoryTheory.Functor C ℰ\ninst✝ : CategoryTheory.yoneda.HasPointwiseLeftKanExtension A\n⊢ CategoryTheory.IsIso (CategoryTheory.yoneda.leftKanExtensionUnit A)","decl":"instance : IsIso (yoneda.leftKanExtensionUnit A) :=\n  isIso_of_isLeftKanExtension _ (yoneda.leftKanExtensionUnit A)\n\n"}
{"name":"CategoryTheory.Presheaf.coconeOfRepresentable_pt","module":"Mathlib.CategoryTheory.Limits.Presheaf","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nP : CategoryTheory.Functor (Opposite C) (Type v₁)\n⊢ Eq (CategoryTheory.Presheaf.coconeOfRepresentable P).pt P","decl":"/-- This is a cocone with point `P` for the functor `functorToRepresentables P`. It is shown in\n`colimitOfRepresentable P` that this cocone is a colimit: that is, we have exhibited an arbitrary\npresheaf `P` as a colimit of representables.\n\nThe construction of [MM92], Chapter I, Section 5, Corollary 3.\n-/\n@[simps]\nnoncomputable def coconeOfRepresentable (P : Cᵒᵖ ⥤ Type v₁) :\n    Cocone (functorToRepresentables P) where\n  pt := P\n  ι :=\n    { app := fun x => yonedaEquiv.symm x.unop.2\n      naturality := fun {x₁ x₂} f => by\n        dsimp\n        rw [comp_id, ← yonedaEquiv_symm_map]\n        congr 1\n        rw [f.unop.2] }\n\n"}
{"name":"CategoryTheory.Presheaf.coconeOfRepresentable_ι_app","module":"Mathlib.CategoryTheory.Limits.Presheaf","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nP : CategoryTheory.Functor (Opposite C) (Type v₁)\nx : Opposite P.Elements\n⊢ Eq ((CategoryTheory.Presheaf.coconeOfRepresentable P).ι.app x) (CategoryTheory.yonedaEquiv.symm (Opposite.unop x).snd)","decl":"/-- This is a cocone with point `P` for the functor `functorToRepresentables P`. It is shown in\n`colimitOfRepresentable P` that this cocone is a colimit: that is, we have exhibited an arbitrary\npresheaf `P` as a colimit of representables.\n\nThe construction of [MM92], Chapter I, Section 5, Corollary 3.\n-/\n@[simps]\nnoncomputable def coconeOfRepresentable (P : Cᵒᵖ ⥤ Type v₁) :\n    Cocone (functorToRepresentables P) where\n  pt := P\n  ι :=\n    { app := fun x => yonedaEquiv.symm x.unop.2\n      naturality := fun {x₁ x₂} f => by\n        dsimp\n        rw [comp_id, ← yonedaEquiv_symm_map]\n        congr 1\n        rw [f.unop.2] }\n\n"}
{"name":"CategoryTheory.Presheaf.coconeOfRepresentable_naturality","module":"Mathlib.CategoryTheory.Limits.Presheaf","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nP₁ P₂ : CategoryTheory.Functor (Opposite C) (Type v₁)\nα : Quiver.Hom P₁ P₂\nj : Opposite P₁.Elements\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Presheaf.coconeOfRepresentable P₁).ι.app j) α) ((CategoryTheory.Presheaf.coconeOfRepresentable P₂).ι.app ((CategoryTheory.CategoryOfElements.map α).op.obj j))","decl":"/-- The legs of the cocone `coconeOfRepresentable` are natural in the choice of presheaf. -/\ntheorem coconeOfRepresentable_naturality {P₁ P₂ : Cᵒᵖ ⥤ Type v₁} (α : P₁ ⟶ P₂) (j : P₁.Elementsᵒᵖ) :\n    (coconeOfRepresentable P₁).ι.app j ≫ α =\n      (coconeOfRepresentable P₂).ι.app ((CategoryOfElements.map α).op.obj j) := by\n  ext T f\n  simpa [coconeOfRepresentable_ι_app] using FunctorToTypes.naturality _ _ α f.op _\n\n"}
{"name":"CategoryTheory.Presheaf.instIsIsoFunctorOfIsLeftKanExtensionOppositeType","module":"Mathlib.CategoryTheory.Limits.Presheaf","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nℰ : Type u₂\ninst✝² : CategoryTheory.Category.{v₁, u₂} ℰ\nA : CategoryTheory.Functor C ℰ\ninst✝¹ : CategoryTheory.yoneda.HasPointwiseLeftKanExtension A\nL : CategoryTheory.Functor (CategoryTheory.Functor (Opposite C) (Type v₁)) ℰ\nα : Quiver.Hom A (CategoryTheory.yoneda.comp L)\ninst✝ : L.IsLeftKanExtension α\n⊢ CategoryTheory.IsIso α","decl":"instance [L.IsLeftKanExtension α] : IsIso α :=\n  (Functor.isPointwiseLeftKanExtensionOfIsLeftKanExtension L α).isIso_hom\n\n"}
{"name":"CategoryTheory.Presheaf.isLeftKanExtension_along_yoneda_iff","module":"Mathlib.CategoryTheory.Limits.Presheaf","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nℰ : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₁, u₂} ℰ\nA : CategoryTheory.Functor C ℰ\ninst✝ : CategoryTheory.yoneda.HasPointwiseLeftKanExtension A\nL : CategoryTheory.Functor (CategoryTheory.Functor (Opposite C) (Type v₁)) ℰ\nα : Quiver.Hom A (CategoryTheory.yoneda.comp L)\n⊢ Iff (L.IsLeftKanExtension α) (And (CategoryTheory.IsIso α) (CategoryTheory.Limits.PreservesColimitsOfSize.{v₁, max u₁ v₁, max u₁ v₁, v₁, max u₁ (v₁ + 1), u₂} L))","decl":"lemma isLeftKanExtension_along_yoneda_iff :\n    L.IsLeftKanExtension α ↔\n      (IsIso α ∧ PreservesColimitsOfSize.{v₁, max u₁ v₁} L) := by\n  constructor\n  · intro\n    exact ⟨inferInstance, preservesColimits_of_natIso\n      (Functor.leftKanExtensionUnique _ (yoneda.leftKanExtensionUnit A) _ α)⟩\n  · rintro ⟨_, _⟩\n    apply Functor.LeftExtension.IsPointwiseLeftKanExtension.isLeftKanExtension\n      (E := Functor.LeftExtension.mk _ α)\n    intro P\n    dsimp [Functor.LeftExtension.IsPointwiseLeftKanExtensionAt]\n    apply IsColimit.ofWhiskerEquivalence (CategoryOfElements.costructuredArrowYonedaEquivalence _)\n    let e : CategoryOfElements.toCostructuredArrow P ⋙ CostructuredArrow.proj yoneda P ⋙ A ≅\n        functorToRepresentables P ⋙ L :=\n      isoWhiskerLeft _ (isoWhiskerLeft _ (asIso α)) ≪≫\n        isoWhiskerLeft _ (Functor.associator _ _ _).symm ≪≫\n        (Functor.associator _ _ _).symm ≪≫ isoWhiskerRight (Iso.refl _) L\n    apply (IsColimit.precomposeHomEquiv e.symm _).1\n    exact IsColimit.ofIsoColimit (isColimitOfPreserves L (colimitOfRepresentable P))\n      (Cocones.ext (Iso.refl _))\n\n"}
{"name":"CategoryTheory.Presheaf.isLeftKanExtension_of_preservesColimits","module":"Mathlib.CategoryTheory.Limits.Presheaf","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nℰ : Type u₂\ninst✝² : CategoryTheory.Category.{v₁, u₂} ℰ\nA : CategoryTheory.Functor C ℰ\ninst✝¹ : CategoryTheory.yoneda.HasPointwiseLeftKanExtension A\nL : CategoryTheory.Functor (CategoryTheory.Functor (Opposite C) (Type v₁)) ℰ\ne : CategoryTheory.Iso A (CategoryTheory.yoneda.comp L)\ninst✝ : CategoryTheory.Limits.PreservesColimitsOfSize.{v₁, max u₁ v₁, max u₁ v₁, v₁, max u₁ (v₁ + 1), u₂} L\n⊢ L.IsLeftKanExtension e.hom","decl":"lemma isLeftKanExtension_of_preservesColimits\n    (L : (Cᵒᵖ ⥤ Type v₁) ⥤ ℰ) (e : A ≅ yoneda ⋙ L)\n    [PreservesColimitsOfSize.{v₁, max u₁ v₁} L] :\n    L.IsLeftKanExtension e.hom := by\n  rw [isLeftKanExtension_along_yoneda_iff]\n  exact ⟨inferInstance, ⟨inferInstance⟩⟩\n\n"}
{"name":"CategoryTheory.Presheaf.instIsLeftKanExtensionFunctorOppositeTypeIdCompYonedaOfPreservesColimitsOfSizeOfHasPointwiseLeftKanExtension","module":"Mathlib.CategoryTheory.Limits.Presheaf","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nℰ : Type u₂\ninst✝² : CategoryTheory.Category.{v₁, u₂} ℰ\nL : CategoryTheory.Functor (CategoryTheory.Functor (Opposite C) (Type v₁)) ℰ\ninst✝¹ : CategoryTheory.Limits.PreservesColimitsOfSize.{v₁, max u₁ v₁, max u₁ v₁, v₁, max u₁ (v₁ + 1), u₂} L\ninst✝ : CategoryTheory.yoneda.HasPointwiseLeftKanExtension (CategoryTheory.yoneda.comp L)\n⊢ L.IsLeftKanExtension (CategoryTheory.CategoryStruct.id (CategoryTheory.yoneda.comp L))","decl":"instance (L : (Cᵒᵖ ⥤ Type v₁) ⥤ ℰ) [PreservesColimitsOfSize.{v₁, max u₁ v₁} L]\n    [yoneda.HasPointwiseLeftKanExtension (yoneda ⋙ L)] :\n    L.IsLeftKanExtension (𝟙 _ : yoneda ⋙ L ⟶ _) :=\n  isLeftKanExtension_of_preservesColimits _ (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Presheaf.isLeftAdjoint_of_preservesColimits","module":"Mathlib.CategoryTheory.Limits.Presheaf","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nℰ : Type u₂\ninst✝² : CategoryTheory.Category.{v₁, u₂} ℰ\nL : CategoryTheory.Functor (CategoryTheory.Functor C (Type v₁)) ℰ\ninst✝¹ : CategoryTheory.Limits.PreservesColimitsOfSize.{v₁, max u₁ v₁, max u₁ v₁, v₁, max u₁ (v₁ + 1), u₂} L\ninst✝ : CategoryTheory.yoneda.HasPointwiseLeftKanExtension (CategoryTheory.yoneda.comp ((CategoryTheory.opOpEquivalence C).congrLeft.functor.comp L))\n⊢ L.IsLeftAdjoint","decl":"/-- If `L` preserves colimits and `ℰ` has them, then it is a left adjoint. Note this is a (partial)\nconverse to `leftAdjointPreservesColimits`.\n-/\nlemma isLeftAdjoint_of_preservesColimits (L : (C ⥤ Type v₁) ⥤ ℰ)\n    [PreservesColimitsOfSize.{v₁, max u₁ v₁} L]\n    [yoneda.HasPointwiseLeftKanExtension\n      (yoneda ⋙ (opOpEquivalence C).congrLeft.functor.comp L)] :\n    L.IsLeftAdjoint :=\n  ⟨_, ⟨((opOpEquivalence C).congrLeft.symm.toAdjunction.comp\n    (yonedaAdjunction _ (𝟙 _))).ofNatIsoLeft ((opOpEquivalence C).congrLeft.invFunIdAssoc L)⟩⟩\n\n"}
{"name":"CategoryTheory.Presheaf.instIsLeftKanExtensionOppositeObjFunctorTypeYonedaYonedaMap","module":"Mathlib.CategoryTheory.Limits.Presheaf","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₁, u₂} D\nF : CategoryTheory.Functor C D\nX : C\n⊢ (CategoryTheory.yoneda.obj (F.obj X)).IsLeftKanExtension (CategoryTheory.yonedaMap F X)","decl":"/-- Given `F : C ⥤ D` and `X : C`, `yoneda.obj (F.obj X) : Dᵒᵖ ⥤ Type _` is the\nleft Kan extension of `yoneda.obj X : Cᵒᵖ ⥤ Type _` along `F.op`. -/\ninstance (X : C) : (yoneda.obj (F.obj X)).IsLeftKanExtension (yonedaMap F X) :=\n  ⟨⟨Limits.IsInitial.ofUnique _⟩⟩\n\n"}
{"name":"CategoryTheory.Presheaf.compYonedaIsoYonedaCompLan_inv_app_app_apply_eq_id","module":"Mathlib.CategoryTheory.Limits.Presheaf","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₁, u₂} D\nF : CategoryTheory.Functor C D\ninst✝ : ∀ (P : CategoryTheory.Functor (Opposite C) (Type v₁)), F.op.HasLeftKanExtension P\nX : C\n⊢ Eq (((CategoryTheory.Presheaf.compYonedaIsoYonedaCompLan F).inv.app X).app { unop := F.obj X } ((F.op.lanUnit.app (CategoryTheory.yoneda.obj X)).app { unop := X } (CategoryTheory.CategoryStruct.id X))) (CategoryTheory.CategoryStruct.id (Opposite.unop { unop := F.obj X }))","decl":"@[simp]\nlemma compYonedaIsoYonedaCompLan_inv_app_app_apply_eq_id (X : C) :\n    ((compYonedaIsoYonedaCompLan F).inv.app X).app (Opposite.op (F.obj X))\n      ((F.op.lanUnit.app (yoneda.obj X)).app _ (𝟙 X)) = 𝟙 _ :=\n  (congr_fun (Functor.descOfIsLeftKanExtension_fac_app _\n    (F.op.lanUnit.app (yoneda.obj X)) _ (yonedaMap F X) (Opposite.op X)) (𝟙 _)).trans (by simp)\n\n"}
{"name":"CategoryTheory.Presheaf.compYonedaIsoYonedaCompLan.coconeApp_naturality_assoc","module":"Mathlib.CategoryTheory.Limits.Presheaf","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₁, u₂} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor (CategoryTheory.Functor (Opposite C) (Type v₁)) (CategoryTheory.Functor (Opposite D) (Type v₁))\nφ : Quiver.Hom (F.comp CategoryTheory.yoneda) (CategoryTheory.yoneda.comp G)\nP : CategoryTheory.Functor (Opposite C) (Type v₁)\nx y : P.Elements\nf : Quiver.Hom x y\nZ : CategoryTheory.Functor (Opposite C) (Type v₁)\nh : Quiver.Hom (F.op.comp (G.obj P)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.yoneda.map (↑f).unop) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Presheaf.compYonedaIsoYonedaCompLan.coconeApp φ x) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Presheaf.compYonedaIsoYonedaCompLan.coconeApp φ y) h)","decl":"@[reassoc (attr := simp)]\nlemma coconeApp_naturality {P : Cᵒᵖ ⥤ Type v₁} {x y : P.Elements} (f : x ⟶ y) :\n    yoneda.map f.1.unop ≫ coconeApp φ x = coconeApp φ y := by\n  have eq₁ : yoneda.map f.1.unop ≫ yonedaEquiv.symm x.2 = yonedaEquiv.symm y.2 :=\n    yonedaEquiv.injective\n      (by simpa only [Equiv.apply_symm_apply, ← yonedaEquiv_naturality] using f.2)\n  have eq₂ := congr_fun ((G.map (yonedaEquiv.symm x.2)).naturality (F.map f.1.unop).op)\n    ((φ.app x.1.unop).app _ (𝟙 _))\n  have eq₃ := congr_fun (congr_app (φ.naturality f.1.unop) _) (𝟙 _)\n  have eq₄ := congr_fun ((φ.app x.1.unop).naturality (F.map f.1.unop).op)\n  dsimp at eq₂ eq₃ eq₄\n  apply yonedaEquiv.injective\n  dsimp only [coconeApp]\n  rw [Equiv.apply_symm_apply, ← yonedaEquiv_naturality, Equiv.apply_symm_apply]\n  simp [← eq₁, ← eq₂, ← eq₃, ← eq₄, Functor.map_comp, FunctorToTypes.comp, id_comp, comp_id]\n\n"}
{"name":"CategoryTheory.Presheaf.compYonedaIsoYonedaCompLan.coconeApp_naturality","module":"Mathlib.CategoryTheory.Limits.Presheaf","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₁, u₂} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor (CategoryTheory.Functor (Opposite C) (Type v₁)) (CategoryTheory.Functor (Opposite D) (Type v₁))\nφ : Quiver.Hom (F.comp CategoryTheory.yoneda) (CategoryTheory.yoneda.comp G)\nP : CategoryTheory.Functor (Opposite C) (Type v₁)\nx y : P.Elements\nf : Quiver.Hom x y\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.yoneda.map (↑f).unop) (CategoryTheory.Presheaf.compYonedaIsoYonedaCompLan.coconeApp φ x)) (CategoryTheory.Presheaf.compYonedaIsoYonedaCompLan.coconeApp φ y)","decl":"@[reassoc (attr := simp)]\nlemma coconeApp_naturality {P : Cᵒᵖ ⥤ Type v₁} {x y : P.Elements} (f : x ⟶ y) :\n    yoneda.map f.1.unop ≫ coconeApp φ x = coconeApp φ y := by\n  have eq₁ : yoneda.map f.1.unop ≫ yonedaEquiv.symm x.2 = yonedaEquiv.symm y.2 :=\n    yonedaEquiv.injective\n      (by simpa only [Equiv.apply_symm_apply, ← yonedaEquiv_naturality] using f.2)\n  have eq₂ := congr_fun ((G.map (yonedaEquiv.symm x.2)).naturality (F.map f.1.unop).op)\n    ((φ.app x.1.unop).app _ (𝟙 _))\n  have eq₃ := congr_fun (congr_app (φ.naturality f.1.unop) _) (𝟙 _)\n  have eq₄ := congr_fun ((φ.app x.1.unop).naturality (F.map f.1.unop).op)\n  dsimp at eq₂ eq₃ eq₄\n  apply yonedaEquiv.injective\n  dsimp only [coconeApp]\n  rw [Equiv.apply_symm_apply, ← yonedaEquiv_naturality, Equiv.apply_symm_apply]\n  simp [← eq₁, ← eq₂, ← eq₃, ← eq₄, Functor.map_comp, FunctorToTypes.comp, id_comp, comp_id]\n\n"}
{"name":"CategoryTheory.Presheaf.compYonedaIsoYonedaCompLan.yonedaEquiv_ι_presheafHom","module":"Mathlib.CategoryTheory.Limits.Presheaf","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₁, u₂} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor (CategoryTheory.Functor (Opposite C) (Type v₁)) (CategoryTheory.Functor (Opposite D) (Type v₁))\nφ : Quiver.Hom (F.comp CategoryTheory.yoneda) (CategoryTheory.yoneda.comp G)\nP : CategoryTheory.Functor (Opposite C) (Type v₁)\nX : C\nf : Quiver.Hom (CategoryTheory.yoneda.obj X) P\n⊢ Eq (CategoryTheory.yonedaEquiv (CategoryTheory.CategoryStruct.comp f (CategoryTheory.Presheaf.compYonedaIsoYonedaCompLan.presheafHom φ P))) ((G.map f).app { unop := F.obj X } ((φ.app X).app { unop := F.obj X } (CategoryTheory.CategoryStruct.id (Opposite.unop { unop := F.obj X }))))","decl":"lemma yonedaEquiv_ι_presheafHom (P : Cᵒᵖ ⥤ Type v₁) {X : C} (f : yoneda.obj X ⟶ P) :\n    yonedaEquiv (f ≫ presheafHom φ P) =\n      (G.map f).app (Opposite.op (F.obj X)) ((φ.app X).app _ (𝟙 _)) := by\n  obtain ⟨x, rfl⟩ := yonedaEquiv.symm.surjective f\n  erw [(colimitOfRepresentable P).fac _ (Opposite.op (P.elementsMk _ x))]\n  dsimp only [coconeApp]\n  apply Equiv.apply_symm_apply\n\n"}
{"name":"CategoryTheory.Presheaf.compYonedaIsoYonedaCompLan.yonedaEquiv_presheafHom_yoneda_obj","module":"Mathlib.CategoryTheory.Limits.Presheaf","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₁, u₂} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor (CategoryTheory.Functor (Opposite C) (Type v₁)) (CategoryTheory.Functor (Opposite D) (Type v₁))\nφ : Quiver.Hom (F.comp CategoryTheory.yoneda) (CategoryTheory.yoneda.comp G)\nX : C\n⊢ Eq (CategoryTheory.yonedaEquiv (CategoryTheory.Presheaf.compYonedaIsoYonedaCompLan.presheafHom φ (CategoryTheory.yoneda.obj X))) ((φ.app X).app (F.op.obj { unop := X }) (CategoryTheory.CategoryStruct.id (Opposite.unop (F.op.obj { unop := X }))))","decl":"lemma yonedaEquiv_presheafHom_yoneda_obj (X : C) :\n    yonedaEquiv (presheafHom φ (yoneda.obj X)) =\n      ((φ.app X).app (F.op.obj (Opposite.op X)) (𝟙 _)) := by\n  simpa using yonedaEquiv_ι_presheafHom φ (yoneda.obj X) (𝟙 _)\n\n"}
{"name":"CategoryTheory.Presheaf.compYonedaIsoYonedaCompLan.presheafHom_naturality_assoc","module":"Mathlib.CategoryTheory.Limits.Presheaf","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₁, u₂} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor (CategoryTheory.Functor (Opposite C) (Type v₁)) (CategoryTheory.Functor (Opposite D) (Type v₁))\nφ : Quiver.Hom (F.comp CategoryTheory.yoneda) (CategoryTheory.yoneda.comp G)\nP Q : CategoryTheory.Functor (Opposite C) (Type v₁)\nf : Quiver.Hom P Q\nZ : CategoryTheory.Functor (Opposite C) (Type v₁)\nh : Quiver.Hom (F.op.comp (G.obj Q)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Presheaf.compYonedaIsoYonedaCompLan.presheafHom φ P) (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerLeft F.op (G.map f)) h)) (CategoryTheory.CategoryStruct.comp f (CategoryTheory.CategoryStruct.comp (CategoryTheory.Presheaf.compYonedaIsoYonedaCompLan.presheafHom φ Q) h))","decl":"@[reassoc (attr := simp)]\nlemma presheafHom_naturality {P Q : Cᵒᵖ ⥤ Type v₁} (f : P ⟶ Q) :\n    presheafHom φ P ≫ whiskerLeft F.op (G.map f) = f ≫ presheafHom φ Q :=\n  hom_ext_yoneda (fun X p => yonedaEquiv.injective (by\n    rw [← assoc p f, yonedaEquiv_ι_presheafHom, ← assoc,\n      yonedaEquiv_comp, yonedaEquiv_ι_presheafHom,\n      whiskerLeft_app, Functor.map_comp, FunctorToTypes.comp]\n    dsimp))\n\n"}
{"name":"CategoryTheory.Presheaf.compYonedaIsoYonedaCompLan.presheafHom_naturality","module":"Mathlib.CategoryTheory.Limits.Presheaf","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₁, u₂} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor (CategoryTheory.Functor (Opposite C) (Type v₁)) (CategoryTheory.Functor (Opposite D) (Type v₁))\nφ : Quiver.Hom (F.comp CategoryTheory.yoneda) (CategoryTheory.yoneda.comp G)\nP Q : CategoryTheory.Functor (Opposite C) (Type v₁)\nf : Quiver.Hom P Q\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Presheaf.compYonedaIsoYonedaCompLan.presheafHom φ P) (CategoryTheory.whiskerLeft F.op (G.map f))) (CategoryTheory.CategoryStruct.comp f (CategoryTheory.Presheaf.compYonedaIsoYonedaCompLan.presheafHom φ Q))","decl":"@[reassoc (attr := simp)]\nlemma presheafHom_naturality {P Q : Cᵒᵖ ⥤ Type v₁} (f : P ⟶ Q) :\n    presheafHom φ P ≫ whiskerLeft F.op (G.map f) = f ≫ presheafHom φ Q :=\n  hom_ext_yoneda (fun X p => yonedaEquiv.injective (by\n    rw [← assoc p f, yonedaEquiv_ι_presheafHom, ← assoc,\n      yonedaEquiv_comp, yonedaEquiv_ι_presheafHom,\n      whiskerLeft_app, Functor.map_comp, FunctorToTypes.comp]\n    dsimp))\n\n"}
{"name":"CategoryTheory.Presheaf.compYonedaIsoYonedaCompLan.natTrans_app_yoneda_obj","module":"Mathlib.CategoryTheory.Limits.Presheaf","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₁, u₂} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor (CategoryTheory.Functor (Opposite C) (Type v₁)) (CategoryTheory.Functor (Opposite D) (Type v₁))\nφ : Quiver.Hom (F.comp CategoryTheory.yoneda) (CategoryTheory.yoneda.comp G)\ninst✝ : ∀ (P : CategoryTheory.Functor (Opposite C) (Type v₁)), F.op.HasLeftKanExtension P\nX : C\n⊢ Eq ((CategoryTheory.Presheaf.compYonedaIsoYonedaCompLan.natTrans φ).app (CategoryTheory.yoneda.obj X)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Presheaf.compYonedaIsoYonedaCompLan F).inv.app X) (φ.app X))","decl":"lemma natTrans_app_yoneda_obj (X : C) : (natTrans φ).app (yoneda.obj X) =\n    (compYonedaIsoYonedaCompLan F).inv.app X ≫ φ.app X := by\n  dsimp [natTrans]\n  apply (F.op.lan.obj (yoneda.obj X)).hom_ext_of_isLeftKanExtension (F.op.lanUnit.app _)\n  rw [Functor.descOfIsLeftKanExtension_fac]\n  apply yonedaEquiv.injective\n  rw [yonedaEquiv_presheafHom_yoneda_obj]\n  exact congr_arg _ (compYonedaIsoYonedaCompLan_inv_app_app_apply_eq_id F X).symm\n\n"}
{"name":"CategoryTheory.Presheaf.compYonedaIsoYonedaCompLan.hom_ext","module":"Mathlib.CategoryTheory.Limits.Presheaf","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₁, u₂} D\nF : CategoryTheory.Functor C D\ninst✝ : ∀ (P : CategoryTheory.Functor (Opposite C) (Type v₁)), F.op.HasLeftKanExtension P\nΦ : CategoryTheory.yoneda.LeftExtension (F.comp CategoryTheory.yoneda)\nf g : Quiver.Hom (CategoryTheory.Functor.LeftExtension.mk F.op.lan (CategoryTheory.Presheaf.compYonedaIsoYonedaCompLan F).hom) Φ\n⊢ Eq f g","decl":"@[ext]\nlemma hom_ext {Φ : yoneda.LeftExtension (F ⋙ yoneda)}\n    (f g : Functor.LeftExtension.mk F.op.lan (compYonedaIsoYonedaCompLan F).hom ⟶ Φ) :\n    f = g := by\n  ext P : 3\n  apply (F.op.lan.obj P).hom_ext_of_isLeftKanExtension (F.op.lanUnit.app P)\n  apply (colimitOfRepresentable P).hom_ext\n  intro x\n  have eq := F.op.lanUnit.naturality (yonedaEquiv.symm x.unop.2)\n  have eq₁ := congr_fun (congr_app (congr_app (StructuredArrow.w f) x.unop.1.unop)\n    (F.op.obj x.unop.1)) (𝟙 _)\n  have eq₂ := congr_fun (congr_app (congr_app (StructuredArrow.w g) x.unop.1.unop)\n    (F.op.obj x.unop.1)) (𝟙 _)\n  dsimp at eq₁ eq₂ eq ⊢\n  simp only [reassoc_of% eq, ← whiskerLeft_comp]\n  congr 2\n  simp only [← cancel_epi ((compYonedaIsoYonedaCompLan F).hom.app x.unop.1.unop),\n    NatTrans.naturality]\n  apply yonedaEquiv.injective\n  dsimp [yonedaEquiv_apply]\n  rw [eq₁, eq₂]\n\n"}
{"name":"CategoryTheory.Presheaf.compYonedaIsoYonedaCompLan.hom_ext_iff","module":"Mathlib.CategoryTheory.Limits.Presheaf","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₁, u₂} D\nF : CategoryTheory.Functor C D\ninst✝ : ∀ (P : CategoryTheory.Functor (Opposite C) (Type v₁)), F.op.HasLeftKanExtension P\nΦ : CategoryTheory.yoneda.LeftExtension (F.comp CategoryTheory.yoneda)\nf g : Quiver.Hom (CategoryTheory.Functor.LeftExtension.mk F.op.lan (CategoryTheory.Presheaf.compYonedaIsoYonedaCompLan F).hom) Φ\n⊢ Iff (Eq f g) True","decl":"@[ext]\nlemma hom_ext {Φ : yoneda.LeftExtension (F ⋙ yoneda)}\n    (f g : Functor.LeftExtension.mk F.op.lan (compYonedaIsoYonedaCompLan F).hom ⟶ Φ) :\n    f = g := by\n  ext P : 3\n  apply (F.op.lan.obj P).hom_ext_of_isLeftKanExtension (F.op.lanUnit.app P)\n  apply (colimitOfRepresentable P).hom_ext\n  intro x\n  have eq := F.op.lanUnit.naturality (yonedaEquiv.symm x.unop.2)\n  have eq₁ := congr_fun (congr_app (congr_app (StructuredArrow.w f) x.unop.1.unop)\n    (F.op.obj x.unop.1)) (𝟙 _)\n  have eq₂ := congr_fun (congr_app (congr_app (StructuredArrow.w g) x.unop.1.unop)\n    (F.op.obj x.unop.1)) (𝟙 _)\n  dsimp at eq₁ eq₂ eq ⊢\n  simp only [reassoc_of% eq, ← whiskerLeft_comp]\n  congr 2\n  simp only [← cancel_epi ((compYonedaIsoYonedaCompLan F).hom.app x.unop.1.unop),\n    NatTrans.naturality]\n  apply yonedaEquiv.injective\n  dsimp [yonedaEquiv_apply]\n  rw [eq₁, eq₂]\n\n"}
{"name":"CategoryTheory.Presheaf.instIsLeftKanExtensionFunctorOppositeTypeLanOpHomCompYonedaIsoYonedaCompLan","module":"Mathlib.CategoryTheory.Limits.Presheaf","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₁, u₂} D\nF : CategoryTheory.Functor C D\ninst✝ : ∀ (P : CategoryTheory.Functor (Opposite C) (Type v₁)), F.op.HasLeftKanExtension P\n⊢ F.op.lan.IsLeftKanExtension (CategoryTheory.Presheaf.compYonedaIsoYonedaCompLan F).hom","decl":"/-- Given a functor `F : C ⥤ D`, `F.op.lan : (Cᵒᵖ ⥤ Type v₁) ⥤ Dᵒᵖ ⥤ Type v₁` is the\nleft Kan extension of `F ⋙ yoneda : C ⥤ Dᵒᵖ ⥤ Type v₁` along `yoneda : C ⥤ Cᵒᵖ ⥤ Type v₁`. -/\ninstance : F.op.lan.IsLeftKanExtension (compYonedaIsoYonedaCompLan F).hom :=\n  ⟨⟨Limits.IsInitial.ofUnique _⟩⟩\n\n"}
{"name":"CategoryTheory.Presheaf.tautologicalCocone_ι_app","module":"Mathlib.CategoryTheory.Limits.Presheaf","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nP : CategoryTheory.Functor (Opposite C) (Type v₁)\nX : CategoryTheory.CostructuredArrow CategoryTheory.yoneda P\n⊢ Eq ((CategoryTheory.Presheaf.tautologicalCocone P).ι.app X) X.hom","decl":"/-- For a presheaf `P`, consider the forgetful functor from the category of representable\n    presheaves over `P` to the category of presheaves. There is a tautological cocone over this\n    functor whose leg for a natural transformation `V ⟶ P` with `V` representable is just that\n    natural transformation. -/\n@[simps]\ndef tautologicalCocone : Cocone (CostructuredArrow.proj yoneda P ⋙ yoneda) where\n  pt := P\n  ι := { app := fun X => X.hom }\n\n"}
{"name":"CategoryTheory.Presheaf.tautologicalCocone_pt","module":"Mathlib.CategoryTheory.Limits.Presheaf","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nP : CategoryTheory.Functor (Opposite C) (Type v₁)\n⊢ Eq (CategoryTheory.Presheaf.tautologicalCocone P).pt P","decl":"/-- For a presheaf `P`, consider the forgetful functor from the category of representable\n    presheaves over `P` to the category of presheaves. There is a tautological cocone over this\n    functor whose leg for a natural transformation `V ⟶ P` with `V` representable is just that\n    natural transformation. -/\n@[simps]\ndef tautologicalCocone : Cocone (CostructuredArrow.proj yoneda P ⋙ yoneda) where\n  pt := P\n  ι := { app := fun X => X.hom }\n\n"}
{"name":"CategoryTheory.Presheaf.final_toCostructuredArrow_comp_pre","module":"Mathlib.CategoryTheory.Limits.Presheaf","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nI : Type v₁\ninst✝ : CategoryTheory.SmallCategory I\nF : CategoryTheory.Functor I C\nc : CategoryTheory.Limits.Cocone (F.comp CategoryTheory.yoneda)\nhc : CategoryTheory.Limits.IsColimit c\n⊢ (c.toCostructuredArrow.comp (CategoryTheory.CostructuredArrow.pre F CategoryTheory.yoneda c.pt)).Final","decl":"/-- Given a functor `F : I ⥤ C`, a cocone `c` on `F ⋙ yoneda : I ⥤ Cᵒᵖ ⥤ Type v₁` induces a\n    functor `I ⥤ CostructuredArrow yoneda c.pt` which maps `i : I` to the leg\n    `yoneda.obj (F.obj i) ⟶ c.pt`. If `c` is a colimit cocone, then that functor is\n    final.\n\n    Proposition 2.6.3(ii) in [Kashiwara2006] -/\ntheorem final_toCostructuredArrow_comp_pre {c : Cocone (F ⋙ yoneda)} (hc : IsColimit c) :\n    Functor.Final (c.toCostructuredArrow ⋙ CostructuredArrow.pre F yoneda c.pt) := by\n  apply Functor.final_of_isTerminal_colimit_comp_yoneda\n\n  suffices IsTerminal (colimit ((c.toCostructuredArrow ⋙ CostructuredArrow.pre F yoneda c.pt) ⋙\n      CostructuredArrow.toOver yoneda c.pt)) by\n    apply IsTerminal.isTerminalOfObj (overEquivPresheafCostructuredArrow c.pt).inverse\n    apply IsTerminal.ofIso this\n    refine ?_ ≪≫ (preservesColimitIso (overEquivPresheafCostructuredArrow c.pt).inverse _).symm\n    apply HasColimit.isoOfNatIso\n    exact isoWhiskerLeft _\n      (CostructuredArrow.toOverCompOverEquivPresheafCostructuredArrow c.pt).isoCompInverse\n\n  apply IsTerminal.ofIso Over.mkIdTerminal\n  let isc : IsColimit ((Over.forget _).mapCocone _) := isColimitOfPreserves _\n    (colimit.isColimit ((c.toCostructuredArrow ⋙ CostructuredArrow.pre F yoneda c.pt) ⋙\n      CostructuredArrow.toOver yoneda c.pt))\n  exact Over.isoMk (hc.coconePointUniqueUpToIso isc) (hc.hom_ext fun i => by simp)\n\n"}
