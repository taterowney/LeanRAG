{"name":"Multiset.coe_nodup","module":"Mathlib.Data.Multiset.Nodup","initialProofState":"α : Type u_1\nl : List α\n⊢ Iff (↑l).Nodup l.Nodup","decl":"@[simp]\ntheorem coe_nodup {l : List α} : @Nodup α l ↔ l.Nodup :=\n  Iff.rfl\n\n"}
{"name":"Multiset.nodup_zero","module":"Mathlib.Data.Multiset.Nodup","initialProofState":"α : Type u_1\n⊢ Multiset.Nodup 0","decl":"@[simp]\ntheorem nodup_zero : @Nodup α 0 :=\n  Pairwise.nil\n\n"}
{"name":"Multiset.nodup_cons","module":"Mathlib.Data.Multiset.Nodup","initialProofState":"α : Type u_1\na : α\ns : Multiset α\n⊢ Iff (Multiset.cons a s).Nodup (And (Not (Membership.mem s a)) s.Nodup)","decl":"@[simp]\ntheorem nodup_cons {a : α} {s : Multiset α} : Nodup (a ::ₘ s) ↔ a ∉ s ∧ Nodup s :=\n  Quot.induction_on s fun _ => List.nodup_cons\n\n"}
{"name":"Multiset.Nodup.cons","module":"Mathlib.Data.Multiset.Nodup","initialProofState":"α : Type u_1\ns : Multiset α\na : α\nm : Not (Membership.mem s a)\nn : s.Nodup\n⊢ (Multiset.cons a s).Nodup","decl":"theorem Nodup.cons (m : a ∉ s) (n : Nodup s) : Nodup (a ::ₘ s) :=\n  nodup_cons.2 ⟨m, n⟩\n\n"}
{"name":"Multiset.nodup_singleton","module":"Mathlib.Data.Multiset.Nodup","initialProofState":"α : Type u_1\na : α\n⊢ (Singleton.singleton a).Nodup","decl":"@[simp]\ntheorem nodup_singleton : ∀ a : α, Nodup ({a} : Multiset α) :=\n  List.nodup_singleton\n\n"}
{"name":"Multiset.Nodup.of_cons","module":"Mathlib.Data.Multiset.Nodup","initialProofState":"α : Type u_1\ns : Multiset α\na : α\nh : (Multiset.cons a s).Nodup\n⊢ s.Nodup","decl":"theorem Nodup.of_cons (h : Nodup (a ::ₘ s)) : Nodup s :=\n  (nodup_cons.1 h).2\n\n"}
{"name":"Multiset.Nodup.not_mem","module":"Mathlib.Data.Multiset.Nodup","initialProofState":"α : Type u_1\ns : Multiset α\na : α\nh : (Multiset.cons a s).Nodup\n⊢ Not (Membership.mem s a)","decl":"theorem Nodup.not_mem (h : Nodup (a ::ₘ s)) : a ∉ s :=\n  (nodup_cons.1 h).1\n\n"}
{"name":"Multiset.nodup_of_le","module":"Mathlib.Data.Multiset.Nodup","initialProofState":"α : Type u_1\ns t : Multiset α\nh : LE.le s t\na✝ : t.Nodup\n⊢ s.Nodup","decl":"theorem nodup_of_le {s t : Multiset α} (h : s ≤ t) : Nodup t → Nodup s :=\n  Multiset.leInductionOn h fun {_ _} => Nodup.sublist\n\n"}
{"name":"Multiset.not_nodup_pair","module":"Mathlib.Data.Multiset.Nodup","initialProofState":"α : Type u_1\na : α\n⊢ Not (Multiset.cons a (Multiset.cons a 0)).Nodup","decl":"theorem not_nodup_pair : ∀ a : α, ¬Nodup (a ::ₘ a ::ₘ 0) :=\n  List.not_nodup_pair\n\n"}
{"name":"Multiset.nodup_iff_le","module":"Mathlib.Data.Multiset.Nodup","initialProofState":"α : Type u_1\ns : Multiset α\n⊢ Iff s.Nodup (∀ (a : α), Not (LE.le (Multiset.cons a (Multiset.cons a 0)) s))","decl":"theorem nodup_iff_le {s : Multiset α} : Nodup s ↔ ∀ a : α, ¬a ::ₘ a ::ₘ 0 ≤ s :=\n  Quot.induction_on s fun _ =>\n    nodup_iff_sublist.trans <| forall_congr' fun a => not_congr (@replicate_le_coe _ a 2 _).symm\n\n"}
{"name":"Multiset.nodup_iff_ne_cons_cons","module":"Mathlib.Data.Multiset.Nodup","initialProofState":"α : Type u_1\ns : Multiset α\n⊢ Iff s.Nodup (∀ (a : α) (t : Multiset α), Ne s (Multiset.cons a (Multiset.cons a t)))","decl":"theorem nodup_iff_ne_cons_cons {s : Multiset α} : s.Nodup ↔ ∀ a t, s ≠ a ::ₘ a ::ₘ t :=\n  nodup_iff_le.trans\n    ⟨fun h a _ s_eq => h a (s_eq.symm ▸ cons_le_cons a (cons_le_cons a (zero_le _))), fun h a le =>\n      let ⟨t, s_eq⟩ := le_iff_exists_add.mp le\n      h a t (by rwa [cons_add, cons_add, Multiset.zero_add] at s_eq)⟩\n\n"}
{"name":"Multiset.nodup_iff_count_le_one","module":"Mathlib.Data.Multiset.Nodup","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : Multiset α\n⊢ Iff s.Nodup (∀ (a : α), LE.le (Multiset.count a s) 1)","decl":"theorem nodup_iff_count_le_one [DecidableEq α] {s : Multiset α} : Nodup s ↔ ∀ a, count a s ≤ 1 :=\n  Quot.induction_on s fun _l => by\n    simp only [quot_mk_to_coe'', coe_nodup, mem_coe, coe_count]\n    exact List.nodup_iff_count_le_one\n\n"}
{"name":"Multiset.nodup_iff_count_eq_one","module":"Mathlib.Data.Multiset.Nodup","initialProofState":"α : Type u_1\ns : Multiset α\ninst✝ : DecidableEq α\n⊢ Iff s.Nodup (∀ (a : α), Membership.mem s a → Eq (Multiset.count a s) 1)","decl":"theorem nodup_iff_count_eq_one [DecidableEq α] : Nodup s ↔ ∀ a ∈ s, count a s = 1 :=\n  Quot.induction_on s fun _l => by simpa using List.nodup_iff_count_eq_one\n\n"}
{"name":"Multiset.count_eq_one_of_mem","module":"Mathlib.Data.Multiset.Nodup","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na : α\ns : Multiset α\nd : s.Nodup\nh : Membership.mem s a\n⊢ Eq (Multiset.count a s) 1","decl":"@[simp]\ntheorem count_eq_one_of_mem [DecidableEq α] {a : α} {s : Multiset α} (d : Nodup s) (h : a ∈ s) :\n    count a s = 1 :=\n  nodup_iff_count_eq_one.mp d a h\n\n"}
{"name":"Multiset.count_eq_of_nodup","module":"Mathlib.Data.Multiset.Nodup","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na : α\ns : Multiset α\nd : s.Nodup\n⊢ Eq (Multiset.count a s) (ite (Membership.mem s a) 1 0)","decl":"theorem count_eq_of_nodup [DecidableEq α] {a : α} {s : Multiset α} (d : Nodup s) :\n    count a s = if a ∈ s then 1 else 0 := by\n  split_ifs with h\n  · exact count_eq_one_of_mem d h\n  · exact count_eq_zero_of_not_mem h\n\n"}
{"name":"Multiset.nodup_iff_pairwise","module":"Mathlib.Data.Multiset.Nodup","initialProofState":"α : Type u_4\ns : Multiset α\n⊢ Iff s.Nodup (Multiset.Pairwise (fun x1 x2 => Ne x1 x2) s)","decl":"theorem nodup_iff_pairwise {α} {s : Multiset α} : Nodup s ↔ Pairwise (· ≠ ·) s :=\n  Quotient.inductionOn s fun _ => (pairwise_coe_iff_pairwise fun _ _ => Ne.symm).symm\n\n"}
{"name":"Multiset.Nodup.pairwise","module":"Mathlib.Data.Multiset.Nodup","initialProofState":"α : Type u_1\nr : α → α → Prop\ns : Multiset α\na✝¹ : ∀ (a : α), Membership.mem s a → ∀ (b : α), Membership.mem s b → Ne a b → r a b\na✝ : s.Nodup\n⊢ Multiset.Pairwise r s","decl":"protected theorem Nodup.pairwise : (∀ a ∈ s, ∀ b ∈ s, a ≠ b → r a b) → Nodup s → Pairwise r s :=\n  Quotient.inductionOn s fun l h hl => ⟨l, rfl, hl.imp_of_mem fun {a b} ha hb => h a ha b hb⟩\n\n"}
{"name":"Multiset.Pairwise.forall","module":"Mathlib.Data.Multiset.Nodup","initialProofState":"α : Type u_1\nr : α → α → Prop\ns : Multiset α\nH : Symmetric r\nhs : Multiset.Pairwise r s\na : α\na✝² : Membership.mem s a\nb : α\na✝¹ : Membership.mem s b\na✝ : Ne a b\n⊢ r a b","decl":"theorem Pairwise.forall (H : Symmetric r) (hs : Pairwise r s) :\n    ∀ ⦃a⦄, a ∈ s → ∀ ⦃b⦄, b ∈ s → a ≠ b → r a b :=\n  let ⟨_, hl₁, hl₂⟩ := hs\n  hl₁.symm ▸ hl₂.forall H\n\n"}
{"name":"Multiset.nodup_add","module":"Mathlib.Data.Multiset.Nodup","initialProofState":"α : Type u_1\ns t : Multiset α\n⊢ Iff (HAdd.hAdd s t).Nodup (And s.Nodup (And t.Nodup (Disjoint s t)))","decl":"theorem nodup_add {s t : Multiset α} : Nodup (s + t) ↔ Nodup s ∧ Nodup t ∧ Disjoint s t :=\n  Quotient.inductionOn₂ s t fun _ _ => by simp [nodup_append]\n\n"}
{"name":"Multiset.disjoint_of_nodup_add","module":"Mathlib.Data.Multiset.Nodup","initialProofState":"α : Type u_1\ns t : Multiset α\nd : (HAdd.hAdd s t).Nodup\n⊢ Disjoint s t","decl":"theorem disjoint_of_nodup_add {s t : Multiset α} (d : Nodup (s + t)) : Disjoint s t :=\n  (nodup_add.1 d).2.2\n\n"}
{"name":"Multiset.Nodup.add_iff","module":"Mathlib.Data.Multiset.Nodup","initialProofState":"α : Type u_1\ns t : Multiset α\nd₁ : s.Nodup\nd₂ : t.Nodup\n⊢ Iff (HAdd.hAdd s t).Nodup (Disjoint s t)","decl":"theorem Nodup.add_iff (d₁ : Nodup s) (d₂ : Nodup t) : Nodup (s + t) ↔ Disjoint s t := by\n  simp [nodup_add, d₁, d₂]\n\n"}
{"name":"Multiset.Nodup.of_map","module":"Mathlib.Data.Multiset.Nodup","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Multiset α\nf : α → β\na✝ : (Multiset.map f s).Nodup\n⊢ s.Nodup","decl":"theorem Nodup.of_map (f : α → β) : Nodup (map f s) → Nodup s :=\n  Quot.induction_on s fun _ => List.Nodup.of_map f\n\n"}
{"name":"Multiset.Nodup.map_on","module":"Mathlib.Data.Multiset.Nodup","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Multiset α\nf : α → β\na✝¹ : ∀ (x : α), Membership.mem s x → ∀ (y : α), Membership.mem s y → Eq (f x) (f y) → Eq x y\na✝ : s.Nodup\n⊢ (Multiset.map f s).Nodup","decl":"theorem Nodup.map_on {f : α → β} :\n    (∀ x ∈ s, ∀ y ∈ s, f x = f y → x = y) → Nodup s → Nodup (map f s) :=\n  Quot.induction_on s fun _ => List.Nodup.map_on\n\n"}
{"name":"Multiset.Nodup.map","module":"Mathlib.Data.Multiset.Nodup","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\ns : Multiset α\nhf : Function.Injective f\na✝ : s.Nodup\n⊢ (Multiset.map f s).Nodup","decl":"theorem Nodup.map {f : α → β} {s : Multiset α} (hf : Injective f) : Nodup s → Nodup (map f s) :=\n  Nodup.map_on fun _ _ _ _ h => hf h\n\n"}
{"name":"Multiset.nodup_map_iff_of_inj_on","module":"Mathlib.Data.Multiset.Nodup","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Multiset α\nf : α → β\nd : ∀ (x : α), Membership.mem s x → ∀ (y : α), Membership.mem s y → Eq (f x) (f y) → Eq x y\n⊢ Iff (Multiset.map f s).Nodup s.Nodup","decl":"theorem nodup_map_iff_of_inj_on {f : α → β} (d : ∀ x ∈ s, ∀ y ∈ s, f x = f y → x = y) :\n    Nodup (map f s) ↔ Nodup s :=\n  ⟨Nodup.of_map _, fun h => h.map_on d⟩\n\n"}
{"name":"Multiset.nodup_map_iff_of_injective","module":"Mathlib.Data.Multiset.Nodup","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Multiset α\nf : α → β\nd : Function.Injective f\n⊢ Iff (Multiset.map f s).Nodup s.Nodup","decl":"theorem nodup_map_iff_of_injective {f : α → β} (d : Function.Injective f) :\n    Nodup (map f s) ↔ Nodup s :=\n  ⟨Nodup.of_map _, fun h => h.map d⟩\n\n"}
{"name":"Multiset.inj_on_of_nodup_map","module":"Mathlib.Data.Multiset.Nodup","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\ns : Multiset α\na✝³ : (Multiset.map f s).Nodup\nx : α\na✝² : Membership.mem s x\ny : α\na✝¹ : Membership.mem s y\na✝ : Eq (f x) (f y)\n⊢ Eq x y","decl":"theorem inj_on_of_nodup_map {f : α → β} {s : Multiset α} :\n    Nodup (map f s) → ∀ x ∈ s, ∀ y ∈ s, f x = f y → x = y :=\n  Quot.induction_on s fun _ => List.inj_on_of_nodup_map\n\n"}
{"name":"Multiset.nodup_map_iff_inj_on","module":"Mathlib.Data.Multiset.Nodup","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\ns : Multiset α\nd : s.Nodup\n⊢ Iff (Multiset.map f s).Nodup (∀ (x : α), Membership.mem s x → ∀ (y : α), Membership.mem s y → Eq (f x) (f y) → Eq x y)","decl":"theorem nodup_map_iff_inj_on {f : α → β} {s : Multiset α} (d : Nodup s) :\n    Nodup (map f s) ↔ ∀ x ∈ s, ∀ y ∈ s, f x = f y → x = y :=\n  ⟨inj_on_of_nodup_map, fun h => d.map_on h⟩\n\n"}
{"name":"Multiset.Nodup.filter","module":"Mathlib.Data.Multiset.Nodup","initialProofState":"α : Type u_1\np : α → Prop\ninst✝ : DecidablePred p\ns : Multiset α\na✝ : s.Nodup\n⊢ (Multiset.filter p s).Nodup","decl":"theorem Nodup.filter (p : α → Prop) [DecidablePred p] {s} : Nodup s → Nodup (filter p s) :=\n  Quot.induction_on s fun _ => List.Nodup.filter (p ·)\n\n"}
{"name":"Multiset.nodup_attach","module":"Mathlib.Data.Multiset.Nodup","initialProofState":"α : Type u_1\ns : Multiset α\n⊢ Iff s.attach.Nodup s.Nodup","decl":"@[simp]\ntheorem nodup_attach {s : Multiset α} : Nodup (attach s) ↔ Nodup s :=\n  Quot.induction_on s fun _ => List.nodup_attach\n\n"}
{"name":"Multiset.Nodup.attach","module":"Mathlib.Data.Multiset.Nodup","initialProofState":"α : Type u_1\ns : Multiset α\na✝ : s.Nodup\n⊢ s.attach.Nodup","decl":"protected alias ⟨_, Nodup.attach⟩ := nodup_attach\n\n"}
{"name":"Multiset.Nodup.pmap","module":"Mathlib.Data.Multiset.Nodup","initialProofState":"α : Type u_1\nβ : Type u_2\np : α → Prop\nf : (a : α) → p a → β\ns : Multiset α\nH : ∀ (a : α), Membership.mem s a → p a\nhf : ∀ (a : α) (ha : p a) (b : α) (hb : p b), Eq (f a ha) (f b hb) → Eq a b\na✝ : s.Nodup\n⊢ (Multiset.pmap f s H).Nodup","decl":"theorem Nodup.pmap {p : α → Prop} {f : ∀ a, p a → β} {s : Multiset α} {H}\n    (hf : ∀ a ha b hb, f a ha = f b hb → a = b) : Nodup s → Nodup (pmap f s H) :=\n  Quot.induction_on s (fun _ _ => List.Nodup.pmap hf) H\n\n"}
{"name":"Multiset.Nodup.erase_eq_filter","module":"Mathlib.Data.Multiset.Nodup","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na : α\ns : Multiset α\na✝ : s.Nodup\n⊢ Eq (s.erase a) (Multiset.filter (fun x => Ne x a) s)","decl":"theorem Nodup.erase_eq_filter [DecidableEq α] (a : α) {s} :\n    Nodup s → s.erase a = Multiset.filter (· ≠ a) s :=\n  Quot.induction_on s fun _ d =>\n    congr_arg ((↑) : List α → Multiset α) <| by simpa using List.Nodup.erase_eq_filter d a\n\n"}
{"name":"Multiset.Nodup.erase","module":"Mathlib.Data.Multiset.Nodup","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na : α\nl : Multiset α\na✝ : l.Nodup\n⊢ (l.erase a).Nodup","decl":"theorem Nodup.erase [DecidableEq α] (a : α) {l} : Nodup l → Nodup (l.erase a) :=\n  nodup_of_le (erase_le _ _)\n\n"}
{"name":"Multiset.Nodup.mem_erase_iff","module":"Mathlib.Data.Multiset.Nodup","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na b : α\nl : Multiset α\nd : l.Nodup\n⊢ Iff (Membership.mem (l.erase b) a) (And (Ne a b) (Membership.mem l a))","decl":"theorem Nodup.mem_erase_iff [DecidableEq α] {a b : α} {l} (d : Nodup l) :\n    a ∈ l.erase b ↔ a ≠ b ∧ a ∈ l := by\n  rw [d.erase_eq_filter b, mem_filter, and_comm]\n\n"}
{"name":"Multiset.Nodup.not_mem_erase","module":"Mathlib.Data.Multiset.Nodup","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na : α\ns : Multiset α\nh : s.Nodup\n⊢ Not (Membership.mem (s.erase a) a)","decl":"theorem Nodup.not_mem_erase [DecidableEq α] {a : α} {s} (h : Nodup s) : a ∉ s.erase a := fun ha =>\n  (h.mem_erase_iff.1 ha).1 rfl\n\n"}
{"name":"Multiset.Nodup.filterMap","module":"Mathlib.Data.Multiset.Nodup","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Multiset α\nf : α → Option β\nH : ∀ (a a' : α) (b : β), Membership.mem (f a) b → Membership.mem (f a') b → Eq a a'\na✝ : s.Nodup\n⊢ (Multiset.filterMap f s).Nodup","decl":"protected theorem Nodup.filterMap (f : α → Option β) (H : ∀ a a' b, b ∈ f a → b ∈ f a' → a = a') :\n    Nodup s → Nodup (filterMap f s) :=\n  Quot.induction_on s fun _ => List.Nodup.filterMap H\n\n"}
{"name":"Multiset.nodup_range","module":"Mathlib.Data.Multiset.Nodup","initialProofState":"n : Nat\n⊢ (Multiset.range n).Nodup","decl":"theorem nodup_range (n : ℕ) : Nodup (range n) :=\n  List.nodup_range _\n\n"}
{"name":"Multiset.Nodup.inter_left","module":"Mathlib.Data.Multiset.Nodup","initialProofState":"α : Type u_1\ns : Multiset α\ninst✝ : DecidableEq α\nt : Multiset α\na✝ : s.Nodup\n⊢ (Inter.inter s t).Nodup","decl":"lemma Nodup.inter_left [DecidableEq α] (t) : Nodup s → Nodup (s ∩ t) := nodup_of_le inter_le_left\n"}
{"name":"Multiset.Nodup.inter_right","module":"Mathlib.Data.Multiset.Nodup","initialProofState":"α : Type u_1\nt : Multiset α\ninst✝ : DecidableEq α\ns : Multiset α\na✝ : t.Nodup\n⊢ (Inter.inter s t).Nodup","decl":"lemma Nodup.inter_right [DecidableEq α] (s) : Nodup t → Nodup (s ∩ t) := nodup_of_le inter_le_right\n\n"}
{"name":"Multiset.nodup_union","module":"Mathlib.Data.Multiset.Nodup","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t : Multiset α\n⊢ Iff (Union.union s t).Nodup (And s.Nodup t.Nodup)","decl":"@[simp]\ntheorem nodup_union [DecidableEq α] {s t : Multiset α} : Nodup (s ∪ t) ↔ Nodup s ∧ Nodup t :=\n  ⟨fun h => ⟨nodup_of_le le_union_left h, nodup_of_le le_union_right h⟩, fun ⟨h₁, h₂⟩ =>\n    nodup_iff_count_le_one.2 fun a => by\n      rw [count_union]\n      exact max_le (nodup_iff_count_le_one.1 h₁ a) (nodup_iff_count_le_one.1 h₂ a)⟩\n\n"}
{"name":"Multiset.Nodup.ext","module":"Mathlib.Data.Multiset.Nodup","initialProofState":"α : Type u_1\ns t : Multiset α\na✝¹ : s.Nodup\na✝ : t.Nodup\n⊢ Iff (Eq s t) (∀ (a : α), Iff (Membership.mem s a) (Membership.mem t a))","decl":"theorem Nodup.ext {s t : Multiset α} : Nodup s → Nodup t → (s = t ↔ ∀ a, a ∈ s ↔ a ∈ t) :=\n  Quotient.inductionOn₂ s t fun _ _ d₁ d₂ => Quotient.eq.trans <| perm_ext_iff_of_nodup d₁ d₂\n\n"}
{"name":"Multiset.le_iff_subset","module":"Mathlib.Data.Multiset.Nodup","initialProofState":"α : Type u_1\ns t : Multiset α\na✝ : s.Nodup\n⊢ Iff (LE.le s t) (HasSubset.Subset s t)","decl":"theorem le_iff_subset {s t : Multiset α} : Nodup s → (s ≤ t ↔ s ⊆ t) :=\n  Quotient.inductionOn₂ s t fun _ _ d => ⟨subset_of_le, d.subperm⟩\n\n"}
{"name":"Multiset.range_le","module":"Mathlib.Data.Multiset.Nodup","initialProofState":"m n : Nat\n⊢ Iff (LE.le (Multiset.range m) (Multiset.range n)) (LE.le m n)","decl":"theorem range_le {m n : ℕ} : range m ≤ range n ↔ m ≤ n :=\n  (le_iff_subset (nodup_range _)).trans range_subset\n\n"}
{"name":"Multiset.mem_sub_of_nodup","module":"Mathlib.Data.Multiset.Nodup","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na : α\ns t : Multiset α\nd : s.Nodup\n⊢ Iff (Membership.mem (HSub.hSub s t) a) (And (Membership.mem s a) (Not (Membership.mem t a)))","decl":"theorem mem_sub_of_nodup [DecidableEq α] {a : α} {s t : Multiset α} (d : Nodup s) :\n    a ∈ s - t ↔ a ∈ s ∧ a ∉ t :=\n  ⟨fun h =>\n    ⟨mem_of_le (Multiset.sub_le_self ..) h, fun h' => by\n      refine count_eq_zero.1 ?_ h\n      rw [count_sub a s t, Nat.sub_eq_zero_iff_le]\n      exact le_trans (nodup_iff_count_le_one.1 d _) (count_pos.2 h')⟩,\n    fun ⟨h₁, h₂⟩ => Or.resolve_right (mem_add.1 <| mem_of_le Multiset.le_sub_add h₁) h₂⟩\n\n"}
{"name":"Multiset.map_eq_map_of_bij_of_nodup","module":"Mathlib.Data.Multiset.Nodup","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nf : α → γ\ng : β → γ\ns : Multiset α\nt : Multiset β\nhs : s.Nodup\nht : t.Nodup\ni : (a : α) → Membership.mem s a → β\nhi : ∀ (a : α) (ha : Membership.mem s a), Membership.mem t (i a ha)\ni_inj : ∀ (a₁ : α) (ha₁ : Membership.mem s a₁) (a₂ : α) (ha₂ : Membership.mem s a₂), Eq (i a₁ ha₁) (i a₂ ha₂) → Eq a₁ a₂\ni_surj : ∀ (b : β), Membership.mem t b → Exists fun a => Exists fun ha => Eq (i a ha) b\nh : ∀ (a : α) (ha : Membership.mem s a), Eq (f a) (g (i a ha))\n⊢ Eq (Multiset.map f s) (Multiset.map g t)","decl":"theorem map_eq_map_of_bij_of_nodup (f : α → γ) (g : β → γ) {s : Multiset α} {t : Multiset β}\n    (hs : s.Nodup) (ht : t.Nodup) (i : ∀ a ∈ s, β) (hi : ∀ a ha, i a ha ∈ t)\n    (i_inj : ∀ a₁ ha₁ a₂ ha₂, i a₁ ha₁ = i a₂ ha₂ → a₁ = a₂)\n    (i_surj : ∀ b ∈ t, ∃ a ha, i a ha = b) (h : ∀ a ha, f a = g (i a ha)) : s.map f = t.map g := by\n  have : t = s.attach.map fun x => i x.1 x.2 := by\n    rw [ht.ext]\n    · aesop\n    · exact hs.attach.map fun x y hxy ↦ Subtype.ext <| i_inj _ x.2 _ y.2 hxy\n  calc\n    s.map f = s.pmap (fun x _ => f x) fun _ => id := by rw [pmap_eq_map]\n    _ = s.attach.map fun x => f x.1 := by rw [pmap_eq_map_attach]\n    _ = t.map g := by rw [this, Multiset.map_map]; exact map_congr rfl fun x _ => h _ _\n\n"}
