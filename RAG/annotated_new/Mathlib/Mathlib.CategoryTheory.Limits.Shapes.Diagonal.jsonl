{"name":"CategoryTheory.Limits.pullback.diagonal_fst","module":"Mathlib.CategoryTheory.Limits.Shapes.Diagonal","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\nX Y : C\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.Limits.HasPullback f f\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.diagonal f) (CategoryTheory.Limits.pullback.fst f f)) (CategoryTheory.CategoryStruct.id X)","decl":"@[reassoc (attr := simp)]\ntheorem diagonal_fst : diagonal f ≫ pullback.fst _ _ = 𝟙 _ :=\n  pullback.lift_fst _ _ _\n\n"}
{"name":"CategoryTheory.Limits.pullback.diagonal_fst_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Diagonal","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\nX Y : C\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.Limits.HasPullback f f\nZ : C\nh : Quiver.Hom X Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.diagonal f) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst f f) h)) h","decl":"@[reassoc (attr := simp)]\ntheorem diagonal_fst : diagonal f ≫ pullback.fst _ _ = 𝟙 _ :=\n  pullback.lift_fst _ _ _\n\n"}
{"name":"CategoryTheory.Limits.pullback.diagonal_snd_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Diagonal","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\nX Y : C\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.Limits.HasPullback f f\nZ : C\nh : Quiver.Hom X Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.diagonal f) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd f f) h)) h","decl":"@[reassoc (attr := simp)]\ntheorem diagonal_snd : diagonal f ≫ pullback.snd _ _ = 𝟙 _ :=\n  pullback.lift_snd _ _ _\n\n"}
{"name":"CategoryTheory.Limits.pullback.diagonal_snd","module":"Mathlib.CategoryTheory.Limits.Shapes.Diagonal","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\nX Y : C\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.Limits.HasPullback f f\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.diagonal f) (CategoryTheory.Limits.pullback.snd f f)) (CategoryTheory.CategoryStruct.id X)","decl":"@[reassoc (attr := simp)]\ntheorem diagonal_snd : diagonal f ≫ pullback.snd _ _ = 𝟙 _ :=\n  pullback.lift_snd _ _ _\n\n"}
{"name":"CategoryTheory.Limits.pullback.instIsSplitMonoDiagonal","module":"Mathlib.CategoryTheory.Limits.Shapes.Diagonal","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\nX Y : C\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.Limits.HasPullback f f\n⊢ CategoryTheory.IsSplitMono (CategoryTheory.Limits.pullback.diagonal f)","decl":"instance : IsSplitMono (diagonal f) :=\n  ⟨⟨⟨pullback.fst _ _, diagonal_fst f⟩⟩⟩\n\n"}
{"name":"CategoryTheory.Limits.pullback.instIsSplitEpiFst","module":"Mathlib.CategoryTheory.Limits.Shapes.Diagonal","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\nX Y : C\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.Limits.HasPullback f f\n⊢ CategoryTheory.IsSplitEpi (CategoryTheory.Limits.pullback.fst f f)","decl":"instance : IsSplitEpi (pullback.fst f f) :=\n  ⟨⟨⟨diagonal f, diagonal_fst f⟩⟩⟩\n\n"}
{"name":"CategoryTheory.Limits.pullback.instIsSplitEpiSnd","module":"Mathlib.CategoryTheory.Limits.Shapes.Diagonal","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\nX Y : C\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.Limits.HasPullback f f\n⊢ CategoryTheory.IsSplitEpi (CategoryTheory.Limits.pullback.snd f f)","decl":"instance : IsSplitEpi (pullback.snd f f) :=\n  ⟨⟨⟨diagonal f, diagonal_snd f⟩⟩⟩\n\n"}
{"name":"CategoryTheory.Limits.pullback.instIsIsoDiagonalOfMono","module":"Mathlib.CategoryTheory.Limits.Shapes.Diagonal","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\nX Y : C\nf : Quiver.Hom X Y\ninst✝¹ : CategoryTheory.Limits.HasPullback f f\ninst✝ : CategoryTheory.Mono f\n⊢ CategoryTheory.IsIso (CategoryTheory.Limits.pullback.diagonal f)","decl":"instance [Mono f] : IsIso (diagonal f) := by\n  rw [(IsIso.inv_eq_of_inv_hom_id (diagonal_fst f)).symm]\n  infer_instance\n\n"}
{"name":"CategoryTheory.Limits.pullback.isIso_diagonal_iff","module":"Mathlib.CategoryTheory.Limits.Shapes.Diagonal","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\nX Y : C\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.Limits.HasPullback f f\n⊢ Iff (CategoryTheory.IsIso (CategoryTheory.Limits.pullback.diagonal f)) (CategoryTheory.Mono f)","decl":"lemma isIso_diagonal_iff : IsIso (diagonal f) ↔ Mono f :=\n  ⟨fun H ↦ ⟨fun _ _ e ↦ by rw [← lift_fst _ _ e, (cancel_epi (g := fst f f) (h := snd f f)\n    (diagonal f)).mp (by simp), lift_snd]⟩, fun _ ↦ inferInstance⟩\n\n"}
{"name":"CategoryTheory.Limits.pullback.diagonal_isKernelPair","module":"Mathlib.CategoryTheory.Limits.Shapes.Diagonal","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\nX Y : C\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.Limits.HasPullback f f\n⊢ CategoryTheory.IsKernelPair f (CategoryTheory.Limits.pullback.fst f f) (CategoryTheory.Limits.pullback.snd f f)","decl":"/-- The two projections `Δ_{X/Y} ⟶ X` form a kernel pair for `f : X ⟶ Y`. -/\ntheorem diagonal_isKernelPair : IsKernelPair f (pullback.fst f f) (pullback.snd f f) :=\n  IsPullback.of_hasPullback f f\n\n"}
{"name":"CategoryTheory.Limits.pullback_diagonal_map_snd_fst_fst_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Diagonal","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\nX Y : C\ninst✝ : CategoryTheory.Limits.HasPullbacks C\nU V₁ V₂ : C\nf : Quiver.Hom X Y\ni : Quiver.Hom U Y\ni₁ : Quiver.Hom V₁ (CategoryTheory.Limits.pullback f i)\ni₂ : Quiver.Hom V₂ (CategoryTheory.Limits.pullback f i)\nZ : C\nh : Quiver.Hom X Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd (CategoryTheory.Limits.pullback.diagonal f) (CategoryTheory.Limits.pullback.map (CategoryTheory.CategoryStruct.comp i₁ (CategoryTheory.Limits.pullback.snd f i)) (CategoryTheory.CategoryStruct.comp i₂ (CategoryTheory.Limits.pullback.snd f i)) f f (CategoryTheory.CategoryStruct.comp i₁ (CategoryTheory.Limits.pullback.fst f i)) (CategoryTheory.CategoryStruct.comp i₂ (CategoryTheory.Limits.pullback.fst f i)) i ⋯ ⋯)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp i₁ (CategoryTheory.Limits.pullback.snd f i)) (CategoryTheory.CategoryStruct.comp i₂ (CategoryTheory.Limits.pullback.snd f i))) (CategoryTheory.CategoryStruct.comp i₁ (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst f i) h)))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.Limits.pullback.diagonal f) (CategoryTheory.Limits.pullback.map (CategoryTheory.CategoryStruct.comp i₁ (CategoryTheory.Limits.pullback.snd f i)) (CategoryTheory.CategoryStruct.comp i₂ (CategoryTheory.Limits.pullback.snd f i)) f f (CategoryTheory.CategoryStruct.comp i₁ (CategoryTheory.Limits.pullback.fst f i)) (CategoryTheory.CategoryStruct.comp i₂ (CategoryTheory.Limits.pullback.fst f i)) i ⋯ ⋯)) h)","decl":"@[reassoc (attr := simp)]\ntheorem pullback_diagonal_map_snd_fst_fst :\n    (pullback.snd (diagonal f)\n      (map (i₁ ≫ snd f i) (i₂ ≫ snd f i) f f (i₁ ≫ fst f i) (i₂ ≫ fst f i) i\n        (by simp [condition]) (by simp [condition]))) ≫\n      fst _ _ ≫ i₁ ≫ fst _ _ =\n      pullback.fst _ _ := by\n  conv_rhs => rw [← Category.comp_id (pullback.fst _ _)]\n  rw [← diagonal_fst f, pullback.condition_assoc, pullback.lift_fst]\n\n"}
{"name":"CategoryTheory.Limits.pullback_diagonal_map_snd_fst_fst","module":"Mathlib.CategoryTheory.Limits.Shapes.Diagonal","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\nX Y : C\ninst✝ : CategoryTheory.Limits.HasPullbacks C\nU V₁ V₂ : C\nf : Quiver.Hom X Y\ni : Quiver.Hom U Y\ni₁ : Quiver.Hom V₁ (CategoryTheory.Limits.pullback f i)\ni₂ : Quiver.Hom V₂ (CategoryTheory.Limits.pullback f i)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd (CategoryTheory.Limits.pullback.diagonal f) (CategoryTheory.Limits.pullback.map (CategoryTheory.CategoryStruct.comp i₁ (CategoryTheory.Limits.pullback.snd f i)) (CategoryTheory.CategoryStruct.comp i₂ (CategoryTheory.Limits.pullback.snd f i)) f f (CategoryTheory.CategoryStruct.comp i₁ (CategoryTheory.Limits.pullback.fst f i)) (CategoryTheory.CategoryStruct.comp i₂ (CategoryTheory.Limits.pullback.fst f i)) i ⋯ ⋯)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp i₁ (CategoryTheory.Limits.pullback.snd f i)) (CategoryTheory.CategoryStruct.comp i₂ (CategoryTheory.Limits.pullback.snd f i))) (CategoryTheory.CategoryStruct.comp i₁ (CategoryTheory.Limits.pullback.fst f i)))) (CategoryTheory.Limits.pullback.fst (CategoryTheory.Limits.pullback.diagonal f) (CategoryTheory.Limits.pullback.map (CategoryTheory.CategoryStruct.comp i₁ (CategoryTheory.Limits.pullback.snd f i)) (CategoryTheory.CategoryStruct.comp i₂ (CategoryTheory.Limits.pullback.snd f i)) f f (CategoryTheory.CategoryStruct.comp i₁ (CategoryTheory.Limits.pullback.fst f i)) (CategoryTheory.CategoryStruct.comp i₂ (CategoryTheory.Limits.pullback.fst f i)) i ⋯ ⋯))","decl":"@[reassoc (attr := simp)]\ntheorem pullback_diagonal_map_snd_fst_fst :\n    (pullback.snd (diagonal f)\n      (map (i₁ ≫ snd f i) (i₂ ≫ snd f i) f f (i₁ ≫ fst f i) (i₂ ≫ fst f i) i\n        (by simp [condition]) (by simp [condition]))) ≫\n      fst _ _ ≫ i₁ ≫ fst _ _ =\n      pullback.fst _ _ := by\n  conv_rhs => rw [← Category.comp_id (pullback.fst _ _)]\n  rw [← diagonal_fst f, pullback.condition_assoc, pullback.lift_fst]\n\n"}
{"name":"CategoryTheory.Limits.pullback_diagonal_map_snd_snd_fst","module":"Mathlib.CategoryTheory.Limits.Shapes.Diagonal","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\nX Y : C\ninst✝ : CategoryTheory.Limits.HasPullbacks C\nU V₁ V₂ : C\nf : Quiver.Hom X Y\ni : Quiver.Hom U Y\ni₁ : Quiver.Hom V₁ (CategoryTheory.Limits.pullback f i)\ni₂ : Quiver.Hom V₂ (CategoryTheory.Limits.pullback f i)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd (CategoryTheory.Limits.pullback.diagonal f) (CategoryTheory.Limits.pullback.map (CategoryTheory.CategoryStruct.comp i₁ (CategoryTheory.Limits.pullback.snd f i)) (CategoryTheory.CategoryStruct.comp i₂ (CategoryTheory.Limits.pullback.snd f i)) f f (CategoryTheory.CategoryStruct.comp i₁ (CategoryTheory.Limits.pullback.fst f i)) (CategoryTheory.CategoryStruct.comp i₂ (CategoryTheory.Limits.pullback.fst f i)) i ⋯ ⋯)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd (CategoryTheory.CategoryStruct.comp i₁ (CategoryTheory.Limits.pullback.snd f i)) (CategoryTheory.CategoryStruct.comp i₂ (CategoryTheory.Limits.pullback.snd f i))) (CategoryTheory.CategoryStruct.comp i₂ (CategoryTheory.Limits.pullback.fst f i)))) (CategoryTheory.Limits.pullback.fst (CategoryTheory.Limits.pullback.diagonal f) (CategoryTheory.Limits.pullback.map (CategoryTheory.CategoryStruct.comp i₁ (CategoryTheory.Limits.pullback.snd f i)) (CategoryTheory.CategoryStruct.comp i₂ (CategoryTheory.Limits.pullback.snd f i)) f f (CategoryTheory.CategoryStruct.comp i₁ (CategoryTheory.Limits.pullback.fst f i)) (CategoryTheory.CategoryStruct.comp i₂ (CategoryTheory.Limits.pullback.fst f i)) i ⋯ ⋯))","decl":"@[reassoc (attr := simp)]\ntheorem pullback_diagonal_map_snd_snd_fst :\n    (pullback.snd (diagonal f)\n      (map (i₁ ≫ snd f i) (i₂ ≫ snd f i) f f (i₁ ≫ fst f i) (i₂ ≫ fst f i) i\n        (by simp [condition]) (by simp [condition]))) ≫\n      snd _ _ ≫ i₂ ≫ fst _ _ =\n      pullback.fst _ _ := by\n  conv_rhs => rw [← Category.comp_id (pullback.fst _ _)]\n  rw [← diagonal_snd f, pullback.condition_assoc, pullback.lift_snd]\n\n"}
{"name":"CategoryTheory.Limits.pullback_diagonal_map_snd_snd_fst_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Diagonal","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\nX Y : C\ninst✝ : CategoryTheory.Limits.HasPullbacks C\nU V₁ V₂ : C\nf : Quiver.Hom X Y\ni : Quiver.Hom U Y\ni₁ : Quiver.Hom V₁ (CategoryTheory.Limits.pullback f i)\ni₂ : Quiver.Hom V₂ (CategoryTheory.Limits.pullback f i)\nZ : C\nh : Quiver.Hom X Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd (CategoryTheory.Limits.pullback.diagonal f) (CategoryTheory.Limits.pullback.map (CategoryTheory.CategoryStruct.comp i₁ (CategoryTheory.Limits.pullback.snd f i)) (CategoryTheory.CategoryStruct.comp i₂ (CategoryTheory.Limits.pullback.snd f i)) f f (CategoryTheory.CategoryStruct.comp i₁ (CategoryTheory.Limits.pullback.fst f i)) (CategoryTheory.CategoryStruct.comp i₂ (CategoryTheory.Limits.pullback.fst f i)) i ⋯ ⋯)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd (CategoryTheory.CategoryStruct.comp i₁ (CategoryTheory.Limits.pullback.snd f i)) (CategoryTheory.CategoryStruct.comp i₂ (CategoryTheory.Limits.pullback.snd f i))) (CategoryTheory.CategoryStruct.comp i₂ (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst f i) h)))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.Limits.pullback.diagonal f) (CategoryTheory.Limits.pullback.map (CategoryTheory.CategoryStruct.comp i₁ (CategoryTheory.Limits.pullback.snd f i)) (CategoryTheory.CategoryStruct.comp i₂ (CategoryTheory.Limits.pullback.snd f i)) f f (CategoryTheory.CategoryStruct.comp i₁ (CategoryTheory.Limits.pullback.fst f i)) (CategoryTheory.CategoryStruct.comp i₂ (CategoryTheory.Limits.pullback.fst f i)) i ⋯ ⋯)) h)","decl":"@[reassoc (attr := simp)]\ntheorem pullback_diagonal_map_snd_snd_fst :\n    (pullback.snd (diagonal f)\n      (map (i₁ ≫ snd f i) (i₂ ≫ snd f i) f f (i₁ ≫ fst f i) (i₂ ≫ fst f i) i\n        (by simp [condition]) (by simp [condition]))) ≫\n      snd _ _ ≫ i₂ ≫ fst _ _ =\n      pullback.fst _ _ := by\n  conv_rhs => rw [← Category.comp_id (pullback.fst _ _)]\n  rw [← diagonal_snd f, pullback.condition_assoc, pullback.lift_snd]\n\n"}
{"name":"CategoryTheory.Limits.pullbackDiagonalMapIso.hom_fst_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Diagonal","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\nX Y : C\ninst✝¹ : CategoryTheory.Limits.HasPullbacks C\nU V₁ V₂ : C\nf : Quiver.Hom X Y\ni : Quiver.Hom U Y\ni₁ : Quiver.Hom V₁ (CategoryTheory.Limits.pullback f i)\ni₂ : Quiver.Hom V₂ (CategoryTheory.Limits.pullback f i)\ninst✝ : CategoryTheory.Limits.HasPullback i₁ i₂\nZ : C\nh : Quiver.Hom V₁ Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullbackDiagonalMapIso f i i₁ i₂).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst i₁ i₂) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd (CategoryTheory.Limits.pullback.diagonal f) (CategoryTheory.Limits.pullback.map (CategoryTheory.CategoryStruct.comp i₁ (CategoryTheory.Limits.pullback.snd f i)) (CategoryTheory.CategoryStruct.comp i₂ (CategoryTheory.Limits.pullback.snd f i)) f f (CategoryTheory.CategoryStruct.comp i₁ (CategoryTheory.Limits.pullback.fst f i)) (CategoryTheory.CategoryStruct.comp i₂ (CategoryTheory.Limits.pullback.fst f i)) i ⋯ ⋯)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp i₁ (CategoryTheory.Limits.pullback.snd f i)) (CategoryTheory.CategoryStruct.comp i₂ (CategoryTheory.Limits.pullback.snd f i))) h))","decl":"@[reassoc (attr := simp)]\ntheorem pullbackDiagonalMapIso.hom_fst :\n    (pullbackDiagonalMapIso f i i₁ i₂).hom ≫ pullback.fst _ _ =\n      pullback.snd _ _ ≫ pullback.fst _ _ := by\n  delta pullbackDiagonalMapIso\n  simp only [limit.lift_π, PullbackCone.mk_pt, PullbackCone.mk_π_app]\n\n"}
{"name":"CategoryTheory.Limits.pullbackDiagonalMapIso.hom_fst","module":"Mathlib.CategoryTheory.Limits.Shapes.Diagonal","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\nX Y : C\ninst✝¹ : CategoryTheory.Limits.HasPullbacks C\nU V₁ V₂ : C\nf : Quiver.Hom X Y\ni : Quiver.Hom U Y\ni₁ : Quiver.Hom V₁ (CategoryTheory.Limits.pullback f i)\ni₂ : Quiver.Hom V₂ (CategoryTheory.Limits.pullback f i)\ninst✝ : CategoryTheory.Limits.HasPullback i₁ i₂\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullbackDiagonalMapIso f i i₁ i₂).hom (CategoryTheory.Limits.pullback.fst i₁ i₂)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd (CategoryTheory.Limits.pullback.diagonal f) (CategoryTheory.Limits.pullback.map (CategoryTheory.CategoryStruct.comp i₁ (CategoryTheory.Limits.pullback.snd f i)) (CategoryTheory.CategoryStruct.comp i₂ (CategoryTheory.Limits.pullback.snd f i)) f f (CategoryTheory.CategoryStruct.comp i₁ (CategoryTheory.Limits.pullback.fst f i)) (CategoryTheory.CategoryStruct.comp i₂ (CategoryTheory.Limits.pullback.fst f i)) i ⋯ ⋯)) (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp i₁ (CategoryTheory.Limits.pullback.snd f i)) (CategoryTheory.CategoryStruct.comp i₂ (CategoryTheory.Limits.pullback.snd f i))))","decl":"@[reassoc (attr := simp)]\ntheorem pullbackDiagonalMapIso.hom_fst :\n    (pullbackDiagonalMapIso f i i₁ i₂).hom ≫ pullback.fst _ _ =\n      pullback.snd _ _ ≫ pullback.fst _ _ := by\n  delta pullbackDiagonalMapIso\n  simp only [limit.lift_π, PullbackCone.mk_pt, PullbackCone.mk_π_app]\n\n"}
{"name":"CategoryTheory.Limits.pullbackDiagonalMapIso.hom_snd_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Diagonal","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\nX Y : C\ninst✝¹ : CategoryTheory.Limits.HasPullbacks C\nU V₁ V₂ : C\nf : Quiver.Hom X Y\ni : Quiver.Hom U Y\ni₁ : Quiver.Hom V₁ (CategoryTheory.Limits.pullback f i)\ni₂ : Quiver.Hom V₂ (CategoryTheory.Limits.pullback f i)\ninst✝ : CategoryTheory.Limits.HasPullback i₁ i₂\nZ : C\nh : Quiver.Hom V₂ Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullbackDiagonalMapIso f i i₁ i₂).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd i₁ i₂) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd (CategoryTheory.Limits.pullback.diagonal f) (CategoryTheory.Limits.pullback.map (CategoryTheory.CategoryStruct.comp i₁ (CategoryTheory.Limits.pullback.snd f i)) (CategoryTheory.CategoryStruct.comp i₂ (CategoryTheory.Limits.pullback.snd f i)) f f (CategoryTheory.CategoryStruct.comp i₁ (CategoryTheory.Limits.pullback.fst f i)) (CategoryTheory.CategoryStruct.comp i₂ (CategoryTheory.Limits.pullback.fst f i)) i ⋯ ⋯)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd (CategoryTheory.CategoryStruct.comp i₁ (CategoryTheory.Limits.pullback.snd f i)) (CategoryTheory.CategoryStruct.comp i₂ (CategoryTheory.Limits.pullback.snd f i))) h))","decl":"@[reassoc (attr := simp)]\ntheorem pullbackDiagonalMapIso.hom_snd :\n    (pullbackDiagonalMapIso f i i₁ i₂).hom ≫ pullback.snd _ _ =\n      pullback.snd _ _ ≫ pullback.snd _ _ := by\n  delta pullbackDiagonalMapIso\n  simp only [limit.lift_π, PullbackCone.mk_pt, PullbackCone.mk_π_app]\n\n"}
{"name":"CategoryTheory.Limits.pullbackDiagonalMapIso.hom_snd","module":"Mathlib.CategoryTheory.Limits.Shapes.Diagonal","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\nX Y : C\ninst✝¹ : CategoryTheory.Limits.HasPullbacks C\nU V₁ V₂ : C\nf : Quiver.Hom X Y\ni : Quiver.Hom U Y\ni₁ : Quiver.Hom V₁ (CategoryTheory.Limits.pullback f i)\ni₂ : Quiver.Hom V₂ (CategoryTheory.Limits.pullback f i)\ninst✝ : CategoryTheory.Limits.HasPullback i₁ i₂\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullbackDiagonalMapIso f i i₁ i₂).hom (CategoryTheory.Limits.pullback.snd i₁ i₂)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd (CategoryTheory.Limits.pullback.diagonal f) (CategoryTheory.Limits.pullback.map (CategoryTheory.CategoryStruct.comp i₁ (CategoryTheory.Limits.pullback.snd f i)) (CategoryTheory.CategoryStruct.comp i₂ (CategoryTheory.Limits.pullback.snd f i)) f f (CategoryTheory.CategoryStruct.comp i₁ (CategoryTheory.Limits.pullback.fst f i)) (CategoryTheory.CategoryStruct.comp i₂ (CategoryTheory.Limits.pullback.fst f i)) i ⋯ ⋯)) (CategoryTheory.Limits.pullback.snd (CategoryTheory.CategoryStruct.comp i₁ (CategoryTheory.Limits.pullback.snd f i)) (CategoryTheory.CategoryStruct.comp i₂ (CategoryTheory.Limits.pullback.snd f i))))","decl":"@[reassoc (attr := simp)]\ntheorem pullbackDiagonalMapIso.hom_snd :\n    (pullbackDiagonalMapIso f i i₁ i₂).hom ≫ pullback.snd _ _ =\n      pullback.snd _ _ ≫ pullback.snd _ _ := by\n  delta pullbackDiagonalMapIso\n  simp only [limit.lift_π, PullbackCone.mk_pt, PullbackCone.mk_π_app]\n\n"}
{"name":"CategoryTheory.Limits.pullbackDiagonalMapIso.inv_fst_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Diagonal","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\nX Y : C\ninst✝¹ : CategoryTheory.Limits.HasPullbacks C\nU V₁ V₂ : C\nf : Quiver.Hom X Y\ni : Quiver.Hom U Y\ni₁ : Quiver.Hom V₁ (CategoryTheory.Limits.pullback f i)\ni₂ : Quiver.Hom V₂ (CategoryTheory.Limits.pullback f i)\ninst✝ : CategoryTheory.Limits.HasPullback i₁ i₂\nZ : C\nh : Quiver.Hom X Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullbackDiagonalMapIso f i i₁ i₂).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.Limits.pullback.diagonal f) (CategoryTheory.Limits.pullback.map (CategoryTheory.CategoryStruct.comp i₁ (CategoryTheory.Limits.pullback.snd f i)) (CategoryTheory.CategoryStruct.comp i₂ (CategoryTheory.Limits.pullback.snd f i)) f f (CategoryTheory.CategoryStruct.comp i₁ (CategoryTheory.Limits.pullback.fst f i)) (CategoryTheory.CategoryStruct.comp i₂ (CategoryTheory.Limits.pullback.fst f i)) i ⋯ ⋯)) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst i₁ i₂) (CategoryTheory.CategoryStruct.comp i₁ (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst f i) h)))","decl":"@[reassoc (attr := simp)]\ntheorem pullbackDiagonalMapIso.inv_fst :\n    (pullbackDiagonalMapIso f i i₁ i₂).inv ≫ pullback.fst _ _ =\n      pullback.fst _ _ ≫ i₁ ≫ pullback.fst _ _ := by\n  delta pullbackDiagonalMapIso\n  simp only [limit.lift_π, PullbackCone.mk_pt, PullbackCone.mk_π_app]\n\n"}
{"name":"CategoryTheory.Limits.pullbackDiagonalMapIso.inv_fst","module":"Mathlib.CategoryTheory.Limits.Shapes.Diagonal","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\nX Y : C\ninst✝¹ : CategoryTheory.Limits.HasPullbacks C\nU V₁ V₂ : C\nf : Quiver.Hom X Y\ni : Quiver.Hom U Y\ni₁ : Quiver.Hom V₁ (CategoryTheory.Limits.pullback f i)\ni₂ : Quiver.Hom V₂ (CategoryTheory.Limits.pullback f i)\ninst✝ : CategoryTheory.Limits.HasPullback i₁ i₂\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullbackDiagonalMapIso f i i₁ i₂).inv (CategoryTheory.Limits.pullback.fst (CategoryTheory.Limits.pullback.diagonal f) (CategoryTheory.Limits.pullback.map (CategoryTheory.CategoryStruct.comp i₁ (CategoryTheory.Limits.pullback.snd f i)) (CategoryTheory.CategoryStruct.comp i₂ (CategoryTheory.Limits.pullback.snd f i)) f f (CategoryTheory.CategoryStruct.comp i₁ (CategoryTheory.Limits.pullback.fst f i)) (CategoryTheory.CategoryStruct.comp i₂ (CategoryTheory.Limits.pullback.fst f i)) i ⋯ ⋯))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst i₁ i₂) (CategoryTheory.CategoryStruct.comp i₁ (CategoryTheory.Limits.pullback.fst f i)))","decl":"@[reassoc (attr := simp)]\ntheorem pullbackDiagonalMapIso.inv_fst :\n    (pullbackDiagonalMapIso f i i₁ i₂).inv ≫ pullback.fst _ _ =\n      pullback.fst _ _ ≫ i₁ ≫ pullback.fst _ _ := by\n  delta pullbackDiagonalMapIso\n  simp only [limit.lift_π, PullbackCone.mk_pt, PullbackCone.mk_π_app]\n\n"}
{"name":"CategoryTheory.Limits.pullbackDiagonalMapIso.inv_snd_fst_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Diagonal","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\nX Y : C\ninst✝¹ : CategoryTheory.Limits.HasPullbacks C\nU V₁ V₂ : C\nf : Quiver.Hom X Y\ni : Quiver.Hom U Y\ni₁ : Quiver.Hom V₁ (CategoryTheory.Limits.pullback f i)\ni₂ : Quiver.Hom V₂ (CategoryTheory.Limits.pullback f i)\ninst✝ : CategoryTheory.Limits.HasPullback i₁ i₂\nZ : C\nh : Quiver.Hom V₁ Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullbackDiagonalMapIso f i i₁ i₂).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd (CategoryTheory.Limits.pullback.diagonal f) (CategoryTheory.Limits.pullback.map (CategoryTheory.CategoryStruct.comp i₁ (CategoryTheory.Limits.pullback.snd f i)) (CategoryTheory.CategoryStruct.comp i₂ (CategoryTheory.Limits.pullback.snd f i)) f f (CategoryTheory.CategoryStruct.comp i₁ (CategoryTheory.Limits.pullback.fst f i)) (CategoryTheory.CategoryStruct.comp i₂ (CategoryTheory.Limits.pullback.fst f i)) i ⋯ ⋯)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp i₁ (CategoryTheory.Limits.pullback.snd f i)) (CategoryTheory.CategoryStruct.comp i₂ (CategoryTheory.Limits.pullback.snd f i))) h))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst i₁ i₂) h)","decl":"@[reassoc (attr := simp)]\ntheorem pullbackDiagonalMapIso.inv_snd_fst :\n    (pullbackDiagonalMapIso f i i₁ i₂).inv ≫ pullback.snd _ _ ≫ pullback.fst _ _ =\n      pullback.fst _ _ := by\n  delta pullbackDiagonalMapIso\n  simp\n\n"}
{"name":"CategoryTheory.Limits.pullbackDiagonalMapIso.inv_snd_fst","module":"Mathlib.CategoryTheory.Limits.Shapes.Diagonal","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\nX Y : C\ninst✝¹ : CategoryTheory.Limits.HasPullbacks C\nU V₁ V₂ : C\nf : Quiver.Hom X Y\ni : Quiver.Hom U Y\ni₁ : Quiver.Hom V₁ (CategoryTheory.Limits.pullback f i)\ni₂ : Quiver.Hom V₂ (CategoryTheory.Limits.pullback f i)\ninst✝ : CategoryTheory.Limits.HasPullback i₁ i₂\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullbackDiagonalMapIso f i i₁ i₂).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd (CategoryTheory.Limits.pullback.diagonal f) (CategoryTheory.Limits.pullback.map (CategoryTheory.CategoryStruct.comp i₁ (CategoryTheory.Limits.pullback.snd f i)) (CategoryTheory.CategoryStruct.comp i₂ (CategoryTheory.Limits.pullback.snd f i)) f f (CategoryTheory.CategoryStruct.comp i₁ (CategoryTheory.Limits.pullback.fst f i)) (CategoryTheory.CategoryStruct.comp i₂ (CategoryTheory.Limits.pullback.fst f i)) i ⋯ ⋯)) (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp i₁ (CategoryTheory.Limits.pullback.snd f i)) (CategoryTheory.CategoryStruct.comp i₂ (CategoryTheory.Limits.pullback.snd f i))))) (CategoryTheory.Limits.pullback.fst i₁ i₂)","decl":"@[reassoc (attr := simp)]\ntheorem pullbackDiagonalMapIso.inv_snd_fst :\n    (pullbackDiagonalMapIso f i i₁ i₂).inv ≫ pullback.snd _ _ ≫ pullback.fst _ _ =\n      pullback.fst _ _ := by\n  delta pullbackDiagonalMapIso\n  simp\n\n"}
{"name":"CategoryTheory.Limits.pullbackDiagonalMapIso.inv_snd_snd","module":"Mathlib.CategoryTheory.Limits.Shapes.Diagonal","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\nX Y : C\ninst✝¹ : CategoryTheory.Limits.HasPullbacks C\nU V₁ V₂ : C\nf : Quiver.Hom X Y\ni : Quiver.Hom U Y\ni₁ : Quiver.Hom V₁ (CategoryTheory.Limits.pullback f i)\ni₂ : Quiver.Hom V₂ (CategoryTheory.Limits.pullback f i)\ninst✝ : CategoryTheory.Limits.HasPullback i₁ i₂\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullbackDiagonalMapIso f i i₁ i₂).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd (CategoryTheory.Limits.pullback.diagonal f) (CategoryTheory.Limits.pullback.map (CategoryTheory.CategoryStruct.comp i₁ (CategoryTheory.Limits.pullback.snd f i)) (CategoryTheory.CategoryStruct.comp i₂ (CategoryTheory.Limits.pullback.snd f i)) f f (CategoryTheory.CategoryStruct.comp i₁ (CategoryTheory.Limits.pullback.fst f i)) (CategoryTheory.CategoryStruct.comp i₂ (CategoryTheory.Limits.pullback.fst f i)) i ⋯ ⋯)) (CategoryTheory.Limits.pullback.snd (CategoryTheory.CategoryStruct.comp i₁ (CategoryTheory.Limits.pullback.snd f i)) (CategoryTheory.CategoryStruct.comp i₂ (CategoryTheory.Limits.pullback.snd f i))))) (CategoryTheory.Limits.pullback.snd i₁ i₂)","decl":"@[reassoc (attr := simp)]\ntheorem pullbackDiagonalMapIso.inv_snd_snd :\n    (pullbackDiagonalMapIso f i i₁ i₂).inv ≫ pullback.snd _ _ ≫ pullback.snd _ _ =\n      pullback.snd _ _ := by\n  delta pullbackDiagonalMapIso\n  simp\n\n"}
{"name":"CategoryTheory.Limits.pullbackDiagonalMapIso.inv_snd_snd_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Diagonal","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\nX Y : C\ninst✝¹ : CategoryTheory.Limits.HasPullbacks C\nU V₁ V₂ : C\nf : Quiver.Hom X Y\ni : Quiver.Hom U Y\ni₁ : Quiver.Hom V₁ (CategoryTheory.Limits.pullback f i)\ni₂ : Quiver.Hom V₂ (CategoryTheory.Limits.pullback f i)\ninst✝ : CategoryTheory.Limits.HasPullback i₁ i₂\nZ : C\nh : Quiver.Hom V₂ Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullbackDiagonalMapIso f i i₁ i₂).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd (CategoryTheory.Limits.pullback.diagonal f) (CategoryTheory.Limits.pullback.map (CategoryTheory.CategoryStruct.comp i₁ (CategoryTheory.Limits.pullback.snd f i)) (CategoryTheory.CategoryStruct.comp i₂ (CategoryTheory.Limits.pullback.snd f i)) f f (CategoryTheory.CategoryStruct.comp i₁ (CategoryTheory.Limits.pullback.fst f i)) (CategoryTheory.CategoryStruct.comp i₂ (CategoryTheory.Limits.pullback.fst f i)) i ⋯ ⋯)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd (CategoryTheory.CategoryStruct.comp i₁ (CategoryTheory.Limits.pullback.snd f i)) (CategoryTheory.CategoryStruct.comp i₂ (CategoryTheory.Limits.pullback.snd f i))) h))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd i₁ i₂) h)","decl":"@[reassoc (attr := simp)]\ntheorem pullbackDiagonalMapIso.inv_snd_snd :\n    (pullbackDiagonalMapIso f i i₁ i₂).inv ≫ pullback.snd _ _ ≫ pullback.snd _ _ =\n      pullback.snd _ _ := by\n  delta pullbackDiagonalMapIso\n  simp\n\n"}
{"name":"CategoryTheory.Limits.pullback_fst_map_snd_isPullback","module":"Mathlib.CategoryTheory.Limits.Shapes.Diagonal","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\nX Y : C\ninst✝¹ : CategoryTheory.Limits.HasPullbacks C\nU V₁ V₂ : C\nf : Quiver.Hom X Y\ni : Quiver.Hom U Y\ni₁ : Quiver.Hom V₁ (CategoryTheory.Limits.pullback f i)\ni₂ : Quiver.Hom V₂ (CategoryTheory.Limits.pullback f i)\ninst✝ : CategoryTheory.Limits.HasPullback i₁ i₂\n⊢ CategoryTheory.IsPullback (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst i₁ i₂) (CategoryTheory.CategoryStruct.comp i₁ (CategoryTheory.Limits.pullback.fst f i))) (CategoryTheory.Limits.pullback.map i₁ i₂ (CategoryTheory.CategoryStruct.comp i₁ (CategoryTheory.Limits.pullback.snd f i)) (CategoryTheory.CategoryStruct.comp i₂ (CategoryTheory.Limits.pullback.snd f i)) (CategoryTheory.CategoryStruct.id V₁) (CategoryTheory.CategoryStruct.id V₂) (CategoryTheory.Limits.pullback.snd f i) ⋯ ⋯) (CategoryTheory.Limits.pullback.diagonal f) (CategoryTheory.Limits.pullback.map (CategoryTheory.CategoryStruct.comp i₁ (CategoryTheory.Limits.pullback.snd f i)) (CategoryTheory.CategoryStruct.comp i₂ (CategoryTheory.Limits.pullback.snd f i)) f f (CategoryTheory.CategoryStruct.comp i₁ (CategoryTheory.Limits.pullback.fst f i)) (CategoryTheory.CategoryStruct.comp i₂ (CategoryTheory.Limits.pullback.fst f i)) i ⋯ ⋯)","decl":"theorem pullback_fst_map_snd_isPullback :\n    IsPullback (fst _ _ ≫ i₁ ≫ fst _ _)\n      (map i₁ i₂ (i₁ ≫ snd _ _) (i₂ ≫ snd _ _) _ _ _\n        (Category.id_comp _).symm (Category.id_comp _).symm)\n      (diagonal f)\n      (map (i₁ ≫ snd _ _) (i₂ ≫ snd _ _) f f (i₁ ≫ fst _ _) (i₂ ≫ fst _ _) i (by simp [condition])\n        (by simp [condition])) :=\n  IsPullback.of_iso_pullback ⟨by ext <;> simp [condition_assoc]⟩\n    (pullbackDiagonalMapIso f i i₁ i₂).symm (pullbackDiagonalMapIso.inv_fst f i i₁ i₂)\n    (by aesop_cat)\n\n"}
{"name":"CategoryTheory.Limits.pullbackDiagonalMapIdIso_hom_fst_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Diagonal","initialProofState":"C : Type u_1\ninst✝⁵ : CategoryTheory.Category.{u_2, u_1} C\nX Y : C\ninst✝⁴ : CategoryTheory.Limits.HasPullbacks C\nS T : C\nf : Quiver.Hom X T\ng : Quiver.Hom Y T\ni : Quiver.Hom T S\ninst✝³ : CategoryTheory.Limits.HasPullback i i\ninst✝² : CategoryTheory.Limits.HasPullback f g\ninst✝¹ : CategoryTheory.Limits.HasPullback (CategoryTheory.CategoryStruct.comp f i) (CategoryTheory.CategoryStruct.comp g i)\ninst✝ : CategoryTheory.Limits.HasPullback (CategoryTheory.Limits.pullback.diagonal i) (CategoryTheory.Limits.pullback.map (CategoryTheory.CategoryStruct.comp f i) (CategoryTheory.CategoryStruct.comp g i) i i f g (CategoryTheory.CategoryStruct.id S) ⋯ ⋯)\nZ : C\nh : Quiver.Hom X Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullbackDiagonalMapIdIso f g i).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst f g) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd (CategoryTheory.Limits.pullback.diagonal i) (CategoryTheory.Limits.pullback.map (CategoryTheory.CategoryStruct.comp f i) (CategoryTheory.CategoryStruct.comp g i) i i f g (CategoryTheory.CategoryStruct.id S) ⋯ ⋯)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp f i) (CategoryTheory.CategoryStruct.comp g i)) h))","decl":"@[reassoc (attr := simp)]\ntheorem pullbackDiagonalMapIdIso_hom_fst :\n    (pullbackDiagonalMapIdIso f g i).hom ≫ pullback.fst _ _ =\n      pullback.snd _ _ ≫ pullback.fst _ _ := by\n  delta pullbackDiagonalMapIdIso\n  simp\n\n"}
{"name":"CategoryTheory.Limits.pullbackDiagonalMapIdIso_hom_fst","module":"Mathlib.CategoryTheory.Limits.Shapes.Diagonal","initialProofState":"C : Type u_1\ninst✝⁵ : CategoryTheory.Category.{u_2, u_1} C\nX Y : C\ninst✝⁴ : CategoryTheory.Limits.HasPullbacks C\nS T : C\nf : Quiver.Hom X T\ng : Quiver.Hom Y T\ni : Quiver.Hom T S\ninst✝³ : CategoryTheory.Limits.HasPullback i i\ninst✝² : CategoryTheory.Limits.HasPullback f g\ninst✝¹ : CategoryTheory.Limits.HasPullback (CategoryTheory.CategoryStruct.comp f i) (CategoryTheory.CategoryStruct.comp g i)\ninst✝ : CategoryTheory.Limits.HasPullback (CategoryTheory.Limits.pullback.diagonal i) (CategoryTheory.Limits.pullback.map (CategoryTheory.CategoryStruct.comp f i) (CategoryTheory.CategoryStruct.comp g i) i i f g (CategoryTheory.CategoryStruct.id S) ⋯ ⋯)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullbackDiagonalMapIdIso f g i).hom (CategoryTheory.Limits.pullback.fst f g)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd (CategoryTheory.Limits.pullback.diagonal i) (CategoryTheory.Limits.pullback.map (CategoryTheory.CategoryStruct.comp f i) (CategoryTheory.CategoryStruct.comp g i) i i f g (CategoryTheory.CategoryStruct.id S) ⋯ ⋯)) (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp f i) (CategoryTheory.CategoryStruct.comp g i)))","decl":"@[reassoc (attr := simp)]\ntheorem pullbackDiagonalMapIdIso_hom_fst :\n    (pullbackDiagonalMapIdIso f g i).hom ≫ pullback.fst _ _ =\n      pullback.snd _ _ ≫ pullback.fst _ _ := by\n  delta pullbackDiagonalMapIdIso\n  simp\n\n"}
{"name":"CategoryTheory.Limits.pullbackDiagonalMapIdIso_hom_snd","module":"Mathlib.CategoryTheory.Limits.Shapes.Diagonal","initialProofState":"C : Type u_1\ninst✝⁵ : CategoryTheory.Category.{u_2, u_1} C\nX Y : C\ninst✝⁴ : CategoryTheory.Limits.HasPullbacks C\nS T : C\nf : Quiver.Hom X T\ng : Quiver.Hom Y T\ni : Quiver.Hom T S\ninst✝³ : CategoryTheory.Limits.HasPullback i i\ninst✝² : CategoryTheory.Limits.HasPullback f g\ninst✝¹ : CategoryTheory.Limits.HasPullback (CategoryTheory.CategoryStruct.comp f i) (CategoryTheory.CategoryStruct.comp g i)\ninst✝ : CategoryTheory.Limits.HasPullback (CategoryTheory.Limits.pullback.diagonal i) (CategoryTheory.Limits.pullback.map (CategoryTheory.CategoryStruct.comp f i) (CategoryTheory.CategoryStruct.comp g i) i i f g (CategoryTheory.CategoryStruct.id S) ⋯ ⋯)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullbackDiagonalMapIdIso f g i).hom (CategoryTheory.Limits.pullback.snd f g)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd (CategoryTheory.Limits.pullback.diagonal i) (CategoryTheory.Limits.pullback.map (CategoryTheory.CategoryStruct.comp f i) (CategoryTheory.CategoryStruct.comp g i) i i f g (CategoryTheory.CategoryStruct.id S) ⋯ ⋯)) (CategoryTheory.Limits.pullback.snd (CategoryTheory.CategoryStruct.comp f i) (CategoryTheory.CategoryStruct.comp g i)))","decl":"@[reassoc (attr := simp)]\ntheorem pullbackDiagonalMapIdIso_hom_snd :\n    (pullbackDiagonalMapIdIso f g i).hom ≫ pullback.snd _ _ =\n      pullback.snd _ _ ≫ pullback.snd _ _ := by\n  delta pullbackDiagonalMapIdIso\n  simp\n\n"}
{"name":"CategoryTheory.Limits.pullbackDiagonalMapIdIso_hom_snd_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Diagonal","initialProofState":"C : Type u_1\ninst✝⁵ : CategoryTheory.Category.{u_2, u_1} C\nX Y : C\ninst✝⁴ : CategoryTheory.Limits.HasPullbacks C\nS T : C\nf : Quiver.Hom X T\ng : Quiver.Hom Y T\ni : Quiver.Hom T S\ninst✝³ : CategoryTheory.Limits.HasPullback i i\ninst✝² : CategoryTheory.Limits.HasPullback f g\ninst✝¹ : CategoryTheory.Limits.HasPullback (CategoryTheory.CategoryStruct.comp f i) (CategoryTheory.CategoryStruct.comp g i)\ninst✝ : CategoryTheory.Limits.HasPullback (CategoryTheory.Limits.pullback.diagonal i) (CategoryTheory.Limits.pullback.map (CategoryTheory.CategoryStruct.comp f i) (CategoryTheory.CategoryStruct.comp g i) i i f g (CategoryTheory.CategoryStruct.id S) ⋯ ⋯)\nZ : C\nh : Quiver.Hom Y Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullbackDiagonalMapIdIso f g i).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd f g) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd (CategoryTheory.Limits.pullback.diagonal i) (CategoryTheory.Limits.pullback.map (CategoryTheory.CategoryStruct.comp f i) (CategoryTheory.CategoryStruct.comp g i) i i f g (CategoryTheory.CategoryStruct.id S) ⋯ ⋯)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd (CategoryTheory.CategoryStruct.comp f i) (CategoryTheory.CategoryStruct.comp g i)) h))","decl":"@[reassoc (attr := simp)]\ntheorem pullbackDiagonalMapIdIso_hom_snd :\n    (pullbackDiagonalMapIdIso f g i).hom ≫ pullback.snd _ _ =\n      pullback.snd _ _ ≫ pullback.snd _ _ := by\n  delta pullbackDiagonalMapIdIso\n  simp\n\n"}
{"name":"CategoryTheory.Limits.pullbackDiagonalMapIdIso_inv_fst","module":"Mathlib.CategoryTheory.Limits.Shapes.Diagonal","initialProofState":"C : Type u_1\ninst✝⁵ : CategoryTheory.Category.{u_2, u_1} C\nX Y : C\ninst✝⁴ : CategoryTheory.Limits.HasPullbacks C\nS T : C\nf : Quiver.Hom X T\ng : Quiver.Hom Y T\ni : Quiver.Hom T S\ninst✝³ : CategoryTheory.Limits.HasPullback i i\ninst✝² : CategoryTheory.Limits.HasPullback f g\ninst✝¹ : CategoryTheory.Limits.HasPullback (CategoryTheory.CategoryStruct.comp f i) (CategoryTheory.CategoryStruct.comp g i)\ninst✝ : CategoryTheory.Limits.HasPullback (CategoryTheory.Limits.pullback.diagonal i) (CategoryTheory.Limits.pullback.map (CategoryTheory.CategoryStruct.comp f i) (CategoryTheory.CategoryStruct.comp g i) i i f g (CategoryTheory.CategoryStruct.id S) ⋯ ⋯)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullbackDiagonalMapIdIso f g i).inv (CategoryTheory.Limits.pullback.fst (CategoryTheory.Limits.pullback.diagonal i) (CategoryTheory.Limits.pullback.map (CategoryTheory.CategoryStruct.comp f i) (CategoryTheory.CategoryStruct.comp g i) i i f g (CategoryTheory.CategoryStruct.id S) ⋯ ⋯))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst f g) f)","decl":"@[reassoc (attr := simp)]\ntheorem pullbackDiagonalMapIdIso_inv_fst :\n    (pullbackDiagonalMapIdIso f g i).inv ≫ pullback.fst _ _ = pullback.fst _ _ ≫ f := by\n  rw [Iso.inv_comp_eq, ← Category.comp_id (pullback.fst _ _), ← diagonal_fst i,\n    pullback.condition_assoc]\n  simp\n\n"}
{"name":"CategoryTheory.Limits.pullbackDiagonalMapIdIso_inv_fst_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Diagonal","initialProofState":"C : Type u_1\ninst✝⁵ : CategoryTheory.Category.{u_2, u_1} C\nX Y : C\ninst✝⁴ : CategoryTheory.Limits.HasPullbacks C\nS T : C\nf : Quiver.Hom X T\ng : Quiver.Hom Y T\ni : Quiver.Hom T S\ninst✝³ : CategoryTheory.Limits.HasPullback i i\ninst✝² : CategoryTheory.Limits.HasPullback f g\ninst✝¹ : CategoryTheory.Limits.HasPullback (CategoryTheory.CategoryStruct.comp f i) (CategoryTheory.CategoryStruct.comp g i)\ninst✝ : CategoryTheory.Limits.HasPullback (CategoryTheory.Limits.pullback.diagonal i) (CategoryTheory.Limits.pullback.map (CategoryTheory.CategoryStruct.comp f i) (CategoryTheory.CategoryStruct.comp g i) i i f g (CategoryTheory.CategoryStruct.id S) ⋯ ⋯)\nZ : C\nh : Quiver.Hom T Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullbackDiagonalMapIdIso f g i).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.Limits.pullback.diagonal i) (CategoryTheory.Limits.pullback.map (CategoryTheory.CategoryStruct.comp f i) (CategoryTheory.CategoryStruct.comp g i) i i f g (CategoryTheory.CategoryStruct.id S) ⋯ ⋯)) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst f g) (CategoryTheory.CategoryStruct.comp f h))","decl":"@[reassoc (attr := simp)]\ntheorem pullbackDiagonalMapIdIso_inv_fst :\n    (pullbackDiagonalMapIdIso f g i).inv ≫ pullback.fst _ _ = pullback.fst _ _ ≫ f := by\n  rw [Iso.inv_comp_eq, ← Category.comp_id (pullback.fst _ _), ← diagonal_fst i,\n    pullback.condition_assoc]\n  simp\n\n"}
{"name":"CategoryTheory.Limits.pullbackDiagonalMapIdIso_inv_snd_fst","module":"Mathlib.CategoryTheory.Limits.Shapes.Diagonal","initialProofState":"C : Type u_1\ninst✝⁵ : CategoryTheory.Category.{u_2, u_1} C\nX Y : C\ninst✝⁴ : CategoryTheory.Limits.HasPullbacks C\nS T : C\nf : Quiver.Hom X T\ng : Quiver.Hom Y T\ni : Quiver.Hom T S\ninst✝³ : CategoryTheory.Limits.HasPullback i i\ninst✝² : CategoryTheory.Limits.HasPullback f g\ninst✝¹ : CategoryTheory.Limits.HasPullback (CategoryTheory.CategoryStruct.comp f i) (CategoryTheory.CategoryStruct.comp g i)\ninst✝ : CategoryTheory.Limits.HasPullback (CategoryTheory.Limits.pullback.diagonal i) (CategoryTheory.Limits.pullback.map (CategoryTheory.CategoryStruct.comp f i) (CategoryTheory.CategoryStruct.comp g i) i i f g (CategoryTheory.CategoryStruct.id S) ⋯ ⋯)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullbackDiagonalMapIdIso f g i).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd (CategoryTheory.Limits.pullback.diagonal i) (CategoryTheory.Limits.pullback.map (CategoryTheory.CategoryStruct.comp f i) (CategoryTheory.CategoryStruct.comp g i) i i f g (CategoryTheory.CategoryStruct.id S) ⋯ ⋯)) (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp f i) (CategoryTheory.CategoryStruct.comp g i)))) (CategoryTheory.Limits.pullback.fst f g)","decl":"@[reassoc (attr := simp)]\ntheorem pullbackDiagonalMapIdIso_inv_snd_fst :\n    (pullbackDiagonalMapIdIso f g i).inv ≫ pullback.snd _ _ ≫ pullback.fst _ _ =\n      pullback.fst _ _ := by\n  rw [Iso.inv_comp_eq]\n  simp\n\n"}
{"name":"CategoryTheory.Limits.pullbackDiagonalMapIdIso_inv_snd_fst_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Diagonal","initialProofState":"C : Type u_1\ninst✝⁵ : CategoryTheory.Category.{u_2, u_1} C\nX Y : C\ninst✝⁴ : CategoryTheory.Limits.HasPullbacks C\nS T : C\nf : Quiver.Hom X T\ng : Quiver.Hom Y T\ni : Quiver.Hom T S\ninst✝³ : CategoryTheory.Limits.HasPullback i i\ninst✝² : CategoryTheory.Limits.HasPullback f g\ninst✝¹ : CategoryTheory.Limits.HasPullback (CategoryTheory.CategoryStruct.comp f i) (CategoryTheory.CategoryStruct.comp g i)\ninst✝ : CategoryTheory.Limits.HasPullback (CategoryTheory.Limits.pullback.diagonal i) (CategoryTheory.Limits.pullback.map (CategoryTheory.CategoryStruct.comp f i) (CategoryTheory.CategoryStruct.comp g i) i i f g (CategoryTheory.CategoryStruct.id S) ⋯ ⋯)\nZ : C\nh : Quiver.Hom X Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullbackDiagonalMapIdIso f g i).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd (CategoryTheory.Limits.pullback.diagonal i) (CategoryTheory.Limits.pullback.map (CategoryTheory.CategoryStruct.comp f i) (CategoryTheory.CategoryStruct.comp g i) i i f g (CategoryTheory.CategoryStruct.id S) ⋯ ⋯)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp f i) (CategoryTheory.CategoryStruct.comp g i)) h))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst f g) h)","decl":"@[reassoc (attr := simp)]\ntheorem pullbackDiagonalMapIdIso_inv_snd_fst :\n    (pullbackDiagonalMapIdIso f g i).inv ≫ pullback.snd _ _ ≫ pullback.fst _ _ =\n      pullback.fst _ _ := by\n  rw [Iso.inv_comp_eq]\n  simp\n\n"}
{"name":"CategoryTheory.Limits.pullbackDiagonalMapIdIso_inv_snd_snd_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Diagonal","initialProofState":"C : Type u_1\ninst✝⁵ : CategoryTheory.Category.{u_2, u_1} C\nX Y : C\ninst✝⁴ : CategoryTheory.Limits.HasPullbacks C\nS T : C\nf : Quiver.Hom X T\ng : Quiver.Hom Y T\ni : Quiver.Hom T S\ninst✝³ : CategoryTheory.Limits.HasPullback i i\ninst✝² : CategoryTheory.Limits.HasPullback f g\ninst✝¹ : CategoryTheory.Limits.HasPullback (CategoryTheory.CategoryStruct.comp f i) (CategoryTheory.CategoryStruct.comp g i)\ninst✝ : CategoryTheory.Limits.HasPullback (CategoryTheory.Limits.pullback.diagonal i) (CategoryTheory.Limits.pullback.map (CategoryTheory.CategoryStruct.comp f i) (CategoryTheory.CategoryStruct.comp g i) i i f g (CategoryTheory.CategoryStruct.id S) ⋯ ⋯)\nZ : C\nh : Quiver.Hom Y Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullbackDiagonalMapIdIso f g i).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd (CategoryTheory.Limits.pullback.diagonal i) (CategoryTheory.Limits.pullback.map (CategoryTheory.CategoryStruct.comp f i) (CategoryTheory.CategoryStruct.comp g i) i i f g (CategoryTheory.CategoryStruct.id S) ⋯ ⋯)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd (CategoryTheory.CategoryStruct.comp f i) (CategoryTheory.CategoryStruct.comp g i)) h))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd f g) h)","decl":"@[reassoc (attr := simp)]\ntheorem pullbackDiagonalMapIdIso_inv_snd_snd :\n    (pullbackDiagonalMapIdIso f g i).inv ≫ pullback.snd _ _ ≫ pullback.snd _ _ =\n      pullback.snd _ _ := by\n  rw [Iso.inv_comp_eq]\n  simp\n\n"}
{"name":"CategoryTheory.Limits.pullbackDiagonalMapIdIso_inv_snd_snd","module":"Mathlib.CategoryTheory.Limits.Shapes.Diagonal","initialProofState":"C : Type u_1\ninst✝⁵ : CategoryTheory.Category.{u_2, u_1} C\nX Y : C\ninst✝⁴ : CategoryTheory.Limits.HasPullbacks C\nS T : C\nf : Quiver.Hom X T\ng : Quiver.Hom Y T\ni : Quiver.Hom T S\ninst✝³ : CategoryTheory.Limits.HasPullback i i\ninst✝² : CategoryTheory.Limits.HasPullback f g\ninst✝¹ : CategoryTheory.Limits.HasPullback (CategoryTheory.CategoryStruct.comp f i) (CategoryTheory.CategoryStruct.comp g i)\ninst✝ : CategoryTheory.Limits.HasPullback (CategoryTheory.Limits.pullback.diagonal i) (CategoryTheory.Limits.pullback.map (CategoryTheory.CategoryStruct.comp f i) (CategoryTheory.CategoryStruct.comp g i) i i f g (CategoryTheory.CategoryStruct.id S) ⋯ ⋯)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullbackDiagonalMapIdIso f g i).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd (CategoryTheory.Limits.pullback.diagonal i) (CategoryTheory.Limits.pullback.map (CategoryTheory.CategoryStruct.comp f i) (CategoryTheory.CategoryStruct.comp g i) i i f g (CategoryTheory.CategoryStruct.id S) ⋯ ⋯)) (CategoryTheory.Limits.pullback.snd (CategoryTheory.CategoryStruct.comp f i) (CategoryTheory.CategoryStruct.comp g i)))) (CategoryTheory.Limits.pullback.snd f g)","decl":"@[reassoc (attr := simp)]\ntheorem pullbackDiagonalMapIdIso_inv_snd_snd :\n    (pullbackDiagonalMapIdIso f g i).inv ≫ pullback.snd _ _ ≫ pullback.snd _ _ =\n      pullback.snd _ _ := by\n  rw [Iso.inv_comp_eq]\n  simp\n\n"}
{"name":"CategoryTheory.Limits.pullback.diagonal_comp","module":"Mathlib.CategoryTheory.Limits.Shapes.Diagonal","initialProofState":"C : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_2, u_1} C\nX Y Z : C\ninst✝³ : CategoryTheory.Limits.HasPullbacks C\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\ninst✝² : CategoryTheory.Limits.HasPullback f f\ninst✝¹ : CategoryTheory.Limits.HasPullback g g\ninst✝ : CategoryTheory.Limits.HasPullback (CategoryTheory.CategoryStruct.comp f g) (CategoryTheory.CategoryStruct.comp f g)\n⊢ Eq (CategoryTheory.Limits.pullback.diagonal (CategoryTheory.CategoryStruct.comp f g)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.diagonal f) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullbackDiagonalMapIdIso f f g).inv (CategoryTheory.Limits.pullback.snd (CategoryTheory.Limits.pullback.diagonal g) (CategoryTheory.Limits.pullback.map (CategoryTheory.CategoryStruct.comp f g) (CategoryTheory.CategoryStruct.comp f g) g g f f (CategoryTheory.CategoryStruct.id Z) ⋯ ⋯))))","decl":"theorem pullback.diagonal_comp (f : X ⟶ Y) (g : Y ⟶ Z) [HasPullback f f] [HasPullback g g]\n    [HasPullback (f ≫ g) (f ≫ g)] :\n    diagonal (f ≫ g) = diagonal f ≫ (pullbackDiagonalMapIdIso f f g).inv ≫ pullback.snd _ _ := by\n  ext <;> simp\n\n"}
{"name":"CategoryTheory.Limits.pullback_map_diagonal_isPullback","module":"Mathlib.CategoryTheory.Limits.Shapes.Diagonal","initialProofState":"C : Type u_1\ninst✝⁵ : CategoryTheory.Category.{u_2, u_1} C\nX Y : C\ninst✝⁴ : CategoryTheory.Limits.HasPullbacks C\nS T : C\nf : Quiver.Hom X T\ng : Quiver.Hom Y T\ni : Quiver.Hom T S\ninst✝³ : CategoryTheory.Limits.HasPullback i i\ninst✝² : CategoryTheory.Limits.HasPullback f g\ninst✝¹ : CategoryTheory.Limits.HasPullback (CategoryTheory.CategoryStruct.comp f i) (CategoryTheory.CategoryStruct.comp g i)\ninst✝ : CategoryTheory.Limits.HasPullback (CategoryTheory.Limits.pullback.diagonal i) (CategoryTheory.Limits.pullback.map (CategoryTheory.CategoryStruct.comp f i) (CategoryTheory.CategoryStruct.comp g i) i i f g (CategoryTheory.CategoryStruct.id S) ⋯ ⋯)\n⊢ CategoryTheory.IsPullback (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst f g) f) (CategoryTheory.Limits.pullback.map f g (CategoryTheory.CategoryStruct.comp f i) (CategoryTheory.CategoryStruct.comp g i) (CategoryTheory.CategoryStruct.id X) (CategoryTheory.CategoryStruct.id Y) i ⋯ ⋯) (CategoryTheory.Limits.pullback.diagonal i) (CategoryTheory.Limits.pullback.map (CategoryTheory.CategoryStruct.comp f i) (CategoryTheory.CategoryStruct.comp g i) i i f g (CategoryTheory.CategoryStruct.id S) ⋯ ⋯)","decl":"theorem pullback_map_diagonal_isPullback :\n    IsPullback (pullback.fst _ _ ≫ f)\n      (pullback.map f g (f ≫ i) (g ≫ i) _ _ i (Category.id_comp _).symm (Category.id_comp _).symm)\n      (diagonal i)\n      (pullback.map (f ≫ i) (g ≫ i) i i f g (𝟙 _) (Category.comp_id _) (Category.comp_id _)) := by\n  apply IsPullback.of_iso_pullback _ (pullbackDiagonalMapIdIso f g i).symm\n  · simp\n  · ext <;> simp\n  · constructor\n    ext <;> simp [condition]\n\n"}
{"name":"CategoryTheory.Limits.diagonalObjPullbackFstIso_hom_fst_fst_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Diagonal","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasPullbacks C\nX Y Z✝ : C\nf : Quiver.Hom X Z✝\ng : Quiver.Hom Y Z✝\nZ : C\nh : Quiver.Hom Y Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.diagonalObjPullbackFstIso f g).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd g g) g) f) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst g g) h))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.Limits.pullback.fst f g) (CategoryTheory.Limits.pullback.fst f g)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd f g) h))","decl":"@[reassoc (attr := simp)]\ntheorem diagonalObjPullbackFstIso_hom_fst_fst {X Y Z : C} (f : X ⟶ Z) (g : Y ⟶ Z) :\n    (diagonalObjPullbackFstIso f g).hom ≫ pullback.fst _ _ ≫ pullback.fst _ _ =\n      pullback.fst _ _ ≫ pullback.snd _ _ := by\n  delta diagonalObjPullbackFstIso\n  simp\n\n"}
{"name":"CategoryTheory.Limits.diagonalObjPullbackFstIso_hom_fst_fst","module":"Mathlib.CategoryTheory.Limits.Shapes.Diagonal","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasPullbacks C\nX Y Z : C\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.diagonalObjPullbackFstIso f g).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd g g) g) f) (CategoryTheory.Limits.pullback.fst g g))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.Limits.pullback.fst f g) (CategoryTheory.Limits.pullback.fst f g)) (CategoryTheory.Limits.pullback.snd f g))","decl":"@[reassoc (attr := simp)]\ntheorem diagonalObjPullbackFstIso_hom_fst_fst {X Y Z : C} (f : X ⟶ Z) (g : Y ⟶ Z) :\n    (diagonalObjPullbackFstIso f g).hom ≫ pullback.fst _ _ ≫ pullback.fst _ _ =\n      pullback.fst _ _ ≫ pullback.snd _ _ := by\n  delta diagonalObjPullbackFstIso\n  simp\n\n"}
{"name":"CategoryTheory.Limits.diagonalObjPullbackFstIso_hom_fst_snd_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Diagonal","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasPullbacks C\nX Y Z✝ : C\nf : Quiver.Hom X Z✝\ng : Quiver.Hom Y Z✝\nZ : C\nh : Quiver.Hom Y Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.diagonalObjPullbackFstIso f g).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd g g) g) f) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd g g) h))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd (CategoryTheory.Limits.pullback.fst f g) (CategoryTheory.Limits.pullback.fst f g)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd f g) h))","decl":"@[reassoc (attr := simp)]\ntheorem diagonalObjPullbackFstIso_hom_fst_snd {X Y Z : C} (f : X ⟶ Z) (g : Y ⟶ Z) :\n    (diagonalObjPullbackFstIso f g).hom ≫ pullback.fst _ _ ≫ pullback.snd _ _ =\n      pullback.snd _ _ ≫ pullback.snd _ _ := by\n  delta diagonalObjPullbackFstIso\n  simp\n\n"}
{"name":"CategoryTheory.Limits.diagonalObjPullbackFstIso_hom_fst_snd","module":"Mathlib.CategoryTheory.Limits.Shapes.Diagonal","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasPullbacks C\nX Y Z : C\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.diagonalObjPullbackFstIso f g).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd g g) g) f) (CategoryTheory.Limits.pullback.snd g g))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd (CategoryTheory.Limits.pullback.fst f g) (CategoryTheory.Limits.pullback.fst f g)) (CategoryTheory.Limits.pullback.snd f g))","decl":"@[reassoc (attr := simp)]\ntheorem diagonalObjPullbackFstIso_hom_fst_snd {X Y Z : C} (f : X ⟶ Z) (g : Y ⟶ Z) :\n    (diagonalObjPullbackFstIso f g).hom ≫ pullback.fst _ _ ≫ pullback.snd _ _ =\n      pullback.snd _ _ ≫ pullback.snd _ _ := by\n  delta diagonalObjPullbackFstIso\n  simp\n\n"}
{"name":"CategoryTheory.Limits.diagonalObjPullbackFstIso_hom_snd_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Diagonal","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasPullbacks C\nX Y Z✝ : C\nf : Quiver.Hom X Z✝\ng : Quiver.Hom Y Z✝\nZ : C\nh : Quiver.Hom X Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.diagonalObjPullbackFstIso f g).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd g g) g) f) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.Limits.pullback.fst f g) (CategoryTheory.Limits.pullback.fst f g)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst f g) h))","decl":"@[reassoc (attr := simp)]\ntheorem diagonalObjPullbackFstIso_hom_snd {X Y Z : C} (f : X ⟶ Z) (g : Y ⟶ Z) :\n    (diagonalObjPullbackFstIso f g).hom ≫ pullback.snd _ _ =\n      pullback.fst _ _ ≫ pullback.fst _ _ := by\n  delta diagonalObjPullbackFstIso\n  simp\n\n"}
{"name":"CategoryTheory.Limits.diagonalObjPullbackFstIso_hom_snd","module":"Mathlib.CategoryTheory.Limits.Shapes.Diagonal","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasPullbacks C\nX Y Z : C\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.diagonalObjPullbackFstIso f g).hom (CategoryTheory.Limits.pullback.snd (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd g g) g) f)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.Limits.pullback.fst f g) (CategoryTheory.Limits.pullback.fst f g)) (CategoryTheory.Limits.pullback.fst f g))","decl":"@[reassoc (attr := simp)]\ntheorem diagonalObjPullbackFstIso_hom_snd {X Y Z : C} (f : X ⟶ Z) (g : Y ⟶ Z) :\n    (diagonalObjPullbackFstIso f g).hom ≫ pullback.snd _ _ =\n      pullback.fst _ _ ≫ pullback.fst _ _ := by\n  delta diagonalObjPullbackFstIso\n  simp\n\n"}
{"name":"CategoryTheory.Limits.diagonalObjPullbackFstIso_inv_fst_fst_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Diagonal","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasPullbacks C\nX Y Z✝ : C\nf : Quiver.Hom X Z✝\ng : Quiver.Hom Y Z✝\nZ : C\nh : Quiver.Hom X Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.diagonalObjPullbackFstIso f g).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.Limits.pullback.fst f g) (CategoryTheory.Limits.pullback.fst f g)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst f g) h))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd g g) g) f) h)","decl":"@[reassoc (attr := simp)]\ntheorem diagonalObjPullbackFstIso_inv_fst_fst {X Y Z : C} (f : X ⟶ Z) (g : Y ⟶ Z) :\n    (diagonalObjPullbackFstIso f g).inv ≫ pullback.fst _ _ ≫ pullback.fst _ _ =\n      pullback.snd _ _ := by\n  delta diagonalObjPullbackFstIso\n  simp\n\n"}
{"name":"CategoryTheory.Limits.diagonalObjPullbackFstIso_inv_fst_fst","module":"Mathlib.CategoryTheory.Limits.Shapes.Diagonal","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasPullbacks C\nX Y Z : C\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.diagonalObjPullbackFstIso f g).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.Limits.pullback.fst f g) (CategoryTheory.Limits.pullback.fst f g)) (CategoryTheory.Limits.pullback.fst f g))) (CategoryTheory.Limits.pullback.snd (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd g g) g) f)","decl":"@[reassoc (attr := simp)]\ntheorem diagonalObjPullbackFstIso_inv_fst_fst {X Y Z : C} (f : X ⟶ Z) (g : Y ⟶ Z) :\n    (diagonalObjPullbackFstIso f g).inv ≫ pullback.fst _ _ ≫ pullback.fst _ _ =\n      pullback.snd _ _ := by\n  delta diagonalObjPullbackFstIso\n  simp\n\n"}
{"name":"CategoryTheory.Limits.diagonalObjPullbackFstIso_inv_fst_snd_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Diagonal","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasPullbacks C\nX Y Z✝ : C\nf : Quiver.Hom X Z✝\ng : Quiver.Hom Y Z✝\nZ : C\nh : Quiver.Hom Y Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.diagonalObjPullbackFstIso f g).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.Limits.pullback.fst f g) (CategoryTheory.Limits.pullback.fst f g)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd f g) h))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd g g) g) f) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst g g) h))","decl":"@[reassoc (attr := simp)]\ntheorem diagonalObjPullbackFstIso_inv_fst_snd {X Y Z : C} (f : X ⟶ Z) (g : Y ⟶ Z) :\n    (diagonalObjPullbackFstIso f g).inv ≫ pullback.fst _ _ ≫ pullback.snd _ _ =\n      pullback.fst _ _ ≫ pullback.fst _ _ := by\n  delta diagonalObjPullbackFstIso\n  simp\n\n"}
{"name":"CategoryTheory.Limits.diagonalObjPullbackFstIso_inv_fst_snd","module":"Mathlib.CategoryTheory.Limits.Shapes.Diagonal","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasPullbacks C\nX Y Z : C\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.diagonalObjPullbackFstIso f g).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.Limits.pullback.fst f g) (CategoryTheory.Limits.pullback.fst f g)) (CategoryTheory.Limits.pullback.snd f g))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd g g) g) f) (CategoryTheory.Limits.pullback.fst g g))","decl":"@[reassoc (attr := simp)]\ntheorem diagonalObjPullbackFstIso_inv_fst_snd {X Y Z : C} (f : X ⟶ Z) (g : Y ⟶ Z) :\n    (diagonalObjPullbackFstIso f g).inv ≫ pullback.fst _ _ ≫ pullback.snd _ _ =\n      pullback.fst _ _ ≫ pullback.fst _ _ := by\n  delta diagonalObjPullbackFstIso\n  simp\n\n"}
{"name":"CategoryTheory.Limits.diagonalObjPullbackFstIso_inv_snd_fst_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Diagonal","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasPullbacks C\nX Y Z✝ : C\nf : Quiver.Hom X Z✝\ng : Quiver.Hom Y Z✝\nZ : C\nh : Quiver.Hom X Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.diagonalObjPullbackFstIso f g).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd (CategoryTheory.Limits.pullback.fst f g) (CategoryTheory.Limits.pullback.fst f g)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst f g) h))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd g g) g) f) h)","decl":"@[reassoc (attr := simp)]\ntheorem diagonalObjPullbackFstIso_inv_snd_fst {X Y Z : C} (f : X ⟶ Z) (g : Y ⟶ Z) :\n    (diagonalObjPullbackFstIso f g).inv ≫ pullback.snd _ _ ≫ pullback.fst _ _ =\n      pullback.snd _ _ := by\n  delta diagonalObjPullbackFstIso\n  simp\n\n"}
{"name":"CategoryTheory.Limits.diagonalObjPullbackFstIso_inv_snd_fst","module":"Mathlib.CategoryTheory.Limits.Shapes.Diagonal","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasPullbacks C\nX Y Z : C\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.diagonalObjPullbackFstIso f g).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd (CategoryTheory.Limits.pullback.fst f g) (CategoryTheory.Limits.pullback.fst f g)) (CategoryTheory.Limits.pullback.fst f g))) (CategoryTheory.Limits.pullback.snd (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd g g) g) f)","decl":"@[reassoc (attr := simp)]\ntheorem diagonalObjPullbackFstIso_inv_snd_fst {X Y Z : C} (f : X ⟶ Z) (g : Y ⟶ Z) :\n    (diagonalObjPullbackFstIso f g).inv ≫ pullback.snd _ _ ≫ pullback.fst _ _ =\n      pullback.snd _ _ := by\n  delta diagonalObjPullbackFstIso\n  simp\n\n"}
{"name":"CategoryTheory.Limits.diagonalObjPullbackFstIso_inv_snd_snd_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Diagonal","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasPullbacks C\nX Y Z✝ : C\nf : Quiver.Hom X Z✝\ng : Quiver.Hom Y Z✝\nZ : C\nh : Quiver.Hom Y Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.diagonalObjPullbackFstIso f g).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd (CategoryTheory.Limits.pullback.fst f g) (CategoryTheory.Limits.pullback.fst f g)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd f g) h))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd g g) g) f) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd g g) h))","decl":"@[reassoc (attr := simp)]\ntheorem diagonalObjPullbackFstIso_inv_snd_snd {X Y Z : C} (f : X ⟶ Z) (g : Y ⟶ Z) :\n    (diagonalObjPullbackFstIso f g).inv ≫ pullback.snd _ _ ≫ pullback.snd _ _ =\n      pullback.fst _ _ ≫ pullback.snd _ _ := by\n  delta diagonalObjPullbackFstIso\n  simp\n\n"}
{"name":"CategoryTheory.Limits.diagonalObjPullbackFstIso_inv_snd_snd","module":"Mathlib.CategoryTheory.Limits.Shapes.Diagonal","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasPullbacks C\nX Y Z : C\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.diagonalObjPullbackFstIso f g).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd (CategoryTheory.Limits.pullback.fst f g) (CategoryTheory.Limits.pullback.fst f g)) (CategoryTheory.Limits.pullback.snd f g))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd g g) g) f) (CategoryTheory.Limits.pullback.snd g g))","decl":"@[reassoc (attr := simp)]\ntheorem diagonalObjPullbackFstIso_inv_snd_snd {X Y Z : C} (f : X ⟶ Z) (g : Y ⟶ Z) :\n    (diagonalObjPullbackFstIso f g).inv ≫ pullback.snd _ _ ≫ pullback.snd _ _ =\n      pullback.fst _ _ ≫ pullback.snd _ _ := by\n  delta diagonalObjPullbackFstIso\n  simp\n\n"}
{"name":"CategoryTheory.Limits.diagonal_pullback_fst","module":"Mathlib.CategoryTheory.Limits.Shapes.Diagonal","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasPullbacks C\nX Y Z : C\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\n⊢ Eq (CategoryTheory.Limits.pullback.diagonal (CategoryTheory.Limits.pullback.fst f g)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullbackSymmetry f (CategoryTheory.Over.mk g).hom).hom (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Over.pullback f).map (CategoryTheory.Over.homMk (CategoryTheory.Limits.pullback.diagonal g) ⋯)).left (CategoryTheory.Limits.diagonalObjPullbackFstIso f g).inv))","decl":"theorem diagonal_pullback_fst {X Y Z : C} (f : X ⟶ Z) (g : Y ⟶ Z) :\n    diagonal (pullback.fst f g) =\n      (pullbackSymmetry _ _).hom ≫\n        ((Over.pullback f).map\n              (Over.homMk (diagonal g) : Over.mk g ⟶ Over.mk (pullback.snd _ _ ≫ g))).left ≫\n          (diagonalObjPullbackFstIso f g).inv := by\n  ext <;> dsimp <;> simp\n\n"}
{"name":"CategoryTheory.Limits.pullback_lift_diagonal_isPullback","module":"Mathlib.CategoryTheory.Limits.Shapes.Diagonal","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\nX Y : C\ninst✝ : CategoryTheory.Limits.HasPullbacks C\nS : C\ng : Quiver.Hom Y X\nf : Quiver.Hom X S\n⊢ CategoryTheory.IsPullback g (CategoryTheory.Limits.pullback.lift (CategoryTheory.CategoryStruct.id Y) g ⋯) (CategoryTheory.Limits.pullback.diagonal f) (CategoryTheory.Limits.pullback.map (CategoryTheory.CategoryStruct.comp g f) f f f g (CategoryTheory.CategoryStruct.id X) (CategoryTheory.CategoryStruct.id S) ⋯ ⋯)","decl":"/-- Informally, this is a special case of `pullback_map_diagonal_isPullback` for `T = X`. -/\nlemma pullback_lift_diagonal_isPullback (g : Y ⟶ X) (f : X ⟶ S) :\n    IsPullback g (pullback.lift (𝟙 Y) g (by simp)) (diagonal f)\n      (pullback.map (g ≫ f) f f f g (𝟙 X) (𝟙 S) (by simp) (by simp)) := by\n  let i : pullback (g ≫ f) f ≅ pullback (g ≫ f) (𝟙 X ≫ f) := congrHom rfl (by simp)\n  let e : pullback (diagonal f) (map (g ≫ f) f f f g (𝟙 X) (𝟙 S) (by simp) (by simp)) ≅\n      pullback (diagonal f) (map (g ≫ f) (𝟙 X ≫ f) f f g (𝟙 X) (𝟙 S) (by simp) (by simp)) :=\n    (asIso (map _ _ _ _ (𝟙 _) i.inv (𝟙 _) (by simp) (by ext <;> simp [i]))).symm\n  apply IsPullback.of_iso_pullback _\n      (e ≪≫ pullbackDiagonalMapIdIso (T := X) (S := S) g (𝟙 X) f ≪≫ asIso (pullback.fst _ _)).symm\n  · simp [e]\n  · ext <;> simp [e, i]\n  · constructor\n    ext <;> simp [condition]\n\n"}
{"name":"CategoryTheory.Limits.pullbackFstFstIso_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Diagonal","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Limits.HasPullbacks C\nX Y S X' Y' S' : C\nf : Quiver.Hom X S\ng : Quiver.Hom Y S\nf' : Quiver.Hom X' S'\ng' : Quiver.Hom Y' S'\ni₁ : Quiver.Hom X X'\ni₂ : Quiver.Hom Y Y'\ni₃ : Quiver.Hom S S'\ne₁ : Eq (CategoryTheory.CategoryStruct.comp f i₃) (CategoryTheory.CategoryStruct.comp i₁ f')\ne₂ : Eq (CategoryTheory.CategoryStruct.comp g i₃) (CategoryTheory.CategoryStruct.comp i₂ g')\ninst✝ : CategoryTheory.Mono i₃\n⊢ Eq (CategoryTheory.Limits.pullbackFstFstIso f g f' g' i₁ i₂ i₃ e₁ e₂).hom (CategoryTheory.Limits.pullback.lift (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.Limits.pullback.fst (CategoryTheory.Limits.pullback.fst f' g') i₁) (CategoryTheory.Limits.pullback.fst (CategoryTheory.Limits.pullback.snd f' g') i₂)) (CategoryTheory.Limits.pullback.snd (CategoryTheory.Limits.pullback.fst f' g') i₁)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd (CategoryTheory.Limits.pullback.fst (CategoryTheory.Limits.pullback.fst f' g') i₁) (CategoryTheory.Limits.pullback.fst (CategoryTheory.Limits.pullback.snd f' g') i₂)) (CategoryTheory.Limits.pullback.snd (CategoryTheory.Limits.pullback.snd f' g') i₂)) ⋯)","decl":"/-- Given the following diagram with `S ⟶ S'` a monomorphism,\n\n```\n    X ⟶ X'\n      ↘      ↘\n        S ⟶ S'\n      ↗      ↗\n    Y ⟶ Y'\n```\n\nThis iso witnesses the fact that\n\n```\n      X ×[S] Y ⟶ (X' ×[S'] Y') ×[Y'] Y\n          |                  |\n          |                  |\n          ↓                  ↓\n(X' ×[S'] Y') ×[X'] X ⟶ X' ×[S'] Y'\n```\n\nis a pullback square. The diagonal map of this square is `pullback.map`.\nAlso see `pullback_lift_map_is_pullback`.\n-/\n@[simps]\ndef pullbackFstFstIso {X Y S X' Y' S' : C} (f : X ⟶ S) (g : Y ⟶ S) (f' : X' ⟶ S') (g' : Y' ⟶ S')\n    (i₁ : X ⟶ X') (i₂ : Y ⟶ Y') (i₃ : S ⟶ S') (e₁ : f ≫ i₃ = i₁ ≫ f') (e₂ : g ≫ i₃ = i₂ ≫ g')\n    [Mono i₃] :\n    pullback (pullback.fst _ _ : pullback (pullback.fst _ _ : pullback f' g' ⟶ _) i₁ ⟶ _)\n        (pullback.fst _ _ : pullback (pullback.snd _ _ : pullback f' g' ⟶ _) i₂ ⟶ _) ≅\n      pullback f g where\n  hom :=\n    pullback.lift (pullback.fst _ _ ≫ pullback.snd _ _) (pullback.snd _ _ ≫ pullback.snd _ _)\n      (by\n        rw [← cancel_mono i₃, Category.assoc, Category.assoc, Category.assoc, Category.assoc, e₁,\n          e₂, ← pullback.condition_assoc, pullback.condition_assoc, pullback.condition,\n          pullback.condition_assoc])\n  inv :=\n    pullback.lift\n      (pullback.lift (pullback.map _ _ _ _ _ _ _ e₁ e₂) (pullback.fst _ _) (pullback.lift_fst ..))\n      (pullback.lift (pullback.map _ _ _ _ _ _ _ e₁ e₂) (pullback.snd _ _) (pullback.lift_snd ..))\n      (by rw [pullback.lift_fst, pullback.lift_fst])\n  hom_inv_id := by\n    -- We could use `ext` here to immediately descend to the leaf goals,\n    -- but it only obscures the structure.\n    apply pullback.hom_ext\n    · apply pullback.hom_ext\n      · apply pullback.hom_ext\n        · simp only [Category.assoc, lift_fst, lift_fst_assoc, Category.id_comp]\n          rw [condition]\n        · simp [Category.assoc, lift_snd, condition_assoc, condition]\n      · simp only [Category.assoc, lift_fst_assoc, lift_snd, lift_fst, Category.id_comp]\n    · apply pullback.hom_ext\n      · apply pullback.hom_ext\n        · simp only [Category.assoc, lift_snd_assoc, lift_fst_assoc, lift_fst, Category.id_comp]\n          rw [← condition_assoc, condition]\n        · simp only [Category.assoc, lift_snd, lift_fst_assoc, lift_snd_assoc, Category.id_comp]\n          rw [condition]\n      · simp only [Category.assoc, lift_snd_assoc, lift_snd, Category.id_comp]\n  inv_hom_id := by\n    apply pullback.hom_ext\n    · simp only [Category.assoc, lift_fst, lift_fst_assoc, lift_snd, Category.id_comp]\n    · simp only [Category.assoc, lift_snd, lift_snd_assoc, Category.id_comp]\n\n"}
{"name":"CategoryTheory.Limits.pullbackFstFstIso_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.Diagonal","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Limits.HasPullbacks C\nX Y S X' Y' S' : C\nf : Quiver.Hom X S\ng : Quiver.Hom Y S\nf' : Quiver.Hom X' S'\ng' : Quiver.Hom Y' S'\ni₁ : Quiver.Hom X X'\ni₂ : Quiver.Hom Y Y'\ni₃ : Quiver.Hom S S'\ne₁ : Eq (CategoryTheory.CategoryStruct.comp f i₃) (CategoryTheory.CategoryStruct.comp i₁ f')\ne₂ : Eq (CategoryTheory.CategoryStruct.comp g i₃) (CategoryTheory.CategoryStruct.comp i₂ g')\ninst✝ : CategoryTheory.Mono i₃\n⊢ Eq (CategoryTheory.Limits.pullbackFstFstIso f g f' g' i₁ i₂ i₃ e₁ e₂).inv (CategoryTheory.Limits.pullback.lift (CategoryTheory.Limits.pullback.lift (CategoryTheory.Limits.pullback.map f g f' g' i₁ i₂ i₃ e₁ e₂) (CategoryTheory.Limits.pullback.fst f g) ⋯) (CategoryTheory.Limits.pullback.lift (CategoryTheory.Limits.pullback.map f g f' g' i₁ i₂ i₃ e₁ e₂) (CategoryTheory.Limits.pullback.snd f g) ⋯) ⋯)","decl":"/-- Given the following diagram with `S ⟶ S'` a monomorphism,\n\n```\n    X ⟶ X'\n      ↘      ↘\n        S ⟶ S'\n      ↗      ↗\n    Y ⟶ Y'\n```\n\nThis iso witnesses the fact that\n\n```\n      X ×[S] Y ⟶ (X' ×[S'] Y') ×[Y'] Y\n          |                  |\n          |                  |\n          ↓                  ↓\n(X' ×[S'] Y') ×[X'] X ⟶ X' ×[S'] Y'\n```\n\nis a pullback square. The diagonal map of this square is `pullback.map`.\nAlso see `pullback_lift_map_is_pullback`.\n-/\n@[simps]\ndef pullbackFstFstIso {X Y S X' Y' S' : C} (f : X ⟶ S) (g : Y ⟶ S) (f' : X' ⟶ S') (g' : Y' ⟶ S')\n    (i₁ : X ⟶ X') (i₂ : Y ⟶ Y') (i₃ : S ⟶ S') (e₁ : f ≫ i₃ = i₁ ≫ f') (e₂ : g ≫ i₃ = i₂ ≫ g')\n    [Mono i₃] :\n    pullback (pullback.fst _ _ : pullback (pullback.fst _ _ : pullback f' g' ⟶ _) i₁ ⟶ _)\n        (pullback.fst _ _ : pullback (pullback.snd _ _ : pullback f' g' ⟶ _) i₂ ⟶ _) ≅\n      pullback f g where\n  hom :=\n    pullback.lift (pullback.fst _ _ ≫ pullback.snd _ _) (pullback.snd _ _ ≫ pullback.snd _ _)\n      (by\n        rw [← cancel_mono i₃, Category.assoc, Category.assoc, Category.assoc, Category.assoc, e₁,\n          e₂, ← pullback.condition_assoc, pullback.condition_assoc, pullback.condition,\n          pullback.condition_assoc])\n  inv :=\n    pullback.lift\n      (pullback.lift (pullback.map _ _ _ _ _ _ _ e₁ e₂) (pullback.fst _ _) (pullback.lift_fst ..))\n      (pullback.lift (pullback.map _ _ _ _ _ _ _ e₁ e₂) (pullback.snd _ _) (pullback.lift_snd ..))\n      (by rw [pullback.lift_fst, pullback.lift_fst])\n  hom_inv_id := by\n    -- We could use `ext` here to immediately descend to the leaf goals,\n    -- but it only obscures the structure.\n    apply pullback.hom_ext\n    · apply pullback.hom_ext\n      · apply pullback.hom_ext\n        · simp only [Category.assoc, lift_fst, lift_fst_assoc, Category.id_comp]\n          rw [condition]\n        · simp [Category.assoc, lift_snd, condition_assoc, condition]\n      · simp only [Category.assoc, lift_fst_assoc, lift_snd, lift_fst, Category.id_comp]\n    · apply pullback.hom_ext\n      · apply pullback.hom_ext\n        · simp only [Category.assoc, lift_snd_assoc, lift_fst_assoc, lift_fst, Category.id_comp]\n          rw [← condition_assoc, condition]\n        · simp only [Category.assoc, lift_snd, lift_fst_assoc, lift_snd_assoc, Category.id_comp]\n          rw [condition]\n      · simp only [Category.assoc, lift_snd_assoc, lift_snd, Category.id_comp]\n  inv_hom_id := by\n    apply pullback.hom_ext\n    · simp only [Category.assoc, lift_fst, lift_fst_assoc, lift_snd, Category.id_comp]\n    · simp only [Category.assoc, lift_snd, lift_snd_assoc, Category.id_comp]\n\n"}
{"name":"CategoryTheory.Limits.pullback_map_eq_pullbackFstFstIso_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.Diagonal","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Limits.HasPullbacks C\nX Y S X' Y' S' : C\nf : Quiver.Hom X S\ng : Quiver.Hom Y S\nf' : Quiver.Hom X' S'\ng' : Quiver.Hom Y' S'\ni₁ : Quiver.Hom X X'\ni₂ : Quiver.Hom Y Y'\ni₃ : Quiver.Hom S S'\ne₁ : Eq (CategoryTheory.CategoryStruct.comp f i₃) (CategoryTheory.CategoryStruct.comp i₁ f')\ne₂ : Eq (CategoryTheory.CategoryStruct.comp g i₃) (CategoryTheory.CategoryStruct.comp i₂ g')\ninst✝ : CategoryTheory.Mono i₃\n⊢ Eq (CategoryTheory.Limits.pullback.map f g f' g' i₁ i₂ i₃ e₁ e₂) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullbackFstFstIso f g f' g' i₁ i₂ i₃ e₁ e₂).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd (CategoryTheory.Limits.pullback.fst (CategoryTheory.Limits.pullback.fst f' g') i₁) (CategoryTheory.Limits.pullback.fst (CategoryTheory.Limits.pullback.snd f' g') i₂)) (CategoryTheory.Limits.pullback.fst (CategoryTheory.Limits.pullback.snd f' g') i₂)))","decl":"theorem pullback_map_eq_pullbackFstFstIso_inv {X Y S X' Y' S' : C} (f : X ⟶ S) (g : Y ⟶ S)\n    (f' : X' ⟶ S') (g' : Y' ⟶ S') (i₁ : X ⟶ X') (i₂ : Y ⟶ Y') (i₃ : S ⟶ S')\n    (e₁ : f ≫ i₃ = i₁ ≫ f') (e₂ : g ≫ i₃ = i₂ ≫ g') [Mono i₃] :\n    pullback.map f g f' g' i₁ i₂ i₃ e₁ e₂ =\n      (pullbackFstFstIso f g f' g' i₁ i₂ i₃ e₁ e₂).inv ≫ pullback.snd _ _ ≫ pullback.fst _ _ := by\n  simp only [pullbackFstFstIso_inv, lift_snd_assoc, lift_fst]\n\n"}
{"name":"CategoryTheory.Limits.pullback_lift_map_isPullback","module":"Mathlib.CategoryTheory.Limits.Shapes.Diagonal","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Limits.HasPullbacks C\nX Y S X' Y' S' : C\nf : Quiver.Hom X S\ng : Quiver.Hom Y S\nf' : Quiver.Hom X' S'\ng' : Quiver.Hom Y' S'\ni₁ : Quiver.Hom X X'\ni₂ : Quiver.Hom Y Y'\ni₃ : Quiver.Hom S S'\ne₁ : Eq (CategoryTheory.CategoryStruct.comp f i₃) (CategoryTheory.CategoryStruct.comp i₁ f')\ne₂ : Eq (CategoryTheory.CategoryStruct.comp g i₃) (CategoryTheory.CategoryStruct.comp i₂ g')\ninst✝ : CategoryTheory.Mono i₃\n⊢ CategoryTheory.IsPullback (CategoryTheory.Limits.pullback.lift (CategoryTheory.Limits.pullback.map f g f' g' i₁ i₂ i₃ e₁ e₂) (CategoryTheory.Limits.pullback.fst f g) ⋯) (CategoryTheory.Limits.pullback.lift (CategoryTheory.Limits.pullback.map f g f' g' i₁ i₂ i₃ e₁ e₂) (CategoryTheory.Limits.pullback.snd f g) ⋯) (CategoryTheory.Limits.pullback.fst (CategoryTheory.Limits.pullback.fst f' g') i₁) (CategoryTheory.Limits.pullback.fst (CategoryTheory.Limits.pullback.snd f' g') i₂)","decl":"theorem pullback_lift_map_isPullback {X Y S X' Y' S' : C} (f : X ⟶ S) (g : Y ⟶ S) (f' : X' ⟶ S')\n    (g' : Y' ⟶ S') (i₁ : X ⟶ X') (i₂ : Y ⟶ Y') (i₃ : S ⟶ S') (e₁ : f ≫ i₃ = i₁ ≫ f')\n    (e₂ : g ≫ i₃ = i₂ ≫ g') [Mono i₃] :\n    IsPullback (pullback.lift (pullback.map f g f' g' i₁ i₂ i₃ e₁ e₂) (fst _ _) (lift_fst _ _ _))\n      (pullback.lift (pullback.map f g f' g' i₁ i₂ i₃ e₁ e₂) (snd _ _) (lift_snd _ _ _))\n      (pullback.fst _ _) (pullback.fst _ _) :=\n  IsPullback.of_iso_pullback ⟨by rw [lift_fst, lift_fst]⟩\n    (pullbackFstFstIso f g f' g' i₁ i₂ i₃ e₁ e₂).symm (by simp) (by simp)\n\n"}
