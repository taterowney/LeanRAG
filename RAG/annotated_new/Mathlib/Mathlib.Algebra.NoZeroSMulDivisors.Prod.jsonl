{"name":"Prod.noZeroSMulDivisors","module":"Mathlib.Algebra.NoZeroSMulDivisors.Prod","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_3\ninst✝⁶ : Zero R\ninst✝⁵ : Zero M\ninst✝⁴ : Zero N\ninst✝³ : SMulWithZero R M\ninst✝² : SMulWithZero R N\ninst✝¹ : NoZeroSMulDivisors R M\ninst✝ : NoZeroSMulDivisors R N\n⊢ NoZeroSMulDivisors R (Prod M N)","decl":"instance noZeroSMulDivisors [Zero R] [Zero M] [Zero N]\n    [SMulWithZero R M] [SMulWithZero R N] [NoZeroSMulDivisors R M] [NoZeroSMulDivisors R N] :\n    NoZeroSMulDivisors R (M × N) :=\n  { eq_zero_or_eq_zero_of_smul_eq_zero := by -- Porting note: in mathlib3 there is no need for `by`/\n      -- `intro`/`exact`, i.e. the following works:\n      -- ⟨fun c ⟨x, y⟩ h =>\n      --   or_iff_not_imp_left.mpr fun hc =>\n      intro c ⟨x, y⟩ h\n      exact or_iff_not_imp_left.mpr fun hc =>\n        mk.inj_iff.mpr\n          ⟨(smul_eq_zero.mp (congr_arg fst h)).resolve_left hc,\n            (smul_eq_zero.mp (congr_arg snd h)).resolve_left hc⟩ }\n\n"}
