{"name":"CategoryTheory.endofunctorMonoidalCategory_tensorUnit_obj","module":"Mathlib.CategoryTheory.Monoidal.End","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : C\n‚ä¢ Eq (CategoryTheory.MonoidalCategoryStruct.tensorUnit.obj X) X","decl":"@[simp] theorem endofunctorMonoidalCategory_tensorUnit_obj (X : C) :\n    (ùüô_ (C ‚•§ C)).obj X = X := rfl\n\n"}
{"name":"CategoryTheory.endofunctorMonoidalCategory_tensorUnit_map","module":"Mathlib.CategoryTheory.Monoidal.End","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\n‚ä¢ Eq (CategoryTheory.MonoidalCategoryStruct.tensorUnit.map f) f","decl":"@[simp] theorem endofunctorMonoidalCategory_tensorUnit_map {X Y : C} (f : X ‚ü∂ Y) :\n    (ùüô_ (C ‚•§ C)).map f = f := rfl\n\n"}
{"name":"CategoryTheory.endofunctorMonoidalCategory_tensorObj_obj","module":"Mathlib.CategoryTheory.Monoidal.End","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF G : CategoryTheory.Functor C C\nX : C\n‚ä¢ Eq ((CategoryTheory.MonoidalCategoryStruct.tensorObj F G).obj X) (G.obj (F.obj X))","decl":"@[simp] theorem endofunctorMonoidalCategory_tensorObj_obj (F G : C ‚•§ C) (X : C) :\n    (F ‚äó G).obj X = G.obj (F.obj X) := rfl\n\n"}
{"name":"CategoryTheory.endofunctorMonoidalCategory_tensorObj_map","module":"Mathlib.CategoryTheory.Monoidal.End","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF G : CategoryTheory.Functor C C\nX Y : C\nf : Quiver.Hom X Y\n‚ä¢ Eq ((CategoryTheory.MonoidalCategoryStruct.tensorObj F G).map f) (G.map (F.map f))","decl":"@[simp] theorem endofunctorMonoidalCategory_tensorObj_map (F G : C ‚•§ C) {X Y : C} (f : X ‚ü∂ Y) :\n    (F ‚äó G).map f = G.map (F.map f) := rfl\n\n"}
{"name":"CategoryTheory.endofunctorMonoidalCategory_tensorMap_app","module":"Mathlib.CategoryTheory.Monoidal.End","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF G H K : CategoryTheory.Functor C C\nŒ± : Quiver.Hom F G\nŒ≤ : Quiver.Hom H K\nX : C\n‚ä¢ Eq ((CategoryTheory.MonoidalCategoryStruct.tensorHom Œ± Œ≤).app X) (CategoryTheory.CategoryStruct.comp (Œ≤.app (F.obj X)) (K.map (Œ±.app X)))","decl":"@[simp] theorem endofunctorMonoidalCategory_tensorMap_app\n    {F G H K : C ‚•§ C} {Œ± : F ‚ü∂ G} {Œ≤ : H ‚ü∂ K} (X : C) :\n    (Œ± ‚äó Œ≤).app X = Œ≤.app (F.obj X) ‚â´ K.map (Œ±.app X) := rfl\n\n"}
{"name":"CategoryTheory.endofunctorMonoidalCategory_whiskerLeft_app","module":"Mathlib.CategoryTheory.Monoidal.End","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF H K : CategoryTheory.Functor C C\nŒ≤ : Quiver.Hom H K\nX : C\n‚ä¢ Eq ((CategoryTheory.MonoidalCategoryStruct.whiskerLeft F Œ≤).app X) (Œ≤.app (F.obj X))","decl":"@[simp] theorem endofunctorMonoidalCategory_whiskerLeft_app\n    {F H K : C ‚•§ C} {Œ≤ : H ‚ü∂ K} (X : C) :\n    (F ‚óÅ Œ≤).app X = Œ≤.app (F.obj X) := rfl\n\n"}
{"name":"CategoryTheory.endofunctorMonoidalCategory_whiskerRight_app","module":"Mathlib.CategoryTheory.Monoidal.End","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF G H : CategoryTheory.Functor C C\nŒ± : Quiver.Hom F G\nX : C\n‚ä¢ Eq ((CategoryTheory.MonoidalCategoryStruct.whiskerRight Œ± H).app X) (H.map (Œ±.app X))","decl":"@[simp] theorem endofunctorMonoidalCategory_whiskerRight_app\n    {F G H : C ‚•§ C} {Œ± : F ‚ü∂ G} (X : C) :\n    (Œ± ‚ñ∑ H).app X = H.map (Œ±.app X) := rfl\n\n"}
{"name":"CategoryTheory.endofunctorMonoidalCategory_associator_hom_app","module":"Mathlib.CategoryTheory.Monoidal.End","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF G H : CategoryTheory.Functor C C\nX : C\n‚ä¢ Eq ((CategoryTheory.MonoidalCategoryStruct.associator F G H).hom.app X) (CategoryTheory.CategoryStruct.id ((CategoryTheory.MonoidalCategoryStruct.tensorObj (CategoryTheory.MonoidalCategoryStruct.tensorObj F G) H).obj X))","decl":"@[simp] theorem endofunctorMonoidalCategory_associator_hom_app (F G H : C ‚•§ C) (X : C) :\n  (Œ±_ F G H).hom.app X = ùüô _ := rfl\n\n"}
{"name":"CategoryTheory.endofunctorMonoidalCategory_associator_inv_app","module":"Mathlib.CategoryTheory.Monoidal.End","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF G H : CategoryTheory.Functor C C\nX : C\n‚ä¢ Eq ((CategoryTheory.MonoidalCategoryStruct.associator F G H).inv.app X) (CategoryTheory.CategoryStruct.id ((CategoryTheory.MonoidalCategoryStruct.tensorObj F (CategoryTheory.MonoidalCategoryStruct.tensorObj G H)).obj X))","decl":"@[simp] theorem endofunctorMonoidalCategory_associator_inv_app (F G H : C ‚•§ C) (X : C) :\n  (Œ±_ F G H).inv.app X = ùüô _ := rfl\n\n"}
{"name":"CategoryTheory.endofunctorMonoidalCategory_leftUnitor_hom_app","module":"Mathlib.CategoryTheory.Monoidal.End","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor C C\nX : C\n‚ä¢ Eq ((CategoryTheory.MonoidalCategoryStruct.leftUnitor F).hom.app X) (CategoryTheory.CategoryStruct.id ((CategoryTheory.MonoidalCategoryStruct.tensorObj CategoryTheory.MonoidalCategoryStruct.tensorUnit F).obj X))","decl":"@[simp] theorem endofunctorMonoidalCategory_leftUnitor_hom_app (F : C ‚•§ C) (X : C) :\n  (Œª_ F).hom.app X = ùüô _ := rfl\n\n"}
{"name":"CategoryTheory.endofunctorMonoidalCategory_leftUnitor_inv_app","module":"Mathlib.CategoryTheory.Monoidal.End","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor C C\nX : C\n‚ä¢ Eq ((CategoryTheory.MonoidalCategoryStruct.leftUnitor F).inv.app X) (CategoryTheory.CategoryStruct.id (F.obj X))","decl":"@[simp] theorem endofunctorMonoidalCategory_leftUnitor_inv_app (F : C ‚•§ C) (X : C) :\n  (Œª_ F).inv.app X = ùüô _ := rfl\n\n"}
{"name":"CategoryTheory.endofunctorMonoidalCategory_rightUnitor_hom_app","module":"Mathlib.CategoryTheory.Monoidal.End","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor C C\nX : C\n‚ä¢ Eq ((CategoryTheory.MonoidalCategoryStruct.rightUnitor F).hom.app X) (CategoryTheory.CategoryStruct.id ((CategoryTheory.MonoidalCategoryStruct.tensorObj F CategoryTheory.MonoidalCategoryStruct.tensorUnit).obj X))","decl":"@[simp] theorem endofunctorMonoidalCategory_rightUnitor_hom_app (F : C ‚•§ C) (X : C) :\n  (œÅ_ F).hom.app X = ùüô _ := rfl\n\n"}
{"name":"CategoryTheory.endofunctorMonoidalCategory_rightUnitor_inv_app","module":"Mathlib.CategoryTheory.Monoidal.End","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor C C\nX : C\n‚ä¢ Eq ((CategoryTheory.MonoidalCategoryStruct.rightUnitor F).inv.app X) (CategoryTheory.CategoryStruct.id (F.obj X))","decl":"@[simp] theorem endofunctorMonoidalCategory_rightUnitor_inv_app (F : C ‚•§ C) (X : C) :\n  (œÅ_ F).inv.app X = ùüô _ := rfl\n\n"}
{"name":"CategoryTheory.MonoidalCategory.tensoringRight_Œµ","module":"Mathlib.CategoryTheory.Monoidal.End","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.MonoidalCategory C\n‚ä¢ Eq (CategoryTheory.Functor.LaxMonoidal.Œµ (CategoryTheory.MonoidalCategory.tensoringRight C)) (CategoryTheory.MonoidalCategory.rightUnitorNatIso C).inv","decl":"@[simp] lemma tensoringRight_Œµ :\n    Œµ (tensoringRight C) = (rightUnitorNatIso C).inv := rfl\n\n"}
{"name":"CategoryTheory.MonoidalCategory.tensoringRight_Œ∑","module":"Mathlib.CategoryTheory.Monoidal.End","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.MonoidalCategory C\n‚ä¢ Eq (CategoryTheory.Functor.OplaxMonoidal.Œ∑ (CategoryTheory.MonoidalCategory.tensoringRight C)) (CategoryTheory.MonoidalCategory.rightUnitorNatIso C).hom","decl":"@[simp] lemma tensoringRight_Œ∑ :\n    Œ∑ (tensoringRight C) = (rightUnitorNatIso C).hom := rfl\n\n"}
{"name":"CategoryTheory.MonoidalCategory.tensoringRight_Œº","module":"Mathlib.CategoryTheory.Monoidal.End","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nX Y Z : C\n‚ä¢ Eq ((CategoryTheory.Functor.LaxMonoidal.Œº (CategoryTheory.MonoidalCategory.tensoringRight C) X Y).app Z) (CategoryTheory.MonoidalCategoryStruct.associator Z X Y).hom","decl":"@[simp] lemma tensoringRight_Œº (X Y : C) (Z : C) :\n    (Œº (tensoringRight C) X Y).app Z = (Œ±_ Z X Y).hom := rfl\n\n"}
{"name":"CategoryTheory.MonoidalCategory.tensoringRight_Œ¥","module":"Mathlib.CategoryTheory.Monoidal.End","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nX Y Z : C\n‚ä¢ Eq ((CategoryTheory.Functor.OplaxMonoidal.Œ¥ (CategoryTheory.MonoidalCategory.tensoringRight C) X Y).app Z) (CategoryTheory.MonoidalCategoryStruct.associator Z X Y).inv","decl":"@[simp] lemma tensoringRight_Œ¥ (X Y : C) (Z : C) :\n    (Œ¥ (tensoringRight C) X Y).app Z = (Œ±_ Z X Y).inv := rfl\n\n"}
{"name":"CategoryTheory.Œº_Œ¥_app","module":"Mathlib.CategoryTheory.Monoidal.End","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nM : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} M\ninst‚úù¬π : CategoryTheory.MonoidalCategory M\nF : CategoryTheory.Functor M (CategoryTheory.Functor C C)\ni j : M\nX : C\ninst‚úù : F.Monoidal\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Functor.LaxMonoidal.Œº F i j).app X) ((CategoryTheory.Functor.OplaxMonoidal.Œ¥ F i j).app X)) (CategoryTheory.CategoryStruct.id ((CategoryTheory.MonoidalCategoryStruct.tensorObj (F.obj i) (F.obj j)).obj X))","decl":"@[reassoc (attr := simp)]\ntheorem Œº_Œ¥_app (i j : M) (X : C) [F.Monoidal] :\n    (Œº F i j).app X ‚â´ (Œ¥ F i j).app X = ùüô _ :=\n  (ŒºIso F i j).hom_inv_id_app X\n\n"}
{"name":"CategoryTheory.Œº_Œ¥_app_assoc","module":"Mathlib.CategoryTheory.Monoidal.End","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nM : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} M\ninst‚úù¬π : CategoryTheory.MonoidalCategory M\nF : CategoryTheory.Functor M (CategoryTheory.Functor C C)\ni j : M\nX : C\ninst‚úù : F.Monoidal\nZ : C\nh : Quiver.Hom ((CategoryTheory.MonoidalCategoryStruct.tensorObj (F.obj i) (F.obj j)).obj X) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Functor.LaxMonoidal.Œº F i j).app X) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Functor.OplaxMonoidal.Œ¥ F i j).app X) h)) h","decl":"@[reassoc (attr := simp)]\ntheorem Œº_Œ¥_app (i j : M) (X : C) [F.Monoidal] :\n    (Œº F i j).app X ‚â´ (Œ¥ F i j).app X = ùüô _ :=\n  (ŒºIso F i j).hom_inv_id_app X\n\n"}
{"name":"CategoryTheory.Œ¥_Œº_app","module":"Mathlib.CategoryTheory.Monoidal.End","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nM : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} M\ninst‚úù¬π : CategoryTheory.MonoidalCategory M\nF : CategoryTheory.Functor M (CategoryTheory.Functor C C)\ni j : M\nX : C\ninst‚úù : F.Monoidal\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Functor.OplaxMonoidal.Œ¥ F i j).app X) ((CategoryTheory.Functor.LaxMonoidal.Œº F i j).app X)) (CategoryTheory.CategoryStruct.id ((F.obj (CategoryTheory.MonoidalCategoryStruct.tensorObj i j)).obj X))","decl":"@[reassoc (attr := simp)]\ntheorem Œ¥_Œº_app (i j : M) (X : C) [F.Monoidal] :\n    (Œ¥ F i j).app X ‚â´ (Œº F i j).app X = ùüô _ :=\n  (ŒºIso F i j).inv_hom_id_app X\n\n"}
{"name":"CategoryTheory.Œ¥_Œº_app_assoc","module":"Mathlib.CategoryTheory.Monoidal.End","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nM : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} M\ninst‚úù¬π : CategoryTheory.MonoidalCategory M\nF : CategoryTheory.Functor M (CategoryTheory.Functor C C)\ni j : M\nX : C\ninst‚úù : F.Monoidal\nZ : C\nh : Quiver.Hom ((F.obj (CategoryTheory.MonoidalCategoryStruct.tensorObj i j)).obj X) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Functor.OplaxMonoidal.Œ¥ F i j).app X) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Functor.LaxMonoidal.Œº F i j).app X) h)) h","decl":"@[reassoc (attr := simp)]\ntheorem Œ¥_Œº_app (i j : M) (X : C) [F.Monoidal] :\n    (Œ¥ F i j).app X ‚â´ (Œº F i j).app X = ùüô _ :=\n  (ŒºIso F i j).inv_hom_id_app X\n\n"}
{"name":"CategoryTheory.Œµ_Œ∑_app","module":"Mathlib.CategoryTheory.Monoidal.End","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nM : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} M\ninst‚úù¬π : CategoryTheory.MonoidalCategory M\nF : CategoryTheory.Functor M (CategoryTheory.Functor C C)\nX : C\ninst‚úù : F.Monoidal\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Functor.LaxMonoidal.Œµ F).app X) ((CategoryTheory.Functor.OplaxMonoidal.Œ∑ F).app X)) (CategoryTheory.CategoryStruct.id (CategoryTheory.MonoidalCategoryStruct.tensorUnit.obj X))","decl":"@[reassoc (attr := simp)]\ntheorem Œµ_Œ∑_app (X : C) [F.Monoidal] : (Œµ F).app X ‚â´ (Œ∑ F).app X = ùüô _ :=\n  (ŒµIso F).hom_inv_id_app X\n\n"}
{"name":"CategoryTheory.Œµ_Œ∑_app_assoc","module":"Mathlib.CategoryTheory.Monoidal.End","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nM : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} M\ninst‚úù¬π : CategoryTheory.MonoidalCategory M\nF : CategoryTheory.Functor M (CategoryTheory.Functor C C)\nX : C\ninst‚úù : F.Monoidal\nZ : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorUnit.obj X) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Functor.LaxMonoidal.Œµ F).app X) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Functor.OplaxMonoidal.Œ∑ F).app X) h)) h","decl":"@[reassoc (attr := simp)]\ntheorem Œµ_Œ∑_app (X : C) [F.Monoidal] : (Œµ F).app X ‚â´ (Œ∑ F).app X = ùüô _ :=\n  (ŒµIso F).hom_inv_id_app X\n\n"}
{"name":"CategoryTheory.Œ∑_Œµ_app_assoc","module":"Mathlib.CategoryTheory.Monoidal.End","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nM : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} M\ninst‚úù¬π : CategoryTheory.MonoidalCategory M\nF : CategoryTheory.Functor M (CategoryTheory.Functor C C)\nX : C\ninst‚úù : F.Monoidal\nZ : C\nh : Quiver.Hom ((F.obj CategoryTheory.MonoidalCategoryStruct.tensorUnit).obj X) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Functor.OplaxMonoidal.Œ∑ F).app X) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Functor.LaxMonoidal.Œµ F).app X) h)) h","decl":"@[reassoc (attr := simp)]\ntheorem Œ∑_Œµ_app (X : C) [F.Monoidal] : (Œ∑ F).app X ‚â´ (Œµ F).app X = ùüô _ :=\n  (ŒµIso F).inv_hom_id_app X\n\n"}
{"name":"CategoryTheory.Œ∑_Œµ_app","module":"Mathlib.CategoryTheory.Monoidal.End","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nM : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} M\ninst‚úù¬π : CategoryTheory.MonoidalCategory M\nF : CategoryTheory.Functor M (CategoryTheory.Functor C C)\nX : C\ninst‚úù : F.Monoidal\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Functor.OplaxMonoidal.Œ∑ F).app X) ((CategoryTheory.Functor.LaxMonoidal.Œµ F).app X)) (CategoryTheory.CategoryStruct.id ((F.obj CategoryTheory.MonoidalCategoryStruct.tensorUnit).obj X))","decl":"@[reassoc (attr := simp)]\ntheorem Œ∑_Œµ_app (X : C) [F.Monoidal] : (Œ∑ F).app X ‚â´ (Œµ F).app X = ùüô _ :=\n  (ŒµIso F).inv_hom_id_app X\n\n"}
{"name":"CategoryTheory.Œµ_naturality","module":"Mathlib.CategoryTheory.Monoidal.End","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nM : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} M\ninst‚úù¬π : CategoryTheory.MonoidalCategory M\nF : CategoryTheory.Functor M (CategoryTheory.Functor C C)\nX Y : C\nf : Quiver.Hom X Y\ninst‚úù : F.LaxMonoidal\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Functor.LaxMonoidal.Œµ F).app X) ((F.obj CategoryTheory.MonoidalCategoryStruct.tensorUnit).map f)) (CategoryTheory.CategoryStruct.comp f ((CategoryTheory.Functor.LaxMonoidal.Œµ F).app Y))","decl":"@[reassoc (attr := simp)]\ntheorem Œµ_naturality {X Y : C} (f : X ‚ü∂ Y) [F.LaxMonoidal] :\n    (Œµ F).app X ‚â´ (F.obj (ùüô_ M)).map f = f ‚â´ (Œµ F).app Y :=\n  ((Œµ F).naturality f).symm\n\n"}
{"name":"CategoryTheory.Œµ_naturality_assoc","module":"Mathlib.CategoryTheory.Monoidal.End","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nM : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} M\ninst‚úù¬π : CategoryTheory.MonoidalCategory M\nF : CategoryTheory.Functor M (CategoryTheory.Functor C C)\nX Y : C\nf : Quiver.Hom X Y\ninst‚úù : F.LaxMonoidal\nZ : C\nh : Quiver.Hom ((F.obj CategoryTheory.MonoidalCategoryStruct.tensorUnit).obj Y) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Functor.LaxMonoidal.Œµ F).app X) (CategoryTheory.CategoryStruct.comp ((F.obj CategoryTheory.MonoidalCategoryStruct.tensorUnit).map f) h)) (CategoryTheory.CategoryStruct.comp f (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Functor.LaxMonoidal.Œµ F).app Y) h))","decl":"@[reassoc (attr := simp)]\ntheorem Œµ_naturality {X Y : C} (f : X ‚ü∂ Y) [F.LaxMonoidal] :\n    (Œµ F).app X ‚â´ (F.obj (ùüô_ M)).map f = f ‚â´ (Œµ F).app Y :=\n  ((Œµ F).naturality f).symm\n\n"}
{"name":"CategoryTheory.Œ∑_naturality","module":"Mathlib.CategoryTheory.Monoidal.End","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nM : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} M\ninst‚úù¬π : CategoryTheory.MonoidalCategory M\nF : CategoryTheory.Functor M (CategoryTheory.Functor C C)\nX Y : C\nf : Quiver.Hom X Y\ninst‚úù : F.OplaxMonoidal\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Functor.OplaxMonoidal.Œ∑ F).app X) (CategoryTheory.MonoidalCategoryStruct.tensorUnit.map f)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Functor.OplaxMonoidal.Œ∑ F).app X) f)","decl":"@[reassoc (attr := simp)]\ntheorem Œ∑_naturality {X Y : C} (f : X ‚ü∂ Y) [F.OplaxMonoidal]:\n    (Œ∑ F).app X ‚â´ (ùüô_ (C ‚•§ C)).map f = (Œ∑ F).app X ‚â´ f := by\n  simp\n\n"}
{"name":"CategoryTheory.Œ∑_naturality_assoc","module":"Mathlib.CategoryTheory.Monoidal.End","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nM : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} M\ninst‚úù¬π : CategoryTheory.MonoidalCategory M\nF : CategoryTheory.Functor M (CategoryTheory.Functor C C)\nX Y : C\nf : Quiver.Hom X Y\ninst‚úù : F.OplaxMonoidal\nZ : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorUnit.obj Y) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Functor.OplaxMonoidal.Œ∑ F).app X) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorUnit.map f) h)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Functor.OplaxMonoidal.Œ∑ F).app X) (CategoryTheory.CategoryStruct.comp f h))","decl":"@[reassoc (attr := simp)]\ntheorem Œ∑_naturality {X Y : C} (f : X ‚ü∂ Y) [F.OplaxMonoidal]:\n    (Œ∑ F).app X ‚â´ (ùüô_ (C ‚•§ C)).map f = (Œ∑ F).app X ‚â´ f := by\n  simp\n\n"}
{"name":"CategoryTheory.Œº_naturality_assoc","module":"Mathlib.CategoryTheory.Monoidal.End","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nM : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} M\ninst‚úù¬π : CategoryTheory.MonoidalCategory M\nF : CategoryTheory.Functor M (CategoryTheory.Functor C C)\nm n : M\nX Y : C\nf : Quiver.Hom X Y\ninst‚úù : F.LaxMonoidal\nZ : C\nh : Quiver.Hom ((F.obj (CategoryTheory.MonoidalCategoryStruct.tensorObj m n)).obj Y) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((F.obj n).map ((F.obj m).map f)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Functor.LaxMonoidal.Œº F m n).app Y) h)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Functor.LaxMonoidal.Œº F m n).app X) (CategoryTheory.CategoryStruct.comp ((F.obj (CategoryTheory.MonoidalCategoryStruct.tensorObj m n)).map f) h))","decl":"@[reassoc (attr := simp)]\ntheorem Œº_naturality {m n : M} {X Y : C} (f : X ‚ü∂ Y) [F.LaxMonoidal] :\n    (F.obj n).map ((F.obj m).map f) ‚â´ (Œº F m n).app Y = (Œº F m n).app X ‚â´ (F.obj _).map f :=\n  (Œº F m n).naturality f\n\n-- This is a simp lemma in the reverse direction via `NatTrans.naturality`.\n"}
{"name":"CategoryTheory.Œº_naturality","module":"Mathlib.CategoryTheory.Monoidal.End","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nM : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} M\ninst‚úù¬π : CategoryTheory.MonoidalCategory M\nF : CategoryTheory.Functor M (CategoryTheory.Functor C C)\nm n : M\nX Y : C\nf : Quiver.Hom X Y\ninst‚úù : F.LaxMonoidal\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((F.obj n).map ((F.obj m).map f)) ((CategoryTheory.Functor.LaxMonoidal.Œº F m n).app Y)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Functor.LaxMonoidal.Œº F m n).app X) ((F.obj (CategoryTheory.MonoidalCategoryStruct.tensorObj m n)).map f))","decl":"@[reassoc (attr := simp)]\ntheorem Œº_naturality {m n : M} {X Y : C} (f : X ‚ü∂ Y) [F.LaxMonoidal] :\n    (F.obj n).map ((F.obj m).map f) ‚â´ (Œº F m n).app Y = (Œº F m n).app X ‚â´ (F.obj _).map f :=\n  (Œº F m n).naturality f\n\n-- This is a simp lemma in the reverse direction via `NatTrans.naturality`.\n"}
{"name":"CategoryTheory.Œ¥_naturality","module":"Mathlib.CategoryTheory.Monoidal.End","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nM : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} M\ninst‚úù¬π : CategoryTheory.MonoidalCategory M\nF : CategoryTheory.Functor M (CategoryTheory.Functor C C)\nm n : M\nX Y : C\nf : Quiver.Hom X Y\ninst‚úù : F.OplaxMonoidal\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Functor.OplaxMonoidal.Œ¥ F m n).app X) ((F.obj n).map ((F.obj m).map f))) (CategoryTheory.CategoryStruct.comp ((F.obj (CategoryTheory.MonoidalCategoryStruct.tensorObj m n)).map f) ((CategoryTheory.Functor.OplaxMonoidal.Œ¥ F m n).app Y))","decl":"@[reassoc]\ntheorem Œ¥_naturality {m n : M} {X Y : C} (f : X ‚ü∂ Y) [F.OplaxMonoidal]:\n    (Œ¥ F m n).app X ‚â´ (F.obj n).map ((F.obj m).map f) =\n      (F.obj _).map f ‚â´ (Œ¥ F m n).app Y := by simp\n\n-- This is not a simp lemma since it could be proved by the lemmas later.\n"}
{"name":"CategoryTheory.Œ¥_naturality_assoc","module":"Mathlib.CategoryTheory.Monoidal.End","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nM : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} M\ninst‚úù¬π : CategoryTheory.MonoidalCategory M\nF : CategoryTheory.Functor M (CategoryTheory.Functor C C)\nm n : M\nX Y : C\nf : Quiver.Hom X Y\ninst‚úù : F.OplaxMonoidal\nZ : C\nh : Quiver.Hom ((F.obj n).obj ((F.obj m).obj Y)) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Functor.OplaxMonoidal.Œ¥ F m n).app X) (CategoryTheory.CategoryStruct.comp ((F.obj n).map ((F.obj m).map f)) h)) (CategoryTheory.CategoryStruct.comp ((F.obj (CategoryTheory.MonoidalCategoryStruct.tensorObj m n)).map f) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Functor.OplaxMonoidal.Œ¥ F m n).app Y) h))","decl":"@[reassoc]\ntheorem Œ¥_naturality {m n : M} {X Y : C} (f : X ‚ü∂ Y) [F.OplaxMonoidal]:\n    (Œ¥ F m n).app X ‚â´ (F.obj n).map ((F.obj m).map f) =\n      (F.obj _).map f ‚â´ (Œ¥ F m n).app Y := by simp\n\n-- This is not a simp lemma since it could be proved by the lemmas later.\n"}
{"name":"CategoryTheory.Œº_naturality‚ÇÇ_assoc","module":"Mathlib.CategoryTheory.Monoidal.End","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nM : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} M\ninst‚úù¬π : CategoryTheory.MonoidalCategory M\nF : CategoryTheory.Functor M (CategoryTheory.Functor C C)\nm n m' n' : M\nf : Quiver.Hom m m'\ng : Quiver.Hom n n'\nX : C\ninst‚úù : F.LaxMonoidal\nZ : C\nh : Quiver.Hom ((F.obj (CategoryTheory.MonoidalCategoryStruct.tensorObj m' n')).obj X) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((F.map g).app ((F.obj m).obj X)) (CategoryTheory.CategoryStruct.comp ((F.obj n').map ((F.map f).app X)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Functor.LaxMonoidal.Œº F m' n').app X) h))) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Functor.LaxMonoidal.Œº F m n).app X) (CategoryTheory.CategoryStruct.comp ((F.map (CategoryTheory.MonoidalCategoryStruct.tensorHom f g)).app X) h))","decl":"@[reassoc]\ntheorem Œº_naturality‚ÇÇ {m n m' n' : M} (f : m ‚ü∂ m') (g : n ‚ü∂ n') (X : C) [F.LaxMonoidal] :\n    (F.map g).app ((F.obj m).obj X) ‚â´ (F.obj n').map ((F.map f).app X) ‚â´ (Œº F m' n').app X =\n      (Œº F m n).app X ‚â´ (F.map (f ‚äó g)).app X := by\n  have := congr_app (Œº_natural F f g) X\n  dsimp at this\n  simpa using this\n\n"}
{"name":"CategoryTheory.Œº_naturality‚ÇÇ","module":"Mathlib.CategoryTheory.Monoidal.End","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nM : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} M\ninst‚úù¬π : CategoryTheory.MonoidalCategory M\nF : CategoryTheory.Functor M (CategoryTheory.Functor C C)\nm n m' n' : M\nf : Quiver.Hom m m'\ng : Quiver.Hom n n'\nX : C\ninst‚úù : F.LaxMonoidal\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((F.map g).app ((F.obj m).obj X)) (CategoryTheory.CategoryStruct.comp ((F.obj n').map ((F.map f).app X)) ((CategoryTheory.Functor.LaxMonoidal.Œº F m' n').app X))) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Functor.LaxMonoidal.Œº F m n).app X) ((F.map (CategoryTheory.MonoidalCategoryStruct.tensorHom f g)).app X))","decl":"@[reassoc]\ntheorem Œº_naturality‚ÇÇ {m n m' n' : M} (f : m ‚ü∂ m') (g : n ‚ü∂ n') (X : C) [F.LaxMonoidal] :\n    (F.map g).app ((F.obj m).obj X) ‚â´ (F.obj n').map ((F.map f).app X) ‚â´ (Œº F m' n').app X =\n      (Œº F m n).app X ‚â´ (F.map (f ‚äó g)).app X := by\n  have := congr_app (Œº_natural F f g) X\n  dsimp at this\n  simpa using this\n\n"}
{"name":"CategoryTheory.Œº_naturality‚Çó_assoc","module":"Mathlib.CategoryTheory.Monoidal.End","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nM : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} M\ninst‚úù¬π : CategoryTheory.MonoidalCategory M\nF : CategoryTheory.Functor M (CategoryTheory.Functor C C)\nm n m' : M\nf : Quiver.Hom m m'\nX : C\ninst‚úù : F.LaxMonoidal\nZ : C\nh : Quiver.Hom ((F.obj (CategoryTheory.MonoidalCategoryStruct.tensorObj m' n)).obj X) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((F.obj n).map ((F.map f).app X)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Functor.LaxMonoidal.Œº F m' n).app X) h)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Functor.LaxMonoidal.Œº F m n).app X) (CategoryTheory.CategoryStruct.comp ((F.map (CategoryTheory.MonoidalCategoryStruct.whiskerRight f n)).app X) h))","decl":"@[reassoc (attr := simp)]\ntheorem Œº_naturality‚Çó {m n m' : M} (f : m ‚ü∂ m') (X : C) [F.LaxMonoidal]:\n    (F.obj n).map ((F.map f).app X) ‚â´ (Œº F m' n).app X =\n      (Œº F m n).app X ‚â´ (F.map (f ‚ñ∑ n)).app X := by\n  rw [‚Üê tensorHom_id, ‚Üê Œº_naturality‚ÇÇ F f (ùüô n) X]\n  simp\n\n"}
{"name":"CategoryTheory.Œº_naturality‚Çó","module":"Mathlib.CategoryTheory.Monoidal.End","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nM : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} M\ninst‚úù¬π : CategoryTheory.MonoidalCategory M\nF : CategoryTheory.Functor M (CategoryTheory.Functor C C)\nm n m' : M\nf : Quiver.Hom m m'\nX : C\ninst‚úù : F.LaxMonoidal\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((F.obj n).map ((F.map f).app X)) ((CategoryTheory.Functor.LaxMonoidal.Œº F m' n).app X)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Functor.LaxMonoidal.Œº F m n).app X) ((F.map (CategoryTheory.MonoidalCategoryStruct.whiskerRight f n)).app X))","decl":"@[reassoc (attr := simp)]\ntheorem Œº_naturality‚Çó {m n m' : M} (f : m ‚ü∂ m') (X : C) [F.LaxMonoidal]:\n    (F.obj n).map ((F.map f).app X) ‚â´ (Œº F m' n).app X =\n      (Œº F m n).app X ‚â´ (F.map (f ‚ñ∑ n)).app X := by\n  rw [‚Üê tensorHom_id, ‚Üê Œº_naturality‚ÇÇ F f (ùüô n) X]\n  simp\n\n"}
{"name":"CategoryTheory.Œº_naturality·µ£","module":"Mathlib.CategoryTheory.Monoidal.End","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nM : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} M\ninst‚úù¬π : CategoryTheory.MonoidalCategory M\nF : CategoryTheory.Functor M (CategoryTheory.Functor C C)\nm n n' : M\ng : Quiver.Hom n n'\nX : C\ninst‚úù : F.LaxMonoidal\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((F.map g).app ((F.obj m).obj X)) ((CategoryTheory.Functor.LaxMonoidal.Œº F m n').app X)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Functor.LaxMonoidal.Œº F m n).app X) ((F.map (CategoryTheory.MonoidalCategoryStruct.whiskerLeft m g)).app X))","decl":"@[reassoc (attr := simp)]\ntheorem Œº_naturality·µ£ {m n n' : M} (g : n ‚ü∂ n') (X : C) [F.LaxMonoidal] :\n    (F.map g).app ((F.obj m).obj X) ‚â´ (Œº F m n').app X =\n      (Œº F m n).app X ‚â´ (F.map (m ‚óÅ g)).app X := by\n  rw [‚Üê id_tensorHom, ‚Üê Œº_naturality‚ÇÇ F (ùüô m) g X]\n  simp\n\n"}
{"name":"CategoryTheory.Œº_naturality·µ£_assoc","module":"Mathlib.CategoryTheory.Monoidal.End","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nM : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} M\ninst‚úù¬π : CategoryTheory.MonoidalCategory M\nF : CategoryTheory.Functor M (CategoryTheory.Functor C C)\nm n n' : M\ng : Quiver.Hom n n'\nX : C\ninst‚úù : F.LaxMonoidal\nZ : C\nh : Quiver.Hom ((F.obj (CategoryTheory.MonoidalCategoryStruct.tensorObj m n')).obj X) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((F.map g).app ((F.obj m).obj X)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Functor.LaxMonoidal.Œº F m n').app X) h)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Functor.LaxMonoidal.Œº F m n).app X) (CategoryTheory.CategoryStruct.comp ((F.map (CategoryTheory.MonoidalCategoryStruct.whiskerLeft m g)).app X) h))","decl":"@[reassoc (attr := simp)]\ntheorem Œº_naturality·µ£ {m n n' : M} (g : n ‚ü∂ n') (X : C) [F.LaxMonoidal] :\n    (F.map g).app ((F.obj m).obj X) ‚â´ (Œº F m n').app X =\n      (Œº F m n).app X ‚â´ (F.map (m ‚óÅ g)).app X := by\n  rw [‚Üê id_tensorHom, ‚Üê Œº_naturality‚ÇÇ F (ùüô m) g X]\n  simp\n\n"}
{"name":"CategoryTheory.Œ¥_naturality‚Çó","module":"Mathlib.CategoryTheory.Monoidal.End","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nM : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} M\ninst‚úù¬π : CategoryTheory.MonoidalCategory M\nF : CategoryTheory.Functor M (CategoryTheory.Functor C C)\nm n m' : M\nf : Quiver.Hom m m'\nX : C\ninst‚úù : F.OplaxMonoidal\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Functor.OplaxMonoidal.Œ¥ F m n).app X) ((F.obj n).map ((F.map f).app X))) (CategoryTheory.CategoryStruct.comp ((F.map (CategoryTheory.MonoidalCategoryStruct.whiskerRight f n)).app X) ((CategoryTheory.Functor.OplaxMonoidal.Œ¥ F m' n).app X))","decl":"@[reassoc (attr := simp)]\ntheorem Œ¥_naturality‚Çó {m n m' : M} (f : m ‚ü∂ m') (X : C) [F.OplaxMonoidal] :\n    (Œ¥ F m n).app X ‚â´ (F.obj n).map ((F.map f).app X) =\n      (F.map (f ‚ñ∑ n)).app X ‚â´ (Œ¥ F m' n).app X :=\n  congr_app (Œ¥_natural_left F f n) X\n\n"}
{"name":"CategoryTheory.Œ¥_naturality‚Çó_assoc","module":"Mathlib.CategoryTheory.Monoidal.End","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nM : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} M\ninst‚úù¬π : CategoryTheory.MonoidalCategory M\nF : CategoryTheory.Functor M (CategoryTheory.Functor C C)\nm n m' : M\nf : Quiver.Hom m m'\nX : C\ninst‚úù : F.OplaxMonoidal\nZ : C\nh : Quiver.Hom ((F.obj n).obj ((F.obj m').obj X)) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Functor.OplaxMonoidal.Œ¥ F m n).app X) (CategoryTheory.CategoryStruct.comp ((F.obj n).map ((F.map f).app X)) h)) (CategoryTheory.CategoryStruct.comp ((F.map (CategoryTheory.MonoidalCategoryStruct.whiskerRight f n)).app X) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Functor.OplaxMonoidal.Œ¥ F m' n).app X) h))","decl":"@[reassoc (attr := simp)]\ntheorem Œ¥_naturality‚Çó {m n m' : M} (f : m ‚ü∂ m') (X : C) [F.OplaxMonoidal] :\n    (Œ¥ F m n).app X ‚â´ (F.obj n).map ((F.map f).app X) =\n      (F.map (f ‚ñ∑ n)).app X ‚â´ (Œ¥ F m' n).app X :=\n  congr_app (Œ¥_natural_left F f n) X\n\n"}
{"name":"CategoryTheory.Œ¥_naturality·µ£","module":"Mathlib.CategoryTheory.Monoidal.End","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nM : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} M\ninst‚úù¬π : CategoryTheory.MonoidalCategory M\nF : CategoryTheory.Functor M (CategoryTheory.Functor C C)\nm n n' : M\ng : Quiver.Hom n n'\nX : C\ninst‚úù : F.OplaxMonoidal\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Functor.OplaxMonoidal.Œ¥ F m n).app X) ((F.map g).app ((F.obj m).obj X))) (CategoryTheory.CategoryStruct.comp ((F.map (CategoryTheory.MonoidalCategoryStruct.whiskerLeft m g)).app X) ((CategoryTheory.Functor.OplaxMonoidal.Œ¥ F m n').app X))","decl":"@[reassoc (attr := simp)]\ntheorem Œ¥_naturality·µ£ {m n n' : M} (g : n ‚ü∂ n') (X : C) [F.OplaxMonoidal]:\n    (Œ¥ F m n).app X ‚â´ (F.map g).app ((F.obj m).obj X) =\n      (F.map (m ‚óÅ g)).app X ‚â´ (Œ¥ F m n').app X :=\n  congr_app (Œ¥_natural_right F m g) X\n\n"}
{"name":"CategoryTheory.Œ¥_naturality·µ£_assoc","module":"Mathlib.CategoryTheory.Monoidal.End","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nM : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} M\ninst‚úù¬π : CategoryTheory.MonoidalCategory M\nF : CategoryTheory.Functor M (CategoryTheory.Functor C C)\nm n n' : M\ng : Quiver.Hom n n'\nX : C\ninst‚úù : F.OplaxMonoidal\nZ : C\nh : Quiver.Hom ((F.obj n').obj ((F.obj m).obj X)) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Functor.OplaxMonoidal.Œ¥ F m n).app X) (CategoryTheory.CategoryStruct.comp ((F.map g).app ((F.obj m).obj X)) h)) (CategoryTheory.CategoryStruct.comp ((F.map (CategoryTheory.MonoidalCategoryStruct.whiskerLeft m g)).app X) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Functor.OplaxMonoidal.Œ¥ F m n').app X) h))","decl":"@[reassoc (attr := simp)]\ntheorem Œ¥_naturality·µ£ {m n n' : M} (g : n ‚ü∂ n') (X : C) [F.OplaxMonoidal]:\n    (Œ¥ F m n).app X ‚â´ (F.map g).app ((F.obj m).obj X) =\n      (F.map (m ‚óÅ g)).app X ‚â´ (Œ¥ F m n').app X :=\n  congr_app (Œ¥_natural_right F m g) X\n\n"}
{"name":"CategoryTheory.left_unitality_app_assoc","module":"Mathlib.CategoryTheory.Monoidal.End","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nM : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} M\ninst‚úù¬π : CategoryTheory.MonoidalCategory M\nF : CategoryTheory.Functor M (CategoryTheory.Functor C C)\nn : M\nX : C\ninst‚úù : F.LaxMonoidal\nZ : C\nh : Quiver.Hom ((F.obj n).obj X) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((F.obj n).map ((CategoryTheory.Functor.LaxMonoidal.Œµ F).app X)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Functor.LaxMonoidal.Œº F CategoryTheory.MonoidalCategoryStruct.tensorUnit n).app X) (CategoryTheory.CategoryStruct.comp ((F.map (CategoryTheory.MonoidalCategoryStruct.leftUnitor n).hom).app X) h))) h","decl":"@[reassoc]\ntheorem left_unitality_app (n : M) (X : C) [F.LaxMonoidal]:\n    (F.obj n).map ((Œµ F).app X) ‚â´ (Œº F (ùüô_ M) n).app X ‚â´ (F.map (Œª_ n).hom).app X = ùüô _ :=\n  congr_app (left_unitality F n).symm X\n\n"}
{"name":"CategoryTheory.left_unitality_app","module":"Mathlib.CategoryTheory.Monoidal.End","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nM : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} M\ninst‚úù¬π : CategoryTheory.MonoidalCategory M\nF : CategoryTheory.Functor M (CategoryTheory.Functor C C)\nn : M\nX : C\ninst‚úù : F.LaxMonoidal\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((F.obj n).map ((CategoryTheory.Functor.LaxMonoidal.Œµ F).app X)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Functor.LaxMonoidal.Œº F CategoryTheory.MonoidalCategoryStruct.tensorUnit n).app X) ((F.map (CategoryTheory.MonoidalCategoryStruct.leftUnitor n).hom).app X))) (CategoryTheory.CategoryStruct.id ((F.obj n).obj (CategoryTheory.MonoidalCategoryStruct.tensorUnit.obj X)))","decl":"@[reassoc]\ntheorem left_unitality_app (n : M) (X : C) [F.LaxMonoidal]:\n    (F.obj n).map ((Œµ F).app X) ‚â´ (Œº F (ùüô_ M) n).app X ‚â´ (F.map (Œª_ n).hom).app X = ùüô _ :=\n  congr_app (left_unitality F n).symm X\n\n"}
{"name":"CategoryTheory.obj_Œµ_app_assoc","module":"Mathlib.CategoryTheory.Monoidal.End","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nM : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} M\ninst‚úù¬π : CategoryTheory.MonoidalCategory M\nF : CategoryTheory.Functor M (CategoryTheory.Functor C C)\nn : M\nX : C\ninst‚úù : F.Monoidal\nZ : C\nh : Quiver.Hom ((F.obj n).obj ((F.obj CategoryTheory.MonoidalCategoryStruct.tensorUnit).obj X)) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((F.obj n).map ((CategoryTheory.Functor.LaxMonoidal.Œµ F).app X)) h) (CategoryTheory.CategoryStruct.comp ((F.map (CategoryTheory.MonoidalCategoryStruct.leftUnitor n).inv).app X) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Functor.OplaxMonoidal.Œ¥ F CategoryTheory.MonoidalCategoryStruct.tensorUnit n).app X) h))","decl":"@[simp, reassoc]\ntheorem obj_Œµ_app (n : M) (X : C) [F.Monoidal]:\n    (F.obj n).map ((Œµ F).app X) = (F.map (Œª_ n).inv).app X ‚â´ (Œ¥ F (ùüô_ M) n).app X := by\n  rw [map_leftUnitor_inv]\n  dsimp\n  simp only [Category.id_comp, Category.assoc, Œº_Œ¥_app, endofunctorMonoidalCategory_tensorObj_obj,\n    Category.comp_id]\n\n"}
{"name":"CategoryTheory.obj_Œµ_app","module":"Mathlib.CategoryTheory.Monoidal.End","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nM : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} M\ninst‚úù¬π : CategoryTheory.MonoidalCategory M\nF : CategoryTheory.Functor M (CategoryTheory.Functor C C)\nn : M\nX : C\ninst‚úù : F.Monoidal\n‚ä¢ Eq ((F.obj n).map ((CategoryTheory.Functor.LaxMonoidal.Œµ F).app X)) (CategoryTheory.CategoryStruct.comp ((F.map (CategoryTheory.MonoidalCategoryStruct.leftUnitor n).inv).app X) ((CategoryTheory.Functor.OplaxMonoidal.Œ¥ F CategoryTheory.MonoidalCategoryStruct.tensorUnit n).app X))","decl":"@[simp, reassoc]\ntheorem obj_Œµ_app (n : M) (X : C) [F.Monoidal]:\n    (F.obj n).map ((Œµ F).app X) = (F.map (Œª_ n).inv).app X ‚â´ (Œ¥ F (ùüô_ M) n).app X := by\n  rw [map_leftUnitor_inv]\n  dsimp\n  simp only [Category.id_comp, Category.assoc, Œº_Œ¥_app, endofunctorMonoidalCategory_tensorObj_obj,\n    Category.comp_id]\n\n"}
{"name":"CategoryTheory.obj_Œ∑_app_assoc","module":"Mathlib.CategoryTheory.Monoidal.End","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nM : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} M\ninst‚úù¬π : CategoryTheory.MonoidalCategory M\nF : CategoryTheory.Functor M (CategoryTheory.Functor C C)\nn : M\nX : C\ninst‚úù : F.Monoidal\nZ : C\nh : Quiver.Hom ((F.obj n).obj (CategoryTheory.MonoidalCategoryStruct.tensorUnit.obj X)) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((F.obj n).map ((CategoryTheory.Functor.OplaxMonoidal.Œ∑ F).app X)) h) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Functor.LaxMonoidal.Œº F CategoryTheory.MonoidalCategoryStruct.tensorUnit n).app X) (CategoryTheory.CategoryStruct.comp ((F.map (CategoryTheory.MonoidalCategoryStruct.leftUnitor n).hom).app X) h))","decl":"@[simp, reassoc]\ntheorem obj_Œ∑_app (n : M) (X : C) [F.Monoidal] :\n    (F.obj n).map ((Œ∑ F).app X) = (Œº F (ùüô_ M) n).app X ‚â´ (F.map (Œª_ n).hom).app X := by\n  rw [‚Üê cancel_mono ((F.obj n).map ((Œµ F).app X)), ‚Üê Functor.map_comp]\n  simp\n\n"}
{"name":"CategoryTheory.obj_Œ∑_app","module":"Mathlib.CategoryTheory.Monoidal.End","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nM : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} M\ninst‚úù¬π : CategoryTheory.MonoidalCategory M\nF : CategoryTheory.Functor M (CategoryTheory.Functor C C)\nn : M\nX : C\ninst‚úù : F.Monoidal\n‚ä¢ Eq ((F.obj n).map ((CategoryTheory.Functor.OplaxMonoidal.Œ∑ F).app X)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Functor.LaxMonoidal.Œº F CategoryTheory.MonoidalCategoryStruct.tensorUnit n).app X) ((F.map (CategoryTheory.MonoidalCategoryStruct.leftUnitor n).hom).app X))","decl":"@[simp, reassoc]\ntheorem obj_Œ∑_app (n : M) (X : C) [F.Monoidal] :\n    (F.obj n).map ((Œ∑ F).app X) = (Œº F (ùüô_ M) n).app X ‚â´ (F.map (Œª_ n).hom).app X := by\n  rw [‚Üê cancel_mono ((F.obj n).map ((Œµ F).app X)), ‚Üê Functor.map_comp]\n  simp\n\n"}
{"name":"CategoryTheory.right_unitality_app_assoc","module":"Mathlib.CategoryTheory.Monoidal.End","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nM : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} M\ninst‚úù¬π : CategoryTheory.MonoidalCategory M\nF : CategoryTheory.Functor M (CategoryTheory.Functor C C)\nn : M\nX : C\ninst‚úù : F.Monoidal\nZ : C\nh : Quiver.Hom ((F.obj n).obj X) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Functor.LaxMonoidal.Œµ F).app ((F.obj n).obj X)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Functor.LaxMonoidal.Œº F n CategoryTheory.MonoidalCategoryStruct.tensorUnit).app X) (CategoryTheory.CategoryStruct.comp ((F.map (CategoryTheory.MonoidalCategoryStruct.rightUnitor n).hom).app X) h))) h","decl":"@[reassoc]\ntheorem right_unitality_app (n : M) (X : C) [F.Monoidal] :\n    (Œµ F).app ((F.obj n).obj X) ‚â´ (Œº F n (ùüô_ M)).app X ‚â´ (F.map (œÅ_ n).hom).app X = ùüô _ :=\n  congr_app (Functor.LaxMonoidal.right_unitality F n).symm X\n\n"}
{"name":"CategoryTheory.right_unitality_app","module":"Mathlib.CategoryTheory.Monoidal.End","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nM : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} M\ninst‚úù¬π : CategoryTheory.MonoidalCategory M\nF : CategoryTheory.Functor M (CategoryTheory.Functor C C)\nn : M\nX : C\ninst‚úù : F.Monoidal\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Functor.LaxMonoidal.Œµ F).app ((F.obj n).obj X)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Functor.LaxMonoidal.Œº F n CategoryTheory.MonoidalCategoryStruct.tensorUnit).app X) ((F.map (CategoryTheory.MonoidalCategoryStruct.rightUnitor n).hom).app X))) (CategoryTheory.CategoryStruct.id (CategoryTheory.MonoidalCategoryStruct.tensorUnit.obj ((F.obj n).obj X)))","decl":"@[reassoc]\ntheorem right_unitality_app (n : M) (X : C) [F.Monoidal] :\n    (Œµ F).app ((F.obj n).obj X) ‚â´ (Œº F n (ùüô_ M)).app X ‚â´ (F.map (œÅ_ n).hom).app X = ùüô _ :=\n  congr_app (Functor.LaxMonoidal.right_unitality F n).symm X\n\n"}
{"name":"CategoryTheory.Œµ_app_obj","module":"Mathlib.CategoryTheory.Monoidal.End","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nM : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} M\ninst‚úù¬π : CategoryTheory.MonoidalCategory M\nF : CategoryTheory.Functor M (CategoryTheory.Functor C C)\nn : M\nX : C\ninst‚úù : F.Monoidal\n‚ä¢ Eq ((CategoryTheory.Functor.LaxMonoidal.Œµ F).app ((F.obj n).obj X)) (CategoryTheory.CategoryStruct.comp ((F.map (CategoryTheory.MonoidalCategoryStruct.rightUnitor n).inv).app X) ((CategoryTheory.Functor.OplaxMonoidal.Œ¥ F n CategoryTheory.MonoidalCategoryStruct.tensorUnit).app X))","decl":"@[simp]\ntheorem Œµ_app_obj (n : M) (X : C) [F.Monoidal] :\n    (Œµ F).app ((F.obj n).obj X) = (F.map (œÅ_ n).inv).app X ‚â´ (Œ¥ F n (ùüô_ M)).app X := by\n  rw [map_rightUnitor_inv]\n  dsimp\n  simp only [Category.id_comp, Category.assoc, Œº_Œ¥_app,\n    endofunctorMonoidalCategory_tensorObj_obj, Category.comp_id]\n\n"}
{"name":"CategoryTheory.Œ∑_app_obj","module":"Mathlib.CategoryTheory.Monoidal.End","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nM : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} M\ninst‚úù¬π : CategoryTheory.MonoidalCategory M\nF : CategoryTheory.Functor M (CategoryTheory.Functor C C)\nn : M\nX : C\ninst‚úù : F.Monoidal\n‚ä¢ Eq ((CategoryTheory.Functor.OplaxMonoidal.Œ∑ F).app ((F.obj n).obj X)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Functor.LaxMonoidal.Œº F n CategoryTheory.MonoidalCategoryStruct.tensorUnit).app X) ((F.map (CategoryTheory.MonoidalCategoryStruct.rightUnitor n).hom).app X))","decl":"@[simp]\ntheorem Œ∑_app_obj (n : M) (X : C) [F.Monoidal] :\n    (Œ∑ F).app ((F.obj n).obj X) = (Œº F n (ùüô_ M)).app X ‚â´ (F.map (œÅ_ n).hom).app X := by\n  rw [map_rightUnitor]\n  dsimp\n  simp only [Category.comp_id, Œº_Œ¥_app_assoc]\n\n"}
{"name":"CategoryTheory.associativity_app_assoc","module":"Mathlib.CategoryTheory.Monoidal.End","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nM : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} M\ninst‚úù¬π : CategoryTheory.MonoidalCategory M\nF : CategoryTheory.Functor M (CategoryTheory.Functor C C)\nm‚ÇÅ m‚ÇÇ m‚ÇÉ : M\nX : C\ninst‚úù : F.LaxMonoidal\nZ : C\nh : Quiver.Hom ((F.obj (CategoryTheory.MonoidalCategoryStruct.tensorObj m‚ÇÅ (CategoryTheory.MonoidalCategoryStruct.tensorObj m‚ÇÇ m‚ÇÉ))).obj X) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((F.obj m‚ÇÉ).map ((CategoryTheory.Functor.LaxMonoidal.Œº F m‚ÇÅ m‚ÇÇ).app X)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Functor.LaxMonoidal.Œº F (CategoryTheory.MonoidalCategoryStruct.tensorObj m‚ÇÅ m‚ÇÇ) m‚ÇÉ).app X) (CategoryTheory.CategoryStruct.comp ((F.map (CategoryTheory.MonoidalCategoryStruct.associator m‚ÇÅ m‚ÇÇ m‚ÇÉ).hom).app X) h))) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Functor.LaxMonoidal.Œº F m‚ÇÇ m‚ÇÉ).app ((F.obj m‚ÇÅ).obj X)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Functor.LaxMonoidal.Œº F m‚ÇÅ (CategoryTheory.MonoidalCategoryStruct.tensorObj m‚ÇÇ m‚ÇÉ)).app X) h))","decl":"@[reassoc]\ntheorem associativity_app (m‚ÇÅ m‚ÇÇ m‚ÇÉ : M) (X : C) [F.LaxMonoidal] :\n    (F.obj m‚ÇÉ).map ((Œº F m‚ÇÅ m‚ÇÇ).app X) ‚â´\n        (Œº F (m‚ÇÅ ‚äó m‚ÇÇ) m‚ÇÉ).app X ‚â´ (F.map (Œ±_ m‚ÇÅ m‚ÇÇ m‚ÇÉ).hom).app X =\n      (Œº F m‚ÇÇ m‚ÇÉ).app ((F.obj m‚ÇÅ).obj X) ‚â´ (Œº F m‚ÇÅ (m‚ÇÇ ‚äó m‚ÇÉ)).app X := by\n  have := congr_app (associativity F m‚ÇÅ m‚ÇÇ m‚ÇÉ) X\n  dsimp at this\n  simpa using this\n\n"}
{"name":"CategoryTheory.associativity_app","module":"Mathlib.CategoryTheory.Monoidal.End","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nM : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} M\ninst‚úù¬π : CategoryTheory.MonoidalCategory M\nF : CategoryTheory.Functor M (CategoryTheory.Functor C C)\nm‚ÇÅ m‚ÇÇ m‚ÇÉ : M\nX : C\ninst‚úù : F.LaxMonoidal\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((F.obj m‚ÇÉ).map ((CategoryTheory.Functor.LaxMonoidal.Œº F m‚ÇÅ m‚ÇÇ).app X)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Functor.LaxMonoidal.Œº F (CategoryTheory.MonoidalCategoryStruct.tensorObj m‚ÇÅ m‚ÇÇ) m‚ÇÉ).app X) ((F.map (CategoryTheory.MonoidalCategoryStruct.associator m‚ÇÅ m‚ÇÇ m‚ÇÉ).hom).app X))) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Functor.LaxMonoidal.Œº F m‚ÇÇ m‚ÇÉ).app ((F.obj m‚ÇÅ).obj X)) ((CategoryTheory.Functor.LaxMonoidal.Œº F m‚ÇÅ (CategoryTheory.MonoidalCategoryStruct.tensorObj m‚ÇÇ m‚ÇÉ)).app X))","decl":"@[reassoc]\ntheorem associativity_app (m‚ÇÅ m‚ÇÇ m‚ÇÉ : M) (X : C) [F.LaxMonoidal] :\n    (F.obj m‚ÇÉ).map ((Œº F m‚ÇÅ m‚ÇÇ).app X) ‚â´\n        (Œº F (m‚ÇÅ ‚äó m‚ÇÇ) m‚ÇÉ).app X ‚â´ (F.map (Œ±_ m‚ÇÅ m‚ÇÇ m‚ÇÉ).hom).app X =\n      (Œº F m‚ÇÇ m‚ÇÉ).app ((F.obj m‚ÇÅ).obj X) ‚â´ (Œº F m‚ÇÅ (m‚ÇÇ ‚äó m‚ÇÉ)).app X := by\n  have := congr_app (associativity F m‚ÇÅ m‚ÇÇ m‚ÇÉ) X\n  dsimp at this\n  simpa using this\n\n"}
{"name":"CategoryTheory.obj_Œº_app_assoc","module":"Mathlib.CategoryTheory.Monoidal.End","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nM : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} M\ninst‚úù¬π : CategoryTheory.MonoidalCategory M\nF : CategoryTheory.Functor M (CategoryTheory.Functor C C)\nm‚ÇÅ m‚ÇÇ m‚ÇÉ : M\nX : C\ninst‚úù : F.Monoidal\nZ : C\nh : Quiver.Hom ((F.obj m‚ÇÉ).obj ((F.obj (CategoryTheory.MonoidalCategoryStruct.tensorObj m‚ÇÅ m‚ÇÇ)).obj X)) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((F.obj m‚ÇÉ).map ((CategoryTheory.Functor.LaxMonoidal.Œº F m‚ÇÅ m‚ÇÇ).app X)) h) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Functor.LaxMonoidal.Œº F m‚ÇÇ m‚ÇÉ).app ((F.obj m‚ÇÅ).obj X)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Functor.LaxMonoidal.Œº F m‚ÇÅ (CategoryTheory.MonoidalCategoryStruct.tensorObj m‚ÇÇ m‚ÇÉ)).app X) (CategoryTheory.CategoryStruct.comp ((F.map (CategoryTheory.MonoidalCategoryStruct.associator m‚ÇÅ m‚ÇÇ m‚ÇÉ).inv).app X) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Functor.OplaxMonoidal.Œ¥ F (CategoryTheory.MonoidalCategoryStruct.tensorObj m‚ÇÅ m‚ÇÇ) m‚ÇÉ).app X) h))))","decl":"@[simp, reassoc]\ntheorem obj_Œº_app (m‚ÇÅ m‚ÇÇ m‚ÇÉ : M) (X : C) [F.Monoidal] :\n    (F.obj m‚ÇÉ).map ((Œº F m‚ÇÅ m‚ÇÇ).app X) =\n      (Œº F m‚ÇÇ m‚ÇÉ).app ((F.obj m‚ÇÅ).obj X) ‚â´\n        (Œº F m‚ÇÅ (m‚ÇÇ ‚äó m‚ÇÉ)).app X ‚â´\n          (F.map (Œ±_ m‚ÇÅ m‚ÇÇ m‚ÇÉ).inv).app X ‚â´ (Œ¥ F (m‚ÇÅ ‚äó m‚ÇÇ) m‚ÇÉ).app X := by\n  rw [‚Üê associativity_app_assoc]\n  simp\n\n"}
{"name":"CategoryTheory.obj_Œº_app","module":"Mathlib.CategoryTheory.Monoidal.End","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nM : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} M\ninst‚úù¬π : CategoryTheory.MonoidalCategory M\nF : CategoryTheory.Functor M (CategoryTheory.Functor C C)\nm‚ÇÅ m‚ÇÇ m‚ÇÉ : M\nX : C\ninst‚úù : F.Monoidal\n‚ä¢ Eq ((F.obj m‚ÇÉ).map ((CategoryTheory.Functor.LaxMonoidal.Œº F m‚ÇÅ m‚ÇÇ).app X)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Functor.LaxMonoidal.Œº F m‚ÇÇ m‚ÇÉ).app ((F.obj m‚ÇÅ).obj X)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Functor.LaxMonoidal.Œº F m‚ÇÅ (CategoryTheory.MonoidalCategoryStruct.tensorObj m‚ÇÇ m‚ÇÉ)).app X) (CategoryTheory.CategoryStruct.comp ((F.map (CategoryTheory.MonoidalCategoryStruct.associator m‚ÇÅ m‚ÇÇ m‚ÇÉ).inv).app X) ((CategoryTheory.Functor.OplaxMonoidal.Œ¥ F (CategoryTheory.MonoidalCategoryStruct.tensorObj m‚ÇÅ m‚ÇÇ) m‚ÇÉ).app X))))","decl":"@[simp, reassoc]\ntheorem obj_Œº_app (m‚ÇÅ m‚ÇÇ m‚ÇÉ : M) (X : C) [F.Monoidal] :\n    (F.obj m‚ÇÉ).map ((Œº F m‚ÇÅ m‚ÇÇ).app X) =\n      (Œº F m‚ÇÇ m‚ÇÉ).app ((F.obj m‚ÇÅ).obj X) ‚â´\n        (Œº F m‚ÇÅ (m‚ÇÇ ‚äó m‚ÇÉ)).app X ‚â´\n          (F.map (Œ±_ m‚ÇÅ m‚ÇÇ m‚ÇÉ).inv).app X ‚â´ (Œ¥ F (m‚ÇÅ ‚äó m‚ÇÇ) m‚ÇÉ).app X := by\n  rw [‚Üê associativity_app_assoc]\n  simp\n\n"}
{"name":"CategoryTheory.obj_Œº_inv_app","module":"Mathlib.CategoryTheory.Monoidal.End","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nM : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} M\ninst‚úù¬π : CategoryTheory.MonoidalCategory M\nF : CategoryTheory.Functor M (CategoryTheory.Functor C C)\nm‚ÇÅ m‚ÇÇ m‚ÇÉ : M\nX : C\ninst‚úù : F.Monoidal\n‚ä¢ Eq ((F.obj m‚ÇÉ).map ((CategoryTheory.Functor.OplaxMonoidal.Œ¥ F m‚ÇÅ m‚ÇÇ).app X)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Functor.LaxMonoidal.Œº F (CategoryTheory.MonoidalCategoryStruct.tensorObj m‚ÇÅ m‚ÇÇ) m‚ÇÉ).app X) (CategoryTheory.CategoryStruct.comp ((F.map (CategoryTheory.MonoidalCategoryStruct.associator m‚ÇÅ m‚ÇÇ m‚ÇÉ).hom).app X) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Functor.OplaxMonoidal.Œ¥ F m‚ÇÅ (CategoryTheory.MonoidalCategoryStruct.tensorObj m‚ÇÇ m‚ÇÉ)).app X) ((CategoryTheory.Functor.OplaxMonoidal.Œ¥ F m‚ÇÇ m‚ÇÉ).app ((F.obj m‚ÇÅ).obj X)))))","decl":"@[simp, reassoc]\ntheorem obj_Œº_inv_app (m‚ÇÅ m‚ÇÇ m‚ÇÉ : M) (X : C) [F.Monoidal] :\n    (F.obj m‚ÇÉ).map ((Œ¥ F m‚ÇÅ m‚ÇÇ).app X) =\n      (Œº F (m‚ÇÅ ‚äó m‚ÇÇ) m‚ÇÉ).app X ‚â´\n        (F.map (Œ±_ m‚ÇÅ m‚ÇÇ m‚ÇÉ).hom).app X ‚â´\n          (Œ¥ F m‚ÇÅ (m‚ÇÇ ‚äó m‚ÇÉ)).app X ‚â´ (Œ¥ F m‚ÇÇ m‚ÇÉ).app ((F.obj m‚ÇÅ).obj X) := by\n  rw [map_associator]\n  dsimp\n  simp only [Category.id_comp, Category.assoc, Œº_Œ¥_app_assoc, Œº_Œ¥_app,\n    endofunctorMonoidalCategory_tensorObj_obj, Category.comp_id]\n\n"}
{"name":"CategoryTheory.obj_Œº_inv_app_assoc","module":"Mathlib.CategoryTheory.Monoidal.End","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nM : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} M\ninst‚úù¬π : CategoryTheory.MonoidalCategory M\nF : CategoryTheory.Functor M (CategoryTheory.Functor C C)\nm‚ÇÅ m‚ÇÇ m‚ÇÉ : M\nX : C\ninst‚úù : F.Monoidal\nZ : C\nh : Quiver.Hom ((F.obj m‚ÇÉ).obj ((CategoryTheory.MonoidalCategoryStruct.tensorObj (F.obj m‚ÇÅ) (F.obj m‚ÇÇ)).obj X)) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((F.obj m‚ÇÉ).map ((CategoryTheory.Functor.OplaxMonoidal.Œ¥ F m‚ÇÅ m‚ÇÇ).app X)) h) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Functor.LaxMonoidal.Œº F (CategoryTheory.MonoidalCategoryStruct.tensorObj m‚ÇÅ m‚ÇÇ) m‚ÇÉ).app X) (CategoryTheory.CategoryStruct.comp ((F.map (CategoryTheory.MonoidalCategoryStruct.associator m‚ÇÅ m‚ÇÇ m‚ÇÉ).hom).app X) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Functor.OplaxMonoidal.Œ¥ F m‚ÇÅ (CategoryTheory.MonoidalCategoryStruct.tensorObj m‚ÇÇ m‚ÇÉ)).app X) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Functor.OplaxMonoidal.Œ¥ F m‚ÇÇ m‚ÇÉ).app ((F.obj m‚ÇÅ).obj X)) h))))","decl":"@[simp, reassoc]\ntheorem obj_Œº_inv_app (m‚ÇÅ m‚ÇÇ m‚ÇÉ : M) (X : C) [F.Monoidal] :\n    (F.obj m‚ÇÉ).map ((Œ¥ F m‚ÇÅ m‚ÇÇ).app X) =\n      (Œº F (m‚ÇÅ ‚äó m‚ÇÇ) m‚ÇÉ).app X ‚â´\n        (F.map (Œ±_ m‚ÇÅ m‚ÇÇ m‚ÇÉ).hom).app X ‚â´\n          (Œ¥ F m‚ÇÅ (m‚ÇÇ ‚äó m‚ÇÉ)).app X ‚â´ (Œ¥ F m‚ÇÇ m‚ÇÉ).app ((F.obj m‚ÇÅ).obj X) := by\n  rw [map_associator]\n  dsimp\n  simp only [Category.id_comp, Category.assoc, Œº_Œ¥_app_assoc, Œº_Œ¥_app,\n    endofunctorMonoidalCategory_tensorObj_obj, Category.comp_id]\n\n"}
{"name":"CategoryTheory.obj_zero_map_Œº_app_assoc","module":"Mathlib.CategoryTheory.Monoidal.End","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nM : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} M\ninst‚úù¬π : CategoryTheory.MonoidalCategory M\nF : CategoryTheory.Functor M (CategoryTheory.Functor C C)\nm : M\nX Y : C\nf : Quiver.Hom X ((F.obj m).obj Y)\ninst‚úù : F.Monoidal\nZ : C\nh : Quiver.Hom ((F.obj (CategoryTheory.MonoidalCategoryStruct.tensorObj m CategoryTheory.MonoidalCategoryStruct.tensorUnit)).obj Y) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((F.obj CategoryTheory.MonoidalCategoryStruct.tensorUnit).map f) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Functor.LaxMonoidal.Œº F m CategoryTheory.MonoidalCategoryStruct.tensorUnit).app Y) h)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Functor.OplaxMonoidal.Œ∑ F).app X) (CategoryTheory.CategoryStruct.comp f (CategoryTheory.CategoryStruct.comp ((F.map (CategoryTheory.MonoidalCategoryStruct.rightUnitor m).inv).app Y) h)))","decl":"@[reassoc (attr := simp)]\ntheorem obj_zero_map_Œº_app {m : M} {X Y : C} (f : X ‚ü∂ (F.obj m).obj Y) [F.Monoidal] :\n    (F.obj (ùüô_ M)).map f ‚â´ (Œº F m (ùüô_ M)).app _ =\n    (Œ∑ F).app _ ‚â´ f ‚â´ (F.map (œÅ_ m).inv).app _ := by\n  rw [‚Üê cancel_epi ((Œµ F).app _), ‚Üê cancel_mono ((Œ¥ F _ _).app _)]\n  simp\n\n"}
{"name":"CategoryTheory.obj_zero_map_Œº_app","module":"Mathlib.CategoryTheory.Monoidal.End","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nM : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} M\ninst‚úù¬π : CategoryTheory.MonoidalCategory M\nF : CategoryTheory.Functor M (CategoryTheory.Functor C C)\nm : M\nX Y : C\nf : Quiver.Hom X ((F.obj m).obj Y)\ninst‚úù : F.Monoidal\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((F.obj CategoryTheory.MonoidalCategoryStruct.tensorUnit).map f) ((CategoryTheory.Functor.LaxMonoidal.Œº F m CategoryTheory.MonoidalCategoryStruct.tensorUnit).app Y)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Functor.OplaxMonoidal.Œ∑ F).app X) (CategoryTheory.CategoryStruct.comp f ((F.map (CategoryTheory.MonoidalCategoryStruct.rightUnitor m).inv).app Y)))","decl":"@[reassoc (attr := simp)]\ntheorem obj_zero_map_Œº_app {m : M} {X Y : C} (f : X ‚ü∂ (F.obj m).obj Y) [F.Monoidal] :\n    (F.obj (ùüô_ M)).map f ‚â´ (Œº F m (ùüô_ M)).app _ =\n    (Œ∑ F).app _ ‚â´ f ‚â´ (F.map (œÅ_ m).inv).app _ := by\n  rw [‚Üê cancel_epi ((Œµ F).app _), ‚Üê cancel_mono ((Œ¥ F _ _).app _)]\n  simp\n\n"}
{"name":"CategoryTheory.obj_Œº_zero_app","module":"Mathlib.CategoryTheory.Monoidal.End","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nM : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} M\ninst‚úù¬π : CategoryTheory.MonoidalCategory M\nF : CategoryTheory.Functor M (CategoryTheory.Functor C C)\nm‚ÇÅ m‚ÇÇ : M\nX : C\ninst‚úù : F.Monoidal\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Functor.LaxMonoidal.Œº F CategoryTheory.MonoidalCategoryStruct.tensorUnit m‚ÇÇ).app ((F.obj m‚ÇÅ).obj X)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Functor.LaxMonoidal.Œº F m‚ÇÅ (CategoryTheory.MonoidalCategoryStruct.tensorObj CategoryTheory.MonoidalCategoryStruct.tensorUnit m‚ÇÇ)).app X) (CategoryTheory.CategoryStruct.comp ((F.map (CategoryTheory.MonoidalCategoryStruct.associator m‚ÇÅ CategoryTheory.MonoidalCategoryStruct.tensorUnit m‚ÇÇ).inv).app X) ((CategoryTheory.Functor.OplaxMonoidal.Œ¥ F (CategoryTheory.MonoidalCategoryStruct.tensorObj m‚ÇÅ CategoryTheory.MonoidalCategoryStruct.tensorUnit) m‚ÇÇ).app X)))) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Functor.LaxMonoidal.Œº F CategoryTheory.MonoidalCategoryStruct.tensorUnit m‚ÇÇ).app ((F.obj m‚ÇÅ).obj X)) (CategoryTheory.CategoryStruct.comp ((F.map (CategoryTheory.MonoidalCategoryStruct.leftUnitor m‚ÇÇ).hom).app ((F.obj m‚ÇÅ).obj X)) ((F.obj m‚ÇÇ).map ((F.map (CategoryTheory.MonoidalCategoryStruct.rightUnitor m‚ÇÅ).inv).app X))))","decl":"@[simp]\ntheorem obj_Œº_zero_app (m‚ÇÅ m‚ÇÇ : M) (X : C) [F.Monoidal]:\n    (Œº F (ùüô_ M) m‚ÇÇ).app ((F.obj m‚ÇÅ).obj X) ‚â´ (Œº F m‚ÇÅ (ùüô_ M ‚äó m‚ÇÇ)).app X ‚â´\n    (F.map (Œ±_ m‚ÇÅ (ùüô_ M) m‚ÇÇ).inv).app X ‚â´ (Œ¥ F (m‚ÇÅ ‚äó ùüô_ M) m‚ÇÇ).app X =\n    (Œº F (ùüô_ M) m‚ÇÇ).app ((F.obj m‚ÇÅ).obj X) ‚â´\n    (F.map (Œª_ m‚ÇÇ).hom).app ((F.obj m‚ÇÅ).obj X) ‚â´ (F.obj m‚ÇÇ).map ((F.map (œÅ_ m‚ÇÅ).inv).app X) := by\n  rw [‚Üê obj_Œ∑_app_assoc, ‚Üê Functor.map_comp]\n  simp\n\n"}
{"name":"CategoryTheory.unitOfTensorIsoUnit_hom_app","module":"Mathlib.CategoryTheory.Monoidal.End","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nM : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} M\ninst‚úù¬π : CategoryTheory.MonoidalCategory M\nF : CategoryTheory.Functor M (CategoryTheory.Functor C C)\nm n : M\nh : CategoryTheory.Iso (CategoryTheory.MonoidalCategoryStruct.tensorObj m n) CategoryTheory.MonoidalCategoryStruct.tensorUnit\ninst‚úù : F.Monoidal\nX : C\n‚ä¢ Eq ((CategoryTheory.unitOfTensorIsoUnit F m n h).hom.app X) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Functor.LaxMonoidal.Œº F m n).app X) (CategoryTheory.CategoryStruct.comp ((F.map h.hom).app X) ((CategoryTheory.Functor.OplaxMonoidal.Œ∑ F).app X)))","decl":"/-- If `m ‚äó n ‚âÖ ùüô_M`, then `F.obj m` is a left inverse of `F.obj n`. -/\n@[simps!]\nnoncomputable def unitOfTensorIsoUnit (m n : M) (h : m ‚äó n ‚âÖ ùüô_ M) [F.Monoidal] :\n    F.obj m ‚ãô F.obj n ‚âÖ ùü≠ C :=\n  ŒºIso F m n ‚â™‚â´ F.mapIso h ‚â™‚â´ (ŒµIso F).symm\n\n"}
{"name":"CategoryTheory.unitOfTensorIsoUnit_inv_app","module":"Mathlib.CategoryTheory.Monoidal.End","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nM : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} M\ninst‚úù¬π : CategoryTheory.MonoidalCategory M\nF : CategoryTheory.Functor M (CategoryTheory.Functor C C)\nm n : M\nh : CategoryTheory.Iso (CategoryTheory.MonoidalCategoryStruct.tensorObj m n) CategoryTheory.MonoidalCategoryStruct.tensorUnit\ninst‚úù : F.Monoidal\nX : C\n‚ä¢ Eq ((CategoryTheory.unitOfTensorIsoUnit F m n h).inv.app X) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Functor.LaxMonoidal.Œµ F).app X) (CategoryTheory.CategoryStruct.comp ((F.map h.inv).app X) ((CategoryTheory.Functor.OplaxMonoidal.Œ¥ F m n).app X)))","decl":"/-- If `m ‚äó n ‚âÖ ùüô_M`, then `F.obj m` is a left inverse of `F.obj n`. -/\n@[simps!]\nnoncomputable def unitOfTensorIsoUnit (m n : M) (h : m ‚äó n ‚âÖ ùüô_ M) [F.Monoidal] :\n    F.obj m ‚ãô F.obj n ‚âÖ ùü≠ C :=\n  ŒºIso F m n ‚â™‚â´ F.mapIso h ‚â™‚â´ (ŒµIso F).symm\n\n"}
{"name":"CategoryTheory.equivOfTensorIsoUnit_functor","module":"Mathlib.CategoryTheory.Monoidal.End","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nM : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} M\ninst‚úù¬π : CategoryTheory.MonoidalCategory M\nF : CategoryTheory.Functor M (CategoryTheory.Functor C C)\nm n : M\nh‚ÇÅ : CategoryTheory.Iso (CategoryTheory.MonoidalCategoryStruct.tensorObj m n) CategoryTheory.MonoidalCategoryStruct.tensorUnit\nh‚ÇÇ : CategoryTheory.Iso (CategoryTheory.MonoidalCategoryStruct.tensorObj n m) CategoryTheory.MonoidalCategoryStruct.tensorUnit\nH : Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight h‚ÇÅ.hom m) (CategoryTheory.MonoidalCategoryStruct.leftUnitor m).hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator m n m).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft m h‚ÇÇ.hom) (CategoryTheory.MonoidalCategoryStruct.rightUnitor m).hom))\ninst‚úù : F.Monoidal\n‚ä¢ Eq (CategoryTheory.equivOfTensorIsoUnit F m n h‚ÇÅ h‚ÇÇ H).functor (F.obj m)","decl":"/-- If `m ‚äó n ‚âÖ ùüô_M` and `n ‚äó m ‚âÖ ùüô_M` (subject to some commuting constraints),\n  then `F.obj m` and `F.obj n` forms a self-equivalence of `C`. -/\n@[simps]\nnoncomputable def equivOfTensorIsoUnit (m n : M) (h‚ÇÅ : m ‚äó n ‚âÖ ùüô_ M) (h‚ÇÇ : n ‚äó m ‚âÖ ùüô_ M)\n    (H : h‚ÇÅ.hom ‚ñ∑ m ‚â´ (Œª_ m).hom = (Œ±_ m n m).hom ‚â´ m ‚óÅ h‚ÇÇ.hom ‚â´ (œÅ_ m).hom) [F.Monoidal] :\n    C ‚âå C where\n  functor := F.obj m\n  inverse := F.obj n\n  unitIso := (unitOfTensorIsoUnit F m n h‚ÇÅ).symm\n  counitIso := unitOfTensorIsoUnit F n m h‚ÇÇ\n  functor_unitIso_comp X := by\n    dsimp\n    simp only [Œº_naturality·µ£_assoc, Œº_naturality‚Çó_assoc, Œ∑_app_obj, Category.assoc,\n      obj_Œº_inv_app, Functor.map_comp, Œ¥_Œº_app_assoc, obj_Œµ_app,\n      unitOfTensorIsoUnit_inv_app]\n    simp only [‚Üê NatTrans.comp_app, ‚Üê F.map_comp, ‚Üê H, inv_hom_whiskerRight_assoc,\n      Iso.inv_hom_id, Functor.map_id, NatTrans.id_app]\n\n"}
{"name":"CategoryTheory.equivOfTensorIsoUnit_unitIso","module":"Mathlib.CategoryTheory.Monoidal.End","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nM : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} M\ninst‚úù¬π : CategoryTheory.MonoidalCategory M\nF : CategoryTheory.Functor M (CategoryTheory.Functor C C)\nm n : M\nh‚ÇÅ : CategoryTheory.Iso (CategoryTheory.MonoidalCategoryStruct.tensorObj m n) CategoryTheory.MonoidalCategoryStruct.tensorUnit\nh‚ÇÇ : CategoryTheory.Iso (CategoryTheory.MonoidalCategoryStruct.tensorObj n m) CategoryTheory.MonoidalCategoryStruct.tensorUnit\nH : Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight h‚ÇÅ.hom m) (CategoryTheory.MonoidalCategoryStruct.leftUnitor m).hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator m n m).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft m h‚ÇÇ.hom) (CategoryTheory.MonoidalCategoryStruct.rightUnitor m).hom))\ninst‚úù : F.Monoidal\n‚ä¢ Eq (CategoryTheory.equivOfTensorIsoUnit F m n h‚ÇÅ h‚ÇÇ H).unitIso (CategoryTheory.unitOfTensorIsoUnit F m n h‚ÇÅ).symm","decl":"/-- If `m ‚äó n ‚âÖ ùüô_M` and `n ‚äó m ‚âÖ ùüô_M` (subject to some commuting constraints),\n  then `F.obj m` and `F.obj n` forms a self-equivalence of `C`. -/\n@[simps]\nnoncomputable def equivOfTensorIsoUnit (m n : M) (h‚ÇÅ : m ‚äó n ‚âÖ ùüô_ M) (h‚ÇÇ : n ‚äó m ‚âÖ ùüô_ M)\n    (H : h‚ÇÅ.hom ‚ñ∑ m ‚â´ (Œª_ m).hom = (Œ±_ m n m).hom ‚â´ m ‚óÅ h‚ÇÇ.hom ‚â´ (œÅ_ m).hom) [F.Monoidal] :\n    C ‚âå C where\n  functor := F.obj m\n  inverse := F.obj n\n  unitIso := (unitOfTensorIsoUnit F m n h‚ÇÅ).symm\n  counitIso := unitOfTensorIsoUnit F n m h‚ÇÇ\n  functor_unitIso_comp X := by\n    dsimp\n    simp only [Œº_naturality·µ£_assoc, Œº_naturality‚Çó_assoc, Œ∑_app_obj, Category.assoc,\n      obj_Œº_inv_app, Functor.map_comp, Œ¥_Œº_app_assoc, obj_Œµ_app,\n      unitOfTensorIsoUnit_inv_app]\n    simp only [‚Üê NatTrans.comp_app, ‚Üê F.map_comp, ‚Üê H, inv_hom_whiskerRight_assoc,\n      Iso.inv_hom_id, Functor.map_id, NatTrans.id_app]\n\n"}
{"name":"CategoryTheory.equivOfTensorIsoUnit_inverse","module":"Mathlib.CategoryTheory.Monoidal.End","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nM : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} M\ninst‚úù¬π : CategoryTheory.MonoidalCategory M\nF : CategoryTheory.Functor M (CategoryTheory.Functor C C)\nm n : M\nh‚ÇÅ : CategoryTheory.Iso (CategoryTheory.MonoidalCategoryStruct.tensorObj m n) CategoryTheory.MonoidalCategoryStruct.tensorUnit\nh‚ÇÇ : CategoryTheory.Iso (CategoryTheory.MonoidalCategoryStruct.tensorObj n m) CategoryTheory.MonoidalCategoryStruct.tensorUnit\nH : Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight h‚ÇÅ.hom m) (CategoryTheory.MonoidalCategoryStruct.leftUnitor m).hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator m n m).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft m h‚ÇÇ.hom) (CategoryTheory.MonoidalCategoryStruct.rightUnitor m).hom))\ninst‚úù : F.Monoidal\n‚ä¢ Eq (CategoryTheory.equivOfTensorIsoUnit F m n h‚ÇÅ h‚ÇÇ H).inverse (F.obj n)","decl":"/-- If `m ‚äó n ‚âÖ ùüô_M` and `n ‚äó m ‚âÖ ùüô_M` (subject to some commuting constraints),\n  then `F.obj m` and `F.obj n` forms a self-equivalence of `C`. -/\n@[simps]\nnoncomputable def equivOfTensorIsoUnit (m n : M) (h‚ÇÅ : m ‚äó n ‚âÖ ùüô_ M) (h‚ÇÇ : n ‚äó m ‚âÖ ùüô_ M)\n    (H : h‚ÇÅ.hom ‚ñ∑ m ‚â´ (Œª_ m).hom = (Œ±_ m n m).hom ‚â´ m ‚óÅ h‚ÇÇ.hom ‚â´ (œÅ_ m).hom) [F.Monoidal] :\n    C ‚âå C where\n  functor := F.obj m\n  inverse := F.obj n\n  unitIso := (unitOfTensorIsoUnit F m n h‚ÇÅ).symm\n  counitIso := unitOfTensorIsoUnit F n m h‚ÇÇ\n  functor_unitIso_comp X := by\n    dsimp\n    simp only [Œº_naturality·µ£_assoc, Œº_naturality‚Çó_assoc, Œ∑_app_obj, Category.assoc,\n      obj_Œº_inv_app, Functor.map_comp, Œ¥_Œº_app_assoc, obj_Œµ_app,\n      unitOfTensorIsoUnit_inv_app]\n    simp only [‚Üê NatTrans.comp_app, ‚Üê F.map_comp, ‚Üê H, inv_hom_whiskerRight_assoc,\n      Iso.inv_hom_id, Functor.map_id, NatTrans.id_app]\n\n"}
{"name":"CategoryTheory.equivOfTensorIsoUnit_counitIso","module":"Mathlib.CategoryTheory.Monoidal.End","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nM : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} M\ninst‚úù¬π : CategoryTheory.MonoidalCategory M\nF : CategoryTheory.Functor M (CategoryTheory.Functor C C)\nm n : M\nh‚ÇÅ : CategoryTheory.Iso (CategoryTheory.MonoidalCategoryStruct.tensorObj m n) CategoryTheory.MonoidalCategoryStruct.tensorUnit\nh‚ÇÇ : CategoryTheory.Iso (CategoryTheory.MonoidalCategoryStruct.tensorObj n m) CategoryTheory.MonoidalCategoryStruct.tensorUnit\nH : Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight h‚ÇÅ.hom m) (CategoryTheory.MonoidalCategoryStruct.leftUnitor m).hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator m n m).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft m h‚ÇÇ.hom) (CategoryTheory.MonoidalCategoryStruct.rightUnitor m).hom))\ninst‚úù : F.Monoidal\n‚ä¢ Eq (CategoryTheory.equivOfTensorIsoUnit F m n h‚ÇÅ h‚ÇÇ H).counitIso (CategoryTheory.unitOfTensorIsoUnit F n m h‚ÇÇ)","decl":"/-- If `m ‚äó n ‚âÖ ùüô_M` and `n ‚äó m ‚âÖ ùüô_M` (subject to some commuting constraints),\n  then `F.obj m` and `F.obj n` forms a self-equivalence of `C`. -/\n@[simps]\nnoncomputable def equivOfTensorIsoUnit (m n : M) (h‚ÇÅ : m ‚äó n ‚âÖ ùüô_ M) (h‚ÇÇ : n ‚äó m ‚âÖ ùüô_ M)\n    (H : h‚ÇÅ.hom ‚ñ∑ m ‚â´ (Œª_ m).hom = (Œ±_ m n m).hom ‚â´ m ‚óÅ h‚ÇÇ.hom ‚â´ (œÅ_ m).hom) [F.Monoidal] :\n    C ‚âå C where\n  functor := F.obj m\n  inverse := F.obj n\n  unitIso := (unitOfTensorIsoUnit F m n h‚ÇÅ).symm\n  counitIso := unitOfTensorIsoUnit F n m h‚ÇÇ\n  functor_unitIso_comp X := by\n    dsimp\n    simp only [Œº_naturality·µ£_assoc, Œº_naturality‚Çó_assoc, Œ∑_app_obj, Category.assoc,\n      obj_Œº_inv_app, Functor.map_comp, Œ¥_Œº_app_assoc, obj_Œµ_app,\n      unitOfTensorIsoUnit_inv_app]\n    simp only [‚Üê NatTrans.comp_app, ‚Üê F.map_comp, ‚Üê H, inv_hom_whiskerRight_assoc,\n      Iso.inv_hom_id, Functor.map_id, NatTrans.id_app]\n\n"}
