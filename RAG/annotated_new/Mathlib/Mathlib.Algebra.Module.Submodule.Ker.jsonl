{"name":"LinearMap.mem_ker","module":"Mathlib.Algebra.Module.Submodule.Ker","initialProofState":"R : Type u_1\nR₂ : Type u_2\nM : Type u_5\nM₂ : Type u_7\ninst✝⁷ : Semiring R\ninst✝⁶ : Semiring R₂\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : AddCommMonoid M₂\ninst✝³ : Module R M\ninst✝² : Module R₂ M₂\nτ₁₂ : RingHom R R₂\nF : Type u_11\ninst✝¹ : FunLike F M M₂\ninst✝ : SemilinearMapClass F τ₁₂ M M₂\nf : F\ny : M\n⊢ Iff (Membership.mem (LinearMap.ker f) y) (Eq (f y) 0)","decl":"@[simp]\ntheorem mem_ker {f : F} {y} : y ∈ ker f ↔ f y = 0 :=\n  mem_bot R₂\n\n"}
{"name":"LinearMap.ker_id","module":"Mathlib.Algebra.Module.Submodule.Ker","initialProofState":"R : Type u_1\nM : Type u_5\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\n⊢ Eq (LinearMap.ker LinearMap.id) Bot.bot","decl":"@[simp]\ntheorem ker_id : ker (LinearMap.id : M →ₗ[R] M) = ⊥ :=\n  rfl\n\n"}
{"name":"LinearMap.map_coe_ker","module":"Mathlib.Algebra.Module.Submodule.Ker","initialProofState":"R : Type u_1\nR₂ : Type u_2\nM : Type u_5\nM₂ : Type u_7\ninst✝⁷ : Semiring R\ninst✝⁶ : Semiring R₂\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : AddCommMonoid M₂\ninst✝³ : Module R M\ninst✝² : Module R₂ M₂\nτ₁₂ : RingHom R R₂\nF : Type u_11\ninst✝¹ : FunLike F M M₂\ninst✝ : SemilinearMapClass F τ₁₂ M M₂\nf : F\nx : Subtype fun x => Membership.mem (LinearMap.ker f) x\n⊢ Eq (f ↑x) 0","decl":"@[simp]\ntheorem map_coe_ker (f : F) (x : ker f) : f x = 0 :=\n  mem_ker.1 x.2\n\n"}
{"name":"LinearMap.ker_toAddSubmonoid","module":"Mathlib.Algebra.Module.Submodule.Ker","initialProofState":"R : Type u_1\nR₂ : Type u_2\nM : Type u_5\nM₂ : Type u_7\ninst✝⁵ : Semiring R\ninst✝⁴ : Semiring R₂\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M₂\ninst✝¹ : Module R M\ninst✝ : Module R₂ M₂\nτ₁₂ : RingHom R R₂\nf : LinearMap τ₁₂ M M₂\n⊢ Eq (LinearMap.ker f).toAddSubmonoid (AddMonoidHom.mker f)","decl":"theorem ker_toAddSubmonoid (f : M →ₛₗ[τ₁₂] M₂) : f.ker.toAddSubmonoid = (AddMonoidHom.mker f) :=\n  rfl\n\n"}
{"name":"LinearMap.comp_ker_subtype","module":"Mathlib.Algebra.Module.Submodule.Ker","initialProofState":"R : Type u_1\nR₂ : Type u_2\nM : Type u_5\nM₂ : Type u_7\ninst✝⁵ : Semiring R\ninst✝⁴ : Semiring R₂\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M₂\ninst✝¹ : Module R M\ninst✝ : Module R₂ M₂\nτ₁₂ : RingHom R R₂\nf : LinearMap τ₁₂ M M₂\n⊢ Eq (f.comp (LinearMap.ker f).subtype) 0","decl":"theorem comp_ker_subtype (f : M →ₛₗ[τ₁₂] M₂) : f.comp f.ker.subtype = 0 :=\n  LinearMap.ext fun x => mem_ker.1 x.2\n\n"}
{"name":"LinearMap.ker_comp","module":"Mathlib.Algebra.Module.Submodule.Ker","initialProofState":"R : Type u_1\nR₂ : Type u_2\nR₃ : Type u_3\nM : Type u_5\nM₂ : Type u_7\nM₃ : Type u_8\ninst✝⁹ : Semiring R\ninst✝⁸ : Semiring R₂\ninst✝⁷ : Semiring R₃\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : AddCommMonoid M₂\ninst✝⁴ : AddCommMonoid M₃\ninst✝³ : Module R M\ninst✝² : Module R₂ M₂\ninst✝¹ : Module R₃ M₃\nτ₁₂ : RingHom R R₂\nτ₂₃ : RingHom R₂ R₃\nτ₁₃ : RingHom R R₃\ninst✝ : RingHomCompTriple τ₁₂ τ₂₃ τ₁₃\nf : LinearMap τ₁₂ M M₂\ng : LinearMap τ₂₃ M₂ M₃\n⊢ Eq (LinearMap.ker (g.comp f)) (Submodule.comap f (LinearMap.ker g))","decl":"theorem ker_comp (f : M →ₛₗ[τ₁₂] M₂) (g : M₂ →ₛₗ[τ₂₃] M₃) :\n    ker (g.comp f : M →ₛₗ[τ₁₃] M₃) = comap f (ker g) :=\n  rfl\n\n"}
{"name":"LinearMap.ker_le_ker_comp","module":"Mathlib.Algebra.Module.Submodule.Ker","initialProofState":"R : Type u_1\nR₂ : Type u_2\nR₃ : Type u_3\nM : Type u_5\nM₂ : Type u_7\nM₃ : Type u_8\ninst✝⁹ : Semiring R\ninst✝⁸ : Semiring R₂\ninst✝⁷ : Semiring R₃\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : AddCommMonoid M₂\ninst✝⁴ : AddCommMonoid M₃\ninst✝³ : Module R M\ninst✝² : Module R₂ M₂\ninst✝¹ : Module R₃ M₃\nτ₁₂ : RingHom R R₂\nτ₂₃ : RingHom R₂ R₃\nτ₁₃ : RingHom R R₃\ninst✝ : RingHomCompTriple τ₁₂ τ₂₃ τ₁₃\nf : LinearMap τ₁₂ M M₂\ng : LinearMap τ₂₃ M₂ M₃\n⊢ LE.le (LinearMap.ker f) (LinearMap.ker (g.comp f))","decl":"theorem ker_le_ker_comp (f : M →ₛₗ[τ₁₂] M₂) (g : M₂ →ₛₗ[τ₂₃] M₃) :\n    ker f ≤ ker (g.comp f : M →ₛₗ[τ₁₃] M₃) := by rw [ker_comp]; exact comap_mono bot_le\n\n"}
{"name":"LinearMap.ker_sup_ker_le_ker_comp_of_commute","module":"Mathlib.Algebra.Module.Submodule.Ker","initialProofState":"R : Type u_1\nM : Type u_5\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nf g : LinearMap (RingHom.id R) M M\nh : Commute f g\n⊢ LE.le (Max.max (LinearMap.ker f) (LinearMap.ker g)) (LinearMap.ker (f.comp g))","decl":"theorem ker_sup_ker_le_ker_comp_of_commute {f g : M →ₗ[R] M} (h : Commute f g) :\n    ker f ⊔ ker g ≤ ker (f ∘ₗ g) := by\n  refine sup_le_iff.mpr ⟨?_, ker_le_ker_comp g f⟩\n  rw [← mul_eq_comp, h.eq, mul_eq_comp]\n  exact ker_le_ker_comp f g\n\n"}
{"name":"LinearMap.ker_le_comap","module":"Mathlib.Algebra.Module.Submodule.Ker","initialProofState":"R : Type u_1\nR₂ : Type u_2\nM : Type u_5\nM₂ : Type u_7\ninst✝⁵ : Semiring R\ninst✝⁴ : Semiring R₂\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M₂\ninst✝¹ : Module R M\ninst✝ : Module R₂ M₂\nτ₁₂ : RingHom R R₂\np : Submodule R₂ M₂\nf : LinearMap τ₁₂ M M₂\n⊢ LE.le (LinearMap.ker f) (Submodule.comap f p)","decl":"@[simp]\ntheorem ker_le_comap {p : Submodule R₂ M₂} (f : M →ₛₗ[τ₁₂] M₂) :\n    ker f ≤ p.comap f :=\n  fun x hx ↦ by simp [mem_ker.mp hx]\n\n"}
{"name":"LinearMap.disjoint_ker","module":"Mathlib.Algebra.Module.Submodule.Ker","initialProofState":"R : Type u_1\nR₂ : Type u_2\nM : Type u_5\nM₂ : Type u_7\ninst✝⁷ : Semiring R\ninst✝⁶ : Semiring R₂\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : AddCommMonoid M₂\ninst✝³ : Module R M\ninst✝² : Module R₂ M₂\nτ₁₂ : RingHom R R₂\nF : Type u_11\ninst✝¹ : FunLike F M M₂\ninst✝ : SemilinearMapClass F τ₁₂ M M₂\nf : F\np : Submodule R M\n⊢ Iff (Disjoint p (LinearMap.ker f)) (∀ (x : M), Membership.mem p x → Eq (f x) 0 → Eq x 0)","decl":"theorem disjoint_ker {f : F} {p : Submodule R M} :\n    Disjoint p (ker f) ↔ ∀ x ∈ p, f x = 0 → x = 0 := by\n  simp [disjoint_def]\n\n"}
{"name":"LinearMap.ker_eq_bot'","module":"Mathlib.Algebra.Module.Submodule.Ker","initialProofState":"R : Type u_1\nR₂ : Type u_2\nM : Type u_5\nM₂ : Type u_7\ninst✝⁷ : Semiring R\ninst✝⁶ : Semiring R₂\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : AddCommMonoid M₂\ninst✝³ : Module R M\ninst✝² : Module R₂ M₂\nτ₁₂ : RingHom R R₂\nF : Type u_11\ninst✝¹ : FunLike F M M₂\ninst✝ : SemilinearMapClass F τ₁₂ M M₂\nf : F\n⊢ Iff (Eq (LinearMap.ker f) Bot.bot) (∀ (m : M), Eq (f m) 0 → Eq m 0)","decl":"theorem ker_eq_bot' {f : F} : ker f = ⊥ ↔ ∀ m, f m = 0 → m = 0 := by\n  simpa [disjoint_iff_inf_le] using disjoint_ker (f := f) (p := ⊤)\n\n"}
{"name":"LinearMap.ker_eq_bot_of_inverse","module":"Mathlib.Algebra.Module.Submodule.Ker","initialProofState":"R : Type u_1\nR₂ : Type u_2\nM : Type u_5\nM₂ : Type u_7\ninst✝⁶ : Semiring R\ninst✝⁵ : Semiring R₂\ninst✝⁴ : AddCommMonoid M\ninst✝³ : AddCommMonoid M₂\ninst✝² : Module R M\ninst✝¹ : Module R₂ M₂\nτ₁₂ : RingHom R R₂\nτ₂₁ : RingHom R₂ R\ninst✝ : RingHomInvPair τ₁₂ τ₂₁\nf : LinearMap τ₁₂ M M₂\ng : LinearMap τ₂₁ M₂ M\nh : Eq (g.comp f) LinearMap.id\n⊢ Eq (LinearMap.ker f) Bot.bot","decl":"theorem ker_eq_bot_of_inverse {τ₂₁ : R₂ →+* R} [RingHomInvPair τ₁₂ τ₂₁] {f : M →ₛₗ[τ₁₂] M₂}\n    {g : M₂ →ₛₗ[τ₂₁] M} (h : (g.comp f : M →ₗ[R] M) = id) : ker f = ⊥ :=\n  ker_eq_bot'.2 fun m hm => by rw [← id_apply (R := R) m, ← h, comp_apply, hm, g.map_zero]\n\n"}
{"name":"LinearMap.le_ker_iff_map","module":"Mathlib.Algebra.Module.Submodule.Ker","initialProofState":"R : Type u_1\nR₂ : Type u_2\nM : Type u_5\nM₂ : Type u_7\ninst✝⁸ : Semiring R\ninst✝⁷ : Semiring R₂\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : AddCommMonoid M₂\ninst✝⁴ : Module R M\ninst✝³ : Module R₂ M₂\nτ₁₂ : RingHom R R₂\nF : Type u_11\ninst✝² : FunLike F M M₂\ninst✝¹ : SemilinearMapClass F τ₁₂ M M₂\ninst✝ : RingHomSurjective τ₁₂\nf : F\np : Submodule R M\n⊢ Iff (LE.le p (LinearMap.ker f)) (Eq (Submodule.map f p) Bot.bot)","decl":"theorem le_ker_iff_map [RingHomSurjective τ₁₂] {f : F} {p : Submodule R M} :\n    p ≤ ker f ↔ map f p = ⊥ := by rw [ker, eq_bot_iff, map_le_iff_le_comap]\n\n"}
{"name":"LinearMap.ker_codRestrict","module":"Mathlib.Algebra.Module.Submodule.Ker","initialProofState":"R : Type u_1\nR₂ : Type u_2\nM : Type u_5\nM₂ : Type u_7\ninst✝⁵ : Semiring R\ninst✝⁴ : Semiring R₂\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M₂\ninst✝¹ : Module R M\ninst✝ : Module R₂ M₂\nτ₂₁ : RingHom R₂ R\np : Submodule R M\nf : LinearMap τ₂₁ M₂ M\nhf : ∀ (c : M₂), Membership.mem p (f c)\n⊢ Eq (LinearMap.ker (LinearMap.codRestrict p f hf)) (LinearMap.ker f)","decl":"theorem ker_codRestrict {τ₂₁ : R₂ →+* R} (p : Submodule R M) (f : M₂ →ₛₗ[τ₂₁] M) (hf) :\n    ker (codRestrict p f hf) = ker f := by rw [ker, comap_codRestrict, Submodule.map_bot]; rfl\n\n"}
{"name":"LinearMap.ker_domRestrict","module":"Mathlib.Algebra.Module.Submodule.Ker","initialProofState":"R : Type u_1\nM : Type u_5\nM₁ : Type u_6\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : AddCommMonoid M₁\ninst✝ : Module R M₁\np : Submodule R M\nf : LinearMap (RingHom.id R) M M₁\n⊢ Eq (LinearMap.ker (f.domRestrict p)) (Submodule.comap p.subtype (LinearMap.ker f))","decl":"lemma ker_domRestrict [AddCommMonoid M₁] [Module R M₁] (p : Submodule R M) (f : M →ₗ[R] M₁) :\n    ker (domRestrict f p) = (ker f).comap p.subtype := ker_comp ..\n\n"}
{"name":"LinearMap.ker_restrict","module":"Mathlib.Algebra.Module.Submodule.Ker","initialProofState":"R : Type u_1\nM : Type u_5\nM₁ : Type u_6\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : AddCommMonoid M₁\ninst✝ : Module R M₁\np : Submodule R M\nq : Submodule R M₁\nf : LinearMap (RingHom.id R) M M₁\nhf : ∀ (x : M), Membership.mem p x → Membership.mem q (f x)\n⊢ Eq (LinearMap.ker (f.restrict hf)) (Submodule.comap p.subtype (LinearMap.ker f))","decl":"theorem ker_restrict [AddCommMonoid M₁] [Module R M₁] {p : Submodule R M} {q : Submodule R M₁}\n    {f : M →ₗ[R] M₁} (hf : ∀ x : M, x ∈ p → f x ∈ q) :\n    ker (f.restrict hf) = (ker f).comap p.subtype := by\n  rw [restrict_eq_codRestrict_domRestrict, ker_codRestrict, ker_domRestrict]\n\n"}
{"name":"LinearMap.ker_zero","module":"Mathlib.Algebra.Module.Submodule.Ker","initialProofState":"R : Type u_1\nR₂ : Type u_2\nM : Type u_5\nM₂ : Type u_7\ninst✝⁵ : Semiring R\ninst✝⁴ : Semiring R₂\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M₂\ninst✝¹ : Module R M\ninst✝ : Module R₂ M₂\nτ₁₂ : RingHom R R₂\n⊢ Eq (LinearMap.ker 0) Top.top","decl":"@[simp]\ntheorem ker_zero : ker (0 : M →ₛₗ[τ₁₂] M₂) = ⊤ :=\n  eq_top_iff'.2 fun x => by simp\n\n"}
{"name":"LinearMap.ker_eq_top","module":"Mathlib.Algebra.Module.Submodule.Ker","initialProofState":"R : Type u_1\nR₂ : Type u_2\nM : Type u_5\nM₂ : Type u_7\ninst✝⁵ : Semiring R\ninst✝⁴ : Semiring R₂\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M₂\ninst✝¹ : Module R M\ninst✝ : Module R₂ M₂\nτ₁₂ : RingHom R R₂\nf : LinearMap τ₁₂ M M₂\n⊢ Iff (Eq (LinearMap.ker f) Top.top) (Eq f 0)","decl":"theorem ker_eq_top {f : M →ₛₗ[τ₁₂] M₂} : ker f = ⊤ ↔ f = 0 :=\n  ⟨fun h => ext fun _ => mem_ker.1 <| h.symm ▸ trivial, fun h => h.symm ▸ ker_zero⟩\n\n"}
{"name":"AddMonoidHom.coe_toIntLinearMap_ker","module":"Mathlib.Algebra.Module.Submodule.Ker","initialProofState":"M : Type u_12\nM₂ : Type u_13\ninst✝¹ : AddCommGroup M\ninst✝ : AddCommGroup M₂\nf : AddMonoidHom M M₂\n⊢ Eq (LinearMap.ker f.toIntLinearMap) (AddSubgroup.toIntSubmodule f.ker)","decl":"@[simp]\ntheorem _root_.AddMonoidHom.coe_toIntLinearMap_ker {M M₂ : Type*} [AddCommGroup M] [AddCommGroup M₂]\n    (f : M →+ M₂) : LinearMap.ker f.toIntLinearMap = AddSubgroup.toIntSubmodule f.ker := rfl\n\n"}
{"name":"LinearMap.ker_eq_bot_of_injective","module":"Mathlib.Algebra.Module.Submodule.Ker","initialProofState":"R : Type u_1\nR₂ : Type u_2\nM : Type u_5\nM₂ : Type u_7\ninst✝⁷ : Semiring R\ninst✝⁶ : Semiring R₂\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : AddCommMonoid M₂\ninst✝³ : Module R M\ninst✝² : Module R₂ M₂\nτ₁₂ : RingHom R R₂\nF : Type u_11\ninst✝¹ : FunLike F M M₂\ninst✝ : SemilinearMapClass F τ₁₂ M M₂\nf : F\nhf : Function.Injective ⇑f\n⊢ Eq (LinearMap.ker f) Bot.bot","decl":"theorem ker_eq_bot_of_injective {f : F} (hf : Injective f) : ker f = ⊥ := by\n  have : Disjoint ⊤ (ker f) := by\n    -- Porting note: `← map_zero f` should work here, but it needs to be directly applied to H.\n    rw [disjoint_ker]\n    intros _ _ H\n    rw [← map_zero f] at H\n    exact hf H\n  simpa [disjoint_iff_inf_le]\n\n"}
{"name":"LinearMap.iterateKer_coe","module":"Mathlib.Algebra.Module.Submodule.Ker","initialProofState":"R : Type u_1\nM : Type u_5\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nf : LinearMap (RingHom.id R) M M\nn : Nat\n⊢ Eq (f.iterateKer n) (LinearMap.ker (HPow.hPow f n))","decl":"/-- The increasing sequence of submodules consisting of the kernels of the iterates of a linear map.\n-/\n@[simps]\ndef iterateKer (f : M →ₗ[R] M) : ℕ →o Submodule R M where\n  toFun n := ker (f ^ n)\n  monotone' n m w x h := by\n    obtain ⟨c, rfl⟩ := Nat.exists_eq_add_of_le w\n    rw [LinearMap.mem_ker] at h\n    rw [LinearMap.mem_ker, add_comm, pow_add, LinearMap.mul_apply, h, LinearMap.map_zero]\n\n"}
{"name":"LinearMap.ker_toAddSubgroup","module":"Mathlib.Algebra.Module.Submodule.Ker","initialProofState":"R : Type u_1\nR₂ : Type u_2\nM : Type u_5\nM₂ : Type u_7\ninst✝⁵ : Ring R\ninst✝⁴ : Ring R₂\ninst✝³ : AddCommGroup M\ninst✝² : AddCommGroup M₂\ninst✝¹ : Module R M\ninst✝ : Module R₂ M₂\nτ₁₂ : RingHom R R₂\nf : LinearMap τ₁₂ M M₂\n⊢ Eq (LinearMap.ker f).toAddSubgroup f.toAddMonoidHom.ker","decl":"theorem ker_toAddSubgroup (f : M →ₛₗ[τ₁₂] M₂) : (ker f).toAddSubgroup = f.toAddMonoidHom.ker :=\n  rfl\n\n"}
{"name":"LinearMap.sub_mem_ker_iff","module":"Mathlib.Algebra.Module.Submodule.Ker","initialProofState":"R : Type u_1\nR₂ : Type u_2\nM : Type u_5\nM₂ : Type u_7\ninst✝⁷ : Ring R\ninst✝⁶ : Ring R₂\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : AddCommGroup M₂\ninst✝³ : Module R M\ninst✝² : Module R₂ M₂\nτ₁₂ : RingHom R R₂\nF : Type u_11\ninst✝¹ : FunLike F M M₂\ninst✝ : SemilinearMapClass F τ₁₂ M M₂\nf : F\nx y : M\n⊢ Iff (Membership.mem (LinearMap.ker f) (HSub.hSub x y)) (Eq (f x) (f y))","decl":"theorem sub_mem_ker_iff {x y} : x - y ∈ ker f ↔ f x = f y := by rw [mem_ker, map_sub, sub_eq_zero]\n\n"}
{"name":"LinearMap.disjoint_ker'","module":"Mathlib.Algebra.Module.Submodule.Ker","initialProofState":"R : Type u_1\nR₂ : Type u_2\nM : Type u_5\nM₂ : Type u_7\ninst✝⁷ : Ring R\ninst✝⁶ : Ring R₂\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : AddCommGroup M₂\ninst✝³ : Module R M\ninst✝² : Module R₂ M₂\nτ₁₂ : RingHom R R₂\nF : Type u_11\ninst✝¹ : FunLike F M M₂\ninst✝ : SemilinearMapClass F τ₁₂ M M₂\nf : F\np : Submodule R M\n⊢ Iff (Disjoint p (LinearMap.ker f)) (∀ (x : M), Membership.mem p x → ∀ (y : M), Membership.mem p y → Eq (f x) (f y) → Eq x y)","decl":"theorem disjoint_ker' {p : Submodule R M} :\n    Disjoint p (ker f) ↔ ∀ x ∈ p, ∀ y ∈ p, f x = f y → x = y :=\n  disjoint_ker.trans\n    ⟨fun H x hx y hy h => eq_of_sub_eq_zero <| H _ (sub_mem hx hy) (by simp [h]),\n     fun H x h₁ h₂ => H x h₁ 0 (zero_mem _) (by simpa using h₂)⟩\n\n"}
{"name":"LinearMap.injOn_of_disjoint_ker","module":"Mathlib.Algebra.Module.Submodule.Ker","initialProofState":"R : Type u_1\nR₂ : Type u_2\nM : Type u_5\nM₂ : Type u_7\ninst✝⁷ : Ring R\ninst✝⁶ : Ring R₂\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : AddCommGroup M₂\ninst✝³ : Module R M\ninst✝² : Module R₂ M₂\nτ₁₂ : RingHom R R₂\nF : Type u_11\ninst✝¹ : FunLike F M M₂\ninst✝ : SemilinearMapClass F τ₁₂ M M₂\nf : F\np : Submodule R M\ns : Set M\nh : HasSubset.Subset s ↑p\nhd : Disjoint p (LinearMap.ker f)\n⊢ Set.InjOn (⇑f) s","decl":"theorem injOn_of_disjoint_ker {p : Submodule R M} {s : Set M} (h : s ⊆ p)\n    (hd : Disjoint p (ker f)) : Set.InjOn f s := fun _ hx _ hy =>\n  disjoint_ker'.1 hd _ (h hx) _ (h hy)\n\n"}
{"name":"LinearMapClass.ker_eq_bot","module":"Mathlib.Algebra.Module.Submodule.Ker","initialProofState":"R : Type u_1\nR₂ : Type u_2\nM : Type u_5\nM₂ : Type u_7\ninst✝⁷ : Ring R\ninst✝⁶ : Ring R₂\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : AddCommGroup M₂\ninst✝³ : Module R M\ninst✝² : Module R₂ M₂\nτ₁₂ : RingHom R R₂\nF : Type u_11\ninst✝¹ : FunLike F M M₂\ninst✝ : SemilinearMapClass F τ₁₂ M M₂\nf : F\n⊢ Iff (Eq (LinearMap.ker f) Bot.bot) (Function.Injective ⇑f)","decl":"theorem _root_.LinearMapClass.ker_eq_bot : ker f = ⊥ ↔ Injective f := by\n  simpa [disjoint_iff_inf_le] using disjoint_ker' (f := f) (p := ⊤)\n\n"}
{"name":"LinearMap.ker_eq_bot","module":"Mathlib.Algebra.Module.Submodule.Ker","initialProofState":"R : Type u_1\nR₂ : Type u_2\nM : Type u_5\nM₂ : Type u_7\ninst✝⁵ : Ring R\ninst✝⁴ : Ring R₂\ninst✝³ : AddCommGroup M\ninst✝² : AddCommGroup M₂\ninst✝¹ : Module R M\ninst✝ : Module R₂ M₂\nτ₁₂ : RingHom R R₂\nf : LinearMap τ₁₂ M M₂\n⊢ Iff (Eq (LinearMap.ker f) Bot.bot) (Function.Injective ⇑f)","decl":"theorem ker_eq_bot {f : M →ₛₗ[τ₁₂] M₂} : ker f = ⊥ ↔ Injective f :=\n  LinearMapClass.ker_eq_bot _\n\n"}
{"name":"LinearMap.injective_domRestrict_iff","module":"Mathlib.Algebra.Module.Submodule.Ker","initialProofState":"R : Type u_1\nR₂ : Type u_2\nM : Type u_5\nM₂ : Type u_7\ninst✝⁵ : Ring R\ninst✝⁴ : Ring R₂\ninst✝³ : AddCommGroup M\ninst✝² : AddCommGroup M₂\ninst✝¹ : Module R M\ninst✝ : Module R₂ M₂\nτ₁₂ : RingHom R R₂\nf : LinearMap τ₁₂ M M₂\nS : Submodule R M\n⊢ Iff (Function.Injective ⇑(f.domRestrict S)) (Eq (Min.min S (LinearMap.ker f)) Bot.bot)","decl":"@[simp] lemma injective_domRestrict_iff {f : M →ₛₗ[τ₁₂] M₂} {S : Submodule R M} :\n    Injective (f.domRestrict S) ↔ S ⊓ LinearMap.ker f = ⊥ := by\n  rw [← LinearMap.ker_eq_bot]\n  refine ⟨fun h ↦ le_bot_iff.1 ?_, fun h ↦ le_bot_iff.1 ?_⟩\n  · intro x ⟨hx, h'x⟩\n    have : ⟨x, hx⟩ ∈ LinearMap.ker (LinearMap.domRestrict f S) := by simpa using h'x\n    rw [h] at this\n    simpa [mk_eq_zero] using this\n  · rintro ⟨x, hx⟩ h'x\n    have : x ∈ S ⊓ LinearMap.ker f := ⟨hx, h'x⟩\n    rw [h] at this\n    simpa [mk_eq_zero] using this\n\n"}
{"name":"LinearMap.injective_restrict_iff_disjoint","module":"Mathlib.Algebra.Module.Submodule.Ker","initialProofState":"R : Type u_1\nM : Type u_5\ninst✝² : Ring R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\np : Submodule R M\nf : LinearMap (RingHom.id R) M M\nhf : ∀ (x : M), Membership.mem p x → Membership.mem p (f x)\n⊢ Iff (Function.Injective ⇑(f.restrict hf)) (Disjoint p (LinearMap.ker f))","decl":"@[simp] theorem injective_restrict_iff_disjoint {p : Submodule R M} {f : M →ₗ[R] M}\n    (hf : ∀ x ∈ p, f x ∈ p) :\n    Injective (f.restrict hf) ↔ Disjoint p (ker f) := by\n  rw [← ker_eq_bot, ker_restrict hf, ← ker_domRestrict, ker_eq_bot, injective_domRestrict_iff,\n    disjoint_iff]\n\n"}
{"name":"LinearMap.ker_smul","module":"Mathlib.Algebra.Module.Submodule.Ker","initialProofState":"K : Type u_4\nV : Type u_9\nV₂ : Type u_10\ninst✝⁴ : Semifield K\ninst✝³ : AddCommMonoid V\ninst✝² : Module K V\ninst✝¹ : AddCommMonoid V₂\ninst✝ : Module K V₂\nf : LinearMap (RingHom.id K) V V₂\na : K\nh : Ne a 0\n⊢ Eq (LinearMap.ker (HSMul.hSMul a f)) (LinearMap.ker f)","decl":"theorem ker_smul (f : V →ₗ[K] V₂) (a : K) (h : a ≠ 0) : ker (a • f) = ker f :=\n  Submodule.comap_smul f _ a h\n\n"}
{"name":"LinearMap.ker_smul'","module":"Mathlib.Algebra.Module.Submodule.Ker","initialProofState":"K : Type u_4\nV : Type u_9\nV₂ : Type u_10\ninst✝⁴ : Semifield K\ninst✝³ : AddCommMonoid V\ninst✝² : Module K V\ninst✝¹ : AddCommMonoid V₂\ninst✝ : Module K V₂\nf : LinearMap (RingHom.id K) V V₂\na : K\n⊢ Eq (LinearMap.ker (HSMul.hSMul a f)) (iInf fun x => LinearMap.ker f)","decl":"theorem ker_smul' (f : V →ₗ[K] V₂) (a : K) : ker (a • f) = ⨅ _ : a ≠ 0, ker f :=\n  Submodule.comap_smul' f _ a\n\n"}
{"name":"Submodule.comap_bot","module":"Mathlib.Algebra.Module.Submodule.Ker","initialProofState":"R : Type u_1\nR₂ : Type u_2\nM : Type u_5\nM₂ : Type u_7\ninst✝⁷ : Semiring R\ninst✝⁶ : Semiring R₂\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : AddCommMonoid M₂\ninst✝³ : Module R M\ninst✝² : Module R₂ M₂\nτ₁₂ : RingHom R R₂\nF : Type u_11\ninst✝¹ : FunLike F M M₂\ninst✝ : SemilinearMapClass F τ₁₂ M M₂\nf : F\n⊢ Eq (Submodule.comap f Bot.bot) (LinearMap.ker f)","decl":"@[simp]\ntheorem comap_bot (f : F) : comap f ⊥ = ker f :=\n  rfl\n\n"}
{"name":"Submodule.ker_subtype","module":"Mathlib.Algebra.Module.Submodule.Ker","initialProofState":"R : Type u_1\nM : Type u_5\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\np : Submodule R M\n⊢ Eq (LinearMap.ker p.subtype) Bot.bot","decl":"@[simp]\ntheorem ker_subtype : ker p.subtype = ⊥ :=\n  ker_eq_bot_of_injective fun _ _ => Subtype.ext_val\n\n"}
{"name":"Submodule.ker_inclusion","module":"Mathlib.Algebra.Module.Submodule.Ker","initialProofState":"R : Type u_1\nM : Type u_5\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\np p' : Submodule R M\nh : LE.le p p'\n⊢ Eq (LinearMap.ker (Submodule.inclusion h)) Bot.bot","decl":"@[simp]\ntheorem ker_inclusion (p p' : Submodule R M) (h : p ≤ p') : ker (inclusion h) = ⊥ := by\n  rw [inclusion, ker_codRestrict, ker_subtype]\n\n"}
{"name":"LinearMap.ker_comp_of_ker_eq_bot","module":"Mathlib.Algebra.Module.Submodule.Ker","initialProofState":"R : Type u_1\nR₂ : Type u_2\nR₃ : Type u_3\nM : Type u_5\nM₂ : Type u_7\nM₃ : Type u_8\ninst✝⁹ : Semiring R\ninst✝⁸ : Semiring R₂\ninst✝⁷ : Semiring R₃\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : AddCommMonoid M₂\ninst✝⁴ : AddCommMonoid M₃\ninst✝³ : Module R M\ninst✝² : Module R₂ M₂\ninst✝¹ : Module R₃ M₃\nτ₁₂ : RingHom R R₂\nτ₂₃ : RingHom R₂ R₃\nτ₁₃ : RingHom R R₃\ninst✝ : RingHomCompTriple τ₁₂ τ₂₃ τ₁₃\nf : LinearMap τ₁₂ M M₂\ng : LinearMap τ₂₃ M₂ M₃\nhg : Eq (LinearMap.ker g) Bot.bot\n⊢ Eq (LinearMap.ker (g.comp f)) (LinearMap.ker f)","decl":"theorem ker_comp_of_ker_eq_bot (f : M →ₛₗ[τ₁₂] M₂) {g : M₂ →ₛₗ[τ₂₃] M₃} (hg : ker g = ⊥) :\n    ker (g.comp f : M →ₛₗ[τ₁₃] M₃) = ker f := by rw [ker_comp, hg, Submodule.comap_bot]\n\n"}
{"name":"LinearEquiv.ker","module":"Mathlib.Algebra.Module.Submodule.Ker","initialProofState":"R : Type u_1\nR₂ : Type u_2\nM : Type u_5\nM₂ : Type u_7\ninst✝³ : Semiring R\ninst✝² : Semiring R₂\ninst✝¹ : AddCommMonoid M\ninst✝ : AddCommMonoid M₂\nmodule_M : Module R M\nmodule_M₂ : Module R₂ M₂\nσ₁₂ : RingHom R R₂\nσ₂₁ : RingHom R₂ R\nre₁₂ : RingHomInvPair σ₁₂ σ₂₁\nre₂₁ : RingHomInvPair σ₂₁ σ₁₂\ne : LinearEquiv σ₁₂ M M₂\n⊢ Eq (LinearMap.ker ↑e) Bot.bot","decl":"@[simp]\nprotected theorem ker : LinearMap.ker (e : M →ₛₗ[σ₁₂] M₂) = ⊥ :=\n  LinearMap.ker_eq_bot_of_injective e.toEquiv.injective\n\n"}
{"name":"LinearEquiv.ker_comp","module":"Mathlib.Algebra.Module.Submodule.Ker","initialProofState":"R : Type u_1\nR₂ : Type u_2\nR₃ : Type u_3\nM : Type u_5\nM₂ : Type u_7\nM₃ : Type u_8\ninst✝⁶ : Semiring R\ninst✝⁵ : Semiring R₂\ninst✝⁴ : Semiring R₃\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M₂\ninst✝¹ : AddCommMonoid M₃\nmodule_M : Module R M\nmodule_M₂ : Module R₂ M₂\nmodule_M₃ : Module R₃ M₃\nσ₁₂ : RingHom R R₂\nσ₂₃ : RingHom R₂ R₃\nσ₁₃ : RingHom R R₃\ninst✝ : RingHomCompTriple σ₁₂ σ₂₃ σ₁₃\nσ₃₂ : RingHom R₃ R₂\nre₂₃ : RingHomInvPair σ₂₃ σ₃₂\nre₃₂ : RingHomInvPair σ₃₂ σ₂₃\ne'' : LinearEquiv σ₂₃ M₂ M₃\nl : LinearMap σ₁₂ M M₂\n⊢ Eq (LinearMap.ker ((↑e'').comp l)) (LinearMap.ker l)","decl":"@[simp]\ntheorem ker_comp (l : M →ₛₗ[σ₁₂] M₂) :\n    LinearMap.ker (((e'' : M₂ →ₛₗ[σ₂₃] M₃).comp l : M →ₛₗ[σ₁₃] M₃) : M →ₛₗ[σ₁₃] M₃) =\n    LinearMap.ker l :=\n  LinearMap.ker_comp_of_ker_eq_bot _ e''.ker\n\n"}
