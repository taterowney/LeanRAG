{"name":"Fin.mem_piFinset_iff_zero_tail","module":"Mathlib.Data.Fin.Tuple.Finset","initialProofState":"n : Nat\nα : Fin (HAdd.hAdd n 1) → Type u_1\nf : (i : Fin (HAdd.hAdd n 1)) → α i\ns : (i : Fin (HAdd.hAdd n 1)) → Finset (α i)\n⊢ Iff (Membership.mem (Fintype.piFinset s) f) (And (Membership.mem (s 0) (f 0)) (Membership.mem (Fintype.piFinset (Fin.tail s)) (Fin.tail f)))","decl":"lemma mem_piFinset_iff_zero_tail :\n    f ∈ Fintype.piFinset s ↔ f 0 ∈ s 0 ∧ tail f ∈ piFinset (tail s) := by\n  simp only [Fintype.mem_piFinset, forall_fin_succ, tail]\n\n"}
{"name":"Fin.mem_piFinset_iff_last_init","module":"Mathlib.Data.Fin.Tuple.Finset","initialProofState":"n : Nat\nα : Fin (HAdd.hAdd n 1) → Type u_1\nf : (i : Fin (HAdd.hAdd n 1)) → α i\ns : (i : Fin (HAdd.hAdd n 1)) → Finset (α i)\n⊢ Iff (Membership.mem (Fintype.piFinset s) f) (And (Membership.mem (s (Fin.last n)) (f (Fin.last n))) (Membership.mem (Fintype.piFinset (Fin.init s)) (Fin.init f)))","decl":"lemma mem_piFinset_iff_last_init :\n    f ∈ piFinset s ↔ f (last n) ∈ s (last n) ∧ init f ∈ piFinset (init s) := by\n  simp only [Fintype.mem_piFinset, forall_fin_succ', init, and_comm]\n\n"}
{"name":"Fin.mem_piFinset_iff_pivot_removeNth","module":"Mathlib.Data.Fin.Tuple.Finset","initialProofState":"n : Nat\nα : Fin (HAdd.hAdd n 1) → Type u_1\nf : (i : Fin (HAdd.hAdd n 1)) → α i\ns : (i : Fin (HAdd.hAdd n 1)) → Finset (α i)\np : Fin (HAdd.hAdd n 1)\n⊢ Iff (Membership.mem (Fintype.piFinset s) f) (And (Membership.mem (s p) (f p)) (Membership.mem (Fintype.piFinset (p.removeNth s)) (p.removeNth f)))","decl":"lemma mem_piFinset_iff_pivot_removeNth (p : Fin (n + 1)) :\n    f ∈ piFinset s ↔ f p ∈ s p ∧ removeNth p f ∈ piFinset (removeNth p s) := by\n  simp only [Fintype.mem_piFinset, forall_iff_succAbove p, removeNth]\n\n"}
{"name":"Fin.mem_piFinset_succ","module":"Mathlib.Data.Fin.Tuple.Finset","initialProofState":"n : Nat\nα : Fin (HAdd.hAdd n 1) → Type u_1\nf : (i : Fin (HAdd.hAdd n 1)) → α i\ns : (i : Fin (HAdd.hAdd n 1)) → Finset (α i)\n⊢ Iff (Membership.mem (Fintype.piFinset s) f) (And (Membership.mem (s 0) (f 0)) (Membership.mem (Fintype.piFinset (Fin.tail s)) (Fin.tail f)))","decl":"@[deprecated (since := \"2024-09-20\")] alias mem_piFinset_succ := mem_piFinset_iff_zero_tail\n"}
{"name":"Fin.mem_piFinset_succ'","module":"Mathlib.Data.Fin.Tuple.Finset","initialProofState":"n : Nat\nα : Fin (HAdd.hAdd n 1) → Type u_1\nf : (i : Fin (HAdd.hAdd n 1)) → α i\ns : (i : Fin (HAdd.hAdd n 1)) → Finset (α i)\n⊢ Iff (Membership.mem (Fintype.piFinset s) f) (And (Membership.mem (s (Fin.last n)) (f (Fin.last n))) (Membership.mem (Fintype.piFinset (Fin.init s)) (Fin.init f)))","decl":"@[deprecated (since := \"2024-09-20\")] alias mem_piFinset_succ' := mem_piFinset_iff_last_init\n\n"}
{"name":"Fin.cons_mem_piFinset_cons","module":"Mathlib.Data.Fin.Tuple.Finset","initialProofState":"n : Nat\nα : Fin (HAdd.hAdd n 1) → Type u_1\nx_zero : α 0\nx_tail : (i : Fin n) → α i.succ\ns_zero : Finset (α 0)\ns_tail : (i : Fin n) → Finset (α i.succ)\n⊢ Iff (Membership.mem (Fintype.piFinset (Fin.cons s_zero s_tail)) (Fin.cons x_zero x_tail)) (And (Membership.mem s_zero x_zero) (Membership.mem (Fintype.piFinset s_tail) x_tail))","decl":"lemma cons_mem_piFinset_cons {x_zero : α 0} {x_tail : (i : Fin n) → α i.succ}\n    {s_zero : Finset (α 0)} {s_tail : (i : Fin n) → Finset (α i.succ)} :\n    cons x_zero x_tail ∈ piFinset (cons s_zero s_tail) ↔\n      x_zero ∈ s_zero ∧ x_tail ∈ piFinset s_tail := by\n  simp_rw [mem_piFinset_iff_zero_tail, cons_zero, tail_cons]\n\n"}
{"name":"Fin.snoc_mem_piFinset_snoc","module":"Mathlib.Data.Fin.Tuple.Finset","initialProofState":"n : Nat\nα : Fin (HAdd.hAdd n 1) → Type u_1\nx_last : α (Fin.last n)\nx_init : (i : Fin n) → α i.castSucc\ns_last : Finset (α (Fin.last n))\ns_init : (i : Fin n) → Finset (α i.castSucc)\n⊢ Iff (Membership.mem (Fintype.piFinset (Fin.snoc s_init s_last)) (Fin.snoc x_init x_last)) (And (Membership.mem s_last x_last) (Membership.mem (Fintype.piFinset s_init) x_init))","decl":"lemma snoc_mem_piFinset_snoc {x_last : α (last n)} {x_init : (i : Fin n) → α i.castSucc}\n    {s_last : Finset (α (last n))} {s_init : (i : Fin n) → Finset (α i.castSucc)} :\n    snoc x_init x_last ∈ piFinset (snoc s_init s_last) ↔\n      x_last ∈ s_last ∧ x_init ∈ piFinset s_init := by\n  simp_rw [mem_piFinset_iff_last_init, init_snoc, snoc_last]\n\n"}
{"name":"Fin.insertNth_mem_piFinset_insertNth","module":"Mathlib.Data.Fin.Tuple.Finset","initialProofState":"n : Nat\nα : Fin (HAdd.hAdd n 1) → Type u_1\np : Fin (HAdd.hAdd n 1)\nx_pivot : α p\nx_remove : (i : Fin n) → α (p.succAbove i)\ns_pivot : Finset (α p)\ns_remove : (i : Fin n) → Finset (α (p.succAbove i))\n⊢ Iff (Membership.mem (Fintype.piFinset (p.insertNth s_pivot s_remove)) (p.insertNth x_pivot x_remove)) (And (Membership.mem s_pivot x_pivot) (Membership.mem (Fintype.piFinset s_remove) x_remove))","decl":"lemma insertNth_mem_piFinset_insertNth {x_pivot : α p} {x_remove : ∀ i, α (succAbove p i)}\n    {s_pivot : Finset (α p)} {s_remove : ∀ i, Finset (α (succAbove p i))} :\n    insertNth p x_pivot x_remove ∈ piFinset (insertNth p s_pivot s_remove) ↔\n      x_pivot ∈ s_pivot ∧ x_remove ∈ piFinset s_remove := by\n  simp [mem_piFinset_iff_pivot_removeNth p]\n\n"}
{"name":"Finset.map_consEquiv_filter_piFinset","module":"Mathlib.Data.Fin.Tuple.Finset","initialProofState":"n : Nat\nα : Fin (HAdd.hAdd n 1) → Type u_1\nS : (i : Fin (HAdd.hAdd n 1)) → Finset (α i)\nP : ((i : Fin n) → α i.succ) → Prop\ninst✝ : DecidablePred P\n⊢ Eq (Finset.map (Fin.consEquiv α).symm.toEmbedding (Finset.filter (fun r => P (Fin.tail r)) (Fintype.piFinset S))) (SProd.sprod (S 0) (Finset.filter (fun r => P r) (Fintype.piFinset (Fin.tail S))))","decl":"lemma map_consEquiv_filter_piFinset (P : (∀ i, α (succ i)) → Prop) [DecidablePred P] :\n    {r ∈ piFinset S | P (tail r)}.map (consEquiv α).symm.toEmbedding =\n      S 0 ×ˢ {r ∈ piFinset (tail S) | P r} := by\n  unfold tail; ext; simp [Fin.forall_iff_succ, and_assoc]\n\n"}
{"name":"Finset.map_snocEquiv_filter_piFinset","module":"Mathlib.Data.Fin.Tuple.Finset","initialProofState":"n : Nat\nα : Fin (HAdd.hAdd n 1) → Type u_1\nS : (i : Fin (HAdd.hAdd n 1)) → Finset (α i)\nP : ((i : Fin n) → α i.castSucc) → Prop\ninst✝ : DecidablePred P\n⊢ Eq (Finset.map (Fin.snocEquiv α).symm.toEmbedding (Finset.filter (fun r => P (Fin.init r)) (Fintype.piFinset S))) (SProd.sprod (S (Fin.last n)) (Finset.filter (fun r => P r) (Fintype.piFinset (Fin.init S))))","decl":"lemma map_snocEquiv_filter_piFinset (P : (∀ i, α (castSucc i)) → Prop) [DecidablePred P] :\n    {r ∈ piFinset S | P (init r)}.map (snocEquiv α).symm.toEmbedding =\n      S (last _) ×ˢ {r ∈ piFinset (init S) | P r} := by\n  unfold init; ext; simp [Fin.forall_iff_castSucc, and_assoc]\n\n"}
{"name":"Finset.map_insertNthEquiv_filter_piFinset","module":"Mathlib.Data.Fin.Tuple.Finset","initialProofState":"n : Nat\nα : Fin (HAdd.hAdd n 1) → Type u_1\np : Fin (HAdd.hAdd n 1)\nS : (i : Fin (HAdd.hAdd n 1)) → Finset (α i)\nP : ((i : Fin n) → α (p.succAbove i)) → Prop\ninst✝ : DecidablePred P\n⊢ Eq (Finset.map (Fin.insertNthEquiv α p).symm.toEmbedding (Finset.filter (fun r => P (p.removeNth r)) (Fintype.piFinset S))) (SProd.sprod (S p) (Finset.filter (fun r => P r) (Fintype.piFinset (p.removeNth S))))","decl":"lemma map_insertNthEquiv_filter_piFinset (P : (∀ i, α (p.succAbove i)) → Prop) [DecidablePred P] :\n    {r ∈ piFinset S | P (p.removeNth r)}.map (p.insertNthEquiv α).symm.toEmbedding =\n      S p ×ˢ {r ∈ piFinset (p.removeNth  S) | P r} := by\n  unfold removeNth; ext; simp [Fin.forall_iff_succAbove p, and_assoc]\n\n"}
{"name":"Finset.filter_piFinset_eq_map_consEquiv","module":"Mathlib.Data.Fin.Tuple.Finset","initialProofState":"n : Nat\nα : Fin (HAdd.hAdd n 1) → Type u_1\nS : (i : Fin (HAdd.hAdd n 1)) → Finset (α i)\nP : ((i : Fin n) → α i.succ) → Prop\ninst✝ : DecidablePred P\n⊢ Eq (Finset.filter (fun r => P (Fin.tail r)) (Fintype.piFinset S)) (Finset.map (Fin.consEquiv α).toEmbedding (SProd.sprod (S 0) (Finset.filter (fun r => P r) (Fintype.piFinset (Fin.tail S)))))","decl":"lemma filter_piFinset_eq_map_consEquiv (P : (∀ i, α (succ i)) → Prop) [DecidablePred P] :\n    {r ∈ piFinset S | P (tail r)} =\n      (S 0 ×ˢ {r ∈ piFinset (tail S) | P r}).map (consEquiv α).toEmbedding := by\n  simp [← map_consEquiv_filter_piFinset, map_map]\n\n"}
{"name":"Finset.filter_piFinset_eq_map_snocEquiv","module":"Mathlib.Data.Fin.Tuple.Finset","initialProofState":"n : Nat\nα : Fin (HAdd.hAdd n 1) → Type u_1\nS : (i : Fin (HAdd.hAdd n 1)) → Finset (α i)\nP : ((i : Fin n) → α i.castSucc) → Prop\ninst✝ : DecidablePred P\n⊢ Eq (Finset.filter (fun r => P (Fin.init r)) (Fintype.piFinset S)) (Finset.map (Fin.snocEquiv α).toEmbedding (SProd.sprod (S (Fin.last n)) (Finset.filter (fun r => P r) (Fintype.piFinset (Fin.init S)))))","decl":"lemma filter_piFinset_eq_map_snocEquiv (P : (∀ i, α (castSucc i)) → Prop) [DecidablePred P] :\n    {r ∈ piFinset S | P (init r)} =\n      (S (last _) ×ˢ {r ∈ piFinset (init S) | P r}).map (snocEquiv α).toEmbedding := by\n  simp [← map_snocEquiv_filter_piFinset, map_map]\n\n"}
{"name":"Finset.filter_piFinset_eq_map_insertNthEquiv","module":"Mathlib.Data.Fin.Tuple.Finset","initialProofState":"n : Nat\nα : Fin (HAdd.hAdd n 1) → Type u_1\np : Fin (HAdd.hAdd n 1)\nS : (i : Fin (HAdd.hAdd n 1)) → Finset (α i)\nP : ((i : Fin n) → α (p.succAbove i)) → Prop\ninst✝ : DecidablePred P\n⊢ Eq (Finset.filter (fun r => P (p.removeNth r)) (Fintype.piFinset S)) (Finset.map (Fin.insertNthEquiv α p).toEmbedding (SProd.sprod (S p) (Finset.filter (fun r => P r) (Fintype.piFinset (p.removeNth S)))))","decl":"lemma filter_piFinset_eq_map_insertNthEquiv (P : (∀ i, α (p.succAbove i)) → Prop)\n    [DecidablePred P] :\n    {r ∈ piFinset S | P (p.removeNth r)} =\n      (S p ×ˢ {r ∈ piFinset (p.removeNth  S) | P r}).map (p.insertNthEquiv α).toEmbedding := by\n  simp [← map_insertNthEquiv_filter_piFinset, map_map]\n\n"}
{"name":"Finset.card_consEquiv_filter_piFinset","module":"Mathlib.Data.Fin.Tuple.Finset","initialProofState":"n : Nat\nα : Fin (HAdd.hAdd n 1) → Type u_1\nS : (i : Fin (HAdd.hAdd n 1)) → Finset (α i)\nP : ((i : Fin n) → α i.succ) → Prop\ninst✝ : DecidablePred P\n⊢ Eq (Finset.filter (fun r => P (Fin.tail r)) (Fintype.piFinset S)).card (HMul.hMul (S 0).card (Finset.filter (fun r => P r) (Fintype.piFinset (Fin.tail S))).card)","decl":"lemma card_consEquiv_filter_piFinset (P : (∀ i, α (succ i)) → Prop) [DecidablePred P] :\n    {r ∈ piFinset S | P (tail r)}.card = (S 0).card * {r ∈ piFinset (tail S) | P r}.card := by\n  rw [← card_product, ← map_consEquiv_filter_piFinset, card_map]\n\n"}
{"name":"Finset.card_snocEquiv_filter_piFinset","module":"Mathlib.Data.Fin.Tuple.Finset","initialProofState":"n : Nat\nα : Fin (HAdd.hAdd n 1) → Type u_1\nS : (i : Fin (HAdd.hAdd n 1)) → Finset (α i)\nP : ((i : Fin n) → α i.castSucc) → Prop\ninst✝ : DecidablePred P\n⊢ Eq (Finset.filter (fun r => P (Fin.init r)) (Fintype.piFinset S)).card (HMul.hMul (S (Fin.last n)).card (Finset.filter (fun r => P r) (Fintype.piFinset (Fin.init S))).card)","decl":"lemma card_snocEquiv_filter_piFinset (P : (∀ i, α (castSucc i)) → Prop) [DecidablePred P] :\n    {r ∈ piFinset S | P (init r)}.card =\n      (S (last _)).card * {r ∈ piFinset (init S) | P r}.card := by\n  rw [← card_product, ← map_snocEquiv_filter_piFinset, card_map]\n\n"}
{"name":"Finset.card_insertNthEquiv_filter_piFinset","module":"Mathlib.Data.Fin.Tuple.Finset","initialProofState":"n : Nat\nα : Fin (HAdd.hAdd n 1) → Type u_1\np : Fin (HAdd.hAdd n 1)\nS : (i : Fin (HAdd.hAdd n 1)) → Finset (α i)\nP : ((i : Fin n) → α (p.succAbove i)) → Prop\ninst✝ : DecidablePred P\n⊢ Eq (Finset.filter (fun r => P (p.removeNth r)) (Fintype.piFinset S)).card (HMul.hMul (S p).card (Finset.filter (fun r => P r) (Fintype.piFinset (p.removeNth S))).card)","decl":"lemma card_insertNthEquiv_filter_piFinset (P : (∀ i, α (p.succAbove i)) → Prop) [DecidablePred P] :\n    {r ∈ piFinset S | P (p.removeNth r)}.card =\n      (S p).card * {r ∈ piFinset (p.removeNth  S) | P r}.card := by\n  rw [← card_product, ← map_insertNthEquiv_filter_piFinset, card_map]\n\n"}
