{"name":"Basis.algebraMapCoeffs_repr_apply_toFun","module":"Mathlib.RingTheory.AlgebraTower","initialProofState":"R : Type u_1\nA : Type u_3\nι : Type u_5\nM : Type u_6\ninst✝⁵ : CommSemiring R\ninst✝⁴ : Semiring A\ninst✝³ : AddCommMonoid M\ninst✝² : Algebra R A\ninst✝¹ : Module A M\ninst✝ : Module R M\nb : Basis ι R M\nh : Function.Bijective ⇑(algebraMap R A)\na✝¹ : M\na✝ : ι\n⊢ Eq (((Basis.algebraMapCoeffs A b h).repr a✝¹) a✝) ((algebraMap R A) ((b.repr a✝¹) a✝))","decl":"/-- If `R` and `A` have a bijective `algebraMap R A` and act identically on `M`,\nthen a basis for `M` as `R`-module is also a basis for `M` as `R'`-module. -/\n@[simps! repr_apply_support_val repr_apply_toFun]\nnoncomputable def Basis.algebraMapCoeffs : Basis ι A M :=\n  b.mapCoeffs (RingEquiv.ofBijective _ h) fun c x => by simp\n\n"}
{"name":"Basis.algebraMapCoeffs_repr_apply_support_val","module":"Mathlib.RingTheory.AlgebraTower","initialProofState":"R : Type u_1\nA : Type u_3\nι : Type u_5\nM : Type u_6\ninst✝⁵ : CommSemiring R\ninst✝⁴ : Semiring A\ninst✝³ : AddCommMonoid M\ninst✝² : Algebra R A\ninst✝¹ : Module A M\ninst✝ : Module R M\nb : Basis ι R M\nh : Function.Bijective ⇑(algebraMap R A)\na✝ : M\n⊢ Eq ((Basis.algebraMapCoeffs A b h).repr a✝).support.val (Multiset.filter (fun a => Not (Eq ((algebraMap R A) ((b.repr a✝) a)) 0)) (b.repr a✝).support.val)","decl":"/-- If `R` and `A` have a bijective `algebraMap R A` and act identically on `M`,\nthen a basis for `M` as `R`-module is also a basis for `M` as `R'`-module. -/\n@[simps! repr_apply_support_val repr_apply_toFun]\nnoncomputable def Basis.algebraMapCoeffs : Basis ι A M :=\n  b.mapCoeffs (RingEquiv.ofBijective _ h) fun c x => by simp\n\n"}
{"name":"Basis.algebraMapCoeffs_apply","module":"Mathlib.RingTheory.AlgebraTower","initialProofState":"R : Type u_1\nA : Type u_3\nι : Type u_5\nM : Type u_6\ninst✝⁶ : CommSemiring R\ninst✝⁵ : Semiring A\ninst✝⁴ : AddCommMonoid M\ninst✝³ : Algebra R A\ninst✝² : Module A M\ninst✝¹ : Module R M\ninst✝ : IsScalarTower R A M\nb : Basis ι R M\nh : Function.Bijective ⇑(algebraMap R A)\ni : ι\n⊢ Eq ((Basis.algebraMapCoeffs A b h) i) (b i)","decl":"theorem Basis.algebraMapCoeffs_apply (i : ι) : b.algebraMapCoeffs A h i = b i :=\n  b.mapCoeffs_apply _ _ _\n\n"}
{"name":"Basis.coe_algebraMapCoeffs","module":"Mathlib.RingTheory.AlgebraTower","initialProofState":"R : Type u_1\nA : Type u_3\nι : Type u_5\nM : Type u_6\ninst✝⁶ : CommSemiring R\ninst✝⁵ : Semiring A\ninst✝⁴ : AddCommMonoid M\ninst✝³ : Algebra R A\ninst✝² : Module A M\ninst✝¹ : Module R M\ninst✝ : IsScalarTower R A M\nb : Basis ι R M\nh : Function.Bijective ⇑(algebraMap R A)\n⊢ Eq ⇑(Basis.algebraMapCoeffs A b h) ⇑b","decl":"@[simp]\ntheorem Basis.coe_algebraMapCoeffs : (b.algebraMapCoeffs A h : ι → M) = b :=\n  b.coe_mapCoeffs _ _\n\n"}
{"name":"linearIndependent_smul","module":"Mathlib.RingTheory.AlgebraTower","initialProofState":"R : Type u_1\nS : Type u_2\nA : Type u_3\ninst✝⁶ : Semiring R\ninst✝⁵ : Semiring S\ninst✝⁴ : AddCommMonoid A\ninst✝³ : Module R S\ninst✝² : Module S A\ninst✝¹ : Module R A\ninst✝ : IsScalarTower R S A\nι : Type u_5\nb : ι → S\nι' : Type u_6\nc : ι' → A\nhb : LinearIndependent R b\nhc : LinearIndependent S c\n⊢ LinearIndependent R fun p => HSMul.hSMul (b p.1) (c p.2)","decl":"theorem linearIndependent_smul {ι : Type*} {b : ι → S} {ι' : Type*} {c : ι' → A}\n    (hb : LinearIndependent R b) (hc : LinearIndependent S c) :\n    LinearIndependent R fun p : ι × ι' ↦ b p.1 • c p.2 := by\n  rw [← linearIndependent_equiv' (.prodComm ..) (g := fun p : ι' × ι ↦ b p.2 • c p.1) rfl,\n    LinearIndependent, linearCombination_smul]\n  simpa using Function.Injective.comp hc\n    ((mapRange_injective _ (map_zero _) hb).comp <| Equiv.injective _)\n\n"}
{"name":"Basis.isScalarTower_of_nonempty","module":"Mathlib.RingTheory.AlgebraTower","initialProofState":"R : Type u_1\nS : Type u_2\nA : Type u_3\ninst✝⁷ : Semiring R\ninst✝⁶ : Semiring S\ninst✝⁵ : AddCommMonoid A\ninst✝⁴ : Module R S\ninst✝³ : Module S A\ninst✝² : Module R A\ninst✝¹ : IsScalarTower R S A\nι : Type u_5\ninst✝ : Nonempty ι\nb : Basis ι S A\n⊢ IsScalarTower R S S","decl":"theorem Basis.isScalarTower_of_nonempty {ι} [Nonempty ι] (b : Basis ι S A) : IsScalarTower R S S :=\n  (b.repr.symm.comp <| lsingle <| Classical.arbitrary ι).isScalarTower_of_injective R\n    (b.repr.symm.injective.comp <| single_injective _)\n\n"}
{"name":"Basis.isScalarTower_finsupp","module":"Mathlib.RingTheory.AlgebraTower","initialProofState":"R : Type u_1\nS : Type u_2\nA : Type u_3\ninst✝⁶ : Semiring R\ninst✝⁵ : Semiring S\ninst✝⁴ : AddCommMonoid A\ninst✝³ : Module R S\ninst✝² : Module S A\ninst✝¹ : Module R A\ninst✝ : IsScalarTower R S A\nι : Type u_5\nb : Basis ι S A\n⊢ IsScalarTower R S (Finsupp ι S)","decl":"theorem Basis.isScalarTower_finsupp {ι} (b : Basis ι S A) : IsScalarTower R S (ι →₀ S) :=\n  b.repr.symm.isScalarTower_of_injective R b.repr.symm.injective\n\n"}
{"name":"Basis.smulTower_repr","module":"Mathlib.RingTheory.AlgebraTower","initialProofState":"R : Type u_1\nS : Type u_2\nA : Type u_3\ninst✝⁶ : Semiring R\ninst✝⁵ : Semiring S\ninst✝⁴ : AddCommMonoid A\ninst✝³ : Module R S\ninst✝² : Module S A\ninst✝¹ : Module R A\ninst✝ : IsScalarTower R S A\nι : Type u_5\nι' : Type u_6\nb : Basis ι R S\nc : Basis ι' S A\nx : A\nij : Prod ι ι'\n⊢ Eq (((b.smulTower c).repr x) ij) ((b.repr ((c.repr x) ij.2)) ij.1)","decl":"@[simp]\ntheorem Basis.smulTower_repr (x ij) :\n    (b.smulTower c).repr x ij = b.repr (c.repr x ij.2) ij.1 := by\n  simp [smulTower]\n\n"}
{"name":"Basis.smulTower_repr_mk","module":"Mathlib.RingTheory.AlgebraTower","initialProofState":"R : Type u_1\nS : Type u_2\nA : Type u_3\ninst✝⁶ : Semiring R\ninst✝⁵ : Semiring S\ninst✝⁴ : AddCommMonoid A\ninst✝³ : Module R S\ninst✝² : Module S A\ninst✝¹ : Module R A\ninst✝ : IsScalarTower R S A\nι : Type u_5\nι' : Type u_6\nb : Basis ι R S\nc : Basis ι' S A\nx : A\ni : ι\nj : ι'\n⊢ Eq (((b.smulTower c).repr x) { fst := i, snd := j }) ((b.repr ((c.repr x) j)) i)","decl":"theorem Basis.smulTower_repr_mk (x i j) : (b.smulTower c).repr x (i, j) = b.repr (c.repr x j) i :=\n  b.smulTower_repr c x (i, j)\n\n"}
{"name":"Basis.smulTower_apply","module":"Mathlib.RingTheory.AlgebraTower","initialProofState":"R : Type u_1\nS : Type u_2\nA : Type u_3\ninst✝⁶ : Semiring R\ninst✝⁵ : Semiring S\ninst✝⁴ : AddCommMonoid A\ninst✝³ : Module R S\ninst✝² : Module S A\ninst✝¹ : Module R A\ninst✝ : IsScalarTower R S A\nι : Type u_5\nι' : Type u_6\nb : Basis ι R S\nc : Basis ι' S A\nij : Prod ι ι'\n⊢ Eq ((b.smulTower c) ij) (HSMul.hSMul (b ij.1) (c ij.2))","decl":"@[simp]\ntheorem Basis.smulTower_apply (ij) : (b.smulTower c) ij = b ij.1 • c ij.2 := by\n  classical\n  obtain ⟨i, j⟩ := ij\n  rw [Basis.apply_eq_iff]\n  ext ⟨i', j'⟩\n  rw [Basis.smulTower_repr, LinearEquiv.map_smul, Basis.repr_self, Finsupp.smul_apply,\n    Finsupp.single_apply]\n  dsimp only\n  split_ifs with hi\n  · simp [hi, Finsupp.single_apply]\n  · simp [hi]\n\n"}
{"name":"Basis.smulTower'_repr","module":"Mathlib.RingTheory.AlgebraTower","initialProofState":"R : Type u_1\nS : Type u_2\nA : Type u_3\ninst✝⁶ : Semiring R\ninst✝⁵ : Semiring S\ninst✝⁴ : AddCommMonoid A\ninst✝³ : Module R S\ninst✝² : Module S A\ninst✝¹ : Module R A\ninst✝ : IsScalarTower R S A\nι : Type u_5\nι' : Type u_6\nb : Basis ι R S\nc : Basis ι' S A\nx : A\nij : Prod ι' ι\n⊢ Eq (((b.smulTower' c).repr x) ij) ((b.repr ((c.repr x) ij.1)) ij.2)","decl":"theorem Basis.smulTower'_repr (x ij) :\n    (b.smulTower' c).repr x ij = b.repr (c.repr x ij.1) ij.2 := by\n  rw [smulTower', repr_reindex_apply, smulTower_repr]; rfl\n\n"}
{"name":"Basis.smulTower'_repr_mk","module":"Mathlib.RingTheory.AlgebraTower","initialProofState":"R : Type u_1\nS : Type u_2\nA : Type u_3\ninst✝⁶ : Semiring R\ninst✝⁵ : Semiring S\ninst✝⁴ : AddCommMonoid A\ninst✝³ : Module R S\ninst✝² : Module S A\ninst✝¹ : Module R A\ninst✝ : IsScalarTower R S A\nι : Type u_5\nι' : Type u_6\nb : Basis ι R S\nc : Basis ι' S A\nx : A\ni : ι'\nj : ι\n⊢ Eq (((b.smulTower' c).repr x) { fst := i, snd := j }) ((b.repr ((c.repr x) i)) j)","decl":"theorem Basis.smulTower'_repr_mk (x i j) : (b.smulTower' c).repr x (i, j) = b.repr (c.repr x i) j :=\n  b.smulTower'_repr c x (i, j)\n\n"}
{"name":"Basis.smulTower'_apply","module":"Mathlib.RingTheory.AlgebraTower","initialProofState":"R : Type u_1\nS : Type u_2\nA : Type u_3\ninst✝⁶ : Semiring R\ninst✝⁵ : Semiring S\ninst✝⁴ : AddCommMonoid A\ninst✝³ : Module R S\ninst✝² : Module S A\ninst✝¹ : Module R A\ninst✝ : IsScalarTower R S A\nι : Type u_5\nι' : Type u_6\nb : Basis ι R S\nc : Basis ι' S A\nij : Prod ι' ι\n⊢ Eq ((b.smulTower' c) ij) (HSMul.hSMul (b ij.2) (c ij.1))","decl":"theorem Basis.smulTower'_apply (ij) : b.smulTower' c ij = b ij.2 • c ij.1 := by\n  rw [smulTower', reindex_apply, smulTower_apply]; rfl\n\n"}
{"name":"Basis.algebraMap_injective","module":"Mathlib.RingTheory.AlgebraTower","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝⁴ : CommRing R\ninst✝³ : Ring S\ninst✝² : Algebra R S\nι : Type u_5\ninst✝¹ : NoZeroDivisors R\ninst✝ : Nontrivial S\nb : Basis ι R S\n⊢ Function.Injective ⇑(algebraMap R S)","decl":"theorem Basis.algebraMap_injective {ι : Type*} [NoZeroDivisors R] [Nontrivial S]\n    (b : @Basis ι R S _ _ Algebra.toModule) : Function.Injective (algebraMap R S) :=\n  have : NoZeroSMulDivisors R S := b.noZeroSMulDivisors\n  NoZeroSMulDivisors.algebraMap_injective R S\n\n"}
