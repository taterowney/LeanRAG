{"name":"gaussSum_mulShift","module":"Mathlib.NumberTheory.GaussSum","initialProofState":"R : Type u\ninst✝² : CommRing R\ninst✝¹ : Fintype R\nR' : Type v\ninst✝ : CommRing R'\nχ : MulChar R R'\nψ : AddChar R R'\na : Units R\n⊢ Eq (HMul.hMul (χ ↑a) (gaussSum χ (ψ.mulShift ↑a))) (gaussSum χ ψ)","decl":"/-- Replacing `ψ` by `mulShift ψ a` and multiplying the Gauss sum by `χ a` does not change it. -/\ntheorem gaussSum_mulShift (χ : MulChar R R') (ψ : AddChar R R') (a : Rˣ) :\n    χ a * gaussSum χ (mulShift ψ a) = gaussSum χ ψ := by\n  simp only [gaussSum, mulShift_apply, Finset.mul_sum]\n  simp_rw [← mul_assoc, ← map_mul]\n  exact Fintype.sum_bijective _ a.mulLeft_bijective _ _ fun x ↦ rfl\n\n"}
{"name":"gaussSum_mul","module":"Mathlib.NumberTheory.GaussSum","initialProofState":"R : Type u\ninst✝² : CommRing R\ninst✝¹ : Fintype R\nR' : Type v\ninst✝ : CommRing R'\nχ φ : MulChar R R'\nψ : AddChar R R'\n⊢ Eq (HMul.hMul (gaussSum χ ψ) (gaussSum φ ψ)) (Finset.univ.sum fun t => Finset.univ.sum fun x => HMul.hMul (HMul.hMul (χ x) (φ (HSub.hSub t x))) (ψ t))","decl":"open Finset in\n/-- A formula for the product of two Gauss sums with the same additive character. -/\nlemma gaussSum_mul {R : Type u} [CommRing R] [Fintype R] {R' : Type v} [CommRing R']\n    (χ φ : MulChar R R') (ψ : AddChar R R') :\n    gaussSum χ ψ * gaussSum φ ψ = ∑ t : R, ∑ x : R, χ x * φ (t - x) * ψ t := by\n  rw [gaussSum, gaussSum, sum_mul_sum]\n  conv => enter [1, 2, x, 2, x_1]; rw [mul_mul_mul_comm]\n  simp only [← ψ.map_add_eq_mul]\n  have sum_eq x : ∑ y : R, χ x * φ y * ψ (x + y) = ∑ y : R, χ x * φ (y - x) * ψ y := by\n    rw [sum_bij (fun a _ ↦ a + x)]\n    · simp only [mem_univ, forall_true_left, forall_const]\n    · simp only [mem_univ, add_left_inj, imp_self, forall_const]\n    · exact fun b _ ↦ ⟨b - x, mem_univ _, by rw [sub_add_cancel]⟩\n    · exact fun a _ ↦ by rw [add_sub_cancel_right, add_comm]\n  rw [sum_congr rfl fun x _ ↦ sum_eq x, sum_comm]\n\n-- In the following, we need `R` to be a finite field.\n"}
{"name":"mul_gaussSum_inv_eq_gaussSum","module":"Mathlib.NumberTheory.GaussSum","initialProofState":"R : Type u\ninst✝² : Field R\ninst✝¹ : Fintype R\nR' : Type v\ninst✝ : CommRing R'\nχ : MulChar R R'\nψ : AddChar R R'\n⊢ Eq (HMul.hMul (χ (-1)) (gaussSum χ (Inv.inv ψ))) (gaussSum χ ψ)","decl":"lemma mul_gaussSum_inv_eq_gaussSum (χ : MulChar R R') (ψ : AddChar R R') :\n    χ (-1) * gaussSum χ ψ⁻¹ = gaussSum χ ψ := by\n  rw [ψ.inv_mulShift, ← Units.coe_neg_one]\n  exact gaussSum_mulShift χ ψ (-1)\n\n"}
{"name":"gaussSum_mul_gaussSum_eq_card","module":"Mathlib.NumberTheory.GaussSum","initialProofState":"R : Type u\ninst✝³ : Field R\ninst✝² : Fintype R\nR' : Type v\ninst✝¹ : CommRing R'\ninst✝ : IsDomain R'\nχ : MulChar R R'\nhχ : Ne χ 1\nψ : AddChar R R'\nhψ : ψ.IsPrimitive\n⊢ Eq (HMul.hMul (gaussSum χ ψ) (gaussSum (Inv.inv χ) (Inv.inv ψ))) ↑(Fintype.card R)","decl":"/-- We have `gaussSum χ ψ * gaussSum χ⁻¹ ψ⁻¹ = Fintype.card R`\nwhen `χ` is nontrivial and `ψ` is primitive (and `R` is a field). -/\ntheorem gaussSum_mul_gaussSum_eq_card {χ : MulChar R R'} (hχ : χ ≠ 1) {ψ : AddChar R R'}\n    (hψ : IsPrimitive ψ) :\n    gaussSum χ ψ * gaussSum χ⁻¹ ψ⁻¹ = Fintype.card R := by\n  simp only [gaussSum, AddChar.inv_apply, Finset.sum_mul, Finset.mul_sum, MulChar.inv_apply']\n  conv =>\n    enter [1, 2, x, 2, y]\n    rw [mul_mul_mul_comm, ← map_mul, ← map_add_eq_mul, ← sub_eq_add_neg]\n--  conv in _ * _ * (_ * _) => rw [mul_mul_mul_comm, ← map_mul, ← map_add_eq_mul, ← sub_eq_add_neg]\n  simp_rw [gaussSum_mul_aux hχ ψ]\n  rw [Finset.sum_comm]\n  classical -- to get `[DecidableEq R]` for `sum_mulShift`\n  simp_rw [← Finset.mul_sum, sum_mulShift _ hψ, sub_eq_zero, apply_ite, Nat.cast_zero, mul_zero]\n  rw [Finset.sum_ite_eq' Finset.univ (1 : R)]\n  simp only [Finset.mem_univ, map_one, one_mul, if_true]\n\n"}
{"name":"gaussSum_mul_gaussSum_pow_orderOf_sub_one","module":"Mathlib.NumberTheory.GaussSum","initialProofState":"R : Type u\ninst✝³ : Field R\ninst✝² : Fintype R\nR' : Type v\ninst✝¹ : CommRing R'\ninst✝ : IsDomain R'\nχ : MulChar R R'\nψ : AddChar R R'\nhχ : Ne χ 1\nhψ : ψ.IsPrimitive\n⊢ Eq (HMul.hMul (gaussSum χ ψ) (gaussSum (HPow.hPow χ (HSub.hSub (orderOf χ) 1)) ψ)) (HMul.hMul (χ (-1)) ↑(Fintype.card R))","decl":"/-- If `χ` is a multiplicative character of order `n` on a finite field `F`,\nthen `g(χ) * g(χ^(n-1)) = χ(-1)*#F` -/\nlemma gaussSum_mul_gaussSum_pow_orderOf_sub_one {χ : MulChar R R'} {ψ : AddChar R R'}\n    (hχ : χ ≠ 1) (hψ : ψ.IsPrimitive) :\n    gaussSum χ ψ * gaussSum (χ ^ (orderOf χ - 1)) ψ = χ (-1) * Fintype.card R := by\n  have h : χ ^ (orderOf χ - 1) = χ⁻¹ := by\n    refine (inv_eq_of_mul_eq_one_right ?_).symm\n    rw [← pow_succ', Nat.sub_one_add_one_eq_of_pos χ.orderOf_pos, pow_orderOf_eq_one]\n  rw [h, ← mul_gaussSum_inv_eq_gaussSum χ⁻¹, mul_left_comm, gaussSum_mul_gaussSum_eq_card hχ hψ,\n    MulChar.inv_apply', inv_neg_one]\n\n"}
{"name":"gaussSum_ne_zero_of_nontrivial","module":"Mathlib.NumberTheory.GaussSum","initialProofState":"R : Type u\ninst✝³ : Field R\ninst✝² : Fintype R\nR' : Type v\ninst✝¹ : CommRing R'\ninst✝ : IsDomain R'\nh : Ne (↑(Fintype.card R)) 0\nχ : MulChar R R'\nhχ : Ne χ 1\nψ : AddChar R R'\nhψ : ψ.IsPrimitive\n⊢ Ne (gaussSum χ ψ) 0","decl":"/-- The Gauss sum of a nontrivial character on a finite field does not vanish. -/\nlemma gaussSum_ne_zero_of_nontrivial (h : (Fintype.card R : R') ≠ 0) {χ : MulChar R R'}\n    (hχ : χ ≠ 1) {ψ : AddChar R R'} (hψ : ψ.IsPrimitive) :\n    gaussSum χ ψ ≠ 0 :=\n  fun H ↦ h.symm <| zero_mul (gaussSum χ⁻¹ _) ▸ H ▸ gaussSum_mul_gaussSum_eq_card hχ hψ\n\n"}
{"name":"gaussSum_sq","module":"Mathlib.NumberTheory.GaussSum","initialProofState":"R : Type u\ninst✝³ : Field R\ninst✝² : Fintype R\nR' : Type v\ninst✝¹ : CommRing R'\ninst✝ : IsDomain R'\nχ : MulChar R R'\nhχ₁ : Ne χ 1\nhχ₂ : χ.IsQuadratic\nψ : AddChar R R'\nhψ : ψ.IsPrimitive\n⊢ Eq (HPow.hPow (gaussSum χ ψ) 2) (HMul.hMul (χ (-1)) ↑(Fintype.card R))","decl":"/-- When `χ` is a nontrivial quadratic character, then the square of `gaussSum χ ψ`\nis `χ(-1)` times the cardinality of `R`. -/\ntheorem gaussSum_sq {χ : MulChar R R'} (hχ₁ : χ ≠ 1) (hχ₂ : IsQuadratic χ)\n    {ψ : AddChar R R'} (hψ : IsPrimitive ψ) :\n    gaussSum χ ψ ^ 2 = χ (-1) * Fintype.card R := by\n  rw [pow_two, ← gaussSum_mul_gaussSum_eq_card hχ₁ hψ, hχ₂.inv, mul_rotate']\n  congr\n  rw [mul_comm, ← gaussSum_mulShift _ _ (-1 : Rˣ), inv_mulShift]\n  rfl\n\n"}
{"name":"gaussSum_frob","module":"Mathlib.NumberTheory.GaussSum","initialProofState":"R : Type u\ninst✝² : CommRing R\ninst✝¹ : Fintype R\nR' : Type v\ninst✝ : CommRing R'\np : Nat\nfp : Fact (Nat.Prime p)\nhch : CharP R' p\nχ : MulChar R R'\nψ : AddChar R R'\n⊢ Eq (HPow.hPow (gaussSum χ ψ) p) (gaussSum (HPow.hPow χ p) (HPow.hPow ψ p))","decl":"/-- When `R'` has prime characteristic `p`, then the `p`th power of the Gauss sum\nof `χ` and `ψ` is the Gauss sum of `χ^p` and `ψ^p`. -/\ntheorem gaussSum_frob (χ : MulChar R R') (ψ : AddChar R R') :\n    gaussSum χ ψ ^ p = gaussSum (χ ^ p) (ψ ^ p) := by\n  rw [← frobenius_def, gaussSum, gaussSum, map_sum]\n  simp_rw [pow_apply' χ fp.1.ne_zero, map_mul, frobenius_def]\n  rfl\n\n"}
{"name":"MulChar.IsQuadratic.gaussSum_frob","module":"Mathlib.NumberTheory.GaussSum","initialProofState":"R : Type u\ninst✝² : CommRing R\ninst✝¹ : Fintype R\nR' : Type v\ninst✝ : CommRing R'\np : Nat\nfp : Fact (Nat.Prime p)\nhch : CharP R' p\nhp : IsUnit ↑p\nχ : MulChar R R'\nhχ : χ.IsQuadratic\nψ : AddChar R R'\n⊢ Eq (HPow.hPow (gaussSum χ ψ) p) (HMul.hMul (χ ↑p) (gaussSum χ ψ))","decl":"/-- For a quadratic character `χ` and when the characteristic `p` of the target ring\nis a unit in the source ring, the `p`th power of the Gauss sum of`χ` and `ψ` is\n`χ p` times the original Gauss sum. -/\ntheorem MulChar.IsQuadratic.gaussSum_frob (hp : IsUnit (p : R)) {χ : MulChar R R'}\n    (hχ : IsQuadratic χ) (ψ : AddChar R R') :\n    gaussSum χ ψ ^ p = χ p * gaussSum χ ψ := by\n  rw [_root_.gaussSum_frob, pow_mulShift, hχ.pow_char p, ← gaussSum_mulShift χ ψ hp.unit,\n    ← mul_assoc, hp.unit_spec, ← pow_two, ← pow_apply' _ two_ne_zero, hχ.sq_eq_one, ← hp.unit_spec,\n    one_apply_coe, one_mul]\n\n"}
{"name":"MulChar.IsQuadratic.gaussSum_frob_iter","module":"Mathlib.NumberTheory.GaussSum","initialProofState":"R : Type u\ninst✝² : CommRing R\ninst✝¹ : Fintype R\nR' : Type v\ninst✝ : CommRing R'\np : Nat\nfp : Fact (Nat.Prime p)\nhch : CharP R' p\nn : Nat\nhp : IsUnit ↑p\nχ : MulChar R R'\nhχ : χ.IsQuadratic\nψ : AddChar R R'\n⊢ Eq (HPow.hPow (gaussSum χ ψ) (HPow.hPow p n)) (HMul.hMul (χ (HPow.hPow (↑p) n)) (gaussSum χ ψ))","decl":"/-- For a quadratic character `χ` and when the characteristic `p` of the target ring\nis a unit in the source ring and `n` is a natural number, the `p^n`th power of the Gauss\nsum of`χ` and `ψ` is `χ (p^n)` times the original Gauss sum. -/\ntheorem MulChar.IsQuadratic.gaussSum_frob_iter (n : ℕ) (hp : IsUnit (p : R)) {χ : MulChar R R'}\n    (hχ : IsQuadratic χ) (ψ : AddChar R R') :\n    gaussSum χ ψ ^ p ^ n = χ ((p : R) ^ n) * gaussSum χ ψ := by\n  induction' n with n ih\n  · rw [pow_zero, pow_one, pow_zero, MulChar.map_one, one_mul]\n  · rw [pow_succ, pow_mul, ih, mul_pow, hχ.gaussSum_frob _ hp, ← mul_assoc, pow_succ, map_mul,\n      ← pow_apply' χ fp.1.ne_zero ((p : R) ^ n), hχ.pow_char p]\n\n"}
{"name":"Char.card_pow_char_pow","module":"Mathlib.NumberTheory.GaussSum","initialProofState":"R : Type u\ninst✝³ : CommRing R\ninst✝² : Fintype R\nR' : Type v\ninst✝¹ : CommRing R'\ninst✝ : IsDomain R'\nχ : MulChar R R'\nhχ : χ.IsQuadratic\nψ : AddChar R R'\np n : Nat\nfp : Fact (Nat.Prime p)\nhch : CharP R' p\nhp : IsUnit ↑p\nhp' : Ne p 2\nhg : Eq (HPow.hPow (gaussSum χ ψ) 2) (HMul.hMul (χ (-1)) ↑(Fintype.card R))\n⊢ Eq (HPow.hPow (HMul.hMul (χ (-1)) ↑(Fintype.card R)) (HDiv.hDiv (HPow.hPow p n) 2)) (χ (HPow.hPow (↑p) n))","decl":"/-- If the square of the Gauss sum of a quadratic character is `χ(-1) * #R`,\nthen we get, for all `n : ℕ`, the relation `(χ(-1) * #R) ^ (p^n/2) = χ(p^n)`,\nwhere `p` is the (odd) characteristic of the target ring `R'`.\nThis version can be used when `R` is not a field, e.g., `ℤ/8ℤ`. -/\ntheorem Char.card_pow_char_pow {χ : MulChar R R'} (hχ : IsQuadratic χ) (ψ : AddChar R R') (p n : ℕ)\n    [fp : Fact p.Prime] [hch : CharP R' p] (hp : IsUnit (p : R)) (hp' : p ≠ 2)\n    (hg : gaussSum χ ψ ^ 2 = χ (-1) * Fintype.card R) :\n    (χ (-1) * Fintype.card R) ^ (p ^ n / 2) = χ ((p : R) ^ n) := by\n  have : gaussSum χ ψ ≠ 0 := by\n    intro hf\n    rw [hf, zero_pow two_ne_zero, eq_comm, mul_eq_zero] at hg\n    exact not_isUnit_prime_of_dvd_card p\n        ((CharP.cast_eq_zero_iff R' p _).mp <| hg.resolve_left (isUnit_one.neg.map χ).ne_zero) hp\n  rw [← hg]\n  apply mul_right_cancel₀ this\n  rw [← hχ.gaussSum_frob_iter p n hp ψ, ← pow_mul, ← pow_succ,\n    Nat.two_mul_div_two_add_one_of_odd (fp.1.eq_two_or_odd'.resolve_left hp').pow]\n\n"}
{"name":"Char.card_pow_card","module":"Mathlib.NumberTheory.GaussSum","initialProofState":"F : Type u_1\ninst✝³ : Field F\ninst✝² : Fintype F\nF' : Type u_2\ninst✝¹ : Field F'\ninst✝ : Fintype F'\nχ : MulChar F F'\nhχ₁ : Ne χ 1\nhχ₂ : χ.IsQuadratic\nhch₁ : Ne (ringChar F') (ringChar F)\nhch₂ : Ne (ringChar F') 2\n⊢ Eq (HPow.hPow (HMul.hMul (χ (-1)) ↑(Fintype.card F)) (HDiv.hDiv (Fintype.card F') 2)) (χ ↑(Fintype.card F'))","decl":"/-- When `F` and `F'` are finite fields and `χ : F → F'` is a nontrivial quadratic character,\nthen `(χ(-1) * #F)^(#F'/2) = χ #F'`. -/\ntheorem Char.card_pow_card {F : Type*} [Field F] [Fintype F] {F' : Type*} [Field F'] [Fintype F']\n    {χ : MulChar F F'} (hχ₁ : χ ≠ 1) (hχ₂ : IsQuadratic χ)\n    (hch₁ : ringChar F' ≠ ringChar F) (hch₂ : ringChar F' ≠ 2) :\n    (χ (-1) * Fintype.card F) ^ (Fintype.card F' / 2) = χ (Fintype.card F') := by\n  obtain ⟨n, hp, hc⟩ := FiniteField.card F (ringChar F)\n  obtain ⟨n', hp', hc'⟩ := FiniteField.card F' (ringChar F')\n  let ψ := FiniteField.primitiveChar F F' hch₁\n  let FF' := CyclotomicField ψ.n F'\n  have hchar := Algebra.ringChar_eq F' FF'\n  apply (algebraMap F' FF').injective\n  rw [map_pow, map_mul, map_natCast, hc', hchar, Nat.cast_pow]\n  simp only [← MulChar.ringHomComp_apply]\n  have := Fact.mk hp'\n  have := Fact.mk (hchar.subst hp')\n  rw [Ne, ← Nat.prime_dvd_prime_iff_eq hp' hp, ← isUnit_iff_not_dvd_char, hchar] at hch₁\n  exact Char.card_pow_char_pow (hχ₂.comp _) ψ.char (ringChar FF') n' hch₁ (hchar ▸ hch₂)\n       (gaussSum_sq ((ringHomComp_ne_one_iff (RingHom.injective _)).mpr hχ₁) (hχ₂.comp _) ψ.prim)\n\n"}
{"name":"FiniteField.two_pow_card","module":"Mathlib.NumberTheory.GaussSum","initialProofState":"F : Type u_1\ninst✝¹ : Fintype F\ninst✝ : Field F\nhF : Ne (ringChar F) 2\n⊢ Eq (HPow.hPow 2 (HDiv.hDiv (Fintype.card F) 2)) ↑(ZMod.χ₈ ↑(Fintype.card F))","decl":"/-- For every finite field `F` of odd characteristic, we have `2^(#F/2) = χ₈ #F` in `F`. -/\ntheorem FiniteField.two_pow_card {F : Type*} [Fintype F] [Field F] (hF : ringChar F ≠ 2) :\n    (2 : F) ^ (Fintype.card F / 2) = χ₈ (Fintype.card F) := by\n  have hp2 (n : ℕ) : (2 ^ n : F) ≠ 0 := pow_ne_zero n (Ring.two_ne_zero hF)\n  obtain ⟨n, hp, hc⟩ := FiniteField.card F (ringChar F)\n\n  -- we work in `FF`, the eighth cyclotomic field extension of `F`\n  let FF := CyclotomicField 8 F\n  have hchar := Algebra.ringChar_eq F FF\n  have FFp := hchar.subst hp\n  have := Fact.mk FFp\n  have hFF := hchar ▸ hF -- `ringChar FF ≠ 2`\n  have hu : IsUnit (ringChar FF : ZMod 8) := by\n    rw [isUnit_iff_not_dvd_char, ringChar_zmod_n]\n    rw [Ne, ← Nat.prime_dvd_prime_iff_eq FFp Nat.prime_two] at hFF\n    change ¬_ ∣ 2 ^ 3\n    exact mt FFp.dvd_of_dvd_pow hFF\n\n  -- there is a primitive additive character `ℤ/8ℤ → FF`, sending `a + 8ℤ ↦ τ^a`\n  -- with a primitive eighth root of unity `τ`\n  let ψ₈ := primitiveZModChar 8 F (by convert hp2 3 using 1; norm_cast)\n  -- We cast from `AddChar (ZMod (8 : ℕ+)) FF` to `AddChar (ZMod 8) FF`\n  -- This is needed to make `simp_rw [← h₁]` below work.\n  let ψ₈char : AddChar (ZMod 8) FF := ψ₈.char\n  let τ : FF := ψ₈char 1\n  have τ_spec : τ ^ 4 = -1 := by\n    rw [show τ = ψ₈.char 1 from rfl] -- to make `rw [ψ₈.prim.zmod_char_eq_one_iff]` work\n    refine (sq_eq_one_iff.1 ?_).resolve_left ?_\n    · rw [← pow_mul, ← map_nsmul_eq_pow ψ₈.char, ψ₈.prim.zmod_char_eq_one_iff]\n      decide\n    · rw [← map_nsmul_eq_pow ψ₈.char, ψ₈.prim.zmod_char_eq_one_iff]\n      decide\n\n  -- we consider `χ₈` as a multiplicative character `ℤ/8ℤ → FF`\n  let χ := χ₈.ringHomComp (Int.castRingHom FF)\n  have hχ : χ (-1) = 1 := Int.cast_one\n  have hq : IsQuadratic χ := isQuadratic_χ₈.comp _\n\n  -- we now show that the Gauss sum of `χ` and `ψ₈` has the relevant property\n  have h₁ : (fun (a : Fin 8) ↦ ↑(χ₈ a) * τ ^ (a : ℕ)) = fun a ↦ χ a * ↑(ψ₈char a) := by\n    ext1; congr; apply pow_one\n  have hg₁ : gaussSum χ ψ₈char = 2 * (τ - τ ^ 3) := by\n    rw [gaussSum, ← h₁, Fin.sum_univ_eight,\n      -- evaluate `χ₈`\n      show χ₈ 0 = 0 from rfl, show χ₈ 1 = 1 from rfl, show χ₈ 2 = 0 from rfl,\n      show χ₈ 3 = -1 from rfl, show χ₈ 4 = 0 from rfl, show χ₈ 5 = -1 from rfl,\n      show χ₈ 6 = 0 from rfl, show χ₈ 7 = 1 from rfl,\n      -- normalize exponents\n      show ((3 : Fin 8) : ℕ) = 3 from rfl, show ((5 : Fin 8) : ℕ) = 5 from rfl,\n      show ((7 : Fin 8) : ℕ) = 7 from rfl]\n    simp only [Int.cast_zero, zero_mul, Int.cast_one, Fin.val_one, pow_one, one_mul, zero_add,\n      Fin.val_two, add_zero, Int.reduceNeg, Int.cast_neg, neg_mul]\n    linear_combination (τ ^ 3 - τ) * τ_spec\n  have hg : gaussSum χ ψ₈char ^ 2 = χ (-1) * Fintype.card (ZMod 8) := by\n    rw [hχ, one_mul, ZMod.card, Nat.cast_ofNat, hg₁]\n    linear_combination (4 * τ ^ 2 - 8) * τ_spec\n\n  -- this allows us to apply `card_pow_char_pow` to our situation\n  have h := Char.card_pow_char_pow (R := ZMod 8) hq ψ₈char (ringChar FF) n hu hFF hg\n  rw [ZMod.card, ← hchar, hχ, one_mul, ← hc, ← Nat.cast_pow (ringChar F), ← hc] at h\n\n  -- finally, we change `2` to `8` on the left hand side\n  convert_to (8 : F) ^ (Fintype.card F / 2) = _\n  · rw [(by norm_num : (8 : F) = 2 ^ 2 * 2), mul_pow,\n      (FiniteField.isSquare_iff hF <| hp2 2).mp ⟨2, pow_two 2⟩, one_mul]\n  apply (algebraMap F FF).injective\n  simpa only [map_pow, map_ofNat, map_intCast, Nat.cast_ofNat] using h\n\n"}
