{"name":"SeminormFamily.basisSets_iff","module":"Mathlib.Analysis.LocallyConvex.WithSeminorms","initialProofState":"ğ•œ : Type u_1\nE : Type u_5\nÎ¹ : Type u_8\ninstâœÂ² : NormedField ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module ğ•œ E\np : SeminormFamily ğ•œ E Î¹\nU : Set E\nâŠ¢ Iff (Membership.mem p.basisSets U) (Exists fun i => Exists fun r => And (LT.lt 0 r) (Eq U ((i.sup p).ball 0 r)))","decl":"theorem basisSets_iff {U : Set E} :\n    U âˆˆ p.basisSets â†” âˆƒ (i : Finset Î¹) (r : â„), 0 < r âˆ§ U = ball (i.sup p) 0 r := by\n  simp only [basisSets, mem_iUnion, exists_prop, mem_singleton_iff]\n\n"}
{"name":"SeminormFamily.basisSets_mem","module":"Mathlib.Analysis.LocallyConvex.WithSeminorms","initialProofState":"ğ•œ : Type u_1\nE : Type u_5\nÎ¹ : Type u_8\ninstâœÂ² : NormedField ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module ğ•œ E\np : SeminormFamily ğ•œ E Î¹\ni : Finset Î¹\nr : Real\nhr : LT.lt 0 r\nâŠ¢ Membership.mem p.basisSets ((i.sup p).ball 0 r)","decl":"theorem basisSets_mem (i : Finset Î¹) {r : â„} (hr : 0 < r) : (i.sup p).ball 0 r âˆˆ p.basisSets :=\n  (basisSets_iff _).mpr âŸ¨i, _, hr, rflâŸ©\n\n"}
{"name":"SeminormFamily.basisSets_singleton_mem","module":"Mathlib.Analysis.LocallyConvex.WithSeminorms","initialProofState":"ğ•œ : Type u_1\nE : Type u_5\nÎ¹ : Type u_8\ninstâœÂ² : NormedField ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module ğ•œ E\np : SeminormFamily ğ•œ E Î¹\ni : Î¹\nr : Real\nhr : LT.lt 0 r\nâŠ¢ Membership.mem p.basisSets ((p i).ball 0 r)","decl":"theorem basisSets_singleton_mem (i : Î¹) {r : â„} (hr : 0 < r) : (p i).ball 0 r âˆˆ p.basisSets :=\n  (basisSets_iff _).mpr âŸ¨{i}, _, hr, by rw [Finset.sup_singleton]âŸ©\n\n"}
{"name":"SeminormFamily.basisSets_nonempty","module":"Mathlib.Analysis.LocallyConvex.WithSeminorms","initialProofState":"ğ•œ : Type u_1\nE : Type u_5\nÎ¹ : Type u_8\ninstâœÂ³ : NormedField ğ•œ\ninstâœÂ² : AddCommGroup E\ninstâœÂ¹ : Module ğ•œ E\np : SeminormFamily ğ•œ E Î¹\ninstâœ : Nonempty Î¹\nâŠ¢ p.basisSets.Nonempty","decl":"theorem basisSets_nonempty [Nonempty Î¹] : p.basisSets.Nonempty := by\n  let i := Classical.arbitrary Î¹\n  refine nonempty_def.mpr âŸ¨(p i).ball 0 1, ?_âŸ©\n  exact p.basisSets_singleton_mem i zero_lt_one\n\n"}
{"name":"SeminormFamily.basisSets_intersect","module":"Mathlib.Analysis.LocallyConvex.WithSeminorms","initialProofState":"ğ•œ : Type u_1\nE : Type u_5\nÎ¹ : Type u_8\ninstâœÂ² : NormedField ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module ğ•œ E\np : SeminormFamily ğ•œ E Î¹\nU V : Set E\nhU : Membership.mem p.basisSets U\nhV : Membership.mem p.basisSets V\nâŠ¢ Exists fun z => And (Membership.mem p.basisSets z) (HasSubset.Subset z (Inter.inter U V))","decl":"theorem basisSets_intersect (U V : Set E) (hU : U âˆˆ p.basisSets) (hV : V âˆˆ p.basisSets) :\n    âˆƒ z âˆˆ p.basisSets, z âŠ† U âˆ© V := by\n  classical\n    rcases p.basisSets_iff.mp hU with âŸ¨s, râ‚, hrâ‚, hUâŸ©\n    rcases p.basisSets_iff.mp hV with âŸ¨t, râ‚‚, hrâ‚‚, hVâŸ©\n    use ((s âˆª t).sup p).ball 0 (min râ‚ râ‚‚)\n    refine âŸ¨p.basisSets_mem (s âˆª t) (lt_min_iff.mpr âŸ¨hrâ‚, hrâ‚‚âŸ©), ?_âŸ©\n    rw [hU, hV, ball_finset_sup_eq_iInter _ _ _ (lt_min_iff.mpr âŸ¨hrâ‚, hrâ‚‚âŸ©),\n      ball_finset_sup_eq_iInter _ _ _ hrâ‚, ball_finset_sup_eq_iInter _ _ _ hrâ‚‚]\n    exact\n      Set.subset_inter\n        (Set.iInterâ‚‚_mono' fun i hi =>\n          âŸ¨i, Finset.subset_union_left hi, ball_mono <| min_le_left _ _âŸ©)\n        (Set.iInterâ‚‚_mono' fun i hi =>\n          âŸ¨i, Finset.subset_union_right hi, ball_mono <| min_le_right _ _âŸ©)\n\n"}
{"name":"SeminormFamily.basisSets_zero","module":"Mathlib.Analysis.LocallyConvex.WithSeminorms","initialProofState":"ğ•œ : Type u_1\nE : Type u_5\nÎ¹ : Type u_8\ninstâœÂ² : NormedField ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module ğ•œ E\np : SeminormFamily ğ•œ E Î¹\nU : Set E\nhU : Membership.mem p.basisSets U\nâŠ¢ Membership.mem U 0","decl":"theorem basisSets_zero (U) (hU : U âˆˆ p.basisSets) : (0 : E) âˆˆ U := by\n  rcases p.basisSets_iff.mp hU with âŸ¨Î¹', r, hr, hUâŸ©\n  rw [hU, mem_ball_zero, map_zero]\n  exact hr\n\n"}
{"name":"SeminormFamily.basisSets_add","module":"Mathlib.Analysis.LocallyConvex.WithSeminorms","initialProofState":"ğ•œ : Type u_1\nE : Type u_5\nÎ¹ : Type u_8\ninstâœÂ² : NormedField ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module ğ•œ E\np : SeminormFamily ğ•œ E Î¹\nU : Set E\nhU : Membership.mem p.basisSets U\nâŠ¢ Exists fun V => And (Membership.mem p.basisSets V) (HasSubset.Subset (HAdd.hAdd V V) U)","decl":"theorem basisSets_add (U) (hU : U âˆˆ p.basisSets) :\n    âˆƒ V âˆˆ p.basisSets, V + V âŠ† U := by\n  rcases p.basisSets_iff.mp hU with âŸ¨s, r, hr, hUâŸ©\n  use (s.sup p).ball 0 (r / 2)\n  refine âŸ¨p.basisSets_mem s (div_pos hr zero_lt_two), ?_âŸ©\n  refine Set.Subset.trans (ball_add_ball_subset (s.sup p) (r / 2) (r / 2) 0 0) ?_\n  rw [hU, add_zero, add_halves]\n\n"}
{"name":"SeminormFamily.basisSets_neg","module":"Mathlib.Analysis.LocallyConvex.WithSeminorms","initialProofState":"ğ•œ : Type u_1\nE : Type u_5\nÎ¹ : Type u_8\ninstâœÂ² : NormedField ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module ğ•œ E\np : SeminormFamily ğ•œ E Î¹\nU : Set E\nhU' : Membership.mem p.basisSets U\nâŠ¢ Exists fun V => And (Membership.mem p.basisSets V) (HasSubset.Subset V (Set.preimage (fun x => Neg.neg x) U))","decl":"theorem basisSets_neg (U) (hU' : U âˆˆ p.basisSets) :\n    âˆƒ V âˆˆ p.basisSets, V âŠ† (fun x : E => -x) â»Â¹' U := by\n  rcases p.basisSets_iff.mp hU' with âŸ¨s, r, _, hUâŸ©\n  rw [hU, neg_preimage, neg_ball (s.sup p), neg_zero]\n  exact âŸ¨U, hU', Eq.subset hUâŸ©\n\n"}
{"name":"SeminormFamily.basisSets_smul_right","module":"Mathlib.Analysis.LocallyConvex.WithSeminorms","initialProofState":"ğ•œ : Type u_1\nE : Type u_5\nÎ¹ : Type u_8\ninstâœÂ² : NormedField ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module ğ•œ E\np : SeminormFamily ğ•œ E Î¹\nv : E\nU : Set E\nhU : Membership.mem p.basisSets U\nâŠ¢ Filter.Eventually (fun x => Membership.mem U (HSMul.hSMul x v)) (nhds 0)","decl":"theorem basisSets_smul_right (v : E) (U : Set E) (hU : U âˆˆ p.basisSets) :\n    âˆ€á¶  x : ğ•œ in ğ“ 0, x â€¢ v âˆˆ U := by\n  rcases p.basisSets_iff.mp hU with âŸ¨s, r, hr, hUâŸ©\n  rw [hU, Filter.eventually_iff]\n  simp_rw [(s.sup p).mem_ball_zero, map_smul_eq_mul]\n  by_cases h : 0 < (s.sup p) v\n  Â· simp_rw [(lt_div_iffâ‚€ h).symm]\n    rw [â† _root_.ball_zero_eq]\n    exact Metric.ball_mem_nhds 0 (div_pos hr h)\n  simp_rw [le_antisymm (not_lt.mp h) (apply_nonneg _ v), mul_zero, hr]\n  exact IsOpen.mem_nhds isOpen_univ (mem_univ 0)\n\n"}
{"name":"SeminormFamily.basisSets_smul","module":"Mathlib.Analysis.LocallyConvex.WithSeminorms","initialProofState":"ğ•œ : Type u_1\nE : Type u_5\nÎ¹ : Type u_8\ninstâœÂ³ : NormedField ğ•œ\ninstâœÂ² : AddCommGroup E\ninstâœÂ¹ : Module ğ•œ E\np : SeminormFamily ğ•œ E Î¹\ninstâœ : Nonempty Î¹\nU : Set E\nhU : Membership.mem p.basisSets U\nâŠ¢ Exists fun V => And (Membership.mem (nhds 0) V) (Exists fun W => And (Membership.mem AddGroupFilterBasis.toFilterBasis.sets W) (HasSubset.Subset (HSMul.hSMul V W) U))","decl":"theorem basisSets_smul (U) (hU : U âˆˆ p.basisSets) :\n    âˆƒ V âˆˆ ğ“ (0 : ğ•œ), âˆƒ W âˆˆ p.addGroupFilterBasis.sets, V â€¢ W âŠ† U := by\n  rcases p.basisSets_iff.mp hU with âŸ¨s, r, hr, hUâŸ©\n  refine âŸ¨Metric.ball 0 âˆšr, Metric.ball_mem_nhds 0 (Real.sqrt_pos.mpr hr), ?_âŸ©\n  refine âŸ¨(s.sup p).ball 0 âˆšr, p.basisSets_mem s (Real.sqrt_pos.mpr hr), ?_âŸ©\n  refine Set.Subset.trans (ball_smul_ball (s.sup p) âˆšr âˆšr) ?_\n  rw [hU, Real.mul_self_sqrt (le_of_lt hr)]\n\n"}
{"name":"SeminormFamily.basisSets_smul_left","module":"Mathlib.Analysis.LocallyConvex.WithSeminorms","initialProofState":"ğ•œ : Type u_1\nE : Type u_5\nÎ¹ : Type u_8\ninstâœÂ³ : NormedField ğ•œ\ninstâœÂ² : AddCommGroup E\ninstâœÂ¹ : Module ğ•œ E\np : SeminormFamily ğ•œ E Î¹\ninstâœ : Nonempty Î¹\nx : ğ•œ\nU : Set E\nhU : Membership.mem p.basisSets U\nâŠ¢ Exists fun V => And (Membership.mem AddGroupFilterBasis.toFilterBasis.sets V) (HasSubset.Subset V (Set.preimage (fun y => HSMul.hSMul x y) U))","decl":"theorem basisSets_smul_left (x : ğ•œ) (U : Set E) (hU : U âˆˆ p.basisSets) :\n    âˆƒ V âˆˆ p.addGroupFilterBasis.sets, V âŠ† (fun y : E => x â€¢ y) â»Â¹' U := by\n  rcases p.basisSets_iff.mp hU with âŸ¨s, r, hr, hUâŸ©\n  rw [hU]\n  by_cases h : x â‰  0\n  Â· rw [(s.sup p).smul_ball_preimage 0 r x h, smul_zero]\n    use (s.sup p).ball 0 (r / â€–xâ€–)\n    exact âŸ¨p.basisSets_mem s (div_pos hr (norm_pos_iff.mpr h)), Subset.rflâŸ©\n  refine âŸ¨(s.sup p).ball 0 r, p.basisSets_mem s hr, ?_âŸ©\n  simp only [not_ne_iff.mp h, Set.subset_def, mem_ball_zero, hr, mem_univ, map_zero, imp_true_iff,\n    preimage_const_of_mem, zero_smul]\n\n"}
{"name":"SeminormFamily.filter_eq_iInf","module":"Mathlib.Analysis.LocallyConvex.WithSeminorms","initialProofState":"ğ•œ : Type u_1\nE : Type u_5\nÎ¹ : Type u_8\ninstâœÂ³ : NormedField ğ•œ\ninstâœÂ² : AddCommGroup E\ninstâœÂ¹ : Module ğ•œ E\ninstâœ : Nonempty Î¹\np : SeminormFamily ğ•œ E Î¹\nâŠ¢ Eq AddGroupFilterBasis.toFilterBasis.filter (iInf fun i => Filter.comap (â‡‘(p i)) (nhds 0))","decl":"theorem filter_eq_iInf (p : SeminormFamily ğ•œ E Î¹) :\n    p.moduleFilterBasis.toFilterBasis.filter = â¨… i, (ğ“ 0).comap (p i) := by\n  refine le_antisymm (le_iInf fun i => ?_) ?_\n  Â· rw [p.moduleFilterBasis.toFilterBasis.hasBasis.le_basis_iff\n        (Metric.nhds_basis_ball.comap _)]\n    intro Îµ hÎµ\n    refine âŸ¨(p i).ball 0 Îµ, ?_, ?_âŸ©\n    Â· rw [â† (Finset.sup_singleton : _ = p i)]\n      exact p.basisSets_mem {i} hÎµ\n    Â· rw [id, (p i).ball_zero_eq_preimage_ball]\n  Â· rw [p.moduleFilterBasis.toFilterBasis.hasBasis.ge_iff]\n    rintro U (hU : U âˆˆ p.basisSets)\n    rcases p.basisSets_iff.mp hU with âŸ¨s, r, hr, rflâŸ©\n    rw [id, Seminorm.ball_finset_sup_eq_iInter _ _ _ hr, s.iInter_mem_sets]\n    exact fun i _ =>\n      Filter.mem_iInf_of_mem i\n        âŸ¨Metric.ball 0 r, Metric.ball_mem_nhds 0 hr,\n          Eq.subset (p i).ball_zero_eq_preimage_ball.symmâŸ©\n\n"}
{"name":"SeminormFamily.basisSets_mem_nhds","module":"Mathlib.Analysis.LocallyConvex.WithSeminorms","initialProofState":"ğ•œ : Type u_10\nE : Type u_11\nÎ¹ : Type u_12\ninstâœÂ³ : NormedField ğ•œ\ninstâœÂ² : AddCommGroup E\ninstâœÂ¹ : Module ğ•œ E\ninstâœ : TopologicalSpace E\np : SeminormFamily ğ•œ E Î¹\nhp : âˆ€ (i : Î¹), Continuous â‡‘(p i)\nU : Set E\nhU : Membership.mem p.basisSets U\nâŠ¢ Membership.mem (nhds 0) U","decl":"/-- If a family of seminorms is continuous, then their basis sets are neighborhoods of zero. -/\nlemma basisSets_mem_nhds {ğ•œ E Î¹ : Type*} [NormedField ğ•œ]\n    [AddCommGroup E] [Module ğ•œ E] [TopologicalSpace E] (p : SeminormFamily ğ•œ E Î¹)\n    (hp : âˆ€ i, Continuous (p i)) (U : Set E) (hU : U âˆˆ p.basisSets) : U âˆˆ ğ“ (0 : E) := by\n  obtain âŸ¨s, r, hr, rflâŸ© := p.basisSets_iff.mp hU\n  clear hU\n  refine Seminorm.ball_mem_nhds ?_ hr\n  classical\n  induction s using Finset.induction_on\n  case empty => simpa using continuous_zero\n  case insert a s _ hs =>\n    simp only [Finset.sup_insert, coe_sup]\n    exact Continuous.max (hp a) hs\n\n"}
{"name":"Seminorm.isBounded_const","module":"Mathlib.Analysis.LocallyConvex.WithSeminorms","initialProofState":"ğ•œ : Type u_1\nğ•œâ‚‚ : Type u_2\nE : Type u_5\nF : Type u_6\nÎ¹ : Type u_8\ninstâœâ· : NormedField ğ•œ\ninstâœâ¶ : AddCommGroup E\ninstâœâµ : Module ğ•œ E\ninstâœâ´ : NormedField ğ•œâ‚‚\ninstâœÂ³ : AddCommGroup F\ninstâœÂ² : Module ğ•œâ‚‚ F\nÏƒâ‚â‚‚ : RingHom ğ•œ ğ•œâ‚‚\ninstâœÂ¹ : RingHomIsometric Ïƒâ‚â‚‚\nÎ¹' : Type u_10\ninstâœ : Nonempty Î¹'\np : Î¹ â†’ Seminorm ğ•œ E\nq : Seminorm ğ•œâ‚‚ F\nf : LinearMap Ïƒâ‚â‚‚ E F\nâŠ¢ Iff (Seminorm.IsBounded p (fun x => q) f) (Exists fun s => Exists fun C => LE.le (q.comp f) (HSMul.hSMul C (s.sup p)))","decl":"theorem isBounded_const (Î¹' : Type*) [Nonempty Î¹'] {p : Î¹ â†’ Seminorm ğ•œ E} {q : Seminorm ğ•œâ‚‚ F}\n    (f : E â†’â‚›â‚—[Ïƒâ‚â‚‚] F) :\n    IsBounded p (fun _ : Î¹' => q) f â†” âˆƒ (s : Finset Î¹) (C : â„â‰¥0), q.comp f â‰¤ C â€¢ s.sup p := by\n  simp only [IsBounded, forall_const]\n\n"}
{"name":"Seminorm.const_isBounded","module":"Mathlib.Analysis.LocallyConvex.WithSeminorms","initialProofState":"ğ•œ : Type u_1\nğ•œâ‚‚ : Type u_2\nE : Type u_5\nF : Type u_6\nÎ¹' : Type u_9\ninstâœâ· : NormedField ğ•œ\ninstâœâ¶ : AddCommGroup E\ninstâœâµ : Module ğ•œ E\ninstâœâ´ : NormedField ğ•œâ‚‚\ninstâœÂ³ : AddCommGroup F\ninstâœÂ² : Module ğ•œâ‚‚ F\nÏƒâ‚â‚‚ : RingHom ğ•œ ğ•œâ‚‚\ninstâœÂ¹ : RingHomIsometric Ïƒâ‚â‚‚\nÎ¹ : Type u_10\ninstâœ : Nonempty Î¹\np : Seminorm ğ•œ E\nq : Î¹' â†’ Seminorm ğ•œâ‚‚ F\nf : LinearMap Ïƒâ‚â‚‚ E F\nâŠ¢ Iff (Seminorm.IsBounded (fun x => p) q f) (âˆ€ (i : Î¹'), Exists fun C => LE.le ((q i).comp f) (HSMul.hSMul C p))","decl":"theorem const_isBounded (Î¹ : Type*) [Nonempty Î¹] {p : Seminorm ğ•œ E} {q : Î¹' â†’ Seminorm ğ•œâ‚‚ F}\n    (f : E â†’â‚›â‚—[Ïƒâ‚â‚‚] F) : IsBounded (fun _ : Î¹ => p) q f â†” âˆ€ i, âˆƒ C : â„â‰¥0, (q i).comp f â‰¤ C â€¢ p := by\n  constructor <;> intro h i\n  Â· rcases h i with âŸ¨s, C, hâŸ©\n    exact âŸ¨C, le_trans h (smul_le_smul (Finset.sup_le fun _ _ => le_rfl) le_rfl)âŸ©\n  use {Classical.arbitrary Î¹}\n  simp only [h, Finset.sup_singleton]\n\n"}
{"name":"Seminorm.isBounded_sup","module":"Mathlib.Analysis.LocallyConvex.WithSeminorms","initialProofState":"ğ•œ : Type u_1\nğ•œâ‚‚ : Type u_2\nE : Type u_5\nF : Type u_6\nÎ¹ : Type u_8\nÎ¹' : Type u_9\ninstâœâ¶ : NormedField ğ•œ\ninstâœâµ : AddCommGroup E\ninstâœâ´ : Module ğ•œ E\ninstâœÂ³ : NormedField ğ•œâ‚‚\ninstâœÂ² : AddCommGroup F\ninstâœÂ¹ : Module ğ•œâ‚‚ F\nÏƒâ‚â‚‚ : RingHom ğ•œ ğ•œâ‚‚\ninstâœ : RingHomIsometric Ïƒâ‚â‚‚\np : Î¹ â†’ Seminorm ğ•œ E\nq : Î¹' â†’ Seminorm ğ•œâ‚‚ F\nf : LinearMap Ïƒâ‚â‚‚ E F\nhf : Seminorm.IsBounded p q f\ns' : Finset Î¹'\nâŠ¢ Exists fun C => Exists fun s => LE.le ((s'.sup q).comp f) (HSMul.hSMul C (s.sup p))","decl":"theorem isBounded_sup {p : Î¹ â†’ Seminorm ğ•œ E} {q : Î¹' â†’ Seminorm ğ•œâ‚‚ F} {f : E â†’â‚›â‚—[Ïƒâ‚â‚‚] F}\n    (hf : IsBounded p q f) (s' : Finset Î¹') :\n    âˆƒ (C : â„â‰¥0) (s : Finset Î¹), (s'.sup q).comp f â‰¤ C â€¢ s.sup p := by\n  classical\n    obtain rfl | _ := s'.eq_empty_or_nonempty\n    Â· exact âŸ¨1, âˆ…, by simp [Seminorm.bot_eq_zero]âŸ©\n    choose fâ‚› fC hf using hf\n    use s'.card â€¢ s'.sup fC, Finset.biUnion s' fâ‚›\n    have hs : âˆ€ i : Î¹', i âˆˆ s' â†’ (q i).comp f â‰¤ s'.sup fC â€¢ (Finset.biUnion s' fâ‚›).sup p := by\n      intro i hi\n      refine (hf i).trans (smul_le_smul ?_ (Finset.le_sup hi))\n      exact Finset.sup_mono (Finset.subset_biUnion_of_mem fâ‚› hi)\n    refine (comp_mono f (finset_sup_le_sum q s')).trans ?_\n    simp_rw [â† pullback_apply, map_sum, pullback_apply]\n    refine (Finset.sum_le_sum hs).trans ?_\n    rw [Finset.sum_const, smul_assoc]\n\n"}
{"name":"WithSeminorms.topology_eq_withSeminorms","module":"Mathlib.Analysis.LocallyConvex.WithSeminorms","initialProofState":"ğ•œ : Type u_1\nE : Type u_5\nÎ¹ : Type u_8\ninstâœÂ³ : NormedField ğ•œ\ninstâœÂ² : AddCommGroup E\ninstâœÂ¹ : Module ğ•œ E\ninstâœ : Nonempty Î¹\np : SeminormFamily ğ•œ E Î¹\ntopology : TopologicalSpace E\nself : WithSeminorms p\nâŠ¢ Eq topology p.moduleFilterBasis.topology","decl":"/-- The proposition that the topology of `E` is induced by a family of seminorms `p`. -/\nstructure WithSeminorms (p : SeminormFamily ğ•œ E Î¹) [topology : TopologicalSpace E] : Prop where\n  topology_eq_withSeminorms : topology = p.moduleFilterBasis.topology\n\n"}
{"name":"WithSeminorms.withSeminorms_eq","module":"Mathlib.Analysis.LocallyConvex.WithSeminorms","initialProofState":"ğ•œ : Type u_1\nE : Type u_5\nÎ¹ : Type u_8\ninstâœÂ³ : NormedField ğ•œ\ninstâœÂ² : AddCommGroup E\ninstâœÂ¹ : Module ğ•œ E\ninstâœ : Nonempty Î¹\np : SeminormFamily ğ•œ E Î¹\nt : TopologicalSpace E\nhp : WithSeminorms p\nâŠ¢ Eq t p.moduleFilterBasis.topology","decl":"theorem WithSeminorms.withSeminorms_eq {p : SeminormFamily ğ•œ E Î¹} [t : TopologicalSpace E]\n    (hp : WithSeminorms p) : t = p.moduleFilterBasis.topology :=\n  hp.1\n\n"}
{"name":"WithSeminorms.topologicalAddGroup","module":"Mathlib.Analysis.LocallyConvex.WithSeminorms","initialProofState":"ğ•œ : Type u_1\nE : Type u_5\nÎ¹ : Type u_8\ninstâœâ´ : NormedField ğ•œ\ninstâœÂ³ : AddCommGroup E\ninstâœÂ² : Module ğ•œ E\ninstâœÂ¹ : Nonempty Î¹\ninstâœ : TopologicalSpace E\np : SeminormFamily ğ•œ E Î¹\nhp : WithSeminorms p\nâŠ¢ TopologicalAddGroup E","decl":"theorem WithSeminorms.topologicalAddGroup (hp : WithSeminorms p) : TopologicalAddGroup E := by\n  rw [hp.withSeminorms_eq]\n  exact AddGroupFilterBasis.isTopologicalAddGroup _\n\n"}
{"name":"WithSeminorms.continuousSMul","module":"Mathlib.Analysis.LocallyConvex.WithSeminorms","initialProofState":"ğ•œ : Type u_1\nE : Type u_5\nÎ¹ : Type u_8\ninstâœâ´ : NormedField ğ•œ\ninstâœÂ³ : AddCommGroup E\ninstâœÂ² : Module ğ•œ E\ninstâœÂ¹ : Nonempty Î¹\ninstâœ : TopologicalSpace E\np : SeminormFamily ğ•œ E Î¹\nhp : WithSeminorms p\nâŠ¢ ContinuousSMul ğ•œ E","decl":"theorem WithSeminorms.continuousSMul (hp : WithSeminorms p) : ContinuousSMul ğ•œ E := by\n  rw [hp.withSeminorms_eq]\n  exact ModuleFilterBasis.continuousSMul _\n\n"}
{"name":"WithSeminorms.hasBasis","module":"Mathlib.Analysis.LocallyConvex.WithSeminorms","initialProofState":"ğ•œ : Type u_1\nE : Type u_5\nÎ¹ : Type u_8\ninstâœâ´ : NormedField ğ•œ\ninstâœÂ³ : AddCommGroup E\ninstâœÂ² : Module ğ•œ E\ninstâœÂ¹ : Nonempty Î¹\ninstâœ : TopologicalSpace E\np : SeminormFamily ğ•œ E Î¹\nhp : WithSeminorms p\nâŠ¢ (nhds 0).HasBasis (fun s => Membership.mem p.basisSets s) id","decl":"theorem WithSeminorms.hasBasis (hp : WithSeminorms p) :\n    (ğ“ (0 : E)).HasBasis (fun s : Set E => s âˆˆ p.basisSets) id := by\n  rw [congr_fun (congr_arg (@nhds E) hp.1) 0]\n  exact AddGroupFilterBasis.nhds_zero_hasBasis _\n\n"}
{"name":"WithSeminorms.hasBasis_zero_ball","module":"Mathlib.Analysis.LocallyConvex.WithSeminorms","initialProofState":"ğ•œ : Type u_1\nE : Type u_5\nÎ¹ : Type u_8\ninstâœâ´ : NormedField ğ•œ\ninstâœÂ³ : AddCommGroup E\ninstâœÂ² : Module ğ•œ E\ninstâœÂ¹ : Nonempty Î¹\ninstâœ : TopologicalSpace E\np : SeminormFamily ğ•œ E Î¹\nhp : WithSeminorms p\nâŠ¢ (nhds 0).HasBasis (fun sr => LT.lt 0 sr.2) fun sr => (sr.1.sup p).ball 0 sr.2","decl":"theorem WithSeminorms.hasBasis_zero_ball (hp : WithSeminorms p) :\n    (ğ“ (0 : E)).HasBasis\n    (fun sr : Finset Î¹ Ã— â„ => 0 < sr.2) fun sr => (sr.1.sup p).ball 0 sr.2 := by\n  refine âŸ¨fun V => ?_âŸ©\n  simp only [hp.hasBasis.mem_iff, SeminormFamily.basisSets_iff, Prod.exists]\n  constructor\n  Â· rintro âŸ¨-, âŸ¨s, r, hr, rflâŸ©, hVâŸ©\n    exact âŸ¨s, r, hr, hVâŸ©\n  Â· rintro âŸ¨s, r, hr, hVâŸ©\n    exact âŸ¨_, âŸ¨s, r, hr, rflâŸ©, hVâŸ©\n\n"}
{"name":"WithSeminorms.hasBasis_ball","module":"Mathlib.Analysis.LocallyConvex.WithSeminorms","initialProofState":"ğ•œ : Type u_1\nE : Type u_5\nÎ¹ : Type u_8\ninstâœâ´ : NormedField ğ•œ\ninstâœÂ³ : AddCommGroup E\ninstâœÂ² : Module ğ•œ E\ninstâœÂ¹ : Nonempty Î¹\ninstâœ : TopologicalSpace E\np : SeminormFamily ğ•œ E Î¹\nhp : WithSeminorms p\nx : E\nâŠ¢ (nhds x).HasBasis (fun sr => LT.lt 0 sr.2) fun sr => (sr.1.sup p).ball x sr.2","decl":"theorem WithSeminorms.hasBasis_ball (hp : WithSeminorms p) {x : E} :\n    (ğ“ (x : E)).HasBasis\n    (fun sr : Finset Î¹ Ã— â„ => 0 < sr.2) fun sr => (sr.1.sup p).ball x sr.2 := by\n  have : TopologicalAddGroup E := hp.topologicalAddGroup\n  rw [â† map_add_left_nhds_zero]\n  convert hp.hasBasis_zero_ball.map (x + Â·) using 1\n  ext sr : 1\n  -- Porting note: extra type ascriptions needed on `0`\n  have : (sr.fst.sup p).ball (x +áµ¥ (0 : E)) sr.snd = x +áµ¥ (sr.fst.sup p).ball 0 sr.snd :=\n    Eq.symm (Seminorm.vadd_ball (sr.fst.sup p))\n  rwa [vadd_eq_add, add_zero] at this\n\n"}
{"name":"WithSeminorms.mem_nhds_iff","module":"Mathlib.Analysis.LocallyConvex.WithSeminorms","initialProofState":"ğ•œ : Type u_1\nE : Type u_5\nÎ¹ : Type u_8\ninstâœâ´ : NormedField ğ•œ\ninstâœÂ³ : AddCommGroup E\ninstâœÂ² : Module ğ•œ E\ninstâœÂ¹ : Nonempty Î¹\ninstâœ : TopologicalSpace E\np : SeminormFamily ğ•œ E Î¹\nhp : WithSeminorms p\nx : E\nU : Set E\nâŠ¢ Iff (Membership.mem (nhds x) U) (Exists fun s => Exists fun r => And (GT.gt r 0) (HasSubset.Subset ((s.sup p).ball x r) U))","decl":"/-- The `x`-neighbourhoods of a space whose topology is induced by a family of seminorms\nare exactly the sets which contain seminorm balls around `x`. -/\ntheorem WithSeminorms.mem_nhds_iff (hp : WithSeminorms p) (x : E) (U : Set E) :\n    U âˆˆ ğ“ x â†” âˆƒ s : Finset Î¹, âˆƒ r > 0, (s.sup p).ball x r âŠ† U := by\n  rw [hp.hasBasis_ball.mem_iff, Prod.exists]\n\n"}
{"name":"WithSeminorms.isOpen_iff_mem_balls","module":"Mathlib.Analysis.LocallyConvex.WithSeminorms","initialProofState":"ğ•œ : Type u_1\nE : Type u_5\nÎ¹ : Type u_8\ninstâœâ´ : NormedField ğ•œ\ninstâœÂ³ : AddCommGroup E\ninstâœÂ² : Module ğ•œ E\ninstâœÂ¹ : Nonempty Î¹\ninstâœ : TopologicalSpace E\np : SeminormFamily ğ•œ E Î¹\nhp : WithSeminorms p\nU : Set E\nâŠ¢ Iff (IsOpen U) (âˆ€ (x : E), Membership.mem U x â†’ Exists fun s => Exists fun r => And (GT.gt r 0) (HasSubset.Subset ((s.sup p).ball x r) U))","decl":"/-- The open sets of a space whose topology is induced by a family of seminorms\nare exactly the sets which contain seminorm balls around all of their points. -/\ntheorem WithSeminorms.isOpen_iff_mem_balls (hp : WithSeminorms p) (U : Set E) :\n    IsOpen U â†” âˆ€ x âˆˆ U, âˆƒ s : Finset Î¹, âˆƒ r > 0, (s.sup p).ball x r âŠ† U := by\n  simp_rw [â† WithSeminorms.mem_nhds_iff hp _ U, isOpen_iff_mem_nhds]\n\n/- Note that through the following lemmas, one also immediately has that separating families\nof seminorms induce Tâ‚‚ and Tâ‚ƒ topologies by `TopologicalAddGroup.t2Space`\nand `TopologicalAddGroup.t3Space` -/\n"}
{"name":"WithSeminorms.T1_of_separating","module":"Mathlib.Analysis.LocallyConvex.WithSeminorms","initialProofState":"ğ•œ : Type u_1\nE : Type u_5\nÎ¹ : Type u_8\ninstâœâ´ : NormedField ğ•œ\ninstâœÂ³ : AddCommGroup E\ninstâœÂ² : Module ğ•œ E\ninstâœÂ¹ : Nonempty Î¹\ninstâœ : TopologicalSpace E\np : SeminormFamily ğ•œ E Î¹\nhp : WithSeminorms p\nh : âˆ€ (x : E), Ne x 0 â†’ Exists fun i => Ne ((p i) x) 0\nâŠ¢ T1Space E","decl":"/-- A separating family of seminorms induces a Tâ‚ topology. -/\ntheorem WithSeminorms.T1_of_separating (hp : WithSeminorms p)\n    (h : âˆ€ x, x â‰  0 â†’ âˆƒ i, p i x â‰  0) : T1Space E := by\n  have := hp.topologicalAddGroup\n  refine TopologicalAddGroup.t1Space _ ?_\n  rw [â† isOpen_compl_iff, hp.isOpen_iff_mem_balls]\n  rintro x (hx : x â‰  0)\n  cases' h x hx with i pi_nonzero\n  refine âŸ¨{i}, p i x, by positivity, subset_compl_singleton_iff.mpr ?_âŸ©\n  rw [Finset.sup_singleton, mem_ball, zero_sub, map_neg_eq_map, not_lt]\n\n"}
{"name":"WithSeminorms.separating_of_T1","module":"Mathlib.Analysis.LocallyConvex.WithSeminorms","initialProofState":"ğ•œ : Type u_1\nE : Type u_5\nÎ¹ : Type u_8\ninstâœâµ : NormedField ğ•œ\ninstâœâ´ : AddCommGroup E\ninstâœÂ³ : Module ğ•œ E\ninstâœÂ² : Nonempty Î¹\ninstâœÂ¹ : TopologicalSpace E\np : SeminormFamily ğ•œ E Î¹\ninstâœ : T1Space E\nhp : WithSeminorms p\nx : E\nhx : Ne x 0\nâŠ¢ Exists fun i => Ne ((p i) x) 0","decl":"/-- A family of seminorms inducing a Tâ‚ topology is separating. -/\ntheorem WithSeminorms.separating_of_T1 [T1Space E] (hp : WithSeminorms p) (x : E) (hx : x â‰  0) :\n    âˆƒ i, p i x â‰  0 := by\n  have := ((t1Space_TFAE E).out 0 9).mp (inferInstanceAs <| T1Space E)\n  by_contra! h\n  refine hx (this ?_)\n  rw [hp.hasBasis_zero_ball.specializes_iff]\n  rintro âŸ¨s, râŸ© (hr : 0 < r)\n  simp only [ball_finset_sup_eq_iInter _ _ _ hr, mem_iInterâ‚‚, mem_ball_zero, h, hr, forall_true_iff]\n\n"}
{"name":"WithSeminorms.separating_iff_T1","module":"Mathlib.Analysis.LocallyConvex.WithSeminorms","initialProofState":"ğ•œ : Type u_1\nE : Type u_5\nÎ¹ : Type u_8\ninstâœâ´ : NormedField ğ•œ\ninstâœÂ³ : AddCommGroup E\ninstâœÂ² : Module ğ•œ E\ninstâœÂ¹ : Nonempty Î¹\ninstâœ : TopologicalSpace E\np : SeminormFamily ğ•œ E Î¹\nhp : WithSeminorms p\nâŠ¢ Iff (âˆ€ (x : E), Ne x 0 â†’ Exists fun i => Ne ((p i) x) 0) (T1Space E)","decl":"/-- A family of seminorms is separating iff it induces a Tâ‚ topology. -/\ntheorem WithSeminorms.separating_iff_T1 (hp : WithSeminorms p) :\n    (âˆ€ x, x â‰  0 â†’ âˆƒ i, p i x â‰  0) â†” T1Space E := by\n  refine âŸ¨WithSeminorms.T1_of_separating hp, ?_âŸ©\n  intro\n  exact WithSeminorms.separating_of_T1 hp\n\n"}
{"name":"WithSeminorms.tendsto_nhds'","module":"Mathlib.Analysis.LocallyConvex.WithSeminorms","initialProofState":"ğ•œ : Type u_1\nE : Type u_5\nF : Type u_6\nÎ¹ : Type u_8\ninstâœâ´ : NormedField ğ•œ\ninstâœÂ³ : AddCommGroup E\ninstâœÂ² : Module ğ•œ E\ninstâœÂ¹ : Nonempty Î¹\ninstâœ : TopologicalSpace E\np : SeminormFamily ğ•œ E Î¹\nhp : WithSeminorms p\nu : F â†’ E\nf : Filter F\nyâ‚€ : E\nâŠ¢ Iff (Filter.Tendsto u f (nhds yâ‚€)) (âˆ€ (s : Finset Î¹) (Îµ : Real), LT.lt 0 Îµ â†’ Filter.Eventually (fun x => LT.lt ((s.sup p) (HSub.hSub (u x) yâ‚€)) Îµ) f)","decl":"/-- Convergence along filters for `WithSeminorms`.\n\nVariant with `Finset.sup`. -/\ntheorem WithSeminorms.tendsto_nhds' (hp : WithSeminorms p) (u : F â†’ E) {f : Filter F} (yâ‚€ : E) :\n    Filter.Tendsto u f (ğ“ yâ‚€) â†”\n    âˆ€ (s : Finset Î¹) (Îµ), 0 < Îµ â†’ âˆ€á¶  x in f, s.sup p (u x - yâ‚€) < Îµ := by\n  simp [hp.hasBasis_ball.tendsto_right_iff]\n\n"}
{"name":"WithSeminorms.tendsto_nhds","module":"Mathlib.Analysis.LocallyConvex.WithSeminorms","initialProofState":"ğ•œ : Type u_1\nE : Type u_5\nF : Type u_6\nÎ¹ : Type u_8\ninstâœâ´ : NormedField ğ•œ\ninstâœÂ³ : AddCommGroup E\ninstâœÂ² : Module ğ•œ E\ninstâœÂ¹ : Nonempty Î¹\ninstâœ : TopologicalSpace E\np : SeminormFamily ğ•œ E Î¹\nhp : WithSeminorms p\nu : F â†’ E\nf : Filter F\nyâ‚€ : E\nâŠ¢ Iff (Filter.Tendsto u f (nhds yâ‚€)) (âˆ€ (i : Î¹) (Îµ : Real), LT.lt 0 Îµ â†’ Filter.Eventually (fun x => LT.lt ((p i) (HSub.hSub (u x) yâ‚€)) Îµ) f)","decl":"/-- Convergence along filters for `WithSeminorms`. -/\ntheorem WithSeminorms.tendsto_nhds (hp : WithSeminorms p) (u : F â†’ E) {f : Filter F} (yâ‚€ : E) :\n    Filter.Tendsto u f (ğ“ yâ‚€) â†” âˆ€ i Îµ, 0 < Îµ â†’ âˆ€á¶  x in f, p i (u x - yâ‚€) < Îµ := by\n  rw [hp.tendsto_nhds' u yâ‚€]\n  exact\n    âŸ¨fun h i => by simpa only [Finset.sup_singleton] using h {i}, fun h s Îµ hÎµ =>\n      (s.eventually_all.2 fun i _ => h i Îµ hÎµ).mono fun _ => finset_sup_apply_lt hÎµâŸ©\n\n"}
{"name":"WithSeminorms.tendsto_nhds_atTop","module":"Mathlib.Analysis.LocallyConvex.WithSeminorms","initialProofState":"ğ•œ : Type u_1\nE : Type u_5\nF : Type u_6\nÎ¹ : Type u_8\ninstâœâ¶ : NormedField ğ•œ\ninstâœâµ : AddCommGroup E\ninstâœâ´ : Module ğ•œ E\ninstâœÂ³ : Nonempty Î¹\ninstâœÂ² : TopologicalSpace E\np : SeminormFamily ğ•œ E Î¹\ninstâœÂ¹ : SemilatticeSup F\ninstâœ : Nonempty F\nhp : WithSeminorms p\nu : F â†’ E\nyâ‚€ : E\nâŠ¢ Iff (Filter.Tendsto u Filter.atTop (nhds yâ‚€)) (âˆ€ (i : Î¹) (Îµ : Real), LT.lt 0 Îµ â†’ Exists fun xâ‚€ => âˆ€ (x : F), LE.le xâ‚€ x â†’ LT.lt ((p i) (HSub.hSub (u x) yâ‚€)) Îµ)","decl":"/-- Limit `â†’ âˆ` for `WithSeminorms`. -/\ntheorem WithSeminorms.tendsto_nhds_atTop (hp : WithSeminorms p) (u : F â†’ E) (yâ‚€ : E) :\n    Filter.Tendsto u Filter.atTop (ğ“ yâ‚€) â†”\n    âˆ€ i Îµ, 0 < Îµ â†’ âˆƒ xâ‚€, âˆ€ x, xâ‚€ â‰¤ x â†’ p i (u x - yâ‚€) < Îµ := by\n  rw [hp.tendsto_nhds u yâ‚€]\n  exact forallâ‚ƒ_congr fun _ _ _ => Filter.eventually_atTop\n\n"}
{"name":"SeminormFamily.withSeminorms_of_nhds","module":"Mathlib.Analysis.LocallyConvex.WithSeminorms","initialProofState":"ğ•œ : Type u_1\nE : Type u_5\nÎ¹ : Type u_8\ninstâœâ´ : NormedField ğ•œ\ninstâœÂ³ : AddCommGroup E\ninstâœÂ² : Module ğ•œ E\ninstâœÂ¹ : Nonempty Î¹\nt : TopologicalSpace E\ninstâœ : TopologicalAddGroup E\np : SeminormFamily ğ•œ E Î¹\nh : Eq (nhds 0) AddGroupFilterBasis.toFilterBasis.filter\nâŠ¢ WithSeminorms p","decl":"theorem SeminormFamily.withSeminorms_of_nhds [TopologicalAddGroup E] (p : SeminormFamily ğ•œ E Î¹)\n    (h : ğ“ (0 : E) = p.moduleFilterBasis.toFilterBasis.filter) : WithSeminorms p := by\n  refine\n    âŸ¨TopologicalAddGroup.ext inferInstance p.addGroupFilterBasis.isTopologicalAddGroup ?_âŸ©\n  rw [AddGroupFilterBasis.nhds_zero_eq]\n  exact h\n\n"}
{"name":"SeminormFamily.withSeminorms_of_hasBasis","module":"Mathlib.Analysis.LocallyConvex.WithSeminorms","initialProofState":"ğ•œ : Type u_1\nE : Type u_5\nÎ¹ : Type u_8\ninstâœâ´ : NormedField ğ•œ\ninstâœÂ³ : AddCommGroup E\ninstâœÂ² : Module ğ•œ E\ninstâœÂ¹ : Nonempty Î¹\nt : TopologicalSpace E\ninstâœ : TopologicalAddGroup E\np : SeminormFamily ğ•œ E Î¹\nh : (nhds 0).HasBasis (fun s => Membership.mem p.basisSets s) id\nâŠ¢ WithSeminorms p","decl":"theorem SeminormFamily.withSeminorms_of_hasBasis [TopologicalAddGroup E] (p : SeminormFamily ğ•œ E Î¹)\n    (h : (ğ“ (0 : E)).HasBasis (fun s : Set E => s âˆˆ p.basisSets) id) : WithSeminorms p :=\n  p.withSeminorms_of_nhds <|\n    Filter.HasBasis.eq_of_same_basis h p.addGroupFilterBasis.toFilterBasis.hasBasis\n\n"}
{"name":"SeminormFamily.withSeminorms_iff_nhds_eq_iInf","module":"Mathlib.Analysis.LocallyConvex.WithSeminorms","initialProofState":"ğ•œ : Type u_1\nE : Type u_5\nÎ¹ : Type u_8\ninstâœâ´ : NormedField ğ•œ\ninstâœÂ³ : AddCommGroup E\ninstâœÂ² : Module ğ•œ E\ninstâœÂ¹ : Nonempty Î¹\nt : TopologicalSpace E\ninstâœ : TopologicalAddGroup E\np : SeminormFamily ğ•œ E Î¹\nâŠ¢ Iff (WithSeminorms p) (Eq (nhds 0) (iInf fun i => Filter.comap (â‡‘(p i)) (nhds 0)))","decl":"theorem SeminormFamily.withSeminorms_iff_nhds_eq_iInf [TopologicalAddGroup E]\n    (p : SeminormFamily ğ•œ E Î¹) : WithSeminorms p â†” (ğ“ (0 : E)) = â¨… i, (ğ“ 0).comap (p i) := by\n  rw [â† p.filter_eq_iInf]\n  refine âŸ¨fun h => ?_, p.withSeminorms_of_nhdsâŸ©\n  rw [h.topology_eq_withSeminorms]\n  exact AddGroupFilterBasis.nhds_zero_eq _\n\n"}
{"name":"SeminormFamily.withSeminorms_iff_topologicalSpace_eq_iInf","module":"Mathlib.Analysis.LocallyConvex.WithSeminorms","initialProofState":"ğ•œ : Type u_1\nE : Type u_5\nÎ¹ : Type u_8\ninstâœâ´ : NormedField ğ•œ\ninstâœÂ³ : AddCommGroup E\ninstâœÂ² : Module ğ•œ E\ninstâœÂ¹ : Nonempty Î¹\nt : TopologicalSpace E\ninstâœ : TopologicalAddGroup E\np : SeminormFamily ğ•œ E Î¹\nâŠ¢ Iff (WithSeminorms p) (Eq t (iInf fun i => UniformSpace.toTopologicalSpace))","decl":"/-- The topology induced by a family of seminorms is exactly the infimum of the ones induced by\neach seminorm individually. We express this as a characterization of `WithSeminorms p`. -/\ntheorem SeminormFamily.withSeminorms_iff_topologicalSpace_eq_iInf [TopologicalAddGroup E]\n    (p : SeminormFamily ğ•œ E Î¹) :\n    WithSeminorms p â†”\n      t = â¨… i, (p i).toSeminormedAddCommGroup.toUniformSpace.toTopologicalSpace := by\n  rw [p.withSeminorms_iff_nhds_eq_iInf,\n    TopologicalAddGroup.ext_iff inferInstance (topologicalAddGroup_iInf fun i => inferInstance),\n    nhds_iInf]\n  congrm _ = â¨… i, ?_\n  exact @comap_norm_nhds_zero _ (p i).toSeminormedAddGroup\n\n"}
{"name":"WithSeminorms.continuous_seminorm","module":"Mathlib.Analysis.LocallyConvex.WithSeminorms","initialProofState":"ğ•œ : Type u_1\nE : Type u_5\nÎ¹ : Type u_8\ninstâœÂ³ : NormedField ğ•œ\ninstâœÂ² : AddCommGroup E\ninstâœÂ¹ : Module ğ•œ E\ninstâœ : Nonempty Î¹\nt : TopologicalSpace E\np : SeminormFamily ğ•œ E Î¹\nhp : WithSeminorms p\ni : Î¹\nâŠ¢ Continuous â‡‘(p i)","decl":"theorem WithSeminorms.continuous_seminorm {p : SeminormFamily ğ•œ E Î¹} (hp : WithSeminorms p)\n    (i : Î¹) : Continuous (p i) := by\n  have := hp.topologicalAddGroup\n  rw [p.withSeminorms_iff_topologicalSpace_eq_iInf.mp hp]\n  exact continuous_iInf_dom (@continuous_norm _ (p i).toSeminormedAddGroup)\n\n"}
{"name":"SeminormFamily.withSeminorms_iff_uniformSpace_eq_iInf","module":"Mathlib.Analysis.LocallyConvex.WithSeminorms","initialProofState":"ğ•œ : Type u_1\nE : Type u_5\nÎ¹ : Type u_8\ninstâœâ´ : NormedField ğ•œ\ninstâœÂ³ : AddCommGroup E\ninstâœÂ² : Module ğ•œ E\ninstâœÂ¹ : Nonempty Î¹\nu : UniformSpace E\ninstâœ : UniformAddGroup E\np : SeminormFamily ğ•œ E Î¹\nâŠ¢ Iff (WithSeminorms p) (Eq u (iInf fun i => PseudoMetricSpace.toUniformSpace))","decl":"/-- The uniform structure induced by a family of seminorms is exactly the infimum of the ones\ninduced by each seminorm individually. We express this as a characterization of\n`WithSeminorms p`. -/\ntheorem SeminormFamily.withSeminorms_iff_uniformSpace_eq_iInf [u : UniformSpace E]\n    [UniformAddGroup E] (p : SeminormFamily ğ•œ E Î¹) :\n    WithSeminorms p â†” u = â¨… i, (p i).toSeminormedAddCommGroup.toUniformSpace := by\n  rw [p.withSeminorms_iff_nhds_eq_iInf,\n    UniformAddGroup.ext_iff inferInstance (uniformAddGroup_iInf fun i => inferInstance),\n    UniformSpace.toTopologicalSpace_iInf, nhds_iInf]\n  congrm _ = â¨… i, ?_\n  exact @comap_norm_nhds_zero _ (p i).toAddGroupSeminorm.toSeminormedAddGroup\n\n"}
{"name":"norm_withSeminorms","module":"Mathlib.Analysis.LocallyConvex.WithSeminorms","initialProofState":"ğ•œ : Type u_10\nE : Type u_11\ninstâœÂ² : NormedField ğ•œ\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nâŠ¢ WithSeminorms fun x => normSeminorm ğ•œ E","decl":"/-- The topology of a `NormedSpace ğ•œ E` is induced by the seminorm `normSeminorm ğ•œ E`. -/\ntheorem norm_withSeminorms (ğ•œ E) [NormedField ğ•œ] [SeminormedAddCommGroup E] [NormedSpace ğ•œ E] :\n    WithSeminorms fun _ : Fin 1 => normSeminorm ğ•œ E := by\n  let p : SeminormFamily ğ•œ E (Fin 1) := fun _ => normSeminorm ğ•œ E\n  refine\n    âŸ¨SeminormedAddCommGroup.toTopologicalAddGroup.ext\n        p.addGroupFilterBasis.isTopologicalAddGroup ?_âŸ©\n  refine Filter.HasBasis.eq_of_same_basis Metric.nhds_basis_ball ?_\n  rw [â† ball_normSeminorm ğ•œ E]\n  refine\n    Filter.HasBasis.to_hasBasis p.addGroupFilterBasis.nhds_zero_hasBasis ?_ fun r hr =>\n      âŸ¨(normSeminorm ğ•œ E).ball 0 r, p.basisSets_singleton_mem 0 hr, rfl.subsetâŸ©\n  rintro U (hU : U âˆˆ p.basisSets)\n  rcases p.basisSets_iff.mp hU with âŸ¨s, r, hr, hUâŸ©\n  use r, hr\n  rw [hU, id]\n  by_cases h : s.Nonempty\n  Â· rw [Finset.sup_const h]\n  rw [Finset.not_nonempty_iff_eq_empty.mp h, Finset.sup_empty, ball_bot _ hr]\n  exact Set.subset_univ _\n\n"}
{"name":"WithSeminorms.isVonNBounded_iff_finset_seminorm_bounded","module":"Mathlib.Analysis.LocallyConvex.WithSeminorms","initialProofState":"ğ•œ : Type u_1\nE : Type u_5\nÎ¹ : Type u_8\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : AddCommGroup E\ninstâœÂ² : Module ğ•œ E\ninstâœÂ¹ : Nonempty Î¹\np : SeminormFamily ğ•œ E Î¹\ninstâœ : TopologicalSpace E\ns : Set E\nhp : WithSeminorms p\nâŠ¢ Iff (Bornology.IsVonNBounded ğ•œ s) (âˆ€ (I : Finset Î¹), Exists fun r => And (GT.gt r 0) (âˆ€ (x : E), Membership.mem s x â†’ LT.lt ((I.sup p) x) r))","decl":"theorem WithSeminorms.isVonNBounded_iff_finset_seminorm_bounded {s : Set E} (hp : WithSeminorms p) :\n    Bornology.IsVonNBounded ğ•œ s â†” âˆ€ I : Finset Î¹, âˆƒ r > 0, âˆ€ x âˆˆ s, I.sup p x < r := by\n  rw [hp.hasBasis.isVonNBounded_iff]\n  constructor\n  Â· intro h I\n    simp only [id] at h\n    specialize h ((I.sup p).ball 0 1) (p.basisSets_mem I zero_lt_one)\n    rcases h.exists_pos with âŸ¨r, hr, hâŸ©\n    cases' NormedField.exists_lt_norm ğ•œ r with a ha\n    specialize h a (le_of_lt ha)\n    rw [Seminorm.smul_ball_zero (norm_pos_iff.1 <| hr.trans ha), mul_one] at h\n    refine âŸ¨â€–aâ€–, lt_trans hr ha, ?_âŸ©\n    intro x hx\n    specialize h hx\n    exact (Finset.sup I p).mem_ball_zero.mp h\n  intro h s' hs'\n  rcases p.basisSets_iff.mp hs' with âŸ¨I, r, hr, hs'âŸ©\n  rw [id, hs']\n  rcases h I with âŸ¨r', _, h'âŸ©\n  simp_rw [â† (I.sup p).mem_ball_zero] at h'\n  refine Absorbs.mono_right ?_ h'\n  exact (Finset.sup I p).ball_zero_absorbs_ball_zero hr\n\n"}
{"name":"WithSeminorms.image_isVonNBounded_iff_finset_seminorm_bounded","module":"Mathlib.Analysis.LocallyConvex.WithSeminorms","initialProofState":"ğ•œ : Type u_1\nE : Type u_5\nG : Type u_7\nÎ¹ : Type u_8\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : AddCommGroup E\ninstâœÂ² : Module ğ•œ E\ninstâœÂ¹ : Nonempty Î¹\np : SeminormFamily ğ•œ E Î¹\ninstâœ : TopologicalSpace E\nf : G â†’ E\ns : Set G\nhp : WithSeminorms p\nâŠ¢ Iff (Bornology.IsVonNBounded ğ•œ (Set.image f s)) (âˆ€ (I : Finset Î¹), Exists fun r => And (GT.gt r 0) (âˆ€ (x : G), Membership.mem s x â†’ LT.lt ((I.sup p) (f x)) r))","decl":"theorem WithSeminorms.image_isVonNBounded_iff_finset_seminorm_bounded (f : G â†’ E) {s : Set G}\n    (hp : WithSeminorms p) :\n    Bornology.IsVonNBounded ğ•œ (f '' s) â†”\n      âˆ€ I : Finset Î¹, âˆƒ r > 0, âˆ€ x âˆˆ s, I.sup p (f x) < r := by\n  simp_rw [hp.isVonNBounded_iff_finset_seminorm_bounded, Set.forall_mem_image]\n\n"}
{"name":"WithSeminorms.isVonNBounded_iff_seminorm_bounded","module":"Mathlib.Analysis.LocallyConvex.WithSeminorms","initialProofState":"ğ•œ : Type u_1\nE : Type u_5\nÎ¹ : Type u_8\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : AddCommGroup E\ninstâœÂ² : Module ğ•œ E\ninstâœÂ¹ : Nonempty Î¹\np : SeminormFamily ğ•œ E Î¹\ninstâœ : TopologicalSpace E\ns : Set E\nhp : WithSeminorms p\nâŠ¢ Iff (Bornology.IsVonNBounded ğ•œ s) (âˆ€ (i : Î¹), Exists fun r => And (GT.gt r 0) (âˆ€ (x : E), Membership.mem s x â†’ LT.lt ((p i) x) r))","decl":"theorem WithSeminorms.isVonNBounded_iff_seminorm_bounded {s : Set E} (hp : WithSeminorms p) :\n    Bornology.IsVonNBounded ğ•œ s â†” âˆ€ i : Î¹, âˆƒ r > 0, âˆ€ x âˆˆ s, p i x < r := by\n  rw [hp.isVonNBounded_iff_finset_seminorm_bounded]\n  constructor\n  Â· intro hI i\n    convert hI {i}\n    rw [Finset.sup_singleton]\n  intro hi I\n  by_cases hI : I.Nonempty\n  Â· choose r hr h using hi\n    have h' : 0 < I.sup' hI r := by\n      rcases hI with âŸ¨i, hiâŸ©\n      exact lt_of_lt_of_le (hr i) (Finset.le_sup' r hi)\n    refine âŸ¨I.sup' hI r, h', fun x hx => finset_sup_apply_lt h' fun i hi => ?_âŸ©\n    refine lt_of_lt_of_le (h i x hx) ?_\n    simp only [Finset.le_sup'_iff, exists_prop]\n    exact âŸ¨i, hi, (Eq.refl _).leâŸ©\n  simp only [Finset.not_nonempty_iff_eq_empty.mp hI, Finset.sup_empty, coe_bot, Pi.zero_apply,\n    exists_prop]\n  exact âŸ¨1, zero_lt_one, fun _ _ => zero_lt_oneâŸ©\n\n"}
{"name":"WithSeminorms.image_isVonNBounded_iff_seminorm_bounded","module":"Mathlib.Analysis.LocallyConvex.WithSeminorms","initialProofState":"ğ•œ : Type u_1\nE : Type u_5\nG : Type u_7\nÎ¹ : Type u_8\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : AddCommGroup E\ninstâœÂ² : Module ğ•œ E\ninstâœÂ¹ : Nonempty Î¹\np : SeminormFamily ğ•œ E Î¹\ninstâœ : TopologicalSpace E\nf : G â†’ E\ns : Set G\nhp : WithSeminorms p\nâŠ¢ Iff (Bornology.IsVonNBounded ğ•œ (Set.image f s)) (âˆ€ (i : Î¹), Exists fun r => And (GT.gt r 0) (âˆ€ (x : G), Membership.mem s x â†’ LT.lt ((p i) (f x)) r))","decl":"theorem WithSeminorms.image_isVonNBounded_iff_seminorm_bounded (f : G â†’ E) {s : Set G}\n    (hp : WithSeminorms p) :\n    Bornology.IsVonNBounded ğ•œ (f '' s) â†” âˆ€ i : Î¹, âˆƒ r > 0, âˆ€ x âˆˆ s, p i (f x) < r := by\n  simp_rw [hp.isVonNBounded_iff_seminorm_bounded, Set.forall_mem_image]\n\n"}
{"name":"Seminorm.continuous_of_continuous_comp","module":"Mathlib.Analysis.LocallyConvex.WithSeminorms","initialProofState":"ğ• : Type u_3\nğ•â‚‚ : Type u_4\nE : Type u_5\nF : Type u_6\nÎ¹' : Type u_9\ninstâœÂ¹â° : AddCommGroup E\ninstâœâ¹ : NormedField ğ•\ninstâœâ¸ : Module ğ• E\ninstâœâ· : AddCommGroup F\ninstâœâ¶ : NormedField ğ•â‚‚\ninstâœâµ : Module ğ•â‚‚ F\nÏ„â‚â‚‚ : RingHom ğ• ğ•â‚‚\ninstâœâ´ : RingHomIsometric Ï„â‚â‚‚\ninstâœÂ³ : Nonempty Î¹'\nq : SeminormFamily ğ•â‚‚ F Î¹'\ninstâœÂ² : TopologicalSpace E\ninstâœÂ¹ : TopologicalAddGroup E\ninstâœ : TopologicalSpace F\nhq : WithSeminorms q\nf : LinearMap Ï„â‚â‚‚ E F\nhf : âˆ€ (i : Î¹'), Continuous â‡‘((q i).comp f)\nâŠ¢ Continuous â‡‘f","decl":"theorem continuous_of_continuous_comp {q : SeminormFamily ğ•â‚‚ F Î¹'} [TopologicalSpace E]\n    [TopologicalAddGroup E] [TopologicalSpace F] (hq : WithSeminorms q)\n    (f : E â†’â‚›â‚—[Ï„â‚â‚‚] F) (hf : âˆ€ i, Continuous ((q i).comp f)) : Continuous f := by\n  have : TopologicalAddGroup F := hq.topologicalAddGroup\n  refine continuous_of_continuousAt_zero f ?_\n  simp_rw [ContinuousAt, f.map_zero, q.withSeminorms_iff_nhds_eq_iInf.mp hq, Filter.tendsto_iInf,\n    Filter.tendsto_comap_iff]\n  intro i\n  convert (hf i).continuousAt.tendsto\n  exact (map_zero _).symm\n\n"}
{"name":"Seminorm.continuous_iff_continuous_comp","module":"Mathlib.Analysis.LocallyConvex.WithSeminorms","initialProofState":"ğ•œ : Type u_1\nğ•œâ‚‚ : Type u_2\nE : Type u_5\nF : Type u_6\nÎ¹' : Type u_9\ninstâœÂ¹â° : NontriviallyNormedField ğ•œ\ninstâœâ¹ : AddCommGroup E\ninstâœâ¸ : Module ğ•œ E\ninstâœâ· : NontriviallyNormedField ğ•œâ‚‚\ninstâœâ¶ : AddCommGroup F\ninstâœâµ : Module ğ•œâ‚‚ F\nÏƒâ‚â‚‚ : RingHom ğ•œ ğ•œâ‚‚\ninstâœâ´ : RingHomIsometric Ïƒâ‚â‚‚\ninstâœÂ³ : Nonempty Î¹'\nq : SeminormFamily ğ•œâ‚‚ F Î¹'\ninstâœÂ² : TopologicalSpace E\ninstâœÂ¹ : TopologicalAddGroup E\ninstâœ : TopologicalSpace F\nhq : WithSeminorms q\nf : LinearMap Ïƒâ‚â‚‚ E F\nâŠ¢ Iff (Continuous â‡‘f) (âˆ€ (i : Î¹'), Continuous â‡‘((q i).comp f))","decl":"theorem continuous_iff_continuous_comp {q : SeminormFamily ğ•œâ‚‚ F Î¹'} [TopologicalSpace E]\n    [TopologicalAddGroup E] [TopologicalSpace F] (hq : WithSeminorms q) (f : E â†’â‚›â‚—[Ïƒâ‚â‚‚] F) :\n    Continuous f â†” âˆ€ i, Continuous ((q i).comp f) :=\n    -- Porting note: if we *don't* use dot notation for `Continuous.comp`, Lean tries to show\n    -- continuity of `((q i).comp f) âˆ˜ id` because it doesn't see that `((q i).comp f)` is\n    -- actually a composition of functions.\n  âŸ¨fun h i => (hq.continuous_seminorm i).comp h, continuous_of_continuous_comp hq fâŸ©\n\n"}
{"name":"Seminorm.continuous_from_bounded","module":"Mathlib.Analysis.LocallyConvex.WithSeminorms","initialProofState":"ğ• : Type u_3\nğ•â‚‚ : Type u_4\nE : Type u_5\nF : Type u_6\nÎ¹ : Type u_8\nÎ¹' : Type u_9\ninstâœâ¸ : AddCommGroup E\ninstâœâ· : NormedField ğ•\ninstâœâ¶ : Module ğ• E\ninstâœâµ : AddCommGroup F\ninstâœâ´ : NormedField ğ•â‚‚\ninstâœÂ³ : Module ğ•â‚‚ F\nÏ„â‚â‚‚ : RingHom ğ• ğ•â‚‚\ninstâœÂ² : RingHomIsometric Ï„â‚â‚‚\ninstâœÂ¹ : Nonempty Î¹\ninstâœ : Nonempty Î¹'\np : SeminormFamily ğ• E Î¹\nq : SeminormFamily ğ•â‚‚ F Î¹'\nxâœÂ¹ : TopologicalSpace E\nhp : WithSeminorms p\nxâœ : TopologicalSpace F\nhq : WithSeminorms q\nf : LinearMap Ï„â‚â‚‚ E F\nhf : Seminorm.IsBounded p q f\nâŠ¢ Continuous â‡‘f","decl":"theorem continuous_from_bounded {p : SeminormFamily ğ• E Î¹} {q : SeminormFamily ğ•â‚‚ F Î¹'}\n    {_ : TopologicalSpace E} (hp : WithSeminorms p) {_ : TopologicalSpace F} (hq : WithSeminorms q)\n    (f : E â†’â‚›â‚—[Ï„â‚â‚‚] F) (hf : Seminorm.IsBounded p q f) : Continuous f := by\n  have : TopologicalAddGroup E := hp.topologicalAddGroup\n  refine continuous_of_continuous_comp hq _ fun i => ?_\n  rcases hf i with âŸ¨s, C, hCâŸ©\n  rw [â† Seminorm.finset_sup_smul] at hC\n  -- Note: we deduce continuouty of `s.sup (C â€¢ p)` from that of `âˆ‘ i âˆˆ s, C â€¢ p i`.\n  -- The reason is that there is no `continuous_finset_sup`, and even if it were we couldn't\n  -- really use it since `â„` is not an `OrderBot`.\n  refine Seminorm.continuous_of_le ?_ (hC.trans <| Seminorm.finset_sup_le_sum _ _)\n  change Continuous (fun x â†¦ Seminorm.coeFnAddMonoidHom _ _ (âˆ‘ i âˆˆ s, C â€¢ p i) x)\n  simp_rw [map_sum, Finset.sum_apply]\n  exact (continuous_finset_sum _ fun i _ â†¦ (hp.continuous_seminorm i).const_smul (C : â„))\n\n"}
{"name":"Seminorm.cont_withSeminorms_normedSpace","module":"Mathlib.Analysis.LocallyConvex.WithSeminorms","initialProofState":"ğ• : Type u_3\nğ•â‚‚ : Type u_4\nE : Type u_5\nÎ¹ : Type u_8\ninstâœâ¸ : AddCommGroup E\ninstâœâ· : NormedField ğ•\ninstâœâ¶ : Module ğ• E\ninstâœâµ : NormedField ğ•â‚‚\nÏ„â‚â‚‚ : RingHom ğ• ğ•â‚‚\ninstâœâ´ : RingHomIsometric Ï„â‚â‚‚\ninstâœÂ³ : Nonempty Î¹\nF : Type u_10\ninstâœÂ² : SeminormedAddCommGroup F\ninstâœÂ¹ : NormedSpace ğ•â‚‚ F\ninstâœ : TopologicalSpace E\np : Î¹ â†’ Seminorm ğ• E\nhp : WithSeminorms p\nf : LinearMap Ï„â‚â‚‚ E F\nhf : Exists fun s => Exists fun C => LE.le ((normSeminorm ğ•â‚‚ F).comp f) (HSMul.hSMul C (s.sup p))\nâŠ¢ Continuous â‡‘f","decl":"theorem cont_withSeminorms_normedSpace (F) [SeminormedAddCommGroup F] [NormedSpace ğ•â‚‚ F]\n    [TopologicalSpace E] {p : Î¹ â†’ Seminorm ğ• E} (hp : WithSeminorms p)\n    (f : E â†’â‚›â‚—[Ï„â‚â‚‚] F) (hf : âˆƒ (s : Finset Î¹) (C : â„â‰¥0), (normSeminorm ğ•â‚‚ F).comp f â‰¤ C â€¢ s.sup p) :\n    Continuous f := by\n  rw [â† Seminorm.isBounded_const (Fin 1)] at hf\n  exact continuous_from_bounded hp (norm_withSeminorms ğ•â‚‚ F) f hf\n\n"}
{"name":"Seminorm.cont_normedSpace_to_withSeminorms","module":"Mathlib.Analysis.LocallyConvex.WithSeminorms","initialProofState":"ğ• : Type u_3\nğ•â‚‚ : Type u_4\nF : Type u_6\nÎ¹ : Type u_8\ninstâœâ¸ : NormedField ğ•\ninstâœâ· : AddCommGroup F\ninstâœâ¶ : NormedField ğ•â‚‚\ninstâœâµ : Module ğ•â‚‚ F\nÏ„â‚â‚‚ : RingHom ğ• ğ•â‚‚\ninstâœâ´ : RingHomIsometric Ï„â‚â‚‚\ninstâœÂ³ : Nonempty Î¹\nE : Type u_10\ninstâœÂ² : SeminormedAddCommGroup E\ninstâœÂ¹ : NormedSpace ğ• E\ninstâœ : TopologicalSpace F\nq : Î¹ â†’ Seminorm ğ•â‚‚ F\nhq : WithSeminorms q\nf : LinearMap Ï„â‚â‚‚ E F\nhf : âˆ€ (i : Î¹), Exists fun C => LE.le ((q i).comp f) (HSMul.hSMul C (normSeminorm ğ• E))\nâŠ¢ Continuous â‡‘f","decl":"theorem cont_normedSpace_to_withSeminorms (E) [SeminormedAddCommGroup E] [NormedSpace ğ• E]\n    [TopologicalSpace F] {q : Î¹ â†’ Seminorm ğ•â‚‚ F} (hq : WithSeminorms q)\n    (f : E â†’â‚›â‚—[Ï„â‚â‚‚] F) (hf : âˆ€ i : Î¹, âˆƒ C : â„â‰¥0, (q i).comp f â‰¤ C â€¢ normSeminorm ğ• E) :\n    Continuous f := by\n  rw [â† Seminorm.const_isBounded (Fin 1)] at hf\n  exact continuous_from_bounded (norm_withSeminorms ğ• E) hq f hf\n\n"}
{"name":"WithSeminorms.equicontinuous_TFAE","module":"Mathlib.Analysis.LocallyConvex.WithSeminorms","initialProofState":"ğ•œ : Type u_1\nğ•œâ‚‚ : Type u_2\nE : Type u_5\nF : Type u_6\nÎ¹' : Type u_9\ninstâœÂ¹â° : NontriviallyNormedField ğ•œ\ninstâœâ¹ : AddCommGroup E\ninstâœâ¸ : Module ğ•œ E\ninstâœâ· : NontriviallyNormedField ğ•œâ‚‚\ninstâœâ¶ : AddCommGroup F\ninstâœâµ : Module ğ•œâ‚‚ F\nÏƒâ‚â‚‚ : RingHom ğ•œ ğ•œâ‚‚\ninstâœâ´ : RingHomIsometric Ïƒâ‚â‚‚\ninstâœÂ³ : Nonempty Î¹'\nÎº : Type u_10\nq : SeminormFamily ğ•œâ‚‚ F Î¹'\ninstâœÂ² : UniformSpace E\ninstâœÂ¹ : UniformAddGroup E\nu : UniformSpace F\nhu : UniformAddGroup F\nhq : WithSeminorms q\ninstâœ : ContinuousSMul ğ•œ E\nf : Îº â†’ LinearMap Ïƒâ‚â‚‚ E F\nâŠ¢ (List.cons (EquicontinuousAt (Function.comp DFunLike.coe f) 0) (List.cons (Equicontinuous (Function.comp DFunLike.coe f)) (List.cons (UniformEquicontinuous (Function.comp DFunLike.coe f)) (List.cons (âˆ€ (i : Î¹'), Exists fun p => And (Continuous â‡‘p) (âˆ€ (k : Îº), LE.le ((q i).comp (f k)) p)) (List.cons (âˆ€ (i : Î¹'), And (BddAbove (Set.range fun k => (q i).comp (f k))) (Continuous (iSup fun k => â‡‘((q i).comp (f k))))) List.nil))))).TFAE","decl":"/-- Let `E` and `F` be two topological vector spaces over a `NontriviallyNormedField`, and assume\nthat the topology of `F` is generated by some family of seminorms `q`. For a family `f` of linear\nmaps from `E` to `F`, the following are equivalent:\n* `f` is equicontinuous at `0`.\n* `f` is equicontinuous.\n* `f` is uniformly equicontinuous.\n* For each `q i`, the family of seminorms `k â†¦ (q i) âˆ˜ (f k)` is bounded by some continuous\n  seminorm `p` on `E`.\n* For each `q i`, the seminorm `âŠ” k, (q i) âˆ˜ (f k)` is well-defined and continuous.\n\nIn particular, if you can determine all continuous seminorms on `E`, that gives you a complete\ncharacterization of equicontinuity for linear maps from `E` to `F`. For example `E` and `F` are\nboth normed spaces, you get `NormedSpace.equicontinuous_TFAE`. -/\nprotected theorem _root_.WithSeminorms.equicontinuous_TFAE {Îº : Type*}\n    {q : SeminormFamily ğ•œâ‚‚ F Î¹'} [UniformSpace E] [UniformAddGroup E] [u : UniformSpace F]\n    [hu : UniformAddGroup F] (hq : WithSeminorms q) [ContinuousSMul ğ•œ E]\n    (f : Îº â†’ E â†’â‚›â‚—[Ïƒâ‚â‚‚] F) : TFAE\n    [ EquicontinuousAt ((â†‘) âˆ˜ f) 0,\n      Equicontinuous ((â†‘) âˆ˜ f),\n      UniformEquicontinuous ((â†‘) âˆ˜ f),\n      âˆ€ i, âˆƒ p : Seminorm ğ•œ E, Continuous p âˆ§ âˆ€ k, (q i).comp (f k) â‰¤ p,\n      âˆ€ i, BddAbove (range fun k â†¦ (q i).comp (f k)) âˆ§ Continuous (â¨† k, (q i).comp (f k)) ] := by\n  -- We start by reducing to the case where the target is a seminormed space\n  rw [q.withSeminorms_iff_uniformSpace_eq_iInf.mp hq, uniformEquicontinuous_iInf_rng,\n      equicontinuous_iInf_rng, equicontinuousAt_iInf_rng]\n  refine forall_tfae [_, _, _, _, _] fun i â†¦ ?_\n  let _ : SeminormedAddCommGroup F := (q i).toSeminormedAddCommGroup\n  clear u hu hq\n  -- Now we can prove the equivalence in this setting\n  simp only [List.map]\n  tfae_have 1 â†’ 3 := uniformEquicontinuous_of_equicontinuousAt_zero f\n  tfae_have 3 â†’ 2 := UniformEquicontinuous.equicontinuous\n  tfae_have 2 â†’ 1 := fun H â†¦ H 0\n  tfae_have 3 â†’ 5\n  | H => by\n    have : âˆ€á¶  x in ğ“ 0, âˆ€ k, q i (f k x) â‰¤ 1 := by\n      filter_upwards [Metric.equicontinuousAt_iff_right.mp (H.equicontinuous 0) 1 one_pos]\n        with x hx k\n      simpa using (hx k).le\n    have bdd : BddAbove (range fun k â†¦ (q i).comp (f k)) :=\n      Seminorm.bddAbove_of_absorbent (absorbent_nhds_zero this)\n        (fun x hx â†¦ âŸ¨1, forall_mem_range.mpr hxâŸ©)\n    rw [â† Seminorm.coe_iSup_eq bdd]\n    refine âŸ¨bdd, Seminorm.continuous' (r := 1) ?_âŸ©\n    filter_upwards [this] with x hx\n    simpa only [closedBall_iSup bdd _ one_pos, mem_iInter, mem_closedBall_zero] using hx\n  tfae_have 5 â†’ 4 := fun H â†¦ âŸ¨â¨† k, (q i).comp (f k), Seminorm.coe_iSup_eq H.1 â–¸ H.2, le_ciSup H.1âŸ©\n  tfae_have 4 â†’ 1 -- This would work over any `NormedField`\n  | âŸ¨p, hp, hfpâŸ© =>\n    Metric.equicontinuousAt_of_continuity_modulus p (map_zero p â–¸ hp.tendsto 0) _ <|\n      Eventually.of_forall fun x k â†¦ by simpa using hfp k x\n  tfae_finish\n\n"}
{"name":"WithSeminorms.uniformEquicontinuous_iff_exists_continuous_seminorm","module":"Mathlib.Analysis.LocallyConvex.WithSeminorms","initialProofState":"ğ•œ : Type u_1\nğ•œâ‚‚ : Type u_2\nE : Type u_5\nF : Type u_6\nÎ¹' : Type u_9\ninstâœÂ¹Â¹ : NontriviallyNormedField ğ•œ\ninstâœÂ¹â° : AddCommGroup E\ninstâœâ¹ : Module ğ•œ E\ninstâœâ¸ : NontriviallyNormedField ğ•œâ‚‚\ninstâœâ· : AddCommGroup F\ninstâœâ¶ : Module ğ•œâ‚‚ F\nÏƒâ‚â‚‚ : RingHom ğ•œ ğ•œâ‚‚\ninstâœâµ : RingHomIsometric Ïƒâ‚â‚‚\ninstâœâ´ : Nonempty Î¹'\nÎº : Type u_10\nq : SeminormFamily ğ•œâ‚‚ F Î¹'\ninstâœÂ³ : UniformSpace E\ninstâœÂ² : UniformAddGroup E\nu : UniformSpace F\ninstâœÂ¹ : UniformAddGroup F\nhq : WithSeminorms q\ninstâœ : ContinuousSMul ğ•œ E\nf : Îº â†’ LinearMap Ïƒâ‚â‚‚ E F\nâŠ¢ Iff (UniformEquicontinuous (Function.comp DFunLike.coe f)) (âˆ€ (i : Î¹'), Exists fun p => And (Continuous â‡‘p) (âˆ€ (k : Îº), LE.le ((q i).comp (f k)) p))","decl":"theorem _root_.WithSeminorms.uniformEquicontinuous_iff_exists_continuous_seminorm {Îº : Type*}\n    {q : SeminormFamily ğ•œâ‚‚ F Î¹'} [UniformSpace E] [UniformAddGroup E] [u : UniformSpace F]\n    [UniformAddGroup F] (hq : WithSeminorms q) [ContinuousSMul ğ•œ E]\n    (f : Îº â†’ E â†’â‚›â‚—[Ïƒâ‚â‚‚] F) :\n    UniformEquicontinuous ((â†‘) âˆ˜ f) â†”\n    âˆ€ i, âˆƒ p : Seminorm ğ•œ E, Continuous p âˆ§ âˆ€ k, (q i).comp (f k) â‰¤ p :=\n  (hq.equicontinuous_TFAE f).out 2 3\n\n"}
{"name":"WithSeminorms.uniformEquicontinuous_iff_bddAbove_and_continuous_iSup","module":"Mathlib.Analysis.LocallyConvex.WithSeminorms","initialProofState":"ğ•œ : Type u_1\nğ•œâ‚‚ : Type u_2\nE : Type u_5\nF : Type u_6\nÎ¹' : Type u_9\ninstâœÂ¹Â¹ : NontriviallyNormedField ğ•œ\ninstâœÂ¹â° : AddCommGroup E\ninstâœâ¹ : Module ğ•œ E\ninstâœâ¸ : NontriviallyNormedField ğ•œâ‚‚\ninstâœâ· : AddCommGroup F\ninstâœâ¶ : Module ğ•œâ‚‚ F\nÏƒâ‚â‚‚ : RingHom ğ•œ ğ•œâ‚‚\ninstâœâµ : RingHomIsometric Ïƒâ‚â‚‚\ninstâœâ´ : Nonempty Î¹'\nÎº : Type u_10\nq : SeminormFamily ğ•œâ‚‚ F Î¹'\ninstâœÂ³ : UniformSpace E\ninstâœÂ² : UniformAddGroup E\nu : UniformSpace F\ninstâœÂ¹ : UniformAddGroup F\nhq : WithSeminorms q\ninstâœ : ContinuousSMul ğ•œ E\nf : Îº â†’ LinearMap Ïƒâ‚â‚‚ E F\nâŠ¢ Iff (UniformEquicontinuous (Function.comp DFunLike.coe f)) (âˆ€ (i : Î¹'), And (BddAbove (Set.range fun k => (q i).comp (f k))) (Continuous (iSup fun k => â‡‘((q i).comp (f k)))))","decl":"theorem _root_.WithSeminorms.uniformEquicontinuous_iff_bddAbove_and_continuous_iSup {Îº : Type*}\n    {q : SeminormFamily ğ•œâ‚‚ F Î¹'} [UniformSpace E] [UniformAddGroup E] [u : UniformSpace F]\n    [UniformAddGroup F] (hq : WithSeminorms q) [ContinuousSMul ğ•œ E]\n    (f : Îº â†’ E â†’â‚›â‚—[Ïƒâ‚â‚‚] F) :\n    UniformEquicontinuous ((â†‘) âˆ˜ f) â†” âˆ€ i,\n    BddAbove (range fun k â†¦ (q i).comp (f k)) âˆ§\n      Continuous (â¨† k, (q i).comp (f k)) :=\n  (hq.equicontinuous_TFAE f).out 2 4\n\n"}
{"name":"WithSeminorms.congr","module":"Mathlib.Analysis.LocallyConvex.WithSeminorms","initialProofState":"ğ•œ : Type u_1\nE : Type u_5\nÎ¹ : Type u_8\nÎ¹' : Type u_9\ninstâœâ´ : Nonempty Î¹\ninstâœÂ³ : Nonempty Î¹'\ninstâœÂ² : NormedField ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module ğ•œ E\np : SeminormFamily ğ•œ E Î¹\nq : SeminormFamily ğ•œ E Î¹'\nt : TopologicalSpace E\nhp : WithSeminorms p\nhpq : Seminorm.IsBounded p q LinearMap.id\nhqp : Seminorm.IsBounded q p LinearMap.id\nâŠ¢ WithSeminorms q","decl":"/-- Two families of seminorms `p` and `q` on the same space generate the same topology\nif each `p i` is bounded by some `C â€¢ Finset.sup s q` and vice-versa.\n\nWe formulate these boundedness assumptions as `Seminorm.IsBounded q p LinearMap.id` (and\nvice-versa) to reuse the API. Furthermore, we don't actually state it as an equality of topologies\nbut as a way to deduce `WithSeminorms q` from `WithSeminorms p`, since this should be more\nuseful in practice. -/\nprotected theorem congr {p : SeminormFamily ğ•œ E Î¹} {q : SeminormFamily ğ•œ E Î¹'}\n    [t : TopologicalSpace E] (hp : WithSeminorms p) (hpq : Seminorm.IsBounded p q LinearMap.id)\n    (hqp : Seminorm.IsBounded q p LinearMap.id) : WithSeminorms q := by\n  constructor\n  rw [hp.topology_eq_withSeminorms]\n  clear hp t\n  refine le_antisymm ?_ ?_ <;>\n  rw [â† continuous_id_iff_le] <;>\n  refine continuous_from_bounded (.mk (topology := _) rfl) (.mk (topology := _) rfl)\n    LinearMap.id (by assumption)\n\n"}
{"name":"WithSeminorms.finset_sups","module":"Mathlib.Analysis.LocallyConvex.WithSeminorms","initialProofState":"ğ•œ : Type u_1\nE : Type u_5\nÎ¹ : Type u_8\ninstâœâ´ : Nonempty Î¹\ninstâœÂ³ : NormedField ğ•œ\ninstâœÂ² : AddCommGroup E\ninstâœÂ¹ : Module ğ•œ E\np : SeminormFamily ğ•œ E Î¹\ninstâœ : TopologicalSpace E\nhp : WithSeminorms p\nâŠ¢ WithSeminorms fun s => s.sup p","decl":"protected theorem finset_sups {p : SeminormFamily ğ•œ E Î¹} [TopologicalSpace E]\n    (hp : WithSeminorms p) : WithSeminorms (fun s : Finset Î¹ â†¦ s.sup p) := by\n  refine hp.congr ?_ ?_\n  Â· intro s\n    refine âŸ¨s, 1, ?_âŸ©\n    rw [one_smul]\n    rfl\n  Â· intro i\n    refine âŸ¨{{i}}, 1, ?_âŸ©\n    rw [Finset.sup_singleton, Finset.sup_singleton, one_smul]\n    rfl\n\n"}
{"name":"WithSeminorms.partial_sups","module":"Mathlib.Analysis.LocallyConvex.WithSeminorms","initialProofState":"ğ•œ : Type u_1\nE : Type u_5\nÎ¹ : Type u_8\ninstâœâ¶ : Nonempty Î¹\ninstâœâµ : NormedField ğ•œ\ninstâœâ´ : AddCommGroup E\ninstâœÂ³ : Module ğ•œ E\ninstâœÂ² : Preorder Î¹\ninstâœÂ¹ : LocallyFiniteOrderBot Î¹\np : SeminormFamily ğ•œ E Î¹\ninstâœ : TopologicalSpace E\nhp : WithSeminorms p\nâŠ¢ WithSeminorms fun i => (Finset.Iic i).sup p","decl":"protected theorem partial_sups [Preorder Î¹] [LocallyFiniteOrderBot Î¹] {p : SeminormFamily ğ•œ E Î¹}\n    [TopologicalSpace E] (hp : WithSeminorms p) : WithSeminorms (fun i â†¦ (Finset.Iic i).sup p) := by\n  refine hp.congr ?_ ?_\n  Â· intro i\n    refine âŸ¨Finset.Iic i, 1, ?_âŸ©\n    rw [one_smul]\n    rfl\n  Â· intro i\n    refine âŸ¨{i}, 1, ?_âŸ©\n    rw [Finset.sup_singleton, one_smul]\n    exact (Finset.le_sup (Finset.mem_Iic.mpr le_rfl) : p i â‰¤ (Finset.Iic i).sup p)\n\n"}
{"name":"WithSeminorms.congr_equiv","module":"Mathlib.Analysis.LocallyConvex.WithSeminorms","initialProofState":"ğ•œ : Type u_1\nE : Type u_5\nÎ¹ : Type u_8\nÎ¹' : Type u_9\ninstâœâ´ : Nonempty Î¹\ninstâœÂ³ : Nonempty Î¹'\ninstâœÂ² : NormedField ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module ğ•œ E\np : SeminormFamily ğ•œ E Î¹\nt : TopologicalSpace E\nhp : WithSeminorms p\ne : Equiv Î¹' Î¹\nâŠ¢ WithSeminorms (Function.comp p â‡‘e)","decl":"protected theorem congr_equiv {p : SeminormFamily ğ•œ E Î¹} [t : TopologicalSpace E]\n    (hp : WithSeminorms p) (e : Î¹' â‰ƒ Î¹) : WithSeminorms (p âˆ˜ e) := by\n  refine hp.congr ?_ ?_ <;>\n  intro i <;>\n  [use {e i}, 1; use {e.symm i}, 1] <;>\n  simp\n\n"}
{"name":"Seminorm.map_eq_zero_of_norm_zero","module":"Mathlib.Analysis.LocallyConvex.WithSeminorms","initialProofState":"ğ•œ : Type u_1\nF : Type u_6\ninstâœÂ² : NontriviallyNormedField ğ•œ\ninstâœÂ¹ : SeminormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nq : Seminorm ğ•œ F\nhq : Continuous â‡‘q\nx : F\nhx : Eq (Norm.norm x) 0\nâŠ¢ Eq (q x) 0","decl":"/-- In a semi-`NormedSpace`, a continuous seminorm is zero on elements of norm `0`. -/\nlemma map_eq_zero_of_norm_zero (q : Seminorm ğ•œ F)\n    (hq : Continuous q) {x : F} (hx : â€–xâ€– = 0) : q x = 0 :=\n  (map_zero q) â–¸\n    ((specializes_iff_mem_closure.mpr <| mem_closure_zero_iff_norm.mpr hx).map hq).eq.symm\n\n"}
{"name":"Seminorm.bound_of_continuous_normedSpace","module":"Mathlib.Analysis.LocallyConvex.WithSeminorms","initialProofState":"ğ•œ : Type u_1\nF : Type u_6\ninstâœÂ² : NontriviallyNormedField ğ•œ\ninstâœÂ¹ : SeminormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nq : Seminorm ğ•œ F\nhq : Continuous â‡‘q\nâŠ¢ Exists fun C => And (LT.lt 0 C) (âˆ€ (x : F), LE.le (q x) (HMul.hMul C (Norm.norm x)))","decl":"/-- Let `F` be a semi-`NormedSpace` over a `NontriviallyNormedField`, and let `q` be a\nseminorm on `F`. If `q` is continuous, then it is uniformly controlled by the norm, that is there\nis some `C > 0` such that `âˆ€ x, q x â‰¤ C * â€–xâ€–`.\nThe continuity ensures boundedness on a ball of some radius `Îµ`. The nontriviality of the\nnorm is then used to rescale any element into an element of norm in `[Îµ/C, Îµ[`, thus with a\ncontrolled image by `q`. The control of `q` at the original element follows by rescaling. -/\nlemma bound_of_continuous_normedSpace (q : Seminorm ğ•œ F)\n    (hq : Continuous q) : âˆƒ C, 0 < C âˆ§ (âˆ€ x : F, q x â‰¤ C * â€–xâ€–) := by\n  have hq' : Tendsto q (ğ“ 0) (ğ“ 0) := map_zero q â–¸ hq.tendsto 0\n  rcases NormedAddCommGroup.nhds_zero_basis_norm_lt.mem_iff.mp (hq' <| Iio_mem_nhds one_pos)\n    with âŸ¨Îµ, Îµ_pos, hÎµâŸ©\n  rcases NormedField.exists_one_lt_norm ğ•œ with âŸ¨c, hcâŸ©\n  have : 0 < â€–câ€– / Îµ := by positivity\n  refine âŸ¨â€–câ€– / Îµ, this, fun x â†¦ ?_âŸ©\n  by_cases hx : â€–xâ€– = 0\n  Â· rw [hx, mul_zero]\n    exact le_of_eq (map_eq_zero_of_norm_zero q hq hx)\n  Â· refine (normSeminorm ğ•œ F).bound_of_shell q Îµ_pos hc (fun x hle hlt â†¦ ?_) hx\n    refine (le_of_lt <| show q x < _ from hÎµ hlt).trans ?_\n    rwa [â† div_le_iffâ‚€' this, one_div_div]\n\n"}
{"name":"Seminorm.bound_of_continuous","module":"Mathlib.Analysis.LocallyConvex.WithSeminorms","initialProofState":"ğ•œ : Type u_1\nE : Type u_5\nÎ¹ : Type u_8\ninstâœÂ³ : NontriviallyNormedField ğ•œ\ninstâœÂ² : AddCommGroup E\ninstâœÂ¹ : Module ğ•œ E\np : SeminormFamily ğ•œ E Î¹\ninstâœ : Nonempty Î¹\nt : TopologicalSpace E\nhp : WithSeminorms p\nq : Seminorm ğ•œ E\nhq : Continuous â‡‘q\nâŠ¢ Exists fun s => Exists fun C => And (Ne C 0) (LE.le q (HSMul.hSMul C (s.sup p)))","decl":"/-- Let `E` be a topological vector space (over a `NontriviallyNormedField`) whose topology is\ngenerated by some family of seminorms `p`, and let `q` be a seminorm on `E`. If `q` is continuous,\nthen it is uniformly controlled by *finitely many* seminorms of `p`, that is there\nis some finset `s` of the index set and some `C > 0` such that `q â‰¤ C â€¢ s.sup p`. -/\nlemma bound_of_continuous [Nonempty Î¹] [t : TopologicalSpace E] (hp : WithSeminorms p)\n    (q : Seminorm ğ•œ E) (hq : Continuous q) :\n    âˆƒ s : Finset Î¹, âˆƒ C : â„â‰¥0, C â‰  0 âˆ§ q â‰¤ C â€¢ s.sup p := by\n  -- The continuity of `q` gives us a finset `s` and a real `Îµ > 0`\n  -- such that `hÎµ : (s.sup p).ball 0 Îµ âŠ† q.ball 0 1`.\n  rcases hp.hasBasis.mem_iff.mp (ball_mem_nhds hq one_pos) with âŸ¨V, hV, hÎµâŸ©\n  rcases p.basisSets_iff.mp hV with âŸ¨s, Îµ, Îµ_pos, rflâŸ©\n  -- Now forget that `E` already had a topology and view it as the (semi)normed space\n  -- `(E, s.sup p)`.\n  clear hp hq t\n  let _ : SeminormedAddCommGroup E := (s.sup p).toSeminormedAddCommGroup\n  let _ : NormedSpace ğ•œ E := { norm_smul_le := fun a b â†¦ le_of_eq (map_smul_eq_mul (s.sup p) a b) }\n  -- The inclusion `hÎµ` tells us exactly that `q` is *still* continuous for this new topology\n  have : Continuous q :=\n    Seminorm.continuous (r := 1) (mem_of_superset (Metric.ball_mem_nhds _ Îµ_pos) hÎµ)\n  -- Hence we can conclude by applying `bound_of_continuous_normedSpace`.\n  rcases bound_of_continuous_normedSpace q this with âŸ¨C, C_pos, hCâŸ©\n  exact âŸ¨s, âŸ¨C, C_pos.leâŸ©, fun H â†¦ C_pos.ne.symm (congr_arg NNReal.toReal H), hCâŸ©\n  -- Note that the key ingredient for this proof is that, by scaling arguments hidden in\n  -- `Seminorm.continuous`, we only have to look at the `q`-ball of radius one, and the `s` we get\n  -- from that will automatically work for all other radii.\n\n"}
{"name":"WithSeminorms.toLocallyConvexSpace","module":"Mathlib.Analysis.LocallyConvex.WithSeminorms","initialProofState":"ğ•œ : Type u_1\nE : Type u_5\nÎ¹ : Type u_8\ninstâœâ· : Nonempty Î¹\ninstâœâ¶ : NormedField ğ•œ\ninstâœâµ : NormedSpace Real ğ•œ\ninstâœâ´ : AddCommGroup E\ninstâœÂ³ : Module ğ•œ E\ninstâœÂ² : Module Real E\ninstâœÂ¹ : IsScalarTower Real ğ•œ E\ninstâœ : TopologicalSpace E\np : SeminormFamily ğ•œ E Î¹\nhp : WithSeminorms p\nâŠ¢ LocallyConvexSpace Real E","decl":"theorem WithSeminorms.toLocallyConvexSpace {p : SeminormFamily ğ•œ E Î¹} (hp : WithSeminorms p) :\n    LocallyConvexSpace â„ E := by\n  have := hp.topologicalAddGroup\n  apply ofBasisZero â„ E id fun s => s âˆˆ p.basisSets\n  Â· rw [hp.1, AddGroupFilterBasis.nhds_eq _, AddGroupFilterBasis.N_zero]\n    exact FilterBasis.hasBasis _\n  Â· intro s hs\n    change s âˆˆ Set.iUnion _ at hs\n    simp_rw [Set.mem_iUnion, Set.mem_singleton_iff] at hs\n    rcases hs with âŸ¨I, r, _, rflâŸ©\n    exact convex_ball _ _ _\n\n"}
{"name":"NormedSpace.toLocallyConvexSpace'","module":"Mathlib.Analysis.LocallyConvex.WithSeminorms","initialProofState":"ğ•œ : Type u_1\nE : Type u_5\ninstâœâµ : NormedField ğ•œ\ninstâœâ´ : NormedSpace Real ğ•œ\ninstâœÂ³ : SeminormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : Module Real E\ninstâœ : IsScalarTower Real ğ•œ E\nâŠ¢ LocallyConvexSpace Real E","decl":"/-- Not an instance since `ğ•œ` can't be inferred. See `NormedSpace.toLocallyConvexSpace` for a\nslightly weaker instance version. -/\ntheorem NormedSpace.toLocallyConvexSpace' [NormedSpace ğ•œ E] [Module â„ E] [IsScalarTower â„ ğ•œ E] :\n    LocallyConvexSpace â„ E :=\n  (norm_withSeminorms ğ•œ E).toLocallyConvexSpace\n\n"}
{"name":"NormedSpace.toLocallyConvexSpace","module":"Mathlib.Analysis.LocallyConvex.WithSeminorms","initialProofState":"E : Type u_5\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : NormedSpace Real E\nâŠ¢ LocallyConvexSpace Real E","decl":"/-- See `NormedSpace.toLocallyConvexSpace'` for a slightly stronger version which is not an\ninstance. -/\ninstance NormedSpace.toLocallyConvexSpace [NormedSpace â„ E] : LocallyConvexSpace â„ E :=\n  NormedSpace.toLocallyConvexSpace' â„\n\n"}
{"name":"SeminormFamily.comp_apply","module":"Mathlib.Analysis.LocallyConvex.WithSeminorms","initialProofState":"ğ•œ : Type u_1\nğ•œâ‚‚ : Type u_2\nE : Type u_5\nF : Type u_6\nÎ¹ : Type u_8\ninstâœâ¶ : NormedField ğ•œ\ninstâœâµ : AddCommGroup E\ninstâœâ´ : Module ğ•œ E\ninstâœÂ³ : NormedField ğ•œâ‚‚\ninstâœÂ² : AddCommGroup F\ninstâœÂ¹ : Module ğ•œâ‚‚ F\nÏƒâ‚â‚‚ : RingHom ğ•œ ğ•œâ‚‚\ninstâœ : RingHomIsometric Ïƒâ‚â‚‚\nq : SeminormFamily ğ•œâ‚‚ F Î¹\ni : Î¹\nf : LinearMap Ïƒâ‚â‚‚ E F\nâŠ¢ Eq (q.comp f i) ((q i).comp f)","decl":"theorem SeminormFamily.comp_apply (q : SeminormFamily ğ•œâ‚‚ F Î¹) (i : Î¹) (f : E â†’â‚›â‚—[Ïƒâ‚â‚‚] F) :\n    q.comp f i = (q i).comp f :=\n  rfl\n\n"}
{"name":"SeminormFamily.finset_sup_comp","module":"Mathlib.Analysis.LocallyConvex.WithSeminorms","initialProofState":"ğ•œ : Type u_1\nğ•œâ‚‚ : Type u_2\nE : Type u_5\nF : Type u_6\nÎ¹ : Type u_8\ninstâœâ¶ : NormedField ğ•œ\ninstâœâµ : AddCommGroup E\ninstâœâ´ : Module ğ•œ E\ninstâœÂ³ : NormedField ğ•œâ‚‚\ninstâœÂ² : AddCommGroup F\ninstâœÂ¹ : Module ğ•œâ‚‚ F\nÏƒâ‚â‚‚ : RingHom ğ•œ ğ•œâ‚‚\ninstâœ : RingHomIsometric Ïƒâ‚â‚‚\nq : SeminormFamily ğ•œâ‚‚ F Î¹\ns : Finset Î¹\nf : LinearMap Ïƒâ‚â‚‚ E F\nâŠ¢ Eq ((s.sup q).comp f) (s.sup (q.comp f))","decl":"theorem SeminormFamily.finset_sup_comp (q : SeminormFamily ğ•œâ‚‚ F Î¹) (s : Finset Î¹)\n    (f : E â†’â‚›â‚—[Ïƒâ‚â‚‚] F) : (s.sup q).comp f = s.sup (q.comp f) := by\n  ext x\n  rw [Seminorm.comp_apply, Seminorm.finset_sup_apply, Seminorm.finset_sup_apply]\n  rfl\n\n"}
{"name":"LinearMap.withSeminorms_induced","module":"Mathlib.Analysis.LocallyConvex.WithSeminorms","initialProofState":"ğ•œ : Type u_1\nğ•œâ‚‚ : Type u_2\nE : Type u_5\nF : Type u_6\nÎ¹ : Type u_8\ninstâœâ· : NormedField ğ•œ\ninstâœâ¶ : AddCommGroup E\ninstâœâµ : Module ğ•œ E\ninstâœâ´ : NormedField ğ•œâ‚‚\ninstâœÂ³ : AddCommGroup F\ninstâœÂ² : Module ğ•œâ‚‚ F\nÏƒâ‚â‚‚ : RingHom ğ•œ ğ•œâ‚‚\ninstâœÂ¹ : RingHomIsometric Ïƒâ‚â‚‚\ninstâœ : TopologicalSpace F\nhÎ¹ : Nonempty Î¹\nq : SeminormFamily ğ•œâ‚‚ F Î¹\nhq : WithSeminorms q\nf : LinearMap Ïƒâ‚â‚‚ E F\nâŠ¢ WithSeminorms (q.comp f)","decl":"theorem LinearMap.withSeminorms_induced [hÎ¹ : Nonempty Î¹] {q : SeminormFamily ğ•œâ‚‚ F Î¹}\n    (hq : WithSeminorms q) (f : E â†’â‚›â‚—[Ïƒâ‚â‚‚] F) :\n    WithSeminorms (topology := induced f inferInstance) (q.comp f) := by\n  have := hq.topologicalAddGroup\n  let _ : TopologicalSpace E := induced f inferInstance\n  have : TopologicalAddGroup E := topologicalAddGroup_induced f\n  rw [(q.comp f).withSeminorms_iff_nhds_eq_iInf, nhds_induced, map_zero,\n    q.withSeminorms_iff_nhds_eq_iInf.mp hq, Filter.comap_iInf]\n  refine iInf_congr fun i => ?_\n  exact Filter.comap_comap\n\n"}
{"name":"Topology.IsInducing.withSeminorms","module":"Mathlib.Analysis.LocallyConvex.WithSeminorms","initialProofState":"ğ•œ : Type u_1\nğ•œâ‚‚ : Type u_2\nE : Type u_5\nF : Type u_6\nÎ¹ : Type u_8\ninstâœâ¸ : NormedField ğ•œ\ninstâœâ· : AddCommGroup E\ninstâœâ¶ : Module ğ•œ E\ninstâœâµ : NormedField ğ•œâ‚‚\ninstâœâ´ : AddCommGroup F\ninstâœÂ³ : Module ğ•œâ‚‚ F\nÏƒâ‚â‚‚ : RingHom ğ•œ ğ•œâ‚‚\ninstâœÂ² : RingHomIsometric Ïƒâ‚â‚‚\ninstâœÂ¹ : TopologicalSpace F\nhÎ¹ : Nonempty Î¹\nq : SeminormFamily ğ•œâ‚‚ F Î¹\nhq : WithSeminorms q\ninstâœ : TopologicalSpace E\nf : LinearMap Ïƒâ‚â‚‚ E F\nhf : Topology.IsInducing â‡‘f\nâŠ¢ WithSeminorms (q.comp f)","decl":"lemma Topology.IsInducing.withSeminorms [hÎ¹ : Nonempty Î¹] {q : SeminormFamily ğ•œâ‚‚ F Î¹}\n    (hq : WithSeminorms q) [TopologicalSpace E] {f : E â†’â‚›â‚—[Ïƒâ‚â‚‚] F} (hf : IsInducing f) :\n    WithSeminorms (q.comp f) := by\n  rw [hf.eq_induced]\n  exact f.withSeminorms_induced hq\n\n"}
{"name":"Inducing.withSeminorms","module":"Mathlib.Analysis.LocallyConvex.WithSeminorms","initialProofState":"ğ•œ : Type u_1\nğ•œâ‚‚ : Type u_2\nE : Type u_5\nF : Type u_6\nÎ¹ : Type u_8\ninstâœâ¸ : NormedField ğ•œ\ninstâœâ· : AddCommGroup E\ninstâœâ¶ : Module ğ•œ E\ninstâœâµ : NormedField ğ•œâ‚‚\ninstâœâ´ : AddCommGroup F\ninstâœÂ³ : Module ğ•œâ‚‚ F\nÏƒâ‚â‚‚ : RingHom ğ•œ ğ•œâ‚‚\ninstâœÂ² : RingHomIsometric Ïƒâ‚â‚‚\ninstâœÂ¹ : TopologicalSpace F\nhÎ¹ : Nonempty Î¹\nq : SeminormFamily ğ•œâ‚‚ F Î¹\nhq : WithSeminorms q\ninstâœ : TopologicalSpace E\nf : LinearMap Ïƒâ‚â‚‚ E F\nhf : Topology.IsInducing â‡‘f\nâŠ¢ WithSeminorms (q.comp f)","decl":"@[deprecated (since := \"2024-10-28\")] alias Inducing.withSeminorms := IsInducing.withSeminorms\n\n"}
{"name":"withSeminorms_iInf","module":"Mathlib.Analysis.LocallyConvex.WithSeminorms","initialProofState":"ğ•œ : Type u_1\nE : Type u_5\nÎ¹ : Type u_8\ninstâœâ´ : NormedField ğ•œ\ninstâœÂ³ : AddCommGroup E\ninstâœÂ² : Module ğ•œ E\nÎº : Î¹ â†’ Type u_10\ninstâœÂ¹ : Nonempty (Sigma fun i => Îº i)\ninstâœ : âˆ€ (i : Î¹), Nonempty (Îº i)\np : (i : Î¹) â†’ SeminormFamily ğ•œ E (Îº i)\nt : Î¹ â†’ TopologicalSpace E\nhp : âˆ€ (i : Î¹), WithSeminorms (p i)\nâŠ¢ WithSeminorms (SeminormFamily.sigma p)","decl":"theorem withSeminorms_iInf {Îº : Î¹ â†’ Type*} [Nonempty ((i : Î¹) Ã— Îº i)] [âˆ€ i, Nonempty (Îº i)]\n    {p : (i : Î¹) â†’ SeminormFamily ğ•œ E (Îº i)} {t : Î¹ â†’ TopologicalSpace E}\n    (hp : âˆ€ i, WithSeminorms (topology := t i) (p i)) :\n    WithSeminorms (topology := â¨… i, t i) (SeminormFamily.sigma p) := by\n  have : âˆ€ i, @TopologicalAddGroup E (t i) _ :=\n    fun i â†¦ @WithSeminorms.topologicalAddGroup _ _ _ _ _ _ _ (t i) _ (hp i)\n  have : @TopologicalAddGroup E (â¨… i, t i) _ := topologicalAddGroup_iInf inferInstance\n  simp_rw [@SeminormFamily.withSeminorms_iff_topologicalSpace_eq_iInf _ _ _ _ _ _ _ (_)] at hp âŠ¢\n  rw [iInf_sigma]\n  exact iInf_congr hp\n\n"}
{"name":"withSeminorms_pi","module":"Mathlib.Analysis.LocallyConvex.WithSeminorms","initialProofState":"ğ•œ : Type u_1\nÎ¹ : Type u_8\ninstâœâµ : NormedField ğ•œ\nÎº : Î¹ â†’ Type u_10\nE : Î¹ â†’ Type u_11\ninstâœâ´ : (i : Î¹) â†’ AddCommGroup (E i)\ninstâœÂ³ : (i : Î¹) â†’ Module ğ•œ (E i)\ninstâœÂ² : (i : Î¹) â†’ TopologicalSpace (E i)\ninstâœÂ¹ : Nonempty (Sigma fun i => Îº i)\ninstâœ : âˆ€ (i : Î¹), Nonempty (Îº i)\np : (i : Î¹) â†’ SeminormFamily ğ•œ (E i) (Îº i)\nhp : âˆ€ (i : Î¹), WithSeminorms (p i)\nâŠ¢ WithSeminorms (SeminormFamily.sigma fun i => (p i).comp (LinearMap.proj i))","decl":"theorem withSeminorms_pi {Îº : Î¹ â†’ Type*} {E : Î¹ â†’ Type*}\n    [âˆ€ i, AddCommGroup (E i)] [âˆ€ i, Module ğ•œ (E i)] [âˆ€ i, TopologicalSpace (E i)]\n    [Nonempty ((i : Î¹) Ã— Îº i)] [âˆ€ i, Nonempty (Îº i)] {p : (i : Î¹) â†’ SeminormFamily ğ•œ (E i) (Îº i)}\n    (hp : âˆ€ i, WithSeminorms (p i)) :\n    WithSeminorms (SeminormFamily.sigma (fun i â†¦ (p i).comp (LinearMap.proj i))) :=\n  withSeminorms_iInf fun i â†¦ (LinearMap.proj i).withSeminorms_induced (hp i)\n\n"}
{"name":"WithSeminorms.firstCountableTopology","module":"Mathlib.Analysis.LocallyConvex.WithSeminorms","initialProofState":"ğ•œ : Type u_1\nE : Type u_5\nÎ¹ : Type u_8\ninstâœâµ : NontriviallyNormedField ğ•œ\ninstâœâ´ : AddCommGroup E\ninstâœÂ³ : Module ğ•œ E\ninstâœÂ² : Nonempty Î¹\ninstâœÂ¹ : Countable Î¹\np : SeminormFamily ğ•œ E Î¹\ninstâœ : TopologicalSpace E\nhp : WithSeminorms p\nâŠ¢ FirstCountableTopology E","decl":"/-- If the topology of a space is induced by a countable family of seminorms, then the topology\nis first countable. -/\ntheorem WithSeminorms.firstCountableTopology (hp : WithSeminorms p) :\n    FirstCountableTopology E := by\n  have := hp.topologicalAddGroup\n  let _ : UniformSpace E := TopologicalAddGroup.toUniformSpace E\n  have : UniformAddGroup E := comm_topologicalAddGroup_is_uniform\n  have : (ğ“ (0 : E)).IsCountablyGenerated := by\n    rw [p.withSeminorms_iff_nhds_eq_iInf.mp hp]\n    exact Filter.iInf.isCountablyGenerated _\n  have : (uniformity E).IsCountablyGenerated := UniformAddGroup.uniformity_countably_generated\n  exact UniformSpace.firstCountableTopology E\n\n"}
{"name":"WithSeminorms.first_countable","module":"Mathlib.Analysis.LocallyConvex.WithSeminorms","initialProofState":"ğ•œ : Type u_1\nE : Type u_5\nÎ¹ : Type u_8\ninstâœâµ : NontriviallyNormedField ğ•œ\ninstâœâ´ : AddCommGroup E\ninstâœÂ³ : Module ğ•œ E\ninstâœÂ² : Nonempty Î¹\ninstâœÂ¹ : Countable Î¹\np : SeminormFamily ğ•œ E Î¹\ninstâœ : TopologicalSpace E\nhp : WithSeminorms p\nâŠ¢ FirstCountableTopology E","decl":"@[deprecated (since := \"2024-11-13\")] alias\nWithSeminorms.first_countable := WithSeminorms.firstCountableTopology\n\n"}
