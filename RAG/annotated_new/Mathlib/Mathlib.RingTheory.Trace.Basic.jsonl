{"name":"Algebra.traceForm_toMatrix_powerBasis","module":"Mathlib.RingTheory.Trace.Basic","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nh : PowerBasis R S\n⊢ Eq ((BilinForm.toMatrix h.basis) (Algebra.traceForm R S)) (Matrix.of fun i j => (Algebra.trace R S) (HPow.hPow h.gen (HAdd.hAdd ↑i ↑j)))","decl":"theorem Algebra.traceForm_toMatrix_powerBasis (h : PowerBasis R S) :\n    BilinForm.toMatrix h.basis (traceForm R S) = of fun i j => trace R S (h.gen ^ (i.1 + j.1)) := by\n  ext; rw [traceForm_toMatrix, of_apply, pow_add, h.basis_eq_pow, h.basis_eq_pow]\n\n"}
{"name":"PowerBasis.trace_gen_eq_nextCoeff_minpoly","module":"Mathlib.RingTheory.Trace.Basic","initialProofState":"S : Type u_2\ninst✝³ : CommRing S\nK : Type u_4\ninst✝² : Field K\ninst✝¹ : Algebra K S\ninst✝ : Nontrivial S\npb : PowerBasis K S\n⊢ Eq ((Algebra.trace K S) pb.gen) (Neg.neg (minpoly K pb.gen).nextCoeff)","decl":"/-- Given `pb : PowerBasis K S`, the trace of `pb.gen` is `-(minpoly K pb.gen).nextCoeff`. -/\ntheorem PowerBasis.trace_gen_eq_nextCoeff_minpoly [Nontrivial S] (pb : PowerBasis K S) :\n    Algebra.trace K S pb.gen = -(minpoly K pb.gen).nextCoeff := by\n  have d_pos : 0 < pb.dim := PowerBasis.dim_pos pb\n  have d_pos' : 0 < (minpoly K pb.gen).natDegree := by simpa\n  haveI : Nonempty (Fin pb.dim) := ⟨⟨0, d_pos⟩⟩\n  rw [trace_eq_matrix_trace pb.basis, trace_eq_neg_charpoly_coeff, charpoly_leftMulMatrix, ←\n    pb.natDegree_minpoly, Fintype.card_fin, ← nextCoeff_of_natDegree_pos d_pos']\n\n"}
{"name":"PowerBasis.trace_gen_eq_sum_roots","module":"Mathlib.RingTheory.Trace.Basic","initialProofState":"S : Type u_2\ninst✝⁵ : CommRing S\nK : Type u_4\ninst✝⁴ : Field K\nF : Type u_6\ninst✝³ : Field F\ninst✝² : Algebra K S\ninst✝¹ : Algebra K F\ninst✝ : Nontrivial S\npb : PowerBasis K S\nhf : Polynomial.Splits (algebraMap K F) (minpoly K pb.gen)\n⊢ Eq ((algebraMap K F) ((Algebra.trace K S) pb.gen)) ((minpoly K pb.gen).aroots F).sum","decl":"/-- Given `pb : PowerBasis K S`, then the trace of `pb.gen` is\n`((minpoly K pb.gen).aroots F).sum`. -/\ntheorem PowerBasis.trace_gen_eq_sum_roots [Nontrivial S] (pb : PowerBasis K S)\n    (hf : (minpoly K pb.gen).Splits (algebraMap K F)) :\n    algebraMap K F (trace K S pb.gen) = ((minpoly K pb.gen).aroots F).sum := by\n  rw [PowerBasis.trace_gen_eq_nextCoeff_minpoly, RingHom.map_neg, ←\n    nextCoeff_map (algebraMap K F).injective,\n    sum_roots_eq_nextCoeff_of_monic_of_split ((minpoly.monic (PowerBasis.isIntegral_gen _)).map _)\n      ((splits_id_iff_splits _).2 hf),\n    neg_neg]\n\n"}
{"name":"IntermediateField.AdjoinSimple.trace_gen_eq_zero","module":"Mathlib.RingTheory.Trace.Basic","initialProofState":"K : Type u_4\nL : Type u_5\ninst✝² : Field K\ninst✝¹ : Field L\ninst✝ : Algebra K L\nx : L\nhx : Not (IsIntegral K x)\n⊢ Eq ((Algebra.trace K (Subtype fun x_1 => Membership.mem (IntermediateField.adjoin K (Singleton.singleton x)) x_1)) (IntermediateField.AdjoinSimple.gen K x)) 0","decl":"theorem trace_gen_eq_zero {x : L} (hx : ¬IsIntegral K x) :\n    Algebra.trace K K⟮x⟯ (AdjoinSimple.gen K x) = 0 := by\n  rw [trace_eq_zero_of_not_exists_basis, LinearMap.zero_apply]\n  contrapose! hx\n  obtain ⟨s, ⟨b⟩⟩ := hx\n  refine .of_mem_of_fg K⟮x⟯.toSubalgebra ?_ x ?_\n  · exact (Submodule.fg_iff_finiteDimensional _).mpr (FiniteDimensional.of_fintype_basis b)\n  · exact subset_adjoin K _ (Set.mem_singleton x)\n\n"}
{"name":"IntermediateField.AdjoinSimple.trace_gen_eq_sum_roots","module":"Mathlib.RingTheory.Trace.Basic","initialProofState":"K : Type u_4\nL : Type u_5\ninst✝⁴ : Field K\ninst✝³ : Field L\ninst✝² : Algebra K L\nF : Type u_6\ninst✝¹ : Field F\ninst✝ : Algebra K F\nx : L\nhf : Polynomial.Splits (algebraMap K F) (minpoly K x)\n⊢ Eq ((algebraMap K F) ((Algebra.trace K (Subtype fun x_1 => Membership.mem (IntermediateField.adjoin K (Singleton.singleton x)) x_1)) (IntermediateField.AdjoinSimple.gen K x))) ((minpoly K x).aroots F).sum","decl":"theorem trace_gen_eq_sum_roots (x : L) (hf : (minpoly K x).Splits (algebraMap K F)) :\n    algebraMap K F (trace K K⟮x⟯ (AdjoinSimple.gen K x)) =\n      ((minpoly K x).aroots F).sum := by\n  have injKxL := (algebraMap K⟮x⟯ L).injective\n  by_cases hx : IsIntegral K x; swap\n  · simp [minpoly.eq_zero hx, trace_gen_eq_zero hx, aroots_def]\n  rw [← adjoin.powerBasis_gen hx, (adjoin.powerBasis hx).trace_gen_eq_sum_roots] <;>\n    rw [adjoin.powerBasis_gen hx, ← minpoly.algebraMap_eq injKxL] <;>\n    try simp only [AdjoinSimple.algebraMap_gen _ _]\n  exact hf\n\n"}
{"name":"trace_eq_trace_adjoin","module":"Mathlib.RingTheory.Trace.Basic","initialProofState":"K : Type u_4\nL : Type u_5\ninst✝³ : Field K\ninst✝² : Field L\ninst✝¹ : Algebra K L\ninst✝ : FiniteDimensional K L\nx : L\n⊢ Eq ((Algebra.trace K L) x) (HSMul.hSMul (Module.finrank (Subtype fun x_1 => Membership.mem (IntermediateField.adjoin K (Singleton.singleton x)) x_1) L) ((Algebra.trace K (Subtype fun x_1 => Membership.mem (IntermediateField.adjoin K (Singleton.singleton x)) x_1)) (IntermediateField.AdjoinSimple.gen K x)))","decl":"theorem trace_eq_trace_adjoin [FiniteDimensional K L] (x : L) :\n    trace K L x = finrank K⟮x⟯ L • trace K K⟮x⟯ (AdjoinSimple.gen K x) := by\n  rw [← trace_trace (S := K⟮x⟯)]\n  conv in x => rw [← AdjoinSimple.algebraMap_gen K x]\n  rw [trace_algebraMap, LinearMap.map_smul_of_tower]\n\n"}
{"name":"trace_adjoinSimpleGen","module":"Mathlib.RingTheory.Trace.Basic","initialProofState":"K : Type u_4\nL : Type u_5\ninst✝² : Field K\ninst✝¹ : Field L\ninst✝ : Algebra K L\nx : L\nhx : IsIntegral K x\n⊢ Eq ((Algebra.trace K (Subtype fun x_1 => Membership.mem (IntermediateField.adjoin K (Singleton.singleton x)) x_1)) (IntermediateField.AdjoinSimple.gen K x)) (Neg.neg (minpoly K x).nextCoeff)","decl":"variable {K} in\n/-- Trace of the generator of a simple adjoin equals negative of the next coefficient of\nits minimal polynomial coefficient. -/\ntheorem trace_adjoinSimpleGen {x : L} (hx : IsIntegral K x) :\n    trace K K⟮x⟯ (AdjoinSimple.gen K x) = -(minpoly K x).nextCoeff := by\n  simpa [minpoly_gen K x] using PowerBasis.trace_gen_eq_nextCoeff_minpoly <| adjoin.powerBasis hx\n\n"}
{"name":"trace_eq_finrank_mul_minpoly_nextCoeff","module":"Mathlib.RingTheory.Trace.Basic","initialProofState":"K : Type u_4\nL : Type u_5\ninst✝³ : Field K\ninst✝² : Field L\ninst✝¹ : Algebra K L\ninst✝ : FiniteDimensional K L\nx : L\n⊢ Eq ((Algebra.trace K L) x) (HMul.hMul (↑(Module.finrank (Subtype fun x_1 => Membership.mem (IntermediateField.adjoin K (Singleton.singleton x)) x_1) L)) (Neg.neg (minpoly K x).nextCoeff))","decl":"theorem trace_eq_finrank_mul_minpoly_nextCoeff [FiniteDimensional K L] (x : L) :\n    trace K L x = finrank K⟮x⟯ L * -(minpoly K x).nextCoeff := by\n  rw [trace_eq_trace_adjoin, trace_adjoinSimpleGen (.of_finite K x), Algebra.smul_def]; rfl\n\n"}
{"name":"trace_eq_sum_roots","module":"Mathlib.RingTheory.Trace.Basic","initialProofState":"K : Type u_4\nL : Type u_5\ninst✝⁵ : Field K\ninst✝⁴ : Field L\ninst✝³ : Algebra K L\nF : Type u_6\ninst✝² : Field F\ninst✝¹ : Algebra K F\ninst✝ : FiniteDimensional K L\nx : L\nhF : Polynomial.Splits (algebraMap K F) (minpoly K x)\n⊢ Eq ((algebraMap K F) ((Algebra.trace K L) x)) (HSMul.hSMul (Module.finrank (Subtype fun x_1 => Membership.mem (IntermediateField.adjoin K (Singleton.singleton x)) x_1) L) ((minpoly K x).aroots F).sum)","decl":"theorem trace_eq_sum_roots [FiniteDimensional K L] {x : L}\n    (hF : (minpoly K x).Splits (algebraMap K F)) :\n    algebraMap K F (Algebra.trace K L x) =\n      finrank K⟮x⟯ L • ((minpoly K x).aroots F).sum := by\n  rw [trace_eq_trace_adjoin K x, Algebra.smul_def, RingHom.map_mul, ← Algebra.smul_def,\n    IntermediateField.AdjoinSimple.trace_gen_eq_sum_roots _ hF, IsScalarTower.algebraMap_smul]\n\n"}
{"name":"Algebra.isIntegral_trace","module":"Mathlib.RingTheory.Trace.Basic","initialProofState":"R : Type u_1\ninst✝⁷ : CommRing R\nL : Type u_5\ninst✝⁶ : Field L\nF : Type u_6\ninst✝⁵ : Field F\ninst✝⁴ : Algebra R L\ninst✝³ : Algebra L F\ninst✝² : Algebra R F\ninst✝¹ : IsScalarTower R L F\ninst✝ : FiniteDimensional L F\nx : F\nhx : IsIntegral R x\n⊢ IsIntegral R ((Algebra.trace L F) x)","decl":"theorem Algebra.isIntegral_trace [FiniteDimensional L F] {x : F} (hx : IsIntegral R x) :\n    IsIntegral R (Algebra.trace L F x) := by\n  have hx' : IsIntegral L x := hx.tower_top\n  rw [← isIntegral_algebraMap_iff (algebraMap L (AlgebraicClosure F)).injective, trace_eq_sum_roots]\n  · refine (IsIntegral.multiset_sum ?_).nsmul _\n    intro y hy\n    rw [mem_roots_map (minpoly.ne_zero hx')] at hy\n    use minpoly R x, minpoly.monic hx\n    rw [← aeval_def] at hy ⊢\n    exact minpoly.aeval_of_isScalarTower R x y hy\n  · apply IsAlgClosed.splits_codomain\n\n"}
{"name":"Algebra.trace_eq_of_algEquiv","module":"Mathlib.RingTheory.Trace.Basic","initialProofState":"A : Type u_7\nB : Type u_8\nC : Type u_9\ninst✝⁴ : CommRing A\ninst✝³ : CommRing B\ninst✝² : CommRing C\ninst✝¹ : Algebra A B\ninst✝ : Algebra A C\ne : AlgEquiv A B C\nx : B\n⊢ Eq ((Algebra.trace A C) (e x)) ((Algebra.trace A B) x)","decl":"lemma Algebra.trace_eq_of_algEquiv {A B C : Type*} [CommRing A] [CommRing B] [CommRing C]\n    [Algebra A B] [Algebra A C] (e : B ≃ₐ[A] C) (x) :\n    Algebra.trace A C (e x) = Algebra.trace A B x := by\n  simp_rw [Algebra.trace_apply, ← LinearMap.trace_conj' _ e.toLinearEquiv]\n  congr; ext; simp [LinearEquiv.conj_apply]\n\n"}
{"name":"Algebra.trace_eq_of_ringEquiv","module":"Mathlib.RingTheory.Trace.Basic","initialProofState":"A : Type u_7\nB : Type u_8\nC : Type u_9\ninst✝⁴ : CommRing A\ninst✝³ : CommRing B\ninst✝² : CommRing C\ninst✝¹ : Algebra A C\ninst✝ : Algebra B C\ne : RingEquiv A B\nhe : Eq ((algebraMap B C).comp ↑e) (algebraMap A C)\nx : C\n⊢ Eq (e ((Algebra.trace A C) x)) ((Algebra.trace B C) x)","decl":"lemma Algebra.trace_eq_of_ringEquiv {A B C : Type*} [CommRing A] [CommRing B] [CommRing C]\n    [Algebra A C] [Algebra B C] (e : A ≃+* B) (he : (algebraMap B C).comp e = algebraMap A C) (x) :\n    e (Algebra.trace A C x) = Algebra.trace B C x := by\n  classical\n  by_cases h : ∃ s : Finset C, Nonempty (Basis s B C)\n  · obtain ⟨s, ⟨b⟩⟩ := h\n    letI : Algebra A B := RingHom.toAlgebra e\n    letI : IsScalarTower A B C := IsScalarTower.of_algebraMap_eq' he.symm\n    rw [Algebra.trace_eq_matrix_trace b,\n      Algebra.trace_eq_matrix_trace (b.mapCoeffs e.symm (by simp [Algebra.smul_def, ← he]))]\n    show e.toAddMonoidHom _ = _\n    rw [AddMonoidHom.map_trace]\n    congr\n    ext i j\n    simp [leftMulMatrix_apply, LinearMap.toMatrix_apply]\n  rw [trace_eq_zero_of_not_exists_basis _ h, trace_eq_zero_of_not_exists_basis,\n    LinearMap.zero_apply, LinearMap.zero_apply, map_zero]\n  intro ⟨s, ⟨b⟩⟩\n  exact h ⟨s, ⟨b.mapCoeffs e (by simp [Algebra.smul_def, ← he])⟩⟩\n\n"}
{"name":"Algebra.trace_eq_of_equiv_equiv","module":"Mathlib.RingTheory.Trace.Basic","initialProofState":"A₁ : Type u_7\nB₁ : Type u_8\nA₂ : Type u_9\nB₂ : Type u_10\ninst✝⁵ : CommRing A₁\ninst✝⁴ : CommRing B₁\ninst✝³ : CommRing A₂\ninst✝² : CommRing B₂\ninst✝¹ : Algebra A₁ B₁\ninst✝ : Algebra A₂ B₂\ne₁ : RingEquiv A₁ A₂\ne₂ : RingEquiv B₁ B₂\nhe : Eq ((algebraMap A₂ B₂).comp ↑e₁) ((↑e₂).comp (algebraMap A₁ B₁))\nx : B₁\n⊢ Eq ((Algebra.trace A₁ B₁) x) (e₁.symm ((Algebra.trace A₂ B₂) (e₂ x)))","decl":"lemma Algebra.trace_eq_of_equiv_equiv {A₁ B₁ A₂ B₂ : Type*} [CommRing A₁] [CommRing B₁]\n    [CommRing A₂] [CommRing B₂] [Algebra A₁ B₁] [Algebra A₂ B₂] (e₁ : A₁ ≃+* A₂) (e₂ : B₁ ≃+* B₂)\n    (he : RingHom.comp (algebraMap A₂ B₂) ↑e₁ = RingHom.comp ↑e₂ (algebraMap A₁ B₁)) (x) :\n    Algebra.trace A₁ B₁ x = e₁.symm (Algebra.trace A₂ B₂ (e₂ x)) := by\n  letI := (RingHom.comp (e₂ : B₁ →+* B₂) (algebraMap A₁ B₁)).toAlgebra\n  let e' : B₁ ≃ₐ[A₁] B₂ := { e₂ with commutes' := fun _ ↦ rfl }\n  rw [← Algebra.trace_eq_of_ringEquiv e₁ he, ← Algebra.trace_eq_of_algEquiv e',\n    RingEquiv.symm_apply_apply]\n  rfl\n\n"}
{"name":"trace_eq_sum_embeddings_gen","module":"Mathlib.RingTheory.Trace.Basic","initialProofState":"K : Type u_4\nL : Type u_5\ninst✝⁴ : Field K\ninst✝³ : Field L\ninst✝² : Algebra K L\nE : Type u_7\ninst✝¹ : Field E\ninst✝ : Algebra K E\npb : PowerBasis K L\nhE : Polynomial.Splits (algebraMap K E) (minpoly K pb.gen)\nhfx : IsSeparable K pb.gen\n⊢ Eq ((algebraMap K E) ((Algebra.trace K L) pb.gen)) (Finset.univ.sum fun σ => σ pb.gen)","decl":"theorem trace_eq_sum_embeddings_gen (pb : PowerBasis K L)\n    (hE : (minpoly K pb.gen).Splits (algebraMap K E)) (hfx : IsSeparable K pb.gen) :\n    algebraMap K E (Algebra.trace K L pb.gen) =\n      (@Finset.univ _ (PowerBasis.AlgHom.fintype pb)).sum fun σ => σ pb.gen := by\n  letI := Classical.decEq E\n  -- Porting note: the following `letI` was not needed.\n  letI : Fintype (L →ₐ[K] E) := PowerBasis.AlgHom.fintype pb\n  rw [pb.trace_gen_eq_sum_roots hE, Fintype.sum_equiv pb.liftEquiv', Finset.sum_mem_multiset,\n    Finset.sum_eq_multiset_sum, Multiset.toFinset_val, Multiset.dedup_eq_self.mpr _,\n    Multiset.map_id]\n  · exact nodup_roots ((separable_map _).mpr hfx)\n  -- Porting note: the following goal does not exist in mathlib3.\n  · exact (fun x => x.1)\n  · intro x; rfl\n  · intro σ\n    rw [PowerBasis.liftEquiv'_apply_coe]\n\n"}
{"name":"sum_embeddings_eq_finrank_mul","module":"Mathlib.RingTheory.Trace.Basic","initialProofState":"K : Type u_4\nL : Type u_5\ninst✝¹¹ : Field K\ninst✝¹⁰ : Field L\ninst✝⁹ : Algebra K L\nF : Type u_6\ninst✝⁸ : Field F\ninst✝⁷ : Algebra L F\ninst✝⁶ : Algebra K F\ninst✝⁵ : IsScalarTower K L F\nE : Type u_7\ninst✝⁴ : Field E\ninst✝³ : Algebra K E\ninst✝² : IsAlgClosed E\ninst✝¹ : FiniteDimensional K F\ninst✝ : Algebra.IsSeparable K F\npb : PowerBasis K L\n⊢ Eq (Finset.univ.sum fun σ => σ ((algebraMap L F) pb.gen)) (HSMul.hSMul (Module.finrank L F) (Finset.univ.sum fun σ => σ pb.gen))","decl":"theorem sum_embeddings_eq_finrank_mul [FiniteDimensional K F] [Algebra.IsSeparable K F]\n    (pb : PowerBasis K L) :\n    ∑ σ : F →ₐ[K] E, σ (algebraMap L F pb.gen) =\n      finrank L F •\n        (@Finset.univ _ (PowerBasis.AlgHom.fintype pb)).sum fun σ : L →ₐ[K] E => σ pb.gen := by\n  haveI : FiniteDimensional L F := FiniteDimensional.right K L F\n  haveI : Algebra.IsSeparable L F := Algebra.isSeparable_tower_top_of_isSeparable K L F\n  letI : Fintype (L →ₐ[K] E) := PowerBasis.AlgHom.fintype pb\n  letI : ∀ f : L →ₐ[K] E, Fintype (haveI := f.toRingHom.toAlgebra; AlgHom L F E) := ?_\n  · rw [Fintype.sum_equiv algHomEquivSigma (fun σ : F →ₐ[K] E => _) fun σ => σ.1 pb.gen, ←\n      Finset.univ_sigma_univ, Finset.sum_sigma, ← Finset.sum_nsmul]\n    · refine Finset.sum_congr rfl fun σ _ => ?_\n      letI : Algebra L E := σ.toRingHom.toAlgebra\n      -- Porting note: `Finset.card_univ` was inside `simp only`.\n      simp only [Finset.sum_const]\n      congr\n      rw [← AlgHom.card L F E]\n      exact Finset.card_univ (α := F →ₐ[L] E)\n    · intro σ\n      simp only [algHomEquivSigma, Equiv.coe_fn_mk, AlgHom.restrictDomain, AlgHom.comp_apply,\n        IsScalarTower.coe_toAlgHom']\n\n"}
{"name":"trace_eq_sum_embeddings","module":"Mathlib.RingTheory.Trace.Basic","initialProofState":"K : Type u_4\nL : Type u_5\ninst✝⁷ : Field K\ninst✝⁶ : Field L\ninst✝⁵ : Algebra K L\nE : Type u_7\ninst✝⁴ : Field E\ninst✝³ : Algebra K E\ninst✝² : IsAlgClosed E\ninst✝¹ : FiniteDimensional K L\ninst✝ : Algebra.IsSeparable K L\nx : L\n⊢ Eq ((algebraMap K E) ((Algebra.trace K L) x)) (Finset.univ.sum fun σ => σ x)","decl":"theorem trace_eq_sum_embeddings [FiniteDimensional K L] [Algebra.IsSeparable K L] {x : L} :\n    algebraMap K E (Algebra.trace K L x) = ∑ σ : L →ₐ[K] E, σ x := by\n  have hx := Algebra.IsSeparable.isIntegral K x\n  let pb := adjoin.powerBasis hx\n  rw [trace_eq_trace_adjoin K x, Algebra.smul_def, RingHom.map_mul, ← adjoin.powerBasis_gen hx,\n    trace_eq_sum_embeddings_gen E pb (IsAlgClosed.splits_codomain _), ← Algebra.smul_def,\n    algebraMap_smul]\n  · exact (sum_embeddings_eq_finrank_mul L E pb).symm\n  · haveI := Algebra.isSeparable_tower_bot_of_isSeparable K K⟮x⟯ L\n    exact Algebra.IsSeparable.isSeparable K _\n\n"}
{"name":"trace_eq_sum_automorphisms","module":"Mathlib.RingTheory.Trace.Basic","initialProofState":"K : Type u_4\nL : Type u_5\ninst✝⁴ : Field K\ninst✝³ : Field L\ninst✝² : Algebra K L\nx : L\ninst✝¹ : FiniteDimensional K L\ninst✝ : IsGalois K L\n⊢ Eq ((algebraMap K L) ((Algebra.trace K L) x)) (Finset.univ.sum fun σ => σ x)","decl":"theorem trace_eq_sum_automorphisms (x : L) [FiniteDimensional K L] [IsGalois K L] :\n    algebraMap K L (Algebra.trace K L x) = ∑ σ : L ≃ₐ[K] L, σ x := by\n  apply NoZeroSMulDivisors.algebraMap_injective L (AlgebraicClosure L)\n  rw [_root_.map_sum (algebraMap L (AlgebraicClosure L))]\n  rw [← Fintype.sum_equiv (Normal.algHomEquivAut K (AlgebraicClosure L) L)]\n  · rw [← trace_eq_sum_embeddings (AlgebraicClosure L) (x := x)]\n    simp only [algebraMap_eq_smul_one, smul_one_smul]\n  · intro σ\n    simp only [Normal.algHomEquivAut, AlgHom.restrictNormal', Equiv.coe_fn_mk,\n      AlgEquiv.coe_ofBijective, AlgHom.restrictNormal_commutes, id.map_eq_id, RingHom.id_apply]\n\n"}
{"name":"Algebra.traceMatrix_apply","module":"Mathlib.RingTheory.Trace.Basic","initialProofState":"κ : Type w\nA : Type u\nB : Type v\ninst✝² : CommRing A\ninst✝¹ : CommRing B\ninst✝ : Algebra A B\nb : κ → B\ni j : κ\n⊢ Eq (Algebra.traceMatrix A b i j) (((Algebra.traceForm A B) (b i)) (b j))","decl":"@[simp]\ntheorem traceMatrix_apply (b : κ → B) (i j) : traceMatrix A b i j = traceForm A B (b i) (b j) :=\n  rfl\n\n"}
{"name":"Algebra.traceMatrix_reindex","module":"Mathlib.RingTheory.Trace.Basic","initialProofState":"κ : Type w\nA : Type u\nB : Type v\ninst✝² : CommRing A\ninst✝¹ : CommRing B\ninst✝ : Algebra A B\nκ' : Type u_7\nb : Basis κ A B\nf : Equiv κ κ'\n⊢ Eq (Algebra.traceMatrix A ⇑(b.reindex f)) ((Matrix.reindex f f) (Algebra.traceMatrix A ⇑b))","decl":"theorem traceMatrix_reindex {κ' : Type*} (b : Basis κ A B) (f : κ ≃ κ') :\n    traceMatrix A (b.reindex f) = reindex f f (traceMatrix A b) := by ext (x y); simp\n\n"}
{"name":"Algebra.traceMatrix_of_matrix_vecMul","module":"Mathlib.RingTheory.Trace.Basic","initialProofState":"κ : Type w\nA : Type u\nB : Type v\ninst✝³ : CommRing A\ninst✝² : CommRing B\ninst✝¹ : Algebra A B\ninst✝ : Fintype κ\nb : κ → B\nP : Matrix κ κ A\n⊢ Eq (Algebra.traceMatrix A (Matrix.vecMul b (P.map ⇑(algebraMap A B)))) (HMul.hMul (HMul.hMul P.transpose (Algebra.traceMatrix A b)) P)","decl":"theorem traceMatrix_of_matrix_vecMul [Fintype κ] (b : κ → B) (P : Matrix κ κ A) :\n    traceMatrix A (b ᵥ* P.map (algebraMap A B)) = Pᵀ * traceMatrix A b * P := by\n  ext (α β)\n  rw [traceMatrix_apply, vecMul, dotProduct, vecMul, dotProduct, Matrix.mul_apply,\n    BilinForm.sum_left,\n    Fintype.sum_congr _ _ fun i : κ =>\n      BilinForm.sum_right _ _ (b i * P.map (algebraMap A B) i α) fun y : κ =>\n        b y * P.map (algebraMap A B) y β,\n    sum_comm]\n  congr; ext x\n  rw [Matrix.mul_apply, sum_mul]\n  congr; ext y\n  rw [map_apply, traceForm_apply, mul_comm (b y), ← smul_def]\n  simp only [id.smul_eq_mul, RingHom.id_apply, map_apply, transpose_apply, LinearMap.map_smulₛₗ,\n    traceForm_apply, Algebra.smul_mul_assoc]\n  rw [mul_comm (b x), ← smul_def]\n  ring_nf\n  rw [mul_assoc]\n  simp [mul_comm]\n\n"}
{"name":"Algebra.traceMatrix_of_matrix_mulVec","module":"Mathlib.RingTheory.Trace.Basic","initialProofState":"κ : Type w\nA : Type u\nB : Type v\ninst✝³ : CommRing A\ninst✝² : CommRing B\ninst✝¹ : Algebra A B\ninst✝ : Fintype κ\nb : κ → B\nP : Matrix κ κ A\n⊢ Eq (Algebra.traceMatrix A ((P.map ⇑(algebraMap A B)).mulVec b)) (HMul.hMul (HMul.hMul P (Algebra.traceMatrix A b)) P.transpose)","decl":"theorem traceMatrix_of_matrix_mulVec [Fintype κ] (b : κ → B) (P : Matrix κ κ A) :\n    traceMatrix A (P.map (algebraMap A B) *ᵥ b) = P * traceMatrix A b * Pᵀ := by\n  refine AddEquiv.injective (transposeAddEquiv κ κ A) ?_\n  rw [transposeAddEquiv_apply, transposeAddEquiv_apply, ← vecMul_transpose, ← transpose_map,\n    traceMatrix_of_matrix_vecMul, transpose_transpose]\n\n"}
{"name":"Algebra.traceMatrix_of_basis","module":"Mathlib.RingTheory.Trace.Basic","initialProofState":"κ : Type w\nA : Type u\nB : Type v\ninst✝⁴ : CommRing A\ninst✝³ : CommRing B\ninst✝² : Algebra A B\ninst✝¹ : Fintype κ\ninst✝ : DecidableEq κ\nb : Basis κ A B\n⊢ Eq (Algebra.traceMatrix A ⇑b) ((BilinForm.toMatrix b) (Algebra.traceForm A B))","decl":"theorem traceMatrix_of_basis [Fintype κ] [DecidableEq κ] (b : Basis κ A B) :\n    traceMatrix A b = BilinForm.toMatrix b (traceForm A B) := by\n  ext (i j)\n  rw [traceMatrix_apply, traceForm_apply, traceForm_toMatrix]\n\n"}
{"name":"Algebra.traceMatrix_of_basis_mulVec","module":"Mathlib.RingTheory.Trace.Basic","initialProofState":"ι : Type w\ninst✝³ : Fintype ι\nA : Type u\nB : Type v\ninst✝² : CommRing A\ninst✝¹ : CommRing B\ninst✝ : Algebra A B\nb : Basis ι A B\nz : B\n⊢ Eq ((Algebra.traceMatrix A ⇑b).mulVec (b.equivFun z)) fun i => (Algebra.trace A B) (HMul.hMul z (b i))","decl":"theorem traceMatrix_of_basis_mulVec (b : Basis ι A B) (z : B) :\n    traceMatrix A b *ᵥ b.equivFun z = fun i => trace A B (z * b i) := by\n  ext i\n  rw [← col_apply (ι := Fin 1) (traceMatrix A b *ᵥ b.equivFun z) i 0, col_mulVec,\n    Matrix.mul_apply, traceMatrix]\n  simp only [col_apply, traceForm_apply]\n  conv_lhs =>\n    congr\n    rfl\n    ext\n    rw [mul_comm _ (b.equivFun z _), ← smul_eq_mul, of_apply, ← LinearMap.map_smul]\n  rw [← _root_.map_sum]\n  congr\n  conv_lhs =>\n    congr\n    rfl\n    ext\n    rw [← mul_smul_comm]\n  rw [← Finset.mul_sum, mul_comm z]\n  congr\n  rw [b.sum_equivFun]\n\n"}
{"name":"Algebra.embeddingsMatrix_apply","module":"Mathlib.RingTheory.Trace.Basic","initialProofState":"κ : Type w\nA : Type u\nB : Type v\nC : Type z\ninst✝⁴ : CommRing A\ninst✝³ : CommRing B\ninst✝² : Algebra A B\ninst✝¹ : CommRing C\ninst✝ : Algebra A C\nb : κ → B\ni : κ\nσ : AlgHom A B C\n⊢ Eq (Algebra.embeddingsMatrix A C b i σ) (σ (b i))","decl":"@[simp]\ntheorem embeddingsMatrix_apply (b : κ → B) (i) (σ : B →ₐ[A] C) :\n    embeddingsMatrix A C b i σ = σ (b i) :=\n  rfl\n\n"}
{"name":"Algebra.embeddingsMatrixReindex_eq_vandermonde","module":"Mathlib.RingTheory.Trace.Basic","initialProofState":"A : Type u\nB : Type v\nC : Type z\ninst✝⁴ : CommRing A\ninst✝³ : CommRing B\ninst✝² : Algebra A B\ninst✝¹ : CommRing C\ninst✝ : Algebra A C\npb : PowerBasis A B\ne : Equiv (Fin pb.dim) (AlgHom A B C)\n⊢ Eq (Algebra.embeddingsMatrixReindex A C (⇑pb.basis) e) (Matrix.vandermonde fun i => (e i) pb.gen).transpose","decl":"theorem embeddingsMatrixReindex_eq_vandermonde (pb : PowerBasis A B)\n    (e : Fin pb.dim ≃ (B →ₐ[A] C)) :\n    embeddingsMatrixReindex A C pb.basis e = (vandermonde fun i => e i pb.gen)ᵀ := by\n  ext i j\n  simp [embeddingsMatrixReindex, embeddingsMatrix]\n\n"}
{"name":"Algebra.traceMatrix_eq_embeddingsMatrix_mul_trans","module":"Mathlib.RingTheory.Trace.Basic","initialProofState":"K : Type u_4\nL : Type u_5\ninst✝⁷ : Field K\ninst✝⁶ : Field L\ninst✝⁵ : Algebra K L\nκ : Type w\nE : Type z\ninst✝⁴ : Field E\ninst✝³ : Algebra K E\ninst✝² : Module.Finite K L\ninst✝¹ : Algebra.IsSeparable K L\ninst✝ : IsAlgClosed E\nb : κ → L\n⊢ Eq ((Algebra.traceMatrix K b).map ⇑(algebraMap K E)) (HMul.hMul (Algebra.embeddingsMatrix K E b) (Algebra.embeddingsMatrix K E b).transpose)","decl":"theorem traceMatrix_eq_embeddingsMatrix_mul_trans : (traceMatrix K b).map (algebraMap K E) =\n    embeddingsMatrix K E b * (embeddingsMatrix K E b)ᵀ := by\n  ext (i j); simp [trace_eq_sum_embeddings, embeddingsMatrix, Matrix.mul_apply]\n\n"}
{"name":"Algebra.traceMatrix_eq_embeddingsMatrixReindex_mul_trans","module":"Mathlib.RingTheory.Trace.Basic","initialProofState":"K : Type u_4\nL : Type u_5\ninst✝⁸ : Field K\ninst✝⁷ : Field L\ninst✝⁶ : Algebra K L\nκ : Type w\nE : Type z\ninst✝⁵ : Field E\ninst✝⁴ : Algebra K E\ninst✝³ : Module.Finite K L\ninst✝² : Algebra.IsSeparable K L\ninst✝¹ : IsAlgClosed E\nb : κ → L\ninst✝ : Fintype κ\ne : Equiv κ (AlgHom K L E)\n⊢ Eq ((Algebra.traceMatrix K b).map ⇑(algebraMap K E)) (HMul.hMul (Algebra.embeddingsMatrixReindex K E b e) (Algebra.embeddingsMatrixReindex K E b e).transpose)","decl":"theorem traceMatrix_eq_embeddingsMatrixReindex_mul_trans [Fintype κ] (e : κ ≃ (L →ₐ[K] E)) :\n    (traceMatrix K b).map (algebraMap K E) =\n      embeddingsMatrixReindex K E b e * (embeddingsMatrixReindex K E b e)ᵀ := by\n  rw [traceMatrix_eq_embeddingsMatrix_mul_trans, embeddingsMatrixReindex, reindex_apply,\n    transpose_submatrix, ← submatrix_mul_transpose_submatrix, ← Equiv.coe_refl, Equiv.refl_symm]\n\n"}
{"name":"det_traceMatrix_ne_zero'","module":"Mathlib.RingTheory.Trace.Basic","initialProofState":"K : Type u_4\nL : Type u_5\ninst✝³ : Field K\ninst✝² : Field L\ninst✝¹ : Algebra K L\npb : PowerBasis K L\ninst✝ : Algebra.IsSeparable K L\n⊢ Ne (Algebra.traceMatrix K ⇑pb.basis).det 0","decl":"theorem det_traceMatrix_ne_zero' [Algebra.IsSeparable K L] : det (traceMatrix K pb.basis) ≠ 0 := by\n  suffices algebraMap K (AlgebraicClosure L) (det (traceMatrix K pb.basis)) ≠ 0 by\n    refine mt (fun ht => ?_) this\n    rw [ht, RingHom.map_zero]\n  haveI : FiniteDimensional K L := pb.finite\n  let e : Fin pb.dim ≃ (L →ₐ[K] AlgebraicClosure L) := (Fintype.equivFinOfCardEq ?_).symm\n  · rw [RingHom.map_det, RingHom.mapMatrix_apply,\n      traceMatrix_eq_embeddingsMatrixReindex_mul_trans K _ _ e,\n      embeddingsMatrixReindex_eq_vandermonde, det_mul, det_transpose]\n    refine mt mul_self_eq_zero.mp ?_\n    simp only [det_vandermonde, Finset.prod_eq_zero_iff, not_exists, sub_eq_zero]\n    rintro i ⟨_, j, hij, h⟩\n    exact (Finset.mem_Ioi.mp hij).ne' (e.injective <| pb.algHom_ext h)\n  · rw [AlgHom.card, pb.finrank]\n\n"}
{"name":"det_traceForm_ne_zero","module":"Mathlib.RingTheory.Trace.Basic","initialProofState":"K : Type u_4\nL : Type u_5\ninst✝⁵ : Field K\ninst✝⁴ : Field L\ninst✝³ : Algebra K L\nι : Type w\ninst✝² : Fintype ι\ninst✝¹ : Algebra.IsSeparable K L\ninst✝ : DecidableEq ι\nb : Basis ι K L\n⊢ Ne ((BilinForm.toMatrix b) (Algebra.traceForm K L)).det 0","decl":"theorem det_traceForm_ne_zero [Algebra.IsSeparable K L] [DecidableEq ι] (b : Basis ι K L) :\n    det (BilinForm.toMatrix b (traceForm K L)) ≠ 0 := by\n  haveI : FiniteDimensional K L := FiniteDimensional.of_fintype_basis b\n  let pb : PowerBasis K L := Field.powerBasisOfFiniteOfSeparable _ _\n  rw [← BilinForm.toMatrix_mul_basis_toMatrix pb.basis b, ←\n    det_comm' (pb.basis.toMatrix_mul_toMatrix_flip b) _, ← Matrix.mul_assoc, det_mul]\n  swap; · apply Basis.toMatrix_mul_toMatrix_flip\n  refine\n    mul_ne_zero\n      (isUnit_of_mul_eq_one _ ((b.toMatrix pb.basis)ᵀ * b.toMatrix pb.basis).det ?_).ne_zero ?_\n  · calc\n      (pb.basis.toMatrix b * (pb.basis.toMatrix b)ᵀ).det *\n            ((b.toMatrix pb.basis)ᵀ * b.toMatrix pb.basis).det =\n          (pb.basis.toMatrix b * (b.toMatrix pb.basis * pb.basis.toMatrix b)ᵀ *\n              b.toMatrix pb.basis).det := by\n        simp only [← det_mul, Matrix.mul_assoc, Matrix.transpose_mul]\n      _ = 1 := by\n        simp only [Basis.toMatrix_mul_toMatrix_flip, Matrix.transpose_one, Matrix.mul_one,\n          Matrix.det_one]\n  simpa only [traceMatrix_of_basis] using det_traceMatrix_ne_zero' pb\n\n"}
{"name":"traceForm_nondegenerate","module":"Mathlib.RingTheory.Trace.Basic","initialProofState":"K : Type u_4\nL : Type u_5\ninst✝⁴ : Field K\ninst✝³ : Field L\ninst✝² : Algebra K L\ninst✝¹ : FiniteDimensional K L\ninst✝ : Algebra.IsSeparable K L\n⊢ (Algebra.traceForm K L).Nondegenerate","decl":"/-- Let $L/K$ be a finite extension of fields. If $L/K$ is separable,\nthen `traceForm` is nondegenerate. -/\n@[stacks 0BIL \"(1) => (3)\"]\ntheorem traceForm_nondegenerate [FiniteDimensional K L] [Algebra.IsSeparable K L] :\n    (traceForm K L).Nondegenerate :=\n  BilinForm.nondegenerate_of_det_ne_zero (traceForm K L) _\n    (det_traceForm_ne_zero (Module.finBasis K L))\n\n"}
{"name":"Algebra.trace_ne_zero","module":"Mathlib.RingTheory.Trace.Basic","initialProofState":"K : Type u_4\nL : Type u_5\ninst✝⁴ : Field K\ninst✝³ : Field L\ninst✝² : Algebra K L\ninst✝¹ : FiniteDimensional K L\ninst✝ : Algebra.IsSeparable K L\n⊢ Ne (Algebra.trace K L) 0","decl":"theorem Algebra.trace_ne_zero [FiniteDimensional K L] [Algebra.IsSeparable K L] :\n    Algebra.trace K L ≠ 0 := by\n  intro e\n  let pb : PowerBasis K L := Field.powerBasisOfFiniteOfSeparable _ _\n  apply det_traceMatrix_ne_zero' pb\n  rw [show traceMatrix K pb.basis = 0 by ext; simp [e], Matrix.det_zero]\n  rw [← pb.finrank, ← Fin.pos_iff_nonempty]\n  exact finrank_pos\n\n"}
{"name":"Algebra.trace_surjective","module":"Mathlib.RingTheory.Trace.Basic","initialProofState":"K : Type u_4\nL : Type u_5\ninst✝⁴ : Field K\ninst✝³ : Field L\ninst✝² : Algebra K L\ninst✝¹ : FiniteDimensional K L\ninst✝ : Algebra.IsSeparable K L\n⊢ Function.Surjective ⇑(Algebra.trace K L)","decl":"theorem Algebra.trace_surjective [FiniteDimensional K L] [Algebra.IsSeparable K L] :\n    Function.Surjective (Algebra.trace K L) := by\n  rw [← LinearMap.range_eq_top]\n  apply (IsSimpleOrder.eq_bot_or_eq_top (α := Ideal K) _).resolve_left\n  rw [LinearMap.range_eq_bot]\n  exact Algebra.trace_ne_zero K L\n\n"}
{"name":"traceForm_dualBasis_powerBasis_eq","module":"Mathlib.RingTheory.Trace.Basic","initialProofState":"K : Type u_4\nL : Type u_5\ninst✝⁴ : Field K\ninst✝³ : Field L\ninst✝² : Algebra K L\ninst✝¹ : FiniteDimensional K L\ninst✝ : Algebra.IsSeparable K L\npb : PowerBasis K L\ni : Fin pb.dim\n⊢ Eq (((Algebra.traceForm K L).dualBasis ⋯ pb.basis) i) (HDiv.hDiv ((minpolyDiv K pb.gen).coeff ↑i) ((Polynomial.aeval pb.gen) (Polynomial.derivative (minpoly K pb.gen))))","decl":"/--\nThe dual basis of a powerbasis `{1, x, x²...}` under the trace form is `aᵢ / f'(x)`,\nwith `f` being the minimal polynomial of `x` and `f / (X - x) = ∑ aᵢxⁱ`.\n-/\nlemma traceForm_dualBasis_powerBasis_eq [FiniteDimensional K L] [Algebra.IsSeparable K L]\n    (pb : PowerBasis K L) (i) :\n    (Algebra.traceForm K L).dualBasis (traceForm_nondegenerate K L) pb.basis i =\n      (minpolyDiv K pb.gen).coeff i / aeval pb.gen (derivative <| minpoly K pb.gen) := by\n  classical\n  apply ((Algebra.traceForm K L).toDual (traceForm_nondegenerate K L)).injective\n  apply pb.basis.ext\n  intro j\n  simp only [BilinForm.toDual_def, BilinForm.apply_dualBasis_left]\n  apply (algebraMap K (AlgebraicClosure K)).injective\n  have := congr_arg (coeff · i) (sum_smul_minpolyDiv_eq_X_pow (AlgebraicClosure K)\n    pb.adjoin_gen_eq_top (r := j) (pb.finrank.symm ▸ j.prop))\n  simp only [AlgEquiv.toAlgHom_eq_coe, Polynomial.map_smul, map_div₀,\n    map_pow, RingHom.coe_coe, AlgHom.coe_coe, finset_sum_coeff, coeff_smul, coeff_map, smul_eq_mul,\n    coeff_X_pow, ← Fin.ext_iff, @eq_comm _ i] at this\n  rw [PowerBasis.coe_basis]\n  simp only [RingHom.map_ite_one_zero, traceForm_apply]\n  rw [← this, trace_eq_sum_embeddings (E := AlgebraicClosure K)]\n  apply Finset.sum_congr rfl\n  intro σ _\n  simp only [_root_.map_mul, map_div₀, map_pow]\n  ring\n\n"}
{"name":"Algebra.trace_isNilpotent_of_isNilpotent","module":"Mathlib.RingTheory.Trace.Basic","initialProofState":"R : Type u_7\nS : Type u_8\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nx : S\nhx : IsNilpotent x\n⊢ IsNilpotent ((Algebra.trace R S) x)","decl":"/-- The trace of a nilpotent element is nilpotent. -/\nlemma trace_isNilpotent_of_isNilpotent {R S : Type*} [CommRing R] [CommRing S] [Algebra R S] {x : S}\n    (hx : IsNilpotent x) : IsNilpotent (trace R S x) :=\n  LinearMap.isNilpotent_trace_of_isNilpotent (hx.map (lmul R S))\n\n"}
