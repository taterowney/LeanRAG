{"name":"Basis.finite_ofVectorSpaceIndex_of_rank_lt_aleph0","module":"Mathlib.LinearAlgebra.Dimension.DivisionRing","initialProofState":"K : Type u\nV : Type v\ninst✝² : DivisionRing K\ninst✝¹ : AddCommGroup V\ninst✝ : Module K V\nh : LT.lt (Module.rank K V) Cardinal.aleph0\n⊢ (Basis.ofVectorSpaceIndex K V).Finite","decl":"/-- If a vector space has a finite dimension, the index set of `Basis.ofVectorSpace` is finite. -/\ntheorem Basis.finite_ofVectorSpaceIndex_of_rank_lt_aleph0 (h : Module.rank K V < ℵ₀) :\n    (Basis.ofVectorSpaceIndex K V).Finite :=\n  finite_def.2 <| (Basis.ofVectorSpace K V).nonempty_fintype_index_of_rank_lt_aleph0 h\n\n"}
{"name":"rank_quotient_add_rank_of_divisionRing","module":"Mathlib.LinearAlgebra.Dimension.DivisionRing","initialProofState":"K : Type u\nV : Type v\ninst✝² : DivisionRing K\ninst✝¹ : AddCommGroup V\ninst✝ : Module K V\np : Submodule K V\n⊢ Eq (HAdd.hAdd (Module.rank K (HasQuotient.Quotient V p)) (Module.rank K (Subtype fun x => Membership.mem p x))) (Module.rank K V)","decl":"/-- Also see `rank_quotient_add_rank`. -/\ntheorem rank_quotient_add_rank_of_divisionRing (p : Submodule K V) :\n    Module.rank K (V ⧸ p) + Module.rank K p = Module.rank K V := by\n  classical\n    let ⟨f⟩ := quotient_prod_linearEquiv p\n    exact rank_prod'.symm.trans f.rank_eq\n\n"}
{"name":"DivisionRing.hasRankNullity","module":"Mathlib.LinearAlgebra.Dimension.DivisionRing","initialProofState":"K : Type u\ninst✝ : DivisionRing K\n⊢ HasRankNullity.{u₀, u} K","decl":"instance DivisionRing.hasRankNullity : HasRankNullity.{u₀} K where\n  rank_quotient_add_rank := rank_quotient_add_rank_of_divisionRing\n  exists_set_linearIndependent V _ _ := by\n    let b := Module.Free.chooseBasis K V\n    refine ⟨range b, ?_, b.linearIndependent.to_subtype_range⟩\n    rw [← lift_injective.eq_iff, mk_range_eq_of_injective b.injective,\n      Module.Free.rank_eq_card_chooseBasisIndex]\n\n"}
{"name":"rank_add_rank_split","module":"Mathlib.LinearAlgebra.Dimension.DivisionRing","initialProofState":"K : Type u\nV V₁ V₂ V₃ : Type v\ninst✝⁸ : DivisionRing K\ninst✝⁷ : AddCommGroup V\ninst✝⁶ : Module K V\ninst✝⁵ : AddCommGroup V₁\ninst✝⁴ : Module K V₁\ninst✝³ : AddCommGroup V₂\ninst✝² : Module K V₂\ninst✝¹ : AddCommGroup V₃\ninst✝ : Module K V₃\ndb : LinearMap (RingHom.id K) V₂ V\neb : LinearMap (RingHom.id K) V₃ V\ncd : LinearMap (RingHom.id K) V₁ V₂\nce : LinearMap (RingHom.id K) V₁ V₃\nhde : LE.le Top.top (Max.max (LinearMap.range db) (LinearMap.range eb))\nhgd : Eq (LinearMap.ker cd) Bot.bot\neq : Eq (db.comp cd) (eb.comp ce)\neq₂ : ∀ (d : V₂) (e : V₃), Eq (db d) (eb e) → Exists fun c => And (Eq (cd c) d) (Eq (ce c) e)\n⊢ Eq (HAdd.hAdd (Module.rank K V) (Module.rank K V₁)) (HAdd.hAdd (Module.rank K V₂) (Module.rank K V₃))","decl":"/-- This is mostly an auxiliary lemma for `Submodule.rank_sup_add_rank_inf_eq`. -/\ntheorem rank_add_rank_split (db : V₂ →ₗ[K] V) (eb : V₃ →ₗ[K] V) (cd : V₁ →ₗ[K] V₂)\n    (ce : V₁ →ₗ[K] V₃) (hde : ⊤ ≤ LinearMap.range db ⊔ LinearMap.range eb) (hgd : ker cd = ⊥)\n    (eq : db.comp cd = eb.comp ce) (eq₂ : ∀ d e, db d = eb e → ∃ c, cd c = d ∧ ce c = e) :\n    Module.rank K V + Module.rank K V₁ = Module.rank K V₂ + Module.rank K V₃ := by\n  have hf : Surjective (coprod db eb) := by\n    rwa [← range_eq_top, range_coprod, eq_top_iff]\n  conv =>\n    rhs\n    rw [← rank_prod', rank_eq_of_surjective hf]\n  congr 1\n  apply LinearEquiv.rank_eq\n  let L : V₁ →ₗ[K] ker (coprod db eb) := by -- Porting note: this is needed to avoid a timeout\n    refine LinearMap.codRestrict _ (prod cd (-ce)) ?_\n    · intro c\n      simp only [add_eq_zero_iff_eq_neg, LinearMap.prod_apply, mem_ker, Pi.prod, coprod_apply,\n        neg_neg, map_neg, neg_apply]\n      exact LinearMap.ext_iff.1 eq c\n  refine LinearEquiv.ofBijective L ⟨?_, ?_⟩\n  · rw [← ker_eq_bot, ker_codRestrict, ker_prod, hgd, bot_inf_eq]\n  · rw [← range_eq_top, eq_top_iff, range_codRestrict, ← map_le_iff_le_comap,\n      Submodule.map_top, range_subtype]\n    rintro ⟨d, e⟩\n    have h := eq₂ d (-e)\n    simp only [add_eq_zero_iff_eq_neg, LinearMap.prod_apply, mem_ker, SetLike.mem_coe,\n      Prod.mk.inj_iff, coprod_apply, map_neg, neg_apply, LinearMap.mem_range, Pi.prod] at h ⊢\n    intro hde\n    rcases h hde with ⟨c, h₁, h₂⟩\n    refine ⟨c, h₁, ?_⟩\n    rw [h₂, _root_.neg_neg]\n\n"}
{"name":"linearIndependent_of_top_le_span_of_card_eq_finrank","module":"Mathlib.LinearAlgebra.Dimension.DivisionRing","initialProofState":"K : Type u\nV : Type v\ninst✝³ : DivisionRing K\ninst✝² : AddCommGroup V\ninst✝¹ : Module K V\nι : Type u_2\ninst✝ : Fintype ι\nb : ι → V\nspans : LE.le Top.top (Submodule.span K (Set.range b))\ncard_eq : Eq (Fintype.card ι) (Module.finrank K V)\n⊢ LinearIndependent K b","decl":"theorem linearIndependent_of_top_le_span_of_card_eq_finrank {ι : Type*} [Fintype ι] {b : ι → V}\n    (spans : ⊤ ≤ span K (Set.range b)) (card_eq : Fintype.card ι = finrank K V) :\n    LinearIndependent K b :=\n  linearIndependent_iff'.mpr fun s g dependent i i_mem_s => by\n    classical\n    by_contra gx_ne_zero\n    -- We'll derive a contradiction by showing `b '' (univ \\ {i})` of cardinality `n - 1`\n    -- spans a vector space of dimension `n`.\n    refine not_le_of_gt (span_lt_top_of_card_lt_finrank\n      (show (b '' (Set.univ \\ {i})).toFinset.card < finrank K V from ?_)) ?_\n    · calc\n        (b '' (Set.univ \\ {i})).toFinset.card = ((Set.univ \\ {i}).toFinset.image b).card := by\n          rw [Set.toFinset_card, Fintype.card_ofFinset]\n        _ ≤ (Set.univ \\ {i}).toFinset.card := Finset.card_image_le\n        _ = (Finset.univ.erase i).card := (congr_arg Finset.card (Finset.ext (by simp [and_comm])))\n        _ < Finset.univ.card := Finset.card_erase_lt_of_mem (Finset.mem_univ i)\n        _ = finrank K V := card_eq\n    -- We already have that `b '' univ` spans the whole space,\n    -- so we only need to show that the span of `b '' (univ \\ {i})` contains each `b j`.\n    refine spans.trans (span_le.mpr ?_)\n    rintro _ ⟨j, rfl, rfl⟩\n    -- The case that `j ≠ i` is easy because `b j ∈ b '' (univ \\ {i})`.\n    by_cases j_eq : j = i\n    swap\n    · refine subset_span ⟨j, (Set.mem_diff _).mpr ⟨Set.mem_univ _, ?_⟩, rfl⟩\n      exact mt Set.mem_singleton_iff.mp j_eq\n    -- To show `b i ∈ span (b '' (univ \\ {i}))`, we use that it's a weighted sum\n    -- of the other `b j`s.\n    rw [j_eq, SetLike.mem_coe, show b i = -((g i)⁻¹ • (s.erase i).sum fun j => g j • b j) from _]\n    · refine neg_mem (smul_mem _ _ (sum_mem fun k hk => ?_))\n      obtain ⟨k_ne_i, _⟩ := Finset.mem_erase.mp hk\n      refine smul_mem _ _ (subset_span ⟨k, ?_, rfl⟩)\n      simp_all only [Set.mem_univ, Set.mem_diff, Set.mem_singleton_iff, and_self, not_false_eq_true]\n    -- To show `b i` is a weighted sum of the other `b j`s, we'll rewrite this sum\n    -- to have the form of the assumption `dependent`.\n    apply eq_neg_of_add_eq_zero_left\n    calc\n      (b i + (g i)⁻¹ • (s.erase i).sum fun j => g j • b j) =\n          (g i)⁻¹ • (g i • b i + (s.erase i).sum fun j => g j • b j) := by\n        rw [smul_add, ← mul_smul, inv_mul_cancel₀ gx_ne_zero, one_smul]\n      _ = (g i)⁻¹ • (0 : V) := congr_arg _ ?_\n      _ = 0 := smul_zero _\n    -- And then it's just a bit of manipulation with finite sums.\n    rwa [← Finset.insert_erase i_mem_s, Finset.sum_insert (Finset.not_mem_erase _ _)] at dependent\n\n"}
{"name":"linearIndependent_iff_card_eq_finrank_span","module":"Mathlib.LinearAlgebra.Dimension.DivisionRing","initialProofState":"K : Type u\nV : Type v\ninst✝³ : DivisionRing K\ninst✝² : AddCommGroup V\ninst✝¹ : Module K V\nι : Type u_2\ninst✝ : Fintype ι\nb : ι → V\n⊢ Iff (LinearIndependent K b) (Eq (Fintype.card ι) (Set.finrank K (Set.range b)))","decl":"/-- A finite family of vectors is linearly independent if and only if\nits cardinality equals the dimension of its span. -/\ntheorem linearIndependent_iff_card_eq_finrank_span {ι : Type*} [Fintype ι] {b : ι → V} :\n    LinearIndependent K b ↔ Fintype.card ι = (Set.range b).finrank K := by\n  constructor\n  · intro h\n    exact (finrank_span_eq_card h).symm\n  · intro hc\n    let f := Submodule.subtype (span K (Set.range b))\n    let b' : ι → span K (Set.range b) := fun i =>\n      ⟨b i, mem_span.2 fun p hp => hp (Set.mem_range_self _)⟩\n    have hs : ⊤ ≤ span K (Set.range b') := by\n      intro x\n      have h : span K (f '' Set.range b') = map f (span K (Set.range b')) := span_image f\n      have hf : f '' Set.range b' = Set.range b := by\n        ext x\n        simp [f, b', Set.mem_image, Set.mem_range]\n      rw [hf] at h\n      have hx : (x : V) ∈ span K (Set.range b) := x.property\n      simp_rw [h] at hx\n      simpa [f, mem_map] using hx\n    have hi : LinearMap.ker f = ⊥ := ker_subtype _\n    convert (linearIndependent_of_top_le_span_of_card_eq_finrank hs hc).map' _ hi\n\n"}
{"name":"linearIndependent_iff_card_le_finrank_span","module":"Mathlib.LinearAlgebra.Dimension.DivisionRing","initialProofState":"K : Type u\nV : Type v\ninst✝³ : DivisionRing K\ninst✝² : AddCommGroup V\ninst✝¹ : Module K V\nι : Type u_2\ninst✝ : Fintype ι\nb : ι → V\n⊢ Iff (LinearIndependent K b) (LE.le (Fintype.card ι) (Set.finrank K (Set.range b)))","decl":"theorem linearIndependent_iff_card_le_finrank_span {ι : Type*} [Fintype ι] {b : ι → V} :\n    LinearIndependent K b ↔ Fintype.card ι ≤ (Set.range b).finrank K := by\n  rw [linearIndependent_iff_card_eq_finrank_span, (finrank_range_le_card _).le_iff_eq]\n\n"}
{"name":"coe_basisOfTopLeSpanOfCardEqFinrank","module":"Mathlib.LinearAlgebra.Dimension.DivisionRing","initialProofState":"K : Type u\nV : Type v\ninst✝³ : DivisionRing K\ninst✝² : AddCommGroup V\ninst✝¹ : Module K V\nι : Type u_2\ninst✝ : Fintype ι\nb : ι → V\nle_span : LE.le Top.top (Submodule.span K (Set.range b))\ncard_eq : Eq (Fintype.card ι) (Module.finrank K V)\n⊢ Eq (⇑(basisOfTopLeSpanOfCardEqFinrank b le_span card_eq)) b","decl":"@[simp]\ntheorem coe_basisOfTopLeSpanOfCardEqFinrank {ι : Type*} [Fintype ι] (b : ι → V)\n    (le_span : ⊤ ≤ span K (Set.range b)) (card_eq : Fintype.card ι = finrank K V) :\n    ⇑(basisOfTopLeSpanOfCardEqFinrank b le_span card_eq) = b :=\n  Basis.coe_mk _ _\n\n"}
{"name":"finsetBasisOfTopLeSpanOfCardEqFinrank_repr_apply","module":"Mathlib.LinearAlgebra.Dimension.DivisionRing","initialProofState":"K : Type u\nV : Type v\ninst✝² : DivisionRing K\ninst✝¹ : AddCommGroup V\ninst✝ : Module K V\ns : Finset V\nle_span : LE.le Top.top (Submodule.span K ↑s)\ncard_eq : Eq s.card (Module.finrank K V)\na✝ : V\n⊢ Eq ((finsetBasisOfTopLeSpanOfCardEqFinrank le_span card_eq).repr a✝) (⋯.repr ((LinearMap.codRestrict (Submodule.span K (Set.range Subtype.val)) LinearMap.id ⋯) a✝))","decl":"/-- A finset of `finrank K V` vectors forms a basis if they span the whole space. -/\n@[simps! repr_apply]\nnoncomputable def finsetBasisOfTopLeSpanOfCardEqFinrank {s : Finset V}\n    (le_span : ⊤ ≤ span K (s : Set V)) (card_eq : s.card = finrank K V) : Basis {x // x ∈ s} K V :=\n  basisOfTopLeSpanOfCardEqFinrank ((↑) : ↥(s : Set V) → V)\n    ((@Subtype.range_coe_subtype _ fun x => x ∈ s).symm ▸ le_span)\n    (_root_.trans (Fintype.card_coe _) card_eq)\n\n"}
{"name":"setBasisOfTopLeSpanOfCardEqFinrank_repr_apply","module":"Mathlib.LinearAlgebra.Dimension.DivisionRing","initialProofState":"K : Type u\nV : Type v\ninst✝³ : DivisionRing K\ninst✝² : AddCommGroup V\ninst✝¹ : Module K V\ns : Set V\ninst✝ : Fintype ↑s\nle_span : LE.le Top.top (Submodule.span K s)\ncard_eq : Eq s.toFinset.card (Module.finrank K V)\na✝ : V\n⊢ Eq ((setBasisOfTopLeSpanOfCardEqFinrank le_span card_eq).repr a✝) (⋯.repr ((LinearMap.codRestrict (Submodule.span K (Set.range Subtype.val)) LinearMap.id ⋯) a✝))","decl":"/-- A set of `finrank K V` vectors forms a basis if they span the whole space. -/\n@[simps! repr_apply]\nnoncomputable def setBasisOfTopLeSpanOfCardEqFinrank {s : Set V} [Fintype s]\n    (le_span : ⊤ ≤ span K s) (card_eq : s.toFinset.card = finrank K V) : Basis s K V :=\n  basisOfTopLeSpanOfCardEqFinrank ((↑) : s → V) ((@Subtype.range_coe_subtype _ s).symm ▸ le_span)\n    (_root_.trans s.toFinset_card.symm card_eq)\n\n"}
