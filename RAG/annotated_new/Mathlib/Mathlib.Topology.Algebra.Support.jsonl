{"name":"subset_mulTSupport","module":"Mathlib.Topology.Algebra.Support","initialProofState":"X : Type u_1\nŒ± : Type u_2\ninst‚úù¬π : One Œ±\ninst‚úù : TopologicalSpace X\nf : X ‚Üí Œ±\n‚ä¢ HasSubset.Subset (Function.mulSupport f) (mulTSupport f)","decl":"@[to_additive]\ntheorem subset_mulTSupport (f : X ‚Üí Œ±) : mulSupport f ‚äÜ mulTSupport f :=\n  subset_closure\n\n"}
{"name":"subset_tsupport","module":"Mathlib.Topology.Algebra.Support","initialProofState":"X : Type u_1\nŒ± : Type u_2\ninst‚úù¬π : Zero Œ±\ninst‚úù : TopologicalSpace X\nf : X ‚Üí Œ±\n‚ä¢ HasSubset.Subset (Function.support f) (tsupport f)","decl":"@[to_additive]\ntheorem subset_mulTSupport (f : X ‚Üí Œ±) : mulSupport f ‚äÜ mulTSupport f :=\n  subset_closure\n\n"}
{"name":"isClosed_mulTSupport","module":"Mathlib.Topology.Algebra.Support","initialProofState":"X : Type u_1\nŒ± : Type u_2\ninst‚úù¬π : One Œ±\ninst‚úù : TopologicalSpace X\nf : X ‚Üí Œ±\n‚ä¢ IsClosed (mulTSupport f)","decl":"@[to_additive]\ntheorem isClosed_mulTSupport (f : X ‚Üí Œ±) : IsClosed (mulTSupport f) :=\n  isClosed_closure\n\n"}
{"name":"isClosed_tsupport","module":"Mathlib.Topology.Algebra.Support","initialProofState":"X : Type u_1\nŒ± : Type u_2\ninst‚úù¬π : Zero Œ±\ninst‚úù : TopologicalSpace X\nf : X ‚Üí Œ±\n‚ä¢ IsClosed (tsupport f)","decl":"@[to_additive]\ntheorem isClosed_mulTSupport (f : X ‚Üí Œ±) : IsClosed (mulTSupport f) :=\n  isClosed_closure\n\n"}
{"name":"tsupport_eq_empty_iff","module":"Mathlib.Topology.Algebra.Support","initialProofState":"X : Type u_1\nŒ± : Type u_2\ninst‚úù¬π : Zero Œ±\ninst‚úù : TopologicalSpace X\nf : X ‚Üí Œ±\n‚ä¢ Iff (Eq (tsupport f) EmptyCollection.emptyCollection) (Eq f 0)","decl":"@[to_additive]\ntheorem mulTSupport_eq_empty_iff {f : X ‚Üí Œ±} : mulTSupport f = ‚àÖ ‚Üî f = 1 := by\n  rw [mulTSupport, closure_empty_iff, mulSupport_eq_empty_iff]\n\n"}
{"name":"mulTSupport_eq_empty_iff","module":"Mathlib.Topology.Algebra.Support","initialProofState":"X : Type u_1\nŒ± : Type u_2\ninst‚úù¬π : One Œ±\ninst‚úù : TopologicalSpace X\nf : X ‚Üí Œ±\n‚ä¢ Iff (Eq (mulTSupport f) EmptyCollection.emptyCollection) (Eq f 1)","decl":"@[to_additive]\ntheorem mulTSupport_eq_empty_iff {f : X ‚Üí Œ±} : mulTSupport f = ‚àÖ ‚Üî f = 1 := by\n  rw [mulTSupport, closure_empty_iff, mulSupport_eq_empty_iff]\n\n"}
{"name":"image_eq_one_of_nmem_mulTSupport","module":"Mathlib.Topology.Algebra.Support","initialProofState":"X : Type u_1\nŒ± : Type u_2\ninst‚úù¬π : One Œ±\ninst‚úù : TopologicalSpace X\nf : X ‚Üí Œ±\nx : X\nhx : Not (Membership.mem (mulTSupport f) x)\n‚ä¢ Eq (f x) 1","decl":"@[to_additive]\ntheorem image_eq_one_of_nmem_mulTSupport {f : X ‚Üí Œ±} {x : X} (hx : x ‚àâ mulTSupport f) : f x = 1 :=\n  mulSupport_subset_iff'.mp (subset_mulTSupport f) x hx\n\n"}
{"name":"image_eq_zero_of_nmem_tsupport","module":"Mathlib.Topology.Algebra.Support","initialProofState":"X : Type u_1\nŒ± : Type u_2\ninst‚úù¬π : Zero Œ±\ninst‚úù : TopologicalSpace X\nf : X ‚Üí Œ±\nx : X\nhx : Not (Membership.mem (tsupport f) x)\n‚ä¢ Eq (f x) 0","decl":"@[to_additive]\ntheorem image_eq_one_of_nmem_mulTSupport {f : X ‚Üí Œ±} {x : X} (hx : x ‚àâ mulTSupport f) : f x = 1 :=\n  mulSupport_subset_iff'.mp (subset_mulTSupport f) x hx\n\n"}
{"name":"range_subset_insert_image_mulTSupport","module":"Mathlib.Topology.Algebra.Support","initialProofState":"X : Type u_1\nŒ± : Type u_2\ninst‚úù¬π : One Œ±\ninst‚úù : TopologicalSpace X\nf : X ‚Üí Œ±\n‚ä¢ HasSubset.Subset (Set.range f) (Insert.insert 1 (Set.image f (mulTSupport f)))","decl":"@[to_additive]\ntheorem range_subset_insert_image_mulTSupport (f : X ‚Üí Œ±) :\n    range f ‚äÜ insert 1 (f '' mulTSupport f) :=\n  (range_subset_insert_image_mulSupport f).trans <|\n    insert_subset_insert <| image_subset _ subset_closure\n\n"}
{"name":"range_subset_insert_image_tsupport","module":"Mathlib.Topology.Algebra.Support","initialProofState":"X : Type u_1\nŒ± : Type u_2\ninst‚úù¬π : Zero Œ±\ninst‚úù : TopologicalSpace X\nf : X ‚Üí Œ±\n‚ä¢ HasSubset.Subset (Set.range f) (Insert.insert 0 (Set.image f (tsupport f)))","decl":"@[to_additive]\ntheorem range_subset_insert_image_mulTSupport (f : X ‚Üí Œ±) :\n    range f ‚äÜ insert 1 (f '' mulTSupport f) :=\n  (range_subset_insert_image_mulSupport f).trans <|\n    insert_subset_insert <| image_subset _ subset_closure\n\n"}
{"name":"range_eq_image_tsupport_or","module":"Mathlib.Topology.Algebra.Support","initialProofState":"X : Type u_1\nŒ± : Type u_2\ninst‚úù¬π : Zero Œ±\ninst‚úù : TopologicalSpace X\nf : X ‚Üí Œ±\n‚ä¢ Or (Eq (Set.range f) (Set.image f (tsupport f))) (Eq (Set.range f) (Insert.insert 0 (Set.image f (tsupport f))))","decl":"@[to_additive]\ntheorem range_eq_image_mulTSupport_or (f : X ‚Üí Œ±) :\n    range f = f '' mulTSupport f ‚à® range f = insert 1 (f '' mulTSupport f) :=\n  (wcovBy_insert _ _).eq_or_eq (image_subset_range _ _) (range_subset_insert_image_mulTSupport f)\n\n"}
{"name":"range_eq_image_mulTSupport_or","module":"Mathlib.Topology.Algebra.Support","initialProofState":"X : Type u_1\nŒ± : Type u_2\ninst‚úù¬π : One Œ±\ninst‚úù : TopologicalSpace X\nf : X ‚Üí Œ±\n‚ä¢ Or (Eq (Set.range f) (Set.image f (mulTSupport f))) (Eq (Set.range f) (Insert.insert 1 (Set.image f (mulTSupport f))))","decl":"@[to_additive]\ntheorem range_eq_image_mulTSupport_or (f : X ‚Üí Œ±) :\n    range f = f '' mulTSupport f ‚à® range f = insert 1 (f '' mulTSupport f) :=\n  (wcovBy_insert _ _).eq_or_eq (image_subset_range _ _) (range_subset_insert_image_mulTSupport f)\n\n"}
{"name":"tsupport_mul_subset_left","module":"Mathlib.Topology.Algebra.Support","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\nŒ± : Type u_9\ninst‚úù : MulZeroClass Œ±\nf g : X ‚Üí Œ±\n‚ä¢ HasSubset.Subset (tsupport fun x => HMul.hMul (f x) (g x)) (tsupport f)","decl":"theorem tsupport_mul_subset_left {Œ± : Type*} [MulZeroClass Œ±] {f g : X ‚Üí Œ±} :\n    (tsupport fun x => f x * g x) ‚äÜ tsupport f :=\n  closure_mono (support_mul_subset_left _ _)\n\n"}
{"name":"tsupport_mul_subset_right","module":"Mathlib.Topology.Algebra.Support","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\nŒ± : Type u_9\ninst‚úù : MulZeroClass Œ±\nf g : X ‚Üí Œ±\n‚ä¢ HasSubset.Subset (tsupport fun x => HMul.hMul (f x) (g x)) (tsupport g)","decl":"theorem tsupport_mul_subset_right {Œ± : Type*} [MulZeroClass Œ±] {f g : X ‚Üí Œ±} :\n    (tsupport fun x => f x * g x) ‚äÜ tsupport g :=\n  closure_mono (support_mul_subset_right _ _)\n\n"}
{"name":"tsupport_smul_subset_left","module":"Mathlib.Topology.Algebra.Support","initialProofState":"X : Type u_1\nM : Type u_9\nŒ± : Type u_10\ninst‚úù¬≥ : TopologicalSpace X\ninst‚úù¬≤ : Zero M\ninst‚úù¬π : Zero Œ±\ninst‚úù : SMulWithZero M Œ±\nf : X ‚Üí M\ng : X ‚Üí Œ±\n‚ä¢ HasSubset.Subset (tsupport fun x => HSMul.hSMul (f x) (g x)) (tsupport f)","decl":"theorem tsupport_smul_subset_left {M Œ±} [TopologicalSpace X] [Zero M] [Zero Œ±] [SMulWithZero M Œ±]\n    (f : X ‚Üí M) (g : X ‚Üí Œ±) : (tsupport fun x => f x ‚Ä¢ g x) ‚äÜ tsupport f :=\n  closure_mono <| support_smul_subset_left f g\n\n"}
{"name":"tsupport_smul_subset_right","module":"Mathlib.Topology.Algebra.Support","initialProofState":"X : Type u_1\nM : Type u_9\nŒ± : Type u_10\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : Zero Œ±\ninst‚úù : SMulZeroClass M Œ±\nf : X ‚Üí M\ng : X ‚Üí Œ±\n‚ä¢ HasSubset.Subset (tsupport fun x => HSMul.hSMul (f x) (g x)) (tsupport g)","decl":"theorem tsupport_smul_subset_right {M Œ±} [TopologicalSpace X] [Zero Œ±] [SMulZeroClass M Œ±]\n    (f : X ‚Üí M) (g : X ‚Üí Œ±) : (tsupport fun x => f x ‚Ä¢ g x) ‚äÜ tsupport g :=\n  closure_mono <| support_smul_subset_right f g\n\n"}
{"name":"mulTSupport_mul","module":"Mathlib.Topology.Algebra.Support","initialProofState":"X : Type u_1\nŒ± : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : Monoid Œ±\nf g : X ‚Üí Œ±\n‚ä¢ HasSubset.Subset (mulTSupport fun x => HMul.hMul (f x) (g x)) (Union.union (mulTSupport f) (mulTSupport g))","decl":"@[to_additive]\ntheorem mulTSupport_mul [TopologicalSpace X] [Monoid Œ±] {f g : X ‚Üí Œ±} :\n    (mulTSupport fun x ‚Ü¶ f x * g x) ‚äÜ mulTSupport f ‚à™ mulTSupport g :=\n  closure_minimal\n    ((mulSupport_mul f g).trans (union_subset_union (subset_mulTSupport _) (subset_mulTSupport _)))\n    (isClosed_closure.union isClosed_closure)\n\n"}
{"name":"tsupport_add","module":"Mathlib.Topology.Algebra.Support","initialProofState":"X : Type u_1\nŒ± : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : AddMonoid Œ±\nf g : X ‚Üí Œ±\n‚ä¢ HasSubset.Subset (tsupport fun x => HAdd.hAdd (f x) (g x)) (Union.union (tsupport f) (tsupport g))","decl":"@[to_additive]\ntheorem mulTSupport_mul [TopologicalSpace X] [Monoid Œ±] {f g : X ‚Üí Œ±} :\n    (mulTSupport fun x ‚Ü¶ f x * g x) ‚äÜ mulTSupport f ‚à™ mulTSupport g :=\n  closure_minimal\n    ((mulSupport_mul f g).trans (union_subset_union (subset_mulTSupport _) (subset_mulTSupport _)))\n    (isClosed_closure.union isClosed_closure)\n\n"}
{"name":"not_mem_mulTSupport_iff_eventuallyEq","module":"Mathlib.Topology.Algebra.Support","initialProofState":"Œ± : Type u_2\nŒ≤ : Type u_4\ninst‚úù¬π : TopologicalSpace Œ±\ninst‚úù : One Œ≤\nf : Œ± ‚Üí Œ≤\nx : Œ±\n‚ä¢ Iff (Not (Membership.mem (mulTSupport f) x)) ((nhds x).EventuallyEq f 1)","decl":"@[to_additive]\ntheorem not_mem_mulTSupport_iff_eventuallyEq : x ‚àâ mulTSupport f ‚Üî f =·∂†[ùìù x] 1 := by\n  simp_rw [mulTSupport, mem_closure_iff_nhds, not_forall, not_nonempty_iff_eq_empty, exists_prop,\n    ‚Üê disjoint_iff_inter_eq_empty, disjoint_mulSupport_iff, eventuallyEq_iff_exists_mem]\n\n"}
{"name":"not_mem_tsupport_iff_eventuallyEq","module":"Mathlib.Topology.Algebra.Support","initialProofState":"Œ± : Type u_2\nŒ≤ : Type u_4\ninst‚úù¬π : TopologicalSpace Œ±\ninst‚úù : Zero Œ≤\nf : Œ± ‚Üí Œ≤\nx : Œ±\n‚ä¢ Iff (Not (Membership.mem (tsupport f) x)) ((nhds x).EventuallyEq f 0)","decl":"@[to_additive]\ntheorem not_mem_mulTSupport_iff_eventuallyEq : x ‚àâ mulTSupport f ‚Üî f =·∂†[ùìù x] 1 := by\n  simp_rw [mulTSupport, mem_closure_iff_nhds, not_forall, not_nonempty_iff_eq_empty, exists_prop,\n    ‚Üê disjoint_iff_inter_eq_empty, disjoint_mulSupport_iff, eventuallyEq_iff_exists_mem]\n\n"}
{"name":"continuous_of_mulTSupport","module":"Mathlib.Topology.Algebra.Support","initialProofState":"Œ± : Type u_2\nŒ≤ : Type u_4\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : One Œ≤\ninst‚úù : TopologicalSpace Œ≤\nf : Œ± ‚Üí Œ≤\nhf : ‚àÄ (x : Œ±), Membership.mem (mulTSupport f) x ‚Üí ContinuousAt f x\n‚ä¢ Continuous f","decl":"@[to_additive]\ntheorem continuous_of_mulTSupport [TopologicalSpace Œ≤] {f : Œ± ‚Üí Œ≤}\n    (hf : ‚àÄ x ‚àà mulTSupport f, ContinuousAt f x) : Continuous f :=\n  continuous_iff_continuousAt.2 fun x => (em _).elim (hf x) fun hx =>\n    (@continuousAt_const _ _ _ _ _ 1).congr (not_mem_mulTSupport_iff_eventuallyEq.mp hx).symm\n\n"}
{"name":"continuous_of_tsupport","module":"Mathlib.Topology.Algebra.Support","initialProofState":"Œ± : Type u_2\nŒ≤ : Type u_4\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : Zero Œ≤\ninst‚úù : TopologicalSpace Œ≤\nf : Œ± ‚Üí Œ≤\nhf : ‚àÄ (x : Œ±), Membership.mem (tsupport f) x ‚Üí ContinuousAt f x\n‚ä¢ Continuous f","decl":"@[to_additive]\ntheorem continuous_of_mulTSupport [TopologicalSpace Œ≤] {f : Œ± ‚Üí Œ≤}\n    (hf : ‚àÄ x ‚àà mulTSupport f, ContinuousAt f x) : Continuous f :=\n  continuous_iff_continuousAt.2 fun x => (em _).elim (hf x) fun hx =>\n    (@continuousAt_const _ _ _ _ _ 1).congr (not_mem_mulTSupport_iff_eventuallyEq.mp hx).symm\n\n"}
{"name":"hasCompactSupport_def","module":"Mathlib.Topology.Algebra.Support","initialProofState":"Œ± : Type u_2\nŒ≤ : Type u_4\ninst‚úù¬π : TopologicalSpace Œ±\ninst‚úù : Zero Œ≤\nf : Œ± ‚Üí Œ≤\n‚ä¢ Iff (HasCompactSupport f) (IsCompact (closure (Function.support f)))","decl":"@[to_additive]\ntheorem hasCompactMulSupport_def : HasCompactMulSupport f ‚Üî IsCompact (closure (mulSupport f)) := by\n  rfl\n\n"}
{"name":"hasCompactMulSupport_def","module":"Mathlib.Topology.Algebra.Support","initialProofState":"Œ± : Type u_2\nŒ≤ : Type u_4\ninst‚úù¬π : TopologicalSpace Œ±\ninst‚úù : One Œ≤\nf : Œ± ‚Üí Œ≤\n‚ä¢ Iff (HasCompactMulSupport f) (IsCompact (closure (Function.mulSupport f)))","decl":"@[to_additive]\ntheorem hasCompactMulSupport_def : HasCompactMulSupport f ‚Üî IsCompact (closure (mulSupport f)) := by\n  rfl\n\n"}
{"name":"exists_compact_iff_hasCompactMulSupport","module":"Mathlib.Topology.Algebra.Support","initialProofState":"Œ± : Type u_2\nŒ≤ : Type u_4\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : One Œ≤\nf : Œ± ‚Üí Œ≤\ninst‚úù : R1Space Œ±\n‚ä¢ Iff (Exists fun K => And (IsCompact K) (‚àÄ (x : Œ±), Not (Membership.mem K x) ‚Üí Eq (f x) 1)) (HasCompactMulSupport f)","decl":"@[to_additive]\ntheorem exists_compact_iff_hasCompactMulSupport [R1Space Œ±] :\n    (‚àÉ K : Set Œ±, IsCompact K ‚àß ‚àÄ x, x ‚àâ K ‚Üí f x = 1) ‚Üî HasCompactMulSupport f := by\n  simp_rw [‚Üê nmem_mulSupport, ‚Üê mem_compl_iff, ‚Üê subset_def, compl_subset_compl,\n    hasCompactMulSupport_def, exists_isCompact_superset_iff]\n\n"}
{"name":"exists_compact_iff_hasCompactSupport","module":"Mathlib.Topology.Algebra.Support","initialProofState":"Œ± : Type u_2\nŒ≤ : Type u_4\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : Zero Œ≤\nf : Œ± ‚Üí Œ≤\ninst‚úù : R1Space Œ±\n‚ä¢ Iff (Exists fun K => And (IsCompact K) (‚àÄ (x : Œ±), Not (Membership.mem K x) ‚Üí Eq (f x) 0)) (HasCompactSupport f)","decl":"@[to_additive]\ntheorem exists_compact_iff_hasCompactMulSupport [R1Space Œ±] :\n    (‚àÉ K : Set Œ±, IsCompact K ‚àß ‚àÄ x, x ‚àâ K ‚Üí f x = 1) ‚Üî HasCompactMulSupport f := by\n  simp_rw [‚Üê nmem_mulSupport, ‚Üê mem_compl_iff, ‚Üê subset_def, compl_subset_compl,\n    hasCompactMulSupport_def, exists_isCompact_superset_iff]\n\n"}
{"name":"HasCompactMulSupport.intro","module":"Mathlib.Topology.Algebra.Support","initialProofState":"Œ± : Type u_2\nŒ≤ : Type u_4\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : One Œ≤\nf : Œ± ‚Üí Œ≤\ninst‚úù : R1Space Œ±\nK : Set Œ±\nhK : IsCompact K\nhfK : ‚àÄ (x : Œ±), Not (Membership.mem K x) ‚Üí Eq (f x) 1\n‚ä¢ HasCompactMulSupport f","decl":"@[to_additive]\ntheorem intro [R1Space Œ±] {K : Set Œ±} (hK : IsCompact K)\n    (hfK : ‚àÄ x, x ‚àâ K ‚Üí f x = 1) : HasCompactMulSupport f :=\n  exists_compact_iff_hasCompactMulSupport.mp ‚ü®K, hK, hfK‚ü©\n\n"}
{"name":"HasCompactSupport.intro","module":"Mathlib.Topology.Algebra.Support","initialProofState":"Œ± : Type u_2\nŒ≤ : Type u_4\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : Zero Œ≤\nf : Œ± ‚Üí Œ≤\ninst‚úù : R1Space Œ±\nK : Set Œ±\nhK : IsCompact K\nhfK : ‚àÄ (x : Œ±), Not (Membership.mem K x) ‚Üí Eq (f x) 0\n‚ä¢ HasCompactSupport f","decl":"@[to_additive]\ntheorem intro [R1Space Œ±] {K : Set Œ±} (hK : IsCompact K)\n    (hfK : ‚àÄ x, x ‚àâ K ‚Üí f x = 1) : HasCompactMulSupport f :=\n  exists_compact_iff_hasCompactMulSupport.mp ‚ü®K, hK, hfK‚ü©\n\n"}
{"name":"HasCompactSupport.intro'","module":"Mathlib.Topology.Algebra.Support","initialProofState":"Œ± : Type u_2\nŒ≤ : Type u_4\ninst‚úù¬π : TopologicalSpace Œ±\ninst‚úù : Zero Œ≤\nf : Œ± ‚Üí Œ≤\nK : Set Œ±\nhK : IsCompact K\nh'K : IsClosed K\nhfK : ‚àÄ (x : Œ±), Not (Membership.mem K x) ‚Üí Eq (f x) 0\n‚ä¢ HasCompactSupport f","decl":"@[to_additive]\ntheorem intro' {K : Set Œ±} (hK : IsCompact K) (h'K : IsClosed K)\n    (hfK : ‚àÄ x, x ‚àâ K ‚Üí f x = 1) : HasCompactMulSupport f := by\n  have : mulTSupport f ‚äÜ K := by\n    rw [‚Üê h'K.closure_eq]\n    apply closure_mono (mulSupport_subset_iff'.2 hfK)\n  exact IsCompact.of_isClosed_subset hK ( isClosed_mulTSupport f) this\n\n"}
{"name":"HasCompactMulSupport.intro'","module":"Mathlib.Topology.Algebra.Support","initialProofState":"Œ± : Type u_2\nŒ≤ : Type u_4\ninst‚úù¬π : TopologicalSpace Œ±\ninst‚úù : One Œ≤\nf : Œ± ‚Üí Œ≤\nK : Set Œ±\nhK : IsCompact K\nh'K : IsClosed K\nhfK : ‚àÄ (x : Œ±), Not (Membership.mem K x) ‚Üí Eq (f x) 1\n‚ä¢ HasCompactMulSupport f","decl":"@[to_additive]\ntheorem intro' {K : Set Œ±} (hK : IsCompact K) (h'K : IsClosed K)\n    (hfK : ‚àÄ x, x ‚àâ K ‚Üí f x = 1) : HasCompactMulSupport f := by\n  have : mulTSupport f ‚äÜ K := by\n    rw [‚Üê h'K.closure_eq]\n    apply closure_mono (mulSupport_subset_iff'.2 hfK)\n  exact IsCompact.of_isClosed_subset hK ( isClosed_mulTSupport f) this\n\n"}
{"name":"HasCompactSupport.of_support_subset_isCompact","module":"Mathlib.Topology.Algebra.Support","initialProofState":"Œ± : Type u_2\nŒ≤ : Type u_4\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : Zero Œ≤\nf : Œ± ‚Üí Œ≤\ninst‚úù : R1Space Œ±\nK : Set Œ±\nhK : IsCompact K\nh : HasSubset.Subset (Function.support f) K\n‚ä¢ HasCompactSupport f","decl":"@[to_additive]\ntheorem of_mulSupport_subset_isCompact [R1Space Œ±] {K : Set Œ±}\n    (hK : IsCompact K) (h : mulSupport f ‚äÜ K) : HasCompactMulSupport f :=\n  hK.closure_of_subset h\n\n"}
{"name":"HasCompactMulSupport.of_mulSupport_subset_isCompact","module":"Mathlib.Topology.Algebra.Support","initialProofState":"Œ± : Type u_2\nŒ≤ : Type u_4\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : One Œ≤\nf : Œ± ‚Üí Œ≤\ninst‚úù : R1Space Œ±\nK : Set Œ±\nhK : IsCompact K\nh : HasSubset.Subset (Function.mulSupport f) K\n‚ä¢ HasCompactMulSupport f","decl":"@[to_additive]\ntheorem of_mulSupport_subset_isCompact [R1Space Œ±] {K : Set Œ±}\n    (hK : IsCompact K) (h : mulSupport f ‚äÜ K) : HasCompactMulSupport f :=\n  hK.closure_of_subset h\n\n"}
{"name":"HasCompactSupport.isCompact","module":"Mathlib.Topology.Algebra.Support","initialProofState":"Œ± : Type u_2\nŒ≤ : Type u_4\ninst‚úù¬π : TopologicalSpace Œ±\ninst‚úù : Zero Œ≤\nf : Œ± ‚Üí Œ≤\nhf : HasCompactSupport f\n‚ä¢ IsCompact (tsupport f)","decl":"@[to_additive]\ntheorem isCompact (hf : HasCompactMulSupport f) : IsCompact (mulTSupport f) :=\n  hf\n\n"}
{"name":"HasCompactMulSupport.isCompact","module":"Mathlib.Topology.Algebra.Support","initialProofState":"Œ± : Type u_2\nŒ≤ : Type u_4\ninst‚úù¬π : TopologicalSpace Œ±\ninst‚úù : One Œ≤\nf : Œ± ‚Üí Œ≤\nhf : HasCompactMulSupport f\n‚ä¢ IsCompact (mulTSupport f)","decl":"@[to_additive]\ntheorem isCompact (hf : HasCompactMulSupport f) : IsCompact (mulTSupport f) :=\n  hf\n\n"}
{"name":"hasCompactSupport_iff_eventuallyEq","module":"Mathlib.Topology.Algebra.Support","initialProofState":"Œ± : Type u_2\nŒ≤ : Type u_4\ninst‚úù¬π : TopologicalSpace Œ±\ninst‚úù : Zero Œ≤\nf : Œ± ‚Üí Œ≤\n‚ä¢ Iff (HasCompactSupport f) ((Filter.coclosedCompact Œ±).EventuallyEq f 0)","decl":"@[to_additive]\ntheorem _root_.hasCompactMulSupport_iff_eventuallyEq :\n    HasCompactMulSupport f ‚Üî f =·∂†[coclosedCompact Œ±] 1 :=\n  mem_coclosedCompact_iff.symm\n\n"}
{"name":"hasCompactMulSupport_iff_eventuallyEq","module":"Mathlib.Topology.Algebra.Support","initialProofState":"Œ± : Type u_2\nŒ≤ : Type u_4\ninst‚úù¬π : TopologicalSpace Œ±\ninst‚úù : One Œ≤\nf : Œ± ‚Üí Œ≤\n‚ä¢ Iff (HasCompactMulSupport f) ((Filter.coclosedCompact Œ±).EventuallyEq f 1)","decl":"@[to_additive]\ntheorem _root_.hasCompactMulSupport_iff_eventuallyEq :\n    HasCompactMulSupport f ‚Üî f =·∂†[coclosedCompact Œ±] 1 :=\n  mem_coclosedCompact_iff.symm\n\n"}
{"name":"isCompact_range_of_mulSupport_subset_isCompact","module":"Mathlib.Topology.Algebra.Support","initialProofState":"Œ± : Type u_2\nŒ≤ : Type u_4\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : One Œ≤\nf : Œ± ‚Üí Œ≤\ninst‚úù : TopologicalSpace Œ≤\nhf : Continuous f\nk : Set Œ±\nhk : IsCompact k\nh'f : HasSubset.Subset (Function.mulSupport f) k\n‚ä¢ IsCompact (Set.range f)","decl":"@[to_additive]\ntheorem _root_.isCompact_range_of_mulSupport_subset_isCompact [TopologicalSpace Œ≤]\n    (hf : Continuous f) {k : Set Œ±} (hk : IsCompact k) (h'f : mulSupport f ‚äÜ k) :\n    IsCompact (range f) := by\n  cases' range_eq_image_or_of_mulSupport_subset h'f with h2 h2 <;> rw [h2]\n  exacts [hk.image hf, (hk.image hf).insert 1]\n\n"}
{"name":"isCompact_range_of_support_subset_isCompact","module":"Mathlib.Topology.Algebra.Support","initialProofState":"Œ± : Type u_2\nŒ≤ : Type u_4\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : Zero Œ≤\nf : Œ± ‚Üí Œ≤\ninst‚úù : TopologicalSpace Œ≤\nhf : Continuous f\nk : Set Œ±\nhk : IsCompact k\nh'f : HasSubset.Subset (Function.support f) k\n‚ä¢ IsCompact (Set.range f)","decl":"@[to_additive]\ntheorem _root_.isCompact_range_of_mulSupport_subset_isCompact [TopologicalSpace Œ≤]\n    (hf : Continuous f) {k : Set Œ±} (hk : IsCompact k) (h'f : mulSupport f ‚äÜ k) :\n    IsCompact (range f) := by\n  cases' range_eq_image_or_of_mulSupport_subset h'f with h2 h2 <;> rw [h2]\n  exacts [hk.image hf, (hk.image hf).insert 1]\n\n"}
{"name":"HasCompactSupport.isCompact_range","module":"Mathlib.Topology.Algebra.Support","initialProofState":"Œ± : Type u_2\nŒ≤ : Type u_4\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : Zero Œ≤\nf : Œ± ‚Üí Œ≤\ninst‚úù : TopologicalSpace Œ≤\nh : HasCompactSupport f\nhf : Continuous f\n‚ä¢ IsCompact (Set.range f)","decl":"@[to_additive]\ntheorem isCompact_range [TopologicalSpace Œ≤] (h : HasCompactMulSupport f)\n    (hf : Continuous f) : IsCompact (range f) :=\n  isCompact_range_of_mulSupport_subset_isCompact hf h (subset_mulTSupport f)\n\n"}
{"name":"HasCompactMulSupport.isCompact_range","module":"Mathlib.Topology.Algebra.Support","initialProofState":"Œ± : Type u_2\nŒ≤ : Type u_4\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : One Œ≤\nf : Œ± ‚Üí Œ≤\ninst‚úù : TopologicalSpace Œ≤\nh : HasCompactMulSupport f\nhf : Continuous f\n‚ä¢ IsCompact (Set.range f)","decl":"@[to_additive]\ntheorem isCompact_range [TopologicalSpace Œ≤] (h : HasCompactMulSupport f)\n    (hf : Continuous f) : IsCompact (range f) :=\n  isCompact_range_of_mulSupport_subset_isCompact hf h (subset_mulTSupport f)\n\n"}
{"name":"HasCompactSupport.mono'","module":"Mathlib.Topology.Algebra.Support","initialProofState":"Œ± : Type u_2\nŒ≤ : Type u_4\nŒ≥ : Type u_5\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : Zero Œ≤\ninst‚úù : Zero Œ≥\nf : Œ± ‚Üí Œ≤\nf' : Œ± ‚Üí Œ≥\nhf : HasCompactSupport f\nhff' : HasSubset.Subset (Function.support f') (tsupport f)\n‚ä¢ HasCompactSupport f'","decl":"@[to_additive]\ntheorem mono' {f' : Œ± ‚Üí Œ≥} (hf : HasCompactMulSupport f)\n    (hff' : mulSupport f' ‚äÜ mulTSupport f) : HasCompactMulSupport f' :=\n  IsCompact.of_isClosed_subset hf isClosed_closure <| closure_minimal hff' isClosed_closure\n\n"}
{"name":"HasCompactMulSupport.mono'","module":"Mathlib.Topology.Algebra.Support","initialProofState":"Œ± : Type u_2\nŒ≤ : Type u_4\nŒ≥ : Type u_5\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : One Œ≤\ninst‚úù : One Œ≥\nf : Œ± ‚Üí Œ≤\nf' : Œ± ‚Üí Œ≥\nhf : HasCompactMulSupport f\nhff' : HasSubset.Subset (Function.mulSupport f') (mulTSupport f)\n‚ä¢ HasCompactMulSupport f'","decl":"@[to_additive]\ntheorem mono' {f' : Œ± ‚Üí Œ≥} (hf : HasCompactMulSupport f)\n    (hff' : mulSupport f' ‚äÜ mulTSupport f) : HasCompactMulSupport f' :=\n  IsCompact.of_isClosed_subset hf isClosed_closure <| closure_minimal hff' isClosed_closure\n\n"}
{"name":"HasCompactMulSupport.mono","module":"Mathlib.Topology.Algebra.Support","initialProofState":"Œ± : Type u_2\nŒ≤ : Type u_4\nŒ≥ : Type u_5\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : One Œ≤\ninst‚úù : One Œ≥\nf : Œ± ‚Üí Œ≤\nf' : Œ± ‚Üí Œ≥\nhf : HasCompactMulSupport f\nhff' : HasSubset.Subset (Function.mulSupport f') (Function.mulSupport f)\n‚ä¢ HasCompactMulSupport f'","decl":"@[to_additive]\ntheorem mono {f' : Œ± ‚Üí Œ≥} (hf : HasCompactMulSupport f)\n    (hff' : mulSupport f' ‚äÜ mulSupport f) : HasCompactMulSupport f' :=\n  hf.mono' <| hff'.trans subset_closure\n\n"}
{"name":"HasCompactSupport.mono","module":"Mathlib.Topology.Algebra.Support","initialProofState":"Œ± : Type u_2\nŒ≤ : Type u_4\nŒ≥ : Type u_5\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : Zero Œ≤\ninst‚úù : Zero Œ≥\nf : Œ± ‚Üí Œ≤\nf' : Œ± ‚Üí Œ≥\nhf : HasCompactSupport f\nhff' : HasSubset.Subset (Function.support f') (Function.support f)\n‚ä¢ HasCompactSupport f'","decl":"@[to_additive]\ntheorem mono {f' : Œ± ‚Üí Œ≥} (hf : HasCompactMulSupport f)\n    (hff' : mulSupport f' ‚äÜ mulSupport f) : HasCompactMulSupport f' :=\n  hf.mono' <| hff'.trans subset_closure\n\n"}
{"name":"HasCompactMulSupport.comp_left","module":"Mathlib.Topology.Algebra.Support","initialProofState":"Œ± : Type u_2\nŒ≤ : Type u_4\nŒ≥ : Type u_5\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : One Œ≤\ninst‚úù : One Œ≥\ng : Œ≤ ‚Üí Œ≥\nf : Œ± ‚Üí Œ≤\nhf : HasCompactMulSupport f\nhg : Eq (g 1) 1\n‚ä¢ HasCompactMulSupport (Function.comp g f)","decl":"@[to_additive]\ntheorem comp_left (hf : HasCompactMulSupport f) (hg : g 1 = 1) :\n    HasCompactMulSupport (g ‚àò f) :=\n  hf.mono <| mulSupport_comp_subset hg f\n\n"}
{"name":"HasCompactSupport.comp_left","module":"Mathlib.Topology.Algebra.Support","initialProofState":"Œ± : Type u_2\nŒ≤ : Type u_4\nŒ≥ : Type u_5\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : Zero Œ≤\ninst‚úù : Zero Œ≥\ng : Œ≤ ‚Üí Œ≥\nf : Œ± ‚Üí Œ≤\nhf : HasCompactSupport f\nhg : Eq (g 0) 0\n‚ä¢ HasCompactSupport (Function.comp g f)","decl":"@[to_additive]\ntheorem comp_left (hf : HasCompactMulSupport f) (hg : g 1 = 1) :\n    HasCompactMulSupport (g ‚àò f) :=\n  hf.mono <| mulSupport_comp_subset hg f\n\n"}
{"name":"hasCompactSupport_comp_left","module":"Mathlib.Topology.Algebra.Support","initialProofState":"Œ± : Type u_2\nŒ≤ : Type u_4\nŒ≥ : Type u_5\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : Zero Œ≤\ninst‚úù : Zero Œ≥\ng : Œ≤ ‚Üí Œ≥\nf : Œ± ‚Üí Œ≤\nhg : ‚àÄ {x : Œ≤}, Iff (Eq (g x) 0) (Eq x 0)\n‚ä¢ Iff (HasCompactSupport (Function.comp g f)) (HasCompactSupport f)","decl":"@[to_additive]\ntheorem _root_.hasCompactMulSupport_comp_left (hg : ‚àÄ {x}, g x = 1 ‚Üî x = 1) :\n    HasCompactMulSupport (g ‚àò f) ‚Üî HasCompactMulSupport f := by\n  simp_rw [hasCompactMulSupport_def, mulSupport_comp_eq g (@hg) f]\n\n"}
{"name":"hasCompactMulSupport_comp_left","module":"Mathlib.Topology.Algebra.Support","initialProofState":"Œ± : Type u_2\nŒ≤ : Type u_4\nŒ≥ : Type u_5\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : One Œ≤\ninst‚úù : One Œ≥\ng : Œ≤ ‚Üí Œ≥\nf : Œ± ‚Üí Œ≤\nhg : ‚àÄ {x : Œ≤}, Iff (Eq (g x) 1) (Eq x 1)\n‚ä¢ Iff (HasCompactMulSupport (Function.comp g f)) (HasCompactMulSupport f)","decl":"@[to_additive]\ntheorem _root_.hasCompactMulSupport_comp_left (hg : ‚àÄ {x}, g x = 1 ‚Üî x = 1) :\n    HasCompactMulSupport (g ‚àò f) ‚Üî HasCompactMulSupport f := by\n  simp_rw [hasCompactMulSupport_def, mulSupport_comp_eq g (@hg) f]\n\n"}
{"name":"HasCompactSupport.comp_isClosedEmbedding","module":"Mathlib.Topology.Algebra.Support","initialProofState":"Œ± : Type u_2\nŒ±' : Type u_3\nŒ≤ : Type u_4\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : TopologicalSpace Œ±'\ninst‚úù : Zero Œ≤\nf : Œ± ‚Üí Œ≤\nhf : HasCompactSupport f\ng : Œ±' ‚Üí Œ±\nhg : Topology.IsClosedEmbedding g\n‚ä¢ HasCompactSupport (Function.comp f g)","decl":"@[to_additive]\ntheorem comp_isClosedEmbedding (hf : HasCompactMulSupport f) {g : Œ±' ‚Üí Œ±}\n    (hg : IsClosedEmbedding g) : HasCompactMulSupport (f ‚àò g) := by\n  rw [hasCompactMulSupport_def, Function.mulSupport_comp_eq_preimage]\n  refine IsCompact.of_isClosed_subset (hg.isCompact_preimage hf) isClosed_closure ?_\n  rw [hg.isEmbedding.closure_eq_preimage_closure_image]\n  exact preimage_mono (closure_mono <| image_preimage_subset _ _)\n\n"}
{"name":"HasCompactMulSupport.comp_isClosedEmbedding","module":"Mathlib.Topology.Algebra.Support","initialProofState":"Œ± : Type u_2\nŒ±' : Type u_3\nŒ≤ : Type u_4\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : TopologicalSpace Œ±'\ninst‚úù : One Œ≤\nf : Œ± ‚Üí Œ≤\nhf : HasCompactMulSupport f\ng : Œ±' ‚Üí Œ±\nhg : Topology.IsClosedEmbedding g\n‚ä¢ HasCompactMulSupport (Function.comp f g)","decl":"@[to_additive]\ntheorem comp_isClosedEmbedding (hf : HasCompactMulSupport f) {g : Œ±' ‚Üí Œ±}\n    (hg : IsClosedEmbedding g) : HasCompactMulSupport (f ‚àò g) := by\n  rw [hasCompactMulSupport_def, Function.mulSupport_comp_eq_preimage]\n  refine IsCompact.of_isClosed_subset (hg.isCompact_preimage hf) isClosed_closure ?_\n  rw [hg.isEmbedding.closure_eq_preimage_closure_image]\n  exact preimage_mono (closure_mono <| image_preimage_subset _ _)\n\n"}
{"name":"HasCompactMulSupport.comp_closedEmbedding","module":"Mathlib.Topology.Algebra.Support","initialProofState":"Œ± : Type u_2\nŒ±' : Type u_3\nŒ≤ : Type u_4\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : TopologicalSpace Œ±'\ninst‚úù : One Œ≤\nf : Œ± ‚Üí Œ≤\nhf : HasCompactMulSupport f\ng : Œ±' ‚Üí Œ±\nhg : Topology.IsClosedEmbedding g\n‚ä¢ HasCompactMulSupport (Function.comp f g)","decl":"@[deprecated (since := \"2024-10-20\")]\nalias comp_closedEmbedding := comp_isClosedEmbedding\n\n"}
{"name":"HasCompactMulSupport.comp‚ÇÇ_left","module":"Mathlib.Topology.Algebra.Support","initialProofState":"Œ± : Type u_2\nŒ≤ : Type u_4\nŒ≥ : Type u_5\nŒ¥ : Type u_6\ninst‚úù¬≥ : TopologicalSpace Œ±\ninst‚úù¬≤ : One Œ≤\ninst‚úù¬π : One Œ≥\ninst‚úù : One Œ¥\nf : Œ± ‚Üí Œ≤\nf‚ÇÇ : Œ± ‚Üí Œ≥\nm : Œ≤ ‚Üí Œ≥ ‚Üí Œ¥\nhf : HasCompactMulSupport f\nhf‚ÇÇ : HasCompactMulSupport f‚ÇÇ\nhm : Eq (m 1 1) 1\n‚ä¢ HasCompactMulSupport fun x => m (f x) (f‚ÇÇ x)","decl":"@[to_additive]\ntheorem comp‚ÇÇ_left (hf : HasCompactMulSupport f)\n    (hf‚ÇÇ : HasCompactMulSupport f‚ÇÇ) (hm : m 1 1 = 1) :\n    HasCompactMulSupport fun x => m (f x) (f‚ÇÇ x) := by\n  rw [hasCompactMulSupport_iff_eventuallyEq] at hf hf‚ÇÇ ‚ä¢\n  filter_upwards [hf, hf‚ÇÇ] with x hx hx‚ÇÇ\n  simp_rw [hx, hx‚ÇÇ, Pi.one_apply, hm]\n\n"}
{"name":"HasCompactSupport.comp‚ÇÇ_left","module":"Mathlib.Topology.Algebra.Support","initialProofState":"Œ± : Type u_2\nŒ≤ : Type u_4\nŒ≥ : Type u_5\nŒ¥ : Type u_6\ninst‚úù¬≥ : TopologicalSpace Œ±\ninst‚úù¬≤ : Zero Œ≤\ninst‚úù¬π : Zero Œ≥\ninst‚úù : Zero Œ¥\nf : Œ± ‚Üí Œ≤\nf‚ÇÇ : Œ± ‚Üí Œ≥\nm : Œ≤ ‚Üí Œ≥ ‚Üí Œ¥\nhf : HasCompactSupport f\nhf‚ÇÇ : HasCompactSupport f‚ÇÇ\nhm : Eq (m 0 0) 0\n‚ä¢ HasCompactSupport fun x => m (f x) (f‚ÇÇ x)","decl":"@[to_additive]\ntheorem comp‚ÇÇ_left (hf : HasCompactMulSupport f)\n    (hf‚ÇÇ : HasCompactMulSupport f‚ÇÇ) (hm : m 1 1 = 1) :\n    HasCompactMulSupport fun x => m (f x) (f‚ÇÇ x) := by\n  rw [hasCompactMulSupport_iff_eventuallyEq] at hf hf‚ÇÇ ‚ä¢\n  filter_upwards [hf, hf‚ÇÇ] with x hx hx‚ÇÇ\n  simp_rw [hx, hx‚ÇÇ, Pi.one_apply, hm]\n\n"}
{"name":"HasCompactMulSupport.isCompact_preimage","module":"Mathlib.Topology.Algebra.Support","initialProofState":"Œ± : Type u_2\nŒ≤ : Type u_4\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : One Œ≤\nf : Œ± ‚Üí Œ≤\ninst‚úù : TopologicalSpace Œ≤\nh'f : HasCompactMulSupport f\nhf : Continuous f\nk : Set Œ≤\nhk : IsClosed k\nh'k : Not (Membership.mem k 1)\n‚ä¢ IsCompact (Set.preimage f k)","decl":"@[to_additive]\nlemma isCompact_preimage [TopologicalSpace Œ≤]\n    (h'f : HasCompactMulSupport f) (hf : Continuous f) {k : Set Œ≤} (hk : IsClosed k)\n    (h'k : 1 ‚àâ k) : IsCompact (f ‚Åª¬π' k) := by\n  apply IsCompact.of_isClosed_subset h'f (hk.preimage hf) (fun x hx ‚Ü¶ ?_)\n  apply subset_mulTSupport\n  aesop\n\n"}
{"name":"HasCompactSupport.isCompact_preimage","module":"Mathlib.Topology.Algebra.Support","initialProofState":"Œ± : Type u_2\nŒ≤ : Type u_4\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : Zero Œ≤\nf : Œ± ‚Üí Œ≤\ninst‚úù : TopologicalSpace Œ≤\nh'f : HasCompactSupport f\nhf : Continuous f\nk : Set Œ≤\nhk : IsClosed k\nh'k : Not (Membership.mem k 0)\n‚ä¢ IsCompact (Set.preimage f k)","decl":"@[to_additive]\nlemma isCompact_preimage [TopologicalSpace Œ≤]\n    (h'f : HasCompactMulSupport f) (hf : Continuous f) {k : Set Œ≤} (hk : IsClosed k)\n    (h'k : 1 ‚àâ k) : IsCompact (f ‚Åª¬π' k) := by\n  apply IsCompact.of_isClosed_subset h'f (hk.preimage hf) (fun x hx ‚Ü¶ ?_)\n  apply subset_mulTSupport\n  aesop\n\n"}
{"name":"HasCompactSupport.tsupport_extend_zero_subset","module":"Mathlib.Topology.Algebra.Support","initialProofState":"Œ± : Type u_2\nŒ±' : Type u_3\nŒ≤ : Type u_4\ninst‚úù¬≥ : TopologicalSpace Œ±\ninst‚úù¬≤ : TopologicalSpace Œ±'\ninst‚úù¬π : Zero Œ≤\nf : Œ± ‚Üí Œ≤\ninst‚úù : T2Space Œ±'\nhf : HasCompactSupport f\ng : Œ± ‚Üí Œ±'\ncont : Continuous g\n‚ä¢ HasSubset.Subset (tsupport (Function.extend g f 0)) (Set.image g (tsupport f))","decl":"@[to_additive]\ntheorem mulTSupport_extend_one_subset :\n    mulTSupport (g.extend f 1) ‚äÜ g '' mulTSupport f :=\n  (hf.image cont).isClosed.closure_subset_iff.mpr <|\n    mulSupport_extend_one_subset.trans (image_subset g subset_closure)\n\n"}
{"name":"HasCompactMulSupport.mulTSupport_extend_one_subset","module":"Mathlib.Topology.Algebra.Support","initialProofState":"Œ± : Type u_2\nŒ±' : Type u_3\nŒ≤ : Type u_4\ninst‚úù¬≥ : TopologicalSpace Œ±\ninst‚úù¬≤ : TopologicalSpace Œ±'\ninst‚úù¬π : One Œ≤\nf : Œ± ‚Üí Œ≤\ninst‚úù : T2Space Œ±'\nhf : HasCompactMulSupport f\ng : Œ± ‚Üí Œ±'\ncont : Continuous g\n‚ä¢ HasSubset.Subset (mulTSupport (Function.extend g f 1)) (Set.image g (mulTSupport f))","decl":"@[to_additive]\ntheorem mulTSupport_extend_one_subset :\n    mulTSupport (g.extend f 1) ‚äÜ g '' mulTSupport f :=\n  (hf.image cont).isClosed.closure_subset_iff.mpr <|\n    mulSupport_extend_one_subset.trans (image_subset g subset_closure)\n\n"}
{"name":"HasCompactSupport.extend_zero","module":"Mathlib.Topology.Algebra.Support","initialProofState":"Œ± : Type u_2\nŒ±' : Type u_3\nŒ≤ : Type u_4\ninst‚úù¬≥ : TopologicalSpace Œ±\ninst‚úù¬≤ : TopologicalSpace Œ±'\ninst‚úù¬π : Zero Œ≤\nf : Œ± ‚Üí Œ≤\ninst‚úù : T2Space Œ±'\nhf : HasCompactSupport f\ng : Œ± ‚Üí Œ±'\ncont : Continuous g\n‚ä¢ HasCompactSupport (Function.extend g f 0)","decl":"@[to_additive]\ntheorem extend_one : HasCompactMulSupport (g.extend f 1) :=\n  HasCompactMulSupport.of_mulSupport_subset_isCompact (hf.image cont)\n    (subset_closure.trans <| hf.mulTSupport_extend_one_subset cont)\n\n"}
{"name":"HasCompactMulSupport.extend_one","module":"Mathlib.Topology.Algebra.Support","initialProofState":"Œ± : Type u_2\nŒ±' : Type u_3\nŒ≤ : Type u_4\ninst‚úù¬≥ : TopologicalSpace Œ±\ninst‚úù¬≤ : TopologicalSpace Œ±'\ninst‚úù¬π : One Œ≤\nf : Œ± ‚Üí Œ≤\ninst‚úù : T2Space Œ±'\nhf : HasCompactMulSupport f\ng : Œ± ‚Üí Œ±'\ncont : Continuous g\n‚ä¢ HasCompactMulSupport (Function.extend g f 1)","decl":"@[to_additive]\ntheorem extend_one : HasCompactMulSupport (g.extend f 1) :=\n  HasCompactMulSupport.of_mulSupport_subset_isCompact (hf.image cont)\n    (subset_closure.trans <| hf.mulTSupport_extend_one_subset cont)\n\n"}
{"name":"HasCompactSupport.tsupport_extend_zero","module":"Mathlib.Topology.Algebra.Support","initialProofState":"Œ± : Type u_2\nŒ±' : Type u_3\nŒ≤ : Type u_4\ninst‚úù¬≥ : TopologicalSpace Œ±\ninst‚úù¬≤ : TopologicalSpace Œ±'\ninst‚úù¬π : Zero Œ≤\nf : Œ± ‚Üí Œ≤\ninst‚úù : T2Space Œ±'\nhf : HasCompactSupport f\ng : Œ± ‚Üí Œ±'\ncont : Continuous g\ninj : Function.Injective g\n‚ä¢ Eq (tsupport (Function.extend g f 0)) (Set.image g (tsupport f))","decl":"@[to_additive]\ntheorem mulTSupport_extend_one (inj : g.Injective) :\n    mulTSupport (g.extend f 1) = g '' mulTSupport f :=\n  (hf.mulTSupport_extend_one_subset cont).antisymm <|\n    (image_closure_subset_closure_image cont).trans\n      (closure_mono (mulSupport_extend_one inj).superset)\n\n"}
{"name":"HasCompactMulSupport.mulTSupport_extend_one","module":"Mathlib.Topology.Algebra.Support","initialProofState":"Œ± : Type u_2\nŒ±' : Type u_3\nŒ≤ : Type u_4\ninst‚úù¬≥ : TopologicalSpace Œ±\ninst‚úù¬≤ : TopologicalSpace Œ±'\ninst‚úù¬π : One Œ≤\nf : Œ± ‚Üí Œ≤\ninst‚úù : T2Space Œ±'\nhf : HasCompactMulSupport f\ng : Œ± ‚Üí Œ±'\ncont : Continuous g\ninj : Function.Injective g\n‚ä¢ Eq (mulTSupport (Function.extend g f 1)) (Set.image g (mulTSupport f))","decl":"@[to_additive]\ntheorem mulTSupport_extend_one (inj : g.Injective) :\n    mulTSupport (g.extend f 1) = g '' mulTSupport f :=\n  (hf.mulTSupport_extend_one_subset cont).antisymm <|\n    (image_closure_subset_closure_image cont).trans\n      (closure_mono (mulSupport_extend_one inj).superset)\n\n"}
{"name":"HasCompactMulSupport.continuous_extend_one","module":"Mathlib.Topology.Algebra.Support","initialProofState":"Œ±' : Type u_3\nŒ≤ : Type u_4\ninst‚úù¬≥ : TopologicalSpace Œ±'\ninst‚úù¬≤ : One Œ≤\ninst‚úù¬π : T2Space Œ±'\ninst‚úù : TopologicalSpace Œ≤\nU : Set Œ±'\nhU : IsOpen U\nf : ‚ÜëU ‚Üí Œ≤\ncont : Continuous f\nsupp : HasCompactMulSupport f\n‚ä¢ Continuous (Function.extend Subtype.val f 1)","decl":"@[to_additive]\ntheorem continuous_extend_one [TopologicalSpace Œ≤] {U : Set Œ±'} (hU : IsOpen U) {f : U ‚Üí Œ≤}\n    (cont : Continuous f) (supp : HasCompactMulSupport f) :\n    Continuous (Subtype.val.extend f 1) :=\n  continuous_of_mulTSupport fun x h ‚Ü¶ by\n    rw [show x = ‚Üë(‚ü®x, Subtype.coe_image_subset _ _\n      (supp.mulTSupport_extend_one_subset continuous_subtype_val h)‚ü© : U) by rfl,\n      ‚Üê (hU.isOpenEmbedding_subtypeVal).continuousAt_iff, extend_comp Subtype.val_injective]\n    exact cont.continuousAt\n\n"}
{"name":"HasCompactSupport.continuous_extend_zero","module":"Mathlib.Topology.Algebra.Support","initialProofState":"Œ±' : Type u_3\nŒ≤ : Type u_4\ninst‚úù¬≥ : TopologicalSpace Œ±'\ninst‚úù¬≤ : Zero Œ≤\ninst‚úù¬π : T2Space Œ±'\ninst‚úù : TopologicalSpace Œ≤\nU : Set Œ±'\nhU : IsOpen U\nf : ‚ÜëU ‚Üí Œ≤\ncont : Continuous f\nsupp : HasCompactSupport f\n‚ä¢ Continuous (Function.extend Subtype.val f 0)","decl":"@[to_additive]\ntheorem continuous_extend_one [TopologicalSpace Œ≤] {U : Set Œ±'} (hU : IsOpen U) {f : U ‚Üí Œ≤}\n    (cont : Continuous f) (supp : HasCompactMulSupport f) :\n    Continuous (Subtype.val.extend f 1) :=\n  continuous_of_mulTSupport fun x h ‚Ü¶ by\n    rw [show x = ‚Üë(‚ü®x, Subtype.coe_image_subset _ _\n      (supp.mulTSupport_extend_one_subset continuous_subtype_val h)‚ü© : U) by rfl,\n      ‚Üê (hU.isOpenEmbedding_subtypeVal).continuousAt_iff, extend_comp Subtype.val_injective]\n    exact cont.continuousAt\n\n"}
{"name":"HasCompactMulSupport.is_one_at_infty","module":"Mathlib.Topology.Algebra.Support","initialProofState":"Œ± : Type u_2\nŒ≥ : Type u_5\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : One Œ≥\nf : Œ± ‚Üí Œ≥\ninst‚úù : TopologicalSpace Œ≥\nh : HasCompactMulSupport f\n‚ä¢ Filter.Tendsto f (Filter.cocompact Œ±) (nhds 1)","decl":"/-- If `f` has compact multiplicative support, then `f` tends to 1 at infinity. -/\n@[to_additive \"If `f` has compact support, then `f` tends to zero at infinity.\"]\ntheorem is_one_at_infty {f : Œ± ‚Üí Œ≥} [TopologicalSpace Œ≥]\n    (h : HasCompactMulSupport f) : Tendsto f (cocompact Œ±) (ùìù 1) := by\n  intro N hN\n  rw [mem_map, mem_cocompact']\n  refine ‚ü®mulTSupport f, h.isCompact, ?_‚ü©\n  rw [compl_subset_comm]\n  intro v hv\n  rw [mem_preimage, image_eq_one_of_nmem_mulTSupport hv]\n  exact mem_of_mem_nhds hN\n\n"}
{"name":"HasCompactSupport.is_zero_at_infty","module":"Mathlib.Topology.Algebra.Support","initialProofState":"Œ± : Type u_2\nŒ≥ : Type u_5\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : Zero Œ≥\nf : Œ± ‚Üí Œ≥\ninst‚úù : TopologicalSpace Œ≥\nh : HasCompactSupport f\n‚ä¢ Filter.Tendsto f (Filter.cocompact Œ±) (nhds 0)","decl":"/-- If `f` has compact multiplicative support, then `f` tends to 1 at infinity. -/\n@[to_additive \"If `f` has compact support, then `f` tends to zero at infinity.\"]\ntheorem is_one_at_infty {f : Œ± ‚Üí Œ≥} [TopologicalSpace Œ≥]\n    (h : HasCompactMulSupport f) : Tendsto f (cocompact Œ±) (ùìù 1) := by\n  intro N hN\n  rw [mem_map, mem_cocompact']\n  refine ‚ü®mulTSupport f, h.isCompact, ?_‚ü©\n  rw [compl_subset_comm]\n  intro v hv\n  rw [mem_preimage, image_eq_one_of_nmem_mulTSupport hv]\n  exact mem_of_mem_nhds hN\n\n"}
{"name":"HasCompactSupport.of_compactSpace","module":"Mathlib.Topology.Algebra.Support","initialProofState":"Œ± : Type u_2\nŒ≥ : Type u_5\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : Zero Œ≥\ninst‚úù : CompactSpace Œ±\nf : Œ± ‚Üí Œ≥\n‚ä¢ HasCompactSupport f","decl":"/-- In a compact space `Œ±`, any function has compact support. -/\n@[to_additive]\ntheorem HasCompactMulSupport.of_compactSpace (f : Œ± ‚Üí Œ≥) :\n    HasCompactMulSupport f :=\n  IsCompact.of_isClosed_subset isCompact_univ (isClosed_mulTSupport f)\n    (Set.subset_univ (mulTSupport f))\n\n"}
{"name":"HasCompactMulSupport.of_compactSpace","module":"Mathlib.Topology.Algebra.Support","initialProofState":"Œ± : Type u_2\nŒ≥ : Type u_5\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : One Œ≥\ninst‚úù : CompactSpace Œ±\nf : Œ± ‚Üí Œ≥\n‚ä¢ HasCompactMulSupport f","decl":"/-- In a compact space `Œ±`, any function has compact support. -/\n@[to_additive]\ntheorem HasCompactMulSupport.of_compactSpace (f : Œ± ‚Üí Œ≥) :\n    HasCompactMulSupport f :=\n  IsCompact.of_isClosed_subset isCompact_univ (isClosed_mulTSupport f)\n    (Set.subset_univ (mulTSupport f))\n\n"}
{"name":"HasCompactSupport.add","module":"Mathlib.Topology.Algebra.Support","initialProofState":"Œ± : Type u_2\nŒ≤ : Type u_4\ninst‚úù¬π : TopologicalSpace Œ±\ninst‚úù : AddZeroClass Œ≤\nf f' : Œ± ‚Üí Œ≤\nhf : HasCompactSupport f\nhf' : HasCompactSupport f'\n‚ä¢ HasCompactSupport (HAdd.hAdd f f')","decl":"@[to_additive]\ntheorem HasCompactMulSupport.mul (hf : HasCompactMulSupport f) (hf' : HasCompactMulSupport f') :\n    HasCompactMulSupport (f * f') := hf.comp‚ÇÇ_left hf' (mul_one 1)\n\n"}
{"name":"HasCompactMulSupport.mul","module":"Mathlib.Topology.Algebra.Support","initialProofState":"Œ± : Type u_2\nŒ≤ : Type u_4\ninst‚úù¬π : TopologicalSpace Œ±\ninst‚úù : MulOneClass Œ≤\nf f' : Œ± ‚Üí Œ≤\nhf : HasCompactMulSupport f\nhf' : HasCompactMulSupport f'\n‚ä¢ HasCompactMulSupport (HMul.hMul f f')","decl":"@[to_additive]\ntheorem HasCompactMulSupport.mul (hf : HasCompactMulSupport f) (hf' : HasCompactMulSupport f') :\n    HasCompactMulSupport (f * f') := hf.comp‚ÇÇ_left hf' (mul_one 1)\n\n"}
{"name":"HasCompactSupport.zero","module":"Mathlib.Topology.Algebra.Support","initialProofState":"Œ± : Type u_9\nŒ≤ : Type u_10\ninst‚úù¬π : TopologicalSpace Œ±\ninst‚úù : Zero Œ≤\n‚ä¢ HasCompactSupport 0","decl":"@[to_additive, simp]\nprotected lemma HasCompactMulSupport.one {Œ± Œ≤ : Type*} [TopologicalSpace Œ±] [One Œ≤] :\n    HasCompactMulSupport (1 : Œ± ‚Üí Œ≤) := by\n  simp [HasCompactMulSupport, mulTSupport]\n\n"}
{"name":"HasCompactMulSupport.one","module":"Mathlib.Topology.Algebra.Support","initialProofState":"Œ± : Type u_9\nŒ≤ : Type u_10\ninst‚úù¬π : TopologicalSpace Œ±\ninst‚úù : One Œ≤\n‚ä¢ HasCompactMulSupport 1","decl":"@[to_additive, simp]\nprotected lemma HasCompactMulSupport.one {Œ± Œ≤ : Type*} [TopologicalSpace Œ±] [One Œ≤] :\n    HasCompactMulSupport (1 : Œ± ‚Üí Œ≤) := by\n  simp [HasCompactMulSupport, mulTSupport]\n\n"}
{"name":"HasCompactSupport.neg'","module":"Mathlib.Topology.Algebra.Support","initialProofState":"Œ± : Type u_9\nŒ≤ : Type u_10\ninst‚úù¬π : TopologicalSpace Œ±\ninst‚úù : SubtractionMonoid Œ≤\nf : Œ± ‚Üí Œ≤\nhf : HasCompactSupport f\n‚ä¢ HasCompactSupport (Neg.neg f)","decl":"@[to_additive]\nprotected lemma HasCompactMulSupport.inv' {Œ± Œ≤ : Type*} [TopologicalSpace Œ±] [DivisionMonoid Œ≤]\n    {f : Œ± ‚Üí Œ≤} (hf : HasCompactMulSupport f) :\n    HasCompactMulSupport (f‚Åª¬π) := by\n  simpa only [HasCompactMulSupport, mulTSupport, mulSupport_inv'] using hf\n\n"}
{"name":"HasCompactMulSupport.inv'","module":"Mathlib.Topology.Algebra.Support","initialProofState":"Œ± : Type u_9\nŒ≤ : Type u_10\ninst‚úù¬π : TopologicalSpace Œ±\ninst‚úù : DivisionMonoid Œ≤\nf : Œ± ‚Üí Œ≤\nhf : HasCompactMulSupport f\n‚ä¢ HasCompactMulSupport (Inv.inv f)","decl":"@[to_additive]\nprotected lemma HasCompactMulSupport.inv' {Œ± Œ≤ : Type*} [TopologicalSpace Œ±] [DivisionMonoid Œ≤]\n    {f : Œ± ‚Üí Œ≤} (hf : HasCompactMulSupport f) :\n    HasCompactMulSupport (f‚Åª¬π) := by\n  simpa only [HasCompactMulSupport, mulTSupport, mulSupport_inv'] using hf\n\n"}
{"name":"HasCompactSupport.smul_left","module":"Mathlib.Topology.Algebra.Support","initialProofState":"Œ± : Type u_2\nM : Type u_7\nR : Type u_8\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : Zero M\ninst‚úù : SMulZeroClass R M\nf : Œ± ‚Üí R\nf' : Œ± ‚Üí M\nhf : HasCompactSupport f'\n‚ä¢ HasCompactSupport (HSMul.hSMul f f')","decl":"theorem HasCompactSupport.smul_left (hf : HasCompactSupport f') : HasCompactSupport (f ‚Ä¢ f') := by\n  rw [hasCompactSupport_iff_eventuallyEq] at hf ‚ä¢\n  exact hf.mono fun x hx => by simp_rw [Pi.smul_apply', hx, Pi.zero_apply, smul_zero]\n\n"}
{"name":"HasCompactSupport.smul_right","module":"Mathlib.Topology.Algebra.Support","initialProofState":"Œ± : Type u_2\nM : Type u_7\nR : Type u_8\ninst‚úù¬≥ : TopologicalSpace Œ±\ninst‚úù¬≤ : Zero R\ninst‚úù¬π : Zero M\ninst‚úù : SMulWithZero R M\nf : Œ± ‚Üí R\nf' : Œ± ‚Üí M\nhf : HasCompactSupport f\n‚ä¢ HasCompactSupport (HSMul.hSMul f f')","decl":"theorem HasCompactSupport.smul_right (hf : HasCompactSupport f) : HasCompactSupport (f ‚Ä¢ f') := by\n  rw [hasCompactSupport_iff_eventuallyEq] at hf ‚ä¢\n  exact hf.mono fun x hx => by simp_rw [Pi.smul_apply', hx, Pi.zero_apply, zero_smul]\n\n"}
{"name":"HasCompactSupport.mul_right","module":"Mathlib.Topology.Algebra.Support","initialProofState":"Œ± : Type u_2\nŒ≤ : Type u_4\ninst‚úù¬π : TopologicalSpace Œ±\ninst‚úù : MulZeroClass Œ≤\nf f' : Œ± ‚Üí Œ≤\nhf : HasCompactSupport f\n‚ä¢ HasCompactSupport (HMul.hMul f f')","decl":"theorem HasCompactSupport.mul_right (hf : HasCompactSupport f) : HasCompactSupport (f * f') := by\n  rw [hasCompactSupport_iff_eventuallyEq] at hf ‚ä¢\n  exact hf.mono fun x hx => by simp_rw [Pi.mul_apply, hx, Pi.zero_apply, zero_mul]\n\n"}
{"name":"HasCompactSupport.mul_left","module":"Mathlib.Topology.Algebra.Support","initialProofState":"Œ± : Type u_2\nŒ≤ : Type u_4\ninst‚úù¬π : TopologicalSpace Œ±\ninst‚úù : MulZeroClass Œ≤\nf f' : Œ± ‚Üí Œ≤\nhf : HasCompactSupport f'\n‚ä¢ HasCompactSupport (HMul.hMul f f')","decl":"theorem HasCompactSupport.mul_left (hf : HasCompactSupport f') : HasCompactSupport (f * f') := by\n  rw [hasCompactSupport_iff_eventuallyEq] at hf ‚ä¢\n  exact hf.mono fun x hx => by simp_rw [Pi.mul_apply, hx, Pi.zero_apply, mul_zero]\n\n"}
{"name":"HasCompactSupport.abs","module":"Mathlib.Topology.Algebra.Support","initialProofState":"Œ± : Type u_2\nŒ≤ : Type u_4\ninst‚úù¬≥ : TopologicalSpace Œ±\ninst‚úù¬≤ : AddGroup Œ≤\ninst‚úù¬π : Lattice Œ≤\ninst‚úù : AddLeftMono Œ≤\nf : Œ± ‚Üí Œ≤\nhf : HasCompactSupport f\n‚ä¢ HasCompactSupport (abs f)","decl":"protected theorem HasCompactSupport.abs {f : Œ± ‚Üí Œ≤} (hf : HasCompactSupport f) :\n    HasCompactSupport |f| :=\n  hf.comp_left (g := abs) abs_zero\n\n"}
{"name":"LocallyFinite.exists_finset_nhd_support_subset","module":"Mathlib.Topology.Algebra.Support","initialProofState":"X : Type u_1\nR : Type u_8\nŒπ : Type u_9\ninst‚úù¬π : TopologicalSpace X\nU : Œπ ‚Üí Set X\ninst‚úù : Zero R\nf : Œπ ‚Üí X ‚Üí R\nhlf : LocallyFinite fun i => Function.support (f i)\nhso : ‚àÄ (i : Œπ), HasSubset.Subset (tsupport (f i)) (U i)\nho : ‚àÄ (i : Œπ), IsOpen (U i)\nx : X\n‚ä¢ Exists fun is => Exists fun n => And (Membership.mem (nhds x) n) (And (HasSubset.Subset n (Set.iInter fun i => Set.iInter fun h => U i)) (‚àÄ (z : X), Membership.mem n z ‚Üí HasSubset.Subset (Function.support fun i => f i z) ‚Üëis))","decl":"/-- If a family of functions `f` has locally-finite multiplicative support, subordinate to a family\nof open sets, then for any point we can find a neighbourhood on which only finitely-many members of\n`f` are not equal to 1. -/\n@[to_additive \" If a family of functions `f` has locally-finite support, subordinate to a family of\nopen sets, then for any point we can find a neighbourhood on which only finitely-many members of `f`\nare non-zero. \"]\ntheorem LocallyFinite.exists_finset_nhd_mulSupport_subset {U : Œπ ‚Üí Set X} [One R] {f : Œπ ‚Üí X ‚Üí R}\n    (hlf : LocallyFinite fun i => mulSupport (f i)) (hso : ‚àÄ i, mulTSupport (f i) ‚äÜ U i)\n    (ho : ‚àÄ i, IsOpen (U i)) (x : X) :\n    ‚àÉ (is : Finset Œπ), ‚àÉ n, n ‚àà ùìù x ‚àß (n ‚äÜ ‚ãÇ i ‚àà is, U i) ‚àß\n      ‚àÄ z ‚àà n, (mulSupport fun i => f i z) ‚äÜ is := by\n  obtain ‚ü®n, hn, hnf‚ü© := hlf x\n  classical\n    let is := hnf.toFinset.filter fun i => x ‚àà U i\n    let js := hnf.toFinset.filter fun j => x ‚àâ U j\n    refine\n      ‚ü®is, (n ‚à© ‚ãÇ j ‚àà js, (mulTSupport (f j))·∂ú) ‚à© ‚ãÇ i ‚àà is, U i, inter_mem (inter_mem hn ?_) ?_,\n        inter_subset_right, fun z hz => ?_‚ü©\n    ¬∑ exact (biInter_finset_mem js).mpr fun j hj => IsClosed.compl_mem_nhds (isClosed_mulTSupport _)\n        (Set.not_mem_subset (hso j) (Finset.mem_filter.mp hj).2)\n    ¬∑ exact (biInter_finset_mem is).mpr fun i hi => (ho i).mem_nhds (Finset.mem_filter.mp hi).2\n    ¬∑ have hzn : z ‚àà n := by\n        rw [inter_assoc] at hz\n        exact mem_of_mem_inter_left hz\n      replace hz := mem_of_mem_inter_right (mem_of_mem_inter_left hz)\n      simp only [js, Finset.mem_filter, Finite.mem_toFinset, mem_setOf_eq, mem_iInter,\n        and_imp] at hz\n      suffices (mulSupport fun i => f i z) ‚äÜ hnf.toFinset by\n        refine hnf.toFinset.subset_coe_filter_of_subset_forall _ this fun i hi => ?_\n        specialize hz i ‚ü®z, ‚ü®hi, hzn‚ü©‚ü©\n        contrapose hz\n        simp [hz, subset_mulTSupport (f i) hi]\n      intro i hi\n      simp only [Finite.coe_toFinset, mem_setOf_eq]\n      exact ‚ü®z, ‚ü®hi, hzn‚ü©‚ü©\n\n"}
{"name":"LocallyFinite.exists_finset_nhd_mulSupport_subset","module":"Mathlib.Topology.Algebra.Support","initialProofState":"X : Type u_1\nR : Type u_8\nŒπ : Type u_9\ninst‚úù¬π : TopologicalSpace X\nU : Œπ ‚Üí Set X\ninst‚úù : One R\nf : Œπ ‚Üí X ‚Üí R\nhlf : LocallyFinite fun i => Function.mulSupport (f i)\nhso : ‚àÄ (i : Œπ), HasSubset.Subset (mulTSupport (f i)) (U i)\nho : ‚àÄ (i : Œπ), IsOpen (U i)\nx : X\n‚ä¢ Exists fun is => Exists fun n => And (Membership.mem (nhds x) n) (And (HasSubset.Subset n (Set.iInter fun i => Set.iInter fun h => U i)) (‚àÄ (z : X), Membership.mem n z ‚Üí HasSubset.Subset (Function.mulSupport fun i => f i z) ‚Üëis))","decl":"/-- If a family of functions `f` has locally-finite multiplicative support, subordinate to a family\nof open sets, then for any point we can find a neighbourhood on which only finitely-many members of\n`f` are not equal to 1. -/\n@[to_additive \" If a family of functions `f` has locally-finite support, subordinate to a family of\nopen sets, then for any point we can find a neighbourhood on which only finitely-many members of `f`\nare non-zero. \"]\ntheorem LocallyFinite.exists_finset_nhd_mulSupport_subset {U : Œπ ‚Üí Set X} [One R] {f : Œπ ‚Üí X ‚Üí R}\n    (hlf : LocallyFinite fun i => mulSupport (f i)) (hso : ‚àÄ i, mulTSupport (f i) ‚äÜ U i)\n    (ho : ‚àÄ i, IsOpen (U i)) (x : X) :\n    ‚àÉ (is : Finset Œπ), ‚àÉ n, n ‚àà ùìù x ‚àß (n ‚äÜ ‚ãÇ i ‚àà is, U i) ‚àß\n      ‚àÄ z ‚àà n, (mulSupport fun i => f i z) ‚äÜ is := by\n  obtain ‚ü®n, hn, hnf‚ü© := hlf x\n  classical\n    let is := hnf.toFinset.filter fun i => x ‚àà U i\n    let js := hnf.toFinset.filter fun j => x ‚àâ U j\n    refine\n      ‚ü®is, (n ‚à© ‚ãÇ j ‚àà js, (mulTSupport (f j))·∂ú) ‚à© ‚ãÇ i ‚àà is, U i, inter_mem (inter_mem hn ?_) ?_,\n        inter_subset_right, fun z hz => ?_‚ü©\n    ¬∑ exact (biInter_finset_mem js).mpr fun j hj => IsClosed.compl_mem_nhds (isClosed_mulTSupport _)\n        (Set.not_mem_subset (hso j) (Finset.mem_filter.mp hj).2)\n    ¬∑ exact (biInter_finset_mem is).mpr fun i hi => (ho i).mem_nhds (Finset.mem_filter.mp hi).2\n    ¬∑ have hzn : z ‚àà n := by\n        rw [inter_assoc] at hz\n        exact mem_of_mem_inter_left hz\n      replace hz := mem_of_mem_inter_right (mem_of_mem_inter_left hz)\n      simp only [js, Finset.mem_filter, Finite.mem_toFinset, mem_setOf_eq, mem_iInter,\n        and_imp] at hz\n      suffices (mulSupport fun i => f i z) ‚äÜ hnf.toFinset by\n        refine hnf.toFinset.subset_coe_filter_of_subset_forall _ this fun i hi => ?_\n        specialize hz i ‚ü®z, ‚ü®hi, hzn‚ü©‚ü©\n        contrapose hz\n        simp [hz, subset_mulTSupport (f i) hi]\n      intro i hi\n      simp only [Finite.coe_toFinset, mem_setOf_eq]\n      exact ‚ü®z, ‚ü®hi, hzn‚ü©‚ü©\n\n"}
{"name":"locallyFinite_support_iff","module":"Mathlib.Topology.Algebra.Support","initialProofState":"X : Type u_1\nM : Type u_7\nŒπ : Type u_9\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : AddCommMonoid M\nf : Œπ ‚Üí X ‚Üí M\n‚ä¢ Iff (LocallyFinite fun i => Function.support (f i)) (LocallyFinite fun i => tsupport (f i))","decl":"@[to_additive]\ntheorem locallyFinite_mulSupport_iff [CommMonoid M] {f : Œπ ‚Üí X ‚Üí M} :\n    (LocallyFinite fun i ‚Ü¶ mulSupport <| f i) ‚Üî LocallyFinite fun i ‚Ü¶ mulTSupport <| f i :=\n  ‚ü®LocallyFinite.closure, fun H ‚Ü¶ H.subset fun _ ‚Ü¶ subset_closure‚ü©\n\n"}
{"name":"locallyFinite_mulSupport_iff","module":"Mathlib.Topology.Algebra.Support","initialProofState":"X : Type u_1\nM : Type u_7\nŒπ : Type u_9\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : CommMonoid M\nf : Œπ ‚Üí X ‚Üí M\n‚ä¢ Iff (LocallyFinite fun i => Function.mulSupport (f i)) (LocallyFinite fun i => mulTSupport (f i))","decl":"@[to_additive]\ntheorem locallyFinite_mulSupport_iff [CommMonoid M] {f : Œπ ‚Üí X ‚Üí M} :\n    (LocallyFinite fun i ‚Ü¶ mulSupport <| f i) ‚Üî LocallyFinite fun i ‚Ü¶ mulTSupport <| f i :=\n  ‚ü®LocallyFinite.closure, fun H ‚Ü¶ H.subset fun _ ‚Ü¶ subset_closure‚ü©\n\n"}
{"name":"LocallyFinite.smul_left","module":"Mathlib.Topology.Algebra.Support","initialProofState":"X : Type u_1\nM : Type u_7\nR : Type u_8\nŒπ : Type u_9\ninst‚úù¬≥ : TopologicalSpace X\ninst‚úù¬≤ : Zero R\ninst‚úù¬π : Zero M\ninst‚úù : SMulWithZero R M\ns : Œπ ‚Üí X ‚Üí R\nh : LocallyFinite fun i => Function.support (s i)\nf : Œπ ‚Üí X ‚Üí M\n‚ä¢ LocallyFinite fun i => Function.support (HSMul.hSMul (s i) (f i))","decl":"theorem LocallyFinite.smul_left [Zero R] [Zero M] [SMulWithZero R M]\n    {s : Œπ ‚Üí X ‚Üí R} (h : LocallyFinite fun i ‚Ü¶ support <| s i) (f : Œπ ‚Üí X ‚Üí M) :\n    LocallyFinite fun i ‚Ü¶ support <| s i ‚Ä¢ f i :=\n  h.subset fun i x ‚Ü¶ mt <| fun h ‚Ü¶ by rw [Pi.smul_apply', h, zero_smul]\n\n"}
{"name":"LocallyFinite.smul_right","module":"Mathlib.Topology.Algebra.Support","initialProofState":"X : Type u_1\nM : Type u_7\nR : Type u_8\nŒπ : Type u_9\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : Zero M\ninst‚úù : SMulZeroClass R M\nf : Œπ ‚Üí X ‚Üí M\nh : LocallyFinite fun i => Function.support (f i)\ns : Œπ ‚Üí X ‚Üí R\n‚ä¢ LocallyFinite fun i => Function.support (HSMul.hSMul (s i) (f i))","decl":"theorem LocallyFinite.smul_right [Zero M] [SMulZeroClass R M]\n    {f : Œπ ‚Üí X ‚Üí M} (h : LocallyFinite fun i ‚Ü¶ support <| f i) (s : Œπ ‚Üí X ‚Üí R) :\n    LocallyFinite fun i ‚Ü¶ support <| s i ‚Ä¢ f i :=\n  h.subset fun i x ‚Ü¶ mt <| fun h ‚Ü¶ by rw [Pi.smul_apply', h, smul_zero]\n\n"}
