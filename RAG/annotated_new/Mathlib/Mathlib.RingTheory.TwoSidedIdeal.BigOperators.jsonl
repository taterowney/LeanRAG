{"name":"TwoSidedIdeal.listSum_mem","module":"Mathlib.RingTheory.TwoSidedIdeal.BigOperators","initialProofState":"R : Type u_1\ninst✝ : NonUnitalNonAssocRing R\nI : TwoSidedIdeal R\nι : Type u_2\nl : List ι\nf : ι → R\nhl : ∀ (x : ι), Membership.mem l x → Membership.mem I (f x)\n⊢ Membership.mem I (List.map f l).sum","decl":"lemma listSum_mem {ι : Type*} (l : List ι) (f : ι → R) (hl : ∀ x ∈ l, f x ∈ I) :\n    (l.map f).sum ∈ I := by\n  rw [mem_iff, ← List.sum_map_zero]\n  exact I.ringCon.listSum l hl\n\n"}
{"name":"TwoSidedIdeal.multisetSum_mem","module":"Mathlib.RingTheory.TwoSidedIdeal.BigOperators","initialProofState":"R : Type u_1\ninst✝ : NonUnitalNonAssocRing R\nI : TwoSidedIdeal R\nι : Type u_2\ns : Multiset ι\nf : ι → R\nhs : ∀ (x : ι), Membership.mem s x → Membership.mem I (f x)\n⊢ Membership.mem I (Multiset.map f s).sum","decl":"lemma multisetSum_mem {ι : Type*} (s : Multiset ι) (f : ι → R) (hs : ∀ x ∈ s, f x ∈ I) :\n    (s.map f).sum ∈ I := by\n  rw [mem_iff, ← Multiset.sum_map_zero]\n  exact I.ringCon.multisetSum s hs\n\n"}
{"name":"TwoSidedIdeal.finsetSum_mem","module":"Mathlib.RingTheory.TwoSidedIdeal.BigOperators","initialProofState":"R : Type u_1\ninst✝ : NonUnitalNonAssocRing R\nI : TwoSidedIdeal R\nι : Type u_2\ns : Finset ι\nf : ι → R\nhs : ∀ (x : ι), Membership.mem s x → Membership.mem I (f x)\n⊢ Membership.mem I (s.sum f)","decl":"lemma finsetSum_mem {ι : Type*} (s : Finset ι) (f : ι → R) (hs : ∀ x ∈ s, f x ∈ I) :\n    s.sum f ∈ I := by\n  rw [mem_iff, ← Finset.sum_const_zero]\n  exact I.ringCon.finsetSum s hs\n\n"}
{"name":"TwoSidedIdeal.listProd_mem","module":"Mathlib.RingTheory.TwoSidedIdeal.BigOperators","initialProofState":"R : Type u_1\ninst✝ : Ring R\nI : TwoSidedIdeal R\nι : Type u_2\nl : List ι\nf : ι → R\nhl : Exists fun x => And (Membership.mem l x) (Membership.mem I (f x))\n⊢ Membership.mem I (List.map f l).prod","decl":"lemma listProd_mem {ι : Type*} (l : List ι) (f : ι → R) (hl : ∃ x ∈ l, f x ∈ I) :\n    (l.map f).prod ∈ I := by\n  induction l with\n  | nil => simp only [List.not_mem_nil, false_and, exists_false] at hl\n  | cons x l ih =>\n    simp only [List.mem_cons, exists_eq_or_imp] at hl\n    rcases hl with h | hal\n    · simpa only [List.map_cons, List.prod_cons] using I.mul_mem_right _ _ h\n    · simpa only [List.map_cons, List.prod_cons] using I.mul_mem_left _ _ <| ih hal\n\n"}
{"name":"TwoSidedIdeal.multiSetProd_mem","module":"Mathlib.RingTheory.TwoSidedIdeal.BigOperators","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nI : TwoSidedIdeal R\nι : Type u_2\ns : Multiset ι\nf : ι → R\nhs : Exists fun x => And (Membership.mem s x) (Membership.mem I (f x))\n⊢ Membership.mem I (Multiset.map f s).prod","decl":"lemma multiSetProd_mem {ι : Type*} (s : Multiset ι) (f : ι → R) (hs : ∃ x ∈ s, f x ∈ I) :\n    (s.map f).prod ∈ I := by\n  rcases s\n  simpa using listProd_mem (hl := hs)\n\n"}
{"name":"TwoSidedIdeal.finsetProd_mem","module":"Mathlib.RingTheory.TwoSidedIdeal.BigOperators","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nI : TwoSidedIdeal R\nι : Type u_2\ns : Finset ι\nf : ι → R\nhs : Exists fun x => And (Membership.mem s x) (Membership.mem I (f x))\n⊢ Membership.mem I (s.prod f)","decl":"lemma finsetProd_mem {ι : Type*} (s : Finset ι) (f : ι → R) (hs : ∃ x ∈ s, f x ∈ I) :\n    s.prod f ∈ I := by\n  rcases s\n  simpa using multiSetProd_mem (hs := hs)\n\n"}
