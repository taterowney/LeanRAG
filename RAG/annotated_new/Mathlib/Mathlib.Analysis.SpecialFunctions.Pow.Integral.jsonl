{"name":"MeasureTheory.lintegral_rpow_eq_lintegral_meas_le_mul","module":"Mathlib.Analysis.SpecialFunctions.Pow.Integral","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nf : α → Real\nμ : MeasureTheory.Measure α\nf_nn : (MeasureTheory.ae μ).EventuallyLE 0 f\nf_mble : AEMeasurable f μ\np : Real\np_pos : LT.lt 0 p\n⊢ Eq (MeasureTheory.lintegral μ fun ω => ENNReal.ofReal (HPow.hPow (f ω) p)) (HMul.hMul (ENNReal.ofReal p) (MeasureTheory.lintegral (MeasureTheory.MeasureSpace.volume.restrict (Set.Ioi 0)) fun t => HMul.hMul (μ (setOf fun a => LE.le t (f a))) (ENNReal.ofReal (HPow.hPow t (HSub.hSub p 1)))))","decl":"include f_nn f_mble p_pos in\n/-- An application of the layer cake formula / Cavalieri's principle / tail probability formula:\n\nFor a nonnegative function `f` on a measure space, the Lebesgue integral of `f` can\nbe written (roughly speaking) as: `∫⁻ f^p ∂μ = p * ∫⁻ t in 0..∞, t^(p-1) * μ {ω | f(ω) ≥ t}`.\n\nSee `MeasureTheory.lintegral_rpow_eq_lintegral_meas_lt_mul` for a version with sets of the form\n`{ω | f(ω) > t}` instead. -/\ntheorem lintegral_rpow_eq_lintegral_meas_le_mul :\n    ∫⁻ ω, ENNReal.ofReal (f ω ^ p) ∂μ =\n      ENNReal.ofReal p * ∫⁻ t in Ioi 0, μ {a : α | t ≤ f a} * ENNReal.ofReal (t ^ (p - 1)) := by\n  have one_lt_p : -1 < p - 1 := by linarith\n  have obs : ∀ x : ℝ, ∫ t : ℝ in (0)..x, t ^ (p - 1) = x ^ p / p := by\n    intro x\n    rw [integral_rpow (Or.inl one_lt_p)]\n    simp [Real.zero_rpow p_pos.ne.symm]\n  set g := fun t : ℝ => t ^ (p - 1)\n  have g_nn : ∀ᵐ t ∂volume.restrict (Ioi (0 : ℝ)), 0 ≤ g t := by\n    filter_upwards [self_mem_ae_restrict (measurableSet_Ioi : MeasurableSet (Ioi (0 : ℝ)))]\n    intro t t_pos\n    exact Real.rpow_nonneg (mem_Ioi.mp t_pos).le (p - 1)\n  have g_intble : ∀ t > 0, IntervalIntegrable g volume 0 t := fun _ _ =>\n    intervalIntegral.intervalIntegrable_rpow' one_lt_p\n  have key := lintegral_comp_eq_lintegral_meas_le_mul μ f_nn f_mble g_intble g_nn\n  rw [← key, ← lintegral_const_mul'' (ENNReal.ofReal p)] <;> simp_rw [obs]\n  · congr with ω\n    rw [← ENNReal.ofReal_mul p_pos.le, mul_div_cancel₀ (f ω ^ p) p_pos.ne.symm]\n  · have aux := (@measurable_const ℝ α (by infer_instance) (by infer_instance) p).aemeasurable\n                  (μ := μ)\n    exact (Measurable.ennreal_ofReal (hf := measurable_id)).comp_aemeasurable\n      ((f_mble.pow aux).div_const p)\n\n"}
{"name":"MeasureTheory.lintegral_rpow_eq_lintegral_meas_lt_mul","module":"Mathlib.Analysis.SpecialFunctions.Pow.Integral","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nf : α → Real\nμ : MeasureTheory.Measure α\nf_nn : (MeasureTheory.ae μ).EventuallyLE 0 f\nf_mble : AEMeasurable f μ\np : Real\np_pos : LT.lt 0 p\n⊢ Eq (MeasureTheory.lintegral μ fun ω => ENNReal.ofReal (HPow.hPow (f ω) p)) (HMul.hMul (ENNReal.ofReal p) (MeasureTheory.lintegral (MeasureTheory.MeasureSpace.volume.restrict (Set.Ioi 0)) fun t => HMul.hMul (μ (setOf fun a => LT.lt t (f a))) (ENNReal.ofReal (HPow.hPow t (HSub.hSub p 1)))))","decl":"include f_nn f_mble p_pos in\n/-- An application of the layer cake formula / Cavalieri's principle / tail probability formula:\n\nFor a nonnegative function `f` on a measure space, the Lebesgue integral of `f` can\nbe written (roughly speaking) as: `∫⁻ f^p ∂μ = p * ∫⁻ t in 0..∞, t^(p-1) * μ {ω | f(ω) > t}`.\n\nSee `MeasureTheory.lintegral_rpow_eq_lintegral_meas_le_mul` for a version with sets of the form\n`{ω | f(ω) ≥ t}` instead. -/\ntheorem lintegral_rpow_eq_lintegral_meas_lt_mul :\n    ∫⁻ ω, ENNReal.ofReal (f ω ^ p) ∂μ =\n      ENNReal.ofReal p * ∫⁻ t in Ioi 0, μ {a : α | t < f a} * ENNReal.ofReal (t ^ (p - 1)) := by\n  rw [lintegral_rpow_eq_lintegral_meas_le_mul μ f_nn f_mble p_pos]\n  apply congr_arg fun z => ENNReal.ofReal p * z\n  apply lintegral_congr_ae\n  filter_upwards [meas_le_ae_eq_meas_lt μ (volume.restrict (Ioi 0)) f]\n    with t ht\n  rw [ht]\n\n"}
