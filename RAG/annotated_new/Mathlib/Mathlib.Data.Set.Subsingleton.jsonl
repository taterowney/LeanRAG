{"name":"Set.Subsingleton.anti","module":"Mathlib.Data.Set.Subsingleton","initialProofState":"α : Type u\ns t : Set α\nht : t.Subsingleton\nhst : HasSubset.Subset s t\n⊢ s.Subsingleton","decl":"theorem Subsingleton.anti (ht : t.Subsingleton) (hst : s ⊆ t) : s.Subsingleton := fun _ hx _ hy =>\n  ht (hst hx) (hst hy)\n\n"}
{"name":"Set.Subsingleton.eq_singleton_of_mem","module":"Mathlib.Data.Set.Subsingleton","initialProofState":"α : Type u\ns : Set α\nhs : s.Subsingleton\nx : α\nhx : Membership.mem s x\n⊢ Eq s (Singleton.singleton x)","decl":"theorem Subsingleton.eq_singleton_of_mem (hs : s.Subsingleton) {x : α} (hx : x ∈ s) : s = {x} :=\n  ext fun _ => ⟨fun hy => hs hx hy ▸ mem_singleton _, fun hy => (eq_of_mem_singleton hy).symm ▸ hx⟩\n\n"}
{"name":"Set.subsingleton_empty","module":"Mathlib.Data.Set.Subsingleton","initialProofState":"α : Type u\n⊢ EmptyCollection.emptyCollection.Subsingleton","decl":"@[simp]\ntheorem subsingleton_empty : (∅ : Set α).Subsingleton := fun _ => False.elim\n\n"}
{"name":"Set.subsingleton_singleton","module":"Mathlib.Data.Set.Subsingleton","initialProofState":"α : Type u\na : α\n⊢ (Singleton.singleton a).Subsingleton","decl":"@[simp]\ntheorem subsingleton_singleton {a} : ({a} : Set α).Subsingleton := fun _ hx _ hy =>\n  (eq_of_mem_singleton hx).symm ▸ (eq_of_mem_singleton hy).symm ▸ rfl\n\n"}
{"name":"Set.subsingleton_of_subset_singleton","module":"Mathlib.Data.Set.Subsingleton","initialProofState":"α : Type u\na : α\ns : Set α\nh : HasSubset.Subset s (Singleton.singleton a)\n⊢ s.Subsingleton","decl":"theorem subsingleton_of_subset_singleton (h : s ⊆ {a}) : s.Subsingleton :=\n  subsingleton_singleton.anti h\n\n"}
{"name":"Set.subsingleton_of_forall_eq","module":"Mathlib.Data.Set.Subsingleton","initialProofState":"α : Type u\ns : Set α\na : α\nh : ∀ (b : α), Membership.mem s b → Eq b a\n⊢ s.Subsingleton","decl":"theorem subsingleton_of_forall_eq (a : α) (h : ∀ b ∈ s, b = a) : s.Subsingleton := fun _ hb _ hc =>\n  (h _ hb).trans (h _ hc).symm\n\n"}
{"name":"Set.subsingleton_iff_singleton","module":"Mathlib.Data.Set.Subsingleton","initialProofState":"α : Type u\ns : Set α\nx : α\nhx : Membership.mem s x\n⊢ Iff s.Subsingleton (Eq s (Singleton.singleton x))","decl":"theorem subsingleton_iff_singleton {x} (hx : x ∈ s) : s.Subsingleton ↔ s = {x} :=\n  ⟨fun h => h.eq_singleton_of_mem hx, fun h => h.symm ▸ subsingleton_singleton⟩\n\n"}
{"name":"Set.Subsingleton.eq_empty_or_singleton","module":"Mathlib.Data.Set.Subsingleton","initialProofState":"α : Type u\ns : Set α\nhs : s.Subsingleton\n⊢ Or (Eq s EmptyCollection.emptyCollection) (Exists fun x => Eq s (Singleton.singleton x))","decl":"theorem Subsingleton.eq_empty_or_singleton (hs : s.Subsingleton) : s = ∅ ∨ ∃ x, s = {x} :=\n  s.eq_empty_or_nonempty.elim Or.inl fun ⟨x, hx⟩ => Or.inr ⟨x, hs.eq_singleton_of_mem hx⟩\n\n"}
{"name":"Set.Subsingleton.induction_on","module":"Mathlib.Data.Set.Subsingleton","initialProofState":"α : Type u\ns : Set α\np : Set α → Prop\nhs : s.Subsingleton\nhe : p EmptyCollection.emptyCollection\nh₁ : ∀ (x : α), p (Singleton.singleton x)\n⊢ p s","decl":"theorem Subsingleton.induction_on {p : Set α → Prop} (hs : s.Subsingleton) (he : p ∅)\n    (h₁ : ∀ x, p {x}) : p s := by\n  rcases hs.eq_empty_or_singleton with (rfl | ⟨x, rfl⟩)\n  exacts [he, h₁ _]\n\n"}
{"name":"Set.subsingleton_univ","module":"Mathlib.Data.Set.Subsingleton","initialProofState":"α : Type u\ninst✝ : Subsingleton α\n⊢ Set.univ.Subsingleton","decl":"theorem subsingleton_univ [Subsingleton α] : (univ : Set α).Subsingleton := fun x _ y _ =>\n  Subsingleton.elim x y\n\n"}
{"name":"Set.subsingleton_of_univ_subsingleton","module":"Mathlib.Data.Set.Subsingleton","initialProofState":"α : Type u\nh : Set.univ.Subsingleton\n⊢ Subsingleton α","decl":"theorem subsingleton_of_univ_subsingleton (h : (univ : Set α).Subsingleton) : Subsingleton α :=\n  ⟨fun a b => h (mem_univ a) (mem_univ b)⟩\n\n"}
{"name":"Set.subsingleton_univ_iff","module":"Mathlib.Data.Set.Subsingleton","initialProofState":"α : Type u\n⊢ Iff Set.univ.Subsingleton (Subsingleton α)","decl":"@[simp]\ntheorem subsingleton_univ_iff : (univ : Set α).Subsingleton ↔ Subsingleton α :=\n  ⟨subsingleton_of_univ_subsingleton, fun h => @subsingleton_univ _ h⟩\n\n"}
{"name":"Set.Subsingleton.inter_singleton","module":"Mathlib.Data.Set.Subsingleton","initialProofState":"α : Type u\na : α\ns : Set α\n⊢ (Inter.inter s (Singleton.singleton a)).Subsingleton","decl":"lemma Subsingleton.inter_singleton : (s ∩ {a}).Subsingleton :=\n  Set.subsingleton_of_subset_singleton Set.inter_subset_right\n\n"}
{"name":"Set.Subsingleton.singleton_inter","module":"Mathlib.Data.Set.Subsingleton","initialProofState":"α : Type u\na : α\ns : Set α\n⊢ (Inter.inter (Singleton.singleton a) s).Subsingleton","decl":"lemma Subsingleton.singleton_inter : ({a} ∩ s).Subsingleton :=\n  Set.subsingleton_of_subset_singleton Set.inter_subset_left\n\n"}
{"name":"Set.subsingleton_of_subsingleton","module":"Mathlib.Data.Set.Subsingleton","initialProofState":"α : Type u\ninst✝ : Subsingleton α\ns : Set α\n⊢ s.Subsingleton","decl":"theorem subsingleton_of_subsingleton [Subsingleton α] {s : Set α} : Set.Subsingleton s :=\n  subsingleton_univ.anti (subset_univ s)\n\n"}
{"name":"Set.subsingleton_isTop","module":"Mathlib.Data.Set.Subsingleton","initialProofState":"α : Type u_1\ninst✝ : PartialOrder α\n⊢ (setOf fun x => IsTop x).Subsingleton","decl":"theorem subsingleton_isTop (α : Type*) [PartialOrder α] : Set.Subsingleton { x : α | IsTop x } :=\n  fun x hx _ hy => hx.isMax.eq_of_le (hy x)\n\n"}
{"name":"Set.subsingleton_isBot","module":"Mathlib.Data.Set.Subsingleton","initialProofState":"α : Type u_1\ninst✝ : PartialOrder α\n⊢ (setOf fun x => IsBot x).Subsingleton","decl":"theorem subsingleton_isBot (α : Type*) [PartialOrder α] : Set.Subsingleton { x : α | IsBot x } :=\n  fun x hx _ hy => hx.isMin.eq_of_ge (hy x)\n\n"}
{"name":"Set.exists_eq_singleton_iff_nonempty_subsingleton","module":"Mathlib.Data.Set.Subsingleton","initialProofState":"α : Type u\ns : Set α\n⊢ Iff (Exists fun a => Eq s (Singleton.singleton a)) (And s.Nonempty s.Subsingleton)","decl":"theorem exists_eq_singleton_iff_nonempty_subsingleton :\n    (∃ a : α, s = {a}) ↔ s.Nonempty ∧ s.Subsingleton := by\n  refine ⟨?_, fun h => ?_⟩\n  · rintro ⟨a, rfl⟩\n    exact ⟨singleton_nonempty a, subsingleton_singleton⟩\n  · exact h.2.eq_empty_or_singleton.resolve_left h.1.ne_empty\n\n"}
{"name":"Set.subsingleton_coe","module":"Mathlib.Data.Set.Subsingleton","initialProofState":"α : Type u\ns : Set α\n⊢ Iff (Subsingleton ↑s) s.Subsingleton","decl":"/-- `s`, coerced to a type, is a subsingleton type if and only if `s` is a subsingleton set. -/\n@[simp, norm_cast]\ntheorem subsingleton_coe (s : Set α) : Subsingleton s ↔ s.Subsingleton := by\n  constructor\n  · refine fun h => fun a ha b hb => ?_\n    exact SetCoe.ext_iff.2 (@Subsingleton.elim s h ⟨a, ha⟩ ⟨b, hb⟩)\n  · exact fun h => Subsingleton.intro fun a b => SetCoe.ext (h a.property b.property)\n\n"}
{"name":"Set.Subsingleton.coe_sort","module":"Mathlib.Data.Set.Subsingleton","initialProofState":"α : Type u\ns : Set α\na✝ : s.Subsingleton\n⊢ Subsingleton ↑s","decl":"theorem Subsingleton.coe_sort {s : Set α} : s.Subsingleton → Subsingleton s :=\n  s.subsingleton_coe.2\n\n"}
{"name":"Set.subsingleton_coe_of_subsingleton","module":"Mathlib.Data.Set.Subsingleton","initialProofState":"α : Type u\ninst✝ : Subsingleton α\ns : Set α\n⊢ Subsingleton ↑s","decl":"/-- The `coe_sort` of a set `s` in a subsingleton type is a subsingleton.\nFor the corresponding result for `Subtype`, see `subtype.subsingleton`. -/\ninstance subsingleton_coe_of_subsingleton [Subsingleton α] {s : Set α} : Subsingleton s := by\n  rw [s.subsingleton_coe]\n  exact subsingleton_of_subsingleton\n\n"}
{"name":"Set.nontrivial_of_mem_mem_ne","module":"Mathlib.Data.Set.Subsingleton","initialProofState":"α : Type u\ns : Set α\nx y : α\nhx : Membership.mem s x\nhy : Membership.mem s y\nhxy : Ne x y\n⊢ s.Nontrivial","decl":"theorem nontrivial_of_mem_mem_ne {x y} (hx : x ∈ s) (hy : y ∈ s) (hxy : x ≠ y) : s.Nontrivial :=\n  ⟨x, hx, y, hy, hxy⟩\n\n-- Porting note: following the pattern for `Exists`, we have renamed `some` to `choose`.\n\n"}
{"name":"Set.Nontrivial.choose_fst_mem","module":"Mathlib.Data.Set.Subsingleton","initialProofState":"α : Type u\ns : Set α\nhs : s.Nontrivial\n⊢ Membership.mem s hs.choose.fst","decl":"protected theorem Nontrivial.choose_fst_mem (hs : s.Nontrivial) : hs.choose.fst ∈ s :=\n  hs.choose_spec.left\n\n"}
{"name":"Set.Nontrivial.choose_snd_mem","module":"Mathlib.Data.Set.Subsingleton","initialProofState":"α : Type u\ns : Set α\nhs : s.Nontrivial\n⊢ Membership.mem s hs.choose.snd","decl":"protected theorem Nontrivial.choose_snd_mem (hs : s.Nontrivial) : hs.choose.snd ∈ s :=\n  hs.choose_spec.right.choose_spec.left\n\n"}
{"name":"Set.Nontrivial.choose_fst_ne_choose_snd","module":"Mathlib.Data.Set.Subsingleton","initialProofState":"α : Type u\ns : Set α\nhs : s.Nontrivial\n⊢ Ne hs.choose.fst hs.choose.snd","decl":"protected theorem Nontrivial.choose_fst_ne_choose_snd (hs : s.Nontrivial) :\n    hs.choose.fst ≠ hs.choose.snd :=\n  hs.choose_spec.right.choose_spec.right\n\n"}
{"name":"Set.Nontrivial.mono","module":"Mathlib.Data.Set.Subsingleton","initialProofState":"α : Type u\ns t : Set α\nhs : s.Nontrivial\nhst : HasSubset.Subset s t\n⊢ t.Nontrivial","decl":"theorem Nontrivial.mono (hs : s.Nontrivial) (hst : s ⊆ t) : t.Nontrivial :=\n  let ⟨x, hx, y, hy, hxy⟩ := hs\n  ⟨x, hst hx, y, hst hy, hxy⟩\n\n"}
{"name":"Set.nontrivial_pair","module":"Mathlib.Data.Set.Subsingleton","initialProofState":"α : Type u\nx y : α\nhxy : Ne x y\n⊢ (Insert.insert x (Singleton.singleton y)).Nontrivial","decl":"theorem nontrivial_pair {x y} (hxy : x ≠ y) : ({x, y} : Set α).Nontrivial :=\n  ⟨x, mem_insert _ _, y, mem_insert_of_mem _ (mem_singleton _), hxy⟩\n\n"}
{"name":"Set.nontrivial_of_pair_subset","module":"Mathlib.Data.Set.Subsingleton","initialProofState":"α : Type u\ns : Set α\nx y : α\nhxy : Ne x y\nh : HasSubset.Subset (Insert.insert x (Singleton.singleton y)) s\n⊢ s.Nontrivial","decl":"theorem nontrivial_of_pair_subset {x y} (hxy : x ≠ y) (h : {x, y} ⊆ s) : s.Nontrivial :=\n  (nontrivial_pair hxy).mono h\n\n"}
{"name":"Set.Nontrivial.pair_subset","module":"Mathlib.Data.Set.Subsingleton","initialProofState":"α : Type u\ns : Set α\nhs : s.Nontrivial\n⊢ Exists fun x => Exists fun y => And (Ne x y) (HasSubset.Subset (Insert.insert x (Singleton.singleton y)) s)","decl":"theorem Nontrivial.pair_subset (hs : s.Nontrivial) : ∃ x y, x ≠ y ∧ {x, y} ⊆ s :=\n  let ⟨x, hx, y, hy, hxy⟩ := hs\n  ⟨x, y, hxy, insert_subset hx <| singleton_subset_iff.2 hy⟩\n\n"}
{"name":"Set.nontrivial_iff_pair_subset","module":"Mathlib.Data.Set.Subsingleton","initialProofState":"α : Type u\ns : Set α\n⊢ Iff s.Nontrivial (Exists fun x => Exists fun y => And (Ne x y) (HasSubset.Subset (Insert.insert x (Singleton.singleton y)) s))","decl":"theorem nontrivial_iff_pair_subset : s.Nontrivial ↔ ∃ x y, x ≠ y ∧ {x, y} ⊆ s :=\n  ⟨Nontrivial.pair_subset, fun H =>\n    let ⟨_, _, hxy, h⟩ := H\n    nontrivial_of_pair_subset hxy h⟩\n\n"}
{"name":"Set.nontrivial_of_exists_ne","module":"Mathlib.Data.Set.Subsingleton","initialProofState":"α : Type u\ns : Set α\nx : α\nhx : Membership.mem s x\nh : Exists fun y => And (Membership.mem s y) (Ne y x)\n⊢ s.Nontrivial","decl":"theorem nontrivial_of_exists_ne {x} (hx : x ∈ s) (h : ∃ y ∈ s, y ≠ x) : s.Nontrivial :=\n  let ⟨y, hy, hyx⟩ := h\n  ⟨y, hy, x, hx, hyx⟩\n\n"}
{"name":"Set.Nontrivial.exists_ne","module":"Mathlib.Data.Set.Subsingleton","initialProofState":"α : Type u\ns : Set α\nhs : s.Nontrivial\nz : α\n⊢ Exists fun x => And (Membership.mem s x) (Ne x z)","decl":"theorem Nontrivial.exists_ne (hs : s.Nontrivial) (z) : ∃ x ∈ s, x ≠ z := by\n  by_contra! H\n  rcases hs with ⟨x, hx, y, hy, hxy⟩\n  rw [H x hx, H y hy] at hxy\n  exact hxy rfl\n\n"}
{"name":"Set.nontrivial_iff_exists_ne","module":"Mathlib.Data.Set.Subsingleton","initialProofState":"α : Type u\ns : Set α\nx : α\nhx : Membership.mem s x\n⊢ Iff s.Nontrivial (Exists fun y => And (Membership.mem s y) (Ne y x))","decl":"theorem nontrivial_iff_exists_ne {x} (hx : x ∈ s) : s.Nontrivial ↔ ∃ y ∈ s, y ≠ x :=\n  ⟨fun H => H.exists_ne _, nontrivial_of_exists_ne hx⟩\n\n"}
{"name":"Set.nontrivial_of_lt","module":"Mathlib.Data.Set.Subsingleton","initialProofState":"α : Type u\ns : Set α\ninst✝ : Preorder α\nx y : α\nhx : Membership.mem s x\nhy : Membership.mem s y\nhxy : LT.lt x y\n⊢ s.Nontrivial","decl":"theorem nontrivial_of_lt [Preorder α] {x y} (hx : x ∈ s) (hy : y ∈ s) (hxy : x < y) :\n    s.Nontrivial :=\n  ⟨x, hx, y, hy, ne_of_lt hxy⟩\n\n"}
{"name":"Set.nontrivial_of_exists_lt","module":"Mathlib.Data.Set.Subsingleton","initialProofState":"α : Type u\ns : Set α\ninst✝ : Preorder α\nH : Exists fun x => And (Membership.mem s x) (Exists fun y => And (Membership.mem s y) (LT.lt x y))\n⊢ s.Nontrivial","decl":"theorem nontrivial_of_exists_lt [Preorder α]\n    (H : ∃ᵉ (x ∈ s) (y ∈ s), x < y) : s.Nontrivial :=\n  let ⟨_, hx, _, hy, hxy⟩ := H\n  nontrivial_of_lt hx hy hxy\n\n"}
{"name":"Set.Nontrivial.exists_lt","module":"Mathlib.Data.Set.Subsingleton","initialProofState":"α : Type u\ns : Set α\ninst✝ : LinearOrder α\nhs : s.Nontrivial\n⊢ Exists fun x => And (Membership.mem s x) (Exists fun y => And (Membership.mem s y) (LT.lt x y))","decl":"theorem Nontrivial.exists_lt [LinearOrder α] (hs : s.Nontrivial) : ∃ᵉ (x ∈ s) (y ∈ s), x < y :=\n  let ⟨x, hx, y, hy, hxy⟩ := hs\n  Or.elim (lt_or_gt_of_ne hxy) (fun H => ⟨x, hx, y, hy, H⟩) fun H => ⟨y, hy, x, hx, H⟩\n\n"}
{"name":"Set.nontrivial_iff_exists_lt","module":"Mathlib.Data.Set.Subsingleton","initialProofState":"α : Type u\ns : Set α\ninst✝ : LinearOrder α\n⊢ Iff s.Nontrivial (Exists fun x => And (Membership.mem s x) (Exists fun y => And (Membership.mem s y) (LT.lt x y)))","decl":"theorem nontrivial_iff_exists_lt [LinearOrder α] :\n    s.Nontrivial ↔ ∃ᵉ (x ∈ s) (y ∈ s), x < y :=\n  ⟨Nontrivial.exists_lt, nontrivial_of_exists_lt⟩\n\n"}
{"name":"Set.Nontrivial.nonempty","module":"Mathlib.Data.Set.Subsingleton","initialProofState":"α : Type u\ns : Set α\nhs : s.Nontrivial\n⊢ s.Nonempty","decl":"protected theorem Nontrivial.nonempty (hs : s.Nontrivial) : s.Nonempty :=\n  let ⟨x, hx, _⟩ := hs\n  ⟨x, hx⟩\n\n"}
{"name":"Set.Nontrivial.ne_empty","module":"Mathlib.Data.Set.Subsingleton","initialProofState":"α : Type u\ns : Set α\nhs : s.Nontrivial\n⊢ Ne s EmptyCollection.emptyCollection","decl":"protected theorem Nontrivial.ne_empty (hs : s.Nontrivial) : s ≠ ∅ :=\n  hs.nonempty.ne_empty\n\n"}
{"name":"Set.Nontrivial.not_subset_empty","module":"Mathlib.Data.Set.Subsingleton","initialProofState":"α : Type u\ns : Set α\nhs : s.Nontrivial\n⊢ Not (HasSubset.Subset s EmptyCollection.emptyCollection)","decl":"theorem Nontrivial.not_subset_empty (hs : s.Nontrivial) : ¬s ⊆ ∅ :=\n  hs.nonempty.not_subset_empty\n\n"}
{"name":"Set.not_nontrivial_empty","module":"Mathlib.Data.Set.Subsingleton","initialProofState":"α : Type u\n⊢ Not EmptyCollection.emptyCollection.Nontrivial","decl":"@[simp]\ntheorem not_nontrivial_empty : ¬(∅ : Set α).Nontrivial := fun h => h.ne_empty rfl\n\n"}
{"name":"Set.not_nontrivial_singleton","module":"Mathlib.Data.Set.Subsingleton","initialProofState":"α : Type u\nx : α\n⊢ Not (Singleton.singleton x).Nontrivial","decl":"@[simp]\ntheorem not_nontrivial_singleton {x} : ¬({x} : Set α).Nontrivial := fun H => by\n  rw [nontrivial_iff_exists_ne (mem_singleton x)] at H\n  let ⟨y, hy, hya⟩ := H\n  exact hya (mem_singleton_iff.1 hy)\n\n"}
{"name":"Set.Nontrivial.ne_singleton","module":"Mathlib.Data.Set.Subsingleton","initialProofState":"α : Type u\ns : Set α\nx : α\nhs : s.Nontrivial\n⊢ Ne s (Singleton.singleton x)","decl":"theorem Nontrivial.ne_singleton {x} (hs : s.Nontrivial) : s ≠ {x} := fun H => by\n  rw [H] at hs\n  exact not_nontrivial_singleton hs\n\n"}
{"name":"Set.Nontrivial.not_subset_singleton","module":"Mathlib.Data.Set.Subsingleton","initialProofState":"α : Type u\ns : Set α\nx : α\nhs : s.Nontrivial\n⊢ Not (HasSubset.Subset s (Singleton.singleton x))","decl":"theorem Nontrivial.not_subset_singleton {x} (hs : s.Nontrivial) : ¬s ⊆ {x} :=\n  (not_congr subset_singleton_iff_eq).2 (not_or_intro hs.ne_empty hs.ne_singleton)\n\n"}
{"name":"Set.nontrivial_univ","module":"Mathlib.Data.Set.Subsingleton","initialProofState":"α : Type u\ninst✝ : Nontrivial α\n⊢ Set.univ.Nontrivial","decl":"theorem nontrivial_univ [Nontrivial α] : (univ : Set α).Nontrivial :=\n  let ⟨x, y, hxy⟩ := exists_pair_ne α\n  ⟨x, mem_univ _, y, mem_univ _, hxy⟩\n\n"}
{"name":"Set.nontrivial_of_univ_nontrivial","module":"Mathlib.Data.Set.Subsingleton","initialProofState":"α : Type u\nh : Set.univ.Nontrivial\n⊢ Nontrivial α","decl":"theorem nontrivial_of_univ_nontrivial (h : (univ : Set α).Nontrivial) : Nontrivial α :=\n  let ⟨x, _, y, _, hxy⟩ := h\n  ⟨⟨x, y, hxy⟩⟩\n\n"}
{"name":"Set.nontrivial_univ_iff","module":"Mathlib.Data.Set.Subsingleton","initialProofState":"α : Type u\n⊢ Iff Set.univ.Nontrivial (Nontrivial α)","decl":"@[simp]\ntheorem nontrivial_univ_iff : (univ : Set α).Nontrivial ↔ Nontrivial α :=\n  ⟨nontrivial_of_univ_nontrivial, fun h => @nontrivial_univ _ h⟩\n\n"}
{"name":"Set.nontrivial_of_nontrivial","module":"Mathlib.Data.Set.Subsingleton","initialProofState":"α : Type u\ns : Set α\nhs : s.Nontrivial\n⊢ Nontrivial α","decl":"theorem nontrivial_of_nontrivial (hs : s.Nontrivial) : Nontrivial α :=\n  let ⟨x, _, y, _, hxy⟩ := hs\n  ⟨⟨x, y, hxy⟩⟩\n\n"}
{"name":"Set.nontrivial_coe_sort","module":"Mathlib.Data.Set.Subsingleton","initialProofState":"α : Type u\ns : Set α\n⊢ Iff (Nontrivial ↑s) s.Nontrivial","decl":"/-- `s`, coerced to a type, is a nontrivial type if and only if `s` is a nontrivial set. -/\n@[simp, norm_cast]\ntheorem nontrivial_coe_sort {s : Set α} : Nontrivial s ↔ s.Nontrivial := by\n  simp [← nontrivial_univ_iff, Set.Nontrivial]\n\n"}
{"name":"Set.Nontrivial.coe_sort","module":"Mathlib.Data.Set.Subsingleton","initialProofState":"α : Type u\ns : Set α\na✝ : s.Nontrivial\n⊢ Nontrivial ↑s","decl":"alias ⟨_, Nontrivial.coe_sort⟩ := nontrivial_coe_sort\n\n"}
{"name":"Set.nontrivial_of_nontrivial_coe","module":"Mathlib.Data.Set.Subsingleton","initialProofState":"α : Type u\ns : Set α\nhs : Nontrivial ↑s\n⊢ Nontrivial α","decl":"/-- A type with a set `s` whose `coe_sort` is a nontrivial type is nontrivial.\nFor the corresponding result for `Subtype`, see `Subtype.nontrivial_iff_exists_ne`. -/\ntheorem nontrivial_of_nontrivial_coe (hs : Nontrivial s) : Nontrivial α :=\n  nontrivial_of_nontrivial <| nontrivial_coe_sort.1 hs\n\n"}
{"name":"Set.nontrivial_mono","module":"Mathlib.Data.Set.Subsingleton","initialProofState":"α : Type u_1\ns t : Set α\nhst : HasSubset.Subset s t\nhs : Nontrivial ↑s\n⊢ Nontrivial ↑t","decl":"theorem nontrivial_mono {α : Type*} {s t : Set α} (hst : s ⊆ t) (hs : Nontrivial s) :\n    Nontrivial t :=\n  Nontrivial.coe_sort <| (nontrivial_coe_sort.1 hs).mono hst\n\n"}
{"name":"Set.not_subsingleton_iff","module":"Mathlib.Data.Set.Subsingleton","initialProofState":"α : Type u\ns : Set α\n⊢ Iff (Not s.Subsingleton) s.Nontrivial","decl":"@[simp]\ntheorem not_subsingleton_iff : ¬s.Subsingleton ↔ s.Nontrivial := by\n  simp_rw [Set.Subsingleton, Set.Nontrivial, not_forall, exists_prop]\n\n"}
{"name":"Set.not_nontrivial_iff","module":"Mathlib.Data.Set.Subsingleton","initialProofState":"α : Type u\ns : Set α\n⊢ Iff (Not s.Nontrivial) s.Subsingleton","decl":"@[simp]\ntheorem not_nontrivial_iff : ¬s.Nontrivial ↔ s.Subsingleton :=\n  Iff.not_left not_subsingleton_iff.symm\n\n"}
{"name":"Set.Subsingleton.not_nontrivial","module":"Mathlib.Data.Set.Subsingleton","initialProofState":"α : Type u\ns : Set α\na✝ : s.Subsingleton\n⊢ Not s.Nontrivial","decl":"alias ⟨_, Subsingleton.not_nontrivial⟩ := not_nontrivial_iff\n\n"}
{"name":"Set.Nontrivial.not_subsingleton","module":"Mathlib.Data.Set.Subsingleton","initialProofState":"α : Type u\ns : Set α\na✝ : s.Nontrivial\n⊢ Not s.Subsingleton","decl":"alias ⟨_, Nontrivial.not_subsingleton⟩ := not_subsingleton_iff\n\n"}
{"name":"Set.subsingleton_or_nontrivial","module":"Mathlib.Data.Set.Subsingleton","initialProofState":"α : Type u\ns : Set α\n⊢ Or s.Subsingleton s.Nontrivial","decl":"protected lemma subsingleton_or_nontrivial (s : Set α) : s.Subsingleton ∨ s.Nontrivial := by\n  simp [or_iff_not_imp_right]\n\n"}
{"name":"Set.eq_singleton_or_nontrivial","module":"Mathlib.Data.Set.Subsingleton","initialProofState":"α : Type u\na : α\ns : Set α\nha : Membership.mem s a\n⊢ Or (Eq s (Singleton.singleton a)) s.Nontrivial","decl":"lemma eq_singleton_or_nontrivial (ha : a ∈ s) : s = {a} ∨ s.Nontrivial := by\n  rw [← subsingleton_iff_singleton ha]; exact s.subsingleton_or_nontrivial\n\n"}
{"name":"Set.nontrivial_iff_ne_singleton","module":"Mathlib.Data.Set.Subsingleton","initialProofState":"α : Type u\na : α\ns : Set α\nha : Membership.mem s a\n⊢ Iff s.Nontrivial (Ne s (Singleton.singleton a))","decl":"lemma nontrivial_iff_ne_singleton (ha : a ∈ s) : s.Nontrivial ↔ s ≠ {a} :=\n  ⟨Nontrivial.ne_singleton, (eq_singleton_or_nontrivial ha).resolve_left⟩\n\n"}
{"name":"Set.Nonempty.exists_eq_singleton_or_nontrivial","module":"Mathlib.Data.Set.Subsingleton","initialProofState":"α : Type u\ns : Set α\na✝ : s.Nonempty\n⊢ Or (Exists fun a => Eq s (Singleton.singleton a)) s.Nontrivial","decl":"lemma Nonempty.exists_eq_singleton_or_nontrivial : s.Nonempty → (∃ a, s = {a}) ∨ s.Nontrivial :=\n  fun ⟨a, ha⟩ ↦ (eq_singleton_or_nontrivial ha).imp_left <| Exists.intro a\n\n"}
{"name":"Set.univ_eq_true_false","module":"Mathlib.Data.Set.Subsingleton","initialProofState":"⊢ Eq Set.univ (Insert.insert True (Singleton.singleton False))","decl":"theorem univ_eq_true_false : univ = ({True, False} : Set Prop) :=\n  Eq.symm <| eq_univ_of_forall fun x => by\n    rw [mem_insert_iff, mem_singleton_iff]\n    exact Classical.propComplete x\n\n"}
{"name":"Set.Subsingleton.monotoneOn","module":"Mathlib.Data.Set.Subsingleton","initialProofState":"α : Type u\nβ : Type v\ns : Set α\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : α → β\nh : s.Subsingleton\n⊢ MonotoneOn f s","decl":"protected theorem Subsingleton.monotoneOn (h : s.Subsingleton) : MonotoneOn f s :=\n  fun _ ha _ hb _ => (congr_arg _ (h ha hb)).le\n\n"}
{"name":"Set.Subsingleton.antitoneOn","module":"Mathlib.Data.Set.Subsingleton","initialProofState":"α : Type u\nβ : Type v\ns : Set α\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : α → β\nh : s.Subsingleton\n⊢ AntitoneOn f s","decl":"protected theorem Subsingleton.antitoneOn (h : s.Subsingleton) : AntitoneOn f s :=\n  fun _ ha _ hb _ => (congr_arg _ (h hb ha)).le\n\n"}
{"name":"Set.Subsingleton.strictMonoOn","module":"Mathlib.Data.Set.Subsingleton","initialProofState":"α : Type u\nβ : Type v\ns : Set α\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : α → β\nh : s.Subsingleton\n⊢ StrictMonoOn f s","decl":"protected theorem Subsingleton.strictMonoOn (h : s.Subsingleton) : StrictMonoOn f s :=\n  fun _ ha _ hb hlt => (hlt.ne (h ha hb)).elim\n\n"}
{"name":"Set.Subsingleton.strictAntiOn","module":"Mathlib.Data.Set.Subsingleton","initialProofState":"α : Type u\nβ : Type v\ns : Set α\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : α → β\nh : s.Subsingleton\n⊢ StrictAntiOn f s","decl":"protected theorem Subsingleton.strictAntiOn (h : s.Subsingleton) : StrictAntiOn f s :=\n  fun _ ha _ hb hlt => (hlt.ne (h ha hb)).elim\n\n"}
{"name":"Set.monotoneOn_singleton","module":"Mathlib.Data.Set.Subsingleton","initialProofState":"α : Type u\nβ : Type v\na : α\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : α → β\n⊢ MonotoneOn f (Singleton.singleton a)","decl":"@[simp]\ntheorem monotoneOn_singleton : MonotoneOn f {a} :=\n  subsingleton_singleton.monotoneOn f\n\n"}
{"name":"Set.antitoneOn_singleton","module":"Mathlib.Data.Set.Subsingleton","initialProofState":"α : Type u\nβ : Type v\na : α\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : α → β\n⊢ AntitoneOn f (Singleton.singleton a)","decl":"@[simp]\ntheorem antitoneOn_singleton : AntitoneOn f {a} :=\n  subsingleton_singleton.antitoneOn f\n\n"}
{"name":"Set.strictMonoOn_singleton","module":"Mathlib.Data.Set.Subsingleton","initialProofState":"α : Type u\nβ : Type v\na : α\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : α → β\n⊢ StrictMonoOn f (Singleton.singleton a)","decl":"@[simp]\ntheorem strictMonoOn_singleton : StrictMonoOn f {a} :=\n  subsingleton_singleton.strictMonoOn f\n\n"}
{"name":"Set.strictAntiOn_singleton","module":"Mathlib.Data.Set.Subsingleton","initialProofState":"α : Type u\nβ : Type v\na : α\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : α → β\n⊢ StrictAntiOn f (Singleton.singleton a)","decl":"@[simp]\ntheorem strictAntiOn_singleton : StrictAntiOn f {a} :=\n  subsingleton_singleton.strictAntiOn f\n\n"}
