{"name":"iff_assoc","module":"Mathlib.Logic.Lemmas","initialProofState":"a b c : Prop\n⊢ Iff (Iff (Iff a b) c) (Iff a (Iff b c))","decl":"theorem iff_assoc {a b c : Prop} : ((a ↔ b) ↔ c) ↔ (a ↔ (b ↔ c)) := by tauto\n"}
{"name":"iff_left_comm","module":"Mathlib.Logic.Lemmas","initialProofState":"a b c : Prop\n⊢ Iff (Iff a (Iff b c)) (Iff b (Iff a c))","decl":"theorem iff_left_comm {a b c : Prop} : (a ↔ (b ↔ c)) ↔ (b ↔ (a ↔ c)) := by tauto\n"}
{"name":"iff_right_comm","module":"Mathlib.Logic.Lemmas","initialProofState":"a b c : Prop\n⊢ Iff (Iff (Iff a b) c) (Iff (Iff a c) b)","decl":"theorem iff_right_comm {a b c : Prop} : ((a ↔ b) ↔ c) ↔ ((a ↔ c) ↔ b) := by tauto\n\n"}
{"name":"HEq.eq","module":"Mathlib.Logic.Lemmas","initialProofState":"α✝ : Sort u_1\na b : α✝\na✝ : HEq a b\n⊢ Eq a b","decl":"protected alias ⟨HEq.eq, Eq.heq⟩ := heq_iff_eq\n\n"}
{"name":"Eq.heq","module":"Mathlib.Logic.Lemmas","initialProofState":"α✝ : Sort u_1\na b : α✝\na✝ : Eq a b\n⊢ HEq a b","decl":"protected alias ⟨HEq.eq, Eq.heq⟩ := heq_iff_eq\n\n"}
{"name":"dite_dite_distrib_left","module":"Mathlib.Logic.Lemmas","initialProofState":"α : Sort u_1\np q : Prop\ninst✝¹ : Decidable p\ninst✝ : Decidable q\na : p → α\nb : Not p → q → α\nc : Not p → Not q → α\n⊢ Eq (dite p a fun hp => dite q (b hp) (c hp)) (dite q (fun hq => dite p a fun hp => b hp hq) fun hq => dite p a fun hp => c hp hq)","decl":"theorem dite_dite_distrib_left {a : p → α} {b : ¬p → q → α} {c : ¬p → ¬q → α} :\n    (dite p a fun hp ↦ dite q (b hp) (c hp)) =\n      dite q (fun hq ↦ (dite p a) fun hp ↦ b hp hq) fun hq ↦ (dite p a) fun hp ↦ c hp hq := by\n  split_ifs <;> rfl\n\n"}
{"name":"dite_dite_distrib_right","module":"Mathlib.Logic.Lemmas","initialProofState":"α : Sort u_1\np q : Prop\ninst✝¹ : Decidable p\ninst✝ : Decidable q\na : p → q → α\nb : p → Not q → α\nc : Not p → α\n⊢ Eq (dite p (fun hp => dite q (a hp) (b hp)) c) (dite q (fun hq => dite p (fun hp => a hp hq) c) fun hq => dite p (fun hp => b hp hq) c)","decl":"theorem dite_dite_distrib_right {a : p → q → α} {b : p → ¬q → α} {c : ¬p → α} :\n    dite p (fun hp ↦ dite q (a hp) (b hp)) c =\n      dite q (fun hq ↦ dite p (fun hp ↦ a hp hq) c) fun hq ↦ dite p (fun hp ↦ b hp hq) c := by\n  split_ifs <;> rfl\n\n"}
{"name":"ite_dite_distrib_left","module":"Mathlib.Logic.Lemmas","initialProofState":"α : Sort u_1\np q : Prop\ninst✝¹ : Decidable p\ninst✝ : Decidable q\na : α\nb : q → α\nc : Not q → α\n⊢ Eq (ite p a (dite q b c)) (dite q (fun hq => ite p a (b hq)) fun hq => ite p a (c hq))","decl":"theorem ite_dite_distrib_left {a : α} {b : q → α} {c : ¬q → α} :\n    ite p a (dite q b c) = dite q (fun hq ↦ ite p a <| b hq) fun hq ↦ ite p a <| c hq :=\n  dite_dite_distrib_left\n\n"}
{"name":"ite_dite_distrib_right","module":"Mathlib.Logic.Lemmas","initialProofState":"α : Sort u_1\np q : Prop\ninst✝¹ : Decidable p\ninst✝ : Decidable q\na : q → α\nb : Not q → α\nc : α\n⊢ Eq (ite p (dite q a b) c) (dite q (fun hq => ite p (a hq) c) fun hq => ite p (b hq) c)","decl":"theorem ite_dite_distrib_right {a : q → α} {b : ¬q → α} {c : α} :\n    ite p (dite q a b) c = dite q (fun hq ↦ ite p (a hq) c) fun hq ↦ ite p (b hq) c :=\n  dite_dite_distrib_right\n\n"}
{"name":"dite_ite_distrib_left","module":"Mathlib.Logic.Lemmas","initialProofState":"α : Sort u_1\np q : Prop\ninst✝¹ : Decidable p\ninst✝ : Decidable q\na : p → α\nb c : Not p → α\n⊢ Eq (dite p a fun hp => ite q (b hp) (c hp)) (ite q (dite p a b) (dite p a c))","decl":"theorem dite_ite_distrib_left {a : p → α} {b : ¬p → α} {c : ¬p → α} :\n    (dite p a fun hp ↦ ite q (b hp) (c hp)) = ite q (dite p a b) (dite p a c) :=\n  dite_dite_distrib_left\n\n"}
{"name":"dite_ite_distrib_right","module":"Mathlib.Logic.Lemmas","initialProofState":"α : Sort u_1\np q : Prop\ninst✝¹ : Decidable p\ninst✝ : Decidable q\na b : p → α\nc : Not p → α\n⊢ Eq (dite p (fun hp => ite q (a hp) (b hp)) c) (ite q (dite p a c) (dite p b c))","decl":"theorem dite_ite_distrib_right {a : p → α} {b : p → α} {c : ¬p → α} :\n    dite p (fun hp ↦ ite q (a hp) (b hp)) c = ite q (dite p a c) (dite p b c) :=\n  dite_dite_distrib_right\n\n"}
{"name":"ite_ite_distrib_left","module":"Mathlib.Logic.Lemmas","initialProofState":"α : Sort u_1\np q : Prop\ninst✝¹ : Decidable p\ninst✝ : Decidable q\na b c : α\n⊢ Eq (ite p a (ite q b c)) (ite q (ite p a b) (ite p a c))","decl":"theorem ite_ite_distrib_left : ite p a (ite q b c) = ite q (ite p a b) (ite p a c) :=\n  dite_dite_distrib_left\n\n"}
{"name":"ite_ite_distrib_right","module":"Mathlib.Logic.Lemmas","initialProofState":"α : Sort u_1\np q : Prop\ninst✝¹ : Decidable p\ninst✝ : Decidable q\na b c : α\n⊢ Eq (ite p (ite q a b) c) (ite q (ite p a c) (ite p b c))","decl":"theorem ite_ite_distrib_right : ite p (ite q a b) c = ite q (ite p a c) (ite p b c) :=\n  dite_dite_distrib_right\n\n"}
{"name":"Prop.forall","module":"Mathlib.Logic.Lemmas","initialProofState":"f : Prop → Prop\n⊢ Iff (∀ (p : Prop), f p) (And (f True) (f False))","decl":"lemma Prop.forall {f : Prop → Prop} : (∀ p, f p) ↔ f True ∧ f False :=\n  ⟨fun h ↦ ⟨h _, h _⟩, by rintro ⟨h₁, h₀⟩ p; by_cases hp : p <;> simp only [hp] <;> assumption⟩\n\n"}
{"name":"Prop.exists","module":"Mathlib.Logic.Lemmas","initialProofState":"f : Prop → Prop\n⊢ Iff (Exists fun p => f p) (Or (f True) (f False))","decl":"lemma Prop.exists {f : Prop → Prop} : (∃ p, f p) ↔ f True ∨ f False :=\n  ⟨fun ⟨p, h⟩ ↦ by refine (em p).imp ?_ ?_ <;> intro H <;> convert h <;> simp [H],\n    by rintro (h | h) <;> exact ⟨_, h⟩⟩\n"}
