{"name":"Nat.squarefree_iff_nodup_primeFactorsList","module":"Mathlib.Data.Nat.Squarefree","initialProofState":"n : Nat\nh0 : Ne n 0\n⊢ Iff (Squarefree n) n.primeFactorsList.Nodup","decl":"theorem squarefree_iff_nodup_primeFactorsList {n : ℕ} (h0 : n ≠ 0) :\n    Squarefree n ↔ n.primeFactorsList.Nodup := by\n  rw [UniqueFactorizationMonoid.squarefree_iff_nodup_normalizedFactors h0, Nat.factors_eq]\n  simp\n\n"}
{"name":"Squarefree.nodup_primeFactorsList","module":"Mathlib.Data.Nat.Squarefree","initialProofState":"n : Nat\nhn : Squarefree n\n⊢ n.primeFactorsList.Nodup","decl":"theorem Squarefree.nodup_primeFactorsList {n : ℕ} (hn : Squarefree n) : n.primeFactorsList.Nodup :=\n  (Nat.squarefree_iff_nodup_primeFactorsList hn.ne_zero).mp hn\n\n"}
{"name":"Nat.squarefree_iff_prime_squarefree","module":"Mathlib.Data.Nat.Squarefree","initialProofState":"n : Nat\n⊢ Iff (Squarefree n) (∀ (x : Nat), Nat.Prime x → Not (Dvd.dvd (HMul.hMul x x) n))","decl":"theorem squarefree_iff_prime_squarefree {n : ℕ} : Squarefree n ↔ ∀ x, Prime x → ¬x * x ∣ n :=\n  squarefree_iff_irreducible_sq_not_dvd_of_exists_irreducible ⟨_, prime_two⟩\n\n"}
{"name":"Squarefree.natFactorization_le_one","module":"Mathlib.Data.Nat.Squarefree","initialProofState":"n p : Nat\nhn : Squarefree n\n⊢ LE.le (n.factorization p) 1","decl":"theorem _root_.Squarefree.natFactorization_le_one {n : ℕ} (p : ℕ) (hn : Squarefree n) :\n    n.factorization p ≤ 1 := by\n  rcases eq_or_ne n 0 with (rfl | hn')\n  · simp\n  rw [squarefree_iff_emultiplicity_le_one] at hn\n  by_cases hp : p.Prime\n  · have := hn p\n    rw [← multiplicity_eq_factorization hp hn']\n    simp only [Nat.isUnit_iff, hp.ne_one, or_false] at this\n    exact multiplicity_le_of_emultiplicity_le this\n  · rw [factorization_eq_zero_of_non_prime _ hp]\n    exact zero_le_one\n\n"}
{"name":"Nat.factorization_eq_one_of_squarefree","module":"Mathlib.Data.Nat.Squarefree","initialProofState":"n p : Nat\nhn : Squarefree n\nhp : Nat.Prime p\nhpn : Dvd.dvd p n\n⊢ Eq (n.factorization p) 1","decl":"lemma factorization_eq_one_of_squarefree (hn : Squarefree n) (hp : p.Prime) (hpn : p ∣ n) :\n    factorization n p = 1 :=\n  (hn.natFactorization_le_one _).antisymm <| (hp.dvd_iff_one_le_factorization hn.ne_zero).1 hpn\n\n"}
{"name":"Nat.squarefree_of_factorization_le_one","module":"Mathlib.Data.Nat.Squarefree","initialProofState":"n : Nat\nhn : Ne n 0\nhn' : ∀ (p : Nat), LE.le (n.factorization p) 1\n⊢ Squarefree n","decl":"theorem squarefree_of_factorization_le_one {n : ℕ} (hn : n ≠ 0) (hn' : ∀ p, n.factorization p ≤ 1) :\n    Squarefree n := by\n  rw [squarefree_iff_nodup_primeFactorsList hn, List.nodup_iff_count_le_one]\n  intro a\n  rw [primeFactorsList_count_eq]\n  apply hn'\n\n"}
{"name":"Nat.squarefree_iff_factorization_le_one","module":"Mathlib.Data.Nat.Squarefree","initialProofState":"n : Nat\nhn : Ne n 0\n⊢ Iff (Squarefree n) (∀ (p : Nat), LE.le (n.factorization p) 1)","decl":"theorem squarefree_iff_factorization_le_one {n : ℕ} (hn : n ≠ 0) :\n    Squarefree n ↔ ∀ p, n.factorization p ≤ 1 :=\n  ⟨fun hn => hn.natFactorization_le_one, squarefree_of_factorization_le_one hn⟩\n\n"}
{"name":"Nat.Squarefree.ext_iff","module":"Mathlib.Data.Nat.Squarefree","initialProofState":"n m : Nat\nhn : Squarefree n\nhm : Squarefree m\n⊢ Iff (Eq n m) (∀ (p : Nat), Nat.Prime p → Iff (Dvd.dvd p n) (Dvd.dvd p m))","decl":"theorem Squarefree.ext_iff {n m : ℕ} (hn : Squarefree n) (hm : Squarefree m) :\n    n = m ↔ ∀ p, Prime p → (p ∣ n ↔ p ∣ m) := by\n  refine ⟨by rintro rfl; simp, fun h => eq_of_factorization_eq hn.ne_zero hm.ne_zero fun p => ?_⟩\n  by_cases hp : p.Prime\n  · have h₁ := h _ hp\n    rw [← not_iff_not, hp.dvd_iff_one_le_factorization hn.ne_zero, not_le, lt_one_iff,\n      hp.dvd_iff_one_le_factorization hm.ne_zero, not_le, lt_one_iff] at h₁\n    have h₂ := hn.natFactorization_le_one p\n    have h₃ := hm.natFactorization_le_one p\n    omega\n  rw [factorization_eq_zero_of_non_prime _ hp, factorization_eq_zero_of_non_prime _ hp]\n\n"}
{"name":"Nat.squarefree_pow_iff","module":"Mathlib.Data.Nat.Squarefree","initialProofState":"n k : Nat\nhn : Ne n 1\nhk : Ne k 0\n⊢ Iff (Squarefree (HPow.hPow n k)) (And (Squarefree n) (Eq k 1))","decl":"theorem squarefree_pow_iff {n k : ℕ} (hn : n ≠ 1) (hk : k ≠ 0) :\n    Squarefree (n ^ k) ↔ Squarefree n ∧ k = 1 := by\n  refine ⟨fun h => ?_, by rintro ⟨hn, rfl⟩; simpa⟩\n  rcases eq_or_ne n 0 with (rfl | -)\n  · simp [zero_pow hk] at h\n  refine ⟨h.squarefree_of_dvd (dvd_pow_self _ hk), by_contradiction fun h₁ => ?_⟩\n  have : 2 ≤ k := k.two_le_iff.mpr ⟨hk, h₁⟩\n  apply hn (Nat.isUnit_iff.1 (h _ _))\n  rw [← sq]\n  exact pow_dvd_pow _ this\n\n"}
{"name":"Nat.squarefree_and_prime_pow_iff_prime","module":"Mathlib.Data.Nat.Squarefree","initialProofState":"n : Nat\n⊢ Iff (And (Squarefree n) (IsPrimePow n)) (Nat.Prime n)","decl":"theorem squarefree_and_prime_pow_iff_prime {n : ℕ} : Squarefree n ∧ IsPrimePow n ↔ Prime n := by\n  refine ⟨?_, fun hn => ⟨hn.squarefree, hn.isPrimePow⟩⟩\n  rw [isPrimePow_nat_iff]\n  rintro ⟨h, p, k, hp, hk, rfl⟩\n  rw [squarefree_pow_iff hp.ne_one hk.ne'] at h\n  rwa [h.2, pow_one]\n\n"}
{"name":"Nat.minSqFacProp_div","module":"Mathlib.Data.Nat.Squarefree","initialProofState":"n k : Nat\npk : Nat.Prime k\ndk : Dvd.dvd k n\ndkk : Not (Dvd.dvd (HMul.hMul k k) n)\no : Option Nat\nH : (HDiv.hDiv n k).MinSqFacProp o\n⊢ n.MinSqFacProp o","decl":"theorem minSqFacProp_div (n) {k} (pk : Prime k) (dk : k ∣ n) (dkk : ¬k * k ∣ n) {o}\n    (H : MinSqFacProp (n / k) o) : MinSqFacProp n o := by\n  have : ∀ p, Prime p → p * p ∣ n → k * (p * p) ∣ n := fun p pp dp =>\n    have :=\n      (coprime_primes pk pp).2 fun e => by\n        subst e\n        contradiction\n    (coprime_mul_iff_right.2 ⟨this, this⟩).mul_dvd_of_dvd_of_dvd dk dp\n  cases' o with d\n  · rw [MinSqFacProp, squarefree_iff_prime_squarefree] at H ⊢\n    exact fun p pp dp => H p pp ((dvd_div_iff_mul_dvd dk).2 (this _ pp dp))\n  · obtain ⟨H1, H2, H3⟩ := H\n    simp only [dvd_div_iff_mul_dvd dk] at H2 H3\n    exact ⟨H1, dvd_trans (dvd_mul_left _ _) H2, fun p pp dp => H3 _ pp (this _ pp dp)⟩\n\n"}
{"name":"Nat.minSqFacAux_has_prop","module":"Mathlib.Data.Nat.Squarefree","initialProofState":"n k : Nat\nn0 : LT.lt 0 n\ni : Nat\ne : Eq k (HAdd.hAdd (HMul.hMul 2 i) 3)\nih : ∀ (m : Nat), Nat.Prime m → Dvd.dvd m n → LE.le k m\n⊢ n.MinSqFacProp (n.minSqFacAux k)","decl":"theorem minSqFacAux_has_prop {n : ℕ} (k) (n0 : 0 < n) (i) (e : k = 2 * i + 3)\n    (ih : ∀ m, Prime m → m ∣ n → k ≤ m) : MinSqFacProp n (minSqFacAux n k) := by\n  rw [minSqFacAux]\n  by_cases h : n < k * k <;> simp only [h, ↓reduceDIte]\n  · refine squarefree_iff_prime_squarefree.2 fun p pp d => ?_\n    have := ih p pp (dvd_trans ⟨_, rfl⟩ d)\n    have := Nat.mul_le_mul this this\n    exact not_le_of_lt h (le_trans this (le_of_dvd n0 d))\n  have k2 : 2 ≤ k := by omega\n  have k0 : 0 < k := lt_of_lt_of_le (by decide) k2\n  have IH : ∀ n', n' ∣ n → ¬k ∣ n' → MinSqFacProp n' (n'.minSqFacAux (k + 2)) := by\n    intro n' nd' nk\n    have hn' := le_of_dvd n0 nd'\n    refine\n      have : Nat.sqrt n' - k < Nat.sqrt n + 2 - k :=\n        lt_of_le_of_lt (Nat.sub_le_sub_right (Nat.sqrt_le_sqrt hn') _) (Nat.minFac_lemma n k h)\n      @minSqFacAux_has_prop n' (k + 2) (pos_of_dvd_of_pos nd' n0) (i + 1)\n        (by simp [e, left_distrib]) fun m m2 d => ?_\n    rcases Nat.eq_or_lt_of_le (ih m m2 (dvd_trans d nd')) with me | ml\n    · subst me\n      contradiction\n    apply (Nat.eq_or_lt_of_le ml).resolve_left\n    intro me\n    rw [← me, e] at d\n    change 2 * (i + 2) ∣ n' at d\n    have := ih _ prime_two (dvd_trans (dvd_of_mul_right_dvd d) nd')\n    rw [e] at this\n    exact absurd this (by omega)\n  have pk : k ∣ n → Prime k := by\n    refine fun dk => prime_def_minFac.2 ⟨k2, le_antisymm (minFac_le k0) ?_⟩\n    exact ih _ (minFac_prime (ne_of_gt k2)) (dvd_trans (minFac_dvd _) dk)\n  split_ifs with dk dkk\n  · exact ⟨pk dk, (Nat.dvd_div_iff_mul_dvd dk).1 dkk, fun p pp d => ih p pp (dvd_trans ⟨_, rfl⟩ d)⟩\n  · specialize IH (n / k) (div_dvd_of_dvd dk) dkk\n    exact minSqFacProp_div _ (pk dk) dk (mt (Nat.dvd_div_iff_mul_dvd dk).2 dkk) IH\n  · exact IH n (dvd_refl _) dk\ntermination_by n.sqrt + 2 - k\n\n"}
{"name":"Nat.minSqFac_has_prop","module":"Mathlib.Data.Nat.Squarefree","initialProofState":"n : Nat\n⊢ n.MinSqFacProp n.minSqFac","decl":"theorem minSqFac_has_prop (n : ℕ) : MinSqFacProp n (minSqFac n) := by\n  dsimp only [minSqFac]; split_ifs with d2 d4\n  · exact ⟨prime_two, (dvd_div_iff_mul_dvd d2).1 d4, fun p pp _ => pp.two_le⟩\n  · rcases Nat.eq_zero_or_pos n with n0 | n0\n    · subst n0\n      cases d4 (by decide)\n    refine minSqFacProp_div _ prime_two d2 (mt (dvd_div_iff_mul_dvd d2).2 d4) ?_\n    refine minSqFacAux_has_prop 3 (Nat.div_pos (le_of_dvd n0 d2) (by decide)) 0 rfl ?_\n    refine fun p pp dp => succ_le_of_lt (lt_of_le_of_ne pp.two_le ?_)\n    rintro rfl\n    contradiction\n  · rcases Nat.eq_zero_or_pos n with n0 | n0\n    · subst n0\n      cases d2 (by decide)\n    refine minSqFacAux_has_prop _ n0 0 rfl ?_\n    refine fun p pp dp => succ_le_of_lt (lt_of_le_of_ne pp.two_le ?_)\n    rintro rfl\n    contradiction\n\n"}
{"name":"Nat.minSqFac_prime","module":"Mathlib.Data.Nat.Squarefree","initialProofState":"n d : Nat\nh : Eq n.minSqFac (Option.some d)\n⊢ Nat.Prime d","decl":"theorem minSqFac_prime {n d : ℕ} (h : n.minSqFac = some d) : Prime d := by\n  have := minSqFac_has_prop n\n  rw [h] at this\n  exact this.1\n\n"}
{"name":"Nat.minSqFac_dvd","module":"Mathlib.Data.Nat.Squarefree","initialProofState":"n d : Nat\nh : Eq n.minSqFac (Option.some d)\n⊢ Dvd.dvd (HMul.hMul d d) n","decl":"theorem minSqFac_dvd {n d : ℕ} (h : n.minSqFac = some d) : d * d ∣ n := by\n  have := minSqFac_has_prop n\n  rw [h] at this\n  exact this.2.1\n\n"}
{"name":"Nat.minSqFac_le_of_dvd","module":"Mathlib.Data.Nat.Squarefree","initialProofState":"n d : Nat\nh : Eq n.minSqFac (Option.some d)\nm : Nat\nm2 : LE.le 2 m\nmd : Dvd.dvd (HMul.hMul m m) n\n⊢ LE.le d m","decl":"theorem minSqFac_le_of_dvd {n d : ℕ} (h : n.minSqFac = some d) {m} (m2 : 2 ≤ m) (md : m * m ∣ n) :\n    d ≤ m := by\n  have := minSqFac_has_prop n; rw [h] at this\n  have fd := minFac_dvd m\n  exact\n    le_trans (this.2.2 _ (minFac_prime <| ne_of_gt m2) (dvd_trans (mul_dvd_mul fd fd) md))\n      (minFac_le <| lt_of_lt_of_le (by decide) m2)\n\n"}
{"name":"Nat.squarefree_iff_minSqFac","module":"Mathlib.Data.Nat.Squarefree","initialProofState":"n : Nat\n⊢ Iff (Squarefree n) (Eq n.minSqFac Option.none)","decl":"theorem squarefree_iff_minSqFac {n : ℕ} : Squarefree n ↔ n.minSqFac = none := by\n  have := minSqFac_has_prop n\n  constructor <;> intro H\n  · cases' e : n.minSqFac with d\n    · rfl\n    rw [e] at this\n    cases squarefree_iff_prime_squarefree.1 H _ this.1 this.2.1\n  · rwa [H] at this\n\n"}
{"name":"Nat.squarefree_two","module":"Mathlib.Data.Nat.Squarefree","initialProofState":"⊢ Squarefree 2","decl":"theorem squarefree_two : Squarefree 2 := by\n  rw [squarefree_iff_nodup_primeFactorsList] <;> simp\n\n"}
{"name":"Nat.divisors_filter_squarefree_of_squarefree","module":"Mathlib.Data.Nat.Squarefree","initialProofState":"n : Nat\nhn : Squarefree n\n⊢ Eq (Finset.filter (fun d => Squarefree d) n.divisors) n.divisors","decl":"theorem divisors_filter_squarefree_of_squarefree {n : ℕ} (hn : Squarefree n) :\n    {d ∈ n.divisors | Squarefree d} = n.divisors :=\n  Finset.ext fun d => ⟨@Finset.filter_subset _ _ _ _ d, fun hd =>\n    Finset.mem_filter.mpr ⟨hd, hn.squarefree_of_dvd (Nat.dvd_of_mem_divisors hd) ⟩⟩\n\n"}
{"name":"Nat.divisors_filter_squarefree","module":"Mathlib.Data.Nat.Squarefree","initialProofState":"n : Nat\nh0 : Ne n 0\n⊢ Eq (Finset.filter (fun d => Squarefree d) n.divisors).val (Multiset.map (fun x => x.val.prod) (UniqueFactorizationMonoid.normalizedFactors n).toFinset.powerset.val)","decl":"theorem divisors_filter_squarefree {n : ℕ} (h0 : n ≠ 0) :\n    {d ∈ n.divisors | Squarefree d}.val =\n      (UniqueFactorizationMonoid.normalizedFactors n).toFinset.powerset.val.map fun x =>\n        x.val.prod := by\n  rw [(Finset.nodup _).ext ((Finset.nodup _).map_on _)]\n  · intro a\n    simp only [Multiset.mem_filter, id, Multiset.mem_map, Finset.filter_val, ← Finset.mem_def,\n      mem_divisors]\n    constructor\n    · rintro ⟨⟨an, h0⟩, hsq⟩\n      use (UniqueFactorizationMonoid.normalizedFactors a).toFinset\n      simp only [id, Finset.mem_powerset]\n      rcases an with ⟨b, rfl⟩\n      rw [mul_ne_zero_iff] at h0\n      rw [UniqueFactorizationMonoid.squarefree_iff_nodup_normalizedFactors h0.1] at hsq\n      rw [Multiset.toFinset_subset, Multiset.toFinset_val, hsq.dedup, ← associated_iff_eq,\n        normalizedFactors_mul h0.1 h0.2]\n      exact ⟨Multiset.subset_of_le (Multiset.le_add_right _ _), prod_normalizedFactors h0.1⟩\n    · rintro ⟨s, hs, rfl⟩\n      rw [Finset.mem_powerset, ← Finset.val_le_iff, Multiset.toFinset_val] at hs\n      have hs0 : s.val.prod ≠ 0 := by\n        rw [Ne, Multiset.prod_eq_zero_iff]\n        intro con\n        apply\n          not_irreducible_zero\n            (irreducible_of_normalized_factor 0 (Multiset.mem_dedup.1 (Multiset.mem_of_le hs con)))\n      rw [(prod_normalizedFactors h0).symm.dvd_iff_dvd_right]\n      refine ⟨⟨Multiset.prod_dvd_prod_of_le (le_trans hs (Multiset.dedup_le _)), h0⟩, ?_⟩\n      have h :=\n        UniqueFactorizationMonoid.factors_unique irreducible_of_normalized_factor\n          (fun x hx =>\n            irreducible_of_normalized_factor x\n              (Multiset.mem_of_le (le_trans hs (Multiset.dedup_le _)) hx))\n          (prod_normalizedFactors hs0)\n      rw [associated_eq_eq, Multiset.rel_eq] at h\n      rw [UniqueFactorizationMonoid.squarefree_iff_nodup_normalizedFactors hs0, h]\n      apply s.nodup\n  · intro x hx y hy h\n    rw [← Finset.val_inj, ← Multiset.rel_eq, ← associated_eq_eq]\n    rw [← Finset.mem_def, Finset.mem_powerset] at hx hy\n    apply UniqueFactorizationMonoid.factors_unique _ _ (associated_iff_eq.2 h)\n    · intro z hz\n      apply irreducible_of_normalized_factor z\n      · rw [← Multiset.mem_toFinset]\n        apply hx hz\n    · intro z hz\n      apply irreducible_of_normalized_factor z\n      · rw [← Multiset.mem_toFinset]\n        apply hy hz\n\n"}
{"name":"Nat.sum_divisors_filter_squarefree","module":"Mathlib.Data.Nat.Squarefree","initialProofState":"n : Nat\nh0 : Ne n 0\nα : Type u_1\ninst✝ : AddCommMonoid α\nf : Nat → α\n⊢ Eq ((Finset.filter (fun d => Squarefree d) n.divisors).sum fun d => f d) ((UniqueFactorizationMonoid.normalizedFactors n).toFinset.powerset.sum fun i => f i.val.prod)","decl":"theorem sum_divisors_filter_squarefree {n : ℕ} (h0 : n ≠ 0) {α : Type*} [AddCommMonoid α]\n    {f : ℕ → α} :\n    ∑ d ∈ n.divisors with Squarefree d, f d =\n      ∑ i ∈ (UniqueFactorizationMonoid.normalizedFactors n).toFinset.powerset, f i.val.prod := by\n  rw [Finset.sum_eq_multiset_sum, divisors_filter_squarefree h0, Multiset.map_map,\n    Finset.sum_eq_multiset_sum]\n  rfl\n\n"}
{"name":"Nat.sq_mul_squarefree_of_pos","module":"Mathlib.Data.Nat.Squarefree","initialProofState":"n : Nat\nhn : LT.lt 0 n\n⊢ Exists fun a => Exists fun b => And (LT.lt 0 a) (And (LT.lt 0 b) (And (Eq (HMul.hMul (HPow.hPow b 2) a) n) (Squarefree a)))","decl":"theorem sq_mul_squarefree_of_pos {n : ℕ} (hn : 0 < n) :\n    ∃ a b : ℕ, 0 < a ∧ 0 < b ∧ b ^ 2 * a = n ∧ Squarefree a := by\n  classical -- Porting note: This line is not needed in Lean 3\n  set S := {s ∈ range (n + 1) | s ∣ n ∧ ∃ x, s = x ^ 2}\n  have hSne : S.Nonempty := by\n    use 1\n    have h1 : 0 < n ∧ ∃ x : ℕ, 1 = x ^ 2 := ⟨hn, ⟨1, (one_pow 2).symm⟩⟩\n    simp [S, h1]\n  let s := Finset.max' S hSne\n  have hs : s ∈ S := Finset.max'_mem S hSne\n  simp only [S, Finset.mem_filter, Finset.mem_range] at hs\n  obtain ⟨-, ⟨a, hsa⟩, ⟨b, hsb⟩⟩ := hs\n  rw [hsa] at hn\n  obtain ⟨hlts, hlta⟩ := CanonicallyOrderedAdd.mul_pos.mp hn\n  rw [hsb] at hsa hn hlts\n  refine ⟨a, b, hlta, (pow_pos_iff two_ne_zero).mp hlts, hsa.symm, ?_⟩\n  rintro x ⟨y, hy⟩\n  rw [Nat.isUnit_iff]\n  by_contra hx\n  refine Nat.lt_le_asymm ?_ (Finset.le_max' S ((b * x) ^ 2) ?_)\n  -- Porting note: these two goals were in the opposite order in Lean 3\n  · convert lt_mul_of_one_lt_right hlts\n      (one_lt_pow two_ne_zero (one_lt_iff_ne_zero_and_ne_one.mpr ⟨fun h => by simp_all, hx⟩))\n      using 1\n    rw [mul_pow]\n  · simp_rw [S, hsa, Finset.mem_filter, Finset.mem_range]\n    refine ⟨Nat.lt_succ_iff.mpr (le_of_dvd hn ?_), ?_, ⟨b * x, rfl⟩⟩ <;> use y <;> rw [hy] <;> ring\n\n"}
{"name":"Nat.sq_mul_squarefree_of_pos'","module":"Mathlib.Data.Nat.Squarefree","initialProofState":"n : Nat\nh : LT.lt 0 n\n⊢ Exists fun a => Exists fun b => And (Eq (HMul.hMul (HPow.hPow (HAdd.hAdd b 1) 2) (HAdd.hAdd a 1)) n) (Squarefree (HAdd.hAdd a 1))","decl":"theorem sq_mul_squarefree_of_pos' {n : ℕ} (h : 0 < n) :\n    ∃ a b : ℕ, (b + 1) ^ 2 * (a + 1) = n ∧ Squarefree (a + 1) := by\n  obtain ⟨a₁, b₁, ha₁, hb₁, hab₁, hab₂⟩ := sq_mul_squarefree_of_pos h\n  refine ⟨a₁.pred, b₁.pred, ?_, ?_⟩ <;> simpa only [add_one, succ_pred_eq_of_pos, ha₁, hb₁]\n\n"}
{"name":"Nat.sq_mul_squarefree","module":"Mathlib.Data.Nat.Squarefree","initialProofState":"n : Nat\n⊢ Exists fun a => Exists fun b => And (Eq (HMul.hMul (HPow.hPow b 2) a) n) (Squarefree a)","decl":"theorem sq_mul_squarefree (n : ℕ) : ∃ a b : ℕ, b ^ 2 * a = n ∧ Squarefree a := by\n  cases' n with n\n  · exact ⟨1, 0, by simp, squarefree_one⟩\n  · obtain ⟨a, b, -, -, h₁, h₂⟩ := sq_mul_squarefree_of_pos (succ_pos n)\n    exact ⟨a, b, h₁, h₂⟩\n\n"}
{"name":"Nat.squarefree_mul","module":"Mathlib.Data.Nat.Squarefree","initialProofState":"m n : Nat\nhmn : m.Coprime n\n⊢ Iff (Squarefree (HMul.hMul m n)) (And (Squarefree m) (Squarefree n))","decl":"/-- `Squarefree` is multiplicative. Note that the → direction does not require `hmn`\nand generalizes to arbitrary commutative monoids. See `Squarefree.of_mul_left` and\n`Squarefree.of_mul_right` above for auxiliary lemmas. -/\ntheorem squarefree_mul {m n : ℕ} (hmn : m.Coprime n) :\n    Squarefree (m * n) ↔ Squarefree m ∧ Squarefree n := by\n  simp only [squarefree_iff_prime_squarefree, ← sq, ← forall_and]\n  refine forall₂_congr fun p hp => ?_\n  simp only [hmn.isPrimePow_dvd_mul (hp.isPrimePow.pow two_ne_zero), not_or]\n\n"}
{"name":"Nat.coprime_of_squarefree_mul","module":"Mathlib.Data.Nat.Squarefree","initialProofState":"m n : Nat\nh : Squarefree (HMul.hMul m n)\n⊢ m.Coprime n","decl":"theorem coprime_of_squarefree_mul {m n : ℕ} (h : Squarefree (m * n)) : m.Coprime n :=\n  coprime_of_dvd fun p hp hm hn => squarefree_iff_prime_squarefree.mp h p hp (mul_dvd_mul hm hn)\n\n"}
{"name":"Nat.squarefree_mul_iff","module":"Mathlib.Data.Nat.Squarefree","initialProofState":"m n : Nat\n⊢ Iff (Squarefree (HMul.hMul m n)) (And (m.Coprime n) (And (Squarefree m) (Squarefree n)))","decl":"theorem squarefree_mul_iff {m n : ℕ} :\n    Squarefree (m * n) ↔ m.Coprime n ∧ Squarefree m ∧ Squarefree n :=\n  ⟨fun h => ⟨coprime_of_squarefree_mul h, (squarefree_mul <| coprime_of_squarefree_mul h).mp h⟩,\n    fun h => (squarefree_mul h.1).mpr h.2⟩\n\n"}
{"name":"Nat.coprime_div_gcd_of_squarefree","module":"Mathlib.Data.Nat.Squarefree","initialProofState":"m n : Nat\nhm : Squarefree m\nhn : Ne n 0\n⊢ (HDiv.hDiv m (m.gcd n)).Coprime n","decl":"lemma coprime_div_gcd_of_squarefree (hm : Squarefree m) (hn : n ≠ 0) : Coprime (m / gcd m n) n := by\n  have : Coprime (m / gcd m n) (gcd m n) :=\n    coprime_of_squarefree_mul <| by simpa [Nat.div_mul_cancel, gcd_dvd_left]\n  simpa [Nat.div_mul_cancel, gcd_dvd_right] using\n    (coprime_div_gcd_div_gcd (m := m) (gcd_ne_zero_right hn).bot_lt).mul_right this\n\n"}
{"name":"Nat.prod_primeFactors_of_squarefree","module":"Mathlib.Data.Nat.Squarefree","initialProofState":"n : Nat\nhn : Squarefree n\n⊢ Eq (n.primeFactors.prod fun p => p) n","decl":"lemma prod_primeFactors_of_squarefree (hn : Squarefree n) : ∏ p ∈ n.primeFactors, p = n := by\n  rw [← toFinset_factors, List.prod_toFinset _ hn.nodup_primeFactorsList,\n    List.map_id', Nat.prod_primeFactorsList hn.ne_zero]\n\n"}
{"name":"Nat.primeFactors_prod","module":"Mathlib.Data.Nat.Squarefree","initialProofState":"s : Finset Nat\nhs : ∀ (p : Nat), Membership.mem s p → Nat.Prime p\n⊢ Eq (s.prod fun p => p).primeFactors s","decl":"lemma primeFactors_prod (hs : ∀ p ∈ s, p.Prime) : primeFactors (∏ p ∈ s, p) = s := by\n  have hn : ∏ p ∈ s, p ≠ 0 := prod_ne_zero_iff.2 fun p hp ↦ (hs _ hp).ne_zero\n  ext p\n  rw [mem_primeFactors_of_ne_zero hn, and_congr_right (fun hp ↦ hp.prime.dvd_finset_prod_iff _)]\n  refine ⟨?_, fun hp ↦ ⟨hs _ hp, _, hp, dvd_rfl⟩⟩\n  rintro ⟨hp, q, hq, hpq⟩\n  rwa [← ((hs _ hq).dvd_iff_eq hp.ne_one).1 hpq]\n\n"}
{"name":"Nat.primeFactors_div_gcd","module":"Mathlib.Data.Nat.Squarefree","initialProofState":"m n : Nat\nhm : Squarefree m\nhn : Ne n 0\n⊢ Eq (HDiv.hDiv m (m.gcd n)).primeFactors (SDiff.sdiff m.primeFactors n.primeFactors)","decl":"lemma primeFactors_div_gcd (hm : Squarefree m) (hn : n ≠ 0) :\n    primeFactors (m / m.gcd n) = primeFactors m \\ primeFactors n := by\n  ext p\n  have : m / m.gcd n ≠ 0 := by simp [gcd_ne_zero_right hn, gcd_le_left _ hm.ne_zero.bot_lt]\n  simp only [mem_primeFactors, ne_eq, this, not_false_eq_true, and_true, not_and, mem_sdiff,\n    hm.ne_zero, hn, dvd_div_iff_mul_dvd (gcd_dvd_left _ _)]\n  refine ⟨fun hp ↦ ⟨⟨hp.1, dvd_of_mul_left_dvd hp.2⟩, fun _ hpn ↦ hp.1.not_unit <| hm _ <|\n    (mul_dvd_mul_right (dvd_gcd (dvd_of_mul_left_dvd hp.2) hpn) _).trans hp.2⟩, fun hp ↦\n      ⟨hp.1.1, Coprime.mul_dvd_of_dvd_of_dvd ?_ (gcd_dvd_left _ _) hp.1.2⟩⟩\n  rw [coprime_comm, hp.1.1.coprime_iff_not_dvd]\n  exact fun hpn ↦ hp.2 hp.1.1 <| hpn.trans <| gcd_dvd_right _ _\n\n"}
{"name":"Nat.prod_primeFactors_invOn_squarefree","module":"Mathlib.Data.Nat.Squarefree","initialProofState":"⊢ Set.InvOn (fun n => n.factorization.support) (fun s => s.prod fun p => p) (setOf fun s => ∀ (p : Nat), Membership.mem s p → Nat.Prime p) (setOf fun n => Squarefree n)","decl":"lemma prod_primeFactors_invOn_squarefree :\n    Set.InvOn (fun n : ℕ ↦ (factorization n).support) (fun s ↦ ∏ p ∈ s, p)\n      {s | ∀ p ∈ s, p.Prime} {n | Squarefree n} :=\n  ⟨fun _s ↦ primeFactors_prod, fun _n ↦ prod_primeFactors_of_squarefree⟩\n\n"}
{"name":"Nat.prod_primeFactors_sdiff_of_squarefree","module":"Mathlib.Data.Nat.Squarefree","initialProofState":"n : Nat\nhn : Squarefree n\nt : Finset Nat\nht : HasSubset.Subset t n.primeFactors\n⊢ Eq ((SDiff.sdiff n.primeFactors t).prod fun a => a) (HDiv.hDiv n (t.prod fun a => a))","decl":"theorem prod_primeFactors_sdiff_of_squarefree {n : ℕ} (hn : Squarefree n) {t : Finset ℕ}\n    (ht : t ⊆ n.primeFactors) :\n    ∏ a ∈ (n.primeFactors \\ t), a = n / ∏ a ∈ t, a := by\n  refine symm <| Nat.div_eq_of_eq_mul_left (Finset.prod_pos\n    fun p hp => (prime_of_mem_primeFactorsList (List.mem_toFinset.mp (ht hp))).pos) ?_\n  rw [Finset.prod_sdiff ht, prod_primeFactors_of_squarefree hn]\n\n"}
