{"name":"AlgebraicTopology.DoldKan.instReflectsIsomorphismsSimplicialObjectKaroubiChainComplexNatN₁","module":"Mathlib.AlgebraicTopology.DoldKan.NReflectsIso","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\n⊢ AlgebraicTopology.DoldKan.N₁.ReflectsIsomorphisms","decl":"instance : (N₁ : SimplicialObject C ⥤ Karoubi (ChainComplex C ℕ)).ReflectsIsomorphisms :=\n  ⟨fun {X Y} f => by\n    intro\n    -- restating the result in a way that allows induction on the degree n\n    suffices ∀ n : ℕ, IsIso (f.app (op [n])) by\n      haveI : ∀ Δ : SimplexCategoryᵒᵖ, IsIso (f.app Δ) := fun Δ => this Δ.unop.len\n      apply NatIso.isIso_of_isIso_app\n    -- restating the assumption in a more practical form\n    have h₁ := HomologicalComplex.congr_hom (Karoubi.hom_ext_iff.mp (IsIso.hom_inv_id (N₁.map f)))\n    have h₂ := HomologicalComplex.congr_hom (Karoubi.hom_ext_iff.mp (IsIso.inv_hom_id (N₁.map f)))\n    have h₃ := fun n =>\n      Karoubi.HomologicalComplex.p_comm_f_assoc (inv (N₁.map f)) n (f.app (op [n]))\n    simp only [N₁_map_f, Karoubi.comp_f, HomologicalComplex.comp_f,\n      AlternatingFaceMapComplex.map_f, N₁_obj_p, Karoubi.id_f, assoc] at h₁ h₂ h₃\n    -- we have to construct an inverse to f in degree n, by induction on n\n    intro n\n    induction n with\n    -- degree 0\n    | zero =>\n      use (inv (N₁.map f)).f.f 0\n      have h₁₀ := h₁ 0\n      have h₂₀ := h₂ 0\n      dsimp at h₁₀ h₂₀\n      simp only [id_comp, comp_id] at h₁₀ h₂₀\n      tauto\n    | succ n hn =>\n      haveI := hn\n      use φ { a := PInfty.f (n + 1) ≫ (inv (N₁.map f)).f.f (n + 1)\n              b := fun i => inv (f.app (op [n])) ≫ X.σ i }\n      simp only [MorphComponents.id, ← id_φ, ← preComp_φ, preComp, ← postComp_φ, postComp,\n        PInfty_f_naturality_assoc, IsIso.hom_inv_id_assoc, assoc, IsIso.inv_hom_id_assoc,\n        SimplicialObject.σ_naturality, h₁, h₂, h₃, and_self]⟩\n\n"}
{"name":"AlgebraicTopology.DoldKan.compatibility_N₂_N₁_karoubi","module":"Mathlib.AlgebraicTopology.DoldKan.NReflectsIso","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\n⊢ Eq (AlgebraicTopology.DoldKan.N₂.comp (CategoryTheory.Idempotents.karoubiChainComplexEquivalence C Nat).functor) ((CategoryTheory.Idempotents.karoubiFunctorCategoryEmbedding (Opposite SimplexCategory) C).comp (AlgebraicTopology.DoldKan.N₁.comp ((CategoryTheory.Idempotents.karoubiChainComplexEquivalence (CategoryTheory.Idempotents.Karoubi C) Nat).functor.comp ((CategoryTheory.Idempotents.KaroubiKaroubi.equivalence C).inverse.mapHomologicalComplex (ComplexShape.down Nat)))))","decl":"theorem compatibility_N₂_N₁_karoubi :\n    N₂ ⋙ (karoubiChainComplexEquivalence C ℕ).functor =\n      karoubiFunctorCategoryEmbedding SimplexCategoryᵒᵖ C ⋙\n        N₁ ⋙ (karoubiChainComplexEquivalence (Karoubi C) ℕ).functor ⋙\n            Functor.mapHomologicalComplex (KaroubiKaroubi.equivalence C).inverse _ := by\n  refine CategoryTheory.Functor.ext (fun P => ?_) fun P Q f => ?_\n  · refine HomologicalComplex.ext ?_ ?_\n    · ext n\n      · rfl\n      · dsimp\n        simp only [karoubi_PInfty_f, comp_id, PInfty_f_naturality, id_comp, eqToHom_refl]\n    · rintro _ n (rfl : n + 1 = _)\n      ext\n      have h := (AlternatingFaceMapComplex.map P.p).comm (n + 1) n\n      dsimp [N₂, karoubiChainComplexEquivalence,\n        KaroubiHomologicalComplexEquivalence.Functor.obj] at h ⊢\n      simp only [assoc, Karoubi.eqToHom_f, eqToHom_refl, comp_id,\n        karoubi_alternatingFaceMapComplex_d, karoubi_PInfty_f,\n        ← HomologicalComplex.Hom.comm_assoc, ← h, app_idem_assoc]\n  · ext n\n    dsimp [KaroubiKaroubi.inverse, Functor.mapHomologicalComplex]\n    simp only [karoubi_PInfty_f, HomologicalComplex.eqToHom_f, Karoubi.eqToHom_f,\n      assoc, comp_id, PInfty_f_naturality, app_p_comp,\n      karoubiChainComplexEquivalence_functor_obj_X_p, N₂_obj_p_f, eqToHom_refl,\n      PInfty_f_naturality_assoc, app_comp_p, PInfty_f_idem_assoc]\n\n"}
{"name":"AlgebraicTopology.DoldKan.instReflectsIsomorphismsKaroubiSimplicialObjectChainComplexNatN₂","module":"Mathlib.AlgebraicTopology.DoldKan.NReflectsIso","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\n⊢ AlgebraicTopology.DoldKan.N₂.ReflectsIsomorphisms","decl":"/-- We deduce that `N₂ : Karoubi (SimplicialObject C) ⥤ Karoubi (ChainComplex C ℕ))`\nreflects isomorphisms from the fact that\n`N₁ : SimplicialObject (Karoubi C) ⥤ Karoubi (ChainComplex (Karoubi C) ℕ)` does. -/\ninstance : (N₂ : Karoubi (SimplicialObject C) ⥤ Karoubi (ChainComplex C ℕ)).ReflectsIsomorphisms :=\n  ⟨fun f => by\n    intro\n    -- The following functor `F` reflects isomorphism because it is\n    -- a composition of four functors which reflects isomorphisms.\n    -- Then, it suffices to show that `F.map f` is an isomorphism.\n    let F₁ := karoubiFunctorCategoryEmbedding SimplexCategoryᵒᵖ C\n    let F₂ : SimplicialObject (Karoubi C) ⥤ _ := N₁\n    let F₃ := (karoubiChainComplexEquivalence (Karoubi C) ℕ).functor\n    let F₄ := Functor.mapHomologicalComplex (KaroubiKaroubi.equivalence C).inverse\n      (ComplexShape.down ℕ)\n    let F := F₁ ⋙ F₂ ⋙ F₃ ⋙ F₄\n    -- Porting note: we have to help Lean4 find the `ReflectsIsomorphisms` instances\n    -- could this be fixed by setting better instance priorities?\n    haveI : F₁.ReflectsIsomorphisms := reflectsIsomorphisms_of_full_and_faithful _\n    haveI : F₂.ReflectsIsomorphisms := by infer_instance\n    haveI : F₃.ReflectsIsomorphisms := reflectsIsomorphisms_of_full_and_faithful _\n    haveI : ((KaroubiKaroubi.equivalence C).inverse).ReflectsIsomorphisms :=\n      reflectsIsomorphisms_of_full_and_faithful _\n    have : IsIso (F.map f) := by\n      simp only [F]\n      rw [← compatibility_N₂_N₁_karoubi, Functor.comp_map]\n      apply Functor.map_isIso\n    exact isIso_of_reflects_iso f F⟩\n\n"}
