{"name":"fermatLastTheoremThree_case_1","module":"Mathlib.NumberTheory.FLT.Three","initialProofState":"a b c : Int\nhdvd : Not (Dvd.dvd 3 (HMul.hMul (HMul.hMul a b) c))\n⊢ Ne (HAdd.hAdd (HPow.hPow a 3) (HPow.hPow b 3)) (HPow.hPow c 3)","decl":"/-- If `a b c : ℤ` are such that `¬ 3 ∣ a * b * c`, then `a ^ 3 + b ^ 3 ≠ c ^ 3`. -/\ntheorem fermatLastTheoremThree_case_1 {a b c : ℤ} (hdvd : ¬ 3 ∣ a * b * c) :\n    a ^ 3 + b ^ 3 ≠ c ^ 3 := by\n  simp_rw [Int.prime_three.dvd_mul, not_or] at hdvd\n  apply mt (congrArg (Int.cast : ℤ → ZMod 9))\n  simp_rw [Int.cast_add, Int.cast_pow]\n  rcases cube_of_not_dvd hdvd.1.1 with ha | ha <;>\n  rcases cube_of_not_dvd hdvd.1.2 with hb | hb <;>\n  rcases cube_of_not_dvd hdvd.2 with hc | hc <;>\n  rw [ha, hb, hc] <;> decide\n\n"}
{"name":"fermatLastTheoremThree_of_three_dvd_only_c","module":"Mathlib.NumberTheory.FLT.Three","initialProofState":"H : ∀ (a b c : Int), Ne c 0 → Not (Dvd.dvd 3 a) → Not (Dvd.dvd 3 b) → Dvd.dvd 3 c → IsCoprime a b → Ne (HAdd.hAdd (HPow.hPow a 3) (HPow.hPow b 3)) (HPow.hPow c 3)\n⊢ FermatLastTheoremFor 3","decl":"open Finset Int in\n/--\n  To prove Fermat's Last Theorem for `n = 3`, it is enough to show that for all `a`, `b`, `c`\n  in `ℤ` such that `c ≠ 0`, `¬ 3 ∣ a`, `¬ 3 ∣ b`, `a` and `b` are coprime and `3 ∣ c`, we have\n  `a ^ 3 + b ^ 3 ≠ c ^ 3`.\n-/\ntheorem fermatLastTheoremThree_of_three_dvd_only_c\n    (H : ∀ a b c : ℤ, c ≠ 0 → ¬ 3 ∣ a → ¬ 3 ∣ b  → 3 ∣ c → IsCoprime a b → a ^ 3 + b ^ 3 ≠ c ^ 3) :\n    FermatLastTheoremFor 3 := by\n  rw [fermatLastTheoremFor_iff_int]\n  refine fermatLastTheoremWith_of_fermatLastTheoremWith_coprime (fun a b c ha hb hc Hgcd hF ↦?_)\n  by_cases h1 : 3 ∣ a * b * c\n  swap\n  · exact fermatLastTheoremThree_case_1 h1 hF\n  rw [(prime_three).dvd_mul, (prime_three).dvd_mul] at h1\n  rw [← sub_eq_zero, sub_eq_add_neg, ← (show Odd 3 by decide).neg_pow] at hF\n  rcases h1 with (h3a | h3b) | h3c\n  · refine fermatLastTheoremThree_of_dvd_a_of_gcd_eq_one_of_case2 ha h3a ?_ H hF\n    simp only [← Hgcd, insert_comm, gcd_insert, gcd_singleton, id_eq, ← abs_eq_normalize, abs_neg]\n  · rw [add_comm (a ^ 3)] at hF\n    refine fermatLastTheoremThree_of_dvd_a_of_gcd_eq_one_of_case2 hb h3b ?_ H hF\n    simp only [← Hgcd, insert_comm, gcd_insert, gcd_singleton, id_eq, ← abs_eq_normalize, abs_neg]\n  · rw [add_comm _ ((-c) ^ 3), ← add_assoc] at hF\n    refine fermatLastTheoremThree_of_dvd_a_of_gcd_eq_one_of_case2 (neg_ne_zero.2 hc) (by simp [h3c])\n      ?_ H hF\n    rw [Finset.insert_comm (-c), Finset.pair_comm (-c) b]\n    simp only [← Hgcd, insert_comm, gcd_insert, gcd_singleton, id_eq, ← abs_eq_normalize, abs_neg]\n\n"}
{"name":"FermatLastTheoremForThree_of_FermatLastTheoremThreeGen","module":"Mathlib.NumberTheory.FLT.Three","initialProofState":"K : Type u_1\ninst✝² : Field K\nζ : K\nhζ : IsPrimitiveRoot ζ ↑3\ninst✝¹ : NumberField K\ninst✝ : IsCyclotomicExtension (Singleton.singleton 3) Rat K\na✝ : FermatLastTheoremForThreeGen hζ\n⊢ FermatLastTheoremFor 3","decl":"/-- To prove `FermatLastTheoremFor 3`, it is enough to prove `FermatLastTheoremForThreeGen`. -/\nlemma FermatLastTheoremForThree_of_FermatLastTheoremThreeGen\n    [NumberField K] [IsCyclotomicExtension {3} ℚ K] :\n    FermatLastTheoremForThreeGen hζ → FermatLastTheoremFor 3 := by\n  intro H\n  refine fermatLastTheoremThree_of_three_dvd_only_c (fun a b c hc ha hb ⟨x, hx⟩ hcoprime h ↦ ?_)\n  refine H a b c 1 (by simp [hc]) (fun hdvd ↦ ha ?_) (fun hdvd ↦ hb ?_) ?_ ?_ ?_\n  · rwa [← Ideal.norm_dvd_iff (hζ.prime_norm_toInteger_sub_one_of_prime_ne_two' (by decide)),\n      hζ.norm_toInteger_sub_one_of_prime_ne_two' (by decide)] at hdvd\n  · rwa [← Ideal.norm_dvd_iff (hζ.prime_norm_toInteger_sub_one_of_prime_ne_two' (by decide)),\n      hζ.norm_toInteger_sub_one_of_prime_ne_two' (by decide)] at hdvd\n  · exact dvd_trans hζ.toInteger_sub_one_dvd_prime' ⟨x, by simp [hx]⟩\n  · rw [show a = algebraMap _ (𝓞 K) a by simp, show b = algebraMap _ (𝓞 K) b by simp]\n    exact hcoprime.map _\n  · simp only [Units.val_one, one_mul]\n    exact_mod_cast h\n\n"}
{"name":"FermatLastTheoremForThreeGen.Solution'.ha","module":"Mathlib.NumberTheory.FLT.Three","initialProofState":"K : Type u_1\ninst✝ : Field K\nζ : K\nhζ : IsPrimitiveRoot ζ ↑3\nself : FermatLastTheoremForThreeGen.Solution' hζ\n⊢ Not (Dvd.dvd (HSub.hSub hζ.toInteger 1) self.a)","decl":"/-- `Solution'` is a tuple given by a solution to `a ^ 3 + b ^ 3 = u * c ^ 3`,\nwhere `a`, `b`, `c` and `u` are as in `FermatLastTheoremForThreeGen`.\nSee `Solution` for the actual structure on which we will do the descent. -/\nstructure Solution' where\n  a : 𝓞 K\n  b : 𝓞 K\n  c : 𝓞 K\n  u : (𝓞 K)ˣ\n  ha : ¬ λ ∣ a\n  hb : ¬ λ ∣ b\n  hc : c ≠ 0\n  coprime : IsCoprime a b\n  hcdvd : λ ∣ c\n  H : a ^ 3 + b ^ 3 = u * c ^ 3\n"}
{"name":"FermatLastTheoremForThreeGen.Solution'.H","module":"Mathlib.NumberTheory.FLT.Three","initialProofState":"K : Type u_1\ninst✝ : Field K\nζ : K\nhζ : IsPrimitiveRoot ζ ↑3\nself : FermatLastTheoremForThreeGen.Solution' hζ\n⊢ Eq (HAdd.hAdd (HPow.hPow self.a 3) (HPow.hPow self.b 3)) (HMul.hMul (↑self.u) (HPow.hPow self.c 3))","decl":"/-- `Solution'` is a tuple given by a solution to `a ^ 3 + b ^ 3 = u * c ^ 3`,\nwhere `a`, `b`, `c` and `u` are as in `FermatLastTheoremForThreeGen`.\nSee `Solution` for the actual structure on which we will do the descent. -/\nstructure Solution' where\n  a : 𝓞 K\n  b : 𝓞 K\n  c : 𝓞 K\n  u : (𝓞 K)ˣ\n  ha : ¬ λ ∣ a\n  hb : ¬ λ ∣ b\n  hc : c ≠ 0\n  coprime : IsCoprime a b\n  hcdvd : λ ∣ c\n  H : a ^ 3 + b ^ 3 = u * c ^ 3\n"}
{"name":"FermatLastTheoremForThreeGen.Solution'.hc","module":"Mathlib.NumberTheory.FLT.Three","initialProofState":"K : Type u_1\ninst✝ : Field K\nζ : K\nhζ : IsPrimitiveRoot ζ ↑3\nself : FermatLastTheoremForThreeGen.Solution' hζ\n⊢ Ne self.c 0","decl":"/-- `Solution'` is a tuple given by a solution to `a ^ 3 + b ^ 3 = u * c ^ 3`,\nwhere `a`, `b`, `c` and `u` are as in `FermatLastTheoremForThreeGen`.\nSee `Solution` for the actual structure on which we will do the descent. -/\nstructure Solution' where\n  a : 𝓞 K\n  b : 𝓞 K\n  c : 𝓞 K\n  u : (𝓞 K)ˣ\n  ha : ¬ λ ∣ a\n  hb : ¬ λ ∣ b\n  hc : c ≠ 0\n  coprime : IsCoprime a b\n  hcdvd : λ ∣ c\n  H : a ^ 3 + b ^ 3 = u * c ^ 3\n"}
{"name":"FermatLastTheoremForThreeGen.Solution'.coprime","module":"Mathlib.NumberTheory.FLT.Three","initialProofState":"K : Type u_1\ninst✝ : Field K\nζ : K\nhζ : IsPrimitiveRoot ζ ↑3\nself : FermatLastTheoremForThreeGen.Solution' hζ\n⊢ IsCoprime self.a self.b","decl":"/-- `Solution'` is a tuple given by a solution to `a ^ 3 + b ^ 3 = u * c ^ 3`,\nwhere `a`, `b`, `c` and `u` are as in `FermatLastTheoremForThreeGen`.\nSee `Solution` for the actual structure on which we will do the descent. -/\nstructure Solution' where\n  a : 𝓞 K\n  b : 𝓞 K\n  c : 𝓞 K\n  u : (𝓞 K)ˣ\n  ha : ¬ λ ∣ a\n  hb : ¬ λ ∣ b\n  hc : c ≠ 0\n  coprime : IsCoprime a b\n  hcdvd : λ ∣ c\n  H : a ^ 3 + b ^ 3 = u * c ^ 3\n"}
{"name":"FermatLastTheoremForThreeGen.Solution'.mk.inj","module":"Mathlib.NumberTheory.FLT.Three","initialProofState":"K : Type u_1\ninst✝ : Field K\nζ : K\nhζ : IsPrimitiveRoot ζ ↑3\na✝ b✝ c✝ : NumberField.RingOfIntegers K\nu✝ : Units (NumberField.RingOfIntegers K)\nha✝ : Not (Dvd.dvd (HSub.hSub hζ.toInteger 1) a✝)\nhb✝ : Not (Dvd.dvd (HSub.hSub hζ.toInteger 1) b✝)\nhc✝ : Ne c✝ 0\ncoprime✝ : IsCoprime a✝ b✝\nhcdvd✝ : Dvd.dvd (HSub.hSub hζ.toInteger 1) c✝\nH✝ : Eq (HAdd.hAdd (HPow.hPow a✝ 3) (HPow.hPow b✝ 3)) (HMul.hMul (↑u✝) (HPow.hPow c✝ 3))\na b c : NumberField.RingOfIntegers K\nu : Units (NumberField.RingOfIntegers K)\nha : Not (Dvd.dvd (HSub.hSub hζ.toInteger 1) a)\nhb : Not (Dvd.dvd (HSub.hSub hζ.toInteger 1) b)\nhc : Ne c 0\ncoprime : IsCoprime a b\nhcdvd : Dvd.dvd (HSub.hSub hζ.toInteger 1) c\nH : Eq (HAdd.hAdd (HPow.hPow a 3) (HPow.hPow b 3)) (HMul.hMul (↑u) (HPow.hPow c 3))\nx✝ : Eq { a := a✝, b := b✝, c := c✝, u := u✝, ha := ha✝, hb := hb✝, hc := hc✝, coprime := coprime✝, hcdvd := hcdvd✝, H := H✝ } { a := a, b := b, c := c, u := u, ha := ha, hb := hb, hc := hc, coprime := coprime, hcdvd := hcdvd, H := H }\n⊢ And (Eq a✝ a) (And (Eq b✝ b) (And (Eq c✝ c) (Eq u✝ u)))","decl":"/-- `Solution'` is a tuple given by a solution to `a ^ 3 + b ^ 3 = u * c ^ 3`,\nwhere `a`, `b`, `c` and `u` are as in `FermatLastTheoremForThreeGen`.\nSee `Solution` for the actual structure on which we will do the descent. -/\nstructure Solution' where\n  a : 𝓞 K\n  b : 𝓞 K\n  c : 𝓞 K\n  u : (𝓞 K)ˣ\n  ha : ¬ λ ∣ a\n  hb : ¬ λ ∣ b\n  hc : c ≠ 0\n  coprime : IsCoprime a b\n  hcdvd : λ ∣ c\n  H : a ^ 3 + b ^ 3 = u * c ^ 3\n"}
{"name":"FermatLastTheoremForThreeGen.Solution'.hb","module":"Mathlib.NumberTheory.FLT.Three","initialProofState":"K : Type u_1\ninst✝ : Field K\nζ : K\nhζ : IsPrimitiveRoot ζ ↑3\nself : FermatLastTheoremForThreeGen.Solution' hζ\n⊢ Not (Dvd.dvd (HSub.hSub hζ.toInteger 1) self.b)","decl":"/-- `Solution'` is a tuple given by a solution to `a ^ 3 + b ^ 3 = u * c ^ 3`,\nwhere `a`, `b`, `c` and `u` are as in `FermatLastTheoremForThreeGen`.\nSee `Solution` for the actual structure on which we will do the descent. -/\nstructure Solution' where\n  a : 𝓞 K\n  b : 𝓞 K\n  c : 𝓞 K\n  u : (𝓞 K)ˣ\n  ha : ¬ λ ∣ a\n  hb : ¬ λ ∣ b\n  hc : c ≠ 0\n  coprime : IsCoprime a b\n  hcdvd : λ ∣ c\n  H : a ^ 3 + b ^ 3 = u * c ^ 3\n"}
{"name":"FermatLastTheoremForThreeGen.Solution'.mk.sizeOf_spec","module":"Mathlib.NumberTheory.FLT.Three","initialProofState":"K : Type u_1\ninst✝¹ : Field K\nζ : K\nhζ : IsPrimitiveRoot ζ ↑3\ninst✝ : SizeOf K\na b c : NumberField.RingOfIntegers K\nu : Units (NumberField.RingOfIntegers K)\nha : Not (Dvd.dvd (HSub.hSub hζ.toInteger 1) a)\nhb : Not (Dvd.dvd (HSub.hSub hζ.toInteger 1) b)\nhc : Ne c 0\ncoprime : IsCoprime a b\nhcdvd : Dvd.dvd (HSub.hSub hζ.toInteger 1) c\nH : Eq (HAdd.hAdd (HPow.hPow a 3) (HPow.hPow b 3)) (HMul.hMul (↑u) (HPow.hPow c 3))\n⊢ Eq (SizeOf.sizeOf { a := a, b := b, c := c, u := u, ha := ha, hb := hb, hc := hc, coprime := coprime, hcdvd := hcdvd, H := H }) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf a)) (SizeOf.sizeOf b)) (SizeOf.sizeOf c)) (SizeOf.sizeOf u)) (SizeOf.sizeOf coprime)) (SizeOf.sizeOf hcdvd)) (SizeOf.sizeOf H))","decl":"/-- `Solution'` is a tuple given by a solution to `a ^ 3 + b ^ 3 = u * c ^ 3`,\nwhere `a`, `b`, `c` and `u` are as in `FermatLastTheoremForThreeGen`.\nSee `Solution` for the actual structure on which we will do the descent. -/\nstructure Solution' where\n  a : 𝓞 K\n  b : 𝓞 K\n  c : 𝓞 K\n  u : (𝓞 K)ˣ\n  ha : ¬ λ ∣ a\n  hb : ¬ λ ∣ b\n  hc : c ≠ 0\n  coprime : IsCoprime a b\n  hcdvd : λ ∣ c\n  H : a ^ 3 + b ^ 3 = u * c ^ 3\n"}
{"name":"FermatLastTheoremForThreeGen.Solution'.mk.injEq","module":"Mathlib.NumberTheory.FLT.Three","initialProofState":"K : Type u_1\ninst✝ : Field K\nζ : K\nhζ : IsPrimitiveRoot ζ ↑3\na✝ b✝ c✝ : NumberField.RingOfIntegers K\nu✝ : Units (NumberField.RingOfIntegers K)\nha✝ : Not (Dvd.dvd (HSub.hSub hζ.toInteger 1) a✝)\nhb✝ : Not (Dvd.dvd (HSub.hSub hζ.toInteger 1) b✝)\nhc✝ : Ne c✝ 0\ncoprime✝ : IsCoprime a✝ b✝\nhcdvd✝ : Dvd.dvd (HSub.hSub hζ.toInteger 1) c✝\nH✝ : Eq (HAdd.hAdd (HPow.hPow a✝ 3) (HPow.hPow b✝ 3)) (HMul.hMul (↑u✝) (HPow.hPow c✝ 3))\na b c : NumberField.RingOfIntegers K\nu : Units (NumberField.RingOfIntegers K)\nha : Not (Dvd.dvd (HSub.hSub hζ.toInteger 1) a)\nhb : Not (Dvd.dvd (HSub.hSub hζ.toInteger 1) b)\nhc : Ne c 0\ncoprime : IsCoprime a b\nhcdvd : Dvd.dvd (HSub.hSub hζ.toInteger 1) c\nH : Eq (HAdd.hAdd (HPow.hPow a 3) (HPow.hPow b 3)) (HMul.hMul (↑u) (HPow.hPow c 3))\n⊢ Eq (Eq { a := a✝, b := b✝, c := c✝, u := u✝, ha := ha✝, hb := hb✝, hc := hc✝, coprime := coprime✝, hcdvd := hcdvd✝, H := H✝ } { a := a, b := b, c := c, u := u, ha := ha, hb := hb, hc := hc, coprime := coprime, hcdvd := hcdvd, H := H }) (And (Eq a✝ a) (And (Eq b✝ b) (And (Eq c✝ c) (Eq u✝ u))))","decl":"/-- `Solution'` is a tuple given by a solution to `a ^ 3 + b ^ 3 = u * c ^ 3`,\nwhere `a`, `b`, `c` and `u` are as in `FermatLastTheoremForThreeGen`.\nSee `Solution` for the actual structure on which we will do the descent. -/\nstructure Solution' where\n  a : 𝓞 K\n  b : 𝓞 K\n  c : 𝓞 K\n  u : (𝓞 K)ˣ\n  ha : ¬ λ ∣ a\n  hb : ¬ λ ∣ b\n  hc : c ≠ 0\n  coprime : IsCoprime a b\n  hcdvd : λ ∣ c\n  H : a ^ 3 + b ^ 3 = u * c ^ 3\n"}
{"name":"FermatLastTheoremForThreeGen.Solution'.hcdvd","module":"Mathlib.NumberTheory.FLT.Three","initialProofState":"K : Type u_1\ninst✝ : Field K\nζ : K\nhζ : IsPrimitiveRoot ζ ↑3\nself : FermatLastTheoremForThreeGen.Solution' hζ\n⊢ Dvd.dvd (HSub.hSub hζ.toInteger 1) self.c","decl":"/-- `Solution'` is a tuple given by a solution to `a ^ 3 + b ^ 3 = u * c ^ 3`,\nwhere `a`, `b`, `c` and `u` are as in `FermatLastTheoremForThreeGen`.\nSee `Solution` for the actual structure on which we will do the descent. -/\nstructure Solution' where\n  a : 𝓞 K\n  b : 𝓞 K\n  c : 𝓞 K\n  u : (𝓞 K)ˣ\n  ha : ¬ λ ∣ a\n  hb : ¬ λ ∣ b\n  hc : c ≠ 0\n  coprime : IsCoprime a b\n  hcdvd : λ ∣ c\n  H : a ^ 3 + b ^ 3 = u * c ^ 3\n"}
{"name":"FermatLastTheoremForThreeGen.Solution.mk.inj","module":"Mathlib.NumberTheory.FLT.Three","initialProofState":"K : Type u_1\ninst✝ : Field K\nζ : K\nhζ : IsPrimitiveRoot ζ ↑3\ntoSolution'✝ : FermatLastTheoremForThreeGen.Solution' hζ\nhab✝ : Dvd.dvd (HPow.hPow (HSub.hSub hζ.toInteger 1) 2) (HAdd.hAdd toSolution'✝.a toSolution'✝.b)\ntoSolution' : FermatLastTheoremForThreeGen.Solution' hζ\nhab : Dvd.dvd (HPow.hPow (HSub.hSub hζ.toInteger 1) 2) (HAdd.hAdd toSolution'.a toSolution'.b)\nx✝ : Eq { toSolution' := toSolution'✝, hab := hab✝ } { toSolution' := toSolution', hab := hab }\n⊢ Eq toSolution'✝ toSolution'","decl":"/-- `Solution` is the same as `Solution'` with the additional assumption that `λ ^ 2 ∣ a + b`. -/\nstructure Solution extends Solution' hζ where\n  hab : λ ^ 2 ∣ a + b\n\n"}
{"name":"FermatLastTheoremForThreeGen.Solution.hab","module":"Mathlib.NumberTheory.FLT.Three","initialProofState":"K : Type u_1\ninst✝ : Field K\nζ : K\nhζ : IsPrimitiveRoot ζ ↑3\nself : FermatLastTheoremForThreeGen.Solution hζ\n⊢ Dvd.dvd (HPow.hPow (HSub.hSub hζ.toInteger 1) 2) (HAdd.hAdd self.a self.b)","decl":"/-- `Solution` is the same as `Solution'` with the additional assumption that `λ ^ 2 ∣ a + b`. -/\nstructure Solution extends Solution' hζ where\n  hab : λ ^ 2 ∣ a + b\n\n"}
{"name":"FermatLastTheoremForThreeGen.Solution.mk.injEq","module":"Mathlib.NumberTheory.FLT.Three","initialProofState":"K : Type u_1\ninst✝ : Field K\nζ : K\nhζ : IsPrimitiveRoot ζ ↑3\ntoSolution'✝ : FermatLastTheoremForThreeGen.Solution' hζ\nhab✝ : Dvd.dvd (HPow.hPow (HSub.hSub hζ.toInteger 1) 2) (HAdd.hAdd toSolution'✝.a toSolution'✝.b)\ntoSolution' : FermatLastTheoremForThreeGen.Solution' hζ\nhab : Dvd.dvd (HPow.hPow (HSub.hSub hζ.toInteger 1) 2) (HAdd.hAdd toSolution'.a toSolution'.b)\n⊢ Eq (Eq { toSolution' := toSolution'✝, hab := hab✝ } { toSolution' := toSolution', hab := hab }) (Eq toSolution'✝ toSolution')","decl":"/-- `Solution` is the same as `Solution'` with the additional assumption that `λ ^ 2 ∣ a + b`. -/\nstructure Solution extends Solution' hζ where\n  hab : λ ^ 2 ∣ a + b\n\n"}
{"name":"FermatLastTheoremForThreeGen.Solution.mk.sizeOf_spec","module":"Mathlib.NumberTheory.FLT.Three","initialProofState":"K : Type u_1\ninst✝¹ : Field K\nζ : K\nhζ : IsPrimitiveRoot ζ ↑3\ninst✝ : SizeOf K\ntoSolution' : FermatLastTheoremForThreeGen.Solution' hζ\nhab : Dvd.dvd (HPow.hPow (HSub.hSub hζ.toInteger 1) 2) (HAdd.hAdd toSolution'.a toSolution'.b)\n⊢ Eq (SizeOf.sizeOf { toSolution' := toSolution', hab := hab }) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf toSolution')) (SizeOf.sizeOf hab))","decl":"/-- `Solution` is the same as `Solution'` with the additional assumption that `λ ^ 2 ∣ a + b`. -/\nstructure Solution extends Solution' hζ where\n  hab : λ ^ 2 ∣ a + b\n\n"}
{"name":"FermatLastTheoremForThreeGen.Solution'.multiplicity_lambda_c_finite","module":"Mathlib.NumberTheory.FLT.Three","initialProofState":"K : Type u_1\ninst✝² : Field K\nζ : K\nhζ : IsPrimitiveRoot ζ ↑3\nS' : FermatLastTheoremForThreeGen.Solution' hζ\ninst✝¹ : NumberField K\ninst✝ : IsCyclotomicExtension (Singleton.singleton 3) Rat K\n⊢ FiniteMultiplicity (HSub.hSub hζ.toInteger 1) S'.c","decl":"/-- For any `S' : Solution'`, the multiplicity of `λ` in `S'.c` is finite. -/\nlemma Solution'.multiplicity_lambda_c_finite :\n    FiniteMultiplicity (hζ.toInteger - 1) S'.c :=\n  .of_not_isUnit hζ.zeta_sub_one_prime'.not_unit S'.hc\n\n"}
{"name":"FermatLastTheoremForThreeGen.Solution.exists_minimal","module":"Mathlib.NumberTheory.FLT.Three","initialProofState":"K : Type u_1\ninst✝ : Field K\nζ : K\nhζ : IsPrimitiveRoot ζ ↑3\nS : FermatLastTheoremForThreeGen.Solution hζ\n⊢ Exists fun S₁ => S₁.isMinimal","decl":"omit [NumberField K] [IsCyclotomicExtension {3} ℚ K] in\ninclude S in\n/-- If there is a solution then there is a minimal one. -/\nlemma Solution.exists_minimal : ∃ (S₁ : Solution hζ), S₁.isMinimal := by\n  classical\n  let T := {n | ∃ (S' : Solution hζ), S'.multiplicity = n}\n  rcases Nat.find_spec (⟨S.multiplicity, ⟨S, rfl⟩⟩ : T.Nonempty) with ⟨S₁, hS₁⟩\n  exact ⟨S₁, fun S'' ↦ hS₁ ▸ Nat.find_min' _ ⟨S'', rfl⟩⟩\n\n"}
{"name":"FermatLastTheoremForThreeGen.a_cube_b_cube_congr_one_or_neg_one","module":"Mathlib.NumberTheory.FLT.Three","initialProofState":"K : Type u_1\ninst✝² : Field K\nζ : K\nhζ : IsPrimitiveRoot ζ ↑3\nS' : FermatLastTheoremForThreeGen.Solution' hζ\ninst✝¹ : NumberField K\ninst✝ : IsCyclotomicExtension (Singleton.singleton 3) Rat K\n⊢ Or (And (Dvd.dvd (HPow.hPow (HSub.hSub hζ.toInteger 1) 4) (HSub.hSub (HPow.hPow S'.a 3) 1)) (Dvd.dvd (HPow.hPow (HSub.hSub hζ.toInteger 1) 4) (HAdd.hAdd (HPow.hPow S'.b 3) 1))) (And (Dvd.dvd (HPow.hPow (HSub.hSub hζ.toInteger 1) 4) (HAdd.hAdd (HPow.hPow S'.a 3) 1)) (Dvd.dvd (HPow.hPow (HSub.hSub hζ.toInteger 1) 4) (HSub.hSub (HPow.hPow S'.b 3) 1)))","decl":"/-- Given `S' : Solution'`, then `S'.a` and `S'.b` are both congruent to `1` modulo `λ ^ 4` or are\nboth congruent to `-1`. -/\nlemma a_cube_b_cube_congr_one_or_neg_one :\n    λ ^ 4 ∣ S'.a ^ 3 - 1 ∧ λ ^ 4 ∣ S'.b ^ 3 + 1 ∨ λ ^ 4 ∣ S'.a ^ 3 + 1 ∧ λ ^ 4 ∣ S'.b ^ 3 - 1 := by\n  obtain ⟨z, hz⟩ := S'.hcdvd\n  rcases lambda_pow_four_dvd_cube_sub_one_or_add_one_of_lambda_not_dvd hζ S'.ha with\n    ⟨x, hx⟩ | ⟨x, hx⟩ <;>\n  rcases lambda_pow_four_dvd_cube_sub_one_or_add_one_of_lambda_not_dvd hζ S'.hb with\n    ⟨y, hy⟩ | ⟨y, hy⟩\n  · exfalso\n    replace hζ : IsPrimitiveRoot ζ ((3 : ℕ+) ^ 1) := by rwa [pow_one]\n    refine hζ.toInteger_sub_one_not_dvd_two (by decide) ⟨S'.u * λ ^ 2 * z ^ 3 - λ ^ 3 * (x + y), ?_⟩\n    symm\n    calc _ = S'.u * (λ * z) ^ 3 - λ ^ 4 * x - λ ^ 4 * y := by ring\n    _ = (S'.a ^ 3 + S'.b ^ 3) - (S'.a ^ 3 - 1) - (S'.b ^ 3 - 1) := by rw [← hx, ← hy, ← hz, ← S'.H]\n    _ = 2 := by ring\n  · left\n    exact ⟨⟨x, hx⟩, ⟨y, hy⟩⟩\n  · right\n    exact ⟨⟨x, hx⟩, ⟨y, hy⟩⟩\n  · exfalso\n    replace hζ : IsPrimitiveRoot ζ ((3 : ℕ+) ^ 1) := by rwa [pow_one]\n    refine hζ.toInteger_sub_one_not_dvd_two (by decide) ⟨λ ^ 3 * (x + y) - S'.u * λ ^ 2 * z ^ 3, ?_⟩\n    symm\n    calc _ =  λ ^ 4 * x + λ ^ 4 * y - S'.u * (λ * z) ^ 3 := by ring\n    _ = (S'.a ^ 3 + 1) + (S'.b ^ 3 + 1) - (S'.a ^ 3 + S'.b ^ 3) := by rw [← hx, ← hy, ← hz, ← S'.H]\n    _ = 2 := by ring\n\n"}
{"name":"FermatLastTheoremForThreeGen.lambda_pow_four_dvd_c_cube","module":"Mathlib.NumberTheory.FLT.Three","initialProofState":"K : Type u_1\ninst✝² : Field K\nζ : K\nhζ : IsPrimitiveRoot ζ ↑3\nS' : FermatLastTheoremForThreeGen.Solution' hζ\ninst✝¹ : NumberField K\ninst✝ : IsCyclotomicExtension (Singleton.singleton 3) Rat K\n⊢ Dvd.dvd (HPow.hPow (HSub.hSub hζ.toInteger 1) 4) (HPow.hPow S'.c 3)","decl":"/-- Given `S' : Solution'`, we have that `λ ^ 4` divides `S'.c ^ 3`. -/\nlemma lambda_pow_four_dvd_c_cube : λ ^ 4 ∣ S'.c ^ 3 := by\n  rcases a_cube_b_cube_congr_one_or_neg_one S' with\n    ⟨⟨x, hx⟩, ⟨y, hy⟩⟩ | ⟨⟨x, hx⟩, ⟨y, hy⟩⟩ <;>\n  · refine ⟨S'.u⁻¹ * (x + y), ?_⟩\n    symm\n    calc _ = S'.u⁻¹ * (λ ^ 4 * x + λ ^ 4 * y) := by ring\n    _ = S'.u⁻¹ * (S'.a ^ 3 + S'.b ^ 3) := by rw [← hx, ← hy]; ring\n    _ = S'.u⁻¹ * (S'.u * S'.c ^ 3) := by rw [S'.H]\n    _ = S'.c ^ 3 := by simp\n\n"}
{"name":"FermatLastTheoremForThreeGen.lambda_sq_dvd_c","module":"Mathlib.NumberTheory.FLT.Three","initialProofState":"K : Type u_1\ninst✝² : Field K\nζ : K\nhζ : IsPrimitiveRoot ζ ↑3\nS' : FermatLastTheoremForThreeGen.Solution' hζ\ninst✝¹ : NumberField K\ninst✝ : IsCyclotomicExtension (Singleton.singleton 3) Rat K\n⊢ Dvd.dvd (HPow.hPow (HSub.hSub hζ.toInteger 1) 2) S'.c","decl":"/-- Given `S' : Solution'`, we have that `λ ^ 2` divides `S'.c`. -/\nlemma lambda_sq_dvd_c : λ ^ 2 ∣ S'.c := by\n  have hm := S'.multiplicity_lambda_c_finite\n  suffices 2 ≤ multiplicity (hζ.toInteger - 1) S'.c by\n    obtain ⟨x, hx⟩ := pow_multiplicity_dvd (hζ.toInteger - 1) S'.c\n    refine ⟨λ ^ (multiplicity (hζ.toInteger - 1) S'.c - 2) * x, ?_⟩\n    rw [← mul_assoc, ← pow_add]\n    convert hx using 3\n    simp [this]\n  have := lambda_pow_four_dvd_c_cube S'\n  rw [pow_dvd_iff_le_emultiplicity, emultiplicity_pow hζ.zeta_sub_one_prime',\n    hm.emultiplicity_eq_multiplicity] at this\n  norm_cast at this\n  omega\n\n"}
{"name":"FermatLastTheoremForThreeGen.Solution'.two_le_multiplicity","module":"Mathlib.NumberTheory.FLT.Three","initialProofState":"K : Type u_1\ninst✝² : Field K\nζ : K\nhζ : IsPrimitiveRoot ζ ↑3\nS' : FermatLastTheoremForThreeGen.Solution' hζ\ninst✝¹ : NumberField K\ninst✝ : IsCyclotomicExtension (Singleton.singleton 3) Rat K\n⊢ LE.le 2 S'.multiplicity","decl":"/-- Given `S' : Solution'`, we have that `2 ≤ S'.multiplicity`. -/\nlemma Solution'.two_le_multiplicity : 2 ≤ S'.multiplicity := by\n  simpa [Solution'.multiplicity] using\n    S'.multiplicity_lambda_c_finite.le_multiplicity_of_pow_dvd (lambda_sq_dvd_c S')\n\n"}
{"name":"FermatLastTheoremForThreeGen.Solution.two_le_multiplicity","module":"Mathlib.NumberTheory.FLT.Three","initialProofState":"K : Type u_1\ninst✝² : Field K\nζ : K\nhζ : IsPrimitiveRoot ζ ↑3\nS : FermatLastTheoremForThreeGen.Solution hζ\ninst✝¹ : NumberField K\ninst✝ : IsCyclotomicExtension (Singleton.singleton 3) Rat K\n⊢ LE.le 2 S.multiplicity","decl":"/-- Given `S : Solution`, we have that `2 ≤ S.multiplicity`. -/\nlemma Solution.two_le_multiplicity : 2 ≤ S.multiplicity :=\n  S.toSolution'.two_le_multiplicity\n\n"}
{"name":"FermatLastTheoremForThreeGen.a_cube_add_b_cube_eq_mul","module":"Mathlib.NumberTheory.FLT.Three","initialProofState":"K : Type u_1\ninst✝ : Field K\nζ : K\nhζ : IsPrimitiveRoot ζ ↑3\nS' : FermatLastTheoremForThreeGen.Solution' hζ\n⊢ Eq (HAdd.hAdd (HPow.hPow S'.a 3) (HPow.hPow S'.b 3)) (HMul.hMul (HMul.hMul (HAdd.hAdd S'.a S'.b) (HAdd.hAdd S'.a (HMul.hMul (↑⋯.unit) S'.b))) (HAdd.hAdd S'.a (HMul.hMul (HPow.hPow (↑⋯.unit) 2) S'.b)))","decl":"/-- Given `S' : Solution'`, the key factorization of `S'.a ^ 3 + S'.b ^ 3`. -/\nlemma a_cube_add_b_cube_eq_mul :\n    S'.a ^ 3 + S'.b ^ 3 = (S'.a + S'.b) * (S'.a + η * S'.b) * (S'.a + η ^ 2 * S'.b) := by\n  symm\n  calc _ = S'.a^3+S'.a^2*S'.b*(η^2+η+1)+S'.a*S'.b^2*(η^2+η+η^3)+η^3*S'.b^3 := by ring\n  _ = S'.a^3+S'.a^2*S'.b*(η^2+η+1)+S'.a*S'.b^2*(η^2+η+1)+S'.b^3 := by\n    simp [hζ.toInteger_cube_eq_one]\n  _ = S'.a ^ 3 + S'.b ^ 3 := by rw [eta_sq]; ring\n\n"}
{"name":"FermatLastTheoremForThreeGen.lambda_sq_dvd_or_dvd_or_dvd","module":"Mathlib.NumberTheory.FLT.Three","initialProofState":"K : Type u_1\ninst✝³ : Field K\nζ : K\nhζ : IsPrimitiveRoot ζ ↑3\nS' : FermatLastTheoremForThreeGen.Solution' hζ\ninst✝² : NumberField K\ninst✝¹ : IsCyclotomicExtension (Singleton.singleton 3) Rat K\ninst✝ : DecidableRel fun a b => Dvd.dvd a b\n⊢ Or (Dvd.dvd (HPow.hPow (HSub.hSub hζ.toInteger 1) 2) (HAdd.hAdd S'.a S'.b)) (Or (Dvd.dvd (HPow.hPow (HSub.hSub hζ.toInteger 1) 2) (HAdd.hAdd S'.a (HMul.hMul (↑⋯.unit) S'.b))) (Dvd.dvd (HPow.hPow (HSub.hSub hζ.toInteger 1) 2) (HAdd.hAdd S'.a (HMul.hMul (HPow.hPow (↑⋯.unit) 2) S'.b))))","decl":"/-- Given `S' : Solution'`, we have that `λ ^ 2` divides one amongst `S'.a + S'.b`,\n`S'.a + η * S'.b` and `S'.a + η ^ 2 * S'.b`. -/\nlemma lambda_sq_dvd_or_dvd_or_dvd :\n    λ ^ 2 ∣ S'.a + S'.b ∨ λ ^ 2 ∣ S'.a + η * S'.b ∨ λ ^ 2 ∣ S'.a + η ^ 2 * S'.b := by\n  by_contra! h\n  rcases h with ⟨h1, h2, h3⟩\n  rw [← emultiplicity_lt_iff_not_dvd] at h1 h2 h3\n  have h1' : FiniteMultiplicity (hζ.toInteger - 1) (S'.a + S'.b) :=\n    finiteMultiplicity_iff_emultiplicity_ne_top.2 (fun ht ↦ by simp [ht] at h1)\n  have h2' : FiniteMultiplicity (hζ.toInteger - 1) (S'.a + η * S'.b) := by\n    refine finiteMultiplicity_iff_emultiplicity_ne_top.2 (fun ht ↦ ?_)\n    rw [coe_eta] at ht\n    simp [ht] at h2\n  have h3' : FiniteMultiplicity (hζ.toInteger - 1) (S'.a + η ^ 2 * S'.b) := by\n    refine finiteMultiplicity_iff_emultiplicity_ne_top.2 (fun ht ↦ ?_)\n    rw [coe_eta] at ht\n    simp [ht] at h3\n  rw [h1'.emultiplicity_eq_multiplicity, Nat.cast_lt] at h1\n  rw [h2'.emultiplicity_eq_multiplicity, Nat.cast_lt] at h2\n  rw [h3'.emultiplicity_eq_multiplicity, Nat.cast_lt] at h3\n  have := (pow_dvd_pow_of_dvd (lambda_sq_dvd_c S') 3).mul_left S'.u\n  rw [← pow_mul, ← S'.H, a_cube_add_b_cube_eq_mul, pow_dvd_iff_le_emultiplicity,\n    emultiplicity_mul hζ.zeta_sub_one_prime', emultiplicity_mul hζ.zeta_sub_one_prime',\n      h1'.emultiplicity_eq_multiplicity, h2'.emultiplicity_eq_multiplicity,\n      h3'.emultiplicity_eq_multiplicity, ← Nat.cast_add, ← Nat.cast_add, Nat.cast_le] at this\n  omega\n\n"}
{"name":"FermatLastTheoremForThreeGen.ex_cube_add_cube_eq_and_isCoprime_and_not_dvd_and_dvd","module":"Mathlib.NumberTheory.FLT.Three","initialProofState":"K : Type u_1\ninst✝³ : Field K\nζ : K\nhζ : IsPrimitiveRoot ζ ↑3\nS' : FermatLastTheoremForThreeGen.Solution' hζ\ninst✝² : NumberField K\ninst✝¹ : IsCyclotomicExtension (Singleton.singleton 3) Rat K\ninst✝ : DecidableRel fun a b => Dvd.dvd a b\n⊢ Exists fun a' => Exists fun b' => And (Eq (HAdd.hAdd (HPow.hPow a' 3) (HPow.hPow b' 3)) (HMul.hMul (↑S'.u) (HPow.hPow S'.c 3))) (And (IsCoprime a' b') (And (Not (Dvd.dvd (HSub.hSub hζ.toInteger 1) a')) (And (Not (Dvd.dvd (HSub.hSub hζ.toInteger 1) b')) (Dvd.dvd (HPow.hPow (HSub.hSub hζ.toInteger 1) 2) (HAdd.hAdd a' b')))))","decl":"open Units in\n/-- Given `S' : Solution'`, we may assume that `λ ^ 2` divides `S'.a + S'.b ∨ λ ^ 2` (see also the\nresult below). -/\nlemma ex_cube_add_cube_eq_and_isCoprime_and_not_dvd_and_dvd :\n    ∃ (a' b' : 𝓞 K), a' ^ 3 + b' ^ 3 = S'.u * S'.c ^ 3 ∧ IsCoprime a' b' ∧ ¬ λ ∣ a' ∧\n      ¬ λ ∣ b' ∧ λ ^ 2 ∣ a' + b' := by\n  rcases lambda_sq_dvd_or_dvd_or_dvd S' with h | h | h\n  · exact ⟨S'.a, S'.b, S'.H, S'.coprime, S'.ha, S'.hb, h⟩\n  · refine ⟨S'.a, η * S'.b, ?_, ?_, S'.ha, fun ⟨x, hx⟩ ↦ S'.hb ⟨η ^ 2 * x, ?_⟩, h⟩\n    · simp [mul_pow, ← val_pow_eq_pow_val, hζ.toInteger_cube_eq_one, val_one, one_mul, S'.H]\n    · refine (isCoprime_mul_unit_left_right (Units.isUnit η) _ _).2 S'.coprime\n    · rw [mul_comm _ x, ← mul_assoc, ← hx, mul_comm _ S'.b, mul_assoc, ← pow_succ', coe_eta,\n        hζ.toInteger_cube_eq_one, mul_one]\n  · refine ⟨S'.a, η ^ 2 * S'.b, ?_, ?_, S'.ha, fun ⟨x, hx⟩ ↦ S'.hb ⟨η * x, ?_⟩, h⟩\n    · rw [mul_pow, ← pow_mul, mul_comm 2, pow_mul, coe_eta, hζ.toInteger_cube_eq_one, one_pow,\n        one_mul, S'.H]\n    · exact (isCoprime_mul_unit_left_right ((Units.isUnit η).pow _) _ _).2 S'.coprime\n    · rw [mul_comm _ x, ← mul_assoc, ← hx, mul_comm _ S'.b, mul_assoc, ← pow_succ, coe_eta,\n        hζ.toInteger_cube_eq_one, mul_one]\n\n"}
{"name":"FermatLastTheoremForThreeGen.exists_Solution_of_Solution'","module":"Mathlib.NumberTheory.FLT.Three","initialProofState":"K : Type u_1\ninst✝³ : Field K\nζ : K\nhζ : IsPrimitiveRoot ζ ↑3\nS' : FermatLastTheoremForThreeGen.Solution' hζ\ninst✝² : NumberField K\ninst✝¹ : IsCyclotomicExtension (Singleton.singleton 3) Rat K\ninst✝ : DecidableRel fun a b => Dvd.dvd a b\n⊢ Exists fun S₁ => Eq S₁.multiplicity S'.multiplicity","decl":"/-- Given `S' : Solution'`, then there is `S₁ : Solution` such that\n`S₁.multiplicity = S'.multiplicity`. -/\nlemma exists_Solution_of_Solution' : ∃ (S₁ : Solution hζ), S₁.multiplicity = S'.multiplicity := by\n  obtain ⟨a, b, H, coprime, ha, hb, hab⟩ := ex_cube_add_cube_eq_and_isCoprime_and_not_dvd_and_dvd S'\n  exact ⟨\n  { a := a\n    b := b\n    c := S'.c\n    u := S'.u\n    ha := ha\n    hb := hb\n    hc := S'.hc\n    coprime := coprime\n    hcdvd := S'.hcdvd\n    H := H\n    hab := hab }, rfl⟩\n\n"}
{"name":"FermatLastTheoremForThreeGen.Solution.a_add_eta_mul_b","module":"Mathlib.NumberTheory.FLT.Three","initialProofState":"K : Type u_1\ninst✝ : Field K\nζ : K\nhζ : IsPrimitiveRoot ζ ↑3\nS : FermatLastTheoremForThreeGen.Solution hζ\n⊢ Eq (HAdd.hAdd S.a (HMul.hMul (↑⋯.unit) S.b)) (HAdd.hAdd (HAdd.hAdd S.a S.b) (HMul.hMul (HSub.hSub hζ.toInteger 1) S.b))","decl":"lemma a_add_eta_mul_b : S.a + η * S.b = (S.a + S.b) + λ * S.b := by rw [coe_eta]; ring\n\n"}
{"name":"FermatLastTheoremForThreeGen.Solution.lambda_dvd_a_add_eta_mul_b","module":"Mathlib.NumberTheory.FLT.Three","initialProofState":"K : Type u_1\ninst✝ : Field K\nζ : K\nhζ : IsPrimitiveRoot ζ ↑3\nS : FermatLastTheoremForThreeGen.Solution hζ\n⊢ Dvd.dvd (HSub.hSub hζ.toInteger 1) (HAdd.hAdd S.a (HMul.hMul (↑⋯.unit) S.b))","decl":"/-- Given `(S : Solution)`, we have that `λ ∣ (S.a + η * S.b)`. -/\nlemma lambda_dvd_a_add_eta_mul_b : λ ∣ (S.a + η * S.b) :=\n  a_add_eta_mul_b S ▸ dvd_add (dvd_trans (dvd_pow_self _ (by decide)) S.hab) ⟨S.b, by rw [mul_comm]⟩\n\n"}
{"name":"FermatLastTheoremForThreeGen.Solution.lambda_dvd_a_add_eta_sq_mul_b","module":"Mathlib.NumberTheory.FLT.Three","initialProofState":"K : Type u_1\ninst✝ : Field K\nζ : K\nhζ : IsPrimitiveRoot ζ ↑3\nS : FermatLastTheoremForThreeGen.Solution hζ\n⊢ Dvd.dvd (HSub.hSub hζ.toInteger 1) (HAdd.hAdd S.a (HMul.hMul (HPow.hPow (↑⋯.unit) 2) S.b))","decl":"/-- Given `(S : Solution)`, we have that `λ ∣ (S.a + η ^ 2 * S.b)`. -/\nlemma lambda_dvd_a_add_eta_sq_mul_b : λ ∣ (S.a + η ^ 2 * S.b) := by\n  rw [show S.a + η ^ 2 * S.b = (S.a + S.b) + λ ^ 2 * S.b + 2 * λ * S.b by rw [coe_eta]; ring]\n  exact dvd_add (dvd_add (dvd_trans (dvd_pow_self _ (by decide)) S.hab) ⟨λ * S.b, by ring⟩)\n    ⟨2 * S.b, by ring⟩\n\n"}
{"name":"FermatLastTheoremForThreeGen.Solution.lambda_sq_not_dvd_a_add_eta_mul_b","module":"Mathlib.NumberTheory.FLT.Three","initialProofState":"K : Type u_1\ninst✝² : Field K\nζ : K\nhζ : IsPrimitiveRoot ζ ↑3\nS : FermatLastTheoremForThreeGen.Solution hζ\ninst✝¹ : NumberField K\ninst✝ : IsCyclotomicExtension (Singleton.singleton 3) Rat K\n⊢ Not (Dvd.dvd (HPow.hPow (HSub.hSub hζ.toInteger 1) 2) (HAdd.hAdd S.a (HMul.hMul (↑⋯.unit) S.b)))","decl":"/-- Given `(S : Solution)`, we have that `λ ^ 2` does not divide `S.a + η * S.b`. -/\nlemma lambda_sq_not_dvd_a_add_eta_mul_b : ¬ λ ^ 2 ∣ (S.a + η * S.b) := by\n  simp_rw [a_add_eta_mul_b, dvd_add_right S.hab, pow_two, mul_dvd_mul_iff_left\n    hζ.zeta_sub_one_prime'.ne_zero, S.hb, not_false_eq_true]\n\n"}
{"name":"FermatLastTheoremForThreeGen.Solution.lambda_sq_not_dvd_a_add_eta_sq_mul_b","module":"Mathlib.NumberTheory.FLT.Three","initialProofState":"K : Type u_1\ninst✝² : Field K\nζ : K\nhζ : IsPrimitiveRoot ζ ↑3\nS : FermatLastTheoremForThreeGen.Solution hζ\ninst✝¹ : NumberField K\ninst✝ : IsCyclotomicExtension (Singleton.singleton 3) Rat K\n⊢ Not (Dvd.dvd (HPow.hPow (HSub.hSub hζ.toInteger 1) 2) (HAdd.hAdd S.a (HMul.hMul (HPow.hPow (↑⋯.unit) 2) S.b)))","decl":"/-- Given `(S : Solution)`, we have that `λ ^ 2` does not divide `S.a + η ^ 2 * S.b`. -/\nlemma lambda_sq_not_dvd_a_add_eta_sq_mul_b : ¬ λ ^ 2 ∣ (S.a + η ^ 2 * S.b) := by\n  intro ⟨k, hk⟩\n  rcases S.hab with ⟨k', hk'⟩\n  refine S.hb ⟨(k - k') * (-η), ?_⟩\n  rw [show S.a + η ^ 2 * S.b = S.a + S.b - S.b + η ^ 2 * S.b by ring, hk',\n    show λ ^ 2 * k' - S.b + η ^ 2 * S.b = λ * (S.b * (η +1) + λ * k') by rw [coe_eta]; ring,\n    pow_two, mul_assoc] at hk\n  simp only [mul_eq_mul_left_iff, hζ.zeta_sub_one_prime'.ne_zero, or_false] at hk\n  apply_fun (· * -↑η) at hk\n  rw [show (S.b * (η + 1) + λ * k') * -η = (- S.b) * (η ^ 2 + η + 1 - 1) - η * λ * k' by ring,\n    eta_sq, show -S.b * (-↑η - 1 + ↑η + 1 - 1) = S.b by ring, sub_eq_iff_eq_add] at hk\n  rw [hk]\n  ring\n\n"}
{"name":"FermatLastTheoremForThreeGen.Solution.associated_of_dvd_a_add_b_of_dvd_a_add_eta_mul_b","module":"Mathlib.NumberTheory.FLT.Three","initialProofState":"K : Type u_1\ninst✝² : Field K\nζ : K\nhζ : IsPrimitiveRoot ζ ↑3\nS : FermatLastTheoremForThreeGen.Solution hζ\ninst✝¹ : NumberField K\ninst✝ : IsCyclotomicExtension (Singleton.singleton 3) Rat K\np : NumberField.RingOfIntegers K\nhp : Prime p\nhpab : Dvd.dvd p (HAdd.hAdd S.a S.b)\nhpaηb : Dvd.dvd p (HAdd.hAdd S.a (HMul.hMul (↑⋯.unit) S.b))\n⊢ Associated p (HSub.hSub hζ.toInteger 1)","decl":"/-- If `p : 𝓞 K` is a prime that divides both `S.a + S.b` and `S.a + η * S.b`, then `p`\nis associated with `λ`. -/\nlemma associated_of_dvd_a_add_b_of_dvd_a_add_eta_mul_b {p : 𝓞 K} (hp : Prime p)\n    (hpab : p ∣ S.a + S.b) (hpaηb : p ∣ S.a + η * S.b) : Associated p λ := by\n  suffices p_lam : p ∣ λ from hp.associated_of_dvd hζ.zeta_sub_one_prime' p_lam\n  rw [← one_mul S.a, ← one_mul S.b] at hpab\n  rw [← one_mul S.a] at hpaηb\n  have := dvd_mul_sub_mul_mul_gcd_of_dvd hpab hpaηb\n  rwa [one_mul, one_mul, coe_eta, IsUnit.dvd_mul_right <| (gcd_isUnit_iff _ _).2 S.coprime] at this\n\n"}
{"name":"FermatLastTheoremForThreeGen.Solution.associated_of_dvd_a_add_b_of_dvd_a_add_eta_sq_mul_b","module":"Mathlib.NumberTheory.FLT.Three","initialProofState":"K : Type u_1\ninst✝² : Field K\nζ : K\nhζ : IsPrimitiveRoot ζ ↑3\nS : FermatLastTheoremForThreeGen.Solution hζ\ninst✝¹ : NumberField K\ninst✝ : IsCyclotomicExtension (Singleton.singleton 3) Rat K\np : NumberField.RingOfIntegers K\nhp : Prime p\nhpab : Dvd.dvd p (HAdd.hAdd S.a S.b)\nhpaηsqb : Dvd.dvd p (HAdd.hAdd S.a (HMul.hMul (HPow.hPow (↑⋯.unit) 2) S.b))\n⊢ Associated p (HSub.hSub hζ.toInteger 1)","decl":"/-- If `p : 𝓞 K` is a prime that divides both `S.a + S.b` and `S.a + η ^ 2 * S.b`, then `p`\nis associated with `λ`. -/\nlemma associated_of_dvd_a_add_b_of_dvd_a_add_eta_sq_mul_b {p : 𝓞 K} (hp : Prime p)\n    (hpab : p ∣ (S.a + S.b)) (hpaηsqb : p ∣ (S.a + η ^ 2 * S.b)) : Associated p λ := by\n  suffices p_lam : p ∣ λ from hp.associated_of_dvd hζ.zeta_sub_one_prime' p_lam\n  rw [← one_mul S.a, ← one_mul S.b] at hpab\n  rw [← one_mul S.a] at hpaηsqb\n  have := dvd_mul_sub_mul_mul_gcd_of_dvd hpab hpaηsqb\n  rw [one_mul, mul_one, IsUnit.dvd_mul_right <| (gcd_isUnit_iff _ _).2 S.coprime, ← dvd_neg] at this\n  convert dvd_mul_of_dvd_left this η using 1\n  rw [eta_sq, neg_sub, sub_mul, sub_mul, neg_mul, ← pow_two, eta_sq, coe_eta]\n  ring\n\n"}
{"name":"FermatLastTheoremForThreeGen.Solution.associated_of_dvd_a_add_eta_mul_b_of_dvd_a_add_eta_sq_mul_b","module":"Mathlib.NumberTheory.FLT.Three","initialProofState":"K : Type u_1\ninst✝² : Field K\nζ : K\nhζ : IsPrimitiveRoot ζ ↑3\nS : FermatLastTheoremForThreeGen.Solution hζ\ninst✝¹ : NumberField K\ninst✝ : IsCyclotomicExtension (Singleton.singleton 3) Rat K\np : NumberField.RingOfIntegers K\nhp : Prime p\nhpaηb : Dvd.dvd p (HAdd.hAdd S.a (HMul.hMul (↑⋯.unit) S.b))\nhpaηsqb : Dvd.dvd p (HAdd.hAdd S.a (HMul.hMul (HPow.hPow (↑⋯.unit) 2) S.b))\n⊢ Associated p (HSub.hSub hζ.toInteger 1)","decl":"/-- If `p : 𝓞 K` is a prime that divides both `S.a + η * S.b` and `S.a + η ^ 2 * S.b`, then `p`\nis associated with `λ`. -/\nlemma associated_of_dvd_a_add_eta_mul_b_of_dvd_a_add_eta_sq_mul_b {p : 𝓞 K} (hp : Prime p)\n    (hpaηb : p ∣ S.a + η * S.b) (hpaηsqb : p ∣ S.a + η ^ 2 * S.b) : Associated p λ := by\n  suffices p_lam : p ∣ λ from hp.associated_of_dvd hζ.zeta_sub_one_prime' p_lam\n  rw [← one_mul S.a] at hpaηb\n  rw [← one_mul S.a] at hpaηsqb\n  have := dvd_mul_sub_mul_mul_gcd_of_dvd hpaηb hpaηsqb\n  rw [one_mul, mul_one, IsUnit.dvd_mul_right <| (gcd_isUnit_iff _ _).2 S.coprime] at this\n  convert (dvd_mul_of_dvd_left (dvd_mul_of_dvd_left this η) η) using 1\n  symm\n  calc _ = (-η.1 - 1 - η) * (-η - 1) := by rw [eta_sq, mul_assoc, ← pow_two, eta_sq]\n  _ = 2 * η.1 ^ 2 + 3 * η + 1 := by ring\n  _ = λ := by rw [eta_sq, coe_eta]; ring\n\n"}
{"name":"FermatLastTheoremForThreeGen.Solution.Solution'_descent_multiplicity","module":"Mathlib.NumberTheory.FLT.Three","initialProofState":"K : Type u_1\ninst✝² : Field K\nζ : K\nhζ : IsPrimitiveRoot ζ ↑3\nS : FermatLastTheoremForThreeGen.Solution hζ\ninst✝¹ : NumberField K\ninst✝ : IsCyclotomicExtension (Singleton.singleton 3) Rat K\n⊢ Eq S.Solution'_descent.multiplicity (HSub.hSub S.multiplicity 1)","decl":"/-- We have that `S.Solution'_descent.multiplicity = S.multiplicity - 1`. -/\nlemma Solution'_descent_multiplicity : S.Solution'_descent.multiplicity = S.multiplicity - 1 := by\n  refine multiplicity_eq_of_dvd_of_not_dvd\n    (by simp [Solution'_descent]) (fun h ↦ S.lambda_not_dvd_X ?_)\n  obtain ⟨k, hk : λ^(S.multiplicity-1)*S.X=λ^(S.multiplicity-1+1)*k⟩ := h\n  rw [pow_succ, mul_assoc] at hk\n  simp only [mul_eq_mul_left_iff, pow_eq_zero_iff', hζ.zeta_sub_one_prime'.ne_zero, ne_eq,\n    false_and, or_false] at hk\n  simp [hk]\n\n"}
{"name":"FermatLastTheoremForThreeGen.Solution.Solution'_descent_multiplicity_lt","module":"Mathlib.NumberTheory.FLT.Three","initialProofState":"K : Type u_1\ninst✝² : Field K\nζ : K\nhζ : IsPrimitiveRoot ζ ↑3\nS : FermatLastTheoremForThreeGen.Solution hζ\ninst✝¹ : NumberField K\ninst✝ : IsCyclotomicExtension (Singleton.singleton 3) Rat K\n⊢ LT.lt S.Solution'_descent.multiplicity S.multiplicity","decl":"/-- We have that `S.Solution'_descent.multiplicity < S.multiplicity`. -/\nlemma Solution'_descent_multiplicity_lt :\n    (Solution'_descent S).multiplicity < S.multiplicity := by\n  rw [Solution'_descent_multiplicity S, Nat.sub_one]\n  exact Nat.pred_lt <| by have := S.two_le_multiplicity; omega\n\n"}
{"name":"FermatLastTheoremForThreeGen.Solution.exists_Solution_multiplicity_lt","module":"Mathlib.NumberTheory.FLT.Three","initialProofState":"K : Type u_1\ninst✝² : Field K\nζ : K\nhζ : IsPrimitiveRoot ζ ↑3\nS : FermatLastTheoremForThreeGen.Solution hζ\ninst✝¹ : NumberField K\ninst✝ : IsCyclotomicExtension (Singleton.singleton 3) Rat K\n⊢ Exists fun S₁ => LT.lt S₁.multiplicity S.multiplicity","decl":"/-- Given any `S : Solution`, there is another `S₁ : Solution` such that\n  `S₁.multiplicity < S.multiplicity` -/\ntheorem exists_Solution_multiplicity_lt :\n    ∃ S₁ : Solution hζ, S₁.multiplicity < S.multiplicity := by classical\n  obtain ⟨S', hS'⟩ := exists_Solution_of_Solution' (Solution'_descent S)\n  exact ⟨S', hS' ▸ Solution'_descent_multiplicity_lt S⟩\n\n"}
{"name":"fermatLastTheoremThree","module":"Mathlib.NumberTheory.FLT.Three","initialProofState":"⊢ FermatLastTheoremFor 3","decl":"/-- Fermat's Last Theorem for `n = 3`: if `a b c : ℕ` are all non-zero then\n`a ^ 3 + b ^ 3 ≠ c ^ 3`. -/\ntheorem fermatLastTheoremThree : FermatLastTheoremFor 3 := by\n  classical\n  let K := CyclotomicField 3 ℚ\n  let hζ := IsCyclotomicExtension.zeta_spec 3 ℚ K\n  have : NumberField K := IsCyclotomicExtension.numberField {3} ℚ _\n  apply FermatLastTheoremForThree_of_FermatLastTheoremThreeGen hζ\n  intro a b c u hc ha hb hcdvd coprime H\n  let S' : FermatLastTheoremForThreeGen.Solution' hζ :=\n  { a := a\n    b := b\n    c := c\n    u := u\n    ha := ha\n    hb := hb\n    hc := hc\n    coprime := coprime\n    hcdvd := hcdvd\n    H := H }\n  obtain ⟨S, -⟩ := FermatLastTheoremForThreeGen.exists_Solution_of_Solution' S'\n  obtain ⟨Smin, hSmin⟩ := S.exists_minimal\n  obtain ⟨Sfin, hSfin⟩ := Smin.exists_Solution_multiplicity_lt\n  linarith [hSmin Sfin]\n"}
