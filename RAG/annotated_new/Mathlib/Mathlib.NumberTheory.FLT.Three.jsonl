{"name":"fermatLastTheoremThree_case_1","module":"Mathlib.NumberTheory.FLT.Three","initialProofState":"a b c : Int\nhdvd : Not (Dvd.dvd 3 (HMul.hMul (HMul.hMul a b) c))\n‚ä¢ Ne (HAdd.hAdd (HPow.hPow a 3) (HPow.hPow b 3)) (HPow.hPow c 3)","decl":"/-- If `a b c : ‚Ñ§` are such that `¬¨ 3 ‚à£ a * b * c`, then `a ^ 3 + b ^ 3 ‚â† c ^ 3`. -/\ntheorem fermatLastTheoremThree_case_1 {a b c : ‚Ñ§} (hdvd : ¬¨ 3 ‚à£ a * b * c) :\n    a ^ 3 + b ^ 3 ‚â† c ^ 3 := by\n  simp_rw [Int.prime_three.dvd_mul, not_or] at hdvd\n  apply mt (congrArg (Int.cast : ‚Ñ§ ‚Üí ZMod 9))\n  simp_rw [Int.cast_add, Int.cast_pow]\n  rcases cube_of_not_dvd hdvd.1.1 with ha | ha <;>\n  rcases cube_of_not_dvd hdvd.1.2 with hb | hb <;>\n  rcases cube_of_not_dvd hdvd.2 with hc | hc <;>\n  rw [ha, hb, hc] <;> decide\n\n"}
{"name":"fermatLastTheoremThree_of_three_dvd_only_c","module":"Mathlib.NumberTheory.FLT.Three","initialProofState":"H : ‚àÄ (a b c : Int), Ne c 0 ‚Üí Not (Dvd.dvd 3 a) ‚Üí Not (Dvd.dvd 3 b) ‚Üí Dvd.dvd 3 c ‚Üí IsCoprime a b ‚Üí Ne (HAdd.hAdd (HPow.hPow a 3) (HPow.hPow b 3)) (HPow.hPow c 3)\n‚ä¢ FermatLastTheoremFor 3","decl":"open Finset Int in\n/--\n  To prove Fermat's Last Theorem for `n = 3`, it is enough to show that for all `a`, `b`, `c`\n  in `‚Ñ§` such that `c ‚â† 0`, `¬¨ 3 ‚à£ a`, `¬¨ 3 ‚à£ b`, `a` and `b` are coprime and `3 ‚à£ c`, we have\n  `a ^ 3 + b ^ 3 ‚â† c ^ 3`.\n-/\ntheorem fermatLastTheoremThree_of_three_dvd_only_c\n    (H : ‚àÄ a b c : ‚Ñ§, c ‚â† 0 ‚Üí ¬¨ 3 ‚à£ a ‚Üí ¬¨ 3 ‚à£ b  ‚Üí 3 ‚à£ c ‚Üí IsCoprime a b ‚Üí a ^ 3 + b ^ 3 ‚â† c ^ 3) :\n    FermatLastTheoremFor 3 := by\n  rw [fermatLastTheoremFor_iff_int]\n  refine fermatLastTheoremWith_of_fermatLastTheoremWith_coprime (fun a b c ha hb hc Hgcd hF ‚Ü¶?_)\n  by_cases h1 : 3 ‚à£ a * b * c\n  swap\n  ¬∑ exact fermatLastTheoremThree_case_1 h1 hF\n  rw [(prime_three).dvd_mul, (prime_three).dvd_mul] at h1\n  rw [‚Üê sub_eq_zero, sub_eq_add_neg, ‚Üê (show Odd 3 by decide).neg_pow] at hF\n  rcases h1 with (h3a | h3b) | h3c\n  ¬∑ refine fermatLastTheoremThree_of_dvd_a_of_gcd_eq_one_of_case2 ha h3a ?_ H hF\n    simp only [‚Üê Hgcd, insert_comm, gcd_insert, gcd_singleton, id_eq, ‚Üê abs_eq_normalize, abs_neg]\n  ¬∑ rw [add_comm (a ^ 3)] at hF\n    refine fermatLastTheoremThree_of_dvd_a_of_gcd_eq_one_of_case2 hb h3b ?_ H hF\n    simp only [‚Üê Hgcd, insert_comm, gcd_insert, gcd_singleton, id_eq, ‚Üê abs_eq_normalize, abs_neg]\n  ¬∑ rw [add_comm _ ((-c) ^ 3), ‚Üê add_assoc] at hF\n    refine fermatLastTheoremThree_of_dvd_a_of_gcd_eq_one_of_case2 (neg_ne_zero.2 hc) (by simp [h3c])\n      ?_ H hF\n    rw [Finset.insert_comm (-c), Finset.pair_comm (-c) b]\n    simp only [‚Üê Hgcd, insert_comm, gcd_insert, gcd_singleton, id_eq, ‚Üê abs_eq_normalize, abs_neg]\n\n"}
{"name":"FermatLastTheoremForThree_of_FermatLastTheoremThreeGen","module":"Mathlib.NumberTheory.FLT.Three","initialProofState":"K : Type u_1\ninst‚úù¬≤ : Field K\nŒ∂ : K\nhŒ∂ : IsPrimitiveRoot Œ∂ ‚Üë3\ninst‚úù¬π : NumberField K\ninst‚úù : IsCyclotomicExtension (Singleton.singleton 3) Rat K\na‚úù : FermatLastTheoremForThreeGen hŒ∂\n‚ä¢ FermatLastTheoremFor 3","decl":"/-- To prove `FermatLastTheoremFor 3`, it is enough to prove `FermatLastTheoremForThreeGen`. -/\nlemma FermatLastTheoremForThree_of_FermatLastTheoremThreeGen\n    [NumberField K] [IsCyclotomicExtension {3} ‚Ñö K] :\n    FermatLastTheoremForThreeGen hŒ∂ ‚Üí FermatLastTheoremFor 3 := by\n  intro H\n  refine fermatLastTheoremThree_of_three_dvd_only_c (fun a b c hc ha hb ‚ü®x, hx‚ü© hcoprime h ‚Ü¶ ?_)\n  refine H a b c 1 (by simp [hc]) (fun hdvd ‚Ü¶ ha ?_) (fun hdvd ‚Ü¶ hb ?_) ?_ ?_ ?_\n  ¬∑ rwa [‚Üê Ideal.norm_dvd_iff (hŒ∂.prime_norm_toInteger_sub_one_of_prime_ne_two' (by decide)),\n      hŒ∂.norm_toInteger_sub_one_of_prime_ne_two' (by decide)] at hdvd\n  ¬∑ rwa [‚Üê Ideal.norm_dvd_iff (hŒ∂.prime_norm_toInteger_sub_one_of_prime_ne_two' (by decide)),\n      hŒ∂.norm_toInteger_sub_one_of_prime_ne_two' (by decide)] at hdvd\n  ¬∑ exact dvd_trans hŒ∂.toInteger_sub_one_dvd_prime' ‚ü®x, by simp [hx]‚ü©\n  ¬∑ rw [show a = algebraMap _ (ùìû K) a by simp, show b = algebraMap _ (ùìû K) b by simp]\n    exact hcoprime.map _\n  ¬∑ simp only [Units.val_one, one_mul]\n    exact_mod_cast h\n\n"}
{"name":"FermatLastTheoremForThreeGen.Solution'.ha","module":"Mathlib.NumberTheory.FLT.Three","initialProofState":"K : Type u_1\ninst‚úù : Field K\nŒ∂ : K\nhŒ∂ : IsPrimitiveRoot Œ∂ ‚Üë3\nself : FermatLastTheoremForThreeGen.Solution' hŒ∂\n‚ä¢ Not (Dvd.dvd (HSub.hSub hŒ∂.toInteger 1) self.a)","decl":"/-- `Solution'` is a tuple given by a solution to `a ^ 3 + b ^ 3 = u * c ^ 3`,\nwhere `a`, `b`, `c` and `u` are as in `FermatLastTheoremForThreeGen`.\nSee `Solution` for the actual structure on which we will do the descent. -/\nstructure Solution' where\n  a : ùìû K\n  b : ùìû K\n  c : ùìû K\n  u : (ùìû K)À£\n  ha : ¬¨ Œª ‚à£ a\n  hb : ¬¨ Œª ‚à£ b\n  hc : c ‚â† 0\n  coprime : IsCoprime a b\n  hcdvd : Œª ‚à£ c\n  H : a ^ 3 + b ^ 3 = u * c ^ 3\n"}
{"name":"FermatLastTheoremForThreeGen.Solution'.H","module":"Mathlib.NumberTheory.FLT.Three","initialProofState":"K : Type u_1\ninst‚úù : Field K\nŒ∂ : K\nhŒ∂ : IsPrimitiveRoot Œ∂ ‚Üë3\nself : FermatLastTheoremForThreeGen.Solution' hŒ∂\n‚ä¢ Eq (HAdd.hAdd (HPow.hPow self.a 3) (HPow.hPow self.b 3)) (HMul.hMul (‚Üëself.u) (HPow.hPow self.c 3))","decl":"/-- `Solution'` is a tuple given by a solution to `a ^ 3 + b ^ 3 = u * c ^ 3`,\nwhere `a`, `b`, `c` and `u` are as in `FermatLastTheoremForThreeGen`.\nSee `Solution` for the actual structure on which we will do the descent. -/\nstructure Solution' where\n  a : ùìû K\n  b : ùìû K\n  c : ùìû K\n  u : (ùìû K)À£\n  ha : ¬¨ Œª ‚à£ a\n  hb : ¬¨ Œª ‚à£ b\n  hc : c ‚â† 0\n  coprime : IsCoprime a b\n  hcdvd : Œª ‚à£ c\n  H : a ^ 3 + b ^ 3 = u * c ^ 3\n"}
{"name":"FermatLastTheoremForThreeGen.Solution'.hc","module":"Mathlib.NumberTheory.FLT.Three","initialProofState":"K : Type u_1\ninst‚úù : Field K\nŒ∂ : K\nhŒ∂ : IsPrimitiveRoot Œ∂ ‚Üë3\nself : FermatLastTheoremForThreeGen.Solution' hŒ∂\n‚ä¢ Ne self.c 0","decl":"/-- `Solution'` is a tuple given by a solution to `a ^ 3 + b ^ 3 = u * c ^ 3`,\nwhere `a`, `b`, `c` and `u` are as in `FermatLastTheoremForThreeGen`.\nSee `Solution` for the actual structure on which we will do the descent. -/\nstructure Solution' where\n  a : ùìû K\n  b : ùìû K\n  c : ùìû K\n  u : (ùìû K)À£\n  ha : ¬¨ Œª ‚à£ a\n  hb : ¬¨ Œª ‚à£ b\n  hc : c ‚â† 0\n  coprime : IsCoprime a b\n  hcdvd : Œª ‚à£ c\n  H : a ^ 3 + b ^ 3 = u * c ^ 3\n"}
{"name":"FermatLastTheoremForThreeGen.Solution'.coprime","module":"Mathlib.NumberTheory.FLT.Three","initialProofState":"K : Type u_1\ninst‚úù : Field K\nŒ∂ : K\nhŒ∂ : IsPrimitiveRoot Œ∂ ‚Üë3\nself : FermatLastTheoremForThreeGen.Solution' hŒ∂\n‚ä¢ IsCoprime self.a self.b","decl":"/-- `Solution'` is a tuple given by a solution to `a ^ 3 + b ^ 3 = u * c ^ 3`,\nwhere `a`, `b`, `c` and `u` are as in `FermatLastTheoremForThreeGen`.\nSee `Solution` for the actual structure on which we will do the descent. -/\nstructure Solution' where\n  a : ùìû K\n  b : ùìû K\n  c : ùìû K\n  u : (ùìû K)À£\n  ha : ¬¨ Œª ‚à£ a\n  hb : ¬¨ Œª ‚à£ b\n  hc : c ‚â† 0\n  coprime : IsCoprime a b\n  hcdvd : Œª ‚à£ c\n  H : a ^ 3 + b ^ 3 = u * c ^ 3\n"}
{"name":"FermatLastTheoremForThreeGen.Solution'.mk.inj","module":"Mathlib.NumberTheory.FLT.Three","initialProofState":"K : Type u_1\ninst‚úù : Field K\nŒ∂ : K\nhŒ∂ : IsPrimitiveRoot Œ∂ ‚Üë3\na‚úù b‚úù c‚úù : NumberField.RingOfIntegers K\nu‚úù : Units (NumberField.RingOfIntegers K)\nha‚úù : Not (Dvd.dvd (HSub.hSub hŒ∂.toInteger 1) a‚úù)\nhb‚úù : Not (Dvd.dvd (HSub.hSub hŒ∂.toInteger 1) b‚úù)\nhc‚úù : Ne c‚úù 0\ncoprime‚úù : IsCoprime a‚úù b‚úù\nhcdvd‚úù : Dvd.dvd (HSub.hSub hŒ∂.toInteger 1) c‚úù\nH‚úù : Eq (HAdd.hAdd (HPow.hPow a‚úù 3) (HPow.hPow b‚úù 3)) (HMul.hMul (‚Üëu‚úù) (HPow.hPow c‚úù 3))\na b c : NumberField.RingOfIntegers K\nu : Units (NumberField.RingOfIntegers K)\nha : Not (Dvd.dvd (HSub.hSub hŒ∂.toInteger 1) a)\nhb : Not (Dvd.dvd (HSub.hSub hŒ∂.toInteger 1) b)\nhc : Ne c 0\ncoprime : IsCoprime a b\nhcdvd : Dvd.dvd (HSub.hSub hŒ∂.toInteger 1) c\nH : Eq (HAdd.hAdd (HPow.hPow a 3) (HPow.hPow b 3)) (HMul.hMul (‚Üëu) (HPow.hPow c 3))\nx‚úù : Eq { a := a‚úù, b := b‚úù, c := c‚úù, u := u‚úù, ha := ha‚úù, hb := hb‚úù, hc := hc‚úù, coprime := coprime‚úù, hcdvd := hcdvd‚úù, H := H‚úù } { a := a, b := b, c := c, u := u, ha := ha, hb := hb, hc := hc, coprime := coprime, hcdvd := hcdvd, H := H }\n‚ä¢ And (Eq a‚úù a) (And (Eq b‚úù b) (And (Eq c‚úù c) (Eq u‚úù u)))","decl":"/-- `Solution'` is a tuple given by a solution to `a ^ 3 + b ^ 3 = u * c ^ 3`,\nwhere `a`, `b`, `c` and `u` are as in `FermatLastTheoremForThreeGen`.\nSee `Solution` for the actual structure on which we will do the descent. -/\nstructure Solution' where\n  a : ùìû K\n  b : ùìû K\n  c : ùìû K\n  u : (ùìû K)À£\n  ha : ¬¨ Œª ‚à£ a\n  hb : ¬¨ Œª ‚à£ b\n  hc : c ‚â† 0\n  coprime : IsCoprime a b\n  hcdvd : Œª ‚à£ c\n  H : a ^ 3 + b ^ 3 = u * c ^ 3\n"}
{"name":"FermatLastTheoremForThreeGen.Solution'.hb","module":"Mathlib.NumberTheory.FLT.Three","initialProofState":"K : Type u_1\ninst‚úù : Field K\nŒ∂ : K\nhŒ∂ : IsPrimitiveRoot Œ∂ ‚Üë3\nself : FermatLastTheoremForThreeGen.Solution' hŒ∂\n‚ä¢ Not (Dvd.dvd (HSub.hSub hŒ∂.toInteger 1) self.b)","decl":"/-- `Solution'` is a tuple given by a solution to `a ^ 3 + b ^ 3 = u * c ^ 3`,\nwhere `a`, `b`, `c` and `u` are as in `FermatLastTheoremForThreeGen`.\nSee `Solution` for the actual structure on which we will do the descent. -/\nstructure Solution' where\n  a : ùìû K\n  b : ùìû K\n  c : ùìû K\n  u : (ùìû K)À£\n  ha : ¬¨ Œª ‚à£ a\n  hb : ¬¨ Œª ‚à£ b\n  hc : c ‚â† 0\n  coprime : IsCoprime a b\n  hcdvd : Œª ‚à£ c\n  H : a ^ 3 + b ^ 3 = u * c ^ 3\n"}
{"name":"FermatLastTheoremForThreeGen.Solution'.mk.sizeOf_spec","module":"Mathlib.NumberTheory.FLT.Three","initialProofState":"K : Type u_1\ninst‚úù¬π : Field K\nŒ∂ : K\nhŒ∂ : IsPrimitiveRoot Œ∂ ‚Üë3\ninst‚úù : SizeOf K\na b c : NumberField.RingOfIntegers K\nu : Units (NumberField.RingOfIntegers K)\nha : Not (Dvd.dvd (HSub.hSub hŒ∂.toInteger 1) a)\nhb : Not (Dvd.dvd (HSub.hSub hŒ∂.toInteger 1) b)\nhc : Ne c 0\ncoprime : IsCoprime a b\nhcdvd : Dvd.dvd (HSub.hSub hŒ∂.toInteger 1) c\nH : Eq (HAdd.hAdd (HPow.hPow a 3) (HPow.hPow b 3)) (HMul.hMul (‚Üëu) (HPow.hPow c 3))\n‚ä¢ Eq (SizeOf.sizeOf { a := a, b := b, c := c, u := u, ha := ha, hb := hb, hc := hc, coprime := coprime, hcdvd := hcdvd, H := H }) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf a)) (SizeOf.sizeOf b)) (SizeOf.sizeOf c)) (SizeOf.sizeOf u)) (SizeOf.sizeOf coprime)) (SizeOf.sizeOf hcdvd)) (SizeOf.sizeOf H))","decl":"/-- `Solution'` is a tuple given by a solution to `a ^ 3 + b ^ 3 = u * c ^ 3`,\nwhere `a`, `b`, `c` and `u` are as in `FermatLastTheoremForThreeGen`.\nSee `Solution` for the actual structure on which we will do the descent. -/\nstructure Solution' where\n  a : ùìû K\n  b : ùìû K\n  c : ùìû K\n  u : (ùìû K)À£\n  ha : ¬¨ Œª ‚à£ a\n  hb : ¬¨ Œª ‚à£ b\n  hc : c ‚â† 0\n  coprime : IsCoprime a b\n  hcdvd : Œª ‚à£ c\n  H : a ^ 3 + b ^ 3 = u * c ^ 3\n"}
{"name":"FermatLastTheoremForThreeGen.Solution'.mk.injEq","module":"Mathlib.NumberTheory.FLT.Three","initialProofState":"K : Type u_1\ninst‚úù : Field K\nŒ∂ : K\nhŒ∂ : IsPrimitiveRoot Œ∂ ‚Üë3\na‚úù b‚úù c‚úù : NumberField.RingOfIntegers K\nu‚úù : Units (NumberField.RingOfIntegers K)\nha‚úù : Not (Dvd.dvd (HSub.hSub hŒ∂.toInteger 1) a‚úù)\nhb‚úù : Not (Dvd.dvd (HSub.hSub hŒ∂.toInteger 1) b‚úù)\nhc‚úù : Ne c‚úù 0\ncoprime‚úù : IsCoprime a‚úù b‚úù\nhcdvd‚úù : Dvd.dvd (HSub.hSub hŒ∂.toInteger 1) c‚úù\nH‚úù : Eq (HAdd.hAdd (HPow.hPow a‚úù 3) (HPow.hPow b‚úù 3)) (HMul.hMul (‚Üëu‚úù) (HPow.hPow c‚úù 3))\na b c : NumberField.RingOfIntegers K\nu : Units (NumberField.RingOfIntegers K)\nha : Not (Dvd.dvd (HSub.hSub hŒ∂.toInteger 1) a)\nhb : Not (Dvd.dvd (HSub.hSub hŒ∂.toInteger 1) b)\nhc : Ne c 0\ncoprime : IsCoprime a b\nhcdvd : Dvd.dvd (HSub.hSub hŒ∂.toInteger 1) c\nH : Eq (HAdd.hAdd (HPow.hPow a 3) (HPow.hPow b 3)) (HMul.hMul (‚Üëu) (HPow.hPow c 3))\n‚ä¢ Eq (Eq { a := a‚úù, b := b‚úù, c := c‚úù, u := u‚úù, ha := ha‚úù, hb := hb‚úù, hc := hc‚úù, coprime := coprime‚úù, hcdvd := hcdvd‚úù, H := H‚úù } { a := a, b := b, c := c, u := u, ha := ha, hb := hb, hc := hc, coprime := coprime, hcdvd := hcdvd, H := H }) (And (Eq a‚úù a) (And (Eq b‚úù b) (And (Eq c‚úù c) (Eq u‚úù u))))","decl":"/-- `Solution'` is a tuple given by a solution to `a ^ 3 + b ^ 3 = u * c ^ 3`,\nwhere `a`, `b`, `c` and `u` are as in `FermatLastTheoremForThreeGen`.\nSee `Solution` for the actual structure on which we will do the descent. -/\nstructure Solution' where\n  a : ùìû K\n  b : ùìû K\n  c : ùìû K\n  u : (ùìû K)À£\n  ha : ¬¨ Œª ‚à£ a\n  hb : ¬¨ Œª ‚à£ b\n  hc : c ‚â† 0\n  coprime : IsCoprime a b\n  hcdvd : Œª ‚à£ c\n  H : a ^ 3 + b ^ 3 = u * c ^ 3\n"}
{"name":"FermatLastTheoremForThreeGen.Solution'.hcdvd","module":"Mathlib.NumberTheory.FLT.Three","initialProofState":"K : Type u_1\ninst‚úù : Field K\nŒ∂ : K\nhŒ∂ : IsPrimitiveRoot Œ∂ ‚Üë3\nself : FermatLastTheoremForThreeGen.Solution' hŒ∂\n‚ä¢ Dvd.dvd (HSub.hSub hŒ∂.toInteger 1) self.c","decl":"/-- `Solution'` is a tuple given by a solution to `a ^ 3 + b ^ 3 = u * c ^ 3`,\nwhere `a`, `b`, `c` and `u` are as in `FermatLastTheoremForThreeGen`.\nSee `Solution` for the actual structure on which we will do the descent. -/\nstructure Solution' where\n  a : ùìû K\n  b : ùìû K\n  c : ùìû K\n  u : (ùìû K)À£\n  ha : ¬¨ Œª ‚à£ a\n  hb : ¬¨ Œª ‚à£ b\n  hc : c ‚â† 0\n  coprime : IsCoprime a b\n  hcdvd : Œª ‚à£ c\n  H : a ^ 3 + b ^ 3 = u * c ^ 3\n"}
{"name":"FermatLastTheoremForThreeGen.Solution.mk.inj","module":"Mathlib.NumberTheory.FLT.Three","initialProofState":"K : Type u_1\ninst‚úù : Field K\nŒ∂ : K\nhŒ∂ : IsPrimitiveRoot Œ∂ ‚Üë3\ntoSolution'‚úù : FermatLastTheoremForThreeGen.Solution' hŒ∂\nhab‚úù : Dvd.dvd (HPow.hPow (HSub.hSub hŒ∂.toInteger 1) 2) (HAdd.hAdd toSolution'‚úù.a toSolution'‚úù.b)\ntoSolution' : FermatLastTheoremForThreeGen.Solution' hŒ∂\nhab : Dvd.dvd (HPow.hPow (HSub.hSub hŒ∂.toInteger 1) 2) (HAdd.hAdd toSolution'.a toSolution'.b)\nx‚úù : Eq { toSolution' := toSolution'‚úù, hab := hab‚úù } { toSolution' := toSolution', hab := hab }\n‚ä¢ Eq toSolution'‚úù toSolution'","decl":"/-- `Solution` is the same as `Solution'` with the additional assumption that `Œª ^ 2 ‚à£ a + b`. -/\nstructure Solution extends Solution' hŒ∂ where\n  hab : Œª ^ 2 ‚à£ a + b\n\n"}
{"name":"FermatLastTheoremForThreeGen.Solution.hab","module":"Mathlib.NumberTheory.FLT.Three","initialProofState":"K : Type u_1\ninst‚úù : Field K\nŒ∂ : K\nhŒ∂ : IsPrimitiveRoot Œ∂ ‚Üë3\nself : FermatLastTheoremForThreeGen.Solution hŒ∂\n‚ä¢ Dvd.dvd (HPow.hPow (HSub.hSub hŒ∂.toInteger 1) 2) (HAdd.hAdd self.a self.b)","decl":"/-- `Solution` is the same as `Solution'` with the additional assumption that `Œª ^ 2 ‚à£ a + b`. -/\nstructure Solution extends Solution' hŒ∂ where\n  hab : Œª ^ 2 ‚à£ a + b\n\n"}
{"name":"FermatLastTheoremForThreeGen.Solution.mk.injEq","module":"Mathlib.NumberTheory.FLT.Three","initialProofState":"K : Type u_1\ninst‚úù : Field K\nŒ∂ : K\nhŒ∂ : IsPrimitiveRoot Œ∂ ‚Üë3\ntoSolution'‚úù : FermatLastTheoremForThreeGen.Solution' hŒ∂\nhab‚úù : Dvd.dvd (HPow.hPow (HSub.hSub hŒ∂.toInteger 1) 2) (HAdd.hAdd toSolution'‚úù.a toSolution'‚úù.b)\ntoSolution' : FermatLastTheoremForThreeGen.Solution' hŒ∂\nhab : Dvd.dvd (HPow.hPow (HSub.hSub hŒ∂.toInteger 1) 2) (HAdd.hAdd toSolution'.a toSolution'.b)\n‚ä¢ Eq (Eq { toSolution' := toSolution'‚úù, hab := hab‚úù } { toSolution' := toSolution', hab := hab }) (Eq toSolution'‚úù toSolution')","decl":"/-- `Solution` is the same as `Solution'` with the additional assumption that `Œª ^ 2 ‚à£ a + b`. -/\nstructure Solution extends Solution' hŒ∂ where\n  hab : Œª ^ 2 ‚à£ a + b\n\n"}
{"name":"FermatLastTheoremForThreeGen.Solution.mk.sizeOf_spec","module":"Mathlib.NumberTheory.FLT.Three","initialProofState":"K : Type u_1\ninst‚úù¬π : Field K\nŒ∂ : K\nhŒ∂ : IsPrimitiveRoot Œ∂ ‚Üë3\ninst‚úù : SizeOf K\ntoSolution' : FermatLastTheoremForThreeGen.Solution' hŒ∂\nhab : Dvd.dvd (HPow.hPow (HSub.hSub hŒ∂.toInteger 1) 2) (HAdd.hAdd toSolution'.a toSolution'.b)\n‚ä¢ Eq (SizeOf.sizeOf { toSolution' := toSolution', hab := hab }) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf toSolution')) (SizeOf.sizeOf hab))","decl":"/-- `Solution` is the same as `Solution'` with the additional assumption that `Œª ^ 2 ‚à£ a + b`. -/\nstructure Solution extends Solution' hŒ∂ where\n  hab : Œª ^ 2 ‚à£ a + b\n\n"}
{"name":"FermatLastTheoremForThreeGen.Solution'.multiplicity_lambda_c_finite","module":"Mathlib.NumberTheory.FLT.Three","initialProofState":"K : Type u_1\ninst‚úù¬≤ : Field K\nŒ∂ : K\nhŒ∂ : IsPrimitiveRoot Œ∂ ‚Üë3\nS' : FermatLastTheoremForThreeGen.Solution' hŒ∂\ninst‚úù¬π : NumberField K\ninst‚úù : IsCyclotomicExtension (Singleton.singleton 3) Rat K\n‚ä¢ FiniteMultiplicity (HSub.hSub hŒ∂.toInteger 1) S'.c","decl":"/-- For any `S' : Solution'`, the multiplicity of `Œª` in `S'.c` is finite. -/\nlemma Solution'.multiplicity_lambda_c_finite :\n    FiniteMultiplicity (hŒ∂.toInteger - 1) S'.c :=\n  .of_not_isUnit hŒ∂.zeta_sub_one_prime'.not_unit S'.hc\n\n"}
{"name":"FermatLastTheoremForThreeGen.Solution.exists_minimal","module":"Mathlib.NumberTheory.FLT.Three","initialProofState":"K : Type u_1\ninst‚úù : Field K\nŒ∂ : K\nhŒ∂ : IsPrimitiveRoot Œ∂ ‚Üë3\nS : FermatLastTheoremForThreeGen.Solution hŒ∂\n‚ä¢ Exists fun S‚ÇÅ => S‚ÇÅ.isMinimal","decl":"omit [NumberField K] [IsCyclotomicExtension {3} ‚Ñö K] in\ninclude S in\n/-- If there is a solution then there is a minimal one. -/\nlemma Solution.exists_minimal : ‚àÉ (S‚ÇÅ : Solution hŒ∂), S‚ÇÅ.isMinimal := by\n  classical\n  let T := {n | ‚àÉ (S' : Solution hŒ∂), S'.multiplicity = n}\n  rcases Nat.find_spec (‚ü®S.multiplicity, ‚ü®S, rfl‚ü©‚ü© : T.Nonempty) with ‚ü®S‚ÇÅ, hS‚ÇÅ‚ü©\n  exact ‚ü®S‚ÇÅ, fun S'' ‚Ü¶ hS‚ÇÅ ‚ñ∏ Nat.find_min' _ ‚ü®S'', rfl‚ü©‚ü©\n\n"}
{"name":"FermatLastTheoremForThreeGen.a_cube_b_cube_congr_one_or_neg_one","module":"Mathlib.NumberTheory.FLT.Three","initialProofState":"K : Type u_1\ninst‚úù¬≤ : Field K\nŒ∂ : K\nhŒ∂ : IsPrimitiveRoot Œ∂ ‚Üë3\nS' : FermatLastTheoremForThreeGen.Solution' hŒ∂\ninst‚úù¬π : NumberField K\ninst‚úù : IsCyclotomicExtension (Singleton.singleton 3) Rat K\n‚ä¢ Or (And (Dvd.dvd (HPow.hPow (HSub.hSub hŒ∂.toInteger 1) 4) (HSub.hSub (HPow.hPow S'.a 3) 1)) (Dvd.dvd (HPow.hPow (HSub.hSub hŒ∂.toInteger 1) 4) (HAdd.hAdd (HPow.hPow S'.b 3) 1))) (And (Dvd.dvd (HPow.hPow (HSub.hSub hŒ∂.toInteger 1) 4) (HAdd.hAdd (HPow.hPow S'.a 3) 1)) (Dvd.dvd (HPow.hPow (HSub.hSub hŒ∂.toInteger 1) 4) (HSub.hSub (HPow.hPow S'.b 3) 1)))","decl":"/-- Given `S' : Solution'`, then `S'.a` and `S'.b` are both congruent to `1` modulo `Œª ^ 4` or are\nboth congruent to `-1`. -/\nlemma a_cube_b_cube_congr_one_or_neg_one :\n    Œª ^ 4 ‚à£ S'.a ^ 3 - 1 ‚àß Œª ^ 4 ‚à£ S'.b ^ 3 + 1 ‚à® Œª ^ 4 ‚à£ S'.a ^ 3 + 1 ‚àß Œª ^ 4 ‚à£ S'.b ^ 3 - 1 := by\n  obtain ‚ü®z, hz‚ü© := S'.hcdvd\n  rcases lambda_pow_four_dvd_cube_sub_one_or_add_one_of_lambda_not_dvd hŒ∂ S'.ha with\n    ‚ü®x, hx‚ü© | ‚ü®x, hx‚ü© <;>\n  rcases lambda_pow_four_dvd_cube_sub_one_or_add_one_of_lambda_not_dvd hŒ∂ S'.hb with\n    ‚ü®y, hy‚ü© | ‚ü®y, hy‚ü©\n  ¬∑ exfalso\n    replace hŒ∂ : IsPrimitiveRoot Œ∂ ((3 : ‚Ñï+) ^ 1) := by rwa [pow_one]\n    refine hŒ∂.toInteger_sub_one_not_dvd_two (by decide) ‚ü®S'.u * Œª ^ 2 * z ^ 3 - Œª ^ 3 * (x + y), ?_‚ü©\n    symm\n    calc _ = S'.u * (Œª * z) ^ 3 - Œª ^ 4 * x - Œª ^ 4 * y := by ring\n    _ = (S'.a ^ 3 + S'.b ^ 3) - (S'.a ^ 3 - 1) - (S'.b ^ 3 - 1) := by rw [‚Üê hx, ‚Üê hy, ‚Üê hz, ‚Üê S'.H]\n    _ = 2 := by ring\n  ¬∑ left\n    exact ‚ü®‚ü®x, hx‚ü©, ‚ü®y, hy‚ü©‚ü©\n  ¬∑ right\n    exact ‚ü®‚ü®x, hx‚ü©, ‚ü®y, hy‚ü©‚ü©\n  ¬∑ exfalso\n    replace hŒ∂ : IsPrimitiveRoot Œ∂ ((3 : ‚Ñï+) ^ 1) := by rwa [pow_one]\n    refine hŒ∂.toInteger_sub_one_not_dvd_two (by decide) ‚ü®Œª ^ 3 * (x + y) - S'.u * Œª ^ 2 * z ^ 3, ?_‚ü©\n    symm\n    calc _ =  Œª ^ 4 * x + Œª ^ 4 * y - S'.u * (Œª * z) ^ 3 := by ring\n    _ = (S'.a ^ 3 + 1) + (S'.b ^ 3 + 1) - (S'.a ^ 3 + S'.b ^ 3) := by rw [‚Üê hx, ‚Üê hy, ‚Üê hz, ‚Üê S'.H]\n    _ = 2 := by ring\n\n"}
{"name":"FermatLastTheoremForThreeGen.lambda_pow_four_dvd_c_cube","module":"Mathlib.NumberTheory.FLT.Three","initialProofState":"K : Type u_1\ninst‚úù¬≤ : Field K\nŒ∂ : K\nhŒ∂ : IsPrimitiveRoot Œ∂ ‚Üë3\nS' : FermatLastTheoremForThreeGen.Solution' hŒ∂\ninst‚úù¬π : NumberField K\ninst‚úù : IsCyclotomicExtension (Singleton.singleton 3) Rat K\n‚ä¢ Dvd.dvd (HPow.hPow (HSub.hSub hŒ∂.toInteger 1) 4) (HPow.hPow S'.c 3)","decl":"/-- Given `S' : Solution'`, we have that `Œª ^ 4` divides `S'.c ^ 3`. -/\nlemma lambda_pow_four_dvd_c_cube : Œª ^ 4 ‚à£ S'.c ^ 3 := by\n  rcases a_cube_b_cube_congr_one_or_neg_one S' with\n    ‚ü®‚ü®x, hx‚ü©, ‚ü®y, hy‚ü©‚ü© | ‚ü®‚ü®x, hx‚ü©, ‚ü®y, hy‚ü©‚ü© <;>\n  ¬∑ refine ‚ü®S'.u‚Åª¬π * (x + y), ?_‚ü©\n    symm\n    calc _ = S'.u‚Åª¬π * (Œª ^ 4 * x + Œª ^ 4 * y) := by ring\n    _ = S'.u‚Åª¬π * (S'.a ^ 3 + S'.b ^ 3) := by rw [‚Üê hx, ‚Üê hy]; ring\n    _ = S'.u‚Åª¬π * (S'.u * S'.c ^ 3) := by rw [S'.H]\n    _ = S'.c ^ 3 := by simp\n\n"}
{"name":"FermatLastTheoremForThreeGen.lambda_sq_dvd_c","module":"Mathlib.NumberTheory.FLT.Three","initialProofState":"K : Type u_1\ninst‚úù¬≤ : Field K\nŒ∂ : K\nhŒ∂ : IsPrimitiveRoot Œ∂ ‚Üë3\nS' : FermatLastTheoremForThreeGen.Solution' hŒ∂\ninst‚úù¬π : NumberField K\ninst‚úù : IsCyclotomicExtension (Singleton.singleton 3) Rat K\n‚ä¢ Dvd.dvd (HPow.hPow (HSub.hSub hŒ∂.toInteger 1) 2) S'.c","decl":"/-- Given `S' : Solution'`, we have that `Œª ^ 2` divides `S'.c`. -/\nlemma lambda_sq_dvd_c : Œª ^ 2 ‚à£ S'.c := by\n  have hm := S'.multiplicity_lambda_c_finite\n  suffices 2 ‚â§ multiplicity (hŒ∂.toInteger - 1) S'.c by\n    obtain ‚ü®x, hx‚ü© := pow_multiplicity_dvd (hŒ∂.toInteger - 1) S'.c\n    refine ‚ü®Œª ^ (multiplicity (hŒ∂.toInteger - 1) S'.c - 2) * x, ?_‚ü©\n    rw [‚Üê mul_assoc, ‚Üê pow_add]\n    convert hx using 3\n    simp [this]\n  have := lambda_pow_four_dvd_c_cube S'\n  rw [pow_dvd_iff_le_emultiplicity, emultiplicity_pow hŒ∂.zeta_sub_one_prime',\n    hm.emultiplicity_eq_multiplicity] at this\n  norm_cast at this\n  omega\n\n"}
{"name":"FermatLastTheoremForThreeGen.Solution'.two_le_multiplicity","module":"Mathlib.NumberTheory.FLT.Three","initialProofState":"K : Type u_1\ninst‚úù¬≤ : Field K\nŒ∂ : K\nhŒ∂ : IsPrimitiveRoot Œ∂ ‚Üë3\nS' : FermatLastTheoremForThreeGen.Solution' hŒ∂\ninst‚úù¬π : NumberField K\ninst‚úù : IsCyclotomicExtension (Singleton.singleton 3) Rat K\n‚ä¢ LE.le 2 S'.multiplicity","decl":"/-- Given `S' : Solution'`, we have that `2 ‚â§ S'.multiplicity`. -/\nlemma Solution'.two_le_multiplicity : 2 ‚â§ S'.multiplicity := by\n  simpa [Solution'.multiplicity] using\n    S'.multiplicity_lambda_c_finite.le_multiplicity_of_pow_dvd (lambda_sq_dvd_c S')\n\n"}
{"name":"FermatLastTheoremForThreeGen.Solution.two_le_multiplicity","module":"Mathlib.NumberTheory.FLT.Three","initialProofState":"K : Type u_1\ninst‚úù¬≤ : Field K\nŒ∂ : K\nhŒ∂ : IsPrimitiveRoot Œ∂ ‚Üë3\nS : FermatLastTheoremForThreeGen.Solution hŒ∂\ninst‚úù¬π : NumberField K\ninst‚úù : IsCyclotomicExtension (Singleton.singleton 3) Rat K\n‚ä¢ LE.le 2 S.multiplicity","decl":"/-- Given `S : Solution`, we have that `2 ‚â§ S.multiplicity`. -/\nlemma Solution.two_le_multiplicity : 2 ‚â§ S.multiplicity :=\n  S.toSolution'.two_le_multiplicity\n\n"}
{"name":"FermatLastTheoremForThreeGen.a_cube_add_b_cube_eq_mul","module":"Mathlib.NumberTheory.FLT.Three","initialProofState":"K : Type u_1\ninst‚úù : Field K\nŒ∂ : K\nhŒ∂ : IsPrimitiveRoot Œ∂ ‚Üë3\nS' : FermatLastTheoremForThreeGen.Solution' hŒ∂\n‚ä¢ Eq (HAdd.hAdd (HPow.hPow S'.a 3) (HPow.hPow S'.b 3)) (HMul.hMul (HMul.hMul (HAdd.hAdd S'.a S'.b) (HAdd.hAdd S'.a (HMul.hMul (‚Üë‚ãØ.unit) S'.b))) (HAdd.hAdd S'.a (HMul.hMul (HPow.hPow (‚Üë‚ãØ.unit) 2) S'.b)))","decl":"/-- Given `S' : Solution'`, the key factorization of `S'.a ^ 3 + S'.b ^ 3`. -/\nlemma a_cube_add_b_cube_eq_mul :\n    S'.a ^ 3 + S'.b ^ 3 = (S'.a + S'.b) * (S'.a + Œ∑ * S'.b) * (S'.a + Œ∑ ^ 2 * S'.b) := by\n  symm\n  calc _ = S'.a^3+S'.a^2*S'.b*(Œ∑^2+Œ∑+1)+S'.a*S'.b^2*(Œ∑^2+Œ∑+Œ∑^3)+Œ∑^3*S'.b^3 := by ring\n  _ = S'.a^3+S'.a^2*S'.b*(Œ∑^2+Œ∑+1)+S'.a*S'.b^2*(Œ∑^2+Œ∑+1)+S'.b^3 := by\n    simp [hŒ∂.toInteger_cube_eq_one]\n  _ = S'.a ^ 3 + S'.b ^ 3 := by rw [eta_sq]; ring\n\n"}
{"name":"FermatLastTheoremForThreeGen.lambda_sq_dvd_or_dvd_or_dvd","module":"Mathlib.NumberTheory.FLT.Three","initialProofState":"K : Type u_1\ninst‚úù¬≥ : Field K\nŒ∂ : K\nhŒ∂ : IsPrimitiveRoot Œ∂ ‚Üë3\nS' : FermatLastTheoremForThreeGen.Solution' hŒ∂\ninst‚úù¬≤ : NumberField K\ninst‚úù¬π : IsCyclotomicExtension (Singleton.singleton 3) Rat K\ninst‚úù : DecidableRel fun a b => Dvd.dvd a b\n‚ä¢ Or (Dvd.dvd (HPow.hPow (HSub.hSub hŒ∂.toInteger 1) 2) (HAdd.hAdd S'.a S'.b)) (Or (Dvd.dvd (HPow.hPow (HSub.hSub hŒ∂.toInteger 1) 2) (HAdd.hAdd S'.a (HMul.hMul (‚Üë‚ãØ.unit) S'.b))) (Dvd.dvd (HPow.hPow (HSub.hSub hŒ∂.toInteger 1) 2) (HAdd.hAdd S'.a (HMul.hMul (HPow.hPow (‚Üë‚ãØ.unit) 2) S'.b))))","decl":"/-- Given `S' : Solution'`, we have that `Œª ^ 2` divides one amongst `S'.a + S'.b`,\n`S'.a + Œ∑ * S'.b` and `S'.a + Œ∑ ^ 2 * S'.b`. -/\nlemma lambda_sq_dvd_or_dvd_or_dvd :\n    Œª ^ 2 ‚à£ S'.a + S'.b ‚à® Œª ^ 2 ‚à£ S'.a + Œ∑ * S'.b ‚à® Œª ^ 2 ‚à£ S'.a + Œ∑ ^ 2 * S'.b := by\n  by_contra! h\n  rcases h with ‚ü®h1, h2, h3‚ü©\n  rw [‚Üê emultiplicity_lt_iff_not_dvd] at h1 h2 h3\n  have h1' : FiniteMultiplicity (hŒ∂.toInteger - 1) (S'.a + S'.b) :=\n    finiteMultiplicity_iff_emultiplicity_ne_top.2 (fun ht ‚Ü¶ by simp [ht] at h1)\n  have h2' : FiniteMultiplicity (hŒ∂.toInteger - 1) (S'.a + Œ∑ * S'.b) := by\n    refine finiteMultiplicity_iff_emultiplicity_ne_top.2 (fun ht ‚Ü¶ ?_)\n    rw [coe_eta] at ht\n    simp [ht] at h2\n  have h3' : FiniteMultiplicity (hŒ∂.toInteger - 1) (S'.a + Œ∑ ^ 2 * S'.b) := by\n    refine finiteMultiplicity_iff_emultiplicity_ne_top.2 (fun ht ‚Ü¶ ?_)\n    rw [coe_eta] at ht\n    simp [ht] at h3\n  rw [h1'.emultiplicity_eq_multiplicity, Nat.cast_lt] at h1\n  rw [h2'.emultiplicity_eq_multiplicity, Nat.cast_lt] at h2\n  rw [h3'.emultiplicity_eq_multiplicity, Nat.cast_lt] at h3\n  have := (pow_dvd_pow_of_dvd (lambda_sq_dvd_c S') 3).mul_left S'.u\n  rw [‚Üê pow_mul, ‚Üê S'.H, a_cube_add_b_cube_eq_mul, pow_dvd_iff_le_emultiplicity,\n    emultiplicity_mul hŒ∂.zeta_sub_one_prime', emultiplicity_mul hŒ∂.zeta_sub_one_prime',\n      h1'.emultiplicity_eq_multiplicity, h2'.emultiplicity_eq_multiplicity,\n      h3'.emultiplicity_eq_multiplicity, ‚Üê Nat.cast_add, ‚Üê Nat.cast_add, Nat.cast_le] at this\n  omega\n\n"}
{"name":"FermatLastTheoremForThreeGen.ex_cube_add_cube_eq_and_isCoprime_and_not_dvd_and_dvd","module":"Mathlib.NumberTheory.FLT.Three","initialProofState":"K : Type u_1\ninst‚úù¬≥ : Field K\nŒ∂ : K\nhŒ∂ : IsPrimitiveRoot Œ∂ ‚Üë3\nS' : FermatLastTheoremForThreeGen.Solution' hŒ∂\ninst‚úù¬≤ : NumberField K\ninst‚úù¬π : IsCyclotomicExtension (Singleton.singleton 3) Rat K\ninst‚úù : DecidableRel fun a b => Dvd.dvd a b\n‚ä¢ Exists fun a' => Exists fun b' => And (Eq (HAdd.hAdd (HPow.hPow a' 3) (HPow.hPow b' 3)) (HMul.hMul (‚ÜëS'.u) (HPow.hPow S'.c 3))) (And (IsCoprime a' b') (And (Not (Dvd.dvd (HSub.hSub hŒ∂.toInteger 1) a')) (And (Not (Dvd.dvd (HSub.hSub hŒ∂.toInteger 1) b')) (Dvd.dvd (HPow.hPow (HSub.hSub hŒ∂.toInteger 1) 2) (HAdd.hAdd a' b')))))","decl":"open Units in\n/-- Given `S' : Solution'`, we may assume that `Œª ^ 2` divides `S'.a + S'.b ‚à® Œª ^ 2` (see also the\nresult below). -/\nlemma ex_cube_add_cube_eq_and_isCoprime_and_not_dvd_and_dvd :\n    ‚àÉ (a' b' : ùìû K), a' ^ 3 + b' ^ 3 = S'.u * S'.c ^ 3 ‚àß IsCoprime a' b' ‚àß ¬¨ Œª ‚à£ a' ‚àß\n      ¬¨ Œª ‚à£ b' ‚àß Œª ^ 2 ‚à£ a' + b' := by\n  rcases lambda_sq_dvd_or_dvd_or_dvd S' with h | h | h\n  ¬∑ exact ‚ü®S'.a, S'.b, S'.H, S'.coprime, S'.ha, S'.hb, h‚ü©\n  ¬∑ refine ‚ü®S'.a, Œ∑ * S'.b, ?_, ?_, S'.ha, fun ‚ü®x, hx‚ü© ‚Ü¶ S'.hb ‚ü®Œ∑ ^ 2 * x, ?_‚ü©, h‚ü©\n    ¬∑ simp [mul_pow, ‚Üê val_pow_eq_pow_val, hŒ∂.toInteger_cube_eq_one, val_one, one_mul, S'.H]\n    ¬∑ refine (isCoprime_mul_unit_left_right (Units.isUnit Œ∑) _ _).2 S'.coprime\n    ¬∑ rw [mul_comm _ x, ‚Üê mul_assoc, ‚Üê hx, mul_comm _ S'.b, mul_assoc, ‚Üê pow_succ', coe_eta,\n        hŒ∂.toInteger_cube_eq_one, mul_one]\n  ¬∑ refine ‚ü®S'.a, Œ∑ ^ 2 * S'.b, ?_, ?_, S'.ha, fun ‚ü®x, hx‚ü© ‚Ü¶ S'.hb ‚ü®Œ∑ * x, ?_‚ü©, h‚ü©\n    ¬∑ rw [mul_pow, ‚Üê pow_mul, mul_comm 2, pow_mul, coe_eta, hŒ∂.toInteger_cube_eq_one, one_pow,\n        one_mul, S'.H]\n    ¬∑ exact (isCoprime_mul_unit_left_right ((Units.isUnit Œ∑).pow _) _ _).2 S'.coprime\n    ¬∑ rw [mul_comm _ x, ‚Üê mul_assoc, ‚Üê hx, mul_comm _ S'.b, mul_assoc, ‚Üê pow_succ, coe_eta,\n        hŒ∂.toInteger_cube_eq_one, mul_one]\n\n"}
{"name":"FermatLastTheoremForThreeGen.exists_Solution_of_Solution'","module":"Mathlib.NumberTheory.FLT.Three","initialProofState":"K : Type u_1\ninst‚úù¬≥ : Field K\nŒ∂ : K\nhŒ∂ : IsPrimitiveRoot Œ∂ ‚Üë3\nS' : FermatLastTheoremForThreeGen.Solution' hŒ∂\ninst‚úù¬≤ : NumberField K\ninst‚úù¬π : IsCyclotomicExtension (Singleton.singleton 3) Rat K\ninst‚úù : DecidableRel fun a b => Dvd.dvd a b\n‚ä¢ Exists fun S‚ÇÅ => Eq S‚ÇÅ.multiplicity S'.multiplicity","decl":"/-- Given `S' : Solution'`, then there is `S‚ÇÅ : Solution` such that\n`S‚ÇÅ.multiplicity = S'.multiplicity`. -/\nlemma exists_Solution_of_Solution' : ‚àÉ (S‚ÇÅ : Solution hŒ∂), S‚ÇÅ.multiplicity = S'.multiplicity := by\n  obtain ‚ü®a, b, H, coprime, ha, hb, hab‚ü© := ex_cube_add_cube_eq_and_isCoprime_and_not_dvd_and_dvd S'\n  exact ‚ü®\n  { a := a\n    b := b\n    c := S'.c\n    u := S'.u\n    ha := ha\n    hb := hb\n    hc := S'.hc\n    coprime := coprime\n    hcdvd := S'.hcdvd\n    H := H\n    hab := hab }, rfl‚ü©\n\n"}
{"name":"FermatLastTheoremForThreeGen.Solution.a_add_eta_mul_b","module":"Mathlib.NumberTheory.FLT.Three","initialProofState":"K : Type u_1\ninst‚úù : Field K\nŒ∂ : K\nhŒ∂ : IsPrimitiveRoot Œ∂ ‚Üë3\nS : FermatLastTheoremForThreeGen.Solution hŒ∂\n‚ä¢ Eq (HAdd.hAdd S.a (HMul.hMul (‚Üë‚ãØ.unit) S.b)) (HAdd.hAdd (HAdd.hAdd S.a S.b) (HMul.hMul (HSub.hSub hŒ∂.toInteger 1) S.b))","decl":"lemma a_add_eta_mul_b : S.a + Œ∑ * S.b = (S.a + S.b) + Œª * S.b := by rw [coe_eta]; ring\n\n"}
{"name":"FermatLastTheoremForThreeGen.Solution.lambda_dvd_a_add_eta_mul_b","module":"Mathlib.NumberTheory.FLT.Three","initialProofState":"K : Type u_1\ninst‚úù : Field K\nŒ∂ : K\nhŒ∂ : IsPrimitiveRoot Œ∂ ‚Üë3\nS : FermatLastTheoremForThreeGen.Solution hŒ∂\n‚ä¢ Dvd.dvd (HSub.hSub hŒ∂.toInteger 1) (HAdd.hAdd S.a (HMul.hMul (‚Üë‚ãØ.unit) S.b))","decl":"/-- Given `(S : Solution)`, we have that `Œª ‚à£ (S.a + Œ∑ * S.b)`. -/\nlemma lambda_dvd_a_add_eta_mul_b : Œª ‚à£ (S.a + Œ∑ * S.b) :=\n  a_add_eta_mul_b S ‚ñ∏ dvd_add (dvd_trans (dvd_pow_self _ (by decide)) S.hab) ‚ü®S.b, by rw [mul_comm]‚ü©\n\n"}
{"name":"FermatLastTheoremForThreeGen.Solution.lambda_dvd_a_add_eta_sq_mul_b","module":"Mathlib.NumberTheory.FLT.Three","initialProofState":"K : Type u_1\ninst‚úù : Field K\nŒ∂ : K\nhŒ∂ : IsPrimitiveRoot Œ∂ ‚Üë3\nS : FermatLastTheoremForThreeGen.Solution hŒ∂\n‚ä¢ Dvd.dvd (HSub.hSub hŒ∂.toInteger 1) (HAdd.hAdd S.a (HMul.hMul (HPow.hPow (‚Üë‚ãØ.unit) 2) S.b))","decl":"/-- Given `(S : Solution)`, we have that `Œª ‚à£ (S.a + Œ∑ ^ 2 * S.b)`. -/\nlemma lambda_dvd_a_add_eta_sq_mul_b : Œª ‚à£ (S.a + Œ∑ ^ 2 * S.b) := by\n  rw [show S.a + Œ∑ ^ 2 * S.b = (S.a + S.b) + Œª ^ 2 * S.b + 2 * Œª * S.b by rw [coe_eta]; ring]\n  exact dvd_add (dvd_add (dvd_trans (dvd_pow_self _ (by decide)) S.hab) ‚ü®Œª * S.b, by ring‚ü©)\n    ‚ü®2 * S.b, by ring‚ü©\n\n"}
{"name":"FermatLastTheoremForThreeGen.Solution.lambda_sq_not_dvd_a_add_eta_mul_b","module":"Mathlib.NumberTheory.FLT.Three","initialProofState":"K : Type u_1\ninst‚úù¬≤ : Field K\nŒ∂ : K\nhŒ∂ : IsPrimitiveRoot Œ∂ ‚Üë3\nS : FermatLastTheoremForThreeGen.Solution hŒ∂\ninst‚úù¬π : NumberField K\ninst‚úù : IsCyclotomicExtension (Singleton.singleton 3) Rat K\n‚ä¢ Not (Dvd.dvd (HPow.hPow (HSub.hSub hŒ∂.toInteger 1) 2) (HAdd.hAdd S.a (HMul.hMul (‚Üë‚ãØ.unit) S.b)))","decl":"/-- Given `(S : Solution)`, we have that `Œª ^ 2` does not divide `S.a + Œ∑ * S.b`. -/\nlemma lambda_sq_not_dvd_a_add_eta_mul_b : ¬¨ Œª ^ 2 ‚à£ (S.a + Œ∑ * S.b) := by\n  simp_rw [a_add_eta_mul_b, dvd_add_right S.hab, pow_two, mul_dvd_mul_iff_left\n    hŒ∂.zeta_sub_one_prime'.ne_zero, S.hb, not_false_eq_true]\n\n"}
{"name":"FermatLastTheoremForThreeGen.Solution.lambda_sq_not_dvd_a_add_eta_sq_mul_b","module":"Mathlib.NumberTheory.FLT.Three","initialProofState":"K : Type u_1\ninst‚úù¬≤ : Field K\nŒ∂ : K\nhŒ∂ : IsPrimitiveRoot Œ∂ ‚Üë3\nS : FermatLastTheoremForThreeGen.Solution hŒ∂\ninst‚úù¬π : NumberField K\ninst‚úù : IsCyclotomicExtension (Singleton.singleton 3) Rat K\n‚ä¢ Not (Dvd.dvd (HPow.hPow (HSub.hSub hŒ∂.toInteger 1) 2) (HAdd.hAdd S.a (HMul.hMul (HPow.hPow (‚Üë‚ãØ.unit) 2) S.b)))","decl":"/-- Given `(S : Solution)`, we have that `Œª ^ 2` does not divide `S.a + Œ∑ ^ 2 * S.b`. -/\nlemma lambda_sq_not_dvd_a_add_eta_sq_mul_b : ¬¨ Œª ^ 2 ‚à£ (S.a + Œ∑ ^ 2 * S.b) := by\n  intro ‚ü®k, hk‚ü©\n  rcases S.hab with ‚ü®k', hk'‚ü©\n  refine S.hb ‚ü®(k - k') * (-Œ∑), ?_‚ü©\n  rw [show S.a + Œ∑ ^ 2 * S.b = S.a + S.b - S.b + Œ∑ ^ 2 * S.b by ring, hk',\n    show Œª ^ 2 * k' - S.b + Œ∑ ^ 2 * S.b = Œª * (S.b * (Œ∑ +1) + Œª * k') by rw [coe_eta]; ring,\n    pow_two, mul_assoc] at hk\n  simp only [mul_eq_mul_left_iff, hŒ∂.zeta_sub_one_prime'.ne_zero, or_false] at hk\n  apply_fun (¬∑ * -‚ÜëŒ∑) at hk\n  rw [show (S.b * (Œ∑ + 1) + Œª * k') * -Œ∑ = (- S.b) * (Œ∑ ^ 2 + Œ∑ + 1 - 1) - Œ∑ * Œª * k' by ring,\n    eta_sq, show -S.b * (-‚ÜëŒ∑ - 1 + ‚ÜëŒ∑ + 1 - 1) = S.b by ring, sub_eq_iff_eq_add] at hk\n  rw [hk]\n  ring\n\n"}
{"name":"FermatLastTheoremForThreeGen.Solution.associated_of_dvd_a_add_b_of_dvd_a_add_eta_mul_b","module":"Mathlib.NumberTheory.FLT.Three","initialProofState":"K : Type u_1\ninst‚úù¬≤ : Field K\nŒ∂ : K\nhŒ∂ : IsPrimitiveRoot Œ∂ ‚Üë3\nS : FermatLastTheoremForThreeGen.Solution hŒ∂\ninst‚úù¬π : NumberField K\ninst‚úù : IsCyclotomicExtension (Singleton.singleton 3) Rat K\np : NumberField.RingOfIntegers K\nhp : Prime p\nhpab : Dvd.dvd p (HAdd.hAdd S.a S.b)\nhpaŒ∑b : Dvd.dvd p (HAdd.hAdd S.a (HMul.hMul (‚Üë‚ãØ.unit) S.b))\n‚ä¢ Associated p (HSub.hSub hŒ∂.toInteger 1)","decl":"/-- If `p : ùìû K` is a prime that divides both `S.a + S.b` and `S.a + Œ∑ * S.b`, then `p`\nis associated with `Œª`. -/\nlemma associated_of_dvd_a_add_b_of_dvd_a_add_eta_mul_b {p : ùìû K} (hp : Prime p)\n    (hpab : p ‚à£ S.a + S.b) (hpaŒ∑b : p ‚à£ S.a + Œ∑ * S.b) : Associated p Œª := by\n  suffices p_lam : p ‚à£ Œª from hp.associated_of_dvd hŒ∂.zeta_sub_one_prime' p_lam\n  rw [‚Üê one_mul S.a, ‚Üê one_mul S.b] at hpab\n  rw [‚Üê one_mul S.a] at hpaŒ∑b\n  have := dvd_mul_sub_mul_mul_gcd_of_dvd hpab hpaŒ∑b\n  rwa [one_mul, one_mul, coe_eta, IsUnit.dvd_mul_right <| (gcd_isUnit_iff _ _).2 S.coprime] at this\n\n"}
{"name":"FermatLastTheoremForThreeGen.Solution.associated_of_dvd_a_add_b_of_dvd_a_add_eta_sq_mul_b","module":"Mathlib.NumberTheory.FLT.Three","initialProofState":"K : Type u_1\ninst‚úù¬≤ : Field K\nŒ∂ : K\nhŒ∂ : IsPrimitiveRoot Œ∂ ‚Üë3\nS : FermatLastTheoremForThreeGen.Solution hŒ∂\ninst‚úù¬π : NumberField K\ninst‚úù : IsCyclotomicExtension (Singleton.singleton 3) Rat K\np : NumberField.RingOfIntegers K\nhp : Prime p\nhpab : Dvd.dvd p (HAdd.hAdd S.a S.b)\nhpaŒ∑sqb : Dvd.dvd p (HAdd.hAdd S.a (HMul.hMul (HPow.hPow (‚Üë‚ãØ.unit) 2) S.b))\n‚ä¢ Associated p (HSub.hSub hŒ∂.toInteger 1)","decl":"/-- If `p : ùìû K` is a prime that divides both `S.a + S.b` and `S.a + Œ∑ ^ 2 * S.b`, then `p`\nis associated with `Œª`. -/\nlemma associated_of_dvd_a_add_b_of_dvd_a_add_eta_sq_mul_b {p : ùìû K} (hp : Prime p)\n    (hpab : p ‚à£ (S.a + S.b)) (hpaŒ∑sqb : p ‚à£ (S.a + Œ∑ ^ 2 * S.b)) : Associated p Œª := by\n  suffices p_lam : p ‚à£ Œª from hp.associated_of_dvd hŒ∂.zeta_sub_one_prime' p_lam\n  rw [‚Üê one_mul S.a, ‚Üê one_mul S.b] at hpab\n  rw [‚Üê one_mul S.a] at hpaŒ∑sqb\n  have := dvd_mul_sub_mul_mul_gcd_of_dvd hpab hpaŒ∑sqb\n  rw [one_mul, mul_one, IsUnit.dvd_mul_right <| (gcd_isUnit_iff _ _).2 S.coprime, ‚Üê dvd_neg] at this\n  convert dvd_mul_of_dvd_left this Œ∑ using 1\n  rw [eta_sq, neg_sub, sub_mul, sub_mul, neg_mul, ‚Üê pow_two, eta_sq, coe_eta]\n  ring\n\n"}
{"name":"FermatLastTheoremForThreeGen.Solution.associated_of_dvd_a_add_eta_mul_b_of_dvd_a_add_eta_sq_mul_b","module":"Mathlib.NumberTheory.FLT.Three","initialProofState":"K : Type u_1\ninst‚úù¬≤ : Field K\nŒ∂ : K\nhŒ∂ : IsPrimitiveRoot Œ∂ ‚Üë3\nS : FermatLastTheoremForThreeGen.Solution hŒ∂\ninst‚úù¬π : NumberField K\ninst‚úù : IsCyclotomicExtension (Singleton.singleton 3) Rat K\np : NumberField.RingOfIntegers K\nhp : Prime p\nhpaŒ∑b : Dvd.dvd p (HAdd.hAdd S.a (HMul.hMul (‚Üë‚ãØ.unit) S.b))\nhpaŒ∑sqb : Dvd.dvd p (HAdd.hAdd S.a (HMul.hMul (HPow.hPow (‚Üë‚ãØ.unit) 2) S.b))\n‚ä¢ Associated p (HSub.hSub hŒ∂.toInteger 1)","decl":"/-- If `p : ùìû K` is a prime that divides both `S.a + Œ∑ * S.b` and `S.a + Œ∑ ^ 2 * S.b`, then `p`\nis associated with `Œª`. -/\nlemma associated_of_dvd_a_add_eta_mul_b_of_dvd_a_add_eta_sq_mul_b {p : ùìû K} (hp : Prime p)\n    (hpaŒ∑b : p ‚à£ S.a + Œ∑ * S.b) (hpaŒ∑sqb : p ‚à£ S.a + Œ∑ ^ 2 * S.b) : Associated p Œª := by\n  suffices p_lam : p ‚à£ Œª from hp.associated_of_dvd hŒ∂.zeta_sub_one_prime' p_lam\n  rw [‚Üê one_mul S.a] at hpaŒ∑b\n  rw [‚Üê one_mul S.a] at hpaŒ∑sqb\n  have := dvd_mul_sub_mul_mul_gcd_of_dvd hpaŒ∑b hpaŒ∑sqb\n  rw [one_mul, mul_one, IsUnit.dvd_mul_right <| (gcd_isUnit_iff _ _).2 S.coprime] at this\n  convert (dvd_mul_of_dvd_left (dvd_mul_of_dvd_left this Œ∑) Œ∑) using 1\n  symm\n  calc _ = (-Œ∑.1 - 1 - Œ∑) * (-Œ∑ - 1) := by rw [eta_sq, mul_assoc, ‚Üê pow_two, eta_sq]\n  _ = 2 * Œ∑.1 ^ 2 + 3 * Œ∑ + 1 := by ring\n  _ = Œª := by rw [eta_sq, coe_eta]; ring\n\n"}
{"name":"FermatLastTheoremForThreeGen.Solution.Solution'_descent_multiplicity","module":"Mathlib.NumberTheory.FLT.Three","initialProofState":"K : Type u_1\ninst‚úù¬≤ : Field K\nŒ∂ : K\nhŒ∂ : IsPrimitiveRoot Œ∂ ‚Üë3\nS : FermatLastTheoremForThreeGen.Solution hŒ∂\ninst‚úù¬π : NumberField K\ninst‚úù : IsCyclotomicExtension (Singleton.singleton 3) Rat K\n‚ä¢ Eq S.Solution'_descent.multiplicity (HSub.hSub S.multiplicity 1)","decl":"/-- We have that `S.Solution'_descent.multiplicity = S.multiplicity - 1`. -/\nlemma Solution'_descent_multiplicity : S.Solution'_descent.multiplicity = S.multiplicity - 1 := by\n  refine multiplicity_eq_of_dvd_of_not_dvd\n    (by simp [Solution'_descent]) (fun h ‚Ü¶ S.lambda_not_dvd_X ?_)\n  obtain ‚ü®k, hk : Œª^(S.multiplicity-1)*S.X=Œª^(S.multiplicity-1+1)*k‚ü© := h\n  rw [pow_succ, mul_assoc] at hk\n  simp only [mul_eq_mul_left_iff, pow_eq_zero_iff', hŒ∂.zeta_sub_one_prime'.ne_zero, ne_eq,\n    false_and, or_false] at hk\n  simp [hk]\n\n"}
{"name":"FermatLastTheoremForThreeGen.Solution.Solution'_descent_multiplicity_lt","module":"Mathlib.NumberTheory.FLT.Three","initialProofState":"K : Type u_1\ninst‚úù¬≤ : Field K\nŒ∂ : K\nhŒ∂ : IsPrimitiveRoot Œ∂ ‚Üë3\nS : FermatLastTheoremForThreeGen.Solution hŒ∂\ninst‚úù¬π : NumberField K\ninst‚úù : IsCyclotomicExtension (Singleton.singleton 3) Rat K\n‚ä¢ LT.lt S.Solution'_descent.multiplicity S.multiplicity","decl":"/-- We have that `S.Solution'_descent.multiplicity < S.multiplicity`. -/\nlemma Solution'_descent_multiplicity_lt :\n    (Solution'_descent S).multiplicity < S.multiplicity := by\n  rw [Solution'_descent_multiplicity S, Nat.sub_one]\n  exact Nat.pred_lt <| by have := S.two_le_multiplicity; omega\n\n"}
{"name":"FermatLastTheoremForThreeGen.Solution.exists_Solution_multiplicity_lt","module":"Mathlib.NumberTheory.FLT.Three","initialProofState":"K : Type u_1\ninst‚úù¬≤ : Field K\nŒ∂ : K\nhŒ∂ : IsPrimitiveRoot Œ∂ ‚Üë3\nS : FermatLastTheoremForThreeGen.Solution hŒ∂\ninst‚úù¬π : NumberField K\ninst‚úù : IsCyclotomicExtension (Singleton.singleton 3) Rat K\n‚ä¢ Exists fun S‚ÇÅ => LT.lt S‚ÇÅ.multiplicity S.multiplicity","decl":"/-- Given any `S : Solution`, there is another `S‚ÇÅ : Solution` such that\n  `S‚ÇÅ.multiplicity < S.multiplicity` -/\ntheorem exists_Solution_multiplicity_lt :\n    ‚àÉ S‚ÇÅ : Solution hŒ∂, S‚ÇÅ.multiplicity < S.multiplicity := by classical\n  obtain ‚ü®S', hS'‚ü© := exists_Solution_of_Solution' (Solution'_descent S)\n  exact ‚ü®S', hS' ‚ñ∏ Solution'_descent_multiplicity_lt S‚ü©\n\n"}
{"name":"fermatLastTheoremThree","module":"Mathlib.NumberTheory.FLT.Three","initialProofState":"‚ä¢ FermatLastTheoremFor 3","decl":"/-- Fermat's Last Theorem for `n = 3`: if `a b c : ‚Ñï` are all non-zero then\n`a ^ 3 + b ^ 3 ‚â† c ^ 3`. -/\ntheorem fermatLastTheoremThree : FermatLastTheoremFor 3 := by\n  classical\n  let K := CyclotomicField 3 ‚Ñö\n  let hŒ∂ := IsCyclotomicExtension.zeta_spec 3 ‚Ñö K\n  have : NumberField K := IsCyclotomicExtension.numberField {3} ‚Ñö _\n  apply FermatLastTheoremForThree_of_FermatLastTheoremThreeGen hŒ∂\n  intro a b c u hc ha hb hcdvd coprime H\n  let S' : FermatLastTheoremForThreeGen.Solution' hŒ∂ :=\n  { a := a\n    b := b\n    c := c\n    u := u\n    ha := ha\n    hb := hb\n    hc := hc\n    coprime := coprime\n    hcdvd := hcdvd\n    H := H }\n  obtain ‚ü®S, -‚ü© := FermatLastTheoremForThreeGen.exists_Solution_of_Solution' S'\n  obtain ‚ü®Smin, hSmin‚ü© := S.exists_minimal\n  obtain ‚ü®Sfin, hSfin‚ü© := Smin.exists_Solution_multiplicity_lt\n  linarith [hSmin Sfin]\n"}
