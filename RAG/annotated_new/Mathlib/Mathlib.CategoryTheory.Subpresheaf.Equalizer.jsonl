{"name":"CategoryTheory.Subpresheaf.equalizer_obj","module":"Mathlib.CategoryTheory.Subpresheaf.Equalizer","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF‚ÇÅ F‚ÇÇ : CategoryTheory.Functor (Opposite C) (Type w)\nA : CategoryTheory.Subpresheaf F‚ÇÅ\nf g : Quiver.Hom A.toPresheaf F‚ÇÇ\nU : Opposite C\n‚ä¢ Eq ((CategoryTheory.Subpresheaf.equalizer f g).obj U) (setOf fun x => Exists fun hx => Eq (f.app U ‚ü®x, hx‚ü©) (g.app U ‚ü®x, hx‚ü©))","decl":"/-- The equalizer of two morphisms of presheaves of types of the form\n`A.toPresheaf ‚ü∂ F‚ÇÇ` with `A : Subpresheaf F‚ÇÅ`, as a subcomplex of `F‚ÇÅ`. -/\n@[simps (config := .lemmasOnly)]\nprotected def equalizer : Subpresheaf F‚ÇÅ where\n  obj U := setOf (fun x ‚Ü¶ ‚àÉ (hx : x ‚àà A.obj _), f.app _ ‚ü®x, hx‚ü© = g.app _ ‚ü®x, hx‚ü©)\n  map œÜ x := by\n    rintro ‚ü®hx, h‚ü©\n    exact ‚ü®A.map _ hx,\n      (FunctorToTypes.naturality _ _ f œÜ ‚ü®x, hx‚ü©).trans (Eq.trans (by rw [h])\n        (FunctorToTypes.naturality _ _ g œÜ ‚ü®x, hx‚ü©).symm)‚ü©\n\n"}
{"name":"CategoryTheory.Subpresheaf.equalizer_le","module":"Mathlib.CategoryTheory.Subpresheaf.Equalizer","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF‚ÇÅ F‚ÇÇ : CategoryTheory.Functor (Opposite C) (Type w)\nA : CategoryTheory.Subpresheaf F‚ÇÅ\nf g : Quiver.Hom A.toPresheaf F‚ÇÇ\n‚ä¢ LE.le (CategoryTheory.Subpresheaf.equalizer f g) A","decl":"lemma equalizer_le : Subpresheaf.equalizer f g ‚â§ A :=\n  fun _ _ h ‚Ü¶ h.1\n\n"}
{"name":"CategoryTheory.Subpresheaf.equalizer_self","module":"Mathlib.CategoryTheory.Subpresheaf.Equalizer","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF‚ÇÅ F‚ÇÇ : CategoryTheory.Functor (Opposite C) (Type w)\nA : CategoryTheory.Subpresheaf F‚ÇÅ\nf : Quiver.Hom A.toPresheaf F‚ÇÇ\n‚ä¢ Eq (CategoryTheory.Subpresheaf.equalizer f f) A","decl":"@[simp]\nlemma equalizer_self : Subpresheaf.equalizer f f = A := by aesop\n\n"}
{"name":"CategoryTheory.Subpresheaf.mem_equalizer_iff","module":"Mathlib.CategoryTheory.Subpresheaf.Equalizer","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF‚ÇÅ F‚ÇÇ : CategoryTheory.Functor (Opposite C) (Type w)\nA : CategoryTheory.Subpresheaf F‚ÇÅ\nf g : Quiver.Hom A.toPresheaf F‚ÇÇ\ni : Opposite C\nx : A.toPresheaf.obj i\n‚ä¢ Iff (Membership.mem ((CategoryTheory.Subpresheaf.equalizer f g).obj i) ‚Üëx) (Eq (f.app i x) (g.app i x))","decl":"lemma mem_equalizer_iff {i : C·µí·µñ} (x : A.toPresheaf.obj i) :\n    x.1 ‚àà (Subpresheaf.equalizer f g).obj i ‚Üî f.app i x = g.app i x := by\n  simp\n\n"}
{"name":"CategoryTheory.Subpresheaf.range_le_equalizer_iff","module":"Mathlib.CategoryTheory.Subpresheaf.Equalizer","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF‚ÇÅ F‚ÇÇ : CategoryTheory.Functor (Opposite C) (Type w)\nA : CategoryTheory.Subpresheaf F‚ÇÅ\nf g : Quiver.Hom A.toPresheaf F‚ÇÇ\nG : CategoryTheory.Functor (Opposite C) (Type w)\nœÜ : Quiver.Hom G A.toPresheaf\n‚ä¢ Iff (LE.le (CategoryTheory.Subpresheaf.range (CategoryTheory.CategoryStruct.comp œÜ A.Œπ)) (CategoryTheory.Subpresheaf.equalizer f g)) (Eq (CategoryTheory.CategoryStruct.comp œÜ f) (CategoryTheory.CategoryStruct.comp œÜ g))","decl":"lemma range_le_equalizer_iff {G : C·µí·µñ ‚•§ Type w} (œÜ : G ‚ü∂ A.toPresheaf) :\n    range (œÜ ‚â´ A.Œπ) ‚â§ Subpresheaf.equalizer f g ‚Üî œÜ ‚â´ f = œÜ ‚â´ g := by\n  rw [NatTrans.ext_iff]\n  simp [le_def, Set.subset_def, funext_iff, CategoryTheory.types_ext_iff]\n\n"}
{"name":"CategoryTheory.Subpresheaf.equalizer_eq_iff","module":"Mathlib.CategoryTheory.Subpresheaf.Equalizer","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF‚ÇÅ F‚ÇÇ : CategoryTheory.Functor (Opposite C) (Type w)\nA : CategoryTheory.Subpresheaf F‚ÇÅ\nf g : Quiver.Hom A.toPresheaf F‚ÇÇ\n‚ä¢ Iff (Eq (CategoryTheory.Subpresheaf.equalizer f g) A) (Eq f g)","decl":"lemma equalizer_eq_iff :\n    Subpresheaf.equalizer f g = A ‚Üî f = g := by\n  have := range_le_equalizer_iff f g (ùüô _)\n  simp only [Category.id_comp, range_Œπ] at this\n  rw [‚Üê this]\n  constructor\n  ¬∑ intro h\n    rw [h]\n  ¬∑ intro h\n    exact le_antisymm (equalizer_le f g) h\n\n"}
{"name":"CategoryTheory.Subpresheaf.instMonoFunctorOppositeTypeŒπ_1","module":"Mathlib.CategoryTheory.Subpresheaf.Equalizer","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF‚ÇÅ F‚ÇÇ : CategoryTheory.Functor (Opposite C) (Type w)\nA : CategoryTheory.Subpresheaf F‚ÇÅ\nf g : Quiver.Hom A.toPresheaf F‚ÇÇ\n‚ä¢ CategoryTheory.Mono (CategoryTheory.Subpresheaf.equalizer.Œπ f g)","decl":"instance : Mono (equalizer.Œπ f g) := by\n  dsimp [equalizer.Œπ]\n  infer_instance\n\n"}
{"name":"CategoryTheory.Subpresheaf.equalizer.Œπ_Œπ_assoc","module":"Mathlib.CategoryTheory.Subpresheaf.Equalizer","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF‚ÇÅ F‚ÇÇ : CategoryTheory.Functor (Opposite C) (Type w)\nA : CategoryTheory.Subpresheaf F‚ÇÅ\nf g : Quiver.Hom A.toPresheaf F‚ÇÇ\nZ : CategoryTheory.Functor (Opposite C) (Type w)\nh : Quiver.Hom F‚ÇÅ Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Subpresheaf.equalizer.Œπ f g) (CategoryTheory.CategoryStruct.comp A.Œπ h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Subpresheaf.equalizer f g).Œπ h)","decl":"@[reassoc (attr := simp)]\nlemma equalizer.Œπ_Œπ : equalizer.Œπ f g ‚â´ A.Œπ = (Subpresheaf.equalizer f g).Œπ := rfl\n\n"}
{"name":"CategoryTheory.Subpresheaf.equalizer.Œπ_Œπ","module":"Mathlib.CategoryTheory.Subpresheaf.Equalizer","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF‚ÇÅ F‚ÇÇ : CategoryTheory.Functor (Opposite C) (Type w)\nA : CategoryTheory.Subpresheaf F‚ÇÅ\nf g : Quiver.Hom A.toPresheaf F‚ÇÇ\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Subpresheaf.equalizer.Œπ f g) A.Œπ) (CategoryTheory.Subpresheaf.equalizer f g).Œπ","decl":"@[reassoc (attr := simp)]\nlemma equalizer.Œπ_Œπ : equalizer.Œπ f g ‚â´ A.Œπ = (Subpresheaf.equalizer f g).Œπ := rfl\n\n"}
{"name":"CategoryTheory.Subpresheaf.equalizer.condition_assoc","module":"Mathlib.CategoryTheory.Subpresheaf.Equalizer","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF‚ÇÅ F‚ÇÇ : CategoryTheory.Functor (Opposite C) (Type w)\nA : CategoryTheory.Subpresheaf F‚ÇÅ\nf g : Quiver.Hom A.toPresheaf F‚ÇÇ\nZ : CategoryTheory.Functor (Opposite C) (Type w)\nh : Quiver.Hom F‚ÇÇ Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Subpresheaf.equalizer.Œπ f g) (CategoryTheory.CategoryStruct.comp f h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Subpresheaf.equalizer.Œπ f g) (CategoryTheory.CategoryStruct.comp g h))","decl":"@[reassoc]\nlemma equalizer.condition : equalizer.Œπ f g ‚â´ f = equalizer.Œπ f g ‚â´ g := by\n  simp [‚Üê range_le_equalizer_iff]\n\n"}
{"name":"CategoryTheory.Subpresheaf.equalizer.condition","module":"Mathlib.CategoryTheory.Subpresheaf.Equalizer","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF‚ÇÅ F‚ÇÇ : CategoryTheory.Functor (Opposite C) (Type w)\nA : CategoryTheory.Subpresheaf F‚ÇÅ\nf g : Quiver.Hom A.toPresheaf F‚ÇÇ\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Subpresheaf.equalizer.Œπ f g) f) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Subpresheaf.equalizer.Œπ f g) g)","decl":"@[reassoc]\nlemma equalizer.condition : equalizer.Œπ f g ‚â´ f = equalizer.Œπ f g ‚â´ g := by\n  simp [‚Üê range_le_equalizer_iff]\n\n"}
{"name":"CategoryTheory.Subpresheaf.equalizer.lift_Œπ'_assoc","module":"Mathlib.CategoryTheory.Subpresheaf.Equalizer","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF‚ÇÅ F‚ÇÇ : CategoryTheory.Functor (Opposite C) (Type w)\nA : CategoryTheory.Subpresheaf F‚ÇÅ\nf g : Quiver.Hom A.toPresheaf F‚ÇÇ\nG : CategoryTheory.Functor (Opposite C) (Type w)\nœÜ : Quiver.Hom G A.toPresheaf\nw : Eq (CategoryTheory.CategoryStruct.comp œÜ f) (CategoryTheory.CategoryStruct.comp œÜ g)\nZ : CategoryTheory.Functor (Opposite C) (Type w)\nh : Quiver.Hom F‚ÇÅ Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Subpresheaf.equalizer.lift f g œÜ w) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Subpresheaf.equalizer f g).Œπ h)) (CategoryTheory.CategoryStruct.comp œÜ (CategoryTheory.CategoryStruct.comp A.Œπ h))","decl":"@[reassoc (attr := simp)]\nlemma equalizer.lift_Œπ' {G : C·µí·µñ ‚•§ Type w} (œÜ : G ‚ü∂ A.toPresheaf)\n    (w : œÜ ‚â´ f = œÜ ‚â´ g) :\n    equalizer.lift f g œÜ w ‚â´ (Subpresheaf.equalizer f g).Œπ = œÜ ‚â´ A.Œπ :=\n  rfl\n\n"}
{"name":"CategoryTheory.Subpresheaf.equalizer.lift_Œπ'","module":"Mathlib.CategoryTheory.Subpresheaf.Equalizer","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF‚ÇÅ F‚ÇÇ : CategoryTheory.Functor (Opposite C) (Type w)\nA : CategoryTheory.Subpresheaf F‚ÇÅ\nf g : Quiver.Hom A.toPresheaf F‚ÇÇ\nG : CategoryTheory.Functor (Opposite C) (Type w)\nœÜ : Quiver.Hom G A.toPresheaf\nw : Eq (CategoryTheory.CategoryStruct.comp œÜ f) (CategoryTheory.CategoryStruct.comp œÜ g)\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Subpresheaf.equalizer.lift f g œÜ w) (CategoryTheory.Subpresheaf.equalizer f g).Œπ) (CategoryTheory.CategoryStruct.comp œÜ A.Œπ)","decl":"@[reassoc (attr := simp)]\nlemma equalizer.lift_Œπ' {G : C·µí·µñ ‚•§ Type w} (œÜ : G ‚ü∂ A.toPresheaf)\n    (w : œÜ ‚â´ f = œÜ ‚â´ g) :\n    equalizer.lift f g œÜ w ‚â´ (Subpresheaf.equalizer f g).Œπ = œÜ ‚â´ A.Œπ :=\n  rfl\n\n"}
{"name":"CategoryTheory.Subpresheaf.equalizer.lift_Œπ_assoc","module":"Mathlib.CategoryTheory.Subpresheaf.Equalizer","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF‚ÇÅ F‚ÇÇ : CategoryTheory.Functor (Opposite C) (Type w)\nA : CategoryTheory.Subpresheaf F‚ÇÅ\nf g : Quiver.Hom A.toPresheaf F‚ÇÇ\nG : CategoryTheory.Functor (Opposite C) (Type w)\nœÜ : Quiver.Hom G A.toPresheaf\nw : Eq (CategoryTheory.CategoryStruct.comp œÜ f) (CategoryTheory.CategoryStruct.comp œÜ g)\nZ : CategoryTheory.Functor (Opposite C) (Type w)\nh : Quiver.Hom A.toPresheaf Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Subpresheaf.equalizer.lift f g œÜ w) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Subpresheaf.equalizer.Œπ f g) h)) (CategoryTheory.CategoryStruct.comp œÜ h)","decl":"@[reassoc (attr := simp)]\nlemma equalizer.lift_Œπ {G : C·µí·µñ ‚•§ Type w} (œÜ : G ‚ü∂ A.toPresheaf)\n    (w : œÜ ‚â´ f = œÜ ‚â´ g) :\n    equalizer.lift f g œÜ w ‚â´ equalizer.Œπ f g = œÜ :=\n  rfl\n\n"}
{"name":"CategoryTheory.Subpresheaf.equalizer.lift_Œπ","module":"Mathlib.CategoryTheory.Subpresheaf.Equalizer","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF‚ÇÅ F‚ÇÇ : CategoryTheory.Functor (Opposite C) (Type w)\nA : CategoryTheory.Subpresheaf F‚ÇÅ\nf g : Quiver.Hom A.toPresheaf F‚ÇÇ\nG : CategoryTheory.Functor (Opposite C) (Type w)\nœÜ : Quiver.Hom G A.toPresheaf\nw : Eq (CategoryTheory.CategoryStruct.comp œÜ f) (CategoryTheory.CategoryStruct.comp œÜ g)\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Subpresheaf.equalizer.lift f g œÜ w) (CategoryTheory.Subpresheaf.equalizer.Œπ f g)) œÜ","decl":"@[reassoc (attr := simp)]\nlemma equalizer.lift_Œπ {G : C·µí·µñ ‚•§ Type w} (œÜ : G ‚ü∂ A.toPresheaf)\n    (w : œÜ ‚â´ f = œÜ ‚â´ g) :\n    equalizer.lift f g œÜ w ‚â´ equalizer.Œπ f g = œÜ :=\n  rfl\n\n"}
{"name":"CategoryTheory.Subpresheaf.equalizer.fork_pt","module":"Mathlib.CategoryTheory.Subpresheaf.Equalizer","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF‚ÇÅ F‚ÇÇ : CategoryTheory.Functor (Opposite C) (Type w)\nA : CategoryTheory.Subpresheaf F‚ÇÅ\nf g : Quiver.Hom A.toPresheaf F‚ÇÇ\n‚ä¢ Eq (CategoryTheory.Subpresheaf.equalizer.fork f g).pt (CategoryTheory.Subpresheaf.equalizer f g).toPresheaf","decl":"/-- The (limit) fork which expresses `(Subpresheaf.equalizer f g).toPresheaf` as\nthe equalizer of `f` and `g`. -/\n@[simps! pt]\ndef equalizer.fork : Limits.Fork f g :=\n  Limits.Fork.ofŒπ (equalizer.Œπ f g) (equalizer.condition f g)\n\n"}
{"name":"CategoryTheory.Subpresheaf.equalizer.fork_Œπ","module":"Mathlib.CategoryTheory.Subpresheaf.Equalizer","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF‚ÇÅ F‚ÇÇ : CategoryTheory.Functor (Opposite C) (Type w)\nA : CategoryTheory.Subpresheaf F‚ÇÅ\nf g : Quiver.Hom A.toPresheaf F‚ÇÇ\n‚ä¢ Eq (CategoryTheory.Subpresheaf.equalizer.fork f g).Œπ (CategoryTheory.Subpresheaf.equalizer.Œπ f g)","decl":"@[simp]\nlemma equalizer.fork_Œπ :\n    (equalizer.fork f g).Œπ = equalizer.Œπ f g := rfl\n\n"}
