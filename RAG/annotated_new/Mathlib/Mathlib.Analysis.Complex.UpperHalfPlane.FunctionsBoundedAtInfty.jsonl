{"name":"UpperHalfPlane.atImInfty_basis","module":"Mathlib.Analysis.Complex.UpperHalfPlane.FunctionsBoundedAtInfty","initialProofState":"⊢ UpperHalfPlane.atImInfty.HasBasis (fun x => True) fun i => Set.preimage UpperHalfPlane.im (Set.Ici i)","decl":"theorem atImInfty_basis : atImInfty.HasBasis (fun _ => True) fun i : ℝ => im ⁻¹' Set.Ici i :=\n  Filter.HasBasis.comap UpperHalfPlane.im Filter.atTop_basis\n\n"}
{"name":"UpperHalfPlane.atImInfty_mem","module":"Mathlib.Analysis.Complex.UpperHalfPlane.FunctionsBoundedAtInfty","initialProofState":"S : Set UpperHalfPlane\n⊢ Iff (Membership.mem UpperHalfPlane.atImInfty S) (Exists fun A => ∀ (z : UpperHalfPlane), LE.le A z.im → Membership.mem S z)","decl":"theorem atImInfty_mem (S : Set ℍ) : S ∈ atImInfty ↔ ∃ A : ℝ, ∀ z : ℍ, A ≤ im z → z ∈ S := by\n  simp only [atImInfty_basis.mem_iff, true_and]; rfl\n\n"}
{"name":"UpperHalfPlane.zero_form_isBoundedAtImInfty","module":"Mathlib.Analysis.Complex.UpperHalfPlane.FunctionsBoundedAtInfty","initialProofState":"α : Type u_1\ninst✝ : NormedField α\n⊢ UpperHalfPlane.IsBoundedAtImInfty 0","decl":"theorem zero_form_isBoundedAtImInfty {α : Type*} [NormedField α] :\n    IsBoundedAtImInfty (0 : ℍ → α) :=\n  const_boundedAtFilter atImInfty (0 : α)\n\n"}
{"name":"UpperHalfPlane.isBoundedAtImInfty_iff","module":"Mathlib.Analysis.Complex.UpperHalfPlane.FunctionsBoundedAtInfty","initialProofState":"α : Type u_1\ninst✝ : Norm α\nf : UpperHalfPlane → α\n⊢ Iff (UpperHalfPlane.IsBoundedAtImInfty f) (Exists fun M => Exists fun A => ∀ (z : UpperHalfPlane), LE.le A z.im → LE.le (Norm.norm (f z)) M)","decl":"theorem isBoundedAtImInfty_iff {α : Type*} [Norm α] {f : ℍ → α} :\n    IsBoundedAtImInfty f ↔ ∃ M A : ℝ, ∀ z : ℍ, A ≤ im z → ‖f z‖ ≤ M := by\n  simp [IsBoundedAtImInfty, BoundedAtFilter, Asymptotics.isBigO_iff, Filter.Eventually,\n    atImInfty_mem]\n\n"}
{"name":"bounded_mem","module":"Mathlib.Analysis.Complex.UpperHalfPlane.FunctionsBoundedAtInfty","initialProofState":"α : Type u_1\ninst✝ : Norm α\nf : UpperHalfPlane → α\n⊢ Iff (UpperHalfPlane.IsBoundedAtImInfty f) (Exists fun M => Exists fun A => ∀ (z : UpperHalfPlane), LE.le A z.im → LE.le (Norm.norm (f z)) M)","decl":"@[deprecated (since := \"2024-08-27\")] alias _root_.bounded_mem := isBoundedAtImInfty_iff\n\n"}
{"name":"UpperHalfPlane.isZeroAtImInfty_iff","module":"Mathlib.Analysis.Complex.UpperHalfPlane.FunctionsBoundedAtInfty","initialProofState":"α : Type u_1\ninst✝ : SeminormedAddGroup α\nf : UpperHalfPlane → α\n⊢ Iff (UpperHalfPlane.IsZeroAtImInfty f) (∀ (ε : Real), LT.lt 0 ε → Exists fun A => ∀ (z : UpperHalfPlane), LE.le A z.im → LE.le (Norm.norm (f z)) ε)","decl":"theorem isZeroAtImInfty_iff {α : Type*} [SeminormedAddGroup α] {f : ℍ → α} :\n    IsZeroAtImInfty f ↔ ∀ ε : ℝ, 0 < ε → ∃ A : ℝ, ∀ z : ℍ, A ≤ im z → ‖f z‖ ≤ ε :=\n  (atImInfty_basis.tendsto_iff Metric.nhds_basis_closedBall).trans <| by simp\n\n"}
{"name":"zero_at_im_infty","module":"Mathlib.Analysis.Complex.UpperHalfPlane.FunctionsBoundedAtInfty","initialProofState":"α : Type u_1\ninst✝ : SeminormedAddGroup α\nf : UpperHalfPlane → α\n⊢ Iff (UpperHalfPlane.IsZeroAtImInfty f) (∀ (ε : Real), LT.lt 0 ε → Exists fun A => ∀ (z : UpperHalfPlane), LE.le A z.im → LE.le (Norm.norm (f z)) ε)","decl":"@[deprecated (since := \"2024-08-27\")] alias _root_.zero_at_im_infty := isZeroAtImInfty_iff\n\n"}
{"name":"UpperHalfPlane.IsZeroAtImInfty.isBoundedAtImInfty","module":"Mathlib.Analysis.Complex.UpperHalfPlane.FunctionsBoundedAtInfty","initialProofState":"α : Type u_1\ninst✝ : SeminormedAddGroup α\nf : UpperHalfPlane → α\nhf : UpperHalfPlane.IsZeroAtImInfty f\n⊢ UpperHalfPlane.IsBoundedAtImInfty f","decl":"theorem IsZeroAtImInfty.isBoundedAtImInfty {α : Type*} [SeminormedAddGroup α] {f : ℍ → α}\n    (hf : IsZeroAtImInfty f) : IsBoundedAtImInfty f :=\n  hf.boundedAtFilter\n\n"}
{"name":"UpperHalfPlane.tendsto_comap_im_ofComplex","module":"Mathlib.Analysis.Complex.UpperHalfPlane.FunctionsBoundedAtInfty","initialProofState":"⊢ Filter.Tendsto (↑UpperHalfPlane.ofComplex) (Filter.comap Complex.im Filter.atTop) UpperHalfPlane.atImInfty","decl":"lemma tendsto_comap_im_ofComplex :\n    Tendsto ofComplex (comap Complex.im atTop) atImInfty := by\n  simp only [atImInfty, tendsto_comap_iff, Function.comp_def]\n  refine tendsto_comap.congr' ?_\n  filter_upwards [preimage_mem_comap (Ioi_mem_atTop 0)] with z hz\n  simp only [ofComplex_apply_of_im_pos hz, ← UpperHalfPlane.coe_im, coe_mk_subtype]\n\n"}
{"name":"UpperHalfPlane.tendsto_coe_atImInfty","module":"Mathlib.Analysis.Complex.UpperHalfPlane.FunctionsBoundedAtInfty","initialProofState":"⊢ Filter.Tendsto UpperHalfPlane.coe UpperHalfPlane.atImInfty (Filter.comap Complex.im Filter.atTop)","decl":"lemma tendsto_coe_atImInfty :\n    Tendsto UpperHalfPlane.coe atImInfty (comap Complex.im atTop) := by\n  simpa only [atImInfty, tendsto_comap_iff, Function.comp_def,\n    funext UpperHalfPlane.coe_im] using tendsto_comap\n\n\n"}
