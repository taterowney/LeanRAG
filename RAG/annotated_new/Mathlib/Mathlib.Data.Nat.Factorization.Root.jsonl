{"name":"Nat.floorRoot_def","module":"Mathlib.Data.Nat.Factorization.Root","initialProofState":"a n : Nat\n⊢ Eq (n.floorRoot a) (ite (Or (Eq n 0) (Eq a 0)) 0 ((FloorDiv.floorDiv a.factorization n).prod fun x1 x2 => HPow.hPow x1 x2))","decl":"/-- The RHS is a noncomputable version of `Nat.floorRoot` with better order theoretical\nproperties. -/\nlemma floorRoot_def :\n    floorRoot n a = if n = 0 ∨ a = 0 then 0 else (a.factorization ⌊/⌋ n).prod (· ^ ·) := by\n  unfold floorRoot; split_ifs with h <;> simp [Finsupp.floorDiv_def, prod_mapRange_index pow_zero]\n\n"}
{"name":"Nat.floorRoot_zero_left","module":"Mathlib.Data.Nat.Factorization.Root","initialProofState":"a : Nat\n⊢ Eq (Nat.floorRoot 0 a) 0","decl":"@[simp] lemma floorRoot_zero_left (a : ℕ) : floorRoot 0 a = 0 := by simp [floorRoot]\n"}
{"name":"Nat.floorRoot_zero_right","module":"Mathlib.Data.Nat.Factorization.Root","initialProofState":"n : Nat\n⊢ Eq (n.floorRoot 0) 0","decl":"@[simp] lemma floorRoot_zero_right (n : ℕ) : floorRoot n 0 = 0 := by simp [floorRoot]\n"}
{"name":"Nat.floorRoot_one_left","module":"Mathlib.Data.Nat.Factorization.Root","initialProofState":"a : Nat\n⊢ Eq (Nat.floorRoot 1 a) a","decl":"@[simp] lemma floorRoot_one_left (a : ℕ) : floorRoot 1 a = a := by\n  simp [floorRoot]; split_ifs <;> simp [*]\n"}
{"name":"Nat.floorRoot_one_right","module":"Mathlib.Data.Nat.Factorization.Root","initialProofState":"n : Nat\nhn : Ne n 0\n⊢ Eq (n.floorRoot 1) 1","decl":"@[simp] lemma floorRoot_one_right (hn : n ≠ 0) : floorRoot n 1 = 1 := by simp [floorRoot, hn]\n\n"}
{"name":"Nat.floorRoot_pow_self","module":"Mathlib.Data.Nat.Factorization.Root","initialProofState":"n : Nat\nhn : Ne n 0\na : Nat\n⊢ Eq (n.floorRoot (HPow.hPow a n)) a","decl":"@[simp] lemma floorRoot_pow_self (hn : n ≠ 0) (a : ℕ) : floorRoot n (a ^ n) = a := by\n  simp [floorRoot_def, pos_iff_ne_zero.2, hn]; split_ifs <;> simp [*]\n\n"}
{"name":"Nat.floorRoot_ne_zero","module":"Mathlib.Data.Nat.Factorization.Root","initialProofState":"a n : Nat\n⊢ Iff (Ne (n.floorRoot a) 0) (And (Ne n 0) (Ne a 0))","decl":"lemma floorRoot_ne_zero : floorRoot n a ≠ 0 ↔ n ≠ 0 ∧ a ≠ 0 := by\n  simp +contextual [floorRoot, not_imp_not, not_or]\n\n"}
{"name":"Nat.floorRoot_eq_zero","module":"Mathlib.Data.Nat.Factorization.Root","initialProofState":"a n : Nat\n⊢ Iff (Eq (n.floorRoot a) 0) (Or (Eq n 0) (Eq a 0))","decl":"@[simp] lemma floorRoot_eq_zero : floorRoot n a = 0 ↔ n = 0 ∨ a = 0 :=\n  floorRoot_ne_zero.not_right.trans <| by simp only [not_and_or, ne_eq, not_not]\n\n"}
{"name":"Nat.factorization_floorRoot","module":"Mathlib.Data.Nat.Factorization.Root","initialProofState":"n a : Nat\n⊢ Eq (n.floorRoot a).factorization (FloorDiv.floorDiv a.factorization n)","decl":"@[simp] lemma factorization_floorRoot (n a : ℕ) :\n    (floorRoot n a).factorization = a.factorization ⌊/⌋ n := by\n  rw [floorRoot_def]\n  split_ifs with h\n  · obtain rfl | rfl := h <;> simp\n  refine prod_pow_factorization_eq_self fun p hp ↦ ?_\n  have : p.Prime ∧ p ∣ a ∧ ¬a = 0 := by simpa using support_floorDiv_subset hp\n  exact this.1\n\n"}
{"name":"Nat.pow_dvd_iff_dvd_floorRoot","module":"Mathlib.Data.Nat.Factorization.Root","initialProofState":"a b n : Nat\n⊢ Iff (Dvd.dvd (HPow.hPow a n) b) (Dvd.dvd a (n.floorRoot b))","decl":"/-- Galois connection between `a ↦ a ^ n : ℕ → ℕ` and `floorRoot n : ℕ → ℕ` where `ℕ` is ordered\nby divisibility. -/\nlemma pow_dvd_iff_dvd_floorRoot : a ^ n ∣ b ↔ a ∣ floorRoot n b := by\n  obtain rfl | hn := eq_or_ne n 0\n  · simp\n  obtain rfl | hb := eq_or_ne b 0\n  · simp\n  obtain rfl | ha := eq_or_ne a 0\n  · simp [hn]\n  rw [← factorization_le_iff_dvd (pow_ne_zero _ ha) hb,\n    ← factorization_le_iff_dvd ha (floorRoot_ne_zero.2 ⟨hn, hb⟩), factorization_pow,\n    factorization_floorRoot, le_floorDiv_iff_smul_le (β := ℕ →₀ ℕ) (pos_iff_ne_zero.2 hn)]\n\n"}
{"name":"Nat.floorRoot_pow_dvd","module":"Mathlib.Data.Nat.Factorization.Root","initialProofState":"a n : Nat\n⊢ Dvd.dvd (HPow.hPow (n.floorRoot a) n) a","decl":"lemma floorRoot_pow_dvd : floorRoot n a ^ n ∣ a := pow_dvd_iff_dvd_floorRoot.2 dvd_rfl\n\n"}
{"name":"Nat.ceilRoot_def","module":"Mathlib.Data.Nat.Factorization.Root","initialProofState":"a n : Nat\n⊢ Eq (n.ceilRoot a) (ite (Or (Eq n 0) (Eq a 0)) 0 ((CeilDiv.ceilDiv a.factorization n).prod fun x1 x2 => HPow.hPow x1 x2))","decl":"/-- The RHS is a noncomputable version of `Nat.ceilRoot` with better order theoretical\nproperties. -/\nlemma ceilRoot_def :\n    ceilRoot n a = if n = 0 ∨ a = 0 then 0 else (a.factorization ⌈/⌉ n).prod (· ^ ·) := by\n  unfold ceilRoot\n  split_ifs with h <;>\n    simp [Finsupp.ceilDiv_def, prod_mapRange_index pow_zero, Nat.ceilDiv_eq_add_pred_div]\n\n"}
{"name":"Nat.ceilRoot_zero_left","module":"Mathlib.Data.Nat.Factorization.Root","initialProofState":"a : Nat\n⊢ Eq (Nat.ceilRoot 0 a) 0","decl":"@[simp] lemma ceilRoot_zero_left (a : ℕ) : ceilRoot 0 a = 0 := by simp [ceilRoot]\n"}
{"name":"Nat.ceilRoot_zero_right","module":"Mathlib.Data.Nat.Factorization.Root","initialProofState":"n : Nat\n⊢ Eq (n.ceilRoot 0) 0","decl":"@[simp] lemma ceilRoot_zero_right (n : ℕ) : ceilRoot n 0 = 0 := by simp [ceilRoot]\n"}
{"name":"Nat.ceilRoot_one_left","module":"Mathlib.Data.Nat.Factorization.Root","initialProofState":"a : Nat\n⊢ Eq (Nat.ceilRoot 1 a) a","decl":"@[simp] lemma ceilRoot_one_left (a : ℕ) : ceilRoot 1 a = a := by\n  simp [ceilRoot]; split_ifs <;> simp [*]\n"}
{"name":"Nat.ceilRoot_one_right","module":"Mathlib.Data.Nat.Factorization.Root","initialProofState":"n : Nat\nhn : Ne n 0\n⊢ Eq (n.ceilRoot 1) 1","decl":"@[simp] lemma ceilRoot_one_right (hn : n ≠ 0) : ceilRoot n 1 = 1 := by simp [ceilRoot, hn]\n\n"}
{"name":"Nat.ceilRoot_pow_self","module":"Mathlib.Data.Nat.Factorization.Root","initialProofState":"n : Nat\nhn : Ne n 0\na : Nat\n⊢ Eq (n.ceilRoot (HPow.hPow a n)) a","decl":"@[simp] lemma ceilRoot_pow_self (hn : n ≠ 0) (a : ℕ) : ceilRoot n (a ^ n) = a := by\n  simp [ceilRoot_def, pos_iff_ne_zero.2, hn]; split_ifs <;> simp [*]\n\n"}
{"name":"Nat.ceilRoot_ne_zero","module":"Mathlib.Data.Nat.Factorization.Root","initialProofState":"a n : Nat\n⊢ Iff (Ne (n.ceilRoot a) 0) (And (Ne n 0) (Ne a 0))","decl":"lemma ceilRoot_ne_zero : ceilRoot n a ≠ 0 ↔ n ≠ 0 ∧ a ≠ 0 := by\n  simp +contextual [ceilRoot_def, not_imp_not, not_or]\n\n"}
{"name":"Nat.ceilRoot_eq_zero","module":"Mathlib.Data.Nat.Factorization.Root","initialProofState":"a n : Nat\n⊢ Iff (Eq (n.ceilRoot a) 0) (Or (Eq n 0) (Eq a 0))","decl":"@[simp] lemma ceilRoot_eq_zero : ceilRoot n a = 0 ↔ n = 0 ∨ a = 0 :=\n  ceilRoot_ne_zero.not_right.trans <| by simp only [not_and_or, ne_eq, not_not]\n\n"}
{"name":"Nat.factorization_ceilRoot","module":"Mathlib.Data.Nat.Factorization.Root","initialProofState":"n a : Nat\n⊢ Eq (n.ceilRoot a).factorization (CeilDiv.ceilDiv a.factorization n)","decl":"@[simp] lemma factorization_ceilRoot (n a : ℕ) :\n    (ceilRoot n a).factorization = a.factorization ⌈/⌉ n := by\n  rw [ceilRoot_def]\n  split_ifs with h\n  · obtain rfl | rfl := h <;> simp\n  refine prod_pow_factorization_eq_self fun p hp ↦ ?_\n  have : p.Prime ∧ p ∣ a ∧ ¬a = 0 := by simpa using support_ceilDiv_subset hp\n  exact this.1\n\n"}
{"name":"Nat.dvd_pow_iff_ceilRoot_dvd","module":"Mathlib.Data.Nat.Factorization.Root","initialProofState":"a b n : Nat\nhn : Ne n 0\n⊢ Iff (Dvd.dvd a (HPow.hPow b n)) (Dvd.dvd (n.ceilRoot a) b)","decl":"/-- Galois connection between `ceilRoot n : ℕ → ℕ` and `a ↦ a ^ n : ℕ → ℕ` where `ℕ` is ordered\nby divisibility.\n\nNote that this cannot possibly hold for `n = 0`, regardless of the value of `ceilRoot 0 a`, because\nthe statement reduces to `a = 1 ↔ ceilRoot 0 a ∣ b`, which is false for eg `a = 0`,\n`b = ceilRoot 0 a`. -/\nlemma dvd_pow_iff_ceilRoot_dvd (hn : n ≠ 0) : a ∣ b ^ n ↔ ceilRoot n a ∣ b := by\n  obtain rfl | ha := eq_or_ne a 0\n  · aesop\n  obtain rfl | hb := eq_or_ne b 0\n  · simp [hn]\n  rw [← factorization_le_iff_dvd ha (pow_ne_zero _ hb),\n    ← factorization_le_iff_dvd (ceilRoot_ne_zero.2 ⟨hn, ha⟩) hb, factorization_pow,\n    factorization_ceilRoot, ceilDiv_le_iff_le_smul (β := ℕ →₀ ℕ) (pos_iff_ne_zero.2 hn)]\n\n"}
{"name":"Nat.dvd_ceilRoot_pow","module":"Mathlib.Data.Nat.Factorization.Root","initialProofState":"a n : Nat\nhn : Ne n 0\n⊢ Dvd.dvd a (HPow.hPow (n.ceilRoot a) n)","decl":"lemma dvd_ceilRoot_pow (hn : n ≠ 0) : a ∣ ceilRoot n a ^ n :=\n  (dvd_pow_iff_ceilRoot_dvd hn).2 dvd_rfl\n\n"}
