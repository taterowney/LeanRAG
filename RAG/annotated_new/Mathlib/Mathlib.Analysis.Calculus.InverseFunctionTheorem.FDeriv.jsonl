{"name":"HasStrictFDerivAt.approximates_deriv_on_nhds","module":"Mathlib.Analysis.Calculus.InverseFunctionTheorem.FDeriv","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nf' : ContinuousLinearMap (RingHom.id 𝕜) E F\na : E\nhf : HasStrictFDerivAt f f' a\nc : NNReal\nhc : Or (Subsingleton E) (LT.lt 0 c)\n⊢ Exists fun s => And (Membership.mem (nhds a) s) (ApproximatesLinearOn f f' s c)","decl":"/-- If `f` has derivative `f'` at `a` in the strict sense and `c > 0`, then `f` approximates `f'`\nwith constant `c` on some neighborhood of `a`. -/\ntheorem approximates_deriv_on_nhds {f : E → F} {f' : E →L[𝕜] F} {a : E}\n    (hf : HasStrictFDerivAt f f' a) {c : ℝ≥0} (hc : Subsingleton E ∨ 0 < c) :\n    ∃ s ∈ 𝓝 a, ApproximatesLinearOn f f' s c := by\n  cases' hc with hE hc\n  · refine ⟨univ, IsOpen.mem_nhds isOpen_univ trivial, fun x _ y _ => ?_⟩\n    simp [@Subsingleton.elim E hE x y]\n  have := hf.isLittleO.def hc\n  rw [nhds_prod_eq, Filter.Eventually, mem_prod_same_iff] at this\n  rcases this with ⟨s, has, hs⟩\n  exact ⟨s, has, fun x hx y hy => hs (mk_mem_prod hx hy)⟩\n\n"}
{"name":"HasStrictFDerivAt.map_nhds_eq_of_surj","module":"Mathlib.Analysis.Calculus.InverseFunctionTheorem.FDeriv","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\ninst✝¹ : CompleteSpace E\ninst✝ : CompleteSpace F\nf : E → F\nf' : ContinuousLinearMap (RingHom.id 𝕜) E F\na : E\nhf : HasStrictFDerivAt f f' a\nh : Eq (LinearMap.range f') Top.top\n⊢ Eq (Filter.map f (nhds a)) (nhds (f a))","decl":"theorem map_nhds_eq_of_surj [CompleteSpace E] [CompleteSpace F] {f : E → F} {f' : E →L[𝕜] F} {a : E}\n    (hf : HasStrictFDerivAt f (f' : E →L[𝕜] F) a) (h : LinearMap.range f' = ⊤) :\n    map f (𝓝 a) = 𝓝 (f a) := by\n  let f'symm := f'.nonlinearRightInverseOfSurjective h\n  set c : ℝ≥0 := f'symm.nnnorm⁻¹ / 2 with hc\n  have f'symm_pos : 0 < f'symm.nnnorm := f'.nonlinearRightInverseOfSurjective_nnnorm_pos h\n  have cpos : 0 < c := by simp [hc, half_pos, inv_pos, f'symm_pos]\n  obtain ⟨s, s_nhds, hs⟩ : ∃ s ∈ 𝓝 a, ApproximatesLinearOn f f' s c :=\n    hf.approximates_deriv_on_nhds (Or.inr cpos)\n  apply hs.map_nhds_eq f'symm s_nhds (Or.inr (NNReal.half_lt_self _))\n  simp [ne_of_gt f'symm_pos]\n\n"}
{"name":"HasStrictFDerivAt.approximates_deriv_on_open_nhds","module":"Mathlib.Analysis.Calculus.InverseFunctionTheorem.FDeriv","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nf' : ContinuousLinearEquiv (RingHom.id 𝕜) E F\na : E\nhf : HasStrictFDerivAt f (↑f') a\n⊢ Exists fun s => And (Membership.mem s a) (And (IsOpen s) (ApproximatesLinearOn f (↑f') s (HDiv.hDiv (Inv.inv (NNNorm.nnnorm ↑f'.symm)) 2)))","decl":"theorem approximates_deriv_on_open_nhds (hf : HasStrictFDerivAt f (f' : E →L[𝕜] F) a) :\n    ∃ s : Set E, a ∈ s ∧ IsOpen s ∧\n      ApproximatesLinearOn f (f' : E →L[𝕜] F) s (‖(f'.symm : F →L[𝕜] E)‖₊⁻¹ / 2) := by\n  simp only [← and_assoc]\n  refine ((nhds_basis_opens a).exists_iff fun s t => ApproximatesLinearOn.mono_set).1 ?_\n  exact\n    hf.approximates_deriv_on_nhds <|\n      f'.subsingleton_or_nnnorm_symm_pos.imp id fun hf' => half_pos <| inv_pos.2 hf'\n\n"}
{"name":"HasStrictFDerivAt.toPartialHomeomorph_coe","module":"Mathlib.Analysis.Calculus.InverseFunctionTheorem.FDeriv","initialProofState":"𝕜 : Type u_1\ninst✝⁵ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace 𝕜 F\nf : E → F\nf' : ContinuousLinearEquiv (RingHom.id 𝕜) E F\na : E\ninst✝ : CompleteSpace E\nhf : HasStrictFDerivAt f (↑f') a\n⊢ Eq (↑(HasStrictFDerivAt.toPartialHomeomorph f hf)) f","decl":"@[simp]\ntheorem toPartialHomeomorph_coe (hf : HasStrictFDerivAt f (f' : E →L[𝕜] F) a) :\n    (hf.toPartialHomeomorph f : E → F) = f :=\n  rfl\n\n"}
{"name":"HasStrictFDerivAt.mem_toPartialHomeomorph_source","module":"Mathlib.Analysis.Calculus.InverseFunctionTheorem.FDeriv","initialProofState":"𝕜 : Type u_1\ninst✝⁵ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace 𝕜 F\nf : E → F\nf' : ContinuousLinearEquiv (RingHom.id 𝕜) E F\na : E\ninst✝ : CompleteSpace E\nhf : HasStrictFDerivAt f (↑f') a\n⊢ Membership.mem (HasStrictFDerivAt.toPartialHomeomorph f hf).source a","decl":"theorem mem_toPartialHomeomorph_source (hf : HasStrictFDerivAt f (f' : E →L[𝕜] F) a) :\n    a ∈ (hf.toPartialHomeomorph f).source :=\n  (Classical.choose_spec hf.approximates_deriv_on_open_nhds).1\n\n"}
{"name":"HasStrictFDerivAt.image_mem_toPartialHomeomorph_target","module":"Mathlib.Analysis.Calculus.InverseFunctionTheorem.FDeriv","initialProofState":"𝕜 : Type u_1\ninst✝⁵ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace 𝕜 F\nf : E → F\nf' : ContinuousLinearEquiv (RingHom.id 𝕜) E F\na : E\ninst✝ : CompleteSpace E\nhf : HasStrictFDerivAt f (↑f') a\n⊢ Membership.mem (HasStrictFDerivAt.toPartialHomeomorph f hf).target (f a)","decl":"theorem image_mem_toPartialHomeomorph_target (hf : HasStrictFDerivAt f (f' : E →L[𝕜] F) a) :\n    f a ∈ (hf.toPartialHomeomorph f).target :=\n  (hf.toPartialHomeomorph f).map_source hf.mem_toPartialHomeomorph_source\n\n"}
{"name":"HasStrictFDerivAt.map_nhds_eq_of_equiv","module":"Mathlib.Analysis.Calculus.InverseFunctionTheorem.FDeriv","initialProofState":"𝕜 : Type u_1\ninst✝⁵ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace 𝕜 F\nf : E → F\nf' : ContinuousLinearEquiv (RingHom.id 𝕜) E F\na : E\ninst✝ : CompleteSpace E\nhf : HasStrictFDerivAt f (↑f') a\n⊢ Eq (Filter.map f (nhds a)) (nhds (f a))","decl":"theorem map_nhds_eq_of_equiv (hf : HasStrictFDerivAt f (f' : E →L[𝕜] F) a) :\n    map f (𝓝 a) = 𝓝 (f a) :=\n  (hf.toPartialHomeomorph f).map_nhds_eq hf.mem_toPartialHomeomorph_source\n\n"}
{"name":"HasStrictFDerivAt.localInverse_def","module":"Mathlib.Analysis.Calculus.InverseFunctionTheorem.FDeriv","initialProofState":"𝕜 : Type u_1\ninst✝⁵ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace 𝕜 F\nf : E → F\nf' : ContinuousLinearEquiv (RingHom.id 𝕜) E F\na : E\ninst✝ : CompleteSpace E\nhf : HasStrictFDerivAt f (↑f') a\n⊢ Eq (HasStrictFDerivAt.localInverse f f' a hf) ↑(HasStrictFDerivAt.toPartialHomeomorph f hf).symm","decl":"theorem localInverse_def (hf : HasStrictFDerivAt f (f' : E →L[𝕜] F) a) :\n    hf.localInverse f _ _ = (hf.toPartialHomeomorph f).symm :=\n  rfl\n\n"}
{"name":"HasStrictFDerivAt.eventually_left_inverse","module":"Mathlib.Analysis.Calculus.InverseFunctionTheorem.FDeriv","initialProofState":"𝕜 : Type u_1\ninst✝⁵ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace 𝕜 F\nf : E → F\nf' : ContinuousLinearEquiv (RingHom.id 𝕜) E F\na : E\ninst✝ : CompleteSpace E\nhf : HasStrictFDerivAt f (↑f') a\n⊢ Filter.Eventually (fun x => Eq (HasStrictFDerivAt.localInverse f f' a hf (f x)) x) (nhds a)","decl":"theorem eventually_left_inverse (hf : HasStrictFDerivAt f (f' : E →L[𝕜] F) a) :\n    ∀ᶠ x in 𝓝 a, hf.localInverse f f' a (f x) = x :=\n  (hf.toPartialHomeomorph f).eventually_left_inverse hf.mem_toPartialHomeomorph_source\n\n"}
{"name":"HasStrictFDerivAt.localInverse_apply_image","module":"Mathlib.Analysis.Calculus.InverseFunctionTheorem.FDeriv","initialProofState":"𝕜 : Type u_1\ninst✝⁵ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace 𝕜 F\nf : E → F\nf' : ContinuousLinearEquiv (RingHom.id 𝕜) E F\na : E\ninst✝ : CompleteSpace E\nhf : HasStrictFDerivAt f (↑f') a\n⊢ Eq (HasStrictFDerivAt.localInverse f f' a hf (f a)) a","decl":"@[simp]\ntheorem localInverse_apply_image (hf : HasStrictFDerivAt f (f' : E →L[𝕜] F) a) :\n    hf.localInverse f f' a (f a) = a :=\n  hf.eventually_left_inverse.self_of_nhds\n\n"}
{"name":"HasStrictFDerivAt.eventually_right_inverse","module":"Mathlib.Analysis.Calculus.InverseFunctionTheorem.FDeriv","initialProofState":"𝕜 : Type u_1\ninst✝⁵ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace 𝕜 F\nf : E → F\nf' : ContinuousLinearEquiv (RingHom.id 𝕜) E F\na : E\ninst✝ : CompleteSpace E\nhf : HasStrictFDerivAt f (↑f') a\n⊢ Filter.Eventually (fun y => Eq (f (HasStrictFDerivAt.localInverse f f' a hf y)) y) (nhds (f a))","decl":"theorem eventually_right_inverse (hf : HasStrictFDerivAt f (f' : E →L[𝕜] F) a) :\n    ∀ᶠ y in 𝓝 (f a), f (hf.localInverse f f' a y) = y :=\n  (hf.toPartialHomeomorph f).eventually_right_inverse' hf.mem_toPartialHomeomorph_source\n\n"}
{"name":"HasStrictFDerivAt.localInverse_continuousAt","module":"Mathlib.Analysis.Calculus.InverseFunctionTheorem.FDeriv","initialProofState":"𝕜 : Type u_1\ninst✝⁵ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace 𝕜 F\nf : E → F\nf' : ContinuousLinearEquiv (RingHom.id 𝕜) E F\na : E\ninst✝ : CompleteSpace E\nhf : HasStrictFDerivAt f (↑f') a\n⊢ ContinuousAt (HasStrictFDerivAt.localInverse f f' a hf) (f a)","decl":"theorem localInverse_continuousAt (hf : HasStrictFDerivAt f (f' : E →L[𝕜] F) a) :\n    ContinuousAt (hf.localInverse f f' a) (f a) :=\n  (hf.toPartialHomeomorph f).continuousAt_symm hf.image_mem_toPartialHomeomorph_target\n\n"}
{"name":"HasStrictFDerivAt.localInverse_tendsto","module":"Mathlib.Analysis.Calculus.InverseFunctionTheorem.FDeriv","initialProofState":"𝕜 : Type u_1\ninst✝⁵ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace 𝕜 F\nf : E → F\nf' : ContinuousLinearEquiv (RingHom.id 𝕜) E F\na : E\ninst✝ : CompleteSpace E\nhf : HasStrictFDerivAt f (↑f') a\n⊢ Filter.Tendsto (HasStrictFDerivAt.localInverse f f' a hf) (nhds (f a)) (nhds a)","decl":"theorem localInverse_tendsto (hf : HasStrictFDerivAt f (f' : E →L[𝕜] F) a) :\n    Tendsto (hf.localInverse f f' a) (𝓝 <| f a) (𝓝 a) :=\n  (hf.toPartialHomeomorph f).tendsto_symm hf.mem_toPartialHomeomorph_source\n\n"}
{"name":"HasStrictFDerivAt.localInverse_unique","module":"Mathlib.Analysis.Calculus.InverseFunctionTheorem.FDeriv","initialProofState":"𝕜 : Type u_1\ninst✝⁵ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace 𝕜 F\nf : E → F\nf' : ContinuousLinearEquiv (RingHom.id 𝕜) E F\na : E\ninst✝ : CompleteSpace E\nhf : HasStrictFDerivAt f (↑f') a\ng : F → E\nhg : Filter.Eventually (fun x => Eq (g (f x)) x) (nhds a)\n⊢ Filter.Eventually (fun y => Eq (g y) (HasStrictFDerivAt.localInverse f f' a hf y)) (nhds (f a))","decl":"theorem localInverse_unique (hf : HasStrictFDerivAt f (f' : E →L[𝕜] F) a) {g : F → E}\n    (hg : ∀ᶠ x in 𝓝 a, g (f x) = x) : ∀ᶠ y in 𝓝 (f a), g y = localInverse f f' a hf y :=\n  eventuallyEq_of_left_inv_of_right_inv hg hf.eventually_right_inverse <|\n    (hf.toPartialHomeomorph f).tendsto_symm hf.mem_toPartialHomeomorph_source\n\n"}
{"name":"HasStrictFDerivAt.to_localInverse","module":"Mathlib.Analysis.Calculus.InverseFunctionTheorem.FDeriv","initialProofState":"𝕜 : Type u_1\ninst✝⁵ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace 𝕜 F\nf : E → F\nf' : ContinuousLinearEquiv (RingHom.id 𝕜) E F\na : E\ninst✝ : CompleteSpace E\nhf : HasStrictFDerivAt f (↑f') a\n⊢ HasStrictFDerivAt (HasStrictFDerivAt.localInverse f f' a hf) (↑f'.symm) (f a)","decl":"/-- If `f` has an invertible derivative `f'` at `a` in the sense of strict differentiability `(hf)`,\nthen the inverse function `hf.localInverse f` has derivative `f'.symm` at `f a`. -/\ntheorem to_localInverse (hf : HasStrictFDerivAt f (f' : E →L[𝕜] F) a) :\n    HasStrictFDerivAt (hf.localInverse f f' a) (f'.symm : F →L[𝕜] E) (f a) :=\n  (hf.toPartialHomeomorph f).hasStrictFDerivAt_symm hf.image_mem_toPartialHomeomorph_target <| by\n    simpa [← localInverse_def] using hf\n\n"}
{"name":"HasStrictFDerivAt.to_local_left_inverse","module":"Mathlib.Analysis.Calculus.InverseFunctionTheorem.FDeriv","initialProofState":"𝕜 : Type u_1\ninst✝⁵ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace 𝕜 F\nf : E → F\nf' : ContinuousLinearEquiv (RingHom.id 𝕜) E F\na : E\ninst✝ : CompleteSpace E\nhf : HasStrictFDerivAt f (↑f') a\ng : F → E\nhg : Filter.Eventually (fun x => Eq (g (f x)) x) (nhds a)\n⊢ HasStrictFDerivAt g (↑f'.symm) (f a)","decl":"/-- If `f : E → F` has an invertible derivative `f'` at `a` in the sense of strict differentiability\nand `g (f x) = x` in a neighborhood of `a`, then `g` has derivative `f'.symm` at `f a`.\n\nFor a version assuming `f (g y) = y` and continuity of `g` at `f a` but not `[CompleteSpace E]`\nsee `of_local_left_inverse`. -/\ntheorem to_local_left_inverse (hf : HasStrictFDerivAt f (f' : E →L[𝕜] F) a) {g : F → E}\n    (hg : ∀ᶠ x in 𝓝 a, g (f x) = x) : HasStrictFDerivAt g (f'.symm : F →L[𝕜] E) (f a) :=\n  hf.to_localInverse.congr_of_eventuallyEq <| (hf.localInverse_unique hg).mono fun _ => Eq.symm\n\n"}
{"name":"isOpenMap_of_hasStrictFDerivAt_equiv","module":"Mathlib.Analysis.Calculus.InverseFunctionTheorem.FDeriv","initialProofState":"𝕜 : Type u_1\ninst✝⁵ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace 𝕜 F\ninst✝ : CompleteSpace E\nf : E → F\nf' : E → ContinuousLinearEquiv (RingHom.id 𝕜) E F\nhf : ∀ (x : E), HasStrictFDerivAt f (↑(f' x)) x\n⊢ IsOpenMap f","decl":"/-- If a function has an invertible strict derivative at all points, then it is an open map. -/\ntheorem isOpenMap_of_hasStrictFDerivAt_equiv [CompleteSpace E] {f : E → F} {f' : E → E ≃L[𝕜] F}\n    (hf : ∀ x, HasStrictFDerivAt f (f' x : E →L[𝕜] F) x) : IsOpenMap f :=\n  isOpenMap_iff_nhds_le.2 fun x => (hf x).map_nhds_eq_of_equiv.ge\n"}
