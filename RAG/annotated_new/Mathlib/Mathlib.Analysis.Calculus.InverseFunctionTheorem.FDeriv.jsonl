{"name":"HasStrictFDerivAt.approximates_deriv_on_nhds","module":"Mathlib.Analysis.Calculus.InverseFunctionTheorem.FDeriv","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nf' : ContinuousLinearMap (RingHom.id ğ•œ) E F\na : E\nhf : HasStrictFDerivAt f f' a\nc : NNReal\nhc : Or (Subsingleton E) (LT.lt 0 c)\nâŠ¢ Exists fun s => And (Membership.mem (nhds a) s) (ApproximatesLinearOn f f' s c)","decl":"/-- If `f` has derivative `f'` at `a` in the strict sense and `c > 0`, then `f` approximates `f'`\nwith constant `c` on some neighborhood of `a`. -/\ntheorem approximates_deriv_on_nhds {f : E â†’ F} {f' : E â†’L[ğ•œ] F} {a : E}\n    (hf : HasStrictFDerivAt f f' a) {c : â„â‰¥0} (hc : Subsingleton E âˆ¨ 0 < c) :\n    âˆƒ s âˆˆ ğ“ a, ApproximatesLinearOn f f' s c := by\n  cases' hc with hE hc\n  Â· refine âŸ¨univ, IsOpen.mem_nhds isOpen_univ trivial, fun x _ y _ => ?_âŸ©\n    simp [@Subsingleton.elim E hE x y]\n  have := hf.isLittleO.def hc\n  rw [nhds_prod_eq, Filter.Eventually, mem_prod_same_iff] at this\n  rcases this with âŸ¨s, has, hsâŸ©\n  exact âŸ¨s, has, fun x hx y hy => hs (mk_mem_prod hx hy)âŸ©\n\n"}
{"name":"HasStrictFDerivAt.map_nhds_eq_of_surj","module":"Mathlib.Analysis.Calculus.InverseFunctionTheorem.FDeriv","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\ninstâœÂ¹ : CompleteSpace E\ninstâœ : CompleteSpace F\nf : E â†’ F\nf' : ContinuousLinearMap (RingHom.id ğ•œ) E F\na : E\nhf : HasStrictFDerivAt f f' a\nh : Eq (LinearMap.range f') Top.top\nâŠ¢ Eq (Filter.map f (nhds a)) (nhds (f a))","decl":"theorem map_nhds_eq_of_surj [CompleteSpace E] [CompleteSpace F] {f : E â†’ F} {f' : E â†’L[ğ•œ] F} {a : E}\n    (hf : HasStrictFDerivAt f (f' : E â†’L[ğ•œ] F) a) (h : LinearMap.range f' = âŠ¤) :\n    map f (ğ“ a) = ğ“ (f a) := by\n  let f'symm := f'.nonlinearRightInverseOfSurjective h\n  set c : â„â‰¥0 := f'symm.nnnormâ»Â¹ / 2 with hc\n  have f'symm_pos : 0 < f'symm.nnnorm := f'.nonlinearRightInverseOfSurjective_nnnorm_pos h\n  have cpos : 0 < c := by simp [hc, half_pos, inv_pos, f'symm_pos]\n  obtain âŸ¨s, s_nhds, hsâŸ© : âˆƒ s âˆˆ ğ“ a, ApproximatesLinearOn f f' s c :=\n    hf.approximates_deriv_on_nhds (Or.inr cpos)\n  apply hs.map_nhds_eq f'symm s_nhds (Or.inr (NNReal.half_lt_self _))\n  simp [ne_of_gt f'symm_pos]\n\n"}
{"name":"HasStrictFDerivAt.approximates_deriv_on_open_nhds","module":"Mathlib.Analysis.Calculus.InverseFunctionTheorem.FDeriv","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nf' : ContinuousLinearEquiv (RingHom.id ğ•œ) E F\na : E\nhf : HasStrictFDerivAt f (â†‘f') a\nâŠ¢ Exists fun s => And (Membership.mem s a) (And (IsOpen s) (ApproximatesLinearOn f (â†‘f') s (HDiv.hDiv (Inv.inv (NNNorm.nnnorm â†‘f'.symm)) 2)))","decl":"theorem approximates_deriv_on_open_nhds (hf : HasStrictFDerivAt f (f' : E â†’L[ğ•œ] F) a) :\n    âˆƒ s : Set E, a âˆˆ s âˆ§ IsOpen s âˆ§\n      ApproximatesLinearOn f (f' : E â†’L[ğ•œ] F) s (â€–(f'.symm : F â†’L[ğ•œ] E)â€–â‚Šâ»Â¹ / 2) := by\n  simp only [â† and_assoc]\n  refine ((nhds_basis_opens a).exists_iff fun s t => ApproximatesLinearOn.mono_set).1 ?_\n  exact\n    hf.approximates_deriv_on_nhds <|\n      f'.subsingleton_or_nnnorm_symm_pos.imp id fun hf' => half_pos <| inv_pos.2 hf'\n\n"}
{"name":"HasStrictFDerivAt.toPartialHomeomorph_coe","module":"Mathlib.Analysis.Calculus.InverseFunctionTheorem.FDeriv","initialProofState":"ğ•œ : Type u_1\ninstâœâµ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace ğ•œ F\nf : E â†’ F\nf' : ContinuousLinearEquiv (RingHom.id ğ•œ) E F\na : E\ninstâœ : CompleteSpace E\nhf : HasStrictFDerivAt f (â†‘f') a\nâŠ¢ Eq (â†‘(HasStrictFDerivAt.toPartialHomeomorph f hf)) f","decl":"@[simp]\ntheorem toPartialHomeomorph_coe (hf : HasStrictFDerivAt f (f' : E â†’L[ğ•œ] F) a) :\n    (hf.toPartialHomeomorph f : E â†’ F) = f :=\n  rfl\n\n"}
{"name":"HasStrictFDerivAt.mem_toPartialHomeomorph_source","module":"Mathlib.Analysis.Calculus.InverseFunctionTheorem.FDeriv","initialProofState":"ğ•œ : Type u_1\ninstâœâµ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace ğ•œ F\nf : E â†’ F\nf' : ContinuousLinearEquiv (RingHom.id ğ•œ) E F\na : E\ninstâœ : CompleteSpace E\nhf : HasStrictFDerivAt f (â†‘f') a\nâŠ¢ Membership.mem (HasStrictFDerivAt.toPartialHomeomorph f hf).source a","decl":"theorem mem_toPartialHomeomorph_source (hf : HasStrictFDerivAt f (f' : E â†’L[ğ•œ] F) a) :\n    a âˆˆ (hf.toPartialHomeomorph f).source :=\n  (Classical.choose_spec hf.approximates_deriv_on_open_nhds).1\n\n"}
{"name":"HasStrictFDerivAt.image_mem_toPartialHomeomorph_target","module":"Mathlib.Analysis.Calculus.InverseFunctionTheorem.FDeriv","initialProofState":"ğ•œ : Type u_1\ninstâœâµ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace ğ•œ F\nf : E â†’ F\nf' : ContinuousLinearEquiv (RingHom.id ğ•œ) E F\na : E\ninstâœ : CompleteSpace E\nhf : HasStrictFDerivAt f (â†‘f') a\nâŠ¢ Membership.mem (HasStrictFDerivAt.toPartialHomeomorph f hf).target (f a)","decl":"theorem image_mem_toPartialHomeomorph_target (hf : HasStrictFDerivAt f (f' : E â†’L[ğ•œ] F) a) :\n    f a âˆˆ (hf.toPartialHomeomorph f).target :=\n  (hf.toPartialHomeomorph f).map_source hf.mem_toPartialHomeomorph_source\n\n"}
{"name":"HasStrictFDerivAt.map_nhds_eq_of_equiv","module":"Mathlib.Analysis.Calculus.InverseFunctionTheorem.FDeriv","initialProofState":"ğ•œ : Type u_1\ninstâœâµ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace ğ•œ F\nf : E â†’ F\nf' : ContinuousLinearEquiv (RingHom.id ğ•œ) E F\na : E\ninstâœ : CompleteSpace E\nhf : HasStrictFDerivAt f (â†‘f') a\nâŠ¢ Eq (Filter.map f (nhds a)) (nhds (f a))","decl":"theorem map_nhds_eq_of_equiv (hf : HasStrictFDerivAt f (f' : E â†’L[ğ•œ] F) a) :\n    map f (ğ“ a) = ğ“ (f a) :=\n  (hf.toPartialHomeomorph f).map_nhds_eq hf.mem_toPartialHomeomorph_source\n\n"}
{"name":"HasStrictFDerivAt.localInverse_def","module":"Mathlib.Analysis.Calculus.InverseFunctionTheorem.FDeriv","initialProofState":"ğ•œ : Type u_1\ninstâœâµ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace ğ•œ F\nf : E â†’ F\nf' : ContinuousLinearEquiv (RingHom.id ğ•œ) E F\na : E\ninstâœ : CompleteSpace E\nhf : HasStrictFDerivAt f (â†‘f') a\nâŠ¢ Eq (HasStrictFDerivAt.localInverse f f' a hf) â†‘(HasStrictFDerivAt.toPartialHomeomorph f hf).symm","decl":"theorem localInverse_def (hf : HasStrictFDerivAt f (f' : E â†’L[ğ•œ] F) a) :\n    hf.localInverse f _ _ = (hf.toPartialHomeomorph f).symm :=\n  rfl\n\n"}
{"name":"HasStrictFDerivAt.eventually_left_inverse","module":"Mathlib.Analysis.Calculus.InverseFunctionTheorem.FDeriv","initialProofState":"ğ•œ : Type u_1\ninstâœâµ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace ğ•œ F\nf : E â†’ F\nf' : ContinuousLinearEquiv (RingHom.id ğ•œ) E F\na : E\ninstâœ : CompleteSpace E\nhf : HasStrictFDerivAt f (â†‘f') a\nâŠ¢ Filter.Eventually (fun x => Eq (HasStrictFDerivAt.localInverse f f' a hf (f x)) x) (nhds a)","decl":"theorem eventually_left_inverse (hf : HasStrictFDerivAt f (f' : E â†’L[ğ•œ] F) a) :\n    âˆ€á¶  x in ğ“ a, hf.localInverse f f' a (f x) = x :=\n  (hf.toPartialHomeomorph f).eventually_left_inverse hf.mem_toPartialHomeomorph_source\n\n"}
{"name":"HasStrictFDerivAt.localInverse_apply_image","module":"Mathlib.Analysis.Calculus.InverseFunctionTheorem.FDeriv","initialProofState":"ğ•œ : Type u_1\ninstâœâµ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace ğ•œ F\nf : E â†’ F\nf' : ContinuousLinearEquiv (RingHom.id ğ•œ) E F\na : E\ninstâœ : CompleteSpace E\nhf : HasStrictFDerivAt f (â†‘f') a\nâŠ¢ Eq (HasStrictFDerivAt.localInverse f f' a hf (f a)) a","decl":"@[simp]\ntheorem localInverse_apply_image (hf : HasStrictFDerivAt f (f' : E â†’L[ğ•œ] F) a) :\n    hf.localInverse f f' a (f a) = a :=\n  hf.eventually_left_inverse.self_of_nhds\n\n"}
{"name":"HasStrictFDerivAt.eventually_right_inverse","module":"Mathlib.Analysis.Calculus.InverseFunctionTheorem.FDeriv","initialProofState":"ğ•œ : Type u_1\ninstâœâµ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace ğ•œ F\nf : E â†’ F\nf' : ContinuousLinearEquiv (RingHom.id ğ•œ) E F\na : E\ninstâœ : CompleteSpace E\nhf : HasStrictFDerivAt f (â†‘f') a\nâŠ¢ Filter.Eventually (fun y => Eq (f (HasStrictFDerivAt.localInverse f f' a hf y)) y) (nhds (f a))","decl":"theorem eventually_right_inverse (hf : HasStrictFDerivAt f (f' : E â†’L[ğ•œ] F) a) :\n    âˆ€á¶  y in ğ“ (f a), f (hf.localInverse f f' a y) = y :=\n  (hf.toPartialHomeomorph f).eventually_right_inverse' hf.mem_toPartialHomeomorph_source\n\n"}
{"name":"HasStrictFDerivAt.localInverse_continuousAt","module":"Mathlib.Analysis.Calculus.InverseFunctionTheorem.FDeriv","initialProofState":"ğ•œ : Type u_1\ninstâœâµ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace ğ•œ F\nf : E â†’ F\nf' : ContinuousLinearEquiv (RingHom.id ğ•œ) E F\na : E\ninstâœ : CompleteSpace E\nhf : HasStrictFDerivAt f (â†‘f') a\nâŠ¢ ContinuousAt (HasStrictFDerivAt.localInverse f f' a hf) (f a)","decl":"theorem localInverse_continuousAt (hf : HasStrictFDerivAt f (f' : E â†’L[ğ•œ] F) a) :\n    ContinuousAt (hf.localInverse f f' a) (f a) :=\n  (hf.toPartialHomeomorph f).continuousAt_symm hf.image_mem_toPartialHomeomorph_target\n\n"}
{"name":"HasStrictFDerivAt.localInverse_tendsto","module":"Mathlib.Analysis.Calculus.InverseFunctionTheorem.FDeriv","initialProofState":"ğ•œ : Type u_1\ninstâœâµ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace ğ•œ F\nf : E â†’ F\nf' : ContinuousLinearEquiv (RingHom.id ğ•œ) E F\na : E\ninstâœ : CompleteSpace E\nhf : HasStrictFDerivAt f (â†‘f') a\nâŠ¢ Filter.Tendsto (HasStrictFDerivAt.localInverse f f' a hf) (nhds (f a)) (nhds a)","decl":"theorem localInverse_tendsto (hf : HasStrictFDerivAt f (f' : E â†’L[ğ•œ] F) a) :\n    Tendsto (hf.localInverse f f' a) (ğ“ <| f a) (ğ“ a) :=\n  (hf.toPartialHomeomorph f).tendsto_symm hf.mem_toPartialHomeomorph_source\n\n"}
{"name":"HasStrictFDerivAt.localInverse_unique","module":"Mathlib.Analysis.Calculus.InverseFunctionTheorem.FDeriv","initialProofState":"ğ•œ : Type u_1\ninstâœâµ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace ğ•œ F\nf : E â†’ F\nf' : ContinuousLinearEquiv (RingHom.id ğ•œ) E F\na : E\ninstâœ : CompleteSpace E\nhf : HasStrictFDerivAt f (â†‘f') a\ng : F â†’ E\nhg : Filter.Eventually (fun x => Eq (g (f x)) x) (nhds a)\nâŠ¢ Filter.Eventually (fun y => Eq (g y) (HasStrictFDerivAt.localInverse f f' a hf y)) (nhds (f a))","decl":"theorem localInverse_unique (hf : HasStrictFDerivAt f (f' : E â†’L[ğ•œ] F) a) {g : F â†’ E}\n    (hg : âˆ€á¶  x in ğ“ a, g (f x) = x) : âˆ€á¶  y in ğ“ (f a), g y = localInverse f f' a hf y :=\n  eventuallyEq_of_left_inv_of_right_inv hg hf.eventually_right_inverse <|\n    (hf.toPartialHomeomorph f).tendsto_symm hf.mem_toPartialHomeomorph_source\n\n"}
{"name":"HasStrictFDerivAt.to_localInverse","module":"Mathlib.Analysis.Calculus.InverseFunctionTheorem.FDeriv","initialProofState":"ğ•œ : Type u_1\ninstâœâµ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace ğ•œ F\nf : E â†’ F\nf' : ContinuousLinearEquiv (RingHom.id ğ•œ) E F\na : E\ninstâœ : CompleteSpace E\nhf : HasStrictFDerivAt f (â†‘f') a\nâŠ¢ HasStrictFDerivAt (HasStrictFDerivAt.localInverse f f' a hf) (â†‘f'.symm) (f a)","decl":"/-- If `f` has an invertible derivative `f'` at `a` in the sense of strict differentiability `(hf)`,\nthen the inverse function `hf.localInverse f` has derivative `f'.symm` at `f a`. -/\ntheorem to_localInverse (hf : HasStrictFDerivAt f (f' : E â†’L[ğ•œ] F) a) :\n    HasStrictFDerivAt (hf.localInverse f f' a) (f'.symm : F â†’L[ğ•œ] E) (f a) :=\n  (hf.toPartialHomeomorph f).hasStrictFDerivAt_symm hf.image_mem_toPartialHomeomorph_target <| by\n    simpa [â† localInverse_def] using hf\n\n"}
{"name":"HasStrictFDerivAt.to_local_left_inverse","module":"Mathlib.Analysis.Calculus.InverseFunctionTheorem.FDeriv","initialProofState":"ğ•œ : Type u_1\ninstâœâµ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace ğ•œ F\nf : E â†’ F\nf' : ContinuousLinearEquiv (RingHom.id ğ•œ) E F\na : E\ninstâœ : CompleteSpace E\nhf : HasStrictFDerivAt f (â†‘f') a\ng : F â†’ E\nhg : Filter.Eventually (fun x => Eq (g (f x)) x) (nhds a)\nâŠ¢ HasStrictFDerivAt g (â†‘f'.symm) (f a)","decl":"/-- If `f : E â†’ F` has an invertible derivative `f'` at `a` in the sense of strict differentiability\nand `g (f x) = x` in a neighborhood of `a`, then `g` has derivative `f'.symm` at `f a`.\n\nFor a version assuming `f (g y) = y` and continuity of `g` at `f a` but not `[CompleteSpace E]`\nsee `of_local_left_inverse`. -/\ntheorem to_local_left_inverse (hf : HasStrictFDerivAt f (f' : E â†’L[ğ•œ] F) a) {g : F â†’ E}\n    (hg : âˆ€á¶  x in ğ“ a, g (f x) = x) : HasStrictFDerivAt g (f'.symm : F â†’L[ğ•œ] E) (f a) :=\n  hf.to_localInverse.congr_of_eventuallyEq <| (hf.localInverse_unique hg).mono fun _ => Eq.symm\n\n"}
{"name":"isOpenMap_of_hasStrictFDerivAt_equiv","module":"Mathlib.Analysis.Calculus.InverseFunctionTheorem.FDeriv","initialProofState":"ğ•œ : Type u_1\ninstâœâµ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace ğ•œ F\ninstâœ : CompleteSpace E\nf : E â†’ F\nf' : E â†’ ContinuousLinearEquiv (RingHom.id ğ•œ) E F\nhf : âˆ€ (x : E), HasStrictFDerivAt f (â†‘(f' x)) x\nâŠ¢ IsOpenMap f","decl":"/-- If a function has an invertible strict derivative at all points, then it is an open map. -/\ntheorem isOpenMap_of_hasStrictFDerivAt_equiv [CompleteSpace E] {f : E â†’ F} {f' : E â†’ E â‰ƒL[ğ•œ] F}\n    (hf : âˆ€ x, HasStrictFDerivAt f (f' x : E â†’L[ğ•œ] F) x) : IsOpenMap f :=\n  isOpenMap_iff_nhds_le.2 fun x => (hf x).map_nhds_eq_of_equiv.ge\n"}
