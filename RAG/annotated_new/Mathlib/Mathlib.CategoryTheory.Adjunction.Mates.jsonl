{"name":"CategoryTheory.mateEquiv_symm_apply","module":"Mathlib.CategoryTheory.Adjunction.Mates","initialProofState":"C : Type u‚ÇÅ\nD : Type u‚ÇÇ\nE : Type u‚ÇÉ\nF : Type u‚ÇÑ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\ninst‚úù : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} F\nG : CategoryTheory.Functor C E\nH : CategoryTheory.Functor D F\nL‚ÇÅ : CategoryTheory.Functor C D\nR‚ÇÅ : CategoryTheory.Functor D C\nL‚ÇÇ : CategoryTheory.Functor E F\nR‚ÇÇ : CategoryTheory.Functor F E\nadj‚ÇÅ : CategoryTheory.Adjunction L‚ÇÅ R‚ÇÅ\nadj‚ÇÇ : CategoryTheory.Adjunction L‚ÇÇ R‚ÇÇ\nŒ≤ : Quiver.Hom (R‚ÇÅ.comp G) (H.comp R‚ÇÇ)\n‚ä¢ Eq ((CategoryTheory.mateEquiv adj‚ÇÅ adj‚ÇÇ).symm Œ≤) (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerRight adj‚ÇÅ.unit (G.comp L‚ÇÇ)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerRight (CategoryTheory.whiskerLeft L‚ÇÅ Œ≤) L‚ÇÇ) (CategoryTheory.whiskerLeft (L‚ÇÅ.comp H) adj‚ÇÇ.counit)))","decl":"/-- Suppose we have a square of functors (where the top and bottom are adjunctions `L‚ÇÅ ‚ä£ R‚ÇÅ`\nand `L‚ÇÇ ‚ä£ R‚ÇÇ` respectively).\n\n      C ‚Üî D\n    G ‚Üì   ‚Üì H\n      E ‚Üî F\n\nThen we have a bijection between natural transformations `G ‚ãô L‚ÇÇ ‚ü∂ L‚ÇÅ ‚ãô H` and\n`R‚ÇÅ ‚ãô G ‚ü∂ H ‚ãô R‚ÇÇ`. This can be seen as a bijection of the 2-cells:\n\n         L‚ÇÅ                  R‚ÇÅ\n      C --‚Üí D             C ‚Üê-- D\n    G ‚Üì  ‚Üó  ‚Üì H         G ‚Üì  ‚Üò  ‚Üì H\n      E --‚Üí F             E ‚Üê-- F\n         L‚ÇÇ                  R‚ÇÇ\n\nNote that if one of the transformations is an iso, it does not imply the other is an iso.\n-/\n@[simps]\ndef mateEquiv : (G ‚ãô L‚ÇÇ ‚ü∂ L‚ÇÅ ‚ãô H) ‚âÉ (R‚ÇÅ ‚ãô G ‚ü∂ H ‚ãô R‚ÇÇ) where\n  toFun Œ± :=\n    whiskerLeft (R‚ÇÅ ‚ãô G) adj‚ÇÇ.unit ‚â´\n    whiskerRight (whiskerLeft R‚ÇÅ Œ±) R‚ÇÇ ‚â´\n    whiskerRight adj‚ÇÅ.counit (H ‚ãô R‚ÇÇ)\n  invFun Œ≤ :=\n    whiskerRight adj‚ÇÅ.unit (G ‚ãô L‚ÇÇ) ‚â´\n    whiskerRight (whiskerLeft L‚ÇÅ Œ≤) L‚ÇÇ ‚â´\n    whiskerLeft (L‚ÇÅ ‚ãô H) adj‚ÇÇ.counit\n  left_inv Œ± := by\n    ext\n    unfold whiskerRight whiskerLeft\n    simp only [comp_obj, id_obj, Functor.comp_map, comp_app, map_comp, assoc, counit_naturality,\n      counit_naturality_assoc, left_triangle_components_assoc]\n    rw [‚Üê assoc, ‚Üê Functor.comp_map, Œ±.naturality, Functor.comp_map, assoc, ‚Üê H.map_comp,\n      left_triangle_components, map_id]\n    simp only [comp_obj, comp_id]\n  right_inv Œ≤ := by\n    ext\n    unfold whiskerLeft whiskerRight\n    simp only [comp_obj, id_obj, Functor.comp_map, comp_app, map_comp, assoc,\n      unit_naturality_assoc, right_triangle_components_assoc]\n    rw [‚Üê assoc, ‚Üê Functor.comp_map, assoc, ‚Üê Œ≤.naturality, ‚Üê assoc, Functor.comp_map,\n      ‚Üê G.map_comp, right_triangle_components, map_id, id_comp]\n\n"}
{"name":"CategoryTheory.mateEquiv_apply","module":"Mathlib.CategoryTheory.Adjunction.Mates","initialProofState":"C : Type u‚ÇÅ\nD : Type u‚ÇÇ\nE : Type u‚ÇÉ\nF : Type u‚ÇÑ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\ninst‚úù : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} F\nG : CategoryTheory.Functor C E\nH : CategoryTheory.Functor D F\nL‚ÇÅ : CategoryTheory.Functor C D\nR‚ÇÅ : CategoryTheory.Functor D C\nL‚ÇÇ : CategoryTheory.Functor E F\nR‚ÇÇ : CategoryTheory.Functor F E\nadj‚ÇÅ : CategoryTheory.Adjunction L‚ÇÅ R‚ÇÅ\nadj‚ÇÇ : CategoryTheory.Adjunction L‚ÇÇ R‚ÇÇ\nŒ± : Quiver.Hom (G.comp L‚ÇÇ) (L‚ÇÅ.comp H)\n‚ä¢ Eq ((CategoryTheory.mateEquiv adj‚ÇÅ adj‚ÇÇ) Œ±) (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerLeft (R‚ÇÅ.comp G) adj‚ÇÇ.unit) (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerRight (CategoryTheory.whiskerLeft R‚ÇÅ Œ±) R‚ÇÇ) (CategoryTheory.whiskerRight adj‚ÇÅ.counit (H.comp R‚ÇÇ))))","decl":"/-- Suppose we have a square of functors (where the top and bottom are adjunctions `L‚ÇÅ ‚ä£ R‚ÇÅ`\nand `L‚ÇÇ ‚ä£ R‚ÇÇ` respectively).\n\n      C ‚Üî D\n    G ‚Üì   ‚Üì H\n      E ‚Üî F\n\nThen we have a bijection between natural transformations `G ‚ãô L‚ÇÇ ‚ü∂ L‚ÇÅ ‚ãô H` and\n`R‚ÇÅ ‚ãô G ‚ü∂ H ‚ãô R‚ÇÇ`. This can be seen as a bijection of the 2-cells:\n\n         L‚ÇÅ                  R‚ÇÅ\n      C --‚Üí D             C ‚Üê-- D\n    G ‚Üì  ‚Üó  ‚Üì H         G ‚Üì  ‚Üò  ‚Üì H\n      E --‚Üí F             E ‚Üê-- F\n         L‚ÇÇ                  R‚ÇÇ\n\nNote that if one of the transformations is an iso, it does not imply the other is an iso.\n-/\n@[simps]\ndef mateEquiv : (G ‚ãô L‚ÇÇ ‚ü∂ L‚ÇÅ ‚ãô H) ‚âÉ (R‚ÇÅ ‚ãô G ‚ü∂ H ‚ãô R‚ÇÇ) where\n  toFun Œ± :=\n    whiskerLeft (R‚ÇÅ ‚ãô G) adj‚ÇÇ.unit ‚â´\n    whiskerRight (whiskerLeft R‚ÇÅ Œ±) R‚ÇÇ ‚â´\n    whiskerRight adj‚ÇÅ.counit (H ‚ãô R‚ÇÇ)\n  invFun Œ≤ :=\n    whiskerRight adj‚ÇÅ.unit (G ‚ãô L‚ÇÇ) ‚â´\n    whiskerRight (whiskerLeft L‚ÇÅ Œ≤) L‚ÇÇ ‚â´\n    whiskerLeft (L‚ÇÅ ‚ãô H) adj‚ÇÇ.counit\n  left_inv Œ± := by\n    ext\n    unfold whiskerRight whiskerLeft\n    simp only [comp_obj, id_obj, Functor.comp_map, comp_app, map_comp, assoc, counit_naturality,\n      counit_naturality_assoc, left_triangle_components_assoc]\n    rw [‚Üê assoc, ‚Üê Functor.comp_map, Œ±.naturality, Functor.comp_map, assoc, ‚Üê H.map_comp,\n      left_triangle_components, map_id]\n    simp only [comp_obj, comp_id]\n  right_inv Œ≤ := by\n    ext\n    unfold whiskerLeft whiskerRight\n    simp only [comp_obj, id_obj, Functor.comp_map, comp_app, map_comp, assoc,\n      unit_naturality_assoc, right_triangle_components_assoc]\n    rw [‚Üê assoc, ‚Üê Functor.comp_map, assoc, ‚Üê Œ≤.naturality, ‚Üê assoc, Functor.comp_map,\n      ‚Üê G.map_comp, right_triangle_components, map_id, id_comp]\n\n"}
{"name":"CategoryTheory.mateEquiv_counit","module":"Mathlib.CategoryTheory.Adjunction.Mates","initialProofState":"C : Type u‚ÇÅ\nD : Type u‚ÇÇ\nE : Type u‚ÇÉ\nF : Type u‚ÇÑ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\ninst‚úù : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} F\nG : CategoryTheory.Functor C E\nH : CategoryTheory.Functor D F\nL‚ÇÅ : CategoryTheory.Functor C D\nR‚ÇÅ : CategoryTheory.Functor D C\nL‚ÇÇ : CategoryTheory.Functor E F\nR‚ÇÇ : CategoryTheory.Functor F E\nadj‚ÇÅ : CategoryTheory.Adjunction L‚ÇÅ R‚ÇÅ\nadj‚ÇÇ : CategoryTheory.Adjunction L‚ÇÇ R‚ÇÇ\nŒ± : Quiver.Hom (G.comp L‚ÇÇ) (L‚ÇÅ.comp H)\nd : D\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (L‚ÇÇ.map (((CategoryTheory.mateEquiv adj‚ÇÅ adj‚ÇÇ) Œ±).app d)) (adj‚ÇÇ.counit.app (H.obj d))) (CategoryTheory.CategoryStruct.comp (Œ±.app (R‚ÇÅ.obj d)) (H.map (adj‚ÇÅ.counit.app d)))","decl":"/-- A component of a transposed version of the mates correspondence. -/\ntheorem mateEquiv_counit (Œ± : G ‚ãô L‚ÇÇ ‚ü∂ L‚ÇÅ ‚ãô H) (d : D) :\n    L‚ÇÇ.map ((mateEquiv adj‚ÇÅ adj‚ÇÇ Œ±).app _) ‚â´ adj‚ÇÇ.counit.app _ =\n      Œ±.app _ ‚â´ H.map (adj‚ÇÅ.counit.app d) := by simp\n\n"}
{"name":"CategoryTheory.mateEquiv_counit_symm","module":"Mathlib.CategoryTheory.Adjunction.Mates","initialProofState":"C : Type u‚ÇÅ\nD : Type u‚ÇÇ\nE : Type u‚ÇÉ\nF : Type u‚ÇÑ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\ninst‚úù : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} F\nG : CategoryTheory.Functor C E\nH : CategoryTheory.Functor D F\nL‚ÇÅ : CategoryTheory.Functor C D\nR‚ÇÅ : CategoryTheory.Functor D C\nL‚ÇÇ : CategoryTheory.Functor E F\nR‚ÇÇ : CategoryTheory.Functor F E\nadj‚ÇÅ : CategoryTheory.Adjunction L‚ÇÅ R‚ÇÅ\nadj‚ÇÇ : CategoryTheory.Adjunction L‚ÇÇ R‚ÇÇ\nŒ± : Quiver.Hom (R‚ÇÅ.comp G) (H.comp R‚ÇÇ)\nd : D\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (L‚ÇÇ.map (Œ±.app d)) (adj‚ÇÇ.counit.app (H.obj d))) (CategoryTheory.CategoryStruct.comp (((CategoryTheory.mateEquiv adj‚ÇÅ adj‚ÇÇ).symm Œ±).app (R‚ÇÅ.obj d)) (H.map (adj‚ÇÅ.counit.app d)))","decl":"/-- A component of a transposed version of the inverse mates correspondence. -/\ntheorem mateEquiv_counit_symm (Œ± : R‚ÇÅ ‚ãô G ‚ü∂ H ‚ãô R‚ÇÇ) (d : D) :\n    L‚ÇÇ.map (Œ±.app _) ‚â´ adj‚ÇÇ.counit.app _ =\n      ((mateEquiv adj‚ÇÅ adj‚ÇÇ).symm Œ±).app _ ‚â´ H.map (adj‚ÇÅ.counit.app d) := by\n  conv_lhs => rw [‚Üê (mateEquiv adj‚ÇÅ adj‚ÇÇ).right_inv Œ±]\n  exact (mateEquiv_counit adj‚ÇÅ adj‚ÇÇ ((mateEquiv adj‚ÇÅ adj‚ÇÇ).symm Œ±) d)\n\n/- A component of a transposed version of the mates correspondence. -/\n"}
{"name":"CategoryTheory.unit_mateEquiv","module":"Mathlib.CategoryTheory.Adjunction.Mates","initialProofState":"C : Type u‚ÇÅ\nD : Type u‚ÇÇ\nE : Type u‚ÇÉ\nF : Type u‚ÇÑ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\ninst‚úù : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} F\nG : CategoryTheory.Functor C E\nH : CategoryTheory.Functor D F\nL‚ÇÅ : CategoryTheory.Functor C D\nR‚ÇÅ : CategoryTheory.Functor D C\nL‚ÇÇ : CategoryTheory.Functor E F\nR‚ÇÇ : CategoryTheory.Functor F E\nadj‚ÇÅ : CategoryTheory.Adjunction L‚ÇÅ R‚ÇÅ\nadj‚ÇÇ : CategoryTheory.Adjunction L‚ÇÇ R‚ÇÇ\nŒ± : Quiver.Hom (G.comp L‚ÇÇ) (L‚ÇÅ.comp H)\nc : C\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (G.map (adj‚ÇÅ.unit.app c)) (((CategoryTheory.mateEquiv adj‚ÇÅ adj‚ÇÇ) Œ±).app (L‚ÇÅ.obj c))) (CategoryTheory.CategoryStruct.comp (adj‚ÇÇ.unit.app (G.obj ((CategoryTheory.Functor.id C).obj c))) (R‚ÇÇ.map (Œ±.app ((CategoryTheory.Functor.id C).obj c))))","decl":"theorem unit_mateEquiv (Œ± : G ‚ãô L‚ÇÇ ‚ü∂ L‚ÇÅ ‚ãô H) (c : C) :\n    G.map (adj‚ÇÅ.unit.app c) ‚â´ (mateEquiv adj‚ÇÅ adj‚ÇÇ Œ±).app _ =\n      adj‚ÇÇ.unit.app _ ‚â´ R‚ÇÇ.map (Œ±.app _) := by\n  dsimp [mateEquiv]\n  rw [‚Üê adj‚ÇÇ.unit_naturality_assoc]\n  slice_lhs 2 3 =>\n    rw [‚Üê R‚ÇÇ.map_comp, ‚Üê Functor.comp_map G L‚ÇÇ, Œ±.naturality]\n  rw [R‚ÇÇ.map_comp]\n  slice_lhs 3 4 =>\n    rw [‚Üê R‚ÇÇ.map_comp, Functor.comp_map L‚ÇÅ H, ‚Üê H.map_comp, left_triangle_components]\n  simp only [comp_obj, map_id, comp_id]\n\n"}
{"name":"CategoryTheory.unit_mateEquiv_symm","module":"Mathlib.CategoryTheory.Adjunction.Mates","initialProofState":"C : Type u‚ÇÅ\nD : Type u‚ÇÇ\nE : Type u‚ÇÉ\nF : Type u‚ÇÑ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\ninst‚úù : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} F\nG : CategoryTheory.Functor C E\nH : CategoryTheory.Functor D F\nL‚ÇÅ : CategoryTheory.Functor C D\nR‚ÇÅ : CategoryTheory.Functor D C\nL‚ÇÇ : CategoryTheory.Functor E F\nR‚ÇÇ : CategoryTheory.Functor F E\nadj‚ÇÅ : CategoryTheory.Adjunction L‚ÇÅ R‚ÇÅ\nadj‚ÇÇ : CategoryTheory.Adjunction L‚ÇÇ R‚ÇÇ\nŒ± : Quiver.Hom (R‚ÇÅ.comp G) (H.comp R‚ÇÇ)\nc : C\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (G.map (adj‚ÇÅ.unit.app c)) (Œ±.app (L‚ÇÅ.obj c))) (CategoryTheory.CategoryStruct.comp (adj‚ÇÇ.unit.app (G.obj ((CategoryTheory.Functor.id C).obj c))) (R‚ÇÇ.map (((CategoryTheory.mateEquiv adj‚ÇÅ adj‚ÇÇ).symm Œ±).app ((CategoryTheory.Functor.id C).obj c))))","decl":"/-- A component of a transposed version of the inverse mates correspondence. -/\ntheorem unit_mateEquiv_symm (Œ± : R‚ÇÅ ‚ãô G ‚ü∂ H ‚ãô R‚ÇÇ) (c : C) :\n    G.map (adj‚ÇÅ.unit.app c) ‚â´ Œ±.app _ =\n      adj‚ÇÇ.unit.app _ ‚â´ R‚ÇÇ.map (((mateEquiv adj‚ÇÅ adj‚ÇÇ).symm Œ±).app _) := by\n  conv_lhs => rw [‚Üê (mateEquiv adj‚ÇÅ adj‚ÇÇ).right_inv Œ±]\n  exact (unit_mateEquiv adj‚ÇÅ adj‚ÇÇ ((mateEquiv adj‚ÇÅ adj‚ÇÇ).symm Œ±) c)\n\n"}
{"name":"CategoryTheory.mateEquiv_vcomp","module":"Mathlib.CategoryTheory.Adjunction.Mates","initialProofState":"A : Type u‚ÇÅ\nB : Type u‚ÇÇ\nC : Type u‚ÇÉ\nD : Type u‚ÇÑ\nE : Type u‚ÇÖ\nF : Type u‚ÇÜ\ninst‚úù‚Åµ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} A\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} B\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} D\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÖ, u‚ÇÖ} E\ninst‚úù : CategoryTheory.Category.{v‚ÇÜ, u‚ÇÜ} F\nG‚ÇÅ : CategoryTheory.Functor A C\nG‚ÇÇ : CategoryTheory.Functor C E\nH‚ÇÅ : CategoryTheory.Functor B D\nH‚ÇÇ : CategoryTheory.Functor D F\nL‚ÇÅ : CategoryTheory.Functor A B\nR‚ÇÅ : CategoryTheory.Functor B A\nL‚ÇÇ : CategoryTheory.Functor C D\nR‚ÇÇ : CategoryTheory.Functor D C\nL‚ÇÉ : CategoryTheory.Functor E F\nR‚ÇÉ : CategoryTheory.Functor F E\nadj‚ÇÅ : CategoryTheory.Adjunction L‚ÇÅ R‚ÇÅ\nadj‚ÇÇ : CategoryTheory.Adjunction L‚ÇÇ R‚ÇÇ\nadj‚ÇÉ : CategoryTheory.Adjunction L‚ÇÉ R‚ÇÉ\nŒ± : Quiver.Hom (G‚ÇÅ.comp L‚ÇÇ) (L‚ÇÅ.comp H‚ÇÅ)\nŒ≤ : Quiver.Hom (G‚ÇÇ.comp L‚ÇÉ) (L‚ÇÇ.comp H‚ÇÇ)\n‚ä¢ Eq ((CategoryTheory.mateEquiv adj‚ÇÅ adj‚ÇÉ) (CategoryTheory.leftAdjointSquare.vcomp Œ± Œ≤)) (CategoryTheory.rightAdjointSquare.vcomp ((CategoryTheory.mateEquiv adj‚ÇÅ adj‚ÇÇ) Œ±) ((CategoryTheory.mateEquiv adj‚ÇÇ adj‚ÇÉ) Œ≤))","decl":"/-- The mates equivalence commutes with vertical composition. -/\ntheorem mateEquiv_vcomp\n    (Œ± : G‚ÇÅ ‚ãô L‚ÇÇ ‚ü∂ L‚ÇÅ ‚ãô H‚ÇÅ) (Œ≤ : G‚ÇÇ ‚ãô L‚ÇÉ ‚ü∂ L‚ÇÇ ‚ãô H‚ÇÇ) :\n    (mateEquiv (G := G‚ÇÅ ‚ãô G‚ÇÇ) (H := H‚ÇÅ ‚ãô H‚ÇÇ) adj‚ÇÅ adj‚ÇÉ) (leftAdjointSquare.vcomp Œ± Œ≤) =\n      rightAdjointSquare.vcomp (mateEquiv adj‚ÇÅ adj‚ÇÇ Œ±) (mateEquiv adj‚ÇÇ adj‚ÇÉ Œ≤) := by\n  unfold leftAdjointSquare.vcomp rightAdjointSquare.vcomp mateEquiv\n  ext b\n  simp only [comp_obj, Equiv.coe_fn_mk, whiskerLeft_comp, whiskerLeft_twice, whiskerRight_comp,\n    assoc, comp_app, whiskerLeft_app, whiskerRight_app, id_obj, Functor.comp_map,\n    whiskerRight_twice]\n  slice_rhs 1 4 => rw [‚Üê assoc, ‚Üê assoc, ‚Üê unit_naturality (adj‚ÇÉ)]\n  rw [L‚ÇÉ.map_comp, R‚ÇÉ.map_comp]\n  slice_rhs 2 4 =>\n    rw [‚Üê R‚ÇÉ.map_comp, ‚Üê R‚ÇÉ.map_comp, ‚Üê assoc, ‚Üê L‚ÇÉ.map_comp, ‚Üê G‚ÇÇ.map_comp, ‚Üê G‚ÇÇ.map_comp]\n    rw [‚Üê Functor.comp_map G‚ÇÇ L‚ÇÉ, Œ≤.naturality]\n  rw [(L‚ÇÇ ‚ãô H‚ÇÇ).map_comp, R‚ÇÉ.map_comp, R‚ÇÉ.map_comp]\n  slice_rhs 4 5 =>\n    rw [‚Üê R‚ÇÉ.map_comp, Functor.comp_map L‚ÇÇ _, ‚Üê Functor.comp_map _ L‚ÇÇ, ‚Üê H‚ÇÇ.map_comp]\n    rw [adj‚ÇÇ.counit.naturality]\n  simp only [comp_obj, Functor.comp_map, map_comp, id_obj, Functor.id_map, assoc]\n  slice_rhs 4 5 =>\n    rw [‚Üê R‚ÇÉ.map_comp, ‚Üê H‚ÇÇ.map_comp, ‚Üê Functor.comp_map _ L‚ÇÇ, adj‚ÇÇ.counit.naturality]\n  simp only [comp_obj, id_obj, Functor.id_map, map_comp, assoc]\n  slice_rhs 3 4 =>\n    rw [‚Üê R‚ÇÉ.map_comp, ‚Üê H‚ÇÇ.map_comp, left_triangle_components]\n  simp only [map_id, id_comp]\n\n"}
{"name":"CategoryTheory.mateEquiv_hcomp","module":"Mathlib.CategoryTheory.Adjunction.Mates","initialProofState":"A : Type u‚ÇÅ\nB : Type u‚ÇÇ\nC : Type u‚ÇÉ\nD : Type u‚ÇÑ\nE : Type u‚ÇÖ\nF : Type u‚ÇÜ\ninst‚úù‚Åµ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} A\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} B\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} D\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÖ, u‚ÇÖ} E\ninst‚úù : CategoryTheory.Category.{v‚ÇÜ, u‚ÇÜ} F\nG : CategoryTheory.Functor A D\nH : CategoryTheory.Functor B E\nK : CategoryTheory.Functor C F\nL‚ÇÅ : CategoryTheory.Functor A B\nR‚ÇÅ : CategoryTheory.Functor B A\nL‚ÇÇ : CategoryTheory.Functor D E\nR‚ÇÇ : CategoryTheory.Functor E D\nL‚ÇÉ : CategoryTheory.Functor B C\nR‚ÇÉ : CategoryTheory.Functor C B\nL‚ÇÑ : CategoryTheory.Functor E F\nR‚ÇÑ : CategoryTheory.Functor F E\nadj‚ÇÅ : CategoryTheory.Adjunction L‚ÇÅ R‚ÇÅ\nadj‚ÇÇ : CategoryTheory.Adjunction L‚ÇÇ R‚ÇÇ\nadj‚ÇÉ : CategoryTheory.Adjunction L‚ÇÉ R‚ÇÉ\nadj‚ÇÑ : CategoryTheory.Adjunction L‚ÇÑ R‚ÇÑ\nŒ± : Quiver.Hom (G.comp L‚ÇÇ) (L‚ÇÅ.comp H)\nŒ≤ : Quiver.Hom (H.comp L‚ÇÑ) (L‚ÇÉ.comp K)\n‚ä¢ Eq ((CategoryTheory.mateEquiv (adj‚ÇÅ.comp adj‚ÇÉ) (adj‚ÇÇ.comp adj‚ÇÑ)) (CategoryTheory.leftAdjointSquare.hcomp Œ± Œ≤)) (CategoryTheory.rightAdjointSquare.hcomp ((CategoryTheory.mateEquiv adj‚ÇÅ adj‚ÇÇ) Œ±) ((CategoryTheory.mateEquiv adj‚ÇÉ adj‚ÇÑ) Œ≤))","decl":"/-- The mates equivalence commutes with horizontal composition of squares. -/\ntheorem mateEquiv_hcomp\n    (Œ± : G ‚ãô L‚ÇÇ ‚ü∂ L‚ÇÅ ‚ãô H) (Œ≤ : H ‚ãô L‚ÇÑ ‚ü∂ L‚ÇÉ ‚ãô K) :\n    (mateEquiv (adj‚ÇÅ.comp adj‚ÇÉ) (adj‚ÇÇ.comp adj‚ÇÑ)) (leftAdjointSquare.hcomp Œ± Œ≤) =\n      rightAdjointSquare.hcomp (mateEquiv adj‚ÇÅ adj‚ÇÇ Œ±) (mateEquiv adj‚ÇÉ adj‚ÇÑ Œ≤) := by\n  unfold leftAdjointSquare.hcomp rightAdjointSquare.hcomp mateEquiv Adjunction.comp\n  ext c\n  dsimp\n  simp only [comp_id, map_comp, id_comp, assoc]\n  slice_rhs 2 4 =>\n    rw [‚Üê R‚ÇÇ.map_comp, ‚Üê R‚ÇÇ.map_comp, ‚Üê assoc, ‚Üê unit_naturality (adj‚ÇÑ)]\n  rw [R‚ÇÇ.map_comp, L‚ÇÑ.map_comp, R‚ÇÑ.map_comp, R‚ÇÇ.map_comp]\n  slice_rhs 4 5 =>\n    rw [‚Üê R‚ÇÇ.map_comp, ‚Üê R‚ÇÑ.map_comp, ‚Üê Functor.comp_map _ L‚ÇÑ , Œ≤.naturality]\n  simp only [comp_obj, Functor.comp_map, map_comp, assoc]\n\n"}
{"name":"CategoryTheory.leftAdjointSquare.comp_vhcomp","module":"Mathlib.CategoryTheory.Adjunction.Mates","initialProofState":"A : Type u‚ÇÅ\nB : Type u‚ÇÇ\nC : Type u‚ÇÉ\nD : Type u‚ÇÑ\nE : Type u‚ÇÖ\nF : Type u‚ÇÜ\nX : Type u‚Çá\nY : Type u‚Çà\nZ : Type u‚Çâ\ninst‚úù‚Å∏ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} A\ninst‚úù‚Å∑ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} B\ninst‚úù‚Å∂ : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\ninst‚úù‚Åµ : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} D\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÖ, u‚ÇÖ} E\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÜ, u‚ÇÜ} F\ninst‚úù¬≤ : CategoryTheory.Category.{v‚Çá, u‚Çá} X\ninst‚úù¬π : CategoryTheory.Category.{v‚Çà, u‚Çà} Y\ninst‚úù : CategoryTheory.Category.{v‚Çâ, u‚Çâ} Z\nG‚ÇÅ : CategoryTheory.Functor A D\nH‚ÇÅ : CategoryTheory.Functor B E\nK‚ÇÅ : CategoryTheory.Functor C F\nG‚ÇÇ : CategoryTheory.Functor D X\nH‚ÇÇ : CategoryTheory.Functor E Y\nK‚ÇÇ : CategoryTheory.Functor F Z\nL‚ÇÅ : CategoryTheory.Functor A B\nL‚ÇÇ : CategoryTheory.Functor B C\nL‚ÇÉ : CategoryTheory.Functor D E\nL‚ÇÑ : CategoryTheory.Functor E F\nL‚ÇÖ : CategoryTheory.Functor X Y\nL‚ÇÜ : CategoryTheory.Functor Y Z\nŒ± : Quiver.Hom (G‚ÇÅ.comp L‚ÇÉ) (L‚ÇÅ.comp H‚ÇÅ)\nŒ≤ : Quiver.Hom (H‚ÇÅ.comp L‚ÇÑ) (L‚ÇÇ.comp K‚ÇÅ)\nŒ≥ : Quiver.Hom (G‚ÇÇ.comp L‚ÇÖ) (L‚ÇÉ.comp H‚ÇÇ)\nŒ¥ : Quiver.Hom (H‚ÇÇ.comp L‚ÇÜ) (L‚ÇÑ.comp K‚ÇÇ)\n‚ä¢ Eq (CategoryTheory.leftAdjointSquare.comp Œ± Œ≤ Œ≥ Œ¥) (CategoryTheory.leftAdjointSquare.vcomp (CategoryTheory.leftAdjointSquare.hcomp Œ± Œ≤) (CategoryTheory.leftAdjointSquare.hcomp Œ≥ Œ¥))","decl":"theorem leftAdjointSquare.comp_vhcomp\n    (Œ± : G‚ÇÅ ‚ãô L‚ÇÉ ‚ü∂ L‚ÇÅ ‚ãô H‚ÇÅ) (Œ≤ : H‚ÇÅ ‚ãô L‚ÇÑ ‚ü∂ L‚ÇÇ ‚ãô K‚ÇÅ)\n    (Œ≥ : G‚ÇÇ ‚ãô L‚ÇÖ ‚ü∂ L‚ÇÉ ‚ãô H‚ÇÇ) (Œ¥ : H‚ÇÇ ‚ãô L‚ÇÜ ‚ü∂ L‚ÇÑ ‚ãô K‚ÇÇ) :\n    leftAdjointSquare.comp Œ± Œ≤ Œ≥ Œ¥ =\n      leftAdjointSquare.vcomp (leftAdjointSquare.hcomp Œ± Œ≤) (leftAdjointSquare.hcomp Œ≥ Œ¥) := rfl\n\n"}
{"name":"CategoryTheory.leftAdjointSquare.comp_hvcomp","module":"Mathlib.CategoryTheory.Adjunction.Mates","initialProofState":"A : Type u‚ÇÅ\nB : Type u‚ÇÇ\nC : Type u‚ÇÉ\nD : Type u‚ÇÑ\nE : Type u‚ÇÖ\nF : Type u‚ÇÜ\nX : Type u‚Çá\nY : Type u‚Çà\nZ : Type u‚Çâ\ninst‚úù‚Å∏ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} A\ninst‚úù‚Å∑ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} B\ninst‚úù‚Å∂ : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\ninst‚úù‚Åµ : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} D\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÖ, u‚ÇÖ} E\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÜ, u‚ÇÜ} F\ninst‚úù¬≤ : CategoryTheory.Category.{v‚Çá, u‚Çá} X\ninst‚úù¬π : CategoryTheory.Category.{v‚Çà, u‚Çà} Y\ninst‚úù : CategoryTheory.Category.{v‚Çâ, u‚Çâ} Z\nG‚ÇÅ : CategoryTheory.Functor A D\nH‚ÇÅ : CategoryTheory.Functor B E\nK‚ÇÅ : CategoryTheory.Functor C F\nG‚ÇÇ : CategoryTheory.Functor D X\nH‚ÇÇ : CategoryTheory.Functor E Y\nK‚ÇÇ : CategoryTheory.Functor F Z\nL‚ÇÅ : CategoryTheory.Functor A B\nL‚ÇÇ : CategoryTheory.Functor B C\nL‚ÇÉ : CategoryTheory.Functor D E\nL‚ÇÑ : CategoryTheory.Functor E F\nL‚ÇÖ : CategoryTheory.Functor X Y\nL‚ÇÜ : CategoryTheory.Functor Y Z\nŒ± : Quiver.Hom (G‚ÇÅ.comp L‚ÇÉ) (L‚ÇÅ.comp H‚ÇÅ)\nŒ≤ : Quiver.Hom (H‚ÇÅ.comp L‚ÇÑ) (L‚ÇÇ.comp K‚ÇÅ)\nŒ≥ : Quiver.Hom (G‚ÇÇ.comp L‚ÇÖ) (L‚ÇÉ.comp H‚ÇÇ)\nŒ¥ : Quiver.Hom (H‚ÇÇ.comp L‚ÇÜ) (L‚ÇÑ.comp K‚ÇÇ)\n‚ä¢ Eq (CategoryTheory.leftAdjointSquare.comp Œ± Œ≤ Œ≥ Œ¥) (CategoryTheory.leftAdjointSquare.hcomp (CategoryTheory.leftAdjointSquare.vcomp Œ± Œ≥) (CategoryTheory.leftAdjointSquare.vcomp Œ≤ Œ¥))","decl":"/-- Horizontal and vertical composition of squares commutes.-/\ntheorem leftAdjointSquare.comp_hvcomp\n    (Œ± : G‚ÇÅ ‚ãô L‚ÇÉ ‚ü∂ L‚ÇÅ ‚ãô H‚ÇÅ) (Œ≤ : H‚ÇÅ ‚ãô L‚ÇÑ ‚ü∂ L‚ÇÇ ‚ãô K‚ÇÅ)\n    (Œ≥ : G‚ÇÇ ‚ãô L‚ÇÖ ‚ü∂ L‚ÇÉ ‚ãô H‚ÇÇ) (Œ¥ : H‚ÇÇ ‚ãô L‚ÇÜ ‚ü∂ L‚ÇÑ ‚ãô K‚ÇÇ) :\n    leftAdjointSquare.comp Œ± Œ≤ Œ≥ Œ¥ =\n      leftAdjointSquare.hcomp (leftAdjointSquare.vcomp Œ± Œ≥) (leftAdjointSquare.vcomp Œ≤ Œ¥) := by\n  unfold leftAdjointSquare.comp leftAdjointSquare.hcomp leftAdjointSquare.vcomp\n  unfold whiskerLeft whiskerRight\n  ext a\n  simp only [comp_obj, comp_app, map_comp, assoc]\n  slice_rhs 2 3 =>\n    rw [‚Üê Functor.comp_map _ L‚ÇÜ, Œ¥.naturality]\n  simp only [comp_obj, Functor.comp_map, assoc]\n\n"}
{"name":"CategoryTheory.rightAdjointSquare.comp_vhcomp","module":"Mathlib.CategoryTheory.Adjunction.Mates","initialProofState":"A : Type u‚ÇÅ\nB : Type u‚ÇÇ\nC : Type u‚ÇÉ\nD : Type u‚ÇÑ\nE : Type u‚ÇÖ\nF : Type u‚ÇÜ\nX : Type u‚Çá\nY : Type u‚Çà\nZ : Type u‚Çâ\ninst‚úù‚Å∏ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} A\ninst‚úù‚Å∑ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} B\ninst‚úù‚Å∂ : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\ninst‚úù‚Åµ : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} D\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÖ, u‚ÇÖ} E\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÜ, u‚ÇÜ} F\ninst‚úù¬≤ : CategoryTheory.Category.{v‚Çá, u‚Çá} X\ninst‚úù¬π : CategoryTheory.Category.{v‚Çà, u‚Çà} Y\ninst‚úù : CategoryTheory.Category.{v‚Çâ, u‚Çâ} Z\nG‚ÇÅ : CategoryTheory.Functor A D\nH‚ÇÅ : CategoryTheory.Functor B E\nK‚ÇÅ : CategoryTheory.Functor C F\nG‚ÇÇ : CategoryTheory.Functor D X\nH‚ÇÇ : CategoryTheory.Functor E Y\nK‚ÇÇ : CategoryTheory.Functor F Z\nR‚ÇÅ : CategoryTheory.Functor B A\nR‚ÇÇ : CategoryTheory.Functor C B\nR‚ÇÉ : CategoryTheory.Functor E D\nR‚ÇÑ : CategoryTheory.Functor F E\nR‚ÇÖ : CategoryTheory.Functor Y X\nR‚ÇÜ : CategoryTheory.Functor Z Y\nŒ± : Quiver.Hom (R‚ÇÅ.comp G‚ÇÅ) (H‚ÇÅ.comp R‚ÇÉ)\nŒ≤ : Quiver.Hom (R‚ÇÇ.comp H‚ÇÅ) (K‚ÇÅ.comp R‚ÇÑ)\nŒ≥ : Quiver.Hom (R‚ÇÉ.comp G‚ÇÇ) (H‚ÇÇ.comp R‚ÇÖ)\nŒ¥ : Quiver.Hom (R‚ÇÑ.comp H‚ÇÇ) (K‚ÇÇ.comp R‚ÇÜ)\n‚ä¢ Eq (CategoryTheory.rightAdjointSquare.comp Œ± Œ≤ Œ≥ Œ¥) (CategoryTheory.rightAdjointSquare.vcomp (CategoryTheory.rightAdjointSquare.hcomp Œ± Œ≤) (CategoryTheory.rightAdjointSquare.hcomp Œ≥ Œ¥))","decl":"theorem rightAdjointSquare.comp_vhcomp\n    (Œ± : R‚ÇÅ ‚ãô G‚ÇÅ ‚ü∂ H‚ÇÅ ‚ãô R‚ÇÉ) (Œ≤ : R‚ÇÇ ‚ãô H‚ÇÅ ‚ü∂ K‚ÇÅ ‚ãô R‚ÇÑ)\n    (Œ≥ : R‚ÇÉ ‚ãô G‚ÇÇ ‚ü∂ H‚ÇÇ ‚ãô R‚ÇÖ) (Œ¥ : R‚ÇÑ ‚ãô H‚ÇÇ ‚ü∂ K‚ÇÇ ‚ãô R‚ÇÜ) :\n    rightAdjointSquare.comp Œ± Œ≤ Œ≥ Œ¥ =\n    rightAdjointSquare.vcomp (rightAdjointSquare.hcomp Œ± Œ≤) (rightAdjointSquare.hcomp Œ≥ Œ¥) := rfl\n\n"}
{"name":"CategoryTheory.rightAdjointSquare.comp_hvcomp","module":"Mathlib.CategoryTheory.Adjunction.Mates","initialProofState":"A : Type u‚ÇÅ\nB : Type u‚ÇÇ\nC : Type u‚ÇÉ\nD : Type u‚ÇÑ\nE : Type u‚ÇÖ\nF : Type u‚ÇÜ\nX : Type u‚Çá\nY : Type u‚Çà\nZ : Type u‚Çâ\ninst‚úù‚Å∏ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} A\ninst‚úù‚Å∑ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} B\ninst‚úù‚Å∂ : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\ninst‚úù‚Åµ : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} D\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÖ, u‚ÇÖ} E\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÜ, u‚ÇÜ} F\ninst‚úù¬≤ : CategoryTheory.Category.{v‚Çá, u‚Çá} X\ninst‚úù¬π : CategoryTheory.Category.{v‚Çà, u‚Çà} Y\ninst‚úù : CategoryTheory.Category.{v‚Çâ, u‚Çâ} Z\nG‚ÇÅ : CategoryTheory.Functor A D\nH‚ÇÅ : CategoryTheory.Functor B E\nK‚ÇÅ : CategoryTheory.Functor C F\nG‚ÇÇ : CategoryTheory.Functor D X\nH‚ÇÇ : CategoryTheory.Functor E Y\nK‚ÇÇ : CategoryTheory.Functor F Z\nR‚ÇÅ : CategoryTheory.Functor B A\nR‚ÇÇ : CategoryTheory.Functor C B\nR‚ÇÉ : CategoryTheory.Functor E D\nR‚ÇÑ : CategoryTheory.Functor F E\nR‚ÇÖ : CategoryTheory.Functor Y X\nR‚ÇÜ : CategoryTheory.Functor Z Y\nŒ± : Quiver.Hom (R‚ÇÅ.comp G‚ÇÅ) (H‚ÇÅ.comp R‚ÇÉ)\nŒ≤ : Quiver.Hom (R‚ÇÇ.comp H‚ÇÅ) (K‚ÇÅ.comp R‚ÇÑ)\nŒ≥ : Quiver.Hom (R‚ÇÉ.comp G‚ÇÇ) (H‚ÇÇ.comp R‚ÇÖ)\nŒ¥ : Quiver.Hom (R‚ÇÑ.comp H‚ÇÇ) (K‚ÇÇ.comp R‚ÇÜ)\n‚ä¢ Eq (CategoryTheory.rightAdjointSquare.comp Œ± Œ≤ Œ≥ Œ¥) (CategoryTheory.rightAdjointSquare.hcomp (CategoryTheory.rightAdjointSquare.vcomp Œ± Œ≥) (CategoryTheory.rightAdjointSquare.vcomp Œ≤ Œ¥))","decl":"/-- Horizontal and vertical composition of squares commutes.-/\ntheorem rightAdjointSquare.comp_hvcomp\n    (Œ± : R‚ÇÅ ‚ãô G‚ÇÅ ‚ü∂ H‚ÇÅ ‚ãô R‚ÇÉ) (Œ≤ : R‚ÇÇ ‚ãô H‚ÇÅ ‚ü∂ K‚ÇÅ ‚ãô R‚ÇÑ)\n    (Œ≥ : R‚ÇÉ ‚ãô G‚ÇÇ ‚ü∂ H‚ÇÇ ‚ãô R‚ÇÖ) (Œ¥ : R‚ÇÑ ‚ãô H‚ÇÇ ‚ü∂ K‚ÇÇ ‚ãô R‚ÇÜ) :\n    rightAdjointSquare.comp Œ± Œ≤ Œ≥ Œ¥ =\n    rightAdjointSquare.hcomp (rightAdjointSquare.vcomp Œ± Œ≥) (rightAdjointSquare.vcomp Œ≤ Œ¥) := by\n  unfold rightAdjointSquare.comp rightAdjointSquare.hcomp rightAdjointSquare.vcomp\n  unfold whiskerLeft whiskerRight\n  ext c\n  simp only [comp_obj, comp_app, map_comp, assoc]\n  slice_rhs 2 3 =>\n    rw [‚Üê Functor.comp_map _ R‚ÇÖ, ‚Üê Œ≥.naturality]\n  simp only [comp_obj, Functor.comp_map, assoc]\n\n"}
{"name":"CategoryTheory.mateEquiv_square","module":"Mathlib.CategoryTheory.Adjunction.Mates","initialProofState":"A : Type u‚ÇÅ\nB : Type u‚ÇÇ\nC : Type u‚ÇÉ\nD : Type u‚ÇÑ\nE : Type u‚ÇÖ\nF : Type u‚ÇÜ\nX : Type u‚Çá\nY : Type u‚Çà\nZ : Type u‚Çâ\ninst‚úù‚Å∏ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} A\ninst‚úù‚Å∑ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} B\ninst‚úù‚Å∂ : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\ninst‚úù‚Åµ : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} D\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÖ, u‚ÇÖ} E\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÜ, u‚ÇÜ} F\ninst‚úù¬≤ : CategoryTheory.Category.{v‚Çá, u‚Çá} X\ninst‚úù¬π : CategoryTheory.Category.{v‚Çà, u‚Çà} Y\ninst‚úù : CategoryTheory.Category.{v‚Çâ, u‚Çâ} Z\nG‚ÇÅ : CategoryTheory.Functor A D\nH‚ÇÅ : CategoryTheory.Functor B E\nK‚ÇÅ : CategoryTheory.Functor C F\nG‚ÇÇ : CategoryTheory.Functor D X\nH‚ÇÇ : CategoryTheory.Functor E Y\nK‚ÇÇ : CategoryTheory.Functor F Z\nL‚ÇÅ : CategoryTheory.Functor A B\nR‚ÇÅ : CategoryTheory.Functor B A\nL‚ÇÇ : CategoryTheory.Functor B C\nR‚ÇÇ : CategoryTheory.Functor C B\nL‚ÇÉ : CategoryTheory.Functor D E\nR‚ÇÉ : CategoryTheory.Functor E D\nL‚ÇÑ : CategoryTheory.Functor E F\nR‚ÇÑ : CategoryTheory.Functor F E\nL‚ÇÖ : CategoryTheory.Functor X Y\nR‚ÇÖ : CategoryTheory.Functor Y X\nL‚ÇÜ : CategoryTheory.Functor Y Z\nR‚ÇÜ : CategoryTheory.Functor Z Y\nadj‚ÇÅ : CategoryTheory.Adjunction L‚ÇÅ R‚ÇÅ\nadj‚ÇÇ : CategoryTheory.Adjunction L‚ÇÇ R‚ÇÇ\nadj‚ÇÉ : CategoryTheory.Adjunction L‚ÇÉ R‚ÇÉ\nadj‚ÇÑ : CategoryTheory.Adjunction L‚ÇÑ R‚ÇÑ\nadj‚ÇÖ : CategoryTheory.Adjunction L‚ÇÖ R‚ÇÖ\nadj‚ÇÜ : CategoryTheory.Adjunction L‚ÇÜ R‚ÇÜ\nŒ± : Quiver.Hom (G‚ÇÅ.comp L‚ÇÉ) (L‚ÇÅ.comp H‚ÇÅ)\nŒ≤ : Quiver.Hom (H‚ÇÅ.comp L‚ÇÑ) (L‚ÇÇ.comp K‚ÇÅ)\nŒ≥ : Quiver.Hom (G‚ÇÇ.comp L‚ÇÖ) (L‚ÇÉ.comp H‚ÇÇ)\nŒ¥ : Quiver.Hom (H‚ÇÇ.comp L‚ÇÜ) (L‚ÇÑ.comp K‚ÇÇ)\n‚ä¢ Eq ((CategoryTheory.mateEquiv (adj‚ÇÅ.comp adj‚ÇÇ) (adj‚ÇÖ.comp adj‚ÇÜ)) (CategoryTheory.leftAdjointSquare.comp Œ± Œ≤ Œ≥ Œ¥)) (CategoryTheory.rightAdjointSquare.comp ((CategoryTheory.mateEquiv adj‚ÇÅ adj‚ÇÉ) Œ±) ((CategoryTheory.mateEquiv adj‚ÇÇ adj‚ÇÑ) Œ≤) ((CategoryTheory.mateEquiv adj‚ÇÉ adj‚ÇÖ) Œ≥) ((CategoryTheory.mateEquiv adj‚ÇÑ adj‚ÇÜ) Œ¥))","decl":"/-- The mates equivalence commutes with composition of squares of squares. These results form the\nbasis for an isomorphism of double categories to be proven later.\n-/\ntheorem mateEquiv_square\n    (Œ± : G‚ÇÅ ‚ãô L‚ÇÉ ‚ü∂ L‚ÇÅ ‚ãô H‚ÇÅ) (Œ≤ : H‚ÇÅ ‚ãô L‚ÇÑ ‚ü∂ L‚ÇÇ ‚ãô K‚ÇÅ)\n    (Œ≥ : G‚ÇÇ ‚ãô L‚ÇÖ ‚ü∂ L‚ÇÉ ‚ãô H‚ÇÇ) (Œ¥ : H‚ÇÇ ‚ãô L‚ÇÜ ‚ü∂ L‚ÇÑ ‚ãô K‚ÇÇ) :\n    (mateEquiv (G := G‚ÇÅ ‚ãô G‚ÇÇ) (H := K‚ÇÅ ‚ãô K‚ÇÇ) (adj‚ÇÅ.comp adj‚ÇÇ) (adj‚ÇÖ.comp adj‚ÇÜ))\n        (leftAdjointSquare.comp Œ± Œ≤ Œ≥ Œ¥) =\n      rightAdjointSquare.comp\n        (mateEquiv adj‚ÇÅ adj‚ÇÉ Œ±) (mateEquiv adj‚ÇÇ adj‚ÇÑ Œ≤)\n        (mateEquiv adj‚ÇÉ adj‚ÇÖ Œ≥) (mateEquiv adj‚ÇÑ adj‚ÇÜ Œ¥) := by\n  have vcomp :=\n    mateEquiv_vcomp (adj‚ÇÅ.comp adj‚ÇÇ) (adj‚ÇÉ.comp adj‚ÇÑ) (adj‚ÇÖ.comp adj‚ÇÜ)\n      (leftAdjointSquare.hcomp Œ± Œ≤) (leftAdjointSquare.hcomp Œ≥ Œ¥)\n  have hcomp1 := mateEquiv_hcomp adj‚ÇÅ adj‚ÇÉ adj‚ÇÇ adj‚ÇÑ Œ± Œ≤\n  have hcomp2 := mateEquiv_hcomp adj‚ÇÉ adj‚ÇÖ adj‚ÇÑ adj‚ÇÜ Œ≥ Œ¥\n  rw [hcomp1, hcomp2] at vcomp\n  exact vcomp\n\n"}
{"name":"CategoryTheory.conjugateEquiv_symm_apply_app","module":"Mathlib.CategoryTheory.Adjunction.Mates","initialProofState":"C : Type u‚ÇÅ\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nL‚ÇÅ L‚ÇÇ : CategoryTheory.Functor C D\nR‚ÇÅ R‚ÇÇ : CategoryTheory.Functor D C\nadj‚ÇÅ : CategoryTheory.Adjunction L‚ÇÅ R‚ÇÅ\nadj‚ÇÇ : CategoryTheory.Adjunction L‚ÇÇ R‚ÇÇ\na‚úù : Quiver.Hom R‚ÇÅ R‚ÇÇ\nX : C\n‚ä¢ Eq (((CategoryTheory.conjugateEquiv adj‚ÇÅ adj‚ÇÇ).symm a‚úù).app X) (CategoryTheory.CategoryStruct.comp (L‚ÇÇ.map (adj‚ÇÅ.unit.app X)) (CategoryTheory.CategoryStruct.comp (L‚ÇÇ.map (a‚úù.app (L‚ÇÅ.obj X))) (adj‚ÇÇ.counit.app (L‚ÇÅ.obj X))))","decl":"/-- Given two adjunctions `L‚ÇÅ ‚ä£ R‚ÇÅ` and `L‚ÇÇ ‚ä£ R‚ÇÇ` both between categories `C`, `D`, there is a\nbijection between natural transformations `L‚ÇÇ ‚ü∂ L‚ÇÅ` and natural transformations `R‚ÇÅ ‚ü∂ R‚ÇÇ`. This is\ndefined as a special case of `mateEquiv`, where the two \"vertical\" functors are identity, modulo\ncomposition with the unitors. Corresponding natural transformations are called `conjugateEquiv`.\nTODO: Generalise to when the two vertical functors are equivalences rather than being exactly `ùü≠`.\n\nFurthermore, this bijection preserves (and reflects) isomorphisms, i.e. a transformation is an iso\niff its image under the bijection is an iso, see eg `CategoryTheory.conjugateIsoEquiv`.\nThis is in contrast to the general case `mateEquiv` which does not in general have this property.\n-/\n@[simps!]\ndef conjugateEquiv : (L‚ÇÇ ‚ü∂ L‚ÇÅ) ‚âÉ (R‚ÇÅ ‚ü∂ R‚ÇÇ) :=\n  calc\n    (L‚ÇÇ ‚ü∂ L‚ÇÅ) ‚âÉ _ := (Iso.homCongr L‚ÇÇ.leftUnitor L‚ÇÅ.rightUnitor).symm\n    _ ‚âÉ _ := mateEquiv adj‚ÇÅ adj‚ÇÇ\n    _ ‚âÉ (R‚ÇÅ ‚ü∂ R‚ÇÇ) := R‚ÇÅ.rightUnitor.homCongr R‚ÇÇ.leftUnitor\n\n"}
{"name":"CategoryTheory.conjugateEquiv_apply_app","module":"Mathlib.CategoryTheory.Adjunction.Mates","initialProofState":"C : Type u‚ÇÅ\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nL‚ÇÅ L‚ÇÇ : CategoryTheory.Functor C D\nR‚ÇÅ R‚ÇÇ : CategoryTheory.Functor D C\nadj‚ÇÅ : CategoryTheory.Adjunction L‚ÇÅ R‚ÇÅ\nadj‚ÇÇ : CategoryTheory.Adjunction L‚ÇÇ R‚ÇÇ\na‚úù : Quiver.Hom L‚ÇÇ L‚ÇÅ\nX : D\n‚ä¢ Eq (((CategoryTheory.conjugateEquiv adj‚ÇÅ adj‚ÇÇ) a‚úù).app X) (CategoryTheory.CategoryStruct.comp (adj‚ÇÇ.unit.app (R‚ÇÅ.obj X)) (CategoryTheory.CategoryStruct.comp (R‚ÇÇ.map (a‚úù.app (R‚ÇÅ.obj X))) (R‚ÇÇ.map (adj‚ÇÅ.counit.app X))))","decl":"/-- Given two adjunctions `L‚ÇÅ ‚ä£ R‚ÇÅ` and `L‚ÇÇ ‚ä£ R‚ÇÇ` both between categories `C`, `D`, there is a\nbijection between natural transformations `L‚ÇÇ ‚ü∂ L‚ÇÅ` and natural transformations `R‚ÇÅ ‚ü∂ R‚ÇÇ`. This is\ndefined as a special case of `mateEquiv`, where the two \"vertical\" functors are identity, modulo\ncomposition with the unitors. Corresponding natural transformations are called `conjugateEquiv`.\nTODO: Generalise to when the two vertical functors are equivalences rather than being exactly `ùü≠`.\n\nFurthermore, this bijection preserves (and reflects) isomorphisms, i.e. a transformation is an iso\niff its image under the bijection is an iso, see eg `CategoryTheory.conjugateIsoEquiv`.\nThis is in contrast to the general case `mateEquiv` which does not in general have this property.\n-/\n@[simps!]\ndef conjugateEquiv : (L‚ÇÇ ‚ü∂ L‚ÇÅ) ‚âÉ (R‚ÇÅ ‚ü∂ R‚ÇÇ) :=\n  calc\n    (L‚ÇÇ ‚ü∂ L‚ÇÅ) ‚âÉ _ := (Iso.homCongr L‚ÇÇ.leftUnitor L‚ÇÅ.rightUnitor).symm\n    _ ‚âÉ _ := mateEquiv adj‚ÇÅ adj‚ÇÇ\n    _ ‚âÉ (R‚ÇÅ ‚ü∂ R‚ÇÇ) := R‚ÇÅ.rightUnitor.homCongr R‚ÇÇ.leftUnitor\n\n"}
{"name":"CategoryTheory.conjugateEquiv_counit","module":"Mathlib.CategoryTheory.Adjunction.Mates","initialProofState":"C : Type u‚ÇÅ\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nL‚ÇÅ L‚ÇÇ : CategoryTheory.Functor C D\nR‚ÇÅ R‚ÇÇ : CategoryTheory.Functor D C\nadj‚ÇÅ : CategoryTheory.Adjunction L‚ÇÅ R‚ÇÅ\nadj‚ÇÇ : CategoryTheory.Adjunction L‚ÇÇ R‚ÇÇ\nŒ± : Quiver.Hom L‚ÇÇ L‚ÇÅ\nd : D\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (L‚ÇÇ.map (((CategoryTheory.conjugateEquiv adj‚ÇÅ adj‚ÇÇ) Œ±).app d)) (adj‚ÇÇ.counit.app d)) (CategoryTheory.CategoryStruct.comp (Œ±.app (R‚ÇÅ.obj d)) (adj‚ÇÅ.counit.app d))","decl":"/-- A component of a transposed form of the conjugation definition. -/\ntheorem conjugateEquiv_counit (Œ± : L‚ÇÇ ‚ü∂ L‚ÇÅ) (d : D) :\n    L‚ÇÇ.map ((conjugateEquiv adj‚ÇÅ adj‚ÇÇ Œ±).app _) ‚â´ adj‚ÇÇ.counit.app d =\n      Œ±.app _ ‚â´ adj‚ÇÅ.counit.app d := by\n  dsimp [conjugateEquiv]\n  rw [id_comp, comp_id]\n  have := mateEquiv_counit adj‚ÇÅ adj‚ÇÇ (L‚ÇÇ.leftUnitor.hom ‚â´ Œ± ‚â´ L‚ÇÅ.rightUnitor.inv) d\n  dsimp at this\n  rw [this]\n  simp only [comp_id, id_comp]\n\n"}
{"name":"CategoryTheory.conjugateEquiv_counit_symm","module":"Mathlib.CategoryTheory.Adjunction.Mates","initialProofState":"C : Type u‚ÇÅ\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nL‚ÇÅ L‚ÇÇ : CategoryTheory.Functor C D\nR‚ÇÅ R‚ÇÇ : CategoryTheory.Functor D C\nadj‚ÇÅ : CategoryTheory.Adjunction L‚ÇÅ R‚ÇÅ\nadj‚ÇÇ : CategoryTheory.Adjunction L‚ÇÇ R‚ÇÇ\nŒ± : Quiver.Hom R‚ÇÅ R‚ÇÇ\nd : D\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (L‚ÇÇ.map (Œ±.app d)) (adj‚ÇÇ.counit.app d)) (CategoryTheory.CategoryStruct.comp (((CategoryTheory.conjugateEquiv adj‚ÇÅ adj‚ÇÇ).symm Œ±).app (R‚ÇÅ.obj d)) (adj‚ÇÅ.counit.app d))","decl":"/-- A component of a transposed form of the inverse conjugation definition. -/\ntheorem conjugateEquiv_counit_symm (Œ± : R‚ÇÅ ‚ü∂ R‚ÇÇ) (d : D) :\n    L‚ÇÇ.map (Œ±.app _) ‚â´ adj‚ÇÇ.counit.app d =\n      ((conjugateEquiv adj‚ÇÅ adj‚ÇÇ).symm Œ±).app _ ‚â´ adj‚ÇÅ.counit.app d := by\n    conv_lhs => rw [‚Üê (conjugateEquiv adj‚ÇÅ adj‚ÇÇ).right_inv Œ±]\n    exact (conjugateEquiv_counit adj‚ÇÅ adj‚ÇÇ ((conjugateEquiv adj‚ÇÅ adj‚ÇÇ).symm Œ±) d)\n\n"}
{"name":"CategoryTheory.unit_conjugateEquiv","module":"Mathlib.CategoryTheory.Adjunction.Mates","initialProofState":"C : Type u‚ÇÅ\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nL‚ÇÅ L‚ÇÇ : CategoryTheory.Functor C D\nR‚ÇÅ R‚ÇÇ : CategoryTheory.Functor D C\nadj‚ÇÅ : CategoryTheory.Adjunction L‚ÇÅ R‚ÇÅ\nadj‚ÇÇ : CategoryTheory.Adjunction L‚ÇÇ R‚ÇÇ\nŒ± : Quiver.Hom L‚ÇÇ L‚ÇÅ\nc : C\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (adj‚ÇÅ.unit.app c) (((CategoryTheory.conjugateEquiv adj‚ÇÅ adj‚ÇÇ) Œ±).app (L‚ÇÅ.obj c))) (CategoryTheory.CategoryStruct.comp (adj‚ÇÇ.unit.app c) (R‚ÇÇ.map (Œ±.app c)))","decl":"/-- A component of a transposed form of the conjugation definition. -/\ntheorem unit_conjugateEquiv (Œ± : L‚ÇÇ ‚ü∂ L‚ÇÅ) (c : C) :\n    adj‚ÇÅ.unit.app _ ‚â´ (conjugateEquiv adj‚ÇÅ adj‚ÇÇ Œ±).app _ =\n      adj‚ÇÇ.unit.app c ‚â´ R‚ÇÇ.map (Œ±.app _) := by\n  dsimp [conjugateEquiv]\n  rw [id_comp, comp_id]\n  have := unit_mateEquiv adj‚ÇÅ adj‚ÇÇ (L‚ÇÇ.leftUnitor.hom ‚â´ Œ± ‚â´ L‚ÇÅ.rightUnitor.inv) c\n  dsimp at this\n  rw [this]\n  simp\n\n"}
{"name":"CategoryTheory.unit_conjugateEquiv_symm","module":"Mathlib.CategoryTheory.Adjunction.Mates","initialProofState":"C : Type u‚ÇÅ\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nL‚ÇÅ L‚ÇÇ : CategoryTheory.Functor C D\nR‚ÇÅ R‚ÇÇ : CategoryTheory.Functor D C\nadj‚ÇÅ : CategoryTheory.Adjunction L‚ÇÅ R‚ÇÅ\nadj‚ÇÇ : CategoryTheory.Adjunction L‚ÇÇ R‚ÇÇ\nŒ± : Quiver.Hom R‚ÇÅ R‚ÇÇ\nc : C\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (adj‚ÇÅ.unit.app c) (Œ±.app (L‚ÇÅ.obj c))) (CategoryTheory.CategoryStruct.comp (adj‚ÇÇ.unit.app c) (R‚ÇÇ.map (((CategoryTheory.conjugateEquiv adj‚ÇÅ adj‚ÇÇ).symm Œ±).app c)))","decl":"/-- A component of a transposed form of the inverse conjugation definition. -/\ntheorem unit_conjugateEquiv_symm (Œ± : R‚ÇÅ ‚ü∂ R‚ÇÇ) (c : C) :\n    adj‚ÇÅ.unit.app _ ‚â´ Œ±.app _ =\n      adj‚ÇÇ.unit.app c ‚â´ R‚ÇÇ.map (((conjugateEquiv adj‚ÇÅ adj‚ÇÇ).symm Œ±).app _) := by\n    conv_lhs => rw [‚Üê (conjugateEquiv adj‚ÇÅ adj‚ÇÇ).right_inv Œ±]\n    exact (unit_conjugateEquiv adj‚ÇÅ adj‚ÇÇ ((conjugateEquiv adj‚ÇÅ adj‚ÇÇ).symm Œ±) c)\n\n"}
{"name":"CategoryTheory.conjugateEquiv_id","module":"Mathlib.CategoryTheory.Adjunction.Mates","initialProofState":"C : Type u‚ÇÅ\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nL‚ÇÅ : CategoryTheory.Functor C D\nR‚ÇÅ : CategoryTheory.Functor D C\nadj‚ÇÅ : CategoryTheory.Adjunction L‚ÇÅ R‚ÇÅ\n‚ä¢ Eq ((CategoryTheory.conjugateEquiv adj‚ÇÅ adj‚ÇÅ) (CategoryTheory.CategoryStruct.id L‚ÇÅ)) (CategoryTheory.CategoryStruct.id R‚ÇÅ)","decl":"@[simp]\ntheorem conjugateEquiv_id : conjugateEquiv adj‚ÇÅ adj‚ÇÅ (ùüô _) = ùüô _ := by\n  ext\n  dsimp [conjugateEquiv, mateEquiv]\n  simp only [comp_id, map_id, id_comp, right_triangle_components]\n\n"}
{"name":"CategoryTheory.conjugateEquiv_symm_id","module":"Mathlib.CategoryTheory.Adjunction.Mates","initialProofState":"C : Type u‚ÇÅ\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nL‚ÇÅ : CategoryTheory.Functor C D\nR‚ÇÅ : CategoryTheory.Functor D C\nadj‚ÇÅ : CategoryTheory.Adjunction L‚ÇÅ R‚ÇÅ\n‚ä¢ Eq ((CategoryTheory.conjugateEquiv adj‚ÇÅ adj‚ÇÅ).symm (CategoryTheory.CategoryStruct.id R‚ÇÅ)) (CategoryTheory.CategoryStruct.id L‚ÇÅ)","decl":"@[simp]\ntheorem conjugateEquiv_symm_id : (conjugateEquiv adj‚ÇÅ adj‚ÇÅ).symm (ùüô _) = ùüô _ := by\n  rw [Equiv.symm_apply_eq]\n  simp only [conjugateEquiv_id]\n\n"}
{"name":"CategoryTheory.conjugateEquiv_adjunction_id","module":"Mathlib.CategoryTheory.Adjunction.Mates","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nL R : CategoryTheory.Functor C C\nadj : CategoryTheory.Adjunction L R\nŒ± : Quiver.Hom (CategoryTheory.Functor.id C) L\nc : C\n‚ä¢ Eq (((CategoryTheory.conjugateEquiv adj CategoryTheory.Adjunction.id) Œ±).app c) (CategoryTheory.CategoryStruct.comp (Œ±.app (R.obj c)) (adj.counit.app c))","decl":"theorem conjugateEquiv_adjunction_id {L R : C ‚•§ C} (adj : L ‚ä£ R) (Œ± : ùü≠ C ‚ü∂ L) (c : C) :\n    (conjugateEquiv adj Adjunction.id Œ±).app c = Œ±.app (R.obj c) ‚â´ adj.counit.app c := by\n  dsimp [conjugateEquiv, mateEquiv, Adjunction.id]\n  simp only [comp_id, id_comp]\n\n"}
{"name":"CategoryTheory.conjugateEquiv_adjunction_id_symm","module":"Mathlib.CategoryTheory.Adjunction.Mates","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nL R : CategoryTheory.Functor C C\nadj : CategoryTheory.Adjunction L R\nŒ± : Quiver.Hom R (CategoryTheory.Functor.id C)\nc : C\n‚ä¢ Eq (((CategoryTheory.conjugateEquiv adj CategoryTheory.Adjunction.id).symm Œ±).app c) (CategoryTheory.CategoryStruct.comp (adj.unit.app c) (Œ±.app (L.obj c)))","decl":"theorem conjugateEquiv_adjunction_id_symm {L R : C ‚•§ C} (adj : L ‚ä£ R) (Œ± : R ‚ü∂ ùü≠ C) (c : C) :\n    ((conjugateEquiv adj Adjunction.id).symm Œ±).app c = adj.unit.app c ‚â´ Œ±.app (L.obj c) := by\n  dsimp [conjugateEquiv, mateEquiv, Adjunction.id]\n  simp only [comp_id, id_comp]\n"}
{"name":"CategoryTheory.conjugateEquiv_comp","module":"Mathlib.CategoryTheory.Adjunction.Mates","initialProofState":"C : Type u‚ÇÅ\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nL‚ÇÅ L‚ÇÇ L‚ÇÉ : CategoryTheory.Functor C D\nR‚ÇÅ R‚ÇÇ R‚ÇÉ : CategoryTheory.Functor D C\nadj‚ÇÅ : CategoryTheory.Adjunction L‚ÇÅ R‚ÇÅ\nadj‚ÇÇ : CategoryTheory.Adjunction L‚ÇÇ R‚ÇÇ\nadj‚ÇÉ : CategoryTheory.Adjunction L‚ÇÉ R‚ÇÉ\nŒ± : Quiver.Hom L‚ÇÇ L‚ÇÅ\nŒ≤ : Quiver.Hom L‚ÇÉ L‚ÇÇ\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.conjugateEquiv adj‚ÇÅ adj‚ÇÇ) Œ±) ((CategoryTheory.conjugateEquiv adj‚ÇÇ adj‚ÇÉ) Œ≤)) ((CategoryTheory.conjugateEquiv adj‚ÇÅ adj‚ÇÉ) (CategoryTheory.CategoryStruct.comp Œ≤ Œ±))","decl":"@[simp]\ntheorem conjugateEquiv_comp (Œ± : L‚ÇÇ ‚ü∂ L‚ÇÅ) (Œ≤ : L‚ÇÉ ‚ü∂ L‚ÇÇ) :\n    conjugateEquiv adj‚ÇÅ adj‚ÇÇ Œ± ‚â´ conjugateEquiv adj‚ÇÇ adj‚ÇÉ Œ≤ =\n      conjugateEquiv adj‚ÇÅ adj‚ÇÉ (Œ≤ ‚â´ Œ±) := by\n  ext d\n  dsimp [conjugateEquiv, mateEquiv]\n  have vcomp := mateEquiv_vcomp adj‚ÇÅ adj‚ÇÇ adj‚ÇÉ\n    (L‚ÇÇ.leftUnitor.hom ‚â´ Œ± ‚â´ L‚ÇÅ.rightUnitor.inv)\n    (L‚ÇÉ.leftUnitor.hom ‚â´ Œ≤ ‚â´ L‚ÇÇ.rightUnitor.inv)\n  have vcompd := congr_app vcomp d\n  dsimp [mateEquiv, leftAdjointSquare.vcomp, rightAdjointSquare.vcomp] at vcompd\n  simp only [comp_id, id_comp, assoc, map_comp] at vcompd ‚ä¢\n  rw [vcompd]\n\n"}
{"name":"CategoryTheory.conjugateEquiv_symm_comp","module":"Mathlib.CategoryTheory.Adjunction.Mates","initialProofState":"C : Type u‚ÇÅ\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nL‚ÇÅ L‚ÇÇ L‚ÇÉ : CategoryTheory.Functor C D\nR‚ÇÅ R‚ÇÇ R‚ÇÉ : CategoryTheory.Functor D C\nadj‚ÇÅ : CategoryTheory.Adjunction L‚ÇÅ R‚ÇÅ\nadj‚ÇÇ : CategoryTheory.Adjunction L‚ÇÇ R‚ÇÇ\nadj‚ÇÉ : CategoryTheory.Adjunction L‚ÇÉ R‚ÇÉ\nŒ± : Quiver.Hom R‚ÇÅ R‚ÇÇ\nŒ≤ : Quiver.Hom R‚ÇÇ R‚ÇÉ\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.conjugateEquiv adj‚ÇÇ adj‚ÇÉ).symm Œ≤) ((CategoryTheory.conjugateEquiv adj‚ÇÅ adj‚ÇÇ).symm Œ±)) ((CategoryTheory.conjugateEquiv adj‚ÇÅ adj‚ÇÉ).symm (CategoryTheory.CategoryStruct.comp Œ± Œ≤))","decl":"@[simp]\ntheorem conjugateEquiv_symm_comp (Œ± : R‚ÇÅ ‚ü∂ R‚ÇÇ) (Œ≤ : R‚ÇÇ ‚ü∂ R‚ÇÉ) :\n    (conjugateEquiv adj‚ÇÇ adj‚ÇÉ).symm Œ≤ ‚â´ (conjugateEquiv adj‚ÇÅ adj‚ÇÇ).symm Œ± =\n      (conjugateEquiv adj‚ÇÅ adj‚ÇÉ).symm (Œ± ‚â´ Œ≤) := by\n  rw [Equiv.eq_symm_apply, ‚Üê conjugateEquiv_comp _ adj‚ÇÇ]\n  simp only [Equiv.apply_symm_apply]\n\n"}
{"name":"CategoryTheory.conjugateEquiv_comm","module":"Mathlib.CategoryTheory.Adjunction.Mates","initialProofState":"C : Type u‚ÇÅ\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nL‚ÇÅ L‚ÇÇ : CategoryTheory.Functor C D\nR‚ÇÅ R‚ÇÇ : CategoryTheory.Functor D C\nadj‚ÇÅ : CategoryTheory.Adjunction L‚ÇÅ R‚ÇÅ\nadj‚ÇÇ : CategoryTheory.Adjunction L‚ÇÇ R‚ÇÇ\nŒ± : Quiver.Hom L‚ÇÇ L‚ÇÅ\nŒ≤ : Quiver.Hom L‚ÇÅ L‚ÇÇ\nŒ≤Œ± : Eq (CategoryTheory.CategoryStruct.comp Œ≤ Œ±) (CategoryTheory.CategoryStruct.id L‚ÇÅ)\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.conjugateEquiv adj‚ÇÅ adj‚ÇÇ) Œ±) ((CategoryTheory.conjugateEquiv adj‚ÇÇ adj‚ÇÅ) Œ≤)) (CategoryTheory.CategoryStruct.id R‚ÇÅ)","decl":"theorem conjugateEquiv_comm {Œ± : L‚ÇÇ ‚ü∂ L‚ÇÅ} {Œ≤ : L‚ÇÅ ‚ü∂ L‚ÇÇ} (Œ≤Œ± : Œ≤ ‚â´ Œ± = ùüô _) :\n    conjugateEquiv adj‚ÇÅ adj‚ÇÇ Œ± ‚â´ conjugateEquiv adj‚ÇÇ adj‚ÇÅ Œ≤ = ùüô _ := by\n  rw [conjugateEquiv_comp, Œ≤Œ±, conjugateEquiv_id]\n\n"}
{"name":"CategoryTheory.conjugateEquiv_symm_comm","module":"Mathlib.CategoryTheory.Adjunction.Mates","initialProofState":"C : Type u‚ÇÅ\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nL‚ÇÅ L‚ÇÇ : CategoryTheory.Functor C D\nR‚ÇÅ R‚ÇÇ : CategoryTheory.Functor D C\nadj‚ÇÅ : CategoryTheory.Adjunction L‚ÇÅ R‚ÇÅ\nadj‚ÇÇ : CategoryTheory.Adjunction L‚ÇÇ R‚ÇÇ\nŒ± : Quiver.Hom R‚ÇÅ R‚ÇÇ\nŒ≤ : Quiver.Hom R‚ÇÇ R‚ÇÅ\nŒ±Œ≤ : Eq (CategoryTheory.CategoryStruct.comp Œ± Œ≤) (CategoryTheory.CategoryStruct.id R‚ÇÅ)\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.conjugateEquiv adj‚ÇÇ adj‚ÇÅ).symm Œ≤) ((CategoryTheory.conjugateEquiv adj‚ÇÅ adj‚ÇÇ).symm Œ±)) (CategoryTheory.CategoryStruct.id L‚ÇÅ)","decl":"theorem conjugateEquiv_symm_comm {Œ± : R‚ÇÅ ‚ü∂ R‚ÇÇ} {Œ≤ : R‚ÇÇ ‚ü∂ R‚ÇÅ} (Œ±Œ≤ : Œ± ‚â´ Œ≤ = ùüô _) :\n    (conjugateEquiv adj‚ÇÇ adj‚ÇÅ).symm Œ≤ ‚â´ (conjugateEquiv adj‚ÇÅ adj‚ÇÇ).symm Œ± = ùüô _ := by\n  rw [conjugateEquiv_symm_comp, Œ±Œ≤, conjugateEquiv_symm_id]\n\n"}
{"name":"CategoryTheory.conjugateEquiv_iso","module":"Mathlib.CategoryTheory.Adjunction.Mates","initialProofState":"C : Type u‚ÇÅ\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nL‚ÇÅ L‚ÇÇ : CategoryTheory.Functor C D\nR‚ÇÅ R‚ÇÇ : CategoryTheory.Functor D C\nadj‚ÇÅ : CategoryTheory.Adjunction L‚ÇÅ R‚ÇÅ\nadj‚ÇÇ : CategoryTheory.Adjunction L‚ÇÇ R‚ÇÇ\nŒ± : Quiver.Hom L‚ÇÇ L‚ÇÅ\ninst‚úù : CategoryTheory.IsIso Œ±\n‚ä¢ CategoryTheory.IsIso ((CategoryTheory.conjugateEquiv adj‚ÇÅ adj‚ÇÇ) Œ±)","decl":"/-- If `Œ±` is an isomorphism between left adjoints, then its conjugate transformation is an\nisomorphism. The converse is given in `conjugateEquiv_of_iso`.\n-/\ninstance conjugateEquiv_iso (Œ± : L‚ÇÇ ‚ü∂ L‚ÇÅ) [IsIso Œ±] :\n    IsIso (conjugateEquiv adj‚ÇÅ adj‚ÇÇ Œ±) :=\n  ‚ü®‚ü®conjugateEquiv adj‚ÇÇ adj‚ÇÅ (inv Œ±),\n      ‚ü®conjugateEquiv_comm _ _ (by simp), conjugateEquiv_comm _ _ (by simp)‚ü©‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.conjugateEquiv_symm_iso","module":"Mathlib.CategoryTheory.Adjunction.Mates","initialProofState":"C : Type u‚ÇÅ\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nL‚ÇÅ L‚ÇÇ : CategoryTheory.Functor C D\nR‚ÇÅ R‚ÇÇ : CategoryTheory.Functor D C\nadj‚ÇÅ : CategoryTheory.Adjunction L‚ÇÅ R‚ÇÅ\nadj‚ÇÇ : CategoryTheory.Adjunction L‚ÇÇ R‚ÇÇ\nŒ± : Quiver.Hom R‚ÇÅ R‚ÇÇ\ninst‚úù : CategoryTheory.IsIso Œ±\n‚ä¢ CategoryTheory.IsIso ((CategoryTheory.conjugateEquiv adj‚ÇÅ adj‚ÇÇ).symm Œ±)","decl":"/-- If `Œ±` is an isomorphism between right adjoints, then its conjugate transformation is an\nisomorphism. The converse is given in `conjugateEquiv_symm_of_iso`.\n-/\ninstance conjugateEquiv_symm_iso (Œ± : R‚ÇÅ ‚ü∂ R‚ÇÇ) [IsIso Œ±] :\n    IsIso ((conjugateEquiv adj‚ÇÅ adj‚ÇÇ).symm Œ±) :=\n  ‚ü®‚ü®(conjugateEquiv adj‚ÇÇ adj‚ÇÅ).symm (inv Œ±),\n      ‚ü®conjugateEquiv_symm_comm _ _ (by simp), conjugateEquiv_symm_comm _ _ (by simp)‚ü©‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.conjugateEquiv_of_iso","module":"Mathlib.CategoryTheory.Adjunction.Mates","initialProofState":"C : Type u‚ÇÅ\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nL‚ÇÅ L‚ÇÇ : CategoryTheory.Functor C D\nR‚ÇÅ R‚ÇÇ : CategoryTheory.Functor D C\nadj‚ÇÅ : CategoryTheory.Adjunction L‚ÇÅ R‚ÇÅ\nadj‚ÇÇ : CategoryTheory.Adjunction L‚ÇÇ R‚ÇÇ\nŒ± : Quiver.Hom L‚ÇÇ L‚ÇÅ\ninst‚úù : CategoryTheory.IsIso ((CategoryTheory.conjugateEquiv adj‚ÇÅ adj‚ÇÇ) Œ±)\n‚ä¢ CategoryTheory.IsIso Œ±","decl":"/-- If `Œ±` is a natural transformation between left adjoints whose conjugate natural transformation\nis an isomorphism, then `Œ±` is an isomorphism. The converse is given in `Conjugate_iso`.\n-/\ntheorem conjugateEquiv_of_iso (Œ± : L‚ÇÇ ‚ü∂ L‚ÇÅ) [IsIso (conjugateEquiv adj‚ÇÅ adj‚ÇÇ Œ±)] :\n    IsIso Œ± := by\n  suffices IsIso ((conjugateEquiv adj‚ÇÅ adj‚ÇÇ).symm (conjugateEquiv adj‚ÇÅ adj‚ÇÇ Œ±))\n    by simpa using this\n  infer_instance\n\n"}
{"name":"CategoryTheory.conjugateEquiv_symm_of_iso","module":"Mathlib.CategoryTheory.Adjunction.Mates","initialProofState":"C : Type u‚ÇÅ\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nL‚ÇÅ L‚ÇÇ : CategoryTheory.Functor C D\nR‚ÇÅ R‚ÇÇ : CategoryTheory.Functor D C\nadj‚ÇÅ : CategoryTheory.Adjunction L‚ÇÅ R‚ÇÅ\nadj‚ÇÇ : CategoryTheory.Adjunction L‚ÇÇ R‚ÇÇ\nŒ± : Quiver.Hom R‚ÇÅ R‚ÇÇ\ninst‚úù : CategoryTheory.IsIso ((CategoryTheory.conjugateEquiv adj‚ÇÅ adj‚ÇÇ).symm Œ±)\n‚ä¢ CategoryTheory.IsIso Œ±","decl":"/--\nIf `Œ±` is a natural transformation between right adjoints whose conjugate natural transformation is\nan isomorphism, then `Œ±` is an isomorphism. The converse is given in `conjugateEquiv_symm_iso`.\n-/\ntheorem conjugateEquiv_symm_of_iso (Œ± : R‚ÇÅ ‚ü∂ R‚ÇÇ)\n    [IsIso ((conjugateEquiv adj‚ÇÅ adj‚ÇÇ).symm Œ±)] : IsIso Œ± := by\n  suffices IsIso ((conjugateEquiv adj‚ÇÅ adj‚ÇÇ) ((conjugateEquiv adj‚ÇÅ adj‚ÇÇ).symm Œ±))\n    by simpa using this\n  infer_instance\n\n"}
{"name":"CategoryTheory.conjugateIsoEquiv_symm_apply_hom","module":"Mathlib.CategoryTheory.Adjunction.Mates","initialProofState":"C : Type u‚ÇÅ\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nL‚ÇÅ L‚ÇÇ : CategoryTheory.Functor C D\nR‚ÇÅ R‚ÇÇ : CategoryTheory.Functor D C\nadj‚ÇÅ : CategoryTheory.Adjunction L‚ÇÅ R‚ÇÅ\nadj‚ÇÇ : CategoryTheory.Adjunction L‚ÇÇ R‚ÇÇ\nŒ≤ : CategoryTheory.Iso R‚ÇÅ R‚ÇÇ\n‚ä¢ Eq ((CategoryTheory.conjugateIsoEquiv adj‚ÇÅ adj‚ÇÇ).symm Œ≤).hom ((CategoryTheory.conjugateEquiv adj‚ÇÅ adj‚ÇÇ).symm Œ≤.hom)","decl":"/-- Thus conjugation defines an equivalence between natural isomorphisms. -/\n@[simps]\ndef conjugateIsoEquiv : (L‚ÇÇ ‚âÖ L‚ÇÅ) ‚âÉ (R‚ÇÅ ‚âÖ R‚ÇÇ) where\n  toFun Œ± := {\n    hom := conjugateEquiv adj‚ÇÅ adj‚ÇÇ Œ±.hom\n    inv := conjugateEquiv adj‚ÇÇ adj‚ÇÅ Œ±.inv\n  }\n  invFun Œ≤ := {\n    hom := (conjugateEquiv adj‚ÇÅ adj‚ÇÇ).symm Œ≤.hom\n    inv := (conjugateEquiv adj‚ÇÇ adj‚ÇÅ).symm Œ≤.inv\n  }\n  left_inv := by aesop_cat\n  right_inv := by aesop_cat\n\n"}
{"name":"CategoryTheory.conjugateIsoEquiv_symm_apply_inv","module":"Mathlib.CategoryTheory.Adjunction.Mates","initialProofState":"C : Type u‚ÇÅ\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nL‚ÇÅ L‚ÇÇ : CategoryTheory.Functor C D\nR‚ÇÅ R‚ÇÇ : CategoryTheory.Functor D C\nadj‚ÇÅ : CategoryTheory.Adjunction L‚ÇÅ R‚ÇÅ\nadj‚ÇÇ : CategoryTheory.Adjunction L‚ÇÇ R‚ÇÇ\nŒ≤ : CategoryTheory.Iso R‚ÇÅ R‚ÇÇ\n‚ä¢ Eq ((CategoryTheory.conjugateIsoEquiv adj‚ÇÅ adj‚ÇÇ).symm Œ≤).inv ((CategoryTheory.conjugateEquiv adj‚ÇÇ adj‚ÇÅ).symm Œ≤.inv)","decl":"/-- Thus conjugation defines an equivalence between natural isomorphisms. -/\n@[simps]\ndef conjugateIsoEquiv : (L‚ÇÇ ‚âÖ L‚ÇÅ) ‚âÉ (R‚ÇÅ ‚âÖ R‚ÇÇ) where\n  toFun Œ± := {\n    hom := conjugateEquiv adj‚ÇÅ adj‚ÇÇ Œ±.hom\n    inv := conjugateEquiv adj‚ÇÇ adj‚ÇÅ Œ±.inv\n  }\n  invFun Œ≤ := {\n    hom := (conjugateEquiv adj‚ÇÅ adj‚ÇÇ).symm Œ≤.hom\n    inv := (conjugateEquiv adj‚ÇÇ adj‚ÇÅ).symm Œ≤.inv\n  }\n  left_inv := by aesop_cat\n  right_inv := by aesop_cat\n\n"}
{"name":"CategoryTheory.conjugateIsoEquiv_apply_inv","module":"Mathlib.CategoryTheory.Adjunction.Mates","initialProofState":"C : Type u‚ÇÅ\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nL‚ÇÅ L‚ÇÇ : CategoryTheory.Functor C D\nR‚ÇÅ R‚ÇÇ : CategoryTheory.Functor D C\nadj‚ÇÅ : CategoryTheory.Adjunction L‚ÇÅ R‚ÇÅ\nadj‚ÇÇ : CategoryTheory.Adjunction L‚ÇÇ R‚ÇÇ\nŒ± : CategoryTheory.Iso L‚ÇÇ L‚ÇÅ\n‚ä¢ Eq ((CategoryTheory.conjugateIsoEquiv adj‚ÇÅ adj‚ÇÇ) Œ±).inv ((CategoryTheory.conjugateEquiv adj‚ÇÇ adj‚ÇÅ) Œ±.inv)","decl":"/-- Thus conjugation defines an equivalence between natural isomorphisms. -/\n@[simps]\ndef conjugateIsoEquiv : (L‚ÇÇ ‚âÖ L‚ÇÅ) ‚âÉ (R‚ÇÅ ‚âÖ R‚ÇÇ) where\n  toFun Œ± := {\n    hom := conjugateEquiv adj‚ÇÅ adj‚ÇÇ Œ±.hom\n    inv := conjugateEquiv adj‚ÇÇ adj‚ÇÅ Œ±.inv\n  }\n  invFun Œ≤ := {\n    hom := (conjugateEquiv adj‚ÇÅ adj‚ÇÇ).symm Œ≤.hom\n    inv := (conjugateEquiv adj‚ÇÇ adj‚ÇÅ).symm Œ≤.inv\n  }\n  left_inv := by aesop_cat\n  right_inv := by aesop_cat\n\n"}
{"name":"CategoryTheory.conjugateIsoEquiv_apply_hom","module":"Mathlib.CategoryTheory.Adjunction.Mates","initialProofState":"C : Type u‚ÇÅ\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nL‚ÇÅ L‚ÇÇ : CategoryTheory.Functor C D\nR‚ÇÅ R‚ÇÇ : CategoryTheory.Functor D C\nadj‚ÇÅ : CategoryTheory.Adjunction L‚ÇÅ R‚ÇÅ\nadj‚ÇÇ : CategoryTheory.Adjunction L‚ÇÇ R‚ÇÇ\nŒ± : CategoryTheory.Iso L‚ÇÇ L‚ÇÅ\n‚ä¢ Eq ((CategoryTheory.conjugateIsoEquiv adj‚ÇÅ adj‚ÇÇ) Œ±).hom ((CategoryTheory.conjugateEquiv adj‚ÇÅ adj‚ÇÇ) Œ±.hom)","decl":"/-- Thus conjugation defines an equivalence between natural isomorphisms. -/\n@[simps]\ndef conjugateIsoEquiv : (L‚ÇÇ ‚âÖ L‚ÇÅ) ‚âÉ (R‚ÇÅ ‚âÖ R‚ÇÇ) where\n  toFun Œ± := {\n    hom := conjugateEquiv adj‚ÇÅ adj‚ÇÇ Œ±.hom\n    inv := conjugateEquiv adj‚ÇÇ adj‚ÇÅ Œ±.inv\n  }\n  invFun Œ≤ := {\n    hom := (conjugateEquiv adj‚ÇÅ adj‚ÇÇ).symm Œ≤.hom\n    inv := (conjugateEquiv adj‚ÇÇ adj‚ÇÅ).symm Œ≤.inv\n  }\n  left_inv := by aesop_cat\n  right_inv := by aesop_cat\n\n"}
{"name":"CategoryTheory.iterated_mateEquiv_conjugateEquiv","module":"Mathlib.CategoryTheory.Adjunction.Mates","initialProofState":"A : Type u‚ÇÅ\nB : Type u‚ÇÇ\nC : Type u‚ÇÉ\nD : Type u‚ÇÑ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} A\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} B\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\ninst‚úù : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} D\nF‚ÇÅ : CategoryTheory.Functor A C\nU‚ÇÅ : CategoryTheory.Functor C A\nF‚ÇÇ : CategoryTheory.Functor B D\nU‚ÇÇ : CategoryTheory.Functor D B\nL‚ÇÅ : CategoryTheory.Functor A B\nR‚ÇÅ : CategoryTheory.Functor B A\nL‚ÇÇ : CategoryTheory.Functor C D\nR‚ÇÇ : CategoryTheory.Functor D C\nadj‚ÇÅ : CategoryTheory.Adjunction L‚ÇÅ R‚ÇÅ\nadj‚ÇÇ : CategoryTheory.Adjunction L‚ÇÇ R‚ÇÇ\nadj‚ÇÉ : CategoryTheory.Adjunction F‚ÇÅ U‚ÇÅ\nadj‚ÇÑ : CategoryTheory.Adjunction F‚ÇÇ U‚ÇÇ\nŒ± : Quiver.Hom (F‚ÇÅ.comp L‚ÇÇ) (L‚ÇÅ.comp F‚ÇÇ)\n‚ä¢ Eq ((CategoryTheory.mateEquiv adj‚ÇÑ adj‚ÇÉ) ((CategoryTheory.mateEquiv adj‚ÇÅ adj‚ÇÇ) Œ±)) ((CategoryTheory.conjugateEquiv (adj‚ÇÅ.comp adj‚ÇÑ) (adj‚ÇÉ.comp adj‚ÇÇ)) Œ±)","decl":"/-- When all four functors in a sequare are left adjoints, the mates operation can be iterated:\n\n         L‚ÇÅ                  R‚ÇÅ                  R‚ÇÅ\n      C --‚Üí D             C ‚Üê-- D             C ‚Üê-- D\n   F‚ÇÅ ‚Üì  ‚Üó  ‚Üì  F‚ÇÇ      F‚ÇÅ ‚Üì  ‚Üò  ‚Üì F‚ÇÇ       U‚ÇÅ ‚Üë  ‚Üô  ‚Üë U‚ÇÇ\n      E --‚Üí F             E ‚Üê-- F             E ‚Üê-- F\n         L‚ÇÇ                  R‚ÇÇ                  R‚ÇÇ\n\nIn this case the iterated mate equals the conjugate of the original transformation and is thus an\nisomorphism if and only if the original transformation is. This explains why some Beck-Chevalley\nnatural transformations are natural isomorphisms.\n-/\ntheorem iterated_mateEquiv_conjugateEquiv (Œ± : F‚ÇÅ ‚ãô L‚ÇÇ ‚ü∂ L‚ÇÅ ‚ãô F‚ÇÇ) :\n    mateEquiv adj‚ÇÑ adj‚ÇÉ (mateEquiv adj‚ÇÅ adj‚ÇÇ Œ±) =\n      conjugateEquiv (adj‚ÇÅ.comp adj‚ÇÑ) (adj‚ÇÉ.comp adj‚ÇÇ) Œ± := by\n  ext d\n  unfold conjugateEquiv mateEquiv Adjunction.comp\n  simp\n\n"}
{"name":"CategoryTheory.iterated_mateEquiv_conjugateEquiv_symm","module":"Mathlib.CategoryTheory.Adjunction.Mates","initialProofState":"A : Type u‚ÇÅ\nB : Type u‚ÇÇ\nC : Type u‚ÇÉ\nD : Type u‚ÇÑ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} A\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} B\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\ninst‚úù : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} D\nF‚ÇÅ : CategoryTheory.Functor A C\nU‚ÇÅ : CategoryTheory.Functor C A\nF‚ÇÇ : CategoryTheory.Functor B D\nU‚ÇÇ : CategoryTheory.Functor D B\nL‚ÇÅ : CategoryTheory.Functor A B\nR‚ÇÅ : CategoryTheory.Functor B A\nL‚ÇÇ : CategoryTheory.Functor C D\nR‚ÇÇ : CategoryTheory.Functor D C\nadj‚ÇÅ : CategoryTheory.Adjunction L‚ÇÅ R‚ÇÅ\nadj‚ÇÇ : CategoryTheory.Adjunction L‚ÇÇ R‚ÇÇ\nadj‚ÇÉ : CategoryTheory.Adjunction F‚ÇÅ U‚ÇÅ\nadj‚ÇÑ : CategoryTheory.Adjunction F‚ÇÇ U‚ÇÇ\nŒ± : Quiver.Hom (U‚ÇÇ.comp R‚ÇÅ) (R‚ÇÇ.comp U‚ÇÅ)\n‚ä¢ Eq ((CategoryTheory.mateEquiv adj‚ÇÅ adj‚ÇÇ).symm ((CategoryTheory.mateEquiv adj‚ÇÑ adj‚ÇÉ).symm Œ±)) ((CategoryTheory.conjugateEquiv (adj‚ÇÅ.comp adj‚ÇÑ) (adj‚ÇÉ.comp adj‚ÇÇ)).symm Œ±)","decl":"theorem iterated_mateEquiv_conjugateEquiv_symm (Œ± : U‚ÇÇ ‚ãô R‚ÇÅ ‚ü∂ R‚ÇÇ ‚ãô U‚ÇÅ) :\n    (mateEquiv adj‚ÇÅ adj‚ÇÇ).symm ((mateEquiv adj‚ÇÑ adj‚ÇÉ).symm Œ±) =\n      (conjugateEquiv (adj‚ÇÅ.comp adj‚ÇÑ) (adj‚ÇÉ.comp adj‚ÇÇ)).symm Œ± := by\n  rw [Equiv.eq_symm_apply, ‚Üê iterated_mateEquiv_conjugateEquiv]\n  simp only [Equiv.apply_symm_apply]\n\n"}
{"name":"CategoryTheory.mateEquiv_conjugateEquiv_vcomp","module":"Mathlib.CategoryTheory.Adjunction.Mates","initialProofState":"A : Type u‚ÇÅ\nB : Type u‚ÇÇ\nC : Type u‚ÇÉ\nD : Type u‚ÇÑ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} A\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} B\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\ninst‚úù : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} D\nG : CategoryTheory.Functor A C\nH : CategoryTheory.Functor B D\nL‚ÇÅ : CategoryTheory.Functor A B\nR‚ÇÅ : CategoryTheory.Functor B A\nL‚ÇÇ : CategoryTheory.Functor C D\nR‚ÇÇ : CategoryTheory.Functor D C\nL‚ÇÉ : CategoryTheory.Functor C D\nR‚ÇÉ : CategoryTheory.Functor D C\nadj‚ÇÅ : CategoryTheory.Adjunction L‚ÇÅ R‚ÇÅ\nadj‚ÇÇ : CategoryTheory.Adjunction L‚ÇÇ R‚ÇÇ\nadj‚ÇÉ : CategoryTheory.Adjunction L‚ÇÉ R‚ÇÉ\nŒ± : Quiver.Hom (G.comp L‚ÇÇ) (L‚ÇÅ.comp H)\nŒ≤ : Quiver.Hom L‚ÇÉ L‚ÇÇ\n‚ä¢ Eq ((CategoryTheory.mateEquiv adj‚ÇÅ adj‚ÇÉ) (CategoryTheory.leftAdjointSquareConjugate.vcomp Œ± Œ≤)) (CategoryTheory.rightAdjointSquareConjugate.vcomp ((CategoryTheory.mateEquiv adj‚ÇÅ adj‚ÇÇ) Œ±) ((CategoryTheory.conjugateEquiv adj‚ÇÇ adj‚ÇÉ) Œ≤))","decl":"/-- The mates equivalence commutes with this composition, essentially by `mateEquiv_vcomp`. -/\ntheorem mateEquiv_conjugateEquiv_vcomp\n    (Œ± : G ‚ãô L‚ÇÇ ‚ü∂ L‚ÇÅ ‚ãô H) (Œ≤ : L‚ÇÉ ‚ü∂ L‚ÇÇ) :\n    (mateEquiv adj‚ÇÅ adj‚ÇÉ) (leftAdjointSquareConjugate.vcomp Œ± Œ≤) =\n      rightAdjointSquareConjugate.vcomp (mateEquiv adj‚ÇÅ adj‚ÇÇ Œ±) (conjugateEquiv adj‚ÇÇ adj‚ÇÉ Œ≤) := by\n  ext b\n  have vcomp := mateEquiv_vcomp adj‚ÇÅ adj‚ÇÇ adj‚ÇÉ Œ± (L‚ÇÉ.leftUnitor.hom ‚â´ Œ≤ ‚â´ L‚ÇÇ.rightUnitor.inv)\n  unfold leftAdjointSquare.vcomp rightAdjointSquare.vcomp at vcomp\n  unfold leftAdjointSquareConjugate.vcomp rightAdjointSquareConjugate.vcomp conjugateEquiv\n  have vcompb := congr_app vcomp b\n  simp at vcompb\n  unfold mateEquiv\n  simp only [comp_obj, Equiv.coe_fn_mk, whiskerLeft_comp, whiskerLeft_twice, whiskerRight_comp,\n    assoc, comp_app, whiskerLeft_app, whiskerRight_app, id_obj, Functor.comp_map, Iso.homCongr_symm,\n    Equiv.instTrans_trans, Equiv.trans_apply, Iso.homCongr_apply, Iso.symm_inv, Iso.symm_hom,\n    rightUnitor_inv_app, leftUnitor_hom_app, map_id, Functor.id_map, comp_id, id_comp]\n  exact vcompb\n\n"}
{"name":"CategoryTheory.conjugateEquiv_mateEquiv_vcomp","module":"Mathlib.CategoryTheory.Adjunction.Mates","initialProofState":"A : Type u‚ÇÅ\nB : Type u‚ÇÇ\nC : Type u‚ÇÉ\nD : Type u‚ÇÑ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} A\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} B\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\ninst‚úù : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} D\nG : CategoryTheory.Functor A C\nH : CategoryTheory.Functor B D\nL‚ÇÅ : CategoryTheory.Functor A B\nR‚ÇÅ : CategoryTheory.Functor B A\nL‚ÇÇ : CategoryTheory.Functor A B\nR‚ÇÇ : CategoryTheory.Functor B A\nL‚ÇÉ : CategoryTheory.Functor C D\nR‚ÇÉ : CategoryTheory.Functor D C\nadj‚ÇÅ : CategoryTheory.Adjunction L‚ÇÅ R‚ÇÅ\nadj‚ÇÇ : CategoryTheory.Adjunction L‚ÇÇ R‚ÇÇ\nadj‚ÇÉ : CategoryTheory.Adjunction L‚ÇÉ R‚ÇÉ\nŒ± : Quiver.Hom L‚ÇÇ L‚ÇÅ\nŒ≤ : Quiver.Hom (G.comp L‚ÇÉ) (L‚ÇÇ.comp H)\n‚ä¢ Eq ((CategoryTheory.mateEquiv adj‚ÇÅ adj‚ÇÉ) (CategoryTheory.leftAdjointConjugateSquare.vcomp Œ± Œ≤)) (CategoryTheory.rightAdjointConjugateSquare.vcomp ((CategoryTheory.conjugateEquiv adj‚ÇÅ adj‚ÇÇ) Œ±) ((CategoryTheory.mateEquiv adj‚ÇÇ adj‚ÇÉ) Œ≤))","decl":"/-- The mates equivalence commutes with this composition, essentially by `mateEquiv_vcomp`. -/\ntheorem conjugateEquiv_mateEquiv_vcomp\n    (Œ± : L‚ÇÇ ‚ü∂ L‚ÇÅ) (Œ≤ : G ‚ãô L‚ÇÉ ‚ü∂ L‚ÇÇ ‚ãô H) :\n    (mateEquiv adj‚ÇÅ adj‚ÇÉ) (leftAdjointConjugateSquare.vcomp Œ± Œ≤) =\n      rightAdjointConjugateSquare.vcomp (conjugateEquiv adj‚ÇÅ adj‚ÇÇ Œ±) (mateEquiv adj‚ÇÇ adj‚ÇÉ Œ≤) := by\n  ext b\n  have vcomp := mateEquiv_vcomp adj‚ÇÅ adj‚ÇÇ adj‚ÇÉ (L‚ÇÇ.leftUnitor.hom ‚â´ Œ± ‚â´ L‚ÇÅ.rightUnitor.inv) Œ≤\n  unfold leftAdjointSquare.vcomp rightAdjointSquare.vcomp at vcomp\n  unfold leftAdjointConjugateSquare.vcomp rightAdjointConjugateSquare.vcomp conjugateEquiv\n  have vcompb := congr_app vcomp b\n  simp at vcompb\n  unfold mateEquiv\n  simp only [comp_obj, Equiv.coe_fn_mk, whiskerLeft_comp, whiskerLeft_twice, whiskerRight_comp,\n    assoc, comp_app, whiskerLeft_app, whiskerRight_app, id_obj, Functor.comp_map, Iso.homCongr_symm,\n    Equiv.instTrans_trans, Equiv.trans_apply, Iso.homCongr_apply, Iso.symm_inv, Iso.symm_hom,\n    rightUnitor_inv_app, leftUnitor_hom_app, map_id, Functor.id_map, comp_id, id_comp]\n  exact vcompb\n\n"}
