{"name":"CategoryTheory.mateEquiv_symm_apply","module":"Mathlib.CategoryTheory.Adjunction.Mates","initialProofState":"C : Type u₁\nD : Type u₂\nE : Type u₃\nF : Type u₄\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} E\ninst✝ : CategoryTheory.Category.{v₄, u₄} F\nG : CategoryTheory.Functor C E\nH : CategoryTheory.Functor D F\nL₁ : CategoryTheory.Functor C D\nR₁ : CategoryTheory.Functor D C\nL₂ : CategoryTheory.Functor E F\nR₂ : CategoryTheory.Functor F E\nadj₁ : CategoryTheory.Adjunction L₁ R₁\nadj₂ : CategoryTheory.Adjunction L₂ R₂\nβ : Quiver.Hom (R₁.comp G) (H.comp R₂)\n⊢ Eq ((CategoryTheory.mateEquiv adj₁ adj₂).symm β) (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerRight adj₁.unit (G.comp L₂)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerRight (CategoryTheory.whiskerLeft L₁ β) L₂) (CategoryTheory.whiskerLeft (L₁.comp H) adj₂.counit)))","decl":"/-- Suppose we have a square of functors (where the top and bottom are adjunctions `L₁ ⊣ R₁`\nand `L₂ ⊣ R₂` respectively).\n\n      C ↔ D\n    G ↓   ↓ H\n      E ↔ F\n\nThen we have a bijection between natural transformations `G ⋙ L₂ ⟶ L₁ ⋙ H` and\n`R₁ ⋙ G ⟶ H ⋙ R₂`. This can be seen as a bijection of the 2-cells:\n\n         L₁                  R₁\n      C --→ D             C ←-- D\n    G ↓  ↗  ↓ H         G ↓  ↘  ↓ H\n      E --→ F             E ←-- F\n         L₂                  R₂\n\nNote that if one of the transformations is an iso, it does not imply the other is an iso.\n-/\n@[simps]\ndef mateEquiv : (G ⋙ L₂ ⟶ L₁ ⋙ H) ≃ (R₁ ⋙ G ⟶ H ⋙ R₂) where\n  toFun α :=\n    whiskerLeft (R₁ ⋙ G) adj₂.unit ≫\n    whiskerRight (whiskerLeft R₁ α) R₂ ≫\n    whiskerRight adj₁.counit (H ⋙ R₂)\n  invFun β :=\n    whiskerRight adj₁.unit (G ⋙ L₂) ≫\n    whiskerRight (whiskerLeft L₁ β) L₂ ≫\n    whiskerLeft (L₁ ⋙ H) adj₂.counit\n  left_inv α := by\n    ext\n    unfold whiskerRight whiskerLeft\n    simp only [comp_obj, id_obj, Functor.comp_map, comp_app, map_comp, assoc, counit_naturality,\n      counit_naturality_assoc, left_triangle_components_assoc]\n    rw [← assoc, ← Functor.comp_map, α.naturality, Functor.comp_map, assoc, ← H.map_comp,\n      left_triangle_components, map_id]\n    simp only [comp_obj, comp_id]\n  right_inv β := by\n    ext\n    unfold whiskerLeft whiskerRight\n    simp only [comp_obj, id_obj, Functor.comp_map, comp_app, map_comp, assoc,\n      unit_naturality_assoc, right_triangle_components_assoc]\n    rw [← assoc, ← Functor.comp_map, assoc, ← β.naturality, ← assoc, Functor.comp_map,\n      ← G.map_comp, right_triangle_components, map_id, id_comp]\n\n"}
{"name":"CategoryTheory.mateEquiv_apply","module":"Mathlib.CategoryTheory.Adjunction.Mates","initialProofState":"C : Type u₁\nD : Type u₂\nE : Type u₃\nF : Type u₄\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} E\ninst✝ : CategoryTheory.Category.{v₄, u₄} F\nG : CategoryTheory.Functor C E\nH : CategoryTheory.Functor D F\nL₁ : CategoryTheory.Functor C D\nR₁ : CategoryTheory.Functor D C\nL₂ : CategoryTheory.Functor E F\nR₂ : CategoryTheory.Functor F E\nadj₁ : CategoryTheory.Adjunction L₁ R₁\nadj₂ : CategoryTheory.Adjunction L₂ R₂\nα : Quiver.Hom (G.comp L₂) (L₁.comp H)\n⊢ Eq ((CategoryTheory.mateEquiv adj₁ adj₂) α) (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerLeft (R₁.comp G) adj₂.unit) (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerRight (CategoryTheory.whiskerLeft R₁ α) R₂) (CategoryTheory.whiskerRight adj₁.counit (H.comp R₂))))","decl":"/-- Suppose we have a square of functors (where the top and bottom are adjunctions `L₁ ⊣ R₁`\nand `L₂ ⊣ R₂` respectively).\n\n      C ↔ D\n    G ↓   ↓ H\n      E ↔ F\n\nThen we have a bijection between natural transformations `G ⋙ L₂ ⟶ L₁ ⋙ H` and\n`R₁ ⋙ G ⟶ H ⋙ R₂`. This can be seen as a bijection of the 2-cells:\n\n         L₁                  R₁\n      C --→ D             C ←-- D\n    G ↓  ↗  ↓ H         G ↓  ↘  ↓ H\n      E --→ F             E ←-- F\n         L₂                  R₂\n\nNote that if one of the transformations is an iso, it does not imply the other is an iso.\n-/\n@[simps]\ndef mateEquiv : (G ⋙ L₂ ⟶ L₁ ⋙ H) ≃ (R₁ ⋙ G ⟶ H ⋙ R₂) where\n  toFun α :=\n    whiskerLeft (R₁ ⋙ G) adj₂.unit ≫\n    whiskerRight (whiskerLeft R₁ α) R₂ ≫\n    whiskerRight adj₁.counit (H ⋙ R₂)\n  invFun β :=\n    whiskerRight adj₁.unit (G ⋙ L₂) ≫\n    whiskerRight (whiskerLeft L₁ β) L₂ ≫\n    whiskerLeft (L₁ ⋙ H) adj₂.counit\n  left_inv α := by\n    ext\n    unfold whiskerRight whiskerLeft\n    simp only [comp_obj, id_obj, Functor.comp_map, comp_app, map_comp, assoc, counit_naturality,\n      counit_naturality_assoc, left_triangle_components_assoc]\n    rw [← assoc, ← Functor.comp_map, α.naturality, Functor.comp_map, assoc, ← H.map_comp,\n      left_triangle_components, map_id]\n    simp only [comp_obj, comp_id]\n  right_inv β := by\n    ext\n    unfold whiskerLeft whiskerRight\n    simp only [comp_obj, id_obj, Functor.comp_map, comp_app, map_comp, assoc,\n      unit_naturality_assoc, right_triangle_components_assoc]\n    rw [← assoc, ← Functor.comp_map, assoc, ← β.naturality, ← assoc, Functor.comp_map,\n      ← G.map_comp, right_triangle_components, map_id, id_comp]\n\n"}
{"name":"CategoryTheory.mateEquiv_counit","module":"Mathlib.CategoryTheory.Adjunction.Mates","initialProofState":"C : Type u₁\nD : Type u₂\nE : Type u₃\nF : Type u₄\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} E\ninst✝ : CategoryTheory.Category.{v₄, u₄} F\nG : CategoryTheory.Functor C E\nH : CategoryTheory.Functor D F\nL₁ : CategoryTheory.Functor C D\nR₁ : CategoryTheory.Functor D C\nL₂ : CategoryTheory.Functor E F\nR₂ : CategoryTheory.Functor F E\nadj₁ : CategoryTheory.Adjunction L₁ R₁\nadj₂ : CategoryTheory.Adjunction L₂ R₂\nα : Quiver.Hom (G.comp L₂) (L₁.comp H)\nd : D\n⊢ Eq (CategoryTheory.CategoryStruct.comp (L₂.map (((CategoryTheory.mateEquiv adj₁ adj₂) α).app d)) (adj₂.counit.app (H.obj d))) (CategoryTheory.CategoryStruct.comp (α.app (R₁.obj d)) (H.map (adj₁.counit.app d)))","decl":"/-- A component of a transposed version of the mates correspondence. -/\ntheorem mateEquiv_counit (α : G ⋙ L₂ ⟶ L₁ ⋙ H) (d : D) :\n    L₂.map ((mateEquiv adj₁ adj₂ α).app _) ≫ adj₂.counit.app _ =\n      α.app _ ≫ H.map (adj₁.counit.app d) := by simp\n\n"}
{"name":"CategoryTheory.mateEquiv_counit_symm","module":"Mathlib.CategoryTheory.Adjunction.Mates","initialProofState":"C : Type u₁\nD : Type u₂\nE : Type u₃\nF : Type u₄\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} E\ninst✝ : CategoryTheory.Category.{v₄, u₄} F\nG : CategoryTheory.Functor C E\nH : CategoryTheory.Functor D F\nL₁ : CategoryTheory.Functor C D\nR₁ : CategoryTheory.Functor D C\nL₂ : CategoryTheory.Functor E F\nR₂ : CategoryTheory.Functor F E\nadj₁ : CategoryTheory.Adjunction L₁ R₁\nadj₂ : CategoryTheory.Adjunction L₂ R₂\nα : Quiver.Hom (R₁.comp G) (H.comp R₂)\nd : D\n⊢ Eq (CategoryTheory.CategoryStruct.comp (L₂.map (α.app d)) (adj₂.counit.app (H.obj d))) (CategoryTheory.CategoryStruct.comp (((CategoryTheory.mateEquiv adj₁ adj₂).symm α).app (R₁.obj d)) (H.map (adj₁.counit.app d)))","decl":"/-- A component of a transposed version of the inverse mates correspondence. -/\ntheorem mateEquiv_counit_symm (α : R₁ ⋙ G ⟶ H ⋙ R₂) (d : D) :\n    L₂.map (α.app _) ≫ adj₂.counit.app _ =\n      ((mateEquiv adj₁ adj₂).symm α).app _ ≫ H.map (adj₁.counit.app d) := by\n  conv_lhs => rw [← (mateEquiv adj₁ adj₂).right_inv α]\n  exact (mateEquiv_counit adj₁ adj₂ ((mateEquiv adj₁ adj₂).symm α) d)\n\n/- A component of a transposed version of the mates correspondence. -/\n"}
{"name":"CategoryTheory.unit_mateEquiv","module":"Mathlib.CategoryTheory.Adjunction.Mates","initialProofState":"C : Type u₁\nD : Type u₂\nE : Type u₃\nF : Type u₄\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} E\ninst✝ : CategoryTheory.Category.{v₄, u₄} F\nG : CategoryTheory.Functor C E\nH : CategoryTheory.Functor D F\nL₁ : CategoryTheory.Functor C D\nR₁ : CategoryTheory.Functor D C\nL₂ : CategoryTheory.Functor E F\nR₂ : CategoryTheory.Functor F E\nadj₁ : CategoryTheory.Adjunction L₁ R₁\nadj₂ : CategoryTheory.Adjunction L₂ R₂\nα : Quiver.Hom (G.comp L₂) (L₁.comp H)\nc : C\n⊢ Eq (CategoryTheory.CategoryStruct.comp (G.map (adj₁.unit.app c)) (((CategoryTheory.mateEquiv adj₁ adj₂) α).app (L₁.obj c))) (CategoryTheory.CategoryStruct.comp (adj₂.unit.app (G.obj ((CategoryTheory.Functor.id C).obj c))) (R₂.map (α.app ((CategoryTheory.Functor.id C).obj c))))","decl":"theorem unit_mateEquiv (α : G ⋙ L₂ ⟶ L₁ ⋙ H) (c : C) :\n    G.map (adj₁.unit.app c) ≫ (mateEquiv adj₁ adj₂ α).app _ =\n      adj₂.unit.app _ ≫ R₂.map (α.app _) := by\n  dsimp [mateEquiv]\n  rw [← adj₂.unit_naturality_assoc]\n  slice_lhs 2 3 =>\n    rw [← R₂.map_comp, ← Functor.comp_map G L₂, α.naturality]\n  rw [R₂.map_comp]\n  slice_lhs 3 4 =>\n    rw [← R₂.map_comp, Functor.comp_map L₁ H, ← H.map_comp, left_triangle_components]\n  simp only [comp_obj, map_id, comp_id]\n\n"}
{"name":"CategoryTheory.unit_mateEquiv_symm","module":"Mathlib.CategoryTheory.Adjunction.Mates","initialProofState":"C : Type u₁\nD : Type u₂\nE : Type u₃\nF : Type u₄\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} E\ninst✝ : CategoryTheory.Category.{v₄, u₄} F\nG : CategoryTheory.Functor C E\nH : CategoryTheory.Functor D F\nL₁ : CategoryTheory.Functor C D\nR₁ : CategoryTheory.Functor D C\nL₂ : CategoryTheory.Functor E F\nR₂ : CategoryTheory.Functor F E\nadj₁ : CategoryTheory.Adjunction L₁ R₁\nadj₂ : CategoryTheory.Adjunction L₂ R₂\nα : Quiver.Hom (R₁.comp G) (H.comp R₂)\nc : C\n⊢ Eq (CategoryTheory.CategoryStruct.comp (G.map (adj₁.unit.app c)) (α.app (L₁.obj c))) (CategoryTheory.CategoryStruct.comp (adj₂.unit.app (G.obj ((CategoryTheory.Functor.id C).obj c))) (R₂.map (((CategoryTheory.mateEquiv adj₁ adj₂).symm α).app ((CategoryTheory.Functor.id C).obj c))))","decl":"/-- A component of a transposed version of the inverse mates correspondence. -/\ntheorem unit_mateEquiv_symm (α : R₁ ⋙ G ⟶ H ⋙ R₂) (c : C) :\n    G.map (adj₁.unit.app c) ≫ α.app _ =\n      adj₂.unit.app _ ≫ R₂.map (((mateEquiv adj₁ adj₂).symm α).app _) := by\n  conv_lhs => rw [← (mateEquiv adj₁ adj₂).right_inv α]\n  exact (unit_mateEquiv adj₁ adj₂ ((mateEquiv adj₁ adj₂).symm α) c)\n\n"}
{"name":"CategoryTheory.mateEquiv_vcomp","module":"Mathlib.CategoryTheory.Adjunction.Mates","initialProofState":"A : Type u₁\nB : Type u₂\nC : Type u₃\nD : Type u₄\nE : Type u₅\nF : Type u₆\ninst✝⁵ : CategoryTheory.Category.{v₁, u₁} A\ninst✝⁴ : CategoryTheory.Category.{v₂, u₂} B\ninst✝³ : CategoryTheory.Category.{v₃, u₃} C\ninst✝² : CategoryTheory.Category.{v₄, u₄} D\ninst✝¹ : CategoryTheory.Category.{v₅, u₅} E\ninst✝ : CategoryTheory.Category.{v₆, u₆} F\nG₁ : CategoryTheory.Functor A C\nG₂ : CategoryTheory.Functor C E\nH₁ : CategoryTheory.Functor B D\nH₂ : CategoryTheory.Functor D F\nL₁ : CategoryTheory.Functor A B\nR₁ : CategoryTheory.Functor B A\nL₂ : CategoryTheory.Functor C D\nR₂ : CategoryTheory.Functor D C\nL₃ : CategoryTheory.Functor E F\nR₃ : CategoryTheory.Functor F E\nadj₁ : CategoryTheory.Adjunction L₁ R₁\nadj₂ : CategoryTheory.Adjunction L₂ R₂\nadj₃ : CategoryTheory.Adjunction L₃ R₃\nα : Quiver.Hom (G₁.comp L₂) (L₁.comp H₁)\nβ : Quiver.Hom (G₂.comp L₃) (L₂.comp H₂)\n⊢ Eq ((CategoryTheory.mateEquiv adj₁ adj₃) (CategoryTheory.leftAdjointSquare.vcomp α β)) (CategoryTheory.rightAdjointSquare.vcomp ((CategoryTheory.mateEquiv adj₁ adj₂) α) ((CategoryTheory.mateEquiv adj₂ adj₃) β))","decl":"/-- The mates equivalence commutes with vertical composition. -/\ntheorem mateEquiv_vcomp\n    (α : G₁ ⋙ L₂ ⟶ L₁ ⋙ H₁) (β : G₂ ⋙ L₃ ⟶ L₂ ⋙ H₂) :\n    (mateEquiv (G := G₁ ⋙ G₂) (H := H₁ ⋙ H₂) adj₁ adj₃) (leftAdjointSquare.vcomp α β) =\n      rightAdjointSquare.vcomp (mateEquiv adj₁ adj₂ α) (mateEquiv adj₂ adj₃ β) := by\n  unfold leftAdjointSquare.vcomp rightAdjointSquare.vcomp mateEquiv\n  ext b\n  simp only [comp_obj, Equiv.coe_fn_mk, whiskerLeft_comp, whiskerLeft_twice, whiskerRight_comp,\n    assoc, comp_app, whiskerLeft_app, whiskerRight_app, id_obj, Functor.comp_map,\n    whiskerRight_twice]\n  slice_rhs 1 4 => rw [← assoc, ← assoc, ← unit_naturality (adj₃)]\n  rw [L₃.map_comp, R₃.map_comp]\n  slice_rhs 2 4 =>\n    rw [← R₃.map_comp, ← R₃.map_comp, ← assoc, ← L₃.map_comp, ← G₂.map_comp, ← G₂.map_comp]\n    rw [← Functor.comp_map G₂ L₃, β.naturality]\n  rw [(L₂ ⋙ H₂).map_comp, R₃.map_comp, R₃.map_comp]\n  slice_rhs 4 5 =>\n    rw [← R₃.map_comp, Functor.comp_map L₂ _, ← Functor.comp_map _ L₂, ← H₂.map_comp]\n    rw [adj₂.counit.naturality]\n  simp only [comp_obj, Functor.comp_map, map_comp, id_obj, Functor.id_map, assoc]\n  slice_rhs 4 5 =>\n    rw [← R₃.map_comp, ← H₂.map_comp, ← Functor.comp_map _ L₂, adj₂.counit.naturality]\n  simp only [comp_obj, id_obj, Functor.id_map, map_comp, assoc]\n  slice_rhs 3 4 =>\n    rw [← R₃.map_comp, ← H₂.map_comp, left_triangle_components]\n  simp only [map_id, id_comp]\n\n"}
{"name":"CategoryTheory.mateEquiv_hcomp","module":"Mathlib.CategoryTheory.Adjunction.Mates","initialProofState":"A : Type u₁\nB : Type u₂\nC : Type u₃\nD : Type u₄\nE : Type u₅\nF : Type u₆\ninst✝⁵ : CategoryTheory.Category.{v₁, u₁} A\ninst✝⁴ : CategoryTheory.Category.{v₂, u₂} B\ninst✝³ : CategoryTheory.Category.{v₃, u₃} C\ninst✝² : CategoryTheory.Category.{v₄, u₄} D\ninst✝¹ : CategoryTheory.Category.{v₅, u₅} E\ninst✝ : CategoryTheory.Category.{v₆, u₆} F\nG : CategoryTheory.Functor A D\nH : CategoryTheory.Functor B E\nK : CategoryTheory.Functor C F\nL₁ : CategoryTheory.Functor A B\nR₁ : CategoryTheory.Functor B A\nL₂ : CategoryTheory.Functor D E\nR₂ : CategoryTheory.Functor E D\nL₃ : CategoryTheory.Functor B C\nR₃ : CategoryTheory.Functor C B\nL₄ : CategoryTheory.Functor E F\nR₄ : CategoryTheory.Functor F E\nadj₁ : CategoryTheory.Adjunction L₁ R₁\nadj₂ : CategoryTheory.Adjunction L₂ R₂\nadj₃ : CategoryTheory.Adjunction L₃ R₃\nadj₄ : CategoryTheory.Adjunction L₄ R₄\nα : Quiver.Hom (G.comp L₂) (L₁.comp H)\nβ : Quiver.Hom (H.comp L₄) (L₃.comp K)\n⊢ Eq ((CategoryTheory.mateEquiv (adj₁.comp adj₃) (adj₂.comp adj₄)) (CategoryTheory.leftAdjointSquare.hcomp α β)) (CategoryTheory.rightAdjointSquare.hcomp ((CategoryTheory.mateEquiv adj₁ adj₂) α) ((CategoryTheory.mateEquiv adj₃ adj₄) β))","decl":"/-- The mates equivalence commutes with horizontal composition of squares. -/\ntheorem mateEquiv_hcomp\n    (α : G ⋙ L₂ ⟶ L₁ ⋙ H) (β : H ⋙ L₄ ⟶ L₃ ⋙ K) :\n    (mateEquiv (adj₁.comp adj₃) (adj₂.comp adj₄)) (leftAdjointSquare.hcomp α β) =\n      rightAdjointSquare.hcomp (mateEquiv adj₁ adj₂ α) (mateEquiv adj₃ adj₄ β) := by\n  unfold leftAdjointSquare.hcomp rightAdjointSquare.hcomp mateEquiv Adjunction.comp\n  ext c\n  dsimp\n  simp only [comp_id, map_comp, id_comp, assoc]\n  slice_rhs 2 4 =>\n    rw [← R₂.map_comp, ← R₂.map_comp, ← assoc, ← unit_naturality (adj₄)]\n  rw [R₂.map_comp, L₄.map_comp, R₄.map_comp, R₂.map_comp]\n  slice_rhs 4 5 =>\n    rw [← R₂.map_comp, ← R₄.map_comp, ← Functor.comp_map _ L₄ , β.naturality]\n  simp only [comp_obj, Functor.comp_map, map_comp, assoc]\n\n"}
{"name":"CategoryTheory.leftAdjointSquare.comp_vhcomp","module":"Mathlib.CategoryTheory.Adjunction.Mates","initialProofState":"A : Type u₁\nB : Type u₂\nC : Type u₃\nD : Type u₄\nE : Type u₅\nF : Type u₆\nX : Type u₇\nY : Type u₈\nZ : Type u₉\ninst✝⁸ : CategoryTheory.Category.{v₁, u₁} A\ninst✝⁷ : CategoryTheory.Category.{v₂, u₂} B\ninst✝⁶ : CategoryTheory.Category.{v₃, u₃} C\ninst✝⁵ : CategoryTheory.Category.{v₄, u₄} D\ninst✝⁴ : CategoryTheory.Category.{v₅, u₅} E\ninst✝³ : CategoryTheory.Category.{v₆, u₆} F\ninst✝² : CategoryTheory.Category.{v₇, u₇} X\ninst✝¹ : CategoryTheory.Category.{v₈, u₈} Y\ninst✝ : CategoryTheory.Category.{v₉, u₉} Z\nG₁ : CategoryTheory.Functor A D\nH₁ : CategoryTheory.Functor B E\nK₁ : CategoryTheory.Functor C F\nG₂ : CategoryTheory.Functor D X\nH₂ : CategoryTheory.Functor E Y\nK₂ : CategoryTheory.Functor F Z\nL₁ : CategoryTheory.Functor A B\nL₂ : CategoryTheory.Functor B C\nL₃ : CategoryTheory.Functor D E\nL₄ : CategoryTheory.Functor E F\nL₅ : CategoryTheory.Functor X Y\nL₆ : CategoryTheory.Functor Y Z\nα : Quiver.Hom (G₁.comp L₃) (L₁.comp H₁)\nβ : Quiver.Hom (H₁.comp L₄) (L₂.comp K₁)\nγ : Quiver.Hom (G₂.comp L₅) (L₃.comp H₂)\nδ : Quiver.Hom (H₂.comp L₆) (L₄.comp K₂)\n⊢ Eq (CategoryTheory.leftAdjointSquare.comp α β γ δ) (CategoryTheory.leftAdjointSquare.vcomp (CategoryTheory.leftAdjointSquare.hcomp α β) (CategoryTheory.leftAdjointSquare.hcomp γ δ))","decl":"theorem leftAdjointSquare.comp_vhcomp\n    (α : G₁ ⋙ L₃ ⟶ L₁ ⋙ H₁) (β : H₁ ⋙ L₄ ⟶ L₂ ⋙ K₁)\n    (γ : G₂ ⋙ L₅ ⟶ L₃ ⋙ H₂) (δ : H₂ ⋙ L₆ ⟶ L₄ ⋙ K₂) :\n    leftAdjointSquare.comp α β γ δ =\n      leftAdjointSquare.vcomp (leftAdjointSquare.hcomp α β) (leftAdjointSquare.hcomp γ δ) := rfl\n\n"}
{"name":"CategoryTheory.leftAdjointSquare.comp_hvcomp","module":"Mathlib.CategoryTheory.Adjunction.Mates","initialProofState":"A : Type u₁\nB : Type u₂\nC : Type u₃\nD : Type u₄\nE : Type u₅\nF : Type u₆\nX : Type u₇\nY : Type u₈\nZ : Type u₉\ninst✝⁸ : CategoryTheory.Category.{v₁, u₁} A\ninst✝⁷ : CategoryTheory.Category.{v₂, u₂} B\ninst✝⁶ : CategoryTheory.Category.{v₃, u₃} C\ninst✝⁵ : CategoryTheory.Category.{v₄, u₄} D\ninst✝⁴ : CategoryTheory.Category.{v₅, u₅} E\ninst✝³ : CategoryTheory.Category.{v₆, u₆} F\ninst✝² : CategoryTheory.Category.{v₇, u₇} X\ninst✝¹ : CategoryTheory.Category.{v₈, u₈} Y\ninst✝ : CategoryTheory.Category.{v₉, u₉} Z\nG₁ : CategoryTheory.Functor A D\nH₁ : CategoryTheory.Functor B E\nK₁ : CategoryTheory.Functor C F\nG₂ : CategoryTheory.Functor D X\nH₂ : CategoryTheory.Functor E Y\nK₂ : CategoryTheory.Functor F Z\nL₁ : CategoryTheory.Functor A B\nL₂ : CategoryTheory.Functor B C\nL₃ : CategoryTheory.Functor D E\nL₄ : CategoryTheory.Functor E F\nL₅ : CategoryTheory.Functor X Y\nL₆ : CategoryTheory.Functor Y Z\nα : Quiver.Hom (G₁.comp L₃) (L₁.comp H₁)\nβ : Quiver.Hom (H₁.comp L₄) (L₂.comp K₁)\nγ : Quiver.Hom (G₂.comp L₅) (L₃.comp H₂)\nδ : Quiver.Hom (H₂.comp L₆) (L₄.comp K₂)\n⊢ Eq (CategoryTheory.leftAdjointSquare.comp α β γ δ) (CategoryTheory.leftAdjointSquare.hcomp (CategoryTheory.leftAdjointSquare.vcomp α γ) (CategoryTheory.leftAdjointSquare.vcomp β δ))","decl":"/-- Horizontal and vertical composition of squares commutes.-/\ntheorem leftAdjointSquare.comp_hvcomp\n    (α : G₁ ⋙ L₃ ⟶ L₁ ⋙ H₁) (β : H₁ ⋙ L₄ ⟶ L₂ ⋙ K₁)\n    (γ : G₂ ⋙ L₅ ⟶ L₃ ⋙ H₂) (δ : H₂ ⋙ L₆ ⟶ L₄ ⋙ K₂) :\n    leftAdjointSquare.comp α β γ δ =\n      leftAdjointSquare.hcomp (leftAdjointSquare.vcomp α γ) (leftAdjointSquare.vcomp β δ) := by\n  unfold leftAdjointSquare.comp leftAdjointSquare.hcomp leftAdjointSquare.vcomp\n  unfold whiskerLeft whiskerRight\n  ext a\n  simp only [comp_obj, comp_app, map_comp, assoc]\n  slice_rhs 2 3 =>\n    rw [← Functor.comp_map _ L₆, δ.naturality]\n  simp only [comp_obj, Functor.comp_map, assoc]\n\n"}
{"name":"CategoryTheory.rightAdjointSquare.comp_vhcomp","module":"Mathlib.CategoryTheory.Adjunction.Mates","initialProofState":"A : Type u₁\nB : Type u₂\nC : Type u₃\nD : Type u₄\nE : Type u₅\nF : Type u₆\nX : Type u₇\nY : Type u₈\nZ : Type u₉\ninst✝⁸ : CategoryTheory.Category.{v₁, u₁} A\ninst✝⁷ : CategoryTheory.Category.{v₂, u₂} B\ninst✝⁶ : CategoryTheory.Category.{v₃, u₃} C\ninst✝⁵ : CategoryTheory.Category.{v₄, u₄} D\ninst✝⁴ : CategoryTheory.Category.{v₅, u₅} E\ninst✝³ : CategoryTheory.Category.{v₆, u₆} F\ninst✝² : CategoryTheory.Category.{v₇, u₇} X\ninst✝¹ : CategoryTheory.Category.{v₈, u₈} Y\ninst✝ : CategoryTheory.Category.{v₉, u₉} Z\nG₁ : CategoryTheory.Functor A D\nH₁ : CategoryTheory.Functor B E\nK₁ : CategoryTheory.Functor C F\nG₂ : CategoryTheory.Functor D X\nH₂ : CategoryTheory.Functor E Y\nK₂ : CategoryTheory.Functor F Z\nR₁ : CategoryTheory.Functor B A\nR₂ : CategoryTheory.Functor C B\nR₃ : CategoryTheory.Functor E D\nR₄ : CategoryTheory.Functor F E\nR₅ : CategoryTheory.Functor Y X\nR₆ : CategoryTheory.Functor Z Y\nα : Quiver.Hom (R₁.comp G₁) (H₁.comp R₃)\nβ : Quiver.Hom (R₂.comp H₁) (K₁.comp R₄)\nγ : Quiver.Hom (R₃.comp G₂) (H₂.comp R₅)\nδ : Quiver.Hom (R₄.comp H₂) (K₂.comp R₆)\n⊢ Eq (CategoryTheory.rightAdjointSquare.comp α β γ δ) (CategoryTheory.rightAdjointSquare.vcomp (CategoryTheory.rightAdjointSquare.hcomp α β) (CategoryTheory.rightAdjointSquare.hcomp γ δ))","decl":"theorem rightAdjointSquare.comp_vhcomp\n    (α : R₁ ⋙ G₁ ⟶ H₁ ⋙ R₃) (β : R₂ ⋙ H₁ ⟶ K₁ ⋙ R₄)\n    (γ : R₃ ⋙ G₂ ⟶ H₂ ⋙ R₅) (δ : R₄ ⋙ H₂ ⟶ K₂ ⋙ R₆) :\n    rightAdjointSquare.comp α β γ δ =\n    rightAdjointSquare.vcomp (rightAdjointSquare.hcomp α β) (rightAdjointSquare.hcomp γ δ) := rfl\n\n"}
{"name":"CategoryTheory.rightAdjointSquare.comp_hvcomp","module":"Mathlib.CategoryTheory.Adjunction.Mates","initialProofState":"A : Type u₁\nB : Type u₂\nC : Type u₃\nD : Type u₄\nE : Type u₅\nF : Type u₆\nX : Type u₇\nY : Type u₈\nZ : Type u₉\ninst✝⁸ : CategoryTheory.Category.{v₁, u₁} A\ninst✝⁷ : CategoryTheory.Category.{v₂, u₂} B\ninst✝⁶ : CategoryTheory.Category.{v₃, u₃} C\ninst✝⁵ : CategoryTheory.Category.{v₄, u₄} D\ninst✝⁴ : CategoryTheory.Category.{v₅, u₅} E\ninst✝³ : CategoryTheory.Category.{v₆, u₆} F\ninst✝² : CategoryTheory.Category.{v₇, u₇} X\ninst✝¹ : CategoryTheory.Category.{v₈, u₈} Y\ninst✝ : CategoryTheory.Category.{v₉, u₉} Z\nG₁ : CategoryTheory.Functor A D\nH₁ : CategoryTheory.Functor B E\nK₁ : CategoryTheory.Functor C F\nG₂ : CategoryTheory.Functor D X\nH₂ : CategoryTheory.Functor E Y\nK₂ : CategoryTheory.Functor F Z\nR₁ : CategoryTheory.Functor B A\nR₂ : CategoryTheory.Functor C B\nR₃ : CategoryTheory.Functor E D\nR₄ : CategoryTheory.Functor F E\nR₅ : CategoryTheory.Functor Y X\nR₆ : CategoryTheory.Functor Z Y\nα : Quiver.Hom (R₁.comp G₁) (H₁.comp R₃)\nβ : Quiver.Hom (R₂.comp H₁) (K₁.comp R₄)\nγ : Quiver.Hom (R₃.comp G₂) (H₂.comp R₅)\nδ : Quiver.Hom (R₄.comp H₂) (K₂.comp R₆)\n⊢ Eq (CategoryTheory.rightAdjointSquare.comp α β γ δ) (CategoryTheory.rightAdjointSquare.hcomp (CategoryTheory.rightAdjointSquare.vcomp α γ) (CategoryTheory.rightAdjointSquare.vcomp β δ))","decl":"/-- Horizontal and vertical composition of squares commutes.-/\ntheorem rightAdjointSquare.comp_hvcomp\n    (α : R₁ ⋙ G₁ ⟶ H₁ ⋙ R₃) (β : R₂ ⋙ H₁ ⟶ K₁ ⋙ R₄)\n    (γ : R₃ ⋙ G₂ ⟶ H₂ ⋙ R₅) (δ : R₄ ⋙ H₂ ⟶ K₂ ⋙ R₆) :\n    rightAdjointSquare.comp α β γ δ =\n    rightAdjointSquare.hcomp (rightAdjointSquare.vcomp α γ) (rightAdjointSquare.vcomp β δ) := by\n  unfold rightAdjointSquare.comp rightAdjointSquare.hcomp rightAdjointSquare.vcomp\n  unfold whiskerLeft whiskerRight\n  ext c\n  simp only [comp_obj, comp_app, map_comp, assoc]\n  slice_rhs 2 3 =>\n    rw [← Functor.comp_map _ R₅, ← γ.naturality]\n  simp only [comp_obj, Functor.comp_map, assoc]\n\n"}
{"name":"CategoryTheory.mateEquiv_square","module":"Mathlib.CategoryTheory.Adjunction.Mates","initialProofState":"A : Type u₁\nB : Type u₂\nC : Type u₃\nD : Type u₄\nE : Type u₅\nF : Type u₆\nX : Type u₇\nY : Type u₈\nZ : Type u₉\ninst✝⁸ : CategoryTheory.Category.{v₁, u₁} A\ninst✝⁷ : CategoryTheory.Category.{v₂, u₂} B\ninst✝⁶ : CategoryTheory.Category.{v₃, u₃} C\ninst✝⁵ : CategoryTheory.Category.{v₄, u₄} D\ninst✝⁴ : CategoryTheory.Category.{v₅, u₅} E\ninst✝³ : CategoryTheory.Category.{v₆, u₆} F\ninst✝² : CategoryTheory.Category.{v₇, u₇} X\ninst✝¹ : CategoryTheory.Category.{v₈, u₈} Y\ninst✝ : CategoryTheory.Category.{v₉, u₉} Z\nG₁ : CategoryTheory.Functor A D\nH₁ : CategoryTheory.Functor B E\nK₁ : CategoryTheory.Functor C F\nG₂ : CategoryTheory.Functor D X\nH₂ : CategoryTheory.Functor E Y\nK₂ : CategoryTheory.Functor F Z\nL₁ : CategoryTheory.Functor A B\nR₁ : CategoryTheory.Functor B A\nL₂ : CategoryTheory.Functor B C\nR₂ : CategoryTheory.Functor C B\nL₃ : CategoryTheory.Functor D E\nR₃ : CategoryTheory.Functor E D\nL₄ : CategoryTheory.Functor E F\nR₄ : CategoryTheory.Functor F E\nL₅ : CategoryTheory.Functor X Y\nR₅ : CategoryTheory.Functor Y X\nL₆ : CategoryTheory.Functor Y Z\nR₆ : CategoryTheory.Functor Z Y\nadj₁ : CategoryTheory.Adjunction L₁ R₁\nadj₂ : CategoryTheory.Adjunction L₂ R₂\nadj₃ : CategoryTheory.Adjunction L₃ R₃\nadj₄ : CategoryTheory.Adjunction L₄ R₄\nadj₅ : CategoryTheory.Adjunction L₅ R₅\nadj₆ : CategoryTheory.Adjunction L₆ R₆\nα : Quiver.Hom (G₁.comp L₃) (L₁.comp H₁)\nβ : Quiver.Hom (H₁.comp L₄) (L₂.comp K₁)\nγ : Quiver.Hom (G₂.comp L₅) (L₃.comp H₂)\nδ : Quiver.Hom (H₂.comp L₆) (L₄.comp K₂)\n⊢ Eq ((CategoryTheory.mateEquiv (adj₁.comp adj₂) (adj₅.comp adj₆)) (CategoryTheory.leftAdjointSquare.comp α β γ δ)) (CategoryTheory.rightAdjointSquare.comp ((CategoryTheory.mateEquiv adj₁ adj₃) α) ((CategoryTheory.mateEquiv adj₂ adj₄) β) ((CategoryTheory.mateEquiv adj₃ adj₅) γ) ((CategoryTheory.mateEquiv adj₄ adj₆) δ))","decl":"/-- The mates equivalence commutes with composition of squares of squares. These results form the\nbasis for an isomorphism of double categories to be proven later.\n-/\ntheorem mateEquiv_square\n    (α : G₁ ⋙ L₃ ⟶ L₁ ⋙ H₁) (β : H₁ ⋙ L₄ ⟶ L₂ ⋙ K₁)\n    (γ : G₂ ⋙ L₅ ⟶ L₃ ⋙ H₂) (δ : H₂ ⋙ L₆ ⟶ L₄ ⋙ K₂) :\n    (mateEquiv (G := G₁ ⋙ G₂) (H := K₁ ⋙ K₂) (adj₁.comp adj₂) (adj₅.comp adj₆))\n        (leftAdjointSquare.comp α β γ δ) =\n      rightAdjointSquare.comp\n        (mateEquiv adj₁ adj₃ α) (mateEquiv adj₂ adj₄ β)\n        (mateEquiv adj₃ adj₅ γ) (mateEquiv adj₄ adj₆ δ) := by\n  have vcomp :=\n    mateEquiv_vcomp (adj₁.comp adj₂) (adj₃.comp adj₄) (adj₅.comp adj₆)\n      (leftAdjointSquare.hcomp α β) (leftAdjointSquare.hcomp γ δ)\n  have hcomp1 := mateEquiv_hcomp adj₁ adj₃ adj₂ adj₄ α β\n  have hcomp2 := mateEquiv_hcomp adj₃ adj₅ adj₄ adj₆ γ δ\n  rw [hcomp1, hcomp2] at vcomp\n  exact vcomp\n\n"}
{"name":"CategoryTheory.conjugateEquiv_symm_apply_app","module":"Mathlib.CategoryTheory.Adjunction.Mates","initialProofState":"C : Type u₁\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nL₁ L₂ : CategoryTheory.Functor C D\nR₁ R₂ : CategoryTheory.Functor D C\nadj₁ : CategoryTheory.Adjunction L₁ R₁\nadj₂ : CategoryTheory.Adjunction L₂ R₂\na✝ : Quiver.Hom R₁ R₂\nX : C\n⊢ Eq (((CategoryTheory.conjugateEquiv adj₁ adj₂).symm a✝).app X) (CategoryTheory.CategoryStruct.comp (L₂.map (adj₁.unit.app X)) (CategoryTheory.CategoryStruct.comp (L₂.map (a✝.app (L₁.obj X))) (adj₂.counit.app (L₁.obj X))))","decl":"/-- Given two adjunctions `L₁ ⊣ R₁` and `L₂ ⊣ R₂` both between categories `C`, `D`, there is a\nbijection between natural transformations `L₂ ⟶ L₁` and natural transformations `R₁ ⟶ R₂`. This is\ndefined as a special case of `mateEquiv`, where the two \"vertical\" functors are identity, modulo\ncomposition with the unitors. Corresponding natural transformations are called `conjugateEquiv`.\nTODO: Generalise to when the two vertical functors are equivalences rather than being exactly `𝟭`.\n\nFurthermore, this bijection preserves (and reflects) isomorphisms, i.e. a transformation is an iso\niff its image under the bijection is an iso, see eg `CategoryTheory.conjugateIsoEquiv`.\nThis is in contrast to the general case `mateEquiv` which does not in general have this property.\n-/\n@[simps!]\ndef conjugateEquiv : (L₂ ⟶ L₁) ≃ (R₁ ⟶ R₂) :=\n  calc\n    (L₂ ⟶ L₁) ≃ _ := (Iso.homCongr L₂.leftUnitor L₁.rightUnitor).symm\n    _ ≃ _ := mateEquiv adj₁ adj₂\n    _ ≃ (R₁ ⟶ R₂) := R₁.rightUnitor.homCongr R₂.leftUnitor\n\n"}
{"name":"CategoryTheory.conjugateEquiv_apply_app","module":"Mathlib.CategoryTheory.Adjunction.Mates","initialProofState":"C : Type u₁\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nL₁ L₂ : CategoryTheory.Functor C D\nR₁ R₂ : CategoryTheory.Functor D C\nadj₁ : CategoryTheory.Adjunction L₁ R₁\nadj₂ : CategoryTheory.Adjunction L₂ R₂\na✝ : Quiver.Hom L₂ L₁\nX : D\n⊢ Eq (((CategoryTheory.conjugateEquiv adj₁ adj₂) a✝).app X) (CategoryTheory.CategoryStruct.comp (adj₂.unit.app (R₁.obj X)) (CategoryTheory.CategoryStruct.comp (R₂.map (a✝.app (R₁.obj X))) (R₂.map (adj₁.counit.app X))))","decl":"/-- Given two adjunctions `L₁ ⊣ R₁` and `L₂ ⊣ R₂` both between categories `C`, `D`, there is a\nbijection between natural transformations `L₂ ⟶ L₁` and natural transformations `R₁ ⟶ R₂`. This is\ndefined as a special case of `mateEquiv`, where the two \"vertical\" functors are identity, modulo\ncomposition with the unitors. Corresponding natural transformations are called `conjugateEquiv`.\nTODO: Generalise to when the two vertical functors are equivalences rather than being exactly `𝟭`.\n\nFurthermore, this bijection preserves (and reflects) isomorphisms, i.e. a transformation is an iso\niff its image under the bijection is an iso, see eg `CategoryTheory.conjugateIsoEquiv`.\nThis is in contrast to the general case `mateEquiv` which does not in general have this property.\n-/\n@[simps!]\ndef conjugateEquiv : (L₂ ⟶ L₁) ≃ (R₁ ⟶ R₂) :=\n  calc\n    (L₂ ⟶ L₁) ≃ _ := (Iso.homCongr L₂.leftUnitor L₁.rightUnitor).symm\n    _ ≃ _ := mateEquiv adj₁ adj₂\n    _ ≃ (R₁ ⟶ R₂) := R₁.rightUnitor.homCongr R₂.leftUnitor\n\n"}
{"name":"CategoryTheory.conjugateEquiv_counit","module":"Mathlib.CategoryTheory.Adjunction.Mates","initialProofState":"C : Type u₁\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nL₁ L₂ : CategoryTheory.Functor C D\nR₁ R₂ : CategoryTheory.Functor D C\nadj₁ : CategoryTheory.Adjunction L₁ R₁\nadj₂ : CategoryTheory.Adjunction L₂ R₂\nα : Quiver.Hom L₂ L₁\nd : D\n⊢ Eq (CategoryTheory.CategoryStruct.comp (L₂.map (((CategoryTheory.conjugateEquiv adj₁ adj₂) α).app d)) (adj₂.counit.app d)) (CategoryTheory.CategoryStruct.comp (α.app (R₁.obj d)) (adj₁.counit.app d))","decl":"/-- A component of a transposed form of the conjugation definition. -/\ntheorem conjugateEquiv_counit (α : L₂ ⟶ L₁) (d : D) :\n    L₂.map ((conjugateEquiv adj₁ adj₂ α).app _) ≫ adj₂.counit.app d =\n      α.app _ ≫ adj₁.counit.app d := by\n  dsimp [conjugateEquiv]\n  rw [id_comp, comp_id]\n  have := mateEquiv_counit adj₁ adj₂ (L₂.leftUnitor.hom ≫ α ≫ L₁.rightUnitor.inv) d\n  dsimp at this\n  rw [this]\n  simp only [comp_id, id_comp]\n\n"}
{"name":"CategoryTheory.conjugateEquiv_counit_symm","module":"Mathlib.CategoryTheory.Adjunction.Mates","initialProofState":"C : Type u₁\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nL₁ L₂ : CategoryTheory.Functor C D\nR₁ R₂ : CategoryTheory.Functor D C\nadj₁ : CategoryTheory.Adjunction L₁ R₁\nadj₂ : CategoryTheory.Adjunction L₂ R₂\nα : Quiver.Hom R₁ R₂\nd : D\n⊢ Eq (CategoryTheory.CategoryStruct.comp (L₂.map (α.app d)) (adj₂.counit.app d)) (CategoryTheory.CategoryStruct.comp (((CategoryTheory.conjugateEquiv adj₁ adj₂).symm α).app (R₁.obj d)) (adj₁.counit.app d))","decl":"/-- A component of a transposed form of the inverse conjugation definition. -/\ntheorem conjugateEquiv_counit_symm (α : R₁ ⟶ R₂) (d : D) :\n    L₂.map (α.app _) ≫ adj₂.counit.app d =\n      ((conjugateEquiv adj₁ adj₂).symm α).app _ ≫ adj₁.counit.app d := by\n    conv_lhs => rw [← (conjugateEquiv adj₁ adj₂).right_inv α]\n    exact (conjugateEquiv_counit adj₁ adj₂ ((conjugateEquiv adj₁ adj₂).symm α) d)\n\n"}
{"name":"CategoryTheory.unit_conjugateEquiv","module":"Mathlib.CategoryTheory.Adjunction.Mates","initialProofState":"C : Type u₁\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nL₁ L₂ : CategoryTheory.Functor C D\nR₁ R₂ : CategoryTheory.Functor D C\nadj₁ : CategoryTheory.Adjunction L₁ R₁\nadj₂ : CategoryTheory.Adjunction L₂ R₂\nα : Quiver.Hom L₂ L₁\nc : C\n⊢ Eq (CategoryTheory.CategoryStruct.comp (adj₁.unit.app c) (((CategoryTheory.conjugateEquiv adj₁ adj₂) α).app (L₁.obj c))) (CategoryTheory.CategoryStruct.comp (adj₂.unit.app c) (R₂.map (α.app c)))","decl":"/-- A component of a transposed form of the conjugation definition. -/\ntheorem unit_conjugateEquiv (α : L₂ ⟶ L₁) (c : C) :\n    adj₁.unit.app _ ≫ (conjugateEquiv adj₁ adj₂ α).app _ =\n      adj₂.unit.app c ≫ R₂.map (α.app _) := by\n  dsimp [conjugateEquiv]\n  rw [id_comp, comp_id]\n  have := unit_mateEquiv adj₁ adj₂ (L₂.leftUnitor.hom ≫ α ≫ L₁.rightUnitor.inv) c\n  dsimp at this\n  rw [this]\n  simp\n\n"}
{"name":"CategoryTheory.unit_conjugateEquiv_symm","module":"Mathlib.CategoryTheory.Adjunction.Mates","initialProofState":"C : Type u₁\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nL₁ L₂ : CategoryTheory.Functor C D\nR₁ R₂ : CategoryTheory.Functor D C\nadj₁ : CategoryTheory.Adjunction L₁ R₁\nadj₂ : CategoryTheory.Adjunction L₂ R₂\nα : Quiver.Hom R₁ R₂\nc : C\n⊢ Eq (CategoryTheory.CategoryStruct.comp (adj₁.unit.app c) (α.app (L₁.obj c))) (CategoryTheory.CategoryStruct.comp (adj₂.unit.app c) (R₂.map (((CategoryTheory.conjugateEquiv adj₁ adj₂).symm α).app c)))","decl":"/-- A component of a transposed form of the inverse conjugation definition. -/\ntheorem unit_conjugateEquiv_symm (α : R₁ ⟶ R₂) (c : C) :\n    adj₁.unit.app _ ≫ α.app _ =\n      adj₂.unit.app c ≫ R₂.map (((conjugateEquiv adj₁ adj₂).symm α).app _) := by\n    conv_lhs => rw [← (conjugateEquiv adj₁ adj₂).right_inv α]\n    exact (unit_conjugateEquiv adj₁ adj₂ ((conjugateEquiv adj₁ adj₂).symm α) c)\n\n"}
{"name":"CategoryTheory.conjugateEquiv_id","module":"Mathlib.CategoryTheory.Adjunction.Mates","initialProofState":"C : Type u₁\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nL₁ : CategoryTheory.Functor C D\nR₁ : CategoryTheory.Functor D C\nadj₁ : CategoryTheory.Adjunction L₁ R₁\n⊢ Eq ((CategoryTheory.conjugateEquiv adj₁ adj₁) (CategoryTheory.CategoryStruct.id L₁)) (CategoryTheory.CategoryStruct.id R₁)","decl":"@[simp]\ntheorem conjugateEquiv_id : conjugateEquiv adj₁ adj₁ (𝟙 _) = 𝟙 _ := by\n  ext\n  dsimp [conjugateEquiv, mateEquiv]\n  simp only [comp_id, map_id, id_comp, right_triangle_components]\n\n"}
{"name":"CategoryTheory.conjugateEquiv_symm_id","module":"Mathlib.CategoryTheory.Adjunction.Mates","initialProofState":"C : Type u₁\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nL₁ : CategoryTheory.Functor C D\nR₁ : CategoryTheory.Functor D C\nadj₁ : CategoryTheory.Adjunction L₁ R₁\n⊢ Eq ((CategoryTheory.conjugateEquiv adj₁ adj₁).symm (CategoryTheory.CategoryStruct.id R₁)) (CategoryTheory.CategoryStruct.id L₁)","decl":"@[simp]\ntheorem conjugateEquiv_symm_id : (conjugateEquiv adj₁ adj₁).symm (𝟙 _) = 𝟙 _ := by\n  rw [Equiv.symm_apply_eq]\n  simp only [conjugateEquiv_id]\n\n"}
{"name":"CategoryTheory.conjugateEquiv_adjunction_id","module":"Mathlib.CategoryTheory.Adjunction.Mates","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nL R : CategoryTheory.Functor C C\nadj : CategoryTheory.Adjunction L R\nα : Quiver.Hom (CategoryTheory.Functor.id C) L\nc : C\n⊢ Eq (((CategoryTheory.conjugateEquiv adj CategoryTheory.Adjunction.id) α).app c) (CategoryTheory.CategoryStruct.comp (α.app (R.obj c)) (adj.counit.app c))","decl":"theorem conjugateEquiv_adjunction_id {L R : C ⥤ C} (adj : L ⊣ R) (α : 𝟭 C ⟶ L) (c : C) :\n    (conjugateEquiv adj Adjunction.id α).app c = α.app (R.obj c) ≫ adj.counit.app c := by\n  dsimp [conjugateEquiv, mateEquiv, Adjunction.id]\n  simp only [comp_id, id_comp]\n\n"}
{"name":"CategoryTheory.conjugateEquiv_adjunction_id_symm","module":"Mathlib.CategoryTheory.Adjunction.Mates","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nL R : CategoryTheory.Functor C C\nadj : CategoryTheory.Adjunction L R\nα : Quiver.Hom R (CategoryTheory.Functor.id C)\nc : C\n⊢ Eq (((CategoryTheory.conjugateEquiv adj CategoryTheory.Adjunction.id).symm α).app c) (CategoryTheory.CategoryStruct.comp (adj.unit.app c) (α.app (L.obj c)))","decl":"theorem conjugateEquiv_adjunction_id_symm {L R : C ⥤ C} (adj : L ⊣ R) (α : R ⟶ 𝟭 C) (c : C) :\n    ((conjugateEquiv adj Adjunction.id).symm α).app c = adj.unit.app c ≫ α.app (L.obj c) := by\n  dsimp [conjugateEquiv, mateEquiv, Adjunction.id]\n  simp only [comp_id, id_comp]\n"}
{"name":"CategoryTheory.conjugateEquiv_comp","module":"Mathlib.CategoryTheory.Adjunction.Mates","initialProofState":"C : Type u₁\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nL₁ L₂ L₃ : CategoryTheory.Functor C D\nR₁ R₂ R₃ : CategoryTheory.Functor D C\nadj₁ : CategoryTheory.Adjunction L₁ R₁\nadj₂ : CategoryTheory.Adjunction L₂ R₂\nadj₃ : CategoryTheory.Adjunction L₃ R₃\nα : Quiver.Hom L₂ L₁\nβ : Quiver.Hom L₃ L₂\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.conjugateEquiv adj₁ adj₂) α) ((CategoryTheory.conjugateEquiv adj₂ adj₃) β)) ((CategoryTheory.conjugateEquiv adj₁ adj₃) (CategoryTheory.CategoryStruct.comp β α))","decl":"@[simp]\ntheorem conjugateEquiv_comp (α : L₂ ⟶ L₁) (β : L₃ ⟶ L₂) :\n    conjugateEquiv adj₁ adj₂ α ≫ conjugateEquiv adj₂ adj₃ β =\n      conjugateEquiv adj₁ adj₃ (β ≫ α) := by\n  ext d\n  dsimp [conjugateEquiv, mateEquiv]\n  have vcomp := mateEquiv_vcomp adj₁ adj₂ adj₃\n    (L₂.leftUnitor.hom ≫ α ≫ L₁.rightUnitor.inv)\n    (L₃.leftUnitor.hom ≫ β ≫ L₂.rightUnitor.inv)\n  have vcompd := congr_app vcomp d\n  dsimp [mateEquiv, leftAdjointSquare.vcomp, rightAdjointSquare.vcomp] at vcompd\n  simp only [comp_id, id_comp, assoc, map_comp] at vcompd ⊢\n  rw [vcompd]\n\n"}
{"name":"CategoryTheory.conjugateEquiv_symm_comp","module":"Mathlib.CategoryTheory.Adjunction.Mates","initialProofState":"C : Type u₁\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nL₁ L₂ L₃ : CategoryTheory.Functor C D\nR₁ R₂ R₃ : CategoryTheory.Functor D C\nadj₁ : CategoryTheory.Adjunction L₁ R₁\nadj₂ : CategoryTheory.Adjunction L₂ R₂\nadj₃ : CategoryTheory.Adjunction L₃ R₃\nα : Quiver.Hom R₁ R₂\nβ : Quiver.Hom R₂ R₃\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.conjugateEquiv adj₂ adj₃).symm β) ((CategoryTheory.conjugateEquiv adj₁ adj₂).symm α)) ((CategoryTheory.conjugateEquiv adj₁ adj₃).symm (CategoryTheory.CategoryStruct.comp α β))","decl":"@[simp]\ntheorem conjugateEquiv_symm_comp (α : R₁ ⟶ R₂) (β : R₂ ⟶ R₃) :\n    (conjugateEquiv adj₂ adj₃).symm β ≫ (conjugateEquiv adj₁ adj₂).symm α =\n      (conjugateEquiv adj₁ adj₃).symm (α ≫ β) := by\n  rw [Equiv.eq_symm_apply, ← conjugateEquiv_comp _ adj₂]\n  simp only [Equiv.apply_symm_apply]\n\n"}
{"name":"CategoryTheory.conjugateEquiv_comm","module":"Mathlib.CategoryTheory.Adjunction.Mates","initialProofState":"C : Type u₁\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nL₁ L₂ : CategoryTheory.Functor C D\nR₁ R₂ : CategoryTheory.Functor D C\nadj₁ : CategoryTheory.Adjunction L₁ R₁\nadj₂ : CategoryTheory.Adjunction L₂ R₂\nα : Quiver.Hom L₂ L₁\nβ : Quiver.Hom L₁ L₂\nβα : Eq (CategoryTheory.CategoryStruct.comp β α) (CategoryTheory.CategoryStruct.id L₁)\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.conjugateEquiv adj₁ adj₂) α) ((CategoryTheory.conjugateEquiv adj₂ adj₁) β)) (CategoryTheory.CategoryStruct.id R₁)","decl":"theorem conjugateEquiv_comm {α : L₂ ⟶ L₁} {β : L₁ ⟶ L₂} (βα : β ≫ α = 𝟙 _) :\n    conjugateEquiv adj₁ adj₂ α ≫ conjugateEquiv adj₂ adj₁ β = 𝟙 _ := by\n  rw [conjugateEquiv_comp, βα, conjugateEquiv_id]\n\n"}
{"name":"CategoryTheory.conjugateEquiv_symm_comm","module":"Mathlib.CategoryTheory.Adjunction.Mates","initialProofState":"C : Type u₁\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nL₁ L₂ : CategoryTheory.Functor C D\nR₁ R₂ : CategoryTheory.Functor D C\nadj₁ : CategoryTheory.Adjunction L₁ R₁\nadj₂ : CategoryTheory.Adjunction L₂ R₂\nα : Quiver.Hom R₁ R₂\nβ : Quiver.Hom R₂ R₁\nαβ : Eq (CategoryTheory.CategoryStruct.comp α β) (CategoryTheory.CategoryStruct.id R₁)\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.conjugateEquiv adj₂ adj₁).symm β) ((CategoryTheory.conjugateEquiv adj₁ adj₂).symm α)) (CategoryTheory.CategoryStruct.id L₁)","decl":"theorem conjugateEquiv_symm_comm {α : R₁ ⟶ R₂} {β : R₂ ⟶ R₁} (αβ : α ≫ β = 𝟙 _) :\n    (conjugateEquiv adj₂ adj₁).symm β ≫ (conjugateEquiv adj₁ adj₂).symm α = 𝟙 _ := by\n  rw [conjugateEquiv_symm_comp, αβ, conjugateEquiv_symm_id]\n\n"}
{"name":"CategoryTheory.conjugateEquiv_iso","module":"Mathlib.CategoryTheory.Adjunction.Mates","initialProofState":"C : Type u₁\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nL₁ L₂ : CategoryTheory.Functor C D\nR₁ R₂ : CategoryTheory.Functor D C\nadj₁ : CategoryTheory.Adjunction L₁ R₁\nadj₂ : CategoryTheory.Adjunction L₂ R₂\nα : Quiver.Hom L₂ L₁\ninst✝ : CategoryTheory.IsIso α\n⊢ CategoryTheory.IsIso ((CategoryTheory.conjugateEquiv adj₁ adj₂) α)","decl":"/-- If `α` is an isomorphism between left adjoints, then its conjugate transformation is an\nisomorphism. The converse is given in `conjugateEquiv_of_iso`.\n-/\ninstance conjugateEquiv_iso (α : L₂ ⟶ L₁) [IsIso α] :\n    IsIso (conjugateEquiv adj₁ adj₂ α) :=\n  ⟨⟨conjugateEquiv adj₂ adj₁ (inv α),\n      ⟨conjugateEquiv_comm _ _ (by simp), conjugateEquiv_comm _ _ (by simp)⟩⟩⟩\n\n"}
{"name":"CategoryTheory.conjugateEquiv_symm_iso","module":"Mathlib.CategoryTheory.Adjunction.Mates","initialProofState":"C : Type u₁\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nL₁ L₂ : CategoryTheory.Functor C D\nR₁ R₂ : CategoryTheory.Functor D C\nadj₁ : CategoryTheory.Adjunction L₁ R₁\nadj₂ : CategoryTheory.Adjunction L₂ R₂\nα : Quiver.Hom R₁ R₂\ninst✝ : CategoryTheory.IsIso α\n⊢ CategoryTheory.IsIso ((CategoryTheory.conjugateEquiv adj₁ adj₂).symm α)","decl":"/-- If `α` is an isomorphism between right adjoints, then its conjugate transformation is an\nisomorphism. The converse is given in `conjugateEquiv_symm_of_iso`.\n-/\ninstance conjugateEquiv_symm_iso (α : R₁ ⟶ R₂) [IsIso α] :\n    IsIso ((conjugateEquiv adj₁ adj₂).symm α) :=\n  ⟨⟨(conjugateEquiv adj₂ adj₁).symm (inv α),\n      ⟨conjugateEquiv_symm_comm _ _ (by simp), conjugateEquiv_symm_comm _ _ (by simp)⟩⟩⟩\n\n"}
{"name":"CategoryTheory.conjugateEquiv_of_iso","module":"Mathlib.CategoryTheory.Adjunction.Mates","initialProofState":"C : Type u₁\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nL₁ L₂ : CategoryTheory.Functor C D\nR₁ R₂ : CategoryTheory.Functor D C\nadj₁ : CategoryTheory.Adjunction L₁ R₁\nadj₂ : CategoryTheory.Adjunction L₂ R₂\nα : Quiver.Hom L₂ L₁\ninst✝ : CategoryTheory.IsIso ((CategoryTheory.conjugateEquiv adj₁ adj₂) α)\n⊢ CategoryTheory.IsIso α","decl":"/-- If `α` is a natural transformation between left adjoints whose conjugate natural transformation\nis an isomorphism, then `α` is an isomorphism. The converse is given in `Conjugate_iso`.\n-/\ntheorem conjugateEquiv_of_iso (α : L₂ ⟶ L₁) [IsIso (conjugateEquiv adj₁ adj₂ α)] :\n    IsIso α := by\n  suffices IsIso ((conjugateEquiv adj₁ adj₂).symm (conjugateEquiv adj₁ adj₂ α))\n    by simpa using this\n  infer_instance\n\n"}
{"name":"CategoryTheory.conjugateEquiv_symm_of_iso","module":"Mathlib.CategoryTheory.Adjunction.Mates","initialProofState":"C : Type u₁\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nL₁ L₂ : CategoryTheory.Functor C D\nR₁ R₂ : CategoryTheory.Functor D C\nadj₁ : CategoryTheory.Adjunction L₁ R₁\nadj₂ : CategoryTheory.Adjunction L₂ R₂\nα : Quiver.Hom R₁ R₂\ninst✝ : CategoryTheory.IsIso ((CategoryTheory.conjugateEquiv adj₁ adj₂).symm α)\n⊢ CategoryTheory.IsIso α","decl":"/--\nIf `α` is a natural transformation between right adjoints whose conjugate natural transformation is\nan isomorphism, then `α` is an isomorphism. The converse is given in `conjugateEquiv_symm_iso`.\n-/\ntheorem conjugateEquiv_symm_of_iso (α : R₁ ⟶ R₂)\n    [IsIso ((conjugateEquiv adj₁ adj₂).symm α)] : IsIso α := by\n  suffices IsIso ((conjugateEquiv adj₁ adj₂) ((conjugateEquiv adj₁ adj₂).symm α))\n    by simpa using this\n  infer_instance\n\n"}
{"name":"CategoryTheory.conjugateIsoEquiv_symm_apply_hom","module":"Mathlib.CategoryTheory.Adjunction.Mates","initialProofState":"C : Type u₁\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nL₁ L₂ : CategoryTheory.Functor C D\nR₁ R₂ : CategoryTheory.Functor D C\nadj₁ : CategoryTheory.Adjunction L₁ R₁\nadj₂ : CategoryTheory.Adjunction L₂ R₂\nβ : CategoryTheory.Iso R₁ R₂\n⊢ Eq ((CategoryTheory.conjugateIsoEquiv adj₁ adj₂).symm β).hom ((CategoryTheory.conjugateEquiv adj₁ adj₂).symm β.hom)","decl":"/-- Thus conjugation defines an equivalence between natural isomorphisms. -/\n@[simps]\ndef conjugateIsoEquiv : (L₂ ≅ L₁) ≃ (R₁ ≅ R₂) where\n  toFun α := {\n    hom := conjugateEquiv adj₁ adj₂ α.hom\n    inv := conjugateEquiv adj₂ adj₁ α.inv\n  }\n  invFun β := {\n    hom := (conjugateEquiv adj₁ adj₂).symm β.hom\n    inv := (conjugateEquiv adj₂ adj₁).symm β.inv\n  }\n  left_inv := by aesop_cat\n  right_inv := by aesop_cat\n\n"}
{"name":"CategoryTheory.conjugateIsoEquiv_symm_apply_inv","module":"Mathlib.CategoryTheory.Adjunction.Mates","initialProofState":"C : Type u₁\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nL₁ L₂ : CategoryTheory.Functor C D\nR₁ R₂ : CategoryTheory.Functor D C\nadj₁ : CategoryTheory.Adjunction L₁ R₁\nadj₂ : CategoryTheory.Adjunction L₂ R₂\nβ : CategoryTheory.Iso R₁ R₂\n⊢ Eq ((CategoryTheory.conjugateIsoEquiv adj₁ adj₂).symm β).inv ((CategoryTheory.conjugateEquiv adj₂ adj₁).symm β.inv)","decl":"/-- Thus conjugation defines an equivalence between natural isomorphisms. -/\n@[simps]\ndef conjugateIsoEquiv : (L₂ ≅ L₁) ≃ (R₁ ≅ R₂) where\n  toFun α := {\n    hom := conjugateEquiv adj₁ adj₂ α.hom\n    inv := conjugateEquiv adj₂ adj₁ α.inv\n  }\n  invFun β := {\n    hom := (conjugateEquiv adj₁ adj₂).symm β.hom\n    inv := (conjugateEquiv adj₂ adj₁).symm β.inv\n  }\n  left_inv := by aesop_cat\n  right_inv := by aesop_cat\n\n"}
{"name":"CategoryTheory.conjugateIsoEquiv_apply_inv","module":"Mathlib.CategoryTheory.Adjunction.Mates","initialProofState":"C : Type u₁\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nL₁ L₂ : CategoryTheory.Functor C D\nR₁ R₂ : CategoryTheory.Functor D C\nadj₁ : CategoryTheory.Adjunction L₁ R₁\nadj₂ : CategoryTheory.Adjunction L₂ R₂\nα : CategoryTheory.Iso L₂ L₁\n⊢ Eq ((CategoryTheory.conjugateIsoEquiv adj₁ adj₂) α).inv ((CategoryTheory.conjugateEquiv adj₂ adj₁) α.inv)","decl":"/-- Thus conjugation defines an equivalence between natural isomorphisms. -/\n@[simps]\ndef conjugateIsoEquiv : (L₂ ≅ L₁) ≃ (R₁ ≅ R₂) where\n  toFun α := {\n    hom := conjugateEquiv adj₁ adj₂ α.hom\n    inv := conjugateEquiv adj₂ adj₁ α.inv\n  }\n  invFun β := {\n    hom := (conjugateEquiv adj₁ adj₂).symm β.hom\n    inv := (conjugateEquiv adj₂ adj₁).symm β.inv\n  }\n  left_inv := by aesop_cat\n  right_inv := by aesop_cat\n\n"}
{"name":"CategoryTheory.conjugateIsoEquiv_apply_hom","module":"Mathlib.CategoryTheory.Adjunction.Mates","initialProofState":"C : Type u₁\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nL₁ L₂ : CategoryTheory.Functor C D\nR₁ R₂ : CategoryTheory.Functor D C\nadj₁ : CategoryTheory.Adjunction L₁ R₁\nadj₂ : CategoryTheory.Adjunction L₂ R₂\nα : CategoryTheory.Iso L₂ L₁\n⊢ Eq ((CategoryTheory.conjugateIsoEquiv adj₁ adj₂) α).hom ((CategoryTheory.conjugateEquiv adj₁ adj₂) α.hom)","decl":"/-- Thus conjugation defines an equivalence between natural isomorphisms. -/\n@[simps]\ndef conjugateIsoEquiv : (L₂ ≅ L₁) ≃ (R₁ ≅ R₂) where\n  toFun α := {\n    hom := conjugateEquiv adj₁ adj₂ α.hom\n    inv := conjugateEquiv adj₂ adj₁ α.inv\n  }\n  invFun β := {\n    hom := (conjugateEquiv adj₁ adj₂).symm β.hom\n    inv := (conjugateEquiv adj₂ adj₁).symm β.inv\n  }\n  left_inv := by aesop_cat\n  right_inv := by aesop_cat\n\n"}
{"name":"CategoryTheory.iterated_mateEquiv_conjugateEquiv","module":"Mathlib.CategoryTheory.Adjunction.Mates","initialProofState":"A : Type u₁\nB : Type u₂\nC : Type u₃\nD : Type u₄\ninst✝³ : CategoryTheory.Category.{v₁, u₁} A\ninst✝² : CategoryTheory.Category.{v₂, u₂} B\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} C\ninst✝ : CategoryTheory.Category.{v₄, u₄} D\nF₁ : CategoryTheory.Functor A C\nU₁ : CategoryTheory.Functor C A\nF₂ : CategoryTheory.Functor B D\nU₂ : CategoryTheory.Functor D B\nL₁ : CategoryTheory.Functor A B\nR₁ : CategoryTheory.Functor B A\nL₂ : CategoryTheory.Functor C D\nR₂ : CategoryTheory.Functor D C\nadj₁ : CategoryTheory.Adjunction L₁ R₁\nadj₂ : CategoryTheory.Adjunction L₂ R₂\nadj₃ : CategoryTheory.Adjunction F₁ U₁\nadj₄ : CategoryTheory.Adjunction F₂ U₂\nα : Quiver.Hom (F₁.comp L₂) (L₁.comp F₂)\n⊢ Eq ((CategoryTheory.mateEquiv adj₄ adj₃) ((CategoryTheory.mateEquiv adj₁ adj₂) α)) ((CategoryTheory.conjugateEquiv (adj₁.comp adj₄) (adj₃.comp adj₂)) α)","decl":"/-- When all four functors in a sequare are left adjoints, the mates operation can be iterated:\n\n         L₁                  R₁                  R₁\n      C --→ D             C ←-- D             C ←-- D\n   F₁ ↓  ↗  ↓  F₂      F₁ ↓  ↘  ↓ F₂       U₁ ↑  ↙  ↑ U₂\n      E --→ F             E ←-- F             E ←-- F\n         L₂                  R₂                  R₂\n\nIn this case the iterated mate equals the conjugate of the original transformation and is thus an\nisomorphism if and only if the original transformation is. This explains why some Beck-Chevalley\nnatural transformations are natural isomorphisms.\n-/\ntheorem iterated_mateEquiv_conjugateEquiv (α : F₁ ⋙ L₂ ⟶ L₁ ⋙ F₂) :\n    mateEquiv adj₄ adj₃ (mateEquiv adj₁ adj₂ α) =\n      conjugateEquiv (adj₁.comp adj₄) (adj₃.comp adj₂) α := by\n  ext d\n  unfold conjugateEquiv mateEquiv Adjunction.comp\n  simp\n\n"}
{"name":"CategoryTheory.iterated_mateEquiv_conjugateEquiv_symm","module":"Mathlib.CategoryTheory.Adjunction.Mates","initialProofState":"A : Type u₁\nB : Type u₂\nC : Type u₃\nD : Type u₄\ninst✝³ : CategoryTheory.Category.{v₁, u₁} A\ninst✝² : CategoryTheory.Category.{v₂, u₂} B\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} C\ninst✝ : CategoryTheory.Category.{v₄, u₄} D\nF₁ : CategoryTheory.Functor A C\nU₁ : CategoryTheory.Functor C A\nF₂ : CategoryTheory.Functor B D\nU₂ : CategoryTheory.Functor D B\nL₁ : CategoryTheory.Functor A B\nR₁ : CategoryTheory.Functor B A\nL₂ : CategoryTheory.Functor C D\nR₂ : CategoryTheory.Functor D C\nadj₁ : CategoryTheory.Adjunction L₁ R₁\nadj₂ : CategoryTheory.Adjunction L₂ R₂\nadj₃ : CategoryTheory.Adjunction F₁ U₁\nadj₄ : CategoryTheory.Adjunction F₂ U₂\nα : Quiver.Hom (U₂.comp R₁) (R₂.comp U₁)\n⊢ Eq ((CategoryTheory.mateEquiv adj₁ adj₂).symm ((CategoryTheory.mateEquiv adj₄ adj₃).symm α)) ((CategoryTheory.conjugateEquiv (adj₁.comp adj₄) (adj₃.comp adj₂)).symm α)","decl":"theorem iterated_mateEquiv_conjugateEquiv_symm (α : U₂ ⋙ R₁ ⟶ R₂ ⋙ U₁) :\n    (mateEquiv adj₁ adj₂).symm ((mateEquiv adj₄ adj₃).symm α) =\n      (conjugateEquiv (adj₁.comp adj₄) (adj₃.comp adj₂)).symm α := by\n  rw [Equiv.eq_symm_apply, ← iterated_mateEquiv_conjugateEquiv]\n  simp only [Equiv.apply_symm_apply]\n\n"}
{"name":"CategoryTheory.mateEquiv_conjugateEquiv_vcomp","module":"Mathlib.CategoryTheory.Adjunction.Mates","initialProofState":"A : Type u₁\nB : Type u₂\nC : Type u₃\nD : Type u₄\ninst✝³ : CategoryTheory.Category.{v₁, u₁} A\ninst✝² : CategoryTheory.Category.{v₂, u₂} B\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} C\ninst✝ : CategoryTheory.Category.{v₄, u₄} D\nG : CategoryTheory.Functor A C\nH : CategoryTheory.Functor B D\nL₁ : CategoryTheory.Functor A B\nR₁ : CategoryTheory.Functor B A\nL₂ : CategoryTheory.Functor C D\nR₂ : CategoryTheory.Functor D C\nL₃ : CategoryTheory.Functor C D\nR₃ : CategoryTheory.Functor D C\nadj₁ : CategoryTheory.Adjunction L₁ R₁\nadj₂ : CategoryTheory.Adjunction L₂ R₂\nadj₃ : CategoryTheory.Adjunction L₃ R₃\nα : Quiver.Hom (G.comp L₂) (L₁.comp H)\nβ : Quiver.Hom L₃ L₂\n⊢ Eq ((CategoryTheory.mateEquiv adj₁ adj₃) (CategoryTheory.leftAdjointSquareConjugate.vcomp α β)) (CategoryTheory.rightAdjointSquareConjugate.vcomp ((CategoryTheory.mateEquiv adj₁ adj₂) α) ((CategoryTheory.conjugateEquiv adj₂ adj₃) β))","decl":"/-- The mates equivalence commutes with this composition, essentially by `mateEquiv_vcomp`. -/\ntheorem mateEquiv_conjugateEquiv_vcomp\n    (α : G ⋙ L₂ ⟶ L₁ ⋙ H) (β : L₃ ⟶ L₂) :\n    (mateEquiv adj₁ adj₃) (leftAdjointSquareConjugate.vcomp α β) =\n      rightAdjointSquareConjugate.vcomp (mateEquiv adj₁ adj₂ α) (conjugateEquiv adj₂ adj₃ β) := by\n  ext b\n  have vcomp := mateEquiv_vcomp adj₁ adj₂ adj₃ α (L₃.leftUnitor.hom ≫ β ≫ L₂.rightUnitor.inv)\n  unfold leftAdjointSquare.vcomp rightAdjointSquare.vcomp at vcomp\n  unfold leftAdjointSquareConjugate.vcomp rightAdjointSquareConjugate.vcomp conjugateEquiv\n  have vcompb := congr_app vcomp b\n  simp at vcompb\n  unfold mateEquiv\n  simp only [comp_obj, Equiv.coe_fn_mk, whiskerLeft_comp, whiskerLeft_twice, whiskerRight_comp,\n    assoc, comp_app, whiskerLeft_app, whiskerRight_app, id_obj, Functor.comp_map, Iso.homCongr_symm,\n    Equiv.instTrans_trans, Equiv.trans_apply, Iso.homCongr_apply, Iso.symm_inv, Iso.symm_hom,\n    rightUnitor_inv_app, leftUnitor_hom_app, map_id, Functor.id_map, comp_id, id_comp]\n  exact vcompb\n\n"}
{"name":"CategoryTheory.conjugateEquiv_mateEquiv_vcomp","module":"Mathlib.CategoryTheory.Adjunction.Mates","initialProofState":"A : Type u₁\nB : Type u₂\nC : Type u₃\nD : Type u₄\ninst✝³ : CategoryTheory.Category.{v₁, u₁} A\ninst✝² : CategoryTheory.Category.{v₂, u₂} B\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} C\ninst✝ : CategoryTheory.Category.{v₄, u₄} D\nG : CategoryTheory.Functor A C\nH : CategoryTheory.Functor B D\nL₁ : CategoryTheory.Functor A B\nR₁ : CategoryTheory.Functor B A\nL₂ : CategoryTheory.Functor A B\nR₂ : CategoryTheory.Functor B A\nL₃ : CategoryTheory.Functor C D\nR₃ : CategoryTheory.Functor D C\nadj₁ : CategoryTheory.Adjunction L₁ R₁\nadj₂ : CategoryTheory.Adjunction L₂ R₂\nadj₃ : CategoryTheory.Adjunction L₃ R₃\nα : Quiver.Hom L₂ L₁\nβ : Quiver.Hom (G.comp L₃) (L₂.comp H)\n⊢ Eq ((CategoryTheory.mateEquiv adj₁ adj₃) (CategoryTheory.leftAdjointConjugateSquare.vcomp α β)) (CategoryTheory.rightAdjointConjugateSquare.vcomp ((CategoryTheory.conjugateEquiv adj₁ adj₂) α) ((CategoryTheory.mateEquiv adj₂ adj₃) β))","decl":"/-- The mates equivalence commutes with this composition, essentially by `mateEquiv_vcomp`. -/\ntheorem conjugateEquiv_mateEquiv_vcomp\n    (α : L₂ ⟶ L₁) (β : G ⋙ L₃ ⟶ L₂ ⋙ H) :\n    (mateEquiv adj₁ adj₃) (leftAdjointConjugateSquare.vcomp α β) =\n      rightAdjointConjugateSquare.vcomp (conjugateEquiv adj₁ adj₂ α) (mateEquiv adj₂ adj₃ β) := by\n  ext b\n  have vcomp := mateEquiv_vcomp adj₁ adj₂ adj₃ (L₂.leftUnitor.hom ≫ α ≫ L₁.rightUnitor.inv) β\n  unfold leftAdjointSquare.vcomp rightAdjointSquare.vcomp at vcomp\n  unfold leftAdjointConjugateSquare.vcomp rightAdjointConjugateSquare.vcomp conjugateEquiv\n  have vcompb := congr_app vcomp b\n  simp at vcompb\n  unfold mateEquiv\n  simp only [comp_obj, Equiv.coe_fn_mk, whiskerLeft_comp, whiskerLeft_twice, whiskerRight_comp,\n    assoc, comp_app, whiskerLeft_app, whiskerRight_app, id_obj, Functor.comp_map, Iso.homCongr_symm,\n    Equiv.instTrans_trans, Equiv.trans_apply, Iso.homCongr_apply, Iso.symm_inv, Iso.symm_hom,\n    rightUnitor_inv_app, leftUnitor_hom_app, map_id, Functor.id_map, comp_id, id_comp]\n  exact vcompb\n\n"}
