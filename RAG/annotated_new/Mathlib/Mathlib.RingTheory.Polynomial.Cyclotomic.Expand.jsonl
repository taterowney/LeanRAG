{"name":"Polynomial.cyclotomic_expand_eq_cyclotomic_mul","module":"Mathlib.RingTheory.Polynomial.Cyclotomic.Expand","initialProofState":"p n : Nat\nhp : Nat.Prime p\nhdiv : Not (Dvd.dvd p n)\nR : Type u_1\ninst✝ : CommRing R\n⊢ Eq ((Polynomial.expand R p) (Polynomial.cyclotomic n R)) (HMul.hMul (Polynomial.cyclotomic (HMul.hMul n p) R) (Polynomial.cyclotomic n R))","decl":"/-- If `p` is a prime such that `¬ p ∣ n`, then\n`expand R p (cyclotomic n R) = (cyclotomic (n * p) R) * (cyclotomic n R)`. -/\n@[simp]\ntheorem cyclotomic_expand_eq_cyclotomic_mul {p n : ℕ} (hp : Nat.Prime p) (hdiv : ¬p ∣ n)\n    (R : Type*) [CommRing R] :\n    expand R p (cyclotomic n R) = cyclotomic (n * p) R * cyclotomic n R := by\n  rcases Nat.eq_zero_or_pos n with (rfl | hnpos)\n  · simp\n  haveI := NeZero.of_pos hnpos\n  suffices expand ℤ p (cyclotomic n ℤ) = cyclotomic (n * p) ℤ * cyclotomic n ℤ by\n    rw [← map_cyclotomic_int, ← map_expand, this, Polynomial.map_mul, map_cyclotomic_int,\n      map_cyclotomic]\n  refine eq_of_monic_of_dvd_of_natDegree_le ((cyclotomic.monic _ ℤ).mul (cyclotomic.monic _ ℤ))\n    ((cyclotomic.monic n ℤ).expand hp.pos) ?_ ?_\n  · refine (IsPrimitive.Int.dvd_iff_map_cast_dvd_map_cast _ _\n      (IsPrimitive.mul (cyclotomic.isPrimitive (n * p) ℤ) (cyclotomic.isPrimitive n ℤ))\n      ((cyclotomic.monic n ℤ).expand hp.pos).isPrimitive).2 ?_\n    rw [Polynomial.map_mul, map_cyclotomic_int, map_cyclotomic_int, map_expand, map_cyclotomic_int]\n    refine IsCoprime.mul_dvd (cyclotomic.isCoprime_rat fun h => ?_) ?_ ?_\n    · replace h : n * p = n * 1 := by simp [h]\n      exact Nat.Prime.ne_one hp (mul_left_cancel₀ hnpos.ne' h)\n    · have hpos : 0 < n * p := mul_pos hnpos hp.pos\n      have hprim := Complex.isPrimitiveRoot_exp _ hpos.ne'\n      rw [cyclotomic_eq_minpoly_rat hprim hpos]\n      refine minpoly.dvd ℚ _ ?_\n      rw [aeval_def, ← eval_map, map_expand, map_cyclotomic, expand_eval, ← IsRoot.def,\n        @isRoot_cyclotomic_iff]\n      convert IsPrimitiveRoot.pow_of_dvd hprim hp.ne_zero (dvd_mul_left p n)\n      rw [Nat.mul_div_cancel _ (Nat.Prime.pos hp)]\n    · have hprim := Complex.isPrimitiveRoot_exp _ hnpos.ne.symm\n      rw [cyclotomic_eq_minpoly_rat hprim hnpos]\n      refine minpoly.dvd ℚ _ ?_\n      rw [aeval_def, ← eval_map, map_expand, expand_eval, ← IsRoot.def, ←\n        cyclotomic_eq_minpoly_rat hprim hnpos, map_cyclotomic, @isRoot_cyclotomic_iff]\n      exact IsPrimitiveRoot.pow_of_prime hprim hp hdiv\n  · rw [natDegree_expand, natDegree_cyclotomic,\n      natDegree_mul (cyclotomic_ne_zero _ ℤ) (cyclotomic_ne_zero _ ℤ), natDegree_cyclotomic,\n      natDegree_cyclotomic, mul_comm n,\n      Nat.totient_mul ((Nat.Prime.coprime_iff_not_dvd hp).2 hdiv), Nat.totient_prime hp,\n      mul_comm (p - 1), ← Nat.mul_succ, Nat.sub_one, Nat.succ_pred_eq_of_pos hp.pos]\n\n"}
{"name":"Polynomial.cyclotomic_expand_eq_cyclotomic","module":"Mathlib.RingTheory.Polynomial.Cyclotomic.Expand","initialProofState":"p n : Nat\nhp : Nat.Prime p\nhdiv : Dvd.dvd p n\nR : Type u_1\ninst✝ : CommRing R\n⊢ Eq ((Polynomial.expand R p) (Polynomial.cyclotomic n R)) (Polynomial.cyclotomic (HMul.hMul n p) R)","decl":"/-- If `p` is a prime such that `p ∣ n`, then\n`expand R p (cyclotomic n R) = cyclotomic (p * n) R`. -/\n@[simp]\ntheorem cyclotomic_expand_eq_cyclotomic {p n : ℕ} (hp : Nat.Prime p) (hdiv : p ∣ n) (R : Type*)\n    [CommRing R] : expand R p (cyclotomic n R) = cyclotomic (n * p) R := by\n  rcases n.eq_zero_or_pos with (rfl | hzero)\n  · simp\n  haveI := NeZero.of_pos hzero\n  suffices expand ℤ p (cyclotomic n ℤ) = cyclotomic (n * p) ℤ by\n    rw [← map_cyclotomic_int, ← map_expand, this, map_cyclotomic_int]\n  refine eq_of_monic_of_dvd_of_natDegree_le (cyclotomic.monic _ ℤ)\n    ((cyclotomic.monic n ℤ).expand hp.pos) ?_ ?_\n  · have hpos := Nat.mul_pos hzero hp.pos\n    have hprim := Complex.isPrimitiveRoot_exp _ hpos.ne.symm\n    rw [cyclotomic_eq_minpoly hprim hpos]\n    refine minpoly.isIntegrallyClosed_dvd (hprim.isIntegral hpos) ?_\n    rw [aeval_def, ← eval_map, map_expand, map_cyclotomic, expand_eval, ← IsRoot.def,\n      @isRoot_cyclotomic_iff]\n    convert IsPrimitiveRoot.pow_of_dvd hprim hp.ne_zero (dvd_mul_left p n)\n    rw [Nat.mul_div_cancel _ hp.pos]\n  · rw [natDegree_expand, natDegree_cyclotomic, natDegree_cyclotomic, mul_comm n,\n      Nat.totient_mul_of_prime_of_dvd hp hdiv, mul_comm]\n\n"}
{"name":"Polynomial.cyclotomic_irreducible_pow_of_irreducible_pow","module":"Mathlib.RingTheory.Polynomial.Cyclotomic.Expand","initialProofState":"p : Nat\nhp : Nat.Prime p\nR : Type u_1\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\nn m : Nat\nhmn : LE.le m n\nh : Irreducible (Polynomial.cyclotomic (HPow.hPow p n) R)\n⊢ Irreducible (Polynomial.cyclotomic (HPow.hPow p m) R)","decl":"/-- If the `p ^ n`th cyclotomic polynomial is irreducible, so is the `p ^ m`th, for `m ≤ n`. -/\ntheorem cyclotomic_irreducible_pow_of_irreducible_pow {p : ℕ} (hp : Nat.Prime p) {R} [CommRing R]\n    [IsDomain R] {n m : ℕ} (hmn : m ≤ n) (h : Irreducible (cyclotomic (p ^ n) R)) :\n    Irreducible (cyclotomic (p ^ m) R) := by\n  rcases m.eq_zero_or_pos with (rfl | hm)\n  · simpa using irreducible_X_sub_C (1 : R)\n  obtain ⟨k, rfl⟩ := Nat.exists_eq_add_of_le hmn\n  induction' k with k hk\n  · simpa using h\n  have : m + k ≠ 0 := (add_pos_of_pos_of_nonneg hm k.zero_le).ne'\n  rw [Nat.add_succ, pow_succ, ← cyclotomic_expand_eq_cyclotomic hp <| dvd_pow_self p this] at h\n  exact hk (by omega) (of_irreducible_expand hp.ne_zero h)\n\n"}
{"name":"Polynomial.cyclotomic_irreducible_of_irreducible_pow","module":"Mathlib.RingTheory.Polynomial.Cyclotomic.Expand","initialProofState":"p : Nat\nhp : Nat.Prime p\nR : Type u_1\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\nn : Nat\nhn : Ne n 0\nh : Irreducible (Polynomial.cyclotomic (HPow.hPow p n) R)\n⊢ Irreducible (Polynomial.cyclotomic p R)","decl":"/-- If `Irreducible (cyclotomic (p ^ n) R)` then `Irreducible (cyclotomic p R).` -/\ntheorem cyclotomic_irreducible_of_irreducible_pow {p : ℕ} (hp : Nat.Prime p) {R} [CommRing R]\n    [IsDomain R] {n : ℕ} (hn : n ≠ 0) (h : Irreducible (cyclotomic (p ^ n) R)) :\n    Irreducible (cyclotomic p R) :=\n  pow_one p ▸ cyclotomic_irreducible_pow_of_irreducible_pow hp hn.bot_lt h\n\n"}
{"name":"Polynomial.cyclotomic_mul_prime_eq_pow_of_not_dvd","module":"Mathlib.RingTheory.Polynomial.Cyclotomic.Expand","initialProofState":"R : Type u_1\np n : Nat\nhp : Fact (Nat.Prime p)\ninst✝¹ : Ring R\ninst✝ : CharP R p\nhn : Not (Dvd.dvd p n)\n⊢ Eq (Polynomial.cyclotomic (HMul.hMul n p) R) (HPow.hPow (Polynomial.cyclotomic n R) (HSub.hSub p 1))","decl":"/-- If `R` is of characteristic `p` and `¬p ∣ n`, then\n`cyclotomic (n * p) R = (cyclotomic n R) ^ (p - 1)`. -/\ntheorem cyclotomic_mul_prime_eq_pow_of_not_dvd (R : Type*) {p n : ℕ} [hp : Fact (Nat.Prime p)]\n    [Ring R] [CharP R p] (hn : ¬p ∣ n) : cyclotomic (n * p) R = cyclotomic n R ^ (p - 1) := by\n  letI : Algebra (ZMod p) R := ZMod.algebra _ _\n  suffices cyclotomic (n * p) (ZMod p) = cyclotomic n (ZMod p) ^ (p - 1) by\n    rw [← map_cyclotomic _ (algebraMap (ZMod p) R), ← map_cyclotomic _ (algebraMap (ZMod p) R),\n      this, Polynomial.map_pow]\n  apply mul_right_injective₀ (cyclotomic_ne_zero n <| ZMod p); dsimp\n  rw [← pow_succ', tsub_add_cancel_of_le hp.out.one_lt.le, mul_comm, ← ZMod.expand_card]\n  conv_rhs => rw [← map_cyclotomic_int]\n  rw [← map_expand, cyclotomic_expand_eq_cyclotomic_mul hp.out hn, Polynomial.map_mul,\n    map_cyclotomic, map_cyclotomic]\n\n"}
{"name":"Polynomial.cyclotomic_mul_prime_dvd_eq_pow","module":"Mathlib.RingTheory.Polynomial.Cyclotomic.Expand","initialProofState":"R : Type u_1\np n : Nat\nhp : Fact (Nat.Prime p)\ninst✝¹ : Ring R\ninst✝ : CharP R p\nhn : Dvd.dvd p n\n⊢ Eq (Polynomial.cyclotomic (HMul.hMul n p) R) (HPow.hPow (Polynomial.cyclotomic n R) p)","decl":"/-- If `R` is of characteristic `p` and `p ∣ n`, then\n`cyclotomic (n * p) R = (cyclotomic n R) ^ p`. -/\ntheorem cyclotomic_mul_prime_dvd_eq_pow (R : Type*) {p n : ℕ} [hp : Fact (Nat.Prime p)] [Ring R]\n    [CharP R p] (hn : p ∣ n) : cyclotomic (n * p) R = cyclotomic n R ^ p := by\n  letI : Algebra (ZMod p) R := ZMod.algebra _ _\n  suffices cyclotomic (n * p) (ZMod p) = cyclotomic n (ZMod p) ^ p by\n    rw [← map_cyclotomic _ (algebraMap (ZMod p) R), ← map_cyclotomic _ (algebraMap (ZMod p) R),\n      this, Polynomial.map_pow]\n  rw [← ZMod.expand_card, ← map_cyclotomic_int n, ← map_expand,\n    cyclotomic_expand_eq_cyclotomic hp.out hn, map_cyclotomic]\n\n"}
{"name":"Polynomial.cyclotomic_mul_prime_pow_eq","module":"Mathlib.RingTheory.Polynomial.Cyclotomic.Expand","initialProofState":"R : Type u_1\np m : Nat\ninst✝² : Fact (Nat.Prime p)\ninst✝¹ : Ring R\ninst✝ : CharP R p\nhm : Not (Dvd.dvd p m)\nk : Nat\na✝ : LT.lt 0 k\n⊢ Eq (Polynomial.cyclotomic (HMul.hMul (HPow.hPow p k) m) R) (HPow.hPow (Polynomial.cyclotomic m R) (HSub.hSub (HPow.hPow p k) (HPow.hPow p (HSub.hSub k 1))))","decl":"/-- If `R` is of characteristic `p` and `¬p ∣ m`, then\n`cyclotomic (p ^ k * m) R = (cyclotomic m R) ^ (p ^ k - p ^ (k - 1))`. -/\ntheorem cyclotomic_mul_prime_pow_eq (R : Type*) {p m : ℕ} [Fact (Nat.Prime p)] [Ring R] [CharP R p]\n    (hm : ¬p ∣ m) : ∀ {k}, 0 < k → cyclotomic (p ^ k * m) R = cyclotomic m R ^ (p ^ k - p ^ (k - 1))\n  | 1, _ => by\n    rw [pow_one, Nat.sub_self, pow_zero, mul_comm, cyclotomic_mul_prime_eq_pow_of_not_dvd R hm]\n  | a + 2, _ => by\n    have hdiv : p ∣ p ^ a.succ * m := ⟨p ^ a * m, by rw [← mul_assoc, pow_succ']⟩\n    rw [pow_succ', mul_assoc, mul_comm, cyclotomic_mul_prime_dvd_eq_pow R hdiv,\n      cyclotomic_mul_prime_pow_eq _ _ a.succ_pos, ← pow_mul]\n    · simp only [tsub_zero, Nat.succ_sub_succ_eq_sub]\n      rw [Nat.mul_sub_right_distrib, mul_comm, pow_succ]\n    · assumption\n\n"}
{"name":"Polynomial.isRoot_cyclotomic_prime_pow_mul_iff_of_charP","module":"Mathlib.RingTheory.Polynomial.Cyclotomic.Expand","initialProofState":"m k p : Nat\nR : Type u_1\ninst✝² : CommRing R\ninst✝¹ : IsDomain R\nhp : Fact (Nat.Prime p)\nhchar : CharP R p\nμ : R\ninst✝ : NeZero ↑m\n⊢ Iff ((Polynomial.cyclotomic (HMul.hMul (HPow.hPow p k) m) R).IsRoot μ) (IsPrimitiveRoot μ m)","decl":"/-- If `R` is of characteristic `p` and `¬p ∣ m`, then `ζ` is a root of `cyclotomic (p ^ k * m) R`\n if and only if it is a primitive `m`-th root of unity. -/\ntheorem isRoot_cyclotomic_prime_pow_mul_iff_of_charP {m k p : ℕ} {R : Type*} [CommRing R]\n    [IsDomain R] [hp : Fact (Nat.Prime p)] [hchar : CharP R p] {μ : R} [NeZero (m : R)] :\n    (Polynomial.cyclotomic (p ^ k * m) R).IsRoot μ ↔ IsPrimitiveRoot μ m := by\n  rcases k.eq_zero_or_pos with (rfl | hk)\n  · rw [pow_zero, one_mul, isRoot_cyclotomic_iff]\n  refine ⟨fun h => ?_, fun h => ?_⟩\n  · rw [IsRoot.def, cyclotomic_mul_prime_pow_eq R (NeZero.not_char_dvd R p m) hk, eval_pow]\n      at h\n    replace h := pow_eq_zero h\n    rwa [← IsRoot.def, isRoot_cyclotomic_iff] at h\n  · rw [← isRoot_cyclotomic_iff, IsRoot.def] at h\n    rw [cyclotomic_mul_prime_pow_eq R (NeZero.not_char_dvd R p m) hk, IsRoot.def, eval_pow,\n      h, zero_pow]\n    exact Nat.sub_ne_zero_of_lt <| pow_right_strictMono₀ hp.out.one_lt <| Nat.pred_lt hk.ne'\n\n"}
