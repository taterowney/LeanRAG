{"name":"Finset.singleton_val","module":"Mathlib.Data.Finset.Insert","initialProofState":"α : Type u_1\na : α\n⊢ Eq (Singleton.singleton a).val (Singleton.singleton a)","decl":"@[simp]\ntheorem singleton_val (a : α) : ({a} : Finset α).1 = {a} :=\n  rfl\n\n"}
{"name":"Finset.mem_singleton","module":"Mathlib.Data.Finset.Insert","initialProofState":"α : Type u_1\na b : α\n⊢ Iff (Membership.mem (Singleton.singleton a) b) (Eq b a)","decl":"@[simp]\ntheorem mem_singleton {a b : α} : b ∈ ({a} : Finset α) ↔ b = a :=\n  Multiset.mem_singleton\n\n"}
{"name":"Finset.eq_of_mem_singleton","module":"Mathlib.Data.Finset.Insert","initialProofState":"α : Type u_1\nx y : α\nh : Membership.mem (Singleton.singleton y) x\n⊢ Eq x y","decl":"theorem eq_of_mem_singleton {x y : α} (h : x ∈ ({y} : Finset α)) : x = y :=\n  mem_singleton.1 h\n\n"}
{"name":"Finset.not_mem_singleton","module":"Mathlib.Data.Finset.Insert","initialProofState":"α : Type u_1\na b : α\n⊢ Iff (Not (Membership.mem (Singleton.singleton b) a)) (Ne a b)","decl":"theorem not_mem_singleton {a b : α} : a ∉ ({b} : Finset α) ↔ a ≠ b :=\n  not_congr mem_singleton\n\n"}
{"name":"Finset.mem_singleton_self","module":"Mathlib.Data.Finset.Insert","initialProofState":"α : Type u_1\na : α\n⊢ Membership.mem (Singleton.singleton a) a","decl":"theorem mem_singleton_self (a : α) : a ∈ ({a} : Finset α) :=\n  -- Porting note: was `Or.inl rfl`\n  mem_singleton.mpr rfl\n\n"}
{"name":"Finset.val_eq_singleton_iff","module":"Mathlib.Data.Finset.Insert","initialProofState":"α : Type u_1\na : α\ns : Finset α\n⊢ Iff (Eq s.val (Singleton.singleton a)) (Eq s (Singleton.singleton a))","decl":"@[simp]\ntheorem val_eq_singleton_iff {a : α} {s : Finset α} : s.val = {a} ↔ s = {a} := by\n  rw [← val_inj]\n  rfl\n\n"}
{"name":"Finset.singleton_injective","module":"Mathlib.Data.Finset.Insert","initialProofState":"α : Type u_1\n⊢ Function.Injective Singleton.singleton","decl":"theorem singleton_injective : Injective (singleton : α → Finset α) := fun _a _b h =>\n  mem_singleton.1 (h ▸ mem_singleton_self _)\n\n"}
{"name":"Finset.singleton_inj","module":"Mathlib.Data.Finset.Insert","initialProofState":"α : Type u_1\na b : α\n⊢ Iff (Eq (Singleton.singleton a) (Singleton.singleton b)) (Eq a b)","decl":"@[simp]\ntheorem singleton_inj : ({a} : Finset α) = {b} ↔ a = b :=\n  singleton_injective.eq_iff\n\n"}
{"name":"Finset.singleton_nonempty","module":"Mathlib.Data.Finset.Insert","initialProofState":"α : Type u_1\na : α\n⊢ (Singleton.singleton a).Nonempty","decl":"@[simp, aesop safe apply (rule_sets := [finsetNonempty])]\ntheorem singleton_nonempty (a : α) : ({a} : Finset α).Nonempty :=\n  ⟨a, mem_singleton_self a⟩\n\n"}
{"name":"Finset.singleton_ne_empty","module":"Mathlib.Data.Finset.Insert","initialProofState":"α : Type u_1\na : α\n⊢ Ne (Singleton.singleton a) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem singleton_ne_empty (a : α) : ({a} : Finset α) ≠ ∅ :=\n  (singleton_nonempty a).ne_empty\n\n"}
{"name":"Finset.empty_ssubset_singleton","module":"Mathlib.Data.Finset.Insert","initialProofState":"α : Type u_1\na : α\n⊢ HasSSubset.SSubset EmptyCollection.emptyCollection (Singleton.singleton a)","decl":"theorem empty_ssubset_singleton : (∅ : Finset α) ⊂ {a} :=\n  (singleton_nonempty _).empty_ssubset\n\n"}
{"name":"Finset.coe_singleton","module":"Mathlib.Data.Finset.Insert","initialProofState":"α : Type u_1\na : α\n⊢ Eq (↑(Singleton.singleton a)) (Singleton.singleton a)","decl":"@[simp, norm_cast]\ntheorem coe_singleton (a : α) : (({a} : Finset α) : Set α) = {a} := by\n  ext\n  simp\n\n"}
{"name":"Finset.coe_eq_singleton","module":"Mathlib.Data.Finset.Insert","initialProofState":"α : Type u_1\ns : Finset α\na : α\n⊢ Iff (Eq (↑s) (Singleton.singleton a)) (Eq s (Singleton.singleton a))","decl":"@[simp, norm_cast]\ntheorem coe_eq_singleton {s : Finset α} {a : α} : (s : Set α) = {a} ↔ s = {a} := by\n  rw [← coe_singleton, coe_inj]\n\n"}
{"name":"Finset.coe_subset_singleton","module":"Mathlib.Data.Finset.Insert","initialProofState":"α : Type u_1\ns : Finset α\na : α\n⊢ Iff (HasSubset.Subset (↑s) (Singleton.singleton a)) (HasSubset.Subset s (Singleton.singleton a))","decl":"@[norm_cast]\nlemma coe_subset_singleton : (s : Set α) ⊆ {a} ↔ s ⊆ {a} := by rw [← coe_subset, coe_singleton]\n\n"}
{"name":"Finset.singleton_subset_coe","module":"Mathlib.Data.Finset.Insert","initialProofState":"α : Type u_1\ns : Finset α\na : α\n⊢ Iff (HasSubset.Subset (Singleton.singleton a) ↑s) (HasSubset.Subset (Singleton.singleton a) s)","decl":"@[norm_cast]\nlemma singleton_subset_coe : {a} ⊆ (s : Set α) ↔ {a} ⊆ s := by rw [← coe_subset, coe_singleton]\n\n"}
{"name":"Finset.eq_singleton_iff_unique_mem","module":"Mathlib.Data.Finset.Insert","initialProofState":"α : Type u_1\ns : Finset α\na : α\n⊢ Iff (Eq s (Singleton.singleton a)) (And (Membership.mem s a) (∀ (x : α), Membership.mem s x → Eq x a))","decl":"theorem eq_singleton_iff_unique_mem {s : Finset α} {a : α} : s = {a} ↔ a ∈ s ∧ ∀ x ∈ s, x = a := by\n  constructor <;> intro t\n  · rw [t]\n    exact ⟨Finset.mem_singleton_self _, fun _ => Finset.mem_singleton.1⟩\n  · ext\n    rw [Finset.mem_singleton]\n    exact ⟨t.right _, fun r => r.symm ▸ t.left⟩\n\n"}
{"name":"Finset.eq_singleton_iff_nonempty_unique_mem","module":"Mathlib.Data.Finset.Insert","initialProofState":"α : Type u_1\ns : Finset α\na : α\n⊢ Iff (Eq s (Singleton.singleton a)) (And s.Nonempty (∀ (x : α), Membership.mem s x → Eq x a))","decl":"theorem eq_singleton_iff_nonempty_unique_mem {s : Finset α} {a : α} :\n    s = {a} ↔ s.Nonempty ∧ ∀ x ∈ s, x = a := by\n  constructor\n  · rintro rfl\n    simp\n  · rintro ⟨hne, h_uniq⟩\n    rw [eq_singleton_iff_unique_mem]\n    refine ⟨?_, h_uniq⟩\n    rw [← h_uniq hne.choose hne.choose_spec]\n    exact hne.choose_spec\n\n"}
{"name":"Finset.nonempty_iff_eq_singleton_default","module":"Mathlib.Data.Finset.Insert","initialProofState":"α : Type u_1\ninst✝ : Unique α\ns : Finset α\n⊢ Iff s.Nonempty (Eq s (Singleton.singleton Inhabited.default))","decl":"theorem nonempty_iff_eq_singleton_default [Unique α] {s : Finset α} :\n    s.Nonempty ↔ s = {default} := by\n  simp [eq_singleton_iff_nonempty_unique_mem, eq_iff_true_of_subsingleton]\n\n"}
{"name":"Finset.Nonempty.eq_singleton_default","module":"Mathlib.Data.Finset.Insert","initialProofState":"α : Type u_1\ninst✝ : Unique α\ns : Finset α\na✝ : s.Nonempty\n⊢ Eq s (Singleton.singleton Inhabited.default)","decl":"alias ⟨Nonempty.eq_singleton_default, _⟩ := nonempty_iff_eq_singleton_default\n\n"}
{"name":"Finset.singleton_iff_unique_mem","module":"Mathlib.Data.Finset.Insert","initialProofState":"α : Type u_1\ns : Finset α\n⊢ Iff (Exists fun a => Eq s (Singleton.singleton a)) (ExistsUnique fun a => Membership.mem s a)","decl":"theorem singleton_iff_unique_mem (s : Finset α) : (∃ a, s = {a}) ↔ ∃! a, a ∈ s := by\n  simp only [eq_singleton_iff_unique_mem, ExistsUnique]\n\n"}
{"name":"Finset.singleton_subset_set_iff","module":"Mathlib.Data.Finset.Insert","initialProofState":"α : Type u_1\ns : Set α\na : α\n⊢ Iff (HasSubset.Subset (↑(Singleton.singleton a)) s) (Membership.mem s a)","decl":"theorem singleton_subset_set_iff {s : Set α} {a : α} : ↑({a} : Finset α) ⊆ s ↔ a ∈ s := by\n  rw [coe_singleton, Set.singleton_subset_iff]\n\n"}
{"name":"Finset.singleton_subset_iff","module":"Mathlib.Data.Finset.Insert","initialProofState":"α : Type u_1\ns : Finset α\na : α\n⊢ Iff (HasSubset.Subset (Singleton.singleton a) s) (Membership.mem s a)","decl":"@[simp]\ntheorem singleton_subset_iff {s : Finset α} {a : α} : {a} ⊆ s ↔ a ∈ s :=\n  singleton_subset_set_iff\n\n"}
{"name":"Finset.subset_singleton_iff","module":"Mathlib.Data.Finset.Insert","initialProofState":"α : Type u_1\ns : Finset α\na : α\n⊢ Iff (HasSubset.Subset s (Singleton.singleton a)) (Or (Eq s EmptyCollection.emptyCollection) (Eq s (Singleton.singleton a)))","decl":"@[simp]\ntheorem subset_singleton_iff {s : Finset α} {a : α} : s ⊆ {a} ↔ s = ∅ ∨ s = {a} := by\n  rw [← coe_subset, coe_singleton, Set.subset_singleton_iff_eq, coe_eq_empty, coe_eq_singleton]\n\n"}
{"name":"Finset.singleton_subset_singleton","module":"Mathlib.Data.Finset.Insert","initialProofState":"α : Type u_1\na b : α\n⊢ Iff (HasSubset.Subset (Singleton.singleton a) (Singleton.singleton b)) (Eq a b)","decl":"theorem singleton_subset_singleton : ({a} : Finset α) ⊆ {b} ↔ a = b := by simp\n\n"}
{"name":"Finset.Nonempty.subset_singleton_iff","module":"Mathlib.Data.Finset.Insert","initialProofState":"α : Type u_1\ns : Finset α\na : α\nh : s.Nonempty\n⊢ Iff (HasSubset.Subset s (Singleton.singleton a)) (Eq s (Singleton.singleton a))","decl":"protected theorem Nonempty.subset_singleton_iff {s : Finset α} {a : α} (h : s.Nonempty) :\n    s ⊆ {a} ↔ s = {a} :=\n  subset_singleton_iff.trans <| or_iff_right h.ne_empty\n\n"}
{"name":"Finset.subset_singleton_iff'","module":"Mathlib.Data.Finset.Insert","initialProofState":"α : Type u_1\ns : Finset α\na : α\n⊢ Iff (HasSubset.Subset s (Singleton.singleton a)) (∀ (b : α), Membership.mem s b → Eq b a)","decl":"theorem subset_singleton_iff' {s : Finset α} {a : α} : s ⊆ {a} ↔ ∀ b ∈ s, b = a :=\n  forall₂_congr fun _ _ => mem_singleton\n\n"}
{"name":"Finset.ssubset_singleton_iff","module":"Mathlib.Data.Finset.Insert","initialProofState":"α : Type u_1\ns : Finset α\na : α\n⊢ Iff (HasSSubset.SSubset s (Singleton.singleton a)) (Eq s EmptyCollection.emptyCollection)","decl":"@[simp]\ntheorem ssubset_singleton_iff {s : Finset α} {a : α} : s ⊂ {a} ↔ s = ∅ := by\n  rw [← coe_ssubset, coe_singleton, Set.ssubset_singleton_iff, coe_eq_empty]\n\n"}
{"name":"Finset.eq_empty_of_ssubset_singleton","module":"Mathlib.Data.Finset.Insert","initialProofState":"α : Type u_1\ns : Finset α\nx : α\nhs : HasSSubset.SSubset s (Singleton.singleton x)\n⊢ Eq s EmptyCollection.emptyCollection","decl":"theorem eq_empty_of_ssubset_singleton {s : Finset α} {x : α} (hs : s ⊂ {x}) : s = ∅ :=\n  ssubset_singleton_iff.1 hs\n\n"}
{"name":"Finset.Nontrivial.nonempty","module":"Mathlib.Data.Finset.Insert","initialProofState":"α : Type u_1\ns : Finset α\nhs : s.Nontrivial\n⊢ s.Nonempty","decl":"nonrec lemma Nontrivial.nonempty (hs : s.Nontrivial) : s.Nonempty := hs.nonempty\n\n"}
{"name":"Finset.not_nontrivial_empty","module":"Mathlib.Data.Finset.Insert","initialProofState":"α : Type u_1\n⊢ Not EmptyCollection.emptyCollection.Nontrivial","decl":"@[simp]\ntheorem not_nontrivial_empty : ¬ (∅ : Finset α).Nontrivial := by simp [Finset.Nontrivial]\n\n"}
{"name":"Finset.not_nontrivial_singleton","module":"Mathlib.Data.Finset.Insert","initialProofState":"α : Type u_1\na : α\n⊢ Not (Singleton.singleton a).Nontrivial","decl":"@[simp]\ntheorem not_nontrivial_singleton : ¬ ({a} : Finset α).Nontrivial := by simp [Finset.Nontrivial]\n\n"}
{"name":"Finset.Nontrivial.ne_singleton","module":"Mathlib.Data.Finset.Insert","initialProofState":"α : Type u_1\ns : Finset α\na : α\nhs : s.Nontrivial\n⊢ Ne s (Singleton.singleton a)","decl":"theorem Nontrivial.ne_singleton (hs : s.Nontrivial) : s ≠ {a} := by\n  rintro rfl; exact not_nontrivial_singleton hs\n\n"}
{"name":"Finset.Nontrivial.exists_ne","module":"Mathlib.Data.Finset.Insert","initialProofState":"α : Type u_1\ns : Finset α\nhs : s.Nontrivial\na : α\n⊢ Exists fun b => And (Membership.mem s b) (Ne b a)","decl":"nonrec lemma Nontrivial.exists_ne (hs : s.Nontrivial) (a : α) : ∃ b ∈ s, b ≠ a := hs.exists_ne _\n\n"}
{"name":"Finset.eq_singleton_or_nontrivial","module":"Mathlib.Data.Finset.Insert","initialProofState":"α : Type u_1\ns : Finset α\na : α\nha : Membership.mem s a\n⊢ Or (Eq s (Singleton.singleton a)) s.Nontrivial","decl":"theorem eq_singleton_or_nontrivial (ha : a ∈ s) : s = {a} ∨ s.Nontrivial := by\n  rw [← coe_eq_singleton]; exact Set.eq_singleton_or_nontrivial ha\n\n"}
{"name":"Finset.nontrivial_iff_ne_singleton","module":"Mathlib.Data.Finset.Insert","initialProofState":"α : Type u_1\ns : Finset α\na : α\nha : Membership.mem s a\n⊢ Iff s.Nontrivial (Ne s (Singleton.singleton a))","decl":"theorem nontrivial_iff_ne_singleton (ha : a ∈ s) : s.Nontrivial ↔ s ≠ {a} :=\n  ⟨Nontrivial.ne_singleton, (eq_singleton_or_nontrivial ha).resolve_left⟩\n\n"}
{"name":"Finset.Nonempty.exists_eq_singleton_or_nontrivial","module":"Mathlib.Data.Finset.Insert","initialProofState":"α : Type u_1\ns : Finset α\na✝ : s.Nonempty\n⊢ Or (Exists fun a => Eq s (Singleton.singleton a)) s.Nontrivial","decl":"theorem Nonempty.exists_eq_singleton_or_nontrivial : s.Nonempty → (∃ a, s = {a}) ∨ s.Nontrivial :=\n  fun ⟨a, ha⟩ => (eq_singleton_or_nontrivial ha).imp_left <| Exists.intro a\n\n"}
{"name":"Finset.nontrivial_coe","module":"Mathlib.Data.Finset.Insert","initialProofState":"α : Type u_1\ns : Finset α\n⊢ Iff (↑s).Nontrivial s.Nontrivial","decl":"@[simp, norm_cast] lemma nontrivial_coe : (s : Set α).Nontrivial ↔ s.Nontrivial := .rfl\n\n"}
{"name":"Finset.Nontrivial.coe","module":"Mathlib.Data.Finset.Insert","initialProofState":"α : Type u_1\ns : Finset α\na✝ : s.Nontrivial\n⊢ (↑s).Nontrivial","decl":"alias ⟨Nontrivial.of_coe, Nontrivial.coe⟩ := nontrivial_coe\n\n"}
{"name":"Finset.Nontrivial.of_coe","module":"Mathlib.Data.Finset.Insert","initialProofState":"α : Type u_1\ns : Finset α\na✝ : (↑s).Nontrivial\n⊢ s.Nontrivial","decl":"alias ⟨Nontrivial.of_coe, Nontrivial.coe⟩ := nontrivial_coe\n\n"}
{"name":"Finset.Nontrivial.not_subset_singleton","module":"Mathlib.Data.Finset.Insert","initialProofState":"α : Type u_1\ns : Finset α\na : α\nhs : s.Nontrivial\n⊢ Not (HasSubset.Subset s (Singleton.singleton a))","decl":"lemma Nontrivial.not_subset_singleton (hs : s.Nontrivial) : ¬s ⊆ {a} :=\n  mod_cast hs.coe.not_subset_singleton\n\n"}
{"name":"Finset.instNontrivial","module":"Mathlib.Data.Finset.Insert","initialProofState":"α : Type u_1\ninst✝ : Nonempty α\n⊢ Nontrivial (Finset α)","decl":"instance instNontrivial [Nonempty α] : Nontrivial (Finset α) :=\n  ‹Nonempty α›.elim fun a => ⟨⟨{a}, ∅, singleton_ne_empty _⟩⟩\n\n"}
{"name":"Finset.default_singleton","module":"Mathlib.Data.Finset.Insert","initialProofState":"α : Type u_1\ni : α\n⊢ Eq (↑Inhabited.default) i","decl":"@[simp]\nlemma default_singleton (i : α) : ((default : ({i} : Finset α)) : α) = i := rfl\n\n"}
{"name":"Finset.mem_cons","module":"Mathlib.Data.Finset.Insert","initialProofState":"α : Type u_1\ns : Finset α\na b : α\nh : Not (Membership.mem s a)\n⊢ Iff (Membership.mem (Finset.cons a s h) b) (Or (Eq b a) (Membership.mem s b))","decl":"@[simp]\ntheorem mem_cons {h} : b ∈ s.cons a h ↔ b = a ∨ b ∈ s :=\n  Multiset.mem_cons\n\n"}
{"name":"Finset.mem_cons_of_mem","module":"Mathlib.Data.Finset.Insert","initialProofState":"α : Type u_1\na b : α\ns : Finset α\nhb : Not (Membership.mem s b)\nha : Membership.mem s a\n⊢ Membership.mem (Finset.cons b s hb) a","decl":"theorem mem_cons_of_mem {a b : α} {s : Finset α} {hb : b ∉ s} (ha : a ∈ s) : a ∈ cons b s hb :=\n  Multiset.mem_cons_of_mem ha\n\n"}
{"name":"Finset.mem_cons_self","module":"Mathlib.Data.Finset.Insert","initialProofState":"α : Type u_1\na : α\ns : Finset α\nh : Not (Membership.mem s a)\n⊢ Membership.mem (Finset.cons a s h) a","decl":"theorem mem_cons_self (a : α) (s : Finset α) {h} : a ∈ cons a s h :=\n  Multiset.mem_cons_self _ _\n\n"}
{"name":"Finset.cons_val","module":"Mathlib.Data.Finset.Insert","initialProofState":"α : Type u_1\ns : Finset α\na : α\nh : Not (Membership.mem s a)\n⊢ Eq (Finset.cons a s h).val (Multiset.cons a s.val)","decl":"@[simp]\ntheorem cons_val (h : a ∉ s) : (cons a s h).1 = a ::ₘ s.1 :=\n  rfl\n\n"}
{"name":"Finset.eq_of_mem_cons_of_not_mem","module":"Mathlib.Data.Finset.Insert","initialProofState":"α : Type u_1\ns : Finset α\na b : α\nhas : Not (Membership.mem s a)\nh : Membership.mem (Finset.cons a s has) b\nhb : Not (Membership.mem s b)\n⊢ Eq b a","decl":"theorem eq_of_mem_cons_of_not_mem (has : a ∉ s) (h : b ∈ cons a s has) (hb : b ∉ s) : b = a :=\n  (mem_cons.1 h).resolve_right hb\n\n"}
{"name":"Finset.mem_of_mem_cons_of_ne","module":"Mathlib.Data.Finset.Insert","initialProofState":"α : Type u_1\ns : Finset α\na : α\nhas : Not (Membership.mem s a)\ni : α\nhi : Membership.mem (Finset.cons a s has) i\nhia : Ne i a\n⊢ Membership.mem s i","decl":"theorem mem_of_mem_cons_of_ne {s : Finset α} {a : α} {has} {i : α}\n    (hi : i ∈ cons a s has) (hia : i ≠ a) : i ∈ s :=\n  (mem_cons.1 hi).resolve_left hia\n\n"}
{"name":"Finset.forall_mem_cons","module":"Mathlib.Data.Finset.Insert","initialProofState":"α : Type u_1\ns : Finset α\na : α\nh : Not (Membership.mem s a)\np : α → Prop\n⊢ Iff (∀ (x : α), Membership.mem (Finset.cons a s h) x → p x) (And (p a) (∀ (x : α), Membership.mem s x → p x))","decl":"theorem forall_mem_cons (h : a ∉ s) (p : α → Prop) :\n    (∀ x, x ∈ cons a s h → p x) ↔ p a ∧ ∀ x, x ∈ s → p x := by\n  simp only [mem_cons, or_imp, forall_and, forall_eq]\n\n"}
{"name":"Finset.forall_of_forall_cons","module":"Mathlib.Data.Finset.Insert","initialProofState":"α : Type u_1\ns : Finset α\na : α\np : α → Prop\nh✝ : Not (Membership.mem s a)\nH : ∀ (x : α), Membership.mem (Finset.cons a s h✝) x → p x\nx : α\nh : Membership.mem s x\n⊢ p x","decl":"/-- Useful in proofs by induction. -/\ntheorem forall_of_forall_cons {p : α → Prop} {h : a ∉ s} (H : ∀ x, x ∈ cons a s h → p x) (x)\n    (h : x ∈ s) : p x :=\n  H _ <| mem_cons.2 <| Or.inr h\n\n"}
{"name":"Finset.mk_cons","module":"Mathlib.Data.Finset.Insert","initialProofState":"α : Type u_1\na : α\ns : Multiset α\nh : (Multiset.cons a s).Nodup\n⊢ Eq { val := Multiset.cons a s, nodup := h } (Finset.cons a { val := s, nodup := ⋯ } ⋯)","decl":"@[simp]\ntheorem mk_cons {s : Multiset α} (h : (a ::ₘ s).Nodup) :\n    (⟨a ::ₘ s, h⟩ : Finset α) = cons a ⟨s, (nodup_cons.1 h).2⟩ (nodup_cons.1 h).1 :=\n  rfl\n\n"}
{"name":"Finset.cons_empty","module":"Mathlib.Data.Finset.Insert","initialProofState":"α : Type u_1\na : α\n⊢ Eq (Finset.cons a EmptyCollection.emptyCollection ⋯) (Singleton.singleton a)","decl":"@[simp]\ntheorem cons_empty (a : α) : cons a ∅ (not_mem_empty _) = {a} := rfl\n\n"}
{"name":"Finset.cons_nonempty","module":"Mathlib.Data.Finset.Insert","initialProofState":"α : Type u_1\ns : Finset α\na : α\nh : Not (Membership.mem s a)\n⊢ (Finset.cons a s h).Nonempty","decl":"@[simp, aesop safe apply (rule_sets := [finsetNonempty])]\ntheorem cons_nonempty (h : a ∉ s) : (cons a s h).Nonempty :=\n  ⟨a, mem_cons.2 <| Or.inl rfl⟩\n\n"}
{"name":"Finset.nonempty_cons","module":"Mathlib.Data.Finset.Insert","initialProofState":"α : Type u_1\ns : Finset α\na : α\nh : Not (Membership.mem s a)\n⊢ (Finset.cons a s h).Nonempty","decl":"@[deprecated (since := \"2024-09-19\")] alias nonempty_cons := cons_nonempty\n\n"}
{"name":"Finset.cons_ne_empty","module":"Mathlib.Data.Finset.Insert","initialProofState":"α : Type u_1\ns : Finset α\na : α\nh : Not (Membership.mem s a)\n⊢ Ne (Finset.cons a s h) EmptyCollection.emptyCollection","decl":"@[simp] theorem cons_ne_empty (h : a ∉ s) : cons a s h ≠ ∅ := (cons_nonempty _).ne_empty\n\n"}
{"name":"Finset.nonempty_mk","module":"Mathlib.Data.Finset.Insert","initialProofState":"α : Type u_1\nm : Multiset α\nhm : m.Nodup\n⊢ Iff { val := m, nodup := hm }.Nonempty (Ne m 0)","decl":"@[simp]\ntheorem nonempty_mk {m : Multiset α} {hm} : (⟨m, hm⟩ : Finset α).Nonempty ↔ m ≠ 0 := by\n  induction m using Multiset.induction_on <;> simp\n\n"}
{"name":"Finset.coe_cons","module":"Mathlib.Data.Finset.Insert","initialProofState":"α : Type u_1\na : α\ns : Finset α\nh : Not (Membership.mem s a)\n⊢ Eq (↑(Finset.cons a s h)) (Insert.insert a ↑s)","decl":"@[simp]\ntheorem coe_cons {a s h} : (@cons α a s h : Set α) = insert a (s : Set α) := by\n  ext\n  simp\n\n"}
{"name":"Finset.subset_cons","module":"Mathlib.Data.Finset.Insert","initialProofState":"α : Type u_1\ns : Finset α\na : α\nh : Not (Membership.mem s a)\n⊢ HasSubset.Subset s (Finset.cons a s h)","decl":"theorem subset_cons (h : a ∉ s) : s ⊆ s.cons a h :=\n  Multiset.subset_cons _ _\n\n"}
{"name":"Finset.ssubset_cons","module":"Mathlib.Data.Finset.Insert","initialProofState":"α : Type u_1\ns : Finset α\na : α\nh : Not (Membership.mem s a)\n⊢ HasSSubset.SSubset s (Finset.cons a s h)","decl":"theorem ssubset_cons (h : a ∉ s) : s ⊂ s.cons a h :=\n  Multiset.ssubset_cons h\n\n"}
{"name":"Finset.cons_subset","module":"Mathlib.Data.Finset.Insert","initialProofState":"α : Type u_1\ns t : Finset α\na : α\nh : Not (Membership.mem s a)\n⊢ Iff (HasSubset.Subset (Finset.cons a s h) t) (And (Membership.mem t a) (HasSubset.Subset s t))","decl":"theorem cons_subset {h : a ∉ s} : s.cons a h ⊆ t ↔ a ∈ t ∧ s ⊆ t :=\n  Multiset.cons_subset\n\n"}
{"name":"Finset.cons_subset_cons","module":"Mathlib.Data.Finset.Insert","initialProofState":"α : Type u_1\ns t : Finset α\na : α\nhs : Not (Membership.mem s a)\nht : Not (Membership.mem t a)\n⊢ Iff (HasSubset.Subset (Finset.cons a s hs) (Finset.cons a t ht)) (HasSubset.Subset s t)","decl":"@[simp]\ntheorem cons_subset_cons {hs ht} : s.cons a hs ⊆ t.cons a ht ↔ s ⊆ t := by\n  rwa [← coe_subset, coe_cons, coe_cons, Set.insert_subset_insert_iff, coe_subset]\n\n"}
{"name":"Finset.ssubset_iff_exists_cons_subset","module":"Mathlib.Data.Finset.Insert","initialProofState":"α : Type u_1\ns t : Finset α\n⊢ Iff (HasSSubset.SSubset s t) (Exists fun a => Exists fun h => HasSubset.Subset (Finset.cons a s h) t)","decl":"theorem ssubset_iff_exists_cons_subset : s ⊂ t ↔ ∃ (a : _) (h : a ∉ s), s.cons a h ⊆ t := by\n  refine ⟨fun h => ?_, fun ⟨a, ha, h⟩ => ssubset_of_ssubset_of_subset (ssubset_cons _) h⟩\n  obtain ⟨a, hs, ht⟩ := not_subset.1 h.2\n  exact ⟨a, ht, cons_subset.2 ⟨hs, h.subset⟩⟩\n\n"}
{"name":"Finset.cons_swap","module":"Mathlib.Data.Finset.Insert","initialProofState":"α : Type u_1\ns : Finset α\na b : α\nhb : Not (Membership.mem s b)\nha : Not (Membership.mem (Finset.cons b s hb) a)\n⊢ Eq (Finset.cons a (Finset.cons b s hb) ha) (Finset.cons b (Finset.cons a s ⋯) ⋯)","decl":"theorem cons_swap (hb : b ∉ s) (ha : a ∉ s.cons b hb) :\n    (s.cons b hb).cons a ha = (s.cons a fun h ↦ ha (mem_cons.mpr (.inr h))).cons b fun h ↦\n      ha (mem_cons.mpr (.inl ((mem_cons.mp h).elim symm (fun h ↦ False.elim (hb h))))) :=\n  eq_of_veq <| Multiset.cons_swap a b s.val\n\n"}
{"name":"Finset.consPiProd_fst","module":"Mathlib.Data.Finset.Insert","initialProofState":"α : Type u_1\ns : Finset α\na : α\nf : α → Type u_3\nhas : Not (Membership.mem s a)\nx : (i : α) → Membership.mem (Finset.cons a s has) i → f i\n⊢ Eq (Finset.consPiProd f has x).1 (x a ⋯)","decl":"/-- Split the added element of cons off a Pi type. -/\n@[simps!]\ndef consPiProd (f : α → Type*) (has : a ∉ s) (x : Π i ∈ cons a s has, f i) : f a × Π i ∈ s, f i :=\n  (x a (mem_cons_self a s), fun i hi => x i (mem_cons_of_mem hi))\n\n"}
{"name":"Finset.consPiProd_snd","module":"Mathlib.Data.Finset.Insert","initialProofState":"α : Type u_1\ns : Finset α\na : α\nf : α → Type u_3\nhas : Not (Membership.mem s a)\nx : (i : α) → Membership.mem (Finset.cons a s has) i → f i\ni : α\nhi : Membership.mem s i\n⊢ Eq ((Finset.consPiProd f has x).2 i hi) (x i ⋯)","decl":"/-- Split the added element of cons off a Pi type. -/\n@[simps!]\ndef consPiProd (f : α → Type*) (has : a ∉ s) (x : Π i ∈ cons a s has, f i) : f a × Π i ∈ s, f i :=\n  (x a (mem_cons_self a s), fun i hi => x i (mem_cons_of_mem hi))\n\n"}
{"name":"Finset.insert_def","module":"Mathlib.Data.Finset.Insert","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na : α\ns : Finset α\n⊢ Eq (Insert.insert a s) { val := Multiset.ndinsert a s.val, nodup := ⋯ }","decl":"theorem insert_def (a : α) (s : Finset α) : insert a s = ⟨_, s.2.ndinsert a⟩ :=\n  rfl\n\n"}
{"name":"Finset.insert_val","module":"Mathlib.Data.Finset.Insert","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na : α\ns : Finset α\n⊢ Eq (Insert.insert a s).val (Multiset.ndinsert a s.val)","decl":"@[simp]\ntheorem insert_val (a : α) (s : Finset α) : (insert a s).1 = ndinsert a s.1 :=\n  rfl\n\n"}
{"name":"Finset.insert_val'","module":"Mathlib.Data.Finset.Insert","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na : α\ns : Finset α\n⊢ Eq (Insert.insert a s).val (Multiset.cons a s.val).dedup","decl":"theorem insert_val' (a : α) (s : Finset α) : (insert a s).1 = dedup (a ::ₘ s.1) := by\n  rw [dedup_cons, dedup_eq_self]; rfl\n\n"}
{"name":"Finset.insert_val_of_not_mem","module":"Mathlib.Data.Finset.Insert","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na : α\ns : Finset α\nh : Not (Membership.mem s a)\n⊢ Eq (Insert.insert a s).val (Multiset.cons a s.val)","decl":"theorem insert_val_of_not_mem {a : α} {s : Finset α} (h : a ∉ s) : (insert a s).1 = a ::ₘ s.1 := by\n  rw [insert_val, ndinsert_of_not_mem h]\n\n"}
{"name":"Finset.mem_insert","module":"Mathlib.Data.Finset.Insert","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : Finset α\na b : α\n⊢ Iff (Membership.mem (Insert.insert b s) a) (Or (Eq a b) (Membership.mem s a))","decl":"@[simp]\ntheorem mem_insert : a ∈ insert b s ↔ a = b ∨ a ∈ s :=\n  mem_ndinsert\n\n"}
{"name":"Finset.mem_insert_self","module":"Mathlib.Data.Finset.Insert","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na : α\ns : Finset α\n⊢ Membership.mem (Insert.insert a s) a","decl":"theorem mem_insert_self (a : α) (s : Finset α) : a ∈ insert a s :=\n  mem_ndinsert_self a s.1\n\n"}
{"name":"Finset.mem_insert_of_mem","module":"Mathlib.Data.Finset.Insert","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : Finset α\na b : α\nh : Membership.mem s a\n⊢ Membership.mem (Insert.insert b s) a","decl":"theorem mem_insert_of_mem (h : a ∈ s) : a ∈ insert b s :=\n  mem_ndinsert_of_mem h\n\n"}
{"name":"Finset.mem_of_mem_insert_of_ne","module":"Mathlib.Data.Finset.Insert","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : Finset α\na b : α\nh : Membership.mem (Insert.insert a s) b\na✝ : Ne b a\n⊢ Membership.mem s b","decl":"theorem mem_of_mem_insert_of_ne (h : b ∈ insert a s) : b ≠ a → b ∈ s :=\n  (mem_insert.1 h).resolve_left\n\n"}
{"name":"Finset.eq_of_mem_insert_of_not_mem","module":"Mathlib.Data.Finset.Insert","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : Finset α\na b : α\nha : Membership.mem (Insert.insert a s) b\nhb : Not (Membership.mem s b)\n⊢ Eq b a","decl":"theorem eq_of_mem_insert_of_not_mem (ha : b ∈ insert a s) (hb : b ∉ s) : b = a :=\n  (mem_insert.1 ha).resolve_right hb\n\n"}
{"name":"Finset.insert_empty","module":"Mathlib.Data.Finset.Insert","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na : α\n⊢ Eq (Insert.insert a EmptyCollection.emptyCollection) (Singleton.singleton a)","decl":"/-- A version of `LawfulSingleton.insert_emptyc_eq` that works with `dsimp`. -/\n@[simp] lemma insert_empty : insert a (∅ : Finset α) = {a} := rfl\n\n"}
{"name":"Finset.cons_eq_insert","module":"Mathlib.Data.Finset.Insert","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na : α\ns : Finset α\nh : Not (Membership.mem s a)\n⊢ Eq (Finset.cons a s h) (Insert.insert a s)","decl":"@[simp]\ntheorem cons_eq_insert (a s h) : @cons α a s h = insert a s :=\n  ext fun a => by simp\n\n"}
{"name":"Finset.coe_insert","module":"Mathlib.Data.Finset.Insert","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na : α\ns : Finset α\n⊢ Eq (↑(Insert.insert a s)) (Insert.insert a ↑s)","decl":"@[simp, norm_cast]\ntheorem coe_insert (a : α) (s : Finset α) : ↑(insert a s) = (insert a s : Set α) :=\n  Set.ext fun x => by simp only [mem_coe, mem_insert, Set.mem_insert_iff]\n\n"}
{"name":"Finset.mem_insert_coe","module":"Mathlib.Data.Finset.Insert","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : Finset α\nx y : α\n⊢ Iff (Membership.mem (Insert.insert y s) x) (Membership.mem (Insert.insert y ↑s) x)","decl":"theorem mem_insert_coe {s : Finset α} {x y : α} : x ∈ insert y s ↔ x ∈ insert y (s : Set α) := by\n  simp\n\n"}
{"name":"Finset.instLawfulSingleton","module":"Mathlib.Data.Finset.Insert","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\n⊢ LawfulSingleton α (Finset α)","decl":"instance : LawfulSingleton α (Finset α) :=\n  ⟨fun a => by ext; simp⟩\n\n"}
{"name":"Finset.insert_eq_of_mem","module":"Mathlib.Data.Finset.Insert","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : Finset α\na : α\nh : Membership.mem s a\n⊢ Eq (Insert.insert a s) s","decl":"@[simp]\ntheorem insert_eq_of_mem (h : a ∈ s) : insert a s = s :=\n  eq_of_veq <| ndinsert_of_mem h\n\n"}
{"name":"Finset.insert_eq_self","module":"Mathlib.Data.Finset.Insert","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : Finset α\na : α\n⊢ Iff (Eq (Insert.insert a s) s) (Membership.mem s a)","decl":"@[simp]\ntheorem insert_eq_self : insert a s = s ↔ a ∈ s :=\n  ⟨fun h => h ▸ mem_insert_self _ _, insert_eq_of_mem⟩\n\n"}
{"name":"Finset.insert_ne_self","module":"Mathlib.Data.Finset.Insert","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : Finset α\na : α\n⊢ Iff (Ne (Insert.insert a s) s) (Not (Membership.mem s a))","decl":"theorem insert_ne_self : insert a s ≠ s ↔ a ∉ s :=\n  insert_eq_self.not\n\n"}
{"name":"Finset.pair_eq_singleton","module":"Mathlib.Data.Finset.Insert","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na : α\n⊢ Eq (Insert.insert a (Singleton.singleton a)) (Singleton.singleton a)","decl":"theorem pair_eq_singleton (a : α) : ({a, a} : Finset α) = {a} :=\n  insert_eq_of_mem <| mem_singleton_self _\n\n"}
{"name":"Finset.insert_comm","module":"Mathlib.Data.Finset.Insert","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na b : α\ns : Finset α\n⊢ Eq (Insert.insert a (Insert.insert b s)) (Insert.insert b (Insert.insert a s))","decl":"theorem insert_comm (a b : α) (s : Finset α) : insert a (insert b s) = insert b (insert a s) :=\n  ext fun x => by simp only [mem_insert, or_left_comm]\n\n"}
{"name":"Finset.Insert.comm","module":"Mathlib.Data.Finset.Insert","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na b : α\ns : Finset α\n⊢ Eq (Insert.insert a (Insert.insert b s)) (Insert.insert b (Insert.insert a s))","decl":"@[deprecated (since := \"2024-11-29\")] alias Insert.comm := insert_comm\n\n"}
{"name":"Finset.coe_pair","module":"Mathlib.Data.Finset.Insert","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na b : α\n⊢ Eq (↑(Insert.insert a (Singleton.singleton b))) (Insert.insert a (Singleton.singleton b))","decl":"@[norm_cast]\ntheorem coe_pair {a b : α} : (({a, b} : Finset α) : Set α) = {a, b} := by\n  ext\n  simp\n\n"}
{"name":"Finset.coe_eq_pair","module":"Mathlib.Data.Finset.Insert","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : Finset α\na b : α\n⊢ Iff (Eq (↑s) (Insert.insert a (Singleton.singleton b))) (Eq s (Insert.insert a (Singleton.singleton b)))","decl":"@[simp, norm_cast]\ntheorem coe_eq_pair {s : Finset α} {a b : α} : (s : Set α) = {a, b} ↔ s = {a, b} := by\n  rw [← coe_pair, coe_inj]\n\n"}
{"name":"Finset.pair_comm","module":"Mathlib.Data.Finset.Insert","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na b : α\n⊢ Eq (Insert.insert a (Singleton.singleton b)) (Insert.insert b (Singleton.singleton a))","decl":"theorem pair_comm (a b : α) : ({a, b} : Finset α) = {b, a} :=\n  insert_comm a b ∅\n\n"}
{"name":"Finset.insert_idem","module":"Mathlib.Data.Finset.Insert","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na : α\ns : Finset α\n⊢ Eq (Insert.insert a (Insert.insert a s)) (Insert.insert a s)","decl":"theorem insert_idem (a : α) (s : Finset α) : insert a (insert a s) = insert a s :=\n  ext fun x => by simp only [mem_insert, ← or_assoc, or_self_iff]\n\n"}
{"name":"Finset.insert_nonempty","module":"Mathlib.Data.Finset.Insert","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na : α\ns : Finset α\n⊢ (Insert.insert a s).Nonempty","decl":"@[simp, aesop safe apply (rule_sets := [finsetNonempty])]\ntheorem insert_nonempty (a : α) (s : Finset α) : (insert a s).Nonempty :=\n  ⟨a, mem_insert_self a s⟩\n\n"}
{"name":"Finset.insert_ne_empty","module":"Mathlib.Data.Finset.Insert","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na : α\ns : Finset α\n⊢ Ne (Insert.insert a s) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem insert_ne_empty (a : α) (s : Finset α) : insert a s ≠ ∅ :=\n  (insert_nonempty a s).ne_empty\n\n-- Porting note: explicit universe annotation is no longer required.\n"}
{"name":"Finset.instNonemptyElemToSetInsert","module":"Mathlib.Data.Finset.Insert","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ni : α\ns : Finset α\n⊢ Nonempty ↑↑(Insert.insert i s)","decl":"instance (i : α) (s : Finset α) : Nonempty ((insert i s : Finset α) : Set α) :=\n  (Finset.coe_nonempty.mpr (s.insert_nonempty i)).to_subtype\n\n"}
{"name":"Finset.ne_insert_of_not_mem","module":"Mathlib.Data.Finset.Insert","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\na : α\nh : Not (Membership.mem s a)\n⊢ Ne s (Insert.insert a t)","decl":"theorem ne_insert_of_not_mem (s t : Finset α) {a : α} (h : a ∉ s) : s ≠ insert a t := by\n  contrapose! h\n  simp [h]\n\n"}
{"name":"Finset.insert_subset_iff","module":"Mathlib.Data.Finset.Insert","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\na : α\n⊢ Iff (HasSubset.Subset (Insert.insert a s) t) (And (Membership.mem t a) (HasSubset.Subset s t))","decl":"theorem insert_subset_iff : insert a s ⊆ t ↔ a ∈ t ∧ s ⊆ t := by\n  simp only [subset_iff, mem_insert, forall_eq, or_imp, forall_and]\n\n"}
{"name":"Finset.insert_subset","module":"Mathlib.Data.Finset.Insert","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\na : α\nha : Membership.mem t a\nhs : HasSubset.Subset s t\n⊢ HasSubset.Subset (Insert.insert a s) t","decl":"theorem insert_subset (ha : a ∈ t) (hs : s ⊆ t) : insert a s ⊆ t :=\n  insert_subset_iff.mpr ⟨ha,hs⟩\n\n"}
{"name":"Finset.subset_insert","module":"Mathlib.Data.Finset.Insert","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na : α\ns : Finset α\n⊢ HasSubset.Subset s (Insert.insert a s)","decl":"@[simp] theorem subset_insert (a : α) (s : Finset α) : s ⊆ insert a s := fun _b => mem_insert_of_mem\n\n"}
{"name":"Finset.insert_subset_insert","module":"Mathlib.Data.Finset.Insert","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na : α\ns t : Finset α\nh : HasSubset.Subset s t\n⊢ HasSubset.Subset (Insert.insert a s) (Insert.insert a t)","decl":"@[gcongr]\ntheorem insert_subset_insert (a : α) {s t : Finset α} (h : s ⊆ t) : insert a s ⊆ insert a t :=\n  insert_subset_iff.2 ⟨mem_insert_self _ _, Subset.trans h (subset_insert _ _)⟩\n\n"}
{"name":"Finset.insert_subset_insert_iff","module":"Mathlib.Data.Finset.Insert","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\na : α\nha : Not (Membership.mem s a)\n⊢ Iff (HasSubset.Subset (Insert.insert a s) (Insert.insert a t)) (HasSubset.Subset s t)","decl":"@[simp] lemma insert_subset_insert_iff (ha : a ∉ s) : insert a s ⊆ insert a t ↔ s ⊆ t := by\n  simp_rw [← coe_subset]; simp [-coe_subset, ha]\n\n"}
{"name":"Finset.insert_inj","module":"Mathlib.Data.Finset.Insert","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : Finset α\na b : α\nha : Not (Membership.mem s a)\n⊢ Iff (Eq (Insert.insert a s) (Insert.insert b s)) (Eq a b)","decl":"theorem insert_inj (ha : a ∉ s) : insert a s = insert b s ↔ a = b :=\n  ⟨fun h => eq_of_mem_insert_of_not_mem (h ▸ mem_insert_self _ _) ha, congr_arg (insert · s)⟩\n\n"}
{"name":"Finset.insert_inj_on","module":"Mathlib.Data.Finset.Insert","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : Finset α\n⊢ Set.InjOn (fun a => Insert.insert a s) (HasCompl.compl ↑s)","decl":"theorem insert_inj_on (s : Finset α) : Set.InjOn (fun a => insert a s) sᶜ := fun _ h _ _ =>\n  (insert_inj h).1\n\n"}
{"name":"Finset.ssubset_iff","module":"Mathlib.Data.Finset.Insert","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\n⊢ Iff (HasSSubset.SSubset s t) (Exists fun a => And (Not (Membership.mem s a)) (HasSubset.Subset (Insert.insert a s) t))","decl":"theorem ssubset_iff : s ⊂ t ↔ ∃ a ∉ s, insert a s ⊆ t := mod_cast @Set.ssubset_iff_insert α s t\n\n"}
{"name":"Finset.ssubset_insert","module":"Mathlib.Data.Finset.Insert","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : Finset α\na : α\nh : Not (Membership.mem s a)\n⊢ HasSSubset.SSubset s (Insert.insert a s)","decl":"theorem ssubset_insert (h : a ∉ s) : s ⊂ insert a s :=\n  ssubset_iff.mpr ⟨a, h, Subset.rfl⟩\n\n"}
{"name":"Finset.cons_induction","module":"Mathlib.Data.Finset.Insert","initialProofState":"α : Type u_3\np : Finset α → Prop\nempty : p EmptyCollection.emptyCollection\ncons : ∀ (a : α) (s : Finset α) (h : Not (Membership.mem s a)), p s → p (Finset.cons a s h)\ns : Finset α\n⊢ p s","decl":"@[elab_as_elim]\ntheorem cons_induction {α : Type*} {p : Finset α → Prop} (empty : p ∅)\n    (cons : ∀ (a : α) (s : Finset α) (h : a ∉ s), p s → p (cons a s h)) : ∀ s, p s\n  | ⟨s, nd⟩ => by\n    induction s using Multiset.induction with\n    | empty => exact empty\n    | cons a s IH =>\n      rw [mk_cons nd]\n      exact cons a _ _ (IH _)\n\n"}
{"name":"Finset.cons_induction_on","module":"Mathlib.Data.Finset.Insert","initialProofState":"α : Type u_3\np : Finset α → Prop\ns : Finset α\nh₁ : p EmptyCollection.emptyCollection\nh₂ : ∀ ⦃a : α⦄ {s : Finset α} (h : Not (Membership.mem s a)), p s → p (Finset.cons a s h)\n⊢ p s","decl":"@[elab_as_elim]\ntheorem cons_induction_on {α : Type*} {p : Finset α → Prop} (s : Finset α) (h₁ : p ∅)\n    (h₂ : ∀ ⦃a : α⦄ {s : Finset α} (h : a ∉ s), p s → p (cons a s h)) : p s :=\n  cons_induction h₁ h₂ s\n\n"}
{"name":"Finset.induction","module":"Mathlib.Data.Finset.Insert","initialProofState":"α : Type u_3\np : Finset α → Prop\ninst✝ : DecidableEq α\nempty : p EmptyCollection.emptyCollection\ninsert : ∀ ⦃a : α⦄ {s : Finset α}, Not (Membership.mem s a) → p s → p (Insert.insert a s)\ns : Finset α\n⊢ p s","decl":"@[elab_as_elim]\nprotected theorem induction {α : Type*} {p : Finset α → Prop} [DecidableEq α] (empty : p ∅)\n    (insert : ∀ ⦃a : α⦄ {s : Finset α}, a ∉ s → p s → p (insert a s)) : ∀ s, p s :=\n  cons_induction empty fun a s ha => (s.cons_eq_insert a ha).symm ▸ insert ha\n\n"}
{"name":"Finset.induction_on","module":"Mathlib.Data.Finset.Insert","initialProofState":"α : Type u_3\np : Finset α → Prop\ninst✝ : DecidableEq α\ns : Finset α\nempty : p EmptyCollection.emptyCollection\ninsert : ∀ ⦃a : α⦄ {s : Finset α}, Not (Membership.mem s a) → p s → p (Insert.insert a s)\n⊢ p s","decl":"/-- To prove a proposition about an arbitrary `Finset α`,\nit suffices to prove it for the empty `Finset`,\nand to show that if it holds for some `Finset α`,\nthen it holds for the `Finset` obtained by inserting a new element.\n-/\n@[elab_as_elim]\nprotected theorem induction_on {α : Type*} {p : Finset α → Prop} [DecidableEq α] (s : Finset α)\n    (empty : p ∅) (insert : ∀ ⦃a : α⦄ {s : Finset α}, a ∉ s → p s → p (insert a s)) : p s :=\n  Finset.induction empty insert s\n\n"}
{"name":"Finset.induction_on'","module":"Mathlib.Data.Finset.Insert","initialProofState":"α : Type u_3\np : Finset α → Prop\ninst✝ : DecidableEq α\nS : Finset α\nh₁ : p EmptyCollection.emptyCollection\nh₂ : ∀ {a : α} {s : Finset α}, Membership.mem S a → HasSubset.Subset s S → Not (Membership.mem s a) → p s → p (Insert.insert a s)\n⊢ p S","decl":"/-- To prove a proposition about `S : Finset α`,\nit suffices to prove it for the empty `Finset`,\nand to show that if it holds for some `Finset α ⊆ S`,\nthen it holds for the `Finset` obtained by inserting a new element of `S`.\n-/\n@[elab_as_elim]\ntheorem induction_on' {α : Type*} {p : Finset α → Prop} [DecidableEq α] (S : Finset α) (h₁ : p ∅)\n    (h₂ : ∀ {a s}, a ∈ S → s ⊆ S → a ∉ s → p s → p (insert a s)) : p S :=\n  @Finset.induction_on α (fun T => T ⊆ S → p T) _ S (fun _ => h₁)\n    (fun _ _ has hqs hs =>\n      let ⟨hS, sS⟩ := Finset.insert_subset_iff.1 hs\n      h₂ hS sS has (hqs sS))\n    (Finset.Subset.refl S)\n\n"}
{"name":"Finset.Nonempty.cons_induction","module":"Mathlib.Data.Finset.Insert","initialProofState":"α : Type u_3\np : (s : Finset α) → s.Nonempty → Prop\nsingleton : ∀ (a : α), p (Singleton.singleton a) ⋯\ncons : ∀ (a : α) (s : Finset α) (h : Not (Membership.mem s a)) (hs : s.Nonempty), p s hs → p (Finset.cons a s h) ⋯\ns : Finset α\nhs : s.Nonempty\n⊢ p s hs","decl":"/-- To prove a proposition about a nonempty `s : Finset α`, it suffices to show it holds for all\nsingletons and that if it holds for nonempty `t : Finset α`, then it also holds for the `Finset`\nobtained by inserting an element in `t`. -/\n@[elab_as_elim]\ntheorem Nonempty.cons_induction {α : Type*} {p : ∀ s : Finset α, s.Nonempty → Prop}\n    (singleton : ∀ a, p {a} (singleton_nonempty _))\n    (cons : ∀ a s (h : a ∉ s) (hs), p s hs → p (Finset.cons a s h) (cons_nonempty h))\n    {s : Finset α} (hs : s.Nonempty) : p s hs := by\n  induction s using Finset.cons_induction with\n  | empty => exact (not_nonempty_empty hs).elim\n  | cons a t ha h =>\n    obtain rfl | ht := t.eq_empty_or_nonempty\n    · exact singleton a\n    · exact cons a t ha ht (h ht)\n\n-- We use a fresh `α` here to exclude the unneeded `DecidableEq α` instance from the section.\n"}
{"name":"Finset.Nonempty.exists_cons_eq","module":"Mathlib.Data.Finset.Insert","initialProofState":"α : Type u_3\ns : Finset α\nhs : s.Nonempty\n⊢ Exists fun t => Exists fun a => Exists fun ha => Eq (Finset.cons a t ha) s","decl":"lemma Nonempty.exists_cons_eq {α} {s : Finset α} (hs : s.Nonempty) : ∃ t a ha, cons a t ha = s :=\n  hs.cons_induction (fun a ↦ ⟨∅, a, _, cons_empty _⟩) fun _ _ _ _ _ ↦ ⟨_, _, _, rfl⟩\n\n"}
{"name":"Finset.insertPiProd_fst","module":"Mathlib.Data.Finset.Insert","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : Finset α\na : α\nf : α → Type u_3\nx : (i : α) → Membership.mem (Insert.insert a s) i → f i\n⊢ Eq (Finset.insertPiProd f x).1 (x a ⋯)","decl":"/-- Split the added element of insert off a Pi type. -/\n@[simps!]\ndef insertPiProd (f : α → Type*) (x : Π i ∈ insert a s, f i) : f a × Π i ∈ s, f i :=\n  (x a (mem_insert_self a s), fun i hi => x i (mem_insert_of_mem hi))\n\n"}
{"name":"Finset.insertPiProd_snd","module":"Mathlib.Data.Finset.Insert","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : Finset α\na : α\nf : α → Type u_3\nx : (i : α) → Membership.mem (Insert.insert a s) i → f i\ni : α\nhi : Membership.mem s i\n⊢ Eq ((Finset.insertPiProd f x).2 i hi) (x i ⋯)","decl":"/-- Split the added element of insert off a Pi type. -/\n@[simps!]\ndef insertPiProd (f : α → Type*) (x : Π i ∈ insert a s, f i) : f a × Π i ∈ s, f i :=\n  (x a (mem_insert_self a s), fun i hi => x i (mem_insert_of_mem hi))\n\n"}
{"name":"Finset.exists_mem_insert","module":"Mathlib.Data.Finset.Insert","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na : α\ns : Finset α\np : α → Prop\n⊢ Iff (Exists fun x => And (Membership.mem (Insert.insert a s) x) (p x)) (Or (p a) (Exists fun x => And (Membership.mem s x) (p x)))","decl":"theorem exists_mem_insert (a : α) (s : Finset α) (p : α → Prop) :\n    (∃ x, x ∈ insert a s ∧ p x) ↔ p a ∨ ∃ x, x ∈ s ∧ p x := by\n  simp only [mem_insert, or_and_right, exists_or, exists_eq_left]\n\n"}
{"name":"Finset.forall_mem_insert","module":"Mathlib.Data.Finset.Insert","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na : α\ns : Finset α\np : α → Prop\n⊢ Iff (∀ (x : α), Membership.mem (Insert.insert a s) x → p x) (And (p a) (∀ (x : α), Membership.mem s x → p x))","decl":"theorem forall_mem_insert (a : α) (s : Finset α) (p : α → Prop) :\n    (∀ x, x ∈ insert a s → p x) ↔ p a ∧ ∀ x, x ∈ s → p x := by\n  simp only [mem_insert, or_imp, forall_and, forall_eq]\n\n"}
{"name":"Finset.forall_of_forall_insert","module":"Mathlib.Data.Finset.Insert","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\np : α → Prop\na : α\ns : Finset α\nH : ∀ (x : α), Membership.mem (Insert.insert a s) x → p x\nx : α\nh : Membership.mem s x\n⊢ p x","decl":"/-- Useful in proofs by induction. -/\ntheorem forall_of_forall_insert {p : α → Prop} {a : α} {s : Finset α}\n    (H : ∀ x, x ∈ insert a s → p x) (x) (h : x ∈ s) : p x :=\n  H _ <| mem_insert_of_mem h\n\n"}
{"name":"Multiset.toFinset_zero","module":"Mathlib.Data.Finset.Insert","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\n⊢ Eq (Multiset.toFinset 0) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem toFinset_zero : toFinset (0 : Multiset α) = ∅ :=\n  rfl\n\n"}
{"name":"Multiset.toFinset_cons","module":"Mathlib.Data.Finset.Insert","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na : α\ns : Multiset α\n⊢ Eq (Multiset.cons a s).toFinset (Insert.insert a s.toFinset)","decl":"@[simp]\ntheorem toFinset_cons (a : α) (s : Multiset α) : toFinset (a ::ₘ s) = insert a (toFinset s) :=\n  Finset.eq_of_veq dedup_cons\n\n"}
{"name":"Multiset.toFinset_singleton","module":"Mathlib.Data.Finset.Insert","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na : α\n⊢ Eq (Singleton.singleton a).toFinset (Singleton.singleton a)","decl":"@[simp]\ntheorem toFinset_singleton (a : α) : toFinset ({a} : Multiset α) = {a} := by\n  rw [← cons_zero, toFinset_cons, toFinset_zero, LawfulSingleton.insert_emptyc_eq]\n\n"}
{"name":"List.toFinset_nil","module":"Mathlib.Data.Finset.Insert","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\n⊢ Eq List.nil.toFinset EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem toFinset_nil : toFinset (@nil α) = ∅ :=\n  rfl\n\n"}
{"name":"List.toFinset_cons","module":"Mathlib.Data.Finset.Insert","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nl : List α\na : α\n⊢ Eq (List.cons a l).toFinset (Insert.insert a l.toFinset)","decl":"@[simp]\ntheorem toFinset_cons : toFinset (a :: l) = insert a (toFinset l) :=\n  Finset.eq_of_veq <| by by_cases h : a ∈ l <;> simp [Finset.insert_val', Multiset.dedup_cons, h]\n\n"}
{"name":"List.toFinset_replicate_of_ne_zero","module":"Mathlib.Data.Finset.Insert","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na : α\nn : Nat\nhn : Ne n 0\n⊢ Eq (List.replicate n a).toFinset (Singleton.singleton a)","decl":"theorem toFinset_replicate_of_ne_zero {n : ℕ} (hn : n ≠ 0) :\n    (List.replicate n a).toFinset = {a} := by\n  ext x\n  simp [hn, List.mem_replicate]\n\n"}
{"name":"List.toFinset_eq_empty_iff","module":"Mathlib.Data.Finset.Insert","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nl : List α\n⊢ Iff (Eq l.toFinset EmptyCollection.emptyCollection) (Eq l List.nil)","decl":"@[simp]\ntheorem toFinset_eq_empty_iff (l : List α) : l.toFinset = ∅ ↔ l = nil := by\n  cases l <;> simp\n\n"}
{"name":"List.toFinset_nonempty_iff","module":"Mathlib.Data.Finset.Insert","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nl : List α\n⊢ Iff l.toFinset.Nonempty (Ne l List.nil)","decl":"@[simp]\ntheorem toFinset_nonempty_iff (l : List α) : l.toFinset.Nonempty ↔ l ≠ [] := by\n  simp [Finset.nonempty_iff_ne_empty]\n\n"}
{"name":"Finset.toList_eq_singleton_iff","module":"Mathlib.Data.Finset.Insert","initialProofState":"α : Type u_1\na : α\ns : Finset α\n⊢ Iff (Eq s.toList (List.cons a List.nil)) (Eq s (Singleton.singleton a))","decl":"@[simp]\ntheorem toList_eq_singleton_iff {a : α} {s : Finset α} : s.toList = [a] ↔ s = {a} := by\n  rw [toList, Multiset.toList_eq_singleton_iff, val_eq_singleton_iff]\n\n"}
{"name":"Finset.toList_singleton","module":"Mathlib.Data.Finset.Insert","initialProofState":"α : Type u_1\na : α\n⊢ Eq (Singleton.singleton a).toList (List.cons a List.nil)","decl":"@[simp]\ntheorem toList_singleton : ∀ a, ({a} : Finset α).toList = [a] :=\n  Multiset.toList_singleton\n\n"}
{"name":"Finset.toList_cons","module":"Mathlib.Data.Finset.Insert","initialProofState":"α : Type u_1\na : α\ns : Finset α\nh : Not (Membership.mem s a)\n⊢ (Finset.cons a s h).toList.Perm (List.cons a s.toList)","decl":"open scoped List in\ntheorem toList_cons {a : α} {s : Finset α} (h : a ∉ s) : (cons a s h).toList ~ a :: s.toList :=\n  (List.perm_ext_iff_of_nodup (nodup_toList _) (by simp [h, nodup_toList s])).2 fun x => by\n    simp only [List.mem_cons, Finset.mem_toList, Finset.mem_cons]\n\n"}
{"name":"Finset.toList_insert","module":"Mathlib.Data.Finset.Insert","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na : α\ns : Finset α\nh : Not (Membership.mem s a)\n⊢ (Insert.insert a s).toList.Perm (List.cons a s.toList)","decl":"open scoped List in\ntheorem toList_insert [DecidableEq α] {a : α} {s : Finset α} (h : a ∉ s) :\n    (insert a s).toList ~ a :: s.toList :=\n  cons_eq_insert _ _ h ▸ toList_cons _\n\n"}
{"name":"Finset.pairwise_cons'","module":"Mathlib.Data.Finset.Insert","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Finset α\na : α\nha : Not (Membership.mem s a)\nr : β → β → Prop\nf : α → β\n⊢ Iff (Pairwise (Function.onFun r fun a_1 => f ↑a_1)) (And (Pairwise (Function.onFun r fun a => f ↑a)) (∀ (b : α), Membership.mem s b → And (r (f a) (f b)) (r (f b) (f a))))","decl":"theorem pairwise_cons' {a : α} (ha : a ∉ s) (r : β → β → Prop) (f : α → β) :\n    Pairwise (r on fun a : s.cons a ha => f a) ↔\n    Pairwise (r on fun a : s => f a) ∧ ∀ b ∈ s, r (f a) (f b) ∧ r (f b) (f a) := by\n  simp only [pairwise_subtype_iff_pairwise_finset', Finset.coe_cons, Set.pairwise_insert,\n    Finset.mem_coe, and_congr_right_iff]\n  exact fun _ =>\n    ⟨fun h b hb =>\n      h b hb <| by\n        rintro rfl\n        contradiction,\n      fun h b hb _ => h b hb⟩\n\n"}
{"name":"Finset.pairwise_cons","module":"Mathlib.Data.Finset.Insert","initialProofState":"α : Type u_1\ns : Finset α\na : α\nha : Not (Membership.mem s a)\nr : α → α → Prop\n⊢ Iff (Pairwise (Function.onFun r fun a_1 => ↑a_1)) (And (Pairwise (Function.onFun r fun a => ↑a)) (∀ (b : α), Membership.mem s b → And (r a b) (r b a)))","decl":"theorem pairwise_cons {a : α} (ha : a ∉ s) (r : α → α → Prop) :\n    Pairwise (r on fun a : s.cons a ha => a) ↔\n      Pairwise (r on fun a : s => a) ∧ ∀ b ∈ s, r a b ∧ r b a :=\n  pairwise_cons' ha r id\n\n"}
