{"name":"CategoryTheory.ShortComplex.LeftHomologyData.mk.injEq","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nK✝ H✝ : C\ni✝ : Quiver.Hom K✝ S.X₂\nπ✝ : Quiver.Hom K✝ H✝\nwi✝ : Eq (CategoryTheory.CategoryStruct.comp i✝ S.g) 0\nhi✝ : CategoryTheory.Limits.IsLimit (CategoryTheory.Limits.KernelFork.ofι i✝ wi✝)\nwπ✝ : Eq (CategoryTheory.CategoryStruct.comp (hi✝.lift (CategoryTheory.Limits.KernelFork.ofι S.f ⋯)) π✝) 0\nhπ✝ : CategoryTheory.Limits.IsColimit (CategoryTheory.Limits.CokernelCofork.ofπ π✝ wπ✝)\nK H : C\ni : Quiver.Hom K S.X₂\nπ : Quiver.Hom K H\nwi : Eq (CategoryTheory.CategoryStruct.comp i S.g) 0\nhi : CategoryTheory.Limits.IsLimit (CategoryTheory.Limits.KernelFork.ofι i wi)\nwπ : Eq (CategoryTheory.CategoryStruct.comp (hi.lift (CategoryTheory.Limits.KernelFork.ofι S.f ⋯)) π) 0\nhπ : CategoryTheory.Limits.IsColimit (CategoryTheory.Limits.CokernelCofork.ofπ π wπ)\n⊢ Eq (Eq { K := K✝, H := H✝, i := i✝, π := π✝, wi := wi✝, hi := hi✝, wπ := wπ✝, hπ := hπ✝ } { K := K, H := H, i := i, π := π, wi := wi, hi := hi, wπ := wπ, hπ := hπ }) (And (Eq K✝ K) (And (Eq H✝ H) (And (HEq i✝ i) (And (HEq π✝ π) (And (HEq hi✝ hi) (HEq hπ✝ hπ))))))","decl":"/-- A left homology data for a short complex `S` consists of morphisms `i : K ⟶ S.X₂` and\n`π : K ⟶ H` such that `i` identifies `K` to the kernel of `g : S.X₂ ⟶ S.X₃`,\nand that `π` identifies `H` to the cokernel of the induced map `f' : S.X₁ ⟶ K` -/\nstructure LeftHomologyData where\n  /-- a choice of kernel of `S.g : S.X₂ ⟶ S.X₃`-/\n  K : C\n  /-- a choice of cokernel of the induced morphism `S.f' : S.X₁ ⟶ K`-/\n  H : C\n  /-- the inclusion of cycles in `S.X₂` -/\n  i : K ⟶ S.X₂\n  /-- the projection from cycles to the (left) homology -/\n  π : K ⟶ H\n  /-- the kernel condition for `i` -/\n  wi : i ≫ S.g = 0\n  /-- `i : K ⟶ S.X₂` is a kernel of `g : S.X₂ ⟶ S.X₃` -/\n  hi : IsLimit (KernelFork.ofι i wi)\n  /-- the cokernel condition for `π` -/\n  wπ : hi.lift (KernelFork.ofι _ S.zero) ≫ π = 0\n  /-- `π : K ⟶ H` is a cokernel of the induced morphism `S.f' : S.X₁ ⟶ K` -/\n  hπ : IsColimit (CokernelCofork.ofπ π wπ)\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.wπ","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nself : S.LeftHomologyData\n⊢ Eq (CategoryTheory.CategoryStruct.comp (self.hi.lift (CategoryTheory.Limits.KernelFork.ofι S.f ⋯)) self.π) 0","decl":"/-- A left homology data for a short complex `S` consists of morphisms `i : K ⟶ S.X₂` and\n`π : K ⟶ H` such that `i` identifies `K` to the kernel of `g : S.X₂ ⟶ S.X₃`,\nand that `π` identifies `H` to the cokernel of the induced map `f' : S.X₁ ⟶ K` -/\nstructure LeftHomologyData where\n  /-- a choice of kernel of `S.g : S.X₂ ⟶ S.X₃`-/\n  K : C\n  /-- a choice of cokernel of the induced morphism `S.f' : S.X₁ ⟶ K`-/\n  H : C\n  /-- the inclusion of cycles in `S.X₂` -/\n  i : K ⟶ S.X₂\n  /-- the projection from cycles to the (left) homology -/\n  π : K ⟶ H\n  /-- the kernel condition for `i` -/\n  wi : i ≫ S.g = 0\n  /-- `i : K ⟶ S.X₂` is a kernel of `g : S.X₂ ⟶ S.X₃` -/\n  hi : IsLimit (KernelFork.ofι i wi)\n  /-- the cokernel condition for `π` -/\n  wπ : hi.lift (KernelFork.ofι _ S.zero) ≫ π = 0\n  /-- `π : K ⟶ H` is a cokernel of the induced morphism `S.f' : S.X₁ ⟶ K` -/\n  hπ : IsColimit (CokernelCofork.ofπ π wπ)\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.mk.inj","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nK✝ H✝ : C\ni✝ : Quiver.Hom K✝ S.X₂\nπ✝ : Quiver.Hom K✝ H✝\nwi✝ : Eq (CategoryTheory.CategoryStruct.comp i✝ S.g) 0\nhi✝ : CategoryTheory.Limits.IsLimit (CategoryTheory.Limits.KernelFork.ofι i✝ wi✝)\nwπ✝ : Eq (CategoryTheory.CategoryStruct.comp (hi✝.lift (CategoryTheory.Limits.KernelFork.ofι S.f ⋯)) π✝) 0\nhπ✝ : CategoryTheory.Limits.IsColimit (CategoryTheory.Limits.CokernelCofork.ofπ π✝ wπ✝)\nK H : C\ni : Quiver.Hom K S.X₂\nπ : Quiver.Hom K H\nwi : Eq (CategoryTheory.CategoryStruct.comp i S.g) 0\nhi : CategoryTheory.Limits.IsLimit (CategoryTheory.Limits.KernelFork.ofι i wi)\nwπ : Eq (CategoryTheory.CategoryStruct.comp (hi.lift (CategoryTheory.Limits.KernelFork.ofι S.f ⋯)) π) 0\nhπ : CategoryTheory.Limits.IsColimit (CategoryTheory.Limits.CokernelCofork.ofπ π wπ)\nx✝ : Eq { K := K✝, H := H✝, i := i✝, π := π✝, wi := wi✝, hi := hi✝, wπ := wπ✝, hπ := hπ✝ } { K := K, H := H, i := i, π := π, wi := wi, hi := hi, wπ := wπ, hπ := hπ }\n⊢ And (Eq K✝ K) (And (Eq H✝ H) (And (HEq i✝ i) (And (HEq π✝ π) (And (HEq hi✝ hi) (HEq hπ✝ hπ)))))","decl":"/-- A left homology data for a short complex `S` consists of morphisms `i : K ⟶ S.X₂` and\n`π : K ⟶ H` such that `i` identifies `K` to the kernel of `g : S.X₂ ⟶ S.X₃`,\nand that `π` identifies `H` to the cokernel of the induced map `f' : S.X₁ ⟶ K` -/\nstructure LeftHomologyData where\n  /-- a choice of kernel of `S.g : S.X₂ ⟶ S.X₃`-/\n  K : C\n  /-- a choice of cokernel of the induced morphism `S.f' : S.X₁ ⟶ K`-/\n  H : C\n  /-- the inclusion of cycles in `S.X₂` -/\n  i : K ⟶ S.X₂\n  /-- the projection from cycles to the (left) homology -/\n  π : K ⟶ H\n  /-- the kernel condition for `i` -/\n  wi : i ≫ S.g = 0\n  /-- `i : K ⟶ S.X₂` is a kernel of `g : S.X₂ ⟶ S.X₃` -/\n  hi : IsLimit (KernelFork.ofι i wi)\n  /-- the cokernel condition for `π` -/\n  wπ : hi.lift (KernelFork.ofι _ S.zero) ≫ π = 0\n  /-- `π : K ⟶ H` is a cokernel of the induced morphism `S.f' : S.X₁ ⟶ K` -/\n  hπ : IsColimit (CokernelCofork.ofπ π wπ)\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.mk.sizeOf_spec","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst✝ : SizeOf C\nK H : C\ni : Quiver.Hom K S.X₂\nπ : Quiver.Hom K H\nwi : Eq (CategoryTheory.CategoryStruct.comp i S.g) 0\nhi : CategoryTheory.Limits.IsLimit (CategoryTheory.Limits.KernelFork.ofι i wi)\nwπ : Eq (CategoryTheory.CategoryStruct.comp (hi.lift (CategoryTheory.Limits.KernelFork.ofι S.f ⋯)) π) 0\nhπ : CategoryTheory.Limits.IsColimit (CategoryTheory.Limits.CokernelCofork.ofπ π wπ)\n⊢ Eq (SizeOf.sizeOf { K := K, H := H, i := i, π := π, wi := wi, hi := hi, wπ := wπ, hπ := hπ }) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf K)) (SizeOf.sizeOf H)) (SizeOf.sizeOf i)) (SizeOf.sizeOf π)) (SizeOf.sizeOf wi)) (SizeOf.sizeOf hi)) (SizeOf.sizeOf wπ)) (SizeOf.sizeOf hπ))","decl":"/-- A left homology data for a short complex `S` consists of morphisms `i : K ⟶ S.X₂` and\n`π : K ⟶ H` such that `i` identifies `K` to the kernel of `g : S.X₂ ⟶ S.X₃`,\nand that `π` identifies `H` to the cokernel of the induced map `f' : S.X₁ ⟶ K` -/\nstructure LeftHomologyData where\n  /-- a choice of kernel of `S.g : S.X₂ ⟶ S.X₃`-/\n  K : C\n  /-- a choice of cokernel of the induced morphism `S.f' : S.X₁ ⟶ K`-/\n  H : C\n  /-- the inclusion of cycles in `S.X₂` -/\n  i : K ⟶ S.X₂\n  /-- the projection from cycles to the (left) homology -/\n  π : K ⟶ H\n  /-- the kernel condition for `i` -/\n  wi : i ≫ S.g = 0\n  /-- `i : K ⟶ S.X₂` is a kernel of `g : S.X₂ ⟶ S.X₃` -/\n  hi : IsLimit (KernelFork.ofι i wi)\n  /-- the cokernel condition for `π` -/\n  wπ : hi.lift (KernelFork.ofι _ S.zero) ≫ π = 0\n  /-- `π : K ⟶ H` is a cokernel of the induced morphism `S.f' : S.X₁ ⟶ K` -/\n  hπ : IsColimit (CokernelCofork.ofπ π wπ)\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.wi","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nself : S.LeftHomologyData\n⊢ Eq (CategoryTheory.CategoryStruct.comp self.i S.g) 0","decl":"/-- A left homology data for a short complex `S` consists of morphisms `i : K ⟶ S.X₂` and\n`π : K ⟶ H` such that `i` identifies `K` to the kernel of `g : S.X₂ ⟶ S.X₃`,\nand that `π` identifies `H` to the cokernel of the induced map `f' : S.X₁ ⟶ K` -/\nstructure LeftHomologyData where\n  /-- a choice of kernel of `S.g : S.X₂ ⟶ S.X₃`-/\n  K : C\n  /-- a choice of cokernel of the induced morphism `S.f' : S.X₁ ⟶ K`-/\n  H : C\n  /-- the inclusion of cycles in `S.X₂` -/\n  i : K ⟶ S.X₂\n  /-- the projection from cycles to the (left) homology -/\n  π : K ⟶ H\n  /-- the kernel condition for `i` -/\n  wi : i ≫ S.g = 0\n  /-- `i : K ⟶ S.X₂` is a kernel of `g : S.X₂ ⟶ S.X₃` -/\n  hi : IsLimit (KernelFork.ofι i wi)\n  /-- the cokernel condition for `π` -/\n  wπ : hi.lift (KernelFork.ofι _ S.zero) ≫ π = 0\n  /-- `π : K ⟶ H` is a cokernel of the induced morphism `S.f' : S.X₁ ⟶ K` -/\n  hπ : IsColimit (CokernelCofork.ofπ π wπ)\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.ofHasKernelOfHasCokernel_i","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_2, u_1} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst✝¹ : CategoryTheory.Limits.HasKernel S.g\ninst✝ : CategoryTheory.Limits.HasCokernel (CategoryTheory.Limits.kernel.lift S.g S.f ⋯)\n⊢ Eq (CategoryTheory.ShortComplex.LeftHomologyData.ofHasKernelOfHasCokernel S).i (CategoryTheory.Limits.kernel.ι S.g)","decl":"/-- The chosen kernels and cokernels of the limits API give a `LeftHomologyData` -/\n@[simps]\nnoncomputable def ofHasKernelOfHasCokernel\n    [HasKernel S.g] [HasCokernel (kernel.lift S.g S.f S.zero)] :\n    S.LeftHomologyData where\n  K := kernel S.g\n  H := cokernel (kernel.lift S.g S.f S.zero)\n  i := kernel.ι _\n  π := cokernel.π _\n  wi := kernel.condition _\n  hi := kernelIsKernel _\n  wπ := cokernel.condition _\n  hπ := cokernelIsCokernel _\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.ofHasKernelOfHasCokernel_K","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_2, u_1} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst✝¹ : CategoryTheory.Limits.HasKernel S.g\ninst✝ : CategoryTheory.Limits.HasCokernel (CategoryTheory.Limits.kernel.lift S.g S.f ⋯)\n⊢ Eq (CategoryTheory.ShortComplex.LeftHomologyData.ofHasKernelOfHasCokernel S).K (CategoryTheory.Limits.kernel S.g)","decl":"/-- The chosen kernels and cokernels of the limits API give a `LeftHomologyData` -/\n@[simps]\nnoncomputable def ofHasKernelOfHasCokernel\n    [HasKernel S.g] [HasCokernel (kernel.lift S.g S.f S.zero)] :\n    S.LeftHomologyData where\n  K := kernel S.g\n  H := cokernel (kernel.lift S.g S.f S.zero)\n  i := kernel.ι _\n  π := cokernel.π _\n  wi := kernel.condition _\n  hi := kernelIsKernel _\n  wπ := cokernel.condition _\n  hπ := cokernelIsCokernel _\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.ofHasKernelOfHasCokernel_H","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_2, u_1} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst✝¹ : CategoryTheory.Limits.HasKernel S.g\ninst✝ : CategoryTheory.Limits.HasCokernel (CategoryTheory.Limits.kernel.lift S.g S.f ⋯)\n⊢ Eq (CategoryTheory.ShortComplex.LeftHomologyData.ofHasKernelOfHasCokernel S).H (CategoryTheory.Limits.cokernel (CategoryTheory.Limits.kernel.lift S.g S.f ⋯))","decl":"/-- The chosen kernels and cokernels of the limits API give a `LeftHomologyData` -/\n@[simps]\nnoncomputable def ofHasKernelOfHasCokernel\n    [HasKernel S.g] [HasCokernel (kernel.lift S.g S.f S.zero)] :\n    S.LeftHomologyData where\n  K := kernel S.g\n  H := cokernel (kernel.lift S.g S.f S.zero)\n  i := kernel.ι _\n  π := cokernel.π _\n  wi := kernel.condition _\n  hi := kernelIsKernel _\n  wπ := cokernel.condition _\n  hπ := cokernelIsCokernel _\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.ofHasKernelOfHasCokernel_π","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_2, u_1} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst✝¹ : CategoryTheory.Limits.HasKernel S.g\ninst✝ : CategoryTheory.Limits.HasCokernel (CategoryTheory.Limits.kernel.lift S.g S.f ⋯)\n⊢ Eq (CategoryTheory.ShortComplex.LeftHomologyData.ofHasKernelOfHasCokernel S).π (CategoryTheory.Limits.cokernel.π (CategoryTheory.Limits.kernel.lift S.g S.f ⋯))","decl":"/-- The chosen kernels and cokernels of the limits API give a `LeftHomologyData` -/\n@[simps]\nnoncomputable def ofHasKernelOfHasCokernel\n    [HasKernel S.g] [HasCokernel (kernel.lift S.g S.f S.zero)] :\n    S.LeftHomologyData where\n  K := kernel S.g\n  H := cokernel (kernel.lift S.g S.f S.zero)\n  i := kernel.ι _\n  π := cokernel.π _\n  wi := kernel.condition _\n  hi := kernelIsKernel _\n  wπ := cokernel.condition _\n  hπ := cokernelIsCokernel _\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.wi_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nself : S.LeftHomologyData\nZ : C\nh : Quiver.Hom S.X₃ Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp self.i (CategoryTheory.CategoryStruct.comp S.g h)) (CategoryTheory.CategoryStruct.comp 0 h)","decl":"attribute [reassoc (attr := simp)] wi wπ\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.wπ_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nself : S.LeftHomologyData\nZ : C\nh : Quiver.Hom self.H Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (self.hi.lift (CategoryTheory.Limits.KernelFork.ofι S.f ⋯)) (CategoryTheory.CategoryStruct.comp self.π h)) (CategoryTheory.CategoryStruct.comp 0 h)","decl":"attribute [reassoc (attr := simp)] wi wπ\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.instMonoI","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nh : S.LeftHomologyData\n⊢ CategoryTheory.Mono h.i","decl":"instance : Mono h.i := ⟨fun _ _ => Fork.IsLimit.hom_ext h.hi⟩\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.instEpiπ","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nh : S.LeftHomologyData\n⊢ CategoryTheory.Epi h.π","decl":"instance : Epi h.π := ⟨fun _ _ => Cofork.IsColimit.hom_ext h.hπ⟩\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.liftK_i","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nh : S.LeftHomologyData\nA : C\nk : Quiver.Hom A S.X₂\nhk : Eq (CategoryTheory.CategoryStruct.comp k S.g) 0\n⊢ Eq (CategoryTheory.CategoryStruct.comp (h.liftK k hk) h.i) k","decl":"@[reassoc (attr := simp)]\nlemma liftK_i (k : A ⟶ S.X₂) (hk : k ≫ S.g = 0) : h.liftK k hk ≫ h.i = k :=\n  h.hi.fac _ WalkingParallelPair.zero\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.liftK_i_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nh✝ : S.LeftHomologyData\nA : C\nk : Quiver.Hom A S.X₂\nhk : Eq (CategoryTheory.CategoryStruct.comp k S.g) 0\nZ : C\nh : Quiver.Hom S.X₂ Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (h✝.liftK k hk) (CategoryTheory.CategoryStruct.comp h✝.i h)) (CategoryTheory.CategoryStruct.comp k h)","decl":"@[reassoc (attr := simp)]\nlemma liftK_i (k : A ⟶ S.X₂) (hk : k ≫ S.g = 0) : h.liftK k hk ≫ h.i = k :=\n  h.hi.fac _ WalkingParallelPair.zero\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.f'_i","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nh : S.LeftHomologyData\n⊢ Eq (CategoryTheory.CategoryStruct.comp h.f' h.i) S.f","decl":"@[reassoc (attr := simp)] lemma f'_i : h.f' ≫ h.i = S.f := liftK_i _ _ _\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.f'_i_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nh✝ : S.LeftHomologyData\nZ : C\nh : Quiver.Hom S.X₂ Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp h✝.f' (CategoryTheory.CategoryStruct.comp h✝.i h)) (CategoryTheory.CategoryStruct.comp S.f h)","decl":"@[reassoc (attr := simp)] lemma f'_i : h.f' ≫ h.i = S.f := liftK_i _ _ _\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.f'_π","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nh : S.LeftHomologyData\n⊢ Eq (CategoryTheory.CategoryStruct.comp h.f' h.π) 0","decl":"@[reassoc (attr := simp)] lemma f'_π : h.f' ≫ h.π = 0 := h.wπ\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.f'_π_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nh✝ : S.LeftHomologyData\nZ : C\nh : Quiver.Hom h✝.H Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp h✝.f' (CategoryTheory.CategoryStruct.comp h✝.π h)) (CategoryTheory.CategoryStruct.comp 0 h)","decl":"@[reassoc (attr := simp)] lemma f'_π : h.f' ≫ h.π = 0 := h.wπ\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.liftK_π_eq_zero_of_boundary","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nh : S.LeftHomologyData\nA : C\nk : Quiver.Hom A S.X₂\nx : Quiver.Hom A S.X₁\nhx : Eq k (CategoryTheory.CategoryStruct.comp x S.f)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (h.liftK k ⋯) h.π) 0","decl":"@[reassoc]\nlemma liftK_π_eq_zero_of_boundary (k : A ⟶ S.X₂) (x : A ⟶ S.X₁) (hx : k = x ≫ S.f) :\n    h.liftK k (by rw [hx, assoc, S.zero, comp_zero]) ≫ h.π = 0 := by\n  rw [show 0 = (x ≫ h.f') ≫ h.π by simp]\n  congr 1\n  simp only [← cancel_mono h.i, hx, liftK_i, assoc, f'_i]\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.liftK_π_eq_zero_of_boundary_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nh✝ : S.LeftHomologyData\nA : C\nk : Quiver.Hom A S.X₂\nx : Quiver.Hom A S.X₁\nhx : Eq k (CategoryTheory.CategoryStruct.comp x S.f)\nZ : C\nh : Quiver.Hom h✝.H Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (h✝.liftK k ⋯) (CategoryTheory.CategoryStruct.comp h✝.π h)) (CategoryTheory.CategoryStruct.comp 0 h)","decl":"@[reassoc]\nlemma liftK_π_eq_zero_of_boundary (k : A ⟶ S.X₂) (x : A ⟶ S.X₁) (hx : k = x ≫ S.f) :\n    h.liftK k (by rw [hx, assoc, S.zero, comp_zero]) ≫ h.π = 0 := by\n  rw [show 0 = (x ≫ h.f') ≫ h.π by simp]\n  congr 1\n  simp only [← cancel_mono h.i, hx, liftK_i, assoc, f'_i]\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.π_descH_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nh✝ : S.LeftHomologyData\nA : C\nk : Quiver.Hom h✝.K A\nhk : Eq (CategoryTheory.CategoryStruct.comp h✝.f' k) 0\nZ : C\nh : Quiver.Hom A Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp h✝.π (CategoryTheory.CategoryStruct.comp (h✝.descH k hk) h)) (CategoryTheory.CategoryStruct.comp k h)","decl":"@[reassoc (attr := simp)]\nlemma π_descH (k : h.K ⟶ A) (hk : h.f' ≫ k = 0) : h.π ≫ h.descH k hk = k :=\n  h.hπ.fac (CokernelCofork.ofπ k hk) WalkingParallelPair.one\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.π_descH","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nh : S.LeftHomologyData\nA : C\nk : Quiver.Hom h.K A\nhk : Eq (CategoryTheory.CategoryStruct.comp h.f' k) 0\n⊢ Eq (CategoryTheory.CategoryStruct.comp h.π (h.descH k hk)) k","decl":"@[reassoc (attr := simp)]\nlemma π_descH (k : h.K ⟶ A) (hk : h.f' ≫ k = 0) : h.π ≫ h.descH k hk = k :=\n  h.hπ.fac (CokernelCofork.ofπ k hk) WalkingParallelPair.one\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.isIso_i","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nh : S.LeftHomologyData\nhg : Eq S.g 0\n⊢ CategoryTheory.IsIso h.i","decl":"lemma isIso_i (hg : S.g = 0) : IsIso h.i :=\n  ⟨h.liftK (𝟙 S.X₂) (by rw [hg, id_comp]),\n    by simp only [← cancel_mono h.i, id_comp, assoc, liftK_i, comp_id], liftK_i _ _ _⟩\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.isIso_π","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nh : S.LeftHomologyData\nhf : Eq S.f 0\n⊢ CategoryTheory.IsIso h.π","decl":"lemma isIso_π (hf : S.f = 0) : IsIso h.π := by\n  have ⟨φ, hφ⟩ := CokernelCofork.IsColimit.desc' h.hπ' (𝟙 _)\n    (by rw [← cancel_mono h.i, comp_id, f'_i, zero_comp, hf])\n  dsimp at hφ\n  exact ⟨φ, hφ, by rw [← cancel_epi h.π, reassoc_of% hφ, comp_id]⟩\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.ofIsColimitCokernelCofork_i","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nhg : Eq S.g 0\nc : CategoryTheory.Limits.CokernelCofork S.f\nhc : CategoryTheory.Limits.IsColimit c\n⊢ Eq (CategoryTheory.ShortComplex.LeftHomologyData.ofIsColimitCokernelCofork S hg c hc).i (CategoryTheory.CategoryStruct.id S.X₂)","decl":"/-- When the second map `S.g` is zero, this is the left homology data on `S` given\nby any colimit cokernel cofork of `S.f` -/\n@[simps]\ndef ofIsColimitCokernelCofork (hg : S.g = 0) (c : CokernelCofork S.f) (hc : IsColimit c) :\n    S.LeftHomologyData where\n  K := S.X₂\n  H := c.pt\n  i := 𝟙 _\n  π := c.π\n  wi := by rw [id_comp, hg]\n  hi := KernelFork.IsLimit.ofId _ hg\n  wπ := CokernelCofork.condition _\n  hπ := IsColimit.ofIsoColimit hc (Cofork.ext (Iso.refl _))\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.ofIsColimitCokernelCofork_H","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nhg : Eq S.g 0\nc : CategoryTheory.Limits.CokernelCofork S.f\nhc : CategoryTheory.Limits.IsColimit c\n⊢ Eq (CategoryTheory.ShortComplex.LeftHomologyData.ofIsColimitCokernelCofork S hg c hc).H c.pt","decl":"/-- When the second map `S.g` is zero, this is the left homology data on `S` given\nby any colimit cokernel cofork of `S.f` -/\n@[simps]\ndef ofIsColimitCokernelCofork (hg : S.g = 0) (c : CokernelCofork S.f) (hc : IsColimit c) :\n    S.LeftHomologyData where\n  K := S.X₂\n  H := c.pt\n  i := 𝟙 _\n  π := c.π\n  wi := by rw [id_comp, hg]\n  hi := KernelFork.IsLimit.ofId _ hg\n  wπ := CokernelCofork.condition _\n  hπ := IsColimit.ofIsoColimit hc (Cofork.ext (Iso.refl _))\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.ofIsColimitCokernelCofork_π","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nhg : Eq S.g 0\nc : CategoryTheory.Limits.CokernelCofork S.f\nhc : CategoryTheory.Limits.IsColimit c\n⊢ Eq (CategoryTheory.ShortComplex.LeftHomologyData.ofIsColimitCokernelCofork S hg c hc).π (CategoryTheory.Limits.Cofork.π c)","decl":"/-- When the second map `S.g` is zero, this is the left homology data on `S` given\nby any colimit cokernel cofork of `S.f` -/\n@[simps]\ndef ofIsColimitCokernelCofork (hg : S.g = 0) (c : CokernelCofork S.f) (hc : IsColimit c) :\n    S.LeftHomologyData where\n  K := S.X₂\n  H := c.pt\n  i := 𝟙 _\n  π := c.π\n  wi := by rw [id_comp, hg]\n  hi := KernelFork.IsLimit.ofId _ hg\n  wπ := CokernelCofork.condition _\n  hπ := IsColimit.ofIsoColimit hc (Cofork.ext (Iso.refl _))\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.ofIsColimitCokernelCofork_K","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nhg : Eq S.g 0\nc : CategoryTheory.Limits.CokernelCofork S.f\nhc : CategoryTheory.Limits.IsColimit c\n⊢ Eq (CategoryTheory.ShortComplex.LeftHomologyData.ofIsColimitCokernelCofork S hg c hc).K S.X₂","decl":"/-- When the second map `S.g` is zero, this is the left homology data on `S` given\nby any colimit cokernel cofork of `S.f` -/\n@[simps]\ndef ofIsColimitCokernelCofork (hg : S.g = 0) (c : CokernelCofork S.f) (hc : IsColimit c) :\n    S.LeftHomologyData where\n  K := S.X₂\n  H := c.pt\n  i := 𝟙 _\n  π := c.π\n  wi := by rw [id_comp, hg]\n  hi := KernelFork.IsLimit.ofId _ hg\n  wπ := CokernelCofork.condition _\n  hπ := IsColimit.ofIsoColimit hc (Cofork.ext (Iso.refl _))\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.ofIsColimitCokernelCofork_f'","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nhg : Eq S.g 0\nc : CategoryTheory.Limits.CokernelCofork S.f\nhc : CategoryTheory.Limits.IsColimit c\n⊢ Eq (CategoryTheory.ShortComplex.LeftHomologyData.ofIsColimitCokernelCofork S hg c hc).f' S.f","decl":"@[simp] lemma ofIsColimitCokernelCofork_f' (hg : S.g = 0) (c : CokernelCofork S.f)\n    (hc : IsColimit c) : (ofIsColimitCokernelCofork S hg c hc).f' = S.f := by\n  rw [← cancel_mono (ofIsColimitCokernelCofork S hg c hc).i, f'_i,\n    ofIsColimitCokernelCofork_i]\n  dsimp\n  rw [comp_id]\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.ofHasCokernel_H","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst✝ : CategoryTheory.Limits.HasCokernel S.f\nhg : Eq S.g 0\n⊢ Eq (CategoryTheory.ShortComplex.LeftHomologyData.ofHasCokernel S hg).H (CategoryTheory.Limits.cokernel S.f)","decl":"/-- When the second map `S.g` is zero, this is the left homology data on `S` given by\nthe chosen `cokernel S.f` -/\n@[simps!]\nnoncomputable def ofHasCokernel [HasCokernel S.f] (hg : S.g = 0) : S.LeftHomologyData :=\n  ofIsColimitCokernelCofork S hg _ (cokernelIsCokernel _)\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.ofHasCokernel_π","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst✝ : CategoryTheory.Limits.HasCokernel S.f\nhg : Eq S.g 0\n⊢ Eq (CategoryTheory.ShortComplex.LeftHomologyData.ofHasCokernel S hg).π (CategoryTheory.Limits.cokernel.π S.f)","decl":"/-- When the second map `S.g` is zero, this is the left homology data on `S` given by\nthe chosen `cokernel S.f` -/\n@[simps!]\nnoncomputable def ofHasCokernel [HasCokernel S.f] (hg : S.g = 0) : S.LeftHomologyData :=\n  ofIsColimitCokernelCofork S hg _ (cokernelIsCokernel _)\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.ofHasCokernel_K","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst✝ : CategoryTheory.Limits.HasCokernel S.f\nhg : Eq S.g 0\n⊢ Eq (CategoryTheory.ShortComplex.LeftHomologyData.ofHasCokernel S hg).K S.X₂","decl":"/-- When the second map `S.g` is zero, this is the left homology data on `S` given by\nthe chosen `cokernel S.f` -/\n@[simps!]\nnoncomputable def ofHasCokernel [HasCokernel S.f] (hg : S.g = 0) : S.LeftHomologyData :=\n  ofIsColimitCokernelCofork S hg _ (cokernelIsCokernel _)\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.ofHasCokernel_i","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst✝ : CategoryTheory.Limits.HasCokernel S.f\nhg : Eq S.g 0\n⊢ Eq (CategoryTheory.ShortComplex.LeftHomologyData.ofHasCokernel S hg).i (CategoryTheory.CategoryStruct.id S.X₂)","decl":"/-- When the second map `S.g` is zero, this is the left homology data on `S` given by\nthe chosen `cokernel S.f` -/\n@[simps!]\nnoncomputable def ofHasCokernel [HasCokernel S.f] (hg : S.g = 0) : S.LeftHomologyData :=\n  ofIsColimitCokernelCofork S hg _ (cokernelIsCokernel _)\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.ofIsLimitKernelFork_H","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nhf : Eq S.f 0\nc : CategoryTheory.Limits.KernelFork S.g\nhc : CategoryTheory.Limits.IsLimit c\n⊢ Eq (CategoryTheory.ShortComplex.LeftHomologyData.ofIsLimitKernelFork S hf c hc).H c.pt","decl":"/-- When the first map `S.f` is zero, this is the left homology data on `S` given\nby any limit kernel fork of `S.g` -/\n@[simps]\ndef ofIsLimitKernelFork (hf : S.f = 0) (c : KernelFork S.g) (hc : IsLimit c) :\n    S.LeftHomologyData where\n  K := c.pt\n  H := c.pt\n  i := c.ι\n  π := 𝟙 _\n  wi := KernelFork.condition _\n  hi := IsLimit.ofIsoLimit hc (Fork.ext (Iso.refl _))\n  wπ := Fork.IsLimit.hom_ext hc (by\n    dsimp\n    simp only [comp_id, zero_comp, Fork.IsLimit.lift_ι, Fork.ι_ofι, hf])\n  hπ := CokernelCofork.IsColimit.ofId _ (Fork.IsLimit.hom_ext hc (by\n    dsimp\n    simp only [comp_id, zero_comp, Fork.IsLimit.lift_ι, Fork.ι_ofι, hf]))\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.ofIsLimitKernelFork_K","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nhf : Eq S.f 0\nc : CategoryTheory.Limits.KernelFork S.g\nhc : CategoryTheory.Limits.IsLimit c\n⊢ Eq (CategoryTheory.ShortComplex.LeftHomologyData.ofIsLimitKernelFork S hf c hc).K c.pt","decl":"/-- When the first map `S.f` is zero, this is the left homology data on `S` given\nby any limit kernel fork of `S.g` -/\n@[simps]\ndef ofIsLimitKernelFork (hf : S.f = 0) (c : KernelFork S.g) (hc : IsLimit c) :\n    S.LeftHomologyData where\n  K := c.pt\n  H := c.pt\n  i := c.ι\n  π := 𝟙 _\n  wi := KernelFork.condition _\n  hi := IsLimit.ofIsoLimit hc (Fork.ext (Iso.refl _))\n  wπ := Fork.IsLimit.hom_ext hc (by\n    dsimp\n    simp only [comp_id, zero_comp, Fork.IsLimit.lift_ι, Fork.ι_ofι, hf])\n  hπ := CokernelCofork.IsColimit.ofId _ (Fork.IsLimit.hom_ext hc (by\n    dsimp\n    simp only [comp_id, zero_comp, Fork.IsLimit.lift_ι, Fork.ι_ofι, hf]))\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.ofIsLimitKernelFork_i","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nhf : Eq S.f 0\nc : CategoryTheory.Limits.KernelFork S.g\nhc : CategoryTheory.Limits.IsLimit c\n⊢ Eq (CategoryTheory.ShortComplex.LeftHomologyData.ofIsLimitKernelFork S hf c hc).i (CategoryTheory.Limits.Fork.ι c)","decl":"/-- When the first map `S.f` is zero, this is the left homology data on `S` given\nby any limit kernel fork of `S.g` -/\n@[simps]\ndef ofIsLimitKernelFork (hf : S.f = 0) (c : KernelFork S.g) (hc : IsLimit c) :\n    S.LeftHomologyData where\n  K := c.pt\n  H := c.pt\n  i := c.ι\n  π := 𝟙 _\n  wi := KernelFork.condition _\n  hi := IsLimit.ofIsoLimit hc (Fork.ext (Iso.refl _))\n  wπ := Fork.IsLimit.hom_ext hc (by\n    dsimp\n    simp only [comp_id, zero_comp, Fork.IsLimit.lift_ι, Fork.ι_ofι, hf])\n  hπ := CokernelCofork.IsColimit.ofId _ (Fork.IsLimit.hom_ext hc (by\n    dsimp\n    simp only [comp_id, zero_comp, Fork.IsLimit.lift_ι, Fork.ι_ofι, hf]))\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.ofIsLimitKernelFork_π","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nhf : Eq S.f 0\nc : CategoryTheory.Limits.KernelFork S.g\nhc : CategoryTheory.Limits.IsLimit c\n⊢ Eq (CategoryTheory.ShortComplex.LeftHomologyData.ofIsLimitKernelFork S hf c hc).π (CategoryTheory.CategoryStruct.id c.pt)","decl":"/-- When the first map `S.f` is zero, this is the left homology data on `S` given\nby any limit kernel fork of `S.g` -/\n@[simps]\ndef ofIsLimitKernelFork (hf : S.f = 0) (c : KernelFork S.g) (hc : IsLimit c) :\n    S.LeftHomologyData where\n  K := c.pt\n  H := c.pt\n  i := c.ι\n  π := 𝟙 _\n  wi := KernelFork.condition _\n  hi := IsLimit.ofIsoLimit hc (Fork.ext (Iso.refl _))\n  wπ := Fork.IsLimit.hom_ext hc (by\n    dsimp\n    simp only [comp_id, zero_comp, Fork.IsLimit.lift_ι, Fork.ι_ofι, hf])\n  hπ := CokernelCofork.IsColimit.ofId _ (Fork.IsLimit.hom_ext hc (by\n    dsimp\n    simp only [comp_id, zero_comp, Fork.IsLimit.lift_ι, Fork.ι_ofι, hf]))\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.ofIsLimitKernelFork_f'","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nhf : Eq S.f 0\nc : CategoryTheory.Limits.KernelFork S.g\nhc : CategoryTheory.Limits.IsLimit c\n⊢ Eq (CategoryTheory.ShortComplex.LeftHomologyData.ofIsLimitKernelFork S hf c hc).f' 0","decl":"@[simp] lemma ofIsLimitKernelFork_f' (hf : S.f = 0) (c : KernelFork S.g) (hc : IsLimit c) :\n    (ofIsLimitKernelFork S hf c hc).f' = 0 := by\n  rw [← cancel_mono (ofIsLimitKernelFork S hf c hc).i, f'_i, hf, zero_comp]\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.ofZeros_H","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nhf : Eq S.f 0\nhg : Eq S.g 0\n⊢ Eq (CategoryTheory.ShortComplex.LeftHomologyData.ofZeros S hf hg).H S.X₂","decl":"/-- When both `S.f` and `S.g` are zero, the middle object `S.X₂` gives a left homology data on S -/\n@[simps]\ndef ofZeros (hf : S.f = 0) (hg : S.g = 0) : S.LeftHomologyData where\n  K := S.X₂\n  H := S.X₂\n  i := 𝟙 _\n  π := 𝟙 _\n  wi := by rw [id_comp, hg]\n  hi := KernelFork.IsLimit.ofId _ hg\n  wπ := by\n    change S.f ≫ 𝟙 _ = 0\n    simp only [hf, zero_comp]\n  hπ := CokernelCofork.IsColimit.ofId _ hf\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.ofZeros_K","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nhf : Eq S.f 0\nhg : Eq S.g 0\n⊢ Eq (CategoryTheory.ShortComplex.LeftHomologyData.ofZeros S hf hg).K S.X₂","decl":"/-- When both `S.f` and `S.g` are zero, the middle object `S.X₂` gives a left homology data on S -/\n@[simps]\ndef ofZeros (hf : S.f = 0) (hg : S.g = 0) : S.LeftHomologyData where\n  K := S.X₂\n  H := S.X₂\n  i := 𝟙 _\n  π := 𝟙 _\n  wi := by rw [id_comp, hg]\n  hi := KernelFork.IsLimit.ofId _ hg\n  wπ := by\n    change S.f ≫ 𝟙 _ = 0\n    simp only [hf, zero_comp]\n  hπ := CokernelCofork.IsColimit.ofId _ hf\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.ofZeros_π","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nhf : Eq S.f 0\nhg : Eq S.g 0\n⊢ Eq (CategoryTheory.ShortComplex.LeftHomologyData.ofZeros S hf hg).π (CategoryTheory.CategoryStruct.id S.X₂)","decl":"/-- When both `S.f` and `S.g` are zero, the middle object `S.X₂` gives a left homology data on S -/\n@[simps]\ndef ofZeros (hf : S.f = 0) (hg : S.g = 0) : S.LeftHomologyData where\n  K := S.X₂\n  H := S.X₂\n  i := 𝟙 _\n  π := 𝟙 _\n  wi := by rw [id_comp, hg]\n  hi := KernelFork.IsLimit.ofId _ hg\n  wπ := by\n    change S.f ≫ 𝟙 _ = 0\n    simp only [hf, zero_comp]\n  hπ := CokernelCofork.IsColimit.ofId _ hf\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.ofZeros_i","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nhf : Eq S.f 0\nhg : Eq S.g 0\n⊢ Eq (CategoryTheory.ShortComplex.LeftHomologyData.ofZeros S hf hg).i (CategoryTheory.CategoryStruct.id S.X₂)","decl":"/-- When both `S.f` and `S.g` are zero, the middle object `S.X₂` gives a left homology data on S -/\n@[simps]\ndef ofZeros (hf : S.f = 0) (hg : S.g = 0) : S.LeftHomologyData where\n  K := S.X₂\n  H := S.X₂\n  i := 𝟙 _\n  π := 𝟙 _\n  wi := by rw [id_comp, hg]\n  hi := KernelFork.IsLimit.ofId _ hg\n  wπ := by\n    change S.f ≫ 𝟙 _ = 0\n    simp only [hf, zero_comp]\n  hπ := CokernelCofork.IsColimit.ofId _ hf\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.ofZeros_f'","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nhf : Eq S.f 0\nhg : Eq S.g 0\n⊢ Eq (CategoryTheory.ShortComplex.LeftHomologyData.ofZeros S hf hg).f' 0","decl":"@[simp] lemma ofZeros_f' (hf : S.f = 0) (hg : S.g = 0) :\n    (ofZeros S hf hg).f' = 0 := by\n  rw [← cancel_mono ((ofZeros S hf hg).i), zero_comp, f'_i, hf]\n\n"}
{"name":"CategoryTheory.ShortComplex.HasLeftHomology.condition","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nself : S.HasLeftHomology\n⊢ Nonempty S.LeftHomologyData","decl":"/-- A short complex `S` has left homology when there exists a `S.LeftHomologyData` -/\nclass HasLeftHomology : Prop where\n  condition : Nonempty S.LeftHomologyData\n\n"}
{"name":"CategoryTheory.ShortComplex.HasLeftHomology.mk'","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nh : S.LeftHomologyData\n⊢ S.HasLeftHomology","decl":"lemma mk' (h : S.LeftHomologyData) : HasLeftHomology S := ⟨Nonempty.intro h⟩\n\n"}
{"name":"CategoryTheory.ShortComplex.HasLeftHomology.of_hasKernel_of_hasCokernel","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_2, u_1} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst✝¹ : CategoryTheory.Limits.HasKernel S.g\ninst✝ : CategoryTheory.Limits.HasCokernel (CategoryTheory.Limits.kernel.lift S.g S.f ⋯)\n⊢ S.HasLeftHomology","decl":"instance of_hasKernel_of_hasCokernel [HasKernel S.g] [HasCokernel (kernel.lift S.g S.f S.zero)] :\n  S.HasLeftHomology := HasLeftHomology.mk' (LeftHomologyData.ofHasKernelOfHasCokernel S)\n\n"}
{"name":"CategoryTheory.ShortComplex.HasLeftHomology.of_hasCokernel","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf : Quiver.Hom X Y\nZ : C\ninst✝ : CategoryTheory.Limits.HasCokernel f\n⊢ (CategoryTheory.ShortComplex.mk f 0 ⋯).HasLeftHomology","decl":"instance of_hasCokernel {X Y : C} (f : X ⟶ Y) (Z : C) [HasCokernel f] :\n    (ShortComplex.mk f (0 : Y ⟶ Z) comp_zero).HasLeftHomology :=\n  HasLeftHomology.mk' (LeftHomologyData.ofHasCokernel _ rfl)\n\n"}
{"name":"CategoryTheory.ShortComplex.HasLeftHomology.of_hasKernel","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nY Z : C\ng : Quiver.Hom Y Z\nX : C\ninst✝ : CategoryTheory.Limits.HasKernel g\n⊢ (CategoryTheory.ShortComplex.mk 0 g ⋯).HasLeftHomology","decl":"instance of_hasKernel {Y Z : C} (g : Y ⟶ Z) (X : C) [HasKernel g] :\n    (ShortComplex.mk (0 : X ⟶ Y) g zero_comp).HasLeftHomology :=\n  HasLeftHomology.mk' (LeftHomologyData.ofHasKernel _ rfl)\n\n"}
{"name":"CategoryTheory.ShortComplex.HasLeftHomology.of_zeros","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y Z : C\n⊢ (CategoryTheory.ShortComplex.mk 0 0 ⋯).HasLeftHomology","decl":"instance of_zeros (X Y Z : C) :\n    (ShortComplex.mk (0 : X ⟶ Y) (0 : Y ⟶ Z) zero_comp).HasLeftHomology :=\n  HasLeftHomology.mk' (LeftHomologyData.ofZeros _ rfl rfl)\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyMapData.mk.sizeOf_spec","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nh₁ : S₁.LeftHomologyData\nh₂ : S₂.LeftHomologyData\ninst✝ : SizeOf C\nφK : Quiver.Hom h₁.K h₂.K\nφH : Quiver.Hom h₁.H h₂.H\ncommi : autoParam (Eq (CategoryTheory.CategoryStruct.comp φK h₂.i) (CategoryTheory.CategoryStruct.comp h₁.i φ.τ₂)) _auto✝\ncommf' : autoParam (Eq (CategoryTheory.CategoryStruct.comp h₁.f' φK) (CategoryTheory.CategoryStruct.comp φ.τ₁ h₂.f')) _auto✝\ncommπ : autoParam (Eq (CategoryTheory.CategoryStruct.comp h₁.π φH) (CategoryTheory.CategoryStruct.comp φK h₂.π)) _auto✝\n⊢ Eq (SizeOf.sizeOf { φK := φK, φH := φH, commi := commi, commf' := commf', commπ := commπ }) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf φK)) (SizeOf.sizeOf φH)) (SizeOf.sizeOf commi)) (SizeOf.sizeOf commf')) (SizeOf.sizeOf commπ))","decl":"/-- Given left homology data `h₁` and `h₂` for two short complexes `S₁` and `S₂`,\na `LeftHomologyMapData` for a morphism `φ : S₁ ⟶ S₂`\nconsists of a description of the induced morphisms on the `K` (cycles)\nand `H` (left homology) fields of `h₁` and `h₂`. -/\nstructure LeftHomologyMapData where\n  /-- the induced map on cycles -/\n  φK : h₁.K ⟶ h₂.K\n  /-- the induced map on left homology -/\n  φH : h₁.H ⟶ h₂.H\n  /-- commutation with `i` -/\n  commi : φK ≫ h₂.i = h₁.i ≫ φ.τ₂ := by aesop_cat\n  /-- commutation with `f'` -/\n  commf' : h₁.f' ≫ φK = φ.τ₁ ≫ h₂.f' := by aesop_cat\n  /-- commutation with `π` -/\n  commπ : h₁.π ≫ φH = φK ≫ h₂.π := by aesop_cat\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyMapData.mk.inj","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nh₁ : S₁.LeftHomologyData\nh₂ : S₂.LeftHomologyData\nφK✝ : Quiver.Hom h₁.K h₂.K\nφH✝ : Quiver.Hom h₁.H h₂.H\ncommi✝ : autoParam (Eq (CategoryTheory.CategoryStruct.comp φK✝ h₂.i) (CategoryTheory.CategoryStruct.comp h₁.i φ.τ₂)) _auto✝\ncommf'✝ : autoParam (Eq (CategoryTheory.CategoryStruct.comp h₁.f' φK✝) (CategoryTheory.CategoryStruct.comp φ.τ₁ h₂.f')) _auto✝\ncommπ✝ : autoParam (Eq (CategoryTheory.CategoryStruct.comp h₁.π φH✝) (CategoryTheory.CategoryStruct.comp φK✝ h₂.π)) _auto✝\nφK : Quiver.Hom h₁.K h₂.K\nφH : Quiver.Hom h₁.H h₂.H\ncommi : autoParam (Eq (CategoryTheory.CategoryStruct.comp φK h₂.i) (CategoryTheory.CategoryStruct.comp h₁.i φ.τ₂)) _auto✝\ncommf' : autoParam (Eq (CategoryTheory.CategoryStruct.comp h₁.f' φK) (CategoryTheory.CategoryStruct.comp φ.τ₁ h₂.f')) _auto✝\ncommπ : autoParam (Eq (CategoryTheory.CategoryStruct.comp h₁.π φH) (CategoryTheory.CategoryStruct.comp φK h₂.π)) _auto✝\nx✝ : Eq { φK := φK✝, φH := φH✝, commi := commi✝, commf' := commf'✝, commπ := commπ✝ } { φK := φK, φH := φH, commi := commi, commf' := commf', commπ := commπ }\n⊢ And (Eq φK✝ φK) (Eq φH✝ φH)","decl":"/-- Given left homology data `h₁` and `h₂` for two short complexes `S₁` and `S₂`,\na `LeftHomologyMapData` for a morphism `φ : S₁ ⟶ S₂`\nconsists of a description of the induced morphisms on the `K` (cycles)\nand `H` (left homology) fields of `h₁` and `h₂`. -/\nstructure LeftHomologyMapData where\n  /-- the induced map on cycles -/\n  φK : h₁.K ⟶ h₂.K\n  /-- the induced map on left homology -/\n  φH : h₁.H ⟶ h₂.H\n  /-- commutation with `i` -/\n  commi : φK ≫ h₂.i = h₁.i ≫ φ.τ₂ := by aesop_cat\n  /-- commutation with `f'` -/\n  commf' : h₁.f' ≫ φK = φ.τ₁ ≫ h₂.f' := by aesop_cat\n  /-- commutation with `π` -/\n  commπ : h₁.π ≫ φH = φK ≫ h₂.π := by aesop_cat\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyMapData.mk.injEq","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nh₁ : S₁.LeftHomologyData\nh₂ : S₂.LeftHomologyData\nφK✝ : Quiver.Hom h₁.K h₂.K\nφH✝ : Quiver.Hom h₁.H h₂.H\ncommi✝ : autoParam (Eq (CategoryTheory.CategoryStruct.comp φK✝ h₂.i) (CategoryTheory.CategoryStruct.comp h₁.i φ.τ₂)) _auto✝\ncommf'✝ : autoParam (Eq (CategoryTheory.CategoryStruct.comp h₁.f' φK✝) (CategoryTheory.CategoryStruct.comp φ.τ₁ h₂.f')) _auto✝\ncommπ✝ : autoParam (Eq (CategoryTheory.CategoryStruct.comp h₁.π φH✝) (CategoryTheory.CategoryStruct.comp φK✝ h₂.π)) _auto✝\nφK : Quiver.Hom h₁.K h₂.K\nφH : Quiver.Hom h₁.H h₂.H\ncommi : autoParam (Eq (CategoryTheory.CategoryStruct.comp φK h₂.i) (CategoryTheory.CategoryStruct.comp h₁.i φ.τ₂)) _auto✝\ncommf' : autoParam (Eq (CategoryTheory.CategoryStruct.comp h₁.f' φK) (CategoryTheory.CategoryStruct.comp φ.τ₁ h₂.f')) _auto✝\ncommπ : autoParam (Eq (CategoryTheory.CategoryStruct.comp h₁.π φH) (CategoryTheory.CategoryStruct.comp φK h₂.π)) _auto✝\n⊢ Eq (Eq { φK := φK✝, φH := φH✝, commi := commi✝, commf' := commf'✝, commπ := commπ✝ } { φK := φK, φH := φH, commi := commi, commf' := commf', commπ := commπ }) (And (Eq φK✝ φK) (Eq φH✝ φH))","decl":"/-- Given left homology data `h₁` and `h₂` for two short complexes `S₁` and `S₂`,\na `LeftHomologyMapData` for a morphism `φ : S₁ ⟶ S₂`\nconsists of a description of the induced morphisms on the `K` (cycles)\nand `H` (left homology) fields of `h₁` and `h₂`. -/\nstructure LeftHomologyMapData where\n  /-- the induced map on cycles -/\n  φK : h₁.K ⟶ h₂.K\n  /-- the induced map on left homology -/\n  φH : h₁.H ⟶ h₂.H\n  /-- commutation with `i` -/\n  commi : φK ≫ h₂.i = h₁.i ≫ φ.τ₂ := by aesop_cat\n  /-- commutation with `f'` -/\n  commf' : h₁.f' ≫ φK = φ.τ₁ ≫ h₂.f' := by aesop_cat\n  /-- commutation with `π` -/\n  commπ : h₁.π ≫ φH = φK ≫ h₂.π := by aesop_cat\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyMapData.commf'","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nh₁ : S₁.LeftHomologyData\nh₂ : S₂.LeftHomologyData\nself : CategoryTheory.ShortComplex.LeftHomologyMapData φ h₁ h₂\n⊢ Eq (CategoryTheory.CategoryStruct.comp h₁.f' self.φK) (CategoryTheory.CategoryStruct.comp φ.τ₁ h₂.f')","decl":"/-- Given left homology data `h₁` and `h₂` for two short complexes `S₁` and `S₂`,\na `LeftHomologyMapData` for a morphism `φ : S₁ ⟶ S₂`\nconsists of a description of the induced morphisms on the `K` (cycles)\nand `H` (left homology) fields of `h₁` and `h₂`. -/\nstructure LeftHomologyMapData where\n  /-- the induced map on cycles -/\n  φK : h₁.K ⟶ h₂.K\n  /-- the induced map on left homology -/\n  φH : h₁.H ⟶ h₂.H\n  /-- commutation with `i` -/\n  commi : φK ≫ h₂.i = h₁.i ≫ φ.τ₂ := by aesop_cat\n  /-- commutation with `f'` -/\n  commf' : h₁.f' ≫ φK = φ.τ₁ ≫ h₂.f' := by aesop_cat\n  /-- commutation with `π` -/\n  commπ : h₁.π ≫ φH = φK ≫ h₂.π := by aesop_cat\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyMapData.commπ","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nh₁ : S₁.LeftHomologyData\nh₂ : S₂.LeftHomologyData\nself : CategoryTheory.ShortComplex.LeftHomologyMapData φ h₁ h₂\n⊢ Eq (CategoryTheory.CategoryStruct.comp h₁.π self.φH) (CategoryTheory.CategoryStruct.comp self.φK h₂.π)","decl":"/-- Given left homology data `h₁` and `h₂` for two short complexes `S₁` and `S₂`,\na `LeftHomologyMapData` for a morphism `φ : S₁ ⟶ S₂`\nconsists of a description of the induced morphisms on the `K` (cycles)\nand `H` (left homology) fields of `h₁` and `h₂`. -/\nstructure LeftHomologyMapData where\n  /-- the induced map on cycles -/\n  φK : h₁.K ⟶ h₂.K\n  /-- the induced map on left homology -/\n  φH : h₁.H ⟶ h₂.H\n  /-- commutation with `i` -/\n  commi : φK ≫ h₂.i = h₁.i ≫ φ.τ₂ := by aesop_cat\n  /-- commutation with `f'` -/\n  commf' : h₁.f' ≫ φK = φ.τ₁ ≫ h₂.f' := by aesop_cat\n  /-- commutation with `π` -/\n  commπ : h₁.π ≫ φH = φK ≫ h₂.π := by aesop_cat\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyMapData.commi","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nh₁ : S₁.LeftHomologyData\nh₂ : S₂.LeftHomologyData\nself : CategoryTheory.ShortComplex.LeftHomologyMapData φ h₁ h₂\n⊢ Eq (CategoryTheory.CategoryStruct.comp self.φK h₂.i) (CategoryTheory.CategoryStruct.comp h₁.i φ.τ₂)","decl":"/-- Given left homology data `h₁` and `h₂` for two short complexes `S₁` and `S₂`,\na `LeftHomologyMapData` for a morphism `φ : S₁ ⟶ S₂`\nconsists of a description of the induced morphisms on the `K` (cycles)\nand `H` (left homology) fields of `h₁` and `h₂`. -/\nstructure LeftHomologyMapData where\n  /-- the induced map on cycles -/\n  φK : h₁.K ⟶ h₂.K\n  /-- the induced map on left homology -/\n  φH : h₁.H ⟶ h₂.H\n  /-- commutation with `i` -/\n  commi : φK ≫ h₂.i = h₁.i ≫ φ.τ₂ := by aesop_cat\n  /-- commutation with `f'` -/\n  commf' : h₁.f' ≫ φK = φ.τ₁ ≫ h₂.f' := by aesop_cat\n  /-- commutation with `π` -/\n  commπ : h₁.π ≫ φH = φK ≫ h₂.π := by aesop_cat\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyMapData.commπ_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nh₁ : S₁.LeftHomologyData\nh₂ : S₂.LeftHomologyData\nself : CategoryTheory.ShortComplex.LeftHomologyMapData φ h₁ h₂\nZ : C\nh : Quiver.Hom h₂.H Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp h₁.π (CategoryTheory.CategoryStruct.comp self.φH h)) (CategoryTheory.CategoryStruct.comp self.φK (CategoryTheory.CategoryStruct.comp h₂.π h))","decl":"attribute [reassoc (attr := simp)] commi commf' commπ\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyMapData.commi_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nh₁ : S₁.LeftHomologyData\nh₂ : S₂.LeftHomologyData\nself : CategoryTheory.ShortComplex.LeftHomologyMapData φ h₁ h₂\nZ : C\nh : Quiver.Hom S₂.X₂ Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp self.φK (CategoryTheory.CategoryStruct.comp h₂.i h)) (CategoryTheory.CategoryStruct.comp h₁.i (CategoryTheory.CategoryStruct.comp φ.τ₂ h))","decl":"attribute [reassoc (attr := simp)] commi commf' commπ\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyMapData.commf'_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nh₁ : S₁.LeftHomologyData\nh₂ : S₂.LeftHomologyData\nself : CategoryTheory.ShortComplex.LeftHomologyMapData φ h₁ h₂\nZ : C\nh : Quiver.Hom h₂.K Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp h₁.f' (CategoryTheory.CategoryStruct.comp self.φK h)) (CategoryTheory.CategoryStruct.comp φ.τ₁ (CategoryTheory.CategoryStruct.comp h₂.f' h))","decl":"attribute [reassoc (attr := simp)] commi commf' commπ\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyMapData.zero_φK","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nh₁ : S₁.LeftHomologyData\nh₂ : S₂.LeftHomologyData\n⊢ Eq (CategoryTheory.ShortComplex.LeftHomologyMapData.zero h₁ h₂).φK 0","decl":"/-- The left homology map data associated to the zero morphism between two short complexes. -/\n@[simps]\ndef zero (h₁ : S₁.LeftHomologyData) (h₂ : S₂.LeftHomologyData) :\n    LeftHomologyMapData 0 h₁ h₂ where\n  φK := 0\n  φH := 0\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyMapData.zero_φH","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nh₁ : S₁.LeftHomologyData\nh₂ : S₂.LeftHomologyData\n⊢ Eq (CategoryTheory.ShortComplex.LeftHomologyMapData.zero h₁ h₂).φH 0","decl":"/-- The left homology map data associated to the zero morphism between two short complexes. -/\n@[simps]\ndef zero (h₁ : S₁.LeftHomologyData) (h₂ : S₂.LeftHomologyData) :\n    LeftHomologyMapData 0 h₁ h₂ where\n  φK := 0\n  φH := 0\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyMapData.id_φK","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nh : S.LeftHomologyData\n⊢ Eq (CategoryTheory.ShortComplex.LeftHomologyMapData.id h).φK (CategoryTheory.CategoryStruct.id h.K)","decl":"/-- The left homology map data associated to the identity morphism of a short complex. -/\n@[simps]\ndef id (h : S.LeftHomologyData) : LeftHomologyMapData (𝟙 S) h h where\n  φK := 𝟙 _\n  φH := 𝟙 _\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyMapData.id_φH","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nh : S.LeftHomologyData\n⊢ Eq (CategoryTheory.ShortComplex.LeftHomologyMapData.id h).φH (CategoryTheory.CategoryStruct.id h.H)","decl":"/-- The left homology map data associated to the identity morphism of a short complex. -/\n@[simps]\ndef id (h : S.LeftHomologyData) : LeftHomologyMapData (𝟙 S) h h where\n  φK := 𝟙 _\n  φH := 𝟙 _\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyMapData.comp_φK","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ S₃ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nφ' : Quiver.Hom S₂ S₃\nh₁ : S₁.LeftHomologyData\nh₂ : S₂.LeftHomologyData\nh₃ : S₃.LeftHomologyData\nψ : CategoryTheory.ShortComplex.LeftHomologyMapData φ h₁ h₂\nψ' : CategoryTheory.ShortComplex.LeftHomologyMapData φ' h₂ h₃\n⊢ Eq (ψ.comp ψ').φK (CategoryTheory.CategoryStruct.comp ψ.φK ψ'.φK)","decl":"/-- The composition of left homology map data. -/\n@[simps]\ndef comp {φ : S₁ ⟶ S₂} {φ' : S₂ ⟶ S₃}\n    {h₁ : S₁.LeftHomologyData} {h₂ : S₂.LeftHomologyData} {h₃ : S₃.LeftHomologyData}\n    (ψ : LeftHomologyMapData φ h₁ h₂) (ψ' : LeftHomologyMapData φ' h₂ h₃) :\n    LeftHomologyMapData (φ ≫ φ') h₁ h₃ where\n  φK := ψ.φK ≫ ψ'.φK\n  φH := ψ.φH ≫ ψ'.φH\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyMapData.comp_φH","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ S₃ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nφ' : Quiver.Hom S₂ S₃\nh₁ : S₁.LeftHomologyData\nh₂ : S₂.LeftHomologyData\nh₃ : S₃.LeftHomologyData\nψ : CategoryTheory.ShortComplex.LeftHomologyMapData φ h₁ h₂\nψ' : CategoryTheory.ShortComplex.LeftHomologyMapData φ' h₂ h₃\n⊢ Eq (ψ.comp ψ').φH (CategoryTheory.CategoryStruct.comp ψ.φH ψ'.φH)","decl":"/-- The composition of left homology map data. -/\n@[simps]\ndef comp {φ : S₁ ⟶ S₂} {φ' : S₂ ⟶ S₃}\n    {h₁ : S₁.LeftHomologyData} {h₂ : S₂.LeftHomologyData} {h₃ : S₃.LeftHomologyData}\n    (ψ : LeftHomologyMapData φ h₁ h₂) (ψ' : LeftHomologyMapData φ' h₂ h₃) :\n    LeftHomologyMapData (φ ≫ φ') h₁ h₃ where\n  φK := ψ.φK ≫ ψ'.φK\n  φH := ψ.φH ≫ ψ'.φH\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyMapData.instSubsingleton","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nh₁ : S₁.LeftHomologyData\nh₂ : S₂.LeftHomologyData\n⊢ Subsingleton (CategoryTheory.ShortComplex.LeftHomologyMapData φ h₁ h₂)","decl":"instance : Subsingleton (LeftHomologyMapData φ h₁ h₂) :=\n  ⟨fun ψ₁ ψ₂ => by\n    have hK : ψ₁.φK = ψ₂.φK := by rw [← cancel_mono h₂.i, commi, commi]\n    have hH : ψ₁.φH = ψ₂.φH := by rw [← cancel_epi h₁.π, commπ, commπ, hK]\n    cases ψ₁\n    cases ψ₂\n    congr⟩\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyMapData.congr_φH","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nh₁ : S₁.LeftHomologyData\nh₂ : S₂.LeftHomologyData\nγ₁ γ₂ : CategoryTheory.ShortComplex.LeftHomologyMapData φ h₁ h₂\neq : Eq γ₁ γ₂\n⊢ Eq γ₁.φH γ₂.φH","decl":"lemma congr_φH {γ₁ γ₂ : LeftHomologyMapData φ h₁ h₂} (eq : γ₁ = γ₂) : γ₁.φH = γ₂.φH := by rw [eq]\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyMapData.congr_φK","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nh₁ : S₁.LeftHomologyData\nh₂ : S₂.LeftHomologyData\nγ₁ γ₂ : CategoryTheory.ShortComplex.LeftHomologyMapData φ h₁ h₂\neq : Eq γ₁ γ₂\n⊢ Eq γ₁.φK γ₂.φK","decl":"lemma congr_φK {γ₁ γ₂ : LeftHomologyMapData φ h₁ h₂} (eq : γ₁ = γ₂) : γ₁.φK = γ₂.φK := by rw [eq]\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyMapData.ofZeros_φH","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nhf₁ : Eq S₁.f 0\nhg₁ : Eq S₁.g 0\nhf₂ : Eq S₂.f 0\nhg₂ : Eq S₂.g 0\n⊢ Eq (CategoryTheory.ShortComplex.LeftHomologyMapData.ofZeros φ hf₁ hg₁ hf₂ hg₂).φH φ.τ₂","decl":"/-- When `S₁.f`, `S₁.g`, `S₂.f` and `S₂.g` are all zero, the action on left homology of a\nmorphism `φ : S₁ ⟶ S₂` is given by the action `φ.τ₂` on the middle objects. -/\n@[simps]\ndef ofZeros (φ : S₁ ⟶ S₂) (hf₁ : S₁.f = 0) (hg₁ : S₁.g = 0) (hf₂ : S₂.f = 0) (hg₂ : S₂.g = 0) :\n    LeftHomologyMapData φ (LeftHomologyData.ofZeros S₁ hf₁ hg₁)\n      (LeftHomologyData.ofZeros S₂ hf₂ hg₂) where\n  φK := φ.τ₂\n  φH := φ.τ₂\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyMapData.ofZeros_φK","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nhf₁ : Eq S₁.f 0\nhg₁ : Eq S₁.g 0\nhf₂ : Eq S₂.f 0\nhg₂ : Eq S₂.g 0\n⊢ Eq (CategoryTheory.ShortComplex.LeftHomologyMapData.ofZeros φ hf₁ hg₁ hf₂ hg₂).φK φ.τ₂","decl":"/-- When `S₁.f`, `S₁.g`, `S₂.f` and `S₂.g` are all zero, the action on left homology of a\nmorphism `φ : S₁ ⟶ S₂` is given by the action `φ.τ₂` on the middle objects. -/\n@[simps]\ndef ofZeros (φ : S₁ ⟶ S₂) (hf₁ : S₁.f = 0) (hg₁ : S₁.g = 0) (hf₂ : S₂.f = 0) (hg₂ : S₂.g = 0) :\n    LeftHomologyMapData φ (LeftHomologyData.ofZeros S₁ hf₁ hg₁)\n      (LeftHomologyData.ofZeros S₂ hf₂ hg₂) where\n  φK := φ.τ₂\n  φH := φ.τ₂\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyMapData.ofIsColimitCokernelCofork_φK","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nhg₁ : Eq S₁.g 0\nc₁ : CategoryTheory.Limits.CokernelCofork S₁.f\nhc₁ : CategoryTheory.Limits.IsColimit c₁\nhg₂ : Eq S₂.g 0\nc₂ : CategoryTheory.Limits.CokernelCofork S₂.f\nhc₂ : CategoryTheory.Limits.IsColimit c₂\nf : Quiver.Hom c₁.pt c₂.pt\ncomm : Eq (CategoryTheory.CategoryStruct.comp φ.τ₂ (CategoryTheory.Limits.Cofork.π c₂)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Cofork.π c₁) f)\n⊢ Eq (CategoryTheory.ShortComplex.LeftHomologyMapData.ofIsColimitCokernelCofork φ hg₁ c₁ hc₁ hg₂ c₂ hc₂ f comm).φK φ.τ₂","decl":"/-- When `S₁.g` and `S₂.g` are zero and we have chosen colimit cokernel coforks `c₁` and `c₂`\nfor `S₁.f` and `S₂.f` respectively, the action on left homology of a morphism `φ : S₁ ⟶ S₂` of\nshort complexes is given by the unique morphism `f : c₁.pt ⟶ c₂.pt` such that\n`φ.τ₂ ≫ c₂.π = c₁.π ≫ f`. -/\n@[simps]\ndef ofIsColimitCokernelCofork (φ : S₁ ⟶ S₂)\n    (hg₁ : S₁.g = 0) (c₁ : CokernelCofork S₁.f) (hc₁ : IsColimit c₁)\n    (hg₂ : S₂.g = 0) (c₂ : CokernelCofork S₂.f) (hc₂ : IsColimit c₂) (f : c₁.pt ⟶ c₂.pt)\n    (comm : φ.τ₂ ≫ c₂.π = c₁.π ≫ f) :\n    LeftHomologyMapData φ (LeftHomologyData.ofIsColimitCokernelCofork S₁ hg₁ c₁ hc₁)\n      (LeftHomologyData.ofIsColimitCokernelCofork S₂ hg₂ c₂ hc₂) where\n  φK := φ.τ₂\n  φH := f\n  commπ := comm.symm\n  commf' := by simp only [LeftHomologyData.ofIsColimitCokernelCofork_f', φ.comm₁₂]\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyMapData.ofIsColimitCokernelCofork_φH","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nhg₁ : Eq S₁.g 0\nc₁ : CategoryTheory.Limits.CokernelCofork S₁.f\nhc₁ : CategoryTheory.Limits.IsColimit c₁\nhg₂ : Eq S₂.g 0\nc₂ : CategoryTheory.Limits.CokernelCofork S₂.f\nhc₂ : CategoryTheory.Limits.IsColimit c₂\nf : Quiver.Hom c₁.pt c₂.pt\ncomm : Eq (CategoryTheory.CategoryStruct.comp φ.τ₂ (CategoryTheory.Limits.Cofork.π c₂)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Cofork.π c₁) f)\n⊢ Eq (CategoryTheory.ShortComplex.LeftHomologyMapData.ofIsColimitCokernelCofork φ hg₁ c₁ hc₁ hg₂ c₂ hc₂ f comm).φH f","decl":"/-- When `S₁.g` and `S₂.g` are zero and we have chosen colimit cokernel coforks `c₁` and `c₂`\nfor `S₁.f` and `S₂.f` respectively, the action on left homology of a morphism `φ : S₁ ⟶ S₂` of\nshort complexes is given by the unique morphism `f : c₁.pt ⟶ c₂.pt` such that\n`φ.τ₂ ≫ c₂.π = c₁.π ≫ f`. -/\n@[simps]\ndef ofIsColimitCokernelCofork (φ : S₁ ⟶ S₂)\n    (hg₁ : S₁.g = 0) (c₁ : CokernelCofork S₁.f) (hc₁ : IsColimit c₁)\n    (hg₂ : S₂.g = 0) (c₂ : CokernelCofork S₂.f) (hc₂ : IsColimit c₂) (f : c₁.pt ⟶ c₂.pt)\n    (comm : φ.τ₂ ≫ c₂.π = c₁.π ≫ f) :\n    LeftHomologyMapData φ (LeftHomologyData.ofIsColimitCokernelCofork S₁ hg₁ c₁ hc₁)\n      (LeftHomologyData.ofIsColimitCokernelCofork S₂ hg₂ c₂ hc₂) where\n  φK := φ.τ₂\n  φH := f\n  commπ := comm.symm\n  commf' := by simp only [LeftHomologyData.ofIsColimitCokernelCofork_f', φ.comm₁₂]\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyMapData.ofIsLimitKernelFork_φK","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nhf₁ : Eq S₁.f 0\nc₁ : CategoryTheory.Limits.KernelFork S₁.g\nhc₁ : CategoryTheory.Limits.IsLimit c₁\nhf₂ : Eq S₂.f 0\nc₂ : CategoryTheory.Limits.KernelFork S₂.g\nhc₂ : CategoryTheory.Limits.IsLimit c₂\nf : Quiver.Hom c₁.pt c₂.pt\ncomm : Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Fork.ι c₁) φ.τ₂) (CategoryTheory.CategoryStruct.comp f (CategoryTheory.Limits.Fork.ι c₂))\n⊢ Eq (CategoryTheory.ShortComplex.LeftHomologyMapData.ofIsLimitKernelFork φ hf₁ c₁ hc₁ hf₂ c₂ hc₂ f comm).φK f","decl":"/-- When `S₁.f` and `S₂.f` are zero and we have chosen limit kernel forks `c₁` and `c₂`\nfor `S₁.g` and `S₂.g` respectively, the action on left homology of a morphism `φ : S₁ ⟶ S₂` of\nshort complexes is given by the unique morphism `f : c₁.pt ⟶ c₂.pt` such that\n`c₁.ι ≫ φ.τ₂ = f ≫ c₂.ι`. -/\n@[simps]\ndef ofIsLimitKernelFork (φ : S₁ ⟶ S₂)\n    (hf₁ : S₁.f = 0) (c₁ : KernelFork S₁.g) (hc₁ : IsLimit c₁)\n    (hf₂ : S₂.f = 0) (c₂ : KernelFork S₂.g) (hc₂ : IsLimit c₂) (f : c₁.pt ⟶ c₂.pt)\n    (comm : c₁.ι ≫ φ.τ₂ = f ≫ c₂.ι) :\n    LeftHomologyMapData φ (LeftHomologyData.ofIsLimitKernelFork S₁ hf₁ c₁ hc₁)\n      (LeftHomologyData.ofIsLimitKernelFork S₂ hf₂ c₂ hc₂) where\n  φK := f\n  φH := f\n  commi := comm.symm\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyMapData.ofIsLimitKernelFork_φH","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nhf₁ : Eq S₁.f 0\nc₁ : CategoryTheory.Limits.KernelFork S₁.g\nhc₁ : CategoryTheory.Limits.IsLimit c₁\nhf₂ : Eq S₂.f 0\nc₂ : CategoryTheory.Limits.KernelFork S₂.g\nhc₂ : CategoryTheory.Limits.IsLimit c₂\nf : Quiver.Hom c₁.pt c₂.pt\ncomm : Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Fork.ι c₁) φ.τ₂) (CategoryTheory.CategoryStruct.comp f (CategoryTheory.Limits.Fork.ι c₂))\n⊢ Eq (CategoryTheory.ShortComplex.LeftHomologyMapData.ofIsLimitKernelFork φ hf₁ c₁ hc₁ hf₂ c₂ hc₂ f comm).φH f","decl":"/-- When `S₁.f` and `S₂.f` are zero and we have chosen limit kernel forks `c₁` and `c₂`\nfor `S₁.g` and `S₂.g` respectively, the action on left homology of a morphism `φ : S₁ ⟶ S₂` of\nshort complexes is given by the unique morphism `f : c₁.pt ⟶ c₂.pt` such that\n`c₁.ι ≫ φ.τ₂ = f ≫ c₂.ι`. -/\n@[simps]\ndef ofIsLimitKernelFork (φ : S₁ ⟶ S₂)\n    (hf₁ : S₁.f = 0) (c₁ : KernelFork S₁.g) (hc₁ : IsLimit c₁)\n    (hf₂ : S₂.f = 0) (c₂ : KernelFork S₂.g) (hc₂ : IsLimit c₂) (f : c₁.pt ⟶ c₂.pt)\n    (comm : c₁.ι ≫ φ.τ₂ = f ≫ c₂.ι) :\n    LeftHomologyMapData φ (LeftHomologyData.ofIsLimitKernelFork S₁ hf₁ c₁ hc₁)\n      (LeftHomologyData.ofIsLimitKernelFork S₂ hf₂ c₂ hc₂) where\n  φK := f\n  φH := f\n  commi := comm.symm\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyMapData.compatibilityOfZerosOfIsColimitCokernelCofork_φH","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nhf : Eq S.f 0\nhg : Eq S.g 0\nc : CategoryTheory.Limits.CokernelCofork S.f\nhc : CategoryTheory.Limits.IsColimit c\n⊢ Eq (CategoryTheory.ShortComplex.LeftHomologyMapData.compatibilityOfZerosOfIsColimitCokernelCofork S hf hg c hc).φH (CategoryTheory.Limits.Cofork.π c)","decl":"/-- When both maps `S.f` and `S.g` of a short complex `S` are zero, this is the left homology map\ndata (for the identity of `S`) which relates the left homology data `ofZeros` and\n`ofIsColimitCokernelCofork`. -/\n@[simps]\ndef compatibilityOfZerosOfIsColimitCokernelCofork (hf : S.f = 0) (hg : S.g = 0)\n    (c : CokernelCofork S.f) (hc : IsColimit c) :\n    LeftHomologyMapData (𝟙 S) (LeftHomologyData.ofZeros S hf hg)\n      (LeftHomologyData.ofIsColimitCokernelCofork S hg c hc) where\n  φK := 𝟙 _\n  φH := c.π\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyMapData.compatibilityOfZerosOfIsColimitCokernelCofork_φK","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nhf : Eq S.f 0\nhg : Eq S.g 0\nc : CategoryTheory.Limits.CokernelCofork S.f\nhc : CategoryTheory.Limits.IsColimit c\n⊢ Eq (CategoryTheory.ShortComplex.LeftHomologyMapData.compatibilityOfZerosOfIsColimitCokernelCofork S hf hg c hc).φK (CategoryTheory.CategoryStruct.id (CategoryTheory.ShortComplex.LeftHomologyData.ofZeros S hf hg).K)","decl":"/-- When both maps `S.f` and `S.g` of a short complex `S` are zero, this is the left homology map\ndata (for the identity of `S`) which relates the left homology data `ofZeros` and\n`ofIsColimitCokernelCofork`. -/\n@[simps]\ndef compatibilityOfZerosOfIsColimitCokernelCofork (hf : S.f = 0) (hg : S.g = 0)\n    (c : CokernelCofork S.f) (hc : IsColimit c) :\n    LeftHomologyMapData (𝟙 S) (LeftHomologyData.ofZeros S hf hg)\n      (LeftHomologyData.ofIsColimitCokernelCofork S hg c hc) where\n  φK := 𝟙 _\n  φH := c.π\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyMapData.compatibilityOfZerosOfIsLimitKernelFork_φH","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nhf : Eq S.f 0\nhg : Eq S.g 0\nc : CategoryTheory.Limits.KernelFork S.g\nhc : CategoryTheory.Limits.IsLimit c\n⊢ Eq (CategoryTheory.ShortComplex.LeftHomologyMapData.compatibilityOfZerosOfIsLimitKernelFork S hf hg c hc).φH (CategoryTheory.Limits.Fork.ι c)","decl":"/-- When both maps `S.f` and `S.g` of a short complex `S` are zero, this is the left homology map\ndata (for the identity of `S`) which relates the left homology data\n`LeftHomologyData.ofIsLimitKernelFork` and `ofZeros` . -/\n@[simps]\ndef compatibilityOfZerosOfIsLimitKernelFork (hf : S.f = 0) (hg : S.g = 0)\n    (c : KernelFork S.g) (hc : IsLimit c) :\n    LeftHomologyMapData (𝟙 S) (LeftHomologyData.ofIsLimitKernelFork S hf c hc)\n      (LeftHomologyData.ofZeros S hf hg) where\n  φK := c.ι\n  φH := c.ι\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyMapData.compatibilityOfZerosOfIsLimitKernelFork_φK","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nhf : Eq S.f 0\nhg : Eq S.g 0\nc : CategoryTheory.Limits.KernelFork S.g\nhc : CategoryTheory.Limits.IsLimit c\n⊢ Eq (CategoryTheory.ShortComplex.LeftHomologyMapData.compatibilityOfZerosOfIsLimitKernelFork S hf hg c hc).φK (CategoryTheory.Limits.Fork.ι c)","decl":"/-- When both maps `S.f` and `S.g` of a short complex `S` are zero, this is the left homology map\ndata (for the identity of `S`) which relates the left homology data\n`LeftHomologyData.ofIsLimitKernelFork` and `ofZeros` . -/\n@[simps]\ndef compatibilityOfZerosOfIsLimitKernelFork (hf : S.f = 0) (hg : S.g = 0)\n    (c : KernelFork S.g) (hc : IsLimit c) :\n    LeftHomologyMapData (𝟙 S) (LeftHomologyData.ofIsLimitKernelFork S hf c hc)\n      (LeftHomologyData.ofZeros S hf hg) where\n  φK := c.ι\n  φH := c.ι\n\n"}
{"name":"CategoryTheory.ShortComplex.iCycles_g","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst✝ : S.HasLeftHomology\n⊢ Eq (CategoryTheory.CategoryStruct.comp S.iCycles S.g) 0","decl":"@[reassoc (attr := simp)]\nlemma iCycles_g : S.iCycles ≫ S.g = 0 := S.leftHomologyData.wi\n\n"}
{"name":"CategoryTheory.ShortComplex.iCycles_g_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst✝ : S.HasLeftHomology\nZ : C\nh : Quiver.Hom S.X₃ Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp S.iCycles (CategoryTheory.CategoryStruct.comp S.g h)) (CategoryTheory.CategoryStruct.comp 0 h)","decl":"@[reassoc (attr := simp)]\nlemma iCycles_g : S.iCycles ≫ S.g = 0 := S.leftHomologyData.wi\n\n"}
{"name":"CategoryTheory.ShortComplex.toCycles_i","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst✝ : S.HasLeftHomology\n⊢ Eq (CategoryTheory.CategoryStruct.comp S.toCycles S.iCycles) S.f","decl":"@[reassoc (attr := simp)]\nlemma toCycles_i : S.toCycles ≫ S.iCycles = S.f := S.leftHomologyData.f'_i\n\n"}
{"name":"CategoryTheory.ShortComplex.toCycles_i_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst✝ : S.HasLeftHomology\nZ : C\nh : Quiver.Hom S.X₂ Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp S.toCycles (CategoryTheory.CategoryStruct.comp S.iCycles h)) (CategoryTheory.CategoryStruct.comp S.f h)","decl":"@[reassoc (attr := simp)]\nlemma toCycles_i : S.toCycles ≫ S.iCycles = S.f := S.leftHomologyData.f'_i\n\n"}
{"name":"CategoryTheory.ShortComplex.instMonoICycles","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst✝ : S.HasLeftHomology\n⊢ CategoryTheory.Mono S.iCycles","decl":"instance : Mono S.iCycles := by\n  dsimp only [iCycles]\n  infer_instance\n\n"}
{"name":"CategoryTheory.ShortComplex.instEpiLeftHomologyπ","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst✝ : S.HasLeftHomology\n⊢ CategoryTheory.Epi S.leftHomologyπ","decl":"instance : Epi S.leftHomologyπ := by\n  dsimp only [leftHomologyπ]\n  infer_instance\n\n"}
{"name":"CategoryTheory.ShortComplex.leftHomology_ext_iff","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst✝ : S.HasLeftHomology\nA : C\nf₁ f₂ : Quiver.Hom S.leftHomology A\n⊢ Iff (Eq f₁ f₂) (Eq (CategoryTheory.CategoryStruct.comp S.leftHomologyπ f₁) (CategoryTheory.CategoryStruct.comp S.leftHomologyπ f₂))","decl":"lemma leftHomology_ext_iff {A : C} (f₁ f₂ : S.leftHomology ⟶ A) :\n    f₁ = f₂ ↔ S.leftHomologyπ ≫ f₁ = S.leftHomologyπ ≫ f₂ := by\n  rw [cancel_epi]\n\n"}
{"name":"CategoryTheory.ShortComplex.leftHomology_ext","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst✝ : S.HasLeftHomology\nA : C\nf₁ f₂ : Quiver.Hom S.leftHomology A\nh : Eq (CategoryTheory.CategoryStruct.comp S.leftHomologyπ f₁) (CategoryTheory.CategoryStruct.comp S.leftHomologyπ f₂)\n⊢ Eq f₁ f₂","decl":"@[ext]\nlemma leftHomology_ext {A : C} (f₁ f₂ : S.leftHomology ⟶ A)\n    (h : S.leftHomologyπ ≫ f₁ = S.leftHomologyπ ≫ f₂) : f₁ = f₂ := by\n  simpa only [leftHomology_ext_iff] using h\n\n"}
{"name":"CategoryTheory.ShortComplex.cycles_ext_iff","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst✝ : S.HasLeftHomology\nA : C\nf₁ f₂ : Quiver.Hom A S.cycles\n⊢ Iff (Eq f₁ f₂) (Eq (CategoryTheory.CategoryStruct.comp f₁ S.iCycles) (CategoryTheory.CategoryStruct.comp f₂ S.iCycles))","decl":"lemma cycles_ext_iff {A : C} (f₁ f₂ : A ⟶ S.cycles) :\n    f₁ = f₂ ↔ f₁ ≫ S.iCycles = f₂ ≫ S.iCycles := by\n  rw [cancel_mono]\n\n"}
{"name":"CategoryTheory.ShortComplex.cycles_ext","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst✝ : S.HasLeftHomology\nA : C\nf₁ f₂ : Quiver.Hom A S.cycles\nh : Eq (CategoryTheory.CategoryStruct.comp f₁ S.iCycles) (CategoryTheory.CategoryStruct.comp f₂ S.iCycles)\n⊢ Eq f₁ f₂","decl":"@[ext]\nlemma cycles_ext {A : C} (f₁ f₂ : A ⟶ S.cycles) (h : f₁ ≫ S.iCycles = f₂ ≫ S.iCycles) :\n    f₁ = f₂ := by\n  simpa only [cycles_ext_iff] using h\n\n"}
{"name":"CategoryTheory.ShortComplex.isIso_iCycles","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst✝ : S.HasLeftHomology\nhg : Eq S.g 0\n⊢ CategoryTheory.IsIso S.iCycles","decl":"lemma isIso_iCycles (hg : S.g = 0) : IsIso S.iCycles :=\n  LeftHomologyData.isIso_i _ hg\n\n"}
{"name":"CategoryTheory.ShortComplex.cyclesIsoX₂_hom","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst✝ : S.HasLeftHomology\nhg : Eq S.g 0\n⊢ Eq (S.cyclesIsoX₂ hg).hom S.iCycles","decl":"/-- When `S.g = 0`, this is the canonical isomorphism `S.cycles ≅ S.X₂` induced by `S.iCycles`. -/\n@[simps! hom]\nnoncomputable def cyclesIsoX₂ (hg : S.g = 0) : S.cycles ≅ S.X₂ := by\n  have := S.isIso_iCycles hg\n  exact asIso S.iCycles\n\n"}
{"name":"CategoryTheory.ShortComplex.cyclesIsoX₂_hom_inv_id","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst✝ : S.HasLeftHomology\nhg : Eq S.g 0\n⊢ Eq (CategoryTheory.CategoryStruct.comp S.iCycles (S.cyclesIsoX₂ hg).inv) (CategoryTheory.CategoryStruct.id S.cycles)","decl":"@[reassoc (attr := simp)]\nlemma cyclesIsoX₂_hom_inv_id (hg : S.g = 0) :\n    S.iCycles ≫ (S.cyclesIsoX₂ hg).inv = 𝟙 _ := (S.cyclesIsoX₂ hg).hom_inv_id\n\n"}
{"name":"CategoryTheory.ShortComplex.cyclesIsoX₂_hom_inv_id_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst✝ : S.HasLeftHomology\nhg : Eq S.g 0\nZ : C\nh : Quiver.Hom S.cycles Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp S.iCycles (CategoryTheory.CategoryStruct.comp (S.cyclesIsoX₂ hg).inv h)) h","decl":"@[reassoc (attr := simp)]\nlemma cyclesIsoX₂_hom_inv_id (hg : S.g = 0) :\n    S.iCycles ≫ (S.cyclesIsoX₂ hg).inv = 𝟙 _ := (S.cyclesIsoX₂ hg).hom_inv_id\n\n"}
{"name":"CategoryTheory.ShortComplex.cyclesIsoX₂_inv_hom_id_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst✝ : S.HasLeftHomology\nhg : Eq S.g 0\nZ : C\nh : Quiver.Hom S.X₂ Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (S.cyclesIsoX₂ hg).inv (CategoryTheory.CategoryStruct.comp S.iCycles h)) h","decl":"@[reassoc (attr := simp)]\nlemma cyclesIsoX₂_inv_hom_id (hg : S.g = 0) :\n    (S.cyclesIsoX₂ hg).inv ≫ S.iCycles = 𝟙 _ := (S.cyclesIsoX₂ hg).inv_hom_id\n\n"}
{"name":"CategoryTheory.ShortComplex.cyclesIsoX₂_inv_hom_id","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst✝ : S.HasLeftHomology\nhg : Eq S.g 0\n⊢ Eq (CategoryTheory.CategoryStruct.comp (S.cyclesIsoX₂ hg).inv S.iCycles) (CategoryTheory.CategoryStruct.id S.X₂)","decl":"@[reassoc (attr := simp)]\nlemma cyclesIsoX₂_inv_hom_id (hg : S.g = 0) :\n    (S.cyclesIsoX₂ hg).inv ≫ S.iCycles = 𝟙 _ := (S.cyclesIsoX₂ hg).inv_hom_id\n\n"}
{"name":"CategoryTheory.ShortComplex.isIso_leftHomologyπ","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst✝ : S.HasLeftHomology\nhf : Eq S.f 0\n⊢ CategoryTheory.IsIso S.leftHomologyπ","decl":"lemma isIso_leftHomologyπ (hf : S.f = 0) : IsIso S.leftHomologyπ :=\n  LeftHomologyData.isIso_π _ hf\n\n"}
{"name":"CategoryTheory.ShortComplex.cyclesIsoLeftHomology_hom","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst✝ : S.HasLeftHomology\nhf : Eq S.f 0\n⊢ Eq (S.cyclesIsoLeftHomology hf).hom S.leftHomologyπ","decl":"/-- When `S.f = 0`, this is the canonical isomorphism `S.cycles ≅ S.leftHomology` induced\nby `S.leftHomologyπ`. -/\n@[simps! hom]\nnoncomputable def cyclesIsoLeftHomology (hf : S.f = 0) : S.cycles ≅ S.leftHomology := by\n  have := S.isIso_leftHomologyπ hf\n  exact asIso S.leftHomologyπ\n\n"}
{"name":"CategoryTheory.ShortComplex.cyclesIsoLeftHomology_hom_inv_id","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst✝ : S.HasLeftHomology\nhf : Eq S.f 0\n⊢ Eq (CategoryTheory.CategoryStruct.comp S.leftHomologyπ (S.cyclesIsoLeftHomology hf).inv) (CategoryTheory.CategoryStruct.id S.cycles)","decl":"@[reassoc (attr := simp)]\nlemma cyclesIsoLeftHomology_hom_inv_id (hf : S.f = 0) :\n    S.leftHomologyπ ≫ (S.cyclesIsoLeftHomology hf).inv = 𝟙 _ :=\n  (S.cyclesIsoLeftHomology hf).hom_inv_id\n\n"}
{"name":"CategoryTheory.ShortComplex.cyclesIsoLeftHomology_hom_inv_id_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst✝ : S.HasLeftHomology\nhf : Eq S.f 0\nZ : C\nh : Quiver.Hom S.cycles Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp S.leftHomologyπ (CategoryTheory.CategoryStruct.comp (S.cyclesIsoLeftHomology hf).inv h)) h","decl":"@[reassoc (attr := simp)]\nlemma cyclesIsoLeftHomology_hom_inv_id (hf : S.f = 0) :\n    S.leftHomologyπ ≫ (S.cyclesIsoLeftHomology hf).inv = 𝟙 _ :=\n  (S.cyclesIsoLeftHomology hf).hom_inv_id\n\n"}
{"name":"CategoryTheory.ShortComplex.cyclesIsoLeftHomology_inv_hom_id","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst✝ : S.HasLeftHomology\nhf : Eq S.f 0\n⊢ Eq (CategoryTheory.CategoryStruct.comp (S.cyclesIsoLeftHomology hf).inv S.leftHomologyπ) (CategoryTheory.CategoryStruct.id S.leftHomology)","decl":"@[reassoc (attr := simp)]\nlemma cyclesIsoLeftHomology_inv_hom_id (hf : S.f = 0) :\n    (S.cyclesIsoLeftHomology hf).inv ≫ S.leftHomologyπ = 𝟙 _ :=\n  (S.cyclesIsoLeftHomology hf).inv_hom_id\n\n"}
{"name":"CategoryTheory.ShortComplex.cyclesIsoLeftHomology_inv_hom_id_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst✝ : S.HasLeftHomology\nhf : Eq S.f 0\nZ : C\nh : Quiver.Hom S.leftHomology Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (S.cyclesIsoLeftHomology hf).inv (CategoryTheory.CategoryStruct.comp S.leftHomologyπ h)) h","decl":"@[reassoc (attr := simp)]\nlemma cyclesIsoLeftHomology_inv_hom_id (hf : S.f = 0) :\n    (S.cyclesIsoLeftHomology hf).inv ≫ S.leftHomologyπ = 𝟙 _ :=\n  (S.cyclesIsoLeftHomology hf).inv_hom_id\n\n"}
{"name":"CategoryTheory.ShortComplex.cyclesMap'_i","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nh₁ : S₁.LeftHomologyData\nh₂ : S₂.LeftHomologyData\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.cyclesMap' φ h₁ h₂) h₂.i) (CategoryTheory.CategoryStruct.comp h₁.i φ.τ₂)","decl":"@[reassoc (attr := simp)]\nlemma cyclesMap'_i : cyclesMap' φ h₁ h₂ ≫ h₂.i = h₁.i ≫ φ.τ₂ :=\n  LeftHomologyMapData.commi _\n\n"}
{"name":"CategoryTheory.ShortComplex.cyclesMap'_i_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nh₁ : S₁.LeftHomologyData\nh₂ : S₂.LeftHomologyData\nZ : C\nh : Quiver.Hom S₂.X₂ Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.cyclesMap' φ h₁ h₂) (CategoryTheory.CategoryStruct.comp h₂.i h)) (CategoryTheory.CategoryStruct.comp h₁.i (CategoryTheory.CategoryStruct.comp φ.τ₂ h))","decl":"@[reassoc (attr := simp)]\nlemma cyclesMap'_i : cyclesMap' φ h₁ h₂ ≫ h₂.i = h₁.i ≫ φ.τ₂ :=\n  LeftHomologyMapData.commi _\n\n"}
{"name":"CategoryTheory.ShortComplex.f'_cyclesMap'_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nh₁ : S₁.LeftHomologyData\nh₂ : S₂.LeftHomologyData\nZ : C\nh : Quiver.Hom h₂.K Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp h₁.f' (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.cyclesMap' φ h₁ h₂) h)) (CategoryTheory.CategoryStruct.comp φ.τ₁ (CategoryTheory.CategoryStruct.comp h₂.f' h))","decl":"@[reassoc (attr := simp)]\nlemma f'_cyclesMap' : h₁.f' ≫ cyclesMap' φ h₁ h₂ = φ.τ₁ ≫ h₂.f' := by\n  simp only [← cancel_mono h₂.i, assoc, φ.comm₁₂, cyclesMap'_i,\n    LeftHomologyData.f'_i_assoc, LeftHomologyData.f'_i]\n\n"}
{"name":"CategoryTheory.ShortComplex.f'_cyclesMap'","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nh₁ : S₁.LeftHomologyData\nh₂ : S₂.LeftHomologyData\n⊢ Eq (CategoryTheory.CategoryStruct.comp h₁.f' (CategoryTheory.ShortComplex.cyclesMap' φ h₁ h₂)) (CategoryTheory.CategoryStruct.comp φ.τ₁ h₂.f')","decl":"@[reassoc (attr := simp)]\nlemma f'_cyclesMap' : h₁.f' ≫ cyclesMap' φ h₁ h₂ = φ.τ₁ ≫ h₂.f' := by\n  simp only [← cancel_mono h₂.i, assoc, φ.comm₁₂, cyclesMap'_i,\n    LeftHomologyData.f'_i_assoc, LeftHomologyData.f'_i]\n\n"}
{"name":"CategoryTheory.ShortComplex.leftHomologyπ_naturality'","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nh₁ : S₁.LeftHomologyData\nh₂ : S₂.LeftHomologyData\n⊢ Eq (CategoryTheory.CategoryStruct.comp h₁.π (CategoryTheory.ShortComplex.leftHomologyMap' φ h₁ h₂)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.cyclesMap' φ h₁ h₂) h₂.π)","decl":"@[reassoc (attr := simp)]\nlemma leftHomologyπ_naturality' :\n    h₁.π ≫ leftHomologyMap' φ h₁ h₂ = cyclesMap' φ h₁ h₂ ≫ h₂.π :=\n  LeftHomologyMapData.commπ _\n\n"}
{"name":"CategoryTheory.ShortComplex.leftHomologyπ_naturality'_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nh₁ : S₁.LeftHomologyData\nh₂ : S₂.LeftHomologyData\nZ : C\nh : Quiver.Hom h₂.H Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp h₁.π (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.leftHomologyMap' φ h₁ h₂) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.cyclesMap' φ h₁ h₂) (CategoryTheory.CategoryStruct.comp h₂.π h))","decl":"@[reassoc (attr := simp)]\nlemma leftHomologyπ_naturality' :\n    h₁.π ≫ leftHomologyMap' φ h₁ h₂ = cyclesMap' φ h₁ h₂ ≫ h₂.π :=\n  LeftHomologyMapData.commπ _\n\n"}
{"name":"CategoryTheory.ShortComplex.cyclesMap_i_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_2, u_1} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\ninst✝¹ : S₁.HasLeftHomology\ninst✝ : S₂.HasLeftHomology\nφ : Quiver.Hom S₁ S₂\nZ : C\nh : Quiver.Hom S₂.X₂ Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.cyclesMap φ) (CategoryTheory.CategoryStruct.comp S₂.iCycles h)) (CategoryTheory.CategoryStruct.comp S₁.iCycles (CategoryTheory.CategoryStruct.comp φ.τ₂ h))","decl":"@[reassoc (attr := simp)]\nlemma cyclesMap_i : cyclesMap φ ≫ S₂.iCycles = S₁.iCycles ≫ φ.τ₂ :=\n  cyclesMap'_i _ _ _\n\n"}
{"name":"CategoryTheory.ShortComplex.cyclesMap_i","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_2, u_1} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\ninst✝¹ : S₁.HasLeftHomology\ninst✝ : S₂.HasLeftHomology\nφ : Quiver.Hom S₁ S₂\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.cyclesMap φ) S₂.iCycles) (CategoryTheory.CategoryStruct.comp S₁.iCycles φ.τ₂)","decl":"@[reassoc (attr := simp)]\nlemma cyclesMap_i : cyclesMap φ ≫ S₂.iCycles = S₁.iCycles ≫ φ.τ₂ :=\n  cyclesMap'_i _ _ _\n\n"}
{"name":"CategoryTheory.ShortComplex.toCycles_naturality","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_2, u_1} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\ninst✝¹ : S₁.HasLeftHomology\ninst✝ : S₂.HasLeftHomology\nφ : Quiver.Hom S₁ S₂\n⊢ Eq (CategoryTheory.CategoryStruct.comp S₁.toCycles (CategoryTheory.ShortComplex.cyclesMap φ)) (CategoryTheory.CategoryStruct.comp φ.τ₁ S₂.toCycles)","decl":"@[reassoc (attr := simp)]\nlemma toCycles_naturality : S₁.toCycles ≫ cyclesMap φ = φ.τ₁ ≫ S₂.toCycles :=\n  f'_cyclesMap' _ _ _\n\n"}
{"name":"CategoryTheory.ShortComplex.toCycles_naturality_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_2, u_1} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\ninst✝¹ : S₁.HasLeftHomology\ninst✝ : S₂.HasLeftHomology\nφ : Quiver.Hom S₁ S₂\nZ : C\nh : Quiver.Hom S₂.cycles Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp S₁.toCycles (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.cyclesMap φ) h)) (CategoryTheory.CategoryStruct.comp φ.τ₁ (CategoryTheory.CategoryStruct.comp S₂.toCycles h))","decl":"@[reassoc (attr := simp)]\nlemma toCycles_naturality : S₁.toCycles ≫ cyclesMap φ = φ.τ₁ ≫ S₂.toCycles :=\n  f'_cyclesMap' _ _ _\n\n"}
{"name":"CategoryTheory.ShortComplex.leftHomologyπ_naturality_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_2, u_1} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\ninst✝¹ : S₁.HasLeftHomology\ninst✝ : S₂.HasLeftHomology\nφ : Quiver.Hom S₁ S₂\nZ : C\nh : Quiver.Hom S₂.leftHomology Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp S₁.leftHomologyπ (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.leftHomologyMap φ) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.cyclesMap φ) (CategoryTheory.CategoryStruct.comp S₂.leftHomologyπ h))","decl":"@[reassoc (attr := simp)]\nlemma leftHomologyπ_naturality :\n    S₁.leftHomologyπ ≫ leftHomologyMap φ = cyclesMap φ ≫ S₂.leftHomologyπ :=\n  leftHomologyπ_naturality' _ _ _\n\n"}
{"name":"CategoryTheory.ShortComplex.leftHomologyπ_naturality","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_2, u_1} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\ninst✝¹ : S₁.HasLeftHomology\ninst✝ : S₂.HasLeftHomology\nφ : Quiver.Hom S₁ S₂\n⊢ Eq (CategoryTheory.CategoryStruct.comp S₁.leftHomologyπ (CategoryTheory.ShortComplex.leftHomologyMap φ)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.cyclesMap φ) S₂.leftHomologyπ)","decl":"@[reassoc (attr := simp)]\nlemma leftHomologyπ_naturality :\n    S₁.leftHomologyπ ≫ leftHomologyMap φ = cyclesMap φ ≫ S₂.leftHomologyπ :=\n  leftHomologyπ_naturality' _ _ _\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyMapData.leftHomologyMap'_eq","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nh₁ : S₁.LeftHomologyData\nh₂ : S₂.LeftHomologyData\nγ : CategoryTheory.ShortComplex.LeftHomologyMapData φ h₁ h₂\n⊢ Eq (CategoryTheory.ShortComplex.leftHomologyMap' φ h₁ h₂) γ.φH","decl":"lemma leftHomologyMap'_eq : leftHomologyMap' φ h₁ h₂ = γ.φH :=\n  LeftHomologyMapData.congr_φH (Subsingleton.elim _ _)\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyMapData.cyclesMap'_eq","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nh₁ : S₁.LeftHomologyData\nh₂ : S₂.LeftHomologyData\nγ : CategoryTheory.ShortComplex.LeftHomologyMapData φ h₁ h₂\n⊢ Eq (CategoryTheory.ShortComplex.cyclesMap' φ h₁ h₂) γ.φK","decl":"lemma cyclesMap'_eq : cyclesMap' φ h₁ h₂ = γ.φK :=\n  LeftHomologyMapData.congr_φK (Subsingleton.elim _ _)\n\n"}
{"name":"CategoryTheory.ShortComplex.leftHomologyMap'_id","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nh : S.LeftHomologyData\n⊢ Eq (CategoryTheory.ShortComplex.leftHomologyMap' (CategoryTheory.CategoryStruct.id S) h h) (CategoryTheory.CategoryStruct.id h.H)","decl":"@[simp]\nlemma leftHomologyMap'_id (h : S.LeftHomologyData) :\n    leftHomologyMap' (𝟙 S) h h = 𝟙 _ :=\n  (LeftHomologyMapData.id h).leftHomologyMap'_eq\n\n"}
{"name":"CategoryTheory.ShortComplex.cyclesMap'_id","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nh : S.LeftHomologyData\n⊢ Eq (CategoryTheory.ShortComplex.cyclesMap' (CategoryTheory.CategoryStruct.id S) h h) (CategoryTheory.CategoryStruct.id h.K)","decl":"@[simp]\nlemma cyclesMap'_id (h : S.LeftHomologyData) :\n    cyclesMap' (𝟙 S) h h = 𝟙 _ :=\n  (LeftHomologyMapData.id h).cyclesMap'_eq\n\n"}
{"name":"CategoryTheory.ShortComplex.leftHomologyMap_id","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst✝ : S.HasLeftHomology\n⊢ Eq (CategoryTheory.ShortComplex.leftHomologyMap (CategoryTheory.CategoryStruct.id S)) (CategoryTheory.CategoryStruct.id S.leftHomology)","decl":"@[simp]\nlemma leftHomologyMap_id [HasLeftHomology S] :\n    leftHomologyMap (𝟙 S) = 𝟙 _ :=\n  leftHomologyMap'_id _\n\n"}
{"name":"CategoryTheory.ShortComplex.cyclesMap_id","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst✝ : S.HasLeftHomology\n⊢ Eq (CategoryTheory.ShortComplex.cyclesMap (CategoryTheory.CategoryStruct.id S)) (CategoryTheory.CategoryStruct.id S.cycles)","decl":"@[simp]\nlemma cyclesMap_id [HasLeftHomology S] :\n    cyclesMap (𝟙 S) = 𝟙 _ :=\n  cyclesMap'_id _\n\n"}
{"name":"CategoryTheory.ShortComplex.leftHomologyMap'_zero","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nh₁ : S₁.LeftHomologyData\nh₂ : S₂.LeftHomologyData\n⊢ Eq (CategoryTheory.ShortComplex.leftHomologyMap' 0 h₁ h₂) 0","decl":"@[simp]\nlemma leftHomologyMap'_zero (h₁ : S₁.LeftHomologyData) (h₂ : S₂.LeftHomologyData) :\n    leftHomologyMap' 0 h₁ h₂ = 0 :=\n  (LeftHomologyMapData.zero h₁ h₂).leftHomologyMap'_eq\n\n"}
{"name":"CategoryTheory.ShortComplex.cyclesMap'_zero","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nh₁ : S₁.LeftHomologyData\nh₂ : S₂.LeftHomologyData\n⊢ Eq (CategoryTheory.ShortComplex.cyclesMap' 0 h₁ h₂) 0","decl":"@[simp]\nlemma cyclesMap'_zero (h₁ : S₁.LeftHomologyData) (h₂ : S₂.LeftHomologyData) :\n    cyclesMap' 0 h₁ h₂ = 0 :=\n  (LeftHomologyMapData.zero h₁ h₂).cyclesMap'_eq\n\n"}
{"name":"CategoryTheory.ShortComplex.leftHomologyMap_zero","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_2, u_1} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\ninst✝¹ : S₁.HasLeftHomology\ninst✝ : S₂.HasLeftHomology\n⊢ Eq (CategoryTheory.ShortComplex.leftHomologyMap 0) 0","decl":"@[simp]\nlemma leftHomologyMap_zero [HasLeftHomology S₁] [HasLeftHomology S₂] :\n    leftHomologyMap (0 : S₁ ⟶ S₂) = 0 :=\n  leftHomologyMap'_zero _ _\n\n"}
{"name":"CategoryTheory.ShortComplex.cyclesMap_zero","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_2, u_1} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\ninst✝¹ : S₁.HasLeftHomology\ninst✝ : S₂.HasLeftHomology\n⊢ Eq (CategoryTheory.ShortComplex.cyclesMap 0) 0","decl":"@[simp]\nlemma cyclesMap_zero [HasLeftHomology S₁] [HasLeftHomology S₂] :\n    cyclesMap (0 : S₁ ⟶ S₂) = 0 :=\n  cyclesMap'_zero _ _\n\n"}
{"name":"CategoryTheory.ShortComplex.leftHomologyMap'_comp_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ S₃ : CategoryTheory.ShortComplex C\nφ₁ : Quiver.Hom S₁ S₂\nφ₂ : Quiver.Hom S₂ S₃\nh₁ : S₁.LeftHomologyData\nh₂ : S₂.LeftHomologyData\nh₃ : S₃.LeftHomologyData\nZ : C\nh : Quiver.Hom h₃.H Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.leftHomologyMap' (CategoryTheory.CategoryStruct.comp φ₁ φ₂) h₁ h₃) h) (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.leftHomologyMap' φ₁ h₁ h₂) (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.leftHomologyMap' φ₂ h₂ h₃) h))","decl":"@[reassoc]\nlemma leftHomologyMap'_comp (φ₁ : S₁ ⟶ S₂) (φ₂ : S₂ ⟶ S₃)\n    (h₁ : S₁.LeftHomologyData) (h₂ : S₂.LeftHomologyData) (h₃ : S₃.LeftHomologyData) :\n    leftHomologyMap' (φ₁ ≫ φ₂) h₁ h₃ = leftHomologyMap' φ₁ h₁ h₂ ≫\n      leftHomologyMap' φ₂ h₂ h₃ := by\n  let γ₁ := leftHomologyMapData φ₁ h₁ h₂\n  let γ₂ := leftHomologyMapData φ₂ h₂ h₃\n  rw [γ₁.leftHomologyMap'_eq, γ₂.leftHomologyMap'_eq, (γ₁.comp γ₂).leftHomologyMap'_eq,\n    LeftHomologyMapData.comp_φH]\n\n"}
{"name":"CategoryTheory.ShortComplex.leftHomologyMap'_comp","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ S₃ : CategoryTheory.ShortComplex C\nφ₁ : Quiver.Hom S₁ S₂\nφ₂ : Quiver.Hom S₂ S₃\nh₁ : S₁.LeftHomologyData\nh₂ : S₂.LeftHomologyData\nh₃ : S₃.LeftHomologyData\n⊢ Eq (CategoryTheory.ShortComplex.leftHomologyMap' (CategoryTheory.CategoryStruct.comp φ₁ φ₂) h₁ h₃) (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.leftHomologyMap' φ₁ h₁ h₂) (CategoryTheory.ShortComplex.leftHomologyMap' φ₂ h₂ h₃))","decl":"@[reassoc]\nlemma leftHomologyMap'_comp (φ₁ : S₁ ⟶ S₂) (φ₂ : S₂ ⟶ S₃)\n    (h₁ : S₁.LeftHomologyData) (h₂ : S₂.LeftHomologyData) (h₃ : S₃.LeftHomologyData) :\n    leftHomologyMap' (φ₁ ≫ φ₂) h₁ h₃ = leftHomologyMap' φ₁ h₁ h₂ ≫\n      leftHomologyMap' φ₂ h₂ h₃ := by\n  let γ₁ := leftHomologyMapData φ₁ h₁ h₂\n  let γ₂ := leftHomologyMapData φ₂ h₂ h₃\n  rw [γ₁.leftHomologyMap'_eq, γ₂.leftHomologyMap'_eq, (γ₁.comp γ₂).leftHomologyMap'_eq,\n    LeftHomologyMapData.comp_φH]\n\n"}
{"name":"CategoryTheory.ShortComplex.cyclesMap'_comp","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ S₃ : CategoryTheory.ShortComplex C\nφ₁ : Quiver.Hom S₁ S₂\nφ₂ : Quiver.Hom S₂ S₃\nh₁ : S₁.LeftHomologyData\nh₂ : S₂.LeftHomologyData\nh₃ : S₃.LeftHomologyData\n⊢ Eq (CategoryTheory.ShortComplex.cyclesMap' (CategoryTheory.CategoryStruct.comp φ₁ φ₂) h₁ h₃) (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.cyclesMap' φ₁ h₁ h₂) (CategoryTheory.ShortComplex.cyclesMap' φ₂ h₂ h₃))","decl":"@[reassoc]\nlemma cyclesMap'_comp (φ₁ : S₁ ⟶ S₂) (φ₂ : S₂ ⟶ S₃)\n    (h₁ : S₁.LeftHomologyData) (h₂ : S₂.LeftHomologyData) (h₃ : S₃.LeftHomologyData) :\n    cyclesMap' (φ₁ ≫ φ₂) h₁ h₃ = cyclesMap' φ₁ h₁ h₂ ≫ cyclesMap' φ₂ h₂ h₃ := by\n  let γ₁ := leftHomologyMapData φ₁ h₁ h₂\n  let γ₂ := leftHomologyMapData φ₂ h₂ h₃\n  rw [γ₁.cyclesMap'_eq, γ₂.cyclesMap'_eq, (γ₁.comp γ₂).cyclesMap'_eq,\n    LeftHomologyMapData.comp_φK]\n\n"}
{"name":"CategoryTheory.ShortComplex.cyclesMap'_comp_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ S₃ : CategoryTheory.ShortComplex C\nφ₁ : Quiver.Hom S₁ S₂\nφ₂ : Quiver.Hom S₂ S₃\nh₁ : S₁.LeftHomologyData\nh₂ : S₂.LeftHomologyData\nh₃ : S₃.LeftHomologyData\nZ : C\nh : Quiver.Hom h₃.K Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.cyclesMap' (CategoryTheory.CategoryStruct.comp φ₁ φ₂) h₁ h₃) h) (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.cyclesMap' φ₁ h₁ h₂) (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.cyclesMap' φ₂ h₂ h₃) h))","decl":"@[reassoc]\nlemma cyclesMap'_comp (φ₁ : S₁ ⟶ S₂) (φ₂ : S₂ ⟶ S₃)\n    (h₁ : S₁.LeftHomologyData) (h₂ : S₂.LeftHomologyData) (h₃ : S₃.LeftHomologyData) :\n    cyclesMap' (φ₁ ≫ φ₂) h₁ h₃ = cyclesMap' φ₁ h₁ h₂ ≫ cyclesMap' φ₂ h₂ h₃ := by\n  let γ₁ := leftHomologyMapData φ₁ h₁ h₂\n  let γ₂ := leftHomologyMapData φ₂ h₂ h₃\n  rw [γ₁.cyclesMap'_eq, γ₂.cyclesMap'_eq, (γ₁.comp γ₂).cyclesMap'_eq,\n    LeftHomologyMapData.comp_φK]\n\n"}
{"name":"CategoryTheory.ShortComplex.leftHomologyMap_comp_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_2, u_1} C\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ S₃ : CategoryTheory.ShortComplex C\ninst✝² : S₁.HasLeftHomology\ninst✝¹ : S₂.HasLeftHomology\ninst✝ : S₃.HasLeftHomology\nφ₁ : Quiver.Hom S₁ S₂\nφ₂ : Quiver.Hom S₂ S₃\nZ : C\nh : Quiver.Hom S₃.leftHomology Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.leftHomologyMap (CategoryTheory.CategoryStruct.comp φ₁ φ₂)) h) (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.leftHomologyMap φ₁) (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.leftHomologyMap φ₂) h))","decl":"@[reassoc]\nlemma leftHomologyMap_comp [HasLeftHomology S₁] [HasLeftHomology S₂] [HasLeftHomology S₃]\n    (φ₁ : S₁ ⟶ S₂) (φ₂ : S₂ ⟶ S₃) :\n    leftHomologyMap (φ₁ ≫ φ₂) = leftHomologyMap φ₁ ≫ leftHomologyMap φ₂ :=\n  leftHomologyMap'_comp _ _ _ _ _\n\n"}
{"name":"CategoryTheory.ShortComplex.leftHomologyMap_comp","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_2, u_1} C\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ S₃ : CategoryTheory.ShortComplex C\ninst✝² : S₁.HasLeftHomology\ninst✝¹ : S₂.HasLeftHomology\ninst✝ : S₃.HasLeftHomology\nφ₁ : Quiver.Hom S₁ S₂\nφ₂ : Quiver.Hom S₂ S₃\n⊢ Eq (CategoryTheory.ShortComplex.leftHomologyMap (CategoryTheory.CategoryStruct.comp φ₁ φ₂)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.leftHomologyMap φ₁) (CategoryTheory.ShortComplex.leftHomologyMap φ₂))","decl":"@[reassoc]\nlemma leftHomologyMap_comp [HasLeftHomology S₁] [HasLeftHomology S₂] [HasLeftHomology S₃]\n    (φ₁ : S₁ ⟶ S₂) (φ₂ : S₂ ⟶ S₃) :\n    leftHomologyMap (φ₁ ≫ φ₂) = leftHomologyMap φ₁ ≫ leftHomologyMap φ₂ :=\n  leftHomologyMap'_comp _ _ _ _ _\n\n"}
{"name":"CategoryTheory.ShortComplex.cyclesMap_comp_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_2, u_1} C\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ S₃ : CategoryTheory.ShortComplex C\ninst✝² : S₁.HasLeftHomology\ninst✝¹ : S₂.HasLeftHomology\ninst✝ : S₃.HasLeftHomology\nφ₁ : Quiver.Hom S₁ S₂\nφ₂ : Quiver.Hom S₂ S₃\nZ : C\nh : Quiver.Hom S₃.cycles Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.cyclesMap (CategoryTheory.CategoryStruct.comp φ₁ φ₂)) h) (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.cyclesMap φ₁) (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.cyclesMap φ₂) h))","decl":"@[reassoc]\nlemma cyclesMap_comp [HasLeftHomology S₁] [HasLeftHomology S₂] [HasLeftHomology S₃]\n    (φ₁ : S₁ ⟶ S₂) (φ₂ : S₂ ⟶ S₃) :\n    cyclesMap (φ₁ ≫ φ₂) = cyclesMap φ₁ ≫ cyclesMap φ₂ :=\n  cyclesMap'_comp _ _ _ _ _\n\n"}
{"name":"CategoryTheory.ShortComplex.cyclesMap_comp","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_2, u_1} C\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ S₃ : CategoryTheory.ShortComplex C\ninst✝² : S₁.HasLeftHomology\ninst✝¹ : S₂.HasLeftHomology\ninst✝ : S₃.HasLeftHomology\nφ₁ : Quiver.Hom S₁ S₂\nφ₂ : Quiver.Hom S₂ S₃\n⊢ Eq (CategoryTheory.ShortComplex.cyclesMap (CategoryTheory.CategoryStruct.comp φ₁ φ₂)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.cyclesMap φ₁) (CategoryTheory.ShortComplex.cyclesMap φ₂))","decl":"@[reassoc]\nlemma cyclesMap_comp [HasLeftHomology S₁] [HasLeftHomology S₂] [HasLeftHomology S₃]\n    (φ₁ : S₁ ⟶ S₂) (φ₂ : S₂ ⟶ S₃) :\n    cyclesMap (φ₁ ≫ φ₂) = cyclesMap φ₁ ≫ cyclesMap φ₂ :=\n  cyclesMap'_comp _ _ _ _ _\n\n"}
{"name":"CategoryTheory.ShortComplex.leftHomologyMapIso'_hom","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\ne : CategoryTheory.Iso S₁ S₂\nh₁ : S₁.LeftHomologyData\nh₂ : S₂.LeftHomologyData\n⊢ Eq (CategoryTheory.ShortComplex.leftHomologyMapIso' e h₁ h₂).hom (CategoryTheory.ShortComplex.leftHomologyMap' e.hom h₁ h₂)","decl":"/-- An isomorphism of short complexes `S₁ ≅ S₂` induces an isomorphism on the `H` fields\nof left homology data of `S₁` and `S₂`. -/\n@[simps]\ndef leftHomologyMapIso' (e : S₁ ≅ S₂) (h₁ : S₁.LeftHomologyData)\n    (h₂ : S₂.LeftHomologyData) : h₁.H ≅ h₂.H where\n  hom := leftHomologyMap' e.hom h₁ h₂\n  inv := leftHomologyMap' e.inv h₂ h₁\n  hom_inv_id := by rw [← leftHomologyMap'_comp, e.hom_inv_id, leftHomologyMap'_id]\n  inv_hom_id := by rw [← leftHomologyMap'_comp, e.inv_hom_id, leftHomologyMap'_id]\n\n"}
{"name":"CategoryTheory.ShortComplex.leftHomologyMapIso'_inv","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\ne : CategoryTheory.Iso S₁ S₂\nh₁ : S₁.LeftHomologyData\nh₂ : S₂.LeftHomologyData\n⊢ Eq (CategoryTheory.ShortComplex.leftHomologyMapIso' e h₁ h₂).inv (CategoryTheory.ShortComplex.leftHomologyMap' e.inv h₂ h₁)","decl":"/-- An isomorphism of short complexes `S₁ ≅ S₂` induces an isomorphism on the `H` fields\nof left homology data of `S₁` and `S₂`. -/\n@[simps]\ndef leftHomologyMapIso' (e : S₁ ≅ S₂) (h₁ : S₁.LeftHomologyData)\n    (h₂ : S₂.LeftHomologyData) : h₁.H ≅ h₂.H where\n  hom := leftHomologyMap' e.hom h₁ h₂\n  inv := leftHomologyMap' e.inv h₂ h₁\n  hom_inv_id := by rw [← leftHomologyMap'_comp, e.hom_inv_id, leftHomologyMap'_id]\n  inv_hom_id := by rw [← leftHomologyMap'_comp, e.inv_hom_id, leftHomologyMap'_id]\n\n"}
{"name":"CategoryTheory.ShortComplex.isIso_leftHomologyMap'_of_isIso","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\ninst✝ : CategoryTheory.IsIso φ\nh₁ : S₁.LeftHomologyData\nh₂ : S₂.LeftHomologyData\n⊢ CategoryTheory.IsIso (CategoryTheory.ShortComplex.leftHomologyMap' φ h₁ h₂)","decl":"instance isIso_leftHomologyMap'_of_isIso (φ : S₁ ⟶ S₂) [IsIso φ]\n    (h₁ : S₁.LeftHomologyData) (h₂ : S₂.LeftHomologyData) :\n    IsIso (leftHomologyMap' φ h₁ h₂) :=\n  (inferInstance : IsIso (leftHomologyMapIso' (asIso φ) h₁ h₂).hom)\n\n"}
{"name":"CategoryTheory.ShortComplex.cyclesMapIso'_hom","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\ne : CategoryTheory.Iso S₁ S₂\nh₁ : S₁.LeftHomologyData\nh₂ : S₂.LeftHomologyData\n⊢ Eq (CategoryTheory.ShortComplex.cyclesMapIso' e h₁ h₂).hom (CategoryTheory.ShortComplex.cyclesMap' e.hom h₁ h₂)","decl":"/-- An isomorphism of short complexes `S₁ ≅ S₂` induces an isomorphism on the `K` fields\nof left homology data of `S₁` and `S₂`. -/\n@[simps]\ndef cyclesMapIso' (e : S₁ ≅ S₂) (h₁ : S₁.LeftHomologyData)\n    (h₂ : S₂.LeftHomologyData) : h₁.K ≅ h₂.K where\n  hom := cyclesMap' e.hom h₁ h₂\n  inv := cyclesMap' e.inv h₂ h₁\n  hom_inv_id := by rw [← cyclesMap'_comp, e.hom_inv_id, cyclesMap'_id]\n  inv_hom_id := by rw [← cyclesMap'_comp, e.inv_hom_id, cyclesMap'_id]\n\n"}
{"name":"CategoryTheory.ShortComplex.cyclesMapIso'_inv","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\ne : CategoryTheory.Iso S₁ S₂\nh₁ : S₁.LeftHomologyData\nh₂ : S₂.LeftHomologyData\n⊢ Eq (CategoryTheory.ShortComplex.cyclesMapIso' e h₁ h₂).inv (CategoryTheory.ShortComplex.cyclesMap' e.inv h₂ h₁)","decl":"/-- An isomorphism of short complexes `S₁ ≅ S₂` induces an isomorphism on the `K` fields\nof left homology data of `S₁` and `S₂`. -/\n@[simps]\ndef cyclesMapIso' (e : S₁ ≅ S₂) (h₁ : S₁.LeftHomologyData)\n    (h₂ : S₂.LeftHomologyData) : h₁.K ≅ h₂.K where\n  hom := cyclesMap' e.hom h₁ h₂\n  inv := cyclesMap' e.inv h₂ h₁\n  hom_inv_id := by rw [← cyclesMap'_comp, e.hom_inv_id, cyclesMap'_id]\n  inv_hom_id := by rw [← cyclesMap'_comp, e.inv_hom_id, cyclesMap'_id]\n\n"}
{"name":"CategoryTheory.ShortComplex.isIso_cyclesMap'_of_isIso","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\ninst✝ : CategoryTheory.IsIso φ\nh₁ : S₁.LeftHomologyData\nh₂ : S₂.LeftHomologyData\n⊢ CategoryTheory.IsIso (CategoryTheory.ShortComplex.cyclesMap' φ h₁ h₂)","decl":"instance isIso_cyclesMap'_of_isIso (φ : S₁ ⟶ S₂) [IsIso φ]\n    (h₁ : S₁.LeftHomologyData) (h₂ : S₂.LeftHomologyData) :\n    IsIso (cyclesMap' φ h₁ h₂) :=\n  (inferInstance : IsIso (cyclesMapIso' (asIso φ) h₁ h₂).hom)\n\n"}
{"name":"CategoryTheory.ShortComplex.leftHomologyMapIso_hom","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_2, u_1} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\ne : CategoryTheory.Iso S₁ S₂\ninst✝¹ : S₁.HasLeftHomology\ninst✝ : S₂.HasLeftHomology\n⊢ Eq (CategoryTheory.ShortComplex.leftHomologyMapIso e).hom (CategoryTheory.ShortComplex.leftHomologyMap e.hom)","decl":"/-- The isomorphism `S₁.leftHomology ≅ S₂.leftHomology` induced by an isomorphism of\nshort complexes `S₁ ≅ S₂`. -/\n@[simps]\nnoncomputable def leftHomologyMapIso (e : S₁ ≅ S₂) [S₁.HasLeftHomology]\n    [S₂.HasLeftHomology] : S₁.leftHomology ≅ S₂.leftHomology where\n  hom := leftHomologyMap e.hom\n  inv := leftHomologyMap e.inv\n  hom_inv_id := by rw [← leftHomologyMap_comp, e.hom_inv_id, leftHomologyMap_id]\n  inv_hom_id := by rw [← leftHomologyMap_comp, e.inv_hom_id, leftHomologyMap_id]\n\n"}
{"name":"CategoryTheory.ShortComplex.leftHomologyMapIso_inv","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_2, u_1} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\ne : CategoryTheory.Iso S₁ S₂\ninst✝¹ : S₁.HasLeftHomology\ninst✝ : S₂.HasLeftHomology\n⊢ Eq (CategoryTheory.ShortComplex.leftHomologyMapIso e).inv (CategoryTheory.ShortComplex.leftHomologyMap e.inv)","decl":"/-- The isomorphism `S₁.leftHomology ≅ S₂.leftHomology` induced by an isomorphism of\nshort complexes `S₁ ≅ S₂`. -/\n@[simps]\nnoncomputable def leftHomologyMapIso (e : S₁ ≅ S₂) [S₁.HasLeftHomology]\n    [S₂.HasLeftHomology] : S₁.leftHomology ≅ S₂.leftHomology where\n  hom := leftHomologyMap e.hom\n  inv := leftHomologyMap e.inv\n  hom_inv_id := by rw [← leftHomologyMap_comp, e.hom_inv_id, leftHomologyMap_id]\n  inv_hom_id := by rw [← leftHomologyMap_comp, e.inv_hom_id, leftHomologyMap_id]\n\n"}
{"name":"CategoryTheory.ShortComplex.isIso_leftHomologyMap_of_iso","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_2, u_1} C\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\ninst✝² : CategoryTheory.IsIso φ\ninst✝¹ : S₁.HasLeftHomology\ninst✝ : S₂.HasLeftHomology\n⊢ CategoryTheory.IsIso (CategoryTheory.ShortComplex.leftHomologyMap φ)","decl":"instance isIso_leftHomologyMap_of_iso (φ : S₁ ⟶ S₂)\n    [IsIso φ] [S₁.HasLeftHomology] [S₂.HasLeftHomology] :\n    IsIso (leftHomologyMap φ) :=\n  (inferInstance : IsIso (leftHomologyMapIso (asIso φ)).hom)\n\n"}
{"name":"CategoryTheory.ShortComplex.cyclesMapIso_hom","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_2, u_1} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\ne : CategoryTheory.Iso S₁ S₂\ninst✝¹ : S₁.HasLeftHomology\ninst✝ : S₂.HasLeftHomology\n⊢ Eq (CategoryTheory.ShortComplex.cyclesMapIso e).hom (CategoryTheory.ShortComplex.cyclesMap e.hom)","decl":"/-- The isomorphism `S₁.cycles ≅ S₂.cycles` induced by an isomorphism\nof short complexes `S₁ ≅ S₂`. -/\n@[simps]\nnoncomputable def cyclesMapIso (e : S₁ ≅ S₂) [S₁.HasLeftHomology]\n    [S₂.HasLeftHomology] : S₁.cycles ≅ S₂.cycles where\n  hom := cyclesMap e.hom\n  inv := cyclesMap e.inv\n  hom_inv_id := by rw [← cyclesMap_comp, e.hom_inv_id, cyclesMap_id]\n  inv_hom_id := by rw [← cyclesMap_comp, e.inv_hom_id, cyclesMap_id]\n\n"}
{"name":"CategoryTheory.ShortComplex.cyclesMapIso_inv","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_2, u_1} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\ne : CategoryTheory.Iso S₁ S₂\ninst✝¹ : S₁.HasLeftHomology\ninst✝ : S₂.HasLeftHomology\n⊢ Eq (CategoryTheory.ShortComplex.cyclesMapIso e).inv (CategoryTheory.ShortComplex.cyclesMap e.inv)","decl":"/-- The isomorphism `S₁.cycles ≅ S₂.cycles` induced by an isomorphism\nof short complexes `S₁ ≅ S₂`. -/\n@[simps]\nnoncomputable def cyclesMapIso (e : S₁ ≅ S₂) [S₁.HasLeftHomology]\n    [S₂.HasLeftHomology] : S₁.cycles ≅ S₂.cycles where\n  hom := cyclesMap e.hom\n  inv := cyclesMap e.inv\n  hom_inv_id := by rw [← cyclesMap_comp, e.hom_inv_id, cyclesMap_id]\n  inv_hom_id := by rw [← cyclesMap_comp, e.inv_hom_id, cyclesMap_id]\n\n"}
{"name":"CategoryTheory.ShortComplex.isIso_cyclesMap_of_iso","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_2, u_1} C\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\ninst✝² : CategoryTheory.IsIso φ\ninst✝¹ : S₁.HasLeftHomology\ninst✝ : S₂.HasLeftHomology\n⊢ CategoryTheory.IsIso (CategoryTheory.ShortComplex.cyclesMap φ)","decl":"instance isIso_cyclesMap_of_iso (φ : S₁ ⟶ S₂) [IsIso φ] [S₁.HasLeftHomology]\n    [S₂.HasLeftHomology] : IsIso (cyclesMap φ) :=\n  (inferInstance : IsIso (cyclesMapIso (asIso φ)).hom)\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.cyclesIso_hom_comp_i_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nh✝ : S.LeftHomologyData\ninst✝ : S.HasLeftHomology\nZ : C\nh : Quiver.Hom S.X₂ Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp h✝.cyclesIso.hom (CategoryTheory.CategoryStruct.comp h✝.i h)) (CategoryTheory.CategoryStruct.comp S.iCycles h)","decl":"@[reassoc (attr := simp)]\nlemma cyclesIso_hom_comp_i : h.cyclesIso.hom ≫ h.i = S.iCycles := by\n  dsimp [iCycles, LeftHomologyData.cyclesIso]\n  simp only [cyclesMap'_i, id_τ₂, comp_id]\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.cyclesIso_hom_comp_i","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nh : S.LeftHomologyData\ninst✝ : S.HasLeftHomology\n⊢ Eq (CategoryTheory.CategoryStruct.comp h.cyclesIso.hom h.i) S.iCycles","decl":"@[reassoc (attr := simp)]\nlemma cyclesIso_hom_comp_i : h.cyclesIso.hom ≫ h.i = S.iCycles := by\n  dsimp [iCycles, LeftHomologyData.cyclesIso]\n  simp only [cyclesMap'_i, id_τ₂, comp_id]\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.cyclesIso_inv_comp_iCycles","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nh : S.LeftHomologyData\ninst✝ : S.HasLeftHomology\n⊢ Eq (CategoryTheory.CategoryStruct.comp h.cyclesIso.inv S.iCycles) h.i","decl":"@[reassoc (attr := simp)]\nlemma cyclesIso_inv_comp_iCycles : h.cyclesIso.inv ≫ S.iCycles = h.i := by\n  simp only [← h.cyclesIso_hom_comp_i, Iso.inv_hom_id_assoc]\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.cyclesIso_inv_comp_iCycles_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nh✝ : S.LeftHomologyData\ninst✝ : S.HasLeftHomology\nZ : C\nh : Quiver.Hom S.X₂ Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp h✝.cyclesIso.inv (CategoryTheory.CategoryStruct.comp S.iCycles h)) (CategoryTheory.CategoryStruct.comp h✝.i h)","decl":"@[reassoc (attr := simp)]\nlemma cyclesIso_inv_comp_iCycles : h.cyclesIso.inv ≫ S.iCycles = h.i := by\n  simp only [← h.cyclesIso_hom_comp_i, Iso.inv_hom_id_assoc]\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.leftHomologyπ_comp_leftHomologyIso_hom_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nh✝ : S.LeftHomologyData\ninst✝ : S.HasLeftHomology\nZ : C\nh : Quiver.Hom h✝.H Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp S.leftHomologyπ (CategoryTheory.CategoryStruct.comp h✝.leftHomologyIso.hom h)) (CategoryTheory.CategoryStruct.comp h✝.cyclesIso.hom (CategoryTheory.CategoryStruct.comp h✝.π h))","decl":"@[reassoc (attr := simp)]\nlemma leftHomologyπ_comp_leftHomologyIso_hom :\n    S.leftHomologyπ ≫ h.leftHomologyIso.hom = h.cyclesIso.hom ≫ h.π := by\n  dsimp only [leftHomologyπ, leftHomologyIso, cyclesIso, leftHomologyMapIso',\n    cyclesMapIso', Iso.refl]\n  rw [← leftHomologyπ_naturality']\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.leftHomologyπ_comp_leftHomologyIso_hom","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nh : S.LeftHomologyData\ninst✝ : S.HasLeftHomology\n⊢ Eq (CategoryTheory.CategoryStruct.comp S.leftHomologyπ h.leftHomologyIso.hom) (CategoryTheory.CategoryStruct.comp h.cyclesIso.hom h.π)","decl":"@[reassoc (attr := simp)]\nlemma leftHomologyπ_comp_leftHomologyIso_hom :\n    S.leftHomologyπ ≫ h.leftHomologyIso.hom = h.cyclesIso.hom ≫ h.π := by\n  dsimp only [leftHomologyπ, leftHomologyIso, cyclesIso, leftHomologyMapIso',\n    cyclesMapIso', Iso.refl]\n  rw [← leftHomologyπ_naturality']\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.π_comp_leftHomologyIso_inv","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nh : S.LeftHomologyData\ninst✝ : S.HasLeftHomology\n⊢ Eq (CategoryTheory.CategoryStruct.comp h.π h.leftHomologyIso.inv) (CategoryTheory.CategoryStruct.comp h.cyclesIso.inv S.leftHomologyπ)","decl":"@[reassoc (attr := simp)]\nlemma π_comp_leftHomologyIso_inv :\n    h.π ≫ h.leftHomologyIso.inv = h.cyclesIso.inv ≫ S.leftHomologyπ := by\n  simp only [← cancel_epi h.cyclesIso.hom, ← cancel_mono h.leftHomologyIso.hom, assoc,\n    Iso.inv_hom_id, comp_id, Iso.hom_inv_id_assoc,\n    LeftHomologyData.leftHomologyπ_comp_leftHomologyIso_hom]\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.π_comp_leftHomologyIso_inv_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nh✝ : S.LeftHomologyData\ninst✝ : S.HasLeftHomology\nZ : C\nh : Quiver.Hom S.leftHomology Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp h✝.π (CategoryTheory.CategoryStruct.comp h✝.leftHomologyIso.inv h)) (CategoryTheory.CategoryStruct.comp h✝.cyclesIso.inv (CategoryTheory.CategoryStruct.comp S.leftHomologyπ h))","decl":"@[reassoc (attr := simp)]\nlemma π_comp_leftHomologyIso_inv :\n    h.π ≫ h.leftHomologyIso.inv = h.cyclesIso.inv ≫ S.leftHomologyπ := by\n  simp only [← cancel_epi h.cyclesIso.hom, ← cancel_mono h.leftHomologyIso.hom, assoc,\n    Iso.inv_hom_id, comp_id, Iso.hom_inv_id_assoc,\n    LeftHomologyData.leftHomologyπ_comp_leftHomologyIso_hom]\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyMapData.leftHomologyMap_eq","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_2, u_1} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nh₁ : S₁.LeftHomologyData\nh₂ : S₂.LeftHomologyData\nγ : CategoryTheory.ShortComplex.LeftHomologyMapData φ h₁ h₂\ninst✝¹ : S₁.HasLeftHomology\ninst✝ : S₂.HasLeftHomology\n⊢ Eq (CategoryTheory.ShortComplex.leftHomologyMap φ) (CategoryTheory.CategoryStruct.comp h₁.leftHomologyIso.hom (CategoryTheory.CategoryStruct.comp γ.φH h₂.leftHomologyIso.inv))","decl":"lemma leftHomologyMap_eq [S₁.HasLeftHomology] [S₂.HasLeftHomology] :\n    leftHomologyMap φ = h₁.leftHomologyIso.hom ≫ γ.φH ≫ h₂.leftHomologyIso.inv := by\n  dsimp [LeftHomologyData.leftHomologyIso, leftHomologyMapIso']\n  rw [← γ.leftHomologyMap'_eq, ← leftHomologyMap'_comp,\n    ← leftHomologyMap'_comp, id_comp, comp_id]\n  rfl\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyMapData.cyclesMap_eq","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_2, u_1} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nh₁ : S₁.LeftHomologyData\nh₂ : S₂.LeftHomologyData\nγ : CategoryTheory.ShortComplex.LeftHomologyMapData φ h₁ h₂\ninst✝¹ : S₁.HasLeftHomology\ninst✝ : S₂.HasLeftHomology\n⊢ Eq (CategoryTheory.ShortComplex.cyclesMap φ) (CategoryTheory.CategoryStruct.comp h₁.cyclesIso.hom (CategoryTheory.CategoryStruct.comp γ.φK h₂.cyclesIso.inv))","decl":"lemma cyclesMap_eq [S₁.HasLeftHomology] [S₂.HasLeftHomology] :\n    cyclesMap φ = h₁.cyclesIso.hom ≫ γ.φK ≫ h₂.cyclesIso.inv := by\n  dsimp [LeftHomologyData.cyclesIso, cyclesMapIso']\n  rw [← γ.cyclesMap'_eq, ← cyclesMap'_comp, ← cyclesMap'_comp, id_comp, comp_id]\n  rfl\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyMapData.leftHomologyMap_comm","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_2, u_1} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nh₁ : S₁.LeftHomologyData\nh₂ : S₂.LeftHomologyData\nγ : CategoryTheory.ShortComplex.LeftHomologyMapData φ h₁ h₂\ninst✝¹ : S₁.HasLeftHomology\ninst✝ : S₂.HasLeftHomology\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.leftHomologyMap φ) h₂.leftHomologyIso.hom) (CategoryTheory.CategoryStruct.comp h₁.leftHomologyIso.hom γ.φH)","decl":"lemma leftHomologyMap_comm [S₁.HasLeftHomology] [S₂.HasLeftHomology] :\n    leftHomologyMap φ ≫ h₂.leftHomologyIso.hom = h₁.leftHomologyIso.hom ≫ γ.φH := by\n  simp only [γ.leftHomologyMap_eq, assoc, Iso.inv_hom_id, comp_id]\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyMapData.cyclesMap_comm","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_2, u_1} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nh₁ : S₁.LeftHomologyData\nh₂ : S₂.LeftHomologyData\nγ : CategoryTheory.ShortComplex.LeftHomologyMapData φ h₁ h₂\ninst✝¹ : S₁.HasLeftHomology\ninst✝ : S₂.HasLeftHomology\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.cyclesMap φ) h₂.cyclesIso.hom) (CategoryTheory.CategoryStruct.comp h₁.cyclesIso.hom γ.φK)","decl":"lemma cyclesMap_comm [S₁.HasLeftHomology] [S₂.HasLeftHomology] :\n    cyclesMap φ ≫ h₂.cyclesIso.hom = h₁.cyclesIso.hom ≫ γ.φK := by\n  simp only [γ.cyclesMap_eq, assoc, Iso.inv_hom_id, comp_id]\n\n"}
{"name":"CategoryTheory.ShortComplex.leftHomologyFunctor_obj","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_2, u_1} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝¹ : CategoryTheory.Limits.HasKernels C\ninst✝ : CategoryTheory.Limits.HasCokernels C\nS : CategoryTheory.ShortComplex C\n⊢ Eq ((CategoryTheory.ShortComplex.leftHomologyFunctor C).obj S) S.leftHomology","decl":"/-- The left homology functor `ShortComplex C ⥤ C`, where the left homology of a\nshort complex `S` is understood as a cokernel of the obvious map `S.toCycles : S.X₁ ⟶ S.cycles`\nwhere `S.cycles` is a kernel of `S.g : S.X₂ ⟶ S.X₃`. -/\n@[simps]\nnoncomputable def leftHomologyFunctor : ShortComplex C ⥤ C where\n  obj S := S.leftHomology\n  map := leftHomologyMap\n\n"}
{"name":"CategoryTheory.ShortComplex.leftHomologyFunctor_map","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_2, u_1} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝¹ : CategoryTheory.Limits.HasKernels C\ninst✝ : CategoryTheory.Limits.HasCokernels C\nX✝ Y✝ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom X✝ Y✝\n⊢ Eq ((CategoryTheory.ShortComplex.leftHomologyFunctor C).map φ) (CategoryTheory.ShortComplex.leftHomologyMap φ)","decl":"/-- The left homology functor `ShortComplex C ⥤ C`, where the left homology of a\nshort complex `S` is understood as a cokernel of the obvious map `S.toCycles : S.X₁ ⟶ S.cycles`\nwhere `S.cycles` is a kernel of `S.g : S.X₂ ⟶ S.X₃`. -/\n@[simps]\nnoncomputable def leftHomologyFunctor : ShortComplex C ⥤ C where\n  obj S := S.leftHomology\n  map := leftHomologyMap\n\n"}
{"name":"CategoryTheory.ShortComplex.cyclesFunctor_obj","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_2, u_1} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝¹ : CategoryTheory.Limits.HasKernels C\ninst✝ : CategoryTheory.Limits.HasCokernels C\nS : CategoryTheory.ShortComplex C\n⊢ Eq ((CategoryTheory.ShortComplex.cyclesFunctor C).obj S) S.cycles","decl":"/-- The cycles functor `ShortComplex C ⥤ C` which sends a short complex `S` to `S.cycles`\nwhich is a kernel of `S.g : S.X₂ ⟶ S.X₃`. -/\n@[simps]\nnoncomputable def cyclesFunctor : ShortComplex C ⥤ C where\n  obj S := S.cycles\n  map := cyclesMap\n\n"}
{"name":"CategoryTheory.ShortComplex.cyclesFunctor_map","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_2, u_1} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝¹ : CategoryTheory.Limits.HasKernels C\ninst✝ : CategoryTheory.Limits.HasCokernels C\nX✝ Y✝ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom X✝ Y✝\n⊢ Eq ((CategoryTheory.ShortComplex.cyclesFunctor C).map φ) (CategoryTheory.ShortComplex.cyclesMap φ)","decl":"/-- The cycles functor `ShortComplex C ⥤ C` which sends a short complex `S` to `S.cycles`\nwhich is a kernel of `S.g : S.X₂ ⟶ S.X₃`. -/\n@[simps]\nnoncomputable def cyclesFunctor : ShortComplex C ⥤ C where\n  obj S := S.cycles\n  map := cyclesMap\n\n"}
{"name":"CategoryTheory.ShortComplex.leftHomologyπNatTrans_app","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_2, u_1} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝¹ : CategoryTheory.Limits.HasKernels C\ninst✝ : CategoryTheory.Limits.HasCokernels C\nS : CategoryTheory.ShortComplex C\n⊢ Eq ((CategoryTheory.ShortComplex.leftHomologyπNatTrans C).app S) S.leftHomologyπ","decl":"/-- The natural transformation `S.cycles ⟶ S.leftHomology` for all short complexes `S`. -/\n@[simps]\nnoncomputable def leftHomologyπNatTrans : cyclesFunctor C ⟶ leftHomologyFunctor C where\n  app S := leftHomologyπ S\n  naturality := fun _ _ φ => (leftHomologyπ_naturality φ).symm\n\n"}
{"name":"CategoryTheory.ShortComplex.iCyclesNatTrans_app","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_2, u_1} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝¹ : CategoryTheory.Limits.HasKernels C\ninst✝ : CategoryTheory.Limits.HasCokernels C\nS : CategoryTheory.ShortComplex C\n⊢ Eq ((CategoryTheory.ShortComplex.iCyclesNatTrans C).app S) S.iCycles","decl":"/-- The natural transformation `S.cycles ⟶ S.X₂` for all short complexes `S`. -/\n@[simps]\nnoncomputable def iCyclesNatTrans : cyclesFunctor C ⟶ ShortComplex.π₂ where\n  app S := S.iCycles\n\n"}
{"name":"CategoryTheory.ShortComplex.toCyclesNatTrans_app","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_2, u_1} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝¹ : CategoryTheory.Limits.HasKernels C\ninst✝ : CategoryTheory.Limits.HasCokernels C\nS : CategoryTheory.ShortComplex C\n⊢ Eq ((CategoryTheory.ShortComplex.toCyclesNatTrans C).app S) S.toCycles","decl":"/-- The natural transformation `S.X₁ ⟶ S.cycles` for all short complexes `S`. -/\n@[simps]\nnoncomputable def toCyclesNatTrans :\n    π₁ ⟶ cyclesFunctor C where\n  app S := S.toCycles\n  naturality := fun _ _ φ => (toCycles_naturality φ).symm\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.ofEpiOfIsIsoOfMono_K","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_2, u_1} C\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nh : S₁.LeftHomologyData\ninst✝² : CategoryTheory.Epi φ.τ₁\ninst✝¹ : CategoryTheory.IsIso φ.τ₂\ninst✝ : CategoryTheory.Mono φ.τ₃\n⊢ Eq (CategoryTheory.ShortComplex.LeftHomologyData.ofEpiOfIsIsoOfMono φ h).K h.K","decl":"/-- If `φ : S₁ ⟶ S₂` is a morphism of short complexes such that `φ.τ₁` is epi, `φ.τ₂` is an iso\nand `φ.τ₃` is mono, then a left homology data for `S₁` induces a left homology data for `S₂` with\nthe same `K` and `H` fields. The inverse construction is `ofEpiOfIsIsoOfMono'`. -/\n@[simps]\nnoncomputable def ofEpiOfIsIsoOfMono (φ : S₁ ⟶ S₂) (h : LeftHomologyData S₁)\n    [Epi φ.τ₁] [IsIso φ.τ₂] [Mono φ.τ₃] : LeftHomologyData S₂ := by\n  let i : h.K ⟶ S₂.X₂ := h.i ≫ φ.τ₂\n  have wi : i ≫ S₂.g = 0 := by simp only [i, assoc, φ.comm₂₃, h.wi_assoc, zero_comp]\n  have hi : IsLimit (KernelFork.ofι i wi) := KernelFork.IsLimit.ofι _ _\n    (fun x hx => h.liftK (x ≫ inv φ.τ₂) (by rw [assoc, ← cancel_mono φ.τ₃, assoc,\n      assoc, ← φ.comm₂₃, IsIso.inv_hom_id_assoc, hx, zero_comp]))\n    (fun x hx => by simp [i]) (fun x hx b hb => by\n      dsimp\n      rw [← cancel_mono h.i, ← cancel_mono φ.τ₂, assoc, assoc, liftK_i_assoc,\n        assoc, IsIso.inv_hom_id, comp_id, hb])\n  let f' := hi.lift (KernelFork.ofι S₂.f S₂.zero)\n  have hf' : φ.τ₁ ≫ f' = h.f' := by\n    have eq := @Fork.IsLimit.lift_ι _ _ _ _ _ _ _ ((KernelFork.ofι S₂.f S₂.zero)) hi\n    simp only [Fork.ι_ofι] at eq\n    rw [← cancel_mono h.i, ← cancel_mono φ.τ₂, assoc, assoc, eq, f'_i, φ.comm₁₂]\n  have wπ : f' ≫ h.π = 0 := by\n    rw [← cancel_epi φ.τ₁, comp_zero, reassoc_of% hf', h.f'_π]\n  have hπ : IsColimit (CokernelCofork.ofπ h.π wπ) := CokernelCofork.IsColimit.ofπ _ _\n    (fun x hx => h.descH x (by rw [← hf', assoc, hx, comp_zero]))\n    (fun x hx => by simp) (fun x hx b hb => by rw [← cancel_epi h.π, π_descH, hb])\n  exact ⟨h.K, h.H, i, h.π, wi, hi, wπ, hπ⟩\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.ofEpiOfIsIsoOfMono_H","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_2, u_1} C\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nh : S₁.LeftHomologyData\ninst✝² : CategoryTheory.Epi φ.τ₁\ninst✝¹ : CategoryTheory.IsIso φ.τ₂\ninst✝ : CategoryTheory.Mono φ.τ₃\n⊢ Eq (CategoryTheory.ShortComplex.LeftHomologyData.ofEpiOfIsIsoOfMono φ h).H h.H","decl":"/-- If `φ : S₁ ⟶ S₂` is a morphism of short complexes such that `φ.τ₁` is epi, `φ.τ₂` is an iso\nand `φ.τ₃` is mono, then a left homology data for `S₁` induces a left homology data for `S₂` with\nthe same `K` and `H` fields. The inverse construction is `ofEpiOfIsIsoOfMono'`. -/\n@[simps]\nnoncomputable def ofEpiOfIsIsoOfMono (φ : S₁ ⟶ S₂) (h : LeftHomologyData S₁)\n    [Epi φ.τ₁] [IsIso φ.τ₂] [Mono φ.τ₃] : LeftHomologyData S₂ := by\n  let i : h.K ⟶ S₂.X₂ := h.i ≫ φ.τ₂\n  have wi : i ≫ S₂.g = 0 := by simp only [i, assoc, φ.comm₂₃, h.wi_assoc, zero_comp]\n  have hi : IsLimit (KernelFork.ofι i wi) := KernelFork.IsLimit.ofι _ _\n    (fun x hx => h.liftK (x ≫ inv φ.τ₂) (by rw [assoc, ← cancel_mono φ.τ₃, assoc,\n      assoc, ← φ.comm₂₃, IsIso.inv_hom_id_assoc, hx, zero_comp]))\n    (fun x hx => by simp [i]) (fun x hx b hb => by\n      dsimp\n      rw [← cancel_mono h.i, ← cancel_mono φ.τ₂, assoc, assoc, liftK_i_assoc,\n        assoc, IsIso.inv_hom_id, comp_id, hb])\n  let f' := hi.lift (KernelFork.ofι S₂.f S₂.zero)\n  have hf' : φ.τ₁ ≫ f' = h.f' := by\n    have eq := @Fork.IsLimit.lift_ι _ _ _ _ _ _ _ ((KernelFork.ofι S₂.f S₂.zero)) hi\n    simp only [Fork.ι_ofι] at eq\n    rw [← cancel_mono h.i, ← cancel_mono φ.τ₂, assoc, assoc, eq, f'_i, φ.comm₁₂]\n  have wπ : f' ≫ h.π = 0 := by\n    rw [← cancel_epi φ.τ₁, comp_zero, reassoc_of% hf', h.f'_π]\n  have hπ : IsColimit (CokernelCofork.ofπ h.π wπ) := CokernelCofork.IsColimit.ofπ _ _\n    (fun x hx => h.descH x (by rw [← hf', assoc, hx, comp_zero]))\n    (fun x hx => by simp) (fun x hx b hb => by rw [← cancel_epi h.π, π_descH, hb])\n  exact ⟨h.K, h.H, i, h.π, wi, hi, wπ, hπ⟩\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.ofEpiOfIsIsoOfMono_i","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_2, u_1} C\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nh : S₁.LeftHomologyData\ninst✝² : CategoryTheory.Epi φ.τ₁\ninst✝¹ : CategoryTheory.IsIso φ.τ₂\ninst✝ : CategoryTheory.Mono φ.τ₃\n⊢ Eq (CategoryTheory.ShortComplex.LeftHomologyData.ofEpiOfIsIsoOfMono φ h).i (CategoryTheory.CategoryStruct.comp h.i φ.τ₂)","decl":"/-- If `φ : S₁ ⟶ S₂` is a morphism of short complexes such that `φ.τ₁` is epi, `φ.τ₂` is an iso\nand `φ.τ₃` is mono, then a left homology data for `S₁` induces a left homology data for `S₂` with\nthe same `K` and `H` fields. The inverse construction is `ofEpiOfIsIsoOfMono'`. -/\n@[simps]\nnoncomputable def ofEpiOfIsIsoOfMono (φ : S₁ ⟶ S₂) (h : LeftHomologyData S₁)\n    [Epi φ.τ₁] [IsIso φ.τ₂] [Mono φ.τ₃] : LeftHomologyData S₂ := by\n  let i : h.K ⟶ S₂.X₂ := h.i ≫ φ.τ₂\n  have wi : i ≫ S₂.g = 0 := by simp only [i, assoc, φ.comm₂₃, h.wi_assoc, zero_comp]\n  have hi : IsLimit (KernelFork.ofι i wi) := KernelFork.IsLimit.ofι _ _\n    (fun x hx => h.liftK (x ≫ inv φ.τ₂) (by rw [assoc, ← cancel_mono φ.τ₃, assoc,\n      assoc, ← φ.comm₂₃, IsIso.inv_hom_id_assoc, hx, zero_comp]))\n    (fun x hx => by simp [i]) (fun x hx b hb => by\n      dsimp\n      rw [← cancel_mono h.i, ← cancel_mono φ.τ₂, assoc, assoc, liftK_i_assoc,\n        assoc, IsIso.inv_hom_id, comp_id, hb])\n  let f' := hi.lift (KernelFork.ofι S₂.f S₂.zero)\n  have hf' : φ.τ₁ ≫ f' = h.f' := by\n    have eq := @Fork.IsLimit.lift_ι _ _ _ _ _ _ _ ((KernelFork.ofι S₂.f S₂.zero)) hi\n    simp only [Fork.ι_ofι] at eq\n    rw [← cancel_mono h.i, ← cancel_mono φ.τ₂, assoc, assoc, eq, f'_i, φ.comm₁₂]\n  have wπ : f' ≫ h.π = 0 := by\n    rw [← cancel_epi φ.τ₁, comp_zero, reassoc_of% hf', h.f'_π]\n  have hπ : IsColimit (CokernelCofork.ofπ h.π wπ) := CokernelCofork.IsColimit.ofπ _ _\n    (fun x hx => h.descH x (by rw [← hf', assoc, hx, comp_zero]))\n    (fun x hx => by simp) (fun x hx b hb => by rw [← cancel_epi h.π, π_descH, hb])\n  exact ⟨h.K, h.H, i, h.π, wi, hi, wπ, hπ⟩\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.ofEpiOfIsIsoOfMono_π","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_2, u_1} C\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nh : S₁.LeftHomologyData\ninst✝² : CategoryTheory.Epi φ.τ₁\ninst✝¹ : CategoryTheory.IsIso φ.τ₂\ninst✝ : CategoryTheory.Mono φ.τ₃\n⊢ Eq (CategoryTheory.ShortComplex.LeftHomologyData.ofEpiOfIsIsoOfMono φ h).π h.π","decl":"/-- If `φ : S₁ ⟶ S₂` is a morphism of short complexes such that `φ.τ₁` is epi, `φ.τ₂` is an iso\nand `φ.τ₃` is mono, then a left homology data for `S₁` induces a left homology data for `S₂` with\nthe same `K` and `H` fields. The inverse construction is `ofEpiOfIsIsoOfMono'`. -/\n@[simps]\nnoncomputable def ofEpiOfIsIsoOfMono (φ : S₁ ⟶ S₂) (h : LeftHomologyData S₁)\n    [Epi φ.τ₁] [IsIso φ.τ₂] [Mono φ.τ₃] : LeftHomologyData S₂ := by\n  let i : h.K ⟶ S₂.X₂ := h.i ≫ φ.τ₂\n  have wi : i ≫ S₂.g = 0 := by simp only [i, assoc, φ.comm₂₃, h.wi_assoc, zero_comp]\n  have hi : IsLimit (KernelFork.ofι i wi) := KernelFork.IsLimit.ofι _ _\n    (fun x hx => h.liftK (x ≫ inv φ.τ₂) (by rw [assoc, ← cancel_mono φ.τ₃, assoc,\n      assoc, ← φ.comm₂₃, IsIso.inv_hom_id_assoc, hx, zero_comp]))\n    (fun x hx => by simp [i]) (fun x hx b hb => by\n      dsimp\n      rw [← cancel_mono h.i, ← cancel_mono φ.τ₂, assoc, assoc, liftK_i_assoc,\n        assoc, IsIso.inv_hom_id, comp_id, hb])\n  let f' := hi.lift (KernelFork.ofι S₂.f S₂.zero)\n  have hf' : φ.τ₁ ≫ f' = h.f' := by\n    have eq := @Fork.IsLimit.lift_ι _ _ _ _ _ _ _ ((KernelFork.ofι S₂.f S₂.zero)) hi\n    simp only [Fork.ι_ofι] at eq\n    rw [← cancel_mono h.i, ← cancel_mono φ.τ₂, assoc, assoc, eq, f'_i, φ.comm₁₂]\n  have wπ : f' ≫ h.π = 0 := by\n    rw [← cancel_epi φ.τ₁, comp_zero, reassoc_of% hf', h.f'_π]\n  have hπ : IsColimit (CokernelCofork.ofπ h.π wπ) := CokernelCofork.IsColimit.ofπ _ _\n    (fun x hx => h.descH x (by rw [← hf', assoc, hx, comp_zero]))\n    (fun x hx => by simp) (fun x hx b hb => by rw [← cancel_epi h.π, π_descH, hb])\n  exact ⟨h.K, h.H, i, h.π, wi, hi, wπ, hπ⟩\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.τ₁_ofEpiOfIsIsoOfMono_f'","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_2, u_1} C\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nh : S₁.LeftHomologyData\ninst✝² : CategoryTheory.Epi φ.τ₁\ninst✝¹ : CategoryTheory.IsIso φ.τ₂\ninst✝ : CategoryTheory.Mono φ.τ₃\n⊢ Eq (CategoryTheory.CategoryStruct.comp φ.τ₁ (CategoryTheory.ShortComplex.LeftHomologyData.ofEpiOfIsIsoOfMono φ h).f') h.f'","decl":"@[simp]\nlemma τ₁_ofEpiOfIsIsoOfMono_f' (φ : S₁ ⟶ S₂) (h : LeftHomologyData S₁)\n    [Epi φ.τ₁] [IsIso φ.τ₂] [Mono φ.τ₃] : φ.τ₁ ≫ (ofEpiOfIsIsoOfMono φ h).f' = h.f' := by\n  rw [← cancel_mono (ofEpiOfIsIsoOfMono φ h).i, assoc, f'_i,\n    ofEpiOfIsIsoOfMono_i, f'_i_assoc, φ.comm₁₂]\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.ofEpiOfIsIsoOfMono'_π","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_2, u_1} C\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nh : S₂.LeftHomologyData\ninst✝² : CategoryTheory.Epi φ.τ₁\ninst✝¹ : CategoryTheory.IsIso φ.τ₂\ninst✝ : CategoryTheory.Mono φ.τ₃\n⊢ Eq (CategoryTheory.ShortComplex.LeftHomologyData.ofEpiOfIsIsoOfMono' φ h).π h.π","decl":"/-- If `φ : S₁ ⟶ S₂` is a morphism of short complexes such that `φ.τ₁` is epi, `φ.τ₂` is an iso\nand `φ.τ₃` is mono, then a left homology data for `S₂` induces a left homology data for `S₁` with\nthe same `K` and `H` fields. The inverse construction is `ofEpiOfIsIsoOfMono`. -/\n@[simps]\nnoncomputable def ofEpiOfIsIsoOfMono' (φ : S₁ ⟶ S₂) (h : LeftHomologyData S₂)\n    [Epi φ.τ₁] [IsIso φ.τ₂] [Mono φ.τ₃] : LeftHomologyData S₁ := by\n  let i : h.K ⟶ S₁.X₂ := h.i ≫ inv φ.τ₂\n  have wi : i ≫ S₁.g = 0 := by\n    rw [assoc, ← cancel_mono φ.τ₃, zero_comp, assoc, assoc, ← φ.comm₂₃,\n      IsIso.inv_hom_id_assoc, h.wi]\n  have hi : IsLimit (KernelFork.ofι i wi) := KernelFork.IsLimit.ofι _ _\n    (fun x hx => h.liftK (x ≫ φ.τ₂)\n      (by rw [assoc, φ.comm₂₃, reassoc_of% hx, zero_comp]))\n    (fun x hx => by simp [i])\n    (fun x hx b hb => by rw [← cancel_mono h.i, ← cancel_mono (inv φ.τ₂), assoc, assoc,\n      hb, liftK_i_assoc, assoc, IsIso.hom_inv_id, comp_id])\n  let f' := hi.lift (KernelFork.ofι S₁.f S₁.zero)\n  have hf' : f' ≫ i = S₁.f := Fork.IsLimit.lift_ι _\n  have hf'' : f' = φ.τ₁ ≫ h.f' := by\n    rw [← cancel_mono h.i, ← cancel_mono (inv φ.τ₂), assoc, assoc, assoc, hf', f'_i_assoc,\n      φ.comm₁₂_assoc, IsIso.hom_inv_id, comp_id]\n  have wπ : f' ≫ h.π = 0 := by simp only [hf'', assoc, f'_π, comp_zero]\n  have hπ : IsColimit (CokernelCofork.ofπ h.π wπ) := CokernelCofork.IsColimit.ofπ _ _\n    (fun x hx => h.descH x (by rw [← cancel_epi φ.τ₁, ← reassoc_of% hf'', hx, comp_zero]))\n    (fun x hx => π_descH _ _ _)\n    (fun x hx b hx => by rw [← cancel_epi h.π, π_descH, hx])\n  exact ⟨h.K, h.H, i, h.π, wi, hi, wπ, hπ⟩\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.ofEpiOfIsIsoOfMono'_K","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_2, u_1} C\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nh : S₂.LeftHomologyData\ninst✝² : CategoryTheory.Epi φ.τ₁\ninst✝¹ : CategoryTheory.IsIso φ.τ₂\ninst✝ : CategoryTheory.Mono φ.τ₃\n⊢ Eq (CategoryTheory.ShortComplex.LeftHomologyData.ofEpiOfIsIsoOfMono' φ h).K h.K","decl":"/-- If `φ : S₁ ⟶ S₂` is a morphism of short complexes such that `φ.τ₁` is epi, `φ.τ₂` is an iso\nand `φ.τ₃` is mono, then a left homology data for `S₂` induces a left homology data for `S₁` with\nthe same `K` and `H` fields. The inverse construction is `ofEpiOfIsIsoOfMono`. -/\n@[simps]\nnoncomputable def ofEpiOfIsIsoOfMono' (φ : S₁ ⟶ S₂) (h : LeftHomologyData S₂)\n    [Epi φ.τ₁] [IsIso φ.τ₂] [Mono φ.τ₃] : LeftHomologyData S₁ := by\n  let i : h.K ⟶ S₁.X₂ := h.i ≫ inv φ.τ₂\n  have wi : i ≫ S₁.g = 0 := by\n    rw [assoc, ← cancel_mono φ.τ₃, zero_comp, assoc, assoc, ← φ.comm₂₃,\n      IsIso.inv_hom_id_assoc, h.wi]\n  have hi : IsLimit (KernelFork.ofι i wi) := KernelFork.IsLimit.ofι _ _\n    (fun x hx => h.liftK (x ≫ φ.τ₂)\n      (by rw [assoc, φ.comm₂₃, reassoc_of% hx, zero_comp]))\n    (fun x hx => by simp [i])\n    (fun x hx b hb => by rw [← cancel_mono h.i, ← cancel_mono (inv φ.τ₂), assoc, assoc,\n      hb, liftK_i_assoc, assoc, IsIso.hom_inv_id, comp_id])\n  let f' := hi.lift (KernelFork.ofι S₁.f S₁.zero)\n  have hf' : f' ≫ i = S₁.f := Fork.IsLimit.lift_ι _\n  have hf'' : f' = φ.τ₁ ≫ h.f' := by\n    rw [← cancel_mono h.i, ← cancel_mono (inv φ.τ₂), assoc, assoc, assoc, hf', f'_i_assoc,\n      φ.comm₁₂_assoc, IsIso.hom_inv_id, comp_id]\n  have wπ : f' ≫ h.π = 0 := by simp only [hf'', assoc, f'_π, comp_zero]\n  have hπ : IsColimit (CokernelCofork.ofπ h.π wπ) := CokernelCofork.IsColimit.ofπ _ _\n    (fun x hx => h.descH x (by rw [← cancel_epi φ.τ₁, ← reassoc_of% hf'', hx, comp_zero]))\n    (fun x hx => π_descH _ _ _)\n    (fun x hx b hx => by rw [← cancel_epi h.π, π_descH, hx])\n  exact ⟨h.K, h.H, i, h.π, wi, hi, wπ, hπ⟩\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.ofEpiOfIsIsoOfMono'_H","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_2, u_1} C\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nh : S₂.LeftHomologyData\ninst✝² : CategoryTheory.Epi φ.τ₁\ninst✝¹ : CategoryTheory.IsIso φ.τ₂\ninst✝ : CategoryTheory.Mono φ.τ₃\n⊢ Eq (CategoryTheory.ShortComplex.LeftHomologyData.ofEpiOfIsIsoOfMono' φ h).H h.H","decl":"/-- If `φ : S₁ ⟶ S₂` is a morphism of short complexes such that `φ.τ₁` is epi, `φ.τ₂` is an iso\nand `φ.τ₃` is mono, then a left homology data for `S₂` induces a left homology data for `S₁` with\nthe same `K` and `H` fields. The inverse construction is `ofEpiOfIsIsoOfMono`. -/\n@[simps]\nnoncomputable def ofEpiOfIsIsoOfMono' (φ : S₁ ⟶ S₂) (h : LeftHomologyData S₂)\n    [Epi φ.τ₁] [IsIso φ.τ₂] [Mono φ.τ₃] : LeftHomologyData S₁ := by\n  let i : h.K ⟶ S₁.X₂ := h.i ≫ inv φ.τ₂\n  have wi : i ≫ S₁.g = 0 := by\n    rw [assoc, ← cancel_mono φ.τ₃, zero_comp, assoc, assoc, ← φ.comm₂₃,\n      IsIso.inv_hom_id_assoc, h.wi]\n  have hi : IsLimit (KernelFork.ofι i wi) := KernelFork.IsLimit.ofι _ _\n    (fun x hx => h.liftK (x ≫ φ.τ₂)\n      (by rw [assoc, φ.comm₂₃, reassoc_of% hx, zero_comp]))\n    (fun x hx => by simp [i])\n    (fun x hx b hb => by rw [← cancel_mono h.i, ← cancel_mono (inv φ.τ₂), assoc, assoc,\n      hb, liftK_i_assoc, assoc, IsIso.hom_inv_id, comp_id])\n  let f' := hi.lift (KernelFork.ofι S₁.f S₁.zero)\n  have hf' : f' ≫ i = S₁.f := Fork.IsLimit.lift_ι _\n  have hf'' : f' = φ.τ₁ ≫ h.f' := by\n    rw [← cancel_mono h.i, ← cancel_mono (inv φ.τ₂), assoc, assoc, assoc, hf', f'_i_assoc,\n      φ.comm₁₂_assoc, IsIso.hom_inv_id, comp_id]\n  have wπ : f' ≫ h.π = 0 := by simp only [hf'', assoc, f'_π, comp_zero]\n  have hπ : IsColimit (CokernelCofork.ofπ h.π wπ) := CokernelCofork.IsColimit.ofπ _ _\n    (fun x hx => h.descH x (by rw [← cancel_epi φ.τ₁, ← reassoc_of% hf'', hx, comp_zero]))\n    (fun x hx => π_descH _ _ _)\n    (fun x hx b hx => by rw [← cancel_epi h.π, π_descH, hx])\n  exact ⟨h.K, h.H, i, h.π, wi, hi, wπ, hπ⟩\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.ofEpiOfIsIsoOfMono'_i","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_2, u_1} C\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nh : S₂.LeftHomologyData\ninst✝² : CategoryTheory.Epi φ.τ₁\ninst✝¹ : CategoryTheory.IsIso φ.τ₂\ninst✝ : CategoryTheory.Mono φ.τ₃\n⊢ Eq (CategoryTheory.ShortComplex.LeftHomologyData.ofEpiOfIsIsoOfMono' φ h).i (CategoryTheory.CategoryStruct.comp h.i (CategoryTheory.inv φ.τ₂))","decl":"/-- If `φ : S₁ ⟶ S₂` is a morphism of short complexes such that `φ.τ₁` is epi, `φ.τ₂` is an iso\nand `φ.τ₃` is mono, then a left homology data for `S₂` induces a left homology data for `S₁` with\nthe same `K` and `H` fields. The inverse construction is `ofEpiOfIsIsoOfMono`. -/\n@[simps]\nnoncomputable def ofEpiOfIsIsoOfMono' (φ : S₁ ⟶ S₂) (h : LeftHomologyData S₂)\n    [Epi φ.τ₁] [IsIso φ.τ₂] [Mono φ.τ₃] : LeftHomologyData S₁ := by\n  let i : h.K ⟶ S₁.X₂ := h.i ≫ inv φ.τ₂\n  have wi : i ≫ S₁.g = 0 := by\n    rw [assoc, ← cancel_mono φ.τ₃, zero_comp, assoc, assoc, ← φ.comm₂₃,\n      IsIso.inv_hom_id_assoc, h.wi]\n  have hi : IsLimit (KernelFork.ofι i wi) := KernelFork.IsLimit.ofι _ _\n    (fun x hx => h.liftK (x ≫ φ.τ₂)\n      (by rw [assoc, φ.comm₂₃, reassoc_of% hx, zero_comp]))\n    (fun x hx => by simp [i])\n    (fun x hx b hb => by rw [← cancel_mono h.i, ← cancel_mono (inv φ.τ₂), assoc, assoc,\n      hb, liftK_i_assoc, assoc, IsIso.hom_inv_id, comp_id])\n  let f' := hi.lift (KernelFork.ofι S₁.f S₁.zero)\n  have hf' : f' ≫ i = S₁.f := Fork.IsLimit.lift_ι _\n  have hf'' : f' = φ.τ₁ ≫ h.f' := by\n    rw [← cancel_mono h.i, ← cancel_mono (inv φ.τ₂), assoc, assoc, assoc, hf', f'_i_assoc,\n      φ.comm₁₂_assoc, IsIso.hom_inv_id, comp_id]\n  have wπ : f' ≫ h.π = 0 := by simp only [hf'', assoc, f'_π, comp_zero]\n  have hπ : IsColimit (CokernelCofork.ofπ h.π wπ) := CokernelCofork.IsColimit.ofπ _ _\n    (fun x hx => h.descH x (by rw [← cancel_epi φ.τ₁, ← reassoc_of% hf'', hx, comp_zero]))\n    (fun x hx => π_descH _ _ _)\n    (fun x hx b hx => by rw [← cancel_epi h.π, π_descH, hx])\n  exact ⟨h.K, h.H, i, h.π, wi, hi, wπ, hπ⟩\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.ofEpiOfIsIsoOfMono'_f'","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_2, u_1} C\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nh : S₂.LeftHomologyData\ninst✝² : CategoryTheory.Epi φ.τ₁\ninst✝¹ : CategoryTheory.IsIso φ.τ₂\ninst✝ : CategoryTheory.Mono φ.τ₃\n⊢ Eq (CategoryTheory.ShortComplex.LeftHomologyData.ofEpiOfIsIsoOfMono' φ h).f' (CategoryTheory.CategoryStruct.comp φ.τ₁ h.f')","decl":"@[simp]\nlemma ofEpiOfIsIsoOfMono'_f' (φ : S₁ ⟶ S₂) (h : LeftHomologyData S₂)\n    [Epi φ.τ₁] [IsIso φ.τ₂] [Mono φ.τ₃] : (ofEpiOfIsIsoOfMono' φ h).f' = φ.τ₁ ≫ h.f' := by\n  rw [← cancel_mono (ofEpiOfIsIsoOfMono' φ h).i, f'_i, ofEpiOfIsIsoOfMono'_i,\n    assoc, f'_i_assoc, φ.comm₁₂_assoc, IsIso.hom_inv_id, comp_id]\n\n"}
{"name":"CategoryTheory.ShortComplex.hasLeftHomology_of_epi_of_isIso_of_mono","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝⁵ : CategoryTheory.Category.{u_2, u_1} C\ninst✝⁴ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\ninst✝³ : S₁.HasLeftHomology\ninst✝² : CategoryTheory.Epi φ.τ₁\ninst✝¹ : CategoryTheory.IsIso φ.τ₂\ninst✝ : CategoryTheory.Mono φ.τ₃\n⊢ S₂.HasLeftHomology","decl":"lemma hasLeftHomology_of_epi_of_isIso_of_mono (φ : S₁ ⟶ S₂) [HasLeftHomology S₁]\n    [Epi φ.τ₁] [IsIso φ.τ₂] [Mono φ.τ₃] : HasLeftHomology S₂ :=\n  HasLeftHomology.mk' (LeftHomologyData.ofEpiOfIsIsoOfMono φ S₁.leftHomologyData)\n\n"}
{"name":"CategoryTheory.ShortComplex.hasLeftHomology_of_epi_of_isIso_of_mono'","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝⁵ : CategoryTheory.Category.{u_2, u_1} C\ninst✝⁴ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\ninst✝³ : S₂.HasLeftHomology\ninst✝² : CategoryTheory.Epi φ.τ₁\ninst✝¹ : CategoryTheory.IsIso φ.τ₂\ninst✝ : CategoryTheory.Mono φ.τ₃\n⊢ S₁.HasLeftHomology","decl":"lemma hasLeftHomology_of_epi_of_isIso_of_mono' (φ : S₁ ⟶ S₂) [HasLeftHomology S₂]\n    [Epi φ.τ₁] [IsIso φ.τ₂] [Mono φ.τ₃] : HasLeftHomology S₁ :=\n  HasLeftHomology.mk' (LeftHomologyData.ofEpiOfIsIsoOfMono' φ S₂.leftHomologyData)\n\n"}
{"name":"CategoryTheory.ShortComplex.hasLeftHomology_of_iso","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\ne : CategoryTheory.Iso S₁ S₂\ninst✝ : S₁.HasLeftHomology\n⊢ S₂.HasLeftHomology","decl":"lemma hasLeftHomology_of_iso {S₁ S₂ : ShortComplex C} (e : S₁ ≅ S₂) [HasLeftHomology S₁] :\n    HasLeftHomology S₂ :=\n  hasLeftHomology_of_epi_of_isIso_of_mono e.hom\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyMapData.ofEpiOfIsIsoOfMono_φH","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_2, u_1} C\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nh : S₁.LeftHomologyData\ninst✝² : CategoryTheory.Epi φ.τ₁\ninst✝¹ : CategoryTheory.IsIso φ.τ₂\ninst✝ : CategoryTheory.Mono φ.τ₃\n⊢ Eq (CategoryTheory.ShortComplex.LeftHomologyMapData.ofEpiOfIsIsoOfMono φ h).φH (CategoryTheory.CategoryStruct.id h.H)","decl":"/-- This left homology map data expresses compatibilities of the left homology data\nconstructed by `LeftHomologyData.ofEpiOfIsIsoOfMono` -/\n@[simps]\ndef ofEpiOfIsIsoOfMono (φ : S₁ ⟶ S₂) (h : LeftHomologyData S₁)\n    [Epi φ.τ₁] [IsIso φ.τ₂] [Mono φ.τ₃] :\n    LeftHomologyMapData φ h (LeftHomologyData.ofEpiOfIsIsoOfMono φ h) where\n  φK := 𝟙 _\n  φH := 𝟙 _\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyMapData.ofEpiOfIsIsoOfMono_φK","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_2, u_1} C\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nh : S₁.LeftHomologyData\ninst✝² : CategoryTheory.Epi φ.τ₁\ninst✝¹ : CategoryTheory.IsIso φ.τ₂\ninst✝ : CategoryTheory.Mono φ.τ₃\n⊢ Eq (CategoryTheory.ShortComplex.LeftHomologyMapData.ofEpiOfIsIsoOfMono φ h).φK (CategoryTheory.CategoryStruct.id h.K)","decl":"/-- This left homology map data expresses compatibilities of the left homology data\nconstructed by `LeftHomologyData.ofEpiOfIsIsoOfMono` -/\n@[simps]\ndef ofEpiOfIsIsoOfMono (φ : S₁ ⟶ S₂) (h : LeftHomologyData S₁)\n    [Epi φ.τ₁] [IsIso φ.τ₂] [Mono φ.τ₃] :\n    LeftHomologyMapData φ h (LeftHomologyData.ofEpiOfIsIsoOfMono φ h) where\n  φK := 𝟙 _\n  φH := 𝟙 _\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyMapData.ofEpiOfIsIsoOfMono'_φH","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_2, u_1} C\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nh : S₂.LeftHomologyData\ninst✝² : CategoryTheory.Epi φ.τ₁\ninst✝¹ : CategoryTheory.IsIso φ.τ₂\ninst✝ : CategoryTheory.Mono φ.τ₃\n⊢ Eq (CategoryTheory.ShortComplex.LeftHomologyMapData.ofEpiOfIsIsoOfMono' φ h).φH (CategoryTheory.CategoryStruct.id (CategoryTheory.ShortComplex.LeftHomologyData.ofEpiOfIsIsoOfMono' φ h).H)","decl":"/-- This left homology map data expresses compatibilities of the left homology data\nconstructed by `LeftHomologyData.ofEpiOfIsIsoOfMono'` -/\n@[simps]\nnoncomputable def ofEpiOfIsIsoOfMono' (φ : S₁ ⟶ S₂) (h : LeftHomologyData S₂)\n    [Epi φ.τ₁] [IsIso φ.τ₂] [Mono φ.τ₃] :\n    LeftHomologyMapData φ (LeftHomologyData.ofEpiOfIsIsoOfMono' φ h) h where\n  φK := 𝟙 _\n  φH := 𝟙 _\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyMapData.ofEpiOfIsIsoOfMono'_φK","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_2, u_1} C\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nh : S₂.LeftHomologyData\ninst✝² : CategoryTheory.Epi φ.τ₁\ninst✝¹ : CategoryTheory.IsIso φ.τ₂\ninst✝ : CategoryTheory.Mono φ.τ₃\n⊢ Eq (CategoryTheory.ShortComplex.LeftHomologyMapData.ofEpiOfIsIsoOfMono' φ h).φK (CategoryTheory.CategoryStruct.id (CategoryTheory.ShortComplex.LeftHomologyData.ofEpiOfIsIsoOfMono' φ h).K)","decl":"/-- This left homology map data expresses compatibilities of the left homology data\nconstructed by `LeftHomologyData.ofEpiOfIsIsoOfMono'` -/\n@[simps]\nnoncomputable def ofEpiOfIsIsoOfMono' (φ : S₁ ⟶ S₂) (h : LeftHomologyData S₂)\n    [Epi φ.τ₁] [IsIso φ.τ₂] [Mono φ.τ₃] :\n    LeftHomologyMapData φ (LeftHomologyData.ofEpiOfIsIsoOfMono' φ h) h where\n  φK := 𝟙 _\n  φH := 𝟙 _\n\n"}
{"name":"CategoryTheory.ShortComplex.instIsIsoLeftHomologyMap'OfEpiτ₁Ofτ₂OfMonoτ₃","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_2, u_1} C\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nh₁ : S₁.LeftHomologyData\nh₂ : S₂.LeftHomologyData\ninst✝² : CategoryTheory.Epi φ.τ₁\ninst✝¹ : CategoryTheory.IsIso φ.τ₂\ninst✝ : CategoryTheory.Mono φ.τ₃\n⊢ CategoryTheory.IsIso (CategoryTheory.ShortComplex.leftHomologyMap' φ h₁ h₂)","decl":"instance (φ : S₁ ⟶ S₂) (h₁ : S₁.LeftHomologyData) (h₂ : S₂.LeftHomologyData)\n    [Epi φ.τ₁] [IsIso φ.τ₂] [Mono φ.τ₃] :\n    IsIso (leftHomologyMap' φ h₁ h₂) := by\n  let h₂' := LeftHomologyData.ofEpiOfIsIsoOfMono φ h₁\n  have : IsIso (leftHomologyMap' φ h₁ h₂') := by\n    rw [(LeftHomologyMapData.ofEpiOfIsIsoOfMono φ h₁).leftHomologyMap'_eq]\n    dsimp\n    infer_instance\n  have eq := leftHomologyMap'_comp φ (𝟙 S₂) h₁ h₂' h₂\n  rw [comp_id] at eq\n  rw [eq]\n  infer_instance\n\n"}
{"name":"CategoryTheory.ShortComplex.instIsIsoLeftHomologyMapOfEpiτ₁Ofτ₂OfMonoτ₃","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝⁶ : CategoryTheory.Category.{u_2, u_1} C\ninst✝⁵ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\ninst✝⁴ : S₁.HasLeftHomology\ninst✝³ : S₂.HasLeftHomology\ninst✝² : CategoryTheory.Epi φ.τ₁\ninst✝¹ : CategoryTheory.IsIso φ.τ₂\ninst✝ : CategoryTheory.Mono φ.τ₃\n⊢ CategoryTheory.IsIso (CategoryTheory.ShortComplex.leftHomologyMap φ)","decl":"/-- If a morphism of short complexes `φ : S₁ ⟶ S₂` is such that `φ.τ₁` is epi, `φ.τ₂` is an iso,\nand `φ.τ₃` is mono, then the induced morphism on left homology is an isomorphism. -/\ninstance (φ : S₁ ⟶ S₂) [S₁.HasLeftHomology] [S₂.HasLeftHomology]\n    [Epi φ.τ₁] [IsIso φ.τ₂] [Mono φ.τ₃] :\n    IsIso (leftHomologyMap φ) := by\n  dsimp only [leftHomologyMap]\n  infer_instance\n\n"}
{"name":"CategoryTheory.ShortComplex.liftCycles_i","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nA : C\nk : Quiver.Hom A S.X₂\nhk : Eq (CategoryTheory.CategoryStruct.comp k S.g) 0\ninst✝ : S.HasLeftHomology\n⊢ Eq (CategoryTheory.CategoryStruct.comp (S.liftCycles k hk) S.iCycles) k","decl":"@[reassoc (attr := simp)]\nlemma liftCycles_i : S.liftCycles k hk ≫ S.iCycles = k :=\n  LeftHomologyData.liftK_i _ k hk\n\n"}
{"name":"CategoryTheory.ShortComplex.liftCycles_i_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nA : C\nk : Quiver.Hom A S.X₂\nhk : Eq (CategoryTheory.CategoryStruct.comp k S.g) 0\ninst✝ : S.HasLeftHomology\nZ : C\nh : Quiver.Hom S.X₂ Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (S.liftCycles k hk) (CategoryTheory.CategoryStruct.comp S.iCycles h)) (CategoryTheory.CategoryStruct.comp k h)","decl":"@[reassoc (attr := simp)]\nlemma liftCycles_i : S.liftCycles k hk ≫ S.iCycles = k :=\n  LeftHomologyData.liftK_i _ k hk\n\n"}
{"name":"CategoryTheory.ShortComplex.comp_liftCycles_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nA : C\nk : Quiver.Hom A S.X₂\nhk : Eq (CategoryTheory.CategoryStruct.comp k S.g) 0\ninst✝ : S.HasLeftHomology\nA' : C\nα : Quiver.Hom A' A\nZ : C\nh : Quiver.Hom S.cycles Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp α (CategoryTheory.CategoryStruct.comp (S.liftCycles k hk) h)) (CategoryTheory.CategoryStruct.comp (S.liftCycles (CategoryTheory.CategoryStruct.comp α k) ⋯) h)","decl":"@[reassoc]\nlemma comp_liftCycles {A' : C} (α : A' ⟶ A) :\n    α ≫ S.liftCycles k hk = S.liftCycles (α ≫ k) (by rw [assoc, hk, comp_zero]) := by aesop_cat\n\n"}
{"name":"CategoryTheory.ShortComplex.comp_liftCycles","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nA : C\nk : Quiver.Hom A S.X₂\nhk : Eq (CategoryTheory.CategoryStruct.comp k S.g) 0\ninst✝ : S.HasLeftHomology\nA' : C\nα : Quiver.Hom A' A\n⊢ Eq (CategoryTheory.CategoryStruct.comp α (S.liftCycles k hk)) (S.liftCycles (CategoryTheory.CategoryStruct.comp α k) ⋯)","decl":"@[reassoc]\nlemma comp_liftCycles {A' : C} (α : A' ⟶ A) :\n    α ≫ S.liftCycles k hk = S.liftCycles (α ≫ k) (by rw [assoc, hk, comp_zero]) := by aesop_cat\n\n"}
{"name":"CategoryTheory.ShortComplex.cyclesIsoKernel_inv","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_2, u_1} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst✝¹ : S.HasLeftHomology\ninst✝ : CategoryTheory.Limits.HasKernel S.g\n⊢ Eq S.cyclesIsoKernel.inv (S.liftCycles (CategoryTheory.Limits.kernel.ι S.g) ⋯)","decl":"/-- The canonical isomorphism `S.cycles ≅ kernel S.g`. -/\n@[simps]\nnoncomputable def cyclesIsoKernel [HasKernel S.g] : S.cycles ≅ kernel S.g where\n  hom := kernel.lift S.g S.iCycles (by simp)\n  inv := S.liftCycles (kernel.ι S.g) (by simp)\n\n"}
{"name":"CategoryTheory.ShortComplex.cyclesIsoKernel_hom","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_2, u_1} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst✝¹ : S.HasLeftHomology\ninst✝ : CategoryTheory.Limits.HasKernel S.g\n⊢ Eq S.cyclesIsoKernel.hom (CategoryTheory.Limits.kernel.lift S.g S.iCycles ⋯)","decl":"/-- The canonical isomorphism `S.cycles ≅ kernel S.g`. -/\n@[simps]\nnoncomputable def cyclesIsoKernel [HasKernel S.g] : S.cycles ≅ kernel S.g where\n  hom := kernel.lift S.g S.iCycles (by simp)\n  inv := S.liftCycles (kernel.ι S.g) (by simp)\n\n"}
{"name":"CategoryTheory.ShortComplex.liftCycles_leftHomologyπ_eq_zero_of_boundary_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nA : C\nk : Quiver.Hom A S.X₂\ninst✝ : S.HasLeftHomology\nx : Quiver.Hom A S.X₁\nhx : Eq k (CategoryTheory.CategoryStruct.comp x S.f)\nZ : C\nh : Quiver.Hom S.leftHomology Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (S.liftCycles k ⋯) (CategoryTheory.CategoryStruct.comp S.leftHomologyπ h)) (CategoryTheory.CategoryStruct.comp 0 h)","decl":"@[reassoc]\nlemma liftCycles_leftHomologyπ_eq_zero_of_boundary (x : A ⟶ S.X₁) (hx : k = x ≫ S.f) :\n    S.liftCycles k (by rw [hx, assoc, S.zero, comp_zero]) ≫ S.leftHomologyπ = 0 :=\n  LeftHomologyData.liftK_π_eq_zero_of_boundary _ k x hx\n\n"}
{"name":"CategoryTheory.ShortComplex.liftCycles_leftHomologyπ_eq_zero_of_boundary","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nA : C\nk : Quiver.Hom A S.X₂\ninst✝ : S.HasLeftHomology\nx : Quiver.Hom A S.X₁\nhx : Eq k (CategoryTheory.CategoryStruct.comp x S.f)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (S.liftCycles k ⋯) S.leftHomologyπ) 0","decl":"@[reassoc]\nlemma liftCycles_leftHomologyπ_eq_zero_of_boundary (x : A ⟶ S.X₁) (hx : k = x ≫ S.f) :\n    S.liftCycles k (by rw [hx, assoc, S.zero, comp_zero]) ≫ S.leftHomologyπ = 0 :=\n  LeftHomologyData.liftK_π_eq_zero_of_boundary _ k x hx\n\n"}
{"name":"CategoryTheory.ShortComplex.toCycles_comp_leftHomologyπ_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst✝ : S.HasLeftHomology\nZ : C\nh : Quiver.Hom S.leftHomology Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp S.toCycles (CategoryTheory.CategoryStruct.comp S.leftHomologyπ h)) (CategoryTheory.CategoryStruct.comp 0 h)","decl":"@[reassoc (attr := simp)]\nlemma toCycles_comp_leftHomologyπ : S.toCycles ≫ S.leftHomologyπ = 0 :=\n  S.liftCycles_leftHomologyπ_eq_zero_of_boundary S.f (𝟙 _) (by rw [id_comp])\n\n"}
{"name":"CategoryTheory.ShortComplex.toCycles_comp_leftHomologyπ","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst✝ : S.HasLeftHomology\n⊢ Eq (CategoryTheory.CategoryStruct.comp S.toCycles S.leftHomologyπ) 0","decl":"@[reassoc (attr := simp)]\nlemma toCycles_comp_leftHomologyπ : S.toCycles ≫ S.leftHomologyπ = 0 :=\n  S.liftCycles_leftHomologyπ_eq_zero_of_boundary S.f (𝟙 _) (by rw [id_comp])\n\n"}
{"name":"CategoryTheory.ShortComplex.liftCycles_comp_cyclesMap_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_2, u_1} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nS S₁ : CategoryTheory.ShortComplex C\nA : C\nk : Quiver.Hom A S.X₂\nhk : Eq (CategoryTheory.CategoryStruct.comp k S.g) 0\ninst✝¹ : S.HasLeftHomology\nφ : Quiver.Hom S S₁\ninst✝ : S₁.HasLeftHomology\nZ : C\nh : Quiver.Hom S₁.cycles Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (S.liftCycles k hk) (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.cyclesMap φ) h)) (CategoryTheory.CategoryStruct.comp (S₁.liftCycles (CategoryTheory.CategoryStruct.comp k φ.τ₂) ⋯) h)","decl":"@[reassoc (attr := simp)]\nlemma liftCycles_comp_cyclesMap (φ : S ⟶ S₁) [S₁.HasLeftHomology] :\n    S.liftCycles k hk ≫ cyclesMap φ =\n      S₁.liftCycles (k ≫ φ.τ₂) (by rw [assoc, φ.comm₂₃, reassoc_of% hk, zero_comp]) := by\n  aesop_cat\n\n"}
{"name":"CategoryTheory.ShortComplex.liftCycles_comp_cyclesMap","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_2, u_1} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nS S₁ : CategoryTheory.ShortComplex C\nA : C\nk : Quiver.Hom A S.X₂\nhk : Eq (CategoryTheory.CategoryStruct.comp k S.g) 0\ninst✝¹ : S.HasLeftHomology\nφ : Quiver.Hom S S₁\ninst✝ : S₁.HasLeftHomology\n⊢ Eq (CategoryTheory.CategoryStruct.comp (S.liftCycles k hk) (CategoryTheory.ShortComplex.cyclesMap φ)) (S₁.liftCycles (CategoryTheory.CategoryStruct.comp k φ.τ₂) ⋯)","decl":"@[reassoc (attr := simp)]\nlemma liftCycles_comp_cyclesMap (φ : S ⟶ S₁) [S₁.HasLeftHomology] :\n    S.liftCycles k hk ≫ cyclesMap φ =\n      S₁.liftCycles (k ≫ φ.τ₂) (by rw [assoc, φ.comm₂₃, reassoc_of% hk, zero_comp]) := by\n  aesop_cat\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.liftCycles_comp_cyclesIso_hom","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nh : S.LeftHomologyData\nA : C\nk : Quiver.Hom A S.X₂\nhk : Eq (CategoryTheory.CategoryStruct.comp k S.g) 0\ninst✝ : S.HasLeftHomology\n⊢ Eq (CategoryTheory.CategoryStruct.comp (S.liftCycles k hk) h.cyclesIso.hom) (h.liftK k hk)","decl":"@[reassoc (attr := simp)]\nlemma LeftHomologyData.liftCycles_comp_cyclesIso_hom :\n    S.liftCycles k hk ≫ h.cyclesIso.hom = h.liftK k hk := by\n  simp only [← cancel_mono h.i, assoc, LeftHomologyData.cyclesIso_hom_comp_i,\n    liftCycles_i, LeftHomologyData.liftK_i]\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.liftCycles_comp_cyclesIso_hom_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nh✝ : S.LeftHomologyData\nA : C\nk : Quiver.Hom A S.X₂\nhk : Eq (CategoryTheory.CategoryStruct.comp k S.g) 0\ninst✝ : S.HasLeftHomology\nZ : C\nh : Quiver.Hom h✝.K Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (S.liftCycles k hk) (CategoryTheory.CategoryStruct.comp h✝.cyclesIso.hom h)) (CategoryTheory.CategoryStruct.comp (h✝.liftK k hk) h)","decl":"@[reassoc (attr := simp)]\nlemma LeftHomologyData.liftCycles_comp_cyclesIso_hom :\n    S.liftCycles k hk ≫ h.cyclesIso.hom = h.liftK k hk := by\n  simp only [← cancel_mono h.i, assoc, LeftHomologyData.cyclesIso_hom_comp_i,\n    liftCycles_i, LeftHomologyData.liftK_i]\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.lift_K_comp_cyclesIso_inv","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nh : S.LeftHomologyData\nA : C\nk : Quiver.Hom A S.X₂\nhk : Eq (CategoryTheory.CategoryStruct.comp k S.g) 0\ninst✝ : S.HasLeftHomology\n⊢ Eq (CategoryTheory.CategoryStruct.comp (h.liftK k hk) h.cyclesIso.inv) (S.liftCycles k hk)","decl":"@[reassoc (attr := simp)]\nlemma LeftHomologyData.lift_K_comp_cyclesIso_inv :\n    h.liftK k hk ≫ h.cyclesIso.inv = S.liftCycles k hk := by\n  rw [← h.liftCycles_comp_cyclesIso_hom, assoc, Iso.hom_inv_id, comp_id]\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.lift_K_comp_cyclesIso_inv_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nh✝ : S.LeftHomologyData\nA : C\nk : Quiver.Hom A S.X₂\nhk : Eq (CategoryTheory.CategoryStruct.comp k S.g) 0\ninst✝ : S.HasLeftHomology\nZ : C\nh : Quiver.Hom S.cycles Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (h✝.liftK k hk) (CategoryTheory.CategoryStruct.comp h✝.cyclesIso.inv h)) (CategoryTheory.CategoryStruct.comp (S.liftCycles k hk) h)","decl":"@[reassoc (attr := simp)]\nlemma LeftHomologyData.lift_K_comp_cyclesIso_inv :\n    h.liftK k hk ≫ h.cyclesIso.inv = S.liftCycles k hk := by\n  rw [← h.liftCycles_comp_cyclesIso_hom, assoc, Iso.hom_inv_id, comp_id]\n\n"}
{"name":"CategoryTheory.ShortComplex.HasLeftHomology.hasKernel","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst✝ : S.HasLeftHomology\n⊢ CategoryTheory.Limits.HasKernel S.g","decl":"lemma hasKernel [S.HasLeftHomology] : HasKernel S.g :=\n  ⟨⟨⟨_, S.leftHomologyData.hi⟩⟩⟩\n\n"}
{"name":"CategoryTheory.ShortComplex.HasLeftHomology.hasCokernel","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_2, u_1} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst✝¹ : S.HasLeftHomology\ninst✝ : CategoryTheory.Limits.HasKernel S.g\n⊢ CategoryTheory.Limits.HasCokernel (CategoryTheory.Limits.kernel.lift S.g S.f ⋯)","decl":"lemma hasCokernel [S.HasLeftHomology] [HasKernel S.g] :\n    HasCokernel (kernel.lift S.g S.f S.zero) := by\n  let h := S.leftHomologyData\n  haveI : HasColimit (parallelPair h.f' 0) := ⟨⟨⟨_, h.hπ'⟩⟩⟩\n  let e : parallelPair (kernel.lift S.g S.f S.zero) 0 ≅ parallelPair h.f' 0 :=\n    parallelPair.ext (Iso.refl _) (IsLimit.conePointUniqueUpToIso (kernelIsKernel S.g) h.hi)\n      (by aesop_cat) (by simp)\n  exact hasColimitOfIso e\n\n"}
{"name":"CategoryTheory.ShortComplex.isIso_cyclesMap'_of_isIso_of_mono","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nh₂✝ : CategoryTheory.IsIso φ.τ₂\nh₃ : CategoryTheory.Mono φ.τ₃\nh₁ : S₁.LeftHomologyData\nh₂ : S₂.LeftHomologyData\n⊢ CategoryTheory.IsIso (CategoryTheory.ShortComplex.cyclesMap' φ h₁ h₂)","decl":"lemma isIso_cyclesMap'_of_isIso_of_mono (φ : S₁ ⟶ S₂) (h₂ : IsIso φ.τ₂) (h₃ : Mono φ.τ₃)\n    (h₁ : S₁.LeftHomologyData) (h₂ : S₂.LeftHomologyData) :\n    IsIso (cyclesMap' φ h₁ h₂) := by\n  refine ⟨h₁.liftK (h₂.i ≫ inv φ.τ₂) ?_, ?_, ?_⟩\n  · simp only [assoc, ← cancel_mono φ.τ₃, zero_comp, ← φ.comm₂₃, IsIso.inv_hom_id_assoc, h₂.wi]\n  · simp only [← cancel_mono h₁.i, assoc, h₁.liftK_i, cyclesMap'_i_assoc,\n      IsIso.hom_inv_id, comp_id, id_comp]\n  · simp only [← cancel_mono h₂.i, assoc, cyclesMap'_i, h₁.liftK_i_assoc,\n      IsIso.inv_hom_id, comp_id, id_comp]\n\n"}
{"name":"CategoryTheory.ShortComplex.isIso_cyclesMap_of_isIso_of_mono'","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_2, u_1} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nh₂ : CategoryTheory.IsIso φ.τ₂\nh₃ : CategoryTheory.Mono φ.τ₃\ninst✝¹ : S₁.HasLeftHomology\ninst✝ : S₂.HasLeftHomology\n⊢ CategoryTheory.IsIso (CategoryTheory.ShortComplex.cyclesMap φ)","decl":"lemma isIso_cyclesMap_of_isIso_of_mono' (φ : S₁ ⟶ S₂) (h₂ : IsIso φ.τ₂) (h₃ : Mono φ.τ₃)\n    [S₁.HasLeftHomology] [S₂.HasLeftHomology] :\n    IsIso (cyclesMap φ) :=\n  isIso_cyclesMap'_of_isIso_of_mono φ h₂ h₃ _ _\n\n"}
{"name":"CategoryTheory.ShortComplex.isIso_cyclesMap_of_isIso_of_mono","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst✝⁵ : CategoryTheory.Category.{u_2, u_1} C\ninst✝⁴ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\ninst✝³ : CategoryTheory.IsIso φ.τ₂\ninst✝² : CategoryTheory.Mono φ.τ₃\ninst✝¹ : S₁.HasLeftHomology\ninst✝ : S₂.HasLeftHomology\n⊢ CategoryTheory.IsIso (CategoryTheory.ShortComplex.cyclesMap φ)","decl":"instance isIso_cyclesMap_of_isIso_of_mono (φ : S₁ ⟶ S₂) [IsIso φ.τ₂] [Mono φ.τ₃]\n    [S₁.HasLeftHomology] [S₂.HasLeftHomology] :\n    IsIso (cyclesMap φ) :=\n  isIso_cyclesMap_of_isIso_of_mono' φ inferInstance inferInstance\n\n"}
