{"name":"CategoryTheory.ShortComplex.LeftHomologyData.mk.injEq","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nK‚úù H‚úù : C\ni‚úù : Quiver.Hom K‚úù S.X‚ÇÇ\nœÄ‚úù : Quiver.Hom K‚úù H‚úù\nwi‚úù : Eq (CategoryTheory.CategoryStruct.comp i‚úù S.g) 0\nhi‚úù : CategoryTheory.Limits.IsLimit (CategoryTheory.Limits.KernelFork.ofŒπ i‚úù wi‚úù)\nwœÄ‚úù : Eq (CategoryTheory.CategoryStruct.comp (hi‚úù.lift (CategoryTheory.Limits.KernelFork.ofŒπ S.f ‚ãØ)) œÄ‚úù) 0\nhœÄ‚úù : CategoryTheory.Limits.IsColimit (CategoryTheory.Limits.CokernelCofork.ofœÄ œÄ‚úù wœÄ‚úù)\nK H : C\ni : Quiver.Hom K S.X‚ÇÇ\nœÄ : Quiver.Hom K H\nwi : Eq (CategoryTheory.CategoryStruct.comp i S.g) 0\nhi : CategoryTheory.Limits.IsLimit (CategoryTheory.Limits.KernelFork.ofŒπ i wi)\nwœÄ : Eq (CategoryTheory.CategoryStruct.comp (hi.lift (CategoryTheory.Limits.KernelFork.ofŒπ S.f ‚ãØ)) œÄ) 0\nhœÄ : CategoryTheory.Limits.IsColimit (CategoryTheory.Limits.CokernelCofork.ofœÄ œÄ wœÄ)\n‚ä¢ Eq (Eq { K := K‚úù, H := H‚úù, i := i‚úù, œÄ := œÄ‚úù, wi := wi‚úù, hi := hi‚úù, wœÄ := wœÄ‚úù, hœÄ := hœÄ‚úù } { K := K, H := H, i := i, œÄ := œÄ, wi := wi, hi := hi, wœÄ := wœÄ, hœÄ := hœÄ }) (And (Eq K‚úù K) (And (Eq H‚úù H) (And (HEq i‚úù i) (And (HEq œÄ‚úù œÄ) (And (HEq hi‚úù hi) (HEq hœÄ‚úù hœÄ))))))","decl":"/-- A left homology data for a short complex `S` consists of morphisms `i : K ‚ü∂ S.X‚ÇÇ` and\n`œÄ : K ‚ü∂ H` such that `i` identifies `K` to the kernel of `g : S.X‚ÇÇ ‚ü∂ S.X‚ÇÉ`,\nand that `œÄ` identifies `H` to the cokernel of the induced map `f' : S.X‚ÇÅ ‚ü∂ K` -/\nstructure LeftHomologyData where\n  /-- a choice of kernel of `S.g : S.X‚ÇÇ ‚ü∂ S.X‚ÇÉ`-/\n  K : C\n  /-- a choice of cokernel of the induced morphism `S.f' : S.X‚ÇÅ ‚ü∂ K`-/\n  H : C\n  /-- the inclusion of cycles in `S.X‚ÇÇ` -/\n  i : K ‚ü∂ S.X‚ÇÇ\n  /-- the projection from cycles to the (left) homology -/\n  œÄ : K ‚ü∂ H\n  /-- the kernel condition for `i` -/\n  wi : i ‚â´ S.g = 0\n  /-- `i : K ‚ü∂ S.X‚ÇÇ` is a kernel of `g : S.X‚ÇÇ ‚ü∂ S.X‚ÇÉ` -/\n  hi : IsLimit (KernelFork.ofŒπ i wi)\n  /-- the cokernel condition for `œÄ` -/\n  wœÄ : hi.lift (KernelFork.ofŒπ _ S.zero) ‚â´ œÄ = 0\n  /-- `œÄ : K ‚ü∂ H` is a cokernel of the induced morphism `S.f' : S.X‚ÇÅ ‚ü∂ K` -/\n  hœÄ : IsColimit (CokernelCofork.ofœÄ œÄ wœÄ)\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.wœÄ","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nself : S.LeftHomologyData\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (self.hi.lift (CategoryTheory.Limits.KernelFork.ofŒπ S.f ‚ãØ)) self.œÄ) 0","decl":"/-- A left homology data for a short complex `S` consists of morphisms `i : K ‚ü∂ S.X‚ÇÇ` and\n`œÄ : K ‚ü∂ H` such that `i` identifies `K` to the kernel of `g : S.X‚ÇÇ ‚ü∂ S.X‚ÇÉ`,\nand that `œÄ` identifies `H` to the cokernel of the induced map `f' : S.X‚ÇÅ ‚ü∂ K` -/\nstructure LeftHomologyData where\n  /-- a choice of kernel of `S.g : S.X‚ÇÇ ‚ü∂ S.X‚ÇÉ`-/\n  K : C\n  /-- a choice of cokernel of the induced morphism `S.f' : S.X‚ÇÅ ‚ü∂ K`-/\n  H : C\n  /-- the inclusion of cycles in `S.X‚ÇÇ` -/\n  i : K ‚ü∂ S.X‚ÇÇ\n  /-- the projection from cycles to the (left) homology -/\n  œÄ : K ‚ü∂ H\n  /-- the kernel condition for `i` -/\n  wi : i ‚â´ S.g = 0\n  /-- `i : K ‚ü∂ S.X‚ÇÇ` is a kernel of `g : S.X‚ÇÇ ‚ü∂ S.X‚ÇÉ` -/\n  hi : IsLimit (KernelFork.ofŒπ i wi)\n  /-- the cokernel condition for `œÄ` -/\n  wœÄ : hi.lift (KernelFork.ofŒπ _ S.zero) ‚â´ œÄ = 0\n  /-- `œÄ : K ‚ü∂ H` is a cokernel of the induced morphism `S.f' : S.X‚ÇÅ ‚ü∂ K` -/\n  hœÄ : IsColimit (CokernelCofork.ofœÄ œÄ wœÄ)\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.mk.inj","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nK‚úù H‚úù : C\ni‚úù : Quiver.Hom K‚úù S.X‚ÇÇ\nœÄ‚úù : Quiver.Hom K‚úù H‚úù\nwi‚úù : Eq (CategoryTheory.CategoryStruct.comp i‚úù S.g) 0\nhi‚úù : CategoryTheory.Limits.IsLimit (CategoryTheory.Limits.KernelFork.ofŒπ i‚úù wi‚úù)\nwœÄ‚úù : Eq (CategoryTheory.CategoryStruct.comp (hi‚úù.lift (CategoryTheory.Limits.KernelFork.ofŒπ S.f ‚ãØ)) œÄ‚úù) 0\nhœÄ‚úù : CategoryTheory.Limits.IsColimit (CategoryTheory.Limits.CokernelCofork.ofœÄ œÄ‚úù wœÄ‚úù)\nK H : C\ni : Quiver.Hom K S.X‚ÇÇ\nœÄ : Quiver.Hom K H\nwi : Eq (CategoryTheory.CategoryStruct.comp i S.g) 0\nhi : CategoryTheory.Limits.IsLimit (CategoryTheory.Limits.KernelFork.ofŒπ i wi)\nwœÄ : Eq (CategoryTheory.CategoryStruct.comp (hi.lift (CategoryTheory.Limits.KernelFork.ofŒπ S.f ‚ãØ)) œÄ) 0\nhœÄ : CategoryTheory.Limits.IsColimit (CategoryTheory.Limits.CokernelCofork.ofœÄ œÄ wœÄ)\nx‚úù : Eq { K := K‚úù, H := H‚úù, i := i‚úù, œÄ := œÄ‚úù, wi := wi‚úù, hi := hi‚úù, wœÄ := wœÄ‚úù, hœÄ := hœÄ‚úù } { K := K, H := H, i := i, œÄ := œÄ, wi := wi, hi := hi, wœÄ := wœÄ, hœÄ := hœÄ }\n‚ä¢ And (Eq K‚úù K) (And (Eq H‚úù H) (And (HEq i‚úù i) (And (HEq œÄ‚úù œÄ) (And (HEq hi‚úù hi) (HEq hœÄ‚úù hœÄ)))))","decl":"/-- A left homology data for a short complex `S` consists of morphisms `i : K ‚ü∂ S.X‚ÇÇ` and\n`œÄ : K ‚ü∂ H` such that `i` identifies `K` to the kernel of `g : S.X‚ÇÇ ‚ü∂ S.X‚ÇÉ`,\nand that `œÄ` identifies `H` to the cokernel of the induced map `f' : S.X‚ÇÅ ‚ü∂ K` -/\nstructure LeftHomologyData where\n  /-- a choice of kernel of `S.g : S.X‚ÇÇ ‚ü∂ S.X‚ÇÉ`-/\n  K : C\n  /-- a choice of cokernel of the induced morphism `S.f' : S.X‚ÇÅ ‚ü∂ K`-/\n  H : C\n  /-- the inclusion of cycles in `S.X‚ÇÇ` -/\n  i : K ‚ü∂ S.X‚ÇÇ\n  /-- the projection from cycles to the (left) homology -/\n  œÄ : K ‚ü∂ H\n  /-- the kernel condition for `i` -/\n  wi : i ‚â´ S.g = 0\n  /-- `i : K ‚ü∂ S.X‚ÇÇ` is a kernel of `g : S.X‚ÇÇ ‚ü∂ S.X‚ÇÉ` -/\n  hi : IsLimit (KernelFork.ofŒπ i wi)\n  /-- the cokernel condition for `œÄ` -/\n  wœÄ : hi.lift (KernelFork.ofŒπ _ S.zero) ‚â´ œÄ = 0\n  /-- `œÄ : K ‚ü∂ H` is a cokernel of the induced morphism `S.f' : S.X‚ÇÅ ‚ü∂ K` -/\n  hœÄ : IsColimit (CokernelCofork.ofœÄ œÄ wœÄ)\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.mk.sizeOf_spec","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst‚úù : SizeOf C\nK H : C\ni : Quiver.Hom K S.X‚ÇÇ\nœÄ : Quiver.Hom K H\nwi : Eq (CategoryTheory.CategoryStruct.comp i S.g) 0\nhi : CategoryTheory.Limits.IsLimit (CategoryTheory.Limits.KernelFork.ofŒπ i wi)\nwœÄ : Eq (CategoryTheory.CategoryStruct.comp (hi.lift (CategoryTheory.Limits.KernelFork.ofŒπ S.f ‚ãØ)) œÄ) 0\nhœÄ : CategoryTheory.Limits.IsColimit (CategoryTheory.Limits.CokernelCofork.ofœÄ œÄ wœÄ)\n‚ä¢ Eq (SizeOf.sizeOf { K := K, H := H, i := i, œÄ := œÄ, wi := wi, hi := hi, wœÄ := wœÄ, hœÄ := hœÄ }) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf K)) (SizeOf.sizeOf H)) (SizeOf.sizeOf i)) (SizeOf.sizeOf œÄ)) (SizeOf.sizeOf wi)) (SizeOf.sizeOf hi)) (SizeOf.sizeOf wœÄ)) (SizeOf.sizeOf hœÄ))","decl":"/-- A left homology data for a short complex `S` consists of morphisms `i : K ‚ü∂ S.X‚ÇÇ` and\n`œÄ : K ‚ü∂ H` such that `i` identifies `K` to the kernel of `g : S.X‚ÇÇ ‚ü∂ S.X‚ÇÉ`,\nand that `œÄ` identifies `H` to the cokernel of the induced map `f' : S.X‚ÇÅ ‚ü∂ K` -/\nstructure LeftHomologyData where\n  /-- a choice of kernel of `S.g : S.X‚ÇÇ ‚ü∂ S.X‚ÇÉ`-/\n  K : C\n  /-- a choice of cokernel of the induced morphism `S.f' : S.X‚ÇÅ ‚ü∂ K`-/\n  H : C\n  /-- the inclusion of cycles in `S.X‚ÇÇ` -/\n  i : K ‚ü∂ S.X‚ÇÇ\n  /-- the projection from cycles to the (left) homology -/\n  œÄ : K ‚ü∂ H\n  /-- the kernel condition for `i` -/\n  wi : i ‚â´ S.g = 0\n  /-- `i : K ‚ü∂ S.X‚ÇÇ` is a kernel of `g : S.X‚ÇÇ ‚ü∂ S.X‚ÇÉ` -/\n  hi : IsLimit (KernelFork.ofŒπ i wi)\n  /-- the cokernel condition for `œÄ` -/\n  wœÄ : hi.lift (KernelFork.ofŒπ _ S.zero) ‚â´ œÄ = 0\n  /-- `œÄ : K ‚ü∂ H` is a cokernel of the induced morphism `S.f' : S.X‚ÇÅ ‚ü∂ K` -/\n  hœÄ : IsColimit (CokernelCofork.ofœÄ œÄ wœÄ)\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.wi","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nself : S.LeftHomologyData\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp self.i S.g) 0","decl":"/-- A left homology data for a short complex `S` consists of morphisms `i : K ‚ü∂ S.X‚ÇÇ` and\n`œÄ : K ‚ü∂ H` such that `i` identifies `K` to the kernel of `g : S.X‚ÇÇ ‚ü∂ S.X‚ÇÉ`,\nand that `œÄ` identifies `H` to the cokernel of the induced map `f' : S.X‚ÇÅ ‚ü∂ K` -/\nstructure LeftHomologyData where\n  /-- a choice of kernel of `S.g : S.X‚ÇÇ ‚ü∂ S.X‚ÇÉ`-/\n  K : C\n  /-- a choice of cokernel of the induced morphism `S.f' : S.X‚ÇÅ ‚ü∂ K`-/\n  H : C\n  /-- the inclusion of cycles in `S.X‚ÇÇ` -/\n  i : K ‚ü∂ S.X‚ÇÇ\n  /-- the projection from cycles to the (left) homology -/\n  œÄ : K ‚ü∂ H\n  /-- the kernel condition for `i` -/\n  wi : i ‚â´ S.g = 0\n  /-- `i : K ‚ü∂ S.X‚ÇÇ` is a kernel of `g : S.X‚ÇÇ ‚ü∂ S.X‚ÇÉ` -/\n  hi : IsLimit (KernelFork.ofŒπ i wi)\n  /-- the cokernel condition for `œÄ` -/\n  wœÄ : hi.lift (KernelFork.ofŒπ _ S.zero) ‚â´ œÄ = 0\n  /-- `œÄ : K ‚ü∂ H` is a cokernel of the induced morphism `S.f' : S.X‚ÇÅ ‚ü∂ K` -/\n  hœÄ : IsColimit (CokernelCofork.ofœÄ œÄ wœÄ)\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.ofHasKernelOfHasCokernel_i","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬≥ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst‚úù¬π : CategoryTheory.Limits.HasKernel S.g\ninst‚úù : CategoryTheory.Limits.HasCokernel (CategoryTheory.Limits.kernel.lift S.g S.f ‚ãØ)\n‚ä¢ Eq (CategoryTheory.ShortComplex.LeftHomologyData.ofHasKernelOfHasCokernel S).i (CategoryTheory.Limits.kernel.Œπ S.g)","decl":"/-- The chosen kernels and cokernels of the limits API give a `LeftHomologyData` -/\n@[simps]\nnoncomputable def ofHasKernelOfHasCokernel\n    [HasKernel S.g] [HasCokernel (kernel.lift S.g S.f S.zero)] :\n    S.LeftHomologyData where\n  K := kernel S.g\n  H := cokernel (kernel.lift S.g S.f S.zero)\n  i := kernel.Œπ _\n  œÄ := cokernel.œÄ _\n  wi := kernel.condition _\n  hi := kernelIsKernel _\n  wœÄ := cokernel.condition _\n  hœÄ := cokernelIsCokernel _\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.ofHasKernelOfHasCokernel_K","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬≥ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst‚úù¬π : CategoryTheory.Limits.HasKernel S.g\ninst‚úù : CategoryTheory.Limits.HasCokernel (CategoryTheory.Limits.kernel.lift S.g S.f ‚ãØ)\n‚ä¢ Eq (CategoryTheory.ShortComplex.LeftHomologyData.ofHasKernelOfHasCokernel S).K (CategoryTheory.Limits.kernel S.g)","decl":"/-- The chosen kernels and cokernels of the limits API give a `LeftHomologyData` -/\n@[simps]\nnoncomputable def ofHasKernelOfHasCokernel\n    [HasKernel S.g] [HasCokernel (kernel.lift S.g S.f S.zero)] :\n    S.LeftHomologyData where\n  K := kernel S.g\n  H := cokernel (kernel.lift S.g S.f S.zero)\n  i := kernel.Œπ _\n  œÄ := cokernel.œÄ _\n  wi := kernel.condition _\n  hi := kernelIsKernel _\n  wœÄ := cokernel.condition _\n  hœÄ := cokernelIsCokernel _\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.ofHasKernelOfHasCokernel_H","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬≥ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst‚úù¬π : CategoryTheory.Limits.HasKernel S.g\ninst‚úù : CategoryTheory.Limits.HasCokernel (CategoryTheory.Limits.kernel.lift S.g S.f ‚ãØ)\n‚ä¢ Eq (CategoryTheory.ShortComplex.LeftHomologyData.ofHasKernelOfHasCokernel S).H (CategoryTheory.Limits.cokernel (CategoryTheory.Limits.kernel.lift S.g S.f ‚ãØ))","decl":"/-- The chosen kernels and cokernels of the limits API give a `LeftHomologyData` -/\n@[simps]\nnoncomputable def ofHasKernelOfHasCokernel\n    [HasKernel S.g] [HasCokernel (kernel.lift S.g S.f S.zero)] :\n    S.LeftHomologyData where\n  K := kernel S.g\n  H := cokernel (kernel.lift S.g S.f S.zero)\n  i := kernel.Œπ _\n  œÄ := cokernel.œÄ _\n  wi := kernel.condition _\n  hi := kernelIsKernel _\n  wœÄ := cokernel.condition _\n  hœÄ := cokernelIsCokernel _\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.ofHasKernelOfHasCokernel_œÄ","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬≥ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst‚úù¬π : CategoryTheory.Limits.HasKernel S.g\ninst‚úù : CategoryTheory.Limits.HasCokernel (CategoryTheory.Limits.kernel.lift S.g S.f ‚ãØ)\n‚ä¢ Eq (CategoryTheory.ShortComplex.LeftHomologyData.ofHasKernelOfHasCokernel S).œÄ (CategoryTheory.Limits.cokernel.œÄ (CategoryTheory.Limits.kernel.lift S.g S.f ‚ãØ))","decl":"/-- The chosen kernels and cokernels of the limits API give a `LeftHomologyData` -/\n@[simps]\nnoncomputable def ofHasKernelOfHasCokernel\n    [HasKernel S.g] [HasCokernel (kernel.lift S.g S.f S.zero)] :\n    S.LeftHomologyData where\n  K := kernel S.g\n  H := cokernel (kernel.lift S.g S.f S.zero)\n  i := kernel.Œπ _\n  œÄ := cokernel.œÄ _\n  wi := kernel.condition _\n  hi := kernelIsKernel _\n  wœÄ := cokernel.condition _\n  hœÄ := cokernelIsCokernel _\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.wi_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nself : S.LeftHomologyData\nZ : C\nh : Quiver.Hom S.X‚ÇÉ Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp self.i (CategoryTheory.CategoryStruct.comp S.g h)) (CategoryTheory.CategoryStruct.comp 0 h)","decl":"attribute [reassoc (attr := simp)] wi wœÄ\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.wœÄ_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nself : S.LeftHomologyData\nZ : C\nh : Quiver.Hom self.H Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (self.hi.lift (CategoryTheory.Limits.KernelFork.ofŒπ S.f ‚ãØ)) (CategoryTheory.CategoryStruct.comp self.œÄ h)) (CategoryTheory.CategoryStruct.comp 0 h)","decl":"attribute [reassoc (attr := simp)] wi wœÄ\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.instMonoI","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nh : S.LeftHomologyData\n‚ä¢ CategoryTheory.Mono h.i","decl":"instance : Mono h.i := ‚ü®fun _ _ => Fork.IsLimit.hom_ext h.hi‚ü©\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.instEpiœÄ","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nh : S.LeftHomologyData\n‚ä¢ CategoryTheory.Epi h.œÄ","decl":"instance : Epi h.œÄ := ‚ü®fun _ _ => Cofork.IsColimit.hom_ext h.hœÄ‚ü©\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.liftK_i","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nh : S.LeftHomologyData\nA : C\nk : Quiver.Hom A S.X‚ÇÇ\nhk : Eq (CategoryTheory.CategoryStruct.comp k S.g) 0\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (h.liftK k hk) h.i) k","decl":"@[reassoc (attr := simp)]\nlemma liftK_i (k : A ‚ü∂ S.X‚ÇÇ) (hk : k ‚â´ S.g = 0) : h.liftK k hk ‚â´ h.i = k :=\n  h.hi.fac _ WalkingParallelPair.zero\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.liftK_i_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nh‚úù : S.LeftHomologyData\nA : C\nk : Quiver.Hom A S.X‚ÇÇ\nhk : Eq (CategoryTheory.CategoryStruct.comp k S.g) 0\nZ : C\nh : Quiver.Hom S.X‚ÇÇ Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (h‚úù.liftK k hk) (CategoryTheory.CategoryStruct.comp h‚úù.i h)) (CategoryTheory.CategoryStruct.comp k h)","decl":"@[reassoc (attr := simp)]\nlemma liftK_i (k : A ‚ü∂ S.X‚ÇÇ) (hk : k ‚â´ S.g = 0) : h.liftK k hk ‚â´ h.i = k :=\n  h.hi.fac _ WalkingParallelPair.zero\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.f'_i","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nh : S.LeftHomologyData\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp h.f' h.i) S.f","decl":"@[reassoc (attr := simp)] lemma f'_i : h.f' ‚â´ h.i = S.f := liftK_i _ _ _\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.f'_i_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nh‚úù : S.LeftHomologyData\nZ : C\nh : Quiver.Hom S.X‚ÇÇ Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp h‚úù.f' (CategoryTheory.CategoryStruct.comp h‚úù.i h)) (CategoryTheory.CategoryStruct.comp S.f h)","decl":"@[reassoc (attr := simp)] lemma f'_i : h.f' ‚â´ h.i = S.f := liftK_i _ _ _\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.f'_œÄ","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nh : S.LeftHomologyData\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp h.f' h.œÄ) 0","decl":"@[reassoc (attr := simp)] lemma f'_œÄ : h.f' ‚â´ h.œÄ = 0 := h.wœÄ\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.f'_œÄ_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nh‚úù : S.LeftHomologyData\nZ : C\nh : Quiver.Hom h‚úù.H Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp h‚úù.f' (CategoryTheory.CategoryStruct.comp h‚úù.œÄ h)) (CategoryTheory.CategoryStruct.comp 0 h)","decl":"@[reassoc (attr := simp)] lemma f'_œÄ : h.f' ‚â´ h.œÄ = 0 := h.wœÄ\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.liftK_œÄ_eq_zero_of_boundary","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nh : S.LeftHomologyData\nA : C\nk : Quiver.Hom A S.X‚ÇÇ\nx : Quiver.Hom A S.X‚ÇÅ\nhx : Eq k (CategoryTheory.CategoryStruct.comp x S.f)\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (h.liftK k ‚ãØ) h.œÄ) 0","decl":"@[reassoc]\nlemma liftK_œÄ_eq_zero_of_boundary (k : A ‚ü∂ S.X‚ÇÇ) (x : A ‚ü∂ S.X‚ÇÅ) (hx : k = x ‚â´ S.f) :\n    h.liftK k (by rw [hx, assoc, S.zero, comp_zero]) ‚â´ h.œÄ = 0 := by\n  rw [show 0 = (x ‚â´ h.f') ‚â´ h.œÄ by simp]\n  congr 1\n  simp only [‚Üê cancel_mono h.i, hx, liftK_i, assoc, f'_i]\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.liftK_œÄ_eq_zero_of_boundary_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nh‚úù : S.LeftHomologyData\nA : C\nk : Quiver.Hom A S.X‚ÇÇ\nx : Quiver.Hom A S.X‚ÇÅ\nhx : Eq k (CategoryTheory.CategoryStruct.comp x S.f)\nZ : C\nh : Quiver.Hom h‚úù.H Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (h‚úù.liftK k ‚ãØ) (CategoryTheory.CategoryStruct.comp h‚úù.œÄ h)) (CategoryTheory.CategoryStruct.comp 0 h)","decl":"@[reassoc]\nlemma liftK_œÄ_eq_zero_of_boundary (k : A ‚ü∂ S.X‚ÇÇ) (x : A ‚ü∂ S.X‚ÇÅ) (hx : k = x ‚â´ S.f) :\n    h.liftK k (by rw [hx, assoc, S.zero, comp_zero]) ‚â´ h.œÄ = 0 := by\n  rw [show 0 = (x ‚â´ h.f') ‚â´ h.œÄ by simp]\n  congr 1\n  simp only [‚Üê cancel_mono h.i, hx, liftK_i, assoc, f'_i]\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.œÄ_descH_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nh‚úù : S.LeftHomologyData\nA : C\nk : Quiver.Hom h‚úù.K A\nhk : Eq (CategoryTheory.CategoryStruct.comp h‚úù.f' k) 0\nZ : C\nh : Quiver.Hom A Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp h‚úù.œÄ (CategoryTheory.CategoryStruct.comp (h‚úù.descH k hk) h)) (CategoryTheory.CategoryStruct.comp k h)","decl":"@[reassoc (attr := simp)]\nlemma œÄ_descH (k : h.K ‚ü∂ A) (hk : h.f' ‚â´ k = 0) : h.œÄ ‚â´ h.descH k hk = k :=\n  h.hœÄ.fac (CokernelCofork.ofœÄ k hk) WalkingParallelPair.one\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.œÄ_descH","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nh : S.LeftHomologyData\nA : C\nk : Quiver.Hom h.K A\nhk : Eq (CategoryTheory.CategoryStruct.comp h.f' k) 0\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp h.œÄ (h.descH k hk)) k","decl":"@[reassoc (attr := simp)]\nlemma œÄ_descH (k : h.K ‚ü∂ A) (hk : h.f' ‚â´ k = 0) : h.œÄ ‚â´ h.descH k hk = k :=\n  h.hœÄ.fac (CokernelCofork.ofœÄ k hk) WalkingParallelPair.one\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.isIso_i","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nh : S.LeftHomologyData\nhg : Eq S.g 0\n‚ä¢ CategoryTheory.IsIso h.i","decl":"lemma isIso_i (hg : S.g = 0) : IsIso h.i :=\n  ‚ü®h.liftK (ùüô S.X‚ÇÇ) (by rw [hg, id_comp]),\n    by simp only [‚Üê cancel_mono h.i, id_comp, assoc, liftK_i, comp_id], liftK_i _ _ _‚ü©\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.isIso_œÄ","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nh : S.LeftHomologyData\nhf : Eq S.f 0\n‚ä¢ CategoryTheory.IsIso h.œÄ","decl":"lemma isIso_œÄ (hf : S.f = 0) : IsIso h.œÄ := by\n  have ‚ü®œÜ, hœÜ‚ü© := CokernelCofork.IsColimit.desc' h.hœÄ' (ùüô _)\n    (by rw [‚Üê cancel_mono h.i, comp_id, f'_i, zero_comp, hf])\n  dsimp at hœÜ\n  exact ‚ü®œÜ, hœÜ, by rw [‚Üê cancel_epi h.œÄ, reassoc_of% hœÜ, comp_id]‚ü©\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.ofIsColimitCokernelCofork_i","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nhg : Eq S.g 0\nc : CategoryTheory.Limits.CokernelCofork S.f\nhc : CategoryTheory.Limits.IsColimit c\n‚ä¢ Eq (CategoryTheory.ShortComplex.LeftHomologyData.ofIsColimitCokernelCofork S hg c hc).i (CategoryTheory.CategoryStruct.id S.X‚ÇÇ)","decl":"/-- When the second map `S.g` is zero, this is the left homology data on `S` given\nby any colimit cokernel cofork of `S.f` -/\n@[simps]\ndef ofIsColimitCokernelCofork (hg : S.g = 0) (c : CokernelCofork S.f) (hc : IsColimit c) :\n    S.LeftHomologyData where\n  K := S.X‚ÇÇ\n  H := c.pt\n  i := ùüô _\n  œÄ := c.œÄ\n  wi := by rw [id_comp, hg]\n  hi := KernelFork.IsLimit.ofId _ hg\n  wœÄ := CokernelCofork.condition _\n  hœÄ := IsColimit.ofIsoColimit hc (Cofork.ext (Iso.refl _))\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.ofIsColimitCokernelCofork_H","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nhg : Eq S.g 0\nc : CategoryTheory.Limits.CokernelCofork S.f\nhc : CategoryTheory.Limits.IsColimit c\n‚ä¢ Eq (CategoryTheory.ShortComplex.LeftHomologyData.ofIsColimitCokernelCofork S hg c hc).H c.pt","decl":"/-- When the second map `S.g` is zero, this is the left homology data on `S` given\nby any colimit cokernel cofork of `S.f` -/\n@[simps]\ndef ofIsColimitCokernelCofork (hg : S.g = 0) (c : CokernelCofork S.f) (hc : IsColimit c) :\n    S.LeftHomologyData where\n  K := S.X‚ÇÇ\n  H := c.pt\n  i := ùüô _\n  œÄ := c.œÄ\n  wi := by rw [id_comp, hg]\n  hi := KernelFork.IsLimit.ofId _ hg\n  wœÄ := CokernelCofork.condition _\n  hœÄ := IsColimit.ofIsoColimit hc (Cofork.ext (Iso.refl _))\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.ofIsColimitCokernelCofork_œÄ","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nhg : Eq S.g 0\nc : CategoryTheory.Limits.CokernelCofork S.f\nhc : CategoryTheory.Limits.IsColimit c\n‚ä¢ Eq (CategoryTheory.ShortComplex.LeftHomologyData.ofIsColimitCokernelCofork S hg c hc).œÄ (CategoryTheory.Limits.Cofork.œÄ c)","decl":"/-- When the second map `S.g` is zero, this is the left homology data on `S` given\nby any colimit cokernel cofork of `S.f` -/\n@[simps]\ndef ofIsColimitCokernelCofork (hg : S.g = 0) (c : CokernelCofork S.f) (hc : IsColimit c) :\n    S.LeftHomologyData where\n  K := S.X‚ÇÇ\n  H := c.pt\n  i := ùüô _\n  œÄ := c.œÄ\n  wi := by rw [id_comp, hg]\n  hi := KernelFork.IsLimit.ofId _ hg\n  wœÄ := CokernelCofork.condition _\n  hœÄ := IsColimit.ofIsoColimit hc (Cofork.ext (Iso.refl _))\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.ofIsColimitCokernelCofork_K","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nhg : Eq S.g 0\nc : CategoryTheory.Limits.CokernelCofork S.f\nhc : CategoryTheory.Limits.IsColimit c\n‚ä¢ Eq (CategoryTheory.ShortComplex.LeftHomologyData.ofIsColimitCokernelCofork S hg c hc).K S.X‚ÇÇ","decl":"/-- When the second map `S.g` is zero, this is the left homology data on `S` given\nby any colimit cokernel cofork of `S.f` -/\n@[simps]\ndef ofIsColimitCokernelCofork (hg : S.g = 0) (c : CokernelCofork S.f) (hc : IsColimit c) :\n    S.LeftHomologyData where\n  K := S.X‚ÇÇ\n  H := c.pt\n  i := ùüô _\n  œÄ := c.œÄ\n  wi := by rw [id_comp, hg]\n  hi := KernelFork.IsLimit.ofId _ hg\n  wœÄ := CokernelCofork.condition _\n  hœÄ := IsColimit.ofIsoColimit hc (Cofork.ext (Iso.refl _))\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.ofIsColimitCokernelCofork_f'","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nhg : Eq S.g 0\nc : CategoryTheory.Limits.CokernelCofork S.f\nhc : CategoryTheory.Limits.IsColimit c\n‚ä¢ Eq (CategoryTheory.ShortComplex.LeftHomologyData.ofIsColimitCokernelCofork S hg c hc).f' S.f","decl":"@[simp] lemma ofIsColimitCokernelCofork_f' (hg : S.g = 0) (c : CokernelCofork S.f)\n    (hc : IsColimit c) : (ofIsColimitCokernelCofork S hg c hc).f' = S.f := by\n  rw [‚Üê cancel_mono (ofIsColimitCokernelCofork S hg c hc).i, f'_i,\n    ofIsColimitCokernelCofork_i]\n  dsimp\n  rw [comp_id]\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.ofHasCokernel_H","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst‚úù : CategoryTheory.Limits.HasCokernel S.f\nhg : Eq S.g 0\n‚ä¢ Eq (CategoryTheory.ShortComplex.LeftHomologyData.ofHasCokernel S hg).H (CategoryTheory.Limits.cokernel S.f)","decl":"/-- When the second map `S.g` is zero, this is the left homology data on `S` given by\nthe chosen `cokernel S.f` -/\n@[simps!]\nnoncomputable def ofHasCokernel [HasCokernel S.f] (hg : S.g = 0) : S.LeftHomologyData :=\n  ofIsColimitCokernelCofork S hg _ (cokernelIsCokernel _)\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.ofHasCokernel_œÄ","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst‚úù : CategoryTheory.Limits.HasCokernel S.f\nhg : Eq S.g 0\n‚ä¢ Eq (CategoryTheory.ShortComplex.LeftHomologyData.ofHasCokernel S hg).œÄ (CategoryTheory.Limits.cokernel.œÄ S.f)","decl":"/-- When the second map `S.g` is zero, this is the left homology data on `S` given by\nthe chosen `cokernel S.f` -/\n@[simps!]\nnoncomputable def ofHasCokernel [HasCokernel S.f] (hg : S.g = 0) : S.LeftHomologyData :=\n  ofIsColimitCokernelCofork S hg _ (cokernelIsCokernel _)\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.ofHasCokernel_K","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst‚úù : CategoryTheory.Limits.HasCokernel S.f\nhg : Eq S.g 0\n‚ä¢ Eq (CategoryTheory.ShortComplex.LeftHomologyData.ofHasCokernel S hg).K S.X‚ÇÇ","decl":"/-- When the second map `S.g` is zero, this is the left homology data on `S` given by\nthe chosen `cokernel S.f` -/\n@[simps!]\nnoncomputable def ofHasCokernel [HasCokernel S.f] (hg : S.g = 0) : S.LeftHomologyData :=\n  ofIsColimitCokernelCofork S hg _ (cokernelIsCokernel _)\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.ofHasCokernel_i","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst‚úù : CategoryTheory.Limits.HasCokernel S.f\nhg : Eq S.g 0\n‚ä¢ Eq (CategoryTheory.ShortComplex.LeftHomologyData.ofHasCokernel S hg).i (CategoryTheory.CategoryStruct.id S.X‚ÇÇ)","decl":"/-- When the second map `S.g` is zero, this is the left homology data on `S` given by\nthe chosen `cokernel S.f` -/\n@[simps!]\nnoncomputable def ofHasCokernel [HasCokernel S.f] (hg : S.g = 0) : S.LeftHomologyData :=\n  ofIsColimitCokernelCofork S hg _ (cokernelIsCokernel _)\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.ofIsLimitKernelFork_H","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nhf : Eq S.f 0\nc : CategoryTheory.Limits.KernelFork S.g\nhc : CategoryTheory.Limits.IsLimit c\n‚ä¢ Eq (CategoryTheory.ShortComplex.LeftHomologyData.ofIsLimitKernelFork S hf c hc).H c.pt","decl":"/-- When the first map `S.f` is zero, this is the left homology data on `S` given\nby any limit kernel fork of `S.g` -/\n@[simps]\ndef ofIsLimitKernelFork (hf : S.f = 0) (c : KernelFork S.g) (hc : IsLimit c) :\n    S.LeftHomologyData where\n  K := c.pt\n  H := c.pt\n  i := c.Œπ\n  œÄ := ùüô _\n  wi := KernelFork.condition _\n  hi := IsLimit.ofIsoLimit hc (Fork.ext (Iso.refl _))\n  wœÄ := Fork.IsLimit.hom_ext hc (by\n    dsimp\n    simp only [comp_id, zero_comp, Fork.IsLimit.lift_Œπ, Fork.Œπ_ofŒπ, hf])\n  hœÄ := CokernelCofork.IsColimit.ofId _ (Fork.IsLimit.hom_ext hc (by\n    dsimp\n    simp only [comp_id, zero_comp, Fork.IsLimit.lift_Œπ, Fork.Œπ_ofŒπ, hf]))\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.ofIsLimitKernelFork_K","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nhf : Eq S.f 0\nc : CategoryTheory.Limits.KernelFork S.g\nhc : CategoryTheory.Limits.IsLimit c\n‚ä¢ Eq (CategoryTheory.ShortComplex.LeftHomologyData.ofIsLimitKernelFork S hf c hc).K c.pt","decl":"/-- When the first map `S.f` is zero, this is the left homology data on `S` given\nby any limit kernel fork of `S.g` -/\n@[simps]\ndef ofIsLimitKernelFork (hf : S.f = 0) (c : KernelFork S.g) (hc : IsLimit c) :\n    S.LeftHomologyData where\n  K := c.pt\n  H := c.pt\n  i := c.Œπ\n  œÄ := ùüô _\n  wi := KernelFork.condition _\n  hi := IsLimit.ofIsoLimit hc (Fork.ext (Iso.refl _))\n  wœÄ := Fork.IsLimit.hom_ext hc (by\n    dsimp\n    simp only [comp_id, zero_comp, Fork.IsLimit.lift_Œπ, Fork.Œπ_ofŒπ, hf])\n  hœÄ := CokernelCofork.IsColimit.ofId _ (Fork.IsLimit.hom_ext hc (by\n    dsimp\n    simp only [comp_id, zero_comp, Fork.IsLimit.lift_Œπ, Fork.Œπ_ofŒπ, hf]))\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.ofIsLimitKernelFork_i","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nhf : Eq S.f 0\nc : CategoryTheory.Limits.KernelFork S.g\nhc : CategoryTheory.Limits.IsLimit c\n‚ä¢ Eq (CategoryTheory.ShortComplex.LeftHomologyData.ofIsLimitKernelFork S hf c hc).i (CategoryTheory.Limits.Fork.Œπ c)","decl":"/-- When the first map `S.f` is zero, this is the left homology data on `S` given\nby any limit kernel fork of `S.g` -/\n@[simps]\ndef ofIsLimitKernelFork (hf : S.f = 0) (c : KernelFork S.g) (hc : IsLimit c) :\n    S.LeftHomologyData where\n  K := c.pt\n  H := c.pt\n  i := c.Œπ\n  œÄ := ùüô _\n  wi := KernelFork.condition _\n  hi := IsLimit.ofIsoLimit hc (Fork.ext (Iso.refl _))\n  wœÄ := Fork.IsLimit.hom_ext hc (by\n    dsimp\n    simp only [comp_id, zero_comp, Fork.IsLimit.lift_Œπ, Fork.Œπ_ofŒπ, hf])\n  hœÄ := CokernelCofork.IsColimit.ofId _ (Fork.IsLimit.hom_ext hc (by\n    dsimp\n    simp only [comp_id, zero_comp, Fork.IsLimit.lift_Œπ, Fork.Œπ_ofŒπ, hf]))\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.ofIsLimitKernelFork_œÄ","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nhf : Eq S.f 0\nc : CategoryTheory.Limits.KernelFork S.g\nhc : CategoryTheory.Limits.IsLimit c\n‚ä¢ Eq (CategoryTheory.ShortComplex.LeftHomologyData.ofIsLimitKernelFork S hf c hc).œÄ (CategoryTheory.CategoryStruct.id c.pt)","decl":"/-- When the first map `S.f` is zero, this is the left homology data on `S` given\nby any limit kernel fork of `S.g` -/\n@[simps]\ndef ofIsLimitKernelFork (hf : S.f = 0) (c : KernelFork S.g) (hc : IsLimit c) :\n    S.LeftHomologyData where\n  K := c.pt\n  H := c.pt\n  i := c.Œπ\n  œÄ := ùüô _\n  wi := KernelFork.condition _\n  hi := IsLimit.ofIsoLimit hc (Fork.ext (Iso.refl _))\n  wœÄ := Fork.IsLimit.hom_ext hc (by\n    dsimp\n    simp only [comp_id, zero_comp, Fork.IsLimit.lift_Œπ, Fork.Œπ_ofŒπ, hf])\n  hœÄ := CokernelCofork.IsColimit.ofId _ (Fork.IsLimit.hom_ext hc (by\n    dsimp\n    simp only [comp_id, zero_comp, Fork.IsLimit.lift_Œπ, Fork.Œπ_ofŒπ, hf]))\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.ofIsLimitKernelFork_f'","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nhf : Eq S.f 0\nc : CategoryTheory.Limits.KernelFork S.g\nhc : CategoryTheory.Limits.IsLimit c\n‚ä¢ Eq (CategoryTheory.ShortComplex.LeftHomologyData.ofIsLimitKernelFork S hf c hc).f' 0","decl":"@[simp] lemma ofIsLimitKernelFork_f' (hf : S.f = 0) (c : KernelFork S.g) (hc : IsLimit c) :\n    (ofIsLimitKernelFork S hf c hc).f' = 0 := by\n  rw [‚Üê cancel_mono (ofIsLimitKernelFork S hf c hc).i, f'_i, hf, zero_comp]\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.ofZeros_H","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nhf : Eq S.f 0\nhg : Eq S.g 0\n‚ä¢ Eq (CategoryTheory.ShortComplex.LeftHomologyData.ofZeros S hf hg).H S.X‚ÇÇ","decl":"/-- When both `S.f` and `S.g` are zero, the middle object `S.X‚ÇÇ` gives a left homology data on S -/\n@[simps]\ndef ofZeros (hf : S.f = 0) (hg : S.g = 0) : S.LeftHomologyData where\n  K := S.X‚ÇÇ\n  H := S.X‚ÇÇ\n  i := ùüô _\n  œÄ := ùüô _\n  wi := by rw [id_comp, hg]\n  hi := KernelFork.IsLimit.ofId _ hg\n  wœÄ := by\n    change S.f ‚â´ ùüô _ = 0\n    simp only [hf, zero_comp]\n  hœÄ := CokernelCofork.IsColimit.ofId _ hf\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.ofZeros_K","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nhf : Eq S.f 0\nhg : Eq S.g 0\n‚ä¢ Eq (CategoryTheory.ShortComplex.LeftHomologyData.ofZeros S hf hg).K S.X‚ÇÇ","decl":"/-- When both `S.f` and `S.g` are zero, the middle object `S.X‚ÇÇ` gives a left homology data on S -/\n@[simps]\ndef ofZeros (hf : S.f = 0) (hg : S.g = 0) : S.LeftHomologyData where\n  K := S.X‚ÇÇ\n  H := S.X‚ÇÇ\n  i := ùüô _\n  œÄ := ùüô _\n  wi := by rw [id_comp, hg]\n  hi := KernelFork.IsLimit.ofId _ hg\n  wœÄ := by\n    change S.f ‚â´ ùüô _ = 0\n    simp only [hf, zero_comp]\n  hœÄ := CokernelCofork.IsColimit.ofId _ hf\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.ofZeros_œÄ","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nhf : Eq S.f 0\nhg : Eq S.g 0\n‚ä¢ Eq (CategoryTheory.ShortComplex.LeftHomologyData.ofZeros S hf hg).œÄ (CategoryTheory.CategoryStruct.id S.X‚ÇÇ)","decl":"/-- When both `S.f` and `S.g` are zero, the middle object `S.X‚ÇÇ` gives a left homology data on S -/\n@[simps]\ndef ofZeros (hf : S.f = 0) (hg : S.g = 0) : S.LeftHomologyData where\n  K := S.X‚ÇÇ\n  H := S.X‚ÇÇ\n  i := ùüô _\n  œÄ := ùüô _\n  wi := by rw [id_comp, hg]\n  hi := KernelFork.IsLimit.ofId _ hg\n  wœÄ := by\n    change S.f ‚â´ ùüô _ = 0\n    simp only [hf, zero_comp]\n  hœÄ := CokernelCofork.IsColimit.ofId _ hf\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.ofZeros_i","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nhf : Eq S.f 0\nhg : Eq S.g 0\n‚ä¢ Eq (CategoryTheory.ShortComplex.LeftHomologyData.ofZeros S hf hg).i (CategoryTheory.CategoryStruct.id S.X‚ÇÇ)","decl":"/-- When both `S.f` and `S.g` are zero, the middle object `S.X‚ÇÇ` gives a left homology data on S -/\n@[simps]\ndef ofZeros (hf : S.f = 0) (hg : S.g = 0) : S.LeftHomologyData where\n  K := S.X‚ÇÇ\n  H := S.X‚ÇÇ\n  i := ùüô _\n  œÄ := ùüô _\n  wi := by rw [id_comp, hg]\n  hi := KernelFork.IsLimit.ofId _ hg\n  wœÄ := by\n    change S.f ‚â´ ùüô _ = 0\n    simp only [hf, zero_comp]\n  hœÄ := CokernelCofork.IsColimit.ofId _ hf\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.ofZeros_f'","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nhf : Eq S.f 0\nhg : Eq S.g 0\n‚ä¢ Eq (CategoryTheory.ShortComplex.LeftHomologyData.ofZeros S hf hg).f' 0","decl":"@[simp] lemma ofZeros_f' (hf : S.f = 0) (hg : S.g = 0) :\n    (ofZeros S hf hg).f' = 0 := by\n  rw [‚Üê cancel_mono ((ofZeros S hf hg).i), zero_comp, f'_i, hf]\n\n"}
{"name":"CategoryTheory.ShortComplex.HasLeftHomology.condition","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nself : S.HasLeftHomology\n‚ä¢ Nonempty S.LeftHomologyData","decl":"/-- A short complex `S` has left homology when there exists a `S.LeftHomologyData` -/\nclass HasLeftHomology : Prop where\n  condition : Nonempty S.LeftHomologyData\n\n"}
{"name":"CategoryTheory.ShortComplex.HasLeftHomology.mk'","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nh : S.LeftHomologyData\n‚ä¢ S.HasLeftHomology","decl":"lemma mk' (h : S.LeftHomologyData) : HasLeftHomology S := ‚ü®Nonempty.intro h‚ü©\n\n"}
{"name":"CategoryTheory.ShortComplex.HasLeftHomology.of_hasKernel_of_hasCokernel","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬≥ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst‚úù¬π : CategoryTheory.Limits.HasKernel S.g\ninst‚úù : CategoryTheory.Limits.HasCokernel (CategoryTheory.Limits.kernel.lift S.g S.f ‚ãØ)\n‚ä¢ S.HasLeftHomology","decl":"instance of_hasKernel_of_hasCokernel [HasKernel S.g] [HasCokernel (kernel.lift S.g S.f S.zero)] :\n  S.HasLeftHomology := HasLeftHomology.mk' (LeftHomologyData.ofHasKernelOfHasCokernel S)\n\n"}
{"name":"CategoryTheory.ShortComplex.HasLeftHomology.of_hasCokernel","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf : Quiver.Hom X Y\nZ : C\ninst‚úù : CategoryTheory.Limits.HasCokernel f\n‚ä¢ (CategoryTheory.ShortComplex.mk f 0 ‚ãØ).HasLeftHomology","decl":"instance of_hasCokernel {X Y : C} (f : X ‚ü∂ Y) (Z : C) [HasCokernel f] :\n    (ShortComplex.mk f (0 : Y ‚ü∂ Z) comp_zero).HasLeftHomology :=\n  HasLeftHomology.mk' (LeftHomologyData.ofHasCokernel _ rfl)\n\n"}
{"name":"CategoryTheory.ShortComplex.HasLeftHomology.of_hasKernel","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms C\nY Z : C\ng : Quiver.Hom Y Z\nX : C\ninst‚úù : CategoryTheory.Limits.HasKernel g\n‚ä¢ (CategoryTheory.ShortComplex.mk 0 g ‚ãØ).HasLeftHomology","decl":"instance of_hasKernel {Y Z : C} (g : Y ‚ü∂ Z) (X : C) [HasKernel g] :\n    (ShortComplex.mk (0 : X ‚ü∂ Y) g zero_comp).HasLeftHomology :=\n  HasLeftHomology.mk' (LeftHomologyData.ofHasKernel _ rfl)\n\n"}
{"name":"CategoryTheory.ShortComplex.HasLeftHomology.of_zeros","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nX Y Z : C\n‚ä¢ (CategoryTheory.ShortComplex.mk 0 0 ‚ãØ).HasLeftHomology","decl":"instance of_zeros (X Y Z : C) :\n    (ShortComplex.mk (0 : X ‚ü∂ Y) (0 : Y ‚ü∂ Z) zero_comp).HasLeftHomology :=\n  HasLeftHomology.mk' (LeftHomologyData.ofZeros _ rfl rfl)\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyMapData.mk.sizeOf_spec","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms C\nS‚ÇÅ S‚ÇÇ : CategoryTheory.ShortComplex C\nœÜ : Quiver.Hom S‚ÇÅ S‚ÇÇ\nh‚ÇÅ : S‚ÇÅ.LeftHomologyData\nh‚ÇÇ : S‚ÇÇ.LeftHomologyData\ninst‚úù : SizeOf C\nœÜK : Quiver.Hom h‚ÇÅ.K h‚ÇÇ.K\nœÜH : Quiver.Hom h‚ÇÅ.H h‚ÇÇ.H\ncommi : autoParam (Eq (CategoryTheory.CategoryStruct.comp œÜK h‚ÇÇ.i) (CategoryTheory.CategoryStruct.comp h‚ÇÅ.i œÜ.œÑ‚ÇÇ)) _auto‚úù\ncommf' : autoParam (Eq (CategoryTheory.CategoryStruct.comp h‚ÇÅ.f' œÜK) (CategoryTheory.CategoryStruct.comp œÜ.œÑ‚ÇÅ h‚ÇÇ.f')) _auto‚úù\ncommœÄ : autoParam (Eq (CategoryTheory.CategoryStruct.comp h‚ÇÅ.œÄ œÜH) (CategoryTheory.CategoryStruct.comp œÜK h‚ÇÇ.œÄ)) _auto‚úù\n‚ä¢ Eq (SizeOf.sizeOf { œÜK := œÜK, œÜH := œÜH, commi := commi, commf' := commf', commœÄ := commœÄ }) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf œÜK)) (SizeOf.sizeOf œÜH)) (SizeOf.sizeOf commi)) (SizeOf.sizeOf commf')) (SizeOf.sizeOf commœÄ))","decl":"/-- Given left homology data `h‚ÇÅ` and `h‚ÇÇ` for two short complexes `S‚ÇÅ` and `S‚ÇÇ`,\na `LeftHomologyMapData` for a morphism `œÜ : S‚ÇÅ ‚ü∂ S‚ÇÇ`\nconsists of a description of the induced morphisms on the `K` (cycles)\nand `H` (left homology) fields of `h‚ÇÅ` and `h‚ÇÇ`. -/\nstructure LeftHomologyMapData where\n  /-- the induced map on cycles -/\n  œÜK : h‚ÇÅ.K ‚ü∂ h‚ÇÇ.K\n  /-- the induced map on left homology -/\n  œÜH : h‚ÇÅ.H ‚ü∂ h‚ÇÇ.H\n  /-- commutation with `i` -/\n  commi : œÜK ‚â´ h‚ÇÇ.i = h‚ÇÅ.i ‚â´ œÜ.œÑ‚ÇÇ := by aesop_cat\n  /-- commutation with `f'` -/\n  commf' : h‚ÇÅ.f' ‚â´ œÜK = œÜ.œÑ‚ÇÅ ‚â´ h‚ÇÇ.f' := by aesop_cat\n  /-- commutation with `œÄ` -/\n  commœÄ : h‚ÇÅ.œÄ ‚â´ œÜH = œÜK ‚â´ h‚ÇÇ.œÄ := by aesop_cat\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyMapData.mk.inj","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nS‚ÇÅ S‚ÇÇ : CategoryTheory.ShortComplex C\nœÜ : Quiver.Hom S‚ÇÅ S‚ÇÇ\nh‚ÇÅ : S‚ÇÅ.LeftHomologyData\nh‚ÇÇ : S‚ÇÇ.LeftHomologyData\nœÜK‚úù : Quiver.Hom h‚ÇÅ.K h‚ÇÇ.K\nœÜH‚úù : Quiver.Hom h‚ÇÅ.H h‚ÇÇ.H\ncommi‚úù : autoParam (Eq (CategoryTheory.CategoryStruct.comp œÜK‚úù h‚ÇÇ.i) (CategoryTheory.CategoryStruct.comp h‚ÇÅ.i œÜ.œÑ‚ÇÇ)) _auto‚úù\ncommf'‚úù : autoParam (Eq (CategoryTheory.CategoryStruct.comp h‚ÇÅ.f' œÜK‚úù) (CategoryTheory.CategoryStruct.comp œÜ.œÑ‚ÇÅ h‚ÇÇ.f')) _auto‚úù\ncommœÄ‚úù : autoParam (Eq (CategoryTheory.CategoryStruct.comp h‚ÇÅ.œÄ œÜH‚úù) (CategoryTheory.CategoryStruct.comp œÜK‚úù h‚ÇÇ.œÄ)) _auto‚úù\nœÜK : Quiver.Hom h‚ÇÅ.K h‚ÇÇ.K\nœÜH : Quiver.Hom h‚ÇÅ.H h‚ÇÇ.H\ncommi : autoParam (Eq (CategoryTheory.CategoryStruct.comp œÜK h‚ÇÇ.i) (CategoryTheory.CategoryStruct.comp h‚ÇÅ.i œÜ.œÑ‚ÇÇ)) _auto‚úù\ncommf' : autoParam (Eq (CategoryTheory.CategoryStruct.comp h‚ÇÅ.f' œÜK) (CategoryTheory.CategoryStruct.comp œÜ.œÑ‚ÇÅ h‚ÇÇ.f')) _auto‚úù\ncommœÄ : autoParam (Eq (CategoryTheory.CategoryStruct.comp h‚ÇÅ.œÄ œÜH) (CategoryTheory.CategoryStruct.comp œÜK h‚ÇÇ.œÄ)) _auto‚úù\nx‚úù : Eq { œÜK := œÜK‚úù, œÜH := œÜH‚úù, commi := commi‚úù, commf' := commf'‚úù, commœÄ := commœÄ‚úù } { œÜK := œÜK, œÜH := œÜH, commi := commi, commf' := commf', commœÄ := commœÄ }\n‚ä¢ And (Eq œÜK‚úù œÜK) (Eq œÜH‚úù œÜH)","decl":"/-- Given left homology data `h‚ÇÅ` and `h‚ÇÇ` for two short complexes `S‚ÇÅ` and `S‚ÇÇ`,\na `LeftHomologyMapData` for a morphism `œÜ : S‚ÇÅ ‚ü∂ S‚ÇÇ`\nconsists of a description of the induced morphisms on the `K` (cycles)\nand `H` (left homology) fields of `h‚ÇÅ` and `h‚ÇÇ`. -/\nstructure LeftHomologyMapData where\n  /-- the induced map on cycles -/\n  œÜK : h‚ÇÅ.K ‚ü∂ h‚ÇÇ.K\n  /-- the induced map on left homology -/\n  œÜH : h‚ÇÅ.H ‚ü∂ h‚ÇÇ.H\n  /-- commutation with `i` -/\n  commi : œÜK ‚â´ h‚ÇÇ.i = h‚ÇÅ.i ‚â´ œÜ.œÑ‚ÇÇ := by aesop_cat\n  /-- commutation with `f'` -/\n  commf' : h‚ÇÅ.f' ‚â´ œÜK = œÜ.œÑ‚ÇÅ ‚â´ h‚ÇÇ.f' := by aesop_cat\n  /-- commutation with `œÄ` -/\n  commœÄ : h‚ÇÅ.œÄ ‚â´ œÜH = œÜK ‚â´ h‚ÇÇ.œÄ := by aesop_cat\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyMapData.mk.injEq","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nS‚ÇÅ S‚ÇÇ : CategoryTheory.ShortComplex C\nœÜ : Quiver.Hom S‚ÇÅ S‚ÇÇ\nh‚ÇÅ : S‚ÇÅ.LeftHomologyData\nh‚ÇÇ : S‚ÇÇ.LeftHomologyData\nœÜK‚úù : Quiver.Hom h‚ÇÅ.K h‚ÇÇ.K\nœÜH‚úù : Quiver.Hom h‚ÇÅ.H h‚ÇÇ.H\ncommi‚úù : autoParam (Eq (CategoryTheory.CategoryStruct.comp œÜK‚úù h‚ÇÇ.i) (CategoryTheory.CategoryStruct.comp h‚ÇÅ.i œÜ.œÑ‚ÇÇ)) _auto‚úù\ncommf'‚úù : autoParam (Eq (CategoryTheory.CategoryStruct.comp h‚ÇÅ.f' œÜK‚úù) (CategoryTheory.CategoryStruct.comp œÜ.œÑ‚ÇÅ h‚ÇÇ.f')) _auto‚úù\ncommœÄ‚úù : autoParam (Eq (CategoryTheory.CategoryStruct.comp h‚ÇÅ.œÄ œÜH‚úù) (CategoryTheory.CategoryStruct.comp œÜK‚úù h‚ÇÇ.œÄ)) _auto‚úù\nœÜK : Quiver.Hom h‚ÇÅ.K h‚ÇÇ.K\nœÜH : Quiver.Hom h‚ÇÅ.H h‚ÇÇ.H\ncommi : autoParam (Eq (CategoryTheory.CategoryStruct.comp œÜK h‚ÇÇ.i) (CategoryTheory.CategoryStruct.comp h‚ÇÅ.i œÜ.œÑ‚ÇÇ)) _auto‚úù\ncommf' : autoParam (Eq (CategoryTheory.CategoryStruct.comp h‚ÇÅ.f' œÜK) (CategoryTheory.CategoryStruct.comp œÜ.œÑ‚ÇÅ h‚ÇÇ.f')) _auto‚úù\ncommœÄ : autoParam (Eq (CategoryTheory.CategoryStruct.comp h‚ÇÅ.œÄ œÜH) (CategoryTheory.CategoryStruct.comp œÜK h‚ÇÇ.œÄ)) _auto‚úù\n‚ä¢ Eq (Eq { œÜK := œÜK‚úù, œÜH := œÜH‚úù, commi := commi‚úù, commf' := commf'‚úù, commœÄ := commœÄ‚úù } { œÜK := œÜK, œÜH := œÜH, commi := commi, commf' := commf', commœÄ := commœÄ }) (And (Eq œÜK‚úù œÜK) (Eq œÜH‚úù œÜH))","decl":"/-- Given left homology data `h‚ÇÅ` and `h‚ÇÇ` for two short complexes `S‚ÇÅ` and `S‚ÇÇ`,\na `LeftHomologyMapData` for a morphism `œÜ : S‚ÇÅ ‚ü∂ S‚ÇÇ`\nconsists of a description of the induced morphisms on the `K` (cycles)\nand `H` (left homology) fields of `h‚ÇÅ` and `h‚ÇÇ`. -/\nstructure LeftHomologyMapData where\n  /-- the induced map on cycles -/\n  œÜK : h‚ÇÅ.K ‚ü∂ h‚ÇÇ.K\n  /-- the induced map on left homology -/\n  œÜH : h‚ÇÅ.H ‚ü∂ h‚ÇÇ.H\n  /-- commutation with `i` -/\n  commi : œÜK ‚â´ h‚ÇÇ.i = h‚ÇÅ.i ‚â´ œÜ.œÑ‚ÇÇ := by aesop_cat\n  /-- commutation with `f'` -/\n  commf' : h‚ÇÅ.f' ‚â´ œÜK = œÜ.œÑ‚ÇÅ ‚â´ h‚ÇÇ.f' := by aesop_cat\n  /-- commutation with `œÄ` -/\n  commœÄ : h‚ÇÅ.œÄ ‚â´ œÜH = œÜK ‚â´ h‚ÇÇ.œÄ := by aesop_cat\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyMapData.commf'","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nS‚ÇÅ S‚ÇÇ : CategoryTheory.ShortComplex C\nœÜ : Quiver.Hom S‚ÇÅ S‚ÇÇ\nh‚ÇÅ : S‚ÇÅ.LeftHomologyData\nh‚ÇÇ : S‚ÇÇ.LeftHomologyData\nself : CategoryTheory.ShortComplex.LeftHomologyMapData œÜ h‚ÇÅ h‚ÇÇ\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp h‚ÇÅ.f' self.œÜK) (CategoryTheory.CategoryStruct.comp œÜ.œÑ‚ÇÅ h‚ÇÇ.f')","decl":"/-- Given left homology data `h‚ÇÅ` and `h‚ÇÇ` for two short complexes `S‚ÇÅ` and `S‚ÇÇ`,\na `LeftHomologyMapData` for a morphism `œÜ : S‚ÇÅ ‚ü∂ S‚ÇÇ`\nconsists of a description of the induced morphisms on the `K` (cycles)\nand `H` (left homology) fields of `h‚ÇÅ` and `h‚ÇÇ`. -/\nstructure LeftHomologyMapData where\n  /-- the induced map on cycles -/\n  œÜK : h‚ÇÅ.K ‚ü∂ h‚ÇÇ.K\n  /-- the induced map on left homology -/\n  œÜH : h‚ÇÅ.H ‚ü∂ h‚ÇÇ.H\n  /-- commutation with `i` -/\n  commi : œÜK ‚â´ h‚ÇÇ.i = h‚ÇÅ.i ‚â´ œÜ.œÑ‚ÇÇ := by aesop_cat\n  /-- commutation with `f'` -/\n  commf' : h‚ÇÅ.f' ‚â´ œÜK = œÜ.œÑ‚ÇÅ ‚â´ h‚ÇÇ.f' := by aesop_cat\n  /-- commutation with `œÄ` -/\n  commœÄ : h‚ÇÅ.œÄ ‚â´ œÜH = œÜK ‚â´ h‚ÇÇ.œÄ := by aesop_cat\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyMapData.commœÄ","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nS‚ÇÅ S‚ÇÇ : CategoryTheory.ShortComplex C\nœÜ : Quiver.Hom S‚ÇÅ S‚ÇÇ\nh‚ÇÅ : S‚ÇÅ.LeftHomologyData\nh‚ÇÇ : S‚ÇÇ.LeftHomologyData\nself : CategoryTheory.ShortComplex.LeftHomologyMapData œÜ h‚ÇÅ h‚ÇÇ\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp h‚ÇÅ.œÄ self.œÜH) (CategoryTheory.CategoryStruct.comp self.œÜK h‚ÇÇ.œÄ)","decl":"/-- Given left homology data `h‚ÇÅ` and `h‚ÇÇ` for two short complexes `S‚ÇÅ` and `S‚ÇÇ`,\na `LeftHomologyMapData` for a morphism `œÜ : S‚ÇÅ ‚ü∂ S‚ÇÇ`\nconsists of a description of the induced morphisms on the `K` (cycles)\nand `H` (left homology) fields of `h‚ÇÅ` and `h‚ÇÇ`. -/\nstructure LeftHomologyMapData where\n  /-- the induced map on cycles -/\n  œÜK : h‚ÇÅ.K ‚ü∂ h‚ÇÇ.K\n  /-- the induced map on left homology -/\n  œÜH : h‚ÇÅ.H ‚ü∂ h‚ÇÇ.H\n  /-- commutation with `i` -/\n  commi : œÜK ‚â´ h‚ÇÇ.i = h‚ÇÅ.i ‚â´ œÜ.œÑ‚ÇÇ := by aesop_cat\n  /-- commutation with `f'` -/\n  commf' : h‚ÇÅ.f' ‚â´ œÜK = œÜ.œÑ‚ÇÅ ‚â´ h‚ÇÇ.f' := by aesop_cat\n  /-- commutation with `œÄ` -/\n  commœÄ : h‚ÇÅ.œÄ ‚â´ œÜH = œÜK ‚â´ h‚ÇÇ.œÄ := by aesop_cat\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyMapData.commi","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nS‚ÇÅ S‚ÇÇ : CategoryTheory.ShortComplex C\nœÜ : Quiver.Hom S‚ÇÅ S‚ÇÇ\nh‚ÇÅ : S‚ÇÅ.LeftHomologyData\nh‚ÇÇ : S‚ÇÇ.LeftHomologyData\nself : CategoryTheory.ShortComplex.LeftHomologyMapData œÜ h‚ÇÅ h‚ÇÇ\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp self.œÜK h‚ÇÇ.i) (CategoryTheory.CategoryStruct.comp h‚ÇÅ.i œÜ.œÑ‚ÇÇ)","decl":"/-- Given left homology data `h‚ÇÅ` and `h‚ÇÇ` for two short complexes `S‚ÇÅ` and `S‚ÇÇ`,\na `LeftHomologyMapData` for a morphism `œÜ : S‚ÇÅ ‚ü∂ S‚ÇÇ`\nconsists of a description of the induced morphisms on the `K` (cycles)\nand `H` (left homology) fields of `h‚ÇÅ` and `h‚ÇÇ`. -/\nstructure LeftHomologyMapData where\n  /-- the induced map on cycles -/\n  œÜK : h‚ÇÅ.K ‚ü∂ h‚ÇÇ.K\n  /-- the induced map on left homology -/\n  œÜH : h‚ÇÅ.H ‚ü∂ h‚ÇÇ.H\n  /-- commutation with `i` -/\n  commi : œÜK ‚â´ h‚ÇÇ.i = h‚ÇÅ.i ‚â´ œÜ.œÑ‚ÇÇ := by aesop_cat\n  /-- commutation with `f'` -/\n  commf' : h‚ÇÅ.f' ‚â´ œÜK = œÜ.œÑ‚ÇÅ ‚â´ h‚ÇÇ.f' := by aesop_cat\n  /-- commutation with `œÄ` -/\n  commœÄ : h‚ÇÅ.œÄ ‚â´ œÜH = œÜK ‚â´ h‚ÇÇ.œÄ := by aesop_cat\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyMapData.commœÄ_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nS‚ÇÅ S‚ÇÇ : CategoryTheory.ShortComplex C\nœÜ : Quiver.Hom S‚ÇÅ S‚ÇÇ\nh‚ÇÅ : S‚ÇÅ.LeftHomologyData\nh‚ÇÇ : S‚ÇÇ.LeftHomologyData\nself : CategoryTheory.ShortComplex.LeftHomologyMapData œÜ h‚ÇÅ h‚ÇÇ\nZ : C\nh : Quiver.Hom h‚ÇÇ.H Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp h‚ÇÅ.œÄ (CategoryTheory.CategoryStruct.comp self.œÜH h)) (CategoryTheory.CategoryStruct.comp self.œÜK (CategoryTheory.CategoryStruct.comp h‚ÇÇ.œÄ h))","decl":"attribute [reassoc (attr := simp)] commi commf' commœÄ\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyMapData.commi_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nS‚ÇÅ S‚ÇÇ : CategoryTheory.ShortComplex C\nœÜ : Quiver.Hom S‚ÇÅ S‚ÇÇ\nh‚ÇÅ : S‚ÇÅ.LeftHomologyData\nh‚ÇÇ : S‚ÇÇ.LeftHomologyData\nself : CategoryTheory.ShortComplex.LeftHomologyMapData œÜ h‚ÇÅ h‚ÇÇ\nZ : C\nh : Quiver.Hom S‚ÇÇ.X‚ÇÇ Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp self.œÜK (CategoryTheory.CategoryStruct.comp h‚ÇÇ.i h)) (CategoryTheory.CategoryStruct.comp h‚ÇÅ.i (CategoryTheory.CategoryStruct.comp œÜ.œÑ‚ÇÇ h))","decl":"attribute [reassoc (attr := simp)] commi commf' commœÄ\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyMapData.commf'_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nS‚ÇÅ S‚ÇÇ : CategoryTheory.ShortComplex C\nœÜ : Quiver.Hom S‚ÇÅ S‚ÇÇ\nh‚ÇÅ : S‚ÇÅ.LeftHomologyData\nh‚ÇÇ : S‚ÇÇ.LeftHomologyData\nself : CategoryTheory.ShortComplex.LeftHomologyMapData œÜ h‚ÇÅ h‚ÇÇ\nZ : C\nh : Quiver.Hom h‚ÇÇ.K Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp h‚ÇÅ.f' (CategoryTheory.CategoryStruct.comp self.œÜK h)) (CategoryTheory.CategoryStruct.comp œÜ.œÑ‚ÇÅ (CategoryTheory.CategoryStruct.comp h‚ÇÇ.f' h))","decl":"attribute [reassoc (attr := simp)] commi commf' commœÄ\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyMapData.zero_œÜK","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nS‚ÇÅ S‚ÇÇ : CategoryTheory.ShortComplex C\nh‚ÇÅ : S‚ÇÅ.LeftHomologyData\nh‚ÇÇ : S‚ÇÇ.LeftHomologyData\n‚ä¢ Eq (CategoryTheory.ShortComplex.LeftHomologyMapData.zero h‚ÇÅ h‚ÇÇ).œÜK 0","decl":"/-- The left homology map data associated to the zero morphism between two short complexes. -/\n@[simps]\ndef zero (h‚ÇÅ : S‚ÇÅ.LeftHomologyData) (h‚ÇÇ : S‚ÇÇ.LeftHomologyData) :\n    LeftHomologyMapData 0 h‚ÇÅ h‚ÇÇ where\n  œÜK := 0\n  œÜH := 0\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyMapData.zero_œÜH","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nS‚ÇÅ S‚ÇÇ : CategoryTheory.ShortComplex C\nh‚ÇÅ : S‚ÇÅ.LeftHomologyData\nh‚ÇÇ : S‚ÇÇ.LeftHomologyData\n‚ä¢ Eq (CategoryTheory.ShortComplex.LeftHomologyMapData.zero h‚ÇÅ h‚ÇÇ).œÜH 0","decl":"/-- The left homology map data associated to the zero morphism between two short complexes. -/\n@[simps]\ndef zero (h‚ÇÅ : S‚ÇÅ.LeftHomologyData) (h‚ÇÇ : S‚ÇÇ.LeftHomologyData) :\n    LeftHomologyMapData 0 h‚ÇÅ h‚ÇÇ where\n  œÜK := 0\n  œÜH := 0\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyMapData.id_œÜK","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nh : S.LeftHomologyData\n‚ä¢ Eq (CategoryTheory.ShortComplex.LeftHomologyMapData.id h).œÜK (CategoryTheory.CategoryStruct.id h.K)","decl":"/-- The left homology map data associated to the identity morphism of a short complex. -/\n@[simps]\ndef id (h : S.LeftHomologyData) : LeftHomologyMapData (ùüô S) h h where\n  œÜK := ùüô _\n  œÜH := ùüô _\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyMapData.id_œÜH","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nh : S.LeftHomologyData\n‚ä¢ Eq (CategoryTheory.ShortComplex.LeftHomologyMapData.id h).œÜH (CategoryTheory.CategoryStruct.id h.H)","decl":"/-- The left homology map data associated to the identity morphism of a short complex. -/\n@[simps]\ndef id (h : S.LeftHomologyData) : LeftHomologyMapData (ùüô S) h h where\n  œÜK := ùüô _\n  œÜH := ùüô _\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyMapData.comp_œÜK","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nS‚ÇÅ S‚ÇÇ S‚ÇÉ : CategoryTheory.ShortComplex C\nœÜ : Quiver.Hom S‚ÇÅ S‚ÇÇ\nœÜ' : Quiver.Hom S‚ÇÇ S‚ÇÉ\nh‚ÇÅ : S‚ÇÅ.LeftHomologyData\nh‚ÇÇ : S‚ÇÇ.LeftHomologyData\nh‚ÇÉ : S‚ÇÉ.LeftHomologyData\nœà : CategoryTheory.ShortComplex.LeftHomologyMapData œÜ h‚ÇÅ h‚ÇÇ\nœà' : CategoryTheory.ShortComplex.LeftHomologyMapData œÜ' h‚ÇÇ h‚ÇÉ\n‚ä¢ Eq (œà.comp œà').œÜK (CategoryTheory.CategoryStruct.comp œà.œÜK œà'.œÜK)","decl":"/-- The composition of left homology map data. -/\n@[simps]\ndef comp {œÜ : S‚ÇÅ ‚ü∂ S‚ÇÇ} {œÜ' : S‚ÇÇ ‚ü∂ S‚ÇÉ}\n    {h‚ÇÅ : S‚ÇÅ.LeftHomologyData} {h‚ÇÇ : S‚ÇÇ.LeftHomologyData} {h‚ÇÉ : S‚ÇÉ.LeftHomologyData}\n    (œà : LeftHomologyMapData œÜ h‚ÇÅ h‚ÇÇ) (œà' : LeftHomologyMapData œÜ' h‚ÇÇ h‚ÇÉ) :\n    LeftHomologyMapData (œÜ ‚â´ œÜ') h‚ÇÅ h‚ÇÉ where\n  œÜK := œà.œÜK ‚â´ œà'.œÜK\n  œÜH := œà.œÜH ‚â´ œà'.œÜH\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyMapData.comp_œÜH","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nS‚ÇÅ S‚ÇÇ S‚ÇÉ : CategoryTheory.ShortComplex C\nœÜ : Quiver.Hom S‚ÇÅ S‚ÇÇ\nœÜ' : Quiver.Hom S‚ÇÇ S‚ÇÉ\nh‚ÇÅ : S‚ÇÅ.LeftHomologyData\nh‚ÇÇ : S‚ÇÇ.LeftHomologyData\nh‚ÇÉ : S‚ÇÉ.LeftHomologyData\nœà : CategoryTheory.ShortComplex.LeftHomologyMapData œÜ h‚ÇÅ h‚ÇÇ\nœà' : CategoryTheory.ShortComplex.LeftHomologyMapData œÜ' h‚ÇÇ h‚ÇÉ\n‚ä¢ Eq (œà.comp œà').œÜH (CategoryTheory.CategoryStruct.comp œà.œÜH œà'.œÜH)","decl":"/-- The composition of left homology map data. -/\n@[simps]\ndef comp {œÜ : S‚ÇÅ ‚ü∂ S‚ÇÇ} {œÜ' : S‚ÇÇ ‚ü∂ S‚ÇÉ}\n    {h‚ÇÅ : S‚ÇÅ.LeftHomologyData} {h‚ÇÇ : S‚ÇÇ.LeftHomologyData} {h‚ÇÉ : S‚ÇÉ.LeftHomologyData}\n    (œà : LeftHomologyMapData œÜ h‚ÇÅ h‚ÇÇ) (œà' : LeftHomologyMapData œÜ' h‚ÇÇ h‚ÇÉ) :\n    LeftHomologyMapData (œÜ ‚â´ œÜ') h‚ÇÅ h‚ÇÉ where\n  œÜK := œà.œÜK ‚â´ œà'.œÜK\n  œÜH := œà.œÜH ‚â´ œà'.œÜH\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyMapData.instSubsingleton","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nS‚ÇÅ S‚ÇÇ : CategoryTheory.ShortComplex C\nœÜ : Quiver.Hom S‚ÇÅ S‚ÇÇ\nh‚ÇÅ : S‚ÇÅ.LeftHomologyData\nh‚ÇÇ : S‚ÇÇ.LeftHomologyData\n‚ä¢ Subsingleton (CategoryTheory.ShortComplex.LeftHomologyMapData œÜ h‚ÇÅ h‚ÇÇ)","decl":"instance : Subsingleton (LeftHomologyMapData œÜ h‚ÇÅ h‚ÇÇ) :=\n  ‚ü®fun œà‚ÇÅ œà‚ÇÇ => by\n    have hK : œà‚ÇÅ.œÜK = œà‚ÇÇ.œÜK := by rw [‚Üê cancel_mono h‚ÇÇ.i, commi, commi]\n    have hH : œà‚ÇÅ.œÜH = œà‚ÇÇ.œÜH := by rw [‚Üê cancel_epi h‚ÇÅ.œÄ, commœÄ, commœÄ, hK]\n    cases œà‚ÇÅ\n    cases œà‚ÇÇ\n    congr‚ü©\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyMapData.congr_œÜH","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nS‚ÇÅ S‚ÇÇ : CategoryTheory.ShortComplex C\nœÜ : Quiver.Hom S‚ÇÅ S‚ÇÇ\nh‚ÇÅ : S‚ÇÅ.LeftHomologyData\nh‚ÇÇ : S‚ÇÇ.LeftHomologyData\nŒ≥‚ÇÅ Œ≥‚ÇÇ : CategoryTheory.ShortComplex.LeftHomologyMapData œÜ h‚ÇÅ h‚ÇÇ\neq : Eq Œ≥‚ÇÅ Œ≥‚ÇÇ\n‚ä¢ Eq Œ≥‚ÇÅ.œÜH Œ≥‚ÇÇ.œÜH","decl":"lemma congr_œÜH {Œ≥‚ÇÅ Œ≥‚ÇÇ : LeftHomologyMapData œÜ h‚ÇÅ h‚ÇÇ} (eq : Œ≥‚ÇÅ = Œ≥‚ÇÇ) : Œ≥‚ÇÅ.œÜH = Œ≥‚ÇÇ.œÜH := by rw [eq]\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyMapData.congr_œÜK","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nS‚ÇÅ S‚ÇÇ : CategoryTheory.ShortComplex C\nœÜ : Quiver.Hom S‚ÇÅ S‚ÇÇ\nh‚ÇÅ : S‚ÇÅ.LeftHomologyData\nh‚ÇÇ : S‚ÇÇ.LeftHomologyData\nŒ≥‚ÇÅ Œ≥‚ÇÇ : CategoryTheory.ShortComplex.LeftHomologyMapData œÜ h‚ÇÅ h‚ÇÇ\neq : Eq Œ≥‚ÇÅ Œ≥‚ÇÇ\n‚ä¢ Eq Œ≥‚ÇÅ.œÜK Œ≥‚ÇÇ.œÜK","decl":"lemma congr_œÜK {Œ≥‚ÇÅ Œ≥‚ÇÇ : LeftHomologyMapData œÜ h‚ÇÅ h‚ÇÇ} (eq : Œ≥‚ÇÅ = Œ≥‚ÇÇ) : Œ≥‚ÇÅ.œÜK = Œ≥‚ÇÇ.œÜK := by rw [eq]\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyMapData.ofZeros_œÜH","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nS‚ÇÅ S‚ÇÇ : CategoryTheory.ShortComplex C\nœÜ : Quiver.Hom S‚ÇÅ S‚ÇÇ\nhf‚ÇÅ : Eq S‚ÇÅ.f 0\nhg‚ÇÅ : Eq S‚ÇÅ.g 0\nhf‚ÇÇ : Eq S‚ÇÇ.f 0\nhg‚ÇÇ : Eq S‚ÇÇ.g 0\n‚ä¢ Eq (CategoryTheory.ShortComplex.LeftHomologyMapData.ofZeros œÜ hf‚ÇÅ hg‚ÇÅ hf‚ÇÇ hg‚ÇÇ).œÜH œÜ.œÑ‚ÇÇ","decl":"/-- When `S‚ÇÅ.f`, `S‚ÇÅ.g`, `S‚ÇÇ.f` and `S‚ÇÇ.g` are all zero, the action on left homology of a\nmorphism `œÜ : S‚ÇÅ ‚ü∂ S‚ÇÇ` is given by the action `œÜ.œÑ‚ÇÇ` on the middle objects. -/\n@[simps]\ndef ofZeros (œÜ : S‚ÇÅ ‚ü∂ S‚ÇÇ) (hf‚ÇÅ : S‚ÇÅ.f = 0) (hg‚ÇÅ : S‚ÇÅ.g = 0) (hf‚ÇÇ : S‚ÇÇ.f = 0) (hg‚ÇÇ : S‚ÇÇ.g = 0) :\n    LeftHomologyMapData œÜ (LeftHomologyData.ofZeros S‚ÇÅ hf‚ÇÅ hg‚ÇÅ)\n      (LeftHomologyData.ofZeros S‚ÇÇ hf‚ÇÇ hg‚ÇÇ) where\n  œÜK := œÜ.œÑ‚ÇÇ\n  œÜH := œÜ.œÑ‚ÇÇ\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyMapData.ofZeros_œÜK","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nS‚ÇÅ S‚ÇÇ : CategoryTheory.ShortComplex C\nœÜ : Quiver.Hom S‚ÇÅ S‚ÇÇ\nhf‚ÇÅ : Eq S‚ÇÅ.f 0\nhg‚ÇÅ : Eq S‚ÇÅ.g 0\nhf‚ÇÇ : Eq S‚ÇÇ.f 0\nhg‚ÇÇ : Eq S‚ÇÇ.g 0\n‚ä¢ Eq (CategoryTheory.ShortComplex.LeftHomologyMapData.ofZeros œÜ hf‚ÇÅ hg‚ÇÅ hf‚ÇÇ hg‚ÇÇ).œÜK œÜ.œÑ‚ÇÇ","decl":"/-- When `S‚ÇÅ.f`, `S‚ÇÅ.g`, `S‚ÇÇ.f` and `S‚ÇÇ.g` are all zero, the action on left homology of a\nmorphism `œÜ : S‚ÇÅ ‚ü∂ S‚ÇÇ` is given by the action `œÜ.œÑ‚ÇÇ` on the middle objects. -/\n@[simps]\ndef ofZeros (œÜ : S‚ÇÅ ‚ü∂ S‚ÇÇ) (hf‚ÇÅ : S‚ÇÅ.f = 0) (hg‚ÇÅ : S‚ÇÅ.g = 0) (hf‚ÇÇ : S‚ÇÇ.f = 0) (hg‚ÇÇ : S‚ÇÇ.g = 0) :\n    LeftHomologyMapData œÜ (LeftHomologyData.ofZeros S‚ÇÅ hf‚ÇÅ hg‚ÇÅ)\n      (LeftHomologyData.ofZeros S‚ÇÇ hf‚ÇÇ hg‚ÇÇ) where\n  œÜK := œÜ.œÑ‚ÇÇ\n  œÜH := œÜ.œÑ‚ÇÇ\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyMapData.ofIsColimitCokernelCofork_œÜK","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nS‚ÇÅ S‚ÇÇ : CategoryTheory.ShortComplex C\nœÜ : Quiver.Hom S‚ÇÅ S‚ÇÇ\nhg‚ÇÅ : Eq S‚ÇÅ.g 0\nc‚ÇÅ : CategoryTheory.Limits.CokernelCofork S‚ÇÅ.f\nhc‚ÇÅ : CategoryTheory.Limits.IsColimit c‚ÇÅ\nhg‚ÇÇ : Eq S‚ÇÇ.g 0\nc‚ÇÇ : CategoryTheory.Limits.CokernelCofork S‚ÇÇ.f\nhc‚ÇÇ : CategoryTheory.Limits.IsColimit c‚ÇÇ\nf : Quiver.Hom c‚ÇÅ.pt c‚ÇÇ.pt\ncomm : Eq (CategoryTheory.CategoryStruct.comp œÜ.œÑ‚ÇÇ (CategoryTheory.Limits.Cofork.œÄ c‚ÇÇ)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Cofork.œÄ c‚ÇÅ) f)\n‚ä¢ Eq (CategoryTheory.ShortComplex.LeftHomologyMapData.ofIsColimitCokernelCofork œÜ hg‚ÇÅ c‚ÇÅ hc‚ÇÅ hg‚ÇÇ c‚ÇÇ hc‚ÇÇ f comm).œÜK œÜ.œÑ‚ÇÇ","decl":"/-- When `S‚ÇÅ.g` and `S‚ÇÇ.g` are zero and we have chosen colimit cokernel coforks `c‚ÇÅ` and `c‚ÇÇ`\nfor `S‚ÇÅ.f` and `S‚ÇÇ.f` respectively, the action on left homology of a morphism `œÜ : S‚ÇÅ ‚ü∂ S‚ÇÇ` of\nshort complexes is given by the unique morphism `f : c‚ÇÅ.pt ‚ü∂ c‚ÇÇ.pt` such that\n`œÜ.œÑ‚ÇÇ ‚â´ c‚ÇÇ.œÄ = c‚ÇÅ.œÄ ‚â´ f`. -/\n@[simps]\ndef ofIsColimitCokernelCofork (œÜ : S‚ÇÅ ‚ü∂ S‚ÇÇ)\n    (hg‚ÇÅ : S‚ÇÅ.g = 0) (c‚ÇÅ : CokernelCofork S‚ÇÅ.f) (hc‚ÇÅ : IsColimit c‚ÇÅ)\n    (hg‚ÇÇ : S‚ÇÇ.g = 0) (c‚ÇÇ : CokernelCofork S‚ÇÇ.f) (hc‚ÇÇ : IsColimit c‚ÇÇ) (f : c‚ÇÅ.pt ‚ü∂ c‚ÇÇ.pt)\n    (comm : œÜ.œÑ‚ÇÇ ‚â´ c‚ÇÇ.œÄ = c‚ÇÅ.œÄ ‚â´ f) :\n    LeftHomologyMapData œÜ (LeftHomologyData.ofIsColimitCokernelCofork S‚ÇÅ hg‚ÇÅ c‚ÇÅ hc‚ÇÅ)\n      (LeftHomologyData.ofIsColimitCokernelCofork S‚ÇÇ hg‚ÇÇ c‚ÇÇ hc‚ÇÇ) where\n  œÜK := œÜ.œÑ‚ÇÇ\n  œÜH := f\n  commœÄ := comm.symm\n  commf' := by simp only [LeftHomologyData.ofIsColimitCokernelCofork_f', œÜ.comm‚ÇÅ‚ÇÇ]\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyMapData.ofIsColimitCokernelCofork_œÜH","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nS‚ÇÅ S‚ÇÇ : CategoryTheory.ShortComplex C\nœÜ : Quiver.Hom S‚ÇÅ S‚ÇÇ\nhg‚ÇÅ : Eq S‚ÇÅ.g 0\nc‚ÇÅ : CategoryTheory.Limits.CokernelCofork S‚ÇÅ.f\nhc‚ÇÅ : CategoryTheory.Limits.IsColimit c‚ÇÅ\nhg‚ÇÇ : Eq S‚ÇÇ.g 0\nc‚ÇÇ : CategoryTheory.Limits.CokernelCofork S‚ÇÇ.f\nhc‚ÇÇ : CategoryTheory.Limits.IsColimit c‚ÇÇ\nf : Quiver.Hom c‚ÇÅ.pt c‚ÇÇ.pt\ncomm : Eq (CategoryTheory.CategoryStruct.comp œÜ.œÑ‚ÇÇ (CategoryTheory.Limits.Cofork.œÄ c‚ÇÇ)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Cofork.œÄ c‚ÇÅ) f)\n‚ä¢ Eq (CategoryTheory.ShortComplex.LeftHomologyMapData.ofIsColimitCokernelCofork œÜ hg‚ÇÅ c‚ÇÅ hc‚ÇÅ hg‚ÇÇ c‚ÇÇ hc‚ÇÇ f comm).œÜH f","decl":"/-- When `S‚ÇÅ.g` and `S‚ÇÇ.g` are zero and we have chosen colimit cokernel coforks `c‚ÇÅ` and `c‚ÇÇ`\nfor `S‚ÇÅ.f` and `S‚ÇÇ.f` respectively, the action on left homology of a morphism `œÜ : S‚ÇÅ ‚ü∂ S‚ÇÇ` of\nshort complexes is given by the unique morphism `f : c‚ÇÅ.pt ‚ü∂ c‚ÇÇ.pt` such that\n`œÜ.œÑ‚ÇÇ ‚â´ c‚ÇÇ.œÄ = c‚ÇÅ.œÄ ‚â´ f`. -/\n@[simps]\ndef ofIsColimitCokernelCofork (œÜ : S‚ÇÅ ‚ü∂ S‚ÇÇ)\n    (hg‚ÇÅ : S‚ÇÅ.g = 0) (c‚ÇÅ : CokernelCofork S‚ÇÅ.f) (hc‚ÇÅ : IsColimit c‚ÇÅ)\n    (hg‚ÇÇ : S‚ÇÇ.g = 0) (c‚ÇÇ : CokernelCofork S‚ÇÇ.f) (hc‚ÇÇ : IsColimit c‚ÇÇ) (f : c‚ÇÅ.pt ‚ü∂ c‚ÇÇ.pt)\n    (comm : œÜ.œÑ‚ÇÇ ‚â´ c‚ÇÇ.œÄ = c‚ÇÅ.œÄ ‚â´ f) :\n    LeftHomologyMapData œÜ (LeftHomologyData.ofIsColimitCokernelCofork S‚ÇÅ hg‚ÇÅ c‚ÇÅ hc‚ÇÅ)\n      (LeftHomologyData.ofIsColimitCokernelCofork S‚ÇÇ hg‚ÇÇ c‚ÇÇ hc‚ÇÇ) where\n  œÜK := œÜ.œÑ‚ÇÇ\n  œÜH := f\n  commœÄ := comm.symm\n  commf' := by simp only [LeftHomologyData.ofIsColimitCokernelCofork_f', œÜ.comm‚ÇÅ‚ÇÇ]\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyMapData.ofIsLimitKernelFork_œÜK","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nS‚ÇÅ S‚ÇÇ : CategoryTheory.ShortComplex C\nœÜ : Quiver.Hom S‚ÇÅ S‚ÇÇ\nhf‚ÇÅ : Eq S‚ÇÅ.f 0\nc‚ÇÅ : CategoryTheory.Limits.KernelFork S‚ÇÅ.g\nhc‚ÇÅ : CategoryTheory.Limits.IsLimit c‚ÇÅ\nhf‚ÇÇ : Eq S‚ÇÇ.f 0\nc‚ÇÇ : CategoryTheory.Limits.KernelFork S‚ÇÇ.g\nhc‚ÇÇ : CategoryTheory.Limits.IsLimit c‚ÇÇ\nf : Quiver.Hom c‚ÇÅ.pt c‚ÇÇ.pt\ncomm : Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Fork.Œπ c‚ÇÅ) œÜ.œÑ‚ÇÇ) (CategoryTheory.CategoryStruct.comp f (CategoryTheory.Limits.Fork.Œπ c‚ÇÇ))\n‚ä¢ Eq (CategoryTheory.ShortComplex.LeftHomologyMapData.ofIsLimitKernelFork œÜ hf‚ÇÅ c‚ÇÅ hc‚ÇÅ hf‚ÇÇ c‚ÇÇ hc‚ÇÇ f comm).œÜK f","decl":"/-- When `S‚ÇÅ.f` and `S‚ÇÇ.f` are zero and we have chosen limit kernel forks `c‚ÇÅ` and `c‚ÇÇ`\nfor `S‚ÇÅ.g` and `S‚ÇÇ.g` respectively, the action on left homology of a morphism `œÜ : S‚ÇÅ ‚ü∂ S‚ÇÇ` of\nshort complexes is given by the unique morphism `f : c‚ÇÅ.pt ‚ü∂ c‚ÇÇ.pt` such that\n`c‚ÇÅ.Œπ ‚â´ œÜ.œÑ‚ÇÇ = f ‚â´ c‚ÇÇ.Œπ`. -/\n@[simps]\ndef ofIsLimitKernelFork (œÜ : S‚ÇÅ ‚ü∂ S‚ÇÇ)\n    (hf‚ÇÅ : S‚ÇÅ.f = 0) (c‚ÇÅ : KernelFork S‚ÇÅ.g) (hc‚ÇÅ : IsLimit c‚ÇÅ)\n    (hf‚ÇÇ : S‚ÇÇ.f = 0) (c‚ÇÇ : KernelFork S‚ÇÇ.g) (hc‚ÇÇ : IsLimit c‚ÇÇ) (f : c‚ÇÅ.pt ‚ü∂ c‚ÇÇ.pt)\n    (comm : c‚ÇÅ.Œπ ‚â´ œÜ.œÑ‚ÇÇ = f ‚â´ c‚ÇÇ.Œπ) :\n    LeftHomologyMapData œÜ (LeftHomologyData.ofIsLimitKernelFork S‚ÇÅ hf‚ÇÅ c‚ÇÅ hc‚ÇÅ)\n      (LeftHomologyData.ofIsLimitKernelFork S‚ÇÇ hf‚ÇÇ c‚ÇÇ hc‚ÇÇ) where\n  œÜK := f\n  œÜH := f\n  commi := comm.symm\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyMapData.ofIsLimitKernelFork_œÜH","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nS‚ÇÅ S‚ÇÇ : CategoryTheory.ShortComplex C\nœÜ : Quiver.Hom S‚ÇÅ S‚ÇÇ\nhf‚ÇÅ : Eq S‚ÇÅ.f 0\nc‚ÇÅ : CategoryTheory.Limits.KernelFork S‚ÇÅ.g\nhc‚ÇÅ : CategoryTheory.Limits.IsLimit c‚ÇÅ\nhf‚ÇÇ : Eq S‚ÇÇ.f 0\nc‚ÇÇ : CategoryTheory.Limits.KernelFork S‚ÇÇ.g\nhc‚ÇÇ : CategoryTheory.Limits.IsLimit c‚ÇÇ\nf : Quiver.Hom c‚ÇÅ.pt c‚ÇÇ.pt\ncomm : Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Fork.Œπ c‚ÇÅ) œÜ.œÑ‚ÇÇ) (CategoryTheory.CategoryStruct.comp f (CategoryTheory.Limits.Fork.Œπ c‚ÇÇ))\n‚ä¢ Eq (CategoryTheory.ShortComplex.LeftHomologyMapData.ofIsLimitKernelFork œÜ hf‚ÇÅ c‚ÇÅ hc‚ÇÅ hf‚ÇÇ c‚ÇÇ hc‚ÇÇ f comm).œÜH f","decl":"/-- When `S‚ÇÅ.f` and `S‚ÇÇ.f` are zero and we have chosen limit kernel forks `c‚ÇÅ` and `c‚ÇÇ`\nfor `S‚ÇÅ.g` and `S‚ÇÇ.g` respectively, the action on left homology of a morphism `œÜ : S‚ÇÅ ‚ü∂ S‚ÇÇ` of\nshort complexes is given by the unique morphism `f : c‚ÇÅ.pt ‚ü∂ c‚ÇÇ.pt` such that\n`c‚ÇÅ.Œπ ‚â´ œÜ.œÑ‚ÇÇ = f ‚â´ c‚ÇÇ.Œπ`. -/\n@[simps]\ndef ofIsLimitKernelFork (œÜ : S‚ÇÅ ‚ü∂ S‚ÇÇ)\n    (hf‚ÇÅ : S‚ÇÅ.f = 0) (c‚ÇÅ : KernelFork S‚ÇÅ.g) (hc‚ÇÅ : IsLimit c‚ÇÅ)\n    (hf‚ÇÇ : S‚ÇÇ.f = 0) (c‚ÇÇ : KernelFork S‚ÇÇ.g) (hc‚ÇÇ : IsLimit c‚ÇÇ) (f : c‚ÇÅ.pt ‚ü∂ c‚ÇÇ.pt)\n    (comm : c‚ÇÅ.Œπ ‚â´ œÜ.œÑ‚ÇÇ = f ‚â´ c‚ÇÇ.Œπ) :\n    LeftHomologyMapData œÜ (LeftHomologyData.ofIsLimitKernelFork S‚ÇÅ hf‚ÇÅ c‚ÇÅ hc‚ÇÅ)\n      (LeftHomologyData.ofIsLimitKernelFork S‚ÇÇ hf‚ÇÇ c‚ÇÇ hc‚ÇÇ) where\n  œÜK := f\n  œÜH := f\n  commi := comm.symm\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyMapData.compatibilityOfZerosOfIsColimitCokernelCofork_œÜH","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nhf : Eq S.f 0\nhg : Eq S.g 0\nc : CategoryTheory.Limits.CokernelCofork S.f\nhc : CategoryTheory.Limits.IsColimit c\n‚ä¢ Eq (CategoryTheory.ShortComplex.LeftHomologyMapData.compatibilityOfZerosOfIsColimitCokernelCofork S hf hg c hc).œÜH (CategoryTheory.Limits.Cofork.œÄ c)","decl":"/-- When both maps `S.f` and `S.g` of a short complex `S` are zero, this is the left homology map\ndata (for the identity of `S`) which relates the left homology data `ofZeros` and\n`ofIsColimitCokernelCofork`. -/\n@[simps]\ndef compatibilityOfZerosOfIsColimitCokernelCofork (hf : S.f = 0) (hg : S.g = 0)\n    (c : CokernelCofork S.f) (hc : IsColimit c) :\n    LeftHomologyMapData (ùüô S) (LeftHomologyData.ofZeros S hf hg)\n      (LeftHomologyData.ofIsColimitCokernelCofork S hg c hc) where\n  œÜK := ùüô _\n  œÜH := c.œÄ\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyMapData.compatibilityOfZerosOfIsColimitCokernelCofork_œÜK","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nhf : Eq S.f 0\nhg : Eq S.g 0\nc : CategoryTheory.Limits.CokernelCofork S.f\nhc : CategoryTheory.Limits.IsColimit c\n‚ä¢ Eq (CategoryTheory.ShortComplex.LeftHomologyMapData.compatibilityOfZerosOfIsColimitCokernelCofork S hf hg c hc).œÜK (CategoryTheory.CategoryStruct.id (CategoryTheory.ShortComplex.LeftHomologyData.ofZeros S hf hg).K)","decl":"/-- When both maps `S.f` and `S.g` of a short complex `S` are zero, this is the left homology map\ndata (for the identity of `S`) which relates the left homology data `ofZeros` and\n`ofIsColimitCokernelCofork`. -/\n@[simps]\ndef compatibilityOfZerosOfIsColimitCokernelCofork (hf : S.f = 0) (hg : S.g = 0)\n    (c : CokernelCofork S.f) (hc : IsColimit c) :\n    LeftHomologyMapData (ùüô S) (LeftHomologyData.ofZeros S hf hg)\n      (LeftHomologyData.ofIsColimitCokernelCofork S hg c hc) where\n  œÜK := ùüô _\n  œÜH := c.œÄ\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyMapData.compatibilityOfZerosOfIsLimitKernelFork_œÜH","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nhf : Eq S.f 0\nhg : Eq S.g 0\nc : CategoryTheory.Limits.KernelFork S.g\nhc : CategoryTheory.Limits.IsLimit c\n‚ä¢ Eq (CategoryTheory.ShortComplex.LeftHomologyMapData.compatibilityOfZerosOfIsLimitKernelFork S hf hg c hc).œÜH (CategoryTheory.Limits.Fork.Œπ c)","decl":"/-- When both maps `S.f` and `S.g` of a short complex `S` are zero, this is the left homology map\ndata (for the identity of `S`) which relates the left homology data\n`LeftHomologyData.ofIsLimitKernelFork` and `ofZeros` . -/\n@[simps]\ndef compatibilityOfZerosOfIsLimitKernelFork (hf : S.f = 0) (hg : S.g = 0)\n    (c : KernelFork S.g) (hc : IsLimit c) :\n    LeftHomologyMapData (ùüô S) (LeftHomologyData.ofIsLimitKernelFork S hf c hc)\n      (LeftHomologyData.ofZeros S hf hg) where\n  œÜK := c.Œπ\n  œÜH := c.Œπ\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyMapData.compatibilityOfZerosOfIsLimitKernelFork_œÜK","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nhf : Eq S.f 0\nhg : Eq S.g 0\nc : CategoryTheory.Limits.KernelFork S.g\nhc : CategoryTheory.Limits.IsLimit c\n‚ä¢ Eq (CategoryTheory.ShortComplex.LeftHomologyMapData.compatibilityOfZerosOfIsLimitKernelFork S hf hg c hc).œÜK (CategoryTheory.Limits.Fork.Œπ c)","decl":"/-- When both maps `S.f` and `S.g` of a short complex `S` are zero, this is the left homology map\ndata (for the identity of `S`) which relates the left homology data\n`LeftHomologyData.ofIsLimitKernelFork` and `ofZeros` . -/\n@[simps]\ndef compatibilityOfZerosOfIsLimitKernelFork (hf : S.f = 0) (hg : S.g = 0)\n    (c : KernelFork S.g) (hc : IsLimit c) :\n    LeftHomologyMapData (ùüô S) (LeftHomologyData.ofIsLimitKernelFork S hf c hc)\n      (LeftHomologyData.ofZeros S hf hg) where\n  œÜK := c.Œπ\n  œÜH := c.Œπ\n\n"}
{"name":"CategoryTheory.ShortComplex.iCycles_g","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst‚úù : S.HasLeftHomology\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp S.iCycles S.g) 0","decl":"@[reassoc (attr := simp)]\nlemma iCycles_g : S.iCycles ‚â´ S.g = 0 := S.leftHomologyData.wi\n\n"}
{"name":"CategoryTheory.ShortComplex.iCycles_g_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst‚úù : S.HasLeftHomology\nZ : C\nh : Quiver.Hom S.X‚ÇÉ Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp S.iCycles (CategoryTheory.CategoryStruct.comp S.g h)) (CategoryTheory.CategoryStruct.comp 0 h)","decl":"@[reassoc (attr := simp)]\nlemma iCycles_g : S.iCycles ‚â´ S.g = 0 := S.leftHomologyData.wi\n\n"}
{"name":"CategoryTheory.ShortComplex.toCycles_i","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst‚úù : S.HasLeftHomology\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp S.toCycles S.iCycles) S.f","decl":"@[reassoc (attr := simp)]\nlemma toCycles_i : S.toCycles ‚â´ S.iCycles = S.f := S.leftHomologyData.f'_i\n\n"}
{"name":"CategoryTheory.ShortComplex.toCycles_i_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst‚úù : S.HasLeftHomology\nZ : C\nh : Quiver.Hom S.X‚ÇÇ Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp S.toCycles (CategoryTheory.CategoryStruct.comp S.iCycles h)) (CategoryTheory.CategoryStruct.comp S.f h)","decl":"@[reassoc (attr := simp)]\nlemma toCycles_i : S.toCycles ‚â´ S.iCycles = S.f := S.leftHomologyData.f'_i\n\n"}
{"name":"CategoryTheory.ShortComplex.instMonoICycles","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst‚úù : S.HasLeftHomology\n‚ä¢ CategoryTheory.Mono S.iCycles","decl":"instance : Mono S.iCycles := by\n  dsimp only [iCycles]\n  infer_instance\n\n"}
{"name":"CategoryTheory.ShortComplex.instEpiLeftHomologyœÄ","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst‚úù : S.HasLeftHomology\n‚ä¢ CategoryTheory.Epi S.leftHomologyœÄ","decl":"instance : Epi S.leftHomologyœÄ := by\n  dsimp only [leftHomologyœÄ]\n  infer_instance\n\n"}
{"name":"CategoryTheory.ShortComplex.leftHomology_ext_iff","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst‚úù : S.HasLeftHomology\nA : C\nf‚ÇÅ f‚ÇÇ : Quiver.Hom S.leftHomology A\n‚ä¢ Iff (Eq f‚ÇÅ f‚ÇÇ) (Eq (CategoryTheory.CategoryStruct.comp S.leftHomologyœÄ f‚ÇÅ) (CategoryTheory.CategoryStruct.comp S.leftHomologyœÄ f‚ÇÇ))","decl":"lemma leftHomology_ext_iff {A : C} (f‚ÇÅ f‚ÇÇ : S.leftHomology ‚ü∂ A) :\n    f‚ÇÅ = f‚ÇÇ ‚Üî S.leftHomologyœÄ ‚â´ f‚ÇÅ = S.leftHomologyœÄ ‚â´ f‚ÇÇ := by\n  rw [cancel_epi]\n\n"}
{"name":"CategoryTheory.ShortComplex.leftHomology_ext","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst‚úù : S.HasLeftHomology\nA : C\nf‚ÇÅ f‚ÇÇ : Quiver.Hom S.leftHomology A\nh : Eq (CategoryTheory.CategoryStruct.comp S.leftHomologyœÄ f‚ÇÅ) (CategoryTheory.CategoryStruct.comp S.leftHomologyœÄ f‚ÇÇ)\n‚ä¢ Eq f‚ÇÅ f‚ÇÇ","decl":"@[ext]\nlemma leftHomology_ext {A : C} (f‚ÇÅ f‚ÇÇ : S.leftHomology ‚ü∂ A)\n    (h : S.leftHomologyœÄ ‚â´ f‚ÇÅ = S.leftHomologyœÄ ‚â´ f‚ÇÇ) : f‚ÇÅ = f‚ÇÇ := by\n  simpa only [leftHomology_ext_iff] using h\n\n"}
{"name":"CategoryTheory.ShortComplex.cycles_ext_iff","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst‚úù : S.HasLeftHomology\nA : C\nf‚ÇÅ f‚ÇÇ : Quiver.Hom A S.cycles\n‚ä¢ Iff (Eq f‚ÇÅ f‚ÇÇ) (Eq (CategoryTheory.CategoryStruct.comp f‚ÇÅ S.iCycles) (CategoryTheory.CategoryStruct.comp f‚ÇÇ S.iCycles))","decl":"lemma cycles_ext_iff {A : C} (f‚ÇÅ f‚ÇÇ : A ‚ü∂ S.cycles) :\n    f‚ÇÅ = f‚ÇÇ ‚Üî f‚ÇÅ ‚â´ S.iCycles = f‚ÇÇ ‚â´ S.iCycles := by\n  rw [cancel_mono]\n\n"}
{"name":"CategoryTheory.ShortComplex.cycles_ext","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst‚úù : S.HasLeftHomology\nA : C\nf‚ÇÅ f‚ÇÇ : Quiver.Hom A S.cycles\nh : Eq (CategoryTheory.CategoryStruct.comp f‚ÇÅ S.iCycles) (CategoryTheory.CategoryStruct.comp f‚ÇÇ S.iCycles)\n‚ä¢ Eq f‚ÇÅ f‚ÇÇ","decl":"@[ext]\nlemma cycles_ext {A : C} (f‚ÇÅ f‚ÇÇ : A ‚ü∂ S.cycles) (h : f‚ÇÅ ‚â´ S.iCycles = f‚ÇÇ ‚â´ S.iCycles) :\n    f‚ÇÅ = f‚ÇÇ := by\n  simpa only [cycles_ext_iff] using h\n\n"}
{"name":"CategoryTheory.ShortComplex.isIso_iCycles","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst‚úù : S.HasLeftHomology\nhg : Eq S.g 0\n‚ä¢ CategoryTheory.IsIso S.iCycles","decl":"lemma isIso_iCycles (hg : S.g = 0) : IsIso S.iCycles :=\n  LeftHomologyData.isIso_i _ hg\n\n"}
{"name":"CategoryTheory.ShortComplex.cyclesIsoX‚ÇÇ_hom","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst‚úù : S.HasLeftHomology\nhg : Eq S.g 0\n‚ä¢ Eq (S.cyclesIsoX‚ÇÇ hg).hom S.iCycles","decl":"/-- When `S.g = 0`, this is the canonical isomorphism `S.cycles ‚âÖ S.X‚ÇÇ` induced by `S.iCycles`. -/\n@[simps! hom]\nnoncomputable def cyclesIsoX‚ÇÇ (hg : S.g = 0) : S.cycles ‚âÖ S.X‚ÇÇ := by\n  have := S.isIso_iCycles hg\n  exact asIso S.iCycles\n\n"}
{"name":"CategoryTheory.ShortComplex.cyclesIsoX‚ÇÇ_hom_inv_id","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst‚úù : S.HasLeftHomology\nhg : Eq S.g 0\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp S.iCycles (S.cyclesIsoX‚ÇÇ hg).inv) (CategoryTheory.CategoryStruct.id S.cycles)","decl":"@[reassoc (attr := simp)]\nlemma cyclesIsoX‚ÇÇ_hom_inv_id (hg : S.g = 0) :\n    S.iCycles ‚â´ (S.cyclesIsoX‚ÇÇ hg).inv = ùüô _ := (S.cyclesIsoX‚ÇÇ hg).hom_inv_id\n\n"}
{"name":"CategoryTheory.ShortComplex.cyclesIsoX‚ÇÇ_hom_inv_id_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst‚úù : S.HasLeftHomology\nhg : Eq S.g 0\nZ : C\nh : Quiver.Hom S.cycles Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp S.iCycles (CategoryTheory.CategoryStruct.comp (S.cyclesIsoX‚ÇÇ hg).inv h)) h","decl":"@[reassoc (attr := simp)]\nlemma cyclesIsoX‚ÇÇ_hom_inv_id (hg : S.g = 0) :\n    S.iCycles ‚â´ (S.cyclesIsoX‚ÇÇ hg).inv = ùüô _ := (S.cyclesIsoX‚ÇÇ hg).hom_inv_id\n\n"}
{"name":"CategoryTheory.ShortComplex.cyclesIsoX‚ÇÇ_inv_hom_id_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst‚úù : S.HasLeftHomology\nhg : Eq S.g 0\nZ : C\nh : Quiver.Hom S.X‚ÇÇ Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (S.cyclesIsoX‚ÇÇ hg).inv (CategoryTheory.CategoryStruct.comp S.iCycles h)) h","decl":"@[reassoc (attr := simp)]\nlemma cyclesIsoX‚ÇÇ_inv_hom_id (hg : S.g = 0) :\n    (S.cyclesIsoX‚ÇÇ hg).inv ‚â´ S.iCycles = ùüô _ := (S.cyclesIsoX‚ÇÇ hg).inv_hom_id\n\n"}
{"name":"CategoryTheory.ShortComplex.cyclesIsoX‚ÇÇ_inv_hom_id","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst‚úù : S.HasLeftHomology\nhg : Eq S.g 0\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (S.cyclesIsoX‚ÇÇ hg).inv S.iCycles) (CategoryTheory.CategoryStruct.id S.X‚ÇÇ)","decl":"@[reassoc (attr := simp)]\nlemma cyclesIsoX‚ÇÇ_inv_hom_id (hg : S.g = 0) :\n    (S.cyclesIsoX‚ÇÇ hg).inv ‚â´ S.iCycles = ùüô _ := (S.cyclesIsoX‚ÇÇ hg).inv_hom_id\n\n"}
{"name":"CategoryTheory.ShortComplex.isIso_leftHomologyœÄ","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst‚úù : S.HasLeftHomology\nhf : Eq S.f 0\n‚ä¢ CategoryTheory.IsIso S.leftHomologyœÄ","decl":"lemma isIso_leftHomologyœÄ (hf : S.f = 0) : IsIso S.leftHomologyœÄ :=\n  LeftHomologyData.isIso_œÄ _ hf\n\n"}
{"name":"CategoryTheory.ShortComplex.cyclesIsoLeftHomology_hom","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst‚úù : S.HasLeftHomology\nhf : Eq S.f 0\n‚ä¢ Eq (S.cyclesIsoLeftHomology hf).hom S.leftHomologyœÄ","decl":"/-- When `S.f = 0`, this is the canonical isomorphism `S.cycles ‚âÖ S.leftHomology` induced\nby `S.leftHomologyœÄ`. -/\n@[simps! hom]\nnoncomputable def cyclesIsoLeftHomology (hf : S.f = 0) : S.cycles ‚âÖ S.leftHomology := by\n  have := S.isIso_leftHomologyœÄ hf\n  exact asIso S.leftHomologyœÄ\n\n"}
{"name":"CategoryTheory.ShortComplex.cyclesIsoLeftHomology_hom_inv_id","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst‚úù : S.HasLeftHomology\nhf : Eq S.f 0\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp S.leftHomologyœÄ (S.cyclesIsoLeftHomology hf).inv) (CategoryTheory.CategoryStruct.id S.cycles)","decl":"@[reassoc (attr := simp)]\nlemma cyclesIsoLeftHomology_hom_inv_id (hf : S.f = 0) :\n    S.leftHomologyœÄ ‚â´ (S.cyclesIsoLeftHomology hf).inv = ùüô _ :=\n  (S.cyclesIsoLeftHomology hf).hom_inv_id\n\n"}
{"name":"CategoryTheory.ShortComplex.cyclesIsoLeftHomology_hom_inv_id_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst‚úù : S.HasLeftHomology\nhf : Eq S.f 0\nZ : C\nh : Quiver.Hom S.cycles Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp S.leftHomologyœÄ (CategoryTheory.CategoryStruct.comp (S.cyclesIsoLeftHomology hf).inv h)) h","decl":"@[reassoc (attr := simp)]\nlemma cyclesIsoLeftHomology_hom_inv_id (hf : S.f = 0) :\n    S.leftHomologyœÄ ‚â´ (S.cyclesIsoLeftHomology hf).inv = ùüô _ :=\n  (S.cyclesIsoLeftHomology hf).hom_inv_id\n\n"}
{"name":"CategoryTheory.ShortComplex.cyclesIsoLeftHomology_inv_hom_id","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst‚úù : S.HasLeftHomology\nhf : Eq S.f 0\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (S.cyclesIsoLeftHomology hf).inv S.leftHomologyœÄ) (CategoryTheory.CategoryStruct.id S.leftHomology)","decl":"@[reassoc (attr := simp)]\nlemma cyclesIsoLeftHomology_inv_hom_id (hf : S.f = 0) :\n    (S.cyclesIsoLeftHomology hf).inv ‚â´ S.leftHomologyœÄ = ùüô _ :=\n  (S.cyclesIsoLeftHomology hf).inv_hom_id\n\n"}
{"name":"CategoryTheory.ShortComplex.cyclesIsoLeftHomology_inv_hom_id_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst‚úù : S.HasLeftHomology\nhf : Eq S.f 0\nZ : C\nh : Quiver.Hom S.leftHomology Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (S.cyclesIsoLeftHomology hf).inv (CategoryTheory.CategoryStruct.comp S.leftHomologyœÄ h)) h","decl":"@[reassoc (attr := simp)]\nlemma cyclesIsoLeftHomology_inv_hom_id (hf : S.f = 0) :\n    (S.cyclesIsoLeftHomology hf).inv ‚â´ S.leftHomologyœÄ = ùüô _ :=\n  (S.cyclesIsoLeftHomology hf).inv_hom_id\n\n"}
{"name":"CategoryTheory.ShortComplex.cyclesMap'_i","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nS‚ÇÅ S‚ÇÇ : CategoryTheory.ShortComplex C\nœÜ : Quiver.Hom S‚ÇÅ S‚ÇÇ\nh‚ÇÅ : S‚ÇÅ.LeftHomologyData\nh‚ÇÇ : S‚ÇÇ.LeftHomologyData\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.cyclesMap' œÜ h‚ÇÅ h‚ÇÇ) h‚ÇÇ.i) (CategoryTheory.CategoryStruct.comp h‚ÇÅ.i œÜ.œÑ‚ÇÇ)","decl":"@[reassoc (attr := simp)]\nlemma cyclesMap'_i : cyclesMap' œÜ h‚ÇÅ h‚ÇÇ ‚â´ h‚ÇÇ.i = h‚ÇÅ.i ‚â´ œÜ.œÑ‚ÇÇ :=\n  LeftHomologyMapData.commi _\n\n"}
{"name":"CategoryTheory.ShortComplex.cyclesMap'_i_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nS‚ÇÅ S‚ÇÇ : CategoryTheory.ShortComplex C\nœÜ : Quiver.Hom S‚ÇÅ S‚ÇÇ\nh‚ÇÅ : S‚ÇÅ.LeftHomologyData\nh‚ÇÇ : S‚ÇÇ.LeftHomologyData\nZ : C\nh : Quiver.Hom S‚ÇÇ.X‚ÇÇ Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.cyclesMap' œÜ h‚ÇÅ h‚ÇÇ) (CategoryTheory.CategoryStruct.comp h‚ÇÇ.i h)) (CategoryTheory.CategoryStruct.comp h‚ÇÅ.i (CategoryTheory.CategoryStruct.comp œÜ.œÑ‚ÇÇ h))","decl":"@[reassoc (attr := simp)]\nlemma cyclesMap'_i : cyclesMap' œÜ h‚ÇÅ h‚ÇÇ ‚â´ h‚ÇÇ.i = h‚ÇÅ.i ‚â´ œÜ.œÑ‚ÇÇ :=\n  LeftHomologyMapData.commi _\n\n"}
{"name":"CategoryTheory.ShortComplex.f'_cyclesMap'_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nS‚ÇÅ S‚ÇÇ : CategoryTheory.ShortComplex C\nœÜ : Quiver.Hom S‚ÇÅ S‚ÇÇ\nh‚ÇÅ : S‚ÇÅ.LeftHomologyData\nh‚ÇÇ : S‚ÇÇ.LeftHomologyData\nZ : C\nh : Quiver.Hom h‚ÇÇ.K Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp h‚ÇÅ.f' (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.cyclesMap' œÜ h‚ÇÅ h‚ÇÇ) h)) (CategoryTheory.CategoryStruct.comp œÜ.œÑ‚ÇÅ (CategoryTheory.CategoryStruct.comp h‚ÇÇ.f' h))","decl":"@[reassoc (attr := simp)]\nlemma f'_cyclesMap' : h‚ÇÅ.f' ‚â´ cyclesMap' œÜ h‚ÇÅ h‚ÇÇ = œÜ.œÑ‚ÇÅ ‚â´ h‚ÇÇ.f' := by\n  simp only [‚Üê cancel_mono h‚ÇÇ.i, assoc, œÜ.comm‚ÇÅ‚ÇÇ, cyclesMap'_i,\n    LeftHomologyData.f'_i_assoc, LeftHomologyData.f'_i]\n\n"}
{"name":"CategoryTheory.ShortComplex.f'_cyclesMap'","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nS‚ÇÅ S‚ÇÇ : CategoryTheory.ShortComplex C\nœÜ : Quiver.Hom S‚ÇÅ S‚ÇÇ\nh‚ÇÅ : S‚ÇÅ.LeftHomologyData\nh‚ÇÇ : S‚ÇÇ.LeftHomologyData\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp h‚ÇÅ.f' (CategoryTheory.ShortComplex.cyclesMap' œÜ h‚ÇÅ h‚ÇÇ)) (CategoryTheory.CategoryStruct.comp œÜ.œÑ‚ÇÅ h‚ÇÇ.f')","decl":"@[reassoc (attr := simp)]\nlemma f'_cyclesMap' : h‚ÇÅ.f' ‚â´ cyclesMap' œÜ h‚ÇÅ h‚ÇÇ = œÜ.œÑ‚ÇÅ ‚â´ h‚ÇÇ.f' := by\n  simp only [‚Üê cancel_mono h‚ÇÇ.i, assoc, œÜ.comm‚ÇÅ‚ÇÇ, cyclesMap'_i,\n    LeftHomologyData.f'_i_assoc, LeftHomologyData.f'_i]\n\n"}
{"name":"CategoryTheory.ShortComplex.leftHomologyœÄ_naturality'","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nS‚ÇÅ S‚ÇÇ : CategoryTheory.ShortComplex C\nœÜ : Quiver.Hom S‚ÇÅ S‚ÇÇ\nh‚ÇÅ : S‚ÇÅ.LeftHomologyData\nh‚ÇÇ : S‚ÇÇ.LeftHomologyData\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp h‚ÇÅ.œÄ (CategoryTheory.ShortComplex.leftHomologyMap' œÜ h‚ÇÅ h‚ÇÇ)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.cyclesMap' œÜ h‚ÇÅ h‚ÇÇ) h‚ÇÇ.œÄ)","decl":"@[reassoc (attr := simp)]\nlemma leftHomologyœÄ_naturality' :\n    h‚ÇÅ.œÄ ‚â´ leftHomologyMap' œÜ h‚ÇÅ h‚ÇÇ = cyclesMap' œÜ h‚ÇÅ h‚ÇÇ ‚â´ h‚ÇÇ.œÄ :=\n  LeftHomologyMapData.commœÄ _\n\n"}
{"name":"CategoryTheory.ShortComplex.leftHomologyœÄ_naturality'_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nS‚ÇÅ S‚ÇÇ : CategoryTheory.ShortComplex C\nœÜ : Quiver.Hom S‚ÇÅ S‚ÇÇ\nh‚ÇÅ : S‚ÇÅ.LeftHomologyData\nh‚ÇÇ : S‚ÇÇ.LeftHomologyData\nZ : C\nh : Quiver.Hom h‚ÇÇ.H Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp h‚ÇÅ.œÄ (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.leftHomologyMap' œÜ h‚ÇÅ h‚ÇÇ) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.cyclesMap' œÜ h‚ÇÅ h‚ÇÇ) (CategoryTheory.CategoryStruct.comp h‚ÇÇ.œÄ h))","decl":"@[reassoc (attr := simp)]\nlemma leftHomologyœÄ_naturality' :\n    h‚ÇÅ.œÄ ‚â´ leftHomologyMap' œÜ h‚ÇÅ h‚ÇÇ = cyclesMap' œÜ h‚ÇÅ h‚ÇÇ ‚â´ h‚ÇÇ.œÄ :=\n  LeftHomologyMapData.commœÄ _\n\n"}
{"name":"CategoryTheory.ShortComplex.cyclesMap_i_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬≥ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroMorphisms C\nS‚ÇÅ S‚ÇÇ : CategoryTheory.ShortComplex C\ninst‚úù¬π : S‚ÇÅ.HasLeftHomology\ninst‚úù : S‚ÇÇ.HasLeftHomology\nœÜ : Quiver.Hom S‚ÇÅ S‚ÇÇ\nZ : C\nh : Quiver.Hom S‚ÇÇ.X‚ÇÇ Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.cyclesMap œÜ) (CategoryTheory.CategoryStruct.comp S‚ÇÇ.iCycles h)) (CategoryTheory.CategoryStruct.comp S‚ÇÅ.iCycles (CategoryTheory.CategoryStruct.comp œÜ.œÑ‚ÇÇ h))","decl":"@[reassoc (attr := simp)]\nlemma cyclesMap_i : cyclesMap œÜ ‚â´ S‚ÇÇ.iCycles = S‚ÇÅ.iCycles ‚â´ œÜ.œÑ‚ÇÇ :=\n  cyclesMap'_i _ _ _\n\n"}
{"name":"CategoryTheory.ShortComplex.cyclesMap_i","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬≥ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroMorphisms C\nS‚ÇÅ S‚ÇÇ : CategoryTheory.ShortComplex C\ninst‚úù¬π : S‚ÇÅ.HasLeftHomology\ninst‚úù : S‚ÇÇ.HasLeftHomology\nœÜ : Quiver.Hom S‚ÇÅ S‚ÇÇ\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.cyclesMap œÜ) S‚ÇÇ.iCycles) (CategoryTheory.CategoryStruct.comp S‚ÇÅ.iCycles œÜ.œÑ‚ÇÇ)","decl":"@[reassoc (attr := simp)]\nlemma cyclesMap_i : cyclesMap œÜ ‚â´ S‚ÇÇ.iCycles = S‚ÇÅ.iCycles ‚â´ œÜ.œÑ‚ÇÇ :=\n  cyclesMap'_i _ _ _\n\n"}
{"name":"CategoryTheory.ShortComplex.toCycles_naturality","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬≥ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroMorphisms C\nS‚ÇÅ S‚ÇÇ : CategoryTheory.ShortComplex C\ninst‚úù¬π : S‚ÇÅ.HasLeftHomology\ninst‚úù : S‚ÇÇ.HasLeftHomology\nœÜ : Quiver.Hom S‚ÇÅ S‚ÇÇ\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp S‚ÇÅ.toCycles (CategoryTheory.ShortComplex.cyclesMap œÜ)) (CategoryTheory.CategoryStruct.comp œÜ.œÑ‚ÇÅ S‚ÇÇ.toCycles)","decl":"@[reassoc (attr := simp)]\nlemma toCycles_naturality : S‚ÇÅ.toCycles ‚â´ cyclesMap œÜ = œÜ.œÑ‚ÇÅ ‚â´ S‚ÇÇ.toCycles :=\n  f'_cyclesMap' _ _ _\n\n"}
{"name":"CategoryTheory.ShortComplex.toCycles_naturality_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬≥ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroMorphisms C\nS‚ÇÅ S‚ÇÇ : CategoryTheory.ShortComplex C\ninst‚úù¬π : S‚ÇÅ.HasLeftHomology\ninst‚úù : S‚ÇÇ.HasLeftHomology\nœÜ : Quiver.Hom S‚ÇÅ S‚ÇÇ\nZ : C\nh : Quiver.Hom S‚ÇÇ.cycles Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp S‚ÇÅ.toCycles (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.cyclesMap œÜ) h)) (CategoryTheory.CategoryStruct.comp œÜ.œÑ‚ÇÅ (CategoryTheory.CategoryStruct.comp S‚ÇÇ.toCycles h))","decl":"@[reassoc (attr := simp)]\nlemma toCycles_naturality : S‚ÇÅ.toCycles ‚â´ cyclesMap œÜ = œÜ.œÑ‚ÇÅ ‚â´ S‚ÇÇ.toCycles :=\n  f'_cyclesMap' _ _ _\n\n"}
{"name":"CategoryTheory.ShortComplex.leftHomologyœÄ_naturality_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬≥ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroMorphisms C\nS‚ÇÅ S‚ÇÇ : CategoryTheory.ShortComplex C\ninst‚úù¬π : S‚ÇÅ.HasLeftHomology\ninst‚úù : S‚ÇÇ.HasLeftHomology\nœÜ : Quiver.Hom S‚ÇÅ S‚ÇÇ\nZ : C\nh : Quiver.Hom S‚ÇÇ.leftHomology Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp S‚ÇÅ.leftHomologyœÄ (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.leftHomologyMap œÜ) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.cyclesMap œÜ) (CategoryTheory.CategoryStruct.comp S‚ÇÇ.leftHomologyœÄ h))","decl":"@[reassoc (attr := simp)]\nlemma leftHomologyœÄ_naturality :\n    S‚ÇÅ.leftHomologyœÄ ‚â´ leftHomologyMap œÜ = cyclesMap œÜ ‚â´ S‚ÇÇ.leftHomologyœÄ :=\n  leftHomologyœÄ_naturality' _ _ _\n\n"}
{"name":"CategoryTheory.ShortComplex.leftHomologyœÄ_naturality","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬≥ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroMorphisms C\nS‚ÇÅ S‚ÇÇ : CategoryTheory.ShortComplex C\ninst‚úù¬π : S‚ÇÅ.HasLeftHomology\ninst‚úù : S‚ÇÇ.HasLeftHomology\nœÜ : Quiver.Hom S‚ÇÅ S‚ÇÇ\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp S‚ÇÅ.leftHomologyœÄ (CategoryTheory.ShortComplex.leftHomologyMap œÜ)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.cyclesMap œÜ) S‚ÇÇ.leftHomologyœÄ)","decl":"@[reassoc (attr := simp)]\nlemma leftHomologyœÄ_naturality :\n    S‚ÇÅ.leftHomologyœÄ ‚â´ leftHomologyMap œÜ = cyclesMap œÜ ‚â´ S‚ÇÇ.leftHomologyœÄ :=\n  leftHomologyœÄ_naturality' _ _ _\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyMapData.leftHomologyMap'_eq","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nS‚ÇÅ S‚ÇÇ : CategoryTheory.ShortComplex C\nœÜ : Quiver.Hom S‚ÇÅ S‚ÇÇ\nh‚ÇÅ : S‚ÇÅ.LeftHomologyData\nh‚ÇÇ : S‚ÇÇ.LeftHomologyData\nŒ≥ : CategoryTheory.ShortComplex.LeftHomologyMapData œÜ h‚ÇÅ h‚ÇÇ\n‚ä¢ Eq (CategoryTheory.ShortComplex.leftHomologyMap' œÜ h‚ÇÅ h‚ÇÇ) Œ≥.œÜH","decl":"lemma leftHomologyMap'_eq : leftHomologyMap' œÜ h‚ÇÅ h‚ÇÇ = Œ≥.œÜH :=\n  LeftHomologyMapData.congr_œÜH (Subsingleton.elim _ _)\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyMapData.cyclesMap'_eq","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nS‚ÇÅ S‚ÇÇ : CategoryTheory.ShortComplex C\nœÜ : Quiver.Hom S‚ÇÅ S‚ÇÇ\nh‚ÇÅ : S‚ÇÅ.LeftHomologyData\nh‚ÇÇ : S‚ÇÇ.LeftHomologyData\nŒ≥ : CategoryTheory.ShortComplex.LeftHomologyMapData œÜ h‚ÇÅ h‚ÇÇ\n‚ä¢ Eq (CategoryTheory.ShortComplex.cyclesMap' œÜ h‚ÇÅ h‚ÇÇ) Œ≥.œÜK","decl":"lemma cyclesMap'_eq : cyclesMap' œÜ h‚ÇÅ h‚ÇÇ = Œ≥.œÜK :=\n  LeftHomologyMapData.congr_œÜK (Subsingleton.elim _ _)\n\n"}
{"name":"CategoryTheory.ShortComplex.leftHomologyMap'_id","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nh : S.LeftHomologyData\n‚ä¢ Eq (CategoryTheory.ShortComplex.leftHomologyMap' (CategoryTheory.CategoryStruct.id S) h h) (CategoryTheory.CategoryStruct.id h.H)","decl":"@[simp]\nlemma leftHomologyMap'_id (h : S.LeftHomologyData) :\n    leftHomologyMap' (ùüô S) h h = ùüô _ :=\n  (LeftHomologyMapData.id h).leftHomologyMap'_eq\n\n"}
{"name":"CategoryTheory.ShortComplex.cyclesMap'_id","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nh : S.LeftHomologyData\n‚ä¢ Eq (CategoryTheory.ShortComplex.cyclesMap' (CategoryTheory.CategoryStruct.id S) h h) (CategoryTheory.CategoryStruct.id h.K)","decl":"@[simp]\nlemma cyclesMap'_id (h : S.LeftHomologyData) :\n    cyclesMap' (ùüô S) h h = ùüô _ :=\n  (LeftHomologyMapData.id h).cyclesMap'_eq\n\n"}
{"name":"CategoryTheory.ShortComplex.leftHomologyMap_id","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst‚úù : S.HasLeftHomology\n‚ä¢ Eq (CategoryTheory.ShortComplex.leftHomologyMap (CategoryTheory.CategoryStruct.id S)) (CategoryTheory.CategoryStruct.id S.leftHomology)","decl":"@[simp]\nlemma leftHomologyMap_id [HasLeftHomology S] :\n    leftHomologyMap (ùüô S) = ùüô _ :=\n  leftHomologyMap'_id _\n\n"}
{"name":"CategoryTheory.ShortComplex.cyclesMap_id","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst‚úù : S.HasLeftHomology\n‚ä¢ Eq (CategoryTheory.ShortComplex.cyclesMap (CategoryTheory.CategoryStruct.id S)) (CategoryTheory.CategoryStruct.id S.cycles)","decl":"@[simp]\nlemma cyclesMap_id [HasLeftHomology S] :\n    cyclesMap (ùüô S) = ùüô _ :=\n  cyclesMap'_id _\n\n"}
{"name":"CategoryTheory.ShortComplex.leftHomologyMap'_zero","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nS‚ÇÅ S‚ÇÇ : CategoryTheory.ShortComplex C\nh‚ÇÅ : S‚ÇÅ.LeftHomologyData\nh‚ÇÇ : S‚ÇÇ.LeftHomologyData\n‚ä¢ Eq (CategoryTheory.ShortComplex.leftHomologyMap' 0 h‚ÇÅ h‚ÇÇ) 0","decl":"@[simp]\nlemma leftHomologyMap'_zero (h‚ÇÅ : S‚ÇÅ.LeftHomologyData) (h‚ÇÇ : S‚ÇÇ.LeftHomologyData) :\n    leftHomologyMap' 0 h‚ÇÅ h‚ÇÇ = 0 :=\n  (LeftHomologyMapData.zero h‚ÇÅ h‚ÇÇ).leftHomologyMap'_eq\n\n"}
{"name":"CategoryTheory.ShortComplex.cyclesMap'_zero","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nS‚ÇÅ S‚ÇÇ : CategoryTheory.ShortComplex C\nh‚ÇÅ : S‚ÇÅ.LeftHomologyData\nh‚ÇÇ : S‚ÇÇ.LeftHomologyData\n‚ä¢ Eq (CategoryTheory.ShortComplex.cyclesMap' 0 h‚ÇÅ h‚ÇÇ) 0","decl":"@[simp]\nlemma cyclesMap'_zero (h‚ÇÅ : S‚ÇÅ.LeftHomologyData) (h‚ÇÇ : S‚ÇÇ.LeftHomologyData) :\n    cyclesMap' 0 h‚ÇÅ h‚ÇÇ = 0 :=\n  (LeftHomologyMapData.zero h‚ÇÅ h‚ÇÇ).cyclesMap'_eq\n\n"}
{"name":"CategoryTheory.ShortComplex.leftHomologyMap_zero","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬≥ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroMorphisms C\nS‚ÇÅ S‚ÇÇ : CategoryTheory.ShortComplex C\ninst‚úù¬π : S‚ÇÅ.HasLeftHomology\ninst‚úù : S‚ÇÇ.HasLeftHomology\n‚ä¢ Eq (CategoryTheory.ShortComplex.leftHomologyMap 0) 0","decl":"@[simp]\nlemma leftHomologyMap_zero [HasLeftHomology S‚ÇÅ] [HasLeftHomology S‚ÇÇ] :\n    leftHomologyMap (0 : S‚ÇÅ ‚ü∂ S‚ÇÇ) = 0 :=\n  leftHomologyMap'_zero _ _\n\n"}
{"name":"CategoryTheory.ShortComplex.cyclesMap_zero","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬≥ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroMorphisms C\nS‚ÇÅ S‚ÇÇ : CategoryTheory.ShortComplex C\ninst‚úù¬π : S‚ÇÅ.HasLeftHomology\ninst‚úù : S‚ÇÇ.HasLeftHomology\n‚ä¢ Eq (CategoryTheory.ShortComplex.cyclesMap 0) 0","decl":"@[simp]\nlemma cyclesMap_zero [HasLeftHomology S‚ÇÅ] [HasLeftHomology S‚ÇÇ] :\n    cyclesMap (0 : S‚ÇÅ ‚ü∂ S‚ÇÇ) = 0 :=\n  cyclesMap'_zero _ _\n\n"}
{"name":"CategoryTheory.ShortComplex.leftHomologyMap'_comp_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nS‚ÇÅ S‚ÇÇ S‚ÇÉ : CategoryTheory.ShortComplex C\nœÜ‚ÇÅ : Quiver.Hom S‚ÇÅ S‚ÇÇ\nœÜ‚ÇÇ : Quiver.Hom S‚ÇÇ S‚ÇÉ\nh‚ÇÅ : S‚ÇÅ.LeftHomologyData\nh‚ÇÇ : S‚ÇÇ.LeftHomologyData\nh‚ÇÉ : S‚ÇÉ.LeftHomologyData\nZ : C\nh : Quiver.Hom h‚ÇÉ.H Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.leftHomologyMap' (CategoryTheory.CategoryStruct.comp œÜ‚ÇÅ œÜ‚ÇÇ) h‚ÇÅ h‚ÇÉ) h) (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.leftHomologyMap' œÜ‚ÇÅ h‚ÇÅ h‚ÇÇ) (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.leftHomologyMap' œÜ‚ÇÇ h‚ÇÇ h‚ÇÉ) h))","decl":"@[reassoc]\nlemma leftHomologyMap'_comp (œÜ‚ÇÅ : S‚ÇÅ ‚ü∂ S‚ÇÇ) (œÜ‚ÇÇ : S‚ÇÇ ‚ü∂ S‚ÇÉ)\n    (h‚ÇÅ : S‚ÇÅ.LeftHomologyData) (h‚ÇÇ : S‚ÇÇ.LeftHomologyData) (h‚ÇÉ : S‚ÇÉ.LeftHomologyData) :\n    leftHomologyMap' (œÜ‚ÇÅ ‚â´ œÜ‚ÇÇ) h‚ÇÅ h‚ÇÉ = leftHomologyMap' œÜ‚ÇÅ h‚ÇÅ h‚ÇÇ ‚â´\n      leftHomologyMap' œÜ‚ÇÇ h‚ÇÇ h‚ÇÉ := by\n  let Œ≥‚ÇÅ := leftHomologyMapData œÜ‚ÇÅ h‚ÇÅ h‚ÇÇ\n  let Œ≥‚ÇÇ := leftHomologyMapData œÜ‚ÇÇ h‚ÇÇ h‚ÇÉ\n  rw [Œ≥‚ÇÅ.leftHomologyMap'_eq, Œ≥‚ÇÇ.leftHomologyMap'_eq, (Œ≥‚ÇÅ.comp Œ≥‚ÇÇ).leftHomologyMap'_eq,\n    LeftHomologyMapData.comp_œÜH]\n\n"}
{"name":"CategoryTheory.ShortComplex.leftHomologyMap'_comp","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nS‚ÇÅ S‚ÇÇ S‚ÇÉ : CategoryTheory.ShortComplex C\nœÜ‚ÇÅ : Quiver.Hom S‚ÇÅ S‚ÇÇ\nœÜ‚ÇÇ : Quiver.Hom S‚ÇÇ S‚ÇÉ\nh‚ÇÅ : S‚ÇÅ.LeftHomologyData\nh‚ÇÇ : S‚ÇÇ.LeftHomologyData\nh‚ÇÉ : S‚ÇÉ.LeftHomologyData\n‚ä¢ Eq (CategoryTheory.ShortComplex.leftHomologyMap' (CategoryTheory.CategoryStruct.comp œÜ‚ÇÅ œÜ‚ÇÇ) h‚ÇÅ h‚ÇÉ) (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.leftHomologyMap' œÜ‚ÇÅ h‚ÇÅ h‚ÇÇ) (CategoryTheory.ShortComplex.leftHomologyMap' œÜ‚ÇÇ h‚ÇÇ h‚ÇÉ))","decl":"@[reassoc]\nlemma leftHomologyMap'_comp (œÜ‚ÇÅ : S‚ÇÅ ‚ü∂ S‚ÇÇ) (œÜ‚ÇÇ : S‚ÇÇ ‚ü∂ S‚ÇÉ)\n    (h‚ÇÅ : S‚ÇÅ.LeftHomologyData) (h‚ÇÇ : S‚ÇÇ.LeftHomologyData) (h‚ÇÉ : S‚ÇÉ.LeftHomologyData) :\n    leftHomologyMap' (œÜ‚ÇÅ ‚â´ œÜ‚ÇÇ) h‚ÇÅ h‚ÇÉ = leftHomologyMap' œÜ‚ÇÅ h‚ÇÅ h‚ÇÇ ‚â´\n      leftHomologyMap' œÜ‚ÇÇ h‚ÇÇ h‚ÇÉ := by\n  let Œ≥‚ÇÅ := leftHomologyMapData œÜ‚ÇÅ h‚ÇÅ h‚ÇÇ\n  let Œ≥‚ÇÇ := leftHomologyMapData œÜ‚ÇÇ h‚ÇÇ h‚ÇÉ\n  rw [Œ≥‚ÇÅ.leftHomologyMap'_eq, Œ≥‚ÇÇ.leftHomologyMap'_eq, (Œ≥‚ÇÅ.comp Œ≥‚ÇÇ).leftHomologyMap'_eq,\n    LeftHomologyMapData.comp_œÜH]\n\n"}
{"name":"CategoryTheory.ShortComplex.cyclesMap'_comp","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nS‚ÇÅ S‚ÇÇ S‚ÇÉ : CategoryTheory.ShortComplex C\nœÜ‚ÇÅ : Quiver.Hom S‚ÇÅ S‚ÇÇ\nœÜ‚ÇÇ : Quiver.Hom S‚ÇÇ S‚ÇÉ\nh‚ÇÅ : S‚ÇÅ.LeftHomologyData\nh‚ÇÇ : S‚ÇÇ.LeftHomologyData\nh‚ÇÉ : S‚ÇÉ.LeftHomologyData\n‚ä¢ Eq (CategoryTheory.ShortComplex.cyclesMap' (CategoryTheory.CategoryStruct.comp œÜ‚ÇÅ œÜ‚ÇÇ) h‚ÇÅ h‚ÇÉ) (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.cyclesMap' œÜ‚ÇÅ h‚ÇÅ h‚ÇÇ) (CategoryTheory.ShortComplex.cyclesMap' œÜ‚ÇÇ h‚ÇÇ h‚ÇÉ))","decl":"@[reassoc]\nlemma cyclesMap'_comp (œÜ‚ÇÅ : S‚ÇÅ ‚ü∂ S‚ÇÇ) (œÜ‚ÇÇ : S‚ÇÇ ‚ü∂ S‚ÇÉ)\n    (h‚ÇÅ : S‚ÇÅ.LeftHomologyData) (h‚ÇÇ : S‚ÇÇ.LeftHomologyData) (h‚ÇÉ : S‚ÇÉ.LeftHomologyData) :\n    cyclesMap' (œÜ‚ÇÅ ‚â´ œÜ‚ÇÇ) h‚ÇÅ h‚ÇÉ = cyclesMap' œÜ‚ÇÅ h‚ÇÅ h‚ÇÇ ‚â´ cyclesMap' œÜ‚ÇÇ h‚ÇÇ h‚ÇÉ := by\n  let Œ≥‚ÇÅ := leftHomologyMapData œÜ‚ÇÅ h‚ÇÅ h‚ÇÇ\n  let Œ≥‚ÇÇ := leftHomologyMapData œÜ‚ÇÇ h‚ÇÇ h‚ÇÉ\n  rw [Œ≥‚ÇÅ.cyclesMap'_eq, Œ≥‚ÇÇ.cyclesMap'_eq, (Œ≥‚ÇÅ.comp Œ≥‚ÇÇ).cyclesMap'_eq,\n    LeftHomologyMapData.comp_œÜK]\n\n"}
{"name":"CategoryTheory.ShortComplex.cyclesMap'_comp_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nS‚ÇÅ S‚ÇÇ S‚ÇÉ : CategoryTheory.ShortComplex C\nœÜ‚ÇÅ : Quiver.Hom S‚ÇÅ S‚ÇÇ\nœÜ‚ÇÇ : Quiver.Hom S‚ÇÇ S‚ÇÉ\nh‚ÇÅ : S‚ÇÅ.LeftHomologyData\nh‚ÇÇ : S‚ÇÇ.LeftHomologyData\nh‚ÇÉ : S‚ÇÉ.LeftHomologyData\nZ : C\nh : Quiver.Hom h‚ÇÉ.K Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.cyclesMap' (CategoryTheory.CategoryStruct.comp œÜ‚ÇÅ œÜ‚ÇÇ) h‚ÇÅ h‚ÇÉ) h) (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.cyclesMap' œÜ‚ÇÅ h‚ÇÅ h‚ÇÇ) (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.cyclesMap' œÜ‚ÇÇ h‚ÇÇ h‚ÇÉ) h))","decl":"@[reassoc]\nlemma cyclesMap'_comp (œÜ‚ÇÅ : S‚ÇÅ ‚ü∂ S‚ÇÇ) (œÜ‚ÇÇ : S‚ÇÇ ‚ü∂ S‚ÇÉ)\n    (h‚ÇÅ : S‚ÇÅ.LeftHomologyData) (h‚ÇÇ : S‚ÇÇ.LeftHomologyData) (h‚ÇÉ : S‚ÇÉ.LeftHomologyData) :\n    cyclesMap' (œÜ‚ÇÅ ‚â´ œÜ‚ÇÇ) h‚ÇÅ h‚ÇÉ = cyclesMap' œÜ‚ÇÅ h‚ÇÅ h‚ÇÇ ‚â´ cyclesMap' œÜ‚ÇÇ h‚ÇÇ h‚ÇÉ := by\n  let Œ≥‚ÇÅ := leftHomologyMapData œÜ‚ÇÅ h‚ÇÅ h‚ÇÇ\n  let Œ≥‚ÇÇ := leftHomologyMapData œÜ‚ÇÇ h‚ÇÇ h‚ÇÉ\n  rw [Œ≥‚ÇÅ.cyclesMap'_eq, Œ≥‚ÇÇ.cyclesMap'_eq, (Œ≥‚ÇÅ.comp Œ≥‚ÇÇ).cyclesMap'_eq,\n    LeftHomologyMapData.comp_œÜK]\n\n"}
{"name":"CategoryTheory.ShortComplex.leftHomologyMap_comp_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù¬≥ : CategoryTheory.Limits.HasZeroMorphisms C\nS‚ÇÅ S‚ÇÇ S‚ÇÉ : CategoryTheory.ShortComplex C\ninst‚úù¬≤ : S‚ÇÅ.HasLeftHomology\ninst‚úù¬π : S‚ÇÇ.HasLeftHomology\ninst‚úù : S‚ÇÉ.HasLeftHomology\nœÜ‚ÇÅ : Quiver.Hom S‚ÇÅ S‚ÇÇ\nœÜ‚ÇÇ : Quiver.Hom S‚ÇÇ S‚ÇÉ\nZ : C\nh : Quiver.Hom S‚ÇÉ.leftHomology Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.leftHomologyMap (CategoryTheory.CategoryStruct.comp œÜ‚ÇÅ œÜ‚ÇÇ)) h) (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.leftHomologyMap œÜ‚ÇÅ) (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.leftHomologyMap œÜ‚ÇÇ) h))","decl":"@[reassoc]\nlemma leftHomologyMap_comp [HasLeftHomology S‚ÇÅ] [HasLeftHomology S‚ÇÇ] [HasLeftHomology S‚ÇÉ]\n    (œÜ‚ÇÅ : S‚ÇÅ ‚ü∂ S‚ÇÇ) (œÜ‚ÇÇ : S‚ÇÇ ‚ü∂ S‚ÇÉ) :\n    leftHomologyMap (œÜ‚ÇÅ ‚â´ œÜ‚ÇÇ) = leftHomologyMap œÜ‚ÇÅ ‚â´ leftHomologyMap œÜ‚ÇÇ :=\n  leftHomologyMap'_comp _ _ _ _ _\n\n"}
{"name":"CategoryTheory.ShortComplex.leftHomologyMap_comp","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù¬≥ : CategoryTheory.Limits.HasZeroMorphisms C\nS‚ÇÅ S‚ÇÇ S‚ÇÉ : CategoryTheory.ShortComplex C\ninst‚úù¬≤ : S‚ÇÅ.HasLeftHomology\ninst‚úù¬π : S‚ÇÇ.HasLeftHomology\ninst‚úù : S‚ÇÉ.HasLeftHomology\nœÜ‚ÇÅ : Quiver.Hom S‚ÇÅ S‚ÇÇ\nœÜ‚ÇÇ : Quiver.Hom S‚ÇÇ S‚ÇÉ\n‚ä¢ Eq (CategoryTheory.ShortComplex.leftHomologyMap (CategoryTheory.CategoryStruct.comp œÜ‚ÇÅ œÜ‚ÇÇ)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.leftHomologyMap œÜ‚ÇÅ) (CategoryTheory.ShortComplex.leftHomologyMap œÜ‚ÇÇ))","decl":"@[reassoc]\nlemma leftHomologyMap_comp [HasLeftHomology S‚ÇÅ] [HasLeftHomology S‚ÇÇ] [HasLeftHomology S‚ÇÉ]\n    (œÜ‚ÇÅ : S‚ÇÅ ‚ü∂ S‚ÇÇ) (œÜ‚ÇÇ : S‚ÇÇ ‚ü∂ S‚ÇÉ) :\n    leftHomologyMap (œÜ‚ÇÅ ‚â´ œÜ‚ÇÇ) = leftHomologyMap œÜ‚ÇÅ ‚â´ leftHomologyMap œÜ‚ÇÇ :=\n  leftHomologyMap'_comp _ _ _ _ _\n\n"}
{"name":"CategoryTheory.ShortComplex.cyclesMap_comp_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù¬≥ : CategoryTheory.Limits.HasZeroMorphisms C\nS‚ÇÅ S‚ÇÇ S‚ÇÉ : CategoryTheory.ShortComplex C\ninst‚úù¬≤ : S‚ÇÅ.HasLeftHomology\ninst‚úù¬π : S‚ÇÇ.HasLeftHomology\ninst‚úù : S‚ÇÉ.HasLeftHomology\nœÜ‚ÇÅ : Quiver.Hom S‚ÇÅ S‚ÇÇ\nœÜ‚ÇÇ : Quiver.Hom S‚ÇÇ S‚ÇÉ\nZ : C\nh : Quiver.Hom S‚ÇÉ.cycles Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.cyclesMap (CategoryTheory.CategoryStruct.comp œÜ‚ÇÅ œÜ‚ÇÇ)) h) (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.cyclesMap œÜ‚ÇÅ) (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.cyclesMap œÜ‚ÇÇ) h))","decl":"@[reassoc]\nlemma cyclesMap_comp [HasLeftHomology S‚ÇÅ] [HasLeftHomology S‚ÇÇ] [HasLeftHomology S‚ÇÉ]\n    (œÜ‚ÇÅ : S‚ÇÅ ‚ü∂ S‚ÇÇ) (œÜ‚ÇÇ : S‚ÇÇ ‚ü∂ S‚ÇÉ) :\n    cyclesMap (œÜ‚ÇÅ ‚â´ œÜ‚ÇÇ) = cyclesMap œÜ‚ÇÅ ‚â´ cyclesMap œÜ‚ÇÇ :=\n  cyclesMap'_comp _ _ _ _ _\n\n"}
{"name":"CategoryTheory.ShortComplex.cyclesMap_comp","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù¬≥ : CategoryTheory.Limits.HasZeroMorphisms C\nS‚ÇÅ S‚ÇÇ S‚ÇÉ : CategoryTheory.ShortComplex C\ninst‚úù¬≤ : S‚ÇÅ.HasLeftHomology\ninst‚úù¬π : S‚ÇÇ.HasLeftHomology\ninst‚úù : S‚ÇÉ.HasLeftHomology\nœÜ‚ÇÅ : Quiver.Hom S‚ÇÅ S‚ÇÇ\nœÜ‚ÇÇ : Quiver.Hom S‚ÇÇ S‚ÇÉ\n‚ä¢ Eq (CategoryTheory.ShortComplex.cyclesMap (CategoryTheory.CategoryStruct.comp œÜ‚ÇÅ œÜ‚ÇÇ)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.cyclesMap œÜ‚ÇÅ) (CategoryTheory.ShortComplex.cyclesMap œÜ‚ÇÇ))","decl":"@[reassoc]\nlemma cyclesMap_comp [HasLeftHomology S‚ÇÅ] [HasLeftHomology S‚ÇÇ] [HasLeftHomology S‚ÇÉ]\n    (œÜ‚ÇÅ : S‚ÇÅ ‚ü∂ S‚ÇÇ) (œÜ‚ÇÇ : S‚ÇÇ ‚ü∂ S‚ÇÉ) :\n    cyclesMap (œÜ‚ÇÅ ‚â´ œÜ‚ÇÇ) = cyclesMap œÜ‚ÇÅ ‚â´ cyclesMap œÜ‚ÇÇ :=\n  cyclesMap'_comp _ _ _ _ _\n\n"}
{"name":"CategoryTheory.ShortComplex.leftHomologyMapIso'_hom","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nS‚ÇÅ S‚ÇÇ : CategoryTheory.ShortComplex C\ne : CategoryTheory.Iso S‚ÇÅ S‚ÇÇ\nh‚ÇÅ : S‚ÇÅ.LeftHomologyData\nh‚ÇÇ : S‚ÇÇ.LeftHomologyData\n‚ä¢ Eq (CategoryTheory.ShortComplex.leftHomologyMapIso' e h‚ÇÅ h‚ÇÇ).hom (CategoryTheory.ShortComplex.leftHomologyMap' e.hom h‚ÇÅ h‚ÇÇ)","decl":"/-- An isomorphism of short complexes `S‚ÇÅ ‚âÖ S‚ÇÇ` induces an isomorphism on the `H` fields\nof left homology data of `S‚ÇÅ` and `S‚ÇÇ`. -/\n@[simps]\ndef leftHomologyMapIso' (e : S‚ÇÅ ‚âÖ S‚ÇÇ) (h‚ÇÅ : S‚ÇÅ.LeftHomologyData)\n    (h‚ÇÇ : S‚ÇÇ.LeftHomologyData) : h‚ÇÅ.H ‚âÖ h‚ÇÇ.H where\n  hom := leftHomologyMap' e.hom h‚ÇÅ h‚ÇÇ\n  inv := leftHomologyMap' e.inv h‚ÇÇ h‚ÇÅ\n  hom_inv_id := by rw [‚Üê leftHomologyMap'_comp, e.hom_inv_id, leftHomologyMap'_id]\n  inv_hom_id := by rw [‚Üê leftHomologyMap'_comp, e.inv_hom_id, leftHomologyMap'_id]\n\n"}
{"name":"CategoryTheory.ShortComplex.leftHomologyMapIso'_inv","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nS‚ÇÅ S‚ÇÇ : CategoryTheory.ShortComplex C\ne : CategoryTheory.Iso S‚ÇÅ S‚ÇÇ\nh‚ÇÅ : S‚ÇÅ.LeftHomologyData\nh‚ÇÇ : S‚ÇÇ.LeftHomologyData\n‚ä¢ Eq (CategoryTheory.ShortComplex.leftHomologyMapIso' e h‚ÇÅ h‚ÇÇ).inv (CategoryTheory.ShortComplex.leftHomologyMap' e.inv h‚ÇÇ h‚ÇÅ)","decl":"/-- An isomorphism of short complexes `S‚ÇÅ ‚âÖ S‚ÇÇ` induces an isomorphism on the `H` fields\nof left homology data of `S‚ÇÅ` and `S‚ÇÇ`. -/\n@[simps]\ndef leftHomologyMapIso' (e : S‚ÇÅ ‚âÖ S‚ÇÇ) (h‚ÇÅ : S‚ÇÅ.LeftHomologyData)\n    (h‚ÇÇ : S‚ÇÇ.LeftHomologyData) : h‚ÇÅ.H ‚âÖ h‚ÇÇ.H where\n  hom := leftHomologyMap' e.hom h‚ÇÅ h‚ÇÇ\n  inv := leftHomologyMap' e.inv h‚ÇÇ h‚ÇÅ\n  hom_inv_id := by rw [‚Üê leftHomologyMap'_comp, e.hom_inv_id, leftHomologyMap'_id]\n  inv_hom_id := by rw [‚Üê leftHomologyMap'_comp, e.inv_hom_id, leftHomologyMap'_id]\n\n"}
{"name":"CategoryTheory.ShortComplex.isIso_leftHomologyMap'_of_isIso","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms C\nS‚ÇÅ S‚ÇÇ : CategoryTheory.ShortComplex C\nœÜ : Quiver.Hom S‚ÇÅ S‚ÇÇ\ninst‚úù : CategoryTheory.IsIso œÜ\nh‚ÇÅ : S‚ÇÅ.LeftHomologyData\nh‚ÇÇ : S‚ÇÇ.LeftHomologyData\n‚ä¢ CategoryTheory.IsIso (CategoryTheory.ShortComplex.leftHomologyMap' œÜ h‚ÇÅ h‚ÇÇ)","decl":"instance isIso_leftHomologyMap'_of_isIso (œÜ : S‚ÇÅ ‚ü∂ S‚ÇÇ) [IsIso œÜ]\n    (h‚ÇÅ : S‚ÇÅ.LeftHomologyData) (h‚ÇÇ : S‚ÇÇ.LeftHomologyData) :\n    IsIso (leftHomologyMap' œÜ h‚ÇÅ h‚ÇÇ) :=\n  (inferInstance : IsIso (leftHomologyMapIso' (asIso œÜ) h‚ÇÅ h‚ÇÇ).hom)\n\n"}
{"name":"CategoryTheory.ShortComplex.cyclesMapIso'_hom","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nS‚ÇÅ S‚ÇÇ : CategoryTheory.ShortComplex C\ne : CategoryTheory.Iso S‚ÇÅ S‚ÇÇ\nh‚ÇÅ : S‚ÇÅ.LeftHomologyData\nh‚ÇÇ : S‚ÇÇ.LeftHomologyData\n‚ä¢ Eq (CategoryTheory.ShortComplex.cyclesMapIso' e h‚ÇÅ h‚ÇÇ).hom (CategoryTheory.ShortComplex.cyclesMap' e.hom h‚ÇÅ h‚ÇÇ)","decl":"/-- An isomorphism of short complexes `S‚ÇÅ ‚âÖ S‚ÇÇ` induces an isomorphism on the `K` fields\nof left homology data of `S‚ÇÅ` and `S‚ÇÇ`. -/\n@[simps]\ndef cyclesMapIso' (e : S‚ÇÅ ‚âÖ S‚ÇÇ) (h‚ÇÅ : S‚ÇÅ.LeftHomologyData)\n    (h‚ÇÇ : S‚ÇÇ.LeftHomologyData) : h‚ÇÅ.K ‚âÖ h‚ÇÇ.K where\n  hom := cyclesMap' e.hom h‚ÇÅ h‚ÇÇ\n  inv := cyclesMap' e.inv h‚ÇÇ h‚ÇÅ\n  hom_inv_id := by rw [‚Üê cyclesMap'_comp, e.hom_inv_id, cyclesMap'_id]\n  inv_hom_id := by rw [‚Üê cyclesMap'_comp, e.inv_hom_id, cyclesMap'_id]\n\n"}
{"name":"CategoryTheory.ShortComplex.cyclesMapIso'_inv","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nS‚ÇÅ S‚ÇÇ : CategoryTheory.ShortComplex C\ne : CategoryTheory.Iso S‚ÇÅ S‚ÇÇ\nh‚ÇÅ : S‚ÇÅ.LeftHomologyData\nh‚ÇÇ : S‚ÇÇ.LeftHomologyData\n‚ä¢ Eq (CategoryTheory.ShortComplex.cyclesMapIso' e h‚ÇÅ h‚ÇÇ).inv (CategoryTheory.ShortComplex.cyclesMap' e.inv h‚ÇÇ h‚ÇÅ)","decl":"/-- An isomorphism of short complexes `S‚ÇÅ ‚âÖ S‚ÇÇ` induces an isomorphism on the `K` fields\nof left homology data of `S‚ÇÅ` and `S‚ÇÇ`. -/\n@[simps]\ndef cyclesMapIso' (e : S‚ÇÅ ‚âÖ S‚ÇÇ) (h‚ÇÅ : S‚ÇÅ.LeftHomologyData)\n    (h‚ÇÇ : S‚ÇÇ.LeftHomologyData) : h‚ÇÅ.K ‚âÖ h‚ÇÇ.K where\n  hom := cyclesMap' e.hom h‚ÇÅ h‚ÇÇ\n  inv := cyclesMap' e.inv h‚ÇÇ h‚ÇÅ\n  hom_inv_id := by rw [‚Üê cyclesMap'_comp, e.hom_inv_id, cyclesMap'_id]\n  inv_hom_id := by rw [‚Üê cyclesMap'_comp, e.inv_hom_id, cyclesMap'_id]\n\n"}
{"name":"CategoryTheory.ShortComplex.isIso_cyclesMap'_of_isIso","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms C\nS‚ÇÅ S‚ÇÇ : CategoryTheory.ShortComplex C\nœÜ : Quiver.Hom S‚ÇÅ S‚ÇÇ\ninst‚úù : CategoryTheory.IsIso œÜ\nh‚ÇÅ : S‚ÇÅ.LeftHomologyData\nh‚ÇÇ : S‚ÇÇ.LeftHomologyData\n‚ä¢ CategoryTheory.IsIso (CategoryTheory.ShortComplex.cyclesMap' œÜ h‚ÇÅ h‚ÇÇ)","decl":"instance isIso_cyclesMap'_of_isIso (œÜ : S‚ÇÅ ‚ü∂ S‚ÇÇ) [IsIso œÜ]\n    (h‚ÇÅ : S‚ÇÅ.LeftHomologyData) (h‚ÇÇ : S‚ÇÇ.LeftHomologyData) :\n    IsIso (cyclesMap' œÜ h‚ÇÅ h‚ÇÇ) :=\n  (inferInstance : IsIso (cyclesMapIso' (asIso œÜ) h‚ÇÅ h‚ÇÇ).hom)\n\n"}
{"name":"CategoryTheory.ShortComplex.leftHomologyMapIso_hom","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬≥ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroMorphisms C\nS‚ÇÅ S‚ÇÇ : CategoryTheory.ShortComplex C\ne : CategoryTheory.Iso S‚ÇÅ S‚ÇÇ\ninst‚úù¬π : S‚ÇÅ.HasLeftHomology\ninst‚úù : S‚ÇÇ.HasLeftHomology\n‚ä¢ Eq (CategoryTheory.ShortComplex.leftHomologyMapIso e).hom (CategoryTheory.ShortComplex.leftHomologyMap e.hom)","decl":"/-- The isomorphism `S‚ÇÅ.leftHomology ‚âÖ S‚ÇÇ.leftHomology` induced by an isomorphism of\nshort complexes `S‚ÇÅ ‚âÖ S‚ÇÇ`. -/\n@[simps]\nnoncomputable def leftHomologyMapIso (e : S‚ÇÅ ‚âÖ S‚ÇÇ) [S‚ÇÅ.HasLeftHomology]\n    [S‚ÇÇ.HasLeftHomology] : S‚ÇÅ.leftHomology ‚âÖ S‚ÇÇ.leftHomology where\n  hom := leftHomologyMap e.hom\n  inv := leftHomologyMap e.inv\n  hom_inv_id := by rw [‚Üê leftHomologyMap_comp, e.hom_inv_id, leftHomologyMap_id]\n  inv_hom_id := by rw [‚Üê leftHomologyMap_comp, e.inv_hom_id, leftHomologyMap_id]\n\n"}
{"name":"CategoryTheory.ShortComplex.leftHomologyMapIso_inv","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬≥ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroMorphisms C\nS‚ÇÅ S‚ÇÇ : CategoryTheory.ShortComplex C\ne : CategoryTheory.Iso S‚ÇÅ S‚ÇÇ\ninst‚úù¬π : S‚ÇÅ.HasLeftHomology\ninst‚úù : S‚ÇÇ.HasLeftHomology\n‚ä¢ Eq (CategoryTheory.ShortComplex.leftHomologyMapIso e).inv (CategoryTheory.ShortComplex.leftHomologyMap e.inv)","decl":"/-- The isomorphism `S‚ÇÅ.leftHomology ‚âÖ S‚ÇÇ.leftHomology` induced by an isomorphism of\nshort complexes `S‚ÇÅ ‚âÖ S‚ÇÇ`. -/\n@[simps]\nnoncomputable def leftHomologyMapIso (e : S‚ÇÅ ‚âÖ S‚ÇÇ) [S‚ÇÅ.HasLeftHomology]\n    [S‚ÇÇ.HasLeftHomology] : S‚ÇÅ.leftHomology ‚âÖ S‚ÇÇ.leftHomology where\n  hom := leftHomologyMap e.hom\n  inv := leftHomologyMap e.inv\n  hom_inv_id := by rw [‚Üê leftHomologyMap_comp, e.hom_inv_id, leftHomologyMap_id]\n  inv_hom_id := by rw [‚Üê leftHomologyMap_comp, e.inv_hom_id, leftHomologyMap_id]\n\n"}
{"name":"CategoryTheory.ShortComplex.isIso_leftHomologyMap_of_iso","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù¬≥ : CategoryTheory.Limits.HasZeroMorphisms C\nS‚ÇÅ S‚ÇÇ : CategoryTheory.ShortComplex C\nœÜ : Quiver.Hom S‚ÇÅ S‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.IsIso œÜ\ninst‚úù¬π : S‚ÇÅ.HasLeftHomology\ninst‚úù : S‚ÇÇ.HasLeftHomology\n‚ä¢ CategoryTheory.IsIso (CategoryTheory.ShortComplex.leftHomologyMap œÜ)","decl":"instance isIso_leftHomologyMap_of_iso (œÜ : S‚ÇÅ ‚ü∂ S‚ÇÇ)\n    [IsIso œÜ] [S‚ÇÅ.HasLeftHomology] [S‚ÇÇ.HasLeftHomology] :\n    IsIso (leftHomologyMap œÜ) :=\n  (inferInstance : IsIso (leftHomologyMapIso (asIso œÜ)).hom)\n\n"}
{"name":"CategoryTheory.ShortComplex.cyclesMapIso_hom","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬≥ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroMorphisms C\nS‚ÇÅ S‚ÇÇ : CategoryTheory.ShortComplex C\ne : CategoryTheory.Iso S‚ÇÅ S‚ÇÇ\ninst‚úù¬π : S‚ÇÅ.HasLeftHomology\ninst‚úù : S‚ÇÇ.HasLeftHomology\n‚ä¢ Eq (CategoryTheory.ShortComplex.cyclesMapIso e).hom (CategoryTheory.ShortComplex.cyclesMap e.hom)","decl":"/-- The isomorphism `S‚ÇÅ.cycles ‚âÖ S‚ÇÇ.cycles` induced by an isomorphism\nof short complexes `S‚ÇÅ ‚âÖ S‚ÇÇ`. -/\n@[simps]\nnoncomputable def cyclesMapIso (e : S‚ÇÅ ‚âÖ S‚ÇÇ) [S‚ÇÅ.HasLeftHomology]\n    [S‚ÇÇ.HasLeftHomology] : S‚ÇÅ.cycles ‚âÖ S‚ÇÇ.cycles where\n  hom := cyclesMap e.hom\n  inv := cyclesMap e.inv\n  hom_inv_id := by rw [‚Üê cyclesMap_comp, e.hom_inv_id, cyclesMap_id]\n  inv_hom_id := by rw [‚Üê cyclesMap_comp, e.inv_hom_id, cyclesMap_id]\n\n"}
{"name":"CategoryTheory.ShortComplex.cyclesMapIso_inv","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬≥ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroMorphisms C\nS‚ÇÅ S‚ÇÇ : CategoryTheory.ShortComplex C\ne : CategoryTheory.Iso S‚ÇÅ S‚ÇÇ\ninst‚úù¬π : S‚ÇÅ.HasLeftHomology\ninst‚úù : S‚ÇÇ.HasLeftHomology\n‚ä¢ Eq (CategoryTheory.ShortComplex.cyclesMapIso e).inv (CategoryTheory.ShortComplex.cyclesMap e.inv)","decl":"/-- The isomorphism `S‚ÇÅ.cycles ‚âÖ S‚ÇÇ.cycles` induced by an isomorphism\nof short complexes `S‚ÇÅ ‚âÖ S‚ÇÇ`. -/\n@[simps]\nnoncomputable def cyclesMapIso (e : S‚ÇÅ ‚âÖ S‚ÇÇ) [S‚ÇÅ.HasLeftHomology]\n    [S‚ÇÇ.HasLeftHomology] : S‚ÇÅ.cycles ‚âÖ S‚ÇÇ.cycles where\n  hom := cyclesMap e.hom\n  inv := cyclesMap e.inv\n  hom_inv_id := by rw [‚Üê cyclesMap_comp, e.hom_inv_id, cyclesMap_id]\n  inv_hom_id := by rw [‚Üê cyclesMap_comp, e.inv_hom_id, cyclesMap_id]\n\n"}
{"name":"CategoryTheory.ShortComplex.isIso_cyclesMap_of_iso","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù¬≥ : CategoryTheory.Limits.HasZeroMorphisms C\nS‚ÇÅ S‚ÇÇ : CategoryTheory.ShortComplex C\nœÜ : Quiver.Hom S‚ÇÅ S‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.IsIso œÜ\ninst‚úù¬π : S‚ÇÅ.HasLeftHomology\ninst‚úù : S‚ÇÇ.HasLeftHomology\n‚ä¢ CategoryTheory.IsIso (CategoryTheory.ShortComplex.cyclesMap œÜ)","decl":"instance isIso_cyclesMap_of_iso (œÜ : S‚ÇÅ ‚ü∂ S‚ÇÇ) [IsIso œÜ] [S‚ÇÅ.HasLeftHomology]\n    [S‚ÇÇ.HasLeftHomology] : IsIso (cyclesMap œÜ) :=\n  (inferInstance : IsIso (cyclesMapIso (asIso œÜ)).hom)\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.cyclesIso_hom_comp_i_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nh‚úù : S.LeftHomologyData\ninst‚úù : S.HasLeftHomology\nZ : C\nh : Quiver.Hom S.X‚ÇÇ Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp h‚úù.cyclesIso.hom (CategoryTheory.CategoryStruct.comp h‚úù.i h)) (CategoryTheory.CategoryStruct.comp S.iCycles h)","decl":"@[reassoc (attr := simp)]\nlemma cyclesIso_hom_comp_i : h.cyclesIso.hom ‚â´ h.i = S.iCycles := by\n  dsimp [iCycles, LeftHomologyData.cyclesIso]\n  simp only [cyclesMap'_i, id_œÑ‚ÇÇ, comp_id]\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.cyclesIso_hom_comp_i","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nh : S.LeftHomologyData\ninst‚úù : S.HasLeftHomology\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp h.cyclesIso.hom h.i) S.iCycles","decl":"@[reassoc (attr := simp)]\nlemma cyclesIso_hom_comp_i : h.cyclesIso.hom ‚â´ h.i = S.iCycles := by\n  dsimp [iCycles, LeftHomologyData.cyclesIso]\n  simp only [cyclesMap'_i, id_œÑ‚ÇÇ, comp_id]\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.cyclesIso_inv_comp_iCycles","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nh : S.LeftHomologyData\ninst‚úù : S.HasLeftHomology\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp h.cyclesIso.inv S.iCycles) h.i","decl":"@[reassoc (attr := simp)]\nlemma cyclesIso_inv_comp_iCycles : h.cyclesIso.inv ‚â´ S.iCycles = h.i := by\n  simp only [‚Üê h.cyclesIso_hom_comp_i, Iso.inv_hom_id_assoc]\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.cyclesIso_inv_comp_iCycles_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nh‚úù : S.LeftHomologyData\ninst‚úù : S.HasLeftHomology\nZ : C\nh : Quiver.Hom S.X‚ÇÇ Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp h‚úù.cyclesIso.inv (CategoryTheory.CategoryStruct.comp S.iCycles h)) (CategoryTheory.CategoryStruct.comp h‚úù.i h)","decl":"@[reassoc (attr := simp)]\nlemma cyclesIso_inv_comp_iCycles : h.cyclesIso.inv ‚â´ S.iCycles = h.i := by\n  simp only [‚Üê h.cyclesIso_hom_comp_i, Iso.inv_hom_id_assoc]\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.leftHomologyœÄ_comp_leftHomologyIso_hom_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nh‚úù : S.LeftHomologyData\ninst‚úù : S.HasLeftHomology\nZ : C\nh : Quiver.Hom h‚úù.H Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp S.leftHomologyœÄ (CategoryTheory.CategoryStruct.comp h‚úù.leftHomologyIso.hom h)) (CategoryTheory.CategoryStruct.comp h‚úù.cyclesIso.hom (CategoryTheory.CategoryStruct.comp h‚úù.œÄ h))","decl":"@[reassoc (attr := simp)]\nlemma leftHomologyœÄ_comp_leftHomologyIso_hom :\n    S.leftHomologyœÄ ‚â´ h.leftHomologyIso.hom = h.cyclesIso.hom ‚â´ h.œÄ := by\n  dsimp only [leftHomologyœÄ, leftHomologyIso, cyclesIso, leftHomologyMapIso',\n    cyclesMapIso', Iso.refl]\n  rw [‚Üê leftHomologyœÄ_naturality']\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.leftHomologyœÄ_comp_leftHomologyIso_hom","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nh : S.LeftHomologyData\ninst‚úù : S.HasLeftHomology\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp S.leftHomologyœÄ h.leftHomologyIso.hom) (CategoryTheory.CategoryStruct.comp h.cyclesIso.hom h.œÄ)","decl":"@[reassoc (attr := simp)]\nlemma leftHomologyœÄ_comp_leftHomologyIso_hom :\n    S.leftHomologyœÄ ‚â´ h.leftHomologyIso.hom = h.cyclesIso.hom ‚â´ h.œÄ := by\n  dsimp only [leftHomologyœÄ, leftHomologyIso, cyclesIso, leftHomologyMapIso',\n    cyclesMapIso', Iso.refl]\n  rw [‚Üê leftHomologyœÄ_naturality']\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.œÄ_comp_leftHomologyIso_inv","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nh : S.LeftHomologyData\ninst‚úù : S.HasLeftHomology\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp h.œÄ h.leftHomologyIso.inv) (CategoryTheory.CategoryStruct.comp h.cyclesIso.inv S.leftHomologyœÄ)","decl":"@[reassoc (attr := simp)]\nlemma œÄ_comp_leftHomologyIso_inv :\n    h.œÄ ‚â´ h.leftHomologyIso.inv = h.cyclesIso.inv ‚â´ S.leftHomologyœÄ := by\n  simp only [‚Üê cancel_epi h.cyclesIso.hom, ‚Üê cancel_mono h.leftHomologyIso.hom, assoc,\n    Iso.inv_hom_id, comp_id, Iso.hom_inv_id_assoc,\n    LeftHomologyData.leftHomologyœÄ_comp_leftHomologyIso_hom]\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.œÄ_comp_leftHomologyIso_inv_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nh‚úù : S.LeftHomologyData\ninst‚úù : S.HasLeftHomology\nZ : C\nh : Quiver.Hom S.leftHomology Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp h‚úù.œÄ (CategoryTheory.CategoryStruct.comp h‚úù.leftHomologyIso.inv h)) (CategoryTheory.CategoryStruct.comp h‚úù.cyclesIso.inv (CategoryTheory.CategoryStruct.comp S.leftHomologyœÄ h))","decl":"@[reassoc (attr := simp)]\nlemma œÄ_comp_leftHomologyIso_inv :\n    h.œÄ ‚â´ h.leftHomologyIso.inv = h.cyclesIso.inv ‚â´ S.leftHomologyœÄ := by\n  simp only [‚Üê cancel_epi h.cyclesIso.hom, ‚Üê cancel_mono h.leftHomologyIso.hom, assoc,\n    Iso.inv_hom_id, comp_id, Iso.hom_inv_id_assoc,\n    LeftHomologyData.leftHomologyœÄ_comp_leftHomologyIso_hom]\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyMapData.leftHomologyMap_eq","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬≥ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroMorphisms C\nS‚ÇÅ S‚ÇÇ : CategoryTheory.ShortComplex C\nœÜ : Quiver.Hom S‚ÇÅ S‚ÇÇ\nh‚ÇÅ : S‚ÇÅ.LeftHomologyData\nh‚ÇÇ : S‚ÇÇ.LeftHomologyData\nŒ≥ : CategoryTheory.ShortComplex.LeftHomologyMapData œÜ h‚ÇÅ h‚ÇÇ\ninst‚úù¬π : S‚ÇÅ.HasLeftHomology\ninst‚úù : S‚ÇÇ.HasLeftHomology\n‚ä¢ Eq (CategoryTheory.ShortComplex.leftHomologyMap œÜ) (CategoryTheory.CategoryStruct.comp h‚ÇÅ.leftHomologyIso.hom (CategoryTheory.CategoryStruct.comp Œ≥.œÜH h‚ÇÇ.leftHomologyIso.inv))","decl":"lemma leftHomologyMap_eq [S‚ÇÅ.HasLeftHomology] [S‚ÇÇ.HasLeftHomology] :\n    leftHomologyMap œÜ = h‚ÇÅ.leftHomologyIso.hom ‚â´ Œ≥.œÜH ‚â´ h‚ÇÇ.leftHomologyIso.inv := by\n  dsimp [LeftHomologyData.leftHomologyIso, leftHomologyMapIso']\n  rw [‚Üê Œ≥.leftHomologyMap'_eq, ‚Üê leftHomologyMap'_comp,\n    ‚Üê leftHomologyMap'_comp, id_comp, comp_id]\n  rfl\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyMapData.cyclesMap_eq","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬≥ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroMorphisms C\nS‚ÇÅ S‚ÇÇ : CategoryTheory.ShortComplex C\nœÜ : Quiver.Hom S‚ÇÅ S‚ÇÇ\nh‚ÇÅ : S‚ÇÅ.LeftHomologyData\nh‚ÇÇ : S‚ÇÇ.LeftHomologyData\nŒ≥ : CategoryTheory.ShortComplex.LeftHomologyMapData œÜ h‚ÇÅ h‚ÇÇ\ninst‚úù¬π : S‚ÇÅ.HasLeftHomology\ninst‚úù : S‚ÇÇ.HasLeftHomology\n‚ä¢ Eq (CategoryTheory.ShortComplex.cyclesMap œÜ) (CategoryTheory.CategoryStruct.comp h‚ÇÅ.cyclesIso.hom (CategoryTheory.CategoryStruct.comp Œ≥.œÜK h‚ÇÇ.cyclesIso.inv))","decl":"lemma cyclesMap_eq [S‚ÇÅ.HasLeftHomology] [S‚ÇÇ.HasLeftHomology] :\n    cyclesMap œÜ = h‚ÇÅ.cyclesIso.hom ‚â´ Œ≥.œÜK ‚â´ h‚ÇÇ.cyclesIso.inv := by\n  dsimp [LeftHomologyData.cyclesIso, cyclesMapIso']\n  rw [‚Üê Œ≥.cyclesMap'_eq, ‚Üê cyclesMap'_comp, ‚Üê cyclesMap'_comp, id_comp, comp_id]\n  rfl\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyMapData.leftHomologyMap_comm","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬≥ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroMorphisms C\nS‚ÇÅ S‚ÇÇ : CategoryTheory.ShortComplex C\nœÜ : Quiver.Hom S‚ÇÅ S‚ÇÇ\nh‚ÇÅ : S‚ÇÅ.LeftHomologyData\nh‚ÇÇ : S‚ÇÇ.LeftHomologyData\nŒ≥ : CategoryTheory.ShortComplex.LeftHomologyMapData œÜ h‚ÇÅ h‚ÇÇ\ninst‚úù¬π : S‚ÇÅ.HasLeftHomology\ninst‚úù : S‚ÇÇ.HasLeftHomology\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.leftHomologyMap œÜ) h‚ÇÇ.leftHomologyIso.hom) (CategoryTheory.CategoryStruct.comp h‚ÇÅ.leftHomologyIso.hom Œ≥.œÜH)","decl":"lemma leftHomologyMap_comm [S‚ÇÅ.HasLeftHomology] [S‚ÇÇ.HasLeftHomology] :\n    leftHomologyMap œÜ ‚â´ h‚ÇÇ.leftHomologyIso.hom = h‚ÇÅ.leftHomologyIso.hom ‚â´ Œ≥.œÜH := by\n  simp only [Œ≥.leftHomologyMap_eq, assoc, Iso.inv_hom_id, comp_id]\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyMapData.cyclesMap_comm","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬≥ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroMorphisms C\nS‚ÇÅ S‚ÇÇ : CategoryTheory.ShortComplex C\nœÜ : Quiver.Hom S‚ÇÅ S‚ÇÇ\nh‚ÇÅ : S‚ÇÅ.LeftHomologyData\nh‚ÇÇ : S‚ÇÇ.LeftHomologyData\nŒ≥ : CategoryTheory.ShortComplex.LeftHomologyMapData œÜ h‚ÇÅ h‚ÇÇ\ninst‚úù¬π : S‚ÇÅ.HasLeftHomology\ninst‚úù : S‚ÇÇ.HasLeftHomology\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.cyclesMap œÜ) h‚ÇÇ.cyclesIso.hom) (CategoryTheory.CategoryStruct.comp h‚ÇÅ.cyclesIso.hom Œ≥.œÜK)","decl":"lemma cyclesMap_comm [S‚ÇÅ.HasLeftHomology] [S‚ÇÇ.HasLeftHomology] :\n    cyclesMap œÜ ‚â´ h‚ÇÇ.cyclesIso.hom = h‚ÇÅ.cyclesIso.hom ‚â´ Œ≥.œÜK := by\n  simp only [Œ≥.cyclesMap_eq, assoc, Iso.inv_hom_id, comp_id]\n\n"}
{"name":"CategoryTheory.ShortComplex.leftHomologyFunctor_obj","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬≥ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroMorphisms C\ninst‚úù¬π : CategoryTheory.Limits.HasKernels C\ninst‚úù : CategoryTheory.Limits.HasCokernels C\nS : CategoryTheory.ShortComplex C\n‚ä¢ Eq ((CategoryTheory.ShortComplex.leftHomologyFunctor C).obj S) S.leftHomology","decl":"/-- The left homology functor `ShortComplex C ‚•§ C`, where the left homology of a\nshort complex `S` is understood as a cokernel of the obvious map `S.toCycles : S.X‚ÇÅ ‚ü∂ S.cycles`\nwhere `S.cycles` is a kernel of `S.g : S.X‚ÇÇ ‚ü∂ S.X‚ÇÉ`. -/\n@[simps]\nnoncomputable def leftHomologyFunctor : ShortComplex C ‚•§ C where\n  obj S := S.leftHomology\n  map := leftHomologyMap\n\n"}
{"name":"CategoryTheory.ShortComplex.leftHomologyFunctor_map","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬≥ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroMorphisms C\ninst‚úù¬π : CategoryTheory.Limits.HasKernels C\ninst‚úù : CategoryTheory.Limits.HasCokernels C\nX‚úù Y‚úù : CategoryTheory.ShortComplex C\nœÜ : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.ShortComplex.leftHomologyFunctor C).map œÜ) (CategoryTheory.ShortComplex.leftHomologyMap œÜ)","decl":"/-- The left homology functor `ShortComplex C ‚•§ C`, where the left homology of a\nshort complex `S` is understood as a cokernel of the obvious map `S.toCycles : S.X‚ÇÅ ‚ü∂ S.cycles`\nwhere `S.cycles` is a kernel of `S.g : S.X‚ÇÇ ‚ü∂ S.X‚ÇÉ`. -/\n@[simps]\nnoncomputable def leftHomologyFunctor : ShortComplex C ‚•§ C where\n  obj S := S.leftHomology\n  map := leftHomologyMap\n\n"}
{"name":"CategoryTheory.ShortComplex.cyclesFunctor_obj","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬≥ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroMorphisms C\ninst‚úù¬π : CategoryTheory.Limits.HasKernels C\ninst‚úù : CategoryTheory.Limits.HasCokernels C\nS : CategoryTheory.ShortComplex C\n‚ä¢ Eq ((CategoryTheory.ShortComplex.cyclesFunctor C).obj S) S.cycles","decl":"/-- The cycles functor `ShortComplex C ‚•§ C` which sends a short complex `S` to `S.cycles`\nwhich is a kernel of `S.g : S.X‚ÇÇ ‚ü∂ S.X‚ÇÉ`. -/\n@[simps]\nnoncomputable def cyclesFunctor : ShortComplex C ‚•§ C where\n  obj S := S.cycles\n  map := cyclesMap\n\n"}
{"name":"CategoryTheory.ShortComplex.cyclesFunctor_map","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬≥ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroMorphisms C\ninst‚úù¬π : CategoryTheory.Limits.HasKernels C\ninst‚úù : CategoryTheory.Limits.HasCokernels C\nX‚úù Y‚úù : CategoryTheory.ShortComplex C\nœÜ : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.ShortComplex.cyclesFunctor C).map œÜ) (CategoryTheory.ShortComplex.cyclesMap œÜ)","decl":"/-- The cycles functor `ShortComplex C ‚•§ C` which sends a short complex `S` to `S.cycles`\nwhich is a kernel of `S.g : S.X‚ÇÇ ‚ü∂ S.X‚ÇÉ`. -/\n@[simps]\nnoncomputable def cyclesFunctor : ShortComplex C ‚•§ C where\n  obj S := S.cycles\n  map := cyclesMap\n\n"}
{"name":"CategoryTheory.ShortComplex.leftHomologyœÄNatTrans_app","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬≥ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroMorphisms C\ninst‚úù¬π : CategoryTheory.Limits.HasKernels C\ninst‚úù : CategoryTheory.Limits.HasCokernels C\nS : CategoryTheory.ShortComplex C\n‚ä¢ Eq ((CategoryTheory.ShortComplex.leftHomologyœÄNatTrans C).app S) S.leftHomologyœÄ","decl":"/-- The natural transformation `S.cycles ‚ü∂ S.leftHomology` for all short complexes `S`. -/\n@[simps]\nnoncomputable def leftHomologyœÄNatTrans : cyclesFunctor C ‚ü∂ leftHomologyFunctor C where\n  app S := leftHomologyœÄ S\n  naturality := fun _ _ œÜ => (leftHomologyœÄ_naturality œÜ).symm\n\n"}
{"name":"CategoryTheory.ShortComplex.iCyclesNatTrans_app","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬≥ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroMorphisms C\ninst‚úù¬π : CategoryTheory.Limits.HasKernels C\ninst‚úù : CategoryTheory.Limits.HasCokernels C\nS : CategoryTheory.ShortComplex C\n‚ä¢ Eq ((CategoryTheory.ShortComplex.iCyclesNatTrans C).app S) S.iCycles","decl":"/-- The natural transformation `S.cycles ‚ü∂ S.X‚ÇÇ` for all short complexes `S`. -/\n@[simps]\nnoncomputable def iCyclesNatTrans : cyclesFunctor C ‚ü∂ ShortComplex.œÄ‚ÇÇ where\n  app S := S.iCycles\n\n"}
{"name":"CategoryTheory.ShortComplex.toCyclesNatTrans_app","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬≥ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroMorphisms C\ninst‚úù¬π : CategoryTheory.Limits.HasKernels C\ninst‚úù : CategoryTheory.Limits.HasCokernels C\nS : CategoryTheory.ShortComplex C\n‚ä¢ Eq ((CategoryTheory.ShortComplex.toCyclesNatTrans C).app S) S.toCycles","decl":"/-- The natural transformation `S.X‚ÇÅ ‚ü∂ S.cycles` for all short complexes `S`. -/\n@[simps]\nnoncomputable def toCyclesNatTrans :\n    œÄ‚ÇÅ ‚ü∂ cyclesFunctor C where\n  app S := S.toCycles\n  naturality := fun _ _ œÜ => (toCycles_naturality œÜ).symm\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.ofEpiOfIsIsoOfMono_K","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù¬≥ : CategoryTheory.Limits.HasZeroMorphisms C\nS‚ÇÅ S‚ÇÇ : CategoryTheory.ShortComplex C\nœÜ : Quiver.Hom S‚ÇÅ S‚ÇÇ\nh : S‚ÇÅ.LeftHomologyData\ninst‚úù¬≤ : CategoryTheory.Epi œÜ.œÑ‚ÇÅ\ninst‚úù¬π : CategoryTheory.IsIso œÜ.œÑ‚ÇÇ\ninst‚úù : CategoryTheory.Mono œÜ.œÑ‚ÇÉ\n‚ä¢ Eq (CategoryTheory.ShortComplex.LeftHomologyData.ofEpiOfIsIsoOfMono œÜ h).K h.K","decl":"/-- If `œÜ : S‚ÇÅ ‚ü∂ S‚ÇÇ` is a morphism of short complexes such that `œÜ.œÑ‚ÇÅ` is epi, `œÜ.œÑ‚ÇÇ` is an iso\nand `œÜ.œÑ‚ÇÉ` is mono, then a left homology data for `S‚ÇÅ` induces a left homology data for `S‚ÇÇ` with\nthe same `K` and `H` fields. The inverse construction is `ofEpiOfIsIsoOfMono'`. -/\n@[simps]\nnoncomputable def ofEpiOfIsIsoOfMono (œÜ : S‚ÇÅ ‚ü∂ S‚ÇÇ) (h : LeftHomologyData S‚ÇÅ)\n    [Epi œÜ.œÑ‚ÇÅ] [IsIso œÜ.œÑ‚ÇÇ] [Mono œÜ.œÑ‚ÇÉ] : LeftHomologyData S‚ÇÇ := by\n  let i : h.K ‚ü∂ S‚ÇÇ.X‚ÇÇ := h.i ‚â´ œÜ.œÑ‚ÇÇ\n  have wi : i ‚â´ S‚ÇÇ.g = 0 := by simp only [i, assoc, œÜ.comm‚ÇÇ‚ÇÉ, h.wi_assoc, zero_comp]\n  have hi : IsLimit (KernelFork.ofŒπ i wi) := KernelFork.IsLimit.ofŒπ _ _\n    (fun x hx => h.liftK (x ‚â´ inv œÜ.œÑ‚ÇÇ) (by rw [assoc, ‚Üê cancel_mono œÜ.œÑ‚ÇÉ, assoc,\n      assoc, ‚Üê œÜ.comm‚ÇÇ‚ÇÉ, IsIso.inv_hom_id_assoc, hx, zero_comp]))\n    (fun x hx => by simp [i]) (fun x hx b hb => by\n      dsimp\n      rw [‚Üê cancel_mono h.i, ‚Üê cancel_mono œÜ.œÑ‚ÇÇ, assoc, assoc, liftK_i_assoc,\n        assoc, IsIso.inv_hom_id, comp_id, hb])\n  let f' := hi.lift (KernelFork.ofŒπ S‚ÇÇ.f S‚ÇÇ.zero)\n  have hf' : œÜ.œÑ‚ÇÅ ‚â´ f' = h.f' := by\n    have eq := @Fork.IsLimit.lift_Œπ _ _ _ _ _ _ _ ((KernelFork.ofŒπ S‚ÇÇ.f S‚ÇÇ.zero)) hi\n    simp only [Fork.Œπ_ofŒπ] at eq\n    rw [‚Üê cancel_mono h.i, ‚Üê cancel_mono œÜ.œÑ‚ÇÇ, assoc, assoc, eq, f'_i, œÜ.comm‚ÇÅ‚ÇÇ]\n  have wœÄ : f' ‚â´ h.œÄ = 0 := by\n    rw [‚Üê cancel_epi œÜ.œÑ‚ÇÅ, comp_zero, reassoc_of% hf', h.f'_œÄ]\n  have hœÄ : IsColimit (CokernelCofork.ofœÄ h.œÄ wœÄ) := CokernelCofork.IsColimit.ofœÄ _ _\n    (fun x hx => h.descH x (by rw [‚Üê hf', assoc, hx, comp_zero]))\n    (fun x hx => by simp) (fun x hx b hb => by rw [‚Üê cancel_epi h.œÄ, œÄ_descH, hb])\n  exact ‚ü®h.K, h.H, i, h.œÄ, wi, hi, wœÄ, hœÄ‚ü©\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.ofEpiOfIsIsoOfMono_H","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù¬≥ : CategoryTheory.Limits.HasZeroMorphisms C\nS‚ÇÅ S‚ÇÇ : CategoryTheory.ShortComplex C\nœÜ : Quiver.Hom S‚ÇÅ S‚ÇÇ\nh : S‚ÇÅ.LeftHomologyData\ninst‚úù¬≤ : CategoryTheory.Epi œÜ.œÑ‚ÇÅ\ninst‚úù¬π : CategoryTheory.IsIso œÜ.œÑ‚ÇÇ\ninst‚úù : CategoryTheory.Mono œÜ.œÑ‚ÇÉ\n‚ä¢ Eq (CategoryTheory.ShortComplex.LeftHomologyData.ofEpiOfIsIsoOfMono œÜ h).H h.H","decl":"/-- If `œÜ : S‚ÇÅ ‚ü∂ S‚ÇÇ` is a morphism of short complexes such that `œÜ.œÑ‚ÇÅ` is epi, `œÜ.œÑ‚ÇÇ` is an iso\nand `œÜ.œÑ‚ÇÉ` is mono, then a left homology data for `S‚ÇÅ` induces a left homology data for `S‚ÇÇ` with\nthe same `K` and `H` fields. The inverse construction is `ofEpiOfIsIsoOfMono'`. -/\n@[simps]\nnoncomputable def ofEpiOfIsIsoOfMono (œÜ : S‚ÇÅ ‚ü∂ S‚ÇÇ) (h : LeftHomologyData S‚ÇÅ)\n    [Epi œÜ.œÑ‚ÇÅ] [IsIso œÜ.œÑ‚ÇÇ] [Mono œÜ.œÑ‚ÇÉ] : LeftHomologyData S‚ÇÇ := by\n  let i : h.K ‚ü∂ S‚ÇÇ.X‚ÇÇ := h.i ‚â´ œÜ.œÑ‚ÇÇ\n  have wi : i ‚â´ S‚ÇÇ.g = 0 := by simp only [i, assoc, œÜ.comm‚ÇÇ‚ÇÉ, h.wi_assoc, zero_comp]\n  have hi : IsLimit (KernelFork.ofŒπ i wi) := KernelFork.IsLimit.ofŒπ _ _\n    (fun x hx => h.liftK (x ‚â´ inv œÜ.œÑ‚ÇÇ) (by rw [assoc, ‚Üê cancel_mono œÜ.œÑ‚ÇÉ, assoc,\n      assoc, ‚Üê œÜ.comm‚ÇÇ‚ÇÉ, IsIso.inv_hom_id_assoc, hx, zero_comp]))\n    (fun x hx => by simp [i]) (fun x hx b hb => by\n      dsimp\n      rw [‚Üê cancel_mono h.i, ‚Üê cancel_mono œÜ.œÑ‚ÇÇ, assoc, assoc, liftK_i_assoc,\n        assoc, IsIso.inv_hom_id, comp_id, hb])\n  let f' := hi.lift (KernelFork.ofŒπ S‚ÇÇ.f S‚ÇÇ.zero)\n  have hf' : œÜ.œÑ‚ÇÅ ‚â´ f' = h.f' := by\n    have eq := @Fork.IsLimit.lift_Œπ _ _ _ _ _ _ _ ((KernelFork.ofŒπ S‚ÇÇ.f S‚ÇÇ.zero)) hi\n    simp only [Fork.Œπ_ofŒπ] at eq\n    rw [‚Üê cancel_mono h.i, ‚Üê cancel_mono œÜ.œÑ‚ÇÇ, assoc, assoc, eq, f'_i, œÜ.comm‚ÇÅ‚ÇÇ]\n  have wœÄ : f' ‚â´ h.œÄ = 0 := by\n    rw [‚Üê cancel_epi œÜ.œÑ‚ÇÅ, comp_zero, reassoc_of% hf', h.f'_œÄ]\n  have hœÄ : IsColimit (CokernelCofork.ofœÄ h.œÄ wœÄ) := CokernelCofork.IsColimit.ofœÄ _ _\n    (fun x hx => h.descH x (by rw [‚Üê hf', assoc, hx, comp_zero]))\n    (fun x hx => by simp) (fun x hx b hb => by rw [‚Üê cancel_epi h.œÄ, œÄ_descH, hb])\n  exact ‚ü®h.K, h.H, i, h.œÄ, wi, hi, wœÄ, hœÄ‚ü©\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.ofEpiOfIsIsoOfMono_i","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù¬≥ : CategoryTheory.Limits.HasZeroMorphisms C\nS‚ÇÅ S‚ÇÇ : CategoryTheory.ShortComplex C\nœÜ : Quiver.Hom S‚ÇÅ S‚ÇÇ\nh : S‚ÇÅ.LeftHomologyData\ninst‚úù¬≤ : CategoryTheory.Epi œÜ.œÑ‚ÇÅ\ninst‚úù¬π : CategoryTheory.IsIso œÜ.œÑ‚ÇÇ\ninst‚úù : CategoryTheory.Mono œÜ.œÑ‚ÇÉ\n‚ä¢ Eq (CategoryTheory.ShortComplex.LeftHomologyData.ofEpiOfIsIsoOfMono œÜ h).i (CategoryTheory.CategoryStruct.comp h.i œÜ.œÑ‚ÇÇ)","decl":"/-- If `œÜ : S‚ÇÅ ‚ü∂ S‚ÇÇ` is a morphism of short complexes such that `œÜ.œÑ‚ÇÅ` is epi, `œÜ.œÑ‚ÇÇ` is an iso\nand `œÜ.œÑ‚ÇÉ` is mono, then a left homology data for `S‚ÇÅ` induces a left homology data for `S‚ÇÇ` with\nthe same `K` and `H` fields. The inverse construction is `ofEpiOfIsIsoOfMono'`. -/\n@[simps]\nnoncomputable def ofEpiOfIsIsoOfMono (œÜ : S‚ÇÅ ‚ü∂ S‚ÇÇ) (h : LeftHomologyData S‚ÇÅ)\n    [Epi œÜ.œÑ‚ÇÅ] [IsIso œÜ.œÑ‚ÇÇ] [Mono œÜ.œÑ‚ÇÉ] : LeftHomologyData S‚ÇÇ := by\n  let i : h.K ‚ü∂ S‚ÇÇ.X‚ÇÇ := h.i ‚â´ œÜ.œÑ‚ÇÇ\n  have wi : i ‚â´ S‚ÇÇ.g = 0 := by simp only [i, assoc, œÜ.comm‚ÇÇ‚ÇÉ, h.wi_assoc, zero_comp]\n  have hi : IsLimit (KernelFork.ofŒπ i wi) := KernelFork.IsLimit.ofŒπ _ _\n    (fun x hx => h.liftK (x ‚â´ inv œÜ.œÑ‚ÇÇ) (by rw [assoc, ‚Üê cancel_mono œÜ.œÑ‚ÇÉ, assoc,\n      assoc, ‚Üê œÜ.comm‚ÇÇ‚ÇÉ, IsIso.inv_hom_id_assoc, hx, zero_comp]))\n    (fun x hx => by simp [i]) (fun x hx b hb => by\n      dsimp\n      rw [‚Üê cancel_mono h.i, ‚Üê cancel_mono œÜ.œÑ‚ÇÇ, assoc, assoc, liftK_i_assoc,\n        assoc, IsIso.inv_hom_id, comp_id, hb])\n  let f' := hi.lift (KernelFork.ofŒπ S‚ÇÇ.f S‚ÇÇ.zero)\n  have hf' : œÜ.œÑ‚ÇÅ ‚â´ f' = h.f' := by\n    have eq := @Fork.IsLimit.lift_Œπ _ _ _ _ _ _ _ ((KernelFork.ofŒπ S‚ÇÇ.f S‚ÇÇ.zero)) hi\n    simp only [Fork.Œπ_ofŒπ] at eq\n    rw [‚Üê cancel_mono h.i, ‚Üê cancel_mono œÜ.œÑ‚ÇÇ, assoc, assoc, eq, f'_i, œÜ.comm‚ÇÅ‚ÇÇ]\n  have wœÄ : f' ‚â´ h.œÄ = 0 := by\n    rw [‚Üê cancel_epi œÜ.œÑ‚ÇÅ, comp_zero, reassoc_of% hf', h.f'_œÄ]\n  have hœÄ : IsColimit (CokernelCofork.ofœÄ h.œÄ wœÄ) := CokernelCofork.IsColimit.ofœÄ _ _\n    (fun x hx => h.descH x (by rw [‚Üê hf', assoc, hx, comp_zero]))\n    (fun x hx => by simp) (fun x hx b hb => by rw [‚Üê cancel_epi h.œÄ, œÄ_descH, hb])\n  exact ‚ü®h.K, h.H, i, h.œÄ, wi, hi, wœÄ, hœÄ‚ü©\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.ofEpiOfIsIsoOfMono_œÄ","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù¬≥ : CategoryTheory.Limits.HasZeroMorphisms C\nS‚ÇÅ S‚ÇÇ : CategoryTheory.ShortComplex C\nœÜ : Quiver.Hom S‚ÇÅ S‚ÇÇ\nh : S‚ÇÅ.LeftHomologyData\ninst‚úù¬≤ : CategoryTheory.Epi œÜ.œÑ‚ÇÅ\ninst‚úù¬π : CategoryTheory.IsIso œÜ.œÑ‚ÇÇ\ninst‚úù : CategoryTheory.Mono œÜ.œÑ‚ÇÉ\n‚ä¢ Eq (CategoryTheory.ShortComplex.LeftHomologyData.ofEpiOfIsIsoOfMono œÜ h).œÄ h.œÄ","decl":"/-- If `œÜ : S‚ÇÅ ‚ü∂ S‚ÇÇ` is a morphism of short complexes such that `œÜ.œÑ‚ÇÅ` is epi, `œÜ.œÑ‚ÇÇ` is an iso\nand `œÜ.œÑ‚ÇÉ` is mono, then a left homology data for `S‚ÇÅ` induces a left homology data for `S‚ÇÇ` with\nthe same `K` and `H` fields. The inverse construction is `ofEpiOfIsIsoOfMono'`. -/\n@[simps]\nnoncomputable def ofEpiOfIsIsoOfMono (œÜ : S‚ÇÅ ‚ü∂ S‚ÇÇ) (h : LeftHomologyData S‚ÇÅ)\n    [Epi œÜ.œÑ‚ÇÅ] [IsIso œÜ.œÑ‚ÇÇ] [Mono œÜ.œÑ‚ÇÉ] : LeftHomologyData S‚ÇÇ := by\n  let i : h.K ‚ü∂ S‚ÇÇ.X‚ÇÇ := h.i ‚â´ œÜ.œÑ‚ÇÇ\n  have wi : i ‚â´ S‚ÇÇ.g = 0 := by simp only [i, assoc, œÜ.comm‚ÇÇ‚ÇÉ, h.wi_assoc, zero_comp]\n  have hi : IsLimit (KernelFork.ofŒπ i wi) := KernelFork.IsLimit.ofŒπ _ _\n    (fun x hx => h.liftK (x ‚â´ inv œÜ.œÑ‚ÇÇ) (by rw [assoc, ‚Üê cancel_mono œÜ.œÑ‚ÇÉ, assoc,\n      assoc, ‚Üê œÜ.comm‚ÇÇ‚ÇÉ, IsIso.inv_hom_id_assoc, hx, zero_comp]))\n    (fun x hx => by simp [i]) (fun x hx b hb => by\n      dsimp\n      rw [‚Üê cancel_mono h.i, ‚Üê cancel_mono œÜ.œÑ‚ÇÇ, assoc, assoc, liftK_i_assoc,\n        assoc, IsIso.inv_hom_id, comp_id, hb])\n  let f' := hi.lift (KernelFork.ofŒπ S‚ÇÇ.f S‚ÇÇ.zero)\n  have hf' : œÜ.œÑ‚ÇÅ ‚â´ f' = h.f' := by\n    have eq := @Fork.IsLimit.lift_Œπ _ _ _ _ _ _ _ ((KernelFork.ofŒπ S‚ÇÇ.f S‚ÇÇ.zero)) hi\n    simp only [Fork.Œπ_ofŒπ] at eq\n    rw [‚Üê cancel_mono h.i, ‚Üê cancel_mono œÜ.œÑ‚ÇÇ, assoc, assoc, eq, f'_i, œÜ.comm‚ÇÅ‚ÇÇ]\n  have wœÄ : f' ‚â´ h.œÄ = 0 := by\n    rw [‚Üê cancel_epi œÜ.œÑ‚ÇÅ, comp_zero, reassoc_of% hf', h.f'_œÄ]\n  have hœÄ : IsColimit (CokernelCofork.ofœÄ h.œÄ wœÄ) := CokernelCofork.IsColimit.ofœÄ _ _\n    (fun x hx => h.descH x (by rw [‚Üê hf', assoc, hx, comp_zero]))\n    (fun x hx => by simp) (fun x hx b hb => by rw [‚Üê cancel_epi h.œÄ, œÄ_descH, hb])\n  exact ‚ü®h.K, h.H, i, h.œÄ, wi, hi, wœÄ, hœÄ‚ü©\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.œÑ‚ÇÅ_ofEpiOfIsIsoOfMono_f'","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù¬≥ : CategoryTheory.Limits.HasZeroMorphisms C\nS‚ÇÅ S‚ÇÇ : CategoryTheory.ShortComplex C\nœÜ : Quiver.Hom S‚ÇÅ S‚ÇÇ\nh : S‚ÇÅ.LeftHomologyData\ninst‚úù¬≤ : CategoryTheory.Epi œÜ.œÑ‚ÇÅ\ninst‚úù¬π : CategoryTheory.IsIso œÜ.œÑ‚ÇÇ\ninst‚úù : CategoryTheory.Mono œÜ.œÑ‚ÇÉ\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp œÜ.œÑ‚ÇÅ (CategoryTheory.ShortComplex.LeftHomologyData.ofEpiOfIsIsoOfMono œÜ h).f') h.f'","decl":"@[simp]\nlemma œÑ‚ÇÅ_ofEpiOfIsIsoOfMono_f' (œÜ : S‚ÇÅ ‚ü∂ S‚ÇÇ) (h : LeftHomologyData S‚ÇÅ)\n    [Epi œÜ.œÑ‚ÇÅ] [IsIso œÜ.œÑ‚ÇÇ] [Mono œÜ.œÑ‚ÇÉ] : œÜ.œÑ‚ÇÅ ‚â´ (ofEpiOfIsIsoOfMono œÜ h).f' = h.f' := by\n  rw [‚Üê cancel_mono (ofEpiOfIsIsoOfMono œÜ h).i, assoc, f'_i,\n    ofEpiOfIsIsoOfMono_i, f'_i_assoc, œÜ.comm‚ÇÅ‚ÇÇ]\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.ofEpiOfIsIsoOfMono'_œÄ","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù¬≥ : CategoryTheory.Limits.HasZeroMorphisms C\nS‚ÇÅ S‚ÇÇ : CategoryTheory.ShortComplex C\nœÜ : Quiver.Hom S‚ÇÅ S‚ÇÇ\nh : S‚ÇÇ.LeftHomologyData\ninst‚úù¬≤ : CategoryTheory.Epi œÜ.œÑ‚ÇÅ\ninst‚úù¬π : CategoryTheory.IsIso œÜ.œÑ‚ÇÇ\ninst‚úù : CategoryTheory.Mono œÜ.œÑ‚ÇÉ\n‚ä¢ Eq (CategoryTheory.ShortComplex.LeftHomologyData.ofEpiOfIsIsoOfMono' œÜ h).œÄ h.œÄ","decl":"/-- If `œÜ : S‚ÇÅ ‚ü∂ S‚ÇÇ` is a morphism of short complexes such that `œÜ.œÑ‚ÇÅ` is epi, `œÜ.œÑ‚ÇÇ` is an iso\nand `œÜ.œÑ‚ÇÉ` is mono, then a left homology data for `S‚ÇÇ` induces a left homology data for `S‚ÇÅ` with\nthe same `K` and `H` fields. The inverse construction is `ofEpiOfIsIsoOfMono`. -/\n@[simps]\nnoncomputable def ofEpiOfIsIsoOfMono' (œÜ : S‚ÇÅ ‚ü∂ S‚ÇÇ) (h : LeftHomologyData S‚ÇÇ)\n    [Epi œÜ.œÑ‚ÇÅ] [IsIso œÜ.œÑ‚ÇÇ] [Mono œÜ.œÑ‚ÇÉ] : LeftHomologyData S‚ÇÅ := by\n  let i : h.K ‚ü∂ S‚ÇÅ.X‚ÇÇ := h.i ‚â´ inv œÜ.œÑ‚ÇÇ\n  have wi : i ‚â´ S‚ÇÅ.g = 0 := by\n    rw [assoc, ‚Üê cancel_mono œÜ.œÑ‚ÇÉ, zero_comp, assoc, assoc, ‚Üê œÜ.comm‚ÇÇ‚ÇÉ,\n      IsIso.inv_hom_id_assoc, h.wi]\n  have hi : IsLimit (KernelFork.ofŒπ i wi) := KernelFork.IsLimit.ofŒπ _ _\n    (fun x hx => h.liftK (x ‚â´ œÜ.œÑ‚ÇÇ)\n      (by rw [assoc, œÜ.comm‚ÇÇ‚ÇÉ, reassoc_of% hx, zero_comp]))\n    (fun x hx => by simp [i])\n    (fun x hx b hb => by rw [‚Üê cancel_mono h.i, ‚Üê cancel_mono (inv œÜ.œÑ‚ÇÇ), assoc, assoc,\n      hb, liftK_i_assoc, assoc, IsIso.hom_inv_id, comp_id])\n  let f' := hi.lift (KernelFork.ofŒπ S‚ÇÅ.f S‚ÇÅ.zero)\n  have hf' : f' ‚â´ i = S‚ÇÅ.f := Fork.IsLimit.lift_Œπ _\n  have hf'' : f' = œÜ.œÑ‚ÇÅ ‚â´ h.f' := by\n    rw [‚Üê cancel_mono h.i, ‚Üê cancel_mono (inv œÜ.œÑ‚ÇÇ), assoc, assoc, assoc, hf', f'_i_assoc,\n      œÜ.comm‚ÇÅ‚ÇÇ_assoc, IsIso.hom_inv_id, comp_id]\n  have wœÄ : f' ‚â´ h.œÄ = 0 := by simp only [hf'', assoc, f'_œÄ, comp_zero]\n  have hœÄ : IsColimit (CokernelCofork.ofœÄ h.œÄ wœÄ) := CokernelCofork.IsColimit.ofœÄ _ _\n    (fun x hx => h.descH x (by rw [‚Üê cancel_epi œÜ.œÑ‚ÇÅ, ‚Üê reassoc_of% hf'', hx, comp_zero]))\n    (fun x hx => œÄ_descH _ _ _)\n    (fun x hx b hx => by rw [‚Üê cancel_epi h.œÄ, œÄ_descH, hx])\n  exact ‚ü®h.K, h.H, i, h.œÄ, wi, hi, wœÄ, hœÄ‚ü©\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.ofEpiOfIsIsoOfMono'_K","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù¬≥ : CategoryTheory.Limits.HasZeroMorphisms C\nS‚ÇÅ S‚ÇÇ : CategoryTheory.ShortComplex C\nœÜ : Quiver.Hom S‚ÇÅ S‚ÇÇ\nh : S‚ÇÇ.LeftHomologyData\ninst‚úù¬≤ : CategoryTheory.Epi œÜ.œÑ‚ÇÅ\ninst‚úù¬π : CategoryTheory.IsIso œÜ.œÑ‚ÇÇ\ninst‚úù : CategoryTheory.Mono œÜ.œÑ‚ÇÉ\n‚ä¢ Eq (CategoryTheory.ShortComplex.LeftHomologyData.ofEpiOfIsIsoOfMono' œÜ h).K h.K","decl":"/-- If `œÜ : S‚ÇÅ ‚ü∂ S‚ÇÇ` is a morphism of short complexes such that `œÜ.œÑ‚ÇÅ` is epi, `œÜ.œÑ‚ÇÇ` is an iso\nand `œÜ.œÑ‚ÇÉ` is mono, then a left homology data for `S‚ÇÇ` induces a left homology data for `S‚ÇÅ` with\nthe same `K` and `H` fields. The inverse construction is `ofEpiOfIsIsoOfMono`. -/\n@[simps]\nnoncomputable def ofEpiOfIsIsoOfMono' (œÜ : S‚ÇÅ ‚ü∂ S‚ÇÇ) (h : LeftHomologyData S‚ÇÇ)\n    [Epi œÜ.œÑ‚ÇÅ] [IsIso œÜ.œÑ‚ÇÇ] [Mono œÜ.œÑ‚ÇÉ] : LeftHomologyData S‚ÇÅ := by\n  let i : h.K ‚ü∂ S‚ÇÅ.X‚ÇÇ := h.i ‚â´ inv œÜ.œÑ‚ÇÇ\n  have wi : i ‚â´ S‚ÇÅ.g = 0 := by\n    rw [assoc, ‚Üê cancel_mono œÜ.œÑ‚ÇÉ, zero_comp, assoc, assoc, ‚Üê œÜ.comm‚ÇÇ‚ÇÉ,\n      IsIso.inv_hom_id_assoc, h.wi]\n  have hi : IsLimit (KernelFork.ofŒπ i wi) := KernelFork.IsLimit.ofŒπ _ _\n    (fun x hx => h.liftK (x ‚â´ œÜ.œÑ‚ÇÇ)\n      (by rw [assoc, œÜ.comm‚ÇÇ‚ÇÉ, reassoc_of% hx, zero_comp]))\n    (fun x hx => by simp [i])\n    (fun x hx b hb => by rw [‚Üê cancel_mono h.i, ‚Üê cancel_mono (inv œÜ.œÑ‚ÇÇ), assoc, assoc,\n      hb, liftK_i_assoc, assoc, IsIso.hom_inv_id, comp_id])\n  let f' := hi.lift (KernelFork.ofŒπ S‚ÇÅ.f S‚ÇÅ.zero)\n  have hf' : f' ‚â´ i = S‚ÇÅ.f := Fork.IsLimit.lift_Œπ _\n  have hf'' : f' = œÜ.œÑ‚ÇÅ ‚â´ h.f' := by\n    rw [‚Üê cancel_mono h.i, ‚Üê cancel_mono (inv œÜ.œÑ‚ÇÇ), assoc, assoc, assoc, hf', f'_i_assoc,\n      œÜ.comm‚ÇÅ‚ÇÇ_assoc, IsIso.hom_inv_id, comp_id]\n  have wœÄ : f' ‚â´ h.œÄ = 0 := by simp only [hf'', assoc, f'_œÄ, comp_zero]\n  have hœÄ : IsColimit (CokernelCofork.ofœÄ h.œÄ wœÄ) := CokernelCofork.IsColimit.ofœÄ _ _\n    (fun x hx => h.descH x (by rw [‚Üê cancel_epi œÜ.œÑ‚ÇÅ, ‚Üê reassoc_of% hf'', hx, comp_zero]))\n    (fun x hx => œÄ_descH _ _ _)\n    (fun x hx b hx => by rw [‚Üê cancel_epi h.œÄ, œÄ_descH, hx])\n  exact ‚ü®h.K, h.H, i, h.œÄ, wi, hi, wœÄ, hœÄ‚ü©\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.ofEpiOfIsIsoOfMono'_H","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù¬≥ : CategoryTheory.Limits.HasZeroMorphisms C\nS‚ÇÅ S‚ÇÇ : CategoryTheory.ShortComplex C\nœÜ : Quiver.Hom S‚ÇÅ S‚ÇÇ\nh : S‚ÇÇ.LeftHomologyData\ninst‚úù¬≤ : CategoryTheory.Epi œÜ.œÑ‚ÇÅ\ninst‚úù¬π : CategoryTheory.IsIso œÜ.œÑ‚ÇÇ\ninst‚úù : CategoryTheory.Mono œÜ.œÑ‚ÇÉ\n‚ä¢ Eq (CategoryTheory.ShortComplex.LeftHomologyData.ofEpiOfIsIsoOfMono' œÜ h).H h.H","decl":"/-- If `œÜ : S‚ÇÅ ‚ü∂ S‚ÇÇ` is a morphism of short complexes such that `œÜ.œÑ‚ÇÅ` is epi, `œÜ.œÑ‚ÇÇ` is an iso\nand `œÜ.œÑ‚ÇÉ` is mono, then a left homology data for `S‚ÇÇ` induces a left homology data for `S‚ÇÅ` with\nthe same `K` and `H` fields. The inverse construction is `ofEpiOfIsIsoOfMono`. -/\n@[simps]\nnoncomputable def ofEpiOfIsIsoOfMono' (œÜ : S‚ÇÅ ‚ü∂ S‚ÇÇ) (h : LeftHomologyData S‚ÇÇ)\n    [Epi œÜ.œÑ‚ÇÅ] [IsIso œÜ.œÑ‚ÇÇ] [Mono œÜ.œÑ‚ÇÉ] : LeftHomologyData S‚ÇÅ := by\n  let i : h.K ‚ü∂ S‚ÇÅ.X‚ÇÇ := h.i ‚â´ inv œÜ.œÑ‚ÇÇ\n  have wi : i ‚â´ S‚ÇÅ.g = 0 := by\n    rw [assoc, ‚Üê cancel_mono œÜ.œÑ‚ÇÉ, zero_comp, assoc, assoc, ‚Üê œÜ.comm‚ÇÇ‚ÇÉ,\n      IsIso.inv_hom_id_assoc, h.wi]\n  have hi : IsLimit (KernelFork.ofŒπ i wi) := KernelFork.IsLimit.ofŒπ _ _\n    (fun x hx => h.liftK (x ‚â´ œÜ.œÑ‚ÇÇ)\n      (by rw [assoc, œÜ.comm‚ÇÇ‚ÇÉ, reassoc_of% hx, zero_comp]))\n    (fun x hx => by simp [i])\n    (fun x hx b hb => by rw [‚Üê cancel_mono h.i, ‚Üê cancel_mono (inv œÜ.œÑ‚ÇÇ), assoc, assoc,\n      hb, liftK_i_assoc, assoc, IsIso.hom_inv_id, comp_id])\n  let f' := hi.lift (KernelFork.ofŒπ S‚ÇÅ.f S‚ÇÅ.zero)\n  have hf' : f' ‚â´ i = S‚ÇÅ.f := Fork.IsLimit.lift_Œπ _\n  have hf'' : f' = œÜ.œÑ‚ÇÅ ‚â´ h.f' := by\n    rw [‚Üê cancel_mono h.i, ‚Üê cancel_mono (inv œÜ.œÑ‚ÇÇ), assoc, assoc, assoc, hf', f'_i_assoc,\n      œÜ.comm‚ÇÅ‚ÇÇ_assoc, IsIso.hom_inv_id, comp_id]\n  have wœÄ : f' ‚â´ h.œÄ = 0 := by simp only [hf'', assoc, f'_œÄ, comp_zero]\n  have hœÄ : IsColimit (CokernelCofork.ofœÄ h.œÄ wœÄ) := CokernelCofork.IsColimit.ofœÄ _ _\n    (fun x hx => h.descH x (by rw [‚Üê cancel_epi œÜ.œÑ‚ÇÅ, ‚Üê reassoc_of% hf'', hx, comp_zero]))\n    (fun x hx => œÄ_descH _ _ _)\n    (fun x hx b hx => by rw [‚Üê cancel_epi h.œÄ, œÄ_descH, hx])\n  exact ‚ü®h.K, h.H, i, h.œÄ, wi, hi, wœÄ, hœÄ‚ü©\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.ofEpiOfIsIsoOfMono'_i","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù¬≥ : CategoryTheory.Limits.HasZeroMorphisms C\nS‚ÇÅ S‚ÇÇ : CategoryTheory.ShortComplex C\nœÜ : Quiver.Hom S‚ÇÅ S‚ÇÇ\nh : S‚ÇÇ.LeftHomologyData\ninst‚úù¬≤ : CategoryTheory.Epi œÜ.œÑ‚ÇÅ\ninst‚úù¬π : CategoryTheory.IsIso œÜ.œÑ‚ÇÇ\ninst‚úù : CategoryTheory.Mono œÜ.œÑ‚ÇÉ\n‚ä¢ Eq (CategoryTheory.ShortComplex.LeftHomologyData.ofEpiOfIsIsoOfMono' œÜ h).i (CategoryTheory.CategoryStruct.comp h.i (CategoryTheory.inv œÜ.œÑ‚ÇÇ))","decl":"/-- If `œÜ : S‚ÇÅ ‚ü∂ S‚ÇÇ` is a morphism of short complexes such that `œÜ.œÑ‚ÇÅ` is epi, `œÜ.œÑ‚ÇÇ` is an iso\nand `œÜ.œÑ‚ÇÉ` is mono, then a left homology data for `S‚ÇÇ` induces a left homology data for `S‚ÇÅ` with\nthe same `K` and `H` fields. The inverse construction is `ofEpiOfIsIsoOfMono`. -/\n@[simps]\nnoncomputable def ofEpiOfIsIsoOfMono' (œÜ : S‚ÇÅ ‚ü∂ S‚ÇÇ) (h : LeftHomologyData S‚ÇÇ)\n    [Epi œÜ.œÑ‚ÇÅ] [IsIso œÜ.œÑ‚ÇÇ] [Mono œÜ.œÑ‚ÇÉ] : LeftHomologyData S‚ÇÅ := by\n  let i : h.K ‚ü∂ S‚ÇÅ.X‚ÇÇ := h.i ‚â´ inv œÜ.œÑ‚ÇÇ\n  have wi : i ‚â´ S‚ÇÅ.g = 0 := by\n    rw [assoc, ‚Üê cancel_mono œÜ.œÑ‚ÇÉ, zero_comp, assoc, assoc, ‚Üê œÜ.comm‚ÇÇ‚ÇÉ,\n      IsIso.inv_hom_id_assoc, h.wi]\n  have hi : IsLimit (KernelFork.ofŒπ i wi) := KernelFork.IsLimit.ofŒπ _ _\n    (fun x hx => h.liftK (x ‚â´ œÜ.œÑ‚ÇÇ)\n      (by rw [assoc, œÜ.comm‚ÇÇ‚ÇÉ, reassoc_of% hx, zero_comp]))\n    (fun x hx => by simp [i])\n    (fun x hx b hb => by rw [‚Üê cancel_mono h.i, ‚Üê cancel_mono (inv œÜ.œÑ‚ÇÇ), assoc, assoc,\n      hb, liftK_i_assoc, assoc, IsIso.hom_inv_id, comp_id])\n  let f' := hi.lift (KernelFork.ofŒπ S‚ÇÅ.f S‚ÇÅ.zero)\n  have hf' : f' ‚â´ i = S‚ÇÅ.f := Fork.IsLimit.lift_Œπ _\n  have hf'' : f' = œÜ.œÑ‚ÇÅ ‚â´ h.f' := by\n    rw [‚Üê cancel_mono h.i, ‚Üê cancel_mono (inv œÜ.œÑ‚ÇÇ), assoc, assoc, assoc, hf', f'_i_assoc,\n      œÜ.comm‚ÇÅ‚ÇÇ_assoc, IsIso.hom_inv_id, comp_id]\n  have wœÄ : f' ‚â´ h.œÄ = 0 := by simp only [hf'', assoc, f'_œÄ, comp_zero]\n  have hœÄ : IsColimit (CokernelCofork.ofœÄ h.œÄ wœÄ) := CokernelCofork.IsColimit.ofœÄ _ _\n    (fun x hx => h.descH x (by rw [‚Üê cancel_epi œÜ.œÑ‚ÇÅ, ‚Üê reassoc_of% hf'', hx, comp_zero]))\n    (fun x hx => œÄ_descH _ _ _)\n    (fun x hx b hx => by rw [‚Üê cancel_epi h.œÄ, œÄ_descH, hx])\n  exact ‚ü®h.K, h.H, i, h.œÄ, wi, hi, wœÄ, hœÄ‚ü©\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.ofEpiOfIsIsoOfMono'_f'","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù¬≥ : CategoryTheory.Limits.HasZeroMorphisms C\nS‚ÇÅ S‚ÇÇ : CategoryTheory.ShortComplex C\nœÜ : Quiver.Hom S‚ÇÅ S‚ÇÇ\nh : S‚ÇÇ.LeftHomologyData\ninst‚úù¬≤ : CategoryTheory.Epi œÜ.œÑ‚ÇÅ\ninst‚úù¬π : CategoryTheory.IsIso œÜ.œÑ‚ÇÇ\ninst‚úù : CategoryTheory.Mono œÜ.œÑ‚ÇÉ\n‚ä¢ Eq (CategoryTheory.ShortComplex.LeftHomologyData.ofEpiOfIsIsoOfMono' œÜ h).f' (CategoryTheory.CategoryStruct.comp œÜ.œÑ‚ÇÅ h.f')","decl":"@[simp]\nlemma ofEpiOfIsIsoOfMono'_f' (œÜ : S‚ÇÅ ‚ü∂ S‚ÇÇ) (h : LeftHomologyData S‚ÇÇ)\n    [Epi œÜ.œÑ‚ÇÅ] [IsIso œÜ.œÑ‚ÇÇ] [Mono œÜ.œÑ‚ÇÉ] : (ofEpiOfIsIsoOfMono' œÜ h).f' = œÜ.œÑ‚ÇÅ ‚â´ h.f' := by\n  rw [‚Üê cancel_mono (ofEpiOfIsIsoOfMono' œÜ h).i, f'_i, ofEpiOfIsIsoOfMono'_i,\n    assoc, f'_i_assoc, œÜ.comm‚ÇÅ‚ÇÇ_assoc, IsIso.hom_inv_id, comp_id]\n\n"}
{"name":"CategoryTheory.ShortComplex.hasLeftHomology_of_epi_of_isIso_of_mono","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù‚Åµ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù‚Å¥ : CategoryTheory.Limits.HasZeroMorphisms C\nS‚ÇÅ S‚ÇÇ : CategoryTheory.ShortComplex C\nœÜ : Quiver.Hom S‚ÇÅ S‚ÇÇ\ninst‚úù¬≥ : S‚ÇÅ.HasLeftHomology\ninst‚úù¬≤ : CategoryTheory.Epi œÜ.œÑ‚ÇÅ\ninst‚úù¬π : CategoryTheory.IsIso œÜ.œÑ‚ÇÇ\ninst‚úù : CategoryTheory.Mono œÜ.œÑ‚ÇÉ\n‚ä¢ S‚ÇÇ.HasLeftHomology","decl":"lemma hasLeftHomology_of_epi_of_isIso_of_mono (œÜ : S‚ÇÅ ‚ü∂ S‚ÇÇ) [HasLeftHomology S‚ÇÅ]\n    [Epi œÜ.œÑ‚ÇÅ] [IsIso œÜ.œÑ‚ÇÇ] [Mono œÜ.œÑ‚ÇÉ] : HasLeftHomology S‚ÇÇ :=\n  HasLeftHomology.mk' (LeftHomologyData.ofEpiOfIsIsoOfMono œÜ S‚ÇÅ.leftHomologyData)\n\n"}
{"name":"CategoryTheory.ShortComplex.hasLeftHomology_of_epi_of_isIso_of_mono'","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù‚Åµ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù‚Å¥ : CategoryTheory.Limits.HasZeroMorphisms C\nS‚ÇÅ S‚ÇÇ : CategoryTheory.ShortComplex C\nœÜ : Quiver.Hom S‚ÇÅ S‚ÇÇ\ninst‚úù¬≥ : S‚ÇÇ.HasLeftHomology\ninst‚úù¬≤ : CategoryTheory.Epi œÜ.œÑ‚ÇÅ\ninst‚úù¬π : CategoryTheory.IsIso œÜ.œÑ‚ÇÇ\ninst‚úù : CategoryTheory.Mono œÜ.œÑ‚ÇÉ\n‚ä¢ S‚ÇÅ.HasLeftHomology","decl":"lemma hasLeftHomology_of_epi_of_isIso_of_mono' (œÜ : S‚ÇÅ ‚ü∂ S‚ÇÇ) [HasLeftHomology S‚ÇÇ]\n    [Epi œÜ.œÑ‚ÇÅ] [IsIso œÜ.œÑ‚ÇÇ] [Mono œÜ.œÑ‚ÇÉ] : HasLeftHomology S‚ÇÅ :=\n  HasLeftHomology.mk' (LeftHomologyData.ofEpiOfIsIsoOfMono' œÜ S‚ÇÇ.leftHomologyData)\n\n"}
{"name":"CategoryTheory.ShortComplex.hasLeftHomology_of_iso","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms C\nS‚ÇÅ S‚ÇÇ : CategoryTheory.ShortComplex C\ne : CategoryTheory.Iso S‚ÇÅ S‚ÇÇ\ninst‚úù : S‚ÇÅ.HasLeftHomology\n‚ä¢ S‚ÇÇ.HasLeftHomology","decl":"lemma hasLeftHomology_of_iso {S‚ÇÅ S‚ÇÇ : ShortComplex C} (e : S‚ÇÅ ‚âÖ S‚ÇÇ) [HasLeftHomology S‚ÇÅ] :\n    HasLeftHomology S‚ÇÇ :=\n  hasLeftHomology_of_epi_of_isIso_of_mono e.hom\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyMapData.ofEpiOfIsIsoOfMono_œÜH","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù¬≥ : CategoryTheory.Limits.HasZeroMorphisms C\nS‚ÇÅ S‚ÇÇ : CategoryTheory.ShortComplex C\nœÜ : Quiver.Hom S‚ÇÅ S‚ÇÇ\nh : S‚ÇÅ.LeftHomologyData\ninst‚úù¬≤ : CategoryTheory.Epi œÜ.œÑ‚ÇÅ\ninst‚úù¬π : CategoryTheory.IsIso œÜ.œÑ‚ÇÇ\ninst‚úù : CategoryTheory.Mono œÜ.œÑ‚ÇÉ\n‚ä¢ Eq (CategoryTheory.ShortComplex.LeftHomologyMapData.ofEpiOfIsIsoOfMono œÜ h).œÜH (CategoryTheory.CategoryStruct.id h.H)","decl":"/-- This left homology map data expresses compatibilities of the left homology data\nconstructed by `LeftHomologyData.ofEpiOfIsIsoOfMono` -/\n@[simps]\ndef ofEpiOfIsIsoOfMono (œÜ : S‚ÇÅ ‚ü∂ S‚ÇÇ) (h : LeftHomologyData S‚ÇÅ)\n    [Epi œÜ.œÑ‚ÇÅ] [IsIso œÜ.œÑ‚ÇÇ] [Mono œÜ.œÑ‚ÇÉ] :\n    LeftHomologyMapData œÜ h (LeftHomologyData.ofEpiOfIsIsoOfMono œÜ h) where\n  œÜK := ùüô _\n  œÜH := ùüô _\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyMapData.ofEpiOfIsIsoOfMono_œÜK","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù¬≥ : CategoryTheory.Limits.HasZeroMorphisms C\nS‚ÇÅ S‚ÇÇ : CategoryTheory.ShortComplex C\nœÜ : Quiver.Hom S‚ÇÅ S‚ÇÇ\nh : S‚ÇÅ.LeftHomologyData\ninst‚úù¬≤ : CategoryTheory.Epi œÜ.œÑ‚ÇÅ\ninst‚úù¬π : CategoryTheory.IsIso œÜ.œÑ‚ÇÇ\ninst‚úù : CategoryTheory.Mono œÜ.œÑ‚ÇÉ\n‚ä¢ Eq (CategoryTheory.ShortComplex.LeftHomologyMapData.ofEpiOfIsIsoOfMono œÜ h).œÜK (CategoryTheory.CategoryStruct.id h.K)","decl":"/-- This left homology map data expresses compatibilities of the left homology data\nconstructed by `LeftHomologyData.ofEpiOfIsIsoOfMono` -/\n@[simps]\ndef ofEpiOfIsIsoOfMono (œÜ : S‚ÇÅ ‚ü∂ S‚ÇÇ) (h : LeftHomologyData S‚ÇÅ)\n    [Epi œÜ.œÑ‚ÇÅ] [IsIso œÜ.œÑ‚ÇÇ] [Mono œÜ.œÑ‚ÇÉ] :\n    LeftHomologyMapData œÜ h (LeftHomologyData.ofEpiOfIsIsoOfMono œÜ h) where\n  œÜK := ùüô _\n  œÜH := ùüô _\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyMapData.ofEpiOfIsIsoOfMono'_œÜH","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù¬≥ : CategoryTheory.Limits.HasZeroMorphisms C\nS‚ÇÅ S‚ÇÇ : CategoryTheory.ShortComplex C\nœÜ : Quiver.Hom S‚ÇÅ S‚ÇÇ\nh : S‚ÇÇ.LeftHomologyData\ninst‚úù¬≤ : CategoryTheory.Epi œÜ.œÑ‚ÇÅ\ninst‚úù¬π : CategoryTheory.IsIso œÜ.œÑ‚ÇÇ\ninst‚úù : CategoryTheory.Mono œÜ.œÑ‚ÇÉ\n‚ä¢ Eq (CategoryTheory.ShortComplex.LeftHomologyMapData.ofEpiOfIsIsoOfMono' œÜ h).œÜH (CategoryTheory.CategoryStruct.id (CategoryTheory.ShortComplex.LeftHomologyData.ofEpiOfIsIsoOfMono' œÜ h).H)","decl":"/-- This left homology map data expresses compatibilities of the left homology data\nconstructed by `LeftHomologyData.ofEpiOfIsIsoOfMono'` -/\n@[simps]\nnoncomputable def ofEpiOfIsIsoOfMono' (œÜ : S‚ÇÅ ‚ü∂ S‚ÇÇ) (h : LeftHomologyData S‚ÇÇ)\n    [Epi œÜ.œÑ‚ÇÅ] [IsIso œÜ.œÑ‚ÇÇ] [Mono œÜ.œÑ‚ÇÉ] :\n    LeftHomologyMapData œÜ (LeftHomologyData.ofEpiOfIsIsoOfMono' œÜ h) h where\n  œÜK := ùüô _\n  œÜH := ùüô _\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyMapData.ofEpiOfIsIsoOfMono'_œÜK","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù¬≥ : CategoryTheory.Limits.HasZeroMorphisms C\nS‚ÇÅ S‚ÇÇ : CategoryTheory.ShortComplex C\nœÜ : Quiver.Hom S‚ÇÅ S‚ÇÇ\nh : S‚ÇÇ.LeftHomologyData\ninst‚úù¬≤ : CategoryTheory.Epi œÜ.œÑ‚ÇÅ\ninst‚úù¬π : CategoryTheory.IsIso œÜ.œÑ‚ÇÇ\ninst‚úù : CategoryTheory.Mono œÜ.œÑ‚ÇÉ\n‚ä¢ Eq (CategoryTheory.ShortComplex.LeftHomologyMapData.ofEpiOfIsIsoOfMono' œÜ h).œÜK (CategoryTheory.CategoryStruct.id (CategoryTheory.ShortComplex.LeftHomologyData.ofEpiOfIsIsoOfMono' œÜ h).K)","decl":"/-- This left homology map data expresses compatibilities of the left homology data\nconstructed by `LeftHomologyData.ofEpiOfIsIsoOfMono'` -/\n@[simps]\nnoncomputable def ofEpiOfIsIsoOfMono' (œÜ : S‚ÇÅ ‚ü∂ S‚ÇÇ) (h : LeftHomologyData S‚ÇÇ)\n    [Epi œÜ.œÑ‚ÇÅ] [IsIso œÜ.œÑ‚ÇÇ] [Mono œÜ.œÑ‚ÇÉ] :\n    LeftHomologyMapData œÜ (LeftHomologyData.ofEpiOfIsIsoOfMono' œÜ h) h where\n  œÜK := ùüô _\n  œÜH := ùüô _\n\n"}
{"name":"CategoryTheory.ShortComplex.instIsIsoLeftHomologyMap'OfEpiœÑ‚ÇÅOfœÑ‚ÇÇOfMonoœÑ‚ÇÉ","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù¬≥ : CategoryTheory.Limits.HasZeroMorphisms C\nS‚ÇÅ S‚ÇÇ : CategoryTheory.ShortComplex C\nœÜ : Quiver.Hom S‚ÇÅ S‚ÇÇ\nh‚ÇÅ : S‚ÇÅ.LeftHomologyData\nh‚ÇÇ : S‚ÇÇ.LeftHomologyData\ninst‚úù¬≤ : CategoryTheory.Epi œÜ.œÑ‚ÇÅ\ninst‚úù¬π : CategoryTheory.IsIso œÜ.œÑ‚ÇÇ\ninst‚úù : CategoryTheory.Mono œÜ.œÑ‚ÇÉ\n‚ä¢ CategoryTheory.IsIso (CategoryTheory.ShortComplex.leftHomologyMap' œÜ h‚ÇÅ h‚ÇÇ)","decl":"instance (œÜ : S‚ÇÅ ‚ü∂ S‚ÇÇ) (h‚ÇÅ : S‚ÇÅ.LeftHomologyData) (h‚ÇÇ : S‚ÇÇ.LeftHomologyData)\n    [Epi œÜ.œÑ‚ÇÅ] [IsIso œÜ.œÑ‚ÇÇ] [Mono œÜ.œÑ‚ÇÉ] :\n    IsIso (leftHomologyMap' œÜ h‚ÇÅ h‚ÇÇ) := by\n  let h‚ÇÇ' := LeftHomologyData.ofEpiOfIsIsoOfMono œÜ h‚ÇÅ\n  have : IsIso (leftHomologyMap' œÜ h‚ÇÅ h‚ÇÇ') := by\n    rw [(LeftHomologyMapData.ofEpiOfIsIsoOfMono œÜ h‚ÇÅ).leftHomologyMap'_eq]\n    dsimp\n    infer_instance\n  have eq := leftHomologyMap'_comp œÜ (ùüô S‚ÇÇ) h‚ÇÅ h‚ÇÇ' h‚ÇÇ\n  rw [comp_id] at eq\n  rw [eq]\n  infer_instance\n\n"}
{"name":"CategoryTheory.ShortComplex.instIsIsoLeftHomologyMapOfEpiœÑ‚ÇÅOfœÑ‚ÇÇOfMonoœÑ‚ÇÉ","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù‚Å∂ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù‚Åµ : CategoryTheory.Limits.HasZeroMorphisms C\nS‚ÇÅ S‚ÇÇ : CategoryTheory.ShortComplex C\nœÜ : Quiver.Hom S‚ÇÅ S‚ÇÇ\ninst‚úù‚Å¥ : S‚ÇÅ.HasLeftHomology\ninst‚úù¬≥ : S‚ÇÇ.HasLeftHomology\ninst‚úù¬≤ : CategoryTheory.Epi œÜ.œÑ‚ÇÅ\ninst‚úù¬π : CategoryTheory.IsIso œÜ.œÑ‚ÇÇ\ninst‚úù : CategoryTheory.Mono œÜ.œÑ‚ÇÉ\n‚ä¢ CategoryTheory.IsIso (CategoryTheory.ShortComplex.leftHomologyMap œÜ)","decl":"/-- If a morphism of short complexes `œÜ : S‚ÇÅ ‚ü∂ S‚ÇÇ` is such that `œÜ.œÑ‚ÇÅ` is epi, `œÜ.œÑ‚ÇÇ` is an iso,\nand `œÜ.œÑ‚ÇÉ` is mono, then the induced morphism on left homology is an isomorphism. -/\ninstance (œÜ : S‚ÇÅ ‚ü∂ S‚ÇÇ) [S‚ÇÅ.HasLeftHomology] [S‚ÇÇ.HasLeftHomology]\n    [Epi œÜ.œÑ‚ÇÅ] [IsIso œÜ.œÑ‚ÇÇ] [Mono œÜ.œÑ‚ÇÉ] :\n    IsIso (leftHomologyMap œÜ) := by\n  dsimp only [leftHomologyMap]\n  infer_instance\n\n"}
{"name":"CategoryTheory.ShortComplex.liftCycles_i","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nA : C\nk : Quiver.Hom A S.X‚ÇÇ\nhk : Eq (CategoryTheory.CategoryStruct.comp k S.g) 0\ninst‚úù : S.HasLeftHomology\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (S.liftCycles k hk) S.iCycles) k","decl":"@[reassoc (attr := simp)]\nlemma liftCycles_i : S.liftCycles k hk ‚â´ S.iCycles = k :=\n  LeftHomologyData.liftK_i _ k hk\n\n"}
{"name":"CategoryTheory.ShortComplex.liftCycles_i_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nA : C\nk : Quiver.Hom A S.X‚ÇÇ\nhk : Eq (CategoryTheory.CategoryStruct.comp k S.g) 0\ninst‚úù : S.HasLeftHomology\nZ : C\nh : Quiver.Hom S.X‚ÇÇ Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (S.liftCycles k hk) (CategoryTheory.CategoryStruct.comp S.iCycles h)) (CategoryTheory.CategoryStruct.comp k h)","decl":"@[reassoc (attr := simp)]\nlemma liftCycles_i : S.liftCycles k hk ‚â´ S.iCycles = k :=\n  LeftHomologyData.liftK_i _ k hk\n\n"}
{"name":"CategoryTheory.ShortComplex.comp_liftCycles_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nA : C\nk : Quiver.Hom A S.X‚ÇÇ\nhk : Eq (CategoryTheory.CategoryStruct.comp k S.g) 0\ninst‚úù : S.HasLeftHomology\nA' : C\nŒ± : Quiver.Hom A' A\nZ : C\nh : Quiver.Hom S.cycles Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp Œ± (CategoryTheory.CategoryStruct.comp (S.liftCycles k hk) h)) (CategoryTheory.CategoryStruct.comp (S.liftCycles (CategoryTheory.CategoryStruct.comp Œ± k) ‚ãØ) h)","decl":"@[reassoc]\nlemma comp_liftCycles {A' : C} (Œ± : A' ‚ü∂ A) :\n    Œ± ‚â´ S.liftCycles k hk = S.liftCycles (Œ± ‚â´ k) (by rw [assoc, hk, comp_zero]) := by aesop_cat\n\n"}
{"name":"CategoryTheory.ShortComplex.comp_liftCycles","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nA : C\nk : Quiver.Hom A S.X‚ÇÇ\nhk : Eq (CategoryTheory.CategoryStruct.comp k S.g) 0\ninst‚úù : S.HasLeftHomology\nA' : C\nŒ± : Quiver.Hom A' A\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp Œ± (S.liftCycles k hk)) (S.liftCycles (CategoryTheory.CategoryStruct.comp Œ± k) ‚ãØ)","decl":"@[reassoc]\nlemma comp_liftCycles {A' : C} (Œ± : A' ‚ü∂ A) :\n    Œ± ‚â´ S.liftCycles k hk = S.liftCycles (Œ± ‚â´ k) (by rw [assoc, hk, comp_zero]) := by aesop_cat\n\n"}
{"name":"CategoryTheory.ShortComplex.cyclesIsoKernel_inv","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬≥ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst‚úù¬π : S.HasLeftHomology\ninst‚úù : CategoryTheory.Limits.HasKernel S.g\n‚ä¢ Eq S.cyclesIsoKernel.inv (S.liftCycles (CategoryTheory.Limits.kernel.Œπ S.g) ‚ãØ)","decl":"/-- The canonical isomorphism `S.cycles ‚âÖ kernel S.g`. -/\n@[simps]\nnoncomputable def cyclesIsoKernel [HasKernel S.g] : S.cycles ‚âÖ kernel S.g where\n  hom := kernel.lift S.g S.iCycles (by simp)\n  inv := S.liftCycles (kernel.Œπ S.g) (by simp)\n\n"}
{"name":"CategoryTheory.ShortComplex.cyclesIsoKernel_hom","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬≥ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst‚úù¬π : S.HasLeftHomology\ninst‚úù : CategoryTheory.Limits.HasKernel S.g\n‚ä¢ Eq S.cyclesIsoKernel.hom (CategoryTheory.Limits.kernel.lift S.g S.iCycles ‚ãØ)","decl":"/-- The canonical isomorphism `S.cycles ‚âÖ kernel S.g`. -/\n@[simps]\nnoncomputable def cyclesIsoKernel [HasKernel S.g] : S.cycles ‚âÖ kernel S.g where\n  hom := kernel.lift S.g S.iCycles (by simp)\n  inv := S.liftCycles (kernel.Œπ S.g) (by simp)\n\n"}
{"name":"CategoryTheory.ShortComplex.liftCycles_leftHomologyœÄ_eq_zero_of_boundary_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nA : C\nk : Quiver.Hom A S.X‚ÇÇ\ninst‚úù : S.HasLeftHomology\nx : Quiver.Hom A S.X‚ÇÅ\nhx : Eq k (CategoryTheory.CategoryStruct.comp x S.f)\nZ : C\nh : Quiver.Hom S.leftHomology Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (S.liftCycles k ‚ãØ) (CategoryTheory.CategoryStruct.comp S.leftHomologyœÄ h)) (CategoryTheory.CategoryStruct.comp 0 h)","decl":"@[reassoc]\nlemma liftCycles_leftHomologyœÄ_eq_zero_of_boundary (x : A ‚ü∂ S.X‚ÇÅ) (hx : k = x ‚â´ S.f) :\n    S.liftCycles k (by rw [hx, assoc, S.zero, comp_zero]) ‚â´ S.leftHomologyœÄ = 0 :=\n  LeftHomologyData.liftK_œÄ_eq_zero_of_boundary _ k x hx\n\n"}
{"name":"CategoryTheory.ShortComplex.liftCycles_leftHomologyœÄ_eq_zero_of_boundary","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nA : C\nk : Quiver.Hom A S.X‚ÇÇ\ninst‚úù : S.HasLeftHomology\nx : Quiver.Hom A S.X‚ÇÅ\nhx : Eq k (CategoryTheory.CategoryStruct.comp x S.f)\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (S.liftCycles k ‚ãØ) S.leftHomologyœÄ) 0","decl":"@[reassoc]\nlemma liftCycles_leftHomologyœÄ_eq_zero_of_boundary (x : A ‚ü∂ S.X‚ÇÅ) (hx : k = x ‚â´ S.f) :\n    S.liftCycles k (by rw [hx, assoc, S.zero, comp_zero]) ‚â´ S.leftHomologyœÄ = 0 :=\n  LeftHomologyData.liftK_œÄ_eq_zero_of_boundary _ k x hx\n\n"}
{"name":"CategoryTheory.ShortComplex.toCycles_comp_leftHomologyœÄ_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst‚úù : S.HasLeftHomology\nZ : C\nh : Quiver.Hom S.leftHomology Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp S.toCycles (CategoryTheory.CategoryStruct.comp S.leftHomologyœÄ h)) (CategoryTheory.CategoryStruct.comp 0 h)","decl":"@[reassoc (attr := simp)]\nlemma toCycles_comp_leftHomologyœÄ : S.toCycles ‚â´ S.leftHomologyœÄ = 0 :=\n  S.liftCycles_leftHomologyœÄ_eq_zero_of_boundary S.f (ùüô _) (by rw [id_comp])\n\n"}
{"name":"CategoryTheory.ShortComplex.toCycles_comp_leftHomologyœÄ","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst‚úù : S.HasLeftHomology\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp S.toCycles S.leftHomologyœÄ) 0","decl":"@[reassoc (attr := simp)]\nlemma toCycles_comp_leftHomologyœÄ : S.toCycles ‚â´ S.leftHomologyœÄ = 0 :=\n  S.liftCycles_leftHomologyœÄ_eq_zero_of_boundary S.f (ùüô _) (by rw [id_comp])\n\n"}
{"name":"CategoryTheory.ShortComplex.liftCycles_comp_cyclesMap_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬≥ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroMorphisms C\nS S‚ÇÅ : CategoryTheory.ShortComplex C\nA : C\nk : Quiver.Hom A S.X‚ÇÇ\nhk : Eq (CategoryTheory.CategoryStruct.comp k S.g) 0\ninst‚úù¬π : S.HasLeftHomology\nœÜ : Quiver.Hom S S‚ÇÅ\ninst‚úù : S‚ÇÅ.HasLeftHomology\nZ : C\nh : Quiver.Hom S‚ÇÅ.cycles Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (S.liftCycles k hk) (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.cyclesMap œÜ) h)) (CategoryTheory.CategoryStruct.comp (S‚ÇÅ.liftCycles (CategoryTheory.CategoryStruct.comp k œÜ.œÑ‚ÇÇ) ‚ãØ) h)","decl":"@[reassoc (attr := simp)]\nlemma liftCycles_comp_cyclesMap (œÜ : S ‚ü∂ S‚ÇÅ) [S‚ÇÅ.HasLeftHomology] :\n    S.liftCycles k hk ‚â´ cyclesMap œÜ =\n      S‚ÇÅ.liftCycles (k ‚â´ œÜ.œÑ‚ÇÇ) (by rw [assoc, œÜ.comm‚ÇÇ‚ÇÉ, reassoc_of% hk, zero_comp]) := by\n  aesop_cat\n\n"}
{"name":"CategoryTheory.ShortComplex.liftCycles_comp_cyclesMap","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬≥ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroMorphisms C\nS S‚ÇÅ : CategoryTheory.ShortComplex C\nA : C\nk : Quiver.Hom A S.X‚ÇÇ\nhk : Eq (CategoryTheory.CategoryStruct.comp k S.g) 0\ninst‚úù¬π : S.HasLeftHomology\nœÜ : Quiver.Hom S S‚ÇÅ\ninst‚úù : S‚ÇÅ.HasLeftHomology\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (S.liftCycles k hk) (CategoryTheory.ShortComplex.cyclesMap œÜ)) (S‚ÇÅ.liftCycles (CategoryTheory.CategoryStruct.comp k œÜ.œÑ‚ÇÇ) ‚ãØ)","decl":"@[reassoc (attr := simp)]\nlemma liftCycles_comp_cyclesMap (œÜ : S ‚ü∂ S‚ÇÅ) [S‚ÇÅ.HasLeftHomology] :\n    S.liftCycles k hk ‚â´ cyclesMap œÜ =\n      S‚ÇÅ.liftCycles (k ‚â´ œÜ.œÑ‚ÇÇ) (by rw [assoc, œÜ.comm‚ÇÇ‚ÇÉ, reassoc_of% hk, zero_comp]) := by\n  aesop_cat\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.liftCycles_comp_cyclesIso_hom","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nh : S.LeftHomologyData\nA : C\nk : Quiver.Hom A S.X‚ÇÇ\nhk : Eq (CategoryTheory.CategoryStruct.comp k S.g) 0\ninst‚úù : S.HasLeftHomology\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (S.liftCycles k hk) h.cyclesIso.hom) (h.liftK k hk)","decl":"@[reassoc (attr := simp)]\nlemma LeftHomologyData.liftCycles_comp_cyclesIso_hom :\n    S.liftCycles k hk ‚â´ h.cyclesIso.hom = h.liftK k hk := by\n  simp only [‚Üê cancel_mono h.i, assoc, LeftHomologyData.cyclesIso_hom_comp_i,\n    liftCycles_i, LeftHomologyData.liftK_i]\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.liftCycles_comp_cyclesIso_hom_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nh‚úù : S.LeftHomologyData\nA : C\nk : Quiver.Hom A S.X‚ÇÇ\nhk : Eq (CategoryTheory.CategoryStruct.comp k S.g) 0\ninst‚úù : S.HasLeftHomology\nZ : C\nh : Quiver.Hom h‚úù.K Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (S.liftCycles k hk) (CategoryTheory.CategoryStruct.comp h‚úù.cyclesIso.hom h)) (CategoryTheory.CategoryStruct.comp (h‚úù.liftK k hk) h)","decl":"@[reassoc (attr := simp)]\nlemma LeftHomologyData.liftCycles_comp_cyclesIso_hom :\n    S.liftCycles k hk ‚â´ h.cyclesIso.hom = h.liftK k hk := by\n  simp only [‚Üê cancel_mono h.i, assoc, LeftHomologyData.cyclesIso_hom_comp_i,\n    liftCycles_i, LeftHomologyData.liftK_i]\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.lift_K_comp_cyclesIso_inv","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nh : S.LeftHomologyData\nA : C\nk : Quiver.Hom A S.X‚ÇÇ\nhk : Eq (CategoryTheory.CategoryStruct.comp k S.g) 0\ninst‚úù : S.HasLeftHomology\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (h.liftK k hk) h.cyclesIso.inv) (S.liftCycles k hk)","decl":"@[reassoc (attr := simp)]\nlemma LeftHomologyData.lift_K_comp_cyclesIso_inv :\n    h.liftK k hk ‚â´ h.cyclesIso.inv = S.liftCycles k hk := by\n  rw [‚Üê h.liftCycles_comp_cyclesIso_hom, assoc, Iso.hom_inv_id, comp_id]\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.lift_K_comp_cyclesIso_inv_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nh‚úù : S.LeftHomologyData\nA : C\nk : Quiver.Hom A S.X‚ÇÇ\nhk : Eq (CategoryTheory.CategoryStruct.comp k S.g) 0\ninst‚úù : S.HasLeftHomology\nZ : C\nh : Quiver.Hom S.cycles Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (h‚úù.liftK k hk) (CategoryTheory.CategoryStruct.comp h‚úù.cyclesIso.inv h)) (CategoryTheory.CategoryStruct.comp (S.liftCycles k hk) h)","decl":"@[reassoc (attr := simp)]\nlemma LeftHomologyData.lift_K_comp_cyclesIso_inv :\n    h.liftK k hk ‚â´ h.cyclesIso.inv = S.liftCycles k hk := by\n  rw [‚Üê h.liftCycles_comp_cyclesIso_hom, assoc, Iso.hom_inv_id, comp_id]\n\n"}
{"name":"CategoryTheory.ShortComplex.HasLeftHomology.hasKernel","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst‚úù : S.HasLeftHomology\n‚ä¢ CategoryTheory.Limits.HasKernel S.g","decl":"lemma hasKernel [S.HasLeftHomology] : HasKernel S.g :=\n  ‚ü®‚ü®‚ü®_, S.leftHomologyData.hi‚ü©‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.ShortComplex.HasLeftHomology.hasCokernel","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬≥ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst‚úù¬π : S.HasLeftHomology\ninst‚úù : CategoryTheory.Limits.HasKernel S.g\n‚ä¢ CategoryTheory.Limits.HasCokernel (CategoryTheory.Limits.kernel.lift S.g S.f ‚ãØ)","decl":"lemma hasCokernel [S.HasLeftHomology] [HasKernel S.g] :\n    HasCokernel (kernel.lift S.g S.f S.zero) := by\n  let h := S.leftHomologyData\n  haveI : HasColimit (parallelPair h.f' 0) := ‚ü®‚ü®‚ü®_, h.hœÄ'‚ü©‚ü©‚ü©\n  let e : parallelPair (kernel.lift S.g S.f S.zero) 0 ‚âÖ parallelPair h.f' 0 :=\n    parallelPair.ext (Iso.refl _) (IsLimit.conePointUniqueUpToIso (kernelIsKernel S.g) h.hi)\n      (by aesop_cat) (by simp)\n  exact hasColimitOfIso e\n\n"}
{"name":"CategoryTheory.ShortComplex.isIso_cyclesMap'_of_isIso_of_mono","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nS‚ÇÅ S‚ÇÇ : CategoryTheory.ShortComplex C\nœÜ : Quiver.Hom S‚ÇÅ S‚ÇÇ\nh‚ÇÇ‚úù : CategoryTheory.IsIso œÜ.œÑ‚ÇÇ\nh‚ÇÉ : CategoryTheory.Mono œÜ.œÑ‚ÇÉ\nh‚ÇÅ : S‚ÇÅ.LeftHomologyData\nh‚ÇÇ : S‚ÇÇ.LeftHomologyData\n‚ä¢ CategoryTheory.IsIso (CategoryTheory.ShortComplex.cyclesMap' œÜ h‚ÇÅ h‚ÇÇ)","decl":"lemma isIso_cyclesMap'_of_isIso_of_mono (œÜ : S‚ÇÅ ‚ü∂ S‚ÇÇ) (h‚ÇÇ : IsIso œÜ.œÑ‚ÇÇ) (h‚ÇÉ : Mono œÜ.œÑ‚ÇÉ)\n    (h‚ÇÅ : S‚ÇÅ.LeftHomologyData) (h‚ÇÇ : S‚ÇÇ.LeftHomologyData) :\n    IsIso (cyclesMap' œÜ h‚ÇÅ h‚ÇÇ) := by\n  refine ‚ü®h‚ÇÅ.liftK (h‚ÇÇ.i ‚â´ inv œÜ.œÑ‚ÇÇ) ?_, ?_, ?_‚ü©\n  ¬∑ simp only [assoc, ‚Üê cancel_mono œÜ.œÑ‚ÇÉ, zero_comp, ‚Üê œÜ.comm‚ÇÇ‚ÇÉ, IsIso.inv_hom_id_assoc, h‚ÇÇ.wi]\n  ¬∑ simp only [‚Üê cancel_mono h‚ÇÅ.i, assoc, h‚ÇÅ.liftK_i, cyclesMap'_i_assoc,\n      IsIso.hom_inv_id, comp_id, id_comp]\n  ¬∑ simp only [‚Üê cancel_mono h‚ÇÇ.i, assoc, cyclesMap'_i, h‚ÇÅ.liftK_i_assoc,\n      IsIso.inv_hom_id, comp_id, id_comp]\n\n"}
{"name":"CategoryTheory.ShortComplex.isIso_cyclesMap_of_isIso_of_mono'","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù¬≥ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroMorphisms C\nS‚ÇÅ S‚ÇÇ : CategoryTheory.ShortComplex C\nœÜ : Quiver.Hom S‚ÇÅ S‚ÇÇ\nh‚ÇÇ : CategoryTheory.IsIso œÜ.œÑ‚ÇÇ\nh‚ÇÉ : CategoryTheory.Mono œÜ.œÑ‚ÇÉ\ninst‚úù¬π : S‚ÇÅ.HasLeftHomology\ninst‚úù : S‚ÇÇ.HasLeftHomology\n‚ä¢ CategoryTheory.IsIso (CategoryTheory.ShortComplex.cyclesMap œÜ)","decl":"lemma isIso_cyclesMap_of_isIso_of_mono' (œÜ : S‚ÇÅ ‚ü∂ S‚ÇÇ) (h‚ÇÇ : IsIso œÜ.œÑ‚ÇÇ) (h‚ÇÉ : Mono œÜ.œÑ‚ÇÉ)\n    [S‚ÇÅ.HasLeftHomology] [S‚ÇÇ.HasLeftHomology] :\n    IsIso (cyclesMap œÜ) :=\n  isIso_cyclesMap'_of_isIso_of_mono œÜ h‚ÇÇ h‚ÇÉ _ _\n\n"}
{"name":"CategoryTheory.ShortComplex.isIso_cyclesMap_of_isIso_of_mono","module":"Mathlib.Algebra.Homology.ShortComplex.LeftHomology","initialProofState":"C : Type u_1\ninst‚úù‚Åµ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù‚Å¥ : CategoryTheory.Limits.HasZeroMorphisms C\nS‚ÇÅ S‚ÇÇ : CategoryTheory.ShortComplex C\nœÜ : Quiver.Hom S‚ÇÅ S‚ÇÇ\ninst‚úù¬≥ : CategoryTheory.IsIso œÜ.œÑ‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Mono œÜ.œÑ‚ÇÉ\ninst‚úù¬π : S‚ÇÅ.HasLeftHomology\ninst‚úù : S‚ÇÇ.HasLeftHomology\n‚ä¢ CategoryTheory.IsIso (CategoryTheory.ShortComplex.cyclesMap œÜ)","decl":"instance isIso_cyclesMap_of_isIso_of_mono (œÜ : S‚ÇÅ ‚ü∂ S‚ÇÇ) [IsIso œÜ.œÑ‚ÇÇ] [Mono œÜ.œÑ‚ÇÉ]\n    [S‚ÇÅ.HasLeftHomology] [S‚ÇÇ.HasLeftHomology] :\n    IsIso (cyclesMap œÜ) :=\n  isIso_cyclesMap_of_isIso_of_mono' œÜ inferInstance inferInstance\n\n"}
