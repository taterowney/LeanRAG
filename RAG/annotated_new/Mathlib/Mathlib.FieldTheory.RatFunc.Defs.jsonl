{"name":"RatFunc.ofFractionRing.sizeOf_spec","module":"Mathlib.FieldTheory.RatFunc.Defs","initialProofState":"K : Type u\ninst✝¹ : CommRing K\ninst✝ : SizeOf K\ntoFractionRing : FractionRing (Polynomial K)\n⊢ Eq (SizeOf.sizeOf { toFractionRing := toFractionRing }) (HAdd.hAdd 1 (SizeOf.sizeOf toFractionRing))","decl":"/-- `RatFunc K` is `K(X)`, the field of rational functions over `K`.\n\nThe inclusion of polynomials into `RatFunc` is `algebraMap K[X] (RatFunc K)`,\nthe maps between `RatFunc K` and another field of fractions of `K[X]`,\nespecially `FractionRing K[X]`, are given by `IsLocalization.algEquiv`.\n-/\nstructure RatFunc [CommRing K] : Type u where ofFractionRing ::\n/-- the coercion to the fraction ring of the polynomial ring -/\n  toFractionRing : FractionRing K[X]\n\n"}
{"name":"RatFunc.ofFractionRing.inj","module":"Mathlib.FieldTheory.RatFunc.Defs","initialProofState":"K : Type u\ninst✝ : CommRing K\ntoFractionRing✝ toFractionRing : FractionRing (Polynomial K)\nx✝ : Eq { toFractionRing := toFractionRing✝ } { toFractionRing := toFractionRing }\n⊢ Eq toFractionRing✝ toFractionRing","decl":"/-- `RatFunc K` is `K(X)`, the field of rational functions over `K`.\n\nThe inclusion of polynomials into `RatFunc` is `algebraMap K[X] (RatFunc K)`,\nthe maps between `RatFunc K` and another field of fractions of `K[X]`,\nespecially `FractionRing K[X]`, are given by `IsLocalization.algEquiv`.\n-/\nstructure RatFunc [CommRing K] : Type u where ofFractionRing ::\n/-- the coercion to the fraction ring of the polynomial ring -/\n  toFractionRing : FractionRing K[X]\n\n"}
{"name":"RatFunc.ofFractionRing.injEq","module":"Mathlib.FieldTheory.RatFunc.Defs","initialProofState":"K : Type u\ninst✝ : CommRing K\ntoFractionRing✝ toFractionRing : FractionRing (Polynomial K)\n⊢ Eq (Eq { toFractionRing := toFractionRing✝ } { toFractionRing := toFractionRing }) (Eq toFractionRing✝ toFractionRing)","decl":"/-- `RatFunc K` is `K(X)`, the field of rational functions over `K`.\n\nThe inclusion of polynomials into `RatFunc` is `algebraMap K[X] (RatFunc K)`,\nthe maps between `RatFunc K` and another field of fractions of `K[X]`,\nespecially `FractionRing K[X]`, are given by `IsLocalization.algEquiv`.\n-/\nstructure RatFunc [CommRing K] : Type u where ofFractionRing ::\n/-- the coercion to the fraction ring of the polynomial ring -/\n  toFractionRing : FractionRing K[X]\n\n"}
{"name":"RatFunc.ofFractionRing_injective","module":"Mathlib.FieldTheory.RatFunc.Defs","initialProofState":"K : Type u\ninst✝ : CommRing K\n⊢ Function.Injective RatFunc.ofFractionRing","decl":"theorem ofFractionRing_injective : Function.Injective (ofFractionRing : _ → RatFunc K) :=\n  fun _ _ => ofFractionRing.inj\n\n"}
{"name":"RatFunc.toFractionRing_injective","module":"Mathlib.FieldTheory.RatFunc.Defs","initialProofState":"K : Type u\ninst✝ : CommRing K\n⊢ Function.Injective RatFunc.toFractionRing","decl":"theorem toFractionRing_injective : Function.Injective (toFractionRing : _ → FractionRing K[X])\n  | ⟨x⟩, ⟨y⟩, xy => by subst xy; rfl\n\n"}
{"name":"RatFunc.toFractionRing_inj","module":"Mathlib.FieldTheory.RatFunc.Defs","initialProofState":"K : Type u\ninst✝ : CommRing K\nx y : RatFunc K\n⊢ Iff (Eq x.toFractionRing y.toFractionRing) (Eq x y)","decl":"@[simp] lemma toFractionRing_inj {x y : RatFunc K} :\n    toFractionRing x = toFractionRing y ↔ x = y :=\n  toFractionRing_injective.eq_iff\n\n"}
{"name":"RatFunc.toFractionRing_eq_iff","module":"Mathlib.FieldTheory.RatFunc.Defs","initialProofState":"K : Type u\ninst✝ : CommRing K\nx y : RatFunc K\n⊢ Iff (Eq x.toFractionRing y.toFractionRing) (Eq x y)","decl":"@[deprecated (since := \"2024-12-29\")] alias toFractionRing_eq_iff := toFractionRing_inj\n\n"}
{"name":"RatFunc.liftOn_def","module":"Mathlib.FieldTheory.RatFunc.Defs","initialProofState":"K : Type u_1\ninst✝ : CommRing K\nP : Sort u_2\nx : RatFunc K\nf : Polynomial K → Polynomial K → P\nH : ∀ {p q p' q' : Polynomial K}, Membership.mem (nonZeroDivisors (Polynomial K)) q → Membership.mem (nonZeroDivisors (Polynomial K)) q' → Eq (HMul.hMul q' p) (HMul.hMul q p') → Eq (f p q) (f p' q')\n⊢ Eq (x.liftOn f H) (Localization.liftOn x.toFractionRing (fun p q => f p ↑q) ⋯)","decl":"/-- Non-dependent recursion principle for `RatFunc K`:\nTo construct a term of `P : Sort*` out of `x : RatFunc K`,\nit suffices to provide a constructor `f : Π (p q : K[X]), P`\nand a proof that `f p q = f p' q'` for all `p q p' q'` such that `q' * p = q * p'` where\nboth `q` and `q'` are not zero divisors, stated as `q ∉ K[X]⁰`, `q' ∉ K[X]⁰`.\n\nIf considering `K` as an integral domain, this is the same as saying that\nwe construct a value of `P` for such elements of `RatFunc K` by setting\n`liftOn (p / q) f _ = f p q`.\n\nWhen `[IsDomain K]`, one can use `RatFunc.liftOn'`, which has the stronger requirement\nof `∀ {p q a : K[X]} (hq : q ≠ 0) (ha : a ≠ 0), f (a * p) (a * q) = f p q)`.\n-/\nprotected irreducible_def liftOn {P : Sort v} (x : RatFunc K) (f : K[X] → K[X] → P)\n    (H : ∀ {p q p' q'} (_hq : q ∈ K[X]⁰) (_hq' : q' ∈ K[X]⁰), q' * p = q * p' → f p q = f p' q') :\n    P :=\n  Localization.liftOn (toFractionRing x) (fun p q => f p q) fun {_ _ q q'} h =>\n    H q.2 q'.2 (let ⟨⟨_, _⟩, mul_eq⟩ := Localization.r_iff_exists.mp h\n      mul_cancel_left_coe_nonZeroDivisors.mp mul_eq)\n\n"}
{"name":"RatFunc.liftOn_ofFractionRing_mk","module":"Mathlib.FieldTheory.RatFunc.Defs","initialProofState":"K : Type u\ninst✝ : CommRing K\nP : Sort v\nn : Polynomial K\nd : Subtype fun x => Membership.mem (nonZeroDivisors (Polynomial K)) x\nf : Polynomial K → Polynomial K → P\nH : ∀ {p q p' q' : Polynomial K}, Membership.mem (nonZeroDivisors (Polynomial K)) q → Membership.mem (nonZeroDivisors (Polynomial K)) q' → Eq (HMul.hMul q' p) (HMul.hMul q p') → Eq (f p q) (f p' q')\n⊢ Eq ({ toFractionRing := Localization.mk n d }.liftOn f H) (f n ↑d)","decl":"theorem liftOn_ofFractionRing_mk {P : Sort v} (n : K[X]) (d : K[X]⁰) (f : K[X] → K[X] → P)\n    (H : ∀ {p q p' q'} (_hq : q ∈ K[X]⁰) (_hq' : q' ∈ K[X]⁰), q' * p = q * p' → f p q = f p' q') :\n    RatFunc.liftOn (ofFractionRing (Localization.mk n d)) f @H = f n d := by\n  rw [RatFunc.liftOn]\n  exact Localization.liftOn_mk _ _ _ _\n\n"}
{"name":"RatFunc.liftOn_condition_of_liftOn'_condition","module":"Mathlib.FieldTheory.RatFunc.Defs","initialProofState":"K : Type u\ninst✝ : CommRing K\nP : Sort v\nf : Polynomial K → Polynomial K → P\nH : ∀ {p q a : Polynomial K}, Ne q 0 → Ne a 0 → Eq (f (HMul.hMul a p) (HMul.hMul a q)) (f p q)\np q p' q' : Polynomial K\nhq : Ne q 0\nhq' : Ne q' 0\nh : Eq (HMul.hMul q' p) (HMul.hMul q p')\n⊢ Eq (f p q) (f p' q')","decl":"theorem liftOn_condition_of_liftOn'_condition {P : Sort v} {f : K[X] → K[X] → P}\n    (H : ∀ {p q a} (_ : q ≠ 0) (_ha : a ≠ 0), f (a * p) (a * q) = f p q) ⦃p q p' q' : K[X]⦄\n    (hq : q ≠ 0) (hq' : q' ≠ 0) (h : q' * p = q * p') : f p q = f p' q' :=\n  calc\n    f p q = f (q' * p) (q' * q) := (H hq hq').symm\n    _ = f (q * p') (q * q') := by rw [h, mul_comm q']\n    _ = f p' q' := H hq' hq\n\n"}
{"name":"RatFunc.mk_def","module":"Mathlib.FieldTheory.RatFunc.Defs","initialProofState":"K : Type u_1\ninst✝¹ : CommRing K\ninst✝ : IsDomain K\np q : Polynomial K\n⊢ Eq (RatFunc.mk p q) { toFractionRing := HDiv.hDiv ((algebraMap (Polynomial K) (FractionRing (Polynomial K))) p) ((algebraMap (Polynomial K) (FractionRing (Polynomial K))) q) }","decl":"/-- `RatFunc.mk (p q : K[X])` is `p / q` as a rational function.\n\nIf `q = 0`, then `mk` returns 0.\n\nThis is an auxiliary definition used to define an `Algebra` structure on `RatFunc`;\nthe `simp` normal form of `mk p q` is `algebraMap _ _ p / algebraMap _ _ q`.\n-/\nprotected irreducible_def mk (p q : K[X]) : RatFunc K :=\n  ofFractionRing (algebraMap _ _ p / algebraMap _ _ q)\n\n"}
{"name":"RatFunc.mk_eq_div'","module":"Mathlib.FieldTheory.RatFunc.Defs","initialProofState":"K : Type u\ninst✝¹ : CommRing K\ninst✝ : IsDomain K\np q : Polynomial K\n⊢ Eq (RatFunc.mk p q) { toFractionRing := HDiv.hDiv ((algebraMap (Polynomial K) (FractionRing (Polynomial K))) p) ((algebraMap (Polynomial K) (FractionRing (Polynomial K))) q) }","decl":"theorem mk_eq_div' (p q : K[X]) :\n    RatFunc.mk p q = ofFractionRing (algebraMap _ _ p / algebraMap _ _ q) := by rw [RatFunc.mk]\n\n"}
{"name":"RatFunc.mk_zero","module":"Mathlib.FieldTheory.RatFunc.Defs","initialProofState":"K : Type u\ninst✝¹ : CommRing K\ninst✝ : IsDomain K\np : Polynomial K\n⊢ Eq (RatFunc.mk p 0) { toFractionRing := 0 }","decl":"theorem mk_zero (p : K[X]) : RatFunc.mk p 0 = ofFractionRing (0 : FractionRing K[X]) := by\n  rw [mk_eq_div', RingHom.map_zero, div_zero]\n\n"}
{"name":"RatFunc.mk_coe_def","module":"Mathlib.FieldTheory.RatFunc.Defs","initialProofState":"K : Type u\ninst✝¹ : CommRing K\ninst✝ : IsDomain K\np : Polynomial K\nq : Subtype fun x => Membership.mem (nonZeroDivisors (Polynomial K)) x\n⊢ Eq (RatFunc.mk p ↑q) { toFractionRing := IsLocalization.mk' (FractionRing (Polynomial K)) p q }","decl":"theorem mk_coe_def (p : K[X]) (q : K[X]⁰) :\n    RatFunc.mk p q = ofFractionRing (IsLocalization.mk' _ p q) := by\n  simp only [mk_eq_div', ← Localization.mk_eq_mk', FractionRing.mk_eq_div]\n\n"}
{"name":"RatFunc.mk_def_of_mem","module":"Mathlib.FieldTheory.RatFunc.Defs","initialProofState":"K : Type u\ninst✝¹ : CommRing K\ninst✝ : IsDomain K\np q : Polynomial K\nhq : Membership.mem (nonZeroDivisors (Polynomial K)) q\n⊢ Eq (RatFunc.mk p q) { toFractionRing := IsLocalization.mk' (FractionRing (Polynomial K)) p ⟨q, hq⟩ }","decl":"theorem mk_def_of_mem (p : K[X]) {q} (hq : q ∈ K[X]⁰) :\n    RatFunc.mk p q = ofFractionRing (IsLocalization.mk' (FractionRing K[X]) p ⟨q, hq⟩) := by\n  simp only [← mk_coe_def]\n\n"}
{"name":"RatFunc.mk_def_of_ne","module":"Mathlib.FieldTheory.RatFunc.Defs","initialProofState":"K : Type u\ninst✝¹ : CommRing K\ninst✝ : IsDomain K\np q : Polynomial K\nhq : Ne q 0\n⊢ Eq (RatFunc.mk p q) { toFractionRing := IsLocalization.mk' (FractionRing (Polynomial K)) p ⟨q, ⋯⟩ }","decl":"theorem mk_def_of_ne (p : K[X]) {q : K[X]} (hq : q ≠ 0) :\n    RatFunc.mk p q =\n      ofFractionRing (IsLocalization.mk' (FractionRing K[X]) p\n        ⟨q, mem_nonZeroDivisors_iff_ne_zero.mpr hq⟩) :=\n  mk_def_of_mem p _\n\n"}
{"name":"RatFunc.mk_eq_localization_mk","module":"Mathlib.FieldTheory.RatFunc.Defs","initialProofState":"K : Type u\ninst✝¹ : CommRing K\ninst✝ : IsDomain K\np q : Polynomial K\nhq : Ne q 0\n⊢ Eq (RatFunc.mk p q) { toFractionRing := Localization.mk p ⟨q, ⋯⟩ }","decl":"theorem mk_eq_localization_mk (p : K[X]) {q : K[X]} (hq : q ≠ 0) :\n    RatFunc.mk p q =\n      ofFractionRing (Localization.mk p ⟨q, mem_nonZeroDivisors_iff_ne_zero.mpr hq⟩) := by\n  rw [mk_def_of_ne _ hq, Localization.mk_eq_mk']\n\n"}
{"name":"RatFunc.mk_one'","module":"Mathlib.FieldTheory.RatFunc.Defs","initialProofState":"K : Type u\ninst✝¹ : CommRing K\ninst✝ : IsDomain K\np : Polynomial K\n⊢ Eq (RatFunc.mk p 1) { toFractionRing := (algebraMap (Polynomial K) (FractionRing (Polynomial K))) p }","decl":"theorem mk_one' (p : K[X]) :\n    RatFunc.mk p 1 = ofFractionRing (algebraMap _ _ p) := by\n  rw [← IsLocalization.mk'_one (M := K[X]⁰) (FractionRing K[X]) p, ← mk_coe_def, Submonoid.coe_one]\n\n"}
{"name":"RatFunc.mk_eq_mk","module":"Mathlib.FieldTheory.RatFunc.Defs","initialProofState":"K : Type u\ninst✝¹ : CommRing K\ninst✝ : IsDomain K\np q p' q' : Polynomial K\nhq : Ne q 0\nhq' : Ne q' 0\n⊢ Iff (Eq (RatFunc.mk p q) (RatFunc.mk p' q')) (Eq (HMul.hMul p q') (HMul.hMul p' q))","decl":"theorem mk_eq_mk {p q p' q' : K[X]} (hq : q ≠ 0) (hq' : q' ≠ 0) :\n    RatFunc.mk p q = RatFunc.mk p' q' ↔ p * q' = p' * q := by\n  rw [mk_def_of_ne _ hq, mk_def_of_ne _ hq', ofFractionRing_injective.eq_iff,\n    IsLocalization.mk'_eq_iff_eq',\n    (IsFractionRing.injective K[X] (FractionRing K[X])).eq_iff]\n\n"}
{"name":"RatFunc.liftOn_mk","module":"Mathlib.FieldTheory.RatFunc.Defs","initialProofState":"K : Type u\ninst✝¹ : CommRing K\ninst✝ : IsDomain K\nP : Sort v\np q : Polynomial K\nf : Polynomial K → Polynomial K → P\nf0 : ∀ (p : Polynomial K), Eq (f p 0) (f 0 1)\nH' : ∀ {p q p' q' : Polynomial K}, Ne q 0 → Ne q' 0 → Eq (HMul.hMul q' p) (HMul.hMul q p') → Eq (f p q) (f p' q')\nH : optParam (∀ {p q p' q' : Polynomial K}, Membership.mem (nonZeroDivisors (Polynomial K)) q → Membership.mem (nonZeroDivisors (Polynomial K)) q' → Eq (HMul.hMul q' p) (HMul.hMul q p') → Eq (f p q) (f p' q')) ⋯\n⊢ Eq ((RatFunc.mk p q).liftOn f H) (f p q)","decl":"theorem liftOn_mk {P : Sort v} (p q : K[X]) (f : K[X] → K[X] → P) (f0 : ∀ p, f p 0 = f 0 1)\n    (H' : ∀ {p q p' q'} (_hq : q ≠ 0) (_hq' : q' ≠ 0), q' * p = q * p' → f p q = f p' q')\n    (H : ∀ {p q p' q'} (_hq : q ∈ K[X]⁰) (_hq' : q' ∈ K[X]⁰), q' * p = q * p' → f p q = f p' q' :=\n      fun {_ _ _ _} hq hq' h => H' (nonZeroDivisors.ne_zero hq) (nonZeroDivisors.ne_zero hq') h) :\n    (RatFunc.mk p q).liftOn f @H = f p q := by\n  by_cases hq : q = 0\n  · subst hq\n    simp only [mk_zero, f0, ← Localization.mk_zero 1, Localization.liftOn_mk,\n      liftOn_ofFractionRing_mk, Submonoid.coe_one]\n  · simp only [mk_eq_localization_mk _ hq, Localization.liftOn_mk, liftOn_ofFractionRing_mk]\n\n"}
{"name":"RatFunc.liftOn'_def","module":"Mathlib.FieldTheory.RatFunc.Defs","initialProofState":"K : Type u_1\ninst✝¹ : CommRing K\ninst✝ : IsDomain K\nP : Sort u_2\nx : RatFunc K\nf : Polynomial K → Polynomial K → P\nH : ∀ {p q a : Polynomial K}, Ne q 0 → Ne a 0 → Eq (f (HMul.hMul a p) (HMul.hMul a q)) (f p q)\n⊢ Eq (x.liftOn' f H) (x.liftOn f ⋯)","decl":"/-- Non-dependent recursion principle for `RatFunc K`: if `f p q : P` for all `p q`,\nsuch that `f (a * p) (a * q) = f p q`, then we can find a value of `P`\nfor all elements of `RatFunc K` by setting `lift_on' (p / q) f _ = f p q`.\n\nThe value of `f p 0` for any `p` is never used and in principle this may be anything,\nalthough many usages of `lift_on'` assume `f p 0 = f 0 1`.\n-/\nprotected irreducible_def liftOn' {P : Sort v} (x : RatFunc K) (f : K[X] → K[X] → P)\n  (H : ∀ {p q a} (_hq : q ≠ 0) (_ha : a ≠ 0), f (a * p) (a * q) = f p q) : P :=\n  x.liftOn f fun {_p _q _p' _q'} hq hq' =>\n    liftOn_condition_of_liftOn'_condition (@H) (nonZeroDivisors.ne_zero hq)\n      (nonZeroDivisors.ne_zero hq')\n\n"}
{"name":"RatFunc.liftOn'_mk","module":"Mathlib.FieldTheory.RatFunc.Defs","initialProofState":"K : Type u\ninst✝¹ : CommRing K\ninst✝ : IsDomain K\nP : Sort v\np q : Polynomial K\nf : Polynomial K → Polynomial K → P\nf0 : ∀ (p : Polynomial K), Eq (f p 0) (f 0 1)\nH : ∀ {p q a : Polynomial K}, Ne q 0 → Ne a 0 → Eq (f (HMul.hMul a p) (HMul.hMul a q)) (f p q)\n⊢ Eq ((RatFunc.mk p q).liftOn' f H) (f p q)","decl":"theorem liftOn'_mk {P : Sort v} (p q : K[X]) (f : K[X] → K[X] → P) (f0 : ∀ p, f p 0 = f 0 1)\n    (H : ∀ {p q a} (_hq : q ≠ 0) (_ha : a ≠ 0), f (a * p) (a * q) = f p q) :\n    (RatFunc.mk p q).liftOn' f @H = f p q := by\n  rw [RatFunc.liftOn', RatFunc.liftOn_mk _ _ _ f0]\n  apply liftOn_condition_of_liftOn'_condition H\n\n"}
{"name":"RatFunc.induction_on'","module":"Mathlib.FieldTheory.RatFunc.Defs","initialProofState":"K : Type u\ninst✝¹ : CommRing K\ninst✝ : IsDomain K\nP : RatFunc K → Prop\nx : RatFunc K\n_pq : ∀ (p q : Polynomial K), Ne q 0 → P (RatFunc.mk p q)\n⊢ P x","decl":"/-- Induction principle for `RatFunc K`: if `f p q : P (RatFunc.mk p q)` for all `p q`,\nthen `P` holds on all elements of `RatFunc K`.\n\nSee also `induction_on`, which is a recursion principle defined in terms of `algebraMap`.\n-/\n@[elab_as_elim]\nprotected theorem induction_on' {P : RatFunc K → Prop} :\n    ∀ (x : RatFunc K) (_pq : ∀ (p q : K[X]) (_ : q ≠ 0), P (RatFunc.mk p q)), P x\n  | ⟨x⟩, f =>\n    Localization.induction_on x fun ⟨p, q⟩ => by\n      simpa only [mk_coe_def, Localization.mk_eq_mk'] using\n        f p q (mem_nonZeroDivisors_iff_ne_zero.mp q.2)\n\n"}
