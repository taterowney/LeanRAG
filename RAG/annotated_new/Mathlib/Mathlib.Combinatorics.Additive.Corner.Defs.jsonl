{"name":"IsCorner.fst_fst_mem","module":"Mathlib.Combinatorics.Additive.Corner.Defs","initialProofState":"G : Type u_1\ninst✝ : AddCommMonoid G\nA : Set (Prod G G)\nx₁ y₁ x₂ y₂ : G\nself : IsCorner A x₁ y₁ x₂ y₂\n⊢ Membership.mem A { fst := x₁, snd := y₁ }","decl":"/-- A **corner** of a set `A` in an abelian group is a triple of points of the form\n`(x, y), (x + d, y), (x, y + d)`. It is **nontrivial** if `d ≠ 0`.\n\nHere we define it as triples `(x₁, y₁), (x₂, y₁), (x₁, y₂)` where `x₁ + y₂ = x₂ + y₁` in order for\nthe definition to make sense in commutative monoids, the motivating example being `ℕ`. -/\n@[mk_iff]\nstructure IsCorner (A : Set (G × G)) (x₁ y₁ x₂ y₂ : G) : Prop where\n  fst_fst_mem : (x₁, y₁) ∈ A\n  fst_snd_mem : (x₁, y₂) ∈ A\n  snd_fst_mem : (x₂, y₁) ∈ A\n  add_eq_add : x₁ + y₂ = x₂ + y₁\n\n"}
{"name":"isCorner_iff","module":"Mathlib.Combinatorics.Additive.Corner.Defs","initialProofState":"G : Type u_1\ninst✝ : AddCommMonoid G\nA : Set (Prod G G)\nx₁ y₁ x₂ y₂ : G\n⊢ Iff (IsCorner A x₁ y₁ x₂ y₂) (And (Membership.mem A { fst := x₁, snd := y₁ }) (And (Membership.mem A { fst := x₁, snd := y₂ }) (And (Membership.mem A { fst := x₂, snd := y₁ }) (Eq (HAdd.hAdd x₁ y₂) (HAdd.hAdd x₂ y₁)))))","decl":"/-- A **corner** of a set `A` in an abelian group is a triple of points of the form\n`(x, y), (x + d, y), (x, y + d)`. It is **nontrivial** if `d ≠ 0`.\n\nHere we define it as triples `(x₁, y₁), (x₂, y₁), (x₁, y₂)` where `x₁ + y₂ = x₂ + y₁` in order for\nthe definition to make sense in commutative monoids, the motivating example being `ℕ`. -/\n@[mk_iff]\nstructure IsCorner (A : Set (G × G)) (x₁ y₁ x₂ y₂ : G) : Prop where\n  fst_fst_mem : (x₁, y₁) ∈ A\n  fst_snd_mem : (x₁, y₂) ∈ A\n  snd_fst_mem : (x₂, y₁) ∈ A\n  add_eq_add : x₁ + y₂ = x₂ + y₁\n\n"}
{"name":"IsCorner.fst_snd_mem","module":"Mathlib.Combinatorics.Additive.Corner.Defs","initialProofState":"G : Type u_1\ninst✝ : AddCommMonoid G\nA : Set (Prod G G)\nx₁ y₁ x₂ y₂ : G\nself : IsCorner A x₁ y₁ x₂ y₂\n⊢ Membership.mem A { fst := x₁, snd := y₂ }","decl":"/-- A **corner** of a set `A` in an abelian group is a triple of points of the form\n`(x, y), (x + d, y), (x, y + d)`. It is **nontrivial** if `d ≠ 0`.\n\nHere we define it as triples `(x₁, y₁), (x₂, y₁), (x₁, y₂)` where `x₁ + y₂ = x₂ + y₁` in order for\nthe definition to make sense in commutative monoids, the motivating example being `ℕ`. -/\n@[mk_iff]\nstructure IsCorner (A : Set (G × G)) (x₁ y₁ x₂ y₂ : G) : Prop where\n  fst_fst_mem : (x₁, y₁) ∈ A\n  fst_snd_mem : (x₁, y₂) ∈ A\n  snd_fst_mem : (x₂, y₁) ∈ A\n  add_eq_add : x₁ + y₂ = x₂ + y₁\n\n"}
{"name":"IsCorner.add_eq_add","module":"Mathlib.Combinatorics.Additive.Corner.Defs","initialProofState":"G : Type u_1\ninst✝ : AddCommMonoid G\nA : Set (Prod G G)\nx₁ y₁ x₂ y₂ : G\nself : IsCorner A x₁ y₁ x₂ y₂\n⊢ Eq (HAdd.hAdd x₁ y₂) (HAdd.hAdd x₂ y₁)","decl":"/-- A **corner** of a set `A` in an abelian group is a triple of points of the form\n`(x, y), (x + d, y), (x, y + d)`. It is **nontrivial** if `d ≠ 0`.\n\nHere we define it as triples `(x₁, y₁), (x₂, y₁), (x₁, y₂)` where `x₁ + y₂ = x₂ + y₁` in order for\nthe definition to make sense in commutative monoids, the motivating example being `ℕ`. -/\n@[mk_iff]\nstructure IsCorner (A : Set (G × G)) (x₁ y₁ x₂ y₂ : G) : Prop where\n  fst_fst_mem : (x₁, y₁) ∈ A\n  fst_snd_mem : (x₁, y₂) ∈ A\n  snd_fst_mem : (x₂, y₁) ∈ A\n  add_eq_add : x₁ + y₂ = x₂ + y₁\n\n"}
{"name":"IsCorner.snd_fst_mem","module":"Mathlib.Combinatorics.Additive.Corner.Defs","initialProofState":"G : Type u_1\ninst✝ : AddCommMonoid G\nA : Set (Prod G G)\nx₁ y₁ x₂ y₂ : G\nself : IsCorner A x₁ y₁ x₂ y₂\n⊢ Membership.mem A { fst := x₂, snd := y₁ }","decl":"/-- A **corner** of a set `A` in an abelian group is a triple of points of the form\n`(x, y), (x + d, y), (x, y + d)`. It is **nontrivial** if `d ≠ 0`.\n\nHere we define it as triples `(x₁, y₁), (x₂, y₁), (x₁, y₂)` where `x₁ + y₂ = x₂ + y₁` in order for\nthe definition to make sense in commutative monoids, the motivating example being `ℕ`. -/\n@[mk_iff]\nstructure IsCorner (A : Set (G × G)) (x₁ y₁ x₂ y₂ : G) : Prop where\n  fst_fst_mem : (x₁, y₁) ∈ A\n  fst_snd_mem : (x₁, y₂) ∈ A\n  snd_fst_mem : (x₂, y₁) ∈ A\n  add_eq_add : x₁ + y₂ = x₂ + y₁\n\n"}
{"name":"isCornerFree_iff","module":"Mathlib.Combinatorics.Additive.Corner.Defs","initialProofState":"G : Type u_1\ninst✝ : AddCommMonoid G\nA : Set (Prod G G)\ns : Set G\nhAs : HasSubset.Subset A (SProd.sprod s s)\n⊢ Iff (IsCornerFree A) (∀ ⦃x₁ : G⦄, Membership.mem s x₁ → ∀ ⦃y₁ : G⦄, Membership.mem s y₁ → ∀ ⦃x₂ : G⦄, Membership.mem s x₂ → ∀ ⦃y₂ : G⦄, Membership.mem s y₂ → IsCorner A x₁ y₁ x₂ y₂ → Eq x₁ x₂)","decl":"/-- A convenient restatement of corner-freeness in terms of an ambient product set. -/\nlemma isCornerFree_iff (hAs : A ⊆ s ×ˢ s) :\n    IsCornerFree A ↔ ∀ ⦃x₁⦄, x₁ ∈ s → ∀ ⦃y₁⦄, y₁ ∈ s → ∀ ⦃x₂⦄, x₂ ∈ s → ∀ ⦃y₂⦄, y₂ ∈ s →\n      IsCorner A x₁ y₁ x₂ y₂ → x₁ = x₂ where\n  mp hA _x₁ _ _y₁ _ _x₂ _ _y₂ _ hxy := hA hxy\n  mpr hA _x₁ _y₁ _x₂ _y₂ hxy := hA (hAs hxy.fst_fst_mem).1 (hAs hxy.fst_fst_mem).2\n    (hAs hxy.snd_fst_mem).1 (hAs hxy.fst_snd_mem).2 hxy\n\n"}
{"name":"IsCorner.mono","module":"Mathlib.Combinatorics.Additive.Corner.Defs","initialProofState":"G : Type u_1\ninst✝ : AddCommMonoid G\nA B : Set (Prod G G)\nx₁ y₁ x₂ y₂ : G\nhAB : HasSubset.Subset A B\nhA : IsCorner A x₁ y₁ x₂ y₂\n⊢ IsCorner B x₁ y₁ x₂ y₂","decl":"lemma IsCorner.mono (hAB : A ⊆ B) (hA : IsCorner A x₁ y₁ x₂ y₂) : IsCorner B x₁ y₁ x₂ y₂ where\n  fst_fst_mem := hAB hA.fst_fst_mem\n  fst_snd_mem := hAB hA.fst_snd_mem\n  snd_fst_mem := hAB hA.snd_fst_mem\n  add_eq_add := hA.add_eq_add\n\n"}
{"name":"IsCornerFree.mono","module":"Mathlib.Combinatorics.Additive.Corner.Defs","initialProofState":"G : Type u_1\ninst✝ : AddCommMonoid G\nA B : Set (Prod G G)\nhAB : HasSubset.Subset A B\nhB : IsCornerFree B\n⊢ IsCornerFree A","decl":"lemma IsCornerFree.mono (hAB : A ⊆ B) (hB : IsCornerFree B) : IsCornerFree A :=\n  fun _x₁ _y₁ _x₂ _y₂ hxyd ↦ hB <| hxyd.mono hAB\n\n"}
{"name":"not_isCorner_empty","module":"Mathlib.Combinatorics.Additive.Corner.Defs","initialProofState":"G : Type u_1\ninst✝ : AddCommMonoid G\nx₁ y₁ x₂ y₂ : G\n⊢ Not (IsCorner EmptyCollection.emptyCollection x₁ y₁ x₂ y₂)","decl":"@[simp] lemma not_isCorner_empty : ¬ IsCorner ∅ x₁ y₁ x₂ y₂ := by simp [isCorner_iff]\n\n"}
{"name":"Set.Subsingleton.isCornerFree","module":"Mathlib.Combinatorics.Additive.Corner.Defs","initialProofState":"G : Type u_1\ninst✝ : AddCommMonoid G\nA : Set (Prod G G)\nhA : A.Subsingleton\n⊢ IsCornerFree A","decl":"@[simp] lemma Set.Subsingleton.isCornerFree (hA : A.Subsingleton) : IsCornerFree A :=\n  fun _x₁ _y₁ _x₂ _y₂ hxyd ↦ by simpa using hA hxyd.fst_fst_mem hxyd.snd_fst_mem\n\n"}
{"name":"isCornerFree_empty","module":"Mathlib.Combinatorics.Additive.Corner.Defs","initialProofState":"G : Type u_1\ninst✝ : AddCommMonoid G\n⊢ IsCornerFree EmptyCollection.emptyCollection","decl":"lemma isCornerFree_empty : IsCornerFree (∅ : Set (G × G)) := subsingleton_empty.isCornerFree\n"}
{"name":"isCornerFree_singleton","module":"Mathlib.Combinatorics.Additive.Corner.Defs","initialProofState":"G : Type u_1\ninst✝ : AddCommMonoid G\nx : Prod G G\n⊢ IsCornerFree (Singleton.singleton x)","decl":"lemma isCornerFree_singleton (x : G × G) : IsCornerFree {x} := subsingleton_singleton.isCornerFree\n\n"}
{"name":"IsCorner.image","module":"Mathlib.Combinatorics.Additive.Corner.Defs","initialProofState":"G : Type u_1\nH : Type u_2\ninst✝¹ : AddCommMonoid G\ninst✝ : AddCommMonoid H\nA : Set (Prod G G)\ns : Set G\nt : Set H\nf : G → H\nx₁ y₁ x₂ y₂ : G\nhf : IsAddFreimanHom 2 s t f\nhAs : HasSubset.Subset A (SProd.sprod s s)\nhA : IsCorner A x₁ y₁ x₂ y₂\n⊢ IsCorner (Set.image (Prod.map f f) A) (f x₁) (f y₁) (f x₂) (f y₂)","decl":"/-- Corners are preserved under `2`-Freiman homomorphisms. --/\nlemma IsCorner.image (hf : IsAddFreimanHom 2 s t f) (hAs : (A : Set (G × G)) ⊆ s ×ˢ s)\n    (hA : IsCorner A x₁ y₁ x₂ y₂) : IsCorner (Prod.map f f '' A) (f x₁) (f y₁) (f x₂) (f y₂) := by\n  obtain ⟨hx₁y₁, hx₁y₂, hx₂y₁, hxy⟩ := hA\n  exact ⟨mem_image_of_mem _ hx₁y₁, mem_image_of_mem _ hx₁y₂, mem_image_of_mem _ hx₂y₁,\n    hf.add_eq_add (hAs hx₁y₁).1 (hAs hx₁y₂).2 (hAs hx₂y₁).1 (hAs hx₁y₁).2 hxy⟩\n\n"}
{"name":"IsCornerFree.of_image","module":"Mathlib.Combinatorics.Additive.Corner.Defs","initialProofState":"G : Type u_1\nH : Type u_2\ninst✝¹ : AddCommMonoid G\ninst✝ : AddCommMonoid H\nA : Set (Prod G G)\ns : Set G\nt : Set H\nf : G → H\nhf : IsAddFreimanHom 2 s t f\nhf' : Set.InjOn f s\nhAs : HasSubset.Subset A (SProd.sprod s s)\nhA : IsCornerFree (Set.image (Prod.map f f) A)\n⊢ IsCornerFree A","decl":"/-- Corners are preserved under `2`-Freiman homomorphisms. --/\nlemma IsCornerFree.of_image (hf : IsAddFreimanHom 2 s t f) (hf' : s.InjOn f)\n    (hAs : (A : Set (G × G)) ⊆ s ×ˢ s) (hA : IsCornerFree (Prod.map f f '' A)) : IsCornerFree A :=\n  fun _x₁ _y₁ _x₂ _y₂ hxy ↦\n    hf' (hAs hxy.fst_fst_mem).1 (hAs hxy.snd_fst_mem).1 <| hA <| hxy.image hf hAs\n\n"}
{"name":"isCorner_image","module":"Mathlib.Combinatorics.Additive.Corner.Defs","initialProofState":"G : Type u_1\nH : Type u_2\ninst✝¹ : AddCommMonoid G\ninst✝ : AddCommMonoid H\nA : Set (Prod G G)\ns : Set G\nt : Set H\nf : G → H\nx₁ y₁ x₂ y₂ : G\nhf : IsAddFreimanIso 2 s t f\nhAs : HasSubset.Subset A (SProd.sprod s s)\nhx₁ : Membership.mem s x₁\nhy₁ : Membership.mem s y₁\nhx₂ : Membership.mem s x₂\nhy₂ : Membership.mem s y₂\n⊢ Iff (IsCorner (Set.image (Prod.map f f) A) (f x₁) (f y₁) (f x₂) (f y₂)) (IsCorner A x₁ y₁ x₂ y₂)","decl":"lemma isCorner_image (hf : IsAddFreimanIso 2 s t f) (hAs : A ⊆ s ×ˢ s)\n    (hx₁ : x₁ ∈ s) (hy₁ : y₁ ∈ s) (hx₂ : x₂ ∈ s) (hy₂ : y₂ ∈ s) :\n    IsCorner (Prod.map f f '' A) (f x₁) (f y₁) (f x₂) (f y₂) ↔ IsCorner A x₁ y₁ x₂ y₂ := by\n  have hf' := hf.bijOn.injOn.prodMap hf.bijOn.injOn\n  rw [isCorner_iff, isCorner_iff]\n  congr!\n  · exact hf'.mem_image_iff hAs (mk_mem_prod hx₁ hy₁)\n  · exact hf'.mem_image_iff hAs (mk_mem_prod hx₁ hy₂)\n  · exact hf'.mem_image_iff hAs (mk_mem_prod hx₂ hy₁)\n  · exact hf.add_eq_add hx₁ hy₂ hx₂ hy₁\n\n"}
{"name":"isCornerFree_image","module":"Mathlib.Combinatorics.Additive.Corner.Defs","initialProofState":"G : Type u_1\nH : Type u_2\ninst✝¹ : AddCommMonoid G\ninst✝ : AddCommMonoid H\nA : Set (Prod G G)\ns : Set G\nt : Set H\nf : G → H\nhf : IsAddFreimanIso 2 s t f\nhAs : HasSubset.Subset A (SProd.sprod s s)\n⊢ Iff (IsCornerFree (Set.image (Prod.map f f) A)) (IsCornerFree A)","decl":"lemma isCornerFree_image (hf : IsAddFreimanIso 2 s t f) (hAs : A ⊆ s ×ˢ s) :\n    IsCornerFree (Prod.map f f '' A) ↔ IsCornerFree A := by\n  have : Prod.map f f '' A ⊆ t ×ˢ t :=\n    ((hf.bijOn.mapsTo.prodMap hf.bijOn.mapsTo).mono hAs Subset.rfl).image_subset\n  rw [isCornerFree_iff hAs, isCornerFree_iff this]\n  simp +contextual only [hf.bijOn.forall, isCorner_image hf hAs, hf.bijOn.injOn.eq_iff]\n\n"}
{"name":"IsCorner.of_image","module":"Mathlib.Combinatorics.Additive.Corner.Defs","initialProofState":"G : Type u_1\nH : Type u_2\ninst✝¹ : AddCommMonoid G\ninst✝ : AddCommMonoid H\nA : Set (Prod G G)\ns : Set G\nt : Set H\nf : G → H\nx₁ y₁ x₂ y₂ : G\nhf : IsAddFreimanIso 2 s t f\nhAs : HasSubset.Subset A (SProd.sprod s s)\nhx₁ : Membership.mem s x₁\nhy₁ : Membership.mem s y₁\nhx₂ : Membership.mem s x₂\nhy₂ : Membership.mem s y₂\na✝ : IsCorner (Set.image (Prod.map f f) A) (f x₁) (f y₁) (f x₂) (f y₂)\n⊢ IsCorner A x₁ y₁ x₂ y₂","decl":"alias ⟨IsCorner.of_image, _⟩ := isCorner_image\n"}
{"name":"IsCornerFree.image","module":"Mathlib.Combinatorics.Additive.Corner.Defs","initialProofState":"G : Type u_1\nH : Type u_2\ninst✝¹ : AddCommMonoid G\ninst✝ : AddCommMonoid H\nA : Set (Prod G G)\ns : Set G\nt : Set H\nf : G → H\nhf : IsAddFreimanIso 2 s t f\nhAs : HasSubset.Subset A (SProd.sprod s s)\na✝ : IsCornerFree A\n⊢ IsCornerFree (Set.image (Prod.map f f) A)","decl":"alias ⟨_, IsCornerFree.image⟩ := isCornerFree_image\n\n"}
