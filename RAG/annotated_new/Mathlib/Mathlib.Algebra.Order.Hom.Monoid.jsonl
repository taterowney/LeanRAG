{"name":"OrderAddMonoidHom.mk.inj","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"α : Type u_6\nβ : Type u_7\ninst✝³ : Preorder α\ninst✝² : Preorder β\ninst✝¹ : AddZeroClass α\ninst✝ : AddZeroClass β\ntoAddMonoidHom✝ : AddMonoidHom α β\nmonotone'✝ : Monotone (↑toAddMonoidHom✝).toFun\ntoAddMonoidHom : AddMonoidHom α β\nmonotone' : Monotone (↑toAddMonoidHom).toFun\nx✝ : Eq { toAddMonoidHom := toAddMonoidHom✝, monotone' := monotone'✝ } { toAddMonoidHom := toAddMonoidHom, monotone' := monotone' }\n⊢ Eq toAddMonoidHom✝ toAddMonoidHom","decl":"/-- `α →+o β` is the type of monotone functions `α → β` that preserve the `OrderedAddCommMonoid`\nstructure.\n\n`OrderAddMonoidHom` is also used for ordered group homomorphisms.\n\nWhen possible, instead of parametrizing results over `(f : α →+o β)`,\nyou should parametrize over\n`(F : Type*) [FunLike F M N] [MonoidHomClass F M N] [OrderHomClass F M N] (f : F)`. -/\nstructure OrderAddMonoidHom (α β : Type*) [Preorder α] [Preorder β] [AddZeroClass α]\n  [AddZeroClass β] extends α →+ β where\n  /-- An `OrderAddMonoidHom` is a monotone function. -/\n  monotone' : Monotone toFun\n\n"}
{"name":"OrderAddMonoidHom.monotone'","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"α : Type u_6\nβ : Type u_7\ninst✝³ : Preorder α\ninst✝² : Preorder β\ninst✝¹ : AddZeroClass α\ninst✝ : AddZeroClass β\nself : OrderAddMonoidHom α β\n⊢ Monotone (↑self.toAddMonoidHom).toFun","decl":"/-- `α →+o β` is the type of monotone functions `α → β` that preserve the `OrderedAddCommMonoid`\nstructure.\n\n`OrderAddMonoidHom` is also used for ordered group homomorphisms.\n\nWhen possible, instead of parametrizing results over `(f : α →+o β)`,\nyou should parametrize over\n`(F : Type*) [FunLike F M N] [MonoidHomClass F M N] [OrderHomClass F M N] (f : F)`. -/\nstructure OrderAddMonoidHom (α β : Type*) [Preorder α] [Preorder β] [AddZeroClass α]\n  [AddZeroClass β] extends α →+ β where\n  /-- An `OrderAddMonoidHom` is a monotone function. -/\n  monotone' : Monotone toFun\n\n"}
{"name":"OrderAddMonoidHom.mk.sizeOf_spec","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"α : Type u_6\nβ : Type u_7\ninst✝⁵ : Preorder α\ninst✝⁴ : Preorder β\ninst✝³ : AddZeroClass α\ninst✝² : AddZeroClass β\ninst✝¹ : SizeOf α\ninst✝ : SizeOf β\ntoAddMonoidHom : AddMonoidHom α β\nmonotone' : Monotone (↑toAddMonoidHom).toFun\n⊢ Eq (SizeOf.sizeOf { toAddMonoidHom := toAddMonoidHom, monotone' := monotone' }) (HAdd.hAdd 1 (SizeOf.sizeOf toAddMonoidHom))","decl":"/-- `α →+o β` is the type of monotone functions `α → β` that preserve the `OrderedAddCommMonoid`\nstructure.\n\n`OrderAddMonoidHom` is also used for ordered group homomorphisms.\n\nWhen possible, instead of parametrizing results over `(f : α →+o β)`,\nyou should parametrize over\n`(F : Type*) [FunLike F M N] [MonoidHomClass F M N] [OrderHomClass F M N] (f : F)`. -/\nstructure OrderAddMonoidHom (α β : Type*) [Preorder α] [Preorder β] [AddZeroClass α]\n  [AddZeroClass β] extends α →+ β where\n  /-- An `OrderAddMonoidHom` is a monotone function. -/\n  monotone' : Monotone toFun\n\n"}
{"name":"OrderAddMonoidHom.mk.injEq","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"α : Type u_6\nβ : Type u_7\ninst✝³ : Preorder α\ninst✝² : Preorder β\ninst✝¹ : AddZeroClass α\ninst✝ : AddZeroClass β\ntoAddMonoidHom✝ : AddMonoidHom α β\nmonotone'✝ : Monotone (↑toAddMonoidHom✝).toFun\ntoAddMonoidHom : AddMonoidHom α β\nmonotone' : Monotone (↑toAddMonoidHom).toFun\n⊢ Eq (Eq { toAddMonoidHom := toAddMonoidHom✝, monotone' := monotone'✝ } { toAddMonoidHom := toAddMonoidHom, monotone' := monotone' }) (Eq toAddMonoidHom✝ toAddMonoidHom)","decl":"/-- `α →+o β` is the type of monotone functions `α → β` that preserve the `OrderedAddCommMonoid`\nstructure.\n\n`OrderAddMonoidHom` is also used for ordered group homomorphisms.\n\nWhen possible, instead of parametrizing results over `(f : α →+o β)`,\nyou should parametrize over\n`(F : Type*) [FunLike F M N] [MonoidHomClass F M N] [OrderHomClass F M N] (f : F)`. -/\nstructure OrderAddMonoidHom (α β : Type*) [Preorder α] [Preorder β] [AddZeroClass α]\n  [AddZeroClass β] extends α →+ β where\n  /-- An `OrderAddMonoidHom` is a monotone function. -/\n  monotone' : Monotone toFun\n\n"}
{"name":"OrderAddMonoidIso.mk.sizeOf_spec","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"α : Type u_6\nβ : Type u_7\ninst✝⁵ : Preorder α\ninst✝⁴ : Preorder β\ninst✝³ : Add α\ninst✝² : Add β\ninst✝¹ : SizeOf α\ninst✝ : SizeOf β\ntoAddEquiv : AddEquiv α β\nmap_le_map_iff' : ∀ {a b : α}, Iff (LE.le (toAddEquiv.toFun a) (toAddEquiv.toFun b)) (LE.le a b)\n⊢ Eq (SizeOf.sizeOf { toAddEquiv := toAddEquiv, map_le_map_iff' := map_le_map_iff' }) (HAdd.hAdd 1 (SizeOf.sizeOf toAddEquiv))","decl":"/-- `α ≃+o β` is the type of monotone isomorphisms `α ≃ β` that preserve the `OrderedAddCommMonoid`\nstructure.\n\n`OrderAddMonoidIso` is also used for ordered group isomorphisms.\n\nWhen possible, instead of parametrizing results over `(f : α ≃+o β)`,\nyou should parametrize over\n`(F : Type*) [FunLike F M N] [AddEquivClass F M N] [OrderIsoClass F M N] (f : F)`. -/\nstructure OrderAddMonoidIso (α β : Type*) [Preorder α] [Preorder β] [Add α] [Add β]\n  extends α ≃+ β where\n  /-- An `OrderAddMonoidIso` respects `≤`. -/\n  map_le_map_iff' {a b : α} : toFun a ≤ toFun b ↔ a ≤ b\n\n"}
{"name":"OrderAddMonoidIso.mk.inj","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"α : Type u_6\nβ : Type u_7\ninst✝³ : Preorder α\ninst✝² : Preorder β\ninst✝¹ : Add α\ninst✝ : Add β\ntoAddEquiv✝ : AddEquiv α β\nmap_le_map_iff'✝ : ∀ {a b : α}, Iff (LE.le (toAddEquiv✝.toFun a) (toAddEquiv✝.toFun b)) (LE.le a b)\ntoAddEquiv : AddEquiv α β\nmap_le_map_iff' : ∀ {a b : α}, Iff (LE.le (toAddEquiv.toFun a) (toAddEquiv.toFun b)) (LE.le a b)\nx✝ : Eq { toAddEquiv := toAddEquiv✝, map_le_map_iff' := map_le_map_iff'✝ } { toAddEquiv := toAddEquiv, map_le_map_iff' := map_le_map_iff' }\n⊢ Eq toAddEquiv✝ toAddEquiv","decl":"/-- `α ≃+o β` is the type of monotone isomorphisms `α ≃ β` that preserve the `OrderedAddCommMonoid`\nstructure.\n\n`OrderAddMonoidIso` is also used for ordered group isomorphisms.\n\nWhen possible, instead of parametrizing results over `(f : α ≃+o β)`,\nyou should parametrize over\n`(F : Type*) [FunLike F M N] [AddEquivClass F M N] [OrderIsoClass F M N] (f : F)`. -/\nstructure OrderAddMonoidIso (α β : Type*) [Preorder α] [Preorder β] [Add α] [Add β]\n  extends α ≃+ β where\n  /-- An `OrderAddMonoidIso` respects `≤`. -/\n  map_le_map_iff' {a b : α} : toFun a ≤ toFun b ↔ a ≤ b\n\n"}
{"name":"OrderAddMonoidIso.mk.injEq","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"α : Type u_6\nβ : Type u_7\ninst✝³ : Preorder α\ninst✝² : Preorder β\ninst✝¹ : Add α\ninst✝ : Add β\ntoAddEquiv✝ : AddEquiv α β\nmap_le_map_iff'✝ : ∀ {a b : α}, Iff (LE.le (toAddEquiv✝.toFun a) (toAddEquiv✝.toFun b)) (LE.le a b)\ntoAddEquiv : AddEquiv α β\nmap_le_map_iff' : ∀ {a b : α}, Iff (LE.le (toAddEquiv.toFun a) (toAddEquiv.toFun b)) (LE.le a b)\n⊢ Eq (Eq { toAddEquiv := toAddEquiv✝, map_le_map_iff' := map_le_map_iff'✝ } { toAddEquiv := toAddEquiv, map_le_map_iff' := map_le_map_iff' }) (Eq toAddEquiv✝ toAddEquiv)","decl":"/-- `α ≃+o β` is the type of monotone isomorphisms `α ≃ β` that preserve the `OrderedAddCommMonoid`\nstructure.\n\n`OrderAddMonoidIso` is also used for ordered group isomorphisms.\n\nWhen possible, instead of parametrizing results over `(f : α ≃+o β)`,\nyou should parametrize over\n`(F : Type*) [FunLike F M N] [AddEquivClass F M N] [OrderIsoClass F M N] (f : F)`. -/\nstructure OrderAddMonoidIso (α β : Type*) [Preorder α] [Preorder β] [Add α] [Add β]\n  extends α ≃+ β where\n  /-- An `OrderAddMonoidIso` respects `≤`. -/\n  map_le_map_iff' {a b : α} : toFun a ≤ toFun b ↔ a ≤ b\n\n"}
{"name":"OrderAddMonoidIso.map_le_map_iff'","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"α : Type u_6\nβ : Type u_7\ninst✝³ : Preorder α\ninst✝² : Preorder β\ninst✝¹ : Add α\ninst✝ : Add β\nself : OrderAddMonoidIso α β\na b : α\n⊢ Iff (LE.le (self.toFun a) (self.toFun b)) (LE.le a b)","decl":"/-- `α ≃+o β` is the type of monotone isomorphisms `α ≃ β` that preserve the `OrderedAddCommMonoid`\nstructure.\n\n`OrderAddMonoidIso` is also used for ordered group isomorphisms.\n\nWhen possible, instead of parametrizing results over `(f : α ≃+o β)`,\nyou should parametrize over\n`(F : Type*) [FunLike F M N] [AddEquivClass F M N] [OrderIsoClass F M N] (f : F)`. -/\nstructure OrderAddMonoidIso (α β : Type*) [Preorder α] [Preorder β] [Add α] [Add β]\n  extends α ≃+ β where\n  /-- An `OrderAddMonoidIso` respects `≤`. -/\n  map_le_map_iff' {a b : α} : toFun a ≤ toFun b ↔ a ≤ b\n\n"}
{"name":"OrderMonoidHom.monotone'","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"α : Type u_6\nβ : Type u_7\ninst✝³ : Preorder α\ninst✝² : Preorder β\ninst✝¹ : MulOneClass α\ninst✝ : MulOneClass β\nself : OrderMonoidHom α β\n⊢ Monotone (↑self.toMonoidHom).toFun","decl":"/-- `α →*o β` is the type of functions `α → β` that preserve the `OrderedCommMonoid` structure.\n\n`OrderMonoidHom` is also used for ordered group homomorphisms.\n\nWhen possible, instead of parametrizing results over `(f : α →*o β)`,\nyou should parametrize over\n`(F : Type*) [FunLike F M N] [MonoidHomClass F M N] [OrderHomClass F M N] (f : F)`. -/\n@[to_additive]\nstructure OrderMonoidHom (α β : Type*) [Preorder α] [Preorder β] [MulOneClass α]\n  [MulOneClass β] extends α →* β where\n  /-- An `OrderMonoidHom` is a monotone function. -/\n  monotone' : Monotone toFun\n\n"}
{"name":"OrderMonoidHom.mk.sizeOf_spec","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"α : Type u_6\nβ : Type u_7\ninst✝⁵ : Preorder α\ninst✝⁴ : Preorder β\ninst✝³ : MulOneClass α\ninst✝² : MulOneClass β\ninst✝¹ : SizeOf α\ninst✝ : SizeOf β\ntoMonoidHom : MonoidHom α β\nmonotone' : Monotone (↑toMonoidHom).toFun\n⊢ Eq (SizeOf.sizeOf { toMonoidHom := toMonoidHom, monotone' := monotone' }) (HAdd.hAdd 1 (SizeOf.sizeOf toMonoidHom))","decl":"/-- `α →*o β` is the type of functions `α → β` that preserve the `OrderedCommMonoid` structure.\n\n`OrderMonoidHom` is also used for ordered group homomorphisms.\n\nWhen possible, instead of parametrizing results over `(f : α →*o β)`,\nyou should parametrize over\n`(F : Type*) [FunLike F M N] [MonoidHomClass F M N] [OrderHomClass F M N] (f : F)`. -/\n@[to_additive]\nstructure OrderMonoidHom (α β : Type*) [Preorder α] [Preorder β] [MulOneClass α]\n  [MulOneClass β] extends α →* β where\n  /-- An `OrderMonoidHom` is a monotone function. -/\n  monotone' : Monotone toFun\n\n"}
{"name":"OrderMonoidHom.mk.injEq","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"α : Type u_6\nβ : Type u_7\ninst✝³ : Preorder α\ninst✝² : Preorder β\ninst✝¹ : MulOneClass α\ninst✝ : MulOneClass β\ntoMonoidHom✝ : MonoidHom α β\nmonotone'✝ : Monotone (↑toMonoidHom✝).toFun\ntoMonoidHom : MonoidHom α β\nmonotone' : Monotone (↑toMonoidHom).toFun\n⊢ Eq (Eq { toMonoidHom := toMonoidHom✝, monotone' := monotone'✝ } { toMonoidHom := toMonoidHom, monotone' := monotone' }) (Eq toMonoidHom✝ toMonoidHom)","decl":"/-- `α →*o β` is the type of functions `α → β` that preserve the `OrderedCommMonoid` structure.\n\n`OrderMonoidHom` is also used for ordered group homomorphisms.\n\nWhen possible, instead of parametrizing results over `(f : α →*o β)`,\nyou should parametrize over\n`(F : Type*) [FunLike F M N] [MonoidHomClass F M N] [OrderHomClass F M N] (f : F)`. -/\n@[to_additive]\nstructure OrderMonoidHom (α β : Type*) [Preorder α] [Preorder β] [MulOneClass α]\n  [MulOneClass β] extends α →* β where\n  /-- An `OrderMonoidHom` is a monotone function. -/\n  monotone' : Monotone toFun\n\n"}
{"name":"OrderMonoidHom.mk.inj","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"α : Type u_6\nβ : Type u_7\ninst✝³ : Preorder α\ninst✝² : Preorder β\ninst✝¹ : MulOneClass α\ninst✝ : MulOneClass β\ntoMonoidHom✝ : MonoidHom α β\nmonotone'✝ : Monotone (↑toMonoidHom✝).toFun\ntoMonoidHom : MonoidHom α β\nmonotone' : Monotone (↑toMonoidHom).toFun\nx✝ : Eq { toMonoidHom := toMonoidHom✝, monotone' := monotone'✝ } { toMonoidHom := toMonoidHom, monotone' := monotone' }\n⊢ Eq toMonoidHom✝ toMonoidHom","decl":"/-- `α →*o β` is the type of functions `α → β` that preserve the `OrderedCommMonoid` structure.\n\n`OrderMonoidHom` is also used for ordered group homomorphisms.\n\nWhen possible, instead of parametrizing results over `(f : α →*o β)`,\nyou should parametrize over\n`(F : Type*) [FunLike F M N] [MonoidHomClass F M N] [OrderHomClass F M N] (f : F)`. -/\n@[to_additive]\nstructure OrderMonoidHom (α β : Type*) [Preorder α] [Preorder β] [MulOneClass α]\n  [MulOneClass β] extends α →* β where\n  /-- An `OrderMonoidHom` is a monotone function. -/\n  monotone' : Monotone toFun\n\n"}
{"name":"OrderMonoidIso.mk.inj","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"α : Type u_6\nβ : Type u_7\ninst✝³ : Preorder α\ninst✝² : Preorder β\ninst✝¹ : Mul α\ninst✝ : Mul β\ntoMulEquiv✝ : MulEquiv α β\nmap_le_map_iff'✝ : ∀ {a b : α}, Iff (LE.le (toMulEquiv✝.toFun a) (toMulEquiv✝.toFun b)) (LE.le a b)\ntoMulEquiv : MulEquiv α β\nmap_le_map_iff' : ∀ {a b : α}, Iff (LE.le (toMulEquiv.toFun a) (toMulEquiv.toFun b)) (LE.le a b)\nx✝ : Eq { toMulEquiv := toMulEquiv✝, map_le_map_iff' := map_le_map_iff'✝ } { toMulEquiv := toMulEquiv, map_le_map_iff' := map_le_map_iff' }\n⊢ Eq toMulEquiv✝ toMulEquiv","decl":"/-- `α ≃*o β` is the type of isomorphisms `α ≃ β` that preserve the `OrderedCommMonoid` structure.\n\n`OrderMonoidIso` is also used for ordered group isomorphisms.\n\nWhen possible, instead of parametrizing results over `(f : α ≃*o β)`,\nyou should parametrize over\n`(F : Type*) [FunLike F M N] [MulEquivClass F M N] [OrderIsoClass F M N] (f : F)`. -/\n@[to_additive]\nstructure OrderMonoidIso (α β : Type*) [Preorder α] [Preorder β] [Mul α] [Mul β]\n  extends α ≃* β where\n  /-- An `OrderMonoidIso` respects `≤`. -/\n  map_le_map_iff' {a b : α} : toFun a ≤ toFun b ↔ a ≤ b\n\n"}
{"name":"OrderMonoidIso.mk.sizeOf_spec","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"α : Type u_6\nβ : Type u_7\ninst✝⁵ : Preorder α\ninst✝⁴ : Preorder β\ninst✝³ : Mul α\ninst✝² : Mul β\ninst✝¹ : SizeOf α\ninst✝ : SizeOf β\ntoMulEquiv : MulEquiv α β\nmap_le_map_iff' : ∀ {a b : α}, Iff (LE.le (toMulEquiv.toFun a) (toMulEquiv.toFun b)) (LE.le a b)\n⊢ Eq (SizeOf.sizeOf { toMulEquiv := toMulEquiv, map_le_map_iff' := map_le_map_iff' }) (HAdd.hAdd 1 (SizeOf.sizeOf toMulEquiv))","decl":"/-- `α ≃*o β` is the type of isomorphisms `α ≃ β` that preserve the `OrderedCommMonoid` structure.\n\n`OrderMonoidIso` is also used for ordered group isomorphisms.\n\nWhen possible, instead of parametrizing results over `(f : α ≃*o β)`,\nyou should parametrize over\n`(F : Type*) [FunLike F M N] [MulEquivClass F M N] [OrderIsoClass F M N] (f : F)`. -/\n@[to_additive]\nstructure OrderMonoidIso (α β : Type*) [Preorder α] [Preorder β] [Mul α] [Mul β]\n  extends α ≃* β where\n  /-- An `OrderMonoidIso` respects `≤`. -/\n  map_le_map_iff' {a b : α} : toFun a ≤ toFun b ↔ a ≤ b\n\n"}
{"name":"OrderMonoidIso.mk.injEq","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"α : Type u_6\nβ : Type u_7\ninst✝³ : Preorder α\ninst✝² : Preorder β\ninst✝¹ : Mul α\ninst✝ : Mul β\ntoMulEquiv✝ : MulEquiv α β\nmap_le_map_iff'✝ : ∀ {a b : α}, Iff (LE.le (toMulEquiv✝.toFun a) (toMulEquiv✝.toFun b)) (LE.le a b)\ntoMulEquiv : MulEquiv α β\nmap_le_map_iff' : ∀ {a b : α}, Iff (LE.le (toMulEquiv.toFun a) (toMulEquiv.toFun b)) (LE.le a b)\n⊢ Eq (Eq { toMulEquiv := toMulEquiv✝, map_le_map_iff' := map_le_map_iff'✝ } { toMulEquiv := toMulEquiv, map_le_map_iff' := map_le_map_iff' }) (Eq toMulEquiv✝ toMulEquiv)","decl":"/-- `α ≃*o β` is the type of isomorphisms `α ≃ β` that preserve the `OrderedCommMonoid` structure.\n\n`OrderMonoidIso` is also used for ordered group isomorphisms.\n\nWhen possible, instead of parametrizing results over `(f : α ≃*o β)`,\nyou should parametrize over\n`(F : Type*) [FunLike F M N] [MulEquivClass F M N] [OrderIsoClass F M N] (f : F)`. -/\n@[to_additive]\nstructure OrderMonoidIso (α β : Type*) [Preorder α] [Preorder β] [Mul α] [Mul β]\n  extends α ≃* β where\n  /-- An `OrderMonoidIso` respects `≤`. -/\n  map_le_map_iff' {a b : α} : toFun a ≤ toFun b ↔ a ≤ b\n\n"}
{"name":"OrderMonoidIso.map_le_map_iff'","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"α : Type u_6\nβ : Type u_7\ninst✝³ : Preorder α\ninst✝² : Preorder β\ninst✝¹ : Mul α\ninst✝ : Mul β\nself : OrderMonoidIso α β\na b : α\n⊢ Iff (LE.le (self.toFun a) (self.toFun b)) (LE.le a b)","decl":"/-- `α ≃*o β` is the type of isomorphisms `α ≃ β` that preserve the `OrderedCommMonoid` structure.\n\n`OrderMonoidIso` is also used for ordered group isomorphisms.\n\nWhen possible, instead of parametrizing results over `(f : α ≃*o β)`,\nyou should parametrize over\n`(F : Type*) [FunLike F M N] [MulEquivClass F M N] [OrderIsoClass F M N] (f : F)`. -/\n@[to_additive]\nstructure OrderMonoidIso (α β : Type*) [Preorder α] [Preorder β] [Mul α] [Mul β]\n  extends α ≃* β where\n  /-- An `OrderMonoidIso` respects `≤`. -/\n  map_le_map_iff' {a b : α} : toFun a ≤ toFun b ↔ a ≤ b\n\n"}
{"name":"OrderMonoidWithZeroHom.monotone'","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"α : Type u_6\nβ : Type u_7\ninst✝³ : Preorder α\ninst✝² : Preorder β\ninst✝¹ : MulZeroOneClass α\ninst✝ : MulZeroOneClass β\nself : OrderMonoidWithZeroHom α β\n⊢ Monotone (↑self.toMonoidWithZeroHom).toFun","decl":"/-- `OrderMonoidWithZeroHom α β` is the type of functions `α → β` that preserve\nthe `MonoidWithZero` structure.\n\n`OrderMonoidWithZeroHom` is also used for group homomorphisms.\n\nWhen possible, instead of parametrizing results over `(f : α →+ β)`,\nyou should parameterize over\n`(F : Type*) [FunLike F M N] [MonoidWithZeroHomClass F M N] [OrderHomClass F M N] (f : F)`. -/\nstructure OrderMonoidWithZeroHom (α β : Type*) [Preorder α] [Preorder β] [MulZeroOneClass α]\n  [MulZeroOneClass β] extends α →*₀ β where\n  /-- An `OrderMonoidWithZeroHom` is a monotone function. -/\n  monotone' : Monotone toFun\n\n"}
{"name":"OrderMonoidWithZeroHom.mk.inj","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"α : Type u_6\nβ : Type u_7\ninst✝³ : Preorder α\ninst✝² : Preorder β\ninst✝¹ : MulZeroOneClass α\ninst✝ : MulZeroOneClass β\ntoMonoidWithZeroHom✝ : MonoidWithZeroHom α β\nmonotone'✝ : Monotone (↑toMonoidWithZeroHom✝).toFun\ntoMonoidWithZeroHom : MonoidWithZeroHom α β\nmonotone' : Monotone (↑toMonoidWithZeroHom).toFun\nx✝ : Eq { toMonoidWithZeroHom := toMonoidWithZeroHom✝, monotone' := monotone'✝ } { toMonoidWithZeroHom := toMonoidWithZeroHom, monotone' := monotone' }\n⊢ Eq toMonoidWithZeroHom✝ toMonoidWithZeroHom","decl":"/-- `OrderMonoidWithZeroHom α β` is the type of functions `α → β` that preserve\nthe `MonoidWithZero` structure.\n\n`OrderMonoidWithZeroHom` is also used for group homomorphisms.\n\nWhen possible, instead of parametrizing results over `(f : α →+ β)`,\nyou should parameterize over\n`(F : Type*) [FunLike F M N] [MonoidWithZeroHomClass F M N] [OrderHomClass F M N] (f : F)`. -/\nstructure OrderMonoidWithZeroHom (α β : Type*) [Preorder α] [Preorder β] [MulZeroOneClass α]\n  [MulZeroOneClass β] extends α →*₀ β where\n  /-- An `OrderMonoidWithZeroHom` is a monotone function. -/\n  monotone' : Monotone toFun\n\n"}
{"name":"OrderMonoidWithZeroHom.mk.injEq","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"α : Type u_6\nβ : Type u_7\ninst✝³ : Preorder α\ninst✝² : Preorder β\ninst✝¹ : MulZeroOneClass α\ninst✝ : MulZeroOneClass β\ntoMonoidWithZeroHom✝ : MonoidWithZeroHom α β\nmonotone'✝ : Monotone (↑toMonoidWithZeroHom✝).toFun\ntoMonoidWithZeroHom : MonoidWithZeroHom α β\nmonotone' : Monotone (↑toMonoidWithZeroHom).toFun\n⊢ Eq (Eq { toMonoidWithZeroHom := toMonoidWithZeroHom✝, monotone' := monotone'✝ } { toMonoidWithZeroHom := toMonoidWithZeroHom, monotone' := monotone' }) (Eq toMonoidWithZeroHom✝ toMonoidWithZeroHom)","decl":"/-- `OrderMonoidWithZeroHom α β` is the type of functions `α → β` that preserve\nthe `MonoidWithZero` structure.\n\n`OrderMonoidWithZeroHom` is also used for group homomorphisms.\n\nWhen possible, instead of parametrizing results over `(f : α →+ β)`,\nyou should parameterize over\n`(F : Type*) [FunLike F M N] [MonoidWithZeroHomClass F M N] [OrderHomClass F M N] (f : F)`. -/\nstructure OrderMonoidWithZeroHom (α β : Type*) [Preorder α] [Preorder β] [MulZeroOneClass α]\n  [MulZeroOneClass β] extends α →*₀ β where\n  /-- An `OrderMonoidWithZeroHom` is a monotone function. -/\n  monotone' : Monotone toFun\n\n"}
{"name":"OrderMonoidWithZeroHom.mk.sizeOf_spec","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"α : Type u_6\nβ : Type u_7\ninst✝⁵ : Preorder α\ninst✝⁴ : Preorder β\ninst✝³ : MulZeroOneClass α\ninst✝² : MulZeroOneClass β\ninst✝¹ : SizeOf α\ninst✝ : SizeOf β\ntoMonoidWithZeroHom : MonoidWithZeroHom α β\nmonotone' : Monotone (↑toMonoidWithZeroHom).toFun\n⊢ Eq (SizeOf.sizeOf { toMonoidWithZeroHom := toMonoidWithZeroHom, monotone' := monotone' }) (HAdd.hAdd 1 (SizeOf.sizeOf toMonoidWithZeroHom))","decl":"/-- `OrderMonoidWithZeroHom α β` is the type of functions `α → β` that preserve\nthe `MonoidWithZero` structure.\n\n`OrderMonoidWithZeroHom` is also used for group homomorphisms.\n\nWhen possible, instead of parametrizing results over `(f : α →+ β)`,\nyou should parameterize over\n`(F : Type*) [FunLike F M N] [MonoidWithZeroHomClass F M N] [OrderHomClass F M N] (f : F)`. -/\nstructure OrderMonoidWithZeroHom (α β : Type*) [Preorder α] [Preorder β] [MulZeroOneClass α]\n  [MulZeroOneClass β] extends α →*₀ β where\n  /-- An `OrderMonoidWithZeroHom` is a monotone function. -/\n  monotone' : Monotone toFun\n\n"}
{"name":"map_nonneg","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"F : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝⁶ : FunLike F α β\ninst✝⁵ : Preorder α\ninst✝⁴ : Zero α\ninst✝³ : Preorder β\ninst✝² : Zero β\ninst✝¹ : OrderHomClass F α β\ninst✝ : ZeroHomClass F α β\nf : F\na : α\nha : LE.le 0 a\n⊢ LE.le 0 (f a)","decl":"/-- See also `NonnegHomClass.apply_nonneg`. -/\ntheorem map_nonneg (ha : 0 ≤ a) : 0 ≤ f a := by\n  rw [← map_zero f]\n  exact OrderHomClass.mono _ ha\n\n"}
{"name":"map_nonpos","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"F : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝⁶ : FunLike F α β\ninst✝⁵ : Preorder α\ninst✝⁴ : Zero α\ninst✝³ : Preorder β\ninst✝² : Zero β\ninst✝¹ : OrderHomClass F α β\ninst✝ : ZeroHomClass F α β\nf : F\na : α\nha : LE.le a 0\n⊢ LE.le (f a) 0","decl":"theorem map_nonpos (ha : a ≤ 0) : f a ≤ 0 := by\n  rw [← map_zero f]\n  exact OrderHomClass.mono _ ha\n\n"}
{"name":"monotone_iff_map_nonneg","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"F : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝¹ : OrderedAddCommGroup α\ninst✝ : OrderedAddCommMonoid β\ni : FunLike F α β\nf : F\niamhc : AddMonoidHomClass F α β\n⊢ Iff (Monotone ⇑f) (∀ (a : α), LE.le 0 a → LE.le 0 (f a))","decl":"theorem monotone_iff_map_nonneg [iamhc : AddMonoidHomClass F α β] :\n    Monotone (f : α → β) ↔ ∀ a, 0 ≤ a → 0 ≤ f a :=\n  ⟨fun h a => by\n    rw [← map_zero f]\n    apply h, fun h a b hl => by\n    rw [← sub_add_cancel b a, map_add f]\n    exact le_add_of_nonneg_left (h _ <| sub_nonneg.2 hl)⟩\n\n"}
{"name":"antitone_iff_map_nonpos","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"F : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝¹ : OrderedAddCommGroup α\ninst✝ : OrderedAddCommMonoid β\ni : FunLike F α β\nf : F\niamhc : AddMonoidHomClass F α β\n⊢ Iff (Antitone ⇑f) (∀ (a : α), LE.le 0 a → LE.le (f a) 0)","decl":"theorem antitone_iff_map_nonpos : Antitone (f : α → β) ↔ ∀ a, 0 ≤ a → f a ≤ 0 :=\n  monotone_toDual_comp_iff.symm.trans <| monotone_iff_map_nonneg (β := βᵒᵈ) (iamhc := iamhc) _\n\n"}
{"name":"monotone_iff_map_nonpos","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"F : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝¹ : OrderedAddCommGroup α\ninst✝ : OrderedAddCommMonoid β\ni : FunLike F α β\nf : F\niamhc : AddMonoidHomClass F α β\n⊢ Iff (Monotone ⇑f) (∀ (a : α), LE.le a 0 → LE.le (f a) 0)","decl":"theorem monotone_iff_map_nonpos : Monotone (f : α → β) ↔ ∀ a ≤ 0, f a ≤ 0 :=\n  antitone_comp_ofDual_iff.symm.trans <| antitone_iff_map_nonpos (α := αᵒᵈ) (iamhc := iamhc) _\n\n"}
{"name":"antitone_iff_map_nonneg","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"F : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝¹ : OrderedAddCommGroup α\ninst✝ : OrderedAddCommMonoid β\ni : FunLike F α β\nf : F\niamhc : AddMonoidHomClass F α β\n⊢ Iff (Antitone ⇑f) (∀ (a : α), LE.le a 0 → LE.le 0 (f a))","decl":"theorem antitone_iff_map_nonneg : Antitone (f : α → β) ↔ ∀ a ≤ 0, 0 ≤ f a :=\n  monotone_comp_ofDual_iff.symm.trans <| monotone_iff_map_nonneg (α := αᵒᵈ) (iamhc := iamhc) _\n\n"}
{"name":"strictMono_iff_map_pos","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"F : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝² : OrderedAddCommGroup α\ninst✝¹ : OrderedAddCommMonoid β\ni : FunLike F α β\nf : F\niamhc : AddMonoidHomClass F α β\ninst✝ : AddLeftStrictMono β\n⊢ Iff (StrictMono ⇑f) (∀ (a : α), LT.lt 0 a → LT.lt 0 (f a))","decl":"theorem strictMono_iff_map_pos :\n    StrictMono (f : α → β) ↔ ∀ a, 0 < a → 0 < f a := by\n  refine ⟨fun h a => ?_, fun h a b hl => ?_⟩\n  · rw [← map_zero f]\n    apply h\n  · rw [← sub_add_cancel b a, map_add f]\n    exact lt_add_of_pos_left _ (h _ <| sub_pos.2 hl)\n\n"}
{"name":"strictAnti_iff_map_neg","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"F : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝² : OrderedAddCommGroup α\ninst✝¹ : OrderedAddCommMonoid β\ni : FunLike F α β\nf : F\niamhc : AddMonoidHomClass F α β\ninst✝ : AddLeftStrictMono β\n⊢ Iff (StrictAnti ⇑f) (∀ (a : α), LT.lt 0 a → LT.lt (f a) 0)","decl":"theorem strictAnti_iff_map_neg : StrictAnti (f : α → β) ↔ ∀ a, 0 < a → f a < 0 :=\n  strictMono_toDual_comp_iff.symm.trans <| strictMono_iff_map_pos (β := βᵒᵈ) (iamhc := iamhc) _\n\n"}
{"name":"strictMono_iff_map_neg","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"F : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝² : OrderedAddCommGroup α\ninst✝¹ : OrderedAddCommMonoid β\ni : FunLike F α β\nf : F\niamhc : AddMonoidHomClass F α β\ninst✝ : AddLeftStrictMono β\n⊢ Iff (StrictMono ⇑f) (∀ (a : α), LT.lt a 0 → LT.lt (f a) 0)","decl":"theorem strictMono_iff_map_neg : StrictMono (f : α → β) ↔ ∀ a < 0, f a < 0 :=\n  strictAnti_comp_ofDual_iff.symm.trans <| strictAnti_iff_map_neg (α := αᵒᵈ) (iamhc := iamhc) _\n\n"}
{"name":"strictAnti_iff_map_pos","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"F : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝² : OrderedAddCommGroup α\ninst✝¹ : OrderedAddCommMonoid β\ni : FunLike F α β\nf : F\niamhc : AddMonoidHomClass F α β\ninst✝ : AddLeftStrictMono β\n⊢ Iff (StrictAnti ⇑f) (∀ (a : α), LT.lt a 0 → LT.lt 0 (f a))","decl":"theorem strictAnti_iff_map_pos : StrictAnti (f : α → β) ↔ ∀ a < 0, 0 < f a :=\n  strictMono_comp_ofDual_iff.symm.trans <| strictMono_iff_map_pos (α := αᵒᵈ) (iamhc := iamhc) _\n\n"}
{"name":"OrderMonoidHom.instOrderHomClass","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : Preorder α\ninst✝² : Preorder β\ninst✝¹ : MulOneClass α\ninst✝ : MulOneClass β\n⊢ OrderHomClass (OrderMonoidHom α β) α β","decl":"@[to_additive]\ninstance : OrderHomClass (α →*o β) α β where\n  map_rel f _ _ h := f.monotone' h\n\n"}
{"name":"OrderAddMonoidHom.instOrderHomClass","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : Preorder α\ninst✝² : Preorder β\ninst✝¹ : AddZeroClass α\ninst✝ : AddZeroClass β\n⊢ OrderHomClass (OrderAddMonoidHom α β) α β","decl":"@[to_additive]\ninstance : OrderHomClass (α →*o β) α β where\n  map_rel f _ _ h := f.monotone' h\n\n"}
{"name":"OrderAddMonoidHom.instAddMonoidHomClass","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : Preorder α\ninst✝² : Preorder β\ninst✝¹ : AddZeroClass α\ninst✝ : AddZeroClass β\n⊢ AddMonoidHomClass (OrderAddMonoidHom α β) α β","decl":"@[to_additive]\ninstance : MonoidHomClass (α →*o β) α β where\n  map_mul f := f.map_mul'\n  map_one f := f.map_one'\n\n-- Other lemmas should be accessed through the `FunLike` API\n"}
{"name":"OrderMonoidHom.instMonoidHomClass","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : Preorder α\ninst✝² : Preorder β\ninst✝¹ : MulOneClass α\ninst✝ : MulOneClass β\n⊢ MonoidHomClass (OrderMonoidHom α β) α β","decl":"@[to_additive]\ninstance : MonoidHomClass (α →*o β) α β where\n  map_mul f := f.map_mul'\n  map_one f := f.map_one'\n\n-- Other lemmas should be accessed through the `FunLike` API\n"}
{"name":"OrderMonoidHom.ext_iff","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : Preorder α\ninst✝² : Preorder β\ninst✝¹ : MulOneClass α\ninst✝ : MulOneClass β\nf g : OrderMonoidHom α β\n⊢ Iff (Eq f g) (∀ (a : α), Eq (f a) (g a))","decl":"@[to_additive (attr := ext)]\ntheorem ext (h : ∀ a, f a = g a) : f = g :=\n  DFunLike.ext f g h\n\n"}
{"name":"OrderMonoidHom.ext","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : Preorder α\ninst✝² : Preorder β\ninst✝¹ : MulOneClass α\ninst✝ : MulOneClass β\nf g : OrderMonoidHom α β\nh : ∀ (a : α), Eq (f a) (g a)\n⊢ Eq f g","decl":"@[to_additive (attr := ext)]\ntheorem ext (h : ∀ a, f a = g a) : f = g :=\n  DFunLike.ext f g h\n\n"}
{"name":"OrderAddMonoidHom.ext","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : Preorder α\ninst✝² : Preorder β\ninst✝¹ : AddZeroClass α\ninst✝ : AddZeroClass β\nf g : OrderAddMonoidHom α β\nh : ∀ (a : α), Eq (f a) (g a)\n⊢ Eq f g","decl":"@[to_additive (attr := ext)]\ntheorem ext (h : ∀ a, f a = g a) : f = g :=\n  DFunLike.ext f g h\n\n"}
{"name":"OrderAddMonoidHom.ext_iff","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : Preorder α\ninst✝² : Preorder β\ninst✝¹ : AddZeroClass α\ninst✝ : AddZeroClass β\nf g : OrderAddMonoidHom α β\n⊢ Iff (Eq f g) (∀ (a : α), Eq (f a) (g a))","decl":"@[to_additive (attr := ext)]\ntheorem ext (h : ∀ a, f a = g a) : f = g :=\n  DFunLike.ext f g h\n\n"}
{"name":"OrderAddMonoidHom.toFun_eq_coe","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : Preorder α\ninst✝² : Preorder β\ninst✝¹ : AddZeroClass α\ninst✝ : AddZeroClass β\nf : OrderAddMonoidHom α β\n⊢ Eq (↑f.toAddMonoidHom).toFun ⇑f","decl":"@[to_additive]\ntheorem toFun_eq_coe (f : α →*o β) : f.toFun = (f : α → β) :=\n  rfl\n\n"}
{"name":"OrderMonoidHom.toFun_eq_coe","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : Preorder α\ninst✝² : Preorder β\ninst✝¹ : MulOneClass α\ninst✝ : MulOneClass β\nf : OrderMonoidHom α β\n⊢ Eq (↑f.toMonoidHom).toFun ⇑f","decl":"@[to_additive]\ntheorem toFun_eq_coe (f : α →*o β) : f.toFun = (f : α → β) :=\n  rfl\n\n"}
{"name":"OrderMonoidHom.coe_mk","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : Preorder α\ninst✝² : Preorder β\ninst✝¹ : MulOneClass α\ninst✝ : MulOneClass β\nf : MonoidHom α β\nh : Monotone (↑f).toFun\n⊢ Eq ⇑{ toMonoidHom := f, monotone' := h } ⇑f","decl":"@[to_additive (attr := simp)]\ntheorem coe_mk (f : α →* β) (h) : (OrderMonoidHom.mk f h : α → β) = f :=\n  rfl\n\n"}
{"name":"OrderAddMonoidHom.coe_mk","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : Preorder α\ninst✝² : Preorder β\ninst✝¹ : AddZeroClass α\ninst✝ : AddZeroClass β\nf : AddMonoidHom α β\nh : Monotone (↑f).toFun\n⊢ Eq ⇑{ toAddMonoidHom := f, monotone' := h } ⇑f","decl":"@[to_additive (attr := simp)]\ntheorem coe_mk (f : α →* β) (h) : (OrderMonoidHom.mk f h : α → β) = f :=\n  rfl\n\n"}
{"name":"OrderMonoidHom.mk_coe","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : Preorder α\ninst✝² : Preorder β\ninst✝¹ : MulOneClass α\ninst✝ : MulOneClass β\nf : OrderMonoidHom α β\nh : Monotone (↑↑f).toFun\n⊢ Eq { toMonoidHom := ↑f, monotone' := h } f","decl":"@[to_additive (attr := simp)]\ntheorem mk_coe (f : α →*o β) (h) : OrderMonoidHom.mk (f : α →* β) h = f := by\n  ext\n  rfl\n\n"}
{"name":"OrderAddMonoidHom.mk_coe","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : Preorder α\ninst✝² : Preorder β\ninst✝¹ : AddZeroClass α\ninst✝ : AddZeroClass β\nf : OrderAddMonoidHom α β\nh : Monotone (↑↑f).toFun\n⊢ Eq { toAddMonoidHom := ↑f, monotone' := h } f","decl":"@[to_additive (attr := simp)]\ntheorem mk_coe (f : α →*o β) (h) : OrderMonoidHom.mk (f : α →* β) h = f := by\n  ext\n  rfl\n\n"}
{"name":"OrderMonoidHom.coe_monoidHom","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : Preorder α\ninst✝² : Preorder β\ninst✝¹ : MulOneClass α\ninst✝ : MulOneClass β\nf : OrderMonoidHom α β\n⊢ Eq ⇑↑f ⇑f","decl":"@[to_additive (attr := simp)]\ntheorem coe_monoidHom (f : α →*o β) : ((f : α →* β) : α → β) = f :=\n  rfl\n\n"}
{"name":"OrderAddMonoidHom.coe_addMonoidHom","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : Preorder α\ninst✝² : Preorder β\ninst✝¹ : AddZeroClass α\ninst✝ : AddZeroClass β\nf : OrderAddMonoidHom α β\n⊢ Eq ⇑↑f ⇑f","decl":"@[to_additive (attr := simp)]\ntheorem coe_monoidHom (f : α →*o β) : ((f : α →* β) : α → β) = f :=\n  rfl\n\n"}
{"name":"OrderMonoidHom.coe_orderHom","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : Preorder α\ninst✝² : Preorder β\ninst✝¹ : MulOneClass α\ninst✝ : MulOneClass β\nf : OrderMonoidHom α β\n⊢ Eq ⇑↑f ⇑f","decl":"@[to_additive (attr := simp)]\ntheorem coe_orderHom (f : α →*o β) : ((f : α →o β) : α → β) = f :=\n  rfl\n\n"}
{"name":"OrderAddMonoidHom.coe_orderHom","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : Preorder α\ninst✝² : Preorder β\ninst✝¹ : AddZeroClass α\ninst✝ : AddZeroClass β\nf : OrderAddMonoidHom α β\n⊢ Eq ⇑↑f ⇑f","decl":"@[to_additive (attr := simp)]\ntheorem coe_orderHom (f : α →*o β) : ((f : α →o β) : α → β) = f :=\n  rfl\n\n"}
{"name":"OrderMonoidHom.toMonoidHom_injective","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : Preorder α\ninst✝² : Preorder β\ninst✝¹ : MulOneClass α\ninst✝ : MulOneClass β\n⊢ Function.Injective OrderMonoidHom.toMonoidHom","decl":"@[to_additive]\ntheorem toMonoidHom_injective : Injective (toMonoidHom : _ → α →* β) := fun f g h =>\n  ext <| by convert DFunLike.ext_iff.1 h using 0\n\n"}
{"name":"OrderAddMonoidHom.toAddMonoidHom_injective","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : Preorder α\ninst✝² : Preorder β\ninst✝¹ : AddZeroClass α\ninst✝ : AddZeroClass β\n⊢ Function.Injective OrderAddMonoidHom.toAddMonoidHom","decl":"@[to_additive]\ntheorem toMonoidHom_injective : Injective (toMonoidHom : _ → α →* β) := fun f g h =>\n  ext <| by convert DFunLike.ext_iff.1 h using 0\n\n"}
{"name":"OrderAddMonoidHom.toOrderHom_injective","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : Preorder α\ninst✝² : Preorder β\ninst✝¹ : AddZeroClass α\ninst✝ : AddZeroClass β\n⊢ Function.Injective OrderAddMonoidHom.toOrderHom","decl":"@[to_additive]\ntheorem toOrderHom_injective : Injective (toOrderHom : _ → α →o β) := fun f g h =>\n  ext <| by convert DFunLike.ext_iff.1 h using 0\n\n"}
{"name":"OrderMonoidHom.toOrderHom_injective","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : Preorder α\ninst✝² : Preorder β\ninst✝¹ : MulOneClass α\ninst✝ : MulOneClass β\n⊢ Function.Injective OrderMonoidHom.toOrderHom","decl":"@[to_additive]\ntheorem toOrderHom_injective : Injective (toOrderHom : _ → α →o β) := fun f g h =>\n  ext <| by convert DFunLike.ext_iff.1 h using 0\n\n"}
{"name":"OrderMonoidHom.coe_copy","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : Preorder α\ninst✝² : Preorder β\ninst✝¹ : MulOneClass α\ninst✝ : MulOneClass β\nf : OrderMonoidHom α β\nf' : α → β\nh : Eq f' ⇑f\n⊢ Eq (⇑(f.copy f' h)) f'","decl":"@[to_additive (attr := simp)]\ntheorem coe_copy (f : α →*o β) (f' : α → β) (h : f' = f) : ⇑(f.copy f' h) = f' :=\n  rfl\n\n"}
{"name":"OrderAddMonoidHom.coe_copy","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : Preorder α\ninst✝² : Preorder β\ninst✝¹ : AddZeroClass α\ninst✝ : AddZeroClass β\nf : OrderAddMonoidHom α β\nf' : α → β\nh : Eq f' ⇑f\n⊢ Eq (⇑(f.copy f' h)) f'","decl":"@[to_additive (attr := simp)]\ntheorem coe_copy (f : α →*o β) (f' : α → β) (h : f' = f) : ⇑(f.copy f' h) = f' :=\n  rfl\n\n"}
{"name":"OrderAddMonoidHom.copy_eq","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : Preorder α\ninst✝² : Preorder β\ninst✝¹ : AddZeroClass α\ninst✝ : AddZeroClass β\nf : OrderAddMonoidHom α β\nf' : α → β\nh : Eq f' ⇑f\n⊢ Eq (f.copy f' h) f","decl":"@[to_additive]\ntheorem copy_eq (f : α →*o β) (f' : α → β) (h : f' = f) : f.copy f' h = f :=\n  DFunLike.ext' h\n\n"}
{"name":"OrderMonoidHom.copy_eq","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : Preorder α\ninst✝² : Preorder β\ninst✝¹ : MulOneClass α\ninst✝ : MulOneClass β\nf : OrderMonoidHom α β\nf' : α → β\nh : Eq f' ⇑f\n⊢ Eq (f.copy f' h) f","decl":"@[to_additive]\ntheorem copy_eq (f : α →*o β) (f' : α → β) (h : f' = f) : f.copy f' h = f :=\n  DFunLike.ext' h\n\n"}
{"name":"OrderAddMonoidHom.coe_id","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"α : Type u_2\ninst✝¹ : Preorder α\ninst✝ : AddZeroClass α\n⊢ Eq (⇑(OrderAddMonoidHom.id α)) id","decl":"@[to_additive (attr := simp)]\ntheorem coe_id : ⇑(OrderMonoidHom.id α) = id :=\n  rfl\n\n"}
{"name":"OrderMonoidHom.coe_id","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"α : Type u_2\ninst✝¹ : Preorder α\ninst✝ : MulOneClass α\n⊢ Eq (⇑(OrderMonoidHom.id α)) id","decl":"@[to_additive (attr := simp)]\ntheorem coe_id : ⇑(OrderMonoidHom.id α) = id :=\n  rfl\n\n"}
{"name":"OrderAddMonoidHom.coe_comp","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝⁵ : Preorder α\ninst✝⁴ : Preorder β\ninst✝³ : Preorder γ\ninst✝² : AddZeroClass α\ninst✝¹ : AddZeroClass β\ninst✝ : AddZeroClass γ\nf : OrderAddMonoidHom β γ\ng : OrderAddMonoidHom α β\n⊢ Eq (⇑(f.comp g)) (Function.comp ⇑f ⇑g)","decl":"@[to_additive (attr := simp)]\ntheorem coe_comp (f : β →*o γ) (g : α →*o β) : (f.comp g : α → γ) = f ∘ g :=\n  rfl\n\n"}
{"name":"OrderMonoidHom.coe_comp","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝⁵ : Preorder α\ninst✝⁴ : Preorder β\ninst✝³ : Preorder γ\ninst✝² : MulOneClass α\ninst✝¹ : MulOneClass β\ninst✝ : MulOneClass γ\nf : OrderMonoidHom β γ\ng : OrderMonoidHom α β\n⊢ Eq (⇑(f.comp g)) (Function.comp ⇑f ⇑g)","decl":"@[to_additive (attr := simp)]\ntheorem coe_comp (f : β →*o γ) (g : α →*o β) : (f.comp g : α → γ) = f ∘ g :=\n  rfl\n\n"}
{"name":"OrderMonoidHom.comp_apply","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝⁵ : Preorder α\ninst✝⁴ : Preorder β\ninst✝³ : Preorder γ\ninst✝² : MulOneClass α\ninst✝¹ : MulOneClass β\ninst✝ : MulOneClass γ\nf : OrderMonoidHom β γ\ng : OrderMonoidHom α β\na : α\n⊢ Eq ((f.comp g) a) (f (g a))","decl":"@[to_additive (attr := simp)]\ntheorem comp_apply (f : β →*o γ) (g : α →*o β) (a : α) : (f.comp g) a = f (g a) :=\n  rfl\n\n"}
{"name":"OrderAddMonoidHom.comp_apply","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝⁵ : Preorder α\ninst✝⁴ : Preorder β\ninst✝³ : Preorder γ\ninst✝² : AddZeroClass α\ninst✝¹ : AddZeroClass β\ninst✝ : AddZeroClass γ\nf : OrderAddMonoidHom β γ\ng : OrderAddMonoidHom α β\na : α\n⊢ Eq ((f.comp g) a) (f (g a))","decl":"@[to_additive (attr := simp)]\ntheorem comp_apply (f : β →*o γ) (g : α →*o β) (a : α) : (f.comp g) a = f (g a) :=\n  rfl\n\n"}
{"name":"OrderMonoidHom.coe_comp_monoidHom","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝⁵ : Preorder α\ninst✝⁴ : Preorder β\ninst✝³ : Preorder γ\ninst✝² : MulOneClass α\ninst✝¹ : MulOneClass β\ninst✝ : MulOneClass γ\nf : OrderMonoidHom β γ\ng : OrderMonoidHom α β\n⊢ Eq (↑(f.comp g)) ((↑f).comp ↑g)","decl":"@[to_additive]\ntheorem coe_comp_monoidHom (f : β →*o γ) (g : α →*o β) :\n    (f.comp g : α →* γ) = (f : β →* γ).comp g :=\n  rfl\n\n"}
{"name":"OrderAddMonoidHom.coe_comp_addMonoidHom","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝⁵ : Preorder α\ninst✝⁴ : Preorder β\ninst✝³ : Preorder γ\ninst✝² : AddZeroClass α\ninst✝¹ : AddZeroClass β\ninst✝ : AddZeroClass γ\nf : OrderAddMonoidHom β γ\ng : OrderAddMonoidHom α β\n⊢ Eq (↑(f.comp g)) ((↑f).comp ↑g)","decl":"@[to_additive]\ntheorem coe_comp_monoidHom (f : β →*o γ) (g : α →*o β) :\n    (f.comp g : α →* γ) = (f : β →* γ).comp g :=\n  rfl\n\n"}
{"name":"OrderAddMonoidHom.coe_comp_orderHom","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝⁵ : Preorder α\ninst✝⁴ : Preorder β\ninst✝³ : Preorder γ\ninst✝² : AddZeroClass α\ninst✝¹ : AddZeroClass β\ninst✝ : AddZeroClass γ\nf : OrderAddMonoidHom β γ\ng : OrderAddMonoidHom α β\n⊢ Eq (↑(f.comp g)) ((↑f).comp ↑g)","decl":"@[to_additive]\ntheorem coe_comp_orderHom (f : β →*o γ) (g : α →*o β) :\n    (f.comp g : α →o γ) = (f : β →o γ).comp g :=\n  rfl\n\n"}
{"name":"OrderMonoidHom.coe_comp_orderHom","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝⁵ : Preorder α\ninst✝⁴ : Preorder β\ninst✝³ : Preorder γ\ninst✝² : MulOneClass α\ninst✝¹ : MulOneClass β\ninst✝ : MulOneClass γ\nf : OrderMonoidHom β γ\ng : OrderMonoidHom α β\n⊢ Eq (↑(f.comp g)) ((↑f).comp ↑g)","decl":"@[to_additive]\ntheorem coe_comp_orderHom (f : β →*o γ) (g : α →*o β) :\n    (f.comp g : α →o γ) = (f : β →o γ).comp g :=\n  rfl\n\n"}
{"name":"OrderAddMonoidHom.comp_assoc","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\nδ : Type u_5\ninst✝⁷ : Preorder α\ninst✝⁶ : Preorder β\ninst✝⁵ : Preorder γ\ninst✝⁴ : Preorder δ\ninst✝³ : AddZeroClass α\ninst✝² : AddZeroClass β\ninst✝¹ : AddZeroClass γ\ninst✝ : AddZeroClass δ\nf : OrderAddMonoidHom γ δ\ng : OrderAddMonoidHom β γ\nh : OrderAddMonoidHom α β\n⊢ Eq ((f.comp g).comp h) (f.comp (g.comp h))","decl":"@[to_additive (attr := simp)]\ntheorem comp_assoc (f : γ →*o δ) (g : β →*o γ) (h : α →*o β) :\n    (f.comp g).comp h = f.comp (g.comp h) :=\n  rfl\n\n"}
{"name":"OrderMonoidHom.comp_assoc","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\nδ : Type u_5\ninst✝⁷ : Preorder α\ninst✝⁶ : Preorder β\ninst✝⁵ : Preorder γ\ninst✝⁴ : Preorder δ\ninst✝³ : MulOneClass α\ninst✝² : MulOneClass β\ninst✝¹ : MulOneClass γ\ninst✝ : MulOneClass δ\nf : OrderMonoidHom γ δ\ng : OrderMonoidHom β γ\nh : OrderMonoidHom α β\n⊢ Eq ((f.comp g).comp h) (f.comp (g.comp h))","decl":"@[to_additive (attr := simp)]\ntheorem comp_assoc (f : γ →*o δ) (g : β →*o γ) (h : α →*o β) :\n    (f.comp g).comp h = f.comp (g.comp h) :=\n  rfl\n\n"}
{"name":"OrderMonoidHom.comp_id","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : Preorder α\ninst✝² : Preorder β\ninst✝¹ : MulOneClass α\ninst✝ : MulOneClass β\nf : OrderMonoidHom α β\n⊢ Eq (f.comp (OrderMonoidHom.id α)) f","decl":"@[to_additive (attr := simp)]\ntheorem comp_id (f : α →*o β) : f.comp (OrderMonoidHom.id α) = f :=\n  rfl\n\n"}
{"name":"OrderAddMonoidHom.comp_id","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : Preorder α\ninst✝² : Preorder β\ninst✝¹ : AddZeroClass α\ninst✝ : AddZeroClass β\nf : OrderAddMonoidHom α β\n⊢ Eq (f.comp (OrderAddMonoidHom.id α)) f","decl":"@[to_additive (attr := simp)]\ntheorem comp_id (f : α →*o β) : f.comp (OrderMonoidHom.id α) = f :=\n  rfl\n\n"}
{"name":"OrderMonoidHom.id_comp","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : Preorder α\ninst✝² : Preorder β\ninst✝¹ : MulOneClass α\ninst✝ : MulOneClass β\nf : OrderMonoidHom α β\n⊢ Eq ((OrderMonoidHom.id β).comp f) f","decl":"@[to_additive (attr := simp)]\ntheorem id_comp (f : α →*o β) : (OrderMonoidHom.id β).comp f = f :=\n  rfl\n\n"}
{"name":"OrderAddMonoidHom.id_comp","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : Preorder α\ninst✝² : Preorder β\ninst✝¹ : AddZeroClass α\ninst✝ : AddZeroClass β\nf : OrderAddMonoidHom α β\n⊢ Eq ((OrderAddMonoidHom.id β).comp f) f","decl":"@[to_additive (attr := simp)]\ntheorem id_comp (f : α →*o β) : (OrderMonoidHom.id β).comp f = f :=\n  rfl\n\n"}
{"name":"OrderAddMonoidHom.cancel_right","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝⁵ : Preorder α\ninst✝⁴ : Preorder β\ninst✝³ : Preorder γ\ninst✝² : AddZeroClass α\ninst✝¹ : AddZeroClass β\ninst✝ : AddZeroClass γ\ng₁ g₂ : OrderAddMonoidHom β γ\nf : OrderAddMonoidHom α β\nhf : Function.Surjective ⇑f\n⊢ Iff (Eq (g₁.comp f) (g₂.comp f)) (Eq g₁ g₂)","decl":"@[to_additive (attr := simp)]\ntheorem cancel_right {g₁ g₂ : β →*o γ} {f : α →*o β} (hf : Function.Surjective f) :\n    g₁.comp f = g₂.comp f ↔ g₁ = g₂ :=\n  ⟨fun h => ext <| hf.forall.2 <| DFunLike.ext_iff.1 h, fun _ => by congr⟩\n\n"}
{"name":"OrderMonoidHom.cancel_right","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝⁵ : Preorder α\ninst✝⁴ : Preorder β\ninst✝³ : Preorder γ\ninst✝² : MulOneClass α\ninst✝¹ : MulOneClass β\ninst✝ : MulOneClass γ\ng₁ g₂ : OrderMonoidHom β γ\nf : OrderMonoidHom α β\nhf : Function.Surjective ⇑f\n⊢ Iff (Eq (g₁.comp f) (g₂.comp f)) (Eq g₁ g₂)","decl":"@[to_additive (attr := simp)]\ntheorem cancel_right {g₁ g₂ : β →*o γ} {f : α →*o β} (hf : Function.Surjective f) :\n    g₁.comp f = g₂.comp f ↔ g₁ = g₂ :=\n  ⟨fun h => ext <| hf.forall.2 <| DFunLike.ext_iff.1 h, fun _ => by congr⟩\n\n"}
{"name":"OrderAddMonoidHom.cancel_left","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝⁵ : Preorder α\ninst✝⁴ : Preorder β\ninst✝³ : Preorder γ\ninst✝² : AddZeroClass α\ninst✝¹ : AddZeroClass β\ninst✝ : AddZeroClass γ\ng : OrderAddMonoidHom β γ\nf₁ f₂ : OrderAddMonoidHom α β\nhg : Function.Injective ⇑g\n⊢ Iff (Eq (g.comp f₁) (g.comp f₂)) (Eq f₁ f₂)","decl":"@[to_additive (attr := simp)]\ntheorem cancel_left {g : β →*o γ} {f₁ f₂ : α →*o β} (hg : Function.Injective g) :\n    g.comp f₁ = g.comp f₂ ↔ f₁ = f₂ :=\n  ⟨fun h => ext fun a => hg <| by rw [← comp_apply, h, comp_apply], congr_arg _⟩\n\n"}
{"name":"OrderMonoidHom.cancel_left","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝⁵ : Preorder α\ninst✝⁴ : Preorder β\ninst✝³ : Preorder γ\ninst✝² : MulOneClass α\ninst✝¹ : MulOneClass β\ninst✝ : MulOneClass γ\ng : OrderMonoidHom β γ\nf₁ f₂ : OrderMonoidHom α β\nhg : Function.Injective ⇑g\n⊢ Iff (Eq (g.comp f₁) (g.comp f₂)) (Eq f₁ f₂)","decl":"@[to_additive (attr := simp)]\ntheorem cancel_left {g : β →*o γ} {f₁ f₂ : α →*o β} (hg : Function.Injective g) :\n    g.comp f₁ = g.comp f₂ ↔ f₁ = f₂ :=\n  ⟨fun h => ext fun a => hg <| by rw [← comp_apply, h, comp_apply], congr_arg _⟩\n\n"}
{"name":"OrderAddMonoidHom.coe_zero","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : Preorder α\ninst✝² : Preorder β\ninst✝¹ : AddZeroClass α\ninst✝ : AddZeroClass β\n⊢ Eq (⇑0) 0","decl":"@[to_additive (attr := simp)]\ntheorem coe_one : ⇑(1 : α →*o β) = 1 :=\n  rfl\n\n"}
{"name":"OrderMonoidHom.coe_one","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : Preorder α\ninst✝² : Preorder β\ninst✝¹ : MulOneClass α\ninst✝ : MulOneClass β\n⊢ Eq (⇑1) 1","decl":"@[to_additive (attr := simp)]\ntheorem coe_one : ⇑(1 : α →*o β) = 1 :=\n  rfl\n\n"}
{"name":"OrderAddMonoidHom.zero_apply","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : Preorder α\ninst✝² : Preorder β\ninst✝¹ : AddZeroClass α\ninst✝ : AddZeroClass β\na : α\n⊢ Eq (0 a) 0","decl":"@[to_additive (attr := simp)]\ntheorem one_apply (a : α) : (1 : α →*o β) a = 1 :=\n  rfl\n\n"}
{"name":"OrderMonoidHom.one_apply","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : Preorder α\ninst✝² : Preorder β\ninst✝¹ : MulOneClass α\ninst✝ : MulOneClass β\na : α\n⊢ Eq (1 a) 1","decl":"@[to_additive (attr := simp)]\ntheorem one_apply (a : α) : (1 : α →*o β) a = 1 :=\n  rfl\n\n"}
{"name":"OrderAddMonoidHom.zero_comp","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝⁵ : Preorder α\ninst✝⁴ : Preorder β\ninst✝³ : Preorder γ\ninst✝² : AddZeroClass α\ninst✝¹ : AddZeroClass β\ninst✝ : AddZeroClass γ\nf : OrderAddMonoidHom α β\n⊢ Eq (OrderAddMonoidHom.comp 0 f) 0","decl":"@[to_additive (attr := simp)]\ntheorem one_comp (f : α →*o β) : (1 : β →*o γ).comp f = 1 :=\n  rfl\n\n"}
{"name":"OrderMonoidHom.one_comp","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝⁵ : Preorder α\ninst✝⁴ : Preorder β\ninst✝³ : Preorder γ\ninst✝² : MulOneClass α\ninst✝¹ : MulOneClass β\ninst✝ : MulOneClass γ\nf : OrderMonoidHom α β\n⊢ Eq (OrderMonoidHom.comp 1 f) 1","decl":"@[to_additive (attr := simp)]\ntheorem one_comp (f : α →*o β) : (1 : β →*o γ).comp f = 1 :=\n  rfl\n\n"}
{"name":"OrderMonoidHom.comp_one","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝⁵ : Preorder α\ninst✝⁴ : Preorder β\ninst✝³ : Preorder γ\ninst✝² : MulOneClass α\ninst✝¹ : MulOneClass β\ninst✝ : MulOneClass γ\nf : OrderMonoidHom β γ\n⊢ Eq (f.comp 1) 1","decl":"@[to_additive (attr := simp)]\ntheorem comp_one (f : β →*o γ) : f.comp (1 : α →*o β) = 1 :=\n  ext fun _ => map_one f\n\n"}
{"name":"OrderAddMonoidHom.comp_zero","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝⁵ : Preorder α\ninst✝⁴ : Preorder β\ninst✝³ : Preorder γ\ninst✝² : AddZeroClass α\ninst✝¹ : AddZeroClass β\ninst✝ : AddZeroClass γ\nf : OrderAddMonoidHom β γ\n⊢ Eq (f.comp 0) 0","decl":"@[to_additive (attr := simp)]\ntheorem comp_one (f : β →*o γ) : f.comp (1 : α →*o β) = 1 :=\n  ext fun _ => map_one f\n\n"}
{"name":"OrderAddMonoidHom.coe_add","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : OrderedAddCommMonoid α\ninst✝ : OrderedAddCommMonoid β\nf g : OrderAddMonoidHom α β\n⊢ Eq (⇑(HAdd.hAdd f g)) (HAdd.hAdd ⇑f ⇑g)","decl":"@[to_additive (attr := simp)]\ntheorem coe_mul (f g : α →*o β) : ⇑(f * g) = f * g :=\n  rfl\n\n"}
{"name":"OrderMonoidHom.coe_mul","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : OrderedCommMonoid α\ninst✝ : OrderedCommMonoid β\nf g : OrderMonoidHom α β\n⊢ Eq (⇑(HMul.hMul f g)) (HMul.hMul ⇑f ⇑g)","decl":"@[to_additive (attr := simp)]\ntheorem coe_mul (f g : α →*o β) : ⇑(f * g) = f * g :=\n  rfl\n\n"}
{"name":"OrderAddMonoidHom.add_apply","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : OrderedAddCommMonoid α\ninst✝ : OrderedAddCommMonoid β\nf g : OrderAddMonoidHom α β\na : α\n⊢ Eq ((HAdd.hAdd f g) a) (HAdd.hAdd (f a) (g a))","decl":"@[to_additive (attr := simp)]\ntheorem mul_apply (f g : α →*o β) (a : α) : (f * g) a = f a * g a :=\n  rfl\n\n"}
{"name":"OrderMonoidHom.mul_apply","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : OrderedCommMonoid α\ninst✝ : OrderedCommMonoid β\nf g : OrderMonoidHom α β\na : α\n⊢ Eq ((HMul.hMul f g) a) (HMul.hMul (f a) (g a))","decl":"@[to_additive (attr := simp)]\ntheorem mul_apply (f g : α →*o β) (a : α) : (f * g) a = f a * g a :=\n  rfl\n\n"}
{"name":"OrderMonoidHom.mul_comp","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝² : OrderedCommMonoid α\ninst✝¹ : OrderedCommMonoid β\ninst✝ : OrderedCommMonoid γ\ng₁ g₂ : OrderMonoidHom β γ\nf : OrderMonoidHom α β\n⊢ Eq ((HMul.hMul g₁ g₂).comp f) (HMul.hMul (g₁.comp f) (g₂.comp f))","decl":"@[to_additive]\ntheorem mul_comp (g₁ g₂ : β →*o γ) (f : α →*o β) : (g₁ * g₂).comp f = g₁.comp f * g₂.comp f :=\n  rfl\n\n"}
{"name":"OrderAddMonoidHom.add_comp","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝² : OrderedAddCommMonoid α\ninst✝¹ : OrderedAddCommMonoid β\ninst✝ : OrderedAddCommMonoid γ\ng₁ g₂ : OrderAddMonoidHom β γ\nf : OrderAddMonoidHom α β\n⊢ Eq ((HAdd.hAdd g₁ g₂).comp f) (HAdd.hAdd (g₁.comp f) (g₂.comp f))","decl":"@[to_additive]\ntheorem mul_comp (g₁ g₂ : β →*o γ) (f : α →*o β) : (g₁ * g₂).comp f = g₁.comp f * g₂.comp f :=\n  rfl\n\n"}
{"name":"OrderAddMonoidHom.comp_add","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝² : OrderedAddCommMonoid α\ninst✝¹ : OrderedAddCommMonoid β\ninst✝ : OrderedAddCommMonoid γ\ng : OrderAddMonoidHom β γ\nf₁ f₂ : OrderAddMonoidHom α β\n⊢ Eq (g.comp (HAdd.hAdd f₁ f₂)) (HAdd.hAdd (g.comp f₁) (g.comp f₂))","decl":"@[to_additive]\ntheorem comp_mul (g : β →*o γ) (f₁ f₂ : α →*o β) : g.comp (f₁ * f₂) = g.comp f₁ * g.comp f₂ :=\n  ext fun _ => map_mul g _ _\n\n"}
{"name":"OrderMonoidHom.comp_mul","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝² : OrderedCommMonoid α\ninst✝¹ : OrderedCommMonoid β\ninst✝ : OrderedCommMonoid γ\ng : OrderMonoidHom β γ\nf₁ f₂ : OrderMonoidHom α β\n⊢ Eq (g.comp (HMul.hMul f₁ f₂)) (HMul.hMul (g.comp f₁) (g.comp f₂))","decl":"@[to_additive]\ntheorem comp_mul (g : β →*o γ) (f₁ f₂ : α →*o β) : g.comp (f₁ * f₂) = g.comp f₁ * g.comp f₂ :=\n  ext fun _ => map_mul g _ _\n\n"}
{"name":"OrderMonoidHom.toMonoidHom_eq_coe","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"α : Type u_2\nβ : Type u_3\nhα : OrderedCommMonoid α\nhβ : OrderedCommMonoid β\nf : OrderMonoidHom α β\n⊢ Eq f.toMonoidHom ↑f","decl":"@[to_additive (attr := simp)]\ntheorem toMonoidHom_eq_coe (f : α →*o β) : f.toMonoidHom = f :=\n  rfl\n\n"}
{"name":"OrderAddMonoidHom.toAddMonoidHom_eq_coe","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"α : Type u_2\nβ : Type u_3\nhα : OrderedAddCommMonoid α\nhβ : OrderedAddCommMonoid β\nf : OrderAddMonoidHom α β\n⊢ Eq f.toAddMonoidHom ↑f","decl":"@[to_additive (attr := simp)]\ntheorem toMonoidHom_eq_coe (f : α →*o β) : f.toMonoidHom = f :=\n  rfl\n\n"}
{"name":"OrderAddMonoidHom.toOrderHom_eq_coe","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"α : Type u_2\nβ : Type u_3\nhα : OrderedAddCommMonoid α\nhβ : OrderedAddCommMonoid β\nf : OrderAddMonoidHom α β\n⊢ Eq f.toOrderHom ↑f","decl":"@[to_additive (attr := simp)]\ntheorem toOrderHom_eq_coe (f : α →*o β) : f.toOrderHom = f :=\n  rfl\n\n"}
{"name":"OrderMonoidHom.toOrderHom_eq_coe","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"α : Type u_2\nβ : Type u_3\nhα : OrderedCommMonoid α\nhβ : OrderedCommMonoid β\nf : OrderMonoidHom α β\n⊢ Eq f.toOrderHom ↑f","decl":"@[to_additive (attr := simp)]\ntheorem toOrderHom_eq_coe (f : α →*o β) : f.toOrderHom = f :=\n  rfl\n\n"}
{"name":"OrderMonoidIso.instOrderIsoClass","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : Preorder α\ninst✝² : Preorder β\ninst✝¹ : Mul α\ninst✝ : Mul β\n⊢ OrderIsoClass (OrderMonoidIso α β) α β","decl":"@[to_additive]\ninstance : OrderIsoClass (α ≃*o β) α β where\n  map_le_map_iff f := f.map_le_map_iff'\n\n"}
{"name":"OrderAddMonoidIso.instOrderIsoClass","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : Preorder α\ninst✝² : Preorder β\ninst✝¹ : Add α\ninst✝ : Add β\n⊢ OrderIsoClass (OrderAddMonoidIso α β) α β","decl":"@[to_additive]\ninstance : OrderIsoClass (α ≃*o β) α β where\n  map_le_map_iff f := f.map_le_map_iff'\n\n"}
{"name":"OrderAddMonoidIso.instAddEquivClass","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : Preorder α\ninst✝² : Preorder β\ninst✝¹ : Add α\ninst✝ : Add β\n⊢ AddEquivClass (OrderAddMonoidIso α β) α β","decl":"@[to_additive]\ninstance : MulEquivClass (α ≃*o β) α β where\n  map_mul f := map_mul f.toMulEquiv\n\n-- Other lemmas should be accessed through the `FunLike` API\n"}
{"name":"OrderMonoidIso.instMulEquivClass","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : Preorder α\ninst✝² : Preorder β\ninst✝¹ : Mul α\ninst✝ : Mul β\n⊢ MulEquivClass (OrderMonoidIso α β) α β","decl":"@[to_additive]\ninstance : MulEquivClass (α ≃*o β) α β where\n  map_mul f := map_mul f.toMulEquiv\n\n-- Other lemmas should be accessed through the `FunLike` API\n"}
{"name":"OrderMonoidIso.ext","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : Preorder α\ninst✝² : Preorder β\ninst✝¹ : Mul α\ninst✝ : Mul β\nf g : OrderMonoidIso α β\nh : ∀ (a : α), Eq (f a) (g a)\n⊢ Eq f g","decl":"@[to_additive (attr := ext)]\ntheorem ext (h : ∀ a, f a = g a) : f = g :=\n  DFunLike.ext f g h\n\n"}
{"name":"OrderAddMonoidIso.ext_iff","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : Preorder α\ninst✝² : Preorder β\ninst✝¹ : Add α\ninst✝ : Add β\nf g : OrderAddMonoidIso α β\n⊢ Iff (Eq f g) (∀ (a : α), Eq (f a) (g a))","decl":"@[to_additive (attr := ext)]\ntheorem ext (h : ∀ a, f a = g a) : f = g :=\n  DFunLike.ext f g h\n\n"}
{"name":"OrderAddMonoidIso.ext","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : Preorder α\ninst✝² : Preorder β\ninst✝¹ : Add α\ninst✝ : Add β\nf g : OrderAddMonoidIso α β\nh : ∀ (a : α), Eq (f a) (g a)\n⊢ Eq f g","decl":"@[to_additive (attr := ext)]\ntheorem ext (h : ∀ a, f a = g a) : f = g :=\n  DFunLike.ext f g h\n\n"}
{"name":"OrderMonoidIso.ext_iff","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : Preorder α\ninst✝² : Preorder β\ninst✝¹ : Mul α\ninst✝ : Mul β\nf g : OrderMonoidIso α β\n⊢ Iff (Eq f g) (∀ (a : α), Eq (f a) (g a))","decl":"@[to_additive (attr := ext)]\ntheorem ext (h : ∀ a, f a = g a) : f = g :=\n  DFunLike.ext f g h\n\n"}
{"name":"OrderAddMonoidIso.toFun_eq_coe","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : Preorder α\ninst✝² : Preorder β\ninst✝¹ : Add α\ninst✝ : Add β\nf : OrderAddMonoidIso α β\n⊢ Eq f.toFun ⇑f","decl":"@[to_additive]\ntheorem toFun_eq_coe (f : α ≃*o β) : f.toFun = (f : α → β) :=\n  rfl\n\n"}
{"name":"OrderMonoidIso.toFun_eq_coe","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : Preorder α\ninst✝² : Preorder β\ninst✝¹ : Mul α\ninst✝ : Mul β\nf : OrderMonoidIso α β\n⊢ Eq f.toFun ⇑f","decl":"@[to_additive]\ntheorem toFun_eq_coe (f : α ≃*o β) : f.toFun = (f : α → β) :=\n  rfl\n\n"}
{"name":"OrderMonoidIso.coe_mk","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : Preorder α\ninst✝² : Preorder β\ninst✝¹ : Mul α\ninst✝ : Mul β\nf : MulEquiv α β\nh : ∀ {a b : α}, Iff (LE.le (f.toFun a) (f.toFun b)) (LE.le a b)\n⊢ Eq ⇑{ toMulEquiv := f, map_le_map_iff' := h } ⇑f","decl":"@[to_additive (attr := simp)]\ntheorem coe_mk (f : α ≃* β) (h) : (OrderMonoidIso.mk f h : α → β) = f :=\n  rfl\n\n"}
{"name":"OrderAddMonoidIso.coe_mk","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : Preorder α\ninst✝² : Preorder β\ninst✝¹ : Add α\ninst✝ : Add β\nf : AddEquiv α β\nh : ∀ {a b : α}, Iff (LE.le (f.toFun a) (f.toFun b)) (LE.le a b)\n⊢ Eq ⇑{ toAddEquiv := f, map_le_map_iff' := h } ⇑f","decl":"@[to_additive (attr := simp)]\ntheorem coe_mk (f : α ≃* β) (h) : (OrderMonoidIso.mk f h : α → β) = f :=\n  rfl\n\n"}
{"name":"OrderMonoidIso.mk_coe","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : Preorder α\ninst✝² : Preorder β\ninst✝¹ : Mul α\ninst✝ : Mul β\nf : OrderMonoidIso α β\nh : ∀ {a b : α}, Iff (LE.le ((↑f).toFun a) ((↑f).toFun b)) (LE.le a b)\n⊢ Eq { toMulEquiv := ↑f, map_le_map_iff' := h } f","decl":"@[to_additive (attr := simp)]\ntheorem mk_coe (f : α ≃*o β) (h) : OrderMonoidIso.mk (f : α ≃* β) h = f := rfl\n\n"}
{"name":"OrderAddMonoidIso.mk_coe","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : Preorder α\ninst✝² : Preorder β\ninst✝¹ : Add α\ninst✝ : Add β\nf : OrderAddMonoidIso α β\nh : ∀ {a b : α}, Iff (LE.le ((↑f).toFun a) ((↑f).toFun b)) (LE.le a b)\n⊢ Eq { toAddEquiv := ↑f, map_le_map_iff' := h } f","decl":"@[to_additive (attr := simp)]\ntheorem mk_coe (f : α ≃*o β) (h) : OrderMonoidIso.mk (f : α ≃* β) h = f := rfl\n\n"}
{"name":"OrderMonoidIso.coe_mulEquiv","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : Preorder α\ninst✝² : Preorder β\ninst✝¹ : Mul α\ninst✝ : Mul β\nf : OrderMonoidIso α β\n⊢ Eq ⇑↑f ⇑f","decl":"@[to_additive (attr := simp)]\ntheorem coe_mulEquiv (f : α ≃*o β) : ((f : α ≃* β) : α → β) = f :=\n  rfl\n\n"}
{"name":"OrderAddMonoidIso.coe_addEquiv","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : Preorder α\ninst✝² : Preorder β\ninst✝¹ : Add α\ninst✝ : Add β\nf : OrderAddMonoidIso α β\n⊢ Eq ⇑↑f ⇑f","decl":"@[to_additive (attr := simp)]\ntheorem coe_mulEquiv (f : α ≃*o β) : ((f : α ≃* β) : α → β) = f :=\n  rfl\n\n"}
{"name":"OrderAddMonoidIso.coe_orderIso","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : Preorder α\ninst✝² : Preorder β\ninst✝¹ : Add α\ninst✝ : Add β\nf : OrderAddMonoidIso α β\n⊢ Eq ⇑↑f ⇑f","decl":"@[to_additive (attr := simp)]\ntheorem coe_orderIso (f : α ≃*o β) : ((f : α →o β) : α → β) = f :=\n  rfl\n\n"}
{"name":"OrderMonoidIso.coe_orderIso","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : Preorder α\ninst✝² : Preorder β\ninst✝¹ : Mul α\ninst✝ : Mul β\nf : OrderMonoidIso α β\n⊢ Eq ⇑↑f ⇑f","decl":"@[to_additive (attr := simp)]\ntheorem coe_orderIso (f : α ≃*o β) : ((f : α →o β) : α → β) = f :=\n  rfl\n\n"}
{"name":"OrderAddMonoidIso.toAddEquiv_injective","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : Preorder α\ninst✝² : Preorder β\ninst✝¹ : Add α\ninst✝ : Add β\n⊢ Function.Injective OrderAddMonoidIso.toAddEquiv","decl":"@[to_additive]\ntheorem toMulEquiv_injective : Injective (toMulEquiv : _ → α ≃* β) := fun f g h =>\n  ext <| by convert DFunLike.ext_iff.1 h using 0\n\n"}
{"name":"OrderMonoidIso.toMulEquiv_injective","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : Preorder α\ninst✝² : Preorder β\ninst✝¹ : Mul α\ninst✝ : Mul β\n⊢ Function.Injective OrderMonoidIso.toMulEquiv","decl":"@[to_additive]\ntheorem toMulEquiv_injective : Injective (toMulEquiv : _ → α ≃* β) := fun f g h =>\n  ext <| by convert DFunLike.ext_iff.1 h using 0\n\n"}
{"name":"OrderAddMonoidIso.toOrderIso_injective","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : Preorder α\ninst✝² : Preorder β\ninst✝¹ : Add α\ninst✝ : Add β\n⊢ Function.Injective OrderAddMonoidIso.toOrderIso","decl":"@[to_additive]\ntheorem toOrderIso_injective : Injective (toOrderIso : _ → α ≃o β) := fun f g h =>\n  ext <| by convert DFunLike.ext_iff.1 h using 0\n\n"}
{"name":"OrderMonoidIso.toOrderIso_injective","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : Preorder α\ninst✝² : Preorder β\ninst✝¹ : Mul α\ninst✝ : Mul β\n⊢ Function.Injective OrderMonoidIso.toOrderIso","decl":"@[to_additive]\ntheorem toOrderIso_injective : Injective (toOrderIso : _ → α ≃o β) := fun f g h =>\n  ext <| by convert DFunLike.ext_iff.1 h using 0\n\n"}
{"name":"OrderMonoidIso.coe_refl","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"α : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Mul α\n⊢ Eq (⇑(OrderMonoidIso.refl α)) id","decl":"@[to_additive (attr := simp)]\ntheorem coe_refl : ⇑(OrderMonoidIso.refl α) = id :=\n  rfl\n\n"}
{"name":"OrderAddMonoidIso.coe_refl","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"α : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Add α\n⊢ Eq (⇑(OrderAddMonoidIso.refl α)) id","decl":"@[to_additive (attr := simp)]\ntheorem coe_refl : ⇑(OrderMonoidIso.refl α) = id :=\n  rfl\n\n"}
{"name":"OrderAddMonoidIso.coe_trans","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝⁵ : Preorder α\ninst✝⁴ : Preorder β\ninst✝³ : Preorder γ\ninst✝² : Add α\ninst✝¹ : Add β\ninst✝ : Add γ\nf : OrderAddMonoidIso α β\ng : OrderAddMonoidIso β γ\n⊢ Eq (⇑(f.trans g)) (Function.comp ⇑g ⇑f)","decl":"@[to_additive (attr := simp)]\ntheorem coe_trans (f : α ≃*o β) (g : β ≃*o γ) : (f.trans g : α → γ) = g ∘ f :=\n  rfl\n\n"}
{"name":"OrderMonoidIso.coe_trans","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝⁵ : Preorder α\ninst✝⁴ : Preorder β\ninst✝³ : Preorder γ\ninst✝² : Mul α\ninst✝¹ : Mul β\ninst✝ : Mul γ\nf : OrderMonoidIso α β\ng : OrderMonoidIso β γ\n⊢ Eq (⇑(f.trans g)) (Function.comp ⇑g ⇑f)","decl":"@[to_additive (attr := simp)]\ntheorem coe_trans (f : α ≃*o β) (g : β ≃*o γ) : (f.trans g : α → γ) = g ∘ f :=\n  rfl\n\n"}
{"name":"OrderMonoidIso.trans_apply","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝⁵ : Preorder α\ninst✝⁴ : Preorder β\ninst✝³ : Preorder γ\ninst✝² : Mul α\ninst✝¹ : Mul β\ninst✝ : Mul γ\nf : OrderMonoidIso α β\ng : OrderMonoidIso β γ\na : α\n⊢ Eq ((f.trans g) a) (g (f a))","decl":"@[to_additive (attr := simp)]\ntheorem trans_apply (f : α ≃*o β) (g : β ≃*o γ) (a : α) : (f.trans g) a = g (f a) :=\n  rfl\n\n"}
{"name":"OrderAddMonoidIso.trans_apply","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝⁵ : Preorder α\ninst✝⁴ : Preorder β\ninst✝³ : Preorder γ\ninst✝² : Add α\ninst✝¹ : Add β\ninst✝ : Add γ\nf : OrderAddMonoidIso α β\ng : OrderAddMonoidIso β γ\na : α\n⊢ Eq ((f.trans g) a) (g (f a))","decl":"@[to_additive (attr := simp)]\ntheorem trans_apply (f : α ≃*o β) (g : β ≃*o γ) (a : α) : (f.trans g) a = g (f a) :=\n  rfl\n\n"}
{"name":"OrderMonoidIso.coe_trans_mulEquiv","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝⁵ : Preorder α\ninst✝⁴ : Preorder β\ninst✝³ : Preorder γ\ninst✝² : Mul α\ninst✝¹ : Mul β\ninst✝ : Mul γ\nf : OrderMonoidIso α β\ng : OrderMonoidIso β γ\n⊢ Eq (↑(f.trans g)) ((↑f).trans ↑g)","decl":"@[to_additive]\ntheorem coe_trans_mulEquiv (f : α ≃*o β) (g : β ≃*o γ) :\n    (f.trans g : α ≃* γ) = (f : α ≃* β).trans g :=\n  rfl\n\n"}
{"name":"OrderAddMonoidIso.coe_trans_addEquiv","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝⁵ : Preorder α\ninst✝⁴ : Preorder β\ninst✝³ : Preorder γ\ninst✝² : Add α\ninst✝¹ : Add β\ninst✝ : Add γ\nf : OrderAddMonoidIso α β\ng : OrderAddMonoidIso β γ\n⊢ Eq (↑(f.trans g)) ((↑f).trans ↑g)","decl":"@[to_additive]\ntheorem coe_trans_mulEquiv (f : α ≃*o β) (g : β ≃*o γ) :\n    (f.trans g : α ≃* γ) = (f : α ≃* β).trans g :=\n  rfl\n\n"}
{"name":"OrderMonoidIso.coe_trans_orderIso","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝⁵ : Preorder α\ninst✝⁴ : Preorder β\ninst✝³ : Preorder γ\ninst✝² : Mul α\ninst✝¹ : Mul β\ninst✝ : Mul γ\nf : OrderMonoidIso α β\ng : OrderMonoidIso β γ\n⊢ Eq (↑(f.trans g)) ((↑f).trans ↑g)","decl":"@[to_additive]\ntheorem coe_trans_orderIso (f : α ≃*o β) (g : β ≃*o γ) :\n    (f.trans g : α ≃o γ) = (f : α ≃o β).trans g :=\n  rfl\n\n"}
{"name":"OrderAddMonoidIso.coe_trans_orderIso","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝⁵ : Preorder α\ninst✝⁴ : Preorder β\ninst✝³ : Preorder γ\ninst✝² : Add α\ninst✝¹ : Add β\ninst✝ : Add γ\nf : OrderAddMonoidIso α β\ng : OrderAddMonoidIso β γ\n⊢ Eq (↑(f.trans g)) ((↑f).trans ↑g)","decl":"@[to_additive]\ntheorem coe_trans_orderIso (f : α ≃*o β) (g : β ≃*o γ) :\n    (f.trans g : α ≃o γ) = (f : α ≃o β).trans g :=\n  rfl\n\n"}
{"name":"OrderAddMonoidIso.trans_assoc","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\nδ : Type u_5\ninst✝⁷ : Preorder α\ninst✝⁶ : Preorder β\ninst✝⁵ : Preorder γ\ninst✝⁴ : Preorder δ\ninst✝³ : Add α\ninst✝² : Add β\ninst✝¹ : Add γ\ninst✝ : Add δ\nf : OrderAddMonoidIso α β\ng : OrderAddMonoidIso β γ\nh : OrderAddMonoidIso γ δ\n⊢ Eq ((f.trans g).trans h) (f.trans (g.trans h))","decl":"@[to_additive (attr := simp)]\ntheorem trans_assoc (f : α ≃*o β) (g : β ≃*o γ) (h : γ ≃*o δ) :\n    (f.trans g).trans h = f.trans (g.trans h) :=\n  rfl\n\n"}
{"name":"OrderMonoidIso.trans_assoc","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\nδ : Type u_5\ninst✝⁷ : Preorder α\ninst✝⁶ : Preorder β\ninst✝⁵ : Preorder γ\ninst✝⁴ : Preorder δ\ninst✝³ : Mul α\ninst✝² : Mul β\ninst✝¹ : Mul γ\ninst✝ : Mul δ\nf : OrderMonoidIso α β\ng : OrderMonoidIso β γ\nh : OrderMonoidIso γ δ\n⊢ Eq ((f.trans g).trans h) (f.trans (g.trans h))","decl":"@[to_additive (attr := simp)]\ntheorem trans_assoc (f : α ≃*o β) (g : β ≃*o γ) (h : γ ≃*o δ) :\n    (f.trans g).trans h = f.trans (g.trans h) :=\n  rfl\n\n"}
{"name":"OrderMonoidIso.trans_refl","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : Preorder α\ninst✝² : Preorder β\ninst✝¹ : Mul α\ninst✝ : Mul β\nf : OrderMonoidIso α β\n⊢ Eq (f.trans (OrderMonoidIso.refl β)) f","decl":"@[to_additive (attr := simp)]\ntheorem trans_refl (f : α ≃*o β) : f.trans (OrderMonoidIso.refl β) = f :=\n  rfl\n\n"}
{"name":"OrderAddMonoidIso.trans_refl","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : Preorder α\ninst✝² : Preorder β\ninst✝¹ : Add α\ninst✝ : Add β\nf : OrderAddMonoidIso α β\n⊢ Eq (f.trans (OrderAddMonoidIso.refl β)) f","decl":"@[to_additive (attr := simp)]\ntheorem trans_refl (f : α ≃*o β) : f.trans (OrderMonoidIso.refl β) = f :=\n  rfl\n\n"}
{"name":"OrderAddMonoidIso.refl_trans","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : Preorder α\ninst✝² : Preorder β\ninst✝¹ : Add α\ninst✝ : Add β\nf : OrderAddMonoidIso α β\n⊢ Eq ((OrderAddMonoidIso.refl α).trans f) f","decl":"@[to_additive (attr := simp)]\ntheorem refl_trans (f : α ≃*o β) : (OrderMonoidIso.refl α).trans f = f :=\n  rfl\n\n"}
{"name":"OrderMonoidIso.refl_trans","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : Preorder α\ninst✝² : Preorder β\ninst✝¹ : Mul α\ninst✝ : Mul β\nf : OrderMonoidIso α β\n⊢ Eq ((OrderMonoidIso.refl α).trans f) f","decl":"@[to_additive (attr := simp)]\ntheorem refl_trans (f : α ≃*o β) : (OrderMonoidIso.refl α).trans f = f :=\n  rfl\n\n"}
{"name":"OrderMonoidIso.cancel_right","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝⁵ : Preorder α\ninst✝⁴ : Preorder β\ninst✝³ : Preorder γ\ninst✝² : Mul α\ninst✝¹ : Mul β\ninst✝ : Mul γ\ng₁ g₂ : OrderMonoidIso α β\nf : OrderMonoidIso β γ\nhf : Function.Injective ⇑f\n⊢ Iff (Eq (g₁.trans f) (g₂.trans f)) (Eq g₁ g₂)","decl":"@[to_additive (attr := simp)]\ntheorem cancel_right {g₁ g₂ : α ≃*o β} {f : β ≃*o γ} (hf : Function.Injective f) :\n    g₁.trans f = g₂.trans f ↔ g₁ = g₂ :=\n  ⟨fun h => ext fun a => hf <| by rw [← trans_apply, h, trans_apply], by rintro rfl; rfl⟩\n\n"}
{"name":"OrderAddMonoidIso.cancel_right","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝⁵ : Preorder α\ninst✝⁴ : Preorder β\ninst✝³ : Preorder γ\ninst✝² : Add α\ninst✝¹ : Add β\ninst✝ : Add γ\ng₁ g₂ : OrderAddMonoidIso α β\nf : OrderAddMonoidIso β γ\nhf : Function.Injective ⇑f\n⊢ Iff (Eq (g₁.trans f) (g₂.trans f)) (Eq g₁ g₂)","decl":"@[to_additive (attr := simp)]\ntheorem cancel_right {g₁ g₂ : α ≃*o β} {f : β ≃*o γ} (hf : Function.Injective f) :\n    g₁.trans f = g₂.trans f ↔ g₁ = g₂ :=\n  ⟨fun h => ext fun a => hf <| by rw [← trans_apply, h, trans_apply], by rintro rfl; rfl⟩\n\n"}
{"name":"OrderAddMonoidIso.cancel_left","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝⁵ : Preorder α\ninst✝⁴ : Preorder β\ninst✝³ : Preorder γ\ninst✝² : Add α\ninst✝¹ : Add β\ninst✝ : Add γ\ng : OrderAddMonoidIso α β\nf₁ f₂ : OrderAddMonoidIso β γ\nhg : Function.Surjective ⇑g\n⊢ Iff (Eq (g.trans f₁) (g.trans f₂)) (Eq f₁ f₂)","decl":"@[to_additive (attr := simp)]\ntheorem cancel_left {g : α ≃*o β} {f₁ f₂ : β ≃*o γ} (hg : Function.Surjective g) :\n    g.trans f₁ = g.trans f₂ ↔ f₁ = f₂ :=\n  ⟨fun h => ext <| hg.forall.2 <| DFunLike.ext_iff.1 h, fun _ => by congr⟩\n\n"}
{"name":"OrderMonoidIso.cancel_left","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝⁵ : Preorder α\ninst✝⁴ : Preorder β\ninst✝³ : Preorder γ\ninst✝² : Mul α\ninst✝¹ : Mul β\ninst✝ : Mul γ\ng : OrderMonoidIso α β\nf₁ f₂ : OrderMonoidIso β γ\nhg : Function.Surjective ⇑g\n⊢ Iff (Eq (g.trans f₁) (g.trans f₂)) (Eq f₁ f₂)","decl":"@[to_additive (attr := simp)]\ntheorem cancel_left {g : α ≃*o β} {f₁ f₂ : β ≃*o γ} (hg : Function.Surjective g) :\n    g.trans f₁ = g.trans f₂ ↔ f₁ = f₂ :=\n  ⟨fun h => ext <| hg.forall.2 <| DFunLike.ext_iff.1 h, fun _ => by congr⟩\n\n"}
{"name":"OrderMonoidIso.toMulEquiv_eq_coe","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : Preorder α\ninst✝² : Preorder β\ninst✝¹ : Mul α\ninst✝ : Mul β\nf : OrderMonoidIso α β\n⊢ Eq f.toMulEquiv ↑f","decl":"@[to_additive (attr := simp)]\ntheorem toMulEquiv_eq_coe (f : α ≃*o β) : f.toMulEquiv = f :=\n  rfl\n\n"}
{"name":"OrderAddMonoidIso.toAddEquiv_eq_coe","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : Preorder α\ninst✝² : Preorder β\ninst✝¹ : Add α\ninst✝ : Add β\nf : OrderAddMonoidIso α β\n⊢ Eq f.toAddEquiv ↑f","decl":"@[to_additive (attr := simp)]\ntheorem toMulEquiv_eq_coe (f : α ≃*o β) : f.toMulEquiv = f :=\n  rfl\n\n"}
{"name":"OrderAddMonoidIso.toOrderIso_eq_coe","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : Preorder α\ninst✝² : Preorder β\ninst✝¹ : Add α\ninst✝ : Add β\nf : OrderAddMonoidIso α β\n⊢ Eq f.toOrderIso ↑f","decl":"@[to_additive (attr := simp)]\ntheorem toOrderIso_eq_coe (f : α ≃*o β) : f.toOrderIso = f :=\n  rfl\n\n"}
{"name":"OrderMonoidIso.toOrderIso_eq_coe","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : Preorder α\ninst✝² : Preorder β\ninst✝¹ : Mul α\ninst✝ : Mul β\nf : OrderMonoidIso α β\n⊢ Eq f.toOrderIso ↑f","decl":"@[to_additive (attr := simp)]\ntheorem toOrderIso_eq_coe (f : α ≃*o β) : f.toOrderIso = f :=\n  rfl\n\n"}
{"name":"OrderMonoidIso.strictMono","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : Preorder α\ninst✝² : Preorder β\ninst✝¹ : Mul α\ninst✝ : Mul β\nf : OrderMonoidIso α β\n⊢ StrictMono ⇑f","decl":"@[to_additive]\nprotected lemma strictMono : StrictMono f :=\n  strictMono_of_le_iff_le fun _ _ ↦ (map_le_map_iff _).symm\n\n"}
{"name":"OrderAddMonoidIso.strictMono","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : Preorder α\ninst✝² : Preorder β\ninst✝¹ : Add α\ninst✝ : Add β\nf : OrderAddMonoidIso α β\n⊢ StrictMono ⇑f","decl":"@[to_additive]\nprotected lemma strictMono : StrictMono f :=\n  strictMono_of_le_iff_le fun _ _ ↦ (map_le_map_iff _).symm\n\n"}
{"name":"OrderAddMonoidIso.strictMono_symm","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : Preorder α\ninst✝² : Preorder β\ninst✝¹ : Add α\ninst✝ : Add β\nf : OrderAddMonoidIso α β\n⊢ StrictMono ⇑f.symm","decl":"@[to_additive]\nprotected lemma strictMono_symm : StrictMono f.symm :=\n  strictMono_of_le_iff_le <| fun a b ↦ by\n    rw [← map_le_map_iff f]\n    convert Iff.rfl <;>\n    exact f.toEquiv.apply_symm_apply _\n\n"}
{"name":"OrderMonoidIso.strictMono_symm","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : Preorder α\ninst✝² : Preorder β\ninst✝¹ : Mul α\ninst✝ : Mul β\nf : OrderMonoidIso α β\n⊢ StrictMono ⇑f.symm","decl":"@[to_additive]\nprotected lemma strictMono_symm : StrictMono f.symm :=\n  strictMono_of_le_iff_le <| fun a b ↦ by\n    rw [← map_le_map_iff f]\n    convert Iff.rfl <;>\n    exact f.toEquiv.apply_symm_apply _\n\n"}
{"name":"OrderMonoidWithZeroHom.instMonoidWithZeroHomClass","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : Preorder α\ninst✝² : Preorder β\ninst✝¹ : MulZeroOneClass α\ninst✝ : MulZeroOneClass β\n⊢ MonoidWithZeroHomClass (OrderMonoidWithZeroHom α β) α β","decl":"instance : MonoidWithZeroHomClass (α →*₀o β) α β where\n  map_mul f := f.map_mul'\n  map_one f := f.map_one'\n  map_zero f := f.map_zero'\n\n"}
{"name":"OrderMonoidWithZeroHom.instOrderHomClass","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : Preorder α\ninst✝² : Preorder β\ninst✝¹ : MulZeroOneClass α\ninst✝ : MulZeroOneClass β\n⊢ OrderHomClass (OrderMonoidWithZeroHom α β) α β","decl":"instance : OrderHomClass (α →*₀o β) α β where\n  map_rel f _ _ h := f.monotone' h\n\n-- Other lemmas should be accessed through the `FunLike` API\n"}
{"name":"OrderMonoidWithZeroHom.ext_iff","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : Preorder α\ninst✝² : Preorder β\ninst✝¹ : MulZeroOneClass α\ninst✝ : MulZeroOneClass β\nf g : OrderMonoidWithZeroHom α β\n⊢ Iff (Eq f g) (∀ (a : α), Eq (f a) (g a))","decl":"@[ext]\ntheorem ext (h : ∀ a, f a = g a) : f = g :=\n  DFunLike.ext f g h\n\n"}
{"name":"OrderMonoidWithZeroHom.ext","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : Preorder α\ninst✝² : Preorder β\ninst✝¹ : MulZeroOneClass α\ninst✝ : MulZeroOneClass β\nf g : OrderMonoidWithZeroHom α β\nh : ∀ (a : α), Eq (f a) (g a)\n⊢ Eq f g","decl":"@[ext]\ntheorem ext (h : ∀ a, f a = g a) : f = g :=\n  DFunLike.ext f g h\n\n"}
{"name":"OrderMonoidWithZeroHom.toFun_eq_coe","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : Preorder α\ninst✝² : Preorder β\ninst✝¹ : MulZeroOneClass α\ninst✝ : MulZeroOneClass β\nf : OrderMonoidWithZeroHom α β\n⊢ Eq (↑f.toMonoidWithZeroHom).toFun ⇑f","decl":"theorem toFun_eq_coe (f : α →*₀o β) : f.toFun = (f : α → β) :=\n  rfl\n\n"}
{"name":"OrderMonoidWithZeroHom.coe_mk","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : Preorder α\ninst✝² : Preorder β\ninst✝¹ : MulZeroOneClass α\ninst✝ : MulZeroOneClass β\nf : MonoidWithZeroHom α β\nh : Monotone (↑f).toFun\n⊢ Eq ⇑{ toMonoidWithZeroHom := f, monotone' := h } ⇑f","decl":"@[simp]\ntheorem coe_mk (f : α →*₀ β) (h) : (OrderMonoidWithZeroHom.mk f h : α → β) = f :=\n  rfl\n\n"}
{"name":"OrderMonoidWithZeroHom.mk_coe","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : Preorder α\ninst✝² : Preorder β\ninst✝¹ : MulZeroOneClass α\ninst✝ : MulZeroOneClass β\nf : OrderMonoidWithZeroHom α β\nh : Monotone (↑↑f).toFun\n⊢ Eq { toMonoidWithZeroHom := ↑f, monotone' := h } f","decl":"@[simp]\ntheorem mk_coe (f : α →*₀o β) (h) : OrderMonoidWithZeroHom.mk (f : α →*₀ β) h = f := rfl\n\n"}
{"name":"OrderMonoidWithZeroHom.coe_monoidWithZeroHom","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : Preorder α\ninst✝² : Preorder β\ninst✝¹ : MulZeroOneClass α\ninst✝ : MulZeroOneClass β\nf : OrderMonoidWithZeroHom α β\n⊢ Eq ⇑↑f ⇑f","decl":"@[simp]\ntheorem coe_monoidWithZeroHom (f : α →*₀o β) : ⇑(f : α →*₀ β) = f :=\n  rfl\n\n"}
{"name":"OrderMonoidWithZeroHom.coe_orderMonoidHom","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : Preorder α\ninst✝² : Preorder β\ninst✝¹ : MulZeroOneClass α\ninst✝ : MulZeroOneClass β\nf : OrderMonoidWithZeroHom α β\n⊢ Eq ⇑↑f ⇑f","decl":"@[simp]\ntheorem coe_orderMonoidHom (f : α →*₀o β) : ⇑(f : α →*o β) = f :=\n  rfl\n\n"}
{"name":"OrderMonoidWithZeroHom.toOrderMonoidHom_injective","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : Preorder α\ninst✝² : Preorder β\ninst✝¹ : MulZeroOneClass α\ninst✝ : MulZeroOneClass β\n⊢ Function.Injective OrderMonoidWithZeroHom.toOrderMonoidHom","decl":"theorem toOrderMonoidHom_injective : Injective (toOrderMonoidHom : _ → α →*o β) := fun f g h =>\n  ext <| by convert DFunLike.ext_iff.1 h using 0\n\n"}
{"name":"OrderMonoidWithZeroHom.toMonoidWithZeroHom_injective","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : Preorder α\ninst✝² : Preorder β\ninst✝¹ : MulZeroOneClass α\ninst✝ : MulZeroOneClass β\n⊢ Function.Injective OrderMonoidWithZeroHom.toMonoidWithZeroHom","decl":"theorem toMonoidWithZeroHom_injective : Injective (toMonoidWithZeroHom : _ → α →*₀ β) :=\n  fun f g h => ext <| by convert DFunLike.ext_iff.1 h using 0\n\n"}
{"name":"OrderMonoidWithZeroHom.coe_copy","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : Preorder α\ninst✝² : Preorder β\ninst✝¹ : MulZeroOneClass α\ninst✝ : MulZeroOneClass β\nf : OrderMonoidWithZeroHom α β\nf' : α → β\nh : Eq f' ⇑f\n⊢ Eq (⇑(f.copy f' h)) f'","decl":"@[simp]\ntheorem coe_copy (f : α →*₀o β) (f' : α → β) (h : f' = f) : ⇑(f.copy f' h) = f' :=\n  rfl\n\n"}
{"name":"OrderMonoidWithZeroHom.copy_eq","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : Preorder α\ninst✝² : Preorder β\ninst✝¹ : MulZeroOneClass α\ninst✝ : MulZeroOneClass β\nf : OrderMonoidWithZeroHom α β\nf' : α → β\nh : Eq f' ⇑f\n⊢ Eq (f.copy f' h) ↑f","decl":"theorem copy_eq (f : α →*₀o β) (f' : α → β) (h : f' = f) : f.copy f' h = f :=\n  DFunLike.ext' h\n\n"}
{"name":"OrderMonoidWithZeroHom.coe_id","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"α : Type u_2\ninst✝¹ : Preorder α\ninst✝ : MulZeroOneClass α\n⊢ Eq (⇑(OrderMonoidWithZeroHom.id α)) id","decl":"@[simp, norm_cast]\ntheorem coe_id : ⇑(OrderMonoidWithZeroHom.id α) = id :=\n  rfl\n\n"}
{"name":"OrderMonoidWithZeroHom.coe_comp","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝⁵ : Preorder α\ninst✝⁴ : Preorder β\ninst✝³ : Preorder γ\ninst✝² : MulZeroOneClass α\ninst✝¹ : MulZeroOneClass β\ninst✝ : MulZeroOneClass γ\nf : OrderMonoidWithZeroHom β γ\ng : OrderMonoidWithZeroHom α β\n⊢ Eq (⇑(f.comp g)) (Function.comp ⇑f ⇑g)","decl":"@[simp]\ntheorem coe_comp (f : β →*₀o γ) (g : α →*₀o β) : (f.comp g : α → γ) = f ∘ g :=\n  rfl\n\n"}
{"name":"OrderMonoidWithZeroHom.comp_apply","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝⁵ : Preorder α\ninst✝⁴ : Preorder β\ninst✝³ : Preorder γ\ninst✝² : MulZeroOneClass α\ninst✝¹ : MulZeroOneClass β\ninst✝ : MulZeroOneClass γ\nf : OrderMonoidWithZeroHom β γ\ng : OrderMonoidWithZeroHom α β\na : α\n⊢ Eq ((f.comp g) a) (f (g a))","decl":"@[simp]\ntheorem comp_apply (f : β →*₀o γ) (g : α →*₀o β) (a : α) : (f.comp g) a = f (g a) :=\n  rfl\n\n"}
{"name":"OrderMonoidWithZeroHom.coe_comp_monoidWithZeroHom","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝⁵ : Preorder α\ninst✝⁴ : Preorder β\ninst✝³ : Preorder γ\ninst✝² : MulZeroOneClass α\ninst✝¹ : MulZeroOneClass β\ninst✝ : MulZeroOneClass γ\nf : OrderMonoidWithZeroHom β γ\ng : OrderMonoidWithZeroHom α β\n⊢ Eq (↑(f.comp g)) ((↑f).comp ↑g)","decl":"theorem coe_comp_monoidWithZeroHom (f : β →*₀o γ) (g : α →*₀o β) :\n    (f.comp g : α →*₀ γ) = (f : β →*₀ γ).comp g :=\n  rfl\n\n"}
{"name":"OrderMonoidWithZeroHom.coe_comp_orderMonoidHom","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝⁵ : Preorder α\ninst✝⁴ : Preorder β\ninst✝³ : Preorder γ\ninst✝² : MulZeroOneClass α\ninst✝¹ : MulZeroOneClass β\ninst✝ : MulZeroOneClass γ\nf : OrderMonoidWithZeroHom β γ\ng : OrderMonoidWithZeroHom α β\n⊢ Eq (↑(f.comp g)) ((↑f).comp ↑g)","decl":"theorem coe_comp_orderMonoidHom (f : β →*₀o γ) (g : α →*₀o β) :\n    (f.comp g : α →*o γ) = (f : β →*o γ).comp g :=\n  rfl\n\n"}
{"name":"OrderMonoidWithZeroHom.comp_assoc","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\nδ : Type u_5\ninst✝⁷ : Preorder α\ninst✝⁶ : Preorder β\ninst✝⁵ : Preorder γ\ninst✝⁴ : Preorder δ\ninst✝³ : MulZeroOneClass α\ninst✝² : MulZeroOneClass β\ninst✝¹ : MulZeroOneClass γ\ninst✝ : MulZeroOneClass δ\nf : OrderMonoidWithZeroHom γ δ\ng : OrderMonoidWithZeroHom β γ\nh : OrderMonoidWithZeroHom α β\n⊢ Eq ((f.comp g).comp h) (f.comp (g.comp h))","decl":"@[simp]\ntheorem comp_assoc (f : γ →*₀o δ) (g : β →*₀o γ) (h : α →*₀o β) :\n    (f.comp g).comp h = f.comp (g.comp h) :=\n  rfl\n\n"}
{"name":"OrderMonoidWithZeroHom.comp_id","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : Preorder α\ninst✝² : Preorder β\ninst✝¹ : MulZeroOneClass α\ninst✝ : MulZeroOneClass β\nf : OrderMonoidWithZeroHom α β\n⊢ Eq (f.comp (OrderMonoidWithZeroHom.id α)) f","decl":"@[simp]\ntheorem comp_id (f : α →*₀o β) : f.comp (OrderMonoidWithZeroHom.id α) = f := rfl\n\n"}
{"name":"OrderMonoidWithZeroHom.id_comp","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : Preorder α\ninst✝² : Preorder β\ninst✝¹ : MulZeroOneClass α\ninst✝ : MulZeroOneClass β\nf : OrderMonoidWithZeroHom α β\n⊢ Eq ((OrderMonoidWithZeroHom.id β).comp f) f","decl":"@[simp]\ntheorem id_comp (f : α →*₀o β) : (OrderMonoidWithZeroHom.id β).comp f = f := rfl\n\n"}
{"name":"OrderMonoidWithZeroHom.cancel_right","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝⁵ : Preorder α\ninst✝⁴ : Preorder β\ninst✝³ : Preorder γ\ninst✝² : MulZeroOneClass α\ninst✝¹ : MulZeroOneClass β\ninst✝ : MulZeroOneClass γ\ng₁ g₂ : OrderMonoidWithZeroHom β γ\nf : OrderMonoidWithZeroHom α β\nhf : Function.Surjective ⇑f\n⊢ Iff (Eq (g₁.comp f) (g₂.comp f)) (Eq g₁ g₂)","decl":"@[simp]\ntheorem cancel_right {g₁ g₂ : β →*₀o γ} {f : α →*₀o β} (hf : Function.Surjective f) :\n    g₁.comp f = g₂.comp f ↔ g₁ = g₂ :=\n  ⟨fun h => ext <| hf.forall.2 <| DFunLike.ext_iff.1 h, fun _ => by congr⟩\n\n"}
{"name":"OrderMonoidWithZeroHom.cancel_left","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝⁵ : Preorder α\ninst✝⁴ : Preorder β\ninst✝³ : Preorder γ\ninst✝² : MulZeroOneClass α\ninst✝¹ : MulZeroOneClass β\ninst✝ : MulZeroOneClass γ\ng : OrderMonoidWithZeroHom β γ\nf₁ f₂ : OrderMonoidWithZeroHom α β\nhg : Function.Injective ⇑g\n⊢ Iff (Eq (g.comp f₁) (g.comp f₂)) (Eq f₁ f₂)","decl":"@[simp]\ntheorem cancel_left {g : β →*₀o γ} {f₁ f₂ : α →*₀o β} (hg : Function.Injective g) :\n    g.comp f₁ = g.comp f₂ ↔ f₁ = f₂ :=\n  ⟨fun h => ext fun a => hg <| by rw [← comp_apply, h, comp_apply], congr_arg _⟩\n\n"}
{"name":"OrderMonoidWithZeroHom.coe_mul","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : LinearOrderedCommMonoidWithZero α\ninst✝ : LinearOrderedCommMonoidWithZero β\nf g : OrderMonoidWithZeroHom α β\n⊢ Eq (⇑(HMul.hMul f g)) (HMul.hMul ⇑f ⇑g)","decl":"@[simp]\ntheorem coe_mul (f g : α →*₀o β) : ⇑(f * g) = f * g :=\n  rfl\n\n"}
{"name":"OrderMonoidWithZeroHom.mul_apply","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : LinearOrderedCommMonoidWithZero α\ninst✝ : LinearOrderedCommMonoidWithZero β\nf g : OrderMonoidWithZeroHom α β\na : α\n⊢ Eq ((HMul.hMul f g) a) (HMul.hMul (f a) (g a))","decl":"@[simp]\ntheorem mul_apply (f g : α →*₀o β) (a : α) : (f * g) a = f a * g a :=\n  rfl\n\n"}
{"name":"OrderMonoidWithZeroHom.mul_comp","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝² : LinearOrderedCommMonoidWithZero α\ninst✝¹ : LinearOrderedCommMonoidWithZero β\ninst✝ : LinearOrderedCommMonoidWithZero γ\ng₁ g₂ : OrderMonoidWithZeroHom β γ\nf : OrderMonoidWithZeroHom α β\n⊢ Eq ((HMul.hMul g₁ g₂).comp f) (HMul.hMul (g₁.comp f) (g₂.comp f))","decl":"theorem mul_comp (g₁ g₂ : β →*₀o γ) (f : α →*₀o β) : (g₁ * g₂).comp f = g₁.comp f * g₂.comp f :=\n  rfl\n\n"}
{"name":"OrderMonoidWithZeroHom.comp_mul","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝² : LinearOrderedCommMonoidWithZero α\ninst✝¹ : LinearOrderedCommMonoidWithZero β\ninst✝ : LinearOrderedCommMonoidWithZero γ\ng : OrderMonoidWithZeroHom β γ\nf₁ f₂ : OrderMonoidWithZeroHom α β\n⊢ Eq (g.comp (HMul.hMul f₁ f₂)) (HMul.hMul (g.comp f₁) (g.comp f₂))","decl":"theorem comp_mul (g : β →*₀o γ) (f₁ f₂ : α →*₀o β) : g.comp (f₁ * f₂) = g.comp f₁ * g.comp f₂ :=\n  ext fun _ => map_mul g _ _\n\n"}
{"name":"OrderMonoidWithZeroHom.toMonoidWithZeroHom_eq_coe","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"α : Type u_2\nβ : Type u_3\nhα : Preorder α\nhα' : MulZeroOneClass α\nhβ : Preorder β\nhβ' : MulZeroOneClass β\nf : OrderMonoidWithZeroHom α β\n⊢ Eq f.toMonoidWithZeroHom ↑f","decl":"@[simp]\ntheorem toMonoidWithZeroHom_eq_coe (f : α →*₀o β) : f.toMonoidWithZeroHom = f := by\n  rfl\n\n"}
{"name":"OrderMonoidWithZeroHom.toOrderMonoidHom_eq_coe","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"α : Type u_2\nβ : Type u_3\nhα : Preorder α\nhα' : MulZeroOneClass α\nhβ : Preorder β\nhβ' : MulZeroOneClass β\nf : OrderMonoidWithZeroHom α β\n⊢ Eq f.toOrderMonoidHom ↑f","decl":"@[simp]\ntheorem toOrderMonoidHom_eq_coe (f : α →*₀o β) : f.toOrderMonoidHom = f :=\n  rfl\n\n"}
{"name":"OrderMonoidIso.unitsWithZero_toFun","module":"Mathlib.Algebra.Order.Hom.Monoid","initialProofState":"α : Type u_6\ninst✝¹ : Group α\ninst✝ : Preorder α\na : Units (WithZero α)\n⊢ Eq (OrderMonoidIso.unitsWithZero a) (WithZero.unzero ⋯)","decl":"/-- Any ordered group is isomorphic to the units of itself adjoined with `0`. -/\n@[simps! toFun]\ndef OrderMonoidIso.unitsWithZero {α : Type*} [Group α] [Preorder α] : (WithZero α)ˣ ≃*o α where\n  toMulEquiv := WithZero.unitsWithZeroEquiv\n  map_le_map_iff' {a b} := by simp [WithZero.unitsWithZeroEquiv]\n"}
