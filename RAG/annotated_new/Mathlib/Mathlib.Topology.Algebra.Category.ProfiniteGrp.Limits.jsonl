{"name":"ProfiniteGrp.toLimit_fun_continuous","module":"Mathlib.Topology.Algebra.Category.ProfiniteGrp.Limits","initialProofState":"P : ProfiniteGrp.{u}\n⊢ Continuous ⇑P.toLimit_fun","decl":"lemma toLimit_fun_continuous (P : ProfiniteGrp.{u}) : Continuous (toLimit_fun P) := by\n  apply continuous_induced_rng.mpr (continuous_pi _)\n  intro H\n  dsimp only [Functor.comp_obj, CompHausLike.toCompHausLike_obj, CompHausLike.compHausLikeToTop_obj,\n    CompHausLike.coe_of, Functor.comp_map, CompHausLike.toCompHausLike_map,\n    CompHausLike.compHausLikeToTop_map, Set.mem_setOf_eq, toLimit_fun,\n    MonoidHom.coe_mk, OneHom.coe_mk, Function.comp_apply]\n  apply Continuous.mk\n  intro s _\n  rw [← (Set.biUnion_preimage_singleton QuotientGroup.mk s)]\n  refine isOpen_iUnion (fun i ↦ isOpen_iUnion (fun _ ↦ ?_))\n  convert IsOpen.leftCoset H.toOpenSubgroup.isOpen' (Quotient.out i)\n  ext x\n  simp only [Set.mem_preimage, Set.mem_singleton_iff]\n  nth_rw 1 [← QuotientGroup.out_eq' i, eq_comm, QuotientGroup.eq]\n  exact Iff.symm (Set.mem_smul_set_iff_inv_smul_mem)\n\n"}
{"name":"ProfiniteGrp.denseRange_toLimit","module":"Mathlib.Topology.Algebra.Category.ProfiniteGrp.Limits","initialProofState":"P : ProfiniteGrp.{u}\n⊢ DenseRange ⇑P.toLimit.hom","decl":"/--An auxiliary result, superceded by `toLimit_surjective`.-/\ntheorem denseRange_toLimit (P : ProfiniteGrp.{u}) : DenseRange (toLimit P) := by\n  apply dense_iff_inter_open.mpr\n  rintro U ⟨s, hsO, hsv⟩ ⟨⟨spc, hspc⟩, uDefaultSpec⟩\n  simp_rw [← hsv, Set.mem_preimage] at uDefaultSpec\n  rcases (isOpen_pi_iff.mp hsO) _ uDefaultSpec with ⟨J, fJ, hJ1, hJ2⟩\n  let M := iInf (fun (j : J) => j.1.1.1)\n  have hM : M.Normal := Subgroup.normal_iInf_normal fun j => j.1.isNormal'\n  have hMOpen : IsOpen (M : Set P) := by\n    rw [Subgroup.coe_iInf]\n    exact isOpen_iInter_of_finite fun i => i.1.1.isOpen'\n  let m : OpenNormalSubgroup P := { M with isOpen' := hMOpen }\n  rcases QuotientGroup.mk'_surjective M (spc m) with ⟨origin, horigin⟩\n  use (toLimit P) origin\n  refine ⟨?_, origin, rfl⟩\n  rw [← hsv]\n  apply hJ2\n  intro a a_in_J\n  let M_to_Na : m ⟶ a := (iInf_le (fun (j : J) => j.1.1.1) ⟨a, a_in_J⟩).hom\n  rw [← (P.toLimit origin).property M_to_Na]\n  show (P.toFiniteQuotientFunctor.map M_to_Na) (QuotientGroup.mk' M origin) ∈ _\n  rw [horigin]\n  exact Set.mem_of_eq_of_mem (hspc M_to_Na) (hJ1 a a_in_J).2\n\n"}
{"name":"ProfiniteGrp.toLimit_surjective","module":"Mathlib.Topology.Algebra.Category.ProfiniteGrp.Limits","initialProofState":"P : ProfiniteGrp.{u}\n⊢ Function.Surjective ⇑P.toLimit.hom","decl":"theorem toLimit_surjective (P : ProfiniteGrp.{u}) : Function.Surjective (toLimit P) := by\n  have : IsClosed (Set.range P.toLimit) :=\n    P.toLimit.hom.continuous_toFun.isClosedMap.isClosed_range\n  rw [← Set.range_eq_univ, ← closure_eq_iff_isClosed.mpr this,\n    Dense.closure_eq (denseRange_toLimit P)]\n\n"}
{"name":"ProfiniteGrp.toLimit_injective","module":"Mathlib.Topology.Algebra.Category.ProfiniteGrp.Limits","initialProofState":"P : ProfiniteGrp.{u}\n⊢ Function.Injective ⇑P.toLimit.hom","decl":"theorem toLimit_injective (P : ProfiniteGrp.{u}) : Function.Injective (toLimit P) := by\n  show Function.Injective (toLimit P).hom.toMonoidHom\n  rw [← MonoidHom.ker_eq_bot_iff, Subgroup.eq_bot_iff_forall]\n  intro x h\n  by_contra xne1\n  rcases exist_openNormalSubgroup_sub_open_nhd_of_one (isOpen_compl_singleton)\n    (Set.mem_compl_singleton_iff.mpr fun a => xne1 a.symm) with ⟨H, hH⟩\n  exact hH ((QuotientGroup.eq_one_iff x).mp (congrFun (Subtype.val_inj.mpr h) H)) rfl\n\n"}
{"name":"ProfiniteGrp.isIso_toLimit","module":"Mathlib.Topology.Algebra.Category.ProfiniteGrp.Limits","initialProofState":"P : ProfiniteGrp.{u}\n⊢ CategoryTheory.IsIso P.toLimit","decl":"instance isIso_toLimit (P : ProfiniteGrp.{u}) : IsIso (toLimit P) := by\n  rw [CategoryTheory.ConcreteCategory.isIso_iff_bijective]\n  exact ⟨toLimit_injective P, toLimit_surjective P⟩\n\n"}
