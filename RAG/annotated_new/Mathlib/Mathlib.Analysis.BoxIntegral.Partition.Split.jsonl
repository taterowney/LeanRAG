{"name":"BoxIntegral.Box.coe_splitLower","module":"Mathlib.Analysis.BoxIntegral.Partition.Split","initialProofState":"ι : Type u_1\nI : BoxIntegral.Box ι\ni : ι\nx : Real\n⊢ Eq (↑(I.splitLower i x)) (Inter.inter (↑I) (setOf fun y => LE.le (y i) x))","decl":"@[simp]\ntheorem coe_splitLower : (splitLower I i x : Set (ι → ℝ)) = ↑I ∩ { y | y i ≤ x } := by\n  rw [splitLower, coe_mk']\n  ext y\n  simp only [mem_univ_pi, mem_Ioc, mem_inter_iff, mem_coe, mem_setOf_eq, forall_and, ← Pi.le_def,\n    le_update_iff, le_min_iff, and_assoc, and_forall_ne (p := fun j => y j ≤ upper I j) i, mem_def]\n  rw [and_comm (a := y i ≤ x)]\n\n"}
{"name":"BoxIntegral.Box.splitLower_le","module":"Mathlib.Analysis.BoxIntegral.Partition.Split","initialProofState":"ι : Type u_1\nI : BoxIntegral.Box ι\ni : ι\nx : Real\n⊢ LE.le (I.splitLower i x) ↑I","decl":"theorem splitLower_le : I.splitLower i x ≤ I :=\n  withBotCoe_subset_iff.1 <| by simp\n\n"}
{"name":"BoxIntegral.Box.splitLower_eq_bot","module":"Mathlib.Analysis.BoxIntegral.Partition.Split","initialProofState":"ι : Type u_1\nI : BoxIntegral.Box ι\ni : ι\nx : Real\n⊢ Iff (Eq (I.splitLower i x) Bot.bot) (LE.le x (I.lower i))","decl":"@[simp]\ntheorem splitLower_eq_bot {i x} : I.splitLower i x = ⊥ ↔ x ≤ I.lower i := by\n  classical\n  rw [splitLower, mk'_eq_bot, exists_update_iff I.upper fun j y => y ≤ I.lower j]\n  simp [(I.lower_lt_upper _).not_le]\n\n"}
{"name":"BoxIntegral.Box.splitLower_eq_self","module":"Mathlib.Analysis.BoxIntegral.Partition.Split","initialProofState":"ι : Type u_1\nI : BoxIntegral.Box ι\ni : ι\nx : Real\n⊢ Iff (Eq (I.splitLower i x) ↑I) (LE.le (I.upper i) x)","decl":"@[simp]\ntheorem splitLower_eq_self : I.splitLower i x = I ↔ I.upper i ≤ x := by\n  simp [splitLower, update_eq_iff]\n\n"}
{"name":"BoxIntegral.Box.splitLower_def","module":"Mathlib.Analysis.BoxIntegral.Partition.Split","initialProofState":"ι : Type u_1\nI : BoxIntegral.Box ι\ninst✝ : DecidableEq ι\ni : ι\nx : Real\nh : Membership.mem (Set.Ioo (I.lower i) (I.upper i)) x\nh' : optParam (∀ (j : ι), LT.lt (I.lower j) (Function.update I.upper i x j)) ⋯\n⊢ Eq (I.splitLower i x) ↑{ lower := I.lower, upper := Function.update I.upper i x, lower_lt_upper := h' }","decl":"theorem splitLower_def [DecidableEq ι] {i x} (h : x ∈ Ioo (I.lower i) (I.upper i))\n    (h' : ∀ j, I.lower j < update I.upper i x j :=\n      (forall_update_iff I.upper fun j y => I.lower j < y).2\n        ⟨h.1, fun _ _ => I.lower_lt_upper _⟩) :\n    I.splitLower i x = (⟨I.lower, update I.upper i x, h'⟩ : Box ι) := by\n  simp (config := { unfoldPartialApp := true }) only [splitLower, mk'_eq_coe, min_eq_left h.2.le,\n    update, and_self]\n\n"}
{"name":"BoxIntegral.Box.coe_splitUpper","module":"Mathlib.Analysis.BoxIntegral.Partition.Split","initialProofState":"ι : Type u_1\nI : BoxIntegral.Box ι\ni : ι\nx : Real\n⊢ Eq (↑(I.splitUpper i x)) (Inter.inter (↑I) (setOf fun y => LT.lt x (y i)))","decl":"@[simp]\ntheorem coe_splitUpper : (splitUpper I i x : Set (ι → ℝ)) = ↑I ∩ { y | x < y i } := by\n  classical\n  rw [splitUpper, coe_mk']\n  ext y\n  simp only [mem_univ_pi, mem_Ioc, mem_inter_iff, mem_coe, mem_setOf_eq, forall_and,\n    forall_update_iff I.lower fun j z => z < y j, max_lt_iff, and_assoc (a := x < y i),\n    and_forall_ne (p := fun j => lower I j < y j) i, mem_def]\n  exact and_comm\n\n"}
{"name":"BoxIntegral.Box.splitUpper_le","module":"Mathlib.Analysis.BoxIntegral.Partition.Split","initialProofState":"ι : Type u_1\nI : BoxIntegral.Box ι\ni : ι\nx : Real\n⊢ LE.le (I.splitUpper i x) ↑I","decl":"theorem splitUpper_le : I.splitUpper i x ≤ I :=\n  withBotCoe_subset_iff.1 <| by simp\n\n"}
{"name":"BoxIntegral.Box.splitUpper_eq_bot","module":"Mathlib.Analysis.BoxIntegral.Partition.Split","initialProofState":"ι : Type u_1\nI : BoxIntegral.Box ι\ni : ι\nx : Real\n⊢ Iff (Eq (I.splitUpper i x) Bot.bot) (LE.le (I.upper i) x)","decl":"@[simp]\ntheorem splitUpper_eq_bot {i x} : I.splitUpper i x = ⊥ ↔ I.upper i ≤ x := by\n  classical\n  rw [splitUpper, mk'_eq_bot, exists_update_iff I.lower fun j y => I.upper j ≤ y]\n  simp [(I.lower_lt_upper _).not_le]\n\n"}
{"name":"BoxIntegral.Box.splitUpper_eq_self","module":"Mathlib.Analysis.BoxIntegral.Partition.Split","initialProofState":"ι : Type u_1\nI : BoxIntegral.Box ι\ni : ι\nx : Real\n⊢ Iff (Eq (I.splitUpper i x) ↑I) (LE.le x (I.lower i))","decl":"@[simp]\ntheorem splitUpper_eq_self : I.splitUpper i x = I ↔ x ≤ I.lower i := by\n  simp [splitUpper, update_eq_iff]\n\n"}
{"name":"BoxIntegral.Box.splitUpper_def","module":"Mathlib.Analysis.BoxIntegral.Partition.Split","initialProofState":"ι : Type u_1\nI : BoxIntegral.Box ι\ninst✝ : DecidableEq ι\ni : ι\nx : Real\nh : Membership.mem (Set.Ioo (I.lower i) (I.upper i)) x\nh' : optParam (∀ (j : ι), LT.lt (Function.update I.lower i x j) (I.upper j)) ⋯\n⊢ Eq (I.splitUpper i x) ↑{ lower := Function.update I.lower i x, upper := I.upper, lower_lt_upper := h' }","decl":"theorem splitUpper_def [DecidableEq ι] {i x} (h : x ∈ Ioo (I.lower i) (I.upper i))\n    (h' : ∀ j, update I.lower i x j < I.upper j :=\n      (forall_update_iff I.lower fun j y => y < I.upper j).2\n        ⟨h.2, fun _ _ => I.lower_lt_upper _⟩) :\n    I.splitUpper i x = (⟨update I.lower i x, I.upper, h'⟩ : Box ι) := by\n  simp (config := { unfoldPartialApp := true }) only [splitUpper, mk'_eq_coe, max_eq_left h.1.le,\n    update, and_self]\n\n"}
{"name":"BoxIntegral.Box.disjoint_splitLower_splitUpper","module":"Mathlib.Analysis.BoxIntegral.Partition.Split","initialProofState":"ι : Type u_1\nI : BoxIntegral.Box ι\ni : ι\nx : Real\n⊢ Disjoint (I.splitLower i x) (I.splitUpper i x)","decl":"theorem disjoint_splitLower_splitUpper (I : Box ι) (i : ι) (x : ℝ) :\n    Disjoint (I.splitLower i x) (I.splitUpper i x) := by\n  rw [← disjoint_withBotCoe, coe_splitLower, coe_splitUpper]\n  refine (Disjoint.inf_left' _ ?_).inf_right' _\n  rw [Set.disjoint_left]\n  exact fun y (hle : y i ≤ x) hlt => not_lt_of_le hle hlt\n\n"}
{"name":"BoxIntegral.Box.splitLower_ne_splitUpper","module":"Mathlib.Analysis.BoxIntegral.Partition.Split","initialProofState":"ι : Type u_1\nI : BoxIntegral.Box ι\ni : ι\nx : Real\n⊢ Ne (I.splitLower i x) (I.splitUpper i x)","decl":"theorem splitLower_ne_splitUpper (I : Box ι) (i : ι) (x : ℝ) :\n    I.splitLower i x ≠ I.splitUpper i x := by\n  cases' le_or_lt x (I.lower i) with h\n  · rw [splitUpper_eq_self.2 h, splitLower_eq_bot.2 h]\n    exact WithBot.bot_ne_coe\n  · refine (disjoint_splitLower_splitUpper I i x).ne ?_\n    rwa [Ne, splitLower_eq_bot, not_le]\n\n"}
{"name":"BoxIntegral.Prepartition.mem_split_iff","module":"Mathlib.Analysis.BoxIntegral.Partition.Split","initialProofState":"ι : Type u_1\nI J : BoxIntegral.Box ι\ni : ι\nx : Real\n⊢ Iff (Membership.mem (BoxIntegral.Prepartition.split I i x) J) (Or (Eq (↑J) (I.splitLower i x)) (Eq (↑J) (I.splitUpper i x)))","decl":"@[simp]\ntheorem mem_split_iff : J ∈ split I i x ↔ ↑J = I.splitLower i x ∨ ↑J = I.splitUpper i x := by\n  simp [split]\n\n"}
{"name":"BoxIntegral.Prepartition.mem_split_iff'","module":"Mathlib.Analysis.BoxIntegral.Partition.Split","initialProofState":"ι : Type u_1\nI J : BoxIntegral.Box ι\ni : ι\nx : Real\n⊢ Iff (Membership.mem (BoxIntegral.Prepartition.split I i x) J) (Or (Eq (↑J) (Inter.inter (↑I) (setOf fun y => LE.le (y i) x))) (Eq (↑J) (Inter.inter (↑I) (setOf fun y => LT.lt x (y i)))))","decl":"theorem mem_split_iff' : J ∈ split I i x ↔\n    (J : Set (ι → ℝ)) = ↑I ∩ { y | y i ≤ x } ∨ (J : Set (ι → ℝ)) = ↑I ∩ { y | x < y i } := by\n  simp [mem_split_iff, ← Box.withBotCoe_inj]\n\n"}
{"name":"BoxIntegral.Prepartition.iUnion_split","module":"Mathlib.Analysis.BoxIntegral.Partition.Split","initialProofState":"ι : Type u_1\nI : BoxIntegral.Box ι\ni : ι\nx : Real\n⊢ Eq (BoxIntegral.Prepartition.split I i x).iUnion ↑I","decl":"@[simp]\ntheorem iUnion_split (I : Box ι) (i : ι) (x : ℝ) : (split I i x).iUnion = I := by\n  simp [split, ← inter_union_distrib_left, ← setOf_or, le_or_lt]\n\n"}
{"name":"BoxIntegral.Prepartition.isPartitionSplit","module":"Mathlib.Analysis.BoxIntegral.Partition.Split","initialProofState":"ι : Type u_1\nI : BoxIntegral.Box ι\ni : ι\nx : Real\n⊢ (BoxIntegral.Prepartition.split I i x).IsPartition","decl":"theorem isPartitionSplit (I : Box ι) (i : ι) (x : ℝ) : IsPartition (split I i x) :=\n  isPartition_iff_iUnion_eq.2 <| iUnion_split I i x\n\n-- Porting note: In the type, changed `Option.elim` to `Option.elim'`\n"}
{"name":"BoxIntegral.Prepartition.sum_split_boxes","module":"Mathlib.Analysis.BoxIntegral.Partition.Split","initialProofState":"ι : Type u_1\nM : Type u_3\ninst✝ : AddCommMonoid M\nI : BoxIntegral.Box ι\ni : ι\nx : Real\nf : BoxIntegral.Box ι → M\n⊢ Eq ((BoxIntegral.Prepartition.split I i x).boxes.sum fun J => f J) (HAdd.hAdd (Option.elim' 0 f (I.splitLower i x)) (Option.elim' 0 f (I.splitUpper i x)))","decl":"theorem sum_split_boxes {M : Type*} [AddCommMonoid M] (I : Box ι) (i : ι) (x : ℝ) (f : Box ι → M) :\n    (∑ J ∈ (split I i x).boxes, f J) =\n      (I.splitLower i x).elim' 0 f + (I.splitUpper i x).elim' 0 f := by\n  classical\n  rw [split, sum_ofWithBot, Finset.sum_pair (I.splitLower_ne_splitUpper i x)]\n\n"}
{"name":"BoxIntegral.Prepartition.split_of_not_mem_Ioo","module":"Mathlib.Analysis.BoxIntegral.Partition.Split","initialProofState":"ι : Type u_1\nI : BoxIntegral.Box ι\ni : ι\nx : Real\nh : Not (Membership.mem (Set.Ioo (I.lower i) (I.upper i)) x)\n⊢ Eq (BoxIntegral.Prepartition.split I i x) Top.top","decl":"/-- If `x ∉ (I.lower i, I.upper i)`, then the hyperplane `{y | y i = x}` does not split `I`. -/\ntheorem split_of_not_mem_Ioo (h : x ∉ Ioo (I.lower i) (I.upper i)) : split I i x = ⊤ := by\n  refine ((isPartitionTop I).eq_of_boxes_subset fun J hJ => ?_).symm\n  rcases mem_top.1 hJ with rfl; clear hJ\n  rw [mem_boxes, mem_split_iff]\n  rw [mem_Ioo, not_and_or, not_lt, not_lt] at h\n  cases h <;> [right; left]\n  · rwa [eq_comm, Box.splitUpper_eq_self]\n  · rwa [eq_comm, Box.splitLower_eq_self]\n\n"}
{"name":"BoxIntegral.Prepartition.coe_eq_of_mem_split_of_mem_le","module":"Mathlib.Analysis.BoxIntegral.Partition.Split","initialProofState":"ι : Type u_1\nI J : BoxIntegral.Box ι\ni : ι\nx : Real\ny : ι → Real\nh₁ : Membership.mem (BoxIntegral.Prepartition.split I i x) J\nh₂ : Membership.mem J y\nh₃ : LE.le (y i) x\n⊢ Eq (↑J) (Inter.inter (↑I) (setOf fun y => LE.le (y i) x))","decl":"theorem coe_eq_of_mem_split_of_mem_le {y : ι → ℝ} (h₁ : J ∈ split I i x) (h₂ : y ∈ J)\n    (h₃ : y i ≤ x) : (J : Set (ι → ℝ)) = ↑I ∩ { y | y i ≤ x } := by\n  refine (mem_split_iff'.1 h₁).resolve_right fun H => ?_\n  rw [← Box.mem_coe, H] at h₂\n  exact h₃.not_lt h₂.2\n\n"}
{"name":"BoxIntegral.Prepartition.coe_eq_of_mem_split_of_lt_mem","module":"Mathlib.Analysis.BoxIntegral.Partition.Split","initialProofState":"ι : Type u_1\nI J : BoxIntegral.Box ι\ni : ι\nx : Real\ny : ι → Real\nh₁ : Membership.mem (BoxIntegral.Prepartition.split I i x) J\nh₂ : Membership.mem J y\nh₃ : LT.lt x (y i)\n⊢ Eq (↑J) (Inter.inter (↑I) (setOf fun y => LT.lt x (y i)))","decl":"theorem coe_eq_of_mem_split_of_lt_mem {y : ι → ℝ} (h₁ : J ∈ split I i x) (h₂ : y ∈ J)\n    (h₃ : x < y i) : (J : Set (ι → ℝ)) = ↑I ∩ { y | x < y i } := by\n  refine (mem_split_iff'.1 h₁).resolve_left fun H => ?_\n  rw [← Box.mem_coe, H] at h₂\n  exact h₃.not_le h₂.2\n\n"}
{"name":"BoxIntegral.Prepartition.restrict_split","module":"Mathlib.Analysis.BoxIntegral.Partition.Split","initialProofState":"ι : Type u_1\nI J : BoxIntegral.Box ι\nh : LE.le I J\ni : ι\nx : Real\n⊢ Eq ((BoxIntegral.Prepartition.split J i x).restrict I) (BoxIntegral.Prepartition.split I i x)","decl":"@[simp]\ntheorem restrict_split (h : I ≤ J) (i : ι) (x : ℝ) : (split J i x).restrict I = split I i x := by\n  refine ((isPartitionSplit J i x).restrict h).eq_of_boxes_subset ?_\n  simp only [Finset.subset_iff, mem_boxes, mem_restrict', exists_prop, mem_split_iff']\n  have : ∀ s, (I ∩ s : Set (ι → ℝ)) ⊆ J := fun s => inter_subset_left.trans h\n  rintro J₁ ⟨J₂, H₂ | H₂, H₁⟩ <;> [left; right] <;>\n    simp [H₁, H₂, inter_left_comm (I : Set (ι → ℝ)), this]\n\n"}
{"name":"BoxIntegral.Prepartition.inf_split","module":"Mathlib.Analysis.BoxIntegral.Partition.Split","initialProofState":"ι : Type u_1\nI : BoxIntegral.Box ι\nπ : BoxIntegral.Prepartition I\ni : ι\nx : Real\n⊢ Eq (Min.min π (BoxIntegral.Prepartition.split I i x)) (π.biUnion fun J => BoxIntegral.Prepartition.split J i x)","decl":"theorem inf_split (π : Prepartition I) (i : ι) (x : ℝ) :\n    π ⊓ split I i x = π.biUnion fun J => split J i x :=\n  biUnion_congr_of_le rfl fun _ hJ => restrict_split hJ i x\n\n"}
{"name":"BoxIntegral.Prepartition.splitMany_empty","module":"Mathlib.Analysis.BoxIntegral.Partition.Split","initialProofState":"ι : Type u_1\nI : BoxIntegral.Box ι\n⊢ Eq (BoxIntegral.Prepartition.splitMany I EmptyCollection.emptyCollection) Top.top","decl":"@[simp]\ntheorem splitMany_empty (I : Box ι) : splitMany I ∅ = ⊤ :=\n  Finset.inf_empty\n\n"}
{"name":"BoxIntegral.Prepartition.splitMany_insert","module":"Mathlib.Analysis.BoxIntegral.Partition.Split","initialProofState":"ι : Type u_1\nI : BoxIntegral.Box ι\ns : Finset (Prod ι Real)\np : Prod ι Real\n⊢ Eq (BoxIntegral.Prepartition.splitMany I (Insert.insert p s)) (Min.min (BoxIntegral.Prepartition.splitMany I s) (BoxIntegral.Prepartition.split I p.1 p.2))","decl":"open scoped Classical in\n@[simp]\ntheorem splitMany_insert (I : Box ι) (s : Finset (ι × ℝ)) (p : ι × ℝ) :\n    splitMany I (insert p s) = splitMany I s ⊓ split I p.1 p.2 := by\n  rw [splitMany, Finset.inf_insert, inf_comm, splitMany]\n\n"}
{"name":"BoxIntegral.Prepartition.splitMany_le_split","module":"Mathlib.Analysis.BoxIntegral.Partition.Split","initialProofState":"ι : Type u_1\nI : BoxIntegral.Box ι\ns : Finset (Prod ι Real)\np : Prod ι Real\nhp : Membership.mem s p\n⊢ LE.le (BoxIntegral.Prepartition.splitMany I s) (BoxIntegral.Prepartition.split I p.1 p.2)","decl":"theorem splitMany_le_split (I : Box ι) {s : Finset (ι × ℝ)} {p : ι × ℝ} (hp : p ∈ s) :\n    splitMany I s ≤ split I p.1 p.2 :=\n  Finset.inf_le hp\n\n"}
{"name":"BoxIntegral.Prepartition.isPartition_splitMany","module":"Mathlib.Analysis.BoxIntegral.Partition.Split","initialProofState":"ι : Type u_1\nI : BoxIntegral.Box ι\ns : Finset (Prod ι Real)\n⊢ (BoxIntegral.Prepartition.splitMany I s).IsPartition","decl":"theorem isPartition_splitMany (I : Box ι) (s : Finset (ι × ℝ)) : IsPartition (splitMany I s) := by\n  classical\n  exact Finset.induction_on s (by simp only [splitMany_empty, isPartitionTop]) fun a s _ hs => by\n    simpa only [splitMany_insert, inf_split] using hs.biUnion fun J _ => isPartitionSplit _ _ _\n\n"}
{"name":"BoxIntegral.Prepartition.iUnion_splitMany","module":"Mathlib.Analysis.BoxIntegral.Partition.Split","initialProofState":"ι : Type u_1\nI : BoxIntegral.Box ι\ns : Finset (Prod ι Real)\n⊢ Eq (BoxIntegral.Prepartition.splitMany I s).iUnion ↑I","decl":"@[simp]\ntheorem iUnion_splitMany (I : Box ι) (s : Finset (ι × ℝ)) : (splitMany I s).iUnion = I :=\n  (isPartition_splitMany I s).iUnion_eq\n\n"}
{"name":"BoxIntegral.Prepartition.inf_splitMany","module":"Mathlib.Analysis.BoxIntegral.Partition.Split","initialProofState":"ι : Type u_1\nI : BoxIntegral.Box ι\nπ : BoxIntegral.Prepartition I\ns : Finset (Prod ι Real)\n⊢ Eq (Min.min π (BoxIntegral.Prepartition.splitMany I s)) (π.biUnion fun J => BoxIntegral.Prepartition.splitMany J s)","decl":"theorem inf_splitMany {I : Box ι} (π : Prepartition I) (s : Finset (ι × ℝ)) :\n    π ⊓ splitMany I s = π.biUnion fun J => splitMany J s := by\n  classical\n  induction' s using Finset.induction_on with p s _ ihp\n  · simp\n  · simp_rw [splitMany_insert, ← inf_assoc, ihp, inf_split, biUnion_assoc]\n\n"}
{"name":"BoxIntegral.Prepartition.not_disjoint_imp_le_of_subset_of_mem_splitMany","module":"Mathlib.Analysis.BoxIntegral.Partition.Split","initialProofState":"ι : Type u_1\nI J Js : BoxIntegral.Box ι\ns : Finset (Prod ι Real)\nH : ∀ (i : ι), HasSubset.Subset (Insert.insert { fst := i, snd := J.lower i } (Singleton.singleton { fst := i, snd := J.upper i })) s\nHJs : Membership.mem (BoxIntegral.Prepartition.splitMany I s) Js\nHn : Not (Disjoint ↑J ↑Js)\n⊢ LE.le Js J","decl":"open scoped Classical in\n/-- Let `s : Finset (ι × ℝ)` be a set of hyperplanes `{x : ι → ℝ | x i = r}` in `ι → ℝ` encoded as\npairs `(i, r)`. Suppose that this set contains all faces of a box `J`. The hyperplanes of `s` split\na box `I` into subboxes. Let `Js` be one of them. If `J` and `Js` have nonempty intersection, then\n`Js` is a subbox of `J`. -/\ntheorem not_disjoint_imp_le_of_subset_of_mem_splitMany {I J Js : Box ι} {s : Finset (ι × ℝ)}\n    (H : ∀ i, {(i, J.lower i), (i, J.upper i)} ⊆ s) (HJs : Js ∈ splitMany I s)\n    (Hn : ¬Disjoint (J : WithBot (Box ι)) Js) : Js ≤ J := by\n  simp only [Finset.insert_subset_iff, Finset.singleton_subset_iff] at H\n  rcases Box.not_disjoint_coe_iff_nonempty_inter.mp Hn with ⟨x, hx, hxs⟩\n  refine fun y hy i => ⟨?_, ?_⟩\n  · rcases splitMany_le_split I (H i).1 HJs with ⟨Jl, Hmem : Jl ∈ split I i (J.lower i), Hle⟩\n    have := Hle hxs\n    rw [← Box.coe_subset_coe, coe_eq_of_mem_split_of_lt_mem Hmem this (hx i).1] at Hle\n    exact (Hle hy).2\n  · rcases splitMany_le_split I (H i).2 HJs with ⟨Jl, Hmem : Jl ∈ split I i (J.upper i), Hle⟩\n    have := Hle hxs\n    rw [← Box.coe_subset_coe, coe_eq_of_mem_split_of_mem_le Hmem this (hx i).2] at Hle\n    exact (Hle hy).2\n\n"}
{"name":"BoxIntegral.Prepartition.eventually_not_disjoint_imp_le_of_mem_splitMany","module":"Mathlib.Analysis.BoxIntegral.Partition.Split","initialProofState":"ι : Type u_1\ninst✝ : Finite ι\ns : Finset (BoxIntegral.Box ι)\n⊢ Filter.Eventually (fun t => ∀ (I J : BoxIntegral.Box ι), Membership.mem s J → ∀ (J' : BoxIntegral.Box ι), Membership.mem (BoxIntegral.Prepartition.splitMany I t) J' → Not (Disjoint ↑J ↑J') → LE.le J' J) Filter.atTop","decl":"/-- Let `s` be a finite set of boxes in `ℝⁿ = ι → ℝ`. Then there exists a finite set `t₀` of\nhyperplanes (namely, the set of all hyperfaces of boxes in `s`) such that for any `t ⊇ t₀`\nand any box `I` in `ℝⁿ` the following holds. The hyperplanes from `t` split `I` into subboxes.\nLet `J'` be one of them, and let `J` be one of the boxes in `s`. If these boxes have a nonempty\nintersection, then `J' ≤ J`. -/\ntheorem eventually_not_disjoint_imp_le_of_mem_splitMany (s : Finset (Box ι)) :\n    ∀ᶠ t : Finset (ι × ℝ) in atTop, ∀ (I : Box ι), ∀ J ∈ s, ∀ J' ∈ splitMany I t,\n      ¬Disjoint (J : WithBot (Box ι)) J' → J' ≤ J := by\n  classical\n  cases nonempty_fintype ι\n  refine eventually_atTop.2\n    ⟨s.biUnion fun J => Finset.univ.biUnion fun i => {(i, J.lower i), (i, J.upper i)},\n      fun t ht I J hJ J' hJ' => not_disjoint_imp_le_of_subset_of_mem_splitMany (fun i => ?_) hJ'⟩\n  exact fun p hp =>\n    ht (Finset.mem_biUnion.2 ⟨J, hJ, Finset.mem_biUnion.2 ⟨i, Finset.mem_univ _, hp⟩⟩)\n\n"}
{"name":"BoxIntegral.Prepartition.eventually_splitMany_inf_eq_filter","module":"Mathlib.Analysis.BoxIntegral.Partition.Split","initialProofState":"ι : Type u_1\nI : BoxIntegral.Box ι\ninst✝ : Finite ι\nπ : BoxIntegral.Prepartition I\n⊢ Filter.Eventually (fun t => Eq (Min.min π (BoxIntegral.Prepartition.splitMany I t)) ((BoxIntegral.Prepartition.splitMany I t).filter fun J => HasSubset.Subset (↑J) π.iUnion)) Filter.atTop","decl":"theorem eventually_splitMany_inf_eq_filter (π : Prepartition I) :\n    ∀ᶠ t : Finset (ι × ℝ) in atTop,\n      π ⊓ splitMany I t = (splitMany I t).filter fun J => ↑J ⊆ π.iUnion := by\n  refine (eventually_not_disjoint_imp_le_of_mem_splitMany π.boxes).mono fun t ht => ?_\n  refine le_antisymm ((biUnion_le_iff _).2 fun J hJ => ?_) (le_inf (fun J hJ => ?_) (filter_le _ _))\n  · refine ofWithBot_mono ?_\n    simp only [Finset.mem_image, exists_prop, mem_boxes, mem_filter]\n    rintro _ ⟨J₁, h₁, rfl⟩ hne\n    refine ⟨_, ⟨J₁, ⟨h₁, Subset.trans ?_ (π.subset_iUnion hJ)⟩, rfl⟩, le_rfl⟩\n    exact ht I J hJ J₁ h₁ (mt disjoint_iff.1 hne)\n  · rw [mem_filter] at hJ\n    rcases Set.mem_iUnion₂.1 (hJ.2 J.upper_mem) with ⟨J', hJ', hmem⟩\n    refine ⟨J', hJ', ht I _ hJ' _ hJ.1 <| Box.not_disjoint_coe_iff_nonempty_inter.2 ?_⟩\n    exact ⟨J.upper, hmem, J.upper_mem⟩\n\n"}
{"name":"BoxIntegral.Prepartition.exists_splitMany_inf_eq_filter_of_finite","module":"Mathlib.Analysis.BoxIntegral.Partition.Split","initialProofState":"ι : Type u_1\nI : BoxIntegral.Box ι\ninst✝ : Finite ι\ns : Set (BoxIntegral.Prepartition I)\nhs : s.Finite\n⊢ Exists fun t => ∀ (π : BoxIntegral.Prepartition I), Membership.mem s π → Eq (Min.min π (BoxIntegral.Prepartition.splitMany I t)) ((BoxIntegral.Prepartition.splitMany I t).filter fun J => HasSubset.Subset (↑J) π.iUnion)","decl":"theorem exists_splitMany_inf_eq_filter_of_finite (s : Set (Prepartition I)) (hs : s.Finite) :\n    ∃ t : Finset (ι × ℝ),\n      ∀ π ∈ s, π ⊓ splitMany I t = (splitMany I t).filter fun J => ↑J ⊆ π.iUnion :=\n  haveI := fun π (_ : π ∈ s) => eventually_splitMany_inf_eq_filter π\n  (hs.eventually_all.2 this).exists\n\n"}
{"name":"BoxIntegral.Prepartition.IsPartition.exists_splitMany_le","module":"Mathlib.Analysis.BoxIntegral.Partition.Split","initialProofState":"ι : Type u_1\ninst✝ : Finite ι\nI : BoxIntegral.Box ι\nπ : BoxIntegral.Prepartition I\nh : π.IsPartition\n⊢ Exists fun s => LE.le (BoxIntegral.Prepartition.splitMany I s) π","decl":"/-- If `π` is a partition of `I`, then there exists a finite set `s` of hyperplanes such that\n`splitMany I s ≤ π`. -/\ntheorem IsPartition.exists_splitMany_le {I : Box ι} {π : Prepartition I} (h : IsPartition π) :\n    ∃ s, splitMany I s ≤ π := by\n  refine (eventually_splitMany_inf_eq_filter π).exists.imp fun s hs => ?_\n  rwa [h.iUnion_eq, filter_of_true, inf_eq_right] at hs\n  exact fun J hJ => le_of_mem _ hJ\n\n"}
{"name":"BoxIntegral.Prepartition.exists_iUnion_eq_diff","module":"Mathlib.Analysis.BoxIntegral.Partition.Split","initialProofState":"ι : Type u_1\nI : BoxIntegral.Box ι\ninst✝ : Finite ι\nπ : BoxIntegral.Prepartition I\n⊢ Exists fun π' => Eq π'.iUnion (SDiff.sdiff (↑I) π.iUnion)","decl":"/-- For every prepartition `π` of `I` there exists a prepartition that covers exactly\n`I \\ π.iUnion`. -/\ntheorem exists_iUnion_eq_diff (π : Prepartition I) :\n    ∃ π' : Prepartition I, π'.iUnion = ↑I \\ π.iUnion := by\n  rcases π.eventually_splitMany_inf_eq_filter.exists with ⟨s, hs⟩\n  use (splitMany I s).filter fun J => ¬(J : Set (ι → ℝ)) ⊆ π.iUnion\n  simp [← hs]\n\n"}
{"name":"BoxIntegral.Prepartition.iUnion_compl","module":"Mathlib.Analysis.BoxIntegral.Partition.Split","initialProofState":"ι : Type u_1\nI : BoxIntegral.Box ι\ninst✝ : Finite ι\nπ : BoxIntegral.Prepartition I\n⊢ Eq π.compl.iUnion (SDiff.sdiff (↑I) π.iUnion)","decl":"@[simp]\ntheorem iUnion_compl (π : Prepartition I) : π.compl.iUnion = ↑I \\ π.iUnion :=\n  π.exists_iUnion_eq_diff.choose_spec\n\n"}
{"name":"BoxIntegral.Prepartition.compl_congr","module":"Mathlib.Analysis.BoxIntegral.Partition.Split","initialProofState":"ι : Type u_1\nI : BoxIntegral.Box ι\ninst✝ : Finite ι\nπ₁ π₂ : BoxIntegral.Prepartition I\nh : Eq π₁.iUnion π₂.iUnion\n⊢ Eq π₁.compl π₂.compl","decl":"/-- Since the definition of `BoxIntegral.Prepartition.compl` uses `Exists.choose`,\nthe result depends only on `π.iUnion`. -/\ntheorem compl_congr {π₁ π₂ : Prepartition I} (h : π₁.iUnion = π₂.iUnion) : π₁.compl = π₂.compl := by\n  dsimp only [compl]\n  congr 1\n  rw [h]\n\n"}
{"name":"BoxIntegral.Prepartition.IsPartition.compl_eq_bot","module":"Mathlib.Analysis.BoxIntegral.Partition.Split","initialProofState":"ι : Type u_1\nI : BoxIntegral.Box ι\ninst✝ : Finite ι\nπ : BoxIntegral.Prepartition I\nh : π.IsPartition\n⊢ Eq π.compl Bot.bot","decl":"theorem IsPartition.compl_eq_bot {π : Prepartition I} (h : IsPartition π) : π.compl = ⊥ := by\n  rw [← iUnion_eq_empty, iUnion_compl, h.iUnion_eq, diff_self]\n\n"}
{"name":"BoxIntegral.Prepartition.compl_top","module":"Mathlib.Analysis.BoxIntegral.Partition.Split","initialProofState":"ι : Type u_1\nI : BoxIntegral.Box ι\ninst✝ : Finite ι\n⊢ Eq Top.top.compl Bot.bot","decl":"@[simp]\ntheorem compl_top : (⊤ : Prepartition I).compl = ⊥ :=\n  (isPartitionTop I).compl_eq_bot\n\n"}
