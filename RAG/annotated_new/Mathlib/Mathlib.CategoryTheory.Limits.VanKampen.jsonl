{"name":"CategoryTheory.NatTrans.equifibered_of_isIso","module":"Mathlib.CategoryTheory.Limits.VanKampen","initialProofState":"J : Type v'\ninst‚úù¬≤ : CategoryTheory.Category.{u', v'} J\nC : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nF G : CategoryTheory.Functor J C\nŒ± : Quiver.Hom F G\ninst‚úù : CategoryTheory.IsIso Œ±\n‚ä¢ CategoryTheory.NatTrans.Equifibered Œ±","decl":"theorem NatTrans.equifibered_of_isIso {F G : J ‚•§ C} (Œ± : F ‚ü∂ G) [IsIso Œ±] : Equifibered Œ± :=\n  fun _ _ f => IsPullback.of_vert_isIso ‚ü®NatTrans.naturality _ f‚ü©\n\n"}
{"name":"CategoryTheory.NatTrans.Equifibered.comp","module":"Mathlib.CategoryTheory.Limits.VanKampen","initialProofState":"J : Type v'\ninst‚úù¬π : CategoryTheory.Category.{u', v'} J\nC : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF G H : CategoryTheory.Functor J C\nŒ± : Quiver.Hom F G\nŒ≤ : Quiver.Hom G H\nhŒ± : CategoryTheory.NatTrans.Equifibered Œ±\nhŒ≤ : CategoryTheory.NatTrans.Equifibered Œ≤\n‚ä¢ CategoryTheory.NatTrans.Equifibered (CategoryTheory.CategoryStruct.comp Œ± Œ≤)","decl":"theorem NatTrans.Equifibered.comp {F G H : J ‚•§ C} {Œ± : F ‚ü∂ G} {Œ≤ : G ‚ü∂ H} (hŒ± : Equifibered Œ±)\n    (hŒ≤ : Equifibered Œ≤) : Equifibered (Œ± ‚â´ Œ≤) :=\n  fun _ _ f => (hŒ± f).paste_vert (hŒ≤ f)\n\n"}
{"name":"CategoryTheory.NatTrans.Equifibered.whiskerRight","module":"Mathlib.CategoryTheory.Limits.VanKampen","initialProofState":"J : Type v'\ninst‚úù¬≥ : CategoryTheory.Category.{u', v'} J\nC : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nD : Type u_2\ninst‚úù¬π : CategoryTheory.Category.{u_3, u_2} D\nF G : CategoryTheory.Functor J C\nŒ± : Quiver.Hom F G\nhŒ± : CategoryTheory.NatTrans.Equifibered Œ±\nH : CategoryTheory.Functor C D\ninst‚úù : ‚àÄ (i j : J) (f : Quiver.Hom j i), CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.cospan (Œ±.app i) (G.map f)) H\n‚ä¢ CategoryTheory.NatTrans.Equifibered (CategoryTheory.whiskerRight Œ± H)","decl":"theorem NatTrans.Equifibered.whiskerRight {F G : J ‚•§ C} {Œ± : F ‚ü∂ G} (hŒ± : Equifibered Œ±)\n    (H : C ‚•§ D) [‚àÄ (i j : J) (f : j ‚ü∂ i), PreservesLimit (cospan (Œ±.app i) (G.map f)) H] :\n    Equifibered (whiskerRight Œ± H) :=\n  fun _ _ f => (hŒ± f).map H\n\n"}
{"name":"CategoryTheory.NatTrans.Equifibered.whiskerLeft","module":"Mathlib.CategoryTheory.Limits.VanKampen","initialProofState":"J : Type v'\ninst‚úù¬≤ : CategoryTheory.Category.{u', v'} J\nC : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nK : Type u_3\ninst‚úù : CategoryTheory.Category.{u_4, u_3} K\nF G : CategoryTheory.Functor J C\nŒ± : Quiver.Hom F G\nhŒ± : CategoryTheory.NatTrans.Equifibered Œ±\nH : CategoryTheory.Functor K J\n‚ä¢ CategoryTheory.NatTrans.Equifibered (CategoryTheory.whiskerLeft H Œ±)","decl":"theorem NatTrans.Equifibered.whiskerLeft {K : Type*} [Category K]  {F G : J ‚•§ C} {Œ± : F ‚ü∂ G}\n    (hŒ± : Equifibered Œ±) (H : K ‚•§ J) : Equifibered (whiskerLeft H Œ±) :=\n  fun _ _ f => hŒ± (H.map f)\n\n"}
{"name":"CategoryTheory.mapPair_equifibered","module":"Mathlib.CategoryTheory.Limits.VanKampen","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF F' : CategoryTheory.Functor (CategoryTheory.Discrete CategoryTheory.Limits.WalkingPair) C\nŒ± : Quiver.Hom F F'\n‚ä¢ CategoryTheory.NatTrans.Equifibered Œ±","decl":"theorem mapPair_equifibered {F F' : Discrete WalkingPair ‚•§ C} (Œ± : F ‚ü∂ F') :\n    NatTrans.Equifibered Œ± := by\n  rintro ‚ü®‚ü®‚ü©‚ü© ‚ü®j‚ü© ‚ü®‚ü®rfl : _ = j‚ü©‚ü©\n  all_goals\n    dsimp; simp only [Discrete.functor_map_id]\n    exact IsPullback.of_horiz_isIso ‚ü®by simp only [Category.comp_id, Category.id_comp]‚ü©\n\n"}
{"name":"CategoryTheory.NatTrans.equifibered_of_discrete","module":"Mathlib.CategoryTheory.Limits.VanKampen","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nŒπ : Type u_3\nF G : CategoryTheory.Functor (CategoryTheory.Discrete Œπ) C\nŒ± : Quiver.Hom F G\n‚ä¢ CategoryTheory.NatTrans.Equifibered Œ±","decl":"theorem NatTrans.equifibered_of_discrete {Œπ : Type*} {F G : Discrete Œπ ‚•§ C}\n    (Œ± : F ‚ü∂ G) : NatTrans.Equifibered Œ± := by\n  rintro ‚ü®i‚ü© ‚ü®j‚ü© ‚ü®‚ü®rfl : i = j‚ü©‚ü©\n  simp only [Discrete.functor_map_id]\n  exact IsPullback.of_horiz_isIso ‚ü®by rw [Category.id_comp, Category.comp_id]‚ü©\n\n"}
{"name":"CategoryTheory.IsVanKampenColimit.isUniversal","module":"Mathlib.CategoryTheory.Limits.VanKampen","initialProofState":"J : Type v'\ninst‚úù¬π : CategoryTheory.Category.{u', v'} J\nC : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\nc : CategoryTheory.Limits.Cocone F\nH : CategoryTheory.IsVanKampenColimit c\n‚ä¢ CategoryTheory.IsUniversalColimit c","decl":"theorem IsVanKampenColimit.isUniversal {F : J ‚•§ C} {c : Cocone F} (H : IsVanKampenColimit c) :\n    IsUniversalColimit c :=\n  fun _ c' Œ± f h hŒ± => (H c' Œ± f h hŒ±).mpr\n\n"}
{"name":"CategoryTheory.IsInitial.isVanKampenColimit","module":"Mathlib.CategoryTheory.Limits.VanKampen","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasStrictInitialObjects C\nX : C\nh : CategoryTheory.Limits.IsInitial X\n‚ä¢ CategoryTheory.IsVanKampenColimit (CategoryTheory.Limits.asEmptyCocone X)","decl":"theorem IsInitial.isVanKampenColimit [HasStrictInitialObjects C] {X : C} (h : IsInitial X) :\n    IsVanKampenColimit (asEmptyCocone X) := by\n  intro F' c' Œ± f hf hŒ±\n  have : F' = Functor.empty C := by apply Functor.hext <;> rintro ‚ü®‚ü®‚ü©‚ü©\n  subst this\n  haveI := h.isIso_to f\n  refine ‚ü®by rintro _ ‚ü®‚ü®‚ü©‚ü©,\n    fun _ => ‚ü®IsColimit.ofIsoColimit h (Cocones.ext (asIso f).symm <| by rintro ‚ü®‚ü®‚ü©‚ü©)‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.IsUniversalColimit.of_iso","module":"Mathlib.CategoryTheory.Limits.VanKampen","initialProofState":"J : Type v'\ninst‚úù¬π : CategoryTheory.Category.{u', v'} J\nC : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\nc c' : CategoryTheory.Limits.Cocone F\nhc : CategoryTheory.IsUniversalColimit c\ne : CategoryTheory.Iso c c'\n‚ä¢ CategoryTheory.IsUniversalColimit c'","decl":"theorem IsUniversalColimit.of_iso {F : J ‚•§ C} {c c' : Cocone F} (hc : IsUniversalColimit c)\n    (e : c ‚âÖ c') : IsUniversalColimit c' := by\n  intro F' c'' Œ± f h hŒ± H\n  have : c'.Œπ ‚â´ (Functor.const J).map e.inv.hom = c.Œπ := by\n    ext j\n    exact e.inv.2 j\n  apply hc c'' Œ± (f ‚â´ e.inv.1) (by rw [Functor.map_comp, ‚Üê reassoc_of% h, this]) hŒ±\n  intro j\n  rw [‚Üê Category.comp_id (Œ±.app j)]\n  have : IsIso e.inv.hom := Functor.map_isIso (Cocones.forget _) e.inv\n  exact (H j).paste_vert (IsPullback.of_vert_isIso ‚ü®by simp‚ü©)\n\n"}
{"name":"CategoryTheory.IsVanKampenColimit.of_iso","module":"Mathlib.CategoryTheory.Limits.VanKampen","initialProofState":"J : Type v'\ninst‚úù¬π : CategoryTheory.Category.{u', v'} J\nC : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\nc c' : CategoryTheory.Limits.Cocone F\nH : CategoryTheory.IsVanKampenColimit c\ne : CategoryTheory.Iso c c'\n‚ä¢ CategoryTheory.IsVanKampenColimit c'","decl":"theorem IsVanKampenColimit.of_iso {F : J ‚•§ C} {c c' : Cocone F} (H : IsVanKampenColimit c)\n    (e : c ‚âÖ c') : IsVanKampenColimit c' := by\n  intro F' c'' Œ± f h hŒ±\n  have : c'.Œπ ‚â´ (Functor.const J).map e.inv.hom = c.Œπ := by\n    ext j\n    exact e.inv.2 j\n  rw [H c'' Œ± (f ‚â´ e.inv.1) (by rw [Functor.map_comp, ‚Üê reassoc_of% h, this]) hŒ±]\n  apply forall_congr'\n  intro j\n  conv_lhs => rw [‚Üê Category.comp_id (Œ±.app j)]\n  haveI : IsIso e.inv.hom := Functor.map_isIso (Cocones.forget _) e.inv\n  exact (IsPullback.of_vert_isIso ‚ü®by simp‚ü©).paste_vert_iff (NatTrans.congr_app h j).symm\n\n"}
{"name":"CategoryTheory.IsVanKampenColimit.precompose_isIso","module":"Mathlib.CategoryTheory.Limits.VanKampen","initialProofState":"J : Type v'\ninst‚úù¬≤ : CategoryTheory.Category.{u', v'} J\nC : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nF G : CategoryTheory.Functor J C\nŒ± : Quiver.Hom F G\ninst‚úù : CategoryTheory.IsIso Œ±\nc : CategoryTheory.Limits.Cocone G\nhc : CategoryTheory.IsVanKampenColimit c\n‚ä¢ CategoryTheory.IsVanKampenColimit ((CategoryTheory.Limits.Cocones.precompose Œ±).obj c)","decl":"theorem IsVanKampenColimit.precompose_isIso {F G : J ‚•§ C} (Œ± : F ‚ü∂ G) [IsIso Œ±]\n    {c : Cocone G} (hc : IsVanKampenColimit c) :\n    IsVanKampenColimit ((Cocones.precompose Œ±).obj c) := by\n  intros F' c' Œ±' f e hŒ±\n  refine (hc c' (Œ±' ‚â´ Œ±) f ((Category.assoc _ _ _).trans e)\n    (hŒ±.comp (NatTrans.equifibered_of_isIso _))).trans ?_\n  apply forall_congr'\n  intro j\n  simp only [Functor.const_obj_obj, NatTrans.comp_app,\n    Cocones.precompose_obj_pt, Cocones.precompose_obj_Œπ]\n  have : IsPullback (Œ±.app j ‚â´ c.Œπ.app j) (Œ±.app j) (ùüô _) (c.Œπ.app j) :=\n    IsPullback.of_vert_isIso ‚ü®Category.comp_id _‚ü©\n  rw [‚Üê IsPullback.paste_vert_iff this _, Category.comp_id]\n  exact (congr_app e j).symm\n\n"}
{"name":"CategoryTheory.IsUniversalColimit.precompose_isIso","module":"Mathlib.CategoryTheory.Limits.VanKampen","initialProofState":"J : Type v'\ninst‚úù¬≤ : CategoryTheory.Category.{u', v'} J\nC : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nF G : CategoryTheory.Functor J C\nŒ± : Quiver.Hom F G\ninst‚úù : CategoryTheory.IsIso Œ±\nc : CategoryTheory.Limits.Cocone G\nhc : CategoryTheory.IsUniversalColimit c\n‚ä¢ CategoryTheory.IsUniversalColimit ((CategoryTheory.Limits.Cocones.precompose Œ±).obj c)","decl":"theorem IsUniversalColimit.precompose_isIso {F G : J ‚•§ C} (Œ± : F ‚ü∂ G) [IsIso Œ±]\n    {c : Cocone G} (hc : IsUniversalColimit c) :\n    IsUniversalColimit ((Cocones.precompose Œ±).obj c) := by\n  intros F' c' Œ±' f e hŒ± H\n  apply (hc c' (Œ±' ‚â´ Œ±) f ((Category.assoc _ _ _).trans e)\n    (hŒ±.comp (NatTrans.equifibered_of_isIso _)))\n  intro j\n  simp only [Functor.const_obj_obj, NatTrans.comp_app,\n    Cocones.precompose_obj_pt, Cocones.precompose_obj_Œπ]\n  rw [‚Üê Category.comp_id f]\n  exact (H j).paste_vert (IsPullback.of_vert_isIso ‚ü®Category.comp_id _‚ü©)\n\n"}
{"name":"CategoryTheory.IsVanKampenColimit.precompose_isIso_iff","module":"Mathlib.CategoryTheory.Limits.VanKampen","initialProofState":"J : Type v'\ninst‚úù¬≤ : CategoryTheory.Category.{u', v'} J\nC : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nF G : CategoryTheory.Functor J C\nŒ± : Quiver.Hom F G\ninst‚úù : CategoryTheory.IsIso Œ±\nc : CategoryTheory.Limits.Cocone G\n‚ä¢ Iff (CategoryTheory.IsVanKampenColimit ((CategoryTheory.Limits.Cocones.precompose Œ±).obj c)) (CategoryTheory.IsVanKampenColimit c)","decl":"theorem IsVanKampenColimit.precompose_isIso_iff {F G : J ‚•§ C} (Œ± : F ‚ü∂ G) [IsIso Œ±]\n    {c : Cocone G} : IsVanKampenColimit ((Cocones.precompose Œ±).obj c) ‚Üî IsVanKampenColimit c :=\n  ‚ü®fun hc ‚Ü¶ IsVanKampenColimit.of_iso (IsVanKampenColimit.precompose_isIso (inv Œ±) hc)\n    (Cocones.ext (Iso.refl _) (by simp)),\n    IsVanKampenColimit.precompose_isIso Œ±‚ü©\n\n"}
{"name":"CategoryTheory.IsUniversalColimit.of_mapCocone","module":"Mathlib.CategoryTheory.Limits.VanKampen","initialProofState":"J : Type v'\ninst‚úù‚Å¥ : CategoryTheory.Category.{u', v'} J\nC : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nD : Type u_2\ninst‚úù¬≤ : CategoryTheory.Category.{u_3, u_2} D\nG : CategoryTheory.Functor C D\nF : CategoryTheory.Functor J C\nc : CategoryTheory.Limits.Cocone F\ninst‚úù¬π : CategoryTheory.Limits.PreservesLimitsOfShape CategoryTheory.Limits.WalkingCospan G\ninst‚úù : CategoryTheory.Limits.ReflectsColimitsOfShape J G\nhc : CategoryTheory.IsUniversalColimit (G.mapCocone c)\n‚ä¢ CategoryTheory.IsUniversalColimit c","decl":"theorem IsUniversalColimit.of_mapCocone (G : C ‚•§ D) {F : J ‚•§ C} {c : Cocone F}\n    [PreservesLimitsOfShape WalkingCospan G] [ReflectsColimitsOfShape J G]\n    (hc : IsUniversalColimit (G.mapCocone c)) : IsUniversalColimit c :=\n  fun F' c' Œ± f h hŒ± H ‚Ü¶\n    ‚ü®isColimitOfReflects _ (hc (G.mapCocone c') (whiskerRight Œ± G) (G.map f)\n    (by ext j; simpa using G.congr_map (NatTrans.congr_app h j))\n    (hŒ±.whiskerRight G) (fun j ‚Ü¶ (H j).map G)).some‚ü©\n\n"}
{"name":"CategoryTheory.IsVanKampenColimit.of_mapCocone","module":"Mathlib.CategoryTheory.Limits.VanKampen","initialProofState":"J : Type v'\ninst‚úù‚Å∑ : CategoryTheory.Category.{u', v'} J\nC : Type u\ninst‚úù‚Å∂ : CategoryTheory.Category.{v, u} C\nD : Type u_2\ninst‚úù‚Åµ : CategoryTheory.Category.{u_3, u_2} D\nG : CategoryTheory.Functor C D\nF : CategoryTheory.Functor J C\nc : CategoryTheory.Limits.Cocone F\ninst‚úù‚Å¥ : ‚àÄ (i j : J) (X : C) (f : Quiver.Hom X (F.obj j)) (g : Quiver.Hom i j), CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.cospan f (F.map g)) G\ninst‚úù¬≥ : ‚àÄ (i : J) (X : C) (f : Quiver.Hom X c.pt), CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.cospan f (c.Œπ.app i)) G\ninst‚úù¬≤ : CategoryTheory.Limits.ReflectsLimitsOfShape CategoryTheory.Limits.WalkingCospan G\ninst‚úù¬π : CategoryTheory.Limits.PreservesColimitsOfShape J G\ninst‚úù : CategoryTheory.Limits.ReflectsColimitsOfShape J G\nH : CategoryTheory.IsVanKampenColimit (G.mapCocone c)\n‚ä¢ CategoryTheory.IsVanKampenColimit c","decl":"theorem IsVanKampenColimit.of_mapCocone (G : C ‚•§ D) {F : J ‚•§ C} {c : Cocone F}\n    [‚àÄ (i j : J) (X : C) (f : X ‚ü∂ F.obj j) (g : i ‚ü∂ j), PreservesLimit (cospan f (F.map g)) G]\n    [‚àÄ (i : J) (X : C) (f : X ‚ü∂ c.pt), PreservesLimit (cospan f (c.Œπ.app i)) G]\n    [ReflectsLimitsOfShape WalkingCospan G]\n    [PreservesColimitsOfShape J G]\n    [ReflectsColimitsOfShape J G]\n    (H : IsVanKampenColimit (G.mapCocone c)) : IsVanKampenColimit c := by\n  intro F' c' Œ± f h hŒ±\n  refine (Iff.trans ?_ (H (G.mapCocone c') (whiskerRight Œ± G) (G.map f)\n      (by ext j; simpa using G.congr_map (NatTrans.congr_app h j))\n      (hŒ±.whiskerRight G))).trans (forall_congr' fun j => ?_)\n  ¬∑ exact ‚ü®fun h => ‚ü®isColimitOfPreserves G h.some‚ü©, fun h => ‚ü®isColimitOfReflects G h.some‚ü©‚ü©\n  ¬∑ exact IsPullback.map_iff G (NatTrans.congr_app h.symm j)\n\n"}
{"name":"CategoryTheory.IsVanKampenColimit.mapCocone_iff","module":"Mathlib.CategoryTheory.Limits.VanKampen","initialProofState":"J : Type v'\ninst‚úù¬≥ : CategoryTheory.Category.{u', v'} J\nC : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nD : Type u_2\ninst‚úù¬π : CategoryTheory.Category.{u_3, u_2} D\nG : CategoryTheory.Functor C D\nF : CategoryTheory.Functor J C\nc : CategoryTheory.Limits.Cocone F\ninst‚úù : G.IsEquivalence\n‚ä¢ Iff (CategoryTheory.IsVanKampenColimit (G.mapCocone c)) (CategoryTheory.IsVanKampenColimit c)","decl":"theorem IsVanKampenColimit.mapCocone_iff (G : C ‚•§ D) {F : J ‚•§ C} {c : Cocone F}\n    [G.IsEquivalence] : IsVanKampenColimit (G.mapCocone c) ‚Üî IsVanKampenColimit c :=\n  ‚ü®IsVanKampenColimit.of_mapCocone G, fun hc ‚Ü¶ by\n    let e : F ‚ãô G ‚ãô Functor.inv G ‚âÖ F := NatIso.hcomp (Iso.refl F) G.asEquivalence.unitIso.symm\n    apply IsVanKampenColimit.of_mapCocone G.inv\n    apply (IsVanKampenColimit.precompose_isIso_iff e.inv).mp\n    exact hc.of_iso (Cocones.ext (G.asEquivalence.unitIso.app c.pt) (fun j => (by simp [e])))‚ü©\n\n"}
{"name":"CategoryTheory.IsUniversalColimit.whiskerEquivalence","module":"Mathlib.CategoryTheory.Limits.VanKampen","initialProofState":"J : Type v'\ninst‚úù¬≤ : CategoryTheory.Category.{u', v'} J\nC : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nK : Type u_3\ninst‚úù : CategoryTheory.Category.{u_4, u_3} K\ne : CategoryTheory.Equivalence J K\nF : CategoryTheory.Functor K C\nc : CategoryTheory.Limits.Cocone F\nhc : CategoryTheory.IsUniversalColimit c\n‚ä¢ CategoryTheory.IsUniversalColimit (CategoryTheory.Limits.Cocone.whisker e.functor c)","decl":"theorem IsUniversalColimit.whiskerEquivalence {K : Type*} [Category K] (e : J ‚âå K)\n    {F : K ‚•§ C} {c : Cocone F} (hc : IsUniversalColimit c) :\n    IsUniversalColimit (c.whisker e.functor) := by\n  intro F' c' Œ± f e' hŒ± H\n  convert hc (c'.whisker e.inverse) (whiskerLeft e.inverse Œ± ‚â´ (e.invFunIdAssoc F).hom) f ?_\n    ((hŒ±.whiskerLeft _).comp (NatTrans.equifibered_of_isIso _)) ?_ using 1\n  ¬∑ exact (IsColimit.whiskerEquivalenceEquiv e.symm).nonempty_congr\n  ¬∑ convert congr_arg (whiskerLeft e.inverse) e'\n    ext\n    simp\n  ¬∑ intro k\n    rw [‚Üê Category.comp_id f]\n    refine (H (e.inverse.obj k)).paste_vert ?_\n    have : IsIso (ùüô (Cocone.whisker e.functor c).pt) := inferInstance\n    exact IsPullback.of_vert_isIso ‚ü®by simp‚ü©\n\n"}
{"name":"CategoryTheory.IsUniversalColimit.whiskerEquivalence_iff","module":"Mathlib.CategoryTheory.Limits.VanKampen","initialProofState":"J : Type v'\ninst‚úù¬≤ : CategoryTheory.Category.{u', v'} J\nC : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nK : Type u_3\ninst‚úù : CategoryTheory.Category.{u_4, u_3} K\ne : CategoryTheory.Equivalence J K\nF : CategoryTheory.Functor K C\nc : CategoryTheory.Limits.Cocone F\n‚ä¢ Iff (CategoryTheory.IsUniversalColimit (CategoryTheory.Limits.Cocone.whisker e.functor c)) (CategoryTheory.IsUniversalColimit c)","decl":"theorem IsUniversalColimit.whiskerEquivalence_iff {K : Type*} [Category K] (e : J ‚âå K)\n    {F : K ‚•§ C} {c : Cocone F} :\n    IsUniversalColimit (c.whisker e.functor) ‚Üî IsUniversalColimit c :=\n  ‚ü®fun hc ‚Ü¶ ((hc.whiskerEquivalence e.symm).precompose_isIso (e.invFunIdAssoc F).inv).of_iso\n      (Cocones.ext (Iso.refl _) (by simp)), IsUniversalColimit.whiskerEquivalence e‚ü©\n\n"}
{"name":"CategoryTheory.IsVanKampenColimit.whiskerEquivalence","module":"Mathlib.CategoryTheory.Limits.VanKampen","initialProofState":"J : Type v'\ninst‚úù¬≤ : CategoryTheory.Category.{u', v'} J\nC : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nK : Type u_3\ninst‚úù : CategoryTheory.Category.{u_4, u_3} K\ne : CategoryTheory.Equivalence J K\nF : CategoryTheory.Functor K C\nc : CategoryTheory.Limits.Cocone F\nhc : CategoryTheory.IsVanKampenColimit c\n‚ä¢ CategoryTheory.IsVanKampenColimit (CategoryTheory.Limits.Cocone.whisker e.functor c)","decl":"theorem IsVanKampenColimit.whiskerEquivalence {K : Type*} [Category K] (e : J ‚âå K)\n    {F : K ‚•§ C} {c : Cocone F} (hc : IsVanKampenColimit c) :\n    IsVanKampenColimit (c.whisker e.functor) := by\n  intro F' c' Œ± f e' hŒ±\n  convert hc (c'.whisker e.inverse) (whiskerLeft e.inverse Œ± ‚â´ (e.invFunIdAssoc F).hom) f ?_\n    ((hŒ±.whiskerLeft _).comp (NatTrans.equifibered_of_isIso _)) using 1\n  ¬∑ exact (IsColimit.whiskerEquivalenceEquiv e.symm).nonempty_congr\n  ¬∑ simp only [Functor.const_obj_obj, Functor.comp_obj, Cocone.whisker_pt, Cocone.whisker_Œπ,\n      whiskerLeft_app, NatTrans.comp_app, Equivalence.invFunIdAssoc_hom_app, Functor.id_obj]\n    constructor\n    ¬∑ intro H k\n      rw [‚Üê Category.comp_id f]\n      refine (H (e.inverse.obj k)).paste_vert ?_\n      have : IsIso (ùüô (Cocone.whisker e.functor c).pt) := inferInstance\n      exact IsPullback.of_vert_isIso ‚ü®by simp‚ü©\n    ¬∑ intro H j\n      have : Œ±.app j\n          = F'.map (e.unit.app _) ‚â´ Œ±.app _ ‚â´ F.map (e.counit.app (e.functor.obj j)) := by\n        simp [‚Üê Functor.map_comp]\n      rw [‚Üê Category.id_comp f, this]\n      refine IsPullback.paste_vert ?_ (H (e.functor.obj j))\n      exact IsPullback.of_vert_isIso ‚ü®by simp‚ü©\n  ¬∑ ext k\n    simpa using congr_app e' (e.inverse.obj k)\n\n"}
{"name":"CategoryTheory.IsVanKampenColimit.whiskerEquivalence_iff","module":"Mathlib.CategoryTheory.Limits.VanKampen","initialProofState":"J : Type v'\ninst‚úù¬≤ : CategoryTheory.Category.{u', v'} J\nC : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nK : Type u_3\ninst‚úù : CategoryTheory.Category.{u_4, u_3} K\ne : CategoryTheory.Equivalence J K\nF : CategoryTheory.Functor K C\nc : CategoryTheory.Limits.Cocone F\n‚ä¢ Iff (CategoryTheory.IsVanKampenColimit (CategoryTheory.Limits.Cocone.whisker e.functor c)) (CategoryTheory.IsVanKampenColimit c)","decl":"theorem IsVanKampenColimit.whiskerEquivalence_iff {K : Type*} [Category K] (e : J ‚âå K)\n    {F : K ‚•§ C} {c : Cocone F} :\n    IsVanKampenColimit (c.whisker e.functor) ‚Üî IsVanKampenColimit c :=\n  ‚ü®fun hc ‚Ü¶ ((hc.whiskerEquivalence e.symm).precompose_isIso (e.invFunIdAssoc F).inv).of_iso\n      (Cocones.ext (Iso.refl _) (by simp)), IsVanKampenColimit.whiskerEquivalence e‚ü©\n\n"}
{"name":"CategoryTheory.isVanKampenColimit_of_evaluation","module":"Mathlib.CategoryTheory.Limits.VanKampen","initialProofState":"J : Type v'\ninst‚úù‚Å¥ : CategoryTheory.Category.{u', v'} J\nC : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nD : Type u_2\ninst‚úù¬≤ : CategoryTheory.Category.{u_3, u_2} D\ninst‚úù¬π : CategoryTheory.Limits.HasPullbacks D\ninst‚úù : CategoryTheory.Limits.HasColimitsOfShape J D\nF : CategoryTheory.Functor J (CategoryTheory.Functor C D)\nc : CategoryTheory.Limits.Cocone F\nhc : ‚àÄ (x : C), CategoryTheory.IsVanKampenColimit (((CategoryTheory.evaluation C D).obj x).mapCocone c)\n‚ä¢ CategoryTheory.IsVanKampenColimit c","decl":"theorem isVanKampenColimit_of_evaluation [HasPullbacks D] [HasColimitsOfShape J D] (F : J ‚•§ C ‚•§ D)\n    (c : Cocone F) (hc : ‚àÄ x : C, IsVanKampenColimit (((evaluation C D).obj x).mapCocone c)) :\n    IsVanKampenColimit c := by\n  intro F' c' Œ± f e hŒ±\n  have := fun x => hc x (((evaluation C D).obj x).mapCocone c') (whiskerRight Œ± _)\n      (((evaluation C D).obj x).map f)\n      (by\n        ext y\n        dsimp\n        exact NatTrans.congr_app (NatTrans.congr_app e y) x)\n      (hŒ±.whiskerRight _)\n  constructor\n  ¬∑ rintro ‚ü®hc'‚ü© j\n    refine ‚ü®‚ü®(NatTrans.congr_app e j).symm‚ü©, ‚ü®evaluationJointlyReflectsLimits _ ?_‚ü©‚ü©\n    refine fun x => (isLimitMapConePullbackConeEquiv _ _).symm ?_\n    exact ((this x).mp ‚ü®isColimitOfPreserves _ hc'‚ü© _).isLimit\n  ¬∑ exact fun H => ‚ü®evaluationJointlyReflectsColimits _ fun x =>\n      ((this x).mpr fun j => (H j).map ((evaluation C D).obj x)).some‚ü©\n\n"}
{"name":"CategoryTheory.IsUniversalColimit.map_reflective","module":"Mathlib.CategoryTheory.Limits.VanKampen","initialProofState":"J : Type v'\ninst‚úù‚Å∂ : CategoryTheory.Category.{u', v'} J\nC : Type u\ninst‚úù‚Åµ : CategoryTheory.Category.{v, u} C\nD : Type u_2\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_3, u_2} D\nGl : CategoryTheory.Functor C D\nGr : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction Gl Gr\ninst‚úù¬≥ : Gr.Full\ninst‚úù¬≤ : Gr.Faithful\nF : CategoryTheory.Functor J D\nc : CategoryTheory.Limits.Cocone (F.comp Gr)\nH : CategoryTheory.IsUniversalColimit c\ninst‚úù¬π : ‚àÄ (X : D) (f : Quiver.Hom X (Gl.obj c.pt)), CategoryTheory.Limits.HasPullback (Gr.map f) (adj.unit.app c.pt)\ninst‚úù : ‚àÄ (X : D) (f : Quiver.Hom X (Gl.obj c.pt)), CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.cospan (Gr.map f) (adj.unit.app c.pt)) Gl\n‚ä¢ CategoryTheory.IsUniversalColimit (Gl.mapCocone c)","decl":"theorem IsUniversalColimit.map_reflective\n    {Gl : C ‚•§ D} {Gr : D ‚•§ C} (adj : Gl ‚ä£ Gr) [Gr.Full] [Gr.Faithful]\n    {F : J ‚•§ D} {c : Cocone (F ‚ãô Gr)}\n    (H : IsUniversalColimit c)\n    [‚àÄ X (f : X ‚ü∂ Gl.obj c.pt), HasPullback (Gr.map f) (adj.unit.app c.pt)]\n    [‚àÄ X (f : X ‚ü∂ Gl.obj c.pt), PreservesLimit (cospan (Gr.map f) (adj.unit.app c.pt)) Gl] :\n    IsUniversalColimit (Gl.mapCocone c) := by\n  have := adj.rightAdjoint_preservesLimits\n  have : PreservesColimitsOfSize.{u', v'} Gl := adj.leftAdjoint_preservesColimits\n  intros F' c' Œ± f h hŒ± hc'\n  have : HasPullback (Gl.map (Gr.map f)) (Gl.map (adj.unit.app c.pt)) :=\n    ‚ü®‚ü®_, isLimitPullbackConeMapOfIsLimit _ pullback.condition\n      (IsPullback.of_hasPullback _ _).isLimit‚ü©‚ü©\n  let Œ±' := Œ± ‚â´ (Functor.associator _ _ _).hom ‚â´ whiskerLeft F adj.counit ‚â´ F.rightUnitor.hom\n  have hŒ±' : NatTrans.Equifibered Œ±' := hŒ±.comp (NatTrans.equifibered_of_isIso _)\n  have hadj : ‚àÄ X, Gl.map (adj.unit.app X) = inv (adj.counit.app _) := by\n    intro X\n    apply IsIso.eq_inv_of_inv_hom_id\n    exact adj.left_triangle_components _\n  haveI : ‚àÄ X, IsIso (Gl.map (adj.unit.app X)) := by\n    simp_rw [hadj]\n    infer_instance\n  have hŒ±'' : ‚àÄ j, Gl.map (Gr.map <| Œ±'.app j) = adj.counit.app _ ‚â´ Œ±.app j := by\n    intro j\n    rw [‚Üê cancel_mono (adj.counit.app <| F.obj j)]\n    dsimp [Œ±']\n    simp only [Category.comp_id, Adjunction.counit_naturality_assoc, Category.id_comp,\n      Adjunction.counit_naturality, Category.assoc, Functor.map_comp]\n  have hc'' : ‚àÄ j, Œ±.app j ‚â´ Gl.map (c.Œπ.app j) = c'.Œπ.app j ‚â´ f := NatTrans.congr_app h\n  let Œ≤ := isoWhiskerLeft F' (asIso adj.counit) ‚â™‚â´ F'.rightUnitor\n  let c'' : Cocone (F' ‚ãô Gr) := by\n    refine\n    { pt := pullback (Gr.map f) (adj.unit.app _)\n      Œπ := { app := fun j ‚Ü¶ pullback.lift (Gr.map <| c'.Œπ.app j) (Gr.map (Œ±'.app j) ‚â´ c.Œπ.app j) ?_\n             naturality := ?_ } }\n    ¬∑ rw [‚Üê Gr.map_comp, ‚Üê hc'']\n      erw [‚Üê adj.unit_naturality]\n      rw [Gl.map_comp, hŒ±'']\n      dsimp\n      simp only [Category.assoc, Functor.map_comp, adj.right_triangle_components_assoc]\n    ¬∑ intros i j g\n      dsimp [Œ±']\n      ext\n      all_goals simp only [Category.comp_id, Category.id_comp, Category.assoc,\n        ‚Üê Functor.map_comp, pullback.lift_fst, pullback.lift_snd, ‚Üê Functor.map_comp_assoc]\n      ¬∑ congr 1\n        exact c'.w _\n      ¬∑ rw [Œ±.naturality_assoc]\n        dsimp\n        rw [adj.counit_naturality, ‚Üê Category.assoc, Gr.map_comp_assoc]\n        congr 1\n        exact c.w _\n  let cf : (Cocones.precompose Œ≤.hom).obj c' ‚ü∂ Gl.mapCocone c'' := by\n    refine { hom := pullback.lift ?_ f ?_ ‚â´ (PreservesPullback.iso _ _ _).inv, w := ?_ }\n    ¬∑ exact inv <| adj.counit.app c'.pt\n    ¬∑ simp [‚Üê cancel_mono (adj.counit.app <| Gl.obj c.pt)]\n    ¬∑ intro j\n      rw [‚Üê Category.assoc, Iso.comp_inv_eq]\n      ext\n      all_goals simp only [c'', PreservesPullback.iso_hom_fst, PreservesPullback.iso_hom_snd,\n          pullback.lift_fst, pullback.lift_snd, Category.assoc,\n          Functor.mapCocone_Œπ_app, ‚Üê Gl.map_comp]\n      ¬∑ rw [IsIso.comp_inv_eq, adj.counit_naturality]\n        dsimp [Œ≤]\n        rw [Category.comp_id]\n      ¬∑ rw [Gl.map_comp, hŒ±'', Category.assoc, hc'']\n        dsimp [Œ≤]\n        rw [Category.comp_id, Category.assoc]\n  have :\n      cf.hom ‚â´ (PreservesPullback.iso _ _ _).hom ‚â´ pullback.fst _ _ ‚â´ adj.counit.app _ = ùüô _ := by\n    simp only [cf, IsIso.inv_hom_id, Iso.inv_hom_id_assoc, Category.assoc,\n      pullback.lift_fst_assoc]\n  have : IsIso cf := by\n    apply @Cocones.cocone_iso_of_hom_iso (i := ?_)\n    rw [‚Üê IsIso.eq_comp_inv] at this\n    rw [this]\n    infer_instance\n  have ‚ü®Hc''‚ü© := H c'' (whiskerRight Œ±' Gr) (pullback.snd _ _) ?_ (hŒ±'.whiskerRight Gr) ?_\n  ¬∑ exact ‚ü®IsColimit.precomposeHomEquiv Œ≤ c' <|\n      (isColimitOfPreserves Gl Hc'').ofIsoColimit (asIso cf).symm‚ü©\n  ¬∑ ext j\n    dsimp [c'']\n    simp only [Category.comp_id, Category.id_comp, Category.assoc,\n      Functor.map_comp, pullback.lift_snd]\n  ¬∑ intro j\n    apply IsPullback.of_right _ _ (IsPullback.of_hasPullback _ _)\n    ¬∑ dsimp [Œ±', c'']\n      simp only [Category.comp_id, Category.id_comp, Category.assoc, Functor.map_comp,\n        pullback.lift_fst]\n      rw [‚Üê Category.comp_id (Gr.map f)]\n      refine ((hc' j).map Gr).paste_vert (IsPullback.of_vert_isIso ‚ü®?_‚ü©)\n      rw [‚Üê adj.unit_naturality, Category.comp_id, ‚Üê Category.assoc,\n        ‚Üê Category.id_comp (Gr.map ((Gl.mapCocone c).Œπ.app j))]\n      congr 1\n      rw [‚Üê cancel_mono (Gr.map (adj.counit.app (F.obj j)))]\n      dsimp\n      simp only [Category.comp_id, Adjunction.right_triangle_components, Category.id_comp,\n        Category.assoc]\n    ¬∑ dsimp [c'']\n      simp only [Category.comp_id, Category.id_comp, Category.assoc, Functor.map_comp,\n        pullback.lift_snd]\n\n"}
{"name":"CategoryTheory.IsVanKampenColimit.map_reflective","module":"Mathlib.CategoryTheory.Limits.VanKampen","initialProofState":"J : Type v'\ninst‚úù‚Å∏ : CategoryTheory.Category.{u', v'} J\nC : Type u\ninst‚úù‚Å∑ : CategoryTheory.Category.{v, u} C\nD : Type u_2\ninst‚úù‚Å∂ : CategoryTheory.Category.{u_3, u_2} D\ninst‚úù‚Åµ : CategoryTheory.Limits.HasColimitsOfShape J C\nGl : CategoryTheory.Functor C D\nGr : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction Gl Gr\ninst‚úù‚Å¥ : Gr.Full\ninst‚úù¬≥ : Gr.Faithful\nF : CategoryTheory.Functor J D\nc : CategoryTheory.Limits.Cocone (F.comp Gr)\nH : CategoryTheory.IsVanKampenColimit c\ninst‚úù¬≤ : ‚àÄ (X : D) (f : Quiver.Hom X (Gl.obj c.pt)), CategoryTheory.Limits.HasPullback (Gr.map f) (adj.unit.app c.pt)\ninst‚úù¬π : ‚àÄ (X : D) (f : Quiver.Hom X (Gl.obj c.pt)), CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.cospan (Gr.map f) (adj.unit.app c.pt)) Gl\ninst‚úù : ‚àÄ (X : C) (i : J) (f : Quiver.Hom X c.pt), CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.cospan f (c.Œπ.app i)) Gl\n‚ä¢ CategoryTheory.IsVanKampenColimit (Gl.mapCocone c)","decl":"theorem IsVanKampenColimit.map_reflective [HasColimitsOfShape J C]\n    {Gl : C ‚•§ D} {Gr : D ‚•§ C} (adj : Gl ‚ä£ Gr) [Gr.Full] [Gr.Faithful]\n    {F : J ‚•§ D} {c : Cocone (F ‚ãô Gr)} (H : IsVanKampenColimit c)\n    [‚àÄ X (f : X ‚ü∂ Gl.obj c.pt), HasPullback (Gr.map f) (adj.unit.app c.pt)]\n    [‚àÄ X (f : X ‚ü∂ Gl.obj c.pt), PreservesLimit (cospan (Gr.map f) (adj.unit.app c.pt)) Gl]\n    [‚àÄ X i (f : X ‚ü∂ c.pt), PreservesLimit (cospan f (c.Œπ.app i)) Gl] :\n    IsVanKampenColimit (Gl.mapCocone c) := by\n  have := adj.rightAdjoint_preservesLimits\n  have : PreservesColimitsOfSize.{u', v'} Gl := adj.leftAdjoint_preservesColimits\n  intro F' c' Œ± f h hŒ±\n  refine ‚ü®?_, H.isUniversal.map_reflective adj c' Œ± f h hŒ±‚ü©\n  intro ‚ü®hc'‚ü© j\n  let Œ±' := Œ± ‚â´ (Functor.associator _ _ _).hom ‚â´ whiskerLeft F adj.counit ‚â´ F.rightUnitor.hom\n  have hŒ±' : NatTrans.Equifibered Œ±' := hŒ±.comp (NatTrans.equifibered_of_isIso _)\n  have hŒ±'' : ‚àÄ j, Gl.map (Gr.map <| Œ±'.app j) = adj.counit.app _ ‚â´ Œ±.app j := by\n    intro j\n    rw [‚Üê cancel_mono (adj.counit.app <| F.obj j)]\n    dsimp [Œ±']\n    simp only [Category.comp_id, Adjunction.counit_naturality_assoc, Category.id_comp,\n      Adjunction.counit_naturality, Category.assoc, Functor.map_comp]\n  let Œ≤ := isoWhiskerLeft F' (asIso adj.counit) ‚â™‚â´ F'.rightUnitor\n  let hl := (IsColimit.precomposeHomEquiv Œ≤ c').symm hc'\n  let hr := isColimitOfPreserves Gl (colimit.isColimit <| F' ‚ãô Gr)\n  have : Œ±.app j = Œ≤.inv.app _ ‚â´ Gl.map (Gr.map <| Œ±'.app j) := by\n    rw [hŒ±'']\n    simp [Œ≤]\n  rw [this]\n  have : f = (hl.coconePointUniqueUpToIso hr).hom ‚â´\n    Gl.map (colimit.desc _ ‚ü®_, whiskerRight Œ±' Gr ‚â´ c.2‚ü©) := by\n    symm\n    convert @IsColimit.coconePointUniqueUpToIso_hom_desc _ _ _ _ ((F' ‚ãô Gr) ‚ãô Gl)\n      (Gl.mapCocone ‚ü®_, (whiskerRight Œ±' Gr ‚â´ c.2 :)‚ü©) _ _ hl hr using 2\n    ¬∑ apply hr.hom_ext\n      intro j\n      rw [hr.fac, Functor.mapCocone_Œπ_app, ‚Üê Gl.map_comp, colimit.cocone_Œπ, colimit.Œπ_desc]\n      rfl\n    ¬∑ clear_value Œ±'\n      apply hl.hom_ext\n      intro j\n      rw [hl.fac]\n      dsimp [Œ≤]\n      simp only [Category.comp_id, hŒ±'', Category.assoc, Gl.map_comp]\n      congr 1\n      exact (NatTrans.congr_app h j).symm\n  rw [this]\n  have := ((H (colimit.cocone <| F' ‚ãô Gr) (whiskerRight Œ±' Gr)\n    (colimit.desc _ ‚ü®_, whiskerRight Œ±' Gr ‚â´ c.2‚ü©) ?_ (hŒ±'.whiskerRight Gr)).mp\n    ‚ü®(getColimitCocone <| F' ‚ãô Gr).2‚ü© j).map Gl\n  ¬∑ convert IsPullback.paste_vert _ this\n    refine IsPullback.of_vert_isIso ‚ü®?_‚ü©\n    rw [‚Üê IsIso.inv_comp_eq, ‚Üê Category.assoc, NatIso.inv_inv_app]\n    exact IsColimit.comp_coconePointUniqueUpToIso_hom hl hr _\n  ¬∑ clear_value Œ±'\n    ext j\n    simp\n\n"}
{"name":"CategoryTheory.hasStrictInitial_of_isUniversal","module":"Mathlib.CategoryTheory.Limits.VanKampen","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasInitial C\nH : CategoryTheory.IsUniversalColimit (CategoryTheory.Limits.BinaryCofan.mk (CategoryTheory.CategoryStruct.id (CategoryTheory.Limits.initial C)) (CategoryTheory.CategoryStruct.id (CategoryTheory.Limits.initial C)))\n‚ä¢ CategoryTheory.Limits.HasStrictInitialObjects C","decl":"theorem hasStrictInitial_of_isUniversal [HasInitial C]\n    (H : IsUniversalColimit (BinaryCofan.mk (ùüô (‚ä•_ C)) (ùüô (‚ä•_ C)))) : HasStrictInitialObjects C :=\n  hasStrictInitialObjects_of_initial_is_strict\n    (by\n      intro A f\n      suffices IsColimit (BinaryCofan.mk (ùüô A) (ùüô A)) by\n        obtain ‚ü®l, h‚ÇÅ, h‚ÇÇ‚ü© := Limits.BinaryCofan.IsColimit.desc' this (f ‚â´ initial.to A) (ùüô A)\n        rcases(Category.id_comp _).symm.trans h‚ÇÇ with rfl\n        exact ‚ü®‚ü®_, ((Category.id_comp _).symm.trans h‚ÇÅ).symm, initialIsInitial.hom_ext _ _‚ü©‚ü©\n      refine (H (BinaryCofan.mk (ùüô _) (ùüô _)) (mapPair f f) f (by ext ‚ü®‚ü®‚ü©‚ü© <;> dsimp <;> simp)\n        (mapPair_equifibered _) ?_).some\n      rintro ‚ü®‚ü®‚ü©‚ü© <;> dsimp <;>\n        exact IsPullback.of_horiz_isIso ‚ü®(Category.id_comp _).trans (Category.comp_id _).symm‚ü©)\n\n"}
{"name":"CategoryTheory.isVanKampenColimit_of_isEmpty","module":"Mathlib.CategoryTheory.Limits.VanKampen","initialProofState":"J : Type v'\ninst‚úù¬≥ : CategoryTheory.Category.{u', v'} J\nC : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasStrictInitialObjects C\ninst‚úù : IsEmpty J\nF : CategoryTheory.Functor J C\nc : CategoryTheory.Limits.Cocone F\nhc : CategoryTheory.Limits.IsColimit c\n‚ä¢ CategoryTheory.IsVanKampenColimit c","decl":"theorem isVanKampenColimit_of_isEmpty [HasStrictInitialObjects C] [IsEmpty J] {F : J ‚•§ C}\n    (c : Cocone F) (hc : IsColimit c) : IsVanKampenColimit c := by\n  have : IsInitial c.pt := by\n    have := (IsColimit.precomposeInvEquiv (Functor.uniqueFromEmpty _) _).symm\n      (hc.whiskerEquivalence (equivalenceOfIsEmpty (Discrete PEmpty.{1}) J))\n    exact IsColimit.ofIsoColimit this (Cocones.ext (Iso.refl c.pt) (fun {X} ‚Ü¶ isEmptyElim X))\n  replace this := IsInitial.isVanKampenColimit this\n  apply (IsVanKampenColimit.whiskerEquivalence_iff\n    (equivalenceOfIsEmpty (Discrete PEmpty.{1}) J)).mp\n  exact (this.precompose_isIso (Functor.uniqueFromEmpty\n    ((equivalenceOfIsEmpty (Discrete PEmpty.{1}) J).functor ‚ãô F)).hom).of_iso\n    (Cocones.ext (Iso.refl _) (by simp))\n\n"}
{"name":"CategoryTheory.BinaryCofan.isVanKampen_iff","module":"Mathlib.CategoryTheory.Limits.VanKampen","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nc : CategoryTheory.Limits.BinaryCofan X Y\n‚ä¢ Iff (CategoryTheory.IsVanKampenColimit c) (‚àÄ {X' Y' : C} (c' : CategoryTheory.Limits.BinaryCofan X' Y') (Œ±X : Quiver.Hom X' X) (Œ±Y : Quiver.Hom Y' Y) (f : Quiver.Hom c'.pt c.pt), Eq (CategoryTheory.CategoryStruct.comp Œ±X c.inl) (CategoryTheory.CategoryStruct.comp c'.inl f) ‚Üí Eq (CategoryTheory.CategoryStruct.comp Œ±Y c.inr) (CategoryTheory.CategoryStruct.comp c'.inr f) ‚Üí Iff (Nonempty (CategoryTheory.Limits.IsColimit c')) (And (CategoryTheory.IsPullback c'.inl Œ±X f c.inl) (CategoryTheory.IsPullback c'.inr Œ±Y f c.inr)))","decl":"theorem BinaryCofan.isVanKampen_iff (c : BinaryCofan X Y) :\n    IsVanKampenColimit c ‚Üî\n      ‚àÄ {X' Y' : C} (c' : BinaryCofan X' Y') (Œ±X : X' ‚ü∂ X) (Œ±Y : Y' ‚ü∂ Y) (f : c'.pt ‚ü∂ c.pt)\n        (_ : Œ±X ‚â´ c.inl = c'.inl ‚â´ f) (_ : Œ±Y ‚â´ c.inr = c'.inr ‚â´ f),\n        Nonempty (IsColimit c') ‚Üî IsPullback c'.inl Œ±X f c.inl ‚àß IsPullback c'.inr Œ±Y f c.inr := by\n  constructor\n  ¬∑ introv H hŒ±X hŒ±Y\n    rw [H c' (mapPair Œ±X Œ±Y) f (by ext ‚ü®‚ü®‚ü©‚ü© <;> dsimp <;> assumption) (mapPair_equifibered _)]\n    constructor\n    ¬∑ intro H\n      exact ‚ü®H _, H _‚ü©\n    ¬∑ rintro H ‚ü®‚ü®‚ü©‚ü©\n      exacts [H.1, H.2]\n  ¬∑ introv H F' hŒ± h\n    let X' := F'.obj ‚ü®WalkingPair.left‚ü©\n    let Y' := F'.obj ‚ü®WalkingPair.right‚ü©\n    have : F' = pair X' Y' := by\n      apply Functor.hext\n      ¬∑ rintro ‚ü®‚ü®‚ü©‚ü© <;> rfl\n      ¬∑ rintro ‚ü®‚ü®‚ü©‚ü© ‚ü®j‚ü© ‚ü®‚ü®rfl : _ = j‚ü©‚ü© <;> simp [X', Y']\n    clear_value X' Y'\n    subst this\n    change BinaryCofan X' Y' at c'\n    rw [H c' _ _ _ (NatTrans.congr_app hŒ± ‚ü®WalkingPair.left‚ü©)\n        (NatTrans.congr_app hŒ± ‚ü®WalkingPair.right‚ü©)]\n    constructor\n    ¬∑ rintro H ‚ü®‚ü®‚ü©‚ü©\n      exacts [H.1, H.2]\n    ¬∑ intro H\n      exact ‚ü®H _, H _‚ü©\n\n"}
{"name":"CategoryTheory.BinaryCofan.isVanKampen_mk","module":"Mathlib.CategoryTheory.Limits.VanKampen","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nc : CategoryTheory.Limits.BinaryCofan X Y\ncofans : (X Y : C) ‚Üí CategoryTheory.Limits.BinaryCofan X Y\ncolimits : (X Y : C) ‚Üí CategoryTheory.Limits.IsColimit (cofans X Y)\ncones : {X Y Z : C} ‚Üí (f : Quiver.Hom X Z) ‚Üí (g : Quiver.Hom Y Z) ‚Üí CategoryTheory.Limits.PullbackCone f g\nlimits : {X Y Z : C} ‚Üí (f : Quiver.Hom X Z) ‚Üí (g : Quiver.Hom Y Z) ‚Üí CategoryTheory.Limits.IsLimit (cones f g)\nh‚ÇÅ : ‚àÄ {X' Y' : C} (Œ±X : Quiver.Hom X' X) (Œ±Y : Quiver.Hom Y' Y) (f : Quiver.Hom (cofans X' Y').pt c.pt), Eq (CategoryTheory.CategoryStruct.comp Œ±X c.inl) (CategoryTheory.CategoryStruct.comp (cofans X' Y').inl f) ‚Üí Eq (CategoryTheory.CategoryStruct.comp Œ±Y c.inr) (CategoryTheory.CategoryStruct.comp (cofans X' Y').inr f) ‚Üí And (CategoryTheory.IsPullback (cofans X' Y').inl Œ±X f c.inl) (CategoryTheory.IsPullback (cofans X' Y').inr Œ±Y f c.inr)\nh‚ÇÇ : {Z : C} ‚Üí (f : Quiver.Hom Z c.pt) ‚Üí CategoryTheory.Limits.IsColimit (CategoryTheory.Limits.BinaryCofan.mk (cones f c.inl).fst (cones f c.inr).fst)\n‚ä¢ CategoryTheory.IsVanKampenColimit c","decl":"theorem BinaryCofan.isVanKampen_mk {X Y : C} (c : BinaryCofan X Y)\n    (cofans : ‚àÄ X Y : C, BinaryCofan X Y) (colimits : ‚àÄ X Y, IsColimit (cofans X Y))\n    (cones : ‚àÄ {X Y Z : C} (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z), PullbackCone f g)\n    (limits : ‚àÄ {X Y Z : C} (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z), IsLimit (cones f g))\n    (h‚ÇÅ : ‚àÄ {X' Y' : C} (Œ±X : X' ‚ü∂ X) (Œ±Y : Y' ‚ü∂ Y) (f : (cofans X' Y').pt ‚ü∂ c.pt)\n      (_ : Œ±X ‚â´ c.inl = (cofans X' Y').inl ‚â´ f) (_ : Œ±Y ‚â´ c.inr = (cofans X' Y').inr ‚â´ f),\n      IsPullback (cofans X' Y').inl Œ±X f c.inl ‚àß IsPullback (cofans X' Y').inr Œ±Y f c.inr)\n    (h‚ÇÇ : ‚àÄ {Z : C} (f : Z ‚ü∂ c.pt),\n      IsColimit (BinaryCofan.mk (cones f c.inl).fst (cones f c.inr).fst)) :\n    IsVanKampenColimit c := by\n  rw [BinaryCofan.isVanKampen_iff]\n  introv hX hY\n  constructor\n  ¬∑ rintro ‚ü®h‚ü©\n    let e := h.coconePointUniqueUpToIso (colimits _ _)\n    obtain ‚ü®hl, hr‚ü© := h‚ÇÅ Œ±X Œ±Y (e.inv ‚â´ f) (by simp [e, hX]) (by simp [e, hY])\n    constructor\n    ¬∑ rw [‚Üê Category.id_comp Œ±X, ‚Üê Iso.hom_inv_id_assoc e f]\n      haveI : IsIso (ùüô X') := inferInstance\n      have : c'.inl ‚â´ e.hom = ùüô X' ‚â´ (cofans X' Y').inl := by\n        dsimp [e]\n        simp\n      exact (IsPullback.of_vert_isIso ‚ü®this‚ü©).paste_vert hl\n    ¬∑ rw [‚Üê Category.id_comp Œ±Y, ‚Üê Iso.hom_inv_id_assoc e f]\n      haveI : IsIso (ùüô Y') := inferInstance\n      have : c'.inr ‚â´ e.hom = ùüô Y' ‚â´ (cofans X' Y').inr := by\n        dsimp [e]\n        simp\n      exact (IsPullback.of_vert_isIso ‚ü®this‚ü©).paste_vert hr\n  ¬∑ rintro ‚ü®H‚ÇÅ, H‚ÇÇ‚ü©\n    refine ‚ü®IsColimit.ofIsoColimit ?_ <| (isoBinaryCofanMk _).symm‚ü©\n    let e‚ÇÅ : X' ‚âÖ _ := H‚ÇÅ.isLimit.conePointUniqueUpToIso (limits _ _)\n    let e‚ÇÇ : Y' ‚âÖ _ := H‚ÇÇ.isLimit.conePointUniqueUpToIso (limits _ _)\n    have he‚ÇÅ : c'.inl = e‚ÇÅ.hom ‚â´ (cones f c.inl).fst := by simp [e‚ÇÅ]\n    have he‚ÇÇ : c'.inr = e‚ÇÇ.hom ‚â´ (cones f c.inr).fst := by simp [e‚ÇÇ]\n    rw [he‚ÇÅ, he‚ÇÇ]\n    exact (BinaryCofan.mk _ _).isColimitCompRightIso e‚ÇÇ.hom\n      ((BinaryCofan.mk _ _).isColimitCompLeftIso e‚ÇÅ.hom (h‚ÇÇ f))\n\n"}
{"name":"CategoryTheory.BinaryCofan.mono_inr_of_isVanKampen","module":"Mathlib.CategoryTheory.Limits.VanKampen","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasInitial C\nX Y : C\nc : CategoryTheory.Limits.BinaryCofan X Y\nh : CategoryTheory.IsVanKampenColimit c\n‚ä¢ CategoryTheory.Mono c.inr","decl":"theorem BinaryCofan.mono_inr_of_isVanKampen [HasInitial C] {X Y : C} {c : BinaryCofan X Y}\n    (h : IsVanKampenColimit c) : Mono c.inr := by\n  refine PullbackCone.mono_of_isLimitMkIdId _ (IsPullback.isLimit ?_)\n  refine (h (BinaryCofan.mk (initial.to Y) (ùüô Y)) (mapPair (initial.to X) (ùüô Y)) c.inr ?_\n      (mapPair_equifibered _)).mp ‚ü®?_‚ü© ‚ü®WalkingPair.right‚ü©\n  ¬∑ ext ‚ü®‚ü®‚ü©‚ü© <;> dsimp; simp\n  ¬∑ exact ((BinaryCofan.isColimit_iff_isIso_inr initialIsInitial _).mpr (by\n      dsimp\n      infer_instance)).some\n\n"}
{"name":"CategoryTheory.BinaryCofan.isPullback_initial_to_of_isVanKampen","module":"Mathlib.CategoryTheory.Limits.VanKampen","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y : C\ninst‚úù : CategoryTheory.Limits.HasInitial C\nc : CategoryTheory.Limits.BinaryCofan X Y\nh : CategoryTheory.IsVanKampenColimit c\n‚ä¢ CategoryTheory.IsPullback (CategoryTheory.Limits.initial.to ((CategoryTheory.Limits.pair X Y).obj { as := CategoryTheory.Limits.WalkingPair.left })) (CategoryTheory.Limits.initial.to ((CategoryTheory.Limits.pair X Y).obj { as := CategoryTheory.Limits.WalkingPair.right })) c.inl c.inr","decl":"theorem BinaryCofan.isPullback_initial_to_of_isVanKampen [HasInitial C] {c : BinaryCofan X Y}\n    (h : IsVanKampenColimit c) : IsPullback (initial.to _) (initial.to _) c.inl c.inr := by\n  refine ((h (BinaryCofan.mk (initial.to Y) (ùüô Y)) (mapPair (initial.to X) (ùüô Y)) c.inr ?_\n      (mapPair_equifibered _)).mp ‚ü®?_‚ü© ‚ü®WalkingPair.left‚ü©).flip\n  ¬∑ ext ‚ü®‚ü®‚ü©‚ü© <;> dsimp; simp\n  ¬∑ exact ((BinaryCofan.isColimit_iff_isIso_inr initialIsInitial _).mpr (by\n      dsimp\n      infer_instance)).some\n\n"}
{"name":"CategoryTheory.isUniversalColimit_extendCofan","module":"Mathlib.CategoryTheory.Limits.VanKampen","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nn : Nat\nf : Fin (HAdd.hAdd n 1) ‚Üí C\nc‚ÇÅ : CategoryTheory.Limits.Cofan fun i => f i.succ\nc‚ÇÇ : CategoryTheory.Limits.BinaryCofan (f 0) c‚ÇÅ.pt\nt‚ÇÅ : CategoryTheory.IsUniversalColimit c‚ÇÅ\nt‚ÇÇ : CategoryTheory.IsUniversalColimit c‚ÇÇ\ninst‚úù : ‚àÄ {Z : C} (i : Quiver.Hom Z c‚ÇÇ.pt), CategoryTheory.Limits.HasPullback c‚ÇÇ.inr i\n‚ä¢ CategoryTheory.IsUniversalColimit (CategoryTheory.extendCofan c‚ÇÅ c‚ÇÇ)","decl":"theorem isUniversalColimit_extendCofan {n : ‚Ñï} (f : Fin (n + 1) ‚Üí C)\n    {c‚ÇÅ : Cofan fun i : Fin n ‚Ü¶ f i.succ} {c‚ÇÇ : BinaryCofan (f 0) c‚ÇÅ.pt}\n    (t‚ÇÅ : IsUniversalColimit c‚ÇÅ) (t‚ÇÇ : IsUniversalColimit c‚ÇÇ)\n    [‚àÄ {Z} (i : Z ‚ü∂ c‚ÇÇ.pt), HasPullback c‚ÇÇ.inr i] :\n    IsUniversalColimit (extendCofan c‚ÇÅ c‚ÇÇ) := by\n  intro F c Œ± i e hŒ± H\n  let F' : Fin (n + 1) ‚Üí C := F.obj ‚àò Discrete.mk\n  have : F = Discrete.functor F' := by\n    apply Functor.hext\n    ¬∑ exact fun i ‚Ü¶ rfl\n    ¬∑ rintro ‚ü®i‚ü© ‚ü®j‚ü© ‚ü®‚ü®rfl : i = j‚ü©‚ü©\n      simp [F']\n  have t‚ÇÅ' := @t‚ÇÅ (Discrete.functor (fun j ‚Ü¶ F.obj ‚ü®j.succ‚ü©))\n    (Cofan.mk (pullback c‚ÇÇ.inr i) fun j ‚Ü¶ pullback.lift (Œ±.app _ ‚â´ c‚ÇÅ.inj _) (c.Œπ.app _) ?_)\n    (Discrete.natTrans fun i ‚Ü¶ Œ±.app _) (pullback.fst _ _) ?_\n    (NatTrans.equifibered_of_discrete _) ?_\n  rotate_left\n  ¬∑ simpa only [Functor.const_obj_obj, pair_obj_right, Discrete.functor_obj, Category.assoc,\n      extendCofan_pt, Functor.const_obj_obj, NatTrans.comp_app, extendCofan_Œπ_app,\n      Fin.cases_succ, Functor.const_map_app] using congr_app e ‚ü®j.succ‚ü©\n  ¬∑ ext j\n    dsimp\n    simp only [limit.lift_œÄ, PullbackCone.mk_pt, PullbackCone.mk_œÄ_app, Cofan.inj]\n  ¬∑ intro j\n    simp only [pair_obj_right, Functor.const_obj_obj, Discrete.functor_obj, id_eq,\n      extendCofan_pt, eq_mpr_eq_cast, Cofan.mk_pt, Cofan.mk_Œπ_app, Discrete.natTrans_app]\n    refine IsPullback.of_right ?_ ?_ (IsPullback.of_hasPullback (BinaryCofan.inr c‚ÇÇ) i).flip\n    ¬∑ simp only [Functor.const_obj_obj, pair_obj_right, limit.lift_œÄ,\n        PullbackCone.mk_pt, PullbackCone.mk_œÄ_app]\n      exact H _\n    ¬∑ simp only [limit.lift_œÄ, PullbackCone.mk_pt, PullbackCone.mk_œÄ_app, Cofan.inj]\n  obtain ‚ü®H‚ÇÅ‚ü© := t‚ÇÅ'\n  have t‚ÇÇ' := @t‚ÇÇ (pair (F.obj ‚ü®0‚ü©) (pullback c‚ÇÇ.inr i))\n    (BinaryCofan.mk (c.Œπ.app ‚ü®0‚ü©) (pullback.snd _ _)) (mapPair (Œ±.app _) (pullback.fst _ _)) i ?_\n    (mapPair_equifibered _) ?_\n  rotate_left\n  ¬∑ ext ‚ü®‚ü®‚ü©‚ü©\n    ¬∑ simpa [mapPair] using congr_app e ‚ü®0‚ü©\n    ¬∑ simpa using pullback.condition\n  ¬∑ rintro ‚ü®‚ü®‚ü©‚ü©\n    ¬∑ simp only [pair_obj_right, Functor.const_obj_obj, pair_obj_left, BinaryCofan.mk_pt,\n        BinaryCofan.Œπ_app_left, BinaryCofan.mk_inl, mapPair_left]\n      exact H ‚ü®0‚ü©\n    ¬∑ simp only [pair_obj_right, Functor.const_obj_obj, BinaryCofan.mk_pt, BinaryCofan.Œπ_app_right,\n        BinaryCofan.mk_inr, mapPair_right]\n      exact (IsPullback.of_hasPullback (BinaryCofan.inr c‚ÇÇ) i).flip\n  obtain ‚ü®H‚ÇÇ‚ü© := t‚ÇÇ'\n  clear_value F'\n  subst this\n  refine ‚ü®IsColimit.ofIsoColimit (extendCofanIsColimit\n    (fun i ‚Ü¶ (Discrete.functor F').obj ‚ü®i‚ü©) H‚ÇÅ H‚ÇÇ) <| Cocones.ext (Iso.refl _) ?_‚ü©\n  dsimp\n  rintro ‚ü®j‚ü©\n  simp only [Discrete.functor_obj, limit.lift_œÄ, PullbackCone.mk_pt,\n    PullbackCone.mk_œÄ_app, Category.comp_id]\n  induction' j using Fin.inductionOn\n  ¬∑ simp only [Fin.cases_zero]\n  ¬∑ simp only [Fin.cases_succ]\n\n"}
{"name":"CategoryTheory.isVanKampenColimit_extendCofan","module":"Mathlib.CategoryTheory.Limits.VanKampen","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nn : Nat\nf : Fin (HAdd.hAdd n 1) ‚Üí C\nc‚ÇÅ : CategoryTheory.Limits.Cofan fun i => f i.succ\nc‚ÇÇ : CategoryTheory.Limits.BinaryCofan (f 0) c‚ÇÅ.pt\nt‚ÇÅ : CategoryTheory.IsVanKampenColimit c‚ÇÅ\nt‚ÇÇ : CategoryTheory.IsVanKampenColimit c‚ÇÇ\ninst‚úù¬π : ‚àÄ {Z : C} (i : Quiver.Hom Z c‚ÇÇ.pt), CategoryTheory.Limits.HasPullback c‚ÇÇ.inr i\ninst‚úù : CategoryTheory.Limits.HasFiniteCoproducts C\n‚ä¢ CategoryTheory.IsVanKampenColimit (CategoryTheory.extendCofan c‚ÇÅ c‚ÇÇ)","decl":"theorem isVanKampenColimit_extendCofan {n : ‚Ñï} (f : Fin (n + 1) ‚Üí C)\n    {c‚ÇÅ : Cofan fun i : Fin n ‚Ü¶ f i.succ} {c‚ÇÇ : BinaryCofan (f 0) c‚ÇÅ.pt}\n    (t‚ÇÅ : IsVanKampenColimit c‚ÇÅ) (t‚ÇÇ : IsVanKampenColimit c‚ÇÇ)\n    [‚àÄ {Z} (i : Z ‚ü∂ c‚ÇÇ.pt), HasPullback c‚ÇÇ.inr i]\n    [HasFiniteCoproducts C] :\n    IsVanKampenColimit (extendCofan c‚ÇÅ c‚ÇÇ) := by\n  intro F c Œ± i e hŒ±\n  refine ‚ü®?_, isUniversalColimit_extendCofan f t‚ÇÅ.isUniversal t‚ÇÇ.isUniversal c Œ± i e hŒ±‚ü©\n  intro ‚ü®Hc‚ü© ‚ü®j‚ü©\n  have t‚ÇÇ' := (@t‚ÇÇ (pair (F.obj ‚ü®0‚ü©) (‚àê fun (j : Fin n) ‚Ü¶ F.obj ‚ü®j.succ‚ü©))\n    (BinaryCofan.mk (P := c.pt) (c.Œπ.app _) (Sigma.desc fun b ‚Ü¶ c.Œπ.app _))\n    (mapPair (Œ±.app _) (Sigma.desc fun b ‚Ü¶ Œ±.app _ ‚â´ c‚ÇÅ.inj _)) i ?_\n    (mapPair_equifibered _)).mp ‚ü®?_‚ü©\n  rotate_left\n  ¬∑ ext ‚ü®‚ü®‚ü©‚ü©\n    ¬∑ simpa only [pair_obj_left, Functor.const_obj_obj, pair_obj_right, Discrete.functor_obj,\n        NatTrans.comp_app, mapPair_left, BinaryCofan.Œπ_app_left, BinaryCofan.mk_pt,\n        BinaryCofan.mk_inl, Functor.const_map_app, extendCofan_pt,\n        extendCofan_Œπ_app, Fin.cases_zero] using congr_app e ‚ü®0‚ü©\n    ¬∑ dsimp\n      ext j\n      simpa only [colimit.Œπ_desc_assoc, Discrete.functor_obj, Cofan.mk_pt, Cofan.mk_Œπ_app,\n        Category.assoc, extendCofan_pt, Functor.const_obj_obj, NatTrans.comp_app, extendCofan_Œπ_app,\n        Fin.cases_succ, Functor.const_map_app] using congr_app e ‚ü®j.succ‚ü©\n  ¬∑ let F' : Fin (n + 1) ‚Üí C := F.obj ‚àò Discrete.mk\n    have : F = Discrete.functor F' := by\n      apply Functor.hext\n      ¬∑ exact fun i ‚Ü¶ rfl\n      ¬∑ rintro ‚ü®i‚ü© ‚ü®j‚ü© ‚ü®‚ü®rfl : i = j‚ü©‚ü©\n        simp [F']\n    clear_value F'\n    subst this\n    apply BinaryCofan.IsColimit.mk _ (fun {T} f‚ÇÅ f‚ÇÇ ‚Ü¶ Hc.desc (Cofan.mk T (Fin.cases f‚ÇÅ\n      (fun i ‚Ü¶ Sigma.Œπ (fun (j : Fin n) ‚Ü¶ (Discrete.functor F').obj ‚ü®j.succ‚ü©) _ ‚â´ f‚ÇÇ))))\n    ¬∑ intro T f‚ÇÅ f‚ÇÇ\n      simp only [Discrete.functor_obj, pair_obj_left, BinaryCofan.mk_pt, Functor.const_obj_obj,\n        BinaryCofan.Œπ_app_left, BinaryCofan.mk_inl, IsColimit.fac, Cofan.mk_pt, Cofan.mk_Œπ_app,\n        Fin.cases_zero]\n    ¬∑ intro T f‚ÇÅ f‚ÇÇ\n      simp only [Discrete.functor_obj, pair_obj_right, BinaryCofan.mk_pt, Functor.const_obj_obj,\n        BinaryCofan.Œπ_app_right, BinaryCofan.mk_inr]\n      ext j\n      simp only [colimit.Œπ_desc_assoc, Discrete.functor_obj, Cofan.mk_pt,\n        Cofan.mk_Œπ_app, IsColimit.fac, Fin.cases_succ]\n    ¬∑ intro T f‚ÇÅ f‚ÇÇ f‚ÇÉ m‚ÇÅ m‚ÇÇ\n      simp at m‚ÇÅ m‚ÇÇ ‚ä¢\n      refine Hc.uniq (Cofan.mk T (Fin.cases f‚ÇÅ\n        (fun i ‚Ü¶ Sigma.Œπ (fun (j : Fin n) ‚Ü¶ (Discrete.functor F').obj ‚ü®j.succ‚ü©) _ ‚â´ f‚ÇÇ))) _ ?_\n      intro ‚ü®j‚ü©\n      simp only [Discrete.functor_obj, Cofan.mk_pt, Functor.const_obj_obj, Cofan.mk_Œπ_app]\n      induction' j using Fin.inductionOn with j _\n      ¬∑ simp only [Fin.cases_zero, m‚ÇÅ]\n      ¬∑ simp only [‚Üê m‚ÇÇ, colimit.Œπ_desc_assoc, Discrete.functor_obj,\n          Cofan.mk_pt, Cofan.mk_Œπ_app, Fin.cases_succ]\n  induction' j using Fin.inductionOn with j _\n  ¬∑ exact t‚ÇÇ' ‚ü®WalkingPair.left‚ü©\n  ¬∑ have t‚ÇÅ' := (@t‚ÇÅ (Discrete.functor (fun j ‚Ü¶ F.obj ‚ü®j.succ‚ü©)) (Cofan.mk _ _) (Discrete.natTrans\n      fun i ‚Ü¶ Œ±.app _) (Sigma.desc (fun j ‚Ü¶ Œ±.app _ ‚â´ c‚ÇÅ.inj _)) ?_\n      (NatTrans.equifibered_of_discrete _)).mp ‚ü®coproductIsCoproduct _‚ü© ‚ü®j‚ü©\n    rotate_left\n    ¬∑ ext ‚ü®j‚ü©\n      dsimp\n      rw [colimit.Œπ_desc]\n      rfl\n    simpa [Functor.const_obj_obj, Discrete.functor_obj, extendCofan_pt, extendCofan_Œπ_app,\n      Fin.cases_succ, BinaryCofan.mk_pt, colimit.cocone_x, Cofan.mk_pt, Cofan.mk_Œπ_app,\n      BinaryCofan.Œπ_app_right, BinaryCofan.mk_inr, colimit.Œπ_desc,\n      Discrete.natTrans_app] using t‚ÇÅ'.paste_horiz (t‚ÇÇ' ‚ü®WalkingPair.right‚ü©)\n\n"}
{"name":"CategoryTheory.isPullback_of_cofan_isVanKampen","module":"Mathlib.CategoryTheory.Limits.VanKampen","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasInitial C\nŒπ : Type u_3\nX : Œπ ‚Üí C\nc : CategoryTheory.Limits.Cofan X\nhc : CategoryTheory.IsVanKampenColimit c\ni j : Œπ\ninst‚úù : DecidableEq Œπ\n‚ä¢ CategoryTheory.IsPullback (dite (Eq j i) (fun h => CategoryTheory.eqToHom ‚ãØ) fun h => CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom ‚ãØ) (CategoryTheory.Limits.initial.to (X i))) (dite (Eq j i) (fun h => CategoryTheory.eqToHom ‚ãØ) fun h => CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom ‚ãØ) (CategoryTheory.Limits.initial.to (X j))) (c.inj i) (c.inj j)","decl":"theorem isPullback_of_cofan_isVanKampen [HasInitial C] {Œπ : Type*} {X : Œπ ‚Üí C}\n    {c : Cofan X} (hc : IsVanKampenColimit c) (i j : Œπ) [DecidableEq Œπ] :\n    IsPullback (P := (if j = i then X i else ‚ä•_ C))\n      (if h : j = i then eqToHom (if_pos h) else eqToHom (if_neg h) ‚â´ initial.to (X i))\n      (if h : j = i then eqToHom ((if_pos h).trans (congr_arg X h.symm))\n        else eqToHom (if_neg h) ‚â´ initial.to (X j))\n      (Cofan.inj c i) (Cofan.inj c j) := by\n  refine (hc (Cofan.mk (X i) (f := fun k ‚Ü¶ if k = i then X i else ‚ä•_ C)\n    (fun k ‚Ü¶ if h : k = i then (eqToHom <| if_pos h) else (eqToHom <| if_neg h) ‚â´ initial.to _))\n    (Discrete.natTrans (fun k ‚Ü¶ if h : k.1 = i then (eqToHom <| (if_pos h).trans\n      (congr_arg X h.symm)) else (eqToHom <| if_neg h) ‚â´ initial.to _))\n    (c.inj i) ?_ (NatTrans.equifibered_of_discrete _)).mp ‚ü®?_‚ü© ‚ü®j‚ü©\n  ¬∑ ext ‚ü®k‚ü©\n    simp only [Discrete.functor_obj, Functor.const_obj_obj, NatTrans.comp_app,\n      Discrete.natTrans_app, Cofan.mk_pt, Cofan.mk_Œπ_app, Functor.const_map_app]\n    split\n    ¬∑ subst ‚Äπk = i‚Ä∫; rfl\n    ¬∑ simp\n  ¬∑ refine mkCofanColimit _ (fun t ‚Ü¶ (eqToHom (if_pos rfl).symm) ‚â´ t.inj i) ?_ ?_\n    ¬∑ intro t j\n      simp only [Cofan.mk_pt, cofan_mk_inj]\n      split\n      ¬∑ subst ‚Äπj = i‚Ä∫; simp\n      ¬∑ rw [Category.assoc, ‚Üê IsIso.eq_inv_comp]\n        exact initialIsInitial.hom_ext _ _\n    ¬∑ intro t m hm\n      simp [‚Üê hm i]\n\n"}
{"name":"CategoryTheory.isPullback_initial_to_of_cofan_isVanKampen","module":"Mathlib.CategoryTheory.Limits.VanKampen","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasInitial C\nŒπ : Type u_3\nF : CategoryTheory.Functor (CategoryTheory.Discrete Œπ) C\nc : CategoryTheory.Limits.Cocone F\nhc : CategoryTheory.IsVanKampenColimit c\ni j : CategoryTheory.Discrete Œπ\nhi : Ne i j\n‚ä¢ CategoryTheory.IsPullback (CategoryTheory.Limits.initial.to (F.obj i)) (CategoryTheory.Limits.initial.to (F.obj j)) (c.Œπ.app i) (c.Œπ.app j)","decl":"theorem isPullback_initial_to_of_cofan_isVanKampen [HasInitial C] {Œπ : Type*} {F : Discrete Œπ ‚•§ C}\n    {c : Cocone F} (hc : IsVanKampenColimit c) (i j : Discrete Œπ) (hi : i ‚â† j) :\n    IsPullback (initial.to _) (initial.to _) (c.Œπ.app i) (c.Œπ.app j) := by\n  classical\n  let f : Œπ ‚Üí C := F.obj ‚àò Discrete.mk\n  have : F = Discrete.functor f :=\n    Functor.hext (fun i ‚Ü¶ rfl) (by rintro ‚ü®i‚ü© ‚ü®j‚ü© ‚ü®‚ü®rfl : i = j‚ü©‚ü©; simp [f])\n  clear_value f\n  subst this\n  have : ‚àÄ i, Subsingleton (‚ä•_ C ‚ü∂ (Discrete.functor f).obj i) := inferInstance\n  convert isPullback_of_cofan_isVanKampen hc i.as j.as\n  exact (if_neg (mt Discrete.ext hi.symm)).symm\n\n"}
{"name":"CategoryTheory.mono_of_cofan_isVanKampen","module":"Mathlib.CategoryTheory.Limits.VanKampen","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasInitial C\nŒπ : Type u_3\nF : CategoryTheory.Functor (CategoryTheory.Discrete Œπ) C\nc : CategoryTheory.Limits.Cocone F\nhc : CategoryTheory.IsVanKampenColimit c\ni : CategoryTheory.Discrete Œπ\n‚ä¢ CategoryTheory.Mono (c.Œπ.app i)","decl":"theorem mono_of_cofan_isVanKampen [HasInitial C] {Œπ : Type*} {F : Discrete Œπ ‚•§ C}\n    {c : Cocone F} (hc : IsVanKampenColimit c) (i : Discrete Œπ) : Mono (c.Œπ.app i) := by\n  classical\n  let f : Œπ ‚Üí C := F.obj ‚àò Discrete.mk\n  have : F = Discrete.functor f :=\n    Functor.hext (fun i ‚Ü¶ rfl) (by rintro ‚ü®i‚ü© ‚ü®j‚ü© ‚ü®‚ü®rfl : i = j‚ü©‚ü©; simp [f])\n  clear_value f\n  subst this\n  refine PullbackCone.mono_of_isLimitMkIdId _ (IsPullback.isLimit ?_)\n  nth_rw 1 [‚Üê Category.id_comp (c.Œπ.app i)]\n  convert IsPullback.paste_vert _ (isPullback_of_cofan_isVanKampen hc i.as i.as)\n  swap\n  ¬∑ exact (eqToHom (if_pos rfl).symm)\n  ¬∑ simp\n  ¬∑ exact IsPullback.of_vert_isIso ‚ü®by simp‚ü©\n\n"}
