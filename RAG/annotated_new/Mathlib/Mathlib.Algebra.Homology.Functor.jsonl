{"name":"HomologicalComplex.asFunctor_obj","module":"Mathlib.Algebra.Homology.Functor","initialProofState":"V : Type u\ninst✝² : CategoryTheory.Category.{v, u} V\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms V\nι : Type u_1\nc : ComplexShape ι\nT : Type u_2\ninst✝ : CategoryTheory.Category.{u_3, u_2} T\nC : HomologicalComplex (CategoryTheory.Functor T V) c\nt : T\n⊢ Eq (C.asFunctor.obj t) { X := fun i => (C.X i).obj t, d := fun i j => (C.d i j).app t, shape := ⋯, d_comp_d' := ⋯ }","decl":"/-- A complex of functors gives a functor to complexes. -/\n@[simps obj map]\ndef asFunctor {T : Type*} [Category T] (C : HomologicalComplex (T ⥤ V) c) :\n    T ⥤ HomologicalComplex V c where\n  obj t :=\n    { X := fun i => (C.X i).obj t\n      d := fun i j => (C.d i j).app t\n      d_comp_d' := fun i j k _ _ => by\n        have := C.d_comp_d i j k\n        rw [NatTrans.ext_iff, funext_iff] at this\n        exact this t\n      shape := fun i j h => by\n        have := C.shape _ _ h\n        rw [NatTrans.ext_iff, funext_iff] at this\n        exact this t }\n  map h :=\n    { f := fun i => (C.X i).map h\n      comm' := fun _ _ _ => NatTrans.naturality _ _ }\n  map_id t := by\n    ext i\n    dsimp\n    rw [(C.X i).map_id]\n  map_comp h₁ h₂ := by\n    ext i\n    dsimp\n    rw [Functor.map_comp]\n\n-- TODO in fact, this is an equivalence of categories.\n"}
{"name":"HomologicalComplex.asFunctor_map","module":"Mathlib.Algebra.Homology.Functor","initialProofState":"V : Type u\ninst✝² : CategoryTheory.Category.{v, u} V\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms V\nι : Type u_1\nc : ComplexShape ι\nT : Type u_2\ninst✝ : CategoryTheory.Category.{u_3, u_2} T\nC : HomologicalComplex (CategoryTheory.Functor T V) c\nX✝ Y✝ : T\nh : Quiver.Hom X✝ Y✝\n⊢ Eq (C.asFunctor.map h) { f := fun i => (C.X i).map h, comm' := ⋯ }","decl":"/-- A complex of functors gives a functor to complexes. -/\n@[simps obj map]\ndef asFunctor {T : Type*} [Category T] (C : HomologicalComplex (T ⥤ V) c) :\n    T ⥤ HomologicalComplex V c where\n  obj t :=\n    { X := fun i => (C.X i).obj t\n      d := fun i j => (C.d i j).app t\n      d_comp_d' := fun i j k _ _ => by\n        have := C.d_comp_d i j k\n        rw [NatTrans.ext_iff, funext_iff] at this\n        exact this t\n      shape := fun i j h => by\n        have := C.shape _ _ h\n        rw [NatTrans.ext_iff, funext_iff] at this\n        exact this t }\n  map h :=\n    { f := fun i => (C.X i).map h\n      comm' := fun _ _ _ => NatTrans.naturality _ _ }\n  map_id t := by\n    ext i\n    dsimp\n    rw [(C.X i).map_id]\n  map_comp h₁ h₂ := by\n    ext i\n    dsimp\n    rw [Functor.map_comp]\n\n-- TODO in fact, this is an equivalence of categories.\n"}
{"name":"HomologicalComplex.complexOfFunctorsToFunctorToComplex_map_app_f","module":"Mathlib.Algebra.Homology.Functor","initialProofState":"V : Type u\ninst✝² : CategoryTheory.Category.{v, u} V\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms V\nι : Type u_1\nc : ComplexShape ι\nT : Type u_2\ninst✝ : CategoryTheory.Category.{u_3, u_2} T\nX✝ Y✝ : HomologicalComplex (CategoryTheory.Functor T V) c\nf : Quiver.Hom X✝ Y✝\nt : T\ni : ι\n⊢ Eq (((HomologicalComplex.complexOfFunctorsToFunctorToComplex.map f).app t).f i) ((f.f i).app t)","decl":"/-- The functorial version of `HomologicalComplex.asFunctor`. -/\n@[simps]\ndef complexOfFunctorsToFunctorToComplex {T : Type*} [Category T] :\n    HomologicalComplex (T ⥤ V) c ⥤ T ⥤ HomologicalComplex V c where\n  obj C := C.asFunctor\n  map f :=\n    { app := fun t =>\n        { f := fun i => (f.f i).app t\n          comm' := fun i j _ => NatTrans.congr_app (f.comm i j) t }\n      naturality := fun t t' g => by\n        ext i\n        exact (f.f i).naturality g }\n\n"}
{"name":"HomologicalComplex.complexOfFunctorsToFunctorToComplex_obj","module":"Mathlib.Algebra.Homology.Functor","initialProofState":"V : Type u\ninst✝² : CategoryTheory.Category.{v, u} V\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms V\nι : Type u_1\nc : ComplexShape ι\nT : Type u_2\ninst✝ : CategoryTheory.Category.{u_3, u_2} T\nC : HomologicalComplex (CategoryTheory.Functor T V) c\n⊢ Eq (HomologicalComplex.complexOfFunctorsToFunctorToComplex.obj C) C.asFunctor","decl":"/-- The functorial version of `HomologicalComplex.asFunctor`. -/\n@[simps]\ndef complexOfFunctorsToFunctorToComplex {T : Type*} [Category T] :\n    HomologicalComplex (T ⥤ V) c ⥤ T ⥤ HomologicalComplex V c where\n  obj C := C.asFunctor\n  map f :=\n    { app := fun t =>\n        { f := fun i => (f.f i).app t\n          comm' := fun i j _ => NatTrans.congr_app (f.comm i j) t }\n      naturality := fun t t' g => by\n        ext i\n        exact (f.f i).naturality g }\n\n"}
