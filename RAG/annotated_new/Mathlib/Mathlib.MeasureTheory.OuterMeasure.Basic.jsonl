{"name":"MeasureTheory.measure_empty","module":"Mathlib.MeasureTheory.OuterMeasure.Basic","initialProofState":"Î± : Type u_1\nF : Type u_3\ninstâœÂ¹ : FunLike F (Set Î±) ENNReal\ninstâœ : MeasureTheory.OuterMeasureClass F Î±\nÎ¼ : F\nâŠ¢ Eq (Î¼ EmptyCollection.emptyCollection) 0","decl":"@[simp]\ntheorem measure_empty : Î¼ âˆ… = 0 := OuterMeasureClass.measure_empty Î¼\n\n"}
{"name":"MeasureTheory.measure_mono","module":"Mathlib.MeasureTheory.OuterMeasure.Basic","initialProofState":"Î± : Type u_1\nF : Type u_3\ninstâœÂ¹ : FunLike F (Set Î±) ENNReal\ninstâœ : MeasureTheory.OuterMeasureClass F Î±\nÎ¼ : F\ns t : Set Î±\nh : HasSubset.Subset s t\nâŠ¢ LE.le (Î¼ s) (Î¼ t)","decl":"@[mono, gcongr]\ntheorem measure_mono (h : s âŠ† t) : Î¼ s â‰¤ Î¼ t :=\n  OuterMeasureClass.measure_mono Î¼ h\n\n"}
{"name":"MeasureTheory.measure_mono_null","module":"Mathlib.MeasureTheory.OuterMeasure.Basic","initialProofState":"Î± : Type u_1\nF : Type u_3\ninstâœÂ¹ : FunLike F (Set Î±) ENNReal\ninstâœ : MeasureTheory.OuterMeasureClass F Î±\nÎ¼ : F\ns t : Set Î±\nh : HasSubset.Subset s t\nht : Eq (Î¼ t) 0\nâŠ¢ Eq (Î¼ s) 0","decl":"theorem measure_mono_null (h : s âŠ† t) (ht : Î¼ t = 0) : Î¼ s = 0 :=\n  eq_bot_mono (measure_mono h) ht\n\n"}
{"name":"MeasureTheory.measure_pos_of_superset","module":"Mathlib.MeasureTheory.OuterMeasure.Basic","initialProofState":"Î± : Type u_1\nF : Type u_3\ninstâœÂ¹ : FunLike F (Set Î±) ENNReal\ninstâœ : MeasureTheory.OuterMeasureClass F Î±\nÎ¼ : F\ns t : Set Î±\nh : HasSubset.Subset s t\nhs : Ne (Î¼ s) 0\nâŠ¢ LT.lt 0 (Î¼ t)","decl":"theorem measure_pos_of_superset (h : s âŠ† t) (hs : Î¼ s â‰  0) : 0 < Î¼ t :=\n  hs.bot_lt.trans_le (measure_mono h)\n\n"}
{"name":"MeasureTheory.measure_iUnion_le","module":"Mathlib.MeasureTheory.OuterMeasure.Basic","initialProofState":"Î± : Type u_1\nÎ¹ : Type u_2\nF : Type u_3\ninstâœÂ² : FunLike F (Set Î±) ENNReal\ninstâœÂ¹ : MeasureTheory.OuterMeasureClass F Î±\nÎ¼ : F\ninstâœ : Countable Î¹\ns : Î¹ â†’ Set Î±\nâŠ¢ LE.le (Î¼ (Set.iUnion fun i => s i)) (tsum fun i => Î¼ (s i))","decl":"theorem measure_iUnion_le [Countable Î¹] (s : Î¹ â†’ Set Î±) : Î¼ (â‹ƒ i, s i) â‰¤ âˆ‘' i, Î¼ (s i) := by\n  refine rel_iSup_tsum Î¼ measure_empty (Â· â‰¤ Â·) (fun t â†¦ ?_) _\n  calc\n    Î¼ (â‹ƒ i, t i) = Î¼ (â‹ƒ i, disjointed t i) := by rw [iUnion_disjointed]\n    _ â‰¤ âˆ‘' i, Î¼ (disjointed t i) :=\n      OuterMeasureClass.measure_iUnion_nat_le _ _ (disjoint_disjointed _)\n    _ â‰¤ âˆ‘' i, Î¼ (t i) := by gcongr; exact disjointed_subset ..\n\n"}
{"name":"MeasureTheory.measure_biUnion_le","module":"Mathlib.MeasureTheory.OuterMeasure.Basic","initialProofState":"Î± : Type u_1\nÎ¹ : Type u_2\nF : Type u_3\ninstâœÂ¹ : FunLike F (Set Î±) ENNReal\ninstâœ : MeasureTheory.OuterMeasureClass F Î±\nI : Set Î¹\nÎ¼ : F\nhI : I.Countable\ns : Î¹ â†’ Set Î±\nâŠ¢ LE.le (Î¼ (Set.iUnion fun i => Set.iUnion fun h => s i)) (tsum fun i => Î¼ (s â†‘i))","decl":"theorem measure_biUnion_le {I : Set Î¹} (Î¼ : F) (hI : I.Countable) (s : Î¹ â†’ Set Î±) :\n    Î¼ (â‹ƒ i âˆˆ I, s i) â‰¤ âˆ‘' i : I, Î¼ (s i) := by\n  have := hI.to_subtype\n  rw [biUnion_eq_iUnion]\n  apply measure_iUnion_le\n\n"}
{"name":"MeasureTheory.measure_biUnion_finset_le","module":"Mathlib.MeasureTheory.OuterMeasure.Basic","initialProofState":"Î± : Type u_1\nÎ¹ : Type u_2\nF : Type u_3\ninstâœÂ¹ : FunLike F (Set Î±) ENNReal\ninstâœ : MeasureTheory.OuterMeasureClass F Î±\nÎ¼ : F\nI : Finset Î¹\ns : Î¹ â†’ Set Î±\nâŠ¢ LE.le (Î¼ (Set.iUnion fun i => Set.iUnion fun h => s i)) (I.sum fun i => Î¼ (s i))","decl":"theorem measure_biUnion_finset_le (I : Finset Î¹) (s : Î¹ â†’ Set Î±) :\n    Î¼ (â‹ƒ i âˆˆ I, s i) â‰¤ âˆ‘ i âˆˆ I, Î¼ (s i) :=\n  (measure_biUnion_le Î¼ I.countable_toSet s).trans_eq <| I.tsum_subtype (Î¼ <| s Â·)\n\n"}
{"name":"MeasureTheory.measure_iUnion_fintype_le","module":"Mathlib.MeasureTheory.OuterMeasure.Basic","initialProofState":"Î± : Type u_1\nÎ¹ : Type u_2\nF : Type u_3\ninstâœÂ² : FunLike F (Set Î±) ENNReal\ninstâœÂ¹ : MeasureTheory.OuterMeasureClass F Î±\ninstâœ : Fintype Î¹\nÎ¼ : F\ns : Î¹ â†’ Set Î±\nâŠ¢ LE.le (Î¼ (Set.iUnion fun i => s i)) (Finset.univ.sum fun i => Î¼ (s i))","decl":"theorem measure_iUnion_fintype_le [Fintype Î¹] (Î¼ : F) (s : Î¹ â†’ Set Î±) :\n    Î¼ (â‹ƒ i, s i) â‰¤ âˆ‘ i, Î¼ (s i) := by\n  simpa using measure_biUnion_finset_le Finset.univ s\n\n"}
{"name":"MeasureTheory.measure_union_le","module":"Mathlib.MeasureTheory.OuterMeasure.Basic","initialProofState":"Î± : Type u_1\nF : Type u_3\ninstâœÂ¹ : FunLike F (Set Î±) ENNReal\ninstâœ : MeasureTheory.OuterMeasureClass F Î±\nÎ¼ : F\ns t : Set Î±\nâŠ¢ LE.le (Î¼ (Union.union s t)) (HAdd.hAdd (Î¼ s) (Î¼ t))","decl":"theorem measure_union_le (s t : Set Î±) : Î¼ (s âˆª t) â‰¤ Î¼ s + Î¼ t := by\n  simpa [union_eq_iUnion] using measure_iUnion_fintype_le Î¼ (cond Â· s t)\n\n"}
{"name":"MeasureTheory.measure_univ_le_add_compl","module":"Mathlib.MeasureTheory.OuterMeasure.Basic","initialProofState":"Î± : Type u_1\nF : Type u_3\ninstâœÂ¹ : FunLike F (Set Î±) ENNReal\ninstâœ : MeasureTheory.OuterMeasureClass F Î±\nÎ¼ : F\ns : Set Î±\nâŠ¢ LE.le (Î¼ Set.univ) (HAdd.hAdd (Î¼ s) (Î¼ (HasCompl.compl s)))","decl":"lemma measure_univ_le_add_compl (s : Set Î±) : Î¼ univ â‰¤ Î¼ s + Î¼ sá¶œ :=\n  s.union_compl_self â–¸ measure_union_le s sá¶œ\n\n"}
{"name":"MeasureTheory.measure_le_inter_add_diff","module":"Mathlib.MeasureTheory.OuterMeasure.Basic","initialProofState":"Î± : Type u_1\nF : Type u_3\ninstâœÂ¹ : FunLike F (Set Î±) ENNReal\ninstâœ : MeasureTheory.OuterMeasureClass F Î±\nÎ¼ : F\ns t : Set Î±\nâŠ¢ LE.le (Î¼ s) (HAdd.hAdd (Î¼ (Inter.inter s t)) (Î¼ (SDiff.sdiff s t)))","decl":"theorem measure_le_inter_add_diff (Î¼ : F) (s t : Set Î±) : Î¼ s â‰¤ Î¼ (s âˆ© t) + Î¼ (s \\ t) := by\n  simpa using measure_union_le (s âˆ© t) (s \\ t)\n\n"}
{"name":"MeasureTheory.measure_diff_null","module":"Mathlib.MeasureTheory.OuterMeasure.Basic","initialProofState":"Î± : Type u_1\nF : Type u_3\ninstâœÂ¹ : FunLike F (Set Î±) ENNReal\ninstâœ : MeasureTheory.OuterMeasureClass F Î±\nÎ¼ : F\ns t : Set Î±\nht : Eq (Î¼ t) 0\nâŠ¢ Eq (Î¼ (SDiff.sdiff s t)) (Î¼ s)","decl":"theorem measure_diff_null (ht : Î¼ t = 0) : Î¼ (s \\ t) = Î¼ s :=\n  (measure_mono diff_subset).antisymm <| calc\n    Î¼ s â‰¤ Î¼ (s âˆ© t) + Î¼ (s \\ t) := measure_le_inter_add_diff _ _ _\n    _ â‰¤ Î¼ t + Î¼ (s \\ t) := by gcongr; apply inter_subset_right\n    _ = Î¼ (s \\ t) := by simp [ht]\n\n"}
{"name":"MeasureTheory.measure_biUnion_null_iff","module":"Mathlib.MeasureTheory.OuterMeasure.Basic","initialProofState":"Î± : Type u_1\nÎ¹ : Type u_2\nF : Type u_3\ninstâœÂ¹ : FunLike F (Set Î±) ENNReal\ninstâœ : MeasureTheory.OuterMeasureClass F Î±\nÎ¼ : F\nI : Set Î¹\nhI : I.Countable\ns : Î¹ â†’ Set Î±\nâŠ¢ Iff (Eq (Î¼ (Set.iUnion fun i => Set.iUnion fun h => s i)) 0) (âˆ€ (i : Î¹), Membership.mem I i â†’ Eq (Î¼ (s i)) 0)","decl":"theorem measure_biUnion_null_iff {I : Set Î¹} (hI : I.Countable) {s : Î¹ â†’ Set Î±} :\n    Î¼ (â‹ƒ i âˆˆ I, s i) = 0 â†” âˆ€ i âˆˆ I, Î¼ (s i) = 0 := by\n  refine âŸ¨fun h i hi â†¦ measure_mono_null (subset_biUnion_of_mem hi) h, fun h â†¦ ?_âŸ©\n  have _ := hI.to_subtype\n  simpa [h] using measure_iUnion_le (Î¼ := Î¼) fun x : I â†¦ s x\n\n"}
{"name":"MeasureTheory.measure_sUnion_null_iff","module":"Mathlib.MeasureTheory.OuterMeasure.Basic","initialProofState":"Î± : Type u_1\nF : Type u_3\ninstâœÂ¹ : FunLike F (Set Î±) ENNReal\ninstâœ : MeasureTheory.OuterMeasureClass F Î±\nÎ¼ : F\nS : Set (Set Î±)\nhS : S.Countable\nâŠ¢ Iff (Eq (Î¼ S.sUnion) 0) (âˆ€ (s : Set Î±), Membership.mem S s â†’ Eq (Î¼ s) 0)","decl":"theorem measure_sUnion_null_iff {S : Set (Set Î±)} (hS : S.Countable) :\n    Î¼ (â‹ƒâ‚€ S) = 0 â†” âˆ€ s âˆˆ S, Î¼ s = 0 := by\n  rw [sUnion_eq_biUnion, measure_biUnion_null_iff hS]\n\n"}
{"name":"MeasureTheory.measure_iUnion_null_iff","module":"Mathlib.MeasureTheory.OuterMeasure.Basic","initialProofState":"Î± : Type u_1\nF : Type u_3\ninstâœÂ² : FunLike F (Set Î±) ENNReal\ninstâœÂ¹ : MeasureTheory.OuterMeasureClass F Î±\nÎ¼ : F\nÎ¹ : Sort u_4\ninstâœ : Countable Î¹\ns : Î¹ â†’ Set Î±\nâŠ¢ Iff (Eq (Î¼ (Set.iUnion fun i => s i)) 0) (âˆ€ (i : Î¹), Eq (Î¼ (s i)) 0)","decl":"@[simp]\ntheorem measure_iUnion_null_iff {Î¹ : Sort*} [Countable Î¹] {s : Î¹ â†’ Set Î±} :\n    Î¼ (â‹ƒ i, s i) = 0 â†” âˆ€ i, Î¼ (s i) = 0 := by\n  rw [â† sUnion_range, measure_sUnion_null_iff (countable_range s), forall_mem_range]\n\n"}
{"name":"MeasureTheory.measure_iUnion_null","module":"Mathlib.MeasureTheory.OuterMeasure.Basic","initialProofState":"Î± : Type u_1\nF : Type u_3\ninstâœÂ² : FunLike F (Set Î±) ENNReal\ninstâœÂ¹ : MeasureTheory.OuterMeasureClass F Î±\nÎ¼ : F\nÎ¹ : Sort u_4\ninstâœ : Countable Î¹\ns : Î¹ â†’ Set Î±\naâœ : âˆ€ (i : Î¹), Eq (Î¼ (s i)) 0\nâŠ¢ Eq (Î¼ (Set.iUnion fun i => s i)) 0","decl":"alias âŸ¨_, measure_iUnion_nullâŸ© := measure_iUnion_null_iff\n\n"}
{"name":"MeasureTheory.measure_union_null_iff","module":"Mathlib.MeasureTheory.OuterMeasure.Basic","initialProofState":"Î± : Type u_1\nF : Type u_3\ninstâœÂ¹ : FunLike F (Set Î±) ENNReal\ninstâœ : MeasureTheory.OuterMeasureClass F Î±\nÎ¼ : F\ns t : Set Î±\nâŠ¢ Iff (Eq (Î¼ (Union.union s t)) 0) (And (Eq (Î¼ s) 0) (Eq (Î¼ t) 0))","decl":"@[simp]\ntheorem measure_union_null_iff : Î¼ (s âˆª t) = 0 â†” Î¼ s = 0 âˆ§ Î¼ t = 0 := by\n  simp [union_eq_iUnion, and_comm]\n\n"}
{"name":"MeasureTheory.measure_union_null","module":"Mathlib.MeasureTheory.OuterMeasure.Basic","initialProofState":"Î± : Type u_1\nF : Type u_3\ninstâœÂ¹ : FunLike F (Set Î±) ENNReal\ninstâœ : MeasureTheory.OuterMeasureClass F Î±\nÎ¼ : F\ns t : Set Î±\nhs : Eq (Î¼ s) 0\nht : Eq (Î¼ t) 0\nâŠ¢ Eq (Î¼ (Union.union s t)) 0","decl":"theorem measure_union_null (hs : Î¼ s = 0) (ht : Î¼ t = 0) : Î¼ (s âˆª t) = 0 := by simp [*]\n\n"}
{"name":"MeasureTheory.measure_null_iff_singleton","module":"Mathlib.MeasureTheory.OuterMeasure.Basic","initialProofState":"Î± : Type u_1\nF : Type u_3\ninstâœÂ¹ : FunLike F (Set Î±) ENNReal\ninstâœ : MeasureTheory.OuterMeasureClass F Î±\nÎ¼ : F\ns : Set Î±\nhs : s.Countable\nâŠ¢ Iff (Eq (Î¼ s) 0) (âˆ€ (x : Î±), Membership.mem s x â†’ Eq (Î¼ (Singleton.singleton x)) 0)","decl":"lemma measure_null_iff_singleton (hs : s.Countable) : Î¼ s = 0 â†” âˆ€ x âˆˆ s, Î¼ {x} = 0 := by\n  rw [â† measure_biUnion_null_iff hs, biUnion_of_singleton]\n\n"}
{"name":"MeasureTheory.measure_iUnion_of_tendsto_zero","module":"Mathlib.MeasureTheory.OuterMeasure.Basic","initialProofState":"Î± : Type u_1\nF : Type u_3\ninstâœÂ² : FunLike F (Set Î±) ENNReal\ninstâœÂ¹ : MeasureTheory.OuterMeasureClass F Î±\nÎ¹ : Type u_4\nÎ¼ : F\ns : Î¹ â†’ Set Î±\nl : Filter Î¹\ninstâœ : l.NeBot\nh0 : Filter.Tendsto (fun k => Î¼ (SDiff.sdiff (Set.iUnion fun n => s n) (s k))) l (nhds 0)\nâŠ¢ Eq (Î¼ (Set.iUnion fun n => s n)) (iSup fun n => Î¼ (s n))","decl":"/-- Let `Î¼` be an (outer) measure; let `s : Î¹ â†’ Set Î±` be a sequence of sets, `S = â‹ƒ n, s n`.\nIf `Î¼ (S \\ s n)` tends to zero along some nontrivial filter (usually `Filter.atTop` on `Î¹ = â„•`),\nthen `Î¼ S = â¨† n, Î¼ (s n)`. -/\ntheorem measure_iUnion_of_tendsto_zero {Î¹} (Î¼ : F) {s : Î¹ â†’ Set Î±} (l : Filter Î¹) [NeBot l]\n    (h0 : Tendsto (fun k => Î¼ ((â‹ƒ n, s n) \\ s k)) l (ğ“ 0)) : Î¼ (â‹ƒ n, s n) = â¨† n, Î¼ (s n) := by\n  refine le_antisymm ?_ <| iSup_le fun n â†¦ measure_mono <| subset_iUnion _ _\n  set S := â‹ƒ n, s n\n  set M := â¨† n, Î¼ (s n)\n  have A : âˆ€ k, Î¼ S â‰¤ M + Î¼ (S \\ s k) := fun k â†¦ calc\n    Î¼ S â‰¤ Î¼ (S âˆ© s k) + Î¼ (S \\ s k) := measure_le_inter_add_diff _ _ _\n    _ â‰¤ Î¼ (s k) + Î¼ (S \\ s k) := by gcongr; apply inter_subset_right\n    _ â‰¤ M + Î¼ (S \\ s k) := by gcongr; exact le_iSup (Î¼ âˆ˜ s) k\n  have B : Tendsto (fun k â†¦ M + Î¼ (S \\ s k)) l (ğ“ M) := by simpa using tendsto_const_nhds.add h0\n  exact ge_of_tendsto' B A\n\n"}
{"name":"MeasureTheory.measure_null_of_locally_null","module":"Mathlib.MeasureTheory.OuterMeasure.Basic","initialProofState":"Î± : Type u_1\nF : Type u_3\ninstâœÂ³ : FunLike F (Set Î±) ENNReal\ninstâœÂ² : MeasureTheory.OuterMeasureClass F Î±\nÎ¼ : F\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : SecondCountableTopology Î±\ns : Set Î±\nhs : âˆ€ (x : Î±), Membership.mem s x â†’ Exists fun u => And (Membership.mem (nhdsWithin x s) u) (Eq (Î¼ u) 0)\nâŠ¢ Eq (Î¼ s) 0","decl":"/-- If a set has zero measure in a neighborhood of each of its points, then it has zero measure\nin a second-countable space. -/\ntheorem measure_null_of_locally_null [TopologicalSpace Î±] [SecondCountableTopology Î±]\n    (s : Set Î±) (hs : âˆ€ x âˆˆ s, âˆƒ u âˆˆ ğ“[s] x, Î¼ u = 0) : Î¼ s = 0 := by\n  choose! u hxu huâ‚€ using hs\n  choose t ht using TopologicalSpace.countable_cover_nhdsWithin hxu\n  rcases ht with âŸ¨ts, t_count, htâŸ©\n  apply measure_mono_null ht\n  exact (measure_biUnion_null_iff t_count).2 fun x hx => huâ‚€ x (ts hx)\n\n"}
{"name":"MeasureTheory.exists_mem_forall_mem_nhdsWithin_pos_measure","module":"Mathlib.MeasureTheory.OuterMeasure.Basic","initialProofState":"Î± : Type u_1\nF : Type u_3\ninstâœÂ³ : FunLike F (Set Î±) ENNReal\ninstâœÂ² : MeasureTheory.OuterMeasureClass F Î±\nÎ¼ : F\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : SecondCountableTopology Î±\ns : Set Î±\nhs : Ne (Î¼ s) 0\nâŠ¢ Exists fun x => And (Membership.mem s x) (âˆ€ (t : Set Î±), Membership.mem (nhdsWithin x s) t â†’ LT.lt 0 (Î¼ t))","decl":"/-- If `m s â‰  0`, then for some point `x âˆˆ s` and any `t âˆˆ ğ“[s] x` we have `0 < m t`. -/\ntheorem exists_mem_forall_mem_nhdsWithin_pos_measure [TopologicalSpace Î±]\n    [SecondCountableTopology Î±] {s : Set Î±} (hs : Î¼ s â‰  0) :\n    âˆƒ x âˆˆ s, âˆ€ t âˆˆ ğ“[s] x, 0 < Î¼ t := by\n  contrapose! hs\n  simp only [nonpos_iff_eq_zero] at hs\n  exact measure_null_of_locally_null s hs\n\n"}
{"name":"MeasureTheory.OuterMeasure.iUnion_of_tendsto_zero","module":"Mathlib.MeasureTheory.OuterMeasure.Basic","initialProofState":"Î± : Type u_1\nÎ¹ : Type u_3\nm : MeasureTheory.OuterMeasure Î±\ns : Î¹ â†’ Set Î±\nl : Filter Î¹\ninstâœ : l.NeBot\nh0 : Filter.Tendsto (fun k => m (SDiff.sdiff (Set.iUnion fun n => s n) (s k))) l (nhds 0)\nâŠ¢ Eq (m (Set.iUnion fun n => s n)) (iSup fun n => m (s n))","decl":"/-- If `s : Î¹ â†’ Set Î±` is a sequence of sets, `S = â‹ƒ n, s n`, and `m (S \\ s n)` tends to zero along\nsome nontrivial filter (usually `atTop` on `Î¹ = â„•`), then `m S = â¨† n, m (s n)`. -/\ntheorem iUnion_of_tendsto_zero {Î¹} (m : OuterMeasure Î±) {s : Î¹ â†’ Set Î±} (l : Filter Î¹) [NeBot l]\n    (h0 : Tendsto (fun k => m ((â‹ƒ n, s n) \\ s k)) l (ğ“ 0)) : m (â‹ƒ n, s n) = â¨† n, m (s n) :=\n  measure_iUnion_of_tendsto_zero m l h0\n\n"}
{"name":"MeasureTheory.OuterMeasure.iUnion_nat_of_monotone_of_tsum_ne_top","module":"Mathlib.MeasureTheory.OuterMeasure.Basic","initialProofState":"Î± : Type u_1\nm : MeasureTheory.OuterMeasure Î±\ns : Nat â†’ Set Î±\nh_mono : âˆ€ (n : Nat), HasSubset.Subset (s n) (s (HAdd.hAdd n 1))\nh0 : Ne (tsum fun k => m (SDiff.sdiff (s (HAdd.hAdd k 1)) (s k))) Top.top\nâŠ¢ Eq (m (Set.iUnion fun n => s n)) (iSup fun n => m (s n))","decl":"/-- If `s : â„• â†’ Set Î±` is a monotone sequence of sets such that `âˆ‘' k, m (s (k + 1) \\ s k) â‰  âˆ`,\nthen `m (â‹ƒ n, s n) = â¨† n, m (s n)`. -/\ntheorem iUnion_nat_of_monotone_of_tsum_ne_top (m : OuterMeasure Î±) {s : â„• â†’ Set Î±}\n    (h_mono : âˆ€ n, s n âŠ† s (n + 1)) (h0 : (âˆ‘' k, m (s (k + 1) \\ s k)) â‰  âˆ) :\n    m (â‹ƒ n, s n) = â¨† n, m (s n) := by\n  classical\n  refine measure_iUnion_of_tendsto_zero m atTop ?_\n  refine tendsto_nhds_bot_mono' (ENNReal.tendsto_sum_nat_add _ h0) fun n => ?_\n  refine (m.mono ?_).trans (measure_iUnion_le _)\n  -- Current goal: `(â‹ƒ k, s k) \\ s n âŠ† â‹ƒ k, s (k + n + 1) \\ s (k + n)`\n  have h' : Monotone s := @monotone_nat_of_le_succ (Set Î±) _ _ h_mono\n  simp only [diff_subset_iff, iUnion_subset_iff]\n  intro i x hx\n  have : âˆƒi, x âˆˆ s i := by exists i\n  rcases Nat.findX this with âŸ¨j, hj, hltâŸ©\n  clear hx i\n  rcases le_or_lt j n with hjn | hnj\n  Â· exact Or.inl (h' hjn hj)\n  have : j - (n + 1) + n + 1 = j := by omega\n  refine Or.inr (mem_iUnion.2 âŸ¨j - (n + 1), ?_, hlt _ ?_âŸ©)\n  Â· rwa [this]\n  Â· rw [â† Nat.succ_le_iff, Nat.succ_eq_add_one, this]\n\n"}
{"name":"MeasureTheory.OuterMeasure.coe_fn_injective","module":"Mathlib.MeasureTheory.OuterMeasure.Basic","initialProofState":"Î± : Type u_1\nâŠ¢ Function.Injective fun Î¼ s => Î¼ s","decl":"theorem coe_fn_injective : Injective fun (Î¼ : OuterMeasure Î±) (s : Set Î±) => Î¼ s :=\n  DFunLike.coe_injective\n\n"}
{"name":"MeasureTheory.OuterMeasure.ext","module":"Mathlib.MeasureTheory.OuterMeasure.Basic","initialProofState":"Î± : Type u_1\nÎ¼â‚ Î¼â‚‚ : MeasureTheory.OuterMeasure Î±\nh : âˆ€ (s : Set Î±), Eq (Î¼â‚ s) (Î¼â‚‚ s)\nâŠ¢ Eq Î¼â‚ Î¼â‚‚","decl":"@[ext]\ntheorem ext {Î¼â‚ Î¼â‚‚ : OuterMeasure Î±} (h : âˆ€ s, Î¼â‚ s = Î¼â‚‚ s) : Î¼â‚ = Î¼â‚‚ :=\n  DFunLike.ext _ _ h\n\n"}
{"name":"MeasureTheory.OuterMeasure.ext_iff","module":"Mathlib.MeasureTheory.OuterMeasure.Basic","initialProofState":"Î± : Type u_1\nÎ¼â‚ Î¼â‚‚ : MeasureTheory.OuterMeasure Î±\nâŠ¢ Iff (Eq Î¼â‚ Î¼â‚‚) (âˆ€ (s : Set Î±), Eq (Î¼â‚ s) (Î¼â‚‚ s))","decl":"@[ext]\ntheorem ext {Î¼â‚ Î¼â‚‚ : OuterMeasure Î±} (h : âˆ€ s, Î¼â‚ s = Î¼â‚‚ s) : Î¼â‚ = Î¼â‚‚ :=\n  DFunLike.ext _ _ h\n\n"}
{"name":"MeasureTheory.OuterMeasure.ext_nonempty","module":"Mathlib.MeasureTheory.OuterMeasure.Basic","initialProofState":"Î± : Type u_1\nÎ¼â‚ Î¼â‚‚ : MeasureTheory.OuterMeasure Î±\nh : âˆ€ (s : Set Î±), s.Nonempty â†’ Eq (Î¼â‚ s) (Î¼â‚‚ s)\nâŠ¢ Eq Î¼â‚ Î¼â‚‚","decl":"/-- A version of `MeasureTheory.OuterMeasure.ext` that assumes `Î¼â‚ s = Î¼â‚‚ s` on all *nonempty*\nsets `s`, and gets `Î¼â‚ âˆ… = Î¼â‚‚ âˆ…` from `MeasureTheory.OuterMeasure.empty'`. -/\ntheorem ext_nonempty {Î¼â‚ Î¼â‚‚ : OuterMeasure Î±} (h : âˆ€ s : Set Î±, s.Nonempty â†’ Î¼â‚ s = Î¼â‚‚ s) :\n    Î¼â‚ = Î¼â‚‚ :=\n  ext fun s => s.eq_empty_or_nonempty.elim (fun he => by simp [he]) (h s)\n\n"}
