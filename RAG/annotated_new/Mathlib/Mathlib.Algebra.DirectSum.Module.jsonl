{"name":"DirectSum.instSMulCommClass","module":"Mathlib.Algebra.DirectSum.Module","initialProofState":"R : Type u\ninst✝⁵ : Semiring R\nι : Type v\nM : ι → Type w\ninst✝⁴ : (i : ι) → AddCommMonoid (M i)\ninst✝³ : (i : ι) → Module R (M i)\nS : Type u_1\ninst✝² : Semiring S\ninst✝¹ : (i : ι) → Module S (M i)\ninst✝ : ∀ (i : ι), SMulCommClass R S (M i)\n⊢ SMulCommClass R S (DirectSum ι fun i => M i)","decl":"instance {S : Type*} [Semiring S] [∀ i, Module S (M i)] [∀ i, SMulCommClass R S (M i)] :\n    SMulCommClass R S (⨁ i, M i) :=\n  DFinsupp.smulCommClass\n\n"}
{"name":"DirectSum.instIsScalarTower","module":"Mathlib.Algebra.DirectSum.Module","initialProofState":"R : Type u\ninst✝⁶ : Semiring R\nι : Type v\nM : ι → Type w\ninst✝⁵ : (i : ι) → AddCommMonoid (M i)\ninst✝⁴ : (i : ι) → Module R (M i)\nS : Type u_1\ninst✝³ : Semiring S\ninst✝² : SMul R S\ninst✝¹ : (i : ι) → Module S (M i)\ninst✝ : ∀ (i : ι), IsScalarTower R S (M i)\n⊢ IsScalarTower R S (DirectSum ι fun i => M i)","decl":"instance {S : Type*} [Semiring S] [SMul R S] [∀ i, Module S (M i)] [∀ i, IsScalarTower R S (M i)] :\n    IsScalarTower R S (⨁ i, M i) :=\n  DFinsupp.isScalarTower\n\n"}
{"name":"DirectSum.instIsCentralScalar","module":"Mathlib.Algebra.DirectSum.Module","initialProofState":"R : Type u\ninst✝⁴ : Semiring R\nι : Type v\nM : ι → Type w\ninst✝³ : (i : ι) → AddCommMonoid (M i)\ninst✝² : (i : ι) → Module R (M i)\ninst✝¹ : (i : ι) → Module (MulOpposite R) (M i)\ninst✝ : ∀ (i : ι), IsCentralScalar R (M i)\n⊢ IsCentralScalar R (DirectSum ι fun i => M i)","decl":"instance [∀ i, Module Rᵐᵒᵖ (M i)] [∀ i, IsCentralScalar R (M i)] : IsCentralScalar R (⨁ i, M i) :=\n  DFinsupp.isCentralScalar\n\n"}
{"name":"DirectSum.smul_apply","module":"Mathlib.Algebra.DirectSum.Module","initialProofState":"R : Type u\ninst✝² : Semiring R\nι : Type v\nM : ι → Type w\ninst✝¹ : (i : ι) → AddCommMonoid (M i)\ninst✝ : (i : ι) → Module R (M i)\nb : R\nv : DirectSum ι fun i => M i\ni : ι\n⊢ Eq ((HSMul.hSMul b v) i) (HSMul.hSMul b (v i))","decl":"theorem smul_apply (b : R) (v : ⨁ i, M i) (i : ι) : (b • v) i = b • v i :=\n  DFinsupp.smul_apply _ _ _\n\n"}
{"name":"DirectSum.lof_eq_of","module":"Mathlib.Algebra.DirectSum.Module","initialProofState":"R : Type u\ninst✝³ : Semiring R\nι : Type v\nM : ι → Type w\ninst✝² : (i : ι) → AddCommMonoid (M i)\ninst✝¹ : (i : ι) → Module R (M i)\ninst✝ : DecidableEq ι\ni : ι\nb : M i\n⊢ Eq ((DirectSum.lof R ι M i) b) ((DirectSum.of M i) b)","decl":"theorem lof_eq_of (i : ι) (b : M i) : lof R ι M i b = of M i b := rfl\n\n"}
{"name":"DirectSum.single_eq_lof","module":"Mathlib.Algebra.DirectSum.Module","initialProofState":"R : Type u\ninst✝³ : Semiring R\nι : Type v\nM : ι → Type w\ninst✝² : (i : ι) → AddCommMonoid (M i)\ninst✝¹ : (i : ι) → Module R (M i)\ninst✝ : DecidableEq ι\ni : ι\nb : M i\n⊢ Eq (DFinsupp.single i b) ((DirectSum.lof R ι M i) b)","decl":"theorem single_eq_lof (i : ι) (b : M i) : DFinsupp.single i b = lof R ι M i b := rfl\n\n"}
{"name":"DirectSum.mk_smul","module":"Mathlib.Algebra.DirectSum.Module","initialProofState":"R : Type u\ninst✝³ : Semiring R\nι : Type v\nM : ι → Type w\ninst✝² : (i : ι) → AddCommMonoid (M i)\ninst✝¹ : (i : ι) → Module R (M i)\ninst✝ : DecidableEq ι\ns : Finset ι\nc : R\nx : (i : ↑↑s) → M ↑i\n⊢ Eq ((DirectSum.mk M s) (HSMul.hSMul c x)) (HSMul.hSMul c ((DirectSum.mk M s) x))","decl":"/-- Scalar multiplication commutes with direct sums. -/\ntheorem mk_smul (s : Finset ι) (c : R) (x) : mk M s (c • x) = c • mk M s x :=\n  (lmk R ι M s).map_smul c x\n\n"}
{"name":"DirectSum.of_smul","module":"Mathlib.Algebra.DirectSum.Module","initialProofState":"R : Type u\ninst✝³ : Semiring R\nι : Type v\nM : ι → Type w\ninst✝² : (i : ι) → AddCommMonoid (M i)\ninst✝¹ : (i : ι) → Module R (M i)\ninst✝ : DecidableEq ι\ni : ι\nc : R\nx : M i\n⊢ Eq ((DirectSum.of M i) (HSMul.hSMul c x)) (HSMul.hSMul c ((DirectSum.of M i) x))","decl":"/-- Scalar multiplication commutes with the inclusion of each component into the direct sum. -/\ntheorem of_smul (i : ι) (c : R) (x) : of M i (c • x) = c • of M i x :=\n  (lof R ι M i).map_smul c x\n\n"}
{"name":"DirectSum.support_smul","module":"Mathlib.Algebra.DirectSum.Module","initialProofState":"R : Type u\ninst✝⁴ : Semiring R\nι : Type v\nM : ι → Type w\ninst✝³ : (i : ι) → AddCommMonoid (M i)\ninst✝² : (i : ι) → Module R (M i)\ninst✝¹ : DecidableEq ι\ninst✝ : (i : ι) → (x : M i) → Decidable (Ne x 0)\nc : R\nv : DirectSum ι fun i => M i\n⊢ HasSubset.Subset (DFinsupp.support (HSMul.hSMul c v)) (DFinsupp.support v)","decl":"theorem support_smul [∀ (i : ι) (x : M i), Decidable (x ≠ 0)] (c : R) (v : ⨁ i, M i) :\n    (c • v).support ⊆ v.support :=\n  DFinsupp.support_smul _ _\n\n"}
{"name":"DirectSum.coe_toModule_eq_coe_toAddMonoid","module":"Mathlib.Algebra.DirectSum.Module","initialProofState":"R : Type u\ninst✝⁵ : Semiring R\nι : Type v\nM : ι → Type w\ninst✝⁴ : (i : ι) → AddCommMonoid (M i)\ninst✝³ : (i : ι) → Module R (M i)\ninst✝² : DecidableEq ι\nN : Type u₁\ninst✝¹ : AddCommMonoid N\ninst✝ : Module R N\nφ : (i : ι) → LinearMap (RingHom.id R) (M i) N\n⊢ Eq ⇑(DirectSum.toModule R ι N φ) ⇑(DirectSum.toAddMonoid fun i => (φ i).toAddMonoidHom)","decl":"/-- Coproducts in the categories of modules and additive monoids commute with the forgetful functor\nfrom modules to additive monoids. -/\ntheorem coe_toModule_eq_coe_toAddMonoid :\n    (toModule R ι N φ : (⨁ i, M i) → N) = toAddMonoid fun i ↦ (φ i).toAddMonoidHom := rfl\n\n"}
{"name":"DirectSum.toModule_lof","module":"Mathlib.Algebra.DirectSum.Module","initialProofState":"R : Type u\ninst✝⁵ : Semiring R\nι : Type v\nM : ι → Type w\ninst✝⁴ : (i : ι) → AddCommMonoid (M i)\ninst✝³ : (i : ι) → Module R (M i)\ninst✝² : DecidableEq ι\nN : Type u₁\ninst✝¹ : AddCommMonoid N\ninst✝ : Module R N\nφ : (i : ι) → LinearMap (RingHom.id R) (M i) N\ni : ι\nx : M i\n⊢ Eq ((DirectSum.toModule R ι N φ) ((DirectSum.lof R ι M i) x)) ((φ i) x)","decl":"/-- The map constructed using the universal property gives back the original maps when\nrestricted to each component. -/\n@[simp]\ntheorem toModule_lof (i) (x : M i) : toModule R ι N φ (lof R ι M i x) = φ i x :=\n  toAddMonoid_of (fun i ↦ (φ i).toAddMonoidHom) i x\n\n"}
{"name":"DirectSum.toModule.unique","module":"Mathlib.Algebra.DirectSum.Module","initialProofState":"R : Type u\ninst✝⁵ : Semiring R\nι : Type v\nM : ι → Type w\ninst✝⁴ : (i : ι) → AddCommMonoid (M i)\ninst✝³ : (i : ι) → Module R (M i)\ninst✝² : DecidableEq ι\nN : Type u₁\ninst✝¹ : AddCommMonoid N\ninst✝ : Module R N\nψ : LinearMap (RingHom.id R) (DirectSum ι fun i => M i) N\nf : DirectSum ι fun i => M i\n⊢ Eq (ψ f) ((DirectSum.toModule R ι N fun i => ψ.comp (DirectSum.lof R ι M i)) f)","decl":"/-- Every linear map from a direct sum agrees with the one obtained by applying\nthe universal property to each of its components. -/\ntheorem toModule.unique (f : ⨁ i, M i) : ψ f = toModule R ι N (fun i ↦ ψ.comp <| lof R ι M i) f :=\n  toAddMonoid.unique ψ.toAddMonoidHom f\n\n"}
{"name":"DirectSum.linearMap_ext_iff","module":"Mathlib.Algebra.DirectSum.Module","initialProofState":"R : Type u\ninst✝⁵ : Semiring R\nι : Type v\nM : ι → Type w\ninst✝⁴ : (i : ι) → AddCommMonoid (M i)\ninst✝³ : (i : ι) → Module R (M i)\ninst✝² : DecidableEq ι\nN : Type u₁\ninst✝¹ : AddCommMonoid N\ninst✝ : Module R N\nψ ψ' : LinearMap (RingHom.id R) (DirectSum ι fun i => M i) N\n⊢ Iff (Eq ψ ψ') (∀ (i : ι), Eq (ψ.comp (DirectSum.lof R ι M i)) (ψ'.comp (DirectSum.lof R ι M i)))","decl":"/-- Two `LinearMap`s out of a direct sum are equal if they agree on the generators.\n\nSee note [partially-applied ext lemmas]. -/\n@[ext]\ntheorem linearMap_ext ⦃ψ ψ' : (⨁ i, M i) →ₗ[R] N⦄\n    (H : ∀ i, ψ.comp (lof R ι M i) = ψ'.comp (lof R ι M i)) : ψ = ψ' :=\n  DFinsupp.lhom_ext' H\n\n"}
{"name":"DirectSum.linearMap_ext","module":"Mathlib.Algebra.DirectSum.Module","initialProofState":"R : Type u\ninst✝⁵ : Semiring R\nι : Type v\nM : ι → Type w\ninst✝⁴ : (i : ι) → AddCommMonoid (M i)\ninst✝³ : (i : ι) → Module R (M i)\ninst✝² : DecidableEq ι\nN : Type u₁\ninst✝¹ : AddCommMonoid N\ninst✝ : Module R N\nψ ψ' : LinearMap (RingHom.id R) (DirectSum ι fun i => M i) N\nH : ∀ (i : ι), Eq (ψ.comp (DirectSum.lof R ι M i)) (ψ'.comp (DirectSum.lof R ι M i))\n⊢ Eq ψ ψ'","decl":"/-- Two `LinearMap`s out of a direct sum are equal if they agree on the generators.\n\nSee note [partially-applied ext lemmas]. -/\n@[ext]\ntheorem linearMap_ext ⦃ψ ψ' : (⨁ i, M i) →ₗ[R] N⦄\n    (H : ∀ i, ψ.comp (lof R ι M i) = ψ'.comp (lof R ι M i)) : ψ = ψ' :=\n  DFinsupp.lhom_ext' H\n\n"}
{"name":"DirectSum.linearEquivFunOnFintype_apply","module":"Mathlib.Algebra.DirectSum.Module","initialProofState":"R : Type u\ninst✝³ : Semiring R\nι : Type v\nM : ι → Type w\ninst✝² : (i : ι) → AddCommMonoid (M i)\ninst✝¹ : (i : ι) → Module R (M i)\ninst✝ : Fintype ι\na✝ : DFinsupp fun i => (fun i => M i) i\na : ι\n⊢ Eq ((DirectSum.linearEquivFunOnFintype R ι M) a✝ a) (a✝ a)","decl":"/-- Given `Fintype α`, `linearEquivFunOnFintype R` is the natural `R`-linear equivalence\nbetween `⨁ i, M i` and `∀ i, M i`. -/\n@[simps apply]\ndef linearEquivFunOnFintype [Fintype ι] : (⨁ i, M i) ≃ₗ[R] ∀ i, M i :=\n  { DFinsupp.equivFunOnFintype with\n    toFun := (↑)\n    map_add' := fun f g ↦ by\n      ext\n      rw [add_apply, Pi.add_apply]\n    map_smul' := fun c f ↦ by\n      simp_rw [RingHom.id_apply]\n      rw [DFinsupp.coe_smul] }\n\n"}
{"name":"DirectSum.linearEquivFunOnFintype_lof","module":"Mathlib.Algebra.DirectSum.Module","initialProofState":"R : Type u\ninst✝⁴ : Semiring R\nι : Type v\nM : ι → Type w\ninst✝³ : (i : ι) → AddCommMonoid (M i)\ninst✝² : (i : ι) → Module R (M i)\ninst✝¹ : DecidableEq ι\ninst✝ : Fintype ι\ni : ι\nm : M i\n⊢ Eq ((DirectSum.linearEquivFunOnFintype R ι M) ((DirectSum.lof R ι M i) m)) (Pi.single i m)","decl":"@[simp]\ntheorem linearEquivFunOnFintype_lof [Fintype ι] (i : ι) (m : M i) :\n    (linearEquivFunOnFintype R ι M) (lof R ι M i m) = Pi.single i m := by\n  ext a\n  change (DFinsupp.equivFunOnFintype (lof R ι M i m)) a = _\n  convert _root_.congr_fun (DFinsupp.equivFunOnFintype_single i m) a\n\n"}
{"name":"DirectSum.linearEquivFunOnFintype_symm_single","module":"Mathlib.Algebra.DirectSum.Module","initialProofState":"R : Type u\ninst✝⁴ : Semiring R\nι : Type v\nM : ι → Type w\ninst✝³ : (i : ι) → AddCommMonoid (M i)\ninst✝² : (i : ι) → Module R (M i)\ninst✝¹ : DecidableEq ι\ninst✝ : Fintype ι\ni : ι\nm : M i\n⊢ Eq ((DirectSum.linearEquivFunOnFintype R ι M).symm (Pi.single i m)) ((DirectSum.lof R ι M i) m)","decl":"@[simp]\ntheorem linearEquivFunOnFintype_symm_single [Fintype ι] (i : ι) (m : M i) :\n    (linearEquivFunOnFintype R ι M).symm (Pi.single i m) = lof R ι M i m := by\n  change (DFinsupp.equivFunOnFintype.symm (Pi.single i m)) = _\n  rw [DFinsupp.equivFunOnFintype_symm_single i m]\n  rfl\n\n"}
{"name":"DirectSum.linearEquivFunOnFintype_symm_coe","module":"Mathlib.Algebra.DirectSum.Module","initialProofState":"R : Type u\ninst✝³ : Semiring R\nι : Type v\nM : ι → Type w\ninst✝² : (i : ι) → AddCommMonoid (M i)\ninst✝¹ : (i : ι) → Module R (M i)\ninst✝ : Fintype ι\nf : DirectSum ι fun i => M i\n⊢ Eq ((DirectSum.linearEquivFunOnFintype R ι M).symm ⇑f) f","decl":"@[simp]\ntheorem linearEquivFunOnFintype_symm_coe [Fintype ι] (f : ⨁ i, M i) :\n    (linearEquivFunOnFintype R ι M).symm f = f := by\n  simp [linearEquivFunOnFintype]\n\n"}
{"name":"DirectSum.apply_eq_component","module":"Mathlib.Algebra.DirectSum.Module","initialProofState":"R : Type u\ninst✝² : Semiring R\nι : Type v\nM : ι → Type w\ninst✝¹ : (i : ι) → AddCommMonoid (M i)\ninst✝ : (i : ι) → Module R (M i)\nf : DirectSum ι fun i => M i\ni : ι\n⊢ Eq (f i) ((DirectSum.component R ι M i) f)","decl":"theorem apply_eq_component (f : ⨁ i, M i) (i : ι) : f i = component R ι M i f := rfl\n\n-- Note(kmill): `@[ext]` cannot prove `ext_iff` because `R` is not determined by `f` or `g`.\n-- This is not useful as an `@[ext]` lemma as the `ext` tactic can not infer `R`.\n"}
{"name":"DirectSum.ext_component","module":"Mathlib.Algebra.DirectSum.Module","initialProofState":"R : Type u\ninst✝² : Semiring R\nι : Type v\nM : ι → Type w\ninst✝¹ : (i : ι) → AddCommMonoid (M i)\ninst✝ : (i : ι) → Module R (M i)\nf g : DirectSum ι fun i => M i\nh : ∀ (i : ι), Eq ((DirectSum.component R ι M i) f) ((DirectSum.component R ι M i) g)\n⊢ Eq f g","decl":"theorem ext_component {f g : ⨁ i, M i} (h : ∀ i, component R ι M i f = component R ι M i g) :\n    f = g :=\n  DFinsupp.ext h\n\n"}
{"name":"DirectSum.ext_component_iff","module":"Mathlib.Algebra.DirectSum.Module","initialProofState":"R : Type u\ninst✝² : Semiring R\nι : Type v\nM : ι → Type w\ninst✝¹ : (i : ι) → AddCommMonoid (M i)\ninst✝ : (i : ι) → Module R (M i)\nf g : DirectSum ι fun i => M i\n⊢ Iff (Eq f g) (∀ (i : ι), Eq ((DirectSum.component R ι M i) f) ((DirectSum.component R ι M i) g))","decl":"theorem ext_component_iff {f g : ⨁ i, M i} :\n    f = g ↔ ∀ i, component R ι M i f = component R ι M i g :=\n  ⟨fun h _ ↦ by rw [h], ext_component R⟩\n\n"}
{"name":"DirectSum.lof_apply","module":"Mathlib.Algebra.DirectSum.Module","initialProofState":"R : Type u\ninst✝³ : Semiring R\nι : Type v\nM : ι → Type w\ninst✝² : (i : ι) → AddCommMonoid (M i)\ninst✝¹ : (i : ι) → Module R (M i)\ninst✝ : DecidableEq ι\ni : ι\nb : M i\n⊢ Eq (((DirectSum.lof R ι M i) b) i) b","decl":"@[simp]\ntheorem lof_apply [DecidableEq ι] (i : ι) (b : M i) : ((lof R ι M i) b) i = b :=\n  DFinsupp.single_eq_same\n\n"}
{"name":"DirectSum.component.lof_self","module":"Mathlib.Algebra.DirectSum.Module","initialProofState":"R : Type u\ninst✝³ : Semiring R\nι : Type v\nM : ι → Type w\ninst✝² : (i : ι) → AddCommMonoid (M i)\ninst✝¹ : (i : ι) → Module R (M i)\ninst✝ : DecidableEq ι\ni : ι\nb : M i\n⊢ Eq ((DirectSum.component R ι M i) ((DirectSum.lof R ι M i) b)) b","decl":"@[simp]\ntheorem component.lof_self [DecidableEq ι] (i : ι) (b : M i) :\n    component R ι M i ((lof R ι M i) b) = b :=\n  lof_apply R i b\n\n"}
{"name":"DirectSum.component.of","module":"Mathlib.Algebra.DirectSum.Module","initialProofState":"R : Type u\ninst✝³ : Semiring R\nι : Type v\nM : ι → Type w\ninst✝² : (i : ι) → AddCommMonoid (M i)\ninst✝¹ : (i : ι) → Module R (M i)\ninst✝ : DecidableEq ι\ni j : ι\nb : M j\n⊢ Eq ((DirectSum.component R ι M i) ((DirectSum.lof R ι M j) b)) (dite (Eq j i) (fun h => Eq.recOn h b) fun h => 0)","decl":"theorem component.of [DecidableEq ι] (i j : ι) (b : M j) :\n    component R ι M i ((lof R ι M j) b) = if h : j = i then Eq.recOn h b else 0 :=\n  DFinsupp.single_apply\n\n"}
{"name":"DirectSum.lmap_apply","module":"Mathlib.Algebra.DirectSum.Module","initialProofState":"R : Type u\ninst✝⁴ : Semiring R\nι : Type v\nM : ι → Type w\ninst✝³ : (i : ι) → AddCommMonoid (M i)\ninst✝² : (i : ι) → Module R (M i)\nN : ι → Type u_1\ninst✝¹ : (i : ι) → AddCommMonoid (N i)\ninst✝ : (i : ι) → Module R (N i)\nf : (i : ι) → LinearMap (RingHom.id R) (M i) (N i)\nx : DirectSum ι fun i => M i\ni : ι\n⊢ Eq (((DirectSum.lmap f) x) i) ((f i) (x i))","decl":"@[simp] theorem lmap_apply (x i) : lmap f x i = f i (x i) := rfl\n\n"}
{"name":"DirectSum.lmap_lof","module":"Mathlib.Algebra.DirectSum.Module","initialProofState":"R : Type u\ninst✝⁵ : Semiring R\nι : Type v\nM : ι → Type w\ninst✝⁴ : (i : ι) → AddCommMonoid (M i)\ninst✝³ : (i : ι) → Module R (M i)\nN : ι → Type u_1\ninst✝² : (i : ι) → AddCommMonoid (N i)\ninst✝¹ : (i : ι) → Module R (N i)\nf : (i : ι) → LinearMap (RingHom.id R) (M i) (N i)\ninst✝ : DecidableEq ι\ni : ι\nx : M i\n⊢ Eq ((DirectSum.lmap f) ((DirectSum.lof R ι M i) x)) ((DirectSum.lof R ι N i) ((f i) x))","decl":"@[simp] theorem lmap_lof [DecidableEq ι] (i) (x : M i) :\n    lmap f (lof R _ _ _ x) = lof R _ _ _ (f i x) :=\n  DFinsupp.mapRange_single (hf := fun _ ↦ map_zero _)\n\n"}
{"name":"DirectSum.lmap_injective","module":"Mathlib.Algebra.DirectSum.Module","initialProofState":"R : Type u\ninst✝⁴ : Semiring R\nι : Type v\nM : ι → Type w\ninst✝³ : (i : ι) → AddCommMonoid (M i)\ninst✝² : (i : ι) → Module R (M i)\nN : ι → Type u_1\ninst✝¹ : (i : ι) → AddCommMonoid (N i)\ninst✝ : (i : ι) → Module R (N i)\nf : (i : ι) → LinearMap (RingHom.id R) (M i) (N i)\n⊢ Iff (Function.Injective ⇑(DirectSum.lmap f)) (∀ (i : ι), Function.Injective ⇑(f i))","decl":"theorem lmap_injective : Function.Injective (lmap f) ↔ ∀ i, Function.Injective (f i) := by\n  classical exact DFinsupp.mapRange_injective (hf := fun _ ↦ map_zero _)\n\n"}
{"name":"DirectSum.lequivCongrLeft_apply","module":"Mathlib.Algebra.DirectSum.Module","initialProofState":"R : Type u\ninst✝² : Semiring R\nι : Type v\nM : ι → Type w\ninst✝¹ : (i : ι) → AddCommMonoid (M i)\ninst✝ : (i : ι) → Module R (M i)\nκ : Type u_1\nh : Equiv ι κ\nf : DirectSum ι fun i => M i\nk : κ\n⊢ Eq (((DirectSum.lequivCongrLeft R h) f) k) (f (h.symm k))","decl":"@[simp]\ntheorem lequivCongrLeft_apply (h : ι ≃ κ) (f : ⨁ i, M i) (k : κ) :\n    lequivCongrLeft R h f k = f (h.symm k) :=\n  equivCongrLeft_apply _ _ _\n\n"}
{"name":"DirectSum.sigmaLcurry_apply","module":"Mathlib.Algebra.DirectSum.Module","initialProofState":"R : Type u\ninst✝³ : Semiring R\nι : Type v\nα : ι → Type u_1\nδ : (i : ι) → α i → Type w\ninst✝² : DecidableEq ι\ninst✝¹ : (i : ι) → (j : α i) → AddCommMonoid (δ i j)\ninst✝ : (i : ι) → (j : α i) → Module R (δ i j)\nf : DirectSum (Sigma fun x => α x) fun i => δ i.fst i.snd\ni : ι\nj : α i\n⊢ Eq ((((DirectSum.sigmaLcurry R) f) i) j) (f ⟨i, j⟩)","decl":"@[simp]\ntheorem sigmaLcurry_apply (f : ⨁ i : Σ_, _, δ i.1 i.2) (i : ι) (j : α i) :\n    sigmaLcurry R f i j = f ⟨i, j⟩ :=\n  sigmaCurry_apply f i j\n\n"}
{"name":"DirectSum.sigmaLuncurry_apply","module":"Mathlib.Algebra.DirectSum.Module","initialProofState":"R : Type u\ninst✝³ : Semiring R\nι : Type v\nα : ι → Type u_1\nδ : (i : ι) → α i → Type w\ninst✝² : DecidableEq ι\ninst✝¹ : (i : ι) → (j : α i) → AddCommMonoid (δ i j)\ninst✝ : (i : ι) → (j : α i) → Module R (δ i j)\nf : DirectSum ι fun i => DirectSum (α i) fun j => δ i j\ni : ι\nj : α i\n⊢ Eq (((DirectSum.sigmaLuncurry R) f) ⟨i, j⟩) ((f i) j)","decl":"@[simp]\ntheorem sigmaLuncurry_apply (f : ⨁ (i) (j), δ i j) (i : ι) (j : α i) :\n    sigmaLuncurry R f ⟨i, j⟩ = f i j :=\n  sigmaUncurry_apply f i j\n\n"}
{"name":"DirectSum.lequivProdDirectSum_symm_apply","module":"Mathlib.Algebra.DirectSum.Module","initialProofState":"R : Type u\ninst✝² : Semiring R\nι : Type v\nα : Option ι → Type w\ninst✝¹ : (i : Option ι) → AddCommMonoid (α i)\ninst✝ : (i : Option ι) → Module R (α i)\na✝ : Prod (α Option.none) (DirectSum ι fun i => α (Option.some i))\n⊢ Eq ((DirectSum.lequivProdDirectSum R).symm a✝) (DirectSum.addEquivProdDirectSum.invFun a✝)","decl":"/-- Linear isomorphism obtained by separating the term of index `none` of a direct sum over\n`Option ι`. -/\n@[simps]\nnoncomputable def lequivProdDirectSum : (⨁ i, α i) ≃ₗ[R] α none × ⨁ i, α (some i) :=\n  { addEquivProdDirectSum with map_smul' := DFinsupp.equivProdDFinsupp_smul }\n\n"}
{"name":"DirectSum.lequivProdDirectSum_apply","module":"Mathlib.Algebra.DirectSum.Module","initialProofState":"R : Type u\ninst✝² : Semiring R\nι : Type v\nα : Option ι → Type w\ninst✝¹ : (i : Option ι) → AddCommMonoid (α i)\ninst✝ : (i : Option ι) → Module R (α i)\na✝ : DirectSum (Option ι) fun i => α i\n⊢ Eq ((DirectSum.lequivProdDirectSum R) a✝) (DirectSum.addEquivProdDirectSum.toFun a✝)","decl":"/-- Linear isomorphism obtained by separating the term of index `none` of a direct sum over\n`Option ι`. -/\n@[simps]\nnoncomputable def lequivProdDirectSum : (⨁ i, α i) ≃ₗ[R] α none × ⨁ i, α (some i) :=\n  { addEquivProdDirectSum with map_smul' := DFinsupp.equivProdDFinsupp_smul }\n\n"}
{"name":"DirectSum.coeLinearMap_eq_dfinsupp_sum","module":"Mathlib.Algebra.DirectSum.Module","initialProofState":"R : Type u\ninst✝³ : Semiring R\nι : Type v\ndec_ι : DecidableEq ι\nM : Type u_1\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\nA : ι → Submodule R M\ninst✝ : DecidableEq M\nx : DirectSum ι fun i => Subtype fun x => Membership.mem (A i) x\n⊢ Eq ((DirectSum.coeLinearMap A) x) (DFinsupp.sum x fun i x => ↑x)","decl":"theorem coeLinearMap_eq_dfinsupp_sum [DecidableEq M] (x : DirectSum ι fun i => A i) :\n    coeLinearMap A x = DFinsupp.sum x fun i => (fun x : A i => ↑x) := by\n  simp only [coeLinearMap, toModule, DFinsupp.lsum, LinearEquiv.coe_mk, LinearMap.coe_mk,\n    AddHom.coe_mk]\n  rw [DFinsupp.sumAddHom_apply]\n  simp only [LinearMap.toAddMonoidHom_coe, Submodule.coe_subtype]\n\n"}
{"name":"DirectSum.coeLinearMap_of","module":"Mathlib.Algebra.DirectSum.Module","initialProofState":"R : Type u\ninst✝² : Semiring R\nι : Type v\ndec_ι : DecidableEq ι\nM : Type u_1\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nA : ι → Submodule R M\ni : ι\nx : Subtype fun x => Membership.mem (A i) x\n⊢ Eq ((DirectSum.coeLinearMap A) ((DirectSum.of (fun i => Subtype fun x => Membership.mem (A i) x) i) x)) ↑x","decl":"@[simp]\ntheorem coeLinearMap_of (i : ι) (x : A i) : DirectSum.coeLinearMap A (of (fun i ↦ A i) i x) = x :=\n  -- Porting note: spelled out arguments. (I don't know how this works.)\n  toAddMonoid_of (β := fun i => A i) (fun i ↦ ((A i).subtype : A i →+ M)) i x\n\n"}
{"name":"DirectSum.range_coeLinearMap","module":"Mathlib.Algebra.DirectSum.Module","initialProofState":"R : Type u\ninst✝² : Semiring R\nι : Type v\ndec_ι : DecidableEq ι\nM : Type u_1\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nA : ι → Submodule R M\n⊢ Eq (LinearMap.range (DirectSum.coeLinearMap A)) (iSup fun i => A i)","decl":"theorem range_coeLinearMap : LinearMap.range (coeLinearMap A) = ⨆ i, A i :=\n  (Submodule.iSup_eq_range_dfinsupp_lsum _).symm\n\n"}
{"name":"DirectSum.IsInternal.ofBijective_coeLinearMap_same","module":"Mathlib.Algebra.DirectSum.Module","initialProofState":"R : Type u\ninst✝² : Semiring R\nι : Type v\ndec_ι : DecidableEq ι\nM : Type u_1\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nA : ι → Submodule R M\nh : DirectSum.IsInternal A\ni : ι\nx : Subtype fun x => Membership.mem (A i) x\n⊢ Eq (((LinearEquiv.ofBijective (DirectSum.coeLinearMap A) h).symm ↑x) i) x","decl":"@[simp]\ntheorem IsInternal.ofBijective_coeLinearMap_same (h : IsInternal A)\n    {i : ι} (x : A i) :\n    (LinearEquiv.ofBijective (coeLinearMap A) h).symm x i = x := by\n  rw [← coeLinearMap_of, LinearEquiv.ofBijective_symm_apply_apply, of_eq_same]\n\n"}
{"name":"DirectSum.IsInternal.ofBijective_coeLinearMap_of_ne","module":"Mathlib.Algebra.DirectSum.Module","initialProofState":"R : Type u\ninst✝² : Semiring R\nι : Type v\ndec_ι : DecidableEq ι\nM : Type u_1\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nA : ι → Submodule R M\nh : DirectSum.IsInternal A\ni j : ι\nhij : Ne i j\nx : Subtype fun x => Membership.mem (A i) x\n⊢ Eq (((LinearEquiv.ofBijective (DirectSum.coeLinearMap A) h).symm ↑x) j) 0","decl":"@[simp]\ntheorem IsInternal.ofBijective_coeLinearMap_of_ne (h : IsInternal A)\n    {i j : ι} (hij : i ≠ j) (x : A i) :\n    (LinearEquiv.ofBijective (coeLinearMap A) h).symm x j = 0 := by\n  rw [← coeLinearMap_of, LinearEquiv.ofBijective_symm_apply_apply, of_eq_of_ne i j _ hij]\n\n"}
{"name":"DirectSum.IsInternal.ofBijective_coeLinearMap_of_mem","module":"Mathlib.Algebra.DirectSum.Module","initialProofState":"R : Type u\ninst✝² : Semiring R\nι : Type v\ndec_ι : DecidableEq ι\nM : Type u_1\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nA : ι → Submodule R M\nh : DirectSum.IsInternal A\ni : ι\nx : M\nhx : Membership.mem (A i) x\n⊢ Eq (((LinearEquiv.ofBijective (DirectSum.coeLinearMap A) h).symm x) i) ⟨x, hx⟩","decl":"theorem IsInternal.ofBijective_coeLinearMap_of_mem (h : IsInternal A)\n    {i : ι} {x : M} (hx : x ∈ A i) :\n    (LinearEquiv.ofBijective (coeLinearMap A) h).symm x i = ⟨x, hx⟩ :=\n  h.ofBijective_coeLinearMap_same ⟨x, hx⟩\n\n"}
{"name":"DirectSum.IsInternal.ofBijective_coeLinearMap_of_mem_ne","module":"Mathlib.Algebra.DirectSum.Module","initialProofState":"R : Type u\ninst✝² : Semiring R\nι : Type v\ndec_ι : DecidableEq ι\nM : Type u_1\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nA : ι → Submodule R M\nh : DirectSum.IsInternal A\ni j : ι\nhij : Ne i j\nx : M\nhx : Membership.mem (A i) x\n⊢ Eq (((LinearEquiv.ofBijective (DirectSum.coeLinearMap A) h).symm x) j) 0","decl":"theorem IsInternal.ofBijective_coeLinearMap_of_mem_ne (h : IsInternal A)\n    {i j : ι} (hij : i ≠ j) {x : M} (hx : x ∈ A i) :\n    (LinearEquiv.ofBijective (coeLinearMap A) h).symm x j = 0 :=\n  h.ofBijective_coeLinearMap_of_ne hij ⟨x, hx⟩\n\n"}
{"name":"DirectSum.IsInternal.submodule_iSup_eq_top","module":"Mathlib.Algebra.DirectSum.Module","initialProofState":"R : Type u\ninst✝² : Semiring R\nι : Type v\ndec_ι : DecidableEq ι\nM : Type u_1\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nA : ι → Submodule R M\nh : DirectSum.IsInternal A\n⊢ Eq (iSup A) Top.top","decl":"/-- If a direct sum of submodules is internal then the submodules span the module. -/\ntheorem IsInternal.submodule_iSup_eq_top (h : IsInternal A) : iSup A = ⊤ := by\n  rw [Submodule.iSup_eq_range_dfinsupp_lsum, LinearMap.range_eq_top]\n  exact Function.Bijective.surjective h\n\n"}
{"name":"DirectSum.IsInternal.submodule_iSupIndep","module":"Mathlib.Algebra.DirectSum.Module","initialProofState":"R : Type u\ninst✝² : Semiring R\nι : Type v\ndec_ι : DecidableEq ι\nM : Type u_1\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nA : ι → Submodule R M\nh : DirectSum.IsInternal A\n⊢ iSupIndep A","decl":"/-- If a direct sum of submodules is internal then the submodules are independent. -/\ntheorem IsInternal.submodule_iSupIndep (h : IsInternal A) : iSupIndep A :=\n  iSupIndep_of_dfinsupp_lsum_injective _ h.injective\n\n"}
{"name":"DirectSum.IsInternal.submodule_independent","module":"Mathlib.Algebra.DirectSum.Module","initialProofState":"R : Type u\ninst✝² : Semiring R\nι : Type v\ndec_ι : DecidableEq ι\nM : Type u_1\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nA : ι → Submodule R M\nh : DirectSum.IsInternal A\n⊢ iSupIndep A","decl":"@[deprecated (since := \"2024-11-24\")]\nalias IsInternal.submodule_independent := IsInternal.submodule_iSupIndep\n\n"}
{"name":"DirectSum.IsInternal.collectedBasis_coe","module":"Mathlib.Algebra.DirectSum.Module","initialProofState":"R : Type u\ninst✝² : Semiring R\nι : Type v\ndec_ι : DecidableEq ι\nM : Type u_1\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nA : ι → Submodule R M\nh : DirectSum.IsInternal A\nα : ι → Type u_2\nv : (i : ι) → Basis (α i) R (Subtype fun x => Membership.mem (A i) x)\n⊢ Eq ⇑(h.collectedBasis v) fun a => ↑((v a.fst) a.snd)","decl":"@[simp]\ntheorem IsInternal.collectedBasis_coe (h : IsInternal A) {α : ι → Type*}\n    (v : ∀ i, Basis (α i) R (A i)) : ⇑(h.collectedBasis v) = fun a : Σi, α i ↦ ↑(v a.1 a.2) := by\n  funext a\n  -- Porting note: was\n  -- simp only [IsInternal.collectedBasis, toModule, coeLinearMap, Basis.coe_ofRepr,\n  --   Basis.repr_symm_apply, DFinsupp.lsum_apply_apply, DFinsupp.mapRange.linearEquiv_apply,\n  --   DFinsupp.mapRange.linearEquiv_symm, DFinsupp.mapRange_single, linearCombination_single,\n  --   LinearEquiv.ofBijective_apply, LinearEquiv.symm_symm, LinearEquiv.symm_trans_apply, one_smul,\n  --   sigmaFinsuppAddEquivDFinsupp_apply, sigmaFinsuppEquivDFinsupp_single,\n  --   sigmaFinsuppLequivDFinsupp_apply]\n  -- convert DFinsupp.sumAddHom_single (fun i ↦ (A i).subtype.toAddMonoidHom) a.1 (v a.1 a.2)\n  simp only [IsInternal.collectedBasis, coeLinearMap, Basis.coe_ofRepr, LinearEquiv.trans_symm,\n    LinearEquiv.symm_symm, LinearEquiv.trans_apply, sigmaFinsuppLequivDFinsupp_apply,\n    sigmaFinsuppEquivDFinsupp_single, LinearEquiv.ofBijective_apply,\n    sigmaFinsuppAddEquivDFinsupp_apply]\n  rw [DFinsupp.mapRange.linearEquiv_symm]\n  erw [DFinsupp.mapRange.linearEquiv_apply]\n  simp only [DFinsupp.mapRange_single, Basis.repr_symm_apply, linearCombination_single, one_smul,\n    toModule]\n  erw [DFinsupp.lsum_single]\n  simp only [Submodule.coe_subtype]\n\n"}
{"name":"DirectSum.IsInternal.collectedBasis_mem","module":"Mathlib.Algebra.DirectSum.Module","initialProofState":"R : Type u\ninst✝² : Semiring R\nι : Type v\ndec_ι : DecidableEq ι\nM : Type u_1\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nA : ι → Submodule R M\nh : DirectSum.IsInternal A\nα : ι → Type u_2\nv : (i : ι) → Basis (α i) R (Subtype fun x => Membership.mem (A i) x)\na : Sigma fun i => α i\n⊢ Membership.mem (A a.fst) ((h.collectedBasis v) a)","decl":"theorem IsInternal.collectedBasis_mem (h : IsInternal A) {α : ι → Type*}\n    (v : ∀ i, Basis (α i) R (A i)) (a : Σi, α i) : h.collectedBasis v a ∈ A a.1 := by simp\n\n"}
{"name":"DirectSum.IsInternal.collectedBasis_repr_of_mem","module":"Mathlib.Algebra.DirectSum.Module","initialProofState":"R : Type u\ninst✝² : Semiring R\nι : Type v\ndec_ι : DecidableEq ι\nM : Type u_1\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nA : ι → Submodule R M\nh : DirectSum.IsInternal A\nα : ι → Type u_2\nv : (i : ι) → Basis (α i) R (Subtype fun x => Membership.mem (A i) x)\nx : M\ni : ι\na : α i\nhx : Membership.mem (A i) x\n⊢ Eq (((h.collectedBasis v).repr x) ⟨i, a⟩) (((v i).repr ⟨x, hx⟩) a)","decl":"theorem IsInternal.collectedBasis_repr_of_mem (h : IsInternal A) {α : ι → Type*}\n    (v : ∀ i, Basis (α i) R (A i)) {x : M} {i : ι} {a : α i} (hx : x ∈ A i) :\n    (h.collectedBasis v).repr x ⟨i, a⟩ = (v i).repr ⟨x, hx⟩ a := by\n  change (sigmaFinsuppLequivDFinsupp R).symm (DFinsupp.mapRange _ (fun i ↦ map_zero _) _) _ = _\n  simp [h.ofBijective_coeLinearMap_of_mem hx]\n\n"}
{"name":"DirectSum.IsInternal.collectedBasis_repr_of_mem_ne","module":"Mathlib.Algebra.DirectSum.Module","initialProofState":"R : Type u\ninst✝² : Semiring R\nι : Type v\ndec_ι : DecidableEq ι\nM : Type u_1\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nA : ι → Submodule R M\nh : DirectSum.IsInternal A\nα : ι → Type u_2\nv : (i : ι) → Basis (α i) R (Subtype fun x => Membership.mem (A i) x)\nx : M\ni j : ι\nhij : Ne i j\na : α j\nhx : Membership.mem (A i) x\n⊢ Eq (((h.collectedBasis v).repr x) ⟨j, a⟩) 0","decl":"theorem IsInternal.collectedBasis_repr_of_mem_ne (h : IsInternal A) {α : ι → Type*}\n    (v : ∀ i, Basis (α i) R (A i)) {x : M} {i j : ι} (hij : i ≠ j) {a : α j} (hx : x ∈ A i) :\n    (h.collectedBasis v).repr x ⟨j, a⟩ = 0 := by\n  change (sigmaFinsuppLequivDFinsupp R).symm (DFinsupp.mapRange _ (fun i ↦ map_zero _) _) _ = _\n  simp [h.ofBijective_coeLinearMap_of_mem_ne hij hx]\n\n"}
{"name":"DirectSum.IsInternal.isCompl","module":"Mathlib.Algebra.DirectSum.Module","initialProofState":"R : Type u\ninst✝² : Semiring R\nι : Type v\ndec_ι : DecidableEq ι\nM : Type u_1\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nA : ι → Submodule R M\ni j : ι\nhij : Ne i j\nh : Eq Set.univ (Insert.insert i (Singleton.singleton j))\nhi : DirectSum.IsInternal A\n⊢ IsCompl (A i) (A j)","decl":"/-- When indexed by only two distinct elements, `DirectSum.IsInternal` implies\nthe two submodules are complementary. Over a `Ring R`, this is true as an iff, as\n`DirectSum.isInternal_submodule_iff_isCompl`. -/\ntheorem IsInternal.isCompl {A : ι → Submodule R M} {i j : ι} (hij : i ≠ j)\n    (h : (Set.univ : Set ι) = {i, j}) (hi : IsInternal A) : IsCompl (A i) (A j) :=\n  ⟨hi.submodule_iSupIndep.pairwiseDisjoint hij,\n    codisjoint_iff.mpr <| Eq.symm <| hi.submodule_iSup_eq_top.symm.trans <| by\n      rw [← sSup_pair, iSup, ← Set.image_univ, h, Set.image_insert_eq, Set.image_singleton]⟩\n\n"}
{"name":"DirectSum.isInternal_submodule_of_iSupIndep_of_iSup_eq_top","module":"Mathlib.Algebra.DirectSum.Module","initialProofState":"R : Type u\ninst✝² : Ring R\nι : Type v\ndec_ι : DecidableEq ι\nM : Type u_1\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nA : ι → Submodule R M\nhi : iSupIndep A\nhs : Eq (iSup A) Top.top\n⊢ DirectSum.IsInternal A","decl":"/-- Note that this is not generally true for `[Semiring R]`; see\n`iSupIndep.dfinsupp_lsum_injective` for details. -/\ntheorem isInternal_submodule_of_iSupIndep_of_iSup_eq_top {A : ι → Submodule R M}\n    (hi : iSupIndep A) (hs : iSup A = ⊤) : IsInternal A :=\n  ⟨hi.dfinsupp_lsum_injective,\n    -- Note: https://github.com/leanprover-community/mathlib4/pull/8386 had to specify value of `f`\n    (LinearMap.range_eq_top (f := DFinsupp.lsum _ _)).1 <|\n      (Submodule.iSup_eq_range_dfinsupp_lsum _).symm.trans hs⟩\n\n"}
{"name":"DirectSum.isInternal_submodule_of_independent_of_iSup_eq_top","module":"Mathlib.Algebra.DirectSum.Module","initialProofState":"R : Type u\ninst✝² : Ring R\nι : Type v\ndec_ι : DecidableEq ι\nM : Type u_1\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nA : ι → Submodule R M\nhi : iSupIndep A\nhs : Eq (iSup A) Top.top\n⊢ DirectSum.IsInternal A","decl":"@[deprecated (since := \"2024-11-24\")]\nalias isInternal_submodule_of_independent_of_iSup_eq_top :=\n  isInternal_submodule_of_iSupIndep_of_iSup_eq_top\n\n"}
{"name":"DirectSum.isInternal_submodule_iff_iSupIndep_and_iSup_eq_top","module":"Mathlib.Algebra.DirectSum.Module","initialProofState":"R : Type u\ninst✝² : Ring R\nι : Type v\ndec_ι : DecidableEq ι\nM : Type u_1\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nA : ι → Submodule R M\n⊢ Iff (DirectSum.IsInternal A) (And (iSupIndep A) (Eq (iSup A) Top.top))","decl":"/-- `iff` version of `DirectSum.isInternal_submodule_of_iSupIndep_of_iSup_eq_top`,\n`DirectSum.IsInternal.iSupIndep`, and `DirectSum.IsInternal.submodule_iSup_eq_top`. -/\ntheorem isInternal_submodule_iff_iSupIndep_and_iSup_eq_top (A : ι → Submodule R M) :\n    IsInternal A ↔ iSupIndep A ∧ iSup A = ⊤ :=\n  ⟨fun i ↦ ⟨i.submodule_iSupIndep, i.submodule_iSup_eq_top⟩,\n    And.rec isInternal_submodule_of_iSupIndep_of_iSup_eq_top⟩\n\n"}
{"name":"DirectSum.isInternal_submodule_iff_independent_and_iSup_eq_top","module":"Mathlib.Algebra.DirectSum.Module","initialProofState":"R : Type u\ninst✝² : Ring R\nι : Type v\ndec_ι : DecidableEq ι\nM : Type u_1\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nA : ι → Submodule R M\n⊢ Iff (DirectSum.IsInternal A) (And (iSupIndep A) (Eq (iSup A) Top.top))","decl":"@[deprecated (since := \"2024-11-24\")]\nalias isInternal_submodule_iff_independent_and_iSup_eq_top :=\n  isInternal_submodule_iff_iSupIndep_and_iSup_eq_top\n\n"}
{"name":"DirectSum.isInternal_submodule_iff_isCompl","module":"Mathlib.Algebra.DirectSum.Module","initialProofState":"R : Type u\ninst✝² : Ring R\nι : Type v\ndec_ι : DecidableEq ι\nM : Type u_1\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nA : ι → Submodule R M\ni j : ι\nhij : Ne i j\nh : Eq Set.univ (Insert.insert i (Singleton.singleton j))\n⊢ Iff (DirectSum.IsInternal A) (IsCompl (A i) (A j))","decl":"/-- If a collection of submodules has just two indices, `i` and `j`, then\n`DirectSum.IsInternal` is equivalent to `isCompl`. -/\ntheorem isInternal_submodule_iff_isCompl (A : ι → Submodule R M) {i j : ι} (hij : i ≠ j)\n    (h : (Set.univ : Set ι) = {i, j}) : IsInternal A ↔ IsCompl (A i) (A j) := by\n  have : ∀ k, k = i ∨ k = j := fun k ↦ by simpa using Set.ext_iff.mp h k\n  rw [isInternal_submodule_iff_iSupIndep_and_iSup_eq_top, iSup, ← Set.image_univ, h,\n    Set.image_insert_eq, Set.image_singleton, sSup_pair, iSupIndep_pair hij this]\n  exact ⟨fun ⟨hd, ht⟩ ↦ ⟨hd, codisjoint_iff.mpr ht⟩, fun ⟨hd, ht⟩ ↦ ⟨hd, ht.eq_top⟩⟩\n\n"}
{"name":"DirectSum.isInternal_ne_bot_iff","module":"Mathlib.Algebra.DirectSum.Module","initialProofState":"R : Type u\ninst✝² : Ring R\nι : Type v\ndec_ι : DecidableEq ι\nM : Type u_1\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nA : ι → Submodule R M\n⊢ Iff (DirectSum.IsInternal fun i => A ↑i) (DirectSum.IsInternal A)","decl":"@[simp]\ntheorem isInternal_ne_bot_iff {A : ι → Submodule R M} :\n    IsInternal (fun i : {i // A i ≠ ⊥} ↦ A i) ↔ IsInternal A := by\n  simp [isInternal_submodule_iff_iSupIndep_and_iSup_eq_top]\n\n"}
{"name":"DirectSum.isInternal_biSup_submodule_of_iSupIndep","module":"Mathlib.Algebra.DirectSum.Module","initialProofState":"R : Type u\ninst✝² : Ring R\nι : Type v\ndec_ι : DecidableEq ι\nM : Type u_1\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nA : ι → Submodule R M\ns : Set ι\nh : iSupIndep fun i => A ↑i\n⊢ DirectSum.IsInternal fun i => Submodule.comap (iSup fun i => iSup fun h => A i).subtype (A ↑i)","decl":"lemma isInternal_biSup_submodule_of_iSupIndep {A : ι → Submodule R M} (s : Set ι)\n    (h : iSupIndep <| fun i : s ↦ A i) :\n    IsInternal <| fun (i : s) ↦ (A i).comap (⨆ i ∈ s, A i).subtype := by\n  refine (isInternal_submodule_iff_iSupIndep_and_iSup_eq_top _).mpr ⟨?_, by simp [iSup_subtype]⟩\n  let p := ⨆ i ∈ s, A i\n  have hp : ∀ i ∈ s, A i ≤ p := fun i hi ↦ le_biSup A hi\n  let e : Submodule R p ≃o Set.Iic p := p.mapIic\n  suffices (e ∘ fun i : s ↦ (A i).comap p.subtype) = fun i ↦ ⟨A i, hp i i.property⟩ by\n    rw [← iSupIndep_map_orderIso_iff e, this]\n    exact .of_coe_Iic_comp h\n  ext i m\n  change m ∈ ((A i).comap p.subtype).map p.subtype ↔ _\n  rw [Submodule.map_comap_subtype, inf_of_le_right (hp i i.property)]\n\n"}
{"name":"DirectSum.isInternal_biSup_submodule_of_independent","module":"Mathlib.Algebra.DirectSum.Module","initialProofState":"R : Type u\ninst✝² : Ring R\nι : Type v\ndec_ι : DecidableEq ι\nM : Type u_1\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nA : ι → Submodule R M\ns : Set ι\nh : iSupIndep fun i => A ↑i\n⊢ DirectSum.IsInternal fun i => Submodule.comap (iSup fun i => iSup fun h => A i).subtype (A ↑i)","decl":"@[deprecated (since := \"2024-11-24\")]\nalias isInternal_biSup_submodule_of_independent := isInternal_biSup_submodule_of_iSupIndep\n\n"}
{"name":"DirectSum.IsInternal.addSubmonoid_iSupIndep","module":"Mathlib.Algebra.DirectSum.Module","initialProofState":"ι : Type v\ndec_ι : DecidableEq ι\nM : Type u_2\ninst✝ : AddCommMonoid M\nA : ι → AddSubmonoid M\nh : DirectSum.IsInternal A\n⊢ iSupIndep A","decl":"theorem IsInternal.addSubmonoid_iSupIndep {M : Type*} [AddCommMonoid M] {A : ι → AddSubmonoid M}\n    (h : IsInternal A) : iSupIndep A :=\n  iSupIndep_of_dfinsupp_sumAddHom_injective _ h.injective\n\n"}
{"name":"DirectSum.IsInternal.addSubmonoid_independent","module":"Mathlib.Algebra.DirectSum.Module","initialProofState":"ι : Type v\ndec_ι : DecidableEq ι\nM : Type u_2\ninst✝ : AddCommMonoid M\nA : ι → AddSubmonoid M\nh : DirectSum.IsInternal A\n⊢ iSupIndep A","decl":"@[deprecated (since := \"2024-11-24\")]\nalias IsInternal.addSubmonoid_independent := IsInternal.addSubmonoid_iSupIndep\n\n"}
{"name":"DirectSum.IsInternal.addSubgroup_iSupIndep","module":"Mathlib.Algebra.DirectSum.Module","initialProofState":"ι : Type v\ndec_ι : DecidableEq ι\nG : Type u_2\ninst✝ : AddCommGroup G\nA : ι → AddSubgroup G\nh : DirectSum.IsInternal A\n⊢ iSupIndep A","decl":"theorem IsInternal.addSubgroup_iSupIndep {G : Type*} [AddCommGroup G] {A : ι → AddSubgroup G}\n    (h : IsInternal A) : iSupIndep A :=\n  iSupIndep_of_dfinsupp_sumAddHom_injective' _ h.injective\n\n"}
{"name":"DirectSum.IsInternal.addSubgroup_independent","module":"Mathlib.Algebra.DirectSum.Module","initialProofState":"ι : Type v\ndec_ι : DecidableEq ι\nG : Type u_2\ninst✝ : AddCommGroup G\nA : ι → AddSubgroup G\nh : DirectSum.IsInternal A\n⊢ iSupIndep A","decl":"@[deprecated (since := \"2024-11-24\")]\nalias IsInternal.addSubgroup_independent := IsInternal.addSubgroup_iSupIndep\n\n"}
