{"name":"EMetric.diam_eq_sSup","module":"Mathlib.Topology.EMetricSpace.Diam","initialProofState":"α : Type u_1\ninst✝ : PseudoEMetricSpace α\ns : Set α\n⊢ Eq (EMetric.diam s) (SupSet.sSup (Set.image2 EDist.edist s s))","decl":"theorem diam_eq_sSup (s : Set α) : diam s = sSup (image2 edist s s) := sSup_image2.symm\n\n"}
{"name":"EMetric.diam_le_iff","module":"Mathlib.Topology.EMetricSpace.Diam","initialProofState":"α : Type u_1\ns : Set α\ninst✝ : PseudoEMetricSpace α\nd : ENNReal\n⊢ Iff (LE.le (EMetric.diam s) d) (∀ (x : α), Membership.mem s x → ∀ (y : α), Membership.mem s y → LE.le (EDist.edist x y) d)","decl":"theorem diam_le_iff {d : ℝ≥0∞} : diam s ≤ d ↔ ∀ x ∈ s, ∀ y ∈ s, edist x y ≤ d := by\n  simp only [diam, iSup_le_iff]\n\n"}
{"name":"EMetric.diam_image_le_iff","module":"Mathlib.Topology.EMetricSpace.Diam","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : PseudoEMetricSpace α\nd : ENNReal\nf : β → α\ns : Set β\n⊢ Iff (LE.le (EMetric.diam (Set.image f s)) d) (∀ (x : β), Membership.mem s x → ∀ (y : β), Membership.mem s y → LE.le (EDist.edist (f x) (f y)) d)","decl":"theorem diam_image_le_iff {d : ℝ≥0∞} {f : β → α} {s : Set β} :\n    diam (f '' s) ≤ d ↔ ∀ x ∈ s, ∀ y ∈ s, edist (f x) (f y) ≤ d := by\n  simp only [diam_le_iff, forall_mem_image]\n\n"}
{"name":"EMetric.edist_le_of_diam_le","module":"Mathlib.Topology.EMetricSpace.Diam","initialProofState":"α : Type u_1\ns : Set α\nx y : α\ninst✝ : PseudoEMetricSpace α\nd : ENNReal\nhx : Membership.mem s x\nhy : Membership.mem s y\nhd : LE.le (EMetric.diam s) d\n⊢ LE.le (EDist.edist x y) d","decl":"theorem edist_le_of_diam_le {d} (hx : x ∈ s) (hy : y ∈ s) (hd : diam s ≤ d) : edist x y ≤ d :=\n  diam_le_iff.1 hd x hx y hy\n\n"}
{"name":"EMetric.edist_le_diam_of_mem","module":"Mathlib.Topology.EMetricSpace.Diam","initialProofState":"α : Type u_1\ns : Set α\nx y : α\ninst✝ : PseudoEMetricSpace α\nhx : Membership.mem s x\nhy : Membership.mem s y\n⊢ LE.le (EDist.edist x y) (EMetric.diam s)","decl":"/-- If two points belong to some set, their edistance is bounded by the diameter of the set -/\ntheorem edist_le_diam_of_mem (hx : x ∈ s) (hy : y ∈ s) : edist x y ≤ diam s :=\n  edist_le_of_diam_le hx hy le_rfl\n\n"}
{"name":"EMetric.diam_le","module":"Mathlib.Topology.EMetricSpace.Diam","initialProofState":"α : Type u_1\ns : Set α\ninst✝ : PseudoEMetricSpace α\nd : ENNReal\nh : ∀ (x : α), Membership.mem s x → ∀ (y : α), Membership.mem s y → LE.le (EDist.edist x y) d\n⊢ LE.le (EMetric.diam s) d","decl":"/-- If the distance between any two points in a set is bounded by some constant, this constant\nbounds the diameter. -/\ntheorem diam_le {d : ℝ≥0∞} (h : ∀ x ∈ s, ∀ y ∈ s, edist x y ≤ d) : diam s ≤ d :=\n  diam_le_iff.2 h\n\n"}
{"name":"EMetric.diam_subsingleton","module":"Mathlib.Topology.EMetricSpace.Diam","initialProofState":"α : Type u_1\ns : Set α\ninst✝ : PseudoEMetricSpace α\nhs : s.Subsingleton\n⊢ Eq (EMetric.diam s) 0","decl":"/-- The diameter of a subsingleton vanishes. -/\ntheorem diam_subsingleton (hs : s.Subsingleton) : diam s = 0 :=\n  nonpos_iff_eq_zero.1 <| diam_le fun _x hx y hy => (hs hx hy).symm ▸ edist_self y ▸ le_rfl\n\n"}
{"name":"EMetric.diam_empty","module":"Mathlib.Topology.EMetricSpace.Diam","initialProofState":"α : Type u_1\ninst✝ : PseudoEMetricSpace α\n⊢ Eq (EMetric.diam EmptyCollection.emptyCollection) 0","decl":"/-- The diameter of the empty set vanishes -/\n@[simp]\ntheorem diam_empty : diam (∅ : Set α) = 0 :=\n  diam_subsingleton subsingleton_empty\n\n"}
{"name":"EMetric.diam_singleton","module":"Mathlib.Topology.EMetricSpace.Diam","initialProofState":"α : Type u_1\nx : α\ninst✝ : PseudoEMetricSpace α\n⊢ Eq (EMetric.diam (Singleton.singleton x)) 0","decl":"/-- The diameter of a singleton vanishes -/\n@[simp]\ntheorem diam_singleton : diam ({x} : Set α) = 0 :=\n  diam_subsingleton subsingleton_singleton\n\n"}
{"name":"EMetric.diam_one","module":"Mathlib.Topology.EMetricSpace.Diam","initialProofState":"α : Type u_1\ninst✝¹ : PseudoEMetricSpace α\ninst✝ : One α\n⊢ Eq (EMetric.diam 1) 0","decl":"@[to_additive (attr := simp)]\ntheorem diam_one [One α] : diam (1 : Set α) = 0 :=\n  diam_singleton\n\n"}
{"name":"EMetric.diam_zero","module":"Mathlib.Topology.EMetricSpace.Diam","initialProofState":"α : Type u_1\ninst✝¹ : PseudoEMetricSpace α\ninst✝ : Zero α\n⊢ Eq (EMetric.diam 0) 0","decl":"@[to_additive (attr := simp)]\ntheorem diam_one [One α] : diam (1 : Set α) = 0 :=\n  diam_singleton\n\n"}
{"name":"EMetric.diam_iUnion_mem_option","module":"Mathlib.Topology.EMetricSpace.Diam","initialProofState":"α : Type u_1\ninst✝ : PseudoEMetricSpace α\nι : Type u_3\no : Option ι\ns : ι → Set α\n⊢ Eq (EMetric.diam (Set.iUnion fun i => Set.iUnion fun h => s i)) (iSup fun i => iSup fun h => EMetric.diam (s i))","decl":"theorem diam_iUnion_mem_option {ι : Type*} (o : Option ι) (s : ι → Set α) :\n    diam (⋃ i ∈ o, s i) = ⨆ i ∈ o, diam (s i) := by cases o <;> simp\n\n"}
{"name":"EMetric.diam_insert","module":"Mathlib.Topology.EMetricSpace.Diam","initialProofState":"α : Type u_1\ns : Set α\nx : α\ninst✝ : PseudoEMetricSpace α\n⊢ Eq (EMetric.diam (Insert.insert x s)) (Max.max (iSup fun y => iSup fun h => EDist.edist x y) (EMetric.diam s))","decl":"theorem diam_insert : diam (insert x s) = max (⨆ y ∈ s, edist x y) (diam s) :=\n  eq_of_forall_ge_iff fun d => by\n    simp only [diam_le_iff, forall_mem_insert, edist_self, edist_comm x, max_le_iff, iSup_le_iff,\n      zero_le, true_and, forall_and, and_self_iff, ← and_assoc]\n\n"}
{"name":"EMetric.diam_pair","module":"Mathlib.Topology.EMetricSpace.Diam","initialProofState":"α : Type u_1\nx y : α\ninst✝ : PseudoEMetricSpace α\n⊢ Eq (EMetric.diam (Insert.insert x (Singleton.singleton y))) (EDist.edist x y)","decl":"theorem diam_pair : diam ({x, y} : Set α) = edist x y := by\n  simp only [iSup_singleton, diam_insert, diam_singleton, ENNReal.max_zero_right]\n\n"}
{"name":"EMetric.diam_triple","module":"Mathlib.Topology.EMetricSpace.Diam","initialProofState":"α : Type u_1\nx y z : α\ninst✝ : PseudoEMetricSpace α\n⊢ Eq (EMetric.diam (Insert.insert x (Insert.insert y (Singleton.singleton z)))) (Max.max (Max.max (EDist.edist x y) (EDist.edist x z)) (EDist.edist y z))","decl":"theorem diam_triple : diam ({x, y, z} : Set α) = max (max (edist x y) (edist x z)) (edist y z) := by\n  simp only [diam_insert, iSup_insert, iSup_singleton, diam_singleton, ENNReal.max_zero_right]\n\n"}
{"name":"EMetric.diam_mono","module":"Mathlib.Topology.EMetricSpace.Diam","initialProofState":"α : Type u_1\ninst✝ : PseudoEMetricSpace α\ns t : Set α\nh : HasSubset.Subset s t\n⊢ LE.le (EMetric.diam s) (EMetric.diam t)","decl":"/-- The diameter is monotonous with respect to inclusion -/\n@[gcongr]\ntheorem diam_mono {s t : Set α} (h : s ⊆ t) : diam s ≤ diam t :=\n  diam_le fun _x hx _y hy => edist_le_diam_of_mem (h hx) (h hy)\n\n"}
{"name":"EMetric.diam_union","module":"Mathlib.Topology.EMetricSpace.Diam","initialProofState":"α : Type u_1\ns : Set α\nx y : α\ninst✝ : PseudoEMetricSpace α\nt : Set α\nxs : Membership.mem s x\nyt : Membership.mem t y\n⊢ LE.le (EMetric.diam (Union.union s t)) (HAdd.hAdd (HAdd.hAdd (EMetric.diam s) (EDist.edist x y)) (EMetric.diam t))","decl":"/-- The diameter of a union is controlled by the diameter of the sets, and the edistance\nbetween two points in the sets. -/\ntheorem diam_union {t : Set α} (xs : x ∈ s) (yt : y ∈ t) :\n    diam (s ∪ t) ≤ diam s + edist x y + diam t := by\n  have A : ∀ a ∈ s, ∀ b ∈ t, edist a b ≤ diam s + edist x y + diam t := fun a ha b hb =>\n    calc\n      edist a b ≤ edist a x + edist x y + edist y b := edist_triangle4 _ _ _ _\n      _ ≤ diam s + edist x y + diam t :=\n        add_le_add (add_le_add (edist_le_diam_of_mem ha xs) le_rfl) (edist_le_diam_of_mem yt hb)\n  refine diam_le fun a ha b hb => ?_\n  cases' (mem_union _ _ _).1 ha with h'a h'a <;> cases' (mem_union _ _ _).1 hb with h'b h'b\n  · calc\n      edist a b ≤ diam s := edist_le_diam_of_mem h'a h'b\n      _ ≤ diam s + (edist x y + diam t) := le_self_add\n      _ = diam s + edist x y + diam t := (add_assoc _ _ _).symm\n  · exact A a h'a b h'b\n  · have Z := A b h'b a h'a\n    rwa [edist_comm] at Z\n  · calc\n      edist a b ≤ diam t := edist_le_diam_of_mem h'a h'b\n      _ ≤ diam s + edist x y + diam t := le_add_self\n\n"}
{"name":"EMetric.diam_union'","module":"Mathlib.Topology.EMetricSpace.Diam","initialProofState":"α : Type u_1\ns : Set α\ninst✝ : PseudoEMetricSpace α\nt : Set α\nh : (Inter.inter s t).Nonempty\n⊢ LE.le (EMetric.diam (Union.union s t)) (HAdd.hAdd (EMetric.diam s) (EMetric.diam t))","decl":"theorem diam_union' {t : Set α} (h : (s ∩ t).Nonempty) : diam (s ∪ t) ≤ diam s + diam t := by\n  let ⟨x, ⟨xs, xt⟩⟩ := h\n  simpa using diam_union xs xt\n\n"}
{"name":"EMetric.diam_closedBall","module":"Mathlib.Topology.EMetricSpace.Diam","initialProofState":"α : Type u_1\nx : α\ninst✝ : PseudoEMetricSpace α\nr : ENNReal\n⊢ LE.le (EMetric.diam (EMetric.closedBall x r)) (HMul.hMul 2 r)","decl":"theorem diam_closedBall {r : ℝ≥0∞} : diam (closedBall x r) ≤ 2 * r :=\n  diam_le fun a ha b hb =>\n    calc\n      edist a b ≤ edist a x + edist b x := edist_triangle_right _ _ _\n      _ ≤ r + r := add_le_add ha hb\n      _ = 2 * r := (two_mul r).symm\n\n"}
{"name":"EMetric.diam_ball","module":"Mathlib.Topology.EMetricSpace.Diam","initialProofState":"α : Type u_1\nx : α\ninst✝ : PseudoEMetricSpace α\nr : ENNReal\n⊢ LE.le (EMetric.diam (EMetric.ball x r)) (HMul.hMul 2 r)","decl":"theorem diam_ball {r : ℝ≥0∞} : diam (ball x r) ≤ 2 * r :=\n  le_trans (diam_mono ball_subset_closedBall) diam_closedBall\n\n"}
{"name":"EMetric.diam_pi_le_of_le","module":"Mathlib.Topology.EMetricSpace.Diam","initialProofState":"β : Type u_2\nπ : β → Type u_3\ninst✝¹ : Fintype β\ninst✝ : (b : β) → PseudoEMetricSpace (π b)\ns : (b : β) → Set (π b)\nc : ENNReal\nh : ∀ (b : β), LE.le (EMetric.diam (s b)) c\n⊢ LE.le (EMetric.diam (Set.univ.pi s)) c","decl":"theorem diam_pi_le_of_le {π : β → Type*} [Fintype β] [∀ b, PseudoEMetricSpace (π b)]\n    {s : ∀ b : β, Set (π b)} {c : ℝ≥0∞} (h : ∀ b, diam (s b) ≤ c) : diam (Set.pi univ s) ≤ c := by\n  refine diam_le fun x hx y hy => edist_pi_le_iff.mpr ?_\n  rw [mem_univ_pi] at hx hy\n  exact fun b => diam_le_iff.1 (h b) (x b) (hx b) (y b) (hy b)\n\n"}
{"name":"EMetric.diam_eq_zero_iff","module":"Mathlib.Topology.EMetricSpace.Diam","initialProofState":"β : Type u_2\ninst✝ : EMetricSpace β\ns : Set β\n⊢ Iff (Eq (EMetric.diam s) 0) s.Subsingleton","decl":"theorem diam_eq_zero_iff : diam s = 0 ↔ s.Subsingleton :=\n  ⟨fun h _x hx _y hy => edist_le_zero.1 <| h ▸ edist_le_diam_of_mem hx hy, diam_subsingleton⟩\n\n"}
{"name":"EMetric.diam_pos_iff","module":"Mathlib.Topology.EMetricSpace.Diam","initialProofState":"β : Type u_2\ninst✝ : EMetricSpace β\ns : Set β\n⊢ Iff (LT.lt 0 (EMetric.diam s)) s.Nontrivial","decl":"theorem diam_pos_iff : 0 < diam s ↔ s.Nontrivial := by\n  simp only [pos_iff_ne_zero, Ne, diam_eq_zero_iff, Set.not_subsingleton_iff]\n\n"}
{"name":"EMetric.diam_pos_iff'","module":"Mathlib.Topology.EMetricSpace.Diam","initialProofState":"β : Type u_2\ninst✝ : EMetricSpace β\ns : Set β\n⊢ Iff (LT.lt 0 (EMetric.diam s)) (Exists fun x => And (Membership.mem s x) (Exists fun y => And (Membership.mem s y) (Ne x y)))","decl":"theorem diam_pos_iff' : 0 < diam s ↔ ∃ x ∈ s, ∃ y ∈ s, x ≠ y := by\n  simp only [diam_pos_iff, Set.Nontrivial, exists_prop]\n\n"}
