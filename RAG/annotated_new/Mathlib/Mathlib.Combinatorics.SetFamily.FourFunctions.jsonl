{"name":"collapse_eq","module":"Mathlib.Combinatorics.SetFamily.FourFunctions","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ¹ : DecidableEq Î±\ninstâœ : LinearOrderedCommSemiring Î²\na : Î±\ns : Finset Î±\nha : Not (Membership.mem s a)\nğ’œ : Finset (Finset Î±)\nf : Finset Î± â†’ Î²\nâŠ¢ Eq (collapse ğ’œ a f s) (HAdd.hAdd (ite (Membership.mem ğ’œ s) (f s) 0) (ite (Membership.mem ğ’œ (Insert.insert a s)) (f (Insert.insert a s)) 0))","decl":"lemma collapse_eq (ha : a âˆ‰ s) (ğ’œ : Finset (Finset Î±)) (f : Finset Î± â†’ Î²) :\n    collapse ğ’œ a f s = (if s âˆˆ ğ’œ then f s else 0) +\n      if insert a s âˆˆ ğ’œ then f (insert a s) else 0 := by\n  rw [collapse, filter_collapse_eq ha]\n  split_ifs <;> simp [(ne_of_mem_of_not_mem' (mem_insert_self a s) ha).symm, *]\n\n"}
{"name":"collapse_of_mem","module":"Mathlib.Combinatorics.SetFamily.FourFunctions","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ¹ : DecidableEq Î±\ninstâœ : LinearOrderedCommSemiring Î²\nğ’œ : Finset (Finset Î±)\na : Î±\nf : Finset Î± â†’ Î²\ns t u : Finset Î±\nha : Not (Membership.mem s a)\nht : Membership.mem ğ’œ t\nhu : Membership.mem ğ’œ u\nhts : Eq t s\nhus : Eq u (Insert.insert a s)\nâŠ¢ Eq (collapse ğ’œ a f s) (HAdd.hAdd (f t) (f u))","decl":"lemma collapse_of_mem (ha : a âˆ‰ s) (ht : t âˆˆ ğ’œ) (hu : u âˆˆ ğ’œ) (hts : t = s)\n    (hus : u = insert a s) : collapse ğ’œ a f s = f t + f u := by\n  subst hts; subst hus; simp_rw [collapse_eq ha, if_pos ht, if_pos hu]\n\n"}
{"name":"le_collapse_of_mem","module":"Mathlib.Combinatorics.SetFamily.FourFunctions","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ¹ : DecidableEq Î±\ninstâœ : LinearOrderedCommSemiring Î²\nğ’œ : Finset (Finset Î±)\na : Î±\nf : Finset Î± â†’ Î²\ns t : Finset Î±\nha : Not (Membership.mem s a)\nhf : LE.le 0 f\nhts : Eq t s\nht : Membership.mem ğ’œ t\nâŠ¢ LE.le (f t) (collapse ğ’œ a f s)","decl":"lemma le_collapse_of_mem (ha : a âˆ‰ s) (hf : 0 â‰¤ f) (hts : t = s) (ht : t âˆˆ ğ’œ) :\n    f t â‰¤ collapse ğ’œ a f s := by\n  subst hts\n  rw [collapse_eq ha, if_pos ht]\n  split_ifs\n  Â· exact le_add_of_nonneg_right <| hf _\n  Â· rw [add_zero]\n\n"}
{"name":"le_collapse_of_insert_mem","module":"Mathlib.Combinatorics.SetFamily.FourFunctions","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ¹ : DecidableEq Î±\ninstâœ : LinearOrderedCommSemiring Î²\nğ’œ : Finset (Finset Î±)\na : Î±\nf : Finset Î± â†’ Î²\ns t : Finset Î±\nha : Not (Membership.mem s a)\nhf : LE.le 0 f\nhts : Eq t (Insert.insert a s)\nht : Membership.mem ğ’œ t\nâŠ¢ LE.le (f t) (collapse ğ’œ a f s)","decl":"lemma le_collapse_of_insert_mem (ha : a âˆ‰ s) (hf : 0 â‰¤ f) (hts : t = insert a s) (ht : t âˆˆ ğ’œ) :\n    f t â‰¤ collapse ğ’œ a f s := by\n  rw [collapse_eq ha, â† hts, if_pos ht]\n  split_ifs\n  Â· exact le_add_of_nonneg_left <| hf _\n  Â· rw [zero_add]\n\n"}
{"name":"collapse_nonneg","module":"Mathlib.Combinatorics.SetFamily.FourFunctions","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ¹ : DecidableEq Î±\ninstâœ : LinearOrderedCommSemiring Î²\nğ’œ : Finset (Finset Î±)\na : Î±\nf : Finset Î± â†’ Î²\nhf : LE.le 0 f\nâŠ¢ LE.le 0 (collapse ğ’œ a f)","decl":"lemma collapse_nonneg (hf : 0 â‰¤ f) : 0 â‰¤ collapse ğ’œ a f := fun _s â†¦ sum_nonneg fun _t _ â†¦ hf _\n\n"}
{"name":"collapse_modular","module":"Mathlib.Combinatorics.SetFamily.FourFunctions","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ² : DecidableEq Î±\ninstâœÂ¹ : LinearOrderedCommSemiring Î²\na : Î±\nfâ‚ fâ‚‚ fâ‚ƒ fâ‚„ : Finset Î± â†’ Î²\nu : Finset Î±\ninstâœ : ExistsAddOfLE Î²\nhu : Not (Membership.mem u a)\nhâ‚ : LE.le 0 fâ‚\nhâ‚‚ : LE.le 0 fâ‚‚\nhâ‚ƒ : LE.le 0 fâ‚ƒ\nhâ‚„ : LE.le 0 fâ‚„\nh : âˆ€ â¦ƒs : Finset Î±â¦„, HasSubset.Subset s (Insert.insert a u) â†’ âˆ€ â¦ƒt : Finset Î±â¦„, HasSubset.Subset t (Insert.insert a u) â†’ LE.le (HMul.hMul (fâ‚ s) (fâ‚‚ t)) (HMul.hMul (fâ‚ƒ (Inter.inter s t)) (fâ‚„ (Union.union s t)))\nğ’œ â„¬ : Finset (Finset Î±)\ns : Finset Î±\naâœÂ¹ : HasSubset.Subset s u\nt : Finset Î±\naâœ : HasSubset.Subset t u\nâŠ¢ LE.le (HMul.hMul (collapse ğ’œ a fâ‚ s) (collapse â„¬ a fâ‚‚ t)) (HMul.hMul (collapse (HasInfs.infs ğ’œ â„¬) a fâ‚ƒ (Inter.inter s t)) (collapse (HasSups.sups ğ’œ â„¬) a fâ‚„ (Union.union s t)))","decl":"lemma collapse_modular [ExistsAddOfLE Î²]\n    (hu : a âˆ‰ u) (hâ‚ : 0 â‰¤ fâ‚) (hâ‚‚ : 0 â‰¤ fâ‚‚) (hâ‚ƒ : 0 â‰¤ fâ‚ƒ) (hâ‚„ : 0 â‰¤ fâ‚„)\n    (h : âˆ€ â¦ƒsâ¦„, s âŠ† insert a u â†’ âˆ€ â¦ƒtâ¦„, t âŠ† insert a u â†’  fâ‚ s * fâ‚‚ t â‰¤ fâ‚ƒ (s âˆ© t) * fâ‚„ (s âˆª t))\n    (ğ’œ â„¬ : Finset (Finset Î±)) :\n    âˆ€ â¦ƒsâ¦„, s âŠ† u â†’ âˆ€ â¦ƒtâ¦„, t âŠ† u â†’ collapse ğ’œ a fâ‚ s * collapse â„¬ a fâ‚‚ t â‰¤\n      collapse (ğ’œ âŠ¼ â„¬) a fâ‚ƒ (s âˆ© t) * collapse (ğ’œ âŠ» â„¬) a fâ‚„ (s âˆª t) := by\n  rintro s hsu t htu\n  -- Gather a bunch of facts we'll need a lot\n  have := hsu.trans <| subset_insert a _\n  have := htu.trans <| subset_insert a _\n  have := insert_subset_insert a hsu\n  have := insert_subset_insert a htu\n  have has := not_mem_mono hsu hu\n  have hat := not_mem_mono htu hu\n  have : a âˆ‰ s âˆ© t := not_mem_mono (inter_subset_left.trans hsu) hu\n  have := not_mem_union.2 âŸ¨has, hatâŸ©\n  rw [collapse_eq has]\n  split_ifs\n  Â· rw [collapse_eq hat]\n    split_ifs\n    Â· rw [collapse_of_mem â€¹_â€º (inter_mem_infs â€¹_â€º â€¹_â€º) (inter_mem_infs â€¹_â€º â€¹_â€º) rfl\n        (insert_inter_distrib _ _ _).symm, collapse_of_mem â€¹_â€º (union_mem_sups â€¹_â€º â€¹_â€º)\n        (union_mem_sups â€¹_â€º â€¹_â€º) rfl (insert_union_distrib _ _ _).symm]\n      refine ineq (hâ‚ _) (hâ‚ _) (hâ‚‚ _) (hâ‚‚ _) (hâ‚ƒ _) (hâ‚ƒ _) (hâ‚„ _) (hâ‚„ _) (h â€¹_â€º â€¹_â€º) ?_ ?_ ?_\n      Â· simpa [*] using h â€¹insert a s âŠ† _â€º â€¹t âŠ† _â€º\n      Â· simpa [*] using h â€¹s âŠ† _â€º â€¹insert a t âŠ† _â€º\n      Â· simpa [*] using h â€¹insert a s âŠ† _â€º â€¹insert a t âŠ† _â€º\n    Â· rw [add_zero, add_mul]\n      refine (add_le_add (h â€¹_â€º â€¹_â€º) <| h â€¹_â€º â€¹_â€º).trans ?_\n      rw [collapse_of_mem â€¹_â€º (union_mem_sups â€¹_â€º â€¹_â€º) (union_mem_sups â€¹_â€º â€¹_â€º) rfl\n        (insert_union _ _ _), insert_inter_of_not_mem â€¹_â€º, â† mul_add]\n      exact mul_le_mul_of_nonneg_right (le_collapse_of_mem â€¹_â€º hâ‚ƒ rfl <| inter_mem_infs â€¹_â€º â€¹_â€º) <|\n        add_nonneg (hâ‚„ _) <| hâ‚„ _\n    Â· rw [zero_add, add_mul]\n      refine (add_le_add (h â€¹_â€º â€¹_â€º) <| h â€¹_â€º â€¹_â€º).trans ?_\n      rw [collapse_of_mem â€¹_â€º (inter_mem_infs â€¹_â€º â€¹_â€º) (inter_mem_infs â€¹_â€º â€¹_â€º)\n        (inter_insert_of_not_mem â€¹_â€º) (insert_inter_distrib _ _ _).symm, union_insert,\n        insert_union_distrib, â† add_mul]\n      exact mul_le_mul_of_nonneg_left (le_collapse_of_insert_mem â€¹_â€º hâ‚„\n        (insert_union_distrib _ _ _).symm <| union_mem_sups â€¹_â€º â€¹_â€º) <| add_nonneg (hâ‚ƒ _) <| hâ‚ƒ _\n    Â· rw [add_zero, mul_zero]\n      exact mul_nonneg (collapse_nonneg hâ‚ƒ _) <| collapse_nonneg hâ‚„ _\n  Â· rw [add_zero, collapse_eq hat, mul_add]\n    split_ifs\n    Â· refine (add_le_add (h â€¹_â€º â€¹_â€º) <| h â€¹_â€º â€¹_â€º).trans ?_\n      rw [collapse_of_mem â€¹_â€º (union_mem_sups â€¹_â€º â€¹_â€º) (union_mem_sups â€¹_â€º â€¹_â€º) rfl\n        (union_insert _ _ _), inter_insert_of_not_mem â€¹_â€º, â† mul_add]\n      exact mul_le_mul_of_nonneg_right (le_collapse_of_mem â€¹_â€º hâ‚ƒ rfl <| inter_mem_infs â€¹_â€º â€¹_â€º) <|\n        add_nonneg (hâ‚„ _) <| hâ‚„ _\n    Â· rw [mul_zero, add_zero]\n      exact (h â€¹_â€º â€¹_â€º).trans <| mul_le_mul (le_collapse_of_mem â€¹_â€º hâ‚ƒ rfl <|\n        inter_mem_infs â€¹_â€º â€¹_â€º) (le_collapse_of_mem â€¹_â€º hâ‚„ rfl <| union_mem_sups â€¹_â€º â€¹_â€º)\n        (hâ‚„ _) <| collapse_nonneg hâ‚ƒ _\n    Â· rw [mul_zero, zero_add]\n      refine (h â€¹_â€º â€¹_â€º).trans <| mul_le_mul ?_ (le_collapse_of_insert_mem â€¹_â€º hâ‚„\n        (union_insert _ _ _) <| union_mem_sups â€¹_â€º â€¹_â€º) (hâ‚„ _) <| collapse_nonneg hâ‚ƒ _\n      exact le_collapse_of_mem (not_mem_mono inter_subset_left â€¹_â€º) hâ‚ƒ\n        (inter_insert_of_not_mem â€¹_â€º) <| inter_mem_infs â€¹_â€º â€¹_â€º\n    Â· simp_rw [mul_zero, add_zero]\n      exact mul_nonneg (collapse_nonneg hâ‚ƒ _) <| collapse_nonneg hâ‚„ _\n  Â· rw [zero_add, collapse_eq hat, mul_add]\n    split_ifs\n    Â· refine (add_le_add (h â€¹_â€º â€¹_â€º) <| h â€¹_â€º â€¹_â€º).trans ?_\n      rw [collapse_of_mem â€¹_â€º (inter_mem_infs â€¹_â€º â€¹_â€º) (inter_mem_infs â€¹_â€º â€¹_â€º)\n        (insert_inter_of_not_mem â€¹_â€º) (insert_inter_distrib _ _ _).symm,\n        insert_inter_of_not_mem â€¹_â€º, â† insert_inter_distrib, insert_union, insert_union_distrib,\n        â† add_mul]\n      exact mul_le_mul_of_nonneg_left (le_collapse_of_insert_mem â€¹_â€º hâ‚„\n        (insert_union_distrib _ _ _).symm <| union_mem_sups â€¹_â€º â€¹_â€º) <| add_nonneg (hâ‚ƒ _) <| hâ‚ƒ _\n    Â· rw [mul_zero, add_zero]\n      refine (h â€¹_â€º â€¹_â€º).trans <| mul_le_mul (le_collapse_of_mem â€¹_â€º hâ‚ƒ\n        (insert_inter_of_not_mem â€¹_â€º) <| inter_mem_infs â€¹_â€º â€¹_â€º) (le_collapse_of_insert_mem â€¹_â€º hâ‚„\n        (insert_union _ _ _) <| union_mem_sups â€¹_â€º â€¹_â€º) (hâ‚„ _) <| collapse_nonneg hâ‚ƒ _\n    Â· rw [mul_zero, zero_add]\n      exact (h â€¹_â€º â€¹_â€º).trans <| mul_le_mul (le_collapse_of_insert_mem â€¹_â€º hâ‚ƒ\n        (insert_inter_distrib _ _ _).symm <| inter_mem_infs â€¹_â€º â€¹_â€º) (le_collapse_of_insert_mem â€¹_â€º\n        hâ‚„ (insert_union_distrib _ _ _).symm <| union_mem_sups â€¹_â€º â€¹_â€º) (hâ‚„ _) <|\n        collapse_nonneg hâ‚ƒ _\n    Â· simp_rw [mul_zero, add_zero]\n      exact mul_nonneg (collapse_nonneg hâ‚ƒ _) <| collapse_nonneg hâ‚„ _\n  Â· simp_rw [add_zero, zero_mul]\n    exact mul_nonneg (collapse_nonneg hâ‚ƒ _) <| collapse_nonneg hâ‚„ _\n\n"}
{"name":"sum_collapse","module":"Mathlib.Combinatorics.SetFamily.FourFunctions","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ¹ : DecidableEq Î±\ninstâœ : LinearOrderedCommSemiring Î²\nğ’œ : Finset (Finset Î±)\na : Î±\nf : Finset Î± â†’ Î²\nu : Finset Î±\nhğ’œ : HasSubset.Subset ğ’œ (Insert.insert a u).powerset\nhu : Not (Membership.mem u a)\nâŠ¢ Eq (u.powerset.sum fun s => collapse ğ’œ a f s) (ğ’œ.sum fun s => f s)","decl":"lemma sum_collapse (hğ’œ : ğ’œ âŠ† (insert a u).powerset) (hu : a âˆ‰ u) :\n    âˆ‘ s âˆˆ u.powerset, collapse ğ’œ a f s = âˆ‘ s âˆˆ ğ’œ, f s := by\n  calc\n    _ = âˆ‘ s âˆˆ u.powerset âˆ© ğ’œ, f s + âˆ‘ s âˆˆ u.powerset.image (insert a) âˆ© ğ’œ, f s := ?_\n    _ = âˆ‘ s âˆˆ u.powerset âˆ© ğ’œ, f s + âˆ‘ s âˆˆ ((insert a u).powerset \\ u.powerset) âˆ© ğ’œ, f s := ?_\n    _ = âˆ‘ s âˆˆ ğ’œ, f s := ?_\n  Â· rw [â† Finset.sum_ite_mem, â† Finset.sum_ite_mem, sum_image, â† sum_add_distrib]\n    Â· exact sum_congr rfl fun s hs â†¦ collapse_eq (not_mem_mono (mem_powerset.1 hs) hu) _ _\n    Â· exact (insert_erase_invOn.2.injOn).mono fun s hs â†¦ not_mem_mono (mem_powerset.1 hs) hu\n  Â· congr with s\n    simp only [mem_image, mem_powerset, mem_sdiff, subset_insert_iff]\n    refine âŸ¨?_, fun h â†¦ âŸ¨_, h.1, ?_âŸ©âŸ©\n    Â· rintro âŸ¨s, hs, rflâŸ©\n      exact âŸ¨subset_insert_iff.1 <| insert_subset_insert _ hs, fun h â†¦\n        hu <| h <| mem_insert_self _ _âŸ©\n    Â· rw [insert_erase (erase_ne_self.1 fun hs â†¦ ?_)]\n      rw [hs] at h\n      exact h.2 h.1\n  Â· rw [â† sum_union (disjoint_sdiff_self_right.mono inf_le_left inf_le_left),\n      â† union_inter_distrib_right, union_sdiff_of_subset (powerset_mono.2 <| subset_insert _ _),\n      inter_eq_right.2 hğ’œ]\n\n"}
{"name":"Finset.four_functions_theorem","module":"Mathlib.Combinatorics.SetFamily.FourFunctions","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ² : DecidableEq Î±\ninstâœÂ¹ : LinearOrderedCommSemiring Î²\nfâ‚ fâ‚‚ fâ‚ƒ fâ‚„ : Finset Î± â†’ Î²\ninstâœ : ExistsAddOfLE Î²\nu : Finset Î±\nhâ‚ : LE.le 0 fâ‚\nhâ‚‚ : LE.le 0 fâ‚‚\nhâ‚ƒ : LE.le 0 fâ‚ƒ\nhâ‚„ : LE.le 0 fâ‚„\nh : âˆ€ â¦ƒs : Finset Î±â¦„, HasSubset.Subset s u â†’ âˆ€ â¦ƒt : Finset Î±â¦„, HasSubset.Subset t u â†’ LE.le (HMul.hMul (fâ‚ s) (fâ‚‚ t)) (HMul.hMul (fâ‚ƒ (Inter.inter s t)) (fâ‚„ (Union.union s t)))\nğ’œ â„¬ : Finset (Finset Î±)\nhğ’œ : HasSubset.Subset ğ’œ u.powerset\nhâ„¬ : HasSubset.Subset â„¬ u.powerset\nâŠ¢ LE.le (HMul.hMul (ğ’œ.sum fun s => fâ‚ s) (â„¬.sum fun s => fâ‚‚ s)) (HMul.hMul ((HasInfs.infs ğ’œ â„¬).sum fun s => fâ‚ƒ s) ((HasSups.sups ğ’œ â„¬).sum fun s => fâ‚„ s))","decl":"/-- The **Four Functions Theorem** on a powerset algebra. See `four_functions_theorem` for the\nfinite distributive lattice generalisation. -/\nprotected lemma Finset.four_functions_theorem (u : Finset Î±)\n    (hâ‚ : 0 â‰¤ fâ‚) (hâ‚‚ : 0 â‰¤ fâ‚‚) (hâ‚ƒ : 0 â‰¤ fâ‚ƒ) (hâ‚„ : 0 â‰¤ fâ‚„)\n    (h : âˆ€ â¦ƒsâ¦„, s âŠ† u â†’ âˆ€ â¦ƒtâ¦„, t âŠ† u â†’ fâ‚ s * fâ‚‚ t â‰¤ fâ‚ƒ (s âˆ© t) * fâ‚„ (s âˆª t))\n    {ğ’œ â„¬ : Finset (Finset Î±)} (hğ’œ : ğ’œ âŠ† u.powerset) (hâ„¬ : â„¬ âŠ† u.powerset) :\n    (âˆ‘ s âˆˆ ğ’œ, fâ‚ s) * âˆ‘ s âˆˆ â„¬, fâ‚‚ s â‰¤ (âˆ‘ s âˆˆ ğ’œ âŠ¼ â„¬, fâ‚ƒ s) * âˆ‘ s âˆˆ ğ’œ âŠ» â„¬, fâ‚„ s := by\n  induction' u using Finset.induction with a u hu ih generalizing fâ‚ fâ‚‚ fâ‚ƒ fâ‚„ ğ’œ â„¬\n  Â· simp only [Finset.powerset_empty, Finset.subset_singleton_iff] at hğ’œ hâ„¬\n    obtain rfl | rfl := hğ’œ <;> obtain rfl | rfl := hâ„¬ <;> simp; exact h (subset_refl âˆ…) subset_rfl\n  specialize ih (collapse_nonneg hâ‚) (collapse_nonneg hâ‚‚) (collapse_nonneg hâ‚ƒ) (collapse_nonneg hâ‚„)\n    (collapse_modular hu hâ‚ hâ‚‚ hâ‚ƒ hâ‚„ h ğ’œ â„¬) Subset.rfl Subset.rfl\n  have : ğ’œ âŠ¼ â„¬ âŠ† powerset (insert a u) := by simpa using infs_subset hğ’œ hâ„¬\n  have : ğ’œ âŠ» â„¬ âŠ† powerset (insert a u) := by simpa using sups_subset hğ’œ hâ„¬\n  simpa only [powerset_sups_powerset_self, powerset_infs_powerset_self, sum_collapse,\n    not_false_eq_true, *] using ih\n\n"}
{"name":"four_functions_theorem","module":"Mathlib.Combinatorics.SetFamily.FourFunctions","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ³ : DistribLattice Î±\ninstâœÂ² : LinearOrderedCommSemiring Î²\ninstâœÂ¹ : ExistsAddOfLE Î²\nfâ‚ fâ‚‚ fâ‚ƒ fâ‚„ : Î± â†’ Î²\ninstâœ : DecidableEq Î±\nhâ‚ : LE.le 0 fâ‚\nhâ‚‚ : LE.le 0 fâ‚‚\nhâ‚ƒ : LE.le 0 fâ‚ƒ\nhâ‚„ : LE.le 0 fâ‚„\nh : âˆ€ (a b : Î±), LE.le (HMul.hMul (fâ‚ a) (fâ‚‚ b)) (HMul.hMul (fâ‚ƒ (Min.min a b)) (fâ‚„ (Max.max a b)))\ns t : Finset Î±\nâŠ¢ LE.le (HMul.hMul (s.sum fun a => fâ‚ a) (t.sum fun a => fâ‚‚ a)) (HMul.hMul ((HasInfs.infs s t).sum fun a => fâ‚ƒ a) ((HasSups.sups s t).sum fun a => fâ‚„ a))","decl":"/-- The **Four Functions Theorem**, aka **Ahlswede-Daykin Inequality**. -/\nlemma four_functions_theorem [DecidableEq Î±] (hâ‚ : 0 â‰¤ fâ‚) (hâ‚‚ : 0 â‰¤ fâ‚‚) (hâ‚ƒ : 0 â‰¤ fâ‚ƒ) (hâ‚„ : 0 â‰¤ fâ‚„)\n    (h : âˆ€ a b, fâ‚ a * fâ‚‚ b â‰¤ fâ‚ƒ (a âŠ“ b) * fâ‚„ (a âŠ” b)) (s t : Finset Î±) :\n    (âˆ‘ a âˆˆ s, fâ‚ a) * âˆ‘ a âˆˆ t, fâ‚‚ a â‰¤ (âˆ‘ a âˆˆ s âŠ¼ t, fâ‚ƒ a) * âˆ‘ a âˆˆ s âŠ» t, fâ‚„ a := by\n  classical\n  set L : Sublattice Î± := âŸ¨latticeClosure (s âˆª t), isSublattice_latticeClosure.1,\n    isSublattice_latticeClosure.2âŸ©\n  have : Finite L := (s.finite_toSet.union t.finite_toSet).latticeClosure.to_subtype\n  set s' : Finset L := s.preimage (â†‘) Subtype.coe_injective.injOn\n  set t' : Finset L := t.preimage (â†‘) Subtype.coe_injective.injOn\n  have hs' : s'.map âŸ¨L.subtype, Subtype.coe_injectiveâŸ© = s := by\n    simp [s', map_eq_image, image_preimage, filter_eq_self]\n    exact fun a ha â†¦ subset_latticeClosure <| Set.subset_union_left ha\n  have ht' : t'.map âŸ¨L.subtype, Subtype.coe_injectiveâŸ© = t := by\n    simp [t', map_eq_image, image_preimage, filter_eq_self]\n    exact fun a ha â†¦ subset_latticeClosure <| Set.subset_union_right ha\n  clear_value s' t'\n  obtain âŸ¨Î², _, _, g, hgâŸ© := exists_birkhoff_representation L\n  have := four_functions_theorem_aux (extend g (fâ‚ âˆ˜ (â†‘)) 0) (extend g (fâ‚‚ âˆ˜ (â†‘)) 0)\n    (extend g (fâ‚ƒ âˆ˜ (â†‘)) 0) (extend g (fâ‚„ âˆ˜ (â†‘)) 0) (extend_nonneg (fun _ â†¦ hâ‚ _) le_rfl)\n    (extend_nonneg (fun _ â†¦ hâ‚‚ _) le_rfl) (extend_nonneg (fun _ â†¦ hâ‚ƒ _) le_rfl)\n    (extend_nonneg (fun _ â†¦ hâ‚„ _) le_rfl) ?_ (s'.map âŸ¨g, hgâŸ©) (t'.map âŸ¨g, hgâŸ©)\n  Â· simpa only [â† hs', â† ht', â† map_sups, â† map_infs, sum_map, Embedding.coeFn_mk, hg.extend_apply]\n      using this\n  rintro s t\n  classical\n  obtain âŸ¨a, rflâŸ© | hs := em (âˆƒ a, g a = s)\n  Â· obtain âŸ¨b, rflâŸ© | ht := em (âˆƒ b, g b = t)\n    Â· simp_rw [â† sup_eq_union, â† inf_eq_inter, â† map_sup, â† map_inf, hg.extend_apply]\n      exact h _ _\n    Â· simpa [extend_apply' _ _ _ ht] using mul_nonneg\n        (extend_nonneg (fun a : L â†¦ hâ‚ƒ a) le_rfl _) (extend_nonneg (fun a : L â†¦ hâ‚„ a) le_rfl _)\n  Â· simpa [extend_apply' _ _ _ hs] using mul_nonneg\n      (extend_nonneg (fun a : L â†¦ hâ‚ƒ a) le_rfl _) (extend_nonneg (fun a : L â†¦ hâ‚„ a) le_rfl _)\n\n"}
{"name":"Finset.le_card_infs_mul_card_sups","module":"Mathlib.Combinatorics.SetFamily.FourFunctions","initialProofState":"Î± : Type u_1\ninstâœÂ¹ : DistribLattice Î±\ninstâœ : DecidableEq Î±\ns t : Finset Î±\nâŠ¢ LE.le (HMul.hMul s.card t.card) (HMul.hMul (HasInfs.infs s t).card (HasSups.sups s t).card)","decl":"/-- An inequality of Daykin. Interestingly, any lattice in which this inequality holds is\ndistributive. -/\nlemma Finset.le_card_infs_mul_card_sups [DecidableEq Î±] (s t : Finset Î±) :\n    #s * #t â‰¤ #(s âŠ¼ t) * #(s âŠ» t) := by\n  simpa using four_functions_theorem (1 : Î± â†’ â„•) 1 1 1 zero_le_one zero_le_one zero_le_one\n    zero_le_one (fun _ _ â†¦ le_rfl) s t\n\n"}
{"name":"four_functions_theorem_univ","module":"Mathlib.Combinatorics.SetFamily.FourFunctions","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ³ : DistribLattice Î±\ninstâœÂ² : LinearOrderedCommSemiring Î²\ninstâœÂ¹ : ExistsAddOfLE Î²\nfâ‚ fâ‚‚ fâ‚ƒ fâ‚„ : Î± â†’ Î²\ninstâœ : Fintype Î±\nhâ‚ : LE.le 0 fâ‚\nhâ‚‚ : LE.le 0 fâ‚‚\nhâ‚ƒ : LE.le 0 fâ‚ƒ\nhâ‚„ : LE.le 0 fâ‚„\nh : âˆ€ (a b : Î±), LE.le (HMul.hMul (fâ‚ a) (fâ‚‚ b)) (HMul.hMul (fâ‚ƒ (Min.min a b)) (fâ‚„ (Max.max a b)))\nâŠ¢ LE.le (HMul.hMul (Finset.univ.sum fun a => fâ‚ a) (Finset.univ.sum fun a => fâ‚‚ a)) (HMul.hMul (Finset.univ.sum fun a => fâ‚ƒ a) (Finset.univ.sum fun a => fâ‚„ a))","decl":"/-- Special case of the **Four Functions Theorem** when `s = t = univ`. -/\nlemma four_functions_theorem_univ (hâ‚ : 0 â‰¤ fâ‚) (hâ‚‚ : 0 â‰¤ fâ‚‚) (hâ‚ƒ : 0 â‰¤ fâ‚ƒ) (hâ‚„ : 0 â‰¤ fâ‚„)\n    (h : âˆ€ a b, fâ‚ a * fâ‚‚ b â‰¤ fâ‚ƒ (a âŠ“ b) * fâ‚„ (a âŠ” b)) :\n    (âˆ‘ a, fâ‚ a) * âˆ‘ a, fâ‚‚ a â‰¤ (âˆ‘ a, fâ‚ƒ a) * âˆ‘ a, fâ‚„ a := by\n  classical simpa using four_functions_theorem fâ‚ fâ‚‚ fâ‚ƒ fâ‚„ hâ‚ hâ‚‚ hâ‚ƒ hâ‚„ h univ univ\n\n"}
{"name":"holley","module":"Mathlib.Combinatorics.SetFamily.FourFunctions","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ³ : DistribLattice Î±\ninstâœÂ² : LinearOrderedCommSemiring Î²\ninstâœÂ¹ : ExistsAddOfLE Î²\nf g Î¼ : Î± â†’ Î²\ninstâœ : Fintype Î±\nhÎ¼â‚€ : LE.le 0 Î¼\nhf : LE.le 0 f\nhg : LE.le 0 g\nhÎ¼ : Monotone Î¼\nhfg : Eq (Finset.univ.sum fun a => f a) (Finset.univ.sum fun a => g a)\nh : âˆ€ (a b : Î±), LE.le (HMul.hMul (f a) (g b)) (HMul.hMul (f (Min.min a b)) (g (Max.max a b)))\nâŠ¢ LE.le (Finset.univ.sum fun a => HMul.hMul (Î¼ a) (f a)) (Finset.univ.sum fun a => HMul.hMul (Î¼ a) (g a))","decl":"/-- The **Holley Inequality**. -/\nlemma holley (hÎ¼â‚€ : 0 â‰¤ Î¼) (hf : 0 â‰¤ f) (hg : 0 â‰¤ g) (hÎ¼ : Monotone Î¼)\n    (hfg : âˆ‘ a, f a = âˆ‘ a, g a) (h : âˆ€ a b, f a * g b â‰¤ f (a âŠ“ b) * g (a âŠ” b)) :\n    âˆ‘ a, Î¼ a * f a â‰¤ âˆ‘ a, Î¼ a * g a := by\n  classical\n  obtain rfl | hf := hf.eq_or_lt\n  Â· simp only [Pi.zero_apply, sum_const_zero, eq_comm, Fintype.sum_eq_zero_iff_of_nonneg hg] at hfg\n    simp [hfg]\n  obtain rfl | hg := hg.eq_or_lt\n  Â· simp only [Pi.zero_apply, sum_const_zero, Fintype.sum_eq_zero_iff_of_nonneg hf.le] at hfg\n    simp [hfg]\n  have := four_functions_theorem g (Î¼ * f) f (Î¼ * g) hg.le (mul_nonneg hÎ¼â‚€ hf.le) hf.le\n    (mul_nonneg hÎ¼â‚€ hg.le) (fun a b â†¦ ?_) univ univ\n  Â· simpa [hfg, sum_pos hg] using this\n  Â· simp_rw [Pi.mul_apply, mul_left_comm _ (Î¼ _), mul_comm (g _)]\n    rw [sup_comm, inf_comm]\n    exact mul_le_mul (hÎ¼ le_sup_left) (h _ _) (mul_nonneg (hf.le _) <| hg.le _) <| hÎ¼â‚€ _\n\n"}
{"name":"fkg","module":"Mathlib.Combinatorics.SetFamily.FourFunctions","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ³ : DistribLattice Î±\ninstâœÂ² : LinearOrderedCommSemiring Î²\ninstâœÂ¹ : ExistsAddOfLE Î²\nf g Î¼ : Î± â†’ Î²\ninstâœ : Fintype Î±\nhÎ¼â‚€ : LE.le 0 Î¼\nhfâ‚€ : LE.le 0 f\nhgâ‚€ : LE.le 0 g\nhf : Monotone f\nhg : Monotone g\nhÎ¼ : âˆ€ (a b : Î±), LE.le (HMul.hMul (Î¼ a) (Î¼ b)) (HMul.hMul (Î¼ (Min.min a b)) (Î¼ (Max.max a b)))\nâŠ¢ LE.le (HMul.hMul (Finset.univ.sum fun a => HMul.hMul (Î¼ a) (f a)) (Finset.univ.sum fun a => HMul.hMul (Î¼ a) (g a))) (HMul.hMul (Finset.univ.sum fun a => Î¼ a) (Finset.univ.sum fun a => HMul.hMul (Î¼ a) (HMul.hMul (f a) (g a))))","decl":"/-- The **Fortuin-Kastelyn-Ginibre Inequality**. -/\nlemma fkg (hÎ¼â‚€ : 0 â‰¤ Î¼) (hfâ‚€ : 0 â‰¤ f) (hgâ‚€ : 0 â‰¤ g) (hf : Monotone f) (hg : Monotone g)\n    (hÎ¼ : âˆ€ a b, Î¼ a * Î¼ b â‰¤ Î¼ (a âŠ“ b) * Î¼ (a âŠ” b)) :\n    (âˆ‘ a, Î¼ a * f a) * âˆ‘ a, Î¼ a * g a â‰¤ (âˆ‘ a, Î¼ a) * âˆ‘ a, Î¼ a * (f a * g a) := by\n  refine four_functions_theorem_univ (Î¼ * f) (Î¼ * g) Î¼ _ (mul_nonneg hÎ¼â‚€ hfâ‚€) (mul_nonneg hÎ¼â‚€ hgâ‚€)\n    hÎ¼â‚€ (mul_nonneg hÎ¼â‚€ <| mul_nonneg hfâ‚€ hgâ‚€) (fun a b â†¦ ?_)\n  dsimp\n  rw [mul_mul_mul_comm, â† mul_assoc (Î¼ (a âŠ“ b))]\n  exact mul_le_mul (hÎ¼ _ _) (mul_le_mul (hf le_sup_left) (hg le_sup_right) (hgâ‚€ _) <| hfâ‚€ _)\n    (mul_nonneg (hfâ‚€ _) <| hgâ‚€ _) <| mul_nonneg (hÎ¼â‚€ _) <| hÎ¼â‚€ _\n\n"}
{"name":"Finset.le_card_diffs_mul_card_diffs","module":"Mathlib.Combinatorics.SetFamily.FourFunctions","initialProofState":"Î± : Type u_1\ninstâœÂ¹ : DecidableEq Î±\ninstâœ : GeneralizedBooleanAlgebra Î±\ns t : Finset Î±\nâŠ¢ LE.le (HMul.hMul s.card t.card) (HMul.hMul (s.diffs t).card (t.diffs s).card)","decl":"/-- A slight generalisation of the **Marica-SchÃ¶nheim Inequality**. -/\nlemma Finset.le_card_diffs_mul_card_diffs (s t : Finset Î±) :\n    #s * #t â‰¤ #(s \\\\ t) * #(t \\\\ s) := by\n  have : âˆ€ s t : Finset Î±, (s \\\\ t).map âŸ¨_, liftLatticeHom_injectiveâŸ© =\n      s.map âŸ¨_, liftLatticeHom_injectiveâŸ© \\\\ t.map âŸ¨_, liftLatticeHom_injectiveâŸ© := by\n    rintro s t\n    simp_rw [map_eq_image]\n    exact image_imageâ‚‚_distrib fun a b â†¦ rfl\n  simpa [â† card_compls (_ âŠ» _), â† map_sup, â† map_inf, â† this] using\n    (s.map âŸ¨_, liftLatticeHom_injectiveâŸ©).le_card_infs_mul_card_sups\n      (t.map âŸ¨_, liftLatticeHom_injectiveâŸ©)á¶œË¢\n\n"}
{"name":"Finset.card_le_card_diffs","module":"Mathlib.Combinatorics.SetFamily.FourFunctions","initialProofState":"Î± : Type u_1\ninstâœÂ¹ : DecidableEq Î±\ninstâœ : GeneralizedBooleanAlgebra Î±\ns : Finset Î±\nâŠ¢ LE.le s.card (s.diffs s).card","decl":"/-- The **Marica-SchÃ¶nheim Inequality**. -/\nlemma Finset.card_le_card_diffs (s : Finset Î±) : #s â‰¤ #(s \\\\ s) :=\n  le_of_pow_le_pow_leftâ‚€ two_ne_zero (zero_le _) <| by\n    simpa [â† sq] using s.le_card_diffs_mul_card_diffs s\n"}
