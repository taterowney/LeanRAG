{"name":"collapse_eq","module":"Mathlib.Combinatorics.SetFamily.FourFunctions","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : LinearOrderedCommSemiring β\na : α\ns : Finset α\nha : Not (Membership.mem s a)\n𝒜 : Finset (Finset α)\nf : Finset α → β\n⊢ Eq (collapse 𝒜 a f s) (HAdd.hAdd (ite (Membership.mem 𝒜 s) (f s) 0) (ite (Membership.mem 𝒜 (Insert.insert a s)) (f (Insert.insert a s)) 0))","decl":"lemma collapse_eq (ha : a ∉ s) (𝒜 : Finset (Finset α)) (f : Finset α → β) :\n    collapse 𝒜 a f s = (if s ∈ 𝒜 then f s else 0) +\n      if insert a s ∈ 𝒜 then f (insert a s) else 0 := by\n  rw [collapse, filter_collapse_eq ha]\n  split_ifs <;> simp [(ne_of_mem_of_not_mem' (mem_insert_self a s) ha).symm, *]\n\n"}
{"name":"collapse_of_mem","module":"Mathlib.Combinatorics.SetFamily.FourFunctions","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : LinearOrderedCommSemiring β\n𝒜 : Finset (Finset α)\na : α\nf : Finset α → β\ns t u : Finset α\nha : Not (Membership.mem s a)\nht : Membership.mem 𝒜 t\nhu : Membership.mem 𝒜 u\nhts : Eq t s\nhus : Eq u (Insert.insert a s)\n⊢ Eq (collapse 𝒜 a f s) (HAdd.hAdd (f t) (f u))","decl":"lemma collapse_of_mem (ha : a ∉ s) (ht : t ∈ 𝒜) (hu : u ∈ 𝒜) (hts : t = s)\n    (hus : u = insert a s) : collapse 𝒜 a f s = f t + f u := by\n  subst hts; subst hus; simp_rw [collapse_eq ha, if_pos ht, if_pos hu]\n\n"}
{"name":"le_collapse_of_mem","module":"Mathlib.Combinatorics.SetFamily.FourFunctions","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : LinearOrderedCommSemiring β\n𝒜 : Finset (Finset α)\na : α\nf : Finset α → β\ns t : Finset α\nha : Not (Membership.mem s a)\nhf : LE.le 0 f\nhts : Eq t s\nht : Membership.mem 𝒜 t\n⊢ LE.le (f t) (collapse 𝒜 a f s)","decl":"lemma le_collapse_of_mem (ha : a ∉ s) (hf : 0 ≤ f) (hts : t = s) (ht : t ∈ 𝒜) :\n    f t ≤ collapse 𝒜 a f s := by\n  subst hts\n  rw [collapse_eq ha, if_pos ht]\n  split_ifs\n  · exact le_add_of_nonneg_right <| hf _\n  · rw [add_zero]\n\n"}
{"name":"le_collapse_of_insert_mem","module":"Mathlib.Combinatorics.SetFamily.FourFunctions","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : LinearOrderedCommSemiring β\n𝒜 : Finset (Finset α)\na : α\nf : Finset α → β\ns t : Finset α\nha : Not (Membership.mem s a)\nhf : LE.le 0 f\nhts : Eq t (Insert.insert a s)\nht : Membership.mem 𝒜 t\n⊢ LE.le (f t) (collapse 𝒜 a f s)","decl":"lemma le_collapse_of_insert_mem (ha : a ∉ s) (hf : 0 ≤ f) (hts : t = insert a s) (ht : t ∈ 𝒜) :\n    f t ≤ collapse 𝒜 a f s := by\n  rw [collapse_eq ha, ← hts, if_pos ht]\n  split_ifs\n  · exact le_add_of_nonneg_left <| hf _\n  · rw [zero_add]\n\n"}
{"name":"collapse_nonneg","module":"Mathlib.Combinatorics.SetFamily.FourFunctions","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : LinearOrderedCommSemiring β\n𝒜 : Finset (Finset α)\na : α\nf : Finset α → β\nhf : LE.le 0 f\n⊢ LE.le 0 (collapse 𝒜 a f)","decl":"lemma collapse_nonneg (hf : 0 ≤ f) : 0 ≤ collapse 𝒜 a f := fun _s ↦ sum_nonneg fun _t _ ↦ hf _\n\n"}
{"name":"collapse_modular","module":"Mathlib.Combinatorics.SetFamily.FourFunctions","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : DecidableEq α\ninst✝¹ : LinearOrderedCommSemiring β\na : α\nf₁ f₂ f₃ f₄ : Finset α → β\nu : Finset α\ninst✝ : ExistsAddOfLE β\nhu : Not (Membership.mem u a)\nh₁ : LE.le 0 f₁\nh₂ : LE.le 0 f₂\nh₃ : LE.le 0 f₃\nh₄ : LE.le 0 f₄\nh : ∀ ⦃s : Finset α⦄, HasSubset.Subset s (Insert.insert a u) → ∀ ⦃t : Finset α⦄, HasSubset.Subset t (Insert.insert a u) → LE.le (HMul.hMul (f₁ s) (f₂ t)) (HMul.hMul (f₃ (Inter.inter s t)) (f₄ (Union.union s t)))\n𝒜 ℬ : Finset (Finset α)\ns : Finset α\na✝¹ : HasSubset.Subset s u\nt : Finset α\na✝ : HasSubset.Subset t u\n⊢ LE.le (HMul.hMul (collapse 𝒜 a f₁ s) (collapse ℬ a f₂ t)) (HMul.hMul (collapse (HasInfs.infs 𝒜 ℬ) a f₃ (Inter.inter s t)) (collapse (HasSups.sups 𝒜 ℬ) a f₄ (Union.union s t)))","decl":"lemma collapse_modular [ExistsAddOfLE β]\n    (hu : a ∉ u) (h₁ : 0 ≤ f₁) (h₂ : 0 ≤ f₂) (h₃ : 0 ≤ f₃) (h₄ : 0 ≤ f₄)\n    (h : ∀ ⦃s⦄, s ⊆ insert a u → ∀ ⦃t⦄, t ⊆ insert a u →  f₁ s * f₂ t ≤ f₃ (s ∩ t) * f₄ (s ∪ t))\n    (𝒜 ℬ : Finset (Finset α)) :\n    ∀ ⦃s⦄, s ⊆ u → ∀ ⦃t⦄, t ⊆ u → collapse 𝒜 a f₁ s * collapse ℬ a f₂ t ≤\n      collapse (𝒜 ⊼ ℬ) a f₃ (s ∩ t) * collapse (𝒜 ⊻ ℬ) a f₄ (s ∪ t) := by\n  rintro s hsu t htu\n  -- Gather a bunch of facts we'll need a lot\n  have := hsu.trans <| subset_insert a _\n  have := htu.trans <| subset_insert a _\n  have := insert_subset_insert a hsu\n  have := insert_subset_insert a htu\n  have has := not_mem_mono hsu hu\n  have hat := not_mem_mono htu hu\n  have : a ∉ s ∩ t := not_mem_mono (inter_subset_left.trans hsu) hu\n  have := not_mem_union.2 ⟨has, hat⟩\n  rw [collapse_eq has]\n  split_ifs\n  · rw [collapse_eq hat]\n    split_ifs\n    · rw [collapse_of_mem ‹_› (inter_mem_infs ‹_› ‹_›) (inter_mem_infs ‹_› ‹_›) rfl\n        (insert_inter_distrib _ _ _).symm, collapse_of_mem ‹_› (union_mem_sups ‹_› ‹_›)\n        (union_mem_sups ‹_› ‹_›) rfl (insert_union_distrib _ _ _).symm]\n      refine ineq (h₁ _) (h₁ _) (h₂ _) (h₂ _) (h₃ _) (h₃ _) (h₄ _) (h₄ _) (h ‹_› ‹_›) ?_ ?_ ?_\n      · simpa [*] using h ‹insert a s ⊆ _› ‹t ⊆ _›\n      · simpa [*] using h ‹s ⊆ _› ‹insert a t ⊆ _›\n      · simpa [*] using h ‹insert a s ⊆ _› ‹insert a t ⊆ _›\n    · rw [add_zero, add_mul]\n      refine (add_le_add (h ‹_› ‹_›) <| h ‹_› ‹_›).trans ?_\n      rw [collapse_of_mem ‹_› (union_mem_sups ‹_› ‹_›) (union_mem_sups ‹_› ‹_›) rfl\n        (insert_union _ _ _), insert_inter_of_not_mem ‹_›, ← mul_add]\n      exact mul_le_mul_of_nonneg_right (le_collapse_of_mem ‹_› h₃ rfl <| inter_mem_infs ‹_› ‹_›) <|\n        add_nonneg (h₄ _) <| h₄ _\n    · rw [zero_add, add_mul]\n      refine (add_le_add (h ‹_› ‹_›) <| h ‹_› ‹_›).trans ?_\n      rw [collapse_of_mem ‹_› (inter_mem_infs ‹_› ‹_›) (inter_mem_infs ‹_› ‹_›)\n        (inter_insert_of_not_mem ‹_›) (insert_inter_distrib _ _ _).symm, union_insert,\n        insert_union_distrib, ← add_mul]\n      exact mul_le_mul_of_nonneg_left (le_collapse_of_insert_mem ‹_› h₄\n        (insert_union_distrib _ _ _).symm <| union_mem_sups ‹_› ‹_›) <| add_nonneg (h₃ _) <| h₃ _\n    · rw [add_zero, mul_zero]\n      exact mul_nonneg (collapse_nonneg h₃ _) <| collapse_nonneg h₄ _\n  · rw [add_zero, collapse_eq hat, mul_add]\n    split_ifs\n    · refine (add_le_add (h ‹_› ‹_›) <| h ‹_› ‹_›).trans ?_\n      rw [collapse_of_mem ‹_› (union_mem_sups ‹_› ‹_›) (union_mem_sups ‹_› ‹_›) rfl\n        (union_insert _ _ _), inter_insert_of_not_mem ‹_›, ← mul_add]\n      exact mul_le_mul_of_nonneg_right (le_collapse_of_mem ‹_› h₃ rfl <| inter_mem_infs ‹_› ‹_›) <|\n        add_nonneg (h₄ _) <| h₄ _\n    · rw [mul_zero, add_zero]\n      exact (h ‹_› ‹_›).trans <| mul_le_mul (le_collapse_of_mem ‹_› h₃ rfl <|\n        inter_mem_infs ‹_› ‹_›) (le_collapse_of_mem ‹_› h₄ rfl <| union_mem_sups ‹_› ‹_›)\n        (h₄ _) <| collapse_nonneg h₃ _\n    · rw [mul_zero, zero_add]\n      refine (h ‹_› ‹_›).trans <| mul_le_mul ?_ (le_collapse_of_insert_mem ‹_› h₄\n        (union_insert _ _ _) <| union_mem_sups ‹_› ‹_›) (h₄ _) <| collapse_nonneg h₃ _\n      exact le_collapse_of_mem (not_mem_mono inter_subset_left ‹_›) h₃\n        (inter_insert_of_not_mem ‹_›) <| inter_mem_infs ‹_› ‹_›\n    · simp_rw [mul_zero, add_zero]\n      exact mul_nonneg (collapse_nonneg h₃ _) <| collapse_nonneg h₄ _\n  · rw [zero_add, collapse_eq hat, mul_add]\n    split_ifs\n    · refine (add_le_add (h ‹_› ‹_›) <| h ‹_› ‹_›).trans ?_\n      rw [collapse_of_mem ‹_› (inter_mem_infs ‹_› ‹_›) (inter_mem_infs ‹_› ‹_›)\n        (insert_inter_of_not_mem ‹_›) (insert_inter_distrib _ _ _).symm,\n        insert_inter_of_not_mem ‹_›, ← insert_inter_distrib, insert_union, insert_union_distrib,\n        ← add_mul]\n      exact mul_le_mul_of_nonneg_left (le_collapse_of_insert_mem ‹_› h₄\n        (insert_union_distrib _ _ _).symm <| union_mem_sups ‹_› ‹_›) <| add_nonneg (h₃ _) <| h₃ _\n    · rw [mul_zero, add_zero]\n      refine (h ‹_› ‹_›).trans <| mul_le_mul (le_collapse_of_mem ‹_› h₃\n        (insert_inter_of_not_mem ‹_›) <| inter_mem_infs ‹_› ‹_›) (le_collapse_of_insert_mem ‹_› h₄\n        (insert_union _ _ _) <| union_mem_sups ‹_› ‹_›) (h₄ _) <| collapse_nonneg h₃ _\n    · rw [mul_zero, zero_add]\n      exact (h ‹_› ‹_›).trans <| mul_le_mul (le_collapse_of_insert_mem ‹_› h₃\n        (insert_inter_distrib _ _ _).symm <| inter_mem_infs ‹_› ‹_›) (le_collapse_of_insert_mem ‹_›\n        h₄ (insert_union_distrib _ _ _).symm <| union_mem_sups ‹_› ‹_›) (h₄ _) <|\n        collapse_nonneg h₃ _\n    · simp_rw [mul_zero, add_zero]\n      exact mul_nonneg (collapse_nonneg h₃ _) <| collapse_nonneg h₄ _\n  · simp_rw [add_zero, zero_mul]\n    exact mul_nonneg (collapse_nonneg h₃ _) <| collapse_nonneg h₄ _\n\n"}
{"name":"sum_collapse","module":"Mathlib.Combinatorics.SetFamily.FourFunctions","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : LinearOrderedCommSemiring β\n𝒜 : Finset (Finset α)\na : α\nf : Finset α → β\nu : Finset α\nh𝒜 : HasSubset.Subset 𝒜 (Insert.insert a u).powerset\nhu : Not (Membership.mem u a)\n⊢ Eq (u.powerset.sum fun s => collapse 𝒜 a f s) (𝒜.sum fun s => f s)","decl":"lemma sum_collapse (h𝒜 : 𝒜 ⊆ (insert a u).powerset) (hu : a ∉ u) :\n    ∑ s ∈ u.powerset, collapse 𝒜 a f s = ∑ s ∈ 𝒜, f s := by\n  calc\n    _ = ∑ s ∈ u.powerset ∩ 𝒜, f s + ∑ s ∈ u.powerset.image (insert a) ∩ 𝒜, f s := ?_\n    _ = ∑ s ∈ u.powerset ∩ 𝒜, f s + ∑ s ∈ ((insert a u).powerset \\ u.powerset) ∩ 𝒜, f s := ?_\n    _ = ∑ s ∈ 𝒜, f s := ?_\n  · rw [← Finset.sum_ite_mem, ← Finset.sum_ite_mem, sum_image, ← sum_add_distrib]\n    · exact sum_congr rfl fun s hs ↦ collapse_eq (not_mem_mono (mem_powerset.1 hs) hu) _ _\n    · exact (insert_erase_invOn.2.injOn).mono fun s hs ↦ not_mem_mono (mem_powerset.1 hs) hu\n  · congr with s\n    simp only [mem_image, mem_powerset, mem_sdiff, subset_insert_iff]\n    refine ⟨?_, fun h ↦ ⟨_, h.1, ?_⟩⟩\n    · rintro ⟨s, hs, rfl⟩\n      exact ⟨subset_insert_iff.1 <| insert_subset_insert _ hs, fun h ↦\n        hu <| h <| mem_insert_self _ _⟩\n    · rw [insert_erase (erase_ne_self.1 fun hs ↦ ?_)]\n      rw [hs] at h\n      exact h.2 h.1\n  · rw [← sum_union (disjoint_sdiff_self_right.mono inf_le_left inf_le_left),\n      ← union_inter_distrib_right, union_sdiff_of_subset (powerset_mono.2 <| subset_insert _ _),\n      inter_eq_right.2 h𝒜]\n\n"}
{"name":"Finset.four_functions_theorem","module":"Mathlib.Combinatorics.SetFamily.FourFunctions","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : DecidableEq α\ninst✝¹ : LinearOrderedCommSemiring β\nf₁ f₂ f₃ f₄ : Finset α → β\ninst✝ : ExistsAddOfLE β\nu : Finset α\nh₁ : LE.le 0 f₁\nh₂ : LE.le 0 f₂\nh₃ : LE.le 0 f₃\nh₄ : LE.le 0 f₄\nh : ∀ ⦃s : Finset α⦄, HasSubset.Subset s u → ∀ ⦃t : Finset α⦄, HasSubset.Subset t u → LE.le (HMul.hMul (f₁ s) (f₂ t)) (HMul.hMul (f₃ (Inter.inter s t)) (f₄ (Union.union s t)))\n𝒜 ℬ : Finset (Finset α)\nh𝒜 : HasSubset.Subset 𝒜 u.powerset\nhℬ : HasSubset.Subset ℬ u.powerset\n⊢ LE.le (HMul.hMul (𝒜.sum fun s => f₁ s) (ℬ.sum fun s => f₂ s)) (HMul.hMul ((HasInfs.infs 𝒜 ℬ).sum fun s => f₃ s) ((HasSups.sups 𝒜 ℬ).sum fun s => f₄ s))","decl":"/-- The **Four Functions Theorem** on a powerset algebra. See `four_functions_theorem` for the\nfinite distributive lattice generalisation. -/\nprotected lemma Finset.four_functions_theorem (u : Finset α)\n    (h₁ : 0 ≤ f₁) (h₂ : 0 ≤ f₂) (h₃ : 0 ≤ f₃) (h₄ : 0 ≤ f₄)\n    (h : ∀ ⦃s⦄, s ⊆ u → ∀ ⦃t⦄, t ⊆ u → f₁ s * f₂ t ≤ f₃ (s ∩ t) * f₄ (s ∪ t))\n    {𝒜 ℬ : Finset (Finset α)} (h𝒜 : 𝒜 ⊆ u.powerset) (hℬ : ℬ ⊆ u.powerset) :\n    (∑ s ∈ 𝒜, f₁ s) * ∑ s ∈ ℬ, f₂ s ≤ (∑ s ∈ 𝒜 ⊼ ℬ, f₃ s) * ∑ s ∈ 𝒜 ⊻ ℬ, f₄ s := by\n  induction' u using Finset.induction with a u hu ih generalizing f₁ f₂ f₃ f₄ 𝒜 ℬ\n  · simp only [Finset.powerset_empty, Finset.subset_singleton_iff] at h𝒜 hℬ\n    obtain rfl | rfl := h𝒜 <;> obtain rfl | rfl := hℬ <;> simp; exact h (subset_refl ∅) subset_rfl\n  specialize ih (collapse_nonneg h₁) (collapse_nonneg h₂) (collapse_nonneg h₃) (collapse_nonneg h₄)\n    (collapse_modular hu h₁ h₂ h₃ h₄ h 𝒜 ℬ) Subset.rfl Subset.rfl\n  have : 𝒜 ⊼ ℬ ⊆ powerset (insert a u) := by simpa using infs_subset h𝒜 hℬ\n  have : 𝒜 ⊻ ℬ ⊆ powerset (insert a u) := by simpa using sups_subset h𝒜 hℬ\n  simpa only [powerset_sups_powerset_self, powerset_infs_powerset_self, sum_collapse,\n    not_false_eq_true, *] using ih\n\n"}
{"name":"four_functions_theorem","module":"Mathlib.Combinatorics.SetFamily.FourFunctions","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : DistribLattice α\ninst✝² : LinearOrderedCommSemiring β\ninst✝¹ : ExistsAddOfLE β\nf₁ f₂ f₃ f₄ : α → β\ninst✝ : DecidableEq α\nh₁ : LE.le 0 f₁\nh₂ : LE.le 0 f₂\nh₃ : LE.le 0 f₃\nh₄ : LE.le 0 f₄\nh : ∀ (a b : α), LE.le (HMul.hMul (f₁ a) (f₂ b)) (HMul.hMul (f₃ (Min.min a b)) (f₄ (Max.max a b)))\ns t : Finset α\n⊢ LE.le (HMul.hMul (s.sum fun a => f₁ a) (t.sum fun a => f₂ a)) (HMul.hMul ((HasInfs.infs s t).sum fun a => f₃ a) ((HasSups.sups s t).sum fun a => f₄ a))","decl":"/-- The **Four Functions Theorem**, aka **Ahlswede-Daykin Inequality**. -/\nlemma four_functions_theorem [DecidableEq α] (h₁ : 0 ≤ f₁) (h₂ : 0 ≤ f₂) (h₃ : 0 ≤ f₃) (h₄ : 0 ≤ f₄)\n    (h : ∀ a b, f₁ a * f₂ b ≤ f₃ (a ⊓ b) * f₄ (a ⊔ b)) (s t : Finset α) :\n    (∑ a ∈ s, f₁ a) * ∑ a ∈ t, f₂ a ≤ (∑ a ∈ s ⊼ t, f₃ a) * ∑ a ∈ s ⊻ t, f₄ a := by\n  classical\n  set L : Sublattice α := ⟨latticeClosure (s ∪ t), isSublattice_latticeClosure.1,\n    isSublattice_latticeClosure.2⟩\n  have : Finite L := (s.finite_toSet.union t.finite_toSet).latticeClosure.to_subtype\n  set s' : Finset L := s.preimage (↑) Subtype.coe_injective.injOn\n  set t' : Finset L := t.preimage (↑) Subtype.coe_injective.injOn\n  have hs' : s'.map ⟨L.subtype, Subtype.coe_injective⟩ = s := by\n    simp [s', map_eq_image, image_preimage, filter_eq_self]\n    exact fun a ha ↦ subset_latticeClosure <| Set.subset_union_left ha\n  have ht' : t'.map ⟨L.subtype, Subtype.coe_injective⟩ = t := by\n    simp [t', map_eq_image, image_preimage, filter_eq_self]\n    exact fun a ha ↦ subset_latticeClosure <| Set.subset_union_right ha\n  clear_value s' t'\n  obtain ⟨β, _, _, g, hg⟩ := exists_birkhoff_representation L\n  have := four_functions_theorem_aux (extend g (f₁ ∘ (↑)) 0) (extend g (f₂ ∘ (↑)) 0)\n    (extend g (f₃ ∘ (↑)) 0) (extend g (f₄ ∘ (↑)) 0) (extend_nonneg (fun _ ↦ h₁ _) le_rfl)\n    (extend_nonneg (fun _ ↦ h₂ _) le_rfl) (extend_nonneg (fun _ ↦ h₃ _) le_rfl)\n    (extend_nonneg (fun _ ↦ h₄ _) le_rfl) ?_ (s'.map ⟨g, hg⟩) (t'.map ⟨g, hg⟩)\n  · simpa only [← hs', ← ht', ← map_sups, ← map_infs, sum_map, Embedding.coeFn_mk, hg.extend_apply]\n      using this\n  rintro s t\n  classical\n  obtain ⟨a, rfl⟩ | hs := em (∃ a, g a = s)\n  · obtain ⟨b, rfl⟩ | ht := em (∃ b, g b = t)\n    · simp_rw [← sup_eq_union, ← inf_eq_inter, ← map_sup, ← map_inf, hg.extend_apply]\n      exact h _ _\n    · simpa [extend_apply' _ _ _ ht] using mul_nonneg\n        (extend_nonneg (fun a : L ↦ h₃ a) le_rfl _) (extend_nonneg (fun a : L ↦ h₄ a) le_rfl _)\n  · simpa [extend_apply' _ _ _ hs] using mul_nonneg\n      (extend_nonneg (fun a : L ↦ h₃ a) le_rfl _) (extend_nonneg (fun a : L ↦ h₄ a) le_rfl _)\n\n"}
{"name":"Finset.le_card_infs_mul_card_sups","module":"Mathlib.Combinatorics.SetFamily.FourFunctions","initialProofState":"α : Type u_1\ninst✝¹ : DistribLattice α\ninst✝ : DecidableEq α\ns t : Finset α\n⊢ LE.le (HMul.hMul s.card t.card) (HMul.hMul (HasInfs.infs s t).card (HasSups.sups s t).card)","decl":"/-- An inequality of Daykin. Interestingly, any lattice in which this inequality holds is\ndistributive. -/\nlemma Finset.le_card_infs_mul_card_sups [DecidableEq α] (s t : Finset α) :\n    #s * #t ≤ #(s ⊼ t) * #(s ⊻ t) := by\n  simpa using four_functions_theorem (1 : α → ℕ) 1 1 1 zero_le_one zero_le_one zero_le_one\n    zero_le_one (fun _ _ ↦ le_rfl) s t\n\n"}
{"name":"four_functions_theorem_univ","module":"Mathlib.Combinatorics.SetFamily.FourFunctions","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : DistribLattice α\ninst✝² : LinearOrderedCommSemiring β\ninst✝¹ : ExistsAddOfLE β\nf₁ f₂ f₃ f₄ : α → β\ninst✝ : Fintype α\nh₁ : LE.le 0 f₁\nh₂ : LE.le 0 f₂\nh₃ : LE.le 0 f₃\nh₄ : LE.le 0 f₄\nh : ∀ (a b : α), LE.le (HMul.hMul (f₁ a) (f₂ b)) (HMul.hMul (f₃ (Min.min a b)) (f₄ (Max.max a b)))\n⊢ LE.le (HMul.hMul (Finset.univ.sum fun a => f₁ a) (Finset.univ.sum fun a => f₂ a)) (HMul.hMul (Finset.univ.sum fun a => f₃ a) (Finset.univ.sum fun a => f₄ a))","decl":"/-- Special case of the **Four Functions Theorem** when `s = t = univ`. -/\nlemma four_functions_theorem_univ (h₁ : 0 ≤ f₁) (h₂ : 0 ≤ f₂) (h₃ : 0 ≤ f₃) (h₄ : 0 ≤ f₄)\n    (h : ∀ a b, f₁ a * f₂ b ≤ f₃ (a ⊓ b) * f₄ (a ⊔ b)) :\n    (∑ a, f₁ a) * ∑ a, f₂ a ≤ (∑ a, f₃ a) * ∑ a, f₄ a := by\n  classical simpa using four_functions_theorem f₁ f₂ f₃ f₄ h₁ h₂ h₃ h₄ h univ univ\n\n"}
{"name":"holley","module":"Mathlib.Combinatorics.SetFamily.FourFunctions","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : DistribLattice α\ninst✝² : LinearOrderedCommSemiring β\ninst✝¹ : ExistsAddOfLE β\nf g μ : α → β\ninst✝ : Fintype α\nhμ₀ : LE.le 0 μ\nhf : LE.le 0 f\nhg : LE.le 0 g\nhμ : Monotone μ\nhfg : Eq (Finset.univ.sum fun a => f a) (Finset.univ.sum fun a => g a)\nh : ∀ (a b : α), LE.le (HMul.hMul (f a) (g b)) (HMul.hMul (f (Min.min a b)) (g (Max.max a b)))\n⊢ LE.le (Finset.univ.sum fun a => HMul.hMul (μ a) (f a)) (Finset.univ.sum fun a => HMul.hMul (μ a) (g a))","decl":"/-- The **Holley Inequality**. -/\nlemma holley (hμ₀ : 0 ≤ μ) (hf : 0 ≤ f) (hg : 0 ≤ g) (hμ : Monotone μ)\n    (hfg : ∑ a, f a = ∑ a, g a) (h : ∀ a b, f a * g b ≤ f (a ⊓ b) * g (a ⊔ b)) :\n    ∑ a, μ a * f a ≤ ∑ a, μ a * g a := by\n  classical\n  obtain rfl | hf := hf.eq_or_lt\n  · simp only [Pi.zero_apply, sum_const_zero, eq_comm, Fintype.sum_eq_zero_iff_of_nonneg hg] at hfg\n    simp [hfg]\n  obtain rfl | hg := hg.eq_or_lt\n  · simp only [Pi.zero_apply, sum_const_zero, Fintype.sum_eq_zero_iff_of_nonneg hf.le] at hfg\n    simp [hfg]\n  have := four_functions_theorem g (μ * f) f (μ * g) hg.le (mul_nonneg hμ₀ hf.le) hf.le\n    (mul_nonneg hμ₀ hg.le) (fun a b ↦ ?_) univ univ\n  · simpa [hfg, sum_pos hg] using this\n  · simp_rw [Pi.mul_apply, mul_left_comm _ (μ _), mul_comm (g _)]\n    rw [sup_comm, inf_comm]\n    exact mul_le_mul (hμ le_sup_left) (h _ _) (mul_nonneg (hf.le _) <| hg.le _) <| hμ₀ _\n\n"}
{"name":"fkg","module":"Mathlib.Combinatorics.SetFamily.FourFunctions","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : DistribLattice α\ninst✝² : LinearOrderedCommSemiring β\ninst✝¹ : ExistsAddOfLE β\nf g μ : α → β\ninst✝ : Fintype α\nhμ₀ : LE.le 0 μ\nhf₀ : LE.le 0 f\nhg₀ : LE.le 0 g\nhf : Monotone f\nhg : Monotone g\nhμ : ∀ (a b : α), LE.le (HMul.hMul (μ a) (μ b)) (HMul.hMul (μ (Min.min a b)) (μ (Max.max a b)))\n⊢ LE.le (HMul.hMul (Finset.univ.sum fun a => HMul.hMul (μ a) (f a)) (Finset.univ.sum fun a => HMul.hMul (μ a) (g a))) (HMul.hMul (Finset.univ.sum fun a => μ a) (Finset.univ.sum fun a => HMul.hMul (μ a) (HMul.hMul (f a) (g a))))","decl":"/-- The **Fortuin-Kastelyn-Ginibre Inequality**. -/\nlemma fkg (hμ₀ : 0 ≤ μ) (hf₀ : 0 ≤ f) (hg₀ : 0 ≤ g) (hf : Monotone f) (hg : Monotone g)\n    (hμ : ∀ a b, μ a * μ b ≤ μ (a ⊓ b) * μ (a ⊔ b)) :\n    (∑ a, μ a * f a) * ∑ a, μ a * g a ≤ (∑ a, μ a) * ∑ a, μ a * (f a * g a) := by\n  refine four_functions_theorem_univ (μ * f) (μ * g) μ _ (mul_nonneg hμ₀ hf₀) (mul_nonneg hμ₀ hg₀)\n    hμ₀ (mul_nonneg hμ₀ <| mul_nonneg hf₀ hg₀) (fun a b ↦ ?_)\n  dsimp\n  rw [mul_mul_mul_comm, ← mul_assoc (μ (a ⊓ b))]\n  exact mul_le_mul (hμ _ _) (mul_le_mul (hf le_sup_left) (hg le_sup_right) (hg₀ _) <| hf₀ _)\n    (mul_nonneg (hf₀ _) <| hg₀ _) <| mul_nonneg (hμ₀ _) <| hμ₀ _\n\n"}
{"name":"Finset.le_card_diffs_mul_card_diffs","module":"Mathlib.Combinatorics.SetFamily.FourFunctions","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : GeneralizedBooleanAlgebra α\ns t : Finset α\n⊢ LE.le (HMul.hMul s.card t.card) (HMul.hMul (s.diffs t).card (t.diffs s).card)","decl":"/-- A slight generalisation of the **Marica-Schönheim Inequality**. -/\nlemma Finset.le_card_diffs_mul_card_diffs (s t : Finset α) :\n    #s * #t ≤ #(s \\\\ t) * #(t \\\\ s) := by\n  have : ∀ s t : Finset α, (s \\\\ t).map ⟨_, liftLatticeHom_injective⟩ =\n      s.map ⟨_, liftLatticeHom_injective⟩ \\\\ t.map ⟨_, liftLatticeHom_injective⟩ := by\n    rintro s t\n    simp_rw [map_eq_image]\n    exact image_image₂_distrib fun a b ↦ rfl\n  simpa [← card_compls (_ ⊻ _), ← map_sup, ← map_inf, ← this] using\n    (s.map ⟨_, liftLatticeHom_injective⟩).le_card_infs_mul_card_sups\n      (t.map ⟨_, liftLatticeHom_injective⟩)ᶜˢ\n\n"}
{"name":"Finset.card_le_card_diffs","module":"Mathlib.Combinatorics.SetFamily.FourFunctions","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : GeneralizedBooleanAlgebra α\ns : Finset α\n⊢ LE.le s.card (s.diffs s).card","decl":"/-- The **Marica-Schönheim Inequality**. -/\nlemma Finset.card_le_card_diffs (s : Finset α) : #s ≤ #(s \\\\ s) :=\n  le_of_pow_le_pow_left₀ two_ne_zero (zero_le _) <| by\n    simpa [← sq] using s.le_card_diffs_mul_card_diffs s\n"}
