{"name":"LinearMap.conjugate_apply","module":"Mathlib.RepresentationTheory.Maschke","initialProofState":"k : Type u\ninst✝⁹ : CommRing k\nG : Type u\ninst✝⁸ : Group G\nV : Type v\ninst✝⁷ : AddCommGroup V\ninst✝⁶ : Module k V\ninst✝⁵ : Module (MonoidAlgebra k G) V\ninst✝⁴ : IsScalarTower k (MonoidAlgebra k G) V\nW : Type w\ninst✝³ : AddCommGroup W\ninst✝² : Module k W\ninst✝¹ : Module (MonoidAlgebra k G) W\ninst✝ : IsScalarTower k (MonoidAlgebra k G) W\nπ : LinearMap (RingHom.id k) W V\ng : G\nv : W\n⊢ Eq ((π.conjugate g) v) (HSMul.hSMul (MonoidAlgebra.single (Inv.inv g) 1) (π (HSMul.hSMul (MonoidAlgebra.single g 1) v)))","decl":"theorem conjugate_apply (g : G) (v : W) :\n    π.conjugate g v = MonoidAlgebra.single g⁻¹ (1 : k) • π (MonoidAlgebra.single g (1 : k) • v) :=\n  rfl\n\n"}
{"name":"LinearMap.conjugate_i","module":"Mathlib.RepresentationTheory.Maschke","initialProofState":"k : Type u\ninst✝⁹ : CommRing k\nG : Type u\ninst✝⁸ : Group G\nV : Type v\ninst✝⁷ : AddCommGroup V\ninst✝⁶ : Module k V\ninst✝⁵ : Module (MonoidAlgebra k G) V\ninst✝⁴ : IsScalarTower k (MonoidAlgebra k G) V\nW : Type w\ninst✝³ : AddCommGroup W\ninst✝² : Module k W\ninst✝¹ : Module (MonoidAlgebra k G) W\ninst✝ : IsScalarTower k (MonoidAlgebra k G) W\nπ : LinearMap (RingHom.id k) W V\ni : LinearMap (RingHom.id (MonoidAlgebra k G)) V W\nh : ∀ (v : V), Eq (π (i v)) v\ng : G\nv : V\n⊢ Eq ((π.conjugate g) (i v)) v","decl":"theorem conjugate_i (h : ∀ v : V, π (i v) = v) (g : G) (v : V) :\n    (conjugate π g : W → V) (i v) = v := by\n  rw [conjugate_apply, ← i.map_smul, h, ← mul_smul, single_mul_single, mul_one, inv_mul_cancel,\n    ← one_def, one_smul]\n\n"}
{"name":"LinearMap.sumOfConjugates_apply","module":"Mathlib.RepresentationTheory.Maschke","initialProofState":"k : Type u\ninst✝¹⁰ : CommRing k\nG : Type u\ninst✝⁹ : Group G\nV : Type v\ninst✝⁸ : AddCommGroup V\ninst✝⁷ : Module k V\ninst✝⁶ : Module (MonoidAlgebra k G) V\ninst✝⁵ : IsScalarTower k (MonoidAlgebra k G) V\nW : Type w\ninst✝⁴ : AddCommGroup W\ninst✝³ : Module k W\ninst✝² : Module (MonoidAlgebra k G) W\ninst✝¹ : IsScalarTower k (MonoidAlgebra k G) W\nπ : LinearMap (RingHom.id k) W V\ninst✝ : Fintype G\nv : W\n⊢ Eq ((LinearMap.sumOfConjugates G π) v) (Finset.univ.sum fun g => (π.conjugate g) v)","decl":"lemma sumOfConjugates_apply (v : W) : π.sumOfConjugates G v = ∑ g : G, π.conjugate g v :=\n  LinearMap.sum_apply _ _ _\n\n"}
{"name":"LinearMap.sumOfConjugatesEquivariant_apply","module":"Mathlib.RepresentationTheory.Maschke","initialProofState":"k : Type u\ninst✝¹⁰ : CommRing k\nG : Type u\ninst✝⁹ : Group G\nV : Type v\ninst✝⁸ : AddCommGroup V\ninst✝⁷ : Module k V\ninst✝⁶ : Module (MonoidAlgebra k G) V\ninst✝⁵ : IsScalarTower k (MonoidAlgebra k G) V\nW : Type w\ninst✝⁴ : AddCommGroup W\ninst✝³ : Module k W\ninst✝² : Module (MonoidAlgebra k G) W\ninst✝¹ : IsScalarTower k (MonoidAlgebra k G) W\nπ : LinearMap (RingHom.id k) W V\ninst✝ : Fintype G\nv : W\n⊢ Eq ((LinearMap.sumOfConjugatesEquivariant G π) v) (Finset.univ.sum fun g => (π.conjugate g) v)","decl":"theorem sumOfConjugatesEquivariant_apply (v : W) :\n    π.sumOfConjugatesEquivariant G v = ∑ g : G, π.conjugate g v :=\n  π.sumOfConjugates_apply G v\n\n"}
{"name":"LinearMap.equivariantProjection_apply","module":"Mathlib.RepresentationTheory.Maschke","initialProofState":"k : Type u\ninst✝¹⁰ : CommRing k\nG : Type u\ninst✝⁹ : Group G\nV : Type v\ninst✝⁸ : AddCommGroup V\ninst✝⁷ : Module k V\ninst✝⁶ : Module (MonoidAlgebra k G) V\ninst✝⁵ : IsScalarTower k (MonoidAlgebra k G) V\nW : Type w\ninst✝⁴ : AddCommGroup W\ninst✝³ : Module k W\ninst✝² : Module (MonoidAlgebra k G) W\ninst✝¹ : IsScalarTower k (MonoidAlgebra k G) W\nπ : LinearMap (RingHom.id k) W V\ninst✝ : Fintype G\nv : W\n⊢ Eq ((LinearMap.equivariantProjection G π) v) (HSMul.hSMul (Ring.inverse ↑(Fintype.card G)) (Finset.univ.sum fun g => (π.conjugate g) v))","decl":"theorem equivariantProjection_apply (v : W) :\n    π.equivariantProjection G v = Ring.inverse (Fintype.card G : k) • ∑ g : G, π.conjugate g v := by\n  simp only [equivariantProjection, smul_apply, sumOfConjugatesEquivariant_apply]\n\n"}
{"name":"LinearMap.equivariantProjection_condition","module":"Mathlib.RepresentationTheory.Maschke","initialProofState":"k : Type u\ninst✝¹⁰ : CommRing k\nG : Type u\ninst✝⁹ : Group G\nV : Type v\ninst✝⁸ : AddCommGroup V\ninst✝⁷ : Module k V\ninst✝⁶ : Module (MonoidAlgebra k G) V\ninst✝⁵ : IsScalarTower k (MonoidAlgebra k G) V\nW : Type w\ninst✝⁴ : AddCommGroup W\ninst✝³ : Module k W\ninst✝² : Module (MonoidAlgebra k G) W\ninst✝¹ : IsScalarTower k (MonoidAlgebra k G) W\nπ : LinearMap (RingHom.id k) W V\ni : LinearMap (RingHom.id (MonoidAlgebra k G)) V W\ninst✝ : Fintype G\nhcard : IsUnit ↑(Fintype.card G)\nh : ∀ (v : V), Eq (π (i v)) v\nv : V\n⊢ Eq ((LinearMap.equivariantProjection G π) (i v)) v","decl":"theorem equivariantProjection_condition (hcard : IsUnit (Fintype.card G : k))\n    (h : ∀ v : V, π (i v) = v) (v : V) : (π.equivariantProjection G) (i v) = v := by\n  rw [equivariantProjection_apply]\n  simp only [conjugate_i π i h]\n  rw [Finset.sum_const, Finset.card_univ, ← Nat.cast_smul_eq_nsmul k, smul_smul,\n    Ring.inverse_mul_cancel _ hcard, one_smul]\n\n"}
{"name":"MonoidAlgebra.exists_leftInverse_of_injective","module":"Mathlib.RepresentationTheory.Maschke","initialProofState":"k : Type u\ninst✝⁷ : Field k\nG : Type u\ninst✝⁶ : Fintype G\ninst✝⁵ : NeZero ↑(Fintype.card G)\ninst✝⁴ : Group G\nV : Type u\ninst✝³ : AddCommGroup V\ninst✝² : Module (MonoidAlgebra k G) V\nW : Type u\ninst✝¹ : AddCommGroup W\ninst✝ : Module (MonoidAlgebra k G) W\nf : LinearMap (RingHom.id (MonoidAlgebra k G)) V W\nhf : Eq (LinearMap.ker f) Bot.bot\n⊢ Exists fun g => Eq (g.comp f) LinearMap.id","decl":"theorem exists_leftInverse_of_injective\n    (f : V →ₗ[MonoidAlgebra k G] W) (hf : LinearMap.ker f = ⊥) :\n    ∃ g : W →ₗ[MonoidAlgebra k G] V, g.comp f = LinearMap.id := by\n  let A := MonoidAlgebra k G\n  letI : Module k W := .compHom W (algebraMap k A)\n  letI : Module k V := .compHom V (algebraMap k A)\n  have := IsScalarTower.of_compHom k A W\n  have := IsScalarTower.of_compHom k A V\n  obtain ⟨φ, hφ⟩ := (f.restrictScalars k).exists_leftInverse_of_injective <| by\n    simp only [hf, Submodule.restrictScalars_bot, LinearMap.ker_restrictScalars]\n  refine ⟨φ.equivariantProjection G, DFunLike.ext _ _ ?_⟩\n  exact φ.equivariantProjection_condition G _ (.mk0 _ <| NeZero.ne _) <| DFunLike.congr_fun hφ\n\n"}
{"name":"MonoidAlgebra.Submodule.exists_isCompl","module":"Mathlib.RepresentationTheory.Maschke","initialProofState":"k : Type u\ninst✝⁵ : Field k\nG : Type u\ninst✝⁴ : Fintype G\ninst✝³ : NeZero ↑(Fintype.card G)\ninst✝² : Group G\nV : Type u\ninst✝¹ : AddCommGroup V\ninst✝ : Module (MonoidAlgebra k G) V\np : Submodule (MonoidAlgebra k G) V\n⊢ Exists fun q => IsCompl p q","decl":"theorem exists_isCompl (p : Submodule (MonoidAlgebra k G) V) :\n    ∃ q : Submodule (MonoidAlgebra k G) V, IsCompl p q := by\n  rcases MonoidAlgebra.exists_leftInverse_of_injective p.subtype p.ker_subtype with ⟨f, hf⟩\n  exact ⟨LinearMap.ker f, LinearMap.isCompl_of_proj <| DFunLike.congr_fun hf⟩\n\n"}
{"name":"MonoidAlgebra.Submodule.complementedLattice","module":"Mathlib.RepresentationTheory.Maschke","initialProofState":"k : Type u\ninst✝⁵ : Field k\nG : Type u\ninst✝⁴ : Fintype G\ninst✝³ : NeZero ↑(Fintype.card G)\ninst✝² : Group G\nV : Type u\ninst✝¹ : AddCommGroup V\ninst✝ : Module (MonoidAlgebra k G) V\n⊢ ComplementedLattice (Submodule (MonoidAlgebra k G) V)","decl":"/-- This also implies instances `IsSemisimpleModule (MonoidAlgebra k G) V` and\n`IsSemisimpleRing (MonoidAlgebra k G)`. -/\ninstance complementedLattice : ComplementedLattice (Submodule (MonoidAlgebra k G) V) :=\n  ⟨exists_isCompl⟩\n\n"}
{"name":"MonoidAlgebra.Submodule.instIsSemisimpleRingAddMonoidAlgebra","module":"Mathlib.RepresentationTheory.Maschke","initialProofState":"k : Type u\ninst✝² : Field k\nG : Type u\ninst✝¹ : Fintype G\ninst✝ : AddGroup G\n⊢ IsSemisimpleRing (AddMonoidAlgebra k G)","decl":"instance [AddGroup G] : IsSemisimpleRing (AddMonoidAlgebra k G) :=\n  haveI : NeZero (Fintype.card (Multiplicative G) : k) := by\n    rwa [Fintype.card_congr Multiplicative.toAdd]\n  (AddMonoidAlgebra.toMultiplicativeAlgEquiv k G (R := ℕ)).toRingEquiv.symm.isSemisimpleRing\n\n"}
