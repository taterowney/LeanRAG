{"name":"lucas_primality","module":"Mathlib.NumberTheory.LucasPrimality","initialProofState":"p : Nat\na : ZMod p\nha : Eq (HPow.hPow a (HSub.hSub p 1)) 1\nhd : ∀ (q : Nat), Nat.Prime q → Dvd.dvd q (HSub.hSub p 1) → Ne (HPow.hPow a (HDiv.hDiv (HSub.hSub p 1) q)) 1\n⊢ Nat.Prime p","decl":"/-- If `a^(p-1) = 1 mod p`, but `a^((p-1)/q) ≠ 1 mod p` for all prime factors `q` of `p-1`, then `p`\nis prime. This is true because `a` has order `p-1` in the multiplicative group mod `p`, so this\ngroup must itself have order `p-1`, which only happens when `p` is prime.\n-/\ntheorem lucas_primality (p : ℕ) (a : ZMod p) (ha : a ^ (p - 1) = 1)\n    (hd : ∀ q : ℕ, q.Prime → q ∣ p - 1 → a ^ ((p - 1) / q) ≠ 1) : p.Prime := by\n  have h : p ≠ 0 ∧ p ≠ 1 := by\n    constructor <;> rintro rfl <;> exact hd 2 Nat.prime_two (dvd_zero _) (pow_zero _)\n  have hp1 : 1 < p := Nat.one_lt_iff_ne_zero_and_ne_one.2 h\n  have : NeZero p := ⟨h.1⟩\n  rw [Nat.prime_iff_card_units]\n  apply (Nat.card_units_zmod_lt_sub_one hp1).antisymm\n  let a' : (ZMod p)ˣ := Units.mkOfMulEqOne a _ (by rwa [← pow_succ', tsub_add_eq_add_tsub hp1])\n  calc p - 1 = orderOf a := (orderOf_eq_of_pow_and_pow_div_prime (tsub_pos_of_lt hp1) ha hd).symm\n    _ = orderOf a' := orderOf_injective (Units.coeHom _) Units.ext a'\n    _ ≤ Fintype.card (ZMod p)ˣ := orderOf_le_card_univ\n\n"}
{"name":"reverse_lucas_primality","module":"Mathlib.NumberTheory.LucasPrimality","initialProofState":"p : Nat\nhP : Nat.Prime p\n⊢ Exists fun a => And (Eq (HPow.hPow a (HSub.hSub p 1)) 1) (∀ (q : Nat), Nat.Prime q → Dvd.dvd q (HSub.hSub p 1) → Ne (HPow.hPow a (HDiv.hDiv (HSub.hSub p 1) q)) 1)","decl":"/-- If `p` is prime, then there exists an `a` such that `a^(p-1) = 1 mod p`\nand `a^((p-1)/q) ≠ 1 mod p` for all prime factors `q` of `p-1`.\nThe multiplicative group mod `p` is cyclic, so `a` can be any generator of the group\n(which must have order `p-1`).\n-/\ntheorem reverse_lucas_primality (p : ℕ) (hP : p.Prime) :\n    ∃ a : ZMod p, a ^ (p - 1) = 1 ∧ ∀ q : ℕ, q.Prime → q ∣ p - 1 → a ^ ((p - 1) / q) ≠ 1 := by\n  have : Fact p.Prime := ⟨hP⟩\n  obtain ⟨g, hg⟩ := IsCyclic.exists_generator (α := (ZMod p)ˣ)\n  have h1 : orderOf g = p - 1 := by\n    rwa [orderOf_eq_card_of_forall_mem_zpowers hg, Nat.card_eq_fintype_card,\n      ← Nat.prime_iff_card_units]\n  have h2 := tsub_pos_iff_lt.2 hP.one_lt\n  rw [← orderOf_injective (Units.coeHom _) Units.ext _, orderOf_eq_iff h2] at h1\n  refine ⟨g, h1.1, fun q hq hqd ↦ ?_⟩\n  replace hq := hq.one_lt\n  exact h1.2 _ (Nat.div_lt_self h2 hq) (Nat.div_pos (Nat.le_of_dvd h2 hqd) (zero_lt_one.trans hq))\n\n"}
{"name":"lucas_primality_iff","module":"Mathlib.NumberTheory.LucasPrimality","initialProofState":"p : Nat\n⊢ Iff (Nat.Prime p) (Exists fun a => And (Eq (HPow.hPow a (HSub.hSub p 1)) 1) (∀ (q : Nat), Nat.Prime q → Dvd.dvd q (HSub.hSub p 1) → Ne (HPow.hPow a (HDiv.hDiv (HSub.hSub p 1) q)) 1))","decl":"/-- A number `p` is prime if and only if there exists an `a` such that\n`a^(p-1) = 1 mod p` and `a^((p-1)/q) ≠ 1 mod p` for all prime factors `q` of `p-1`.\n-/\ntheorem lucas_primality_iff (p : ℕ) : p.Prime ↔\n    ∃ a : ZMod p, a ^ (p - 1) = 1 ∧ ∀ q : ℕ, q.Prime → q ∣ p - 1 → a ^ ((p - 1) / q) ≠ 1 :=\n  ⟨reverse_lucas_primality p, fun ⟨a, ⟨ha, hb⟩⟩ ↦ lucas_primality p a ha hb⟩\n"}
