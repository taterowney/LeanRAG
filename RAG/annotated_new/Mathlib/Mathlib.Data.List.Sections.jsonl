{"name":"List.mem_sections","module":"Mathlib.Data.List.Sections","initialProofState":"α : Type u_1\nL : List (List α)\nf : List α\n⊢ Iff (Membership.mem L.sections f) (List.Forall₂ (fun x1 x2 => Membership.mem x2 x1) f L)","decl":"theorem mem_sections {L : List (List α)} {f} : f ∈ sections L ↔ Forall₂ (· ∈ ·) f L := by\n  refine ⟨fun h => ?_, fun h => ?_⟩\n  · induction L generalizing f\n    · cases mem_singleton.1 h\n      exact Forall₂.nil\n    simp only [sections, bind_eq_flatMap, mem_flatMap, mem_map] at h\n    rcases h with ⟨_, _, _, _, rfl⟩\n    simp only [*, forall₂_cons, true_and]\n  · induction' h with a l f L al fL fs\n    · simp only [sections, mem_singleton]\n    simp only [sections, bind_eq_flatMap, mem_flatMap, mem_map]\n    exact ⟨f, fs, a, al, rfl⟩\n\n"}
{"name":"List.mem_sections_length","module":"Mathlib.Data.List.Sections","initialProofState":"α : Type u_1\nL : List (List α)\nf : List α\nh : Membership.mem L.sections f\n⊢ Eq f.length L.length","decl":"theorem mem_sections_length {L : List (List α)} {f} (h : f ∈ sections L) : length f = length L :=\n  (mem_sections.1 h).length_eq\n\n"}
{"name":"List.rel_sections","module":"Mathlib.Data.List.Sections","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → β → Prop\n⊢ Relator.LiftFun (List.Forall₂ (List.Forall₂ r)) (List.Forall₂ (List.Forall₂ r)) List.sections List.sections","decl":"theorem rel_sections {r : α → β → Prop} :\n    (Forall₂ (Forall₂ r) ⇒ Forall₂ (Forall₂ r)) sections sections\n  | _, _, Forall₂.nil => Forall₂.cons Forall₂.nil Forall₂.nil\n  | _, _, Forall₂.cons h₀ h₁ =>\n    rel_flatMap (rel_sections h₁) fun _ _ hl => rel_map (fun _ _ ha => Forall₂.cons ha hl) h₀\n\n"}
