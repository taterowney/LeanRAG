{"name":"sum_Ico_le_integral_of_le","module":"Mathlib.Analysis.SumIntegralComparisons","initialProofState":"a b : Nat\nf g : Real → Real\nhab : LE.le a b\nh : ∀ (i : Nat), Membership.mem (Set.Ico a b) i → ∀ (x : Real), Membership.mem (Set.Ico ↑i ↑(HAdd.hAdd i 1)) x → LE.le (f ↑i) (g x)\nhg : MeasureTheory.IntegrableOn g (Set.Ico ↑a ↑b) MeasureTheory.MeasureSpace.volume\n⊢ LE.le ((Finset.Ico a b).sum fun i => f ↑i) (intervalIntegral (fun x => g x) (↑a) (↑b) MeasureTheory.MeasureSpace.volume)","decl":"lemma sum_Ico_le_integral_of_le\n    (hab : a ≤ b) (h : ∀ i ∈ Ico a b, ∀ x ∈ Ico (i : ℝ) (i + 1 : ℕ), f i ≤ g x)\n    (hg : IntegrableOn g (Set.Ico a b)) :\n    ∑ i ∈ Finset.Ico a b, f i ≤ ∫ x in a..b, g x := by\n  have A i (hi : i ∈ Finset.Ico a b) : IntervalIntegrable g volume i (i + 1 : ℕ) := by\n    rw [intervalIntegrable_iff_integrableOn_Ico_of_le (by simp)]\n    apply hg.mono _ le_rfl\n    rintro x ⟨hx, h'x⟩\n    simp only [Finset.mem_Ico, mem_Ico] at hi ⊢\n    exact ⟨le_trans (mod_cast hi.1) hx, h'x.trans_le (mod_cast hi.2)⟩\n  calc\n  ∑ i ∈ Finset.Ico a b, f i\n  _ = ∑ i ∈ Finset.Ico a b, (∫ x in (i : ℝ)..(i + 1 : ℕ), f i) := by simp\n  _ ≤ ∑ i ∈ Finset.Ico a b, (∫ x in (i : ℝ)..(i + 1 : ℕ), g x) := by\n    apply Finset.sum_le_sum (fun i hi ↦ ?_)\n    apply intervalIntegral.integral_mono_on_of_le_Ioo (by simp) (by simp) (A _ hi) (fun x hx ↦ ?_)\n    exact h _ (by simpa using hi) _ (Ioo_subset_Ico_self hx)\n  _ = ∫ x in a..b, g x := by\n    rw [intervalIntegral.sum_integral_adjacent_intervals_Ico (a := fun i ↦ i) hab]\n    intro i hi\n    exact A _ (by simpa using hi)\n\n"}
{"name":"integral_le_sum_Ico_of_le","module":"Mathlib.Analysis.SumIntegralComparisons","initialProofState":"a b : Nat\nf g : Real → Real\nhab : LE.le a b\nh : ∀ (i : Nat), Membership.mem (Set.Ico a b) i → ∀ (x : Real), Membership.mem (Set.Ico ↑i ↑(HAdd.hAdd i 1)) x → LE.le (g x) (f ↑i)\nhg : MeasureTheory.IntegrableOn g (Set.Ico ↑a ↑b) MeasureTheory.MeasureSpace.volume\n⊢ LE.le (intervalIntegral (fun x => g x) (↑a) (↑b) MeasureTheory.MeasureSpace.volume) ((Finset.Ico a b).sum fun i => f ↑i)","decl":"lemma integral_le_sum_Ico_of_le\n    (hab : a ≤ b) (h : ∀ i ∈ Ico a b, ∀ x ∈ Ico (i : ℝ) (i + 1 : ℕ), g x ≤ f i)\n    (hg : IntegrableOn g (Set.Ico a b)) :\n    ∫ x in a..b, g x ≤ ∑ i ∈ Finset.Ico a b, f i := by\n  convert neg_le_neg (sum_Ico_le_integral_of_le (f := -f) (g := -g) hab\n    (fun i hi x hx ↦ neg_le_neg (h i hi x hx)) hg.neg) <;> simp\n\n"}
{"name":"AntitoneOn.integral_le_sum","module":"Mathlib.Analysis.SumIntegralComparisons","initialProofState":"x₀ : Real\na : Nat\nf : Real → Real\nhf : AntitoneOn f (Set.Icc x₀ (HAdd.hAdd x₀ ↑a))\n⊢ LE.le (intervalIntegral (fun x => f x) x₀ (HAdd.hAdd x₀ ↑a) MeasureTheory.MeasureSpace.volume) ((Finset.range a).sum fun i => f (HAdd.hAdd x₀ ↑i))","decl":"theorem AntitoneOn.integral_le_sum (hf : AntitoneOn f (Icc x₀ (x₀ + a))) :\n    (∫ x in x₀..x₀ + a, f x) ≤ ∑ i ∈ Finset.range a, f (x₀ + i) := by\n  have hint : ∀ k : ℕ, k < a → IntervalIntegrable f volume (x₀ + k) (x₀ + (k + 1 : ℕ)) := by\n    intro k hk\n    refine (hf.mono ?_).intervalIntegrable\n    rw [uIcc_of_le]\n    · apply Icc_subset_Icc\n      · simp only [le_add_iff_nonneg_right, Nat.cast_nonneg]\n      · simp only [add_le_add_iff_left, Nat.cast_le, Nat.succ_le_of_lt hk]\n    · simp only [add_le_add_iff_left, Nat.cast_le, Nat.le_succ]\n  calc\n    ∫ x in x₀..x₀ + a, f x = ∑ i ∈ Finset.range a, ∫ x in x₀ + i..x₀ + (i + 1 : ℕ), f x := by\n      convert (intervalIntegral.sum_integral_adjacent_intervals hint).symm\n      simp only [Nat.cast_zero, add_zero]\n    _ ≤ ∑ i ∈ Finset.range a, ∫ _ in x₀ + i..x₀ + (i + 1 : ℕ), f (x₀ + i) := by\n      apply Finset.sum_le_sum fun i hi => ?_\n      have ia : i < a := Finset.mem_range.1 hi\n      refine intervalIntegral.integral_mono_on (by simp) (hint _ ia) (by simp) fun x hx => ?_\n      apply hf _ _ hx.1\n      · simp only [ia.le, mem_Icc, le_add_iff_nonneg_right, Nat.cast_nonneg, add_le_add_iff_left,\n          Nat.cast_le, and_self_iff]\n      · refine mem_Icc.2 ⟨le_trans (by simp) hx.1, le_trans hx.2 ?_⟩\n        simp only [add_le_add_iff_left, Nat.cast_le, Nat.succ_le_of_lt ia]\n    _ = ∑ i ∈ Finset.range a, f (x₀ + i) := by simp\n\n"}
{"name":"AntitoneOn.integral_le_sum_Ico","module":"Mathlib.Analysis.SumIntegralComparisons","initialProofState":"a b : Nat\nf : Real → Real\nhab : LE.le a b\nhf : AntitoneOn f (Set.Icc ↑a ↑b)\n⊢ LE.le (intervalIntegral (fun x => f x) (↑a) (↑b) MeasureTheory.MeasureSpace.volume) ((Finset.Ico a b).sum fun x => f ↑x)","decl":"theorem AntitoneOn.integral_le_sum_Ico (hab : a ≤ b) (hf : AntitoneOn f (Set.Icc a b)) :\n    (∫ x in a..b, f x) ≤ ∑ x ∈ Finset.Ico a b, f x := by\n  rw [(Nat.sub_add_cancel hab).symm, Nat.cast_add]\n  conv =>\n    congr\n    congr\n    · skip\n    · skip\n    rw [add_comm]\n    · skip\n    · skip\n    congr\n    congr\n    rw [← zero_add a]\n  rw [← Finset.sum_Ico_add, Nat.Ico_zero_eq_range]\n  conv =>\n    rhs\n    congr\n    · skip\n    ext\n    rw [Nat.cast_add]\n  apply AntitoneOn.integral_le_sum\n  simp only [hf, hab, Nat.cast_sub, add_sub_cancel]\n\n"}
{"name":"AntitoneOn.sum_le_integral","module":"Mathlib.Analysis.SumIntegralComparisons","initialProofState":"x₀ : Real\na : Nat\nf : Real → Real\nhf : AntitoneOn f (Set.Icc x₀ (HAdd.hAdd x₀ ↑a))\n⊢ LE.le ((Finset.range a).sum fun i => f (HAdd.hAdd x₀ ↑(HAdd.hAdd i 1))) (intervalIntegral (fun x => f x) x₀ (HAdd.hAdd x₀ ↑a) MeasureTheory.MeasureSpace.volume)","decl":"theorem AntitoneOn.sum_le_integral (hf : AntitoneOn f (Icc x₀ (x₀ + a))) :\n    (∑ i ∈ Finset.range a, f (x₀ + (i + 1 : ℕ))) ≤ ∫ x in x₀..x₀ + a, f x := by\n  have hint : ∀ k : ℕ, k < a → IntervalIntegrable f volume (x₀ + k) (x₀ + (k + 1 : ℕ)) := by\n    intro k hk\n    refine (hf.mono ?_).intervalIntegrable\n    rw [uIcc_of_le]\n    · apply Icc_subset_Icc\n      · simp only [le_add_iff_nonneg_right, Nat.cast_nonneg]\n      · simp only [add_le_add_iff_left, Nat.cast_le, Nat.succ_le_of_lt hk]\n    · simp only [add_le_add_iff_left, Nat.cast_le, Nat.le_succ]\n  calc\n    (∑ i ∈ Finset.range a, f (x₀ + (i + 1 : ℕ))) =\n        ∑ i ∈ Finset.range a, ∫ _ in x₀ + i..x₀ + (i + 1 : ℕ), f (x₀ + (i + 1 : ℕ)) := by simp\n    _ ≤ ∑ i ∈ Finset.range a, ∫ x in x₀ + i..x₀ + (i + 1 : ℕ), f x := by\n      apply Finset.sum_le_sum fun i hi => ?_\n      have ia : i + 1 ≤ a := Finset.mem_range.1 hi\n      refine intervalIntegral.integral_mono_on (by simp) (by simp) (hint _ ia) fun x hx => ?_\n      apply hf _ _ hx.2\n      · refine mem_Icc.2 ⟨le_trans (le_add_of_nonneg_right (Nat.cast_nonneg _)) hx.1,\n          le_trans hx.2 ?_⟩\n        simp only [Nat.cast_le, add_le_add_iff_left, ia]\n      · refine mem_Icc.2 ⟨le_add_of_nonneg_right (Nat.cast_nonneg _), ?_⟩\n        simp only [add_le_add_iff_left, Nat.cast_le, ia]\n    _ = ∫ x in x₀..x₀ + a, f x := by\n      convert intervalIntegral.sum_integral_adjacent_intervals hint\n      simp only [Nat.cast_zero, add_zero]\n\n"}
{"name":"AntitoneOn.sum_le_integral_Ico","module":"Mathlib.Analysis.SumIntegralComparisons","initialProofState":"a b : Nat\nf : Real → Real\nhab : LE.le a b\nhf : AntitoneOn f (Set.Icc ↑a ↑b)\n⊢ LE.le ((Finset.Ico a b).sum fun i => f ↑(HAdd.hAdd i 1)) (intervalIntegral (fun x => f x) (↑a) (↑b) MeasureTheory.MeasureSpace.volume)","decl":"theorem AntitoneOn.sum_le_integral_Ico (hab : a ≤ b) (hf : AntitoneOn f (Set.Icc a b)) :\n    (∑ i ∈ Finset.Ico a b, f (i + 1 : ℕ)) ≤ ∫ x in a..b, f x := by\n  rw [(Nat.sub_add_cancel hab).symm, Nat.cast_add]\n  conv =>\n    congr\n    congr\n    congr\n    rw [← zero_add a]\n    · skip\n    · skip\n    · skip\n    rw [add_comm]\n  rw [← Finset.sum_Ico_add, Nat.Ico_zero_eq_range]\n  conv =>\n    lhs\n    congr\n    congr\n    · skip\n    ext\n    rw [add_assoc, Nat.cast_add]\n  apply AntitoneOn.sum_le_integral\n  simp only [hf, hab, Nat.cast_sub, add_sub_cancel]\n\n"}
{"name":"MonotoneOn.sum_le_integral","module":"Mathlib.Analysis.SumIntegralComparisons","initialProofState":"x₀ : Real\na : Nat\nf : Real → Real\nhf : MonotoneOn f (Set.Icc x₀ (HAdd.hAdd x₀ ↑a))\n⊢ LE.le ((Finset.range a).sum fun i => f (HAdd.hAdd x₀ ↑i)) (intervalIntegral (fun x => f x) x₀ (HAdd.hAdd x₀ ↑a) MeasureTheory.MeasureSpace.volume)","decl":"theorem MonotoneOn.sum_le_integral (hf : MonotoneOn f (Icc x₀ (x₀ + a))) :\n    (∑ i ∈ Finset.range a, f (x₀ + i)) ≤ ∫ x in x₀..x₀ + a, f x := by\n  rw [← neg_le_neg_iff, ← Finset.sum_neg_distrib, ← intervalIntegral.integral_neg]\n  exact hf.neg.integral_le_sum\n\n"}
{"name":"MonotoneOn.sum_le_integral_Ico","module":"Mathlib.Analysis.SumIntegralComparisons","initialProofState":"a b : Nat\nf : Real → Real\nhab : LE.le a b\nhf : MonotoneOn f (Set.Icc ↑a ↑b)\n⊢ LE.le ((Finset.Ico a b).sum fun x => f ↑x) (intervalIntegral (fun x => f x) (↑a) (↑b) MeasureTheory.MeasureSpace.volume)","decl":"theorem MonotoneOn.sum_le_integral_Ico (hab : a ≤ b) (hf : MonotoneOn f (Set.Icc a b)) :\n    ∑ x ∈ Finset.Ico a b, f x ≤ ∫ x in a..b, f x := by\n  rw [← neg_le_neg_iff, ← Finset.sum_neg_distrib, ← intervalIntegral.integral_neg]\n  exact hf.neg.integral_le_sum_Ico hab\n\n"}
{"name":"MonotoneOn.integral_le_sum","module":"Mathlib.Analysis.SumIntegralComparisons","initialProofState":"x₀ : Real\na : Nat\nf : Real → Real\nhf : MonotoneOn f (Set.Icc x₀ (HAdd.hAdd x₀ ↑a))\n⊢ LE.le (intervalIntegral (fun x => f x) x₀ (HAdd.hAdd x₀ ↑a) MeasureTheory.MeasureSpace.volume) ((Finset.range a).sum fun i => f (HAdd.hAdd x₀ ↑(HAdd.hAdd i 1)))","decl":"theorem MonotoneOn.integral_le_sum (hf : MonotoneOn f (Icc x₀ (x₀ + a))) :\n    (∫ x in x₀..x₀ + a, f x) ≤ ∑ i ∈ Finset.range a, f (x₀ + (i + 1 : ℕ)) := by\n  rw [← neg_le_neg_iff, ← Finset.sum_neg_distrib, ← intervalIntegral.integral_neg]\n  exact hf.neg.sum_le_integral\n\n"}
{"name":"MonotoneOn.integral_le_sum_Ico","module":"Mathlib.Analysis.SumIntegralComparisons","initialProofState":"a b : Nat\nf : Real → Real\nhab : LE.le a b\nhf : MonotoneOn f (Set.Icc ↑a ↑b)\n⊢ LE.le (intervalIntegral (fun x => f x) (↑a) (↑b) MeasureTheory.MeasureSpace.volume) ((Finset.Ico a b).sum fun i => f ↑(HAdd.hAdd i 1))","decl":"theorem MonotoneOn.integral_le_sum_Ico (hab : a ≤ b) (hf : MonotoneOn f (Set.Icc a b)) :\n    (∫ x in a..b, f x) ≤ ∑ i ∈ Finset.Ico a b, f (i + 1 : ℕ) := by\n  rw [← neg_le_neg_iff, ← Finset.sum_neg_distrib, ← intervalIntegral.integral_neg]\n  exact hf.neg.sum_le_integral_Ico hab\n\n"}
{"name":"sum_mul_Ico_le_integral_of_monotone_antitone","module":"Mathlib.Analysis.SumIntegralComparisons","initialProofState":"a b : Nat\nf g : Real → Real\nhab : LE.le a b\nhf : MonotoneOn f (Set.Icc ↑a ↑b)\nhg : AntitoneOn g (Set.Icc (HSub.hSub (↑a) 1) (HSub.hSub (↑b) 1))\nfpos : LE.le 0 (f ↑a)\ngpos : LE.le 0 (g (HSub.hSub (↑b) 1))\n⊢ LE.le ((Finset.Ico a b).sum fun i => HMul.hMul (f ↑i) (g ↑i)) (intervalIntegral (fun x => HMul.hMul (f x) (g (HSub.hSub x 1))) (↑a) (↑b) MeasureTheory.MeasureSpace.volume)","decl":"lemma sum_mul_Ico_le_integral_of_monotone_antitone\n    (hab : a ≤ b) (hf : MonotoneOn f (Icc a b)) (hg : AntitoneOn g (Icc (a - 1) (b - 1)))\n    (fpos : 0 ≤ f a) (gpos : 0 ≤ g (b - 1)) :\n    ∑ i ∈ Finset.Ico a b, f i * g i ≤ ∫ x in a..b, f x * g (x - 1) := by\n  apply sum_Ico_le_integral_of_le (f := fun x ↦ f x * g x) hab\n  · intro i hi x hx\n    simp only [Nat.cast_add, Nat.cast_one, mem_Ico] at hx hi\n    have I0 : (i : ℝ) ≤ b - 1 := by\n      simp only [le_sub_iff_add_le]\n      norm_cast\n      omega\n    have I1 : (i : ℝ) ∈ Icc (a - 1 : ℝ) (b - 1) := by\n      simp only [mem_Icc, tsub_le_iff_right]\n      exact ⟨by norm_cast; omega, I0⟩\n    have I2 : x ∈ Icc (a : ℝ) b := by\n      refine ⟨le_trans (mod_cast hi.1) hx.1, hx.2.le.trans ?_⟩\n      norm_cast\n      omega\n    apply mul_le_mul\n    · apply hf\n      · simp only [mem_Icc, Nat.cast_le]\n        exact ⟨hi.1, hi.2.le⟩\n      · exact I2\n      · exact hx.1\n    · apply hg\n      · simp only [mem_Icc, tsub_le_iff_right, sub_add_cancel]\n        refine ⟨le_trans (mod_cast hi.1) hx.1, hx.2.le.trans ?_⟩\n        norm_cast\n        omega\n      · exact I1\n      · simpa [sub_le_iff_le_add] using hx.2.le\n    · apply gpos.trans\n      apply hg I1 (by simp [hab]) I0\n    · apply fpos.trans\n      apply hf (by simp [hab]) I2\n      exact le_trans (mod_cast hi.1) hx.1\n  · apply Integrable.mono_measure _ (Measure.restrict_mono_set _ Ico_subset_Icc_self)\n    apply Integrable.mul_of_top_left\n    · exact hf.integrableOn_isCompact isCompact_Icc\n    · apply AntitoneOn.memℒp_isCompact isCompact_Icc\n      intro x hx y hy hxy\n      apply hg\n      · simpa using hx\n      · simpa using hy\n      · simpa using hxy\n\n"}
{"name":"integral_le_sum_mul_Ico_of_antitone_monotone","module":"Mathlib.Analysis.SumIntegralComparisons","initialProofState":"a b : Nat\nf g : Real → Real\nhab : LE.le a b\nhf : AntitoneOn f (Set.Icc ↑a ↑b)\nhg : MonotoneOn g (Set.Icc (HSub.hSub (↑a) 1) (HSub.hSub (↑b) 1))\nfpos : LE.le 0 (f ↑b)\ngpos : LE.le 0 (g (HSub.hSub (↑a) 1))\n⊢ LE.le (intervalIntegral (fun x => HMul.hMul (f x) (g (HSub.hSub x 1))) (↑a) (↑b) MeasureTheory.MeasureSpace.volume) ((Finset.Ico a b).sum fun i => HMul.hMul (f ↑i) (g ↑i))","decl":"lemma integral_le_sum_mul_Ico_of_antitone_monotone\n    (hab : a ≤ b) (hf : AntitoneOn f (Icc a b)) (hg : MonotoneOn g (Icc (a - 1) (b - 1)))\n    (fpos : 0 ≤ f b) (gpos : 0 ≤ g (a - 1)) :\n    ∫ x in a..b, f x * g (x - 1) ≤ ∑ i ∈ Finset.Ico a b, f i * g i := by\n  apply integral_le_sum_Ico_of_le (f := fun x ↦ f x * g x) hab\n  · intro i hi x hx\n    simp only [Nat.cast_add, Nat.cast_one, mem_Ico] at hx hi\n    have I0 : (i : ℝ) ≤ b - 1 := by\n      simp only [le_sub_iff_add_le]\n      norm_cast\n      omega\n    have I1 : (i : ℝ) ∈ Icc (a - 1 : ℝ) (b - 1) := by\n      simp only [mem_Icc, tsub_le_iff_right]\n      exact ⟨by norm_cast; omega, I0⟩\n    have I2 : x ∈ Icc (a : ℝ) b := by\n      refine ⟨le_trans (mod_cast hi.1) hx.1, hx.2.le.trans ?_⟩\n      norm_cast\n      omega\n    apply mul_le_mul\n    · apply hf\n      · simp only [mem_Icc, Nat.cast_le]\n        exact ⟨hi.1, hi.2.le⟩\n      · exact I2\n      · exact hx.1\n    · apply hg\n      · simp only [mem_Icc, tsub_le_iff_right, sub_add_cancel]\n        refine ⟨le_trans (mod_cast hi.1) hx.1, hx.2.le.trans ?_⟩\n        norm_cast\n        omega\n      · exact I1\n      · simpa [sub_le_iff_le_add] using hx.2.le\n    · apply gpos.trans\n      apply hg (by simp [hab]) (by simpa using I2) (by simpa using I2.1)\n    · apply fpos.trans\n      apply hf ⟨mod_cast hi.1, mod_cast hi.2.le⟩ (by simpa using hab) (mod_cast hi.2.le)\n  · apply Integrable.mono_measure _ (Measure.restrict_mono_set _ Ico_subset_Icc_self)\n    apply Integrable.mul_of_top_left\n    · exact hf.integrableOn_isCompact isCompact_Icc\n    · apply MonotoneOn.memℒp_isCompact isCompact_Icc\n      intro x hx y hy hxy\n      apply hg\n      · simpa using hx\n      · simpa using hy\n      · simpa using hxy\n"}
