{"name":"SemiRingCat.hasLimit","module":"Mathlib.Algebra.Category.Ring.Limits","initialProofState":"J : Type v\ninst✝¹ : CategoryTheory.Category.{w, v} J\nF : CategoryTheory.Functor J SemiRingCat\ninst✝ : Small.{u, max u v} ↑(F.comp (CategoryTheory.forget SemiRingCat)).sections\n⊢ CategoryTheory.Limits.HasLimit F","decl":"/-- If `(F ⋙ forget SemiRingCat).sections` is `u`-small, `F` has a limit. -/\ninstance hasLimit : HasLimit F := ⟨limitCone.{v, u} F, limitConeIsLimit.{v, u} F⟩\n\n"}
{"name":"SemiRingCat.hasLimitsOfShape","module":"Mathlib.Algebra.Category.Ring.Limits","initialProofState":"J : Type v\ninst✝¹ : CategoryTheory.Category.{w, v} J\ninst✝ : Small.{u, v} J\n⊢ CategoryTheory.Limits.HasLimitsOfShape J SemiRingCat","decl":"/-- If `J` is `u`-small, `SemiRingCat.{u}` has limits of shape `J`. -/\ninstance hasLimitsOfShape [Small.{u} J] : HasLimitsOfShape J SemiRingCat.{u} where\n\n"}
{"name":"SemiRingCat.hasLimitsOfSize","module":"Mathlib.Algebra.Category.Ring.Limits","initialProofState":"inst✝ : UnivLE.{v, u}\n⊢ CategoryTheory.Limits.HasLimitsOfSize.{w, v, u, u + 1} SemiRingCat","decl":"/-- The category of rings has all limits. -/\ninstance hasLimitsOfSize [UnivLE.{v, u}] : HasLimitsOfSize.{w, v} SemiRingCat.{u} where\n  has_limits_of_shape _ _ := { }\n\n"}
{"name":"SemiRingCat.hasLimits","module":"Mathlib.Algebra.Category.Ring.Limits","initialProofState":"⊢ CategoryTheory.Limits.HasLimits SemiRingCat","decl":"instance hasLimits : HasLimits SemiRingCat.{u} :=\n  SemiRingCat.hasLimitsOfSize.{u, u}\n\n"}
{"name":"SemiRingCat.forget₂AddCommMon_preservesLimitsOfSize","module":"Mathlib.Algebra.Category.Ring.Limits","initialProofState":"inst✝ : UnivLE.{v, u}\n⊢ CategoryTheory.Limits.PreservesLimitsOfSize.{w, v, u, u, u + 1, u + 1} (CategoryTheory.forget₂ SemiRingCat AddCommMonCat)","decl":"/-- The forgetful functor from semirings to additive commutative monoids preserves all limits.\n-/\ninstance forget₂AddCommMon_preservesLimitsOfSize [UnivLE.{v, u}] :\n    PreservesLimitsOfSize.{w, v} (forget₂ SemiRingCat AddCommMonCat.{u}) where\n  preservesLimitsOfShape {_ _} :=\n    { preservesLimit := fun {F} =>\n        preservesLimit_of_preserves_limit_cone (limitConeIsLimit.{v, u} F)\n          (forget₂AddCommMonPreservesLimitsAux F) }\n\n"}
{"name":"SemiRingCat.forget₂AddCommMon_preservesLimits","module":"Mathlib.Algebra.Category.Ring.Limits","initialProofState":"⊢ CategoryTheory.Limits.PreservesLimits (CategoryTheory.forget₂ SemiRingCat AddCommMonCat)","decl":"instance forget₂AddCommMon_preservesLimits :\n    PreservesLimits (forget₂ SemiRingCat AddCommMonCat.{u}) :=\n  SemiRingCat.forget₂AddCommMon_preservesLimitsOfSize.{u, u}\n\n"}
{"name":"SemiRingCat.forget₂Mon_preservesLimitsOfSize","module":"Mathlib.Algebra.Category.Ring.Limits","initialProofState":"inst✝ : UnivLE.{v, u}\n⊢ CategoryTheory.Limits.PreservesLimitsOfSize.{w, v, u, u, u + 1, u + 1} (CategoryTheory.forget₂ SemiRingCat MonCat)","decl":"/-- The forgetful functor from semirings to monoids preserves all limits.\n-/\ninstance forget₂Mon_preservesLimitsOfSize [UnivLE.{v, u}] :\n    PreservesLimitsOfSize.{w, v} (forget₂ SemiRingCat MonCat.{u}) where\n  preservesLimitsOfShape {_ _} :=\n    { preservesLimit := fun {F} =>\n        preservesLimit_of_preserves_limit_cone (limitConeIsLimit F)\n          (forget₂MonPreservesLimitsAux.{v, u} F) }\n\n"}
{"name":"SemiRingCat.forget₂Mon_preservesLimits","module":"Mathlib.Algebra.Category.Ring.Limits","initialProofState":"⊢ CategoryTheory.Limits.PreservesLimits (CategoryTheory.forget₂ SemiRingCat MonCat)","decl":"instance forget₂Mon_preservesLimits : PreservesLimits (forget₂ SemiRingCat MonCat.{u}) :=\n  SemiRingCat.forget₂Mon_preservesLimitsOfSize.{u, u}\n\n"}
{"name":"SemiRingCat.forget_preservesLimitsOfSize","module":"Mathlib.Algebra.Category.Ring.Limits","initialProofState":"inst✝ : UnivLE.{v, u}\n⊢ CategoryTheory.Limits.PreservesLimitsOfSize.{w, v, u, u, u + 1, u + 1} (CategoryTheory.forget SemiRingCat)","decl":"/-- The forgetful functor from semirings to types preserves all limits.\n-/\ninstance forget_preservesLimitsOfSize [UnivLE.{v, u}] :\n    PreservesLimitsOfSize.{w, v} (forget SemiRingCat.{u}) where\n  preservesLimitsOfShape {_ _} :=\n    { preservesLimit := fun {F} =>\n        preservesLimit_of_preserves_limit_cone (limitConeIsLimit F)\n          (Types.Small.limitConeIsLimit.{v, u} (F ⋙ forget _)) }\n\n"}
{"name":"SemiRingCat.forget_preservesLimits","module":"Mathlib.Algebra.Category.Ring.Limits","initialProofState":"⊢ CategoryTheory.Limits.PreservesLimits (CategoryTheory.forget SemiRingCat)","decl":"instance forget_preservesLimits : PreservesLimits (forget SemiRingCat.{u}) :=\n  SemiRingCat.forget_preservesLimitsOfSize.{u, u}\n\n"}
{"name":"CommSemiRingCat.hasLimit","module":"Mathlib.Algebra.Category.Ring.Limits","initialProofState":"J : Type v\ninst✝¹ : CategoryTheory.Category.{w, v} J\nF : CategoryTheory.Functor J CommSemiRingCat\ninst✝ : Small.{u, max u v} ↑(F.comp (CategoryTheory.forget CommSemiRingCat)).sections\n⊢ CategoryTheory.Limits.HasLimit F","decl":"/-- If `(F ⋙ forget CommSemiRingCat).sections` is `u`-small, `F` has a limit. -/\ninstance hasLimit : HasLimit F := ⟨limitCone.{v, u} F, limitConeIsLimit.{v, u} F⟩\n\n"}
{"name":"CommSemiRingCat.hasLimitsOfShape","module":"Mathlib.Algebra.Category.Ring.Limits","initialProofState":"J : Type v\ninst✝¹ : CategoryTheory.Category.{w, v} J\ninst✝ : Small.{u, v} J\n⊢ CategoryTheory.Limits.HasLimitsOfShape J CommSemiRingCat","decl":"/-- If `J` is `u`-small, `CommSemiRingCat.{u}` has limits of shape `J`. -/\ninstance hasLimitsOfShape [Small.{u} J] : HasLimitsOfShape J CommSemiRingCat.{u} where\n\n"}
{"name":"CommSemiRingCat.hasLimitsOfSize","module":"Mathlib.Algebra.Category.Ring.Limits","initialProofState":"inst✝ : UnivLE.{v, u}\n⊢ CategoryTheory.Limits.HasLimitsOfSize.{w, v, u, u + 1} CommSemiRingCat","decl":"/-- The category of rings has all limits. -/\ninstance hasLimitsOfSize [UnivLE.{v, u}] : HasLimitsOfSize.{w, v} CommSemiRingCat.{u} where\n\n"}
{"name":"CommSemiRingCat.hasLimits","module":"Mathlib.Algebra.Category.Ring.Limits","initialProofState":"⊢ CategoryTheory.Limits.HasLimits CommSemiRingCat","decl":"instance hasLimits : HasLimits CommSemiRingCat.{u} :=\n  CommSemiRingCat.hasLimitsOfSize.{u, u}\n\n"}
{"name":"CommSemiRingCat.forget₂SemiRing_preservesLimitsOfSize","module":"Mathlib.Algebra.Category.Ring.Limits","initialProofState":"inst✝ : UnivLE.{v, u}\n⊢ CategoryTheory.Limits.PreservesLimitsOfSize.{w, v, u, u, u + 1, u + 1} (CategoryTheory.forget₂ CommSemiRingCat SemiRingCat)","decl":"/-- The forgetful functor from rings to semirings preserves all limits.\n-/\ninstance forget₂SemiRing_preservesLimitsOfSize [UnivLE.{v, u}] :\n    PreservesLimitsOfSize.{w, v} (forget₂ CommSemiRingCat SemiRingCat.{u}) where\n  preservesLimitsOfShape {_ _} :=\n    { preservesLimit := fun {F} =>\n        preservesLimit_of_preserves_limit_cone (limitConeIsLimit.{v, u} F)\n          (SemiRingCat.HasLimits.limitConeIsLimit (F ⋙ forget₂ _ SemiRingCat)) }\n\n"}
{"name":"CommSemiRingCat.forget₂SemiRing_preservesLimits","module":"Mathlib.Algebra.Category.Ring.Limits","initialProofState":"⊢ CategoryTheory.Limits.PreservesLimits (CategoryTheory.forget₂ CommSemiRingCat SemiRingCat)","decl":"instance forget₂SemiRing_preservesLimits :\n    PreservesLimits (forget₂ CommSemiRingCat SemiRingCat.{u}) :=\n  CommSemiRingCat.forget₂SemiRing_preservesLimitsOfSize.{u, u}\n\n"}
{"name":"CommSemiRingCat.forget_preservesLimitsOfSize","module":"Mathlib.Algebra.Category.Ring.Limits","initialProofState":"inst✝ : UnivLE.{v, u}\n⊢ CategoryTheory.Limits.PreservesLimitsOfSize.{w, v, u, u, u + 1, u + 1} (CategoryTheory.forget CommSemiRingCat)","decl":"/-- The forgetful functor from rings to types preserves all limits. (That is, the underlying\ntypes could have been computed instead as limits in the category of types.)\n-/\ninstance forget_preservesLimitsOfSize [UnivLE.{v, u}] :\n    PreservesLimitsOfSize.{w, v} (forget CommSemiRingCat.{u}) where\n  preservesLimitsOfShape {_ _} :=\n    { preservesLimit := fun {F} =>\n        preservesLimit_of_preserves_limit_cone (limitConeIsLimit.{v, u} F)\n          (Types.Small.limitConeIsLimit.{v, u} _) }\n\n"}
{"name":"CommSemiRingCat.forget_preservesLimits","module":"Mathlib.Algebra.Category.Ring.Limits","initialProofState":"⊢ CategoryTheory.Limits.PreservesLimits (CategoryTheory.forget CommSemiRingCat)","decl":"instance forget_preservesLimits : PreservesLimits (forget CommSemiRingCat.{u}) :=\n  CommSemiRingCat.forget_preservesLimitsOfSize.{u, u}\n\n"}
{"name":"RingCat.hasLimit","module":"Mathlib.Algebra.Category.Ring.Limits","initialProofState":"J : Type v\ninst✝¹ : CategoryTheory.Category.{w, v} J\nF : CategoryTheory.Functor J RingCat\ninst✝ : Small.{u, max u v} ↑(F.comp (CategoryTheory.forget RingCat)).sections\n⊢ CategoryTheory.Limits.HasLimit F","decl":"/-- If `(F ⋙ forget RingCat).sections` is `u`-small, `F` has a limit. -/\ninstance hasLimit : HasLimit F :=\n  letI : Small.{u} (Functor.sections ((F ⋙ forget₂ _ SemiRingCat) ⋙ forget _)) :=\n    inferInstanceAs <| Small.{u} (Functor.sections (F ⋙ forget _))\n  hasLimit_of_created F (forget₂ RingCat.{u} SemiRingCat.{u})\n\n"}
{"name":"RingCat.hasLimitsOfShape","module":"Mathlib.Algebra.Category.Ring.Limits","initialProofState":"J : Type v\ninst✝¹ : CategoryTheory.Category.{w, v} J\ninst✝ : Small.{u, v} J\n⊢ CategoryTheory.Limits.HasLimitsOfShape J RingCat","decl":"/-- If `J` is `u`-small, `RingCat.{u}` has limits of shape `J`. -/\ninstance hasLimitsOfShape [Small.{u} J] : HasLimitsOfShape J RingCat.{u} where\n\n"}
{"name":"RingCat.hasLimitsOfSize","module":"Mathlib.Algebra.Category.Ring.Limits","initialProofState":"inst✝ : UnivLE.{v, u}\n⊢ CategoryTheory.Limits.HasLimitsOfSize.{w, v, u, u + 1} RingCat","decl":"/-- The category of rings has all limits. -/\ninstance hasLimitsOfSize [UnivLE.{v, u}] : HasLimitsOfSize.{w, v} RingCat.{u} where\n\n"}
{"name":"RingCat.hasLimits","module":"Mathlib.Algebra.Category.Ring.Limits","initialProofState":"⊢ CategoryTheory.Limits.HasLimits RingCat","decl":"instance hasLimits : HasLimits RingCat.{u} :=\n  RingCat.hasLimitsOfSize.{u, u}\n\n"}
{"name":"RingCat.forget₂SemiRing_preservesLimitsOfSize","module":"Mathlib.Algebra.Category.Ring.Limits","initialProofState":"inst✝ : UnivLE.{v, u}\n⊢ CategoryTheory.Limits.PreservesLimitsOfSize.{w, v, u, u, u + 1, u + 1} (CategoryTheory.forget₂ RingCat SemiRingCat)","decl":"/-- The forgetful functor from rings to semirings preserves all limits.\n-/\ninstance forget₂SemiRing_preservesLimitsOfSize [UnivLE.{v, u}] :\n    PreservesLimitsOfSize.{w, v} (forget₂ RingCat SemiRingCat.{u}) where\n  preservesLimitsOfShape {_ _} :=\n      { preservesLimit := fun {F} =>\n          preservesLimit_of_preserves_limit_cone (limitConeIsLimit.{v, u} F)\n            (SemiRingCat.HasLimits.limitConeIsLimit.{v, u} _) }\n\n"}
{"name":"RingCat.forget₂SemiRing_preservesLimits","module":"Mathlib.Algebra.Category.Ring.Limits","initialProofState":"⊢ CategoryTheory.Limits.PreservesLimits (CategoryTheory.forget₂ RingCat SemiRingCat)","decl":"instance forget₂SemiRing_preservesLimits : PreservesLimits (forget₂ RingCat SemiRingCat.{u}) :=\n  RingCat.forget₂SemiRing_preservesLimitsOfSize.{u, u}\n\n"}
{"name":"RingCat.forget₂AddCommGroup_preservesLimitsOfSize","module":"Mathlib.Algebra.Category.Ring.Limits","initialProofState":"inst✝ : UnivLE.{v, u}\n⊢ CategoryTheory.Limits.PreservesLimitsOfSize.{v, v, u, u, u + 1, u + 1} (CategoryTheory.forget₂ RingCat AddCommGrp)","decl":"/-- The forgetful functor from rings to additive commutative groups preserves all limits.\n-/\ninstance forget₂AddCommGroup_preservesLimitsOfSize [UnivLE.{v, u}] :\n    PreservesLimitsOfSize.{v, v} (forget₂ RingCat.{u} AddCommGrp.{u}) where\n  preservesLimitsOfShape {_ _} :=\n    { preservesLimit := fun {F} =>\n        preservesLimit_of_preserves_limit_cone (limitConeIsLimit.{v, u} F)\n          (forget₂AddCommGroupPreservesLimitsAux F) }\n\n"}
{"name":"RingCat.forget₂AddCommGroup_preservesLimits","module":"Mathlib.Algebra.Category.Ring.Limits","initialProofState":"⊢ CategoryTheory.Limits.PreservesLimits (CategoryTheory.forget₂ RingCat AddCommGrp)","decl":"instance forget₂AddCommGroup_preservesLimits :\n    PreservesLimits (forget₂ RingCat AddCommGrp.{u}) :=\n  RingCat.forget₂AddCommGroup_preservesLimitsOfSize.{u, u}\n\n"}
{"name":"RingCat.forget_preservesLimitsOfSize","module":"Mathlib.Algebra.Category.Ring.Limits","initialProofState":"inst✝ : UnivLE.{v, u}\n⊢ CategoryTheory.Limits.PreservesLimitsOfSize.{v, v, u, u, u + 1, u + 1} (CategoryTheory.forget RingCat)","decl":"/-- The forgetful functor from rings to types preserves all limits. (That is, the underlying\ntypes could have been computed instead as limits in the category of types.)\n-/\ninstance forget_preservesLimitsOfSize [UnivLE.{v, u}] :\n    PreservesLimitsOfSize.{v, v} (forget RingCat.{u}) where\n  preservesLimitsOfShape {_ _} :=\n    { preservesLimit := fun {F} =>\n        preservesLimit_of_preserves_limit_cone (limitConeIsLimit.{v, u} F)\n          (Types.Small.limitConeIsLimit.{v, u} _) }\n\n"}
{"name":"RingCat.forget_preservesLimits","module":"Mathlib.Algebra.Category.Ring.Limits","initialProofState":"⊢ CategoryTheory.Limits.PreservesLimits (CategoryTheory.forget RingCat)","decl":"instance forget_preservesLimits : PreservesLimits (forget RingCat.{u}) :=\n  RingCat.forget_preservesLimitsOfSize.{u, u}\n\n"}
{"name":"CommRingCat.hasLimit","module":"Mathlib.Algebra.Category.Ring.Limits","initialProofState":"J : Type v\ninst✝¹ : CategoryTheory.Category.{w, v} J\nF : CategoryTheory.Functor J CommRingCat\ninst✝ : Small.{u, max u v} ↑(F.comp (CategoryTheory.forget CommRingCat)).sections\n⊢ CategoryTheory.Limits.HasLimit F","decl":"/-- If `(F ⋙ forget CommRingCat).sections` is `u`-small, `F` has a limit. -/\ninstance hasLimit : HasLimit F :=\n  letI : Small.{u} (Functor.sections ((F ⋙ forget₂ CommRingCat RingCat) ⋙ forget RingCat)) :=\n    inferInstanceAs <| Small.{u} (Functor.sections (F ⋙ forget _))\n  hasLimit_of_created F (forget₂ CommRingCat.{u} RingCat.{u})\n\n"}
{"name":"CommRingCat.hasLimitsOfShape","module":"Mathlib.Algebra.Category.Ring.Limits","initialProofState":"J : Type v\ninst✝¹ : CategoryTheory.Category.{w, v} J\ninst✝ : Small.{u, v} J\n⊢ CategoryTheory.Limits.HasLimitsOfShape J CommRingCat","decl":"/-- If `J` is `u`-small, `CommRingCat.{u}` has limits of shape `J`. -/\ninstance hasLimitsOfShape [Small.{u} J] : HasLimitsOfShape J CommRingCat.{u} where\n\n"}
{"name":"CommRingCat.hasLimitsOfSize","module":"Mathlib.Algebra.Category.Ring.Limits","initialProofState":"inst✝ : UnivLE.{v, u}\n⊢ CategoryTheory.Limits.HasLimitsOfSize.{w, v, u, u + 1} CommRingCat","decl":"/-- The category of commutative rings has all limits. -/\ninstance hasLimitsOfSize [UnivLE.{v, u}] : HasLimitsOfSize.{w, v} CommRingCat.{u} where\n\n"}
{"name":"CommRingCat.hasLimits","module":"Mathlib.Algebra.Category.Ring.Limits","initialProofState":"⊢ CategoryTheory.Limits.HasLimits CommRingCat","decl":"instance hasLimits : HasLimits CommRingCat.{u} :=\n  CommRingCat.hasLimitsOfSize.{u, u}\n\n"}
{"name":"CommRingCat.forget₂Ring_preservesLimitsOfSize","module":"Mathlib.Algebra.Category.Ring.Limits","initialProofState":"inst✝ : UnivLE.{v, u}\n⊢ CategoryTheory.Limits.PreservesLimitsOfSize.{w, v, u, u, u + 1, u + 1} (CategoryTheory.forget₂ CommRingCat RingCat)","decl":"/-- The forgetful functor from commutative rings to rings preserves all limits.\n(That is, the underlying rings could have been computed instead as limits in the category of rings.)\n-/\ninstance forget₂Ring_preservesLimitsOfSize [UnivLE.{v, u}] :\n    PreservesLimitsOfSize.{w, v} (forget₂ CommRingCat RingCat.{u}) where\n  preservesLimitsOfShape {_ _} :=\n    { preservesLimit := fun {F} =>\n        preservesLimit_of_preserves_limit_cone.{w, v} (limitConeIsLimit.{v, u} F)\n          (RingCat.limitConeIsLimit.{v, u} _) }\n\n"}
{"name":"CommRingCat.forget₂Ring_preservesLimits","module":"Mathlib.Algebra.Category.Ring.Limits","initialProofState":"⊢ CategoryTheory.Limits.PreservesLimits (CategoryTheory.forget₂ CommRingCat RingCat)","decl":"instance forget₂Ring_preservesLimits : PreservesLimits (forget₂ CommRingCat RingCat.{u}) :=\n  CommRingCat.forget₂Ring_preservesLimitsOfSize.{u, u}\n\n"}
{"name":"CommRingCat.forget₂CommSemiRing_preservesLimitsOfSize","module":"Mathlib.Algebra.Category.Ring.Limits","initialProofState":"inst✝ : UnivLE.{v, u}\n⊢ CategoryTheory.Limits.PreservesLimitsOfSize.{w, v, u, u, u + 1, u + 1} (CategoryTheory.forget₂ CommRingCat CommSemiRingCat)","decl":"/-- The forgetful functor from commutative rings to commutative semirings preserves all limits.\n(That is, the underlying commutative semirings could have been computed instead as limits\nin the category of commutative semirings.)\n-/\ninstance forget₂CommSemiRing_preservesLimitsOfSize [UnivLE.{v, u}] :\n    PreservesLimitsOfSize.{w, v} (forget₂ CommRingCat CommSemiRingCat.{u}) where\n  preservesLimitsOfShape {_ _} :=\n    { preservesLimit := fun {F} =>\n        preservesLimit_of_preserves_limit_cone (limitConeIsLimit.{v, u} F)\n          (forget₂CommSemiRingPreservesLimitsAux.{v, u} F) }\n\n"}
{"name":"CommRingCat.forget₂CommSemiRing_preservesLimits","module":"Mathlib.Algebra.Category.Ring.Limits","initialProofState":"⊢ CategoryTheory.Limits.PreservesLimits (CategoryTheory.forget₂ CommRingCat CommSemiRingCat)","decl":"instance forget₂CommSemiRing_preservesLimits :\n    PreservesLimits (forget₂ CommRingCat CommSemiRingCat.{u}) :=\n  CommRingCat.forget₂CommSemiRing_preservesLimitsOfSize.{u, u}\n\n"}
{"name":"CommRingCat.forget_preservesLimitsOfSize","module":"Mathlib.Algebra.Category.Ring.Limits","initialProofState":"inst✝ : UnivLE.{v, u}\n⊢ CategoryTheory.Limits.PreservesLimitsOfSize.{w, v, u, u, u + 1, u + 1} (CategoryTheory.forget CommRingCat)","decl":"/-- The forgetful functor from commutative rings to types preserves all limits.\n(That is, the underlying types could have been computed instead as limits in the category of types.)\n-/\ninstance forget_preservesLimitsOfSize [UnivLE.{v, u}] :\n    PreservesLimitsOfSize.{w, v} (forget CommRingCat.{u}) where\n  preservesLimitsOfShape {_ _} :=\n    { preservesLimit := fun {F} =>\n        preservesLimit_of_preserves_limit_cone.{w, v} (limitConeIsLimit.{v, u} F)\n          (Types.Small.limitConeIsLimit.{v, u} _) }\n\n"}
{"name":"CommRingCat.forget_preservesLimits","module":"Mathlib.Algebra.Category.Ring.Limits","initialProofState":"⊢ CategoryTheory.Limits.PreservesLimits (CategoryTheory.forget CommRingCat)","decl":"instance forget_preservesLimits : PreservesLimits (forget CommRingCat.{u}) :=\n  CommRingCat.forget_preservesLimitsOfSize.{u, u}\n\n"}
