{"name":"Algebra.FormallyUnramified.subsingleton_kaehlerDifferential","module":"Mathlib.RingTheory.Unramified.Basic","initialProofState":"R : Type v\nA : Type u\ninst✝² : CommRing R\ninst✝¹ : CommRing A\ninst✝ : Algebra R A\nself : Algebra.FormallyUnramified R A\n⊢ Subsingleton (KaehlerDifferential R A)","decl":"/--\nAn `R`-algebra `A` is formally unramified if `Ω[A⁄R]` is trivial.\n\nThis is equivalent to \"for every `R`-algebra, every square-zero ideal\n`I : Ideal B` and `f : A →ₐ[R] B ⧸ I`, there exists at most one lift `A →ₐ[R] B`\".\nSee `Algebra.FormallyUnramified.iff_comp_injective`. -/\n@[mk_iff, stacks 00UM]\nclass FormallyUnramified : Prop where\n  subsingleton_kaehlerDifferential : Subsingleton (Ω[A⁄R])\n\n"}
{"name":"Algebra.formallyUnramified_iff","module":"Mathlib.RingTheory.Unramified.Basic","initialProofState":"R : Type v\nA : Type u\ninst✝² : CommRing R\ninst✝¹ : CommRing A\ninst✝ : Algebra R A\n⊢ Iff (Algebra.FormallyUnramified R A) (Subsingleton (KaehlerDifferential R A))","decl":"/--\nAn `R`-algebra `A` is formally unramified if `Ω[A⁄R]` is trivial.\n\nThis is equivalent to \"for every `R`-algebra, every square-zero ideal\n`I : Ideal B` and `f : A →ₐ[R] B ⧸ I`, there exists at most one lift `A →ₐ[R] B`\".\nSee `Algebra.FormallyUnramified.iff_comp_injective`. -/\n@[mk_iff, stacks 00UM]\nclass FormallyUnramified : Prop where\n  subsingleton_kaehlerDifferential : Subsingleton (Ω[A⁄R])\n\n"}
{"name":"Algebra.FormallyUnramified.comp_injective","module":"Mathlib.RingTheory.Unramified.Basic","initialProofState":"R : Type v\ninst✝⁵ : CommRing R\nA : Type u\ninst✝⁴ : CommRing A\ninst✝³ : Algebra R A\nB : Type w\ninst✝² : CommRing B\ninst✝¹ : Algebra R B\nI : Ideal B\ninst✝ : Algebra.FormallyUnramified R A\nhI : Eq (HPow.hPow I 2) Bot.bot\n⊢ Function.Injective (Ideal.Quotient.mkₐ R I).comp","decl":"theorem comp_injective [FormallyUnramified R A] (hI : I ^ 2 = ⊥) :\n    Function.Injective ((Ideal.Quotient.mkₐ R I).comp : (A →ₐ[R] B) → A →ₐ[R] B ⧸ I) := by\n  intro f₁ f₂ e\n  letI := f₁.toRingHom.toAlgebra\n  haveI := IsScalarTower.of_algebraMap_eq' f₁.comp_algebraMap.symm\n  have :=\n    ((KaehlerDifferential.linearMapEquivDerivation R A).toEquiv.trans\n          (derivationToSquareZeroEquivLift I hI)).surjective.subsingleton\n  exact Subtype.ext_iff.mp (@Subsingleton.elim _ this ⟨f₁, rfl⟩ ⟨f₂, e.symm⟩)\n\n"}
{"name":"Algebra.FormallyUnramified.iff_comp_injective","module":"Mathlib.RingTheory.Unramified.Basic","initialProofState":"R : Type v\ninst✝² : CommRing R\nA : Type u\ninst✝¹ : CommRing A\ninst✝ : Algebra R A\n⊢ Iff (Algebra.FormallyUnramified R A) (∀ ⦃B : Type u⦄ [inst : CommRing B] [inst_1 : Algebra R B] (I : Ideal B), Eq (HPow.hPow I 2) Bot.bot → Function.Injective (Ideal.Quotient.mkₐ R I).comp)","decl":"theorem iff_comp_injective :\n    FormallyUnramified R A ↔\n      ∀ ⦃B : Type u⦄ [CommRing B],\n        ∀ [Algebra R B] (I : Ideal B) (_ : I ^ 2 = ⊥),\n          Function.Injective ((Ideal.Quotient.mkₐ R I).comp : (A →ₐ[R] B) → A →ₐ[R] B ⧸ I) := by\n  constructor\n  · intros; exact comp_injective _ ‹_›\n  · intro H\n    constructor\n    rw [← not_nontrivial_iff_subsingleton]\n    intro h\n    obtain ⟨f₁, f₂, e⟩ := (KaehlerDifferential.endEquiv R A).injective.nontrivial\n    apply e\n    ext1\n    refine H\n      (RingHom.ker (TensorProduct.lmul' R (S := A)).kerSquareLift.toRingHom) ?_ ?_\n    · rw [AlgHom.ker_kerSquareLift]\n      exact Ideal.cotangentIdeal_square _\n    · ext x\n      apply RingHom.kerLift_injective (TensorProduct.lmul' R (S := A)).kerSquareLift.toRingHom\n      simpa using DFunLike.congr_fun (f₁.2.trans f₂.2.symm) x\n\n"}
{"name":"Algebra.FormallyUnramified.lift_unique","module":"Mathlib.RingTheory.Unramified.Basic","initialProofState":"R : Type v\ninst✝⁵ : CommRing R\nA : Type u\ninst✝⁴ : CommRing A\ninst✝³ : Algebra R A\nB : Type w\ninst✝² : CommRing B\ninst✝¹ : Algebra R B\ninst✝ : Algebra.FormallyUnramified R A\nI : Ideal B\nhI : IsNilpotent I\ng₁ g₂ : AlgHom R A B\nh : Eq ((Ideal.Quotient.mkₐ R I).comp g₁) ((Ideal.Quotient.mkₐ R I).comp g₂)\n⊢ Eq g₁ g₂","decl":"theorem lift_unique\n    [FormallyUnramified R A] (I : Ideal B) (hI : IsNilpotent I) (g₁ g₂ : A →ₐ[R] B)\n    (h : (Ideal.Quotient.mkₐ R I).comp g₁ = (Ideal.Quotient.mkₐ R I).comp g₂) : g₁ = g₂ := by\n  revert g₁ g₂\n  change Function.Injective (Ideal.Quotient.mkₐ R I).comp\n  revert ‹Algebra R B›\n  apply Ideal.IsNilpotent.induction_on (S := B) I hI\n  · intro B _ I hI _; exact FormallyUnramified.comp_injective I hI\n  · intro B _ I J hIJ h₁ h₂ _ g₁ g₂ e\n    apply h₁\n    apply h₂\n    ext x\n    replace e := AlgHom.congr_fun e x\n    dsimp only [AlgHom.comp_apply, Ideal.Quotient.mkₐ_eq_mk] at e ⊢\n    rwa [Ideal.Quotient.eq, ← map_sub, Ideal.mem_quotient_iff_mem hIJ, ← Ideal.Quotient.eq]\n\n"}
{"name":"Algebra.FormallyUnramified.ext","module":"Mathlib.RingTheory.Unramified.Basic","initialProofState":"R : Type v\ninst✝⁵ : CommRing R\nA : Type u\ninst✝⁴ : CommRing A\ninst✝³ : Algebra R A\nB : Type w\ninst✝² : CommRing B\ninst✝¹ : Algebra R B\nI : Ideal B\ninst✝ : Algebra.FormallyUnramified R A\nhI : IsNilpotent I\ng₁ g₂ : AlgHom R A B\nH : ∀ (x : A), Eq ((Ideal.Quotient.mk I) (g₁ x)) ((Ideal.Quotient.mk I) (g₂ x))\n⊢ Eq g₁ g₂","decl":"theorem ext [FormallyUnramified R A] (hI : IsNilpotent I) {g₁ g₂ : A →ₐ[R] B}\n    (H : ∀ x, Ideal.Quotient.mk I (g₁ x) = Ideal.Quotient.mk I (g₂ x)) : g₁ = g₂ :=\n  FormallyUnramified.lift_unique I hI g₁ g₂ (AlgHom.ext H)\n\n"}
{"name":"Algebra.FormallyUnramified.lift_unique_of_ringHom","module":"Mathlib.RingTheory.Unramified.Basic","initialProofState":"R : Type v\ninst✝⁶ : CommRing R\nA : Type u\ninst✝⁵ : CommRing A\ninst✝⁴ : Algebra R A\nB : Type w\ninst✝³ : CommRing B\ninst✝² : Algebra R B\ninst✝¹ : Algebra.FormallyUnramified R A\nC : Type u_1\ninst✝ : CommRing C\nf : RingHom B C\nhf : IsNilpotent (RingHom.ker f)\ng₁ g₂ : AlgHom R A B\nh : Eq (f.comp ↑g₁) (f.comp ↑g₂)\n⊢ Eq g₁ g₂","decl":"theorem lift_unique_of_ringHom [FormallyUnramified R A] {C : Type*} [CommRing C]\n    (f : B →+* C) (hf : IsNilpotent <| RingHom.ker f) (g₁ g₂ : A →ₐ[R] B)\n    (h : f.comp ↑g₁ = f.comp (g₂ : A →+* B)) : g₁ = g₂ :=\n  FormallyUnramified.lift_unique _ hf _ _\n    (by\n      ext x\n      have := RingHom.congr_fun h x\n      simpa only [Ideal.Quotient.eq, Function.comp_apply, AlgHom.coe_comp, Ideal.Quotient.mkₐ_eq_mk,\n        RingHom.mem_ker, map_sub, sub_eq_zero])\n\n"}
{"name":"Algebra.FormallyUnramified.ext'","module":"Mathlib.RingTheory.Unramified.Basic","initialProofState":"R : Type v\ninst✝⁶ : CommRing R\nA : Type u\ninst✝⁵ : CommRing A\ninst✝⁴ : Algebra R A\nB : Type w\ninst✝³ : CommRing B\ninst✝² : Algebra R B\ninst✝¹ : Algebra.FormallyUnramified R A\nC : Type u_1\ninst✝ : CommRing C\nf : RingHom B C\nhf : IsNilpotent (RingHom.ker f)\ng₁ g₂ : AlgHom R A B\nh : ∀ (x : A), Eq (f (g₁ x)) (f (g₂ x))\n⊢ Eq g₁ g₂","decl":"theorem ext' [FormallyUnramified R A] {C : Type*} [CommRing C] (f : B →+* C)\n    (hf : IsNilpotent <| RingHom.ker f) (g₁ g₂ : A →ₐ[R] B) (h : ∀ x, f (g₁ x) = f (g₂ x)) :\n    g₁ = g₂ :=\n  FormallyUnramified.lift_unique_of_ringHom f hf g₁ g₂ (RingHom.ext h)\n\n"}
{"name":"Algebra.FormallyUnramified.lift_unique'","module":"Mathlib.RingTheory.Unramified.Basic","initialProofState":"R : Type v\ninst✝⁷ : CommRing R\nA : Type u\ninst✝⁶ : CommRing A\ninst✝⁵ : Algebra R A\nB : Type w\ninst✝⁴ : CommRing B\ninst✝³ : Algebra R B\ninst✝² : Algebra.FormallyUnramified R A\nC : Type u_1\ninst✝¹ : CommRing C\ninst✝ : Algebra R C\nf : AlgHom R B C\nhf : IsNilpotent (RingHom.ker ↑f)\ng₁ g₂ : AlgHom R A B\nh : Eq (f.comp g₁) (f.comp g₂)\n⊢ Eq g₁ g₂","decl":"theorem lift_unique' [FormallyUnramified R A] {C : Type*} [CommRing C]\n    [Algebra R C] (f : B →ₐ[R] C) (hf : IsNilpotent <| RingHom.ker (f : B →+* C))\n    (g₁ g₂ : A →ₐ[R] B) (h : f.comp g₁ = f.comp g₂) : g₁ = g₂ :=\n  FormallyUnramified.ext' _ hf g₁ g₂ (AlgHom.congr_fun h)\n\n"}
{"name":"Algebra.FormallyUnramified.inst","module":"Mathlib.RingTheory.Unramified.Basic","initialProofState":"R : Type u_1\ninst✝ : CommRing R\n⊢ Algebra.FormallyUnramified R R","decl":"instance {R : Type*} [CommRing R] : FormallyUnramified R R := by\n  rw [iff_comp_injective]\n  intros B _ _ _ _ f₁ f₂ _\n  exact Subsingleton.elim _ _\n\n"}
{"name":"Algebra.FormallyUnramified.of_equiv","module":"Mathlib.RingTheory.Unramified.Basic","initialProofState":"R : Type u_1\ninst✝⁵ : CommRing R\nA : Type u_2\nB : Type u_3\ninst✝⁴ : CommRing A\ninst✝³ : Algebra R A\ninst✝² : CommRing B\ninst✝¹ : Algebra R B\ninst✝ : Algebra.FormallyUnramified R A\ne : AlgEquiv R A B\n⊢ Algebra.FormallyUnramified R B","decl":"theorem of_equiv [FormallyUnramified R A] (e : A ≃ₐ[R] B) :\n    FormallyUnramified R B := by\n  rw [iff_comp_injective]\n  intro C _ _ I hI f₁ f₂ e'\n  rw [← f₁.comp_id, ← f₂.comp_id, ← e.comp_symm, ← AlgHom.comp_assoc, ← AlgHom.comp_assoc]\n  congr 1\n  refine FormallyUnramified.comp_injective I hI ?_\n  rw [← AlgHom.comp_assoc, e', AlgHom.comp_assoc]\n\n"}
{"name":"Algebra.FormallyUnramified.comp","module":"Mathlib.RingTheory.Unramified.Basic","initialProofState":"R : Type u_1\ninst✝⁸ : CommRing R\nA : Type u_2\ninst✝⁷ : CommRing A\ninst✝⁶ : Algebra R A\nB : Type u_3\ninst✝⁵ : CommRing B\ninst✝⁴ : Algebra R B\ninst✝³ : Algebra A B\ninst✝² : IsScalarTower R A B\ninst✝¹ : Algebra.FormallyUnramified R A\ninst✝ : Algebra.FormallyUnramified A B\n⊢ Algebra.FormallyUnramified R B","decl":"theorem comp [FormallyUnramified R A] [FormallyUnramified A B] :\n    FormallyUnramified R B := by\n  rw [iff_comp_injective]\n  intro C _ _ I hI f₁ f₂ e\n  have e' :=\n    FormallyUnramified.lift_unique I ⟨2, hI⟩ (f₁.comp <| IsScalarTower.toAlgHom R A B)\n      (f₂.comp <| IsScalarTower.toAlgHom R A B) (by rw [← AlgHom.comp_assoc, e, AlgHom.comp_assoc])\n  letI := (f₁.restrictDomain A).toAlgebra\n  let F₁ : B →ₐ[A] C := { f₁ with commutes' := fun r => rfl }\n  let F₂ : B →ₐ[A] C := { f₂ with commutes' := AlgHom.congr_fun e'.symm }\n  ext1 x\n  change F₁ x = F₂ x\n  congr\n  exact FormallyUnramified.ext I ⟨2, hI⟩ (AlgHom.congr_fun e)\n\n"}
{"name":"Algebra.FormallyUnramified.of_comp","module":"Mathlib.RingTheory.Unramified.Basic","initialProofState":"R : Type u_1\ninst✝⁷ : CommRing R\nA : Type u_2\ninst✝⁶ : CommRing A\ninst✝⁵ : Algebra R A\nB : Type u_3\ninst✝⁴ : CommRing B\ninst✝³ : Algebra R B\ninst✝² : Algebra A B\ninst✝¹ : IsScalarTower R A B\ninst✝ : Algebra.FormallyUnramified R B\n⊢ Algebra.FormallyUnramified A B","decl":"theorem of_comp [FormallyUnramified R B] : FormallyUnramified A B := by\n  rw [iff_comp_injective]\n  intro Q _ _ I e f₁ f₂ e'\n  letI := ((algebraMap A Q).comp (algebraMap R A)).toAlgebra\n  letI : IsScalarTower R A Q := IsScalarTower.of_algebraMap_eq' rfl\n  refine AlgHom.restrictScalars_injective R ?_\n  refine FormallyUnramified.ext I ⟨2, e⟩ ?_\n  intro x\n  exact AlgHom.congr_fun e' x\n\n"}
{"name":"Algebra.FormallyUnramified.of_surjective","module":"Mathlib.RingTheory.Unramified.Basic","initialProofState":"R : Type u_1\ninst✝⁵ : CommRing R\nA : Type u_2\nB : Type u_3\ninst✝⁴ : CommRing A\ninst✝³ : Algebra R A\ninst✝² : CommRing B\ninst✝¹ : Algebra R B\ninst✝ : Algebra.FormallyUnramified R A\nf : AlgHom R A B\nH : Function.Surjective ⇑f\n⊢ Algebra.FormallyUnramified R B","decl":"/-- This holds in general for epimorphisms. -/\ntheorem of_surjective [FormallyUnramified R A] (f : A →ₐ[R] B) (H : Function.Surjective f) :\n    FormallyUnramified R B := by\n  rw [iff_comp_injective]\n  intro Q _ _ I hI f₁ f₂ e\n  ext x\n  obtain ⟨x, rfl⟩ := H x\n  rw [← AlgHom.comp_apply, ← AlgHom.comp_apply]\n  congr 1\n  apply FormallyUnramified.comp_injective I hI\n  ext x; exact DFunLike.congr_fun e (f x)\n\n"}
{"name":"Algebra.FormallyUnramified.quotient","module":"Mathlib.RingTheory.Unramified.Basic","initialProofState":"R : Type u_1\ninst✝³ : CommRing R\nA : Type u_4\ninst✝² : CommRing A\ninst✝¹ : Algebra R A\ninst✝ : Algebra.FormallyUnramified R A\nI : Ideal A\n⊢ Algebra.FormallyUnramified R (HasQuotient.Quotient A I)","decl":"instance quotient {A} [CommRing A] [Algebra R A] [FormallyUnramified R A] (I : Ideal A) :\n    FormallyUnramified R (A ⧸ I) :=\n  FormallyUnramified.of_surjective (IsScalarTower.toAlgHom R A (A ⧸ I)) Ideal.Quotient.mk_surjective\n\n"}
{"name":"Algebra.FormallyUnramified.iff_of_equiv","module":"Mathlib.RingTheory.Unramified.Basic","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\nA : Type u_2\nB : Type u_3\ninst✝³ : CommRing A\ninst✝² : Algebra R A\ninst✝¹ : CommRing B\ninst✝ : Algebra R B\ne : AlgEquiv R A B\n⊢ Iff (Algebra.FormallyUnramified R A) (Algebra.FormallyUnramified R B)","decl":"theorem iff_of_equiv (e : A ≃ₐ[R] B) : FormallyUnramified R A ↔ FormallyUnramified R B :=\n  ⟨fun _ ↦ of_equiv e, fun _ ↦ of_equiv e.symm⟩\n\n"}
{"name":"Algebra.FormallyUnramified.base_change","module":"Mathlib.RingTheory.Unramified.Basic","initialProofState":"R : Type u_1\ninst✝⁵ : CommRing R\nA : Type u_2\ninst✝⁴ : CommRing A\ninst✝³ : Algebra R A\nB : Type u_3\ninst✝² : CommRing B\ninst✝¹ : Algebra R B\ninst✝ : Algebra.FormallyUnramified R A\n⊢ Algebra.FormallyUnramified B (TensorProduct R B A)","decl":"instance base_change [FormallyUnramified R A] :\n    FormallyUnramified B (B ⊗[R] A) := by\n  rw [iff_comp_injective]\n  intro C _ _ I hI f₁ f₂ e\n  letI := ((algebraMap B C).comp (algebraMap R B)).toAlgebra\n  haveI : IsScalarTower R B C := IsScalarTower.of_algebraMap_eq' rfl\n  ext : 1\n  · subsingleton\n  · exact FormallyUnramified.ext I ⟨2, hI⟩ fun x => AlgHom.congr_fun e (1 ⊗ₜ x)\n\n"}
{"name":"Algebra.FormallyUnramified.of_isLocalization","module":"Mathlib.RingTheory.Unramified.Basic","initialProofState":"R : Type u_1\nRₘ : Type u_3\ninst✝³ : CommRing R\ninst✝² : CommRing Rₘ\nM : Submonoid R\ninst✝¹ : Algebra R Rₘ\ninst✝ : IsLocalization M Rₘ\n⊢ Algebra.FormallyUnramified R Rₘ","decl":"/-- This holds in general for epimorphisms. -/\ntheorem of_isLocalization [IsLocalization M Rₘ] : FormallyUnramified R Rₘ := by\n  rw [iff_comp_injective]\n  intro Q _ _ I _ f₁ f₂ _\n  apply AlgHom.coe_ringHom_injective\n  refine IsLocalization.ringHom_ext M ?_\n  ext\n  simp\n\n"}
{"name":"Algebra.FormallyUnramified.localization_base","module":"Mathlib.RingTheory.Unramified.Basic","initialProofState":"R : Type u_1\nRₘ : Type u_3\nSₘ : Type u_4\ninst✝⁷ : CommRing R\ninst✝⁶ : CommRing Rₘ\ninst✝⁵ : CommRing Sₘ\nM : Submonoid R\ninst✝⁴ : Algebra R Sₘ\ninst✝³ : Algebra R Rₘ\ninst✝² : Algebra Rₘ Sₘ\ninst✝¹ : IsScalarTower R Rₘ Sₘ\ninst✝ : Algebra.FormallyUnramified R Sₘ\n⊢ Algebra.FormallyUnramified Rₘ Sₘ","decl":"/-- This actually does not need the localization instance, and is stated here again for\nconsistency. See `Algebra.FormallyUnramified.of_comp` instead.\n\n The intended use is for copying proofs between `Formally{Unramified, Smooth, Etale}`\n without the need to change anything (including removing redundant arguments). -/\n-- @[nolint unusedArguments] -- Porting note: removed\ntheorem localization_base [FormallyUnramified R Sₘ] : FormallyUnramified Rₘ Sₘ :=\n  -- Porting note: added\n  let _ := M\n  FormallyUnramified.of_comp R Rₘ Sₘ\n\n"}
{"name":"Algebra.FormallyUnramified.localization_map","module":"Mathlib.RingTheory.Unramified.Basic","initialProofState":"R : Type u_1\nS : Type u_2\nRₘ : Type u_3\nSₘ : Type u_4\ninst✝¹² : CommRing R\ninst✝¹¹ : CommRing S\ninst✝¹⁰ : CommRing Rₘ\ninst✝⁹ : CommRing Sₘ\nM : Submonoid R\ninst✝⁸ : Algebra R S\ninst✝⁷ : Algebra R Sₘ\ninst✝⁶ : Algebra S Sₘ\ninst✝⁵ : Algebra R Rₘ\ninst✝⁴ : Algebra Rₘ Sₘ\ninst✝³ : IsScalarTower R Rₘ Sₘ\ninst✝² : IsScalarTower R S Sₘ\ninst✝¹ : IsLocalization (Submonoid.map (algebraMap R S) M) Sₘ\ninst✝ : Algebra.FormallyUnramified R S\n⊢ Algebra.FormallyUnramified Rₘ Sₘ","decl":"theorem localization_map [FormallyUnramified R S] :\n    FormallyUnramified Rₘ Sₘ := by\n  haveI : FormallyUnramified S Sₘ :=\n    FormallyUnramified.of_isLocalization (M.map (algebraMap R S))\n  haveI : FormallyUnramified R Sₘ := FormallyUnramified.comp R S Sₘ\n  exact FormallyUnramified.localization_base M\n\n"}
{"name":"Algebra.Unramified.finiteType","module":"Mathlib.RingTheory.Unramified.Basic","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nA : Type u_2\ninst✝¹ : CommRing A\ninst✝ : Algebra R A\nself : Algebra.Unramified R A\n⊢ Algebra.FiniteType R A","decl":"/-- An `R`-algebra `A` is unramified if it is formally unramified and of finite type. -/\n@[stacks 00UT \"Note that the Stacks project has a different definition of unramified, and tag\n<https://stacks.math.columbia.edu/tag/00UU> shows that their definition is the same as this one.\"]\nclass Unramified : Prop where\n  formallyUnramified : FormallyUnramified R A := by infer_instance\n  finiteType : FiniteType R A := by infer_instance\n\n"}
{"name":"Algebra.Unramified.formallyUnramified","module":"Mathlib.RingTheory.Unramified.Basic","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nA : Type u_2\ninst✝¹ : CommRing A\ninst✝ : Algebra R A\nself : Algebra.Unramified R A\n⊢ Algebra.FormallyUnramified R A","decl":"/-- An `R`-algebra `A` is unramified if it is formally unramified and of finite type. -/\n@[stacks 00UT \"Note that the Stacks project has a different definition of unramified, and tag\n<https://stacks.math.columbia.edu/tag/00UU> shows that their definition is the same as this one.\"]\nclass Unramified : Prop where\n  formallyUnramified : FormallyUnramified R A := by infer_instance\n  finiteType : FiniteType R A := by infer_instance\n\n"}
{"name":"Algebra.Unramified.of_equiv","module":"Mathlib.RingTheory.Unramified.Basic","initialProofState":"R : Type u_1\ninst✝⁵ : CommRing R\nA : Type u_2\nB : Type u_3\ninst✝⁴ : CommRing A\ninst✝³ : Algebra R A\ninst✝² : CommRing B\ninst✝¹ : Algebra R B\ninst✝ : Algebra.Unramified R A\ne : AlgEquiv R A B\n⊢ Algebra.Unramified R B","decl":"/-- Being unramified is transported via algebra isomorphisms. -/\ntheorem of_equiv [Unramified R A] (e : A ≃ₐ[R] B) : Unramified R B where\n  formallyUnramified := FormallyUnramified.of_equiv e\n  finiteType := FiniteType.equiv Unramified.finiteType e\n\n"}
{"name":"Algebra.Unramified.of_isLocalization_Away","module":"Mathlib.RingTheory.Unramified.Basic","initialProofState":"R : Type u_1\ninst✝³ : CommRing R\nA : Type u_2\ninst✝² : CommRing A\ninst✝¹ : Algebra R A\nr : R\ninst✝ : IsLocalization.Away r A\n⊢ Algebra.Unramified R A","decl":"/-- Localization at an element is unramified. -/\ntheorem of_isLocalization_Away (r : R) [IsLocalization.Away r A] : Unramified R A where\n  formallyUnramified := Algebra.FormallyUnramified.of_isLocalization (Submonoid.powers r)\n  finiteType :=\n    haveI : FinitePresentation R A := IsLocalization.Away.finitePresentation r\n    inferInstance\n\n"}
{"name":"Algebra.Unramified.comp","module":"Mathlib.RingTheory.Unramified.Basic","initialProofState":"R : Type u_1\ninst✝⁸ : CommRing R\nA : Type u_2\nB : Type u_3\ninst✝⁷ : CommRing A\ninst✝⁶ : Algebra R A\ninst✝⁵ : CommRing B\ninst✝⁴ : Algebra R B\ninst✝³ : Algebra A B\ninst✝² : IsScalarTower R A B\ninst✝¹ : Algebra.Unramified R A\ninst✝ : Algebra.Unramified A B\n⊢ Algebra.Unramified R B","decl":"/-- Unramified is stable under composition. -/\ntheorem comp [Algebra A B] [IsScalarTower R A B] [Unramified R A] [Unramified A B] :\n    Unramified R B where\n  formallyUnramified := FormallyUnramified.comp R A B\n  finiteType := FiniteType.trans (S := A) Unramified.finiteType\n    Unramified.finiteType\n\n"}
{"name":"Algebra.Unramified.baseChange","module":"Mathlib.RingTheory.Unramified.Basic","initialProofState":"R : Type u_1\ninst✝⁵ : CommRing R\nA : Type u_2\nB : Type u_3\ninst✝⁴ : CommRing A\ninst✝³ : Algebra R A\ninst✝² : CommRing B\ninst✝¹ : Algebra R B\ninst✝ : Algebra.Unramified R A\n⊢ Algebra.Unramified B (TensorProduct R B A)","decl":"/-- Unramified is stable under base change. -/\ninstance baseChange [Unramified R A] : Unramified B (B ⊗[R] A) where\n\n"}
