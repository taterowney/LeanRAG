{"name":"groupCohomology.resolution.actionDiagonalSucc_hom_apply","module":"Mathlib.RepresentationTheory.GroupCohomology.Resolution","initialProofState":"G : Type u\ninst✝ : Group G\nn : Nat\nf : Fin (HAdd.hAdd n 1) → G\n⊢ Eq ((groupCohomology.resolution.actionDiagonalSucc G n).hom.hom f) { fst := f 0, snd := fun i => HMul.hMul (Inv.inv (f i.castSucc)) (f i.succ) }","decl":"theorem actionDiagonalSucc_hom_apply {G : Type u} [Group G] {n : ℕ} (f : Fin (n + 1) → G) :\n    (actionDiagonalSucc G n).hom.hom f = (f 0, fun i => (f (Fin.castSucc i))⁻¹ * f i.succ) := by\n  induction' n with n hn\n  · exact Prod.ext rfl (funext fun x => Fin.elim0 x)\n  · refine Prod.ext rfl (funext fun x => ?_)\n    /- Porting note (https://github.com/leanprover-community/mathlib4/issues/11039): broken proof was\n    · dsimp only [actionDiagonalSucc]\n      simp only [Iso.trans_hom, comp_hom, types_comp_apply, diagonalSucc_hom_hom,\n        leftRegularTensorIso_hom_hom, tensorIso_hom, mkIso_hom_hom, Equiv.toIso_hom,\n        Action.tensorHom, Equiv.piFinSuccAbove_symm_apply, tensor_apply, types_id_apply,\n        tensor_rho, MonoidHom.one_apply, End.one_def, hn fun j : Fin (n + 1) => f j.succ,\n        Fin.insertNth_zero']\n      refine' Fin.cases (Fin.cons_zero _ _) (fun i => _) x\n      · simp only [Fin.cons_succ, mul_left_inj, inv_inj, Fin.castSucc_fin_succ] -/\n    dsimp [actionDiagonalSucc]\n    erw [hn (fun (j : Fin (n + 1)) => f j.succ)]\n    exact Fin.cases rfl (fun i => rfl) x\n\n"}
{"name":"groupCohomology.resolution.actionDiagonalSucc_inv_apply","module":"Mathlib.RepresentationTheory.GroupCohomology.Resolution","initialProofState":"G : Type u\ninst✝ : Group G\nn : Nat\ng : G\nf : Fin n → G\n⊢ Eq ((groupCohomology.resolution.actionDiagonalSucc G n).inv.hom { fst := g, snd := f }) (HSMul.hSMul g (Fin.partialProd f))","decl":"theorem actionDiagonalSucc_inv_apply {G : Type u} [Group G] {n : ℕ} (g : G) (f : Fin n → G) :\n    (actionDiagonalSucc G n).inv.hom (g, f) = (g • Fin.partialProd f : Fin (n + 1) → G) := by\n  revert g\n  induction' n with n hn\n  · intro g\n    funext (x : Fin 1)\n    simp only [Subsingleton.elim x 0, Pi.smul_apply, Fin.partialProd_zero, smul_eq_mul, mul_one]\n    rfl\n  · intro g\n    /- Porting note (https://github.com/leanprover-community/mathlib4/issues/11039): broken proof was\n    ext\n    dsimp only [actionDiagonalSucc]\n    simp only [Iso.trans_inv, comp_hom, hn, diagonalSucc_inv_hom, types_comp_apply, tensorIso_inv,\n      Iso.refl_inv, Action.tensorHom, id_hom, tensor_apply, types_id_apply,\n      leftRegularTensorIso_inv_hom, tensor_ρ, leftRegular_ρ_apply, Pi.smul_apply, smul_eq_mul]\n    refine' Fin.cases _ _ x\n    · simp only [Fin.cons_zero, Fin.partialProd_zero, mul_one]\n    · intro i\n      simpa only [Fin.cons_succ, Pi.smul_apply, smul_eq_mul, Fin.partialProd_succ', mul_assoc] -/\n    funext x\n    dsimp [actionDiagonalSucc]\n    erw [hn, Fin.consEquiv_apply]\n    refine Fin.cases ?_ (fun i => ?_) x\n    · simp only [Fin.insertNth_zero, Fin.cons_zero, Fin.partialProd_zero, mul_one]\n    · simp only [Fin.cons_succ, Pi.smul_apply, smul_eq_mul, Fin.partialProd_succ', ← mul_assoc]\n      rfl\n\n"}
{"name":"groupCohomology.resolution.diagonalSucc_hom_single","module":"Mathlib.RepresentationTheory.GroupCohomology.Resolution","initialProofState":"k G : Type u\ninst✝¹ : CommRing k\nn : Nat\ninst✝ : Group G\nf : Fin (HAdd.hAdd n 1) → G\na : k\n⊢ Eq ((CategoryTheory.ConcreteCategory.hom (groupCohomology.resolution.diagonalSucc k G n).hom.hom) (Finsupp.single f a)) (TensorProduct.tmul k (Finsupp.single (f 0) 1) (Finsupp.single (fun i => HMul.hMul (Inv.inv (f i.castSucc)) (f i.succ)) a))","decl":"theorem diagonalSucc_hom_single (f : Gⁿ⁺¹) (a : k) :\n    (diagonalSucc k G n).hom.hom (single f a) =\n      single (f 0) 1 ⊗ₜ single (fun i => (f (Fin.castSucc i))⁻¹ * f i.succ) a := by\n  dsimp [diagonalSucc]\n  erw [lmapDomain_apply, mapDomain_single, LinearEquiv.coe_toLinearMap, finsuppTensorFinsupp',\n    LinearEquiv.trans_symm, LinearEquiv.trans_apply, lcongr_symm, Equiv.refl_symm]\n  erw [lcongr_single]\n  rw [TensorProduct.lid_symm_apply, actionDiagonalSucc_hom_apply, finsuppTensorFinsupp_symm_single]\n  rfl\n\n"}
{"name":"groupCohomology.resolution.diagonalSucc_inv_single_single","module":"Mathlib.RepresentationTheory.GroupCohomology.Resolution","initialProofState":"k G : Type u\ninst✝¹ : CommRing k\nn : Nat\ninst✝ : Group G\ng : G\nf : Fin n → G\na b : k\n⊢ Eq ((CategoryTheory.ConcreteCategory.hom (groupCohomology.resolution.diagonalSucc k G n).inv.hom) (TensorProduct.tmul k (Finsupp.single g a) (Finsupp.single f b))) (Finsupp.single (HSMul.hSMul g (Fin.partialProd f)) (HMul.hMul a b))","decl":"theorem diagonalSucc_inv_single_single (g : G) (f : Gⁿ) (a b : k) :\n    (diagonalSucc k G n).inv.hom (Finsupp.single g a ⊗ₜ Finsupp.single f b) =\n      single (g • partialProd f) (a * b) := by\n/- Porting note (https://github.com/leanprover-community/mathlib4/issues/11039): broken proof was\n  dsimp only [diagonalSucc]\n  simp only [Iso.trans_inv, Iso.symm_inv, Iso.refl_inv, tensorIso_inv, Action.tensorHom,\n    Action.comp_hom, ModuleCat.comp_def, LinearMap.comp_apply, asIso_hom, Functor.mapIso_inv,\n    ModuleCat.MonoidalCategory.hom_apply, linearizationTrivialIso_inv_hom_apply,\n    linearization_μ_hom, Action.id_hom ((linearization k G).obj _), actionDiagonalSucc_inv_apply,\n    ModuleCat.id_apply, LinearEquiv.coe_toLinearMap,\n    finsuppTensorFinsupp'_single_tmul_single k (Action.leftRegular G).V,\n    linearization_map_hom_single (actionDiagonalSucc G n).inv (g, f) (a * b)] -/\n  change mapDomain (actionDiagonalSucc G n).inv.hom\n    (lcongr (Equiv.refl (G × (Fin n → G))) (TensorProduct.lid k k)\n      (finsuppTensorFinsupp k k k k G (Fin n → G) (single g a ⊗ₜ[k] single f b)))\n    = single (g • partialProd f) (a * b)\n  rw [finsuppTensorFinsupp_single, lcongr_single, mapDomain_single, Equiv.refl_apply,\n    actionDiagonalSucc_inv_apply]\n  rfl\n\n"}
{"name":"groupCohomology.resolution.diagonalSucc_inv_single_left","module":"Mathlib.RepresentationTheory.GroupCohomology.Resolution","initialProofState":"k G : Type u\ninst✝¹ : CommRing k\nn : Nat\ninst✝ : Group G\ng : G\nf : Finsupp (Fin n → G) k\nr : k\n⊢ Eq ((CategoryTheory.ConcreteCategory.hom (groupCohomology.resolution.diagonalSucc k G n).inv.hom) (TensorProduct.tmul k (Finsupp.single g r) f)) (((Finsupp.lift (Finsupp (Fin (HAdd.hAdd n 1) → G) k) k (Fin n → G)) fun f => Finsupp.single (HSMul.hSMul g (Fin.partialProd f)) r) f)","decl":"theorem diagonalSucc_inv_single_left (g : G) (f : Gⁿ →₀ k) (r : k) :\n    (diagonalSucc k G n).inv.hom (Finsupp.single g r ⊗ₜ f) =\n      Finsupp.lift (Gⁿ⁺¹ →₀ k) k Gⁿ (fun f => single (g • partialProd f) r) f := by\n  refine f.induction ?_ ?_\n  · simp only [TensorProduct.tmul_zero, map_zero]\n  · intro a b x _ _ hx\n    -- `simp` doesn't pick up on `diagonalSucc_inv_single_single` unless it has parentheses.\n    simp only [lift_apply, smul_single', mul_one, TensorProduct.tmul_add, map_add,\n      (diagonalSucc_inv_single_single), hx, Finsupp.sum_single_index, mul_comm b,\n      zero_mul, single_zero]\n\n"}
{"name":"groupCohomology.resolution.diagonalSucc_inv_single_right","module":"Mathlib.RepresentationTheory.GroupCohomology.Resolution","initialProofState":"k G : Type u\ninst✝¹ : CommRing k\nn : Nat\ninst✝ : Group G\ng : Finsupp G k\nf : Fin n → G\nr : k\n⊢ Eq ((CategoryTheory.ConcreteCategory.hom (groupCohomology.resolution.diagonalSucc k G n).inv.hom) (TensorProduct.tmul k g (Finsupp.single f r))) (((Finsupp.lift (Finsupp (Fin (HAdd.hAdd n 1) → G) k) k G) fun a => Finsupp.single (HSMul.hSMul a (Fin.partialProd f)) r) g)","decl":"theorem diagonalSucc_inv_single_right (g : G →₀ k) (f : Gⁿ) (r : k) :\n    (diagonalSucc k G n).inv.hom (g ⊗ₜ Finsupp.single f r) =\n      Finsupp.lift _ k G (fun a => single (a • partialProd f) r) g := by\n  refine g.induction ?_ ?_\n  · simp only [TensorProduct.zero_tmul, map_zero]\n  · intro a b x _ _ hx\n    -- `simp` doesn't pick up on `diagonalSucc_inv_single_single` unless it has parentheses.\n    simp only [lift_apply, smul_single', map_add, hx, (diagonalSucc_inv_single_single),\n      TensorProduct.add_tmul, Finsupp.sum_single_index, zero_mul, single_zero]\n\n"}
{"name":"groupCohomology.resolution.ofMulAction_free","module":"Mathlib.RepresentationTheory.GroupCohomology.Resolution","initialProofState":"k G : Type u\ninst✝¹ : CommRing k\nn : Nat\ninst✝ : Group G\n⊢ Module.Free (MonoidAlgebra k G) (Representation.ofMulAction k G (Fin (HAdd.hAdd n 1) → G)).asModule","decl":"theorem ofMulAction_free :\n    Module.Free (MonoidAlgebra k G) (ofMulAction k G (Fin (n + 1) → G)).asModule :=\n  Module.Free.of_basis (ofMulActionBasis k G n)\n\n"}
{"name":"Rep.diagonalHomEquiv_apply","module":"Mathlib.RepresentationTheory.GroupCohomology.Resolution","initialProofState":"k G : Type u\ninst✝¹ : CommRing k\nn : Nat\ninst✝ : Group G\nA : Rep k G\nf : Quiver.Hom (Rep.diagonal k G (HAdd.hAdd n 1)) A\nx : Fin n → G\n⊢ Eq ((Rep.diagonalHomEquiv n A) f x) ((CategoryTheory.ConcreteCategory.hom f.hom) (Finsupp.single (Fin.partialProd x) 1))","decl":"/-- Given a `k`-linear `G`-representation `A`, `diagonalHomEquiv` is a `k`-linear isomorphism of\nthe set of representation morphisms `Hom(k[Gⁿ⁺¹], A)` with `Fun(Gⁿ, A)`. This lemma says that this\nsends a morphism of representations `f : k[Gⁿ⁺¹] ⟶ A` to the function\n`(g₁, ..., gₙ) ↦ f(1, g₁, g₁g₂, ..., g₁g₂...gₙ).` -/\ntheorem diagonalHomEquiv_apply (f : Rep.diagonal k G (n + 1) ⟶ A) (x : Fin n → G) :\n    diagonalHomEquiv n A f x = f.hom (Finsupp.single (Fin.partialProd x) 1) := by\n/- Porting note (https://github.com/leanprover-community/mathlib4/issues/11039): broken proof was\n  unfold diagonalHomEquiv\n  simpa only [LinearEquiv.trans_apply, Rep.leftRegularHomEquiv_apply,\n    MonoidalClosed.linearHomEquivComm_hom, Finsupp.llift_symm_apply, TensorProduct.curry_apply,\n    Linear.homCongr_apply, Iso.refl_hom, Iso.trans_inv, Action.comp_hom, ModuleCat.comp_def,\n    LinearMap.comp_apply, Representation.repOfTprodIso_inv_apply,\n    diagonalSucc_inv_single_single (1 : G) x, one_smul, one_mul] -/\n  change f.hom ((diagonalSucc k G n).inv.hom (Finsupp.single 1 1 ⊗ₜ[k] Finsupp.single x 1)) = _\n  rw [diagonalSucc_inv_single_single, one_smul, one_mul]\n\n"}
{"name":"Rep.diagonalHomEquiv_symm_apply","module":"Mathlib.RepresentationTheory.GroupCohomology.Resolution","initialProofState":"k G : Type u\ninst✝¹ : CommRing k\nn : Nat\ninst✝ : Group G\nA : Rep k G\nf : (Fin n → G) → CoeSort.coe A\nx : Fin (HAdd.hAdd n 1) → G\n⊢ Eq ((CategoryTheory.ConcreteCategory.hom ((Rep.diagonalHomEquiv n A).symm f).hom) (Finsupp.single x 1)) ((A.ρ (x 0)) (f fun i => HMul.hMul (Inv.inv (x i.castSucc)) (x i.succ)))","decl":"/-- Given a `k`-linear `G`-representation `A`, `diagonalHomEquiv` is a `k`-linear isomorphism of\nthe set of representation morphisms `Hom(k[Gⁿ⁺¹], A)` with `Fun(Gⁿ, A)`. This lemma says that the\ninverse map sends a function `f : Gⁿ → A` to the representation morphism sending\n`(g₀, ... gₙ) ↦ ρ(g₀)(f(g₀⁻¹g₁, g₁⁻¹g₂, ..., gₙ₋₁⁻¹gₙ))`, where `ρ` is the representation attached\nto `A`. -/\ntheorem diagonalHomEquiv_symm_apply (f : (Fin n → G) → A) (x : Fin (n + 1) → G) :\n    ((diagonalHomEquiv n A).symm f).hom (Finsupp.single x 1) =\n      A.ρ (x 0) (f fun i : Fin n => (x (Fin.castSucc i))⁻¹ * x i.succ) := by\n  unfold diagonalHomEquiv\n/- Porting note (https://github.com/leanprover-community/mathlib4/issues/11039): broken proof was\n  simp only [LinearEquiv.trans_symm, LinearEquiv.symm_symm, LinearEquiv.trans_apply,\n    Rep.leftRegularHomEquiv_symm_apply, Linear.homCongr_symm_apply, Action.comp_hom, Iso.refl_inv,\n    Category.comp_id, Rep.MonoidalClosed.linearHomEquivComm_symm_hom, Iso.trans_hom,\n    ModuleCat.comp_def, LinearMap.comp_apply, Representation.repOfTprodIso_apply,\n    diagonalSucc_hom_single x (1 : k), TensorProduct.uncurry_apply, Rep.leftRegularHom_hom,\n    Finsupp.lift_apply, ihom_obj_ρ_def, Rep.ihom_obj_ρ_apply, Finsupp.sum_single_index, zero_smul,\n    one_smul, Rep.of_ρ, Rep.Action_ρ_eq_ρ, Rep.trivial_def (x 0)⁻¹, Finsupp.llift_apply A k k] -/\n  simp only [LinearEquiv.trans_symm, LinearEquiv.symm_symm, LinearEquiv.trans_apply,\n    leftRegularHomEquiv_symm_apply, Linear.homCongr_symm_apply, Iso.trans_hom, Iso.refl_inv,\n    Category.comp_id, Action.comp_hom, MonoidalClosed.linearHomEquivComm_symm_hom,\n    ModuleCat.hom_comp, LinearMap.comp_apply]\n  rw [diagonalSucc_hom_single]\n  -- The prototype linter that checks if `erw` could be replaced with `rw` would time out\n  -- if it replaces the next `erw`s with `rw`s. So we focus down on the relevant part.\n  conv_lhs =>\n    erw [TensorProduct.uncurry_apply, Finsupp.lift_apply, Finsupp.sum_single_index]\n    · simp only [one_smul]\n      erw [Representation.linHom_apply]\n      simp only [LinearMap.comp_apply, MonoidHom.one_apply, LinearMap.one_apply]\n      erw [Finsupp.llift_apply]\n      rw [Finsupp.lift_apply]\n      erw [Finsupp.sum_single_index]\n      · rw [one_smul]\n      · rw [zero_smul]\n    · rw [zero_smul]\n\n"}
{"name":"Rep.diagonalHomEquiv_symm_partialProd_succ","module":"Mathlib.RepresentationTheory.GroupCohomology.Resolution","initialProofState":"k G : Type u\ninst✝¹ : CommRing k\nn : Nat\ninst✝ : Group G\nA : Rep k G\nf : (Fin n → G) → CoeSort.coe A\ng : Fin (HAdd.hAdd n 1) → G\na : Fin (HAdd.hAdd n 1)\n⊢ Eq ((CategoryTheory.ConcreteCategory.hom ((Rep.diagonalHomEquiv n A).symm f).hom) (Finsupp.single (Function.comp (Fin.partialProd g) a.succ.succAbove) 1)) (f (a.contractNth (fun x1 x2 => HMul.hMul x1 x2) g))","decl":"/-- Auxiliary lemma for defining group cohomology, used to show that the isomorphism\n`diagonalHomEquiv` commutes with the differentials in two complexes which compute\ngroup cohomology. -/\ntheorem diagonalHomEquiv_symm_partialProd_succ (f : (Fin n → G) → A) (g : Fin (n + 1) → G)\n    (a : Fin (n + 1)) :\n    ((diagonalHomEquiv n A).symm f).hom (Finsupp.single (Fin.partialProd g ∘ a.succ.succAbove) 1)\n      = f (Fin.contractNth a (· * ·) g) := by\n  simp only [diagonalHomEquiv_symm_apply, Function.comp_apply, Fin.succ_succAbove_zero,\n    Fin.partialProd_zero, map_one, Fin.succ_succAbove_succ, LinearMap.one_apply,\n    Fin.partialProd_succ]\n  congr\n  ext\n  rw [← Fin.partialProd_succ, Fin.inv_partialProd_mul_eq_contractNth]\n\n"}
{"name":"groupCohomology.resolution.d_of","module":"Mathlib.RepresentationTheory.GroupCohomology.Resolution","initialProofState":"k : Type u\ninst✝ : CommRing k\nG : Type u\nn : Nat\nc : Fin (HAdd.hAdd n 1) → G\n⊢ Eq ((groupCohomology.resolution.d k G n) (Finsupp.single c 1)) (Finset.univ.sum fun p => Finsupp.single (Function.comp c p.succAbove) (HPow.hPow (-1) ↑p))","decl":"@[simp]\ntheorem d_of {G : Type u} {n : ℕ} (c : Fin (n + 1) → G) :\n    d k G n (Finsupp.single c 1) =\n      Finset.univ.sum fun p : Fin (n + 1) =>\n        Finsupp.single (c ∘ p.succAbove) ((-1 : k) ^ (p : ℕ)) := by\n  simp [d]\n\n"}
{"name":"groupCohomology.resolution.x_projective","module":"Mathlib.RepresentationTheory.GroupCohomology.Resolution","initialProofState":"k : Type u\ninst✝¹ : CommRing k\nG : Type u\ninst✝ : Group G\nn : Nat\n⊢ CategoryTheory.Projective ((groupCohomology.resolution k G).X n)","decl":"instance x_projective (G : Type u) [Group G] (n : ℕ) :\n    Projective ((groupCohomology.resolution k G).X n) :=\n  Rep.equivalenceModuleMonoidAlgebra.toAdjunction.projective_of_map_projective _ <|\n    @ModuleCat.projective_of_free.{u} _ _\n      (ModuleCat.of (MonoidAlgebra k G) (Representation.ofMulAction k G (Fin (n + 1) → G)).asModule)\n      _ (ofMulActionBasis k G n)\n\n"}
{"name":"groupCohomology.resolution.d_eq","module":"Mathlib.RepresentationTheory.GroupCohomology.Resolution","initialProofState":"k G : Type u\ninst✝¹ : CommRing k\ninst✝ : Monoid G\nn : Nat\n⊢ Eq ((groupCohomology.resolution k G).d (HAdd.hAdd n 1) n).hom (ModuleCat.ofHom (groupCohomology.resolution.d k G (HAdd.hAdd n 1)))","decl":"/-- Simpler expression for the differential in the standard resolution of `k` as a\n`G`-representation. It sends `(g₀, ..., gₙ₊₁) ↦ ∑ (-1)ⁱ • (g₀, ..., ĝᵢ, ..., gₙ₊₁)`. -/\ntheorem d_eq (n : ℕ) : ((groupCohomology.resolution k G).d (n + 1) n).hom =\n    ModuleCat.ofHom (d k G (n + 1)) := by\n  ext : 1\n  refine Finsupp.lhom_ext' fun x => LinearMap.ext_ring ?_\n  dsimp [groupCohomology.resolution]\n/- Porting note (https://github.com/leanprover-community/mathlib4/issues/11039): broken proof was\n  simpa [← @intCast_smul k, simplicial_object.δ] -/\n  simp_rw [alternatingFaceMapComplex_obj_d, AlternatingFaceMapComplex.objD, SimplicialObject.δ,\n    Functor.comp_map, ← Int.cast_smul_eq_zsmul k ((-1) ^ _ : ℤ), Int.cast_pow, Int.cast_neg,\n    Int.cast_one, Action.sum_hom, Action.smul_hom, Rep.linearization_map_hom]\n  rw [ModuleCat.hom_sum, LinearMap.coeFn_sum, Fintype.sum_apply]\n  erw [d_of (k := k) x]\n/- Porting note: want to rewrite `LinearMap.smul_apply` but simp/simp_rw won't do it; I need erw,\nso using Finset.sum_congr to get rid of the binder -/\n  refine Finset.sum_congr rfl fun _ _ => ?_\n  simp only [ModuleCat.hom_smul, SimplexCategory.len_mk, ModuleCat.hom_ofHom]\n  erw [LinearMap.smul_apply]\n  rw [Finsupp.lmapDomain_apply, Finsupp.mapDomain_single, Finsupp.smul_single', mul_one]\n  rfl\n\n"}
{"name":"groupCohomology.resolution.forget₂ToModuleCatHomotopyEquiv_f_0_eq","module":"Mathlib.RepresentationTheory.GroupCohomology.Resolution","initialProofState":"k G : Type u\ninst✝¹ : CommRing k\ninst✝ : Monoid G\n⊢ Eq ((groupCohomology.resolution.forget₂ToModuleCatHomotopyEquiv k G).hom.f 0) ((CategoryTheory.forget₂ (Rep k G) (ModuleCat k)).map (groupCohomology.resolution.ε k G))","decl":"/-- The homotopy equivalence of complexes of `k`-modules between the standard resolution of `k` as\na trivial `G`-representation, and the complex which is `k` at 0 and 0 everywhere else, acts as\n`∑ nᵢgᵢ ↦ ∑ nᵢ : k[G¹] → k` at 0. -/\ntheorem forget₂ToModuleCatHomotopyEquiv_f_0_eq :\n    (forget₂ToModuleCatHomotopyEquiv k G).1.f 0 = (forget₂ (Rep k G) _).map (ε k G) := by\n  show (HomotopyEquiv.hom _ ≫ HomotopyEquiv.hom _ ≫ HomotopyEquiv.hom _).f 0 = _\n  simp only [HomologicalComplex.comp_f]\n  dsimp\n  convert Category.id_comp (X := (forget₂ToModuleCat k G).X 0) _\n  · dsimp only [HomotopyEquiv.ofIso, compForgetAugmentedIso]\n    simp only [Iso.symm_hom, eqToIso.inv, HomologicalComplex.eqToHom_f, eqToHom_refl]\n  ext : 1\n  trans (linearCombination _ fun _ => (1 : k)).comp ((ModuleCat.free k).map (terminal.from _)).hom\n  · erw [Finsupp.lmapDomain_linearCombination (α := Fin 1 → G) (R := k) (α' := ⊤_ Type u)\n        (v := fun _ => (1 : k)) (v' := fun _ => (1 : k))\n        (terminal.from\n          ((classifyingSpaceUniversalCover G).obj (Opposite.op (SimplexCategory.mk 0))).V)\n        LinearMap.id fun i => rfl,\n      LinearMap.id_comp]\n    rfl\n  · rw [ModuleCat.hom_comp]\n    congr\n    · ext x\n      dsimp (config := { unfoldPartialApp := true }) [HomotopyEquiv.ofIso,\n        Finsupp.LinearEquiv.finsuppUnique]\n      rw [@Unique.eq_default _ Types.terminalIso.toEquiv.unique x]\n      simp\n    · exact @Subsingleton.elim _ (@Unique.instSubsingleton _ (Limits.uniqueToTerminal _)) _ _\n\n"}
{"name":"groupCohomology.resolution.d_comp_ε","module":"Mathlib.RepresentationTheory.GroupCohomology.Resolution","initialProofState":"k G : Type u\ninst✝¹ : CommRing k\ninst✝ : Monoid G\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((groupCohomology.resolution k G).d 1 0) (groupCohomology.resolution.ε k G)) 0","decl":"theorem d_comp_ε : (groupCohomology.resolution k G).d 1 0 ≫ ε k G = 0 := by\n  ext : 1\n  refine ModuleCat.hom_ext <| LinearMap.ext fun x => ?_\n  have : (forget₂ToModuleCat k G).d 1 0\n      ≫ (forget₂ (Rep k G) (ModuleCat.{u} k)).map (ε k G) = 0 := by\n    rw [← forget₂ToModuleCatHomotopyEquiv_f_0_eq,\n      ← (forget₂ToModuleCatHomotopyEquiv k G).1.2 1 0 rfl]\n    exact comp_zero\n  exact LinearMap.ext_iff.1 (ModuleCat.hom_ext_iff.mp this) _\n\n"}
{"name":"groupCohomology.resolution.εToSingle₀_comp_eq","module":"Mathlib.RepresentationTheory.GroupCohomology.Resolution","initialProofState":"k G : Type u\ninst✝¹ : CommRing k\ninst✝ : Monoid G\n⊢ Eq (CategoryTheory.CategoryStruct.comp (((CategoryTheory.forget₂ (Rep k G) (ModuleCat k)).mapHomologicalComplex (ComplexShape.down Nat)).map (groupCohomology.resolution.εToSingle₀ k G)) ((HomologicalComplex.singleMapHomologicalComplex (CategoryTheory.forget₂ (Rep k G) (ModuleCat k)) (ComplexShape.down Nat) 0).hom.app (Rep.trivial k G k))) (groupCohomology.resolution.forget₂ToModuleCatHomotopyEquiv k G).hom","decl":"theorem εToSingle₀_comp_eq :\n    ((forget₂ _ (ModuleCat.{u} k)).mapHomologicalComplex _).map (εToSingle₀ k G) ≫\n        (HomologicalComplex.singleMapHomologicalComplex _ _ _).hom.app _ =\n      (forget₂ToModuleCatHomotopyEquiv k G).hom := by\n  dsimp\n  ext1\n  dsimp\n  simpa using (forget₂ToModuleCatHomotopyEquiv_f_0_eq k G).symm\n\n"}
{"name":"groupCohomology.resolution.quasiIso_forget₂_εToSingle₀","module":"Mathlib.RepresentationTheory.GroupCohomology.Resolution","initialProofState":"k G : Type u\ninst✝¹ : CommRing k\ninst✝ : Monoid G\n⊢ QuasiIso (((CategoryTheory.forget₂ (Rep k G) (ModuleCat k)).mapHomologicalComplex (ComplexShape.down Nat)).map (groupCohomology.resolution.εToSingle₀ k G))","decl":"theorem quasiIso_forget₂_εToSingle₀ :\n    QuasiIso (((forget₂ _ (ModuleCat.{u} k)).mapHomologicalComplex _).map (εToSingle₀ k G)) := by\n  have h : QuasiIso (forget₂ToModuleCatHomotopyEquiv k G).hom := inferInstance\n  rw [← εToSingle₀_comp_eq k G] at h\n  exact quasiIso_of_comp_right (hφφ' := h)\n\n"}
{"name":"groupCohomology.resolution.instQuasiIsoNatRepεToSingle₀","module":"Mathlib.RepresentationTheory.GroupCohomology.Resolution","initialProofState":"k G : Type u\ninst✝¹ : CommRing k\ninst✝ : Monoid G\n⊢ QuasiIso (groupCohomology.resolution.εToSingle₀ k G)","decl":"instance : QuasiIso (εToSingle₀ k G) := by\n  rw [← HomologicalComplex.quasiIso_map_iff_of_preservesHomology _ (forget₂ _ (ModuleCat.{u} k))]\n  apply quasiIso_forget₂_εToSingle₀\n\n"}
{"name":"instEnoughProjectivesRep","module":"Mathlib.RepresentationTheory.GroupCohomology.Resolution","initialProofState":"k G : Type u\ninst✝¹ : CommRing k\ninst✝ : Group G\n⊢ CategoryTheory.EnoughProjectives (Rep k G)","decl":"instance : EnoughProjectives (Rep k G) :=\n  Rep.equivalenceModuleMonoidAlgebra.enoughProjectives_iff.2\n    ModuleCat.moduleCat_enoughProjectives.{u}\n\n"}
