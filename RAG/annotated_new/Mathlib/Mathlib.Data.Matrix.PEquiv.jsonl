{"name":"PEquiv.toMatrix_apply","module":"Mathlib.Data.Matrix.PEquiv","initialProofState":"m : Type u_3\nn : Type u_4\nα : Type u_5\ninst✝² : DecidableEq n\ninst✝¹ : Zero α\ninst✝ : One α\nf : PEquiv m n\ni : m\nj : n\n⊢ Eq (f.toMatrix i j) (ite (Membership.mem (f i) j) 1 0)","decl":"@[simp]\ntheorem toMatrix_apply [DecidableEq n] [Zero α] [One α] (f : m ≃. n) (i j) :\n    toMatrix f i j = if j ∈ f i then (1 : α) else 0 :=\n  rfl\n\n"}
{"name":"PEquiv.toMatrix_mul_apply","module":"Mathlib.Data.Matrix.PEquiv","initialProofState":"l : Type u_2\nm : Type u_3\nn : Type u_4\nα : Type u_5\ninst✝² : Fintype m\ninst✝¹ : DecidableEq m\ninst✝ : Semiring α\nf : PEquiv l m\nM : Matrix m n α\ni : l\nj : n\n⊢ Eq (HMul.hMul f.toMatrix M i j) (Option.casesOn (f i) 0 fun fi => M fi j)","decl":"theorem toMatrix_mul_apply [Fintype m] [DecidableEq m] [Semiring α] (f : l ≃. m) (M : Matrix m n α)\n    (i j) : (f.toMatrix * M :) i j = Option.casesOn (f i) 0 fun fi => M fi j := by\n  dsimp [toMatrix, Matrix.mul_apply]\n  cases' h : f i with fi\n  · simp [h]\n  · rw [Finset.sum_eq_single fi] <;> simp +contextual [h, eq_comm]\n\n"}
{"name":"PEquiv.mul_matrix_apply","module":"Mathlib.Data.Matrix.PEquiv","initialProofState":"l : Type u_2\nm : Type u_3\nn : Type u_4\nα : Type u_5\ninst✝² : Fintype m\ninst✝¹ : DecidableEq m\ninst✝ : Semiring α\nf : PEquiv l m\nM : Matrix m n α\ni : l\nj : n\n⊢ Eq (HMul.hMul f.toMatrix M i j) (Option.casesOn (f i) 0 fun fi => M fi j)","decl":"@[deprecated (since := \"2025-01-27\")] alias mul_matrix_apply := toMatrix_mul_apply\n\n"}
{"name":"PEquiv.mul_toMatrix_apply","module":"Mathlib.Data.Matrix.PEquiv","initialProofState":"l : Type u_2\nm : Type u_3\nn : Type u_4\nα : Type u_5\ninst✝² : Fintype m\ninst✝¹ : Semiring α\ninst✝ : DecidableEq n\nM : Matrix l m α\nf : PEquiv m n\ni : l\nj : n\n⊢ Eq (HMul.hMul M f.toMatrix i j) (Option.casesOn (f.symm j) 0 (M i))","decl":"theorem mul_toMatrix_apply [Fintype m] [Semiring α] [DecidableEq n] (M : Matrix l m α) (f : m ≃. n)\n    (i j) : (M * f.toMatrix :) i j = Option.casesOn (f.symm j) 0 (M i) := by\n  dsimp [Matrix.mul_apply, toMatrix_apply]\n  cases' h : f.symm j with fj\n  · simp [h, ← f.eq_some_iff]\n  · rw [Finset.sum_eq_single fj]\n    · simp [h, ← f.eq_some_iff]\n    · rintro b - n\n      simp [h, ← f.eq_some_iff, n.symm]\n    · simp\n\n"}
{"name":"PEquiv.matrix_mul_apply","module":"Mathlib.Data.Matrix.PEquiv","initialProofState":"l : Type u_2\nm : Type u_3\nn : Type u_4\nα : Type u_5\ninst✝² : Fintype m\ninst✝¹ : Semiring α\ninst✝ : DecidableEq n\nM : Matrix l m α\nf : PEquiv m n\ni : l\nj : n\n⊢ Eq (HMul.hMul M f.toMatrix i j) (Option.casesOn (f.symm j) 0 (M i))","decl":"@[deprecated (since := \"2025-01-27\")] alias matrix_mul_apply := mul_toMatrix_apply\n\n"}
{"name":"PEquiv.toMatrix_symm","module":"Mathlib.Data.Matrix.PEquiv","initialProofState":"m : Type u_3\nn : Type u_4\nα : Type u_5\ninst✝³ : DecidableEq m\ninst✝² : DecidableEq n\ninst✝¹ : Zero α\ninst✝ : One α\nf : PEquiv m n\n⊢ Eq f.symm.toMatrix f.toMatrix.transpose","decl":"theorem toMatrix_symm [DecidableEq m] [DecidableEq n] [Zero α] [One α] (f : m ≃. n) :\n    (f.symm.toMatrix : Matrix n m α) = f.toMatrixᵀ := by\n  ext\n  simp only [transpose, mem_iff_mem f, toMatrix_apply]\n  congr\n\n"}
{"name":"PEquiv.toMatrix_refl","module":"Mathlib.Data.Matrix.PEquiv","initialProofState":"n : Type u_4\nα : Type u_5\ninst✝² : DecidableEq n\ninst✝¹ : Zero α\ninst✝ : One α\n⊢ Eq (PEquiv.refl n).toMatrix 1","decl":"@[simp]\ntheorem toMatrix_refl [DecidableEq n] [Zero α] [One α] :\n    ((PEquiv.refl n).toMatrix : Matrix n n α) = 1 := by\n  ext\n  simp [toMatrix_apply, one_apply]\n\n"}
{"name":"PEquiv.toMatrix_toPEquiv_apply","module":"Mathlib.Data.Matrix.PEquiv","initialProofState":"m : Type u_3\nn : Type u_4\nα : Type u_5\ninst✝² : DecidableEq n\ninst✝¹ : Zero α\ninst✝ : One α\nf : Equiv m n\ni : m\n⊢ Eq (f.toPEquiv.toMatrix i) (Pi.single (f i) 1)","decl":"@[simp]\ntheorem toMatrix_toPEquiv_apply [DecidableEq n] [Zero α] [One α] (f : m ≃ n) (i) :\n    f.toPEquiv.toMatrix i = Pi.single (f i) (1 : α) := by\n  ext\n  simp [toMatrix_apply, Pi.single_apply, eq_comm]\n\n"}
{"name":"PEquiv.transpose_toMatrix_toPEquiv_apply","module":"Mathlib.Data.Matrix.PEquiv","initialProofState":"m : Type u_3\nn : Type u_4\nα : Type u_5\ninst✝³ : DecidableEq m\ninst✝² : DecidableEq n\ninst✝¹ : Zero α\ninst✝ : One α\nf : Equiv m n\nj : n\n⊢ Eq (f.toPEquiv.toMatrix.transpose j) (Pi.single (f.symm j) 1)","decl":"@[simp]\ntheorem transpose_toMatrix_toPEquiv_apply\n    [DecidableEq m] [DecidableEq n] [Zero α] [One α] (f : m ≃ n) (j) :\n    f.toPEquiv.toMatrixᵀ j = Pi.single (f.symm j) (1 : α) := by\n  ext\n  simp [toMatrix_apply, Pi.single_apply, eq_comm, ← Equiv.apply_eq_iff_eq_symm_apply]\n\n"}
{"name":"PEquiv.toMatrix_toPEquiv_mul","module":"Mathlib.Data.Matrix.PEquiv","initialProofState":"l : Type u_2\nm : Type u_3\nn : Type u_4\nα : Type u_5\ninst✝² : Fintype m\ninst✝¹ : DecidableEq m\ninst✝ : Semiring α\nf : Equiv l m\nM : Matrix m n α\n⊢ Eq (HMul.hMul f.toPEquiv.toMatrix M) (M.submatrix (⇑f) id)","decl":"theorem toMatrix_toPEquiv_mul [Fintype m] [DecidableEq m]\n    [Semiring α] (f : l ≃ m) (M : Matrix m n α) :\n    f.toPEquiv.toMatrix * M = M.submatrix f id := by\n  ext i j\n  rw [toMatrix_mul_apply, Equiv.toPEquiv_apply, submatrix_apply, id]\n\n"}
{"name":"PEquiv.toPEquiv_mul_matrix","module":"Mathlib.Data.Matrix.PEquiv","initialProofState":"l : Type u_2\nm : Type u_3\nn : Type u_4\nα : Type u_5\ninst✝² : Fintype m\ninst✝¹ : DecidableEq m\ninst✝ : Semiring α\nf : Equiv l m\nM : Matrix m n α\n⊢ Eq (HMul.hMul f.toPEquiv.toMatrix M) (M.submatrix (⇑f) id)","decl":"@[deprecated (since := \"2025-01-27\")] alias toPEquiv_mul_matrix := toMatrix_toPEquiv_mul\n\n"}
{"name":"PEquiv.mul_toMatrix_toPEquiv","module":"Mathlib.Data.Matrix.PEquiv","initialProofState":"l : Type u_2\nm : Type u_3\nn : Type u_4\nα : Type u_5\ninst✝² : Fintype m\ninst✝¹ : DecidableEq n\ninst✝ : Semiring α\nM : Matrix l m α\nf : Equiv m n\n⊢ Eq (HMul.hMul M f.toPEquiv.toMatrix) (M.submatrix id ⇑f.symm)","decl":"theorem mul_toMatrix_toPEquiv [Fintype m] [DecidableEq n]\n    [Semiring α] (M : Matrix l m α) (f : m ≃ n) :\n    (M * f.toPEquiv.toMatrix) = M.submatrix id f.symm :=\n  Matrix.ext fun i j => by\n    rw [PEquiv.mul_toMatrix_apply, ← Equiv.toPEquiv_symm, Equiv.toPEquiv_apply,\n      Matrix.submatrix_apply, id]\n\n"}
{"name":"PEquiv.mul_toPEquiv_toMatrix","module":"Mathlib.Data.Matrix.PEquiv","initialProofState":"l : Type u_2\nm : Type u_3\nn : Type u_4\nα : Type u_5\ninst✝² : Fintype m\ninst✝¹ : DecidableEq n\ninst✝ : Semiring α\nM : Matrix l m α\nf : Equiv m n\n⊢ Eq (HMul.hMul M f.toPEquiv.toMatrix) (M.submatrix id ⇑f.symm)","decl":"@[deprecated (since := \"2025-01-27\")] alias mul_toPEquiv_toMatrix := mul_toMatrix_toPEquiv\n\n"}
{"name":"PEquiv.toMatrix_toPEquiv_mulVec","module":"Mathlib.Data.Matrix.PEquiv","initialProofState":"m : Type u_3\nn : Type u_4\nα : Type u_5\ninst✝² : DecidableEq n\ninst✝¹ : Fintype n\ninst✝ : NonAssocSemiring α\nσ : Equiv m n\na : n → α\n⊢ Eq (σ.toPEquiv.toMatrix.mulVec a) (Function.comp a ⇑σ)","decl":"lemma toMatrix_toPEquiv_mulVec [DecidableEq n] [Fintype n]\n    [NonAssocSemiring α] (σ : m ≃ n) (a : n → α) :\n    σ.toPEquiv.toMatrix *ᵥ a = a ∘ σ := by\n  ext j\n  simp [toMatrix, mulVec, dotProduct]\n\n"}
{"name":"PEquiv.vecMul_toMatrix_toPEquiv","module":"Mathlib.Data.Matrix.PEquiv","initialProofState":"m : Type u_3\nn : Type u_4\nα : Type u_5\ninst✝² : DecidableEq n\ninst✝¹ : Fintype m\ninst✝ : NonAssocSemiring α\nσ : Equiv m n\na : m → α\n⊢ Eq (Matrix.vecMul a σ.toPEquiv.toMatrix) (Function.comp a ⇑σ.symm)","decl":"lemma vecMul_toMatrix_toPEquiv [DecidableEq n] [Fintype m]\n    [NonAssocSemiring α] (σ : m ≃ n) (a : m → α) :\n    a ᵥ* σ.toPEquiv.toMatrix = a ∘ σ.symm := by\n  classical\n  ext j\n  simp [toMatrix, σ.apply_eq_iff_eq_symm_apply, vecMul, dotProduct]\n\n"}
{"name":"PEquiv.toMatrix_trans","module":"Mathlib.Data.Matrix.PEquiv","initialProofState":"l : Type u_2\nm : Type u_3\nn : Type u_4\nα : Type u_5\ninst✝³ : Fintype m\ninst✝² : DecidableEq m\ninst✝¹ : DecidableEq n\ninst✝ : Semiring α\nf : PEquiv l m\ng : PEquiv m n\n⊢ Eq (f.trans g).toMatrix (HMul.hMul f.toMatrix g.toMatrix)","decl":"theorem toMatrix_trans [Fintype m] [DecidableEq m] [DecidableEq n] [Semiring α] (f : l ≃. m)\n    (g : m ≃. n) : ((f.trans g).toMatrix : Matrix l n α) = f.toMatrix * g.toMatrix := by\n  ext i j\n  rw [toMatrix_mul_apply]\n  dsimp [toMatrix, PEquiv.trans]\n  cases f i <;> simp\n\n"}
{"name":"PEquiv.toMatrix_bot","module":"Mathlib.Data.Matrix.PEquiv","initialProofState":"m : Type u_3\nn : Type u_4\nα : Type u_5\ninst✝² : DecidableEq n\ninst✝¹ : Zero α\ninst✝ : One α\n⊢ Eq Bot.bot.toMatrix 0","decl":"@[simp]\ntheorem toMatrix_bot [DecidableEq n] [Zero α] [One α] :\n    ((⊥ : PEquiv m n).toMatrix : Matrix m n α) = 0 :=\n  rfl\n\n"}
{"name":"PEquiv.toMatrix_injective","module":"Mathlib.Data.Matrix.PEquiv","initialProofState":"m : Type u_3\nn : Type u_4\nα : Type u_5\ninst✝² : DecidableEq n\ninst✝¹ : MonoidWithZero α\ninst✝ : Nontrivial α\n⊢ Function.Injective PEquiv.toMatrix","decl":"theorem toMatrix_injective [DecidableEq n] [MonoidWithZero α] [Nontrivial α] :\n    Function.Injective (@toMatrix m n α _ _ _) := by\n  intro f g\n  refine not_imp_not.1 ?_\n  simp only [Matrix.ext_iff.symm, toMatrix_apply, PEquiv.ext_iff, not_forall, exists_imp]\n  intro i hi\n  use i\n  cases' hf : f i with fi\n  · cases' hg : g i with gi\n    · rw [hf, hg] at hi; exact (hi rfl).elim\n    · use gi\n      simp\n  · use fi\n    simp [hf.symm, Ne.symm hi]\n\n"}
{"name":"PEquiv.toMatrix_swap","module":"Mathlib.Data.Matrix.PEquiv","initialProofState":"n : Type u_4\nα : Type u_5\ninst✝¹ : DecidableEq n\ninst✝ : Ring α\ni j : n\n⊢ Eq (Equiv.toPEquiv (Equiv.swap i j)).toMatrix (HAdd.hAdd (HAdd.hAdd (HSub.hSub (HSub.hSub 1 (PEquiv.single i i).toMatrix) (PEquiv.single j j).toMatrix) (PEquiv.single i j).toMatrix) (PEquiv.single j i).toMatrix)","decl":"theorem toMatrix_swap [DecidableEq n] [Ring α] (i j : n) :\n    (Equiv.swap i j).toPEquiv.toMatrix =\n      (1 : Matrix n n α) - (single i i).toMatrix - (single j j).toMatrix + (single i j).toMatrix +\n        (single j i).toMatrix := by\n  ext\n  dsimp [toMatrix, single, Equiv.swap_apply_def, Equiv.toPEquiv, one_apply]\n  split_ifs <;> simp_all\n\n"}
{"name":"PEquiv.single_mul_single","module":"Mathlib.Data.Matrix.PEquiv","initialProofState":"k : Type u_1\nm : Type u_3\nn : Type u_4\nα : Type u_5\ninst✝⁴ : Fintype n\ninst✝³ : DecidableEq k\ninst✝² : DecidableEq m\ninst✝¹ : DecidableEq n\ninst✝ : Semiring α\na : m\nb : n\nc : k\n⊢ Eq (HMul.hMul (PEquiv.single a b).toMatrix (PEquiv.single b c).toMatrix) (PEquiv.single a c).toMatrix","decl":"@[simp]\ntheorem single_mul_single [Fintype n] [DecidableEq k] [DecidableEq m] [DecidableEq n] [Semiring α]\n    (a : m) (b : n) (c : k) :\n    ((single a b).toMatrix : Matrix _ _ α) * (single b c).toMatrix = (single a c).toMatrix := by\n  rw [← toMatrix_trans, single_trans_single]\n\n"}
{"name":"PEquiv.single_mul_single_of_ne","module":"Mathlib.Data.Matrix.PEquiv","initialProofState":"k : Type u_1\nm : Type u_3\nn : Type u_4\nα : Type u_5\ninst✝⁴ : Fintype n\ninst✝³ : DecidableEq n\ninst✝² : DecidableEq k\ninst✝¹ : DecidableEq m\ninst✝ : Semiring α\nb₁ b₂ : n\nhb : Ne b₁ b₂\na : m\nc : k\n⊢ Eq (HMul.hMul (PEquiv.single a b₁).toMatrix (PEquiv.single b₂ c).toMatrix) 0","decl":"theorem single_mul_single_of_ne [Fintype n] [DecidableEq n] [DecidableEq k] [DecidableEq m]\n    [Semiring α] {b₁ b₂ : n} (hb : b₁ ≠ b₂) (a : m) (c : k) :\n    (single a b₁).toMatrix * (single b₂ c).toMatrix = (0 : Matrix _ _ α) := by\n  rw [← toMatrix_trans, single_trans_single_of_ne hb, toMatrix_bot]\n\n"}
{"name":"PEquiv.single_mul_single_right","module":"Mathlib.Data.Matrix.PEquiv","initialProofState":"k : Type u_1\nl : Type u_2\nm : Type u_3\nn : Type u_4\nα : Type u_5\ninst✝⁵ : Fintype n\ninst✝⁴ : Fintype k\ninst✝³ : DecidableEq n\ninst✝² : DecidableEq k\ninst✝¹ : DecidableEq m\ninst✝ : Semiring α\na : m\nb : n\nc : k\nM : Matrix k l α\n⊢ Eq (HMul.hMul (PEquiv.single a b).toMatrix (HMul.hMul (PEquiv.single b c).toMatrix M)) (HMul.hMul (PEquiv.single a c).toMatrix M)","decl":"/-- Restatement of `single_mul_single`, which will simplify expressions in `simp` normal form,\n  when associativity may otherwise need to be carefully applied. -/\n@[simp]\ntheorem single_mul_single_right [Fintype n] [Fintype k] [DecidableEq n] [DecidableEq k]\n    [DecidableEq m] [Semiring α] (a : m) (b : n) (c : k) (M : Matrix k l α) :\n    (single a b).toMatrix * ((single b c).toMatrix * M) = (single a c).toMatrix * M := by\n  rw [← Matrix.mul_assoc, single_mul_single]\n\n"}
{"name":"PEquiv.toMatrix_toPEquiv_eq","module":"Mathlib.Data.Matrix.PEquiv","initialProofState":"n : Type u_4\nα : Type u_5\ninst✝² : DecidableEq n\ninst✝¹ : Zero α\ninst✝ : One α\nσ : Equiv.Perm n\n⊢ Eq (Equiv.toPEquiv σ).toMatrix (Matrix.submatrix 1 (⇑σ) id)","decl":"/-- We can also define permutation matrices by permuting the rows of the identity matrix. -/\ntheorem toMatrix_toPEquiv_eq [DecidableEq n] [Zero α] [One α] (σ : Equiv.Perm n) :\n    σ.toPEquiv.toMatrix = (1 : Matrix n n α).submatrix σ id :=\n  Matrix.ext fun _ _ => if_congr Option.some_inj rfl rfl\n\n"}
{"name":"PEquiv.equiv_toPEquiv_toMatrix","module":"Mathlib.Data.Matrix.PEquiv","initialProofState":"n : Type u_4\nα : Type u_5\ninst✝² : DecidableEq n\ninst✝¹ : Zero α\ninst✝ : One α\nσ : Equiv.Perm n\n⊢ Eq (Equiv.toPEquiv σ).toMatrix (Matrix.submatrix 1 (⇑σ) id)","decl":"@[deprecated (since := \"2025-01-27\")] alias equiv_toPEquiv_toMatrix := toMatrix_toPEquiv_eq\n\n"}
{"name":"PEquiv.map_toMatrix","module":"Mathlib.Data.Matrix.PEquiv","initialProofState":"m : Type u_3\nn : Type u_4\nα : Type u_5\nβ : Type u_6\ninst✝² : DecidableEq n\ninst✝¹ : NonAssocSemiring α\ninst✝ : NonAssocSemiring β\nf : RingHom α β\nσ : PEquiv m n\n⊢ Eq (σ.toMatrix.map ⇑f) σ.toMatrix","decl":"@[simp]\nlemma map_toMatrix [DecidableEq n] [NonAssocSemiring α] [NonAssocSemiring β]\n    (f : α →+* β) (σ : m ≃. n) : σ.toMatrix.map f = σ.toMatrix := by\n  ext i j\n  simp\n\n"}
