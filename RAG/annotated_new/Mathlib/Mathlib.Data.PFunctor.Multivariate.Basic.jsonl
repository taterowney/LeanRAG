{"name":"MvPFunctor.mk.injEq","module":"Mathlib.Data.PFunctor.Multivariate.Basic","initialProofState":"n : Nat\nA✝ : Type u\nB✝ : A✝ → TypeVec.{u} n\nA : Type u\nB : A → TypeVec.{u} n\n⊢ Eq (Eq { A := A✝, B := B✝ } { A := A, B := B }) (And (Eq A✝ A) (HEq B✝ B))","decl":"/-- multivariate polynomial functors\n-/\n@[pp_with_univ]\nstructure MvPFunctor (n : ℕ) where\n  /-- The head type -/\n  A : Type u\n  /-- The child family of types -/\n  B : A → TypeVec.{u} n\n\n"}
{"name":"MvPFunctor.mk.sizeOf_spec","module":"Mathlib.Data.PFunctor.Multivariate.Basic","initialProofState":"n : Nat\nA : Type u\nB : A → TypeVec.{u} n\n⊢ Eq (SizeOf.sizeOf { A := A, B := B }) (HAdd.hAdd 1 (SizeOf.sizeOf A))","decl":"/-- multivariate polynomial functors\n-/\n@[pp_with_univ]\nstructure MvPFunctor (n : ℕ) where\n  /-- The head type -/\n  A : Type u\n  /-- The child family of types -/\n  B : A → TypeVec.{u} n\n\n"}
{"name":"MvPFunctor.mk.inj","module":"Mathlib.Data.PFunctor.Multivariate.Basic","initialProofState":"n : Nat\nA✝ : Type u\nB✝ : A✝ → TypeVec.{u} n\nA : Type u\nB : A → TypeVec.{u} n\nx✝ : Eq { A := A✝, B := B✝ } { A := A, B := B }\n⊢ And (Eq A✝ A) (HEq B✝ B)","decl":"/-- multivariate polynomial functors\n-/\n@[pp_with_univ]\nstructure MvPFunctor (n : ℕ) where\n  /-- The head type -/\n  A : Type u\n  /-- The child family of types -/\n  B : A → TypeVec.{u} n\n\n"}
{"name":"MvPFunctor.map_eq","module":"Mathlib.Data.PFunctor.Multivariate.Basic","initialProofState":"n : Nat\nP : MvPFunctor.{u} n\nα β : TypeVec.{u} n\ng : α.Arrow β\na : P.A\nf : (P.B a).Arrow α\n⊢ Eq (MvFunctor.map g ⟨a, f⟩) ⟨a, TypeVec.comp g f⟩","decl":"theorem map_eq {α β : TypeVec n} (g : α ⟹ β) (a : P.A) (f : P.B a ⟹ α) :\n    @MvFunctor.map _ P.Obj _ _ _ g ⟨a, f⟩ = ⟨a, g ⊚ f⟩ :=\n  rfl\n\n"}
{"name":"MvPFunctor.id_map","module":"Mathlib.Data.PFunctor.Multivariate.Basic","initialProofState":"n : Nat\nP : MvPFunctor.{u} n\nα : TypeVec.{u} n\nx : ↑P α\n⊢ Eq (MvFunctor.map TypeVec.id x) x","decl":"theorem id_map {α : TypeVec n} : ∀ x : P α, TypeVec.id <$$> x = x\n  | ⟨_, _⟩ => rfl\n\n"}
{"name":"MvPFunctor.comp_map","module":"Mathlib.Data.PFunctor.Multivariate.Basic","initialProofState":"n : Nat\nP : MvPFunctor.{u} n\nα β γ : TypeVec.{u} n\nf : α.Arrow β\ng : β.Arrow γ\nx : ↑P α\n⊢ Eq (MvFunctor.map (TypeVec.comp g f) x) (MvFunctor.map g (MvFunctor.map f x))","decl":"theorem comp_map {α β γ : TypeVec n} (f : α ⟹ β) (g : β ⟹ γ) :\n    ∀ x : P α, (g ⊚ f) <$$> x = g <$$> f <$$> x\n  | ⟨_, _⟩ => rfl\n\n"}
{"name":"MvPFunctor.instLawfulMvFunctorObj","module":"Mathlib.Data.PFunctor.Multivariate.Basic","initialProofState":"n : Nat\nP : MvPFunctor.{u} n\n⊢ LawfulMvFunctor ↑P","decl":"instance : LawfulMvFunctor.{u} P.Obj where\n  id_map := @id_map _ P\n  comp_map := @comp_map _ P\n\n"}
{"name":"MvPFunctor.const.get_map","module":"Mathlib.Data.PFunctor.Multivariate.Basic","initialProofState":"n : Nat\nA : Type u\nα β : TypeVec.{u} n\nf : α.Arrow β\nx : ↑(MvPFunctor.const n A) α\n⊢ Eq (MvPFunctor.const.get (MvFunctor.map f x)) (MvPFunctor.const.get x)","decl":"@[simp]\ntheorem const.get_map (f : α ⟹ β) (x : const n A α) : const.get (f <$$> x) = const.get x := by\n  cases x\n  rfl\n\n"}
{"name":"MvPFunctor.const.get_mk","module":"Mathlib.Data.PFunctor.Multivariate.Basic","initialProofState":"n : Nat\nA : Type u\nα : TypeVec.{u} n\nx : A\n⊢ Eq (MvPFunctor.const.get (MvPFunctor.const.mk n x)) x","decl":"@[simp]\ntheorem const.get_mk (x : A) : const.get (const.mk n x : const n A α) = x := rfl\n\n"}
{"name":"MvPFunctor.const.mk_get","module":"Mathlib.Data.PFunctor.Multivariate.Basic","initialProofState":"n : Nat\nA : Type u\nα : TypeVec.{u} n\nx : ↑(MvPFunctor.const n A) α\n⊢ Eq (MvPFunctor.const.mk n (MvPFunctor.const.get x)) x","decl":"@[simp]\ntheorem const.mk_get (x : const n A α) : const.mk n (const.get x) = x := by\n  cases x\n  dsimp [const.get, const.mk]\n  congr with (_⟨⟩)\n\n"}
{"name":"MvPFunctor.comp.get_map","module":"Mathlib.Data.PFunctor.Multivariate.Basic","initialProofState":"n m : Nat\nP : MvPFunctor.{u} n\nQ : Fin2 n → MvPFunctor.{u} m\nα β : TypeVec.{u} m\nf : α.Arrow β\nx : ↑(P.comp Q) α\n⊢ Eq (MvPFunctor.comp.get (MvFunctor.map f x)) (MvFunctor.map (fun i x => MvFunctor.map f x) (MvPFunctor.comp.get x))","decl":"theorem comp.get_map (f : α ⟹ β) (x : comp P Q α) :\n    comp.get (f <$$> x) = (fun i (x : Q i α) => f <$$> x) <$$> comp.get x := by\n  rfl\n\n"}
{"name":"MvPFunctor.comp.get_mk","module":"Mathlib.Data.PFunctor.Multivariate.Basic","initialProofState":"n m : Nat\nP : MvPFunctor.{u} n\nQ : Fin2 n → MvPFunctor.{u} m\nα : TypeVec.{u} m\nx : ↑P fun i => ↑(Q i) α\n⊢ Eq (MvPFunctor.comp.get (MvPFunctor.comp.mk x)) x","decl":"@[simp]\ntheorem comp.get_mk (x : P (fun i => Q i α)) : comp.get (comp.mk x) = x := by\n  rfl\n\n"}
{"name":"MvPFunctor.comp.mk_get","module":"Mathlib.Data.PFunctor.Multivariate.Basic","initialProofState":"n m : Nat\nP : MvPFunctor.{u} n\nQ : Fin2 n → MvPFunctor.{u} m\nα : TypeVec.{u} m\nx : ↑(P.comp Q) α\n⊢ Eq (MvPFunctor.comp.mk (MvPFunctor.comp.get x)) x","decl":"@[simp]\ntheorem comp.mk_get (x : comp P Q α) : comp.mk (comp.get x) = x := by\n  rfl\n\n/-\nlifting predicates and relations\n-/\n"}
{"name":"MvPFunctor.liftP_iff","module":"Mathlib.Data.PFunctor.Multivariate.Basic","initialProofState":"n : Nat\nP : MvPFunctor.{u} n\nα : TypeVec.{u} n\np : ⦃i : Fin2 n⦄ → α i → Prop\nx : ↑P α\n⊢ Iff (MvFunctor.LiftP p x) (Exists fun a => Exists fun f => And (Eq x ⟨a, f⟩) (∀ (i : Fin2 n) (j : P.B a i), p (f i j)))","decl":"theorem liftP_iff {α : TypeVec n} (p : ∀ ⦃i⦄, α i → Prop) (x : P α) :\n    LiftP p x ↔ ∃ a f, x = ⟨a, f⟩ ∧ ∀ i j, p (f i j) := by\n  constructor\n  · rintro ⟨y, hy⟩\n    cases' h : y with a f\n    refine ⟨a, fun i j => (f i j).val, ?_, fun i j => (f i j).property⟩\n    rw [← hy, h, map_eq]\n    rfl\n  rintro ⟨a, f, xeq, pf⟩\n  use ⟨a, fun i j => ⟨f i j, pf i j⟩⟩\n  rw [xeq]; rfl\n\n"}
{"name":"MvPFunctor.liftP_iff'","module":"Mathlib.Data.PFunctor.Multivariate.Basic","initialProofState":"n : Nat\nP : MvPFunctor.{u} n\nα : TypeVec.{u} n\np : ⦃i : Fin2 n⦄ → α i → Prop\na : P.A\nf : (P.B a).Arrow α\n⊢ Iff (MvFunctor.LiftP p ⟨a, f⟩) (∀ (i : Fin2 n) (x : P.B a i), p (f i x))","decl":"theorem liftP_iff' {α : TypeVec n} (p : ∀ ⦃i⦄, α i → Prop) (a : P.A) (f : P.B a ⟹ α) :\n    @LiftP.{u} _ P.Obj _ α p ⟨a, f⟩ ↔ ∀ i x, p (f i x) := by\n  simp only [liftP_iff, Sigma.mk.inj_iff]; constructor\n  · rintro ⟨_, _, ⟨⟩, _⟩\n    assumption\n  · intro\n    repeat' first |constructor|assumption\n\n"}
{"name":"MvPFunctor.liftR_iff","module":"Mathlib.Data.PFunctor.Multivariate.Basic","initialProofState":"n : Nat\nP : MvPFunctor.{u} n\nα : TypeVec.{u} n\nr : ⦃i : Fin2 n⦄ → α i → α i → Prop\nx y : ↑P α\n⊢ Iff (MvFunctor.LiftR r x y) (Exists fun a => Exists fun f₀ => Exists fun f₁ => And (Eq x ⟨a, f₀⟩) (And (Eq y ⟨a, f₁⟩) (∀ (i : Fin2 n) (j : P.B a i), r (f₀ i j) (f₁ i j))))","decl":"theorem liftR_iff {α : TypeVec n} (r : ∀ ⦃i⦄, α i → α i → Prop) (x y : P α) :\n    LiftR @r x y ↔ ∃ a f₀ f₁, x = ⟨a, f₀⟩ ∧ y = ⟨a, f₁⟩ ∧ ∀ i j, r (f₀ i j) (f₁ i j) := by\n  constructor\n  · rintro ⟨u, xeq, yeq⟩\n    cases' h : u with a f\n    use a, fun i j => (f i j).val.fst, fun i j => (f i j).val.snd\n    constructor\n    · rw [← xeq, h]\n      rfl\n    constructor\n    · rw [← yeq, h]\n      rfl\n    intro i j\n    exact (f i j).property\n  rintro ⟨a, f₀, f₁, xeq, yeq, h⟩\n  use ⟨a, fun i j => ⟨(f₀ i j, f₁ i j), h i j⟩⟩\n  dsimp; constructor\n  · rw [xeq]\n    rfl\n  rw [yeq]; rfl\n\n"}
{"name":"MvPFunctor.supp_eq","module":"Mathlib.Data.PFunctor.Multivariate.Basic","initialProofState":"n : Nat\nP : MvPFunctor.{u} n\nα : TypeVec.{u} n\na : P.A\nf : (P.B a).Arrow α\ni : Fin2 n\n⊢ Eq (MvFunctor.supp ⟨a, f⟩ i) (Set.image (f i) Set.univ)","decl":"theorem supp_eq {α : TypeVec n} (a : P.A) (f : P.B a ⟹ α) (i) :\n    @supp.{u} _ P.Obj _ α (⟨a, f⟩ : P α) i = f i '' univ := by\n  ext x; simp only [supp, image_univ, mem_range, mem_setOf_eq]\n  constructor <;> intro h\n  · apply @h fun i x => ∃ y : P.B a i, f i y = x\n    rw [liftP_iff']\n    intros\n    exact ⟨_, rfl⟩\n  · simp only [liftP_iff']\n    cases h\n    subst x\n    tauto\n\n"}
