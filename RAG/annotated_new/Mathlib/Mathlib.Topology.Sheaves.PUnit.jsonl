{"name":"TopCat.Presheaf.isSheaf_of_isTerminal_of_indiscrete","module":"Mathlib.Topology.Sheaves.PUnit","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX : TopCat\nhind : Eq X.str Top.top\nF : TopCat.Presheaf C X\nit : CategoryTheory.Limits.IsTerminal (F.obj { unop := Bot.bot })\n⊢ F.IsSheaf","decl":"theorem isSheaf_of_isTerminal_of_indiscrete {X : TopCat.{w}} (hind : X.str = ⊤) (F : Presheaf C X)\n    (it : IsTerminal <| F.obj <| op ⊥) : F.IsSheaf := fun c U s hs => by\n  obtain rfl | hne := eq_or_ne U ⊥\n  · intro _ _\n    rw [@existsUnique_iff_exists _ ⟨fun _ _ => _⟩]\n    · refine ⟨it.from _, fun U hU hs => IsTerminal.hom_ext ?_ _ _⟩\n      rwa [le_bot_iff.1 hU.le]\n    · apply it.hom_ext\n  · convert Presieve.isSheafFor_top_sieve (F ⋙ coyoneda.obj (@op C c))\n    rw [← Sieve.id_mem_iff_eq_top]\n    have := (U.eq_bot_or_top hind).resolve_left hne\n    subst this\n    obtain he | ⟨⟨x⟩⟩ := isEmpty_or_nonempty X\n    · exact (hne <| SetLike.ext'_iff.2 <| Set.univ_eq_empty_iff.2 he).elim\n    obtain ⟨U, f, hf, hm⟩ := hs x _root_.trivial\n    obtain rfl | rfl := U.eq_bot_or_top hind\n    · cases hm\n    · convert hf\n\n"}
{"name":"TopCat.Presheaf.isSheaf_iff_isTerminal_of_indiscrete","module":"Mathlib.Topology.Sheaves.PUnit","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX : TopCat\nhind : Eq X.str Top.top\nF : TopCat.Presheaf C X\n⊢ Iff F.IsSheaf (Nonempty (CategoryTheory.Limits.IsTerminal (F.obj { unop := Bot.bot })))","decl":"theorem isSheaf_iff_isTerminal_of_indiscrete {X : TopCat.{w}} (hind : X.str = ⊤)\n    (F : Presheaf C X) : F.IsSheaf ↔ Nonempty (IsTerminal <| F.obj <| op ⊥) :=\n  ⟨fun h => ⟨Sheaf.isTerminalOfEmpty ⟨F, h⟩⟩, fun ⟨it⟩ =>\n    isSheaf_of_isTerminal_of_indiscrete hind F it⟩\n\n"}
{"name":"TopCat.Presheaf.isSheaf_on_punit_of_isTerminal","module":"Mathlib.Topology.Sheaves.PUnit","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nF : TopCat.Presheaf C (TopCat.of PUnit.{u_1 + 1})\nit : CategoryTheory.Limits.IsTerminal (F.obj { unop := Bot.bot })\n⊢ F.IsSheaf","decl":"theorem isSheaf_on_punit_of_isTerminal (F : Presheaf C (TopCat.of PUnit))\n    (it : IsTerminal <| F.obj <| op ⊥) : F.IsSheaf :=\n  isSheaf_of_isTerminal_of_indiscrete (@Subsingleton.elim (TopologicalSpace PUnit) _ _ _) F it\n\n"}
{"name":"TopCat.Presheaf.isSheaf_on_punit_iff_isTerminal","module":"Mathlib.Topology.Sheaves.PUnit","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nF : TopCat.Presheaf C (TopCat.of PUnit.{u_1 + 1})\n⊢ Iff F.IsSheaf (Nonempty (CategoryTheory.Limits.IsTerminal (F.obj { unop := Bot.bot })))","decl":"theorem isSheaf_on_punit_iff_isTerminal (F : Presheaf C (TopCat.of PUnit)) :\n    F.IsSheaf ↔ Nonempty (IsTerminal <| F.obj <| op ⊥) :=\n  ⟨fun h => ⟨Sheaf.isTerminalOfEmpty ⟨F, h⟩⟩, fun ⟨it⟩ => isSheaf_on_punit_of_isTerminal F it⟩\n\n"}
