{"name":"Monoid.CoprodI.Word.chain_ne","module":"Mathlib.GroupTheory.CoprodI","initialProofState":"ι : Type u_1\nM : ι → Type u_2\ninst✝ : (i : ι) → Monoid (M i)\nself : Monoid.CoprodI.Word M\n⊢ List.Chain' (fun l l' => Ne l.fst l'.fst) self.toList","decl":"/-- The type of reduced words. A reduced word cannot contain a letter `1`, and no two adjacent\nletters can come from the same summand. -/\n@[ext]\nstructure Word where\n  /-- A `Word` is a `List (Σ i, M i)`, such that `1` is not in the list, and no\n  two adjacent letters are from the same summand -/\n  toList : List (Σi, M i)\n  /-- A reduced word does not contain `1` -/\n  ne_one : ∀ l ∈ toList, Sigma.snd l ≠ 1\n  /-- Adjacent letters are not from the same summand. -/\n  chain_ne : toList.Chain' fun l l' => Sigma.fst l ≠ Sigma.fst l'\n\n"}
{"name":"Monoid.CoprodI.Word.ext_iff","module":"Mathlib.GroupTheory.CoprodI","initialProofState":"ι : Type u_1\nM : ι → Type u_2\ninst✝ : (i : ι) → Monoid (M i)\nx y : Monoid.CoprodI.Word M\n⊢ Iff (Eq x y) (Eq x.toList y.toList)","decl":"/-- The type of reduced words. A reduced word cannot contain a letter `1`, and no two adjacent\nletters can come from the same summand. -/\n@[ext]\nstructure Word where\n  /-- A `Word` is a `List (Σ i, M i)`, such that `1` is not in the list, and no\n  two adjacent letters are from the same summand -/\n  toList : List (Σi, M i)\n  /-- A reduced word does not contain `1` -/\n  ne_one : ∀ l ∈ toList, Sigma.snd l ≠ 1\n  /-- Adjacent letters are not from the same summand. -/\n  chain_ne : toList.Chain' fun l l' => Sigma.fst l ≠ Sigma.fst l'\n\n"}
{"name":"Monoid.CoprodI.Word.mk.inj","module":"Mathlib.GroupTheory.CoprodI","initialProofState":"ι : Type u_1\nM : ι → Type u_2\ninst✝ : (i : ι) → Monoid (M i)\ntoList✝ : List (Sigma fun i => M i)\nne_one✝ : ∀ (l : Sigma fun i => M i), Membership.mem toList✝ l → Ne l.snd 1\nchain_ne✝ : List.Chain' (fun l l' => Ne l.fst l'.fst) toList✝\ntoList : List (Sigma fun i => M i)\nne_one : ∀ (l : Sigma fun i => M i), Membership.mem toList l → Ne l.snd 1\nchain_ne : List.Chain' (fun l l' => Ne l.fst l'.fst) toList\nx✝ : Eq { toList := toList✝, ne_one := ne_one✝, chain_ne := chain_ne✝ } { toList := toList, ne_one := ne_one, chain_ne := chain_ne }\n⊢ Eq toList✝ toList","decl":"/-- The type of reduced words. A reduced word cannot contain a letter `1`, and no two adjacent\nletters can come from the same summand. -/\n@[ext]\nstructure Word where\n  /-- A `Word` is a `List (Σ i, M i)`, such that `1` is not in the list, and no\n  two adjacent letters are from the same summand -/\n  toList : List (Σi, M i)\n  /-- A reduced word does not contain `1` -/\n  ne_one : ∀ l ∈ toList, Sigma.snd l ≠ 1\n  /-- Adjacent letters are not from the same summand. -/\n  chain_ne : toList.Chain' fun l l' => Sigma.fst l ≠ Sigma.fst l'\n\n"}
{"name":"Monoid.CoprodI.Word.ext","module":"Mathlib.GroupTheory.CoprodI","initialProofState":"ι : Type u_1\nM : ι → Type u_2\ninst✝ : (i : ι) → Monoid (M i)\nx y : Monoid.CoprodI.Word M\ntoList : Eq x.toList y.toList\n⊢ Eq x y","decl":"/-- The type of reduced words. A reduced word cannot contain a letter `1`, and no two adjacent\nletters can come from the same summand. -/\n@[ext]\nstructure Word where\n  /-- A `Word` is a `List (Σ i, M i)`, such that `1` is not in the list, and no\n  two adjacent letters are from the same summand -/\n  toList : List (Σi, M i)\n  /-- A reduced word does not contain `1` -/\n  ne_one : ∀ l ∈ toList, Sigma.snd l ≠ 1\n  /-- Adjacent letters are not from the same summand. -/\n  chain_ne : toList.Chain' fun l l' => Sigma.fst l ≠ Sigma.fst l'\n\n"}
{"name":"Monoid.CoprodI.Word.mk.injEq","module":"Mathlib.GroupTheory.CoprodI","initialProofState":"ι : Type u_1\nM : ι → Type u_2\ninst✝ : (i : ι) → Monoid (M i)\ntoList✝ : List (Sigma fun i => M i)\nne_one✝ : ∀ (l : Sigma fun i => M i), Membership.mem toList✝ l → Ne l.snd 1\nchain_ne✝ : List.Chain' (fun l l' => Ne l.fst l'.fst) toList✝\ntoList : List (Sigma fun i => M i)\nne_one : ∀ (l : Sigma fun i => M i), Membership.mem toList l → Ne l.snd 1\nchain_ne : List.Chain' (fun l l' => Ne l.fst l'.fst) toList\n⊢ Eq (Eq { toList := toList✝, ne_one := ne_one✝, chain_ne := chain_ne✝ } { toList := toList, ne_one := ne_one, chain_ne := chain_ne }) (Eq toList✝ toList)","decl":"/-- The type of reduced words. A reduced word cannot contain a letter `1`, and no two adjacent\nletters can come from the same summand. -/\n@[ext]\nstructure Word where\n  /-- A `Word` is a `List (Σ i, M i)`, such that `1` is not in the list, and no\n  two adjacent letters are from the same summand -/\n  toList : List (Σi, M i)\n  /-- A reduced word does not contain `1` -/\n  ne_one : ∀ l ∈ toList, Sigma.snd l ≠ 1\n  /-- Adjacent letters are not from the same summand. -/\n  chain_ne : toList.Chain' fun l l' => Sigma.fst l ≠ Sigma.fst l'\n\n"}
{"name":"Monoid.CoprodI.Word.ne_one","module":"Mathlib.GroupTheory.CoprodI","initialProofState":"ι : Type u_1\nM : ι → Type u_2\ninst✝ : (i : ι) → Monoid (M i)\nself : Monoid.CoprodI.Word M\nl : Sigma fun i => M i\na✝ : Membership.mem self.toList l\n⊢ Ne l.snd 1","decl":"/-- The type of reduced words. A reduced word cannot contain a letter `1`, and no two adjacent\nletters can come from the same summand. -/\n@[ext]\nstructure Word where\n  /-- A `Word` is a `List (Σ i, M i)`, such that `1` is not in the list, and no\n  two adjacent letters are from the same summand -/\n  toList : List (Σi, M i)\n  /-- A reduced word does not contain `1` -/\n  ne_one : ∀ l ∈ toList, Sigma.snd l ≠ 1\n  /-- Adjacent letters are not from the same summand. -/\n  chain_ne : toList.Chain' fun l l' => Sigma.fst l ≠ Sigma.fst l'\n\n"}
{"name":"Monoid.CoprodI.Word.mk.sizeOf_spec","module":"Mathlib.GroupTheory.CoprodI","initialProofState":"ι : Type u_1\nM : ι → Type u_2\ninst✝² : (i : ι) → Monoid (M i)\ninst✝¹ : SizeOf ι\ninst✝ : (a : ι) → SizeOf (M a)\ntoList : List (Sigma fun i => M i)\nne_one : ∀ (l : Sigma fun i => M i), Membership.mem toList l → Ne l.snd 1\nchain_ne : List.Chain' (fun l l' => Ne l.fst l'.fst) toList\n⊢ Eq (SizeOf.sizeOf { toList := toList, ne_one := ne_one, chain_ne := chain_ne }) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf toList)) (SizeOf.sizeOf chain_ne))","decl":"/-- The type of reduced words. A reduced word cannot contain a letter `1`, and no two adjacent\nletters can come from the same summand. -/\n@[ext]\nstructure Word where\n  /-- A `Word` is a `List (Σ i, M i)`, such that `1` is not in the list, and no\n  two adjacent letters are from the same summand -/\n  toList : List (Σi, M i)\n  /-- A reduced word does not contain `1` -/\n  ne_one : ∀ l ∈ toList, Sigma.snd l ≠ 1\n  /-- Adjacent letters are not from the same summand. -/\n  chain_ne : toList.Chain' fun l l' => Sigma.fst l ≠ Sigma.fst l'\n\n"}
{"name":"Monoid.CoprodI.of_apply","module":"Mathlib.GroupTheory.CoprodI","initialProofState":"ι : Type u_1\nM : ι → Type u_2\ninst✝ : (i : ι) → Monoid (M i)\ni : ι\nm : M i\n⊢ Eq (Monoid.CoprodI.of m) ((conGen (Monoid.CoprodI.Rel M)).mk' (FreeMonoid.of ⟨i, m⟩))","decl":"theorem of_apply {i} (m : M i) : of m = Con.mk' _ (FreeMonoid.of <| Sigma.mk i m) :=\n  rfl\n\n"}
{"name":"Monoid.CoprodI.ext_hom_iff","module":"Mathlib.GroupTheory.CoprodI","initialProofState":"ι : Type u_1\nM : ι → Type u_2\ninst✝¹ : (i : ι) → Monoid (M i)\nN : Type u_3\ninst✝ : Monoid N\nf g : MonoidHom (Monoid.CoprodI M) N\n⊢ Iff (Eq f g) (∀ (i : ι), Eq (f.comp Monoid.CoprodI.of) (g.comp Monoid.CoprodI.of))","decl":"/-- See note [partially-applied ext lemmas]. -/\n-- Porting note: higher `ext` priority\n@[ext 1100]\ntheorem ext_hom (f g : CoprodI M →* N) (h : ∀ i, f.comp (of : M i →* _) = g.comp of) : f = g :=\n  (MonoidHom.cancel_right Con.mk'_surjective).mp <|\n    FreeMonoid.hom_eq fun ⟨i, x⟩ => by\n      -- This used to be `rw`, but we need `erw` after https://github.com/leanprover/lean4/pull/2644\n      erw [MonoidHom.comp_apply, MonoidHom.comp_apply, ← of_apply, ← MonoidHom.comp_apply, ←\n        MonoidHom.comp_apply, h]; rfl\n\n"}
{"name":"Monoid.CoprodI.ext_hom","module":"Mathlib.GroupTheory.CoprodI","initialProofState":"ι : Type u_1\nM : ι → Type u_2\ninst✝¹ : (i : ι) → Monoid (M i)\nN : Type u_3\ninst✝ : Monoid N\nf g : MonoidHom (Monoid.CoprodI M) N\nh : ∀ (i : ι), Eq (f.comp Monoid.CoprodI.of) (g.comp Monoid.CoprodI.of)\n⊢ Eq f g","decl":"/-- See note [partially-applied ext lemmas]. -/\n-- Porting note: higher `ext` priority\n@[ext 1100]\ntheorem ext_hom (f g : CoprodI M →* N) (h : ∀ i, f.comp (of : M i →* _) = g.comp of) : f = g :=\n  (MonoidHom.cancel_right Con.mk'_surjective).mp <|\n    FreeMonoid.hom_eq fun ⟨i, x⟩ => by\n      -- This used to be `rw`, but we need `erw` after https://github.com/leanprover/lean4/pull/2644\n      erw [MonoidHom.comp_apply, MonoidHom.comp_apply, ← of_apply, ← MonoidHom.comp_apply, ←\n        MonoidHom.comp_apply, h]; rfl\n\n"}
{"name":"Monoid.CoprodI.lift_symm_apply","module":"Mathlib.GroupTheory.CoprodI","initialProofState":"ι : Type u_1\nM : ι → Type u_2\ninst✝¹ : (i : ι) → Monoid (M i)\nN : Type u_3\ninst✝ : Monoid N\nf : MonoidHom (Monoid.CoprodI M) N\nx✝ : ι\n⊢ Eq (Monoid.CoprodI.lift.symm f x✝) (f.comp Monoid.CoprodI.of)","decl":"/-- A map out of the free product corresponds to a family of maps out of the summands. This is the\nuniversal property of the free product, characterizing it as a categorical coproduct. -/\n@[simps symm_apply]\ndef lift : (∀ i, M i →* N) ≃ (CoprodI M →* N) where\n  toFun fi :=\n    Con.lift _ (FreeMonoid.lift fun p : Σi, M i => fi p.fst p.snd) <|\n      Con.conGen_le <| by\n        simp_rw [Con.ker_rel]\n        rintro _ _ (i | ⟨x, y⟩)\n        · change FreeMonoid.lift _ (FreeMonoid.of _) = FreeMonoid.lift _ 1\n          simp only [MonoidHom.map_one, FreeMonoid.lift_eval_of]\n        · change\n            FreeMonoid.lift _ (FreeMonoid.of _ * FreeMonoid.of _) =\n              FreeMonoid.lift _ (FreeMonoid.of _)\n          simp only [MonoidHom.map_mul, FreeMonoid.lift_eval_of]\n  invFun f _ := f.comp of\n  left_inv := by\n    intro fi\n    ext i x\n    -- This used to be `rw`, but we need `erw` after https://github.com/leanprover/lean4/pull/2644\n    erw [MonoidHom.comp_apply, of_apply, Con.lift_mk', FreeMonoid.lift_eval_of]\n  right_inv := by\n    intro f\n    ext i x\n    rfl\n\n"}
{"name":"Monoid.CoprodI.lift_comp_of","module":"Mathlib.GroupTheory.CoprodI","initialProofState":"ι : Type u_1\nM : ι → Type u_2\ninst✝¹ : (i : ι) → Monoid (M i)\nN : Type u_4\ninst✝ : Monoid N\nfi : (i : ι) → MonoidHom (M i) N\ni : ι\n⊢ Eq ((Monoid.CoprodI.lift fi).comp Monoid.CoprodI.of) (fi i)","decl":"@[simp]\ntheorem lift_comp_of {N} [Monoid N] (fi : ∀ i, M i →* N) i : (lift fi).comp of = fi i :=\n  congr_fun (lift.symm_apply_apply fi) i\n\n"}
{"name":"Monoid.CoprodI.lift_of","module":"Mathlib.GroupTheory.CoprodI","initialProofState":"ι : Type u_1\nM : ι → Type u_2\ninst✝¹ : (i : ι) → Monoid (M i)\nN : Type u_4\ninst✝ : Monoid N\nfi : (i : ι) → MonoidHom (M i) N\ni : ι\nm : M i\n⊢ Eq ((Monoid.CoprodI.lift fi) (Monoid.CoprodI.of m)) ((fi i) m)","decl":"@[simp]\ntheorem lift_of {N} [Monoid N] (fi : ∀ i, M i →* N) {i} (m : M i) : lift fi (of m) = fi i m :=\n  DFunLike.congr_fun (lift_comp_of ..) m\n\n"}
{"name":"Monoid.CoprodI.lift_comp_of'","module":"Mathlib.GroupTheory.CoprodI","initialProofState":"ι : Type u_1\nM : ι → Type u_2\ninst✝¹ : (i : ι) → Monoid (M i)\nN : Type u_4\ninst✝ : Monoid N\nf : MonoidHom (Monoid.CoprodI M) N\n⊢ Eq (Monoid.CoprodI.lift fun i => f.comp Monoid.CoprodI.of) f","decl":"@[simp]\ntheorem lift_comp_of' {N} [Monoid N] (f : CoprodI M →* N) :\n    lift (fun i ↦ f.comp (of (i := i))) = f :=\n  lift.apply_symm_apply f\n\n"}
{"name":"Monoid.CoprodI.lift_of'","module":"Mathlib.GroupTheory.CoprodI","initialProofState":"ι : Type u_1\nM : ι → Type u_2\ninst✝ : (i : ι) → Monoid (M i)\n⊢ Eq (Monoid.CoprodI.lift fun i => Monoid.CoprodI.of) (MonoidHom.id (Monoid.CoprodI M))","decl":"@[simp]\ntheorem lift_of' : lift (fun i ↦ (of : M i →* CoprodI M)) = .id (CoprodI M) :=\n  lift_comp_of' (.id _)\n\n"}
{"name":"Monoid.CoprodI.of_leftInverse","module":"Mathlib.GroupTheory.CoprodI","initialProofState":"ι : Type u_1\nM : ι → Type u_2\ninst✝¹ : (i : ι) → Monoid (M i)\ninst✝ : DecidableEq ι\ni : ι\n⊢ Function.LeftInverse ⇑(Monoid.CoprodI.lift (Pi.mulSingle i (MonoidHom.id (M i)))) ⇑Monoid.CoprodI.of","decl":"theorem of_leftInverse [DecidableEq ι] (i : ι) :\n    Function.LeftInverse (lift <| Pi.mulSingle i (MonoidHom.id (M i))) of := fun x => by\n  simp only [lift_of, Pi.mulSingle_eq_same, MonoidHom.id_apply]\n\n"}
{"name":"Monoid.CoprodI.of_injective","module":"Mathlib.GroupTheory.CoprodI","initialProofState":"ι : Type u_1\nM : ι → Type u_2\ninst✝ : (i : ι) → Monoid (M i)\ni : ι\n⊢ Function.Injective ⇑Monoid.CoprodI.of","decl":"theorem of_injective (i : ι) : Function.Injective (of : M i →* _) := by\n  classical exact (of_leftInverse i).injective\n\n"}
{"name":"Monoid.CoprodI.mrange_eq_iSup","module":"Mathlib.GroupTheory.CoprodI","initialProofState":"ι : Type u_1\nM : ι → Type u_2\ninst✝¹ : (i : ι) → Monoid (M i)\nN : Type u_4\ninst✝ : Monoid N\nf : (i : ι) → MonoidHom (M i) N\n⊢ Eq (MonoidHom.mrange (Monoid.CoprodI.lift f)) (iSup fun i => MonoidHom.mrange (f i))","decl":"theorem mrange_eq_iSup {N} [Monoid N] (f : ∀ i, M i →* N) :\n    MonoidHom.mrange (lift f) = ⨆ i, MonoidHom.mrange (f i) := by\n  rw [lift, Equiv.coe_fn_mk, Con.lift_range, FreeMonoid.mrange_lift,\n    range_sigma_eq_iUnion_range, Submonoid.closure_iUnion]\n  simp only [MonoidHom.mclosure_range]\n\n"}
{"name":"Monoid.CoprodI.lift_mrange_le","module":"Mathlib.GroupTheory.CoprodI","initialProofState":"ι : Type u_1\nM : ι → Type u_2\ninst✝¹ : (i : ι) → Monoid (M i)\nN : Type u_4\ninst✝ : Monoid N\nf : (i : ι) → MonoidHom (M i) N\ns : Submonoid N\n⊢ Iff (LE.le (MonoidHom.mrange (Monoid.CoprodI.lift f)) s) (∀ (i : ι), LE.le (MonoidHom.mrange (f i)) s)","decl":"theorem lift_mrange_le {N} [Monoid N] (f : ∀ i, M i →* N) {s : Submonoid N} :\n    MonoidHom.mrange (lift f) ≤ s ↔ ∀ i, MonoidHom.mrange (f i) ≤ s := by\n  simp [mrange_eq_iSup]\n\n"}
{"name":"Monoid.CoprodI.iSup_mrange_of","module":"Mathlib.GroupTheory.CoprodI","initialProofState":"ι : Type u_1\nM : ι → Type u_2\ninst✝ : (i : ι) → Monoid (M i)\n⊢ Eq (iSup fun i => MonoidHom.mrange Monoid.CoprodI.of) Top.top","decl":"@[simp]\ntheorem iSup_mrange_of : ⨆ i, MonoidHom.mrange (of : M i →* CoprodI M) = ⊤ := by\n  simp [← mrange_eq_iSup]\n\n"}
{"name":"Monoid.CoprodI.mclosure_iUnion_range_of","module":"Mathlib.GroupTheory.CoprodI","initialProofState":"ι : Type u_1\nM : ι → Type u_2\ninst✝ : (i : ι) → Monoid (M i)\n⊢ Eq (Submonoid.closure (Set.iUnion fun i => Set.range ⇑Monoid.CoprodI.of)) Top.top","decl":"@[simp]\ntheorem mclosure_iUnion_range_of :\n    Submonoid.closure (⋃ i, Set.range (of : M i →* CoprodI M)) = ⊤ := by\n  simp [Submonoid.closure_iUnion]\n\n"}
{"name":"Monoid.CoprodI.induction_left","module":"Mathlib.GroupTheory.CoprodI","initialProofState":"ι : Type u_1\nM : ι → Type u_2\ninst✝ : (i : ι) → Monoid (M i)\nC : Monoid.CoprodI M → Prop\nm : Monoid.CoprodI M\none : C 1\nmul : ∀ {i : ι} (m : M i) (x : Monoid.CoprodI M), C x → C (HMul.hMul (Monoid.CoprodI.of m) x)\n⊢ C m","decl":"@[elab_as_elim]\ntheorem induction_left {C : CoprodI M → Prop} (m : CoprodI M) (one : C 1)\n    (mul : ∀ {i} (m : M i) x, C x → C (of m * x)) : C m := by\n  induction m using Submonoid.induction_of_closure_eq_top_left mclosure_iUnion_range_of with\n  | one => exact one\n  | mul x hx y ihy =>\n    obtain ⟨i, m, rfl⟩ : ∃ (i : ι) (m : M i), of m = x := by simpa using hx\n    exact mul m y ihy\n\n"}
{"name":"Monoid.CoprodI.induction_on","module":"Mathlib.GroupTheory.CoprodI","initialProofState":"ι : Type u_1\nM : ι → Type u_2\ninst✝ : (i : ι) → Monoid (M i)\nC : Monoid.CoprodI M → Prop\nm : Monoid.CoprodI M\nh_one : C 1\nh_of : ∀ (i : ι) (m : M i), C (Monoid.CoprodI.of m)\nh_mul : ∀ (x y : Monoid.CoprodI M), C x → C y → C (HMul.hMul x y)\n⊢ C m","decl":"@[elab_as_elim]\ntheorem induction_on {C : CoprodI M → Prop} (m : CoprodI M) (h_one : C 1)\n    (h_of : ∀ (i) (m : M i), C (of m)) (h_mul : ∀ x y, C x → C y → C (x * y)) : C m := by\n  induction m using CoprodI.induction_left with\n  | one => exact h_one\n  | mul m x hx => exact h_mul _ _ (h_of _ _) hx\n\n"}
{"name":"Monoid.CoprodI.inv_def","module":"Mathlib.GroupTheory.CoprodI","initialProofState":"ι : Type u_1\nG : ι → Type u_4\ninst✝ : (i : ι) → Group (G i)\nx : Monoid.CoprodI G\n⊢ Eq (Inv.inv x) (MulOpposite.unop ((Monoid.CoprodI.lift fun i => (MonoidHom.op Monoid.CoprodI.of).comp (MulEquiv.inv' (G i)).toMonoidHom) x))","decl":"theorem inv_def (x : CoprodI G) :\n    x⁻¹ =\n      MulOpposite.unop\n        (lift (fun i => (of : G i →* _).op.comp (MulEquiv.inv' (G i)).toMonoidHom) x) :=\n  rfl\n\n"}
{"name":"Monoid.CoprodI.lift_range_le","module":"Mathlib.GroupTheory.CoprodI","initialProofState":"ι : Type u_1\nG : ι → Type u_4\ninst✝¹ : (i : ι) → Group (G i)\nN : Type u_5\ninst✝ : Group N\nf : (i : ι) → MonoidHom (G i) N\ns : Subgroup N\nh : ∀ (i : ι), LE.le (f i).range s\n⊢ LE.le (Monoid.CoprodI.lift f).range s","decl":"theorem lift_range_le {N} [Group N] (f : ∀ i, G i →* N) {s : Subgroup N}\n    (h : ∀ i, (f i).range ≤ s) : (lift f).range ≤ s := by\n  rintro _ ⟨x, rfl⟩\n  induction' x using CoprodI.induction_on with i x x y hx hy\n  · exact s.one_mem\n  · simp only [lift_of, SetLike.mem_coe]\n    exact h i (Set.mem_range_self x)\n  · simp only [map_mul, SetLike.mem_coe]\n    exact s.mul_mem hx hy\n\n"}
{"name":"Monoid.CoprodI.range_eq_iSup","module":"Mathlib.GroupTheory.CoprodI","initialProofState":"ι : Type u_1\nG : ι → Type u_4\ninst✝¹ : (i : ι) → Group (G i)\nN : Type u_5\ninst✝ : Group N\nf : (i : ι) → MonoidHom (G i) N\n⊢ Eq (Monoid.CoprodI.lift f).range (iSup fun i => (f i).range)","decl":"theorem range_eq_iSup {N} [Group N] (f : ∀ i, G i →* N) : (lift f).range = ⨆ i, (f i).range := by\n  apply le_antisymm (lift_range_le _ f fun i => le_iSup (fun i => MonoidHom.range (f i)) i)\n  apply iSup_le _\n  rintro i _ ⟨x, rfl⟩\n  exact ⟨of x, by simp only [lift_of]⟩\n\n"}
{"name":"Monoid.CoprodI.Word.empty_toList","module":"Mathlib.GroupTheory.CoprodI","initialProofState":"ι : Type u_1\nM : ι → Type u_2\ninst✝ : (i : ι) → Monoid (M i)\n⊢ Eq Monoid.CoprodI.Word.empty.toList List.nil","decl":"/-- The empty reduced word. -/\n@[simps]\ndef empty : Word M where\n  toList := []\n  ne_one := by simp\n  chain_ne := List.chain'_nil\n\n"}
{"name":"Monoid.CoprodI.Word.prod_empty","module":"Mathlib.GroupTheory.CoprodI","initialProofState":"ι : Type u_1\nM : ι → Type u_2\ninst✝ : (i : ι) → Monoid (M i)\n⊢ Eq Monoid.CoprodI.Word.empty.prod 1","decl":"@[simp]\ntheorem prod_empty : prod (empty : Word M) = 1 :=\n  rfl\n\n"}
{"name":"Monoid.CoprodI.Word.fstIdx_ne_iff","module":"Mathlib.GroupTheory.CoprodI","initialProofState":"ι : Type u_1\nM : ι → Type u_2\ninst✝ : (i : ι) → Monoid (M i)\nw : Monoid.CoprodI.Word M\ni : ι\n⊢ Iff (Ne w.fstIdx (Option.some i)) (∀ (l : Sigma fun i => M i), Membership.mem w.toList.head? l → Ne i l.fst)","decl":"theorem fstIdx_ne_iff {w : Word M} {i} :\n    fstIdx w ≠ some i ↔ ∀ l ∈ w.toList.head?, i ≠ Sigma.fst l :=\n  not_iff_not.mp <| by simp [fstIdx]\n\n"}
{"name":"Monoid.CoprodI.Word.Pair.fstIdx_ne","module":"Mathlib.GroupTheory.CoprodI","initialProofState":"ι : Type u_1\nM : ι → Type u_2\ninst✝ : (i : ι) → Monoid (M i)\ni : ι\nself : Monoid.CoprodI.Word.Pair M i\n⊢ Ne self.tail.fstIdx (Option.some i)","decl":"/-- Given an index `i : ι`, `Pair M i` is the type of pairs `(head, tail)` where `head : M i` and\n`tail : Word M`, subject to the constraint that first letter of `tail` can't be `⟨i, m⟩`.\nBy prepending `head` to `tail`, one obtains a new word. We'll show that any word can be uniquely\nobtained in this way. -/\n@[ext]\nstructure Pair (i : ι) where\n  /-- An element of `M i`, the first letter of the word. -/\n  head : M i\n  /-- The remaining letters of the word, excluding the first letter -/\n  tail : Word M\n  /-- The index first letter of tail of a `Pair M i` is not equal to `i` -/\n  fstIdx_ne : fstIdx tail ≠ some i\n\n"}
{"name":"Monoid.CoprodI.Word.Pair.mk.inj","module":"Mathlib.GroupTheory.CoprodI","initialProofState":"ι : Type u_1\nM : ι → Type u_2\ninst✝ : (i : ι) → Monoid (M i)\ni : ι\nhead✝ : M i\ntail✝ : Monoid.CoprodI.Word M\nfstIdx_ne✝ : Ne tail✝.fstIdx (Option.some i)\nhead : M i\ntail : Monoid.CoprodI.Word M\nfstIdx_ne : Ne tail.fstIdx (Option.some i)\nx✝ : Eq { head := head✝, tail := tail✝, fstIdx_ne := fstIdx_ne✝ } { head := head, tail := tail, fstIdx_ne := fstIdx_ne }\n⊢ And (Eq head✝ head) (Eq tail✝ tail)","decl":"/-- Given an index `i : ι`, `Pair M i` is the type of pairs `(head, tail)` where `head : M i` and\n`tail : Word M`, subject to the constraint that first letter of `tail` can't be `⟨i, m⟩`.\nBy prepending `head` to `tail`, one obtains a new word. We'll show that any word can be uniquely\nobtained in this way. -/\n@[ext]\nstructure Pair (i : ι) where\n  /-- An element of `M i`, the first letter of the word. -/\n  head : M i\n  /-- The remaining letters of the word, excluding the first letter -/\n  tail : Word M\n  /-- The index first letter of tail of a `Pair M i` is not equal to `i` -/\n  fstIdx_ne : fstIdx tail ≠ some i\n\n"}
{"name":"Monoid.CoprodI.Word.Pair.mk.injEq","module":"Mathlib.GroupTheory.CoprodI","initialProofState":"ι : Type u_1\nM : ι → Type u_2\ninst✝ : (i : ι) → Monoid (M i)\ni : ι\nhead✝ : M i\ntail✝ : Monoid.CoprodI.Word M\nfstIdx_ne✝ : Ne tail✝.fstIdx (Option.some i)\nhead : M i\ntail : Monoid.CoprodI.Word M\nfstIdx_ne : Ne tail.fstIdx (Option.some i)\n⊢ Eq (Eq { head := head✝, tail := tail✝, fstIdx_ne := fstIdx_ne✝ } { head := head, tail := tail, fstIdx_ne := fstIdx_ne }) (And (Eq head✝ head) (Eq tail✝ tail))","decl":"/-- Given an index `i : ι`, `Pair M i` is the type of pairs `(head, tail)` where `head : M i` and\n`tail : Word M`, subject to the constraint that first letter of `tail` can't be `⟨i, m⟩`.\nBy prepending `head` to `tail`, one obtains a new word. We'll show that any word can be uniquely\nobtained in this way. -/\n@[ext]\nstructure Pair (i : ι) where\n  /-- An element of `M i`, the first letter of the word. -/\n  head : M i\n  /-- The remaining letters of the word, excluding the first letter -/\n  tail : Word M\n  /-- The index first letter of tail of a `Pair M i` is not equal to `i` -/\n  fstIdx_ne : fstIdx tail ≠ some i\n\n"}
{"name":"Monoid.CoprodI.Word.Pair.mk.sizeOf_spec","module":"Mathlib.GroupTheory.CoprodI","initialProofState":"ι : Type u_1\nM : ι → Type u_2\ninst✝² : (i : ι) → Monoid (M i)\ni : ι\ninst✝¹ : SizeOf ι\ninst✝ : (a : ι) → SizeOf (M a)\nhead : M i\ntail : Monoid.CoprodI.Word M\nfstIdx_ne : Ne tail.fstIdx (Option.some i)\n⊢ Eq (SizeOf.sizeOf { head := head, tail := tail, fstIdx_ne := fstIdx_ne }) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf head)) (SizeOf.sizeOf tail))","decl":"/-- Given an index `i : ι`, `Pair M i` is the type of pairs `(head, tail)` where `head : M i` and\n`tail : Word M`, subject to the constraint that first letter of `tail` can't be `⟨i, m⟩`.\nBy prepending `head` to `tail`, one obtains a new word. We'll show that any word can be uniquely\nobtained in this way. -/\n@[ext]\nstructure Pair (i : ι) where\n  /-- An element of `M i`, the first letter of the word. -/\n  head : M i\n  /-- The remaining letters of the word, excluding the first letter -/\n  tail : Word M\n  /-- The index first letter of tail of a `Pair M i` is not equal to `i` -/\n  fstIdx_ne : fstIdx tail ≠ some i\n\n"}
{"name":"Monoid.CoprodI.Word.Pair.ext","module":"Mathlib.GroupTheory.CoprodI","initialProofState":"ι : Type u_1\nM : ι → Type u_2\ninst✝ : (i : ι) → Monoid (M i)\ni : ι\nx y : Monoid.CoprodI.Word.Pair M i\nhead : Eq x.head y.head\ntail : Eq x.tail y.tail\n⊢ Eq x y","decl":"/-- Given an index `i : ι`, `Pair M i` is the type of pairs `(head, tail)` where `head : M i` and\n`tail : Word M`, subject to the constraint that first letter of `tail` can't be `⟨i, m⟩`.\nBy prepending `head` to `tail`, one obtains a new word. We'll show that any word can be uniquely\nobtained in this way. -/\n@[ext]\nstructure Pair (i : ι) where\n  /-- An element of `M i`, the first letter of the word. -/\n  head : M i\n  /-- The remaining letters of the word, excluding the first letter -/\n  tail : Word M\n  /-- The index first letter of tail of a `Pair M i` is not equal to `i` -/\n  fstIdx_ne : fstIdx tail ≠ some i\n\n"}
{"name":"Monoid.CoprodI.Word.Pair.ext_iff","module":"Mathlib.GroupTheory.CoprodI","initialProofState":"ι : Type u_1\nM : ι → Type u_2\ninst✝ : (i : ι) → Monoid (M i)\ni : ι\nx y : Monoid.CoprodI.Word.Pair M i\n⊢ Iff (Eq x y) (And (Eq x.head y.head) (Eq x.tail y.tail))","decl":"/-- Given an index `i : ι`, `Pair M i` is the type of pairs `(head, tail)` where `head : M i` and\n`tail : Word M`, subject to the constraint that first letter of `tail` can't be `⟨i, m⟩`.\nBy prepending `head` to `tail`, one obtains a new word. We'll show that any word can be uniquely\nobtained in this way. -/\n@[ext]\nstructure Pair (i : ι) where\n  /-- An element of `M i`, the first letter of the word. -/\n  head : M i\n  /-- The remaining letters of the word, excluding the first letter -/\n  tail : Word M\n  /-- The index first letter of tail of a `Pair M i` is not equal to `i` -/\n  fstIdx_ne : fstIdx tail ≠ some i\n\n"}
{"name":"Monoid.CoprodI.Word.cons_toList","module":"Mathlib.GroupTheory.CoprodI","initialProofState":"ι : Type u_1\nM : ι → Type u_2\ninst✝ : (i : ι) → Monoid (M i)\ni : ι\nm : M i\nw : Monoid.CoprodI.Word M\nhmw : Ne w.fstIdx (Option.some i)\nh1 : Ne m 1\n⊢ Eq (Monoid.CoprodI.Word.cons m w hmw h1).toList (List.cons ⟨i, m⟩ w.toList)","decl":"/-- Construct a new `Word` without any reduction. The underlying list of\n`cons m w _ _` is `⟨_, m⟩::w`  -/\n@[simps]\ndef cons {i} (m : M i) (w : Word M) (hmw : w.fstIdx ≠ some i) (h1 : m ≠ 1) : Word M :=\n  { toList := ⟨i, m⟩ :: w.toList,\n    ne_one := by\n      simp only [List.mem_cons]\n      rintro l (rfl | hl)\n      · exact h1\n      · exact w.ne_one l hl\n    chain_ne := w.chain_ne.cons' (fstIdx_ne_iff.mp hmw) }\n\n"}
{"name":"Monoid.CoprodI.Word.fstIdx_cons","module":"Mathlib.GroupTheory.CoprodI","initialProofState":"ι : Type u_1\nM : ι → Type u_2\ninst✝ : (i : ι) → Monoid (M i)\ni : ι\nm : M i\nw : Monoid.CoprodI.Word M\nhmw : Ne w.fstIdx (Option.some i)\nh1 : Ne m 1\n⊢ Eq (Monoid.CoprodI.Word.cons m w hmw h1).fstIdx (Option.some i)","decl":"@[simp]\ntheorem fstIdx_cons {i} (m : M i) (w : Word M) (hmw : w.fstIdx ≠ some i) (h1 : m ≠ 1) :\n    fstIdx (cons m w hmw h1) = some i := by simp [cons, fstIdx]\n\n"}
{"name":"Monoid.CoprodI.Word.prod_cons","module":"Mathlib.GroupTheory.CoprodI","initialProofState":"ι : Type u_1\nM : ι → Type u_2\ninst✝ : (i : ι) → Monoid (M i)\ni : ι\nm : M i\nw : Monoid.CoprodI.Word M\nh1 : Ne m 1\nh2 : Ne w.fstIdx (Option.some i)\n⊢ Eq (Monoid.CoprodI.Word.cons m w h2 h1).prod (HMul.hMul (Monoid.CoprodI.of m) w.prod)","decl":"@[simp]\ntheorem prod_cons (i) (m : M i) (w : Word M) (h1 : m ≠ 1) (h2 : w.fstIdx ≠ some i) :\n    prod (cons m w h2 h1) = of m * prod w := by\n  simp [cons, prod, List.map_cons, List.prod_cons]\n\n"}
{"name":"Monoid.CoprodI.Word.prod_rcons","module":"Mathlib.GroupTheory.CoprodI","initialProofState":"ι : Type u_1\nM : ι → Type u_2\ninst✝¹ : (i : ι) → Monoid (M i)\ninst✝ : (i : ι) → DecidableEq (M i)\ni : ι\np : Monoid.CoprodI.Word.Pair M i\n⊢ Eq (Monoid.CoprodI.Word.rcons p).prod (HMul.hMul (Monoid.CoprodI.of p.head) p.tail.prod)","decl":"@[simp]\ntheorem prod_rcons {i} (p : Pair M i) : prod (rcons p) = of p.head * prod p.tail :=\n  if hm : p.head = 1 then by rw [rcons, dif_pos hm, hm, MonoidHom.map_one, one_mul]\n  else by rw [rcons, dif_neg hm, cons, prod, List.map_cons, List.prod_cons, prod]\n\n"}
{"name":"Monoid.CoprodI.Word.rcons_inj","module":"Mathlib.GroupTheory.CoprodI","initialProofState":"ι : Type u_1\nM : ι → Type u_2\ninst✝¹ : (i : ι) → Monoid (M i)\ninst✝ : (i : ι) → DecidableEq (M i)\ni : ι\n⊢ Function.Injective Monoid.CoprodI.Word.rcons","decl":"theorem rcons_inj {i} : Function.Injective (rcons : Pair M i → Word M) := by\n  rintro ⟨m, w, h⟩ ⟨m', w', h'⟩ he\n  by_cases hm : m = 1 <;> by_cases hm' : m' = 1\n  · simp only [rcons, dif_pos hm, dif_pos hm'] at he\n    aesop\n  · exfalso\n    simp only [rcons, dif_pos hm, dif_neg hm'] at he\n    rw [he] at h\n    exact h rfl\n  · exfalso\n    simp only [rcons, dif_pos hm', dif_neg hm] at he\n    rw [← he] at h'\n    exact h' rfl\n  · have : m = m' ∧ w.toList = w'.toList := by\n      simpa [cons, rcons, dif_neg hm, dif_neg hm', eq_self_iff_true, Subtype.mk_eq_mk,\n        heq_iff_eq, ← Subtype.ext_iff_val] using he\n    rcases this with ⟨rfl, h⟩\n    congr\n    exact Word.ext h\n\n"}
{"name":"Monoid.CoprodI.Word.mem_rcons_iff","module":"Mathlib.GroupTheory.CoprodI","initialProofState":"ι : Type u_1\nM : ι → Type u_2\ninst✝¹ : (i : ι) → Monoid (M i)\ninst✝ : (i : ι) → DecidableEq (M i)\ni j : ι\np : Monoid.CoprodI.Word.Pair M i\nm : M j\n⊢ Iff (Membership.mem (Monoid.CoprodI.Word.rcons p).toList ⟨j, m⟩) (Or (Membership.mem p.tail.toList ⟨j, m⟩) (And (Ne m 1) (Exists fun h => Eq m (Eq.rec p.head h))))","decl":"theorem mem_rcons_iff {i j : ι} (p : Pair M i) (m : M j) :\n    ⟨_, m⟩ ∈ (rcons p).toList ↔ ⟨_, m⟩ ∈ p.tail.toList ∨\n      m ≠ 1 ∧ (∃ h : i = j, m = h ▸ p.head) := by\n  simp only [rcons, cons, ne_eq]\n  by_cases hij : i = j\n  · subst i\n    by_cases hm : m = p.head\n    · subst m\n      split_ifs <;> simp_all\n    · split_ifs <;> simp_all\n  · split_ifs <;> simp_all [Ne.symm hij]\n\n"}
{"name":"Monoid.CoprodI.Word.consRecOn_empty","module":"Mathlib.GroupTheory.CoprodI","initialProofState":"ι : Type u_1\nM : ι → Type u_2\ninst✝ : (i : ι) → Monoid (M i)\nmotive : Monoid.CoprodI.Word M → Sort u_4\nh_empty : motive Monoid.CoprodI.Word.empty\nh_cons : (i : ι) → (m : M i) → (w : Monoid.CoprodI.Word M) → (h1 : Ne w.fstIdx (Option.some i)) → (h2 : Ne m 1) → motive w → motive (Monoid.CoprodI.Word.cons m w h1 h2)\n⊢ Eq (Monoid.CoprodI.Word.consRecOn Monoid.CoprodI.Word.empty h_empty h_cons) h_empty","decl":"@[simp]\ntheorem consRecOn_empty {motive : Word M → Sort*} (h_empty : motive empty)\n    (h_cons : ∀ (i) (m : M i) (w) h1 h2, motive w → motive (cons m w h1 h2)) :\n    consRecOn empty h_empty h_cons = h_empty := rfl\n\n"}
{"name":"Monoid.CoprodI.Word.consRecOn_cons","module":"Mathlib.GroupTheory.CoprodI","initialProofState":"ι : Type u_1\nM : ι → Type u_2\ninst✝ : (i : ι) → Monoid (M i)\nmotive : Monoid.CoprodI.Word M → Sort u_4\ni : ι\nm : M i\nw : Monoid.CoprodI.Word M\nh1 : Ne w.fstIdx (Option.some i)\nh2 : Ne m 1\nh_empty : motive Monoid.CoprodI.Word.empty\nh_cons : (i : ι) → (m : M i) → (w : Monoid.CoprodI.Word M) → (h1 : Ne w.fstIdx (Option.some i)) → (h2 : Ne m 1) → motive w → motive (Monoid.CoprodI.Word.cons m w h1 h2)\n⊢ Eq (Monoid.CoprodI.Word.consRecOn (Monoid.CoprodI.Word.cons m w h1 h2) h_empty h_cons) (h_cons i m w h1 h2 (Monoid.CoprodI.Word.consRecOn w h_empty h_cons))","decl":"@[simp]\ntheorem consRecOn_cons {motive : Word M → Sort*} (i) (m : M i) (w : Word M) h1 h2\n    (h_empty : motive empty)\n    (h_cons : ∀ (i) (m : M i) (w) h1 h2, motive w → motive (cons m w h1 h2)) :\n    consRecOn (cons m w h1 h2) h_empty h_cons = h_cons i m w h1 h2\n      (consRecOn w h_empty h_cons) := rfl\n\n"}
{"name":"Monoid.CoprodI.Word.equivPair_symm","module":"Mathlib.GroupTheory.CoprodI","initialProofState":"ι : Type u_1\nM : ι → Type u_2\ninst✝² : (i : ι) → Monoid (M i)\ninst✝¹ : DecidableEq ι\ninst✝ : (i : ι) → DecidableEq (M i)\ni : ι\np : Monoid.CoprodI.Word.Pair M i\n⊢ Eq ((Monoid.CoprodI.Word.equivPair i).symm p) (Monoid.CoprodI.Word.rcons p)","decl":"theorem equivPair_symm (i) (p : Pair M i) : (equivPair i).symm p = rcons p :=\n  rfl\n\n"}
{"name":"Monoid.CoprodI.Word.equivPair_eq_of_fstIdx_ne","module":"Mathlib.GroupTheory.CoprodI","initialProofState":"ι : Type u_1\nM : ι → Type u_2\ninst✝² : (i : ι) → Monoid (M i)\ninst✝¹ : DecidableEq ι\ninst✝ : (i : ι) → DecidableEq (M i)\ni : ι\nw : Monoid.CoprodI.Word M\nh : Ne w.fstIdx (Option.some i)\n⊢ Eq ((Monoid.CoprodI.Word.equivPair i) w) { head := 1, tail := w, fstIdx_ne := h }","decl":"theorem equivPair_eq_of_fstIdx_ne {i} {w : Word M} (h : fstIdx w ≠ some i) :\n    equivPair i w = ⟨1, w, h⟩ :=\n  (equivPair i).apply_eq_iff_eq_symm_apply.mpr <| Eq.symm (dif_pos rfl)\n\n"}
{"name":"Monoid.CoprodI.Word.mem_equivPair_tail_iff","module":"Mathlib.GroupTheory.CoprodI","initialProofState":"ι : Type u_1\nM : ι → Type u_2\ninst✝² : (i : ι) → Monoid (M i)\ninst✝¹ : DecidableEq ι\ninst✝ : (i : ι) → DecidableEq (M i)\ni j : ι\nw : Monoid.CoprodI.Word M\nm : M i\n⊢ Iff (Membership.mem ((Monoid.CoprodI.Word.equivPair j) w).tail.toList ⟨i, m⟩) (Or (Membership.mem w.toList.tail ⟨i, m⟩) (And (Ne i j) (Exists fun h => Eq (w.toList.head h) ⟨i, m⟩)))","decl":"theorem mem_equivPair_tail_iff {i j : ι} {w : Word M} (m : M i) :\n    (⟨i, m⟩ ∈ (equivPair j w).tail.toList) ↔ ⟨i, m⟩ ∈ w.toList.tail\n      ∨ i ≠ j ∧ ∃ h : w.toList ≠ [], w.toList.head h = ⟨i, m⟩ := by\n  simp only [equivPair, equivPairAux, ne_eq, Equiv.coe_fn_mk]\n  induction w using consRecOn with\n  | h_empty => simp\n  | h_cons k g tail h1 h2 ih =>\n    simp only [consRecOn_cons]\n    split_ifs with h\n    · subst k\n      by_cases hij : j = i <;> simp_all\n    · by_cases hik : i = k\n      · subst i; simp_all [@eq_comm _ m g, @eq_comm _ k j, or_comm]\n      · simp [hik, Ne.symm hik]\n\n"}
{"name":"Monoid.CoprodI.Word.mem_of_mem_equivPair_tail","module":"Mathlib.GroupTheory.CoprodI","initialProofState":"ι : Type u_1\nM : ι → Type u_2\ninst✝² : (i : ι) → Monoid (M i)\ninst✝¹ : DecidableEq ι\ninst✝ : (i : ι) → DecidableEq (M i)\ni j : ι\nw : Monoid.CoprodI.Word M\nm : M i\na✝ : Membership.mem ((Monoid.CoprodI.Word.equivPair j) w).tail.toList ⟨i, m⟩\n⊢ Membership.mem w.toList ⟨i, m⟩","decl":"theorem mem_of_mem_equivPair_tail {i j : ι} {w : Word M} (m : M i) :\n    (⟨i, m⟩ ∈ (equivPair j w).tail.toList) → ⟨i, m⟩ ∈ w.toList := by\n  rw [mem_equivPair_tail_iff]\n  rintro (h | h)\n  · exact List.mem_of_mem_tail h\n  · revert h; cases w.toList <;> simp (config := {contextual := true})\n\n"}
{"name":"Monoid.CoprodI.Word.equivPair_head","module":"Mathlib.GroupTheory.CoprodI","initialProofState":"ι : Type u_1\nM : ι → Type u_2\ninst✝² : (i : ι) → Monoid (M i)\ninst✝¹ : DecidableEq ι\ninst✝ : (i : ι) → DecidableEq (M i)\ni : ι\nw : Monoid.CoprodI.Word M\n⊢ Eq ((Monoid.CoprodI.Word.equivPair i) w).head (dite (Exists fun h => Eq (w.toList.head h).fst i) (fun h => Eq.rec (w.toList.head ⋯).snd ⋯) fun h => 1)","decl":"theorem equivPair_head {i : ι} {w : Word M} :\n    (equivPair i w).head =\n      if h : ∃ (h : w.toList ≠ []), (w.toList.head h).1 = i\n      then h.snd ▸ (w.toList.head h.1).2\n      else 1 := by\n  simp only [equivPair, equivPairAux]\n  induction w using consRecOn with\n  | h_empty => simp\n  | h_cons head =>\n    by_cases hi : i = head\n    · subst hi; simp\n    · simp [hi, Ne.symm hi]\n\n"}
{"name":"Monoid.CoprodI.Word.smul_def","module":"Mathlib.GroupTheory.CoprodI","initialProofState":"ι : Type u_1\nM : ι → Type u_2\ninst✝² : (i : ι) → Monoid (M i)\ninst✝¹ : DecidableEq ι\ninst✝ : (i : ι) → DecidableEq (M i)\ni : ι\nm : M i\nw : Monoid.CoprodI.Word M\n⊢ Eq (HSMul.hSMul m w)\n    (Monoid.CoprodI.Word.rcons\n      (let __src := (Monoid.CoprodI.Word.equivPair i) w;\n      { head := HMul.hMul m ((Monoid.CoprodI.Word.equivPair i) w).head, tail := __src.tail, fstIdx_ne := ⋯ }))","decl":"theorem smul_def {i} (m : M i) (w : Word M) :\n    m • w = rcons { equivPair i w with head := m * (equivPair i w).head } :=\n  rfl\n\n"}
{"name":"Monoid.CoprodI.Word.of_smul_def","module":"Mathlib.GroupTheory.CoprodI","initialProofState":"ι : Type u_1\nM : ι → Type u_2\ninst✝² : (i : ι) → Monoid (M i)\ninst✝¹ : DecidableEq ι\ninst✝ : (i : ι) → DecidableEq (M i)\ni : ι\nw : Monoid.CoprodI.Word M\nm : M i\n⊢ Eq (HSMul.hSMul (Monoid.CoprodI.of m) w)\n    (Monoid.CoprodI.Word.rcons\n      (let __src := (Monoid.CoprodI.Word.equivPair i) w;\n      { head := HMul.hMul m ((Monoid.CoprodI.Word.equivPair i) w).head, tail := __src.tail, fstIdx_ne := ⋯ }))","decl":"theorem of_smul_def (i) (w : Word M) (m : M i) :\n    of m • w = rcons { equivPair i w with head := m * (equivPair i w).head } :=\n  rfl\n\n"}
{"name":"Monoid.CoprodI.Word.equivPair_smul_same","module":"Mathlib.GroupTheory.CoprodI","initialProofState":"ι : Type u_1\nM : ι → Type u_2\ninst✝² : (i : ι) → Monoid (M i)\ninst✝¹ : DecidableEq ι\ninst✝ : (i : ι) → DecidableEq (M i)\ni : ι\nm : M i\nw : Monoid.CoprodI.Word M\n⊢ Eq ((Monoid.CoprodI.Word.equivPair i) (HSMul.hSMul (Monoid.CoprodI.of m) w)) { head := HMul.hMul m ((Monoid.CoprodI.Word.equivPair i) w).head, tail := ((Monoid.CoprodI.Word.equivPair i) w).tail, fstIdx_ne := ⋯ }","decl":"theorem equivPair_smul_same {i} (m : M i) (w : Word M) :\n    equivPair i (of m • w) = ⟨m * (equivPair i w).head, (equivPair i w).tail,\n      (equivPair i w).fstIdx_ne⟩ := by\n  rw [of_smul_def, ← equivPair_symm]\n  simp\n\n"}
{"name":"Monoid.CoprodI.Word.equivPair_tail","module":"Mathlib.GroupTheory.CoprodI","initialProofState":"ι : Type u_1\nM : ι → Type u_2\ninst✝² : (i : ι) → Monoid (M i)\ninst✝¹ : DecidableEq ι\ninst✝ : (i : ι) → DecidableEq (M i)\ni : ι\np : Monoid.CoprodI.Word.Pair M i\n⊢ Eq ((Monoid.CoprodI.Word.equivPair i) p.tail) { head := 1, tail := p.tail, fstIdx_ne := ⋯ }","decl":"@[simp]\ntheorem equivPair_tail {i} (p : Pair M i) :\n    equivPair i p.tail = ⟨1, p.tail, p.fstIdx_ne⟩ :=\n  equivPair_eq_of_fstIdx_ne _\n\n"}
{"name":"Monoid.CoprodI.Word.smul_eq_of_smul","module":"Mathlib.GroupTheory.CoprodI","initialProofState":"ι : Type u_1\nM : ι → Type u_2\ninst✝² : (i : ι) → Monoid (M i)\ninst✝¹ : DecidableEq ι\ninst✝ : (i : ι) → DecidableEq (M i)\ni : ι\nm : M i\nw : Monoid.CoprodI.Word M\n⊢ Eq (HSMul.hSMul m w) (HSMul.hSMul (Monoid.CoprodI.of m) w)","decl":"theorem smul_eq_of_smul {i} (m : M i) (w : Word M) :\n    m • w = of m • w := rfl\n\n"}
{"name":"Monoid.CoprodI.Word.mem_smul_iff","module":"Mathlib.GroupTheory.CoprodI","initialProofState":"ι : Type u_1\nM : ι → Type u_2\ninst✝² : (i : ι) → Monoid (M i)\ninst✝¹ : DecidableEq ι\ninst✝ : (i : ι) → DecidableEq (M i)\ni j : ι\nm₁ : M i\nm₂ : M j\nw : Monoid.CoprodI.Word M\n⊢ Iff (Membership.mem (HSMul.hSMul (Monoid.CoprodI.of m₂) w).toList ⟨i, m₁⟩) (Or (And (Not (Eq i j)) (Membership.mem w.toList ⟨i, m₁⟩)) (And (Ne m₁ 1) (Exists fun hij => Or (Membership.mem w.toList.tail ⟨i, m₁⟩) (Or (Exists fun m' => And (Membership.mem w.toList.head? ⟨j, m'⟩) (Eq m₁ (Eq.rec (HMul.hMul m₂ m') ⋯))) (And (Ne w.fstIdx (Option.some j)) (Eq m₁ (Eq.rec m₂ ⋯)))))))","decl":"theorem mem_smul_iff {i j : ι} {m₁ : M i} {m₂ : M j} {w : Word M} :\n    ⟨_, m₁⟩ ∈ (of m₂ • w).toList ↔\n      (¬i = j ∧ ⟨i, m₁⟩ ∈ w.toList)\n      ∨ (m₁ ≠ 1 ∧ ∃ (hij : i = j),(⟨i, m₁⟩ ∈ w.toList.tail) ∨\n        (∃ m', ⟨j, m'⟩ ∈ w.toList.head? ∧ m₁ = hij ▸ (m₂ * m')) ∨\n        (w.fstIdx ≠ some j ∧ m₁ = hij ▸ m₂)) := by\n  rw [of_smul_def, mem_rcons_iff, mem_equivPair_tail_iff, equivPair_head, or_assoc]\n  by_cases hij : i = j\n  · subst i\n    simp only [not_true, ne_eq, false_and, exists_prop, true_and, false_or]\n    by_cases hw : ⟨j, m₁⟩ ∈ w.toList.tail\n    · simp [hw, show m₁ ≠ 1 from w.ne_one _ (List.mem_of_mem_tail hw)]\n    · simp only [hw, false_or, Option.mem_def, ne_eq, and_congr_right_iff]\n      intro hm1\n      split_ifs with h\n      · rcases h with ⟨hnil, rfl⟩\n        simp only [List.head?_eq_head hnil, Option.some.injEq, ne_eq]\n        constructor\n        · rintro rfl\n          exact Or.inl ⟨_, rfl, rfl⟩\n        · rintro (⟨_, h, rfl⟩ | hm')\n          · simp only [Sigma.ext_iff, heq_eq_eq, true_and] at h\n            subst h\n            rfl\n          · simp only [fstIdx, Option.map_eq_some', Sigma.exists,\n              exists_and_right, exists_eq_right, not_exists, ne_eq] at hm'\n            exact (hm'.1 (w.toList.head hnil).2 (by rw [List.head?_eq_head])).elim\n      · revert h\n        rw [fstIdx]\n        cases w.toList\n        · simp\n        · simp (config := {contextual := true}) [Sigma.ext_iff]\n  · rcases w with ⟨_ | _, _, _⟩ <;>\n    simp [or_comm, hij, Ne.symm hij]; rw [eq_comm]\n\n"}
{"name":"Monoid.CoprodI.Word.mem_smul_iff_of_ne","module":"Mathlib.GroupTheory.CoprodI","initialProofState":"ι : Type u_1\nM : ι → Type u_2\ninst✝² : (i : ι) → Monoid (M i)\ninst✝¹ : DecidableEq ι\ninst✝ : (i : ι) → DecidableEq (M i)\ni j : ι\nhij : Ne i j\nm₁ : M i\nm₂ : M j\nw : Monoid.CoprodI.Word M\n⊢ Iff (Membership.mem (HSMul.hSMul (Monoid.CoprodI.of m₂) w).toList ⟨i, m₁⟩) (Membership.mem w.toList ⟨i, m₁⟩)","decl":"theorem mem_smul_iff_of_ne {i j : ι} (hij : i ≠ j) {m₁ : M i} {m₂ : M j} {w : Word M} :\n    ⟨_, m₁⟩ ∈ (of m₂ • w).toList ↔ ⟨i, m₁⟩ ∈ w.toList := by\n  simp [mem_smul_iff, *]\n\n"}
{"name":"Monoid.CoprodI.Word.cons_eq_smul","module":"Mathlib.GroupTheory.CoprodI","initialProofState":"ι : Type u_1\nM : ι → Type u_2\ninst✝² : (i : ι) → Monoid (M i)\ninst✝¹ : DecidableEq ι\ninst✝ : (i : ι) → DecidableEq (M i)\ni : ι\nm : M i\nls : Monoid.CoprodI.Word M\nh1 : Ne ls.fstIdx (Option.some i)\nh2 : Ne m 1\n⊢ Eq (Monoid.CoprodI.Word.cons m ls h1 h2) (HSMul.hSMul (Monoid.CoprodI.of m) ls)","decl":"theorem cons_eq_smul {i} {m : M i} {ls h1 h2} :\n    cons m ls h1 h2 = of m • ls := by\n  rw [of_smul_def, equivPair_eq_of_fstIdx_ne _]\n  · simp [cons, rcons, h2]\n  · exact h1\n\n"}
{"name":"Monoid.CoprodI.Word.rcons_eq_smul","module":"Mathlib.GroupTheory.CoprodI","initialProofState":"ι : Type u_1\nM : ι → Type u_2\ninst✝² : (i : ι) → Monoid (M i)\ninst✝¹ : DecidableEq ι\ninst✝ : (i : ι) → DecidableEq (M i)\ni : ι\np : Monoid.CoprodI.Word.Pair M i\n⊢ Eq (Monoid.CoprodI.Word.rcons p) (HSMul.hSMul (Monoid.CoprodI.of p.head) p.tail)","decl":"theorem rcons_eq_smul {i} (p : Pair M i) :\n    rcons p = of p.head • p.tail := by\n  simp [of_smul_def]\n\n"}
{"name":"Monoid.CoprodI.Word.equivPair_head_smul_equivPair_tail","module":"Mathlib.GroupTheory.CoprodI","initialProofState":"ι : Type u_1\nM : ι → Type u_2\ninst✝² : (i : ι) → Monoid (M i)\ninst✝¹ : DecidableEq ι\ninst✝ : (i : ι) → DecidableEq (M i)\ni : ι\nw : Monoid.CoprodI.Word M\n⊢ Eq (HSMul.hSMul (Monoid.CoprodI.of ((Monoid.CoprodI.Word.equivPair i) w).head) ((Monoid.CoprodI.Word.equivPair i) w).tail) w","decl":"@[simp]\ntheorem equivPair_head_smul_equivPair_tail {i : ι} (w : Word M) :\n    of (equivPair i w).head • (equivPair i w).tail = w := by\n  rw [← rcons_eq_smul, ← equivPair_symm, Equiv.symm_apply_apply]\n\n"}
{"name":"Monoid.CoprodI.Word.equivPair_tail_eq_inv_smul","module":"Mathlib.GroupTheory.CoprodI","initialProofState":"ι : Type u_1\ninst✝² : DecidableEq ι\nG : ι → Type u_4\ninst✝¹ : (i : ι) → Group (G i)\ninst✝ : (i : ι) → DecidableEq (G i)\ni : ι\nw : Monoid.CoprodI.Word G\n⊢ Eq ((Monoid.CoprodI.Word.equivPair i) w).tail (HSMul.hSMul (Inv.inv (Monoid.CoprodI.of ((Monoid.CoprodI.Word.equivPair i) w).head)) w)","decl":"theorem equivPair_tail_eq_inv_smul {G : ι → Type*} [∀ i, Group (G i)]\n    [∀i, DecidableEq (G i)] {i} (w : Word G) :\n    (equivPair i w).tail = (of (equivPair i w).head)⁻¹ • w :=\n  Eq.symm <| inv_smul_eq_iff.2 (equivPair_head_smul_equivPair_tail w).symm\n\n"}
{"name":"Monoid.CoprodI.Word.smul_induction","module":"Mathlib.GroupTheory.CoprodI","initialProofState":"ι : Type u_1\nM : ι → Type u_2\ninst✝² : (i : ι) → Monoid (M i)\ninst✝¹ : DecidableEq ι\ninst✝ : (i : ι) → DecidableEq (M i)\nC : Monoid.CoprodI.Word M → Prop\nh_empty : C Monoid.CoprodI.Word.empty\nh_smul : ∀ (i : ι) (m : M i) (w : Monoid.CoprodI.Word M), C w → C (HSMul.hSMul (Monoid.CoprodI.of m) w)\nw : Monoid.CoprodI.Word M\n⊢ C w","decl":"theorem smul_induction {C : Word M → Prop} (h_empty : C empty)\n    (h_smul : ∀ (i) (m : M i) (w), C w → C (of m • w)) (w : Word M) : C w := by\n  induction w using consRecOn with\n  | h_empty => exact h_empty\n  | h_cons _ _ _ _ _ ih =>\n    rw [cons_eq_smul]\n    exact h_smul _ _ _ ih\n\n"}
{"name":"Monoid.CoprodI.Word.prod_smul","module":"Mathlib.GroupTheory.CoprodI","initialProofState":"ι : Type u_1\nM : ι → Type u_2\ninst✝² : (i : ι) → Monoid (M i)\ninst✝¹ : DecidableEq ι\ninst✝ : (i : ι) → DecidableEq (M i)\nm : Monoid.CoprodI M\nw : Monoid.CoprodI.Word M\n⊢ Eq (HSMul.hSMul m w).prod (HMul.hMul m w.prod)","decl":"@[simp]\ntheorem prod_smul (m) : ∀ w : Word M, prod (m • w) = m * prod w := by\n  induction m using CoprodI.induction_on with\n  | h_one =>\n    intro\n    rw [one_smul, one_mul]\n  | h_of _ =>\n    intros\n    rw [of_smul_def, prod_rcons, of.map_mul, mul_assoc, ← prod_rcons, ← equivPair_symm,\n      Equiv.symm_apply_apply]\n  | h_mul x y hx hy =>\n    intro w\n    rw [mul_smul, hx, hy, mul_assoc]\n\n"}
{"name":"Monoid.CoprodI.NeWord.append.inj","module":"Mathlib.GroupTheory.CoprodI","initialProofState":"ι : Type u_1\nM : ι → Type u_2\ninst✝ : (i : ι) → Monoid (M i)\ni j✝ k✝ l : ι\n_w₁✝ : Monoid.CoprodI.NeWord M i j✝\n_hne✝ : Ne j✝ k✝\n_w₂✝ : Monoid.CoprodI.NeWord M k✝ l\nj k : ι\n_w₁ : Monoid.CoprodI.NeWord M i j\n_hne : Ne j k\n_w₂ : Monoid.CoprodI.NeWord M k l\nx✝ : Eq (_w₁✝.append _hne✝ _w₂✝) (_w₁.append _hne _w₂)\n⊢ And (Eq j✝ j) (And (Eq k✝ k) (And (HEq _w₁✝ _w₁) (HEq _w₂✝ _w₂)))","decl":"/-- A `NeWord M i j` is a representation of a non-empty reduced words where the first letter comes\nfrom `M i` and the last letter comes from `M j`. It can be constructed from singletons and via\nconcatenation, and thus provides a useful induction principle. -/\ninductive NeWord : ι → ι → Type _\n  | singleton : ∀ {i : ι} (x : M i), x ≠ 1 → NeWord i i\n  | append : ∀ {i j k l} (_w₁ : NeWord i j) (_hne : j ≠ k) (_w₂ : NeWord k l), NeWord i l\n\n"}
{"name":"Monoid.CoprodI.NeWord.singleton.injEq","module":"Mathlib.GroupTheory.CoprodI","initialProofState":"ι : Type u_1\nM : ι → Type u_2\ninst✝ : (i : ι) → Monoid (M i)\ni : ι\nx✝ : M i\na✝¹ : Ne x✝ 1\nx : M i\na✝ : Ne x 1\n⊢ Eq (Eq (Monoid.CoprodI.NeWord.singleton x✝ a✝¹) (Monoid.CoprodI.NeWord.singleton x a✝)) (Eq x✝ x)","decl":"/-- A `NeWord M i j` is a representation of a non-empty reduced words where the first letter comes\nfrom `M i` and the last letter comes from `M j`. It can be constructed from singletons and via\nconcatenation, and thus provides a useful induction principle. -/\ninductive NeWord : ι → ι → Type _\n  | singleton : ∀ {i : ι} (x : M i), x ≠ 1 → NeWord i i\n  | append : ∀ {i j k l} (_w₁ : NeWord i j) (_hne : j ≠ k) (_w₂ : NeWord k l), NeWord i l\n\n"}
{"name":"Monoid.CoprodI.NeWord.append.sizeOf_spec","module":"Mathlib.GroupTheory.CoprodI","initialProofState":"ι : Type u_1\nM : ι → Type u_2\ninst✝² : (i : ι) → Monoid (M i)\ninst✝¹ : SizeOf ι\ninst✝ : (a : ι) → SizeOf (M a)\ni j k l : ι\n_w₁ : Monoid.CoprodI.NeWord M i j\n_hne : Ne j k\n_w₂ : Monoid.CoprodI.NeWord M k l\n⊢ Eq (SizeOf.sizeOf (_w₁.append _hne _w₂)) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf i)) (SizeOf.sizeOf j)) (SizeOf.sizeOf k)) (SizeOf.sizeOf l)) (SizeOf.sizeOf _w₁)) (SizeOf.sizeOf _w₂))","decl":"/-- A `NeWord M i j` is a representation of a non-empty reduced words where the first letter comes\nfrom `M i` and the last letter comes from `M j`. It can be constructed from singletons and via\nconcatenation, and thus provides a useful induction principle. -/\ninductive NeWord : ι → ι → Type _\n  | singleton : ∀ {i : ι} (x : M i), x ≠ 1 → NeWord i i\n  | append : ∀ {i j k l} (_w₁ : NeWord i j) (_hne : j ≠ k) (_w₂ : NeWord k l), NeWord i l\n\n"}
{"name":"Monoid.CoprodI.NeWord.append.injEq","module":"Mathlib.GroupTheory.CoprodI","initialProofState":"ι : Type u_1\nM : ι → Type u_2\ninst✝ : (i : ι) → Monoid (M i)\ni j✝ k✝ l : ι\n_w₁✝ : Monoid.CoprodI.NeWord M i j✝\n_hne✝ : Ne j✝ k✝\n_w₂✝ : Monoid.CoprodI.NeWord M k✝ l\nj k : ι\n_w₁ : Monoid.CoprodI.NeWord M i j\n_hne : Ne j k\n_w₂ : Monoid.CoprodI.NeWord M k l\n⊢ Eq (Eq (_w₁✝.append _hne✝ _w₂✝) (_w₁.append _hne _w₂)) (And (Eq j✝ j) (And (Eq k✝ k) (And (HEq _w₁✝ _w₁) (HEq _w₂✝ _w₂))))","decl":"/-- A `NeWord M i j` is a representation of a non-empty reduced words where the first letter comes\nfrom `M i` and the last letter comes from `M j`. It can be constructed from singletons and via\nconcatenation, and thus provides a useful induction principle. -/\ninductive NeWord : ι → ι → Type _\n  | singleton : ∀ {i : ι} (x : M i), x ≠ 1 → NeWord i i\n  | append : ∀ {i j k l} (_w₁ : NeWord i j) (_hne : j ≠ k) (_w₂ : NeWord k l), NeWord i l\n\n"}
{"name":"Monoid.CoprodI.NeWord.singleton.sizeOf_spec","module":"Mathlib.GroupTheory.CoprodI","initialProofState":"ι : Type u_1\nM : ι → Type u_2\ninst✝² : (i : ι) → Monoid (M i)\ninst✝¹ : SizeOf ι\ninst✝ : (a : ι) → SizeOf (M a)\ni : ι\nx : M i\na✝ : Ne x 1\n⊢ Eq (SizeOf.sizeOf (Monoid.CoprodI.NeWord.singleton x a✝)) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf i)) (SizeOf.sizeOf x))","decl":"/-- A `NeWord M i j` is a representation of a non-empty reduced words where the first letter comes\nfrom `M i` and the last letter comes from `M j`. It can be constructed from singletons and via\nconcatenation, and thus provides a useful induction principle. -/\ninductive NeWord : ι → ι → Type _\n  | singleton : ∀ {i : ι} (x : M i), x ≠ 1 → NeWord i i\n  | append : ∀ {i j k l} (_w₁ : NeWord i j) (_hne : j ≠ k) (_w₂ : NeWord k l), NeWord i l\n\n"}
{"name":"Monoid.CoprodI.NeWord.singleton.inj","module":"Mathlib.GroupTheory.CoprodI","initialProofState":"ι : Type u_1\nM : ι → Type u_2\ninst✝ : (i : ι) → Monoid (M i)\ni : ι\nx✝¹ : M i\na✝¹ : Ne x✝¹ 1\nx : M i\na✝ : Ne x 1\nx✝ : Eq (Monoid.CoprodI.NeWord.singleton x✝¹ a✝¹) (Monoid.CoprodI.NeWord.singleton x a✝)\n⊢ Eq x✝¹ x","decl":"/-- A `NeWord M i j` is a representation of a non-empty reduced words where the first letter comes\nfrom `M i` and the last letter comes from `M j`. It can be constructed from singletons and via\nconcatenation, and thus provides a useful induction principle. -/\ninductive NeWord : ι → ι → Type _\n  | singleton : ∀ {i : ι} (x : M i), x ≠ 1 → NeWord i i\n  | append : ∀ {i j k l} (_w₁ : NeWord i j) (_hne : j ≠ k) (_w₂ : NeWord k l), NeWord i l\n\n"}
{"name":"Monoid.CoprodI.NeWord.toList_ne_nil","module":"Mathlib.GroupTheory.CoprodI","initialProofState":"ι : Type u_1\nM : ι → Type u_2\ninst✝ : (i : ι) → Monoid (M i)\ni j : ι\nw : Monoid.CoprodI.NeWord M i j\n⊢ Ne w.toList List.nil","decl":"theorem toList_ne_nil {i j} (w : NeWord M i j) : w.toList ≠ List.nil := by\n  induction w\n  · rintro ⟨rfl⟩\n  · apply List.append_ne_nil_of_left_ne_nil\n    assumption\n\n"}
{"name":"Monoid.CoprodI.NeWord.toList_head?","module":"Mathlib.GroupTheory.CoprodI","initialProofState":"ι : Type u_1\nM : ι → Type u_2\ninst✝ : (i : ι) → Monoid (M i)\ni j : ι\nw : Monoid.CoprodI.NeWord M i j\n⊢ Eq w.toList.head? (Option.some ⟨i, w.head⟩)","decl":"@[simp]\ntheorem toList_head? {i j} (w : NeWord M i j) : w.toList.head? = Option.some ⟨i, w.head⟩ := by\n  rw [← Option.mem_def]\n  induction w\n  · rw [Option.mem_def]\n    rfl\n  · exact List.mem_head?_append_of_mem_head? (by assumption)\n\n"}
{"name":"Monoid.CoprodI.NeWord.toList_getLast?","module":"Mathlib.GroupTheory.CoprodI","initialProofState":"ι : Type u_1\nM : ι → Type u_2\ninst✝ : (i : ι) → Monoid (M i)\ni j : ι\nw : Monoid.CoprodI.NeWord M i j\n⊢ Eq w.toList.getLast? (Option.some ⟨j, w.last⟩)","decl":"@[simp]\ntheorem toList_getLast? {i j} (w : NeWord M i j) : w.toList.getLast? = Option.some ⟨j, w.last⟩ := by\n  rw [← Option.mem_def]\n  induction w\n  · rw [Option.mem_def]\n    rfl\n  · exact List.mem_getLast?_append_of_mem_getLast? (by assumption)\n\n"}
{"name":"Monoid.CoprodI.NeWord.of_word","module":"Mathlib.GroupTheory.CoprodI","initialProofState":"ι : Type u_1\nM : ι → Type u_2\ninst✝ : (i : ι) → Monoid (M i)\nw : Monoid.CoprodI.Word M\nh : Ne w Monoid.CoprodI.Word.empty\n⊢ Exists fun i => Exists fun j => Exists fun w' => Eq w'.toWord w","decl":"/-- Every nonempty `Word M` can be constructed as a `NeWord M i j` -/\ntheorem of_word (w : Word M) (h : w ≠ empty) : ∃ (i j : _) (w' : NeWord M i j), w'.toWord = w := by\n  suffices ∃ (i j : _) (w' : NeWord M i j), w'.toWord.toList = w.toList by\n    rcases this with ⟨i, j, w, h⟩\n    refine ⟨i, j, w, ?_⟩\n    ext\n    rw [h]\n  cases' w with l hnot1 hchain\n  induction' l with x l hi\n  · contradiction\n  · rw [List.forall_mem_cons] at hnot1\n    cases' l with y l\n    · refine ⟨x.1, x.1, singleton x.2 hnot1.1, ?_⟩\n      simp [toWord]\n    · rw [List.chain'_cons] at hchain\n      specialize hi hnot1.2 hchain.2 (by rintro ⟨rfl⟩)\n      obtain ⟨i, j, w', hw' : w'.toList = y::l⟩ := hi\n      obtain rfl : y = ⟨i, w'.head⟩ := by simpa [hw'] using w'.toList_head?\n      refine ⟨x.1, j, append (singleton x.2 hnot1.1) hchain.1 w', ?_⟩\n      simpa [toWord] using hw'\n\n"}
{"name":"Monoid.CoprodI.NeWord.singleton_head","module":"Mathlib.GroupTheory.CoprodI","initialProofState":"ι : Type u_1\nM : ι → Type u_2\ninst✝ : (i : ι) → Monoid (M i)\ni : ι\nx : M i\nhne_one : Ne x 1\n⊢ Eq (Monoid.CoprodI.NeWord.singleton x hne_one).head x","decl":"@[simp]\ntheorem singleton_head {i} (x : M i) (hne_one : x ≠ 1) : (singleton x hne_one).head = x :=\n  rfl\n\n"}
{"name":"Monoid.CoprodI.NeWord.singleton_last","module":"Mathlib.GroupTheory.CoprodI","initialProofState":"ι : Type u_1\nM : ι → Type u_2\ninst✝ : (i : ι) → Monoid (M i)\ni : ι\nx : M i\nhne_one : Ne x 1\n⊢ Eq (Monoid.CoprodI.NeWord.singleton x hne_one).last x","decl":"@[simp]\ntheorem singleton_last {i} (x : M i) (hne_one : x ≠ 1) : (singleton x hne_one).last = x :=\n  rfl\n\n"}
{"name":"Monoid.CoprodI.NeWord.prod_singleton","module":"Mathlib.GroupTheory.CoprodI","initialProofState":"ι : Type u_1\nM : ι → Type u_2\ninst✝ : (i : ι) → Monoid (M i)\ni : ι\nx : M i\nhne_one : Ne x 1\n⊢ Eq (Monoid.CoprodI.NeWord.singleton x hne_one).prod (Monoid.CoprodI.of x)","decl":"@[simp]\ntheorem prod_singleton {i} (x : M i) (hne_one : x ≠ 1) : (singleton x hne_one).prod = of x := by\n  simp [toWord, prod, Word.prod]\n\n"}
{"name":"Monoid.CoprodI.NeWord.append_head","module":"Mathlib.GroupTheory.CoprodI","initialProofState":"ι : Type u_1\nM : ι → Type u_2\ninst✝ : (i : ι) → Monoid (M i)\ni j k l : ι\nw₁ : Monoid.CoprodI.NeWord M i j\nhne : Ne j k\nw₂ : Monoid.CoprodI.NeWord M k l\n⊢ Eq (w₁.append hne w₂).head w₁.head","decl":"@[simp]\ntheorem append_head {i j k l} {w₁ : NeWord M i j} {hne : j ≠ k} {w₂ : NeWord M k l} :\n    (append w₁ hne w₂).head = w₁.head :=\n  rfl\n\n"}
{"name":"Monoid.CoprodI.NeWord.append_last","module":"Mathlib.GroupTheory.CoprodI","initialProofState":"ι : Type u_1\nM : ι → Type u_2\ninst✝ : (i : ι) → Monoid (M i)\ni j k l : ι\nw₁ : Monoid.CoprodI.NeWord M i j\nhne : Ne j k\nw₂ : Monoid.CoprodI.NeWord M k l\n⊢ Eq (w₁.append hne w₂).last w₂.last","decl":"@[simp]\ntheorem append_last {i j k l} {w₁ : NeWord M i j} {hne : j ≠ k} {w₂ : NeWord M k l} :\n    (append w₁ hne w₂).last = w₂.last :=\n  rfl\n\n"}
{"name":"Monoid.CoprodI.NeWord.append_prod","module":"Mathlib.GroupTheory.CoprodI","initialProofState":"ι : Type u_1\nM : ι → Type u_2\ninst✝ : (i : ι) → Monoid (M i)\ni j k l : ι\nw₁ : Monoid.CoprodI.NeWord M i j\nhne : Ne j k\nw₂ : Monoid.CoprodI.NeWord M k l\n⊢ Eq (w₁.append hne w₂).prod (HMul.hMul w₁.prod w₂.prod)","decl":"@[simp]\ntheorem append_prod {i j k l} {w₁ : NeWord M i j} {hne : j ≠ k} {w₂ : NeWord M k l} :\n    (append w₁ hne w₂).prod = w₁.prod * w₂.prod := by simp [toWord, prod, Word.prod]\n\n"}
{"name":"Monoid.CoprodI.NeWord.replaceHead_head","module":"Mathlib.GroupTheory.CoprodI","initialProofState":"ι : Type u_1\nM : ι → Type u_2\ninst✝ : (i : ι) → Monoid (M i)\ni j : ι\nx : M i\nhnotone : Ne x 1\nw : Monoid.CoprodI.NeWord M i j\n⊢ Eq (Monoid.CoprodI.NeWord.replaceHead x hnotone w).head x","decl":"@[simp]\ntheorem replaceHead_head {i j : ι} (x : M i) (hnotone : x ≠ 1) (w : NeWord M i j) :\n    (replaceHead x hnotone w).head = x := by\n  induction w\n  · rfl\n  · simp [*, replaceHead]\n\n"}
{"name":"Monoid.CoprodI.NeWord.mulHead_head","module":"Mathlib.GroupTheory.CoprodI","initialProofState":"ι : Type u_1\nM : ι → Type u_2\ninst✝ : (i : ι) → Monoid (M i)\ni j : ι\nw : Monoid.CoprodI.NeWord M i j\nx : M i\nhnotone : Ne (HMul.hMul x w.head) 1\n⊢ Eq (w.mulHead x hnotone).head (HMul.hMul x w.head)","decl":"@[simp]\ntheorem mulHead_head {i j : ι} (w : NeWord M i j) (x : M i) (hnotone : x * w.head ≠ 1) :\n    (mulHead w x hnotone).head = x * w.head := by\n  induction w\n  · rfl\n  · simp [*, mulHead]\n\n"}
{"name":"Monoid.CoprodI.NeWord.mulHead_prod","module":"Mathlib.GroupTheory.CoprodI","initialProofState":"ι : Type u_1\nM : ι → Type u_2\ninst✝ : (i : ι) → Monoid (M i)\ni j : ι\nw : Monoid.CoprodI.NeWord M i j\nx : M i\nhnotone : Ne (HMul.hMul x w.head) 1\n⊢ Eq (w.mulHead x hnotone).prod (HMul.hMul (Monoid.CoprodI.of x) w.prod)","decl":"@[simp]\ntheorem mulHead_prod {i j : ι} (w : NeWord M i j) (x : M i) (hnotone : x * w.head ≠ 1) :\n    (mulHead w x hnotone).prod = of x * w.prod := by\n  unfold mulHead\n  induction w with\n  | singleton => simp [mulHead, replaceHead]\n  | append _ _ _ w_ih_w₁ w_ih_w₂ =>\n    specialize w_ih_w₁ _ hnotone\n    clear w_ih_w₂\n    simp? [replaceHead, ← mul_assoc] at * says\n      simp only [replaceHead, head, append_prod, ← mul_assoc] at *\n    congr 1\n\n"}
{"name":"Monoid.CoprodI.NeWord.inv_prod","module":"Mathlib.GroupTheory.CoprodI","initialProofState":"ι : Type u_1\nG : ι → Type u_4\ninst✝ : (i : ι) → Group (G i)\ni j : ι\nw : Monoid.CoprodI.NeWord G i j\n⊢ Eq w.inv.prod (Inv.inv w.prod)","decl":"@[simp]\ntheorem inv_prod {i j} (w : NeWord G i j) : w.inv.prod = w.prod⁻¹ := by\n  induction w <;> simp [inv, *]\n\n"}
{"name":"Monoid.CoprodI.NeWord.inv_head","module":"Mathlib.GroupTheory.CoprodI","initialProofState":"ι : Type u_1\nG : ι → Type u_4\ninst✝ : (i : ι) → Group (G i)\ni j : ι\nw : Monoid.CoprodI.NeWord G i j\n⊢ Eq w.inv.head (Inv.inv w.last)","decl":"@[simp]\ntheorem inv_head {i j} (w : NeWord G i j) : w.inv.head = w.last⁻¹ := by\n  induction w <;> simp [inv, *]\n\n"}
{"name":"Monoid.CoprodI.NeWord.inv_last","module":"Mathlib.GroupTheory.CoprodI","initialProofState":"ι : Type u_1\nG : ι → Type u_4\ninst✝ : (i : ι) → Group (G i)\ni j : ι\nw : Monoid.CoprodI.NeWord G i j\n⊢ Eq w.inv.last (Inv.inv w.head)","decl":"@[simp]\ntheorem inv_last {i j} (w : NeWord G i j) : w.inv.last = w.head⁻¹ := by\n  induction w <;> simp [inv, *]\n\n"}
{"name":"Monoid.CoprodI.lift_word_ping_pong","module":"Mathlib.GroupTheory.CoprodI","initialProofState":"ι : Type u_1\nG : Type u_4\ninst✝² : Group G\nH : ι → Type u_5\ninst✝¹ : (i : ι) → Group (H i)\nf : (i : ι) → MonoidHom (H i) G\nα : Type u_6\ninst✝ : MulAction G α\nX : ι → Set α\nhpp : Pairwise fun i j => ∀ (h : H i), Ne h 1 → HasSubset.Subset (HSMul.hSMul ((f i) h) (X j)) (X i)\ni j k : ι\nw : Monoid.CoprodI.NeWord H i j\nhk : Ne j k\n⊢ HasSubset.Subset (HSMul.hSMul ((Monoid.CoprodI.lift f) w.prod) (X k)) (X i)","decl":"theorem lift_word_ping_pong {i j k} (w : NeWord H i j) (hk : j ≠ k) :\n    lift f w.prod • X k ⊆ X i := by\n  induction' w with i x hne_one i j k l w₁ hne w₂ hIw₁ hIw₂ generalizing k\n  · simpa using hpp hk _ hne_one\n  · calc\n      lift f (NeWord.append w₁ hne w₂).prod • X k = lift f w₁.prod • lift f w₂.prod • X k := by\n        simp [MulAction.mul_smul]\n      _ ⊆ lift f w₁.prod • X _ := smul_set_subset_smul_set_iff.mpr (hIw₂ hk)\n      _ ⊆ X i := hIw₁ hne\n\n"}
{"name":"Monoid.CoprodI.lift_word_prod_nontrivial_of_other_i","module":"Mathlib.GroupTheory.CoprodI","initialProofState":"ι : Type u_1\nG : Type u_4\ninst✝² : Group G\nH : ι → Type u_5\ninst✝¹ : (i : ι) → Group (H i)\nf : (i : ι) → MonoidHom (H i) G\nα : Type u_6\ninst✝ : MulAction G α\nX : ι → Set α\nhXnonempty : ∀ (i : ι), (X i).Nonempty\nhXdisj : Pairwise (Function.onFun Disjoint X)\nhpp : Pairwise fun i j => ∀ (h : H i), Ne h 1 → HasSubset.Subset (HSMul.hSMul ((f i) h) (X j)) (X i)\ni j k : ι\nw : Monoid.CoprodI.NeWord H i j\nhhead : Ne k i\nhlast : Ne k j\n⊢ Ne ((Monoid.CoprodI.lift f) w.prod) 1","decl":"theorem lift_word_prod_nontrivial_of_other_i {i j k} (w : NeWord H i j) (hhead : k ≠ i)\n    (hlast : k ≠ j) : lift f w.prod ≠ 1 := by\n  intro heq1\n  have : X k ⊆ X i := by simpa [heq1] using lift_word_ping_pong f X hpp w hlast.symm\n  obtain ⟨x, hx⟩ := hXnonempty k\n  exact (hXdisj hhead).le_bot ⟨hx, this hx⟩\n\n"}
{"name":"Monoid.CoprodI.lift_word_prod_nontrivial_of_head_eq_last","module":"Mathlib.GroupTheory.CoprodI","initialProofState":"ι : Type u_1\nG : Type u_4\ninst✝³ : Group G\nH : ι → Type u_5\ninst✝² : (i : ι) → Group (H i)\nf : (i : ι) → MonoidHom (H i) G\nα : Type u_6\ninst✝¹ : MulAction G α\nX : ι → Set α\nhXnonempty : ∀ (i : ι), (X i).Nonempty\nhXdisj : Pairwise (Function.onFun Disjoint X)\nhpp : Pairwise fun i j => ∀ (h : H i), Ne h 1 → HasSubset.Subset (HSMul.hSMul ((f i) h) (X j)) (X i)\ninst✝ : Nontrivial ι\ni : ι\nw : Monoid.CoprodI.NeWord H i i\n⊢ Ne ((Monoid.CoprodI.lift f) w.prod) 1","decl":"theorem lift_word_prod_nontrivial_of_head_eq_last {i} (w : NeWord H i i) :\n    lift f w.prod ≠ 1 := by\n  obtain ⟨k, hk⟩ := exists_ne i\n  exact lift_word_prod_nontrivial_of_other_i f X hXnonempty hXdisj hpp w hk hk\n\n"}
{"name":"Monoid.CoprodI.lift_word_prod_nontrivial_of_head_card","module":"Mathlib.GroupTheory.CoprodI","initialProofState":"ι : Type u_1\nG : Type u_4\ninst✝³ : Group G\nH : ι → Type u_5\ninst✝² : (i : ι) → Group (H i)\nf : (i : ι) → MonoidHom (H i) G\nα : Type u_6\ninst✝¹ : MulAction G α\nX : ι → Set α\nhXnonempty : ∀ (i : ι), (X i).Nonempty\nhXdisj : Pairwise (Function.onFun Disjoint X)\nhpp : Pairwise fun i j => ∀ (h : H i), Ne h 1 → HasSubset.Subset (HSMul.hSMul ((f i) h) (X j)) (X i)\ninst✝ : Nontrivial ι\ni j : ι\nw : Monoid.CoprodI.NeWord H i j\nhcard : LE.le 3 (Cardinal.mk (H i))\nhheadtail : Ne i j\n⊢ Ne ((Monoid.CoprodI.lift f) w.prod) 1","decl":"theorem lift_word_prod_nontrivial_of_head_card {i j} (w : NeWord H i j)\n    (hcard : 3 ≤ #(H i)) (hheadtail : i ≠ j) : lift f w.prod ≠ 1 := by\n  obtain ⟨h, hn1, hnh⟩ := Cardinal.three_le hcard 1 w.head⁻¹\n  have hnot1 : h * w.head ≠ 1 := by\n    rw [← div_inv_eq_mul]\n    exact div_ne_one_of_ne hnh\n  let w' : NeWord H i i :=\n    NeWord.append (NeWord.mulHead w h hnot1) hheadtail.symm\n      (NeWord.singleton h⁻¹ (inv_ne_one.mpr hn1))\n  have hw' : lift f w'.prod ≠ 1 :=\n    lift_word_prod_nontrivial_of_head_eq_last f X hXnonempty hXdisj hpp w'\n  intro heq1\n  apply hw'\n  simp [w', heq1]\n\n"}
{"name":"Monoid.CoprodI.lift_word_prod_nontrivial_of_not_empty","module":"Mathlib.GroupTheory.CoprodI","initialProofState":"ι : Type u_1\nG : Type u_4\ninst✝³ : Group G\nH : ι → Type u_5\ninst✝² : (i : ι) → Group (H i)\nf : (i : ι) → MonoidHom (H i) G\nhcard : Or (LE.le 3 (Cardinal.mk ι)) (Exists fun i => LE.le 3 (Cardinal.mk (H i)))\nα : Type u_6\ninst✝¹ : MulAction G α\nX : ι → Set α\nhXnonempty : ∀ (i : ι), (X i).Nonempty\nhXdisj : Pairwise (Function.onFun Disjoint X)\nhpp : Pairwise fun i j => ∀ (h : H i), Ne h 1 → HasSubset.Subset (HSMul.hSMul ((f i) h) (X j)) (X i)\ninst✝ : Nontrivial ι\ni j : ι\nw : Monoid.CoprodI.NeWord H i j\n⊢ Ne ((Monoid.CoprodI.lift f) w.prod) 1","decl":"include hcard in\ntheorem lift_word_prod_nontrivial_of_not_empty {i j} (w : NeWord H i j) :\n    lift f w.prod ≠ 1 := by\n  classical\n    cases' hcard with hcard hcard\n    · obtain ⟨i, h1, h2⟩ := Cardinal.three_le hcard i j\n      exact lift_word_prod_nontrivial_of_other_i f X hXnonempty hXdisj hpp w h1 h2\n    · cases' hcard with k hcard\n      by_cases hh : i = k <;> by_cases hl : j = k\n      · subst hh\n        subst hl\n        exact lift_word_prod_nontrivial_of_head_eq_last f X hXnonempty hXdisj hpp w\n      · subst hh\n        change j ≠ i at hl\n        exact lift_word_prod_nontrivial_of_head_card f X hXnonempty hXdisj hpp w hcard hl.symm\n      · subst hl\n        change i ≠ j at hh\n        have : lift f w.inv.prod ≠ 1 :=\n          lift_word_prod_nontrivial_of_head_card f X hXnonempty hXdisj hpp w.inv hcard hh.symm\n        intro heq\n        apply this\n        simpa using heq\n      · change i ≠ k at hh\n        change j ≠ k at hl\n        exact lift_word_prod_nontrivial_of_other_i f X hXnonempty hXdisj hpp w hh.symm hl.symm\n\n"}
{"name":"Monoid.CoprodI.empty_of_word_prod_eq_one","module":"Mathlib.GroupTheory.CoprodI","initialProofState":"ι : Type u_1\nG : Type u_4\ninst✝³ : Group G\nH : ι → Type u_5\ninst✝² : (i : ι) → Group (H i)\nf : (i : ι) → MonoidHom (H i) G\nhcard : Or (LE.le 3 (Cardinal.mk ι)) (Exists fun i => LE.le 3 (Cardinal.mk (H i)))\nα : Type u_6\ninst✝¹ : MulAction G α\nX : ι → Set α\nhXnonempty : ∀ (i : ι), (X i).Nonempty\nhXdisj : Pairwise (Function.onFun Disjoint X)\nhpp : Pairwise fun i j => ∀ (h : H i), Ne h 1 → HasSubset.Subset (HSMul.hSMul ((f i) h) (X j)) (X i)\ninst✝ : Nontrivial ι\nw : Monoid.CoprodI.Word H\nh : Eq ((Monoid.CoprodI.lift f) w.prod) 1\n⊢ Eq w Monoid.CoprodI.Word.empty","decl":"include hcard in\ntheorem empty_of_word_prod_eq_one {w : Word H} (h : lift f w.prod = 1) :\n    w = Word.empty := by\n  by_contra hnotempty\n  obtain ⟨i, j, w, rfl⟩ := NeWord.of_word w hnotempty\n  exact lift_word_prod_nontrivial_of_not_empty f hcard X hXnonempty hXdisj hpp w h\n\n"}
{"name":"Monoid.CoprodI.lift_injective_of_ping_pong","module":"Mathlib.GroupTheory.CoprodI","initialProofState":"ι : Type u_1\nG : Type u_4\ninst✝³ : Group G\nH : ι → Type u_5\ninst✝² : (i : ι) → Group (H i)\nf : (i : ι) → MonoidHom (H i) G\nhcard : Or (LE.le 3 (Cardinal.mk ι)) (Exists fun i => LE.le 3 (Cardinal.mk (H i)))\nα : Type u_6\ninst✝¹ : MulAction G α\nX : ι → Set α\nhXnonempty : ∀ (i : ι), (X i).Nonempty\nhXdisj : Pairwise (Function.onFun Disjoint X)\nhpp : Pairwise fun i j => ∀ (h : H i), Ne h 1 → HasSubset.Subset (HSMul.hSMul ((f i) h) (X j)) (X i)\ninst✝ : Nontrivial ι\n⊢ Function.Injective ⇑(Monoid.CoprodI.lift f)","decl":"include hcard in\n/-- The **Ping-Pong-Lemma**.\n\nGiven a group action of `G` on `X` so that the `H i` acts in a specific way on disjoint subsets\n`X i` we can prove that `lift f` is injective, and thus the image of `lift f` is isomorphic to the\nfree product of the `H i`.\n\nOften the Ping-Pong-Lemma is stated with regard to subgroups `H i` that generate the whole group;\nwe generalize to arbitrary group homomorphisms `f i : H i →* G` and do not require the group to be\ngenerated by the images.\n\nUsually the Ping-Pong-Lemma requires that one group `H i` has at least three elements. This\ncondition is only needed if `# ι = 2`, and we accept `3 ≤ # ι` as an alternative.\n-/\ntheorem lift_injective_of_ping_pong : Function.Injective (lift f) := by\n  classical\n    apply (injective_iff_map_eq_one (lift f)).mpr\n    rw [(CoprodI.Word.equiv).forall_congr_left]\n    intro w Heq\n    dsimp [Word.equiv] at *\n    rw [empty_of_word_prod_eq_one f hcard X hXnonempty hXdisj hpp Heq, Word.prod_empty]\n\n"}
{"name":"Monoid.CoprodI.instIsFreeGroup","module":"Mathlib.GroupTheory.CoprodI","initialProofState":"ι : Type u_4\nG : ι → Type u_5\ninst✝¹ : (i : ι) → Group (G i)\ninst✝ : ∀ (i : ι), IsFreeGroup (G i)\n⊢ IsFreeGroup (Monoid.CoprodI G)","decl":"/-- The free product of free groups is itself a free group. -/\ninstance {ι : Type*} (G : ι → Type*) [∀ i, Group (G i)] [∀ i, IsFreeGroup (G i)] :\n    IsFreeGroup (CoprodI G) :=\n  (FreeGroupBasis.coprodI (fun i ↦ IsFreeGroup.basis (G i))).isFreeGroup\n\n-- NB: One might expect this theorem to be phrased with ℤ, but ℤ is an additive group,\n-- and using `Multiplicative ℤ` runs into diamond issues.\n"}
{"name":"freeGroupEquivCoprodI_symm_apply","module":"Mathlib.GroupTheory.CoprodI","initialProofState":"ι : Type u_1\na : Monoid.CoprodI fun x => FreeGroup Unit\n⊢ Eq (freeGroupEquivCoprodI.symm a) ((Monoid.CoprodI.lift fun i => FreeGroup.lift fun x => FreeGroup.of i) a)","decl":"/-- A free group is a free product of copies of the free_group over one generator. -/\n@[simps!]\ndef _root_.freeGroupEquivCoprodI {ι : Type u_1} :\n    FreeGroup ι ≃* CoprodI fun _ : ι => FreeGroup Unit := by\n  refine MonoidHom.toMulEquiv ?_ ?_ ?_ ?_\n  · exact FreeGroup.lift fun i => @CoprodI.of ι _ _ i (FreeGroup.of Unit.unit)\n  · exact CoprodI.lift fun i => FreeGroup.lift fun _ => FreeGroup.of i\n  · ext; simp\n  · ext i a; cases a; simp\n\n"}
{"name":"freeGroupEquivCoprodI_apply","module":"Mathlib.GroupTheory.CoprodI","initialProofState":"ι : Type u_1\na : FreeGroup ι\n⊢ Eq (freeGroupEquivCoprodI a) ((FreeGroup.lift fun i => Monoid.CoprodI.of (FreeGroup.of Unit.unit)) a)","decl":"/-- A free group is a free product of copies of the free_group over one generator. -/\n@[simps!]\ndef _root_.freeGroupEquivCoprodI {ι : Type u_1} :\n    FreeGroup ι ≃* CoprodI fun _ : ι => FreeGroup Unit := by\n  refine MonoidHom.toMulEquiv ?_ ?_ ?_ ?_\n  · exact FreeGroup.lift fun i => @CoprodI.of ι _ _ i (FreeGroup.of Unit.unit)\n  · exact CoprodI.lift fun i => FreeGroup.lift fun _ => FreeGroup.of i\n  · ext; simp\n  · ext i a; cases a; simp\n\n"}
{"name":"FreeGroup.injective_lift_of_ping_pong","module":"Mathlib.GroupTheory.CoprodI","initialProofState":"ι : Type u_1\ninst✝² : Nontrivial ι\nG : Type u_1\ninst✝¹ : Group G\na : ι → G\nα : Type u_4\ninst✝ : MulAction G α\nX Y : ι → Set α\nhXnonempty : ∀ (i : ι), (X i).Nonempty\nhXdisj : Pairwise (Function.onFun Disjoint X)\nhYdisj : Pairwise (Function.onFun Disjoint Y)\nhXYdisj : ∀ (i j : ι), Disjoint (X i) (Y j)\nhX : ∀ (i : ι), HasSubset.Subset (HSMul.hSMul (a i) (HasCompl.compl (Y i))) (X i)\nhY : ∀ (i : ι), HasSubset.Subset (HSMul.hSMul (Inv.inv a i) (HasCompl.compl (X i))) (Y i)\n⊢ Function.Injective ⇑(FreeGroup.lift a)","decl":"include hXnonempty hXdisj hYdisj hXYdisj hX hY in\n/-- The Ping-Pong-Lemma.\n\nGiven a group action of `G` on `X` so that the generators of the free groups act in specific\nways on disjoint subsets `X i` and `Y i` we can prove that `lift f` is injective, and thus the image\nof `lift f` is isomorphic to the free group.\n\nOften the Ping-Pong-Lemma is stated with regard to group elements that generate the whole group;\nwe generalize to arbitrary group homomorphisms from the free group to `G` and do not require the\ngroup to be generated by the elements.\n-/\ntheorem _root_.FreeGroup.injective_lift_of_ping_pong : Function.Injective (FreeGroup.lift a) := by\n  -- Step one: express the free group lift via the free product lift\n  have : FreeGroup.lift a =\n      (CoprodI.lift fun i => FreeGroup.lift fun _ => a i).comp\n        (@freeGroupEquivCoprodI ι).toMonoidHom := by\n    ext i\n    simp\n  rw [this, MonoidHom.coe_comp]\n  clear this\n  refine Function.Injective.comp ?_ (MulEquiv.injective freeGroupEquivCoprodI)\n  -- Step two: Invoke the ping-pong lemma for free products\n  show Function.Injective (lift fun i : ι => FreeGroup.lift fun _ => a i)\n  -- Prepare to instantiate lift_injective_of_ping_pong\n  let H : ι → Type _ := fun _i => FreeGroup Unit\n  let f : ∀ i, H i →* G := fun i => FreeGroup.lift fun _ => a i\n  let X' : ι → Set α := fun i => X i ∪ Y i\n  apply lift_injective_of_ping_pong f _ X'\n  · show ∀ i, (X' i).Nonempty\n    exact fun i => Set.Nonempty.inl (hXnonempty i)\n  · show Pairwise (Disjoint on X')\n    intro i j hij\n    simp only [X']\n    apply Disjoint.union_left <;> apply Disjoint.union_right\n    · exact hXdisj hij\n    · exact hXYdisj i j\n    · exact (hXYdisj j i).symm\n    · exact hYdisj hij\n  · show Pairwise fun i j => ∀ h : H i, h ≠ 1 → f i h • X' j ⊆ X' i\n    rintro i j hij\n    -- use free_group unit ≃ ℤ\n    refine FreeGroup.freeGroupUnitEquivInt.forall_congr_left.mpr ?_\n    intro n hne1\n    change FreeGroup.lift (fun _ => a i) (FreeGroup.of () ^ n) • X' j ⊆ X' i\n    simp only [map_zpow, FreeGroup.lift.of]\n    change a i ^ n • X' j ⊆ X' i\n    have hnne0 : n ≠ 0 := by\n      rintro rfl\n      apply hne1\n      simp [H, FreeGroup.freeGroupUnitEquivInt]\n    clear hne1\n    simp only [X']\n    -- Positive and negative powers separately\n    cases' (lt_or_gt_of_ne hnne0).symm with hlt hgt\n    · have h1n : 1 ≤ n := hlt\n      calc\n        a i ^ n • X' j ⊆ a i ^ n • (Y i)ᶜ :=\n          smul_set_mono ((hXYdisj j i).union_left <| hYdisj hij.symm).subset_compl_right\n        _ ⊆ X i := by\n          clear hnne0 hlt\n          refine Int.le_induction (P := fun n => a i ^ n • (Y i)ᶜ ⊆ X i) ?_ ?_ n h1n\n          · dsimp\n            rw [zpow_one]\n            exact hX i\n          · dsimp\n            intro n _hle hi\n            calc\n              a i ^ (n + 1) • (Y i)ᶜ = (a i ^ n * a i) • (Y i)ᶜ := by rw [zpow_add, zpow_one]\n              _ = a i ^ n • a i • (Y i)ᶜ := MulAction.mul_smul _ _ _\n              _ ⊆ a i ^ n • X i := smul_set_mono <| hX i\n              _ ⊆ a i ^ n • (Y i)ᶜ := smul_set_mono (hXYdisj i i).subset_compl_right\n              _ ⊆ X i := hi\n        _ ⊆ X' i := Set.subset_union_left\n    · have h1n : n ≤ -1 := by\n        apply Int.le_of_lt_add_one\n        simpa using hgt\n      calc\n        a i ^ n • X' j ⊆ a i ^ n • (X i)ᶜ :=\n          smul_set_mono ((hXdisj hij.symm).union_left (hXYdisj i j).symm).subset_compl_right\n        _ ⊆ Y i := by\n          refine Int.le_induction_down (P := fun n => a i ^ n • (X i)ᶜ ⊆ Y i) ?_ ?_ _ h1n\n          · dsimp\n            rw [zpow_neg, zpow_one]\n            exact hY i\n          · dsimp\n            intro n _ hi\n            calc\n              a i ^ (n - 1) • (X i)ᶜ = (a i ^ n * (a i)⁻¹) • (X i)ᶜ := by rw [zpow_sub, zpow_one]\n              _ = a i ^ n • (a i)⁻¹ • (X i)ᶜ := MulAction.mul_smul _ _ _\n              _ ⊆ a i ^ n • Y i := smul_set_mono <| hY i\n              _ ⊆ a i ^ n • (X i)ᶜ := smul_set_mono (hXYdisj i i).symm.subset_compl_right\n              _ ⊆ Y i := hi\n        _ ⊆ X' i := Set.subset_union_right\n  show _ ∨ ∃ i, 3 ≤ #(H i)\n  inhabit ι\n  right\n  use Inhabited.default\n  simp only [H]\n  rw [FreeGroup.freeGroupUnitEquivInt.cardinal_eq, Cardinal.mk_denumerable]\n  apply le_of_lt\n  exact nat_lt_aleph0 3\n\n"}
