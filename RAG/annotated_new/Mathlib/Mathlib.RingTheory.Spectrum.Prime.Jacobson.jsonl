{"name":"PrimeSpectrum.exists_isClosed_singleton_of_isJacobsonRing","module":"Mathlib.RingTheory.Spectrum.Prime.Jacobson","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\ninst✝ : IsJacobsonRing R\ns : Set (PrimeSpectrum R)\nhs : IsOpen s\nhs' : s.Nonempty\n⊢ Exists fun x => And (Membership.mem s x) (IsClosed (Singleton.singleton x))","decl":"lemma exists_isClosed_singleton_of_isJacobsonRing [IsJacobsonRing R]\n    (s : (Set (PrimeSpectrum R))) (hs : IsOpen s) (hs' : s.Nonempty) :\n    ∃ x ∈ s, IsClosed {x} := by\n  simp_rw [isClosed_singleton_iff_isMaximal]\n  obtain ⟨I, hI'⟩ := (isClosed_iff_zeroLocus_ideal _).mp hs.isClosed_compl\n  simp_rw [← @Set.not_mem_compl_iff _ s, hI', mem_zeroLocus]\n  have := hs'.ne_empty\n  contrapose! this\n  simp_rw [not_imp_not] at this\n  rw [← Set.compl_univ, eq_compl_comm, hI', eq_comm, ← zeroLocus_bot,\n    zeroLocus_eq_iff, Ideal.radical_eq_jacobson, Ideal.radical_eq_jacobson]\n  refine le_antisymm (le_sInf ?_) (Ideal.jacobson_mono bot_le)\n  rintro x ⟨-, hx⟩\n  exact sInf_le ⟨this ⟨x, hx.isPrime⟩ hx, hx⟩\n\n"}
{"name":"PrimeSpectrum.instJacobsonSpaceOfIsJacobsonRing","module":"Mathlib.RingTheory.Spectrum.Prime.Jacobson","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\ninst✝ : IsJacobsonRing R\n⊢ JacobsonSpace (PrimeSpectrum R)","decl":"instance [IsJacobsonRing R] : JacobsonSpace (PrimeSpectrum R) := by\n  rw [jacobsonSpace_iff_locallyClosed]\n  rintro S hS ⟨U, Z, hU, hZ, rfl⟩\n  simp only [← isClosed_compl_iff, isClosed_iff_zeroLocus_ideal, @compl_eq_comm _ U] at hU hZ\n  obtain ⟨⟨I, rfl⟩, ⟨J, rfl⟩⟩ := And.intro hU hZ\n  simp only [Set.nonempty_iff_ne_empty, ne_eq, Set.inter_assoc,\n    ← Set.disjoint_iff_inter_eq_empty, Set.disjoint_compl_left_iff_subset,\n    zeroLocus_subset_zeroLocus_iff, Ideal.radical_eq_jacobson, Ideal.jacobson, le_sInf_iff] at hS ⊢\n  contrapose! hS\n  rintro x ⟨hJx, hx⟩\n  exact @hS ⟨x, hx.isPrime⟩ ⟨hJx, (isClosed_singleton_iff_isMaximal _).mpr hx⟩\n\n"}
{"name":"PrimeSpectrum.isJacobsonRing_iff_jacobsonSpace","module":"Mathlib.RingTheory.Spectrum.Prime.Jacobson","initialProofState":"R : Type u_1\ninst✝ : CommRing R\n⊢ Iff (IsJacobsonRing R) (JacobsonSpace (PrimeSpectrum R))","decl":"lemma isJacobsonRing_iff_jacobsonSpace :\n    IsJacobsonRing R ↔ JacobsonSpace (PrimeSpectrum R) := by\n  refine ⟨fun _ ↦ inferInstance, fun H ↦ ⟨fun I hI ↦ le_antisymm ?_ Ideal.le_jacobson⟩⟩\n  rw [← I.isRadical_jacobson.radical]\n  conv_rhs => rw [← hI.radical]\n  simp_rw [← vanishingIdeal_zeroLocus_eq_radical]\n  apply vanishingIdeal_anti_mono\n  rw [← H.1 (isClosed_zeroLocus I), (isClosed_zeroLocus _).closure_subset_iff]\n  rintro x ⟨hx : I ≤ x.asIdeal, hx'⟩\n  show jacobson I ≤ x.asIdeal\n  exact sInf_le ⟨hx, (isClosed_singleton_iff_isMaximal _).mp hx'⟩\n\n"}
{"name":"PrimeSpectrum.isOpen_singleton_tfae_of_isNoetherian_of_isJacobsonRing","module":"Mathlib.RingTheory.Spectrum.Prime.Jacobson","initialProofState":"R : Type u_1\ninst✝² : CommRing R\ninst✝¹ : IsNoetherianRing R\ninst✝ : IsJacobsonRing R\nx : PrimeSpectrum R\n⊢ (List.cons (IsOpen (Singleton.singleton x)) (List.cons (IsClopen (Singleton.singleton x)) (List.cons (And (IsClosed (Singleton.singleton x)) (StableUnderGeneralization (Singleton.singleton x))) List.nil))).TFAE","decl":"/--\nIf `R` is both noetherian and jacobson, then the following are equivalent for `x : Spec R`:\n1. `{x}` is open (i.e. `x` is an isolated point)\n2. `{x}` is clopen\n3. `{x}` is both closed and stable under generalization\n  (i.e. `x` is both a minimal prime and a maximal ideal)\n-/\nlemma isOpen_singleton_tfae_of_isNoetherian_of_isJacobsonRing\n    [IsNoetherianRing R] [IsJacobsonRing R] (x : PrimeSpectrum R) :\n    List.TFAE [IsOpen {x}, IsClopen {x}, IsClosed {x} ∧ StableUnderGeneralization {x}] := by\n  tfae_have 1 → 2\n  | h => by\n    obtain ⟨y, rfl : y = x, h'⟩ := exists_isClosed_singleton_of_isJacobsonRing _ h\n      ⟨x, Set.mem_singleton x⟩\n    exact ⟨h', h⟩\n  tfae_have 2 → 3\n  | h => ⟨h.isClosed, h.isOpen.stableUnderGeneralization⟩\n  tfae_have 3 → 1\n  | ⟨h₁, h₂⟩ => by\n    rw [isClosed_singleton_iff_isMaximal, ← isMax_iff] at h₁\n    suffices {x} = (⋃ p ∈ { p : PrimeSpectrum R | IsMin p ∧ p ≠ x }, closure {p})ᶜ by\n      rw [this, isOpen_compl_iff]\n      refine Set.Finite.isClosed_biUnion ?_ (fun _ _ ↦ isClosed_closure)\n      exact (finite_setOf_isMin R).subset fun x h ↦ h.1\n    ext p\n    simp only [Set.mem_singleton_iff, ne_eq, Set.mem_setOf_eq, Set.compl_iUnion, Set.mem_iInter,\n      Set.mem_compl_iff, and_imp, ← specializes_iff_mem_closure, ← le_iff_specializes,\n      not_imp_not]\n    constructor\n    · rintro rfl _ _\n      rw [stableUnderGeneralization_singleton, ← isMin_iff] at h₂\n      exact h₂.eq_of_le\n    · intros hp\n      apply h₁.eq_of_ge\n      obtain ⟨q, hq, hq'⟩ := Ideal.exists_minimalPrimes_le (J := p.asIdeal) bot_le\n      exact (hp ⟨q, hq.1.1⟩ (isMin_iff.mpr hq) hq').ge.trans hq'\n  tfae_finish\n\n"}
