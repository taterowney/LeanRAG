{"name":"OrderedFinpartition.parts_strictMono","module":"Mathlib.Analysis.Calculus.ContDiff.FaaDiBruno","initialProofState":"n : Nat\nself : OrderedFinpartition n\n‚ä¢ StrictMono fun m => self.emb m ‚ü®HSub.hSub (self.partSize m) 1, ‚ãØ‚ü©","decl":"/-- A partition of `Fin n` into finitely many nonempty subsets, given by the increasing\nparameterization of these subsets. We order the subsets by increasing greatest element.\nThis definition is tailored-made for the Faa di Bruno formula, and probably not useful elsewhere,\nbecause of the specific parameterization by `Fin n` and the peculiar ordering. -/\n@[ext]\nstructure OrderedFinpartition (n : ‚Ñï) where\n  /-- The number of parts in the partition -/\n  length : ‚Ñï\n  /-- The size of each part -/\n  partSize : Fin length ‚Üí ‚Ñï\n  partSize_pos : ‚àÄ m, 0 < partSize m\n  /-- The increasing parameterization of each part -/\n  emb : ‚àÄ m, (Fin (partSize m)) ‚Üí Fin n\n  emb_strictMono : ‚àÄ m, StrictMono (emb m)\n  /-- The parts are ordered by increasing greatest element. -/\n  parts_strictMono :\n    StrictMono fun m ‚Ü¶ emb m ‚ü®partSize m - 1, Nat.sub_one_lt_of_lt (partSize_pos m)‚ü©\n  /-- The parts are disjoint -/\n  disjoint : PairwiseDisjoint univ fun m ‚Ü¶ range (emb m)\n  /-- The parts cover everything -/\n  cover x : ‚àÉ m, x ‚àà range (emb m)\n  deriving DecidableEq\n\n"}
{"name":"OrderedFinpartition.ext","module":"Mathlib.Analysis.Calculus.ContDiff.FaaDiBruno","initialProofState":"n : Nat\nx y : OrderedFinpartition n\nlength : Eq x.length y.length\npartSize : HEq x.partSize y.partSize\nemb : HEq x.emb y.emb\n‚ä¢ Eq x y","decl":"/-- A partition of `Fin n` into finitely many nonempty subsets, given by the increasing\nparameterization of these subsets. We order the subsets by increasing greatest element.\nThis definition is tailored-made for the Faa di Bruno formula, and probably not useful elsewhere,\nbecause of the specific parameterization by `Fin n` and the peculiar ordering. -/\n@[ext]\nstructure OrderedFinpartition (n : ‚Ñï) where\n  /-- The number of parts in the partition -/\n  length : ‚Ñï\n  /-- The size of each part -/\n  partSize : Fin length ‚Üí ‚Ñï\n  partSize_pos : ‚àÄ m, 0 < partSize m\n  /-- The increasing parameterization of each part -/\n  emb : ‚àÄ m, (Fin (partSize m)) ‚Üí Fin n\n  emb_strictMono : ‚àÄ m, StrictMono (emb m)\n  /-- The parts are ordered by increasing greatest element. -/\n  parts_strictMono :\n    StrictMono fun m ‚Ü¶ emb m ‚ü®partSize m - 1, Nat.sub_one_lt_of_lt (partSize_pos m)‚ü©\n  /-- The parts are disjoint -/\n  disjoint : PairwiseDisjoint univ fun m ‚Ü¶ range (emb m)\n  /-- The parts cover everything -/\n  cover x : ‚àÉ m, x ‚àà range (emb m)\n  deriving DecidableEq\n\n"}
{"name":"OrderedFinpartition.partSize_pos","module":"Mathlib.Analysis.Calculus.ContDiff.FaaDiBruno","initialProofState":"n : Nat\nself : OrderedFinpartition n\nm : Fin self.length\n‚ä¢ LT.lt 0 (self.partSize m)","decl":"/-- A partition of `Fin n` into finitely many nonempty subsets, given by the increasing\nparameterization of these subsets. We order the subsets by increasing greatest element.\nThis definition is tailored-made for the Faa di Bruno formula, and probably not useful elsewhere,\nbecause of the specific parameterization by `Fin n` and the peculiar ordering. -/\n@[ext]\nstructure OrderedFinpartition (n : ‚Ñï) where\n  /-- The number of parts in the partition -/\n  length : ‚Ñï\n  /-- The size of each part -/\n  partSize : Fin length ‚Üí ‚Ñï\n  partSize_pos : ‚àÄ m, 0 < partSize m\n  /-- The increasing parameterization of each part -/\n  emb : ‚àÄ m, (Fin (partSize m)) ‚Üí Fin n\n  emb_strictMono : ‚àÄ m, StrictMono (emb m)\n  /-- The parts are ordered by increasing greatest element. -/\n  parts_strictMono :\n    StrictMono fun m ‚Ü¶ emb m ‚ü®partSize m - 1, Nat.sub_one_lt_of_lt (partSize_pos m)‚ü©\n  /-- The parts are disjoint -/\n  disjoint : PairwiseDisjoint univ fun m ‚Ü¶ range (emb m)\n  /-- The parts cover everything -/\n  cover x : ‚àÉ m, x ‚àà range (emb m)\n  deriving DecidableEq\n\n"}
{"name":"OrderedFinpartition.emb_strictMono","module":"Mathlib.Analysis.Calculus.ContDiff.FaaDiBruno","initialProofState":"n : Nat\nself : OrderedFinpartition n\nm : Fin self.length\n‚ä¢ StrictMono (self.emb m)","decl":"/-- A partition of `Fin n` into finitely many nonempty subsets, given by the increasing\nparameterization of these subsets. We order the subsets by increasing greatest element.\nThis definition is tailored-made for the Faa di Bruno formula, and probably not useful elsewhere,\nbecause of the specific parameterization by `Fin n` and the peculiar ordering. -/\n@[ext]\nstructure OrderedFinpartition (n : ‚Ñï) where\n  /-- The number of parts in the partition -/\n  length : ‚Ñï\n  /-- The size of each part -/\n  partSize : Fin length ‚Üí ‚Ñï\n  partSize_pos : ‚àÄ m, 0 < partSize m\n  /-- The increasing parameterization of each part -/\n  emb : ‚àÄ m, (Fin (partSize m)) ‚Üí Fin n\n  emb_strictMono : ‚àÄ m, StrictMono (emb m)\n  /-- The parts are ordered by increasing greatest element. -/\n  parts_strictMono :\n    StrictMono fun m ‚Ü¶ emb m ‚ü®partSize m - 1, Nat.sub_one_lt_of_lt (partSize_pos m)‚ü©\n  /-- The parts are disjoint -/\n  disjoint : PairwiseDisjoint univ fun m ‚Ü¶ range (emb m)\n  /-- The parts cover everything -/\n  cover x : ‚àÉ m, x ‚àà range (emb m)\n  deriving DecidableEq\n\n"}
{"name":"OrderedFinpartition.cover","module":"Mathlib.Analysis.Calculus.ContDiff.FaaDiBruno","initialProofState":"n : Nat\nself : OrderedFinpartition n\nx : Fin n\n‚ä¢ Exists fun m => Membership.mem (Set.range (self.emb m)) x","decl":"/-- A partition of `Fin n` into finitely many nonempty subsets, given by the increasing\nparameterization of these subsets. We order the subsets by increasing greatest element.\nThis definition is tailored-made for the Faa di Bruno formula, and probably not useful elsewhere,\nbecause of the specific parameterization by `Fin n` and the peculiar ordering. -/\n@[ext]\nstructure OrderedFinpartition (n : ‚Ñï) where\n  /-- The number of parts in the partition -/\n  length : ‚Ñï\n  /-- The size of each part -/\n  partSize : Fin length ‚Üí ‚Ñï\n  partSize_pos : ‚àÄ m, 0 < partSize m\n  /-- The increasing parameterization of each part -/\n  emb : ‚àÄ m, (Fin (partSize m)) ‚Üí Fin n\n  emb_strictMono : ‚àÄ m, StrictMono (emb m)\n  /-- The parts are ordered by increasing greatest element. -/\n  parts_strictMono :\n    StrictMono fun m ‚Ü¶ emb m ‚ü®partSize m - 1, Nat.sub_one_lt_of_lt (partSize_pos m)‚ü©\n  /-- The parts are disjoint -/\n  disjoint : PairwiseDisjoint univ fun m ‚Ü¶ range (emb m)\n  /-- The parts cover everything -/\n  cover x : ‚àÉ m, x ‚àà range (emb m)\n  deriving DecidableEq\n\n"}
{"name":"OrderedFinpartition.mk.sizeOf_spec","module":"Mathlib.Analysis.Calculus.ContDiff.FaaDiBruno","initialProofState":"n length : Nat\npartSize : Fin length ‚Üí Nat\npartSize_pos : ‚àÄ (m : Fin length), LT.lt 0 (partSize m)\nemb : (m : Fin length) ‚Üí Fin (partSize m) ‚Üí Fin n\nemb_strictMono : ‚àÄ (m : Fin length), StrictMono (emb m)\nparts_strictMono : StrictMono fun m => emb m ‚ü®HSub.hSub (partSize m) 1, ‚ãØ‚ü©\ndisjoint : Set.univ.PairwiseDisjoint fun m => Set.range (emb m)\ncover : ‚àÄ (x : Fin n), Exists fun m => Membership.mem (Set.range (emb m)) x\n‚ä¢ Eq (SizeOf.sizeOf { length := length, partSize := partSize, partSize_pos := partSize_pos, emb := emb, emb_strictMono := emb_strictMono, parts_strictMono := parts_strictMono, disjoint := disjoint, cover := cover }) (HAdd.hAdd 1 (SizeOf.sizeOf length))","decl":"/-- A partition of `Fin n` into finitely many nonempty subsets, given by the increasing\nparameterization of these subsets. We order the subsets by increasing greatest element.\nThis definition is tailored-made for the Faa di Bruno formula, and probably not useful elsewhere,\nbecause of the specific parameterization by `Fin n` and the peculiar ordering. -/\n@[ext]\nstructure OrderedFinpartition (n : ‚Ñï) where\n  /-- The number of parts in the partition -/\n  length : ‚Ñï\n  /-- The size of each part -/\n  partSize : Fin length ‚Üí ‚Ñï\n  partSize_pos : ‚àÄ m, 0 < partSize m\n  /-- The increasing parameterization of each part -/\n  emb : ‚àÄ m, (Fin (partSize m)) ‚Üí Fin n\n  emb_strictMono : ‚àÄ m, StrictMono (emb m)\n  /-- The parts are ordered by increasing greatest element. -/\n  parts_strictMono :\n    StrictMono fun m ‚Ü¶ emb m ‚ü®partSize m - 1, Nat.sub_one_lt_of_lt (partSize_pos m)‚ü©\n  /-- The parts are disjoint -/\n  disjoint : PairwiseDisjoint univ fun m ‚Ü¶ range (emb m)\n  /-- The parts cover everything -/\n  cover x : ‚àÉ m, x ‚àà range (emb m)\n  deriving DecidableEq\n\n"}
{"name":"OrderedFinpartition.ext_iff","module":"Mathlib.Analysis.Calculus.ContDiff.FaaDiBruno","initialProofState":"n : Nat\nx y : OrderedFinpartition n\n‚ä¢ Iff (Eq x y) (And (Eq x.length y.length) (And (HEq x.partSize y.partSize) (HEq x.emb y.emb)))","decl":"/-- A partition of `Fin n` into finitely many nonempty subsets, given by the increasing\nparameterization of these subsets. We order the subsets by increasing greatest element.\nThis definition is tailored-made for the Faa di Bruno formula, and probably not useful elsewhere,\nbecause of the specific parameterization by `Fin n` and the peculiar ordering. -/\n@[ext]\nstructure OrderedFinpartition (n : ‚Ñï) where\n  /-- The number of parts in the partition -/\n  length : ‚Ñï\n  /-- The size of each part -/\n  partSize : Fin length ‚Üí ‚Ñï\n  partSize_pos : ‚àÄ m, 0 < partSize m\n  /-- The increasing parameterization of each part -/\n  emb : ‚àÄ m, (Fin (partSize m)) ‚Üí Fin n\n  emb_strictMono : ‚àÄ m, StrictMono (emb m)\n  /-- The parts are ordered by increasing greatest element. -/\n  parts_strictMono :\n    StrictMono fun m ‚Ü¶ emb m ‚ü®partSize m - 1, Nat.sub_one_lt_of_lt (partSize_pos m)‚ü©\n  /-- The parts are disjoint -/\n  disjoint : PairwiseDisjoint univ fun m ‚Ü¶ range (emb m)\n  /-- The parts cover everything -/\n  cover x : ‚àÉ m, x ‚àà range (emb m)\n  deriving DecidableEq\n\n"}
{"name":"OrderedFinpartition.mk.inj","module":"Mathlib.Analysis.Calculus.ContDiff.FaaDiBruno","initialProofState":"n length‚úù : Nat\npartSize‚úù : Fin length‚úù ‚Üí Nat\npartSize_pos‚úù : ‚àÄ (m : Fin length‚úù), LT.lt 0 (partSize‚úù m)\nemb‚úù : (m : Fin length‚úù) ‚Üí Fin (partSize‚úù m) ‚Üí Fin n\nemb_strictMono‚úù : ‚àÄ (m : Fin length‚úù), StrictMono (emb‚úù m)\nparts_strictMono‚úù : StrictMono fun m => emb‚úù m ‚ü®HSub.hSub (partSize‚úù m) 1, ‚ãØ‚ü©\ndisjoint‚úù : Set.univ.PairwiseDisjoint fun m => Set.range (emb‚úù m)\ncover‚úù : ‚àÄ (x : Fin n), Exists fun m => Membership.mem (Set.range (emb‚úù m)) x\nlength : Nat\npartSize : Fin length ‚Üí Nat\npartSize_pos : ‚àÄ (m : Fin length), LT.lt 0 (partSize m)\nemb : (m : Fin length) ‚Üí Fin (partSize m) ‚Üí Fin n\nemb_strictMono : ‚àÄ (m : Fin length), StrictMono (emb m)\nparts_strictMono : StrictMono fun m => emb m ‚ü®HSub.hSub (partSize m) 1, ‚ãØ‚ü©\ndisjoint : Set.univ.PairwiseDisjoint fun m => Set.range (emb m)\ncover : ‚àÄ (x : Fin n), Exists fun m => Membership.mem (Set.range (emb m)) x\nx‚úù : Eq { length := length‚úù, partSize := partSize‚úù, partSize_pos := partSize_pos‚úù, emb := emb‚úù, emb_strictMono := emb_strictMono‚úù, parts_strictMono := parts_strictMono‚úù, disjoint := disjoint‚úù, cover := cover‚úù } { length := length, partSize := partSize, partSize_pos := partSize_pos, emb := emb, emb_strictMono := emb_strictMono, parts_strictMono := parts_strictMono, disjoint := disjoint, cover := cover }\n‚ä¢ And (Eq length‚úù length) (And (HEq partSize‚úù partSize) (HEq emb‚úù emb))","decl":"/-- A partition of `Fin n` into finitely many nonempty subsets, given by the increasing\nparameterization of these subsets. We order the subsets by increasing greatest element.\nThis definition is tailored-made for the Faa di Bruno formula, and probably not useful elsewhere,\nbecause of the specific parameterization by `Fin n` and the peculiar ordering. -/\n@[ext]\nstructure OrderedFinpartition (n : ‚Ñï) where\n  /-- The number of parts in the partition -/\n  length : ‚Ñï\n  /-- The size of each part -/\n  partSize : Fin length ‚Üí ‚Ñï\n  partSize_pos : ‚àÄ m, 0 < partSize m\n  /-- The increasing parameterization of each part -/\n  emb : ‚àÄ m, (Fin (partSize m)) ‚Üí Fin n\n  emb_strictMono : ‚àÄ m, StrictMono (emb m)\n  /-- The parts are ordered by increasing greatest element. -/\n  parts_strictMono :\n    StrictMono fun m ‚Ü¶ emb m ‚ü®partSize m - 1, Nat.sub_one_lt_of_lt (partSize_pos m)‚ü©\n  /-- The parts are disjoint -/\n  disjoint : PairwiseDisjoint univ fun m ‚Ü¶ range (emb m)\n  /-- The parts cover everything -/\n  cover x : ‚àÉ m, x ‚àà range (emb m)\n  deriving DecidableEq\n\n"}
{"name":"OrderedFinpartition.disjoint","module":"Mathlib.Analysis.Calculus.ContDiff.FaaDiBruno","initialProofState":"n : Nat\nself : OrderedFinpartition n\n‚ä¢ Set.univ.PairwiseDisjoint fun m => Set.range (self.emb m)","decl":"/-- A partition of `Fin n` into finitely many nonempty subsets, given by the increasing\nparameterization of these subsets. We order the subsets by increasing greatest element.\nThis definition is tailored-made for the Faa di Bruno formula, and probably not useful elsewhere,\nbecause of the specific parameterization by `Fin n` and the peculiar ordering. -/\n@[ext]\nstructure OrderedFinpartition (n : ‚Ñï) where\n  /-- The number of parts in the partition -/\n  length : ‚Ñï\n  /-- The size of each part -/\n  partSize : Fin length ‚Üí ‚Ñï\n  partSize_pos : ‚àÄ m, 0 < partSize m\n  /-- The increasing parameterization of each part -/\n  emb : ‚àÄ m, (Fin (partSize m)) ‚Üí Fin n\n  emb_strictMono : ‚àÄ m, StrictMono (emb m)\n  /-- The parts are ordered by increasing greatest element. -/\n  parts_strictMono :\n    StrictMono fun m ‚Ü¶ emb m ‚ü®partSize m - 1, Nat.sub_one_lt_of_lt (partSize_pos m)‚ü©\n  /-- The parts are disjoint -/\n  disjoint : PairwiseDisjoint univ fun m ‚Ü¶ range (emb m)\n  /-- The parts cover everything -/\n  cover x : ‚àÉ m, x ‚àà range (emb m)\n  deriving DecidableEq\n\n"}
{"name":"OrderedFinpartition.mk.injEq","module":"Mathlib.Analysis.Calculus.ContDiff.FaaDiBruno","initialProofState":"n length‚úù : Nat\npartSize‚úù : Fin length‚úù ‚Üí Nat\npartSize_pos‚úù : ‚àÄ (m : Fin length‚úù), LT.lt 0 (partSize‚úù m)\nemb‚úù : (m : Fin length‚úù) ‚Üí Fin (partSize‚úù m) ‚Üí Fin n\nemb_strictMono‚úù : ‚àÄ (m : Fin length‚úù), StrictMono (emb‚úù m)\nparts_strictMono‚úù : StrictMono fun m => emb‚úù m ‚ü®HSub.hSub (partSize‚úù m) 1, ‚ãØ‚ü©\ndisjoint‚úù : Set.univ.PairwiseDisjoint fun m => Set.range (emb‚úù m)\ncover‚úù : ‚àÄ (x : Fin n), Exists fun m => Membership.mem (Set.range (emb‚úù m)) x\nlength : Nat\npartSize : Fin length ‚Üí Nat\npartSize_pos : ‚àÄ (m : Fin length), LT.lt 0 (partSize m)\nemb : (m : Fin length) ‚Üí Fin (partSize m) ‚Üí Fin n\nemb_strictMono : ‚àÄ (m : Fin length), StrictMono (emb m)\nparts_strictMono : StrictMono fun m => emb m ‚ü®HSub.hSub (partSize m) 1, ‚ãØ‚ü©\ndisjoint : Set.univ.PairwiseDisjoint fun m => Set.range (emb m)\ncover : ‚àÄ (x : Fin n), Exists fun m => Membership.mem (Set.range (emb m)) x\n‚ä¢ Eq (Eq { length := length‚úù, partSize := partSize‚úù, partSize_pos := partSize_pos‚úù, emb := emb‚úù, emb_strictMono := emb_strictMono‚úù, parts_strictMono := parts_strictMono‚úù, disjoint := disjoint‚úù, cover := cover‚úù } { length := length, partSize := partSize, partSize_pos := partSize_pos, emb := emb, emb_strictMono := emb_strictMono, parts_strictMono := parts_strictMono, disjoint := disjoint, cover := cover }) (And (Eq length‚úù length) (And (HEq partSize‚úù partSize) (HEq emb‚úù emb)))","decl":"/-- A partition of `Fin n` into finitely many nonempty subsets, given by the increasing\nparameterization of these subsets. We order the subsets by increasing greatest element.\nThis definition is tailored-made for the Faa di Bruno formula, and probably not useful elsewhere,\nbecause of the specific parameterization by `Fin n` and the peculiar ordering. -/\n@[ext]\nstructure OrderedFinpartition (n : ‚Ñï) where\n  /-- The number of parts in the partition -/\n  length : ‚Ñï\n  /-- The size of each part -/\n  partSize : Fin length ‚Üí ‚Ñï\n  partSize_pos : ‚àÄ m, 0 < partSize m\n  /-- The increasing parameterization of each part -/\n  emb : ‚àÄ m, (Fin (partSize m)) ‚Üí Fin n\n  emb_strictMono : ‚àÄ m, StrictMono (emb m)\n  /-- The parts are ordered by increasing greatest element. -/\n  parts_strictMono :\n    StrictMono fun m ‚Ü¶ emb m ‚ü®partSize m - 1, Nat.sub_one_lt_of_lt (partSize_pos m)‚ü©\n  /-- The parts are disjoint -/\n  disjoint : PairwiseDisjoint univ fun m ‚Ü¶ range (emb m)\n  /-- The parts cover everything -/\n  cover x : ‚àÉ m, x ‚àà range (emb m)\n  deriving DecidableEq\n\n"}
{"name":"OrderedFinpartition.atomic_length","module":"Mathlib.Analysis.Calculus.ContDiff.FaaDiBruno","initialProofState":"n : Nat\n‚ä¢ Eq (OrderedFinpartition.atomic n).length n","decl":"/-- The ordered finpartition of `Fin n` into singletons. -/\n@[simps] def atomic (n : ‚Ñï) : OrderedFinpartition n where\n  length := n\n  partSize _ :=  1\n  partSize_pos _ := _root_.zero_lt_one\n  emb m _ := m\n  emb_strictMono _ := Subsingleton.strictMono _\n  parts_strictMono := strictMono_id\n  disjoint _ _ _ _ h := by simpa using h\n  cover m := by simp\n\n"}
{"name":"OrderedFinpartition.atomic_partSize","module":"Mathlib.Analysis.Calculus.ContDiff.FaaDiBruno","initialProofState":"n : Nat\nx‚úù : Fin n\n‚ä¢ Eq ((OrderedFinpartition.atomic n).partSize x‚úù) 1","decl":"/-- The ordered finpartition of `Fin n` into singletons. -/\n@[simps] def atomic (n : ‚Ñï) : OrderedFinpartition n where\n  length := n\n  partSize _ :=  1\n  partSize_pos _ := _root_.zero_lt_one\n  emb m _ := m\n  emb_strictMono _ := Subsingleton.strictMono _\n  parts_strictMono := strictMono_id\n  disjoint _ _ _ _ h := by simpa using h\n  cover m := by simp\n\n"}
{"name":"OrderedFinpartition.atomic_emb","module":"Mathlib.Analysis.Calculus.ContDiff.FaaDiBruno","initialProofState":"n : Nat\nm : Fin n\nx‚úù : Fin ((fun x => 1) m)\n‚ä¢ Eq ((OrderedFinpartition.atomic n).emb m x‚úù) m","decl":"/-- The ordered finpartition of `Fin n` into singletons. -/\n@[simps] def atomic (n : ‚Ñï) : OrderedFinpartition n where\n  length := n\n  partSize _ :=  1\n  partSize_pos _ := _root_.zero_lt_one\n  emb m _ := m\n  emb_strictMono _ := Subsingleton.strictMono _\n  parts_strictMono := strictMono_id\n  disjoint _ _ _ _ h := by simpa using h\n  cover m := by simp\n\n"}
{"name":"OrderedFinpartition.length_le","module":"Mathlib.Analysis.Calculus.ContDiff.FaaDiBruno","initialProofState":"n : Nat\nc : OrderedFinpartition n\n‚ä¢ LE.le c.length n","decl":"lemma length_le : c.length ‚â§ n := by\n  simpa only [Fintype.card_fin] using Fintype.card_le_of_injective _ c.parts_strictMono.injective\n\n"}
{"name":"OrderedFinpartition.partSize_le","module":"Mathlib.Analysis.Calculus.ContDiff.FaaDiBruno","initialProofState":"n : Nat\nc : OrderedFinpartition n\nm : Fin c.length\n‚ä¢ LE.le (c.partSize m) n","decl":"lemma partSize_le (m : Fin c.length) : c.partSize m ‚â§ n := by\n  simpa only [Fintype.card_fin] using Fintype.card_le_of_injective _ (c.emb_strictMono m).injective\n\n"}
{"name":"OrderedFinpartition.injective_embSigma","module":"Mathlib.Analysis.Calculus.ContDiff.FaaDiBruno","initialProofState":"n : Nat\n‚ä¢ Function.Injective (OrderedFinpartition.embSigma n)","decl":"lemma injective_embSigma (n : ‚Ñï) : Injective (embSigma n) := by\n  rintro ‚ü®plength, psize, -, pemb, -, -, -, -‚ü© ‚ü®qlength, qsize, -, qemb, -, -, -, -‚ü©\n  intro hpq\n  simp_all only [Sigma.mk.inj_iff, heq_eq_eq, true_and, mk.injEq, and_true, Fin.mk.injEq, embSigma]\n  have : plength = qlength := hpq.1\n  subst this\n  simp_all only [Sigma.mk.inj_iff, heq_eq_eq, true_and, mk.injEq, and_true, Fin.mk.injEq, embSigma]\n  ext i\n  exact mk.inj_iff.mp (congr_fun hpq.1 i)\n\n/- The best proof would probably to establish the bijection with Finpartitions, but we opt\nfor a direct argument, embedding `OrderedPartition n` in a type which is obviously finite. -/\n"}
{"name":"OrderedFinpartition.exists_inverse","module":"Mathlib.Analysis.Calculus.ContDiff.FaaDiBruno","initialProofState":"n : Nat\nc : OrderedFinpartition n\nj : Fin n\n‚ä¢ Exists fun p => Eq (c.emb p.fst p.snd) j","decl":"lemma exists_inverse {n : ‚Ñï} (c : OrderedFinpartition n) (j : Fin n) :\n    ‚àÉ p : Œ£ m, Fin (c.partSize m), c.emb p.1 p.2 = j := by\n  rcases c.cover j with ‚ü®m, r, hmr‚ü©\n  exact ‚ü®‚ü®m, r‚ü©, hmr‚ü©\n\n"}
{"name":"OrderedFinpartition.emb_injective","module":"Mathlib.Analysis.Calculus.ContDiff.FaaDiBruno","initialProofState":"n : Nat\nc : OrderedFinpartition n\n‚ä¢ Function.Injective fun p => c.emb p.fst p.snd","decl":"lemma emb_injective : Injective (fun (p : Œ£ m, Fin (c.partSize m)) ‚Ü¶ c.emb p.1 p.2) := by\n  rintro ‚ü®m, r‚ü© ‚ü®m', r'‚ü© (h : c.emb m r = c.emb m' r')\n  have : m = m' := by\n    contrapose! h\n    have A : Disjoint (range (c.emb m)) (range (c.emb m')) :=\n      c.disjoint (mem_univ m) (mem_univ m') h\n    apply disjoint_iff_forall_ne.1 A (mem_range_self r) (mem_range_self r')\n  subst this\n  simpa using (c.emb_strictMono m).injective h\n\n"}
{"name":"OrderedFinpartition.emb_ne_emb_of_ne","module":"Mathlib.Analysis.Calculus.ContDiff.FaaDiBruno","initialProofState":"n : Nat\nc : OrderedFinpartition n\ni j : Fin c.length\na : Fin (c.partSize i)\nb : Fin (c.partSize j)\nh : Ne i j\n‚ä¢ Ne (c.emb i a) (c.emb j b)","decl":"lemma emb_ne_emb_of_ne {i j : Fin c.length} {a : Fin (c.partSize i)} {b : Fin (c.partSize j)}\n    (h : i ‚â† j) : c.emb i a ‚â† c.emb j b :=\n  c.emb_injective.ne (a‚ÇÅ := ‚ü®i, a‚ü©) (a‚ÇÇ := ‚ü®j, b‚ü©) (by simp [h])\n\n"}
{"name":"OrderedFinpartition.emb_invEmbedding","module":"Mathlib.Analysis.Calculus.ContDiff.FaaDiBruno","initialProofState":"n : Nat\nc : OrderedFinpartition n\nj : Fin n\n‚ä¢ Eq (c.emb (c.index j) (c.invEmbedding j)) j","decl":"@[simp] lemma emb_invEmbedding (j : Fin n) :\n    c.emb (c.index j) (c.invEmbedding j) = j :=\n  (c.exists_inverse j).choose_spec\n\n"}
{"name":"OrderedFinpartition.prod_sigma_eq_prod","module":"Mathlib.Analysis.Calculus.ContDiff.FaaDiBruno","initialProofState":"n : Nat\nc : OrderedFinpartition n\nŒ± : Type u_5\ninst‚úù : CommMonoid Œ±\nv : Fin n ‚Üí Œ±\n‚ä¢ Eq (Finset.univ.prod fun m => Finset.univ.prod fun r => v (c.emb m r)) (Finset.univ.prod fun i => v i)","decl":"@[to_additive] lemma prod_sigma_eq_prod {Œ± : Type*} [CommMonoid Œ±] (v : Fin n ‚Üí Œ±) :\n    ‚àè (m : Fin c.length), ‚àè (r : Fin (c.partSize m)), v (c.emb m r) = ‚àè i, v i := by\n  rw [Finset.prod_sigma']\n  exact Fintype.prod_equiv c.equivSigma _ _ (fun p ‚Ü¶ rfl)\n\n"}
{"name":"OrderedFinpartition.sum_sigma_eq_sum","module":"Mathlib.Analysis.Calculus.ContDiff.FaaDiBruno","initialProofState":"n : Nat\nc : OrderedFinpartition n\nŒ± : Type u_5\ninst‚úù : AddCommMonoid Œ±\nv : Fin n ‚Üí Œ±\n‚ä¢ Eq (Finset.univ.sum fun m => Finset.univ.sum fun r => v (c.emb m r)) (Finset.univ.sum fun i => v i)","decl":"@[to_additive] lemma prod_sigma_eq_prod {Œ± : Type*} [CommMonoid Œ±] (v : Fin n ‚Üí Œ±) :\n    ‚àè (m : Fin c.length), ‚àè (r : Fin (c.partSize m)), v (c.emb m r) = ‚àè i, v i := by\n  rw [Finset.prod_sigma']\n  exact Fintype.prod_equiv c.equivSigma _ _ (fun p ‚Ü¶ rfl)\n\n"}
{"name":"OrderedFinpartition.length_pos","module":"Mathlib.Analysis.Calculus.ContDiff.FaaDiBruno","initialProofState":"n : Nat\nc : OrderedFinpartition n\nh : LT.lt 0 n\n‚ä¢ LT.lt 0 c.length","decl":"lemma length_pos (h : 0 < n) : 0 < c.length := Nat.zero_lt_of_lt (c.index ‚ü®0, h‚ü©).2\n\n"}
{"name":"OrderedFinpartition.neZero_length","module":"Mathlib.Analysis.Calculus.ContDiff.FaaDiBruno","initialProofState":"n : Nat\ninst‚úù : NeZero n\nc : OrderedFinpartition n\n‚ä¢ NeZero c.length","decl":"lemma neZero_length [NeZero n] (c : OrderedFinpartition n) : NeZero c.length :=\n  ‚ü®(c.length_pos pos').ne'‚ü©\n\n"}
{"name":"OrderedFinpartition.neZero_partSize","module":"Mathlib.Analysis.Calculus.ContDiff.FaaDiBruno","initialProofState":"n : Nat\nc : OrderedFinpartition n\ni : Fin c.length\n‚ä¢ NeZero (c.partSize i)","decl":"lemma neZero_partSize (c : OrderedFinpartition n) (i : Fin c.length) : NeZero (c.partSize i) :=\n  .of_pos (c.partSize_pos i)\n\n"}
{"name":"OrderedFinpartition.emb_zero","module":"Mathlib.Analysis.Calculus.ContDiff.FaaDiBruno","initialProofState":"n : Nat\nc : OrderedFinpartition n\ninst‚úù : NeZero n\n‚ä¢ Eq (c.emb (c.index 0) 0) 0","decl":"lemma emb_zero [NeZero n] : c.emb (c.index 0) 0 = 0 := by\n  apply le_antisymm _ (Fin.zero_le' _)\n  conv_rhs => rw [‚Üê c.emb_invEmbedding 0]\n  apply (c.emb_strictMono _).monotone (Fin.zero_le' _)\n\n"}
{"name":"OrderedFinpartition.partSize_eq_one_of_range_emb_eq_singleton","module":"Mathlib.Analysis.Calculus.ContDiff.FaaDiBruno","initialProofState":"n : Nat\nc : OrderedFinpartition n\ni : Fin c.length\nj : Fin n\nhc : Eq (Set.range (c.emb i)) (Singleton.singleton j)\n‚ä¢ Eq (c.partSize i) 1","decl":"lemma partSize_eq_one_of_range_emb_eq_singleton\n    (c : OrderedFinpartition n) {i : Fin c.length} {j : Fin n}\n    (hc : range (c.emb i) = {j}) :\n    c.partSize i = 1 := by\n  have : Fintype.card (range (c.emb i)) = Fintype.card (Fin (c.partSize i)) :=\n    card_range_of_injective (c.emb_strictMono i).injective\n  simpa [hc] using this.symm\n\n"}
{"name":"OrderedFinpartition.one_lt_partSize_index_zero","module":"Mathlib.Analysis.Calculus.ContDiff.FaaDiBruno","initialProofState":"n : Nat\nc : OrderedFinpartition (HAdd.hAdd n 1)\nhc : Ne (Set.range (c.emb 0)) (Singleton.singleton 0)\n‚ä¢ LT.lt 1 (c.partSize (c.index 0))","decl":"/-- If the left-most part is not `{0}`, then the part containing `0` has at least two elements:\neither because it's the left-most part, and then it's not just `0` by assumption, or because it's\nnot the left-most part and then, by increasingness of maximal elements in parts, it contains\na positive element. -/\nlemma one_lt_partSize_index_zero (c : OrderedFinpartition (n + 1)) (hc : range (c.emb 0) ‚â† {0}) :\n    1 < c.partSize (c.index 0) := by\n  have : c.partSize (c.index 0) = Nat.card (range (c.emb (c.index 0))) := by\n    rw [Nat.card_range_of_injective (c.emb_strictMono _).injective]; simp\n  rw [this]\n  rcases eq_or_ne (c.index 0) 0 with h | h\n  ¬∑ rw [‚Üê h] at hc\n    have : {0} ‚äÇ range (c.emb (c.index 0)) := by\n      apply ssubset_of_subset_of_ne ?_ hc.symm\n      simpa only [singleton_subset_iff, mem_range] using ‚ü®0, emb_zero c‚ü©\n    simpa using Set.Finite.card_lt_card (finite_range _) this\n  ¬∑ apply one_lt_two.trans_le\n    have : {c.emb (c.index 0) 0,\n        c.emb (c.index 0) ‚ü®c.partSize (c.index 0) - 1, Nat.sub_one_lt_of_lt (c.partSize_pos _)‚ü©}\n          ‚äÜ range (c.emb (c.index 0)) := by simp [insert_subset]\n    simp [emb_zero] at this\n    convert Nat.card_mono Subtype.finite this\n    simp only [Nat.card_eq_fintype_card, Fintype.card_ofFinset, toFinset_singleton]\n    apply (Finset.card_pair ?_).symm\n    exact ((Fin.zero_le _).trans_lt (c.parts_strictMono ((pos_iff_ne_zero' (c.index 0)).mpr h))).ne\n\n"}
{"name":"OrderedFinpartition.range_extendLeft_zero","module":"Mathlib.Analysis.Calculus.ContDiff.FaaDiBruno","initialProofState":"n : Nat\nc : OrderedFinpartition n\n‚ä¢ Eq (Set.range (c.extendLeft.emb 0)) (Singleton.singleton 0)","decl":"@[simp] lemma range_extendLeft_zero (c : OrderedFinpartition n) :\n    range (c.extendLeft.emb 0) = {0} := by\n  simp [extendLeft]\n  apply @range_const _ _ (by simp; infer_instance)\n\n"}
{"name":"OrderedFinpartition.index_extendMiddle_zero","module":"Mathlib.Analysis.Calculus.ContDiff.FaaDiBruno","initialProofState":"n : Nat\nc : OrderedFinpartition n\ni : Fin c.length\n‚ä¢ Eq ((c.extendMiddle i).index 0) i","decl":"lemma index_extendMiddle_zero (c : OrderedFinpartition n) (i : Fin c.length) :\n    (c.extendMiddle i).index 0 = i := by\n  have : (c.extendMiddle i).emb i 0 = 0 := by simp [extendMiddle]\n  conv_rhs at this => rw [‚Üê (c.extendMiddle i).emb_invEmbedding 0]\n  contrapose! this\n  exact (c.extendMiddle i).emb_ne_emb_of_ne (Ne.symm this)\n\n"}
{"name":"OrderedFinpartition.range_emb_extendMiddle_ne_singleton_zero","module":"Mathlib.Analysis.Calculus.ContDiff.FaaDiBruno","initialProofState":"n : Nat\nc : OrderedFinpartition n\ni j : Fin c.length\n‚ä¢ Ne (Set.range ((c.extendMiddle i).emb j)) (Singleton.singleton 0)","decl":"lemma range_emb_extendMiddle_ne_singleton_zero (c : OrderedFinpartition n) (i j : Fin c.length) :\n    range ((c.extendMiddle i).emb j) ‚â† {0} := by\n  intro h\n  rcases eq_or_ne j i with rfl | hij\n  ¬∑ have : Fin.succ (c.emb j 0) ‚àà ({0} : Set (Fin n.succ)) := by\n      rw [‚Üê h]\n      simp only [Nat.succ_eq_add_one, mem_range]\n      have A : (c.extendMiddle j).partSize j = c.partSize j + 1 := by simp [extendMiddle]\n      refine ‚ü®Fin.cast A.symm (succ 0), ?_‚ü©\n      simp only [extendMiddle, ‚ÜìreduceDIte, comp_apply, cast_trans, cast_eq_self, cases_succ]\n    simp only [mem_singleton_iff] at this\n    exact Fin.succ_ne_zero _ this\n  ¬∑ have : (c.extendMiddle i).emb j 0 ‚àà range ((c.extendMiddle i).emb j) :=\n      mem_range_self 0\n    rw [h] at this\n    simp only [extendMiddle, hij, ‚ÜìreduceDIte, comp_apply, cast_zero, mem_singleton_iff] at this\n    exact Fin.succ_ne_zero _ this\n\n"}
{"name":"OrderedFinpartition.applyOrderedFinpartition_apply","module":"Mathlib.Analysis.Calculus.ContDiff.FaaDiBruno","initialProofState":"ùïú : Type u_1\ninst‚úù‚Å¥ : NontriviallyNormedField ùïú\nE : Type u_2\ninst‚úù¬≥ : NormedAddCommGroup E\ninst‚úù¬≤ : NormedSpace ùïú E\nF : Type u_3\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : NormedSpace ùïú F\nn : Nat\nc : OrderedFinpartition n\np : (i : Fin c.length) ‚Üí ContinuousMultilinearMap ùïú (fun i => E) F\nv : Fin n ‚Üí E\n‚ä¢ Eq (c.applyOrderedFinpartition p v) fun m => (p m) (Function.comp v (c.emb m))","decl":"lemma applyOrderedFinpartition_apply (p : ‚àÄ (i : Fin c.length), E[√óc.partSize i]‚ÜíL[ùïú] F)\n    (v : Fin n ‚Üí E) :\n  c.applyOrderedFinpartition p v = (fun m ‚Ü¶ p m (v ‚àò c.emb m)) := rfl\n\n"}
{"name":"OrderedFinpartition.norm_applyOrderedFinpartition_le","module":"Mathlib.Analysis.Calculus.ContDiff.FaaDiBruno","initialProofState":"ùïú : Type u_1\ninst‚úù‚Å¥ : NontriviallyNormedField ùïú\nE : Type u_2\ninst‚úù¬≥ : NormedAddCommGroup E\ninst‚úù¬≤ : NormedSpace ùïú E\nF : Type u_3\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : NormedSpace ùïú F\nn : Nat\nc : OrderedFinpartition n\np : (i : Fin c.length) ‚Üí ContinuousMultilinearMap ùïú (fun i => E) F\nv : Fin n ‚Üí E\nm : Fin c.length\n‚ä¢ LE.le (Norm.norm (c.applyOrderedFinpartition p v m)) (HMul.hMul (Norm.norm (p m)) (Finset.univ.prod fun i => Norm.norm (v (c.emb m i))))","decl":"theorem norm_applyOrderedFinpartition_le (p : ‚àÄ (i : Fin c.length), E[√óc.partSize i]‚ÜíL[ùïú] F)\n    (v : Fin n ‚Üí E) (m : Fin c.length) :\n    ‚Äñc.applyOrderedFinpartition p v m‚Äñ ‚â§ ‚Äñp m‚Äñ * ‚àè i : Fin (c.partSize m), ‚Äñv (c.emb m i)‚Äñ :=\n  (p m).le_opNorm _\n\n"}
{"name":"OrderedFinpartition.applyOrderedFinpartition_update_right","module":"Mathlib.Analysis.Calculus.ContDiff.FaaDiBruno","initialProofState":"ùïú : Type u_1\ninst‚úù‚Å¥ : NontriviallyNormedField ùïú\nE : Type u_2\ninst‚úù¬≥ : NormedAddCommGroup E\ninst‚úù¬≤ : NormedSpace ùïú E\nF : Type u_3\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : NormedSpace ùïú F\nn : Nat\nc : OrderedFinpartition n\np : (i : Fin c.length) ‚Üí ContinuousMultilinearMap ùïú (fun i => E) F\nj : Fin n\nv : Fin n ‚Üí E\nz : E\n‚ä¢ Eq (c.applyOrderedFinpartition p (Function.update v j z)) (Function.update (c.applyOrderedFinpartition p v) (c.index j) ((p (c.index j)) (Function.update (Function.comp v (c.emb (c.index j))) (c.invEmbedding j) z)))","decl":"/-- Technical lemma stating how `c.applyOrderedFinpartition` commutes with updating variables. This\nwill be the key point to show that functions constructed from `applyOrderedFinpartition` retain\nmultilinearity. -/\ntheorem applyOrderedFinpartition_update_right\n    (p : ‚àÄ (i : Fin c.length), E[√óc.partSize i]‚ÜíL[ùïú] F)\n    (j : Fin n) (v : Fin n ‚Üí E) (z : E) :\n    c.applyOrderedFinpartition p (update v j z) =\n      update (c.applyOrderedFinpartition p v) (c.index j)\n        (p (c.index j)\n          (Function.update (v ‚àò c.emb (c.index j)) (c.invEmbedding j) z)) := by\n  ext m\n  by_cases h : m = c.index j\n  ¬∑ rw [h]\n    simp only [applyOrderedFinpartition, update_self]\n    congr\n    rw [‚Üê Function.update_comp_eq_of_injective]\n    ¬∑ simp\n    ¬∑ exact (c.emb_strictMono (c.index j)).injective\n  ¬∑ simp only [applyOrderedFinpartition, ne_eq, h, not_false_eq_true,\n      update_of_ne]\n    congr\n    apply Function.update_comp_eq_of_not_mem_range\n    have A : Disjoint (range (c.emb m)) (range (c.emb (c.index j))) :=\n      c.disjoint (mem_univ m) (mem_univ (c.index j)) h\n    have : j ‚àà range (c.emb (c.index j)) := mem_range.2 ‚ü®c.invEmbedding j, by simp‚ü©\n    exact Set.disjoint_right.1 A this\n\n"}
{"name":"OrderedFinpartition.applyOrderedFinpartition_update_left","module":"Mathlib.Analysis.Calculus.ContDiff.FaaDiBruno","initialProofState":"ùïú : Type u_1\ninst‚úù‚Å¥ : NontriviallyNormedField ùïú\nE : Type u_2\ninst‚úù¬≥ : NormedAddCommGroup E\ninst‚úù¬≤ : NormedSpace ùïú E\nF : Type u_3\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : NormedSpace ùïú F\nn : Nat\nc : OrderedFinpartition n\np : (i : Fin c.length) ‚Üí ContinuousMultilinearMap ùïú (fun i => E) F\nm : Fin c.length\nv : Fin n ‚Üí E\nq : ContinuousMultilinearMap ùïú (fun i => E) F\n‚ä¢ Eq (c.applyOrderedFinpartition (Function.update p m q) v) (Function.update (c.applyOrderedFinpartition p v) m (q (Function.comp v (c.emb m))))","decl":"theorem applyOrderedFinpartition_update_left (p : ‚àÄ (i : Fin c.length), E[√óc.partSize i]‚ÜíL[ùïú] F)\n    (m : Fin c.length) (v : Fin n ‚Üí E) (q : E[√óc.partSize m]‚ÜíL[ùïú] F) :\n    c.applyOrderedFinpartition (update p m q) v\n      = update (c.applyOrderedFinpartition p v) m (q (v ‚àò c.emb m)) := by\n  ext d\n  by_cases h : d = m\n  ¬∑ rw [h]\n    simp [applyOrderedFinpartition]\n  ¬∑ simp [h, applyOrderedFinpartition]\n\n"}
{"name":"OrderedFinpartition.compAlongOrderFinpartition_apply","module":"Mathlib.Analysis.Calculus.ContDiff.FaaDiBruno","initialProofState":"ùïú : Type u_1\ninst‚úù‚Å∂ : NontriviallyNormedField ùïú\nE : Type u_2\ninst‚úù‚Åµ : NormedAddCommGroup E\ninst‚úù‚Å¥ : NormedSpace ùïú E\nF : Type u_3\ninst‚úù¬≥ : NormedAddCommGroup F\ninst‚úù¬≤ : NormedSpace ùïú F\nG : Type u_4\ninst‚úù¬π : NormedAddCommGroup G\ninst‚úù : NormedSpace ùïú G\nn : Nat\nc : OrderedFinpartition n\nf : ContinuousMultilinearMap ùïú (fun i => F) G\np : (i : Fin c.length) ‚Üí ContinuousMultilinearMap ùïú (fun i => E) F\nv : Fin n ‚Üí E\n‚ä¢ Eq ((c.compAlongOrderedFinpartition f p) v) (f (c.applyOrderedFinpartition p v))","decl":"@[simp] lemma compAlongOrderFinpartition_apply (f : F [√óc.length]‚ÜíL[ùïú] G)\n    (p : ‚àÄ i, E[√óc.partSize i]‚ÜíL[ùïú] F) (v : Fin n ‚Üí E) :\n    c.compAlongOrderedFinpartition f p v = f (c.applyOrderedFinpartition p v) := rfl\n\n"}
{"name":"OrderedFinpartition.norm_compAlongOrderedFinpartition_le","module":"Mathlib.Analysis.Calculus.ContDiff.FaaDiBruno","initialProofState":"ùïú : Type u_1\ninst‚úù‚Å∂ : NontriviallyNormedField ùïú\nE : Type u_2\ninst‚úù‚Åµ : NormedAddCommGroup E\ninst‚úù‚Å¥ : NormedSpace ùïú E\nF : Type u_3\ninst‚úù¬≥ : NormedAddCommGroup F\ninst‚úù¬≤ : NormedSpace ùïú F\nG : Type u_4\ninst‚úù¬π : NormedAddCommGroup G\ninst‚úù : NormedSpace ùïú G\nn : Nat\nc : OrderedFinpartition n\nf : ContinuousMultilinearMap ùïú (fun i => F) G\np : (i : Fin c.length) ‚Üí ContinuousMultilinearMap ùïú (fun i => E) F\n‚ä¢ LE.le (Norm.norm (c.compAlongOrderedFinpartition f p)) (HMul.hMul (Norm.norm f) (Finset.univ.prod fun i => Norm.norm (p i)))","decl":"theorem norm_compAlongOrderedFinpartition_le (f : F [√óc.length]‚ÜíL[ùïú] G)\n    (p : ‚àÄ i, E [√óc.partSize i]‚ÜíL[ùïú] F) :\n    ‚Äñc.compAlongOrderedFinpartition f p‚Äñ ‚â§ ‚Äñf‚Äñ * ‚àè i, ‚Äñp i‚Äñ := by\n  refine ContinuousMultilinearMap.opNorm_le_bound (by positivity) fun v ‚Ü¶ ?_\n  rw [compAlongOrderFinpartition_apply, mul_assoc, ‚Üê c.prod_sigma_eq_prod,\n    ‚Üê Finset.prod_mul_distrib]\n  exact f.le_opNorm_mul_prod_of_le <| c.norm_applyOrderedFinpartition_le _ _\n\n"}
{"name":"OrderedFinpartition.compAlongOrderedFinpartition‚Çó_apply_apply","module":"Mathlib.Analysis.Calculus.ContDiff.FaaDiBruno","initialProofState":"ùïú : Type u_1\ninst‚úù‚Å∂ : NontriviallyNormedField ùïú\nE : Type u_2\ninst‚úù‚Åµ : NormedAddCommGroup E\ninst‚úù‚Å¥ : NormedSpace ùïú E\nF : Type u_3\ninst‚úù¬≥ : NormedAddCommGroup F\ninst‚úù¬≤ : NormedSpace ùïú F\nG : Type u_4\ninst‚úù¬π : NormedAddCommGroup G\ninst‚úù : NormedSpace ùïú G\nn : Nat\nc : OrderedFinpartition n\nf : ContinuousMultilinearMap ùïú (fun i => F) G\np : (i : Fin c.length) ‚Üí ContinuousMultilinearMap ùïú (fun i => E) F\n‚ä¢ Eq ((c.compAlongOrderedFinpartition‚Çó f) p) (c.compAlongOrderedFinpartition f p)","decl":"/-- Bundled version of `compAlongOrderedFinpartition`, depending linearly on `f`\nand multilinearly on `p`.-/\n@[simps apply_apply]\ndef compAlongOrderedFinpartition‚Çó :\n    (F [√óc.length]‚ÜíL[ùïú] G) ‚Üí‚Çó[ùïú]\n      MultilinearMap ùïú (fun i : Fin c.length ‚Ü¶ E[√óc.partSize i]‚ÜíL[ùïú] F) (E[√ón]‚ÜíL[ùïú] G) where\n  toFun f :=\n    { toFun := fun p ‚Ü¶ c.compAlongOrderedFinpartition f p\n      map_update_add' := by\n        intro inst p m q q'\n        cases Subsingleton.elim ‚Äπ_‚Ä∫ (instDecidableEqFin _)\n        ext v\n        simp [applyOrderedFinpartition_update_left]\n      map_update_smul' := by\n        intro inst p m a q\n        cases Subsingleton.elim ‚Äπ_‚Ä∫ (instDecidableEqFin _)\n        ext v\n        simp [applyOrderedFinpartition_update_left] }\n  map_add' _ _ := rfl\n  map_smul' _ _ :=  rfl\n\n"}
{"name":"OrderedFinpartition.compAlongOrderedFinpartitionL_apply","module":"Mathlib.Analysis.Calculus.ContDiff.FaaDiBruno","initialProofState":"ùïú : Type u_1\ninst‚úù‚Å∂ : NontriviallyNormedField ùïú\nE : Type u_2\ninst‚úù‚Åµ : NormedAddCommGroup E\ninst‚úù‚Å¥ : NormedSpace ùïú E\nF : Type u_3\ninst‚úù¬≥ : NormedAddCommGroup F\ninst‚úù¬≤ : NormedSpace ùïú F\nG : Type u_4\ninst‚úù¬π : NormedAddCommGroup G\ninst‚úù : NormedSpace ùïú G\nn : Nat\nc : OrderedFinpartition n\nf : ContinuousMultilinearMap ùïú (fun i => F) G\np : (i : Fin c.length) ‚Üí ContinuousMultilinearMap ùïú (fun i => E) F\n‚ä¢ Eq (((OrderedFinpartition.compAlongOrderedFinpartitionL ùïú E F G c) f) p) (c.compAlongOrderedFinpartition f p)","decl":"@[simp] lemma compAlongOrderedFinpartitionL_apply (f : F [√óc.length]‚ÜíL[ùïú] G)\n    (p : ‚àÄ (i : Fin c.length), E[√óc.partSize i]‚ÜíL[ùïú] F) :\n    c.compAlongOrderedFinpartitionL ùïú E F G f p = c.compAlongOrderedFinpartition f p := rfl\n\n"}
{"name":"OrderedFinpartition.norm_compAlongOrderedFinpartitionL_le","module":"Mathlib.Analysis.Calculus.ContDiff.FaaDiBruno","initialProofState":"ùïú : Type u_1\ninst‚úù‚Å∂ : NontriviallyNormedField ùïú\nE : Type u_2\ninst‚úù‚Åµ : NormedAddCommGroup E\ninst‚úù‚Å¥ : NormedSpace ùïú E\nF : Type u_3\ninst‚úù¬≥ : NormedAddCommGroup F\ninst‚úù¬≤ : NormedSpace ùïú F\nG : Type u_4\ninst‚úù¬π : NormedAddCommGroup G\ninst‚úù : NormedSpace ùïú G\nn : Nat\nc : OrderedFinpartition n\n‚ä¢ LE.le (Norm.norm (OrderedFinpartition.compAlongOrderedFinpartitionL ùïú E F G c)) 1","decl":"theorem norm_compAlongOrderedFinpartitionL_le :\n    set_option maxSynthPendingDepth 2 in\n    ‚Äñc.compAlongOrderedFinpartitionL ùïú E F G‚Äñ ‚â§ 1 :=\n  MultilinearMap.mkContinuousLinear_norm_le _ zero_le_one _\n\n"}
{"name":"FormalMultilinearSeries.compAlongOrderedFinpartition_apply","module":"Mathlib.Analysis.Calculus.ContDiff.FaaDiBruno","initialProofState":"ùïú : Type u_1\ninst‚úù‚Å∂ : NontriviallyNormedField ùïú\nE : Type u_2\ninst‚úù‚Åµ : NormedAddCommGroup E\ninst‚úù‚Å¥ : NormedSpace ùïú E\nF : Type u_3\ninst‚úù¬≥ : NormedAddCommGroup F\ninst‚úù¬≤ : NormedSpace ùïú F\nG : Type u_4\ninst‚úù¬π : NormedAddCommGroup G\ninst‚úù : NormedSpace ùïú G\nn : Nat\nq : FormalMultilinearSeries ùïú F G\np : FormalMultilinearSeries ùïú E F\nc : OrderedFinpartition n\nv : Fin n ‚Üí E\n‚ä¢ Eq ((q.compAlongOrderedFinpartition p c) v) ((q c.length) (c.applyOrderedFinpartition (fun m => p (c.partSize m)) v))","decl":"@[simp]\ntheorem compAlongOrderedFinpartition_apply {n : ‚Ñï} (q : FormalMultilinearSeries ùïú F G)\n    (p : FormalMultilinearSeries ùïú E F) (c : OrderedFinpartition n) (v : Fin n ‚Üí E) :\n    (q.compAlongOrderedFinpartition p c) v =\n      q c.length (c.applyOrderedFinpartition (fun m ‚Ü¶ (p (c.partSize m))) v) :=\n  rfl\n\n"}
{"name":"analyticOn_taylorComp","module":"Mathlib.Analysis.Calculus.ContDiff.FaaDiBruno","initialProofState":"ùïú : Type u_1\ninst‚úù‚Å∂ : NontriviallyNormedField ùïú\nE : Type u_2\ninst‚úù‚Åµ : NormedAddCommGroup E\ninst‚úù‚Å¥ : NormedSpace ùïú E\nF : Type u_3\ninst‚úù¬≥ : NormedAddCommGroup F\ninst‚úù¬≤ : NormedSpace ùïú F\nG : Type u_4\ninst‚úù¬π : NormedAddCommGroup G\ninst‚úù : NormedSpace ùïú G\ns : Set E\nt : Set F\nq : F ‚Üí FormalMultilinearSeries ùïú F G\np : E ‚Üí FormalMultilinearSeries ùïú E F\nhq : ‚àÄ (n : Nat), AnalyticOn ùïú (fun x => q x n) t\nhp : ‚àÄ (n : Nat), AnalyticOn ùïú (fun x => p x n) s\nf : E ‚Üí F\nhf : AnalyticOn ùïú f s\nh : Set.MapsTo f s t\nn : Nat\n‚ä¢ AnalyticOn ùïú (fun x => (q (f x)).taylorComp (p x) n) s","decl":"theorem analyticOn_taylorComp\n    (hq : ‚àÄ (n : ‚Ñï), AnalyticOn ùïú (fun x ‚Ü¶ q x n) t)\n    (hp : ‚àÄ n, AnalyticOn ùïú (fun x ‚Ü¶ p x n) s) {f : E ‚Üí F}\n    (hf : AnalyticOn ùïú f s) (h : MapsTo f s t) (n : ‚Ñï) :\n    AnalyticOn ùïú (fun x ‚Ü¶ (q (f x)).taylorComp (p x) n) s := by\n  apply Finset.analyticOn_sum _ (fun c _ ‚Ü¶ ?_)\n  let B := c.compAlongOrderedFinpartitionL ùïú E F G\n  change AnalyticOn ùïú\n    ((fun p ‚Ü¶ B p.1 p.2) ‚àò (fun x ‚Ü¶ (q (f x) c.length, fun m ‚Ü¶ p x (c.partSize m)))) s\n  apply B.analyticOnNhd_uncurry_of_multilinear.comp_analyticOn ?_ (mapsTo_univ _ _)\n  apply AnalyticOn.prod\n  ¬∑ exact (hq c.length).comp hf h\n  ¬∑ exact AnalyticOn.pi (fun i ‚Ü¶ hp _)\n\n"}
{"name":"HasFTaylorSeriesUpToOn.comp","module":"Mathlib.Analysis.Calculus.ContDiff.FaaDiBruno","initialProofState":"ùïú : Type u_1\ninst‚úù‚Å∂ : NontriviallyNormedField ùïú\nE : Type u_2\ninst‚úù‚Åµ : NormedAddCommGroup E\ninst‚úù‚Å¥ : NormedSpace ùïú E\nF : Type u_3\ninst‚úù¬≥ : NormedAddCommGroup F\ninst‚úù¬≤ : NormedSpace ùïú F\nG : Type u_4\ninst‚úù¬π : NormedAddCommGroup G\ninst‚úù : NormedSpace ùïú G\ns : Set E\nt : Set F\nq : F ‚Üí FormalMultilinearSeries ùïú F G\np : E ‚Üí FormalMultilinearSeries ùïú E F\nn : WithTop ENat\ng : F ‚Üí G\nf : E ‚Üí F\nhg : HasFTaylorSeriesUpToOn n g q t\nhf : HasFTaylorSeriesUpToOn n f p s\nh : Set.MapsTo f s t\n‚ä¢ HasFTaylorSeriesUpToOn n (Function.comp g f) (fun x => (q (f x)).taylorComp (p x)) s","decl":"/-- *Faa di Bruno* formula: If two functions `g` and `f` have Taylor series up to `n` given by\n`q` and `p`, then `g ‚àò f` also has a Taylor series, given by `q.taylorComp p`. -/\ntheorem HasFTaylorSeriesUpToOn.comp {n : WithTop ‚Ñï‚àû} {g : F ‚Üí G} {f : E ‚Üí F}\n    (hg : HasFTaylorSeriesUpToOn n g q t) (hf : HasFTaylorSeriesUpToOn n f p s) (h : MapsTo f s t) :\n    HasFTaylorSeriesUpToOn n (g ‚àò f) (fun x ‚Ü¶ (q (f x)).taylorComp (p x)) s := by\n  /- One has to check that the `m+1`-th term is the derivative of the `m`-th term. The `m`-th term\n  is a sum, that one can differentiate term by term. Each term is a linear map into continuous\n  multilinear maps, applied to parts of `p` and `q`. One knows how to differentiate such a map,\n  thanks to `HasFDerivWithinAt.linear_multilinear_comp`. The terms that show up are matched, using\n  `faaDiBruno_aux1` and `faaDiBruno_aux2`, with terms of the same form at order `m+1`. Then, one\n  needs to check that one gets each term once and exactly once, which is given by the bijection\n  `OrderedFinpartition.extendEquiv m`. -/\n  classical\n  constructor\n  ¬∑ intro x hx\n    simp [FormalMultilinearSeries.taylorComp, default, HasFTaylorSeriesUpToOn.zero_eq' hg (h hx)]\n  ¬∑ intro m hm x hx\n    have A (c : OrderedFinpartition m) :\n      HasFDerivWithinAt (fun x ‚Ü¶ (q (f x)).compAlongOrderedFinpartition (p x) c)\n        (‚àë i : Option (Fin c.length),\n          ((q (f x)).compAlongOrderedFinpartition (p x) (c.extend i)).curryLeft) s x := by\n      let B := c.compAlongOrderedFinpartitionL ùïú E F G\n      change HasFDerivWithinAt (fun y ‚Ü¶ B (q (f y) c.length) (fun i ‚Ü¶ p y (c.partSize i)))\n        (‚àë i : Option (Fin c.length),\n          ((q (f x)).compAlongOrderedFinpartition (p x) (c.extend i)).curryLeft) s x\n      have cm : (c.length : WithTop ‚Ñï‚àû) ‚â§ m := mod_cast OrderedFinpartition.length_le c\n      have cp i : (c.partSize i : WithTop ‚Ñï‚àû) ‚â§ m := by\n        exact_mod_cast OrderedFinpartition.partSize_le c i\n      have I i : HasFDerivWithinAt (fun x ‚Ü¶ p x (c.partSize i))\n          (p x (c.partSize i).succ).curryLeft s x :=\n        hf.fderivWithin (c.partSize i) ((cp i).trans_lt hm) x hx\n      have J : HasFDerivWithinAt (fun x ‚Ü¶ q x c.length) (q (f x) c.length.succ).curryLeft\n        t (f x) := hg.fderivWithin c.length (cm.trans_lt hm) (f x) (h hx)\n      have K : HasFDerivWithinAt f ((continuousMultilinearCurryFin1 ùïú E F) (p x 1)) s x :=\n        hf.hasFDerivWithinAt (le_trans (mod_cast Nat.le_add_left 1 m)\n          (ENat.add_one_natCast_le_withTop_of_lt hm)) hx\n      convert HasFDerivWithinAt.linear_multilinear_comp (J.comp x K h) I B\n      simp only [B, Nat.succ_eq_add_one, Fintype.sum_option, comp_apply, faaDiBruno_aux1,\n        faaDiBruno_aux2]\n    have B : HasFDerivWithinAt (fun x ‚Ü¶ (q (f x)).taylorComp (p x) m)\n        (‚àë c : OrderedFinpartition m, ‚àë i : Option (Fin c.length),\n          ((q (f x)).compAlongOrderedFinpartition (p x) (c.extend i)).curryLeft) s x :=\n      HasFDerivWithinAt.sum (fun c _ ‚Ü¶ A c)\n    suffices ‚àë c : OrderedFinpartition m, ‚àë i : Option (Fin c.length),\n          ((q (f x)).compAlongOrderedFinpartition (p x) (c.extend i)) =\n        (q (f x)).taylorComp (p x) (m + 1) by\n      rw [‚Üê this]\n      convert B\n      ext v\n      simp only [Nat.succ_eq_add_one, Fintype.sum_option, ContinuousMultilinearMap.curryLeft_apply,\n        ContinuousMultilinearMap.sum_apply, ContinuousMultilinearMap.add_apply,\n        FormalMultilinearSeries.compAlongOrderedFinpartition_apply, ContinuousLinearMap.coe_sum',\n        Finset.sum_apply, ContinuousLinearMap.add_apply]\n    rw [Finset.sum_sigma']\n    exact Fintype.sum_equiv (OrderedFinpartition.extendEquiv m) _ _ (fun p ‚Ü¶ rfl)\n  ¬∑ intro m hm\n    apply continuousOn_finset_sum _ (fun c _ ‚Ü¶ ?_)\n    let B := c.compAlongOrderedFinpartitionL ùïú E F G\n    change ContinuousOn\n      ((fun p ‚Ü¶ B p.1 p.2) ‚àò (fun x ‚Ü¶ (q (f x) c.length, fun i ‚Ü¶ p x (c.partSize i)))) s\n    apply B.continuous_uncurry_of_multilinear.comp_continuousOn (ContinuousOn.prod ?_ ?_)\n    ¬∑ have : (c.length : WithTop ‚Ñï‚àû) ‚â§ m := mod_cast OrderedFinpartition.length_le c\n      exact (hg.cont c.length (this.trans hm)).comp hf.continuousOn h\n    ¬∑ apply continuousOn_pi.2 (fun i ‚Ü¶ ?_)\n      have : (c.partSize i : WithTop ‚Ñï‚àû) ‚â§ m := by\n        exact_mod_cast OrderedFinpartition.partSize_le c i\n      exact hf.cont _ (this.trans hm)\n"}
