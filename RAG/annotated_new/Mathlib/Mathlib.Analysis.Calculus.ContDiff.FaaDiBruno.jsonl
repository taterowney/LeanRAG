{"name":"OrderedFinpartition.parts_strictMono","module":"Mathlib.Analysis.Calculus.ContDiff.FaaDiBruno","initialProofState":"n : Nat\nself : OrderedFinpartition n\n⊢ StrictMono fun m => self.emb m ⟨HSub.hSub (self.partSize m) 1, ⋯⟩","decl":"/-- A partition of `Fin n` into finitely many nonempty subsets, given by the increasing\nparameterization of these subsets. We order the subsets by increasing greatest element.\nThis definition is tailored-made for the Faa di Bruno formula, and probably not useful elsewhere,\nbecause of the specific parameterization by `Fin n` and the peculiar ordering. -/\n@[ext]\nstructure OrderedFinpartition (n : ℕ) where\n  /-- The number of parts in the partition -/\n  length : ℕ\n  /-- The size of each part -/\n  partSize : Fin length → ℕ\n  partSize_pos : ∀ m, 0 < partSize m\n  /-- The increasing parameterization of each part -/\n  emb : ∀ m, (Fin (partSize m)) → Fin n\n  emb_strictMono : ∀ m, StrictMono (emb m)\n  /-- The parts are ordered by increasing greatest element. -/\n  parts_strictMono :\n    StrictMono fun m ↦ emb m ⟨partSize m - 1, Nat.sub_one_lt_of_lt (partSize_pos m)⟩\n  /-- The parts are disjoint -/\n  disjoint : PairwiseDisjoint univ fun m ↦ range (emb m)\n  /-- The parts cover everything -/\n  cover x : ∃ m, x ∈ range (emb m)\n  deriving DecidableEq\n\n"}
{"name":"OrderedFinpartition.ext","module":"Mathlib.Analysis.Calculus.ContDiff.FaaDiBruno","initialProofState":"n : Nat\nx y : OrderedFinpartition n\nlength : Eq x.length y.length\npartSize : HEq x.partSize y.partSize\nemb : HEq x.emb y.emb\n⊢ Eq x y","decl":"/-- A partition of `Fin n` into finitely many nonempty subsets, given by the increasing\nparameterization of these subsets. We order the subsets by increasing greatest element.\nThis definition is tailored-made for the Faa di Bruno formula, and probably not useful elsewhere,\nbecause of the specific parameterization by `Fin n` and the peculiar ordering. -/\n@[ext]\nstructure OrderedFinpartition (n : ℕ) where\n  /-- The number of parts in the partition -/\n  length : ℕ\n  /-- The size of each part -/\n  partSize : Fin length → ℕ\n  partSize_pos : ∀ m, 0 < partSize m\n  /-- The increasing parameterization of each part -/\n  emb : ∀ m, (Fin (partSize m)) → Fin n\n  emb_strictMono : ∀ m, StrictMono (emb m)\n  /-- The parts are ordered by increasing greatest element. -/\n  parts_strictMono :\n    StrictMono fun m ↦ emb m ⟨partSize m - 1, Nat.sub_one_lt_of_lt (partSize_pos m)⟩\n  /-- The parts are disjoint -/\n  disjoint : PairwiseDisjoint univ fun m ↦ range (emb m)\n  /-- The parts cover everything -/\n  cover x : ∃ m, x ∈ range (emb m)\n  deriving DecidableEq\n\n"}
{"name":"OrderedFinpartition.partSize_pos","module":"Mathlib.Analysis.Calculus.ContDiff.FaaDiBruno","initialProofState":"n : Nat\nself : OrderedFinpartition n\nm : Fin self.length\n⊢ LT.lt 0 (self.partSize m)","decl":"/-- A partition of `Fin n` into finitely many nonempty subsets, given by the increasing\nparameterization of these subsets. We order the subsets by increasing greatest element.\nThis definition is tailored-made for the Faa di Bruno formula, and probably not useful elsewhere,\nbecause of the specific parameterization by `Fin n` and the peculiar ordering. -/\n@[ext]\nstructure OrderedFinpartition (n : ℕ) where\n  /-- The number of parts in the partition -/\n  length : ℕ\n  /-- The size of each part -/\n  partSize : Fin length → ℕ\n  partSize_pos : ∀ m, 0 < partSize m\n  /-- The increasing parameterization of each part -/\n  emb : ∀ m, (Fin (partSize m)) → Fin n\n  emb_strictMono : ∀ m, StrictMono (emb m)\n  /-- The parts are ordered by increasing greatest element. -/\n  parts_strictMono :\n    StrictMono fun m ↦ emb m ⟨partSize m - 1, Nat.sub_one_lt_of_lt (partSize_pos m)⟩\n  /-- The parts are disjoint -/\n  disjoint : PairwiseDisjoint univ fun m ↦ range (emb m)\n  /-- The parts cover everything -/\n  cover x : ∃ m, x ∈ range (emb m)\n  deriving DecidableEq\n\n"}
{"name":"OrderedFinpartition.emb_strictMono","module":"Mathlib.Analysis.Calculus.ContDiff.FaaDiBruno","initialProofState":"n : Nat\nself : OrderedFinpartition n\nm : Fin self.length\n⊢ StrictMono (self.emb m)","decl":"/-- A partition of `Fin n` into finitely many nonempty subsets, given by the increasing\nparameterization of these subsets. We order the subsets by increasing greatest element.\nThis definition is tailored-made for the Faa di Bruno formula, and probably not useful elsewhere,\nbecause of the specific parameterization by `Fin n` and the peculiar ordering. -/\n@[ext]\nstructure OrderedFinpartition (n : ℕ) where\n  /-- The number of parts in the partition -/\n  length : ℕ\n  /-- The size of each part -/\n  partSize : Fin length → ℕ\n  partSize_pos : ∀ m, 0 < partSize m\n  /-- The increasing parameterization of each part -/\n  emb : ∀ m, (Fin (partSize m)) → Fin n\n  emb_strictMono : ∀ m, StrictMono (emb m)\n  /-- The parts are ordered by increasing greatest element. -/\n  parts_strictMono :\n    StrictMono fun m ↦ emb m ⟨partSize m - 1, Nat.sub_one_lt_of_lt (partSize_pos m)⟩\n  /-- The parts are disjoint -/\n  disjoint : PairwiseDisjoint univ fun m ↦ range (emb m)\n  /-- The parts cover everything -/\n  cover x : ∃ m, x ∈ range (emb m)\n  deriving DecidableEq\n\n"}
{"name":"OrderedFinpartition.cover","module":"Mathlib.Analysis.Calculus.ContDiff.FaaDiBruno","initialProofState":"n : Nat\nself : OrderedFinpartition n\nx : Fin n\n⊢ Exists fun m => Membership.mem (Set.range (self.emb m)) x","decl":"/-- A partition of `Fin n` into finitely many nonempty subsets, given by the increasing\nparameterization of these subsets. We order the subsets by increasing greatest element.\nThis definition is tailored-made for the Faa di Bruno formula, and probably not useful elsewhere,\nbecause of the specific parameterization by `Fin n` and the peculiar ordering. -/\n@[ext]\nstructure OrderedFinpartition (n : ℕ) where\n  /-- The number of parts in the partition -/\n  length : ℕ\n  /-- The size of each part -/\n  partSize : Fin length → ℕ\n  partSize_pos : ∀ m, 0 < partSize m\n  /-- The increasing parameterization of each part -/\n  emb : ∀ m, (Fin (partSize m)) → Fin n\n  emb_strictMono : ∀ m, StrictMono (emb m)\n  /-- The parts are ordered by increasing greatest element. -/\n  parts_strictMono :\n    StrictMono fun m ↦ emb m ⟨partSize m - 1, Nat.sub_one_lt_of_lt (partSize_pos m)⟩\n  /-- The parts are disjoint -/\n  disjoint : PairwiseDisjoint univ fun m ↦ range (emb m)\n  /-- The parts cover everything -/\n  cover x : ∃ m, x ∈ range (emb m)\n  deriving DecidableEq\n\n"}
{"name":"OrderedFinpartition.mk.sizeOf_spec","module":"Mathlib.Analysis.Calculus.ContDiff.FaaDiBruno","initialProofState":"n length : Nat\npartSize : Fin length → Nat\npartSize_pos : ∀ (m : Fin length), LT.lt 0 (partSize m)\nemb : (m : Fin length) → Fin (partSize m) → Fin n\nemb_strictMono : ∀ (m : Fin length), StrictMono (emb m)\nparts_strictMono : StrictMono fun m => emb m ⟨HSub.hSub (partSize m) 1, ⋯⟩\ndisjoint : Set.univ.PairwiseDisjoint fun m => Set.range (emb m)\ncover : ∀ (x : Fin n), Exists fun m => Membership.mem (Set.range (emb m)) x\n⊢ Eq (SizeOf.sizeOf { length := length, partSize := partSize, partSize_pos := partSize_pos, emb := emb, emb_strictMono := emb_strictMono, parts_strictMono := parts_strictMono, disjoint := disjoint, cover := cover }) (HAdd.hAdd 1 (SizeOf.sizeOf length))","decl":"/-- A partition of `Fin n` into finitely many nonempty subsets, given by the increasing\nparameterization of these subsets. We order the subsets by increasing greatest element.\nThis definition is tailored-made for the Faa di Bruno formula, and probably not useful elsewhere,\nbecause of the specific parameterization by `Fin n` and the peculiar ordering. -/\n@[ext]\nstructure OrderedFinpartition (n : ℕ) where\n  /-- The number of parts in the partition -/\n  length : ℕ\n  /-- The size of each part -/\n  partSize : Fin length → ℕ\n  partSize_pos : ∀ m, 0 < partSize m\n  /-- The increasing parameterization of each part -/\n  emb : ∀ m, (Fin (partSize m)) → Fin n\n  emb_strictMono : ∀ m, StrictMono (emb m)\n  /-- The parts are ordered by increasing greatest element. -/\n  parts_strictMono :\n    StrictMono fun m ↦ emb m ⟨partSize m - 1, Nat.sub_one_lt_of_lt (partSize_pos m)⟩\n  /-- The parts are disjoint -/\n  disjoint : PairwiseDisjoint univ fun m ↦ range (emb m)\n  /-- The parts cover everything -/\n  cover x : ∃ m, x ∈ range (emb m)\n  deriving DecidableEq\n\n"}
{"name":"OrderedFinpartition.ext_iff","module":"Mathlib.Analysis.Calculus.ContDiff.FaaDiBruno","initialProofState":"n : Nat\nx y : OrderedFinpartition n\n⊢ Iff (Eq x y) (And (Eq x.length y.length) (And (HEq x.partSize y.partSize) (HEq x.emb y.emb)))","decl":"/-- A partition of `Fin n` into finitely many nonempty subsets, given by the increasing\nparameterization of these subsets. We order the subsets by increasing greatest element.\nThis definition is tailored-made for the Faa di Bruno formula, and probably not useful elsewhere,\nbecause of the specific parameterization by `Fin n` and the peculiar ordering. -/\n@[ext]\nstructure OrderedFinpartition (n : ℕ) where\n  /-- The number of parts in the partition -/\n  length : ℕ\n  /-- The size of each part -/\n  partSize : Fin length → ℕ\n  partSize_pos : ∀ m, 0 < partSize m\n  /-- The increasing parameterization of each part -/\n  emb : ∀ m, (Fin (partSize m)) → Fin n\n  emb_strictMono : ∀ m, StrictMono (emb m)\n  /-- The parts are ordered by increasing greatest element. -/\n  parts_strictMono :\n    StrictMono fun m ↦ emb m ⟨partSize m - 1, Nat.sub_one_lt_of_lt (partSize_pos m)⟩\n  /-- The parts are disjoint -/\n  disjoint : PairwiseDisjoint univ fun m ↦ range (emb m)\n  /-- The parts cover everything -/\n  cover x : ∃ m, x ∈ range (emb m)\n  deriving DecidableEq\n\n"}
{"name":"OrderedFinpartition.mk.inj","module":"Mathlib.Analysis.Calculus.ContDiff.FaaDiBruno","initialProofState":"n length✝ : Nat\npartSize✝ : Fin length✝ → Nat\npartSize_pos✝ : ∀ (m : Fin length✝), LT.lt 0 (partSize✝ m)\nemb✝ : (m : Fin length✝) → Fin (partSize✝ m) → Fin n\nemb_strictMono✝ : ∀ (m : Fin length✝), StrictMono (emb✝ m)\nparts_strictMono✝ : StrictMono fun m => emb✝ m ⟨HSub.hSub (partSize✝ m) 1, ⋯⟩\ndisjoint✝ : Set.univ.PairwiseDisjoint fun m => Set.range (emb✝ m)\ncover✝ : ∀ (x : Fin n), Exists fun m => Membership.mem (Set.range (emb✝ m)) x\nlength : Nat\npartSize : Fin length → Nat\npartSize_pos : ∀ (m : Fin length), LT.lt 0 (partSize m)\nemb : (m : Fin length) → Fin (partSize m) → Fin n\nemb_strictMono : ∀ (m : Fin length), StrictMono (emb m)\nparts_strictMono : StrictMono fun m => emb m ⟨HSub.hSub (partSize m) 1, ⋯⟩\ndisjoint : Set.univ.PairwiseDisjoint fun m => Set.range (emb m)\ncover : ∀ (x : Fin n), Exists fun m => Membership.mem (Set.range (emb m)) x\nx✝ : Eq { length := length✝, partSize := partSize✝, partSize_pos := partSize_pos✝, emb := emb✝, emb_strictMono := emb_strictMono✝, parts_strictMono := parts_strictMono✝, disjoint := disjoint✝, cover := cover✝ } { length := length, partSize := partSize, partSize_pos := partSize_pos, emb := emb, emb_strictMono := emb_strictMono, parts_strictMono := parts_strictMono, disjoint := disjoint, cover := cover }\n⊢ And (Eq length✝ length) (And (HEq partSize✝ partSize) (HEq emb✝ emb))","decl":"/-- A partition of `Fin n` into finitely many nonempty subsets, given by the increasing\nparameterization of these subsets. We order the subsets by increasing greatest element.\nThis definition is tailored-made for the Faa di Bruno formula, and probably not useful elsewhere,\nbecause of the specific parameterization by `Fin n` and the peculiar ordering. -/\n@[ext]\nstructure OrderedFinpartition (n : ℕ) where\n  /-- The number of parts in the partition -/\n  length : ℕ\n  /-- The size of each part -/\n  partSize : Fin length → ℕ\n  partSize_pos : ∀ m, 0 < partSize m\n  /-- The increasing parameterization of each part -/\n  emb : ∀ m, (Fin (partSize m)) → Fin n\n  emb_strictMono : ∀ m, StrictMono (emb m)\n  /-- The parts are ordered by increasing greatest element. -/\n  parts_strictMono :\n    StrictMono fun m ↦ emb m ⟨partSize m - 1, Nat.sub_one_lt_of_lt (partSize_pos m)⟩\n  /-- The parts are disjoint -/\n  disjoint : PairwiseDisjoint univ fun m ↦ range (emb m)\n  /-- The parts cover everything -/\n  cover x : ∃ m, x ∈ range (emb m)\n  deriving DecidableEq\n\n"}
{"name":"OrderedFinpartition.disjoint","module":"Mathlib.Analysis.Calculus.ContDiff.FaaDiBruno","initialProofState":"n : Nat\nself : OrderedFinpartition n\n⊢ Set.univ.PairwiseDisjoint fun m => Set.range (self.emb m)","decl":"/-- A partition of `Fin n` into finitely many nonempty subsets, given by the increasing\nparameterization of these subsets. We order the subsets by increasing greatest element.\nThis definition is tailored-made for the Faa di Bruno formula, and probably not useful elsewhere,\nbecause of the specific parameterization by `Fin n` and the peculiar ordering. -/\n@[ext]\nstructure OrderedFinpartition (n : ℕ) where\n  /-- The number of parts in the partition -/\n  length : ℕ\n  /-- The size of each part -/\n  partSize : Fin length → ℕ\n  partSize_pos : ∀ m, 0 < partSize m\n  /-- The increasing parameterization of each part -/\n  emb : ∀ m, (Fin (partSize m)) → Fin n\n  emb_strictMono : ∀ m, StrictMono (emb m)\n  /-- The parts are ordered by increasing greatest element. -/\n  parts_strictMono :\n    StrictMono fun m ↦ emb m ⟨partSize m - 1, Nat.sub_one_lt_of_lt (partSize_pos m)⟩\n  /-- The parts are disjoint -/\n  disjoint : PairwiseDisjoint univ fun m ↦ range (emb m)\n  /-- The parts cover everything -/\n  cover x : ∃ m, x ∈ range (emb m)\n  deriving DecidableEq\n\n"}
{"name":"OrderedFinpartition.mk.injEq","module":"Mathlib.Analysis.Calculus.ContDiff.FaaDiBruno","initialProofState":"n length✝ : Nat\npartSize✝ : Fin length✝ → Nat\npartSize_pos✝ : ∀ (m : Fin length✝), LT.lt 0 (partSize✝ m)\nemb✝ : (m : Fin length✝) → Fin (partSize✝ m) → Fin n\nemb_strictMono✝ : ∀ (m : Fin length✝), StrictMono (emb✝ m)\nparts_strictMono✝ : StrictMono fun m => emb✝ m ⟨HSub.hSub (partSize✝ m) 1, ⋯⟩\ndisjoint✝ : Set.univ.PairwiseDisjoint fun m => Set.range (emb✝ m)\ncover✝ : ∀ (x : Fin n), Exists fun m => Membership.mem (Set.range (emb✝ m)) x\nlength : Nat\npartSize : Fin length → Nat\npartSize_pos : ∀ (m : Fin length), LT.lt 0 (partSize m)\nemb : (m : Fin length) → Fin (partSize m) → Fin n\nemb_strictMono : ∀ (m : Fin length), StrictMono (emb m)\nparts_strictMono : StrictMono fun m => emb m ⟨HSub.hSub (partSize m) 1, ⋯⟩\ndisjoint : Set.univ.PairwiseDisjoint fun m => Set.range (emb m)\ncover : ∀ (x : Fin n), Exists fun m => Membership.mem (Set.range (emb m)) x\n⊢ Eq (Eq { length := length✝, partSize := partSize✝, partSize_pos := partSize_pos✝, emb := emb✝, emb_strictMono := emb_strictMono✝, parts_strictMono := parts_strictMono✝, disjoint := disjoint✝, cover := cover✝ } { length := length, partSize := partSize, partSize_pos := partSize_pos, emb := emb, emb_strictMono := emb_strictMono, parts_strictMono := parts_strictMono, disjoint := disjoint, cover := cover }) (And (Eq length✝ length) (And (HEq partSize✝ partSize) (HEq emb✝ emb)))","decl":"/-- A partition of `Fin n` into finitely many nonempty subsets, given by the increasing\nparameterization of these subsets. We order the subsets by increasing greatest element.\nThis definition is tailored-made for the Faa di Bruno formula, and probably not useful elsewhere,\nbecause of the specific parameterization by `Fin n` and the peculiar ordering. -/\n@[ext]\nstructure OrderedFinpartition (n : ℕ) where\n  /-- The number of parts in the partition -/\n  length : ℕ\n  /-- The size of each part -/\n  partSize : Fin length → ℕ\n  partSize_pos : ∀ m, 0 < partSize m\n  /-- The increasing parameterization of each part -/\n  emb : ∀ m, (Fin (partSize m)) → Fin n\n  emb_strictMono : ∀ m, StrictMono (emb m)\n  /-- The parts are ordered by increasing greatest element. -/\n  parts_strictMono :\n    StrictMono fun m ↦ emb m ⟨partSize m - 1, Nat.sub_one_lt_of_lt (partSize_pos m)⟩\n  /-- The parts are disjoint -/\n  disjoint : PairwiseDisjoint univ fun m ↦ range (emb m)\n  /-- The parts cover everything -/\n  cover x : ∃ m, x ∈ range (emb m)\n  deriving DecidableEq\n\n"}
{"name":"OrderedFinpartition.atomic_length","module":"Mathlib.Analysis.Calculus.ContDiff.FaaDiBruno","initialProofState":"n : Nat\n⊢ Eq (OrderedFinpartition.atomic n).length n","decl":"/-- The ordered finpartition of `Fin n` into singletons. -/\n@[simps] def atomic (n : ℕ) : OrderedFinpartition n where\n  length := n\n  partSize _ :=  1\n  partSize_pos _ := _root_.zero_lt_one\n  emb m _ := m\n  emb_strictMono _ := Subsingleton.strictMono _\n  parts_strictMono := strictMono_id\n  disjoint _ _ _ _ h := by simpa using h\n  cover m := by simp\n\n"}
{"name":"OrderedFinpartition.atomic_partSize","module":"Mathlib.Analysis.Calculus.ContDiff.FaaDiBruno","initialProofState":"n : Nat\nx✝ : Fin n\n⊢ Eq ((OrderedFinpartition.atomic n).partSize x✝) 1","decl":"/-- The ordered finpartition of `Fin n` into singletons. -/\n@[simps] def atomic (n : ℕ) : OrderedFinpartition n where\n  length := n\n  partSize _ :=  1\n  partSize_pos _ := _root_.zero_lt_one\n  emb m _ := m\n  emb_strictMono _ := Subsingleton.strictMono _\n  parts_strictMono := strictMono_id\n  disjoint _ _ _ _ h := by simpa using h\n  cover m := by simp\n\n"}
{"name":"OrderedFinpartition.atomic_emb","module":"Mathlib.Analysis.Calculus.ContDiff.FaaDiBruno","initialProofState":"n : Nat\nm : Fin n\nx✝ : Fin ((fun x => 1) m)\n⊢ Eq ((OrderedFinpartition.atomic n).emb m x✝) m","decl":"/-- The ordered finpartition of `Fin n` into singletons. -/\n@[simps] def atomic (n : ℕ) : OrderedFinpartition n where\n  length := n\n  partSize _ :=  1\n  partSize_pos _ := _root_.zero_lt_one\n  emb m _ := m\n  emb_strictMono _ := Subsingleton.strictMono _\n  parts_strictMono := strictMono_id\n  disjoint _ _ _ _ h := by simpa using h\n  cover m := by simp\n\n"}
{"name":"OrderedFinpartition.length_le","module":"Mathlib.Analysis.Calculus.ContDiff.FaaDiBruno","initialProofState":"n : Nat\nc : OrderedFinpartition n\n⊢ LE.le c.length n","decl":"lemma length_le : c.length ≤ n := by\n  simpa only [Fintype.card_fin] using Fintype.card_le_of_injective _ c.parts_strictMono.injective\n\n"}
{"name":"OrderedFinpartition.partSize_le","module":"Mathlib.Analysis.Calculus.ContDiff.FaaDiBruno","initialProofState":"n : Nat\nc : OrderedFinpartition n\nm : Fin c.length\n⊢ LE.le (c.partSize m) n","decl":"lemma partSize_le (m : Fin c.length) : c.partSize m ≤ n := by\n  simpa only [Fintype.card_fin] using Fintype.card_le_of_injective _ (c.emb_strictMono m).injective\n\n"}
{"name":"OrderedFinpartition.injective_embSigma","module":"Mathlib.Analysis.Calculus.ContDiff.FaaDiBruno","initialProofState":"n : Nat\n⊢ Function.Injective (OrderedFinpartition.embSigma n)","decl":"lemma injective_embSigma (n : ℕ) : Injective (embSigma n) := by\n  rintro ⟨plength, psize, -, pemb, -, -, -, -⟩ ⟨qlength, qsize, -, qemb, -, -, -, -⟩\n  intro hpq\n  simp_all only [Sigma.mk.inj_iff, heq_eq_eq, true_and, mk.injEq, and_true, Fin.mk.injEq, embSigma]\n  have : plength = qlength := hpq.1\n  subst this\n  simp_all only [Sigma.mk.inj_iff, heq_eq_eq, true_and, mk.injEq, and_true, Fin.mk.injEq, embSigma]\n  ext i\n  exact mk.inj_iff.mp (congr_fun hpq.1 i)\n\n/- The best proof would probably to establish the bijection with Finpartitions, but we opt\nfor a direct argument, embedding `OrderedPartition n` in a type which is obviously finite. -/\n"}
{"name":"OrderedFinpartition.exists_inverse","module":"Mathlib.Analysis.Calculus.ContDiff.FaaDiBruno","initialProofState":"n : Nat\nc : OrderedFinpartition n\nj : Fin n\n⊢ Exists fun p => Eq (c.emb p.fst p.snd) j","decl":"lemma exists_inverse {n : ℕ} (c : OrderedFinpartition n) (j : Fin n) :\n    ∃ p : Σ m, Fin (c.partSize m), c.emb p.1 p.2 = j := by\n  rcases c.cover j with ⟨m, r, hmr⟩\n  exact ⟨⟨m, r⟩, hmr⟩\n\n"}
{"name":"OrderedFinpartition.emb_injective","module":"Mathlib.Analysis.Calculus.ContDiff.FaaDiBruno","initialProofState":"n : Nat\nc : OrderedFinpartition n\n⊢ Function.Injective fun p => c.emb p.fst p.snd","decl":"lemma emb_injective : Injective (fun (p : Σ m, Fin (c.partSize m)) ↦ c.emb p.1 p.2) := by\n  rintro ⟨m, r⟩ ⟨m', r'⟩ (h : c.emb m r = c.emb m' r')\n  have : m = m' := by\n    contrapose! h\n    have A : Disjoint (range (c.emb m)) (range (c.emb m')) :=\n      c.disjoint (mem_univ m) (mem_univ m') h\n    apply disjoint_iff_forall_ne.1 A (mem_range_self r) (mem_range_self r')\n  subst this\n  simpa using (c.emb_strictMono m).injective h\n\n"}
{"name":"OrderedFinpartition.emb_ne_emb_of_ne","module":"Mathlib.Analysis.Calculus.ContDiff.FaaDiBruno","initialProofState":"n : Nat\nc : OrderedFinpartition n\ni j : Fin c.length\na : Fin (c.partSize i)\nb : Fin (c.partSize j)\nh : Ne i j\n⊢ Ne (c.emb i a) (c.emb j b)","decl":"lemma emb_ne_emb_of_ne {i j : Fin c.length} {a : Fin (c.partSize i)} {b : Fin (c.partSize j)}\n    (h : i ≠ j) : c.emb i a ≠ c.emb j b :=\n  c.emb_injective.ne (a₁ := ⟨i, a⟩) (a₂ := ⟨j, b⟩) (by simp [h])\n\n"}
{"name":"OrderedFinpartition.emb_invEmbedding","module":"Mathlib.Analysis.Calculus.ContDiff.FaaDiBruno","initialProofState":"n : Nat\nc : OrderedFinpartition n\nj : Fin n\n⊢ Eq (c.emb (c.index j) (c.invEmbedding j)) j","decl":"@[simp] lemma emb_invEmbedding (j : Fin n) :\n    c.emb (c.index j) (c.invEmbedding j) = j :=\n  (c.exists_inverse j).choose_spec\n\n"}
{"name":"OrderedFinpartition.prod_sigma_eq_prod","module":"Mathlib.Analysis.Calculus.ContDiff.FaaDiBruno","initialProofState":"n : Nat\nc : OrderedFinpartition n\nα : Type u_5\ninst✝ : CommMonoid α\nv : Fin n → α\n⊢ Eq (Finset.univ.prod fun m => Finset.univ.prod fun r => v (c.emb m r)) (Finset.univ.prod fun i => v i)","decl":"@[to_additive] lemma prod_sigma_eq_prod {α : Type*} [CommMonoid α] (v : Fin n → α) :\n    ∏ (m : Fin c.length), ∏ (r : Fin (c.partSize m)), v (c.emb m r) = ∏ i, v i := by\n  rw [Finset.prod_sigma']\n  exact Fintype.prod_equiv c.equivSigma _ _ (fun p ↦ rfl)\n\n"}
{"name":"OrderedFinpartition.sum_sigma_eq_sum","module":"Mathlib.Analysis.Calculus.ContDiff.FaaDiBruno","initialProofState":"n : Nat\nc : OrderedFinpartition n\nα : Type u_5\ninst✝ : AddCommMonoid α\nv : Fin n → α\n⊢ Eq (Finset.univ.sum fun m => Finset.univ.sum fun r => v (c.emb m r)) (Finset.univ.sum fun i => v i)","decl":"@[to_additive] lemma prod_sigma_eq_prod {α : Type*} [CommMonoid α] (v : Fin n → α) :\n    ∏ (m : Fin c.length), ∏ (r : Fin (c.partSize m)), v (c.emb m r) = ∏ i, v i := by\n  rw [Finset.prod_sigma']\n  exact Fintype.prod_equiv c.equivSigma _ _ (fun p ↦ rfl)\n\n"}
{"name":"OrderedFinpartition.length_pos","module":"Mathlib.Analysis.Calculus.ContDiff.FaaDiBruno","initialProofState":"n : Nat\nc : OrderedFinpartition n\nh : LT.lt 0 n\n⊢ LT.lt 0 c.length","decl":"lemma length_pos (h : 0 < n) : 0 < c.length := Nat.zero_lt_of_lt (c.index ⟨0, h⟩).2\n\n"}
{"name":"OrderedFinpartition.neZero_length","module":"Mathlib.Analysis.Calculus.ContDiff.FaaDiBruno","initialProofState":"n : Nat\ninst✝ : NeZero n\nc : OrderedFinpartition n\n⊢ NeZero c.length","decl":"lemma neZero_length [NeZero n] (c : OrderedFinpartition n) : NeZero c.length :=\n  ⟨(c.length_pos pos').ne'⟩\n\n"}
{"name":"OrderedFinpartition.neZero_partSize","module":"Mathlib.Analysis.Calculus.ContDiff.FaaDiBruno","initialProofState":"n : Nat\nc : OrderedFinpartition n\ni : Fin c.length\n⊢ NeZero (c.partSize i)","decl":"lemma neZero_partSize (c : OrderedFinpartition n) (i : Fin c.length) : NeZero (c.partSize i) :=\n  .of_pos (c.partSize_pos i)\n\n"}
{"name":"OrderedFinpartition.emb_zero","module":"Mathlib.Analysis.Calculus.ContDiff.FaaDiBruno","initialProofState":"n : Nat\nc : OrderedFinpartition n\ninst✝ : NeZero n\n⊢ Eq (c.emb (c.index 0) 0) 0","decl":"lemma emb_zero [NeZero n] : c.emb (c.index 0) 0 = 0 := by\n  apply le_antisymm _ (Fin.zero_le' _)\n  conv_rhs => rw [← c.emb_invEmbedding 0]\n  apply (c.emb_strictMono _).monotone (Fin.zero_le' _)\n\n"}
{"name":"OrderedFinpartition.partSize_eq_one_of_range_emb_eq_singleton","module":"Mathlib.Analysis.Calculus.ContDiff.FaaDiBruno","initialProofState":"n : Nat\nc : OrderedFinpartition n\ni : Fin c.length\nj : Fin n\nhc : Eq (Set.range (c.emb i)) (Singleton.singleton j)\n⊢ Eq (c.partSize i) 1","decl":"lemma partSize_eq_one_of_range_emb_eq_singleton\n    (c : OrderedFinpartition n) {i : Fin c.length} {j : Fin n}\n    (hc : range (c.emb i) = {j}) :\n    c.partSize i = 1 := by\n  have : Fintype.card (range (c.emb i)) = Fintype.card (Fin (c.partSize i)) :=\n    card_range_of_injective (c.emb_strictMono i).injective\n  simpa [hc] using this.symm\n\n"}
{"name":"OrderedFinpartition.one_lt_partSize_index_zero","module":"Mathlib.Analysis.Calculus.ContDiff.FaaDiBruno","initialProofState":"n : Nat\nc : OrderedFinpartition (HAdd.hAdd n 1)\nhc : Ne (Set.range (c.emb 0)) (Singleton.singleton 0)\n⊢ LT.lt 1 (c.partSize (c.index 0))","decl":"/-- If the left-most part is not `{0}`, then the part containing `0` has at least two elements:\neither because it's the left-most part, and then it's not just `0` by assumption, or because it's\nnot the left-most part and then, by increasingness of maximal elements in parts, it contains\na positive element. -/\nlemma one_lt_partSize_index_zero (c : OrderedFinpartition (n + 1)) (hc : range (c.emb 0) ≠ {0}) :\n    1 < c.partSize (c.index 0) := by\n  have : c.partSize (c.index 0) = Nat.card (range (c.emb (c.index 0))) := by\n    rw [Nat.card_range_of_injective (c.emb_strictMono _).injective]; simp\n  rw [this]\n  rcases eq_or_ne (c.index 0) 0 with h | h\n  · rw [← h] at hc\n    have : {0} ⊂ range (c.emb (c.index 0)) := by\n      apply ssubset_of_subset_of_ne ?_ hc.symm\n      simpa only [singleton_subset_iff, mem_range] using ⟨0, emb_zero c⟩\n    simpa using Set.Finite.card_lt_card (finite_range _) this\n  · apply one_lt_two.trans_le\n    have : {c.emb (c.index 0) 0,\n        c.emb (c.index 0) ⟨c.partSize (c.index 0) - 1, Nat.sub_one_lt_of_lt (c.partSize_pos _)⟩}\n          ⊆ range (c.emb (c.index 0)) := by simp [insert_subset]\n    simp [emb_zero] at this\n    convert Nat.card_mono Subtype.finite this\n    simp only [Nat.card_eq_fintype_card, Fintype.card_ofFinset, toFinset_singleton]\n    apply (Finset.card_pair ?_).symm\n    exact ((Fin.zero_le _).trans_lt (c.parts_strictMono ((pos_iff_ne_zero' (c.index 0)).mpr h))).ne\n\n"}
{"name":"OrderedFinpartition.range_extendLeft_zero","module":"Mathlib.Analysis.Calculus.ContDiff.FaaDiBruno","initialProofState":"n : Nat\nc : OrderedFinpartition n\n⊢ Eq (Set.range (c.extendLeft.emb 0)) (Singleton.singleton 0)","decl":"@[simp] lemma range_extendLeft_zero (c : OrderedFinpartition n) :\n    range (c.extendLeft.emb 0) = {0} := by\n  simp [extendLeft]\n  apply @range_const _ _ (by simp; infer_instance)\n\n"}
{"name":"OrderedFinpartition.index_extendMiddle_zero","module":"Mathlib.Analysis.Calculus.ContDiff.FaaDiBruno","initialProofState":"n : Nat\nc : OrderedFinpartition n\ni : Fin c.length\n⊢ Eq ((c.extendMiddle i).index 0) i","decl":"lemma index_extendMiddle_zero (c : OrderedFinpartition n) (i : Fin c.length) :\n    (c.extendMiddle i).index 0 = i := by\n  have : (c.extendMiddle i).emb i 0 = 0 := by simp [extendMiddle]\n  conv_rhs at this => rw [← (c.extendMiddle i).emb_invEmbedding 0]\n  contrapose! this\n  exact (c.extendMiddle i).emb_ne_emb_of_ne (Ne.symm this)\n\n"}
{"name":"OrderedFinpartition.range_emb_extendMiddle_ne_singleton_zero","module":"Mathlib.Analysis.Calculus.ContDiff.FaaDiBruno","initialProofState":"n : Nat\nc : OrderedFinpartition n\ni j : Fin c.length\n⊢ Ne (Set.range ((c.extendMiddle i).emb j)) (Singleton.singleton 0)","decl":"lemma range_emb_extendMiddle_ne_singleton_zero (c : OrderedFinpartition n) (i j : Fin c.length) :\n    range ((c.extendMiddle i).emb j) ≠ {0} := by\n  intro h\n  rcases eq_or_ne j i with rfl | hij\n  · have : Fin.succ (c.emb j 0) ∈ ({0} : Set (Fin n.succ)) := by\n      rw [← h]\n      simp only [Nat.succ_eq_add_one, mem_range]\n      have A : (c.extendMiddle j).partSize j = c.partSize j + 1 := by simp [extendMiddle]\n      refine ⟨Fin.cast A.symm (succ 0), ?_⟩\n      simp only [extendMiddle, ↓reduceDIte, comp_apply, cast_trans, cast_eq_self, cases_succ]\n    simp only [mem_singleton_iff] at this\n    exact Fin.succ_ne_zero _ this\n  · have : (c.extendMiddle i).emb j 0 ∈ range ((c.extendMiddle i).emb j) :=\n      mem_range_self 0\n    rw [h] at this\n    simp only [extendMiddle, hij, ↓reduceDIte, comp_apply, cast_zero, mem_singleton_iff] at this\n    exact Fin.succ_ne_zero _ this\n\n"}
{"name":"OrderedFinpartition.applyOrderedFinpartition_apply","module":"Mathlib.Analysis.Calculus.ContDiff.FaaDiBruno","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nn : Nat\nc : OrderedFinpartition n\np : (i : Fin c.length) → ContinuousMultilinearMap 𝕜 (fun i => E) F\nv : Fin n → E\n⊢ Eq (c.applyOrderedFinpartition p v) fun m => (p m) (Function.comp v (c.emb m))","decl":"lemma applyOrderedFinpartition_apply (p : ∀ (i : Fin c.length), E[×c.partSize i]→L[𝕜] F)\n    (v : Fin n → E) :\n  c.applyOrderedFinpartition p v = (fun m ↦ p m (v ∘ c.emb m)) := rfl\n\n"}
{"name":"OrderedFinpartition.norm_applyOrderedFinpartition_le","module":"Mathlib.Analysis.Calculus.ContDiff.FaaDiBruno","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nn : Nat\nc : OrderedFinpartition n\np : (i : Fin c.length) → ContinuousMultilinearMap 𝕜 (fun i => E) F\nv : Fin n → E\nm : Fin c.length\n⊢ LE.le (Norm.norm (c.applyOrderedFinpartition p v m)) (HMul.hMul (Norm.norm (p m)) (Finset.univ.prod fun i => Norm.norm (v (c.emb m i))))","decl":"theorem norm_applyOrderedFinpartition_le (p : ∀ (i : Fin c.length), E[×c.partSize i]→L[𝕜] F)\n    (v : Fin n → E) (m : Fin c.length) :\n    ‖c.applyOrderedFinpartition p v m‖ ≤ ‖p m‖ * ∏ i : Fin (c.partSize m), ‖v (c.emb m i)‖ :=\n  (p m).le_opNorm _\n\n"}
{"name":"OrderedFinpartition.applyOrderedFinpartition_update_right","module":"Mathlib.Analysis.Calculus.ContDiff.FaaDiBruno","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nn : Nat\nc : OrderedFinpartition n\np : (i : Fin c.length) → ContinuousMultilinearMap 𝕜 (fun i => E) F\nj : Fin n\nv : Fin n → E\nz : E\n⊢ Eq (c.applyOrderedFinpartition p (Function.update v j z)) (Function.update (c.applyOrderedFinpartition p v) (c.index j) ((p (c.index j)) (Function.update (Function.comp v (c.emb (c.index j))) (c.invEmbedding j) z)))","decl":"/-- Technical lemma stating how `c.applyOrderedFinpartition` commutes with updating variables. This\nwill be the key point to show that functions constructed from `applyOrderedFinpartition` retain\nmultilinearity. -/\ntheorem applyOrderedFinpartition_update_right\n    (p : ∀ (i : Fin c.length), E[×c.partSize i]→L[𝕜] F)\n    (j : Fin n) (v : Fin n → E) (z : E) :\n    c.applyOrderedFinpartition p (update v j z) =\n      update (c.applyOrderedFinpartition p v) (c.index j)\n        (p (c.index j)\n          (Function.update (v ∘ c.emb (c.index j)) (c.invEmbedding j) z)) := by\n  ext m\n  by_cases h : m = c.index j\n  · rw [h]\n    simp only [applyOrderedFinpartition, update_self]\n    congr\n    rw [← Function.update_comp_eq_of_injective]\n    · simp\n    · exact (c.emb_strictMono (c.index j)).injective\n  · simp only [applyOrderedFinpartition, ne_eq, h, not_false_eq_true,\n      update_of_ne]\n    congr\n    apply Function.update_comp_eq_of_not_mem_range\n    have A : Disjoint (range (c.emb m)) (range (c.emb (c.index j))) :=\n      c.disjoint (mem_univ m) (mem_univ (c.index j)) h\n    have : j ∈ range (c.emb (c.index j)) := mem_range.2 ⟨c.invEmbedding j, by simp⟩\n    exact Set.disjoint_right.1 A this\n\n"}
{"name":"OrderedFinpartition.applyOrderedFinpartition_update_left","module":"Mathlib.Analysis.Calculus.ContDiff.FaaDiBruno","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nn : Nat\nc : OrderedFinpartition n\np : (i : Fin c.length) → ContinuousMultilinearMap 𝕜 (fun i => E) F\nm : Fin c.length\nv : Fin n → E\nq : ContinuousMultilinearMap 𝕜 (fun i => E) F\n⊢ Eq (c.applyOrderedFinpartition (Function.update p m q) v) (Function.update (c.applyOrderedFinpartition p v) m (q (Function.comp v (c.emb m))))","decl":"theorem applyOrderedFinpartition_update_left (p : ∀ (i : Fin c.length), E[×c.partSize i]→L[𝕜] F)\n    (m : Fin c.length) (v : Fin n → E) (q : E[×c.partSize m]→L[𝕜] F) :\n    c.applyOrderedFinpartition (update p m q) v\n      = update (c.applyOrderedFinpartition p v) m (q (v ∘ c.emb m)) := by\n  ext d\n  by_cases h : d = m\n  · rw [h]\n    simp [applyOrderedFinpartition]\n  · simp [h, applyOrderedFinpartition]\n\n"}
{"name":"OrderedFinpartition.compAlongOrderFinpartition_apply","module":"Mathlib.Analysis.Calculus.ContDiff.FaaDiBruno","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type u_4\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nn : Nat\nc : OrderedFinpartition n\nf : ContinuousMultilinearMap 𝕜 (fun i => F) G\np : (i : Fin c.length) → ContinuousMultilinearMap 𝕜 (fun i => E) F\nv : Fin n → E\n⊢ Eq ((c.compAlongOrderedFinpartition f p) v) (f (c.applyOrderedFinpartition p v))","decl":"@[simp] lemma compAlongOrderFinpartition_apply (f : F [×c.length]→L[𝕜] G)\n    (p : ∀ i, E[×c.partSize i]→L[𝕜] F) (v : Fin n → E) :\n    c.compAlongOrderedFinpartition f p v = f (c.applyOrderedFinpartition p v) := rfl\n\n"}
{"name":"OrderedFinpartition.norm_compAlongOrderedFinpartition_le","module":"Mathlib.Analysis.Calculus.ContDiff.FaaDiBruno","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type u_4\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nn : Nat\nc : OrderedFinpartition n\nf : ContinuousMultilinearMap 𝕜 (fun i => F) G\np : (i : Fin c.length) → ContinuousMultilinearMap 𝕜 (fun i => E) F\n⊢ LE.le (Norm.norm (c.compAlongOrderedFinpartition f p)) (HMul.hMul (Norm.norm f) (Finset.univ.prod fun i => Norm.norm (p i)))","decl":"theorem norm_compAlongOrderedFinpartition_le (f : F [×c.length]→L[𝕜] G)\n    (p : ∀ i, E [×c.partSize i]→L[𝕜] F) :\n    ‖c.compAlongOrderedFinpartition f p‖ ≤ ‖f‖ * ∏ i, ‖p i‖ := by\n  refine ContinuousMultilinearMap.opNorm_le_bound (by positivity) fun v ↦ ?_\n  rw [compAlongOrderFinpartition_apply, mul_assoc, ← c.prod_sigma_eq_prod,\n    ← Finset.prod_mul_distrib]\n  exact f.le_opNorm_mul_prod_of_le <| c.norm_applyOrderedFinpartition_le _ _\n\n"}
{"name":"OrderedFinpartition.compAlongOrderedFinpartitionₗ_apply_apply","module":"Mathlib.Analysis.Calculus.ContDiff.FaaDiBruno","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type u_4\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nn : Nat\nc : OrderedFinpartition n\nf : ContinuousMultilinearMap 𝕜 (fun i => F) G\np : (i : Fin c.length) → ContinuousMultilinearMap 𝕜 (fun i => E) F\n⊢ Eq ((c.compAlongOrderedFinpartitionₗ f) p) (c.compAlongOrderedFinpartition f p)","decl":"/-- Bundled version of `compAlongOrderedFinpartition`, depending linearly on `f`\nand multilinearly on `p`.-/\n@[simps apply_apply]\ndef compAlongOrderedFinpartitionₗ :\n    (F [×c.length]→L[𝕜] G) →ₗ[𝕜]\n      MultilinearMap 𝕜 (fun i : Fin c.length ↦ E[×c.partSize i]→L[𝕜] F) (E[×n]→L[𝕜] G) where\n  toFun f :=\n    { toFun := fun p ↦ c.compAlongOrderedFinpartition f p\n      map_update_add' := by\n        intro inst p m q q'\n        cases Subsingleton.elim ‹_› (instDecidableEqFin _)\n        ext v\n        simp [applyOrderedFinpartition_update_left]\n      map_update_smul' := by\n        intro inst p m a q\n        cases Subsingleton.elim ‹_› (instDecidableEqFin _)\n        ext v\n        simp [applyOrderedFinpartition_update_left] }\n  map_add' _ _ := rfl\n  map_smul' _ _ :=  rfl\n\n"}
{"name":"OrderedFinpartition.compAlongOrderedFinpartitionL_apply","module":"Mathlib.Analysis.Calculus.ContDiff.FaaDiBruno","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type u_4\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nn : Nat\nc : OrderedFinpartition n\nf : ContinuousMultilinearMap 𝕜 (fun i => F) G\np : (i : Fin c.length) → ContinuousMultilinearMap 𝕜 (fun i => E) F\n⊢ Eq (((OrderedFinpartition.compAlongOrderedFinpartitionL 𝕜 E F G c) f) p) (c.compAlongOrderedFinpartition f p)","decl":"@[simp] lemma compAlongOrderedFinpartitionL_apply (f : F [×c.length]→L[𝕜] G)\n    (p : ∀ (i : Fin c.length), E[×c.partSize i]→L[𝕜] F) :\n    c.compAlongOrderedFinpartitionL 𝕜 E F G f p = c.compAlongOrderedFinpartition f p := rfl\n\n"}
{"name":"OrderedFinpartition.norm_compAlongOrderedFinpartitionL_le","module":"Mathlib.Analysis.Calculus.ContDiff.FaaDiBruno","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type u_4\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nn : Nat\nc : OrderedFinpartition n\n⊢ LE.le (Norm.norm (OrderedFinpartition.compAlongOrderedFinpartitionL 𝕜 E F G c)) 1","decl":"theorem norm_compAlongOrderedFinpartitionL_le :\n    set_option maxSynthPendingDepth 2 in\n    ‖c.compAlongOrderedFinpartitionL 𝕜 E F G‖ ≤ 1 :=\n  MultilinearMap.mkContinuousLinear_norm_le _ zero_le_one _\n\n"}
{"name":"FormalMultilinearSeries.compAlongOrderedFinpartition_apply","module":"Mathlib.Analysis.Calculus.ContDiff.FaaDiBruno","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type u_4\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nn : Nat\nq : FormalMultilinearSeries 𝕜 F G\np : FormalMultilinearSeries 𝕜 E F\nc : OrderedFinpartition n\nv : Fin n → E\n⊢ Eq ((q.compAlongOrderedFinpartition p c) v) ((q c.length) (c.applyOrderedFinpartition (fun m => p (c.partSize m)) v))","decl":"@[simp]\ntheorem compAlongOrderedFinpartition_apply {n : ℕ} (q : FormalMultilinearSeries 𝕜 F G)\n    (p : FormalMultilinearSeries 𝕜 E F) (c : OrderedFinpartition n) (v : Fin n → E) :\n    (q.compAlongOrderedFinpartition p c) v =\n      q c.length (c.applyOrderedFinpartition (fun m ↦ (p (c.partSize m))) v) :=\n  rfl\n\n"}
{"name":"analyticOn_taylorComp","module":"Mathlib.Analysis.Calculus.ContDiff.FaaDiBruno","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type u_4\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\ns : Set E\nt : Set F\nq : F → FormalMultilinearSeries 𝕜 F G\np : E → FormalMultilinearSeries 𝕜 E F\nhq : ∀ (n : Nat), AnalyticOn 𝕜 (fun x => q x n) t\nhp : ∀ (n : Nat), AnalyticOn 𝕜 (fun x => p x n) s\nf : E → F\nhf : AnalyticOn 𝕜 f s\nh : Set.MapsTo f s t\nn : Nat\n⊢ AnalyticOn 𝕜 (fun x => (q (f x)).taylorComp (p x) n) s","decl":"theorem analyticOn_taylorComp\n    (hq : ∀ (n : ℕ), AnalyticOn 𝕜 (fun x ↦ q x n) t)\n    (hp : ∀ n, AnalyticOn 𝕜 (fun x ↦ p x n) s) {f : E → F}\n    (hf : AnalyticOn 𝕜 f s) (h : MapsTo f s t) (n : ℕ) :\n    AnalyticOn 𝕜 (fun x ↦ (q (f x)).taylorComp (p x) n) s := by\n  apply Finset.analyticOn_sum _ (fun c _ ↦ ?_)\n  let B := c.compAlongOrderedFinpartitionL 𝕜 E F G\n  change AnalyticOn 𝕜\n    ((fun p ↦ B p.1 p.2) ∘ (fun x ↦ (q (f x) c.length, fun m ↦ p x (c.partSize m)))) s\n  apply B.analyticOnNhd_uncurry_of_multilinear.comp_analyticOn ?_ (mapsTo_univ _ _)\n  apply AnalyticOn.prod\n  · exact (hq c.length).comp hf h\n  · exact AnalyticOn.pi (fun i ↦ hp _)\n\n"}
{"name":"HasFTaylorSeriesUpToOn.comp","module":"Mathlib.Analysis.Calculus.ContDiff.FaaDiBruno","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type u_4\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\ns : Set E\nt : Set F\nq : F → FormalMultilinearSeries 𝕜 F G\np : E → FormalMultilinearSeries 𝕜 E F\nn : WithTop ENat\ng : F → G\nf : E → F\nhg : HasFTaylorSeriesUpToOn n g q t\nhf : HasFTaylorSeriesUpToOn n f p s\nh : Set.MapsTo f s t\n⊢ HasFTaylorSeriesUpToOn n (Function.comp g f) (fun x => (q (f x)).taylorComp (p x)) s","decl":"/-- *Faa di Bruno* formula: If two functions `g` and `f` have Taylor series up to `n` given by\n`q` and `p`, then `g ∘ f` also has a Taylor series, given by `q.taylorComp p`. -/\ntheorem HasFTaylorSeriesUpToOn.comp {n : WithTop ℕ∞} {g : F → G} {f : E → F}\n    (hg : HasFTaylorSeriesUpToOn n g q t) (hf : HasFTaylorSeriesUpToOn n f p s) (h : MapsTo f s t) :\n    HasFTaylorSeriesUpToOn n (g ∘ f) (fun x ↦ (q (f x)).taylorComp (p x)) s := by\n  /- One has to check that the `m+1`-th term is the derivative of the `m`-th term. The `m`-th term\n  is a sum, that one can differentiate term by term. Each term is a linear map into continuous\n  multilinear maps, applied to parts of `p` and `q`. One knows how to differentiate such a map,\n  thanks to `HasFDerivWithinAt.linear_multilinear_comp`. The terms that show up are matched, using\n  `faaDiBruno_aux1` and `faaDiBruno_aux2`, with terms of the same form at order `m+1`. Then, one\n  needs to check that one gets each term once and exactly once, which is given by the bijection\n  `OrderedFinpartition.extendEquiv m`. -/\n  classical\n  constructor\n  · intro x hx\n    simp [FormalMultilinearSeries.taylorComp, default, HasFTaylorSeriesUpToOn.zero_eq' hg (h hx)]\n  · intro m hm x hx\n    have A (c : OrderedFinpartition m) :\n      HasFDerivWithinAt (fun x ↦ (q (f x)).compAlongOrderedFinpartition (p x) c)\n        (∑ i : Option (Fin c.length),\n          ((q (f x)).compAlongOrderedFinpartition (p x) (c.extend i)).curryLeft) s x := by\n      let B := c.compAlongOrderedFinpartitionL 𝕜 E F G\n      change HasFDerivWithinAt (fun y ↦ B (q (f y) c.length) (fun i ↦ p y (c.partSize i)))\n        (∑ i : Option (Fin c.length),\n          ((q (f x)).compAlongOrderedFinpartition (p x) (c.extend i)).curryLeft) s x\n      have cm : (c.length : WithTop ℕ∞) ≤ m := mod_cast OrderedFinpartition.length_le c\n      have cp i : (c.partSize i : WithTop ℕ∞) ≤ m := by\n        exact_mod_cast OrderedFinpartition.partSize_le c i\n      have I i : HasFDerivWithinAt (fun x ↦ p x (c.partSize i))\n          (p x (c.partSize i).succ).curryLeft s x :=\n        hf.fderivWithin (c.partSize i) ((cp i).trans_lt hm) x hx\n      have J : HasFDerivWithinAt (fun x ↦ q x c.length) (q (f x) c.length.succ).curryLeft\n        t (f x) := hg.fderivWithin c.length (cm.trans_lt hm) (f x) (h hx)\n      have K : HasFDerivWithinAt f ((continuousMultilinearCurryFin1 𝕜 E F) (p x 1)) s x :=\n        hf.hasFDerivWithinAt (le_trans (mod_cast Nat.le_add_left 1 m)\n          (ENat.add_one_natCast_le_withTop_of_lt hm)) hx\n      convert HasFDerivWithinAt.linear_multilinear_comp (J.comp x K h) I B\n      simp only [B, Nat.succ_eq_add_one, Fintype.sum_option, comp_apply, faaDiBruno_aux1,\n        faaDiBruno_aux2]\n    have B : HasFDerivWithinAt (fun x ↦ (q (f x)).taylorComp (p x) m)\n        (∑ c : OrderedFinpartition m, ∑ i : Option (Fin c.length),\n          ((q (f x)).compAlongOrderedFinpartition (p x) (c.extend i)).curryLeft) s x :=\n      HasFDerivWithinAt.sum (fun c _ ↦ A c)\n    suffices ∑ c : OrderedFinpartition m, ∑ i : Option (Fin c.length),\n          ((q (f x)).compAlongOrderedFinpartition (p x) (c.extend i)) =\n        (q (f x)).taylorComp (p x) (m + 1) by\n      rw [← this]\n      convert B\n      ext v\n      simp only [Nat.succ_eq_add_one, Fintype.sum_option, ContinuousMultilinearMap.curryLeft_apply,\n        ContinuousMultilinearMap.sum_apply, ContinuousMultilinearMap.add_apply,\n        FormalMultilinearSeries.compAlongOrderedFinpartition_apply, ContinuousLinearMap.coe_sum',\n        Finset.sum_apply, ContinuousLinearMap.add_apply]\n    rw [Finset.sum_sigma']\n    exact Fintype.sum_equiv (OrderedFinpartition.extendEquiv m) _ _ (fun p ↦ rfl)\n  · intro m hm\n    apply continuousOn_finset_sum _ (fun c _ ↦ ?_)\n    let B := c.compAlongOrderedFinpartitionL 𝕜 E F G\n    change ContinuousOn\n      ((fun p ↦ B p.1 p.2) ∘ (fun x ↦ (q (f x) c.length, fun i ↦ p x (c.partSize i)))) s\n    apply B.continuous_uncurry_of_multilinear.comp_continuousOn (ContinuousOn.prod ?_ ?_)\n    · have : (c.length : WithTop ℕ∞) ≤ m := mod_cast OrderedFinpartition.length_le c\n      exact (hg.cont c.length (this.trans hm)).comp hf.continuousOn h\n    · apply continuousOn_pi.2 (fun i ↦ ?_)\n      have : (c.partSize i : WithTop ℕ∞) ≤ m := by\n        exact_mod_cast OrderedFinpartition.partSize_le c i\n      exact hf.cont _ (this.trans hm)\n"}
