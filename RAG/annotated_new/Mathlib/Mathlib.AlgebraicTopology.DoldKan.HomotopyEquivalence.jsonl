{"name":"AlgebraicTopology.DoldKan.homotopyPToId_eventually_constant","module":"Mathlib.AlgebraicTopology.DoldKan.HomotopyEquivalence","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù : CategoryTheory.Preadditive C\nX : CategoryTheory.SimplicialObject C\nq n : Nat\nhqn : LT.lt n q\n‚ä¢ Eq ((AlgebraicTopology.DoldKan.homotopyPToId X (HAdd.hAdd q 1)).hom n (HAdd.hAdd n 1)) ((AlgebraicTopology.DoldKan.homotopyPToId X q).hom n (HAdd.hAdd n 1))","decl":"theorem homotopyPToId_eventually_constant {q n : ‚Ñï} (hqn : n < q) :\n    ((homotopyPToId X (q + 1)).hom n (n + 1) : X _[n] ‚ü∂ X _[n + 1]) =\n      (homotopyPToId X q).hom n (n + 1) := by\n  simp only [homotopyHœÉToZero, AlternatingFaceMapComplex.obj_X, Nat.add_eq, Homotopy.trans_hom,\n    Homotopy.ofEq_hom, Pi.zero_apply, Homotopy.add_hom, Homotopy.compLeft_hom, add_zero,\n    Homotopy.nullHomotopy'_hom, ComplexShape.down_Rel, hœÉ'_eq_zero hqn (c_mk (n + 1) n rfl),\n    dite_eq_ite, ite_self, comp_zero, zero_add, homotopyPToId]\n\n"}
{"name":"AlgebraicTopology.DoldKan.homotopyPInftyToId_hom","module":"Mathlib.AlgebraicTopology.DoldKan.HomotopyEquivalence","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù : CategoryTheory.Preadditive C\nX : CategoryTheory.SimplicialObject C\ni j : Nat\n‚ä¢ Eq ((AlgebraicTopology.DoldKan.homotopyPInftyToId X).hom i j) ((AlgebraicTopology.DoldKan.homotopyPToId X (HAdd.hAdd j 1)).hom i j)","decl":"/-- Construction of the homotopy from `PInfty` to the identity using eventually\n(termwise) constant homotopies from `P q` to the identity for all `q` -/\n@[simps]\ndef homotopyPInftyToId : Homotopy (PInfty : K[X] ‚ü∂ _) (ùüô _) where\n  hom i j := (homotopyPToId X (j + 1)).hom i j\n  zero i j hij := Homotopy.zero _ i j hij\n  comm n := by\n    rcases n with _|n\n    ¬∑ simpa only [Homotopy.dNext_zero_chainComplex, Homotopy.prevD_chainComplex,\n        PInfty_f, P_f_0_eq, zero_add] using (homotopyPToId X 2).comm 0\n    ¬∑ simp only [Homotopy.dNext_succ_chainComplex, Homotopy.prevD_chainComplex,\n        HomologicalComplex.id_f, PInfty_f, ‚Üê P_is_eventually_constant (le_refl <| n + 1)]\n      -- Porting note(lean4/2146): remaining proof was\n      -- `simpa only [homotopyPToId_eventually_constant X (lt_add_one (Nat.succ n))]\n      -- using (homotopyPToId X (n + 2)).comm (n + 1)`;\n      -- fails since leanprover/lean4:nightly-2023-05-16; `erw` below clunkily works around this.\n      erw [homotopyPToId_eventually_constant X (lt_add_one (Nat.succ n))]\n      have := (homotopyPToId X (n + 2)).comm (n + 1)\n      rw [Homotopy.dNext_succ_chainComplex, Homotopy.prevD_chainComplex] at this\n      exact this\n\n"}
{"name":"AlgebraicTopology.DoldKan.homotopyEquivNormalizedMooreComplexAlternatingFaceMapComplex_inv","module":"Mathlib.AlgebraicTopology.DoldKan.HomotopyEquivalence","initialProofState":"A : Type u_2\ninst‚úù¬π : CategoryTheory.Category.{u_3, u_2} A\ninst‚úù : CategoryTheory.Abelian A\nY : CategoryTheory.SimplicialObject A\n‚ä¢ Eq AlgebraicTopology.DoldKan.homotopyEquivNormalizedMooreComplexAlternatingFaceMapComplex.inv (AlgebraicTopology.DoldKan.PInftyToNormalizedMooreComplex Y)","decl":"/-- The inclusion of the Moore complex in the alternating face map complex\nis a homotopy equivalence -/\n@[simps]\ndef homotopyEquivNormalizedMooreComplexAlternatingFaceMapComplex {A : Type*} [Category A]\n    [Abelian A] {Y : SimplicialObject A} :\n    HomotopyEquiv ((normalizedMooreComplex A).obj Y) ((alternatingFaceMapComplex A).obj Y) where\n  hom := inclusionOfMooreComplexMap Y\n  inv := PInftyToNormalizedMooreComplex Y\n  homotopyHomInvId := Homotopy.ofEq (splitMonoInclusionOfMooreComplexMap Y).id\n  homotopyInvHomId := Homotopy.trans\n      (Homotopy.ofEq (PInftyToNormalizedMooreComplex_comp_inclusionOfMooreComplexMap Y))\n      (homotopyPInftyToId Y)\n\n"}
{"name":"AlgebraicTopology.DoldKan.homotopyEquivNormalizedMooreComplexAlternatingFaceMapComplex_homotopyInvHomId","module":"Mathlib.AlgebraicTopology.DoldKan.HomotopyEquivalence","initialProofState":"A : Type u_2\ninst‚úù¬π : CategoryTheory.Category.{u_3, u_2} A\ninst‚úù : CategoryTheory.Abelian A\nY : CategoryTheory.SimplicialObject A\n‚ä¢ Eq AlgebraicTopology.DoldKan.homotopyEquivNormalizedMooreComplexAlternatingFaceMapComplex.homotopyInvHomId ((Homotopy.ofEq ‚ãØ).trans (AlgebraicTopology.DoldKan.homotopyPInftyToId Y))","decl":"/-- The inclusion of the Moore complex in the alternating face map complex\nis a homotopy equivalence -/\n@[simps]\ndef homotopyEquivNormalizedMooreComplexAlternatingFaceMapComplex {A : Type*} [Category A]\n    [Abelian A] {Y : SimplicialObject A} :\n    HomotopyEquiv ((normalizedMooreComplex A).obj Y) ((alternatingFaceMapComplex A).obj Y) where\n  hom := inclusionOfMooreComplexMap Y\n  inv := PInftyToNormalizedMooreComplex Y\n  homotopyHomInvId := Homotopy.ofEq (splitMonoInclusionOfMooreComplexMap Y).id\n  homotopyInvHomId := Homotopy.trans\n      (Homotopy.ofEq (PInftyToNormalizedMooreComplex_comp_inclusionOfMooreComplexMap Y))\n      (homotopyPInftyToId Y)\n\n"}
{"name":"AlgebraicTopology.DoldKan.homotopyEquivNormalizedMooreComplexAlternatingFaceMapComplex_homotopyHomInvId","module":"Mathlib.AlgebraicTopology.DoldKan.HomotopyEquivalence","initialProofState":"A : Type u_2\ninst‚úù¬π : CategoryTheory.Category.{u_3, u_2} A\ninst‚úù : CategoryTheory.Abelian A\nY : CategoryTheory.SimplicialObject A\n‚ä¢ Eq AlgebraicTopology.DoldKan.homotopyEquivNormalizedMooreComplexAlternatingFaceMapComplex.homotopyHomInvId (Homotopy.ofEq ‚ãØ)","decl":"/-- The inclusion of the Moore complex in the alternating face map complex\nis a homotopy equivalence -/\n@[simps]\ndef homotopyEquivNormalizedMooreComplexAlternatingFaceMapComplex {A : Type*} [Category A]\n    [Abelian A] {Y : SimplicialObject A} :\n    HomotopyEquiv ((normalizedMooreComplex A).obj Y) ((alternatingFaceMapComplex A).obj Y) where\n  hom := inclusionOfMooreComplexMap Y\n  inv := PInftyToNormalizedMooreComplex Y\n  homotopyHomInvId := Homotopy.ofEq (splitMonoInclusionOfMooreComplexMap Y).id\n  homotopyInvHomId := Homotopy.trans\n      (Homotopy.ofEq (PInftyToNormalizedMooreComplex_comp_inclusionOfMooreComplexMap Y))\n      (homotopyPInftyToId Y)\n\n"}
{"name":"AlgebraicTopology.DoldKan.homotopyEquivNormalizedMooreComplexAlternatingFaceMapComplex_hom","module":"Mathlib.AlgebraicTopology.DoldKan.HomotopyEquivalence","initialProofState":"A : Type u_2\ninst‚úù¬π : CategoryTheory.Category.{u_3, u_2} A\ninst‚úù : CategoryTheory.Abelian A\nY : CategoryTheory.SimplicialObject A\n‚ä¢ Eq AlgebraicTopology.DoldKan.homotopyEquivNormalizedMooreComplexAlternatingFaceMapComplex.hom (AlgebraicTopology.inclusionOfMooreComplexMap Y)","decl":"/-- The inclusion of the Moore complex in the alternating face map complex\nis a homotopy equivalence -/\n@[simps]\ndef homotopyEquivNormalizedMooreComplexAlternatingFaceMapComplex {A : Type*} [Category A]\n    [Abelian A] {Y : SimplicialObject A} :\n    HomotopyEquiv ((normalizedMooreComplex A).obj Y) ((alternatingFaceMapComplex A).obj Y) where\n  hom := inclusionOfMooreComplexMap Y\n  inv := PInftyToNormalizedMooreComplex Y\n  homotopyHomInvId := Homotopy.ofEq (splitMonoInclusionOfMooreComplexMap Y).id\n  homotopyInvHomId := Homotopy.trans\n      (Homotopy.ofEq (PInftyToNormalizedMooreComplex_comp_inclusionOfMooreComplexMap Y))\n      (homotopyPInftyToId Y)\n\n"}
