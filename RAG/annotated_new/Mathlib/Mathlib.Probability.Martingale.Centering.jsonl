{"name":"MeasureTheory.predictablePart_zero","module":"Mathlib.Probability.Martingale.Centering","initialProofState":"Ω : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Ω\nμ : MeasureTheory.Measure Ω\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\ninst✝ : CompleteSpace E\nf : Nat → Ω → E\nℱ : MeasureTheory.Filtration Nat m0\n⊢ Eq (MeasureTheory.predictablePart f ℱ μ 0) 0","decl":"@[simp]\ntheorem predictablePart_zero : predictablePart f ℱ μ 0 = 0 := by\n  simp_rw [predictablePart, Finset.range_zero, Finset.sum_empty]\n\n"}
{"name":"MeasureTheory.adapted_predictablePart","module":"Mathlib.Probability.Martingale.Centering","initialProofState":"Ω : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Ω\nμ : MeasureTheory.Measure Ω\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\ninst✝ : CompleteSpace E\nf : Nat → Ω → E\nℱ : MeasureTheory.Filtration Nat m0\n⊢ MeasureTheory.Adapted ℱ fun n => MeasureTheory.predictablePart f ℱ μ (HAdd.hAdd n 1)","decl":"theorem adapted_predictablePart : Adapted ℱ fun n => predictablePart f ℱ μ (n + 1) := fun _ =>\n  Finset.stronglyMeasurable_sum' _ fun _ hin =>\n    stronglyMeasurable_condExp.mono (ℱ.mono (Finset.mem_range_succ_iff.mp hin))\n\n"}
{"name":"MeasureTheory.adapted_predictablePart'","module":"Mathlib.Probability.Martingale.Centering","initialProofState":"Ω : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Ω\nμ : MeasureTheory.Measure Ω\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\ninst✝ : CompleteSpace E\nf : Nat → Ω → E\nℱ : MeasureTheory.Filtration Nat m0\n⊢ MeasureTheory.Adapted ℱ fun n => MeasureTheory.predictablePart f ℱ μ n","decl":"theorem adapted_predictablePart' : Adapted ℱ fun n => predictablePart f ℱ μ n := fun _ =>\n  Finset.stronglyMeasurable_sum' _ fun _ hin =>\n    stronglyMeasurable_condExp.mono (ℱ.mono (Finset.mem_range_le hin))\n\n"}
{"name":"MeasureTheory.martingalePart_add_predictablePart","module":"Mathlib.Probability.Martingale.Centering","initialProofState":"Ω : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Ω\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\ninst✝ : CompleteSpace E\nℱ : MeasureTheory.Filtration Nat m0\nμ : MeasureTheory.Measure Ω\nf : Nat → Ω → E\n⊢ Eq (HAdd.hAdd (MeasureTheory.martingalePart f ℱ μ) (MeasureTheory.predictablePart f ℱ μ)) f","decl":"theorem martingalePart_add_predictablePart (ℱ : Filtration ℕ m0) (μ : Measure Ω) (f : ℕ → Ω → E) :\n    martingalePart f ℱ μ + predictablePart f ℱ μ = f :=\n  sub_add_cancel _ _\n\n"}
{"name":"MeasureTheory.martingalePart_eq_sum","module":"Mathlib.Probability.Martingale.Centering","initialProofState":"Ω : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Ω\nμ : MeasureTheory.Measure Ω\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\ninst✝ : CompleteSpace E\nf : Nat → Ω → E\nℱ : MeasureTheory.Filtration Nat m0\n⊢ Eq (MeasureTheory.martingalePart f ℱ μ) fun n => HAdd.hAdd (f 0) ((Finset.range n).sum fun i => HSub.hSub (HSub.hSub (f (HAdd.hAdd i 1)) (f i)) (MeasureTheory.condExp (↑ℱ i) μ (HSub.hSub (f (HAdd.hAdd i 1)) (f i))))","decl":"theorem martingalePart_eq_sum : martingalePart f ℱ μ = fun n =>\n    f 0 + ∑ i ∈ Finset.range n, (f (i + 1) - f i - μ[f (i + 1) - f i|ℱ i]) := by\n  unfold martingalePart predictablePart\n  ext1 n\n  rw [Finset.eq_sum_range_sub f n, ← add_sub, ← Finset.sum_sub_distrib]\n\n"}
{"name":"MeasureTheory.adapted_martingalePart","module":"Mathlib.Probability.Martingale.Centering","initialProofState":"Ω : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Ω\nμ : MeasureTheory.Measure Ω\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\ninst✝ : CompleteSpace E\nf : Nat → Ω → E\nℱ : MeasureTheory.Filtration Nat m0\nhf : MeasureTheory.Adapted ℱ f\n⊢ MeasureTheory.Adapted ℱ (MeasureTheory.martingalePart f ℱ μ)","decl":"theorem adapted_martingalePart (hf : Adapted ℱ f) : Adapted ℱ (martingalePart f ℱ μ) :=\n  Adapted.sub hf adapted_predictablePart'\n\n"}
{"name":"MeasureTheory.integrable_martingalePart","module":"Mathlib.Probability.Martingale.Centering","initialProofState":"Ω : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Ω\nμ : MeasureTheory.Measure Ω\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\ninst✝ : CompleteSpace E\nf : Nat → Ω → E\nℱ : MeasureTheory.Filtration Nat m0\nhf_int : ∀ (n : Nat), MeasureTheory.Integrable (f n) μ\nn : Nat\n⊢ MeasureTheory.Integrable (MeasureTheory.martingalePart f ℱ μ n) μ","decl":"theorem integrable_martingalePart (hf_int : ∀ n, Integrable (f n) μ) (n : ℕ) :\n    Integrable (martingalePart f ℱ μ n) μ := by\n  rw [martingalePart_eq_sum]\n  fun_prop\n\n"}
{"name":"MeasureTheory.martingale_martingalePart","module":"Mathlib.Probability.Martingale.Centering","initialProofState":"Ω : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Ω\nμ : MeasureTheory.Measure Ω\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace Real E\ninst✝¹ : CompleteSpace E\nf : Nat → Ω → E\nℱ : MeasureTheory.Filtration Nat m0\nhf : MeasureTheory.Adapted ℱ f\nhf_int : ∀ (n : Nat), MeasureTheory.Integrable (f n) μ\ninst✝ : MeasureTheory.SigmaFiniteFiltration μ ℱ\n⊢ MeasureTheory.Martingale (MeasureTheory.martingalePart f ℱ μ) ℱ μ","decl":"theorem martingale_martingalePart (hf : Adapted ℱ f) (hf_int : ∀ n, Integrable (f n) μ)\n    [SigmaFiniteFiltration μ ℱ] : Martingale (martingalePart f ℱ μ) ℱ μ := by\n  refine ⟨adapted_martingalePart hf, fun i j hij => ?_⟩\n  -- ⊢ μ[martingalePart f ℱ μ j | ℱ i] =ᵐ[μ] martingalePart f ℱ μ i\n  have h_eq_sum : μ[martingalePart f ℱ μ j|ℱ i] =ᵐ[μ]\n      f 0 + ∑ k ∈ Finset.range j, (μ[f (k + 1) - f k|ℱ i] - μ[μ[f (k + 1) - f k|ℱ k]|ℱ i]) := by\n    rw [martingalePart_eq_sum]\n    refine (condExp_add (hf_int 0) (by fun_prop) _).trans ?_\n    refine (EventuallyEq.rfl.add (condExp_finset_sum (fun i _ => by fun_prop) _)).trans ?_\n    refine EventuallyEq.add ?_ ?_\n    · rw [condExp_of_stronglyMeasurable (ℱ.le _) _ (hf_int 0)]\n      · exact (hf 0).mono (ℱ.mono (zero_le i))\n    · exact eventuallyEq_sum fun k _ => condExp_sub (by fun_prop) integrable_condExp _\n  refine h_eq_sum.trans ?_\n  have h_ge : ∀ k, i ≤ k → μ[f (k + 1) - f k|ℱ i] - μ[μ[f (k + 1) - f k|ℱ k]|ℱ i] =ᵐ[μ] 0 := by\n    intro k hk\n    have : μ[μ[f (k + 1) - f k|ℱ k]|ℱ i] =ᵐ[μ] μ[f (k + 1) - f k|ℱ i] :=\n      condExp_condExp_of_le (ℱ.mono hk) (ℱ.le k)\n    filter_upwards [this] with x hx\n    rw [Pi.sub_apply, Pi.zero_apply, hx, sub_self]\n  have h_lt : ∀ k, k < i → μ[f (k + 1) - f k|ℱ i] - μ[μ[f (k + 1) - f k|ℱ k]|ℱ i] =ᵐ[μ]\n      f (k + 1) - f k - μ[f (k + 1) - f k|ℱ k] := by\n    refine fun k hk => EventuallyEq.sub ?_ ?_\n    · rw [condExp_of_stronglyMeasurable]\n      · exact ((hf (k + 1)).mono (ℱ.mono (Nat.succ_le_of_lt hk))).sub ((hf k).mono (ℱ.mono hk.le))\n      · exact (hf_int _).sub (hf_int _)\n    · rw [condExp_of_stronglyMeasurable]\n      · exact stronglyMeasurable_condExp.mono (ℱ.mono hk.le)\n      · exact integrable_condExp\n  rw [martingalePart_eq_sum]\n  refine EventuallyEq.add EventuallyEq.rfl ?_\n  rw [← Finset.sum_range_add_sum_Ico _ hij, ←\n    add_zero (∑ i ∈ Finset.range i, (f (i + 1) - f i - μ[f (i + 1) - f i|ℱ i]))]\n  refine (eventuallyEq_sum fun k hk => h_lt k (Finset.mem_range.mp hk)).add ?_\n  refine (eventuallyEq_sum fun k hk => h_ge k (Finset.mem_Ico.mp hk).1).trans ?_\n  simp only [Finset.sum_const_zero, Pi.zero_apply]\n  rfl\n\n-- The following two lemmas demonstrate the essential uniqueness of the decomposition\n"}
{"name":"MeasureTheory.martingalePart_add_ae_eq","module":"Mathlib.Probability.Martingale.Centering","initialProofState":"Ω : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Ω\nμ : MeasureTheory.Measure Ω\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace Real E\ninst✝¹ : CompleteSpace E\nℱ : MeasureTheory.Filtration Nat m0\ninst✝ : MeasureTheory.SigmaFiniteFiltration μ ℱ\nf g : Nat → Ω → E\nhf : MeasureTheory.Martingale f ℱ μ\nhg : MeasureTheory.Adapted ℱ fun n => g (HAdd.hAdd n 1)\nhg0 : Eq (g 0) 0\nhgint : ∀ (n : Nat), MeasureTheory.Integrable (g n) μ\nn : Nat\n⊢ (MeasureTheory.ae μ).EventuallyEq (MeasureTheory.martingalePart (HAdd.hAdd f g) ℱ μ n) (f n)","decl":"theorem martingalePart_add_ae_eq [SigmaFiniteFiltration μ ℱ] {f g : ℕ → Ω → E}\n    (hf : Martingale f ℱ μ) (hg : Adapted ℱ fun n => g (n + 1)) (hg0 : g 0 = 0)\n    (hgint : ∀ n, Integrable (g n) μ) (n : ℕ) : martingalePart (f + g) ℱ μ n =ᵐ[μ] f n := by\n  set h := f - martingalePart (f + g) ℱ μ with hhdef\n  have hh : h = predictablePart (f + g) ℱ μ - g := by\n    rw [hhdef, sub_eq_sub_iff_add_eq_add, add_comm (predictablePart (f + g) ℱ μ),\n      martingalePart_add_predictablePart]\n  have hhpred : Adapted ℱ fun n => h (n + 1) := by\n    rw [hh]\n    exact adapted_predictablePart.sub hg\n  have hhmgle : Martingale h ℱ μ := hf.sub (martingale_martingalePart\n    (hf.adapted.add <| Predictable.adapted hg <| hg0.symm ▸ stronglyMeasurable_zero) fun n =>\n    (hf.integrable n).add <| hgint n)\n  refine (eventuallyEq_iff_sub.2 ?_).symm\n  filter_upwards [hhmgle.eq_zero_of_predictable hhpred n] with ω hω\n  unfold h at hω\n  rw [Pi.sub_apply] at hω\n  rw [hω, Pi.sub_apply, martingalePart]\n  simp [hg0]\n\n"}
{"name":"MeasureTheory.predictablePart_add_ae_eq","module":"Mathlib.Probability.Martingale.Centering","initialProofState":"Ω : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Ω\nμ : MeasureTheory.Measure Ω\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace Real E\ninst✝¹ : CompleteSpace E\nℱ : MeasureTheory.Filtration Nat m0\ninst✝ : MeasureTheory.SigmaFiniteFiltration μ ℱ\nf g : Nat → Ω → E\nhf : MeasureTheory.Martingale f ℱ μ\nhg : MeasureTheory.Adapted ℱ fun n => g (HAdd.hAdd n 1)\nhg0 : Eq (g 0) 0\nhgint : ∀ (n : Nat), MeasureTheory.Integrable (g n) μ\nn : Nat\n⊢ (MeasureTheory.ae μ).EventuallyEq (MeasureTheory.predictablePart (HAdd.hAdd f g) ℱ μ n) (g n)","decl":"theorem predictablePart_add_ae_eq [SigmaFiniteFiltration μ ℱ] {f g : ℕ → Ω → E}\n    (hf : Martingale f ℱ μ) (hg : Adapted ℱ fun n => g (n + 1)) (hg0 : g 0 = 0)\n    (hgint : ∀ n, Integrable (g n) μ) (n : ℕ) : predictablePart (f + g) ℱ μ n =ᵐ[μ] g n := by\n  filter_upwards [martingalePart_add_ae_eq hf hg hg0 hgint n] with ω hω\n  rw [← add_right_inj (f n ω)]\n  conv_rhs => rw [← Pi.add_apply, ← Pi.add_apply, ← martingalePart_add_predictablePart ℱ μ (f + g)]\n  rw [Pi.add_apply, Pi.add_apply, hω]\n\n"}
{"name":"MeasureTheory.predictablePart_bdd_difference","module":"Mathlib.Probability.Martingale.Centering","initialProofState":"Ω : Type u_1\nm0 : MeasurableSpace Ω\nμ : MeasureTheory.Measure Ω\nR : NNReal\nf : Nat → Ω → Real\nℱ : MeasureTheory.Filtration Nat m0\nhbdd : Filter.Eventually (fun ω => ∀ (i : Nat), LE.le (abs (HSub.hSub (f (HAdd.hAdd i 1) ω) (f i ω))) ↑R) (MeasureTheory.ae μ)\n⊢ Filter.Eventually (fun ω => ∀ (i : Nat), LE.le (abs (HSub.hSub (MeasureTheory.predictablePart f ℱ μ (HAdd.hAdd i 1) ω) (MeasureTheory.predictablePart f ℱ μ i ω))) ↑R) (MeasureTheory.ae μ)","decl":"theorem predictablePart_bdd_difference {R : ℝ≥0} {f : ℕ → Ω → ℝ} (ℱ : Filtration ℕ m0)\n    (hbdd : ∀ᵐ ω ∂μ, ∀ i, |f (i + 1) ω - f i ω| ≤ R) :\n    ∀ᵐ ω ∂μ, ∀ i, |predictablePart f ℱ μ (i + 1) ω - predictablePart f ℱ μ i ω| ≤ R := by\n  simp_rw [predictablePart, Finset.sum_apply, Finset.sum_range_succ_sub_sum]\n  exact ae_all_iff.2 fun i => ae_bdd_condExp_of_ae_bdd <| ae_all_iff.1 hbdd i\n\n"}
{"name":"MeasureTheory.martingalePart_bdd_difference","module":"Mathlib.Probability.Martingale.Centering","initialProofState":"Ω : Type u_1\nm0 : MeasurableSpace Ω\nμ : MeasureTheory.Measure Ω\nR : NNReal\nf : Nat → Ω → Real\nℱ : MeasureTheory.Filtration Nat m0\nhbdd : Filter.Eventually (fun ω => ∀ (i : Nat), LE.le (abs (HSub.hSub (f (HAdd.hAdd i 1) ω) (f i ω))) ↑R) (MeasureTheory.ae μ)\n⊢ Filter.Eventually (fun ω => ∀ (i : Nat), LE.le (abs (HSub.hSub (MeasureTheory.martingalePart f ℱ μ (HAdd.hAdd i 1) ω) (MeasureTheory.martingalePart f ℱ μ i ω))) ↑(HMul.hMul 2 R)) (MeasureTheory.ae μ)","decl":"theorem martingalePart_bdd_difference {R : ℝ≥0} {f : ℕ → Ω → ℝ} (ℱ : Filtration ℕ m0)\n    (hbdd : ∀ᵐ ω ∂μ, ∀ i, |f (i + 1) ω - f i ω| ≤ R) :\n    ∀ᵐ ω ∂μ, ∀ i, |martingalePart f ℱ μ (i + 1) ω - martingalePart f ℱ μ i ω| ≤ ↑(2 * R) := by\n  filter_upwards [hbdd, predictablePart_bdd_difference ℱ hbdd] with ω hω₁ hω₂ i\n  simp only [two_mul, martingalePart, Pi.sub_apply]\n  have : |f (i + 1) ω - predictablePart f ℱ μ (i + 1) ω - (f i ω - predictablePart f ℱ μ i ω)| =\n      |f (i + 1) ω - f i ω - (predictablePart f ℱ μ (i + 1) ω - predictablePart f ℱ μ i ω)| := by\n    ring_nf -- `ring` suggests `ring_nf` despite proving the goal\n  rw [this]\n  exact (abs_sub _ _).trans (add_le_add (hω₁ i) (hω₂ i))\n\n"}
