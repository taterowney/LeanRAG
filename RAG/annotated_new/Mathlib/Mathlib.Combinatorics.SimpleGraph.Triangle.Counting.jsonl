{"name":"SimpleGraph.triangle_counting'","module":"Mathlib.Combinatorics.SimpleGraph.Triangle.Counting","initialProofState":"α : Type u_1\nG : SimpleGraph α\ninst✝ : DecidableRel G.Adj\nε : Real\ns t u : Finset α\ndst : LE.le (HMul.hMul 2 ε) ↑(G.edgeDensity s t)\nhst : G.IsUniform ε s t\ndsu : LE.le (HMul.hMul 2 ε) ↑(G.edgeDensity s u)\nusu : G.IsUniform ε s u\ndtu : LE.le (HMul.hMul 2 ε) ↑(G.edgeDensity t u)\nutu : G.IsUniform ε t u\n⊢ LE.le (HMul.hMul (HMul.hMul (HMul.hMul (HMul.hMul (HSub.hSub 1 (HMul.hMul 2 ε)) (HPow.hPow ε 3)) ↑s.card) ↑t.card) ↑u.card) ↑(Finset.filter (fun x => SimpleGraph.triangle_split_helper.match_1 (fun x => Prop) x fun a b c => And (G.Adj a b) (And (G.Adj a c) (G.Adj b c))) (SProd.sprod s (SProd.sprod t u))).card","decl":"/-- The **Triangle Counting Lemma**. If `G` is a graph and `s`, `t`, `u` are sets of vertices such\nthat each pair is `ε`-uniform and `2 * ε`-dense, then a proportion of at least\n`(1 - 2 * ε) * ε ^ 3` of the triples `(a, b, c) ∈ s × t × u` are triangles. -/\nlemma triangle_counting'\n    (dst : 2 * ε ≤ G.edgeDensity s t) (hst : G.IsUniform ε s t)\n    (dsu : 2 * ε ≤ G.edgeDensity s u) (usu : G.IsUniform ε s u)\n    (dtu : 2 * ε ≤ G.edgeDensity t u) (utu : G.IsUniform ε t u) :\n    (1 - 2 * ε) * ε ^ 3 * #s * #t * #u ≤\n      #((s ×ˢ t ×ˢ u).filter fun (a, b, c) ↦ G.Adj a b ∧ G.Adj a c ∧ G.Adj b c) := by\n  classical\n  have h₁ : #(badVertices G ε s t) ≤ #s * ε := G.card_badVertices_le dst hst\n  have h₂ : #(badVertices G ε s u) ≤ #s * ε := G.card_badVertices_le dsu usu\n  let X' := s \\ (badVertices G ε s t ∪ badVertices G ε s u)\n  have : X'.biUnion _ ⊆ (s ×ˢ t ×ˢ u).filter fun (a, b, c) ↦ G.Adj a b ∧ G.Adj a c ∧ G.Adj b c :=\n    triangle_split_helper _\n  refine le_trans ?_ (Nat.cast_le.2 <| card_le_card this)\n  rw [card_biUnion, Nat.cast_sum]\n  · apply le_trans _ (card_nsmul_le_sum X' _ _ <| G.good_vertices_triangle_card dst dsu dtu utu)\n    rw [nsmul_eq_mul]\n    have := hst.pos.le\n    suffices hX' : (1 - 2 * ε) * #s ≤ #X' by\n      exact Eq.trans_le (by ring) (mul_le_mul_of_nonneg_right hX' <| by positivity)\n    have i : badVertices G ε s t ∪ badVertices G ε s u ⊆ s :=\n      union_subset (filter_subset _ _) (filter_subset _ _)\n    rw [sub_mul, one_mul, card_sdiff i, Nat.cast_sub (card_le_card i), sub_le_sub_iff_left,\n      mul_assoc, mul_comm ε, two_mul]\n    refine (Nat.cast_le.2 <| card_union_le _ _).trans ?_\n    rw [Nat.cast_add]\n    exact add_le_add h₁ h₂\n  rintro a _ b _ t\n  rw [disjoint_left]\n  simp only [Prod.forall, mem_image, not_exists, exists_prop, mem_filter, Prod.mk.inj_iff,\n    exists_imp, and_imp, not_and, mem_product, or_assoc]\n  aesop\n\n"}
{"name":"SimpleGraph.triangle_counting","module":"Mathlib.Combinatorics.SimpleGraph.Triangle.Counting","initialProofState":"α : Type u_1\nG : SimpleGraph α\ninst✝² : DecidableRel G.Adj\nε : Real\ns t u : Finset α\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\ndst : LE.le (HMul.hMul 2 ε) ↑(G.edgeDensity s t)\nust : G.IsUniform ε s t\nhst : Disjoint s t\ndsu : LE.le (HMul.hMul 2 ε) ↑(G.edgeDensity s u)\nusu : G.IsUniform ε s u\nhsu : Disjoint s u\ndtu : LE.le (HMul.hMul 2 ε) ↑(G.edgeDensity t u)\nutu : G.IsUniform ε t u\nhtu : Disjoint t u\n⊢ LE.le (HMul.hMul (HMul.hMul (HMul.hMul (HMul.hMul (HSub.hSub 1 (HMul.hMul 2 ε)) (HPow.hPow ε 3)) ↑s.card) ↑t.card) ↑u.card) ↑(G.cliqueFinset 3).card","decl":"/-- The **Triangle Counting Lemma**. If `G` is a graph and `s`, `t`, `u` are disjoint sets of\nvertices such that each pair is `ε`-uniform and `2 * ε`-dense, then `G` contains at least\n`(1 - 2 * ε) * ε ^ 3 * |s| * |t| * |u|` triangles. -/\nlemma triangle_counting\n    (dst : 2 * ε ≤ G.edgeDensity s t) (ust : G.IsUniform ε s t) (hst : Disjoint s t)\n    (dsu : 2 * ε ≤ G.edgeDensity s u) (usu : G.IsUniform ε s u) (hsu : Disjoint s u)\n    (dtu : 2 * ε ≤ G.edgeDensity t u) (utu : G.IsUniform ε t u) (htu : Disjoint t u) :\n    (1 - 2 * ε) * ε ^ 3 * #s * #t * #u ≤ #(G.cliqueFinset 3) := by\n  apply (G.triangle_counting' dst ust dsu usu dtu utu).trans _\n  rw [Nat.cast_le]\n  refine card_le_card_of_injOn (fun (x, y, z) ↦ {x, y, z}) ?_ ?_\n  · rintro ⟨x, y, z⟩\n    simp only [and_imp, mem_filter, mem_product, mem_cliqueFinset_iff, is3Clique_triple_iff]\n    exact fun _ _ _ hxy hxz hyz ↦ ⟨hxy, hxz, hyz⟩\n  rintro ⟨x₁, y₁, z₁⟩ h₁ ⟨x₂, y₂, z₂⟩ h₂ t\n  simp only [mem_coe, mem_filter, mem_product] at h₁ h₂\n  apply triple_eq_triple_of_mem hst hsu htu t <;> tauto\n\n"}
