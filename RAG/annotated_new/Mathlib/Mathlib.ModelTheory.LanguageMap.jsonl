{"name":"FirstOrder.Language.LHom.mk.sizeOf_spec","module":"Mathlib.ModelTheory.LanguageMap","initialProofState":"L : FirstOrder.Language\nL' : FirstOrder.Language\nonFunction : autoParam (⦃n : Nat⦄ → L.Functions n → L'.Functions n) _auto✝\nonRelation : autoParam (⦃n : Nat⦄ → L.Relations n → L'.Relations n) _auto✝\n⊢ Eq (SizeOf.sizeOf { onFunction := onFunction, onRelation := onRelation }) 1","decl":"/-- A language homomorphism maps the symbols of one language to symbols of another. -/\nstructure LHom where\n  onFunction : ∀ ⦃n⦄, L.Functions n → L'.Functions n := by\n    exact fun {n} => isEmptyElim\n  onRelation : ∀ ⦃n⦄, L.Relations n → L'.Relations n :=by\n    exact fun {n} => isEmptyElim\n\n"}
{"name":"FirstOrder.Language.LHom.mk.inj","module":"Mathlib.ModelTheory.LanguageMap","initialProofState":"L : FirstOrder.Language\nL' : FirstOrder.Language\nonFunction✝ : autoParam (⦃n : Nat⦄ → L.Functions n → L'.Functions n) _auto✝\nonRelation✝ : autoParam (⦃n : Nat⦄ → L.Relations n → L'.Relations n) _auto✝\nonFunction : autoParam (⦃n : Nat⦄ → L.Functions n → L'.Functions n) _auto✝\nonRelation : autoParam (⦃n : Nat⦄ → L.Relations n → L'.Relations n) _auto✝\nx✝ : Eq { onFunction := onFunction✝, onRelation := onRelation✝ } { onFunction := onFunction, onRelation := onRelation }\n⊢ And (Eq onFunction✝ onFunction) (Eq onRelation✝ onRelation)","decl":"/-- A language homomorphism maps the symbols of one language to symbols of another. -/\nstructure LHom where\n  onFunction : ∀ ⦃n⦄, L.Functions n → L'.Functions n := by\n    exact fun {n} => isEmptyElim\n  onRelation : ∀ ⦃n⦄, L.Relations n → L'.Relations n :=by\n    exact fun {n} => isEmptyElim\n\n"}
{"name":"FirstOrder.Language.LHom.mk.injEq","module":"Mathlib.ModelTheory.LanguageMap","initialProofState":"L : FirstOrder.Language\nL' : FirstOrder.Language\nonFunction✝ : autoParam (⦃n : Nat⦄ → L.Functions n → L'.Functions n) _auto✝\nonRelation✝ : autoParam (⦃n : Nat⦄ → L.Relations n → L'.Relations n) _auto✝\nonFunction : autoParam (⦃n : Nat⦄ → L.Functions n → L'.Functions n) _auto✝\nonRelation : autoParam (⦃n : Nat⦄ → L.Relations n → L'.Relations n) _auto✝\n⊢ Eq (Eq { onFunction := onFunction✝, onRelation := onRelation✝ } { onFunction := onFunction, onRelation := onRelation }) (And (Eq onFunction✝ onFunction) (Eq onRelation✝ onRelation))","decl":"/-- A language homomorphism maps the symbols of one language to symbols of another. -/\nstructure LHom where\n  onFunction : ∀ ⦃n⦄, L.Functions n → L'.Functions n := by\n    exact fun {n} => isEmptyElim\n  onRelation : ∀ ⦃n⦄, L.Relations n → L'.Relations n :=by\n    exact fun {n} => isEmptyElim\n\n"}
{"name":"FirstOrder.Language.LHom.id_onFunction","module":"Mathlib.ModelTheory.LanguageMap","initialProofState":"L : FirstOrder.Language\n_n : Nat\na : L.Functions _n\n⊢ Eq ((FirstOrder.Language.LHom.id L).onFunction a) (id a)","decl":"/-- The identity language homomorphism. -/\n@[simps]\nprotected def id (L : Language) : L →ᴸ L :=\n  ⟨fun _n => id, fun _n => id⟩\n\n"}
{"name":"FirstOrder.Language.LHom.id_onRelation","module":"Mathlib.ModelTheory.LanguageMap","initialProofState":"L : FirstOrder.Language\n_n : Nat\na : L.Relations _n\n⊢ Eq ((FirstOrder.Language.LHom.id L).onRelation a) (id a)","decl":"/-- The identity language homomorphism. -/\n@[simps]\nprotected def id (L : Language) : L →ᴸ L :=\n  ⟨fun _n => id, fun _n => id⟩\n\n"}
{"name":"FirstOrder.Language.LHom.sumInl_onFunction","module":"Mathlib.ModelTheory.LanguageMap","initialProofState":"L : FirstOrder.Language\nL' : FirstOrder.Language\n_n : Nat\nval : L.Functions _n\n⊢ Eq (FirstOrder.Language.LHom.sumInl.onFunction val) (Sum.inl val)","decl":"/-- The inclusion of the left factor into the sum of two languages. -/\n@[simps]\nprotected def sumInl : L →ᴸ L.sum L' :=\n  ⟨fun _n => Sum.inl, fun _n => Sum.inl⟩\n\n"}
{"name":"FirstOrder.Language.LHom.sumInl_onRelation","module":"Mathlib.ModelTheory.LanguageMap","initialProofState":"L : FirstOrder.Language\nL' : FirstOrder.Language\n_n : Nat\nval : L.Relations _n\n⊢ Eq (FirstOrder.Language.LHom.sumInl.onRelation val) (Sum.inl val)","decl":"/-- The inclusion of the left factor into the sum of two languages. -/\n@[simps]\nprotected def sumInl : L →ᴸ L.sum L' :=\n  ⟨fun _n => Sum.inl, fun _n => Sum.inl⟩\n\n"}
{"name":"FirstOrder.Language.LHom.sumInr_onRelation","module":"Mathlib.ModelTheory.LanguageMap","initialProofState":"L : FirstOrder.Language\nL' : FirstOrder.Language\n_n : Nat\nval : L'.Relations _n\n⊢ Eq (FirstOrder.Language.LHom.sumInr.onRelation val) (Sum.inr val)","decl":"/-- The inclusion of the right factor into the sum of two languages. -/\n@[simps]\nprotected def sumInr : L' →ᴸ L.sum L' :=\n  ⟨fun _n => Sum.inr, fun _n => Sum.inr⟩\n\n"}
{"name":"FirstOrder.Language.LHom.sumInr_onFunction","module":"Mathlib.ModelTheory.LanguageMap","initialProofState":"L : FirstOrder.Language\nL' : FirstOrder.Language\n_n : Nat\nval : L'.Functions _n\n⊢ Eq (FirstOrder.Language.LHom.sumInr.onFunction val) (Sum.inr val)","decl":"/-- The inclusion of the right factor into the sum of two languages. -/\n@[simps]\nprotected def sumInr : L' →ᴸ L.sum L' :=\n  ⟨fun _n => Sum.inr, fun _n => Sum.inr⟩\n\n"}
{"name":"FirstOrder.Language.LHom.ofIsEmpty_onFunction","module":"Mathlib.ModelTheory.LanguageMap","initialProofState":"L : FirstOrder.Language\nL' : FirstOrder.Language\ninst✝¹ : L.IsAlgebraic\ninst✝ : L.IsRelational\nn : Nat\na : L.Functions n\n⊢ Eq ((FirstOrder.Language.LHom.ofIsEmpty L L').onFunction a) (isEmptyElim a)","decl":"/-- The inclusion of an empty language into any other language. -/\n@[simps]\nprotected def ofIsEmpty [L.IsAlgebraic] [L.IsRelational] : L →ᴸ L' where\n\n"}
{"name":"FirstOrder.Language.LHom.ofIsEmpty_onRelation","module":"Mathlib.ModelTheory.LanguageMap","initialProofState":"L : FirstOrder.Language\nL' : FirstOrder.Language\ninst✝¹ : L.IsAlgebraic\ninst✝ : L.IsRelational\nn : Nat\na : L.Relations n\n⊢ Eq ((FirstOrder.Language.LHom.ofIsEmpty L L').onRelation a) (isEmptyElim a)","decl":"/-- The inclusion of an empty language into any other language. -/\n@[simps]\nprotected def ofIsEmpty [L.IsAlgebraic] [L.IsRelational] : L →ᴸ L' where\n\n"}
{"name":"FirstOrder.Language.LHom.funext_iff","module":"Mathlib.ModelTheory.LanguageMap","initialProofState":"L : FirstOrder.Language\nL' : FirstOrder.Language\nF G : L.LHom L'\n⊢ Iff (Eq F G) (And (Eq F.onFunction G.onFunction) (Eq F.onRelation G.onRelation))","decl":"@[ext]\nprotected theorem funext {F G : L →ᴸ L'} (h_fun : F.onFunction = G.onFunction)\n    (h_rel : F.onRelation = G.onRelation) : F = G := by\n  cases' F with Ff Fr\n  cases' G with Gf Gr\n  simp only [mk.injEq]\n  exact And.intro h_fun h_rel\n\n"}
{"name":"FirstOrder.Language.LHom.funext","module":"Mathlib.ModelTheory.LanguageMap","initialProofState":"L : FirstOrder.Language\nL' : FirstOrder.Language\nF G : L.LHom L'\nh_fun : Eq F.onFunction G.onFunction\nh_rel : Eq F.onRelation G.onRelation\n⊢ Eq F G","decl":"@[ext]\nprotected theorem funext {F G : L →ᴸ L'} (h_fun : F.onFunction = G.onFunction)\n    (h_rel : F.onRelation = G.onRelation) : F = G := by\n  cases' F with Ff Fr\n  cases' G with Gf Gr\n  simp only [mk.injEq]\n  exact And.intro h_fun h_rel\n\n"}
{"name":"FirstOrder.Language.LHom.comp_onFunction","module":"Mathlib.ModelTheory.LanguageMap","initialProofState":"L : FirstOrder.Language\nL' : FirstOrder.Language\nL'' : FirstOrder.Language\ng : L'.LHom L''\nf : L.LHom L'\n_n : Nat\nF : L.Functions _n\n⊢ Eq ((g.comp f).onFunction F) (g.onFunction (f.onFunction F))","decl":"/-- The composition of two language homomorphisms. -/\n@[simps]\ndef comp (g : L' →ᴸ L'') (f : L →ᴸ L') : L →ᴸ L'' :=\n  ⟨fun _n F => g.1 (f.1 F), fun _ R => g.2 (f.2 R)⟩\n\n-- Porting note: added ᴸ to avoid clash with function composition\n"}
{"name":"FirstOrder.Language.LHom.comp_onRelation","module":"Mathlib.ModelTheory.LanguageMap","initialProofState":"L : FirstOrder.Language\nL' : FirstOrder.Language\nL'' : FirstOrder.Language\ng : L'.LHom L''\nf : L.LHom L'\nx✝ : Nat\nR : L.Relations x✝\n⊢ Eq ((g.comp f).onRelation R) (g.onRelation (f.onRelation R))","decl":"/-- The composition of two language homomorphisms. -/\n@[simps]\ndef comp (g : L' →ᴸ L'') (f : L →ᴸ L') : L →ᴸ L'' :=\n  ⟨fun _n F => g.1 (f.1 F), fun _ R => g.2 (f.2 R)⟩\n\n-- Porting note: added ᴸ to avoid clash with function composition\n"}
{"name":"FirstOrder.Language.LHom.id_comp","module":"Mathlib.ModelTheory.LanguageMap","initialProofState":"L : FirstOrder.Language\nL' : FirstOrder.Language\nF : L.LHom L'\n⊢ Eq ((FirstOrder.Language.LHom.id L').comp F) F","decl":"@[simp]\ntheorem id_comp (F : L →ᴸ L') : LHom.id L' ∘ᴸ F = F := by\n  cases F\n  rfl\n\n"}
{"name":"FirstOrder.Language.LHom.comp_id","module":"Mathlib.ModelTheory.LanguageMap","initialProofState":"L : FirstOrder.Language\nL' : FirstOrder.Language\nF : L.LHom L'\n⊢ Eq (F.comp (FirstOrder.Language.LHom.id L)) F","decl":"@[simp]\ntheorem comp_id (F : L →ᴸ L') : F ∘ᴸ LHom.id L = F := by\n  cases F\n  rfl\n\n"}
{"name":"FirstOrder.Language.LHom.comp_assoc","module":"Mathlib.ModelTheory.LanguageMap","initialProofState":"L : FirstOrder.Language\nL' : FirstOrder.Language\nL'' : FirstOrder.Language\nL3 : FirstOrder.Language\nF : L''.LHom L3\nG : L'.LHom L''\nH : L.LHom L'\n⊢ Eq ((F.comp G).comp H) (F.comp (G.comp H))","decl":"theorem comp_assoc {L3 : Language} (F : L'' →ᴸ L3) (G : L' →ᴸ L'') (H : L →ᴸ L') :\n    F ∘ᴸ G ∘ᴸ H = F ∘ᴸ (G ∘ᴸ H) :=\n  rfl\n\n"}
{"name":"FirstOrder.Language.LHom.sumElim_onRelation","module":"Mathlib.ModelTheory.LanguageMap","initialProofState":"L : FirstOrder.Language\nL' : FirstOrder.Language\nϕ : L.LHom L'\nL'' : FirstOrder.Language\nψ : L''.LHom L'\n_n : Nat\na✝ : Sum (L.Relations _n) (L''.Relations _n)\n⊢ Eq ((ϕ.sumElim ψ).onRelation a✝) (Sum.elim (fun f => ϕ.onRelation f) (fun f => ψ.onRelation f) a✝)","decl":"/-- A language map defined on two factors of a sum. -/\n@[simps]\nprotected def sumElim : L.sum L'' →ᴸ L' where\n  onFunction _n := Sum.elim (fun f => ϕ.onFunction f) fun f => ψ.onFunction f\n  onRelation _n := Sum.elim (fun f => ϕ.onRelation f) fun f => ψ.onRelation f\n\n"}
{"name":"FirstOrder.Language.LHom.sumElim_onFunction","module":"Mathlib.ModelTheory.LanguageMap","initialProofState":"L : FirstOrder.Language\nL' : FirstOrder.Language\nϕ : L.LHom L'\nL'' : FirstOrder.Language\nψ : L''.LHom L'\n_n : Nat\na✝ : Sum (L.Functions _n) (L''.Functions _n)\n⊢ Eq ((ϕ.sumElim ψ).onFunction a✝) (Sum.elim (fun f => ϕ.onFunction f) (fun f => ψ.onFunction f) a✝)","decl":"/-- A language map defined on two factors of a sum. -/\n@[simps]\nprotected def sumElim : L.sum L'' →ᴸ L' where\n  onFunction _n := Sum.elim (fun f => ϕ.onFunction f) fun f => ψ.onFunction f\n  onRelation _n := Sum.elim (fun f => ϕ.onRelation f) fun f => ψ.onRelation f\n\n"}
{"name":"FirstOrder.Language.LHom.sumElim_comp_inl","module":"Mathlib.ModelTheory.LanguageMap","initialProofState":"L : FirstOrder.Language\nL' : FirstOrder.Language\nϕ : L.LHom L'\nL'' : FirstOrder.Language\nψ : L''.LHom L'\n⊢ Eq ((ϕ.sumElim ψ).comp FirstOrder.Language.LHom.sumInl) ϕ","decl":"theorem sumElim_comp_inl (ψ : L'' →ᴸ L') : ϕ.sumElim ψ ∘ᴸ LHom.sumInl = ϕ :=\n  LHom.funext (funext fun _ => rfl) (funext fun _ => rfl)\n\n"}
{"name":"FirstOrder.Language.LHom.sumElim_comp_inr","module":"Mathlib.ModelTheory.LanguageMap","initialProofState":"L : FirstOrder.Language\nL' : FirstOrder.Language\nϕ : L.LHom L'\nL'' : FirstOrder.Language\nψ : L''.LHom L'\n⊢ Eq ((ϕ.sumElim ψ).comp FirstOrder.Language.LHom.sumInr) ψ","decl":"theorem sumElim_comp_inr (ψ : L'' →ᴸ L') : ϕ.sumElim ψ ∘ᴸ LHom.sumInr = ψ :=\n  LHom.funext (funext fun _ => rfl) (funext fun _ => rfl)\n\n"}
{"name":"FirstOrder.Language.LHom.sumElim_inl_inr","module":"Mathlib.ModelTheory.LanguageMap","initialProofState":"L : FirstOrder.Language\nL' : FirstOrder.Language\n⊢ Eq (FirstOrder.Language.LHom.sumInl.sumElim FirstOrder.Language.LHom.sumInr) (FirstOrder.Language.LHom.id (L.sum L'))","decl":"theorem sumElim_inl_inr : LHom.sumInl.sumElim LHom.sumInr = LHom.id (L.sum L') :=\n  LHom.funext (funext fun _ => Sum.elim_inl_inr) (funext fun _ => Sum.elim_inl_inr)\n\n"}
{"name":"FirstOrder.Language.LHom.comp_sumElim","module":"Mathlib.ModelTheory.LanguageMap","initialProofState":"L : FirstOrder.Language\nL' : FirstOrder.Language\nϕ : L.LHom L'\nL'' : FirstOrder.Language\nψ : L''.LHom L'\nL3 : FirstOrder.Language\nθ : L'.LHom L3\n⊢ Eq (θ.comp (ϕ.sumElim ψ)) ((θ.comp ϕ).sumElim (θ.comp ψ))","decl":"theorem comp_sumElim {L3 : Language} (θ : L' →ᴸ L3) :\n    θ ∘ᴸ ϕ.sumElim ψ = (θ ∘ᴸ ϕ).sumElim (θ ∘ᴸ ψ) :=\n  LHom.funext (funext fun _n => Sum.comp_elim _ _ _) (funext fun _n => Sum.comp_elim _ _ _)\n\n"}
{"name":"FirstOrder.Language.LHom.sumMap_onFunction","module":"Mathlib.ModelTheory.LanguageMap","initialProofState":"L : FirstOrder.Language\nL' : FirstOrder.Language\nϕ : L.LHom L'\nL₁ : FirstOrder.Language\nL₂ : FirstOrder.Language\nψ : L₁.LHom L₂\n_n : Nat\na✝ : Sum (L.Functions _n) (L₁.Functions _n)\n⊢ Eq ((ϕ.sumMap ψ).onFunction a✝) (Sum.map (fun f => ϕ.onFunction f) (fun f => ψ.onFunction f) a✝)","decl":"/-- The map between two sum-languages induced by maps on the two factors. -/\n@[simps]\ndef sumMap : L.sum L₁ →ᴸ L'.sum L₂ where\n  onFunction _n := Sum.map (fun f => ϕ.onFunction f) fun f => ψ.onFunction f\n  onRelation _n := Sum.map (fun f => ϕ.onRelation f) fun f => ψ.onRelation f\n\n"}
{"name":"FirstOrder.Language.LHom.sumMap_onRelation","module":"Mathlib.ModelTheory.LanguageMap","initialProofState":"L : FirstOrder.Language\nL' : FirstOrder.Language\nϕ : L.LHom L'\nL₁ : FirstOrder.Language\nL₂ : FirstOrder.Language\nψ : L₁.LHom L₂\n_n : Nat\na✝ : Sum (L.Relations _n) (L₁.Relations _n)\n⊢ Eq ((ϕ.sumMap ψ).onRelation a✝) (Sum.map (fun f => ϕ.onRelation f) (fun f => ψ.onRelation f) a✝)","decl":"/-- The map between two sum-languages induced by maps on the two factors. -/\n@[simps]\ndef sumMap : L.sum L₁ →ᴸ L'.sum L₂ where\n  onFunction _n := Sum.map (fun f => ϕ.onFunction f) fun f => ψ.onFunction f\n  onRelation _n := Sum.map (fun f => ϕ.onRelation f) fun f => ψ.onRelation f\n\n"}
{"name":"FirstOrder.Language.LHom.sumMap_comp_inl","module":"Mathlib.ModelTheory.LanguageMap","initialProofState":"L : FirstOrder.Language\nL' : FirstOrder.Language\nϕ : L.LHom L'\nL₁ : FirstOrder.Language\nL₂ : FirstOrder.Language\nψ : L₁.LHom L₂\n⊢ Eq ((ϕ.sumMap ψ).comp FirstOrder.Language.LHom.sumInl) (FirstOrder.Language.LHom.sumInl.comp ϕ)","decl":"@[simp]\ntheorem sumMap_comp_inl : ϕ.sumMap ψ ∘ᴸ LHom.sumInl = LHom.sumInl ∘ᴸ ϕ :=\n  LHom.funext (funext fun _ => rfl) (funext fun _ => rfl)\n\n"}
{"name":"FirstOrder.Language.LHom.sumMap_comp_inr","module":"Mathlib.ModelTheory.LanguageMap","initialProofState":"L : FirstOrder.Language\nL' : FirstOrder.Language\nϕ : L.LHom L'\nL₁ : FirstOrder.Language\nL₂ : FirstOrder.Language\nψ : L₁.LHom L₂\n⊢ Eq ((ϕ.sumMap ψ).comp FirstOrder.Language.LHom.sumInr) (FirstOrder.Language.LHom.sumInr.comp ψ)","decl":"@[simp]\ntheorem sumMap_comp_inr : ϕ.sumMap ψ ∘ᴸ LHom.sumInr = LHom.sumInr ∘ᴸ ψ :=\n  LHom.funext (funext fun _ => rfl) (funext fun _ => rfl)\n\n"}
{"name":"FirstOrder.Language.LHom.Injective.onFunction","module":"Mathlib.ModelTheory.LanguageMap","initialProofState":"L : FirstOrder.Language\nL' : FirstOrder.Language\nϕ : L.LHom L'\nself : ϕ.Injective\nn : Nat\n⊢ Function.Injective fun f => ϕ.onFunction f","decl":"/-- A language homomorphism is injective when all the maps between symbol types are. -/\nprotected structure Injective : Prop where\n  onFunction {n} : Function.Injective fun f : L.Functions n => onFunction ϕ f\n  onRelation {n} : Function.Injective fun R : L.Relations n => onRelation ϕ R\n\n"}
{"name":"FirstOrder.Language.LHom.Injective.onRelation","module":"Mathlib.ModelTheory.LanguageMap","initialProofState":"L : FirstOrder.Language\nL' : FirstOrder.Language\nϕ : L.LHom L'\nself : ϕ.Injective\nn : Nat\n⊢ Function.Injective fun R => ϕ.onRelation R","decl":"/-- A language homomorphism is injective when all the maps between symbol types are. -/\nprotected structure Injective : Prop where\n  onFunction {n} : Function.Injective fun f : L.Functions n => onFunction ϕ f\n  onRelation {n} : Function.Injective fun R : L.Relations n => onRelation ϕ R\n\n"}
{"name":"FirstOrder.Language.LHom.IsExpansionOn.map_onRelation","module":"Mathlib.ModelTheory.LanguageMap","initialProofState":"L : FirstOrder.Language\nL' : FirstOrder.Language\nϕ : L.LHom L'\nM : Type u_1\ninst✝¹ : L.Structure M\ninst✝ : L'.Structure M\nself : ϕ.IsExpansionOn M\nn : Nat\nR : L.Relations n\nx : Fin n → M\n⊢ Eq (FirstOrder.Language.Structure.RelMap (ϕ.onRelation R) x) (FirstOrder.Language.Structure.RelMap R x)","decl":"/-- A language homomorphism is an expansion on a structure if it commutes with the interpretation of\nall symbols on that structure. -/\nclass IsExpansionOn (M : Type*) [L.Structure M] [L'.Structure M] : Prop where\n  map_onFunction :\n    ∀ {n} (f : L.Functions n) (x : Fin n → M), funMap (ϕ.onFunction f) x = funMap f x := by\n      exact fun {n} => isEmptyElim\n  map_onRelation :\n    ∀ {n} (R : L.Relations n) (x : Fin n → M), RelMap (ϕ.onRelation R) x = RelMap R x := by\n      exact fun {n} => isEmptyElim\n\n"}
{"name":"FirstOrder.Language.LHom.IsExpansionOn.map_onFunction","module":"Mathlib.ModelTheory.LanguageMap","initialProofState":"L : FirstOrder.Language\nL' : FirstOrder.Language\nϕ : L.LHom L'\nM : Type u_1\ninst✝¹ : L.Structure M\ninst✝ : L'.Structure M\nself : ϕ.IsExpansionOn M\nn : Nat\nf : L.Functions n\nx : Fin n → M\n⊢ Eq (FirstOrder.Language.Structure.funMap (ϕ.onFunction f) x) (FirstOrder.Language.Structure.funMap f x)","decl":"/-- A language homomorphism is an expansion on a structure if it commutes with the interpretation of\nall symbols on that structure. -/\nclass IsExpansionOn (M : Type*) [L.Structure M] [L'.Structure M] : Prop where\n  map_onFunction :\n    ∀ {n} (f : L.Functions n) (x : Fin n → M), funMap (ϕ.onFunction f) x = funMap f x := by\n      exact fun {n} => isEmptyElim\n  map_onRelation :\n    ∀ {n} (R : L.Relations n) (x : Fin n → M), RelMap (ϕ.onRelation R) x = RelMap R x := by\n      exact fun {n} => isEmptyElim\n\n"}
{"name":"FirstOrder.Language.LHom.map_onFunction","module":"Mathlib.ModelTheory.LanguageMap","initialProofState":"L : FirstOrder.Language\nL' : FirstOrder.Language\nϕ : L.LHom L'\nM : Type u_1\ninst✝² : L.Structure M\ninst✝¹ : L'.Structure M\ninst✝ : ϕ.IsExpansionOn M\nn : Nat\nf : L.Functions n\nx : Fin n → M\n⊢ Eq (FirstOrder.Language.Structure.funMap (ϕ.onFunction f) x) (FirstOrder.Language.Structure.funMap f x)","decl":"@[simp]\ntheorem map_onFunction {M : Type*} [L.Structure M] [L'.Structure M] [ϕ.IsExpansionOn M] {n}\n    (f : L.Functions n) (x : Fin n → M) : funMap (ϕ.onFunction f) x = funMap f x :=\n  IsExpansionOn.map_onFunction f x\n\n"}
{"name":"FirstOrder.Language.LHom.map_onRelation","module":"Mathlib.ModelTheory.LanguageMap","initialProofState":"L : FirstOrder.Language\nL' : FirstOrder.Language\nϕ : L.LHom L'\nM : Type u_1\ninst✝² : L.Structure M\ninst✝¹ : L'.Structure M\ninst✝ : ϕ.IsExpansionOn M\nn : Nat\nR : L.Relations n\nx : Fin n → M\n⊢ Eq (FirstOrder.Language.Structure.RelMap (ϕ.onRelation R) x) (FirstOrder.Language.Structure.RelMap R x)","decl":"@[simp]\ntheorem map_onRelation {M : Type*} [L.Structure M] [L'.Structure M] [ϕ.IsExpansionOn M] {n}\n    (R : L.Relations n) (x : Fin n → M) : RelMap (ϕ.onRelation R) x = RelMap R x :=\n  IsExpansionOn.map_onRelation R x\n\n"}
{"name":"FirstOrder.Language.LHom.id_isExpansionOn","module":"Mathlib.ModelTheory.LanguageMap","initialProofState":"L : FirstOrder.Language\nM : Type u_1\ninst✝ : L.Structure M\n⊢ (FirstOrder.Language.LHom.id L).IsExpansionOn M","decl":"instance id_isExpansionOn (M : Type*) [L.Structure M] : IsExpansionOn (LHom.id L) M :=\n  ⟨fun _ _ => rfl, fun _ _ => rfl⟩\n\n"}
{"name":"FirstOrder.Language.LHom.ofIsEmpty_isExpansionOn","module":"Mathlib.ModelTheory.LanguageMap","initialProofState":"L : FirstOrder.Language\nL' : FirstOrder.Language\nM : Type u_1\ninst✝³ : L.Structure M\ninst✝² : L'.Structure M\ninst✝¹ : L.IsAlgebraic\ninst✝ : L.IsRelational\n⊢ (FirstOrder.Language.LHom.ofIsEmpty L L').IsExpansionOn M","decl":"instance ofIsEmpty_isExpansionOn (M : Type*) [L.Structure M] [L'.Structure M] [L.IsAlgebraic]\n    [L.IsRelational] : IsExpansionOn (LHom.ofIsEmpty L L') M where\n\n"}
{"name":"FirstOrder.Language.LHom.sumElim_isExpansionOn","module":"Mathlib.ModelTheory.LanguageMap","initialProofState":"L : FirstOrder.Language\nL' : FirstOrder.Language\nϕ : L.LHom L'\nL'' : FirstOrder.Language\nψ : L''.LHom L'\nM : Type u_1\ninst✝⁴ : L.Structure M\ninst✝³ : L'.Structure M\ninst✝² : L''.Structure M\ninst✝¹ : ϕ.IsExpansionOn M\ninst✝ : ψ.IsExpansionOn M\n⊢ (ϕ.sumElim ψ).IsExpansionOn M","decl":"instance sumElim_isExpansionOn {L'' : Language} (ψ : L'' →ᴸ L') (M : Type*) [L.Structure M]\n    [L'.Structure M] [L''.Structure M] [ϕ.IsExpansionOn M] [ψ.IsExpansionOn M] :\n    (ϕ.sumElim ψ).IsExpansionOn M :=\n  ⟨fun f _ => Sum.casesOn f (by simp) (by simp), fun R _ => Sum.casesOn R (by simp) (by simp)⟩\n\n"}
{"name":"FirstOrder.Language.LHom.sumMap_isExpansionOn","module":"Mathlib.ModelTheory.LanguageMap","initialProofState":"L : FirstOrder.Language\nL' : FirstOrder.Language\nϕ : L.LHom L'\nL₁ : FirstOrder.Language\nL₂ : FirstOrder.Language\nψ : L₁.LHom L₂\nM : Type u_1\ninst✝⁵ : L.Structure M\ninst✝⁴ : L'.Structure M\ninst✝³ : L₁.Structure M\ninst✝² : L₂.Structure M\ninst✝¹ : ϕ.IsExpansionOn M\ninst✝ : ψ.IsExpansionOn M\n⊢ (ϕ.sumMap ψ).IsExpansionOn M","decl":"instance sumMap_isExpansionOn {L₁ L₂ : Language} (ψ : L₁ →ᴸ L₂) (M : Type*) [L.Structure M]\n    [L'.Structure M] [L₁.Structure M] [L₂.Structure M] [ϕ.IsExpansionOn M] [ψ.IsExpansionOn M] :\n    (ϕ.sumMap ψ).IsExpansionOn M :=\n  ⟨fun f _ => Sum.casesOn f (by simp) (by simp), fun R _ => Sum.casesOn R (by simp) (by simp)⟩\n\n"}
{"name":"FirstOrder.Language.LHom.sumInl_isExpansionOn","module":"Mathlib.ModelTheory.LanguageMap","initialProofState":"L : FirstOrder.Language\nL' : FirstOrder.Language\nM : Type u_1\ninst✝¹ : L.Structure M\ninst✝ : L'.Structure M\n⊢ FirstOrder.Language.LHom.sumInl.IsExpansionOn M","decl":"instance sumInl_isExpansionOn (M : Type*) [L.Structure M] [L'.Structure M] :\n    (LHom.sumInl : L →ᴸ L.sum L').IsExpansionOn M :=\n  ⟨fun _f _ => rfl, fun _R _ => rfl⟩\n\n"}
{"name":"FirstOrder.Language.LHom.sumInr_isExpansionOn","module":"Mathlib.ModelTheory.LanguageMap","initialProofState":"L : FirstOrder.Language\nL' : FirstOrder.Language\nM : Type u_1\ninst✝¹ : L.Structure M\ninst✝ : L'.Structure M\n⊢ FirstOrder.Language.LHom.sumInr.IsExpansionOn M","decl":"instance sumInr_isExpansionOn (M : Type*) [L.Structure M] [L'.Structure M] :\n    (LHom.sumInr : L' →ᴸ L.sum L').IsExpansionOn M :=\n  ⟨fun _f _ => rfl, fun _R _ => rfl⟩\n\n"}
{"name":"FirstOrder.Language.LHom.funMap_sumInl","module":"Mathlib.ModelTheory.LanguageMap","initialProofState":"L : FirstOrder.Language\nL' : FirstOrder.Language\nM : Type w\ninst✝² : L.Structure M\ninst✝¹ : (L.sum L').Structure M\ninst✝ : FirstOrder.Language.LHom.sumInl.IsExpansionOn M\nn : Nat\nf : L.Functions n\nx : Fin n → M\n⊢ Eq (FirstOrder.Language.Structure.funMap (Sum.inl f) x) (FirstOrder.Language.Structure.funMap f x)","decl":"@[simp]\ntheorem funMap_sumInl [(L.sum L').Structure M] [(LHom.sumInl : L →ᴸ L.sum L').IsExpansionOn M] {n}\n    {f : L.Functions n} {x : Fin n → M} : @funMap (L.sum L') M _ n (Sum.inl f) x = funMap f x :=\n  (LHom.sumInl : L →ᴸ L.sum L').map_onFunction f x\n\n"}
{"name":"FirstOrder.Language.LHom.funMap_sumInr","module":"Mathlib.ModelTheory.LanguageMap","initialProofState":"L : FirstOrder.Language\nL' : FirstOrder.Language\nM : Type w\ninst✝² : L.Structure M\ninst✝¹ : (L'.sum L).Structure M\ninst✝ : FirstOrder.Language.LHom.sumInr.IsExpansionOn M\nn : Nat\nf : L.Functions n\nx : Fin n → M\n⊢ Eq (FirstOrder.Language.Structure.funMap (Sum.inr f) x) (FirstOrder.Language.Structure.funMap f x)","decl":"@[simp]\ntheorem funMap_sumInr [(L'.sum L).Structure M] [(LHom.sumInr : L →ᴸ L'.sum L).IsExpansionOn M] {n}\n    {f : L.Functions n} {x : Fin n → M} : @funMap (L'.sum L) M _ n (Sum.inr f) x = funMap f x :=\n  (LHom.sumInr : L →ᴸ L'.sum L).map_onFunction f x\n\n"}
{"name":"FirstOrder.Language.LHom.sumInl_injective","module":"Mathlib.ModelTheory.LanguageMap","initialProofState":"L : FirstOrder.Language\nL' : FirstOrder.Language\n⊢ FirstOrder.Language.LHom.sumInl.Injective","decl":"theorem sumInl_injective : (LHom.sumInl : L →ᴸ L.sum L').Injective :=\n  ⟨fun h => Sum.inl_injective h, fun h => Sum.inl_injective h⟩\n\n"}
{"name":"FirstOrder.Language.LHom.sumInr_injective","module":"Mathlib.ModelTheory.LanguageMap","initialProofState":"L : FirstOrder.Language\nL' : FirstOrder.Language\n⊢ FirstOrder.Language.LHom.sumInr.Injective","decl":"theorem sumInr_injective : (LHom.sumInr : L' →ᴸ L.sum L').Injective :=\n  ⟨fun h => Sum.inr_injective h, fun h => Sum.inr_injective h⟩\n\n"}
{"name":"FirstOrder.Language.LHom.isExpansionOn_reduct","module":"Mathlib.ModelTheory.LanguageMap","initialProofState":"L : FirstOrder.Language\nL' : FirstOrder.Language\nϕ : L.LHom L'\nM : Type u_1\ninst✝ : L'.Structure M\n⊢ ϕ.IsExpansionOn M","decl":"instance (priority := 100) isExpansionOn_reduct (ϕ : L →ᴸ L') (M : Type*) [L'.Structure M] :\n    @IsExpansionOn L L' ϕ M (ϕ.reduct M) _ :=\n  letI := ϕ.reduct M\n  ⟨fun _f _ => rfl, fun _R _ => rfl⟩\n\n"}
{"name":"FirstOrder.Language.LHom.Injective.isExpansionOn_default","module":"Mathlib.ModelTheory.LanguageMap","initialProofState":"L : FirstOrder.Language\nL' : FirstOrder.Language\nϕ : L.LHom L'\ninst✝³ : (n : Nat) → (f : L'.Functions n) → Decidable (Membership.mem (Set.range fun f => ϕ.onFunction f) f)\ninst✝² : (n : Nat) → (r : L'.Relations n) → Decidable (Membership.mem (Set.range fun r => ϕ.onRelation r) r)\nh : ϕ.Injective\nM : Type u_1\ninst✝¹ : Inhabited M\ninst✝ : L.Structure M\n⊢ ϕ.IsExpansionOn M","decl":"theorem Injective.isExpansionOn_default {ϕ : L →ᴸ L'}\n    [∀ (n) (f : L'.Functions n), Decidable (f ∈ Set.range fun f : L.Functions n => ϕ.onFunction f)]\n    [∀ (n) (r : L'.Relations n), Decidable (r ∈ Set.range fun r : L.Relations n => ϕ.onRelation r)]\n    (h : ϕ.Injective) (M : Type*) [Inhabited M] [L.Structure M] :\n    @IsExpansionOn L L' ϕ M _ (ϕ.defaultExpansion M) := by\n  letI := ϕ.defaultExpansion M\n  refine ⟨fun {n} f xs => ?_, fun {n} r xs => ?_⟩\n  · have hf : ϕ.onFunction f ∈ Set.range fun f : L.Functions n => ϕ.onFunction f := ⟨f, rfl⟩\n    refine (dif_pos hf).trans ?_\n    rw [h.onFunction hf.choose_spec]\n  · have hr : ϕ.onRelation r ∈ Set.range fun r : L.Relations n => ϕ.onRelation r := ⟨r, rfl⟩\n    refine (dif_pos hr).trans ?_\n    rw [h.onRelation hr.choose_spec]\n\n"}
{"name":"FirstOrder.Language.LEquiv.mk.injEq","module":"Mathlib.ModelTheory.LanguageMap","initialProofState":"L : FirstOrder.Language\nL' : FirstOrder.Language\ntoLHom✝ : L.LHom L'\ninvLHom✝ : L'.LHom L\nleft_inv✝ : Eq (invLHom✝.comp toLHom✝) (FirstOrder.Language.LHom.id L)\nright_inv✝ : Eq (toLHom✝.comp invLHom✝) (FirstOrder.Language.LHom.id L')\ntoLHom : L.LHom L'\ninvLHom : L'.LHom L\nleft_inv : Eq (invLHom.comp toLHom) (FirstOrder.Language.LHom.id L)\nright_inv : Eq (toLHom.comp invLHom) (FirstOrder.Language.LHom.id L')\n⊢ Eq (Eq { toLHom := toLHom✝, invLHom := invLHom✝, left_inv := left_inv✝, right_inv := right_inv✝ } { toLHom := toLHom, invLHom := invLHom, left_inv := left_inv, right_inv := right_inv }) (And (Eq toLHom✝ toLHom) (Eq invLHom✝ invLHom))","decl":"/-- A language equivalence maps the symbols of one language to symbols of another bijectively. -/\nstructure LEquiv (L L' : Language) where\n  toLHom : L →ᴸ L'\n  invLHom : L' →ᴸ L\n  left_inv : invLHom.comp toLHom = LHom.id L\n  right_inv : toLHom.comp invLHom = LHom.id L'\n\n"}
{"name":"FirstOrder.Language.LEquiv.right_inv","module":"Mathlib.ModelTheory.LanguageMap","initialProofState":"L : FirstOrder.Language\nL' : FirstOrder.Language\nself : L.LEquiv L'\n⊢ Eq (self.toLHom.comp self.invLHom) (FirstOrder.Language.LHom.id L')","decl":"/-- A language equivalence maps the symbols of one language to symbols of another bijectively. -/\nstructure LEquiv (L L' : Language) where\n  toLHom : L →ᴸ L'\n  invLHom : L' →ᴸ L\n  left_inv : invLHom.comp toLHom = LHom.id L\n  right_inv : toLHom.comp invLHom = LHom.id L'\n\n"}
{"name":"FirstOrder.Language.LEquiv.mk.inj","module":"Mathlib.ModelTheory.LanguageMap","initialProofState":"L : FirstOrder.Language\nL' : FirstOrder.Language\ntoLHom✝ : L.LHom L'\ninvLHom✝ : L'.LHom L\nleft_inv✝ : Eq (invLHom✝.comp toLHom✝) (FirstOrder.Language.LHom.id L)\nright_inv✝ : Eq (toLHom✝.comp invLHom✝) (FirstOrder.Language.LHom.id L')\ntoLHom : L.LHom L'\ninvLHom : L'.LHom L\nleft_inv : Eq (invLHom.comp toLHom) (FirstOrder.Language.LHom.id L)\nright_inv : Eq (toLHom.comp invLHom) (FirstOrder.Language.LHom.id L')\nx✝ : Eq { toLHom := toLHom✝, invLHom := invLHom✝, left_inv := left_inv✝, right_inv := right_inv✝ } { toLHom := toLHom, invLHom := invLHom, left_inv := left_inv, right_inv := right_inv }\n⊢ And (Eq toLHom✝ toLHom) (Eq invLHom✝ invLHom)","decl":"/-- A language equivalence maps the symbols of one language to symbols of another bijectively. -/\nstructure LEquiv (L L' : Language) where\n  toLHom : L →ᴸ L'\n  invLHom : L' →ᴸ L\n  left_inv : invLHom.comp toLHom = LHom.id L\n  right_inv : toLHom.comp invLHom = LHom.id L'\n\n"}
{"name":"FirstOrder.Language.LEquiv.mk.sizeOf_spec","module":"Mathlib.ModelTheory.LanguageMap","initialProofState":"L : FirstOrder.Language\nL' : FirstOrder.Language\ntoLHom : L.LHom L'\ninvLHom : L'.LHom L\nleft_inv : Eq (invLHom.comp toLHom) (FirstOrder.Language.LHom.id L)\nright_inv : Eq (toLHom.comp invLHom) (FirstOrder.Language.LHom.id L')\n⊢ Eq (SizeOf.sizeOf { toLHom := toLHom, invLHom := invLHom, left_inv := left_inv, right_inv := right_inv }) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf toLHom)) (SizeOf.sizeOf invLHom)) (SizeOf.sizeOf left_inv)) (SizeOf.sizeOf right_inv))","decl":"/-- A language equivalence maps the symbols of one language to symbols of another bijectively. -/\nstructure LEquiv (L L' : Language) where\n  toLHom : L →ᴸ L'\n  invLHom : L' →ᴸ L\n  left_inv : invLHom.comp toLHom = LHom.id L\n  right_inv : toLHom.comp invLHom = LHom.id L'\n\n"}
{"name":"FirstOrder.Language.LEquiv.left_inv","module":"Mathlib.ModelTheory.LanguageMap","initialProofState":"L : FirstOrder.Language\nL' : FirstOrder.Language\nself : L.LEquiv L'\n⊢ Eq (self.invLHom.comp self.toLHom) (FirstOrder.Language.LHom.id L)","decl":"/-- A language equivalence maps the symbols of one language to symbols of another bijectively. -/\nstructure LEquiv (L L' : Language) where\n  toLHom : L →ᴸ L'\n  invLHom : L' →ᴸ L\n  left_inv : invLHom.comp toLHom = LHom.id L\n  right_inv : toLHom.comp invLHom = LHom.id L'\n\n"}
{"name":"FirstOrder.Language.LEquiv.refl_invLHom","module":"Mathlib.ModelTheory.LanguageMap","initialProofState":"L : FirstOrder.Language\n⊢ Eq (FirstOrder.Language.LEquiv.refl L).invLHom (FirstOrder.Language.LHom.id L)","decl":"/-- The identity equivalence from a first-order language to itself. -/\n@[simps]\nprotected def refl : L ≃ᴸ L :=\n  ⟨LHom.id L, LHom.id L, LHom.comp_id _, LHom.comp_id _⟩\n\n"}
{"name":"FirstOrder.Language.LEquiv.refl_toLHom","module":"Mathlib.ModelTheory.LanguageMap","initialProofState":"L : FirstOrder.Language\n⊢ Eq (FirstOrder.Language.LEquiv.refl L).toLHom (FirstOrder.Language.LHom.id L)","decl":"/-- The identity equivalence from a first-order language to itself. -/\n@[simps]\nprotected def refl : L ≃ᴸ L :=\n  ⟨LHom.id L, LHom.id L, LHom.comp_id _, LHom.comp_id _⟩\n\n"}
{"name":"FirstOrder.Language.LEquiv.symm_invLHom","module":"Mathlib.ModelTheory.LanguageMap","initialProofState":"L : FirstOrder.Language\nL' : FirstOrder.Language\ne : L.LEquiv L'\n⊢ Eq e.symm.invLHom e.toLHom","decl":"/-- The inverse of an equivalence of first-order languages. -/\n@[simps]\nprotected def symm : L' ≃ᴸ L :=\n  ⟨e.invLHom, e.toLHom, e.right_inv, e.left_inv⟩\n\n"}
{"name":"FirstOrder.Language.LEquiv.symm_toLHom","module":"Mathlib.ModelTheory.LanguageMap","initialProofState":"L : FirstOrder.Language\nL' : FirstOrder.Language\ne : L.LEquiv L'\n⊢ Eq e.symm.toLHom e.invLHom","decl":"/-- The inverse of an equivalence of first-order languages. -/\n@[simps]\nprotected def symm : L' ≃ᴸ L :=\n  ⟨e.invLHom, e.toLHom, e.right_inv, e.left_inv⟩\n\n"}
{"name":"FirstOrder.Language.LEquiv.trans_invLHom","module":"Mathlib.ModelTheory.LanguageMap","initialProofState":"L : FirstOrder.Language\nL' : FirstOrder.Language\nL'' : FirstOrder.Language\ne : L.LEquiv L'\ne' : L'.LEquiv L''\n⊢ Eq (e.trans e').invLHom (e.invLHom.comp e'.invLHom)","decl":"/-- The composition of equivalences of first-order languages. -/\n@[simps, trans]\nprotected def trans (e : L ≃ᴸ L') (e' : L' ≃ᴸ L'') : L ≃ᴸ L'' :=\n  ⟨e'.toLHom.comp e.toLHom, e.invLHom.comp e'.invLHom, by\n    rw [LHom.comp_assoc, ← LHom.comp_assoc e'.invLHom, e'.left_inv, LHom.id_comp, e.left_inv], by\n    rw [LHom.comp_assoc, ← LHom.comp_assoc e.toLHom, e.right_inv, LHom.id_comp, e'.right_inv]⟩\n\n"}
{"name":"FirstOrder.Language.LEquiv.trans_toLHom","module":"Mathlib.ModelTheory.LanguageMap","initialProofState":"L : FirstOrder.Language\nL' : FirstOrder.Language\nL'' : FirstOrder.Language\ne : L.LEquiv L'\ne' : L'.LEquiv L''\n⊢ Eq (e.trans e').toLHom (e'.toLHom.comp e.toLHom)","decl":"/-- The composition of equivalences of first-order languages. -/\n@[simps, trans]\nprotected def trans (e : L ≃ᴸ L') (e' : L' ≃ᴸ L'') : L ≃ᴸ L'' :=\n  ⟨e'.toLHom.comp e.toLHom, e.invLHom.comp e'.invLHom, by\n    rw [LHom.comp_assoc, ← LHom.comp_assoc e'.invLHom, e'.left_inv, LHom.id_comp, e.left_inv], by\n    rw [LHom.comp_assoc, ← LHom.comp_assoc e.toLHom, e.right_inv, LHom.id_comp, e'.right_inv]⟩\n\n"}
{"name":"FirstOrder.Language.constantsOn_Relations","module":"Mathlib.ModelTheory.LanguageMap","initialProofState":"α : Type u'\nx✝ : Nat\n⊢ Eq ((FirstOrder.Language.constantsOn α).Relations x✝) Empty","decl":"/-- A language with constants indexed by a type. -/\n@[simps]\ndef constantsOn : Language.{u', 0} := ⟨constantsOnFunc α, fun _ => Empty⟩\n\n"}
{"name":"FirstOrder.Language.constantsOn_Functions","module":"Mathlib.ModelTheory.LanguageMap","initialProofState":"α : Type u'\na✝ : Nat\n⊢ Eq ((FirstOrder.Language.constantsOn α).Functions a✝) (FirstOrder.Language.constantsOnFunc α a✝)","decl":"/-- A language with constants indexed by a type. -/\n@[simps]\ndef constantsOn : Language.{u', 0} := ⟨constantsOnFunc α, fun _ => Empty⟩\n\n"}
{"name":"FirstOrder.Language.constantsOn_constants","module":"Mathlib.ModelTheory.LanguageMap","initialProofState":"α : Type u'\n⊢ Eq (FirstOrder.Language.constantsOn α).Constants α","decl":"theorem constantsOn_constants : (constantsOn α).Constants = α :=\n  rfl\n\n"}
{"name":"FirstOrder.Language.isAlgebraic_constantsOn","module":"Mathlib.ModelTheory.LanguageMap","initialProofState":"α : Type u'\n⊢ (FirstOrder.Language.constantsOn α).IsAlgebraic","decl":"instance isAlgebraic_constantsOn : IsAlgebraic (constantsOn α) := by\n  unfold constantsOn\n  infer_instance\n\n"}
{"name":"FirstOrder.Language.isEmpty_functions_constantsOn_succ","module":"Mathlib.ModelTheory.LanguageMap","initialProofState":"α : Type u'\nn : Nat\n⊢ IsEmpty ((FirstOrder.Language.constantsOn α).Functions (HAdd.hAdd n 1))","decl":"instance isEmpty_functions_constantsOn_succ {n : ℕ} : IsEmpty ((constantsOn α).Functions (n + 1)) :=\n  inferInstanceAs (IsEmpty PEmpty)\n\n"}
{"name":"FirstOrder.Language.isRelational_constantsOn","module":"Mathlib.ModelTheory.LanguageMap","initialProofState":"α : Type u'\n_ie : IsEmpty α\n⊢ (FirstOrder.Language.constantsOn α).IsRelational","decl":"instance isRelational_constantsOn [_ie : IsEmpty α] : IsRelational (constantsOn α) :=\n  fun n => Nat.casesOn n _ie inferInstance\n\n"}
{"name":"FirstOrder.Language.card_constantsOn","module":"Mathlib.ModelTheory.LanguageMap","initialProofState":"α : Type u'\n⊢ Eq (FirstOrder.Language.constantsOn α).card (Cardinal.mk α)","decl":"theorem card_constantsOn : (constantsOn α).card = #α := by\n  simp [card_eq_card_functions_add_card_relations, sum_nat_eq_add_sum_succ]\n\n"}
{"name":"FirstOrder.Language.constantsOnMap_isExpansionOn","module":"Mathlib.ModelTheory.LanguageMap","initialProofState":"M : Type w\nα : Type u'\nβ : Type v'\nf : α → β\nfα : α → M\nfβ : β → M\nh : Eq (Function.comp fβ f) fα\n⊢ (FirstOrder.Language.LHom.constantsOnMap f).IsExpansionOn M","decl":"theorem constantsOnMap_isExpansionOn {f : α → β} {fα : α → M} {fβ : β → M} (h : fβ ∘ f = fα) :\n    @LHom.IsExpansionOn _ _ (LHom.constantsOnMap f) M (constantsOn.structure fα)\n      (constantsOn.structure fβ) := by\n  letI := constantsOn.structure fα\n  letI := constantsOn.structure fβ\n  exact\n    ⟨fun {n} => Nat.casesOn n (fun F _x => (congr_fun h F :)) fun n F => isEmptyElim F, fun R =>\n      isEmptyElim R⟩\n\n"}
{"name":"FirstOrder.Language.card_withConstants","module":"Mathlib.ModelTheory.LanguageMap","initialProofState":"L : FirstOrder.Language\nα : Type w'\n⊢ Eq (L.withConstants α).card (HAdd.hAdd (Cardinal.lift.{w', max u v} L.card) (Cardinal.lift.{max u v, w'} (Cardinal.mk α)))","decl":"@[simp]\ntheorem card_withConstants :\n    L[[α]].card = Cardinal.lift.{w'} L.card + Cardinal.lift.{max u v} #α := by\n  rw [withConstants, card_sum, card_constantsOn]\n\n"}
{"name":"FirstOrder.Language.lhomWithConstants_onFunction","module":"Mathlib.ModelTheory.LanguageMap","initialProofState":"L : FirstOrder.Language\nα : Type w'\n_n : Nat\nval : L.Functions _n\n⊢ Eq ((L.lhomWithConstants α).onFunction val) (Sum.inl val)","decl":"/-- The language map adding constants. -/\n@[simps!]\ndef lhomWithConstants : L →ᴸ L[[α]] :=\n  LHom.sumInl\n\n"}
{"name":"FirstOrder.Language.lhomWithConstants_onRelation","module":"Mathlib.ModelTheory.LanguageMap","initialProofState":"L : FirstOrder.Language\nα : Type w'\n_n : Nat\nval : L.Relations _n\n⊢ Eq ((L.lhomWithConstants α).onRelation val) (Sum.inl val)","decl":"/-- The language map adding constants. -/\n@[simps!]\ndef lhomWithConstants : L →ᴸ L[[α]] :=\n  LHom.sumInl\n\n"}
{"name":"FirstOrder.Language.lhomWithConstants_injective","module":"Mathlib.ModelTheory.LanguageMap","initialProofState":"L : FirstOrder.Language\nα : Type w'\n⊢ (L.lhomWithConstants α).Injective","decl":"theorem lhomWithConstants_injective : (L.lhomWithConstants α).Injective :=\n  LHom.sumInl_injective\n\n"}
{"name":"FirstOrder.Language.LEquiv.addEmptyConstants_toLHom","module":"Mathlib.ModelTheory.LanguageMap","initialProofState":"L : FirstOrder.Language\nα : Type w'\nie : IsEmpty α\n⊢ Eq (FirstOrder.Language.LEquiv.addEmptyConstants L α).toLHom (L.lhomWithConstants α)","decl":"/-- The language map removing an empty constant set. -/\n@[simps]\ndef LEquiv.addEmptyConstants [ie : IsEmpty α] : L ≃ᴸ L[[α]] where\n  toLHom := lhomWithConstants L α\n  invLHom := LHom.sumElim (LHom.id L) (LHom.ofIsEmpty (constantsOn α) L)\n  left_inv := by rw [lhomWithConstants, LHom.sumElim_comp_inl]\n  right_inv := by\n    simp only [LHom.comp_sumElim, lhomWithConstants, LHom.comp_id]\n    exact _root_.trans (congr rfl (Subsingleton.elim _ _)) LHom.sumElim_inl_inr\n\n"}
{"name":"FirstOrder.Language.LEquiv.addEmptyConstants_invLHom","module":"Mathlib.ModelTheory.LanguageMap","initialProofState":"L : FirstOrder.Language\nα : Type w'\nie : IsEmpty α\n⊢ Eq (FirstOrder.Language.LEquiv.addEmptyConstants L α).invLHom ((FirstOrder.Language.LHom.id L).sumElim (FirstOrder.Language.LHom.ofIsEmpty (FirstOrder.Language.constantsOn α) L))","decl":"/-- The language map removing an empty constant set. -/\n@[simps]\ndef LEquiv.addEmptyConstants [ie : IsEmpty α] : L ≃ᴸ L[[α]] where\n  toLHom := lhomWithConstants L α\n  invLHom := LHom.sumElim (LHom.id L) (LHom.ofIsEmpty (constantsOn α) L)\n  left_inv := by rw [lhomWithConstants, LHom.sumElim_comp_inl]\n  right_inv := by\n    simp only [LHom.comp_sumElim, lhomWithConstants, LHom.comp_id]\n    exact _root_.trans (congr rfl (Subsingleton.elim _ _)) LHom.sumElim_inl_inr\n\n"}
{"name":"FirstOrder.Language.withConstants_funMap_sum_inl","module":"Mathlib.ModelTheory.LanguageMap","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝² : L.Structure M\nα : Type w'\ninst✝¹ : (L.withConstants α).Structure M\ninst✝ : (L.lhomWithConstants α).IsExpansionOn M\nn : Nat\nf : L.Functions n\nx : Fin n → M\n⊢ Eq (FirstOrder.Language.Structure.funMap (Sum.inl f) x) (FirstOrder.Language.Structure.funMap f x)","decl":"@[simp]\ntheorem withConstants_funMap_sum_inl [L[[α]].Structure M] [(lhomWithConstants L α).IsExpansionOn M]\n    {n} {f : L.Functions n} {x : Fin n → M} : @funMap (L[[α]]) M _ n (Sum.inl f) x = funMap f x :=\n  (lhomWithConstants L α).map_onFunction f x\n\n"}
{"name":"FirstOrder.Language.withConstants_relMap_sum_inl","module":"Mathlib.ModelTheory.LanguageMap","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝² : L.Structure M\nα : Type w'\ninst✝¹ : (L.withConstants α).Structure M\ninst✝ : (L.lhomWithConstants α).IsExpansionOn M\nn : Nat\nR : L.Relations n\nx : Fin n → M\n⊢ Eq (FirstOrder.Language.Structure.RelMap (Sum.inl R) x) (FirstOrder.Language.Structure.RelMap R x)","decl":"@[simp]\ntheorem withConstants_relMap_sum_inl [L[[α]].Structure M] [(lhomWithConstants L α).IsExpansionOn M]\n    {n} {R : L.Relations n} {x : Fin n → M} : @RelMap (L[[α]]) M _ n (Sum.inl R) x = RelMap R x :=\n  (lhomWithConstants L α).map_onRelation R x\n\n"}
{"name":"FirstOrder.Language.LHom.map_constants_comp_sumInl","module":"Mathlib.ModelTheory.LanguageMap","initialProofState":"L : FirstOrder.Language\nα : Type w'\nβ : Type u_1\nf : α → β\n⊢ Eq ((L.lhomWithConstantsMap f).comp FirstOrder.Language.LHom.sumInl) (L.lhomWithConstants β)","decl":"@[simp]\ntheorem LHom.map_constants_comp_sumInl {f : α → β} :\n    (L.lhomWithConstantsMap f).comp LHom.sumInl = L.lhomWithConstants β := by ext <;> rfl\n\n"}
{"name":"FirstOrder.Language.withConstants_self_expansion","module":"Mathlib.ModelTheory.LanguageMap","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\n⊢ (L.lhomWithConstants M).IsExpansionOn M","decl":"instance withConstants_self_expansion : (lhomWithConstants L M).IsExpansionOn M :=\n  ⟨fun _ _ => rfl, fun _ _ => rfl⟩\n\n"}
{"name":"FirstOrder.Language.withConstants_expansion","module":"Mathlib.ModelTheory.LanguageMap","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝¹ : L.Structure M\nα : Type u_1\ninst✝ : (FirstOrder.Language.constantsOn α).Structure M\n⊢ (L.lhomWithConstants α).IsExpansionOn M","decl":"instance withConstants_expansion : (L.lhomWithConstants α).IsExpansionOn M :=\n  ⟨fun _ _ => rfl, fun _ _ => rfl⟩\n\n"}
{"name":"FirstOrder.Language.addEmptyConstants_is_expansion_on'","module":"Mathlib.ModelTheory.LanguageMap","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\n⊢ (FirstOrder.Language.LEquiv.addEmptyConstants L ↑EmptyCollection.emptyCollection).toLHom.IsExpansionOn M","decl":"instance addEmptyConstants_is_expansion_on' :\n    (LEquiv.addEmptyConstants L (∅ : Set M)).toLHom.IsExpansionOn M :=\n  L.withConstants_expansion _\n\n"}
{"name":"FirstOrder.Language.addEmptyConstants_symm_isExpansionOn","module":"Mathlib.ModelTheory.LanguageMap","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\n⊢ (FirstOrder.Language.LEquiv.addEmptyConstants L ↑EmptyCollection.emptyCollection).symm.toLHom.IsExpansionOn M","decl":"instance addEmptyConstants_symm_isExpansionOn :\n    (LEquiv.addEmptyConstants L (∅ : Set M)).symm.toLHom.IsExpansionOn M :=\n  LHom.sumElim_isExpansionOn _ _ _\n\n"}
{"name":"FirstOrder.Language.addConstants_expansion","module":"Mathlib.ModelTheory.LanguageMap","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝³ : L.Structure M\nα : Type u_1\ninst✝² : (FirstOrder.Language.constantsOn α).Structure M\nL' : FirstOrder.Language\ninst✝¹ : L'.Structure M\nφ : L.LHom L'\ninst✝ : φ.IsExpansionOn M\n⊢ (FirstOrder.Language.LHom.addConstants α φ).IsExpansionOn M","decl":"instance addConstants_expansion {L' : Language} [L'.Structure M] (φ : L →ᴸ L') [φ.IsExpansionOn M] :\n    (φ.addConstants α).IsExpansionOn M :=\n  LHom.sumMap_isExpansionOn _ _ M\n\n"}
{"name":"FirstOrder.Language.withConstants_funMap_sum_inr","module":"Mathlib.ModelTheory.LanguageMap","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝¹ : L.Structure M\nα : Type u_1\ninst✝ : (FirstOrder.Language.constantsOn α).Structure M\na : α\nx : Fin 0 → M\n⊢ Eq (FirstOrder.Language.Structure.funMap (Sum.inr a) x) ↑(L.con a)","decl":"@[simp]\ntheorem withConstants_funMap_sum_inr {a : α} {x : Fin 0 → M} :\n    @funMap (L[[α]]) M _ 0 (Sum.inr a : L[[α]].Functions 0) x = L.con a := by\n  rw [Unique.eq_default x]\n  exact (LHom.sumInr : constantsOn α →ᴸ L.sum _).map_onFunction _ _\n\n"}
{"name":"FirstOrder.Language.coe_con","module":"Mathlib.ModelTheory.LanguageMap","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\nA : Set M\na : ↑A\n⊢ Eq ↑(L.con a) ↑a","decl":"@[simp]\ntheorem coe_con {a : A} : (L.con a : M) = a :=\n  rfl\n\n"}
{"name":"FirstOrder.Language.constantsOnMap_inclusion_isExpansionOn","module":"Mathlib.ModelTheory.LanguageMap","initialProofState":"M : Type w\nA B : Set M\nh : HasSubset.Subset A B\n⊢ (FirstOrder.Language.LHom.constantsOnMap (Set.inclusion h)).IsExpansionOn M","decl":"instance constantsOnMap_inclusion_isExpansionOn :\n    (LHom.constantsOnMap (Set.inclusion h)).IsExpansionOn M :=\n  constantsOnMap_isExpansionOn rfl\n\n"}
{"name":"FirstOrder.Language.map_constants_inclusion_isExpansionOn","module":"Mathlib.ModelTheory.LanguageMap","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\nA B : Set M\nh : HasSubset.Subset A B\n⊢ (L.lhomWithConstantsMap (Set.inclusion h)).IsExpansionOn M","decl":"instance map_constants_inclusion_isExpansionOn :\n    (L.lhomWithConstantsMap (Set.inclusion h)).IsExpansionOn M :=\n  LHom.sumMap_isExpansionOn _ _ _\n\n"}
