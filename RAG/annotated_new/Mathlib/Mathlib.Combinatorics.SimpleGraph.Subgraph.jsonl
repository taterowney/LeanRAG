{"name":"SimpleGraph.Subgraph.adj_sub","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nself : G.Subgraph\nv w : V\na✝ : self.Adj v w\n⊢ G.Adj v w","decl":"/-- A subgraph of a `SimpleGraph` is a subset of vertices along with a restriction of the adjacency\nrelation that is symmetric and is supported by the vertex subset.  They also form a bounded lattice.\n\nThinking of `V → V → Prop` as `Set (V × V)`, a set of darts (i.e., half-edges), then\n`Subgraph.adj_sub` is that the darts of a subgraph are a subset of the darts of `G`. -/\n@[ext]\nstructure Subgraph {V : Type u} (G : SimpleGraph V) where\n  verts : Set V\n  Adj : V → V → Prop\n  adj_sub : ∀ {v w : V}, Adj v w → G.Adj v w\n  edge_vert : ∀ {v w : V}, Adj v w → v ∈ verts\n  symm : Symmetric Adj := by aesop_graph -- Porting note: Originally `by obviously`\n\n"}
{"name":"SimpleGraph.Subgraph.ext","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nx y : G.Subgraph\nverts : Eq x.verts y.verts\nAdj : Eq x.Adj y.Adj\n⊢ Eq x y","decl":"/-- A subgraph of a `SimpleGraph` is a subset of vertices along with a restriction of the adjacency\nrelation that is symmetric and is supported by the vertex subset.  They also form a bounded lattice.\n\nThinking of `V → V → Prop` as `Set (V × V)`, a set of darts (i.e., half-edges), then\n`Subgraph.adj_sub` is that the darts of a subgraph are a subset of the darts of `G`. -/\n@[ext]\nstructure Subgraph {V : Type u} (G : SimpleGraph V) where\n  verts : Set V\n  Adj : V → V → Prop\n  adj_sub : ∀ {v w : V}, Adj v w → G.Adj v w\n  edge_vert : ∀ {v w : V}, Adj v w → v ∈ verts\n  symm : Symmetric Adj := by aesop_graph -- Porting note: Originally `by obviously`\n\n"}
{"name":"SimpleGraph.Subgraph.mk.inj","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nverts✝ : Set V\nAdj✝ : V → V → Prop\nadj_sub✝ : ∀ {v w : V}, Adj✝ v w → G.Adj v w\nedge_vert✝ : ∀ {v w : V}, Adj✝ v w → Membership.mem verts✝ v\nsymm✝ : autoParam (Symmetric Adj✝) _auto✝\nverts : Set V\nAdj : V → V → Prop\nadj_sub : ∀ {v w : V}, Adj v w → G.Adj v w\nedge_vert : ∀ {v w : V}, Adj v w → Membership.mem verts v\nsymm : autoParam (Symmetric Adj) _auto✝\nx✝ : Eq { verts := verts✝, Adj := Adj✝, adj_sub := adj_sub✝, edge_vert := edge_vert✝, symm := symm✝ } { verts := verts, Adj := Adj, adj_sub := adj_sub, edge_vert := edge_vert, symm := symm }\n⊢ And (Eq verts✝ verts) (Eq Adj✝ Adj)","decl":"/-- A subgraph of a `SimpleGraph` is a subset of vertices along with a restriction of the adjacency\nrelation that is symmetric and is supported by the vertex subset.  They also form a bounded lattice.\n\nThinking of `V → V → Prop` as `Set (V × V)`, a set of darts (i.e., half-edges), then\n`Subgraph.adj_sub` is that the darts of a subgraph are a subset of the darts of `G`. -/\n@[ext]\nstructure Subgraph {V : Type u} (G : SimpleGraph V) where\n  verts : Set V\n  Adj : V → V → Prop\n  adj_sub : ∀ {v w : V}, Adj v w → G.Adj v w\n  edge_vert : ∀ {v w : V}, Adj v w → v ∈ verts\n  symm : Symmetric Adj := by aesop_graph -- Porting note: Originally `by obviously`\n\n"}
{"name":"SimpleGraph.Subgraph.ext_iff","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nx y : G.Subgraph\n⊢ Iff (Eq x y) (And (Eq x.verts y.verts) (Eq x.Adj y.Adj))","decl":"/-- A subgraph of a `SimpleGraph` is a subset of vertices along with a restriction of the adjacency\nrelation that is symmetric and is supported by the vertex subset.  They also form a bounded lattice.\n\nThinking of `V → V → Prop` as `Set (V × V)`, a set of darts (i.e., half-edges), then\n`Subgraph.adj_sub` is that the darts of a subgraph are a subset of the darts of `G`. -/\n@[ext]\nstructure Subgraph {V : Type u} (G : SimpleGraph V) where\n  verts : Set V\n  Adj : V → V → Prop\n  adj_sub : ∀ {v w : V}, Adj v w → G.Adj v w\n  edge_vert : ∀ {v w : V}, Adj v w → v ∈ verts\n  symm : Symmetric Adj := by aesop_graph -- Porting note: Originally `by obviously`\n\n"}
{"name":"SimpleGraph.Subgraph.edge_vert","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nself : G.Subgraph\nv w : V\na✝ : self.Adj v w\n⊢ Membership.mem self.verts v","decl":"/-- A subgraph of a `SimpleGraph` is a subset of vertices along with a restriction of the adjacency\nrelation that is symmetric and is supported by the vertex subset.  They also form a bounded lattice.\n\nThinking of `V → V → Prop` as `Set (V × V)`, a set of darts (i.e., half-edges), then\n`Subgraph.adj_sub` is that the darts of a subgraph are a subset of the darts of `G`. -/\n@[ext]\nstructure Subgraph {V : Type u} (G : SimpleGraph V) where\n  verts : Set V\n  Adj : V → V → Prop\n  adj_sub : ∀ {v w : V}, Adj v w → G.Adj v w\n  edge_vert : ∀ {v w : V}, Adj v w → v ∈ verts\n  symm : Symmetric Adj := by aesop_graph -- Porting note: Originally `by obviously`\n\n"}
{"name":"SimpleGraph.Subgraph.mk.sizeOf_spec","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\ninst✝ : SizeOf V\nverts : Set V\nAdj : V → V → Prop\nadj_sub : ∀ {v w : V}, Adj v w → G.Adj v w\nedge_vert : ∀ {v w : V}, Adj v w → Membership.mem verts v\nsymm : autoParam (Symmetric Adj) _auto✝\n⊢ Eq (SizeOf.sizeOf { verts := verts, Adj := Adj, adj_sub := adj_sub, edge_vert := edge_vert, symm := symm }) 1","decl":"/-- A subgraph of a `SimpleGraph` is a subset of vertices along with a restriction of the adjacency\nrelation that is symmetric and is supported by the vertex subset.  They also form a bounded lattice.\n\nThinking of `V → V → Prop` as `Set (V × V)`, a set of darts (i.e., half-edges), then\n`Subgraph.adj_sub` is that the darts of a subgraph are a subset of the darts of `G`. -/\n@[ext]\nstructure Subgraph {V : Type u} (G : SimpleGraph V) where\n  verts : Set V\n  Adj : V → V → Prop\n  adj_sub : ∀ {v w : V}, Adj v w → G.Adj v w\n  edge_vert : ∀ {v w : V}, Adj v w → v ∈ verts\n  symm : Symmetric Adj := by aesop_graph -- Porting note: Originally `by obviously`\n\n"}
{"name":"SimpleGraph.Subgraph.mk.injEq","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nverts✝ : Set V\nAdj✝ : V → V → Prop\nadj_sub✝ : ∀ {v w : V}, Adj✝ v w → G.Adj v w\nedge_vert✝ : ∀ {v w : V}, Adj✝ v w → Membership.mem verts✝ v\nsymm✝ : autoParam (Symmetric Adj✝) _auto✝\nverts : Set V\nAdj : V → V → Prop\nadj_sub : ∀ {v w : V}, Adj v w → G.Adj v w\nedge_vert : ∀ {v w : V}, Adj v w → Membership.mem verts v\nsymm : autoParam (Symmetric Adj) _auto✝\n⊢ Eq (Eq { verts := verts✝, Adj := Adj✝, adj_sub := adj_sub✝, edge_vert := edge_vert✝, symm := symm✝ } { verts := verts, Adj := Adj, adj_sub := adj_sub, edge_vert := edge_vert, symm := symm }) (And (Eq verts✝ verts) (Eq Adj✝ Adj))","decl":"/-- A subgraph of a `SimpleGraph` is a subset of vertices along with a restriction of the adjacency\nrelation that is symmetric and is supported by the vertex subset.  They also form a bounded lattice.\n\nThinking of `V → V → Prop` as `Set (V × V)`, a set of darts (i.e., half-edges), then\n`Subgraph.adj_sub` is that the darts of a subgraph are a subset of the darts of `G`. -/\n@[ext]\nstructure Subgraph {V : Type u} (G : SimpleGraph V) where\n  verts : Set V\n  Adj : V → V → Prop\n  adj_sub : ∀ {v w : V}, Adj v w → G.Adj v w\n  edge_vert : ∀ {v w : V}, Adj v w → v ∈ verts\n  symm : Symmetric Adj := by aesop_graph -- Porting note: Originally `by obviously`\n\n"}
{"name":"SimpleGraph.Subgraph.symm","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nself : G.Subgraph\n⊢ Symmetric self.Adj","decl":"/-- A subgraph of a `SimpleGraph` is a subset of vertices along with a restriction of the adjacency\nrelation that is symmetric and is supported by the vertex subset.  They also form a bounded lattice.\n\nThinking of `V → V → Prop` as `Set (V × V)`, a set of darts (i.e., half-edges), then\n`Subgraph.adj_sub` is that the darts of a subgraph are a subset of the darts of `G`. -/\n@[ext]\nstructure Subgraph {V : Type u} (G : SimpleGraph V) where\n  verts : Set V\n  Adj : V → V → Prop\n  adj_sub : ∀ {v w : V}, Adj v w → G.Adj v w\n  edge_vert : ∀ {v w : V}, Adj v w → v ∈ verts\n  symm : Symmetric Adj := by aesop_graph -- Porting note: Originally `by obviously`\n\n"}
{"name":"SimpleGraph.singletonSubgraph_adj","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nv a✝¹ a✝ : V\n⊢ Eq ((G.singletonSubgraph v).Adj a✝¹ a✝) (Bot.bot a✝¹ a✝)","decl":"/-- The one-vertex subgraph. -/\n@[simps]\nprotected def singletonSubgraph (G : SimpleGraph V) (v : V) : G.Subgraph where\n  verts := {v}\n  Adj := ⊥\n  adj_sub := False.elim\n  edge_vert := False.elim\n  symm _ _ := False.elim\n\n"}
{"name":"SimpleGraph.singletonSubgraph_verts","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nv : V\n⊢ Eq (G.singletonSubgraph v).verts (Singleton.singleton v)","decl":"/-- The one-vertex subgraph. -/\n@[simps]\nprotected def singletonSubgraph (G : SimpleGraph V) (v : V) : G.Subgraph where\n  verts := {v}\n  Adj := ⊥\n  adj_sub := False.elim\n  edge_vert := False.elim\n  symm _ _ := False.elim\n\n"}
{"name":"SimpleGraph.subgraphOfAdj_adj","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nv w : V\nhvw : G.Adj v w\na b : V\n⊢ Eq ((G.subgraphOfAdj hvw).Adj a b) (Eq (Sym2.mk { fst := v, snd := w }) (Sym2.mk { fst := a, snd := b }))","decl":"/-- The one-edge subgraph. -/\n@[simps]\ndef subgraphOfAdj (G : SimpleGraph V) {v w : V} (hvw : G.Adj v w) : G.Subgraph where\n  verts := {v, w}\n  Adj a b := s(v, w) = s(a, b)\n  adj_sub h := by\n    rw [← G.mem_edgeSet, ← h]\n    exact hvw\n  edge_vert {a b} h := by\n    apply_fun fun e ↦ a ∈ e at h\n    simp only [Sym2.mem_iff, true_or, eq_iff_iff, iff_true] at h\n    exact h\n\n"}
{"name":"SimpleGraph.subgraphOfAdj_verts","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nv w : V\nhvw : G.Adj v w\n⊢ Eq (G.subgraphOfAdj hvw).verts (Insert.insert v (Singleton.singleton w))","decl":"/-- The one-edge subgraph. -/\n@[simps]\ndef subgraphOfAdj (G : SimpleGraph V) {v w : V} (hvw : G.Adj v w) : G.Subgraph where\n  verts := {v, w}\n  Adj a b := s(v, w) = s(a, b)\n  adj_sub h := by\n    rw [← G.mem_edgeSet, ← h]\n    exact hvw\n  edge_vert {a b} h := by\n    apply_fun fun e ↦ a ∈ e at h\n    simp only [Sym2.mem_iff, true_or, eq_iff_iff, iff_true] at h\n    exact h\n\n"}
{"name":"SimpleGraph.Subgraph.loopless","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nG' : G.Subgraph\n⊢ Irreflexive G'.Adj","decl":"protected theorem loopless (G' : Subgraph G) : Irreflexive G'.Adj :=\n  fun v h ↦ G.loopless v (G'.adj_sub h)\n\n"}
{"name":"SimpleGraph.Subgraph.adj_comm","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nG' : G.Subgraph\nv w : V\n⊢ Iff (G'.Adj v w) (G'.Adj w v)","decl":"theorem adj_comm (G' : Subgraph G) (v w : V) : G'.Adj v w ↔ G'.Adj w v :=\n  ⟨fun x ↦ G'.symm x, fun x ↦ G'.symm x⟩\n\n"}
{"name":"SimpleGraph.Subgraph.adj_symm","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nG' : G.Subgraph\nu v : V\nh : G'.Adj u v\n⊢ G'.Adj v u","decl":"@[symm]\ntheorem adj_symm (G' : Subgraph G) {u v : V} (h : G'.Adj u v) : G'.Adj v u :=\n  G'.symm h\n\n"}
{"name":"SimpleGraph.Subgraph.Adj.symm","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nG' : G.Subgraph\nu v : V\nh : G'.Adj u v\n⊢ G'.Adj v u","decl":"protected theorem Adj.symm {G' : Subgraph G} {u v : V} (h : G'.Adj u v) : G'.Adj v u :=\n  G'.symm h\n\n"}
{"name":"SimpleGraph.Subgraph.Adj.adj_sub","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nH : G.Subgraph\nu v : V\nh : H.Adj u v\n⊢ G.Adj u v","decl":"protected theorem Adj.adj_sub {H : G.Subgraph} {u v : V} (h : H.Adj u v) : G.Adj u v :=\n  H.adj_sub h\n\n"}
{"name":"SimpleGraph.Subgraph.Adj.fst_mem","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nH : G.Subgraph\nu v : V\nh : H.Adj u v\n⊢ Membership.mem H.verts u","decl":"protected theorem Adj.fst_mem {H : G.Subgraph} {u v : V} (h : H.Adj u v) : u ∈ H.verts :=\n  H.edge_vert h\n\n"}
{"name":"SimpleGraph.Subgraph.Adj.snd_mem","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nH : G.Subgraph\nu v : V\nh : H.Adj u v\n⊢ Membership.mem H.verts v","decl":"protected theorem Adj.snd_mem {H : G.Subgraph} {u v : V} (h : H.Adj u v) : v ∈ H.verts :=\n  h.symm.fst_mem\n\n"}
{"name":"SimpleGraph.Subgraph.Adj.ne","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nH : G.Subgraph\nu v : V\nh : H.Adj u v\n⊢ Ne u v","decl":"protected theorem Adj.ne {H : G.Subgraph} {u v : V} (h : H.Adj u v) : u ≠ v :=\n  h.adj_sub.ne\n\n"}
{"name":"SimpleGraph.Subgraph.adj_congr_of_sym2","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nH : G.Subgraph\nu v w x : V\nh2 : Eq (Sym2.mk { fst := u, snd := v }) (Sym2.mk { fst := w, snd := x })\n⊢ Iff (H.Adj u v) (H.Adj w x)","decl":"theorem adj_congr_of_sym2 {H : G.Subgraph} {u v w x : V} (h2 : s(u, v) = s(w, x)) :\n    H.Adj u v ↔ H.Adj w x := by\n  simp only [Sym2.eq, Sym2.rel_iff', Prod.mk.injEq, Prod.swap_prod_mk] at h2\n  cases' h2 with hl hr\n  · rw [hl.1, hl.2]\n  · rw [hr.1, hr.2, Subgraph.adj_comm]\n\n"}
{"name":"SimpleGraph.Subgraph.coe_adj","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nG' : G.Subgraph\nv w : ↑G'.verts\n⊢ Eq (G'.coe.Adj v w) (G'.Adj ↑v ↑w)","decl":"/-- Coercion from `G' : Subgraph G` to a `SimpleGraph G'.verts`. -/\n@[simps]\nprotected def coe (G' : Subgraph G) : SimpleGraph G'.verts where\n  Adj v w := G'.Adj v w\n  symm _ _ h := G'.symm h\n  loopless v h := loopless G v (G'.adj_sub h)\n\n"}
{"name":"SimpleGraph.Subgraph.coe_adj_sub","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nG' : G.Subgraph\nu v : ↑G'.verts\nh : G'.coe.Adj u v\n⊢ G.Adj ↑u ↑v","decl":"@[simp]\ntheorem coe_adj_sub (G' : Subgraph G) (u v : G'.verts) (h : G'.coe.Adj u v) : G.Adj u v :=\n  G'.adj_sub h\n\n-- Given `h : H.Adj u v`, then `h.coe : H.coe.Adj ⟨u, _⟩ ⟨v, _⟩`.\n"}
{"name":"SimpleGraph.Subgraph.Adj.coe","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nH : G.Subgraph\nu v : V\nh : H.Adj u v\n⊢ H.coe.Adj ⟨u, ⋯⟩ ⟨v, ⋯⟩","decl":"protected theorem Adj.coe {H : G.Subgraph} {u v : V} (h : H.Adj u v) :\n    H.coe.Adj ⟨u, H.edge_vert h⟩ ⟨v, H.edge_vert h.symm⟩ := h\n\n"}
{"name":"SimpleGraph.Subgraph.isSpanning_iff","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nG' : G.Subgraph\n⊢ Iff G'.IsSpanning (Eq G'.verts Set.univ)","decl":"theorem isSpanning_iff {G' : Subgraph G} : G'.IsSpanning ↔ G'.verts = Set.univ :=\n  Set.eq_univ_iff_forall.symm\n\n"}
{"name":"SimpleGraph.Subgraph.IsSpanning.verts_eq_univ","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nG' : G.Subgraph\na✝ : G'.IsSpanning\n⊢ Eq G'.verts Set.univ","decl":"protected alias ⟨IsSpanning.verts_eq_univ, _⟩ := isSpanning_iff\n\n"}
{"name":"SimpleGraph.Subgraph.spanningCoe_adj","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nG' : G.Subgraph\na✝¹ a✝ : V\n⊢ Eq (G'.spanningCoe.Adj a✝¹ a✝) (G'.Adj a✝¹ a✝)","decl":"/-- Coercion from `Subgraph G` to `SimpleGraph V`.  If `G'` is a spanning\nsubgraph, then `G'.spanningCoe` yields an isomorphic graph.\nIn general, this adds in all vertices from `V` as isolated vertices. -/\n@[simps]\nprotected def spanningCoe (G' : Subgraph G) : SimpleGraph V where\n  Adj := G'.Adj\n  symm := G'.symm\n  loopless v hv := G.loopless v (G'.adj_sub hv)\n\n"}
{"name":"SimpleGraph.Subgraph.Adj.of_spanningCoe","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nG' : G.Subgraph\nu v : ↑G'.verts\nh : G'.spanningCoe.Adj ↑u ↑v\n⊢ G.Adj ↑u ↑v","decl":"@[simp]\ntheorem Adj.of_spanningCoe {G' : Subgraph G} {u v : G'.verts} (h : G'.spanningCoe.Adj u v) :\n    G.Adj u v :=\n  G'.adj_sub h\n\n"}
{"name":"SimpleGraph.Subgraph.spanningCoe_le","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nG' : G.Subgraph\n⊢ LE.le G'.spanningCoe G","decl":"lemma spanningCoe_le (G' : G.Subgraph) : G'.spanningCoe ≤ G := fun _ _ ↦ G'.3\n\n"}
{"name":"SimpleGraph.Subgraph.spanningCoe_inj","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nG₁ G₂ : G.Subgraph\n⊢ Iff (Eq G₁.spanningCoe G₂.spanningCoe) (Eq G₁.Adj G₂.Adj)","decl":"theorem spanningCoe_inj : G₁.spanningCoe = G₂.spanningCoe ↔ G₁.Adj = G₂.Adj := by\n  simp [Subgraph.spanningCoe]\n\n"}
{"name":"SimpleGraph.Subgraph.mem_of_adj_spanningCoe","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nv w : V\ns : Set V\nG : SimpleGraph ↑s\nhadj : G.spanningCoe.Adj v w\n⊢ Membership.mem s v","decl":"lemma mem_of_adj_spanningCoe {v w : V} {s : Set V} (G : SimpleGraph s)\n    (hadj : G.spanningCoe.Adj v w) : v ∈ s := by aesop\n\n"}
{"name":"SimpleGraph.Subgraph.spanningCoeEquivCoeOfSpanning_symm_apply","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nG' : G.Subgraph\nh : G'.IsSpanning\nv : ↑G'.verts\n⊢ Eq ((RelIso.symm (G'.spanningCoeEquivCoeOfSpanning h)) v) ↑v","decl":"/-- `spanningCoe` is equivalent to `coe` for a subgraph that `IsSpanning`. -/\n@[simps]\ndef spanningCoeEquivCoeOfSpanning (G' : Subgraph G) (h : G'.IsSpanning) :\n    G'.spanningCoe ≃g G'.coe where\n  toFun v := ⟨v, h v⟩\n  invFun v := v\n  left_inv _ := rfl\n  right_inv _ := rfl\n  map_rel_iff' := Iff.rfl\n\n"}
{"name":"SimpleGraph.Subgraph.spanningCoeEquivCoeOfSpanning_apply_coe","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nG' : G.Subgraph\nh : G'.IsSpanning\nv : V\n⊢ Eq (↑((G'.spanningCoeEquivCoeOfSpanning h) v)) v","decl":"/-- `spanningCoe` is equivalent to `coe` for a subgraph that `IsSpanning`. -/\n@[simps]\ndef spanningCoeEquivCoeOfSpanning (G' : Subgraph G) (h : G'.IsSpanning) :\n    G'.spanningCoe ≃g G'.coe where\n  toFun v := ⟨v, h v⟩\n  invFun v := v\n  left_inv _ := rfl\n  right_inv _ := rfl\n  map_rel_iff' := Iff.rfl\n\n"}
{"name":"SimpleGraph.Subgraph.mem_support","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nH : G.Subgraph\nv : V\n⊢ Iff (Membership.mem H.support v) (Exists fun w => H.Adj v w)","decl":"theorem mem_support (H : Subgraph G) {v : V} : v ∈ H.support ↔ ∃ w, H.Adj v w := Iff.rfl\n\n"}
{"name":"SimpleGraph.Subgraph.support_subset_verts","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nH : G.Subgraph\n⊢ HasSubset.Subset H.support H.verts","decl":"theorem support_subset_verts (H : Subgraph G) : H.support ⊆ H.verts :=\n  fun _ ⟨_, h⟩ ↦ H.edge_vert h\n\n"}
{"name":"SimpleGraph.Subgraph.neighborSet_subset","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nG' : G.Subgraph\nv : V\n⊢ HasSubset.Subset (G'.neighborSet v) (G.neighborSet v)","decl":"theorem neighborSet_subset (G' : Subgraph G) (v : V) : G'.neighborSet v ⊆ G.neighborSet v :=\n  fun _ ↦ G'.adj_sub\n\n"}
{"name":"SimpleGraph.Subgraph.neighborSet_subset_verts","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nG' : G.Subgraph\nv : V\n⊢ HasSubset.Subset (G'.neighborSet v) G'.verts","decl":"theorem neighborSet_subset_verts (G' : Subgraph G) (v : V) : G'.neighborSet v ⊆ G'.verts :=\n  fun _ h ↦ G'.edge_vert (adj_symm G' h)\n\n"}
{"name":"SimpleGraph.Subgraph.mem_neighborSet","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nG' : G.Subgraph\nv w : V\n⊢ Iff (Membership.mem (G'.neighborSet v) w) (G'.Adj v w)","decl":"@[simp]\ntheorem mem_neighborSet (G' : Subgraph G) (v w : V) : w ∈ G'.neighborSet v ↔ G'.Adj v w := Iff.rfl\n\n"}
{"name":"SimpleGraph.Subgraph.edgeSet_subset","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nG' : G.Subgraph\n⊢ HasSubset.Subset G'.edgeSet G.edgeSet","decl":"theorem edgeSet_subset (G' : Subgraph G) : G'.edgeSet ⊆ G.edgeSet :=\n  Sym2.ind (fun _ _ ↦ G'.adj_sub)\n\n"}
{"name":"SimpleGraph.Subgraph.mem_edgeSet","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nG' : G.Subgraph\nv w : V\n⊢ Iff (Membership.mem G'.edgeSet (Sym2.mk { fst := v, snd := w })) (G'.Adj v w)","decl":"@[simp]\nprotected lemma mem_edgeSet {G' : Subgraph G} {v w : V} : s(v, w) ∈ G'.edgeSet ↔ G'.Adj v w := .rfl\n\n"}
{"name":"SimpleGraph.Subgraph.edgeSet_coe","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nG' : G.Subgraph\n⊢ Eq G'.coe.edgeSet (Set.preimage (Sym2.map Subtype.val) G'.edgeSet)","decl":"@[simp] lemma edgeSet_coe {G' : G.Subgraph} : G'.coe.edgeSet = Sym2.map (↑) ⁻¹' G'.edgeSet := by\n  ext e; induction' e using Sym2.ind with a b; simp\n\n"}
{"name":"SimpleGraph.Subgraph.image_coe_edgeSet_coe","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nG' : G.Subgraph\n⊢ Eq (Set.image (Sym2.map Subtype.val) G'.coe.edgeSet) G'.edgeSet","decl":"lemma image_coe_edgeSet_coe (G' : G.Subgraph) : Sym2.map (↑) '' G'.coe.edgeSet = G'.edgeSet := by\n  rw [edgeSet_coe, Set.image_preimage_eq_iff]\n  rintro e he\n  induction' e using Sym2.ind with a b\n  rw [Subgraph.mem_edgeSet] at he\n  exact ⟨s(⟨a, edge_vert _ he⟩, ⟨b, edge_vert _ he.symm⟩), Sym2.map_pair_eq ..⟩\n\n"}
{"name":"SimpleGraph.Subgraph.mem_verts_of_mem_edge","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nG' : G.Subgraph\ne : Sym2 V\nv : V\nhe : Membership.mem G'.edgeSet e\nhv : Membership.mem e v\n⊢ Membership.mem G'.verts v","decl":"theorem mem_verts_of_mem_edge {G' : Subgraph G} {e : Sym2 V} {v : V} (he : e ∈ G'.edgeSet)\n    (hv : v ∈ e) : v ∈ G'.verts := by\n  induction e\n  rcases Sym2.mem_iff.mp hv with (rfl | rfl)\n  · exact G'.edge_vert he\n  · exact G'.edge_vert (G'.symm he)\n\n"}
{"name":"SimpleGraph.Subgraph.mem_verts_if_mem_edge","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nG' : G.Subgraph\ne : Sym2 V\nv : V\nhe : Membership.mem G'.edgeSet e\nhv : Membership.mem e v\n⊢ Membership.mem G'.verts v","decl":"@[deprecated (since := \"2024-10-01\")] alias mem_verts_if_mem_edge := mem_verts_of_mem_edge\n\n"}
{"name":"SimpleGraph.Subgraph.incidenceSet_subset_incidenceSet","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nG' : G.Subgraph\nv : V\n⊢ HasSubset.Subset (G'.incidenceSet v) (G.incidenceSet v)","decl":"theorem incidenceSet_subset_incidenceSet (G' : Subgraph G) (v : V) :\n    G'.incidenceSet v ⊆ G.incidenceSet v :=\n  fun _ h ↦ ⟨G'.edgeSet_subset h.1, h.2⟩\n\n"}
{"name":"SimpleGraph.Subgraph.incidenceSet_subset","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nG' : G.Subgraph\nv : V\n⊢ HasSubset.Subset (G'.incidenceSet v) G'.edgeSet","decl":"theorem incidenceSet_subset (G' : Subgraph G) (v : V) : G'.incidenceSet v ⊆ G'.edgeSet :=\n  fun _ h ↦ h.1\n\n"}
{"name":"SimpleGraph.Subgraph.copy_eq","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nG' : G.Subgraph\nV'' : Set V\nhV : Eq V'' G'.verts\nadj' : V → V → Prop\nhadj : Eq adj' G'.Adj\n⊢ Eq (G'.copy V'' hV adj' hadj) G'","decl":"theorem copy_eq (G' : Subgraph G) (V'' : Set V) (hV : V'' = G'.verts)\n    (adj' : V → V → Prop) (hadj : adj' = G'.Adj) : G'.copy V'' hV adj' hadj = G' :=\n  Subgraph.ext hV hadj\n\n"}
{"name":"SimpleGraph.Subgraph.sup_adj","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nG₁ G₂ : G.Subgraph\na b : V\n⊢ Iff ((Max.max G₁ G₂).Adj a b) (Or (G₁.Adj a b) (G₂.Adj a b))","decl":"@[simp]\ntheorem sup_adj : (G₁ ⊔ G₂).Adj a b ↔ G₁.Adj a b ∨ G₂.Adj a b :=\n  Iff.rfl\n\n"}
{"name":"SimpleGraph.Subgraph.inf_adj","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nG₁ G₂ : G.Subgraph\na b : V\n⊢ Iff ((Min.min G₁ G₂).Adj a b) (And (G₁.Adj a b) (G₂.Adj a b))","decl":"@[simp]\ntheorem inf_adj : (G₁ ⊓ G₂).Adj a b ↔ G₁.Adj a b ∧ G₂.Adj a b :=\n  Iff.rfl\n\n"}
{"name":"SimpleGraph.Subgraph.top_adj","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\na b : V\n⊢ Iff (Top.top.Adj a b) (G.Adj a b)","decl":"@[simp]\ntheorem top_adj : (⊤ : Subgraph G).Adj a b ↔ G.Adj a b :=\n  Iff.rfl\n\n"}
{"name":"SimpleGraph.Subgraph.not_bot_adj","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\na b : V\n⊢ Not (Bot.bot.Adj a b)","decl":"@[simp]\ntheorem not_bot_adj : ¬ (⊥ : Subgraph G).Adj a b :=\n  not_false\n\n"}
{"name":"SimpleGraph.Subgraph.verts_sup","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nG₁ G₂ : G.Subgraph\n⊢ Eq (Max.max G₁ G₂).verts (Union.union G₁.verts G₂.verts)","decl":"@[simp]\ntheorem verts_sup (G₁ G₂ : G.Subgraph) : (G₁ ⊔ G₂).verts = G₁.verts ∪ G₂.verts :=\n  rfl\n\n"}
{"name":"SimpleGraph.Subgraph.verts_inf","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nG₁ G₂ : G.Subgraph\n⊢ Eq (Min.min G₁ G₂).verts (Inter.inter G₁.verts G₂.verts)","decl":"@[simp]\ntheorem verts_inf (G₁ G₂ : G.Subgraph) : (G₁ ⊓ G₂).verts = G₁.verts ∩ G₂.verts :=\n  rfl\n\n"}
{"name":"SimpleGraph.Subgraph.verts_top","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\n⊢ Eq Top.top.verts Set.univ","decl":"@[simp]\ntheorem verts_top : (⊤ : G.Subgraph).verts = Set.univ :=\n  rfl\n\n"}
{"name":"SimpleGraph.Subgraph.verts_bot","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\n⊢ Eq Bot.bot.verts EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem verts_bot : (⊥ : G.Subgraph).verts = ∅ :=\n  rfl\n\n"}
{"name":"SimpleGraph.Subgraph.sSup_adj","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\na b : V\ns : Set G.Subgraph\n⊢ Iff ((SupSet.sSup s).Adj a b) (Exists fun G_1 => And (Membership.mem s G_1) (G_1.Adj a b))","decl":"@[simp]\ntheorem sSup_adj {s : Set G.Subgraph} : (sSup s).Adj a b ↔ ∃ G ∈ s, Adj G a b :=\n  Iff.rfl\n\n"}
{"name":"SimpleGraph.Subgraph.sInf_adj","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\na b : V\ns : Set G.Subgraph\n⊢ Iff ((InfSet.sInf s).Adj a b) (And (∀ (G' : G.Subgraph), Membership.mem s G' → G'.Adj a b) (G.Adj a b))","decl":"@[simp]\ntheorem sInf_adj {s : Set G.Subgraph} : (sInf s).Adj a b ↔ (∀ G' ∈ s, Adj G' a b) ∧ G.Adj a b :=\n  Iff.rfl\n\n"}
{"name":"SimpleGraph.Subgraph.iSup_adj","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"ι : Sort u_1\nV : Type u\nG : SimpleGraph V\na b : V\nf : ι → G.Subgraph\n⊢ Iff ((iSup fun i => f i).Adj a b) (Exists fun i => (f i).Adj a b)","decl":"@[simp]\ntheorem iSup_adj {f : ι → G.Subgraph} : (⨆ i, f i).Adj a b ↔ ∃ i, (f i).Adj a b := by\n  simp [iSup]\n\n"}
{"name":"SimpleGraph.Subgraph.iInf_adj","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"ι : Sort u_1\nV : Type u\nG : SimpleGraph V\na b : V\nf : ι → G.Subgraph\n⊢ Iff ((iInf fun i => f i).Adj a b) (And (∀ (i : ι), (f i).Adj a b) (G.Adj a b))","decl":"@[simp]\ntheorem iInf_adj {f : ι → G.Subgraph} : (⨅ i, f i).Adj a b ↔ (∀ i, (f i).Adj a b) ∧ G.Adj a b := by\n  simp [iInf]\n\n"}
{"name":"SimpleGraph.Subgraph.sInf_adj_of_nonempty","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\na b : V\ns : Set G.Subgraph\nhs : s.Nonempty\n⊢ Iff ((InfSet.sInf s).Adj a b) (∀ (G' : G.Subgraph), Membership.mem s G' → G'.Adj a b)","decl":"theorem sInf_adj_of_nonempty {s : Set G.Subgraph} (hs : s.Nonempty) :\n    (sInf s).Adj a b ↔ ∀ G' ∈ s, Adj G' a b :=\n  sInf_adj.trans <|\n    and_iff_left_of_imp <| by\n      obtain ⟨G', hG'⟩ := hs\n      exact fun h => G'.adj_sub (h _ hG')\n\n"}
{"name":"SimpleGraph.Subgraph.iInf_adj_of_nonempty","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"ι : Sort u_1\nV : Type u\nG : SimpleGraph V\na b : V\ninst✝ : Nonempty ι\nf : ι → G.Subgraph\n⊢ Iff ((iInf fun i => f i).Adj a b) (∀ (i : ι), (f i).Adj a b)","decl":"theorem iInf_adj_of_nonempty [Nonempty ι] {f : ι → G.Subgraph} :\n    (⨅ i, f i).Adj a b ↔ ∀ i, (f i).Adj a b := by\n  rw [iInf, sInf_adj_of_nonempty (Set.range_nonempty _)]\n  simp\n\n"}
{"name":"SimpleGraph.Subgraph.verts_sSup","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\ns : Set G.Subgraph\n⊢ Eq (SupSet.sSup s).verts (Set.iUnion fun G' => Set.iUnion fun h => G'.verts)","decl":"@[simp]\ntheorem verts_sSup (s : Set G.Subgraph) : (sSup s).verts = ⋃ G' ∈ s, verts G' :=\n  rfl\n\n"}
{"name":"SimpleGraph.Subgraph.verts_sInf","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\ns : Set G.Subgraph\n⊢ Eq (InfSet.sInf s).verts (Set.iInter fun G' => Set.iInter fun h => G'.verts)","decl":"@[simp]\ntheorem verts_sInf (s : Set G.Subgraph) : (sInf s).verts = ⋂ G' ∈ s, verts G' :=\n  rfl\n\n"}
{"name":"SimpleGraph.Subgraph.verts_iSup","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"ι : Sort u_1\nV : Type u\nG : SimpleGraph V\nf : ι → G.Subgraph\n⊢ Eq (iSup fun i => f i).verts (Set.iUnion fun i => (f i).verts)","decl":"@[simp]\ntheorem verts_iSup {f : ι → G.Subgraph} : (⨆ i, f i).verts = ⋃ i, (f i).verts := by simp [iSup]\n\n"}
{"name":"SimpleGraph.Subgraph.verts_iInf","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"ι : Sort u_1\nV : Type u\nG : SimpleGraph V\nf : ι → G.Subgraph\n⊢ Eq (iInf fun i => f i).verts (Set.iInter fun i => (f i).verts)","decl":"@[simp]\ntheorem verts_iInf {f : ι → G.Subgraph} : (⨅ i, f i).verts = ⋂ i, (f i).verts := by simp [iInf]\n\n"}
{"name":"SimpleGraph.Subgraph.coe_bot","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\n⊢ Eq Bot.bot.coe Bot.bot","decl":"@[simp] lemma coe_bot : (⊥ : G.Subgraph).coe = ⊥ := rfl\n\n"}
{"name":"SimpleGraph.Subgraph.IsInduced.top","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\n⊢ Top.top.IsInduced","decl":"@[simp] lemma IsInduced.top : (⊤ : G.Subgraph).IsInduced := fun _ _ ↦ id\n\n"}
{"name":"SimpleGraph.Subgraph.verts_spanningCoe_injective","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\n⊢ Function.Injective fun G' => { fst := G'.verts, snd := G'.spanningCoe }","decl":"theorem verts_spanningCoe_injective :\n    (fun G' : Subgraph G => (G'.verts, G'.spanningCoe)).Injective := by\n  intro G₁ G₂ h\n  rw [Prod.ext_iff] at h\n  exact Subgraph.ext h.1 (spanningCoe_inj.1 h.2)\n\n"}
{"name":"SimpleGraph.Subgraph.verts_mono","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nH H' : G.Subgraph\nh : LE.le H H'\n⊢ HasSubset.Subset H.verts H'.verts","decl":"@[gcongr] lemma verts_mono {H H' : G.Subgraph} (h : H ≤ H') : H.verts ⊆ H'.verts := h.1\n"}
{"name":"SimpleGraph.Subgraph.verts_monotone","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\n⊢ Monotone SimpleGraph.Subgraph.verts","decl":"lemma verts_monotone : Monotone (verts : G.Subgraph → Set V) := fun _ _ h ↦ h.1\n\n"}
{"name":"SimpleGraph.Subgraph.subgraphInhabited_default","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\n⊢ Eq Inhabited.default Bot.bot","decl":"@[simps]\ninstance subgraphInhabited : Inhabited (Subgraph G) := ⟨⊥⟩\n\n"}
{"name":"SimpleGraph.Subgraph.neighborSet_sup","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nH H' : G.Subgraph\nv : V\n⊢ Eq ((Max.max H H').neighborSet v) (Union.union (H.neighborSet v) (H'.neighborSet v))","decl":"@[simp]\ntheorem neighborSet_sup {H H' : G.Subgraph} (v : V) :\n    (H ⊔ H').neighborSet v = H.neighborSet v ∪ H'.neighborSet v := rfl\n\n"}
{"name":"SimpleGraph.Subgraph.neighborSet_inf","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nH H' : G.Subgraph\nv : V\n⊢ Eq ((Min.min H H').neighborSet v) (Inter.inter (H.neighborSet v) (H'.neighborSet v))","decl":"@[simp]\ntheorem neighborSet_inf {H H' : G.Subgraph} (v : V) :\n    (H ⊓ H').neighborSet v = H.neighborSet v ∩ H'.neighborSet v := rfl\n\n"}
{"name":"SimpleGraph.Subgraph.neighborSet_top","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nv : V\n⊢ Eq (Top.top.neighborSet v) (G.neighborSet v)","decl":"@[simp]\ntheorem neighborSet_top (v : V) : (⊤ : G.Subgraph).neighborSet v = G.neighborSet v := rfl\n\n"}
{"name":"SimpleGraph.Subgraph.neighborSet_bot","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nv : V\n⊢ Eq (Bot.bot.neighborSet v) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem neighborSet_bot (v : V) : (⊥ : G.Subgraph).neighborSet v = ∅ := rfl\n\n"}
{"name":"SimpleGraph.Subgraph.neighborSet_sSup","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\ns : Set G.Subgraph\nv : V\n⊢ Eq ((SupSet.sSup s).neighborSet v) (Set.iUnion fun G' => Set.iUnion fun h => G'.neighborSet v)","decl":"@[simp]\ntheorem neighborSet_sSup (s : Set G.Subgraph) (v : V) :\n    (sSup s).neighborSet v = ⋃ G' ∈ s, neighborSet G' v := by\n  ext\n  simp\n\n"}
{"name":"SimpleGraph.Subgraph.neighborSet_sInf","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\ns : Set G.Subgraph\nv : V\n⊢ Eq ((InfSet.sInf s).neighborSet v) (Inter.inter (Set.iInter fun G' => Set.iInter fun h => G'.neighborSet v) (G.neighborSet v))","decl":"@[simp]\ntheorem neighborSet_sInf (s : Set G.Subgraph) (v : V) :\n    (sInf s).neighborSet v = (⋂ G' ∈ s, neighborSet G' v) ∩ G.neighborSet v := by\n  ext\n  simp\n\n"}
{"name":"SimpleGraph.Subgraph.neighborSet_iSup","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"ι : Sort u_1\nV : Type u\nG : SimpleGraph V\nf : ι → G.Subgraph\nv : V\n⊢ Eq ((iSup fun i => f i).neighborSet v) (Set.iUnion fun i => (f i).neighborSet v)","decl":"@[simp]\ntheorem neighborSet_iSup (f : ι → G.Subgraph) (v : V) :\n    (⨆ i, f i).neighborSet v = ⋃ i, (f i).neighborSet v := by simp [iSup]\n\n"}
{"name":"SimpleGraph.Subgraph.neighborSet_iInf","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"ι : Sort u_1\nV : Type u\nG : SimpleGraph V\nf : ι → G.Subgraph\nv : V\n⊢ Eq ((iInf fun i => f i).neighborSet v) (Inter.inter (Set.iInter fun i => (f i).neighborSet v) (G.neighborSet v))","decl":"@[simp]\ntheorem neighborSet_iInf (f : ι → G.Subgraph) (v : V) :\n    (⨅ i, f i).neighborSet v = (⋂ i, (f i).neighborSet v) ∩ G.neighborSet v := by simp [iInf]\n\n"}
{"name":"SimpleGraph.Subgraph.edgeSet_top","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\n⊢ Eq Top.top.edgeSet G.edgeSet","decl":"@[simp]\ntheorem edgeSet_top : (⊤ : Subgraph G).edgeSet = G.edgeSet := rfl\n\n"}
{"name":"SimpleGraph.Subgraph.edgeSet_bot","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\n⊢ Eq Bot.bot.edgeSet EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem edgeSet_bot : (⊥ : Subgraph G).edgeSet = ∅ :=\n  Set.ext <| Sym2.ind (by simp)\n\n"}
{"name":"SimpleGraph.Subgraph.edgeSet_inf","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nH₁ H₂ : G.Subgraph\n⊢ Eq (Min.min H₁ H₂).edgeSet (Inter.inter H₁.edgeSet H₂.edgeSet)","decl":"@[simp]\ntheorem edgeSet_inf {H₁ H₂ : Subgraph G} : (H₁ ⊓ H₂).edgeSet = H₁.edgeSet ∩ H₂.edgeSet :=\n  Set.ext <| Sym2.ind (by simp)\n\n"}
{"name":"SimpleGraph.Subgraph.edgeSet_sup","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nH₁ H₂ : G.Subgraph\n⊢ Eq (Max.max H₁ H₂).edgeSet (Union.union H₁.edgeSet H₂.edgeSet)","decl":"@[simp]\ntheorem edgeSet_sup {H₁ H₂ : Subgraph G} : (H₁ ⊔ H₂).edgeSet = H₁.edgeSet ∪ H₂.edgeSet :=\n  Set.ext <| Sym2.ind (by simp)\n\n"}
{"name":"SimpleGraph.Subgraph.edgeSet_sSup","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\ns : Set G.Subgraph\n⊢ Eq (SupSet.sSup s).edgeSet (Set.iUnion fun G' => Set.iUnion fun h => G'.edgeSet)","decl":"@[simp]\ntheorem edgeSet_sSup (s : Set G.Subgraph) : (sSup s).edgeSet = ⋃ G' ∈ s, edgeSet G' := by\n  ext e\n  induction e\n  simp\n\n"}
{"name":"SimpleGraph.Subgraph.edgeSet_sInf","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\ns : Set G.Subgraph\n⊢ Eq (InfSet.sInf s).edgeSet (Inter.inter (Set.iInter fun G' => Set.iInter fun h => G'.edgeSet) G.edgeSet)","decl":"@[simp]\ntheorem edgeSet_sInf (s : Set G.Subgraph) :\n    (sInf s).edgeSet = (⋂ G' ∈ s, edgeSet G') ∩ G.edgeSet := by\n  ext e\n  induction e\n  simp\n\n"}
{"name":"SimpleGraph.Subgraph.edgeSet_iSup","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"ι : Sort u_1\nV : Type u\nG : SimpleGraph V\nf : ι → G.Subgraph\n⊢ Eq (iSup fun i => f i).edgeSet (Set.iUnion fun i => (f i).edgeSet)","decl":"@[simp]\ntheorem edgeSet_iSup (f : ι → G.Subgraph) :\n    (⨆ i, f i).edgeSet = ⋃ i, (f i).edgeSet := by simp [iSup]\n\n"}
{"name":"SimpleGraph.Subgraph.edgeSet_iInf","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"ι : Sort u_1\nV : Type u\nG : SimpleGraph V\nf : ι → G.Subgraph\n⊢ Eq (iInf fun i => f i).edgeSet (Inter.inter (Set.iInter fun i => (f i).edgeSet) G.edgeSet)","decl":"@[simp]\ntheorem edgeSet_iInf (f : ι → G.Subgraph) :\n    (⨅ i, f i).edgeSet = (⋂ i, (f i).edgeSet) ∩ G.edgeSet := by\n  simp [iInf]\n\n"}
{"name":"SimpleGraph.Subgraph.spanningCoe_top","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\n⊢ Eq Top.top.spanningCoe G","decl":"@[simp]\ntheorem spanningCoe_top : (⊤ : Subgraph G).spanningCoe = G := rfl\n\n"}
{"name":"SimpleGraph.Subgraph.spanningCoe_bot","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\n⊢ Eq Bot.bot.spanningCoe Bot.bot","decl":"@[simp]\ntheorem spanningCoe_bot : (⊥ : Subgraph G).spanningCoe = ⊥ := rfl\n\n"}
{"name":"SimpleGraph.toSubgraph_adj","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nG H : SimpleGraph V\nh : LE.le H G\na✝¹ a✝ : V\n⊢ Eq ((SimpleGraph.toSubgraph H h).Adj a✝¹ a✝) (H.Adj a✝¹ a✝)","decl":"/-- Turn a subgraph of a `SimpleGraph` into a member of its subgraph type. -/\n@[simps]\ndef _root_.SimpleGraph.toSubgraph (H : SimpleGraph V) (h : H ≤ G) : G.Subgraph where\n  verts := Set.univ\n  Adj := H.Adj\n  adj_sub e := h e\n  edge_vert _ := Set.mem_univ _\n  symm := H.symm\n\n"}
{"name":"SimpleGraph.toSubgraph_verts","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nG H : SimpleGraph V\nh : LE.le H G\n⊢ Eq (SimpleGraph.toSubgraph H h).verts Set.univ","decl":"/-- Turn a subgraph of a `SimpleGraph` into a member of its subgraph type. -/\n@[simps]\ndef _root_.SimpleGraph.toSubgraph (H : SimpleGraph V) (h : H ≤ G) : G.Subgraph where\n  verts := Set.univ\n  Adj := H.Adj\n  adj_sub e := h e\n  edge_vert _ := Set.mem_univ _\n  symm := H.symm\n\n"}
{"name":"SimpleGraph.Subgraph.support_mono","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nH H' : G.Subgraph\nh : LE.le H H'\n⊢ HasSubset.Subset H.support H'.support","decl":"theorem support_mono {H H' : Subgraph G} (h : H ≤ H') : H.support ⊆ H'.support :=\n  Rel.dom_mono h.2\n\n"}
{"name":"SimpleGraph.toSubgraph.isSpanning","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nG H : SimpleGraph V\nh : LE.le H G\n⊢ (SimpleGraph.toSubgraph H h).IsSpanning","decl":"theorem _root_.SimpleGraph.toSubgraph.isSpanning (H : SimpleGraph V) (h : H ≤ G) :\n    (toSubgraph H h).IsSpanning :=\n  Set.mem_univ\n\n"}
{"name":"SimpleGraph.Subgraph.spanningCoe_le_of_le","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nH H' : G.Subgraph\nh : LE.le H H'\n⊢ LE.le H.spanningCoe H'.spanningCoe","decl":"theorem spanningCoe_le_of_le {H H' : Subgraph G} (h : H ≤ H') : H.spanningCoe ≤ H'.spanningCoe :=\n  h.2\n\n"}
{"name":"SimpleGraph.Subgraph.edgeSet_mono","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nH₁ H₂ : G.Subgraph\nh : LE.le H₁ H₂\n⊢ LE.le H₁.edgeSet H₂.edgeSet","decl":"theorem edgeSet_mono {H₁ H₂ : Subgraph G} (h : H₁ ≤ H₂) : H₁.edgeSet ≤ H₂.edgeSet :=\n  Sym2.ind h.2\n\n"}
{"name":"Disjoint.edgeSet","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nH₁ H₂ : G.Subgraph\nh : Disjoint H₁ H₂\n⊢ Disjoint H₁.edgeSet H₂.edgeSet","decl":"theorem _root_.Disjoint.edgeSet {H₁ H₂ : Subgraph G} (h : Disjoint H₁ H₂) :\n    Disjoint H₁.edgeSet H₂.edgeSet :=\n  disjoint_iff_inf_le.mpr <| by simpa using edgeSet_mono h.le_bot\n\n"}
{"name":"SimpleGraph.Subgraph.map_verts","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nW : Type v\nG : SimpleGraph V\nG' : SimpleGraph W\nf : G.Hom G'\nH : G.Subgraph\n⊢ Eq (SimpleGraph.Subgraph.map f H).verts (Set.image (⇑f) H.verts)","decl":"/-- Graph homomorphisms induce a covariant function on subgraphs. -/\n@[simps]\nprotected def map (f : G →g G') (H : G.Subgraph) : G'.Subgraph where\n  verts := f '' H.verts\n  Adj := Relation.Map H.Adj f f\n  adj_sub := by\n    rintro _ _ ⟨u, v, h, rfl, rfl⟩\n    exact f.map_rel (H.adj_sub h)\n  edge_vert := by\n    rintro _ _ ⟨u, v, h, rfl, rfl⟩\n    exact Set.mem_image_of_mem _ (H.edge_vert h)\n  symm := by\n    rintro _ _ ⟨u, v, h, rfl, rfl⟩\n    exact ⟨v, u, H.symm h, rfl, rfl⟩\n\n"}
{"name":"SimpleGraph.Subgraph.map_adj","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nW : Type v\nG : SimpleGraph V\nG' : SimpleGraph W\nf : G.Hom G'\nH : G.Subgraph\na✝¹ a✝ : W\n⊢ Eq ((SimpleGraph.Subgraph.map f H).Adj a✝¹ a✝) (Relation.Map H.Adj (⇑f) (⇑f) a✝¹ a✝)","decl":"/-- Graph homomorphisms induce a covariant function on subgraphs. -/\n@[simps]\nprotected def map (f : G →g G') (H : G.Subgraph) : G'.Subgraph where\n  verts := f '' H.verts\n  Adj := Relation.Map H.Adj f f\n  adj_sub := by\n    rintro _ _ ⟨u, v, h, rfl, rfl⟩\n    exact f.map_rel (H.adj_sub h)\n  edge_vert := by\n    rintro _ _ ⟨u, v, h, rfl, rfl⟩\n    exact Set.mem_image_of_mem _ (H.edge_vert h)\n  symm := by\n    rintro _ _ ⟨u, v, h, rfl, rfl⟩\n    exact ⟨v, u, H.symm h, rfl, rfl⟩\n\n"}
{"name":"SimpleGraph.Subgraph.map_id","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nH : G.Subgraph\n⊢ Eq (SimpleGraph.Subgraph.map SimpleGraph.Hom.id H) H","decl":"@[simp] lemma map_id (H : G.Subgraph) : H.map Hom.id = H := by ext <;> simp\n\n"}
{"name":"SimpleGraph.Subgraph.map_comp","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nW : Type v\nG : SimpleGraph V\nG' : SimpleGraph W\nU : Type u_2\nG'' : SimpleGraph U\nH : G.Subgraph\nf : G.Hom G'\ng : G'.Hom G''\n⊢ Eq (SimpleGraph.Subgraph.map (g.comp f) H) (SimpleGraph.Subgraph.map g (SimpleGraph.Subgraph.map f H))","decl":"lemma map_comp {U : Type*} {G'' : SimpleGraph U} (H : G.Subgraph) (f : G →g G') (g : G' →g G'') :\n    H.map (g.comp f) = (H.map f).map g := by ext <;> simp [Subgraph.map]\n\n"}
{"name":"SimpleGraph.Subgraph.map_mono","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nW : Type v\nG : SimpleGraph V\nG' : SimpleGraph W\nf : G.Hom G'\nH₁ H₂ : G.Subgraph\nhH : LE.le H₁ H₂\n⊢ LE.le (SimpleGraph.Subgraph.map f H₁) (SimpleGraph.Subgraph.map f H₂)","decl":"@[gcongr] lemma map_mono {H₁ H₂ : G.Subgraph} (hH : H₁ ≤ H₂) : H₁.map f ≤ H₂.map f := by\n  constructor\n  · intro\n    simp only [map_verts, Set.mem_image, forall_exists_index, and_imp]\n    rintro v hv rfl\n    exact ⟨_, hH.1 hv, rfl⟩\n  · rintro _ _ ⟨u, v, ha, rfl, rfl⟩\n    exact ⟨_, _, hH.2 ha, rfl, rfl⟩\n\n"}
{"name":"SimpleGraph.Subgraph.map_monotone","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nW : Type v\nG : SimpleGraph V\nG' : SimpleGraph W\nf : G.Hom G'\n⊢ Monotone (SimpleGraph.Subgraph.map f)","decl":"lemma map_monotone : Monotone (Subgraph.map f) := fun _ _ ↦ map_mono\n\n"}
{"name":"SimpleGraph.Subgraph.map_sup","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nW : Type v\nG : SimpleGraph V\nG' : SimpleGraph W\nf : G.Hom G'\nH₁ H₂ : G.Subgraph\n⊢ Eq (SimpleGraph.Subgraph.map f (Max.max H₁ H₂)) (Max.max (SimpleGraph.Subgraph.map f H₁) (SimpleGraph.Subgraph.map f H₂))","decl":"theorem map_sup (f : G →g G') (H₁ H₂ : G.Subgraph) : (H₁ ⊔ H₂).map f = H₁.map f ⊔ H₂.map f := by\n  ext <;> simp [Set.image_union, map_adj, sup_adj, Relation.Map, or_and_right, exists_or]\n\n"}
{"name":"SimpleGraph.Subgraph.comap_adj","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nW : Type v\nG : SimpleGraph V\nG' : SimpleGraph W\nf : G.Hom G'\nH : G'.Subgraph\nu v : V\n⊢ Eq ((SimpleGraph.Subgraph.comap f H).Adj u v) (And (G.Adj u v) (H.Adj (f u) (f v)))","decl":"/-- Graph homomorphisms induce a contravariant function on subgraphs. -/\n@[simps]\nprotected def comap {G' : SimpleGraph W} (f : G →g G') (H : G'.Subgraph) : G.Subgraph where\n  verts := f ⁻¹' H.verts\n  Adj u v := G.Adj u v ∧ H.Adj (f u) (f v)\n  adj_sub h := h.1\n  edge_vert h := Set.mem_preimage.1 (H.edge_vert h.2)\n  symm _ _ h := ⟨G.symm h.1, H.symm h.2⟩\n\n"}
{"name":"SimpleGraph.Subgraph.comap_verts","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nW : Type v\nG : SimpleGraph V\nG' : SimpleGraph W\nf : G.Hom G'\nH : G'.Subgraph\n⊢ Eq (SimpleGraph.Subgraph.comap f H).verts (Set.preimage (⇑f) H.verts)","decl":"/-- Graph homomorphisms induce a contravariant function on subgraphs. -/\n@[simps]\nprotected def comap {G' : SimpleGraph W} (f : G →g G') (H : G'.Subgraph) : G.Subgraph where\n  verts := f ⁻¹' H.verts\n  Adj u v := G.Adj u v ∧ H.Adj (f u) (f v)\n  adj_sub h := h.1\n  edge_vert h := Set.mem_preimage.1 (H.edge_vert h.2)\n  symm _ _ h := ⟨G.symm h.1, H.symm h.2⟩\n\n"}
{"name":"SimpleGraph.Subgraph.comap_monotone","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nW : Type v\nG : SimpleGraph V\nG' : SimpleGraph W\nf : G.Hom G'\n⊢ Monotone (SimpleGraph.Subgraph.comap f)","decl":"theorem comap_monotone {G' : SimpleGraph W} (f : G →g G') : Monotone (Subgraph.comap f) := by\n  intro H H' h\n  constructor\n  · intro\n    simp only [comap_verts, Set.mem_preimage]\n    apply h.1\n  · intro v w\n    simp +contextual only [comap_adj, and_imp, true_and]\n    intro\n    apply h.2\n\n"}
{"name":"SimpleGraph.Subgraph.map_le_iff_le_comap","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nW : Type v\nG : SimpleGraph V\nG' : SimpleGraph W\nf : G.Hom G'\nH : G.Subgraph\nH' : G'.Subgraph\n⊢ Iff (LE.le (SimpleGraph.Subgraph.map f H) H') (LE.le H (SimpleGraph.Subgraph.comap f H'))","decl":"theorem map_le_iff_le_comap {G' : SimpleGraph W} (f : G →g G') (H : G.Subgraph) (H' : G'.Subgraph) :\n    H.map f ≤ H' ↔ H ≤ H'.comap f := by\n  refine ⟨fun h ↦ ⟨fun v hv ↦ ?_, fun v w hvw ↦ ?_⟩, fun h ↦ ⟨fun v ↦ ?_, fun v w ↦ ?_⟩⟩\n  · simp only [comap_verts, Set.mem_preimage]\n    exact h.1 ⟨v, hv, rfl⟩\n  · simp only [H.adj_sub hvw, comap_adj, true_and]\n    exact h.2 ⟨v, w, hvw, rfl, rfl⟩\n  · simp only [map_verts, Set.mem_image, forall_exists_index, and_imp]\n    rintro w hw rfl\n    exact h.1 hw\n  · simp only [Relation.Map, map_adj, forall_exists_index, and_imp]\n    rintro u u' hu rfl rfl\n    exact (h.2 hu).2\n\n"}
{"name":"SimpleGraph.Subgraph.inclusion_apply_coe","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nx y : G.Subgraph\nh : LE.le x y\nv : ↑x.verts\n⊢ Eq ↑((SimpleGraph.Subgraph.inclusion h) v) ↑v","decl":"/-- Given two subgraphs, one a subgraph of the other, there is an induced injective homomorphism of\nthe subgraphs as graphs. -/\n@[simps]\ndef inclusion {x y : Subgraph G} (h : x ≤ y) : x.coe →g y.coe where\n  toFun v := ⟨↑v, And.left h v.property⟩\n  map_rel' hvw := h.2 hvw\n\n"}
{"name":"SimpleGraph.Subgraph.inclusion.injective","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nx y : G.Subgraph\nh : LE.le x y\n⊢ Function.Injective ⇑(SimpleGraph.Subgraph.inclusion h)","decl":"theorem inclusion.injective {x y : Subgraph G} (h : x ≤ y) : Function.Injective (inclusion h) := by\n  intro v w h\n  rw [inclusion, DFunLike.coe, Subtype.mk_eq_mk] at h\n  exact Subtype.ext h\n\n"}
{"name":"SimpleGraph.Subgraph.hom_apply","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nx : G.Subgraph\nv : ↑x.verts\n⊢ Eq (x.hom v) ↑v","decl":"/-- There is an induced injective homomorphism of a subgraph of `G` into `G`. -/\n@[simps]\nprotected def hom (x : Subgraph G) : x.coe →g G where\n  toFun v := v\n  map_rel' := x.adj_sub\n\n"}
{"name":"SimpleGraph.Subgraph.coe_hom","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nx : G.Subgraph\n⊢ Eq ⇑x.hom fun v => ↑v","decl":"@[simp] lemma coe_hom (x : Subgraph G) :\n    (x.hom : x.verts → V) = (fun (v : x.verts) => (v : V)) := rfl\n\n"}
{"name":"SimpleGraph.Subgraph.hom.injective","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nx : G.Subgraph\n⊢ Function.Injective ⇑x.hom","decl":"theorem hom.injective {x : Subgraph G} : Function.Injective x.hom :=\n  fun _ _ ↦ Subtype.ext\n\n"}
{"name":"SimpleGraph.Subgraph.spanningHom_apply","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nx : G.Subgraph\na : V\n⊢ Eq (x.spanningHom a) (id a)","decl":"/-- There is an induced injective homomorphism of a subgraph of `G` as\na spanning subgraph into `G`. -/\n@[simps]\ndef spanningHom (x : Subgraph G) : x.spanningCoe →g G where\n  toFun := id\n  map_rel' := x.adj_sub\n\n"}
{"name":"SimpleGraph.Subgraph.spanningHom.injective","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nx : G.Subgraph\n⊢ Function.Injective ⇑x.spanningHom","decl":"theorem spanningHom.injective {x : Subgraph G} : Function.Injective x.spanningHom :=\n  fun _ _ ↦ id\n\n"}
{"name":"SimpleGraph.Subgraph.neighborSet_subset_of_subgraph","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nx y : G.Subgraph\nh : LE.le x y\nv : V\n⊢ HasSubset.Subset (x.neighborSet v) (y.neighborSet v)","decl":"theorem neighborSet_subset_of_subgraph {x y : Subgraph G} (h : x ≤ y) (v : V) :\n    x.neighborSet v ⊆ y.neighborSet v :=\n  fun _ h' ↦ h.2 h'\n\n"}
{"name":"SimpleGraph.Subgraph.IsSpanning.card_verts","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\ninst✝¹ : Fintype V\nG' : G.Subgraph\ninst✝ : Fintype ↑G'.verts\nh : G'.IsSpanning\n⊢ Eq G'.verts.toFinset.card (Fintype.card V)","decl":"theorem IsSpanning.card_verts [Fintype V] {G' : Subgraph G} [Fintype G'.verts] (h : G'.IsSpanning) :\n    G'.verts.toFinset.card = Fintype.card V := by\n  simp only [isSpanning_iff.1 h, Set.toFinset_univ]\n  congr\n\n"}
{"name":"SimpleGraph.Subgraph.finset_card_neighborSet_eq_degree","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nG' : G.Subgraph\nv : V\ninst✝ : Fintype ↑(G'.neighborSet v)\n⊢ Eq (G'.neighborSet v).toFinset.card (G'.degree v)","decl":"theorem finset_card_neighborSet_eq_degree {G' : Subgraph G} {v : V} [Fintype (G'.neighborSet v)] :\n    (G'.neighborSet v).toFinset.card = G'.degree v := by\n  rw [degree, Set.toFinset_card]\n\n"}
{"name":"SimpleGraph.Subgraph.degree_le","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nG' : G.Subgraph\nv : V\ninst✝¹ : Fintype ↑(G'.neighborSet v)\ninst✝ : Fintype ↑(G.neighborSet v)\n⊢ LE.le (G'.degree v) (G.degree v)","decl":"theorem degree_le (G' : Subgraph G) (v : V) [Fintype (G'.neighborSet v)]\n    [Fintype (G.neighborSet v)] : G'.degree v ≤ G.degree v := by\n  rw [← card_neighborSet_eq_degree]\n  exact Set.card_le_card (G'.neighborSet_subset v)\n\n"}
{"name":"SimpleGraph.Subgraph.degree_le'","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nG' G'' : G.Subgraph\nh : LE.le G' G''\nv : V\ninst✝¹ : Fintype ↑(G'.neighborSet v)\ninst✝ : Fintype ↑(G''.neighborSet v)\n⊢ LE.le (G'.degree v) (G''.degree v)","decl":"theorem degree_le' (G' G'' : Subgraph G) (h : G' ≤ G'') (v : V) [Fintype (G'.neighborSet v)]\n    [Fintype (G''.neighborSet v)] : G'.degree v ≤ G''.degree v :=\n  Set.card_le_card (neighborSet_subset_of_subgraph h v)\n\n"}
{"name":"SimpleGraph.Subgraph.coe_degree","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nG' : G.Subgraph\nv : ↑G'.verts\ninst✝¹ : Fintype ↑(G'.coe.neighborSet v)\ninst✝ : Fintype ↑(G'.neighborSet ↑v)\n⊢ Eq (G'.coe.degree v) (G'.degree ↑v)","decl":"@[simp]\ntheorem coe_degree (G' : Subgraph G) (v : G'.verts) [Fintype (G'.coe.neighborSet v)]\n    [Fintype (G'.neighborSet v)] : G'.coe.degree v = G'.degree v := by\n  rw [← card_neighborSet_eq_degree]\n  exact Fintype.card_congr (coeNeighborSetEquiv v)\n\n"}
{"name":"SimpleGraph.Subgraph.degree_spanningCoe","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nG' : G.Subgraph\nv : V\ninst✝¹ : Fintype ↑(G'.neighborSet v)\ninst✝ : Fintype ↑(G'.spanningCoe.neighborSet v)\n⊢ Eq (G'.spanningCoe.degree v) (G'.degree v)","decl":"@[simp]\ntheorem degree_spanningCoe {G' : G.Subgraph} (v : V) [Fintype (G'.neighborSet v)]\n    [Fintype (G'.spanningCoe.neighborSet v)] : G'.spanningCoe.degree v = G'.degree v := by\n  rw [← card_neighborSet_eq_degree, Subgraph.degree]\n  congr!\n\n"}
{"name":"SimpleGraph.Subgraph.degree_eq_one_iff_unique_adj","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nG' : G.Subgraph\nv : V\ninst✝ : Fintype ↑(G'.neighborSet v)\n⊢ Iff (Eq (G'.degree v) 1) (ExistsUnique fun w => G'.Adj v w)","decl":"theorem degree_eq_one_iff_unique_adj {G' : Subgraph G} {v : V} [Fintype (G'.neighborSet v)] :\n    G'.degree v = 1 ↔ ∃! w : V, G'.Adj v w := by\n  rw [← finset_card_neighborSet_eq_degree, Finset.card_eq_one, Finset.singleton_iff_unique_mem]\n  simp only [Set.mem_toFinset, mem_neighborSet]\n\n"}
{"name":"SimpleGraph.nonempty_singletonSubgraph_verts","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nv : V\n⊢ Nonempty ↑(G.singletonSubgraph v).verts","decl":"instance nonempty_singletonSubgraph_verts (v : V) : Nonempty (G.singletonSubgraph v).verts :=\n  ⟨⟨v, Set.mem_singleton v⟩⟩\n\n"}
{"name":"SimpleGraph.singletonSubgraph_le_iff","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nv : V\nH : G.Subgraph\n⊢ Iff (LE.le (G.singletonSubgraph v) H) (Membership.mem H.verts v)","decl":"@[simp]\ntheorem singletonSubgraph_le_iff (v : V) (H : G.Subgraph) :\n    G.singletonSubgraph v ≤ H ↔ v ∈ H.verts := by\n  refine ⟨fun h ↦ h.1 (Set.mem_singleton v), ?_⟩\n  intro h\n  constructor\n  · rwa [singletonSubgraph_verts, Set.singleton_subset_iff]\n  · exact fun _ _ ↦ False.elim\n\n"}
{"name":"SimpleGraph.map_singletonSubgraph","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nW : Type v\nG : SimpleGraph V\nG' : SimpleGraph W\nf : G.Hom G'\nv : V\n⊢ Eq (SimpleGraph.Subgraph.map f (G.singletonSubgraph v)) (G'.singletonSubgraph (f v))","decl":"@[simp]\ntheorem map_singletonSubgraph (f : G →g G') {v : V} :\n    Subgraph.map f (G.singletonSubgraph v) = G'.singletonSubgraph (f v) := by\n  ext <;> simp only [Relation.Map, Subgraph.map_adj, singletonSubgraph_adj, Pi.bot_apply,\n    exists_and_left, and_iff_left_iff_imp, IsEmpty.forall_iff, Subgraph.map_verts,\n    singletonSubgraph_verts, Set.image_singleton]\n  exact False.elim\n\n"}
{"name":"SimpleGraph.neighborSet_singletonSubgraph","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nv w : V\n⊢ Eq ((G.singletonSubgraph v).neighborSet w) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem neighborSet_singletonSubgraph (v w : V) : (G.singletonSubgraph v).neighborSet w = ∅ :=\n  rfl\n\n"}
{"name":"SimpleGraph.edgeSet_singletonSubgraph","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nv : V\n⊢ Eq (G.singletonSubgraph v).edgeSet EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem edgeSet_singletonSubgraph (v : V) : (G.singletonSubgraph v).edgeSet = ∅ :=\n  Sym2.fromRel_bot\n\n"}
{"name":"SimpleGraph.eq_singletonSubgraph_iff_verts_eq","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nH : G.Subgraph\nv : V\n⊢ Iff (Eq H (G.singletonSubgraph v)) (Eq H.verts (Singleton.singleton v))","decl":"theorem eq_singletonSubgraph_iff_verts_eq (H : G.Subgraph) {v : V} :\n    H = G.singletonSubgraph v ↔ H.verts = {v} := by\n  refine ⟨fun h ↦ by rw [h, singletonSubgraph_verts], fun h ↦ ?_⟩\n  ext\n  · rw [h, singletonSubgraph_verts]\n  · simp only [Prop.bot_eq_false, singletonSubgraph_adj, Pi.bot_apply, iff_false]\n    intro ha\n    have ha1 := ha.fst_mem\n    have ha2 := ha.snd_mem\n    rw [h, Set.mem_singleton_iff] at ha1 ha2\n    subst_vars\n    exact ha.ne rfl\n\n"}
{"name":"SimpleGraph.nonempty_subgraphOfAdj_verts","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nv w : V\nhvw : G.Adj v w\n⊢ Nonempty ↑(G.subgraphOfAdj hvw).verts","decl":"instance nonempty_subgraphOfAdj_verts {v w : V} (hvw : G.Adj v w) :\n    Nonempty (G.subgraphOfAdj hvw).verts :=\n  ⟨⟨v, by simp⟩⟩\n\n"}
{"name":"SimpleGraph.edgeSet_subgraphOfAdj","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nv w : V\nhvw : G.Adj v w\n⊢ Eq (G.subgraphOfAdj hvw).edgeSet (Singleton.singleton (Sym2.mk { fst := v, snd := w }))","decl":"@[simp]\ntheorem edgeSet_subgraphOfAdj {v w : V} (hvw : G.Adj v w) :\n    (G.subgraphOfAdj hvw).edgeSet = {s(v, w)} := by\n  ext e\n  refine e.ind ?_\n  simp only [eq_comm, Set.mem_singleton_iff, Subgraph.mem_edgeSet, subgraphOfAdj_adj,\n    forall₂_true_iff]\n\n"}
{"name":"SimpleGraph.subgraphOfAdj_le_of_adj","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nv w : V\nH : G.Subgraph\nh : H.Adj v w\n⊢ LE.le (G.subgraphOfAdj ⋯) H","decl":"lemma subgraphOfAdj_le_of_adj {v w : V} (H : G.Subgraph) (h : H.Adj v w) :\n    G.subgraphOfAdj (H.adj_sub h) ≤ H := by\n  constructor\n  · intro x\n    rintro (rfl | rfl) <;> simp [H.edge_vert h, H.edge_vert h.symm]\n  · simp only [subgraphOfAdj_adj, Sym2.eq, Sym2.rel_iff]\n    rintro _ _ (⟨rfl, rfl⟩ | ⟨rfl, rfl⟩) <;> simp [h, h.symm]\n\n"}
{"name":"SimpleGraph.subgraphOfAdj_symm","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nv w : V\nhvw : G.Adj v w\n⊢ Eq (G.subgraphOfAdj ⋯) (G.subgraphOfAdj hvw)","decl":"theorem subgraphOfAdj_symm {v w : V} (hvw : G.Adj v w) :\n    G.subgraphOfAdj hvw.symm = G.subgraphOfAdj hvw := by\n  ext <;> simp [or_comm, and_comm]\n\n"}
{"name":"SimpleGraph.map_subgraphOfAdj","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nW : Type v\nG : SimpleGraph V\nG' : SimpleGraph W\nf : G.Hom G'\nv w : V\nhvw : G.Adj v w\n⊢ Eq (SimpleGraph.Subgraph.map f (G.subgraphOfAdj hvw)) (G'.subgraphOfAdj ⋯)","decl":"@[simp]\ntheorem map_subgraphOfAdj (f : G →g G') {v w : V} (hvw : G.Adj v w) :\n    Subgraph.map f (G.subgraphOfAdj hvw) = G'.subgraphOfAdj (f.map_adj hvw) := by\n  ext\n  · simp only [Subgraph.map_verts, subgraphOfAdj_verts, Set.mem_image, Set.mem_insert_iff,\n      Set.mem_singleton_iff]\n    constructor\n    · rintro ⟨u, rfl | rfl, rfl⟩ <;> simp\n    · rintro (rfl | rfl)\n      · use v\n        simp\n      · use w\n        simp\n  · simp only [Relation.Map, Subgraph.map_adj, subgraphOfAdj_adj, Sym2.eq, Sym2.rel_iff]\n    constructor\n    · rintro ⟨a, b, ⟨rfl, rfl⟩ | ⟨rfl, rfl⟩, rfl, rfl⟩ <;> simp\n    · rintro (⟨rfl, rfl⟩ | ⟨rfl, rfl⟩)\n      · use v, w\n        simp\n      · use w, v\n        simp\n\n"}
{"name":"SimpleGraph.neighborSet_subgraphOfAdj_subset","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nu v w : V\nhvw : G.Adj v w\n⊢ HasSubset.Subset ((G.subgraphOfAdj hvw).neighborSet u) (Insert.insert v (Singleton.singleton w))","decl":"theorem neighborSet_subgraphOfAdj_subset {u v w : V} (hvw : G.Adj v w) :\n    (G.subgraphOfAdj hvw).neighborSet u ⊆ {v, w} :=\n  (G.subgraphOfAdj hvw).neighborSet_subset_verts _\n\n"}
{"name":"SimpleGraph.neighborSet_fst_subgraphOfAdj","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nv w : V\nhvw : G.Adj v w\n⊢ Eq ((G.subgraphOfAdj hvw).neighborSet v) (Singleton.singleton w)","decl":"@[simp]\ntheorem neighborSet_fst_subgraphOfAdj {v w : V} (hvw : G.Adj v w) :\n    (G.subgraphOfAdj hvw).neighborSet v = {w} := by\n  ext u\n  suffices w = u ↔ u = w by simpa [hvw.ne.symm] using this\n  rw [eq_comm]\n\n"}
{"name":"SimpleGraph.neighborSet_snd_subgraphOfAdj","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nv w : V\nhvw : G.Adj v w\n⊢ Eq ((G.subgraphOfAdj hvw).neighborSet w) (Singleton.singleton v)","decl":"@[simp]\ntheorem neighborSet_snd_subgraphOfAdj {v w : V} (hvw : G.Adj v w) :\n    (G.subgraphOfAdj hvw).neighborSet w = {v} := by\n  rw [subgraphOfAdj_symm hvw.symm]\n  exact neighborSet_fst_subgraphOfAdj hvw.symm\n\n"}
{"name":"SimpleGraph.neighborSet_subgraphOfAdj_of_ne_of_ne","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nu v w : V\nhvw : G.Adj v w\nhv : Ne u v\nhw : Ne u w\n⊢ Eq ((G.subgraphOfAdj hvw).neighborSet u) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem neighborSet_subgraphOfAdj_of_ne_of_ne {u v w : V} (hvw : G.Adj v w) (hv : u ≠ v)\n    (hw : u ≠ w) : (G.subgraphOfAdj hvw).neighborSet u = ∅ := by\n  ext\n  simp [hv.symm, hw.symm]\n\n"}
{"name":"SimpleGraph.neighborSet_subgraphOfAdj","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\ninst✝ : DecidableEq V\nu v w : V\nhvw : G.Adj v w\n⊢ Eq ((G.subgraphOfAdj hvw).neighborSet u) (Union.union (ite (Eq u v) (Singleton.singleton w) EmptyCollection.emptyCollection) (ite (Eq u w) (Singleton.singleton v) EmptyCollection.emptyCollection))","decl":"theorem neighborSet_subgraphOfAdj [DecidableEq V] {u v w : V} (hvw : G.Adj v w) :\n    (G.subgraphOfAdj hvw).neighborSet u =\n    (if u = v then {w} else ∅) ∪ if u = w then {v} else ∅ := by\n  split_ifs <;> subst_vars <;> simp [*]\n\n"}
{"name":"SimpleGraph.singletonSubgraph_fst_le_subgraphOfAdj","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nu v : V\nh : G.Adj u v\n⊢ LE.le (G.singletonSubgraph u) (G.subgraphOfAdj h)","decl":"theorem singletonSubgraph_fst_le_subgraphOfAdj {u v : V} {h : G.Adj u v} :\n    G.singletonSubgraph u ≤ G.subgraphOfAdj h := by\n  simp\n\n"}
{"name":"SimpleGraph.singletonSubgraph_snd_le_subgraphOfAdj","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nu v : V\nh : G.Adj u v\n⊢ LE.le (G.singletonSubgraph v) (G.subgraphOfAdj h)","decl":"theorem singletonSubgraph_snd_le_subgraphOfAdj {u v : V} {h : G.Adj u v} :\n    G.singletonSubgraph v ≤ G.subgraphOfAdj h := by\n  simp\n\n"}
{"name":"SimpleGraph.support_subgraphOfAdj","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nu v : V\nh : G.Adj u v\n⊢ Eq (G.subgraphOfAdj h).support (Insert.insert u (Singleton.singleton v))","decl":"@[simp]\nlemma support_subgraphOfAdj {u v : V} (h : G.Adj u v) :\n    (G.subgraphOfAdj h).support = {u , v} := by\n  ext\n  rw [Subgraph.mem_support]\n  simp only [subgraphOfAdj_adj, Sym2.eq, Sym2.rel_iff', Prod.mk.injEq, Prod.swap_prod_mk]\n  refine ⟨?_, fun h ↦ h.elim (fun hl ↦ ⟨v, .inl ⟨hl.symm, rfl⟩⟩) fun hr ↦ ⟨u, .inr ⟨rfl, hr.symm⟩⟩⟩\n  rintro ⟨_, hw⟩\n  exact hw.elim (fun h1 ↦ .inl h1.1.symm) fun hr ↦ .inr hr.2.symm\n\n"}
{"name":"SimpleGraph.Subgraph.verts_coeSubgraph","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nG' : G.Subgraph\nG'' : G'.coe.Subgraph\n⊢ Eq (SimpleGraph.Subgraph.coeSubgraph G'').verts (Set.image Subtype.val G''.verts)","decl":"@[simp]\nlemma verts_coeSubgraph {G' : Subgraph G} (G'' : Subgraph G'.coe) :\n    G''.coeSubgraph.verts = (G''.verts : Set V) := rfl\n\n"}
{"name":"SimpleGraph.Subgraph.coeSubgraph_adj","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nG' : G.Subgraph\nG'' : G'.coe.Subgraph\nv w : V\n⊢ Iff ((SimpleGraph.Subgraph.coeSubgraph G'').Adj v w) (Exists fun hv => Exists fun hw => G''.Adj ⟨v, hv⟩ ⟨w, hw⟩)","decl":"lemma coeSubgraph_adj {G' : G.Subgraph} (G'' : G'.coe.Subgraph) (v w : V) :\n    (G'.coeSubgraph G'').Adj v w ↔\n      ∃ (hv : v ∈ G'.verts) (hw : w ∈ G'.verts), G''.Adj ⟨v, hv⟩ ⟨w, hw⟩ := by\n  simp [Relation.Map]\n\n"}
{"name":"SimpleGraph.Subgraph.restrict_adj","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nG' G'' : G.Subgraph\nv w : ↑G'.verts\n⊢ Iff ((SimpleGraph.Subgraph.restrict G'').Adj v w) (And (G'.Adj ↑v ↑w) (G''.Adj ↑v ↑w))","decl":"lemma restrict_adj {G' G'' : G.Subgraph} (v w : G'.verts) :\n    (G'.restrict G'').Adj v w ↔ G'.Adj v w ∧ G''.Adj v w := Iff.rfl\n\n"}
{"name":"SimpleGraph.Subgraph.restrict_coeSubgraph","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nG' : G.Subgraph\nG'' : G'.coe.Subgraph\n⊢ Eq (SimpleGraph.Subgraph.restrict (SimpleGraph.Subgraph.coeSubgraph G'')) G''","decl":"theorem restrict_coeSubgraph {G' : G.Subgraph} (G'' : G'.coe.Subgraph) :\n    Subgraph.restrict (Subgraph.coeSubgraph G'') = G'' := by\n  ext\n  · simp\n  · rw [restrict_adj, coeSubgraph_adj]\n    simpa using G''.adj_sub\n\n"}
{"name":"SimpleGraph.Subgraph.coeSubgraph_injective","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nG' : G.Subgraph\n⊢ Function.Injective SimpleGraph.Subgraph.coeSubgraph","decl":"theorem coeSubgraph_injective (G' : G.Subgraph) :\n    Function.Injective (Subgraph.coeSubgraph : G'.coe.Subgraph → G.Subgraph) :=\n  Function.LeftInverse.injective restrict_coeSubgraph\n\n"}
{"name":"SimpleGraph.Subgraph.coeSubgraph_le","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nH : G.Subgraph\nH' : H.coe.Subgraph\n⊢ LE.le (SimpleGraph.Subgraph.coeSubgraph H') H","decl":"lemma coeSubgraph_le {H : G.Subgraph} (H' : H.coe.Subgraph) :\n    Subgraph.coeSubgraph H' ≤ H := by\n  constructor\n  · simp\n  · rintro v w ⟨_, _, h, rfl, rfl⟩\n    exact H'.adj_sub h\n\n"}
{"name":"SimpleGraph.Subgraph.coeSubgraph_restrict_eq","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nH H' : G.Subgraph\n⊢ Eq (SimpleGraph.Subgraph.coeSubgraph (SimpleGraph.Subgraph.restrict H')) (Min.min H H')","decl":"lemma coeSubgraph_restrict_eq {H : G.Subgraph} (H' : G.Subgraph) :\n    Subgraph.coeSubgraph (H.restrict H') = H ⊓ H' := by\n  ext\n  · simp [and_comm]\n  · simp_rw [coeSubgraph_adj, restrict_adj]\n    simp only [exists_and_left, exists_prop, inf_adj, and_congr_right_iff]\n    intro h\n    simp [H.edge_vert h, H.edge_vert h.symm]\n\n"}
{"name":"SimpleGraph.Subgraph.deleteEdges_verts","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nG' : G.Subgraph\ns : Set (Sym2 V)\n⊢ Eq (G'.deleteEdges s).verts G'.verts","decl":"@[simp]\ntheorem deleteEdges_verts : (G'.deleteEdges s).verts = G'.verts :=\n  rfl\n\n"}
{"name":"SimpleGraph.Subgraph.deleteEdges_adj","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nG' : G.Subgraph\ns : Set (Sym2 V)\nv w : V\n⊢ Iff ((G'.deleteEdges s).Adj v w) (And (G'.Adj v w) (Not (Membership.mem s (Sym2.mk { fst := v, snd := w }))))","decl":"@[simp]\ntheorem deleteEdges_adj (v w : V) : (G'.deleteEdges s).Adj v w ↔ G'.Adj v w ∧ ¬s(v, w) ∈ s :=\n  Iff.rfl\n\n"}
{"name":"SimpleGraph.Subgraph.deleteEdges_deleteEdges","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nG' : G.Subgraph\ns s' : Set (Sym2 V)\n⊢ Eq ((G'.deleteEdges s).deleteEdges s') (G'.deleteEdges (Union.union s s'))","decl":"@[simp]\ntheorem deleteEdges_deleteEdges (s s' : Set (Sym2 V)) :\n    (G'.deleteEdges s).deleteEdges s' = G'.deleteEdges (s ∪ s') := by\n  ext <;> simp [and_assoc, not_or]\n\n"}
{"name":"SimpleGraph.Subgraph.deleteEdges_empty_eq","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nG' : G.Subgraph\n⊢ Eq (G'.deleteEdges EmptyCollection.emptyCollection) G'","decl":"@[simp]\ntheorem deleteEdges_empty_eq : G'.deleteEdges ∅ = G' := by\n  ext <;> simp\n\n"}
{"name":"SimpleGraph.Subgraph.deleteEdges_spanningCoe_eq","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nG' : G.Subgraph\ns : Set (Sym2 V)\n⊢ Eq (G'.spanningCoe.deleteEdges s) (G'.deleteEdges s).spanningCoe","decl":"@[simp]\ntheorem deleteEdges_spanningCoe_eq :\n    G'.spanningCoe.deleteEdges s = (G'.deleteEdges s).spanningCoe := by\n  ext\n  simp\n\n"}
{"name":"SimpleGraph.Subgraph.deleteEdges_coe_eq","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nG' : G.Subgraph\ns : Set (Sym2 ↑G'.verts)\n⊢ Eq (G'.coe.deleteEdges s) (G'.deleteEdges (Set.image (Sym2.map Subtype.val) s)).coe","decl":"theorem deleteEdges_coe_eq (s : Set (Sym2 G'.verts)) :\n    G'.coe.deleteEdges s = (G'.deleteEdges (Sym2.map (↑) '' s)).coe := by\n  ext ⟨v, hv⟩ ⟨w, hw⟩\n  simp only [SimpleGraph.deleteEdges_adj, coe_adj, deleteEdges_adj, Set.mem_image, not_exists,\n    not_and, and_congr_right_iff]\n  intro\n  constructor\n  · intro hs\n    refine Sym2.ind ?_\n    rintro ⟨v', hv'⟩ ⟨w', hw'⟩\n    simp only [Sym2.map_pair_eq, Sym2.eq]\n    contrapose!\n    rintro (_ | _) <;> simpa only [Sym2.eq_swap]\n  · intro h' hs\n    exact h' _ hs rfl\n\n"}
{"name":"SimpleGraph.Subgraph.coe_deleteEdges_eq","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nG' : G.Subgraph\ns : Set (Sym2 V)\n⊢ Eq (G'.deleteEdges s).coe (G'.coe.deleteEdges (Set.preimage (Sym2.map Subtype.val) s))","decl":"theorem coe_deleteEdges_eq (s : Set (Sym2 V)) :\n    (G'.deleteEdges s).coe = G'.coe.deleteEdges (Sym2.map (↑) ⁻¹' s) := by\n  ext ⟨v, hv⟩ ⟨w, hw⟩\n  simp\n\n"}
{"name":"SimpleGraph.Subgraph.deleteEdges_le","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nG' : G.Subgraph\ns : Set (Sym2 V)\n⊢ LE.le (G'.deleteEdges s) G'","decl":"theorem deleteEdges_le : G'.deleteEdges s ≤ G' := by\n  constructor <;> simp +contextual [subset_rfl]\n\n"}
{"name":"SimpleGraph.Subgraph.deleteEdges_le_of_le","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nG' : G.Subgraph\ns s' : Set (Sym2 V)\nh : HasSubset.Subset s s'\n⊢ LE.le (G'.deleteEdges s') (G'.deleteEdges s)","decl":"theorem deleteEdges_le_of_le {s s' : Set (Sym2 V)} (h : s ⊆ s') :\n    G'.deleteEdges s' ≤ G'.deleteEdges s := by\n  constructor <;> simp +contextual only [deleteEdges_verts, deleteEdges_adj,\n    true_and, and_imp, subset_rfl]\n  exact fun _ _ _ hs' hs ↦ hs' (h hs)\n\n"}
{"name":"SimpleGraph.Subgraph.deleteEdges_inter_edgeSet_left_eq","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nG' : G.Subgraph\ns : Set (Sym2 V)\n⊢ Eq (G'.deleteEdges (Inter.inter G'.edgeSet s)) (G'.deleteEdges s)","decl":"@[simp]\ntheorem deleteEdges_inter_edgeSet_left_eq :\n    G'.deleteEdges (G'.edgeSet ∩ s) = G'.deleteEdges s := by\n  ext <;> simp +contextual [imp_false]\n\n"}
{"name":"SimpleGraph.Subgraph.deleteEdges_inter_edgeSet_right_eq","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nG' : G.Subgraph\ns : Set (Sym2 V)\n⊢ Eq (G'.deleteEdges (Inter.inter s G'.edgeSet)) (G'.deleteEdges s)","decl":"@[simp]\ntheorem deleteEdges_inter_edgeSet_right_eq :\n    G'.deleteEdges (s ∩ G'.edgeSet) = G'.deleteEdges s := by\n  ext <;> simp +contextual [imp_false]\n\n"}
{"name":"SimpleGraph.Subgraph.coe_deleteEdges_le","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nG' : G.Subgraph\ns : Set (Sym2 V)\n⊢ LE.le (G'.deleteEdges s).coe G'.coe","decl":"theorem coe_deleteEdges_le : (G'.deleteEdges s).coe ≤ (G'.coe : SimpleGraph G'.verts) := by\n  intro v w\n  simp +contextual\n\n"}
{"name":"SimpleGraph.Subgraph.spanningCoe_deleteEdges_le","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nG' : G.Subgraph\ns : Set (Sym2 V)\n⊢ LE.le (G'.deleteEdges s).spanningCoe G'.spanningCoe","decl":"theorem spanningCoe_deleteEdges_le (G' : G.Subgraph) (s : Set (Sym2 V)) :\n    (G'.deleteEdges s).spanningCoe ≤ G'.spanningCoe :=\n  spanningCoe_le_of_le (deleteEdges_le s)\n\n"}
{"name":"SimpleGraph.Subgraph.induce_verts","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nG' : G.Subgraph\ns : Set V\n⊢ Eq (G'.induce s).verts s","decl":"/-- The induced subgraph of a subgraph. The expectation is that `s ⊆ G'.verts` for the usual\nnotion of an induced subgraph, but, in general, `s` is taken to be the new vertex set and edges\nare induced from the subgraph `G'`. -/\n@[simps]\ndef induce (G' : G.Subgraph) (s : Set V) : G.Subgraph where\n  verts := s\n  Adj u v := u ∈ s ∧ v ∈ s ∧ G'.Adj u v\n  adj_sub h := G'.adj_sub h.2.2\n  edge_vert h := h.1\n  symm _ _ h := ⟨h.2.1, h.1, G'.symm h.2.2⟩\n\n"}
{"name":"SimpleGraph.Subgraph.induce_adj","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nG' : G.Subgraph\ns : Set V\nu v : V\n⊢ Eq ((G'.induce s).Adj u v) (And (Membership.mem s u) (And (Membership.mem s v) (G'.Adj u v)))","decl":"/-- The induced subgraph of a subgraph. The expectation is that `s ⊆ G'.verts` for the usual\nnotion of an induced subgraph, but, in general, `s` is taken to be the new vertex set and edges\nare induced from the subgraph `G'`. -/\n@[simps]\ndef induce (G' : G.Subgraph) (s : Set V) : G.Subgraph where\n  verts := s\n  Adj u v := u ∈ s ∧ v ∈ s ∧ G'.Adj u v\n  adj_sub h := G'.adj_sub h.2.2\n  edge_vert h := h.1\n  symm _ _ h := ⟨h.2.1, h.1, G'.symm h.2.2⟩\n\n"}
{"name":"SimpleGraph.induce_eq_coe_induce_top","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\ns : Set V\n⊢ Eq (SimpleGraph.induce s G) (Top.top.induce s).coe","decl":"theorem _root_.SimpleGraph.induce_eq_coe_induce_top (s : Set V) :\n    G.induce s = ((⊤ : G.Subgraph).induce s).coe := by\n  ext\n  simp\n\n"}
{"name":"SimpleGraph.Subgraph.induce_mono","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nG' G'' : G.Subgraph\ns s' : Set V\nhg : LE.le G' G''\nhs : HasSubset.Subset s s'\n⊢ LE.le (G'.induce s) (G''.induce s')","decl":"theorem induce_mono (hg : G' ≤ G'') (hs : s ⊆ s') : G'.induce s ≤ G''.induce s' := by\n  constructor\n  · simp [hs]\n  · simp +contextual only [induce_adj, and_imp]\n    intro v w hv hw ha\n    exact ⟨hs hv, hs hw, hg.2 ha⟩\n\n"}
{"name":"SimpleGraph.Subgraph.induce_mono_left","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nG' G'' : G.Subgraph\ns : Set V\nhg : LE.le G' G''\n⊢ LE.le (G'.induce s) (G''.induce s)","decl":"@[gcongr, mono]\ntheorem induce_mono_left (hg : G' ≤ G'') : G'.induce s ≤ G''.induce s :=\n  induce_mono hg subset_rfl\n\n"}
{"name":"SimpleGraph.Subgraph.induce_mono_right","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nG' : G.Subgraph\ns s' : Set V\nhs : HasSubset.Subset s s'\n⊢ LE.le (G'.induce s) (G'.induce s')","decl":"@[gcongr, mono]\ntheorem induce_mono_right (hs : s ⊆ s') : G'.induce s ≤ G'.induce s' :=\n  induce_mono le_rfl hs\n\n"}
{"name":"SimpleGraph.Subgraph.induce_empty","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nG' : G.Subgraph\n⊢ Eq (G'.induce EmptyCollection.emptyCollection) Bot.bot","decl":"@[simp]\ntheorem induce_empty : G'.induce ∅ = ⊥ := by\n  ext <;> simp\n\n"}
{"name":"SimpleGraph.Subgraph.induce_self_verts","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nG' : G.Subgraph\n⊢ Eq (G'.induce G'.verts) G'","decl":"@[simp]\ntheorem induce_self_verts : G'.induce G'.verts = G' := by\n  ext\n  · simp\n  · constructor <;>\n      simp +contextual only [induce_adj, imp_true_iff, and_true]\n    exact fun ha ↦ ⟨G'.edge_vert ha, G'.edge_vert ha.symm⟩\n\n"}
{"name":"SimpleGraph.Subgraph.le_induce_top_verts","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nG' : G.Subgraph\n⊢ LE.le G' (Top.top.induce G'.verts)","decl":"lemma le_induce_top_verts : G' ≤ (⊤ : G.Subgraph).induce G'.verts :=\n  calc G' = G'.induce G'.verts               := Subgraph.induce_self_verts.symm\n       _  ≤ (⊤ : G.Subgraph).induce G'.verts := Subgraph.induce_mono_left le_top\n\n"}
{"name":"SimpleGraph.Subgraph.le_induce_union","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nG' : G.Subgraph\ns s' : Set V\n⊢ LE.le (Max.max (G'.induce s) (G'.induce s')) (G'.induce (Union.union s s'))","decl":"lemma le_induce_union : G'.induce s ⊔ G'.induce s' ≤ G'.induce (s ∪ s') := by\n  constructor\n  · simp only [verts_sup, induce_verts, Set.Subset.rfl]\n  · simp only [sup_adj, induce_adj, Set.mem_union]\n    rintro v w (h | h) <;> simp [h]\n\n"}
{"name":"SimpleGraph.Subgraph.le_induce_union_left","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nG' : G.Subgraph\ns s' : Set V\n⊢ LE.le (G'.induce s) (G'.induce (Union.union s s'))","decl":"lemma le_induce_union_left : G'.induce s ≤ G'.induce (s ∪ s') := by\n  exact (sup_le_iff.mp le_induce_union).1\n\n"}
{"name":"SimpleGraph.Subgraph.le_induce_union_right","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nG' : G.Subgraph\ns s' : Set V\n⊢ LE.le (G'.induce s') (G'.induce (Union.union s s'))","decl":"lemma le_induce_union_right : G'.induce s' ≤ G'.induce (s ∪ s') := by\n  exact (sup_le_iff.mp le_induce_union).2\n\n"}
{"name":"SimpleGraph.Subgraph.singletonSubgraph_eq_induce","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nv : V\n⊢ Eq (G.singletonSubgraph v) (Top.top.induce (Singleton.singleton v))","decl":"theorem singletonSubgraph_eq_induce {v : V} :\n    G.singletonSubgraph v = (⊤ : G.Subgraph).induce {v} := by\n  ext <;> simp +contextual [-Set.bot_eq_empty, Prop.bot_eq_false]\n\n"}
{"name":"SimpleGraph.Subgraph.subgraphOfAdj_eq_induce","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nv w : V\nhvw : G.Adj v w\n⊢ Eq (G.subgraphOfAdj hvw) (Top.top.induce (Insert.insert v (Singleton.singleton w)))","decl":"theorem subgraphOfAdj_eq_induce {v w : V} (hvw : G.Adj v w) :\n    G.subgraphOfAdj hvw = (⊤ : G.Subgraph).induce {v, w} := by\n  ext\n  · simp\n  · constructor\n    · intro h\n      simp only [subgraphOfAdj_adj, Sym2.eq, Sym2.rel_iff] at h\n      obtain ⟨rfl, rfl⟩ | ⟨rfl, rfl⟩ := h <;> simp [hvw, hvw.symm]\n    · intro h\n      simp only [induce_adj, Set.mem_insert_iff, Set.mem_singleton_iff, top_adj] at h\n      obtain ⟨rfl | rfl, rfl | rfl, ha⟩ := h <;> first |exact (ha.ne rfl).elim|simp\n\n"}
{"name":"SimpleGraph.Subgraph.deleteVerts_verts","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nG' : G.Subgraph\ns : Set V\n⊢ Eq (G'.deleteVerts s).verts (SDiff.sdiff G'.verts s)","decl":"theorem deleteVerts_verts : (G'.deleteVerts s).verts = G'.verts \\ s :=\n  rfl\n\n"}
{"name":"SimpleGraph.Subgraph.deleteVerts_adj","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nG' : G.Subgraph\ns : Set V\nu v : V\n⊢ Iff ((G'.deleteVerts s).Adj u v) (And (Membership.mem G'.verts u) (And (Not (Membership.mem s u)) (And (Membership.mem G'.verts v) (And (Not (Membership.mem s v)) (G'.Adj u v)))))","decl":"theorem deleteVerts_adj {u v : V} :\n    (G'.deleteVerts s).Adj u v ↔ u ∈ G'.verts ∧ ¬u ∈ s ∧ v ∈ G'.verts ∧ ¬v ∈ s ∧ G'.Adj u v := by\n  simp [and_assoc]\n\n"}
{"name":"SimpleGraph.Subgraph.deleteVerts_deleteVerts","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nG' : G.Subgraph\ns s' : Set V\n⊢ Eq ((G'.deleteVerts s).deleteVerts s') (G'.deleteVerts (Union.union s s'))","decl":"@[simp]\ntheorem deleteVerts_deleteVerts (s s' : Set V) :\n    (G'.deleteVerts s).deleteVerts s' = G'.deleteVerts (s ∪ s') := by\n  ext <;> simp +contextual [not_or, and_assoc]\n\n"}
{"name":"SimpleGraph.Subgraph.deleteVerts_empty","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nG' : G.Subgraph\n⊢ Eq (G'.deleteVerts EmptyCollection.emptyCollection) G'","decl":"@[simp]\ntheorem deleteVerts_empty : G'.deleteVerts ∅ = G' := by\n  simp [deleteVerts]\n\n"}
{"name":"SimpleGraph.Subgraph.deleteVerts_le","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nG' : G.Subgraph\ns : Set V\n⊢ LE.le (G'.deleteVerts s) G'","decl":"theorem deleteVerts_le : G'.deleteVerts s ≤ G' := by\n  constructor <;> simp [Set.diff_subset]\n\n"}
{"name":"SimpleGraph.Subgraph.deleteVerts_mono","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\ns : Set V\nG' G'' : G.Subgraph\nh : LE.le G' G''\n⊢ LE.le (G'.deleteVerts s) (G''.deleteVerts s)","decl":"@[gcongr, mono]\ntheorem deleteVerts_mono {G' G'' : G.Subgraph} (h : G' ≤ G'') :\n    G'.deleteVerts s ≤ G''.deleteVerts s :=\n  induce_mono h (Set.diff_subset_diff_left h.1)\n\n"}
{"name":"SimpleGraph.Subgraph.deleteVerts_anti","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nG' : G.Subgraph\ns s' : Set V\nh : HasSubset.Subset s s'\n⊢ LE.le (G'.deleteVerts s') (G'.deleteVerts s)","decl":"@[gcongr, mono]\ntheorem deleteVerts_anti {s s' : Set V} (h : s ⊆ s') : G'.deleteVerts s' ≤ G'.deleteVerts s :=\n  induce_mono (le_refl _) (Set.diff_subset_diff_right h)\n\n"}
{"name":"SimpleGraph.Subgraph.deleteVerts_inter_verts_left_eq","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nG' : G.Subgraph\ns : Set V\n⊢ Eq (G'.deleteVerts (Inter.inter G'.verts s)) (G'.deleteVerts s)","decl":"@[simp]\ntheorem deleteVerts_inter_verts_left_eq : G'.deleteVerts (G'.verts ∩ s) = G'.deleteVerts s := by\n  ext <;> simp +contextual [imp_false]\n\n"}
{"name":"SimpleGraph.Subgraph.deleteVerts_inter_verts_set_right_eq","module":"Mathlib.Combinatorics.SimpleGraph.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nG' : G.Subgraph\ns : Set V\n⊢ Eq (G'.deleteVerts (Inter.inter s G'.verts)) (G'.deleteVerts s)","decl":"@[simp]\ntheorem deleteVerts_inter_verts_set_right_eq :\n    G'.deleteVerts (s ∩ G'.verts) = G'.deleteVerts s := by\n  ext <;> simp +contextual [imp_false]\n\n"}
