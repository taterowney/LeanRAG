{"name":"List.nextOr_nil","module":"Mathlib.Data.List.Cycle","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nx d : α\n⊢ Eq (List.nil.nextOr x d) d","decl":"@[simp]\ntheorem nextOr_nil (x d : α) : nextOr [] x d = d :=\n  rfl\n\n"}
{"name":"List.nextOr_singleton","module":"Mathlib.Data.List.Cycle","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nx y d : α\n⊢ Eq ((List.cons y List.nil).nextOr x d) d","decl":"@[simp]\ntheorem nextOr_singleton (x y d : α) : nextOr [y] x d = d :=\n  rfl\n\n"}
{"name":"List.nextOr_self_cons_cons","module":"Mathlib.Data.List.Cycle","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nxs : List α\nx y d : α\n⊢ Eq ((List.cons x (List.cons y xs)).nextOr x d) y","decl":"@[simp]\ntheorem nextOr_self_cons_cons (xs : List α) (x y d : α) : nextOr (x :: y :: xs) x d = y :=\n  if_pos rfl\n\n"}
{"name":"List.nextOr_cons_of_ne","module":"Mathlib.Data.List.Cycle","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nxs : List α\ny x d : α\nh : Ne x y\n⊢ Eq ((List.cons y xs).nextOr x d) (xs.nextOr x d)","decl":"theorem nextOr_cons_of_ne (xs : List α) (y x d : α) (h : x ≠ y) :\n    nextOr (y :: xs) x d = nextOr xs x d := by\n  cases' xs with z zs\n  · rfl\n  · exact if_neg h\n\n"}
{"name":"List.nextOr_eq_nextOr_of_mem_of_ne","module":"Mathlib.Data.List.Cycle","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nxs : List α\nx d d' : α\nx_mem : Membership.mem xs x\nx_ne : Ne x (xs.getLast ⋯)\n⊢ Eq (xs.nextOr x d) (xs.nextOr x d')","decl":"/-- `nextOr` does not depend on the default value, if the next value appears. -/\ntheorem nextOr_eq_nextOr_of_mem_of_ne (xs : List α) (x d d' : α) (x_mem : x ∈ xs)\n    (x_ne : x ≠ xs.getLast (ne_nil_of_mem x_mem)) : nextOr xs x d = nextOr xs x d' := by\n  induction' xs with y ys IH\n  · cases x_mem\n  cases' ys with z zs\n  · simp at x_mem x_ne\n    contradiction\n  by_cases h : x = y\n  · rw [h, nextOr_self_cons_cons, nextOr_self_cons_cons]\n  · rw [nextOr, nextOr, IH]\n    · simpa [h] using x_mem\n    · simpa using x_ne\n\n"}
{"name":"List.mem_of_nextOr_ne","module":"Mathlib.Data.List.Cycle","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nxs : List α\nx d : α\nh : Ne (xs.nextOr x d) d\n⊢ Membership.mem xs x","decl":"theorem mem_of_nextOr_ne {xs : List α} {x d : α} (h : nextOr xs x d ≠ d) : x ∈ xs := by\n  induction' xs with y ys IH\n  · simp at h\n  cases' ys with z zs\n  · simp at h\n  · by_cases hx : x = y\n    · simp [hx]\n    · rw [nextOr_cons_of_ne _ _ _ _ hx] at h\n      simpa [hx] using IH h\n\n"}
{"name":"List.nextOr_concat","module":"Mathlib.Data.List.Cycle","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nxs : List α\nx d : α\nh : Not (Membership.mem xs x)\n⊢ Eq ((HAppend.hAppend xs (List.cons x List.nil)).nextOr x d) d","decl":"theorem nextOr_concat {xs : List α} {x : α} (d : α) (h : x ∉ xs) : nextOr (xs ++ [x]) x d = d := by\n  induction' xs with z zs IH\n  · simp\n  · obtain ⟨hz, hzs⟩ := not_or.mp (mt mem_cons.2 h)\n    rw [cons_append, nextOr_cons_of_ne _ _ _ _ hz, IH hzs]\n\n"}
{"name":"List.nextOr_mem","module":"Mathlib.Data.List.Cycle","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nxs : List α\nx d : α\nhd : Membership.mem xs d\n⊢ Membership.mem xs (xs.nextOr x d)","decl":"theorem nextOr_mem {xs : List α} {x d : α} (hd : d ∈ xs) : nextOr xs x d ∈ xs := by\n  revert hd\n  suffices ∀ xs' : List α, (∀ x ∈ xs, x ∈ xs') → d ∈ xs' → nextOr xs x d ∈ xs' by\n    exact this xs fun _ => id\n  intro xs' hxs' hd\n  induction' xs with y ys ih\n  · exact hd\n  cases' ys with z zs\n  · exact hd\n  rw [nextOr]\n  split_ifs with h\n  · exact hxs' _ (mem_cons_of_mem _ (mem_cons_self _ _))\n  · exact ih fun _ h => hxs' _ (mem_cons_of_mem _ h)\n\n"}
{"name":"List.next_singleton","module":"Mathlib.Data.List.Cycle","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nx y : α\nh : Membership.mem (List.cons y List.nil) x\n⊢ Eq ((List.cons y List.nil).next x h) y","decl":"@[simp]\ntheorem next_singleton (x y : α) (h : x ∈ [y]) : next [y] x h = y :=\n  rfl\n\n"}
{"name":"List.prev_singleton","module":"Mathlib.Data.List.Cycle","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nx y : α\nh : Membership.mem (List.cons y List.nil) x\n⊢ Eq ((List.cons y List.nil).prev x h) y","decl":"@[simp]\ntheorem prev_singleton (x y : α) (h : x ∈ [y]) : prev [y] x h = y :=\n  rfl\n\n"}
{"name":"List.next_cons_cons_eq'","module":"Mathlib.Data.List.Cycle","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nl : List α\nx y z : α\nh : Membership.mem (List.cons y (List.cons z l)) x\nhx : Eq x y\n⊢ Eq ((List.cons y (List.cons z l)).next x h) z","decl":"theorem next_cons_cons_eq' (y z : α) (h : x ∈ y :: z :: l) (hx : x = y) :\n    next (y :: z :: l) x h = z := by rw [next, nextOr, if_pos hx]\n\n"}
{"name":"List.next_cons_cons_eq","module":"Mathlib.Data.List.Cycle","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nl : List α\nx z : α\nh : Membership.mem (List.cons x (List.cons z l)) x\n⊢ Eq ((List.cons x (List.cons z l)).next x h) z","decl":"@[simp]\ntheorem next_cons_cons_eq (z : α) (h : x ∈ x :: z :: l) : next (x :: z :: l) x h = z :=\n  next_cons_cons_eq' l x x z h rfl\n\n"}
{"name":"List.next_ne_head_ne_getLast","module":"Mathlib.Data.List.Cycle","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nl : List α\nx : α\nh✝ : Membership.mem l x\ny : α\nh : Membership.mem (List.cons y l) x\nhy : Ne x y\nhx : Ne x ((List.cons y l).getLast ⋯)\n⊢ Eq ((List.cons y l).next x h) (l.next x ⋯)","decl":"theorem next_ne_head_ne_getLast (h : x ∈ l) (y : α) (h : x ∈ y :: l) (hy : x ≠ y)\n    (hx : x ≠ getLast (y :: l) (cons_ne_nil _ _)) :\n    next (y :: l) x h = next l x (by simpa [hy] using h) := by\n  rw [next, next, nextOr_cons_of_ne _ _ _ _ hy, nextOr_eq_nextOr_of_mem_of_ne]\n  · rwa [getLast_cons] at hx\n    exact ne_nil_of_mem (by assumption)\n  · rwa [getLast_cons] at hx\n\n"}
{"name":"List.next_cons_concat","module":"Mathlib.Data.List.Cycle","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nl : List α\nx y : α\nhy : Ne x y\nhx : Not (Membership.mem l x)\nh : optParam (Membership.mem (HAppend.hAppend (List.cons y l) (List.cons x List.nil)) x) ⋯\n⊢ Eq ((HAppend.hAppend (List.cons y l) (List.cons x List.nil)).next x h) y","decl":"theorem next_cons_concat (y : α) (hy : x ≠ y) (hx : x ∉ l)\n    (h : x ∈ y :: l ++ [x] := mem_append_right _ (mem_singleton_self x)) :\n    next (y :: l ++ [x]) x h = y := by\n  rw [next, nextOr_concat]\n  · rfl\n  · simp [hy, hx]\n\n"}
{"name":"List.next_getLast_cons","module":"Mathlib.Data.List.Cycle","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nl : List α\nx : α\nh✝ : Membership.mem l x\ny : α\nh : Membership.mem (List.cons y l) x\nhy : Ne x y\nhx : Eq x ((List.cons y l).getLast ⋯)\nhl : l.Nodup\n⊢ Eq ((List.cons y l).next x h) y","decl":"theorem next_getLast_cons (h : x ∈ l) (y : α) (h : x ∈ y :: l) (hy : x ≠ y)\n    (hx : x = getLast (y :: l) (cons_ne_nil _ _)) (hl : Nodup l) : next (y :: l) x h = y := by\n  rw [next, get, ← dropLast_append_getLast (cons_ne_nil y l), hx, nextOr_concat]\n  subst hx\n  intro H\n  obtain ⟨⟨_ | k, hk⟩, hk'⟩ := get_of_mem H\n  · rw [← Option.some_inj] at hk'\n    rw [← get?_eq_get, dropLast_eq_take, get?_eq_getElem?, getElem?_take_of_lt, getElem?_cons_zero,\n      Option.some_inj] at hk'\n    · exact hy (Eq.symm hk')\n    rw [length_cons]\n    exact length_pos_of_mem (by assumption)\n  suffices k + 1 = l.length by simp [this] at hk\n  cases' l with hd tl\n  · simp at hk\n  · rw [nodup_iff_injective_get] at hl\n    rw [length, Nat.succ_inj']\n    refine Fin.val_eq_of_eq <| @hl ⟨k, Nat.lt_of_succ_lt <| by simpa using hk⟩\n      ⟨tl.length, by simp⟩ ?_\n    rw [← Option.some_inj] at hk'\n    rw [← get?_eq_get, dropLast_eq_take, get?_eq_getElem?, getElem?_take_of_lt, getElem?_cons_succ,\n      getElem?_eq_getElem, Option.some_inj] at hk'\n    · rw [get_eq_getElem, hk']\n      simp only [getLast_eq_getElem, length_cons, Nat.succ_eq_add_one, Nat.succ_sub_succ_eq_sub,\n        Nat.sub_zero, get_eq_getElem, getElem_cons_succ]\n    simpa using hk\n\n"}
{"name":"List.prev_getLast_cons'","module":"Mathlib.Data.List.Cycle","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nl : List α\nx y : α\nhxy : Membership.mem (List.cons y l) x\nhx : Eq x y\n⊢ Eq ((List.cons y l).prev x hxy) ((List.cons y l).getLast ⋯)","decl":"theorem prev_getLast_cons' (y : α) (hxy : x ∈ y :: l) (hx : x = y) :\n    prev (y :: l) x hxy = getLast (y :: l) (cons_ne_nil _ _) := by cases l <;> simp [prev, hx]\n\n"}
{"name":"List.prev_getLast_cons","module":"Mathlib.Data.List.Cycle","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nl : List α\nx : α\nh : Membership.mem (List.cons x l) x\n⊢ Eq ((List.cons x l).prev x h) ((List.cons x l).getLast ⋯)","decl":"@[simp]\ntheorem prev_getLast_cons (h : x ∈ x :: l) :\n    prev (x :: l) x h = getLast (x :: l) (cons_ne_nil _ _) :=\n  prev_getLast_cons' l x x h rfl\n\n"}
{"name":"List.prev_cons_cons_eq'","module":"Mathlib.Data.List.Cycle","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nl : List α\nx y z : α\nh : Membership.mem (List.cons y (List.cons z l)) x\nhx : Eq x y\n⊢ Eq ((List.cons y (List.cons z l)).prev x h) ((List.cons z l).getLast ⋯)","decl":"theorem prev_cons_cons_eq' (y z : α) (h : x ∈ y :: z :: l) (hx : x = y) :\n    prev (y :: z :: l) x h = getLast (z :: l) (cons_ne_nil _ _) := by rw [prev, dif_pos hx]\n\n"}
{"name":"List.prev_cons_cons_eq","module":"Mathlib.Data.List.Cycle","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nl : List α\nx z : α\nh : Membership.mem (List.cons x (List.cons z l)) x\n⊢ Eq ((List.cons x (List.cons z l)).prev x h) ((List.cons z l).getLast ⋯)","decl":"theorem prev_cons_cons_eq (z : α) (h : x ∈ x :: z :: l) :\n    prev (x :: z :: l) x h = getLast (z :: l) (cons_ne_nil _ _) :=\n  prev_cons_cons_eq' l x x z h rfl\n\n"}
{"name":"List.prev_cons_cons_of_ne'","module":"Mathlib.Data.List.Cycle","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nl : List α\nx y z : α\nh : Membership.mem (List.cons y (List.cons z l)) x\nhy : Ne x y\nhz : Eq x z\n⊢ Eq ((List.cons y (List.cons z l)).prev x h) y","decl":"theorem prev_cons_cons_of_ne' (y z : α) (h : x ∈ y :: z :: l) (hy : x ≠ y) (hz : x = z) :\n    prev (y :: z :: l) x h = y := by\n  cases l\n  · simp [prev, hy, hz]\n  · rw [prev, dif_neg hy, if_pos hz]\n\n"}
{"name":"List.prev_cons_cons_of_ne","module":"Mathlib.Data.List.Cycle","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nl : List α\nx y : α\nh : Membership.mem (List.cons y (List.cons x l)) x\nhy : Ne x y\n⊢ Eq ((List.cons y (List.cons x l)).prev x h) y","decl":"theorem prev_cons_cons_of_ne (y : α) (h : x ∈ y :: x :: l) (hy : x ≠ y) :\n    prev (y :: x :: l) x h = y :=\n  prev_cons_cons_of_ne' _ _ _ _ _ hy rfl\n\n"}
{"name":"List.prev_ne_cons_cons","module":"Mathlib.Data.List.Cycle","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nl : List α\nx y z : α\nh : Membership.mem (List.cons y (List.cons z l)) x\nhy : Ne x y\nhz : Ne x z\n⊢ Eq ((List.cons y (List.cons z l)).prev x h) ((List.cons z l).prev x ⋯)","decl":"theorem prev_ne_cons_cons (y z : α) (h : x ∈ y :: z :: l) (hy : x ≠ y) (hz : x ≠ z) :\n    prev (y :: z :: l) x h = prev (z :: l) x (by simpa [hy] using h) := by\n  cases l\n  · simp [hy, hz] at h\n  · rw [prev, dif_neg hy, if_neg hz]\n\n"}
{"name":"List.next_mem","module":"Mathlib.Data.List.Cycle","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nl : List α\nx : α\nh : Membership.mem l x\n⊢ Membership.mem l (l.next x h)","decl":"theorem next_mem (h : x ∈ l) : l.next x h ∈ l :=\n  nextOr_mem (get_mem _ _)\n\n"}
{"name":"List.prev_mem","module":"Mathlib.Data.List.Cycle","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nl : List α\nx : α\nh : Membership.mem l x\n⊢ Membership.mem l (l.prev x h)","decl":"theorem prev_mem (h : x ∈ l) : l.prev x h ∈ l := by\n  cases' l with hd tl\n  · simp at h\n  induction' tl with hd' tl hl generalizing hd\n  · simp\n  · by_cases hx : x = hd\n    · simp only [hx, prev_cons_cons_eq]\n      exact mem_cons_of_mem _ (getLast_mem _)\n    · rw [prev, dif_neg hx]\n      split_ifs with hm\n      · exact mem_cons_self _ _\n      · exact mem_cons_of_mem _ (hl _ _)\n\n"}
{"name":"List.next_get","module":"Mathlib.Data.List.Cycle","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nl : List α\nh : l.Nodup\ni : Fin l.length\n⊢ Eq (l.next (l.get i) ⋯) (l.get ⟨HMod.hMod (HAdd.hAdd (↑i) 1) l.length, ⋯⟩)","decl":"theorem next_get (l : List α) (h : Nodup l) (i : Fin l.length) :\n    next l (l.get i) (get_mem _ _) =\n      l.get ⟨(i + 1) % l.length, Nat.mod_lt _ (i.1.zero_le.trans_lt i.2)⟩ :=\n  match l, h, i with\n  | [], _, i => by simpa using i.2\n  | [_], _, _ => by simp\n  | x::y::l, _h, ⟨0, h0⟩ => by\n    have h₁ : get (x :: y :: l) ⟨0, h0⟩ = x := by simp\n    rw [next_cons_cons_eq' _ _ _ _ _ h₁]\n    simp\n  | x::y::l, hn, ⟨i+1, hi⟩ => by\n    have hx' : (x :: y :: l).get ⟨i+1, hi⟩ ≠ x := by\n      intro H\n      suffices (i + 1 : ℕ) = 0 by simpa\n      rw [nodup_iff_injective_get] at hn\n      refine Fin.val_eq_of_eq (@hn ⟨i + 1, hi⟩ ⟨0, by simp⟩ ?_)\n      simpa using H\n    have hi' : i ≤ l.length := Nat.le_of_lt_succ (Nat.succ_lt_succ_iff.1 hi)\n    rcases hi'.eq_or_lt with (hi' | hi')\n    · subst hi'\n      rw [next_getLast_cons]\n      · simp [hi', get]\n      · rw [get_cons_succ]; exact get_mem _ _\n      · exact hx'\n      · simp [getLast_eq_getElem]\n      · exact hn.of_cons\n    · rw [next_ne_head_ne_getLast _ _ _ _ _ hx']\n      · simp only [get_cons_succ]\n        rw [next_get (y::l), ← get_cons_succ (a := x)]\n        · congr\n          dsimp\n          rw [Nat.mod_eq_of_lt (Nat.succ_lt_succ_iff.2 hi'),\n            Nat.mod_eq_of_lt (Nat.succ_lt_succ_iff.2 (Nat.succ_lt_succ_iff.2 hi'))]\n        · simp [Nat.mod_eq_of_lt (Nat.succ_lt_succ_iff.2 hi'), hi']\n        · exact hn.of_cons\n      · rw [getLast_eq_getElem]\n        intro h\n        have := nodup_iff_injective_get.1 hn h\n        simp at this; simp [this] at hi'\n      · rw [get_cons_succ]; exact get_mem _ _\n\n-- Unused variable linter incorrectly reports that `h` is unused here.\n"}
{"name":"List.prev_get","module":"Mathlib.Data.List.Cycle","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nl : List α\nh : l.Nodup\ni : Fin l.length\n⊢ Eq (l.prev (l.get i) ⋯) (l.get ⟨HMod.hMod (HAdd.hAdd (↑i) (HSub.hSub l.length 1)) l.length, ⋯⟩)","decl":"set_option linter.unusedVariables false in\ntheorem prev_get (l : List α) (h : Nodup l) (i : Fin l.length) :\n    prev l (l.get i) (get_mem _ _) =\n      l.get ⟨(i + (l.length - 1)) % l.length, Nat.mod_lt _ i.pos⟩ :=\n  match l with\n  | [] => by simpa using i.2\n  | x::l => by\n    obtain ⟨n, hn⟩ := i\n    induction l generalizing n x with\n    | nil => simp\n    | cons y l hl =>\n      rcases n with (_ | _ | n)\n      · simp [getLast_eq_getElem]\n      · simp only [mem_cons, nodup_cons] at h\n        push_neg at h\n        simp only [List.prev_cons_cons_of_ne _ _ _ _ h.left.left.symm, List.length,\n          List.get, add_comm, Nat.succ_add_sub_one, Nat.mod_self, zero_add]\n      · rw [prev_ne_cons_cons]\n        · convert hl y h.of_cons n.succ (Nat.le_of_succ_le_succ hn) using 1\n          have : ∀ k hk, (y :: l).get ⟨k, hk⟩ = (x :: y :: l).get ⟨k + 1, Nat.succ_lt_succ hk⟩ := by\n            simp [List.get]\n          rw [this]\n          congr\n          simp only [Nat.add_succ_sub_one, add_zero, length]\n          simp only [length, Nat.succ_lt_succ_iff] at hn\n          set k := l.length\n          rw [Nat.succ_add, ← Nat.add_succ, Nat.add_mod_right, Nat.succ_add, ← Nat.add_succ _ k,\n            Nat.add_mod_right, Nat.mod_eq_of_lt, Nat.mod_eq_of_lt]\n          · exact Nat.lt_succ_of_lt hn\n          · exact Nat.succ_lt_succ (Nat.lt_succ_of_lt hn)\n        · intro H\n          suffices n.succ.succ = 0 by simpa\n          suffices Fin.mk _ hn = ⟨0, by omega⟩ by rwa [Fin.mk.inj_iff] at this\n          rw [nodup_iff_injective_get] at h\n          apply h; rw [← H]; simp\n        · intro H\n          suffices n.succ.succ = 1 by simpa\n          suffices Fin.mk _ hn = ⟨1, by omega⟩ by rwa [Fin.mk.inj_iff] at this\n          rw [nodup_iff_injective_get] at h\n          apply h; rw [← H]; simp\n\n"}
{"name":"List.pmap_next_eq_rotate_one","module":"Mathlib.Data.List.Cycle","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nl : List α\nh : l.Nodup\n⊢ Eq (List.pmap l.next l ⋯) (l.rotate 1)","decl":"theorem pmap_next_eq_rotate_one (h : Nodup l) : (l.pmap l.next fun _ h => h) = l.rotate 1 := by\n  apply List.ext_get\n  · simp\n  · intros\n    rw [get_pmap, get_rotate, next_get _ h]\n\n"}
{"name":"List.pmap_prev_eq_rotate_length_sub_one","module":"Mathlib.Data.List.Cycle","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nl : List α\nh : l.Nodup\n⊢ Eq (List.pmap l.prev l ⋯) (l.rotate (HSub.hSub l.length 1))","decl":"theorem pmap_prev_eq_rotate_length_sub_one (h : Nodup l) :\n    (l.pmap l.prev fun _ h => h) = l.rotate (l.length - 1) := by\n  apply List.ext_get\n  · simp\n  · intro n hn hn'\n    rw [get_rotate, get_pmap, prev_get _ h]\n\n"}
{"name":"List.prev_next","module":"Mathlib.Data.List.Cycle","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nl : List α\nh : l.Nodup\nx : α\nhx : Membership.mem l x\n⊢ Eq (l.prev (l.next x hx) ⋯) x","decl":"theorem prev_next (l : List α) (h : Nodup l) (x : α) (hx : x ∈ l) :\n    prev l (next l x hx) (next_mem _ _ _) = x := by\n  obtain ⟨⟨n, hn⟩, rfl⟩ := get_of_mem hx\n  simp only [next_get, prev_get, h, Nat.mod_add_mod]\n  cases' l with hd tl\n  · simp at hn\n  · have : (n + 1 + length tl) % (length tl + 1) = n := by\n      rw [length_cons] at hn\n      rw [add_assoc, add_comm 1, Nat.add_mod_right, Nat.mod_eq_of_lt hn]\n    simp only [length_cons, Nat.succ_sub_succ_eq_sub, Nat.sub_zero, Nat.succ_eq_add_one, this]\n\n"}
{"name":"List.next_prev","module":"Mathlib.Data.List.Cycle","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nl : List α\nh : l.Nodup\nx : α\nhx : Membership.mem l x\n⊢ Eq (l.next (l.prev x hx) ⋯) x","decl":"theorem next_prev (l : List α) (h : Nodup l) (x : α) (hx : x ∈ l) :\n    next l (prev l x hx) (prev_mem _ _ _) = x := by\n  obtain ⟨⟨n, hn⟩, rfl⟩ := get_of_mem hx\n  simp only [next_get, prev_get, h, Nat.mod_add_mod]\n  cases' l with hd tl\n  · simp at hn\n  · have : (n + length tl + 1) % (length tl + 1) = n := by\n      rw [length_cons] at hn\n      rw [add_assoc, Nat.add_mod_right, Nat.mod_eq_of_lt hn]\n    simp [this]\n\n"}
{"name":"List.prev_reverse_eq_next","module":"Mathlib.Data.List.Cycle","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nl : List α\nh : l.Nodup\nx : α\nhx : Membership.mem l x\n⊢ Eq (l.reverse.prev x ⋯) (l.next x hx)","decl":"theorem prev_reverse_eq_next (l : List α) (h : Nodup l) (x : α) (hx : x ∈ l) :\n    prev l.reverse x (mem_reverse.mpr hx) = next l x hx := by\n  obtain ⟨k, hk, rfl⟩ := getElem_of_mem hx\n  have lpos : 0 < l.length := k.zero_le.trans_lt hk\n  have key : l.length - 1 - k < l.length := by omega\n  rw [← getElem_pmap l.next (fun _ h => h) (by simpa using hk)]\n  simp_rw [getElem_eq_getElem_reverse (l := l), pmap_next_eq_rotate_one _ h]\n  rw [← getElem_pmap l.reverse.prev fun _ h => h]\n  · simp_rw [pmap_prev_eq_rotate_length_sub_one _ (nodup_reverse.mpr h), rotate_reverse,\n      length_reverse, Nat.mod_eq_of_lt (Nat.sub_lt lpos Nat.succ_pos'),\n      Nat.sub_sub_self (Nat.succ_le_of_lt lpos)]\n    rw [getElem_eq_getElem_reverse]\n    · simp [Nat.sub_sub_self (Nat.le_sub_one_of_lt hk)]\n  · simpa\n\n"}
{"name":"List.next_reverse_eq_prev","module":"Mathlib.Data.List.Cycle","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nl : List α\nh : l.Nodup\nx : α\nhx : Membership.mem l x\n⊢ Eq (l.reverse.next x ⋯) (l.prev x hx)","decl":"theorem next_reverse_eq_prev (l : List α) (h : Nodup l) (x : α) (hx : x ∈ l) :\n    next l.reverse x (mem_reverse.mpr hx) = prev l x hx := by\n  convert (prev_reverse_eq_next l.reverse (nodup_reverse.mpr h) x (mem_reverse.mpr hx)).symm\n  exact (reverse_reverse l).symm\n\n"}
{"name":"List.isRotated_next_eq","module":"Mathlib.Data.List.Cycle","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nl l' : List α\nh : l.IsRotated l'\nhn : l.Nodup\nx : α\nhx : Membership.mem l x\n⊢ Eq (l.next x hx) (l'.next x ⋯)","decl":"theorem isRotated_next_eq {l l' : List α} (h : l ~r l') (hn : Nodup l) {x : α} (hx : x ∈ l) :\n    l.next x hx = l'.next x (h.mem_iff.mp hx) := by\n  obtain ⟨k, hk, rfl⟩ := get_of_mem hx\n  obtain ⟨n, rfl⟩ := id h\n  rw [next_get _ hn]\n  simp_rw [get_eq_get_rotate _ n k]\n  rw [next_get _ (h.nodup_iff.mp hn), get_eq_get_rotate _ n]\n  simp [add_assoc]\n\n"}
{"name":"List.isRotated_prev_eq","module":"Mathlib.Data.List.Cycle","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nl l' : List α\nh : l.IsRotated l'\nhn : l.Nodup\nx : α\nhx : Membership.mem l x\n⊢ Eq (l.prev x hx) (l'.prev x ⋯)","decl":"theorem isRotated_prev_eq {l l' : List α} (h : l ~r l') (hn : Nodup l) {x : α} (hx : x ∈ l) :\n    l.prev x hx = l'.prev x (h.mem_iff.mp hx) := by\n  rw [← next_reverse_eq_prev _ hn, ← next_reverse_eq_prev _ (h.nodup_iff.mp hn)]\n  exact isRotated_next_eq h.reverse (nodup_reverse.mpr hn) _\n\n"}
{"name":"Cycle.coe_eq_coe","module":"Mathlib.Data.List.Cycle","initialProofState":"α : Type u_1\nl₁ l₂ : List α\n⊢ Iff (Eq ↑l₁ ↑l₂) (l₁.IsRotated l₂)","decl":"@[simp]\ntheorem coe_eq_coe {l₁ l₂ : List α} : (l₁ : Cycle α) = (l₂ : Cycle α) ↔ l₁ ~r l₂ :=\n  @Quotient.eq _ (IsRotated.setoid _) _ _\n\n"}
{"name":"Cycle.mk_eq_coe","module":"Mathlib.Data.List.Cycle","initialProofState":"α : Type u_1\nl : List α\n⊢ Eq (Quot.mk (⇑(List.IsRotated.setoid α)) l) ↑l","decl":"@[simp]\ntheorem mk_eq_coe (l : List α) : Quot.mk _ l = (l : Cycle α) :=\n  rfl\n\n"}
{"name":"Cycle.mk''_eq_coe","module":"Mathlib.Data.List.Cycle","initialProofState":"α : Type u_1\nl : List α\n⊢ Eq (Quotient.mk'' l) ↑l","decl":"@[simp]\ntheorem mk''_eq_coe (l : List α) : Quotient.mk'' l = (l : Cycle α) :=\n  rfl\n\n"}
{"name":"Cycle.coe_cons_eq_coe_append","module":"Mathlib.Data.List.Cycle","initialProofState":"α : Type u_1\nl : List α\na : α\n⊢ Eq ↑(List.cons a l) ↑(HAppend.hAppend l (List.cons a List.nil))","decl":"theorem coe_cons_eq_coe_append (l : List α) (a : α) :\n    (↑(a :: l) : Cycle α) = (↑(l ++ [a]) : Cycle α) :=\n  Quot.sound ⟨1, by rw [rotate_cons_succ, rotate_zero]⟩\n\n"}
{"name":"Cycle.coe_nil","module":"Mathlib.Data.List.Cycle","initialProofState":"α : Type u_1\n⊢ Eq (↑List.nil) Cycle.nil","decl":"@[simp]\ntheorem coe_nil : ↑([] : List α) = @nil α :=\n  rfl\n\n"}
{"name":"Cycle.coe_eq_nil","module":"Mathlib.Data.List.Cycle","initialProofState":"α : Type u_1\nl : List α\n⊢ Iff (Eq (↑l) Cycle.nil) (Eq l List.nil)","decl":"@[simp]\ntheorem coe_eq_nil (l : List α) : (l : Cycle α) = nil ↔ l = [] :=\n  coe_eq_coe.trans isRotated_nil_iff\n\n"}
{"name":"Cycle.empty_eq","module":"Mathlib.Data.List.Cycle","initialProofState":"α : Type u_1\n⊢ Eq EmptyCollection.emptyCollection Cycle.nil","decl":"@[simp]\ntheorem empty_eq : ∅ = @nil α :=\n  rfl\n\n"}
{"name":"Cycle.induction_on","module":"Mathlib.Data.List.Cycle","initialProofState":"α : Type u_1\nC : Cycle α → Prop\ns : Cycle α\nH0 : C Cycle.nil\nHI : ∀ (a : α) (l : List α), C ↑l → C ↑(List.cons a l)\n⊢ C s","decl":"/-- An induction principle for `Cycle`. Use as `induction s`. -/\n@[elab_as_elim, induction_eliminator]\ntheorem induction_on {C : Cycle α → Prop} (s : Cycle α) (H0 : C nil)\n    (HI : ∀ (a) (l : List α), C ↑l → C ↑(a :: l)) : C s :=\n  Quotient.inductionOn' s fun l => by\n    refine List.recOn l ?_ ?_ <;> simp only [mk''_eq_coe, coe_nil]\n    assumption'\n\n"}
{"name":"Cycle.mem_coe_iff","module":"Mathlib.Data.List.Cycle","initialProofState":"α : Type u_1\na : α\nl : List α\n⊢ Iff (Membership.mem (↑l) a) (Membership.mem l a)","decl":"@[simp]\ntheorem mem_coe_iff {a : α} {l : List α} : a ∈ (↑l : Cycle α) ↔ a ∈ l :=\n  Iff.rfl\n\n"}
{"name":"Cycle.not_mem_nil","module":"Mathlib.Data.List.Cycle","initialProofState":"α : Type u_1\na : α\n⊢ Not (Membership.mem Cycle.nil a)","decl":"@[simp]\ntheorem not_mem_nil : ∀ a, a ∉ @nil α :=\n  List.not_mem_nil\n\n"}
{"name":"Cycle.reverse_coe","module":"Mathlib.Data.List.Cycle","initialProofState":"α : Type u_1\nl : List α\n⊢ Eq (↑l).reverse ↑l.reverse","decl":"@[simp]\ntheorem reverse_coe (l : List α) : (l : Cycle α).reverse = l.reverse :=\n  rfl\n\n"}
{"name":"Cycle.mem_reverse_iff","module":"Mathlib.Data.List.Cycle","initialProofState":"α : Type u_1\na : α\ns : Cycle α\n⊢ Iff (Membership.mem s.reverse a) (Membership.mem s a)","decl":"@[simp]\ntheorem mem_reverse_iff {a : α} {s : Cycle α} : a ∈ s.reverse ↔ a ∈ s :=\n  Quot.inductionOn s fun _ => mem_reverse\n\n"}
{"name":"Cycle.reverse_reverse","module":"Mathlib.Data.List.Cycle","initialProofState":"α : Type u_1\ns : Cycle α\n⊢ Eq s.reverse.reverse s","decl":"@[simp]\ntheorem reverse_reverse (s : Cycle α) : s.reverse.reverse = s :=\n  Quot.inductionOn s fun _ => by simp\n\n"}
{"name":"Cycle.reverse_nil","module":"Mathlib.Data.List.Cycle","initialProofState":"α : Type u_1\n⊢ Eq Cycle.nil.reverse Cycle.nil","decl":"@[simp]\ntheorem reverse_nil : nil.reverse = @nil α :=\n  rfl\n\n"}
{"name":"Cycle.length_coe","module":"Mathlib.Data.List.Cycle","initialProofState":"α : Type u_1\nl : List α\n⊢ Eq (↑l).length l.length","decl":"@[simp]\ntheorem length_coe (l : List α) : length (l : Cycle α) = l.length :=\n  rfl\n\n"}
{"name":"Cycle.length_nil","module":"Mathlib.Data.List.Cycle","initialProofState":"α : Type u_1\n⊢ Eq Cycle.nil.length 0","decl":"@[simp]\ntheorem length_nil : length (@nil α) = 0 :=\n  rfl\n\n"}
{"name":"Cycle.length_reverse","module":"Mathlib.Data.List.Cycle","initialProofState":"α : Type u_1\ns : Cycle α\n⊢ Eq s.reverse.length s.length","decl":"@[simp]\ntheorem length_reverse (s : Cycle α) : s.reverse.length = s.length :=\n  Quot.inductionOn s List.length_reverse\n\n"}
{"name":"Cycle.subsingleton_nil","module":"Mathlib.Data.List.Cycle","initialProofState":"α : Type u_1\n⊢ Cycle.nil.Subsingleton","decl":"theorem subsingleton_nil : Subsingleton (@nil α) := Nat.zero_le _\n\n"}
{"name":"Cycle.length_subsingleton_iff","module":"Mathlib.Data.List.Cycle","initialProofState":"α : Type u_1\ns : Cycle α\n⊢ Iff s.Subsingleton (LE.le s.length 1)","decl":"theorem length_subsingleton_iff {s : Cycle α} : Subsingleton s ↔ length s ≤ 1 :=\n  Iff.rfl\n\n"}
{"name":"Cycle.subsingleton_reverse_iff","module":"Mathlib.Data.List.Cycle","initialProofState":"α : Type u_1\ns : Cycle α\n⊢ Iff s.reverse.Subsingleton s.Subsingleton","decl":"@[simp]\ntheorem subsingleton_reverse_iff {s : Cycle α} : s.reverse.Subsingleton ↔ s.Subsingleton := by\n  simp [length_subsingleton_iff]\n\n"}
{"name":"Cycle.Subsingleton.congr","module":"Mathlib.Data.List.Cycle","initialProofState":"α : Type u_1\ns : Cycle α\nh : s.Subsingleton\nx : α\n_hx : Membership.mem s x\ny : α\n_hy : Membership.mem s y\n⊢ Eq x y","decl":"theorem Subsingleton.congr {s : Cycle α} (h : Subsingleton s) :\n    ∀ ⦃x⦄ (_hx : x ∈ s) ⦃y⦄ (_hy : y ∈ s), x = y := by\n  induction' s using Quot.inductionOn with l\n  simp only [length_subsingleton_iff, length_coe, mk_eq_coe, le_iff_lt_or_eq, Nat.lt_add_one_iff,\n    length_eq_zero, length_eq_one, Nat.not_lt_zero, false_or] at h\n  rcases h with (rfl | ⟨z, rfl⟩) <;> simp\n\n"}
{"name":"Cycle.nontrivial_coe_nodup_iff","module":"Mathlib.Data.List.Cycle","initialProofState":"α : Type u_1\nl : List α\nhl : l.Nodup\n⊢ Iff (↑l).Nontrivial (LE.le 2 l.length)","decl":"@[simp]\ntheorem nontrivial_coe_nodup_iff {l : List α} (hl : l.Nodup) :\n    Nontrivial (l : Cycle α) ↔ 2 ≤ l.length := by\n  rw [Nontrivial]\n  rcases l with (_ | ⟨hd, _ | ⟨hd', tl⟩⟩)\n  · simp\n  · simp\n  · simp only [mem_cons, exists_prop, mem_coe_iff, List.length, Ne, Nat.succ_le_succ_iff,\n      Nat.zero_le, iff_true]\n    refine ⟨hd, hd', ?_, by simp⟩\n    simp only [not_or, mem_cons, nodup_cons] at hl\n    exact hl.left.left\n\n"}
{"name":"Cycle.nontrivial_reverse_iff","module":"Mathlib.Data.List.Cycle","initialProofState":"α : Type u_1\ns : Cycle α\n⊢ Iff s.reverse.Nontrivial s.Nontrivial","decl":"@[simp]\ntheorem nontrivial_reverse_iff {s : Cycle α} : s.reverse.Nontrivial ↔ s.Nontrivial := by\n  simp [Nontrivial]\n\n"}
{"name":"Cycle.length_nontrivial","module":"Mathlib.Data.List.Cycle","initialProofState":"α : Type u_1\ns : Cycle α\nh : s.Nontrivial\n⊢ LE.le 2 s.length","decl":"theorem length_nontrivial {s : Cycle α} (h : Nontrivial s) : 2 ≤ length s := by\n  obtain ⟨x, y, hxy, hx, hy⟩ := h\n  induction' s using Quot.inductionOn with l\n  rcases l with (_ | ⟨hd, _ | ⟨hd', tl⟩⟩)\n  · simp at hx\n  · simp only [mem_coe_iff, mk_eq_coe, mem_singleton] at hx hy\n    simp [hx, hy] at hxy\n  · simp [Nat.succ_le_succ_iff]\n\n"}
{"name":"Cycle.nodup_nil","module":"Mathlib.Data.List.Cycle","initialProofState":"α : Type u_1\n⊢ Cycle.nil.Nodup","decl":"@[simp]\nnonrec theorem nodup_nil : Nodup (@nil α) :=\n  nodup_nil\n\n"}
{"name":"Cycle.nodup_coe_iff","module":"Mathlib.Data.List.Cycle","initialProofState":"α : Type u_1\nl : List α\n⊢ Iff (↑l).Nodup l.Nodup","decl":"@[simp]\ntheorem nodup_coe_iff {l : List α} : Nodup (l : Cycle α) ↔ l.Nodup :=\n  Iff.rfl\n\n"}
{"name":"Cycle.nodup_reverse_iff","module":"Mathlib.Data.List.Cycle","initialProofState":"α : Type u_1\ns : Cycle α\n⊢ Iff s.reverse.Nodup s.Nodup","decl":"@[simp]\ntheorem nodup_reverse_iff {s : Cycle α} : s.reverse.Nodup ↔ s.Nodup :=\n  Quot.inductionOn s fun _ => nodup_reverse\n\n"}
{"name":"Cycle.Subsingleton.nodup","module":"Mathlib.Data.List.Cycle","initialProofState":"α : Type u_1\ns : Cycle α\nh : s.Subsingleton\n⊢ s.Nodup","decl":"theorem Subsingleton.nodup {s : Cycle α} (h : Subsingleton s) : Nodup s := by\n  induction' s using Quot.inductionOn with l\n  cases' l with hd tl\n  · simp\n  · have : tl = [] := by simpa [Subsingleton, length_eq_zero, Nat.succ_le_succ_iff] using h\n    simp [this]\n\n"}
{"name":"Cycle.Nodup.nontrivial_iff","module":"Mathlib.Data.List.Cycle","initialProofState":"α : Type u_1\ns : Cycle α\nh : s.Nodup\n⊢ Iff s.Nontrivial (Not s.Subsingleton)","decl":"theorem Nodup.nontrivial_iff {s : Cycle α} (h : Nodup s) : Nontrivial s ↔ ¬Subsingleton s := by\n  rw [length_subsingleton_iff]\n  induction s using Quotient.inductionOn'\n  simp only [mk''_eq_coe, nodup_coe_iff] at h\n  simp [h, Nat.succ_le_iff]\n\n"}
{"name":"Cycle.coe_toMultiset","module":"Mathlib.Data.List.Cycle","initialProofState":"α : Type u_1\nl : List α\n⊢ Eq (↑l).toMultiset ↑l","decl":"@[simp]\ntheorem coe_toMultiset (l : List α) : (l : Cycle α).toMultiset = l :=\n  rfl\n\n"}
{"name":"Cycle.nil_toMultiset","module":"Mathlib.Data.List.Cycle","initialProofState":"α : Type u_1\n⊢ Eq Cycle.nil.toMultiset 0","decl":"@[simp]\ntheorem nil_toMultiset : nil.toMultiset = (0 : Multiset α) :=\n  rfl\n\n"}
{"name":"Cycle.card_toMultiset","module":"Mathlib.Data.List.Cycle","initialProofState":"α : Type u_1\ns : Cycle α\n⊢ Eq s.toMultiset.card s.length","decl":"@[simp]\ntheorem card_toMultiset (s : Cycle α) : Multiset.card s.toMultiset = s.length :=\n  Quotient.inductionOn' s (by simp)\n\n"}
{"name":"Cycle.toMultiset_eq_nil","module":"Mathlib.Data.List.Cycle","initialProofState":"α : Type u_1\ns : Cycle α\n⊢ Iff (Eq s.toMultiset 0) (Eq s Cycle.nil)","decl":"@[simp]\ntheorem toMultiset_eq_nil {s : Cycle α} : s.toMultiset = 0 ↔ s = Cycle.nil :=\n  Quotient.inductionOn' s (by simp)\n\n"}
{"name":"Cycle.map_nil","module":"Mathlib.Data.List.Cycle","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\n⊢ Eq (Cycle.map f Cycle.nil) Cycle.nil","decl":"@[simp]\ntheorem map_nil {β : Type*} (f : α → β) : map f nil = nil :=\n  rfl\n\n"}
{"name":"Cycle.map_coe","module":"Mathlib.Data.List.Cycle","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nl : List α\n⊢ Eq (Cycle.map f ↑l) ↑(List.map f l)","decl":"@[simp]\ntheorem map_coe {β : Type*} (f : α → β) (l : List α) : map f ↑l = List.map f l :=\n  rfl\n\n"}
{"name":"Cycle.map_eq_nil","module":"Mathlib.Data.List.Cycle","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\ns : Cycle α\n⊢ Iff (Eq (Cycle.map f s) Cycle.nil) (Eq s Cycle.nil)","decl":"@[simp]\ntheorem map_eq_nil {β : Type*} (f : α → β) (s : Cycle α) : map f s = nil ↔ s = nil :=\n  Quotient.inductionOn' s (by simp)\n\n"}
{"name":"Cycle.mem_map","module":"Mathlib.Data.List.Cycle","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nb : β\ns : Cycle α\n⊢ Iff (Membership.mem (Cycle.map f s) b) (Exists fun a => And (Membership.mem s a) (Eq (f a) b))","decl":"@[simp]\ntheorem mem_map {β : Type*} {f : α → β} {b : β} {s : Cycle α} :\n    b ∈ s.map f ↔ ∃ a, a ∈ s ∧ f a = b :=\n  Quotient.inductionOn' s (by simp)\n\n"}
{"name":"Cycle.lists_coe","module":"Mathlib.Data.List.Cycle","initialProofState":"α : Type u_1\nl : List α\n⊢ Eq (↑l).lists ↑l.cyclicPermutations","decl":"@[simp]\ntheorem lists_coe (l : List α) : lists (l : Cycle α) = ↑l.cyclicPermutations :=\n  rfl\n\n"}
{"name":"Cycle.mem_lists_iff_coe_eq","module":"Mathlib.Data.List.Cycle","initialProofState":"α : Type u_1\ns : Cycle α\nl : List α\n⊢ Iff (Membership.mem s.lists l) (Eq (↑l) s)","decl":"@[simp]\ntheorem mem_lists_iff_coe_eq {s : Cycle α} {l : List α} : l ∈ s.lists ↔ (l : Cycle α) = s :=\n  Quotient.inductionOn' s fun l => by\n    rw [lists, Quotient.liftOn'_mk'']\n    simp\n\n"}
{"name":"Cycle.lists_nil","module":"Mathlib.Data.List.Cycle","initialProofState":"α : Type u_1\n⊢ Eq Cycle.nil.lists ↑(List.cons List.nil List.nil)","decl":"@[simp]\ntheorem lists_nil : lists (@nil α) = [([] : List α)] := by\n  rw [nil, lists_coe, cyclicPermutations_nil]\n\n"}
{"name":"Cycle.toFinset_toMultiset","module":"Mathlib.Data.List.Cycle","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : Cycle α\n⊢ Eq s.toMultiset.toFinset s.toFinset","decl":"@[simp]\ntheorem toFinset_toMultiset (s : Cycle α) : s.toMultiset.toFinset = s.toFinset :=\n  rfl\n\n"}
{"name":"Cycle.coe_toFinset","module":"Mathlib.Data.List.Cycle","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nl : List α\n⊢ Eq (↑l).toFinset l.toFinset","decl":"@[simp]\ntheorem coe_toFinset (l : List α) : (l : Cycle α).toFinset = l.toFinset :=\n  rfl\n\n"}
{"name":"Cycle.nil_toFinset","module":"Mathlib.Data.List.Cycle","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\n⊢ Eq Cycle.nil.toFinset EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem nil_toFinset : (@nil α).toFinset = ∅ :=\n  rfl\n\n"}
{"name":"Cycle.toFinset_eq_nil","module":"Mathlib.Data.List.Cycle","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : Cycle α\n⊢ Iff (Eq s.toFinset EmptyCollection.emptyCollection) (Eq s Cycle.nil)","decl":"@[simp]\ntheorem toFinset_eq_nil {s : Cycle α} : s.toFinset = ∅ ↔ s = Cycle.nil :=\n  Quotient.inductionOn' s (by simp)\n\n"}
{"name":"Cycle.prev_reverse_eq_next","module":"Mathlib.Data.List.Cycle","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : Cycle α\nhs : s.Nodup\nx : α\nhx : Membership.mem s x\n⊢ Eq (s.reverse.prev ⋯ x ⋯) (s.next hs x hx)","decl":"nonrec theorem prev_reverse_eq_next (s : Cycle α) : ∀ (hs : Nodup s) (x : α) (hx : x ∈ s),\n    s.reverse.prev (nodup_reverse_iff.mpr hs) x (mem_reverse_iff.mpr hx) = s.next hs x hx :=\n  Quotient.inductionOn' s prev_reverse_eq_next\n\n"}
{"name":"Cycle.prev_reverse_eq_next'","module":"Mathlib.Data.List.Cycle","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : Cycle α\nhs : s.reverse.Nodup\nx : α\nhx : Membership.mem s.reverse x\n⊢ Eq (s.reverse.prev hs x hx) (s.next ⋯ x ⋯)","decl":"@[simp]\nnonrec theorem prev_reverse_eq_next' (s : Cycle α) (hs : Nodup s.reverse) (x : α)\n    (hx : x ∈ s.reverse) :\n    s.reverse.prev hs x hx = s.next (nodup_reverse_iff.mp hs) x (mem_reverse_iff.mp hx) :=\n  prev_reverse_eq_next s (nodup_reverse_iff.mp hs) x (mem_reverse_iff.mp hx)\n\n-- Porting note: removed `simp` and added `next_reverse_eq_prev'` with `simp` attribute\n"}
{"name":"Cycle.next_reverse_eq_prev","module":"Mathlib.Data.List.Cycle","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : Cycle α\nhs : s.Nodup\nx : α\nhx : Membership.mem s x\n⊢ Eq (s.reverse.next ⋯ x ⋯) (s.prev hs x hx)","decl":"theorem next_reverse_eq_prev (s : Cycle α) (hs : Nodup s) (x : α) (hx : x ∈ s) :\n    s.reverse.next (nodup_reverse_iff.mpr hs) x (mem_reverse_iff.mpr hx) = s.prev hs x hx := by\n  simp [← prev_reverse_eq_next]\n\n"}
{"name":"Cycle.next_reverse_eq_prev'","module":"Mathlib.Data.List.Cycle","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : Cycle α\nhs : s.reverse.Nodup\nx : α\nhx : Membership.mem s.reverse x\n⊢ Eq (s.reverse.next hs x hx) (s.prev ⋯ x ⋯)","decl":"@[simp]\ntheorem next_reverse_eq_prev' (s : Cycle α) (hs : Nodup s.reverse) (x : α) (hx : x ∈ s.reverse) :\n    s.reverse.next hs x hx = s.prev (nodup_reverse_iff.mp hs) x (mem_reverse_iff.mp hx) := by\n  simp [← prev_reverse_eq_next]\n\n"}
{"name":"Cycle.next_mem","module":"Mathlib.Data.List.Cycle","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : Cycle α\nhs : s.Nodup\nx : α\nhx : Membership.mem s x\n⊢ Membership.mem s (s.next hs x hx)","decl":"@[simp]\nnonrec theorem next_mem (s : Cycle α) (hs : Nodup s) (x : α) (hx : x ∈ s) : s.next hs x hx ∈ s := by\n  induction s using Quot.inductionOn\n  apply next_mem; assumption\n\n"}
{"name":"Cycle.prev_mem","module":"Mathlib.Data.List.Cycle","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : Cycle α\nhs : s.Nodup\nx : α\nhx : Membership.mem s x\n⊢ Membership.mem s (s.prev hs x hx)","decl":"theorem prev_mem (s : Cycle α) (hs : Nodup s) (x : α) (hx : x ∈ s) : s.prev hs x hx ∈ s := by\n  rw [← next_reverse_eq_prev, ← mem_reverse_iff]\n  apply next_mem\n\n"}
{"name":"Cycle.prev_next","module":"Mathlib.Data.List.Cycle","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : Cycle α\nhs : s.Nodup\nx : α\nhx : Membership.mem s x\n⊢ Eq (s.prev hs (s.next hs x hx) ⋯) x","decl":"@[simp]\nnonrec theorem prev_next (s : Cycle α) : ∀ (hs : Nodup s) (x : α) (hx : x ∈ s),\n    s.prev hs (s.next hs x hx) (next_mem s hs x hx) = x :=\n  Quotient.inductionOn' s prev_next\n\n"}
{"name":"Cycle.next_prev","module":"Mathlib.Data.List.Cycle","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : Cycle α\nhs : s.Nodup\nx : α\nhx : Membership.mem s x\n⊢ Eq (s.next hs (s.prev hs x hx) ⋯) x","decl":"@[simp]\nnonrec theorem next_prev (s : Cycle α) : ∀ (hs : Nodup s) (x : α) (hx : x ∈ s),\n    s.next hs (s.prev hs x hx) (prev_mem s hs x hx) = x :=\n  Quotient.inductionOn' s next_prev\n\n"}
{"name":"Cycle.Chain.nil","module":"Mathlib.Data.List.Cycle","initialProofState":"α : Type u_1\nr : α → α → Prop\n⊢ Cycle.Chain r Cycle.nil","decl":"@[simp]\ntheorem Chain.nil (r : α → α → Prop) : Cycle.Chain r (@nil α) := by trivial\n\n"}
{"name":"Cycle.chain_coe_cons","module":"Mathlib.Data.List.Cycle","initialProofState":"α : Type u_1\nr : α → α → Prop\na : α\nl : List α\n⊢ Iff (Cycle.Chain r ↑(List.cons a l)) (List.Chain r a (HAppend.hAppend l (List.cons a List.nil)))","decl":"@[simp]\ntheorem chain_coe_cons (r : α → α → Prop) (a : α) (l : List α) :\n    Chain r (a :: l) ↔ List.Chain r a (l ++ [a]) :=\n  Iff.rfl\n\n"}
{"name":"Cycle.chain_singleton","module":"Mathlib.Data.List.Cycle","initialProofState":"α : Type u_1\nr : α → α → Prop\na : α\n⊢ Iff (Cycle.Chain r ↑(List.cons a List.nil)) (r a a)","decl":"theorem chain_singleton (r : α → α → Prop) (a : α) : Chain r [a] ↔ r a a := by\n  rw [chain_coe_cons, nil_append, List.chain_singleton]\n\n"}
{"name":"Cycle.chain_ne_nil","module":"Mathlib.Data.List.Cycle","initialProofState":"α : Type u_1\nr : α → α → Prop\nl : List α\nhl : Ne l List.nil\n⊢ Iff (Cycle.Chain r ↑l) (List.Chain r (l.getLast hl) l)","decl":"theorem chain_ne_nil (r : α → α → Prop) {l : List α} :\n    ∀ hl : l ≠ [], Chain r l ↔ List.Chain r (getLast l hl) l :=\n  l.reverseRecOn (fun hm => hm.irrefl.elim) (by\n    intro m a _H _\n    rw [← coe_cons_eq_coe_append, chain_coe_cons, getLast_append_singleton])\n\n"}
{"name":"Cycle.chain_map","module":"Mathlib.Data.List.Cycle","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\nf : β → α\ns : Cycle β\n⊢ Iff (Cycle.Chain r (Cycle.map f s)) (Cycle.Chain (fun a b => r (f a) (f b)) s)","decl":"theorem chain_map {β : Type*} {r : α → α → Prop} (f : β → α) {s : Cycle β} :\n    Chain r (s.map f) ↔ Chain (fun a b => r (f a) (f b)) s :=\n  Quotient.inductionOn s fun l => by\n    cases' l with a l\n    · rfl\n    · simp [← concat_eq_append, ← List.map_concat, List.chain_map f]\n\n"}
{"name":"Cycle.chain_range_succ","module":"Mathlib.Data.List.Cycle","initialProofState":"r : Nat → Nat → Prop\nn : Nat\n⊢ Iff (Cycle.Chain r ↑(List.range n.succ)) (And (r n 0) (∀ (m : Nat), LT.lt m n → r m m.succ))","decl":"nonrec theorem chain_range_succ (r : ℕ → ℕ → Prop) (n : ℕ) :\n    Chain r (List.range n.succ) ↔ r n 0 ∧ ∀ m < n, r m m.succ := by\n  rw [range_succ, ← coe_cons_eq_coe_append, chain_coe_cons, ← range_succ, chain_range_succ]\n\n"}
{"name":"Cycle.Chain.imp","module":"Mathlib.Data.List.Cycle","initialProofState":"α : Type u_1\ns : Cycle α\nr₁ r₂ : α → α → Prop\nH : ∀ (a b : α), r₁ a b → r₂ a b\np : Cycle.Chain r₁ s\n⊢ Cycle.Chain r₂ s","decl":"theorem Chain.imp {r₁ r₂ : α → α → Prop} (H : ∀ a b, r₁ a b → r₂ a b) (p : Chain r₁ s) :\n    Chain r₂ s := by\n  induction s\n  · trivial\n  · rw [chain_coe_cons] at p ⊢\n    exact p.imp H\n\n"}
{"name":"Cycle.chain_mono","module":"Mathlib.Data.List.Cycle","initialProofState":"α : Type u_1\n⊢ Monotone Cycle.Chain","decl":"/-- As a function from a relation to a predicate, `chain` is monotonic. -/\ntheorem chain_mono : Monotone (Chain : (α → α → Prop) → Cycle α → Prop) := fun _a _b hab _s =>\n  Chain.imp hab\n\n"}
{"name":"Cycle.chain_of_pairwise","module":"Mathlib.Data.List.Cycle","initialProofState":"α : Type u_1\nr : α → α → Prop\ns : Cycle α\na✝ : ∀ (a : α), Membership.mem s a → ∀ (b : α), Membership.mem s b → r a b\n⊢ Cycle.Chain r s","decl":"theorem chain_of_pairwise : (∀ a ∈ s, ∀ b ∈ s, r a b) → Chain r s := by\n  induction' s with a l _\n  · exact fun _ => Cycle.Chain.nil r\n  intro hs\n  have Ha : a ∈ (a :: l : Cycle α) := by simp\n  have Hl : ∀ {b} (_hb : b ∈ l), b ∈ (a :: l : Cycle α) := @fun b hb => by simp [hb]\n  rw [Cycle.chain_coe_cons]\n  apply Pairwise.chain\n  rw [pairwise_cons]\n  refine\n    ⟨fun b hb => ?_,\n      pairwise_append.2\n        ⟨pairwise_of_forall_mem_list fun b hb c hc => hs b (Hl hb) c (Hl hc),\n          pairwise_singleton r a, fun b hb c hc => ?_⟩⟩\n  · rw [mem_append] at hb\n    cases' hb with hb hb\n    · exact hs a Ha b (Hl hb)\n    · rw [mem_singleton] at hb\n      rw [hb]\n      exact hs a Ha a Ha\n  · rw [mem_singleton] at hc\n    rw [hc]\n    exact hs b (Hl hb) a Ha\n\n"}
{"name":"Cycle.chain_iff_pairwise","module":"Mathlib.Data.List.Cycle","initialProofState":"α : Type u_1\nr : α → α → Prop\ns : Cycle α\ninst✝ : IsTrans α r\n⊢ Iff (Cycle.Chain r s) (∀ (a : α), Membership.mem s a → ∀ (b : α), Membership.mem s b → r a b)","decl":"theorem chain_iff_pairwise [IsTrans α r] : Chain r s ↔ ∀ a ∈ s, ∀ b ∈ s, r a b :=\n  ⟨by\n    induction' s with a l _\n    · exact fun _ b hb => (not_mem_nil _ hb).elim\n    intro hs b hb c hc\n    rw [Cycle.chain_coe_cons, List.chain_iff_pairwise] at hs\n    simp only [pairwise_append, pairwise_cons, mem_append, mem_singleton, List.not_mem_nil,\n      IsEmpty.forall_iff, imp_true_iff, Pairwise.nil, forall_eq, true_and] at hs\n    simp only [mem_coe_iff, mem_cons] at hb hc\n    rcases hb with (rfl | hb) <;> rcases hc with (rfl | hc)\n    · exact hs.1 c (Or.inr rfl)\n    · exact hs.1 c (Or.inl hc)\n    · exact hs.2.2 b hb\n    · exact _root_.trans (hs.2.2 b hb) (hs.1 c (Or.inl hc)), Cycle.chain_of_pairwise⟩\n\n"}
{"name":"Cycle.Chain.eq_nil_of_irrefl","module":"Mathlib.Data.List.Cycle","initialProofState":"α : Type u_1\nr : α → α → Prop\ns : Cycle α\ninst✝¹ : IsTrans α r\ninst✝ : IsIrrefl α r\nh : Cycle.Chain r s\n⊢ Eq s Cycle.nil","decl":"theorem Chain.eq_nil_of_irrefl [IsTrans α r] [IsIrrefl α r] (h : Chain r s) : s = Cycle.nil := by\n  induction' s with a l _ h\n  · rfl\n  · have ha := mem_cons_self a l\n    exact (irrefl_of r a <| chain_iff_pairwise.1 h a ha a ha).elim\n\n"}
{"name":"Cycle.Chain.eq_nil_of_well_founded","module":"Mathlib.Data.List.Cycle","initialProofState":"α : Type u_1\nr : α → α → Prop\ns : Cycle α\ninst✝ : IsWellFounded α r\nh : Cycle.Chain r s\n⊢ Eq s Cycle.nil","decl":"theorem Chain.eq_nil_of_well_founded [IsWellFounded α r] (h : Chain r s) : s = Cycle.nil :=\n  Chain.eq_nil_of_irrefl <| h.imp fun _ _ => Relation.TransGen.single\n\n"}
{"name":"Cycle.forall_eq_of_chain","module":"Mathlib.Data.List.Cycle","initialProofState":"α : Type u_1\nr : α → α → Prop\ns : Cycle α\ninst✝¹ : IsTrans α r\ninst✝ : IsAntisymm α r\nhs : Cycle.Chain r s\na b : α\nha : Membership.mem s a\nhb : Membership.mem s b\n⊢ Eq a b","decl":"theorem forall_eq_of_chain [IsTrans α r] [IsAntisymm α r] (hs : Chain r s) {a b : α} (ha : a ∈ s)\n    (hb : b ∈ s) : a = b := by\n  rw [chain_iff_pairwise] at hs\n  exact antisymm (hs a ha b hb) (hs b hb a ha)\n\n"}
