{"name":"ProbabilityTheory.Kernel.isRatCondKernelCDFAux_density_Iic","module":"Mathlib.Probability.Kernel.Disintegration.StandardBorel","initialProofState":"α : Type u_1\nγ : Type u_3\nmα : MeasurableSpace α\nmγ : MeasurableSpace γ\ninst✝¹ : MeasurableSpace.CountablyGenerated γ\nκ : ProbabilityTheory.Kernel α (Prod γ Real)\ninst✝ : ProbabilityTheory.IsFiniteKernel κ\n⊢ ProbabilityTheory.IsRatCondKernelCDFAux (fun p q => κ.density κ.fst p.1 p.2 (Set.Iic ↑q)) κ κ.fst","decl":"lemma isRatCondKernelCDFAux_density_Iic (κ : Kernel α (γ × ℝ)) [IsFiniteKernel κ] :\n    IsRatCondKernelCDFAux (fun (p : α × γ) q ↦ density κ (fst κ) p.1 p.2 (Iic q)) κ (fst κ) where\n  measurable := measurable_pi_iff.mpr fun _ ↦ measurable_density κ (fst κ) measurableSet_Iic\n  mono' a q r hqr :=\n    ae_of_all _ fun c ↦ density_mono_set le_rfl a c (Iic_subset_Iic.mpr (by exact_mod_cast hqr))\n  nonneg' _ _ := ae_of_all _ fun _ ↦ density_nonneg le_rfl _ _ _\n  le_one' _ _ := ae_of_all _ fun _ ↦ density_le_one le_rfl _ _ _\n  tendsto_integral_of_antitone a s hs_anti hs_tendsto := by\n    let s' : ℕ → Set ℝ := fun n ↦ Iic (s n)\n    refine tendsto_integral_density_of_antitone le_rfl a s' ?_ ?_ (fun _ ↦ measurableSet_Iic)\n    · refine fun i j hij ↦ Iic_subset_Iic.mpr ?_\n      exact mod_cast hs_anti hij\n    · ext x\n      simp only [mem_iInter, mem_Iic, mem_empty_iff_false, iff_false, not_forall, not_le, s']\n      rw [tendsto_atTop_atBot] at hs_tendsto\n      have ⟨q, hq⟩ := exists_rat_lt x\n      obtain ⟨i, hi⟩ := hs_tendsto q\n      refine ⟨i, lt_of_le_of_lt ?_ hq⟩\n      exact mod_cast hi i le_rfl\n  tendsto_integral_of_monotone a s hs_mono hs_tendsto := by\n    rw [fst_apply' _ _ MeasurableSet.univ]\n    let s' : ℕ → Set ℝ := fun n ↦ Iic (s n)\n    refine tendsto_integral_density_of_monotone (le_rfl : fst κ ≤ fst κ)\n      a s' ?_ ?_ (fun _ ↦ measurableSet_Iic)\n    · exact fun i j hij ↦ Iic_subset_Iic.mpr (by exact mod_cast hs_mono hij)\n    · ext x\n      simp only [mem_iUnion, mem_Iic, mem_univ, iff_true]\n      rw [tendsto_atTop_atTop] at hs_tendsto\n      have ⟨q, hq⟩ := exists_rat_gt x\n      obtain ⟨i, hi⟩ := hs_tendsto q\n      refine ⟨i, hq.le.trans ?_⟩\n      exact mod_cast hi i le_rfl\n  integrable a _ := integrable_density le_rfl a measurableSet_Iic\n  setIntegral a _ hA _ := setIntegral_density le_rfl a measurableSet_Iic hA\n\n"}
{"name":"ProbabilityTheory.Kernel.isRatCondKernelCDF_density_Iic","module":"Mathlib.Probability.Kernel.Disintegration.StandardBorel","initialProofState":"α : Type u_1\nγ : Type u_3\nmα : MeasurableSpace α\nmγ : MeasurableSpace γ\ninst✝¹ : MeasurableSpace.CountablyGenerated γ\nκ : ProbabilityTheory.Kernel α (Prod γ Real)\ninst✝ : ProbabilityTheory.IsFiniteKernel κ\n⊢ ProbabilityTheory.IsRatCondKernelCDF (fun p q => κ.density κ.fst p.1 p.2 (Set.Iic ↑q)) κ κ.fst","decl":"/-- Taking the kernel density of intervals `Iic q` for `q : ℚ` gives a function with the property\n`isRatCondKernelCDF`. -/\nlemma isRatCondKernelCDF_density_Iic (κ : Kernel α (γ × ℝ)) [IsFiniteKernel κ] :\n    IsRatCondKernelCDF (fun (p : α × γ) q ↦ density κ (fst κ) p.1 p.2 (Iic q)) κ (fst κ) :=\n  (isRatCondKernelCDFAux_density_Iic κ).isRatCondKernelCDF\n\n"}
{"name":"ProbabilityTheory.Kernel.isCondKernelCDF_condKernelCDF","module":"Mathlib.Probability.Kernel.Disintegration.StandardBorel","initialProofState":"α : Type u_1\nγ : Type u_3\nmα : MeasurableSpace α\nmγ : MeasurableSpace γ\ninst✝¹ : MeasurableSpace.CountablyGenerated γ\nκ : ProbabilityTheory.Kernel α (Prod γ Real)\ninst✝ : ProbabilityTheory.IsFiniteKernel κ\n⊢ ProbabilityTheory.IsCondKernelCDF κ.condKernelCDF κ κ.fst","decl":"lemma isCondKernelCDF_condKernelCDF (κ : Kernel α (γ × ℝ)) [IsFiniteKernel κ] :\n    IsCondKernelCDF (condKernelCDF κ) κ (fst κ) :=\n  isCondKernelCDF_stieltjesOfMeasurableRat (isRatCondKernelCDF_density_Iic κ)\n\n"}
{"name":"ProbabilityTheory.Kernel.instIsMarkovKernelCondKernelReal","module":"Mathlib.Probability.Kernel.Disintegration.StandardBorel","initialProofState":"α : Type u_1\nγ : Type u_3\nmα : MeasurableSpace α\nmγ : MeasurableSpace γ\ninst✝¹ : MeasurableSpace.CountablyGenerated γ\nκ : ProbabilityTheory.Kernel α (Prod γ Real)\ninst✝ : ProbabilityTheory.IsFiniteKernel κ\n⊢ ProbabilityTheory.IsMarkovKernel κ.condKernelReal","decl":"instance instIsMarkovKernelCondKernelReal (κ : Kernel α (γ × ℝ)) [IsFiniteKernel κ] :\n    IsMarkovKernel (condKernelReal κ) := by\n  rw [condKernelReal]\n  infer_instance\n\n"}
{"name":"ProbabilityTheory.Kernel.compProd_fst_condKernelReal","module":"Mathlib.Probability.Kernel.Disintegration.StandardBorel","initialProofState":"α : Type u_1\nγ : Type u_3\nmα : MeasurableSpace α\nmγ : MeasurableSpace γ\ninst✝¹ : MeasurableSpace.CountablyGenerated γ\nκ : ProbabilityTheory.Kernel α (Prod γ Real)\ninst✝ : ProbabilityTheory.IsFiniteKernel κ\n⊢ Eq (κ.fst.compProd κ.condKernelReal) κ","decl":"lemma compProd_fst_condKernelReal (κ : Kernel α (γ × ℝ)) [IsFiniteKernel κ] :\n    fst κ ⊗ₖ condKernelReal κ = κ := by\n  rw [condKernelReal, compProd_toKernel]\n\n"}
{"name":"ProbabilityTheory.Kernel.instIsMarkovKernelCondKernelUnitReal","module":"Mathlib.Probability.Kernel.Disintegration.StandardBorel","initialProofState":"α : Type u_1\nmα : MeasurableSpace α\nκ : ProbabilityTheory.Kernel Unit (Prod α Real)\ninst✝ : ProbabilityTheory.IsFiniteKernel κ\n⊢ ProbabilityTheory.IsMarkovKernel κ.condKernelUnitReal","decl":"instance instIsMarkovKernelCondKernelUnitReal (κ : Kernel Unit (α × ℝ)) [IsFiniteKernel κ] :\n    IsMarkovKernel (condKernelUnitReal κ) := by\n  rw [condKernelUnitReal]\n  infer_instance\n\n"}
{"name":"ProbabilityTheory.Kernel.condKernelUnitReal.instIsCondKernel","module":"Mathlib.Probability.Kernel.Disintegration.StandardBorel","initialProofState":"α : Type u_1\nmα : MeasurableSpace α\nκ : ProbabilityTheory.Kernel Unit (Prod α Real)\ninst✝ : ProbabilityTheory.IsFiniteKernel κ\n⊢ κ.IsCondKernel κ.condKernelUnitReal","decl":"instance condKernelUnitReal.instIsCondKernel (κ : Kernel Unit (α × ℝ)) [IsFiniteKernel κ] :\n    κ.IsCondKernel κ.condKernelUnitReal where\n  disintegrate := by rw [condKernelUnitReal, compProd_toKernel]; ext; simp\n\n"}
{"name":"ProbabilityTheory.Kernel.borelMarkovFromReal_apply","module":"Mathlib.Probability.Kernel.Disintegration.StandardBorel","initialProofState":"α : Type u_1\nmα : MeasurableSpace α\nΩ : Type u_5\ninst✝² : Nonempty Ω\ninst✝¹ : MeasurableSpace Ω\ninst✝ : StandardBorelSpace Ω\nη : ProbabilityTheory.Kernel α Real\na : α\n⊢ Eq ((ProbabilityTheory.Kernel.borelMarkovFromReal Ω η) a) (ite (Eq ((η a) (HasCompl.compl (Set.range (MeasureTheory.embeddingReal Ω)))) 0) (MeasureTheory.Measure.comap (MeasureTheory.embeddingReal Ω) (η a)) (MeasureTheory.Measure.comap (MeasureTheory.embeddingReal Ω) (MeasureTheory.Measure.dirac (Exists.choose ⋯))))","decl":"lemma borelMarkovFromReal_apply (Ω : Type*) [Nonempty Ω] [MeasurableSpace Ω] [StandardBorelSpace Ω]\n    (η : Kernel α ℝ) (a : α) :\n    borelMarkovFromReal Ω η a\n      = if η a (range (embeddingReal Ω))ᶜ = 0 then (η a).comap (embeddingReal Ω)\n        else (Measure.dirac (range_nonempty (embeddingReal Ω)).choose).comap (embeddingReal Ω) := by\n  classical\n  rw [borelMarkovFromReal, comapRight_apply, piecewise_apply, deterministic_apply]\n  simp only [mem_preimage, mem_singleton_iff]\n  split_ifs <;> rfl\n\n"}
{"name":"ProbabilityTheory.Kernel.borelMarkovFromReal_apply'","module":"Mathlib.Probability.Kernel.Disintegration.StandardBorel","initialProofState":"α : Type u_1\nmα : MeasurableSpace α\nΩ : Type u_5\ninst✝² : Nonempty Ω\ninst✝¹ : MeasurableSpace Ω\ninst✝ : StandardBorelSpace Ω\nη : ProbabilityTheory.Kernel α Real\na : α\ns : Set Ω\nhs : MeasurableSet s\n⊢ Eq (((ProbabilityTheory.Kernel.borelMarkovFromReal Ω η) a) s) (ite (Eq ((η a) (HasCompl.compl (Set.range (MeasureTheory.embeddingReal Ω)))) 0) ((η a) (Set.image (MeasureTheory.embeddingReal Ω) s)) ((Set.image (MeasureTheory.embeddingReal Ω) s).indicator 1 (Exists.choose ⋯)))","decl":"lemma borelMarkovFromReal_apply' (Ω : Type*) [Nonempty Ω] [MeasurableSpace Ω] [StandardBorelSpace Ω]\n    (η : Kernel α ℝ) (a : α) {s : Set Ω} (hs : MeasurableSet s) :\n    borelMarkovFromReal Ω η a s\n      = if η a (range (embeddingReal Ω))ᶜ = 0 then η a (embeddingReal Ω '' s)\n        else (embeddingReal Ω '' s).indicator 1 (range_nonempty (embeddingReal Ω)).choose := by\n  have he := measurableEmbedding_embeddingReal Ω\n  rw [borelMarkovFromReal_apply]\n  split_ifs with h\n  · rw [Measure.comap_apply _ he.injective he.measurableSet_image' _ hs]\n  · rw [Measure.comap_apply _ he.injective he.measurableSet_image' _ hs, Measure.dirac_apply]\n\n"}
{"name":"ProbabilityTheory.Kernel.instIsSFiniteKernelBorelMarkovFromReal","module":"Mathlib.Probability.Kernel.Disintegration.StandardBorel","initialProofState":"α : Type u_1\nΩ : Type u_4\nmα : MeasurableSpace α\ninst✝³ : MeasurableSpace Ω\ninst✝² : StandardBorelSpace Ω\ninst✝¹ : Nonempty Ω\nη : ProbabilityTheory.Kernel α Real\ninst✝ : ProbabilityTheory.IsSFiniteKernel η\n⊢ ProbabilityTheory.IsSFiniteKernel (ProbabilityTheory.Kernel.borelMarkovFromReal Ω η)","decl":"/-- When `η` is an s-finite kernel, `borelMarkovFromReal Ω η` is an s-finite kernel. -/\ninstance instIsSFiniteKernelBorelMarkovFromReal (η : Kernel α ℝ) [IsSFiniteKernel η] :\n    IsSFiniteKernel (borelMarkovFromReal Ω η) :=\n  IsSFiniteKernel.comapRight _ (measurableEmbedding_embeddingReal Ω)\n\n"}
{"name":"ProbabilityTheory.Kernel.instIsFiniteKernelBorelMarkovFromReal","module":"Mathlib.Probability.Kernel.Disintegration.StandardBorel","initialProofState":"α : Type u_1\nΩ : Type u_4\nmα : MeasurableSpace α\ninst✝³ : MeasurableSpace Ω\ninst✝² : StandardBorelSpace Ω\ninst✝¹ : Nonempty Ω\nη : ProbabilityTheory.Kernel α Real\ninst✝ : ProbabilityTheory.IsFiniteKernel η\n⊢ ProbabilityTheory.IsFiniteKernel (ProbabilityTheory.Kernel.borelMarkovFromReal Ω η)","decl":"/-- When `η` is a finite kernel, `borelMarkovFromReal Ω η` is a finite kernel. -/\ninstance instIsFiniteKernelBorelMarkovFromReal (η : Kernel α ℝ) [IsFiniteKernel η] :\n    IsFiniteKernel (borelMarkovFromReal Ω η) :=\n  IsFiniteKernel.comapRight _ (measurableEmbedding_embeddingReal Ω)\n\n"}
{"name":"ProbabilityTheory.Kernel.instIsMarkovKernelBorelMarkovFromReal","module":"Mathlib.Probability.Kernel.Disintegration.StandardBorel","initialProofState":"α : Type u_1\nΩ : Type u_4\nmα : MeasurableSpace α\ninst✝³ : MeasurableSpace Ω\ninst✝² : StandardBorelSpace Ω\ninst✝¹ : Nonempty Ω\nη : ProbabilityTheory.Kernel α Real\ninst✝ : ProbabilityTheory.IsMarkovKernel η\n⊢ ProbabilityTheory.IsMarkovKernel (ProbabilityTheory.Kernel.borelMarkovFromReal Ω η)","decl":"/-- When `η` is a Markov kernel, `borelMarkovFromReal Ω η` is a Markov kernel. -/\ninstance instIsMarkovKernelBorelMarkovFromReal (η : Kernel α ℝ) [IsMarkovKernel η] :\n    IsMarkovKernel (borelMarkovFromReal Ω η) := by\n  refine IsMarkovKernel.comapRight _ (measurableEmbedding_embeddingReal Ω) (fun a ↦ ?_)\n  classical\n  rw [piecewise_apply]\n  split_ifs with h\n  · rwa [← prob_compl_eq_zero_iff (measurableEmbedding_embeddingReal Ω).measurableSet_range]\n  · rw [deterministic_apply]\n    simp [(range_nonempty (embeddingReal Ω)).choose_spec]\n\n"}
{"name":"ProbabilityTheory.Kernel.compProd_fst_borelMarkovFromReal_eq_comapRight_compProd","module":"Mathlib.Probability.Kernel.Disintegration.StandardBorel","initialProofState":"α : Type u_1\nβ : Type u_2\nΩ : Type u_4\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\ninst✝⁴ : MeasurableSpace Ω\ninst✝³ : StandardBorelSpace Ω\ninst✝² : Nonempty Ω\nκ : ProbabilityTheory.Kernel α (Prod β Ω)\ninst✝¹ : ProbabilityTheory.IsSFiniteKernel κ\nη : ProbabilityTheory.Kernel (Prod α β) Real\ninst✝ : ProbabilityTheory.IsSFiniteKernel η\nhη : Eq ((κ.map (Prod.map id (MeasureTheory.embeddingReal Ω))).fst.compProd η) (κ.map (Prod.map id (MeasureTheory.embeddingReal Ω)))\n⊢ Eq (κ.fst.compProd (ProbabilityTheory.Kernel.borelMarkovFromReal Ω η)) (((κ.map (Prod.map id (MeasureTheory.embeddingReal Ω))).fst.compProd η).comapRight ⋯)","decl":"/-- For `κ' := map κ (Prod.map (id : β → β) e)`, the hypothesis `hη` is `fst κ' ⊗ₖ η = κ'`.\nThe conclusion of the lemma is `fst κ ⊗ₖ borelMarkovFromReal Ω η = comapRight (fst κ' ⊗ₖ η) _`. -/\nlemma compProd_fst_borelMarkovFromReal_eq_comapRight_compProd\n    (κ : Kernel α (β × Ω)) [IsSFiniteKernel κ] (η : Kernel (α × β) ℝ) [IsSFiniteKernel η]\n    (hη : (fst (map κ (Prod.map (id : β → β) (embeddingReal Ω)))) ⊗ₖ η\n      = map κ (Prod.map (id : β → β) (embeddingReal Ω))) :\n    fst κ ⊗ₖ borelMarkovFromReal Ω η\n      = comapRight (fst (map κ (Prod.map (id : β → β) (embeddingReal Ω))) ⊗ₖ η)\n        (MeasurableEmbedding.id.prodMap (measurableEmbedding_embeddingReal Ω)) := by\n  let e := embeddingReal Ω\n  let he := measurableEmbedding_embeddingReal Ω\n  let κ' := map κ (Prod.map (id : β → β) e)\n  have hη' : fst κ' ⊗ₖ η = κ' := hη\n  have h_prod_embed : MeasurableEmbedding (Prod.map (id : β → β) e) :=\n    MeasurableEmbedding.id.prodMap he\n  change fst κ ⊗ₖ borelMarkovFromReal Ω η = comapRight (fst κ' ⊗ₖ η) h_prod_embed\n  rw [comapRight_compProd_id_prod _ _ he]\n  have h_fst : fst κ' = fst κ := by\n    ext a u\n    unfold κ'\n    rw [fst_apply, map_apply _ (by fun_prop),\n      Measure.map_map measurable_fst h_prod_embed.measurable, fst_apply]\n    congr\n  rw [h_fst]\n  ext a t ht : 2\n  simp_rw [compProd_apply ht]\n  refine lintegral_congr_ae ?_\n  have h_ae : ∀ᵐ t ∂(fst κ a), (a, t) ∈ {p : α × β | η p (range e)ᶜ = 0} := by\n    rw [← h_fst]\n    have h_compProd : κ' a (univ ×ˢ range e)ᶜ = 0 := by\n      unfold κ'\n      rw [map_apply' _ (by fun_prop)]\n      swap; · exact (MeasurableSet.univ.prod he.measurableSet_range).compl\n      suffices Prod.map id e ⁻¹' (univ ×ˢ range e)ᶜ = ∅ by rw [this]; simp\n      ext x\n      simp\n    rw [← hη', compProd_null] at h_compProd\n    swap; · exact (MeasurableSet.univ.prod he.measurableSet_range).compl\n    simp only [preimage_compl, mem_univ, mk_preimage_prod_right] at h_compProd\n    exact h_compProd\n  filter_upwards [h_ae] with a ha\n  rw [borelMarkovFromReal, comapRight_apply', comapRight_apply']\n  rotate_left\n  · exact measurable_prod_mk_left ht\n  · exact measurable_prod_mk_left ht\n  classical\n  rw [piecewise_apply, if_pos]\n  exact ha\n\n"}
{"name":"ProbabilityTheory.Kernel.compProd_fst_borelMarkovFromReal","module":"Mathlib.Probability.Kernel.Disintegration.StandardBorel","initialProofState":"α : Type u_1\nβ : Type u_2\nΩ : Type u_4\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\ninst✝⁴ : MeasurableSpace Ω\ninst✝³ : StandardBorelSpace Ω\ninst✝² : Nonempty Ω\nκ : ProbabilityTheory.Kernel α (Prod β Ω)\ninst✝¹ : ProbabilityTheory.IsSFiniteKernel κ\nη : ProbabilityTheory.Kernel (Prod α β) Real\ninst✝ : ProbabilityTheory.IsSFiniteKernel η\nhη : Eq ((κ.map (Prod.map id (MeasureTheory.embeddingReal Ω))).fst.compProd η) (κ.map (Prod.map id (MeasureTheory.embeddingReal Ω)))\n⊢ Eq (κ.fst.compProd (ProbabilityTheory.Kernel.borelMarkovFromReal Ω η)) κ","decl":"/-- For `κ' := map κ (Prod.map (id : β → β) e)`, the hypothesis `hη` is `fst κ' ⊗ₖ η = κ'`.\nWith that hypothesis, `fst κ ⊗ₖ borelMarkovFromReal κ η = κ`.-/\nlemma compProd_fst_borelMarkovFromReal (κ : Kernel α (β × Ω)) [IsSFiniteKernel κ]\n    (η : Kernel (α × β) ℝ) [IsSFiniteKernel η]\n    (hη : (fst (map κ (Prod.map (id : β → β) (embeddingReal Ω)))) ⊗ₖ η\n      = map κ (Prod.map (id : β → β) (embeddingReal Ω))) :\n    fst κ ⊗ₖ borelMarkovFromReal Ω η = κ := by\n  let e := embeddingReal Ω\n  let he := measurableEmbedding_embeddingReal Ω\n  let κ' := map κ (Prod.map (id : β → β) e)\n  have hη' : fst κ' ⊗ₖ η = κ' := hη\n  have h_prod_embed : MeasurableEmbedding (Prod.map (id : β → β) e) :=\n    MeasurableEmbedding.id.prodMap he\n  have : κ = comapRight κ' h_prod_embed := by\n    ext c t : 2\n    unfold κ'\n    rw [comapRight_apply, map_apply _ (by fun_prop), h_prod_embed.comap_map]\n  conv_rhs => rw [this, ← hη']\n  exact compProd_fst_borelMarkovFromReal_eq_comapRight_compProd κ η hη\n\n"}
{"name":"ProbabilityTheory.Kernel.instIsMarkovKernelCondKernelBorel","module":"Mathlib.Probability.Kernel.Disintegration.StandardBorel","initialProofState":"α : Type u_1\nγ : Type u_3\nΩ : Type u_4\nmα : MeasurableSpace α\nmγ : MeasurableSpace γ\ninst✝⁴ : MeasurableSpace.CountablyGenerated γ\ninst✝³ : MeasurableSpace Ω\ninst✝² : StandardBorelSpace Ω\ninst✝¹ : Nonempty Ω\nκ : ProbabilityTheory.Kernel α (Prod γ Ω)\ninst✝ : ProbabilityTheory.IsFiniteKernel κ\n⊢ ProbabilityTheory.IsMarkovKernel κ.condKernelBorel","decl":"instance instIsMarkovKernelCondKernelBorel (κ : Kernel α (γ × Ω)) [IsFiniteKernel κ] :\n    IsMarkovKernel (condKernelBorel κ) := by\n  rw [condKernelBorel]\n  infer_instance\n\n"}
{"name":"ProbabilityTheory.Kernel.condKernelBorel.instIsCondKernel","module":"Mathlib.Probability.Kernel.Disintegration.StandardBorel","initialProofState":"α : Type u_1\nγ : Type u_3\nΩ : Type u_4\nmα : MeasurableSpace α\nmγ : MeasurableSpace γ\ninst✝⁴ : MeasurableSpace.CountablyGenerated γ\ninst✝³ : MeasurableSpace Ω\ninst✝² : StandardBorelSpace Ω\ninst✝¹ : Nonempty Ω\nκ : ProbabilityTheory.Kernel α (Prod γ Ω)\ninst✝ : ProbabilityTheory.IsFiniteKernel κ\n⊢ κ.IsCondKernel κ.condKernelBorel","decl":"instance condKernelBorel.instIsCondKernel (κ : Kernel α (γ × Ω)) [IsFiniteKernel κ] :\n    κ.IsCondKernel κ.condKernelBorel where\n  disintegrate := by\n    rw [condKernelBorel, compProd_fst_borelMarkovFromReal _ _ (compProd_fst_condKernelReal _)]\n\n"}
{"name":"ProbabilityTheory.Kernel.instIsMarkovKernelCondKernelUnitBorel","module":"Mathlib.Probability.Kernel.Disintegration.StandardBorel","initialProofState":"α : Type u_1\nΩ : Type u_4\nmα : MeasurableSpace α\ninst✝³ : MeasurableSpace Ω\ninst✝² : StandardBorelSpace Ω\ninst✝¹ : Nonempty Ω\nκ : ProbabilityTheory.Kernel Unit (Prod α Ω)\ninst✝ : ProbabilityTheory.IsFiniteKernel κ\n⊢ ProbabilityTheory.IsMarkovKernel κ.condKernelUnitBorel","decl":"instance instIsMarkovKernelCondKernelUnitBorel : IsMarkovKernel κ.condKernelUnitBorel := by\n  rw [condKernelUnitBorel]\n  infer_instance\n\n"}
{"name":"ProbabilityTheory.Kernel.condKernelUnitBorel.instIsCondKernel","module":"Mathlib.Probability.Kernel.Disintegration.StandardBorel","initialProofState":"α : Type u_1\nΩ : Type u_4\nmα : MeasurableSpace α\ninst✝³ : MeasurableSpace Ω\ninst✝² : StandardBorelSpace Ω\ninst✝¹ : Nonempty Ω\nκ : ProbabilityTheory.Kernel Unit (Prod α Ω)\ninst✝ : ProbabilityTheory.IsFiniteKernel κ\n⊢ κ.IsCondKernel κ.condKernelUnitBorel","decl":"instance condKernelUnitBorel.instIsCondKernel : κ.IsCondKernel κ.condKernelUnitBorel where\n  disintegrate := by\n    rw [condKernelUnitBorel, compProd_fst_borelMarkovFromReal _ _ (disintegrate _ _)]\n\n"}
{"name":"MeasureTheory.Measure.condKernel_def","module":"Mathlib.Probability.Kernel.Disintegration.StandardBorel","initialProofState":"α : Type u_5\nΩ : Type u_6\nmα : MeasurableSpace α\ninst✝³ : MeasurableSpace Ω\ninst✝² : StandardBorelSpace Ω\ninst✝¹ : Nonempty Ω\nρ : MeasureTheory.Measure (Prod α Ω)\ninst✝ : MeasureTheory.IsFiniteMeasure ρ\n⊢ Eq ρ.condKernel ((ProbabilityTheory.Kernel.const Unit ρ).condKernelUnitBorel.comap (fun a => { fst := Unit.unit, snd := a }) ⋯)","decl":"/-- Conditional kernel of a measure on a product space: a Markov kernel such that\n`ρ = ρ.fst ⊗ₘ ρ.condKernel` (see `MeasureTheory.Measure.compProd_fst_condKernel`). -/\nnoncomputable\nirreducible_def _root_.MeasureTheory.Measure.condKernel (ρ : Measure (α × Ω)) [IsFiniteMeasure ρ] :\n    Kernel α Ω :=\n  comap (condKernelUnitBorel (const Unit ρ)) (fun a ↦ ((), a)) measurable_prod_mk_left\n\n"}
{"name":"MeasureTheory.Measure.condKernel_apply","module":"Mathlib.Probability.Kernel.Disintegration.StandardBorel","initialProofState":"α : Type u_1\nΩ : Type u_4\nmα : MeasurableSpace α\ninst✝³ : MeasurableSpace Ω\ninst✝² : StandardBorelSpace Ω\ninst✝¹ : Nonempty Ω\nρ : MeasureTheory.Measure (Prod α Ω)\ninst✝ : MeasureTheory.IsFiniteMeasure ρ\na : α\n⊢ Eq (ρ.condKernel a) ((ProbabilityTheory.Kernel.const Unit ρ).condKernelUnitBorel { fst := Unit.unit, snd := a })","decl":"lemma _root_.MeasureTheory.Measure.condKernel_apply (ρ : Measure (α × Ω)) [IsFiniteMeasure ρ]\n    (a : α) :\n    ρ.condKernel a = condKernelUnitBorel (const Unit ρ) ((), a) := by\n  rw [Measure.condKernel]; rfl\n\n"}
{"name":"MeasureTheory.Measure.condKernel.instIsCondKernel","module":"Mathlib.Probability.Kernel.Disintegration.StandardBorel","initialProofState":"α : Type u_1\nΩ : Type u_4\nmα : MeasurableSpace α\ninst✝³ : MeasurableSpace Ω\ninst✝² : StandardBorelSpace Ω\ninst✝¹ : Nonempty Ω\nρ : MeasureTheory.Measure (Prod α Ω)\ninst✝ : MeasureTheory.IsFiniteMeasure ρ\n⊢ ρ.IsCondKernel ρ.condKernel","decl":"instance _root_.MeasureTheory.Measure.condKernel.instIsCondKernel (ρ : Measure (α × Ω))\n    [IsFiniteMeasure ρ] : ρ.IsCondKernel ρ.condKernel where\n  disintegrate := by\n    have h1 : const Unit (Measure.fst ρ) = fst (const Unit ρ) := by\n      ext\n      simp only [fst_apply, Measure.fst, const_apply]\n    have h2 : prodMkLeft Unit (Measure.condKernel ρ) = condKernelUnitBorel (const Unit ρ) := by\n      ext\n      simp only [prodMkLeft_apply, Measure.condKernel_apply]\n    rw [Measure.compProd, h1, h2, disintegrate]\n    simp\n\n"}
{"name":"MeasureTheory.Measure.instIsMarkovKernelCondKernel","module":"Mathlib.Probability.Kernel.Disintegration.StandardBorel","initialProofState":"α : Type u_1\nΩ : Type u_4\nmα : MeasurableSpace α\ninst✝³ : MeasurableSpace Ω\ninst✝² : StandardBorelSpace Ω\ninst✝¹ : Nonempty Ω\nρ : MeasureTheory.Measure (Prod α Ω)\ninst✝ : MeasureTheory.IsFiniteMeasure ρ\n⊢ ProbabilityTheory.IsMarkovKernel ρ.condKernel","decl":"instance _root_.MeasureTheory.Measure.instIsMarkovKernelCondKernel\n    (ρ : Measure (α × Ω)) [IsFiniteMeasure ρ] : IsMarkovKernel ρ.condKernel := by\n  rw [Measure.condKernel]\n  infer_instance\n\n"}
{"name":"MeasureTheory.Measure.condKernel_apply_of_ne_zero","module":"Mathlib.Probability.Kernel.Disintegration.StandardBorel","initialProofState":"α : Type u_1\nΩ : Type u_4\nmα : MeasurableSpace α\ninst✝⁴ : MeasurableSpace Ω\ninst✝³ : StandardBorelSpace Ω\ninst✝² : Nonempty Ω\nρ : MeasureTheory.Measure (Prod α Ω)\ninst✝¹ : MeasureTheory.IsFiniteMeasure ρ\ninst✝ : MeasurableSingletonClass α\nx : α\nhx : Ne (ρ.fst (Singleton.singleton x)) 0\ns : Set Ω\n⊢ Eq ((ρ.condKernel x) s) (HMul.hMul (Inv.inv (ρ.fst (Singleton.singleton x))) (ρ (SProd.sprod (Singleton.singleton x) s)))","decl":"/-- If the singleton `{x}` has non-zero mass for `ρ.fst`, then for all `s : Set Ω`,\n`ρ.condKernel x s = (ρ.fst {x})⁻¹ * ρ ({x} ×ˢ s)` . -/\nlemma _root_.MeasureTheory.Measure.condKernel_apply_of_ne_zero [MeasurableSingletonClass α]\n    {x : α} (hx : ρ.fst {x} ≠ 0) (s : Set Ω) :\n    ρ.condKernel x s = (ρ.fst {x})⁻¹ * ρ ({x} ×ˢ s) :=\n  Measure.IsCondKernel.apply_of_ne_zero _ _ hx _\n\n"}
{"name":"ProbabilityTheory.Kernel.condKernel_def","module":"Mathlib.Probability.Kernel.Disintegration.StandardBorel","initialProofState":"α : Type u_5\nβ : Type u_6\nΩ : Type u_7\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\ninst✝³ : MeasurableSpace Ω\ninst✝² : StandardBorelSpace Ω\ninst✝¹ : Nonempty Ω\nh : MeasurableSpace.CountableOrCountablyGenerated α β\nκ : ProbabilityTheory.Kernel α (Prod β Ω)\ninst✝ : ProbabilityTheory.IsFiniteKernel κ\n⊢ Eq κ.condKernel (dite (Countable α) (fun hα => ProbabilityTheory.Kernel.condKernelCountable (fun a => (κ a).condKernel) ⋯) fun hα => κ.condKernelBorel)","decl":"open Classical in\n\n/-- Conditional kernel of a kernel `κ : Kernel α (β × Ω)`: a Markov kernel such that\n`fst κ ⊗ₖ condKernel κ = κ` (see `MeasureTheory.Measure.compProd_fst_condKernel`).\nIt exists whenever `Ω` is standard Borel and either `α` is countable\nor `β` is countably generated. -/\nnoncomputable\nirreducible_def condKernel : Kernel (α × β) Ω :=\n  if hα : Countable α then\n    condKernelCountable (fun a ↦ (κ a).condKernel)\n      fun x y h ↦ by simp [apply_congr_of_mem_measurableAtom _ h]\n  else letI := h.countableOrCountablyGenerated.resolve_left hα; condKernelBorel κ\n\n"}
{"name":"ProbabilityTheory.Kernel.instIsMarkovKernelCondKernel","module":"Mathlib.Probability.Kernel.Disintegration.StandardBorel","initialProofState":"α : Type u_1\nβ : Type u_2\nΩ : Type u_4\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\ninst✝³ : MeasurableSpace Ω\ninst✝² : StandardBorelSpace Ω\ninst✝¹ : Nonempty Ω\nh : MeasurableSpace.CountableOrCountablyGenerated α β\nκ : ProbabilityTheory.Kernel α (Prod β Ω)\ninst✝ : ProbabilityTheory.IsFiniteKernel κ\n⊢ ProbabilityTheory.IsMarkovKernel κ.condKernel","decl":"/-- `condKernel κ` is a Markov kernel. -/\ninstance instIsMarkovKernelCondKernel : IsMarkovKernel (condKernel κ) := by\n  rw [condKernel_def]\n  split_ifs <;> infer_instance\n\n"}
{"name":"ProbabilityTheory.Kernel.condKernel.instIsCondKernel","module":"Mathlib.Probability.Kernel.Disintegration.StandardBorel","initialProofState":"α : Type u_1\nβ : Type u_2\nΩ : Type u_4\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\ninst✝³ : MeasurableSpace Ω\ninst✝² : StandardBorelSpace Ω\ninst✝¹ : Nonempty Ω\nh : MeasurableSpace.CountableOrCountablyGenerated α β\nκ : ProbabilityTheory.Kernel α (Prod β Ω)\ninst✝ : ProbabilityTheory.IsFiniteKernel κ\n⊢ κ.IsCondKernel κ.condKernel","decl":"instance condKernel.instIsCondKernel : κ.IsCondKernel κ.condKernel where\n  disintegrate := by rw [condKernel_def]; split_ifs with hα <;> exact disintegrate _ _\n\n"}
