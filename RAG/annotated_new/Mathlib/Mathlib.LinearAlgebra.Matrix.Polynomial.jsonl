{"name":"Polynomial.natDegree_det_X_add_C_le","module":"Mathlib.LinearAlgebra.Matrix.Polynomial","initialProofState":"n : Type u_1\nα : Type u_2\ninst✝² : DecidableEq n\ninst✝¹ : Fintype n\ninst✝ : CommRing α\nA B : Matrix n n α\n⊢ LE.le (HAdd.hAdd (HSMul.hSMul Polynomial.X (A.map ⇑Polynomial.C)) (B.map ⇑Polynomial.C)).det.natDegree (Fintype.card n)","decl":"theorem natDegree_det_X_add_C_le (A B : Matrix n n α) :\n    natDegree (det ((X : α[X]) • A.map C + B.map C : Matrix n n α[X])) ≤ Fintype.card n := by\n  rw [det_apply]\n  refine (natDegree_sum_le _ _).trans ?_\n  refine Multiset.max_le_of_forall_le _ _ ?_\n  simp only [forall_apply_eq_imp_iff, true_and, Function.comp_apply, Multiset.map_map,\n    Multiset.mem_map, exists_imp, Finset.mem_univ_val]\n  intro g\n  calc\n    natDegree (sign g • ∏ i : n, (X • A.map C + B.map C : Matrix n n α[X]) (g i) i) ≤\n        natDegree (∏ i : n, (X • A.map C + B.map C : Matrix n n α[X]) (g i) i) := by\n      cases' Int.units_eq_one_or (sign g) with sg sg\n      · rw [sg, one_smul]\n      · rw [sg, Units.neg_smul, one_smul, natDegree_neg]\n    _ ≤ ∑ i : n, natDegree (((X : α[X]) • A.map C + B.map C : Matrix n n α[X]) (g i) i) :=\n      (natDegree_prod_le (Finset.univ : Finset n) fun i : n =>\n        (X • A.map C + B.map C : Matrix n n α[X]) (g i) i)\n    _ ≤ Finset.univ.card • 1 := (Finset.sum_le_card_nsmul _ _ 1 fun (i : n) _ => ?_)\n    _ ≤ Fintype.card n := by simp [mul_one, Algebra.id.smul_eq_mul, Finset.card_univ]\n  dsimp only [add_apply, smul_apply, map_apply, smul_eq_mul]\n  compute_degree\n\n"}
{"name":"Polynomial.coeff_det_X_add_C_zero","module":"Mathlib.LinearAlgebra.Matrix.Polynomial","initialProofState":"n : Type u_1\nα : Type u_2\ninst✝² : DecidableEq n\ninst✝¹ : Fintype n\ninst✝ : CommRing α\nA B : Matrix n n α\n⊢ Eq ((HAdd.hAdd (HSMul.hSMul Polynomial.X (A.map ⇑Polynomial.C)) (B.map ⇑Polynomial.C)).det.coeff 0) B.det","decl":"theorem coeff_det_X_add_C_zero (A B : Matrix n n α) :\n    coeff (det ((X : α[X]) • A.map C + B.map C)) 0 = det B := by\n  rw [det_apply, finset_sum_coeff, det_apply]\n  refine Finset.sum_congr rfl ?_\n  rintro g -\n  convert coeff_smul (R := α) (sign g) _ 0\n  rw [coeff_zero_prod]\n  refine Finset.prod_congr rfl ?_\n  simp\n\n"}
{"name":"Polynomial.coeff_det_X_add_C_card","module":"Mathlib.LinearAlgebra.Matrix.Polynomial","initialProofState":"n : Type u_1\nα : Type u_2\ninst✝² : DecidableEq n\ninst✝¹ : Fintype n\ninst✝ : CommRing α\nA B : Matrix n n α\n⊢ Eq ((HAdd.hAdd (HSMul.hSMul Polynomial.X (A.map ⇑Polynomial.C)) (B.map ⇑Polynomial.C)).det.coeff (Fintype.card n)) A.det","decl":"theorem coeff_det_X_add_C_card (A B : Matrix n n α) :\n    coeff (det ((X : α[X]) • A.map C + B.map C)) (Fintype.card n) = det A := by\n  rw [det_apply, det_apply, finset_sum_coeff]\n  refine Finset.sum_congr rfl ?_\n  simp only [Algebra.id.smul_eq_mul, Finset.mem_univ, RingHom.mapMatrix_apply, forall_true_left,\n    map_apply, Pi.smul_apply]\n  intro g\n  convert coeff_smul (R := α) (sign g) _ _\n  rw [← mul_one (Fintype.card n)]\n  convert (coeff_prod_of_natDegree_le (R := α) _ _ _ _).symm\n  · simp [coeff_C]\n  · rintro p -\n    dsimp only [add_apply, smul_apply, map_apply, smul_eq_mul]\n    compute_degree\n\n"}
{"name":"Polynomial.leadingCoeff_det_X_one_add_C","module":"Mathlib.LinearAlgebra.Matrix.Polynomial","initialProofState":"n : Type u_1\nα : Type u_2\ninst✝² : DecidableEq n\ninst✝¹ : Fintype n\ninst✝ : CommRing α\nA : Matrix n n α\n⊢ Eq (HAdd.hAdd (HSMul.hSMul Polynomial.X 1) (A.map ⇑Polynomial.C)).det.leadingCoeff 1","decl":"theorem leadingCoeff_det_X_one_add_C (A : Matrix n n α) :\n    leadingCoeff (det ((X : α[X]) • (1 : Matrix n n α[X]) + A.map C)) = 1 := by\n  cases subsingleton_or_nontrivial α\n  · simp [eq_iff_true_of_subsingleton]\n  rw [← @det_one n, ← coeff_det_X_add_C_card _ A, leadingCoeff]\n  simp only [Matrix.map_one, C_eq_zero, RingHom.map_one]\n  rcases (natDegree_det_X_add_C_le 1 A).eq_or_lt with h | h\n  · simp only [RingHom.map_one, Matrix.map_one, C_eq_zero] at h\n    rw [h]\n  · -- contradiction. we have a hypothesis that the degree is less than |n|\n    -- but we know that coeff _ n = 1\n    have H := coeff_eq_zero_of_natDegree_lt h\n    rw [coeff_det_X_add_C_card] at H\n    simp at H\n\n"}
