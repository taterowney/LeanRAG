{"name":"Matrix.mem_subfield_of_mul_eq_one_of_mem_subfield_right","module":"Mathlib.LinearAlgebra.Matrix.BaseChange","initialProofState":"m : Type u_1\nn : Type u_2\nL : Type u_3\ninst✝³ : Fintype m\ninst✝² : Fintype n\ninst✝¹ : DecidableEq m\ninst✝ : Field L\ne : Equiv m n\nK : Subfield L\nA : Matrix m n L\nB : Matrix n m L\nhAB : Eq (HMul.hMul A B) 1\nh_mem : ∀ (i : m) (j : n), Membership.mem K (A i j)\ni : n\nj : m\n⊢ Membership.mem K (B i j)","decl":"lemma mem_subfield_of_mul_eq_one_of_mem_subfield_right\n    (h_mem : ∀ i j, A i j ∈ K) (i : n) (j : m) :\n    B i j ∈ K := by\n  let A' : Matrix m m K := of fun i j ↦ ⟨A.submatrix id e i j, h_mem i (e j)⟩\n  have hA' : A'.map K.subtype = A.submatrix id e := rfl\n  have hA : IsUnit A' := by\n    have h_unit : IsUnit (A.submatrix id e) :=\n      isUnit_of_right_inverse (B := B.submatrix e id) (by simpa)\n    have h_det : (A.submatrix id e).det = K.subtype A'.det := by\n      simp [A', K.subtype.map_det, map, submatrix]\n    simpa [isUnit_iff_isUnit_det, h_det] using h_unit\n  obtain ⟨B', hB⟩ := exists_right_inverse_iff_isUnit.mpr hA\n  suffices (B'.submatrix e.symm id).map K.subtype = B by simp [← this]\n  replace hB : A * (B'.submatrix e.symm id).map K.subtype = 1 := by\n    replace hB := congr_arg (fun C ↦ C.map K.subtype) hB\n    simp_rw [map_mul] at hB\n    rw [hA', ← e.symm_symm, ← submatrix_id_mul_left] at hB\n    simpa using hB\n  classical\n  simpa [← Matrix.mul_assoc, (mul_eq_one_comm_of_equiv e).mp hAB] using congr_arg (B * ·) hB\n\n"}
{"name":"Matrix.mem_subfield_of_mul_eq_one_of_mem_subfield_left","module":"Mathlib.LinearAlgebra.Matrix.BaseChange","initialProofState":"m : Type u_1\nn : Type u_2\nL : Type u_3\ninst✝³ : Fintype m\ninst✝² : Fintype n\ninst✝¹ : DecidableEq m\ninst✝ : Field L\ne : Equiv m n\nK : Subfield L\nA : Matrix m n L\nB : Matrix n m L\nhAB : Eq (HMul.hMul A B) 1\nh_mem : ∀ (i : n) (j : m), Membership.mem K (B i j)\ni : m\nj : n\n⊢ Membership.mem K (A i j)","decl":"lemma mem_subfield_of_mul_eq_one_of_mem_subfield_left\n    (h_mem : ∀ i j, B i j ∈ K) (i : m) (j : n) :\n    A i j ∈ K := by\n  replace hAB : Bᵀ * Aᵀ = 1 := by simpa using congr_arg transpose hAB\n  rw [← A.transpose_apply]\n  simp_rw [← B.transpose_apply] at h_mem\n  exact mem_subfield_of_mul_eq_one_of_mem_subfield_right e K hAB (fun i j ↦ h_mem j i) j i\n\n"}
