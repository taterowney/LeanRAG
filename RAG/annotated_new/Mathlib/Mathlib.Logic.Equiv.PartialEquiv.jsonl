{"name":"PartialEquiv.left_inv'","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_5\nβ : Type u_6\nself : PartialEquiv α β\nx : α\na✝ : Membership.mem self.source x\n⊢ Eq (self.invFun (self.toFun x)) x","decl":"/-- Local equivalence between subsets `source` and `target` of `α` and `β` respectively. The\n(global) maps `toFun : α → β` and `invFun : β → α` map `source` to `target` and conversely, and are\ninverse to each other there. The values of `toFun` outside of `source` and of `invFun` outside of\n`target` are irrelevant. -/\nstructure PartialEquiv (α : Type*) (β : Type*) where\n  /-- The global function which has a partial inverse. Its value outside of the `source` subset is\n  irrelevant. -/\n  toFun : α → β\n  /-- The partial inverse to `toFun`. Its value outside of the `target` subset is irrelevant. -/\n  invFun : β → α\n  /-- The domain of the partial equivalence. -/\n  source : Set α\n  /-- The codomain of the partial equivalence. -/\n  target : Set β\n  /-- The proposition that elements of `source` are mapped to elements of `target`. -/\n  map_source' : ∀ ⦃x⦄, x ∈ source → toFun x ∈ target\n  /-- The proposition that elements of `target` are mapped to elements of `source`. -/\n  map_target' : ∀ ⦃x⦄, x ∈ target → invFun x ∈ source\n  /-- The proposition that `invFun` is a left-inverse of `toFun` on `source`. -/\n  left_inv' : ∀ ⦃x⦄, x ∈ source → invFun (toFun x) = x\n  /-- The proposition that `invFun` is a right-inverse of `toFun` on `target`. -/\n  right_inv' : ∀ ⦃x⦄, x ∈ target → toFun (invFun x) = x\n\n"}
{"name":"PartialEquiv.map_target'","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_5\nβ : Type u_6\nself : PartialEquiv α β\nx : β\na✝ : Membership.mem self.target x\n⊢ Membership.mem self.source (self.invFun x)","decl":"/-- Local equivalence between subsets `source` and `target` of `α` and `β` respectively. The\n(global) maps `toFun : α → β` and `invFun : β → α` map `source` to `target` and conversely, and are\ninverse to each other there. The values of `toFun` outside of `source` and of `invFun` outside of\n`target` are irrelevant. -/\nstructure PartialEquiv (α : Type*) (β : Type*) where\n  /-- The global function which has a partial inverse. Its value outside of the `source` subset is\n  irrelevant. -/\n  toFun : α → β\n  /-- The partial inverse to `toFun`. Its value outside of the `target` subset is irrelevant. -/\n  invFun : β → α\n  /-- The domain of the partial equivalence. -/\n  source : Set α\n  /-- The codomain of the partial equivalence. -/\n  target : Set β\n  /-- The proposition that elements of `source` are mapped to elements of `target`. -/\n  map_source' : ∀ ⦃x⦄, x ∈ source → toFun x ∈ target\n  /-- The proposition that elements of `target` are mapped to elements of `source`. -/\n  map_target' : ∀ ⦃x⦄, x ∈ target → invFun x ∈ source\n  /-- The proposition that `invFun` is a left-inverse of `toFun` on `source`. -/\n  left_inv' : ∀ ⦃x⦄, x ∈ source → invFun (toFun x) = x\n  /-- The proposition that `invFun` is a right-inverse of `toFun` on `target`. -/\n  right_inv' : ∀ ⦃x⦄, x ∈ target → toFun (invFun x) = x\n\n"}
{"name":"PartialEquiv.mk.injEq","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_5\nβ : Type u_6\ntoFun✝ : α → β\ninvFun✝ : β → α\nsource✝ : Set α\ntarget✝ : Set β\nmap_source'✝ : ∀ ⦃x : α⦄, Membership.mem source✝ x → Membership.mem target✝ (toFun✝ x)\nmap_target'✝ : ∀ ⦃x : β⦄, Membership.mem target✝ x → Membership.mem source✝ (invFun✝ x)\nleft_inv'✝ : ∀ ⦃x : α⦄, Membership.mem source✝ x → Eq (invFun✝ (toFun✝ x)) x\nright_inv'✝ : ∀ ⦃x : β⦄, Membership.mem target✝ x → Eq (toFun✝ (invFun✝ x)) x\ntoFun : α → β\ninvFun : β → α\nsource : Set α\ntarget : Set β\nmap_source' : ∀ ⦃x : α⦄, Membership.mem source x → Membership.mem target (toFun x)\nmap_target' : ∀ ⦃x : β⦄, Membership.mem target x → Membership.mem source (invFun x)\nleft_inv' : ∀ ⦃x : α⦄, Membership.mem source x → Eq (invFun (toFun x)) x\nright_inv' : ∀ ⦃x : β⦄, Membership.mem target x → Eq (toFun (invFun x)) x\n⊢ Eq (Eq { toFun := toFun✝, invFun := invFun✝, source := source✝, target := target✝, map_source' := map_source'✝, map_target' := map_target'✝, left_inv' := left_inv'✝, right_inv' := right_inv'✝ } { toFun := toFun, invFun := invFun, source := source, target := target, map_source' := map_source', map_target' := map_target', left_inv' := left_inv', right_inv' := right_inv' }) (And (Eq toFun✝ toFun) (And (Eq invFun✝ invFun) (And (Eq source✝ source) (Eq target✝ target))))","decl":"/-- Local equivalence between subsets `source` and `target` of `α` and `β` respectively. The\n(global) maps `toFun : α → β` and `invFun : β → α` map `source` to `target` and conversely, and are\ninverse to each other there. The values of `toFun` outside of `source` and of `invFun` outside of\n`target` are irrelevant. -/\nstructure PartialEquiv (α : Type*) (β : Type*) where\n  /-- The global function which has a partial inverse. Its value outside of the `source` subset is\n  irrelevant. -/\n  toFun : α → β\n  /-- The partial inverse to `toFun`. Its value outside of the `target` subset is irrelevant. -/\n  invFun : β → α\n  /-- The domain of the partial equivalence. -/\n  source : Set α\n  /-- The codomain of the partial equivalence. -/\n  target : Set β\n  /-- The proposition that elements of `source` are mapped to elements of `target`. -/\n  map_source' : ∀ ⦃x⦄, x ∈ source → toFun x ∈ target\n  /-- The proposition that elements of `target` are mapped to elements of `source`. -/\n  map_target' : ∀ ⦃x⦄, x ∈ target → invFun x ∈ source\n  /-- The proposition that `invFun` is a left-inverse of `toFun` on `source`. -/\n  left_inv' : ∀ ⦃x⦄, x ∈ source → invFun (toFun x) = x\n  /-- The proposition that `invFun` is a right-inverse of `toFun` on `target`. -/\n  right_inv' : ∀ ⦃x⦄, x ∈ target → toFun (invFun x) = x\n\n"}
{"name":"PartialEquiv.mk.sizeOf_spec","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_5\nβ : Type u_6\ninst✝¹ : SizeOf α\ninst✝ : SizeOf β\ntoFun : α → β\ninvFun : β → α\nsource : Set α\ntarget : Set β\nmap_source' : ∀ ⦃x : α⦄, Membership.mem source x → Membership.mem target (toFun x)\nmap_target' : ∀ ⦃x : β⦄, Membership.mem target x → Membership.mem source (invFun x)\nleft_inv' : ∀ ⦃x : α⦄, Membership.mem source x → Eq (invFun (toFun x)) x\nright_inv' : ∀ ⦃x : β⦄, Membership.mem target x → Eq (toFun (invFun x)) x\n⊢ Eq (SizeOf.sizeOf { toFun := toFun, invFun := invFun, source := source, target := target, map_source' := map_source', map_target' := map_target', left_inv' := left_inv', right_inv' := right_inv' }) 1","decl":"/-- Local equivalence between subsets `source` and `target` of `α` and `β` respectively. The\n(global) maps `toFun : α → β` and `invFun : β → α` map `source` to `target` and conversely, and are\ninverse to each other there. The values of `toFun` outside of `source` and of `invFun` outside of\n`target` are irrelevant. -/\nstructure PartialEquiv (α : Type*) (β : Type*) where\n  /-- The global function which has a partial inverse. Its value outside of the `source` subset is\n  irrelevant. -/\n  toFun : α → β\n  /-- The partial inverse to `toFun`. Its value outside of the `target` subset is irrelevant. -/\n  invFun : β → α\n  /-- The domain of the partial equivalence. -/\n  source : Set α\n  /-- The codomain of the partial equivalence. -/\n  target : Set β\n  /-- The proposition that elements of `source` are mapped to elements of `target`. -/\n  map_source' : ∀ ⦃x⦄, x ∈ source → toFun x ∈ target\n  /-- The proposition that elements of `target` are mapped to elements of `source`. -/\n  map_target' : ∀ ⦃x⦄, x ∈ target → invFun x ∈ source\n  /-- The proposition that `invFun` is a left-inverse of `toFun` on `source`. -/\n  left_inv' : ∀ ⦃x⦄, x ∈ source → invFun (toFun x) = x\n  /-- The proposition that `invFun` is a right-inverse of `toFun` on `target`. -/\n  right_inv' : ∀ ⦃x⦄, x ∈ target → toFun (invFun x) = x\n\n"}
{"name":"PartialEquiv.map_source'","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_5\nβ : Type u_6\nself : PartialEquiv α β\nx : α\na✝ : Membership.mem self.source x\n⊢ Membership.mem self.target (self.toFun x)","decl":"/-- Local equivalence between subsets `source` and `target` of `α` and `β` respectively. The\n(global) maps `toFun : α → β` and `invFun : β → α` map `source` to `target` and conversely, and are\ninverse to each other there. The values of `toFun` outside of `source` and of `invFun` outside of\n`target` are irrelevant. -/\nstructure PartialEquiv (α : Type*) (β : Type*) where\n  /-- The global function which has a partial inverse. Its value outside of the `source` subset is\n  irrelevant. -/\n  toFun : α → β\n  /-- The partial inverse to `toFun`. Its value outside of the `target` subset is irrelevant. -/\n  invFun : β → α\n  /-- The domain of the partial equivalence. -/\n  source : Set α\n  /-- The codomain of the partial equivalence. -/\n  target : Set β\n  /-- The proposition that elements of `source` are mapped to elements of `target`. -/\n  map_source' : ∀ ⦃x⦄, x ∈ source → toFun x ∈ target\n  /-- The proposition that elements of `target` are mapped to elements of `source`. -/\n  map_target' : ∀ ⦃x⦄, x ∈ target → invFun x ∈ source\n  /-- The proposition that `invFun` is a left-inverse of `toFun` on `source`. -/\n  left_inv' : ∀ ⦃x⦄, x ∈ source → invFun (toFun x) = x\n  /-- The proposition that `invFun` is a right-inverse of `toFun` on `target`. -/\n  right_inv' : ∀ ⦃x⦄, x ∈ target → toFun (invFun x) = x\n\n"}
{"name":"PartialEquiv.mk.inj","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_5\nβ : Type u_6\ntoFun✝ : α → β\ninvFun✝ : β → α\nsource✝ : Set α\ntarget✝ : Set β\nmap_source'✝ : ∀ ⦃x : α⦄, Membership.mem source✝ x → Membership.mem target✝ (toFun✝ x)\nmap_target'✝ : ∀ ⦃x : β⦄, Membership.mem target✝ x → Membership.mem source✝ (invFun✝ x)\nleft_inv'✝ : ∀ ⦃x : α⦄, Membership.mem source✝ x → Eq (invFun✝ (toFun✝ x)) x\nright_inv'✝ : ∀ ⦃x : β⦄, Membership.mem target✝ x → Eq (toFun✝ (invFun✝ x)) x\ntoFun : α → β\ninvFun : β → α\nsource : Set α\ntarget : Set β\nmap_source' : ∀ ⦃x : α⦄, Membership.mem source x → Membership.mem target (toFun x)\nmap_target' : ∀ ⦃x : β⦄, Membership.mem target x → Membership.mem source (invFun x)\nleft_inv' : ∀ ⦃x : α⦄, Membership.mem source x → Eq (invFun (toFun x)) x\nright_inv' : ∀ ⦃x : β⦄, Membership.mem target x → Eq (toFun (invFun x)) x\nx✝ : Eq { toFun := toFun✝, invFun := invFun✝, source := source✝, target := target✝, map_source' := map_source'✝, map_target' := map_target'✝, left_inv' := left_inv'✝, right_inv' := right_inv'✝ } { toFun := toFun, invFun := invFun, source := source, target := target, map_source' := map_source', map_target' := map_target', left_inv' := left_inv', right_inv' := right_inv' }\n⊢ And (Eq toFun✝ toFun) (And (Eq invFun✝ invFun) (And (Eq source✝ source) (Eq target✝ target)))","decl":"/-- Local equivalence between subsets `source` and `target` of `α` and `β` respectively. The\n(global) maps `toFun : α → β` and `invFun : β → α` map `source` to `target` and conversely, and are\ninverse to each other there. The values of `toFun` outside of `source` and of `invFun` outside of\n`target` are irrelevant. -/\nstructure PartialEquiv (α : Type*) (β : Type*) where\n  /-- The global function which has a partial inverse. Its value outside of the `source` subset is\n  irrelevant. -/\n  toFun : α → β\n  /-- The partial inverse to `toFun`. Its value outside of the `target` subset is irrelevant. -/\n  invFun : β → α\n  /-- The domain of the partial equivalence. -/\n  source : Set α\n  /-- The codomain of the partial equivalence. -/\n  target : Set β\n  /-- The proposition that elements of `source` are mapped to elements of `target`. -/\n  map_source' : ∀ ⦃x⦄, x ∈ source → toFun x ∈ target\n  /-- The proposition that elements of `target` are mapped to elements of `source`. -/\n  map_target' : ∀ ⦃x⦄, x ∈ target → invFun x ∈ source\n  /-- The proposition that `invFun` is a left-inverse of `toFun` on `source`. -/\n  left_inv' : ∀ ⦃x⦄, x ∈ source → invFun (toFun x) = x\n  /-- The proposition that `invFun` is a right-inverse of `toFun` on `target`. -/\n  right_inv' : ∀ ⦃x⦄, x ∈ target → toFun (invFun x) = x\n\n"}
{"name":"PartialEquiv.right_inv'","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_5\nβ : Type u_6\nself : PartialEquiv α β\nx : β\na✝ : Membership.mem self.target x\n⊢ Eq (self.toFun (self.invFun x)) x","decl":"/-- Local equivalence between subsets `source` and `target` of `α` and `β` respectively. The\n(global) maps `toFun : α → β` and `invFun : β → α` map `source` to `target` and conversely, and are\ninverse to each other there. The values of `toFun` outside of `source` and of `invFun` outside of\n`target` are irrelevant. -/\nstructure PartialEquiv (α : Type*) (β : Type*) where\n  /-- The global function which has a partial inverse. Its value outside of the `source` subset is\n  irrelevant. -/\n  toFun : α → β\n  /-- The partial inverse to `toFun`. Its value outside of the `target` subset is irrelevant. -/\n  invFun : β → α\n  /-- The domain of the partial equivalence. -/\n  source : Set α\n  /-- The codomain of the partial equivalence. -/\n  target : Set β\n  /-- The proposition that elements of `source` are mapped to elements of `target`. -/\n  map_source' : ∀ ⦃x⦄, x ∈ source → toFun x ∈ target\n  /-- The proposition that elements of `target` are mapped to elements of `source`. -/\n  map_target' : ∀ ⦃x⦄, x ∈ target → invFun x ∈ source\n  /-- The proposition that `invFun` is a left-inverse of `toFun` on `source`. -/\n  left_inv' : ∀ ⦃x⦄, x ∈ source → invFun (toFun x) = x\n  /-- The proposition that `invFun` is a right-inverse of `toFun` on `target`. -/\n  right_inv' : ∀ ⦃x⦄, x ∈ target → toFun (invFun x) = x\n\n"}
{"name":"PartialEquiv.coe_symm_mk","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\ng : β → α\ns : Set α\nt : Set β\nml : ∀ ⦃x : α⦄, Membership.mem s x → Membership.mem t (f x)\nmr : ∀ ⦃x : β⦄, Membership.mem t x → Membership.mem s (g x)\nil : ∀ ⦃x : α⦄, Membership.mem s x → Eq (g (f x)) x\nir : ∀ ⦃x : β⦄, Membership.mem t x → Eq (f (g x)) x\n⊢ Eq (↑{ toFun := f, invFun := g, source := s, target := t, map_source' := ml, map_target' := mr, left_inv' := il, right_inv' := ir }.symm) g","decl":"@[simp, mfld_simps]\ntheorem coe_symm_mk (f : α → β) (g s t ml mr il ir) :\n    ((PartialEquiv.mk f g s t ml mr il ir).symm : β → α) = g :=\n  rfl\n\n-- Porting note: this is now a syntactic tautology\n-- @[simp, mfld_simps]\n-- theorem toFun_as_coe : e.toFun = e := rfl\n\n"}
{"name":"PartialEquiv.invFun_as_coe","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\nβ : Type u_2\ne : PartialEquiv α β\n⊢ Eq e.invFun ↑e.symm","decl":"@[simp, mfld_simps]\ntheorem invFun_as_coe : e.invFun = e.symm :=\n  rfl\n\n"}
{"name":"PartialEquiv.map_source","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\nβ : Type u_2\ne : PartialEquiv α β\nx : α\nh : Membership.mem e.source x\n⊢ Membership.mem e.target (↑e x)","decl":"@[simp, mfld_simps]\ntheorem map_source {x : α} (h : x ∈ e.source) : e x ∈ e.target :=\n  e.map_source' h\n\n"}
{"name":"PartialEquiv.map_source''","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\nβ : Type u_2\ne : PartialEquiv α β\n⊢ HasSubset.Subset (Set.image (↑e) e.source) e.target","decl":"/-- Variant of `e.map_source` and `map_source'`, stated for images of subsets of `source`. -/\nlemma map_source'' : e '' e.source ⊆ e.target :=\n  fun _ ⟨_, hx, hex⟩ ↦ mem_of_eq_of_mem (id hex.symm) (e.map_source' hx)\n\n"}
{"name":"PartialEquiv.map_target","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\nβ : Type u_2\ne : PartialEquiv α β\nx : β\nh : Membership.mem e.target x\n⊢ Membership.mem e.source (↑e.symm x)","decl":"@[simp, mfld_simps]\ntheorem map_target {x : β} (h : x ∈ e.target) : e.symm x ∈ e.source :=\n  e.map_target' h\n\n"}
{"name":"PartialEquiv.left_inv","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\nβ : Type u_2\ne : PartialEquiv α β\nx : α\nh : Membership.mem e.source x\n⊢ Eq (↑e.symm (↑e x)) x","decl":"@[simp, mfld_simps]\ntheorem left_inv {x : α} (h : x ∈ e.source) : e.symm (e x) = x :=\n  e.left_inv' h\n\n"}
{"name":"PartialEquiv.right_inv","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\nβ : Type u_2\ne : PartialEquiv α β\nx : β\nh : Membership.mem e.target x\n⊢ Eq (↑e (↑e.symm x)) x","decl":"@[simp, mfld_simps]\ntheorem right_inv {x : β} (h : x ∈ e.target) : e (e.symm x) = x :=\n  e.right_inv' h\n\n"}
{"name":"PartialEquiv.eq_symm_apply","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\nβ : Type u_2\ne : PartialEquiv α β\nx : α\ny : β\nhx : Membership.mem e.source x\nhy : Membership.mem e.target y\n⊢ Iff (Eq x (↑e.symm y)) (Eq (↑e x) y)","decl":"theorem eq_symm_apply {x : α} {y : β} (hx : x ∈ e.source) (hy : y ∈ e.target) :\n    x = e.symm y ↔ e x = y :=\n  ⟨fun h => by rw [← e.right_inv hy, h], fun h => by rw [← e.left_inv hx, h]⟩\n\n"}
{"name":"PartialEquiv.mapsTo","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\nβ : Type u_2\ne : PartialEquiv α β\n⊢ Set.MapsTo (↑e) e.source e.target","decl":"protected theorem mapsTo : MapsTo e e.source e.target := fun _ => e.map_source\n\n"}
{"name":"PartialEquiv.symm_mapsTo","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\nβ : Type u_2\ne : PartialEquiv α β\n⊢ Set.MapsTo (↑e.symm) e.target e.source","decl":"theorem symm_mapsTo : MapsTo e.symm e.target e.source :=\n  e.symm.mapsTo\n\n"}
{"name":"PartialEquiv.leftInvOn","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\nβ : Type u_2\ne : PartialEquiv α β\n⊢ Set.LeftInvOn (↑e.symm) (↑e) e.source","decl":"protected theorem leftInvOn : LeftInvOn e.symm e e.source := fun _ => e.left_inv\n\n"}
{"name":"PartialEquiv.rightInvOn","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\nβ : Type u_2\ne : PartialEquiv α β\n⊢ Set.RightInvOn (↑e.symm) (↑e) e.target","decl":"protected theorem rightInvOn : RightInvOn e.symm e e.target := fun _ => e.right_inv\n\n"}
{"name":"PartialEquiv.invOn","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\nβ : Type u_2\ne : PartialEquiv α β\n⊢ Set.InvOn (↑e.symm) (↑e) e.source e.target","decl":"protected theorem invOn : InvOn e.symm e e.source e.target :=\n  ⟨e.leftInvOn, e.rightInvOn⟩\n\n"}
{"name":"PartialEquiv.injOn","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\nβ : Type u_2\ne : PartialEquiv α β\n⊢ Set.InjOn (↑e) e.source","decl":"protected theorem injOn : InjOn e e.source :=\n  e.leftInvOn.injOn\n\n"}
{"name":"PartialEquiv.bijOn","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\nβ : Type u_2\ne : PartialEquiv α β\n⊢ Set.BijOn (↑e) e.source e.target","decl":"protected theorem bijOn : BijOn e e.source e.target :=\n  e.invOn.bijOn e.mapsTo e.symm_mapsTo\n\n"}
{"name":"PartialEquiv.surjOn","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\nβ : Type u_2\ne : PartialEquiv α β\n⊢ Set.SurjOn (↑e) e.source e.target","decl":"protected theorem surjOn : SurjOn e e.source e.target :=\n  e.bijOn.surjOn\n\n"}
{"name":"Equiv.toPartialEquivOfImageEq_target","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\nβ : Type u_2\ne : Equiv α β\ns : Set α\nt : Set β\nh : Eq (Set.image (⇑e) s) t\n⊢ Eq (e.toPartialEquivOfImageEq s t h).target t","decl":"/-- Interpret an `Equiv` as a `PartialEquiv` by restricting it to `s` in the domain\nand to `t` in the codomain. -/\n@[simps (config := .asFn)]\ndef _root_.Equiv.toPartialEquivOfImageEq (e : α ≃ β) (s : Set α) (t : Set β) (h : e '' s = t) :\n    PartialEquiv α β where\n  toFun := e\n  invFun := e.symm\n  source := s\n  target := t\n  map_source' _ hx := h ▸ mem_image_of_mem _ hx\n  map_target' x hx := by\n    subst t\n    rcases hx with ⟨x, hx, rfl⟩\n    rwa [e.symm_apply_apply]\n  left_inv' x _ := e.symm_apply_apply x\n  right_inv' x _ := e.apply_symm_apply x\n\n"}
{"name":"Equiv.toPartialEquivOfImageEq_apply","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\nβ : Type u_2\ne : Equiv α β\ns : Set α\nt : Set β\nh : Eq (Set.image (⇑e) s) t\n⊢ Eq ↑(e.toPartialEquivOfImageEq s t h) ⇑e","decl":"/-- Interpret an `Equiv` as a `PartialEquiv` by restricting it to `s` in the domain\nand to `t` in the codomain. -/\n@[simps (config := .asFn)]\ndef _root_.Equiv.toPartialEquivOfImageEq (e : α ≃ β) (s : Set α) (t : Set β) (h : e '' s = t) :\n    PartialEquiv α β where\n  toFun := e\n  invFun := e.symm\n  source := s\n  target := t\n  map_source' _ hx := h ▸ mem_image_of_mem _ hx\n  map_target' x hx := by\n    subst t\n    rcases hx with ⟨x, hx, rfl⟩\n    rwa [e.symm_apply_apply]\n  left_inv' x _ := e.symm_apply_apply x\n  right_inv' x _ := e.apply_symm_apply x\n\n"}
{"name":"Equiv.toPartialEquivOfImageEq_symm_apply","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\nβ : Type u_2\ne : Equiv α β\ns : Set α\nt : Set β\nh : Eq (Set.image (⇑e) s) t\n⊢ Eq ↑(e.toPartialEquivOfImageEq s t h).symm ⇑e.symm","decl":"/-- Interpret an `Equiv` as a `PartialEquiv` by restricting it to `s` in the domain\nand to `t` in the codomain. -/\n@[simps (config := .asFn)]\ndef _root_.Equiv.toPartialEquivOfImageEq (e : α ≃ β) (s : Set α) (t : Set β) (h : e '' s = t) :\n    PartialEquiv α β where\n  toFun := e\n  invFun := e.symm\n  source := s\n  target := t\n  map_source' _ hx := h ▸ mem_image_of_mem _ hx\n  map_target' x hx := by\n    subst t\n    rcases hx with ⟨x, hx, rfl⟩\n    rwa [e.symm_apply_apply]\n  left_inv' x _ := e.symm_apply_apply x\n  right_inv' x _ := e.apply_symm_apply x\n\n"}
{"name":"Equiv.toPartialEquivOfImageEq_source","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\nβ : Type u_2\ne : Equiv α β\ns : Set α\nt : Set β\nh : Eq (Set.image (⇑e) s) t\n⊢ Eq (e.toPartialEquivOfImageEq s t h).source s","decl":"/-- Interpret an `Equiv` as a `PartialEquiv` by restricting it to `s` in the domain\nand to `t` in the codomain. -/\n@[simps (config := .asFn)]\ndef _root_.Equiv.toPartialEquivOfImageEq (e : α ≃ β) (s : Set α) (t : Set β) (h : e '' s = t) :\n    PartialEquiv α β where\n  toFun := e\n  invFun := e.symm\n  source := s\n  target := t\n  map_source' _ hx := h ▸ mem_image_of_mem _ hx\n  map_target' x hx := by\n    subst t\n    rcases hx with ⟨x, hx, rfl⟩\n    rwa [e.symm_apply_apply]\n  left_inv' x _ := e.symm_apply_apply x\n  right_inv' x _ := e.apply_symm_apply x\n\n"}
{"name":"Equiv.toPartialEquiv_source","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\nβ : Type u_2\ne : Equiv α β\n⊢ Eq e.toPartialEquiv.source Set.univ","decl":"/-- Associate a `PartialEquiv` to an `Equiv`. -/\n@[simps! (config := mfld_cfg)]\ndef _root_.Equiv.toPartialEquiv (e : α ≃ β) : PartialEquiv α β :=\n  e.toPartialEquivOfImageEq univ univ <| by rw [image_univ, e.surjective.range_eq]\n\n"}
{"name":"Equiv.toPartialEquiv_apply","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\nβ : Type u_2\ne : Equiv α β\n⊢ Eq ↑e.toPartialEquiv ⇑e","decl":"/-- Associate a `PartialEquiv` to an `Equiv`. -/\n@[simps! (config := mfld_cfg)]\ndef _root_.Equiv.toPartialEquiv (e : α ≃ β) : PartialEquiv α β :=\n  e.toPartialEquivOfImageEq univ univ <| by rw [image_univ, e.surjective.range_eq]\n\n"}
{"name":"Equiv.toPartialEquiv_target","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\nβ : Type u_2\ne : Equiv α β\n⊢ Eq e.toPartialEquiv.target Set.univ","decl":"/-- Associate a `PartialEquiv` to an `Equiv`. -/\n@[simps! (config := mfld_cfg)]\ndef _root_.Equiv.toPartialEquiv (e : α ≃ β) : PartialEquiv α β :=\n  e.toPartialEquivOfImageEq univ univ <| by rw [image_univ, e.surjective.range_eq]\n\n"}
{"name":"Equiv.toPartialEquiv_symm_apply","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\nβ : Type u_2\ne : Equiv α β\n⊢ Eq ↑e.toPartialEquiv.symm ⇑e.symm","decl":"/-- Associate a `PartialEquiv` to an `Equiv`. -/\n@[simps! (config := mfld_cfg)]\ndef _root_.Equiv.toPartialEquiv (e : α ≃ β) : PartialEquiv α β :=\n  e.toPartialEquivOfImageEq univ univ <| by rw [image_univ, e.surjective.range_eq]\n\n"}
{"name":"PartialEquiv.copy_symm_apply","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\nβ : Type u_2\ne : PartialEquiv α β\nf : α → β\nhf : Eq (↑e) f\ng : β → α\nhg : Eq (↑e.symm) g\ns : Set α\nhs : Eq e.source s\nt : Set β\nht : Eq e.target t\n⊢ Eq (↑(e.copy f hf g hg s hs t ht).symm) g","decl":"/-- Create a copy of a `PartialEquiv` providing better definitional equalities. -/\n@[simps (config := .asFn)]\ndef copy (e : PartialEquiv α β) (f : α → β) (hf : ⇑e = f) (g : β → α) (hg : ⇑e.symm = g) (s : Set α)\n    (hs : e.source = s) (t : Set β) (ht : e.target = t) :\n    PartialEquiv α β where\n  toFun := f\n  invFun := g\n  source := s\n  target := t\n  map_source' _ := ht ▸ hs ▸ hf ▸ e.map_source\n  map_target' _ := hs ▸ ht ▸ hg ▸ e.map_target\n  left_inv' _ := hs ▸ hf ▸ hg ▸ e.left_inv\n  right_inv' _ := ht ▸ hf ▸ hg ▸ e.right_inv\n\n"}
{"name":"PartialEquiv.copy_apply","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\nβ : Type u_2\ne : PartialEquiv α β\nf : α → β\nhf : Eq (↑e) f\ng : β → α\nhg : Eq (↑e.symm) g\ns : Set α\nhs : Eq e.source s\nt : Set β\nht : Eq e.target t\n⊢ Eq (↑(e.copy f hf g hg s hs t ht)) f","decl":"/-- Create a copy of a `PartialEquiv` providing better definitional equalities. -/\n@[simps (config := .asFn)]\ndef copy (e : PartialEquiv α β) (f : α → β) (hf : ⇑e = f) (g : β → α) (hg : ⇑e.symm = g) (s : Set α)\n    (hs : e.source = s) (t : Set β) (ht : e.target = t) :\n    PartialEquiv α β where\n  toFun := f\n  invFun := g\n  source := s\n  target := t\n  map_source' _ := ht ▸ hs ▸ hf ▸ e.map_source\n  map_target' _ := hs ▸ ht ▸ hg ▸ e.map_target\n  left_inv' _ := hs ▸ hf ▸ hg ▸ e.left_inv\n  right_inv' _ := ht ▸ hf ▸ hg ▸ e.right_inv\n\n"}
{"name":"PartialEquiv.copy_target","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\nβ : Type u_2\ne : PartialEquiv α β\nf : α → β\nhf : Eq (↑e) f\ng : β → α\nhg : Eq (↑e.symm) g\ns : Set α\nhs : Eq e.source s\nt : Set β\nht : Eq e.target t\n⊢ Eq (e.copy f hf g hg s hs t ht).target t","decl":"/-- Create a copy of a `PartialEquiv` providing better definitional equalities. -/\n@[simps (config := .asFn)]\ndef copy (e : PartialEquiv α β) (f : α → β) (hf : ⇑e = f) (g : β → α) (hg : ⇑e.symm = g) (s : Set α)\n    (hs : e.source = s) (t : Set β) (ht : e.target = t) :\n    PartialEquiv α β where\n  toFun := f\n  invFun := g\n  source := s\n  target := t\n  map_source' _ := ht ▸ hs ▸ hf ▸ e.map_source\n  map_target' _ := hs ▸ ht ▸ hg ▸ e.map_target\n  left_inv' _ := hs ▸ hf ▸ hg ▸ e.left_inv\n  right_inv' _ := ht ▸ hf ▸ hg ▸ e.right_inv\n\n"}
{"name":"PartialEquiv.copy_source","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\nβ : Type u_2\ne : PartialEquiv α β\nf : α → β\nhf : Eq (↑e) f\ng : β → α\nhg : Eq (↑e.symm) g\ns : Set α\nhs : Eq e.source s\nt : Set β\nht : Eq e.target t\n⊢ Eq (e.copy f hf g hg s hs t ht).source s","decl":"/-- Create a copy of a `PartialEquiv` providing better definitional equalities. -/\n@[simps (config := .asFn)]\ndef copy (e : PartialEquiv α β) (f : α → β) (hf : ⇑e = f) (g : β → α) (hg : ⇑e.symm = g) (s : Set α)\n    (hs : e.source = s) (t : Set β) (ht : e.target = t) :\n    PartialEquiv α β where\n  toFun := f\n  invFun := g\n  source := s\n  target := t\n  map_source' _ := ht ▸ hs ▸ hf ▸ e.map_source\n  map_target' _ := hs ▸ ht ▸ hg ▸ e.map_target\n  left_inv' _ := hs ▸ hf ▸ hg ▸ e.left_inv\n  right_inv' _ := ht ▸ hf ▸ hg ▸ e.right_inv\n\n"}
{"name":"PartialEquiv.copy_eq","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\nβ : Type u_2\ne : PartialEquiv α β\nf : α → β\nhf : Eq (↑e) f\ng : β → α\nhg : Eq (↑e.symm) g\ns : Set α\nhs : Eq e.source s\nt : Set β\nht : Eq e.target t\n⊢ Eq (e.copy f hf g hg s hs t ht) e","decl":"theorem copy_eq (e : PartialEquiv α β) (f : α → β) (hf : ⇑e = f) (g : β → α) (hg : ⇑e.symm = g)\n    (s : Set α) (hs : e.source = s) (t : Set β) (ht : e.target = t) :\n    e.copy f hf g hg s hs t ht = e := by\n  substs f g s t\n  cases e\n  rfl\n\n"}
{"name":"PartialEquiv.symm_source","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\nβ : Type u_2\ne : PartialEquiv α β\n⊢ Eq e.symm.source e.target","decl":"@[simp, mfld_simps]\ntheorem symm_source : e.symm.source = e.target :=\n  rfl\n\n"}
{"name":"PartialEquiv.symm_target","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\nβ : Type u_2\ne : PartialEquiv α β\n⊢ Eq e.symm.target e.source","decl":"@[simp, mfld_simps]\ntheorem symm_target : e.symm.target = e.source :=\n  rfl\n\n"}
{"name":"PartialEquiv.symm_symm","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\nβ : Type u_2\ne : PartialEquiv α β\n⊢ Eq e.symm.symm e","decl":"@[simp, mfld_simps]\ntheorem symm_symm : e.symm.symm = e := rfl\n\n"}
{"name":"PartialEquiv.symm_bijective","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\nβ : Type u_2\n⊢ Function.Bijective PartialEquiv.symm","decl":"theorem symm_bijective :\n    Function.Bijective (PartialEquiv.symm : PartialEquiv α β → PartialEquiv β α) :=\n  Function.bijective_iff_has_inverse.mpr ⟨_, symm_symm, symm_symm⟩\n\n"}
{"name":"PartialEquiv.image_source_eq_target","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\nβ : Type u_2\ne : PartialEquiv α β\n⊢ Eq (Set.image (↑e) e.source) e.target","decl":"theorem image_source_eq_target : e '' e.source = e.target :=\n  e.bijOn.image_eq\n\n"}
{"name":"PartialEquiv.forall_mem_target","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\nβ : Type u_2\ne : PartialEquiv α β\np : β → Prop\n⊢ Iff (∀ (y : β), Membership.mem e.target y → p y) (∀ (x : α), Membership.mem e.source x → p (↑e x))","decl":"theorem forall_mem_target {p : β → Prop} : (∀ y ∈ e.target, p y) ↔ ∀ x ∈ e.source, p (e x) := by\n  rw [← image_source_eq_target, forall_mem_image]\n\n"}
{"name":"PartialEquiv.exists_mem_target","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\nβ : Type u_2\ne : PartialEquiv α β\np : β → Prop\n⊢ Iff (Exists fun y => And (Membership.mem e.target y) (p y)) (Exists fun x => And (Membership.mem e.source x) (p (↑e x)))","decl":"theorem exists_mem_target {p : β → Prop} : (∃ y ∈ e.target, p y) ↔ ∃ x ∈ e.source, p (e x) := by\n  rw [← image_source_eq_target, exists_mem_image]\n\n"}
{"name":"PartialEquiv.IsImage.apply_mem_iff","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\nβ : Type u_2\ne : PartialEquiv α β\ns : Set α\nt : Set β\nx : α\nh : e.IsImage s t\nhx : Membership.mem e.source x\n⊢ Iff (Membership.mem t (↑e x)) (Membership.mem s x)","decl":"theorem apply_mem_iff (h : e.IsImage s t) (hx : x ∈ e.source) : e x ∈ t ↔ x ∈ s :=\n  h hx\n\n"}
{"name":"PartialEquiv.IsImage.symm_apply_mem_iff","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\nβ : Type u_2\ne : PartialEquiv α β\ns : Set α\nt : Set β\nh : e.IsImage s t\ny : β\na✝ : Membership.mem e.target y\n⊢ Iff (Membership.mem s (↑e.symm y)) (Membership.mem t y)","decl":"theorem symm_apply_mem_iff (h : e.IsImage s t) : ∀ ⦃y⦄, y ∈ e.target → (e.symm y ∈ s ↔ y ∈ t) :=\n  e.forall_mem_target.mpr fun x hx => by rw [e.left_inv hx, h hx]\n\n"}
{"name":"PartialEquiv.IsImage.symm","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\nβ : Type u_2\ne : PartialEquiv α β\ns : Set α\nt : Set β\nh : e.IsImage s t\n⊢ e.symm.IsImage t s","decl":"protected theorem symm (h : e.IsImage s t) : e.symm.IsImage t s :=\n  h.symm_apply_mem_iff\n\n"}
{"name":"PartialEquiv.IsImage.symm_iff","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\nβ : Type u_2\ne : PartialEquiv α β\ns : Set α\nt : Set β\n⊢ Iff (e.symm.IsImage t s) (e.IsImage s t)","decl":"@[simp]\ntheorem symm_iff : e.symm.IsImage t s ↔ e.IsImage s t :=\n  ⟨fun h => h.symm, fun h => h.symm⟩\n\n"}
{"name":"PartialEquiv.IsImage.mapsTo","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\nβ : Type u_2\ne : PartialEquiv α β\ns : Set α\nt : Set β\nh : e.IsImage s t\n⊢ Set.MapsTo (↑e) (Inter.inter e.source s) (Inter.inter e.target t)","decl":"protected theorem mapsTo (h : e.IsImage s t) : MapsTo e (e.source ∩ s) (e.target ∩ t) :=\n  fun _ hx => ⟨e.mapsTo hx.1, (h hx.1).2 hx.2⟩\n\n"}
{"name":"PartialEquiv.IsImage.symm_mapsTo","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\nβ : Type u_2\ne : PartialEquiv α β\ns : Set α\nt : Set β\nh : e.IsImage s t\n⊢ Set.MapsTo (↑e.symm) (Inter.inter e.target t) (Inter.inter e.source s)","decl":"theorem symm_mapsTo (h : e.IsImage s t) : MapsTo e.symm (e.target ∩ t) (e.source ∩ s) :=\n  h.symm.mapsTo\n\n"}
{"name":"PartialEquiv.IsImage.restr_target","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\nβ : Type u_2\ne : PartialEquiv α β\ns : Set α\nt : Set β\nh : e.IsImage s t\n⊢ Eq h.restr.target (Inter.inter e.target t)","decl":"/-- Restrict a `PartialEquiv` to a pair of corresponding sets. -/\n@[simps (config := .asFn)]\ndef restr (h : e.IsImage s t) : PartialEquiv α β where\n  toFun := e\n  invFun := e.symm\n  source := e.source ∩ s\n  target := e.target ∩ t\n  map_source' := h.mapsTo\n  map_target' := h.symm_mapsTo\n  left_inv' := e.leftInvOn.mono inter_subset_left\n  right_inv' := e.rightInvOn.mono inter_subset_left\n\n"}
{"name":"PartialEquiv.IsImage.restr_symm_apply","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\nβ : Type u_2\ne : PartialEquiv α β\ns : Set α\nt : Set β\nh : e.IsImage s t\n⊢ Eq ↑h.restr.symm ↑e.symm","decl":"/-- Restrict a `PartialEquiv` to a pair of corresponding sets. -/\n@[simps (config := .asFn)]\ndef restr (h : e.IsImage s t) : PartialEquiv α β where\n  toFun := e\n  invFun := e.symm\n  source := e.source ∩ s\n  target := e.target ∩ t\n  map_source' := h.mapsTo\n  map_target' := h.symm_mapsTo\n  left_inv' := e.leftInvOn.mono inter_subset_left\n  right_inv' := e.rightInvOn.mono inter_subset_left\n\n"}
{"name":"PartialEquiv.IsImage.restr_apply","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\nβ : Type u_2\ne : PartialEquiv α β\ns : Set α\nt : Set β\nh : e.IsImage s t\n⊢ Eq ↑h.restr ↑e","decl":"/-- Restrict a `PartialEquiv` to a pair of corresponding sets. -/\n@[simps (config := .asFn)]\ndef restr (h : e.IsImage s t) : PartialEquiv α β where\n  toFun := e\n  invFun := e.symm\n  source := e.source ∩ s\n  target := e.target ∩ t\n  map_source' := h.mapsTo\n  map_target' := h.symm_mapsTo\n  left_inv' := e.leftInvOn.mono inter_subset_left\n  right_inv' := e.rightInvOn.mono inter_subset_left\n\n"}
{"name":"PartialEquiv.IsImage.restr_source","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\nβ : Type u_2\ne : PartialEquiv α β\ns : Set α\nt : Set β\nh : e.IsImage s t\n⊢ Eq h.restr.source (Inter.inter e.source s)","decl":"/-- Restrict a `PartialEquiv` to a pair of corresponding sets. -/\n@[simps (config := .asFn)]\ndef restr (h : e.IsImage s t) : PartialEquiv α β where\n  toFun := e\n  invFun := e.symm\n  source := e.source ∩ s\n  target := e.target ∩ t\n  map_source' := h.mapsTo\n  map_target' := h.symm_mapsTo\n  left_inv' := e.leftInvOn.mono inter_subset_left\n  right_inv' := e.rightInvOn.mono inter_subset_left\n\n"}
{"name":"PartialEquiv.IsImage.image_eq","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\nβ : Type u_2\ne : PartialEquiv α β\ns : Set α\nt : Set β\nh : e.IsImage s t\n⊢ Eq (Set.image (↑e) (Inter.inter e.source s)) (Inter.inter e.target t)","decl":"theorem image_eq (h : e.IsImage s t) : e '' (e.source ∩ s) = e.target ∩ t :=\n  h.restr.image_source_eq_target\n\n"}
{"name":"PartialEquiv.IsImage.symm_image_eq","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\nβ : Type u_2\ne : PartialEquiv α β\ns : Set α\nt : Set β\nh : e.IsImage s t\n⊢ Eq (Set.image (↑e.symm) (Inter.inter e.target t)) (Inter.inter e.source s)","decl":"theorem symm_image_eq (h : e.IsImage s t) : e.symm '' (e.target ∩ t) = e.source ∩ s :=\n  h.symm.image_eq\n\n"}
{"name":"PartialEquiv.IsImage.iff_preimage_eq","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\nβ : Type u_2\ne : PartialEquiv α β\ns : Set α\nt : Set β\n⊢ Iff (e.IsImage s t) (Eq (Inter.inter e.source (Set.preimage (↑e) t)) (Inter.inter e.source s))","decl":"theorem iff_preimage_eq : e.IsImage s t ↔ e.source ∩ e ⁻¹' t = e.source ∩ s := by\n  simp only [IsImage, Set.ext_iff, mem_inter_iff, mem_preimage, and_congr_right_iff]\n\n"}
{"name":"PartialEquiv.IsImage.preimage_eq","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\nβ : Type u_2\ne : PartialEquiv α β\ns : Set α\nt : Set β\na✝ : e.IsImage s t\n⊢ Eq (Inter.inter e.source (Set.preimage (↑e) t)) (Inter.inter e.source s)","decl":"alias ⟨preimage_eq, of_preimage_eq⟩ := iff_preimage_eq\n\n"}
{"name":"PartialEquiv.IsImage.of_preimage_eq","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\nβ : Type u_2\ne : PartialEquiv α β\ns : Set α\nt : Set β\na✝ : Eq (Inter.inter e.source (Set.preimage (↑e) t)) (Inter.inter e.source s)\n⊢ e.IsImage s t","decl":"alias ⟨preimage_eq, of_preimage_eq⟩ := iff_preimage_eq\n\n"}
{"name":"PartialEquiv.IsImage.iff_symm_preimage_eq","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\nβ : Type u_2\ne : PartialEquiv α β\ns : Set α\nt : Set β\n⊢ Iff (e.IsImage s t) (Eq (Inter.inter e.target (Set.preimage (↑e.symm) s)) (Inter.inter e.target t))","decl":"theorem iff_symm_preimage_eq : e.IsImage s t ↔ e.target ∩ e.symm ⁻¹' s = e.target ∩ t :=\n  symm_iff.symm.trans iff_preimage_eq\n\n"}
{"name":"PartialEquiv.IsImage.of_symm_preimage_eq","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\nβ : Type u_2\ne : PartialEquiv α β\ns : Set α\nt : Set β\na✝ : Eq (Inter.inter e.target (Set.preimage (↑e.symm) s)) (Inter.inter e.target t)\n⊢ e.IsImage s t","decl":"alias ⟨symm_preimage_eq, of_symm_preimage_eq⟩ := iff_symm_preimage_eq\n\n"}
{"name":"PartialEquiv.IsImage.symm_preimage_eq","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\nβ : Type u_2\ne : PartialEquiv α β\ns : Set α\nt : Set β\na✝ : e.IsImage s t\n⊢ Eq (Inter.inter e.target (Set.preimage (↑e.symm) s)) (Inter.inter e.target t)","decl":"alias ⟨symm_preimage_eq, of_symm_preimage_eq⟩ := iff_symm_preimage_eq\n\n"}
{"name":"PartialEquiv.IsImage.of_image_eq","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\nβ : Type u_2\ne : PartialEquiv α β\ns : Set α\nt : Set β\nh : Eq (Set.image (↑e) (Inter.inter e.source s)) (Inter.inter e.target t)\n⊢ e.IsImage s t","decl":"theorem of_image_eq (h : e '' (e.source ∩ s) = e.target ∩ t) : e.IsImage s t :=\n  of_symm_preimage_eq <| Eq.trans (of_symm_preimage_eq rfl).image_eq.symm h\n\n"}
{"name":"PartialEquiv.IsImage.of_symm_image_eq","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\nβ : Type u_2\ne : PartialEquiv α β\ns : Set α\nt : Set β\nh : Eq (Set.image (↑e.symm) (Inter.inter e.target t)) (Inter.inter e.source s)\n⊢ e.IsImage s t","decl":"theorem of_symm_image_eq (h : e.symm '' (e.target ∩ t) = e.source ∩ s) : e.IsImage s t :=\n  of_preimage_eq <| Eq.trans (iff_preimage_eq.2 rfl).symm_image_eq.symm h\n\n"}
{"name":"PartialEquiv.IsImage.compl","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\nβ : Type u_2\ne : PartialEquiv α β\ns : Set α\nt : Set β\nh : e.IsImage s t\n⊢ e.IsImage (HasCompl.compl s) (HasCompl.compl t)","decl":"protected theorem compl (h : e.IsImage s t) : e.IsImage sᶜ tᶜ := fun _ hx => not_congr (h hx)\n\n"}
{"name":"PartialEquiv.IsImage.inter","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\nβ : Type u_2\ne : PartialEquiv α β\ns : Set α\nt : Set β\ns' : Set α\nt' : Set β\nh : e.IsImage s t\nh' : e.IsImage s' t'\n⊢ e.IsImage (Inter.inter s s') (Inter.inter t t')","decl":"protected theorem inter {s' t'} (h : e.IsImage s t) (h' : e.IsImage s' t') :\n    e.IsImage (s ∩ s') (t ∩ t') := fun _ hx => and_congr (h hx) (h' hx)\n\n"}
{"name":"PartialEquiv.IsImage.union","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\nβ : Type u_2\ne : PartialEquiv α β\ns : Set α\nt : Set β\ns' : Set α\nt' : Set β\nh : e.IsImage s t\nh' : e.IsImage s' t'\n⊢ e.IsImage (Union.union s s') (Union.union t t')","decl":"protected theorem union {s' t'} (h : e.IsImage s t) (h' : e.IsImage s' t') :\n    e.IsImage (s ∪ s') (t ∪ t') := fun _ hx => or_congr (h hx) (h' hx)\n\n"}
{"name":"PartialEquiv.IsImage.diff","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\nβ : Type u_2\ne : PartialEquiv α β\ns : Set α\nt : Set β\ns' : Set α\nt' : Set β\nh : e.IsImage s t\nh' : e.IsImage s' t'\n⊢ e.IsImage (SDiff.sdiff s s') (SDiff.sdiff t t')","decl":"protected theorem diff {s' t'} (h : e.IsImage s t) (h' : e.IsImage s' t') :\n    e.IsImage (s \\ s') (t \\ t') :=\n  h.inter h'.compl\n\n"}
{"name":"PartialEquiv.IsImage.leftInvOn_piecewise","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\nβ : Type u_2\ne : PartialEquiv α β\ns : Set α\nt : Set β\ne' : PartialEquiv α β\ninst✝¹ : (i : α) → Decidable (Membership.mem s i)\ninst✝ : (i : β) → Decidable (Membership.mem t i)\nh : e.IsImage s t\nh' : e'.IsImage s t\n⊢ Set.LeftInvOn (t.piecewise ↑e.symm ↑e'.symm) (s.piecewise ↑e ↑e') (s.ite e.source e'.source)","decl":"theorem leftInvOn_piecewise {e' : PartialEquiv α β} [∀ i, Decidable (i ∈ s)]\n    [∀ i, Decidable (i ∈ t)] (h : e.IsImage s t) (h' : e'.IsImage s t) :\n    LeftInvOn (t.piecewise e.symm e'.symm) (s.piecewise e e') (s.ite e.source e'.source) := by\n  rintro x (⟨he, hs⟩ | ⟨he, hs : x ∉ s⟩)\n  · rw [piecewise_eq_of_mem _ _ _ hs, piecewise_eq_of_mem _ _ _ ((h he).2 hs), e.left_inv he]\n  · rw [piecewise_eq_of_not_mem _ _ _ hs, piecewise_eq_of_not_mem _ _ _ ((h'.compl he).2 hs),\n      e'.left_inv he]\n\n"}
{"name":"PartialEquiv.IsImage.inter_eq_of_inter_eq_of_eqOn","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\nβ : Type u_2\ne : PartialEquiv α β\ns : Set α\nt : Set β\ne' : PartialEquiv α β\nh : e.IsImage s t\nh' : e'.IsImage s t\nhs : Eq (Inter.inter e.source s) (Inter.inter e'.source s)\nheq : Set.EqOn (↑e) (↑e') (Inter.inter e.source s)\n⊢ Eq (Inter.inter e.target t) (Inter.inter e'.target t)","decl":"theorem inter_eq_of_inter_eq_of_eqOn {e' : PartialEquiv α β} (h : e.IsImage s t)\n    (h' : e'.IsImage s t) (hs : e.source ∩ s = e'.source ∩ s) (heq : EqOn e e' (e.source ∩ s)) :\n    e.target ∩ t = e'.target ∩ t := by rw [← h.image_eq, ← h'.image_eq, ← hs, heq.image_eq]\n\n"}
{"name":"PartialEquiv.IsImage.symm_eq_on_of_inter_eq_of_eqOn","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\nβ : Type u_2\ne : PartialEquiv α β\ns : Set α\nt : Set β\ne' : PartialEquiv α β\nh : e.IsImage s t\nhs : Eq (Inter.inter e.source s) (Inter.inter e'.source s)\nheq : Set.EqOn (↑e) (↑e') (Inter.inter e.source s)\n⊢ Set.EqOn (↑e.symm) (↑e'.symm) (Inter.inter e.target t)","decl":"theorem symm_eq_on_of_inter_eq_of_eqOn {e' : PartialEquiv α β} (h : e.IsImage s t)\n    (hs : e.source ∩ s = e'.source ∩ s) (heq : EqOn e e' (e.source ∩ s)) :\n    EqOn e.symm e'.symm (e.target ∩ t) := by\n  rw [← h.image_eq]\n  rintro y ⟨x, hx, rfl⟩\n  have hx' := hx; rw [hs] at hx'\n  rw [e.left_inv hx.1, heq hx, e'.left_inv hx'.1]\n\n"}
{"name":"PartialEquiv.isImage_source_target","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\nβ : Type u_2\ne : PartialEquiv α β\n⊢ e.IsImage e.source e.target","decl":"theorem isImage_source_target : e.IsImage e.source e.target := fun x hx => by simp [hx]\n\n"}
{"name":"PartialEquiv.isImage_source_target_of_disjoint","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\nβ : Type u_2\ne e' : PartialEquiv α β\nhs : Disjoint e.source e'.source\nht : Disjoint e.target e'.target\n⊢ e.IsImage e'.source e'.target","decl":"theorem isImage_source_target_of_disjoint (e' : PartialEquiv α β) (hs : Disjoint e.source e'.source)\n    (ht : Disjoint e.target e'.target) : e.IsImage e'.source e'.target :=\n  IsImage.of_image_eq <| by rw [hs.inter_eq, ht.inter_eq, image_empty]\n\n"}
{"name":"PartialEquiv.image_source_inter_eq'","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\nβ : Type u_2\ne : PartialEquiv α β\ns : Set α\n⊢ Eq (Set.image (↑e) (Inter.inter e.source s)) (Inter.inter e.target (Set.preimage (↑e.symm) s))","decl":"theorem image_source_inter_eq' (s : Set α) : e '' (e.source ∩ s) = e.target ∩ e.symm ⁻¹' s := by\n  rw [inter_comm, e.leftInvOn.image_inter', image_source_eq_target, inter_comm]\n\n"}
{"name":"PartialEquiv.image_source_inter_eq","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\nβ : Type u_2\ne : PartialEquiv α β\ns : Set α\n⊢ Eq (Set.image (↑e) (Inter.inter e.source s)) (Inter.inter e.target (Set.preimage (↑e.symm) (Inter.inter e.source s)))","decl":"theorem image_source_inter_eq (s : Set α) :\n    e '' (e.source ∩ s) = e.target ∩ e.symm ⁻¹' (e.source ∩ s) := by\n  rw [inter_comm, e.leftInvOn.image_inter, image_source_eq_target, inter_comm]\n\n"}
{"name":"PartialEquiv.image_eq_target_inter_inv_preimage","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\nβ : Type u_2\ne : PartialEquiv α β\ns : Set α\nh : HasSubset.Subset s e.source\n⊢ Eq (Set.image (↑e) s) (Inter.inter e.target (Set.preimage (↑e.symm) s))","decl":"theorem image_eq_target_inter_inv_preimage {s : Set α} (h : s ⊆ e.source) :\n    e '' s = e.target ∩ e.symm ⁻¹' s := by\n  rw [← e.image_source_inter_eq', inter_eq_self_of_subset_right h]\n\n"}
{"name":"PartialEquiv.symm_image_eq_source_inter_preimage","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\nβ : Type u_2\ne : PartialEquiv α β\ns : Set β\nh : HasSubset.Subset s e.target\n⊢ Eq (Set.image (↑e.symm) s) (Inter.inter e.source (Set.preimage (↑e) s))","decl":"theorem symm_image_eq_source_inter_preimage {s : Set β} (h : s ⊆ e.target) :\n    e.symm '' s = e.source ∩ e ⁻¹' s :=\n  e.symm.image_eq_target_inter_inv_preimage h\n\n"}
{"name":"PartialEquiv.symm_image_target_inter_eq","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\nβ : Type u_2\ne : PartialEquiv α β\ns : Set β\n⊢ Eq (Set.image (↑e.symm) (Inter.inter e.target s)) (Inter.inter e.source (Set.preimage (↑e) (Inter.inter e.target s)))","decl":"theorem symm_image_target_inter_eq (s : Set β) :\n    e.symm '' (e.target ∩ s) = e.source ∩ e ⁻¹' (e.target ∩ s) :=\n  e.symm.image_source_inter_eq _\n\n"}
{"name":"PartialEquiv.symm_image_target_inter_eq'","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\nβ : Type u_2\ne : PartialEquiv α β\ns : Set β\n⊢ Eq (Set.image (↑e.symm) (Inter.inter e.target s)) (Inter.inter e.source (Set.preimage (↑e) s))","decl":"theorem symm_image_target_inter_eq' (s : Set β) : e.symm '' (e.target ∩ s) = e.source ∩ e ⁻¹' s :=\n  e.symm.image_source_inter_eq' _\n\n"}
{"name":"PartialEquiv.source_inter_preimage_inv_preimage","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\nβ : Type u_2\ne : PartialEquiv α β\ns : Set α\n⊢ Eq (Inter.inter e.source (Set.preimage (↑e) (Set.preimage (↑e.symm) s))) (Inter.inter e.source s)","decl":"theorem source_inter_preimage_inv_preimage (s : Set α) :\n    e.source ∩ e ⁻¹' (e.symm ⁻¹' s) = e.source ∩ s :=\n  Set.ext fun x => and_congr_right_iff.2 fun hx =>\n    by simp only [mem_preimage, e.left_inv hx]\n\n"}
{"name":"PartialEquiv.source_inter_preimage_target_inter","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\nβ : Type u_2\ne : PartialEquiv α β\ns : Set β\n⊢ Eq (Inter.inter e.source (Set.preimage (↑e) (Inter.inter e.target s))) (Inter.inter e.source (Set.preimage (↑e) s))","decl":"theorem source_inter_preimage_target_inter (s : Set β) :\n    e.source ∩ e ⁻¹' (e.target ∩ s) = e.source ∩ e ⁻¹' s :=\n  ext fun _ => ⟨fun hx => ⟨hx.1, hx.2.2⟩, fun hx => ⟨hx.1, e.map_source hx.1, hx.2⟩⟩\n\n"}
{"name":"PartialEquiv.target_inter_inv_preimage_preimage","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\nβ : Type u_2\ne : PartialEquiv α β\ns : Set β\n⊢ Eq (Inter.inter e.target (Set.preimage (↑e.symm) (Set.preimage (↑e) s))) (Inter.inter e.target s)","decl":"theorem target_inter_inv_preimage_preimage (s : Set β) :\n    e.target ∩ e.symm ⁻¹' (e ⁻¹' s) = e.target ∩ s :=\n  e.symm.source_inter_preimage_inv_preimage _\n\n"}
{"name":"PartialEquiv.symm_image_image_of_subset_source","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\nβ : Type u_2\ne : PartialEquiv α β\ns : Set α\nh : HasSubset.Subset s e.source\n⊢ Eq (Set.image (↑e.symm) (Set.image (↑e) s)) s","decl":"theorem symm_image_image_of_subset_source {s : Set α} (h : s ⊆ e.source) : e.symm '' (e '' s) = s :=\n  (e.leftInvOn.mono h).image_image\n\n"}
{"name":"PartialEquiv.image_symm_image_of_subset_target","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\nβ : Type u_2\ne : PartialEquiv α β\ns : Set β\nh : HasSubset.Subset s e.target\n⊢ Eq (Set.image (↑e) (Set.image (↑e.symm) s)) s","decl":"theorem image_symm_image_of_subset_target {s : Set β} (h : s ⊆ e.target) : e '' (e.symm '' s) = s :=\n  e.symm.symm_image_image_of_subset_source h\n\n"}
{"name":"PartialEquiv.source_subset_preimage_target","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\nβ : Type u_2\ne : PartialEquiv α β\n⊢ HasSubset.Subset e.source (Set.preimage (↑e) e.target)","decl":"theorem source_subset_preimage_target : e.source ⊆ e ⁻¹' e.target :=\n  e.mapsTo\n\n"}
{"name":"PartialEquiv.symm_image_target_eq_source","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\nβ : Type u_2\ne : PartialEquiv α β\n⊢ Eq (Set.image (↑e.symm) e.target) e.source","decl":"theorem symm_image_target_eq_source : e.symm '' e.target = e.source :=\n  e.symm.image_source_eq_target\n\n"}
{"name":"PartialEquiv.target_subset_preimage_source","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\nβ : Type u_2\ne : PartialEquiv α β\n⊢ HasSubset.Subset e.target (Set.preimage (↑e.symm) e.source)","decl":"theorem target_subset_preimage_source : e.target ⊆ e.symm ⁻¹' e.source :=\n  e.symm_mapsTo\n\n"}
{"name":"PartialEquiv.ext","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\nβ : Type u_2\ne e' : PartialEquiv α β\nh : ∀ (x : α), Eq (↑e x) (↑e' x)\nhsymm : ∀ (x : β), Eq (↑e.symm x) (↑e'.symm x)\nhs : Eq e.source e'.source\n⊢ Eq e e'","decl":"/-- Two partial equivs that have the same `source`, same `toFun` and same `invFun`, coincide. -/\n@[ext]\nprotected theorem ext {e e' : PartialEquiv α β} (h : ∀ x, e x = e' x)\n    (hsymm : ∀ x, e.symm x = e'.symm x) (hs : e.source = e'.source) : e = e' := by\n  have A : (e : α → β) = e' := by\n    ext x\n    exact h x\n  have B : (e.symm : β → α) = e'.symm := by\n    ext x\n    exact hsymm x\n  have I : e '' e.source = e.target := e.image_source_eq_target\n  have I' : e' '' e'.source = e'.target := e'.image_source_eq_target\n  rw [A, hs, I'] at I\n  cases e; cases e'\n  simp_all\n\n"}
{"name":"PartialEquiv.ext_iff","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\nβ : Type u_2\ne e' : PartialEquiv α β\n⊢ Iff (Eq e e') (And (∀ (x : α), Eq (↑e x) (↑e' x)) (And (∀ (x : β), Eq (↑e.symm x) (↑e'.symm x)) (Eq e.source e'.source)))","decl":"/-- Two partial equivs that have the same `source`, same `toFun` and same `invFun`, coincide. -/\n@[ext]\nprotected theorem ext {e e' : PartialEquiv α β} (h : ∀ x, e x = e' x)\n    (hsymm : ∀ x, e.symm x = e'.symm x) (hs : e.source = e'.source) : e = e' := by\n  have A : (e : α → β) = e' := by\n    ext x\n    exact h x\n  have B : (e.symm : β → α) = e'.symm := by\n    ext x\n    exact hsymm x\n  have I : e '' e.source = e.target := e.image_source_eq_target\n  have I' : e' '' e'.source = e'.target := e'.image_source_eq_target\n  rw [A, hs, I'] at I\n  cases e; cases e'\n  simp_all\n\n"}
{"name":"PartialEquiv.restr_coe","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\nβ : Type u_2\ne : PartialEquiv α β\ns : Set α\n⊢ Eq ↑(e.restr s) ↑e","decl":"@[simp, mfld_simps]\ntheorem restr_coe (s : Set α) : (e.restr s : α → β) = e :=\n  rfl\n\n"}
{"name":"PartialEquiv.restr_coe_symm","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\nβ : Type u_2\ne : PartialEquiv α β\ns : Set α\n⊢ Eq ↑(e.restr s).symm ↑e.symm","decl":"@[simp, mfld_simps]\ntheorem restr_coe_symm (s : Set α) : ((e.restr s).symm : β → α) = e.symm :=\n  rfl\n\n"}
{"name":"PartialEquiv.restr_source","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\nβ : Type u_2\ne : PartialEquiv α β\ns : Set α\n⊢ Eq (e.restr s).source (Inter.inter e.source s)","decl":"@[simp, mfld_simps]\ntheorem restr_source (s : Set α) : (e.restr s).source = e.source ∩ s :=\n  rfl\n\n"}
{"name":"PartialEquiv.source_restr_subset_source","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\nβ : Type u_2\ne : PartialEquiv α β\ns : Set α\n⊢ HasSubset.Subset (e.restr s).source e.source","decl":"theorem source_restr_subset_source (s : Set α) : (e.restr s).source ⊆ e.source := inter_subset_left\n\n"}
{"name":"PartialEquiv.restr_target","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\nβ : Type u_2\ne : PartialEquiv α β\ns : Set α\n⊢ Eq (e.restr s).target (Inter.inter e.target (Set.preimage (↑e.symm) s))","decl":"@[simp, mfld_simps]\ntheorem restr_target (s : Set α) : (e.restr s).target = e.target ∩ e.symm ⁻¹' s :=\n  rfl\n\n"}
{"name":"PartialEquiv.restr_eq_of_source_subset","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\nβ : Type u_2\ne : PartialEquiv α β\ns : Set α\nh : HasSubset.Subset e.source s\n⊢ Eq (e.restr s) e","decl":"theorem restr_eq_of_source_subset {e : PartialEquiv α β} {s : Set α} (h : e.source ⊆ s) :\n    e.restr s = e :=\n  PartialEquiv.ext (fun _ => rfl) (fun _ => rfl) (by simp [inter_eq_self_of_subset_left h])\n\n"}
{"name":"PartialEquiv.restr_univ","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\nβ : Type u_2\ne : PartialEquiv α β\n⊢ Eq (e.restr Set.univ) e","decl":"@[simp, mfld_simps]\ntheorem restr_univ {e : PartialEquiv α β} : e.restr univ = e :=\n  restr_eq_of_source_subset (subset_univ _)\n\n"}
{"name":"PartialEquiv.refl_source","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\n⊢ Eq (PartialEquiv.refl α).source Set.univ","decl":"@[simp, mfld_simps]\ntheorem refl_source : (PartialEquiv.refl α).source = univ :=\n  rfl\n\n"}
{"name":"PartialEquiv.refl_target","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\n⊢ Eq (PartialEquiv.refl α).target Set.univ","decl":"@[simp, mfld_simps]\ntheorem refl_target : (PartialEquiv.refl α).target = univ :=\n  rfl\n\n"}
{"name":"PartialEquiv.refl_coe","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\n⊢ Eq (↑(PartialEquiv.refl α)) id","decl":"@[simp, mfld_simps]\ntheorem refl_coe : (PartialEquiv.refl α : α → α) = id :=\n  rfl\n\n"}
{"name":"PartialEquiv.refl_symm","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\n⊢ Eq (PartialEquiv.refl α).symm (PartialEquiv.refl α)","decl":"@[simp, mfld_simps]\ntheorem refl_symm : (PartialEquiv.refl α).symm = PartialEquiv.refl α :=\n  rfl\n\n"}
{"name":"PartialEquiv.refl_restr_source","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\ns : Set α\n⊢ Eq ((PartialEquiv.refl α).restr s).source s","decl":"@[mfld_simps]\ntheorem refl_restr_source (s : Set α) : ((PartialEquiv.refl α).restr s).source = s := by simp\n\n"}
{"name":"PartialEquiv.refl_restr_target","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\ns : Set α\n⊢ Eq ((PartialEquiv.refl α).restr s).target s","decl":"@[mfld_simps]\ntheorem refl_restr_target (s : Set α) : ((PartialEquiv.refl α).restr s).target = s := by\n  change univ ∩ id ⁻¹' s = s\n  simp\n\n"}
{"name":"PartialEquiv.ofSet_source","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\ns : Set α\n⊢ Eq (PartialEquiv.ofSet s).source s","decl":"@[simp, mfld_simps]\ntheorem ofSet_source (s : Set α) : (PartialEquiv.ofSet s).source = s :=\n  rfl\n\n"}
{"name":"PartialEquiv.ofSet_target","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\ns : Set α\n⊢ Eq (PartialEquiv.ofSet s).target s","decl":"@[simp, mfld_simps]\ntheorem ofSet_target (s : Set α) : (PartialEquiv.ofSet s).target = s :=\n  rfl\n\n"}
{"name":"PartialEquiv.ofSet_coe","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\ns : Set α\n⊢ Eq (↑(PartialEquiv.ofSet s)) id","decl":"@[simp, mfld_simps]\ntheorem ofSet_coe (s : Set α) : (PartialEquiv.ofSet s : α → α) = id :=\n  rfl\n\n"}
{"name":"PartialEquiv.ofSet_symm","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\ns : Set α\n⊢ Eq (PartialEquiv.ofSet s).symm (PartialEquiv.ofSet s)","decl":"@[simp, mfld_simps]\ntheorem ofSet_symm (s : Set α) : (PartialEquiv.ofSet s).symm = PartialEquiv.ofSet s :=\n  rfl\n\n"}
{"name":"PartialEquiv.single_symm_apply","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\nβ : Type u_2\na : α\nb a✝ : β\n⊢ Eq (↑(PartialEquiv.single a b).symm a✝) (Function.const β a a✝)","decl":"/-- `Function.const` as a `PartialEquiv`.\nIt consists of two constant maps in opposite directions. -/\n@[simps]\ndef single (a : α) (b : β) : PartialEquiv α β where\n  toFun := Function.const α b\n  invFun := Function.const β a\n  source := {a}\n  target := {b}\n  map_source' _ _ := rfl\n  map_target' _ _ := rfl\n  left_inv' a' ha' := by rw [eq_of_mem_singleton ha', const_apply]\n  right_inv' b' hb' := by rw [eq_of_mem_singleton hb', const_apply]\n\n"}
{"name":"PartialEquiv.single_source","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\nβ : Type u_2\na : α\nb : β\n⊢ Eq (PartialEquiv.single a b).source (Singleton.singleton a)","decl":"/-- `Function.const` as a `PartialEquiv`.\nIt consists of two constant maps in opposite directions. -/\n@[simps]\ndef single (a : α) (b : β) : PartialEquiv α β where\n  toFun := Function.const α b\n  invFun := Function.const β a\n  source := {a}\n  target := {b}\n  map_source' _ _ := rfl\n  map_target' _ _ := rfl\n  left_inv' a' ha' := by rw [eq_of_mem_singleton ha', const_apply]\n  right_inv' b' hb' := by rw [eq_of_mem_singleton hb', const_apply]\n\n"}
{"name":"PartialEquiv.single_target","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\nβ : Type u_2\na : α\nb : β\n⊢ Eq (PartialEquiv.single a b).target (Singleton.singleton b)","decl":"/-- `Function.const` as a `PartialEquiv`.\nIt consists of two constant maps in opposite directions. -/\n@[simps]\ndef single (a : α) (b : β) : PartialEquiv α β where\n  toFun := Function.const α b\n  invFun := Function.const β a\n  source := {a}\n  target := {b}\n  map_source' _ _ := rfl\n  map_target' _ _ := rfl\n  left_inv' a' ha' := by rw [eq_of_mem_singleton ha', const_apply]\n  right_inv' b' hb' := by rw [eq_of_mem_singleton hb', const_apply]\n\n"}
{"name":"PartialEquiv.single_apply","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\nβ : Type u_2\na : α\nb : β\na✝ : α\n⊢ Eq (↑(PartialEquiv.single a b) a✝) (Function.const α b a✝)","decl":"/-- `Function.const` as a `PartialEquiv`.\nIt consists of two constant maps in opposite directions. -/\n@[simps]\ndef single (a : α) (b : β) : PartialEquiv α β where\n  toFun := Function.const α b\n  invFun := Function.const β a\n  source := {a}\n  target := {b}\n  map_source' _ _ := rfl\n  map_target' _ _ := rfl\n  left_inv' a' ha' := by rw [eq_of_mem_singleton ha', const_apply]\n  right_inv' b' hb' := by rw [eq_of_mem_singleton hb', const_apply]\n\n"}
{"name":"PartialEquiv.trans'_apply","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ne : PartialEquiv α β\ne' : PartialEquiv β γ\nh : Eq e.target e'.source\na✝ : α\n⊢ Eq (↑(e.trans' e' h) a✝) (Function.comp (↑e') (↑e) a✝)","decl":"/-- Composing two partial equivs if the target of the first coincides with the source of the\nsecond. -/\n@[simps]\nprotected def trans' (e' : PartialEquiv β γ) (h : e.target = e'.source) : PartialEquiv α γ where\n  toFun := e' ∘ e\n  invFun := e.symm ∘ e'.symm\n  source := e.source\n  target := e'.target\n  map_source' x hx := by simp [← h, hx]\n  map_target' y hy := by simp [h, hy]\n  left_inv' x hx := by simp [hx, ← h]\n  right_inv' y hy := by simp [hy, h]\n\n"}
{"name":"PartialEquiv.trans'_target","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ne : PartialEquiv α β\ne' : PartialEquiv β γ\nh : Eq e.target e'.source\n⊢ Eq (e.trans' e' h).target e'.target","decl":"/-- Composing two partial equivs if the target of the first coincides with the source of the\nsecond. -/\n@[simps]\nprotected def trans' (e' : PartialEquiv β γ) (h : e.target = e'.source) : PartialEquiv α γ where\n  toFun := e' ∘ e\n  invFun := e.symm ∘ e'.symm\n  source := e.source\n  target := e'.target\n  map_source' x hx := by simp [← h, hx]\n  map_target' y hy := by simp [h, hy]\n  left_inv' x hx := by simp [hx, ← h]\n  right_inv' y hy := by simp [hy, h]\n\n"}
{"name":"PartialEquiv.trans'_symm_apply","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ne : PartialEquiv α β\ne' : PartialEquiv β γ\nh : Eq e.target e'.source\na✝ : γ\n⊢ Eq (↑(e.trans' e' h).symm a✝) (Function.comp (↑e.symm) (↑e'.symm) a✝)","decl":"/-- Composing two partial equivs if the target of the first coincides with the source of the\nsecond. -/\n@[simps]\nprotected def trans' (e' : PartialEquiv β γ) (h : e.target = e'.source) : PartialEquiv α γ where\n  toFun := e' ∘ e\n  invFun := e.symm ∘ e'.symm\n  source := e.source\n  target := e'.target\n  map_source' x hx := by simp [← h, hx]\n  map_target' y hy := by simp [h, hy]\n  left_inv' x hx := by simp [hx, ← h]\n  right_inv' y hy := by simp [hy, h]\n\n"}
{"name":"PartialEquiv.trans'_source","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ne : PartialEquiv α β\ne' : PartialEquiv β γ\nh : Eq e.target e'.source\n⊢ Eq (e.trans' e' h).source e.source","decl":"/-- Composing two partial equivs if the target of the first coincides with the source of the\nsecond. -/\n@[simps]\nprotected def trans' (e' : PartialEquiv β γ) (h : e.target = e'.source) : PartialEquiv α γ where\n  toFun := e' ∘ e\n  invFun := e.symm ∘ e'.symm\n  source := e.source\n  target := e'.target\n  map_source' x hx := by simp [← h, hx]\n  map_target' y hy := by simp [h, hy]\n  left_inv' x hx := by simp [hx, ← h]\n  right_inv' y hy := by simp [hy, h]\n\n"}
{"name":"PartialEquiv.coe_trans","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ne : PartialEquiv α β\ne' : PartialEquiv β γ\n⊢ Eq (↑(e.trans e')) (Function.comp ↑e' ↑e)","decl":"@[simp, mfld_simps]\ntheorem coe_trans : (e.trans e' : α → γ) = e' ∘ e :=\n  rfl\n\n"}
{"name":"PartialEquiv.coe_trans_symm","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ne : PartialEquiv α β\ne' : PartialEquiv β γ\n⊢ Eq (↑(e.trans e').symm) (Function.comp ↑e.symm ↑e'.symm)","decl":"@[simp, mfld_simps]\ntheorem coe_trans_symm : ((e.trans e').symm : γ → α) = e.symm ∘ e'.symm :=\n  rfl\n\n"}
{"name":"PartialEquiv.trans_apply","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ne : PartialEquiv α β\ne' : PartialEquiv β γ\nx : α\n⊢ Eq (↑(e.trans e') x) (↑e' (↑e x))","decl":"theorem trans_apply {x : α} : (e.trans e') x = e' (e x) :=\n  rfl\n\n"}
{"name":"PartialEquiv.trans_symm_eq_symm_trans_symm","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ne : PartialEquiv α β\ne' : PartialEquiv β γ\n⊢ Eq (e.trans e').symm (e'.symm.trans e.symm)","decl":"theorem trans_symm_eq_symm_trans_symm : (e.trans e').symm = e'.symm.trans e.symm := by\n  cases e; cases e'; rfl\n\n"}
{"name":"PartialEquiv.trans_source","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ne : PartialEquiv α β\ne' : PartialEquiv β γ\n⊢ Eq (e.trans e').source (Inter.inter e.source (Set.preimage (↑e) e'.source))","decl":"@[simp, mfld_simps]\ntheorem trans_source : (e.trans e').source = e.source ∩ e ⁻¹' e'.source :=\n  rfl\n\n"}
{"name":"PartialEquiv.trans_source'","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ne : PartialEquiv α β\ne' : PartialEquiv β γ\n⊢ Eq (e.trans e').source (Inter.inter e.source (Set.preimage (↑e) (Inter.inter e.target e'.source)))","decl":"theorem trans_source' : (e.trans e').source = e.source ∩ e ⁻¹' (e.target ∩ e'.source) := by\n  mfld_set_tac\n\n"}
{"name":"PartialEquiv.trans_source''","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ne : PartialEquiv α β\ne' : PartialEquiv β γ\n⊢ Eq (e.trans e').source (Set.image (↑e.symm) (Inter.inter e.target e'.source))","decl":"theorem trans_source'' : (e.trans e').source = e.symm '' (e.target ∩ e'.source) := by\n  rw [e.trans_source', e.symm_image_target_inter_eq]\n\n"}
{"name":"PartialEquiv.image_trans_source","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ne : PartialEquiv α β\ne' : PartialEquiv β γ\n⊢ Eq (Set.image (↑e) (e.trans e').source) (Inter.inter e.target e'.source)","decl":"theorem image_trans_source : e '' (e.trans e').source = e.target ∩ e'.source :=\n  (e.symm.restr e'.source).symm.image_source_eq_target\n\n"}
{"name":"PartialEquiv.trans_target","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ne : PartialEquiv α β\ne' : PartialEquiv β γ\n⊢ Eq (e.trans e').target (Inter.inter e'.target (Set.preimage (↑e'.symm) e.target))","decl":"@[simp, mfld_simps]\ntheorem trans_target : (e.trans e').target = e'.target ∩ e'.symm ⁻¹' e.target :=\n  rfl\n\n"}
{"name":"PartialEquiv.trans_target'","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ne : PartialEquiv α β\ne' : PartialEquiv β γ\n⊢ Eq (e.trans e').target (Inter.inter e'.target (Set.preimage (↑e'.symm) (Inter.inter e'.source e.target)))","decl":"theorem trans_target' : (e.trans e').target = e'.target ∩ e'.symm ⁻¹' (e'.source ∩ e.target) :=\n  trans_source' e'.symm e.symm\n\n"}
{"name":"PartialEquiv.trans_target''","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ne : PartialEquiv α β\ne' : PartialEquiv β γ\n⊢ Eq (e.trans e').target (Set.image (↑e') (Inter.inter e'.source e.target))","decl":"theorem trans_target'' : (e.trans e').target = e' '' (e'.source ∩ e.target) :=\n  trans_source'' e'.symm e.symm\n\n"}
{"name":"PartialEquiv.inv_image_trans_target","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ne : PartialEquiv α β\ne' : PartialEquiv β γ\n⊢ Eq (Set.image (↑e'.symm) (e.trans e').target) (Inter.inter e'.source e.target)","decl":"theorem inv_image_trans_target : e'.symm '' (e.trans e').target = e'.source ∩ e.target :=\n  image_trans_source e'.symm e.symm\n\n"}
{"name":"PartialEquiv.trans_assoc","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nδ : Type u_4\ne : PartialEquiv α β\ne' : PartialEquiv β γ\ne'' : PartialEquiv γ δ\n⊢ Eq ((e.trans e').trans e'') (e.trans (e'.trans e''))","decl":"theorem trans_assoc (e'' : PartialEquiv γ δ) : (e.trans e').trans e'' = e.trans (e'.trans e'') :=\n  PartialEquiv.ext (fun _ => rfl) (fun _ => rfl)\n    (by simp [trans_source, @preimage_comp α β γ, inter_assoc])\n\n"}
{"name":"PartialEquiv.trans_refl","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\nβ : Type u_2\ne : PartialEquiv α β\n⊢ Eq (e.trans (PartialEquiv.refl β)) e","decl":"@[simp, mfld_simps]\ntheorem trans_refl : e.trans (PartialEquiv.refl β) = e :=\n  PartialEquiv.ext (fun _ => rfl) (fun _ => rfl) (by simp [trans_source])\n\n"}
{"name":"PartialEquiv.refl_trans","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\nβ : Type u_2\ne : PartialEquiv α β\n⊢ Eq ((PartialEquiv.refl α).trans e) e","decl":"@[simp, mfld_simps]\ntheorem refl_trans : (PartialEquiv.refl α).trans e = e :=\n  PartialEquiv.ext (fun _ => rfl) (fun _ => rfl) (by simp [trans_source, preimage_id])\n\n"}
{"name":"PartialEquiv.trans_ofSet","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\nβ : Type u_2\ne : PartialEquiv α β\ns : Set β\n⊢ Eq (e.trans (PartialEquiv.ofSet s)) (e.restr (Set.preimage (↑e) s))","decl":"theorem trans_ofSet (s : Set β) : e.trans (ofSet s) = e.restr (e ⁻¹' s) :=\n  PartialEquiv.ext (fun _ => rfl) (fun _ => rfl) rfl\n\n"}
{"name":"PartialEquiv.trans_refl_restr","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\nβ : Type u_2\ne : PartialEquiv α β\ns : Set β\n⊢ Eq (e.trans ((PartialEquiv.refl β).restr s)) (e.restr (Set.preimage (↑e) s))","decl":"theorem trans_refl_restr (s : Set β) :\n    e.trans ((PartialEquiv.refl β).restr s) = e.restr (e ⁻¹' s) :=\n  PartialEquiv.ext (fun _ => rfl) (fun _ => rfl) (by simp [trans_source])\n\n"}
{"name":"PartialEquiv.trans_refl_restr'","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\nβ : Type u_2\ne : PartialEquiv α β\ns : Set β\n⊢ Eq (e.trans ((PartialEquiv.refl β).restr s)) (e.restr (Inter.inter e.source (Set.preimage (↑e) s)))","decl":"theorem trans_refl_restr' (s : Set β) :\n    e.trans ((PartialEquiv.refl β).restr s) = e.restr (e.source ∩ e ⁻¹' s) :=\n  PartialEquiv.ext (fun _ => rfl) (fun _ => rfl) <| by\n    simp only [trans_source, restr_source, refl_source, univ_inter]\n    rw [← inter_assoc, inter_self]\n\n"}
{"name":"PartialEquiv.restr_trans","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ne : PartialEquiv α β\ne' : PartialEquiv β γ\ns : Set α\n⊢ Eq ((e.restr s).trans e') ((e.trans e').restr s)","decl":"theorem restr_trans (s : Set α) : (e.restr s).trans e' = (e.trans e').restr s :=\n  PartialEquiv.ext (fun _ => rfl) (fun _ => rfl) <| by\n    simp [trans_source, inter_comm, inter_assoc]\n\n"}
{"name":"PartialEquiv.mem_symm_trans_source","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ne : PartialEquiv α β\ne' : PartialEquiv α γ\nx : α\nhe : Membership.mem e.source x\nhe' : Membership.mem e'.source x\n⊢ Membership.mem (e.symm.trans e').source (↑e x)","decl":"/-- A lemma commonly useful when `e` and `e'` are charts of a manifold. -/\ntheorem mem_symm_trans_source {e' : PartialEquiv α γ} {x : α} (he : x ∈ e.source)\n    (he' : x ∈ e'.source) : e x ∈ (e.symm.trans e').source :=\n  ⟨e.mapsTo he, by rwa [mem_preimage, PartialEquiv.symm_symm, e.left_inv he]⟩\n\n"}
{"name":"PartialEquiv.eqOnSource_refl","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\nβ : Type u_2\ne : PartialEquiv α β\n⊢ HasEquiv.Equiv e e","decl":"theorem eqOnSource_refl : e ≈ e :=\n  Setoid.refl _\n\n"}
{"name":"PartialEquiv.EqOnSource.source_eq","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\nβ : Type u_2\ne e' : PartialEquiv α β\nh : HasEquiv.Equiv e e'\n⊢ Eq e.source e'.source","decl":"/-- Two equivalent partial equivs have the same source. -/\ntheorem EqOnSource.source_eq {e e' : PartialEquiv α β} (h : e ≈ e') : e.source = e'.source :=\n  h.1\n\n"}
{"name":"PartialEquiv.EqOnSource.eqOn","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\nβ : Type u_2\ne e' : PartialEquiv α β\nh : HasEquiv.Equiv e e'\n⊢ Set.EqOn (↑e) (↑e') e.source","decl":"/-- Two equivalent partial equivs coincide on the source. -/\ntheorem EqOnSource.eqOn {e e' : PartialEquiv α β} (h : e ≈ e') : e.source.EqOn e e' :=\n  h.2\n\n-- Porting note: A lot of dot notation failures here. Maybe we should not use `≈`\n\n"}
{"name":"PartialEquiv.EqOnSource.target_eq","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\nβ : Type u_2\ne e' : PartialEquiv α β\nh : HasEquiv.Equiv e e'\n⊢ Eq e.target e'.target","decl":"/-- Two equivalent partial equivs have the same target. -/\ntheorem EqOnSource.target_eq {e e' : PartialEquiv α β} (h : e ≈ e') : e.target = e'.target := by\n  simp only [← image_source_eq_target, ← source_eq h, h.2.image_eq]\n\n"}
{"name":"PartialEquiv.EqOnSource.symm'","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\nβ : Type u_2\ne e' : PartialEquiv α β\nh : HasEquiv.Equiv e e'\n⊢ HasEquiv.Equiv e.symm e'.symm","decl":"/-- If two partial equivs are equivalent, so are their inverses. -/\ntheorem EqOnSource.symm' {e e' : PartialEquiv α β} (h : e ≈ e') : e.symm ≈ e'.symm := by\n  refine ⟨target_eq h, eqOn_of_leftInvOn_of_rightInvOn e.leftInvOn ?_ ?_⟩ <;>\n    simp only [symm_source, target_eq h, source_eq h, e'.symm_mapsTo]\n  exact e'.rightInvOn.congr_right e'.symm_mapsTo (source_eq h ▸ h.eqOn.symm)\n\n"}
{"name":"PartialEquiv.EqOnSource.symm_eqOn","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\nβ : Type u_2\ne e' : PartialEquiv α β\nh : HasEquiv.Equiv e e'\n⊢ Set.EqOn (↑e.symm) (↑e'.symm) e.target","decl":"/-- Two equivalent partial equivs have coinciding inverses on the target. -/\ntheorem EqOnSource.symm_eqOn {e e' : PartialEquiv α β} (h : e ≈ e') :\n    EqOn e.symm e'.symm e.target :=\n  -- Porting note: `h.symm'` dot notation doesn't work anymore because `h` is not recognised as\n  -- `PartialEquiv.EqOnSource` for some reason.\n  eqOn (symm' h)\n\n"}
{"name":"PartialEquiv.EqOnSource.trans'","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ne e' : PartialEquiv α β\nf f' : PartialEquiv β γ\nhe : HasEquiv.Equiv e e'\nhf : HasEquiv.Equiv f f'\n⊢ HasEquiv.Equiv (e.trans f) (e'.trans f')","decl":"/-- Composition of partial equivs respects equivalence. -/\ntheorem EqOnSource.trans' {e e' : PartialEquiv α β} {f f' : PartialEquiv β γ} (he : e ≈ e')\n    (hf : f ≈ f') : e.trans f ≈ e'.trans f' := by\n  constructor\n  · rw [trans_source'', trans_source'', ← target_eq he, ← hf.1]\n    exact (he.symm'.eqOn.mono inter_subset_left).image_eq\n  · intro x hx\n    rw [trans_source] at hx\n    simp [Function.comp_apply, PartialEquiv.coe_trans, (he.2 hx.1).symm, hf.2 hx.2]\n\n"}
{"name":"PartialEquiv.EqOnSource.restr","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\nβ : Type u_2\ne e' : PartialEquiv α β\nhe : HasEquiv.Equiv e e'\ns : Set α\n⊢ HasEquiv.Equiv (e.restr s) (e'.restr s)","decl":"/-- Restriction of partial equivs respects equivalence. -/\ntheorem EqOnSource.restr {e e' : PartialEquiv α β} (he : e ≈ e') (s : Set α) :\n    e.restr s ≈ e'.restr s := by\n  constructor\n  · simp [he.1]\n  · intro x hx\n    simp only [mem_inter_iff, restr_source] at hx\n    exact he.2 hx.1\n\n"}
{"name":"PartialEquiv.EqOnSource.source_inter_preimage_eq","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\nβ : Type u_2\ne e' : PartialEquiv α β\nhe : HasEquiv.Equiv e e'\ns : Set β\n⊢ Eq (Inter.inter e.source (Set.preimage (↑e) s)) (Inter.inter e'.source (Set.preimage (↑e') s))","decl":"/-- Preimages are respected by equivalence. -/\ntheorem EqOnSource.source_inter_preimage_eq {e e' : PartialEquiv α β} (he : e ≈ e') (s : Set β) :\n    e.source ∩ e ⁻¹' s = e'.source ∩ e' ⁻¹' s := by rw [he.eqOn.inter_preimage_eq, source_eq he]\n\n"}
{"name":"PartialEquiv.self_trans_symm","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\nβ : Type u_2\ne : PartialEquiv α β\n⊢ HasEquiv.Equiv (e.trans e.symm) (PartialEquiv.ofSet e.source)","decl":"/-- Composition of a partial equivalence and its inverse is equivalent to\nthe restriction of the identity to the source. -/\ntheorem self_trans_symm : e.trans e.symm ≈ ofSet e.source := by\n  have A : (e.trans e.symm).source = e.source := by mfld_set_tac\n  refine ⟨by rw [A, ofSet_source], fun x hx => ?_⟩\n  rw [A] at hx\n  simp only [hx, mfld_simps]\n\n"}
{"name":"PartialEquiv.symm_trans_self","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\nβ : Type u_2\ne : PartialEquiv α β\n⊢ HasEquiv.Equiv (e.symm.trans e) (PartialEquiv.ofSet e.target)","decl":"/-- Composition of the inverse of a partial equivalence and this partial equivalence is equivalent\nto the restriction of the identity to the target. -/\ntheorem symm_trans_self : e.symm.trans e ≈ ofSet e.target :=\n  self_trans_symm e.symm\n\n"}
{"name":"PartialEquiv.eq_of_eqOnSource_univ","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\nβ : Type u_2\ne e' : PartialEquiv α β\nh : HasEquiv.Equiv e e'\ns : Eq e.source Set.univ\nt : Eq e.target Set.univ\n⊢ Eq e e'","decl":"/-- Two equivalent partial equivs are equal when the source and target are `univ`. -/\ntheorem eq_of_eqOnSource_univ (e e' : PartialEquiv α β) (h : e ≈ e') (s : e.source = univ)\n    (t : e.target = univ) : e = e' := by\n  refine PartialEquiv.ext (fun x => ?_) (fun x => ?_) h.1\n  · apply h.2\n    rw [s]\n    exact mem_univ _\n  · apply h.symm'.2\n    rw [symm_source, t]\n    exact mem_univ _\n\n"}
{"name":"PartialEquiv.prod_source","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nδ : Type u_4\ne : PartialEquiv α β\ne' : PartialEquiv γ δ\n⊢ Eq (e.prod e').source (SProd.sprod e.source e'.source)","decl":"@[simp, mfld_simps]\ntheorem prod_source (e : PartialEquiv α β) (e' : PartialEquiv γ δ) :\n    (e.prod e').source = e.source ×ˢ e'.source :=\n  rfl\n\n"}
{"name":"PartialEquiv.prod_target","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nδ : Type u_4\ne : PartialEquiv α β\ne' : PartialEquiv γ δ\n⊢ Eq (e.prod e').target (SProd.sprod e.target e'.target)","decl":"@[simp, mfld_simps]\ntheorem prod_target (e : PartialEquiv α β) (e' : PartialEquiv γ δ) :\n    (e.prod e').target = e.target ×ˢ e'.target :=\n  rfl\n\n"}
{"name":"PartialEquiv.prod_coe","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nδ : Type u_4\ne : PartialEquiv α β\ne' : PartialEquiv γ δ\n⊢ Eq ↑(e.prod e') fun p => { fst := ↑e p.1, snd := ↑e' p.2 }","decl":"@[simp, mfld_simps]\ntheorem prod_coe (e : PartialEquiv α β) (e' : PartialEquiv γ δ) :\n    (e.prod e' : α × γ → β × δ) = fun p => (e p.1, e' p.2) :=\n  rfl\n\n"}
{"name":"PartialEquiv.prod_coe_symm","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nδ : Type u_4\ne : PartialEquiv α β\ne' : PartialEquiv γ δ\n⊢ Eq ↑(e.prod e').symm fun p => { fst := ↑e.symm p.1, snd := ↑e'.symm p.2 }","decl":"theorem prod_coe_symm (e : PartialEquiv α β) (e' : PartialEquiv γ δ) :\n    ((e.prod e').symm : β × δ → α × γ) = fun p => (e.symm p.1, e'.symm p.2) :=\n  rfl\n\n"}
{"name":"PartialEquiv.prod_symm","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nδ : Type u_4\ne : PartialEquiv α β\ne' : PartialEquiv γ δ\n⊢ Eq (e.prod e').symm (e.symm.prod e'.symm)","decl":"@[simp, mfld_simps]\ntheorem prod_symm (e : PartialEquiv α β) (e' : PartialEquiv γ δ) :\n    (e.prod e').symm = e.symm.prod e'.symm := by\n  ext x <;> simp [prod_coe_symm]\n\n"}
{"name":"PartialEquiv.refl_prod_refl","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\nβ : Type u_2\n⊢ Eq ((PartialEquiv.refl α).prod (PartialEquiv.refl β)) (PartialEquiv.refl (Prod α β))","decl":"@[simp, mfld_simps]\ntheorem refl_prod_refl :\n    (PartialEquiv.refl α).prod (PartialEquiv.refl β) = PartialEquiv.refl (α × β) := by\n  -- Porting note: `ext1 ⟨x, y⟩` insufficient number of binders\n  ext ⟨x, y⟩ <;> simp\n\n"}
{"name":"PartialEquiv.prod_trans","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nδ : Type u_4\nη : Type u_5\nε : Type u_6\ne : PartialEquiv α β\nf : PartialEquiv β γ\ne' : PartialEquiv δ η\nf' : PartialEquiv η ε\n⊢ Eq ((e.prod e').trans (f.prod f')) ((e.trans f).prod (e'.trans f'))","decl":"@[simp, mfld_simps]\ntheorem prod_trans {η : Type*} {ε : Type*} (e : PartialEquiv α β) (f : PartialEquiv β γ)\n    (e' : PartialEquiv δ η) (f' : PartialEquiv η ε) :\n    (e.prod e').trans (f.prod f') = (e.trans f).prod (e'.trans f') := by\n  ext ⟨x, y⟩ <;> simp [Set.ext_iff]; tauto\n\n"}
{"name":"PartialEquiv.piecewise_target","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\nβ : Type u_2\ne e' : PartialEquiv α β\ns : Set α\nt : Set β\ninst✝¹ : (x : α) → Decidable (Membership.mem s x)\ninst✝ : (y : β) → Decidable (Membership.mem t y)\nH : e.IsImage s t\nH' : e'.IsImage s t\n⊢ Eq (e.piecewise e' s t H H').target (t.ite e.target e'.target)","decl":"/-- Combine two `PartialEquiv`s using `Set.piecewise`. The source of the new `PartialEquiv` is\n`s.ite e.source e'.source = e.source ∩ s ∪ e'.source \\ s`, and similarly for target.  The function\nsends `e.source ∩ s` to `e.target ∩ t` using `e` and `e'.source \\ s` to `e'.target \\ t` using `e'`,\nand similarly for the inverse function. The definition assumes `e.isImage s t` and\n`e'.isImage s t`. -/\n@[simps (config := .asFn)]\ndef piecewise (e e' : PartialEquiv α β) (s : Set α) (t : Set β) [∀ x, Decidable (x ∈ s)]\n    [∀ y, Decidable (y ∈ t)] (H : e.IsImage s t) (H' : e'.IsImage s t) :\n    PartialEquiv α β where\n  toFun := s.piecewise e e'\n  invFun := t.piecewise e.symm e'.symm\n  source := s.ite e.source e'.source\n  target := t.ite e.target e'.target\n  map_source' := H.mapsTo.piecewise_ite H'.compl.mapsTo\n  map_target' := H.symm.mapsTo.piecewise_ite H'.symm.compl.mapsTo\n  left_inv' := H.leftInvOn_piecewise H'\n  right_inv' := H.symm.leftInvOn_piecewise H'.symm\n\n"}
{"name":"PartialEquiv.piecewise_apply","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\nβ : Type u_2\ne e' : PartialEquiv α β\ns : Set α\nt : Set β\ninst✝¹ : (x : α) → Decidable (Membership.mem s x)\ninst✝ : (y : β) → Decidable (Membership.mem t y)\nH : e.IsImage s t\nH' : e'.IsImage s t\n⊢ Eq (↑(e.piecewise e' s t H H')) (s.piecewise ↑e ↑e')","decl":"/-- Combine two `PartialEquiv`s using `Set.piecewise`. The source of the new `PartialEquiv` is\n`s.ite e.source e'.source = e.source ∩ s ∪ e'.source \\ s`, and similarly for target.  The function\nsends `e.source ∩ s` to `e.target ∩ t` using `e` and `e'.source \\ s` to `e'.target \\ t` using `e'`,\nand similarly for the inverse function. The definition assumes `e.isImage s t` and\n`e'.isImage s t`. -/\n@[simps (config := .asFn)]\ndef piecewise (e e' : PartialEquiv α β) (s : Set α) (t : Set β) [∀ x, Decidable (x ∈ s)]\n    [∀ y, Decidable (y ∈ t)] (H : e.IsImage s t) (H' : e'.IsImage s t) :\n    PartialEquiv α β where\n  toFun := s.piecewise e e'\n  invFun := t.piecewise e.symm e'.symm\n  source := s.ite e.source e'.source\n  target := t.ite e.target e'.target\n  map_source' := H.mapsTo.piecewise_ite H'.compl.mapsTo\n  map_target' := H.symm.mapsTo.piecewise_ite H'.symm.compl.mapsTo\n  left_inv' := H.leftInvOn_piecewise H'\n  right_inv' := H.symm.leftInvOn_piecewise H'.symm\n\n"}
{"name":"PartialEquiv.piecewise_source","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\nβ : Type u_2\ne e' : PartialEquiv α β\ns : Set α\nt : Set β\ninst✝¹ : (x : α) → Decidable (Membership.mem s x)\ninst✝ : (y : β) → Decidable (Membership.mem t y)\nH : e.IsImage s t\nH' : e'.IsImage s t\n⊢ Eq (e.piecewise e' s t H H').source (s.ite e.source e'.source)","decl":"/-- Combine two `PartialEquiv`s using `Set.piecewise`. The source of the new `PartialEquiv` is\n`s.ite e.source e'.source = e.source ∩ s ∪ e'.source \\ s`, and similarly for target.  The function\nsends `e.source ∩ s` to `e.target ∩ t` using `e` and `e'.source \\ s` to `e'.target \\ t` using `e'`,\nand similarly for the inverse function. The definition assumes `e.isImage s t` and\n`e'.isImage s t`. -/\n@[simps (config := .asFn)]\ndef piecewise (e e' : PartialEquiv α β) (s : Set α) (t : Set β) [∀ x, Decidable (x ∈ s)]\n    [∀ y, Decidable (y ∈ t)] (H : e.IsImage s t) (H' : e'.IsImage s t) :\n    PartialEquiv α β where\n  toFun := s.piecewise e e'\n  invFun := t.piecewise e.symm e'.symm\n  source := s.ite e.source e'.source\n  target := t.ite e.target e'.target\n  map_source' := H.mapsTo.piecewise_ite H'.compl.mapsTo\n  map_target' := H.symm.mapsTo.piecewise_ite H'.symm.compl.mapsTo\n  left_inv' := H.leftInvOn_piecewise H'\n  right_inv' := H.symm.leftInvOn_piecewise H'.symm\n\n"}
{"name":"PartialEquiv.piecewise_symm_apply","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\nβ : Type u_2\ne e' : PartialEquiv α β\ns : Set α\nt : Set β\ninst✝¹ : (x : α) → Decidable (Membership.mem s x)\ninst✝ : (y : β) → Decidable (Membership.mem t y)\nH : e.IsImage s t\nH' : e'.IsImage s t\n⊢ Eq (↑(e.piecewise e' s t H H').symm) (t.piecewise ↑e.symm ↑e'.symm)","decl":"/-- Combine two `PartialEquiv`s using `Set.piecewise`. The source of the new `PartialEquiv` is\n`s.ite e.source e'.source = e.source ∩ s ∪ e'.source \\ s`, and similarly for target.  The function\nsends `e.source ∩ s` to `e.target ∩ t` using `e` and `e'.source \\ s` to `e'.target \\ t` using `e'`,\nand similarly for the inverse function. The definition assumes `e.isImage s t` and\n`e'.isImage s t`. -/\n@[simps (config := .asFn)]\ndef piecewise (e e' : PartialEquiv α β) (s : Set α) (t : Set β) [∀ x, Decidable (x ∈ s)]\n    [∀ y, Decidable (y ∈ t)] (H : e.IsImage s t) (H' : e'.IsImage s t) :\n    PartialEquiv α β where\n  toFun := s.piecewise e e'\n  invFun := t.piecewise e.symm e'.symm\n  source := s.ite e.source e'.source\n  target := t.ite e.target e'.target\n  map_source' := H.mapsTo.piecewise_ite H'.compl.mapsTo\n  map_target' := H.symm.mapsTo.piecewise_ite H'.symm.compl.mapsTo\n  left_inv' := H.leftInvOn_piecewise H'\n  right_inv' := H.symm.leftInvOn_piecewise H'.symm\n\n"}
{"name":"PartialEquiv.symm_piecewise","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\nβ : Type u_2\ne e' : PartialEquiv α β\ns : Set α\nt : Set β\ninst✝¹ : (x : α) → Decidable (Membership.mem s x)\ninst✝ : (y : β) → Decidable (Membership.mem t y)\nH : e.IsImage s t\nH' : e'.IsImage s t\n⊢ Eq (e.piecewise e' s t H H').symm (e.symm.piecewise e'.symm t s ⋯ ⋯)","decl":"theorem symm_piecewise (e e' : PartialEquiv α β) {s : Set α} {t : Set β} [∀ x, Decidable (x ∈ s)]\n    [∀ y, Decidable (y ∈ t)] (H : e.IsImage s t) (H' : e'.IsImage s t) :\n    (e.piecewise e' s t H H').symm = e.symm.piecewise e'.symm t s H.symm H'.symm :=\n  rfl\n\n"}
{"name":"PartialEquiv.disjointUnion_target","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\nβ : Type u_2\ne e' : PartialEquiv α β\nhs : Disjoint e.source e'.source\nht : Disjoint e.target e'.target\ninst✝¹ : (x : α) → Decidable (Membership.mem e.source x)\ninst✝ : (y : β) → Decidable (Membership.mem e.target y)\n⊢ Eq (e.disjointUnion e' hs ht).target (Union.union e.target e'.target)","decl":"/-- Combine two `PartialEquiv`s with disjoint sources and disjoint targets. We reuse\n`PartialEquiv.piecewise`, then override `source` and `target` to ensure better definitional\nequalities. -/\n@[simps! (config := .asFn)]\ndef disjointUnion (e e' : PartialEquiv α β) (hs : Disjoint e.source e'.source)\n    (ht : Disjoint e.target e'.target) [∀ x, Decidable (x ∈ e.source)]\n    [∀ y, Decidable (y ∈ e.target)] : PartialEquiv α β :=\n  (e.piecewise e' e.source e.target e.isImage_source_target <|\n        e'.isImage_source_target_of_disjoint _ hs.symm ht.symm).copy\n    _ rfl _ rfl (e.source ∪ e'.source) (ite_left _ _) (e.target ∪ e'.target) (ite_left _ _)\n\n"}
{"name":"PartialEquiv.disjointUnion_symm_apply","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\nβ : Type u_2\ne e' : PartialEquiv α β\nhs : Disjoint e.source e'.source\nht : Disjoint e.target e'.target\ninst✝¹ : (x : α) → Decidable (Membership.mem e.source x)\ninst✝ : (y : β) → Decidable (Membership.mem e.target y)\n⊢ Eq (↑(e.disjointUnion e' hs ht).symm) (e.target.piecewise ↑e.symm ↑e'.symm)","decl":"/-- Combine two `PartialEquiv`s with disjoint sources and disjoint targets. We reuse\n`PartialEquiv.piecewise`, then override `source` and `target` to ensure better definitional\nequalities. -/\n@[simps! (config := .asFn)]\ndef disjointUnion (e e' : PartialEquiv α β) (hs : Disjoint e.source e'.source)\n    (ht : Disjoint e.target e'.target) [∀ x, Decidable (x ∈ e.source)]\n    [∀ y, Decidable (y ∈ e.target)] : PartialEquiv α β :=\n  (e.piecewise e' e.source e.target e.isImage_source_target <|\n        e'.isImage_source_target_of_disjoint _ hs.symm ht.symm).copy\n    _ rfl _ rfl (e.source ∪ e'.source) (ite_left _ _) (e.target ∪ e'.target) (ite_left _ _)\n\n"}
{"name":"PartialEquiv.disjointUnion_source","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\nβ : Type u_2\ne e' : PartialEquiv α β\nhs : Disjoint e.source e'.source\nht : Disjoint e.target e'.target\ninst✝¹ : (x : α) → Decidable (Membership.mem e.source x)\ninst✝ : (y : β) → Decidable (Membership.mem e.target y)\n⊢ Eq (e.disjointUnion e' hs ht).source (Union.union e.source e'.source)","decl":"/-- Combine two `PartialEquiv`s with disjoint sources and disjoint targets. We reuse\n`PartialEquiv.piecewise`, then override `source` and `target` to ensure better definitional\nequalities. -/\n@[simps! (config := .asFn)]\ndef disjointUnion (e e' : PartialEquiv α β) (hs : Disjoint e.source e'.source)\n    (ht : Disjoint e.target e'.target) [∀ x, Decidable (x ∈ e.source)]\n    [∀ y, Decidable (y ∈ e.target)] : PartialEquiv α β :=\n  (e.piecewise e' e.source e.target e.isImage_source_target <|\n        e'.isImage_source_target_of_disjoint _ hs.symm ht.symm).copy\n    _ rfl _ rfl (e.source ∪ e'.source) (ite_left _ _) (e.target ∪ e'.target) (ite_left _ _)\n\n"}
{"name":"PartialEquiv.disjointUnion_apply","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\nβ : Type u_2\ne e' : PartialEquiv α β\nhs : Disjoint e.source e'.source\nht : Disjoint e.target e'.target\ninst✝¹ : (x : α) → Decidable (Membership.mem e.source x)\ninst✝ : (y : β) → Decidable (Membership.mem e.target y)\n⊢ Eq (↑(e.disjointUnion e' hs ht)) (e.source.piecewise ↑e ↑e')","decl":"/-- Combine two `PartialEquiv`s with disjoint sources and disjoint targets. We reuse\n`PartialEquiv.piecewise`, then override `source` and `target` to ensure better definitional\nequalities. -/\n@[simps! (config := .asFn)]\ndef disjointUnion (e e' : PartialEquiv α β) (hs : Disjoint e.source e'.source)\n    (ht : Disjoint e.target e'.target) [∀ x, Decidable (x ∈ e.source)]\n    [∀ y, Decidable (y ∈ e.target)] : PartialEquiv α β :=\n  (e.piecewise e' e.source e.target e.isImage_source_target <|\n        e'.isImage_source_target_of_disjoint _ hs.symm ht.symm).copy\n    _ rfl _ rfl (e.source ∪ e'.source) (ite_left _ _) (e.target ∪ e'.target) (ite_left _ _)\n\n"}
{"name":"PartialEquiv.disjointUnion_eq_piecewise","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\nβ : Type u_2\ne e' : PartialEquiv α β\nhs : Disjoint e.source e'.source\nht : Disjoint e.target e'.target\ninst✝¹ : (x : α) → Decidable (Membership.mem e.source x)\ninst✝ : (y : β) → Decidable (Membership.mem e.target y)\n⊢ Eq (e.disjointUnion e' hs ht) (e.piecewise e' e.source e.target ⋯ ⋯)","decl":"theorem disjointUnion_eq_piecewise (e e' : PartialEquiv α β) (hs : Disjoint e.source e'.source)\n    (ht : Disjoint e.target e'.target) [∀ x, Decidable (x ∈ e.source)]\n    [∀ y, Decidable (y ∈ e.target)] :\n    e.disjointUnion e' hs ht =\n      e.piecewise e' e.source e.target e.isImage_source_target\n        (e'.isImage_source_target_of_disjoint _ hs.symm ht.symm) :=\n  copy_eq ..\n\n"}
{"name":"PartialEquiv.pi_source","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"ι : Type u_5\nαi : ι → Type u_6\nβi : ι → Type u_7\nei : (i : ι) → PartialEquiv (αi i) (βi i)\n⊢ Eq (PartialEquiv.pi ei).source (Set.univ.pi fun i => (ei i).source)","decl":"/-- The product of a family of partial equivalences, as a partial equivalence on the pi type. -/\n@[simps (config := mfld_cfg) apply source target]\nprotected def pi (ei : ∀ i, PartialEquiv (αi i) (βi i)) : PartialEquiv (∀ i, αi i) (∀ i, βi i) where\n  toFun := Pi.map fun i ↦ ei i\n  invFun := Pi.map fun i ↦ (ei i).symm\n  source := pi univ fun i => (ei i).source\n  target := pi univ fun i => (ei i).target\n  map_source' _ hf i hi := (ei i).map_source (hf i hi)\n  map_target' _ hf i hi := (ei i).map_target (hf i hi)\n  left_inv' _ hf := funext fun i => (ei i).left_inv (hf i trivial)\n  right_inv' _ hf := funext fun i => (ei i).right_inv (hf i trivial)\n\n"}
{"name":"PartialEquiv.pi_apply","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"ι : Type u_5\nαi : ι → Type u_6\nβi : ι → Type u_7\nei : (i : ι) → PartialEquiv (αi i) (βi i)\n⊢ Eq (↑(PartialEquiv.pi ei)) (Pi.map fun i => ↑(ei i))","decl":"/-- The product of a family of partial equivalences, as a partial equivalence on the pi type. -/\n@[simps (config := mfld_cfg) apply source target]\nprotected def pi (ei : ∀ i, PartialEquiv (αi i) (βi i)) : PartialEquiv (∀ i, αi i) (∀ i, βi i) where\n  toFun := Pi.map fun i ↦ ei i\n  invFun := Pi.map fun i ↦ (ei i).symm\n  source := pi univ fun i => (ei i).source\n  target := pi univ fun i => (ei i).target\n  map_source' _ hf i hi := (ei i).map_source (hf i hi)\n  map_target' _ hf i hi := (ei i).map_target (hf i hi)\n  left_inv' _ hf := funext fun i => (ei i).left_inv (hf i trivial)\n  right_inv' _ hf := funext fun i => (ei i).right_inv (hf i trivial)\n\n"}
{"name":"PartialEquiv.pi_target","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"ι : Type u_5\nαi : ι → Type u_6\nβi : ι → Type u_7\nei : (i : ι) → PartialEquiv (αi i) (βi i)\n⊢ Eq (PartialEquiv.pi ei).target (Set.univ.pi fun i => (ei i).target)","decl":"/-- The product of a family of partial equivalences, as a partial equivalence on the pi type. -/\n@[simps (config := mfld_cfg) apply source target]\nprotected def pi (ei : ∀ i, PartialEquiv (αi i) (βi i)) : PartialEquiv (∀ i, αi i) (∀ i, βi i) where\n  toFun := Pi.map fun i ↦ ei i\n  invFun := Pi.map fun i ↦ (ei i).symm\n  source := pi univ fun i => (ei i).source\n  target := pi univ fun i => (ei i).target\n  map_source' _ hf i hi := (ei i).map_source (hf i hi)\n  map_target' _ hf i hi := (ei i).map_target (hf i hi)\n  left_inv' _ hf := funext fun i => (ei i).left_inv (hf i trivial)\n  right_inv' _ hf := funext fun i => (ei i).right_inv (hf i trivial)\n\n"}
{"name":"PartialEquiv.pi_symm","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"ι : Type u_5\nαi : ι → Type u_6\nβi : ι → Type u_7\nei : (i : ι) → PartialEquiv (αi i) (βi i)\n⊢ Eq (PartialEquiv.pi ei).symm (PartialEquiv.pi fun i => (ei i).symm)","decl":"@[simp, mfld_simps]\ntheorem pi_symm (ei : ∀ i, PartialEquiv (αi i) (βi i)) :\n    (PartialEquiv.pi ei).symm = .pi fun i ↦ (ei i).symm :=\n  rfl\n\n"}
{"name":"PartialEquiv.pi_symm_apply","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"ι : Type u_5\nαi : ι → Type u_6\nβi : ι → Type u_7\nei : (i : ι) → PartialEquiv (αi i) (βi i)\n⊢ Eq ↑(PartialEquiv.pi ei).symm fun f i => ↑(ei i).symm (f i)","decl":"theorem pi_symm_apply (ei : ∀ i, PartialEquiv (αi i) (βi i)) :\n    ⇑(PartialEquiv.pi ei).symm = fun f i ↦ (ei i).symm (f i) :=\n  rfl\n\n"}
{"name":"PartialEquiv.pi_refl","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"ι : Type u_5\nαi : ι → Type u_6\n⊢ Eq (PartialEquiv.pi fun i => PartialEquiv.refl (αi i)) (PartialEquiv.refl ((i : ι) → αi i))","decl":"@[simp, mfld_simps]\ntheorem pi_refl : (PartialEquiv.pi fun i ↦ PartialEquiv.refl (αi i)) = .refl (∀ i, αi i) := by\n  ext <;> simp\n\n"}
{"name":"PartialEquiv.pi_trans","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"ι : Type u_5\nαi : ι → Type u_6\nβi : ι → Type u_7\nγi : ι → Type u_8\nei : (i : ι) → PartialEquiv (αi i) (βi i)\nei' : (i : ι) → PartialEquiv (βi i) (γi i)\n⊢ Eq ((PartialEquiv.pi ei).trans (PartialEquiv.pi ei')) (PartialEquiv.pi fun i => (ei i).trans (ei' i))","decl":"@[simp, mfld_simps]\ntheorem pi_trans (ei : ∀ i, PartialEquiv (αi i) (βi i)) (ei' : ∀ i, PartialEquiv (βi i) (γi i)) :\n    (PartialEquiv.pi ei).trans (PartialEquiv.pi ei') = .pi fun i ↦ (ei i).trans (ei' i) := by\n  ext <;> simp [forall_and]\n\n"}
{"name":"Set.BijOn.toPartialEquiv_target","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : Nonempty α\nf : α → β\ns : Set α\nt : Set β\nhf : Set.BijOn f s t\n⊢ Eq (Set.BijOn.toPartialEquiv f s t hf).target t","decl":"/-- A bijection between two sets `s : Set α` and `t : Set β` provides a partial equivalence\nbetween `α` and `β`. -/\n@[simps (config := .asFn)]\nnoncomputable def BijOn.toPartialEquiv [Nonempty α] (f : α → β) (s : Set α) (t : Set β)\n    (hf : BijOn f s t) : PartialEquiv α β where\n  toFun := f\n  invFun := invFunOn f s\n  source := s\n  target := t\n  map_source' := hf.mapsTo\n  map_target' := hf.surjOn.mapsTo_invFunOn\n  left_inv' := hf.invOn_invFunOn.1\n  right_inv' := hf.invOn_invFunOn.2\n\n"}
{"name":"Set.BijOn.toPartialEquiv_symm_apply","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : Nonempty α\nf : α → β\ns : Set α\nt : Set β\nhf : Set.BijOn f s t\n⊢ Eq (↑(Set.BijOn.toPartialEquiv f s t hf).symm) (Function.invFunOn f s)","decl":"/-- A bijection between two sets `s : Set α` and `t : Set β` provides a partial equivalence\nbetween `α` and `β`. -/\n@[simps (config := .asFn)]\nnoncomputable def BijOn.toPartialEquiv [Nonempty α] (f : α → β) (s : Set α) (t : Set β)\n    (hf : BijOn f s t) : PartialEquiv α β where\n  toFun := f\n  invFun := invFunOn f s\n  source := s\n  target := t\n  map_source' := hf.mapsTo\n  map_target' := hf.surjOn.mapsTo_invFunOn\n  left_inv' := hf.invOn_invFunOn.1\n  right_inv' := hf.invOn_invFunOn.2\n\n"}
{"name":"Set.BijOn.toPartialEquiv_source","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : Nonempty α\nf : α → β\ns : Set α\nt : Set β\nhf : Set.BijOn f s t\n⊢ Eq (Set.BijOn.toPartialEquiv f s t hf).source s","decl":"/-- A bijection between two sets `s : Set α` and `t : Set β` provides a partial equivalence\nbetween `α` and `β`. -/\n@[simps (config := .asFn)]\nnoncomputable def BijOn.toPartialEquiv [Nonempty α] (f : α → β) (s : Set α) (t : Set β)\n    (hf : BijOn f s t) : PartialEquiv α β where\n  toFun := f\n  invFun := invFunOn f s\n  source := s\n  target := t\n  map_source' := hf.mapsTo\n  map_target' := hf.surjOn.mapsTo_invFunOn\n  left_inv' := hf.invOn_invFunOn.1\n  right_inv' := hf.invOn_invFunOn.2\n\n"}
{"name":"Set.BijOn.toPartialEquiv_apply","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : Nonempty α\nf : α → β\ns : Set α\nt : Set β\nhf : Set.BijOn f s t\n⊢ Eq (↑(Set.BijOn.toPartialEquiv f s t hf)) f","decl":"/-- A bijection between two sets `s : Set α` and `t : Set β` provides a partial equivalence\nbetween `α` and `β`. -/\n@[simps (config := .asFn)]\nnoncomputable def BijOn.toPartialEquiv [Nonempty α] (f : α → β) (s : Set α) (t : Set β)\n    (hf : BijOn f s t) : PartialEquiv α β where\n  toFun := f\n  invFun := invFunOn f s\n  source := s\n  target := t\n  map_source' := hf.mapsTo\n  map_target' := hf.surjOn.mapsTo_invFunOn\n  left_inv' := hf.invOn_invFunOn.1\n  right_inv' := hf.invOn_invFunOn.2\n\n"}
{"name":"Equiv.refl_toPartialEquiv","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\n⊢ Eq (Equiv.refl α).toPartialEquiv (PartialEquiv.refl α)","decl":"@[simp, mfld_simps]\ntheorem refl_toPartialEquiv : (Equiv.refl α).toPartialEquiv = PartialEquiv.refl α :=\n  rfl\n\n"}
{"name":"Equiv.symm_toPartialEquiv","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\nβ : Type u_2\ne : Equiv α β\n⊢ Eq e.symm.toPartialEquiv e.toPartialEquiv.symm","decl":"@[simp, mfld_simps]\ntheorem symm_toPartialEquiv : e.symm.toPartialEquiv = e.toPartialEquiv.symm :=\n  rfl\n\n"}
{"name":"Equiv.trans_toPartialEquiv","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ne : Equiv α β\ne' : Equiv β γ\n⊢ Eq (e.trans e').toPartialEquiv (e.toPartialEquiv.trans e'.toPartialEquiv)","decl":"@[simp, mfld_simps]\ntheorem trans_toPartialEquiv :\n    (e.trans e').toPartialEquiv = e.toPartialEquiv.trans e'.toPartialEquiv :=\n  PartialEquiv.ext (fun _ => rfl) (fun _ => rfl)\n    (by simp [PartialEquiv.trans_source, Equiv.toPartialEquiv])\n\n"}
{"name":"Equiv.transPartialEquiv_target","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ne : Equiv α β\nf' : PartialEquiv β γ\n⊢ Eq (e.transPartialEquiv f').target f'.target","decl":"/-- Precompose a partial equivalence with an equivalence.\nWe modify the source and target to have better definitional behavior. -/\n@[simps!]\ndef transPartialEquiv (e : α ≃ β) (f' : PartialEquiv β γ) : PartialEquiv α γ :=\n  (e.toPartialEquiv.trans f').copy _ rfl _ rfl (e ⁻¹' f'.source) (univ_inter _) f'.target\n    (inter_univ _)\n\n"}
{"name":"Equiv.transPartialEquiv_source","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ne : Equiv α β\nf' : PartialEquiv β γ\n⊢ Eq (e.transPartialEquiv f').source (Set.preimage (⇑e) f'.source)","decl":"/-- Precompose a partial equivalence with an equivalence.\nWe modify the source and target to have better definitional behavior. -/\n@[simps!]\ndef transPartialEquiv (e : α ≃ β) (f' : PartialEquiv β γ) : PartialEquiv α γ :=\n  (e.toPartialEquiv.trans f').copy _ rfl _ rfl (e ⁻¹' f'.source) (univ_inter _) f'.target\n    (inter_univ _)\n\n"}
{"name":"Equiv.transPartialEquiv_apply","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ne : Equiv α β\nf' : PartialEquiv β γ\na✝ : α\n⊢ Eq (↑(e.transPartialEquiv f') a✝) (↑f' (e a✝))","decl":"/-- Precompose a partial equivalence with an equivalence.\nWe modify the source and target to have better definitional behavior. -/\n@[simps!]\ndef transPartialEquiv (e : α ≃ β) (f' : PartialEquiv β γ) : PartialEquiv α γ :=\n  (e.toPartialEquiv.trans f').copy _ rfl _ rfl (e ⁻¹' f'.source) (univ_inter _) f'.target\n    (inter_univ _)\n\n"}
{"name":"Equiv.transPartialEquiv_symm_apply","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ne : Equiv α β\nf' : PartialEquiv β γ\na✝ : γ\n⊢ Eq (↑(e.transPartialEquiv f').symm a✝) (e.symm (↑f'.symm a✝))","decl":"/-- Precompose a partial equivalence with an equivalence.\nWe modify the source and target to have better definitional behavior. -/\n@[simps!]\ndef transPartialEquiv (e : α ≃ β) (f' : PartialEquiv β γ) : PartialEquiv α γ :=\n  (e.toPartialEquiv.trans f').copy _ rfl _ rfl (e ⁻¹' f'.source) (univ_inter _) f'.target\n    (inter_univ _)\n\n"}
{"name":"Equiv.transPartialEquiv_eq_trans","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ne : Equiv α β\nf' : PartialEquiv β γ\n⊢ Eq (e.transPartialEquiv f') (e.toPartialEquiv.trans f')","decl":"theorem transPartialEquiv_eq_trans (e : α ≃ β) (f' : PartialEquiv β γ) :\n    e.transPartialEquiv f' = e.toPartialEquiv.trans f' :=\n  PartialEquiv.copy_eq ..\n\n"}
{"name":"Equiv.transPartialEquiv_trans","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nδ : Type u_4\ne : Equiv α β\nf' : PartialEquiv β γ\nf'' : PartialEquiv γ δ\n⊢ Eq ((e.transPartialEquiv f').trans f'') (e.transPartialEquiv (f'.trans f''))","decl":"@[simp, mfld_simps]\ntheorem transPartialEquiv_trans (e : α ≃ β) (f' : PartialEquiv β γ) (f'' : PartialEquiv γ δ) :\n    (e.transPartialEquiv f').trans f'' = e.transPartialEquiv (f'.trans f'') := by\n  simp only [transPartialEquiv_eq_trans, PartialEquiv.trans_assoc]\n\n"}
{"name":"Equiv.trans_transPartialEquiv","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nδ : Type u_4\ne : Equiv α β\ne' : Equiv β γ\nf'' : PartialEquiv γ δ\n⊢ Eq ((e.trans e').transPartialEquiv f'') (e.transPartialEquiv (e'.transPartialEquiv f''))","decl":"@[simp, mfld_simps]\ntheorem trans_transPartialEquiv (e : α ≃ β) (e' : β ≃ γ) (f'' : PartialEquiv γ δ) :\n    (e.trans e').transPartialEquiv f'' = e.transPartialEquiv (e'.transPartialEquiv f'') := by\n  simp only [transPartialEquiv_eq_trans, PartialEquiv.trans_assoc, trans_toPartialEquiv]\n\n"}
{"name":"PartialEquiv.transEquiv_apply","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ne : PartialEquiv α β\nf' : Equiv β γ\na✝ : α\n⊢ Eq (↑(e.transEquiv f') a✝) (f' (↑e a✝))","decl":"/-- Postcompose a partial equivalence with an equivalence.\nWe modify the source and target to have better definitional behavior. -/\n@[simps!]\ndef transEquiv (e : PartialEquiv α β) (f' : β ≃ γ) : PartialEquiv α γ :=\n  (e.trans f'.toPartialEquiv).copy _ rfl _ rfl e.source (inter_univ _) (f'.symm ⁻¹' e.target)\n    (univ_inter _)\n\n"}
{"name":"PartialEquiv.transEquiv_target","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ne : PartialEquiv α β\nf' : Equiv β γ\n⊢ Eq (e.transEquiv f').target (Set.preimage (⇑f'.symm) e.target)","decl":"/-- Postcompose a partial equivalence with an equivalence.\nWe modify the source and target to have better definitional behavior. -/\n@[simps!]\ndef transEquiv (e : PartialEquiv α β) (f' : β ≃ γ) : PartialEquiv α γ :=\n  (e.trans f'.toPartialEquiv).copy _ rfl _ rfl e.source (inter_univ _) (f'.symm ⁻¹' e.target)\n    (univ_inter _)\n\n"}
{"name":"PartialEquiv.transEquiv_symm_apply","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ne : PartialEquiv α β\nf' : Equiv β γ\na✝ : γ\n⊢ Eq (↑(e.transEquiv f').symm a✝) (↑e.symm (f'.symm a✝))","decl":"/-- Postcompose a partial equivalence with an equivalence.\nWe modify the source and target to have better definitional behavior. -/\n@[simps!]\ndef transEquiv (e : PartialEquiv α β) (f' : β ≃ γ) : PartialEquiv α γ :=\n  (e.trans f'.toPartialEquiv).copy _ rfl _ rfl e.source (inter_univ _) (f'.symm ⁻¹' e.target)\n    (univ_inter _)\n\n"}
{"name":"PartialEquiv.transEquiv_source","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ne : PartialEquiv α β\nf' : Equiv β γ\n⊢ Eq (e.transEquiv f').source e.source","decl":"/-- Postcompose a partial equivalence with an equivalence.\nWe modify the source and target to have better definitional behavior. -/\n@[simps!]\ndef transEquiv (e : PartialEquiv α β) (f' : β ≃ γ) : PartialEquiv α γ :=\n  (e.trans f'.toPartialEquiv).copy _ rfl _ rfl e.source (inter_univ _) (f'.symm ⁻¹' e.target)\n    (univ_inter _)\n\n"}
{"name":"PartialEquiv.transEquiv_eq_trans","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ne : PartialEquiv α β\ne' : Equiv β γ\n⊢ Eq (e.transEquiv e') (e.trans e'.toPartialEquiv)","decl":"theorem transEquiv_eq_trans (e : PartialEquiv α β) (e' : β ≃ γ) :\n    e.transEquiv e' = e.trans e'.toPartialEquiv :=\n  copy_eq ..\n\n"}
{"name":"PartialEquiv.transEquiv_transEquiv","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nδ : Type u_4\ne : PartialEquiv α β\nf' : Equiv β γ\nf'' : Equiv γ δ\n⊢ Eq ((e.transEquiv f').transEquiv f'') (e.transEquiv (f'.trans f''))","decl":"@[simp, mfld_simps]\ntheorem transEquiv_transEquiv (e : PartialEquiv α β) (f' : β ≃ γ) (f'' : γ ≃ δ) :\n    (e.transEquiv f').transEquiv f'' = e.transEquiv (f'.trans f'') := by\n  simp only [transEquiv_eq_trans, trans_assoc, Equiv.trans_toPartialEquiv]\n\n"}
{"name":"PartialEquiv.trans_transEquiv","module":"Mathlib.Logic.Equiv.PartialEquiv","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nδ : Type u_4\ne : PartialEquiv α β\ne' : PartialEquiv β γ\nf'' : Equiv γ δ\n⊢ Eq ((e.trans e').transEquiv f'') (e.trans (e'.transEquiv f''))","decl":"@[simp, mfld_simps]\ntheorem trans_transEquiv (e : PartialEquiv α β) (e' : PartialEquiv β γ) (f'' : γ ≃ δ) :\n    (e.trans e').transEquiv f'' = e.trans (e'.transEquiv f'') := by\n  simp only [transEquiv_eq_trans, trans_assoc, Equiv.trans_toPartialEquiv]\n\n"}
