{"name":"instCanonicallyOrderedAddPrimeMultiset","module":"Mathlib.Data.PNat.Factors","initialProofState":"⊢ CanonicallyOrderedAdd PrimeMultiset","decl":"instance : CanonicallyOrderedAdd PrimeMultiset :=\n  inferInstanceAs (CanonicallyOrderedAdd (Multiset Nat.Primes))\n\n"}
{"name":"instOrderedSubPrimeMultiset","module":"Mathlib.Data.PNat.Factors","initialProofState":"⊢ OrderedSub PrimeMultiset","decl":"instance : OrderedSub PrimeMultiset :=\n  inferInstanceAs (OrderedSub (Multiset Nat.Primes))\n\n"}
{"name":"PrimeMultiset.card_ofPrime","module":"Mathlib.Data.PNat.Factors","initialProofState":"p : Nat.Primes\n⊢ Eq (Multiset.card (PrimeMultiset.ofPrime p)) 1","decl":"theorem card_ofPrime (p : Nat.Primes) : Multiset.card (ofPrime p) = 1 :=\n  rfl\n\n"}
{"name":"PrimeMultiset.coe_coeNatMonoidHom","module":"Mathlib.Data.PNat.Factors","initialProofState":"⊢ Eq (⇑PrimeMultiset.coeNatMonoidHom) Coe.coe","decl":"@[simp]\ntheorem coe_coeNatMonoidHom : (coeNatMonoidHom : PrimeMultiset → Multiset ℕ) = Coe.coe :=\n  rfl\n\n"}
{"name":"PrimeMultiset.coeNat_injective","module":"Mathlib.Data.PNat.Factors","initialProofState":"⊢ Function.Injective Coe.coe","decl":"theorem coeNat_injective : Function.Injective (Coe.coe : PrimeMultiset → Multiset ℕ) :=\n  Multiset.map_injective Nat.Primes.coe_nat_injective\n\n"}
{"name":"PrimeMultiset.coeNat_ofPrime","module":"Mathlib.Data.PNat.Factors","initialProofState":"p : Nat.Primes\n⊢ Eq (PrimeMultiset.ofPrime p).toNatMultiset (Singleton.singleton ↑p)","decl":"theorem coeNat_ofPrime (p : Nat.Primes) : (ofPrime p : Multiset ℕ) = {(p : ℕ)} :=\n  rfl\n\n"}
{"name":"PrimeMultiset.coeNat_prime","module":"Mathlib.Data.PNat.Factors","initialProofState":"v : PrimeMultiset\np : Nat\nh : Membership.mem v.toNatMultiset p\n⊢ Nat.Prime p","decl":"theorem coeNat_prime (v : PrimeMultiset) (p : ℕ) (h : p ∈ (v : Multiset ℕ)) : p.Prime := by\n  rcases Multiset.mem_map.mp h with ⟨⟨_, hp'⟩, ⟨_, h_eq⟩⟩\n  exact h_eq ▸ hp'\n\n"}
{"name":"PrimeMultiset.coe_coePNatMonoidHom","module":"Mathlib.Data.PNat.Factors","initialProofState":"⊢ Eq (⇑PrimeMultiset.coePNatMonoidHom) Coe.coe","decl":"@[simp]\ntheorem coe_coePNatMonoidHom : (coePNatMonoidHom : PrimeMultiset → Multiset ℕ+) = Coe.coe :=\n  rfl\n\n"}
{"name":"PrimeMultiset.coePNat_injective","module":"Mathlib.Data.PNat.Factors","initialProofState":"⊢ Function.Injective Coe.coe","decl":"theorem coePNat_injective : Function.Injective (Coe.coe : PrimeMultiset → Multiset ℕ+) :=\n  Multiset.map_injective Nat.Primes.coe_pnat_injective\n\n"}
{"name":"PrimeMultiset.coePNat_ofPrime","module":"Mathlib.Data.PNat.Factors","initialProofState":"p : Nat.Primes\n⊢ Eq (PrimeMultiset.ofPrime p).toPNatMultiset (Singleton.singleton ↑p)","decl":"theorem coePNat_ofPrime (p : Nat.Primes) : (ofPrime p : Multiset ℕ+) = {(p : ℕ+)} :=\n  rfl\n\n"}
{"name":"PrimeMultiset.coePNat_prime","module":"Mathlib.Data.PNat.Factors","initialProofState":"v : PrimeMultiset\np : PNat\nh : Membership.mem v.toPNatMultiset p\n⊢ p.Prime","decl":"theorem coePNat_prime (v : PrimeMultiset) (p : ℕ+) (h : p ∈ (v : Multiset ℕ+)) : p.Prime := by\n  rcases Multiset.mem_map.mp h with ⟨⟨_, hp'⟩, ⟨_, h_eq⟩⟩\n  exact h_eq ▸ hp'\n\n"}
{"name":"PrimeMultiset.coePNat_nat","module":"Mathlib.Data.PNat.Factors","initialProofState":"v : PrimeMultiset\n⊢ Eq (Multiset.map PNat.val v.toPNatMultiset) v.toNatMultiset","decl":"theorem coePNat_nat (v : PrimeMultiset) : ((v : Multiset ℕ+) : Multiset ℕ) = (v : Multiset ℕ) := by\n  change (v.map (Coe.coe : Nat.Primes → ℕ+)).map Subtype.val = v.map Subtype.val\n  rw [Multiset.map_map]\n  congr\n\n"}
{"name":"PrimeMultiset.coe_prod","module":"Mathlib.Data.PNat.Factors","initialProofState":"v : PrimeMultiset\n⊢ Eq (↑v.prod) v.toNatMultiset.prod","decl":"theorem coe_prod (v : PrimeMultiset) : (v.prod : ℕ) = (v : Multiset ℕ).prod := by\n  let h : (v.prod : ℕ) = ((v.map Coe.coe).map Coe.coe).prod :=\n    PNat.coeMonoidHom.map_multiset_prod v.toPNatMultiset\n  rw [Multiset.map_map] at h\n  have : (Coe.coe : ℕ+ → ℕ) ∘ (Coe.coe : Nat.Primes → ℕ+) = Coe.coe := funext fun p => rfl\n  rw [this] at h; exact h\n\n"}
{"name":"PrimeMultiset.prod_ofPrime","module":"Mathlib.Data.PNat.Factors","initialProofState":"p : Nat.Primes\n⊢ Eq (PrimeMultiset.ofPrime p).prod ↑p","decl":"theorem prod_ofPrime (p : Nat.Primes) : (ofPrime p).prod = (p : ℕ+) :=\n  Multiset.prod_singleton _\n\n"}
{"name":"PrimeMultiset.to_ofNatMultiset","module":"Mathlib.Data.PNat.Factors","initialProofState":"v : Multiset Nat\nh : ∀ (p : Nat), Membership.mem v p → Nat.Prime p\n⊢ Eq (PrimeMultiset.ofNatMultiset v h).toNatMultiset v","decl":"theorem to_ofNatMultiset (v : Multiset ℕ) (h) : (ofNatMultiset v h : Multiset ℕ) = v := by\n  dsimp [ofNatMultiset, toNatMultiset]\n  have : (fun p h => (Coe.coe : Nat.Primes → ℕ) ⟨p, h⟩) = fun p _ => id p := by\n    funext p h\n    rfl\n  rw [Multiset.map_pmap, this, Multiset.pmap_eq_map, Multiset.map_id]\n\n"}
{"name":"PrimeMultiset.prod_ofNatMultiset","module":"Mathlib.Data.PNat.Factors","initialProofState":"v : Multiset Nat\nh : ∀ (p : Nat), Membership.mem v p → Nat.Prime p\n⊢ Eq (↑(PrimeMultiset.ofNatMultiset v h).prod) v.prod","decl":"theorem prod_ofNatMultiset (v : Multiset ℕ) (h) :\n    ((ofNatMultiset v h).prod : ℕ) = (v.prod : ℕ) := by rw [coe_prod, to_ofNatMultiset]\n\n"}
{"name":"PrimeMultiset.to_ofPNatMultiset","module":"Mathlib.Data.PNat.Factors","initialProofState":"v : Multiset PNat\nh : ∀ (p : PNat), Membership.mem v p → p.Prime\n⊢ Eq (PrimeMultiset.ofPNatMultiset v h).toPNatMultiset v","decl":"theorem to_ofPNatMultiset (v : Multiset ℕ+) (h) : (ofPNatMultiset v h : Multiset ℕ+) = v := by\n  dsimp [ofPNatMultiset, toPNatMultiset]\n  have : (fun (p : ℕ+) (h : p.Prime) => (Coe.coe : Nat.Primes → ℕ+) ⟨p, h⟩) = fun p _ => id p := by\n    funext p h\n    apply Subtype.eq\n    rfl\n  rw [Multiset.map_pmap, this, Multiset.pmap_eq_map, Multiset.map_id]\n\n"}
{"name":"PrimeMultiset.prod_ofPNatMultiset","module":"Mathlib.Data.PNat.Factors","initialProofState":"v : Multiset PNat\nh : ∀ (p : PNat), Membership.mem v p → p.Prime\n⊢ Eq (PrimeMultiset.ofPNatMultiset v h).prod v.prod","decl":"theorem prod_ofPNatMultiset (v : Multiset ℕ+) (h) : ((ofPNatMultiset v h).prod : ℕ+) = v.prod := by\n  dsimp [prod]\n  rw [to_ofPNatMultiset]\n\n"}
{"name":"PrimeMultiset.prod_ofNatList","module":"Mathlib.Data.PNat.Factors","initialProofState":"l : List Nat\nh : ∀ (p : Nat), Membership.mem l p → Nat.Prime p\n⊢ Eq (↑(PrimeMultiset.ofNatList l h).prod) l.prod","decl":"theorem prod_ofNatList (l : List ℕ) (h) : ((ofNatList l h).prod : ℕ) = l.prod := by\n  have := prod_ofNatMultiset (l : Multiset ℕ) h\n  rw [Multiset.prod_coe] at this\n  exact this\n\n"}
{"name":"PrimeMultiset.prod_ofPNatList","module":"Mathlib.Data.PNat.Factors","initialProofState":"l : List PNat\nh : ∀ (p : PNat), Membership.mem l p → p.Prime\n⊢ Eq (PrimeMultiset.ofPNatList l h).prod l.prod","decl":"theorem prod_ofPNatList (l : List ℕ+) (h) : (ofPNatList l h).prod = l.prod := by\n  have := prod_ofPNatMultiset (l : Multiset ℕ+) h\n  rw [Multiset.prod_coe] at this\n  exact this\n\n"}
{"name":"PrimeMultiset.prod_zero","module":"Mathlib.Data.PNat.Factors","initialProofState":"⊢ Eq (PrimeMultiset.prod 0) 1","decl":"/-- The product map gives a homomorphism from the additive monoid\nof multisets to the multiplicative monoid ℕ+. -/\ntheorem prod_zero : (0 : PrimeMultiset).prod = 1 := by\n  exact Multiset.prod_zero\n\n"}
{"name":"PrimeMultiset.prod_add","module":"Mathlib.Data.PNat.Factors","initialProofState":"u v : PrimeMultiset\n⊢ Eq (HAdd.hAdd u v).prod (HMul.hMul u.prod v.prod)","decl":"theorem prod_add (u v : PrimeMultiset) : (u + v).prod = u.prod * v.prod := by\n  change (coePNatMonoidHom (u + v)).prod = _\n  rw [coePNatMonoidHom.map_add]\n  exact Multiset.prod_add _ _\n\n"}
{"name":"PrimeMultiset.prod_smul","module":"Mathlib.Data.PNat.Factors","initialProofState":"d : Nat\nu : PrimeMultiset\n⊢ Eq (HSMul.hSMul d u).prod (HPow.hPow u.prod d)","decl":"theorem prod_smul (d : ℕ) (u : PrimeMultiset) : (d • u).prod = u.prod ^ d := by\n  induction d with\n  | zero => simp only [zero_nsmul, pow_zero, prod_zero]\n  | succ n ih => rw [succ_nsmul, prod_add, ih, pow_succ]\n\n"}
{"name":"PNat.prod_factorMultiset","module":"Mathlib.Data.PNat.Factors","initialProofState":"n : PNat\n⊢ Eq n.factorMultiset.prod n","decl":"/-- The product of the factors is the original number -/\ntheorem prod_factorMultiset (n : ℕ+) : (factorMultiset n).prod = n :=\n  eq <| by\n    dsimp [factorMultiset]\n    rw [PrimeMultiset.prod_ofNatList]\n    exact Nat.prod_primeFactorsList n.ne_zero\n\n"}
{"name":"PNat.coeNat_factorMultiset","module":"Mathlib.Data.PNat.Factors","initialProofState":"n : PNat\n⊢ Eq n.factorMultiset.toNatMultiset ↑(↑n).primeFactorsList","decl":"theorem coeNat_factorMultiset (n : ℕ+) :\n    (factorMultiset n : Multiset ℕ) = (Nat.primeFactorsList n : Multiset ℕ) :=\n  PrimeMultiset.to_ofNatMultiset (Nat.primeFactorsList n) (@Nat.prime_of_mem_primeFactorsList n)\n\n"}
{"name":"PrimeMultiset.factorMultiset_prod","module":"Mathlib.Data.PNat.Factors","initialProofState":"v : PrimeMultiset\n⊢ Eq v.prod.factorMultiset v","decl":"/-- If we start with a multiset of primes, take the product and\n then factor it, we get back the original multiset. -/\ntheorem factorMultiset_prod (v : PrimeMultiset) : v.prod.factorMultiset = v := by\n  apply PrimeMultiset.coeNat_injective\n  suffices toNatMultiset (PNat.factorMultiset (prod v)) = toNatMultiset v by exact this\n  rw [v.prod.coeNat_factorMultiset, PrimeMultiset.coe_prod]\n  rcases v with ⟨l⟩\n  --unfold_coes\n  dsimp [PrimeMultiset.toNatMultiset]\n  let l' := l.map (Coe.coe : Nat.Primes → ℕ)\n  have : ∀ p : ℕ, p ∈ l' → p.Prime := fun p hp => by\n    rcases List.mem_map.mp hp with ⟨⟨_, hp'⟩, ⟨_, h_eq⟩⟩\n    exact h_eq ▸ hp'\n  exact Multiset.coe_eq_coe.mpr (@Nat.primeFactorsList_unique _ l' rfl this).symm\n\n"}
{"name":"PNat.factorMultiset_one","module":"Mathlib.Data.PNat.Factors","initialProofState":"⊢ Eq (PNat.factorMultiset 1) 0","decl":"/-- Factoring gives a homomorphism from the multiplicative\n monoid ℕ+ to the additive monoid of multisets. -/\ntheorem factorMultiset_one : factorMultiset 1 = 0 := by\n  simp [factorMultiset, PrimeMultiset.ofNatList, PrimeMultiset.ofNatMultiset]\n\n"}
{"name":"PNat.factorMultiset_mul","module":"Mathlib.Data.PNat.Factors","initialProofState":"n m : PNat\n⊢ Eq (HMul.hMul n m).factorMultiset (HAdd.hAdd n.factorMultiset m.factorMultiset)","decl":"theorem factorMultiset_mul (n m : ℕ+) :\n    factorMultiset (n * m) = factorMultiset n + factorMultiset m := by\n  let u := factorMultiset n\n  let v := factorMultiset m\n  have : n = u.prod := (prod_factorMultiset n).symm; rw [this]\n  have : m = v.prod := (prod_factorMultiset m).symm; rw [this]\n  rw [← PrimeMultiset.prod_add]\n  repeat' rw [PrimeMultiset.factorMultiset_prod]\n\n"}
{"name":"PNat.factorMultiset_pow","module":"Mathlib.Data.PNat.Factors","initialProofState":"n : PNat\nm : Nat\n⊢ Eq (HPow.hPow n m).factorMultiset (HSMul.hSMul m n.factorMultiset)","decl":"theorem factorMultiset_pow (n : ℕ+) (m : ℕ) :\n    factorMultiset (n ^ m) = m • factorMultiset n := by\n  let u := factorMultiset n\n  have : n = u.prod := (prod_factorMultiset n).symm\n  rw [this, ← PrimeMultiset.prod_smul]\n  repeat' rw [PrimeMultiset.factorMultiset_prod]\n\n"}
{"name":"PNat.factorMultiset_ofPrime","module":"Mathlib.Data.PNat.Factors","initialProofState":"p : Nat.Primes\n⊢ Eq (↑p).factorMultiset (PrimeMultiset.ofPrime p)","decl":"/-- Factoring a prime gives the corresponding one-element multiset. -/\ntheorem factorMultiset_ofPrime (p : Nat.Primes) :\n    (p : ℕ+).factorMultiset = PrimeMultiset.ofPrime p := by\n  apply factorMultisetEquiv.symm.injective\n  change (p : ℕ+).factorMultiset.prod = (PrimeMultiset.ofPrime p).prod\n  rw [(p : ℕ+).prod_factorMultiset, PrimeMultiset.prod_ofPrime]\n\n"}
{"name":"PNat.factorMultiset_le_iff","module":"Mathlib.Data.PNat.Factors","initialProofState":"m n : PNat\n⊢ Iff (LE.le m.factorMultiset n.factorMultiset) (Dvd.dvd m n)","decl":"/-- We now have four different results that all encode the\n idea that inequality of multisets corresponds to divisibility\n of positive integers. -/\ntheorem factorMultiset_le_iff {m n : ℕ+} : factorMultiset m ≤ factorMultiset n ↔ m ∣ n := by\n  constructor\n  · intro h\n    rw [← prod_factorMultiset m, ← prod_factorMultiset m]\n    apply Dvd.intro (n.factorMultiset - m.factorMultiset).prod\n    rw [← PrimeMultiset.prod_add, PrimeMultiset.factorMultiset_prod, add_tsub_cancel_of_le h,\n      prod_factorMultiset]\n  · intro h\n    rw [← mul_div_exact h, factorMultiset_mul]\n    exact le_self_add\n\n"}
{"name":"PNat.factorMultiset_le_iff'","module":"Mathlib.Data.PNat.Factors","initialProofState":"m : PNat\nv : PrimeMultiset\n⊢ Iff (LE.le m.factorMultiset v) (Dvd.dvd m v.prod)","decl":"theorem factorMultiset_le_iff' {m : ℕ+} {v : PrimeMultiset} :\n    factorMultiset m ≤ v ↔ m ∣ v.prod := by\n  let h := @factorMultiset_le_iff m v.prod\n  rw [v.factorMultiset_prod] at h\n  exact h\n\n"}
{"name":"PrimeMultiset.prod_dvd_iff","module":"Mathlib.Data.PNat.Factors","initialProofState":"u v : PrimeMultiset\n⊢ Iff (Dvd.dvd u.prod v.prod) (LE.le u v)","decl":"theorem prod_dvd_iff {u v : PrimeMultiset} : u.prod ∣ v.prod ↔ u ≤ v := by\n  let h := @PNat.factorMultiset_le_iff' u.prod v\n  rw [u.factorMultiset_prod] at h\n  exact h.symm\n\n"}
{"name":"PrimeMultiset.prod_dvd_iff'","module":"Mathlib.Data.PNat.Factors","initialProofState":"u : PrimeMultiset\nn : PNat\n⊢ Iff (Dvd.dvd u.prod n) (LE.le u n.factorMultiset)","decl":"theorem prod_dvd_iff' {u : PrimeMultiset} {n : ℕ+} : u.prod ∣ n ↔ u ≤ n.factorMultiset := by\n  let h := @prod_dvd_iff u n.factorMultiset\n  rw [n.prod_factorMultiset] at h\n  exact h\n\n"}
{"name":"PNat.factorMultiset_gcd","module":"Mathlib.Data.PNat.Factors","initialProofState":"m n : PNat\n⊢ Eq (m.gcd n).factorMultiset (Min.min m.factorMultiset n.factorMultiset)","decl":"/-- The gcd and lcm operations on positive integers correspond\n to the inf and sup operations on multisets. -/\ntheorem factorMultiset_gcd (m n : ℕ+) :\n    factorMultiset (gcd m n) = factorMultiset m ⊓ factorMultiset n := by\n  apply le_antisymm\n  · apply le_inf_iff.mpr; constructor <;> apply factorMultiset_le_iff.mpr\n    · exact gcd_dvd_left m n\n    · exact gcd_dvd_right m n\n  · rw [← PrimeMultiset.prod_dvd_iff, prod_factorMultiset]\n    apply dvd_gcd <;> rw [PrimeMultiset.prod_dvd_iff']\n    · exact inf_le_left\n    · exact inf_le_right\n\n"}
{"name":"PNat.factorMultiset_lcm","module":"Mathlib.Data.PNat.Factors","initialProofState":"m n : PNat\n⊢ Eq (m.lcm n).factorMultiset (Max.max m.factorMultiset n.factorMultiset)","decl":"theorem factorMultiset_lcm (m n : ℕ+) :\n    factorMultiset (lcm m n) = factorMultiset m ⊔ factorMultiset n := by\n  apply le_antisymm\n  · rw [← PrimeMultiset.prod_dvd_iff, prod_factorMultiset]\n    apply lcm_dvd <;> rw [← factorMultiset_le_iff']\n    · exact le_sup_left\n    · exact le_sup_right\n  · apply sup_le_iff.mpr; constructor <;> apply factorMultiset_le_iff.mpr\n    · exact dvd_lcm_left m n\n    · exact dvd_lcm_right m n\n\n"}
{"name":"PNat.count_factorMultiset","module":"Mathlib.Data.PNat.Factors","initialProofState":"m : PNat\np : Nat.Primes\nk : Nat\n⊢ Iff (Dvd.dvd (HPow.hPow (↑p) k) m) (LE.le k (Multiset.count p m.factorMultiset))","decl":"/-- The number of occurrences of p in the factor multiset of m\n is the same as the p-adic valuation of m. -/\ntheorem count_factorMultiset (m : ℕ+) (p : Nat.Primes) (k : ℕ) :\n    (p : ℕ+) ^ k ∣ m ↔ k ≤ m.factorMultiset.count p := by\n  rw [Multiset.le_count_iff_replicate_le, ← factorMultiset_le_iff, factorMultiset_pow,\n    factorMultiset_ofPrime]\n  congr! 2\n  apply Multiset.eq_replicate.mpr\n  constructor\n  · rw [Multiset.card_nsmul, PrimeMultiset.card_ofPrime, mul_one]\n  · intro q h\n    rw [PrimeMultiset.ofPrime, Multiset.nsmul_singleton _ k] at h\n    exact Multiset.eq_of_mem_replicate h\n\n"}
{"name":"PrimeMultiset.prod_inf","module":"Mathlib.Data.PNat.Factors","initialProofState":"u v : PrimeMultiset\n⊢ Eq (Min.min u v).prod (u.prod.gcd v.prod)","decl":"theorem prod_inf (u v : PrimeMultiset) : (u ⊓ v).prod = PNat.gcd u.prod v.prod := by\n  let n := u.prod\n  let m := v.prod\n  change (u ⊓ v).prod = PNat.gcd n m\n  have : u = n.factorMultiset := u.factorMultiset_prod.symm; rw [this]\n  have : v = m.factorMultiset := v.factorMultiset_prod.symm; rw [this]\n  rw [← PNat.factorMultiset_gcd n m, PNat.prod_factorMultiset]\n\n"}
{"name":"PrimeMultiset.prod_sup","module":"Mathlib.Data.PNat.Factors","initialProofState":"u v : PrimeMultiset\n⊢ Eq (Max.max u v).prod (u.prod.lcm v.prod)","decl":"theorem prod_sup (u v : PrimeMultiset) : (u ⊔ v).prod = PNat.lcm u.prod v.prod := by\n  let n := u.prod\n  let m := v.prod\n  change (u ⊔ v).prod = PNat.lcm n m\n  have : u = n.factorMultiset := u.factorMultiset_prod.symm; rw [this]\n  have : v = m.factorMultiset := v.factorMultiset_prod.symm; rw [this]\n  rw [← PNat.factorMultiset_lcm n m, PNat.prod_factorMultiset]\n\n"}
