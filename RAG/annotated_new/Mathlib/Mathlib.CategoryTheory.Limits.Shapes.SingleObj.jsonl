{"name":"CategoryTheory.Limits.SingleObj.Types.sections.equivFixedPoints_apply_coe","module":"Mathlib.CategoryTheory.Limits.Shapes.SingleObj","initialProofState":"M : Type v\ninst✝ : Monoid M\nJ : CategoryTheory.Functor (CategoryTheory.SingleObj M) (Type u)\ns : ↑J.sections\n⊢ Eq (↑((CategoryTheory.Limits.SingleObj.Types.sections.equivFixedPoints J) s)) (↑s (CategoryTheory.SingleObj.star M))","decl":"/-- The equivalence between sections of `J : SingleObj M ⥤ Type u` and fixed points of the\ninduced action on `J.obj (SingleObj.star M)`. -/\n@[simps]\ndef Types.sections.equivFixedPoints :\n    J.sections ≃ MulAction.fixedPoints M (J.obj (SingleObj.star M)) where\n  toFun s := ⟨s.val _, s.property⟩\n  invFun p := ⟨fun _ ↦ p.val, p.property⟩\n  left_inv _ := rfl\n  right_inv _ := rfl\n\n"}
{"name":"CategoryTheory.Limits.SingleObj.Types.sections.equivFixedPoints_symm_apply_coe","module":"Mathlib.CategoryTheory.Limits.Shapes.SingleObj","initialProofState":"M : Type v\ninst✝ : Monoid M\nJ : CategoryTheory.Functor (CategoryTheory.SingleObj M) (Type u)\np : ↑(MulAction.fixedPoints M (J.obj (CategoryTheory.SingleObj.star M)))\nx✝ : CategoryTheory.SingleObj M\n⊢ Eq (↑((CategoryTheory.Limits.SingleObj.Types.sections.equivFixedPoints J).symm p) x✝) ↑p","decl":"/-- The equivalence between sections of `J : SingleObj M ⥤ Type u` and fixed points of the\ninduced action on `J.obj (SingleObj.star M)`. -/\n@[simps]\ndef Types.sections.equivFixedPoints :\n    J.sections ≃ MulAction.fixedPoints M (J.obj (SingleObj.star M)) where\n  toFun s := ⟨s.val _, s.property⟩\n  invFun p := ⟨fun _ ↦ p.val, p.property⟩\n  left_inv _ := rfl\n  right_inv _ := rfl\n\n"}
{"name":"CategoryTheory.Limits.SingleObj.Types.limitEquivFixedPoints_symm_apply","module":"Mathlib.CategoryTheory.Limits.Shapes.SingleObj","initialProofState":"M : Type v\ninst✝ : Monoid M\nJ : CategoryTheory.Functor (CategoryTheory.SingleObj M) (Type u)\na✝ : ↑(MulAction.fixedPoints M (J.obj (CategoryTheory.SingleObj.star M)))\n⊢ Eq ((CategoryTheory.Limits.SingleObj.Types.limitEquivFixedPoints J).symm a✝) ((CategoryTheory.Limits.Types.limitEquivSections J).symm ((CategoryTheory.Limits.SingleObj.Types.sections.equivFixedPoints J).symm a✝))","decl":"/-- The limit of `J : SingleObj M ⥤ Type u` is equivalent to the fixed points of the\ninduced action on `J.obj (SingleObj.star M)`. -/\n@[simps!]\nnoncomputable def Types.limitEquivFixedPoints :\n    limit J ≃ MulAction.fixedPoints M (J.obj (SingleObj.star M)) :=\n  (Types.limitEquivSections J).trans (Types.sections.equivFixedPoints J)\n\n"}
{"name":"CategoryTheory.Limits.SingleObj.Types.limitEquivFixedPoints_apply_coe","module":"Mathlib.CategoryTheory.Limits.Shapes.SingleObj","initialProofState":"M : Type v\ninst✝ : Monoid M\nJ : CategoryTheory.Functor (CategoryTheory.SingleObj M) (Type u)\na✝ : CategoryTheory.Limits.limit J\n⊢ Eq (↑((CategoryTheory.Limits.SingleObj.Types.limitEquivFixedPoints J) a✝)) (CategoryTheory.Limits.limit.π J (CategoryTheory.SingleObj.star M) a✝)","decl":"/-- The limit of `J : SingleObj M ⥤ Type u` is equivalent to the fixed points of the\ninduced action on `J.obj (SingleObj.star M)`. -/\n@[simps!]\nnoncomputable def Types.limitEquivFixedPoints :\n    limit J ≃ MulAction.fixedPoints M (J.obj (SingleObj.star M)) :=\n  (Types.limitEquivSections J).trans (Types.sections.equivFixedPoints J)\n\n"}
{"name":"CategoryTheory.Limits.SingleObj.Types.Quot.Rel.iff_orbitRel","module":"Mathlib.CategoryTheory.Limits.Shapes.SingleObj","initialProofState":"G : Type v\ninst✝ : Group G\nJ : CategoryTheory.Functor (CategoryTheory.SingleObj G) (Type u)\nx y : J.obj (CategoryTheory.SingleObj.star G)\n⊢ Iff (CategoryTheory.Limits.Types.Quot.Rel J ⟨CategoryTheory.SingleObj.star G, x⟩ ⟨CategoryTheory.SingleObj.star G, y⟩) ((MulAction.orbitRel G (J.obj (CategoryTheory.SingleObj.star G))) x y)","decl":"/-- The relation used to construct colimits in types for `J : SingleObj G ⥤ Type u` is\nequivalent to the `MulAction.orbitRel` equivalence relation on `J.obj (SingleObj.star G)`. -/\nlemma Types.Quot.Rel.iff_orbitRel (x y : J.obj (SingleObj.star G)) :\n    Types.Quot.Rel J ⟨SingleObj.star G, x⟩ ⟨SingleObj.star G, y⟩\n    ↔ MulAction.orbitRel G (J.obj (SingleObj.star G)) x y := by\n  have h (g : G) : y = g • x ↔ g • x = y := ⟨symm, symm⟩\n  conv => rhs; rw [Setoid.comm']\n  show (∃ g : G, y = g • x) ↔ (∃ g : G, g • x = y)\n  conv => lhs; simp only [h]\n\n"}
{"name":"CategoryTheory.Limits.SingleObj.Types.Quot.equivOrbitRelQuotient_apply","module":"Mathlib.CategoryTheory.Limits.Shapes.SingleObj","initialProofState":"G : Type v\ninst✝ : Group G\nJ : CategoryTheory.Functor (CategoryTheory.SingleObj G) (Type u)\na : Quot (CategoryTheory.Limits.Types.Quot.Rel J)\n⊢ Eq ((CategoryTheory.Limits.SingleObj.Types.Quot.equivOrbitRelQuotient J) a) (Quot.lift (fun p => Quotient.mk (MulAction.orbitRel G (J.obj (CategoryTheory.SingleObj.star G))) p.snd) ⋯ a)","decl":"/-- The explicit quotient construction of the colimit of `J : SingleObj G ⥤ Type u` is\nequivalent to the quotient of `J.obj (SingleObj.star G)` by the induced action. -/\n@[simps]\ndef Types.Quot.equivOrbitRelQuotient :\n    Types.Quot J ≃ MulAction.orbitRel.Quotient G (J.obj (SingleObj.star G)) where\n  toFun := Quot.lift (fun p => ⟦p.2⟧) <| fun a b h => Quotient.sound <|\n    (Types.Quot.Rel.iff_orbitRel J a.2 b.2).mp h\n  invFun := Quot.lift (fun x => Quot.mk _ ⟨SingleObj.star G, x⟩) <| fun a b h =>\n    Quot.sound <| (Types.Quot.Rel.iff_orbitRel J a b).mpr h\n  left_inv := fun x => Quot.inductionOn x (fun _ ↦ rfl)\n  right_inv := fun x => Quot.inductionOn x (fun _ ↦ rfl)\n\n"}
{"name":"CategoryTheory.Limits.SingleObj.Types.Quot.equivOrbitRelQuotient_symm_apply","module":"Mathlib.CategoryTheory.Limits.Shapes.SingleObj","initialProofState":"G : Type v\ninst✝ : Group G\nJ : CategoryTheory.Functor (CategoryTheory.SingleObj G) (Type u)\na : Quot ⇑(MulAction.orbitRel G (J.obj (CategoryTheory.SingleObj.star G)))\n⊢ Eq ((CategoryTheory.Limits.SingleObj.Types.Quot.equivOrbitRelQuotient J).symm a) (Quot.lift (fun x => Quot.mk (CategoryTheory.Limits.Types.Quot.Rel J) ⟨CategoryTheory.SingleObj.star G, x⟩) ⋯ a)","decl":"/-- The explicit quotient construction of the colimit of `J : SingleObj G ⥤ Type u` is\nequivalent to the quotient of `J.obj (SingleObj.star G)` by the induced action. -/\n@[simps]\ndef Types.Quot.equivOrbitRelQuotient :\n    Types.Quot J ≃ MulAction.orbitRel.Quotient G (J.obj (SingleObj.star G)) where\n  toFun := Quot.lift (fun p => ⟦p.2⟧) <| fun a b h => Quotient.sound <|\n    (Types.Quot.Rel.iff_orbitRel J a.2 b.2).mp h\n  invFun := Quot.lift (fun x => Quot.mk _ ⟨SingleObj.star G, x⟩) <| fun a b h =>\n    Quot.sound <| (Types.Quot.Rel.iff_orbitRel J a b).mpr h\n  left_inv := fun x => Quot.inductionOn x (fun _ ↦ rfl)\n  right_inv := fun x => Quot.inductionOn x (fun _ ↦ rfl)\n\n"}
{"name":"CategoryTheory.Limits.SingleObj.Types.colimitEquivQuotient_apply","module":"Mathlib.CategoryTheory.Limits.Shapes.SingleObj","initialProofState":"G : Type v\ninst✝ : Group G\nJ : CategoryTheory.Functor (CategoryTheory.SingleObj G) (Type u)\na✝ : CategoryTheory.Limits.colimit J\n⊢ Eq ((CategoryTheory.Limits.SingleObj.Types.colimitEquivQuotient J) a✝) (Quot.lift (fun p => Quotient.mk (MulAction.orbitRel G (J.obj (CategoryTheory.SingleObj.star G))) p.snd) ⋯ ((CategoryTheory.Limits.Types.colimitEquivQuot J) a✝))","decl":"/-- The colimit of `J : SingleObj G ⥤ Type u` is equivalent to the quotient of\n`J.obj (SingleObj.star G)` by the induced action. -/\n@[simps!]\nnoncomputable def Types.colimitEquivQuotient :\n    colimit J ≃ MulAction.orbitRel.Quotient G (J.obj (SingleObj.star G)) :=\n  (Types.colimitEquivQuot J).trans (Types.Quot.equivOrbitRelQuotient J)\n\n"}
{"name":"CategoryTheory.Limits.SingleObj.Types.colimitEquivQuotient_symm_apply","module":"Mathlib.CategoryTheory.Limits.Shapes.SingleObj","initialProofState":"G : Type v\ninst✝ : Group G\nJ : CategoryTheory.Functor (CategoryTheory.SingleObj G) (Type u)\na✝ : MulAction.orbitRel.Quotient G (J.obj (CategoryTheory.SingleObj.star G))\n⊢ Eq ((CategoryTheory.Limits.SingleObj.Types.colimitEquivQuotient J).symm a✝) ((CategoryTheory.Limits.Types.colimitEquivQuot J).symm (Quot.lift (fun x => Quot.mk (CategoryTheory.Limits.Types.Quot.Rel J) ⟨CategoryTheory.SingleObj.star G, x⟩) ⋯ a✝))","decl":"/-- The colimit of `J : SingleObj G ⥤ Type u` is equivalent to the quotient of\n`J.obj (SingleObj.star G)` by the induced action. -/\n@[simps!]\nnoncomputable def Types.colimitEquivQuotient :\n    colimit J ≃ MulAction.orbitRel.Quotient G (J.obj (SingleObj.star G)) :=\n  (Types.colimitEquivQuot J).trans (Types.Quot.equivOrbitRelQuotient J)\n\n"}
