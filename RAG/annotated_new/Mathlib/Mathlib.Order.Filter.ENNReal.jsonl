{"name":"ENNReal.eventually_le_limsup","module":"Mathlib.Order.Filter.ENNReal","initialProofState":"α : Type u_1\nf : Filter α\ninst✝ : CountableInterFilter f\nu : α → ENNReal\n⊢ Filter.Eventually (fun y => LE.le (u y) (Filter.limsup u f)) f","decl":"theorem eventually_le_limsup [CountableInterFilter f] (u : α → ℝ≥0∞) :\n    ∀ᶠ y in f, u y ≤ f.limsup u :=\n  _root_.eventually_le_limsup\n\n"}
{"name":"ENNReal.limsup_eq_zero_iff","module":"Mathlib.Order.Filter.ENNReal","initialProofState":"α : Type u_1\nf : Filter α\ninst✝ : CountableInterFilter f\nu : α → ENNReal\n⊢ Iff (Eq (Filter.limsup u f) 0) (f.EventuallyEq u 0)","decl":"theorem limsup_eq_zero_iff [CountableInterFilter f] {u : α → ℝ≥0∞} :\n    f.limsup u = 0 ↔ u =ᶠ[f] 0 :=\n  limsup_eq_bot\n\n"}
{"name":"ENNReal.limsup_const_mul_of_ne_top","module":"Mathlib.Order.Filter.ENNReal","initialProofState":"α : Type u_1\nf : Filter α\nu : α → ENNReal\na : ENNReal\nha_top : Ne a Top.top\n⊢ Eq (Filter.limsup (fun x => HMul.hMul a (u x)) f) (HMul.hMul a (Filter.limsup u f))","decl":"theorem limsup_const_mul_of_ne_top {u : α → ℝ≥0∞} {a : ℝ≥0∞} (ha_top : a ≠ ⊤) :\n    (f.limsup fun x : α => a * u x) = a * f.limsup u := by\n  by_cases ha_zero : a = 0\n  · simp_rw [ha_zero, zero_mul, ← ENNReal.bot_eq_zero]\n    exact limsup_const_bot\n  let g := fun x : ℝ≥0∞ => a * x\n  have hg_bij : Function.Bijective g :=\n    Function.bijective_iff_has_inverse.mpr\n      ⟨fun x => a⁻¹ * x,\n        ⟨fun x => by simp [g, ← mul_assoc, ENNReal.inv_mul_cancel ha_zero ha_top], fun x => by\n          simp [g, ← mul_assoc, ENNReal.mul_inv_cancel ha_zero ha_top]⟩⟩\n  have hg_mono : StrictMono g :=\n    Monotone.strictMono_of_injective (fun _ _ _ => by rwa [mul_le_mul_left ha_zero ha_top]) hg_bij.1\n  let g_iso := StrictMono.orderIsoOfSurjective g hg_mono hg_bij.2\n  exact (OrderIso.limsup_apply g_iso).symm\n\n"}
{"name":"ENNReal.limsup_const_mul","module":"Mathlib.Order.Filter.ENNReal","initialProofState":"α : Type u_1\nf : Filter α\ninst✝ : CountableInterFilter f\nu : α → ENNReal\na : ENNReal\n⊢ Eq (Filter.limsup (fun x => HMul.hMul a (u x)) f) (HMul.hMul a (Filter.limsup u f))","decl":"theorem limsup_const_mul [CountableInterFilter f] {u : α → ℝ≥0∞} {a : ℝ≥0∞} :\n    f.limsup (a * u ·) = a * f.limsup u := by\n  by_cases ha_top : a ≠ ⊤\n  · exact limsup_const_mul_of_ne_top ha_top\n  push_neg at ha_top\n  by_cases hu : u =ᶠ[f] 0\n  · have hau : (a * u ·) =ᶠ[f] 0 := hu.mono fun x hx => by simp [hx]\n    simp only [limsup_congr hu, limsup_congr hau, Pi.zero_def, ← ENNReal.bot_eq_zero,\n      limsup_const_bot]\n    simp\n  · have hu_mul : ∃ᶠ x : α in f, ⊤ ≤ ite (u x = 0) (0 : ℝ≥0∞) ⊤ := by\n      rw [EventuallyEq, not_eventually] at hu\n      refine hu.mono fun x hx => ?_\n      rw [Pi.zero_apply] at hx\n      simp [hx]\n    have h_top_le : (f.limsup fun x : α => ite (u x = 0) (0 : ℝ≥0∞) ⊤) = ⊤ :=\n      eq_top_iff.mpr (le_limsup_of_frequently_le hu_mul)\n    have hfu : f.limsup u ≠ 0 := mt limsup_eq_zero_iff.1 hu\n    simp only [ha_top, top_mul', h_top_le, hfu, ite_false]\n\n"}
{"name":"ENNReal.limsup_mul_le","module":"Mathlib.Order.Filter.ENNReal","initialProofState":"α : Type u_1\nf : Filter α\ninst✝ : CountableInterFilter f\nu v : α → ENNReal\n⊢ LE.le (Filter.limsup (HMul.hMul u v) f) (HMul.hMul (Filter.limsup u f) (Filter.limsup v f))","decl":"/-- See also `limsup_mul_le'`.-/\ntheorem limsup_mul_le [CountableInterFilter f] (u v : α → ℝ≥0∞) :\n    f.limsup (u * v) ≤ f.limsup u * f.limsup v :=\n  calc\n    f.limsup (u * v) ≤ f.limsup fun x => f.limsup u * v x := by\n      refine limsup_le_limsup ?_\n      filter_upwards [@eventually_le_limsup _ f _ u] with x hx using mul_le_mul' hx le_rfl\n    _ = f.limsup u * f.limsup v := limsup_const_mul\n\n"}
{"name":"ENNReal.limsup_add_le","module":"Mathlib.Order.Filter.ENNReal","initialProofState":"α : Type u_1\nf : Filter α\ninst✝ : CountableInterFilter f\nu v : α → ENNReal\n⊢ LE.le (Filter.limsup (HAdd.hAdd u v) f) (HAdd.hAdd (Filter.limsup u f) (Filter.limsup v f))","decl":"theorem limsup_add_le [CountableInterFilter f] (u v : α → ℝ≥0∞) :\n    f.limsup (u + v) ≤ f.limsup u + f.limsup v :=\n  sInf_le ((eventually_le_limsup u).mp\n    ((eventually_le_limsup v).mono fun _ hxg hxf => add_le_add hxf hxg))\n\n"}
{"name":"ENNReal.limsup_liminf_le_liminf_limsup","module":"Mathlib.Order.Filter.ENNReal","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Countable β\nf : Filter α\ninst✝ : CountableInterFilter f\ng : Filter β\nu : α → β → ENNReal\n⊢ LE.le (Filter.limsup (fun a => Filter.liminf (fun b => u a b) g) f) (Filter.liminf (fun b => Filter.limsup (fun a => u a b) f) g)","decl":"theorem limsup_liminf_le_liminf_limsup {β} [Countable β] {f : Filter α} [CountableInterFilter f]\n    {g : Filter β} (u : α → β → ℝ≥0∞) :\n    (f.limsup fun a : α => g.liminf fun b : β => u a b) ≤\n      g.liminf fun b => f.limsup fun a => u a b :=\n  have h1 : ∀ᶠ a in f, ∀ b, u a b ≤ f.limsup fun a' => u a' b := by\n    rw [eventually_countable_forall]\n    exact fun b => ENNReal.eventually_le_limsup fun a => u a b\n  sInf_le <| h1.mono fun x hx => Filter.liminf_le_liminf (Filter.Eventually.of_forall hx)\n\n"}
