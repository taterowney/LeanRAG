{"name":"MeasureTheory.Measure.restrictₗ_apply","module":"Mathlib.MeasureTheory.Measure.Restrict","initialProofState":"α : Type u_2\n_m0 : MeasurableSpace α\ns : Set α\nμ : MeasureTheory.Measure α\n⊢ Eq ((MeasureTheory.Measure.restrictₗ s) μ) (μ.restrict s)","decl":"@[simp]\ntheorem restrictₗ_apply {_m0 : MeasurableSpace α} (s : Set α) (μ : Measure α) :\n    restrictₗ s μ = μ.restrict s :=\n  rfl\n\n"}
{"name":"MeasureTheory.Measure.restrict_toOuterMeasure_eq_toOuterMeasure_restrict","module":"Mathlib.MeasureTheory.Measure.Restrict","initialProofState":"α : Type u_2\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : Set α\nh : MeasurableSet s\n⊢ Eq (μ.restrict s).toOuterMeasure ((MeasureTheory.OuterMeasure.restrict s) μ.toOuterMeasure)","decl":"/-- This lemma shows that `restrict` and `toOuterMeasure` commute. Note that the LHS has a\nrestrict on measures and the RHS has a restrict on outer measures. -/\ntheorem restrict_toOuterMeasure_eq_toOuterMeasure_restrict (h : MeasurableSet s) :\n    (μ.restrict s).toOuterMeasure = OuterMeasure.restrict s μ.toOuterMeasure := by\n  simp_rw [restrict, restrictₗ, liftLinear, LinearMap.coe_mk, AddHom.coe_mk,\n    toMeasure_toOuterMeasure, OuterMeasure.restrict_trim h, μ.trimmed]\n\n"}
{"name":"MeasureTheory.Measure.restrict_apply₀","module":"Mathlib.MeasureTheory.Measure.Restrict","initialProofState":"α : Type u_2\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns t : Set α\nht : MeasureTheory.NullMeasurableSet t (μ.restrict s)\n⊢ Eq ((μ.restrict s) t) (μ (Inter.inter t s))","decl":"theorem restrict_apply₀ (ht : NullMeasurableSet t (μ.restrict s)) : μ.restrict s t = μ (t ∩ s) := by\n  rw [← restrictₗ_apply, restrictₗ, liftLinear_apply₀ _ ht, OuterMeasure.restrict_apply,\n    coe_toOuterMeasure]\n\n"}
{"name":"MeasureTheory.Measure.restrict_apply","module":"Mathlib.MeasureTheory.Measure.Restrict","initialProofState":"α : Type u_2\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns t : Set α\nht : MeasurableSet t\n⊢ Eq ((μ.restrict s) t) (μ (Inter.inter t s))","decl":"/-- If `t` is a measurable set, then the measure of `t` with respect to the restriction of\n  the measure to `s` equals the outer measure of `t ∩ s`. An alternate version requiring that `s`\n  be measurable instead of `t` exists as `Measure.restrict_apply'`. -/\n@[simp]\ntheorem restrict_apply (ht : MeasurableSet t) : μ.restrict s t = μ (t ∩ s) :=\n  restrict_apply₀ ht.nullMeasurableSet\n\n"}
{"name":"MeasureTheory.Measure.restrict_mono'","module":"Mathlib.MeasureTheory.Measure.Restrict","initialProofState":"α : Type u_2\n_m0 : MeasurableSpace α\ns s' : Set α\nμ ν : MeasureTheory.Measure α\nhs : (MeasureTheory.ae μ).EventuallyLE s s'\nhμν : LE.le μ ν\n⊢ LE.le (μ.restrict s) (ν.restrict s')","decl":"/-- Restriction of a measure to a subset is monotone both in set and in measure. -/\ntheorem restrict_mono' {_m0 : MeasurableSpace α} ⦃s s' : Set α⦄ ⦃μ ν : Measure α⦄ (hs : s ≤ᵐ[μ] s')\n    (hμν : μ ≤ ν) : μ.restrict s ≤ ν.restrict s' :=\n  Measure.le_iff.2 fun t ht => calc\n    μ.restrict s t = μ (t ∩ s) := restrict_apply ht\n    _ ≤ μ (t ∩ s') := (measure_mono_ae <| hs.mono fun _x hx ⟨hxt, hxs⟩ => ⟨hxt, hx hxs⟩)\n    _ ≤ ν (t ∩ s') := le_iff'.1 hμν (t ∩ s')\n    _ = ν.restrict s' t := (restrict_apply ht).symm\n\n"}
{"name":"MeasureTheory.Measure.restrict_mono","module":"Mathlib.MeasureTheory.Measure.Restrict","initialProofState":"α : Type u_2\n_m0 : MeasurableSpace α\ns s' : Set α\nhs : HasSubset.Subset s s'\nμ ν : MeasureTheory.Measure α\nhμν : LE.le μ ν\n⊢ LE.le (μ.restrict s) (ν.restrict s')","decl":"/-- Restriction of a measure to a subset is monotone both in set and in measure. -/\n@[mono, gcongr]\ntheorem restrict_mono {_m0 : MeasurableSpace α} ⦃s s' : Set α⦄ (hs : s ⊆ s') ⦃μ ν : Measure α⦄\n    (hμν : μ ≤ ν) : μ.restrict s ≤ ν.restrict s' :=\n  restrict_mono' (ae_of_all _ hs) hμν\n\n"}
{"name":"MeasureTheory.Measure.restrict_mono_measure","module":"Mathlib.MeasureTheory.Measure.Restrict","initialProofState":"α : Type u_2\nx✝ : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\nh : LE.le μ ν\ns : Set α\n⊢ LE.le (μ.restrict s) (ν.restrict s)","decl":"@[gcongr]\ntheorem restrict_mono_measure {_ : MeasurableSpace α} {μ ν : Measure α} (h : μ ≤ ν) (s : Set α) :\n    μ.restrict s ≤ ν.restrict s :=\n  restrict_mono subset_rfl h\n\n"}
{"name":"MeasureTheory.Measure.restrict_mono_set","module":"Mathlib.MeasureTheory.Measure.Restrict","initialProofState":"α : Type u_2\nx✝ : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns t : Set α\nh : HasSubset.Subset s t\n⊢ LE.le (μ.restrict s) (μ.restrict t)","decl":"@[gcongr]\ntheorem restrict_mono_set {_ : MeasurableSpace α} (μ : Measure α) {s t : Set α} (h : s ⊆ t) :\n    μ.restrict s ≤ μ.restrict t :=\n  restrict_mono h le_rfl\n\n"}
{"name":"MeasureTheory.Measure.restrict_mono_ae","module":"Mathlib.MeasureTheory.Measure.Restrict","initialProofState":"α : Type u_2\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns t : Set α\nh : (MeasureTheory.ae μ).EventuallyLE s t\n⊢ LE.le (μ.restrict s) (μ.restrict t)","decl":"theorem restrict_mono_ae (h : s ≤ᵐ[μ] t) : μ.restrict s ≤ μ.restrict t :=\n  restrict_mono' h (le_refl μ)\n\n"}
{"name":"MeasureTheory.Measure.restrict_congr_set","module":"Mathlib.MeasureTheory.Measure.Restrict","initialProofState":"α : Type u_2\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns t : Set α\nh : (MeasureTheory.ae μ).EventuallyEq s t\n⊢ Eq (μ.restrict s) (μ.restrict t)","decl":"theorem restrict_congr_set (h : s =ᵐ[μ] t) : μ.restrict s = μ.restrict t :=\n  le_antisymm (restrict_mono_ae h.le) (restrict_mono_ae h.symm.le)\n\n"}
{"name":"MeasureTheory.Measure.restrict_apply'","module":"Mathlib.MeasureTheory.Measure.Restrict","initialProofState":"α : Type u_2\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns t : Set α\nhs : MeasurableSet s\n⊢ Eq ((μ.restrict s) t) (μ (Inter.inter t s))","decl":"/-- If `s` is a measurable set, then the outer measure of `t` with respect to the restriction of\nthe measure to `s` equals the outer measure of `t ∩ s`. This is an alternate version of\n`Measure.restrict_apply`, requiring that `s` is measurable instead of `t`. -/\n@[simp]\ntheorem restrict_apply' (hs : MeasurableSet s) : μ.restrict s t = μ (t ∩ s) := by\n  rw [← toOuterMeasure_apply,\n    Measure.restrict_toOuterMeasure_eq_toOuterMeasure_restrict hs,\n    OuterMeasure.restrict_apply s t _, toOuterMeasure_apply]\n\n"}
{"name":"MeasureTheory.Measure.restrict_apply₀'","module":"Mathlib.MeasureTheory.Measure.Restrict","initialProofState":"α : Type u_2\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns t : Set α\nhs : MeasureTheory.NullMeasurableSet s μ\n⊢ Eq ((μ.restrict s) t) (μ (Inter.inter t s))","decl":"theorem restrict_apply₀' (hs : NullMeasurableSet s μ) : μ.restrict s t = μ (t ∩ s) := by\n  rw [← restrict_congr_set hs.toMeasurable_ae_eq,\n    restrict_apply' (measurableSet_toMeasurable _ _),\n    measure_congr ((ae_eq_refl t).inter hs.toMeasurable_ae_eq)]\n\n"}
{"name":"MeasureTheory.Measure.restrict_le_self","module":"Mathlib.MeasureTheory.Measure.Restrict","initialProofState":"α : Type u_2\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : Set α\n⊢ LE.le (μ.restrict s) μ","decl":"theorem restrict_le_self : μ.restrict s ≤ μ :=\n  Measure.le_iff.2 fun t ht => calc\n    μ.restrict s t = μ (t ∩ s) := restrict_apply ht\n    _ ≤ μ t := measure_mono inter_subset_left\n\n"}
{"name":"MeasureTheory.Measure.restrict_eq_self","module":"Mathlib.MeasureTheory.Measure.Restrict","initialProofState":"α : Type u_2\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns t : Set α\nh : HasSubset.Subset s t\n⊢ Eq ((μ.restrict t) s) (μ s)","decl":"theorem restrict_eq_self (h : s ⊆ t) : μ.restrict t s = μ s :=\n  (le_iff'.1 restrict_le_self s).antisymm <|\n    calc\n      μ s ≤ μ (toMeasurable (μ.restrict t) s ∩ t) :=\n        measure_mono (subset_inter (subset_toMeasurable _ _) h)\n      _ = μ.restrict t s := by\n        rw [← restrict_apply (measurableSet_toMeasurable _ _), measure_toMeasurable]\n\n"}
{"name":"MeasureTheory.Measure.restrict_apply_self","module":"Mathlib.MeasureTheory.Measure.Restrict","initialProofState":"α : Type u_2\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : Set α\n⊢ Eq ((μ.restrict s) s) (μ s)","decl":"@[simp]\ntheorem restrict_apply_self (s : Set α) : (μ.restrict s) s = μ s :=\n  restrict_eq_self μ Subset.rfl\n\n"}
{"name":"MeasureTheory.Measure.restrict_apply_univ","module":"Mathlib.MeasureTheory.Measure.Restrict","initialProofState":"α : Type u_2\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : Set α\n⊢ Eq ((μ.restrict s) Set.univ) (μ s)","decl":"theorem restrict_apply_univ (s : Set α) : μ.restrict s univ = μ s := by\n  rw [restrict_apply MeasurableSet.univ, Set.univ_inter]\n\n"}
{"name":"MeasureTheory.Measure.le_restrict_apply","module":"Mathlib.MeasureTheory.Measure.Restrict","initialProofState":"α : Type u_2\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns t : Set α\n⊢ LE.le (μ (Inter.inter t s)) ((μ.restrict s) t)","decl":"theorem le_restrict_apply (s t : Set α) : μ (t ∩ s) ≤ μ.restrict s t :=\n  calc\n    μ (t ∩ s) = μ.restrict s (t ∩ s) := (restrict_eq_self μ inter_subset_right).symm\n    _ ≤ μ.restrict s t := measure_mono inter_subset_left\n\n"}
{"name":"MeasureTheory.Measure.restrict_apply_le","module":"Mathlib.MeasureTheory.Measure.Restrict","initialProofState":"α : Type u_2\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns t : Set α\n⊢ LE.le ((μ.restrict s) t) (μ t)","decl":"theorem restrict_apply_le (s t : Set α) : μ.restrict s t ≤ μ t :=\n  Measure.le_iff'.1 restrict_le_self _\n\n"}
{"name":"MeasureTheory.Measure.restrict_apply_superset","module":"Mathlib.MeasureTheory.Measure.Restrict","initialProofState":"α : Type u_2\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns t : Set α\nh : HasSubset.Subset s t\n⊢ Eq ((μ.restrict s) t) (μ s)","decl":"theorem restrict_apply_superset (h : s ⊆ t) : μ.restrict s t = μ s :=\n  ((measure_mono (subset_univ _)).trans_eq <| restrict_apply_univ _).antisymm\n    ((restrict_apply_self μ s).symm.trans_le <| measure_mono h)\n\n"}
{"name":"MeasureTheory.Measure.restrict_add","module":"Mathlib.MeasureTheory.Measure.Restrict","initialProofState":"α : Type u_2\n_m0 : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\ns : Set α\n⊢ Eq ((HAdd.hAdd μ ν).restrict s) (HAdd.hAdd (μ.restrict s) (ν.restrict s))","decl":"@[simp]\ntheorem restrict_add {_m0 : MeasurableSpace α} (μ ν : Measure α) (s : Set α) :\n    (μ + ν).restrict s = μ.restrict s + ν.restrict s :=\n  (restrictₗ s).map_add μ ν\n\n"}
{"name":"MeasureTheory.Measure.restrict_zero","module":"Mathlib.MeasureTheory.Measure.Restrict","initialProofState":"α : Type u_2\n_m0 : MeasurableSpace α\ns : Set α\n⊢ Eq (MeasureTheory.Measure.restrict 0 s) 0","decl":"@[simp]\ntheorem restrict_zero {_m0 : MeasurableSpace α} (s : Set α) : (0 : Measure α).restrict s = 0 :=\n  (restrictₗ s).map_zero\n\n"}
{"name":"MeasureTheory.Measure.restrict_smul","module":"Mathlib.MeasureTheory.Measure.Restrict","initialProofState":"α : Type u_2\n_m0 : MeasurableSpace α\nc : ENNReal\nμ : MeasureTheory.Measure α\ns : Set α\n⊢ Eq ((HSMul.hSMul c μ).restrict s) (HSMul.hSMul c (μ.restrict s))","decl":"@[simp]\ntheorem restrict_smul {_m0 : MeasurableSpace α} (c : ℝ≥0∞) (μ : Measure α) (s : Set α) :\n    (c • μ).restrict s = c • μ.restrict s :=\n  (restrictₗ s).map_smul c μ\n\n"}
{"name":"MeasureTheory.Measure.restrict_restrict₀","module":"Mathlib.MeasureTheory.Measure.Restrict","initialProofState":"α : Type u_2\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns t : Set α\nhs : MeasureTheory.NullMeasurableSet s (μ.restrict t)\n⊢ Eq ((μ.restrict t).restrict s) (μ.restrict (Inter.inter s t))","decl":"theorem restrict_restrict₀ (hs : NullMeasurableSet s (μ.restrict t)) :\n    (μ.restrict t).restrict s = μ.restrict (s ∩ t) :=\n  ext fun u hu => by\n    simp only [Set.inter_assoc, restrict_apply hu,\n      restrict_apply₀ (hu.nullMeasurableSet.inter hs)]\n\n"}
{"name":"MeasureTheory.Measure.restrict_restrict","module":"Mathlib.MeasureTheory.Measure.Restrict","initialProofState":"α : Type u_2\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns t : Set α\nhs : MeasurableSet s\n⊢ Eq ((μ.restrict t).restrict s) (μ.restrict (Inter.inter s t))","decl":"@[simp]\ntheorem restrict_restrict (hs : MeasurableSet s) : (μ.restrict t).restrict s = μ.restrict (s ∩ t) :=\n  restrict_restrict₀ hs.nullMeasurableSet\n\n"}
{"name":"MeasureTheory.Measure.restrict_restrict_of_subset","module":"Mathlib.MeasureTheory.Measure.Restrict","initialProofState":"α : Type u_2\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns t : Set α\nh : HasSubset.Subset s t\n⊢ Eq ((μ.restrict t).restrict s) (μ.restrict s)","decl":"theorem restrict_restrict_of_subset (h : s ⊆ t) : (μ.restrict t).restrict s = μ.restrict s := by\n  ext1 u hu\n  rw [restrict_apply hu, restrict_apply hu, restrict_eq_self]\n  exact inter_subset_right.trans h\n\n"}
{"name":"MeasureTheory.Measure.restrict_restrict₀'","module":"Mathlib.MeasureTheory.Measure.Restrict","initialProofState":"α : Type u_2\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns t : Set α\nht : MeasureTheory.NullMeasurableSet t μ\n⊢ Eq ((μ.restrict t).restrict s) (μ.restrict (Inter.inter s t))","decl":"theorem restrict_restrict₀' (ht : NullMeasurableSet t μ) :\n    (μ.restrict t).restrict s = μ.restrict (s ∩ t) :=\n  ext fun u hu => by simp only [restrict_apply hu, restrict_apply₀' ht, inter_assoc]\n\n"}
{"name":"MeasureTheory.Measure.restrict_restrict'","module":"Mathlib.MeasureTheory.Measure.Restrict","initialProofState":"α : Type u_2\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns t : Set α\nht : MeasurableSet t\n⊢ Eq ((μ.restrict t).restrict s) (μ.restrict (Inter.inter s t))","decl":"theorem restrict_restrict' (ht : MeasurableSet t) :\n    (μ.restrict t).restrict s = μ.restrict (s ∩ t) :=\n  restrict_restrict₀' ht.nullMeasurableSet\n\n"}
{"name":"MeasureTheory.Measure.restrict_comm","module":"Mathlib.MeasureTheory.Measure.Restrict","initialProofState":"α : Type u_2\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns t : Set α\nhs : MeasurableSet s\n⊢ Eq ((μ.restrict t).restrict s) ((μ.restrict s).restrict t)","decl":"theorem restrict_comm (hs : MeasurableSet s) :\n    (μ.restrict t).restrict s = (μ.restrict s).restrict t := by\n  rw [restrict_restrict hs, restrict_restrict' hs, inter_comm]\n\n"}
{"name":"MeasureTheory.Measure.restrict_apply_eq_zero","module":"Mathlib.MeasureTheory.Measure.Restrict","initialProofState":"α : Type u_2\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns t : Set α\nht : MeasurableSet t\n⊢ Iff (Eq ((μ.restrict s) t) 0) (Eq (μ (Inter.inter t s)) 0)","decl":"theorem restrict_apply_eq_zero (ht : MeasurableSet t) : μ.restrict s t = 0 ↔ μ (t ∩ s) = 0 := by\n  rw [restrict_apply ht]\n\n"}
{"name":"MeasureTheory.Measure.measure_inter_eq_zero_of_restrict","module":"Mathlib.MeasureTheory.Measure.Restrict","initialProofState":"α : Type u_2\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns t : Set α\nh : Eq ((μ.restrict s) t) 0\n⊢ Eq (μ (Inter.inter t s)) 0","decl":"theorem measure_inter_eq_zero_of_restrict (h : μ.restrict s t = 0) : μ (t ∩ s) = 0 :=\n  nonpos_iff_eq_zero.1 (h ▸ le_restrict_apply _ _)\n\n"}
{"name":"MeasureTheory.Measure.restrict_apply_eq_zero'","module":"Mathlib.MeasureTheory.Measure.Restrict","initialProofState":"α : Type u_2\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns t : Set α\nhs : MeasurableSet s\n⊢ Iff (Eq ((μ.restrict s) t) 0) (Eq (μ (Inter.inter t s)) 0)","decl":"theorem restrict_apply_eq_zero' (hs : MeasurableSet s) : μ.restrict s t = 0 ↔ μ (t ∩ s) = 0 := by\n  rw [restrict_apply' hs]\n\n"}
{"name":"MeasureTheory.Measure.restrict_eq_zero","module":"Mathlib.MeasureTheory.Measure.Restrict","initialProofState":"α : Type u_2\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : Set α\n⊢ Iff (Eq (μ.restrict s) 0) (Eq (μ s) 0)","decl":"@[simp]\ntheorem restrict_eq_zero : μ.restrict s = 0 ↔ μ s = 0 := by\n  rw [← measure_univ_eq_zero, restrict_apply_univ]\n\n"}
{"name":"MeasureTheory.Measure.restrict.neZero","module":"Mathlib.MeasureTheory.Measure.Restrict","initialProofState":"α : Type u_2\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : Set α\ninst✝ : NeZero (μ s)\n⊢ NeZero (μ.restrict s)","decl":"/-- If `μ s ≠ 0`, then `μ.restrict s ≠ 0`, in terms of `NeZero` instances. -/\ninstance restrict.neZero [NeZero (μ s)] : NeZero (μ.restrict s) :=\n  ⟨mt restrict_eq_zero.mp <| NeZero.ne _⟩\n\n"}
{"name":"MeasureTheory.Measure.restrict_zero_set","module":"Mathlib.MeasureTheory.Measure.Restrict","initialProofState":"α : Type u_2\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : Set α\nh : Eq (μ s) 0\n⊢ Eq (μ.restrict s) 0","decl":"theorem restrict_zero_set {s : Set α} (h : μ s = 0) : μ.restrict s = 0 :=\n  restrict_eq_zero.2 h\n\n"}
{"name":"MeasureTheory.Measure.restrict_empty","module":"Mathlib.MeasureTheory.Measure.Restrict","initialProofState":"α : Type u_2\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\n⊢ Eq (μ.restrict EmptyCollection.emptyCollection) 0","decl":"@[simp]\ntheorem restrict_empty : μ.restrict ∅ = 0 :=\n  restrict_zero_set measure_empty\n\n"}
{"name":"MeasureTheory.Measure.restrict_univ","module":"Mathlib.MeasureTheory.Measure.Restrict","initialProofState":"α : Type u_2\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\n⊢ Eq (μ.restrict Set.univ) μ","decl":"@[simp]\ntheorem restrict_univ : μ.restrict univ = μ :=\n  ext fun s hs => by simp [hs]\n\n"}
{"name":"MeasureTheory.Measure.restrict_inter_add_diff₀","module":"Mathlib.MeasureTheory.Measure.Restrict","initialProofState":"α : Type u_2\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nt s : Set α\nht : MeasureTheory.NullMeasurableSet t μ\n⊢ Eq (HAdd.hAdd (μ.restrict (Inter.inter s t)) (μ.restrict (SDiff.sdiff s t))) (μ.restrict s)","decl":"theorem restrict_inter_add_diff₀ (s : Set α) (ht : NullMeasurableSet t μ) :\n    μ.restrict (s ∩ t) + μ.restrict (s \\ t) = μ.restrict s := by\n  ext1 u hu\n  simp only [add_apply, restrict_apply hu, ← inter_assoc, diff_eq]\n  exact measure_inter_add_diff₀ (u ∩ s) ht\n\n"}
{"name":"MeasureTheory.Measure.restrict_inter_add_diff","module":"Mathlib.MeasureTheory.Measure.Restrict","initialProofState":"α : Type u_2\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nt s : Set α\nht : MeasurableSet t\n⊢ Eq (HAdd.hAdd (μ.restrict (Inter.inter s t)) (μ.restrict (SDiff.sdiff s t))) (μ.restrict s)","decl":"theorem restrict_inter_add_diff (s : Set α) (ht : MeasurableSet t) :\n    μ.restrict (s ∩ t) + μ.restrict (s \\ t) = μ.restrict s :=\n  restrict_inter_add_diff₀ s ht.nullMeasurableSet\n\n"}
{"name":"MeasureTheory.Measure.restrict_union_add_inter₀","module":"Mathlib.MeasureTheory.Measure.Restrict","initialProofState":"α : Type u_2\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nt s : Set α\nht : MeasureTheory.NullMeasurableSet t μ\n⊢ Eq (HAdd.hAdd (μ.restrict (Union.union s t)) (μ.restrict (Inter.inter s t))) (HAdd.hAdd (μ.restrict s) (μ.restrict t))","decl":"theorem restrict_union_add_inter₀ (s : Set α) (ht : NullMeasurableSet t μ) :\n    μ.restrict (s ∪ t) + μ.restrict (s ∩ t) = μ.restrict s + μ.restrict t := by\n  rw [← restrict_inter_add_diff₀ (s ∪ t) ht, union_inter_cancel_right, union_diff_right, ←\n    restrict_inter_add_diff₀ s ht, add_comm, ← add_assoc, add_right_comm]\n\n"}
{"name":"MeasureTheory.Measure.restrict_union_add_inter","module":"Mathlib.MeasureTheory.Measure.Restrict","initialProofState":"α : Type u_2\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nt s : Set α\nht : MeasurableSet t\n⊢ Eq (HAdd.hAdd (μ.restrict (Union.union s t)) (μ.restrict (Inter.inter s t))) (HAdd.hAdd (μ.restrict s) (μ.restrict t))","decl":"theorem restrict_union_add_inter (s : Set α) (ht : MeasurableSet t) :\n    μ.restrict (s ∪ t) + μ.restrict (s ∩ t) = μ.restrict s + μ.restrict t :=\n  restrict_union_add_inter₀ s ht.nullMeasurableSet\n\n"}
{"name":"MeasureTheory.Measure.restrict_union_add_inter'","module":"Mathlib.MeasureTheory.Measure.Restrict","initialProofState":"α : Type u_2\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : Set α\nhs : MeasurableSet s\nt : Set α\n⊢ Eq (HAdd.hAdd (μ.restrict (Union.union s t)) (μ.restrict (Inter.inter s t))) (HAdd.hAdd (μ.restrict s) (μ.restrict t))","decl":"theorem restrict_union_add_inter' (hs : MeasurableSet s) (t : Set α) :\n    μ.restrict (s ∪ t) + μ.restrict (s ∩ t) = μ.restrict s + μ.restrict t := by\n  simpa only [union_comm, inter_comm, add_comm] using restrict_union_add_inter t hs\n\n"}
{"name":"MeasureTheory.Measure.restrict_union₀","module":"Mathlib.MeasureTheory.Measure.Restrict","initialProofState":"α : Type u_2\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns t : Set α\nh : MeasureTheory.AEDisjoint μ s t\nht : MeasureTheory.NullMeasurableSet t μ\n⊢ Eq (μ.restrict (Union.union s t)) (HAdd.hAdd (μ.restrict s) (μ.restrict t))","decl":"theorem restrict_union₀ (h : AEDisjoint μ s t) (ht : NullMeasurableSet t μ) :\n    μ.restrict (s ∪ t) = μ.restrict s + μ.restrict t := by\n  simp [← restrict_union_add_inter₀ s ht, restrict_zero_set h]\n\n"}
{"name":"MeasureTheory.Measure.restrict_union","module":"Mathlib.MeasureTheory.Measure.Restrict","initialProofState":"α : Type u_2\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns t : Set α\nh : Disjoint s t\nht : MeasurableSet t\n⊢ Eq (μ.restrict (Union.union s t)) (HAdd.hAdd (μ.restrict s) (μ.restrict t))","decl":"theorem restrict_union (h : Disjoint s t) (ht : MeasurableSet t) :\n    μ.restrict (s ∪ t) = μ.restrict s + μ.restrict t :=\n  restrict_union₀ h.aedisjoint ht.nullMeasurableSet\n\n"}
{"name":"MeasureTheory.Measure.restrict_union'","module":"Mathlib.MeasureTheory.Measure.Restrict","initialProofState":"α : Type u_2\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns t : Set α\nh : Disjoint s t\nhs : MeasurableSet s\n⊢ Eq (μ.restrict (Union.union s t)) (HAdd.hAdd (μ.restrict s) (μ.restrict t))","decl":"theorem restrict_union' (h : Disjoint s t) (hs : MeasurableSet s) :\n    μ.restrict (s ∪ t) = μ.restrict s + μ.restrict t := by\n  rw [union_comm, restrict_union h.symm hs, add_comm]\n\n"}
{"name":"MeasureTheory.Measure.restrict_add_restrict_compl","module":"Mathlib.MeasureTheory.Measure.Restrict","initialProofState":"α : Type u_2\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : Set α\nhs : MeasurableSet s\n⊢ Eq (HAdd.hAdd (μ.restrict s) (μ.restrict (HasCompl.compl s))) μ","decl":"@[simp]\ntheorem restrict_add_restrict_compl (hs : MeasurableSet s) :\n    μ.restrict s + μ.restrict sᶜ = μ := by\n  rw [← restrict_union (@disjoint_compl_right (Set α) _ _) hs.compl, union_compl_self,\n    restrict_univ]\n\n"}
{"name":"MeasureTheory.Measure.restrict_compl_add_restrict","module":"Mathlib.MeasureTheory.Measure.Restrict","initialProofState":"α : Type u_2\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : Set α\nhs : MeasurableSet s\n⊢ Eq (HAdd.hAdd (μ.restrict (HasCompl.compl s)) (μ.restrict s)) μ","decl":"@[simp]\ntheorem restrict_compl_add_restrict (hs : MeasurableSet s) : μ.restrict sᶜ + μ.restrict s = μ := by\n  rw [add_comm, restrict_add_restrict_compl hs]\n\n"}
{"name":"MeasureTheory.Measure.restrict_union_le","module":"Mathlib.MeasureTheory.Measure.Restrict","initialProofState":"α : Type u_2\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns s' : Set α\n⊢ LE.le (μ.restrict (Union.union s s')) (HAdd.hAdd (μ.restrict s) (μ.restrict s'))","decl":"theorem restrict_union_le (s s' : Set α) : μ.restrict (s ∪ s') ≤ μ.restrict s + μ.restrict s' :=\n  le_iff.2 fun t ht ↦ by\n    simpa [ht, inter_union_distrib_left] using measure_union_le (t ∩ s) (t ∩ s')\n\n"}
{"name":"MeasureTheory.Measure.restrict_iUnion_apply_ae","module":"Mathlib.MeasureTheory.Measure.Restrict","initialProofState":"α : Type u_2\nι : Type u_6\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : Countable ι\ns : ι → Set α\nhd : Pairwise (Function.onFun (MeasureTheory.AEDisjoint μ) s)\nhm : ∀ (i : ι), MeasureTheory.NullMeasurableSet (s i) μ\nt : Set α\nht : MeasurableSet t\n⊢ Eq ((μ.restrict (Set.iUnion fun i => s i)) t) (tsum fun i => (μ.restrict (s i)) t)","decl":"theorem restrict_iUnion_apply_ae [Countable ι] {s : ι → Set α} (hd : Pairwise (AEDisjoint μ on s))\n    (hm : ∀ i, NullMeasurableSet (s i) μ) {t : Set α} (ht : MeasurableSet t) :\n    μ.restrict (⋃ i, s i) t = ∑' i, μ.restrict (s i) t := by\n  simp only [restrict_apply, ht, inter_iUnion]\n  exact\n    measure_iUnion₀ (hd.mono fun i j h => h.mono inter_subset_right inter_subset_right)\n      fun i => ht.nullMeasurableSet.inter (hm i)\n\n"}
{"name":"MeasureTheory.Measure.restrict_iUnion_apply","module":"Mathlib.MeasureTheory.Measure.Restrict","initialProofState":"α : Type u_2\nι : Type u_6\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : Countable ι\ns : ι → Set α\nhd : Pairwise (Function.onFun Disjoint s)\nhm : ∀ (i : ι), MeasurableSet (s i)\nt : Set α\nht : MeasurableSet t\n⊢ Eq ((μ.restrict (Set.iUnion fun i => s i)) t) (tsum fun i => (μ.restrict (s i)) t)","decl":"theorem restrict_iUnion_apply [Countable ι] {s : ι → Set α} (hd : Pairwise (Disjoint on s))\n    (hm : ∀ i, MeasurableSet (s i)) {t : Set α} (ht : MeasurableSet t) :\n    μ.restrict (⋃ i, s i) t = ∑' i, μ.restrict (s i) t :=\n  restrict_iUnion_apply_ae hd.aedisjoint (fun i => (hm i).nullMeasurableSet) ht\n\n"}
{"name":"MeasureTheory.Measure.restrict_iUnion_apply_eq_iSup","module":"Mathlib.MeasureTheory.Measure.Restrict","initialProofState":"α : Type u_2\nι : Type u_6\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : Countable ι\ns : ι → Set α\nhd : Directed (fun x1 x2 => HasSubset.Subset x1 x2) s\nt : Set α\nht : MeasurableSet t\n⊢ Eq ((μ.restrict (Set.iUnion fun i => s i)) t) (iSup fun i => (μ.restrict (s i)) t)","decl":"theorem restrict_iUnion_apply_eq_iSup [Countable ι] {s : ι → Set α} (hd : Directed (· ⊆ ·) s)\n    {t : Set α} (ht : MeasurableSet t) : μ.restrict (⋃ i, s i) t = ⨆ i, μ.restrict (s i) t := by\n  simp only [restrict_apply ht, inter_iUnion]\n  rw [Directed.measure_iUnion]\n  exacts [hd.mono_comp _ fun s₁ s₂ => inter_subset_inter_right _]\n\n"}
{"name":"MeasureTheory.Measure.restrict_map","module":"Mathlib.MeasureTheory.Measure.Restrict","initialProofState":"α : Type u_2\nβ : Type u_3\nm0 : MeasurableSpace α\ninst✝ : MeasurableSpace β\nμ : MeasureTheory.Measure α\nf : α → β\nhf : Measurable f\ns : Set β\nhs : MeasurableSet s\n⊢ Eq ((MeasureTheory.Measure.map f μ).restrict s) (MeasureTheory.Measure.map f (μ.restrict (Set.preimage f s)))","decl":"/-- The restriction of the pushforward measure is the pushforward of the restriction. For a version\nassuming only `AEMeasurable`, see `restrict_map_of_aemeasurable`. -/\ntheorem restrict_map {f : α → β} (hf : Measurable f) {s : Set β} (hs : MeasurableSet s) :\n    (μ.map f).restrict s = (μ.restrict <| f ⁻¹' s).map f :=\n  ext fun t ht => by simp [*, hf ht]\n\n"}
{"name":"MeasureTheory.Measure.restrict_toMeasurable","module":"Mathlib.MeasureTheory.Measure.Restrict","initialProofState":"α : Type u_2\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : Set α\nh : Ne (μ s) Top.top\n⊢ Eq (μ.restrict (MeasureTheory.toMeasurable μ s)) (μ.restrict s)","decl":"theorem restrict_toMeasurable (h : μ s ≠ ∞) : μ.restrict (toMeasurable μ s) = μ.restrict s :=\n  ext fun t ht => by\n    rw [restrict_apply ht, restrict_apply ht, inter_comm, measure_toMeasurable_inter ht h,\n      inter_comm]\n\n"}
{"name":"MeasureTheory.Measure.restrict_eq_self_of_ae_mem","module":"Mathlib.MeasureTheory.Measure.Restrict","initialProofState":"α : Type u_2\n_m0 : MeasurableSpace α\ns : Set α\nμ : MeasureTheory.Measure α\nhs : Filter.Eventually (fun x => Membership.mem s x) (MeasureTheory.ae μ)\n⊢ Eq (μ.restrict s) μ","decl":"theorem restrict_eq_self_of_ae_mem {_m0 : MeasurableSpace α} ⦃s : Set α⦄ ⦃μ : Measure α⦄\n    (hs : ∀ᵐ x ∂μ, x ∈ s) : μ.restrict s = μ :=\n  calc\n    μ.restrict s = μ.restrict univ := restrict_congr_set (eventuallyEq_univ.mpr hs)\n    _ = μ := restrict_univ\n\n"}
{"name":"MeasureTheory.Measure.restrict_congr_meas","module":"Mathlib.MeasureTheory.Measure.Restrict","initialProofState":"α : Type u_2\nm0 : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\ns : Set α\nhs : MeasurableSet s\n⊢ Iff (Eq (μ.restrict s) (ν.restrict s)) (∀ (t : Set α), HasSubset.Subset t s → MeasurableSet t → Eq (μ t) (ν t))","decl":"theorem restrict_congr_meas (hs : MeasurableSet s) :\n    μ.restrict s = ν.restrict s ↔ ∀ t ⊆ s, MeasurableSet t → μ t = ν t :=\n  ⟨fun H t hts ht => by\n    rw [← inter_eq_self_of_subset_left hts, ← restrict_apply ht, H, restrict_apply ht], fun H =>\n    ext fun t ht => by\n      rw [restrict_apply ht, restrict_apply ht, H _ inter_subset_right (ht.inter hs)]⟩\n\n"}
{"name":"MeasureTheory.Measure.restrict_congr_mono","module":"Mathlib.MeasureTheory.Measure.Restrict","initialProofState":"α : Type u_2\nm0 : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\ns t : Set α\nhs : HasSubset.Subset s t\nh : Eq (μ.restrict t) (ν.restrict t)\n⊢ Eq (μ.restrict s) (ν.restrict s)","decl":"theorem restrict_congr_mono (hs : s ⊆ t) (h : μ.restrict t = ν.restrict t) :\n    μ.restrict s = ν.restrict s := by\n  rw [← restrict_restrict_of_subset hs, h, restrict_restrict_of_subset hs]\n\n"}
{"name":"MeasureTheory.Measure.restrict_union_congr","module":"Mathlib.MeasureTheory.Measure.Restrict","initialProofState":"α : Type u_2\nm0 : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\ns t : Set α\n⊢ Iff (Eq (μ.restrict (Union.union s t)) (ν.restrict (Union.union s t))) (And (Eq (μ.restrict s) (ν.restrict s)) (Eq (μ.restrict t) (ν.restrict t)))","decl":"/-- If two measures agree on all measurable subsets of `s` and `t`, then they agree on all\nmeasurable subsets of `s ∪ t`. -/\ntheorem restrict_union_congr :\n    μ.restrict (s ∪ t) = ν.restrict (s ∪ t) ↔\n      μ.restrict s = ν.restrict s ∧ μ.restrict t = ν.restrict t := by\n  refine ⟨fun h ↦ ⟨restrict_congr_mono subset_union_left h,\n    restrict_congr_mono subset_union_right h⟩, ?_⟩\n  rintro ⟨hs, ht⟩\n  ext1 u hu\n  simp only [restrict_apply hu, inter_union_distrib_left]\n  rcases exists_measurable_superset₂ μ ν (u ∩ s) with ⟨US, hsub, hm, hμ, hν⟩\n  calc\n    μ (u ∩ s ∪ u ∩ t) = μ (US ∪ u ∩ t) :=\n      measure_union_congr_of_subset hsub hμ.le Subset.rfl le_rfl\n    _ = μ US + μ ((u ∩ t) \\ US) := (measure_add_diff hm.nullMeasurableSet _).symm\n    _ = restrict μ s u + restrict μ t (u \\ US) := by\n      simp only [restrict_apply, hu, hu.diff hm, hμ, ← inter_comm t, inter_diff_assoc]\n    _ = restrict ν s u + restrict ν t (u \\ US) := by rw [hs, ht]\n    _ = ν US + ν ((u ∩ t) \\ US) := by\n      simp only [restrict_apply, hu, hu.diff hm, hν, ← inter_comm t, inter_diff_assoc]\n    _ = ν (US ∪ u ∩ t) := measure_add_diff hm.nullMeasurableSet _\n    _ = ν (u ∩ s ∪ u ∩ t) := .symm <| measure_union_congr_of_subset hsub hν.le Subset.rfl le_rfl\n\n"}
{"name":"MeasureTheory.Measure.restrict_finset_biUnion_congr","module":"Mathlib.MeasureTheory.Measure.Restrict","initialProofState":"α : Type u_2\nι : Type u_6\nm0 : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\ns : Finset ι\nt : ι → Set α\n⊢ Iff (Eq (μ.restrict (Set.iUnion fun i => Set.iUnion fun h => t i)) (ν.restrict (Set.iUnion fun i => Set.iUnion fun h => t i))) (∀ (i : ι), Membership.mem s i → Eq (μ.restrict (t i)) (ν.restrict (t i)))","decl":"theorem restrict_finset_biUnion_congr {s : Finset ι} {t : ι → Set α} :\n    μ.restrict (⋃ i ∈ s, t i) = ν.restrict (⋃ i ∈ s, t i) ↔\n      ∀ i ∈ s, μ.restrict (t i) = ν.restrict (t i) := by\n  classical\n  induction' s using Finset.induction_on with i s _ hs; · simp\n  simp only [forall_eq_or_imp, iUnion_iUnion_eq_or_left, Finset.mem_insert]\n  rw [restrict_union_congr, ← hs]\n\n"}
{"name":"MeasureTheory.Measure.restrict_iUnion_congr","module":"Mathlib.MeasureTheory.Measure.Restrict","initialProofState":"α : Type u_2\nι : Type u_6\nm0 : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\ninst✝ : Countable ι\ns : ι → Set α\n⊢ Iff (Eq (μ.restrict (Set.iUnion fun i => s i)) (ν.restrict (Set.iUnion fun i => s i))) (∀ (i : ι), Eq (μ.restrict (s i)) (ν.restrict (s i)))","decl":"theorem restrict_iUnion_congr [Countable ι] {s : ι → Set α} :\n    μ.restrict (⋃ i, s i) = ν.restrict (⋃ i, s i) ↔ ∀ i, μ.restrict (s i) = ν.restrict (s i) := by\n  refine ⟨fun h i => restrict_congr_mono (subset_iUnion _ _) h, fun h => ?_⟩\n  ext1 t ht\n  have D : Directed (· ⊆ ·) fun t : Finset ι => ⋃ i ∈ t, s i :=\n    Monotone.directed_le fun t₁ t₂ ht => biUnion_subset_biUnion_left ht\n  rw [iUnion_eq_iUnion_finset]\n  simp only [restrict_iUnion_apply_eq_iSup D ht, restrict_finset_biUnion_congr.2 fun i _ => h i]\n\n"}
{"name":"MeasureTheory.Measure.restrict_biUnion_congr","module":"Mathlib.MeasureTheory.Measure.Restrict","initialProofState":"α : Type u_2\nι : Type u_6\nm0 : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\ns : Set ι\nt : ι → Set α\nhc : s.Countable\n⊢ Iff (Eq (μ.restrict (Set.iUnion fun i => Set.iUnion fun h => t i)) (ν.restrict (Set.iUnion fun i => Set.iUnion fun h => t i))) (∀ (i : ι), Membership.mem s i → Eq (μ.restrict (t i)) (ν.restrict (t i)))","decl":"theorem restrict_biUnion_congr {s : Set ι} {t : ι → Set α} (hc : s.Countable) :\n    μ.restrict (⋃ i ∈ s, t i) = ν.restrict (⋃ i ∈ s, t i) ↔\n      ∀ i ∈ s, μ.restrict (t i) = ν.restrict (t i) := by\n  haveI := hc.toEncodable\n  simp only [biUnion_eq_iUnion, SetCoe.forall', restrict_iUnion_congr]\n\n"}
{"name":"MeasureTheory.Measure.restrict_sUnion_congr","module":"Mathlib.MeasureTheory.Measure.Restrict","initialProofState":"α : Type u_2\nm0 : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\nS : Set (Set α)\nhc : S.Countable\n⊢ Iff (Eq (μ.restrict S.sUnion) (ν.restrict S.sUnion)) (∀ (s : Set α), Membership.mem S s → Eq (μ.restrict s) (ν.restrict s))","decl":"theorem restrict_sUnion_congr {S : Set (Set α)} (hc : S.Countable) :\n    μ.restrict (⋃₀ S) = ν.restrict (⋃₀ S) ↔ ∀ s ∈ S, μ.restrict s = ν.restrict s := by\n  rw [sUnion_eq_biUnion, restrict_biUnion_congr hc]\n\n"}
{"name":"MeasureTheory.Measure.restrict_sInf_eq_sInf_restrict","module":"Mathlib.MeasureTheory.Measure.Restrict","initialProofState":"α : Type u_2\nt : Set α\nm0 : MeasurableSpace α\nm : Set (MeasureTheory.Measure α)\nhm : m.Nonempty\nht : MeasurableSet t\n⊢ Eq ((InfSet.sInf m).restrict t) (InfSet.sInf (Set.image (fun μ => μ.restrict t) m))","decl":"/-- This lemma shows that `Inf` and `restrict` commute for measures. -/\ntheorem restrict_sInf_eq_sInf_restrict {m0 : MeasurableSpace α} {m : Set (Measure α)}\n    (hm : m.Nonempty) (ht : MeasurableSet t) :\n    (sInf m).restrict t = sInf ((fun μ : Measure α => μ.restrict t) '' m) := by\n  ext1 s hs\n  simp_rw [sInf_apply hs, restrict_apply hs, sInf_apply (MeasurableSet.inter hs ht),\n    Set.image_image, restrict_toOuterMeasure_eq_toOuterMeasure_restrict ht, ←\n    Set.image_image _ toOuterMeasure, ← OuterMeasure.restrict_sInf_eq_sInf_restrict _ (hm.image _),\n    OuterMeasure.restrict_apply]\n\n"}
{"name":"MeasureTheory.Measure.exists_mem_of_measure_ne_zero_of_ae","module":"Mathlib.MeasureTheory.Measure.Restrict","initialProofState":"α : Type u_2\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : Set α\nhs : Ne (μ s) 0\np : α → Prop\nhp : Filter.Eventually (fun x => p x) (MeasureTheory.ae (μ.restrict s))\n⊢ Exists fun x => And (Membership.mem s x) (p x)","decl":"theorem exists_mem_of_measure_ne_zero_of_ae (hs : μ s ≠ 0) {p : α → Prop}\n    (hp : ∀ᵐ x ∂μ.restrict s, p x) : ∃ x, x ∈ s ∧ p x := by\n  rw [← μ.restrict_apply_self, ← frequently_ae_mem_iff] at hs\n  exact (hs.and_eventually hp).exists\n\n"}
{"name":"MeasureTheory.Measure.QuasiMeasurePreserving.restrict","module":"Mathlib.MeasureTheory.Measure.Restrict","initialProofState":"α : Type u_2\nβ : Type u_3\nm0 : MeasurableSpace α\ninst✝ : MeasurableSpace β\nμ : MeasureTheory.Measure α\ns : Set α\nν : MeasureTheory.Measure β\nf : α → β\nhf : MeasureTheory.Measure.QuasiMeasurePreserving f μ ν\nt : Set β\nhmaps : Set.MapsTo f s t\n⊢ MeasureTheory.Measure.QuasiMeasurePreserving f (μ.restrict s) (ν.restrict t)","decl":"/-- If a quasi measure preserving map `f` maps a set `s` to a set `t`,\nthen it is quasi measure preserving with respect to the restrictions of the measures. -/\ntheorem QuasiMeasurePreserving.restrict {ν : Measure β} {f : α → β}\n    (hf : QuasiMeasurePreserving f μ ν) {t : Set β} (hmaps : MapsTo f s t) :\n    QuasiMeasurePreserving f (μ.restrict s) (ν.restrict t) where\n  measurable := hf.measurable\n  absolutelyContinuous := by\n    refine AbsolutelyContinuous.mk fun u hum ↦ ?_\n    suffices ν (u ∩ t) = 0 → μ (f ⁻¹' u ∩ s) = 0 by simpa [hum, hf.measurable, hf.measurable hum]\n    refine fun hu ↦ measure_mono_null ?_ (hf.preimage_null hu)\n    rw [preimage_inter]\n    gcongr\n    assumption\n\n"}
{"name":"MeasureTheory.Measure.ext_iff_of_iUnion_eq_univ","module":"Mathlib.MeasureTheory.Measure.Restrict","initialProofState":"α : Type u_2\nι : Type u_6\nm0 : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\ninst✝ : Countable ι\ns : ι → Set α\nhs : Eq (Set.iUnion fun i => s i) Set.univ\n⊢ Iff (Eq μ ν) (∀ (i : ι), Eq (μ.restrict (s i)) (ν.restrict (s i)))","decl":"/-- Two measures are equal if they have equal restrictions on a spanning collection of sets\n  (formulated using `Union`). -/\ntheorem ext_iff_of_iUnion_eq_univ [Countable ι] {s : ι → Set α} (hs : ⋃ i, s i = univ) :\n    μ = ν ↔ ∀ i, μ.restrict (s i) = ν.restrict (s i) := by\n  rw [← restrict_iUnion_congr, hs, restrict_univ, restrict_univ]\n\n"}
{"name":"MeasureTheory.Measure.ext_of_iUnion_eq_univ","module":"Mathlib.MeasureTheory.Measure.Restrict","initialProofState":"α : Type u_2\nι : Type u_6\nm0 : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\ninst✝ : Countable ι\ns : ι → Set α\nhs : Eq (Set.iUnion fun i => s i) Set.univ\na✝ : ∀ (i : ι), Eq (μ.restrict (s i)) (ν.restrict (s i))\n⊢ Eq μ ν","decl":"alias ⟨_, ext_of_iUnion_eq_univ⟩ := ext_iff_of_iUnion_eq_univ\n\n"}
{"name":"MeasureTheory.Measure.ext_iff_of_biUnion_eq_univ","module":"Mathlib.MeasureTheory.Measure.Restrict","initialProofState":"α : Type u_2\nι : Type u_6\nm0 : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\nS : Set ι\ns : ι → Set α\nhc : S.Countable\nhs : Eq (Set.iUnion fun i => Set.iUnion fun h => s i) Set.univ\n⊢ Iff (Eq μ ν) (∀ (i : ι), Membership.mem S i → Eq (μ.restrict (s i)) (ν.restrict (s i)))","decl":"/-- Two measures are equal if they have equal restrictions on a spanning collection of sets\n  (formulated using `biUnion`). -/\ntheorem ext_iff_of_biUnion_eq_univ {S : Set ι} {s : ι → Set α} (hc : S.Countable)\n    (hs : ⋃ i ∈ S, s i = univ) : μ = ν ↔ ∀ i ∈ S, μ.restrict (s i) = ν.restrict (s i) := by\n  rw [← restrict_biUnion_congr hc, hs, restrict_univ, restrict_univ]\n\n"}
{"name":"MeasureTheory.Measure.ext_of_biUnion_eq_univ","module":"Mathlib.MeasureTheory.Measure.Restrict","initialProofState":"α : Type u_2\nι : Type u_6\nm0 : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\nS : Set ι\ns : ι → Set α\nhc : S.Countable\nhs : Eq (Set.iUnion fun i => Set.iUnion fun h => s i) Set.univ\na✝ : ∀ (i : ι), Membership.mem S i → Eq (μ.restrict (s i)) (ν.restrict (s i))\n⊢ Eq μ ν","decl":"alias ⟨_, ext_of_biUnion_eq_univ⟩ := ext_iff_of_biUnion_eq_univ\n\n"}
{"name":"MeasureTheory.Measure.ext_iff_of_sUnion_eq_univ","module":"Mathlib.MeasureTheory.Measure.Restrict","initialProofState":"α : Type u_2\nm0 : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\nS : Set (Set α)\nhc : S.Countable\nhs : Eq S.sUnion Set.univ\n⊢ Iff (Eq μ ν) (∀ (s : Set α), Membership.mem S s → Eq (μ.restrict s) (ν.restrict s))","decl":"/-- Two measures are equal if they have equal restrictions on a spanning collection of sets\n  (formulated using `sUnion`). -/\ntheorem ext_iff_of_sUnion_eq_univ {S : Set (Set α)} (hc : S.Countable) (hs : ⋃₀ S = univ) :\n    μ = ν ↔ ∀ s ∈ S, μ.restrict s = ν.restrict s :=\n  ext_iff_of_biUnion_eq_univ hc <| by rwa [← sUnion_eq_biUnion]\n\n"}
{"name":"MeasureTheory.Measure.ext_of_sUnion_eq_univ","module":"Mathlib.MeasureTheory.Measure.Restrict","initialProofState":"α : Type u_2\nm0 : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\nS : Set (Set α)\nhc : S.Countable\nhs : Eq S.sUnion Set.univ\na✝ : ∀ (s : Set α), Membership.mem S s → Eq (μ.restrict s) (ν.restrict s)\n⊢ Eq μ ν","decl":"alias ⟨_, ext_of_sUnion_eq_univ⟩ := ext_iff_of_sUnion_eq_univ\n\n"}
{"name":"MeasureTheory.Measure.ext_of_generateFrom_of_cover","module":"Mathlib.MeasureTheory.Measure.Restrict","initialProofState":"α : Type u_2\nm0 : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\nS T : Set (Set α)\nh_gen : Eq m0 (MeasurableSpace.generateFrom S)\nhc : T.Countable\nh_inter : IsPiSystem S\nhU : Eq T.sUnion Set.univ\nhtop : ∀ (t : Set α), Membership.mem T t → Ne (μ t) Top.top\nST_eq : ∀ (t : Set α), Membership.mem T t → ∀ (s : Set α), Membership.mem S s → Eq (μ (Inter.inter s t)) (ν (Inter.inter s t))\nT_eq : ∀ (t : Set α), Membership.mem T t → Eq (μ t) (ν t)\n⊢ Eq μ ν","decl":"theorem ext_of_generateFrom_of_cover {S T : Set (Set α)} (h_gen : ‹_› = generateFrom S)\n    (hc : T.Countable) (h_inter : IsPiSystem S) (hU : ⋃₀ T = univ) (htop : ∀ t ∈ T, μ t ≠ ∞)\n    (ST_eq : ∀ t ∈ T, ∀ s ∈ S, μ (s ∩ t) = ν (s ∩ t)) (T_eq : ∀ t ∈ T, μ t = ν t) : μ = ν := by\n  refine ext_of_sUnion_eq_univ hc hU fun t ht => ?_\n  ext1 u hu\n  simp only [restrict_apply hu]\n  induction u, hu using induction_on_inter h_gen h_inter with\n  | empty => simp only [Set.empty_inter, measure_empty]\n  | basic u hu => exact ST_eq _ ht _ hu\n  | compl u hu ihu =>\n    have := T_eq t ht\n    rw [Set.inter_comm] at ihu ⊢\n    rwa [← measure_inter_add_diff t hu, ← measure_inter_add_diff t hu, ← ihu,\n      ENNReal.add_right_inj] at this\n    exact ne_top_of_le_ne_top (htop t ht) (measure_mono Set.inter_subset_left)\n  | iUnion f hfd hfm ihf =>\n    simp only [← restrict_apply (hfm _), ← restrict_apply (MeasurableSet.iUnion hfm)] at ihf ⊢\n    simp only [measure_iUnion hfd hfm, ihf]\n\n"}
{"name":"MeasureTheory.Measure.ext_of_generateFrom_of_cover_subset","module":"Mathlib.MeasureTheory.Measure.Restrict","initialProofState":"α : Type u_2\nm0 : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\nS T : Set (Set α)\nh_gen : Eq m0 (MeasurableSpace.generateFrom S)\nh_inter : IsPiSystem S\nh_sub : HasSubset.Subset T S\nhc : T.Countable\nhU : Eq T.sUnion Set.univ\nhtop : ∀ (s : Set α), Membership.mem T s → Ne (μ s) Top.top\nh_eq : ∀ (s : Set α), Membership.mem S s → Eq (μ s) (ν s)\n⊢ Eq μ ν","decl":"/-- Two measures are equal if they are equal on the π-system generating the σ-algebra,\n  and they are both finite on an increasing spanning sequence of sets in the π-system.\n  This lemma is formulated using `sUnion`. -/\ntheorem ext_of_generateFrom_of_cover_subset {S T : Set (Set α)} (h_gen : ‹_› = generateFrom S)\n    (h_inter : IsPiSystem S) (h_sub : T ⊆ S) (hc : T.Countable) (hU : ⋃₀ T = univ)\n    (htop : ∀ s ∈ T, μ s ≠ ∞) (h_eq : ∀ s ∈ S, μ s = ν s) : μ = ν := by\n  refine ext_of_generateFrom_of_cover h_gen hc h_inter hU htop ?_ fun t ht => h_eq t (h_sub ht)\n  intro t ht s hs; rcases (s ∩ t).eq_empty_or_nonempty with H | H\n  · simp only [H, measure_empty]\n  · exact h_eq _ (h_inter _ hs _ (h_sub ht) H)\n\n"}
{"name":"MeasureTheory.Measure.ext_of_generateFrom_of_iUnion","module":"Mathlib.MeasureTheory.Measure.Restrict","initialProofState":"α : Type u_2\nm0 : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\nC : Set (Set α)\nB : Nat → Set α\nhA : Eq m0 (MeasurableSpace.generateFrom C)\nhC : IsPiSystem C\nh1B : Eq (Set.iUnion fun i => B i) Set.univ\nh2B : ∀ (i : Nat), Membership.mem C (B i)\nhμB : ∀ (i : Nat), Ne (μ (B i)) Top.top\nh_eq : ∀ (s : Set α), Membership.mem C s → Eq (μ s) (ν s)\n⊢ Eq μ ν","decl":"/-- Two measures are equal if they are equal on the π-system generating the σ-algebra,\n  and they are both finite on an increasing spanning sequence of sets in the π-system.\n  This lemma is formulated using `iUnion`.\n  `FiniteSpanningSetsIn.ext` is a reformulation of this lemma. -/\ntheorem ext_of_generateFrom_of_iUnion (C : Set (Set α)) (B : ℕ → Set α) (hA : ‹_› = generateFrom C)\n    (hC : IsPiSystem C) (h1B : ⋃ i, B i = univ) (h2B : ∀ i, B i ∈ C) (hμB : ∀ i, μ (B i) ≠ ∞)\n    (h_eq : ∀ s ∈ C, μ s = ν s) : μ = ν := by\n  refine ext_of_generateFrom_of_cover_subset hA hC ?_ (countable_range B) h1B ?_ h_eq\n  · rintro _ ⟨i, rfl⟩\n    apply h2B\n  · rintro _ ⟨i, rfl⟩\n    apply hμB\n\n"}
{"name":"MeasureTheory.Measure.restrict_sum","module":"Mathlib.MeasureTheory.Measure.Restrict","initialProofState":"α : Type u_2\nι : Type u_6\nm0 : MeasurableSpace α\nμ : ι → MeasureTheory.Measure α\ns : Set α\nhs : MeasurableSet s\n⊢ Eq ((MeasureTheory.Measure.sum μ).restrict s) (MeasureTheory.Measure.sum fun i => (μ i).restrict s)","decl":"@[simp]\ntheorem restrict_sum (μ : ι → Measure α) {s : Set α} (hs : MeasurableSet s) :\n    (sum μ).restrict s = sum fun i => (μ i).restrict s :=\n  ext fun t ht => by simp only [sum_apply, restrict_apply, ht, ht.inter hs]\n\n"}
{"name":"MeasureTheory.Measure.restrict_sum_of_countable","module":"Mathlib.MeasureTheory.Measure.Restrict","initialProofState":"α : Type u_2\nι : Type u_6\nm0 : MeasurableSpace α\ninst✝ : Countable ι\nμ : ι → MeasureTheory.Measure α\ns : Set α\n⊢ Eq ((MeasureTheory.Measure.sum μ).restrict s) (MeasureTheory.Measure.sum fun i => (μ i).restrict s)","decl":"@[simp]\ntheorem restrict_sum_of_countable [Countable ι] (μ : ι → Measure α) (s : Set α) :\n    (sum μ).restrict s = sum fun i => (μ i).restrict s := by\n  ext t ht\n  simp_rw [sum_apply _ ht, restrict_apply ht, sum_apply_of_countable]\n\n"}
{"name":"MeasureTheory.Measure.AbsolutelyContinuous.restrict","module":"Mathlib.MeasureTheory.Measure.Restrict","initialProofState":"α : Type u_2\nm0 : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\nh : μ.AbsolutelyContinuous ν\ns : Set α\n⊢ (μ.restrict s).AbsolutelyContinuous (ν.restrict s)","decl":"lemma AbsolutelyContinuous.restrict (h : μ ≪ ν) (s : Set α) : μ.restrict s ≪ ν.restrict s := by\n  refine Measure.AbsolutelyContinuous.mk (fun t ht htν ↦ ?_)\n  rw [restrict_apply ht] at htν ⊢\n  exact h htν\n\n"}
{"name":"MeasureTheory.Measure.restrict_iUnion_ae","module":"Mathlib.MeasureTheory.Measure.Restrict","initialProofState":"α : Type u_2\nι : Type u_6\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : Countable ι\ns : ι → Set α\nhd : Pairwise (Function.onFun (MeasureTheory.AEDisjoint μ) s)\nhm : ∀ (i : ι), MeasureTheory.NullMeasurableSet (s i) μ\n⊢ Eq (μ.restrict (Set.iUnion fun i => s i)) (MeasureTheory.Measure.sum fun i => μ.restrict (s i))","decl":"theorem restrict_iUnion_ae [Countable ι] {s : ι → Set α} (hd : Pairwise (AEDisjoint μ on s))\n    (hm : ∀ i, NullMeasurableSet (s i) μ) : μ.restrict (⋃ i, s i) = sum fun i => μ.restrict (s i) :=\n  ext fun t ht => by simp only [sum_apply _ ht, restrict_iUnion_apply_ae hd hm ht]\n\n"}
{"name":"MeasureTheory.Measure.restrict_iUnion","module":"Mathlib.MeasureTheory.Measure.Restrict","initialProofState":"α : Type u_2\nι : Type u_6\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : Countable ι\ns : ι → Set α\nhd : Pairwise (Function.onFun Disjoint s)\nhm : ∀ (i : ι), MeasurableSet (s i)\n⊢ Eq (μ.restrict (Set.iUnion fun i => s i)) (MeasureTheory.Measure.sum fun i => μ.restrict (s i))","decl":"theorem restrict_iUnion [Countable ι] {s : ι → Set α} (hd : Pairwise (Disjoint on s))\n    (hm : ∀ i, MeasurableSet (s i)) : μ.restrict (⋃ i, s i) = sum fun i => μ.restrict (s i) :=\n  restrict_iUnion_ae hd.aedisjoint fun i => (hm i).nullMeasurableSet\n\n"}
{"name":"MeasureTheory.Measure.restrict_iUnion_le","module":"Mathlib.MeasureTheory.Measure.Restrict","initialProofState":"α : Type u_2\nι : Type u_6\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : Countable ι\ns : ι → Set α\n⊢ LE.le (μ.restrict (Set.iUnion fun i => s i)) (MeasureTheory.Measure.sum fun i => μ.restrict (s i))","decl":"theorem restrict_iUnion_le [Countable ι] {s : ι → Set α} :\n    μ.restrict (⋃ i, s i) ≤ sum fun i => μ.restrict (s i) :=\n  le_iff.2 fun t ht ↦ by simpa [ht, inter_iUnion] using measure_iUnion_le (t ∩ s ·)\n\n"}
{"name":"MeasureTheory.ae_restrict_iUnion_eq","module":"Mathlib.MeasureTheory.Measure.Restrict","initialProofState":"α : Type u_2\nι : Type u_6\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : Countable ι\ns : ι → Set α\n⊢ Eq (MeasureTheory.ae (μ.restrict (Set.iUnion fun i => s i))) (iSup fun i => MeasureTheory.ae (μ.restrict (s i)))","decl":"@[simp]\ntheorem ae_restrict_iUnion_eq [Countable ι] (s : ι → Set α) :\n    ae (μ.restrict (⋃ i, s i)) = ⨆ i, ae (μ.restrict (s i)) :=\n  le_antisymm ((ae_sum_eq fun i => μ.restrict (s i)) ▸ ae_mono restrict_iUnion_le) <|\n    iSup_le fun i => ae_mono <| restrict_mono (subset_iUnion s i) le_rfl\n\n"}
{"name":"MeasureTheory.ae_restrict_union_eq","module":"Mathlib.MeasureTheory.Measure.Restrict","initialProofState":"α : Type u_2\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns t : Set α\n⊢ Eq (MeasureTheory.ae (μ.restrict (Union.union s t))) (Max.max (MeasureTheory.ae (μ.restrict s)) (MeasureTheory.ae (μ.restrict t)))","decl":"@[simp]\ntheorem ae_restrict_union_eq (s t : Set α) :\n    ae (μ.restrict (s ∪ t)) = ae (μ.restrict s) ⊔ ae (μ.restrict t) := by\n  simp [union_eq_iUnion, iSup_bool_eq]\n\n"}
{"name":"MeasureTheory.ae_restrict_biUnion_eq","module":"Mathlib.MeasureTheory.Measure.Restrict","initialProofState":"α : Type u_2\nι : Type u_6\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : ι → Set α\nt : Set ι\nht : t.Countable\n⊢ Eq (MeasureTheory.ae (μ.restrict (Set.iUnion fun i => Set.iUnion fun h => s i))) (iSup fun i => iSup fun h => MeasureTheory.ae (μ.restrict (s i)))","decl":"theorem ae_restrict_biUnion_eq (s : ι → Set α) {t : Set ι} (ht : t.Countable) :\n    ae (μ.restrict (⋃ i ∈ t, s i)) = ⨆ i ∈ t, ae (μ.restrict (s i)) := by\n  haveI := ht.to_subtype\n  rw [biUnion_eq_iUnion, ae_restrict_iUnion_eq, ← iSup_subtype'']\n\n"}
{"name":"MeasureTheory.ae_restrict_biUnion_finset_eq","module":"Mathlib.MeasureTheory.Measure.Restrict","initialProofState":"α : Type u_2\nι : Type u_6\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : ι → Set α\nt : Finset ι\n⊢ Eq (MeasureTheory.ae (μ.restrict (Set.iUnion fun i => Set.iUnion fun h => s i))) (iSup fun i => iSup fun h => MeasureTheory.ae (μ.restrict (s i)))","decl":"theorem ae_restrict_biUnion_finset_eq (s : ι → Set α) (t : Finset ι) :\n    ae (μ.restrict (⋃ i ∈ t, s i)) = ⨆ i ∈ t, ae (μ.restrict (s i)) :=\n  ae_restrict_biUnion_eq s t.countable_toSet\n\n"}
{"name":"MeasureTheory.ae_restrict_iUnion_iff","module":"Mathlib.MeasureTheory.Measure.Restrict","initialProofState":"α : Type u_2\nι : Type u_6\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : Countable ι\ns : ι → Set α\np : α → Prop\n⊢ Iff (Filter.Eventually (fun x => p x) (MeasureTheory.ae (μ.restrict (Set.iUnion fun i => s i)))) (∀ (i : ι), Filter.Eventually (fun x => p x) (MeasureTheory.ae (μ.restrict (s i))))","decl":"theorem ae_restrict_iUnion_iff [Countable ι] (s : ι → Set α) (p : α → Prop) :\n    (∀ᵐ x ∂μ.restrict (⋃ i, s i), p x) ↔ ∀ i, ∀ᵐ x ∂μ.restrict (s i), p x := by simp\n\n"}
{"name":"MeasureTheory.ae_restrict_union_iff","module":"Mathlib.MeasureTheory.Measure.Restrict","initialProofState":"α : Type u_2\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns t : Set α\np : α → Prop\n⊢ Iff (Filter.Eventually (fun x => p x) (MeasureTheory.ae (μ.restrict (Union.union s t)))) (And (Filter.Eventually (fun x => p x) (MeasureTheory.ae (μ.restrict s))) (Filter.Eventually (fun x => p x) (MeasureTheory.ae (μ.restrict t))))","decl":"theorem ae_restrict_union_iff (s t : Set α) (p : α → Prop) :\n    (∀ᵐ x ∂μ.restrict (s ∪ t), p x) ↔ (∀ᵐ x ∂μ.restrict s, p x) ∧ ∀ᵐ x ∂μ.restrict t, p x := by simp\n\n"}
{"name":"MeasureTheory.ae_restrict_biUnion_iff","module":"Mathlib.MeasureTheory.Measure.Restrict","initialProofState":"α : Type u_2\nι : Type u_6\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : ι → Set α\nt : Set ι\nht : t.Countable\np : α → Prop\n⊢ Iff (Filter.Eventually (fun x => p x) (MeasureTheory.ae (μ.restrict (Set.iUnion fun i => Set.iUnion fun h => s i)))) (∀ (i : ι), Membership.mem t i → Filter.Eventually (fun x => p x) (MeasureTheory.ae (μ.restrict (s i))))","decl":"theorem ae_restrict_biUnion_iff (s : ι → Set α) {t : Set ι} (ht : t.Countable) (p : α → Prop) :\n    (∀ᵐ x ∂μ.restrict (⋃ i ∈ t, s i), p x) ↔ ∀ i ∈ t, ∀ᵐ x ∂μ.restrict (s i), p x := by\n  simp_rw [Filter.Eventually, ae_restrict_biUnion_eq s ht, mem_iSup]\n\n"}
{"name":"MeasureTheory.ae_restrict_biUnion_finset_iff","module":"Mathlib.MeasureTheory.Measure.Restrict","initialProofState":"α : Type u_2\nι : Type u_6\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : ι → Set α\nt : Finset ι\np : α → Prop\n⊢ Iff (Filter.Eventually (fun x => p x) (MeasureTheory.ae (μ.restrict (Set.iUnion fun i => Set.iUnion fun h => s i)))) (∀ (i : ι), Membership.mem t i → Filter.Eventually (fun x => p x) (MeasureTheory.ae (μ.restrict (s i))))","decl":"@[simp]\ntheorem ae_restrict_biUnion_finset_iff (s : ι → Set α) (t : Finset ι) (p : α → Prop) :\n    (∀ᵐ x ∂μ.restrict (⋃ i ∈ t, s i), p x) ↔ ∀ i ∈ t, ∀ᵐ x ∂μ.restrict (s i), p x := by\n  simp_rw [Filter.Eventually, ae_restrict_biUnion_finset_eq s, mem_iSup]\n\n"}
{"name":"MeasureTheory.ae_eq_restrict_iUnion_iff","module":"Mathlib.MeasureTheory.Measure.Restrict","initialProofState":"α : Type u_2\nδ : Type u_4\nι : Type u_6\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : Countable ι\ns : ι → Set α\nf g : α → δ\n⊢ Iff ((MeasureTheory.ae (μ.restrict (Set.iUnion fun i => s i))).EventuallyEq f g) (∀ (i : ι), (MeasureTheory.ae (μ.restrict (s i))).EventuallyEq f g)","decl":"theorem ae_eq_restrict_iUnion_iff [Countable ι] (s : ι → Set α) (f g : α → δ) :\n    f =ᵐ[μ.restrict (⋃ i, s i)] g ↔ ∀ i, f =ᵐ[μ.restrict (s i)] g := by\n  simp_rw [EventuallyEq, ae_restrict_iUnion_eq, eventually_iSup]\n\n"}
{"name":"MeasureTheory.ae_eq_restrict_biUnion_iff","module":"Mathlib.MeasureTheory.Measure.Restrict","initialProofState":"α : Type u_2\nδ : Type u_4\nι : Type u_6\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : ι → Set α\nt : Set ι\nht : t.Countable\nf g : α → δ\n⊢ Iff ((MeasureTheory.ae (μ.restrict (Set.iUnion fun i => Set.iUnion fun h => s i))).EventuallyEq f g) (∀ (i : ι), Membership.mem t i → (MeasureTheory.ae (μ.restrict (s i))).EventuallyEq f g)","decl":"theorem ae_eq_restrict_biUnion_iff (s : ι → Set α) {t : Set ι} (ht : t.Countable) (f g : α → δ) :\n    f =ᵐ[μ.restrict (⋃ i ∈ t, s i)] g ↔ ∀ i ∈ t, f =ᵐ[μ.restrict (s i)] g := by\n  simp_rw [ae_restrict_biUnion_eq s ht, EventuallyEq, eventually_iSup]\n\n"}
{"name":"MeasureTheory.ae_eq_restrict_biUnion_finset_iff","module":"Mathlib.MeasureTheory.Measure.Restrict","initialProofState":"α : Type u_2\nδ : Type u_4\nι : Type u_6\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : ι → Set α\nt : Finset ι\nf g : α → δ\n⊢ Iff ((MeasureTheory.ae (μ.restrict (Set.iUnion fun i => Set.iUnion fun h => s i))).EventuallyEq f g) (∀ (i : ι), Membership.mem t i → (MeasureTheory.ae (μ.restrict (s i))).EventuallyEq f g)","decl":"theorem ae_eq_restrict_biUnion_finset_iff (s : ι → Set α) (t : Finset ι) (f g : α → δ) :\n    f =ᵐ[μ.restrict (⋃ i ∈ t, s i)] g ↔ ∀ i ∈ t, f =ᵐ[μ.restrict (s i)] g :=\n  ae_eq_restrict_biUnion_iff s t.countable_toSet f g\n\n"}
{"name":"MeasureTheory.ae_restrict_uIoc_eq","module":"Mathlib.MeasureTheory.Measure.Restrict","initialProofState":"α : Type u_2\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : LinearOrder α\na b : α\n⊢ Eq (MeasureTheory.ae (μ.restrict (Set.uIoc a b))) (Max.max (MeasureTheory.ae (μ.restrict (Set.Ioc a b))) (MeasureTheory.ae (μ.restrict (Set.Ioc b a))))","decl":"theorem ae_restrict_uIoc_eq [LinearOrder α] (a b : α) :\n    ae (μ.restrict (Ι a b)) = ae (μ.restrict (Ioc a b)) ⊔ ae (μ.restrict (Ioc b a)) := by\n  simp only [uIoc_eq_union, ae_restrict_union_eq]\n\n"}
{"name":"MeasureTheory.ae_restrict_uIoc_iff","module":"Mathlib.MeasureTheory.Measure.Restrict","initialProofState":"α : Type u_2\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : LinearOrder α\na b : α\nP : α → Prop\n⊢ Iff (Filter.Eventually (fun x => P x) (MeasureTheory.ae (μ.restrict (Set.uIoc a b)))) (And (Filter.Eventually (fun x => P x) (MeasureTheory.ae (μ.restrict (Set.Ioc a b)))) (Filter.Eventually (fun x => P x) (MeasureTheory.ae (μ.restrict (Set.Ioc b a)))))","decl":"/-- See also `MeasureTheory.ae_uIoc_iff`. -/\ntheorem ae_restrict_uIoc_iff [LinearOrder α] {a b : α} {P : α → Prop} :\n    (∀ᵐ x ∂μ.restrict (Ι a b), P x) ↔\n      (∀ᵐ x ∂μ.restrict (Ioc a b), P x) ∧ ∀ᵐ x ∂μ.restrict (Ioc b a), P x := by\n  rw [ae_restrict_uIoc_eq, eventually_sup]\n\n"}
{"name":"MeasureTheory.ae_restrict_iff₀","module":"Mathlib.MeasureTheory.Measure.Restrict","initialProofState":"α : Type u_2\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : Set α\np : α → Prop\nhp : MeasureTheory.NullMeasurableSet (setOf fun x => p x) (μ.restrict s)\n⊢ Iff (Filter.Eventually (fun x => p x) (MeasureTheory.ae (μ.restrict s))) (Filter.Eventually (fun x => Membership.mem s x → p x) (MeasureTheory.ae μ))","decl":"theorem ae_restrict_iff₀ {p : α → Prop} (hp : NullMeasurableSet { x | p x } (μ.restrict s)) :\n    (∀ᵐ x ∂μ.restrict s, p x) ↔ ∀ᵐ x ∂μ, x ∈ s → p x := by\n  simp only [ae_iff, ← compl_setOf, Measure.restrict_apply₀ hp.compl]\n  rw [iff_iff_eq]; congr with x; simp [and_comm]\n\n"}
{"name":"MeasureTheory.ae_restrict_iff","module":"Mathlib.MeasureTheory.Measure.Restrict","initialProofState":"α : Type u_2\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : Set α\np : α → Prop\nhp : MeasurableSet (setOf fun x => p x)\n⊢ Iff (Filter.Eventually (fun x => p x) (MeasureTheory.ae (μ.restrict s))) (Filter.Eventually (fun x => Membership.mem s x → p x) (MeasureTheory.ae μ))","decl":"theorem ae_restrict_iff {p : α → Prop} (hp : MeasurableSet { x | p x }) :\n    (∀ᵐ x ∂μ.restrict s, p x) ↔ ∀ᵐ x ∂μ, x ∈ s → p x :=\n  ae_restrict_iff₀ hp.nullMeasurableSet\n\n"}
{"name":"MeasureTheory.ae_imp_of_ae_restrict","module":"Mathlib.MeasureTheory.Measure.Restrict","initialProofState":"α : Type u_2\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : Set α\np : α → Prop\nh : Filter.Eventually (fun x => p x) (MeasureTheory.ae (μ.restrict s))\n⊢ Filter.Eventually (fun x => Membership.mem s x → p x) (MeasureTheory.ae μ)","decl":"theorem ae_imp_of_ae_restrict {s : Set α} {p : α → Prop} (h : ∀ᵐ x ∂μ.restrict s, p x) :\n    ∀ᵐ x ∂μ, x ∈ s → p x := by\n  simp only [ae_iff] at h ⊢\n  simpa [setOf_and, inter_comm] using measure_inter_eq_zero_of_restrict h\n\n"}
{"name":"MeasureTheory.ae_restrict_iff'₀","module":"Mathlib.MeasureTheory.Measure.Restrict","initialProofState":"α : Type u_2\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : Set α\np : α → Prop\nhs : MeasureTheory.NullMeasurableSet s μ\n⊢ Iff (Filter.Eventually (fun x => p x) (MeasureTheory.ae (μ.restrict s))) (Filter.Eventually (fun x => Membership.mem s x → p x) (MeasureTheory.ae μ))","decl":"theorem ae_restrict_iff'₀ {p : α → Prop} (hs : NullMeasurableSet s μ) :\n    (∀ᵐ x ∂μ.restrict s, p x) ↔ ∀ᵐ x ∂μ, x ∈ s → p x := by\n  simp only [ae_iff, ← compl_setOf, restrict_apply₀' hs]\n  rw [iff_iff_eq]; congr with x; simp [and_comm]\n\n"}
{"name":"MeasureTheory.ae_restrict_iff'","module":"Mathlib.MeasureTheory.Measure.Restrict","initialProofState":"α : Type u_2\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : Set α\np : α → Prop\nhs : MeasurableSet s\n⊢ Iff (Filter.Eventually (fun x => p x) (MeasureTheory.ae (μ.restrict s))) (Filter.Eventually (fun x => Membership.mem s x → p x) (MeasureTheory.ae μ))","decl":"theorem ae_restrict_iff' {p : α → Prop} (hs : MeasurableSet s) :\n    (∀ᵐ x ∂μ.restrict s, p x) ↔ ∀ᵐ x ∂μ, x ∈ s → p x :=\n  ae_restrict_iff'₀ hs.nullMeasurableSet\n\n"}
{"name":"Filter.EventuallyEq.restrict","module":"Mathlib.MeasureTheory.Measure.Restrict","initialProofState":"α : Type u_2\nδ : Type u_4\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf g : α → δ\ns : Set α\nhfg : (MeasureTheory.ae μ).EventuallyEq f g\n⊢ (MeasureTheory.ae (μ.restrict s)).EventuallyEq f g","decl":"theorem _root_.Filter.EventuallyEq.restrict {f g : α → δ} {s : Set α} (hfg : f =ᵐ[μ] g) :\n    f =ᵐ[μ.restrict s] g := by\n  -- note that we cannot use `ae_restrict_iff` since we do not require measurability\n  refine hfg.filter_mono ?_\n  rw [Measure.ae_le_iff_absolutelyContinuous]\n  exact Measure.absolutelyContinuous_of_le Measure.restrict_le_self\n\n"}
{"name":"MeasureTheory.ae_restrict_mem₀","module":"Mathlib.MeasureTheory.Measure.Restrict","initialProofState":"α : Type u_2\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : Set α\nhs : MeasureTheory.NullMeasurableSet s μ\n⊢ Filter.Eventually (fun x => Membership.mem s x) (MeasureTheory.ae (μ.restrict s))","decl":"theorem ae_restrict_mem₀ (hs : NullMeasurableSet s μ) : ∀ᵐ x ∂μ.restrict s, x ∈ s :=\n  (ae_restrict_iff'₀ hs).2 (Filter.Eventually.of_forall fun _ => id)\n\n"}
{"name":"MeasureTheory.ae_restrict_mem","module":"Mathlib.MeasureTheory.Measure.Restrict","initialProofState":"α : Type u_2\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : Set α\nhs : MeasurableSet s\n⊢ Filter.Eventually (fun x => Membership.mem s x) (MeasureTheory.ae (μ.restrict s))","decl":"theorem ae_restrict_mem (hs : MeasurableSet s) : ∀ᵐ x ∂μ.restrict s, x ∈ s :=\n  ae_restrict_mem₀ hs.nullMeasurableSet\n\n"}
{"name":"MeasureTheory.ae_restrict_of_forall_mem","module":"Mathlib.MeasureTheory.Measure.Restrict","initialProofState":"α : Type u_2\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : Set α\nhs : MeasurableSet s\np : α → Prop\nh : ∀ (x : α), Membership.mem s x → p x\n⊢ Filter.Eventually (fun x => p x) (MeasureTheory.ae (μ.restrict s))","decl":"theorem ae_restrict_of_forall_mem {μ : Measure α} {s : Set α}\n    (hs : MeasurableSet s) {p : α → Prop} (h : ∀ x ∈ s, p x) : ∀ᵐ (x : α) ∂μ.restrict s, p x :=\n  (ae_restrict_mem hs).mono h\n\n"}
{"name":"MeasureTheory.ae_restrict_of_ae","module":"Mathlib.MeasureTheory.Measure.Restrict","initialProofState":"α : Type u_2\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : Set α\np : α → Prop\nh : Filter.Eventually (fun x => p x) (MeasureTheory.ae μ)\n⊢ Filter.Eventually (fun x => p x) (MeasureTheory.ae (μ.restrict s))","decl":"theorem ae_restrict_of_ae {s : Set α} {p : α → Prop} (h : ∀ᵐ x ∂μ, p x) : ∀ᵐ x ∂μ.restrict s, p x :=\n  h.filter_mono (ae_mono Measure.restrict_le_self)\n\n"}
{"name":"MeasureTheory.ae_restrict_of_ae_restrict_of_subset","module":"Mathlib.MeasureTheory.Measure.Restrict","initialProofState":"α : Type u_2\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns t : Set α\np : α → Prop\nhst : HasSubset.Subset s t\nh : Filter.Eventually (fun x => p x) (MeasureTheory.ae (μ.restrict t))\n⊢ Filter.Eventually (fun x => p x) (MeasureTheory.ae (μ.restrict s))","decl":"theorem ae_restrict_of_ae_restrict_of_subset {s t : Set α} {p : α → Prop} (hst : s ⊆ t)\n    (h : ∀ᵐ x ∂μ.restrict t, p x) : ∀ᵐ x ∂μ.restrict s, p x :=\n  h.filter_mono (ae_mono <| Measure.restrict_mono hst (le_refl μ))\n\n"}
{"name":"MeasureTheory.ae_of_ae_restrict_of_ae_restrict_compl","module":"Mathlib.MeasureTheory.Measure.Restrict","initialProofState":"α : Type u_2\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nt : Set α\np : α → Prop\nht : Filter.Eventually (fun x => p x) (MeasureTheory.ae (μ.restrict t))\nhtc : Filter.Eventually (fun x => p x) (MeasureTheory.ae (μ.restrict (HasCompl.compl t)))\n⊢ Filter.Eventually (fun x => p x) (MeasureTheory.ae μ)","decl":"theorem ae_of_ae_restrict_of_ae_restrict_compl (t : Set α) {p : α → Prop}\n    (ht : ∀ᵐ x ∂μ.restrict t, p x) (htc : ∀ᵐ x ∂μ.restrict tᶜ, p x) : ∀ᵐ x ∂μ, p x :=\n  nonpos_iff_eq_zero.1 <|\n    calc\n      μ { x | ¬p x } ≤ μ ({ x | ¬p x } ∩ t) + μ ({ x | ¬p x } ∩ tᶜ) :=\n        measure_le_inter_add_diff _ _ _\n      _ ≤ μ.restrict t { x | ¬p x } + μ.restrict tᶜ { x | ¬p x } :=\n        add_le_add (le_restrict_apply _ _) (le_restrict_apply _ _)\n      _ = 0 := by rw [ae_iff.1 ht, ae_iff.1 htc, zero_add]\n\n"}
{"name":"MeasureTheory.mem_map_restrict_ae_iff","module":"Mathlib.MeasureTheory.Measure.Restrict","initialProofState":"α : Type u_2\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nβ : Type u_7\ns : Set α\nt : Set β\nf : α → β\nhs : MeasurableSet s\n⊢ Iff (Membership.mem (Filter.map f (MeasureTheory.ae (μ.restrict s))) t) (Eq (μ (Inter.inter (HasCompl.compl (Set.preimage f t)) s)) 0)","decl":"theorem mem_map_restrict_ae_iff {β} {s : Set α} {t : Set β} {f : α → β} (hs : MeasurableSet s) :\n    t ∈ Filter.map f (ae (μ.restrict s)) ↔ μ ((f ⁻¹' t)ᶜ ∩ s) = 0 := by\n  rw [mem_map, mem_ae_iff, Measure.restrict_apply' hs]\n\n"}
{"name":"MeasureTheory.ae_add_measure_iff","module":"Mathlib.MeasureTheory.Measure.Restrict","initialProofState":"α : Type u_2\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\np : α → Prop\nν : MeasureTheory.Measure α\n⊢ Iff (Filter.Eventually (fun x => p x) (MeasureTheory.ae (HAdd.hAdd μ ν))) (And (Filter.Eventually (fun x => p x) (MeasureTheory.ae μ)) (Filter.Eventually (fun x => p x) (MeasureTheory.ae ν)))","decl":"theorem ae_add_measure_iff {p : α → Prop} {ν} :\n    (∀ᵐ x ∂μ + ν, p x) ↔ (∀ᵐ x ∂μ, p x) ∧ ∀ᵐ x ∂ν, p x :=\n  add_eq_zero\n\n"}
{"name":"MeasureTheory.ae_eq_comp'","module":"Mathlib.MeasureTheory.Measure.Restrict","initialProofState":"α : Type u_2\nβ : Type u_3\nδ : Type u_4\nm0 : MeasurableSpace α\ninst✝ : MeasurableSpace β\nμ : MeasureTheory.Measure α\nν : MeasureTheory.Measure β\nf : α → β\ng g' : β → δ\nhf : AEMeasurable f μ\nh : (MeasureTheory.ae ν).EventuallyEq g g'\nh2 : (MeasureTheory.Measure.map f μ).AbsolutelyContinuous ν\n⊢ (MeasureTheory.ae μ).EventuallyEq (Function.comp g f) (Function.comp g' f)","decl":"theorem ae_eq_comp' {ν : Measure β} {f : α → β} {g g' : β → δ} (hf : AEMeasurable f μ)\n    (h : g =ᵐ[ν] g') (h2 : μ.map f ≪ ν) : g ∘ f =ᵐ[μ] g' ∘ f :=\n  (tendsto_ae_map hf).mono_right h2.ae_le h\n\n"}
{"name":"MeasureTheory.Measure.QuasiMeasurePreserving.ae_eq_comp","module":"Mathlib.MeasureTheory.Measure.Restrict","initialProofState":"α : Type u_2\nβ : Type u_3\nδ : Type u_4\nm0 : MeasurableSpace α\ninst✝ : MeasurableSpace β\nμ : MeasureTheory.Measure α\nν : MeasureTheory.Measure β\nf : α → β\ng g' : β → δ\nhf : MeasureTheory.Measure.QuasiMeasurePreserving f μ ν\nh : (MeasureTheory.ae ν).EventuallyEq g g'\n⊢ (MeasureTheory.ae μ).EventuallyEq (Function.comp g f) (Function.comp g' f)","decl":"theorem Measure.QuasiMeasurePreserving.ae_eq_comp {ν : Measure β} {f : α → β} {g g' : β → δ}\n    (hf : QuasiMeasurePreserving f μ ν) (h : g =ᵐ[ν] g') : g ∘ f =ᵐ[μ] g' ∘ f :=\n  ae_eq_comp' hf.aemeasurable h hf.absolutelyContinuous\n\n"}
{"name":"MeasureTheory.ae_eq_comp","module":"Mathlib.MeasureTheory.Measure.Restrict","initialProofState":"α : Type u_2\nβ : Type u_3\nδ : Type u_4\nm0 : MeasurableSpace α\ninst✝ : MeasurableSpace β\nμ : MeasureTheory.Measure α\nf : α → β\ng g' : β → δ\nhf : AEMeasurable f μ\nh : (MeasureTheory.ae (MeasureTheory.Measure.map f μ)).EventuallyEq g g'\n⊢ (MeasureTheory.ae μ).EventuallyEq (Function.comp g f) (Function.comp g' f)","decl":"theorem ae_eq_comp {f : α → β} {g g' : β → δ} (hf : AEMeasurable f μ) (h : g =ᵐ[μ.map f] g') :\n    g ∘ f =ᵐ[μ] g' ∘ f :=\n  ae_eq_comp' hf h AbsolutelyContinuous.rfl\n\n"}
{"name":"MeasureTheory.div_ae_eq_one","module":"Mathlib.MeasureTheory.Measure.Restrict","initialProofState":"α : Type u_2\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nβ : Type u_7\ninst✝ : Group β\nf g : α → β\n⊢ Iff ((MeasureTheory.ae μ).EventuallyEq (HDiv.hDiv f g) 1) ((MeasureTheory.ae μ).EventuallyEq f g)","decl":"@[to_additive]\ntheorem div_ae_eq_one {β} [Group β] (f g : α → β) : f / g =ᵐ[μ] 1 ↔ f =ᵐ[μ] g := by\n  refine ⟨fun h ↦ h.mono fun x hx ↦ ?_, fun h ↦ h.mono fun x hx ↦ ?_⟩\n  · rwa [Pi.div_apply, Pi.one_apply, div_eq_one] at hx\n  · rwa [Pi.div_apply, Pi.one_apply, div_eq_one]\n\n"}
{"name":"MeasureTheory.sub_ae_eq_zero","module":"Mathlib.MeasureTheory.Measure.Restrict","initialProofState":"α : Type u_2\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nβ : Type u_7\ninst✝ : AddGroup β\nf g : α → β\n⊢ Iff ((MeasureTheory.ae μ).EventuallyEq (HSub.hSub f g) 0) ((MeasureTheory.ae μ).EventuallyEq f g)","decl":"@[to_additive]\ntheorem div_ae_eq_one {β} [Group β] (f g : α → β) : f / g =ᵐ[μ] 1 ↔ f =ᵐ[μ] g := by\n  refine ⟨fun h ↦ h.mono fun x hx ↦ ?_, fun h ↦ h.mono fun x hx ↦ ?_⟩\n  · rwa [Pi.div_apply, Pi.one_apply, div_eq_one] at hx\n  · rwa [Pi.div_apply, Pi.one_apply, div_eq_one]\n\n"}
{"name":"MeasureTheory.sub_nonneg_ae","module":"Mathlib.MeasureTheory.Measure.Restrict","initialProofState":"α : Type u_2\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nβ : Type u_7\ninst✝² : AddGroup β\ninst✝¹ : LE β\ninst✝ : AddRightMono β\nf g : α → β\n⊢ Iff ((MeasureTheory.ae μ).EventuallyLE 0 (HSub.hSub g f)) ((MeasureTheory.ae μ).EventuallyLE f g)","decl":"@[to_additive sub_nonneg_ae]\nlemma one_le_div_ae {β : Type*} [Group β] [LE β] [MulRightMono β] (f g : α → β) :\n    1 ≤ᵐ[μ] g / f ↔ f ≤ᵐ[μ] g := by\n  refine ⟨fun h ↦ h.mono fun a ha ↦ ?_, fun h ↦ h.mono fun a ha ↦ ?_⟩\n  · rwa [Pi.one_apply, Pi.div_apply, one_le_div'] at ha\n  · rwa [Pi.one_apply, Pi.div_apply, one_le_div']\n\n"}
{"name":"MeasureTheory.one_le_div_ae","module":"Mathlib.MeasureTheory.Measure.Restrict","initialProofState":"α : Type u_2\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nβ : Type u_7\ninst✝² : Group β\ninst✝¹ : LE β\ninst✝ : MulRightMono β\nf g : α → β\n⊢ Iff ((MeasureTheory.ae μ).EventuallyLE 1 (HDiv.hDiv g f)) ((MeasureTheory.ae μ).EventuallyLE f g)","decl":"@[to_additive sub_nonneg_ae]\nlemma one_le_div_ae {β : Type*} [Group β] [LE β] [MulRightMono β] (f g : α → β) :\n    1 ≤ᵐ[μ] g / f ↔ f ≤ᵐ[μ] g := by\n  refine ⟨fun h ↦ h.mono fun a ha ↦ ?_, fun h ↦ h.mono fun a ha ↦ ?_⟩\n  · rwa [Pi.one_apply, Pi.div_apply, one_le_div'] at ha\n  · rwa [Pi.one_apply, Pi.div_apply, one_le_div']\n\n"}
{"name":"MeasureTheory.le_ae_restrict","module":"Mathlib.MeasureTheory.Measure.Restrict","initialProofState":"α : Type u_2\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : Set α\n⊢ LE.le (Min.min (MeasureTheory.ae μ) (Filter.principal s)) (MeasureTheory.ae (μ.restrict s))","decl":"theorem le_ae_restrict : ae μ ⊓ 𝓟 s ≤ ae (μ.restrict s) := fun _s hs =>\n  eventually_inf_principal.2 (ae_imp_of_ae_restrict hs)\n\n"}
{"name":"MeasureTheory.ae_restrict_eq","module":"Mathlib.MeasureTheory.Measure.Restrict","initialProofState":"α : Type u_2\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : Set α\nhs : MeasurableSet s\n⊢ Eq (MeasureTheory.ae (μ.restrict s)) (Min.min (MeasureTheory.ae μ) (Filter.principal s))","decl":"@[simp]\ntheorem ae_restrict_eq (hs : MeasurableSet s) : ae (μ.restrict s) = ae μ ⊓ 𝓟 s := by\n  ext t\n  simp only [mem_inf_principal, mem_ae_iff, restrict_apply_eq_zero' hs, compl_setOf,\n    Classical.not_imp, fun a => and_comm (a := a ∈ s) (b := ¬a ∈ t)]\n  rfl\n\n"}
{"name":"MeasureTheory.ae_restrict_le","module":"Mathlib.MeasureTheory.Measure.Restrict","initialProofState":"α : Type u_2\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : Set α\n⊢ LE.le (MeasureTheory.ae (μ.restrict s)) (MeasureTheory.ae μ)","decl":"lemma ae_restrict_le : ae (μ.restrict s) ≤ ae μ :=\n  ae_mono restrict_le_self\n\n"}
{"name":"MeasureTheory.ae_restrict_eq_bot","module":"Mathlib.MeasureTheory.Measure.Restrict","initialProofState":"α : Type u_2\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : Set α\n⊢ Iff (Eq (MeasureTheory.ae (μ.restrict s)) Bot.bot) (Eq (μ s) 0)","decl":"theorem ae_restrict_eq_bot {s} : ae (μ.restrict s) = ⊥ ↔ μ s = 0 :=\n  ae_eq_bot.trans restrict_eq_zero\n\n"}
{"name":"MeasureTheory.ae_restrict_neBot","module":"Mathlib.MeasureTheory.Measure.Restrict","initialProofState":"α : Type u_2\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : Set α\n⊢ Iff (MeasureTheory.ae (μ.restrict s)).NeBot (Ne (μ s) 0)","decl":"theorem ae_restrict_neBot {s} : (ae <| μ.restrict s).NeBot ↔ μ s ≠ 0 :=\n  neBot_iff.trans ae_restrict_eq_bot.not\n\n"}
{"name":"MeasureTheory.self_mem_ae_restrict","module":"Mathlib.MeasureTheory.Measure.Restrict","initialProofState":"α : Type u_2\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : Set α\nhs : MeasurableSet s\n⊢ Membership.mem (MeasureTheory.ae (μ.restrict s)) s","decl":"theorem self_mem_ae_restrict {s} (hs : MeasurableSet s) : s ∈ ae (μ.restrict s) := by\n  simp only [ae_restrict_eq hs, exists_prop, mem_principal, mem_inf_iff]\n  exact ⟨_, univ_mem, s, Subset.rfl, (univ_inter s).symm⟩\n\n"}
{"name":"MeasureTheory.ae_restrict_of_ae_eq_of_ae_restrict","module":"Mathlib.MeasureTheory.Measure.Restrict","initialProofState":"α : Type u_2\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns t : α → Prop\nhst : (MeasureTheory.ae μ).EventuallyEq s t\np : α → Prop\na✝ : Filter.Eventually (fun x => p x) (MeasureTheory.ae (μ.restrict s))\n⊢ Filter.Eventually (fun x => p x) (MeasureTheory.ae (μ.restrict t))","decl":"/-- If two measurable sets are ae_eq then any proposition that is almost everywhere true on one\nis almost everywhere true on the other -/\ntheorem ae_restrict_of_ae_eq_of_ae_restrict {s t} (hst : s =ᵐ[μ] t) {p : α → Prop} :\n    (∀ᵐ x ∂μ.restrict s, p x) → ∀ᵐ x ∂μ.restrict t, p x := by simp [Measure.restrict_congr_set hst]\n\n"}
{"name":"MeasureTheory.ae_restrict_congr_set","module":"Mathlib.MeasureTheory.Measure.Restrict","initialProofState":"α : Type u_2\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns t : α → Prop\nhst : (MeasureTheory.ae μ).EventuallyEq s t\np : α → Prop\n⊢ Iff (Filter.Eventually (fun x => p x) (MeasureTheory.ae (μ.restrict s))) (Filter.Eventually (fun x => p x) (MeasureTheory.ae (μ.restrict t)))","decl":"/-- If two measurable sets are ae_eq then any proposition that is almost everywhere true on one\nis almost everywhere true on the other -/\ntheorem ae_restrict_congr_set {s t} (hst : s =ᵐ[μ] t) {p : α → Prop} :\n    (∀ᵐ x ∂μ.restrict s, p x) ↔ ∀ᵐ x ∂μ.restrict t, p x :=\n  ⟨ae_restrict_of_ae_eq_of_ae_restrict hst, ae_restrict_of_ae_eq_of_ae_restrict hst.symm⟩\n\n"}
{"name":"MeasureTheory.NullMeasurable.measure_preimage_eq_measure_restrict_preimage_of_ae_compl_eq_const","module":"Mathlib.MeasureTheory.Measure.Restrict","initialProofState":"α : Type u_2\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nβ : Type u_7\ninst✝ : MeasurableSpace β\nb : β\nf : α → β\ns : Set α\nf_mble : MeasureTheory.NullMeasurable f (μ.restrict s)\nhs : (MeasureTheory.ae (μ.restrict (HasCompl.compl s))).EventuallyEq f fun x => b\nt : Set β\nt_mble : MeasurableSet t\nht : Not (Membership.mem t b)\n⊢ Eq (μ (Set.preimage f t)) ((μ.restrict s) (Set.preimage f t))","decl":"lemma NullMeasurable.measure_preimage_eq_measure_restrict_preimage_of_ae_compl_eq_const\n    {β : Type*} [MeasurableSpace β] {b : β} {f : α → β} {s : Set α}\n    (f_mble : NullMeasurable f (μ.restrict s)) (hs : f =ᵐ[Measure.restrict μ sᶜ] (fun _ ↦ b))\n    {t : Set β} (t_mble : MeasurableSet t) (ht : b ∉ t) :\n    μ (f ⁻¹' t) = μ.restrict s (f ⁻¹' t) := by\n  rw [Measure.restrict_apply₀ (f_mble t_mble)]\n  rw [EventuallyEq, ae_iff, Measure.restrict_apply₀] at hs\n  · apply le_antisymm _ (measure_mono inter_subset_left)\n    apply (measure_mono (Eq.symm (inter_union_compl (f ⁻¹' t) s)).le).trans\n    apply (measure_union_le _ _).trans\n    have obs : μ ((f ⁻¹' t) ∩ sᶜ) = 0 := by\n      apply le_antisymm _ (zero_le _)\n      rw [← hs]\n      apply measure_mono (inter_subset_inter_left _ _)\n      intro x hx hfx\n      simp only [mem_preimage, mem_setOf_eq] at hx hfx\n      exact ht (hfx ▸ hx)\n    simp only [obs, add_zero, le_refl]\n  · exact NullMeasurableSet.of_null hs\n\n"}
{"name":"MeasureTheory.Measure.MeasurableSet.nullMeasurableSet_subtype_coe","module":"Mathlib.MeasureTheory.Measure.Restrict","initialProofState":"α : Type u_2\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : Set α\nt : Set ↑s\nhs : MeasureTheory.NullMeasurableSet s μ\nht : MeasurableSet t\n⊢ MeasureTheory.NullMeasurableSet (Set.image Subtype.val t) μ","decl":"theorem MeasurableSet.nullMeasurableSet_subtype_coe {t : Set s} (hs : NullMeasurableSet s μ)\n    (ht : MeasurableSet t) : NullMeasurableSet ((↑) '' t) μ := by\n  rw [Subtype.instMeasurableSpace, comap_eq_generateFrom] at ht\n  induction t, ht using generateFrom_induction with\n  | hC t' ht' =>\n    obtain ⟨s', hs', rfl⟩ := ht'\n    rw [Subtype.image_preimage_coe]\n    exact hs.inter (hs'.nullMeasurableSet)\n  | empty => simp only [image_empty, nullMeasurableSet_empty]\n  | compl t' _ ht' =>\n    simp only [← range_diff_image Subtype.coe_injective, Subtype.range_coe_subtype, setOf_mem_eq]\n    exact hs.diff ht'\n  | iUnion f _ hf =>\n    dsimp only []\n    rw [image_iUnion]\n    exact .iUnion hf\n\n"}
{"name":"MeasureTheory.Measure.NullMeasurableSet.subtype_coe","module":"Mathlib.MeasureTheory.Measure.Restrict","initialProofState":"α : Type u_2\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : Set α\nt : Set ↑s\nhs : MeasureTheory.NullMeasurableSet s μ\nht : MeasureTheory.NullMeasurableSet t (MeasureTheory.Measure.comap Subtype.val μ)\n⊢ MeasureTheory.NullMeasurableSet (Set.image Subtype.val t) μ","decl":"theorem NullMeasurableSet.subtype_coe {t : Set s} (hs : NullMeasurableSet s μ)\n    (ht : NullMeasurableSet t (μ.comap Subtype.val)) : NullMeasurableSet (((↑) : s → α) '' t) μ :=\n  NullMeasurableSet.image _ μ Subtype.coe_injective\n    (fun _ => MeasurableSet.nullMeasurableSet_subtype_coe hs) ht\n\n"}
{"name":"MeasureTheory.Measure.measure_subtype_coe_le_comap","module":"Mathlib.MeasureTheory.Measure.Restrict","initialProofState":"α : Type u_2\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : Set α\nhs : MeasureTheory.NullMeasurableSet s μ\nt : Set ↑s\n⊢ LE.le (μ (Set.image Subtype.val t)) ((MeasureTheory.Measure.comap Subtype.val μ) t)","decl":"theorem measure_subtype_coe_le_comap (hs : NullMeasurableSet s μ) (t : Set s) :\n    μ (((↑) : s → α) '' t) ≤ μ.comap Subtype.val t :=\n  le_comap_apply _ _ Subtype.coe_injective (fun _ =>\n    MeasurableSet.nullMeasurableSet_subtype_coe hs) _\n\n"}
{"name":"MeasureTheory.Measure.measure_subtype_coe_eq_zero_of_comap_eq_zero","module":"Mathlib.MeasureTheory.Measure.Restrict","initialProofState":"α : Type u_2\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : Set α\nhs : MeasureTheory.NullMeasurableSet s μ\nt : Set ↑s\nht : Eq ((MeasureTheory.Measure.comap Subtype.val μ) t) 0\n⊢ Eq (μ (Set.image Subtype.val t)) 0","decl":"theorem measure_subtype_coe_eq_zero_of_comap_eq_zero (hs : NullMeasurableSet s μ) {t : Set s}\n    (ht : μ.comap Subtype.val t = 0) : μ (((↑) : s → α) '' t) = 0 :=\n  eq_bot_iff.mpr <| (measure_subtype_coe_le_comap hs t).trans ht.le\n\n"}
{"name":"MeasureTheory.Measure.Subtype.volume_def","module":"Mathlib.MeasureTheory.Measure.Restrict","initialProofState":"δ : Type u_4\nu : Set δ\ninst✝ : MeasureTheory.MeasureSpace δ\n⊢ Eq MeasureTheory.MeasureSpace.volume (MeasureTheory.Measure.comap Subtype.val MeasureTheory.MeasureSpace.volume)","decl":"theorem Subtype.volume_def : (volume : Measure u) = volume.comap Subtype.val :=\n  rfl\n\n"}
{"name":"MeasureTheory.Measure.Subtype.volume_univ","module":"Mathlib.MeasureTheory.Measure.Restrict","initialProofState":"δ : Type u_4\nu : Set δ\ninst✝ : MeasureTheory.MeasureSpace δ\nhu : MeasureTheory.NullMeasurableSet u MeasureTheory.MeasureSpace.volume\n⊢ Eq (MeasureTheory.MeasureSpace.volume Set.univ) (MeasureTheory.MeasureSpace.volume u)","decl":"theorem Subtype.volume_univ (hu : NullMeasurableSet u) : volume (univ : Set u) = volume u := by\n  rw [Subtype.volume_def, comap_apply₀ _ _ _ _ MeasurableSet.univ.nullMeasurableSet]\n  · congr\n    simp only [image_univ, Subtype.range_coe_subtype, setOf_mem_eq]\n  · exact Subtype.coe_injective\n  · exact fun t => MeasurableSet.nullMeasurableSet_subtype_coe hu\n\n"}
{"name":"MeasureTheory.Measure.volume_subtype_coe_le_volume","module":"Mathlib.MeasureTheory.Measure.Restrict","initialProofState":"δ : Type u_4\nu : Set δ\ninst✝ : MeasureTheory.MeasureSpace δ\nhu : MeasureTheory.NullMeasurableSet u MeasureTheory.MeasureSpace.volume\nt : Set ↑u\n⊢ LE.le (MeasureTheory.MeasureSpace.volume (Set.image Subtype.val t)) (MeasureTheory.MeasureSpace.volume t)","decl":"theorem volume_subtype_coe_le_volume (hu : NullMeasurableSet u) (t : Set u) :\n    volume (((↑) : u → δ) '' t) ≤ volume t :=\n  measure_subtype_coe_le_comap hu t\n\n"}
{"name":"MeasureTheory.Measure.volume_subtype_coe_eq_zero_of_volume_eq_zero","module":"Mathlib.MeasureTheory.Measure.Restrict","initialProofState":"δ : Type u_4\nu : Set δ\ninst✝ : MeasureTheory.MeasureSpace δ\nhu : MeasureTheory.NullMeasurableSet u MeasureTheory.MeasureSpace.volume\nt : Set ↑u\nht : Eq (MeasureTheory.MeasureSpace.volume t) 0\n⊢ Eq (MeasureTheory.MeasureSpace.volume (Set.image Subtype.val t)) 0","decl":"theorem volume_subtype_coe_eq_zero_of_volume_eq_zero (hu : NullMeasurableSet u) {t : Set u}\n    (ht : volume t = 0) : volume (((↑) : u → δ) '' t) = 0 :=\n  measure_subtype_coe_eq_zero_of_comap_eq_zero hu ht\n\n"}
{"name":"MeasurableEmbedding.map_comap","module":"Mathlib.MeasureTheory.Measure.Restrict","initialProofState":"α : Type u_2\nβ : Type u_3\nm0 : MeasurableSpace α\nm1 : MeasurableSpace β\nf : α → β\nhf : MeasurableEmbedding f\nμ : MeasureTheory.Measure β\n⊢ Eq (MeasureTheory.Measure.map f (MeasureTheory.Measure.comap f μ)) (μ.restrict (Set.range f))","decl":"theorem map_comap (μ : Measure β) : (comap f μ).map f = μ.restrict (range f) := by\n  ext1 t ht\n  rw [hf.map_apply, comap_apply f hf.injective hf.measurableSet_image' _ (hf.measurable ht),\n    image_preimage_eq_inter_range, Measure.restrict_apply ht]\n\n"}
{"name":"MeasurableEmbedding.comap_apply","module":"Mathlib.MeasureTheory.Measure.Restrict","initialProofState":"α : Type u_2\nβ : Type u_3\nm0 : MeasurableSpace α\nm1 : MeasurableSpace β\nf : α → β\nhf : MeasurableEmbedding f\nμ : MeasureTheory.Measure β\ns : Set α\n⊢ Eq ((MeasureTheory.Measure.comap f μ) s) (μ (Set.image f s))","decl":"theorem comap_apply (μ : Measure β) (s : Set α) : comap f μ s = μ (f '' s) :=\n  calc\n    comap f μ s = comap f μ (f ⁻¹' (f '' s)) := by rw [hf.injective.preimage_image]\n    _ = (comap f μ).map f (f '' s) := (hf.map_apply _ _).symm\n    _ = μ (f '' s) := by\n      rw [hf.map_comap, restrict_apply' hf.measurableSet_range,\n        inter_eq_self_of_subset_left (image_subset_range _ _)]\n\n"}
{"name":"MeasurableEmbedding.comap_map","module":"Mathlib.MeasureTheory.Measure.Restrict","initialProofState":"α : Type u_2\nβ : Type u_3\nm0 : MeasurableSpace α\nm1 : MeasurableSpace β\nf : α → β\nhf : MeasurableEmbedding f\nμ : MeasureTheory.Measure α\n⊢ Eq (MeasureTheory.Measure.comap f (MeasureTheory.Measure.map f μ)) μ","decl":"theorem comap_map (μ : Measure α) : (map f μ).comap f = μ := by\n  ext t _\n  rw [hf.comap_apply, hf.map_apply, preimage_image_eq _ hf.injective]\n\n"}
{"name":"MeasurableEmbedding.ae_map_iff","module":"Mathlib.MeasureTheory.Measure.Restrict","initialProofState":"α : Type u_2\nβ : Type u_3\nm0 : MeasurableSpace α\nm1 : MeasurableSpace β\nf : α → β\nhf : MeasurableEmbedding f\np : β → Prop\nμ : MeasureTheory.Measure α\n⊢ Iff (Filter.Eventually (fun x => p x) (MeasureTheory.ae (MeasureTheory.Measure.map f μ))) (Filter.Eventually (fun x => p (f x)) (MeasureTheory.ae μ))","decl":"theorem ae_map_iff {p : β → Prop} {μ : Measure α} : (∀ᵐ x ∂μ.map f, p x) ↔ ∀ᵐ x ∂μ, p (f x) := by\n  simp only [ae_iff, hf.map_apply, preimage_setOf_eq]\n\n"}
{"name":"MeasurableEmbedding.restrict_map","module":"Mathlib.MeasureTheory.Measure.Restrict","initialProofState":"α : Type u_2\nβ : Type u_3\nm0 : MeasurableSpace α\nm1 : MeasurableSpace β\nf : α → β\nhf : MeasurableEmbedding f\nμ : MeasureTheory.Measure α\ns : Set β\n⊢ Eq ((MeasureTheory.Measure.map f μ).restrict s) (MeasureTheory.Measure.map f (μ.restrict (Set.preimage f s)))","decl":"theorem restrict_map (μ : Measure α) (s : Set β) :\n    (μ.map f).restrict s = (μ.restrict <| f ⁻¹' s).map f :=\n  Measure.ext fun t ht => by simp [hf.map_apply, ht, hf.measurable ht]\n\n"}
{"name":"MeasurableEmbedding.comap_preimage","module":"Mathlib.MeasureTheory.Measure.Restrict","initialProofState":"α : Type u_2\nβ : Type u_3\nm0 : MeasurableSpace α\nm1 : MeasurableSpace β\nf : α → β\nhf : MeasurableEmbedding f\nμ : MeasureTheory.Measure β\ns : Set β\n⊢ Eq ((MeasureTheory.Measure.comap f μ) (Set.preimage f s)) (μ (Inter.inter s (Set.range f)))","decl":"protected theorem comap_preimage (μ : Measure β) (s : Set β) :\n    μ.comap f (f ⁻¹' s) = μ (s ∩ range f) := by\n  rw [← hf.map_apply, hf.map_comap, restrict_apply' hf.measurableSet_range]\n\n"}
{"name":"MeasurableEmbedding.comap_restrict","module":"Mathlib.MeasureTheory.Measure.Restrict","initialProofState":"α : Type u_2\nβ : Type u_3\nm0 : MeasurableSpace α\nm1 : MeasurableSpace β\nf : α → β\nhf : MeasurableEmbedding f\nμ : MeasureTheory.Measure β\ns : Set β\n⊢ Eq (MeasureTheory.Measure.comap f (μ.restrict s)) ((MeasureTheory.Measure.comap f μ).restrict (Set.preimage f s))","decl":"lemma comap_restrict (μ : Measure β) (s : Set β) :\n    (μ.restrict s).comap f = (μ.comap f).restrict (f ⁻¹' s) := by\n  ext t ht\n  rw [Measure.restrict_apply ht, comap_apply hf, comap_apply hf,\n    Measure.restrict_apply (hf.measurableSet_image.2 ht), image_inter_preimage]\n\n"}
{"name":"MeasurableEmbedding.restrict_comap","module":"Mathlib.MeasureTheory.Measure.Restrict","initialProofState":"α : Type u_2\nβ : Type u_3\nm0 : MeasurableSpace α\nm1 : MeasurableSpace β\nf : α → β\nhf : MeasurableEmbedding f\nμ : MeasureTheory.Measure β\ns : Set α\n⊢ Eq ((MeasureTheory.Measure.comap f μ).restrict s) (MeasureTheory.Measure.comap f (μ.restrict (Set.image f s)))","decl":"lemma restrict_comap (μ : Measure β) (s : Set α) :\n    (μ.comap f).restrict s = (μ.restrict (f '' s)).comap f := by\n  rw [comap_restrict hf, preimage_image_eq _ hf.injective]\n\n"}
{"name":"MeasurableEquiv.restrict_map","module":"Mathlib.MeasureTheory.Measure.Restrict","initialProofState":"α : Type u_2\nβ : Type u_3\nm0 : MeasurableSpace α\nm1 : MeasurableSpace β\ne : MeasurableEquiv α β\nμ : MeasureTheory.Measure α\ns : Set β\n⊢ Eq ((MeasureTheory.Measure.map (⇑e) μ).restrict s) (MeasureTheory.Measure.map (⇑e) (μ.restrict (Set.preimage (⇑e) s)))","decl":"theorem _root_.MeasurableEquiv.restrict_map (e : α ≃ᵐ β) (μ : Measure α) (s : Set β) :\n    (μ.map e).restrict s = (μ.restrict <| e ⁻¹' s).map e :=\n  e.measurableEmbedding.restrict_map _ _\n\n"}
{"name":"comap_subtype_coe_apply","module":"Mathlib.MeasureTheory.Measure.Restrict","initialProofState":"α : Type u_2\n_m0 : MeasurableSpace α\ns : Set α\nhs : MeasurableSet s\nμ : MeasureTheory.Measure α\nt : Set ↑s\n⊢ Eq ((MeasureTheory.Measure.comap Subtype.val μ) t) (μ (Set.image Subtype.val t))","decl":"theorem comap_subtype_coe_apply {_m0 : MeasurableSpace α} {s : Set α} (hs : MeasurableSet s)\n    (μ : Measure α) (t : Set s) : comap (↑) μ t = μ ((↑) '' t) :=\n  (MeasurableEmbedding.subtype_coe hs).comap_apply _ _\n\n"}
{"name":"map_comap_subtype_coe","module":"Mathlib.MeasureTheory.Measure.Restrict","initialProofState":"α : Type u_2\nm0 : MeasurableSpace α\ns : Set α\nhs : MeasurableSet s\nμ : MeasureTheory.Measure α\n⊢ Eq (MeasureTheory.Measure.map Subtype.val (MeasureTheory.Measure.comap Subtype.val μ)) (μ.restrict s)","decl":"theorem map_comap_subtype_coe {m0 : MeasurableSpace α} {s : Set α} (hs : MeasurableSet s)\n    (μ : Measure α) : (comap (↑) μ).map ((↑) : s → α) = μ.restrict s := by\n  rw [(MeasurableEmbedding.subtype_coe hs).map_comap, Subtype.range_coe]\n\n"}
{"name":"ae_restrict_iff_subtype","module":"Mathlib.MeasureTheory.Measure.Restrict","initialProofState":"α : Type u_2\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : Set α\nhs : MeasurableSet s\np : α → Prop\n⊢ Iff (Filter.Eventually (fun x => p x) (MeasureTheory.ae (μ.restrict s))) (Filter.Eventually (fun x => p ↑x) (MeasureTheory.ae (MeasureTheory.Measure.comap Subtype.val μ)))","decl":"theorem ae_restrict_iff_subtype {m0 : MeasurableSpace α} {μ : Measure α} {s : Set α}\n    (hs : MeasurableSet s) {p : α → Prop} :\n    (∀ᵐ x ∂μ.restrict s, p x) ↔ ∀ᵐ (x : s) ∂comap ((↑) : s → α) μ, p x := by\n  rw [← map_comap_subtype_coe hs, (MeasurableEmbedding.subtype_coe hs).ae_map_iff]\n\n"}
{"name":"volume_set_coe_def","module":"Mathlib.MeasureTheory.Measure.Restrict","initialProofState":"α : Type u_2\ninst✝ : MeasureTheory.MeasureSpace α\ns : Set α\n⊢ Eq MeasureTheory.MeasureSpace.volume (MeasureTheory.Measure.comap Subtype.val MeasureTheory.MeasureSpace.volume)","decl":"theorem volume_set_coe_def (s : Set α) : (volume : Measure s) = comap ((↑) : s → α) volume :=\n  rfl\n\n"}
{"name":"MeasurableSet.map_coe_volume","module":"Mathlib.MeasureTheory.Measure.Restrict","initialProofState":"α : Type u_2\ninst✝ : MeasureTheory.MeasureSpace α\ns : Set α\nhs : MeasurableSet s\n⊢ Eq (MeasureTheory.Measure.map Subtype.val MeasureTheory.MeasureSpace.volume) (MeasureTheory.MeasureSpace.volume.restrict s)","decl":"theorem MeasurableSet.map_coe_volume {s : Set α} (hs : MeasurableSet s) :\n    volume.map ((↑) : s → α) = restrict volume s := by\n  rw [volume_set_coe_def, (MeasurableEmbedding.subtype_coe hs).map_comap volume, Subtype.range_coe]\n\n"}
{"name":"volume_image_subtype_coe","module":"Mathlib.MeasureTheory.Measure.Restrict","initialProofState":"α : Type u_2\ninst✝ : MeasureTheory.MeasureSpace α\ns : Set α\nhs : MeasurableSet s\nt : Set ↑s\n⊢ Eq (MeasureTheory.MeasureSpace.volume (Set.image Subtype.val t)) (MeasureTheory.MeasureSpace.volume t)","decl":"theorem volume_image_subtype_coe {s : Set α} (hs : MeasurableSet s) (t : Set s) :\n    volume ((↑) '' t : Set α) = volume t :=\n  (comap_subtype_coe_apply hs volume t).symm\n\n"}
{"name":"volume_preimage_coe","module":"Mathlib.MeasureTheory.Measure.Restrict","initialProofState":"α : Type u_2\ninst✝ : MeasureTheory.MeasureSpace α\ns t : Set α\nhs : MeasureTheory.NullMeasurableSet s MeasureTheory.MeasureSpace.volume\nht : MeasurableSet t\n⊢ Eq (MeasureTheory.MeasureSpace.volume (Set.preimage Subtype.val t)) (MeasureTheory.MeasureSpace.volume (Inter.inter t s))","decl":"@[simp]\ntheorem volume_preimage_coe (hs : NullMeasurableSet s) (ht : MeasurableSet t) :\n    volume (((↑) : s → α) ⁻¹' t) = volume (t ∩ s) := by\n  rw [volume_set_coe_def,\n    comap_apply₀ _ _ Subtype.coe_injective\n      (fun h => MeasurableSet.nullMeasurableSet_subtype_coe hs)\n      (measurable_subtype_coe ht).nullMeasurableSet,\n    image_preimage_eq_inter_range, Subtype.range_coe]\n\n"}
{"name":"piecewise_ae_eq_restrict","module":"Mathlib.MeasureTheory.Measure.Restrict","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : Set α\nf g : α → β\ninst✝ : DecidablePred fun x => Membership.mem s x\nhs : MeasurableSet s\n⊢ (MeasureTheory.ae (μ.restrict s)).EventuallyEq (s.piecewise f g) f","decl":"theorem piecewise_ae_eq_restrict [DecidablePred (· ∈ s)] (hs : MeasurableSet s) :\n    piecewise s f g =ᵐ[μ.restrict s] f := by\n  rw [ae_restrict_eq hs]\n  exact (piecewise_eqOn s f g).eventuallyEq.filter_mono inf_le_right\n\n"}
{"name":"piecewise_ae_eq_restrict_compl","module":"Mathlib.MeasureTheory.Measure.Restrict","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : Set α\nf g : α → β\ninst✝ : DecidablePred fun x => Membership.mem s x\nhs : MeasurableSet s\n⊢ (MeasureTheory.ae (μ.restrict (HasCompl.compl s))).EventuallyEq (s.piecewise f g) g","decl":"theorem piecewise_ae_eq_restrict_compl [DecidablePred (· ∈ s)] (hs : MeasurableSet s) :\n    piecewise s f g =ᵐ[μ.restrict sᶜ] g := by\n  rw [ae_restrict_eq hs.compl]\n  exact (piecewise_eqOn_compl s f g).eventuallyEq.filter_mono inf_le_right\n\n"}
{"name":"piecewise_ae_eq_of_ae_eq_set","module":"Mathlib.MeasureTheory.Measure.Restrict","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝² : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns t : Set α\nf g : α → β\ninst✝¹ : DecidablePred fun x => Membership.mem s x\ninst✝ : DecidablePred fun x => Membership.mem t x\nhst : (MeasureTheory.ae μ).EventuallyEq s t\n⊢ (MeasureTheory.ae μ).EventuallyEq (s.piecewise f g) (t.piecewise f g)","decl":"theorem piecewise_ae_eq_of_ae_eq_set [DecidablePred (· ∈ s)] [DecidablePred (· ∈ t)]\n    (hst : s =ᵐ[μ] t) : s.piecewise f g =ᵐ[μ] t.piecewise f g :=\n  hst.mem_iff.mono fun x hx => by simp [piecewise, hx]\n\n"}
{"name":"mem_map_indicator_ae_iff_mem_map_restrict_ae_of_zero_mem","module":"Mathlib.MeasureTheory.Measure.Restrict","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : Set α\nf : α → β\ninst✝ : Zero β\nt : Set β\nht : Membership.mem t 0\nhs : MeasurableSet s\n⊢ Iff (Membership.mem (Filter.map (s.indicator f) (MeasureTheory.ae μ)) t) (Membership.mem (Filter.map f (MeasureTheory.ae (μ.restrict s))) t)","decl":"theorem mem_map_indicator_ae_iff_mem_map_restrict_ae_of_zero_mem [Zero β] {t : Set β}\n    (ht : (0 : β) ∈ t) (hs : MeasurableSet s) :\n    t ∈ Filter.map (s.indicator f) (ae μ) ↔ t ∈ Filter.map f (ae <| μ.restrict s) := by\n  classical\n  simp_rw [mem_map, mem_ae_iff]\n  rw [Measure.restrict_apply' hs, Set.indicator_preimage, Set.ite]\n  simp_rw [Set.compl_union, Set.compl_inter]\n  change μ (((f ⁻¹' t)ᶜ ∪ sᶜ) ∩ ((fun _ => (0 : β)) ⁻¹' t \\ s)ᶜ) = 0 ↔ μ ((f ⁻¹' t)ᶜ ∩ s) = 0\n  simp only [ht, ← Set.compl_eq_univ_diff, compl_compl, Set.compl_union, if_true,\n    Set.preimage_const]\n  simp_rw [Set.union_inter_distrib_right, Set.compl_inter_self s, Set.union_empty]\n\n"}
{"name":"mem_map_indicator_ae_iff_of_zero_nmem","module":"Mathlib.MeasureTheory.Measure.Restrict","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : Set α\nf : α → β\ninst✝ : Zero β\nt : Set β\nht : Not (Membership.mem t 0)\n⊢ Iff (Membership.mem (Filter.map (s.indicator f) (MeasureTheory.ae μ)) t) (Eq (μ (Union.union (HasCompl.compl (Set.preimage f t)) (HasCompl.compl s))) 0)","decl":"theorem mem_map_indicator_ae_iff_of_zero_nmem [Zero β] {t : Set β} (ht : (0 : β) ∉ t) :\n    t ∈ Filter.map (s.indicator f) (ae μ) ↔ μ ((f ⁻¹' t)ᶜ ∪ sᶜ) = 0 := by\n  classical\n  rw [mem_map, mem_ae_iff, Set.indicator_preimage, Set.ite, Set.compl_union, Set.compl_inter]\n  change μ (((f ⁻¹' t)ᶜ ∪ sᶜ) ∩ ((fun _ => (0 : β)) ⁻¹' t \\ s)ᶜ) = 0 ↔ μ ((f ⁻¹' t)ᶜ ∪ sᶜ) = 0\n  simp only [ht, if_false, Set.compl_empty, Set.empty_diff, Set.inter_univ, Set.preimage_const]\n\n"}
{"name":"map_restrict_ae_le_map_indicator_ae","module":"Mathlib.MeasureTheory.Measure.Restrict","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : Set α\nf : α → β\ninst✝ : Zero β\nhs : MeasurableSet s\n⊢ LE.le (Filter.map f (MeasureTheory.ae (μ.restrict s))) (Filter.map (s.indicator f) (MeasureTheory.ae μ))","decl":"theorem map_restrict_ae_le_map_indicator_ae [Zero β] (hs : MeasurableSet s) :\n    Filter.map f (ae <| μ.restrict s) ≤ Filter.map (s.indicator f) (ae μ) := by\n  intro t\n  by_cases ht : (0 : β) ∈ t\n  · rw [mem_map_indicator_ae_iff_mem_map_restrict_ae_of_zero_mem ht hs]\n    exact id\n  rw [mem_map_indicator_ae_iff_of_zero_nmem ht, mem_map_restrict_ae_iff hs]\n  exact fun h => measure_mono_null (Set.inter_subset_left.trans Set.subset_union_left) h\n\n"}
{"name":"indicator_ae_eq_restrict","module":"Mathlib.MeasureTheory.Measure.Restrict","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : Set α\nf : α → β\ninst✝ : Zero β\nhs : MeasurableSet s\n⊢ (MeasureTheory.ae (μ.restrict s)).EventuallyEq (s.indicator f) f","decl":"theorem indicator_ae_eq_restrict (hs : MeasurableSet s) : indicator s f =ᵐ[μ.restrict s] f := by\n  classical exact piecewise_ae_eq_restrict hs\n\n"}
{"name":"indicator_ae_eq_restrict_compl","module":"Mathlib.MeasureTheory.Measure.Restrict","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : Set α\nf : α → β\ninst✝ : Zero β\nhs : MeasurableSet s\n⊢ (MeasureTheory.ae (μ.restrict (HasCompl.compl s))).EventuallyEq (s.indicator f) 0","decl":"theorem indicator_ae_eq_restrict_compl (hs : MeasurableSet s) :\n    indicator s f =ᵐ[μ.restrict sᶜ] 0 := by\n  classical exact piecewise_ae_eq_restrict_compl hs\n\n"}
{"name":"indicator_ae_eq_of_restrict_compl_ae_eq_zero","module":"Mathlib.MeasureTheory.Measure.Restrict","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : Set α\nf : α → β\ninst✝ : Zero β\nhs : MeasurableSet s\nhf : (MeasureTheory.ae (μ.restrict (HasCompl.compl s))).EventuallyEq f 0\n⊢ (MeasureTheory.ae μ).EventuallyEq (s.indicator f) f","decl":"theorem indicator_ae_eq_of_restrict_compl_ae_eq_zero (hs : MeasurableSet s)\n    (hf : f =ᵐ[μ.restrict sᶜ] 0) : s.indicator f =ᵐ[μ] f := by\n  rw [Filter.EventuallyEq, ae_restrict_iff' hs.compl] at hf\n  filter_upwards [hf] with x hx\n  by_cases hxs : x ∈ s\n  · simp only [hxs, Set.indicator_of_mem]\n  · simp only [hx hxs, Pi.zero_apply, Set.indicator_apply_eq_zero, eq_self_iff_true, imp_true_iff]\n\n"}
{"name":"indicator_ae_eq_zero_of_restrict_ae_eq_zero","module":"Mathlib.MeasureTheory.Measure.Restrict","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : Set α\nf : α → β\ninst✝ : Zero β\nhs : MeasurableSet s\nhf : (MeasureTheory.ae (μ.restrict s)).EventuallyEq f 0\n⊢ (MeasureTheory.ae μ).EventuallyEq (s.indicator f) 0","decl":"theorem indicator_ae_eq_zero_of_restrict_ae_eq_zero (hs : MeasurableSet s)\n    (hf : f =ᵐ[μ.restrict s] 0) : s.indicator f =ᵐ[μ] 0 := by\n  rw [Filter.EventuallyEq, ae_restrict_iff' hs] at hf\n  filter_upwards [hf] with x hx\n  by_cases hxs : x ∈ s\n  · simp only [hxs, hx hxs, Set.indicator_of_mem]\n  · simp [hx, hxs]\n\n"}
{"name":"indicator_ae_eq_of_ae_eq_set","module":"Mathlib.MeasureTheory.Measure.Restrict","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns t : Set α\nf : α → β\ninst✝ : Zero β\nhst : (MeasureTheory.ae μ).EventuallyEq s t\n⊢ (MeasureTheory.ae μ).EventuallyEq (s.indicator f) (t.indicator f)","decl":"theorem indicator_ae_eq_of_ae_eq_set (hst : s =ᵐ[μ] t) : s.indicator f =ᵐ[μ] t.indicator f := by\n  classical exact piecewise_ae_eq_of_ae_eq_set hst\n\n"}
{"name":"indicator_meas_zero","module":"Mathlib.MeasureTheory.Measure.Restrict","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : Set α\nf : α → β\ninst✝ : Zero β\nhs : Eq (μ s) 0\n⊢ (MeasureTheory.ae μ).EventuallyEq (s.indicator f) 0","decl":"theorem indicator_meas_zero (hs : μ s = 0) : indicator s f =ᵐ[μ] 0 :=\n  indicator_empty' f ▸ indicator_ae_eq_of_ae_eq_set (ae_eq_empty.2 hs)\n\n"}
{"name":"ae_eq_restrict_iff_indicator_ae_eq","module":"Mathlib.MeasureTheory.Measure.Restrict","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : Set α\nf : α → β\ninst✝ : Zero β\ng : α → β\nhs : MeasurableSet s\n⊢ Iff ((MeasureTheory.ae (μ.restrict s)).EventuallyEq f g) ((MeasureTheory.ae μ).EventuallyEq (s.indicator f) (s.indicator g))","decl":"theorem ae_eq_restrict_iff_indicator_ae_eq {g : α → β} (hs : MeasurableSet s) :\n    f =ᵐ[μ.restrict s] g ↔ s.indicator f =ᵐ[μ] s.indicator g := by\n  rw [Filter.EventuallyEq, ae_restrict_iff' hs]\n  refine ⟨fun h => ?_, fun h => ?_⟩ <;> filter_upwards [h] with x hx\n  · by_cases hxs : x ∈ s\n    · simp [hxs, hx hxs]\n    · simp [hxs]\n  · intro hxs\n    simpa [hxs] using hx\n\n"}
