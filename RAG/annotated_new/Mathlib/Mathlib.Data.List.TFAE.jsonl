{"name":"List.tfae_nil","module":"Mathlib.Data.List.TFAE","initialProofState":"⊢ List.nil.TFAE","decl":"theorem tfae_nil : TFAE [] :=\n  forall_mem_nil _\n\n"}
{"name":"List.tfae_singleton","module":"Mathlib.Data.List.TFAE","initialProofState":"p : Prop\n⊢ (List.cons p List.nil).TFAE","decl":"@[simp]\ntheorem tfae_singleton (p) : TFAE [p] := by simp [TFAE, -eq_iff_iff]\n\n"}
{"name":"List.tfae_cons_of_mem","module":"Mathlib.Data.List.TFAE","initialProofState":"a b : Prop\nl : List Prop\nh : Membership.mem l b\n⊢ Iff (List.cons a l).TFAE (And (Iff a b) l.TFAE)","decl":"theorem tfae_cons_of_mem {a b} {l : List Prop} (h : b ∈ l) : TFAE (a :: l) ↔ (a ↔ b) ∧ TFAE l :=\n  ⟨fun H => ⟨H a (by simp) b (Mem.tail a h),\n    fun _ hp _ hq => H _ (Mem.tail a hp) _ (Mem.tail a hq)⟩,\n      by\n        rintro ⟨ab, H⟩ p (_ | ⟨_, hp⟩) q (_ | ⟨_, hq⟩)\n        · rfl\n        · exact ab.trans (H _ h _ hq)\n        · exact (ab.trans (H _ h _ hp)).symm\n        · exact H _ hp _ hq⟩\n\n"}
{"name":"List.tfae_cons_cons","module":"Mathlib.Data.List.TFAE","initialProofState":"a b : Prop\nl : List Prop\n⊢ Iff (List.cons a (List.cons b l)).TFAE (And (Iff a b) (List.cons b l).TFAE)","decl":"theorem tfae_cons_cons {a b} {l : List Prop} : TFAE (a :: b :: l) ↔ (a ↔ b) ∧ TFAE (b :: l) :=\n  tfae_cons_of_mem (Mem.head _)\n\n"}
{"name":"List.tfae_cons_self","module":"Mathlib.Data.List.TFAE","initialProofState":"a : Prop\nl : List Prop\n⊢ Iff (List.cons a (List.cons a l)).TFAE (List.cons a l).TFAE","decl":"@[simp]\ntheorem tfae_cons_self {a} {l : List Prop} : TFAE (a :: a :: l) ↔ TFAE (a :: l) := by\n  simp [tfae_cons_cons]\n\n"}
{"name":"List.tfae_of_forall","module":"Mathlib.Data.List.TFAE","initialProofState":"b : Prop\nl : List Prop\nh : ∀ (a : Prop), Membership.mem l a → Iff a b\n⊢ l.TFAE","decl":"theorem tfae_of_forall (b : Prop) (l : List Prop) (h : ∀ a ∈ l, a ↔ b) : TFAE l :=\n  fun _a₁ h₁ _a₂ h₂ => (h _ h₁).trans (h _ h₂).symm\n\n"}
{"name":"List.tfae_of_cycle","module":"Mathlib.Data.List.TFAE","initialProofState":"a b : Prop\nl : List Prop\nh_chain : List.Chain (fun x1 x2 => x1 → x2) a (List.cons b l)\nh_last : l.getLastD b → a\n⊢ (List.cons a (List.cons b l)).TFAE","decl":"theorem tfae_of_cycle {a b} {l : List Prop} (h_chain : List.Chain (· → ·) a (b :: l))\n    (h_last : getLastD l b → a) : TFAE (a :: b :: l) := by\n  induction l generalizing a b with\n  | nil => simp_all [tfae_cons_cons, iff_def]\n  | cons c l IH =>\n    simp only [tfae_cons_cons, getLastD_cons, tfae_singleton, and_true, chain_cons, Chain.nil] at *\n    rcases h_chain with ⟨ab, ⟨bc, ch⟩⟩\n    have := IH ⟨bc, ch⟩ (ab ∘ h_last)\n    exact ⟨⟨ab, h_last ∘ (this.2 c (.head _) _ (getLastD_mem_cons _ _)).1 ∘ bc⟩, this⟩\n\n"}
{"name":"List.TFAE.out","module":"Mathlib.Data.List.TFAE","initialProofState":"l : List Prop\nh : l.TFAE\nn₁ n₂ : Nat\na b : Prop\nh₁ : autoParam (Eq (l.get? n₁) (Option.some a)) _auto✝\nh₂ : autoParam (Eq (l.get? n₂) (Option.some b)) _auto✝\n⊢ Iff a b","decl":"theorem TFAE.out {l} (h : TFAE l) (n₁ n₂) {a b} (h₁ : List.get? l n₁ = some a := by rfl)\n    (h₂ : List.get? l n₂ = some b := by rfl) : a ↔ b :=\n  h _ (List.mem_of_get? h₁) _ (List.mem_of_get? h₂)\n\n"}
{"name":"List.forall_tfae","module":"Mathlib.Data.List.TFAE","initialProofState":"α : Type u_1\nl : List (α → Prop)\nH : ∀ (a : α), (List.map (fun p => p a) l).TFAE\n⊢ (List.map (fun p => ∀ (a : α), p a) l).TFAE","decl":"/-- If `P₁ x ↔ ... ↔ Pₙ x` for all `x`, then `(∀ x, P₁ x) ↔ ... ↔ (∀ x, Pₙ x)`.\nNote: in concrete cases, Lean has trouble finding the list `[P₁, ..., Pₙ]` from the list\n`[(∀ x, P₁ x), ..., (∀ x, Pₙ x)]`, but simply providing a list of underscores with the right\nlength makes it happier.\n\nExample:\n```lean\nexample (P₁ P₂ P₃ : ℕ → Prop) (H : ∀ n, [P₁ n, P₂ n, P₃ n].TFAE) :\n    [∀ n, P₁ n, ∀ n, P₂ n, ∀ n, P₃ n].TFAE :=\n  forall_tfae [_, _, _] H\n```\n-/\ntheorem forall_tfae {α : Type*} (l : List (α → Prop)) (H : ∀ a : α, (l.map (fun p ↦ p a)).TFAE) :\n    (l.map (fun p ↦ ∀ a, p a)).TFAE := by\n  simp only [TFAE, List.forall_mem_map]\n  intros p₁ hp₁ p₂ hp₂\n  exact forall_congr' fun a ↦ H a (p₁ a) (mem_map_of_mem (fun p ↦ p a) hp₁)\n    (p₂ a) (mem_map_of_mem (fun p ↦ p a) hp₂)\n\n"}
{"name":"List.exists_tfae","module":"Mathlib.Data.List.TFAE","initialProofState":"α : Type u_1\nl : List (α → Prop)\nH : ∀ (a : α), (List.map (fun p => p a) l).TFAE\n⊢ (List.map (fun p => Exists fun a => p a) l).TFAE","decl":"/-- If `P₁ x ↔ ... ↔ Pₙ x` for all `x`, then `(∃ x, P₁ x) ↔ ... ↔ (∃ x, Pₙ x)`.\nNote: in concrete cases, Lean has trouble finding the list `[P₁, ..., Pₙ]` from the list\n`[(∃ x, P₁ x), ..., (∃ x, Pₙ x)]`, but simply providing a list of underscores with the right\nlength makes it happier.\n\nExample:\n```lean\nexample (P₁ P₂ P₃ : ℕ → Prop) (H : ∀ n, [P₁ n, P₂ n, P₃ n].TFAE) :\n    [∃ n, P₁ n, ∃ n, P₂ n, ∃ n, P₃ n].TFAE :=\n  exists_tfae [_, _, _] H\n```\n-/\ntheorem exists_tfae {α : Type*} (l : List (α → Prop)) (H : ∀ a : α, (l.map (fun p ↦ p a)).TFAE) :\n    (l.map (fun p ↦ ∃ a, p a)).TFAE := by\n  simp only [TFAE, List.forall_mem_map]\n  intros p₁ hp₁ p₂ hp₂\n  exact exists_congr fun a ↦ H a (p₁ a) (mem_map_of_mem (fun p ↦ p a) hp₁)\n    (p₂ a) (mem_map_of_mem (fun p ↦ p a) hp₂)\n\n"}
{"name":"List.tfae_not_iff","module":"Mathlib.Data.List.TFAE","initialProofState":"l : List Prop\n⊢ Iff (List.map Not l).TFAE l.TFAE","decl":"theorem tfae_not_iff {l : List Prop} : TFAE (l.map Not) ↔ TFAE l := by\n  classical\n  simp only [TFAE, mem_map, forall_exists_index, and_imp, forall_apply_eq_imp_iff₂,\n    Decidable.not_iff_not]\n\n"}
{"name":"List.TFAE.not","module":"Mathlib.Data.List.TFAE","initialProofState":"l : List Prop\na✝ : l.TFAE\n⊢ (List.map Not l).TFAE","decl":"alias ⟨_, TFAE.not⟩ := tfae_not_iff\n\n"}
