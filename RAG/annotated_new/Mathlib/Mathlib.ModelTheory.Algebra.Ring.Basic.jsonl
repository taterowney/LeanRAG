{"name":"FirstOrder.ringFunc.zero.sizeOf_spec","module":"Mathlib.ModelTheory.Algebra.Ring.Basic","initialProofState":"⊢ Eq (SizeOf.sizeOf FirstOrder.ringFunc.zero) 1","decl":"/-- The type of Ring functions, to be used in the definition of the language of rings.\nIt contains the operations (+,*,-,0,1) -/\ninductive ringFunc : ℕ → Type\n  | add : ringFunc 2\n  | mul : ringFunc 2\n  | neg : ringFunc 1\n  | zero : ringFunc 0\n  | one : ringFunc 0\n  deriving DecidableEq\n\n"}
{"name":"FirstOrder.ringFunc.neg.sizeOf_spec","module":"Mathlib.ModelTheory.Algebra.Ring.Basic","initialProofState":"⊢ Eq (SizeOf.sizeOf FirstOrder.ringFunc.neg) 1","decl":"/-- The type of Ring functions, to be used in the definition of the language of rings.\nIt contains the operations (+,*,-,0,1) -/\ninductive ringFunc : ℕ → Type\n  | add : ringFunc 2\n  | mul : ringFunc 2\n  | neg : ringFunc 1\n  | zero : ringFunc 0\n  | one : ringFunc 0\n  deriving DecidableEq\n\n"}
{"name":"FirstOrder.ringFunc.add.sizeOf_spec","module":"Mathlib.ModelTheory.Algebra.Ring.Basic","initialProofState":"⊢ Eq (SizeOf.sizeOf FirstOrder.ringFunc.add) 1","decl":"/-- The type of Ring functions, to be used in the definition of the language of rings.\nIt contains the operations (+,*,-,0,1) -/\ninductive ringFunc : ℕ → Type\n  | add : ringFunc 2\n  | mul : ringFunc 2\n  | neg : ringFunc 1\n  | zero : ringFunc 0\n  | one : ringFunc 0\n  deriving DecidableEq\n\n"}
{"name":"FirstOrder.ringFunc.one.sizeOf_spec","module":"Mathlib.ModelTheory.Algebra.Ring.Basic","initialProofState":"⊢ Eq (SizeOf.sizeOf FirstOrder.ringFunc.one) 1","decl":"/-- The type of Ring functions, to be used in the definition of the language of rings.\nIt contains the operations (+,*,-,0,1) -/\ninductive ringFunc : ℕ → Type\n  | add : ringFunc 2\n  | mul : ringFunc 2\n  | neg : ringFunc 1\n  | zero : ringFunc 0\n  | one : ringFunc 0\n  deriving DecidableEq\n\n"}
{"name":"FirstOrder.ringFunc.mul.sizeOf_spec","module":"Mathlib.ModelTheory.Algebra.Ring.Basic","initialProofState":"⊢ Eq (SizeOf.sizeOf FirstOrder.ringFunc.mul) 1","decl":"/-- The type of Ring functions, to be used in the definition of the language of rings.\nIt contains the operations (+,*,-,0,1) -/\ninductive ringFunc : ℕ → Type\n  | add : ringFunc 2\n  | mul : ringFunc 2\n  | neg : ringFunc 1\n  | zero : ringFunc 0\n  | one : ringFunc 0\n  deriving DecidableEq\n\n"}
{"name":"FirstOrder.Ring.zero_def","module":"Mathlib.ModelTheory.Algebra.Ring.Basic","initialProofState":"α : Type u_2\n⊢ Eq 0 (FirstOrder.Language.Constants.term FirstOrder.Ring.zeroFunc)","decl":"theorem zero_def (α : Type*) : (0 : Language.ring.Term α) = Constants.term zeroFunc := rfl\n\n"}
{"name":"FirstOrder.Ring.one_def","module":"Mathlib.ModelTheory.Algebra.Ring.Basic","initialProofState":"α : Type u_2\n⊢ Eq 1 (FirstOrder.Language.Constants.term FirstOrder.Ring.oneFunc)","decl":"theorem one_def (α : Type*) : (1 : Language.ring.Term α) = Constants.term oneFunc := rfl\n\n"}
{"name":"FirstOrder.Ring.add_def","module":"Mathlib.ModelTheory.Algebra.Ring.Basic","initialProofState":"α : Type u_2\nt₁ t₂ : FirstOrder.Language.ring.Term α\n⊢ Eq (HAdd.hAdd t₁ t₂) (FirstOrder.Ring.addFunc.apply₂ t₁ t₂)","decl":"theorem add_def (α : Type*) (t₁ t₂ : Language.ring.Term α) :\n    t₁ + t₂ = addFunc.apply₂ t₁ t₂ := rfl\n\n"}
{"name":"FirstOrder.Ring.mul_def","module":"Mathlib.ModelTheory.Algebra.Ring.Basic","initialProofState":"α : Type u_2\nt₁ t₂ : FirstOrder.Language.ring.Term α\n⊢ Eq (HMul.hMul t₁ t₂) (FirstOrder.Ring.mulFunc.apply₂ t₁ t₂)","decl":"theorem mul_def (α : Type*) (t₁ t₂ : Language.ring.Term α) :\n    t₁ * t₂ = mulFunc.apply₂ t₁ t₂ := rfl\n\n"}
{"name":"FirstOrder.Ring.neg_def","module":"Mathlib.ModelTheory.Algebra.Ring.Basic","initialProofState":"α : Type u_2\nt : FirstOrder.Language.ring.Term α\n⊢ Eq (Neg.neg t) (FirstOrder.Ring.negFunc.apply₁ t)","decl":"theorem neg_def (α : Type*) (t : Language.ring.Term α) :\n    -t = negFunc.apply₁ t := rfl\n\n"}
{"name":"FirstOrder.Ring.card_ring","module":"Mathlib.ModelTheory.Algebra.Ring.Basic","initialProofState":"⊢ Eq FirstOrder.Language.ring.card 5","decl":"@[simp]\ntheorem card_ring : card Language.ring = 5 := by\n  have : Fintype.card Language.ring.Symbols = 5 := rfl\n  simp [Language.card, this]\n\n"}
{"name":"FirstOrder.Ring.CompatibleRing.funMap_add","module":"Mathlib.ModelTheory.Algebra.Ring.Basic","initialProofState":"R : Type u_2\ninst✝⁴ : Add R\ninst✝³ : Mul R\ninst✝² : Neg R\ninst✝¹ : One R\ninst✝ : Zero R\nself : FirstOrder.Ring.CompatibleRing R\nx : Fin 2 → R\n⊢ Eq (FirstOrder.Language.Structure.funMap FirstOrder.Ring.addFunc x) (HAdd.hAdd (x 0) (x 1))","decl":"/-- A Type `R` is a `CompatibleRing` if it is a structure for the language of rings and this\nstructure is the same as the structure already given on `R` by the classes `Add`, `Mul` etc.\n\nIt is recommended to use this type class as a hypothesis to any theorem whose statement\nrequires a type to have be both a `Ring` (or `Field` etc.) and a\n`Language.ring.Structure`  -/\n/- This class does not extend `Add` etc, because this way it can be used in\ncombination with a `Ring`, or `Field` instance without having multiple different\n`Add` structures on the Type. -/\nclass CompatibleRing (R : Type*) [Add R] [Mul R] [Neg R] [One R] [Zero R]\n    extends Language.ring.Structure R where\n  /-- Addition in the `Language.ring.Structure` is the same as the addition given by the\n    `Add` instance -/\n  funMap_add : ∀ x, funMap addFunc x = x 0 + x 1\n  /-- Multiplication in the `Language.ring.Structure` is the same as the multiplication given by the\n    `Mul` instance -/\n  funMap_mul : ∀ x, funMap mulFunc x = x 0 * x 1\n  /-- Negation in the `Language.ring.Structure` is the same as the negation given by the\n    `Neg` instance -/\n  funMap_neg : ∀ x, funMap negFunc x = -x 0\n  /-- The constant `0` in the `Language.ring.Structure` is the same as the constant given by the\n    `Zero` instance -/\n  funMap_zero : ∀ x, funMap (zeroFunc : Language.ring.Constants) x = 0\n  /-- The constant `1` in the `Language.ring.Structure` is the same as the constant given by the\n    `One` instance -/\n  funMap_one : ∀ x, funMap (oneFunc : Language.ring.Constants) x = 1\n\n"}
{"name":"FirstOrder.Ring.CompatibleRing.funMap_zero","module":"Mathlib.ModelTheory.Algebra.Ring.Basic","initialProofState":"R : Type u_2\ninst✝⁴ : Add R\ninst✝³ : Mul R\ninst✝² : Neg R\ninst✝¹ : One R\ninst✝ : Zero R\nself : FirstOrder.Ring.CompatibleRing R\nx : Fin 0 → R\n⊢ Eq (FirstOrder.Language.Structure.funMap FirstOrder.Ring.zeroFunc x) 0","decl":"/-- A Type `R` is a `CompatibleRing` if it is a structure for the language of rings and this\nstructure is the same as the structure already given on `R` by the classes `Add`, `Mul` etc.\n\nIt is recommended to use this type class as a hypothesis to any theorem whose statement\nrequires a type to have be both a `Ring` (or `Field` etc.) and a\n`Language.ring.Structure`  -/\n/- This class does not extend `Add` etc, because this way it can be used in\ncombination with a `Ring`, or `Field` instance without having multiple different\n`Add` structures on the Type. -/\nclass CompatibleRing (R : Type*) [Add R] [Mul R] [Neg R] [One R] [Zero R]\n    extends Language.ring.Structure R where\n  /-- Addition in the `Language.ring.Structure` is the same as the addition given by the\n    `Add` instance -/\n  funMap_add : ∀ x, funMap addFunc x = x 0 + x 1\n  /-- Multiplication in the `Language.ring.Structure` is the same as the multiplication given by the\n    `Mul` instance -/\n  funMap_mul : ∀ x, funMap mulFunc x = x 0 * x 1\n  /-- Negation in the `Language.ring.Structure` is the same as the negation given by the\n    `Neg` instance -/\n  funMap_neg : ∀ x, funMap negFunc x = -x 0\n  /-- The constant `0` in the `Language.ring.Structure` is the same as the constant given by the\n    `Zero` instance -/\n  funMap_zero : ∀ x, funMap (zeroFunc : Language.ring.Constants) x = 0\n  /-- The constant `1` in the `Language.ring.Structure` is the same as the constant given by the\n    `One` instance -/\n  funMap_one : ∀ x, funMap (oneFunc : Language.ring.Constants) x = 1\n\n"}
{"name":"FirstOrder.Ring.CompatibleRing.funMap_one","module":"Mathlib.ModelTheory.Algebra.Ring.Basic","initialProofState":"R : Type u_2\ninst✝⁴ : Add R\ninst✝³ : Mul R\ninst✝² : Neg R\ninst✝¹ : One R\ninst✝ : Zero R\nself : FirstOrder.Ring.CompatibleRing R\nx : Fin 0 → R\n⊢ Eq (FirstOrder.Language.Structure.funMap FirstOrder.Ring.oneFunc x) 1","decl":"/-- A Type `R` is a `CompatibleRing` if it is a structure for the language of rings and this\nstructure is the same as the structure already given on `R` by the classes `Add`, `Mul` etc.\n\nIt is recommended to use this type class as a hypothesis to any theorem whose statement\nrequires a type to have be both a `Ring` (or `Field` etc.) and a\n`Language.ring.Structure`  -/\n/- This class does not extend `Add` etc, because this way it can be used in\ncombination with a `Ring`, or `Field` instance without having multiple different\n`Add` structures on the Type. -/\nclass CompatibleRing (R : Type*) [Add R] [Mul R] [Neg R] [One R] [Zero R]\n    extends Language.ring.Structure R where\n  /-- Addition in the `Language.ring.Structure` is the same as the addition given by the\n    `Add` instance -/\n  funMap_add : ∀ x, funMap addFunc x = x 0 + x 1\n  /-- Multiplication in the `Language.ring.Structure` is the same as the multiplication given by the\n    `Mul` instance -/\n  funMap_mul : ∀ x, funMap mulFunc x = x 0 * x 1\n  /-- Negation in the `Language.ring.Structure` is the same as the negation given by the\n    `Neg` instance -/\n  funMap_neg : ∀ x, funMap negFunc x = -x 0\n  /-- The constant `0` in the `Language.ring.Structure` is the same as the constant given by the\n    `Zero` instance -/\n  funMap_zero : ∀ x, funMap (zeroFunc : Language.ring.Constants) x = 0\n  /-- The constant `1` in the `Language.ring.Structure` is the same as the constant given by the\n    `One` instance -/\n  funMap_one : ∀ x, funMap (oneFunc : Language.ring.Constants) x = 1\n\n"}
{"name":"FirstOrder.Ring.CompatibleRing.funMap_neg","module":"Mathlib.ModelTheory.Algebra.Ring.Basic","initialProofState":"R : Type u_2\ninst✝⁴ : Add R\ninst✝³ : Mul R\ninst✝² : Neg R\ninst✝¹ : One R\ninst✝ : Zero R\nself : FirstOrder.Ring.CompatibleRing R\nx : Fin 1 → R\n⊢ Eq (FirstOrder.Language.Structure.funMap FirstOrder.Ring.negFunc x) (Neg.neg (x 0))","decl":"/-- A Type `R` is a `CompatibleRing` if it is a structure for the language of rings and this\nstructure is the same as the structure already given on `R` by the classes `Add`, `Mul` etc.\n\nIt is recommended to use this type class as a hypothesis to any theorem whose statement\nrequires a type to have be both a `Ring` (or `Field` etc.) and a\n`Language.ring.Structure`  -/\n/- This class does not extend `Add` etc, because this way it can be used in\ncombination with a `Ring`, or `Field` instance without having multiple different\n`Add` structures on the Type. -/\nclass CompatibleRing (R : Type*) [Add R] [Mul R] [Neg R] [One R] [Zero R]\n    extends Language.ring.Structure R where\n  /-- Addition in the `Language.ring.Structure` is the same as the addition given by the\n    `Add` instance -/\n  funMap_add : ∀ x, funMap addFunc x = x 0 + x 1\n  /-- Multiplication in the `Language.ring.Structure` is the same as the multiplication given by the\n    `Mul` instance -/\n  funMap_mul : ∀ x, funMap mulFunc x = x 0 * x 1\n  /-- Negation in the `Language.ring.Structure` is the same as the negation given by the\n    `Neg` instance -/\n  funMap_neg : ∀ x, funMap negFunc x = -x 0\n  /-- The constant `0` in the `Language.ring.Structure` is the same as the constant given by the\n    `Zero` instance -/\n  funMap_zero : ∀ x, funMap (zeroFunc : Language.ring.Constants) x = 0\n  /-- The constant `1` in the `Language.ring.Structure` is the same as the constant given by the\n    `One` instance -/\n  funMap_one : ∀ x, funMap (oneFunc : Language.ring.Constants) x = 1\n\n"}
{"name":"FirstOrder.Ring.CompatibleRing.funMap_mul","module":"Mathlib.ModelTheory.Algebra.Ring.Basic","initialProofState":"R : Type u_2\ninst✝⁴ : Add R\ninst✝³ : Mul R\ninst✝² : Neg R\ninst✝¹ : One R\ninst✝ : Zero R\nself : FirstOrder.Ring.CompatibleRing R\nx : Fin 2 → R\n⊢ Eq (FirstOrder.Language.Structure.funMap FirstOrder.Ring.mulFunc x) (HMul.hMul (x 0) (x 1))","decl":"/-- A Type `R` is a `CompatibleRing` if it is a structure for the language of rings and this\nstructure is the same as the structure already given on `R` by the classes `Add`, `Mul` etc.\n\nIt is recommended to use this type class as a hypothesis to any theorem whose statement\nrequires a type to have be both a `Ring` (or `Field` etc.) and a\n`Language.ring.Structure`  -/\n/- This class does not extend `Add` etc, because this way it can be used in\ncombination with a `Ring`, or `Field` instance without having multiple different\n`Add` structures on the Type. -/\nclass CompatibleRing (R : Type*) [Add R] [Mul R] [Neg R] [One R] [Zero R]\n    extends Language.ring.Structure R where\n  /-- Addition in the `Language.ring.Structure` is the same as the addition given by the\n    `Add` instance -/\n  funMap_add : ∀ x, funMap addFunc x = x 0 + x 1\n  /-- Multiplication in the `Language.ring.Structure` is the same as the multiplication given by the\n    `Mul` instance -/\n  funMap_mul : ∀ x, funMap mulFunc x = x 0 * x 1\n  /-- Negation in the `Language.ring.Structure` is the same as the negation given by the\n    `Neg` instance -/\n  funMap_neg : ∀ x, funMap negFunc x = -x 0\n  /-- The constant `0` in the `Language.ring.Structure` is the same as the constant given by the\n    `Zero` instance -/\n  funMap_zero : ∀ x, funMap (zeroFunc : Language.ring.Constants) x = 0\n  /-- The constant `1` in the `Language.ring.Structure` is the same as the constant given by the\n    `One` instance -/\n  funMap_one : ∀ x, funMap (oneFunc : Language.ring.Constants) x = 1\n\n"}
{"name":"FirstOrder.Ring.realize_add","module":"Mathlib.ModelTheory.Algebra.Ring.Basic","initialProofState":"α : Type u_1\nR : Type u_2\ninst✝⁵ : Add R\ninst✝⁴ : Mul R\ninst✝³ : Neg R\ninst✝² : One R\ninst✝¹ : Zero R\ninst✝ : FirstOrder.Ring.CompatibleRing R\nx y : FirstOrder.Language.ring.Term α\nv : α → R\n⊢ Eq (FirstOrder.Language.Term.realize v (HAdd.hAdd x y)) (HAdd.hAdd (FirstOrder.Language.Term.realize v x) (FirstOrder.Language.Term.realize v y))","decl":"@[simp]\ntheorem realize_add (x y : ring.Term α) (v : α → R) :\n    Term.realize v (x + y) = Term.realize v x + Term.realize v y := by\n  simp [add_def, funMap_add]\n\n"}
{"name":"FirstOrder.Ring.realize_mul","module":"Mathlib.ModelTheory.Algebra.Ring.Basic","initialProofState":"α : Type u_1\nR : Type u_2\ninst✝⁵ : Add R\ninst✝⁴ : Mul R\ninst✝³ : Neg R\ninst✝² : One R\ninst✝¹ : Zero R\ninst✝ : FirstOrder.Ring.CompatibleRing R\nx y : FirstOrder.Language.ring.Term α\nv : α → R\n⊢ Eq (FirstOrder.Language.Term.realize v (HMul.hMul x y)) (HMul.hMul (FirstOrder.Language.Term.realize v x) (FirstOrder.Language.Term.realize v y))","decl":"@[simp]\ntheorem realize_mul (x y : ring.Term α) (v : α → R) :\n    Term.realize v (x * y) = Term.realize v x * Term.realize v y := by\n  simp [mul_def, funMap_mul]\n\n"}
{"name":"FirstOrder.Ring.realize_neg","module":"Mathlib.ModelTheory.Algebra.Ring.Basic","initialProofState":"α : Type u_1\nR : Type u_2\ninst✝⁵ : Add R\ninst✝⁴ : Mul R\ninst✝³ : Neg R\ninst✝² : One R\ninst✝¹ : Zero R\ninst✝ : FirstOrder.Ring.CompatibleRing R\nx : FirstOrder.Language.ring.Term α\nv : α → R\n⊢ Eq (FirstOrder.Language.Term.realize v (Neg.neg x)) (Neg.neg (FirstOrder.Language.Term.realize v x))","decl":"@[simp]\ntheorem realize_neg (x : ring.Term α) (v : α → R) :\n    Term.realize v (-x) = -Term.realize v x := by\n  simp [neg_def, funMap_neg]\n\n"}
{"name":"FirstOrder.Ring.realize_zero","module":"Mathlib.ModelTheory.Algebra.Ring.Basic","initialProofState":"α : Type u_1\nR : Type u_2\ninst✝⁵ : Add R\ninst✝⁴ : Mul R\ninst✝³ : Neg R\ninst✝² : One R\ninst✝¹ : Zero R\ninst✝ : FirstOrder.Ring.CompatibleRing R\nv : α → R\n⊢ Eq (FirstOrder.Language.Term.realize v 0) 0","decl":"@[simp]\ntheorem realize_zero (v : α → R) : Term.realize v (0 : ring.Term α) = 0 := by\n  simp [zero_def, funMap_zero, constantMap]\n\n"}
{"name":"FirstOrder.Ring.realize_one","module":"Mathlib.ModelTheory.Algebra.Ring.Basic","initialProofState":"α : Type u_1\nR : Type u_2\ninst✝⁵ : Add R\ninst✝⁴ : Mul R\ninst✝³ : Neg R\ninst✝² : One R\ninst✝¹ : Zero R\ninst✝ : FirstOrder.Ring.CompatibleRing R\nv : α → R\n⊢ Eq (FirstOrder.Language.Term.realize v 1) 1","decl":"@[simp]\ntheorem realize_one (v : α → R) : Term.realize v (1 : ring.Term α) = 1 := by\n  simp [one_def, funMap_one, constantMap]\n\n"}
