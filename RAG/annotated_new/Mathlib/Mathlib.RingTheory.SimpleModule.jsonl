{"name":"RingEquiv.isSemisimpleRing","module":"Mathlib.RingTheory.SimpleModule","initialProofState":"R : Type u_2\nS : Type u_3\ninst✝² : Ring R\ninst✝¹ : Ring S\ne : RingEquiv R S\ninst✝ : IsSemisimpleRing R\n⊢ IsSemisimpleRing S","decl":"theorem RingEquiv.isSemisimpleRing (e : R ≃+* S) [IsSemisimpleRing R] : IsSemisimpleRing S :=\n  (Submodule.orderIsoMapComap e.toSemilinearEquiv).complementedLattice\n\n-- Making this an instance causes the linter to complain of \"dangerous instances\"\n"}
{"name":"IsSimpleModule.nontrivial","module":"Mathlib.RingTheory.SimpleModule","initialProofState":"R : Type u_2\ninst✝³ : Ring R\nM : Type u_4\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : IsSimpleModule R M\n⊢ Nontrivial M","decl":"theorem IsSimpleModule.nontrivial [IsSimpleModule R M] : Nontrivial M :=\n  ⟨⟨0, by\n      have h : (⊥ : Submodule R M) ≠ ⊤ := bot_ne_top\n      contrapose! h\n      ext x\n      simp [Submodule.mem_bot, Submodule.mem_top, h x]⟩⟩\n\n"}
{"name":"LinearMap.isSimpleModule_iff_of_bijective","module":"Mathlib.RingTheory.SimpleModule","initialProofState":"R : Type u_2\nS : Type u_3\ninst✝⁶ : Ring R\ninst✝⁵ : Ring S\nM : Type u_4\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\nN : Type u_5\ninst✝² : AddCommGroup N\ninst✝¹ : Module S N\nσ : RingHom R S\ninst✝ : RingHomSurjective σ\nl : LinearMap σ M N\nhl : Function.Bijective ⇑l\n⊢ Iff (IsSimpleModule R M) (IsSimpleModule S N)","decl":"theorem LinearMap.isSimpleModule_iff_of_bijective [Module S N] {σ : R →+* S} [RingHomSurjective σ]\n    (l : M →ₛₗ[σ] N) (hl : Function.Bijective l) : IsSimpleModule R M ↔ IsSimpleModule S N :=\n  (Submodule.orderIsoMapComapOfBijective l hl).isSimpleOrder_iff\n\n"}
{"name":"IsSimpleModule.congr","module":"Mathlib.RingTheory.SimpleModule","initialProofState":"R : Type u_2\ninst✝⁵ : Ring R\nM : Type u_4\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\nN : Type u_5\ninst✝² : AddCommGroup N\ninst✝¹ : Module R N\nl : LinearEquiv (RingHom.id R) M N\ninst✝ : IsSimpleModule R N\n⊢ IsSimpleModule R M","decl":"theorem IsSimpleModule.congr (l : M ≃ₗ[R] N) [IsSimpleModule R N] : IsSimpleModule R M :=\n  (Submodule.orderIsoMapComap l).isSimpleOrder\n\n"}
{"name":"isSimpleModule_iff_isAtom","module":"Mathlib.RingTheory.SimpleModule","initialProofState":"R : Type u_2\ninst✝² : Ring R\nM : Type u_4\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nm : Submodule R M\n⊢ Iff (IsSimpleModule R (Subtype fun x => Membership.mem m x)) (IsAtom m)","decl":"theorem isSimpleModule_iff_isAtom : IsSimpleModule R m ↔ IsAtom m := by\n  rw [← Set.isSimpleOrder_Iic_iff_isAtom]\n  exact m.mapIic.isSimpleOrder_iff\n\n"}
{"name":"isSimpleModule_iff_isCoatom","module":"Mathlib.RingTheory.SimpleModule","initialProofState":"R : Type u_2\ninst✝² : Ring R\nM : Type u_4\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nm : Submodule R M\n⊢ Iff (IsSimpleModule R (HasQuotient.Quotient M m)) (IsCoatom m)","decl":"theorem isSimpleModule_iff_isCoatom : IsSimpleModule R (M ⧸ m) ↔ IsCoatom m := by\n  rw [← Set.isSimpleOrder_Ici_iff_isCoatom]\n  apply OrderIso.isSimpleOrder_iff\n  exact Submodule.comapMkQRelIso m\n\n"}
{"name":"covBy_iff_quot_is_simple","module":"Mathlib.RingTheory.SimpleModule","initialProofState":"R : Type u_2\ninst✝² : Ring R\nM : Type u_4\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nA B : Submodule R M\nhAB : LE.le A B\n⊢ Iff (CovBy A B) (IsSimpleModule R (HasQuotient.Quotient (Subtype fun x => Membership.mem B x) (Submodule.comap B.subtype A)))","decl":"theorem covBy_iff_quot_is_simple {A B : Submodule R M} (hAB : A ≤ B) :\n    A ⋖ B ↔ IsSimpleModule R (B ⧸ Submodule.comap B.subtype A) := by\n  set f : Submodule R B ≃o Set.Iic B := B.mapIic with hf\n  rw [covBy_iff_coatom_Iic hAB, isSimpleModule_iff_isCoatom, ← OrderIso.isCoatom_iff f, hf]\n  simp [-OrderIso.isCoatom_iff, Submodule.map_comap_subtype, inf_eq_right.2 hAB]\n\n"}
{"name":"IsSimpleModule.isAtom","module":"Mathlib.RingTheory.SimpleModule","initialProofState":"R : Type u_2\ninst✝³ : Ring R\nM : Type u_4\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\nm : Submodule R M\ninst✝ : IsSimpleModule R (Subtype fun x => Membership.mem m x)\n⊢ IsAtom m","decl":"@[simp]\ntheorem isAtom [IsSimpleModule R m] : IsAtom m :=\n  isSimpleModule_iff_isAtom.1 ‹_›\n\n"}
{"name":"IsSimpleModule.span_singleton_eq_top","module":"Mathlib.RingTheory.SimpleModule","initialProofState":"R : Type u_2\ninst✝³ : Ring R\nM : Type u_4\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : IsSimpleModule R M\nm : M\nhm : Ne m 0\n⊢ Eq (Submodule.span R (Singleton.singleton m)) Top.top","decl":"theorem span_singleton_eq_top {m : M} (hm : m ≠ 0) : Submodule.span R {m} = ⊤ :=\n  (eq_bot_or_eq_top _).resolve_left fun h ↦ hm (h.le <| Submodule.mem_span_singleton_self m)\n\n"}
{"name":"IsSimpleModule.instIsPrincipal","module":"Mathlib.RingTheory.SimpleModule","initialProofState":"R : Type u_2\ninst✝² : Ring R\nM : Type u_4\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nS : Submodule R M\n⊢ S.IsPrincipal","decl":"instance (S : Submodule R M) : S.IsPrincipal where\n  principal' := by\n    obtain rfl | rfl := eq_bot_or_eq_top S\n    · exact ⟨0, Submodule.span_zero.symm⟩\n    have := IsSimpleModule.nontrivial R M\n    have ⟨m, hm⟩ := exists_ne (0 : M)\n    exact ⟨m, (span_singleton_eq_top R hm).symm⟩\n\n"}
{"name":"IsSimpleModule.toSpanSingleton_surjective","module":"Mathlib.RingTheory.SimpleModule","initialProofState":"R : Type u_2\ninst✝³ : Ring R\nM : Type u_4\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : IsSimpleModule R M\nm : M\nhm : Ne m 0\n⊢ Function.Surjective ⇑(LinearMap.toSpanSingleton R M m)","decl":"theorem toSpanSingleton_surjective {m : M} (hm : m ≠ 0) :\n    Function.Surjective (toSpanSingleton R M m) := by\n  rw [← range_eq_top, ← span_singleton_eq_range, span_singleton_eq_top R hm]\n\n"}
{"name":"IsSimpleModule.ker_toSpanSingleton_isMaximal","module":"Mathlib.RingTheory.SimpleModule","initialProofState":"R : Type u_2\ninst✝³ : Ring R\nM : Type u_4\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : IsSimpleModule R M\nm : M\nhm : Ne m 0\n⊢ Ideal.IsMaximal (LinearMap.ker (LinearMap.toSpanSingleton R M m))","decl":"theorem ker_toSpanSingleton_isMaximal {m : M} (hm : m ≠ 0) :\n    Ideal.IsMaximal (ker (toSpanSingleton R M m)) := by\n  rw [Ideal.isMaximal_def, ← isSimpleModule_iff_isCoatom]\n  exact congr (quotKerEquivOfSurjective _ <| toSpanSingleton_surjective R hm)\n\n"}
{"name":"IsSimpleModule.instIsNoetherian","module":"Mathlib.RingTheory.SimpleModule","initialProofState":"R : Type u_2\ninst✝³ : Ring R\nM : Type u_4\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : IsSimpleModule R M\n⊢ IsNoetherian R M","decl":"instance : IsNoetherian R M := isNoetherian_iff'.mpr inferInstance\n\n"}
{"name":"isSimpleModule_iff_quot_maximal","module":"Mathlib.RingTheory.SimpleModule","initialProofState":"R : Type u_2\ninst✝² : Ring R\nM : Type u_4\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\n⊢ Iff (IsSimpleModule R M) (Exists fun I => And I.IsMaximal (Nonempty (LinearEquiv (RingHom.id R) M (HasQuotient.Quotient R I))))","decl":"open IsSimpleModule in\n/-- A module is simple iff it's isomorphic to the quotient of the ring by a maximal left ideal\n(not necessarily unique if the ring is not commutative). -/\ntheorem isSimpleModule_iff_quot_maximal :\n    IsSimpleModule R M ↔ ∃ I : Ideal R, I.IsMaximal ∧ Nonempty (M ≃ₗ[R] R ⧸ I) := by\n  refine ⟨fun h ↦ ?_, fun ⟨I, ⟨coatom⟩, ⟨equiv⟩⟩ ↦ ?_⟩\n  · have := IsSimpleModule.nontrivial R M\n    have ⟨m, hm⟩ := exists_ne (0 : M)\n    exact ⟨_, ker_toSpanSingleton_isMaximal R hm,\n      ⟨(LinearMap.quotKerEquivOfSurjective _ <| toSpanSingleton_surjective R hm).symm⟩⟩\n  · convert congr equiv; rwa [isSimpleModule_iff_isCoatom]\n\n"}
{"name":"IsSimpleModule.annihilator_isMaximal","module":"Mathlib.RingTheory.SimpleModule","initialProofState":"M : Type u_4\ninst✝² : AddCommGroup M\nR : Type u_6\ninst✝¹ : CommRing R\ninst✝ : Module R M\nsimple : IsSimpleModule R M\n⊢ (Module.annihilator R M).IsMaximal","decl":"/-- In general, the annihilator of a simple module is called a primitive ideal, and it is\nalways a two-sided prime ideal, but mathlib's `Ideal.IsPrime` is not the correct definition\nfor noncommutative rings. -/\ntheorem IsSimpleModule.annihilator_isMaximal {R} [CommRing R] [Module R M]\n    [simple : IsSimpleModule R M] : (Module.annihilator R M).IsMaximal := by\n  have ⟨I, max, ⟨e⟩⟩ := isSimpleModule_iff_quot_maximal.mp simple\n  rwa [e.annihilator_eq, I.annihilator_quotient]\n\n"}
{"name":"isSimpleModule_iff_toSpanSingleton_surjective","module":"Mathlib.RingTheory.SimpleModule","initialProofState":"R : Type u_2\ninst✝² : Ring R\nM : Type u_4\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\n⊢ Iff (IsSimpleModule R M) (And (Nontrivial M) (∀ (x : M), Ne x 0 → Function.Surjective ⇑(LinearMap.toSpanSingleton R M x)))","decl":"theorem isSimpleModule_iff_toSpanSingleton_surjective : IsSimpleModule R M ↔\n    Nontrivial M ∧ ∀ x : M, x ≠ 0 → Function.Surjective (LinearMap.toSpanSingleton R M x) :=\n  ⟨fun h ↦ ⟨h.nontrivial, fun _ ↦ h.toSpanSingleton_surjective⟩, fun ⟨_, h⟩ ↦\n    ⟨fun m ↦ or_iff_not_imp_left.mpr fun ne_bot ↦\n      have ⟨x, hxm, hx0⟩ := m.ne_bot_iff.mp ne_bot\n      top_unique <| fun z _ ↦ by obtain ⟨y, rfl⟩ := h x hx0 z; exact m.smul_mem _ hxm⟩⟩\n\n"}
{"name":"isSimpleModule_self_iff_isUnit","module":"Mathlib.RingTheory.SimpleModule","initialProofState":"R : Type u_2\ninst✝ : Ring R\n⊢ Iff (IsSimpleModule R R) (And (Nontrivial R) (∀ (x : R), Ne x 0 → IsUnit x))","decl":"/-- A ring is a simple module over itself iff it is a division ring. -/\ntheorem isSimpleModule_self_iff_isUnit :\n    IsSimpleModule R R ↔ Nontrivial R ∧ ∀ x : R, x ≠ 0 → IsUnit x :=\n  isSimpleModule_iff_toSpanSingleton_surjective.trans <| and_congr_right fun _ ↦ by\n    refine ⟨fun h x hx ↦ ?_, fun h x hx ↦ (h x hx).unit.mulRight_bijective.surjective⟩\n    obtain ⟨y, hyx : y * x = 1⟩ := h x hx 1\n    have hy : y ≠ 0 := left_ne_zero_of_mul (hyx.symm ▸ one_ne_zero)\n    obtain ⟨z, hzy : z * y = 1⟩ := h y hy 1\n    exact ⟨⟨x, y, left_inv_eq_right_inv hzy hyx ▸ hzy, hyx⟩, rfl⟩\n\n"}
{"name":"isSimpleModule_iff_finrank_eq_one","module":"Mathlib.RingTheory.SimpleModule","initialProofState":"M : Type u_4\ninst✝² : AddCommGroup M\nR : Type u_6\ninst✝¹ : DivisionRing R\ninst✝ : Module R M\n⊢ Iff (IsSimpleModule R M) (Eq (Module.finrank R M) 1)","decl":"theorem isSimpleModule_iff_finrank_eq_one {R} [DivisionRing R] [Module R M] :\n    IsSimpleModule R M ↔ Module.finrank R M = 1 :=\n  ⟨fun h ↦ have := h.nontrivial; have ⟨v, hv⟩ := exists_ne (0 : M)\n    (finrank_eq_one_iff_of_nonzero' v hv).mpr (IsSimpleModule.toSpanSingleton_surjective R hv),\n  is_simple_module_of_finrank_eq_one⟩\n\n"}
{"name":"IsSemisimpleModule.of_sSup_simples_eq_top","module":"Mathlib.RingTheory.SimpleModule","initialProofState":"R : Type u_2\ninst✝² : Ring R\nM : Type u_4\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nh : Eq (SupSet.sSup (setOf fun m => IsSimpleModule R (Subtype fun x => Membership.mem m x))) Top.top\n⊢ IsSemisimpleModule R M","decl":"theorem IsSemisimpleModule.of_sSup_simples_eq_top\n    (h : sSup { m : Submodule R M | IsSimpleModule R m } = ⊤) : IsSemisimpleModule R M :=\n  complementedLattice_of_sSup_atoms_eq_top (by simp_rw [← h, isSimpleModule_iff_isAtom])\n\n"}
{"name":"IsSemisimpleModule.eq_bot_or_exists_simple_le","module":"Mathlib.RingTheory.SimpleModule","initialProofState":"R : Type u_2\ninst✝³ : Ring R\nM : Type u_4\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : IsSemisimpleModule R M\nN : Submodule R M\n⊢ Or (Eq N Bot.bot) (Exists fun m => And (LE.le m N) (IsSimpleModule R (Subtype fun x => Membership.mem m x)))","decl":"theorem eq_bot_or_exists_simple_le (N : Submodule R M) : N = ⊥ ∨ ∃ m ≤ N, IsSimpleModule R m := by\n  simpa only [isSimpleModule_iff_isAtom, and_comm] using eq_bot_or_exists_atom_le _\n\n"}
{"name":"IsSemisimpleModule.sSup_simples_le","module":"Mathlib.RingTheory.SimpleModule","initialProofState":"R : Type u_2\ninst✝³ : Ring R\nM : Type u_4\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : IsSemisimpleModule R M\nN : Submodule R M\n⊢ Eq (SupSet.sSup (setOf fun m => And (IsSimpleModule R (Subtype fun x => Membership.mem m x)) (LE.le m N))) N","decl":"theorem sSup_simples_le (N : Submodule R M) :\n    sSup { m : Submodule R M | IsSimpleModule R m ∧ m ≤ N } = N := by\n  simpa only [isSimpleModule_iff_isAtom] using sSup_atoms_le_eq _\n\n"}
{"name":"IsSemisimpleModule.exists_simple_submodule","module":"Mathlib.RingTheory.SimpleModule","initialProofState":"R : Type u_2\ninst✝⁴ : Ring R\nM : Type u_4\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : IsSemisimpleModule R M\ninst✝ : Nontrivial M\n⊢ Exists fun m => IsSimpleModule R (Subtype fun x => Membership.mem m x)","decl":"theorem exists_simple_submodule [Nontrivial M] : ∃ m : Submodule R M, IsSimpleModule R m := by\n  simpa only [isSimpleModule_iff_isAtom] using IsAtomic.exists_atom _\n\n"}
{"name":"IsSemisimpleModule.sSup_simples_eq_top","module":"Mathlib.RingTheory.SimpleModule","initialProofState":"R : Type u_2\ninst✝³ : Ring R\nM : Type u_4\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : IsSemisimpleModule R M\n⊢ Eq (SupSet.sSup (setOf fun m => IsSimpleModule R (Subtype fun x => Membership.mem m x))) Top.top","decl":"theorem sSup_simples_eq_top : sSup { m : Submodule R M | IsSimpleModule R m } = ⊤ := by\n  simpa only [isSimpleModule_iff_isAtom] using sSup_atoms_eq_top\n\n"}
{"name":"IsSemisimpleModule.exists_sSupIndep_sSup_simples_eq_top","module":"Mathlib.RingTheory.SimpleModule","initialProofState":"R : Type u_2\ninst✝³ : Ring R\nM : Type u_4\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : IsSemisimpleModule R M\n⊢ Exists fun s => And (sSupIndep s) (And (Eq (SupSet.sSup s) Top.top) (∀ (m : Submodule R M), Membership.mem s m → IsSimpleModule R (Subtype fun x => Membership.mem m x)))","decl":"theorem exists_sSupIndep_sSup_simples_eq_top :\n    ∃ s : Set (Submodule R M), sSupIndep s ∧ sSup s = ⊤ ∧ ∀ m ∈ s, IsSimpleModule R m := by\n  have := sSup_simples_eq_top R M\n  simp_rw [isSimpleModule_iff_isAtom] at this ⊢\n  exact exists_sSupIndep_of_sSup_atoms_eq_top this\n\n"}
{"name":"IsSemisimpleModule.exists_setIndependent_sSup_simples_eq_top","module":"Mathlib.RingTheory.SimpleModule","initialProofState":"R : Type u_2\ninst✝³ : Ring R\nM : Type u_4\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : IsSemisimpleModule R M\n⊢ Exists fun s => And (sSupIndep s) (And (Eq (SupSet.sSup s) Top.top) (∀ (m : Submodule R M), Membership.mem s m → IsSimpleModule R (Subtype fun x => Membership.mem m x)))","decl":"@[deprecated (since := \"2024-11-24\")]\nalias exists_setIndependent_sSup_simples_eq_top := exists_sSupIndep_sSup_simples_eq_top\n\n"}
{"name":"IsSemisimpleModule.annihilator_isRadical","module":"Mathlib.RingTheory.SimpleModule","initialProofState":"M : Type u_4\ninst✝³ : AddCommGroup M\nR : Type u_6\ninst✝² : CommRing R\ninst✝¹ : Module R M\ninst✝ : IsSemisimpleModule R M\n⊢ (Module.annihilator R M).IsRadical","decl":"/-- The annihilator of a semisimple module over a commutative ring is a radical ideal. -/\ntheorem annihilator_isRadical (R) [CommRing R] [Module R M] [IsSemisimpleModule R M] :\n    (Module.annihilator R M).IsRadical := by\n  rw [← Submodule.annihilator_top, ← sSup_simples_eq_top, sSup_eq_iSup', Submodule.annihilator_iSup]\n  exact Ideal.isRadical_iInf _ fun i ↦ (i.2.annihilator_isMaximal).isPrime.isRadical\n\n"}
{"name":"IsSemisimpleModule.submodule","module":"Mathlib.RingTheory.SimpleModule","initialProofState":"R : Type u_2\ninst✝³ : Ring R\nM : Type u_4\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : IsSemisimpleModule R M\nm : Submodule R M\n⊢ IsSemisimpleModule R (Subtype fun x => Membership.mem m x)","decl":"instance submodule {m : Submodule R M} : IsSemisimpleModule R m :=\n  m.mapIic.complementedLattice_iff.2 IsModularLattice.complementedLattice_Iic\n\n"}
{"name":"IsSemisimpleModule.congr","module":"Mathlib.RingTheory.SimpleModule","initialProofState":"R : Type u_2\ninst✝⁵ : Ring R\nM : Type u_4\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\nN : Type u_5\ninst✝² : AddCommGroup N\ninst✝¹ : Module R N\ninst✝ : IsSemisimpleModule R M\ne : LinearEquiv (RingHom.id R) N M\n⊢ IsSemisimpleModule R N","decl":"theorem congr (e : N ≃ₗ[R] M) : IsSemisimpleModule R N :=\n  (Submodule.orderIsoMapComap e.symm).complementedLattice\n\n"}
{"name":"IsSemisimpleModule.quotient","module":"Mathlib.RingTheory.SimpleModule","initialProofState":"R : Type u_2\ninst✝³ : Ring R\nM : Type u_4\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\nm : Submodule R M\ninst✝ : IsSemisimpleModule R M\n⊢ IsSemisimpleModule R (HasQuotient.Quotient M m)","decl":"instance quotient : IsSemisimpleModule R (M ⧸ m) :=\n  have ⟨P, compl⟩ := exists_isCompl m\n  .congr (m.quotientEquivOfIsCompl P compl)\n\n"}
{"name":"IsSemisimpleModule.instIsNoetherianOfFinite","module":"Mathlib.RingTheory.SimpleModule","initialProofState":"R : Type u_2\ninst✝⁴ : Ring R\nM : Type u_4\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : IsSemisimpleModule R M\ninst✝ : Module.Finite R M\n⊢ IsNoetherian R M","decl":"instance (priority := low) [Module.Finite R M] : IsNoetherian R M where\n  noetherian m := have ⟨P, compl⟩ := exists_isCompl m\n    Module.Finite.iff_fg.mp (Module.Finite.equiv <| P.quotientEquivOfIsCompl m compl.symm)\n\n-- does not work as an instance, not sure why\n"}
{"name":"IsSemisimpleModule.range","module":"Mathlib.RingTheory.SimpleModule","initialProofState":"R : Type u_2\ninst✝⁵ : Ring R\nM : Type u_4\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\nN : Type u_5\ninst✝² : AddCommGroup N\ninst✝¹ : Module R N\ninst✝ : IsSemisimpleModule R M\nf : LinearMap (RingHom.id R) M N\n⊢ IsSemisimpleModule R (Subtype fun x => Membership.mem (LinearMap.range f) x)","decl":"protected theorem range (f : M →ₗ[R] N) : IsSemisimpleModule R (range f) :=\n  .congr (quotKerEquivRange _).symm\n\n"}
{"name":"LinearMap.isSemisimpleModule_iff_of_bijective","module":"Mathlib.RingTheory.SimpleModule","initialProofState":"R : Type u_2\nS : Type u_3\ninst✝⁶ : Ring R\ninst✝⁵ : Ring S\nM' : Type u_6\ninst✝⁴ : AddCommGroup M'\ninst✝³ : Module R M'\nN' : Type u_7\ninst✝² : AddCommGroup N'\ninst✝¹ : Module S N'\nσ : RingHom R S\nl : LinearMap σ M' N'\ninst✝ : RingHomSurjective σ\nhl : Function.Bijective ⇑l\n⊢ Iff (IsSemisimpleModule R M') (IsSemisimpleModule S N')","decl":"theorem _root_.LinearMap.isSemisimpleModule_iff_of_bijective\n    [RingHomSurjective σ] (hl : Function.Bijective l) :\n    IsSemisimpleModule R M' ↔ IsSemisimpleModule S N' :=\n  (Submodule.orderIsoMapComapOfBijective l hl).complementedLattice_iff\n\n-- TODO: generalize Submodule.equivMapOfInjective from InvPair to RingHomSurjective\n"}
{"name":"sSup_simples_eq_top_iff_isSemisimpleModule","module":"Mathlib.RingTheory.SimpleModule","initialProofState":"R : Type u_2\ninst✝² : Ring R\nM : Type u_4\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\n⊢ Iff (Eq (SupSet.sSup (setOf fun m => IsSimpleModule R (Subtype fun x => Membership.mem m x))) Top.top) (IsSemisimpleModule R M)","decl":"/-- A module is semisimple iff it is generated by its simple submodules. -/\ntheorem sSup_simples_eq_top_iff_isSemisimpleModule :\n    sSup { m : Submodule R M | IsSimpleModule R m } = ⊤ ↔ IsSemisimpleModule R M :=\n  ⟨.of_sSup_simples_eq_top, fun _ ↦ IsSemisimpleModule.sSup_simples_eq_top _ _⟩\n\n"}
{"name":"isSemisimpleModule_of_isSemisimpleModule_submodule","module":"Mathlib.RingTheory.SimpleModule","initialProofState":"ι : Type u_1\nR : Type u_2\ninst✝² : Ring R\nM : Type u_4\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\ns : Set ι\np : ι → Submodule R M\nhp : ∀ (i : ι), Membership.mem s i → IsSemisimpleModule R (Subtype fun x => Membership.mem (p i) x)\nhp' : Eq (iSup fun i => iSup fun h => p i) Top.top\n⊢ IsSemisimpleModule R M","decl":"/-- A module generated by semisimple submodules is itself semisimple. -/\nlemma isSemisimpleModule_of_isSemisimpleModule_submodule {s : Set ι} {p : ι → Submodule R M}\n    (hp : ∀ i ∈ s, IsSemisimpleModule R (p i)) (hp' : ⨆ i ∈ s, p i = ⊤) :\n    IsSemisimpleModule R M := by\n  refine complementedLattice_of_complementedLattice_Iic (fun i hi ↦ ?_) hp'\n  simpa only [← (p i).mapIic.complementedLattice_iff] using hp i hi\n\n"}
{"name":"isSemisimpleModule_biSup_of_isSemisimpleModule_submodule","module":"Mathlib.RingTheory.SimpleModule","initialProofState":"ι : Type u_1\nR : Type u_2\ninst✝² : Ring R\nM : Type u_4\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\ns : Set ι\np : ι → Submodule R M\nhp : ∀ (i : ι), Membership.mem s i → IsSemisimpleModule R (Subtype fun x => Membership.mem (p i) x)\n⊢ IsSemisimpleModule R (Subtype fun x => Membership.mem (iSup fun i => iSup fun h => p i) x)","decl":"lemma isSemisimpleModule_biSup_of_isSemisimpleModule_submodule {s : Set ι} {p : ι → Submodule R M}\n    (hp : ∀ i ∈ s, IsSemisimpleModule R (p i)) :\n    IsSemisimpleModule R ↥(⨆ i ∈ s, p i) := by\n  let q := ⨆ i ∈ s, p i\n  let p' : ι → Submodule R q := fun i ↦ (p i).comap q.subtype\n  have hp₀ : ∀ i ∈ s, p i ≤ LinearMap.range q.subtype := fun i hi ↦ by\n    simpa only [Submodule.range_subtype] using le_biSup _ hi\n  have hp₁ : ∀ i ∈ s, IsSemisimpleModule R (p' i) := fun i hi ↦ by\n    let e : p' i ≃ₗ[R] p i := (p i).comap_equiv_self_of_inj_of_le q.injective_subtype (hp₀ i hi)\n    exact (Submodule.orderIsoMapComap e).complementedLattice_iff.mpr <| hp i hi\n  have hp₂ : ⨆ i ∈ s, p' i = ⊤ := by\n    apply Submodule.map_injective_of_injective q.injective_subtype\n    simp_rw [Submodule.map_top, Submodule.range_subtype, Submodule.map_iSup]\n    exact biSup_congr fun i hi ↦ Submodule.map_comap_eq_of_le (hp₀ i hi)\n  exact isSemisimpleModule_of_isSemisimpleModule_submodule hp₁ hp₂\n\n"}
{"name":"isSemisimpleModule_of_isSemisimpleModule_submodule'","module":"Mathlib.RingTheory.SimpleModule","initialProofState":"ι : Type u_1\nR : Type u_2\ninst✝² : Ring R\nM : Type u_4\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\np : ι → Submodule R M\nhp : ∀ (i : ι), IsSemisimpleModule R (Subtype fun x => Membership.mem (p i) x)\nhp' : Eq (iSup fun i => p i) Top.top\n⊢ IsSemisimpleModule R M","decl":"lemma isSemisimpleModule_of_isSemisimpleModule_submodule' {p : ι → Submodule R M}\n    (hp : ∀ i, IsSemisimpleModule R (p i)) (hp' : ⨆ i, p i = ⊤) :\n    IsSemisimpleModule R M :=\n  isSemisimpleModule_of_isSemisimpleModule_submodule (s := Set.univ) (fun i _ ↦ hp i) (by simpa)\n\n"}
{"name":"IsSemisimpleModule.sup","module":"Mathlib.RingTheory.SimpleModule","initialProofState":"R : Type u_2\ninst✝² : Ring R\nM : Type u_4\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\np q : Submodule R M\nx✝¹ : IsSemisimpleModule R (Subtype fun x => Membership.mem p x)\nx✝ : IsSemisimpleModule R (Subtype fun x => Membership.mem q x)\n⊢ IsSemisimpleModule R (Subtype fun x => Membership.mem (Max.max p q) x)","decl":"theorem IsSemisimpleModule.sup {p q : Submodule R M}\n    (_ : IsSemisimpleModule R p) (_ : IsSemisimpleModule R q) :\n    IsSemisimpleModule R ↥(p ⊔ q) := by\n  let f : Bool → Submodule R M := Bool.rec q p\n  rw [show p ⊔ q = ⨆ i ∈ Set.univ, f i by rw [iSup_univ, iSup_bool_eq]]\n  exact isSemisimpleModule_biSup_of_isSemisimpleModule_submodule (by rintro (_|_) _ <;> assumption)\n\n"}
{"name":"IsSemisimpleRing.isSemisimpleModule","module":"Mathlib.RingTheory.SimpleModule","initialProofState":"R : Type u_2\ninst✝³ : Ring R\nM : Type u_4\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : IsSemisimpleRing R\n⊢ IsSemisimpleModule R M","decl":"instance IsSemisimpleRing.isSemisimpleModule [IsSemisimpleRing R] : IsSemisimpleModule R M :=\n  have : IsSemisimpleModule R (M →₀ R) := isSemisimpleModule_of_isSemisimpleModule_submodule'\n    (fun _ ↦ .congr (LinearMap.quotKerEquivRange _).symm) Finsupp.iSup_lsingle_range\n  .congr (LinearMap.quotKerEquivOfSurjective _ <| Finsupp.linearCombination_id_surjective R M).symm\n\n"}
{"name":"IsSemisimpleRing.isCoatomic_submodule","module":"Mathlib.RingTheory.SimpleModule","initialProofState":"R : Type u_2\ninst✝³ : Ring R\nM : Type u_4\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : IsSemisimpleRing R\n⊢ IsCoatomic (Submodule R M)","decl":"instance IsSemisimpleRing.isCoatomic_submodule [IsSemisimpleRing R] : IsCoatomic (Submodule R M) :=\n  isCoatomic_of_isAtomic_of_complementedLattice_of_isModular\n\n"}
{"name":"instIsSemisimpleRingForallOfFinite","module":"Mathlib.RingTheory.SimpleModule","initialProofState":"ι : Type u_7\ninst✝² : Finite ι\nR : ι → Type u_6\ninst✝¹ : (i : ι) → Ring (R i)\ninst✝ : ∀ (i : ι), IsSemisimpleRing (R i)\n⊢ IsSemisimpleRing ((i : ι) → R i)","decl":"open LinearMap in\n/-- A finite product of semisimple rings is semisimple. -/\ninstance {ι} [Finite ι] (R : ι → Type*) [Π i, Ring (R i)] [∀ i, IsSemisimpleRing (R i)] :\n    IsSemisimpleRing (Π i, R i) := by\n  letI (i) : Module (Π i, R i) (R i) := Module.compHom _ (Pi.evalRingHom R i)\n  let e (i) : R i →ₛₗ[Pi.evalRingHom R i] R i :=\n    { AddMonoidHom.id (R i) with map_smul' := fun _ _ ↦ rfl }\n  have (i) : IsSemisimpleModule (Π i, R i) (R i) :=\n    ((e i).isSemisimpleModule_iff_of_bijective Function.bijective_id).mpr inferInstance\n  classical\n  exact isSemisimpleModule_of_isSemisimpleModule_submodule' (p := (range <| single _ _ ·))\n    (fun i ↦ .range _) (by simp_rw [range_eq_map, Submodule.iSup_map_single, Submodule.pi_top])\n\n"}
{"name":"instIsSemisimpleRingProd","module":"Mathlib.RingTheory.SimpleModule","initialProofState":"R : Type u_2\nS : Type u_3\ninst✝¹ : Ring R\ninst✝ : Ring S\nhR : IsSemisimpleRing R\nhS : IsSemisimpleRing S\n⊢ IsSemisimpleRing (Prod R S)","decl":"/-- A binary product of semisimple rings is semisimple. -/\ninstance [hR : IsSemisimpleRing R] [hS : IsSemisimpleRing S] : IsSemisimpleRing (R × S) := by\n  letI : Module (R × S) R := Module.compHom _ (.fst R S)\n  letI : Module (R × S) S := Module.compHom _ (.snd R S)\n  -- e₁, e₂ got falsely flagged by the unused argument linter\n  let _e₁ : R →ₛₗ[.fst R S] R := { AddMonoidHom.id R with map_smul' := fun _ _ ↦ rfl }\n  let _e₂ : S →ₛₗ[.snd R S] S := { AddMonoidHom.id S with map_smul' := fun _ _ ↦ rfl }\n  rw [IsSemisimpleRing, ← _e₁.isSemisimpleModule_iff_of_bijective Function.bijective_id] at hR\n  rw [IsSemisimpleRing, ← _e₂.isSemisimpleModule_iff_of_bijective Function.bijective_id] at hS\n  rw [IsSemisimpleRing, ← Submodule.topEquiv.isSemisimpleModule_iff_of_bijective\n    (LinearEquiv.bijective _), ← LinearMap.sup_range_inl_inr]\n  exact .sup (.range _) (.range _)\n\n"}
{"name":"RingHom.isSemisimpleRing_of_surjective","module":"Mathlib.RingTheory.SimpleModule","initialProofState":"R : Type u_2\nS : Type u_3\ninst✝² : Ring R\ninst✝¹ : Ring S\nf : RingHom R S\nhf : Function.Surjective ⇑f\ninst✝ : IsSemisimpleRing R\n⊢ IsSemisimpleRing S","decl":"theorem RingHom.isSemisimpleRing_of_surjective (f : R →+* S) (hf : Function.Surjective f)\n    [IsSemisimpleRing R] : IsSemisimpleRing S := by\n  letI : Module R S := Module.compHom _ f\n  haveI : RingHomSurjective f := ⟨hf⟩\n  let e : S →ₛₗ[f] S := { AddMonoidHom.id S with map_smul' := fun _ _ ↦ rfl }\n  rw [IsSemisimpleRing, ← e.isSemisimpleModule_iff_of_bijective Function.bijective_id]\n  infer_instance\n\n"}
{"name":"IsSemisimpleRing.ideal_eq_span_idempotent","module":"Mathlib.RingTheory.SimpleModule","initialProofState":"R : Type u_2\ninst✝¹ : Ring R\ninst✝ : IsSemisimpleRing R\nI : Ideal R\n⊢ Exists fun e => And (IsIdempotentElem e) (Eq I (Ideal.span (Singleton.singleton e)))","decl":"theorem IsSemisimpleRing.ideal_eq_span_idempotent [IsSemisimpleRing R] (I : Ideal R) :\n    ∃ e : R, IsIdempotentElem e ∧ I = .span {e} := by\n  obtain ⟨J, h⟩ := exists_isCompl I\n  obtain ⟨f, idem, rfl⟩ := I.isIdempotentElemEquiv.symm (I.isComplEquivProj ⟨J, h⟩)\n  exact ⟨f 1, LinearMap.isIdempotentElem_apply_one_iff.mpr idem, by\n    erw [LinearMap.range_eq_map, ← Ideal.span_one, LinearMap.map_span, Set.image_singleton]; rfl⟩\n\n"}
{"name":"instIsPrincipalIdealRingOfIsSemisimpleRing","module":"Mathlib.RingTheory.SimpleModule","initialProofState":"R : Type u_2\ninst✝¹ : Ring R\ninst✝ : IsSemisimpleRing R\n⊢ IsPrincipalIdealRing R","decl":"instance [IsSemisimpleRing R] : IsPrincipalIdealRing R where\n  principal I := have ⟨e, _, he⟩ := IsSemisimpleRing.ideal_eq_span_idempotent I; ⟨e, he⟩\n\n"}
{"name":"LinearMap.injective_or_eq_zero","module":"Mathlib.RingTheory.SimpleModule","initialProofState":"R : Type u_2\ninst✝⁵ : Ring R\nM : Type u_4\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\nN : Type u_5\ninst✝² : AddCommGroup N\ninst✝¹ : Module R N\ninst✝ : IsSimpleModule R M\nf : LinearMap (RingHom.id R) M N\n⊢ Or (Function.Injective ⇑f) (Eq f 0)","decl":"theorem injective_or_eq_zero [IsSimpleModule R M] (f : M →ₗ[R] N) :\n    Function.Injective f ∨ f = 0 := by\n  rw [← ker_eq_bot, ← ker_eq_top]\n  apply eq_bot_or_eq_top\n\n"}
{"name":"LinearMap.injective_of_ne_zero","module":"Mathlib.RingTheory.SimpleModule","initialProofState":"R : Type u_2\ninst✝⁵ : Ring R\nM : Type u_4\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\nN : Type u_5\ninst✝² : AddCommGroup N\ninst✝¹ : Module R N\ninst✝ : IsSimpleModule R M\nf : LinearMap (RingHom.id R) M N\nh : Ne f 0\n⊢ Function.Injective ⇑f","decl":"theorem injective_of_ne_zero [IsSimpleModule R M] {f : M →ₗ[R] N} (h : f ≠ 0) :\n    Function.Injective f :=\n  f.injective_or_eq_zero.resolve_right h\n\n"}
{"name":"LinearMap.surjective_or_eq_zero","module":"Mathlib.RingTheory.SimpleModule","initialProofState":"R : Type u_2\ninst✝⁵ : Ring R\nM : Type u_4\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\nN : Type u_5\ninst✝² : AddCommGroup N\ninst✝¹ : Module R N\ninst✝ : IsSimpleModule R N\nf : LinearMap (RingHom.id R) M N\n⊢ Or (Function.Surjective ⇑f) (Eq f 0)","decl":"theorem surjective_or_eq_zero [IsSimpleModule R N] (f : M →ₗ[R] N) :\n    Function.Surjective f ∨ f = 0 := by\n  rw [← range_eq_top, ← range_eq_bot, or_comm]\n  apply eq_bot_or_eq_top\n\n"}
{"name":"LinearMap.surjective_of_ne_zero","module":"Mathlib.RingTheory.SimpleModule","initialProofState":"R : Type u_2\ninst✝⁵ : Ring R\nM : Type u_4\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\nN : Type u_5\ninst✝² : AddCommGroup N\ninst✝¹ : Module R N\ninst✝ : IsSimpleModule R N\nf : LinearMap (RingHom.id R) M N\nh : Ne f 0\n⊢ Function.Surjective ⇑f","decl":"theorem surjective_of_ne_zero [IsSimpleModule R N] {f : M →ₗ[R] N} (h : f ≠ 0) :\n    Function.Surjective f :=\n  f.surjective_or_eq_zero.resolve_right h\n\n"}
{"name":"LinearMap.bijective_or_eq_zero","module":"Mathlib.RingTheory.SimpleModule","initialProofState":"R : Type u_2\ninst✝⁶ : Ring R\nM : Type u_4\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\nN : Type u_5\ninst✝³ : AddCommGroup N\ninst✝² : Module R N\ninst✝¹ : IsSimpleModule R M\ninst✝ : IsSimpleModule R N\nf : LinearMap (RingHom.id R) M N\n⊢ Or (Function.Bijective ⇑f) (Eq f 0)","decl":"/-- **Schur's Lemma** for linear maps between (possibly distinct) simple modules -/\ntheorem bijective_or_eq_zero [IsSimpleModule R M] [IsSimpleModule R N] (f : M →ₗ[R] N) :\n    Function.Bijective f ∨ f = 0 :=\n  or_iff_not_imp_right.mpr fun h ↦ ⟨injective_of_ne_zero h, surjective_of_ne_zero h⟩\n\n"}
{"name":"LinearMap.bijective_of_ne_zero","module":"Mathlib.RingTheory.SimpleModule","initialProofState":"R : Type u_2\ninst✝⁶ : Ring R\nM : Type u_4\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\nN : Type u_5\ninst✝³ : AddCommGroup N\ninst✝² : Module R N\ninst✝¹ : IsSimpleModule R M\ninst✝ : IsSimpleModule R N\nf : LinearMap (RingHom.id R) M N\nh : Ne f 0\n⊢ Function.Bijective ⇑f","decl":"theorem bijective_of_ne_zero [IsSimpleModule R M] [IsSimpleModule R N] {f : M →ₗ[R] N} (h : f ≠ 0) :\n    Function.Bijective f :=\n  f.bijective_or_eq_zero.resolve_right h\n\n"}
{"name":"LinearMap.isCoatom_ker_of_surjective","module":"Mathlib.RingTheory.SimpleModule","initialProofState":"R : Type u_2\ninst✝⁵ : Ring R\nM : Type u_4\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\nN : Type u_5\ninst✝² : AddCommGroup N\ninst✝¹ : Module R N\ninst✝ : IsSimpleModule R N\nf : LinearMap (RingHom.id R) M N\nhf : Function.Surjective ⇑f\n⊢ IsCoatom (LinearMap.ker f)","decl":"theorem isCoatom_ker_of_surjective [IsSimpleModule R N] {f : M →ₗ[R] N}\n    (hf : Function.Surjective f) : IsCoatom (LinearMap.ker f) := by\n  rw [← isSimpleModule_iff_isCoatom]\n  exact IsSimpleModule.congr (f.quotKerEquivOfSurjective hf)\n\n"}
{"name":"JordanHolderModule.iso_symm","module":"Mathlib.RingTheory.SimpleModule","initialProofState":"R : Type u_2\ninst✝² : Ring R\nM : Type u_4\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nX Y : Prod (Submodule R M) (Submodule R M)\na✝ : JordanHolderModule.Iso X Y\n⊢ JordanHolderModule.Iso Y X","decl":"theorem iso_symm {X Y : Submodule R M × Submodule R M} : Iso X Y → Iso Y X :=\n  fun ⟨f⟩ => ⟨f.symm⟩\n\n"}
{"name":"JordanHolderModule.iso_trans","module":"Mathlib.RingTheory.SimpleModule","initialProofState":"R : Type u_2\ninst✝² : Ring R\nM : Type u_4\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nX Y Z : Prod (Submodule R M) (Submodule R M)\na✝¹ : JordanHolderModule.Iso X Y\na✝ : JordanHolderModule.Iso Y Z\n⊢ JordanHolderModule.Iso X Z","decl":"theorem iso_trans {X Y Z : Submodule R M × Submodule R M} : Iso X Y → Iso Y Z → Iso X Z :=\n  fun ⟨f⟩ ⟨g⟩ => ⟨f.trans g⟩\n\n"}
{"name":"JordanHolderModule.second_iso","module":"Mathlib.RingTheory.SimpleModule","initialProofState":"R : Type u_2\ninst✝² : Ring R\nM : Type u_4\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nX Y : Submodule R M\nx✝ : CovBy X (Max.max X Y)\n⊢ JordanHolderModule.Iso { fst := X, snd := Max.max X Y } { fst := Min.min X Y, snd := Y }","decl":"@[nolint unusedArguments]\ntheorem second_iso {X Y : Submodule R M} (_ : X ⋖ X ⊔ Y) :\n    Iso (X,X ⊔ Y) (X ⊓ Y,Y) := by\n  constructor\n  rw [sup_comm, inf_comm]\n  dsimp\n  exact (LinearMap.quotientInfEquivSupQuotient Y X).symm\n\n"}
