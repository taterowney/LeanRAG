{"name":"Nat.sInf_def","module":"Mathlib.Data.Nat.Lattice","initialProofState":"s : Set Nat\nh : s.Nonempty\n⊢ Eq (InfSet.sInf s) (Nat.find h)","decl":"open scoped Classical in\ntheorem sInf_def {s : Set ℕ} (h : s.Nonempty) : sInf s = @Nat.find (fun n ↦ n ∈ s) _ h :=\n  dif_pos _\n\n"}
{"name":"Nat.sSup_def","module":"Mathlib.Data.Nat.Lattice","initialProofState":"s : Set Nat\nh : Exists fun n => ∀ (a : Nat), Membership.mem s a → LE.le a n\n⊢ Eq (SupSet.sSup s) (Nat.find h)","decl":"open scoped Classical in\ntheorem sSup_def {s : Set ℕ} (h : ∃ n, ∀ a ∈ s, a ≤ n) :\n    sSup s = @Nat.find (fun n ↦ ∀ a ∈ s, a ≤ n) _ h :=\n  dif_pos _\n\n"}
{"name":"Set.Infinite.Nat.sSup_eq_zero","module":"Mathlib.Data.Nat.Lattice","initialProofState":"s : Set Nat\nh : s.Infinite\n⊢ Eq (SupSet.sSup s) 0","decl":"theorem _root_.Set.Infinite.Nat.sSup_eq_zero {s : Set ℕ} (h : s.Infinite) : sSup s = 0 :=\n  dif_neg fun ⟨n, hn⟩ ↦\n    let ⟨k, hks, hk⟩ := h.exists_gt n\n    (hn k hks).not_lt hk\n\n"}
{"name":"Nat.sInf_eq_zero","module":"Mathlib.Data.Nat.Lattice","initialProofState":"s : Set Nat\n⊢ Iff (Eq (InfSet.sInf s) 0) (Or (Membership.mem s 0) (Eq s EmptyCollection.emptyCollection))","decl":"@[simp]\ntheorem sInf_eq_zero {s : Set ℕ} : sInf s = 0 ↔ 0 ∈ s ∨ s = ∅ := by\n  cases eq_empty_or_nonempty s with\n  | inl h => subst h\n             simp only [or_true, eq_self_iff_true, iInf, InfSet.sInf,\n                        mem_empty_iff_false, exists_false, dif_neg, not_false_iff]\n  | inr h => simp only [h.ne_empty, or_false, Nat.sInf_def, h, Nat.find_eq_zero]\n\n"}
{"name":"Nat.sInf_empty","module":"Mathlib.Data.Nat.Lattice","initialProofState":"⊢ Eq (InfSet.sInf EmptyCollection.emptyCollection) 0","decl":"@[simp]\ntheorem sInf_empty : sInf ∅ = 0 := by\n  rw [sInf_eq_zero]\n  right\n  rfl\n\n"}
{"name":"Nat.iInf_of_empty","module":"Mathlib.Data.Nat.Lattice","initialProofState":"ι : Sort u_1\ninst✝ : IsEmpty ι\nf : ι → Nat\n⊢ Eq (iInf f) 0","decl":"@[simp]\ntheorem iInf_of_empty {ι : Sort*} [IsEmpty ι] (f : ι → ℕ) : iInf f = 0 := by\n  rw [iInf_of_isEmpty, sInf_empty]\n\n"}
{"name":"Nat.iInf_const_zero","module":"Mathlib.Data.Nat.Lattice","initialProofState":"ι : Sort u_1\n⊢ Eq (iInf fun x => 0) 0","decl":"/-- This combines `Nat.iInf_of_empty` with `ciInf_const`. -/\n@[simp]\nlemma iInf_const_zero {ι : Sort*} : ⨅ _ : ι, 0 = 0 :=\n  (isEmpty_or_nonempty ι).elim (fun h ↦ by simp) fun h ↦ sInf_eq_zero.2 <| by simp\n\n"}
{"name":"Nat.sInf_mem","module":"Mathlib.Data.Nat.Lattice","initialProofState":"s : Set Nat\nh : s.Nonempty\n⊢ Membership.mem s (InfSet.sInf s)","decl":"theorem sInf_mem {s : Set ℕ} (h : s.Nonempty) : sInf s ∈ s := by\n  classical\n  rw [Nat.sInf_def h]\n  exact Nat.find_spec h\n\n"}
{"name":"Nat.not_mem_of_lt_sInf","module":"Mathlib.Data.Nat.Lattice","initialProofState":"s : Set Nat\nm : Nat\nhm : LT.lt m (InfSet.sInf s)\n⊢ Not (Membership.mem s m)","decl":"theorem not_mem_of_lt_sInf {s : Set ℕ} {m : ℕ} (hm : m < sInf s) : m ∉ s := by\n  classical\n  cases eq_empty_or_nonempty s with\n  | inl h => subst h; apply not_mem_empty\n  | inr h => rw [Nat.sInf_def h] at hm; exact Nat.find_min h hm\n\n"}
{"name":"Nat.sInf_le","module":"Mathlib.Data.Nat.Lattice","initialProofState":"s : Set Nat\nm : Nat\nhm : Membership.mem s m\n⊢ LE.le (InfSet.sInf s) m","decl":"protected theorem sInf_le {s : Set ℕ} {m : ℕ} (hm : m ∈ s) : sInf s ≤ m := by\n  classical\n  rw [Nat.sInf_def ⟨m, hm⟩]\n  exact Nat.find_min' ⟨m, hm⟩ hm\n\n"}
{"name":"Nat.nonempty_of_pos_sInf","module":"Mathlib.Data.Nat.Lattice","initialProofState":"s : Set Nat\nh : LT.lt 0 (InfSet.sInf s)\n⊢ s.Nonempty","decl":"theorem nonempty_of_pos_sInf {s : Set ℕ} (h : 0 < sInf s) : s.Nonempty := by\n  by_contra contra\n  rw [Set.not_nonempty_iff_eq_empty] at contra\n  have h' : sInf s ≠ 0 := ne_of_gt h\n  apply h'\n  rw [Nat.sInf_eq_zero]\n  right\n  assumption\n\n"}
{"name":"Nat.nonempty_of_sInf_eq_succ","module":"Mathlib.Data.Nat.Lattice","initialProofState":"s : Set Nat\nk : Nat\nh : Eq (InfSet.sInf s) (HAdd.hAdd k 1)\n⊢ s.Nonempty","decl":"theorem nonempty_of_sInf_eq_succ {s : Set ℕ} {k : ℕ} (h : sInf s = k + 1) : s.Nonempty :=\n  nonempty_of_pos_sInf (h.symm ▸ succ_pos k : sInf s > 0)\n\n"}
{"name":"Nat.eq_Ici_of_nonempty_of_upward_closed","module":"Mathlib.Data.Nat.Lattice","initialProofState":"s : Set Nat\nhs : s.Nonempty\nhs' : ∀ (k₁ k₂ : Nat), LE.le k₁ k₂ → Membership.mem s k₁ → Membership.mem s k₂\n⊢ Eq s (Set.Ici (InfSet.sInf s))","decl":"theorem eq_Ici_of_nonempty_of_upward_closed {s : Set ℕ} (hs : s.Nonempty)\n    (hs' : ∀ k₁ k₂ : ℕ, k₁ ≤ k₂ → k₁ ∈ s → k₂ ∈ s) : s = Ici (sInf s) :=\n  ext fun n ↦ ⟨fun H ↦ Nat.sInf_le H, fun H ↦ hs' (sInf s) n H (sInf_mem hs)⟩\n\n"}
{"name":"Nat.sInf_upward_closed_eq_succ_iff","module":"Mathlib.Data.Nat.Lattice","initialProofState":"s : Set Nat\nhs : ∀ (k₁ k₂ : Nat), LE.le k₁ k₂ → Membership.mem s k₁ → Membership.mem s k₂\nk : Nat\n⊢ Iff (Eq (InfSet.sInf s) (HAdd.hAdd k 1)) (And (Membership.mem s (HAdd.hAdd k 1)) (Not (Membership.mem s k)))","decl":"theorem sInf_upward_closed_eq_succ_iff {s : Set ℕ} (hs : ∀ k₁ k₂ : ℕ, k₁ ≤ k₂ → k₁ ∈ s → k₂ ∈ s)\n    (k : ℕ) : sInf s = k + 1 ↔ k + 1 ∈ s ∧ k ∉ s := by\n  classical\n  constructor\n  · intro H\n    rw [eq_Ici_of_nonempty_of_upward_closed (nonempty_of_sInf_eq_succ _) hs, H, mem_Ici, mem_Ici]\n    · exact ⟨le_rfl, k.not_succ_le_self⟩\n    · exact k\n    · assumption\n  · rintro ⟨H, H'⟩\n    rw [sInf_def (⟨_, H⟩ : s.Nonempty), find_eq_iff]\n    exact ⟨H, fun n hnk hns ↦ H' <| hs n k (Nat.lt_succ_iff.mp hnk) hns⟩\n\n"}
{"name":"Nat.sSup_mem","module":"Mathlib.Data.Nat.Lattice","initialProofState":"s : Set Nat\nh₁ : s.Nonempty\nh₂ : BddAbove s\n⊢ Membership.mem s (SupSet.sSup s)","decl":"theorem sSup_mem {s : Set ℕ} (h₁ : s.Nonempty) (h₂ : BddAbove s) : sSup s ∈ s :=\n  let ⟨k, hk⟩ := h₂\n  h₁.csSup_mem ((finite_le_nat k).subset hk)\n\n"}
{"name":"Nat.sInf_add","module":"Mathlib.Data.Nat.Lattice","initialProofState":"n : Nat\np : Nat → Prop\nhn : LE.le n (InfSet.sInf (setOf fun m => p m))\n⊢ Eq (HAdd.hAdd (InfSet.sInf (setOf fun m => p (HAdd.hAdd m n))) n) (InfSet.sInf (setOf fun m => p m))","decl":"theorem sInf_add {n : ℕ} {p : ℕ → Prop} (hn : n ≤ sInf { m | p m }) :\n    sInf { m | p (m + n) } + n = sInf { m | p m } := by\n  classical\n  obtain h | ⟨m, hm⟩ := { m | p (m + n) }.eq_empty_or_nonempty\n  · rw [h, Nat.sInf_empty, zero_add]\n    obtain hnp | hnp := hn.eq_or_lt\n    · exact hnp\n    suffices hp : p (sInf { m | p m } - n + n) from (h.subset hp).elim\n    rw [Nat.sub_add_cancel hn]\n    exact csInf_mem (nonempty_of_pos_sInf <| n.zero_le.trans_lt hnp)\n  · have hp : ∃ n, n ∈ { m | p m } := ⟨_, hm⟩\n    rw [Nat.sInf_def ⟨m, hm⟩, Nat.sInf_def hp]\n    rw [Nat.sInf_def hp] at hn\n    exact find_add hn\n\n"}
{"name":"Nat.sInf_add'","module":"Mathlib.Data.Nat.Lattice","initialProofState":"n : Nat\np : Nat → Prop\nh : LT.lt 0 (InfSet.sInf (setOf fun m => p m))\n⊢ Eq (HAdd.hAdd (InfSet.sInf (setOf fun m => p m)) n) (InfSet.sInf (setOf fun m => p (HSub.hSub m n)))","decl":"theorem sInf_add' {n : ℕ} {p : ℕ → Prop} (h : 0 < sInf { m | p m }) :\n    sInf { m | p m } + n = sInf { m | p (m - n) } := by\n  suffices h₁ : n ≤ sInf {m | p (m - n)} by\n    convert sInf_add h₁\n    simp_rw [Nat.add_sub_cancel_right]\n  obtain ⟨m, hm⟩ := nonempty_of_pos_sInf h\n  refine\n    le_csInf ⟨m + n, ?_⟩ fun b hb ↦\n      le_of_not_lt fun hbn ↦\n        ne_of_mem_of_not_mem ?_ (not_mem_of_lt_sInf h) (Nat.sub_eq_zero_of_le hbn.le)\n  · dsimp\n    rwa [Nat.add_sub_cancel_right]\n  · exact hb\n\n"}
{"name":"Nat.iSup_lt_succ","module":"Mathlib.Data.Nat.Lattice","initialProofState":"α : Type u_1\ninst✝ : CompleteLattice α\nu : Nat → α\nn : Nat\n⊢ Eq (iSup fun k => iSup fun h => u k) (Max.max (iSup fun k => iSup fun h => u k) (u n))","decl":"theorem iSup_lt_succ (u : ℕ → α) (n : ℕ) : ⨆ k < n + 1, u k = (⨆ k < n, u k) ⊔ u n := by\n  simp [Nat.lt_succ_iff_lt_or_eq, iSup_or, iSup_sup_eq]\n\n"}
{"name":"Nat.iSup_lt_succ'","module":"Mathlib.Data.Nat.Lattice","initialProofState":"α : Type u_1\ninst✝ : CompleteLattice α\nu : Nat → α\nn : Nat\n⊢ Eq (iSup fun k => iSup fun h => u k) (Max.max (u 0) (iSup fun k => iSup fun h => u (HAdd.hAdd k 1)))","decl":"theorem iSup_lt_succ' (u : ℕ → α) (n : ℕ) : ⨆ k < n + 1, u k = u 0 ⊔ ⨆ k < n, u (k + 1) := by\n  rw [← sup_iSup_nat_succ]\n  simp\n\n"}
{"name":"Nat.iInf_lt_succ","module":"Mathlib.Data.Nat.Lattice","initialProofState":"α : Type u_1\ninst✝ : CompleteLattice α\nu : Nat → α\nn : Nat\n⊢ Eq (iInf fun k => iInf fun h => u k) (Min.min (iInf fun k => iInf fun h => u k) (u n))","decl":"theorem iInf_lt_succ (u : ℕ → α) (n : ℕ) : ⨅ k < n + 1, u k = (⨅ k < n, u k) ⊓ u n :=\n  @iSup_lt_succ αᵒᵈ _ _ _\n\n"}
{"name":"Nat.iInf_lt_succ'","module":"Mathlib.Data.Nat.Lattice","initialProofState":"α : Type u_1\ninst✝ : CompleteLattice α\nu : Nat → α\nn : Nat\n⊢ Eq (iInf fun k => iInf fun h => u k) (Min.min (u 0) (iInf fun k => iInf fun h => u (HAdd.hAdd k 1)))","decl":"theorem iInf_lt_succ' (u : ℕ → α) (n : ℕ) : ⨅ k < n + 1, u k = u 0 ⊓ ⨅ k < n, u (k + 1) :=\n  @iSup_lt_succ' αᵒᵈ _ _ _\n\n"}
{"name":"Nat.iSup_le_succ","module":"Mathlib.Data.Nat.Lattice","initialProofState":"α : Type u_1\ninst✝ : CompleteLattice α\nu : Nat → α\nn : Nat\n⊢ Eq (iSup fun k => iSup fun h => u k) (Max.max (iSup fun k => iSup fun h => u k) (u (HAdd.hAdd n 1)))","decl":"theorem iSup_le_succ (u : ℕ → α) (n : ℕ) : ⨆ k ≤ n + 1, u k = (⨆ k ≤ n, u k) ⊔ u (n + 1) := by\n  simp_rw [← Nat.lt_succ_iff, iSup_lt_succ]\n\n"}
{"name":"Nat.iSup_le_succ'","module":"Mathlib.Data.Nat.Lattice","initialProofState":"α : Type u_1\ninst✝ : CompleteLattice α\nu : Nat → α\nn : Nat\n⊢ Eq (iSup fun k => iSup fun h => u k) (Max.max (u 0) (iSup fun k => iSup fun h => u (HAdd.hAdd k 1)))","decl":"theorem iSup_le_succ' (u : ℕ → α) (n : ℕ) : ⨆ k ≤ n + 1, u k = u 0 ⊔ ⨆ k ≤ n, u (k + 1) := by\n  simp_rw [← Nat.lt_succ_iff, iSup_lt_succ']\n\n"}
{"name":"Nat.iInf_le_succ","module":"Mathlib.Data.Nat.Lattice","initialProofState":"α : Type u_1\ninst✝ : CompleteLattice α\nu : Nat → α\nn : Nat\n⊢ Eq (iInf fun k => iInf fun h => u k) (Min.min (iInf fun k => iInf fun h => u k) (u (HAdd.hAdd n 1)))","decl":"theorem iInf_le_succ (u : ℕ → α) (n : ℕ) : ⨅ k ≤ n + 1, u k = (⨅ k ≤ n, u k) ⊓ u (n + 1) :=\n  @iSup_le_succ αᵒᵈ _ _ _\n\n"}
{"name":"Nat.iInf_le_succ'","module":"Mathlib.Data.Nat.Lattice","initialProofState":"α : Type u_1\ninst✝ : CompleteLattice α\nu : Nat → α\nn : Nat\n⊢ Eq (iInf fun k => iInf fun h => u k) (Min.min (u 0) (iInf fun k => iInf fun h => u (HAdd.hAdd k 1)))","decl":"theorem iInf_le_succ' (u : ℕ → α) (n : ℕ) : ⨅ k ≤ n + 1, u k = u 0 ⊓ ⨅ k ≤ n, u (k + 1) :=\n  @iSup_le_succ' αᵒᵈ _ _ _\n\n"}
{"name":"Set.biUnion_lt_succ","module":"Mathlib.Data.Nat.Lattice","initialProofState":"α : Type u_1\nu : Nat → Set α\nn : Nat\n⊢ Eq (Set.iUnion fun k => Set.iUnion fun h => u k) (Union.union (Set.iUnion fun k => Set.iUnion fun h => u k) (u n))","decl":"theorem biUnion_lt_succ (u : ℕ → Set α) (n : ℕ) : ⋃ k < n + 1, u k = (⋃ k < n, u k) ∪ u n :=\n  Nat.iSup_lt_succ u n\n\n"}
{"name":"Set.biUnion_lt_succ'","module":"Mathlib.Data.Nat.Lattice","initialProofState":"α : Type u_1\nu : Nat → Set α\nn : Nat\n⊢ Eq (Set.iUnion fun k => Set.iUnion fun h => u k) (Union.union (u 0) (Set.iUnion fun k => Set.iUnion fun h => u (HAdd.hAdd k 1)))","decl":"theorem biUnion_lt_succ' (u : ℕ → Set α) (n : ℕ) : ⋃ k < n + 1, u k = u 0 ∪ ⋃ k < n, u (k + 1) :=\n  Nat.iSup_lt_succ' u n\n\n"}
{"name":"Set.biInter_lt_succ","module":"Mathlib.Data.Nat.Lattice","initialProofState":"α : Type u_1\nu : Nat → Set α\nn : Nat\n⊢ Eq (Set.iInter fun k => Set.iInter fun h => u k) (Inter.inter (Set.iInter fun k => Set.iInter fun h => u k) (u n))","decl":"theorem biInter_lt_succ (u : ℕ → Set α) (n : ℕ) : ⋂ k < n + 1, u k = (⋂ k < n, u k) ∩ u n :=\n  Nat.iInf_lt_succ u n\n\n"}
{"name":"Set.biInter_lt_succ'","module":"Mathlib.Data.Nat.Lattice","initialProofState":"α : Type u_1\nu : Nat → Set α\nn : Nat\n⊢ Eq (Set.iInter fun k => Set.iInter fun h => u k) (Inter.inter (u 0) (Set.iInter fun k => Set.iInter fun h => u (HAdd.hAdd k 1)))","decl":"theorem biInter_lt_succ' (u : ℕ → Set α) (n : ℕ) : ⋂ k < n + 1, u k = u 0 ∩ ⋂ k < n, u (k + 1) :=\n  Nat.iInf_lt_succ' u n\n\n"}
{"name":"Set.biUnion_le_succ","module":"Mathlib.Data.Nat.Lattice","initialProofState":"α : Type u_1\nu : Nat → Set α\nn : Nat\n⊢ Eq (Set.iUnion fun k => Set.iUnion fun h => u k) (Union.union (Set.iUnion fun k => Set.iUnion fun h => u k) (u (HAdd.hAdd n 1)))","decl":"theorem biUnion_le_succ (u : ℕ → Set α) (n : ℕ) : ⋃ k ≤ n + 1, u k = (⋃ k ≤ n, u k) ∪ u (n + 1) :=\n  Nat.iSup_le_succ u n\n\n"}
{"name":"Set.biUnion_le_succ'","module":"Mathlib.Data.Nat.Lattice","initialProofState":"α : Type u_1\nu : Nat → Set α\nn : Nat\n⊢ Eq (Set.iUnion fun k => Set.iUnion fun h => u k) (Union.union (u 0) (Set.iUnion fun k => Set.iUnion fun h => u (HAdd.hAdd k 1)))","decl":"theorem biUnion_le_succ' (u : ℕ → Set α) (n : ℕ) : ⋃ k ≤ n + 1, u k = u 0 ∪ ⋃ k ≤ n, u (k + 1) :=\n  Nat.iSup_le_succ' u n\n\n"}
{"name":"Set.biInter_le_succ","module":"Mathlib.Data.Nat.Lattice","initialProofState":"α : Type u_1\nu : Nat → Set α\nn : Nat\n⊢ Eq (Set.iInter fun k => Set.iInter fun h => u k) (Inter.inter (Set.iInter fun k => Set.iInter fun h => u k) (u (HAdd.hAdd n 1)))","decl":"theorem biInter_le_succ (u : ℕ → Set α) (n : ℕ) : ⋂ k ≤ n + 1, u k = (⋂ k ≤ n, u k) ∩ u (n + 1) :=\n  Nat.iInf_le_succ u n\n\n"}
{"name":"Set.biInter_le_succ'","module":"Mathlib.Data.Nat.Lattice","initialProofState":"α : Type u_1\nu : Nat → Set α\nn : Nat\n⊢ Eq (Set.iInter fun k => Set.iInter fun h => u k) (Inter.inter (u 0) (Set.iInter fun k => Set.iInter fun h => u (HAdd.hAdd k 1)))","decl":"theorem biInter_le_succ' (u : ℕ → Set α) (n : ℕ) : ⋂ k ≤ n + 1, u k = u 0 ∩ ⋂ k ≤ n, u (k + 1) :=\n  Nat.iInf_le_succ' u n\n\n"}
{"name":"Set.accumulate_succ","module":"Mathlib.Data.Nat.Lattice","initialProofState":"α : Type u_1\nu : Nat → Set α\nn : Nat\n⊢ Eq (Set.Accumulate u (HAdd.hAdd n 1)) (Union.union (Set.Accumulate u n) (u (HAdd.hAdd n 1)))","decl":"theorem accumulate_succ (u : ℕ → Set α) (n : ℕ) :\n    Accumulate u (n + 1) = Accumulate u n ∪ u (n + 1) := biUnion_le_succ u n\n\n"}
