{"name":"JacobsonNoether.exists_pow_mem_center_of_inseparable","module":"Mathlib.FieldTheory.JacobsonNoether","initialProofState":"D : Type u_1\ninst✝¹ : DivisionRing D\ninst✝ : Algebra.IsAlgebraic (Subtype fun x => Membership.mem (Subring.center D) x) D\np : Nat\nhchar : ExpChar D p\na : D\nhinsep : ∀ (x : D), IsSeparable (Subtype fun x => Membership.mem (Subring.center D) x) x → Membership.mem (Subring.center D) x\n⊢ Exists fun n => Membership.mem (Subring.center D) (HPow.hPow a (HPow.hPow p n))","decl":"/-- If `D` is a purely inseparable extension of `k` with characteristic `p`,\n  then for every element `a` of `D`, there exists a natural number `n`\n  such that `a ^ (p ^ n)` is contained in `k`. -/\nlemma exists_pow_mem_center_of_inseparable (p : ℕ) [hchar : ExpChar D p] (a : D)\n    (hinsep : ∀ x : D, IsSeparable k x → x ∈ k) : ∃ n, a ^ (p ^ n) ∈ k := by\n  have := (@isPurelyInseparable_iff_pow_mem k D _ _ _ _ p (ExpChar.expChar_center_iff.2 hchar)).1\n  have pure : IsPurelyInseparable k D := ⟨Algebra.IsAlgebraic.isIntegral, fun x hx ↦ by\n    rw [RingHom.mem_range, Subtype.exists]\n    exact ⟨x, ⟨hinsep x hx, rfl⟩⟩⟩\n  obtain ⟨n, ⟨m, hm⟩⟩ := this pure a\n  have := Subalgebra.range_subset (R := k) ⟨(k).toSubsemiring, fun r ↦ r.2⟩\n  exact ⟨n, Set.mem_of_subset_of_mem this <| Set.mem_range.2 ⟨m, hm⟩⟩\n\n"}
{"name":"JacobsonNoether.exists_pow_mem_center_of_inseparable'","module":"Mathlib.FieldTheory.JacobsonNoether","initialProofState":"D : Type u_1\ninst✝² : DivisionRing D\ninst✝¹ : Algebra.IsAlgebraic (Subtype fun x => Membership.mem (Subring.center D) x) D\np : Nat\ninst✝ : ExpChar D p\na : D\nha : Not (Membership.mem (Subring.center D) a)\nhinsep : ∀ (x : D), IsSeparable (Subtype fun x => Membership.mem (Subring.center D) x) x → Membership.mem (Subring.center D) x\n⊢ Exists fun n => And (LE.le 1 n) (Membership.mem (Subring.center D) (HPow.hPow a (HPow.hPow p n)))","decl":"/-- If `D` is a purely inseparable extension of `k` with characteristic `p`,\n  then for every element `a` of `D \\ k`, there exists a natural number `n`\n  **greater than 0** such that `a ^ (p ^ n)` is contained in `k`. -/\nlemma exists_pow_mem_center_of_inseparable' (p : ℕ) [ExpChar D p] {a : D}\n    (ha : a ∉ k) (hinsep : ∀ x : D, IsSeparable k x → x ∈ k) : ∃ n, 1 ≤ n ∧ a ^ (p ^ n) ∈ k := by\n  obtain ⟨n, hn⟩ := exists_pow_mem_center_of_inseparable p a hinsep\n  by_cases nzero : n = 0\n  · rw [nzero, pow_zero, pow_one] at hn\n    exact (ha hn).elim\n  · exact ⟨n, ⟨Nat.one_le_iff_ne_zero.mpr nzero, hn⟩⟩\n\n"}
{"name":"JacobsonNoether.exist_pow_eq_zero_of_le","module":"Mathlib.FieldTheory.JacobsonNoether","initialProofState":"D : Type u_1\ninst✝¹ : DivisionRing D\ninst✝ : Algebra.IsAlgebraic (Subtype fun x => Membership.mem (Subring.center D) x) D\np : Nat\nhchar : ExpChar D p\na : D\nha : Not (Membership.mem (Subring.center D) a)\nhinsep : ∀ (x : D), IsSeparable (Subtype fun x => Membership.mem (Subring.center D) x) x → Membership.mem (Subring.center D) x\n⊢ Exists fun m => And (LE.le 1 m) (∀ (n : Nat), LE.le (HPow.hPow p m) n → Eq (Nat.iterate (⇑((LieAlgebra.ad (Subtype fun x => Membership.mem (Subring.center D) x) D) a)) n) 0)","decl":"/-- If `D` is a purely inseparable extension of `k` of characteristic `p`,\n  then for every element `a` of `D \\ k`, there exists a natural number `m`\n  greater than 0 such that `(a * x - x * a) ^ n = 0` (as linear maps) for\n  every `n` greater than `(p ^ m)`. -/\nlemma exist_pow_eq_zero_of_le (p : ℕ) [hchar : ExpChar D p]\n    {a : D} (ha : a ∉ k) (hinsep : ∀ x : D, IsSeparable k x → x ∈ k):\n  ∃ m, 1 ≤ m ∧ ∀ n, p ^ m ≤ n → (ad k D a)^[n] = 0 := by\n  obtain ⟨m, hm⟩ := exists_pow_mem_center_of_inseparable' p ha hinsep\n  refine ⟨m, ⟨hm.1, fun n hn ↦ ?_⟩⟩\n  have inter : (ad k D a)^[p ^ m] = 0 := by\n    ext x\n    rw [ad_eq_lmul_left_sub_lmul_right, ← pow_apply, Pi.sub_apply,\n      sub_pow_expChar_pow_of_commute p m (commute_mulLeft_right a a), sub_apply,\n      pow_mulLeft, mulLeft_apply, pow_mulRight, mulRight_apply, Pi.zero_apply,\n      Subring.mem_center_iff.1 hm.2 x]\n    exact sub_eq_zero_of_eq rfl\n  rw [(Nat.sub_eq_iff_eq_add hn).1 rfl, Function.iterate_add, inter, Pi.comp_zero,\n    iterate_map_zero, Function.const_zero]\n\n"}
{"name":"JacobsonNoether.exists_separable_and_not_isCentral","module":"Mathlib.FieldTheory.JacobsonNoether","initialProofState":"D : Type u_1\ninst✝¹ : DivisionRing D\ninst✝ : Algebra.IsAlgebraic (Subtype fun x => Membership.mem (Subring.center D) x) D\nH : Ne (Subring.center D) Top.top\n⊢ Exists fun x => And (Not (Membership.mem (Subring.center D) x)) (IsSeparable (Subtype fun x => Membership.mem (Subring.center D) x) x)","decl":"variable (D) in\n/-- Jacobson-Noether theorem: For a non-commutative division algebra\n  `D` that is algebraic over its center `k`, there exists an element\n  `x` of `D \\ k` that is separable over `k`. -/\ntheorem exists_separable_and_not_isCentral (H : k ≠ (⊤ : Subring D)) :\n    ∃ x : D, x ∉ k ∧ IsSeparable k x := by\n  obtain ⟨p, hp⟩ := ExpChar.exists D\n  by_contra! insep\n  replace insep : ∀ x : D, IsSeparable k x → x ∈ k :=\n    fun x h ↦ Classical.byContradiction fun hx ↦ insep x hx h\n  -- The element `a` below is in `D` but not in `k`.\n  obtain ⟨a, ha⟩ := not_forall.mp <| mt (Subring.eq_top_iff' k).mpr H\n  have ha₀ : a ≠ 0 := fun nh ↦ nh ▸ ha <| Subring.zero_mem k\n  -- We construct another element `b` that does not commute with `a`.\n  obtain ⟨b, hb1⟩ : ∃ b : D , ad k D a b ≠ 0 := by\n    rw [Subring.mem_center_iff, not_forall] at ha\n    use ha.choose\n    show a * ha.choose - ha.choose * a ≠ 0\n    simpa only [ne_eq, sub_eq_zero] using Ne.symm ha.choose_spec\n  -- We find a maximum natural number `n` such that `(a * x - x * a) ^ n b ≠ 0`.\n  obtain ⟨n, hn, hb⟩ : ∃ n, 0 < n ∧ (ad k D a)^[n] b ≠ 0 ∧ (ad k D a)^[n + 1] b = 0 := by\n    obtain ⟨m, -, hm2⟩ := exist_pow_eq_zero_of_le p ha insep\n    have h_exist : ∃ n, 0 < n ∧ (ad k D a)^[n + 1] b = 0 := ⟨p ^ m,\n      ⟨expChar_pow_pos D p m, by rw [hm2 (p ^ m + 1) (Nat.le_add_right _ _)]; rfl⟩⟩\n    classical\n    refine ⟨Nat.find h_exist, ⟨(Nat.find_spec h_exist).1, ?_, (Nat.find_spec h_exist).2⟩⟩\n    set t := (Nat.find h_exist - 1 : ℕ) with ht\n    by_cases h_pos : 0 < t\n    · convert (ne_eq _ _) ▸ not_and.mp (Nat.find_min h_exist (m := t) (by omega)) h_pos\n      omega\n    · suffices h_find: Nat.find h_exist = 1 by\n        rwa [h_find]\n      rw [not_lt, Nat.le_zero, ht, Nat.sub_eq_zero_iff_le] at h_pos\n      linarith [(Nat.find_spec h_exist).1]\n  -- We define `c` to be the value that we proved above to be non-zero.\n  set c := (ad k D a)^[n] b with hc_def\n  let _ : Invertible c := ⟨c⁻¹, inv_mul_cancel₀ hb.1, mul_inv_cancel₀ hb.1⟩\n  -- We prove that `c` commutes with `a`.\n  have hc : a * c = c * a := by\n    apply eq_of_sub_eq_zero\n    rw [← mulLeft_apply (R := k), ← mulRight_apply (R := k)]\n    suffices ad k D a c = 0 from by\n      rw [← this]; rfl\n    rw [← Function.iterate_succ_apply' (ad k D a) n b, hb.2]\n  -- We now make some computation to obtain the final equation.\n  set d := c⁻¹ * a * (ad k D a)^[n - 1] b with hd_def\n  have hc': c⁻¹ * a = a * c⁻¹ := by\n    apply_fun (c⁻¹ * · * c⁻¹) at hc\n    rw [mul_assoc, mul_assoc, mul_inv_cancel₀ hb.1, mul_one, ← mul_assoc,\n      inv_mul_cancel₀ hb.1, one_mul] at hc\n    exact hc\n  have c_eq : a * (ad k D a)^[n - 1] b - (ad k D a)^[n - 1] b * a = c := by\n    rw [hc_def, ← Nat.sub_add_cancel hn, Function.iterate_succ_apply' (ad k D a) _ b]; rfl\n  have eq1 : c⁻¹ * a * (ad k D a)^[n - 1] b - c⁻¹ * (ad k D a)^[n - 1] b * a = 1 := by\n    simp_rw [mul_assoc, (mul_sub_left_distrib c⁻¹ _ _).symm, c_eq, inv_mul_cancel_of_invertible]\n  -- We show that `a` commutes with `d`.\n  have deq : a * d - d * a = a := by\n    nth_rw 3 [← mul_one a]\n    rw [hd_def, ← eq1, mul_sub, mul_assoc _ _ a, sub_right_inj, hc',\n      ← mul_assoc, ← mul_assoc, ← mul_assoc]\n  -- This then yields a contradiction.\n  apply_fun (a⁻¹ * · ) at deq\n  rw [mul_sub, ← mul_assoc, inv_mul_cancel₀ ha₀, one_mul, ← mul_assoc, sub_eq_iff_eq_add] at deq\n  obtain ⟨r, hr⟩ := exists_pow_mem_center_of_inseparable p d insep\n  apply_fun (· ^ (p ^ r)) at deq\n  rw [add_pow_expChar_pow_of_commute p r (Commute.one_left _) , one_pow,\n    GroupWithZero.conj_pow₀ ha₀, ← hr.comm, mul_assoc, inv_mul_cancel₀ ha₀, mul_one,\n    self_eq_add_left] at deq\n  exact one_ne_zero deq\n\n"}
{"name":"JacobsonNoether.exists_separable_and_not_isCentral'","module":"Mathlib.FieldTheory.JacobsonNoether","initialProofState":"L : Type u_2\nD : Type u_3\ninst✝⁴ : Field L\ninst✝³ : DivisionRing D\ninst✝² : Algebra L D\ninst✝¹ : Algebra.IsAlgebraic L D\ninst✝ : Algebra.IsCentral L D\nhneq : Ne Bot.bot Top.top\n⊢ Exists fun x => And (Not (Membership.mem Bot.bot x)) (IsSeparable L x)","decl":"open Subring Algebra in\n/-- Jacobson-Noether theorem: For a non-commutative division algebra `D`\n  that is algebraic over a field `L`, if the center of\n  `D` coincides with `L`, then there exist an element `x` of `D \\ L`\n  that is separable over `L`. -/\ntheorem exists_separable_and_not_isCentral' {L D : Type*} [Field L] [DivisionRing D]\n    [Algebra L D] [Algebra.IsAlgebraic L D] [Algebra.IsCentral L D]\n  (hneq : (⊥ : Subalgebra L D) ≠ ⊤) :\n    ∃ x : D, x ∉ (⊥ : Subalgebra L D) ∧ IsSeparable L x := by\n  have hcenter : Subalgebra.center L D = ⊥ := le_bot_iff.mp IsCentral.out\n  have ntrivial : Subring.center D ≠ ⊤ :=\n    congr(Subalgebra.toSubring $hcenter).trans_ne (Subalgebra.toSubring_injective.ne hneq)\n  set φ := Subalgebra.equivOfEq (⊥ : Subalgebra L D) (.center L D) hcenter.symm\n  set equiv : L ≃+* (center D) := ((botEquiv L D).symm.trans φ).toRingEquiv\n  let _ : Algebra L (center D) := equiv.toRingHom.toAlgebra\n  let _ : Algebra (center D) L := equiv.symm.toRingHom.toAlgebra\n  have _ : IsScalarTower L (center D) D := .of_algebraMap_eq fun _ ↦ rfl\n  have _ : IsScalarTower (center D) L D := .of_algebraMap_eq fun x ↦ by\n    rw [IsScalarTower.algebraMap_apply L (center D)]\n    congr\n    exact (equiv.apply_symm_apply x).symm\n  have _ : Algebra.IsAlgebraic (center D) D := .tower_top (K := L) _\n  obtain ⟨x, hxd, hx⟩ := exists_separable_and_not_isCentral D ntrivial\n  exact ⟨x, ⟨by rwa [← Subalgebra.center_toSubring L, hcenter] at hxd, IsSeparable.tower_top _ hx⟩⟩\n\n"}
