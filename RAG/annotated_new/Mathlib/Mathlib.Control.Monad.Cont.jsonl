{"name":"MonadCont.Label.mk.injEq","module":"Mathlib.Control.Monad.Cont","initialProofState":"α : Type w\nm : Type u → Type v\nβ : Type u\napply✝ apply : α → m β\n⊢ Eq (Eq { apply := apply✝ } { apply := apply }) (Eq apply✝ apply)","decl":"structure MonadCont.Label (α : Type w) (m : Type u → Type v) (β : Type u) where\n  apply : α → m β\n\n"}
{"name":"MonadCont.Label.mk.inj","module":"Mathlib.Control.Monad.Cont","initialProofState":"α : Type w\nm : Type u → Type v\nβ : Type u\napply✝ apply : α → m β\nx✝ : Eq { apply := apply✝ } { apply := apply }\n⊢ Eq apply✝ apply","decl":"structure MonadCont.Label (α : Type w) (m : Type u → Type v) (β : Type u) where\n  apply : α → m β\n\n"}
{"name":"MonadCont.Label.mk.sizeOf_spec","module":"Mathlib.Control.Monad.Cont","initialProofState":"α : Type w\nm : Type u → Type v\nβ : Type u\ninst✝² : SizeOf α\ninst✝¹ : (a : Type u) → SizeOf (m a)\ninst✝ : SizeOf β\napply : α → m β\n⊢ Eq (SizeOf.sizeOf { apply := apply }) 1","decl":"structure MonadCont.Label (α : Type w) (m : Type u → Type v) (β : Type u) where\n  apply : α → m β\n\n"}
{"name":"LawfulMonadCont.callCC_bind_right","module":"Mathlib.Control.Monad.Cont","initialProofState":"m : Type u → Type v\ninst✝¹ : Monad m\ninst✝ : MonadCont m\nself : LawfulMonadCont m\nα ω γ : Type u\ncmd : m α\nnext : MonadCont.Label ω m γ → α → m ω\n⊢ Eq (MonadCont.callCC fun f => Bind.bind cmd (next f)) (Bind.bind cmd fun x => MonadCont.callCC fun f => next f x)","decl":"class LawfulMonadCont (m : Type u → Type v) [Monad m] [MonadCont m]\n    extends LawfulMonad m : Prop where\n  callCC_bind_right {α ω γ} (cmd : m α) (next : Label ω m γ → α → m ω) :\n    (callCC fun f => cmd >>= next f) = cmd >>= fun x => callCC fun f => next f x\n  callCC_bind_left {α} (β) (x : α) (dead : Label α m β → β → m α) :\n    (callCC fun f : Label α m β => goto f x >>= dead f) = pure x\n  callCC_dummy {α β} (dummy : m α) : (callCC fun _ : Label α m β => dummy) = dummy\n\n"}
{"name":"LawfulMonadCont.callCC_dummy","module":"Mathlib.Control.Monad.Cont","initialProofState":"m : Type u → Type v\ninst✝¹ : Monad m\ninst✝ : MonadCont m\nself : LawfulMonadCont m\nα β : Type u\ndummy : m α\n⊢ Eq (MonadCont.callCC fun x => dummy) dummy","decl":"class LawfulMonadCont (m : Type u → Type v) [Monad m] [MonadCont m]\n    extends LawfulMonad m : Prop where\n  callCC_bind_right {α ω γ} (cmd : m α) (next : Label ω m γ → α → m ω) :\n    (callCC fun f => cmd >>= next f) = cmd >>= fun x => callCC fun f => next f x\n  callCC_bind_left {α} (β) (x : α) (dead : Label α m β → β → m α) :\n    (callCC fun f : Label α m β => goto f x >>= dead f) = pure x\n  callCC_dummy {α β} (dummy : m α) : (callCC fun _ : Label α m β => dummy) = dummy\n\n"}
{"name":"LawfulMonadCont.toLawfulMonad","module":"Mathlib.Control.Monad.Cont","initialProofState":"m : Type u → Type v\ninst✝¹ : Monad m\ninst✝ : MonadCont m\nself : LawfulMonadCont m\n⊢ LawfulMonad m","decl":"class LawfulMonadCont (m : Type u → Type v) [Monad m] [MonadCont m]\n    extends LawfulMonad m : Prop where\n  callCC_bind_right {α ω γ} (cmd : m α) (next : Label ω m γ → α → m ω) :\n    (callCC fun f => cmd >>= next f) = cmd >>= fun x => callCC fun f => next f x\n  callCC_bind_left {α} (β) (x : α) (dead : Label α m β → β → m α) :\n    (callCC fun f : Label α m β => goto f x >>= dead f) = pure x\n  callCC_dummy {α β} (dummy : m α) : (callCC fun _ : Label α m β => dummy) = dummy\n\n"}
{"name":"LawfulMonadCont.callCC_bind_left","module":"Mathlib.Control.Monad.Cont","initialProofState":"m : Type u → Type v\ninst✝¹ : Monad m\ninst✝ : MonadCont m\nself : LawfulMonadCont m\nα β : Type u\nx : α\ndead : MonadCont.Label α m β → β → m α\n⊢ Eq (MonadCont.callCC fun f => Bind.bind (MonadCont.goto f x) (dead f)) (Pure.pure x)","decl":"class LawfulMonadCont (m : Type u → Type v) [Monad m] [MonadCont m]\n    extends LawfulMonad m : Prop where\n  callCC_bind_right {α ω γ} (cmd : m α) (next : Label ω m γ → α → m ω) :\n    (callCC fun f => cmd >>= next f) = cmd >>= fun x => callCC fun f => next f x\n  callCC_bind_left {α} (β) (x : α) (dead : Label α m β → β → m α) :\n    (callCC fun f : Label α m β => goto f x >>= dead f) = pure x\n  callCC_dummy {α β} (dummy : m α) : (callCC fun _ : Label α m β => dummy) = dummy\n\n"}
{"name":"ContT.run_contT_map_contT","module":"Mathlib.Control.Monad.Cont","initialProofState":"r : Type u\nm : Type u → Type v\nα : Type w\nf : m r → m r\nx : ContT r m α\n⊢ Eq (ContT.map f x).run (Function.comp f x.run)","decl":"theorem run_contT_map_contT (f : m r → m r) (x : ContT r m α) : run (map f x) = f ∘ run x :=\n  rfl\n\n"}
{"name":"ContT.run_withContT","module":"Mathlib.Control.Monad.Cont","initialProofState":"r : Type u\nm : Type u → Type v\nα β : Type w\nf : (β → m r) → α → m r\nx : ContT r m α\n⊢ Eq (ContT.withContT f x).run (Function.comp x.run f)","decl":"theorem run_withContT (f : (β → m r) → α → m r) (x : ContT r m α) :\n    run (withContT f x) = run x ∘ f :=\n  rfl\n\n"}
{"name":"ContT.ext","module":"Mathlib.Control.Monad.Cont","initialProofState":"r : Type u\nm : Type u → Type v\nα : Type w\nx y : ContT r m α\nh : ∀ (f : α → m r), Eq (x.run f) (y.run f)\n⊢ Eq x y","decl":"@[ext]\nprotected theorem ext {x y : ContT r m α} (h : ∀ f, x.run f = y.run f) : x = y := by\n  unfold ContT; ext; apply h\n\n"}
{"name":"ContT.ext_iff","module":"Mathlib.Control.Monad.Cont","initialProofState":"r : Type u\nm : Type u → Type v\nα : Type w\nx y : ContT r m α\n⊢ Iff (Eq x y) (∀ (f : α → m r), Eq (x.run f) (y.run f))","decl":"@[ext]\nprotected theorem ext {x y : ContT r m α} (h : ∀ f, x.run f = y.run f) : x = y := by\n  unfold ContT; ext; apply h\n\n"}
{"name":"ContT.instLawfulMonad","module":"Mathlib.Control.Monad.Cont","initialProofState":"r : Type u\nm : Type u → Type v\n⊢ LawfulMonad (ContT r m)","decl":"instance : LawfulMonad (ContT r m) := LawfulMonad.mk'\n  (id_map := by intros; rfl)\n  (pure_bind := by intros; ext; rfl)\n  (bind_assoc := by intros; ext; rfl)\n\n"}
{"name":"ContT.monadLift_bind","module":"Mathlib.Control.Monad.Cont","initialProofState":"r : Type u\nm : Type u → Type v\ninst✝¹ : Monad m\ninst✝ : LawfulMonad m\nα β : Type u\nx : m α\nf : α → m β\n⊢ Eq (ContT.monadLift (Bind.bind x f)) (Bind.bind (ContT.monadLift x) (Function.comp ContT.monadLift f))","decl":"theorem monadLift_bind [Monad m] [LawfulMonad m] {α β} (x : m α) (f : α → m β) :\n    (monadLift (x >>= f) : ContT r m β) = monadLift x >>= monadLift ∘ f := by\n  ext\n  simp only [monadLift, MonadLift.monadLift, (· ∘ ·), (· >>= ·), bind_assoc, id, run,\n    ContT.monadLift]\n\n"}
{"name":"ContT.instLawfulMonadCont","module":"Mathlib.Control.Monad.Cont","initialProofState":"r : Type u\nm : Type u → Type v\n⊢ LawfulMonadCont (ContT r m)","decl":"instance : LawfulMonadCont (ContT r m) where\n  callCC_bind_right := by intros; ext; rfl\n  callCC_bind_left := by intros; ext; rfl\n  callCC_dummy := by intros; ext; rfl\n\n"}
{"name":"ExceptT.goto_mkLabel","module":"Mathlib.Control.Monad.Cont","initialProofState":"m : Type u → Type v\ninst✝ : Monad m\nα β ε : Type u\nx : MonadCont.Label (Except ε α) m β\ni : α\n⊢ Eq (MonadCont.goto (ExceptT.mkLabel x) i) (ExceptT.mk (Functor.map Except.ok (MonadCont.goto x (Except.ok i))))","decl":"theorem ExceptT.goto_mkLabel {α β ε : Type _} (x : Label (Except.{u, u} ε α) m β) (i : α) :\n    goto (ExceptT.mkLabel x) i = ExceptT.mk (Except.ok <$> goto x (Except.ok i)) := by\n  cases x; rfl\n\n"}
{"name":"instLawfulMonadContExceptT","module":"Mathlib.Control.Monad.Cont","initialProofState":"m : Type u → Type v\ninst✝² : Monad m\nε : Type u\ninst✝¹ : MonadCont m\ninst✝ : LawfulMonadCont m\n⊢ LawfulMonadCont (ExceptT ε m)","decl":"instance {ε} [MonadCont m] [LawfulMonadCont m] : LawfulMonadCont (ExceptT ε m) where\n  callCC_bind_right := by\n    intros; simp only [callCC, ExceptT.callCC, ExceptT.run_bind, callCC_bind_right]; ext\n    dsimp\n    congr with ⟨⟩ <;> simp [ExceptT.bindCont, @callCC_dummy m _]\n  callCC_bind_left := by\n    intros\n    simp only [callCC, ExceptT.callCC, ExceptT.goto_mkLabel, map_eq_bind_pure_comp, Function.comp,\n      ExceptT.run_bind, ExceptT.run_mk, bind_assoc, pure_bind, @callCC_bind_left m _]\n    ext; rfl\n  callCC_dummy := by intros; simp only [callCC, ExceptT.callCC, @callCC_dummy m _]; ext; rfl\n\n"}
{"name":"OptionT.goto_mkLabel","module":"Mathlib.Control.Monad.Cont","initialProofState":"m : Type u → Type v\ninst✝ : Monad m\nα β : Type u\nx : MonadCont.Label (Option α) m β\ni : α\n⊢ Eq (MonadCont.goto (OptionT.mkLabel x) i) (OptionT.mk (Bind.bind (MonadCont.goto x (Option.some i)) fun a => Pure.pure (Option.some a)))","decl":"theorem OptionT.goto_mkLabel {α β : Type _} (x : Label (Option.{u} α) m β) (i : α) :\n    goto (OptionT.mkLabel x) i = OptionT.mk (goto x (some i) >>= fun a => pure (some a)) :=\n  rfl\n\n"}
{"name":"instLawfulMonadContOptionT","module":"Mathlib.Control.Monad.Cont","initialProofState":"m : Type u → Type v\ninst✝² : Monad m\ninst✝¹ : MonadCont m\ninst✝ : LawfulMonadCont m\n⊢ LawfulMonadCont (OptionT m)","decl":"instance [MonadCont m] [LawfulMonadCont m] : LawfulMonadCont (OptionT m) where\n  callCC_bind_right := by\n    intros; simp only [callCC, OptionT.callCC, OptionT.run_bind, callCC_bind_right]; ext\n    dsimp\n    congr with ⟨⟩ <;> simp [@callCC_dummy m _]\n  callCC_bind_left := by\n    intros\n    simp only [callCC, OptionT.callCC, OptionT.goto_mkLabel, OptionT.run_bind, OptionT.run_mk,\n      bind_assoc, pure_bind, @callCC_bind_left m _]\n    ext; rfl\n  callCC_dummy := by intros; simp only [callCC, OptionT.callCC, @callCC_dummy m _]; ext; rfl\n\n/- Porting note: In Lean 3, `One ω` is required for `MonadLift (WriterT ω m)`. In Lean 4,\n                 `EmptyCollection ω` or `Monoid ω` is required. So we give definitions for the both\n                 instances. -/\n\n"}
{"name":"WriterT.goto_mkLabel","module":"Mathlib.Control.Monad.Cont","initialProofState":"m : Type u → Type v\ninst✝¹ : Monad m\nα : Type u_1\nβ ω : Type u\ninst✝ : EmptyCollection ω\nx : MonadCont.Label (Prod α ω) m β\ni : α\n⊢ Eq (MonadCont.goto (WriterT.mkLabel x) i) (MonadLiftT.monadLift (MonadCont.goto x { fst := i, snd := EmptyCollection.emptyCollection }))","decl":"theorem WriterT.goto_mkLabel {α β ω : Type _} [EmptyCollection ω] (x : Label (α × ω) m β) (i : α) :\n    goto (WriterT.mkLabel x) i = monadLift (goto x (i, ∅)) := by cases x; rfl\n\n"}
{"name":"WriterT.goto_mkLabel'","module":"Mathlib.Control.Monad.Cont","initialProofState":"m : Type u → Type v\ninst✝¹ : Monad m\nα : Type u_1\nβ ω : Type u\ninst✝ : Monoid ω\nx : MonadCont.Label (Prod α ω) m β\ni : α\n⊢ Eq (MonadCont.goto (WriterT.mkLabel' x) i) (MonadLiftT.monadLift (MonadCont.goto x { fst := i, snd := 1 }))","decl":"theorem WriterT.goto_mkLabel' {α β ω : Type _} [Monoid ω] (x : Label (α × ω) m β) (i : α) :\n    goto (WriterT.mkLabel' x) i = monadLift (goto x (i, 1)) := by cases x; rfl\n\n"}
{"name":"StateT.goto_mkLabel","module":"Mathlib.Control.Monad.Cont","initialProofState":"m : Type u → Type v\nα β σ : Type u\nx : MonadCont.Label (Prod α σ) m (Prod β σ)\ni : α\n⊢ Eq (MonadCont.goto (StateT.mkLabel x) i) (StateT.mk fun s => MonadCont.goto x { fst := i, snd := s })","decl":"theorem StateT.goto_mkLabel {α β σ : Type u} (x : Label (α × σ) m (β × σ)) (i : α) :\n    goto (StateT.mkLabel x) i = StateT.mk (fun s => goto x (i, s)) := by cases x; rfl\n\n"}
{"name":"instLawfulMonadContStateT","module":"Mathlib.Control.Monad.Cont","initialProofState":"m : Type u → Type v\nσ : Type u\ninst✝² : Monad m\ninst✝¹ : MonadCont m\ninst✝ : LawfulMonadCont m\n⊢ LawfulMonadCont (StateT σ m)","decl":"instance {σ} [Monad m] [MonadCont m] [LawfulMonadCont m] : LawfulMonadCont (StateT σ m) where\n  callCC_bind_right := by\n    intros\n    simp only [callCC, StateT.callCC, StateT.run_bind, callCC_bind_right]; ext; rfl\n  callCC_bind_left := by\n    intros\n    simp only [callCC, StateT.callCC, StateT.goto_mkLabel, StateT.run_bind, StateT.run_mk,\n      callCC_bind_left]; ext; rfl\n  callCC_dummy := by\n    intros\n    simp only [callCC, StateT.callCC, @callCC_dummy m _]\n    ext; rfl\n\n"}
{"name":"ReaderT.goto_mkLabel","module":"Mathlib.Control.Monad.Cont","initialProofState":"m : Type u → Type v\nα : Type u_1\nρ β : Type u\nx : MonadCont.Label α m β\ni : α\n⊢ Eq (MonadCont.goto (ReaderT.mkLabel ρ x) i) (MonadLiftT.monadLift (MonadCont.goto x i))","decl":"theorem ReaderT.goto_mkLabel {α ρ β} (x : Label α m β) (i : α) :\n    goto (ReaderT.mkLabel ρ x) i = monadLift (goto x i) := by cases x; rfl\n\n"}
{"name":"instLawfulMonadContReaderT","module":"Mathlib.Control.Monad.Cont","initialProofState":"m : Type u → Type v\nρ : Type u\ninst✝² : Monad m\ninst✝¹ : MonadCont m\ninst✝ : LawfulMonadCont m\n⊢ LawfulMonadCont (ReaderT ρ m)","decl":"instance {ρ} [Monad m] [MonadCont m] [LawfulMonadCont m] : LawfulMonadCont (ReaderT ρ m) where\n  callCC_bind_right := by intros; simp only [callCC, ReaderT.callCC, ReaderT.run_bind,\n                                    callCC_bind_right]; ext; rfl\n  callCC_bind_left := by\n    intros; simp only [callCC, ReaderT.callCC, ReaderT.goto_mkLabel, ReaderT.run_bind,\n      ReaderT.run_monadLift, monadLift_self, callCC_bind_left]\n    ext; rfl\n  callCC_dummy := by intros; simp only [callCC, ReaderT.callCC, @callCC_dummy m _]; ext; rfl\n\n"}
