{"name":"CategoryTheory.Monoidal.InducingFunctorData.whiskerLeft_eq","module":"Mathlib.CategoryTheory.Monoidal.Transport","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\ninst✝² : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\ninst✝ : CategoryTheory.MonoidalCategoryStruct D\nF : CategoryTheory.Functor D C\nself : CategoryTheory.Monoidal.InducingFunctorData F\nX Y₁ Y₂ : D\nf : Quiver.Hom Y₁ Y₂\n⊢ Eq (F.map (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X f)) (CategoryTheory.CategoryStruct.comp (self.μIso X Y₁).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (F.obj X) (F.map f)) (self.μIso X Y₂).hom))","decl":"/-- The data needed to induce a `MonoidalCategory` via the functor `F`; namely, pre-existing\ndefinitions of `⊗`, `𝟙_`, `▷`, `◁` that are preserved by `F`.\n-/\nstructure InducingFunctorData [MonoidalCategoryStruct D] (F : D ⥤ C) where\n  /-- Analogous to `CategoryTheory.LaxMonoidalFunctor.μIso` -/\n  μIso : ∀ X Y,\n    F.obj X ⊗ F.obj Y ≅ F.obj (X ⊗ Y)\n  whiskerLeft_eq : ∀ (X : D) {Y₁ Y₂ : D} (f : Y₁ ⟶ Y₂),\n    F.map (X ◁ f) = (μIso _ _).inv ≫ (F.obj X ◁ F.map f) ≫ (μIso _ _).hom := by\n    aesop_cat\n  whiskerRight_eq : ∀ {X₁ X₂ : D} (f : X₁ ⟶ X₂) (Y : D),\n    F.map (f ▷ Y) = (μIso _ _).inv ≫ (F.map f ▷ F.obj Y) ≫ (μIso _ _).hom := by\n    aesop_cat\n  tensorHom_eq : ∀ {X₁ Y₁ X₂ Y₂ : D} (f : X₁ ⟶ Y₁) (g : X₂ ⟶ Y₂),\n    F.map (f ⊗ g) = (μIso _ _).inv ≫ (F.map f ⊗ F.map g) ≫ (μIso _ _).hom := by\n    aesop_cat\n  /-- Analogous to `CategoryTheory.LaxMonoidalFunctor.εIso` -/\n  εIso : 𝟙_ _ ≅ F.obj (𝟙_ _)\n  associator_eq : ∀ X Y Z : D,\n    F.map (α_ X Y Z).hom =\n      (((μIso _ _).symm ≪≫ ((μIso _ _).symm ⊗ .refl _))\n        ≪≫ α_ (F.obj X) (F.obj Y) (F.obj Z)\n        ≪≫ ((.refl _ ⊗ μIso _ _) ≪≫ μIso _ _)).hom := by\n    aesop_cat\n  leftUnitor_eq : ∀ X : D,\n    F.map (λ_ X).hom =\n      (((μIso _ _).symm ≪≫ (εIso.symm ⊗ .refl _)) ≪≫ λ_ (F.obj X)).hom := by\n    aesop_cat\n  rightUnitor_eq : ∀ X : D,\n    F.map (ρ_ X).hom =\n      (((μIso _ _).symm ≪≫ (.refl _ ⊗ εIso.symm)) ≪≫ ρ_ (F.obj X)).hom := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.Monoidal.InducingFunctorData.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Monoidal.Transport","initialProofState":"C : Type u₁\ninst✝⁵ : CategoryTheory.Category.{v₁, u₁} C\ninst✝⁴ : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\ninst✝² : CategoryTheory.MonoidalCategoryStruct D\nF : CategoryTheory.Functor D C\ninst✝¹ : SizeOf C\ninst✝ : SizeOf D\nμIso : (X Y : D) → CategoryTheory.Iso (CategoryTheory.MonoidalCategoryStruct.tensorObj (F.obj X) (F.obj Y)) (F.obj (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y))\nwhiskerLeft_eq : autoParam (∀ (X : D) {Y₁ Y₂ : D} (f : Quiver.Hom Y₁ Y₂), Eq (F.map (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X f)) (CategoryTheory.CategoryStruct.comp (μIso X Y₁).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (F.obj X) (F.map f)) (μIso X Y₂).hom))) _auto✝\nwhiskerRight_eq : autoParam (∀ {X₁ X₂ : D} (f : Quiver.Hom X₁ X₂) (Y : D), Eq (F.map (CategoryTheory.MonoidalCategoryStruct.whiskerRight f Y)) (CategoryTheory.CategoryStruct.comp (μIso X₁ Y).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (F.map f) (F.obj Y)) (μIso X₂ Y).hom))) _auto✝\ntensorHom_eq : autoParam (∀ {X₁ Y₁ X₂ Y₂ : D} (f : Quiver.Hom X₁ Y₁) (g : Quiver.Hom X₂ Y₂), Eq (F.map (CategoryTheory.MonoidalCategoryStruct.tensorHom f g)) (CategoryTheory.CategoryStruct.comp (μIso X₁ X₂).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom (F.map f) (F.map g)) (μIso Y₁ Y₂).hom))) _auto✝\nεIso : CategoryTheory.Iso CategoryTheory.MonoidalCategoryStruct.tensorUnit (F.obj CategoryTheory.MonoidalCategoryStruct.tensorUnit)\nassociator_eq : autoParam (∀ (X Y Z : D), Eq (F.map (CategoryTheory.MonoidalCategoryStruct.associator X Y Z).hom) (((μIso (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y) Z).symm.trans (CategoryTheory.MonoidalCategory.tensorIso (μIso X Y).symm (CategoryTheory.Iso.refl (F.obj Z)))).trans ((CategoryTheory.MonoidalCategoryStruct.associator (F.obj X) (F.obj Y) (F.obj Z)).trans ((CategoryTheory.MonoidalCategory.tensorIso (CategoryTheory.Iso.refl (F.obj X)) (μIso Y Z)).trans (μIso X (CategoryTheory.MonoidalCategoryStruct.tensorObj Y Z))))).hom) _auto✝\nleftUnitor_eq : autoParam (∀ (X : D), Eq (F.map (CategoryTheory.MonoidalCategoryStruct.leftUnitor X).hom) (((μIso CategoryTheory.MonoidalCategoryStruct.tensorUnit X).symm.trans (CategoryTheory.MonoidalCategory.tensorIso εIso.symm (CategoryTheory.Iso.refl (F.obj X)))).trans (CategoryTheory.MonoidalCategoryStruct.leftUnitor (F.obj X))).hom) _auto✝\nrightUnitor_eq : autoParam (∀ (X : D), Eq (F.map (CategoryTheory.MonoidalCategoryStruct.rightUnitor X).hom) (((μIso X CategoryTheory.MonoidalCategoryStruct.tensorUnit).symm.trans (CategoryTheory.MonoidalCategory.tensorIso (CategoryTheory.Iso.refl (F.obj X)) εIso.symm)).trans (CategoryTheory.MonoidalCategoryStruct.rightUnitor (F.obj X))).hom) _auto✝\n⊢ Eq (SizeOf.sizeOf { μIso := μIso, whiskerLeft_eq := whiskerLeft_eq, whiskerRight_eq := whiskerRight_eq, tensorHom_eq := tensorHom_eq, εIso := εIso, associator_eq := associator_eq, leftUnitor_eq := leftUnitor_eq, rightUnitor_eq := rightUnitor_eq }) (HAdd.hAdd 1 (SizeOf.sizeOf εIso))","decl":"/-- The data needed to induce a `MonoidalCategory` via the functor `F`; namely, pre-existing\ndefinitions of `⊗`, `𝟙_`, `▷`, `◁` that are preserved by `F`.\n-/\nstructure InducingFunctorData [MonoidalCategoryStruct D] (F : D ⥤ C) where\n  /-- Analogous to `CategoryTheory.LaxMonoidalFunctor.μIso` -/\n  μIso : ∀ X Y,\n    F.obj X ⊗ F.obj Y ≅ F.obj (X ⊗ Y)\n  whiskerLeft_eq : ∀ (X : D) {Y₁ Y₂ : D} (f : Y₁ ⟶ Y₂),\n    F.map (X ◁ f) = (μIso _ _).inv ≫ (F.obj X ◁ F.map f) ≫ (μIso _ _).hom := by\n    aesop_cat\n  whiskerRight_eq : ∀ {X₁ X₂ : D} (f : X₁ ⟶ X₂) (Y : D),\n    F.map (f ▷ Y) = (μIso _ _).inv ≫ (F.map f ▷ F.obj Y) ≫ (μIso _ _).hom := by\n    aesop_cat\n  tensorHom_eq : ∀ {X₁ Y₁ X₂ Y₂ : D} (f : X₁ ⟶ Y₁) (g : X₂ ⟶ Y₂),\n    F.map (f ⊗ g) = (μIso _ _).inv ≫ (F.map f ⊗ F.map g) ≫ (μIso _ _).hom := by\n    aesop_cat\n  /-- Analogous to `CategoryTheory.LaxMonoidalFunctor.εIso` -/\n  εIso : 𝟙_ _ ≅ F.obj (𝟙_ _)\n  associator_eq : ∀ X Y Z : D,\n    F.map (α_ X Y Z).hom =\n      (((μIso _ _).symm ≪≫ ((μIso _ _).symm ⊗ .refl _))\n        ≪≫ α_ (F.obj X) (F.obj Y) (F.obj Z)\n        ≪≫ ((.refl _ ⊗ μIso _ _) ≪≫ μIso _ _)).hom := by\n    aesop_cat\n  leftUnitor_eq : ∀ X : D,\n    F.map (λ_ X).hom =\n      (((μIso _ _).symm ≪≫ (εIso.symm ⊗ .refl _)) ≪≫ λ_ (F.obj X)).hom := by\n    aesop_cat\n  rightUnitor_eq : ∀ X : D,\n    F.map (ρ_ X).hom =\n      (((μIso _ _).symm ≪≫ (.refl _ ⊗ εIso.symm)) ≪≫ ρ_ (F.obj X)).hom := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.Monoidal.InducingFunctorData.whiskerRight_eq","module":"Mathlib.CategoryTheory.Monoidal.Transport","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\ninst✝² : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\ninst✝ : CategoryTheory.MonoidalCategoryStruct D\nF : CategoryTheory.Functor D C\nself : CategoryTheory.Monoidal.InducingFunctorData F\nX₁ X₂ : D\nf : Quiver.Hom X₁ X₂\nY : D\n⊢ Eq (F.map (CategoryTheory.MonoidalCategoryStruct.whiskerRight f Y)) (CategoryTheory.CategoryStruct.comp (self.μIso X₁ Y).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (F.map f) (F.obj Y)) (self.μIso X₂ Y).hom))","decl":"/-- The data needed to induce a `MonoidalCategory` via the functor `F`; namely, pre-existing\ndefinitions of `⊗`, `𝟙_`, `▷`, `◁` that are preserved by `F`.\n-/\nstructure InducingFunctorData [MonoidalCategoryStruct D] (F : D ⥤ C) where\n  /-- Analogous to `CategoryTheory.LaxMonoidalFunctor.μIso` -/\n  μIso : ∀ X Y,\n    F.obj X ⊗ F.obj Y ≅ F.obj (X ⊗ Y)\n  whiskerLeft_eq : ∀ (X : D) {Y₁ Y₂ : D} (f : Y₁ ⟶ Y₂),\n    F.map (X ◁ f) = (μIso _ _).inv ≫ (F.obj X ◁ F.map f) ≫ (μIso _ _).hom := by\n    aesop_cat\n  whiskerRight_eq : ∀ {X₁ X₂ : D} (f : X₁ ⟶ X₂) (Y : D),\n    F.map (f ▷ Y) = (μIso _ _).inv ≫ (F.map f ▷ F.obj Y) ≫ (μIso _ _).hom := by\n    aesop_cat\n  tensorHom_eq : ∀ {X₁ Y₁ X₂ Y₂ : D} (f : X₁ ⟶ Y₁) (g : X₂ ⟶ Y₂),\n    F.map (f ⊗ g) = (μIso _ _).inv ≫ (F.map f ⊗ F.map g) ≫ (μIso _ _).hom := by\n    aesop_cat\n  /-- Analogous to `CategoryTheory.LaxMonoidalFunctor.εIso` -/\n  εIso : 𝟙_ _ ≅ F.obj (𝟙_ _)\n  associator_eq : ∀ X Y Z : D,\n    F.map (α_ X Y Z).hom =\n      (((μIso _ _).symm ≪≫ ((μIso _ _).symm ⊗ .refl _))\n        ≪≫ α_ (F.obj X) (F.obj Y) (F.obj Z)\n        ≪≫ ((.refl _ ⊗ μIso _ _) ≪≫ μIso _ _)).hom := by\n    aesop_cat\n  leftUnitor_eq : ∀ X : D,\n    F.map (λ_ X).hom =\n      (((μIso _ _).symm ≪≫ (εIso.symm ⊗ .refl _)) ≪≫ λ_ (F.obj X)).hom := by\n    aesop_cat\n  rightUnitor_eq : ∀ X : D,\n    F.map (ρ_ X).hom =\n      (((μIso _ _).symm ≪≫ (.refl _ ⊗ εIso.symm)) ≪≫ ρ_ (F.obj X)).hom := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.Monoidal.InducingFunctorData.mk.inj","module":"Mathlib.CategoryTheory.Monoidal.Transport","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\ninst✝² : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\ninst✝ : CategoryTheory.MonoidalCategoryStruct D\nF : CategoryTheory.Functor D C\nμIso✝ : (X Y : D) → CategoryTheory.Iso (CategoryTheory.MonoidalCategoryStruct.tensorObj (F.obj X) (F.obj Y)) (F.obj (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y))\nwhiskerLeft_eq✝ : autoParam (∀ (X : D) {Y₁ Y₂ : D} (f : Quiver.Hom Y₁ Y₂), Eq (F.map (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X f)) (CategoryTheory.CategoryStruct.comp (μIso✝ X Y₁).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (F.obj X) (F.map f)) (μIso✝ X Y₂).hom))) _auto✝\nwhiskerRight_eq✝ : autoParam (∀ {X₁ X₂ : D} (f : Quiver.Hom X₁ X₂) (Y : D), Eq (F.map (CategoryTheory.MonoidalCategoryStruct.whiskerRight f Y)) (CategoryTheory.CategoryStruct.comp (μIso✝ X₁ Y).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (F.map f) (F.obj Y)) (μIso✝ X₂ Y).hom))) _auto✝\ntensorHom_eq✝ : autoParam (∀ {X₁ Y₁ X₂ Y₂ : D} (f : Quiver.Hom X₁ Y₁) (g : Quiver.Hom X₂ Y₂), Eq (F.map (CategoryTheory.MonoidalCategoryStruct.tensorHom f g)) (CategoryTheory.CategoryStruct.comp (μIso✝ X₁ X₂).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom (F.map f) (F.map g)) (μIso✝ Y₁ Y₂).hom))) _auto✝\nεIso✝ : CategoryTheory.Iso CategoryTheory.MonoidalCategoryStruct.tensorUnit (F.obj CategoryTheory.MonoidalCategoryStruct.tensorUnit)\nassociator_eq✝ : autoParam (∀ (X Y Z : D), Eq (F.map (CategoryTheory.MonoidalCategoryStruct.associator X Y Z).hom) (((μIso✝ (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y) Z).symm.trans (CategoryTheory.MonoidalCategory.tensorIso (μIso✝ X Y).symm (CategoryTheory.Iso.refl (F.obj Z)))).trans ((CategoryTheory.MonoidalCategoryStruct.associator (F.obj X) (F.obj Y) (F.obj Z)).trans ((CategoryTheory.MonoidalCategory.tensorIso (CategoryTheory.Iso.refl (F.obj X)) (μIso✝ Y Z)).trans (μIso✝ X (CategoryTheory.MonoidalCategoryStruct.tensorObj Y Z))))).hom) _auto✝\nleftUnitor_eq✝ : autoParam (∀ (X : D), Eq (F.map (CategoryTheory.MonoidalCategoryStruct.leftUnitor X).hom) (((μIso✝ CategoryTheory.MonoidalCategoryStruct.tensorUnit X).symm.trans (CategoryTheory.MonoidalCategory.tensorIso εIso✝.symm (CategoryTheory.Iso.refl (F.obj X)))).trans (CategoryTheory.MonoidalCategoryStruct.leftUnitor (F.obj X))).hom) _auto✝\nrightUnitor_eq✝ : autoParam (∀ (X : D), Eq (F.map (CategoryTheory.MonoidalCategoryStruct.rightUnitor X).hom) (((μIso✝ X CategoryTheory.MonoidalCategoryStruct.tensorUnit).symm.trans (CategoryTheory.MonoidalCategory.tensorIso (CategoryTheory.Iso.refl (F.obj X)) εIso✝.symm)).trans (CategoryTheory.MonoidalCategoryStruct.rightUnitor (F.obj X))).hom) _auto✝\nμIso : (X Y : D) → CategoryTheory.Iso (CategoryTheory.MonoidalCategoryStruct.tensorObj (F.obj X) (F.obj Y)) (F.obj (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y))\nwhiskerLeft_eq : autoParam (∀ (X : D) {Y₁ Y₂ : D} (f : Quiver.Hom Y₁ Y₂), Eq (F.map (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X f)) (CategoryTheory.CategoryStruct.comp (μIso X Y₁).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (F.obj X) (F.map f)) (μIso X Y₂).hom))) _auto✝\nwhiskerRight_eq : autoParam (∀ {X₁ X₂ : D} (f : Quiver.Hom X₁ X₂) (Y : D), Eq (F.map (CategoryTheory.MonoidalCategoryStruct.whiskerRight f Y)) (CategoryTheory.CategoryStruct.comp (μIso X₁ Y).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (F.map f) (F.obj Y)) (μIso X₂ Y).hom))) _auto✝\ntensorHom_eq : autoParam (∀ {X₁ Y₁ X₂ Y₂ : D} (f : Quiver.Hom X₁ Y₁) (g : Quiver.Hom X₂ Y₂), Eq (F.map (CategoryTheory.MonoidalCategoryStruct.tensorHom f g)) (CategoryTheory.CategoryStruct.comp (μIso X₁ X₂).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom (F.map f) (F.map g)) (μIso Y₁ Y₂).hom))) _auto✝\nεIso : CategoryTheory.Iso CategoryTheory.MonoidalCategoryStruct.tensorUnit (F.obj CategoryTheory.MonoidalCategoryStruct.tensorUnit)\nassociator_eq : autoParam (∀ (X Y Z : D), Eq (F.map (CategoryTheory.MonoidalCategoryStruct.associator X Y Z).hom) (((μIso (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y) Z).symm.trans (CategoryTheory.MonoidalCategory.tensorIso (μIso X Y).symm (CategoryTheory.Iso.refl (F.obj Z)))).trans ((CategoryTheory.MonoidalCategoryStruct.associator (F.obj X) (F.obj Y) (F.obj Z)).trans ((CategoryTheory.MonoidalCategory.tensorIso (CategoryTheory.Iso.refl (F.obj X)) (μIso Y Z)).trans (μIso X (CategoryTheory.MonoidalCategoryStruct.tensorObj Y Z))))).hom) _auto✝\nleftUnitor_eq : autoParam (∀ (X : D), Eq (F.map (CategoryTheory.MonoidalCategoryStruct.leftUnitor X).hom) (((μIso CategoryTheory.MonoidalCategoryStruct.tensorUnit X).symm.trans (CategoryTheory.MonoidalCategory.tensorIso εIso.symm (CategoryTheory.Iso.refl (F.obj X)))).trans (CategoryTheory.MonoidalCategoryStruct.leftUnitor (F.obj X))).hom) _auto✝\nrightUnitor_eq : autoParam (∀ (X : D), Eq (F.map (CategoryTheory.MonoidalCategoryStruct.rightUnitor X).hom) (((μIso X CategoryTheory.MonoidalCategoryStruct.tensorUnit).symm.trans (CategoryTheory.MonoidalCategory.tensorIso (CategoryTheory.Iso.refl (F.obj X)) εIso.symm)).trans (CategoryTheory.MonoidalCategoryStruct.rightUnitor (F.obj X))).hom) _auto✝\nx✝ : Eq { μIso := μIso✝, whiskerLeft_eq := whiskerLeft_eq✝, whiskerRight_eq := whiskerRight_eq✝, tensorHom_eq := tensorHom_eq✝, εIso := εIso✝, associator_eq := associator_eq✝, leftUnitor_eq := leftUnitor_eq✝, rightUnitor_eq := rightUnitor_eq✝ } { μIso := μIso, whiskerLeft_eq := whiskerLeft_eq, whiskerRight_eq := whiskerRight_eq, tensorHom_eq := tensorHom_eq, εIso := εIso, associator_eq := associator_eq, leftUnitor_eq := leftUnitor_eq, rightUnitor_eq := rightUnitor_eq }\n⊢ And (Eq μIso✝ μIso) (Eq εIso✝ εIso)","decl":"/-- The data needed to induce a `MonoidalCategory` via the functor `F`; namely, pre-existing\ndefinitions of `⊗`, `𝟙_`, `▷`, `◁` that are preserved by `F`.\n-/\nstructure InducingFunctorData [MonoidalCategoryStruct D] (F : D ⥤ C) where\n  /-- Analogous to `CategoryTheory.LaxMonoidalFunctor.μIso` -/\n  μIso : ∀ X Y,\n    F.obj X ⊗ F.obj Y ≅ F.obj (X ⊗ Y)\n  whiskerLeft_eq : ∀ (X : D) {Y₁ Y₂ : D} (f : Y₁ ⟶ Y₂),\n    F.map (X ◁ f) = (μIso _ _).inv ≫ (F.obj X ◁ F.map f) ≫ (μIso _ _).hom := by\n    aesop_cat\n  whiskerRight_eq : ∀ {X₁ X₂ : D} (f : X₁ ⟶ X₂) (Y : D),\n    F.map (f ▷ Y) = (μIso _ _).inv ≫ (F.map f ▷ F.obj Y) ≫ (μIso _ _).hom := by\n    aesop_cat\n  tensorHom_eq : ∀ {X₁ Y₁ X₂ Y₂ : D} (f : X₁ ⟶ Y₁) (g : X₂ ⟶ Y₂),\n    F.map (f ⊗ g) = (μIso _ _).inv ≫ (F.map f ⊗ F.map g) ≫ (μIso _ _).hom := by\n    aesop_cat\n  /-- Analogous to `CategoryTheory.LaxMonoidalFunctor.εIso` -/\n  εIso : 𝟙_ _ ≅ F.obj (𝟙_ _)\n  associator_eq : ∀ X Y Z : D,\n    F.map (α_ X Y Z).hom =\n      (((μIso _ _).symm ≪≫ ((μIso _ _).symm ⊗ .refl _))\n        ≪≫ α_ (F.obj X) (F.obj Y) (F.obj Z)\n        ≪≫ ((.refl _ ⊗ μIso _ _) ≪≫ μIso _ _)).hom := by\n    aesop_cat\n  leftUnitor_eq : ∀ X : D,\n    F.map (λ_ X).hom =\n      (((μIso _ _).symm ≪≫ (εIso.symm ⊗ .refl _)) ≪≫ λ_ (F.obj X)).hom := by\n    aesop_cat\n  rightUnitor_eq : ∀ X : D,\n    F.map (ρ_ X).hom =\n      (((μIso _ _).symm ≪≫ (.refl _ ⊗ εIso.symm)) ≪≫ ρ_ (F.obj X)).hom := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.Monoidal.InducingFunctorData.leftUnitor_eq","module":"Mathlib.CategoryTheory.Monoidal.Transport","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\ninst✝² : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\ninst✝ : CategoryTheory.MonoidalCategoryStruct D\nF : CategoryTheory.Functor D C\nself : CategoryTheory.Monoidal.InducingFunctorData F\nX : D\n⊢ Eq (F.map (CategoryTheory.MonoidalCategoryStruct.leftUnitor X).hom) (((self.μIso CategoryTheory.MonoidalCategoryStruct.tensorUnit X).symm.trans (CategoryTheory.MonoidalCategory.tensorIso self.εIso.symm (CategoryTheory.Iso.refl (F.obj X)))).trans (CategoryTheory.MonoidalCategoryStruct.leftUnitor (F.obj X))).hom","decl":"/-- The data needed to induce a `MonoidalCategory` via the functor `F`; namely, pre-existing\ndefinitions of `⊗`, `𝟙_`, `▷`, `◁` that are preserved by `F`.\n-/\nstructure InducingFunctorData [MonoidalCategoryStruct D] (F : D ⥤ C) where\n  /-- Analogous to `CategoryTheory.LaxMonoidalFunctor.μIso` -/\n  μIso : ∀ X Y,\n    F.obj X ⊗ F.obj Y ≅ F.obj (X ⊗ Y)\n  whiskerLeft_eq : ∀ (X : D) {Y₁ Y₂ : D} (f : Y₁ ⟶ Y₂),\n    F.map (X ◁ f) = (μIso _ _).inv ≫ (F.obj X ◁ F.map f) ≫ (μIso _ _).hom := by\n    aesop_cat\n  whiskerRight_eq : ∀ {X₁ X₂ : D} (f : X₁ ⟶ X₂) (Y : D),\n    F.map (f ▷ Y) = (μIso _ _).inv ≫ (F.map f ▷ F.obj Y) ≫ (μIso _ _).hom := by\n    aesop_cat\n  tensorHom_eq : ∀ {X₁ Y₁ X₂ Y₂ : D} (f : X₁ ⟶ Y₁) (g : X₂ ⟶ Y₂),\n    F.map (f ⊗ g) = (μIso _ _).inv ≫ (F.map f ⊗ F.map g) ≫ (μIso _ _).hom := by\n    aesop_cat\n  /-- Analogous to `CategoryTheory.LaxMonoidalFunctor.εIso` -/\n  εIso : 𝟙_ _ ≅ F.obj (𝟙_ _)\n  associator_eq : ∀ X Y Z : D,\n    F.map (α_ X Y Z).hom =\n      (((μIso _ _).symm ≪≫ ((μIso _ _).symm ⊗ .refl _))\n        ≪≫ α_ (F.obj X) (F.obj Y) (F.obj Z)\n        ≪≫ ((.refl _ ⊗ μIso _ _) ≪≫ μIso _ _)).hom := by\n    aesop_cat\n  leftUnitor_eq : ∀ X : D,\n    F.map (λ_ X).hom =\n      (((μIso _ _).symm ≪≫ (εIso.symm ⊗ .refl _)) ≪≫ λ_ (F.obj X)).hom := by\n    aesop_cat\n  rightUnitor_eq : ∀ X : D,\n    F.map (ρ_ X).hom =\n      (((μIso _ _).symm ≪≫ (.refl _ ⊗ εIso.symm)) ≪≫ ρ_ (F.obj X)).hom := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.Monoidal.InducingFunctorData.mk.injEq","module":"Mathlib.CategoryTheory.Monoidal.Transport","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\ninst✝² : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\ninst✝ : CategoryTheory.MonoidalCategoryStruct D\nF : CategoryTheory.Functor D C\nμIso✝ : (X Y : D) → CategoryTheory.Iso (CategoryTheory.MonoidalCategoryStruct.tensorObj (F.obj X) (F.obj Y)) (F.obj (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y))\nwhiskerLeft_eq✝ : autoParam (∀ (X : D) {Y₁ Y₂ : D} (f : Quiver.Hom Y₁ Y₂), Eq (F.map (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X f)) (CategoryTheory.CategoryStruct.comp (μIso✝ X Y₁).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (F.obj X) (F.map f)) (μIso✝ X Y₂).hom))) _auto✝\nwhiskerRight_eq✝ : autoParam (∀ {X₁ X₂ : D} (f : Quiver.Hom X₁ X₂) (Y : D), Eq (F.map (CategoryTheory.MonoidalCategoryStruct.whiskerRight f Y)) (CategoryTheory.CategoryStruct.comp (μIso✝ X₁ Y).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (F.map f) (F.obj Y)) (μIso✝ X₂ Y).hom))) _auto✝\ntensorHom_eq✝ : autoParam (∀ {X₁ Y₁ X₂ Y₂ : D} (f : Quiver.Hom X₁ Y₁) (g : Quiver.Hom X₂ Y₂), Eq (F.map (CategoryTheory.MonoidalCategoryStruct.tensorHom f g)) (CategoryTheory.CategoryStruct.comp (μIso✝ X₁ X₂).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom (F.map f) (F.map g)) (μIso✝ Y₁ Y₂).hom))) _auto✝\nεIso✝ : CategoryTheory.Iso CategoryTheory.MonoidalCategoryStruct.tensorUnit (F.obj CategoryTheory.MonoidalCategoryStruct.tensorUnit)\nassociator_eq✝ : autoParam (∀ (X Y Z : D), Eq (F.map (CategoryTheory.MonoidalCategoryStruct.associator X Y Z).hom) (((μIso✝ (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y) Z).symm.trans (CategoryTheory.MonoidalCategory.tensorIso (μIso✝ X Y).symm (CategoryTheory.Iso.refl (F.obj Z)))).trans ((CategoryTheory.MonoidalCategoryStruct.associator (F.obj X) (F.obj Y) (F.obj Z)).trans ((CategoryTheory.MonoidalCategory.tensorIso (CategoryTheory.Iso.refl (F.obj X)) (μIso✝ Y Z)).trans (μIso✝ X (CategoryTheory.MonoidalCategoryStruct.tensorObj Y Z))))).hom) _auto✝\nleftUnitor_eq✝ : autoParam (∀ (X : D), Eq (F.map (CategoryTheory.MonoidalCategoryStruct.leftUnitor X).hom) (((μIso✝ CategoryTheory.MonoidalCategoryStruct.tensorUnit X).symm.trans (CategoryTheory.MonoidalCategory.tensorIso εIso✝.symm (CategoryTheory.Iso.refl (F.obj X)))).trans (CategoryTheory.MonoidalCategoryStruct.leftUnitor (F.obj X))).hom) _auto✝\nrightUnitor_eq✝ : autoParam (∀ (X : D), Eq (F.map (CategoryTheory.MonoidalCategoryStruct.rightUnitor X).hom) (((μIso✝ X CategoryTheory.MonoidalCategoryStruct.tensorUnit).symm.trans (CategoryTheory.MonoidalCategory.tensorIso (CategoryTheory.Iso.refl (F.obj X)) εIso✝.symm)).trans (CategoryTheory.MonoidalCategoryStruct.rightUnitor (F.obj X))).hom) _auto✝\nμIso : (X Y : D) → CategoryTheory.Iso (CategoryTheory.MonoidalCategoryStruct.tensorObj (F.obj X) (F.obj Y)) (F.obj (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y))\nwhiskerLeft_eq : autoParam (∀ (X : D) {Y₁ Y₂ : D} (f : Quiver.Hom Y₁ Y₂), Eq (F.map (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X f)) (CategoryTheory.CategoryStruct.comp (μIso X Y₁).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (F.obj X) (F.map f)) (μIso X Y₂).hom))) _auto✝\nwhiskerRight_eq : autoParam (∀ {X₁ X₂ : D} (f : Quiver.Hom X₁ X₂) (Y : D), Eq (F.map (CategoryTheory.MonoidalCategoryStruct.whiskerRight f Y)) (CategoryTheory.CategoryStruct.comp (μIso X₁ Y).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (F.map f) (F.obj Y)) (μIso X₂ Y).hom))) _auto✝\ntensorHom_eq : autoParam (∀ {X₁ Y₁ X₂ Y₂ : D} (f : Quiver.Hom X₁ Y₁) (g : Quiver.Hom X₂ Y₂), Eq (F.map (CategoryTheory.MonoidalCategoryStruct.tensorHom f g)) (CategoryTheory.CategoryStruct.comp (μIso X₁ X₂).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom (F.map f) (F.map g)) (μIso Y₁ Y₂).hom))) _auto✝\nεIso : CategoryTheory.Iso CategoryTheory.MonoidalCategoryStruct.tensorUnit (F.obj CategoryTheory.MonoidalCategoryStruct.tensorUnit)\nassociator_eq : autoParam (∀ (X Y Z : D), Eq (F.map (CategoryTheory.MonoidalCategoryStruct.associator X Y Z).hom) (((μIso (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y) Z).symm.trans (CategoryTheory.MonoidalCategory.tensorIso (μIso X Y).symm (CategoryTheory.Iso.refl (F.obj Z)))).trans ((CategoryTheory.MonoidalCategoryStruct.associator (F.obj X) (F.obj Y) (F.obj Z)).trans ((CategoryTheory.MonoidalCategory.tensorIso (CategoryTheory.Iso.refl (F.obj X)) (μIso Y Z)).trans (μIso X (CategoryTheory.MonoidalCategoryStruct.tensorObj Y Z))))).hom) _auto✝\nleftUnitor_eq : autoParam (∀ (X : D), Eq (F.map (CategoryTheory.MonoidalCategoryStruct.leftUnitor X).hom) (((μIso CategoryTheory.MonoidalCategoryStruct.tensorUnit X).symm.trans (CategoryTheory.MonoidalCategory.tensorIso εIso.symm (CategoryTheory.Iso.refl (F.obj X)))).trans (CategoryTheory.MonoidalCategoryStruct.leftUnitor (F.obj X))).hom) _auto✝\nrightUnitor_eq : autoParam (∀ (X : D), Eq (F.map (CategoryTheory.MonoidalCategoryStruct.rightUnitor X).hom) (((μIso X CategoryTheory.MonoidalCategoryStruct.tensorUnit).symm.trans (CategoryTheory.MonoidalCategory.tensorIso (CategoryTheory.Iso.refl (F.obj X)) εIso.symm)).trans (CategoryTheory.MonoidalCategoryStruct.rightUnitor (F.obj X))).hom) _auto✝\n⊢ Eq (Eq { μIso := μIso✝, whiskerLeft_eq := whiskerLeft_eq✝, whiskerRight_eq := whiskerRight_eq✝, tensorHom_eq := tensorHom_eq✝, εIso := εIso✝, associator_eq := associator_eq✝, leftUnitor_eq := leftUnitor_eq✝, rightUnitor_eq := rightUnitor_eq✝ } { μIso := μIso, whiskerLeft_eq := whiskerLeft_eq, whiskerRight_eq := whiskerRight_eq, tensorHom_eq := tensorHom_eq, εIso := εIso, associator_eq := associator_eq, leftUnitor_eq := leftUnitor_eq, rightUnitor_eq := rightUnitor_eq }) (And (Eq μIso✝ μIso) (Eq εIso✝ εIso))","decl":"/-- The data needed to induce a `MonoidalCategory` via the functor `F`; namely, pre-existing\ndefinitions of `⊗`, `𝟙_`, `▷`, `◁` that are preserved by `F`.\n-/\nstructure InducingFunctorData [MonoidalCategoryStruct D] (F : D ⥤ C) where\n  /-- Analogous to `CategoryTheory.LaxMonoidalFunctor.μIso` -/\n  μIso : ∀ X Y,\n    F.obj X ⊗ F.obj Y ≅ F.obj (X ⊗ Y)\n  whiskerLeft_eq : ∀ (X : D) {Y₁ Y₂ : D} (f : Y₁ ⟶ Y₂),\n    F.map (X ◁ f) = (μIso _ _).inv ≫ (F.obj X ◁ F.map f) ≫ (μIso _ _).hom := by\n    aesop_cat\n  whiskerRight_eq : ∀ {X₁ X₂ : D} (f : X₁ ⟶ X₂) (Y : D),\n    F.map (f ▷ Y) = (μIso _ _).inv ≫ (F.map f ▷ F.obj Y) ≫ (μIso _ _).hom := by\n    aesop_cat\n  tensorHom_eq : ∀ {X₁ Y₁ X₂ Y₂ : D} (f : X₁ ⟶ Y₁) (g : X₂ ⟶ Y₂),\n    F.map (f ⊗ g) = (μIso _ _).inv ≫ (F.map f ⊗ F.map g) ≫ (μIso _ _).hom := by\n    aesop_cat\n  /-- Analogous to `CategoryTheory.LaxMonoidalFunctor.εIso` -/\n  εIso : 𝟙_ _ ≅ F.obj (𝟙_ _)\n  associator_eq : ∀ X Y Z : D,\n    F.map (α_ X Y Z).hom =\n      (((μIso _ _).symm ≪≫ ((μIso _ _).symm ⊗ .refl _))\n        ≪≫ α_ (F.obj X) (F.obj Y) (F.obj Z)\n        ≪≫ ((.refl _ ⊗ μIso _ _) ≪≫ μIso _ _)).hom := by\n    aesop_cat\n  leftUnitor_eq : ∀ X : D,\n    F.map (λ_ X).hom =\n      (((μIso _ _).symm ≪≫ (εIso.symm ⊗ .refl _)) ≪≫ λ_ (F.obj X)).hom := by\n    aesop_cat\n  rightUnitor_eq : ∀ X : D,\n    F.map (ρ_ X).hom =\n      (((μIso _ _).symm ≪≫ (.refl _ ⊗ εIso.symm)) ≪≫ ρ_ (F.obj X)).hom := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.Monoidal.InducingFunctorData.rightUnitor_eq","module":"Mathlib.CategoryTheory.Monoidal.Transport","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\ninst✝² : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\ninst✝ : CategoryTheory.MonoidalCategoryStruct D\nF : CategoryTheory.Functor D C\nself : CategoryTheory.Monoidal.InducingFunctorData F\nX : D\n⊢ Eq (F.map (CategoryTheory.MonoidalCategoryStruct.rightUnitor X).hom) (((self.μIso X CategoryTheory.MonoidalCategoryStruct.tensorUnit).symm.trans (CategoryTheory.MonoidalCategory.tensorIso (CategoryTheory.Iso.refl (F.obj X)) self.εIso.symm)).trans (CategoryTheory.MonoidalCategoryStruct.rightUnitor (F.obj X))).hom","decl":"/-- The data needed to induce a `MonoidalCategory` via the functor `F`; namely, pre-existing\ndefinitions of `⊗`, `𝟙_`, `▷`, `◁` that are preserved by `F`.\n-/\nstructure InducingFunctorData [MonoidalCategoryStruct D] (F : D ⥤ C) where\n  /-- Analogous to `CategoryTheory.LaxMonoidalFunctor.μIso` -/\n  μIso : ∀ X Y,\n    F.obj X ⊗ F.obj Y ≅ F.obj (X ⊗ Y)\n  whiskerLeft_eq : ∀ (X : D) {Y₁ Y₂ : D} (f : Y₁ ⟶ Y₂),\n    F.map (X ◁ f) = (μIso _ _).inv ≫ (F.obj X ◁ F.map f) ≫ (μIso _ _).hom := by\n    aesop_cat\n  whiskerRight_eq : ∀ {X₁ X₂ : D} (f : X₁ ⟶ X₂) (Y : D),\n    F.map (f ▷ Y) = (μIso _ _).inv ≫ (F.map f ▷ F.obj Y) ≫ (μIso _ _).hom := by\n    aesop_cat\n  tensorHom_eq : ∀ {X₁ Y₁ X₂ Y₂ : D} (f : X₁ ⟶ Y₁) (g : X₂ ⟶ Y₂),\n    F.map (f ⊗ g) = (μIso _ _).inv ≫ (F.map f ⊗ F.map g) ≫ (μIso _ _).hom := by\n    aesop_cat\n  /-- Analogous to `CategoryTheory.LaxMonoidalFunctor.εIso` -/\n  εIso : 𝟙_ _ ≅ F.obj (𝟙_ _)\n  associator_eq : ∀ X Y Z : D,\n    F.map (α_ X Y Z).hom =\n      (((μIso _ _).symm ≪≫ ((μIso _ _).symm ⊗ .refl _))\n        ≪≫ α_ (F.obj X) (F.obj Y) (F.obj Z)\n        ≪≫ ((.refl _ ⊗ μIso _ _) ≪≫ μIso _ _)).hom := by\n    aesop_cat\n  leftUnitor_eq : ∀ X : D,\n    F.map (λ_ X).hom =\n      (((μIso _ _).symm ≪≫ (εIso.symm ⊗ .refl _)) ≪≫ λ_ (F.obj X)).hom := by\n    aesop_cat\n  rightUnitor_eq : ∀ X : D,\n    F.map (ρ_ X).hom =\n      (((μIso _ _).symm ≪≫ (.refl _ ⊗ εIso.symm)) ≪≫ ρ_ (F.obj X)).hom := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.Monoidal.InducingFunctorData.associator_eq","module":"Mathlib.CategoryTheory.Monoidal.Transport","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\ninst✝² : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\ninst✝ : CategoryTheory.MonoidalCategoryStruct D\nF : CategoryTheory.Functor D C\nself : CategoryTheory.Monoidal.InducingFunctorData F\nX Y Z : D\n⊢ Eq (F.map (CategoryTheory.MonoidalCategoryStruct.associator X Y Z).hom) (((self.μIso (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y) Z).symm.trans (CategoryTheory.MonoidalCategory.tensorIso (self.μIso X Y).symm (CategoryTheory.Iso.refl (F.obj Z)))).trans ((CategoryTheory.MonoidalCategoryStruct.associator (F.obj X) (F.obj Y) (F.obj Z)).trans ((CategoryTheory.MonoidalCategory.tensorIso (CategoryTheory.Iso.refl (F.obj X)) (self.μIso Y Z)).trans (self.μIso X (CategoryTheory.MonoidalCategoryStruct.tensorObj Y Z))))).hom","decl":"/-- The data needed to induce a `MonoidalCategory` via the functor `F`; namely, pre-existing\ndefinitions of `⊗`, `𝟙_`, `▷`, `◁` that are preserved by `F`.\n-/\nstructure InducingFunctorData [MonoidalCategoryStruct D] (F : D ⥤ C) where\n  /-- Analogous to `CategoryTheory.LaxMonoidalFunctor.μIso` -/\n  μIso : ∀ X Y,\n    F.obj X ⊗ F.obj Y ≅ F.obj (X ⊗ Y)\n  whiskerLeft_eq : ∀ (X : D) {Y₁ Y₂ : D} (f : Y₁ ⟶ Y₂),\n    F.map (X ◁ f) = (μIso _ _).inv ≫ (F.obj X ◁ F.map f) ≫ (μIso _ _).hom := by\n    aesop_cat\n  whiskerRight_eq : ∀ {X₁ X₂ : D} (f : X₁ ⟶ X₂) (Y : D),\n    F.map (f ▷ Y) = (μIso _ _).inv ≫ (F.map f ▷ F.obj Y) ≫ (μIso _ _).hom := by\n    aesop_cat\n  tensorHom_eq : ∀ {X₁ Y₁ X₂ Y₂ : D} (f : X₁ ⟶ Y₁) (g : X₂ ⟶ Y₂),\n    F.map (f ⊗ g) = (μIso _ _).inv ≫ (F.map f ⊗ F.map g) ≫ (μIso _ _).hom := by\n    aesop_cat\n  /-- Analogous to `CategoryTheory.LaxMonoidalFunctor.εIso` -/\n  εIso : 𝟙_ _ ≅ F.obj (𝟙_ _)\n  associator_eq : ∀ X Y Z : D,\n    F.map (α_ X Y Z).hom =\n      (((μIso _ _).symm ≪≫ ((μIso _ _).symm ⊗ .refl _))\n        ≪≫ α_ (F.obj X) (F.obj Y) (F.obj Z)\n        ≪≫ ((.refl _ ⊗ μIso _ _) ≪≫ μIso _ _)).hom := by\n    aesop_cat\n  leftUnitor_eq : ∀ X : D,\n    F.map (λ_ X).hom =\n      (((μIso _ _).symm ≪≫ (εIso.symm ⊗ .refl _)) ≪≫ λ_ (F.obj X)).hom := by\n    aesop_cat\n  rightUnitor_eq : ∀ X : D,\n    F.map (ρ_ X).hom =\n      (((μIso _ _).symm ≪≫ (.refl _ ⊗ εIso.symm)) ≪≫ ρ_ (F.obj X)).hom := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.Monoidal.InducingFunctorData.tensorHom_eq","module":"Mathlib.CategoryTheory.Monoidal.Transport","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\ninst✝² : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\ninst✝ : CategoryTheory.MonoidalCategoryStruct D\nF : CategoryTheory.Functor D C\nself : CategoryTheory.Monoidal.InducingFunctorData F\nX₁ Y₁ X₂ Y₂ : D\nf : Quiver.Hom X₁ Y₁\ng : Quiver.Hom X₂ Y₂\n⊢ Eq (F.map (CategoryTheory.MonoidalCategoryStruct.tensorHom f g)) (CategoryTheory.CategoryStruct.comp (self.μIso X₁ X₂).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom (F.map f) (F.map g)) (self.μIso Y₁ Y₂).hom))","decl":"/-- The data needed to induce a `MonoidalCategory` via the functor `F`; namely, pre-existing\ndefinitions of `⊗`, `𝟙_`, `▷`, `◁` that are preserved by `F`.\n-/\nstructure InducingFunctorData [MonoidalCategoryStruct D] (F : D ⥤ C) where\n  /-- Analogous to `CategoryTheory.LaxMonoidalFunctor.μIso` -/\n  μIso : ∀ X Y,\n    F.obj X ⊗ F.obj Y ≅ F.obj (X ⊗ Y)\n  whiskerLeft_eq : ∀ (X : D) {Y₁ Y₂ : D} (f : Y₁ ⟶ Y₂),\n    F.map (X ◁ f) = (μIso _ _).inv ≫ (F.obj X ◁ F.map f) ≫ (μIso _ _).hom := by\n    aesop_cat\n  whiskerRight_eq : ∀ {X₁ X₂ : D} (f : X₁ ⟶ X₂) (Y : D),\n    F.map (f ▷ Y) = (μIso _ _).inv ≫ (F.map f ▷ F.obj Y) ≫ (μIso _ _).hom := by\n    aesop_cat\n  tensorHom_eq : ∀ {X₁ Y₁ X₂ Y₂ : D} (f : X₁ ⟶ Y₁) (g : X₂ ⟶ Y₂),\n    F.map (f ⊗ g) = (μIso _ _).inv ≫ (F.map f ⊗ F.map g) ≫ (μIso _ _).hom := by\n    aesop_cat\n  /-- Analogous to `CategoryTheory.LaxMonoidalFunctor.εIso` -/\n  εIso : 𝟙_ _ ≅ F.obj (𝟙_ _)\n  associator_eq : ∀ X Y Z : D,\n    F.map (α_ X Y Z).hom =\n      (((μIso _ _).symm ≪≫ ((μIso _ _).symm ⊗ .refl _))\n        ≪≫ α_ (F.obj X) (F.obj Y) (F.obj Z)\n        ≪≫ ((.refl _ ⊗ μIso _ _) ≪≫ μIso _ _)).hom := by\n    aesop_cat\n  leftUnitor_eq : ∀ X : D,\n    F.map (λ_ X).hom =\n      (((μIso _ _).symm ≪≫ (εIso.symm ⊗ .refl _)) ≪≫ λ_ (F.obj X)).hom := by\n    aesop_cat\n  rightUnitor_eq : ∀ X : D,\n    F.map (ρ_ X).hom =\n      (((μIso _ _).symm ≪≫ (.refl _ ⊗ εIso.symm)) ≪≫ ρ_ (F.obj X)).hom := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.Monoidal.transportStruct_tensorObj","module":"Mathlib.CategoryTheory.Monoidal.Transport","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\ne : CategoryTheory.Equivalence C D\nX Y : D\n⊢ Eq (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y) (e.functor.obj (CategoryTheory.MonoidalCategoryStruct.tensorObj (e.inverse.obj X) (e.inverse.obj Y)))","decl":"/-- Transport a monoidal structure along an equivalence of (plain) categories.\n-/\n@[simps (config := .lemmasOnly)]\ndef transportStruct (e : C ≌ D) : MonoidalCategoryStruct.{v₂} D where\n  tensorObj X Y := e.functor.obj (e.inverse.obj X ⊗ e.inverse.obj Y)\n  whiskerLeft X _ _ f := e.functor.map (e.inverse.obj X ◁ e.inverse.map f)\n  whiskerRight f X := e.functor.map (e.inverse.map f ▷ e.inverse.obj X)\n  tensorHom f g := e.functor.map (e.inverse.map f ⊗ e.inverse.map g)\n  tensorUnit := e.functor.obj (𝟙_ C)\n  associator X Y Z :=\n    e.functor.mapIso\n      (whiskerRightIso (e.unitIso.app _).symm _ ≪≫\n        α_ (e.inverse.obj X) (e.inverse.obj Y) (e.inverse.obj Z) ≪≫\n        whiskerLeftIso _ (e.unitIso.app _))\n  leftUnitor X :=\n    e.functor.mapIso ((whiskerRightIso (e.unitIso.app _).symm _) ≪≫ λ_ (e.inverse.obj X)) ≪≫\n      e.counitIso.app _\n  rightUnitor X :=\n    e.functor.mapIso ((whiskerLeftIso _ (e.unitIso.app _).symm) ≪≫ ρ_ (e.inverse.obj X)) ≪≫\n      e.counitIso.app _\n\n"}
{"name":"CategoryTheory.Monoidal.transportStruct_rightUnitor","module":"Mathlib.CategoryTheory.Monoidal.Transport","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\ne : CategoryTheory.Equivalence C D\nX : D\n⊢ Eq (CategoryTheory.MonoidalCategoryStruct.rightUnitor X) ((e.functor.mapIso ((CategoryTheory.MonoidalCategory.whiskerLeftIso (e.inverse.obj X) (e.unitIso.app CategoryTheory.MonoidalCategoryStruct.tensorUnit).symm).trans (CategoryTheory.MonoidalCategoryStruct.rightUnitor (e.inverse.obj X)))).trans (e.counitIso.app X))","decl":"/-- Transport a monoidal structure along an equivalence of (plain) categories.\n-/\n@[simps (config := .lemmasOnly)]\ndef transportStruct (e : C ≌ D) : MonoidalCategoryStruct.{v₂} D where\n  tensorObj X Y := e.functor.obj (e.inverse.obj X ⊗ e.inverse.obj Y)\n  whiskerLeft X _ _ f := e.functor.map (e.inverse.obj X ◁ e.inverse.map f)\n  whiskerRight f X := e.functor.map (e.inverse.map f ▷ e.inverse.obj X)\n  tensorHom f g := e.functor.map (e.inverse.map f ⊗ e.inverse.map g)\n  tensorUnit := e.functor.obj (𝟙_ C)\n  associator X Y Z :=\n    e.functor.mapIso\n      (whiskerRightIso (e.unitIso.app _).symm _ ≪≫\n        α_ (e.inverse.obj X) (e.inverse.obj Y) (e.inverse.obj Z) ≪≫\n        whiskerLeftIso _ (e.unitIso.app _))\n  leftUnitor X :=\n    e.functor.mapIso ((whiskerRightIso (e.unitIso.app _).symm _) ≪≫ λ_ (e.inverse.obj X)) ≪≫\n      e.counitIso.app _\n  rightUnitor X :=\n    e.functor.mapIso ((whiskerLeftIso _ (e.unitIso.app _).symm) ≪≫ ρ_ (e.inverse.obj X)) ≪≫\n      e.counitIso.app _\n\n"}
{"name":"CategoryTheory.Monoidal.transportStruct_whiskerLeft","module":"Mathlib.CategoryTheory.Monoidal.Transport","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\ne : CategoryTheory.Equivalence C D\nX x✝¹ x✝ : D\nf : Quiver.Hom x✝¹ x✝\n⊢ Eq (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X f) (e.functor.map (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (e.inverse.obj X) (e.inverse.map f)))","decl":"/-- Transport a monoidal structure along an equivalence of (plain) categories.\n-/\n@[simps (config := .lemmasOnly)]\ndef transportStruct (e : C ≌ D) : MonoidalCategoryStruct.{v₂} D where\n  tensorObj X Y := e.functor.obj (e.inverse.obj X ⊗ e.inverse.obj Y)\n  whiskerLeft X _ _ f := e.functor.map (e.inverse.obj X ◁ e.inverse.map f)\n  whiskerRight f X := e.functor.map (e.inverse.map f ▷ e.inverse.obj X)\n  tensorHom f g := e.functor.map (e.inverse.map f ⊗ e.inverse.map g)\n  tensorUnit := e.functor.obj (𝟙_ C)\n  associator X Y Z :=\n    e.functor.mapIso\n      (whiskerRightIso (e.unitIso.app _).symm _ ≪≫\n        α_ (e.inverse.obj X) (e.inverse.obj Y) (e.inverse.obj Z) ≪≫\n        whiskerLeftIso _ (e.unitIso.app _))\n  leftUnitor X :=\n    e.functor.mapIso ((whiskerRightIso (e.unitIso.app _).symm _) ≪≫ λ_ (e.inverse.obj X)) ≪≫\n      e.counitIso.app _\n  rightUnitor X :=\n    e.functor.mapIso ((whiskerLeftIso _ (e.unitIso.app _).symm) ≪≫ ρ_ (e.inverse.obj X)) ≪≫\n      e.counitIso.app _\n\n"}
{"name":"CategoryTheory.Monoidal.transportStruct_tensorUnit","module":"Mathlib.CategoryTheory.Monoidal.Transport","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\ne : CategoryTheory.Equivalence C D\n⊢ Eq CategoryTheory.MonoidalCategoryStruct.tensorUnit (e.functor.obj CategoryTheory.MonoidalCategoryStruct.tensorUnit)","decl":"/-- Transport a monoidal structure along an equivalence of (plain) categories.\n-/\n@[simps (config := .lemmasOnly)]\ndef transportStruct (e : C ≌ D) : MonoidalCategoryStruct.{v₂} D where\n  tensorObj X Y := e.functor.obj (e.inverse.obj X ⊗ e.inverse.obj Y)\n  whiskerLeft X _ _ f := e.functor.map (e.inverse.obj X ◁ e.inverse.map f)\n  whiskerRight f X := e.functor.map (e.inverse.map f ▷ e.inverse.obj X)\n  tensorHom f g := e.functor.map (e.inverse.map f ⊗ e.inverse.map g)\n  tensorUnit := e.functor.obj (𝟙_ C)\n  associator X Y Z :=\n    e.functor.mapIso\n      (whiskerRightIso (e.unitIso.app _).symm _ ≪≫\n        α_ (e.inverse.obj X) (e.inverse.obj Y) (e.inverse.obj Z) ≪≫\n        whiskerLeftIso _ (e.unitIso.app _))\n  leftUnitor X :=\n    e.functor.mapIso ((whiskerRightIso (e.unitIso.app _).symm _) ≪≫ λ_ (e.inverse.obj X)) ≪≫\n      e.counitIso.app _\n  rightUnitor X :=\n    e.functor.mapIso ((whiskerLeftIso _ (e.unitIso.app _).symm) ≪≫ ρ_ (e.inverse.obj X)) ≪≫\n      e.counitIso.app _\n\n"}
{"name":"CategoryTheory.Monoidal.transportStruct_leftUnitor","module":"Mathlib.CategoryTheory.Monoidal.Transport","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\ne : CategoryTheory.Equivalence C D\nX : D\n⊢ Eq (CategoryTheory.MonoidalCategoryStruct.leftUnitor X) ((e.functor.mapIso ((CategoryTheory.MonoidalCategory.whiskerRightIso (e.unitIso.app CategoryTheory.MonoidalCategoryStruct.tensorUnit).symm (e.inverse.obj X)).trans (CategoryTheory.MonoidalCategoryStruct.leftUnitor (e.inverse.obj X)))).trans (e.counitIso.app X))","decl":"/-- Transport a monoidal structure along an equivalence of (plain) categories.\n-/\n@[simps (config := .lemmasOnly)]\ndef transportStruct (e : C ≌ D) : MonoidalCategoryStruct.{v₂} D where\n  tensorObj X Y := e.functor.obj (e.inverse.obj X ⊗ e.inverse.obj Y)\n  whiskerLeft X _ _ f := e.functor.map (e.inverse.obj X ◁ e.inverse.map f)\n  whiskerRight f X := e.functor.map (e.inverse.map f ▷ e.inverse.obj X)\n  tensorHom f g := e.functor.map (e.inverse.map f ⊗ e.inverse.map g)\n  tensorUnit := e.functor.obj (𝟙_ C)\n  associator X Y Z :=\n    e.functor.mapIso\n      (whiskerRightIso (e.unitIso.app _).symm _ ≪≫\n        α_ (e.inverse.obj X) (e.inverse.obj Y) (e.inverse.obj Z) ≪≫\n        whiskerLeftIso _ (e.unitIso.app _))\n  leftUnitor X :=\n    e.functor.mapIso ((whiskerRightIso (e.unitIso.app _).symm _) ≪≫ λ_ (e.inverse.obj X)) ≪≫\n      e.counitIso.app _\n  rightUnitor X :=\n    e.functor.mapIso ((whiskerLeftIso _ (e.unitIso.app _).symm) ≪≫ ρ_ (e.inverse.obj X)) ≪≫\n      e.counitIso.app _\n\n"}
{"name":"CategoryTheory.Monoidal.transportStruct_whiskerRight","module":"Mathlib.CategoryTheory.Monoidal.Transport","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\ne : CategoryTheory.Equivalence C D\nX₁✝ X₂✝ : D\nf : Quiver.Hom X₁✝ X₂✝\nX : D\n⊢ Eq (CategoryTheory.MonoidalCategoryStruct.whiskerRight f X) (e.functor.map (CategoryTheory.MonoidalCategoryStruct.whiskerRight (e.inverse.map f) (e.inverse.obj X)))","decl":"/-- Transport a monoidal structure along an equivalence of (plain) categories.\n-/\n@[simps (config := .lemmasOnly)]\ndef transportStruct (e : C ≌ D) : MonoidalCategoryStruct.{v₂} D where\n  tensorObj X Y := e.functor.obj (e.inverse.obj X ⊗ e.inverse.obj Y)\n  whiskerLeft X _ _ f := e.functor.map (e.inverse.obj X ◁ e.inverse.map f)\n  whiskerRight f X := e.functor.map (e.inverse.map f ▷ e.inverse.obj X)\n  tensorHom f g := e.functor.map (e.inverse.map f ⊗ e.inverse.map g)\n  tensorUnit := e.functor.obj (𝟙_ C)\n  associator X Y Z :=\n    e.functor.mapIso\n      (whiskerRightIso (e.unitIso.app _).symm _ ≪≫\n        α_ (e.inverse.obj X) (e.inverse.obj Y) (e.inverse.obj Z) ≪≫\n        whiskerLeftIso _ (e.unitIso.app _))\n  leftUnitor X :=\n    e.functor.mapIso ((whiskerRightIso (e.unitIso.app _).symm _) ≪≫ λ_ (e.inverse.obj X)) ≪≫\n      e.counitIso.app _\n  rightUnitor X :=\n    e.functor.mapIso ((whiskerLeftIso _ (e.unitIso.app _).symm) ≪≫ ρ_ (e.inverse.obj X)) ≪≫\n      e.counitIso.app _\n\n"}
{"name":"CategoryTheory.Monoidal.transportStruct_associator","module":"Mathlib.CategoryTheory.Monoidal.Transport","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\ne : CategoryTheory.Equivalence C D\nX Y Z : D\n⊢ Eq (CategoryTheory.MonoidalCategoryStruct.associator X Y Z) (e.functor.mapIso ((CategoryTheory.MonoidalCategory.whiskerRightIso (e.unitIso.app (CategoryTheory.MonoidalCategoryStruct.tensorObj (e.inverse.obj X) (e.inverse.obj Y))).symm (e.inverse.obj Z)).trans ((CategoryTheory.MonoidalCategoryStruct.associator (e.inverse.obj X) (e.inverse.obj Y) (e.inverse.obj Z)).trans (CategoryTheory.MonoidalCategory.whiskerLeftIso (e.inverse.obj X) (e.unitIso.app (CategoryTheory.MonoidalCategoryStruct.tensorObj (e.inverse.obj Y) (e.inverse.obj Z)))))))","decl":"/-- Transport a monoidal structure along an equivalence of (plain) categories.\n-/\n@[simps (config := .lemmasOnly)]\ndef transportStruct (e : C ≌ D) : MonoidalCategoryStruct.{v₂} D where\n  tensorObj X Y := e.functor.obj (e.inverse.obj X ⊗ e.inverse.obj Y)\n  whiskerLeft X _ _ f := e.functor.map (e.inverse.obj X ◁ e.inverse.map f)\n  whiskerRight f X := e.functor.map (e.inverse.map f ▷ e.inverse.obj X)\n  tensorHom f g := e.functor.map (e.inverse.map f ⊗ e.inverse.map g)\n  tensorUnit := e.functor.obj (𝟙_ C)\n  associator X Y Z :=\n    e.functor.mapIso\n      (whiskerRightIso (e.unitIso.app _).symm _ ≪≫\n        α_ (e.inverse.obj X) (e.inverse.obj Y) (e.inverse.obj Z) ≪≫\n        whiskerLeftIso _ (e.unitIso.app _))\n  leftUnitor X :=\n    e.functor.mapIso ((whiskerRightIso (e.unitIso.app _).symm _) ≪≫ λ_ (e.inverse.obj X)) ≪≫\n      e.counitIso.app _\n  rightUnitor X :=\n    e.functor.mapIso ((whiskerLeftIso _ (e.unitIso.app _).symm) ≪≫ ρ_ (e.inverse.obj X)) ≪≫\n      e.counitIso.app _\n\n"}
{"name":"CategoryTheory.Monoidal.transportStruct_tensorHom","module":"Mathlib.CategoryTheory.Monoidal.Transport","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\ne : CategoryTheory.Equivalence C D\nX₁✝ Y₁✝ X₂✝ Y₂✝ : D\nf : Quiver.Hom X₁✝ Y₁✝\ng : Quiver.Hom X₂✝ Y₂✝\n⊢ Eq (CategoryTheory.MonoidalCategoryStruct.tensorHom f g) (e.functor.map (CategoryTheory.MonoidalCategoryStruct.tensorHom (e.inverse.map f) (e.inverse.map g)))","decl":"/-- Transport a monoidal structure along an equivalence of (plain) categories.\n-/\n@[simps (config := .lemmasOnly)]\ndef transportStruct (e : C ≌ D) : MonoidalCategoryStruct.{v₂} D where\n  tensorObj X Y := e.functor.obj (e.inverse.obj X ⊗ e.inverse.obj Y)\n  whiskerLeft X _ _ f := e.functor.map (e.inverse.obj X ◁ e.inverse.map f)\n  whiskerRight f X := e.functor.map (e.inverse.map f ▷ e.inverse.obj X)\n  tensorHom f g := e.functor.map (e.inverse.map f ⊗ e.inverse.map g)\n  tensorUnit := e.functor.obj (𝟙_ C)\n  associator X Y Z :=\n    e.functor.mapIso\n      (whiskerRightIso (e.unitIso.app _).symm _ ≪≫\n        α_ (e.inverse.obj X) (e.inverse.obj Y) (e.inverse.obj Z) ≪≫\n        whiskerLeftIso _ (e.unitIso.app _))\n  leftUnitor X :=\n    e.functor.mapIso ((whiskerRightIso (e.unitIso.app _).symm _) ≪≫ λ_ (e.inverse.obj X)) ≪≫\n      e.counitIso.app _\n  rightUnitor X :=\n    e.functor.mapIso ((whiskerLeftIso _ (e.unitIso.app _).symm) ≪≫ ρ_ (e.inverse.obj X)) ≪≫\n      e.counitIso.app _\n\n"}
{"name":"CategoryTheory.Monoidal.instIsMonoidalTransportedSymmEquivalenceTransported","module":"Mathlib.CategoryTheory.Monoidal.Transport","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\ne : CategoryTheory.Equivalence C D\n⊢ (CategoryTheory.Monoidal.equivalenceTransported e).symm.IsMonoidal","decl":"instance : (equivalenceTransported e).symm.IsMonoidal := by\n  infer_instance\n\n"}
{"name":"CategoryTheory.Monoidal.instIsMonoidalUnitTransportedEquivalenceTransported","module":"Mathlib.CategoryTheory.Monoidal.Transport","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\ne : CategoryTheory.Equivalence C D\n⊢ CategoryTheory.NatTrans.IsMonoidal (CategoryTheory.Monoidal.equivalenceTransported e).unit","decl":"/-- The unit isomorphism upgrades to a monoidal isomorphism. -/\ninstance : NatTrans.IsMonoidal (equivalenceTransported e).unit :=\n  inferInstanceAs (NatTrans.IsMonoidal (equivalenceTransported e).symm.counitIso.inv)\n\n"}
{"name":"CategoryTheory.Monoidal.instIsMonoidalTransportedCounitEquivalenceTransported","module":"Mathlib.CategoryTheory.Monoidal.Transport","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\ne : CategoryTheory.Equivalence C D\n⊢ CategoryTheory.NatTrans.IsMonoidal (CategoryTheory.Monoidal.equivalenceTransported e).counit","decl":"/-- The counit isomorphism upgrades to a monoidal isomorphism. -/\ninstance : NatTrans.IsMonoidal (equivalenceTransported e).counit :=\n  inferInstanceAs (NatTrans.IsMonoidal (equivalenceTransported e).symm.unitIso.inv)\n\n"}
