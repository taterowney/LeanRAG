{"name":"CategoryTheory.Monoidal.InducingFunctorData.whiskerLeft_eq","module":"Mathlib.CategoryTheory.Monoidal.Transport","initialProofState":"C : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ² : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœ : CategoryTheory.MonoidalCategoryStruct D\nF : CategoryTheory.Functor D C\nself : CategoryTheory.Monoidal.InducingFunctorData F\nX Yâ‚ Yâ‚‚ : D\nf : Quiver.Hom Yâ‚ Yâ‚‚\nâŠ¢ Eq (F.map (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X f)) (CategoryTheory.CategoryStruct.comp (self.Î¼Iso X Yâ‚).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (F.obj X) (F.map f)) (self.Î¼Iso X Yâ‚‚).hom))","decl":"/-- The data needed to induce a `MonoidalCategory` via the functor `F`; namely, pre-existing\ndefinitions of `âŠ—`, `ğŸ™_`, `â–·`, `â—` that are preserved by `F`.\n-/\nstructure InducingFunctorData [MonoidalCategoryStruct D] (F : D â¥¤ C) where\n  /-- Analogous to `CategoryTheory.LaxMonoidalFunctor.Î¼Iso` -/\n  Î¼Iso : âˆ€ X Y,\n    F.obj X âŠ— F.obj Y â‰… F.obj (X âŠ— Y)\n  whiskerLeft_eq : âˆ€ (X : D) {Yâ‚ Yâ‚‚ : D} (f : Yâ‚ âŸ¶ Yâ‚‚),\n    F.map (X â— f) = (Î¼Iso _ _).inv â‰« (F.obj X â— F.map f) â‰« (Î¼Iso _ _).hom := by\n    aesop_cat\n  whiskerRight_eq : âˆ€ {Xâ‚ Xâ‚‚ : D} (f : Xâ‚ âŸ¶ Xâ‚‚) (Y : D),\n    F.map (f â–· Y) = (Î¼Iso _ _).inv â‰« (F.map f â–· F.obj Y) â‰« (Î¼Iso _ _).hom := by\n    aesop_cat\n  tensorHom_eq : âˆ€ {Xâ‚ Yâ‚ Xâ‚‚ Yâ‚‚ : D} (f : Xâ‚ âŸ¶ Yâ‚) (g : Xâ‚‚ âŸ¶ Yâ‚‚),\n    F.map (f âŠ— g) = (Î¼Iso _ _).inv â‰« (F.map f âŠ— F.map g) â‰« (Î¼Iso _ _).hom := by\n    aesop_cat\n  /-- Analogous to `CategoryTheory.LaxMonoidalFunctor.ÎµIso` -/\n  ÎµIso : ğŸ™_ _ â‰… F.obj (ğŸ™_ _)\n  associator_eq : âˆ€ X Y Z : D,\n    F.map (Î±_ X Y Z).hom =\n      (((Î¼Iso _ _).symm â‰ªâ‰« ((Î¼Iso _ _).symm âŠ— .refl _))\n        â‰ªâ‰« Î±_ (F.obj X) (F.obj Y) (F.obj Z)\n        â‰ªâ‰« ((.refl _ âŠ— Î¼Iso _ _) â‰ªâ‰« Î¼Iso _ _)).hom := by\n    aesop_cat\n  leftUnitor_eq : âˆ€ X : D,\n    F.map (Î»_ X).hom =\n      (((Î¼Iso _ _).symm â‰ªâ‰« (ÎµIso.symm âŠ— .refl _)) â‰ªâ‰« Î»_ (F.obj X)).hom := by\n    aesop_cat\n  rightUnitor_eq : âˆ€ X : D,\n    F.map (Ï_ X).hom =\n      (((Î¼Iso _ _).symm â‰ªâ‰« (.refl _ âŠ— ÎµIso.symm)) â‰ªâ‰« Ï_ (F.obj X)).hom := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.Monoidal.InducingFunctorData.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Monoidal.Transport","initialProofState":"C : Type uâ‚\ninstâœâµ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœâ´ : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœÂ² : CategoryTheory.MonoidalCategoryStruct D\nF : CategoryTheory.Functor D C\ninstâœÂ¹ : SizeOf C\ninstâœ : SizeOf D\nÎ¼Iso : (X Y : D) â†’ CategoryTheory.Iso (CategoryTheory.MonoidalCategoryStruct.tensorObj (F.obj X) (F.obj Y)) (F.obj (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y))\nwhiskerLeft_eq : autoParam (âˆ€ (X : D) {Yâ‚ Yâ‚‚ : D} (f : Quiver.Hom Yâ‚ Yâ‚‚), Eq (F.map (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X f)) (CategoryTheory.CategoryStruct.comp (Î¼Iso X Yâ‚).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (F.obj X) (F.map f)) (Î¼Iso X Yâ‚‚).hom))) _autoâœ\nwhiskerRight_eq : autoParam (âˆ€ {Xâ‚ Xâ‚‚ : D} (f : Quiver.Hom Xâ‚ Xâ‚‚) (Y : D), Eq (F.map (CategoryTheory.MonoidalCategoryStruct.whiskerRight f Y)) (CategoryTheory.CategoryStruct.comp (Î¼Iso Xâ‚ Y).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (F.map f) (F.obj Y)) (Î¼Iso Xâ‚‚ Y).hom))) _autoâœ\ntensorHom_eq : autoParam (âˆ€ {Xâ‚ Yâ‚ Xâ‚‚ Yâ‚‚ : D} (f : Quiver.Hom Xâ‚ Yâ‚) (g : Quiver.Hom Xâ‚‚ Yâ‚‚), Eq (F.map (CategoryTheory.MonoidalCategoryStruct.tensorHom f g)) (CategoryTheory.CategoryStruct.comp (Î¼Iso Xâ‚ Xâ‚‚).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom (F.map f) (F.map g)) (Î¼Iso Yâ‚ Yâ‚‚).hom))) _autoâœ\nÎµIso : CategoryTheory.Iso CategoryTheory.MonoidalCategoryStruct.tensorUnit (F.obj CategoryTheory.MonoidalCategoryStruct.tensorUnit)\nassociator_eq : autoParam (âˆ€ (X Y Z : D), Eq (F.map (CategoryTheory.MonoidalCategoryStruct.associator X Y Z).hom) (((Î¼Iso (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y) Z).symm.trans (CategoryTheory.MonoidalCategory.tensorIso (Î¼Iso X Y).symm (CategoryTheory.Iso.refl (F.obj Z)))).trans ((CategoryTheory.MonoidalCategoryStruct.associator (F.obj X) (F.obj Y) (F.obj Z)).trans ((CategoryTheory.MonoidalCategory.tensorIso (CategoryTheory.Iso.refl (F.obj X)) (Î¼Iso Y Z)).trans (Î¼Iso X (CategoryTheory.MonoidalCategoryStruct.tensorObj Y Z))))).hom) _autoâœ\nleftUnitor_eq : autoParam (âˆ€ (X : D), Eq (F.map (CategoryTheory.MonoidalCategoryStruct.leftUnitor X).hom) (((Î¼Iso CategoryTheory.MonoidalCategoryStruct.tensorUnit X).symm.trans (CategoryTheory.MonoidalCategory.tensorIso ÎµIso.symm (CategoryTheory.Iso.refl (F.obj X)))).trans (CategoryTheory.MonoidalCategoryStruct.leftUnitor (F.obj X))).hom) _autoâœ\nrightUnitor_eq : autoParam (âˆ€ (X : D), Eq (F.map (CategoryTheory.MonoidalCategoryStruct.rightUnitor X).hom) (((Î¼Iso X CategoryTheory.MonoidalCategoryStruct.tensorUnit).symm.trans (CategoryTheory.MonoidalCategory.tensorIso (CategoryTheory.Iso.refl (F.obj X)) ÎµIso.symm)).trans (CategoryTheory.MonoidalCategoryStruct.rightUnitor (F.obj X))).hom) _autoâœ\nâŠ¢ Eq (SizeOf.sizeOf { Î¼Iso := Î¼Iso, whiskerLeft_eq := whiskerLeft_eq, whiskerRight_eq := whiskerRight_eq, tensorHom_eq := tensorHom_eq, ÎµIso := ÎµIso, associator_eq := associator_eq, leftUnitor_eq := leftUnitor_eq, rightUnitor_eq := rightUnitor_eq }) (HAdd.hAdd 1 (SizeOf.sizeOf ÎµIso))","decl":"/-- The data needed to induce a `MonoidalCategory` via the functor `F`; namely, pre-existing\ndefinitions of `âŠ—`, `ğŸ™_`, `â–·`, `â—` that are preserved by `F`.\n-/\nstructure InducingFunctorData [MonoidalCategoryStruct D] (F : D â¥¤ C) where\n  /-- Analogous to `CategoryTheory.LaxMonoidalFunctor.Î¼Iso` -/\n  Î¼Iso : âˆ€ X Y,\n    F.obj X âŠ— F.obj Y â‰… F.obj (X âŠ— Y)\n  whiskerLeft_eq : âˆ€ (X : D) {Yâ‚ Yâ‚‚ : D} (f : Yâ‚ âŸ¶ Yâ‚‚),\n    F.map (X â— f) = (Î¼Iso _ _).inv â‰« (F.obj X â— F.map f) â‰« (Î¼Iso _ _).hom := by\n    aesop_cat\n  whiskerRight_eq : âˆ€ {Xâ‚ Xâ‚‚ : D} (f : Xâ‚ âŸ¶ Xâ‚‚) (Y : D),\n    F.map (f â–· Y) = (Î¼Iso _ _).inv â‰« (F.map f â–· F.obj Y) â‰« (Î¼Iso _ _).hom := by\n    aesop_cat\n  tensorHom_eq : âˆ€ {Xâ‚ Yâ‚ Xâ‚‚ Yâ‚‚ : D} (f : Xâ‚ âŸ¶ Yâ‚) (g : Xâ‚‚ âŸ¶ Yâ‚‚),\n    F.map (f âŠ— g) = (Î¼Iso _ _).inv â‰« (F.map f âŠ— F.map g) â‰« (Î¼Iso _ _).hom := by\n    aesop_cat\n  /-- Analogous to `CategoryTheory.LaxMonoidalFunctor.ÎµIso` -/\n  ÎµIso : ğŸ™_ _ â‰… F.obj (ğŸ™_ _)\n  associator_eq : âˆ€ X Y Z : D,\n    F.map (Î±_ X Y Z).hom =\n      (((Î¼Iso _ _).symm â‰ªâ‰« ((Î¼Iso _ _).symm âŠ— .refl _))\n        â‰ªâ‰« Î±_ (F.obj X) (F.obj Y) (F.obj Z)\n        â‰ªâ‰« ((.refl _ âŠ— Î¼Iso _ _) â‰ªâ‰« Î¼Iso _ _)).hom := by\n    aesop_cat\n  leftUnitor_eq : âˆ€ X : D,\n    F.map (Î»_ X).hom =\n      (((Î¼Iso _ _).symm â‰ªâ‰« (ÎµIso.symm âŠ— .refl _)) â‰ªâ‰« Î»_ (F.obj X)).hom := by\n    aesop_cat\n  rightUnitor_eq : âˆ€ X : D,\n    F.map (Ï_ X).hom =\n      (((Î¼Iso _ _).symm â‰ªâ‰« (.refl _ âŠ— ÎµIso.symm)) â‰ªâ‰« Ï_ (F.obj X)).hom := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.Monoidal.InducingFunctorData.whiskerRight_eq","module":"Mathlib.CategoryTheory.Monoidal.Transport","initialProofState":"C : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ² : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœ : CategoryTheory.MonoidalCategoryStruct D\nF : CategoryTheory.Functor D C\nself : CategoryTheory.Monoidal.InducingFunctorData F\nXâ‚ Xâ‚‚ : D\nf : Quiver.Hom Xâ‚ Xâ‚‚\nY : D\nâŠ¢ Eq (F.map (CategoryTheory.MonoidalCategoryStruct.whiskerRight f Y)) (CategoryTheory.CategoryStruct.comp (self.Î¼Iso Xâ‚ Y).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (F.map f) (F.obj Y)) (self.Î¼Iso Xâ‚‚ Y).hom))","decl":"/-- The data needed to induce a `MonoidalCategory` via the functor `F`; namely, pre-existing\ndefinitions of `âŠ—`, `ğŸ™_`, `â–·`, `â—` that are preserved by `F`.\n-/\nstructure InducingFunctorData [MonoidalCategoryStruct D] (F : D â¥¤ C) where\n  /-- Analogous to `CategoryTheory.LaxMonoidalFunctor.Î¼Iso` -/\n  Î¼Iso : âˆ€ X Y,\n    F.obj X âŠ— F.obj Y â‰… F.obj (X âŠ— Y)\n  whiskerLeft_eq : âˆ€ (X : D) {Yâ‚ Yâ‚‚ : D} (f : Yâ‚ âŸ¶ Yâ‚‚),\n    F.map (X â— f) = (Î¼Iso _ _).inv â‰« (F.obj X â— F.map f) â‰« (Î¼Iso _ _).hom := by\n    aesop_cat\n  whiskerRight_eq : âˆ€ {Xâ‚ Xâ‚‚ : D} (f : Xâ‚ âŸ¶ Xâ‚‚) (Y : D),\n    F.map (f â–· Y) = (Î¼Iso _ _).inv â‰« (F.map f â–· F.obj Y) â‰« (Î¼Iso _ _).hom := by\n    aesop_cat\n  tensorHom_eq : âˆ€ {Xâ‚ Yâ‚ Xâ‚‚ Yâ‚‚ : D} (f : Xâ‚ âŸ¶ Yâ‚) (g : Xâ‚‚ âŸ¶ Yâ‚‚),\n    F.map (f âŠ— g) = (Î¼Iso _ _).inv â‰« (F.map f âŠ— F.map g) â‰« (Î¼Iso _ _).hom := by\n    aesop_cat\n  /-- Analogous to `CategoryTheory.LaxMonoidalFunctor.ÎµIso` -/\n  ÎµIso : ğŸ™_ _ â‰… F.obj (ğŸ™_ _)\n  associator_eq : âˆ€ X Y Z : D,\n    F.map (Î±_ X Y Z).hom =\n      (((Î¼Iso _ _).symm â‰ªâ‰« ((Î¼Iso _ _).symm âŠ— .refl _))\n        â‰ªâ‰« Î±_ (F.obj X) (F.obj Y) (F.obj Z)\n        â‰ªâ‰« ((.refl _ âŠ— Î¼Iso _ _) â‰ªâ‰« Î¼Iso _ _)).hom := by\n    aesop_cat\n  leftUnitor_eq : âˆ€ X : D,\n    F.map (Î»_ X).hom =\n      (((Î¼Iso _ _).symm â‰ªâ‰« (ÎµIso.symm âŠ— .refl _)) â‰ªâ‰« Î»_ (F.obj X)).hom := by\n    aesop_cat\n  rightUnitor_eq : âˆ€ X : D,\n    F.map (Ï_ X).hom =\n      (((Î¼Iso _ _).symm â‰ªâ‰« (.refl _ âŠ— ÎµIso.symm)) â‰ªâ‰« Ï_ (F.obj X)).hom := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.Monoidal.InducingFunctorData.mk.inj","module":"Mathlib.CategoryTheory.Monoidal.Transport","initialProofState":"C : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ² : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœ : CategoryTheory.MonoidalCategoryStruct D\nF : CategoryTheory.Functor D C\nÎ¼Isoâœ : (X Y : D) â†’ CategoryTheory.Iso (CategoryTheory.MonoidalCategoryStruct.tensorObj (F.obj X) (F.obj Y)) (F.obj (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y))\nwhiskerLeft_eqâœ : autoParam (âˆ€ (X : D) {Yâ‚ Yâ‚‚ : D} (f : Quiver.Hom Yâ‚ Yâ‚‚), Eq (F.map (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X f)) (CategoryTheory.CategoryStruct.comp (Î¼Isoâœ X Yâ‚).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (F.obj X) (F.map f)) (Î¼Isoâœ X Yâ‚‚).hom))) _autoâœ\nwhiskerRight_eqâœ : autoParam (âˆ€ {Xâ‚ Xâ‚‚ : D} (f : Quiver.Hom Xâ‚ Xâ‚‚) (Y : D), Eq (F.map (CategoryTheory.MonoidalCategoryStruct.whiskerRight f Y)) (CategoryTheory.CategoryStruct.comp (Î¼Isoâœ Xâ‚ Y).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (F.map f) (F.obj Y)) (Î¼Isoâœ Xâ‚‚ Y).hom))) _autoâœ\ntensorHom_eqâœ : autoParam (âˆ€ {Xâ‚ Yâ‚ Xâ‚‚ Yâ‚‚ : D} (f : Quiver.Hom Xâ‚ Yâ‚) (g : Quiver.Hom Xâ‚‚ Yâ‚‚), Eq (F.map (CategoryTheory.MonoidalCategoryStruct.tensorHom f g)) (CategoryTheory.CategoryStruct.comp (Î¼Isoâœ Xâ‚ Xâ‚‚).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom (F.map f) (F.map g)) (Î¼Isoâœ Yâ‚ Yâ‚‚).hom))) _autoâœ\nÎµIsoâœ : CategoryTheory.Iso CategoryTheory.MonoidalCategoryStruct.tensorUnit (F.obj CategoryTheory.MonoidalCategoryStruct.tensorUnit)\nassociator_eqâœ : autoParam (âˆ€ (X Y Z : D), Eq (F.map (CategoryTheory.MonoidalCategoryStruct.associator X Y Z).hom) (((Î¼Isoâœ (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y) Z).symm.trans (CategoryTheory.MonoidalCategory.tensorIso (Î¼Isoâœ X Y).symm (CategoryTheory.Iso.refl (F.obj Z)))).trans ((CategoryTheory.MonoidalCategoryStruct.associator (F.obj X) (F.obj Y) (F.obj Z)).trans ((CategoryTheory.MonoidalCategory.tensorIso (CategoryTheory.Iso.refl (F.obj X)) (Î¼Isoâœ Y Z)).trans (Î¼Isoâœ X (CategoryTheory.MonoidalCategoryStruct.tensorObj Y Z))))).hom) _autoâœ\nleftUnitor_eqâœ : autoParam (âˆ€ (X : D), Eq (F.map (CategoryTheory.MonoidalCategoryStruct.leftUnitor X).hom) (((Î¼Isoâœ CategoryTheory.MonoidalCategoryStruct.tensorUnit X).symm.trans (CategoryTheory.MonoidalCategory.tensorIso ÎµIsoâœ.symm (CategoryTheory.Iso.refl (F.obj X)))).trans (CategoryTheory.MonoidalCategoryStruct.leftUnitor (F.obj X))).hom) _autoâœ\nrightUnitor_eqâœ : autoParam (âˆ€ (X : D), Eq (F.map (CategoryTheory.MonoidalCategoryStruct.rightUnitor X).hom) (((Î¼Isoâœ X CategoryTheory.MonoidalCategoryStruct.tensorUnit).symm.trans (CategoryTheory.MonoidalCategory.tensorIso (CategoryTheory.Iso.refl (F.obj X)) ÎµIsoâœ.symm)).trans (CategoryTheory.MonoidalCategoryStruct.rightUnitor (F.obj X))).hom) _autoâœ\nÎ¼Iso : (X Y : D) â†’ CategoryTheory.Iso (CategoryTheory.MonoidalCategoryStruct.tensorObj (F.obj X) (F.obj Y)) (F.obj (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y))\nwhiskerLeft_eq : autoParam (âˆ€ (X : D) {Yâ‚ Yâ‚‚ : D} (f : Quiver.Hom Yâ‚ Yâ‚‚), Eq (F.map (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X f)) (CategoryTheory.CategoryStruct.comp (Î¼Iso X Yâ‚).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (F.obj X) (F.map f)) (Î¼Iso X Yâ‚‚).hom))) _autoâœ\nwhiskerRight_eq : autoParam (âˆ€ {Xâ‚ Xâ‚‚ : D} (f : Quiver.Hom Xâ‚ Xâ‚‚) (Y : D), Eq (F.map (CategoryTheory.MonoidalCategoryStruct.whiskerRight f Y)) (CategoryTheory.CategoryStruct.comp (Î¼Iso Xâ‚ Y).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (F.map f) (F.obj Y)) (Î¼Iso Xâ‚‚ Y).hom))) _autoâœ\ntensorHom_eq : autoParam (âˆ€ {Xâ‚ Yâ‚ Xâ‚‚ Yâ‚‚ : D} (f : Quiver.Hom Xâ‚ Yâ‚) (g : Quiver.Hom Xâ‚‚ Yâ‚‚), Eq (F.map (CategoryTheory.MonoidalCategoryStruct.tensorHom f g)) (CategoryTheory.CategoryStruct.comp (Î¼Iso Xâ‚ Xâ‚‚).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom (F.map f) (F.map g)) (Î¼Iso Yâ‚ Yâ‚‚).hom))) _autoâœ\nÎµIso : CategoryTheory.Iso CategoryTheory.MonoidalCategoryStruct.tensorUnit (F.obj CategoryTheory.MonoidalCategoryStruct.tensorUnit)\nassociator_eq : autoParam (âˆ€ (X Y Z : D), Eq (F.map (CategoryTheory.MonoidalCategoryStruct.associator X Y Z).hom) (((Î¼Iso (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y) Z).symm.trans (CategoryTheory.MonoidalCategory.tensorIso (Î¼Iso X Y).symm (CategoryTheory.Iso.refl (F.obj Z)))).trans ((CategoryTheory.MonoidalCategoryStruct.associator (F.obj X) (F.obj Y) (F.obj Z)).trans ((CategoryTheory.MonoidalCategory.tensorIso (CategoryTheory.Iso.refl (F.obj X)) (Î¼Iso Y Z)).trans (Î¼Iso X (CategoryTheory.MonoidalCategoryStruct.tensorObj Y Z))))).hom) _autoâœ\nleftUnitor_eq : autoParam (âˆ€ (X : D), Eq (F.map (CategoryTheory.MonoidalCategoryStruct.leftUnitor X).hom) (((Î¼Iso CategoryTheory.MonoidalCategoryStruct.tensorUnit X).symm.trans (CategoryTheory.MonoidalCategory.tensorIso ÎµIso.symm (CategoryTheory.Iso.refl (F.obj X)))).trans (CategoryTheory.MonoidalCategoryStruct.leftUnitor (F.obj X))).hom) _autoâœ\nrightUnitor_eq : autoParam (âˆ€ (X : D), Eq (F.map (CategoryTheory.MonoidalCategoryStruct.rightUnitor X).hom) (((Î¼Iso X CategoryTheory.MonoidalCategoryStruct.tensorUnit).symm.trans (CategoryTheory.MonoidalCategory.tensorIso (CategoryTheory.Iso.refl (F.obj X)) ÎµIso.symm)).trans (CategoryTheory.MonoidalCategoryStruct.rightUnitor (F.obj X))).hom) _autoâœ\nxâœ : Eq { Î¼Iso := Î¼Isoâœ, whiskerLeft_eq := whiskerLeft_eqâœ, whiskerRight_eq := whiskerRight_eqâœ, tensorHom_eq := tensorHom_eqâœ, ÎµIso := ÎµIsoâœ, associator_eq := associator_eqâœ, leftUnitor_eq := leftUnitor_eqâœ, rightUnitor_eq := rightUnitor_eqâœ } { Î¼Iso := Î¼Iso, whiskerLeft_eq := whiskerLeft_eq, whiskerRight_eq := whiskerRight_eq, tensorHom_eq := tensorHom_eq, ÎµIso := ÎµIso, associator_eq := associator_eq, leftUnitor_eq := leftUnitor_eq, rightUnitor_eq := rightUnitor_eq }\nâŠ¢ And (Eq Î¼Isoâœ Î¼Iso) (Eq ÎµIsoâœ ÎµIso)","decl":"/-- The data needed to induce a `MonoidalCategory` via the functor `F`; namely, pre-existing\ndefinitions of `âŠ—`, `ğŸ™_`, `â–·`, `â—` that are preserved by `F`.\n-/\nstructure InducingFunctorData [MonoidalCategoryStruct D] (F : D â¥¤ C) where\n  /-- Analogous to `CategoryTheory.LaxMonoidalFunctor.Î¼Iso` -/\n  Î¼Iso : âˆ€ X Y,\n    F.obj X âŠ— F.obj Y â‰… F.obj (X âŠ— Y)\n  whiskerLeft_eq : âˆ€ (X : D) {Yâ‚ Yâ‚‚ : D} (f : Yâ‚ âŸ¶ Yâ‚‚),\n    F.map (X â— f) = (Î¼Iso _ _).inv â‰« (F.obj X â— F.map f) â‰« (Î¼Iso _ _).hom := by\n    aesop_cat\n  whiskerRight_eq : âˆ€ {Xâ‚ Xâ‚‚ : D} (f : Xâ‚ âŸ¶ Xâ‚‚) (Y : D),\n    F.map (f â–· Y) = (Î¼Iso _ _).inv â‰« (F.map f â–· F.obj Y) â‰« (Î¼Iso _ _).hom := by\n    aesop_cat\n  tensorHom_eq : âˆ€ {Xâ‚ Yâ‚ Xâ‚‚ Yâ‚‚ : D} (f : Xâ‚ âŸ¶ Yâ‚) (g : Xâ‚‚ âŸ¶ Yâ‚‚),\n    F.map (f âŠ— g) = (Î¼Iso _ _).inv â‰« (F.map f âŠ— F.map g) â‰« (Î¼Iso _ _).hom := by\n    aesop_cat\n  /-- Analogous to `CategoryTheory.LaxMonoidalFunctor.ÎµIso` -/\n  ÎµIso : ğŸ™_ _ â‰… F.obj (ğŸ™_ _)\n  associator_eq : âˆ€ X Y Z : D,\n    F.map (Î±_ X Y Z).hom =\n      (((Î¼Iso _ _).symm â‰ªâ‰« ((Î¼Iso _ _).symm âŠ— .refl _))\n        â‰ªâ‰« Î±_ (F.obj X) (F.obj Y) (F.obj Z)\n        â‰ªâ‰« ((.refl _ âŠ— Î¼Iso _ _) â‰ªâ‰« Î¼Iso _ _)).hom := by\n    aesop_cat\n  leftUnitor_eq : âˆ€ X : D,\n    F.map (Î»_ X).hom =\n      (((Î¼Iso _ _).symm â‰ªâ‰« (ÎµIso.symm âŠ— .refl _)) â‰ªâ‰« Î»_ (F.obj X)).hom := by\n    aesop_cat\n  rightUnitor_eq : âˆ€ X : D,\n    F.map (Ï_ X).hom =\n      (((Î¼Iso _ _).symm â‰ªâ‰« (.refl _ âŠ— ÎµIso.symm)) â‰ªâ‰« Ï_ (F.obj X)).hom := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.Monoidal.InducingFunctorData.leftUnitor_eq","module":"Mathlib.CategoryTheory.Monoidal.Transport","initialProofState":"C : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ² : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœ : CategoryTheory.MonoidalCategoryStruct D\nF : CategoryTheory.Functor D C\nself : CategoryTheory.Monoidal.InducingFunctorData F\nX : D\nâŠ¢ Eq (F.map (CategoryTheory.MonoidalCategoryStruct.leftUnitor X).hom) (((self.Î¼Iso CategoryTheory.MonoidalCategoryStruct.tensorUnit X).symm.trans (CategoryTheory.MonoidalCategory.tensorIso self.ÎµIso.symm (CategoryTheory.Iso.refl (F.obj X)))).trans (CategoryTheory.MonoidalCategoryStruct.leftUnitor (F.obj X))).hom","decl":"/-- The data needed to induce a `MonoidalCategory` via the functor `F`; namely, pre-existing\ndefinitions of `âŠ—`, `ğŸ™_`, `â–·`, `â—` that are preserved by `F`.\n-/\nstructure InducingFunctorData [MonoidalCategoryStruct D] (F : D â¥¤ C) where\n  /-- Analogous to `CategoryTheory.LaxMonoidalFunctor.Î¼Iso` -/\n  Î¼Iso : âˆ€ X Y,\n    F.obj X âŠ— F.obj Y â‰… F.obj (X âŠ— Y)\n  whiskerLeft_eq : âˆ€ (X : D) {Yâ‚ Yâ‚‚ : D} (f : Yâ‚ âŸ¶ Yâ‚‚),\n    F.map (X â— f) = (Î¼Iso _ _).inv â‰« (F.obj X â— F.map f) â‰« (Î¼Iso _ _).hom := by\n    aesop_cat\n  whiskerRight_eq : âˆ€ {Xâ‚ Xâ‚‚ : D} (f : Xâ‚ âŸ¶ Xâ‚‚) (Y : D),\n    F.map (f â–· Y) = (Î¼Iso _ _).inv â‰« (F.map f â–· F.obj Y) â‰« (Î¼Iso _ _).hom := by\n    aesop_cat\n  tensorHom_eq : âˆ€ {Xâ‚ Yâ‚ Xâ‚‚ Yâ‚‚ : D} (f : Xâ‚ âŸ¶ Yâ‚) (g : Xâ‚‚ âŸ¶ Yâ‚‚),\n    F.map (f âŠ— g) = (Î¼Iso _ _).inv â‰« (F.map f âŠ— F.map g) â‰« (Î¼Iso _ _).hom := by\n    aesop_cat\n  /-- Analogous to `CategoryTheory.LaxMonoidalFunctor.ÎµIso` -/\n  ÎµIso : ğŸ™_ _ â‰… F.obj (ğŸ™_ _)\n  associator_eq : âˆ€ X Y Z : D,\n    F.map (Î±_ X Y Z).hom =\n      (((Î¼Iso _ _).symm â‰ªâ‰« ((Î¼Iso _ _).symm âŠ— .refl _))\n        â‰ªâ‰« Î±_ (F.obj X) (F.obj Y) (F.obj Z)\n        â‰ªâ‰« ((.refl _ âŠ— Î¼Iso _ _) â‰ªâ‰« Î¼Iso _ _)).hom := by\n    aesop_cat\n  leftUnitor_eq : âˆ€ X : D,\n    F.map (Î»_ X).hom =\n      (((Î¼Iso _ _).symm â‰ªâ‰« (ÎµIso.symm âŠ— .refl _)) â‰ªâ‰« Î»_ (F.obj X)).hom := by\n    aesop_cat\n  rightUnitor_eq : âˆ€ X : D,\n    F.map (Ï_ X).hom =\n      (((Î¼Iso _ _).symm â‰ªâ‰« (.refl _ âŠ— ÎµIso.symm)) â‰ªâ‰« Ï_ (F.obj X)).hom := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.Monoidal.InducingFunctorData.mk.injEq","module":"Mathlib.CategoryTheory.Monoidal.Transport","initialProofState":"C : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ² : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœ : CategoryTheory.MonoidalCategoryStruct D\nF : CategoryTheory.Functor D C\nÎ¼Isoâœ : (X Y : D) â†’ CategoryTheory.Iso (CategoryTheory.MonoidalCategoryStruct.tensorObj (F.obj X) (F.obj Y)) (F.obj (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y))\nwhiskerLeft_eqâœ : autoParam (âˆ€ (X : D) {Yâ‚ Yâ‚‚ : D} (f : Quiver.Hom Yâ‚ Yâ‚‚), Eq (F.map (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X f)) (CategoryTheory.CategoryStruct.comp (Î¼Isoâœ X Yâ‚).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (F.obj X) (F.map f)) (Î¼Isoâœ X Yâ‚‚).hom))) _autoâœ\nwhiskerRight_eqâœ : autoParam (âˆ€ {Xâ‚ Xâ‚‚ : D} (f : Quiver.Hom Xâ‚ Xâ‚‚) (Y : D), Eq (F.map (CategoryTheory.MonoidalCategoryStruct.whiskerRight f Y)) (CategoryTheory.CategoryStruct.comp (Î¼Isoâœ Xâ‚ Y).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (F.map f) (F.obj Y)) (Î¼Isoâœ Xâ‚‚ Y).hom))) _autoâœ\ntensorHom_eqâœ : autoParam (âˆ€ {Xâ‚ Yâ‚ Xâ‚‚ Yâ‚‚ : D} (f : Quiver.Hom Xâ‚ Yâ‚) (g : Quiver.Hom Xâ‚‚ Yâ‚‚), Eq (F.map (CategoryTheory.MonoidalCategoryStruct.tensorHom f g)) (CategoryTheory.CategoryStruct.comp (Î¼Isoâœ Xâ‚ Xâ‚‚).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom (F.map f) (F.map g)) (Î¼Isoâœ Yâ‚ Yâ‚‚).hom))) _autoâœ\nÎµIsoâœ : CategoryTheory.Iso CategoryTheory.MonoidalCategoryStruct.tensorUnit (F.obj CategoryTheory.MonoidalCategoryStruct.tensorUnit)\nassociator_eqâœ : autoParam (âˆ€ (X Y Z : D), Eq (F.map (CategoryTheory.MonoidalCategoryStruct.associator X Y Z).hom) (((Î¼Isoâœ (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y) Z).symm.trans (CategoryTheory.MonoidalCategory.tensorIso (Î¼Isoâœ X Y).symm (CategoryTheory.Iso.refl (F.obj Z)))).trans ((CategoryTheory.MonoidalCategoryStruct.associator (F.obj X) (F.obj Y) (F.obj Z)).trans ((CategoryTheory.MonoidalCategory.tensorIso (CategoryTheory.Iso.refl (F.obj X)) (Î¼Isoâœ Y Z)).trans (Î¼Isoâœ X (CategoryTheory.MonoidalCategoryStruct.tensorObj Y Z))))).hom) _autoâœ\nleftUnitor_eqâœ : autoParam (âˆ€ (X : D), Eq (F.map (CategoryTheory.MonoidalCategoryStruct.leftUnitor X).hom) (((Î¼Isoâœ CategoryTheory.MonoidalCategoryStruct.tensorUnit X).symm.trans (CategoryTheory.MonoidalCategory.tensorIso ÎµIsoâœ.symm (CategoryTheory.Iso.refl (F.obj X)))).trans (CategoryTheory.MonoidalCategoryStruct.leftUnitor (F.obj X))).hom) _autoâœ\nrightUnitor_eqâœ : autoParam (âˆ€ (X : D), Eq (F.map (CategoryTheory.MonoidalCategoryStruct.rightUnitor X).hom) (((Î¼Isoâœ X CategoryTheory.MonoidalCategoryStruct.tensorUnit).symm.trans (CategoryTheory.MonoidalCategory.tensorIso (CategoryTheory.Iso.refl (F.obj X)) ÎµIsoâœ.symm)).trans (CategoryTheory.MonoidalCategoryStruct.rightUnitor (F.obj X))).hom) _autoâœ\nÎ¼Iso : (X Y : D) â†’ CategoryTheory.Iso (CategoryTheory.MonoidalCategoryStruct.tensorObj (F.obj X) (F.obj Y)) (F.obj (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y))\nwhiskerLeft_eq : autoParam (âˆ€ (X : D) {Yâ‚ Yâ‚‚ : D} (f : Quiver.Hom Yâ‚ Yâ‚‚), Eq (F.map (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X f)) (CategoryTheory.CategoryStruct.comp (Î¼Iso X Yâ‚).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (F.obj X) (F.map f)) (Î¼Iso X Yâ‚‚).hom))) _autoâœ\nwhiskerRight_eq : autoParam (âˆ€ {Xâ‚ Xâ‚‚ : D} (f : Quiver.Hom Xâ‚ Xâ‚‚) (Y : D), Eq (F.map (CategoryTheory.MonoidalCategoryStruct.whiskerRight f Y)) (CategoryTheory.CategoryStruct.comp (Î¼Iso Xâ‚ Y).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (F.map f) (F.obj Y)) (Î¼Iso Xâ‚‚ Y).hom))) _autoâœ\ntensorHom_eq : autoParam (âˆ€ {Xâ‚ Yâ‚ Xâ‚‚ Yâ‚‚ : D} (f : Quiver.Hom Xâ‚ Yâ‚) (g : Quiver.Hom Xâ‚‚ Yâ‚‚), Eq (F.map (CategoryTheory.MonoidalCategoryStruct.tensorHom f g)) (CategoryTheory.CategoryStruct.comp (Î¼Iso Xâ‚ Xâ‚‚).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom (F.map f) (F.map g)) (Î¼Iso Yâ‚ Yâ‚‚).hom))) _autoâœ\nÎµIso : CategoryTheory.Iso CategoryTheory.MonoidalCategoryStruct.tensorUnit (F.obj CategoryTheory.MonoidalCategoryStruct.tensorUnit)\nassociator_eq : autoParam (âˆ€ (X Y Z : D), Eq (F.map (CategoryTheory.MonoidalCategoryStruct.associator X Y Z).hom) (((Î¼Iso (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y) Z).symm.trans (CategoryTheory.MonoidalCategory.tensorIso (Î¼Iso X Y).symm (CategoryTheory.Iso.refl (F.obj Z)))).trans ((CategoryTheory.MonoidalCategoryStruct.associator (F.obj X) (F.obj Y) (F.obj Z)).trans ((CategoryTheory.MonoidalCategory.tensorIso (CategoryTheory.Iso.refl (F.obj X)) (Î¼Iso Y Z)).trans (Î¼Iso X (CategoryTheory.MonoidalCategoryStruct.tensorObj Y Z))))).hom) _autoâœ\nleftUnitor_eq : autoParam (âˆ€ (X : D), Eq (F.map (CategoryTheory.MonoidalCategoryStruct.leftUnitor X).hom) (((Î¼Iso CategoryTheory.MonoidalCategoryStruct.tensorUnit X).symm.trans (CategoryTheory.MonoidalCategory.tensorIso ÎµIso.symm (CategoryTheory.Iso.refl (F.obj X)))).trans (CategoryTheory.MonoidalCategoryStruct.leftUnitor (F.obj X))).hom) _autoâœ\nrightUnitor_eq : autoParam (âˆ€ (X : D), Eq (F.map (CategoryTheory.MonoidalCategoryStruct.rightUnitor X).hom) (((Î¼Iso X CategoryTheory.MonoidalCategoryStruct.tensorUnit).symm.trans (CategoryTheory.MonoidalCategory.tensorIso (CategoryTheory.Iso.refl (F.obj X)) ÎµIso.symm)).trans (CategoryTheory.MonoidalCategoryStruct.rightUnitor (F.obj X))).hom) _autoâœ\nâŠ¢ Eq (Eq { Î¼Iso := Î¼Isoâœ, whiskerLeft_eq := whiskerLeft_eqâœ, whiskerRight_eq := whiskerRight_eqâœ, tensorHom_eq := tensorHom_eqâœ, ÎµIso := ÎµIsoâœ, associator_eq := associator_eqâœ, leftUnitor_eq := leftUnitor_eqâœ, rightUnitor_eq := rightUnitor_eqâœ } { Î¼Iso := Î¼Iso, whiskerLeft_eq := whiskerLeft_eq, whiskerRight_eq := whiskerRight_eq, tensorHom_eq := tensorHom_eq, ÎµIso := ÎµIso, associator_eq := associator_eq, leftUnitor_eq := leftUnitor_eq, rightUnitor_eq := rightUnitor_eq }) (And (Eq Î¼Isoâœ Î¼Iso) (Eq ÎµIsoâœ ÎµIso))","decl":"/-- The data needed to induce a `MonoidalCategory` via the functor `F`; namely, pre-existing\ndefinitions of `âŠ—`, `ğŸ™_`, `â–·`, `â—` that are preserved by `F`.\n-/\nstructure InducingFunctorData [MonoidalCategoryStruct D] (F : D â¥¤ C) where\n  /-- Analogous to `CategoryTheory.LaxMonoidalFunctor.Î¼Iso` -/\n  Î¼Iso : âˆ€ X Y,\n    F.obj X âŠ— F.obj Y â‰… F.obj (X âŠ— Y)\n  whiskerLeft_eq : âˆ€ (X : D) {Yâ‚ Yâ‚‚ : D} (f : Yâ‚ âŸ¶ Yâ‚‚),\n    F.map (X â— f) = (Î¼Iso _ _).inv â‰« (F.obj X â— F.map f) â‰« (Î¼Iso _ _).hom := by\n    aesop_cat\n  whiskerRight_eq : âˆ€ {Xâ‚ Xâ‚‚ : D} (f : Xâ‚ âŸ¶ Xâ‚‚) (Y : D),\n    F.map (f â–· Y) = (Î¼Iso _ _).inv â‰« (F.map f â–· F.obj Y) â‰« (Î¼Iso _ _).hom := by\n    aesop_cat\n  tensorHom_eq : âˆ€ {Xâ‚ Yâ‚ Xâ‚‚ Yâ‚‚ : D} (f : Xâ‚ âŸ¶ Yâ‚) (g : Xâ‚‚ âŸ¶ Yâ‚‚),\n    F.map (f âŠ— g) = (Î¼Iso _ _).inv â‰« (F.map f âŠ— F.map g) â‰« (Î¼Iso _ _).hom := by\n    aesop_cat\n  /-- Analogous to `CategoryTheory.LaxMonoidalFunctor.ÎµIso` -/\n  ÎµIso : ğŸ™_ _ â‰… F.obj (ğŸ™_ _)\n  associator_eq : âˆ€ X Y Z : D,\n    F.map (Î±_ X Y Z).hom =\n      (((Î¼Iso _ _).symm â‰ªâ‰« ((Î¼Iso _ _).symm âŠ— .refl _))\n        â‰ªâ‰« Î±_ (F.obj X) (F.obj Y) (F.obj Z)\n        â‰ªâ‰« ((.refl _ âŠ— Î¼Iso _ _) â‰ªâ‰« Î¼Iso _ _)).hom := by\n    aesop_cat\n  leftUnitor_eq : âˆ€ X : D,\n    F.map (Î»_ X).hom =\n      (((Î¼Iso _ _).symm â‰ªâ‰« (ÎµIso.symm âŠ— .refl _)) â‰ªâ‰« Î»_ (F.obj X)).hom := by\n    aesop_cat\n  rightUnitor_eq : âˆ€ X : D,\n    F.map (Ï_ X).hom =\n      (((Î¼Iso _ _).symm â‰ªâ‰« (.refl _ âŠ— ÎµIso.symm)) â‰ªâ‰« Ï_ (F.obj X)).hom := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.Monoidal.InducingFunctorData.rightUnitor_eq","module":"Mathlib.CategoryTheory.Monoidal.Transport","initialProofState":"C : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ² : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœ : CategoryTheory.MonoidalCategoryStruct D\nF : CategoryTheory.Functor D C\nself : CategoryTheory.Monoidal.InducingFunctorData F\nX : D\nâŠ¢ Eq (F.map (CategoryTheory.MonoidalCategoryStruct.rightUnitor X).hom) (((self.Î¼Iso X CategoryTheory.MonoidalCategoryStruct.tensorUnit).symm.trans (CategoryTheory.MonoidalCategory.tensorIso (CategoryTheory.Iso.refl (F.obj X)) self.ÎµIso.symm)).trans (CategoryTheory.MonoidalCategoryStruct.rightUnitor (F.obj X))).hom","decl":"/-- The data needed to induce a `MonoidalCategory` via the functor `F`; namely, pre-existing\ndefinitions of `âŠ—`, `ğŸ™_`, `â–·`, `â—` that are preserved by `F`.\n-/\nstructure InducingFunctorData [MonoidalCategoryStruct D] (F : D â¥¤ C) where\n  /-- Analogous to `CategoryTheory.LaxMonoidalFunctor.Î¼Iso` -/\n  Î¼Iso : âˆ€ X Y,\n    F.obj X âŠ— F.obj Y â‰… F.obj (X âŠ— Y)\n  whiskerLeft_eq : âˆ€ (X : D) {Yâ‚ Yâ‚‚ : D} (f : Yâ‚ âŸ¶ Yâ‚‚),\n    F.map (X â— f) = (Î¼Iso _ _).inv â‰« (F.obj X â— F.map f) â‰« (Î¼Iso _ _).hom := by\n    aesop_cat\n  whiskerRight_eq : âˆ€ {Xâ‚ Xâ‚‚ : D} (f : Xâ‚ âŸ¶ Xâ‚‚) (Y : D),\n    F.map (f â–· Y) = (Î¼Iso _ _).inv â‰« (F.map f â–· F.obj Y) â‰« (Î¼Iso _ _).hom := by\n    aesop_cat\n  tensorHom_eq : âˆ€ {Xâ‚ Yâ‚ Xâ‚‚ Yâ‚‚ : D} (f : Xâ‚ âŸ¶ Yâ‚) (g : Xâ‚‚ âŸ¶ Yâ‚‚),\n    F.map (f âŠ— g) = (Î¼Iso _ _).inv â‰« (F.map f âŠ— F.map g) â‰« (Î¼Iso _ _).hom := by\n    aesop_cat\n  /-- Analogous to `CategoryTheory.LaxMonoidalFunctor.ÎµIso` -/\n  ÎµIso : ğŸ™_ _ â‰… F.obj (ğŸ™_ _)\n  associator_eq : âˆ€ X Y Z : D,\n    F.map (Î±_ X Y Z).hom =\n      (((Î¼Iso _ _).symm â‰ªâ‰« ((Î¼Iso _ _).symm âŠ— .refl _))\n        â‰ªâ‰« Î±_ (F.obj X) (F.obj Y) (F.obj Z)\n        â‰ªâ‰« ((.refl _ âŠ— Î¼Iso _ _) â‰ªâ‰« Î¼Iso _ _)).hom := by\n    aesop_cat\n  leftUnitor_eq : âˆ€ X : D,\n    F.map (Î»_ X).hom =\n      (((Î¼Iso _ _).symm â‰ªâ‰« (ÎµIso.symm âŠ— .refl _)) â‰ªâ‰« Î»_ (F.obj X)).hom := by\n    aesop_cat\n  rightUnitor_eq : âˆ€ X : D,\n    F.map (Ï_ X).hom =\n      (((Î¼Iso _ _).symm â‰ªâ‰« (.refl _ âŠ— ÎµIso.symm)) â‰ªâ‰« Ï_ (F.obj X)).hom := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.Monoidal.InducingFunctorData.associator_eq","module":"Mathlib.CategoryTheory.Monoidal.Transport","initialProofState":"C : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ² : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœ : CategoryTheory.MonoidalCategoryStruct D\nF : CategoryTheory.Functor D C\nself : CategoryTheory.Monoidal.InducingFunctorData F\nX Y Z : D\nâŠ¢ Eq (F.map (CategoryTheory.MonoidalCategoryStruct.associator X Y Z).hom) (((self.Î¼Iso (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y) Z).symm.trans (CategoryTheory.MonoidalCategory.tensorIso (self.Î¼Iso X Y).symm (CategoryTheory.Iso.refl (F.obj Z)))).trans ((CategoryTheory.MonoidalCategoryStruct.associator (F.obj X) (F.obj Y) (F.obj Z)).trans ((CategoryTheory.MonoidalCategory.tensorIso (CategoryTheory.Iso.refl (F.obj X)) (self.Î¼Iso Y Z)).trans (self.Î¼Iso X (CategoryTheory.MonoidalCategoryStruct.tensorObj Y Z))))).hom","decl":"/-- The data needed to induce a `MonoidalCategory` via the functor `F`; namely, pre-existing\ndefinitions of `âŠ—`, `ğŸ™_`, `â–·`, `â—` that are preserved by `F`.\n-/\nstructure InducingFunctorData [MonoidalCategoryStruct D] (F : D â¥¤ C) where\n  /-- Analogous to `CategoryTheory.LaxMonoidalFunctor.Î¼Iso` -/\n  Î¼Iso : âˆ€ X Y,\n    F.obj X âŠ— F.obj Y â‰… F.obj (X âŠ— Y)\n  whiskerLeft_eq : âˆ€ (X : D) {Yâ‚ Yâ‚‚ : D} (f : Yâ‚ âŸ¶ Yâ‚‚),\n    F.map (X â— f) = (Î¼Iso _ _).inv â‰« (F.obj X â— F.map f) â‰« (Î¼Iso _ _).hom := by\n    aesop_cat\n  whiskerRight_eq : âˆ€ {Xâ‚ Xâ‚‚ : D} (f : Xâ‚ âŸ¶ Xâ‚‚) (Y : D),\n    F.map (f â–· Y) = (Î¼Iso _ _).inv â‰« (F.map f â–· F.obj Y) â‰« (Î¼Iso _ _).hom := by\n    aesop_cat\n  tensorHom_eq : âˆ€ {Xâ‚ Yâ‚ Xâ‚‚ Yâ‚‚ : D} (f : Xâ‚ âŸ¶ Yâ‚) (g : Xâ‚‚ âŸ¶ Yâ‚‚),\n    F.map (f âŠ— g) = (Î¼Iso _ _).inv â‰« (F.map f âŠ— F.map g) â‰« (Î¼Iso _ _).hom := by\n    aesop_cat\n  /-- Analogous to `CategoryTheory.LaxMonoidalFunctor.ÎµIso` -/\n  ÎµIso : ğŸ™_ _ â‰… F.obj (ğŸ™_ _)\n  associator_eq : âˆ€ X Y Z : D,\n    F.map (Î±_ X Y Z).hom =\n      (((Î¼Iso _ _).symm â‰ªâ‰« ((Î¼Iso _ _).symm âŠ— .refl _))\n        â‰ªâ‰« Î±_ (F.obj X) (F.obj Y) (F.obj Z)\n        â‰ªâ‰« ((.refl _ âŠ— Î¼Iso _ _) â‰ªâ‰« Î¼Iso _ _)).hom := by\n    aesop_cat\n  leftUnitor_eq : âˆ€ X : D,\n    F.map (Î»_ X).hom =\n      (((Î¼Iso _ _).symm â‰ªâ‰« (ÎµIso.symm âŠ— .refl _)) â‰ªâ‰« Î»_ (F.obj X)).hom := by\n    aesop_cat\n  rightUnitor_eq : âˆ€ X : D,\n    F.map (Ï_ X).hom =\n      (((Î¼Iso _ _).symm â‰ªâ‰« (.refl _ âŠ— ÎµIso.symm)) â‰ªâ‰« Ï_ (F.obj X)).hom := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.Monoidal.InducingFunctorData.tensorHom_eq","module":"Mathlib.CategoryTheory.Monoidal.Transport","initialProofState":"C : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ² : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœ : CategoryTheory.MonoidalCategoryStruct D\nF : CategoryTheory.Functor D C\nself : CategoryTheory.Monoidal.InducingFunctorData F\nXâ‚ Yâ‚ Xâ‚‚ Yâ‚‚ : D\nf : Quiver.Hom Xâ‚ Yâ‚\ng : Quiver.Hom Xâ‚‚ Yâ‚‚\nâŠ¢ Eq (F.map (CategoryTheory.MonoidalCategoryStruct.tensorHom f g)) (CategoryTheory.CategoryStruct.comp (self.Î¼Iso Xâ‚ Xâ‚‚).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom (F.map f) (F.map g)) (self.Î¼Iso Yâ‚ Yâ‚‚).hom))","decl":"/-- The data needed to induce a `MonoidalCategory` via the functor `F`; namely, pre-existing\ndefinitions of `âŠ—`, `ğŸ™_`, `â–·`, `â—` that are preserved by `F`.\n-/\nstructure InducingFunctorData [MonoidalCategoryStruct D] (F : D â¥¤ C) where\n  /-- Analogous to `CategoryTheory.LaxMonoidalFunctor.Î¼Iso` -/\n  Î¼Iso : âˆ€ X Y,\n    F.obj X âŠ— F.obj Y â‰… F.obj (X âŠ— Y)\n  whiskerLeft_eq : âˆ€ (X : D) {Yâ‚ Yâ‚‚ : D} (f : Yâ‚ âŸ¶ Yâ‚‚),\n    F.map (X â— f) = (Î¼Iso _ _).inv â‰« (F.obj X â— F.map f) â‰« (Î¼Iso _ _).hom := by\n    aesop_cat\n  whiskerRight_eq : âˆ€ {Xâ‚ Xâ‚‚ : D} (f : Xâ‚ âŸ¶ Xâ‚‚) (Y : D),\n    F.map (f â–· Y) = (Î¼Iso _ _).inv â‰« (F.map f â–· F.obj Y) â‰« (Î¼Iso _ _).hom := by\n    aesop_cat\n  tensorHom_eq : âˆ€ {Xâ‚ Yâ‚ Xâ‚‚ Yâ‚‚ : D} (f : Xâ‚ âŸ¶ Yâ‚) (g : Xâ‚‚ âŸ¶ Yâ‚‚),\n    F.map (f âŠ— g) = (Î¼Iso _ _).inv â‰« (F.map f âŠ— F.map g) â‰« (Î¼Iso _ _).hom := by\n    aesop_cat\n  /-- Analogous to `CategoryTheory.LaxMonoidalFunctor.ÎµIso` -/\n  ÎµIso : ğŸ™_ _ â‰… F.obj (ğŸ™_ _)\n  associator_eq : âˆ€ X Y Z : D,\n    F.map (Î±_ X Y Z).hom =\n      (((Î¼Iso _ _).symm â‰ªâ‰« ((Î¼Iso _ _).symm âŠ— .refl _))\n        â‰ªâ‰« Î±_ (F.obj X) (F.obj Y) (F.obj Z)\n        â‰ªâ‰« ((.refl _ âŠ— Î¼Iso _ _) â‰ªâ‰« Î¼Iso _ _)).hom := by\n    aesop_cat\n  leftUnitor_eq : âˆ€ X : D,\n    F.map (Î»_ X).hom =\n      (((Î¼Iso _ _).symm â‰ªâ‰« (ÎµIso.symm âŠ— .refl _)) â‰ªâ‰« Î»_ (F.obj X)).hom := by\n    aesop_cat\n  rightUnitor_eq : âˆ€ X : D,\n    F.map (Ï_ X).hom =\n      (((Î¼Iso _ _).symm â‰ªâ‰« (.refl _ âŠ— ÎµIso.symm)) â‰ªâ‰« Ï_ (F.obj X)).hom := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.Monoidal.transportStruct_tensorObj","module":"Mathlib.CategoryTheory.Monoidal.Transport","initialProofState":"C : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ¹ : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ne : CategoryTheory.Equivalence C D\nX Y : D\nâŠ¢ Eq (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y) (e.functor.obj (CategoryTheory.MonoidalCategoryStruct.tensorObj (e.inverse.obj X) (e.inverse.obj Y)))","decl":"/-- Transport a monoidal structure along an equivalence of (plain) categories.\n-/\n@[simps (config := .lemmasOnly)]\ndef transportStruct (e : C â‰Œ D) : MonoidalCategoryStruct.{vâ‚‚} D where\n  tensorObj X Y := e.functor.obj (e.inverse.obj X âŠ— e.inverse.obj Y)\n  whiskerLeft X _ _ f := e.functor.map (e.inverse.obj X â— e.inverse.map f)\n  whiskerRight f X := e.functor.map (e.inverse.map f â–· e.inverse.obj X)\n  tensorHom f g := e.functor.map (e.inverse.map f âŠ— e.inverse.map g)\n  tensorUnit := e.functor.obj (ğŸ™_ C)\n  associator X Y Z :=\n    e.functor.mapIso\n      (whiskerRightIso (e.unitIso.app _).symm _ â‰ªâ‰«\n        Î±_ (e.inverse.obj X) (e.inverse.obj Y) (e.inverse.obj Z) â‰ªâ‰«\n        whiskerLeftIso _ (e.unitIso.app _))\n  leftUnitor X :=\n    e.functor.mapIso ((whiskerRightIso (e.unitIso.app _).symm _) â‰ªâ‰« Î»_ (e.inverse.obj X)) â‰ªâ‰«\n      e.counitIso.app _\n  rightUnitor X :=\n    e.functor.mapIso ((whiskerLeftIso _ (e.unitIso.app _).symm) â‰ªâ‰« Ï_ (e.inverse.obj X)) â‰ªâ‰«\n      e.counitIso.app _\n\n"}
{"name":"CategoryTheory.Monoidal.transportStruct_rightUnitor","module":"Mathlib.CategoryTheory.Monoidal.Transport","initialProofState":"C : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ¹ : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ne : CategoryTheory.Equivalence C D\nX : D\nâŠ¢ Eq (CategoryTheory.MonoidalCategoryStruct.rightUnitor X) ((e.functor.mapIso ((CategoryTheory.MonoidalCategory.whiskerLeftIso (e.inverse.obj X) (e.unitIso.app CategoryTheory.MonoidalCategoryStruct.tensorUnit).symm).trans (CategoryTheory.MonoidalCategoryStruct.rightUnitor (e.inverse.obj X)))).trans (e.counitIso.app X))","decl":"/-- Transport a monoidal structure along an equivalence of (plain) categories.\n-/\n@[simps (config := .lemmasOnly)]\ndef transportStruct (e : C â‰Œ D) : MonoidalCategoryStruct.{vâ‚‚} D where\n  tensorObj X Y := e.functor.obj (e.inverse.obj X âŠ— e.inverse.obj Y)\n  whiskerLeft X _ _ f := e.functor.map (e.inverse.obj X â— e.inverse.map f)\n  whiskerRight f X := e.functor.map (e.inverse.map f â–· e.inverse.obj X)\n  tensorHom f g := e.functor.map (e.inverse.map f âŠ— e.inverse.map g)\n  tensorUnit := e.functor.obj (ğŸ™_ C)\n  associator X Y Z :=\n    e.functor.mapIso\n      (whiskerRightIso (e.unitIso.app _).symm _ â‰ªâ‰«\n        Î±_ (e.inverse.obj X) (e.inverse.obj Y) (e.inverse.obj Z) â‰ªâ‰«\n        whiskerLeftIso _ (e.unitIso.app _))\n  leftUnitor X :=\n    e.functor.mapIso ((whiskerRightIso (e.unitIso.app _).symm _) â‰ªâ‰« Î»_ (e.inverse.obj X)) â‰ªâ‰«\n      e.counitIso.app _\n  rightUnitor X :=\n    e.functor.mapIso ((whiskerLeftIso _ (e.unitIso.app _).symm) â‰ªâ‰« Ï_ (e.inverse.obj X)) â‰ªâ‰«\n      e.counitIso.app _\n\n"}
{"name":"CategoryTheory.Monoidal.transportStruct_whiskerLeft","module":"Mathlib.CategoryTheory.Monoidal.Transport","initialProofState":"C : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ¹ : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ne : CategoryTheory.Equivalence C D\nX xâœÂ¹ xâœ : D\nf : Quiver.Hom xâœÂ¹ xâœ\nâŠ¢ Eq (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X f) (e.functor.map (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (e.inverse.obj X) (e.inverse.map f)))","decl":"/-- Transport a monoidal structure along an equivalence of (plain) categories.\n-/\n@[simps (config := .lemmasOnly)]\ndef transportStruct (e : C â‰Œ D) : MonoidalCategoryStruct.{vâ‚‚} D where\n  tensorObj X Y := e.functor.obj (e.inverse.obj X âŠ— e.inverse.obj Y)\n  whiskerLeft X _ _ f := e.functor.map (e.inverse.obj X â— e.inverse.map f)\n  whiskerRight f X := e.functor.map (e.inverse.map f â–· e.inverse.obj X)\n  tensorHom f g := e.functor.map (e.inverse.map f âŠ— e.inverse.map g)\n  tensorUnit := e.functor.obj (ğŸ™_ C)\n  associator X Y Z :=\n    e.functor.mapIso\n      (whiskerRightIso (e.unitIso.app _).symm _ â‰ªâ‰«\n        Î±_ (e.inverse.obj X) (e.inverse.obj Y) (e.inverse.obj Z) â‰ªâ‰«\n        whiskerLeftIso _ (e.unitIso.app _))\n  leftUnitor X :=\n    e.functor.mapIso ((whiskerRightIso (e.unitIso.app _).symm _) â‰ªâ‰« Î»_ (e.inverse.obj X)) â‰ªâ‰«\n      e.counitIso.app _\n  rightUnitor X :=\n    e.functor.mapIso ((whiskerLeftIso _ (e.unitIso.app _).symm) â‰ªâ‰« Ï_ (e.inverse.obj X)) â‰ªâ‰«\n      e.counitIso.app _\n\n"}
{"name":"CategoryTheory.Monoidal.transportStruct_tensorUnit","module":"Mathlib.CategoryTheory.Monoidal.Transport","initialProofState":"C : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ¹ : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ne : CategoryTheory.Equivalence C D\nâŠ¢ Eq CategoryTheory.MonoidalCategoryStruct.tensorUnit (e.functor.obj CategoryTheory.MonoidalCategoryStruct.tensorUnit)","decl":"/-- Transport a monoidal structure along an equivalence of (plain) categories.\n-/\n@[simps (config := .lemmasOnly)]\ndef transportStruct (e : C â‰Œ D) : MonoidalCategoryStruct.{vâ‚‚} D where\n  tensorObj X Y := e.functor.obj (e.inverse.obj X âŠ— e.inverse.obj Y)\n  whiskerLeft X _ _ f := e.functor.map (e.inverse.obj X â— e.inverse.map f)\n  whiskerRight f X := e.functor.map (e.inverse.map f â–· e.inverse.obj X)\n  tensorHom f g := e.functor.map (e.inverse.map f âŠ— e.inverse.map g)\n  tensorUnit := e.functor.obj (ğŸ™_ C)\n  associator X Y Z :=\n    e.functor.mapIso\n      (whiskerRightIso (e.unitIso.app _).symm _ â‰ªâ‰«\n        Î±_ (e.inverse.obj X) (e.inverse.obj Y) (e.inverse.obj Z) â‰ªâ‰«\n        whiskerLeftIso _ (e.unitIso.app _))\n  leftUnitor X :=\n    e.functor.mapIso ((whiskerRightIso (e.unitIso.app _).symm _) â‰ªâ‰« Î»_ (e.inverse.obj X)) â‰ªâ‰«\n      e.counitIso.app _\n  rightUnitor X :=\n    e.functor.mapIso ((whiskerLeftIso _ (e.unitIso.app _).symm) â‰ªâ‰« Ï_ (e.inverse.obj X)) â‰ªâ‰«\n      e.counitIso.app _\n\n"}
{"name":"CategoryTheory.Monoidal.transportStruct_leftUnitor","module":"Mathlib.CategoryTheory.Monoidal.Transport","initialProofState":"C : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ¹ : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ne : CategoryTheory.Equivalence C D\nX : D\nâŠ¢ Eq (CategoryTheory.MonoidalCategoryStruct.leftUnitor X) ((e.functor.mapIso ((CategoryTheory.MonoidalCategory.whiskerRightIso (e.unitIso.app CategoryTheory.MonoidalCategoryStruct.tensorUnit).symm (e.inverse.obj X)).trans (CategoryTheory.MonoidalCategoryStruct.leftUnitor (e.inverse.obj X)))).trans (e.counitIso.app X))","decl":"/-- Transport a monoidal structure along an equivalence of (plain) categories.\n-/\n@[simps (config := .lemmasOnly)]\ndef transportStruct (e : C â‰Œ D) : MonoidalCategoryStruct.{vâ‚‚} D where\n  tensorObj X Y := e.functor.obj (e.inverse.obj X âŠ— e.inverse.obj Y)\n  whiskerLeft X _ _ f := e.functor.map (e.inverse.obj X â— e.inverse.map f)\n  whiskerRight f X := e.functor.map (e.inverse.map f â–· e.inverse.obj X)\n  tensorHom f g := e.functor.map (e.inverse.map f âŠ— e.inverse.map g)\n  tensorUnit := e.functor.obj (ğŸ™_ C)\n  associator X Y Z :=\n    e.functor.mapIso\n      (whiskerRightIso (e.unitIso.app _).symm _ â‰ªâ‰«\n        Î±_ (e.inverse.obj X) (e.inverse.obj Y) (e.inverse.obj Z) â‰ªâ‰«\n        whiskerLeftIso _ (e.unitIso.app _))\n  leftUnitor X :=\n    e.functor.mapIso ((whiskerRightIso (e.unitIso.app _).symm _) â‰ªâ‰« Î»_ (e.inverse.obj X)) â‰ªâ‰«\n      e.counitIso.app _\n  rightUnitor X :=\n    e.functor.mapIso ((whiskerLeftIso _ (e.unitIso.app _).symm) â‰ªâ‰« Ï_ (e.inverse.obj X)) â‰ªâ‰«\n      e.counitIso.app _\n\n"}
{"name":"CategoryTheory.Monoidal.transportStruct_whiskerRight","module":"Mathlib.CategoryTheory.Monoidal.Transport","initialProofState":"C : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ¹ : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ne : CategoryTheory.Equivalence C D\nXâ‚âœ Xâ‚‚âœ : D\nf : Quiver.Hom Xâ‚âœ Xâ‚‚âœ\nX : D\nâŠ¢ Eq (CategoryTheory.MonoidalCategoryStruct.whiskerRight f X) (e.functor.map (CategoryTheory.MonoidalCategoryStruct.whiskerRight (e.inverse.map f) (e.inverse.obj X)))","decl":"/-- Transport a monoidal structure along an equivalence of (plain) categories.\n-/\n@[simps (config := .lemmasOnly)]\ndef transportStruct (e : C â‰Œ D) : MonoidalCategoryStruct.{vâ‚‚} D where\n  tensorObj X Y := e.functor.obj (e.inverse.obj X âŠ— e.inverse.obj Y)\n  whiskerLeft X _ _ f := e.functor.map (e.inverse.obj X â— e.inverse.map f)\n  whiskerRight f X := e.functor.map (e.inverse.map f â–· e.inverse.obj X)\n  tensorHom f g := e.functor.map (e.inverse.map f âŠ— e.inverse.map g)\n  tensorUnit := e.functor.obj (ğŸ™_ C)\n  associator X Y Z :=\n    e.functor.mapIso\n      (whiskerRightIso (e.unitIso.app _).symm _ â‰ªâ‰«\n        Î±_ (e.inverse.obj X) (e.inverse.obj Y) (e.inverse.obj Z) â‰ªâ‰«\n        whiskerLeftIso _ (e.unitIso.app _))\n  leftUnitor X :=\n    e.functor.mapIso ((whiskerRightIso (e.unitIso.app _).symm _) â‰ªâ‰« Î»_ (e.inverse.obj X)) â‰ªâ‰«\n      e.counitIso.app _\n  rightUnitor X :=\n    e.functor.mapIso ((whiskerLeftIso _ (e.unitIso.app _).symm) â‰ªâ‰« Ï_ (e.inverse.obj X)) â‰ªâ‰«\n      e.counitIso.app _\n\n"}
{"name":"CategoryTheory.Monoidal.transportStruct_associator","module":"Mathlib.CategoryTheory.Monoidal.Transport","initialProofState":"C : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ¹ : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ne : CategoryTheory.Equivalence C D\nX Y Z : D\nâŠ¢ Eq (CategoryTheory.MonoidalCategoryStruct.associator X Y Z) (e.functor.mapIso ((CategoryTheory.MonoidalCategory.whiskerRightIso (e.unitIso.app (CategoryTheory.MonoidalCategoryStruct.tensorObj (e.inverse.obj X) (e.inverse.obj Y))).symm (e.inverse.obj Z)).trans ((CategoryTheory.MonoidalCategoryStruct.associator (e.inverse.obj X) (e.inverse.obj Y) (e.inverse.obj Z)).trans (CategoryTheory.MonoidalCategory.whiskerLeftIso (e.inverse.obj X) (e.unitIso.app (CategoryTheory.MonoidalCategoryStruct.tensorObj (e.inverse.obj Y) (e.inverse.obj Z)))))))","decl":"/-- Transport a monoidal structure along an equivalence of (plain) categories.\n-/\n@[simps (config := .lemmasOnly)]\ndef transportStruct (e : C â‰Œ D) : MonoidalCategoryStruct.{vâ‚‚} D where\n  tensorObj X Y := e.functor.obj (e.inverse.obj X âŠ— e.inverse.obj Y)\n  whiskerLeft X _ _ f := e.functor.map (e.inverse.obj X â— e.inverse.map f)\n  whiskerRight f X := e.functor.map (e.inverse.map f â–· e.inverse.obj X)\n  tensorHom f g := e.functor.map (e.inverse.map f âŠ— e.inverse.map g)\n  tensorUnit := e.functor.obj (ğŸ™_ C)\n  associator X Y Z :=\n    e.functor.mapIso\n      (whiskerRightIso (e.unitIso.app _).symm _ â‰ªâ‰«\n        Î±_ (e.inverse.obj X) (e.inverse.obj Y) (e.inverse.obj Z) â‰ªâ‰«\n        whiskerLeftIso _ (e.unitIso.app _))\n  leftUnitor X :=\n    e.functor.mapIso ((whiskerRightIso (e.unitIso.app _).symm _) â‰ªâ‰« Î»_ (e.inverse.obj X)) â‰ªâ‰«\n      e.counitIso.app _\n  rightUnitor X :=\n    e.functor.mapIso ((whiskerLeftIso _ (e.unitIso.app _).symm) â‰ªâ‰« Ï_ (e.inverse.obj X)) â‰ªâ‰«\n      e.counitIso.app _\n\n"}
{"name":"CategoryTheory.Monoidal.transportStruct_tensorHom","module":"Mathlib.CategoryTheory.Monoidal.Transport","initialProofState":"C : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ¹ : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ne : CategoryTheory.Equivalence C D\nXâ‚âœ Yâ‚âœ Xâ‚‚âœ Yâ‚‚âœ : D\nf : Quiver.Hom Xâ‚âœ Yâ‚âœ\ng : Quiver.Hom Xâ‚‚âœ Yâ‚‚âœ\nâŠ¢ Eq (CategoryTheory.MonoidalCategoryStruct.tensorHom f g) (e.functor.map (CategoryTheory.MonoidalCategoryStruct.tensorHom (e.inverse.map f) (e.inverse.map g)))","decl":"/-- Transport a monoidal structure along an equivalence of (plain) categories.\n-/\n@[simps (config := .lemmasOnly)]\ndef transportStruct (e : C â‰Œ D) : MonoidalCategoryStruct.{vâ‚‚} D where\n  tensorObj X Y := e.functor.obj (e.inverse.obj X âŠ— e.inverse.obj Y)\n  whiskerLeft X _ _ f := e.functor.map (e.inverse.obj X â— e.inverse.map f)\n  whiskerRight f X := e.functor.map (e.inverse.map f â–· e.inverse.obj X)\n  tensorHom f g := e.functor.map (e.inverse.map f âŠ— e.inverse.map g)\n  tensorUnit := e.functor.obj (ğŸ™_ C)\n  associator X Y Z :=\n    e.functor.mapIso\n      (whiskerRightIso (e.unitIso.app _).symm _ â‰ªâ‰«\n        Î±_ (e.inverse.obj X) (e.inverse.obj Y) (e.inverse.obj Z) â‰ªâ‰«\n        whiskerLeftIso _ (e.unitIso.app _))\n  leftUnitor X :=\n    e.functor.mapIso ((whiskerRightIso (e.unitIso.app _).symm _) â‰ªâ‰« Î»_ (e.inverse.obj X)) â‰ªâ‰«\n      e.counitIso.app _\n  rightUnitor X :=\n    e.functor.mapIso ((whiskerLeftIso _ (e.unitIso.app _).symm) â‰ªâ‰« Ï_ (e.inverse.obj X)) â‰ªâ‰«\n      e.counitIso.app _\n\n"}
{"name":"CategoryTheory.Monoidal.instIsMonoidalTransportedSymmEquivalenceTransported","module":"Mathlib.CategoryTheory.Monoidal.Transport","initialProofState":"C : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ¹ : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ne : CategoryTheory.Equivalence C D\nâŠ¢ (CategoryTheory.Monoidal.equivalenceTransported e).symm.IsMonoidal","decl":"instance : (equivalenceTransported e).symm.IsMonoidal := by\n  infer_instance\n\n"}
{"name":"CategoryTheory.Monoidal.instIsMonoidalUnitTransportedEquivalenceTransported","module":"Mathlib.CategoryTheory.Monoidal.Transport","initialProofState":"C : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ¹ : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ne : CategoryTheory.Equivalence C D\nâŠ¢ CategoryTheory.NatTrans.IsMonoidal (CategoryTheory.Monoidal.equivalenceTransported e).unit","decl":"/-- The unit isomorphism upgrades to a monoidal isomorphism. -/\ninstance : NatTrans.IsMonoidal (equivalenceTransported e).unit :=\n  inferInstanceAs (NatTrans.IsMonoidal (equivalenceTransported e).symm.counitIso.inv)\n\n"}
{"name":"CategoryTheory.Monoidal.instIsMonoidalTransportedCounitEquivalenceTransported","module":"Mathlib.CategoryTheory.Monoidal.Transport","initialProofState":"C : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ¹ : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ne : CategoryTheory.Equivalence C D\nâŠ¢ CategoryTheory.NatTrans.IsMonoidal (CategoryTheory.Monoidal.equivalenceTransported e).counit","decl":"/-- The counit isomorphism upgrades to a monoidal isomorphism. -/\ninstance : NatTrans.IsMonoidal (equivalenceTransported e).counit :=\n  inferInstanceAs (NatTrans.IsMonoidal (equivalenceTransported e).symm.unitIso.inv)\n\n"}
