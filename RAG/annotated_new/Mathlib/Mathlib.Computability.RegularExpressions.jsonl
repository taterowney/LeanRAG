{"name":"RegularExpression.zero_def","module":"Mathlib.Computability.RegularExpressions","initialProofState":"α : Type u_1\n⊢ Eq RegularExpression.zero 0","decl":"@[simp]\ntheorem zero_def : (zero : RegularExpression α) = 0 :=\n  rfl\n\n"}
{"name":"RegularExpression.one_def","module":"Mathlib.Computability.RegularExpressions","initialProofState":"α : Type u_1\n⊢ Eq RegularExpression.epsilon 1","decl":"@[simp]\ntheorem one_def : (epsilon : RegularExpression α) = 1 :=\n  rfl\n\n"}
{"name":"RegularExpression.plus_def","module":"Mathlib.Computability.RegularExpressions","initialProofState":"α : Type u_1\nP Q : RegularExpression α\n⊢ Eq (P.plus Q) (HAdd.hAdd P Q)","decl":"@[simp]\ntheorem plus_def (P Q : RegularExpression α) : plus P Q = P + Q :=\n  rfl\n\n"}
{"name":"RegularExpression.comp_def","module":"Mathlib.Computability.RegularExpressions","initialProofState":"α : Type u_1\nP Q : RegularExpression α\n⊢ Eq (P.comp Q) (HMul.hMul P Q)","decl":"@[simp]\ntheorem comp_def (P Q : RegularExpression α) : comp P Q = P * Q :=\n  rfl\n\n-- This was renamed to `matches'` during the port of Lean 4 as `matches` is a reserved word.\n"}
{"name":"RegularExpression.matches'_zero","module":"Mathlib.Computability.RegularExpressions","initialProofState":"α : Type u_1\n⊢ Eq (RegularExpression.matches' 0) 0","decl":"@[simp]\ntheorem matches'_zero : (0 : RegularExpression α).matches' = 0 :=\n  rfl\n\n"}
{"name":"RegularExpression.matches'_epsilon","module":"Mathlib.Computability.RegularExpressions","initialProofState":"α : Type u_1\n⊢ Eq (RegularExpression.matches' 1) 1","decl":"@[simp]\ntheorem matches'_epsilon : (1 : RegularExpression α).matches' = 1 :=\n  rfl\n\n"}
{"name":"RegularExpression.matches'_char","module":"Mathlib.Computability.RegularExpressions","initialProofState":"α : Type u_1\na : α\n⊢ Eq (RegularExpression.char a).matches' (Singleton.singleton (List.cons a List.nil))","decl":"@[simp]\ntheorem matches'_char (a : α) : (char a).matches' = {[a]} :=\n  rfl\n\n"}
{"name":"RegularExpression.matches'_add","module":"Mathlib.Computability.RegularExpressions","initialProofState":"α : Type u_1\nP Q : RegularExpression α\n⊢ Eq (HAdd.hAdd P Q).matches' (HAdd.hAdd P.matches' Q.matches')","decl":"@[simp]\ntheorem matches'_add (P Q : RegularExpression α) : (P + Q).matches' = P.matches' + Q.matches' :=\n  rfl\n\n"}
{"name":"RegularExpression.matches'_mul","module":"Mathlib.Computability.RegularExpressions","initialProofState":"α : Type u_1\nP Q : RegularExpression α\n⊢ Eq (HMul.hMul P Q).matches' (HMul.hMul P.matches' Q.matches')","decl":"@[simp]\ntheorem matches'_mul (P Q : RegularExpression α) : (P * Q).matches' = P.matches' * Q.matches' :=\n  rfl\n\n"}
{"name":"RegularExpression.matches'_pow","module":"Mathlib.Computability.RegularExpressions","initialProofState":"α : Type u_1\nP : RegularExpression α\nn : Nat\n⊢ Eq (HPow.hPow P n).matches' (HPow.hPow P.matches' n)","decl":"@[simp]\ntheorem matches'_pow (P : RegularExpression α) : ∀ n : ℕ, (P ^ n).matches' = P.matches' ^ n\n  | 0 => matches'_epsilon\n  | n + 1 => (matches'_mul _ _).trans <| Eq.trans\n      (congrFun (congrArg HMul.hMul (matches'_pow P n)) (matches' P))\n      (pow_succ _ n).symm\n\n"}
{"name":"RegularExpression.matches'_star","module":"Mathlib.Computability.RegularExpressions","initialProofState":"α : Type u_1\nP : RegularExpression α\n⊢ Eq P.star.matches' (KStar.kstar P.matches')","decl":"@[simp]\ntheorem matches'_star (P : RegularExpression α) : P.star.matches' = P.matches'∗ :=\n  rfl\n\n"}
{"name":"RegularExpression.deriv_zero","module":"Mathlib.Computability.RegularExpressions","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na : α\n⊢ Eq (RegularExpression.deriv 0 a) 0","decl":"@[simp]\ntheorem deriv_zero (a : α) : deriv 0 a = 0 :=\n  rfl\n\n"}
{"name":"RegularExpression.deriv_one","module":"Mathlib.Computability.RegularExpressions","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na : α\n⊢ Eq (RegularExpression.deriv 1 a) 0","decl":"@[simp]\ntheorem deriv_one (a : α) : deriv 1 a = 0 :=\n  rfl\n\n"}
{"name":"RegularExpression.deriv_char_self","module":"Mathlib.Computability.RegularExpressions","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na : α\n⊢ Eq ((RegularExpression.char a).deriv a) 1","decl":"@[simp]\ntheorem deriv_char_self (a : α) : deriv (char a) a = 1 :=\n  if_pos rfl\n\n"}
{"name":"RegularExpression.deriv_char_of_ne","module":"Mathlib.Computability.RegularExpressions","initialProofState":"α : Type u_1\na b : α\ninst✝ : DecidableEq α\nh : Ne a b\n⊢ Eq ((RegularExpression.char a).deriv b) 0","decl":"@[simp]\ntheorem deriv_char_of_ne (h : a ≠ b) : deriv (char a) b = 0 :=\n  if_neg h\n\n"}
{"name":"RegularExpression.deriv_add","module":"Mathlib.Computability.RegularExpressions","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nP Q : RegularExpression α\na : α\n⊢ Eq ((HAdd.hAdd P Q).deriv a) (HAdd.hAdd (P.deriv a) (Q.deriv a))","decl":"@[simp]\ntheorem deriv_add (P Q : RegularExpression α) (a : α) : deriv (P + Q) a = deriv P a + deriv Q a :=\n  rfl\n\n"}
{"name":"RegularExpression.deriv_star","module":"Mathlib.Computability.RegularExpressions","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nP : RegularExpression α\na : α\n⊢ Eq (P.star.deriv a) (HMul.hMul (P.deriv a) P.star)","decl":"@[simp]\ntheorem deriv_star (P : RegularExpression α) (a : α) : deriv P.star a = deriv P a * star P :=\n  rfl\n\n"}
{"name":"RegularExpression.zero_rmatch","module":"Mathlib.Computability.RegularExpressions","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nx : List α\n⊢ Eq (RegularExpression.rmatch 0 x) Bool.false","decl":"@[simp]\ntheorem zero_rmatch (x : List α) : rmatch 0 x = false := by\n  induction x <;> simp [rmatch, matchEpsilon, *]\n\n"}
{"name":"RegularExpression.one_rmatch_iff","module":"Mathlib.Computability.RegularExpressions","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nx : List α\n⊢ Iff (Eq (RegularExpression.rmatch 1 x) Bool.true) (Eq x List.nil)","decl":"theorem one_rmatch_iff (x : List α) : rmatch 1 x ↔ x = [] := by\n  induction x <;> simp [rmatch, matchEpsilon, *]\n\n"}
{"name":"RegularExpression.char_rmatch_iff","module":"Mathlib.Computability.RegularExpressions","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na : α\nx : List α\n⊢ Iff (Eq ((RegularExpression.char a).rmatch x) Bool.true) (Eq x (List.cons a List.nil))","decl":"theorem char_rmatch_iff (a : α) (x : List α) : rmatch (char a) x ↔ x = [a] := by\n  cases' x with _ x\n  · exact of_decide_eq_true rfl\n  cases' x with head tail\n  · rw [rmatch, deriv]\n    split_ifs\n    · tauto\n    · simp [List.singleton_inj]; tauto\n  · rw [rmatch, rmatch, deriv]\n    split_ifs with h\n    · simp only [deriv_one, zero_rmatch, cons.injEq, and_false, reduceCtorEq]\n    · simp only [deriv_zero, zero_rmatch, cons.injEq, and_false, reduceCtorEq]\n\n"}
{"name":"RegularExpression.add_rmatch_iff","module":"Mathlib.Computability.RegularExpressions","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nP Q : RegularExpression α\nx : List α\n⊢ Iff (Eq ((HAdd.hAdd P Q).rmatch x) Bool.true) (Or (Eq (P.rmatch x) Bool.true) (Eq (Q.rmatch x) Bool.true))","decl":"theorem add_rmatch_iff (P Q : RegularExpression α) (x : List α) :\n    (P + Q).rmatch x ↔ P.rmatch x ∨ Q.rmatch x := by\n  induction x generalizing P Q with\n  | nil => simp only [rmatch, matchEpsilon, Bool.or_eq_true_iff]\n  | cons _ _ ih =>\n    repeat rw [rmatch]\n    rw [deriv_add]\n    exact ih _ _\n\n"}
{"name":"RegularExpression.mul_rmatch_iff","module":"Mathlib.Computability.RegularExpressions","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nP Q : RegularExpression α\nx : List α\n⊢ Iff (Eq ((HMul.hMul P Q).rmatch x) Bool.true) (Exists fun t => Exists fun u => And (Eq x (HAppend.hAppend t u)) (And (Eq (P.rmatch t) Bool.true) (Eq (Q.rmatch u) Bool.true)))","decl":"theorem mul_rmatch_iff (P Q : RegularExpression α) (x : List α) :\n    (P * Q).rmatch x ↔ ∃ t u : List α, x = t ++ u ∧ P.rmatch t ∧ Q.rmatch u := by\n  induction' x with a x ih generalizing P Q\n  · rw [rmatch]; simp only [matchEpsilon]\n    constructor\n    · intro h\n      refine ⟨[], [], rfl, ?_⟩\n      rw [rmatch, rmatch]\n      rwa [Bool.and_eq_true_iff] at h\n    · rintro ⟨t, u, h₁, h₂⟩\n      cases' List.append_eq_nil_iff.1 h₁.symm with ht hu\n      subst ht\n      subst hu\n      repeat rw [rmatch] at h₂\n      simp [h₂]\n  · rw [rmatch]; simp only [deriv]\n    split_ifs with hepsilon\n    · rw [add_rmatch_iff, ih]\n      constructor\n      · rintro (⟨t, u, _⟩ | h)\n        · exact ⟨a :: t, u, by tauto⟩\n        · exact ⟨[], a :: x, rfl, hepsilon, h⟩\n      · rintro ⟨t, u, h, hP, hQ⟩\n        cases' t with b t\n        · right\n          rw [List.nil_append] at h\n          rw [← h] at hQ\n          exact hQ\n        · left\n          rw [List.cons_append, List.cons_eq_cons] at h\n          refine ⟨t, u, h.2, ?_, hQ⟩\n          rw [rmatch] at hP\n          convert hP\n          exact h.1\n    · rw [ih]\n      constructor <;> rintro ⟨t, u, h, hP, hQ⟩\n      · exact ⟨a :: t, u, by tauto⟩\n      · cases' t with b t\n        · contradiction\n        · rw [List.cons_append, List.cons_eq_cons] at h\n          refine ⟨t, u, h.2, ?_, hQ⟩\n          rw [rmatch] at hP\n          convert hP\n          exact h.1\n\n"}
{"name":"RegularExpression.star_rmatch_iff","module":"Mathlib.Computability.RegularExpressions","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nP : RegularExpression α\nx : List α\n⊢ Iff (Eq (P.star.rmatch x) Bool.true) (Exists fun S => And (Eq x S.flatten) (∀ (t : List α), Membership.mem S t → And (Ne t List.nil) (Eq (P.rmatch t) Bool.true)))","decl":"theorem star_rmatch_iff (P : RegularExpression α) :\n    ∀ x : List α, (star P).rmatch x ↔ ∃ S : List (List α), x\n          = S.flatten ∧ ∀ t ∈ S, t ≠ [] ∧ P.rmatch t :=\n  fun x => by\n    have IH := fun t (_h : List.length t < List.length x) => star_rmatch_iff P t\n    clear star_rmatch_iff\n    constructor\n    · cases' x with a x\n      · intro _h\n        use []; dsimp; tauto\n      · rw [rmatch, deriv, mul_rmatch_iff]\n        rintro ⟨t, u, hs, ht, hu⟩\n        have hwf : u.length < (List.cons a x).length := by\n          rw [hs, List.length_cons, List.length_append]\n          omega\n        rw [IH _ hwf] at hu\n        rcases hu with ⟨S', hsum, helem⟩\n        use (a :: t) :: S'\n        constructor\n        · simp [hs, hsum]\n        · intro t' ht'\n          cases ht' with\n          | head ht' =>\n            simp only [ne_eq, not_false_iff, true_and, rmatch, reduceCtorEq]\n            exact ht\n          | tail _ ht' => exact helem t' ht'\n    · rintro ⟨S, hsum, helem⟩\n      cases' x with a x\n      · rfl\n      · rw [rmatch, deriv, mul_rmatch_iff]\n        cases' S with t' U\n        · exact ⟨[], [], by tauto⟩\n        · cases' t' with b t\n          · simp only [forall_eq_or_imp, List.mem_cons] at helem\n            simp only [eq_self_iff_true, not_true, Ne, false_and] at helem\n          simp only [List.flatten, List.cons_append, List.cons_eq_cons] at hsum\n          refine ⟨t, U.flatten, hsum.2, ?_, ?_⟩\n          · specialize helem (b :: t) (by simp)\n            rw [rmatch] at helem\n            convert helem.2\n            exact hsum.1\n          · have hwf : U.flatten.length < (List.cons a x).length := by\n              rw [hsum.1, hsum.2]\n              simp only [List.length_append, List.length_flatten, List.length]\n              omega\n            rw [IH _ hwf]\n            refine ⟨U, rfl, fun t h => helem t ?_⟩\n            right\n            assumption\n  termination_by t => (P, t.length)\n\n"}
{"name":"RegularExpression.rmatch_iff_matches'","module":"Mathlib.Computability.RegularExpressions","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nP : RegularExpression α\nx : List α\n⊢ Iff (Eq (P.rmatch x) Bool.true) (Membership.mem P.matches' x)","decl":"@[simp]\ntheorem rmatch_iff_matches' (P : RegularExpression α) (x : List α) :\n    P.rmatch x ↔ x ∈ P.matches' := by\n  induction P generalizing x with\n  | zero =>\n    rw [zero_def, zero_rmatch]\n    tauto\n  | epsilon =>\n    rw [one_def, one_rmatch_iff, matches'_epsilon, Language.mem_one]\n  | char =>\n    rw [char_rmatch_iff]\n    rfl\n  | plus _ _ ih₁ ih₂ =>\n    rw [plus_def, add_rmatch_iff, ih₁, ih₂]\n    rfl\n  | comp P Q ih₁ ih₂ =>\n    simp only [comp_def, mul_rmatch_iff, matches'_mul, Language.mem_mul, *]\n    tauto\n  | star _ ih =>\n    simp only [star_rmatch_iff, matches'_star, ih, Language.mem_kstar_iff_exists_nonempty, and_comm]\n\n"}
{"name":"RegularExpression.map_pow","module":"Mathlib.Computability.RegularExpressions","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nP : RegularExpression α\nn : Nat\n⊢ Eq (RegularExpression.map f (HPow.hPow P n)) (HPow.hPow (RegularExpression.map f P) n)","decl":"@[simp]\nprotected theorem map_pow (f : α → β) (P : RegularExpression α) :\n    ∀ n : ℕ, map f (P ^ n) = map f P ^ n\n  | 0 => by unfold map; rfl\n  | n + 1 => (congr_arg (· * map f P) (RegularExpression.map_pow f P n) :)\n\n"}
{"name":"RegularExpression.map_id","module":"Mathlib.Computability.RegularExpressions","initialProofState":"α : Type u_1\nP : RegularExpression α\n⊢ Eq (RegularExpression.map id P) P","decl":"@[simp]\ntheorem map_id : ∀ P : RegularExpression α, P.map id = P\n  | 0 => rfl\n  | 1 => rfl\n  | char _ => rfl\n  | R + S => by simp_rw [map, map_id]\n  | comp R S => by simp_rw [map, map_id]; rfl\n  | star R => by simp_rw [map, map_id]\n\n"}
{"name":"RegularExpression.map_map","module":"Mathlib.Computability.RegularExpressions","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ng : β → γ\nf : α → β\nP : RegularExpression α\n⊢ Eq (RegularExpression.map g (RegularExpression.map f P)) (RegularExpression.map (Function.comp g f) P)","decl":"@[simp]\ntheorem map_map (g : β → γ) (f : α → β) : ∀ P : RegularExpression α, (P.map f).map g = P.map (g ∘ f)\n  | 0 => rfl\n  | 1 => rfl\n  | char _ => rfl\n  | R + S => by simp only [map, Function.comp_apply, map_map]\n  | comp R S => by simp only [map, Function.comp_apply, map_map]\n  | star R => by simp only [map, Function.comp_apply, map_map]\n\n"}
{"name":"RegularExpression.matches'_map","module":"Mathlib.Computability.RegularExpressions","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nP : RegularExpression α\n⊢ Eq (RegularExpression.map f P).matches' ((Language.map f) P.matches')","decl":"/-- The language of the map is the map of the language. -/\n@[simp]\ntheorem matches'_map (f : α → β) :\n    ∀ P : RegularExpression α, (P.map f).matches' = Language.map f P.matches'\n  | 0 => (map_zero _).symm\n  | 1 => (map_one _).symm\n  | char a => by\n    rw [eq_comm]\n    exact image_singleton\n  | R + S => by simp only [matches'_map, map, matches'_add, map_add]\n  | comp R S => by simp [matches'_map]\n  | star R => by simp [matches'_map]\n\n"}
