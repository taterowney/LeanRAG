{"name":"exteriorPower.toTensorPower_apply_ιMulti","module":"Mathlib.LinearAlgebra.ExteriorPower.Pairing","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nn : Nat\nv : Fin n → M\n⊢ Eq ((exteriorPower.toTensorPower R M n) ((exteriorPower.ιMulti R n) v)) (Finset.univ.sum fun σ => HSMul.hSMul (Equiv.Perm.sign σ) ((PiTensorProduct.tprod R) fun i => v (σ i)))","decl":"variable {M} in\nopen Equiv in\n@[simp]\nlemma toTensorPower_apply_ιMulti {n : ℕ} (v : Fin n → M) :\n    toTensorPower R M n (ιMulti R n v) =\n      ∑ σ : Perm (Fin n), Perm.sign σ • PiTensorProduct.tprod R (fun i ↦ v (σ i)) := by\n  dsimp [toTensorPower]\n  simp only [alternatingMapLinearEquiv_apply_ιMulti,\n    MultilinearMap.alternatization_apply, MultilinearMap.domDomCongr_apply]\n\n"}
{"name":"exteriorPower.alternatingMapToDual_apply_ιMulti","module":"Mathlib.LinearAlgebra.ExteriorPower.Pairing","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nn : Nat\nf : Fin n → Module.Dual R M\nv : Fin n → M\n⊢ Eq (((exteriorPower.alternatingMapToDual R M n) f) ((exteriorPower.ιMulti R n) v)) (Matrix.of fun i j => (f j) (v i)).det","decl":"variable {R M} in\nopen Equiv in\n@[simp]\ntheorem alternatingMapToDual_apply_ιMulti {n : ℕ}\n    (f : (_ : Fin n) → Module.Dual R M) (v : Fin n → M) :\n    alternatingMapToDual R M n f (ιMulti _ _ v) =\n      Matrix.det (n := Fin n) (.of (fun i j ↦ f j (v i))) := by\n  simp [alternatingMapToDual, Matrix.det_apply]\n\n"}
{"name":"exteriorPower.pairingDual_ιMulti_ιMulti","module":"Mathlib.LinearAlgebra.ExteriorPower.Pairing","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nn : Nat\nf : Fin n → Module.Dual R M\nv : Fin n → M\n⊢ Eq (((exteriorPower.pairingDual R M n) ((exteriorPower.ιMulti R n) f)) ((exteriorPower.ιMulti R n) v)) (Matrix.of fun i j => (f j) (v i)).det","decl":"variable {R M} in\nopen Equiv in\n@[simp]\nlemma pairingDual_ιMulti_ιMulti {n : ℕ} (f : (_ : Fin n) → Module.Dual R M) (v : Fin n → M) :\n    pairingDual R M n (ιMulti _ _ f) (ιMulti _ _ v) =\n      Matrix.det (n := Fin n) (.of (fun i j ↦ f j (v i))) := by\n  simp [pairingDual]\n\n\n"}
{"name":"exteriorPower.pairingDual_apply_apply_eq_one","module":"Mathlib.LinearAlgebra.ExteriorPower.Pairing","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝³ : CommRing R\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\nι : Type u_3\ninst✝ : LinearOrder ι\nx : ι → M\nf : ι → Module.Dual R M\nh₁ : ∀ (i : ι), Eq ((f i) (x i)) 1\nh₀ : ∀ ⦃i j : ι⦄, Ne i j → Eq ((f i) (x j)) 0\nn : Nat\na : OrderEmbedding (Fin n) ι\n⊢ Eq (((exteriorPower.pairingDual R M n) ((exteriorPower.ιMulti R n) (Function.comp f ⇑a))) ((exteriorPower.ιMulti R n) (Function.comp x ⇑a))) 1","decl":"include h₁ h₀ in\nlemma pairingDual_apply_apply_eq_one (a : Fin n ↪o ι) :\n    pairingDual R M n (ιMulti _ _ (f ∘ a)) (ιMulti _ _ (x ∘ a)) = 1 := by\n  simp only [pairingDual_ιMulti_ιMulti, Function.comp_apply]\n  rw [← Matrix.det_one (n := Fin n)]\n  congr\n  ext i j\n  dsimp\n  by_cases hij : i = j\n  · subst hij\n    simp only [h₁, Matrix.one_apply_eq]\n  · rw [h₀ (by simpa using Ne.symm hij), Matrix.one_apply_ne hij]\n\n"}
{"name":"exteriorPower.pairingDual_apply_apply_eq_one_zero","module":"Mathlib.LinearAlgebra.ExteriorPower.Pairing","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝³ : CommRing R\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\nι : Type u_3\ninst✝ : LinearOrder ι\nx : ι → M\nf : ι → Module.Dual R M\nh₀ : ∀ ⦃i j : ι⦄, Ne i j → Eq ((f i) (x j)) 0\nn : Nat\na b : OrderEmbedding (Fin n) ι\nh : Ne a b\n⊢ Eq (((exteriorPower.pairingDual R M n) ((exteriorPower.ιMulti R n) (Function.comp f ⇑a))) ((exteriorPower.ιMulti R n) (Function.comp x ⇑b))) 0","decl":"include h₀ in\nlemma pairingDual_apply_apply_eq_one_zero (a b : Fin n ↪o ι) (h : a ≠ b) :\n    pairingDual R M n (ιMulti _ _ (f ∘ a)) (ιMulti _ _ (x ∘ b)) = 0 := by\n  simp only [pairingDual_ιMulti_ιMulti, Function.comp_apply, Matrix.det_apply]\n  refine Finset.sum_eq_zero (fun σ _ ↦ ?_)\n  simp only [Matrix.of_apply, smul_eq_iff_eq_inv_smul, smul_zero]\n  by_contra h'\n  apply h\n  have : a = b ∘ σ := by\n    ext i\n    by_contra hi\n    exact h' (Finset.prod_eq_zero (i := i) (by simp) (h₀ hi))\n  have hσ : Monotone σ := fun i j hij ↦ by\n    have h'' := congr_fun this\n    dsimp at h''\n    rw [← a.map_rel_iff] at hij\n    simpa only [← b.map_rel_iff, ← h'']\n  have hσ' : Monotone σ.symm := fun i j hij ↦ by\n    obtain ⟨i, rfl⟩ := σ.surjective i\n    obtain ⟨j, rfl⟩ := σ.surjective j\n    simp only [Equiv.symm_apply_apply]\n    by_contra! h\n    obtain rfl : i = j := σ.injective (le_antisymm hij (hσ h.le))\n    simp only [lt_self_iff_false] at h\n  obtain rfl : σ = 1 := by\n    ext i : 1\n    exact DFunLike.congr_fun (Subsingleton.elim (σ.toOrderIso hσ hσ') (OrderIso.refl _)) i\n  ext\n  apply congr_fun this\n\n"}
