{"name":"TensorProduct.exists_multiset","module":"Mathlib.LinearAlgebra.TensorProduct.Finiteness","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_3\ninst✝⁴ : CommSemiring R\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid N\ninst✝¹ : Module R M\ninst✝ : Module R N\nx : TensorProduct R M N\n⊢ Exists fun S => Eq x (Multiset.map (fun i => TensorProduct.tmul R i.1 i.2) S).sum","decl":"/-- For any element `x` of `M ⊗[R] N`, there exists a (finite) multiset `{ (m_i, n_i) }`\nof `M × N`, such that `x` is equal to the sum of `m_i ⊗ₜ[R] n_i`. -/\ntheorem exists_multiset (x : M ⊗[R] N) :\n    ∃ S : Multiset (M × N), x = (S.map fun i ↦ i.1 ⊗ₜ[R] i.2).sum := by\n  induction x with\n  | zero => exact ⟨0, by simp⟩\n  | tmul x y => exact ⟨{(x, y)}, by simp⟩\n  | add x y hx hy =>\n    obtain ⟨Sx, hx⟩ := hx\n    obtain ⟨Sy, hy⟩ := hy\n    exact ⟨Sx + Sy, by rw [Multiset.map_add, Multiset.sum_add, hx, hy]⟩\n\n"}
{"name":"TensorProduct.exists_finsupp_left","module":"Mathlib.LinearAlgebra.TensorProduct.Finiteness","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_3\ninst✝⁴ : CommSemiring R\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid N\ninst✝¹ : Module R M\ninst✝ : Module R N\nx : TensorProduct R M N\n⊢ Exists fun S => Eq x (S.sum fun m n => TensorProduct.tmul R m n)","decl":"/-- For any element `x` of `M ⊗[R] N`, there exists a finite subset `{ (m_i, n_i) }`\nof `M × N` such that each `m_i` is distinct (we represent it as an element of `M →₀ N`),\nsuch that `x` is equal to the sum of `m_i ⊗ₜ[R] n_i`. -/\ntheorem exists_finsupp_left (x : M ⊗[R] N) :\n    ∃ S : M →₀ N, x = S.sum fun m n ↦ m ⊗ₜ[R] n := by\n  induction x with\n  | zero => exact ⟨0, by simp⟩\n  | tmul x y => exact ⟨Finsupp.single x y, by simp⟩\n  | add x y hx hy =>\n    obtain ⟨Sx, hx⟩ := hx\n    obtain ⟨Sy, hy⟩ := hy\n    use Sx + Sy\n    rw [hx, hy]\n    exact (Finsupp.sum_add_index' (by simp) TensorProduct.tmul_add).symm\n\n"}
{"name":"TensorProduct.exists_finsupp_right","module":"Mathlib.LinearAlgebra.TensorProduct.Finiteness","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_3\ninst✝⁴ : CommSemiring R\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid N\ninst✝¹ : Module R M\ninst✝ : Module R N\nx : TensorProduct R M N\n⊢ Exists fun S => Eq x (S.sum fun n m => TensorProduct.tmul R m n)","decl":"/-- For any element `x` of `M ⊗[R] N`, there exists a finite subset `{ (m_i, n_i) }`\nof `M × N` such that each `n_i` is distinct (we represent it as an element of `N →₀ M`),\nsuch that `x` is equal to the sum of `m_i ⊗ₜ[R] n_i`. -/\ntheorem exists_finsupp_right (x : M ⊗[R] N) :\n    ∃ S : N →₀ M, x = S.sum fun n m ↦ m ⊗ₜ[R] n := by\n  obtain ⟨S, h⟩ := exists_finsupp_left (TensorProduct.comm R M N x)\n  refine ⟨S, (TensorProduct.comm R M N).injective ?_⟩\n  simp_rw [h, Finsupp.sum, map_sum, comm_tmul]\n\n"}
{"name":"TensorProduct.exists_finset","module":"Mathlib.LinearAlgebra.TensorProduct.Finiteness","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_3\ninst✝⁴ : CommSemiring R\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid N\ninst✝¹ : Module R M\ninst✝ : Module R N\nx : TensorProduct R M N\n⊢ Exists fun S => Eq x (S.sum fun i => TensorProduct.tmul R i.1 i.2)","decl":"/-- For any element `x` of `M ⊗[R] N`, there exists a finite subset `{ (m_i, n_i) }`\nof `M × N`, such that `x` is equal to the sum of `m_i ⊗ₜ[R] n_i`. -/\ntheorem exists_finset (x : M ⊗[R] N) :\n    ∃ S : Finset (M × N), x = S.sum fun i ↦ i.1 ⊗ₜ[R] i.2 := by\n  obtain ⟨S, h⟩ := exists_finsupp_left x\n  use S.graph\n  rw [h, Finsupp.sum]\n  apply Finset.sum_nbij' (fun m ↦ ⟨m, S m⟩) Prod.fst <;> simp\n\n"}
{"name":"TensorProduct.exists_finite_submodule_of_finite","module":"Mathlib.LinearAlgebra.TensorProduct.Finiteness","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_3\ninst✝⁴ : CommSemiring R\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid N\ninst✝¹ : Module R M\ninst✝ : Module R N\ns : Set (TensorProduct R M N)\nhs : s.Finite\n⊢ Exists fun M' => Exists fun N' => And (Module.Finite R (Subtype fun x => Membership.mem M' x)) (And (Module.Finite R (Subtype fun x => Membership.mem N' x)) (HasSubset.Subset s ↑(LinearMap.range (TensorProduct.mapIncl M' N'))))","decl":"/-- For a finite subset `s` of `M ⊗[R] N`, there are finitely generated\nsubmodules `M'` and `N'` of `M` and `N`, respectively, such that `s` is contained in the image\nof `M' ⊗[R] N'` in `M ⊗[R] N`. -/\ntheorem exists_finite_submodule_of_finite (s : Set (M ⊗[R] N)) (hs : s.Finite) :\n    ∃ (M' : Submodule R M) (N' : Submodule R N), Module.Finite R M' ∧ Module.Finite R N' ∧\n      s ⊆ LinearMap.range (mapIncl M' N') := by\n  simp_rw [Module.Finite.iff_fg]\n  refine hs.induction_on _ ⟨_, _, fg_bot, fg_bot, Set.empty_subset _⟩ ?_\n  rintro a s - - ⟨M', N', hM', hN', h⟩\n  refine TensorProduct.induction_on a ?_ (fun x y ↦ ?_) fun x y hx hy ↦ ?_\n  · exact ⟨M', N', hM', hN', Set.insert_subset (zero_mem _) h⟩\n  · refine ⟨_, _, hM'.sup (fg_span_singleton x),\n      hN'.sup (fg_span_singleton y), Set.insert_subset ?_ fun z hz ↦ ?_⟩\n    · exact ⟨⟨x, mem_sup_right (mem_span_singleton_self x)⟩ ⊗ₜ\n        ⟨y, mem_sup_right (mem_span_singleton_self y)⟩, rfl⟩\n    · exact range_mapIncl_mono le_sup_left le_sup_left (h hz)\n  · obtain ⟨M₁', N₁', hM₁', hN₁', h₁⟩ := hx\n    obtain ⟨M₂', N₂', hM₂', hN₂', h₂⟩ := hy\n    refine ⟨_, _, hM₁'.sup hM₂', hN₁'.sup hN₂', Set.insert_subset (add_mem ?_ ?_) fun z hz ↦ ?_⟩\n    · exact range_mapIncl_mono le_sup_left le_sup_left (h₁ (Set.mem_insert x s))\n    · exact range_mapIncl_mono le_sup_right le_sup_right (h₂ (Set.mem_insert y s))\n    · exact range_mapIncl_mono le_sup_left le_sup_left (h₁ (Set.subset_insert x s hz))\n\n"}
{"name":"TensorProduct.exists_finite_submodule_left_of_finite","module":"Mathlib.LinearAlgebra.TensorProduct.Finiteness","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_3\ninst✝⁴ : CommSemiring R\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid N\ninst✝¹ : Module R M\ninst✝ : Module R N\ns : Set (TensorProduct R M N)\nhs : s.Finite\n⊢ Exists fun M' => And (Module.Finite R (Subtype fun x => Membership.mem M' x)) (HasSubset.Subset s ↑(LinearMap.range (LinearMap.rTensor N M'.subtype)))","decl":"/-- For a finite subset `s` of `M ⊗[R] N`, there exists a finitely generated\nsubmodule `M'` of `M`, such that `s` is contained in the image\nof `M' ⊗[R] N` in `M ⊗[R] N`. -/\ntheorem exists_finite_submodule_left_of_finite (s : Set (M ⊗[R] N)) (hs : s.Finite) :\n    ∃ M' : Submodule R M, Module.Finite R M' ∧ s ⊆ LinearMap.range (M'.subtype.rTensor N) := by\n  obtain ⟨M', _, hfin, _, h⟩ := exists_finite_submodule_of_finite s hs\n  refine ⟨M', hfin, ?_⟩\n  rw [mapIncl, ← LinearMap.rTensor_comp_lTensor] at h\n  exact h.trans (LinearMap.range_comp_le_range _ _)\n\n"}
{"name":"TensorProduct.exists_finite_submodule_right_of_finite","module":"Mathlib.LinearAlgebra.TensorProduct.Finiteness","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_3\ninst✝⁴ : CommSemiring R\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid N\ninst✝¹ : Module R M\ninst✝ : Module R N\ns : Set (TensorProduct R M N)\nhs : s.Finite\n⊢ Exists fun N' => And (Module.Finite R (Subtype fun x => Membership.mem N' x)) (HasSubset.Subset s ↑(LinearMap.range (LinearMap.lTensor M N'.subtype)))","decl":"/-- For a finite subset `s` of `M ⊗[R] N`, there exists a finitely generated\nsubmodule `N'` of `N`, such that `s` is contained in the image\nof `M ⊗[R] N'` in `M ⊗[R] N`. -/\ntheorem exists_finite_submodule_right_of_finite (s : Set (M ⊗[R] N)) (hs : s.Finite) :\n    ∃ N' : Submodule R N, Module.Finite R N' ∧ s ⊆ LinearMap.range (N'.subtype.lTensor M) := by\n  obtain ⟨_, N', _, hfin, h⟩ := exists_finite_submodule_of_finite s hs\n  refine ⟨N', hfin, ?_⟩\n  rw [mapIncl, ← LinearMap.lTensor_comp_rTensor] at h\n  exact h.trans (LinearMap.range_comp_le_range _ _)\n\n"}
{"name":"TensorProduct.exists_finite_submodule_of_finite'","module":"Mathlib.LinearAlgebra.TensorProduct.Finiteness","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_3\ninst✝⁴ : CommSemiring R\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid N\ninst✝¹ : Module R M\ninst✝ : Module R N\nM₁ : Submodule R M\nN₁ : Submodule R N\ns : Set (TensorProduct R (Subtype fun x => Membership.mem M₁ x) (Subtype fun x => Membership.mem N₁ x))\nhs : s.Finite\n⊢ Exists fun M' => Exists fun N' => Exists fun hM => Exists fun hN => And (Module.Finite R (Subtype fun x => Membership.mem M' x)) (And (Module.Finite R (Subtype fun x => Membership.mem N' x)) (HasSubset.Subset s ↑(LinearMap.range (TensorProduct.map (Submodule.inclusion hM) (Submodule.inclusion hN)))))","decl":"/-- Variation of `TensorProduct.exists_finite_submodule_of_finite` where `M` and `N` are\nalready submodules. -/\ntheorem exists_finite_submodule_of_finite' (s : Set (M₁ ⊗[R] N₁)) (hs : s.Finite) :\n    ∃ (M' : Submodule R M) (N' : Submodule R N) (hM : M' ≤ M₁) (hN : N' ≤ N₁),\n      Module.Finite R M' ∧ Module.Finite R N' ∧\n        s ⊆ LinearMap.range (TensorProduct.map (inclusion hM) (inclusion hN)) := by\n  obtain ⟨M', N', _, _, h⟩ := exists_finite_submodule_of_finite s hs\n  have hM := map_subtype_le M₁ M'\n  have hN := map_subtype_le N₁ N'\n  refine ⟨_, _, hM, hN, .map _ _, .map _ _, ?_⟩\n  rw [mapIncl,\n    show M'.subtype = inclusion hM ∘ₗ M₁.subtype.submoduleMap M' by ext; simp,\n    show N'.subtype = inclusion hN ∘ₗ N₁.subtype.submoduleMap N' by ext; simp,\n    map_comp] at h\n  exact h.trans (LinearMap.range_comp_le_range _ _)\n\n"}
{"name":"TensorProduct.exists_finite_submodule_left_of_finite'","module":"Mathlib.LinearAlgebra.TensorProduct.Finiteness","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_3\ninst✝⁴ : CommSemiring R\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid N\ninst✝¹ : Module R M\ninst✝ : Module R N\nM₁ : Submodule R M\nN₁ : Submodule R N\ns : Set (TensorProduct R (Subtype fun x => Membership.mem M₁ x) (Subtype fun x => Membership.mem N₁ x))\nhs : s.Finite\n⊢ Exists fun M' => Exists fun hM => And (Module.Finite R (Subtype fun x => Membership.mem M' x)) (HasSubset.Subset s ↑(LinearMap.range (LinearMap.rTensor (Subtype fun x => Membership.mem N₁ x) (Submodule.inclusion hM))))","decl":"/-- Variation of `TensorProduct.exists_finite_submodule_left_of_finite` where `M` and `N` are\nalready submodules. -/\ntheorem exists_finite_submodule_left_of_finite' (s : Set (M₁ ⊗[R] N₁)) (hs : s.Finite) :\n    ∃ (M' : Submodule R M) (hM : M' ≤ M₁), Module.Finite R M' ∧\n      s ⊆ LinearMap.range ((inclusion hM).rTensor N₁) := by\n  obtain ⟨M', _, hM, _, hfin, _, h⟩ := exists_finite_submodule_of_finite' s hs\n  refine ⟨M', hM, hfin, ?_⟩\n  rw [← LinearMap.rTensor_comp_lTensor] at h\n  exact h.trans (LinearMap.range_comp_le_range _ _)\n\n"}
{"name":"TensorProduct.exists_finite_submodule_right_of_finite'","module":"Mathlib.LinearAlgebra.TensorProduct.Finiteness","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_3\ninst✝⁴ : CommSemiring R\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid N\ninst✝¹ : Module R M\ninst✝ : Module R N\nM₁ : Submodule R M\nN₁ : Submodule R N\ns : Set (TensorProduct R (Subtype fun x => Membership.mem M₁ x) (Subtype fun x => Membership.mem N₁ x))\nhs : s.Finite\n⊢ Exists fun N' => Exists fun hN => And (Module.Finite R (Subtype fun x => Membership.mem N' x)) (HasSubset.Subset s ↑(LinearMap.range (LinearMap.lTensor (Subtype fun x => Membership.mem M₁ x) (Submodule.inclusion hN))))","decl":"/-- Variation of `TensorProduct.exists_finite_submodule_right_of_finite` where `M` and `N` are\nalready submodules. -/\ntheorem exists_finite_submodule_right_of_finite' (s : Set (M₁ ⊗[R] N₁)) (hs : s.Finite) :\n    ∃ (N' : Submodule R N) (hN : N' ≤ N₁), Module.Finite R N' ∧\n      s ⊆ LinearMap.range ((inclusion hN).lTensor M₁) := by\n  obtain ⟨_, N', _, hN, _, hfin, h⟩ := exists_finite_submodule_of_finite' s hs\n  refine ⟨N', hN, hfin, ?_⟩\n  rw [← LinearMap.lTensor_comp_rTensor] at h\n  exact h.trans (LinearMap.range_comp_le_range _ _)\n\n"}
