{"name":"MonoidHom.coe_mgraph","module":"Mathlib.Algebra.Group.Graph","initialProofState":"G : Type u_1\nH : Type u_2\ninst✝¹ : Monoid G\ninst✝ : Monoid H\nf : MonoidHom G H\n⊢ Eq (↑f.mgraph) (setOf fun x => Eq (f x.1) x.2)","decl":"attribute [simps! coe] mgraph\n"}
{"name":"AddMonoidHom.coe_mgraph","module":"Mathlib.Algebra.Group.Graph","initialProofState":"G : Type u_1\nH : Type u_2\ninst✝¹ : AddMonoid G\ninst✝ : AddMonoid H\nf : AddMonoidHom G H\n⊢ Eq (↑f.mgraph) (setOf fun x => Eq (f x.1) x.2)","decl":"attribute [simps! coe] AddMonoidHom.mgraph\n"}
{"name":"MonoidHom.mem_mgraph","module":"Mathlib.Algebra.Group.Graph","initialProofState":"G : Type u_1\nH : Type u_2\ninst✝¹ : Monoid G\ninst✝ : Monoid H\nf : MonoidHom G H\nx : Prod G H\n⊢ Iff (Membership.mem f.mgraph x) (Eq (f x.1) x.2)","decl":"@[to_additive (attr := simp)]\nlemma mem_mgraph {f : G →* H} {x : G × H} : x ∈ f.mgraph ↔ f x.1 = x.2 := .rfl\n\n"}
{"name":"AddMonoidHom.mem_mgraph","module":"Mathlib.Algebra.Group.Graph","initialProofState":"G : Type u_1\nH : Type u_2\ninst✝¹ : AddMonoid G\ninst✝ : AddMonoid H\nf : AddMonoidHom G H\nx : Prod G H\n⊢ Iff (Membership.mem f.mgraph x) (Eq (f x.1) x.2)","decl":"@[to_additive (attr := simp)]\nlemma mem_mgraph {f : G →* H} {x : G × H} : x ∈ f.mgraph ↔ f x.1 = x.2 := .rfl\n\n"}
{"name":"MonoidHom.mgraph_eq_mrange_prod","module":"Mathlib.Algebra.Group.Graph","initialProofState":"G : Type u_1\nH : Type u_2\ninst✝¹ : Monoid G\ninst✝ : Monoid H\nf : MonoidHom G H\n⊢ Eq f.mgraph (MonoidHom.mrange ((MonoidHom.id G).prod f))","decl":"@[to_additive]\nlemma mgraph_eq_mrange_prod (f : G →* H) : f.mgraph = mrange ((id _).prod f) := by aesop\n\n"}
{"name":"AddMonoidHom.mgraph_eq_mrange_sum","module":"Mathlib.Algebra.Group.Graph","initialProofState":"G : Type u_1\nH : Type u_2\ninst✝¹ : AddMonoid G\ninst✝ : AddMonoid H\nf : AddMonoidHom G H\n⊢ Eq f.mgraph (AddMonoidHom.mrange ((AddMonoidHom.id G).prod f))","decl":"@[to_additive]\nlemma mgraph_eq_mrange_prod (f : G →* H) : f.mgraph = mrange ((id _).prod f) := by aesop\n\n"}
{"name":"MonoidHom.exists_mrange_eq_mgraph","module":"Mathlib.Algebra.Group.Graph","initialProofState":"G : Type u_1\nH : Type u_2\nI : Type u_3\ninst✝² : Monoid G\ninst✝¹ : Monoid H\ninst✝ : Monoid I\nf : MonoidHom G (Prod H I)\nhf₁ : Function.Surjective (Function.comp Prod.fst ⇑f)\nhf : ∀ (g₁ g₂ : G), Eq (f g₁).1 (f g₂).1 → Eq (f g₁).2 (f g₂).2\n⊢ Exists fun f' => Eq (MonoidHom.mrange f) f'.mgraph","decl":"/-- **Vertical line test** for monoid homomorphisms.\n\nLet `f : G → H × I` be a homomorphism to a product of monoids. Assume that `f` is surjective on the\nfirst factor and that the image of `f` intersects every \"vertical line\" `{(h, i) | i : I}` at most\nonce. Then the image of `f` is the graph of some monoid homomorphism `f' : H → I`. -/\n@[to_additive \"**Vertical line test** for monoid homomorphisms.\n\nLet `f : G → H × I` be a homomorphism to a product of monoids. Assume that `f` is surjective on the\nfirst factor and that the image of `f` intersects every \\\"vertical line\\\" `{(h, i) | i : I}` at most\nonce. Then the image of `f` is the graph of some monoid homomorphism `f' : H → I`.\"]\nlemma exists_mrange_eq_mgraph {f : G →* H × I} (hf₁ : Surjective (Prod.fst ∘ f))\n    (hf : ∀ g₁ g₂, (f g₁).1 = (f g₂).1 → (f g₁).2 = (f g₂).2) :\n    ∃ f' : H →* I, mrange f = f'.mgraph := by\n  obtain ⟨f', hf'⟩ := exists_range_eq_graphOn_univ hf₁ hf\n  simp only [Set.ext_iff, Set.mem_range, mem_graphOn, mem_univ, true_and, Prod.forall] at hf'\n  use\n  { toFun := f'\n    map_one' := (hf' _ _).1 ⟨1, map_one _⟩\n    map_mul' := by\n      simp_rw [hf₁.forall]\n      rintro g₁ g₂\n      exact (hf' _ _).1 ⟨g₁ * g₂, by simp [Prod.ext_iff, (hf' (f _).1 _).1 ⟨_, rfl⟩]⟩ }\n  simpa [SetLike.ext_iff] using hf'\n\n"}
{"name":"AddMonoidHom.exists_mrange_eq_mgraph","module":"Mathlib.Algebra.Group.Graph","initialProofState":"G : Type u_1\nH : Type u_2\nI : Type u_3\ninst✝² : AddMonoid G\ninst✝¹ : AddMonoid H\ninst✝ : AddMonoid I\nf : AddMonoidHom G (Prod H I)\nhf₁ : Function.Surjective (Function.comp Prod.fst ⇑f)\nhf : ∀ (g₁ g₂ : G), Eq (f g₁).1 (f g₂).1 → Eq (f g₁).2 (f g₂).2\n⊢ Exists fun f' => Eq (AddMonoidHom.mrange f) f'.mgraph","decl":"/-- **Vertical line test** for monoid homomorphisms.\n\nLet `f : G → H × I` be a homomorphism to a product of monoids. Assume that `f` is surjective on the\nfirst factor and that the image of `f` intersects every \"vertical line\" `{(h, i) | i : I}` at most\nonce. Then the image of `f` is the graph of some monoid homomorphism `f' : H → I`. -/\n@[to_additive \"**Vertical line test** for monoid homomorphisms.\n\nLet `f : G → H × I` be a homomorphism to a product of monoids. Assume that `f` is surjective on the\nfirst factor and that the image of `f` intersects every \\\"vertical line\\\" `{(h, i) | i : I}` at most\nonce. Then the image of `f` is the graph of some monoid homomorphism `f' : H → I`.\"]\nlemma exists_mrange_eq_mgraph {f : G →* H × I} (hf₁ : Surjective (Prod.fst ∘ f))\n    (hf : ∀ g₁ g₂, (f g₁).1 = (f g₂).1 → (f g₁).2 = (f g₂).2) :\n    ∃ f' : H →* I, mrange f = f'.mgraph := by\n  obtain ⟨f', hf'⟩ := exists_range_eq_graphOn_univ hf₁ hf\n  simp only [Set.ext_iff, Set.mem_range, mem_graphOn, mem_univ, true_and, Prod.forall] at hf'\n  use\n  { toFun := f'\n    map_one' := (hf' _ _).1 ⟨1, map_one _⟩\n    map_mul' := by\n      simp_rw [hf₁.forall]\n      rintro g₁ g₂\n      exact (hf' _ _).1 ⟨g₁ * g₂, by simp [Prod.ext_iff, (hf' (f _).1 _).1 ⟨_, rfl⟩]⟩ }\n  simpa [SetLike.ext_iff] using hf'\n\n"}
{"name":"MonoidHom.exists_mulEquiv_mrange_eq_mgraph","module":"Mathlib.Algebra.Group.Graph","initialProofState":"G : Type u_1\nH : Type u_2\nI : Type u_3\ninst✝² : Monoid G\ninst✝¹ : Monoid H\ninst✝ : Monoid I\nf : MonoidHom G (Prod H I)\nhf₁ : Function.Surjective (Function.comp Prod.fst ⇑f)\nhf₂ : Function.Surjective (Function.comp Prod.snd ⇑f)\nhf : ∀ (g₁ g₂ : G), Iff (Eq (f g₁).1 (f g₂).1) (Eq (f g₁).2 (f g₂).2)\n⊢ Exists fun e => Eq (MonoidHom.mrange f) e.toMonoidHom.mgraph","decl":"/-- **Line test** for monoid isomorphisms.\n\nLet `f : G → H × I` be a homomorphism to a product of monoids. Assume that `f` is surjective on both\nfactors and that the image of `f` intersects every \"vertical line\" `{(h, i) | i : I}` and every\n\"horizontal line\" `{(h, i) | h : H}` at most once. Then the image of `f` is the graph of some monoid\nisomorphism `f' : H ≃ I`. -/\n@[to_additive \"**Line test** for monoid isomorphisms.\n\nLet `f : G → H × I` be a homomorphism to a product of monoids. Assume that `f` is surjective on both\nfactors and that the image of `f` intersects every \\\"vertical line\\\" `{(h, i) | i : I}` and every\n\\\"horizontal line\\\" `{(h, i) | h : H}` at most once. Then the image of `f` is the graph of some\nmonoid isomorphism `f' : H ≃ I`.\"]\nlemma exists_mulEquiv_mrange_eq_mgraph {f : G →* H × I} (hf₁ : Surjective (Prod.fst ∘ f))\n    (hf₂ : Surjective (Prod.snd ∘ f)) (hf : ∀ g₁ g₂, (f g₁).1 = (f g₂).1 ↔ (f g₁).2 = (f g₂).2) :\n    ∃ e : H ≃* I, mrange f = e.toMonoidHom.mgraph := by\n  obtain ⟨e₁, he₁⟩ := f.exists_mrange_eq_mgraph hf₁ fun _ _ ↦ (hf _ _).1\n  obtain ⟨e₂, he₂⟩ := (MulEquiv.prodComm.toMonoidHom.comp f).exists_mrange_eq_mgraph (by simpa) <|\n    by simp [hf]\n  have he₁₂ h i : e₁ h = i ↔ e₂ i = h := by\n    rw [SetLike.ext_iff] at he₁ he₂\n    aesop (add simp [Prod.swap_eq_iff_eq_swap])\n  exact ⟨\n  { toFun := e₁\n    map_mul' := e₁.map_mul'\n    invFun := e₂\n    left_inv := fun h ↦ by rw [← he₁₂]\n    right_inv := fun i ↦ by rw [he₁₂] }, he₁⟩\n\n"}
{"name":"AddMonoidHom.exists_addEquiv_mrange_eq_mgraph","module":"Mathlib.Algebra.Group.Graph","initialProofState":"G : Type u_1\nH : Type u_2\nI : Type u_3\ninst✝² : AddMonoid G\ninst✝¹ : AddMonoid H\ninst✝ : AddMonoid I\nf : AddMonoidHom G (Prod H I)\nhf₁ : Function.Surjective (Function.comp Prod.fst ⇑f)\nhf₂ : Function.Surjective (Function.comp Prod.snd ⇑f)\nhf : ∀ (g₁ g₂ : G), Iff (Eq (f g₁).1 (f g₂).1) (Eq (f g₁).2 (f g₂).2)\n⊢ Exists fun e => Eq (AddMonoidHom.mrange f) e.toAddMonoidHom.mgraph","decl":"/-- **Line test** for monoid isomorphisms.\n\nLet `f : G → H × I` be a homomorphism to a product of monoids. Assume that `f` is surjective on both\nfactors and that the image of `f` intersects every \"vertical line\" `{(h, i) | i : I}` and every\n\"horizontal line\" `{(h, i) | h : H}` at most once. Then the image of `f` is the graph of some monoid\nisomorphism `f' : H ≃ I`. -/\n@[to_additive \"**Line test** for monoid isomorphisms.\n\nLet `f : G → H × I` be a homomorphism to a product of monoids. Assume that `f` is surjective on both\nfactors and that the image of `f` intersects every \\\"vertical line\\\" `{(h, i) | i : I}` and every\n\\\"horizontal line\\\" `{(h, i) | h : H}` at most once. Then the image of `f` is the graph of some\nmonoid isomorphism `f' : H ≃ I`.\"]\nlemma exists_mulEquiv_mrange_eq_mgraph {f : G →* H × I} (hf₁ : Surjective (Prod.fst ∘ f))\n    (hf₂ : Surjective (Prod.snd ∘ f)) (hf : ∀ g₁ g₂, (f g₁).1 = (f g₂).1 ↔ (f g₁).2 = (f g₂).2) :\n    ∃ e : H ≃* I, mrange f = e.toMonoidHom.mgraph := by\n  obtain ⟨e₁, he₁⟩ := f.exists_mrange_eq_mgraph hf₁ fun _ _ ↦ (hf _ _).1\n  obtain ⟨e₂, he₂⟩ := (MulEquiv.prodComm.toMonoidHom.comp f).exists_mrange_eq_mgraph (by simpa) <|\n    by simp [hf]\n  have he₁₂ h i : e₁ h = i ↔ e₂ i = h := by\n    rw [SetLike.ext_iff] at he₁ he₂\n    aesop (add simp [Prod.swap_eq_iff_eq_swap])\n  exact ⟨\n  { toFun := e₁\n    map_mul' := e₁.map_mul'\n    invFun := e₂\n    left_inv := fun h ↦ by rw [← he₁₂]\n    right_inv := fun i ↦ by rw [he₁₂] }, he₁⟩\n\n"}
{"name":"AddSubmonoid.exists_eq_mgraph","module":"Mathlib.Algebra.Group.Graph","initialProofState":"H : Type u_2\nI : Type u_3\ninst✝¹ : AddMonoid H\ninst✝ : AddMonoid I\nG : AddSubmonoid (Prod H I)\nhG₁ : Function.Bijective (Function.comp Prod.fst ⇑G.subtype)\n⊢ Exists fun f => Eq G f.mgraph","decl":"/-- **Vertical line test** for monoid homomorphisms.\n\nLet `G ≤ H × I` be a submonoid of a product of monoids. Assume that `G` maps bijectively to the\nfirst factor. Then `G` is the graph of some monoid homomorphism `f : H → I`. -/\n@[to_additive \"**Vertical line test** for additive monoid homomorphisms.\n\nLet `G ≤ H × I` be a submonoid of a product of monoids. Assume that `G` surjects onto the first\nfactor and `G` intersects every \\\"vertical line\\\" `{(h, i) | i : I}` at most once. Then `G` is the\ngraph of some monoid homomorphism `f : H → I`.\"]\nlemma Submonoid.exists_eq_mgraph {G : Submonoid (H × I)} (hG₁ : Bijective (Prod.fst ∘ G.subtype)) :\n    ∃ f : H →* I, G = f.mgraph := by\n  simpa using MonoidHom.exists_mrange_eq_mgraph hG₁.surjective\n    fun a b h ↦ congr_arg (Prod.snd ∘ G.subtype) (hG₁.injective h)\n\n"}
{"name":"Submonoid.exists_eq_mgraph","module":"Mathlib.Algebra.Group.Graph","initialProofState":"H : Type u_2\nI : Type u_3\ninst✝¹ : Monoid H\ninst✝ : Monoid I\nG : Submonoid (Prod H I)\nhG₁ : Function.Bijective (Function.comp Prod.fst ⇑G.subtype)\n⊢ Exists fun f => Eq G f.mgraph","decl":"/-- **Vertical line test** for monoid homomorphisms.\n\nLet `G ≤ H × I` be a submonoid of a product of monoids. Assume that `G` maps bijectively to the\nfirst factor. Then `G` is the graph of some monoid homomorphism `f : H → I`. -/\n@[to_additive \"**Vertical line test** for additive monoid homomorphisms.\n\nLet `G ≤ H × I` be a submonoid of a product of monoids. Assume that `G` surjects onto the first\nfactor and `G` intersects every \\\"vertical line\\\" `{(h, i) | i : I}` at most once. Then `G` is the\ngraph of some monoid homomorphism `f : H → I`.\"]\nlemma Submonoid.exists_eq_mgraph {G : Submonoid (H × I)} (hG₁ : Bijective (Prod.fst ∘ G.subtype)) :\n    ∃ f : H →* I, G = f.mgraph := by\n  simpa using MonoidHom.exists_mrange_eq_mgraph hG₁.surjective\n    fun a b h ↦ congr_arg (Prod.snd ∘ G.subtype) (hG₁.injective h)\n\n"}
{"name":"Submonoid.exists_mulEquiv_eq_mgraph","module":"Mathlib.Algebra.Group.Graph","initialProofState":"H : Type u_2\nI : Type u_3\ninst✝¹ : Monoid H\ninst✝ : Monoid I\nG : Submonoid (Prod H I)\nhG₁ : Function.Bijective (Function.comp Prod.fst ⇑G.subtype)\nhG₂ : Function.Bijective (Function.comp Prod.snd ⇑G.subtype)\n⊢ Exists fun e => Eq G e.toMonoidHom.mgraph","decl":"/-- **Goursat's lemma** for monoid isomorphisms.\n\nLet `G ≤ H × I` be a submonoid of a product of monoids. Assume that the natural maps from `G` to\nboth factors are bijective. Then `G` is the graph of some isomorphism `f : H ≃* I`. -/\n@[to_additive \"**Goursat's lemma** for additive monoid isomorphisms.\n\nLet `G ≤ H × I` be a submonoid of a product of additive monoids. Assume that the natural maps from\n`G` to both factors are bijective. Then `G` is the graph of some isomorphism `f : H ≃+ I`.\"]\nlemma Submonoid.exists_mulEquiv_eq_mgraph {G : Submonoid (H × I)}\n    (hG₁ : Bijective (Prod.fst ∘ G.subtype)) (hG₂ : Bijective (Prod.snd ∘ G.subtype)) :\n    ∃ e : H ≃* I, G = e.toMonoidHom.mgraph := by\n  simpa using MonoidHom.exists_mulEquiv_mrange_eq_mgraph hG₁.surjective hG₂.surjective\n    fun _ _ ↦ hG₁.injective.eq_iff.trans hG₂.injective.eq_iff.symm\n\n"}
{"name":"AddSubmonoid.exists_addEquiv_eq_mgraph","module":"Mathlib.Algebra.Group.Graph","initialProofState":"H : Type u_2\nI : Type u_3\ninst✝¹ : AddMonoid H\ninst✝ : AddMonoid I\nG : AddSubmonoid (Prod H I)\nhG₁ : Function.Bijective (Function.comp Prod.fst ⇑G.subtype)\nhG₂ : Function.Bijective (Function.comp Prod.snd ⇑G.subtype)\n⊢ Exists fun e => Eq G e.toAddMonoidHom.mgraph","decl":"/-- **Goursat's lemma** for monoid isomorphisms.\n\nLet `G ≤ H × I` be a submonoid of a product of monoids. Assume that the natural maps from `G` to\nboth factors are bijective. Then `G` is the graph of some isomorphism `f : H ≃* I`. -/\n@[to_additive \"**Goursat's lemma** for additive monoid isomorphisms.\n\nLet `G ≤ H × I` be a submonoid of a product of additive monoids. Assume that the natural maps from\n`G` to both factors are bijective. Then `G` is the graph of some isomorphism `f : H ≃+ I`.\"]\nlemma Submonoid.exists_mulEquiv_eq_mgraph {G : Submonoid (H × I)}\n    (hG₁ : Bijective (Prod.fst ∘ G.subtype)) (hG₂ : Bijective (Prod.snd ∘ G.subtype)) :\n    ∃ e : H ≃* I, G = e.toMonoidHom.mgraph := by\n  simpa using MonoidHom.exists_mulEquiv_mrange_eq_mgraph hG₁.surjective hG₂.surjective\n    fun _ _ ↦ hG₁.injective.eq_iff.trans hG₂.injective.eq_iff.symm\n\n"}
{"name":"MonoidHom.graph_toSubmonoid","module":"Mathlib.Algebra.Group.Graph","initialProofState":"G : Type u_1\nH : Type u_2\ninst✝¹ : Group G\ninst✝ : Group H\nf : MonoidHom G H\n⊢ Eq f.graph.toSubmonoid f.mgraph","decl":"attribute [simps! coe toSubmonoid] graph\n"}
{"name":"MonoidHom.coe_graph","module":"Mathlib.Algebra.Group.Graph","initialProofState":"G : Type u_1\nH : Type u_2\ninst✝¹ : Group G\ninst✝ : Group H\nf : MonoidHom G H\n⊢ Eq (↑f.graph) (setOf fun x => Eq (f x.1) x.2)","decl":"attribute [simps! coe toSubmonoid] graph\n"}
{"name":"AddMonoidHom.graph_toAddSubmonoid","module":"Mathlib.Algebra.Group.Graph","initialProofState":"G : Type u_1\nH : Type u_2\ninst✝¹ : AddGroup G\ninst✝ : AddGroup H\nf : AddMonoidHom G H\n⊢ Eq f.graph.toAddSubmonoid f.mgraph","decl":"attribute [simps! coe toAddSubmonoid] AddMonoidHom.graph\n"}
{"name":"AddMonoidHom.coe_graph","module":"Mathlib.Algebra.Group.Graph","initialProofState":"G : Type u_1\nH : Type u_2\ninst✝¹ : AddGroup G\ninst✝ : AddGroup H\nf : AddMonoidHom G H\n⊢ Eq (↑f.graph) (setOf fun x => Eq (f x.1) x.2)","decl":"attribute [simps! coe toAddSubmonoid] AddMonoidHom.graph\n"}
{"name":"MonoidHom.mem_graph","module":"Mathlib.Algebra.Group.Graph","initialProofState":"G : Type u_1\nH : Type u_2\ninst✝¹ : Group G\ninst✝ : Group H\nf : MonoidHom G H\nx : Prod G H\n⊢ Iff (Membership.mem f.graph x) (Eq (f x.1) x.2)","decl":"@[to_additive]\nlemma mem_graph {f : G →* H} {x : G × H} : x ∈ f.graph ↔ f x.1 = x.2 := .rfl\n\n"}
{"name":"AddMonoidHom.mem_graph","module":"Mathlib.Algebra.Group.Graph","initialProofState":"G : Type u_1\nH : Type u_2\ninst✝¹ : AddGroup G\ninst✝ : AddGroup H\nf : AddMonoidHom G H\nx : Prod G H\n⊢ Iff (Membership.mem f.graph x) (Eq (f x.1) x.2)","decl":"@[to_additive]\nlemma mem_graph {f : G →* H} {x : G × H} : x ∈ f.graph ↔ f x.1 = x.2 := .rfl\n\n"}
{"name":"MonoidHom.graph_eq_range_prod","module":"Mathlib.Algebra.Group.Graph","initialProofState":"G : Type u_1\nH : Type u_2\ninst✝¹ : Group G\ninst✝ : Group H\nf : MonoidHom G H\n⊢ Eq f.graph ((MonoidHom.id G).prod f).range","decl":"@[to_additive]\nlemma graph_eq_range_prod (f : G →* H) : f.graph = range ((id _).prod f) := by aesop\n\n"}
{"name":"AddMonoidHom.graph_eq_range_sum","module":"Mathlib.Algebra.Group.Graph","initialProofState":"G : Type u_1\nH : Type u_2\ninst✝¹ : AddGroup G\ninst✝ : AddGroup H\nf : AddMonoidHom G H\n⊢ Eq f.graph ((AddMonoidHom.id G).prod f).range","decl":"@[to_additive]\nlemma graph_eq_range_prod (f : G →* H) : f.graph = range ((id _).prod f) := by aesop\n\n"}
{"name":"MonoidHom.exists_range_eq_graph","module":"Mathlib.Algebra.Group.Graph","initialProofState":"G : Type u_1\nH : Type u_2\nI : Type u_3\ninst✝² : Group G\ninst✝¹ : Group H\ninst✝ : Group I\nf : MonoidHom G (Prod H I)\nhf₁ : Function.Surjective (Function.comp Prod.fst ⇑f)\nhf : ∀ (g₁ g₂ : G), Eq (f g₁).1 (f g₂).1 → Eq (f g₁).2 (f g₂).2\n⊢ Exists fun f' => Eq f.range f'.graph","decl":"/-- **Vertical line test** for group homomorphisms.\n\nLet `f : G → H × I` be a homomorphism to a product of groups. Assume that `f` is surjective on the\nfirst factor and that the image of `f` intersects every \"vertical line\" `{(h, i) | i : I}` at most\nonce. Then the image of `f` is the graph of some group homomorphism `f' : H → I`. -/\n@[to_additive \"**Vertical line test** for group homomorphisms.\n\nLet `f : G → H × I` be a homomorphism to a product of groups. Assume that `f` is surjective on the\nfirst factor and that the image of `f` intersects every \\\"vertical line\\\" `{(h, i) | i : I}` at most\nonce. Then the image of `f` is the graph of some group homomorphism `f' : H → I`.\"]\nlemma exists_range_eq_graph {f : G →* H × I} (hf₁ : Surjective (Prod.fst ∘ f))\n    (hf : ∀ g₁ g₂, (f g₁).1 = (f g₂).1 → (f g₁).2 = (f g₂).2) :\n    ∃ f' : H →* I, range f = f'.graph := by\n  simpa [SetLike.ext_iff] using exists_mrange_eq_mgraph hf₁ hf\n\n"}
{"name":"AddMonoidHom.exists_range_eq_graph","module":"Mathlib.Algebra.Group.Graph","initialProofState":"G : Type u_1\nH : Type u_2\nI : Type u_3\ninst✝² : AddGroup G\ninst✝¹ : AddGroup H\ninst✝ : AddGroup I\nf : AddMonoidHom G (Prod H I)\nhf₁ : Function.Surjective (Function.comp Prod.fst ⇑f)\nhf : ∀ (g₁ g₂ : G), Eq (f g₁).1 (f g₂).1 → Eq (f g₁).2 (f g₂).2\n⊢ Exists fun f' => Eq f.range f'.graph","decl":"/-- **Vertical line test** for group homomorphisms.\n\nLet `f : G → H × I` be a homomorphism to a product of groups. Assume that `f` is surjective on the\nfirst factor and that the image of `f` intersects every \"vertical line\" `{(h, i) | i : I}` at most\nonce. Then the image of `f` is the graph of some group homomorphism `f' : H → I`. -/\n@[to_additive \"**Vertical line test** for group homomorphisms.\n\nLet `f : G → H × I` be a homomorphism to a product of groups. Assume that `f` is surjective on the\nfirst factor and that the image of `f` intersects every \\\"vertical line\\\" `{(h, i) | i : I}` at most\nonce. Then the image of `f` is the graph of some group homomorphism `f' : H → I`.\"]\nlemma exists_range_eq_graph {f : G →* H × I} (hf₁ : Surjective (Prod.fst ∘ f))\n    (hf : ∀ g₁ g₂, (f g₁).1 = (f g₂).1 → (f g₁).2 = (f g₂).2) :\n    ∃ f' : H →* I, range f = f'.graph := by\n  simpa [SetLike.ext_iff] using exists_mrange_eq_mgraph hf₁ hf\n\n"}
{"name":"MonoidHom.exists_mulEquiv_range_eq_graph","module":"Mathlib.Algebra.Group.Graph","initialProofState":"G : Type u_1\nH : Type u_2\nI : Type u_3\ninst✝² : Group G\ninst✝¹ : Group H\ninst✝ : Group I\nf : MonoidHom G (Prod H I)\nhf₁ : Function.Surjective (Function.comp Prod.fst ⇑f)\nhf₂ : Function.Surjective (Function.comp Prod.snd ⇑f)\nhf : ∀ (g₁ g₂ : G), Iff (Eq (f g₁).1 (f g₂).1) (Eq (f g₁).2 (f g₂).2)\n⊢ Exists fun e => Eq f.range e.toMonoidHom.graph","decl":"/-- **Line test** for group isomorphisms.\n\nLet `f : G → H × I` be a homomorphism to a product of groups. Assume that `f` is surjective on both\nfactors and that the image of `f` intersects every \"vertical line\" `{(h, i) | i : I}` and every\n\"horizontal line\" `{(h, i) | h : H}` at most once. Then the image of `f` is the graph of some group\nisomorphism `f' : H ≃ I`. -/\n@[to_additive \"**Line test** for monoid isomorphisms.\n\nLet `f : G → H × I` be a homomorphism to a product of groups. Assume that `f` is surjective on both\nfactors and that the image of `f` intersects every \\\"vertical line\\\" `{(h, i) | i : I}` and every\n\\\"horizontal line\\\" `{(h, i) | h : H}` at most once. Then the image of `f` is the graph of some\ngroup isomorphism `f' : H ≃ I`.\"]\nlemma exists_mulEquiv_range_eq_graph {f : G →* H × I} (hf₁ : Surjective (Prod.fst ∘ f))\n    (hf₂ : Surjective (Prod.snd ∘ f)) (hf : ∀ g₁ g₂, (f g₁).1 = (f g₂).1 ↔ (f g₁).2 = (f g₂).2) :\n    ∃ e : H ≃* I, range f = e.toMonoidHom.graph := by\n  simpa [SetLike.ext_iff] using exists_mulEquiv_mrange_eq_mgraph hf₁ hf₂ hf\n\n"}
{"name":"AddMonoidHom.exists_addEquiv_range_eq_graph","module":"Mathlib.Algebra.Group.Graph","initialProofState":"G : Type u_1\nH : Type u_2\nI : Type u_3\ninst✝² : AddGroup G\ninst✝¹ : AddGroup H\ninst✝ : AddGroup I\nf : AddMonoidHom G (Prod H I)\nhf₁ : Function.Surjective (Function.comp Prod.fst ⇑f)\nhf₂ : Function.Surjective (Function.comp Prod.snd ⇑f)\nhf : ∀ (g₁ g₂ : G), Iff (Eq (f g₁).1 (f g₂).1) (Eq (f g₁).2 (f g₂).2)\n⊢ Exists fun e => Eq f.range e.toAddMonoidHom.graph","decl":"/-- **Line test** for group isomorphisms.\n\nLet `f : G → H × I` be a homomorphism to a product of groups. Assume that `f` is surjective on both\nfactors and that the image of `f` intersects every \"vertical line\" `{(h, i) | i : I}` and every\n\"horizontal line\" `{(h, i) | h : H}` at most once. Then the image of `f` is the graph of some group\nisomorphism `f' : H ≃ I`. -/\n@[to_additive \"**Line test** for monoid isomorphisms.\n\nLet `f : G → H × I` be a homomorphism to a product of groups. Assume that `f` is surjective on both\nfactors and that the image of `f` intersects every \\\"vertical line\\\" `{(h, i) | i : I}` and every\n\\\"horizontal line\\\" `{(h, i) | h : H}` at most once. Then the image of `f` is the graph of some\ngroup isomorphism `f' : H ≃ I`.\"]\nlemma exists_mulEquiv_range_eq_graph {f : G →* H × I} (hf₁ : Surjective (Prod.fst ∘ f))\n    (hf₂ : Surjective (Prod.snd ∘ f)) (hf : ∀ g₁ g₂, (f g₁).1 = (f g₂).1 ↔ (f g₁).2 = (f g₂).2) :\n    ∃ e : H ≃* I, range f = e.toMonoidHom.graph := by\n  simpa [SetLike.ext_iff] using exists_mulEquiv_mrange_eq_mgraph hf₁ hf₂ hf\n\n"}
{"name":"Subgroup.exists_eq_graph","module":"Mathlib.Algebra.Group.Graph","initialProofState":"H : Type u_2\nI : Type u_3\ninst✝¹ : Group H\ninst✝ : Group I\nG : Subgroup (Prod H I)\nhG₁ : Function.Bijective (Function.comp Prod.fst ⇑G.subtype)\n⊢ Exists fun f => Eq G f.graph","decl":"/-- **Vertical line test** for group homomorphisms.\n\nLet `G ≤ H × I` be a subgroup of a product of monoids. Assume that `G` maps bijectively to the\nfirst factor. Then `G` is the graph of some monoid homomorphism `f : H → I`. -/\n@[to_additive \"**Vertical line test** for additive monoid homomorphisms.\n\nLet `G ≤ H × I` be a submonoid of a product of monoids. Assume that `G` surjects onto the first\nfactor and `G` intersects every \\\"vertical line\\\" `{(h, i) | i : I}` at most once. Then `G` is the\ngraph of some monoid homomorphism `f : H → I`.\"]\nlemma Subgroup.exists_eq_graph {G : Subgroup (H × I)} (hG₁ : Bijective (Prod.fst ∘ G.subtype)) :\n    ∃ f : H →* I, G = f.graph := by\n  simpa [SetLike.ext_iff] using Submonoid.exists_eq_mgraph hG₁\n\n"}
{"name":"AddSubgroup.exists_eq_graph","module":"Mathlib.Algebra.Group.Graph","initialProofState":"H : Type u_2\nI : Type u_3\ninst✝¹ : AddGroup H\ninst✝ : AddGroup I\nG : AddSubgroup (Prod H I)\nhG₁ : Function.Bijective (Function.comp Prod.fst ⇑G.subtype)\n⊢ Exists fun f => Eq G f.graph","decl":"/-- **Vertical line test** for group homomorphisms.\n\nLet `G ≤ H × I` be a subgroup of a product of monoids. Assume that `G` maps bijectively to the\nfirst factor. Then `G` is the graph of some monoid homomorphism `f : H → I`. -/\n@[to_additive \"**Vertical line test** for additive monoid homomorphisms.\n\nLet `G ≤ H × I` be a submonoid of a product of monoids. Assume that `G` surjects onto the first\nfactor and `G` intersects every \\\"vertical line\\\" `{(h, i) | i : I}` at most once. Then `G` is the\ngraph of some monoid homomorphism `f : H → I`.\"]\nlemma Subgroup.exists_eq_graph {G : Subgroup (H × I)} (hG₁ : Bijective (Prod.fst ∘ G.subtype)) :\n    ∃ f : H →* I, G = f.graph := by\n  simpa [SetLike.ext_iff] using Submonoid.exists_eq_mgraph hG₁\n\n"}
{"name":"Subgroup.exists_mulEquiv_eq_graph","module":"Mathlib.Algebra.Group.Graph","initialProofState":"H : Type u_2\nI : Type u_3\ninst✝¹ : Group H\ninst✝ : Group I\nG : Subgroup (Prod H I)\nhG₁ : Function.Bijective (Function.comp Prod.fst ⇑G.subtype)\nhG₂ : Function.Bijective (Function.comp Prod.snd ⇑G.subtype)\n⊢ Exists fun e => Eq G e.toMonoidHom.graph","decl":"/-- **Goursat's lemma** for monoid isomorphisms.\n\nLet `G ≤ H × I` be a submonoid of a product of monoids. Assume that the natural maps from `G` to\nboth factors are bijective. Then `G` is the graph of some isomorphism `f : H ≃* I`. -/\n@[to_additive \"**Goursat's lemma** for additive monoid isomorphisms.\n\nLet `G ≤ H × I` be a submonoid of a product of additive monoids. Assume that the natural maps from\n`G` to both factors are bijective. Then `G` is the graph of some isomorphism `f : H ≃+ I`.\"]\nlemma Subgroup.exists_mulEquiv_eq_graph {G : Subgroup (H × I)}\n    (hG₁ : Bijective (Prod.fst ∘ G.subtype)) (hG₂ : Bijective (Prod.snd ∘ G.subtype)) :\n    ∃ e : H ≃* I, G = e.toMonoidHom.graph := by\n  simpa [SetLike.ext_iff] using Submonoid.exists_mulEquiv_eq_mgraph hG₁ hG₂\n\n"}
{"name":"AddSubgroup.exists_addEquiv_eq_graph","module":"Mathlib.Algebra.Group.Graph","initialProofState":"H : Type u_2\nI : Type u_3\ninst✝¹ : AddGroup H\ninst✝ : AddGroup I\nG : AddSubgroup (Prod H I)\nhG₁ : Function.Bijective (Function.comp Prod.fst ⇑G.subtype)\nhG₂ : Function.Bijective (Function.comp Prod.snd ⇑G.subtype)\n⊢ Exists fun e => Eq G e.toAddMonoidHom.graph","decl":"/-- **Goursat's lemma** for monoid isomorphisms.\n\nLet `G ≤ H × I` be a submonoid of a product of monoids. Assume that the natural maps from `G` to\nboth factors are bijective. Then `G` is the graph of some isomorphism `f : H ≃* I`. -/\n@[to_additive \"**Goursat's lemma** for additive monoid isomorphisms.\n\nLet `G ≤ H × I` be a submonoid of a product of additive monoids. Assume that the natural maps from\n`G` to both factors are bijective. Then `G` is the graph of some isomorphism `f : H ≃+ I`.\"]\nlemma Subgroup.exists_mulEquiv_eq_graph {G : Subgroup (H × I)}\n    (hG₁ : Bijective (Prod.fst ∘ G.subtype)) (hG₂ : Bijective (Prod.snd ∘ G.subtype)) :\n    ∃ e : H ≃* I, G = e.toMonoidHom.graph := by\n  simpa [SetLike.ext_iff] using Submonoid.exists_mulEquiv_eq_mgraph hG₁ hG₂\n\n"}
