{"name":"CategoryTheory.Limits.BinaryFan.swap_fst","module":"Mathlib.CategoryTheory.Monoidal.OfChosenFiniteProducts.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nP Q : C\nt : CategoryTheory.Limits.BinaryFan P Q\n‚ä¢ Eq t.swap.fst t.snd","decl":"@[simp]\ntheorem BinaryFan.swap_fst {P Q : C} (t : BinaryFan P Q) : t.swap.fst = t.snd :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.BinaryFan.swap_snd","module":"Mathlib.CategoryTheory.Monoidal.OfChosenFiniteProducts.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nP Q : C\nt : CategoryTheory.Limits.BinaryFan P Q\n‚ä¢ Eq t.swap.snd t.fst","decl":"@[simp]\ntheorem BinaryFan.swap_snd {P Q : C} (t : BinaryFan P Q) : t.swap.snd = t.fst :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.IsLimit.swapBinaryFan_lift","module":"Mathlib.CategoryTheory.Monoidal.OfChosenFiniteProducts.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nP Q : C\nt : CategoryTheory.Limits.BinaryFan P Q\nI : CategoryTheory.Limits.IsLimit t\ns : CategoryTheory.Limits.Cone (CategoryTheory.Limits.pair Q P)\n‚ä¢ Eq (I.swapBinaryFan.lift s) (I.lift (CategoryTheory.Limits.BinaryFan.swap s))","decl":"/-- If a binary fan `t` over `P Q` is a limit cone, then `t.swap` is a limit cone over `Q P`.\n-/\n@[simps]\ndef IsLimit.swapBinaryFan {P Q : C} {t : BinaryFan P Q} (I : IsLimit t) : IsLimit t.swap where\n  lift s := I.lift (BinaryFan.swap s)\n  fac s := by rintro ‚ü®‚ü®‚ü©‚ü© <;> simp\n  uniq s m w := by\n    have h := I.uniq (BinaryFan.swap s) m\n    rw [h]\n    rintro ‚ü®j‚ü©\n    specialize w ‚ü®WalkingPair.swap j‚ü©\n    cases j <;> exact w\n\n"}
{"name":"CategoryTheory.Limits.HasBinaryProduct.swap","module":"Mathlib.CategoryTheory.Monoidal.OfChosenFiniteProducts.Basic","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nP Q : C\ninst‚úù : CategoryTheory.Limits.HasBinaryProduct P Q\n‚ä¢ CategoryTheory.Limits.HasBinaryProduct Q P","decl":"/-- Construct `HasBinaryProduct Q P` from `HasBinaryProduct P Q`.\nThis can't be an instance, as it would cause a loop in typeclass search.\n-/\ntheorem HasBinaryProduct.swap (P Q : C) [HasBinaryProduct P Q] : HasBinaryProduct Q P :=\n  HasLimit.mk ‚ü®BinaryFan.swap (limit.cone (pair P Q)), (limit.isLimit (pair P Q)).swapBinaryFan‚ü©\n\n"}
{"name":"CategoryTheory.Limits.BinaryFan.assoc_fst","module":"Mathlib.CategoryTheory.Monoidal.OfChosenFiniteProducts.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y Z : C\nsXY : CategoryTheory.Limits.BinaryFan X Y\nsYZ : CategoryTheory.Limits.BinaryFan Y Z\nQ : CategoryTheory.Limits.IsLimit sYZ\ns : CategoryTheory.Limits.BinaryFan sXY.pt Z\n‚ä¢ Eq (CategoryTheory.Limits.BinaryFan.assoc Q s).fst (CategoryTheory.CategoryStruct.comp s.fst sXY.fst)","decl":"@[simp]\ntheorem BinaryFan.assoc_fst {X Y Z : C} {sXY : BinaryFan X Y} {sYZ : BinaryFan Y Z}\n    (Q : IsLimit sYZ) (s : BinaryFan sXY.pt Z) : (BinaryFan.assoc Q s).fst = s.fst ‚â´ sXY.fst :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.BinaryFan.assoc_snd","module":"Mathlib.CategoryTheory.Monoidal.OfChosenFiniteProducts.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y Z : C\nsXY : CategoryTheory.Limits.BinaryFan X Y\nsYZ : CategoryTheory.Limits.BinaryFan Y Z\nQ : CategoryTheory.Limits.IsLimit sYZ\ns : CategoryTheory.Limits.BinaryFan sXY.pt Z\n‚ä¢ Eq (CategoryTheory.Limits.BinaryFan.assoc Q s).snd (Q.lift (CategoryTheory.Limits.BinaryFan.mk (CategoryTheory.CategoryStruct.comp s.fst sXY.snd) s.snd))","decl":"@[simp]\ntheorem BinaryFan.assoc_snd {X Y Z : C} {sXY : BinaryFan X Y} {sYZ : BinaryFan Y Z}\n    (Q : IsLimit sYZ) (s : BinaryFan sXY.pt Z) :\n    (BinaryFan.assoc Q s).snd = Q.lift (BinaryFan.mk (s.fst ‚â´ sXY.snd) s.snd) :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.BinaryFan.assocInv_fst","module":"Mathlib.CategoryTheory.Monoidal.OfChosenFiniteProducts.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y Z : C\nsXY : CategoryTheory.Limits.BinaryFan X Y\nP : CategoryTheory.Limits.IsLimit sXY\nsYZ : CategoryTheory.Limits.BinaryFan Y Z\ns : CategoryTheory.Limits.BinaryFan X sYZ.pt\n‚ä¢ Eq (CategoryTheory.Limits.BinaryFan.assocInv P s).fst (P.lift (CategoryTheory.Limits.BinaryFan.mk s.fst (CategoryTheory.CategoryStruct.comp s.snd sYZ.fst)))","decl":"@[simp]\ntheorem BinaryFan.assocInv_fst {X Y Z : C} {sXY : BinaryFan X Y} (P : IsLimit sXY)\n    {sYZ : BinaryFan Y Z} (s : BinaryFan X sYZ.pt) :\n    (BinaryFan.assocInv P s).fst = P.lift (BinaryFan.mk s.fst (s.snd ‚â´ sYZ.fst)) :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.BinaryFan.assocInv_snd","module":"Mathlib.CategoryTheory.Monoidal.OfChosenFiniteProducts.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y Z : C\nsXY : CategoryTheory.Limits.BinaryFan X Y\nP : CategoryTheory.Limits.IsLimit sXY\nsYZ : CategoryTheory.Limits.BinaryFan Y Z\ns : CategoryTheory.Limits.BinaryFan X sYZ.pt\n‚ä¢ Eq (CategoryTheory.Limits.BinaryFan.assocInv P s).snd (CategoryTheory.CategoryStruct.comp s.snd sYZ.snd)","decl":"@[simp]\ntheorem BinaryFan.assocInv_snd {X Y Z : C} {sXY : BinaryFan X Y} (P : IsLimit sXY)\n    {sYZ : BinaryFan Y Z} (s : BinaryFan X sYZ.pt) :\n    (BinaryFan.assocInv P s).snd = s.snd ‚â´ sYZ.snd :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.IsLimit.assoc_lift","module":"Mathlib.CategoryTheory.Monoidal.OfChosenFiniteProducts.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y Z : C\nsXY : CategoryTheory.Limits.BinaryFan X Y\nP : CategoryTheory.Limits.IsLimit sXY\nsYZ : CategoryTheory.Limits.BinaryFan Y Z\nQ : CategoryTheory.Limits.IsLimit sYZ\ns : CategoryTheory.Limits.BinaryFan sXY.pt Z\nR : CategoryTheory.Limits.IsLimit s\nt : CategoryTheory.Limits.Cone (CategoryTheory.Limits.pair X sYZ.pt)\n‚ä¢ Eq ((P.assoc Q R).lift t) (R.lift (CategoryTheory.Limits.BinaryFan.assocInv P t))","decl":"/-- If all the binary fans involved a limit cones, `BinaryFan.assoc` produces another limit cone.\n-/\n@[simps]\ndef IsLimit.assoc {X Y Z : C} {sXY : BinaryFan X Y} (P : IsLimit sXY) {sYZ : BinaryFan Y Z}\n    (Q : IsLimit sYZ) {s : BinaryFan sXY.pt Z} (R : IsLimit s) : IsLimit (BinaryFan.assoc Q s) where\n  lift t := R.lift (BinaryFan.assocInv P t)\n  fac t := by\n    rintro ‚ü®‚ü®‚ü©‚ü© <;> simp\n    apply Q.hom_ext\n    rintro ‚ü®‚ü®‚ü©‚ü© <;> simp\n  uniq t m w := by\n    have h := R.uniq (BinaryFan.assocInv P t) m\n    rw [h]\n    rintro ‚ü®‚ü®‚ü©‚ü© <;> simp\n    ¬∑ apply P.hom_ext\n      rintro ‚ü®‚ü®‚ü©‚ü© <;> simp\n      ¬∑ exact w ‚ü®WalkingPair.left‚ü©\n      ¬∑ specialize w ‚ü®WalkingPair.right‚ü©\n        simp? at w says\n          simp only [pair_obj_right, BinaryFan.œÄ_app_right, BinaryFan.assoc_snd,\n            Functor.const_obj_obj, pair_obj_left] at w\n        rw [‚Üê w]\n        simp\n    ¬∑ specialize w ‚ü®WalkingPair.right‚ü©\n      simp? at w says\n        simp only [pair_obj_right, BinaryFan.œÄ_app_right, BinaryFan.assoc_snd,\n          Functor.const_obj_obj, pair_obj_left] at w\n      rw [‚Üê w]\n      simp\n\n"}
{"name":"CategoryTheory.Limits.BinaryFan.leftUnitor_hom","module":"Mathlib.CategoryTheory.Monoidal.OfChosenFiniteProducts.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : C\ns : CategoryTheory.Limits.Cone (CategoryTheory.Functor.empty C)\nP : CategoryTheory.Limits.IsLimit s\nt : CategoryTheory.Limits.BinaryFan s.pt X\nQ : CategoryTheory.Limits.IsLimit t\n‚ä¢ Eq (CategoryTheory.Limits.BinaryFan.leftUnitor P Q).hom t.snd","decl":"/-- Construct a left unitor from specified limit cones.\n-/\n@[simps]\ndef BinaryFan.leftUnitor {X : C} {s : Cone (Functor.empty.{0} C)} (P : IsLimit s)\n    {t : BinaryFan s.pt X} (Q : IsLimit t) : t.pt ‚âÖ X where\n  hom := t.snd\n  inv := Q.lift <| BinaryFan.mk (P.lift ‚ü®_, fun x => x.as.elim, fun {x} => x.as.elim‚ü©) (ùüô _)\n  hom_inv_id := by\n    apply Q.hom_ext\n    rintro ‚ü®‚ü®‚ü©‚ü©\n    ¬∑ apply P.hom_ext\n      rintro ‚ü®‚ü®‚ü©‚ü©\n    ¬∑ simp\n\n"}
{"name":"CategoryTheory.Limits.BinaryFan.leftUnitor_inv","module":"Mathlib.CategoryTheory.Monoidal.OfChosenFiniteProducts.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : C\ns : CategoryTheory.Limits.Cone (CategoryTheory.Functor.empty C)\nP : CategoryTheory.Limits.IsLimit s\nt : CategoryTheory.Limits.BinaryFan s.pt X\nQ : CategoryTheory.Limits.IsLimit t\n‚ä¢ Eq (CategoryTheory.Limits.BinaryFan.leftUnitor P Q).inv (Q.lift (CategoryTheory.Limits.BinaryFan.mk (P.lift { pt := X, œÄ := { app := fun x => x.as.elim, naturality := ‚ãØ } }) (CategoryTheory.CategoryStruct.id { pt := X, œÄ := { app := fun x => x.as.elim, naturality := ‚ãØ } }.pt)))","decl":"/-- Construct a left unitor from specified limit cones.\n-/\n@[simps]\ndef BinaryFan.leftUnitor {X : C} {s : Cone (Functor.empty.{0} C)} (P : IsLimit s)\n    {t : BinaryFan s.pt X} (Q : IsLimit t) : t.pt ‚âÖ X where\n  hom := t.snd\n  inv := Q.lift <| BinaryFan.mk (P.lift ‚ü®_, fun x => x.as.elim, fun {x} => x.as.elim‚ü©) (ùüô _)\n  hom_inv_id := by\n    apply Q.hom_ext\n    rintro ‚ü®‚ü®‚ü©‚ü©\n    ¬∑ apply P.hom_ext\n      rintro ‚ü®‚ü®‚ü©‚ü©\n    ¬∑ simp\n\n"}
{"name":"CategoryTheory.Limits.BinaryFan.rightUnitor_inv","module":"Mathlib.CategoryTheory.Monoidal.OfChosenFiniteProducts.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : C\ns : CategoryTheory.Limits.Cone (CategoryTheory.Functor.empty C)\nP : CategoryTheory.Limits.IsLimit s\nt : CategoryTheory.Limits.BinaryFan X s.pt\nQ : CategoryTheory.Limits.IsLimit t\n‚ä¢ Eq (CategoryTheory.Limits.BinaryFan.rightUnitor P Q).inv (Q.lift (CategoryTheory.Limits.BinaryFan.mk (CategoryTheory.CategoryStruct.id X) (P.lift { pt := X, œÄ := { app := fun x => x.as.elim, naturality := ‚ãØ } })))","decl":"/-- Construct a right unitor from specified limit cones.\n-/\n@[simps]\ndef BinaryFan.rightUnitor {X : C} {s : Cone (Functor.empty.{0} C)} (P : IsLimit s)\n    {t : BinaryFan X s.pt} (Q : IsLimit t) : t.pt ‚âÖ X where\n  hom := t.fst\n  inv := Q.lift <| BinaryFan.mk (ùüô _) <| P.lift ‚ü®_, fun x => x.as.elim, fun {x} => x.as.elim‚ü©\n  hom_inv_id := by\n    apply Q.hom_ext\n    rintro ‚ü®‚ü®‚ü©‚ü©\n    ¬∑ simp\n    ¬∑ apply P.hom_ext\n      rintro ‚ü®‚ü®‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.Limits.BinaryFan.rightUnitor_hom","module":"Mathlib.CategoryTheory.Monoidal.OfChosenFiniteProducts.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : C\ns : CategoryTheory.Limits.Cone (CategoryTheory.Functor.empty C)\nP : CategoryTheory.Limits.IsLimit s\nt : CategoryTheory.Limits.BinaryFan X s.pt\nQ : CategoryTheory.Limits.IsLimit t\n‚ä¢ Eq (CategoryTheory.Limits.BinaryFan.rightUnitor P Q).hom t.fst","decl":"/-- Construct a right unitor from specified limit cones.\n-/\n@[simps]\ndef BinaryFan.rightUnitor {X : C} {s : Cone (Functor.empty.{0} C)} (P : IsLimit s)\n    {t : BinaryFan X s.pt} (Q : IsLimit t) : t.pt ‚âÖ X where\n  hom := t.fst\n  inv := Q.lift <| BinaryFan.mk (ùüô _) <| P.lift ‚ü®_, fun x => x.as.elim, fun {x} => x.as.elim‚ü©\n  hom_inv_id := by\n    apply Q.hom_ext\n    rintro ‚ü®‚ü®‚ü©‚ü©\n    ¬∑ simp\n    ¬∑ apply P.hom_ext\n      rintro ‚ü®‚ü®‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.MonoidalOfChosenFiniteProducts.tensor_id","module":"Mathlib.CategoryTheory.Monoidal.OfChosenFiniteProducts.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\n‚Ñ¨ : (X Y : C) ‚Üí CategoryTheory.Limits.LimitCone (CategoryTheory.Limits.pair X Y)\nX‚ÇÅ X‚ÇÇ : C\n‚ä¢ Eq (CategoryTheory.MonoidalOfChosenFiniteProducts.tensorHom ‚Ñ¨ (CategoryTheory.CategoryStruct.id X‚ÇÅ) (CategoryTheory.CategoryStruct.id X‚ÇÇ)) (CategoryTheory.CategoryStruct.id (CategoryTheory.MonoidalOfChosenFiniteProducts.tensorObj ‚Ñ¨ X‚ÇÅ X‚ÇÇ))","decl":"theorem tensor_id (X‚ÇÅ X‚ÇÇ : C) : tensorHom ‚Ñ¨ (ùüô X‚ÇÅ) (ùüô X‚ÇÇ) = ùüô (tensorObj ‚Ñ¨ X‚ÇÅ X‚ÇÇ) := by\n  apply IsLimit.hom_ext (‚Ñ¨ _ _).isLimit\n  rintro ‚ü®‚ü®‚ü©‚ü© <;>\n    ¬∑ dsimp [tensorHom]\n      simp\n\n"}
{"name":"CategoryTheory.MonoidalOfChosenFiniteProducts.tensor_comp","module":"Mathlib.CategoryTheory.Monoidal.OfChosenFiniteProducts.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\n‚Ñ¨ : (X Y : C) ‚Üí CategoryTheory.Limits.LimitCone (CategoryTheory.Limits.pair X Y)\nX‚ÇÅ Y‚ÇÅ Z‚ÇÅ X‚ÇÇ Y‚ÇÇ Z‚ÇÇ : C\nf‚ÇÅ : Quiver.Hom X‚ÇÅ Y‚ÇÅ\nf‚ÇÇ : Quiver.Hom X‚ÇÇ Y‚ÇÇ\ng‚ÇÅ : Quiver.Hom Y‚ÇÅ Z‚ÇÅ\ng‚ÇÇ : Quiver.Hom Y‚ÇÇ Z‚ÇÇ\n‚ä¢ Eq (CategoryTheory.MonoidalOfChosenFiniteProducts.tensorHom ‚Ñ¨ (CategoryTheory.CategoryStruct.comp f‚ÇÅ g‚ÇÅ) (CategoryTheory.CategoryStruct.comp f‚ÇÇ g‚ÇÇ)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalOfChosenFiniteProducts.tensorHom ‚Ñ¨ f‚ÇÅ f‚ÇÇ) (CategoryTheory.MonoidalOfChosenFiniteProducts.tensorHom ‚Ñ¨ g‚ÇÅ g‚ÇÇ))","decl":"theorem tensor_comp {X‚ÇÅ Y‚ÇÅ Z‚ÇÅ X‚ÇÇ Y‚ÇÇ Z‚ÇÇ : C} (f‚ÇÅ : X‚ÇÅ ‚ü∂ Y‚ÇÅ) (f‚ÇÇ : X‚ÇÇ ‚ü∂ Y‚ÇÇ) (g‚ÇÅ : Y‚ÇÅ ‚ü∂ Z‚ÇÅ)\n    (g‚ÇÇ : Y‚ÇÇ ‚ü∂ Z‚ÇÇ) : tensorHom ‚Ñ¨ (f‚ÇÅ ‚â´ g‚ÇÅ) (f‚ÇÇ ‚â´ g‚ÇÇ) = tensorHom ‚Ñ¨ f‚ÇÅ f‚ÇÇ ‚â´ tensorHom ‚Ñ¨ g‚ÇÅ g‚ÇÇ := by\n  apply IsLimit.hom_ext (‚Ñ¨ _ _).isLimit\n  rintro ‚ü®‚ü®‚ü©‚ü© <;>\n    ¬∑ dsimp [tensorHom]\n      simp\n\n"}
{"name":"CategoryTheory.MonoidalOfChosenFiniteProducts.pentagon","module":"Mathlib.CategoryTheory.Monoidal.OfChosenFiniteProducts.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\n‚Ñ¨ : (X Y : C) ‚Üí CategoryTheory.Limits.LimitCone (CategoryTheory.Limits.pair X Y)\nW X Y Z : C\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalOfChosenFiniteProducts.tensorHom ‚Ñ¨ (CategoryTheory.Limits.BinaryFan.associatorOfLimitCone ‚Ñ¨ W X Y).hom (CategoryTheory.CategoryStruct.id Z)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.BinaryFan.associatorOfLimitCone ‚Ñ¨ W (CategoryTheory.MonoidalOfChosenFiniteProducts.tensorObj ‚Ñ¨ X Y) Z).hom (CategoryTheory.MonoidalOfChosenFiniteProducts.tensorHom ‚Ñ¨ (CategoryTheory.CategoryStruct.id W) (CategoryTheory.Limits.BinaryFan.associatorOfLimitCone ‚Ñ¨ X Y Z).hom))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.BinaryFan.associatorOfLimitCone ‚Ñ¨ (CategoryTheory.MonoidalOfChosenFiniteProducts.tensorObj ‚Ñ¨ W X) Y Z).hom (CategoryTheory.Limits.BinaryFan.associatorOfLimitCone ‚Ñ¨ W X (CategoryTheory.MonoidalOfChosenFiniteProducts.tensorObj ‚Ñ¨ Y Z)).hom)","decl":"theorem pentagon (W X Y Z : C) :\n    tensorHom ‚Ñ¨ (BinaryFan.associatorOfLimitCone ‚Ñ¨ W X Y).hom (ùüô Z) ‚â´\n        (BinaryFan.associatorOfLimitCone ‚Ñ¨ W (tensorObj ‚Ñ¨ X Y) Z).hom ‚â´\n          tensorHom ‚Ñ¨ (ùüô W) (BinaryFan.associatorOfLimitCone ‚Ñ¨ X Y Z).hom =\n      (BinaryFan.associatorOfLimitCone ‚Ñ¨ (tensorObj ‚Ñ¨ W X) Y Z).hom ‚â´\n        (BinaryFan.associatorOfLimitCone ‚Ñ¨ W X (tensorObj ‚Ñ¨ Y Z)).hom := by\n  dsimp [tensorHom]\n  apply IsLimit.hom_ext (‚Ñ¨ _ _).isLimit; rintro ‚ü®‚ü®‚ü©‚ü©\n  ¬∑ simp\n  ¬∑ apply IsLimit.hom_ext (‚Ñ¨ _ _).isLimit\n    rintro ‚ü®‚ü®‚ü©‚ü©\n    ¬∑ simp\n    apply IsLimit.hom_ext (‚Ñ¨ _ _).isLimit\n    rintro ‚ü®‚ü®‚ü©‚ü©\n    ¬∑ simp\n    ¬∑ simp\n\n"}
{"name":"CategoryTheory.MonoidalOfChosenFiniteProducts.triangle","module":"Mathlib.CategoryTheory.Monoidal.OfChosenFiniteProducts.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nùíØ : CategoryTheory.Limits.LimitCone (CategoryTheory.Functor.empty C)\n‚Ñ¨ : (X Y : C) ‚Üí CategoryTheory.Limits.LimitCone (CategoryTheory.Limits.pair X Y)\nX Y : C\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.BinaryFan.associatorOfLimitCone ‚Ñ¨ X ùíØ.cone.pt Y).hom (CategoryTheory.MonoidalOfChosenFiniteProducts.tensorHom ‚Ñ¨ (CategoryTheory.CategoryStruct.id X) (CategoryTheory.Limits.BinaryFan.leftUnitor ùíØ.isLimit (‚Ñ¨ ùíØ.cone.pt Y).isLimit).hom)) (CategoryTheory.MonoidalOfChosenFiniteProducts.tensorHom ‚Ñ¨ (CategoryTheory.Limits.BinaryFan.rightUnitor ùíØ.isLimit (‚Ñ¨ X ùíØ.cone.pt).isLimit).hom (CategoryTheory.CategoryStruct.id Y))","decl":"theorem triangle (X Y : C) :\n    (BinaryFan.associatorOfLimitCone ‚Ñ¨ X ùíØ.cone.pt Y).hom ‚â´\n        tensorHom ‚Ñ¨ (ùüô X) (BinaryFan.leftUnitor ùíØ.isLimit (‚Ñ¨ ùíØ.cone.pt Y).isLimit).hom =\n      tensorHom ‚Ñ¨ (BinaryFan.rightUnitor ùíØ.isLimit (‚Ñ¨ X ùíØ.cone.pt).isLimit).hom (ùüô Y) := by\n  dsimp [tensorHom]\n  apply IsLimit.hom_ext (‚Ñ¨ _ _).isLimit; rintro ‚ü®‚ü®‚ü©‚ü© <;> simp\n\n"}
{"name":"CategoryTheory.MonoidalOfChosenFiniteProducts.leftUnitor_naturality","module":"Mathlib.CategoryTheory.Monoidal.OfChosenFiniteProducts.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nùíØ : CategoryTheory.Limits.LimitCone (CategoryTheory.Functor.empty C)\n‚Ñ¨ : (X Y : C) ‚Üí CategoryTheory.Limits.LimitCone (CategoryTheory.Limits.pair X Y)\nX‚ÇÅ X‚ÇÇ : C\nf : Quiver.Hom X‚ÇÅ X‚ÇÇ\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalOfChosenFiniteProducts.tensorHom ‚Ñ¨ (CategoryTheory.CategoryStruct.id ùíØ.cone.pt) f) (CategoryTheory.Limits.BinaryFan.leftUnitor ùíØ.isLimit (‚Ñ¨ ùíØ.cone.pt X‚ÇÇ).isLimit).hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.BinaryFan.leftUnitor ùíØ.isLimit (‚Ñ¨ ùíØ.cone.pt X‚ÇÅ).isLimit).hom f)","decl":"theorem leftUnitor_naturality {X‚ÇÅ X‚ÇÇ : C} (f : X‚ÇÅ ‚ü∂ X‚ÇÇ) :\n    tensorHom ‚Ñ¨ (ùüô ùíØ.cone.pt) f ‚â´ (BinaryFan.leftUnitor ùíØ.isLimit (‚Ñ¨ ùíØ.cone.pt X‚ÇÇ).isLimit).hom =\n      (BinaryFan.leftUnitor ùíØ.isLimit (‚Ñ¨ ùíØ.cone.pt X‚ÇÅ).isLimit).hom ‚â´ f := by\n  dsimp [tensorHom]\n  simp\n\n"}
{"name":"CategoryTheory.MonoidalOfChosenFiniteProducts.rightUnitor_naturality","module":"Mathlib.CategoryTheory.Monoidal.OfChosenFiniteProducts.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nùíØ : CategoryTheory.Limits.LimitCone (CategoryTheory.Functor.empty C)\n‚Ñ¨ : (X Y : C) ‚Üí CategoryTheory.Limits.LimitCone (CategoryTheory.Limits.pair X Y)\nX‚ÇÅ X‚ÇÇ : C\nf : Quiver.Hom X‚ÇÅ X‚ÇÇ\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalOfChosenFiniteProducts.tensorHom ‚Ñ¨ f (CategoryTheory.CategoryStruct.id ùíØ.cone.pt)) (CategoryTheory.Limits.BinaryFan.rightUnitor ùíØ.isLimit (‚Ñ¨ X‚ÇÇ ùíØ.cone.pt).isLimit).hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.BinaryFan.rightUnitor ùíØ.isLimit (‚Ñ¨ X‚ÇÅ ùíØ.cone.pt).isLimit).hom f)","decl":"theorem rightUnitor_naturality {X‚ÇÅ X‚ÇÇ : C} (f : X‚ÇÅ ‚ü∂ X‚ÇÇ) :\n    tensorHom ‚Ñ¨ f (ùüô ùíØ.cone.pt) ‚â´ (BinaryFan.rightUnitor ùíØ.isLimit (‚Ñ¨ X‚ÇÇ ùíØ.cone.pt).isLimit).hom =\n      (BinaryFan.rightUnitor ùíØ.isLimit (‚Ñ¨ X‚ÇÅ ùíØ.cone.pt).isLimit).hom ‚â´ f := by\n  dsimp [tensorHom]\n  simp\n\n"}
{"name":"CategoryTheory.MonoidalOfChosenFiniteProducts.associator_naturality","module":"Mathlib.CategoryTheory.Monoidal.OfChosenFiniteProducts.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\n‚Ñ¨ : (X Y : C) ‚Üí CategoryTheory.Limits.LimitCone (CategoryTheory.Limits.pair X Y)\nX‚ÇÅ X‚ÇÇ X‚ÇÉ Y‚ÇÅ Y‚ÇÇ Y‚ÇÉ : C\nf‚ÇÅ : Quiver.Hom X‚ÇÅ Y‚ÇÅ\nf‚ÇÇ : Quiver.Hom X‚ÇÇ Y‚ÇÇ\nf‚ÇÉ : Quiver.Hom X‚ÇÉ Y‚ÇÉ\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalOfChosenFiniteProducts.tensorHom ‚Ñ¨ (CategoryTheory.MonoidalOfChosenFiniteProducts.tensorHom ‚Ñ¨ f‚ÇÅ f‚ÇÇ) f‚ÇÉ) (CategoryTheory.Limits.BinaryFan.associatorOfLimitCone ‚Ñ¨ Y‚ÇÅ Y‚ÇÇ Y‚ÇÉ).hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.BinaryFan.associatorOfLimitCone ‚Ñ¨ X‚ÇÅ X‚ÇÇ X‚ÇÉ).hom (CategoryTheory.MonoidalOfChosenFiniteProducts.tensorHom ‚Ñ¨ f‚ÇÅ (CategoryTheory.MonoidalOfChosenFiniteProducts.tensorHom ‚Ñ¨ f‚ÇÇ f‚ÇÉ)))","decl":"theorem associator_naturality {X‚ÇÅ X‚ÇÇ X‚ÇÉ Y‚ÇÅ Y‚ÇÇ Y‚ÇÉ : C} (f‚ÇÅ : X‚ÇÅ ‚ü∂ Y‚ÇÅ) (f‚ÇÇ : X‚ÇÇ ‚ü∂ Y‚ÇÇ) (f‚ÇÉ : X‚ÇÉ ‚ü∂ Y‚ÇÉ) :\n    tensorHom ‚Ñ¨ (tensorHom ‚Ñ¨ f‚ÇÅ f‚ÇÇ) f‚ÇÉ ‚â´ (BinaryFan.associatorOfLimitCone ‚Ñ¨ Y‚ÇÅ Y‚ÇÇ Y‚ÇÉ).hom =\n      (BinaryFan.associatorOfLimitCone ‚Ñ¨ X‚ÇÅ X‚ÇÇ X‚ÇÉ).hom ‚â´ tensorHom ‚Ñ¨ f‚ÇÅ (tensorHom ‚Ñ¨ f‚ÇÇ f‚ÇÉ) := by\n  dsimp [tensorHom]\n  apply IsLimit.hom_ext (‚Ñ¨ _ _).isLimit; rintro ‚ü®‚ü®‚ü©‚ü©\n  ¬∑ simp\n  ¬∑ apply IsLimit.hom_ext (‚Ñ¨ _ _).isLimit\n    rintro ‚ü®‚ü®‚ü©‚ü©\n    ¬∑ simp\n    ¬∑ simp\n\n"}
