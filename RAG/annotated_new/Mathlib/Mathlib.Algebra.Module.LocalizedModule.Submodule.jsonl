{"name":"Submodule.mem_localized₀","module":"Mathlib.Algebra.Module.LocalizedModule.Submodule","initialProofState":"R : Type u_1\nM : Type u_3\nN : Type u_4\ninst✝⁵ : CommSemiring R\ninst✝⁴ : AddCommMonoid M\ninst✝³ : AddCommMonoid N\ninst✝² : Module R M\ninst✝¹ : Module R N\np : Submonoid R\nf : LinearMap (RingHom.id R) M N\ninst✝ : IsLocalizedModule p f\nM' : Submodule R M\nx : N\n⊢ Iff (Membership.mem (Submodule.localized₀ p f M') x) (Exists fun m => And (Membership.mem M' m) (Exists fun s => Eq (IsLocalizedModule.mk' f m s) x))","decl":"lemma mem_localized₀ (x : N) :\n    x ∈ localized₀ p f M' ↔ ∃ m ∈ M', ∃ s : p, IsLocalizedModule.mk' f m s = x :=\n  Iff.rfl\n\n"}
{"name":"Submodule.mem_localized'","module":"Mathlib.Algebra.Module.LocalizedModule.Submodule","initialProofState":"R : Type u_1\nS : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝¹⁰ : CommSemiring R\ninst✝⁹ : CommSemiring S\ninst✝⁸ : AddCommMonoid M\ninst✝⁷ : AddCommMonoid N\ninst✝⁶ : Module R M\ninst✝⁵ : Module R N\ninst✝⁴ : Algebra R S\ninst✝³ : Module S N\ninst✝² : IsScalarTower R S N\np : Submonoid R\ninst✝¹ : IsLocalization p S\nf : LinearMap (RingHom.id R) M N\ninst✝ : IsLocalizedModule p f\nM' : Submodule R M\nx : N\n⊢ Iff (Membership.mem (Submodule.localized' S p f M') x) (Exists fun m => And (Membership.mem M' m) (Exists fun s => Eq (IsLocalizedModule.mk' f m s) x))","decl":"lemma mem_localized' (x : N) :\n    x ∈ localized' S p f M' ↔ ∃ m ∈ M', ∃ s : p, IsLocalizedModule.mk' f m s = x :=\n  Iff.rfl\n\n"}
{"name":"Submodule.restrictScalars_localized'","module":"Mathlib.Algebra.Module.LocalizedModule.Submodule","initialProofState":"R : Type u_1\nS : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝¹⁰ : CommSemiring R\ninst✝⁹ : CommSemiring S\ninst✝⁸ : AddCommMonoid M\ninst✝⁷ : AddCommMonoid N\ninst✝⁶ : Module R M\ninst✝⁵ : Module R N\ninst✝⁴ : Algebra R S\ninst✝³ : Module S N\ninst✝² : IsScalarTower R S N\np : Submonoid R\ninst✝¹ : IsLocalization p S\nf : LinearMap (RingHom.id R) M N\ninst✝ : IsLocalizedModule p f\nM' : Submodule R M\n⊢ Eq (Submodule.restrictScalars R (Submodule.localized' S p f M')) (Submodule.localized₀ p f M')","decl":"/-- `localized₀` is the same as `localized'` considered as a submodule over the base ring. -/\nlemma restrictScalars_localized' :\n    (localized' S p f M').restrictScalars R = localized₀ p f M' :=\n  rfl\n\n"}
{"name":"Submodule.localized₀_bot","module":"Mathlib.Algebra.Module.LocalizedModule.Submodule","initialProofState":"R : Type u_1\nM : Type u_3\nN : Type u_4\ninst✝⁵ : CommSemiring R\ninst✝⁴ : AddCommMonoid M\ninst✝³ : AddCommMonoid N\ninst✝² : Module R M\ninst✝¹ : Module R N\np : Submonoid R\nf : LinearMap (RingHom.id R) M N\ninst✝ : IsLocalizedModule p f\n⊢ Eq (Submodule.localized₀ p f Bot.bot) Bot.bot","decl":"@[simp]\nlemma localized₀_bot : (⊥ : Submodule R M).localized₀ p f = ⊥ := by\n  rw [← le_bot_iff]\n  rintro _ ⟨_, rfl, s, rfl⟩\n  simp only [IsLocalizedModule.mk'_zero, mem_bot]\n\n"}
{"name":"Submodule.localized'_bot","module":"Mathlib.Algebra.Module.LocalizedModule.Submodule","initialProofState":"R : Type u_1\nS : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝¹⁰ : CommSemiring R\ninst✝⁹ : CommSemiring S\ninst✝⁸ : AddCommMonoid M\ninst✝⁷ : AddCommMonoid N\ninst✝⁶ : Module R M\ninst✝⁵ : Module R N\ninst✝⁴ : Algebra R S\ninst✝³ : Module S N\ninst✝² : IsScalarTower R S N\np : Submonoid R\ninst✝¹ : IsLocalization p S\nf : LinearMap (RingHom.id R) M N\ninst✝ : IsLocalizedModule p f\n⊢ Eq (Submodule.localized' S p f Bot.bot) Bot.bot","decl":"@[simp]\nlemma localized'_bot : (⊥ : Submodule R M).localized' S p f = ⊥ :=\n  SetLike.ext' (by apply SetLike.ext'_iff.mp <| Submodule.localized₀_bot p f)\n\n"}
{"name":"Submodule.localized₀_top","module":"Mathlib.Algebra.Module.LocalizedModule.Submodule","initialProofState":"R : Type u_1\nM : Type u_3\nN : Type u_4\ninst✝⁵ : CommSemiring R\ninst✝⁴ : AddCommMonoid M\ninst✝³ : AddCommMonoid N\ninst✝² : Module R M\ninst✝¹ : Module R N\np : Submonoid R\nf : LinearMap (RingHom.id R) M N\ninst✝ : IsLocalizedModule p f\n⊢ Eq (Submodule.localized₀ p f Top.top) Top.top","decl":"@[simp]\nlemma localized₀_top : (⊤ : Submodule R M).localized₀ p f = ⊤ := by\n  rw [← top_le_iff]\n  rintro x _\n  obtain ⟨⟨x, s⟩, rfl⟩ := IsLocalizedModule.mk'_surjective p f x\n  exact ⟨x, trivial, s, rfl⟩\n\n"}
{"name":"Submodule.localized'_top","module":"Mathlib.Algebra.Module.LocalizedModule.Submodule","initialProofState":"R : Type u_1\nS : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝¹⁰ : CommSemiring R\ninst✝⁹ : CommSemiring S\ninst✝⁸ : AddCommMonoid M\ninst✝⁷ : AddCommMonoid N\ninst✝⁶ : Module R M\ninst✝⁵ : Module R N\ninst✝⁴ : Algebra R S\ninst✝³ : Module S N\ninst✝² : IsScalarTower R S N\np : Submonoid R\ninst✝¹ : IsLocalization p S\nf : LinearMap (RingHom.id R) M N\ninst✝ : IsLocalizedModule p f\n⊢ Eq (Submodule.localized' S p f Top.top) Top.top","decl":"@[simp]\nlemma localized'_top : (⊤ : Submodule R M).localized' S p f = ⊤ :=\n  SetLike.ext' (by apply SetLike.ext'_iff.mp <| Submodule.localized₀_top p f)\n\n"}
{"name":"Submodule.localized'_span","module":"Mathlib.Algebra.Module.LocalizedModule.Submodule","initialProofState":"R : Type u_1\nS : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝¹⁰ : CommSemiring R\ninst✝⁹ : CommSemiring S\ninst✝⁸ : AddCommMonoid M\ninst✝⁷ : AddCommMonoid N\ninst✝⁶ : Module R M\ninst✝⁵ : Module R N\ninst✝⁴ : Algebra R S\ninst✝³ : Module S N\ninst✝² : IsScalarTower R S N\np : Submonoid R\ninst✝¹ : IsLocalization p S\nf : LinearMap (RingHom.id R) M N\ninst✝ : IsLocalizedModule p f\ns : Set M\n⊢ Eq (Submodule.localized' S p f (Submodule.span R s)) (Submodule.span S (Set.image (⇑f) s))","decl":"@[simp]\nlemma localized'_span (s : Set M) : (span R s).localized' S p f = span S (f '' s) := by\n  apply le_antisymm\n  · rintro _ ⟨x, hx, t, rfl⟩\n    have := IsLocalizedModule.mk'_smul_mk' S f 1 x t 1\n    simp only [IsLocalizedModule.mk'_one, one_smul, mul_one] at this\n    rw [← this]\n    apply Submodule.smul_mem\n    rw [← Submodule.restrictScalars_mem R, ← Submodule.mem_comap]\n    refine (show span R s ≤ _ from ?_) hx\n    rw [← Submodule.map_le_iff_le_comap, Submodule.map_span]\n    exact span_le_restrictScalars _ _ _\n  · rw [Submodule.span_le, Set.image_subset_iff]\n    intro x hx\n    exact ⟨x, subset_span hx, 1, IsLocalizedModule.mk'_one _ _ _⟩\n\n"}
{"name":"Submodule.toLocalized₀_apply_coe","module":"Mathlib.Algebra.Module.LocalizedModule.Submodule","initialProofState":"R : Type u_1\nM : Type u_3\nN : Type u_4\ninst✝⁵ : CommSemiring R\ninst✝⁴ : AddCommMonoid M\ninst✝³ : AddCommMonoid N\ninst✝² : Module R M\ninst✝¹ : Module R N\np : Submonoid R\nf : LinearMap (RingHom.id R) M N\ninst✝ : IsLocalizedModule p f\nM' : Submodule R M\nc : Subtype fun x => Membership.mem M' x\n⊢ Eq (↑((Submodule.toLocalized₀ p f M') c)) (f ↑c)","decl":"/-- The localization map of a submodule. -/\n@[simps!]\ndef toLocalized₀ : M' →ₗ[R] M'.localized₀ p f := f.restrict fun x hx ↦ ⟨x, hx, 1, by simp⟩\n\n"}
{"name":"Submodule.toLocalized'_apply_coe","module":"Mathlib.Algebra.Module.LocalizedModule.Submodule","initialProofState":"R : Type u_1\nS : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁹ : CommSemiring R\ninst✝⁸ : CommSemiring S\ninst✝⁷ : AddCommMonoid M\ninst✝⁶ : AddCommMonoid N\ninst✝⁵ : Module R M\ninst✝⁴ : Module R N\ninst✝³ : Algebra R S\ninst✝² : Module S N\ninst✝¹ : IsScalarTower R S N\np : Submonoid R\nf : LinearMap (RingHom.id R) M N\ninst✝ : IsLocalizedModule p f\nM' : Submodule R M\nc : Subtype fun x => Membership.mem M' x\n⊢ Eq (↑((Submodule.toLocalized' S p f M') c)) (f ↑c)","decl":"/-- The localization map of a submodule. -/\n@[simps!]\ndef toLocalized' : M' →ₗ[R] M'.localized' S p f := toLocalized₀ p f M'\n\n"}
{"name":"Submodule.instIsLocalizedModuleSubtypeMemLocalized₀ToLocalized₀","module":"Mathlib.Algebra.Module.LocalizedModule.Submodule","initialProofState":"R : Type u_1\nM : Type u_3\nN : Type u_4\ninst✝⁵ : CommSemiring R\ninst✝⁴ : AddCommMonoid M\ninst✝³ : AddCommMonoid N\ninst✝² : Module R M\ninst✝¹ : Module R N\np : Submonoid R\nf : LinearMap (RingHom.id R) M N\ninst✝ : IsLocalizedModule p f\nM' : Submodule R M\n⊢ IsLocalizedModule p (Submodule.toLocalized₀ p f M')","decl":"instance : IsLocalizedModule p (M'.toLocalized₀ p f) where\n  map_units x := by\n    simp_rw [Module.End_isUnit_iff]\n    constructor\n    · exact fun _ _ e ↦ Subtype.ext\n        (IsLocalizedModule.smul_injective f x (congr_arg Subtype.val e))\n    · rintro ⟨_, m, hm, s, rfl⟩\n      refine ⟨⟨IsLocalizedModule.mk' f m (s * x), ⟨_, hm, _, rfl⟩⟩, Subtype.ext ?_⟩\n      rw [Module.algebraMap_end_apply, SetLike.val_smul_of_tower,\n        ← IsLocalizedModule.mk'_smul, ← Submonoid.smul_def, IsLocalizedModule.mk'_cancel_right]\n  surj' := by\n    rintro ⟨y, x, hx, s, rfl⟩\n    exact ⟨⟨⟨x, hx⟩, s⟩, by ext; simp⟩\n  exists_of_eq e := by simpa [Subtype.ext_iff] using\n      IsLocalizedModule.exists_of_eq (S := p) (f := f) (congr_arg Subtype.val e)\n\n"}
{"name":"Submodule.isLocalizedModule","module":"Mathlib.Algebra.Module.LocalizedModule.Submodule","initialProofState":"R : Type u_1\nS : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁹ : CommSemiring R\ninst✝⁸ : CommSemiring S\ninst✝⁷ : AddCommMonoid M\ninst✝⁶ : AddCommMonoid N\ninst✝⁵ : Module R M\ninst✝⁴ : Module R N\ninst✝³ : Algebra R S\ninst✝² : Module S N\ninst✝¹ : IsScalarTower R S N\np : Submonoid R\nf : LinearMap (RingHom.id R) M N\ninst✝ : IsLocalizedModule p f\nM' : Submodule R M\n⊢ IsLocalizedModule p (Submodule.toLocalized' S p f M')","decl":"instance isLocalizedModule : IsLocalizedModule p (M'.toLocalized' S p f) :=\n  inferInstanceAs (IsLocalizedModule p (M'.toLocalized₀ p f))\n\n"}
{"name":"Submodule.localized₀_le_localized₀_of_smul_le","module":"Mathlib.Algebra.Module.LocalizedModule.Submodule","initialProofState":"R : Type u_1\nM : Type u_3\nN : Type u_4\ninst✝⁵ : CommSemiring R\ninst✝⁴ : AddCommMonoid M\ninst✝³ : AddCommMonoid N\ninst✝² : Module R M\ninst✝¹ : Module R N\np : Submonoid R\nf : LinearMap (RingHom.id R) M N\ninst✝ : IsLocalizedModule p f\nP Q : Submodule R M\nx : Subtype fun x => Membership.mem p x\nh : LE.le (HSMul.hSMul x P) Q\n⊢ LE.le (Submodule.localized₀ p f P) (Submodule.localized₀ p f Q)","decl":"lemma localized₀_le_localized₀_of_smul_le {P Q : Submodule R M} (x : p) (h : x • P ≤ Q) :\n    P.localized₀ p f ≤ Q.localized₀ p f := by\n  rintro - ⟨a, ha, r, rfl⟩\n  refine ⟨x • a, h ⟨a, ha, rfl⟩, x * r, ?_⟩\n  simp\n\n"}
{"name":"Submodule.localized'_le_localized'_of_smul_le","module":"Mathlib.Algebra.Module.LocalizedModule.Submodule","initialProofState":"R : Type u_1\nS : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝¹⁰ : CommSemiring R\ninst✝⁹ : CommSemiring S\ninst✝⁸ : AddCommMonoid M\ninst✝⁷ : AddCommMonoid N\ninst✝⁶ : Module R M\ninst✝⁵ : Module R N\ninst✝⁴ : Algebra R S\ninst✝³ : Module S N\ninst✝² : IsScalarTower R S N\np : Submonoid R\ninst✝¹ : IsLocalization p S\nf : LinearMap (RingHom.id R) M N\ninst✝ : IsLocalizedModule p f\nP Q : Submodule R M\nx : Subtype fun x => Membership.mem p x\nh : LE.le (HSMul.hSMul x P) Q\n⊢ LE.le (Submodule.localized' S p f P) (Submodule.localized' S p f Q)","decl":"lemma localized'_le_localized'_of_smul_le {P Q : Submodule R M} (x : p) (h : x • P ≤ Q) :\n    P.localized' S p f ≤ Q.localized' S p f :=\n  localized₀_le_localized₀_of_smul_le p f x h\n\n"}
{"name":"Submodule.toLocalizedQuotient'_mk","module":"Mathlib.Algebra.Module.LocalizedModule.Submodule","initialProofState":"R : Type u_5\nS : Type u_6\nM : Type u_7\nN : Type u_8\ninst✝¹⁰ : CommRing R\ninst✝⁹ : CommRing S\ninst✝⁸ : AddCommGroup M\ninst✝⁷ : AddCommGroup N\ninst✝⁶ : Module R M\ninst✝⁵ : Module R N\ninst✝⁴ : Algebra R S\ninst✝³ : Module S N\ninst✝² : IsScalarTower R S N\np : Submonoid R\ninst✝¹ : IsLocalization p S\nf : LinearMap (RingHom.id R) M N\ninst✝ : IsLocalizedModule p f\nM' : Submodule R M\nx : M\n⊢ Eq ((Submodule.toLocalizedQuotient' S p f M') (Submodule.Quotient.mk x)) (Submodule.Quotient.mk (f x))","decl":"@[simp]\nlemma Submodule.toLocalizedQuotient'_mk (x : M) :\n    M'.toLocalizedQuotient' S p f (Submodule.Quotient.mk x) = Submodule.Quotient.mk (f x) := rfl\n\n"}
{"name":"IsLocalizedModule.toLocalizedQuotient'","module":"Mathlib.Algebra.Module.LocalizedModule.Submodule","initialProofState":"R : Type u_5\nS : Type u_6\nM : Type u_7\nN : Type u_8\ninst✝⁹ : CommRing R\ninst✝⁸ : CommRing S\ninst✝⁷ : AddCommGroup M\ninst✝⁶ : AddCommGroup N\ninst✝⁵ : Module R M\ninst✝⁴ : Module R N\ninst✝³ : Algebra R S\ninst✝² : Module S N\ninst✝¹ : IsScalarTower R S N\np : Submonoid R\nf : LinearMap (RingHom.id R) M N\ninst✝ : IsLocalizedModule p f\nM' : Submodule R M\n⊢ IsLocalizedModule p (Submodule.toLocalizedQuotient' S p f M')","decl":"open Submodule Submodule.Quotient IsLocalization in\ninstance IsLocalizedModule.toLocalizedQuotient' (M' : Submodule R M) :\n    IsLocalizedModule p (M'.toLocalizedQuotient' S p f) where\n  map_units x := by\n    refine (Module.End_isUnit_iff _).mpr ⟨fun m n e ↦ ?_, fun m ↦ ⟨(IsLocalization.mk' S 1 x) • m,\n        by rw [Module.algebraMap_end_apply, ← smul_assoc, smul_mk'_one, mk'_self', one_smul]⟩⟩\n    obtain ⟨⟨m, rfl⟩, n, rfl⟩ := PProd.mk (mk_surjective _ m) (mk_surjective _ n)\n    simp only [Module.algebraMap_end_apply, ← mk_smul, Submodule.Quotient.eq, ← smul_sub] at e\n    replace e := Submodule.smul_mem _ (IsLocalization.mk' S 1 x) e\n    rwa [smul_comm, ← smul_assoc, smul_mk'_one, mk'_self', one_smul, ← Submodule.Quotient.eq] at e\n  surj' y := by\n    obtain ⟨y, rfl⟩ := mk_surjective _ y\n    obtain ⟨⟨y, s⟩, rfl⟩ := IsLocalizedModule.mk'_surjective p f y\n    exact ⟨⟨Submodule.Quotient.mk y, s⟩,\n      by simp only [Function.uncurry_apply_pair, toLocalizedQuotient'_mk, ← mk_smul, mk'_cancel']⟩\n  exists_of_eq {m n} e := by\n    obtain ⟨⟨m, rfl⟩, n, rfl⟩ := PProd.mk (mk_surjective _ m) (mk_surjective _ n)\n    obtain ⟨x, hx, s, hs⟩ : f (m - n) ∈ _ := by simpa [Submodule.Quotient.eq] using e\n    obtain ⟨c, hc⟩ := exists_of_eq (S := p) (show f (s • (m - n)) = f x by simp [-map_sub, ← hs])\n    exact ⟨c * s, by simpa only [← Quotient.mk_smul, Submodule.Quotient.eq,\n      ← smul_sub, mul_smul, hc] using M'.smul_mem c hx⟩\n\n"}
{"name":"instIsLocalizedModuleQuotientSubmoduleLocalizedModuleLocalizationLocalizedToLocalizedQuotient","module":"Mathlib.Algebra.Module.LocalizedModule.Submodule","initialProofState":"R : Type u_5\nM : Type u_7\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\np : Submonoid R\nM' : Submodule R M\n⊢ IsLocalizedModule p (Submodule.toLocalizedQuotient p M')","decl":"instance (M' : Submodule R M) : IsLocalizedModule p (M'.toLocalizedQuotient p) :=\n  IsLocalizedModule.toLocalizedQuotient' _ _ _ _\n\n"}
{"name":"LinearMap.ker_localizedMap_eq_localized₀_ker","module":"Mathlib.Algebra.Module.LocalizedModule.Submodule","initialProofState":"R : Type u_1\nM : Type u_3\nN : Type u_4\ninst✝¹⁰ : CommSemiring R\ninst✝⁹ : AddCommMonoid M\ninst✝⁸ : AddCommMonoid N\ninst✝⁷ : Module R M\ninst✝⁶ : Module R N\np : Submonoid R\nf : LinearMap (RingHom.id R) M N\ninst✝⁵ : IsLocalizedModule p f\nP : Type u_5\ninst✝⁴ : AddCommMonoid P\ninst✝³ : Module R P\nQ : Type u_6\ninst✝² : AddCommMonoid Q\ninst✝¹ : Module R Q\nf' : LinearMap (RingHom.id R) P Q\ninst✝ : IsLocalizedModule p f'\ng : LinearMap (RingHom.id R) M P\n⊢ Eq (LinearMap.ker ((IsLocalizedModule.map p f f') g)) (Submodule.localized₀ p f (LinearMap.ker g))","decl":"lemma ker_localizedMap_eq_localized₀_ker (g : M →ₗ[R] P) :\n    ker (map p f f' g) = (ker g).localized₀ p f := by\n  ext x\n  simp only [Submodule.mem_localized₀, mem_ker]\n  refine ⟨fun h ↦ ?_, ?_⟩\n  · obtain ⟨⟨a, b⟩, rfl⟩ := IsLocalizedModule.mk'_surjective p f x\n    simp only [Function.uncurry_apply_pair, map_mk', mk'_eq_zero, eq_zero_iff p f'] at h\n    obtain ⟨c, hc⟩ := h\n    refine ⟨c • a, by simpa, c * b, by simp⟩\n  · rintro ⟨m, hm, a, ha, rfl⟩\n    simp [IsLocalizedModule.map_mk', hm]\n\n"}
{"name":"LinearMap.localized'_ker_eq_ker_localizedMap","module":"Mathlib.Algebra.Module.LocalizedModule.Submodule","initialProofState":"R : Type u_1\nS : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝¹⁷ : CommSemiring R\ninst✝¹⁶ : CommSemiring S\ninst✝¹⁵ : AddCommMonoid M\ninst✝¹⁴ : AddCommMonoid N\ninst✝¹³ : Module R M\ninst✝¹² : Module R N\ninst✝¹¹ : Algebra R S\ninst✝¹⁰ : Module S N\ninst✝⁹ : IsScalarTower R S N\np : Submonoid R\ninst✝⁸ : IsLocalization p S\nf : LinearMap (RingHom.id R) M N\ninst✝⁷ : IsLocalizedModule p f\nP : Type u_5\ninst✝⁶ : AddCommMonoid P\ninst✝⁵ : Module R P\nQ : Type u_6\ninst✝⁴ : AddCommMonoid Q\ninst✝³ : Module R Q\ninst✝² : Module S Q\ninst✝¹ : IsScalarTower R S Q\nf' : LinearMap (RingHom.id R) P Q\ninst✝ : IsLocalizedModule p f'\ng : LinearMap (RingHom.id R) M P\n⊢ Eq (Submodule.localized' S p f (LinearMap.ker g)) (LinearMap.ker (LinearMap.extendScalarsOfIsLocalization p S ((IsLocalizedModule.map p f f') g)))","decl":"lemma localized'_ker_eq_ker_localizedMap (g : M →ₗ[R] P) :\n    (ker g).localized' S p f = ker ((map p f f' g).extendScalarsOfIsLocalization p S) :=\n  SetLike.ext (by apply SetLike.ext_iff.mp (f.ker_localizedMap_eq_localized₀_ker p f' g).symm)\n\n"}
{"name":"LinearMap.ker_localizedMap_eq_localized'_ker","module":"Mathlib.Algebra.Module.LocalizedModule.Submodule","initialProofState":"R : Type u_1\nS : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝¹⁷ : CommSemiring R\ninst✝¹⁶ : CommSemiring S\ninst✝¹⁵ : AddCommMonoid M\ninst✝¹⁴ : AddCommMonoid N\ninst✝¹³ : Module R M\ninst✝¹² : Module R N\ninst✝¹¹ : Algebra R S\ninst✝¹⁰ : Module S N\ninst✝⁹ : IsScalarTower R S N\np : Submonoid R\ninst✝⁸ : IsLocalization p S\nf : LinearMap (RingHom.id R) M N\ninst✝⁷ : IsLocalizedModule p f\nP : Type u_5\ninst✝⁶ : AddCommMonoid P\ninst✝⁵ : Module R P\nQ : Type u_6\ninst✝⁴ : AddCommMonoid Q\ninst✝³ : Module R Q\ninst✝² : Module S Q\ninst✝¹ : IsScalarTower R S Q\nf' : LinearMap (RingHom.id R) P Q\ninst✝ : IsLocalizedModule p f'\ng : LinearMap (RingHom.id R) M P\n⊢ Eq (LinearMap.ker ((IsLocalizedModule.map p f f') g)) (Submodule.restrictScalars R (Submodule.localized' S p f (LinearMap.ker g)))","decl":"lemma ker_localizedMap_eq_localized'_ker (g : M →ₗ[R] P) :\n    ker (map p f f' g) = ((ker g).localized' S p f).restrictScalars _ := by\n  ext\n  simp [localized'_ker_eq_ker_localizedMap S p f f']\n\n"}
{"name":"LinearMap.toKerIsLocalized_apply_coe","module":"Mathlib.Algebra.Module.LocalizedModule.Submodule","initialProofState":"R : Type u_1\nM : Type u_3\nN : Type u_4\ninst✝¹⁰ : CommSemiring R\ninst✝⁹ : AddCommMonoid M\ninst✝⁸ : AddCommMonoid N\ninst✝⁷ : Module R M\ninst✝⁶ : Module R N\np : Submonoid R\nf : LinearMap (RingHom.id R) M N\ninst✝⁵ : IsLocalizedModule p f\nP : Type u_5\ninst✝⁴ : AddCommMonoid P\ninst✝³ : Module R P\nQ : Type u_6\ninst✝² : AddCommMonoid Q\ninst✝¹ : Module R Q\nf' : LinearMap (RingHom.id R) P Q\ninst✝ : IsLocalizedModule p f'\ng : LinearMap (RingHom.id R) M P\nc : Subtype fun x => Membership.mem (LinearMap.ker g) x\n⊢ Eq (↑((LinearMap.toKerIsLocalized p f f' g) c)) (f ↑c)","decl":"/--\nThe canonical map from the kernel of `g` to the kernel of `g` localized at a submonoid.\n\nThis is a localization map by `LinearMap.toKerLocalized_isLocalizedModule`.\n-/\n@[simps!]\nnoncomputable def toKerIsLocalized (g : M →ₗ[R] P) :\n    ker g →ₗ[R] ker (map p f f' g) :=\n  f.restrict (fun x hx ↦ by simp [mem_ker, mem_ker.mp hx])\n\n"}
{"name":"LinearMap.toKerLocalized_isLocalizedModule","module":"Mathlib.Algebra.Module.LocalizedModule.Submodule","initialProofState":"R : Type u_1\nS : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝¹⁷ : CommSemiring R\ninst✝¹⁶ : CommSemiring S\ninst✝¹⁵ : AddCommMonoid M\ninst✝¹⁴ : AddCommMonoid N\ninst✝¹³ : Module R M\ninst✝¹² : Module R N\ninst✝¹¹ : Algebra R S\ninst✝¹⁰ : Module S N\ninst✝⁹ : IsScalarTower R S N\np : Submonoid R\ninst✝⁸ : IsLocalization p S\nf : LinearMap (RingHom.id R) M N\ninst✝⁷ : IsLocalizedModule p f\nP : Type u_5\ninst✝⁶ : AddCommMonoid P\ninst✝⁵ : Module R P\nQ : Type u_6\ninst✝⁴ : AddCommMonoid Q\ninst✝³ : Module R Q\ninst✝² : Module S Q\ninst✝¹ : IsScalarTower R S Q\nf' : LinearMap (RingHom.id R) P Q\ninst✝ : IsLocalizedModule p f'\ng : LinearMap (RingHom.id R) M P\n⊢ IsLocalizedModule p (LinearMap.toKerIsLocalized p f f' g)","decl":"include S in\n/-- The canonical map to the kernel of the localization of `g` is localizing.\nIn other words, localization commutes with kernels. -/\nlemma toKerLocalized_isLocalizedModule (g : M →ₗ[R] P) :\n    IsLocalizedModule p (toKerIsLocalized p f f' g) :=\n  let e : Submodule.localized' S p f (ker g) ≃ₗ[S]\n      ker ((map p f f' g).extendScalarsOfIsLocalization p S) :=\n    LinearEquiv.ofEq _ _ (localized'_ker_eq_ker_localizedMap S p f f' g)\n  IsLocalizedModule.of_linearEquiv p (Submodule.toLocalized' S p f (ker g)) (e.restrictScalars R)\n\n"}
{"name":"LinearMap.range_localizedMap_eq_localized₀_range","module":"Mathlib.Algebra.Module.LocalizedModule.Submodule","initialProofState":"R : Type u_1\nM : Type u_3\nN : Type u_4\ninst✝¹⁰ : CommSemiring R\ninst✝⁹ : AddCommMonoid M\ninst✝⁸ : AddCommMonoid N\ninst✝⁷ : Module R M\ninst✝⁶ : Module R N\np : Submonoid R\nf : LinearMap (RingHom.id R) M N\ninst✝⁵ : IsLocalizedModule p f\nP : Type u_5\ninst✝⁴ : AddCommMonoid P\ninst✝³ : Module R P\nQ : Type u_6\ninst✝² : AddCommMonoid Q\ninst✝¹ : Module R Q\nf' : LinearMap (RingHom.id R) P Q\ninst✝ : IsLocalizedModule p f'\ng : LinearMap (RingHom.id R) M P\n⊢ Eq (LinearMap.range ((IsLocalizedModule.map p f f') g)) (Submodule.localized₀ p f' (LinearMap.range g))","decl":"lemma range_localizedMap_eq_localized₀_range (g : M →ₗ[R] P) :\n    range (map p f f' g) = (range g).localized₀ p f' := by\n  ext; simp [mem_localized₀, mem_range, (mk'_surjective p f).exists]\n\n"}
{"name":"LinearMap.localized'_range_eq_range_localizedMap","module":"Mathlib.Algebra.Module.LocalizedModule.Submodule","initialProofState":"R : Type u_1\nS : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝¹⁷ : CommSemiring R\ninst✝¹⁶ : CommSemiring S\ninst✝¹⁵ : AddCommMonoid M\ninst✝¹⁴ : AddCommMonoid N\ninst✝¹³ : Module R M\ninst✝¹² : Module R N\ninst✝¹¹ : Algebra R S\ninst✝¹⁰ : Module S N\ninst✝⁹ : IsScalarTower R S N\np : Submonoid R\ninst✝⁸ : IsLocalization p S\nf : LinearMap (RingHom.id R) M N\ninst✝⁷ : IsLocalizedModule p f\nP : Type u_5\ninst✝⁶ : AddCommMonoid P\ninst✝⁵ : Module R P\nQ : Type u_6\ninst✝⁴ : AddCommMonoid Q\ninst✝³ : Module R Q\ninst✝² : Module S Q\ninst✝¹ : IsScalarTower R S Q\nf' : LinearMap (RingHom.id R) P Q\ninst✝ : IsLocalizedModule p f'\ng : LinearMap (RingHom.id R) M P\n⊢ Eq (Submodule.localized' S p f' (LinearMap.range g)) (LinearMap.range (LinearMap.extendScalarsOfIsLocalization p S ((IsLocalizedModule.map p f f') g)))","decl":"/-- Localization commutes with ranges. -/\nlemma localized'_range_eq_range_localizedMap (g : M →ₗ[R] P) :\n    (range g).localized' S p f' = range ((map p f f' g).extendScalarsOfIsLocalization p S) :=\n  SetLike.ext (by apply SetLike.ext_iff.mp (f.range_localizedMap_eq_localized₀_range p f' g).symm)\n\n"}
