{"name":"Polynomial.isNilpotent_C_mul_pow_X_of_isNilpotent","module":"Mathlib.RingTheory.Polynomial.Nilpotent","initialProofState":"R : Type u_1\nr : R\ninst✝ : Semiring R\nn : Nat\nhnil : IsNilpotent r\n⊢ IsNilpotent (HMul.hMul (Polynomial.C r) (HPow.hPow Polynomial.X n))","decl":"lemma isNilpotent_C_mul_pow_X_of_isNilpotent (n : ℕ) (hnil : IsNilpotent r) :\n    IsNilpotent ((C r) * X ^ n) := by\n  refine Commute.isNilpotent_mul_left (commute_X_pow _ _).symm ?_\n  obtain ⟨m, hm⟩ := hnil\n  refine ⟨m, ?_⟩\n  rw [← C_pow, hm, C_0]\n\n"}
{"name":"Polynomial.isNilpotent_pow_X_mul_C_of_isNilpotent","module":"Mathlib.RingTheory.Polynomial.Nilpotent","initialProofState":"R : Type u_1\nr : R\ninst✝ : Semiring R\nn : Nat\nhnil : IsNilpotent r\n⊢ IsNilpotent (HMul.hMul (HPow.hPow Polynomial.X n) (Polynomial.C r))","decl":"lemma isNilpotent_pow_X_mul_C_of_isNilpotent (n : ℕ) (hnil : IsNilpotent r) :\n    IsNilpotent (X ^ n * (C r)) := by\n  rw [commute_X_pow]\n  exact isNilpotent_C_mul_pow_X_of_isNilpotent n hnil\n\n"}
{"name":"Polynomial.isNilpotent_monomial_iff","module":"Mathlib.RingTheory.Polynomial.Nilpotent","initialProofState":"R : Type u_1\nr : R\ninst✝ : Semiring R\nn : Nat\n⊢ Iff (IsNilpotent ((Polynomial.monomial n) r)) (IsNilpotent r)","decl":"@[simp] lemma isNilpotent_monomial_iff {n : ℕ} :\n    IsNilpotent (monomial (R := R) n r) ↔ IsNilpotent r :=\n  exists_congr fun k ↦ by simp\n\n"}
{"name":"Polynomial.isNilpotent_C_iff","module":"Mathlib.RingTheory.Polynomial.Nilpotent","initialProofState":"R : Type u_1\nr : R\ninst✝ : Semiring R\n⊢ Iff (IsNilpotent (Polynomial.C r)) (IsNilpotent r)","decl":"@[simp] lemma isNilpotent_C_iff :\n    IsNilpotent (C r) ↔ IsNilpotent r :=\n  exists_congr fun k ↦ by simpa only [← C_pow] using C_eq_zero\n\n"}
{"name":"Polynomial.isNilpotent_X_mul_iff","module":"Mathlib.RingTheory.Polynomial.Nilpotent","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nP : Polynomial R\n⊢ Iff (IsNilpotent (HMul.hMul Polynomial.X P)) (IsNilpotent P)","decl":"@[simp] lemma isNilpotent_X_mul_iff :\n    IsNilpotent (X * P) ↔ IsNilpotent P := by\n  refine ⟨fun h ↦ ?_, ?_⟩\n  · rwa [Commute.isNilpotent_mul_right_iff (commute_X P) (by simp)] at h\n  · rintro ⟨k, hk⟩\n    exact ⟨k, by simp [(commute_X P).mul_pow, hk]⟩\n\n"}
{"name":"Polynomial.isNilpotent_mul_X_iff","module":"Mathlib.RingTheory.Polynomial.Nilpotent","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nP : Polynomial R\n⊢ Iff (IsNilpotent (HMul.hMul P Polynomial.X)) (IsNilpotent P)","decl":"@[simp] lemma isNilpotent_mul_X_iff :\n    IsNilpotent (P * X) ↔ IsNilpotent P := by\n  rw [← commute_X P]\n  exact isNilpotent_X_mul_iff\n\n"}
{"name":"Polynomial.isNilpotent_iff","module":"Mathlib.RingTheory.Polynomial.Nilpotent","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nP : Polynomial R\n⊢ Iff (IsNilpotent P) (∀ (i : Nat), IsNilpotent (P.coeff i))","decl":"protected lemma isNilpotent_iff :\n    IsNilpotent P ↔ ∀ i, IsNilpotent (coeff P i) := by\n  refine\n    ⟨P.recOnHorner (by simp) (fun p r hp₀ _ hp hpr i ↦ ?_) (fun p _ hnp hpX i ↦ ?_), fun h ↦ ?_⟩\n  · rw [← sum_monomial_eq P]\n    exact isNilpotent_sum (fun i _ ↦ by simpa only [isNilpotent_monomial_iff] using h i)\n  · have hr : IsNilpotent (C r) := by\n      obtain ⟨k, hk⟩ := hpr\n      replace hp : eval 0 p = 0 := by rwa [coeff_zero_eq_aeval_zero] at hp₀\n      refine isNilpotent_C_iff.mpr ⟨k, ?_⟩\n      simpa [coeff_zero_eq_aeval_zero, hp] using congr_arg (fun q ↦ coeff q 0) hk\n    cases' i with i\n    · simpa [hp₀] using hr\n    simp only [coeff_add, coeff_C_succ, add_zero]\n    apply hp\n    simpa using Commute.isNilpotent_sub (Commute.all _ _) hpr hr\n  · cases' i with i\n    · simp\n    simpa using hnp (isNilpotent_mul_X_iff.mp hpX) i\n\n"}
{"name":"Polynomial.isNilpotent_reflect_iff","module":"Mathlib.RingTheory.Polynomial.Nilpotent","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nP : Polynomial R\nN : Nat\nhN : LE.le P.natDegree N\n⊢ Iff (IsNilpotent (Polynomial.reflect N P)) (IsNilpotent P)","decl":"@[simp] lemma isNilpotent_reflect_iff {P : R[X]} {N : ℕ} (hN : P.natDegree ≤ N) :\n    IsNilpotent (reflect N P) ↔ IsNilpotent P := by\n  simp only [Polynomial.isNilpotent_iff, coeff_reverse]\n  refine ⟨fun h i ↦ ?_, fun h i ↦ ?_⟩ <;> rcases le_or_lt i N with hi | hi\n  · simpa [tsub_tsub_cancel_of_le hi] using h (N - i)\n  · simp [coeff_eq_zero_of_natDegree_lt <| lt_of_le_of_lt hN hi]\n  · simpa [hi, revAt_le] using h (N - i)\n  · simpa [revAt_eq_self_of_lt hi] using h i\n\n"}
{"name":"Polynomial.isNilpotent_reverse_iff","module":"Mathlib.RingTheory.Polynomial.Nilpotent","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nP : Polynomial R\n⊢ Iff (IsNilpotent P.reverse) (IsNilpotent P)","decl":"@[simp] lemma isNilpotent_reverse_iff :\n    IsNilpotent P.reverse ↔ IsNilpotent P :=\n  isNilpotent_reflect_iff (le_refl _)\n\n"}
{"name":"Polynomial.isUnit_of_coeff_isUnit_isNilpotent","module":"Mathlib.RingTheory.Polynomial.Nilpotent","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nP : Polynomial R\nhunit : IsUnit (P.coeff 0)\nhnil : ∀ (i : Nat), Ne i 0 → IsNilpotent (P.coeff i)\n⊢ IsUnit P","decl":"/-- Let `P` be a polynomial over `R`. If its constant term is a unit and its other coefficients are\nnilpotent, then `P` is a unit.\n\nSee also `Polynomial.isUnit_iff_coeff_isUnit_isNilpotent`. -/\ntheorem isUnit_of_coeff_isUnit_isNilpotent (hunit : IsUnit (P.coeff 0))\n    (hnil : ∀ i, i ≠ 0 → IsNilpotent (P.coeff i)) : IsUnit P := by\n  induction' h : P.natDegree using Nat.strong_induction_on with k hind generalizing P\n  by_cases hdeg : P.natDegree = 0\n  { rw [eq_C_of_natDegree_eq_zero hdeg]\n    exact hunit.map C }\n  set P₁ := P.eraseLead with hP₁\n  suffices IsUnit P₁ by\n    rw [← eraseLead_add_monomial_natDegree_leadingCoeff P, ← C_mul_X_pow_eq_monomial, ← hP₁]\n    refine IsNilpotent.isUnit_add_left_of_commute ?_ this (Commute.all _ _)\n    exact isNilpotent_C_mul_pow_X_of_isNilpotent _ (hnil _ hdeg)\n  have hdeg₂ := lt_of_le_of_lt P.eraseLead_natDegree_le (Nat.sub_lt\n    (Nat.pos_of_ne_zero hdeg) zero_lt_one)\n  refine hind P₁.natDegree ?_ ?_ (fun i hi => ?_) rfl\n  · simp_rw [P₁, ← h, hdeg₂]\n  · simp_rw [P₁, eraseLead_coeff_of_ne _ (Ne.symm hdeg), hunit]\n  · by_cases H : i ≤ P₁.natDegree\n    · simp_rw [P₁, eraseLead_coeff_of_ne _ (ne_of_lt (lt_of_le_of_lt H hdeg₂)), hnil i hi]\n    · simp_rw [coeff_eq_zero_of_natDegree_lt (lt_of_not_ge H), IsNilpotent.zero]\n\n"}
{"name":"Polynomial.coeff_isUnit_isNilpotent_of_isUnit","module":"Mathlib.RingTheory.Polynomial.Nilpotent","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nP : Polynomial R\nhunit : IsUnit P\n⊢ And (IsUnit (P.coeff 0)) (∀ (i : Nat), Ne i 0 → IsNilpotent (P.coeff i))","decl":"/-- Let `P` be a polynomial over `R`. If `P` is a unit, then all its coefficients are nilpotent,\nexcept its constant term which is a unit.\n\nSee also `Polynomial.isUnit_iff_coeff_isUnit_isNilpotent`. -/\ntheorem coeff_isUnit_isNilpotent_of_isUnit (hunit : IsUnit P) :\n    IsUnit (P.coeff 0) ∧ (∀ i, i ≠ 0 → IsNilpotent (P.coeff i)) := by\n  obtain ⟨Q, hQ⟩ := IsUnit.exists_right_inv hunit\n  constructor\n  · refine isUnit_of_mul_eq_one _ (Q.coeff 0) ?_\n    have h := (mul_coeff_zero P Q).symm\n    rwa [hQ, coeff_one_zero] at h\n  · intros n hn\n    rw [nilpotent_iff_mem_prime]\n    intros I hI\n    let f := mapRingHom (Ideal.Quotient.mk I)\n    have hPQ : degree (f P) = 0 ∧ degree (f Q) = 0 := by\n      rw [← Nat.WithBot.add_eq_zero_iff, ← degree_mul, ← _root_.map_mul, hQ, map_one, degree_one]\n    have hcoeff : (f P).coeff n = 0 := by\n      refine coeff_eq_zero_of_degree_lt ?_\n      rw [hPQ.1]\n      exact WithBot.coe_pos.2 hn.bot_lt\n    rw [coe_mapRingHom, coeff_map, ← RingHom.mem_ker, Ideal.mk_ker] at hcoeff\n    exact hcoeff\n\n"}
{"name":"Polynomial.isUnit_iff_coeff_isUnit_isNilpotent","module":"Mathlib.RingTheory.Polynomial.Nilpotent","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nP : Polynomial R\n⊢ Iff (IsUnit P) (And (IsUnit (P.coeff 0)) (∀ (i : Nat), Ne i 0 → IsNilpotent (P.coeff i)))","decl":"/-- Let `P` be a polynomial over `R`. `P` is a unit if and only if all its coefficients are\nnilpotent, except its constant term which is a unit.\n\nSee also `Polynomial.isUnit_iff'`. -/\ntheorem isUnit_iff_coeff_isUnit_isNilpotent :\n    IsUnit P ↔ IsUnit (P.coeff 0) ∧ (∀ i, i ≠ 0 → IsNilpotent (P.coeff i)) :=\n  ⟨coeff_isUnit_isNilpotent_of_isUnit, fun H => isUnit_of_coeff_isUnit_isNilpotent H.1 H.2⟩\n\n"}
{"name":"Polynomial.isUnit_C_add_X_mul_iff","module":"Mathlib.RingTheory.Polynomial.Nilpotent","initialProofState":"R : Type u_1\nr : R\ninst✝ : CommRing R\nP : Polynomial R\n⊢ Iff (IsUnit (HAdd.hAdd (Polynomial.C r) (HMul.hMul Polynomial.X P))) (And (IsUnit r) (IsNilpotent P))","decl":"@[simp] lemma isUnit_C_add_X_mul_iff :\n    IsUnit (C r + X * P) ↔ IsUnit r ∧ IsNilpotent P := by\n  have : ∀ i, coeff (C r + X * P) (i + 1) = coeff P i := by simp\n  simp_rw [isUnit_iff_coeff_isUnit_isNilpotent, Nat.forall_ne_zero_iff, this]\n  simp only [coeff_add, coeff_C_zero, mul_coeff_zero, coeff_X_zero, zero_mul, add_zero,\n    and_congr_right_iff, ← Polynomial.isNilpotent_iff]\n\n"}
{"name":"Polynomial.isUnit_iff'","module":"Mathlib.RingTheory.Polynomial.Nilpotent","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nP : Polynomial R\n⊢ Iff (IsUnit P) (And (IsUnit (Polynomial.eval 0 P)) (IsNilpotent (P.divByMonic Polynomial.X)))","decl":"lemma isUnit_iff' :\n    IsUnit P ↔ IsUnit (eval 0 P) ∧ IsNilpotent (P /ₘ X)  := by\n  suffices P = C (eval 0 P) + X * (P /ₘ X) by\n    conv_lhs => rw [this]; simp\n  conv_lhs => rw [← modByMonic_add_div P monic_X]\n  simp [modByMonic_X]\n\n"}
{"name":"Polynomial.not_isUnit_of_natDegree_pos_of_isReduced","module":"Mathlib.RingTheory.Polynomial.Nilpotent","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\ninst✝ : IsReduced R\np : Polynomial R\nhpl : LT.lt 0 p.natDegree\n⊢ Not (IsUnit p)","decl":"theorem not_isUnit_of_natDegree_pos_of_isReduced [IsReduced R] (p : R[X])\n    (hpl : 0 < p.natDegree) : ¬ IsUnit p := by\n  simp only [ne_eq, isNilpotent_iff_eq_zero, not_and, not_forall, exists_prop,\n    Polynomial.isUnit_iff_coeff_isUnit_isNilpotent]\n  intro _\n  refine ⟨p.natDegree, hpl.ne', ?_⟩\n  contrapose! hpl\n  simp only [coeff_natDegree, leadingCoeff_eq_zero] at hpl\n  simp [hpl]\n\n"}
{"name":"Polynomial.not_isUnit_of_degree_pos_of_isReduced","module":"Mathlib.RingTheory.Polynomial.Nilpotent","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\ninst✝ : IsReduced R\np : Polynomial R\nhpl : LT.lt 0 p.degree\n⊢ Not (IsUnit p)","decl":"theorem not_isUnit_of_degree_pos_of_isReduced [IsReduced R] (p : R[X])\n    (hpl : 0 < p.degree) : ¬ IsUnit p :=\n  not_isUnit_of_natDegree_pos_of_isReduced _ (natDegree_pos_iff_degree_pos.mpr hpl)\n\n"}
{"name":"Polynomial.isNilpotent_aeval_sub_of_isNilpotent_sub","module":"Mathlib.RingTheory.Polynomial.Nilpotent","initialProofState":"R : Type u_2\nS : Type u_3\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nP : Polynomial R\na b : S\nh : IsNilpotent (HSub.hSub a b)\n⊢ IsNilpotent (HSub.hSub ((Polynomial.aeval a) P) ((Polynomial.aeval b) P))","decl":"lemma isNilpotent_aeval_sub_of_isNilpotent_sub (h : IsNilpotent (a - b)) :\n    IsNilpotent (aeval a P - aeval b P) := by\n  simp only [← eval_map_algebraMap]\n  have ⟨c, hc⟩ := evalSubFactor (map (algebraMap R S) P) a b\n  exact hc ▸ (Commute.all _ _).isNilpotent_mul_right h\n\n"}
{"name":"Polynomial.isUnit_aeval_of_isUnit_aeval_of_isNilpotent_sub","module":"Mathlib.RingTheory.Polynomial.Nilpotent","initialProofState":"R : Type u_2\nS : Type u_3\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nP : Polynomial R\na b : S\nhb : IsUnit ((Polynomial.aeval b) P)\nhab : IsNilpotent (HSub.hSub a b)\n⊢ IsUnit ((Polynomial.aeval a) P)","decl":"lemma isUnit_aeval_of_isUnit_aeval_of_isNilpotent_sub\n    (hb : IsUnit (aeval b P)) (hab : IsNilpotent (a - b)) :\n    IsUnit (aeval a P) := by\n  rw [← add_sub_cancel (aeval b P) (aeval a P)]\n  refine IsNilpotent.isUnit_add_left_of_commute ?_ hb (Commute.all _ _)\n  exact isNilpotent_aeval_sub_of_isNilpotent_sub P hab\n\n"}
