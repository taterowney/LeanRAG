{"name":"MeasureTheory.exists_pair_mem_lattice_not_disjoint_vadd","module":"Mathlib.MeasureTheory.Group.GeometryOfNumbers","initialProofState":"E : Type u_1\nL : Type u_2\ninst✝⁶ : MeasurableSpace E\nμ : MeasureTheory.Measure E\nF s : Set E\ninst✝⁵ : AddCommGroup L\ninst✝⁴ : Countable L\ninst✝³ : AddAction L E\ninst✝² : MeasurableSpace L\ninst✝¹ : MeasurableVAdd L E\ninst✝ : MeasureTheory.VAddInvariantMeasure L E μ\nfund : MeasureTheory.IsAddFundamentalDomain L F μ\nhS : MeasureTheory.NullMeasurableSet s μ\nh : LT.lt (μ F) (μ s)\n⊢ Exists fun x => Exists fun y => And (Ne x y) (Not (Disjoint (HVAdd.hVAdd x s) (HVAdd.hVAdd y s)))","decl":"/-- **Blichfeldt's Theorem**. If the volume of the set `s` is larger than the covolume of the\ncountable subgroup `L` of `E`, then there exist two distinct points `x, y ∈ L` such that `(x + s)`\nand `(y + s)` are not disjoint. -/\ntheorem exists_pair_mem_lattice_not_disjoint_vadd [AddCommGroup L] [Countable L] [AddAction L E]\n    [MeasurableSpace L] [MeasurableVAdd L E] [VAddInvariantMeasure L E μ]\n    (fund : IsAddFundamentalDomain L F μ) (hS : NullMeasurableSet s μ) (h : μ F < μ s) :\n    ∃ x y : L, x ≠ y ∧ ¬Disjoint (x +ᵥ s) (y +ᵥ s) := by\n  contrapose! h\n  exact ((fund.measure_eq_tsum _).trans (measure_iUnion₀\n    (Pairwise.mono h fun i j hij => (hij.mono inf_le_left inf_le_left).aedisjoint)\n      fun _ => (hS.vadd _).inter fund.nullMeasurableSet).symm).trans_le\n      (measure_mono <| Set.iUnion_subset fun _ => Set.inter_subset_right)\n\n"}
{"name":"MeasureTheory.exists_ne_zero_mem_lattice_of_measure_mul_two_pow_lt_measure","module":"Mathlib.MeasureTheory.Group.GeometryOfNumbers","initialProofState":"E : Type u_1\ninst✝⁶ : MeasurableSpace E\nμ : MeasureTheory.Measure E\nF s : Set E\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace Real E\ninst✝³ : BorelSpace E\ninst✝² : FiniteDimensional Real E\ninst✝¹ : μ.IsAddHaarMeasure\nL : AddSubgroup E\ninst✝ : Countable (Subtype fun x => Membership.mem L x)\nfund : MeasureTheory.IsAddFundamentalDomain (Subtype fun x => Membership.mem L x) F μ\nh_symm : ∀ (x : E), Membership.mem s x → Membership.mem s (Neg.neg x)\nh_conv : Convex Real s\nh : LT.lt (HMul.hMul (μ F) (HPow.hPow 2 (Module.finrank Real E))) (μ s)\n⊢ Exists fun x => And (Ne x 0) (Membership.mem s ↑x)","decl":"/-- The **Minkowski Convex Body Theorem**. If `s` is a convex symmetric domain of `E` whose volume\nis large enough compared to the covolume of a lattice `L` of `E`, then it contains a non-zero\nlattice point of `L`. -/\ntheorem exists_ne_zero_mem_lattice_of_measure_mul_two_pow_lt_measure [NormedAddCommGroup E]\n    [NormedSpace ℝ E] [BorelSpace E] [FiniteDimensional ℝ E] [IsAddHaarMeasure μ]\n    {L : AddSubgroup E} [Countable L] (fund : IsAddFundamentalDomain L F μ)\n    (h_symm : ∀ x ∈ s, -x ∈ s) (h_conv : Convex ℝ s) (h : μ F * 2 ^ finrank ℝ E < μ s) :\n    ∃ x ≠ 0, ((x : L) : E) ∈ s := by\n  have h_vol : μ F < μ ((2⁻¹ : ℝ) • s) := by\n    rw [addHaar_smul_of_nonneg μ (by norm_num : 0 ≤ (2 : ℝ)⁻¹) s, ←\n      mul_lt_mul_right (pow_ne_zero (finrank ℝ E) (two_ne_zero' _)) (pow_ne_top ofNat_ne_top),\n      mul_right_comm, ofReal_pow (by norm_num : 0 ≤ (2 : ℝ)⁻¹), ofReal_inv_of_pos zero_lt_two]\n    norm_num\n    rwa [← mul_pow, ENNReal.inv_mul_cancel two_ne_zero ofNat_ne_top, one_pow, one_mul]\n  obtain ⟨x, y, hxy, h⟩ :=\n    exists_pair_mem_lattice_not_disjoint_vadd fund ((h_conv.smul _).nullMeasurableSet _) h_vol\n  obtain ⟨_, ⟨v, hv, rfl⟩, w, hw, hvw⟩ := Set.not_disjoint_iff.mp h\n  refine ⟨x - y, sub_ne_zero.2 hxy, ?_⟩\n  rw [Set.mem_inv_smul_set_iff₀ (two_ne_zero' ℝ)] at hv hw\n  simp_rw [AddSubgroup.vadd_def, vadd_eq_add, add_comm _ w, ← sub_eq_sub_iff_add_eq_add, ←\n    AddSubgroup.coe_sub] at hvw\n  rw [← hvw, ← inv_smul_smul₀ (two_ne_zero' ℝ) (_ - _), smul_sub, sub_eq_add_neg, smul_add]\n  refine h_conv hw (h_symm _ hv) ?_ ?_ ?_ <;> norm_num\n\n"}
{"name":"MeasureTheory.exists_ne_zero_mem_lattice_of_measure_mul_two_pow_le_measure","module":"Mathlib.MeasureTheory.Group.GeometryOfNumbers","initialProofState":"E : Type u_1\ninst✝⁸ : MeasurableSpace E\nμ : MeasureTheory.Measure E\nF s : Set E\ninst✝⁷ : NormedAddCommGroup E\ninst✝⁶ : NormedSpace Real E\ninst✝⁵ : BorelSpace E\ninst✝⁴ : FiniteDimensional Real E\ninst✝³ : Nontrivial E\ninst✝² : μ.IsAddHaarMeasure\nL : AddSubgroup E\ninst✝¹ : Countable (Subtype fun x => Membership.mem L x)\ninst✝ : DiscreteTopology (Subtype fun x => Membership.mem L x)\nfund : MeasureTheory.IsAddFundamentalDomain (Subtype fun x => Membership.mem L x) F μ\nh_symm : ∀ (x : E), Membership.mem s x → Membership.mem s (Neg.neg x)\nh_conv : Convex Real s\nh_cpt : IsCompact s\nh : LE.le (HMul.hMul (μ F) (HPow.hPow 2 (Module.finrank Real E))) (μ s)\n⊢ Exists fun x => And (Ne x 0) (Membership.mem s ↑x)","decl":"/-- The **Minkowski Convex Body Theorem for compact domain**. If `s` is a convex compact symmetric\ndomain of `E` whose volume is large enough compared to the covolume of a lattice `L` of `E`, then it\ncontains a non-zero lattice point of `L`. Compared to\n`exists_ne_zero_mem_lattice_of_measure_mul_two_pow_lt_measure`, this version requires in addition\nthat `s` is compact and `L` is discrete but provides a weaker inequality rather than a strict\ninequality. -/\ntheorem exists_ne_zero_mem_lattice_of_measure_mul_two_pow_le_measure [NormedAddCommGroup E]\n    [NormedSpace ℝ E] [BorelSpace E] [FiniteDimensional ℝ E] [Nontrivial E] [IsAddHaarMeasure μ]\n    {L : AddSubgroup E} [Countable L] [DiscreteTopology L] (fund : IsAddFundamentalDomain L F μ)\n    (h_symm : ∀ x ∈ s, -x ∈ s) (h_conv : Convex ℝ s) (h_cpt : IsCompact s)\n    (h : μ F * 2 ^ finrank ℝ E ≤ μ s) :\n    ∃ x ≠ 0, ((x : L) : E) ∈ s := by\n  have h_mes : μ s ≠ 0 := by\n    intro hμ\n    suffices μ F = 0 from fund.measure_ne_zero (NeZero.ne μ) this\n    rw [hμ, le_zero_iff, mul_eq_zero] at h\n    exact h.resolve_right <| pow_ne_zero _ two_ne_zero\n  have h_nemp : s.Nonempty := nonempty_of_measure_ne_zero h_mes\n  let u : ℕ → ℝ≥0 := (exists_seq_strictAnti_tendsto 0).choose\n  let K : ConvexBody E := ⟨s, h_conv, h_cpt, h_nemp⟩\n  let S : ℕ → ConvexBody E := fun n => (1 + u n) • K\n  let Z : ℕ → Set E := fun n => (S n) ∩ (L \\ {0})\n  -- The convex bodies `S n` have volume strictly larger than `μ s` and thus we can apply\n  -- `exists_ne_zero_mem_lattice_of_measure_mul_two_pow_lt_measure` to them and obtain that\n  -- `S n` contains a nonzero point of `L`. Since the intersection of the `S n` is equal to `s`,\n  -- it follows that `s` contains a nonzero point of `L`.\n  have h_zero : 0 ∈ K := K.zero_mem_of_symmetric h_symm\n  suffices Set.Nonempty (⋂ n, Z n) by\n    erw [← Set.iInter_inter, K.iInter_smul_eq_self h_zero] at this\n    · obtain ⟨x, hx⟩ := this\n      exact ⟨⟨x, by aesop⟩, by aesop⟩\n    · exact (exists_seq_strictAnti_tendsto (0 : ℝ≥0)).choose_spec.2.2\n  have h_clos : IsClosed ((L : Set E) \\ {0}) := by\n    rsuffices ⟨U, hU⟩ : ∃ U : Set E, IsOpen U ∧  U ∩ L = {0}\n    · rw [sdiff_eq_sdiff_iff_inf_eq_inf (z := U).mpr (by simp [Set.inter_comm .. ▸ hU.2, zero_mem])]\n      exact AddSubgroup.isClosed_of_discrete.sdiff hU.1\n    exact isOpen_inter_eq_singleton_of_mem_discrete (zero_mem L)\n  refine IsCompact.nonempty_iInter_of_sequence_nonempty_isCompact_isClosed Z (fun n => ?_)\n    (fun n => ?_) ((S 0).isCompact.inter_right h_clos) (fun n => (S n).isClosed.inter h_clos)\n  · refine Set.inter_subset_inter_left _ (SetLike.coe_subset_coe.mpr ?_)\n    refine ConvexBody.smul_le_of_le K h_zero ?_\n    rw [add_le_add_iff_left]\n    exact le_of_lt <| (exists_seq_strictAnti_tendsto (0 : ℝ≥0)).choose_spec.1 (Nat.lt.base n)\n  · suffices μ F * 2 ^ finrank ℝ E < μ (S n : Set E) by\n      have h_symm' : ∀ x ∈ S n, -x ∈ S n := by\n        rintro _ ⟨y, hy, rfl⟩\n        exact ⟨-y, h_symm _ hy, by simp⟩\n      obtain ⟨x, hx_nz, hx_mem⟩ := exists_ne_zero_mem_lattice_of_measure_mul_two_pow_lt_measure\n        fund h_symm' (S n).convex this\n      exact ⟨x, hx_mem, by aesop⟩\n    refine lt_of_le_of_lt h ?_\n    rw [ConvexBody.coe_smul', NNReal.smul_def, addHaar_smul_of_nonneg _ (NNReal.coe_nonneg _)]\n    rw [show μ s < _ ↔ 1 * μ s < _ by rw [one_mul]]\n    refine (mul_lt_mul_right h_mes (ne_of_lt h_cpt.measure_lt_top)).mpr ?_\n    rw [ofReal_pow (NNReal.coe_nonneg _)]\n    refine one_lt_pow₀ ?_ (ne_of_gt finrank_pos)\n    simp [u, K, S, Z, (exists_seq_strictAnti_tendsto (0 : ℝ≥0)).choose_spec.2.1 n]\n\n"}
