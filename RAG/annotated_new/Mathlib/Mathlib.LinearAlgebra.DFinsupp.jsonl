{"name":"DFinsupp.lhom_ext","module":"Mathlib.LinearAlgebra.DFinsupp","initialProofState":"ι : Type u_1\nR : Type u_2\nM : ι → Type u_4\nN : Type u_5\ninst✝⁵ : Semiring R\ninst✝⁴ : (i : ι) → AddCommMonoid (M i)\ninst✝³ : (i : ι) → Module R (M i)\ninst✝² : AddCommMonoid N\ninst✝¹ : Module R N\ninst✝ : DecidableEq ι\nφ ψ : LinearMap (RingHom.id R) (DFinsupp fun i => M i) N\nh : ∀ (i : ι) (x : M i), Eq (φ (DFinsupp.single i x)) (ψ (DFinsupp.single i x))\n⊢ Eq φ ψ","decl":"/-- Two `R`-linear maps from `Π₀ i, M i` which agree on each `single i x` agree everywhere. -/\ntheorem lhom_ext ⦃φ ψ : (Π₀ i, M i) →ₗ[R] N⦄ (h : ∀ i x, φ (single i x) = ψ (single i x)) : φ = ψ :=\n  LinearMap.toAddMonoidHom_injective <| addHom_ext h\n\n"}
{"name":"DFinsupp.lhom_ext'","module":"Mathlib.LinearAlgebra.DFinsupp","initialProofState":"ι : Type u_1\nR : Type u_2\nM : ι → Type u_4\nN : Type u_5\ninst✝⁵ : Semiring R\ninst✝⁴ : (i : ι) → AddCommMonoid (M i)\ninst✝³ : (i : ι) → Module R (M i)\ninst✝² : AddCommMonoid N\ninst✝¹ : Module R N\ninst✝ : DecidableEq ι\nφ ψ : LinearMap (RingHom.id R) (DFinsupp fun i => M i) N\nh : ∀ (i : ι), Eq (φ.comp (DFinsupp.lsingle i)) (ψ.comp (DFinsupp.lsingle i))\n⊢ Eq φ ψ","decl":"/-- Two `R`-linear maps from `Π₀ i, M i` which agree on each `single i x` agree everywhere.\n\nSee note [partially-applied ext lemmas].\nAfter applying this lemma, if `M = R` then it suffices to verify\n`φ (single a 1) = ψ (single a 1)`. -/\n@[ext 1100]\ntheorem lhom_ext' ⦃φ ψ : (Π₀ i, M i) →ₗ[R] N⦄ (h : ∀ i, φ.comp (lsingle i) = ψ.comp (lsingle i)) :\n    φ = ψ :=\n  lhom_ext fun i => LinearMap.congr_fun (h i)\n\n-- This lemma has always been bad, but the linter only noticed after https://github.com/leanprover/lean4/pull/2644.\n"}
{"name":"DFinsupp.lhom_ext'_iff","module":"Mathlib.LinearAlgebra.DFinsupp","initialProofState":"ι : Type u_1\nR : Type u_2\nM : ι → Type u_4\nN : Type u_5\ninst✝⁵ : Semiring R\ninst✝⁴ : (i : ι) → AddCommMonoid (M i)\ninst✝³ : (i : ι) → Module R (M i)\ninst✝² : AddCommMonoid N\ninst✝¹ : Module R N\ninst✝ : DecidableEq ι\nφ ψ : LinearMap (RingHom.id R) (DFinsupp fun i => M i) N\n⊢ Iff (Eq φ ψ) (∀ (i : ι), Eq (φ.comp (DFinsupp.lsingle i)) (ψ.comp (DFinsupp.lsingle i)))","decl":"/-- Two `R`-linear maps from `Π₀ i, M i` which agree on each `single i x` agree everywhere.\n\nSee note [partially-applied ext lemmas].\nAfter applying this lemma, if `M = R` then it suffices to verify\n`φ (single a 1) = ψ (single a 1)`. -/\n@[ext 1100]\ntheorem lhom_ext' ⦃φ ψ : (Π₀ i, M i) →ₗ[R] N⦄ (h : ∀ i, φ.comp (lsingle i) = ψ.comp (lsingle i)) :\n    φ = ψ :=\n  lhom_ext fun i => LinearMap.congr_fun (h i)\n\n-- This lemma has always been bad, but the linter only noticed after https://github.com/leanprover/lean4/pull/2644.\n"}
{"name":"DFinsupp.lmk_apply","module":"Mathlib.LinearAlgebra.DFinsupp","initialProofState":"ι : Type u_1\nR : Type u_2\nM : ι → Type u_4\ninst✝³ : Semiring R\ninst✝² : (i : ι) → AddCommMonoid (M i)\ninst✝¹ : (i : ι) → Module R (M i)\ninst✝ : DecidableEq ι\ns : Finset ι\nx : (i : ↑↑s) → M ↑i\n⊢ Eq ((DFinsupp.lmk s) x) (DFinsupp.mk s x)","decl":"@[simp, nolint simpNF]\ntheorem lmk_apply (s : Finset ι) (x) : (lmk s : _ →ₗ[R] Π₀ i, M i) x = mk s x :=\n  rfl\n\n"}
{"name":"DFinsupp.lsingle_apply","module":"Mathlib.LinearAlgebra.DFinsupp","initialProofState":"ι : Type u_1\nR : Type u_2\nM : ι → Type u_4\ninst✝³ : Semiring R\ninst✝² : (i : ι) → AddCommMonoid (M i)\ninst✝¹ : (i : ι) → Module R (M i)\ninst✝ : DecidableEq ι\ni : ι\nx : M i\n⊢ Eq ((DFinsupp.lsingle i) x) (DFinsupp.single i x)","decl":"@[simp]\ntheorem lsingle_apply (i : ι) (x : M i) : (lsingle i : (M i) →ₗ[R] _) x = single i x :=\n  rfl\n\n"}
{"name":"DFinsupp.lapply_apply","module":"Mathlib.LinearAlgebra.DFinsupp","initialProofState":"ι : Type u_1\nR : Type u_2\nM : ι → Type u_4\ninst✝² : Semiring R\ninst✝¹ : (i : ι) → AddCommMonoid (M i)\ninst✝ : (i : ι) → Module R (M i)\ni : ι\nf : DFinsupp fun i => M i\n⊢ Eq ((DFinsupp.lapply i) f) (f i)","decl":"@[simp]\ntheorem lapply_apply (i : ι) (f : Π₀ i, M i) : (lapply i : (Π₀ i, M i) →ₗ[R] _) f = f i :=\n  rfl\n\n"}
{"name":"DFinsupp.lapply_comp_lsingle_same","module":"Mathlib.LinearAlgebra.DFinsupp","initialProofState":"ι : Type u_1\nR : Type u_2\nM : ι → Type u_4\ninst✝³ : Semiring R\ninst✝² : (i : ι) → AddCommMonoid (M i)\ninst✝¹ : (i : ι) → Module R (M i)\ninst✝ : DecidableEq ι\ni : ι\n⊢ Eq ((DFinsupp.lapply i).comp (DFinsupp.lsingle i)) LinearMap.id","decl":"@[simp]\ntheorem lapply_comp_lsingle_same [DecidableEq ι] (i : ι) :\n    lapply i ∘ₗ lsingle i = (.id : M i →ₗ[R] M i) := by ext; simp\n\n"}
{"name":"DFinsupp.lapply_comp_lsingle_of_ne","module":"Mathlib.LinearAlgebra.DFinsupp","initialProofState":"ι : Type u_1\nR : Type u_2\nM : ι → Type u_4\ninst✝³ : Semiring R\ninst✝² : (i : ι) → AddCommMonoid (M i)\ninst✝¹ : (i : ι) → Module R (M i)\ninst✝ : DecidableEq ι\ni i' : ι\nh : Ne i i'\n⊢ Eq ((DFinsupp.lapply i).comp (DFinsupp.lsingle i')) 0","decl":"@[simp]\ntheorem lapply_comp_lsingle_of_ne [DecidableEq ι] (i i' : ι) (h : i ≠ i') :\n    lapply i ∘ₗ lsingle i' = (0 : M i' →ₗ[R] M i) := by ext; simp [h.symm]\n\n"}
{"name":"DFinsupp.lsum_apply_apply","module":"Mathlib.LinearAlgebra.DFinsupp","initialProofState":"ι : Type u_1\nR : Type u_2\nS : Type u_3\nM : ι → Type u_4\nN : Type u_5\ninst✝⁸ : Semiring R\ninst✝⁷ : (i : ι) → AddCommMonoid (M i)\ninst✝⁶ : (i : ι) → Module R (M i)\ninst✝⁵ : AddCommMonoid N\ninst✝⁴ : Module R N\ninst✝³ : DecidableEq ι\ninst✝² : Semiring S\ninst✝¹ : Module S N\ninst✝ : SMulCommClass R S N\nF : (i : ι) → LinearMap (RingHom.id R) (M i) N\na : DFinsupp fun i => M i\n⊢ Eq (((DFinsupp.lsum S) F) a) ((DFinsupp.sumAddHom fun i => (F i).toAddMonoidHom) a)","decl":"/-- The `DFinsupp` version of `Finsupp.lsum`.\n\nSee note [bundled maps over different rings] for why separate `R` and `S` semirings are used. -/\n@[simps]\ndef lsum [Semiring S] [Module S N] [SMulCommClass R S N] :\n    (∀ i, M i →ₗ[R] N) ≃ₗ[S] (Π₀ i, M i) →ₗ[R] N where\n  toFun F :=\n    { toFun := sumAddHom fun i => (F i).toAddMonoidHom\n      map_add' := (DFinsupp.liftAddHom fun (i : ι) => (F i).toAddMonoidHom).map_add\n      map_smul' := fun c f => by\n        dsimp\n        apply DFinsupp.induction f\n        · rw [smul_zero, AddMonoidHom.map_zero, smul_zero]\n        · intro a b f _ _ hf\n          rw [smul_add, AddMonoidHom.map_add, AddMonoidHom.map_add, smul_add, hf, ← single_smul,\n            sumAddHom_single, sumAddHom_single, LinearMap.toAddMonoidHom_coe,\n            LinearMap.map_smul] }\n  invFun F i := F.comp (lsingle i)\n  left_inv F := by\n    ext\n    simp\n  right_inv F := by\n    refine DFinsupp.lhom_ext' (fun i ↦ ?_)\n    ext\n    simp\n  map_add' F G := by\n    refine DFinsupp.lhom_ext' (fun i ↦ ?_)\n    ext\n    simp\n  map_smul' c F := by\n    refine DFinsupp.lhom_ext' (fun i ↦ ?_)\n    ext\n    simp\n\n"}
{"name":"DFinsupp.lsum_symm_apply","module":"Mathlib.LinearAlgebra.DFinsupp","initialProofState":"ι : Type u_1\nR : Type u_2\nS : Type u_3\nM : ι → Type u_4\nN : Type u_5\ninst✝⁸ : Semiring R\ninst✝⁷ : (i : ι) → AddCommMonoid (M i)\ninst✝⁶ : (i : ι) → Module R (M i)\ninst✝⁵ : AddCommMonoid N\ninst✝⁴ : Module R N\ninst✝³ : DecidableEq ι\ninst✝² : Semiring S\ninst✝¹ : Module S N\ninst✝ : SMulCommClass R S N\nF : LinearMap (RingHom.id R) (DFinsupp fun i => M i) N\ni : ι\n⊢ Eq ((DFinsupp.lsum S).symm F i) (F.comp (DFinsupp.lsingle i))","decl":"/-- The `DFinsupp` version of `Finsupp.lsum`.\n\nSee note [bundled maps over different rings] for why separate `R` and `S` semirings are used. -/\n@[simps]\ndef lsum [Semiring S] [Module S N] [SMulCommClass R S N] :\n    (∀ i, M i →ₗ[R] N) ≃ₗ[S] (Π₀ i, M i) →ₗ[R] N where\n  toFun F :=\n    { toFun := sumAddHom fun i => (F i).toAddMonoidHom\n      map_add' := (DFinsupp.liftAddHom fun (i : ι) => (F i).toAddMonoidHom).map_add\n      map_smul' := fun c f => by\n        dsimp\n        apply DFinsupp.induction f\n        · rw [smul_zero, AddMonoidHom.map_zero, smul_zero]\n        · intro a b f _ _ hf\n          rw [smul_add, AddMonoidHom.map_add, AddMonoidHom.map_add, smul_add, hf, ← single_smul,\n            sumAddHom_single, sumAddHom_single, LinearMap.toAddMonoidHom_coe,\n            LinearMap.map_smul] }\n  invFun F i := F.comp (lsingle i)\n  left_inv F := by\n    ext\n    simp\n  right_inv F := by\n    refine DFinsupp.lhom_ext' (fun i ↦ ?_)\n    ext\n    simp\n  map_add' F G := by\n    refine DFinsupp.lhom_ext' (fun i ↦ ?_)\n    ext\n    simp\n  map_smul' c F := by\n    refine DFinsupp.lhom_ext' (fun i ↦ ?_)\n    ext\n    simp\n\n"}
{"name":"DFinsupp.lsum_single","module":"Mathlib.LinearAlgebra.DFinsupp","initialProofState":"ι : Type u_1\nR : Type u_2\nS : Type u_3\nM : ι → Type u_4\nN : Type u_5\ninst✝⁸ : Semiring R\ninst✝⁷ : (i : ι) → AddCommMonoid (M i)\ninst✝⁶ : (i : ι) → Module R (M i)\ninst✝⁵ : AddCommMonoid N\ninst✝⁴ : Module R N\ninst✝³ : DecidableEq ι\ninst✝² : Semiring S\ninst✝¹ : Module S N\ninst✝ : SMulCommClass R S N\nF : (i : ι) → LinearMap (RingHom.id R) (M i) N\ni : ι\nx : M i\n⊢ Eq (((DFinsupp.lsum S) F) (DFinsupp.single i x)) ((F i) x)","decl":"/-- While `simp` can prove this, it is often convenient to avoid unfolding `lsum` into `sumAddHom`\nwith `DFinsupp.lsum_apply_apply`. -/\ntheorem lsum_single [Semiring S] [Module S N] [SMulCommClass R S N] (F : ∀ i, M i →ₗ[R] N) (i)\n    (x : M i) : lsum S (M := M) F (single i x) = F i x := by\n  simp\n\n"}
{"name":"DFinsupp.mapRange_smul","module":"Mathlib.LinearAlgebra.DFinsupp","initialProofState":"ι : Type u_1\nR : Type u_2\ninst✝⁴ : Semiring R\nβ₁ : ι → Type u_7\nβ₂ : ι → Type u_8\ninst✝³ : (i : ι) → AddCommMonoid (β₁ i)\ninst✝² : (i : ι) → AddCommMonoid (β₂ i)\ninst✝¹ : (i : ι) → Module R (β₁ i)\ninst✝ : (i : ι) → Module R (β₂ i)\nf : (i : ι) → β₁ i → β₂ i\nhf : ∀ (i : ι), Eq (f i 0) 0\nr : R\nhf' : ∀ (i : ι) (x : β₁ i), Eq (f i (HSMul.hSMul r x)) (HSMul.hSMul r (f i x))\ng : DFinsupp fun i => β₁ i\n⊢ Eq (DFinsupp.mapRange f hf (HSMul.hSMul r g)) (HSMul.hSMul r (DFinsupp.mapRange f hf g))","decl":"theorem mapRange_smul (f : ∀ i, β₁ i → β₂ i) (hf : ∀ i, f i 0 = 0) (r : R)\n    (hf' : ∀ i x, f i (r • x) = r • f i x) (g : Π₀ i, β₁ i) :\n    mapRange f hf (r • g) = r • mapRange f hf g := by\n  ext\n  simp only [mapRange_apply f, coe_smul, Pi.smul_apply, hf']\n\n"}
{"name":"DFinsupp.mapRange.linearMap_apply","module":"Mathlib.LinearAlgebra.DFinsupp","initialProofState":"ι : Type u_1\nR : Type u_2\ninst✝⁴ : Semiring R\nβ₁ : ι → Type u_7\nβ₂ : ι → Type u_8\ninst✝³ : (i : ι) → AddCommMonoid (β₁ i)\ninst✝² : (i : ι) → AddCommMonoid (β₂ i)\ninst✝¹ : (i : ι) → Module R (β₁ i)\ninst✝ : (i : ι) → Module R (β₂ i)\nf : (i : ι) → LinearMap (RingHom.id R) (β₁ i) (β₂ i)\nx : DFinsupp fun i => β₁ i\n⊢ Eq ((DFinsupp.mapRange.linearMap f) x) (DFinsupp.mapRange (fun i x => (f i) x) ⋯ x)","decl":"/-- `DFinsupp.mapRange` as a `LinearMap`. -/\n@[simps! apply]\ndef mapRange.linearMap (f : ∀ i, β₁ i →ₗ[R] β₂ i) : (Π₀ i, β₁ i) →ₗ[R] Π₀ i, β₂ i :=\n  { mapRange.addMonoidHom fun i => (f i).toAddMonoidHom with\n    toFun := mapRange (fun i x => f i x) fun i => (f i).map_zero\n    map_smul' := fun r => mapRange_smul _ (fun i => (f i).map_zero) _ fun i => (f i).map_smul r }\n\n"}
{"name":"DFinsupp.mapRange.linearMap_id","module":"Mathlib.LinearAlgebra.DFinsupp","initialProofState":"ι : Type u_1\nR : Type u_2\ninst✝² : Semiring R\nβ₂ : ι → Type u_8\ninst✝¹ : (i : ι) → AddCommMonoid (β₂ i)\ninst✝ : (i : ι) → Module R (β₂ i)\n⊢ Eq (DFinsupp.mapRange.linearMap fun i => LinearMap.id) LinearMap.id","decl":"@[simp]\ntheorem mapRange.linearMap_id :\n    (mapRange.linearMap fun i => (LinearMap.id : β₂ i →ₗ[R] _)) = LinearMap.id := by\n  ext\n  simp [linearMap]\n\n"}
{"name":"DFinsupp.mapRange.linearMap_comp","module":"Mathlib.LinearAlgebra.DFinsupp","initialProofState":"ι : Type u_1\nR : Type u_2\ninst✝⁶ : Semiring R\nβ : ι → Type u_6\nβ₁ : ι → Type u_7\nβ₂ : ι → Type u_8\ninst✝⁵ : (i : ι) → AddCommMonoid (β i)\ninst✝⁴ : (i : ι) → AddCommMonoid (β₁ i)\ninst✝³ : (i : ι) → AddCommMonoid (β₂ i)\ninst✝² : (i : ι) → Module R (β i)\ninst✝¹ : (i : ι) → Module R (β₁ i)\ninst✝ : (i : ι) → Module R (β₂ i)\nf : (i : ι) → LinearMap (RingHom.id R) (β₁ i) (β₂ i)\nf₂ : (i : ι) → LinearMap (RingHom.id R) (β i) (β₁ i)\n⊢ Eq (DFinsupp.mapRange.linearMap fun i => (f i).comp (f₂ i)) ((DFinsupp.mapRange.linearMap f).comp (DFinsupp.mapRange.linearMap f₂))","decl":"theorem mapRange.linearMap_comp (f : ∀ i, β₁ i →ₗ[R] β₂ i) (f₂ : ∀ i, β i →ₗ[R] β₁ i) :\n    (mapRange.linearMap fun i => (f i).comp (f₂ i)) =\n      (mapRange.linearMap f).comp (mapRange.linearMap f₂) :=\n  LinearMap.ext <| mapRange_comp (fun i x => f i x) (fun i x => f₂ i x)\n    (fun i => (f i).map_zero) (fun i => (f₂ i).map_zero) (by simp)\n\n"}
{"name":"DFinsupp.sum_mapRange_index.linearMap","module":"Mathlib.LinearAlgebra.DFinsupp","initialProofState":"ι : Type u_1\nR : Type u_2\nN : Type u_5\ninst✝⁷ : Semiring R\ninst✝⁶ : AddCommMonoid N\ninst✝⁵ : Module R N\nβ₁ : ι → Type u_7\nβ₂ : ι → Type u_8\ninst✝⁴ : (i : ι) → AddCommMonoid (β₁ i)\ninst✝³ : (i : ι) → AddCommMonoid (β₂ i)\ninst✝² : (i : ι) → Module R (β₁ i)\ninst✝¹ : (i : ι) → Module R (β₂ i)\ninst✝ : DecidableEq ι\nf : (i : ι) → LinearMap (RingHom.id R) (β₁ i) (β₂ i)\nh : (i : ι) → LinearMap (RingHom.id R) (β₂ i) N\nl : DFinsupp fun i => β₁ i\n⊢ Eq (((DFinsupp.lsum Nat) h) ((DFinsupp.mapRange.linearMap f) l)) (((DFinsupp.lsum Nat) fun i => (h i).comp (f i)) l)","decl":"theorem sum_mapRange_index.linearMap [DecidableEq ι] {f : ∀ i, β₁ i →ₗ[R] β₂ i}\n    {h : ∀ i, β₂ i →ₗ[R] N} {l : Π₀ i, β₁ i} :\n    DFinsupp.lsum ℕ h (mapRange.linearMap f l) = DFinsupp.lsum ℕ (fun i => (h i).comp (f i)) l := by\n  classical simpa [DFinsupp.sumAddHom_apply] using sum_mapRange_index fun i => by simp\n\n"}
{"name":"DFinsupp.mapRange.linearEquiv_apply","module":"Mathlib.LinearAlgebra.DFinsupp","initialProofState":"ι : Type u_1\nR : Type u_2\ninst✝⁴ : Semiring R\nβ₁ : ι → Type u_7\nβ₂ : ι → Type u_8\ninst✝³ : (i : ι) → AddCommMonoid (β₁ i)\ninst✝² : (i : ι) → AddCommMonoid (β₂ i)\ninst✝¹ : (i : ι) → Module R (β₁ i)\ninst✝ : (i : ι) → Module R (β₂ i)\ne : (i : ι) → LinearEquiv (RingHom.id R) (β₁ i) (β₂ i)\nx : DFinsupp fun i => β₁ i\n⊢ Eq ((DFinsupp.mapRange.linearEquiv e) x) (DFinsupp.mapRange (fun i x => (e i) x) ⋯ x)","decl":"/-- `DFinsupp.mapRange.linearMap` as a `LinearEquiv`. -/\n@[simps apply]\ndef mapRange.linearEquiv (e : ∀ i, β₁ i ≃ₗ[R] β₂ i) : (Π₀ i, β₁ i) ≃ₗ[R] Π₀ i, β₂ i :=\n  { mapRange.addEquiv fun i => (e i).toAddEquiv,\n    mapRange.linearMap fun i => (e i).toLinearMap with\n    toFun := mapRange (fun i x => e i x) fun i => (e i).map_zero\n    invFun := mapRange (fun i x => (e i).symm x) fun i => (e i).symm.map_zero }\n\n"}
{"name":"DFinsupp.mapRange.linearEquiv_refl","module":"Mathlib.LinearAlgebra.DFinsupp","initialProofState":"ι : Type u_1\nR : Type u_2\ninst✝² : Semiring R\nβ₁ : ι → Type u_7\ninst✝¹ : (i : ι) → AddCommMonoid (β₁ i)\ninst✝ : (i : ι) → Module R (β₁ i)\n⊢ Eq (DFinsupp.mapRange.linearEquiv fun i => LinearEquiv.refl R (β₁ i)) (LinearEquiv.refl R (DFinsupp fun i => β₁ i))","decl":"@[simp]\ntheorem mapRange.linearEquiv_refl :\n    (mapRange.linearEquiv fun i => LinearEquiv.refl R (β₁ i)) = LinearEquiv.refl _ _ :=\n  LinearEquiv.ext mapRange_id\n\n"}
{"name":"DFinsupp.mapRange.linearEquiv_trans","module":"Mathlib.LinearAlgebra.DFinsupp","initialProofState":"ι : Type u_1\nR : Type u_2\ninst✝⁶ : Semiring R\nβ : ι → Type u_6\nβ₁ : ι → Type u_7\nβ₂ : ι → Type u_8\ninst✝⁵ : (i : ι) → AddCommMonoid (β i)\ninst✝⁴ : (i : ι) → AddCommMonoid (β₁ i)\ninst✝³ : (i : ι) → AddCommMonoid (β₂ i)\ninst✝² : (i : ι) → Module R (β i)\ninst✝¹ : (i : ι) → Module R (β₁ i)\ninst✝ : (i : ι) → Module R (β₂ i)\nf : (i : ι) → LinearEquiv (RingHom.id R) (β i) (β₁ i)\nf₂ : (i : ι) → LinearEquiv (RingHom.id R) (β₁ i) (β₂ i)\n⊢ Eq (DFinsupp.mapRange.linearEquiv fun i => (f i).trans (f₂ i)) ((DFinsupp.mapRange.linearEquiv f).trans (DFinsupp.mapRange.linearEquiv f₂))","decl":"theorem mapRange.linearEquiv_trans (f : ∀ i, β i ≃ₗ[R] β₁ i) (f₂ : ∀ i, β₁ i ≃ₗ[R] β₂ i) :\n    (mapRange.linearEquiv fun i => (f i).trans (f₂ i)) =\n      (mapRange.linearEquiv f).trans (mapRange.linearEquiv f₂) :=\n  LinearEquiv.ext <| mapRange_comp (fun i x => f₂ i x) (fun i x => f i x)\n    (fun i => (f₂ i).map_zero) (fun i => (f i).map_zero) (by simp)\n\n"}
{"name":"DFinsupp.mapRange.linearEquiv_symm","module":"Mathlib.LinearAlgebra.DFinsupp","initialProofState":"ι : Type u_1\nR : Type u_2\ninst✝⁴ : Semiring R\nβ₁ : ι → Type u_7\nβ₂ : ι → Type u_8\ninst✝³ : (i : ι) → AddCommMonoid (β₁ i)\ninst✝² : (i : ι) → AddCommMonoid (β₂ i)\ninst✝¹ : (i : ι) → Module R (β₁ i)\ninst✝ : (i : ι) → Module R (β₂ i)\ne : (i : ι) → LinearEquiv (RingHom.id R) (β₁ i) (β₂ i)\n⊢ Eq (DFinsupp.mapRange.linearEquiv e).symm (DFinsupp.mapRange.linearEquiv fun i => (e i).symm)","decl":"@[simp]\ntheorem mapRange.linearEquiv_symm (e : ∀ i, β₁ i ≃ₗ[R] β₂ i) :\n    (mapRange.linearEquiv e).symm = mapRange.linearEquiv fun i => (e i).symm :=\n  rfl\n\n"}
{"name":"DFinsupp.coprodMap_apply","module":"Mathlib.LinearAlgebra.DFinsupp","initialProofState":"ι : Type u_1\nR : Type u_2\nM : ι → Type u_4\nN : Type u_5\ninst✝⁶ : Semiring R\ninst✝⁵ : (i : ι) → AddCommMonoid (M i)\ninst✝⁴ : (i : ι) → Module R (M i)\ninst✝³ : AddCommMonoid N\ninst✝² : Module R N\ninst✝¹ : DecidableEq ι\ninst✝ : (x : N) → Decidable (Ne x 0)\nf : (i : ι) → LinearMap (RingHom.id R) (M i) N\nx : DFinsupp fun i => M i\n⊢ Eq ((DFinsupp.coprodMap f) x) ((DFinsupp.mapRange (fun i => ⇑(f i)) ⋯ x).sum fun x => id)","decl":"theorem coprodMap_apply [∀ x : N, Decidable (x ≠ 0)] (f : ∀ i : ι, M i →ₗ[R] N) (x : Π₀ i, M i) :\n    coprodMap f x =\n      DFinsupp.sum (mapRange (fun i => f i) (fun _ => LinearMap.map_zero _) x) fun _ =>\n        id :=\n  DFinsupp.sumAddHom_apply _ _\n\n"}
{"name":"DFinsupp.coprodMap_apply_single","module":"Mathlib.LinearAlgebra.DFinsupp","initialProofState":"ι : Type u_1\nR : Type u_2\nM : ι → Type u_4\nN : Type u_5\ninst✝⁵ : Semiring R\ninst✝⁴ : (i : ι) → AddCommMonoid (M i)\ninst✝³ : (i : ι) → Module R (M i)\ninst✝² : AddCommMonoid N\ninst✝¹ : Module R N\ninst✝ : DecidableEq ι\nf : (i : ι) → LinearMap (RingHom.id R) (M i) N\ni : ι\nx : M i\n⊢ Eq ((DFinsupp.coprodMap f) (DFinsupp.single i x)) ((f i) x)","decl":"theorem coprodMap_apply_single (f : ∀ i : ι, M i →ₗ[R] N) (i : ι) (x : M i) :\n    coprodMap f (single i x) = f i x := by\n  simp [coprodMap]\n\n"}
{"name":"Submodule.dfinsupp_sum_mem","module":"Mathlib.LinearAlgebra.DFinsupp","initialProofState":"ι : Type u_1\nR : Type u_2\nN : Type u_5\ninst✝⁵ : Semiring R\ninst✝⁴ : AddCommMonoid N\ninst✝³ : Module R N\ninst✝² : DecidableEq ι\nβ : ι → Type u_6\ninst✝¹ : (i : ι) → Zero (β i)\ninst✝ : (i : ι) → (x : β i) → Decidable (Ne x 0)\nS : Submodule R N\nf : DFinsupp fun i => β i\ng : (i : ι) → β i → N\nh : ∀ (c : ι), Ne (f c) 0 → Membership.mem S (g c (f c))\n⊢ Membership.mem S (f.sum g)","decl":"theorem dfinsupp_sum_mem {β : ι → Type*} [∀ i, Zero (β i)] [∀ (i) (x : β i), Decidable (x ≠ 0)]\n    (S : Submodule R N) (f : Π₀ i, β i) (g : ∀ i, β i → N) (h : ∀ c, f c ≠ 0 → g c (f c) ∈ S) :\n    f.sum g ∈ S :=\n  _root_.dfinsupp_sum_mem S f g h\n\n"}
{"name":"Submodule.dfinsupp_sumAddHom_mem","module":"Mathlib.LinearAlgebra.DFinsupp","initialProofState":"ι : Type u_1\nR : Type u_2\nN : Type u_5\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid N\ninst✝² : Module R N\ninst✝¹ : DecidableEq ι\nβ : ι → Type u_6\ninst✝ : (i : ι) → AddZeroClass (β i)\nS : Submodule R N\nf : DFinsupp fun i => β i\ng : (i : ι) → AddMonoidHom (β i) N\nh : ∀ (c : ι), Ne (f c) 0 → Membership.mem S ((g c) (f c))\n⊢ Membership.mem S ((DFinsupp.sumAddHom g) f)","decl":"theorem dfinsupp_sumAddHom_mem {β : ι → Type*} [∀ i, AddZeroClass (β i)] (S : Submodule R N)\n    (f : Π₀ i, β i) (g : ∀ i, β i →+ N) (h : ∀ c, f c ≠ 0 → g c (f c) ∈ S) :\n    DFinsupp.sumAddHom g f ∈ S :=\n  _root_.dfinsupp_sumAddHom_mem S f g h\n\n"}
{"name":"Submodule.iSup_eq_range_dfinsupp_lsum","module":"Mathlib.LinearAlgebra.DFinsupp","initialProofState":"ι : Type u_1\nR : Type u_2\nN : Type u_5\ninst✝³ : Semiring R\ninst✝² : AddCommMonoid N\ninst✝¹ : Module R N\ninst✝ : DecidableEq ι\np : ι → Submodule R N\n⊢ Eq (iSup p) (LinearMap.range ((DFinsupp.lsum Nat) fun i => (p i).subtype))","decl":"/-- The supremum of a family of submodules is equal to the range of `DFinsupp.lsum`; that is\nevery element in the `iSup` can be produced from taking a finite number of non-zero elements\nof `p i`, coercing them to `N`, and summing them. -/\ntheorem iSup_eq_range_dfinsupp_lsum (p : ι → Submodule R N) :\n    iSup p = LinearMap.range (DFinsupp.lsum ℕ (M := fun i ↦ ↥(p i)) fun i => (p i).subtype) := by\n  apply le_antisymm\n  · apply iSup_le _\n    intro i y hy\n    simp only [LinearMap.mem_range, lsum_apply_apply]\n    exact ⟨DFinsupp.single i ⟨y, hy⟩, DFinsupp.sumAddHom_single _ _ _⟩\n  · rintro x ⟨v, rfl⟩\n    exact dfinsupp_sumAddHom_mem _ v _ fun i _ => (le_iSup p i : p i ≤ _) (v i).2\n\n"}
{"name":"Submodule.biSup_eq_range_dfinsupp_lsum","module":"Mathlib.LinearAlgebra.DFinsupp","initialProofState":"ι : Type u_1\nR : Type u_2\nN : Type u_5\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid N\ninst✝² : Module R N\ninst✝¹ : DecidableEq ι\np : ι → Prop\ninst✝ : DecidablePred p\nS : ι → Submodule R N\n⊢ Eq (iSup fun i => iSup fun x => S i) (LinearMap.range (((DFinsupp.lsum Nat) fun i => (S i).subtype).comp (DFinsupp.filterLinearMap R (fun i => Subtype fun x => Membership.mem (S i) x) p)))","decl":"/-- The bounded supremum of a family of commutative additive submonoids is equal to the range of\n`DFinsupp.sumAddHom` composed with `DFinsupp.filter_add_monoid_hom`; that is, every element in the\nbounded `iSup` can be produced from taking a finite number of non-zero elements from the `S i` that\nsatisfy `p i`, coercing them to `γ`, and summing them. -/\ntheorem biSup_eq_range_dfinsupp_lsum (p : ι → Prop) [DecidablePred p] (S : ι → Submodule R N) :\n    ⨆ (i) (_ : p i), S i =\n      LinearMap.range\n        (LinearMap.comp\n          (DFinsupp.lsum ℕ (M := fun i ↦ ↥(S i)) (fun i => (S i).subtype))\n            (DFinsupp.filterLinearMap R _ p)) := by\n  apply le_antisymm\n  · refine iSup₂_le fun i hi y hy => ⟨DFinsupp.single i ⟨y, hy⟩, ?_⟩\n    rw [LinearMap.comp_apply, filterLinearMap_apply, filter_single_pos _ _ hi]\n    simp only [lsum_apply_apply, sumAddHom_single, LinearMap.toAddMonoidHom_coe, coe_subtype]\n  · rintro x ⟨v, rfl⟩\n    refine dfinsupp_sumAddHom_mem _ _ _ fun i _ => ?_\n    refine mem_iSup_of_mem i ?_\n    by_cases hp : p i\n    · simp [hp]\n    · simp [hp]\n\n"}
{"name":"Submodule.mem_iSup_iff_exists_dfinsupp","module":"Mathlib.LinearAlgebra.DFinsupp","initialProofState":"ι : Type u_1\nR : Type u_2\nN : Type u_5\ninst✝³ : Semiring R\ninst✝² : AddCommMonoid N\ninst✝¹ : Module R N\ninst✝ : DecidableEq ι\np : ι → Submodule R N\nx : N\n⊢ Iff (Membership.mem (iSup p) x) (Exists fun f => Eq (((DFinsupp.lsum Nat) fun i => (p i).subtype) f) x)","decl":"/-- A characterisation of the span of a family of submodules.\n\nSee also `Submodule.mem_iSup_iff_exists_finsupp`. -/\ntheorem mem_iSup_iff_exists_dfinsupp (p : ι → Submodule R N) (x : N) :\n    x ∈ iSup p ↔\n      ∃ f : Π₀ i, p i, DFinsupp.lsum ℕ (M := fun i ↦ ↥(p i)) (fun i => (p i).subtype) f = x :=\n  SetLike.ext_iff.mp (iSup_eq_range_dfinsupp_lsum p) x\n\n"}
{"name":"Submodule.mem_iSup_iff_exists_dfinsupp'","module":"Mathlib.LinearAlgebra.DFinsupp","initialProofState":"ι : Type u_1\nR : Type u_2\nN : Type u_5\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid N\ninst✝² : Module R N\ninst✝¹ : DecidableEq ι\np : ι → Submodule R N\ninst✝ : (i : ι) → (x : Subtype fun x => Membership.mem (p i) x) → Decidable (Ne x 0)\nx : N\n⊢ Iff (Membership.mem (iSup p) x) (Exists fun f => Eq (f.sum fun x xi => ↑xi) x)","decl":"/-- A variant of `Submodule.mem_iSup_iff_exists_dfinsupp` with the RHS fully unfolded.\n\nSee also `Submodule.mem_iSup_iff_exists_finsupp`. -/\ntheorem mem_iSup_iff_exists_dfinsupp' (p : ι → Submodule R N) [∀ (i) (x : p i), Decidable (x ≠ 0)]\n    (x : N) : x ∈ iSup p ↔ ∃ f : Π₀ i, p i, (f.sum fun _ xi => ↑xi) = x := by\n  rw [mem_iSup_iff_exists_dfinsupp]\n  simp_rw [DFinsupp.lsum_apply_apply, DFinsupp.sumAddHom_apply,\n    LinearMap.toAddMonoidHom_coe, coe_subtype]\n\n"}
{"name":"Submodule.mem_biSup_iff_exists_dfinsupp","module":"Mathlib.LinearAlgebra.DFinsupp","initialProofState":"ι : Type u_1\nR : Type u_2\nN : Type u_5\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid N\ninst✝² : Module R N\ninst✝¹ : DecidableEq ι\np : ι → Prop\ninst✝ : DecidablePred p\nS : ι → Submodule R N\nx : N\n⊢ Iff (Membership.mem (iSup fun i => iSup fun x => S i) x) (Exists fun f => Eq (((DFinsupp.lsum Nat) fun i => (S i).subtype) (DFinsupp.filter p f)) x)","decl":"theorem mem_biSup_iff_exists_dfinsupp (p : ι → Prop) [DecidablePred p] (S : ι → Submodule R N)\n    (x : N) :\n    (x ∈ ⨆ (i) (_ : p i), S i) ↔\n      ∃ f : Π₀ i, S i,\n        DFinsupp.lsum ℕ (M := fun i ↦ ↥(S i)) (fun i => (S i).subtype) (f.filter p) = x :=\n  SetLike.ext_iff.mp (biSup_eq_range_dfinsupp_lsum p S) x\n\n"}
{"name":"Submodule.mem_iSup_iff_exists_finsupp","module":"Mathlib.LinearAlgebra.DFinsupp","initialProofState":"ι : Type u_1\nR : Type u_2\nN : Type u_5\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid N\ninst✝ : Module R N\np : ι → Submodule R N\nx : N\n⊢ Iff (Membership.mem (iSup p) x) (Exists fun f => And (∀ (i : ι), Membership.mem (p i) (f i)) (Eq (f.sum fun _i xi => xi) x))","decl":"lemma mem_iSup_iff_exists_finsupp (p : ι → Submodule R N) (x : N) :\n    x ∈ iSup p ↔ ∃ (f : ι →₀ N), (∀ i, f i ∈ p i) ∧ (f.sum fun _i xi ↦ xi) = x := by\n  classical\n  rw [mem_iSup_iff_exists_dfinsupp']\n  refine ⟨fun ⟨f, hf⟩ ↦ ⟨⟨f.support, fun i ↦ (f i : N), by simp⟩, by simp, hf⟩, ?_⟩\n  rintro ⟨f, hf, rfl⟩\n  refine ⟨DFinsupp.mk f.support fun i ↦ ⟨f i, hf i⟩, Finset.sum_congr ?_ fun i hi ↦ ?_⟩\n  · ext; simp [mk_eq_zero]\n  · simp [Finsupp.mem_support_iff.mp hi]\n\n"}
{"name":"Submodule.mem_iSup_finset_iff_exists_sum","module":"Mathlib.LinearAlgebra.DFinsupp","initialProofState":"ι : Type u_1\nR : Type u_2\nN : Type u_5\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid N\ninst✝ : Module R N\ns : Finset ι\np : ι → Submodule R N\na : N\n⊢ Iff (Membership.mem (iSup fun i => iSup fun h => p i) a) (Exists fun μ => Eq (s.sum fun i => ↑(μ i)) a)","decl":"theorem mem_iSup_finset_iff_exists_sum {s : Finset ι} (p : ι → Submodule R N) (a : N) :\n    (a ∈ ⨆ i ∈ s, p i) ↔ ∃ μ : ∀ i, p i, (∑ i ∈ s, (μ i : N)) = a := by\n  classical\n    rw [Submodule.mem_iSup_iff_exists_dfinsupp']\n    constructor <;> rintro ⟨μ, hμ⟩\n    · use fun i => ⟨μ i, (iSup_const_le : _ ≤ p i) (coe_mem <| μ i)⟩\n      rw [← hμ]\n      symm\n      apply Finset.sum_subset\n      · intro x\n        contrapose\n        intro hx\n        rw [mem_support_iff, not_ne_iff]\n        ext\n        rw [coe_zero, ← mem_bot R]\n        suffices ⊥ = ⨆ (_ : x ∈ s), p x from this.symm ▸ coe_mem (μ x)\n        exact (iSup_neg hx).symm\n      · intro x _ hx\n        rw [mem_support_iff, not_ne_iff] at hx\n        rw [hx]\n        rfl\n    · refine ⟨DFinsupp.mk s ?_, ?_⟩\n      · rintro ⟨i, hi⟩\n        refine ⟨μ i, ?_⟩\n        rw [iSup_pos]\n        · exact coe_mem _\n        · exact hi\n      simp only [DFinsupp.sum]\n      rw [Finset.sum_subset support_mk_subset, ← hμ]\n      · exact Finset.sum_congr rfl fun x hx => by rw [mk_of_mem hx]\n      · intro x _ hx\n        rw [mem_support_iff, not_ne_iff] at hx\n        rw [hx]\n        rfl\n\n"}
{"name":"iSupIndep_iff_forall_dfinsupp","module":"Mathlib.LinearAlgebra.DFinsupp","initialProofState":"ι : Type u_1\nR : Type u_2\nN : Type u_5\ninst✝³ : DecidableEq ι\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid N\ninst✝ : Module R N\np : ι → Submodule R N\n⊢ Iff (iSupIndep p) (∀ (i : ι) (x : Subtype fun x => Membership.mem (p i) x) (v : DFinsupp fun i => Subtype fun x => Membership.mem (p i) x), Eq (((DFinsupp.lsum Nat) fun i => (p i).subtype) (DFinsupp.erase i v)) ↑x → Eq x 0)","decl":"/-- Independence of a family of submodules can be expressed as a quantifier over `DFinsupp`s.\n\nThis is an intermediate result used to prove\n`iSupIndep_of_dfinsupp_lsum_injective` and\n`iSupIndep.dfinsupp_lsum_injective`. -/\ntheorem iSupIndep_iff_forall_dfinsupp (p : ι → Submodule R N) :\n    iSupIndep p ↔\n      ∀ (i) (x : p i) (v : Π₀ i : ι, ↥(p i)),\n        lsum ℕ (M := fun i ↦ ↥(p i)) (fun i => (p i).subtype) (erase i v) = x → x = 0 := by\n  simp_rw [iSupIndep_def, Submodule.disjoint_def,\n    Submodule.mem_biSup_iff_exists_dfinsupp, exists_imp, filter_ne_eq_erase]\n  refine forall_congr' fun i => Subtype.forall'.trans ?_\n  simp_rw [Submodule.coe_eq_zero]\n\n"}
{"name":"independent_iff_forall_dfinsupp","module":"Mathlib.LinearAlgebra.DFinsupp","initialProofState":"ι : Type u_1\nR : Type u_2\nN : Type u_5\ninst✝³ : DecidableEq ι\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid N\ninst✝ : Module R N\np : ι → Submodule R N\n⊢ Iff (iSupIndep p) (∀ (i : ι) (x : Subtype fun x => Membership.mem (p i) x) (v : DFinsupp fun i => Subtype fun x => Membership.mem (p i) x), Eq (((DFinsupp.lsum Nat) fun i => (p i).subtype) (DFinsupp.erase i v)) ↑x → Eq x 0)","decl":"@[deprecated (since := \"2024-11-24\")]\nalias independent_iff_forall_dfinsupp := iSupIndep_iff_forall_dfinsupp\n\n/- If `DFinsupp.lsum` applied with `Submodule.subtype` is injective then the submodules are\niSupIndep. -/\n"}
{"name":"iSupIndep_of_dfinsupp_lsum_injective","module":"Mathlib.LinearAlgebra.DFinsupp","initialProofState":"ι : Type u_1\nR : Type u_2\nN : Type u_5\ninst✝³ : DecidableEq ι\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid N\ninst✝ : Module R N\np : ι → Submodule R N\nh : Function.Injective ⇑((DFinsupp.lsum Nat) fun i => (p i).subtype)\n⊢ iSupIndep p","decl":"theorem iSupIndep_of_dfinsupp_lsum_injective (p : ι → Submodule R N)\n    (h : Function.Injective (lsum ℕ (M := fun i ↦ ↥(p i)) fun i => (p i).subtype)) :\n    iSupIndep p := by\n  rw [iSupIndep_iff_forall_dfinsupp]\n  intro i x v hv\n  replace hv : lsum ℕ (M := fun i ↦ ↥(p i)) (fun i => (p i).subtype) (erase i v) =\n      lsum ℕ (M := fun i ↦ ↥(p i)) (fun i => (p i).subtype) (single i x) := by\n    simpa only [lsum_single] using hv\n  have := DFunLike.ext_iff.mp (h hv) i\n  simpa [eq_comm] using this\n\n"}
{"name":"independent_of_dfinsupp_lsum_injective","module":"Mathlib.LinearAlgebra.DFinsupp","initialProofState":"ι : Type u_1\nR : Type u_2\nN : Type u_5\ninst✝³ : DecidableEq ι\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid N\ninst✝ : Module R N\np : ι → Submodule R N\nh : Function.Injective ⇑((DFinsupp.lsum Nat) fun i => (p i).subtype)\n⊢ iSupIndep p","decl":"@[deprecated (since := \"2024-11-24\")]\nalias independent_of_dfinsupp_lsum_injective := iSupIndep_of_dfinsupp_lsum_injective\n\n/- If `DFinsupp.sumAddHom` applied with `AddSubmonoid.subtype` is injective then the additive\nsubmonoids are independent. -/\n"}
{"name":"iSupIndep_of_dfinsupp_sumAddHom_injective","module":"Mathlib.LinearAlgebra.DFinsupp","initialProofState":"ι : Type u_1\nN : Type u_5\ninst✝¹ : DecidableEq ι\ninst✝ : AddCommMonoid N\np : ι → AddSubmonoid N\nh : Function.Injective ⇑(DFinsupp.sumAddHom fun i => (p i).subtype)\n⊢ iSupIndep p","decl":"theorem iSupIndep_of_dfinsupp_sumAddHom_injective (p : ι → AddSubmonoid N)\n    (h : Function.Injective (sumAddHom fun i => (p i).subtype)) : iSupIndep p := by\n  rw [← iSupIndep_map_orderIso_iff (AddSubmonoid.toNatSubmodule : AddSubmonoid N ≃o _)]\n  exact iSupIndep_of_dfinsupp_lsum_injective _ h\n\n"}
{"name":"independent_of_dfinsupp_sumAddHom_injective","module":"Mathlib.LinearAlgebra.DFinsupp","initialProofState":"ι : Type u_1\nN : Type u_5\ninst✝¹ : DecidableEq ι\ninst✝ : AddCommMonoid N\np : ι → AddSubmonoid N\nh : Function.Injective ⇑(DFinsupp.sumAddHom fun i => (p i).subtype)\n⊢ iSupIndep p","decl":"@[deprecated (since := \"2024-11-24\")]\nalias independent_of_dfinsupp_sumAddHom_injective := iSupIndep_of_dfinsupp_sumAddHom_injective\n\n"}
{"name":"lsum_comp_mapRange_toSpanSingleton","module":"Mathlib.LinearAlgebra.DFinsupp","initialProofState":"ι : Type u_1\nR : Type u_2\nN : Type u_5\ninst✝⁴ : DecidableEq ι\ninst✝³ : Semiring R\ninst✝² : AddCommMonoid N\ninst✝¹ : Module R N\ninst✝ : (m : R) → Decidable (Ne m 0)\np : ι → Submodule R N\nv : ι → N\nhv : ∀ (i : ι), Membership.mem (p i) (v i)\n⊢ Eq (((DFinsupp.lsum Nat) fun i => (p i).subtype).comp ((DFinsupp.mapRange.linearMap fun i => LinearMap.toSpanSingleton R (Subtype fun x => Membership.mem (p i) x) ⟨v i, ⋯⟩).comp ↑(finsuppLequivDFinsupp R))) (Finsupp.linearCombination R v)","decl":"/-- Combining `DFinsupp.lsum` with `LinearMap.toSpanSingleton` is the same as\n`Finsupp.linearCombination` -/\ntheorem lsum_comp_mapRange_toSpanSingleton [∀ m : R, Decidable (m ≠ 0)] (p : ι → Submodule R N)\n    {v : ι → N} (hv : ∀ i : ι, v i ∈ p i) :\n    (lsum ℕ (M := fun i ↦ ↥(p i)) fun i => (p i).subtype : _ →ₗ[R] _).comp\n        ((mapRange.linearMap fun i => LinearMap.toSpanSingleton R (↥(p i)) ⟨v i, hv i⟩ :\n              _ →ₗ[R] _).comp\n          (finsuppLequivDFinsupp R : (ι →₀ R) ≃ₗ[R] _).toLinearMap) =\n      Finsupp.linearCombination R v := by\n  ext\n  simp\n\n"}
{"name":"iSupIndep_of_dfinsupp_sumAddHom_injective'","module":"Mathlib.LinearAlgebra.DFinsupp","initialProofState":"ι : Type u_1\nN : Type u_5\ninst✝¹ : DecidableEq ι\ninst✝ : AddCommGroup N\np : ι → AddSubgroup N\nh : Function.Injective ⇑(DFinsupp.sumAddHom fun i => (p i).subtype)\n⊢ iSupIndep p","decl":"/-- If `DFinsupp.sumAddHom` applied with `AddSubmonoid.subtype` is injective then the additive\nsubgroups are independent. -/\ntheorem iSupIndep_of_dfinsupp_sumAddHom_injective' (p : ι → AddSubgroup N)\n    (h : Function.Injective (sumAddHom fun i => (p i).subtype)) : iSupIndep p := by\n  rw [← iSupIndep_map_orderIso_iff (AddSubgroup.toIntSubmodule : AddSubgroup N ≃o _)]\n  exact iSupIndep_of_dfinsupp_lsum_injective _ h\n\n"}
{"name":"independent_of_dfinsupp_sumAddHom_injective'","module":"Mathlib.LinearAlgebra.DFinsupp","initialProofState":"ι : Type u_1\nN : Type u_5\ninst✝¹ : DecidableEq ι\ninst✝ : AddCommGroup N\np : ι → AddSubgroup N\nh : Function.Injective ⇑(DFinsupp.sumAddHom fun i => (p i).subtype)\n⊢ iSupIndep p","decl":"@[deprecated (since := \"2024-11-24\")]\nalias independent_of_dfinsupp_sumAddHom_injective' := iSupIndep_of_dfinsupp_sumAddHom_injective'\n\n"}
{"name":"iSupIndep.dfinsupp_lsum_injective","module":"Mathlib.LinearAlgebra.DFinsupp","initialProofState":"ι : Type u_1\nR : Type u_2\nN : Type u_5\ninst✝³ : DecidableEq ι\ninst✝² : Ring R\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\np : ι → Submodule R N\nh : iSupIndep p\n⊢ Function.Injective ⇑((DFinsupp.lsum Nat) fun i => (p i).subtype)","decl":"/-- The canonical map out of a direct sum of a family of submodules is injective when the submodules\nare `iSupIndep`.\n\nNote that this is not generally true for `[Semiring R]`, for instance when `A` is the\n`ℕ`-submodules of the positive and negative integers.\n\nSee `Counterexamples/DirectSumIsInternal.lean` for a proof of this fact. -/\ntheorem iSupIndep.dfinsupp_lsum_injective {p : ι → Submodule R N} (h : iSupIndep p) :\n    Function.Injective (lsum ℕ (M := fun i ↦ ↥(p i)) fun i => (p i).subtype) := by\n  -- simplify everything down to binders over equalities in `N`\n  rw [iSupIndep_iff_forall_dfinsupp] at h\n  suffices LinearMap.ker (lsum ℕ (M := fun i ↦ ↥(p i)) fun i => (p i).subtype) = ⊥ by\n    -- Lean can't find this without our help\n    letI thisI : AddCommGroup (Π₀ i, p i) := inferInstance\n    rw [LinearMap.ker_eq_bot] at this\n    exact this\n  rw [LinearMap.ker_eq_bot']\n  intro m hm\n  ext i : 1\n  -- split `m` into the piece at `i` and the pieces elsewhere, to match `h`\n  rw [DFinsupp.zero_apply, ← neg_eq_zero]\n  refine h i (-m i) m ?_\n  rwa [← erase_add_single i m, LinearMap.map_add, lsum_single, Submodule.subtype_apply,\n    add_eq_zero_iff_eq_neg, ← Submodule.coe_neg] at hm\n\n"}
{"name":"Independent.dfinsupp_lsum_injective","module":"Mathlib.LinearAlgebra.DFinsupp","initialProofState":"ι : Type u_1\nR : Type u_2\nN : Type u_5\ninst✝³ : DecidableEq ι\ninst✝² : Ring R\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\np : ι → Submodule R N\nh : iSupIndep p\n⊢ Function.Injective ⇑((DFinsupp.lsum Nat) fun i => (p i).subtype)","decl":"@[deprecated (since := \"2024-11-24\")]\nalias Independent.dfinsupp_lsum_injective := iSupIndep.dfinsupp_lsum_injective\n\n"}
{"name":"iSupIndep.dfinsupp_sumAddHom_injective","module":"Mathlib.LinearAlgebra.DFinsupp","initialProofState":"ι : Type u_1\nN : Type u_5\ninst✝¹ : DecidableEq ι\ninst✝ : AddCommGroup N\np : ι → AddSubgroup N\nh : iSupIndep p\n⊢ Function.Injective ⇑(DFinsupp.sumAddHom fun i => (p i).subtype)","decl":"/-- The canonical map out of a direct sum of a family of additive subgroups is injective when the\nadditive subgroups are `iSupIndep`. -/\ntheorem iSupIndep.dfinsupp_sumAddHom_injective {p : ι → AddSubgroup N} (h : iSupIndep p) :\n    Function.Injective (sumAddHom fun i => (p i).subtype) := by\n  rw [← iSupIndep_map_orderIso_iff (AddSubgroup.toIntSubmodule : AddSubgroup N ≃o _)] at h\n  exact h.dfinsupp_lsum_injective\n\n"}
{"name":"Independent.dfinsupp_sumAddHom_injective","module":"Mathlib.LinearAlgebra.DFinsupp","initialProofState":"ι : Type u_1\nN : Type u_5\ninst✝¹ : DecidableEq ι\ninst✝ : AddCommGroup N\np : ι → AddSubgroup N\nh : iSupIndep p\n⊢ Function.Injective ⇑(DFinsupp.sumAddHom fun i => (p i).subtype)","decl":"@[deprecated (since := \"2024-11-24\")]\nalias Independent.dfinsupp_sumAddHom_injective := iSupIndep.dfinsupp_sumAddHom_injective\n\n"}
{"name":"iSupIndep_iff_dfinsupp_lsum_injective","module":"Mathlib.LinearAlgebra.DFinsupp","initialProofState":"ι : Type u_1\nR : Type u_2\nN : Type u_5\ninst✝³ : DecidableEq ι\ninst✝² : Ring R\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\np : ι → Submodule R N\n⊢ Iff (iSupIndep p) (Function.Injective ⇑((DFinsupp.lsum Nat) fun i => (p i).subtype))","decl":"/-- A family of submodules over an additive group are independent if and only iff `DFinsupp.lsum`\napplied with `Submodule.subtype` is injective.\n\nNote that this is not generally true for `[Semiring R]`; see\n`iSupIndep.dfinsupp_lsum_injective` for details. -/\ntheorem iSupIndep_iff_dfinsupp_lsum_injective (p : ι → Submodule R N) :\n    iSupIndep p ↔ Function.Injective (lsum ℕ (M := fun i ↦ ↥(p i)) fun i => (p i).subtype) :=\n  ⟨iSupIndep.dfinsupp_lsum_injective, iSupIndep_of_dfinsupp_lsum_injective p⟩\n\n"}
{"name":"independent_iff_dfinsupp_lsum_injective","module":"Mathlib.LinearAlgebra.DFinsupp","initialProofState":"ι : Type u_1\nR : Type u_2\nN : Type u_5\ninst✝³ : DecidableEq ι\ninst✝² : Ring R\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\np : ι → Submodule R N\n⊢ Iff (iSupIndep p) (Function.Injective ⇑((DFinsupp.lsum Nat) fun i => (p i).subtype))","decl":"@[deprecated (since := \"2024-11-24\")]\nalias independent_iff_dfinsupp_lsum_injective := iSupIndep_iff_dfinsupp_lsum_injective\n\n"}
{"name":"iSupIndep_iff_dfinsupp_sumAddHom_injective","module":"Mathlib.LinearAlgebra.DFinsupp","initialProofState":"ι : Type u_1\nN : Type u_5\ninst✝¹ : DecidableEq ι\ninst✝ : AddCommGroup N\np : ι → AddSubgroup N\n⊢ Iff (iSupIndep p) (Function.Injective ⇑(DFinsupp.sumAddHom fun i => (p i).subtype))","decl":"/-- A family of additive subgroups over an additive group are independent if and only if\n`DFinsupp.sumAddHom` applied with `AddSubgroup.subtype` is injective. -/\ntheorem iSupIndep_iff_dfinsupp_sumAddHom_injective (p : ι → AddSubgroup N) :\n    iSupIndep p ↔ Function.Injective (sumAddHom fun i => (p i).subtype) :=\n  ⟨iSupIndep.dfinsupp_sumAddHom_injective, iSupIndep_of_dfinsupp_sumAddHom_injective' p⟩\n\n"}
{"name":"independent_iff_dfinsupp_sumAddHom_injective","module":"Mathlib.LinearAlgebra.DFinsupp","initialProofState":"ι : Type u_1\nN : Type u_5\ninst✝¹ : DecidableEq ι\ninst✝ : AddCommGroup N\np : ι → AddSubgroup N\n⊢ Iff (iSupIndep p) (Function.Injective ⇑(DFinsupp.sumAddHom fun i => (p i).subtype))","decl":"@[deprecated (since := \"2024-11-24\")]\nalias independent_iff_dfinsupp_sumAddHom_injective := iSupIndep_iff_dfinsupp_sumAddHom_injective\n\n"}
{"name":"iSupIndep.linearIndependent","module":"Mathlib.LinearAlgebra.DFinsupp","initialProofState":"R : Type u_2\nN : Type u_5\ninst✝³ : Ring R\ninst✝² : AddCommGroup N\ninst✝¹ : Module R N\ninst✝ : NoZeroSMulDivisors R N\nι : Type u_6\np : ι → Submodule R N\nhp : iSupIndep p\nv : ι → N\nhv : ∀ (i : ι), Membership.mem (p i) (v i)\nhv' : ∀ (i : ι), Ne (v i) 0\n⊢ LinearIndependent R v","decl":"/-- If a family of submodules is independent, then a choice of nonzero vector from each submodule\nforms a linearly independent family.\n\nSee also `iSupIndep.linearIndependent'`. -/\ntheorem iSupIndep.linearIndependent [NoZeroSMulDivisors R N] {ι} (p : ι → Submodule R N)\n    (hp : iSupIndep p) {v : ι → N} (hv : ∀ i, v i ∈ p i) (hv' : ∀ i, v i ≠ 0) :\n    LinearIndependent R v := by\n  let _ := Classical.decEq ι\n  let _ := Classical.decEq R\n  rw [linearIndependent_iff]\n  intro l hl\n  let a :=\n    DFinsupp.mapRange.linearMap (fun i => LinearMap.toSpanSingleton R (p i) ⟨v i, hv i⟩)\n      l.toDFinsupp\n  have ha : a = 0 := by\n    apply hp.dfinsupp_lsum_injective\n    rwa [← lsum_comp_mapRange_toSpanSingleton _ hv] at hl\n  ext i\n  apply smul_left_injective R (hv' i)\n  have : l i • v i = a i := rfl\n  simp only [coe_zero, Pi.zero_apply, ZeroMemClass.coe_zero, smul_eq_zero, ha] at this\n  simpa\n\n"}
{"name":"Independent.linearIndependent","module":"Mathlib.LinearAlgebra.DFinsupp","initialProofState":"R : Type u_2\nN : Type u_5\ninst✝³ : Ring R\ninst✝² : AddCommGroup N\ninst✝¹ : Module R N\ninst✝ : NoZeroSMulDivisors R N\nι : Type u_6\np : ι → Submodule R N\nhp : iSupIndep p\nv : ι → N\nhv : ∀ (i : ι), Membership.mem (p i) (v i)\nhv' : ∀ (i : ι), Ne (v i) 0\n⊢ LinearIndependent R v","decl":"@[deprecated (since := \"2024-11-24\")]\nalias Independent.linearIndependent := iSupIndep.linearIndependent\n\n"}
{"name":"iSupIndep_iff_linearIndependent_of_ne_zero","module":"Mathlib.LinearAlgebra.DFinsupp","initialProofState":"R : Type u_2\nN : Type u_5\ninst✝³ : Ring R\ninst✝² : AddCommGroup N\ninst✝¹ : Module R N\ninst✝ : NoZeroSMulDivisors R N\nι : Type u_6\nv : ι → N\nh_ne_zero : ∀ (i : ι), Ne (v i) 0\n⊢ Iff (iSupIndep fun i => Submodule.span R (Singleton.singleton (v i))) (LinearIndependent R v)","decl":"theorem iSupIndep_iff_linearIndependent_of_ne_zero [NoZeroSMulDivisors R N] {ι} {v : ι → N}\n    (h_ne_zero : ∀ i, v i ≠ 0) : (iSupIndep fun i => R ∙ v i) ↔ LinearIndependent R v :=\n  let _ := Classical.decEq ι\n  ⟨fun hv => hv.linearIndependent _ (fun i => Submodule.mem_span_singleton_self <| v i) h_ne_zero,\n    fun hv => hv.iSupIndep_span_singleton⟩\n\n"}
{"name":"independent_iff_linearIndependent_of_ne_zero","module":"Mathlib.LinearAlgebra.DFinsupp","initialProofState":"R : Type u_2\nN : Type u_5\ninst✝³ : Ring R\ninst✝² : AddCommGroup N\ninst✝¹ : Module R N\ninst✝ : NoZeroSMulDivisors R N\nι : Type u_6\nv : ι → N\nh_ne_zero : ∀ (i : ι), Ne (v i) 0\n⊢ Iff (iSupIndep fun i => Submodule.span R (Singleton.singleton (v i))) (LinearIndependent R v)","decl":"@[deprecated (since := \"2024-11-24\")]\nalias independent_iff_linearIndependent_of_ne_zero := iSupIndep_iff_linearIndependent_of_ne_zero\n\n"}
{"name":"LinearMap.coe_dfinsupp_sum","module":"Mathlib.LinearAlgebra.DFinsupp","initialProofState":"R : Type u_6\nR₂ : Type u_7\nM : Type u_8\nM₂ : Type u_9\nι : Type u_10\ninst✝⁸ : Semiring R\ninst✝⁷ : Semiring R₂\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : AddCommMonoid M₂\nσ₁₂ : RingHom R R₂\ninst✝⁴ : Module R M\ninst✝³ : Module R₂ M₂\nγ : ι → Type u_11\ninst✝² : DecidableEq ι\ninst✝¹ : (i : ι) → Zero (γ i)\ninst✝ : (i : ι) → (x : γ i) → Decidable (Ne x 0)\nt : DFinsupp fun i => γ i\ng : (i : ι) → γ i → LinearMap σ₁₂ M M₂\n⊢ Eq ⇑(t.sum g) ⇑(t.sum fun i d => g i d)","decl":"theorem coe_dfinsupp_sum (t : Π₀ i, γ i) (g : ∀ i, γ i → M →ₛₗ[σ₁₂] M₂) :\n    ⇑(t.sum g) = t.sum fun i d => g i d := rfl\n\n"}
{"name":"LinearMap.dfinsupp_sum_apply","module":"Mathlib.LinearAlgebra.DFinsupp","initialProofState":"R : Type u_6\nR₂ : Type u_7\nM : Type u_8\nM₂ : Type u_9\nι : Type u_10\ninst✝⁸ : Semiring R\ninst✝⁷ : Semiring R₂\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : AddCommMonoid M₂\nσ₁₂ : RingHom R R₂\ninst✝⁴ : Module R M\ninst✝³ : Module R₂ M₂\nγ : ι → Type u_11\ninst✝² : DecidableEq ι\ninst✝¹ : (i : ι) → Zero (γ i)\ninst✝ : (i : ι) → (x : γ i) → Decidable (Ne x 0)\nt : DFinsupp fun i => γ i\ng : (i : ι) → γ i → LinearMap σ₁₂ M M₂\nb : M\n⊢ Eq ((t.sum g) b) (t.sum fun i d => (g i d) b)","decl":"@[simp]\ntheorem dfinsupp_sum_apply (t : Π₀ i, γ i) (g : ∀ i, γ i → M →ₛₗ[σ₁₂] M₂) (b : M) :\n    (t.sum g) b = t.sum fun i d => g i d b :=\n  sum_apply _ _ _\n\n"}
{"name":"LinearMap.map_dfinsupp_sumAddHom","module":"Mathlib.LinearAlgebra.DFinsupp","initialProofState":"R : Type u_6\nR₂ : Type u_7\nM : Type u_8\nM₂ : Type u_9\nι : Type u_10\ninst✝⁷ : Semiring R\ninst✝⁶ : Semiring R₂\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : AddCommMonoid M₂\nσ₁₂ : RingHom R R₂\ninst✝³ : Module R M\ninst✝² : Module R₂ M₂\nγ : ι → Type u_11\ninst✝¹ : DecidableEq ι\ninst✝ : (i : ι) → AddZeroClass (γ i)\nf : LinearMap σ₁₂ M M₂\nt : DFinsupp fun i => γ i\ng : (i : ι) → AddMonoidHom (γ i) M\n⊢ Eq (f ((DFinsupp.sumAddHom g) t)) ((DFinsupp.sumAddHom fun i => f.toAddMonoidHom.comp (g i)) t)","decl":"@[simp]\ntheorem map_dfinsupp_sumAddHom (f : M →ₛₗ[σ₁₂] M₂) {t : Π₀ i, γ i} {g : ∀ i, γ i →+ M} :\n    f (sumAddHom g t) = sumAddHom (fun i => f.toAddMonoidHom.comp (g i)) t :=\n  f.toAddMonoidHom.map_dfinsupp_sumAddHom _ _\n\n"}
{"name":"LinearEquiv.map_dfinsupp_sumAddHom","module":"Mathlib.LinearAlgebra.DFinsupp","initialProofState":"R : Type u_6\nR₂ : Type u_7\nM : Type u_8\nM₂ : Type u_9\nι : Type u_10\ninst✝⁹ : Semiring R\ninst✝⁸ : Semiring R₂\ninst✝⁷ : AddCommMonoid M\ninst✝⁶ : AddCommMonoid M₂\ninst✝⁵ : Module R M\ninst✝⁴ : Module R₂ M₂\nτ₁₂ : RingHom R R₂\nτ₂₁ : RingHom R₂ R\ninst✝³ : RingHomInvPair τ₁₂ τ₂₁\ninst✝² : RingHomInvPair τ₂₁ τ₁₂\nγ : ι → Type u_11\ninst✝¹ : DecidableEq ι\ninst✝ : (i : ι) → AddZeroClass (γ i)\nf : LinearEquiv τ₁₂ M M₂\nt : DFinsupp fun i => γ i\ng : (i : ι) → AddMonoidHom (γ i) M\n⊢ Eq (f ((DFinsupp.sumAddHom g) t)) ((DFinsupp.sumAddHom fun i => f.toAddEquiv.toAddMonoidHom.comp (g i)) t)","decl":"@[simp]\ntheorem map_dfinsupp_sumAddHom [∀ i, AddZeroClass (γ i)] (f : M ≃ₛₗ[τ₁₂] M₂) (t : Π₀ i, γ i)\n    (g : ∀ i, γ i →+ M) :\n    f (sumAddHom g t) = sumAddHom (fun i => f.toAddEquiv.toAddMonoidHom.comp (g i)) t :=\n  f.toAddEquiv.map_dfinsupp_sumAddHom _ _\n\n"}
