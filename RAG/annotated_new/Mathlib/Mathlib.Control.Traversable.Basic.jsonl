{"name":"ApplicativeTransformation.preserves_seq'","module":"Mathlib.Control.Traversable.Basic","initialProofState":"F : Type u → Type v\ninst✝¹ : Applicative F\nG : Type u → Type w\ninst✝ : Applicative G\nself : ApplicativeTransformation F G\nα β : Type u\nx : F (α → β)\ny : F α\n⊢ Eq (self.app β (Seq.seq x fun x => y)) (Seq.seq (self.app (α → β) x) fun x => self.app α y)","decl":"/-- A transformation between applicative functors.  It is a natural\ntransformation such that `app` preserves the `Pure.pure` and\n`Functor.map` (`<*>`) operations. See\n`ApplicativeTransformation.preserves_map` for naturality. -/\nstructure ApplicativeTransformation : Type max (u + 1) v w where\n  /-- The function on objects defined by an `ApplicativeTransformation`. -/\n  app : ∀ α : Type u, F α → G α\n  /-- An `ApplicativeTransformation` preserves `pure`. -/\n  preserves_pure' : ∀ {α : Type u} (x : α), app _ (pure x) = pure x\n  /-- An `ApplicativeTransformation` intertwines `seq`. -/\n  preserves_seq' : ∀ {α β : Type u} (x : F (α → β)) (y : F α), app _ (x <*> y) = app _ x <*> app _ y\n\n"}
{"name":"ApplicativeTransformation.preserves_pure'","module":"Mathlib.Control.Traversable.Basic","initialProofState":"F : Type u → Type v\ninst✝¹ : Applicative F\nG : Type u → Type w\ninst✝ : Applicative G\nself : ApplicativeTransformation F G\nα : Type u\nx : α\n⊢ Eq (self.app α (Pure.pure x)) (Pure.pure x)","decl":"/-- A transformation between applicative functors.  It is a natural\ntransformation such that `app` preserves the `Pure.pure` and\n`Functor.map` (`<*>`) operations. See\n`ApplicativeTransformation.preserves_map` for naturality. -/\nstructure ApplicativeTransformation : Type max (u + 1) v w where\n  /-- The function on objects defined by an `ApplicativeTransformation`. -/\n  app : ∀ α : Type u, F α → G α\n  /-- An `ApplicativeTransformation` preserves `pure`. -/\n  preserves_pure' : ∀ {α : Type u} (x : α), app _ (pure x) = pure x\n  /-- An `ApplicativeTransformation` intertwines `seq`. -/\n  preserves_seq' : ∀ {α β : Type u} (x : F (α → β)) (y : F α), app _ (x <*> y) = app _ x <*> app _ y\n\n"}
{"name":"ApplicativeTransformation.mk.sizeOf_spec","module":"Mathlib.Control.Traversable.Basic","initialProofState":"F : Type u → Type v\ninst✝³ : Applicative F\nG : Type u → Type w\ninst✝² : Applicative G\ninst✝¹ : (a : Type u) → SizeOf (F a)\ninst✝ : (a : Type u) → SizeOf (G a)\napp : (α : Type u) → F α → G α\npreserves_pure' : ∀ {α : Type u} (x : α), Eq (app α (Pure.pure x)) (Pure.pure x)\npreserves_seq' : ∀ {α β : Type u} (x : F (α → β)) (y : F α), Eq (app β (Seq.seq x fun x => y)) (Seq.seq (app (α → β) x) fun x => app α y)\n⊢ Eq (SizeOf.sizeOf { app := app, preserves_pure' := preserves_pure', preserves_seq' := preserves_seq' }) 1","decl":"/-- A transformation between applicative functors.  It is a natural\ntransformation such that `app` preserves the `Pure.pure` and\n`Functor.map` (`<*>`) operations. See\n`ApplicativeTransformation.preserves_map` for naturality. -/\nstructure ApplicativeTransformation : Type max (u + 1) v w where\n  /-- The function on objects defined by an `ApplicativeTransformation`. -/\n  app : ∀ α : Type u, F α → G α\n  /-- An `ApplicativeTransformation` preserves `pure`. -/\n  preserves_pure' : ∀ {α : Type u} (x : α), app _ (pure x) = pure x\n  /-- An `ApplicativeTransformation` intertwines `seq`. -/\n  preserves_seq' : ∀ {α β : Type u} (x : F (α → β)) (y : F α), app _ (x <*> y) = app _ x <*> app _ y\n\n"}
{"name":"ApplicativeTransformation.mk.injEq","module":"Mathlib.Control.Traversable.Basic","initialProofState":"F : Type u → Type v\ninst✝¹ : Applicative F\nG : Type u → Type w\ninst✝ : Applicative G\napp✝ : (α : Type u) → F α → G α\npreserves_pure'✝ : ∀ {α : Type u} (x : α), Eq (app✝ α (Pure.pure x)) (Pure.pure x)\npreserves_seq'✝ : ∀ {α β : Type u} (x : F (α → β)) (y : F α), Eq (app✝ β (Seq.seq x fun x => y)) (Seq.seq (app✝ (α → β) x) fun x => app✝ α y)\napp : (α : Type u) → F α → G α\npreserves_pure' : ∀ {α : Type u} (x : α), Eq (app α (Pure.pure x)) (Pure.pure x)\npreserves_seq' : ∀ {α β : Type u} (x : F (α → β)) (y : F α), Eq (app β (Seq.seq x fun x => y)) (Seq.seq (app (α → β) x) fun x => app α y)\n⊢ Eq (Eq { app := app✝, preserves_pure' := preserves_pure'✝, preserves_seq' := preserves_seq'✝ } { app := app, preserves_pure' := preserves_pure', preserves_seq' := preserves_seq' }) (Eq app✝ app)","decl":"/-- A transformation between applicative functors.  It is a natural\ntransformation such that `app` preserves the `Pure.pure` and\n`Functor.map` (`<*>`) operations. See\n`ApplicativeTransformation.preserves_map` for naturality. -/\nstructure ApplicativeTransformation : Type max (u + 1) v w where\n  /-- The function on objects defined by an `ApplicativeTransformation`. -/\n  app : ∀ α : Type u, F α → G α\n  /-- An `ApplicativeTransformation` preserves `pure`. -/\n  preserves_pure' : ∀ {α : Type u} (x : α), app _ (pure x) = pure x\n  /-- An `ApplicativeTransformation` intertwines `seq`. -/\n  preserves_seq' : ∀ {α β : Type u} (x : F (α → β)) (y : F α), app _ (x <*> y) = app _ x <*> app _ y\n\n"}
{"name":"ApplicativeTransformation.mk.inj","module":"Mathlib.Control.Traversable.Basic","initialProofState":"F : Type u → Type v\ninst✝¹ : Applicative F\nG : Type u → Type w\ninst✝ : Applicative G\napp✝ : (α : Type u) → F α → G α\npreserves_pure'✝ : ∀ {α : Type u} (x : α), Eq (app✝ α (Pure.pure x)) (Pure.pure x)\npreserves_seq'✝ : ∀ {α β : Type u} (x : F (α → β)) (y : F α), Eq (app✝ β (Seq.seq x fun x => y)) (Seq.seq (app✝ (α → β) x) fun x => app✝ α y)\napp : (α : Type u) → F α → G α\npreserves_pure' : ∀ {α : Type u} (x : α), Eq (app α (Pure.pure x)) (Pure.pure x)\npreserves_seq' : ∀ {α β : Type u} (x : F (α → β)) (y : F α), Eq (app β (Seq.seq x fun x => y)) (Seq.seq (app (α → β) x) fun x => app α y)\nx✝ : Eq { app := app✝, preserves_pure' := preserves_pure'✝, preserves_seq' := preserves_seq'✝ } { app := app, preserves_pure' := preserves_pure', preserves_seq' := preserves_seq' }\n⊢ Eq app✝ app","decl":"/-- A transformation between applicative functors.  It is a natural\ntransformation such that `app` preserves the `Pure.pure` and\n`Functor.map` (`<*>`) operations. See\n`ApplicativeTransformation.preserves_map` for naturality. -/\nstructure ApplicativeTransformation : Type max (u + 1) v w where\n  /-- The function on objects defined by an `ApplicativeTransformation`. -/\n  app : ∀ α : Type u, F α → G α\n  /-- An `ApplicativeTransformation` preserves `pure`. -/\n  preserves_pure' : ∀ {α : Type u} (x : α), app _ (pure x) = pure x\n  /-- An `ApplicativeTransformation` intertwines `seq`. -/\n  preserves_seq' : ∀ {α β : Type u} (x : F (α → β)) (y : F α), app _ (x <*> y) = app _ x <*> app _ y\n\n"}
{"name":"ApplicativeTransformation.app_eq_coe","module":"Mathlib.Control.Traversable.Basic","initialProofState":"F : Type u → Type v\ninst✝¹ : Applicative F\nG : Type u → Type w\ninst✝ : Applicative G\nη : ApplicativeTransformation F G\n⊢ Eq η.app fun {α} => η.app α","decl":"theorem app_eq_coe (η : ApplicativeTransformation F G) : η.app = η :=\n  rfl\n\n"}
{"name":"ApplicativeTransformation.coe_mk","module":"Mathlib.Control.Traversable.Basic","initialProofState":"F : Type u → Type v\ninst✝¹ : Applicative F\nG : Type u → Type w\ninst✝ : Applicative G\nf : (α : Type u) → F α → G α\npp : ∀ {α : Type u} (x : α), Eq (f α (Pure.pure x)) (Pure.pure x)\nps : ∀ {α β : Type u} (x : F (α → β)) (y : F α), Eq (f β (Seq.seq x fun x => y)) (Seq.seq (f (α → β) x) fun x => f α y)\n⊢ Eq (fun {α} => { app := f, preserves_pure' := pp, preserves_seq' := ps }.app α) f","decl":"@[simp]\ntheorem coe_mk (f : ∀ α : Type u, F α → G α) (pp ps) :\n    (ApplicativeTransformation.mk f @pp @ps) = f :=\n  rfl\n\n"}
{"name":"ApplicativeTransformation.congr_fun","module":"Mathlib.Control.Traversable.Basic","initialProofState":"F : Type u → Type v\ninst✝¹ : Applicative F\nG : Type u → Type w\ninst✝ : Applicative G\nη η' : ApplicativeTransformation F G\nh : Eq η η'\nα : Type u\nx : F α\n⊢ Eq ((fun {α} => η.app α) x) ((fun {α} => η'.app α) x)","decl":"protected theorem congr_fun (η η' : ApplicativeTransformation F G) (h : η = η') {α : Type u}\n    (x : F α) : η x = η' x :=\n  congrArg (fun η'' : ApplicativeTransformation F G => η'' x) h\n\n"}
{"name":"ApplicativeTransformation.congr_arg","module":"Mathlib.Control.Traversable.Basic","initialProofState":"F : Type u → Type v\ninst✝¹ : Applicative F\nG : Type u → Type w\ninst✝ : Applicative G\nη : ApplicativeTransformation F G\nα : Type u\nx y : F α\nh : Eq x y\n⊢ Eq ((fun {α} => η.app α) x) ((fun {α} => η.app α) y)","decl":"protected theorem congr_arg (η : ApplicativeTransformation F G) {α : Type u} {x y : F α}\n    (h : x = y) : η x = η y :=\n  congrArg (fun z : F α => η z) h\n\n"}
{"name":"ApplicativeTransformation.coe_inj","module":"Mathlib.Control.Traversable.Basic","initialProofState":"F : Type u → Type v\ninst✝¹ : Applicative F\nG : Type u → Type w\ninst✝ : Applicative G\nη η' : ApplicativeTransformation F G\nh : Eq (fun {α} => η.app α) fun {α} => η'.app α\n⊢ Eq η η'","decl":"theorem coe_inj ⦃η η' : ApplicativeTransformation F G⦄ (h : (η : ∀ α, F α → G α) = η') :\n    η = η' := by\n  cases η\n  cases η'\n  congr\n\n"}
{"name":"ApplicativeTransformation.ext_iff","module":"Mathlib.Control.Traversable.Basic","initialProofState":"F : Type u → Type v\ninst✝¹ : Applicative F\nG : Type u → Type w\ninst✝ : Applicative G\nη η' : ApplicativeTransformation F G\n⊢ Iff (Eq η η') (∀ (α : Type u) (x : F α), Eq ((fun {α} => η.app α) x) ((fun {α} => η'.app α) x))","decl":"@[ext]\ntheorem ext ⦃η η' : ApplicativeTransformation F G⦄ (h : ∀ (α : Type u) (x : F α), η x = η' x) :\n    η = η' := by\n  apply coe_inj\n  ext1 α\n  exact funext (h α)\n\n"}
{"name":"ApplicativeTransformation.ext","module":"Mathlib.Control.Traversable.Basic","initialProofState":"F : Type u → Type v\ninst✝¹ : Applicative F\nG : Type u → Type w\ninst✝ : Applicative G\nη η' : ApplicativeTransformation F G\nh : ∀ (α : Type u) (x : F α), Eq ((fun {α} => η.app α) x) ((fun {α} => η'.app α) x)\n⊢ Eq η η'","decl":"@[ext]\ntheorem ext ⦃η η' : ApplicativeTransformation F G⦄ (h : ∀ (α : Type u) (x : F α), η x = η' x) :\n    η = η' := by\n  apply coe_inj\n  ext1 α\n  exact funext (h α)\n\n"}
{"name":"ApplicativeTransformation.preserves_pure","module":"Mathlib.Control.Traversable.Basic","initialProofState":"F : Type u → Type v\ninst✝¹ : Applicative F\nG : Type u → Type w\ninst✝ : Applicative G\nη : ApplicativeTransformation F G\nα : Type u\nx : α\n⊢ Eq ((fun {α} => η.app α) (Pure.pure x)) (Pure.pure x)","decl":"@[functor_norm]\ntheorem preserves_pure {α} : ∀ x : α, η (pure x) = pure x :=\n  η.preserves_pure'\n\n"}
{"name":"ApplicativeTransformation.preserves_seq","module":"Mathlib.Control.Traversable.Basic","initialProofState":"F : Type u → Type v\ninst✝¹ : Applicative F\nG : Type u → Type w\ninst✝ : Applicative G\nη : ApplicativeTransformation F G\nα β : Type u\nx : F (α → β)\ny : F α\n⊢ Eq ((fun {α} => η.app α) (Seq.seq x fun x => y)) (Seq.seq ((fun {α} => η.app α) x) fun x => (fun {α} => η.app α) y)","decl":"@[functor_norm]\ntheorem preserves_seq {α β : Type u} : ∀ (x : F (α → β)) (y : F α), η (x <*> y) = η x <*> η y :=\n  η.preserves_seq'\n\n"}
{"name":"ApplicativeTransformation.preserves_map","module":"Mathlib.Control.Traversable.Basic","initialProofState":"F : Type u → Type v\ninst✝³ : Applicative F\nG : Type u → Type w\ninst✝² : Applicative G\nη : ApplicativeTransformation F G\ninst✝¹ : LawfulApplicative F\ninst✝ : LawfulApplicative G\nα β : Type u\nx : α → β\ny : F α\n⊢ Eq ((fun {α} => η.app α) (Functor.map x y)) (Functor.map x ((fun {α} => η.app α) y))","decl":"@[functor_norm]\ntheorem preserves_map {α β} (x : α → β) (y : F α) : η (x <$> y) = x <$> η y := by\n  rw [← pure_seq, η.preserves_seq, preserves_pure, pure_seq]\n\n"}
{"name":"ApplicativeTransformation.preserves_map'","module":"Mathlib.Control.Traversable.Basic","initialProofState":"F : Type u → Type v\ninst✝³ : Applicative F\nG : Type u → Type w\ninst✝² : Applicative G\nη : ApplicativeTransformation F G\ninst✝¹ : LawfulApplicative F\ninst✝ : LawfulApplicative G\nα β : Type u\nx : α → β\n⊢ Eq (Function.comp (fun {α} => η.app α) (Functor.map x)) (Function.comp (Functor.map x) fun {α} => η.app α)","decl":"theorem preserves_map' {α β} (x : α → β) : @η _ ∘ Functor.map x = Functor.map x ∘ @η _ := by\n  ext y\n  exact preserves_map η x y\n\n"}
{"name":"ApplicativeTransformation.comp_apply","module":"Mathlib.Control.Traversable.Basic","initialProofState":"F : Type u → Type v\ninst✝² : Applicative F\nG : Type u → Type w\ninst✝¹ : Applicative G\nH : Type u → Type s\ninst✝ : Applicative H\nη' : ApplicativeTransformation G H\nη : ApplicativeTransformation F G\nα : Type u\nx : F α\n⊢ Eq ((fun {α} => (η'.comp η).app α) x) ((fun {α} => η'.app α) ((fun {α} => η.app α) x))","decl":"@[simp]\ntheorem comp_apply (η' : ApplicativeTransformation G H) (η : ApplicativeTransformation F G)\n    {α : Type u} (x : F α) : η'.comp η x = η' (η x) :=\n  rfl\n\n-- Porting note: in mathlib3 we also had the assumption `[LawfulApplicative I]` because\n-- this was assumed\n"}
{"name":"ApplicativeTransformation.comp_assoc","module":"Mathlib.Control.Traversable.Basic","initialProofState":"F : Type u → Type v\ninst✝³ : Applicative F\nG : Type u → Type w\ninst✝² : Applicative G\nH : Type u → Type s\ninst✝¹ : Applicative H\nI : Type u → Type t\ninst✝ : Applicative I\nη'' : ApplicativeTransformation H I\nη' : ApplicativeTransformation G H\nη : ApplicativeTransformation F G\n⊢ Eq ((η''.comp η').comp η) (η''.comp (η'.comp η))","decl":"theorem comp_assoc {I : Type u → Type t} [Applicative I]\n    (η'' : ApplicativeTransformation H I) (η' : ApplicativeTransformation G H)\n    (η : ApplicativeTransformation F G) : (η''.comp η').comp η = η''.comp (η'.comp η) :=\n  rfl\n\n"}
{"name":"ApplicativeTransformation.comp_id","module":"Mathlib.Control.Traversable.Basic","initialProofState":"F : Type u → Type v\ninst✝¹ : Applicative F\nG : Type u → Type w\ninst✝ : Applicative G\nη : ApplicativeTransformation F G\n⊢ Eq (η.comp ApplicativeTransformation.idTransformation) η","decl":"@[simp]\ntheorem comp_id (η : ApplicativeTransformation F G) : η.comp idTransformation = η :=\n  ext fun _ _ => rfl\n\n"}
{"name":"ApplicativeTransformation.id_comp","module":"Mathlib.Control.Traversable.Basic","initialProofState":"F : Type u → Type v\ninst✝¹ : Applicative F\nG : Type u → Type w\ninst✝ : Applicative G\nη : ApplicativeTransformation F G\n⊢ Eq (ApplicativeTransformation.idTransformation.comp η) η","decl":"@[simp]\ntheorem id_comp (η : ApplicativeTransformation F G) : idTransformation.comp η = η :=\n  ext fun _ _ => rfl\n\n"}
{"name":"LawfulTraversable.traverse_eq_map_id","module":"Mathlib.Control.Traversable.Basic","initialProofState":"t : Type u → Type u\ninst✝ : Traversable t\nself : LawfulTraversable t\nα β : Type u\nf : α → β\nx : t α\n⊢ Eq (Traversable.traverse (Function.comp Pure.pure f) x) (id.mk (Functor.map f x))","decl":"/-- A traversable functor is lawful if its `traverse` satisfies a\nnumber of additional properties.  It must send `pure : α → Id α` to `pure`,\nsend the composition of applicative functors to the composition of the\n`traverse` of each, send each function `f` to `fun x ↦ f <$> x`, and\nsatisfy a naturality condition with respect to applicative\ntransformations. -/\nclass LawfulTraversable (t : Type u → Type u) [Traversable t] extends LawfulFunctor t :\n    Prop where\n  /-- `traverse` plays well with `pure` of the identity monad -/\n  id_traverse : ∀ {α} (x : t α), traverse (pure : α → Id α) x = x\n  /-- `traverse` plays well with composition of applicative functors. -/\n  comp_traverse :\n    ∀ {F G} [Applicative F] [Applicative G] [LawfulApplicative F] [LawfulApplicative G] {α β γ}\n      (f : β → F γ) (g : α → G β) (x : t α),\n      traverse (Functor.Comp.mk ∘ map f ∘ g) x = Comp.mk (map (traverse f) (traverse g x))\n  /-- An axiom for `traverse` involving `pure : β → Id β`. -/\n  traverse_eq_map_id : ∀ {α β} (f : α → β) (x : t α),\n    traverse ((pure : β → Id β) ∘ f) x = id.mk (f <$> x)\n  /-- The naturality axiom explaining how lawful traversable functors should play with\n  lawful applicative functors. -/\n  naturality :\n    ∀ {F G} [Applicative F] [Applicative G] [LawfulApplicative F] [LawfulApplicative G]\n      (η : ApplicativeTransformation F G) {α β} (f : α → F β) (x : t α),\n      η (traverse f x) = traverse (@η _ ∘ f) x\n\n"}
{"name":"LawfulTraversable.comp_traverse","module":"Mathlib.Control.Traversable.Basic","initialProofState":"t : Type u → Type u\ninst✝⁴ : Traversable t\nself : LawfulTraversable t\nF G : Type u → Type u\ninst✝³ : Applicative F\ninst✝² : Applicative G\ninst✝¹ : LawfulApplicative F\ninst✝ : LawfulApplicative G\nα β γ : Type u\nf : β → F γ\ng : α → G β\nx : t α\n⊢ Eq (Traversable.traverse (Function.comp Functor.Comp.mk (Function.comp (Functor.map f) g)) x) (Functor.Comp.mk (Functor.map (Traversable.traverse f) (Traversable.traverse g x)))","decl":"/-- A traversable functor is lawful if its `traverse` satisfies a\nnumber of additional properties.  It must send `pure : α → Id α` to `pure`,\nsend the composition of applicative functors to the composition of the\n`traverse` of each, send each function `f` to `fun x ↦ f <$> x`, and\nsatisfy a naturality condition with respect to applicative\ntransformations. -/\nclass LawfulTraversable (t : Type u → Type u) [Traversable t] extends LawfulFunctor t :\n    Prop where\n  /-- `traverse` plays well with `pure` of the identity monad -/\n  id_traverse : ∀ {α} (x : t α), traverse (pure : α → Id α) x = x\n  /-- `traverse` plays well with composition of applicative functors. -/\n  comp_traverse :\n    ∀ {F G} [Applicative F] [Applicative G] [LawfulApplicative F] [LawfulApplicative G] {α β γ}\n      (f : β → F γ) (g : α → G β) (x : t α),\n      traverse (Functor.Comp.mk ∘ map f ∘ g) x = Comp.mk (map (traverse f) (traverse g x))\n  /-- An axiom for `traverse` involving `pure : β → Id β`. -/\n  traverse_eq_map_id : ∀ {α β} (f : α → β) (x : t α),\n    traverse ((pure : β → Id β) ∘ f) x = id.mk (f <$> x)\n  /-- The naturality axiom explaining how lawful traversable functors should play with\n  lawful applicative functors. -/\n  naturality :\n    ∀ {F G} [Applicative F] [Applicative G] [LawfulApplicative F] [LawfulApplicative G]\n      (η : ApplicativeTransformation F G) {α β} (f : α → F β) (x : t α),\n      η (traverse f x) = traverse (@η _ ∘ f) x\n\n"}
{"name":"LawfulTraversable.id_traverse","module":"Mathlib.Control.Traversable.Basic","initialProofState":"t : Type u → Type u\ninst✝ : Traversable t\nself : LawfulTraversable t\nα : Type u\nx : t α\n⊢ Eq (Traversable.traverse Pure.pure x) x","decl":"/-- A traversable functor is lawful if its `traverse` satisfies a\nnumber of additional properties.  It must send `pure : α → Id α` to `pure`,\nsend the composition of applicative functors to the composition of the\n`traverse` of each, send each function `f` to `fun x ↦ f <$> x`, and\nsatisfy a naturality condition with respect to applicative\ntransformations. -/\nclass LawfulTraversable (t : Type u → Type u) [Traversable t] extends LawfulFunctor t :\n    Prop where\n  /-- `traverse` plays well with `pure` of the identity monad -/\n  id_traverse : ∀ {α} (x : t α), traverse (pure : α → Id α) x = x\n  /-- `traverse` plays well with composition of applicative functors. -/\n  comp_traverse :\n    ∀ {F G} [Applicative F] [Applicative G] [LawfulApplicative F] [LawfulApplicative G] {α β γ}\n      (f : β → F γ) (g : α → G β) (x : t α),\n      traverse (Functor.Comp.mk ∘ map f ∘ g) x = Comp.mk (map (traverse f) (traverse g x))\n  /-- An axiom for `traverse` involving `pure : β → Id β`. -/\n  traverse_eq_map_id : ∀ {α β} (f : α → β) (x : t α),\n    traverse ((pure : β → Id β) ∘ f) x = id.mk (f <$> x)\n  /-- The naturality axiom explaining how lawful traversable functors should play with\n  lawful applicative functors. -/\n  naturality :\n    ∀ {F G} [Applicative F] [Applicative G] [LawfulApplicative F] [LawfulApplicative G]\n      (η : ApplicativeTransformation F G) {α β} (f : α → F β) (x : t α),\n      η (traverse f x) = traverse (@η _ ∘ f) x\n\n"}
{"name":"LawfulTraversable.toLawfulFunctor","module":"Mathlib.Control.Traversable.Basic","initialProofState":"t : Type u → Type u\ninst✝ : Traversable t\nself : LawfulTraversable t\n⊢ LawfulFunctor t","decl":"/-- A traversable functor is lawful if its `traverse` satisfies a\nnumber of additional properties.  It must send `pure : α → Id α` to `pure`,\nsend the composition of applicative functors to the composition of the\n`traverse` of each, send each function `f` to `fun x ↦ f <$> x`, and\nsatisfy a naturality condition with respect to applicative\ntransformations. -/\nclass LawfulTraversable (t : Type u → Type u) [Traversable t] extends LawfulFunctor t :\n    Prop where\n  /-- `traverse` plays well with `pure` of the identity monad -/\n  id_traverse : ∀ {α} (x : t α), traverse (pure : α → Id α) x = x\n  /-- `traverse` plays well with composition of applicative functors. -/\n  comp_traverse :\n    ∀ {F G} [Applicative F] [Applicative G] [LawfulApplicative F] [LawfulApplicative G] {α β γ}\n      (f : β → F γ) (g : α → G β) (x : t α),\n      traverse (Functor.Comp.mk ∘ map f ∘ g) x = Comp.mk (map (traverse f) (traverse g x))\n  /-- An axiom for `traverse` involving `pure : β → Id β`. -/\n  traverse_eq_map_id : ∀ {α β} (f : α → β) (x : t α),\n    traverse ((pure : β → Id β) ∘ f) x = id.mk (f <$> x)\n  /-- The naturality axiom explaining how lawful traversable functors should play with\n  lawful applicative functors. -/\n  naturality :\n    ∀ {F G} [Applicative F] [Applicative G] [LawfulApplicative F] [LawfulApplicative G]\n      (η : ApplicativeTransformation F G) {α β} (f : α → F β) (x : t α),\n      η (traverse f x) = traverse (@η _ ∘ f) x\n\n"}
{"name":"LawfulTraversable.naturality","module":"Mathlib.Control.Traversable.Basic","initialProofState":"t : Type u → Type u\ninst✝⁴ : Traversable t\nself : LawfulTraversable t\nF G : Type u → Type u\ninst✝³ : Applicative F\ninst✝² : Applicative G\ninst✝¹ : LawfulApplicative F\ninst✝ : LawfulApplicative G\nη : ApplicativeTransformation F G\nα β : Type u\nf : α → F β\nx : t α\n⊢ Eq ((fun {α} => η.app α) (Traversable.traverse f x)) (Traversable.traverse (Function.comp (fun {α} => η.app α) f) x)","decl":"/-- A traversable functor is lawful if its `traverse` satisfies a\nnumber of additional properties.  It must send `pure : α → Id α` to `pure`,\nsend the composition of applicative functors to the composition of the\n`traverse` of each, send each function `f` to `fun x ↦ f <$> x`, and\nsatisfy a naturality condition with respect to applicative\ntransformations. -/\nclass LawfulTraversable (t : Type u → Type u) [Traversable t] extends LawfulFunctor t :\n    Prop where\n  /-- `traverse` plays well with `pure` of the identity monad -/\n  id_traverse : ∀ {α} (x : t α), traverse (pure : α → Id α) x = x\n  /-- `traverse` plays well with composition of applicative functors. -/\n  comp_traverse :\n    ∀ {F G} [Applicative F] [Applicative G] [LawfulApplicative F] [LawfulApplicative G] {α β γ}\n      (f : β → F γ) (g : α → G β) (x : t α),\n      traverse (Functor.Comp.mk ∘ map f ∘ g) x = Comp.mk (map (traverse f) (traverse g x))\n  /-- An axiom for `traverse` involving `pure : β → Id β`. -/\n  traverse_eq_map_id : ∀ {α β} (f : α → β) (x : t α),\n    traverse ((pure : β → Id β) ∘ f) x = id.mk (f <$> x)\n  /-- The naturality axiom explaining how lawful traversable functors should play with\n  lawful applicative functors. -/\n  naturality :\n    ∀ {F G} [Applicative F] [Applicative G] [LawfulApplicative F] [LawfulApplicative G]\n      (η : ApplicativeTransformation F G) {α β} (f : α → F β) (x : t α),\n      η (traverse f x) = traverse (@η _ ∘ f) x\n\n"}
{"name":"instLawfulTraversableId","module":"Mathlib.Control.Traversable.Basic","initialProofState":"⊢ LawfulTraversable Id","decl":"instance : LawfulTraversable Id where\n  id_traverse _ := rfl\n  comp_traverse _ _ _ := rfl\n  traverse_eq_map_id _ _ := rfl\n  naturality _ _ _ _ _ := rfl\n\n"}
