{"name":"Matrix.charpoly.univ_map_eval₂Hom","module":"Mathlib.LinearAlgebra.Matrix.Charpoly.Univ","initialProofState":"R : Type u_1\nS : Type u_2\nn : Type u_3\ninst✝³ : CommRing R\ninst✝² : CommRing S\ninst✝¹ : Fintype n\ninst✝ : DecidableEq n\nf : RingHom R S\nM : Prod n n → S\n⊢ Eq (Polynomial.map (MvPolynomial.eval₂Hom f M) (Matrix.charpoly.univ R n)) (Matrix.of (Function.curry M)).charpoly","decl":"open MvPolynomial RingHomClass in\n@[simp]\nlemma univ_map_eval₂Hom (M : n × n → S) :\n    (univ R n).map (eval₂Hom f M) = charpoly (Matrix.of M.curry) := by\n  rw [univ, ← charpoly_map, coe_eval₂Hom, ← mvPolynomialX_map_eval₂ f (Matrix.of M.curry)]\n  simp only [of_apply, Function.curry_apply, Prod.mk.eta]\n\n"}
{"name":"Matrix.charpoly.univ_map_map","module":"Mathlib.LinearAlgebra.Matrix.Charpoly.Univ","initialProofState":"R : Type u_1\nS : Type u_2\nn : Type u_3\ninst✝³ : CommRing R\ninst✝² : CommRing S\ninst✝¹ : Fintype n\ninst✝ : DecidableEq n\nf : RingHom R S\n⊢ Eq (Polynomial.map (MvPolynomial.map f) (Matrix.charpoly.univ R n)) (Matrix.charpoly.univ S n)","decl":"lemma univ_map_map :\n    (univ R n).map (MvPolynomial.map f) = univ S n := by\n  rw [MvPolynomial.map, univ_map_eval₂Hom]; rfl\n\n"}
{"name":"Matrix.charpoly.univ_coeff_eval₂Hom","module":"Mathlib.LinearAlgebra.Matrix.Charpoly.Univ","initialProofState":"R : Type u_1\nS : Type u_2\nn : Type u_3\ninst✝³ : CommRing R\ninst✝² : CommRing S\ninst✝¹ : Fintype n\ninst✝ : DecidableEq n\nf : RingHom R S\nM : Prod n n → S\ni : Nat\n⊢ Eq ((MvPolynomial.eval₂Hom f M) ((Matrix.charpoly.univ R n).coeff i)) ((Matrix.of (Function.curry M)).charpoly.coeff i)","decl":"@[simp]\nlemma univ_coeff_eval₂Hom (M : n × n → S) (i : ℕ) :\n    MvPolynomial.eval₂Hom f M ((univ R n).coeff i) =\n      (charpoly (Matrix.of M.curry)).coeff i := by\n  rw [← univ_map_eval₂Hom n f M, Polynomial.coeff_map]\n\n"}
{"name":"Matrix.charpoly.univ_monic","module":"Mathlib.LinearAlgebra.Matrix.Charpoly.Univ","initialProofState":"R : Type u_1\nn : Type u_3\ninst✝² : CommRing R\ninst✝¹ : Fintype n\ninst✝ : DecidableEq n\n⊢ (Matrix.charpoly.univ R n).Monic","decl":"lemma univ_monic : (univ R n).Monic := charpoly_monic (mvPolynomialX n n R)\n\n"}
{"name":"Matrix.charpoly.univ_natDegree","module":"Mathlib.LinearAlgebra.Matrix.Charpoly.Univ","initialProofState":"R : Type u_1\nn : Type u_3\ninst✝³ : CommRing R\ninst✝² : Fintype n\ninst✝¹ : DecidableEq n\ninst✝ : Nontrivial R\n⊢ Eq (Matrix.charpoly.univ R n).natDegree (Fintype.card n)","decl":"lemma univ_natDegree [Nontrivial R] : (univ R n).natDegree = Fintype.card n :=\n  charpoly_natDegree_eq_dim (mvPolynomialX n n R)\n\n"}
{"name":"Matrix.charpoly.univ_coeff_card","module":"Mathlib.LinearAlgebra.Matrix.Charpoly.Univ","initialProofState":"R : Type u_1\nn : Type u_3\ninst✝² : CommRing R\ninst✝¹ : Fintype n\ninst✝ : DecidableEq n\n⊢ Eq ((Matrix.charpoly.univ R n).coeff (Fintype.card n)) 1","decl":"@[simp]\nlemma univ_coeff_card : (univ R n).coeff (Fintype.card n) = 1 := by\n  suffices Polynomial.coeff (univ ℤ n) (Fintype.card n) = 1 by\n    rw [← univ_map_map n (Int.castRingHom R), Polynomial.coeff_map, this, _root_.map_one]\n  rw [← univ_natDegree ℤ n]\n  exact (univ_monic ℤ n).leadingCoeff\n\n"}
{"name":"Matrix.charpoly.optionEquivLeft_symm_univ_isHomogeneous","module":"Mathlib.LinearAlgebra.Matrix.Charpoly.Univ","initialProofState":"R : Type u_1\nn : Type u_3\ninst✝² : CommRing R\ninst✝¹ : Fintype n\ninst✝ : DecidableEq n\n⊢ ((MvPolynomial.optionEquivLeft R (Prod n n)).symm (Matrix.charpoly.univ R n)).IsHomogeneous (Fintype.card n)","decl":"open MvPolynomial in\nlemma optionEquivLeft_symm_univ_isHomogeneous :\n    ((optionEquivLeft R (n × n)).symm (univ R n)).IsHomogeneous (Fintype.card n) := by\n  have aux : Fintype.card n = 0 + ∑ i : n, 1 := by\n    simp only [zero_add, Finset.sum_const, smul_eq_mul, mul_one, Fintype.card]\n  simp only [aux, univ, charpoly, charmatrix, scalar_apply, RingHom.mapMatrix_apply, det_apply',\n    sub_apply, map_apply, of_apply, map_sum, _root_.map_mul, map_intCast, map_prod, map_sub,\n    optionEquivLeft_symm_apply, Polynomial.aevalTower_C, rename_X, diagonal, mvPolynomialX]\n  apply IsHomogeneous.sum\n  rintro i -\n  apply IsHomogeneous.mul\n  · apply isHomogeneous_C\n  · apply IsHomogeneous.prod\n    rintro j -\n    by_cases h : i j = j\n    · simp only [h, ↓reduceIte, Polynomial.aevalTower_X, IsHomogeneous.sub, isHomogeneous_X]\n    · simp only [h, ↓reduceIte, map_zero, zero_sub, (isHomogeneous_X _ _).neg]\n\n"}
{"name":"Matrix.charpoly.univ_coeff_isHomogeneous","module":"Mathlib.LinearAlgebra.Matrix.Charpoly.Univ","initialProofState":"R : Type u_1\nn : Type u_3\ninst✝² : CommRing R\ninst✝¹ : Fintype n\ninst✝ : DecidableEq n\ni j : Nat\nh : Eq (HAdd.hAdd i j) (Fintype.card n)\n⊢ ((Matrix.charpoly.univ R n).coeff i).IsHomogeneous j","decl":"lemma univ_coeff_isHomogeneous (i j : ℕ) (h : i + j = Fintype.card n) :\n    ((univ R n).coeff i).IsHomogeneous j :=\n  (optionEquivLeft_symm_univ_isHomogeneous R n).coeff_isHomogeneous_of_optionEquivLeft_symm _ _ h\n\n"}
