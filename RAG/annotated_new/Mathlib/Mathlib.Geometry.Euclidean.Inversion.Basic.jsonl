{"name":"EuclideanGeometry.inversion_def","module":"Mathlib.Geometry.Euclidean.Inversion.Basic","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\n⊢ Eq EuclideanGeometry.inversion fun c R x => HVAdd.hVAdd (HSMul.hSMul (HPow.hPow (HDiv.hDiv R (Dist.dist x c)) 2) (VSub.vsub x c)) c","decl":"theorem inversion_def :\n    inversion = fun (c : P) (R : ℝ) (x : P) => (R / dist x c) ^ 2 • (x -ᵥ c) +ᵥ c :=\n  rfl\n\n"}
{"name":"EuclideanGeometry.inversion_eq_lineMap","module":"Mathlib.Geometry.Euclidean.Inversion.Basic","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\nc : P\nR : Real\nx : P\n⊢ Eq (EuclideanGeometry.inversion c R x) ((AffineMap.lineMap c x) (HPow.hPow (HDiv.hDiv R (Dist.dist x c)) 2))","decl":"theorem inversion_eq_lineMap (c : P) (R : ℝ) (x : P) :\n    inversion c R x = lineMap c x ((R / dist x c) ^ 2) :=\n  rfl\n\n"}
{"name":"EuclideanGeometry.inversion_vsub_center","module":"Mathlib.Geometry.Euclidean.Inversion.Basic","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\nc : P\nR : Real\nx : P\n⊢ Eq (VSub.vsub (EuclideanGeometry.inversion c R x) c) (HSMul.hSMul (HPow.hPow (HDiv.hDiv R (Dist.dist x c)) 2) (VSub.vsub x c))","decl":"theorem inversion_vsub_center (c : P) (R : ℝ) (x : P) :\n    inversion c R x -ᵥ c = (R / dist x c) ^ 2 • (x -ᵥ c) :=\n  vadd_vsub _ _\n\n"}
{"name":"EuclideanGeometry.inversion_self","module":"Mathlib.Geometry.Euclidean.Inversion.Basic","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\nc : P\nR : Real\n⊢ Eq (EuclideanGeometry.inversion c R c) c","decl":"@[simp]\ntheorem inversion_self (c : P) (R : ℝ) : inversion c R c = c := by simp [inversion]\n\n"}
{"name":"EuclideanGeometry.inversion_zero_radius","module":"Mathlib.Geometry.Euclidean.Inversion.Basic","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\nc x : P\n⊢ Eq (EuclideanGeometry.inversion c 0 x) c","decl":"@[simp]\ntheorem inversion_zero_radius (c x : P) : inversion c 0 x = c := by simp [inversion]\n\n"}
{"name":"EuclideanGeometry.inversion_mul","module":"Mathlib.Geometry.Euclidean.Inversion.Basic","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\nc : P\na R : Real\nx : P\n⊢ Eq (EuclideanGeometry.inversion c (HMul.hMul a R) x) ((AffineMap.homothety c (HPow.hPow a 2)) (EuclideanGeometry.inversion c R x))","decl":"theorem inversion_mul (c : P) (a R : ℝ) (x : P) :\n    inversion c (a * R) x = homothety c (a ^ 2) (inversion c R x) := by\n  simp only [inversion_eq_lineMap, ← homothety_eq_lineMap, ← homothety_mul_apply, mul_div_assoc,\n    mul_pow]\n\n"}
{"name":"EuclideanGeometry.inversion_dist_center","module":"Mathlib.Geometry.Euclidean.Inversion.Basic","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\nc x : P\n⊢ Eq (EuclideanGeometry.inversion c (Dist.dist x c) x) x","decl":"@[simp]\ntheorem inversion_dist_center (c x : P) : inversion c (dist x c) x = x := by\n  rcases eq_or_ne x c with (rfl | hne)\n  · apply inversion_self\n  · rw [inversion, div_self, one_pow, one_smul, vsub_vadd]\n    rwa [dist_ne_zero]\n\n"}
{"name":"EuclideanGeometry.inversion_dist_center'","module":"Mathlib.Geometry.Euclidean.Inversion.Basic","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\nc x : P\n⊢ Eq (EuclideanGeometry.inversion c (Dist.dist c x) x) x","decl":"@[simp]\ntheorem inversion_dist_center' (c x : P) : inversion c (dist c x) x = x := by\n  rw [dist_comm, inversion_dist_center]\n\n"}
{"name":"EuclideanGeometry.inversion_of_mem_sphere","module":"Mathlib.Geometry.Euclidean.Inversion.Basic","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\nc x : P\nR : Real\nh : Membership.mem (Metric.sphere c R) x\n⊢ Eq (EuclideanGeometry.inversion c R x) x","decl":"theorem inversion_of_mem_sphere (h : x ∈ Metric.sphere c R) : inversion c R x = x :=\n  h.out ▸ inversion_dist_center c x\n\n"}
{"name":"EuclideanGeometry.dist_inversion_center","module":"Mathlib.Geometry.Euclidean.Inversion.Basic","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\nc x : P\nR : Real\n⊢ Eq (Dist.dist (EuclideanGeometry.inversion c R x) c) (HDiv.hDiv (HPow.hPow R 2) (Dist.dist x c))","decl":"/-- Distance from the image of a point under inversion to the center. This formula accidentally\nworks for `x = c`. -/\ntheorem dist_inversion_center (c x : P) (R : ℝ) : dist (inversion c R x) c = R ^ 2 / dist x c := by\n  rcases eq_or_ne x c with (rfl | hx)\n  · simp\n  have : dist x c ≠ 0 := dist_ne_zero.2 hx\n  -- was `field_simp [inversion, norm_smul, abs_div, ← dist_eq_norm_vsub, sq, mul_assoc]`,\n  -- but really slow. Replaced by `simp only ...` to speed up.\n  -- TODO(https://github.com/leanprover-community/mathlib4/issues/15486): reinstate `field_simp` once it is faster.\n  simp (disch := field_simp_discharge) only [inversion, sq, mul_div_assoc', div_mul_eq_mul_div,\n    div_div, dist_vadd_left, norm_smul, norm_div, norm_mul, Real.norm_eq_abs, abs_mul_abs_self,\n    abs_dist, ← dist_eq_norm_vsub, mul_assoc, eq_div_iff, div_eq_iff]\n\n"}
{"name":"EuclideanGeometry.dist_center_inversion","module":"Mathlib.Geometry.Euclidean.Inversion.Basic","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\nc x : P\nR : Real\n⊢ Eq (Dist.dist c (EuclideanGeometry.inversion c R x)) (HDiv.hDiv (HPow.hPow R 2) (Dist.dist c x))","decl":"/-- Distance from the center of an inversion to the image of a point under the inversion. This\nformula accidentally works for `x = c`. -/\ntheorem dist_center_inversion (c x : P) (R : ℝ) : dist c (inversion c R x) = R ^ 2 / dist c x := by\n  rw [dist_comm c, dist_comm c, dist_inversion_center]\n\n"}
{"name":"EuclideanGeometry.inversion_inversion","module":"Mathlib.Geometry.Euclidean.Inversion.Basic","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\nc : P\nR : Real\nhR : Ne R 0\nx : P\n⊢ Eq (EuclideanGeometry.inversion c R (EuclideanGeometry.inversion c R x)) x","decl":"@[simp]\ntheorem inversion_inversion (c : P) {R : ℝ} (hR : R ≠ 0) (x : P) :\n    inversion c R (inversion c R x) = x := by\n  rcases eq_or_ne x c with (rfl | hne)\n  · rw [inversion_self, inversion_self]\n  · rw [inversion, dist_inversion_center, inversion_vsub_center, smul_smul, ← mul_pow,\n      div_mul_div_comm, div_mul_cancel₀ _ (dist_ne_zero.2 hne), ← sq, div_self, one_pow, one_smul,\n      vsub_vadd]\n    exact pow_ne_zero _ hR\n\n"}
{"name":"EuclideanGeometry.inversion_involutive","module":"Mathlib.Geometry.Euclidean.Inversion.Basic","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\nc : P\nR : Real\nhR : Ne R 0\n⊢ Function.Involutive (EuclideanGeometry.inversion c R)","decl":"theorem inversion_involutive (c : P) {R : ℝ} (hR : R ≠ 0) : Involutive (inversion c R) :=\n  inversion_inversion c hR\n\n"}
{"name":"EuclideanGeometry.inversion_surjective","module":"Mathlib.Geometry.Euclidean.Inversion.Basic","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\nc : P\nR : Real\nhR : Ne R 0\n⊢ Function.Surjective (EuclideanGeometry.inversion c R)","decl":"theorem inversion_surjective (c : P) {R : ℝ} (hR : R ≠ 0) : Surjective (inversion c R) :=\n  (inversion_involutive c hR).surjective\n\n"}
{"name":"EuclideanGeometry.inversion_injective","module":"Mathlib.Geometry.Euclidean.Inversion.Basic","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\nc : P\nR : Real\nhR : Ne R 0\n⊢ Function.Injective (EuclideanGeometry.inversion c R)","decl":"theorem inversion_injective (c : P) {R : ℝ} (hR : R ≠ 0) : Injective (inversion c R) :=\n  (inversion_involutive c hR).injective\n\n"}
{"name":"EuclideanGeometry.inversion_bijective","module":"Mathlib.Geometry.Euclidean.Inversion.Basic","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\nc : P\nR : Real\nhR : Ne R 0\n⊢ Function.Bijective (EuclideanGeometry.inversion c R)","decl":"theorem inversion_bijective (c : P) {R : ℝ} (hR : R ≠ 0) : Bijective (inversion c R) :=\n  (inversion_involutive c hR).bijective\n\n"}
{"name":"EuclideanGeometry.inversion_eq_center","module":"Mathlib.Geometry.Euclidean.Inversion.Basic","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\nc x : P\nR : Real\nhR : Ne R 0\n⊢ Iff (Eq (EuclideanGeometry.inversion c R x) c) (Eq x c)","decl":"theorem inversion_eq_center (hR : R ≠ 0) : inversion c R x = c ↔ x = c :=\n  (inversion_injective c hR).eq_iff' <| inversion_self _ _\n\n"}
{"name":"EuclideanGeometry.inversion_eq_center'","module":"Mathlib.Geometry.Euclidean.Inversion.Basic","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\nc x : P\nR : Real\n⊢ Iff (Eq (EuclideanGeometry.inversion c R x) c) (Or (Eq x c) (Eq R 0))","decl":"@[simp]\ntheorem inversion_eq_center' : inversion c R x = c ↔ x = c ∨ R = 0 := by\n  by_cases hR : R = 0 <;> simp [inversion_eq_center, hR]\n\n"}
{"name":"EuclideanGeometry.center_eq_inversion","module":"Mathlib.Geometry.Euclidean.Inversion.Basic","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\nc x : P\nR : Real\nhR : Ne R 0\n⊢ Iff (Eq c (EuclideanGeometry.inversion c R x)) (Eq x c)","decl":"theorem center_eq_inversion (hR : R ≠ 0) : c = inversion c R x ↔ x = c :=\n  eq_comm.trans (inversion_eq_center hR)\n\n"}
{"name":"EuclideanGeometry.center_eq_inversion'","module":"Mathlib.Geometry.Euclidean.Inversion.Basic","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\nc x : P\nR : Real\n⊢ Iff (Eq c (EuclideanGeometry.inversion c R x)) (Or (Eq x c) (Eq R 0))","decl":"@[simp]\ntheorem center_eq_inversion' : c = inversion c R x ↔ x = c ∨ R = 0 :=\n  eq_comm.trans inversion_eq_center'\n\n"}
{"name":"EuclideanGeometry.dist_inversion_inversion","module":"Mathlib.Geometry.Euclidean.Inversion.Basic","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\nc x y : P\nhx : Ne x c\nhy : Ne y c\nR : Real\n⊢ Eq (Dist.dist (EuclideanGeometry.inversion c R x) (EuclideanGeometry.inversion c R y)) (HMul.hMul (HDiv.hDiv (HPow.hPow R 2) (HMul.hMul (Dist.dist x c) (Dist.dist y c))) (Dist.dist x y))","decl":"/-- Distance between the images of two points under an inversion. -/\ntheorem dist_inversion_inversion (hx : x ≠ c) (hy : y ≠ c) (R : ℝ) :\n    dist (inversion c R x) (inversion c R y) = R ^ 2 / (dist x c * dist y c) * dist x y := by\n  dsimp only [inversion]\n  simp_rw [dist_vadd_cancel_right, dist_eq_norm_vsub V _ c]\n  simpa only [dist_vsub_cancel_right] using\n    dist_div_norm_sq_smul (vsub_ne_zero.2 hx) (vsub_ne_zero.2 hy) R\n\n"}
{"name":"EuclideanGeometry.dist_inversion_mul_dist_center_eq","module":"Mathlib.Geometry.Euclidean.Inversion.Basic","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\nc x y : P\nR : Real\nhx : Ne x c\nhy : Ne y c\n⊢ Eq (HMul.hMul (Dist.dist (EuclideanGeometry.inversion c R x) y) (Dist.dist x c)) (HMul.hMul (Dist.dist x (EuclideanGeometry.inversion c R y)) (Dist.dist y c))","decl":"theorem dist_inversion_mul_dist_center_eq (hx : x ≠ c) (hy : y ≠ c) :\n    dist (inversion c R x) y * dist x c = dist x (inversion c R y) * dist y c := by\n  rcases eq_or_ne R 0 with rfl | hR; · simp [dist_comm, mul_comm]\n  have hy' : inversion c R y ≠ c := by simp [*]\n  conv in dist _ y => rw [← inversion_inversion c hR y]\n  rw [dist_inversion_inversion hx hy', dist_inversion_center]\n  have : dist x c ≠ 0 := dist_ne_zero.2 hx\n  -- used to be `field_simp`, but was really slow; replaced by `simp only ...` to speed up\n  -- TODO(https://github.com/leanprover-community/mathlib4/issues/15486): reinstate `field_simp` once it is faster.\n  simp (disch := field_simp_discharge) only [mul_div_assoc', div_div_eq_mul_div, div_mul_eq_mul_div,\n    div_eq_iff]\n  ring\n\n"}
{"name":"EuclideanGeometry.mul_dist_le_mul_dist_add_mul_dist","module":"Mathlib.Geometry.Euclidean.Inversion.Basic","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\na b c d : P\n⊢ LE.le (HMul.hMul (Dist.dist a c) (Dist.dist b d)) (HAdd.hAdd (HMul.hMul (Dist.dist a b) (Dist.dist c d)) (HMul.hMul (Dist.dist b c) (Dist.dist a d)))","decl":"include V in\n/-- **Ptolemy's inequality**: in a quadrangle `ABCD`, `|AC| * |BD| ≤ |AB| * |CD| + |BC| * |AD|`. If\n`ABCD` is a convex cyclic polygon, then this inequality becomes an equality, see\n`EuclideanGeometry.mul_dist_add_mul_dist_eq_mul_dist_of_cospherical`. -/\ntheorem mul_dist_le_mul_dist_add_mul_dist (a b c d : P) :\n    dist a c * dist b d ≤ dist a b * dist c d + dist b c * dist a d := by\n  -- If one of the points `b`, `c`, `d` is equal to `a`, then the inequality is trivial.\n  rcases eq_or_ne b a with (rfl | hb)\n  · rw [dist_self, zero_mul, zero_add]\n  rcases eq_or_ne c a with (rfl | hc)\n  · rw [dist_self, zero_mul]\n    apply_rules [add_nonneg, mul_nonneg, dist_nonneg]\n  rcases eq_or_ne d a with (rfl | hd)\n  · rw [dist_self, mul_zero, add_zero, dist_comm d, dist_comm d, mul_comm]\n  /- Otherwise, we apply the triangle inequality to `EuclideanGeometry.inversion a 1 b`,\n    `EuclideanGeometry.inversion a 1 c`, and `EuclideanGeometry.inversion a 1 d`. -/\n  have H := dist_triangle (inversion a 1 b) (inversion a 1 c) (inversion a 1 d)\n  rw [dist_inversion_inversion hb hd, dist_inversion_inversion hb hc,\n    dist_inversion_inversion hc hd, one_pow] at H\n  rw [← dist_pos] at hb hc hd\n  rw [← div_le_div_iff_of_pos_right (mul_pos hb (mul_pos hc hd))]\n  convert H using 1 <;> (field_simp [hb.ne', hc.ne', hd.ne', dist_comm a]; ring)\n\n"}
{"name":"Filter.Tendsto.inversion","module":"Mathlib.Geometry.Euclidean.Inversion.Basic","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\nα : Type u_3\nx c : P\nR : Real\nl : Filter α\nfc fx : α → P\nfR : α → Real\nhc : Filter.Tendsto fc l (nhds c)\nhR : Filter.Tendsto fR l (nhds R)\nhx : Filter.Tendsto fx l (nhds x)\nhne : Ne x c\n⊢ Filter.Tendsto (fun a => EuclideanGeometry.inversion (fc a) (fR a) (fx a)) l (nhds (EuclideanGeometry.inversion c R x))","decl":"protected theorem Filter.Tendsto.inversion {α : Type*} {x c : P} {R : ℝ} {l : Filter α}\n    {fc fx : α → P} {fR : α → ℝ} (hc : Tendsto fc l (𝓝 c)) (hR : Tendsto fR l (𝓝 R))\n    (hx : Tendsto fx l (𝓝 x)) (hne : x ≠ c) :\n    Tendsto (fun a ↦ inversion (fc a) (fR a) (fx a)) l (𝓝 (inversion c R x)) :=\n  (((hR.div (hx.dist hc) <| dist_ne_zero.2 hne).pow 2).smul (hx.vsub hc)).vadd hc\n\n"}
{"name":"ContinuousWithinAt.inversion","module":"Mathlib.Geometry.Euclidean.Inversion.Basic","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝⁴ : NormedAddCommGroup V\ninst✝³ : InnerProductSpace Real V\ninst✝² : MetricSpace P\ninst✝¹ : NormedAddTorsor V P\nX : Type u_3\ninst✝ : TopologicalSpace X\nc x : X → P\nR : X → Real\na₀ : X\ns : Set X\nhc : ContinuousWithinAt c s a₀\nhR : ContinuousWithinAt R s a₀\nhx : ContinuousWithinAt x s a₀\nhne : Ne (x a₀) (c a₀)\n⊢ ContinuousWithinAt (fun a => EuclideanGeometry.inversion (c a) (R a) (x a)) s a₀","decl":"protected nonrec theorem ContinuousWithinAt.inversion (hc : ContinuousWithinAt c s a₀)\n    (hR : ContinuousWithinAt R s a₀) (hx : ContinuousWithinAt x s a₀) (hne : x a₀ ≠ c a₀) :\n    ContinuousWithinAt (fun a ↦ inversion (c a) (R a) (x a)) s a₀ :=\n  hc.inversion hR hx hne\n\n"}
{"name":"ContinuousAt.inversion","module":"Mathlib.Geometry.Euclidean.Inversion.Basic","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝⁴ : NormedAddCommGroup V\ninst✝³ : InnerProductSpace Real V\ninst✝² : MetricSpace P\ninst✝¹ : NormedAddTorsor V P\nX : Type u_3\ninst✝ : TopologicalSpace X\nc x : X → P\nR : X → Real\na₀ : X\nhc : ContinuousAt c a₀\nhR : ContinuousAt R a₀\nhx : ContinuousAt x a₀\nhne : Ne (x a₀) (c a₀)\n⊢ ContinuousAt (fun a => EuclideanGeometry.inversion (c a) (R a) (x a)) a₀","decl":"protected nonrec theorem ContinuousAt.inversion (hc : ContinuousAt c a₀) (hR : ContinuousAt R a₀)\n    (hx : ContinuousAt x a₀) (hne : x a₀ ≠ c a₀) :\n    ContinuousAt (fun a ↦ inversion (c a) (R a) (x a)) a₀ :=\n  hc.inversion hR hx hne\n\n"}
{"name":"ContinuousOn.inversion","module":"Mathlib.Geometry.Euclidean.Inversion.Basic","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝⁴ : NormedAddCommGroup V\ninst✝³ : InnerProductSpace Real V\ninst✝² : MetricSpace P\ninst✝¹ : NormedAddTorsor V P\nX : Type u_3\ninst✝ : TopologicalSpace X\nc x : X → P\nR : X → Real\ns : Set X\nhc : ContinuousOn c s\nhR : ContinuousOn R s\nhx : ContinuousOn x s\nhne : ∀ (a : X), Membership.mem s a → Ne (x a) (c a)\n⊢ ContinuousOn (fun a => EuclideanGeometry.inversion (c a) (R a) (x a)) s","decl":"protected theorem ContinuousOn.inversion (hc : ContinuousOn c s) (hR : ContinuousOn R s)\n    (hx : ContinuousOn x s) (hne : ∀ a ∈ s, x a ≠ c a) :\n    ContinuousOn (fun a ↦ inversion (c a) (R a) (x a)) s := fun a ha ↦\n  (hc a ha).inversion (hR a ha) (hx a ha) (hne a ha)\n\n"}
{"name":"Continuous.inversion","module":"Mathlib.Geometry.Euclidean.Inversion.Basic","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝⁴ : NormedAddCommGroup V\ninst✝³ : InnerProductSpace Real V\ninst✝² : MetricSpace P\ninst✝¹ : NormedAddTorsor V P\nX : Type u_3\ninst✝ : TopologicalSpace X\nc x : X → P\nR : X → Real\nhc : Continuous c\nhR : Continuous R\nhx : Continuous x\nhne : ∀ (a : X), Ne (x a) (c a)\n⊢ Continuous fun a => EuclideanGeometry.inversion (c a) (R a) (x a)","decl":"protected theorem Continuous.inversion (hc : Continuous c) (hR : Continuous R) (hx : Continuous x)\n    (hne : ∀ a, x a ≠ c a) : Continuous (fun a ↦ inversion (c a) (R a) (x a)) :=\n  continuous_iff_continuousAt.2 fun _ ↦\n    hc.continuousAt.inversion hR.continuousAt hx.continuousAt (hne _)\n"}
