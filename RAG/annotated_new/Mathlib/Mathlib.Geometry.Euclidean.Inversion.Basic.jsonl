{"name":"EuclideanGeometry.inversion_def","module":"Mathlib.Geometry.Euclidean.Inversion.Basic","initialProofState":"V : Type u_1\nP : Type u_2\ninstâœÂ³ : NormedAddCommGroup V\ninstâœÂ² : InnerProductSpace Real V\ninstâœÂ¹ : MetricSpace P\ninstâœ : NormedAddTorsor V P\nâŠ¢ Eq EuclideanGeometry.inversion fun c R x => HVAdd.hVAdd (HSMul.hSMul (HPow.hPow (HDiv.hDiv R (Dist.dist x c)) 2) (VSub.vsub x c)) c","decl":"theorem inversion_def :\n    inversion = fun (c : P) (R : â„) (x : P) => (R / dist x c) ^ 2 â€¢ (x -áµ¥ c) +áµ¥ c :=\n  rfl\n\n"}
{"name":"EuclideanGeometry.inversion_eq_lineMap","module":"Mathlib.Geometry.Euclidean.Inversion.Basic","initialProofState":"V : Type u_1\nP : Type u_2\ninstâœÂ³ : NormedAddCommGroup V\ninstâœÂ² : InnerProductSpace Real V\ninstâœÂ¹ : MetricSpace P\ninstâœ : NormedAddTorsor V P\nc : P\nR : Real\nx : P\nâŠ¢ Eq (EuclideanGeometry.inversion c R x) ((AffineMap.lineMap c x) (HPow.hPow (HDiv.hDiv R (Dist.dist x c)) 2))","decl":"theorem inversion_eq_lineMap (c : P) (R : â„) (x : P) :\n    inversion c R x = lineMap c x ((R / dist x c) ^ 2) :=\n  rfl\n\n"}
{"name":"EuclideanGeometry.inversion_vsub_center","module":"Mathlib.Geometry.Euclidean.Inversion.Basic","initialProofState":"V : Type u_1\nP : Type u_2\ninstâœÂ³ : NormedAddCommGroup V\ninstâœÂ² : InnerProductSpace Real V\ninstâœÂ¹ : MetricSpace P\ninstâœ : NormedAddTorsor V P\nc : P\nR : Real\nx : P\nâŠ¢ Eq (VSub.vsub (EuclideanGeometry.inversion c R x) c) (HSMul.hSMul (HPow.hPow (HDiv.hDiv R (Dist.dist x c)) 2) (VSub.vsub x c))","decl":"theorem inversion_vsub_center (c : P) (R : â„) (x : P) :\n    inversion c R x -áµ¥ c = (R / dist x c) ^ 2 â€¢ (x -áµ¥ c) :=\n  vadd_vsub _ _\n\n"}
{"name":"EuclideanGeometry.inversion_self","module":"Mathlib.Geometry.Euclidean.Inversion.Basic","initialProofState":"V : Type u_1\nP : Type u_2\ninstâœÂ³ : NormedAddCommGroup V\ninstâœÂ² : InnerProductSpace Real V\ninstâœÂ¹ : MetricSpace P\ninstâœ : NormedAddTorsor V P\nc : P\nR : Real\nâŠ¢ Eq (EuclideanGeometry.inversion c R c) c","decl":"@[simp]\ntheorem inversion_self (c : P) (R : â„) : inversion c R c = c := by simp [inversion]\n\n"}
{"name":"EuclideanGeometry.inversion_zero_radius","module":"Mathlib.Geometry.Euclidean.Inversion.Basic","initialProofState":"V : Type u_1\nP : Type u_2\ninstâœÂ³ : NormedAddCommGroup V\ninstâœÂ² : InnerProductSpace Real V\ninstâœÂ¹ : MetricSpace P\ninstâœ : NormedAddTorsor V P\nc x : P\nâŠ¢ Eq (EuclideanGeometry.inversion c 0 x) c","decl":"@[simp]\ntheorem inversion_zero_radius (c x : P) : inversion c 0 x = c := by simp [inversion]\n\n"}
{"name":"EuclideanGeometry.inversion_mul","module":"Mathlib.Geometry.Euclidean.Inversion.Basic","initialProofState":"V : Type u_1\nP : Type u_2\ninstâœÂ³ : NormedAddCommGroup V\ninstâœÂ² : InnerProductSpace Real V\ninstâœÂ¹ : MetricSpace P\ninstâœ : NormedAddTorsor V P\nc : P\na R : Real\nx : P\nâŠ¢ Eq (EuclideanGeometry.inversion c (HMul.hMul a R) x) ((AffineMap.homothety c (HPow.hPow a 2)) (EuclideanGeometry.inversion c R x))","decl":"theorem inversion_mul (c : P) (a R : â„) (x : P) :\n    inversion c (a * R) x = homothety c (a ^ 2) (inversion c R x) := by\n  simp only [inversion_eq_lineMap, â† homothety_eq_lineMap, â† homothety_mul_apply, mul_div_assoc,\n    mul_pow]\n\n"}
{"name":"EuclideanGeometry.inversion_dist_center","module":"Mathlib.Geometry.Euclidean.Inversion.Basic","initialProofState":"V : Type u_1\nP : Type u_2\ninstâœÂ³ : NormedAddCommGroup V\ninstâœÂ² : InnerProductSpace Real V\ninstâœÂ¹ : MetricSpace P\ninstâœ : NormedAddTorsor V P\nc x : P\nâŠ¢ Eq (EuclideanGeometry.inversion c (Dist.dist x c) x) x","decl":"@[simp]\ntheorem inversion_dist_center (c x : P) : inversion c (dist x c) x = x := by\n  rcases eq_or_ne x c with (rfl | hne)\n  Â· apply inversion_self\n  Â· rw [inversion, div_self, one_pow, one_smul, vsub_vadd]\n    rwa [dist_ne_zero]\n\n"}
{"name":"EuclideanGeometry.inversion_dist_center'","module":"Mathlib.Geometry.Euclidean.Inversion.Basic","initialProofState":"V : Type u_1\nP : Type u_2\ninstâœÂ³ : NormedAddCommGroup V\ninstâœÂ² : InnerProductSpace Real V\ninstâœÂ¹ : MetricSpace P\ninstâœ : NormedAddTorsor V P\nc x : P\nâŠ¢ Eq (EuclideanGeometry.inversion c (Dist.dist c x) x) x","decl":"@[simp]\ntheorem inversion_dist_center' (c x : P) : inversion c (dist c x) x = x := by\n  rw [dist_comm, inversion_dist_center]\n\n"}
{"name":"EuclideanGeometry.inversion_of_mem_sphere","module":"Mathlib.Geometry.Euclidean.Inversion.Basic","initialProofState":"V : Type u_1\nP : Type u_2\ninstâœÂ³ : NormedAddCommGroup V\ninstâœÂ² : InnerProductSpace Real V\ninstâœÂ¹ : MetricSpace P\ninstâœ : NormedAddTorsor V P\nc x : P\nR : Real\nh : Membership.mem (Metric.sphere c R) x\nâŠ¢ Eq (EuclideanGeometry.inversion c R x) x","decl":"theorem inversion_of_mem_sphere (h : x âˆˆ Metric.sphere c R) : inversion c R x = x :=\n  h.out â–¸ inversion_dist_center c x\n\n"}
{"name":"EuclideanGeometry.dist_inversion_center","module":"Mathlib.Geometry.Euclidean.Inversion.Basic","initialProofState":"V : Type u_1\nP : Type u_2\ninstâœÂ³ : NormedAddCommGroup V\ninstâœÂ² : InnerProductSpace Real V\ninstâœÂ¹ : MetricSpace P\ninstâœ : NormedAddTorsor V P\nc x : P\nR : Real\nâŠ¢ Eq (Dist.dist (EuclideanGeometry.inversion c R x) c) (HDiv.hDiv (HPow.hPow R 2) (Dist.dist x c))","decl":"/-- Distance from the image of a point under inversion to the center. This formula accidentally\nworks for `x = c`. -/\ntheorem dist_inversion_center (c x : P) (R : â„) : dist (inversion c R x) c = R ^ 2 / dist x c := by\n  rcases eq_or_ne x c with (rfl | hx)\n  Â· simp\n  have : dist x c â‰  0 := dist_ne_zero.2 hx\n  -- was `field_simp [inversion, norm_smul, abs_div, â† dist_eq_norm_vsub, sq, mul_assoc]`,\n  -- but really slow. Replaced by `simp only ...` to speed up.\n  -- TODO(https://github.com/leanprover-community/mathlib4/issues/15486): reinstate `field_simp` once it is faster.\n  simp (disch := field_simp_discharge) only [inversion, sq, mul_div_assoc', div_mul_eq_mul_div,\n    div_div, dist_vadd_left, norm_smul, norm_div, norm_mul, Real.norm_eq_abs, abs_mul_abs_self,\n    abs_dist, â† dist_eq_norm_vsub, mul_assoc, eq_div_iff, div_eq_iff]\n\n"}
{"name":"EuclideanGeometry.dist_center_inversion","module":"Mathlib.Geometry.Euclidean.Inversion.Basic","initialProofState":"V : Type u_1\nP : Type u_2\ninstâœÂ³ : NormedAddCommGroup V\ninstâœÂ² : InnerProductSpace Real V\ninstâœÂ¹ : MetricSpace P\ninstâœ : NormedAddTorsor V P\nc x : P\nR : Real\nâŠ¢ Eq (Dist.dist c (EuclideanGeometry.inversion c R x)) (HDiv.hDiv (HPow.hPow R 2) (Dist.dist c x))","decl":"/-- Distance from the center of an inversion to the image of a point under the inversion. This\nformula accidentally works for `x = c`. -/\ntheorem dist_center_inversion (c x : P) (R : â„) : dist c (inversion c R x) = R ^ 2 / dist c x := by\n  rw [dist_comm c, dist_comm c, dist_inversion_center]\n\n"}
{"name":"EuclideanGeometry.inversion_inversion","module":"Mathlib.Geometry.Euclidean.Inversion.Basic","initialProofState":"V : Type u_1\nP : Type u_2\ninstâœÂ³ : NormedAddCommGroup V\ninstâœÂ² : InnerProductSpace Real V\ninstâœÂ¹ : MetricSpace P\ninstâœ : NormedAddTorsor V P\nc : P\nR : Real\nhR : Ne R 0\nx : P\nâŠ¢ Eq (EuclideanGeometry.inversion c R (EuclideanGeometry.inversion c R x)) x","decl":"@[simp]\ntheorem inversion_inversion (c : P) {R : â„} (hR : R â‰  0) (x : P) :\n    inversion c R (inversion c R x) = x := by\n  rcases eq_or_ne x c with (rfl | hne)\n  Â· rw [inversion_self, inversion_self]\n  Â· rw [inversion, dist_inversion_center, inversion_vsub_center, smul_smul, â† mul_pow,\n      div_mul_div_comm, div_mul_cancelâ‚€ _ (dist_ne_zero.2 hne), â† sq, div_self, one_pow, one_smul,\n      vsub_vadd]\n    exact pow_ne_zero _ hR\n\n"}
{"name":"EuclideanGeometry.inversion_involutive","module":"Mathlib.Geometry.Euclidean.Inversion.Basic","initialProofState":"V : Type u_1\nP : Type u_2\ninstâœÂ³ : NormedAddCommGroup V\ninstâœÂ² : InnerProductSpace Real V\ninstâœÂ¹ : MetricSpace P\ninstâœ : NormedAddTorsor V P\nc : P\nR : Real\nhR : Ne R 0\nâŠ¢ Function.Involutive (EuclideanGeometry.inversion c R)","decl":"theorem inversion_involutive (c : P) {R : â„} (hR : R â‰  0) : Involutive (inversion c R) :=\n  inversion_inversion c hR\n\n"}
{"name":"EuclideanGeometry.inversion_surjective","module":"Mathlib.Geometry.Euclidean.Inversion.Basic","initialProofState":"V : Type u_1\nP : Type u_2\ninstâœÂ³ : NormedAddCommGroup V\ninstâœÂ² : InnerProductSpace Real V\ninstâœÂ¹ : MetricSpace P\ninstâœ : NormedAddTorsor V P\nc : P\nR : Real\nhR : Ne R 0\nâŠ¢ Function.Surjective (EuclideanGeometry.inversion c R)","decl":"theorem inversion_surjective (c : P) {R : â„} (hR : R â‰  0) : Surjective (inversion c R) :=\n  (inversion_involutive c hR).surjective\n\n"}
{"name":"EuclideanGeometry.inversion_injective","module":"Mathlib.Geometry.Euclidean.Inversion.Basic","initialProofState":"V : Type u_1\nP : Type u_2\ninstâœÂ³ : NormedAddCommGroup V\ninstâœÂ² : InnerProductSpace Real V\ninstâœÂ¹ : MetricSpace P\ninstâœ : NormedAddTorsor V P\nc : P\nR : Real\nhR : Ne R 0\nâŠ¢ Function.Injective (EuclideanGeometry.inversion c R)","decl":"theorem inversion_injective (c : P) {R : â„} (hR : R â‰  0) : Injective (inversion c R) :=\n  (inversion_involutive c hR).injective\n\n"}
{"name":"EuclideanGeometry.inversion_bijective","module":"Mathlib.Geometry.Euclidean.Inversion.Basic","initialProofState":"V : Type u_1\nP : Type u_2\ninstâœÂ³ : NormedAddCommGroup V\ninstâœÂ² : InnerProductSpace Real V\ninstâœÂ¹ : MetricSpace P\ninstâœ : NormedAddTorsor V P\nc : P\nR : Real\nhR : Ne R 0\nâŠ¢ Function.Bijective (EuclideanGeometry.inversion c R)","decl":"theorem inversion_bijective (c : P) {R : â„} (hR : R â‰  0) : Bijective (inversion c R) :=\n  (inversion_involutive c hR).bijective\n\n"}
{"name":"EuclideanGeometry.inversion_eq_center","module":"Mathlib.Geometry.Euclidean.Inversion.Basic","initialProofState":"V : Type u_1\nP : Type u_2\ninstâœÂ³ : NormedAddCommGroup V\ninstâœÂ² : InnerProductSpace Real V\ninstâœÂ¹ : MetricSpace P\ninstâœ : NormedAddTorsor V P\nc x : P\nR : Real\nhR : Ne R 0\nâŠ¢ Iff (Eq (EuclideanGeometry.inversion c R x) c) (Eq x c)","decl":"theorem inversion_eq_center (hR : R â‰  0) : inversion c R x = c â†” x = c :=\n  (inversion_injective c hR).eq_iff' <| inversion_self _ _\n\n"}
{"name":"EuclideanGeometry.inversion_eq_center'","module":"Mathlib.Geometry.Euclidean.Inversion.Basic","initialProofState":"V : Type u_1\nP : Type u_2\ninstâœÂ³ : NormedAddCommGroup V\ninstâœÂ² : InnerProductSpace Real V\ninstâœÂ¹ : MetricSpace P\ninstâœ : NormedAddTorsor V P\nc x : P\nR : Real\nâŠ¢ Iff (Eq (EuclideanGeometry.inversion c R x) c) (Or (Eq x c) (Eq R 0))","decl":"@[simp]\ntheorem inversion_eq_center' : inversion c R x = c â†” x = c âˆ¨ R = 0 := by\n  by_cases hR : R = 0 <;> simp [inversion_eq_center, hR]\n\n"}
{"name":"EuclideanGeometry.center_eq_inversion","module":"Mathlib.Geometry.Euclidean.Inversion.Basic","initialProofState":"V : Type u_1\nP : Type u_2\ninstâœÂ³ : NormedAddCommGroup V\ninstâœÂ² : InnerProductSpace Real V\ninstâœÂ¹ : MetricSpace P\ninstâœ : NormedAddTorsor V P\nc x : P\nR : Real\nhR : Ne R 0\nâŠ¢ Iff (Eq c (EuclideanGeometry.inversion c R x)) (Eq x c)","decl":"theorem center_eq_inversion (hR : R â‰  0) : c = inversion c R x â†” x = c :=\n  eq_comm.trans (inversion_eq_center hR)\n\n"}
{"name":"EuclideanGeometry.center_eq_inversion'","module":"Mathlib.Geometry.Euclidean.Inversion.Basic","initialProofState":"V : Type u_1\nP : Type u_2\ninstâœÂ³ : NormedAddCommGroup V\ninstâœÂ² : InnerProductSpace Real V\ninstâœÂ¹ : MetricSpace P\ninstâœ : NormedAddTorsor V P\nc x : P\nR : Real\nâŠ¢ Iff (Eq c (EuclideanGeometry.inversion c R x)) (Or (Eq x c) (Eq R 0))","decl":"@[simp]\ntheorem center_eq_inversion' : c = inversion c R x â†” x = c âˆ¨ R = 0 :=\n  eq_comm.trans inversion_eq_center'\n\n"}
{"name":"EuclideanGeometry.dist_inversion_inversion","module":"Mathlib.Geometry.Euclidean.Inversion.Basic","initialProofState":"V : Type u_1\nP : Type u_2\ninstâœÂ³ : NormedAddCommGroup V\ninstâœÂ² : InnerProductSpace Real V\ninstâœÂ¹ : MetricSpace P\ninstâœ : NormedAddTorsor V P\nc x y : P\nhx : Ne x c\nhy : Ne y c\nR : Real\nâŠ¢ Eq (Dist.dist (EuclideanGeometry.inversion c R x) (EuclideanGeometry.inversion c R y)) (HMul.hMul (HDiv.hDiv (HPow.hPow R 2) (HMul.hMul (Dist.dist x c) (Dist.dist y c))) (Dist.dist x y))","decl":"/-- Distance between the images of two points under an inversion. -/\ntheorem dist_inversion_inversion (hx : x â‰  c) (hy : y â‰  c) (R : â„) :\n    dist (inversion c R x) (inversion c R y) = R ^ 2 / (dist x c * dist y c) * dist x y := by\n  dsimp only [inversion]\n  simp_rw [dist_vadd_cancel_right, dist_eq_norm_vsub V _ c]\n  simpa only [dist_vsub_cancel_right] using\n    dist_div_norm_sq_smul (vsub_ne_zero.2 hx) (vsub_ne_zero.2 hy) R\n\n"}
{"name":"EuclideanGeometry.dist_inversion_mul_dist_center_eq","module":"Mathlib.Geometry.Euclidean.Inversion.Basic","initialProofState":"V : Type u_1\nP : Type u_2\ninstâœÂ³ : NormedAddCommGroup V\ninstâœÂ² : InnerProductSpace Real V\ninstâœÂ¹ : MetricSpace P\ninstâœ : NormedAddTorsor V P\nc x y : P\nR : Real\nhx : Ne x c\nhy : Ne y c\nâŠ¢ Eq (HMul.hMul (Dist.dist (EuclideanGeometry.inversion c R x) y) (Dist.dist x c)) (HMul.hMul (Dist.dist x (EuclideanGeometry.inversion c R y)) (Dist.dist y c))","decl":"theorem dist_inversion_mul_dist_center_eq (hx : x â‰  c) (hy : y â‰  c) :\n    dist (inversion c R x) y * dist x c = dist x (inversion c R y) * dist y c := by\n  rcases eq_or_ne R 0 with rfl | hR; Â· simp [dist_comm, mul_comm]\n  have hy' : inversion c R y â‰  c := by simp [*]\n  conv in dist _ y => rw [â† inversion_inversion c hR y]\n  rw [dist_inversion_inversion hx hy', dist_inversion_center]\n  have : dist x c â‰  0 := dist_ne_zero.2 hx\n  -- used to be `field_simp`, but was really slow; replaced by `simp only ...` to speed up\n  -- TODO(https://github.com/leanprover-community/mathlib4/issues/15486): reinstate `field_simp` once it is faster.\n  simp (disch := field_simp_discharge) only [mul_div_assoc', div_div_eq_mul_div, div_mul_eq_mul_div,\n    div_eq_iff]\n  ring\n\n"}
{"name":"EuclideanGeometry.mul_dist_le_mul_dist_add_mul_dist","module":"Mathlib.Geometry.Euclidean.Inversion.Basic","initialProofState":"V : Type u_1\nP : Type u_2\ninstâœÂ³ : NormedAddCommGroup V\ninstâœÂ² : InnerProductSpace Real V\ninstâœÂ¹ : MetricSpace P\ninstâœ : NormedAddTorsor V P\na b c d : P\nâŠ¢ LE.le (HMul.hMul (Dist.dist a c) (Dist.dist b d)) (HAdd.hAdd (HMul.hMul (Dist.dist a b) (Dist.dist c d)) (HMul.hMul (Dist.dist b c) (Dist.dist a d)))","decl":"include V in\n/-- **Ptolemy's inequality**: in a quadrangle `ABCD`, `|AC| * |BD| â‰¤ |AB| * |CD| + |BC| * |AD|`. If\n`ABCD` is a convex cyclic polygon, then this inequality becomes an equality, see\n`EuclideanGeometry.mul_dist_add_mul_dist_eq_mul_dist_of_cospherical`. -/\ntheorem mul_dist_le_mul_dist_add_mul_dist (a b c d : P) :\n    dist a c * dist b d â‰¤ dist a b * dist c d + dist b c * dist a d := by\n  -- If one of the points `b`, `c`, `d` is equal to `a`, then the inequality is trivial.\n  rcases eq_or_ne b a with (rfl | hb)\n  Â· rw [dist_self, zero_mul, zero_add]\n  rcases eq_or_ne c a with (rfl | hc)\n  Â· rw [dist_self, zero_mul]\n    apply_rules [add_nonneg, mul_nonneg, dist_nonneg]\n  rcases eq_or_ne d a with (rfl | hd)\n  Â· rw [dist_self, mul_zero, add_zero, dist_comm d, dist_comm d, mul_comm]\n  /- Otherwise, we apply the triangle inequality to `EuclideanGeometry.inversion a 1 b`,\n    `EuclideanGeometry.inversion a 1 c`, and `EuclideanGeometry.inversion a 1 d`. -/\n  have H := dist_triangle (inversion a 1 b) (inversion a 1 c) (inversion a 1 d)\n  rw [dist_inversion_inversion hb hd, dist_inversion_inversion hb hc,\n    dist_inversion_inversion hc hd, one_pow] at H\n  rw [â† dist_pos] at hb hc hd\n  rw [â† div_le_div_iff_of_pos_right (mul_pos hb (mul_pos hc hd))]\n  convert H using 1 <;> (field_simp [hb.ne', hc.ne', hd.ne', dist_comm a]; ring)\n\n"}
{"name":"Filter.Tendsto.inversion","module":"Mathlib.Geometry.Euclidean.Inversion.Basic","initialProofState":"V : Type u_1\nP : Type u_2\ninstâœÂ³ : NormedAddCommGroup V\ninstâœÂ² : InnerProductSpace Real V\ninstâœÂ¹ : MetricSpace P\ninstâœ : NormedAddTorsor V P\nÎ± : Type u_3\nx c : P\nR : Real\nl : Filter Î±\nfc fx : Î± â†’ P\nfR : Î± â†’ Real\nhc : Filter.Tendsto fc l (nhds c)\nhR : Filter.Tendsto fR l (nhds R)\nhx : Filter.Tendsto fx l (nhds x)\nhne : Ne x c\nâŠ¢ Filter.Tendsto (fun a => EuclideanGeometry.inversion (fc a) (fR a) (fx a)) l (nhds (EuclideanGeometry.inversion c R x))","decl":"protected theorem Filter.Tendsto.inversion {Î± : Type*} {x c : P} {R : â„} {l : Filter Î±}\n    {fc fx : Î± â†’ P} {fR : Î± â†’ â„} (hc : Tendsto fc l (ğ“ c)) (hR : Tendsto fR l (ğ“ R))\n    (hx : Tendsto fx l (ğ“ x)) (hne : x â‰  c) :\n    Tendsto (fun a â†¦ inversion (fc a) (fR a) (fx a)) l (ğ“ (inversion c R x)) :=\n  (((hR.div (hx.dist hc) <| dist_ne_zero.2 hne).pow 2).smul (hx.vsub hc)).vadd hc\n\n"}
{"name":"ContinuousWithinAt.inversion","module":"Mathlib.Geometry.Euclidean.Inversion.Basic","initialProofState":"V : Type u_1\nP : Type u_2\ninstâœâ´ : NormedAddCommGroup V\ninstâœÂ³ : InnerProductSpace Real V\ninstâœÂ² : MetricSpace P\ninstâœÂ¹ : NormedAddTorsor V P\nX : Type u_3\ninstâœ : TopologicalSpace X\nc x : X â†’ P\nR : X â†’ Real\naâ‚€ : X\ns : Set X\nhc : ContinuousWithinAt c s aâ‚€\nhR : ContinuousWithinAt R s aâ‚€\nhx : ContinuousWithinAt x s aâ‚€\nhne : Ne (x aâ‚€) (c aâ‚€)\nâŠ¢ ContinuousWithinAt (fun a => EuclideanGeometry.inversion (c a) (R a) (x a)) s aâ‚€","decl":"protected nonrec theorem ContinuousWithinAt.inversion (hc : ContinuousWithinAt c s aâ‚€)\n    (hR : ContinuousWithinAt R s aâ‚€) (hx : ContinuousWithinAt x s aâ‚€) (hne : x aâ‚€ â‰  c aâ‚€) :\n    ContinuousWithinAt (fun a â†¦ inversion (c a) (R a) (x a)) s aâ‚€ :=\n  hc.inversion hR hx hne\n\n"}
{"name":"ContinuousAt.inversion","module":"Mathlib.Geometry.Euclidean.Inversion.Basic","initialProofState":"V : Type u_1\nP : Type u_2\ninstâœâ´ : NormedAddCommGroup V\ninstâœÂ³ : InnerProductSpace Real V\ninstâœÂ² : MetricSpace P\ninstâœÂ¹ : NormedAddTorsor V P\nX : Type u_3\ninstâœ : TopologicalSpace X\nc x : X â†’ P\nR : X â†’ Real\naâ‚€ : X\nhc : ContinuousAt c aâ‚€\nhR : ContinuousAt R aâ‚€\nhx : ContinuousAt x aâ‚€\nhne : Ne (x aâ‚€) (c aâ‚€)\nâŠ¢ ContinuousAt (fun a => EuclideanGeometry.inversion (c a) (R a) (x a)) aâ‚€","decl":"protected nonrec theorem ContinuousAt.inversion (hc : ContinuousAt c aâ‚€) (hR : ContinuousAt R aâ‚€)\n    (hx : ContinuousAt x aâ‚€) (hne : x aâ‚€ â‰  c aâ‚€) :\n    ContinuousAt (fun a â†¦ inversion (c a) (R a) (x a)) aâ‚€ :=\n  hc.inversion hR hx hne\n\n"}
{"name":"ContinuousOn.inversion","module":"Mathlib.Geometry.Euclidean.Inversion.Basic","initialProofState":"V : Type u_1\nP : Type u_2\ninstâœâ´ : NormedAddCommGroup V\ninstâœÂ³ : InnerProductSpace Real V\ninstâœÂ² : MetricSpace P\ninstâœÂ¹ : NormedAddTorsor V P\nX : Type u_3\ninstâœ : TopologicalSpace X\nc x : X â†’ P\nR : X â†’ Real\ns : Set X\nhc : ContinuousOn c s\nhR : ContinuousOn R s\nhx : ContinuousOn x s\nhne : âˆ€ (a : X), Membership.mem s a â†’ Ne (x a) (c a)\nâŠ¢ ContinuousOn (fun a => EuclideanGeometry.inversion (c a) (R a) (x a)) s","decl":"protected theorem ContinuousOn.inversion (hc : ContinuousOn c s) (hR : ContinuousOn R s)\n    (hx : ContinuousOn x s) (hne : âˆ€ a âˆˆ s, x a â‰  c a) :\n    ContinuousOn (fun a â†¦ inversion (c a) (R a) (x a)) s := fun a ha â†¦\n  (hc a ha).inversion (hR a ha) (hx a ha) (hne a ha)\n\n"}
{"name":"Continuous.inversion","module":"Mathlib.Geometry.Euclidean.Inversion.Basic","initialProofState":"V : Type u_1\nP : Type u_2\ninstâœâ´ : NormedAddCommGroup V\ninstâœÂ³ : InnerProductSpace Real V\ninstâœÂ² : MetricSpace P\ninstâœÂ¹ : NormedAddTorsor V P\nX : Type u_3\ninstâœ : TopologicalSpace X\nc x : X â†’ P\nR : X â†’ Real\nhc : Continuous c\nhR : Continuous R\nhx : Continuous x\nhne : âˆ€ (a : X), Ne (x a) (c a)\nâŠ¢ Continuous fun a => EuclideanGeometry.inversion (c a) (R a) (x a)","decl":"protected theorem Continuous.inversion (hc : Continuous c) (hR : Continuous R) (hx : Continuous x)\n    (hne : âˆ€ a, x a â‰  c a) : Continuous (fun a â†¦ inversion (c a) (R a) (x a)) :=\n  continuous_iff_continuousAt.2 fun _ â†¦\n    hc.continuousAt.inversion hR.continuousAt hx.continuousAt (hne _)\n"}
