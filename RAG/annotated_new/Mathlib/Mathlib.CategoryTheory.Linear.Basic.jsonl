{"name":"CategoryTheory.Linear.comp_smul","module":"Mathlib.CategoryTheory.Linear.Basic","initialProofState":"R : Type w\ninst✝² : Semiring R\nC : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nself : CategoryTheory.Linear R C\nX Y Z : C\nf : Quiver.Hom X Y\nr : R\ng : Quiver.Hom Y Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp f (HSMul.hSMul r g)) (HSMul.hSMul r (CategoryTheory.CategoryStruct.comp f g))","decl":"/-- A category is called `R`-linear if `P ⟶ Q` is an `R`-module such that composition is\n    `R`-linear in both variables. -/\nclass Linear (R : Type w) [Semiring R] (C : Type u) [Category.{v} C] [Preadditive C] where\n  homModule : ∀ X Y : C, Module R (X ⟶ Y) := by infer_instance\n  /-- compatibility of the scalar multiplication with the post-composition -/\n  smul_comp : ∀ (X Y Z : C) (r : R) (f : X ⟶ Y) (g : Y ⟶ Z), (r • f) ≫ g = r • f ≫ g := by\n    aesop_cat\n  /-- compatibility of the scalar multiplication with the pre-composition -/\n  comp_smul : ∀ (X Y Z : C) (f : X ⟶ Y) (r : R) (g : Y ⟶ Z), f ≫ (r • g) = r • f ≫ g := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.Linear.smul_comp","module":"Mathlib.CategoryTheory.Linear.Basic","initialProofState":"R : Type w\ninst✝² : Semiring R\nC : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nself : CategoryTheory.Linear R C\nX Y Z : C\nr : R\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (HSMul.hSMul r f) g) (HSMul.hSMul r (CategoryTheory.CategoryStruct.comp f g))","decl":"/-- A category is called `R`-linear if `P ⟶ Q` is an `R`-module such that composition is\n    `R`-linear in both variables. -/\nclass Linear (R : Type w) [Semiring R] (C : Type u) [Category.{v} C] [Preadditive C] where\n  homModule : ∀ X Y : C, Module R (X ⟶ Y) := by infer_instance\n  /-- compatibility of the scalar multiplication with the post-composition -/\n  smul_comp : ∀ (X Y Z : C) (r : R) (f : X ⟶ Y) (g : Y ⟶ Z), (r • f) ≫ g = r • f ≫ g := by\n    aesop_cat\n  /-- compatibility of the scalar multiplication with the pre-composition -/\n  comp_smul : ∀ (X Y Z : C) (f : X ⟶ Y) (r : R) (g : Y ⟶ Z), f ≫ (r • g) = r • f ≫ g := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.Linear.leftComp_apply","module":"Mathlib.CategoryTheory.Linear.Basic","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Preadditive C\nR : Type w\ninst✝¹ : Semiring R\ninst✝ : CategoryTheory.Linear R C\nX Y Z : C\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\n⊢ Eq ((CategoryTheory.Linear.leftComp R Z f) g) (CategoryTheory.CategoryStruct.comp f g)","decl":"/-- Composition by a fixed left argument as an `R`-linear map. -/\n@[simps]\ndef leftComp {X Y : C} (Z : C) (f : X ⟶ Y) : (Y ⟶ Z) →ₗ[R] X ⟶ Z where\n  toFun g := f ≫ g\n  map_add' := by simp\n  map_smul' := by simp\n\n"}
{"name":"CategoryTheory.Linear.rightComp_apply","module":"Mathlib.CategoryTheory.Linear.Basic","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Preadditive C\nR : Type w\ninst✝¹ : Semiring R\ninst✝ : CategoryTheory.Linear R C\nX Y Z : C\ng : Quiver.Hom Y Z\nf : Quiver.Hom X Y\n⊢ Eq ((CategoryTheory.Linear.rightComp R X g) f) (CategoryTheory.CategoryStruct.comp f g)","decl":"/-- Composition by a fixed right argument as an `R`-linear map. -/\n@[simps]\ndef rightComp (X : C) {Y Z : C} (g : Y ⟶ Z) : (X ⟶ Y) →ₗ[R] X ⟶ Z where\n  toFun f := f ≫ g\n  map_add' := by simp\n  map_smul' := by simp\n\n"}
{"name":"CategoryTheory.Linear.instEpiHSMulHomOfInvertible","module":"Mathlib.CategoryTheory.Linear.Basic","initialProofState":"C : Type u\ninst✝⁵ : CategoryTheory.Category.{v, u} C\ninst✝⁴ : CategoryTheory.Preadditive C\nR : Type w\ninst✝³ : Semiring R\ninst✝² : CategoryTheory.Linear R C\nX Y : C\nf : Quiver.Hom X Y\ninst✝¹ : CategoryTheory.Epi f\nr : R\ninst✝ : Invertible r\n⊢ CategoryTheory.Epi (HSMul.hSMul r f)","decl":"instance {X Y : C} (f : X ⟶ Y) [Epi f] (r : R) [Invertible r] : Epi (r • f) :=\n  ⟨fun g g' H => by\n    rw [smul_comp, smul_comp, ← comp_smul, ← comp_smul, cancel_epi] at H\n    simpa [smul_smul] using congr_arg (fun f => ⅟ r • f) H⟩\n\n"}
{"name":"CategoryTheory.Linear.instMonoHSMulHomOfInvertible","module":"Mathlib.CategoryTheory.Linear.Basic","initialProofState":"C : Type u\ninst✝⁵ : CategoryTheory.Category.{v, u} C\ninst✝⁴ : CategoryTheory.Preadditive C\nR : Type w\ninst✝³ : Semiring R\ninst✝² : CategoryTheory.Linear R C\nX Y : C\nf : Quiver.Hom X Y\ninst✝¹ : CategoryTheory.Mono f\nr : R\ninst✝ : Invertible r\n⊢ CategoryTheory.Mono (HSMul.hSMul r f)","decl":"instance {X Y : C} (f : X ⟶ Y) [Mono f] (r : R) [Invertible r] : Mono (r • f) :=\n  ⟨fun g g' H => by\n    rw [comp_smul, comp_smul, ← smul_comp, ← smul_comp, cancel_mono] at H\n    simpa [smul_smul] using congr_arg (fun f => ⅟ r • f) H⟩\n\n"}
{"name":"CategoryTheory.Linear.homCongr_apply","module":"Mathlib.CategoryTheory.Linear.Basic","initialProofState":"k : Type u_1\nC : Type u_2\ninst✝³ : CategoryTheory.Category.{u_3, u_2} C\ninst✝² : Semiring k\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.Linear k C\nX Y W Z : C\nf₁ : CategoryTheory.Iso X Y\nf₂ : CategoryTheory.Iso W Z\nf : Quiver.Hom X W\n⊢ Eq ((CategoryTheory.Linear.homCongr k f₁ f₂) f) (CategoryTheory.CategoryStruct.comp (CategoryTheory.CategoryStruct.comp f₁.inv f) f₂.hom)","decl":"theorem homCongr_apply (k : Type*) {C : Type*} [Category C] [Semiring k] [Preadditive C]\n    [Linear k C] {X Y W Z : C} (f₁ : X ≅ Y) (f₂ : W ≅ Z) (f : X ⟶ W) :\n    homCongr k f₁ f₂ f = (f₁.inv ≫ f) ≫ f₂.hom :=\n  rfl\n\n"}
{"name":"CategoryTheory.Linear.homCongr_symm_apply","module":"Mathlib.CategoryTheory.Linear.Basic","initialProofState":"k : Type u_1\nC : Type u_2\ninst✝³ : CategoryTheory.Category.{u_3, u_2} C\ninst✝² : Semiring k\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.Linear k C\nX Y W Z : C\nf₁ : CategoryTheory.Iso X Y\nf₂ : CategoryTheory.Iso W Z\nf : Quiver.Hom Y Z\n⊢ Eq ((CategoryTheory.Linear.homCongr k f₁ f₂).symm f) (CategoryTheory.CategoryStruct.comp f₁.hom (CategoryTheory.CategoryStruct.comp f f₂.inv))","decl":"theorem homCongr_symm_apply (k : Type*) {C : Type*} [Category C] [Semiring k] [Preadditive C]\n    [Linear k C] {X Y W Z : C} (f₁ : X ≅ Y) (f₂ : W ≅ Z) (f : Y ⟶ Z) :\n    (homCongr k f₁ f₂).symm f = f₁.hom ≫ f ≫ f₂.inv :=\n  rfl\n\n"}
{"name":"CategoryTheory.Linear.units_smul_comp","module":"Mathlib.CategoryTheory.Linear.Basic","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Preadditive C\nR : Type w\ninst✝¹ : Semiring R\ninst✝ : CategoryTheory.Linear R C\nX Y Z : C\nr : Units R\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (HSMul.hSMul r f) g) (HSMul.hSMul r (CategoryTheory.CategoryStruct.comp f g))","decl":"@[simp]\nlemma units_smul_comp {X Y Z : C} (r : Rˣ) (f : X ⟶ Y) (g : Y ⟶ Z) :\n    (r • f) ≫ g = r • f ≫ g := by\n  apply Linear.smul_comp\n\n"}
{"name":"CategoryTheory.Linear.comp_units_smul","module":"Mathlib.CategoryTheory.Linear.Basic","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Preadditive C\nR : Type w\ninst✝¹ : Semiring R\ninst✝ : CategoryTheory.Linear R C\nX Y Z : C\nf : Quiver.Hom X Y\nr : Units R\ng : Quiver.Hom Y Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp f (HSMul.hSMul r g)) (HSMul.hSMul r (CategoryTheory.CategoryStruct.comp f g))","decl":"@[simp]\nlemma comp_units_smul {X Y Z : C} (f : X ⟶ Y) (r : Rˣ) (g : Y ⟶ Z) :\n    f ≫ (r • g) = r • f ≫ g := by\n  apply Linear.comp_smul\n\n"}
{"name":"CategoryTheory.Linear.comp_apply","module":"Mathlib.CategoryTheory.Linear.Basic","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Preadditive C\nS : Type w\ninst✝¹ : CommSemiring S\ninst✝ : CategoryTheory.Linear S C\nX Y Z : C\nf : Quiver.Hom X Y\n⊢ Eq ((CategoryTheory.Linear.comp X Y Z) f) (CategoryTheory.Linear.leftComp S Z f)","decl":"/-- Composition as a bilinear map. -/\n@[simps]\ndef comp (X Y Z : C) : (X ⟶ Y) →ₗ[S] (Y ⟶ Z) →ₗ[S] X ⟶ Z where\n  toFun f := leftComp S Z f\n  map_add' := by\n    intros\n    ext\n    simp\n  map_smul' := by\n    intros\n    ext\n    simp\n\n"}
