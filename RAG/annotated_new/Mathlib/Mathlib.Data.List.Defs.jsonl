{"name":"List.headI_nil","module":"Mathlib.Data.List.Defs","initialProofState":"α : Type u_1\ninst✝ : Inhabited α\n⊢ Eq List.nil.headI Inhabited.default","decl":"@[simp] theorem headI_nil [Inhabited α] : ([] : List α).headI = default := rfl\n"}
{"name":"List.headI_cons","module":"Mathlib.Data.List.Defs","initialProofState":"α : Type u_1\ninst✝ : Inhabited α\nh : α\nt : List α\n⊢ Eq (List.cons h t).headI h","decl":"@[simp] theorem headI_cons [Inhabited α] {h : α} {t : List α} : (h :: t).headI = h := rfl\n\n"}
{"name":"List.iterateTR_loop_eq","module":"Mathlib.Data.List.Defs","initialProofState":"α : Type u_1\nf : α → α\na : α\nn : Nat\nl : List α\n⊢ Eq (List.iterateTR.loop f a n l) (HAppend.hAppend l.reverse (List.iterate f a n))","decl":"theorem iterateTR_loop_eq (f : α → α) (a : α) (n : ℕ) (l : List α) :\n    iterateTR.loop f a n l = reverse l ++ iterate f a n := by\n  induction n generalizing a l <;> simp [*]\n\n"}
{"name":"List.iterate_eq_iterateTR","module":"Mathlib.Data.List.Defs","initialProofState":"⊢ Eq @List.iterate @List.iterateTR","decl":"@[csimp]\ntheorem iterate_eq_iterateTR : @iterate = @iterateTR := by\n  funext α f a n\n  exact Eq.symm <| iterateTR_loop_eq f a n []\n\n"}
{"name":"List.length_mapAccumr","module":"Mathlib.Data.List.Defs","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nf : α → γ → Prod γ β\nx : List α\ns : γ\n⊢ Eq (List.mapAccumr f x s).snd.length x.length","decl":"/-- Length of the list obtained by `mapAccumr`. -/\n@[simp]\ntheorem length_mapAccumr :\n    ∀ (f : α → γ → γ × β) (x : List α) (s : γ), length (mapAccumr f x s).2 = length x\n  | f, _ :: x, s => congr_arg succ (length_mapAccumr f x s)\n  | _, [], _ => rfl\n\n"}
{"name":"List.length_mapAccumr₂","module":"Mathlib.Data.List.Defs","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nδ : Type u_4\nf : α → β → γ → Prod γ δ\nx : List α\ny : List β\nc : γ\n⊢ Eq (List.mapAccumr₂ f x y c).snd.length (Min.min x.length y.length)","decl":"/-- Length of a list obtained using `mapAccumr₂`. -/\n@[simp]\ntheorem length_mapAccumr₂ :\n    ∀ (f : α → β → γ → γ × δ) (x y c), length (mapAccumr₂ f x y c).2 = min (length x) (length y)\n  | f, _ :: x, _ :: y, c =>\n    calc\n      succ (length (mapAccumr₂ f x y c).2) = succ (min (length x) (length y)) :=\n        congr_arg succ (length_mapAccumr₂ f x y c)\n      _ = min (succ (length x)) (succ (length y)) := Eq.symm (succ_min_succ (length x) (length y))\n  | _, _ :: _, [], _ => rfl\n  | _, [], _ :: _, _ => rfl\n  | _, [], [], _ => rfl\n\n"}
{"name":"List.mem_cons_eq","module":"Mathlib.Data.List.Defs","initialProofState":"α : Type u_1\na y : α\nl : List α\n⊢ Eq (Membership.mem (List.cons y l) a) (Or (Eq a y) (Membership.mem l a))","decl":"@[deprecated List.mem_cons (since := \"2024-08-10\")]\ntheorem mem_cons_eq (a y : α) (l : List α) : (a ∈ y :: l) = (a = y ∨ a ∈ l) :=\n  propext List.mem_cons\n\n"}
{"name":"List.eq_or_mem_of_mem_cons","module":"Mathlib.Data.List.Defs","initialProofState":"α✝ : Type u_1\nb : α✝\nl : List α✝\na : α✝\na✝ : Membership.mem (List.cons b l) a\n⊢ Or (Eq a b) (Membership.mem l a)","decl":"alias ⟨eq_or_mem_of_mem_cons, _⟩ := mem_cons\n\n"}
{"name":"List.not_exists_mem_nil","module":"Mathlib.Data.List.Defs","initialProofState":"α : Type u_1\np : α → Prop\n⊢ Not (Exists fun x => And (Membership.mem List.nil x) (p x))","decl":"@[deprecated List.not_mem_nil (since := \"2024-08-10\")]\ntheorem not_exists_mem_nil (p : α → Prop) : ¬∃ x ∈ @nil α, p x :=\n  fun ⟨_, hx, _⟩ => List.not_mem_nil _ hx\n\n\n"}
{"name":"List.length_le_of_sublist","module":"Mathlib.Data.List.Defs","initialProofState":"α✝ : Type u_1\nl₁ l₂ : List α✝\na✝ : l₁.Sublist l₂\n⊢ LE.le l₁.length l₂.length","decl":"@[deprecated (since := \"2024-08-10\")] alias length_le_of_sublist := Sublist.length_le\n\n"}
