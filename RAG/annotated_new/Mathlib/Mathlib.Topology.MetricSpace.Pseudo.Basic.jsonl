{"name":"dist_le_Ico_sum_dist","module":"Mathlib.Topology.MetricSpace.Pseudo.Basic","initialProofState":"Î± : Type u\ninstâœ : PseudoMetricSpace Î±\nf : Nat â†’ Î±\nm n : Nat\nh : LE.le m n\nâŠ¢ LE.le (Dist.dist (f m) (f n)) ((Finset.Ico m n).sum fun i => Dist.dist (f i) (f (HAdd.hAdd i 1)))","decl":"/-- The triangle (polygon) inequality for sequences of points; `Finset.Ico` version. -/\ntheorem dist_le_Ico_sum_dist (f : â„• â†’ Î±) {m n} (h : m â‰¤ n) :\n    dist (f m) (f n) â‰¤ âˆ‘ i âˆˆ Finset.Ico m n, dist (f i) (f (i + 1)) := by\n  induction n, h using Nat.le_induction with\n  | base => rw [Finset.Ico_self, Finset.sum_empty, dist_self]\n  | succ n hle ihn =>\n    calc\n      dist (f m) (f (n + 1)) â‰¤ dist (f m) (f n) + dist (f n) (f (n + 1)) := dist_triangle _ _ _\n      _ â‰¤ (âˆ‘ i âˆˆ Finset.Ico m n, _) + _ := add_le_add ihn le_rfl\n      _ = âˆ‘ i âˆˆ Finset.Ico m (n + 1), _ := by\n      { rw [Nat.Ico_succ_right_eq_insert_Ico hle, Finset.sum_insert, add_comm]; simp }\n\n"}
{"name":"dist_le_range_sum_dist","module":"Mathlib.Topology.MetricSpace.Pseudo.Basic","initialProofState":"Î± : Type u\ninstâœ : PseudoMetricSpace Î±\nf : Nat â†’ Î±\nn : Nat\nâŠ¢ LE.le (Dist.dist (f 0) (f n)) ((Finset.range n).sum fun i => Dist.dist (f i) (f (HAdd.hAdd i 1)))","decl":"/-- The triangle (polygon) inequality for sequences of points; `Finset.range` version. -/\ntheorem dist_le_range_sum_dist (f : â„• â†’ Î±) (n : â„•) :\n    dist (f 0) (f n) â‰¤ âˆ‘ i âˆˆ Finset.range n, dist (f i) (f (i + 1)) :=\n  Nat.Ico_zero_eq_range â–¸ dist_le_Ico_sum_dist f (Nat.zero_le n)\n\n"}
{"name":"dist_le_Ico_sum_of_dist_le","module":"Mathlib.Topology.MetricSpace.Pseudo.Basic","initialProofState":"Î± : Type u\ninstâœ : PseudoMetricSpace Î±\nf : Nat â†’ Î±\nm n : Nat\nhmn : LE.le m n\nd : Nat â†’ Real\nhd : âˆ€ {k : Nat}, LE.le m k â†’ LT.lt k n â†’ LE.le (Dist.dist (f k) (f (HAdd.hAdd k 1))) (d k)\nâŠ¢ LE.le (Dist.dist (f m) (f n)) ((Finset.Ico m n).sum fun i => d i)","decl":"/-- A version of `dist_le_Ico_sum_dist` with each intermediate distance replaced\nwith an upper estimate. -/\ntheorem dist_le_Ico_sum_of_dist_le {f : â„• â†’ Î±} {m n} (hmn : m â‰¤ n) {d : â„• â†’ â„}\n    (hd : âˆ€ {k}, m â‰¤ k â†’ k < n â†’ dist (f k) (f (k + 1)) â‰¤ d k) :\n    dist (f m) (f n) â‰¤ âˆ‘ i âˆˆ Finset.Ico m n, d i :=\n  le_trans (dist_le_Ico_sum_dist f hmn) <|\n    Finset.sum_le_sum fun _k hk => hd (Finset.mem_Ico.1 hk).1 (Finset.mem_Ico.1 hk).2\n\n"}
{"name":"dist_le_range_sum_of_dist_le","module":"Mathlib.Topology.MetricSpace.Pseudo.Basic","initialProofState":"Î± : Type u\ninstâœ : PseudoMetricSpace Î±\nf : Nat â†’ Î±\nn : Nat\nd : Nat â†’ Real\nhd : âˆ€ {k : Nat}, LT.lt k n â†’ LE.le (Dist.dist (f k) (f (HAdd.hAdd k 1))) (d k)\nâŠ¢ LE.le (Dist.dist (f 0) (f n)) ((Finset.range n).sum fun i => d i)","decl":"/-- A version of `dist_le_range_sum_dist` with each intermediate distance replaced\nwith an upper estimate. -/\ntheorem dist_le_range_sum_of_dist_le {f : â„• â†’ Î±} (n : â„•) {d : â„• â†’ â„}\n    (hd : âˆ€ {k}, k < n â†’ dist (f k) (f (k + 1)) â‰¤ d k) :\n    dist (f 0) (f n) â‰¤ âˆ‘ i âˆˆ Finset.range n, d i :=\n  Nat.Ico_zero_eq_range â–¸ dist_le_Ico_sum_of_dist_le (zero_le n) fun _ => hd\n\n"}
{"name":"Metric.isUniformInducing_iff","module":"Mathlib.Topology.MetricSpace.Pseudo.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ¹ : PseudoMetricSpace Î±\ninstâœ : PseudoMetricSpace Î²\nf : Î± â†’ Î²\nâŠ¢ Iff (IsUniformInducing f) (And (UniformContinuous f) (âˆ€ (Î´ : Real), GT.gt Î´ 0 â†’ Exists fun Îµ => And (GT.gt Îµ 0) (âˆ€ {a b : Î±}, LT.lt (Dist.dist (f a) (f b)) Îµ â†’ LT.lt (Dist.dist a b) Î´)))","decl":"nonrec theorem isUniformInducing_iff [PseudoMetricSpace Î²] {f : Î± â†’ Î²} :\n    IsUniformInducing f â†” UniformContinuous f âˆ§\n      âˆ€ Î´ > 0, âˆƒ Îµ > 0, âˆ€ {a b : Î±}, dist (f a) (f b) < Îµ â†’ dist a b < Î´ :=\n  isUniformInducing_iff'.trans <| Iff.rfl.and <|\n    ((uniformity_basis_dist.comap _).le_basis_iff uniformity_basis_dist).trans <| by\n      simp only [subset_def, Prod.forall, gt_iff_lt, preimage_setOf_eq, Prod.map_apply, mem_setOf]\n\n"}
{"name":"Metric.uniformInducing_iff","module":"Mathlib.Topology.MetricSpace.Pseudo.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ¹ : PseudoMetricSpace Î±\ninstâœ : PseudoMetricSpace Î²\nf : Î± â†’ Î²\nâŠ¢ Iff (IsUniformInducing f) (And (UniformContinuous f) (âˆ€ (Î´ : Real), GT.gt Î´ 0 â†’ Exists fun Îµ => And (GT.gt Îµ 0) (âˆ€ {a b : Î±}, LT.lt (Dist.dist (f a) (f b)) Îµ â†’ LT.lt (Dist.dist a b) Î´)))","decl":"@[deprecated (since := \"2024-10-05\")]\nalias uniformInducing_iff := isUniformInducing_iff\n\n"}
{"name":"Metric.isUniformEmbedding_iff","module":"Mathlib.Topology.MetricSpace.Pseudo.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ¹ : PseudoMetricSpace Î±\ninstâœ : PseudoMetricSpace Î²\nf : Î± â†’ Î²\nâŠ¢ Iff (IsUniformEmbedding f) (And (Function.Injective f) (And (UniformContinuous f) (âˆ€ (Î´ : Real), GT.gt Î´ 0 â†’ Exists fun Îµ => And (GT.gt Îµ 0) (âˆ€ {a b : Î±}, LT.lt (Dist.dist (f a) (f b)) Îµ â†’ LT.lt (Dist.dist a b) Î´))))","decl":"nonrec theorem isUniformEmbedding_iff [PseudoMetricSpace Î²] {f : Î± â†’ Î²} :\n    IsUniformEmbedding f â†” Function.Injective f âˆ§ UniformContinuous f âˆ§\n      âˆ€ Î´ > 0, âˆƒ Îµ > 0, âˆ€ {a b : Î±}, dist (f a) (f b) < Îµ â†’ dist a b < Î´ := by\n  rw [isUniformEmbedding_iff, and_comm, isUniformInducing_iff]\n\n"}
{"name":"Metric.uniformEmbedding_iff","module":"Mathlib.Topology.MetricSpace.Pseudo.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ¹ : PseudoMetricSpace Î±\ninstâœ : PseudoMetricSpace Î²\nf : Î± â†’ Î²\nâŠ¢ Iff (IsUniformEmbedding f) (And (Function.Injective f) (And (UniformContinuous f) (âˆ€ (Î´ : Real), GT.gt Î´ 0 â†’ Exists fun Îµ => And (GT.gt Îµ 0) (âˆ€ {a b : Î±}, LT.lt (Dist.dist (f a) (f b)) Îµ â†’ LT.lt (Dist.dist a b) Î´))))","decl":"@[deprecated (since := \"2024-10-01\")]\nalias uniformEmbedding_iff := isUniformEmbedding_iff\n\n"}
{"name":"Metric.controlled_of_isUniformEmbedding","module":"Mathlib.Topology.MetricSpace.Pseudo.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ¹ : PseudoMetricSpace Î±\ninstâœ : PseudoMetricSpace Î²\nf : Î± â†’ Î²\nh : IsUniformEmbedding f\nâŠ¢ And (âˆ€ (Îµ : Real), GT.gt Îµ 0 â†’ Exists fun Î´ => And (GT.gt Î´ 0) (âˆ€ {a b : Î±}, LT.lt (Dist.dist a b) Î´ â†’ LT.lt (Dist.dist (f a) (f b)) Îµ)) (âˆ€ (Î´ : Real), GT.gt Î´ 0 â†’ Exists fun Îµ => And (GT.gt Îµ 0) (âˆ€ {a b : Î±}, LT.lt (Dist.dist (f a) (f b)) Îµ â†’ LT.lt (Dist.dist a b) Î´))","decl":"/-- If a map between pseudometric spaces is a uniform embedding then the distance between `f x`\nand `f y` is controlled in terms of the distance between `x` and `y`. -/\ntheorem controlled_of_isUniformEmbedding [PseudoMetricSpace Î²] {f : Î± â†’ Î²}\n    (h : IsUniformEmbedding f) :\n    (âˆ€ Îµ > 0, âˆƒ Î´ > 0, âˆ€ {a b : Î±}, dist a b < Î´ â†’ dist (f a) (f b) < Îµ) âˆ§\n      âˆ€ Î´ > 0, âˆƒ Îµ > 0, âˆ€ {a b : Î±}, dist (f a) (f b) < Îµ â†’ dist a b < Î´ :=\n  âŸ¨uniformContinuous_iff.1 h.uniformContinuous, (isUniformEmbedding_iff.1 h).2.2âŸ©\n\n"}
{"name":"Metric.controlled_of_uniformEmbedding","module":"Mathlib.Topology.MetricSpace.Pseudo.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ¹ : PseudoMetricSpace Î±\ninstâœ : PseudoMetricSpace Î²\nf : Î± â†’ Î²\nh : IsUniformEmbedding f\nâŠ¢ And (âˆ€ (Îµ : Real), GT.gt Îµ 0 â†’ Exists fun Î´ => And (GT.gt Î´ 0) (âˆ€ {a b : Î±}, LT.lt (Dist.dist a b) Î´ â†’ LT.lt (Dist.dist (f a) (f b)) Îµ)) (âˆ€ (Î´ : Real), GT.gt Î´ 0 â†’ Exists fun Îµ => And (GT.gt Îµ 0) (âˆ€ {a b : Î±}, LT.lt (Dist.dist (f a) (f b)) Îµ â†’ LT.lt (Dist.dist a b) Î´))","decl":"@[deprecated (since := \"2024-10-01\")]\nalias controlled_of_uniformEmbedding := controlled_of_isUniformEmbedding\n\n"}
{"name":"Metric.totallyBounded_iff","module":"Mathlib.Topology.MetricSpace.Pseudo.Basic","initialProofState":"Î± : Type u\ninstâœ : PseudoMetricSpace Î±\ns : Set Î±\nâŠ¢ Iff (TotallyBounded s) (âˆ€ (Îµ : Real), GT.gt Îµ 0 â†’ Exists fun t => And t.Finite (HasSubset.Subset s (Set.iUnion fun y => Set.iUnion fun h => Metric.ball y Îµ)))","decl":"theorem totallyBounded_iff {s : Set Î±} :\n    TotallyBounded s â†” âˆ€ Îµ > 0, âˆƒ t : Set Î±, t.Finite âˆ§ s âŠ† â‹ƒ y âˆˆ t, ball y Îµ :=\n  uniformity_basis_dist.totallyBounded_iff\n\n"}
{"name":"Metric.totallyBounded_of_finite_discretization","module":"Mathlib.Topology.MetricSpace.Pseudo.Basic","initialProofState":"Î± : Type u\ninstâœ : PseudoMetricSpace Î±\ns : Set Î±\nH : âˆ€ (Îµ : Real), GT.gt Îµ 0 â†’ Exists fun Î² => Exists fun x => Exists fun F => âˆ€ (x y : â†‘s), Eq (F x) (F y) â†’ LT.lt (Dist.dist â†‘x â†‘y) Îµ\nâŠ¢ TotallyBounded s","decl":"/-- A pseudometric space is totally bounded if one can reconstruct up to any Îµ>0 any element of the\nspace from finitely many data. -/\ntheorem totallyBounded_of_finite_discretization {s : Set Î±}\n    (H : âˆ€ Îµ > (0 : â„),\n        âˆƒ (Î² : Type u) (_ : Fintype Î²) (F : s â†’ Î²), âˆ€ x y, F x = F y â†’ dist (x : Î±) y < Îµ) :\n    TotallyBounded s := by\n  rcases s.eq_empty_or_nonempty with hs | hs\n  Â· rw [hs]\n    exact totallyBounded_empty\n  rcases hs with âŸ¨x0, hx0âŸ©\n  haveI : Inhabited s := âŸ¨âŸ¨x0, hx0âŸ©âŸ©\n  refine totallyBounded_iff.2 fun Îµ Îµ0 => ?_\n  rcases H Îµ Îµ0 with âŸ¨Î², fÎ², F, hFâŸ©\n  let Finv := Function.invFun F\n  refine âŸ¨range (Subtype.val âˆ˜ Finv), finite_range _, fun x xs => ?_âŸ©\n  let x' := Finv (F âŸ¨x, xsâŸ©)\n  have : F x' = F âŸ¨x, xsâŸ© := Function.invFun_eq âŸ¨âŸ¨x, xsâŸ©, rflâŸ©\n  simp only [Set.mem_iUnion, Set.mem_range]\n  exact âŸ¨_, âŸ¨F âŸ¨x, xsâŸ©, rflâŸ©, hF _ _ this.symmâŸ©\n\n"}
{"name":"Metric.finite_approx_of_totallyBounded","module":"Mathlib.Topology.MetricSpace.Pseudo.Basic","initialProofState":"Î± : Type u\ninstâœ : PseudoMetricSpace Î±\ns : Set Î±\nhs : TotallyBounded s\nÎµ : Real\naâœ : GT.gt Îµ 0\nâŠ¢ Exists fun t => And (HasSubset.Subset t s) (And t.Finite (HasSubset.Subset s (Set.iUnion fun y => Set.iUnion fun h => Metric.ball y Îµ)))","decl":"theorem finite_approx_of_totallyBounded {s : Set Î±} (hs : TotallyBounded s) :\n    âˆ€ Îµ > 0, âˆƒ t, t âŠ† s âˆ§ Set.Finite t âˆ§ s âŠ† â‹ƒ y âˆˆ t, ball y Îµ := by\n  intro Îµ Îµ_pos\n  rw [totallyBounded_iff_subset] at hs\n  exact hs _ (dist_mem_uniformity Îµ_pos)\n\n"}
{"name":"Metric.tendstoUniformlyOnFilter_iff","module":"Mathlib.Topology.MetricSpace.Pseudo.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nÎ¹ : Type u_1\ninstâœ : PseudoMetricSpace Î±\nF : Î¹ â†’ Î² â†’ Î±\nf : Î² â†’ Î±\np : Filter Î¹\np' : Filter Î²\nâŠ¢ Iff (TendstoUniformlyOnFilter F f p p') (âˆ€ (Îµ : Real), GT.gt Îµ 0 â†’ Filter.Eventually (fun n => LT.lt (Dist.dist (f n.2) (F n.1 n.2)) Îµ) (SProd.sprod p p'))","decl":"/-- Expressing uniform convergence using `dist` -/\ntheorem tendstoUniformlyOnFilter_iff {F : Î¹ â†’ Î² â†’ Î±} {f : Î² â†’ Î±} {p : Filter Î¹} {p' : Filter Î²} :\n    TendstoUniformlyOnFilter F f p p' â†”\n      âˆ€ Îµ > 0, âˆ€á¶  n : Î¹ Ã— Î² in p Ã—Ë¢ p', dist (f n.snd) (F n.fst n.snd) < Îµ := by\n  refine âŸ¨fun H Îµ hÎµ => H _ (dist_mem_uniformity hÎµ), fun H u hu => ?_âŸ©\n  rcases mem_uniformity_dist.1 hu with âŸ¨Îµ, Îµpos, hÎµâŸ©\n  exact (H Îµ Îµpos).mono fun n hn => hÎµ hn\n\n"}
{"name":"Metric.tendstoLocallyUniformlyOn_iff","module":"Mathlib.Topology.MetricSpace.Pseudo.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nÎ¹ : Type u_1\ninstâœÂ¹ : PseudoMetricSpace Î±\ninstâœ : TopologicalSpace Î²\nF : Î¹ â†’ Î² â†’ Î±\nf : Î² â†’ Î±\np : Filter Î¹\ns : Set Î²\nâŠ¢ Iff (TendstoLocallyUniformlyOn F f p s) (âˆ€ (Îµ : Real), GT.gt Îµ 0 â†’ âˆ€ (x : Î²), Membership.mem s x â†’ Exists fun t => And (Membership.mem (nhdsWithin x s) t) (Filter.Eventually (fun n => âˆ€ (y : Î²), Membership.mem t y â†’ LT.lt (Dist.dist (f y) (F n y)) Îµ) p))","decl":"/-- Expressing locally uniform convergence on a set using `dist`. -/\ntheorem tendstoLocallyUniformlyOn_iff [TopologicalSpace Î²] {F : Î¹ â†’ Î² â†’ Î±} {f : Î² â†’ Î±}\n    {p : Filter Î¹} {s : Set Î²} :\n    TendstoLocallyUniformlyOn F f p s â†”\n      âˆ€ Îµ > 0, âˆ€ x âˆˆ s, âˆƒ t âˆˆ ğ“[s] x, âˆ€á¶  n in p, âˆ€ y âˆˆ t, dist (f y) (F n y) < Îµ := by\n  refine âŸ¨fun H Îµ hÎµ => H _ (dist_mem_uniformity hÎµ), fun H u hu x hx => ?_âŸ©\n  rcases mem_uniformity_dist.1 hu with âŸ¨Îµ, Îµpos, hÎµâŸ©\n  rcases H Îµ Îµpos x hx with âŸ¨t, ht, HtâŸ©\n  exact âŸ¨t, ht, Ht.mono fun n hs x hx => hÎµ (hs x hx)âŸ©\n\n"}
{"name":"Metric.tendstoUniformlyOn_iff","module":"Mathlib.Topology.MetricSpace.Pseudo.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nÎ¹ : Type u_1\ninstâœ : PseudoMetricSpace Î±\nF : Î¹ â†’ Î² â†’ Î±\nf : Î² â†’ Î±\np : Filter Î¹\ns : Set Î²\nâŠ¢ Iff (TendstoUniformlyOn F f p s) (âˆ€ (Îµ : Real), GT.gt Îµ 0 â†’ Filter.Eventually (fun n => âˆ€ (x : Î²), Membership.mem s x â†’ LT.lt (Dist.dist (f x) (F n x)) Îµ) p)","decl":"/-- Expressing uniform convergence on a set using `dist`. -/\ntheorem tendstoUniformlyOn_iff {F : Î¹ â†’ Î² â†’ Î±} {f : Î² â†’ Î±} {p : Filter Î¹} {s : Set Î²} :\n    TendstoUniformlyOn F f p s â†” âˆ€ Îµ > 0, âˆ€á¶  n in p, âˆ€ x âˆˆ s, dist (f x) (F n x) < Îµ := by\n  refine âŸ¨fun H Îµ hÎµ => H _ (dist_mem_uniformity hÎµ), fun H u hu => ?_âŸ©\n  rcases mem_uniformity_dist.1 hu with âŸ¨Îµ, Îµpos, hÎµâŸ©\n  exact (H Îµ Îµpos).mono fun n hs x hx => hÎµ (hs x hx)\n\n"}
{"name":"Metric.tendstoLocallyUniformly_iff","module":"Mathlib.Topology.MetricSpace.Pseudo.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nÎ¹ : Type u_1\ninstâœÂ¹ : PseudoMetricSpace Î±\ninstâœ : TopologicalSpace Î²\nF : Î¹ â†’ Î² â†’ Î±\nf : Î² â†’ Î±\np : Filter Î¹\nâŠ¢ Iff (TendstoLocallyUniformly F f p) (âˆ€ (Îµ : Real), GT.gt Îµ 0 â†’ âˆ€ (x : Î²), Exists fun t => And (Membership.mem (nhds x) t) (Filter.Eventually (fun n => âˆ€ (y : Î²), Membership.mem t y â†’ LT.lt (Dist.dist (f y) (F n y)) Îµ) p))","decl":"/-- Expressing locally uniform convergence using `dist`. -/\ntheorem tendstoLocallyUniformly_iff [TopologicalSpace Î²] {F : Î¹ â†’ Î² â†’ Î±} {f : Î² â†’ Î±}\n    {p : Filter Î¹} :\n    TendstoLocallyUniformly F f p â†”\n      âˆ€ Îµ > 0, âˆ€ x : Î², âˆƒ t âˆˆ ğ“ x, âˆ€á¶  n in p, âˆ€ y âˆˆ t, dist (f y) (F n y) < Îµ := by\n  simp only [â† tendstoLocallyUniformlyOn_univ, tendstoLocallyUniformlyOn_iff, nhdsWithin_univ,\n    mem_univ, forall_const, exists_prop]\n\n"}
{"name":"Metric.tendstoUniformly_iff","module":"Mathlib.Topology.MetricSpace.Pseudo.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nÎ¹ : Type u_1\ninstâœ : PseudoMetricSpace Î±\nF : Î¹ â†’ Î² â†’ Î±\nf : Î² â†’ Î±\np : Filter Î¹\nâŠ¢ Iff (TendstoUniformly F f p) (âˆ€ (Îµ : Real), GT.gt Îµ 0 â†’ Filter.Eventually (fun n => âˆ€ (x : Î²), LT.lt (Dist.dist (f x) (F n x)) Îµ) p)","decl":"/-- Expressing uniform convergence using `dist`. -/\ntheorem tendstoUniformly_iff {F : Î¹ â†’ Î² â†’ Î±} {f : Î² â†’ Î±} {p : Filter Î¹} :\n    TendstoUniformly F f p â†” âˆ€ Îµ > 0, âˆ€á¶  n in p, âˆ€ x, dist (f x) (F n x) < Îµ := by\n  rw [â† tendstoUniformlyOn_univ, tendstoUniformlyOn_iff]\n  simp\n\n"}
{"name":"Metric.cauchy_iff","module":"Mathlib.Topology.MetricSpace.Pseudo.Basic","initialProofState":"Î± : Type u\ninstâœ : PseudoMetricSpace Î±\nf : Filter Î±\nâŠ¢ Iff (Cauchy f) (And f.NeBot (âˆ€ (Îµ : Real), GT.gt Îµ 0 â†’ Exists fun t => And (Membership.mem f t) (âˆ€ (x : Î±), Membership.mem t x â†’ âˆ€ (y : Î±), Membership.mem t y â†’ LT.lt (Dist.dist x y) Îµ)))","decl":"protected theorem cauchy_iff {f : Filter Î±} :\n    Cauchy f â†” NeBot f âˆ§ âˆ€ Îµ > 0, âˆƒ t âˆˆ f, âˆ€ x âˆˆ t, âˆ€ y âˆˆ t, dist x y < Îµ :=\n  uniformity_basis_dist.cauchy_iff\n\n"}
{"name":"Metric.exists_ball_inter_eq_singleton_of_mem_discrete","module":"Mathlib.Topology.MetricSpace.Pseudo.Basic","initialProofState":"Î± : Type u\ninstâœÂ¹ : PseudoMetricSpace Î±\ns : Set Î±\ninstâœ : DiscreteTopology â†‘s\nx : Î±\nhx : Membership.mem s x\nâŠ¢ Exists fun Îµ => And (GT.gt Îµ 0) (Eq (Inter.inter (Metric.ball x Îµ) s) (Singleton.singleton x))","decl":"/-- Given a point `x` in a discrete subset `s` of a pseudometric space, there is an open ball\ncentered at `x` and intersecting `s` only at `x`. -/\ntheorem exists_ball_inter_eq_singleton_of_mem_discrete [DiscreteTopology s] {x : Î±} (hx : x âˆˆ s) :\n    âˆƒ Îµ > 0, Metric.ball x Îµ âˆ© s = {x} :=\n  nhds_basis_ball.exists_inter_eq_singleton_of_mem_discrete hx\n\n"}
{"name":"Metric.exists_closedBall_inter_eq_singleton_of_discrete","module":"Mathlib.Topology.MetricSpace.Pseudo.Basic","initialProofState":"Î± : Type u\ninstâœÂ¹ : PseudoMetricSpace Î±\ns : Set Î±\ninstâœ : DiscreteTopology â†‘s\nx : Î±\nhx : Membership.mem s x\nâŠ¢ Exists fun Îµ => And (GT.gt Îµ 0) (Eq (Inter.inter (Metric.closedBall x Îµ) s) (Singleton.singleton x))","decl":"/-- Given a point `x` in a discrete subset `s` of a pseudometric space, there is a closed ball\nof positive radius centered at `x` and intersecting `s` only at `x`. -/\ntheorem exists_closedBall_inter_eq_singleton_of_discrete [DiscreteTopology s] {x : Î±} (hx : x âˆˆ s) :\n    âˆƒ Îµ > 0, Metric.closedBall x Îµ âˆ© s = {x} :=\n  nhds_basis_closedBall.exists_inter_eq_singleton_of_mem_discrete hx\n\n"}
{"name":"Metric.inseparable_iff_nndist","module":"Mathlib.Topology.MetricSpace.Pseudo.Basic","initialProofState":"Î± : Type u\ninstâœ : PseudoMetricSpace Î±\nx y : Î±\nâŠ¢ Iff (Inseparable x y) (Eq (NNDist.nndist x y) 0)","decl":"theorem Metric.inseparable_iff_nndist {x y : Î±} : Inseparable x y â†” nndist x y = 0 := by\n  rw [EMetric.inseparable_iff, edist_nndist, ENNReal.coe_eq_zero]\n\n"}
{"name":"Inseparable.nndist_eq_zero","module":"Mathlib.Topology.MetricSpace.Pseudo.Basic","initialProofState":"Î± : Type u\ninstâœ : PseudoMetricSpace Î±\nx y : Î±\naâœ : Inseparable x y\nâŠ¢ Eq (NNDist.nndist x y) 0","decl":"alias âŸ¨Inseparable.nndist_eq_zero, _âŸ© := Metric.inseparable_iff_nndist\n\n"}
{"name":"Metric.inseparable_iff","module":"Mathlib.Topology.MetricSpace.Pseudo.Basic","initialProofState":"Î± : Type u\ninstâœ : PseudoMetricSpace Î±\nx y : Î±\nâŠ¢ Iff (Inseparable x y) (Eq (Dist.dist x y) 0)","decl":"theorem Metric.inseparable_iff {x y : Î±} : Inseparable x y â†” dist x y = 0 := by\n  rw [Metric.inseparable_iff_nndist, dist_nndist, NNReal.coe_eq_zero]\n\n"}
{"name":"Inseparable.dist_eq_zero","module":"Mathlib.Topology.MetricSpace.Pseudo.Basic","initialProofState":"Î± : Type u\ninstâœ : PseudoMetricSpace Î±\nx y : Î±\naâœ : Inseparable x y\nâŠ¢ Eq (Dist.dist x y) 0","decl":"alias âŸ¨Inseparable.dist_eq_zero, _âŸ© := Metric.inseparable_iff\n\n"}
{"name":"tendsto_nhds_unique_dist","module":"Mathlib.Topology.MetricSpace.Pseudo.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ¹ : PseudoMetricSpace Î±\nf : Î² â†’ Î±\nl : Filter Î²\nx y : Î±\ninstâœ : l.NeBot\nha : Filter.Tendsto f l (nhds x)\nhb : Filter.Tendsto f l (nhds y)\nâŠ¢ Eq (Dist.dist x y) 0","decl":"/-- A weaker version of `tendsto_nhds_unique` for `PseudoMetricSpace`. -/\ntheorem tendsto_nhds_unique_dist {f : Î² â†’ Î±} {l : Filter Î²} {x y : Î±} [NeBot l]\n    (ha : Tendsto f l (ğ“ x)) (hb : Tendsto f l (ğ“ y)) : dist x y = 0 :=\n  (tendsto_nhds_unique_inseparable ha hb).dist_eq_zero\n\n"}
{"name":"cauchySeq_iff_tendsto_dist_atTop_0","module":"Mathlib.Topology.MetricSpace.Pseudo.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ² : PseudoMetricSpace Î±\ninstâœÂ¹ : Nonempty Î²\ninstâœ : SemilatticeSup Î²\nu : Î² â†’ Î±\nâŠ¢ Iff (CauchySeq u) (Filter.Tendsto (fun n => Dist.dist (u n.1) (u n.2)) Filter.atTop (nhds 0))","decl":"theorem cauchySeq_iff_tendsto_dist_atTop_0 [Nonempty Î²] [SemilatticeSup Î²] {u : Î² â†’ Î±} :\n    CauchySeq u â†” Tendsto (fun n : Î² Ã— Î² => dist (u n.1) (u n.2)) atTop (ğ“ 0) := by\n  rw [cauchySeq_iff_tendsto, Metric.uniformity_eq_comap_nhds_zero, tendsto_comap_iff,\n    Function.comp_def]\n  simp_rw [Prod.map_fst, Prod.map_snd]\n\n"}
{"name":"Topology.IsInducing.isSeparable_preimage","module":"Mathlib.Topology.MetricSpace.Pseudo.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ¹ : PseudoMetricSpace Î±\nf : Î² â†’ Î±\ninstâœ : TopologicalSpace Î²\nhf : Topology.IsInducing f\ns : Set Î±\nhs : TopologicalSpace.IsSeparable s\nâŠ¢ TopologicalSpace.IsSeparable (Set.preimage f s)","decl":"/-- The preimage of a separable set by an inducing map is separable. -/\nprotected lemma IsInducing.isSeparable_preimage {f : Î² â†’ Î±} [TopologicalSpace Î²]\n    (hf : IsInducing f) {s : Set Î±} (hs : IsSeparable s) : IsSeparable (f â»Â¹' s) := by\n  have : SeparableSpace s := hs.separableSpace\n  have : SecondCountableTopology s := UniformSpace.secondCountable_of_separable _\n  have : IsInducing ((mapsTo_preimage f s).restrict _ _ _) :=\n    (hf.comp IsInducing.subtypeVal).codRestrict _\n  have := this.secondCountableTopology\n  exact .of_subtype _\n\n"}
{"name":"Inducing.isSeparable_preimage","module":"Mathlib.Topology.MetricSpace.Pseudo.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ¹ : PseudoMetricSpace Î±\nf : Î² â†’ Î±\ninstâœ : TopologicalSpace Î²\nhf : Topology.IsInducing f\ns : Set Î±\nhs : TopologicalSpace.IsSeparable s\nâŠ¢ TopologicalSpace.IsSeparable (Set.preimage f s)","decl":"@[deprecated (since := \"2024-10-28\")]\nalias _root_.Inducing.isSeparable_preimage := IsInducing.isSeparable_preimage\n\n"}
{"name":"Topology.IsEmbedding.isSeparable_preimage","module":"Mathlib.Topology.MetricSpace.Pseudo.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ¹ : PseudoMetricSpace Î±\nf : Î² â†’ Î±\ninstâœ : TopologicalSpace Î²\nhf : Topology.IsEmbedding f\ns : Set Î±\nhs : TopologicalSpace.IsSeparable s\nâŠ¢ TopologicalSpace.IsSeparable (Set.preimage f s)","decl":"protected theorem IsEmbedding.isSeparable_preimage {f : Î² â†’ Î±} [TopologicalSpace Î²]\n    (hf : IsEmbedding f) {s : Set Î±} (hs : IsSeparable s) : IsSeparable (f â»Â¹' s) :=\n  hf.isInducing.isSeparable_preimage hs\n\n"}
{"name":"Embedding.isSeparable_preimage","module":"Mathlib.Topology.MetricSpace.Pseudo.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ¹ : PseudoMetricSpace Î±\nf : Î² â†’ Î±\ninstâœ : TopologicalSpace Î²\nhf : Topology.IsEmbedding f\ns : Set Î±\nhs : TopologicalSpace.IsSeparable s\nâŠ¢ TopologicalSpace.IsSeparable (Set.preimage f s)","decl":"@[deprecated (since := \"2024-10-26\")]\nalias _root_.Embedding.isSeparable_preimage := IsEmbedding.isSeparable_preimage\n\n"}
{"name":"IsCompact.isSeparable","module":"Mathlib.Topology.MetricSpace.Pseudo.Basic","initialProofState":"Î± : Type u\ninstâœ : PseudoMetricSpace Î±\ns : Set Î±\nhs : IsCompact s\nâŠ¢ TopologicalSpace.IsSeparable s","decl":"/-- A compact set is separable. -/\ntheorem IsCompact.isSeparable {s : Set Î±} (hs : IsCompact s) : IsSeparable s :=\n  haveI : CompactSpace s := isCompact_iff_compactSpace.mp hs\n  .of_subtype s\n\n"}
{"name":"Metric.secondCountable_of_almost_dense_set","module":"Mathlib.Topology.MetricSpace.Pseudo.Basic","initialProofState":"Î± : Type u\ninstâœ : PseudoMetricSpace Î±\nH : âˆ€ (Îµ : Real), GT.gt Îµ 0 â†’ Exists fun s => And s.Countable (âˆ€ (x : Î±), Exists fun y => And (Membership.mem s y) (LE.le (Dist.dist x y) Îµ))\nâŠ¢ SecondCountableTopology Î±","decl":"/-- A pseudometric space is second countable if, for every `Îµ > 0`, there is a countable set which\nis `Îµ`-dense. -/\ntheorem secondCountable_of_almost_dense_set\n    (H : âˆ€ Îµ > (0 : â„), âˆƒ s : Set Î±, s.Countable âˆ§ âˆ€ x, âˆƒ y âˆˆ s, dist x y â‰¤ Îµ) :\n    SecondCountableTopology Î± := by\n  refine EMetric.secondCountable_of_almost_dense_set fun Îµ Îµ0 => ?_\n  rcases ENNReal.lt_iff_exists_nnreal_btwn.1 Îµ0 with âŸ¨Îµ', Îµ'0, Îµ'ÎµâŸ©\n  choose s hsc y hys hyx using H Îµ' (mod_cast Îµ'0)\n  refine âŸ¨s, hsc, iUnionâ‚‚_eq_univ_iff.2 fun x => âŸ¨y x, hys _, le_trans ?_ Îµ'Îµ.leâŸ©âŸ©\n  exact mod_cast hyx x\n\n"}
