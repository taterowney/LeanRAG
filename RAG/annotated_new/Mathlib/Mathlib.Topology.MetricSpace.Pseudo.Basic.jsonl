{"name":"dist_le_Ico_sum_dist","module":"Mathlib.Topology.MetricSpace.Pseudo.Basic","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\nf : Nat → α\nm n : Nat\nh : LE.le m n\n⊢ LE.le (Dist.dist (f m) (f n)) ((Finset.Ico m n).sum fun i => Dist.dist (f i) (f (HAdd.hAdd i 1)))","decl":"/-- The triangle (polygon) inequality for sequences of points; `Finset.Ico` version. -/\ntheorem dist_le_Ico_sum_dist (f : ℕ → α) {m n} (h : m ≤ n) :\n    dist (f m) (f n) ≤ ∑ i ∈ Finset.Ico m n, dist (f i) (f (i + 1)) := by\n  induction n, h using Nat.le_induction with\n  | base => rw [Finset.Ico_self, Finset.sum_empty, dist_self]\n  | succ n hle ihn =>\n    calc\n      dist (f m) (f (n + 1)) ≤ dist (f m) (f n) + dist (f n) (f (n + 1)) := dist_triangle _ _ _\n      _ ≤ (∑ i ∈ Finset.Ico m n, _) + _ := add_le_add ihn le_rfl\n      _ = ∑ i ∈ Finset.Ico m (n + 1), _ := by\n      { rw [Nat.Ico_succ_right_eq_insert_Ico hle, Finset.sum_insert, add_comm]; simp }\n\n"}
{"name":"dist_le_range_sum_dist","module":"Mathlib.Topology.MetricSpace.Pseudo.Basic","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\nf : Nat → α\nn : Nat\n⊢ LE.le (Dist.dist (f 0) (f n)) ((Finset.range n).sum fun i => Dist.dist (f i) (f (HAdd.hAdd i 1)))","decl":"/-- The triangle (polygon) inequality for sequences of points; `Finset.range` version. -/\ntheorem dist_le_range_sum_dist (f : ℕ → α) (n : ℕ) :\n    dist (f 0) (f n) ≤ ∑ i ∈ Finset.range n, dist (f i) (f (i + 1)) :=\n  Nat.Ico_zero_eq_range ▸ dist_le_Ico_sum_dist f (Nat.zero_le n)\n\n"}
{"name":"dist_le_Ico_sum_of_dist_le","module":"Mathlib.Topology.MetricSpace.Pseudo.Basic","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\nf : Nat → α\nm n : Nat\nhmn : LE.le m n\nd : Nat → Real\nhd : ∀ {k : Nat}, LE.le m k → LT.lt k n → LE.le (Dist.dist (f k) (f (HAdd.hAdd k 1))) (d k)\n⊢ LE.le (Dist.dist (f m) (f n)) ((Finset.Ico m n).sum fun i => d i)","decl":"/-- A version of `dist_le_Ico_sum_dist` with each intermediate distance replaced\nwith an upper estimate. -/\ntheorem dist_le_Ico_sum_of_dist_le {f : ℕ → α} {m n} (hmn : m ≤ n) {d : ℕ → ℝ}\n    (hd : ∀ {k}, m ≤ k → k < n → dist (f k) (f (k + 1)) ≤ d k) :\n    dist (f m) (f n) ≤ ∑ i ∈ Finset.Ico m n, d i :=\n  le_trans (dist_le_Ico_sum_dist f hmn) <|\n    Finset.sum_le_sum fun _k hk => hd (Finset.mem_Ico.1 hk).1 (Finset.mem_Ico.1 hk).2\n\n"}
{"name":"dist_le_range_sum_of_dist_le","module":"Mathlib.Topology.MetricSpace.Pseudo.Basic","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\nf : Nat → α\nn : Nat\nd : Nat → Real\nhd : ∀ {k : Nat}, LT.lt k n → LE.le (Dist.dist (f k) (f (HAdd.hAdd k 1))) (d k)\n⊢ LE.le (Dist.dist (f 0) (f n)) ((Finset.range n).sum fun i => d i)","decl":"/-- A version of `dist_le_range_sum_dist` with each intermediate distance replaced\nwith an upper estimate. -/\ntheorem dist_le_range_sum_of_dist_le {f : ℕ → α} (n : ℕ) {d : ℕ → ℝ}\n    (hd : ∀ {k}, k < n → dist (f k) (f (k + 1)) ≤ d k) :\n    dist (f 0) (f n) ≤ ∑ i ∈ Finset.range n, d i :=\n  Nat.Ico_zero_eq_range ▸ dist_le_Ico_sum_of_dist_le (zero_le n) fun _ => hd\n\n"}
{"name":"Metric.isUniformInducing_iff","module":"Mathlib.Topology.MetricSpace.Pseudo.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : PseudoMetricSpace α\ninst✝ : PseudoMetricSpace β\nf : α → β\n⊢ Iff (IsUniformInducing f) (And (UniformContinuous f) (∀ (δ : Real), GT.gt δ 0 → Exists fun ε => And (GT.gt ε 0) (∀ {a b : α}, LT.lt (Dist.dist (f a) (f b)) ε → LT.lt (Dist.dist a b) δ)))","decl":"nonrec theorem isUniformInducing_iff [PseudoMetricSpace β] {f : α → β} :\n    IsUniformInducing f ↔ UniformContinuous f ∧\n      ∀ δ > 0, ∃ ε > 0, ∀ {a b : α}, dist (f a) (f b) < ε → dist a b < δ :=\n  isUniformInducing_iff'.trans <| Iff.rfl.and <|\n    ((uniformity_basis_dist.comap _).le_basis_iff uniformity_basis_dist).trans <| by\n      simp only [subset_def, Prod.forall, gt_iff_lt, preimage_setOf_eq, Prod.map_apply, mem_setOf]\n\n"}
{"name":"Metric.uniformInducing_iff","module":"Mathlib.Topology.MetricSpace.Pseudo.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : PseudoMetricSpace α\ninst✝ : PseudoMetricSpace β\nf : α → β\n⊢ Iff (IsUniformInducing f) (And (UniformContinuous f) (∀ (δ : Real), GT.gt δ 0 → Exists fun ε => And (GT.gt ε 0) (∀ {a b : α}, LT.lt (Dist.dist (f a) (f b)) ε → LT.lt (Dist.dist a b) δ)))","decl":"@[deprecated (since := \"2024-10-05\")]\nalias uniformInducing_iff := isUniformInducing_iff\n\n"}
{"name":"Metric.isUniformEmbedding_iff","module":"Mathlib.Topology.MetricSpace.Pseudo.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : PseudoMetricSpace α\ninst✝ : PseudoMetricSpace β\nf : α → β\n⊢ Iff (IsUniformEmbedding f) (And (Function.Injective f) (And (UniformContinuous f) (∀ (δ : Real), GT.gt δ 0 → Exists fun ε => And (GT.gt ε 0) (∀ {a b : α}, LT.lt (Dist.dist (f a) (f b)) ε → LT.lt (Dist.dist a b) δ))))","decl":"nonrec theorem isUniformEmbedding_iff [PseudoMetricSpace β] {f : α → β} :\n    IsUniformEmbedding f ↔ Function.Injective f ∧ UniformContinuous f ∧\n      ∀ δ > 0, ∃ ε > 0, ∀ {a b : α}, dist (f a) (f b) < ε → dist a b < δ := by\n  rw [isUniformEmbedding_iff, and_comm, isUniformInducing_iff]\n\n"}
{"name":"Metric.uniformEmbedding_iff","module":"Mathlib.Topology.MetricSpace.Pseudo.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : PseudoMetricSpace α\ninst✝ : PseudoMetricSpace β\nf : α → β\n⊢ Iff (IsUniformEmbedding f) (And (Function.Injective f) (And (UniformContinuous f) (∀ (δ : Real), GT.gt δ 0 → Exists fun ε => And (GT.gt ε 0) (∀ {a b : α}, LT.lt (Dist.dist (f a) (f b)) ε → LT.lt (Dist.dist a b) δ))))","decl":"@[deprecated (since := \"2024-10-01\")]\nalias uniformEmbedding_iff := isUniformEmbedding_iff\n\n"}
{"name":"Metric.controlled_of_isUniformEmbedding","module":"Mathlib.Topology.MetricSpace.Pseudo.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : PseudoMetricSpace α\ninst✝ : PseudoMetricSpace β\nf : α → β\nh : IsUniformEmbedding f\n⊢ And (∀ (ε : Real), GT.gt ε 0 → Exists fun δ => And (GT.gt δ 0) (∀ {a b : α}, LT.lt (Dist.dist a b) δ → LT.lt (Dist.dist (f a) (f b)) ε)) (∀ (δ : Real), GT.gt δ 0 → Exists fun ε => And (GT.gt ε 0) (∀ {a b : α}, LT.lt (Dist.dist (f a) (f b)) ε → LT.lt (Dist.dist a b) δ))","decl":"/-- If a map between pseudometric spaces is a uniform embedding then the distance between `f x`\nand `f y` is controlled in terms of the distance between `x` and `y`. -/\ntheorem controlled_of_isUniformEmbedding [PseudoMetricSpace β] {f : α → β}\n    (h : IsUniformEmbedding f) :\n    (∀ ε > 0, ∃ δ > 0, ∀ {a b : α}, dist a b < δ → dist (f a) (f b) < ε) ∧\n      ∀ δ > 0, ∃ ε > 0, ∀ {a b : α}, dist (f a) (f b) < ε → dist a b < δ :=\n  ⟨uniformContinuous_iff.1 h.uniformContinuous, (isUniformEmbedding_iff.1 h).2.2⟩\n\n"}
{"name":"Metric.controlled_of_uniformEmbedding","module":"Mathlib.Topology.MetricSpace.Pseudo.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : PseudoMetricSpace α\ninst✝ : PseudoMetricSpace β\nf : α → β\nh : IsUniformEmbedding f\n⊢ And (∀ (ε : Real), GT.gt ε 0 → Exists fun δ => And (GT.gt δ 0) (∀ {a b : α}, LT.lt (Dist.dist a b) δ → LT.lt (Dist.dist (f a) (f b)) ε)) (∀ (δ : Real), GT.gt δ 0 → Exists fun ε => And (GT.gt ε 0) (∀ {a b : α}, LT.lt (Dist.dist (f a) (f b)) ε → LT.lt (Dist.dist a b) δ))","decl":"@[deprecated (since := \"2024-10-01\")]\nalias controlled_of_uniformEmbedding := controlled_of_isUniformEmbedding\n\n"}
{"name":"Metric.totallyBounded_iff","module":"Mathlib.Topology.MetricSpace.Pseudo.Basic","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\ns : Set α\n⊢ Iff (TotallyBounded s) (∀ (ε : Real), GT.gt ε 0 → Exists fun t => And t.Finite (HasSubset.Subset s (Set.iUnion fun y => Set.iUnion fun h => Metric.ball y ε)))","decl":"theorem totallyBounded_iff {s : Set α} :\n    TotallyBounded s ↔ ∀ ε > 0, ∃ t : Set α, t.Finite ∧ s ⊆ ⋃ y ∈ t, ball y ε :=\n  uniformity_basis_dist.totallyBounded_iff\n\n"}
{"name":"Metric.totallyBounded_of_finite_discretization","module":"Mathlib.Topology.MetricSpace.Pseudo.Basic","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\ns : Set α\nH : ∀ (ε : Real), GT.gt ε 0 → Exists fun β => Exists fun x => Exists fun F => ∀ (x y : ↑s), Eq (F x) (F y) → LT.lt (Dist.dist ↑x ↑y) ε\n⊢ TotallyBounded s","decl":"/-- A pseudometric space is totally bounded if one can reconstruct up to any ε>0 any element of the\nspace from finitely many data. -/\ntheorem totallyBounded_of_finite_discretization {s : Set α}\n    (H : ∀ ε > (0 : ℝ),\n        ∃ (β : Type u) (_ : Fintype β) (F : s → β), ∀ x y, F x = F y → dist (x : α) y < ε) :\n    TotallyBounded s := by\n  rcases s.eq_empty_or_nonempty with hs | hs\n  · rw [hs]\n    exact totallyBounded_empty\n  rcases hs with ⟨x0, hx0⟩\n  haveI : Inhabited s := ⟨⟨x0, hx0⟩⟩\n  refine totallyBounded_iff.2 fun ε ε0 => ?_\n  rcases H ε ε0 with ⟨β, fβ, F, hF⟩\n  let Finv := Function.invFun F\n  refine ⟨range (Subtype.val ∘ Finv), finite_range _, fun x xs => ?_⟩\n  let x' := Finv (F ⟨x, xs⟩)\n  have : F x' = F ⟨x, xs⟩ := Function.invFun_eq ⟨⟨x, xs⟩, rfl⟩\n  simp only [Set.mem_iUnion, Set.mem_range]\n  exact ⟨_, ⟨F ⟨x, xs⟩, rfl⟩, hF _ _ this.symm⟩\n\n"}
{"name":"Metric.finite_approx_of_totallyBounded","module":"Mathlib.Topology.MetricSpace.Pseudo.Basic","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\ns : Set α\nhs : TotallyBounded s\nε : Real\na✝ : GT.gt ε 0\n⊢ Exists fun t => And (HasSubset.Subset t s) (And t.Finite (HasSubset.Subset s (Set.iUnion fun y => Set.iUnion fun h => Metric.ball y ε)))","decl":"theorem finite_approx_of_totallyBounded {s : Set α} (hs : TotallyBounded s) :\n    ∀ ε > 0, ∃ t, t ⊆ s ∧ Set.Finite t ∧ s ⊆ ⋃ y ∈ t, ball y ε := by\n  intro ε ε_pos\n  rw [totallyBounded_iff_subset] at hs\n  exact hs _ (dist_mem_uniformity ε_pos)\n\n"}
{"name":"Metric.tendstoUniformlyOnFilter_iff","module":"Mathlib.Topology.MetricSpace.Pseudo.Basic","initialProofState":"α : Type u\nβ : Type v\nι : Type u_1\ninst✝ : PseudoMetricSpace α\nF : ι → β → α\nf : β → α\np : Filter ι\np' : Filter β\n⊢ Iff (TendstoUniformlyOnFilter F f p p') (∀ (ε : Real), GT.gt ε 0 → Filter.Eventually (fun n => LT.lt (Dist.dist (f n.2) (F n.1 n.2)) ε) (SProd.sprod p p'))","decl":"/-- Expressing uniform convergence using `dist` -/\ntheorem tendstoUniformlyOnFilter_iff {F : ι → β → α} {f : β → α} {p : Filter ι} {p' : Filter β} :\n    TendstoUniformlyOnFilter F f p p' ↔\n      ∀ ε > 0, ∀ᶠ n : ι × β in p ×ˢ p', dist (f n.snd) (F n.fst n.snd) < ε := by\n  refine ⟨fun H ε hε => H _ (dist_mem_uniformity hε), fun H u hu => ?_⟩\n  rcases mem_uniformity_dist.1 hu with ⟨ε, εpos, hε⟩\n  exact (H ε εpos).mono fun n hn => hε hn\n\n"}
{"name":"Metric.tendstoLocallyUniformlyOn_iff","module":"Mathlib.Topology.MetricSpace.Pseudo.Basic","initialProofState":"α : Type u\nβ : Type v\nι : Type u_1\ninst✝¹ : PseudoMetricSpace α\ninst✝ : TopologicalSpace β\nF : ι → β → α\nf : β → α\np : Filter ι\ns : Set β\n⊢ Iff (TendstoLocallyUniformlyOn F f p s) (∀ (ε : Real), GT.gt ε 0 → ∀ (x : β), Membership.mem s x → Exists fun t => And (Membership.mem (nhdsWithin x s) t) (Filter.Eventually (fun n => ∀ (y : β), Membership.mem t y → LT.lt (Dist.dist (f y) (F n y)) ε) p))","decl":"/-- Expressing locally uniform convergence on a set using `dist`. -/\ntheorem tendstoLocallyUniformlyOn_iff [TopologicalSpace β] {F : ι → β → α} {f : β → α}\n    {p : Filter ι} {s : Set β} :\n    TendstoLocallyUniformlyOn F f p s ↔\n      ∀ ε > 0, ∀ x ∈ s, ∃ t ∈ 𝓝[s] x, ∀ᶠ n in p, ∀ y ∈ t, dist (f y) (F n y) < ε := by\n  refine ⟨fun H ε hε => H _ (dist_mem_uniformity hε), fun H u hu x hx => ?_⟩\n  rcases mem_uniformity_dist.1 hu with ⟨ε, εpos, hε⟩\n  rcases H ε εpos x hx with ⟨t, ht, Ht⟩\n  exact ⟨t, ht, Ht.mono fun n hs x hx => hε (hs x hx)⟩\n\n"}
{"name":"Metric.tendstoUniformlyOn_iff","module":"Mathlib.Topology.MetricSpace.Pseudo.Basic","initialProofState":"α : Type u\nβ : Type v\nι : Type u_1\ninst✝ : PseudoMetricSpace α\nF : ι → β → α\nf : β → α\np : Filter ι\ns : Set β\n⊢ Iff (TendstoUniformlyOn F f p s) (∀ (ε : Real), GT.gt ε 0 → Filter.Eventually (fun n => ∀ (x : β), Membership.mem s x → LT.lt (Dist.dist (f x) (F n x)) ε) p)","decl":"/-- Expressing uniform convergence on a set using `dist`. -/\ntheorem tendstoUniformlyOn_iff {F : ι → β → α} {f : β → α} {p : Filter ι} {s : Set β} :\n    TendstoUniformlyOn F f p s ↔ ∀ ε > 0, ∀ᶠ n in p, ∀ x ∈ s, dist (f x) (F n x) < ε := by\n  refine ⟨fun H ε hε => H _ (dist_mem_uniformity hε), fun H u hu => ?_⟩\n  rcases mem_uniformity_dist.1 hu with ⟨ε, εpos, hε⟩\n  exact (H ε εpos).mono fun n hs x hx => hε (hs x hx)\n\n"}
{"name":"Metric.tendstoLocallyUniformly_iff","module":"Mathlib.Topology.MetricSpace.Pseudo.Basic","initialProofState":"α : Type u\nβ : Type v\nι : Type u_1\ninst✝¹ : PseudoMetricSpace α\ninst✝ : TopologicalSpace β\nF : ι → β → α\nf : β → α\np : Filter ι\n⊢ Iff (TendstoLocallyUniformly F f p) (∀ (ε : Real), GT.gt ε 0 → ∀ (x : β), Exists fun t => And (Membership.mem (nhds x) t) (Filter.Eventually (fun n => ∀ (y : β), Membership.mem t y → LT.lt (Dist.dist (f y) (F n y)) ε) p))","decl":"/-- Expressing locally uniform convergence using `dist`. -/\ntheorem tendstoLocallyUniformly_iff [TopologicalSpace β] {F : ι → β → α} {f : β → α}\n    {p : Filter ι} :\n    TendstoLocallyUniformly F f p ↔\n      ∀ ε > 0, ∀ x : β, ∃ t ∈ 𝓝 x, ∀ᶠ n in p, ∀ y ∈ t, dist (f y) (F n y) < ε := by\n  simp only [← tendstoLocallyUniformlyOn_univ, tendstoLocallyUniformlyOn_iff, nhdsWithin_univ,\n    mem_univ, forall_const, exists_prop]\n\n"}
{"name":"Metric.tendstoUniformly_iff","module":"Mathlib.Topology.MetricSpace.Pseudo.Basic","initialProofState":"α : Type u\nβ : Type v\nι : Type u_1\ninst✝ : PseudoMetricSpace α\nF : ι → β → α\nf : β → α\np : Filter ι\n⊢ Iff (TendstoUniformly F f p) (∀ (ε : Real), GT.gt ε 0 → Filter.Eventually (fun n => ∀ (x : β), LT.lt (Dist.dist (f x) (F n x)) ε) p)","decl":"/-- Expressing uniform convergence using `dist`. -/\ntheorem tendstoUniformly_iff {F : ι → β → α} {f : β → α} {p : Filter ι} :\n    TendstoUniformly F f p ↔ ∀ ε > 0, ∀ᶠ n in p, ∀ x, dist (f x) (F n x) < ε := by\n  rw [← tendstoUniformlyOn_univ, tendstoUniformlyOn_iff]\n  simp\n\n"}
{"name":"Metric.cauchy_iff","module":"Mathlib.Topology.MetricSpace.Pseudo.Basic","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\nf : Filter α\n⊢ Iff (Cauchy f) (And f.NeBot (∀ (ε : Real), GT.gt ε 0 → Exists fun t => And (Membership.mem f t) (∀ (x : α), Membership.mem t x → ∀ (y : α), Membership.mem t y → LT.lt (Dist.dist x y) ε)))","decl":"protected theorem cauchy_iff {f : Filter α} :\n    Cauchy f ↔ NeBot f ∧ ∀ ε > 0, ∃ t ∈ f, ∀ x ∈ t, ∀ y ∈ t, dist x y < ε :=\n  uniformity_basis_dist.cauchy_iff\n\n"}
{"name":"Metric.exists_ball_inter_eq_singleton_of_mem_discrete","module":"Mathlib.Topology.MetricSpace.Pseudo.Basic","initialProofState":"α : Type u\ninst✝¹ : PseudoMetricSpace α\ns : Set α\ninst✝ : DiscreteTopology ↑s\nx : α\nhx : Membership.mem s x\n⊢ Exists fun ε => And (GT.gt ε 0) (Eq (Inter.inter (Metric.ball x ε) s) (Singleton.singleton x))","decl":"/-- Given a point `x` in a discrete subset `s` of a pseudometric space, there is an open ball\ncentered at `x` and intersecting `s` only at `x`. -/\ntheorem exists_ball_inter_eq_singleton_of_mem_discrete [DiscreteTopology s] {x : α} (hx : x ∈ s) :\n    ∃ ε > 0, Metric.ball x ε ∩ s = {x} :=\n  nhds_basis_ball.exists_inter_eq_singleton_of_mem_discrete hx\n\n"}
{"name":"Metric.exists_closedBall_inter_eq_singleton_of_discrete","module":"Mathlib.Topology.MetricSpace.Pseudo.Basic","initialProofState":"α : Type u\ninst✝¹ : PseudoMetricSpace α\ns : Set α\ninst✝ : DiscreteTopology ↑s\nx : α\nhx : Membership.mem s x\n⊢ Exists fun ε => And (GT.gt ε 0) (Eq (Inter.inter (Metric.closedBall x ε) s) (Singleton.singleton x))","decl":"/-- Given a point `x` in a discrete subset `s` of a pseudometric space, there is a closed ball\nof positive radius centered at `x` and intersecting `s` only at `x`. -/\ntheorem exists_closedBall_inter_eq_singleton_of_discrete [DiscreteTopology s] {x : α} (hx : x ∈ s) :\n    ∃ ε > 0, Metric.closedBall x ε ∩ s = {x} :=\n  nhds_basis_closedBall.exists_inter_eq_singleton_of_mem_discrete hx\n\n"}
{"name":"Metric.inseparable_iff_nndist","module":"Mathlib.Topology.MetricSpace.Pseudo.Basic","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\nx y : α\n⊢ Iff (Inseparable x y) (Eq (NNDist.nndist x y) 0)","decl":"theorem Metric.inseparable_iff_nndist {x y : α} : Inseparable x y ↔ nndist x y = 0 := by\n  rw [EMetric.inseparable_iff, edist_nndist, ENNReal.coe_eq_zero]\n\n"}
{"name":"Inseparable.nndist_eq_zero","module":"Mathlib.Topology.MetricSpace.Pseudo.Basic","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\nx y : α\na✝ : Inseparable x y\n⊢ Eq (NNDist.nndist x y) 0","decl":"alias ⟨Inseparable.nndist_eq_zero, _⟩ := Metric.inseparable_iff_nndist\n\n"}
{"name":"Metric.inseparable_iff","module":"Mathlib.Topology.MetricSpace.Pseudo.Basic","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\nx y : α\n⊢ Iff (Inseparable x y) (Eq (Dist.dist x y) 0)","decl":"theorem Metric.inseparable_iff {x y : α} : Inseparable x y ↔ dist x y = 0 := by\n  rw [Metric.inseparable_iff_nndist, dist_nndist, NNReal.coe_eq_zero]\n\n"}
{"name":"Inseparable.dist_eq_zero","module":"Mathlib.Topology.MetricSpace.Pseudo.Basic","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\nx y : α\na✝ : Inseparable x y\n⊢ Eq (Dist.dist x y) 0","decl":"alias ⟨Inseparable.dist_eq_zero, _⟩ := Metric.inseparable_iff\n\n"}
{"name":"tendsto_nhds_unique_dist","module":"Mathlib.Topology.MetricSpace.Pseudo.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : PseudoMetricSpace α\nf : β → α\nl : Filter β\nx y : α\ninst✝ : l.NeBot\nha : Filter.Tendsto f l (nhds x)\nhb : Filter.Tendsto f l (nhds y)\n⊢ Eq (Dist.dist x y) 0","decl":"/-- A weaker version of `tendsto_nhds_unique` for `PseudoMetricSpace`. -/\ntheorem tendsto_nhds_unique_dist {f : β → α} {l : Filter β} {x y : α} [NeBot l]\n    (ha : Tendsto f l (𝓝 x)) (hb : Tendsto f l (𝓝 y)) : dist x y = 0 :=\n  (tendsto_nhds_unique_inseparable ha hb).dist_eq_zero\n\n"}
{"name":"cauchySeq_iff_tendsto_dist_atTop_0","module":"Mathlib.Topology.MetricSpace.Pseudo.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝² : PseudoMetricSpace α\ninst✝¹ : Nonempty β\ninst✝ : SemilatticeSup β\nu : β → α\n⊢ Iff (CauchySeq u) (Filter.Tendsto (fun n => Dist.dist (u n.1) (u n.2)) Filter.atTop (nhds 0))","decl":"theorem cauchySeq_iff_tendsto_dist_atTop_0 [Nonempty β] [SemilatticeSup β] {u : β → α} :\n    CauchySeq u ↔ Tendsto (fun n : β × β => dist (u n.1) (u n.2)) atTop (𝓝 0) := by\n  rw [cauchySeq_iff_tendsto, Metric.uniformity_eq_comap_nhds_zero, tendsto_comap_iff,\n    Function.comp_def]\n  simp_rw [Prod.map_fst, Prod.map_snd]\n\n"}
{"name":"Topology.IsInducing.isSeparable_preimage","module":"Mathlib.Topology.MetricSpace.Pseudo.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : PseudoMetricSpace α\nf : β → α\ninst✝ : TopologicalSpace β\nhf : Topology.IsInducing f\ns : Set α\nhs : TopologicalSpace.IsSeparable s\n⊢ TopologicalSpace.IsSeparable (Set.preimage f s)","decl":"/-- The preimage of a separable set by an inducing map is separable. -/\nprotected lemma IsInducing.isSeparable_preimage {f : β → α} [TopologicalSpace β]\n    (hf : IsInducing f) {s : Set α} (hs : IsSeparable s) : IsSeparable (f ⁻¹' s) := by\n  have : SeparableSpace s := hs.separableSpace\n  have : SecondCountableTopology s := UniformSpace.secondCountable_of_separable _\n  have : IsInducing ((mapsTo_preimage f s).restrict _ _ _) :=\n    (hf.comp IsInducing.subtypeVal).codRestrict _\n  have := this.secondCountableTopology\n  exact .of_subtype _\n\n"}
{"name":"Inducing.isSeparable_preimage","module":"Mathlib.Topology.MetricSpace.Pseudo.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : PseudoMetricSpace α\nf : β → α\ninst✝ : TopologicalSpace β\nhf : Topology.IsInducing f\ns : Set α\nhs : TopologicalSpace.IsSeparable s\n⊢ TopologicalSpace.IsSeparable (Set.preimage f s)","decl":"@[deprecated (since := \"2024-10-28\")]\nalias _root_.Inducing.isSeparable_preimage := IsInducing.isSeparable_preimage\n\n"}
{"name":"Topology.IsEmbedding.isSeparable_preimage","module":"Mathlib.Topology.MetricSpace.Pseudo.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : PseudoMetricSpace α\nf : β → α\ninst✝ : TopologicalSpace β\nhf : Topology.IsEmbedding f\ns : Set α\nhs : TopologicalSpace.IsSeparable s\n⊢ TopologicalSpace.IsSeparable (Set.preimage f s)","decl":"protected theorem IsEmbedding.isSeparable_preimage {f : β → α} [TopologicalSpace β]\n    (hf : IsEmbedding f) {s : Set α} (hs : IsSeparable s) : IsSeparable (f ⁻¹' s) :=\n  hf.isInducing.isSeparable_preimage hs\n\n"}
{"name":"Embedding.isSeparable_preimage","module":"Mathlib.Topology.MetricSpace.Pseudo.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : PseudoMetricSpace α\nf : β → α\ninst✝ : TopologicalSpace β\nhf : Topology.IsEmbedding f\ns : Set α\nhs : TopologicalSpace.IsSeparable s\n⊢ TopologicalSpace.IsSeparable (Set.preimage f s)","decl":"@[deprecated (since := \"2024-10-26\")]\nalias _root_.Embedding.isSeparable_preimage := IsEmbedding.isSeparable_preimage\n\n"}
{"name":"IsCompact.isSeparable","module":"Mathlib.Topology.MetricSpace.Pseudo.Basic","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\ns : Set α\nhs : IsCompact s\n⊢ TopologicalSpace.IsSeparable s","decl":"/-- A compact set is separable. -/\ntheorem IsCompact.isSeparable {s : Set α} (hs : IsCompact s) : IsSeparable s :=\n  haveI : CompactSpace s := isCompact_iff_compactSpace.mp hs\n  .of_subtype s\n\n"}
{"name":"Metric.secondCountable_of_almost_dense_set","module":"Mathlib.Topology.MetricSpace.Pseudo.Basic","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\nH : ∀ (ε : Real), GT.gt ε 0 → Exists fun s => And s.Countable (∀ (x : α), Exists fun y => And (Membership.mem s y) (LE.le (Dist.dist x y) ε))\n⊢ SecondCountableTopology α","decl":"/-- A pseudometric space is second countable if, for every `ε > 0`, there is a countable set which\nis `ε`-dense. -/\ntheorem secondCountable_of_almost_dense_set\n    (H : ∀ ε > (0 : ℝ), ∃ s : Set α, s.Countable ∧ ∀ x, ∃ y ∈ s, dist x y ≤ ε) :\n    SecondCountableTopology α := by\n  refine EMetric.secondCountable_of_almost_dense_set fun ε ε0 => ?_\n  rcases ENNReal.lt_iff_exists_nnreal_btwn.1 ε0 with ⟨ε', ε'0, ε'ε⟩\n  choose s hsc y hys hyx using H ε' (mod_cast ε'0)\n  refine ⟨s, hsc, iUnion₂_eq_univ_iff.2 fun x => ⟨y x, hys _, le_trans ?_ ε'ε.le⟩⟩\n  exact mod_cast hyx x\n\n"}
