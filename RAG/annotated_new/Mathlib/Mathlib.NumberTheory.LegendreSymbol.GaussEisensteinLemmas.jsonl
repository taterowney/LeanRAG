{"name":"ZMod.Ico_map_valMinAbs_natAbs_eq_Ico_map_id","module":"Mathlib.NumberTheory.LegendreSymbol.GaussEisensteinLemmas","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\na : ZMod p\nhap : Ne a 0\n⊢ Eq (Multiset.map (fun x => (HMul.hMul a ↑x).valMinAbs.natAbs) (Finset.Ico 1 (HDiv.hDiv p 2).succ).val) (Multiset.map (fun a => a) (Finset.Ico 1 (HDiv.hDiv p 2).succ).val)","decl":"/-- The image of the map sending a nonzero natural number `x ≤ p / 2` to the absolute value\n  of the integer in `(-p/2, p/2]` that is congruent to `a * x mod p` is the set\n  of nonzero natural numbers `x` such that `x ≤ p / 2`. -/\ntheorem Ico_map_valMinAbs_natAbs_eq_Ico_map_id (p : ℕ) [hp : Fact p.Prime] (a : ZMod p)\n    (hap : a ≠ 0) : ((Ico 1 (p / 2).succ).1.map fun (x : ℕ) => (a * x).valMinAbs.natAbs) =\n    (Ico 1 (p / 2).succ).1.map fun a => a := by\n  have he : ∀ {x}, x ∈ Ico 1 (p / 2).succ → x ≠ 0 ∧ x ≤ p / 2 := by\n    simp +contextual [Nat.lt_succ_iff, Nat.succ_le_iff, pos_iff_ne_zero]\n  have hep : ∀ {x}, x ∈ Ico 1 (p / 2).succ → x < p := fun hx =>\n    lt_of_le_of_lt (he hx).2 (Nat.div_lt_self hp.1.pos (by decide))\n  have hpe : ∀ {x}, x ∈ Ico 1 (p / 2).succ → ¬p ∣ x := fun hx hpx =>\n    not_lt_of_ge (le_of_dvd (Nat.pos_of_ne_zero (he hx).1) hpx) (hep hx)\n  have hmem : ∀ (x : ℕ) (_ : x ∈ Ico 1 (p / 2).succ),\n      (a * x : ZMod p).valMinAbs.natAbs ∈ Ico 1 (p / 2).succ := by\n    intro x hx\n    simp [hap, CharP.cast_eq_zero_iff (ZMod p) p, hpe hx, Nat.lt_succ_iff, succ_le_iff,\n      pos_iff_ne_zero, natAbs_valMinAbs_le _]\n  have hsurj : ∀ (b : ℕ) (hb : b ∈ Ico 1 (p / 2).succ),\n      ∃ x, ∃ _ : x ∈ Ico 1 (p / 2).succ, (a * x : ZMod p).valMinAbs.natAbs = b := by\n    intro b hb\n    refine ⟨(b / a : ZMod p).valMinAbs.natAbs, mem_Ico.mpr ⟨?_, ?_⟩, ?_⟩\n    · apply Nat.pos_of_ne_zero\n      simp only [div_eq_mul_inv, hap, CharP.cast_eq_zero_iff (ZMod p) p, hpe hb, not_false_iff,\n        valMinAbs_eq_zero, inv_eq_zero, Int.natAbs_eq_zero, Ne, _root_.mul_eq_zero, or_self_iff]\n    · apply lt_succ_of_le; apply natAbs_valMinAbs_le\n    · rw [natCast_natAbs_valMinAbs]\n      split_ifs\n      · rw [mul_div_cancel₀ _ hap, valMinAbs_def_pos, val_cast_of_lt (hep hb),\n          if_pos (le_of_lt_succ (mem_Ico.1 hb).2), Int.natAbs_ofNat]\n      · rw [mul_neg, mul_div_cancel₀ _ hap, natAbs_valMinAbs_neg, valMinAbs_def_pos,\n          val_cast_of_lt (hep hb), if_pos (le_of_lt_succ (mem_Ico.1 hb).2), Int.natAbs_ofNat]\n  exact Multiset.map_eq_map_of_bij_of_nodup _ _ (Finset.nodup _) (Finset.nodup _)\n    (fun x _ => (a * x : ZMod p).valMinAbs.natAbs) hmem\n    (inj_on_of_surj_on_of_card_le _ hmem hsurj le_rfl) hsurj (fun _ _ => rfl)\n\n"}
{"name":"ZMod.gauss_lemma_aux","module":"Mathlib.NumberTheory.LegendreSymbol.GaussEisensteinLemmas","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\na : Int\nhap : Ne (↑a) 0\n⊢ Eq (HPow.hPow (↑a) (HDiv.hDiv p 2)) ↑(HPow.hPow (-1) (Finset.filter (fun x => LT.lt (HDiv.hDiv p 2) (HMul.hMul ↑a ↑x).val) (Finset.Ico 1 (HDiv.hDiv p 2).succ)).card)","decl":"theorem gauss_lemma_aux (p : ℕ) [hp : Fact p.Prime] {a : ℤ} (hap : (a : ZMod p) ≠ 0) :\n    (a ^ (p / 2) : ZMod p) =\n      ((-1) ^ #{x ∈ Ico 1 (p / 2).succ | p / 2 < (a * x.cast : ZMod p).val} :) :=\n  (mul_left_inj' (show ((p / 2)! : ZMod p) ≠ 0 by\n    rw [Ne, CharP.cast_eq_zero_iff (ZMod p) p, hp.1.dvd_factorial, not_le]\n    exact Nat.div_lt_self hp.1.pos (by decide))).1 <| by\n      simpa using gauss_lemma_aux₁ p hap\n\n"}
{"name":"ZMod.gauss_lemma","module":"Mathlib.NumberTheory.LegendreSymbol.GaussEisensteinLemmas","initialProofState":"p : Nat\nh : Fact (Nat.Prime p)\na : Int\nhp : Ne p 2\nha0 : Ne (↑a) 0\n⊢ Eq (legendreSym p a) (HPow.hPow (-1) (Finset.filter (fun x => LT.lt (HDiv.hDiv p 2) (HMul.hMul ↑a ↑x).val) (Finset.Ico 1 (HDiv.hDiv p 2).succ)).card)","decl":"/-- **Gauss' lemma**. The Legendre symbol can be computed by considering the number of naturals less\n  than `p/2` such that `(a * x) % p > p / 2`. -/\ntheorem gauss_lemma {p : ℕ} [h : Fact p.Prime] {a : ℤ} (hp : p ≠ 2) (ha0 : (a : ZMod p) ≠ 0) :\n    legendreSym p a = (-1) ^ #{x ∈ Ico 1 (p / 2).succ | p / 2 < (a * x.cast : ZMod p).val} := by\n  replace hp : Odd p := h.out.odd_of_ne_two hp\n  have : (legendreSym p a : ZMod p) =\n      (((-1) ^ #{x ∈ Ico 1 (p / 2).succ | p / 2 < (a * x.cast : ZMod p).val} : ℤ) : ZMod p) := by\n    rw [legendreSym.eq_pow, gauss_lemma_aux p ha0]\n  cases legendreSym.eq_one_or_neg_one p ha0 <;>\n  cases neg_one_pow_eq_or ℤ #{x ∈ Ico 1 (p / 2).succ | p / 2 < (a * x.cast : ZMod p).val} <;>\n  simp_all [ne_neg_self hp one_ne_zero, (ne_neg_self hp one_ne_zero).symm]\n\n"}
{"name":"ZMod.eisenstein_lemma_aux","module":"Mathlib.NumberTheory.LegendreSymbol.GaussEisensteinLemmas","initialProofState":"p : Nat\ninst✝¹ : Fact (Nat.Prime p)\ninst✝ : Fact (Eq (HMod.hMod p 2) 1)\na : Nat\nha2 : Eq (HMod.hMod a 2) 1\nhap : Ne (↑a) 0\n⊢ Nat.ModEq 2 (Finset.filter (fun x => LT.lt (HDiv.hDiv p 2) (HMul.hMul ↑a ↑x).val) (Finset.Ico 1 (HDiv.hDiv p 2).succ)).card ((Finset.Ico 1 (HDiv.hDiv p 2).succ).sum fun x => HDiv.hDiv (HMul.hMul x a) p)","decl":"theorem eisenstein_lemma_aux (p : ℕ) [Fact p.Prime] [Fact (p % 2 = 1)] {a : ℕ} (ha2 : a % 2 = 1)\n    (hap : (a : ZMod p) ≠ 0) :\n    #{x ∈ Ico 1 (p / 2).succ | p / 2 < (a * x.cast : ZMod p).val} ≡\n      ∑ x ∈ Ico 1 (p / 2).succ, x * a / p [MOD 2] :=\n  have ha2 : (a : ZMod 2) = (1 : ℕ) := (eq_iff_modEq_nat _).2 ha2\n  (eq_iff_modEq_nat 2).1 <| sub_eq_zero.1 <| by\n    simpa [add_left_comm, sub_eq_add_neg, ← mul_sum, mul_comm, ha2, Nat.cast_sum,\n      add_neg_eq_iff_eq_add.symm, neg_eq_self_mod_two, add_assoc] using\n      Eq.symm (eisenstein_lemma_aux₁ p hap)\n\n"}
{"name":"ZMod.div_eq_filter_card","module":"Mathlib.NumberTheory.LegendreSymbol.GaussEisensteinLemmas","initialProofState":"a b c : Nat\nhb0 : LT.lt 0 b\nhc : LE.le (HDiv.hDiv a b) c\n⊢ Eq (HDiv.hDiv a b) (Finset.filter (fun x => LE.le (HMul.hMul x b) a) (Finset.Ico 1 c.succ)).card","decl":"theorem div_eq_filter_card {a b c : ℕ} (hb0 : 0 < b) (hc : a / b ≤ c) :\n    a / b = #{x ∈ Ico 1 c.succ | x * b ≤ a} :=\n  calc\n    a / b = #(Ico 1 (a / b).succ) := by simp\n    _ = #{x ∈ Ico 1 c.succ | x * b ≤ a} :=\n      congr_arg _ <| Finset.ext fun x => by\n        have : x * b ≤ a → x ≤ c := fun h => le_trans (by rwa [le_div_iff_mul_le hb0]) hc\n        simp [Nat.lt_succ_iff, le_div_iff_mul_le hb0]; tauto\n\n"}
{"name":"ZMod.sum_mul_div_add_sum_mul_div_eq_mul","module":"Mathlib.NumberTheory.LegendreSymbol.GaussEisensteinLemmas","initialProofState":"p q : Nat\nhp : Fact (Nat.Prime p)\nhq0 : Ne (↑q) 0\n⊢ Eq (HAdd.hAdd ((Finset.Ico 1 (HDiv.hDiv p 2).succ).sum fun a => HDiv.hDiv (HMul.hMul a q) p) ((Finset.Ico 1 (HDiv.hDiv q 2).succ).sum fun a => HDiv.hDiv (HMul.hMul a p) q)) (HMul.hMul (HDiv.hDiv p 2) (HDiv.hDiv q 2))","decl":"/-- Each of the sums in this lemma is the cardinality of the set of integer points in each of the\n  two triangles formed by the diagonal of the rectangle `(0, p/2) × (0, q/2)`. Adding them\n  gives the number of points in the rectangle. -/\ntheorem sum_mul_div_add_sum_mul_div_eq_mul (p q : ℕ) [hp : Fact p.Prime] (hq0 : (q : ZMod p) ≠ 0) :\n    ∑ a ∈ Ico 1 (p / 2).succ, a * q / p + ∑ a ∈ Ico 1 (q / 2).succ, a * p / q =\n    p / 2 * (q / 2) := by\n  have hswap :\n    #{x ∈ Ico 1 (q / 2).succ ×ˢ Ico 1 (p / 2).succ | x.2 * q ≤ x.1 * p} =\n      #{x ∈ Ico 1 (p / 2).succ ×ˢ Ico 1 (q / 2).succ | x.1 * q ≤ x.2 * p} :=\n    card_equiv (Equiv.prodComm _ _)\n      (fun ⟨_, _⟩ => by\n        simp +contextual only [mem_filter, and_self_iff, Prod.swap_prod_mk,\n          forall_true_iff, mem_product, Equiv.prodComm_apply, and_assoc, and_left_comm])\n  have hdisj :\n    Disjoint {x ∈ Ico 1 (p / 2).succ ×ˢ Ico 1 (q / 2).succ | x.2 * p ≤ x.1 * q}\n      {x ∈ Ico 1 (p / 2).succ ×ˢ Ico 1 (q / 2).succ | x.1 * q ≤ x.2 * p} := by\n    apply disjoint_filter.2 fun x hx hpq hqp => ?_\n    have hxp : x.1 < p := lt_of_le_of_lt\n      (show x.1 ≤ p / 2 by simp_all only [Nat.lt_succ_iff, mem_Ico, mem_product])\n      (Nat.div_lt_self hp.1.pos (by decide))\n    have : (x.1 : ZMod p) = 0 := by\n      simpa [hq0] using congr_arg ((↑) : ℕ → ZMod p) (le_antisymm hpq hqp)\n    apply_fun ZMod.val at this\n    rw [val_cast_of_lt hxp, val_zero] at this\n    simp only [this, nonpos_iff_eq_zero, mem_Ico, one_ne_zero, false_and, mem_product] at hx\n  have hunion :\n      {x ∈ Ico 1 (p / 2).succ ×ˢ Ico 1 (q / 2).succ | x.2 * p ≤ x.1 * q} ∪\n        {x ∈ Ico 1 (p / 2).succ ×ˢ Ico 1 (q / 2).succ | x.1 * q ≤ x.2 * p} =\n      Ico 1 (p / 2).succ ×ˢ Ico 1 (q / 2).succ :=\n    Finset.ext fun x => by\n      have := le_total (x.2 * p) (x.1 * q)\n      simp only [mem_union, mem_filter, mem_Ico, mem_product]\n      tauto\n  rw [sum_Ico_eq_card_lt, sum_Ico_eq_card_lt, hswap, ← card_union_of_disjoint hdisj, hunion,\n    card_product]\n  simp only [card_Ico, tsub_zero, succ_sub_succ_eq_sub]\n\n"}
{"name":"ZMod.eisenstein_lemma","module":"Mathlib.NumberTheory.LegendreSymbol.GaussEisensteinLemmas","initialProofState":"p : Nat\ninst✝ : Fact (Nat.Prime p)\nhp : Ne p 2\na : Nat\nha1 : Eq (HMod.hMod a 2) 1\nha0 : Ne (↑a) 0\n⊢ Eq (legendreSym p ↑a) (HPow.hPow (-1) ((Finset.Ico 1 (HDiv.hDiv p 2).succ).sum fun x => HDiv.hDiv (HMul.hMul x a) p))","decl":"/-- **Eisenstein's lemma** -/\ntheorem eisenstein_lemma {p : ℕ} [Fact p.Prime] (hp : p ≠ 2) {a : ℕ} (ha1 : a % 2 = 1)\n    (ha0 : (a : ZMod p) ≠ 0) : legendreSym p a = (-1) ^ ∑ x ∈ Ico 1 (p / 2).succ, x * a / p := by\n  haveI hp' : Fact (p % 2 = 1) := ⟨Nat.Prime.mod_two_eq_one_iff_ne_two.mpr hp⟩\n  have ha0' : ((a : ℤ) : ZMod p) ≠ 0 := by norm_cast\n  rw [neg_one_pow_eq_pow_mod_two, gauss_lemma hp ha0', neg_one_pow_eq_pow_mod_two,\n    (by norm_cast : ((a : ℤ) : ZMod p) = (a : ZMod p)),\n    show _ = _ from eisenstein_lemma_aux p ha1 ha0]\n\n"}
