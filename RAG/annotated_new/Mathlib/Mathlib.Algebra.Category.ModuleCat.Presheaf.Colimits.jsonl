{"name":"PresheafOfModules.instHasColimitModuleCatCarrierObjOppositeRingCatCompEvaluationRestrictScalarsHomMap","module":"Mathlib.Algebra.Category.ModuleCat.Presheaf.Colimits","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nR : CategoryTheory.Functor (Opposite C) RingCat\nJ : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} J\nF : CategoryTheory.Functor J (PresheafOfModules R)\ninst‚úù¬π : ‚àÄ {X Y : Opposite C} (f : Quiver.Hom X Y), CategoryTheory.Limits.PreservesColimit (F.comp (PresheafOfModules.evaluation R Y)) (ModuleCat.restrictScalars (RingCat.Hom.hom (R.map f)))\ninst‚úù : ‚àÄ (X : Opposite C), CategoryTheory.Limits.HasColimit (F.comp (PresheafOfModules.evaluation R X))\nX Y : Opposite C\nf : Quiver.Hom X Y\n‚ä¢ CategoryTheory.Limits.HasColimit (F.comp ((PresheafOfModules.evaluation R Y).comp (ModuleCat.restrictScalars (RingCat.Hom.hom (R.map f)))))","decl":"instance {X Y : C·µí·µñ} (f : X ‚ü∂ Y) :\n    HasColimit (F ‚ãô evaluation R Y ‚ãô (ModuleCat.restrictScalars (R.map f).hom)) :=\n  ‚ü®_, isColimitOfPreserves (ModuleCat.restrictScalars (R.map f).hom)\n    (colimit.isColimit (F ‚ãô evaluation R Y))‚ü©\n\n"}
{"name":"PresheafOfModules.colimitPresheafOfModules_map","module":"Mathlib.Algebra.Category.ModuleCat.Presheaf.Colimits","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nR : CategoryTheory.Functor (Opposite C) RingCat\nJ : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} J\nF : CategoryTheory.Functor J (PresheafOfModules R)\ninst‚úù¬π : ‚àÄ {X Y : Opposite C} (f : Quiver.Hom X Y), CategoryTheory.Limits.PreservesColimit (F.comp (PresheafOfModules.evaluation R Y)) (ModuleCat.restrictScalars (RingCat.Hom.hom (R.map f)))\ninst‚úù : ‚àÄ (X : Opposite C), CategoryTheory.Limits.HasColimit (F.comp (PresheafOfModules.evaluation R X))\nx‚úù Y : Opposite C\nf : Quiver.Hom x‚úù Y\n‚ä¢ Eq ((PresheafOfModules.colimitPresheafOfModules F).map f) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimMap (CategoryTheory.whiskerLeft F (PresheafOfModules.restriction R f))) (CategoryTheory.preservesColimitIso (ModuleCat.restrictScalars (RingCat.Hom.hom (R.map f))) (F.comp (PresheafOfModules.evaluation R Y))).inv)","decl":"/-- Given `F : J ‚•§ PresheafOfModules.{v} R`, this is the presheaf of modules obtained by\ntaking a colimit in the category of modules over `R.obj X` for all `X`. -/\n@[simps]\nnoncomputable def colimitPresheafOfModules : PresheafOfModules R where\n  obj X := colimit (F ‚ãô evaluation R X)\n  map {_ Y} f := colimMap (whiskerLeft F (restriction R f)) ‚â´\n    (preservesColimitIso (ModuleCat.restrictScalars (R.map f).hom) (F ‚ãô evaluation R Y)).inv\n  map_id X := colimit.hom_ext (fun j => by\n    dsimp\n    rw [Œπ_colimMap_assoc, whiskerLeft_app, restriction_app]\n    erw [Œπ_preservesColimitIso_inv (G := ModuleCat.restrictScalars (R.map (ùüô X)).hom),\n      ModuleCat.restrictScalarsId'App_inv_naturality]\n    rw [map_id]\n    dsimp)\n  map_comp {X Y Z} f g := colimit.hom_ext (fun j => by\n    dsimp\n    rw [Œπ_colimMap_assoc, whiskerLeft_app, restriction_app, assoc, Œπ_colimMap_assoc]\n    erw [Œπ_preservesColimitIso_inv (G := ModuleCat.restrictScalars (R.map (f ‚â´ g)).hom),\n      Œπ_preservesColimitIso_inv_assoc (G := ModuleCat.restrictScalars (R.map f).hom)]\n    rw [‚Üê Functor.map_comp_assoc, Œπ_colimMap_assoc]\n    erw [Œπ_preservesColimitIso_inv (G := ModuleCat.restrictScalars (R.map g).hom)]\n    rw [map_comp, ModuleCat.restrictScalarsComp'_inv_app, assoc, assoc,\n      whiskerLeft_app, whiskerLeft_app, restriction_app, restriction_app]\n    simp only [Functor.map_comp, assoc]\n    rfl)\n\n"}
{"name":"PresheafOfModules.colimitPresheafOfModules_obj","module":"Mathlib.Algebra.Category.ModuleCat.Presheaf.Colimits","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nR : CategoryTheory.Functor (Opposite C) RingCat\nJ : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} J\nF : CategoryTheory.Functor J (PresheafOfModules R)\ninst‚úù¬π : ‚àÄ {X Y : Opposite C} (f : Quiver.Hom X Y), CategoryTheory.Limits.PreservesColimit (F.comp (PresheafOfModules.evaluation R Y)) (ModuleCat.restrictScalars (RingCat.Hom.hom (R.map f)))\ninst‚úù : ‚àÄ (X : Opposite C), CategoryTheory.Limits.HasColimit (F.comp (PresheafOfModules.evaluation R X))\nX : Opposite C\n‚ä¢ Eq ((PresheafOfModules.colimitPresheafOfModules F).obj X) (CategoryTheory.Limits.colimit (F.comp (PresheafOfModules.evaluation R X)))","decl":"/-- Given `F : J ‚•§ PresheafOfModules.{v} R`, this is the presheaf of modules obtained by\ntaking a colimit in the category of modules over `R.obj X` for all `X`. -/\n@[simps]\nnoncomputable def colimitPresheafOfModules : PresheafOfModules R where\n  obj X := colimit (F ‚ãô evaluation R X)\n  map {_ Y} f := colimMap (whiskerLeft F (restriction R f)) ‚â´\n    (preservesColimitIso (ModuleCat.restrictScalars (R.map f).hom) (F ‚ãô evaluation R Y)).inv\n  map_id X := colimit.hom_ext (fun j => by\n    dsimp\n    rw [Œπ_colimMap_assoc, whiskerLeft_app, restriction_app]\n    erw [Œπ_preservesColimitIso_inv (G := ModuleCat.restrictScalars (R.map (ùüô X)).hom),\n      ModuleCat.restrictScalarsId'App_inv_naturality]\n    rw [map_id]\n    dsimp)\n  map_comp {X Y Z} f g := colimit.hom_ext (fun j => by\n    dsimp\n    rw [Œπ_colimMap_assoc, whiskerLeft_app, restriction_app, assoc, Œπ_colimMap_assoc]\n    erw [Œπ_preservesColimitIso_inv (G := ModuleCat.restrictScalars (R.map (f ‚â´ g)).hom),\n      Œπ_preservesColimitIso_inv_assoc (G := ModuleCat.restrictScalars (R.map f).hom)]\n    rw [‚Üê Functor.map_comp_assoc, Œπ_colimMap_assoc]\n    erw [Œπ_preservesColimitIso_inv (G := ModuleCat.restrictScalars (R.map g).hom)]\n    rw [map_comp, ModuleCat.restrictScalarsComp'_inv_app, assoc, assoc,\n      whiskerLeft_app, whiskerLeft_app, restriction_app, restriction_app]\n    simp only [Functor.map_comp, assoc]\n    rfl)\n\n"}
{"name":"PresheafOfModules.colimitCocone_pt","module":"Mathlib.Algebra.Category.ModuleCat.Presheaf.Colimits","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nR : CategoryTheory.Functor (Opposite C) RingCat\nJ : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} J\nF : CategoryTheory.Functor J (PresheafOfModules R)\ninst‚úù¬π : ‚àÄ {X Y : Opposite C} (f : Quiver.Hom X Y), CategoryTheory.Limits.PreservesColimit (F.comp (PresheafOfModules.evaluation R Y)) (ModuleCat.restrictScalars (RingCat.Hom.hom (R.map f)))\ninst‚úù : ‚àÄ (X : Opposite C), CategoryTheory.Limits.HasColimit (F.comp (PresheafOfModules.evaluation R X))\n‚ä¢ Eq (PresheafOfModules.colimitCocone F).pt (PresheafOfModules.colimitPresheafOfModules F)","decl":"/-- The (colimit) cocone for `F : J ‚•§ PresheafOfModules.{v} R` that is constructed from\nthe colimit of `F ‚ãô evaluation R X` for all `X`. -/\n@[simps]\nnoncomputable def colimitCocone : Cocone F where\n  pt := colimitPresheafOfModules F\n  Œπ :=\n    { app := fun j ‚Ü¶\n        { app := fun X ‚Ü¶ colimit.Œπ (F ‚ãô evaluation R X) j\n          naturality := fun {X Y} f ‚Ü¶ by\n            dsimp\n            erw [colimit.Œπ_desc_assoc, assoc, ‚Üê Œπ_preservesColimitIso_inv]\n            rfl }\n      naturality := fun {X Y} f ‚Ü¶ by\n        ext1 X\n        simpa using colimit.w (F ‚ãô evaluation R X) f }\n\n"}
{"name":"PresheafOfModules.colimitCocone_Œπ_app_app","module":"Mathlib.Algebra.Category.ModuleCat.Presheaf.Colimits","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nR : CategoryTheory.Functor (Opposite C) RingCat\nJ : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} J\nF : CategoryTheory.Functor J (PresheafOfModules R)\ninst‚úù¬π : ‚àÄ {X Y : Opposite C} (f : Quiver.Hom X Y), CategoryTheory.Limits.PreservesColimit (F.comp (PresheafOfModules.evaluation R Y)) (ModuleCat.restrictScalars (RingCat.Hom.hom (R.map f)))\ninst‚úù : ‚àÄ (X : Opposite C), CategoryTheory.Limits.HasColimit (F.comp (PresheafOfModules.evaluation R X))\nj : J\nX : Opposite C\n‚ä¢ Eq (((PresheafOfModules.colimitCocone F).Œπ.app j).app X) (CategoryTheory.Limits.colimit.Œπ (F.comp (PresheafOfModules.evaluation R X)) j)","decl":"/-- The (colimit) cocone for `F : J ‚•§ PresheafOfModules.{v} R` that is constructed from\nthe colimit of `F ‚ãô evaluation R X` for all `X`. -/\n@[simps]\nnoncomputable def colimitCocone : Cocone F where\n  pt := colimitPresheafOfModules F\n  Œπ :=\n    { app := fun j ‚Ü¶\n        { app := fun X ‚Ü¶ colimit.Œπ (F ‚ãô evaluation R X) j\n          naturality := fun {X Y} f ‚Ü¶ by\n            dsimp\n            erw [colimit.Œπ_desc_assoc, assoc, ‚Üê Œπ_preservesColimitIso_inv]\n            rfl }\n      naturality := fun {X Y} f ‚Ü¶ by\n        ext1 X\n        simpa using colimit.w (F ‚ãô evaluation R X) f }\n\n"}
{"name":"PresheafOfModules.hasColimit","module":"Mathlib.Algebra.Category.ModuleCat.Presheaf.Colimits","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nR : CategoryTheory.Functor (Opposite C) RingCat\nJ : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} J\nF : CategoryTheory.Functor J (PresheafOfModules R)\ninst‚úù¬π : ‚àÄ {X Y : Opposite C} (f : Quiver.Hom X Y), CategoryTheory.Limits.PreservesColimit (F.comp (PresheafOfModules.evaluation R Y)) (ModuleCat.restrictScalars (RingCat.Hom.hom (R.map f)))\ninst‚úù : ‚àÄ (X : Opposite C), CategoryTheory.Limits.HasColimit (F.comp (PresheafOfModules.evaluation R X))\n‚ä¢ CategoryTheory.Limits.HasColimit F","decl":"instance hasColimit : HasColimit F := ‚ü®_, isColimitColimitCocone F‚ü©\n\n"}
{"name":"PresheafOfModules.evaluation_preservesColimit","module":"Mathlib.Algebra.Category.ModuleCat.Presheaf.Colimits","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nR : CategoryTheory.Functor (Opposite C) RingCat\nJ : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} J\nF : CategoryTheory.Functor J (PresheafOfModules R)\ninst‚úù¬π : ‚àÄ {X Y : Opposite C} (f : Quiver.Hom X Y), CategoryTheory.Limits.PreservesColimit (F.comp (PresheafOfModules.evaluation R Y)) (ModuleCat.restrictScalars (RingCat.Hom.hom (R.map f)))\ninst‚úù : ‚àÄ (X : Opposite C), CategoryTheory.Limits.HasColimit (F.comp (PresheafOfModules.evaluation R X))\nX : Opposite C\n‚ä¢ CategoryTheory.Limits.PreservesColimit F (PresheafOfModules.evaluation R X)","decl":"instance evaluation_preservesColimit (X : C·µí·µñ) :\n    PreservesColimit F (evaluation R X) :=\n  preservesColimit_of_preserves_colimit_cocone (isColimitColimitCocone F) (colimit.isColimit _)\n\n"}
{"name":"PresheafOfModules.toPresheaf_preservesColimit","module":"Mathlib.Algebra.Category.ModuleCat.Presheaf.Colimits","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nR : CategoryTheory.Functor (Opposite C) RingCat\nJ : Type u‚ÇÇ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} J\nF : CategoryTheory.Functor J (PresheafOfModules R)\ninst‚úù¬≤ : ‚àÄ {X Y : Opposite C} (f : Quiver.Hom X Y), CategoryTheory.Limits.PreservesColimit (F.comp (PresheafOfModules.evaluation R Y)) (ModuleCat.restrictScalars (RingCat.Hom.hom (R.map f)))\ninst‚úù¬π : ‚àÄ (X : Opposite C), CategoryTheory.Limits.HasColimit (F.comp (PresheafOfModules.evaluation R X))\ninst‚úù : ‚àÄ (X : Opposite C), CategoryTheory.Limits.PreservesColimit F ((PresheafOfModules.evaluation R X).comp (CategoryTheory.forget‚ÇÇ (ModuleCat ‚Üë(R.obj X)) AddCommGrp))\n‚ä¢ CategoryTheory.Limits.PreservesColimit F (PresheafOfModules.toPresheaf R)","decl":"instance toPresheaf_preservesColimit :\n    PreservesColimit F (toPresheaf R) :=\n  preservesColimit_of_preserves_colimit_cocone (isColimitColimitCocone F)\n    (Limits.evaluationJointlyReflectsColimits _\n      (fun X => isColimitOfPreserves (evaluation R X ‚ãô forget‚ÇÇ _ AddCommGrp)\n        (isColimitColimitCocone F)))\n\n"}
{"name":"PresheafOfModules.hasColimitsOfShape","module":"Mathlib.Algebra.Category.ModuleCat.Presheaf.Colimits","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nR : CategoryTheory.Functor (Opposite C) RingCat\nJ : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} J\n‚ä¢ CategoryTheory.Limits.HasColimitsOfShape J (PresheafOfModules R)","decl":"instance hasColimitsOfShape : HasColimitsOfShape J (PresheafOfModules.{v} R) where\n\n"}
{"name":"PresheafOfModules.evaluation_preservesColimitsOfShape","module":"Mathlib.Algebra.Category.ModuleCat.Presheaf.Colimits","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nR : CategoryTheory.Functor (Opposite C) RingCat\nJ : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} J\nX : Opposite C\n‚ä¢ CategoryTheory.Limits.PreservesColimitsOfShape J (PresheafOfModules.evaluation R X)","decl":"noncomputable instance evaluation_preservesColimitsOfShape (X : C·µí·µñ) :\n    PreservesColimitsOfShape J (evaluation R X : PresheafOfModules.{v} R ‚•§ _) where\n\n"}
{"name":"PresheafOfModules.toPresheaf_preservesColimitsOfShape","module":"Mathlib.Algebra.Category.ModuleCat.Presheaf.Colimits","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nR : CategoryTheory.Functor (Opposite C) RingCat\nJ : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} J\n‚ä¢ CategoryTheory.Limits.PreservesColimitsOfShape J (PresheafOfModules.toPresheaf R)","decl":"noncomputable instance toPresheaf_preservesColimitsOfShape :\n    PreservesColimitsOfShape J (toPresheaf.{v} R) where\n\n"}
{"name":"PresheafOfModules.Finite.hasFiniteColimits","module":"Mathlib.Algebra.Category.ModuleCat.Presheaf.Colimits","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nR : CategoryTheory.Functor (Opposite C) RingCat\n‚ä¢ CategoryTheory.Limits.HasFiniteColimits (PresheafOfModules R)","decl":"instance hasFiniteColimits : HasFiniteColimits (PresheafOfModules.{v} R) :=\n  ‚ü®fun _ => inferInstance‚ü©\n\n"}
{"name":"PresheafOfModules.Finite.evaluation_preservesFiniteColimits","module":"Mathlib.Algebra.Category.ModuleCat.Presheaf.Colimits","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nR : CategoryTheory.Functor (Opposite C) RingCat\nX : Opposite C\n‚ä¢ CategoryTheory.Limits.PreservesFiniteColimits (PresheafOfModules.evaluation R X)","decl":"noncomputable instance evaluation_preservesFiniteColimits (X : C·µí·µñ) :\n    PreservesFiniteColimits (evaluation.{v} R X) where\n\n"}
{"name":"PresheafOfModules.Finite.toPresheaf_preservesFiniteColimits","module":"Mathlib.Algebra.Category.ModuleCat.Presheaf.Colimits","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nR : CategoryTheory.Functor (Opposite C) RingCat\n‚ä¢ CategoryTheory.Limits.PreservesFiniteColimits (PresheafOfModules.toPresheaf R)","decl":"noncomputable instance toPresheaf_preservesFiniteColimits :\n    PreservesFiniteColimits (toPresheaf R) where\n\n"}
