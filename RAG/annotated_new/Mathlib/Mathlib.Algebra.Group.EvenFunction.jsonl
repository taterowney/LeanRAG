{"name":"Function.Even.const","module":"Mathlib.Algebra.Group.EvenFunction","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : Neg α\nb : β\n⊢ Function.Even fun x => b","decl":"/-- Any constant function is even. -/\nlemma Even.const (b : β) : Function.Even (fun _ : α ↦ b) := fun _ ↦ rfl\n\n"}
{"name":"Function.Even.zero","module":"Mathlib.Algebra.Group.EvenFunction","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Neg α\ninst✝ : Zero β\n⊢ Function.Even fun x => 0","decl":"/-- The zero function is even. -/\nlemma Even.zero [Zero β] : Function.Even (fun (_ : α) ↦ (0 : β)) := Even.const 0\n\n"}
{"name":"Function.Odd.zero","module":"Mathlib.Algebra.Group.EvenFunction","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Neg α\ninst✝ : NegZeroClass β\n⊢ Function.Odd fun x => 0","decl":"/-- The zero function is odd. -/\nlemma Odd.zero [NegZeroClass β] : Function.Odd (fun (_ : α) ↦ (0 : β)) := fun _ ↦ neg_zero.symm\n\n"}
{"name":"Function.Even.left_comp","module":"Mathlib.Algebra.Group.EvenFunction","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : Neg α\nγ : Type u_3\ng : α → β\nhg : Function.Even g\nf : β → γ\n⊢ Function.Even (Function.comp f g)","decl":"/-- If `f` is arbitrary and `g` is even, then `f ∘ g` is even. -/\nlemma Even.left_comp {g : α → β} (hg : g.Even) (f : β → γ) : (f ∘ g).Even :=\n  (congr_arg f <| hg ·)\n\n"}
{"name":"Function.Even.comp_odd","module":"Mathlib.Algebra.Group.EvenFunction","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Neg α\nγ : Type u_3\ninst✝ : Neg β\nf : β → γ\nhf : Function.Even f\ng : α → β\nhg : Function.Odd g\n⊢ Function.Even (Function.comp f g)","decl":"/-- If `f` is even and `g` is odd, then `f ∘ g` is even. -/\nlemma Even.comp_odd [Neg β] {f : β → γ} (hf : f.Even) {g : α → β} (hg : g.Odd) :\n    (f ∘ g).Even := by\n  intro a\n  simp only [comp_apply, hg a, hf _]\n\n"}
{"name":"Function.Odd.comp_odd","module":"Mathlib.Algebra.Group.EvenFunction","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : Neg α\nγ : Type u_3\ninst✝¹ : Neg β\ninst✝ : Neg γ\nf : β → γ\nhf : Function.Odd f\ng : α → β\nhg : Function.Odd g\n⊢ Function.Odd (Function.comp f g)","decl":"/-- If `f` and `g` are odd, then `f ∘ g` is odd. -/\nlemma Odd.comp_odd [Neg β] [Neg γ] {f : β → γ} (hf : f.Odd) {g : α → β} (hg : g.Odd) :\n    (f ∘ g).Odd := by\n  intro a\n  simp only [comp_apply, hg a, hf _]\n\n"}
{"name":"Function.Even.add","module":"Mathlib.Algebra.Group.EvenFunction","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Neg α\ninst✝ : Add β\nf g : α → β\nhf : Function.Even f\nhg : Function.Even g\n⊢ Function.Even (HAdd.hAdd f g)","decl":"lemma Even.add [Add β] {f g : α → β} (hf : f.Even) (hg : g.Even) : (f + g).Even := by\n  intro a\n  simp only [hf a, hg a, Pi.add_apply]\n\n"}
{"name":"Function.Odd.add","module":"Mathlib.Algebra.Group.EvenFunction","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Neg α\ninst✝ : SubtractionCommMonoid β\nf g : α → β\nhf : Function.Odd f\nhg : Function.Odd g\n⊢ Function.Odd (HAdd.hAdd f g)","decl":"lemma Odd.add [SubtractionCommMonoid β] {f g : α → β} (hf : f.Odd) (hg : g.Odd) : (f + g).Odd := by\n  intro a\n  simp only [hf a, hg a, Pi.add_apply, neg_add]\n\n"}
{"name":"Function.Even.smul_even","module":"Mathlib.Algebra.Group.EvenFunction","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Neg α\nγ : Type u_3\nf : α → β\ng : α → γ\ninst✝ : SMul β γ\nhf : Function.Even f\nhg : Function.Even g\n⊢ Function.Even (HSMul.hSMul f g)","decl":"lemma Even.smul_even [SMul β γ] (hf : f.Even) (hg : g.Even) : (f • g).Even := by\n  intro a\n  simp only [Pi.smul_apply', hf a, hg a]\n\n"}
{"name":"Function.Even.smul_odd","module":"Mathlib.Algebra.Group.EvenFunction","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : Neg α\nγ : Type u_3\nf : α → β\ng : α → γ\ninst✝² : Monoid β\ninst✝¹ : AddGroup γ\ninst✝ : DistribMulAction β γ\nhf : Function.Even f\nhg : Function.Odd g\n⊢ Function.Odd (HSMul.hSMul f g)","decl":"lemma Even.smul_odd [Monoid β] [AddGroup γ] [DistribMulAction β γ] (hf : f.Even) (hg : g.Odd) :\n    (f • g).Odd := by\n  intro a\n  simp only [Pi.smul_apply', hf a, hg a, smul_neg]\n\n"}
{"name":"Function.Odd.smul_even","module":"Mathlib.Algebra.Group.EvenFunction","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : Neg α\nγ : Type u_3\nf : α → β\ng : α → γ\ninst✝² : Ring β\ninst✝¹ : AddCommGroup γ\ninst✝ : Module β γ\nhf : Function.Odd f\nhg : Function.Even g\n⊢ Function.Odd (HSMul.hSMul f g)","decl":"lemma Odd.smul_even [Ring β] [AddCommGroup γ] [Module β γ] (hf : f.Odd) (hg : g.Even) :\n    (f • g).Odd := by\n  intro a\n  simp only [Pi.smul_apply', hf a, hg a, neg_smul]\n\n"}
{"name":"Function.Odd.smul_odd","module":"Mathlib.Algebra.Group.EvenFunction","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : Neg α\nγ : Type u_3\nf : α → β\ng : α → γ\ninst✝² : Ring β\ninst✝¹ : AddCommGroup γ\ninst✝ : Module β γ\nhf : Function.Odd f\nhg : Function.Odd g\n⊢ Function.Even (HSMul.hSMul f g)","decl":"lemma Odd.smul_odd [Ring β] [AddCommGroup γ] [Module β γ] (hf : f.Odd) (hg : g.Odd) :\n    (f • g).Even := by\n  intro a\n  simp only [Pi.smul_apply', hf a, hg a, smul_neg, neg_smul, neg_neg]\n\n"}
{"name":"Function.Even.const_smul","module":"Mathlib.Algebra.Group.EvenFunction","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Neg α\nγ : Type u_3\ng : α → γ\ninst✝ : SMul β γ\nhg : Function.Even g\nr : β\n⊢ Function.Even (HSMul.hSMul r g)","decl":"lemma Even.const_smul [SMul β γ] (hg : g.Even) (r : β) : (r • g).Even := by\n  intro a\n  simp only [Pi.smul_apply, hg a]\n\n"}
{"name":"Function.Odd.const_smul","module":"Mathlib.Algebra.Group.EvenFunction","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : Neg α\nγ : Type u_3\ng : α → γ\ninst✝² : Monoid β\ninst✝¹ : AddGroup γ\ninst✝ : DistribMulAction β γ\nhg : Function.Odd g\nr : β\n⊢ Function.Odd (HSMul.hSMul r g)","decl":"lemma Odd.const_smul [Monoid β] [AddGroup γ] [DistribMulAction β γ] (hg : g.Odd) (r : β) :\n    (r • g).Odd := by\n  intro a\n  simp only [Pi.smul_apply, hg a, smul_neg]\n\n"}
{"name":"Function.Even.mul_even","module":"Mathlib.Algebra.Group.EvenFunction","initialProofState":"α : Type u_1\ninst✝¹ : Neg α\nR : Type u_3\ninst✝ : Mul R\nf g : α → R\nhf : Function.Even f\nhg : Function.Even g\n⊢ Function.Even (HMul.hMul f g)","decl":"lemma Even.mul_even (hf : f.Even) (hg : g.Even) : (f * g).Even := by\n  intro a\n  simp only [Pi.mul_apply, hf a, hg a]\n\n"}
{"name":"Function.Even.mul_odd","module":"Mathlib.Algebra.Group.EvenFunction","initialProofState":"α : Type u_1\ninst✝² : Neg α\nR : Type u_3\ninst✝¹ : Mul R\nf g : α → R\ninst✝ : HasDistribNeg R\nhf : Function.Even f\nhg : Function.Odd g\n⊢ Function.Odd (HMul.hMul f g)","decl":"lemma Even.mul_odd [HasDistribNeg R] (hf : f.Even) (hg : g.Odd) : (f * g).Odd := by\n  intro a\n  simp only [Pi.mul_apply, hf a, hg a, mul_neg]\n\n"}
{"name":"Function.Odd.mul_even","module":"Mathlib.Algebra.Group.EvenFunction","initialProofState":"α : Type u_1\ninst✝² : Neg α\nR : Type u_3\ninst✝¹ : Mul R\nf g : α → R\ninst✝ : HasDistribNeg R\nhf : Function.Odd f\nhg : Function.Even g\n⊢ Function.Odd (HMul.hMul f g)","decl":"lemma Odd.mul_even [HasDistribNeg R] (hf : f.Odd) (hg : g.Even) : (f * g).Odd := by\n  intro a\n  simp only [Pi.mul_apply, hf a, hg a, neg_mul]\n\n"}
{"name":"Function.Odd.mul_odd","module":"Mathlib.Algebra.Group.EvenFunction","initialProofState":"α : Type u_1\ninst✝² : Neg α\nR : Type u_3\ninst✝¹ : Mul R\nf g : α → R\ninst✝ : HasDistribNeg R\nhf : Function.Odd f\nhg : Function.Odd g\n⊢ Function.Even (HMul.hMul f g)","decl":"lemma Odd.mul_odd [HasDistribNeg R] (hf : f.Odd) (hg : g.Odd) : (f * g).Even := by\n  intro a\n  simp only [Pi.mul_apply, hf a, hg a, mul_neg, neg_mul, neg_neg]\n\n"}
{"name":"Function.zero_of_even_and_odd","module":"Mathlib.Algebra.Group.EvenFunction","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝² : AddCommGroup β\ninst✝¹ : NoZeroSMulDivisors Nat β\nf : α → β\ninst✝ : Neg α\nhe : Function.Even f\nho : Function.Odd f\n⊢ Eq f 0","decl":"/--\nIf `f` is both even and odd, and its target is a torsion-free commutative additive group,\nthen `f = 0`.\n-/\nlemma zero_of_even_and_odd [Neg α] (he : f.Even) (ho : f.Odd) : f = 0 := by\n  ext r\n  rw [Pi.zero_apply, ← neg_eq_self ℕ, ← ho, he]\n\n"}
{"name":"Function.Odd.sum_eq_zero","module":"Mathlib.Algebra.Group.EvenFunction","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝³ : AddCommGroup β\ninst✝² : NoZeroSMulDivisors Nat β\ninst✝¹ : Fintype α\ninst✝ : InvolutiveNeg α\nf : α → β\nhf : Function.Odd f\n⊢ Eq (Finset.univ.sum fun a => f a) 0","decl":"/-- The sum of the values of an odd function is 0. -/\nlemma Odd.sum_eq_zero [Fintype α] [InvolutiveNeg α] {f : α → β} (hf : f.Odd) : ∑ a, f a = 0 := by\n  simpa only [neg_eq_self ℕ, Finset.sum_neg_distrib, funext hf, Equiv.neg_apply] using\n    Equiv.sum_comp (.neg α) f\n\n"}
{"name":"Function.Odd.map_zero","module":"Mathlib.Algebra.Group.EvenFunction","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝² : AddCommGroup β\ninst✝¹ : NoZeroSMulDivisors Nat β\nf : α → β\ninst✝ : NegZeroClass α\nhf : Function.Odd f\n⊢ Eq (f 0) 0","decl":"/-- An odd function vanishes at zero. -/\nlemma Odd.map_zero [NegZeroClass α] (hf : f.Odd) : f 0 = 0 := by\n  simp only [← neg_eq_self ℕ, ← hf 0, neg_zero]\n\n"}
