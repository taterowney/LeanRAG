{"name":"Ordinal.nfpFamily_eq_sup","module":"Mathlib.SetTheory.Ordinal.FixedPoint","initialProofState":"ι : Type u_1\nf : ι → Ordinal.{u} → Ordinal.{u}\na : Ordinal.{u}\n⊢ Eq (Ordinal.nfpFamily f a) (iSup fun i => List.foldr f a i)","decl":"@[deprecated \"No deprecation message was provided.\" (since := \"2024-10-14\")]\ntheorem nfpFamily_eq_sup (f : ι → Ordinal.{u} → Ordinal.{u}) (a : Ordinal.{u}) :\n    nfpFamily f a = ⨆ i, List.foldr f a i :=\n  rfl\n\n"}
{"name":"Ordinal.foldr_le_nfpFamily","module":"Mathlib.SetTheory.Ordinal.FixedPoint","initialProofState":"ι : Type u_1\ninst✝ : Small.{u, u_1} ι\nf : ι → Ordinal.{u} → Ordinal.{u}\na : Ordinal.{u}\nl : List ι\n⊢ LE.le (List.foldr f a l) (Ordinal.nfpFamily f a)","decl":"theorem foldr_le_nfpFamily [Small.{u} ι] (f : ι → Ordinal.{u} → Ordinal.{u}) (a l) :\n    List.foldr f a l ≤ nfpFamily f a :=\n  Ordinal.le_iSup _ _\n\n"}
{"name":"Ordinal.le_nfpFamily","module":"Mathlib.SetTheory.Ordinal.FixedPoint","initialProofState":"ι : Type u_1\ninst✝ : Small.{u, u_1} ι\nf : ι → Ordinal.{u} → Ordinal.{u}\na : Ordinal.{u}\n⊢ LE.le a (Ordinal.nfpFamily f a)","decl":"theorem le_nfpFamily [Small.{u} ι] (f : ι → Ordinal.{u} → Ordinal.{u}) (a) : a ≤ nfpFamily f a :=\n  foldr_le_nfpFamily f a []\n\n"}
{"name":"Ordinal.lt_nfpFamily","module":"Mathlib.SetTheory.Ordinal.FixedPoint","initialProofState":"ι : Type u_1\nf : ι → Ordinal.{u} → Ordinal.{u}\ninst✝ : Small.{u, u_1} ι\na b : Ordinal.{u}\n⊢ Iff (LT.lt a (Ordinal.nfpFamily f b)) (Exists fun l => LT.lt a (List.foldr f b l))","decl":"theorem lt_nfpFamily [Small.{u} ι] {a b} : a < nfpFamily f b ↔ ∃ l, a < List.foldr f b l :=\n  Ordinal.lt_iSup_iff\n\n"}
{"name":"Ordinal.nfpFamily_le_iff","module":"Mathlib.SetTheory.Ordinal.FixedPoint","initialProofState":"ι : Type u_1\nf : ι → Ordinal.{u} → Ordinal.{u}\ninst✝ : Small.{u, u_1} ι\na b : Ordinal.{u}\n⊢ Iff (LE.le (Ordinal.nfpFamily f a) b) (∀ (l : List ι), LE.le (List.foldr f a l) b)","decl":"theorem nfpFamily_le_iff [Small.{u} ι] {a b} : nfpFamily f a ≤ b ↔ ∀ l, List.foldr f a l ≤ b :=\n  Ordinal.iSup_le_iff\n\n"}
{"name":"Ordinal.nfpFamily_le","module":"Mathlib.SetTheory.Ordinal.FixedPoint","initialProofState":"ι : Type u_1\nf : ι → Ordinal.{u} → Ordinal.{u}\na b : Ordinal.{u}\na✝ : ∀ (l : List ι), LE.le (List.foldr f a l) b\n⊢ LE.le (Ordinal.nfpFamily f a) b","decl":"theorem nfpFamily_le {a b} : (∀ l, List.foldr f a l ≤ b) → nfpFamily f a ≤ b :=\n  Ordinal.iSup_le\n\n"}
{"name":"Ordinal.nfpFamily_monotone","module":"Mathlib.SetTheory.Ordinal.FixedPoint","initialProofState":"ι : Type u_1\nf : ι → Ordinal.{u} → Ordinal.{u}\ninst✝ : Small.{u, u_1} ι\nhf : ∀ (i : ι), Monotone (f i)\n⊢ Monotone (Ordinal.nfpFamily f)","decl":"theorem nfpFamily_monotone [Small.{u} ι] (hf : ∀ i, Monotone (f i)) : Monotone (nfpFamily f) :=\n  fun _ _ h ↦ nfpFamily_le <| fun l ↦ (List.foldr_monotone hf l h).trans (foldr_le_nfpFamily _ _ l)\n\n"}
{"name":"Ordinal.apply_lt_nfpFamily","module":"Mathlib.SetTheory.Ordinal.FixedPoint","initialProofState":"ι : Type u_1\nf : ι → Ordinal.{u} → Ordinal.{u}\ninst✝ : Small.{u, u_1} ι\nH : ∀ (i : ι), Ordinal.IsNormal (f i)\na b : Ordinal.{u}\nhb : LT.lt b (Ordinal.nfpFamily f a)\ni : ι\n⊢ LT.lt (f i b) (Ordinal.nfpFamily f a)","decl":"theorem apply_lt_nfpFamily [Small.{u} ι] (H : ∀ i, IsNormal (f i)) {a b}\n    (hb : b < nfpFamily f a) (i) : f i b < nfpFamily f a :=\n  let ⟨l, hl⟩ := lt_nfpFamily.1 hb\n  lt_nfpFamily.2 ⟨i::l, (H i).strictMono hl⟩\n\n"}
{"name":"Ordinal.apply_lt_nfpFamily_iff","module":"Mathlib.SetTheory.Ordinal.FixedPoint","initialProofState":"ι : Type u_1\nf : ι → Ordinal.{u} → Ordinal.{u}\ninst✝¹ : Nonempty ι\ninst✝ : Small.{u, u_1} ι\nH : ∀ (i : ι), Ordinal.IsNormal (f i)\na b : Ordinal.{u}\n⊢ Iff (∀ (i : ι), LT.lt (f i b) (Ordinal.nfpFamily f a)) (LT.lt b (Ordinal.nfpFamily f a))","decl":"theorem apply_lt_nfpFamily_iff [Nonempty ι] [Small.{u} ι] (H : ∀ i, IsNormal (f i)) {a b} :\n    (∀ i, f i b < nfpFamily f a) ↔ b < nfpFamily f a := by\n  refine ⟨fun h ↦ ?_, apply_lt_nfpFamily H⟩\n  let ⟨l, hl⟩ := lt_nfpFamily.1 (h (Classical.arbitrary ι))\n  exact lt_nfpFamily.2 <| ⟨l, (H _).le_apply.trans_lt hl⟩\n\n"}
{"name":"Ordinal.nfpFamily_le_apply","module":"Mathlib.SetTheory.Ordinal.FixedPoint","initialProofState":"ι : Type u_1\nf : ι → Ordinal.{u} → Ordinal.{u}\ninst✝¹ : Nonempty ι\ninst✝ : Small.{u, u_1} ι\nH : ∀ (i : ι), Ordinal.IsNormal (f i)\na b : Ordinal.{u}\n⊢ Iff (Exists fun i => LE.le (Ordinal.nfpFamily f a) (f i b)) (LE.le (Ordinal.nfpFamily f a) b)","decl":"theorem nfpFamily_le_apply [Nonempty ι] [Small.{u} ι] (H : ∀ i, IsNormal (f i)) {a b} :\n    (∃ i, nfpFamily f a ≤ f i b) ↔ nfpFamily f a ≤ b := by\n  rw [← not_iff_not]\n  push_neg\n  exact apply_lt_nfpFamily_iff H\n\n"}
{"name":"Ordinal.nfpFamily_le_fp","module":"Mathlib.SetTheory.Ordinal.FixedPoint","initialProofState":"ι : Type u_1\nf : ι → Ordinal.{u} → Ordinal.{u}\nH : ∀ (i : ι), Monotone (f i)\na b : Ordinal.{u}\nab : LE.le a b\nh : ∀ (i : ι), LE.le (f i b) b\n⊢ LE.le (Ordinal.nfpFamily f a) b","decl":"theorem nfpFamily_le_fp (H : ∀ i, Monotone (f i)) {a b} (ab : a ≤ b) (h : ∀ i, f i b ≤ b) :\n    nfpFamily f a ≤ b := by\n  apply Ordinal.iSup_le\n  intro l\n  induction' l with i l IH generalizing a\n  · exact ab\n  · exact (H i (IH ab)).trans (h i)\n\n"}
{"name":"Ordinal.nfpFamily_fp","module":"Mathlib.SetTheory.Ordinal.FixedPoint","initialProofState":"ι : Type u_1\nf : ι → Ordinal.{u} → Ordinal.{u}\ninst✝ : Small.{u, u_1} ι\ni : ι\nH : Ordinal.IsNormal (f i)\na : Ordinal.{u}\n⊢ Eq (f i (Ordinal.nfpFamily f a)) (Ordinal.nfpFamily f a)","decl":"theorem nfpFamily_fp [Small.{u} ι] {i} (H : IsNormal (f i)) (a) :\n    f i (nfpFamily f a) = nfpFamily f a := by\n  rw [nfpFamily, H.map_iSup]\n  apply le_antisymm <;> refine Ordinal.iSup_le fun l => ?_\n  · exact Ordinal.le_iSup _ (i::l)\n  · exact H.le_apply.trans (Ordinal.le_iSup _ _)\n\n"}
{"name":"Ordinal.apply_le_nfpFamily","module":"Mathlib.SetTheory.Ordinal.FixedPoint","initialProofState":"ι : Type u_1\nf : ι → Ordinal.{u} → Ordinal.{u}\ninst✝ : Small.{u, u_1} ι\nhι : Nonempty ι\nH : ∀ (i : ι), Ordinal.IsNormal (f i)\na b : Ordinal.{u}\n⊢ Iff (∀ (i : ι), LE.le (f i b) (Ordinal.nfpFamily f a)) (LE.le b (Ordinal.nfpFamily f a))","decl":"theorem apply_le_nfpFamily [Small.{u} ι] [hι : Nonempty ι] (H : ∀ i, IsNormal (f i)) {a b} :\n    (∀ i, f i b ≤ nfpFamily f a) ↔ b ≤ nfpFamily f a := by\n  refine ⟨fun h => ?_, fun h i => ?_⟩\n  · obtain ⟨i⟩ := hι\n    exact (H i).le_apply.trans (h i)\n  · rw [← nfpFamily_fp (H i)]\n    exact (H i).monotone h\n\n"}
{"name":"Ordinal.nfpFamily_eq_self","module":"Mathlib.SetTheory.Ordinal.FixedPoint","initialProofState":"ι : Type u_1\nf : ι → Ordinal.{u} → Ordinal.{u}\ninst✝ : Small.{u, u_1} ι\na : Ordinal.{u}\nh : ∀ (i : ι), Eq (f i a) a\n⊢ Eq (Ordinal.nfpFamily f a) a","decl":"theorem nfpFamily_eq_self [Small.{u} ι] {a} (h : ∀ i, f i a = a) : nfpFamily f a = a := by\n  apply (Ordinal.iSup_le ?_).antisymm (le_nfpFamily f a)\n  intro l\n  rw [List.foldr_fixed' h l]\n\n-- Todo: This is actually a special case of the fact the intersection of club sets is a club set.\n"}
{"name":"Ordinal.not_bddAbove_fp_family","module":"Mathlib.SetTheory.Ordinal.FixedPoint","initialProofState":"ι : Type u_1\nf : ι → Ordinal.{u} → Ordinal.{u}\ninst✝ : Small.{u, u_1} ι\nH : ∀ (i : ι), Ordinal.IsNormal (f i)\n⊢ Not (BddAbove (Set.iInter fun i => Function.fixedPoints (f i)))","decl":"/-- A generalization of the fixed point lemma for normal functions: any family of normal functions\n    has an unbounded set of common fixed points. -/\ntheorem not_bddAbove_fp_family [Small.{u} ι] (H : ∀ i, IsNormal (f i)) :\n    ¬ BddAbove (⋂ i, Function.fixedPoints (f i)) := by\n  rw [not_bddAbove_iff]\n  refine fun a ↦ ⟨nfpFamily f (succ a), ?_, (lt_succ a).trans_le (le_nfpFamily f _)⟩\n  rintro _ ⟨i, rfl⟩\n  exact nfpFamily_fp (H i) _\n\n"}
{"name":"Ordinal.derivFamily_zero","module":"Mathlib.SetTheory.Ordinal.FixedPoint","initialProofState":"ι : Type u_1\nf : ι → Ordinal.{u_2} → Ordinal.{u_2}\n⊢ Eq (Ordinal.derivFamily f 0) (Ordinal.nfpFamily f 0)","decl":"@[simp]\ntheorem derivFamily_zero (f : ι → Ordinal → Ordinal) :\n    derivFamily f 0 = nfpFamily f 0 :=\n  limitRecOn_zero ..\n\n"}
{"name":"Ordinal.derivFamily_succ","module":"Mathlib.SetTheory.Ordinal.FixedPoint","initialProofState":"ι : Type u_1\nf : ι → Ordinal.{u_2} → Ordinal.{u_2}\no : Ordinal.{u_2}\n⊢ Eq (Ordinal.derivFamily f (Order.succ o)) (Ordinal.nfpFamily f (Order.succ (Ordinal.derivFamily f o)))","decl":"@[simp]\ntheorem derivFamily_succ (f : ι → Ordinal → Ordinal) (o) :\n    derivFamily f (succ o) = nfpFamily f (succ (derivFamily f o)) :=\n  limitRecOn_succ ..\n\n"}
{"name":"Ordinal.derivFamily_limit","module":"Mathlib.SetTheory.Ordinal.FixedPoint","initialProofState":"ι : Type u_1\nf : ι → Ordinal.{u_2} → Ordinal.{u_2}\no : Ordinal.{u_2}\na✝ : o.IsLimit\n⊢ Eq (Ordinal.derivFamily f o) (iSup fun b => Ordinal.derivFamily f ↑b)","decl":"theorem derivFamily_limit (f : ι → Ordinal → Ordinal) {o} :\n    IsLimit o → derivFamily f o = ⨆ b : Set.Iio o, derivFamily f b :=\n  limitRecOn_limit _ _ _ _\n\n"}
{"name":"Ordinal.isNormal_derivFamily","module":"Mathlib.SetTheory.Ordinal.FixedPoint","initialProofState":"ι : Type u_1\ninst✝ : Small.{u, u_1} ι\nf : ι → Ordinal.{u} → Ordinal.{u}\n⊢ Ordinal.IsNormal (Ordinal.derivFamily f)","decl":"theorem isNormal_derivFamily [Small.{u} ι] (f : ι → Ordinal.{u} → Ordinal.{u}) :\n    IsNormal (derivFamily f) := by\n  refine ⟨fun o ↦ ?_, fun o h a ↦ ?_⟩\n  · rw [derivFamily_succ, ← succ_le_iff]\n    exact le_nfpFamily _ _\n  · simp_rw [derivFamily_limit _ h, Ordinal.iSup_le_iff, Subtype.forall, Set.mem_Iio]\n\n"}
{"name":"Ordinal.derivFamily_isNormal","module":"Mathlib.SetTheory.Ordinal.FixedPoint","initialProofState":"ι : Type u_1\ninst✝ : Small.{u, u_1} ι\nf : ι → Ordinal.{u} → Ordinal.{u}\n⊢ Ordinal.IsNormal (Ordinal.derivFamily f)","decl":"@[deprecated isNormal_derivFamily (since := \"2024-10-11\")]\nalias derivFamily_isNormal := isNormal_derivFamily\n\n"}
{"name":"Ordinal.derivFamily_fp","module":"Mathlib.SetTheory.Ordinal.FixedPoint","initialProofState":"ι : Type u_1\nf : ι → Ordinal.{u} → Ordinal.{u}\ninst✝ : Small.{u, u_1} ι\ni : ι\nH : Ordinal.IsNormal (f i)\no : Ordinal.{u}\n⊢ Eq (f i (Ordinal.derivFamily f o)) (Ordinal.derivFamily f o)","decl":"theorem derivFamily_fp [Small.{u} ι] {i} (H : IsNormal (f i)) (o : Ordinal) :\n    f i (derivFamily f o) = derivFamily f o := by\n  induction' o using limitRecOn with o _ o l IH\n  · rw [derivFamily_zero]\n    exact nfpFamily_fp H 0\n  · rw [derivFamily_succ]\n    exact nfpFamily_fp H _\n  · have : Nonempty (Set.Iio o) := ⟨0, l.pos⟩\n    rw [derivFamily_limit _ l, H.map_iSup]\n    refine eq_of_forall_ge_iff fun c => ?_\n    rw [Ordinal.iSup_le_iff, Ordinal.iSup_le_iff]\n    refine forall_congr' fun a ↦ ?_\n    rw [IH _ a.2]\n\n"}
{"name":"Ordinal.le_iff_derivFamily","module":"Mathlib.SetTheory.Ordinal.FixedPoint","initialProofState":"ι : Type u_1\nf : ι → Ordinal.{u} → Ordinal.{u}\ninst✝ : Small.{u, u_1} ι\nH : ∀ (i : ι), Ordinal.IsNormal (f i)\na : Ordinal.{u}\n⊢ Iff (∀ (i : ι), LE.le (f i a) a) (Exists fun o => Eq (Ordinal.derivFamily f o) a)","decl":"theorem le_iff_derivFamily [Small.{u} ι] (H : ∀ i, IsNormal (f i)) {a} :\n    (∀ i, f i a ≤ a) ↔ ∃ o, derivFamily f o = a :=\n  ⟨fun ha => by\n    suffices ∀ (o), a ≤ derivFamily f o → ∃ o, derivFamily f o = a from\n      this a (isNormal_derivFamily _).le_apply\n    intro o\n    induction' o using limitRecOn with o IH o l IH\n    · intro h₁\n      refine ⟨0, le_antisymm ?_ h₁⟩\n      rw [derivFamily_zero]\n      exact nfpFamily_le_fp (fun i => (H i).monotone) (Ordinal.zero_le _) ha\n    · intro h₁\n      rcases le_or_lt a (derivFamily f o) with h | h\n      · exact IH h\n      refine ⟨succ o, le_antisymm ?_ h₁⟩\n      rw [derivFamily_succ]\n      exact nfpFamily_le_fp (fun i => (H i).monotone) (succ_le_of_lt h) ha\n    · intro h₁\n      cases' eq_or_lt_of_le h₁ with h h\n      · exact ⟨_, h.symm⟩\n      rw [derivFamily_limit _ l, ← not_le, Ordinal.iSup_le_iff, not_forall] at h\n      obtain ⟨o', h⟩ := h\n      exact IH o' o'.2 (le_of_not_le h),\n    fun ⟨_, e⟩ i => e ▸ (derivFamily_fp (H i) _).le⟩\n\n"}
{"name":"Ordinal.fp_iff_derivFamily","module":"Mathlib.SetTheory.Ordinal.FixedPoint","initialProofState":"ι : Type u_1\nf : ι → Ordinal.{u} → Ordinal.{u}\ninst✝ : Small.{u, u_1} ι\nH : ∀ (i : ι), Ordinal.IsNormal (f i)\na : Ordinal.{u}\n⊢ Iff (∀ (i : ι), Eq (f i a) a) (Exists fun o => Eq (Ordinal.derivFamily f o) a)","decl":"theorem fp_iff_derivFamily [Small.{u} ι] (H : ∀ i, IsNormal (f i)) {a} :\n    (∀ i, f i a = a) ↔ ∃ o, derivFamily f o = a :=\n  Iff.trans ⟨fun h i => le_of_eq (h i), fun h i => (H i).le_iff_eq.1 (h i)⟩ (le_iff_derivFamily H)\n\n"}
{"name":"Ordinal.derivFamily_eq_enumOrd","module":"Mathlib.SetTheory.Ordinal.FixedPoint","initialProofState":"ι : Type u_1\nf : ι → Ordinal.{u} → Ordinal.{u}\ninst✝ : Small.{u, u_1} ι\nH : ∀ (i : ι), Ordinal.IsNormal (f i)\n⊢ Eq (Ordinal.derivFamily f) (Ordinal.enumOrd (Set.iInter fun i => Function.fixedPoints (f i)))","decl":"/-- For a family of normal functions, `Ordinal.derivFamily` enumerates the common fixed points. -/\ntheorem derivFamily_eq_enumOrd [Small.{u} ι] (H : ∀ i, IsNormal (f i)) :\n    derivFamily f = enumOrd (⋂ i, Function.fixedPoints (f i)) := by\n  rw [eq_comm, eq_enumOrd _ (not_bddAbove_fp_family H)]\n  use (isNormal_derivFamily f).strictMono\n  rw [Set.range_eq_iff]\n  refine ⟨?_, fun a ha => ?_⟩\n  · rintro a S ⟨i, hi⟩\n    rw [← hi]\n    exact derivFamily_fp (H i) a\n  rw [Set.mem_iInter] at ha\n  rwa [← fp_iff_derivFamily H]\n\n"}
{"name":"Ordinal.nfpBFamily_eq_nfpFamily","module":"Mathlib.SetTheory.Ordinal.FixedPoint","initialProofState":"o : Ordinal.{u}\nf : (b : Ordinal.{u}) → LT.lt b o → Ordinal.{max u v} → Ordinal.{max u v}\n⊢ Eq (o.nfpBFamily f) (Ordinal.nfpFamily (o.familyOfBFamily f))","decl":"set_option linter.deprecated false in\n@[deprecated \"No deprecation message was provided.\"  (since := \"2024-10-14\")]\ntheorem nfpBFamily_eq_nfpFamily {o : Ordinal} (f : ∀ b < o, Ordinal → Ordinal) :\n    nfpBFamily.{u, v} o f = nfpFamily (familyOfBFamily o f) :=\n  rfl\n\n"}
{"name":"Ordinal.foldr_le_nfpBFamily","module":"Mathlib.SetTheory.Ordinal.FixedPoint","initialProofState":"o : Ordinal.{u}\nf : (b : Ordinal.{u}) → LT.lt b o → Ordinal.{max u v} → Ordinal.{max u v}\na : Ordinal.{max u v}\nl : List o.toType\n⊢ LE.le (List.foldr (o.familyOfBFamily f) a l) (o.nfpBFamily f a)","decl":"set_option linter.deprecated false in\n@[deprecated \"No deprecation message was provided.\"  (since := \"2024-10-14\")]\ntheorem foldr_le_nfpBFamily {o : Ordinal}\n    (f : ∀ b < o, Ordinal → Ordinal) (a l) :\n    List.foldr (familyOfBFamily o f) a l ≤ nfpBFamily.{u, v} o f a :=\n  Ordinal.le_iSup _ _\n\n"}
{"name":"Ordinal.le_nfpBFamily","module":"Mathlib.SetTheory.Ordinal.FixedPoint","initialProofState":"o : Ordinal.{u}\nf : (b : Ordinal.{u}) → LT.lt b o → Ordinal.{max u v} → Ordinal.{max u v}\na : Ordinal.{max u v}\n⊢ LE.le a (o.nfpBFamily f a)","decl":"set_option linter.deprecated false in\n@[deprecated \"No deprecation message was provided.\"  (since := \"2024-10-14\")]\ntheorem le_nfpBFamily {o : Ordinal} (f : ∀ b < o, Ordinal → Ordinal) (a) :\n    a ≤ nfpBFamily.{u, v} o f a :=\n  Ordinal.le_iSup (fun _ ↦ List.foldr _ a _) []\n\n"}
{"name":"Ordinal.lt_nfpBFamily","module":"Mathlib.SetTheory.Ordinal.FixedPoint","initialProofState":"o : Ordinal.{u}\nf : (b : Ordinal.{u}) → LT.lt b o → Ordinal.{max u v} → Ordinal.{max u v}\na b : Ordinal.{max u v}\n⊢ Iff (LT.lt a (o.nfpBFamily f b)) (Exists fun l => LT.lt a (List.foldr (o.familyOfBFamily f) b l))","decl":"set_option linter.deprecated false in\n@[deprecated \"No deprecation message was provided.\"  (since := \"2024-10-14\")]\ntheorem lt_nfpBFamily {a b} :\n    a < nfpBFamily.{u, v} o f b ↔ ∃ l, a < List.foldr (familyOfBFamily o f) b l :=\n  Ordinal.lt_iSup_iff\n\n"}
{"name":"Ordinal.nfpBFamily_le_iff","module":"Mathlib.SetTheory.Ordinal.FixedPoint","initialProofState":"o : Ordinal.{u}\nf : (b : Ordinal.{u}) → LT.lt b o → Ordinal.{max u v} → Ordinal.{max u v}\na b : Ordinal.{max u v}\n⊢ Iff (LE.le (o.nfpBFamily f a) b) (∀ (l : List o.toType), LE.le (List.foldr (o.familyOfBFamily f) a l) b)","decl":"set_option linter.deprecated false in\n@[deprecated \"No deprecation message was provided.\"  (since := \"2024-10-14\")]\ntheorem nfpBFamily_le_iff {o : Ordinal} {f : ∀ b < o, Ordinal → Ordinal} {a b} :\n    nfpBFamily.{u, v} o f a ≤ b ↔ ∀ l, List.foldr (familyOfBFamily o f) a l ≤ b :=\n  Ordinal.iSup_le_iff\n\n"}
{"name":"Ordinal.nfpBFamily_le","module":"Mathlib.SetTheory.Ordinal.FixedPoint","initialProofState":"o : Ordinal.{u}\nf : (b : Ordinal.{u}) → LT.lt b o → Ordinal.{max u v} → Ordinal.{max u v}\na b : Ordinal.{max u v}\na✝ : ∀ (l : List o.toType), LE.le (List.foldr (o.familyOfBFamily f) a l) b\n⊢ LE.le (o.nfpBFamily f a) b","decl":"set_option linter.deprecated false in\n@[deprecated \"No deprecation message was provided.\"  (since := \"2024-10-14\")]\ntheorem nfpBFamily_le {o : Ordinal} {f : ∀ b < o, Ordinal → Ordinal} {a b} :\n    (∀ l, List.foldr (familyOfBFamily o f) a l ≤ b) → nfpBFamily.{u, v} o f a ≤ b :=\n  Ordinal.iSup_le\n\n"}
{"name":"Ordinal.nfpBFamily_monotone","module":"Mathlib.SetTheory.Ordinal.FixedPoint","initialProofState":"o : Ordinal.{u}\nf : (b : Ordinal.{u}) → LT.lt b o → Ordinal.{max u v} → Ordinal.{max u v}\nhf : ∀ (i : Ordinal.{u}) (hi : LT.lt i o), Monotone (f i hi)\n⊢ Monotone (o.nfpBFamily f)","decl":"set_option linter.deprecated false in\n@[deprecated \"No deprecation message was provided.\"  (since := \"2024-10-14\")]\ntheorem nfpBFamily_monotone (hf : ∀ i hi, Monotone (f i hi)) : Monotone (nfpBFamily.{u, v} o f) :=\n  nfpFamily_monotone fun _ => hf _ _\n\n"}
{"name":"Ordinal.apply_lt_nfpBFamily","module":"Mathlib.SetTheory.Ordinal.FixedPoint","initialProofState":"o : Ordinal.{u}\nf : (b : Ordinal.{u}) → LT.lt b o → Ordinal.{max u v} → Ordinal.{max u v}\nH : ∀ (i : Ordinal.{u}) (hi : LT.lt i o), Ordinal.IsNormal (f i hi)\na b : Ordinal.{max u v}\nhb : LT.lt b (o.nfpBFamily f a)\ni : Ordinal.{u}\nhi : LT.lt i o\n⊢ LT.lt (f i hi b) (o.nfpBFamily f a)","decl":"set_option linter.deprecated false in\n@[deprecated \"No deprecation message was provided.\"  (since := \"2024-10-14\")]\ntheorem apply_lt_nfpBFamily (H : ∀ i hi, IsNormal (f i hi)) {a b} (hb : b < nfpBFamily.{u, v} o f a)\n    (i hi) : f i hi b < nfpBFamily.{u, v} o f a := by\n  rw [← familyOfBFamily_enum o f]\n  apply apply_lt_nfpFamily (fun _ => H _ _) hb\n\n"}
{"name":"Ordinal.apply_lt_nfpBFamily_iff","module":"Mathlib.SetTheory.Ordinal.FixedPoint","initialProofState":"o : Ordinal.{u}\nf : (b : Ordinal.{u}) → LT.lt b o → Ordinal.{max u v} → Ordinal.{max u v}\nho : Ne o 0\nH : ∀ (i : Ordinal.{u}) (hi : LT.lt i o), Ordinal.IsNormal (f i hi)\na b : Ordinal.{max u v}\n⊢ Iff (∀ (i : Ordinal.{u}) (hi : LT.lt i o), LT.lt (f i hi b) (o.nfpBFamily f a)) (LT.lt b (o.nfpBFamily f a))","decl":"set_option linter.deprecated false in\n@[deprecated \"No deprecation message was provided.\"  (since := \"2024-10-14\")]\ntheorem apply_lt_nfpBFamily_iff (ho : o ≠ 0) (H : ∀ i hi, IsNormal (f i hi)) {a b} :\n    (∀ i hi, f i hi b < nfpBFamily.{u, v} o f a) ↔ b < nfpBFamily.{u, v} o f a :=\n  ⟨fun h => by\n    haveI := toType_nonempty_iff_ne_zero.2 ho\n    refine (apply_lt_nfpFamily_iff ?_).1 fun _ => h _ _\n    exact fun _ => H _ _, apply_lt_nfpBFamily H⟩\n\n"}
{"name":"Ordinal.nfpBFamily_le_apply","module":"Mathlib.SetTheory.Ordinal.FixedPoint","initialProofState":"o : Ordinal.{u}\nf : (b : Ordinal.{u}) → LT.lt b o → Ordinal.{max u v} → Ordinal.{max u v}\nho : Ne o 0\nH : ∀ (i : Ordinal.{u}) (hi : LT.lt i o), Ordinal.IsNormal (f i hi)\na b : Ordinal.{max u v}\n⊢ Iff (Exists fun i => Exists fun hi => LE.le (o.nfpBFamily f a) (f i hi b)) (LE.le (o.nfpBFamily f a) b)","decl":"set_option linter.deprecated false in\n@[deprecated \"No deprecation message was provided.\"  (since := \"2024-10-14\")]\ntheorem nfpBFamily_le_apply (ho : o ≠ 0) (H : ∀ i hi, IsNormal (f i hi)) {a b} :\n    (∃ i hi, nfpBFamily.{u, v} o f a ≤ f i hi b) ↔ nfpBFamily.{u, v} o f a ≤ b := by\n  rw [← not_iff_not]\n  push_neg\n  exact apply_lt_nfpBFamily_iff.{u, v} ho H\n\n"}
{"name":"Ordinal.nfpBFamily_le_fp","module":"Mathlib.SetTheory.Ordinal.FixedPoint","initialProofState":"o : Ordinal.{u}\nf : (b : Ordinal.{u}) → LT.lt b o → Ordinal.{max u v} → Ordinal.{max u v}\nH : ∀ (i : Ordinal.{u}) (hi : LT.lt i o), Monotone (f i hi)\na b : Ordinal.{max u v}\nab : LE.le a b\nh : ∀ (i : Ordinal.{u}) (hi : LT.lt i o), LE.le (f i hi b) b\n⊢ LE.le (o.nfpBFamily f a) b","decl":"set_option linter.deprecated false in\n@[deprecated \"No deprecation message was provided.\"  (since := \"2024-10-14\")]\ntheorem nfpBFamily_le_fp (H : ∀ i hi, Monotone (f i hi)) {a b} (ab : a ≤ b)\n    (h : ∀ i hi, f i hi b ≤ b) : nfpBFamily.{u, v} o f a ≤ b :=\n  nfpFamily_le_fp (fun _ => H _ _) ab fun _ => h _ _\n\n"}
{"name":"Ordinal.nfpBFamily_fp","module":"Mathlib.SetTheory.Ordinal.FixedPoint","initialProofState":"o : Ordinal.{u}\nf : (b : Ordinal.{u}) → LT.lt b o → Ordinal.{max u v} → Ordinal.{max u v}\ni : Ordinal.{u}\nhi : LT.lt i o\nH : Ordinal.IsNormal (f i hi)\na : Ordinal.{max u v}\n⊢ Eq (f i hi (o.nfpBFamily f a)) (o.nfpBFamily f a)","decl":"set_option linter.deprecated false in\n@[deprecated \"No deprecation message was provided.\"  (since := \"2024-10-14\")]\ntheorem nfpBFamily_fp {i hi} (H : IsNormal (f i hi)) (a) :\n    f i hi (nfpBFamily.{u, v} o f a) = nfpBFamily.{u, v} o f a := by\n  rw [← familyOfBFamily_enum o f]\n  apply nfpFamily_fp\n  rw [familyOfBFamily_enum]\n  exact H\n\n"}
{"name":"Ordinal.apply_le_nfpBFamily","module":"Mathlib.SetTheory.Ordinal.FixedPoint","initialProofState":"o : Ordinal.{u}\nf : (b : Ordinal.{u}) → LT.lt b o → Ordinal.{max u v} → Ordinal.{max u v}\nho : Ne o 0\nH : ∀ (i : Ordinal.{u}) (hi : LT.lt i o), Ordinal.IsNormal (f i hi)\na b : Ordinal.{max u v}\n⊢ Iff (∀ (i : Ordinal.{u}) (hi : LT.lt i o), LE.le (f i hi b) (o.nfpBFamily f a)) (LE.le b (o.nfpBFamily f a))","decl":"set_option linter.deprecated false in\n@[deprecated \"No deprecation message was provided.\"  (since := \"2024-10-14\")]\ntheorem apply_le_nfpBFamily (ho : o ≠ 0) (H : ∀ i hi, IsNormal (f i hi)) {a b} :\n    (∀ i hi, f i hi b ≤ nfpBFamily.{u, v} o f a) ↔ b ≤ nfpBFamily.{u, v} o f a := by\n  refine ⟨fun h => ?_, fun h i hi => ?_⟩\n  · have ho' : 0 < o := Ordinal.pos_iff_ne_zero.2 ho\n    exact (H 0 ho').le_apply.trans (h 0 ho')\n  · rw [← nfpBFamily_fp (H i hi)]\n    exact (H i hi).monotone h\n\n"}
{"name":"Ordinal.nfpBFamily_eq_self","module":"Mathlib.SetTheory.Ordinal.FixedPoint","initialProofState":"o : Ordinal.{u}\nf : (b : Ordinal.{u}) → LT.lt b o → Ordinal.{max u v} → Ordinal.{max u v}\na : Ordinal.{max u v}\nh : ∀ (i : Ordinal.{u}) (hi : LT.lt i o), Eq (f i hi a) a\n⊢ Eq (o.nfpBFamily f a) a","decl":"set_option linter.deprecated false in\n@[deprecated \"No deprecation message was provided.\"  (since := \"2024-10-14\")]\ntheorem nfpBFamily_eq_self {a} (h : ∀ i hi, f i hi a = a) : nfpBFamily.{u, v} o f a = a :=\n  nfpFamily_eq_self fun _ => h _ _\n\n"}
{"name":"Ordinal.not_bddAbove_fp_bfamily","module":"Mathlib.SetTheory.Ordinal.FixedPoint","initialProofState":"o : Ordinal.{u}\nf : (b : Ordinal.{u}) → LT.lt b o → Ordinal.{max u v} → Ordinal.{max u v}\nH : ∀ (i : Ordinal.{u}) (hi : LT.lt i o), Ordinal.IsNormal (f i hi)\n⊢ Not (BddAbove (Set.iInter fun i => Set.iInter fun hi => Function.fixedPoints (f i hi)))","decl":"set_option linter.deprecated false in\n/-- A generalization of the fixed point lemma for normal functions: any family of normal functions\n    has an unbounded set of common fixed points. -/\n@[deprecated \"No deprecation message was provided.\"  (since := \"2024-10-14\")]\ntheorem not_bddAbove_fp_bfamily (H : ∀ i hi, IsNormal (f i hi)) :\n    ¬ BddAbove (⋂ (i) (hi), Function.fixedPoints (f i hi)) := by\n  rw [not_bddAbove_iff]\n  refine fun a ↦ ⟨nfpBFamily _ f (succ a), ?_, (lt_succ a).trans_le (le_nfpBFamily f _)⟩\n  rw [Set.mem_iInter₂]\n  exact fun i hi ↦ nfpBFamily_fp (H i hi) _\n\n"}
{"name":"Ordinal.fp_bfamily_unbounded","module":"Mathlib.SetTheory.Ordinal.FixedPoint","initialProofState":"o : Ordinal.{u}\nf : (b : Ordinal.{u}) → LT.lt b o → Ordinal.{max u v} → Ordinal.{max u v}\nH : ∀ (i : Ordinal.{u}) (hi : LT.lt i o), Ordinal.IsNormal (f i hi)\n⊢ Set.Unbounded (fun x1 x2 => LT.lt x1 x2) (Set.iInter fun i => Set.iInter fun hi => Function.fixedPoints (f i hi))","decl":"set_option linter.deprecated false in\n/-- A generalization of the fixed point lemma for normal functions: any family of normal functions\n    has an unbounded set of common fixed points. -/\n@[deprecated not_bddAbove_fp_bfamily (since := \"2024-09-20\")]\ntheorem fp_bfamily_unbounded (H : ∀ i hi, IsNormal (f i hi)) :\n    (⋂ (i) (hi), Function.fixedPoints (f i hi)).Unbounded (· < ·) := fun a =>\n  ⟨nfpBFamily.{u, v} _ f a, by\n    rw [Set.mem_iInter₂]\n    exact fun i hi => nfpBFamily_fp (H i hi) _, (le_nfpBFamily f a).not_lt⟩\n\n"}
{"name":"Ordinal.derivBFamily_eq_derivFamily","module":"Mathlib.SetTheory.Ordinal.FixedPoint","initialProofState":"o : Ordinal.{u}\nf : (b : Ordinal.{u}) → LT.lt b o → Ordinal.{max u v} → Ordinal.{max u v}\n⊢ Eq (o.derivBFamily f) (Ordinal.derivFamily (o.familyOfBFamily f))","decl":"set_option linter.deprecated false in\n@[deprecated \"No deprecation message was provided.\"  (since := \"2024-10-14\")]\ntheorem derivBFamily_eq_derivFamily {o : Ordinal} (f : ∀ b < o, Ordinal → Ordinal) :\n    derivBFamily.{u, v} o f = derivFamily (familyOfBFamily o f) :=\n  rfl\n\n"}
{"name":"Ordinal.isNormal_derivBFamily","module":"Mathlib.SetTheory.Ordinal.FixedPoint","initialProofState":"o : Ordinal.{u_1}\nf : (b : Ordinal.{u_1}) → LT.lt b o → Ordinal.{max u_1 u_2} → Ordinal.{max u_1 u_2}\n⊢ Ordinal.IsNormal (o.derivBFamily f)","decl":"set_option linter.deprecated false in\n@[deprecated \"No deprecation message was provided.\"  (since := \"2024-10-14\")]\ntheorem isNormal_derivBFamily {o : Ordinal} (f : ∀ b < o, Ordinal → Ordinal) :\n    IsNormal (derivBFamily o f) :=\n  isNormal_derivFamily _\n\n"}
{"name":"Ordinal.derivBFamily_isNormal","module":"Mathlib.SetTheory.Ordinal.FixedPoint","initialProofState":"o : Ordinal.{u_1}\nf : (b : Ordinal.{u_1}) → LT.lt b o → Ordinal.{max u_1 u_2} → Ordinal.{max u_1 u_2}\n⊢ Ordinal.IsNormal (o.derivBFamily f)","decl":"@[deprecated isNormal_derivBFamily (since := \"2024-10-11\")]\nalias derivBFamily_isNormal := isNormal_derivBFamily\n\n"}
{"name":"Ordinal.derivBFamily_fp","module":"Mathlib.SetTheory.Ordinal.FixedPoint","initialProofState":"o : Ordinal.{u}\nf : (b : Ordinal.{u}) → LT.lt b o → Ordinal.{max u v} → Ordinal.{max u v}\ni : Ordinal.{u}\nhi : LT.lt i o\nH : Ordinal.IsNormal (f i hi)\na : Ordinal.{max u v}\n⊢ Eq (f i hi (o.derivBFamily f a)) (o.derivBFamily f a)","decl":"set_option linter.deprecated false in\n@[deprecated \"No deprecation message was provided.\"  (since := \"2024-10-14\")]\ntheorem derivBFamily_fp {i hi} (H : IsNormal (f i hi)) (a : Ordinal) :\n    f i hi (derivBFamily.{u, v} o f a) = derivBFamily.{u, v} o f a := by\n  rw [← familyOfBFamily_enum o f]\n  apply derivFamily_fp\n  rw [familyOfBFamily_enum]\n  exact H\n\n"}
{"name":"Ordinal.le_iff_derivBFamily","module":"Mathlib.SetTheory.Ordinal.FixedPoint","initialProofState":"o : Ordinal.{u}\nf : (b : Ordinal.{u}) → LT.lt b o → Ordinal.{max u v} → Ordinal.{max u v}\nH : ∀ (i : Ordinal.{u}) (hi : LT.lt i o), Ordinal.IsNormal (f i hi)\na : Ordinal.{max u v}\n⊢ Iff (∀ (i : Ordinal.{u}) (hi : LT.lt i o), LE.le (f i hi a) a) (Exists fun b => Eq (o.derivBFamily f b) a)","decl":"set_option linter.deprecated false in\n@[deprecated \"No deprecation message was provided.\"  (since := \"2024-10-14\")]\ntheorem le_iff_derivBFamily (H : ∀ i hi, IsNormal (f i hi)) {a} :\n    (∀ i hi, f i hi a ≤ a) ↔ ∃ b, derivBFamily.{u, v} o f b = a := by\n  unfold derivBFamily\n  rw [← le_iff_derivFamily]\n  · refine ⟨fun h i => h _ _, fun h i hi => ?_⟩\n    rw [← familyOfBFamily_enum o f]\n    apply h\n  · exact fun _ => H _ _\n\n"}
{"name":"Ordinal.fp_iff_derivBFamily","module":"Mathlib.SetTheory.Ordinal.FixedPoint","initialProofState":"o : Ordinal.{u}\nf : (b : Ordinal.{u}) → LT.lt b o → Ordinal.{max u v} → Ordinal.{max u v}\nH : ∀ (i : Ordinal.{u}) (hi : LT.lt i o), Ordinal.IsNormal (f i hi)\na : Ordinal.{max u v}\n⊢ Iff (∀ (i : Ordinal.{u}) (hi : LT.lt i o), Eq (f i hi a) a) (Exists fun b => Eq (o.derivBFamily f b) a)","decl":"set_option linter.deprecated false in\n@[deprecated \"No deprecation message was provided.\"  (since := \"2024-10-14\")]\ntheorem fp_iff_derivBFamily (H : ∀ i hi, IsNormal (f i hi)) {a} :\n    (∀ i hi, f i hi a = a) ↔ ∃ b, derivBFamily.{u, v} o f b = a := by\n  rw [← le_iff_derivBFamily H]\n  refine ⟨fun h i hi => le_of_eq (h i hi), fun h i hi => ?_⟩\n  rw [← (H i hi).le_iff_eq]\n  exact h i hi\n\n"}
{"name":"Ordinal.derivBFamily_eq_enumOrd","module":"Mathlib.SetTheory.Ordinal.FixedPoint","initialProofState":"o : Ordinal.{u}\nf : (b : Ordinal.{u}) → LT.lt b o → Ordinal.{max u v} → Ordinal.{max u v}\nH : ∀ (i : Ordinal.{u}) (hi : LT.lt i o), Ordinal.IsNormal (f i hi)\n⊢ Eq (o.derivBFamily f) (Ordinal.enumOrd (Set.iInter fun i => Set.iInter fun hi => Function.fixedPoints (f i hi)))","decl":"set_option linter.deprecated false in\n/-- For a family of normal functions, `Ordinal.derivBFamily` enumerates the common fixed points. -/\n@[deprecated \"No deprecation message was provided.\"  (since := \"2024-10-14\")]\ntheorem derivBFamily_eq_enumOrd (H : ∀ i hi, IsNormal (f i hi)) :\n    derivBFamily.{u, v} o f = enumOrd (⋂ (i) (hi), Function.fixedPoints (f i hi)) := by\n  rw [eq_comm, eq_enumOrd _ (not_bddAbove_fp_bfamily H)]\n  use (isNormal_derivBFamily f).strictMono\n  rw [Set.range_eq_iff]\n  refine ⟨fun a => Set.mem_iInter₂.2 fun i hi => derivBFamily_fp (H i hi) a, fun a ha => ?_⟩\n  rw [Set.mem_iInter₂] at ha\n  rwa [← fp_iff_derivBFamily H]\n\n"}
{"name":"Ordinal.nfp_eq_nfpFamily","module":"Mathlib.SetTheory.Ordinal.FixedPoint","initialProofState":"f : Ordinal.{u_1} → Ordinal.{u_1}\n⊢ Eq (Ordinal.nfp f) (Ordinal.nfpFamily fun x => f)","decl":"theorem nfp_eq_nfpFamily (f : Ordinal → Ordinal) : nfp f = nfpFamily fun _ : Unit => f :=\n  rfl\n\n"}
{"name":"Ordinal.iSup_iterate_eq_nfp","module":"Mathlib.SetTheory.Ordinal.FixedPoint","initialProofState":"f : Ordinal.{u} → Ordinal.{u}\na : Ordinal.{u}\n⊢ Eq (iSup fun n => Nat.iterate f n a) (Ordinal.nfp f a)","decl":"theorem iSup_iterate_eq_nfp (f : Ordinal.{u} → Ordinal.{u}) (a : Ordinal.{u}) :\n    ⨆ n : ℕ, f^[n] a = nfp f a := by\n  apply le_antisymm\n  · rw [Ordinal.iSup_le_iff]\n    intro n\n    rw [← List.length_replicate n Unit.unit, ← List.foldr_const f a]\n    exact Ordinal.le_iSup _ _\n  · apply Ordinal.iSup_le\n    intro l\n    rw [List.foldr_const f a l]\n    exact Ordinal.le_iSup _ _\n\n"}
{"name":"Ordinal.sup_iterate_eq_nfp","module":"Mathlib.SetTheory.Ordinal.FixedPoint","initialProofState":"f : Ordinal.{u} → Ordinal.{u}\na : Ordinal.{u}\n⊢ Eq (Ordinal.sup fun n => Nat.iterate f n a) (Ordinal.nfp f a)","decl":"set_option linter.deprecated false in\n@[deprecated \"No deprecation message was provided.\"  (since := \"2024-08-27\")]\ntheorem sup_iterate_eq_nfp (f : Ordinal.{u} → Ordinal.{u}) (a : Ordinal.{u}) :\n    (sup fun n : ℕ => f^[n] a) = nfp f a := by\n  refine le_antisymm ?_ (sup_le fun l => ?_)\n  · rw [sup_le_iff]\n    intro n\n    rw [← List.length_replicate n Unit.unit, ← List.foldr_const f a]\n    apply le_sup\n  · rw [List.foldr_const f a l]\n    exact le_sup _ _\n\n"}
{"name":"Ordinal.iterate_le_nfp","module":"Mathlib.SetTheory.Ordinal.FixedPoint","initialProofState":"f : Ordinal.{u_1} → Ordinal.{u_1}\na : Ordinal.{u_1}\nn : Nat\n⊢ LE.le (Nat.iterate f n a) (Ordinal.nfp f a)","decl":"theorem iterate_le_nfp (f a n) : f^[n] a ≤ nfp f a := by\n  rw [← iSup_iterate_eq_nfp]\n  exact Ordinal.le_iSup (fun n ↦ f^[n] a) n\n\n"}
{"name":"Ordinal.le_nfp","module":"Mathlib.SetTheory.Ordinal.FixedPoint","initialProofState":"f : Ordinal.{u_1} → Ordinal.{u_1}\na : Ordinal.{u_1}\n⊢ LE.le a (Ordinal.nfp f a)","decl":"theorem le_nfp (f a) : a ≤ nfp f a :=\n  iterate_le_nfp f a 0\n\n"}
{"name":"Ordinal.lt_nfp","module":"Mathlib.SetTheory.Ordinal.FixedPoint","initialProofState":"f : Ordinal.{u} → Ordinal.{u}\na b : Ordinal.{u}\n⊢ Iff (LT.lt a (Ordinal.nfp f b)) (Exists fun n => LT.lt a (Nat.iterate f n b))","decl":"theorem lt_nfp {a b} : a < nfp f b ↔ ∃ n, a < f^[n] b := by\n  rw [← iSup_iterate_eq_nfp]\n  exact Ordinal.lt_iSup_iff\n\n"}
{"name":"Ordinal.nfp_le_iff","module":"Mathlib.SetTheory.Ordinal.FixedPoint","initialProofState":"f : Ordinal.{u} → Ordinal.{u}\na b : Ordinal.{u}\n⊢ Iff (LE.le (Ordinal.nfp f a) b) (∀ (n : Nat), LE.le (Nat.iterate f n a) b)","decl":"theorem nfp_le_iff {a b} : nfp f a ≤ b ↔ ∀ n, f^[n] a ≤ b := by\n  rw [← iSup_iterate_eq_nfp]\n  exact Ordinal.iSup_le_iff\n\n"}
{"name":"Ordinal.nfp_le","module":"Mathlib.SetTheory.Ordinal.FixedPoint","initialProofState":"f : Ordinal.{u} → Ordinal.{u}\na b : Ordinal.{u}\na✝ : ∀ (n : Nat), LE.le (Nat.iterate f n a) b\n⊢ LE.le (Ordinal.nfp f a) b","decl":"theorem nfp_le {a b} : (∀ n, f^[n] a ≤ b) → nfp f a ≤ b :=\n  nfp_le_iff.2\n\n"}
{"name":"Ordinal.nfp_id","module":"Mathlib.SetTheory.Ordinal.FixedPoint","initialProofState":"⊢ Eq (Ordinal.nfp id) id","decl":"@[simp]\ntheorem nfp_id : nfp id = id := by\n  ext\n  simp_rw [← iSup_iterate_eq_nfp, iterate_id]\n  exact ciSup_const\n\n"}
{"name":"Ordinal.nfp_monotone","module":"Mathlib.SetTheory.Ordinal.FixedPoint","initialProofState":"f : Ordinal.{u} → Ordinal.{u}\nhf : Monotone f\n⊢ Monotone (Ordinal.nfp f)","decl":"theorem nfp_monotone (hf : Monotone f) : Monotone (nfp f) :=\n  nfpFamily_monotone fun _ => hf\n\n"}
{"name":"Ordinal.IsNormal.apply_lt_nfp","module":"Mathlib.SetTheory.Ordinal.FixedPoint","initialProofState":"f : Ordinal.{u_1} → Ordinal.{u_1}\nH : Ordinal.IsNormal f\na b : Ordinal.{u_1}\n⊢ Iff (LT.lt (f b) (Ordinal.nfp f a)) (LT.lt b (Ordinal.nfp f a))","decl":"theorem IsNormal.apply_lt_nfp {f} (H : IsNormal f) {a b} : f b < nfp f a ↔ b < nfp f a := by\n  unfold nfp\n  rw [← @apply_lt_nfpFamily_iff Unit (fun _ => f) _ _ (fun _ => H) a b]\n  exact ⟨fun h _ => h, fun h => h Unit.unit⟩\n\n"}
{"name":"Ordinal.IsNormal.nfp_le_apply","module":"Mathlib.SetTheory.Ordinal.FixedPoint","initialProofState":"f : Ordinal.{u_1} → Ordinal.{u_1}\nH : Ordinal.IsNormal f\na b : Ordinal.{u_1}\n⊢ Iff (LE.le (Ordinal.nfp f a) (f b)) (LE.le (Ordinal.nfp f a) b)","decl":"theorem IsNormal.nfp_le_apply {f} (H : IsNormal f) {a b} : nfp f a ≤ f b ↔ nfp f a ≤ b :=\n  le_iff_le_iff_lt_iff_lt.2 H.apply_lt_nfp\n\n"}
{"name":"Ordinal.nfp_le_fp","module":"Mathlib.SetTheory.Ordinal.FixedPoint","initialProofState":"f : Ordinal.{u_1} → Ordinal.{u_1}\nH : Monotone f\na b : Ordinal.{u_1}\nab : LE.le a b\nh : LE.le (f b) b\n⊢ LE.le (Ordinal.nfp f a) b","decl":"theorem nfp_le_fp {f} (H : Monotone f) {a b} (ab : a ≤ b) (h : f b ≤ b) : nfp f a ≤ b :=\n  nfpFamily_le_fp (fun _ => H) ab fun _ => h\n\n"}
{"name":"Ordinal.IsNormal.nfp_fp","module":"Mathlib.SetTheory.Ordinal.FixedPoint","initialProofState":"f : Ordinal.{u_1} → Ordinal.{u_1}\nH : Ordinal.IsNormal f\na : Ordinal.{u_1}\n⊢ Eq (f (Ordinal.nfp f a)) (Ordinal.nfp f a)","decl":"theorem IsNormal.nfp_fp {f} (H : IsNormal f) : ∀ a, f (nfp f a) = nfp f a :=\n  @nfpFamily_fp Unit (fun _ => f) _ () H\n\n"}
{"name":"Ordinal.IsNormal.apply_le_nfp","module":"Mathlib.SetTheory.Ordinal.FixedPoint","initialProofState":"f : Ordinal.{u_1} → Ordinal.{u_1}\nH : Ordinal.IsNormal f\na b : Ordinal.{u_1}\n⊢ Iff (LE.le (f b) (Ordinal.nfp f a)) (LE.le b (Ordinal.nfp f a))","decl":"theorem IsNormal.apply_le_nfp {f} (H : IsNormal f) {a b} : f b ≤ nfp f a ↔ b ≤ nfp f a :=\n  ⟨H.le_apply.trans, fun h => by simpa only [H.nfp_fp] using H.le_iff.2 h⟩\n\n"}
{"name":"Ordinal.nfp_eq_self","module":"Mathlib.SetTheory.Ordinal.FixedPoint","initialProofState":"f : Ordinal.{u_1} → Ordinal.{u_1}\na : Ordinal.{u_1}\nh : Eq (f a) a\n⊢ Eq (Ordinal.nfp f a) a","decl":"theorem nfp_eq_self {f : Ordinal → Ordinal} {a} (h : f a = a) : nfp f a = a :=\n  nfpFamily_eq_self fun _ => h\n\n"}
{"name":"Ordinal.not_bddAbove_fp","module":"Mathlib.SetTheory.Ordinal.FixedPoint","initialProofState":"f : Ordinal.{u} → Ordinal.{u}\nH : Ordinal.IsNormal f\n⊢ Not (BddAbove (Function.fixedPoints f))","decl":"/-- The fixed point lemma for normal functions: any normal function has an unbounded set of\nfixed points. -/\ntheorem not_bddAbove_fp (H : IsNormal f) : ¬ BddAbove (Function.fixedPoints f) := by\n  convert not_bddAbove_fp_family fun _ : Unit => H\n  exact (Set.iInter_const _).symm\n\n"}
{"name":"Ordinal.deriv_eq_derivFamily","module":"Mathlib.SetTheory.Ordinal.FixedPoint","initialProofState":"f : Ordinal.{u_1} → Ordinal.{u_1}\n⊢ Eq (Ordinal.deriv f) (Ordinal.derivFamily fun x => f)","decl":"theorem deriv_eq_derivFamily (f : Ordinal → Ordinal) : deriv f = derivFamily fun _ : Unit => f :=\n  rfl\n\n"}
{"name":"Ordinal.deriv_zero_right","module":"Mathlib.SetTheory.Ordinal.FixedPoint","initialProofState":"f : Ordinal.{u_1} → Ordinal.{u_1}\n⊢ Eq (Ordinal.deriv f 0) (Ordinal.nfp f 0)","decl":"@[simp]\ntheorem deriv_zero_right (f) : deriv f 0 = nfp f 0 :=\n  derivFamily_zero _\n\n"}
{"name":"Ordinal.deriv_succ","module":"Mathlib.SetTheory.Ordinal.FixedPoint","initialProofState":"f : Ordinal.{u_1} → Ordinal.{u_1}\no : Ordinal.{u_1}\n⊢ Eq (Ordinal.deriv f (Order.succ o)) (Ordinal.nfp f (Order.succ (Ordinal.deriv f o)))","decl":"@[simp]\ntheorem deriv_succ (f o) : deriv f (succ o) = nfp f (succ (deriv f o)) :=\n  derivFamily_succ _ _\n\n"}
{"name":"Ordinal.deriv_limit","module":"Mathlib.SetTheory.Ordinal.FixedPoint","initialProofState":"f : Ordinal.{u_1} → Ordinal.{u_1}\no : Ordinal.{u_1}\na✝ : o.IsLimit\n⊢ Eq (Ordinal.deriv f o) (iSup fun a => Ordinal.deriv f ↑a)","decl":"theorem deriv_limit (f) {o} : IsLimit o → deriv f o = ⨆ a : {a // a < o}, deriv f a :=\n  derivFamily_limit _\n\n"}
{"name":"Ordinal.isNormal_deriv","module":"Mathlib.SetTheory.Ordinal.FixedPoint","initialProofState":"f : Ordinal.{u_1} → Ordinal.{u_1}\n⊢ Ordinal.IsNormal (Ordinal.deriv f)","decl":"theorem isNormal_deriv (f) : IsNormal (deriv f) :=\n  isNormal_derivFamily _\n\n"}
{"name":"Ordinal.deriv_isNormal","module":"Mathlib.SetTheory.Ordinal.FixedPoint","initialProofState":"f : Ordinal.{u_1} → Ordinal.{u_1}\n⊢ Ordinal.IsNormal (Ordinal.deriv f)","decl":"@[deprecated isNormal_deriv (since := \"2024-10-11\")]\nalias deriv_isNormal := isNormal_deriv\n\n"}
{"name":"Ordinal.deriv_id_of_nfp_id","module":"Mathlib.SetTheory.Ordinal.FixedPoint","initialProofState":"f : Ordinal.{u_1} → Ordinal.{u_1}\nh : Eq (Ordinal.nfp f) id\n⊢ Eq (Ordinal.deriv f) id","decl":"theorem deriv_id_of_nfp_id {f : Ordinal → Ordinal} (h : nfp f = id) : deriv f = id :=\n  ((isNormal_deriv _).eq_iff_zero_and_succ IsNormal.refl).2 (by simp [h])\n\n"}
{"name":"Ordinal.IsNormal.deriv_fp","module":"Mathlib.SetTheory.Ordinal.FixedPoint","initialProofState":"f : Ordinal.{u_1} → Ordinal.{u_1}\nH : Ordinal.IsNormal f\no : Ordinal.{u_1}\n⊢ Eq (f (Ordinal.deriv f o)) (Ordinal.deriv f o)","decl":"theorem IsNormal.deriv_fp {f} (H : IsNormal f) : ∀ o, f (deriv f o) = deriv f o :=\n  derivFamily_fp (i := ⟨⟩) H\n\n"}
{"name":"Ordinal.IsNormal.le_iff_deriv","module":"Mathlib.SetTheory.Ordinal.FixedPoint","initialProofState":"f : Ordinal.{u_1} → Ordinal.{u_1}\nH : Ordinal.IsNormal f\na : Ordinal.{u_1}\n⊢ Iff (LE.le (f a) a) (Exists fun o => Eq (Ordinal.deriv f o) a)","decl":"theorem IsNormal.le_iff_deriv {f} (H : IsNormal f) {a} : f a ≤ a ↔ ∃ o, deriv f o = a := by\n  unfold deriv\n  rw [← le_iff_derivFamily fun _ : Unit => H]\n  exact ⟨fun h _ => h, fun h => h Unit.unit⟩\n\n"}
{"name":"Ordinal.IsNormal.fp_iff_deriv","module":"Mathlib.SetTheory.Ordinal.FixedPoint","initialProofState":"f : Ordinal.{u_1} → Ordinal.{u_1}\nH : Ordinal.IsNormal f\na : Ordinal.{u_1}\n⊢ Iff (Eq (f a) a) (Exists fun o => Eq (Ordinal.deriv f o) a)","decl":"theorem IsNormal.fp_iff_deriv {f} (H : IsNormal f) {a} : f a = a ↔ ∃ o, deriv f o = a := by\n  rw [← H.le_iff_eq, H.le_iff_deriv]\n\n"}
{"name":"Ordinal.deriv_eq_enumOrd","module":"Mathlib.SetTheory.Ordinal.FixedPoint","initialProofState":"f : Ordinal.{u} → Ordinal.{u}\nH : Ordinal.IsNormal f\n⊢ Eq (Ordinal.deriv f) (Ordinal.enumOrd (Function.fixedPoints f))","decl":"/-- `Ordinal.deriv` enumerates the fixed points of a normal function. -/\ntheorem deriv_eq_enumOrd (H : IsNormal f) : deriv f = enumOrd (Function.fixedPoints f) := by\n  convert derivFamily_eq_enumOrd fun _ : Unit => H\n  exact (Set.iInter_const _).symm\n\n"}
{"name":"Ordinal.deriv_eq_id_of_nfp_eq_id","module":"Mathlib.SetTheory.Ordinal.FixedPoint","initialProofState":"f : Ordinal.{u_1} → Ordinal.{u_1}\nh : Eq (Ordinal.nfp f) id\n⊢ Eq (Ordinal.deriv f) id","decl":"theorem deriv_eq_id_of_nfp_eq_id {f : Ordinal → Ordinal} (h : nfp f = id) : deriv f = id :=\n  (IsNormal.eq_iff_zero_and_succ (isNormal_deriv _) IsNormal.refl).2 <| by simp [h]\n\n"}
{"name":"Ordinal.nfp_zero_left","module":"Mathlib.SetTheory.Ordinal.FixedPoint","initialProofState":"a : Ordinal.{u_1}\n⊢ Eq (Ordinal.nfp 0 a) a","decl":"theorem nfp_zero_left (a) : nfp 0 a = a := by\n  rw [← iSup_iterate_eq_nfp]\n  apply (Ordinal.iSup_le ?_).antisymm (Ordinal.le_iSup _ 0)\n  intro n\n  cases n\n  · rfl\n  · rw [Function.iterate_succ']\n    simp\n\n"}
{"name":"Ordinal.nfp_zero","module":"Mathlib.SetTheory.Ordinal.FixedPoint","initialProofState":"⊢ Eq (Ordinal.nfp 0) id","decl":"@[simp]\ntheorem nfp_zero : nfp 0 = id := by\n  ext\n  exact nfp_zero_left _\n\n"}
{"name":"Ordinal.deriv_zero","module":"Mathlib.SetTheory.Ordinal.FixedPoint","initialProofState":"⊢ Eq (Ordinal.deriv 0) id","decl":"@[simp]\ntheorem deriv_zero : deriv 0 = id :=\n  deriv_eq_id_of_nfp_eq_id nfp_zero\n\n"}
{"name":"Ordinal.deriv_zero_left","module":"Mathlib.SetTheory.Ordinal.FixedPoint","initialProofState":"a : Ordinal.{u_1}\n⊢ Eq (Ordinal.deriv 0 a) a","decl":"theorem deriv_zero_left (a) : deriv 0 a = a := by\n  rw [deriv_zero, id_eq]\n\n"}
{"name":"Ordinal.nfp_add_zero","module":"Mathlib.SetTheory.Ordinal.FixedPoint","initialProofState":"a : Ordinal.{u_1}\n⊢ Eq (Ordinal.nfp (fun x => HAdd.hAdd a x) 0) (HMul.hMul a Ordinal.omega0)","decl":"@[simp]\ntheorem nfp_add_zero (a) : nfp (a + ·) 0 = a * ω := by\n  simp_rw [← iSup_iterate_eq_nfp, ← iSup_mul_nat]\n  congr; funext n\n  induction' n with n hn\n  · rw [Nat.cast_zero, mul_zero, iterate_zero_apply]\n  · rw [iterate_succ_apply', Nat.add_comm, Nat.cast_add, Nat.cast_one, mul_one_add, hn]\n\n"}
{"name":"Ordinal.nfp_add_eq_mul_omega0","module":"Mathlib.SetTheory.Ordinal.FixedPoint","initialProofState":"a b : Ordinal.{u_1}\nhba : LE.le b (HMul.hMul a Ordinal.omega0)\n⊢ Eq (Ordinal.nfp (fun x => HAdd.hAdd a x) b) (HMul.hMul a Ordinal.omega0)","decl":"theorem nfp_add_eq_mul_omega0 {a b} (hba : b ≤ a * ω) : nfp (a + ·) b = a * ω := by\n  apply le_antisymm (nfp_le_fp (isNormal_add_right a).monotone hba _)\n  · rw [← nfp_add_zero]\n    exact nfp_monotone (isNormal_add_right a).monotone (Ordinal.zero_le b)\n  · dsimp; rw [← mul_one_add, one_add_omega0]\n\n"}
{"name":"Ordinal.nfp_add_eq_mul_omega","module":"Mathlib.SetTheory.Ordinal.FixedPoint","initialProofState":"a b : Ordinal.{u_1}\nhba : LE.le b (HMul.hMul a Ordinal.omega0)\n⊢ Eq (Ordinal.nfp (fun x => HAdd.hAdd a x) b) (HMul.hMul a Ordinal.omega0)","decl":"@[deprecated \"No deprecation message was provided.\"  (since := \"2024-09-30\")]\nalias nfp_add_eq_mul_omega := nfp_add_eq_mul_omega0\n\n"}
{"name":"Ordinal.add_eq_right_iff_mul_omega0_le","module":"Mathlib.SetTheory.Ordinal.FixedPoint","initialProofState":"a b : Ordinal.{u_1}\n⊢ Iff (Eq (HAdd.hAdd a b) b) (LE.le (HMul.hMul a Ordinal.omega0) b)","decl":"theorem add_eq_right_iff_mul_omega0_le {a b : Ordinal} : a + b = b ↔ a * ω ≤ b := by\n  refine ⟨fun h => ?_, fun h => ?_⟩\n  · rw [← nfp_add_zero a, ← deriv_zero_right]\n    cases' (isNormal_add_right a).fp_iff_deriv.1 h with c hc\n    rw [← hc]\n    exact (isNormal_deriv _).monotone (Ordinal.zero_le _)\n  · have := Ordinal.add_sub_cancel_of_le h\n    nth_rw 1 [← this]\n    rwa [← add_assoc, ← mul_one_add, one_add_omega0]\n\n"}
{"name":"Ordinal.add_eq_right_iff_mul_omega_le","module":"Mathlib.SetTheory.Ordinal.FixedPoint","initialProofState":"a b : Ordinal.{u_1}\n⊢ Iff (Eq (HAdd.hAdd a b) b) (LE.le (HMul.hMul a Ordinal.omega0) b)","decl":"@[deprecated \"No deprecation message was provided.\"  (since := \"2024-09-30\")]\nalias add_eq_right_iff_mul_omega_le := add_eq_right_iff_mul_omega0_le\n\n"}
{"name":"Ordinal.add_le_right_iff_mul_omega0_le","module":"Mathlib.SetTheory.Ordinal.FixedPoint","initialProofState":"a b : Ordinal.{u_1}\n⊢ Iff (LE.le (HAdd.hAdd a b) b) (LE.le (HMul.hMul a Ordinal.omega0) b)","decl":"theorem add_le_right_iff_mul_omega0_le {a b : Ordinal} : a + b ≤ b ↔ a * ω ≤ b := by\n  rw [← add_eq_right_iff_mul_omega0_le]\n  exact (isNormal_add_right a).le_iff_eq\n\n"}
{"name":"Ordinal.add_le_right_iff_mul_omega_le","module":"Mathlib.SetTheory.Ordinal.FixedPoint","initialProofState":"a b : Ordinal.{u_1}\n⊢ Iff (LE.le (HAdd.hAdd a b) b) (LE.le (HMul.hMul a Ordinal.omega0) b)","decl":"@[deprecated \"No deprecation message was provided.\"  (since := \"2024-09-30\")]\nalias add_le_right_iff_mul_omega_le := add_le_right_iff_mul_omega0_le\n\n"}
{"name":"Ordinal.deriv_add_eq_mul_omega0_add","module":"Mathlib.SetTheory.Ordinal.FixedPoint","initialProofState":"a b : Ordinal.{u}\n⊢ Eq (Ordinal.deriv (fun x => HAdd.hAdd a x) b) (HAdd.hAdd (HMul.hMul a Ordinal.omega0) b)","decl":"theorem deriv_add_eq_mul_omega0_add (a b : Ordinal.{u}) : deriv (a + ·) b = a * ω + b := by\n  revert b\n  rw [← funext_iff, IsNormal.eq_iff_zero_and_succ (isNormal_deriv _) (isNormal_add_right _)]\n  refine ⟨?_, fun a h => ?_⟩\n  · rw [deriv_zero_right, add_zero]\n    exact nfp_add_zero a\n  · rw [deriv_succ, h, add_succ]\n    exact nfp_eq_self (add_eq_right_iff_mul_omega0_le.2 ((le_add_right _ _).trans (le_succ _)))\n\n"}
{"name":"Ordinal.deriv_add_eq_mul_omega_add","module":"Mathlib.SetTheory.Ordinal.FixedPoint","initialProofState":"a b : Ordinal.{u}\n⊢ Eq (Ordinal.deriv (fun x => HAdd.hAdd a x) b) (HAdd.hAdd (HMul.hMul a Ordinal.omega0) b)","decl":"@[deprecated \"No deprecation message was provided.\"  (since := \"2024-09-30\")]\nalias deriv_add_eq_mul_omega_add := deriv_add_eq_mul_omega0_add\n\n"}
{"name":"Ordinal.nfp_mul_one","module":"Mathlib.SetTheory.Ordinal.FixedPoint","initialProofState":"a : Ordinal.{u_1}\nha : LT.lt 0 a\n⊢ Eq (Ordinal.nfp (fun x => HMul.hMul a x) 1) (HPow.hPow a Ordinal.omega0)","decl":"@[simp]\ntheorem nfp_mul_one {a : Ordinal} (ha : 0 < a) : nfp (a * ·) 1 = a ^ ω := by\n  rw [← iSup_iterate_eq_nfp, ← iSup_pow ha]\n  congr\n  funext n\n  induction' n with n hn\n  · rw [pow_zero, iterate_zero_apply]\n  · rw [iterate_succ_apply', Nat.add_comm, pow_add, pow_one, hn]\n\n"}
{"name":"Ordinal.nfp_mul_zero","module":"Mathlib.SetTheory.Ordinal.FixedPoint","initialProofState":"a : Ordinal.{u_1}\n⊢ Eq (Ordinal.nfp (fun x => HMul.hMul a x) 0) 0","decl":"@[simp]\ntheorem nfp_mul_zero (a : Ordinal) : nfp (a * ·) 0 = 0 := by\n  rw [← Ordinal.le_zero, nfp_le_iff]\n  intro n\n  induction' n with n hn; · rfl\n  dsimp only; rwa [iterate_succ_apply, mul_zero]\n\n"}
{"name":"Ordinal.nfp_mul_eq_opow_omega0","module":"Mathlib.SetTheory.Ordinal.FixedPoint","initialProofState":"a b : Ordinal.{u_1}\nhb : LT.lt 0 b\nhba : LE.le b (HPow.hPow a Ordinal.omega0)\n⊢ Eq (Ordinal.nfp (fun x => HMul.hMul a x) b) (HPow.hPow a Ordinal.omega0)","decl":"theorem nfp_mul_eq_opow_omega0 {a b : Ordinal} (hb : 0 < b) (hba : b ≤ a ^ ω) :\n    nfp (a * ·) b = a ^ ω := by\n  rcases eq_zero_or_pos a with ha | ha\n  · rw [ha, zero_opow omega0_ne_zero] at hba ⊢\n    simp_rw [Ordinal.le_zero.1 hba, zero_mul]\n    exact nfp_zero_left 0\n  apply le_antisymm\n  · apply nfp_le_fp (isNormal_mul_right ha).monotone hba\n    rw [← opow_one_add, one_add_omega0]\n  rw [← nfp_mul_one ha]\n  exact nfp_monotone (isNormal_mul_right ha).monotone (one_le_iff_pos.2 hb)\n\n"}
{"name":"Ordinal.nfp_mul_eq_opow_omega","module":"Mathlib.SetTheory.Ordinal.FixedPoint","initialProofState":"a b : Ordinal.{u_1}\nhb : LT.lt 0 b\nhba : LE.le b (HPow.hPow a Ordinal.omega0)\n⊢ Eq (Ordinal.nfp (fun x => HMul.hMul a x) b) (HPow.hPow a Ordinal.omega0)","decl":"@[deprecated \"No deprecation message was provided.\"  (since := \"2024-09-30\")]\nalias nfp_mul_eq_opow_omega := nfp_mul_eq_opow_omega0\n\n"}
{"name":"Ordinal.eq_zero_or_opow_omega0_le_of_mul_eq_right","module":"Mathlib.SetTheory.Ordinal.FixedPoint","initialProofState":"a b : Ordinal.{u_1}\nhab : Eq (HMul.hMul a b) b\n⊢ Or (Eq b 0) (LE.le (HPow.hPow a Ordinal.omega0) b)","decl":"theorem eq_zero_or_opow_omega0_le_of_mul_eq_right {a b : Ordinal} (hab : a * b = b) :\n    b = 0 ∨ a ^ ω ≤ b := by\n  rcases eq_zero_or_pos a with ha | ha\n  · rw [ha, zero_opow omega0_ne_zero]\n    exact Or.inr (Ordinal.zero_le b)\n  rw [or_iff_not_imp_left]\n  intro hb\n  rw [← nfp_mul_one ha]\n  rw [← Ne, ← one_le_iff_ne_zero] at hb\n  exact nfp_le_fp (isNormal_mul_right ha).monotone hb (le_of_eq hab)\n\n"}
{"name":"Ordinal.eq_zero_or_opow_omega_le_of_mul_eq_right","module":"Mathlib.SetTheory.Ordinal.FixedPoint","initialProofState":"a b : Ordinal.{u_1}\nhab : Eq (HMul.hMul a b) b\n⊢ Or (Eq b 0) (LE.le (HPow.hPow a Ordinal.omega0) b)","decl":"@[deprecated \"No deprecation message was provided.\"  (since := \"2024-09-30\")]\nalias eq_zero_or_opow_omega_le_of_mul_eq_right := eq_zero_or_opow_omega0_le_of_mul_eq_right\n\n"}
{"name":"Ordinal.mul_eq_right_iff_opow_omega0_dvd","module":"Mathlib.SetTheory.Ordinal.FixedPoint","initialProofState":"a b : Ordinal.{u_1}\n⊢ Iff (Eq (HMul.hMul a b) b) (Dvd.dvd (HPow.hPow a Ordinal.omega0) b)","decl":"theorem mul_eq_right_iff_opow_omega0_dvd {a b : Ordinal} : a * b = b ↔ a ^ ω ∣ b := by\n  rcases eq_zero_or_pos a with ha | ha\n  · rw [ha, zero_mul, zero_opow omega0_ne_zero, zero_dvd_iff]\n    exact eq_comm\n  refine ⟨fun hab => ?_, fun h => ?_⟩\n  · rw [dvd_iff_mod_eq_zero]\n    rw [← div_add_mod b (a ^ ω), mul_add, ← mul_assoc, ← opow_one_add, one_add_omega0,\n      add_left_cancel_iff] at hab\n    cases' eq_zero_or_opow_omega0_le_of_mul_eq_right hab with hab hab\n    · exact hab\n    refine (not_lt_of_le hab (mod_lt b (opow_ne_zero ω ?_))).elim\n    rwa [← Ordinal.pos_iff_ne_zero]\n  cases' h with c hc\n  rw [hc, ← mul_assoc, ← opow_one_add, one_add_omega0]\n\n"}
{"name":"Ordinal.mul_eq_right_iff_opow_omega_dvd","module":"Mathlib.SetTheory.Ordinal.FixedPoint","initialProofState":"a b : Ordinal.{u_1}\n⊢ Iff (Eq (HMul.hMul a b) b) (Dvd.dvd (HPow.hPow a Ordinal.omega0) b)","decl":"@[deprecated \"No deprecation message was provided.\"  (since := \"2024-09-30\")]\nalias mul_eq_right_iff_opow_omega_dvd := mul_eq_right_iff_opow_omega0_dvd\n\n"}
{"name":"Ordinal.mul_le_right_iff_opow_omega0_dvd","module":"Mathlib.SetTheory.Ordinal.FixedPoint","initialProofState":"a b : Ordinal.{u_1}\nha : LT.lt 0 a\n⊢ Iff (LE.le (HMul.hMul a b) b) (Dvd.dvd (HPow.hPow a Ordinal.omega0) b)","decl":"theorem mul_le_right_iff_opow_omega0_dvd {a b : Ordinal} (ha : 0 < a) :\n    a * b ≤ b ↔ (a ^ ω) ∣ b := by\n  rw [← mul_eq_right_iff_opow_omega0_dvd]\n  exact (isNormal_mul_right ha).le_iff_eq\n\n"}
{"name":"Ordinal.mul_le_right_iff_opow_omega_dvd","module":"Mathlib.SetTheory.Ordinal.FixedPoint","initialProofState":"a b : Ordinal.{u_1}\nha : LT.lt 0 a\n⊢ Iff (LE.le (HMul.hMul a b) b) (Dvd.dvd (HPow.hPow a Ordinal.omega0) b)","decl":"@[deprecated \"No deprecation message was provided.\"  (since := \"2024-09-30\")]\nalias mul_le_right_iff_opow_omega_dvd := mul_le_right_iff_opow_omega0_dvd\n\n"}
{"name":"Ordinal.nfp_mul_opow_omega0_add","module":"Mathlib.SetTheory.Ordinal.FixedPoint","initialProofState":"a c b : Ordinal.{u_1}\nha : LT.lt 0 a\nhc : LT.lt 0 c\nhca : LE.le c (HPow.hPow a Ordinal.omega0)\n⊢ Eq (Ordinal.nfp (fun x => HMul.hMul a x) (HAdd.hAdd (HMul.hMul (HPow.hPow a Ordinal.omega0) b) c)) (HMul.hMul (HPow.hPow a Ordinal.omega0) (Order.succ b))","decl":"theorem nfp_mul_opow_omega0_add {a c : Ordinal} (b) (ha : 0 < a) (hc : 0 < c)\n    (hca : c ≤ a ^ ω) : nfp (a * ·) (a ^ ω * b + c) = a ^ ω * succ b := by\n  apply le_antisymm\n  · apply nfp_le_fp (isNormal_mul_right ha).monotone\n    · rw [mul_succ]\n      apply add_le_add_left hca\n    · dsimp only; rw [← mul_assoc, ← opow_one_add, one_add_omega0]\n  · obtain ⟨d, hd⟩ :=\n      mul_eq_right_iff_opow_omega0_dvd.1 ((isNormal_mul_right ha).nfp_fp ((a ^ ω) * b + c))\n    rw [hd]\n    apply mul_le_mul_left'\n    have := le_nfp (a * ·) (a ^ ω * b + c)\n    rw [hd] at this\n    have := (add_lt_add_left hc (a ^ ω * b)).trans_le this\n    rw [add_zero, mul_lt_mul_iff_left (opow_pos ω ha)] at this\n    rwa [succ_le_iff]\n\n"}
{"name":"Ordinal.nfp_mul_opow_omega_add","module":"Mathlib.SetTheory.Ordinal.FixedPoint","initialProofState":"a c b : Ordinal.{u_1}\nha : LT.lt 0 a\nhc : LT.lt 0 c\nhca : LE.le c (HPow.hPow a Ordinal.omega0)\n⊢ Eq (Ordinal.nfp (fun x => HMul.hMul a x) (HAdd.hAdd (HMul.hMul (HPow.hPow a Ordinal.omega0) b) c)) (HMul.hMul (HPow.hPow a Ordinal.omega0) (Order.succ b))","decl":"@[deprecated \"No deprecation message was provided.\"  (since := \"2024-09-30\")]\nalias nfp_mul_opow_omega_add := nfp_mul_opow_omega0_add\n\n"}
{"name":"Ordinal.deriv_mul_eq_opow_omega0_mul","module":"Mathlib.SetTheory.Ordinal.FixedPoint","initialProofState":"a : Ordinal.{u}\nha : LT.lt 0 a\nb : Ordinal.{u}\n⊢ Eq (Ordinal.deriv (fun x => HMul.hMul a x) b) (HMul.hMul (HPow.hPow a Ordinal.omega0) b)","decl":"theorem deriv_mul_eq_opow_omega0_mul {a : Ordinal.{u}} (ha : 0 < a) (b) :\n    deriv (a * ·) b = a ^ ω * b := by\n  revert b\n  rw [← funext_iff,\n    IsNormal.eq_iff_zero_and_succ (isNormal_deriv _) (isNormal_mul_right (opow_pos ω ha))]\n  refine ⟨?_, fun c h => ?_⟩\n  · dsimp only; rw [deriv_zero_right, nfp_mul_zero, mul_zero]\n  · rw [deriv_succ, h]\n    exact nfp_mul_opow_omega0_add c ha zero_lt_one (one_le_iff_pos.2 (opow_pos _ ha))\n\n"}
{"name":"Ordinal.deriv_mul_eq_opow_omega_mul","module":"Mathlib.SetTheory.Ordinal.FixedPoint","initialProofState":"a : Ordinal.{u}\nha : LT.lt 0 a\nb : Ordinal.{u}\n⊢ Eq (Ordinal.deriv (fun x => HMul.hMul a x) b) (HMul.hMul (HPow.hPow a Ordinal.omega0) b)","decl":"@[deprecated \"No deprecation message was provided.\"  (since := \"2024-09-30\")]\nalias deriv_mul_eq_opow_omega_mul := deriv_mul_eq_opow_omega0_mul\n\n"}
