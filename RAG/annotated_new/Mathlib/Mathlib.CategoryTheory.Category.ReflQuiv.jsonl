{"name":"CategoryTheory.ReflQuiv.of_val","module":"Mathlib.CategoryTheory.Category.ReflQuiv","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.ReflQuiver C\n‚ä¢ Eq (‚Üë(CategoryTheory.ReflQuiv.of C)) C","decl":"@[simp] theorem of_val (C : Type u) [ReflQuiver C] : (ReflQuiv.of C) = C := rfl\n\n"}
{"name":"CategoryTheory.ReflQuiv.id_eq_id","module":"Mathlib.CategoryTheory.Category.ReflQuiv","initialProofState":"X : CategoryTheory.ReflQuiv\n‚ä¢ Eq (CategoryTheory.CategoryStruct.id X) (CategoryTheory.ReflPrefunctor.id ‚ÜëX)","decl":"theorem id_eq_id (X : ReflQuiv) : ùüô X = ùü≠rq X := rfl\n"}
{"name":"CategoryTheory.ReflQuiv.comp_eq_comp","module":"Mathlib.CategoryTheory.Category.ReflQuiv","initialProofState":"X Y Z : CategoryTheory.ReflQuiv\nF : Quiver.Hom X Y\nG : Quiver.Hom Y Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp F G) (CategoryTheory.ReflPrefunctor.comp F G)","decl":"theorem comp_eq_comp {X Y Z : ReflQuiv} (F : X ‚ü∂ Y) (G : Y ‚ü∂ Z) : F ‚â´ G = F ‚ãôrq G := rfl\n\n"}
{"name":"CategoryTheory.ReflQuiv.forget_obj","module":"Mathlib.CategoryTheory.Category.ReflQuiv","initialProofState":"C : CategoryTheory.Cat\n‚ä¢ Eq (CategoryTheory.ReflQuiv.forget.obj C) (CategoryTheory.ReflQuiv.of ‚ÜëC)","decl":"/-- The forgetful functor from categories to quivers. -/\n@[simps]\ndef forget : Cat.{v, u} ‚•§ ReflQuiv.{v, u} where\n  obj C := ReflQuiv.of C\n  map F := F.toReflPrefunctor\n\n"}
{"name":"CategoryTheory.ReflQuiv.forget_map","module":"Mathlib.CategoryTheory.Category.ReflQuiv","initialProofState":"X‚úù Y‚úù : CategoryTheory.Cat\nF : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq (CategoryTheory.ReflQuiv.forget.map F) (CategoryTheory.Functor.toReflPrefunctor F)","decl":"/-- The forgetful functor from categories to quivers. -/\n@[simps]\ndef forget : Cat.{v, u} ‚•§ ReflQuiv.{v, u} where\n  obj C := ReflQuiv.of C\n  map F := F.toReflPrefunctor\n\n"}
{"name":"CategoryTheory.ReflQuiv.forget_faithful","module":"Mathlib.CategoryTheory.Category.ReflQuiv","initialProofState":"C D : CategoryTheory.Cat\nF G : CategoryTheory.Functor ‚ÜëC ‚ÜëD\nhyp : Eq (CategoryTheory.ReflQuiv.forget.map F) (CategoryTheory.ReflQuiv.forget.map G)\n‚ä¢ Eq F G","decl":"theorem forget_faithful {C D : Cat.{v, u}} (F G : C ‚•§ D)\n    (hyp : forget.map F = forget.map G) : F = G := by\n  cases F; cases G; cases hyp; rfl\n\n"}
{"name":"CategoryTheory.ReflQuiv.forget.Faithful","module":"Mathlib.CategoryTheory.Category.ReflQuiv","initialProofState":"‚ä¢ CategoryTheory.ReflQuiv.forget.Faithful","decl":"theorem forget.Faithful : Functor.Faithful (forget) where\n  map_injective := fun hyp ‚Ü¶ forget_faithful _ _ hyp\n\n"}
{"name":"CategoryTheory.ReflQuiv.forgetToQuiv_obj","module":"Mathlib.CategoryTheory.Category.ReflQuiv","initialProofState":"V : CategoryTheory.ReflQuiv\n‚ä¢ Eq (CategoryTheory.ReflQuiv.forgetToQuiv.obj V) (CategoryTheory.Quiv.of ‚ÜëV)","decl":"/-- The forgetful functor from categories to quivers. -/\n@[simps]\ndef forgetToQuiv : ReflQuiv.{v, u} ‚•§ Quiv.{v, u} where\n  obj V := Quiv.of V\n  map F := F.toPrefunctor\n\n"}
{"name":"CategoryTheory.ReflQuiv.forgetToQuiv_map","module":"Mathlib.CategoryTheory.Category.ReflQuiv","initialProofState":"X‚úù Y‚úù : CategoryTheory.ReflQuiv\nF : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq (CategoryTheory.ReflQuiv.forgetToQuiv.map F) F.toPrefunctor","decl":"/-- The forgetful functor from categories to quivers. -/\n@[simps]\ndef forgetToQuiv : ReflQuiv.{v, u} ‚•§ Quiv.{v, u} where\n  obj V := Quiv.of V\n  map F := F.toPrefunctor\n\n"}
{"name":"CategoryTheory.ReflQuiv.forgetToQuiv_faithful","module":"Mathlib.CategoryTheory.Category.ReflQuiv","initialProofState":"V W : CategoryTheory.ReflQuiv\nF G : CategoryTheory.ReflPrefunctor ‚ÜëV ‚ÜëW\nhyp : Eq (CategoryTheory.ReflQuiv.forgetToQuiv.map F) (CategoryTheory.ReflQuiv.forgetToQuiv.map G)\n‚ä¢ Eq F G","decl":"theorem forgetToQuiv_faithful {V W : ReflQuiv} (F G : V ‚•§rq W)\n    (hyp : forgetToQuiv.map F = forgetToQuiv.map G) : F = G := by\n  cases F; cases G; cases hyp; rfl\n\n"}
{"name":"CategoryTheory.ReflQuiv.forgetToQuiv.Faithful","module":"Mathlib.CategoryTheory.Category.ReflQuiv","initialProofState":"‚ä¢ CategoryTheory.ReflQuiv.forgetToQuiv.Faithful","decl":"instance forgetToQuiv.Faithful : Functor.Faithful forgetToQuiv where\n  map_injective := fun hyp ‚Ü¶ forgetToQuiv_faithful _ _ hyp\n\n"}
{"name":"CategoryTheory.ReflQuiv.forget_forgetToQuiv","module":"Mathlib.CategoryTheory.Category.ReflQuiv","initialProofState":"‚ä¢ Eq (CategoryTheory.ReflQuiv.forget.comp CategoryTheory.ReflQuiv.forgetToQuiv) CategoryTheory.Quiv.forget","decl":"theorem forget_forgetToQuiv : forget ‚ãô forgetToQuiv = Quiv.forget := rfl\n\n"}
{"name":"CategoryTheory.Cat.FreeRefl.lift_unique'","module":"Mathlib.CategoryTheory.Category.ReflQuiv","initialProofState":"V : Type u_1\ninst‚úù¬π : CategoryTheory.ReflQuiver V\nD : Type u_3\ninst‚úù : CategoryTheory.Category.{u_4, u_3} D\nF‚ÇÅ F‚ÇÇ : CategoryTheory.Functor (CategoryTheory.Cat.FreeRefl V) D\nh : Eq ((CategoryTheory.Cat.FreeRefl.quotientFunctor V).comp F‚ÇÅ) ((CategoryTheory.Cat.FreeRefl.quotientFunctor V).comp F‚ÇÇ)\n‚ä¢ Eq F‚ÇÅ F‚ÇÇ","decl":"/-- This is a specialization of `Quotient.lift_unique'` rather than `Quotient.lift_unique`, hence\nthe prime in the name.-/\ntheorem FreeRefl.lift_unique' {V} [ReflQuiver V] {D} [Category D] (F‚ÇÅ F‚ÇÇ : FreeRefl V ‚•§ D)\n    (h : quotientFunctor V ‚ãô F‚ÇÅ = quotientFunctor V ‚ãô F‚ÇÇ) :\n    F‚ÇÅ = F‚ÇÇ :=\n  Quotient.lift_unique' (C := Cat.free.obj (Quiv.of V)) (FreeReflRel (V := V)) _ _ h\n\n"}
{"name":"CategoryTheory.Cat.freeRefl_obj_Œ±","module":"Mathlib.CategoryTheory.Category.ReflQuiv","initialProofState":"V : CategoryTheory.ReflQuiv\n‚ä¢ Eq (‚Üë(CategoryTheory.Cat.freeRefl.obj V)) (CategoryTheory.Cat.FreeRefl ‚ÜëV)","decl":"/-- The functor sending a reflexive quiver to the free category it generates, a quotient of\nits path category.-/\n@[simps!]\ndef freeRefl : ReflQuiv.{v, u} ‚•§ Cat.{max u v, u} where\n  obj V := Cat.of (FreeRefl V)\n  map f := Quotient.lift _ ((by exact Cat.free.map f.toPrefunctor) ‚ãô FreeRefl.quotientFunctor _)\n    (fun X Y f g hfg => by\n      apply Quotient.sound\n      cases hfg\n      simp [ReflPrefunctor.map_id]\n      constructor)\n  map_id X := by\n    dsimp\n    refine (Quotient.lift_unique _ _ _ _ ((Functor.comp_id _).trans <|\n      (Functor.id_comp _).symm.trans ?_)).symm\n    congr 1\n    exact (free.map_id X.toQuiv).symm\n  map_comp {X Y Z} f g := by\n    dsimp\n    apply (Quotient.lift_unique _ _ _ _ _).symm\n    have : free.map (f ‚â´ g).toPrefunctor =\n        free.map (X := X.toQuiv) (Y := Y.toQuiv) f.toPrefunctor ‚ãô\n        free.map (X := Y.toQuiv) (Y := Z.toQuiv) g.toPrefunctor := by\n      show _ = _ ‚â´ _\n      rw [‚Üê Functor.map_comp]; rfl\n    rw [this, Functor.assoc]\n    show _ ‚ãô _ ‚ãô _ = _\n    rw [‚Üê Functor.assoc, Quotient.lift_spec, Functor.assoc, FreeRefl.quotientFunctor,\n      Quotient.lift_spec]\n\n"}
{"name":"CategoryTheory.Cat.freeRefl_obj_str_comp","module":"Mathlib.CategoryTheory.Category.ReflQuiv","initialProofState":"V : CategoryTheory.ReflQuiv\na b c : CategoryTheory.Quotient CategoryTheory.Cat.FreeReflRel\na‚úù¬π : CategoryTheory.Quotient.Hom CategoryTheory.Cat.FreeReflRel a b\na‚úù : CategoryTheory.Quotient.Hom CategoryTheory.Cat.FreeReflRel b c\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp a‚úù¬π a‚úù) (CategoryTheory.Quotient.comp CategoryTheory.Cat.FreeReflRel a‚úù¬π a‚úù)","decl":"/-- The functor sending a reflexive quiver to the free category it generates, a quotient of\nits path category.-/\n@[simps!]\ndef freeRefl : ReflQuiv.{v, u} ‚•§ Cat.{max u v, u} where\n  obj V := Cat.of (FreeRefl V)\n  map f := Quotient.lift _ ((by exact Cat.free.map f.toPrefunctor) ‚ãô FreeRefl.quotientFunctor _)\n    (fun X Y f g hfg => by\n      apply Quotient.sound\n      cases hfg\n      simp [ReflPrefunctor.map_id]\n      constructor)\n  map_id X := by\n    dsimp\n    refine (Quotient.lift_unique _ _ _ _ ((Functor.comp_id _).trans <|\n      (Functor.id_comp _).symm.trans ?_)).symm\n    congr 1\n    exact (free.map_id X.toQuiv).symm\n  map_comp {X Y Z} f g := by\n    dsimp\n    apply (Quotient.lift_unique _ _ _ _ _).symm\n    have : free.map (f ‚â´ g).toPrefunctor =\n        free.map (X := X.toQuiv) (Y := Y.toQuiv) f.toPrefunctor ‚ãô\n        free.map (X := Y.toQuiv) (Y := Z.toQuiv) g.toPrefunctor := by\n      show _ = _ ‚â´ _\n      rw [‚Üê Functor.map_comp]; rfl\n    rw [this, Functor.assoc]\n    show _ ‚ãô _ ‚ãô _ = _\n    rw [‚Üê Functor.assoc, Quotient.lift_spec, Functor.assoc, FreeRefl.quotientFunctor,\n      Quotient.lift_spec]\n\n"}
{"name":"CategoryTheory.Cat.freeRefl_map_map","module":"Mathlib.CategoryTheory.Category.ReflQuiv","initialProofState":"X‚úù Y‚úù : CategoryTheory.ReflQuiv\nf : Quiver.Hom X‚úù Y‚úù\na b : CategoryTheory.Quotient CategoryTheory.Cat.FreeReflRel\nhf : Quiver.Hom a b\n‚ä¢ Eq ((CategoryTheory.Cat.freeRefl.map f).map hf) (Quot.liftOn hf (fun f_1 => (CategoryTheory.Cat.FreeRefl.quotientFunctor ‚ÜëY‚úù).map (f.mapPath f_1)) ‚ãØ)","decl":"/-- The functor sending a reflexive quiver to the free category it generates, a quotient of\nits path category.-/\n@[simps!]\ndef freeRefl : ReflQuiv.{v, u} ‚•§ Cat.{max u v, u} where\n  obj V := Cat.of (FreeRefl V)\n  map f := Quotient.lift _ ((by exact Cat.free.map f.toPrefunctor) ‚ãô FreeRefl.quotientFunctor _)\n    (fun X Y f g hfg => by\n      apply Quotient.sound\n      cases hfg\n      simp [ReflPrefunctor.map_id]\n      constructor)\n  map_id X := by\n    dsimp\n    refine (Quotient.lift_unique _ _ _ _ ((Functor.comp_id _).trans <|\n      (Functor.id_comp _).symm.trans ?_)).symm\n    congr 1\n    exact (free.map_id X.toQuiv).symm\n  map_comp {X Y Z} f g := by\n    dsimp\n    apply (Quotient.lift_unique _ _ _ _ _).symm\n    have : free.map (f ‚â´ g).toPrefunctor =\n        free.map (X := X.toQuiv) (Y := Y.toQuiv) f.toPrefunctor ‚ãô\n        free.map (X := Y.toQuiv) (Y := Z.toQuiv) g.toPrefunctor := by\n      show _ = _ ‚â´ _\n      rw [‚Üê Functor.map_comp]; rfl\n    rw [this, Functor.assoc]\n    show _ ‚ãô _ ‚ãô _ = _\n    rw [‚Üê Functor.assoc, Quotient.lift_spec, Functor.assoc, FreeRefl.quotientFunctor,\n      Quotient.lift_spec]\n\n"}
{"name":"CategoryTheory.Cat.freeRefl_map_obj_as","module":"Mathlib.CategoryTheory.Category.ReflQuiv","initialProofState":"X‚úù Y‚úù : CategoryTheory.ReflQuiv\nf : Quiver.Hom X‚úù Y‚úù\na : CategoryTheory.Quotient CategoryTheory.Cat.FreeReflRel\n‚ä¢ Eq ((CategoryTheory.Cat.freeRefl.map f).obj a).as (f.obj a.as)","decl":"/-- The functor sending a reflexive quiver to the free category it generates, a quotient of\nits path category.-/\n@[simps!]\ndef freeRefl : ReflQuiv.{v, u} ‚•§ Cat.{max u v, u} where\n  obj V := Cat.of (FreeRefl V)\n  map f := Quotient.lift _ ((by exact Cat.free.map f.toPrefunctor) ‚ãô FreeRefl.quotientFunctor _)\n    (fun X Y f g hfg => by\n      apply Quotient.sound\n      cases hfg\n      simp [ReflPrefunctor.map_id]\n      constructor)\n  map_id X := by\n    dsimp\n    refine (Quotient.lift_unique _ _ _ _ ((Functor.comp_id _).trans <|\n      (Functor.id_comp _).symm.trans ?_)).symm\n    congr 1\n    exact (free.map_id X.toQuiv).symm\n  map_comp {X Y Z} f g := by\n    dsimp\n    apply (Quotient.lift_unique _ _ _ _ _).symm\n    have : free.map (f ‚â´ g).toPrefunctor =\n        free.map (X := X.toQuiv) (Y := Y.toQuiv) f.toPrefunctor ‚ãô\n        free.map (X := Y.toQuiv) (Y := Z.toQuiv) g.toPrefunctor := by\n      show _ = _ ‚â´ _\n      rw [‚Üê Functor.map_comp]; rfl\n    rw [this, Functor.assoc]\n    show _ ‚ãô _ ‚ãô _ = _\n    rw [‚Üê Functor.assoc, Quotient.lift_spec, Functor.assoc, FreeRefl.quotientFunctor,\n      Quotient.lift_spec]\n\n"}
{"name":"CategoryTheory.Cat.freeRefl_obj_str_id","module":"Mathlib.CategoryTheory.Category.ReflQuiv","initialProofState":"V : CategoryTheory.ReflQuiv\na : CategoryTheory.Quotient CategoryTheory.Cat.FreeReflRel\n‚ä¢ Eq (CategoryTheory.CategoryStruct.id a) (Quot.mk (CategoryTheory.Quotient.CompClosure CategoryTheory.Cat.FreeReflRel) (CategoryTheory.CategoryStruct.id a.as))","decl":"/-- The functor sending a reflexive quiver to the free category it generates, a quotient of\nits path category.-/\n@[simps!]\ndef freeRefl : ReflQuiv.{v, u} ‚•§ Cat.{max u v, u} where\n  obj V := Cat.of (FreeRefl V)\n  map f := Quotient.lift _ ((by exact Cat.free.map f.toPrefunctor) ‚ãô FreeRefl.quotientFunctor _)\n    (fun X Y f g hfg => by\n      apply Quotient.sound\n      cases hfg\n      simp [ReflPrefunctor.map_id]\n      constructor)\n  map_id X := by\n    dsimp\n    refine (Quotient.lift_unique _ _ _ _ ((Functor.comp_id _).trans <|\n      (Functor.id_comp _).symm.trans ?_)).symm\n    congr 1\n    exact (free.map_id X.toQuiv).symm\n  map_comp {X Y Z} f g := by\n    dsimp\n    apply (Quotient.lift_unique _ _ _ _ _).symm\n    have : free.map (f ‚â´ g).toPrefunctor =\n        free.map (X := X.toQuiv) (Y := Y.toQuiv) f.toPrefunctor ‚ãô\n        free.map (X := Y.toQuiv) (Y := Z.toQuiv) g.toPrefunctor := by\n      show _ = _ ‚â´ _\n      rw [‚Üê Functor.map_comp]; rfl\n    rw [this, Functor.assoc]\n    show _ ‚ãô _ ‚ãô _ = _\n    rw [‚Üê Functor.assoc, Quotient.lift_spec, Functor.assoc, FreeRefl.quotientFunctor,\n      Quotient.lift_spec]\n\n"}
{"name":"CategoryTheory.Cat.freeRefl_naturality","module":"Mathlib.CategoryTheory.Category.ReflQuiv","initialProofState":"X Y : Type u_1\ninst‚úù¬π : CategoryTheory.ReflQuiver X\ninst‚úù : CategoryTheory.ReflQuiver Y\nf : CategoryTheory.ReflPrefunctor X Y\n‚ä¢ Eq (CategoryTheory.Functor.comp (CategoryTheory.Cat.free.map f.toPrefunctor) (CategoryTheory.Cat.FreeRefl.quotientFunctor Y)) ((CategoryTheory.Cat.FreeRefl.quotientFunctor X).comp (CategoryTheory.Cat.freeRefl.map f))","decl":"theorem freeRefl_naturality {X Y} [ReflQuiver X] [ReflQuiver Y] (f : X ‚•§rq Y) :\n    free.map (X := Quiv.of X) (Y := Quiv.of Y) f.toPrefunctor ‚ãô\n    FreeRefl.quotientFunctor ‚ÜëY =\n    FreeRefl.quotientFunctor ‚ÜëX ‚ãô freeRefl.map (X := ReflQuiv.of X) (Y := ReflQuiv.of Y) f := by\n  simp only [free_obj, FreeRefl.quotientFunctor, freeRefl, ReflQuiv.of_val]\n  rw [Quotient.lift_spec]\n\n"}
{"name":"CategoryTheory.ReflQuiv.adj.unit.app_toPrefunctor","module":"Mathlib.CategoryTheory.Category.ReflQuiv","initialProofState":"V : CategoryTheory.ReflQuiv\n‚ä¢ Eq (CategoryTheory.ReflQuiv.adj.unit.app V).toPrefunctor (Prefunctor.comp (CategoryTheory.Quiv.adj.unit.app V.toQuiv) (CategoryTheory.Cat.FreeRefl.quotientFunctor ‚ÜëV).toPrefunctor)","decl":"/-- The unit components are defined as the composite of the corresponding unit component for the\nadjunction between categories and quivers with the map underlying the quotient functor.-/\n@[simps! toPrefunctor obj map]\ndef adj.unit.app (V : ReflQuiv.{max u v, u}) : V ‚•§rq forget.obj (Cat.freeRefl.obj V) where\n  toPrefunctor := Quiv.adj.unit.app (V.toQuiv) ‚ãôq\n    Quiv.forget.map (Cat.FreeRefl.quotientFunctor V)\n  map_id := fun _ => Quotient.sound _ ‚ü®‚ü©\n\n"}
{"name":"CategoryTheory.ReflQuiv.adj.unit.app_map","module":"Mathlib.CategoryTheory.Category.ReflQuiv","initialProofState":"V : CategoryTheory.ReflQuiv\nX‚úù Y‚úù : ‚ÜëV\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.ReflQuiv.adj.unit.app V).map f) ((CategoryTheory.Cat.FreeRefl.quotientFunctor ‚ÜëV).map ((CategoryTheory.Quiv.adj.unit.app V.toQuiv).map f))","decl":"/-- The unit components are defined as the composite of the corresponding unit component for the\nadjunction between categories and quivers with the map underlying the quotient functor.-/\n@[simps! toPrefunctor obj map]\ndef adj.unit.app (V : ReflQuiv.{max u v, u}) : V ‚•§rq forget.obj (Cat.freeRefl.obj V) where\n  toPrefunctor := Quiv.adj.unit.app (V.toQuiv) ‚ãôq\n    Quiv.forget.map (Cat.FreeRefl.quotientFunctor V)\n  map_id := fun _ => Quotient.sound _ ‚ü®‚ü©\n\n"}
{"name":"CategoryTheory.ReflQuiv.adj.unit.app_obj","module":"Mathlib.CategoryTheory.Category.ReflQuiv","initialProofState":"V : CategoryTheory.ReflQuiv\nX : ‚ÜëV\n‚ä¢ Eq ((CategoryTheory.ReflQuiv.adj.unit.app V).obj X) ((CategoryTheory.Cat.FreeRefl.quotientFunctor ‚ÜëV).obj ((CategoryTheory.Quiv.adj.unit.app V.toQuiv).obj X))","decl":"/-- The unit components are defined as the composite of the corresponding unit component for the\nadjunction between categories and quivers with the map underlying the quotient functor.-/\n@[simps! toPrefunctor obj map]\ndef adj.unit.app (V : ReflQuiv.{max u v, u}) : V ‚•§rq forget.obj (Cat.freeRefl.obj V) where\n  toPrefunctor := Quiv.adj.unit.app (V.toQuiv) ‚ãôq\n    Quiv.forget.map (Cat.FreeRefl.quotientFunctor V)\n  map_id := fun _ => Quotient.sound _ ‚ü®‚ü©\n\n"}
{"name":"CategoryTheory.ReflQuiv.adj.unit.component_eq","module":"Mathlib.CategoryTheory.Category.ReflQuiv","initialProofState":"V : CategoryTheory.ReflQuiv\n‚ä¢ Eq (CategoryTheory.ReflQuiv.forgetToQuiv.map (CategoryTheory.ReflQuiv.adj.unit.app V)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Quiv.adj.unit.app V.toQuiv) (CategoryTheory.Quiv.forget.map (CategoryTheory.Cat.FreeRefl.quotientFunctor ‚ÜëV)))","decl":"/-- This is used in the proof of both triangle equalities.-/\ntheorem adj.unit.component_eq (V : ReflQuiv.{max u v, u}) :\n    forgetToQuiv.map (adj.unit.app V) = Quiv.adj.unit.app (V.toQuiv) ‚â´\n    Quiv.forget.map (Y := Cat.of _) (Cat.FreeRefl.quotientFunctor V) := rfl\n\n"}
{"name":"CategoryTheory.ReflQuiv.adj.counit.app_map","module":"Mathlib.CategoryTheory.Category.ReflQuiv","initialProofState":"C : CategoryTheory.Cat\na b : CategoryTheory.Quotient CategoryTheory.Cat.FreeReflRel\nhf : Quiver.Hom a b\n‚ä¢ Eq ((CategoryTheory.ReflQuiv.adj.counit.app C).map hf) (Quot.liftOn hf (fun f => (CategoryTheory.Quiv.adj.counit.app C).map f) ‚ãØ)","decl":"/-- The counit components are defined using the universal property of the quotient\nfrom the corresponding counit component for the adjunction between categories and quivers.-/\n@[simps!]\ndef adj.counit.app (C : Cat) : Cat.freeRefl.obj (forget.obj C) ‚•§ C :=\n  Quotient.lift Cat.FreeReflRel (Quiv.adj.counit.app C) (by\n    intro x y f g rel\n    cases rel\n    unfold Quiv.adj\n    simp only [Adjunction.mkOfHomEquiv_counit_app, Equiv.coe_fn_symm_mk,\n      Quiv.lift_map, Prefunctor.mapPath_toPath, composePath_toPath]\n    rfl)\n\n"}
{"name":"CategoryTheory.ReflQuiv.adj.counit.app_obj","module":"Mathlib.CategoryTheory.Category.ReflQuiv","initialProofState":"C : CategoryTheory.Cat\na : CategoryTheory.Quotient CategoryTheory.Cat.FreeReflRel\n‚ä¢ Eq ((CategoryTheory.ReflQuiv.adj.counit.app C).obj a) ((CategoryTheory.Quiv.adj.counit.app C).obj a.as)","decl":"/-- The counit components are defined using the universal property of the quotient\nfrom the corresponding counit component for the adjunction between categories and quivers.-/\n@[simps!]\ndef adj.counit.app (C : Cat) : Cat.freeRefl.obj (forget.obj C) ‚•§ C :=\n  Quotient.lift Cat.FreeReflRel (Quiv.adj.counit.app C) (by\n    intro x y f g rel\n    cases rel\n    unfold Quiv.adj\n    simp only [Adjunction.mkOfHomEquiv_counit_app, Equiv.coe_fn_symm_mk,\n      Quiv.lift_map, Prefunctor.mapPath_toPath, composePath_toPath]\n    rfl)\n\n"}
{"name":"CategoryTheory.ReflQuiv.adj.counit.component_eq","module":"Mathlib.CategoryTheory.Category.ReflQuiv","initialProofState":"C : CategoryTheory.Cat\n‚ä¢ Eq ((CategoryTheory.Cat.FreeRefl.quotientFunctor ‚ÜëC).comp (CategoryTheory.ReflQuiv.adj.counit.app C)) (CategoryTheory.Quiv.adj.counit.app C)","decl":"/-- The counit of `ReflQuiv.adj` is closely related to the counit of `Quiv.adj`.-/\n@[simp]\ntheorem adj.counit.component_eq (C : Cat) :\n    Cat.FreeRefl.quotientFunctor C ‚ãô adj.counit.app C =\n    Quiv.adj.counit.app C := rfl\n\n"}
{"name":"CategoryTheory.ReflQuiv.adj.counit.component_eq'","module":"Mathlib.CategoryTheory.Category.ReflQuiv","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{max u_1 u_2, u_1} C\n‚ä¢ Eq ((CategoryTheory.Cat.FreeRefl.quotientFunctor C).comp (CategoryTheory.ReflQuiv.adj.counit.app (CategoryTheory.Cat.of C))) (CategoryTheory.Quiv.adj.counit.app (CategoryTheory.Cat.of C))","decl":"/-- The counit of `ReflQuiv.adj` is closely related to the counit of `Quiv.adj`. For ease of use,\nwe introduce primed version for unbundled categories.-/\n@[simp]\ntheorem adj.counit.component_eq' (C) [Category C] :\n    Cat.FreeRefl.quotientFunctor C ‚ãô adj.counit.app (Cat.of C) =\n    Quiv.adj.counit.app (Cat.of C) := rfl\n\n"}
