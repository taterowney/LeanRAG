{"name":"CategoryTheory.ReflQuiv.of_val","module":"Mathlib.CategoryTheory.Category.ReflQuiv","initialProofState":"C : Type u\ninst✝ : CategoryTheory.ReflQuiver C\n⊢ Eq (↑(CategoryTheory.ReflQuiv.of C)) C","decl":"@[simp] theorem of_val (C : Type u) [ReflQuiver C] : (ReflQuiv.of C) = C := rfl\n\n"}
{"name":"CategoryTheory.ReflQuiv.id_eq_id","module":"Mathlib.CategoryTheory.Category.ReflQuiv","initialProofState":"X : CategoryTheory.ReflQuiv\n⊢ Eq (CategoryTheory.CategoryStruct.id X) (CategoryTheory.ReflPrefunctor.id ↑X)","decl":"theorem id_eq_id (X : ReflQuiv) : 𝟙 X = 𝟭rq X := rfl\n"}
{"name":"CategoryTheory.ReflQuiv.comp_eq_comp","module":"Mathlib.CategoryTheory.Category.ReflQuiv","initialProofState":"X Y Z : CategoryTheory.ReflQuiv\nF : Quiver.Hom X Y\nG : Quiver.Hom Y Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp F G) (CategoryTheory.ReflPrefunctor.comp F G)","decl":"theorem comp_eq_comp {X Y Z : ReflQuiv} (F : X ⟶ Y) (G : Y ⟶ Z) : F ≫ G = F ⋙rq G := rfl\n\n"}
{"name":"CategoryTheory.ReflQuiv.forget_obj","module":"Mathlib.CategoryTheory.Category.ReflQuiv","initialProofState":"C : CategoryTheory.Cat\n⊢ Eq (CategoryTheory.ReflQuiv.forget.obj C) (CategoryTheory.ReflQuiv.of ↑C)","decl":"/-- The forgetful functor from categories to quivers. -/\n@[simps]\ndef forget : Cat.{v, u} ⥤ ReflQuiv.{v, u} where\n  obj C := ReflQuiv.of C\n  map F := F.toReflPrefunctor\n\n"}
{"name":"CategoryTheory.ReflQuiv.forget_map","module":"Mathlib.CategoryTheory.Category.ReflQuiv","initialProofState":"X✝ Y✝ : CategoryTheory.Cat\nF : Quiver.Hom X✝ Y✝\n⊢ Eq (CategoryTheory.ReflQuiv.forget.map F) (CategoryTheory.Functor.toReflPrefunctor F)","decl":"/-- The forgetful functor from categories to quivers. -/\n@[simps]\ndef forget : Cat.{v, u} ⥤ ReflQuiv.{v, u} where\n  obj C := ReflQuiv.of C\n  map F := F.toReflPrefunctor\n\n"}
{"name":"CategoryTheory.ReflQuiv.forget_faithful","module":"Mathlib.CategoryTheory.Category.ReflQuiv","initialProofState":"C D : CategoryTheory.Cat\nF G : CategoryTheory.Functor ↑C ↑D\nhyp : Eq (CategoryTheory.ReflQuiv.forget.map F) (CategoryTheory.ReflQuiv.forget.map G)\n⊢ Eq F G","decl":"theorem forget_faithful {C D : Cat.{v, u}} (F G : C ⥤ D)\n    (hyp : forget.map F = forget.map G) : F = G := by\n  cases F; cases G; cases hyp; rfl\n\n"}
{"name":"CategoryTheory.ReflQuiv.forget.Faithful","module":"Mathlib.CategoryTheory.Category.ReflQuiv","initialProofState":"⊢ CategoryTheory.ReflQuiv.forget.Faithful","decl":"theorem forget.Faithful : Functor.Faithful (forget) where\n  map_injective := fun hyp ↦ forget_faithful _ _ hyp\n\n"}
{"name":"CategoryTheory.ReflQuiv.forgetToQuiv_obj","module":"Mathlib.CategoryTheory.Category.ReflQuiv","initialProofState":"V : CategoryTheory.ReflQuiv\n⊢ Eq (CategoryTheory.ReflQuiv.forgetToQuiv.obj V) (CategoryTheory.Quiv.of ↑V)","decl":"/-- The forgetful functor from categories to quivers. -/\n@[simps]\ndef forgetToQuiv : ReflQuiv.{v, u} ⥤ Quiv.{v, u} where\n  obj V := Quiv.of V\n  map F := F.toPrefunctor\n\n"}
{"name":"CategoryTheory.ReflQuiv.forgetToQuiv_map","module":"Mathlib.CategoryTheory.Category.ReflQuiv","initialProofState":"X✝ Y✝ : CategoryTheory.ReflQuiv\nF : Quiver.Hom X✝ Y✝\n⊢ Eq (CategoryTheory.ReflQuiv.forgetToQuiv.map F) F.toPrefunctor","decl":"/-- The forgetful functor from categories to quivers. -/\n@[simps]\ndef forgetToQuiv : ReflQuiv.{v, u} ⥤ Quiv.{v, u} where\n  obj V := Quiv.of V\n  map F := F.toPrefunctor\n\n"}
{"name":"CategoryTheory.ReflQuiv.forgetToQuiv_faithful","module":"Mathlib.CategoryTheory.Category.ReflQuiv","initialProofState":"V W : CategoryTheory.ReflQuiv\nF G : CategoryTheory.ReflPrefunctor ↑V ↑W\nhyp : Eq (CategoryTheory.ReflQuiv.forgetToQuiv.map F) (CategoryTheory.ReflQuiv.forgetToQuiv.map G)\n⊢ Eq F G","decl":"theorem forgetToQuiv_faithful {V W : ReflQuiv} (F G : V ⥤rq W)\n    (hyp : forgetToQuiv.map F = forgetToQuiv.map G) : F = G := by\n  cases F; cases G; cases hyp; rfl\n\n"}
{"name":"CategoryTheory.ReflQuiv.forgetToQuiv.Faithful","module":"Mathlib.CategoryTheory.Category.ReflQuiv","initialProofState":"⊢ CategoryTheory.ReflQuiv.forgetToQuiv.Faithful","decl":"instance forgetToQuiv.Faithful : Functor.Faithful forgetToQuiv where\n  map_injective := fun hyp ↦ forgetToQuiv_faithful _ _ hyp\n\n"}
{"name":"CategoryTheory.ReflQuiv.forget_forgetToQuiv","module":"Mathlib.CategoryTheory.Category.ReflQuiv","initialProofState":"⊢ Eq (CategoryTheory.ReflQuiv.forget.comp CategoryTheory.ReflQuiv.forgetToQuiv) CategoryTheory.Quiv.forget","decl":"theorem forget_forgetToQuiv : forget ⋙ forgetToQuiv = Quiv.forget := rfl\n\n"}
{"name":"CategoryTheory.Cat.FreeRefl.lift_unique'","module":"Mathlib.CategoryTheory.Category.ReflQuiv","initialProofState":"V : Type u_1\ninst✝¹ : CategoryTheory.ReflQuiver V\nD : Type u_3\ninst✝ : CategoryTheory.Category.{u_4, u_3} D\nF₁ F₂ : CategoryTheory.Functor (CategoryTheory.Cat.FreeRefl V) D\nh : Eq ((CategoryTheory.Cat.FreeRefl.quotientFunctor V).comp F₁) ((CategoryTheory.Cat.FreeRefl.quotientFunctor V).comp F₂)\n⊢ Eq F₁ F₂","decl":"/-- This is a specialization of `Quotient.lift_unique'` rather than `Quotient.lift_unique`, hence\nthe prime in the name.-/\ntheorem FreeRefl.lift_unique' {V} [ReflQuiver V] {D} [Category D] (F₁ F₂ : FreeRefl V ⥤ D)\n    (h : quotientFunctor V ⋙ F₁ = quotientFunctor V ⋙ F₂) :\n    F₁ = F₂ :=\n  Quotient.lift_unique' (C := Cat.free.obj (Quiv.of V)) (FreeReflRel (V := V)) _ _ h\n\n"}
{"name":"CategoryTheory.Cat.freeRefl_obj_α","module":"Mathlib.CategoryTheory.Category.ReflQuiv","initialProofState":"V : CategoryTheory.ReflQuiv\n⊢ Eq (↑(CategoryTheory.Cat.freeRefl.obj V)) (CategoryTheory.Cat.FreeRefl ↑V)","decl":"/-- The functor sending a reflexive quiver to the free category it generates, a quotient of\nits path category.-/\n@[simps!]\ndef freeRefl : ReflQuiv.{v, u} ⥤ Cat.{max u v, u} where\n  obj V := Cat.of (FreeRefl V)\n  map f := Quotient.lift _ ((by exact Cat.free.map f.toPrefunctor) ⋙ FreeRefl.quotientFunctor _)\n    (fun X Y f g hfg => by\n      apply Quotient.sound\n      cases hfg\n      simp [ReflPrefunctor.map_id]\n      constructor)\n  map_id X := by\n    dsimp\n    refine (Quotient.lift_unique _ _ _ _ ((Functor.comp_id _).trans <|\n      (Functor.id_comp _).symm.trans ?_)).symm\n    congr 1\n    exact (free.map_id X.toQuiv).symm\n  map_comp {X Y Z} f g := by\n    dsimp\n    apply (Quotient.lift_unique _ _ _ _ _).symm\n    have : free.map (f ≫ g).toPrefunctor =\n        free.map (X := X.toQuiv) (Y := Y.toQuiv) f.toPrefunctor ⋙\n        free.map (X := Y.toQuiv) (Y := Z.toQuiv) g.toPrefunctor := by\n      show _ = _ ≫ _\n      rw [← Functor.map_comp]; rfl\n    rw [this, Functor.assoc]\n    show _ ⋙ _ ⋙ _ = _\n    rw [← Functor.assoc, Quotient.lift_spec, Functor.assoc, FreeRefl.quotientFunctor,\n      Quotient.lift_spec]\n\n"}
{"name":"CategoryTheory.Cat.freeRefl_obj_str_comp","module":"Mathlib.CategoryTheory.Category.ReflQuiv","initialProofState":"V : CategoryTheory.ReflQuiv\na b c : CategoryTheory.Quotient CategoryTheory.Cat.FreeReflRel\na✝¹ : CategoryTheory.Quotient.Hom CategoryTheory.Cat.FreeReflRel a b\na✝ : CategoryTheory.Quotient.Hom CategoryTheory.Cat.FreeReflRel b c\n⊢ Eq (CategoryTheory.CategoryStruct.comp a✝¹ a✝) (CategoryTheory.Quotient.comp CategoryTheory.Cat.FreeReflRel a✝¹ a✝)","decl":"/-- The functor sending a reflexive quiver to the free category it generates, a quotient of\nits path category.-/\n@[simps!]\ndef freeRefl : ReflQuiv.{v, u} ⥤ Cat.{max u v, u} where\n  obj V := Cat.of (FreeRefl V)\n  map f := Quotient.lift _ ((by exact Cat.free.map f.toPrefunctor) ⋙ FreeRefl.quotientFunctor _)\n    (fun X Y f g hfg => by\n      apply Quotient.sound\n      cases hfg\n      simp [ReflPrefunctor.map_id]\n      constructor)\n  map_id X := by\n    dsimp\n    refine (Quotient.lift_unique _ _ _ _ ((Functor.comp_id _).trans <|\n      (Functor.id_comp _).symm.trans ?_)).symm\n    congr 1\n    exact (free.map_id X.toQuiv).symm\n  map_comp {X Y Z} f g := by\n    dsimp\n    apply (Quotient.lift_unique _ _ _ _ _).symm\n    have : free.map (f ≫ g).toPrefunctor =\n        free.map (X := X.toQuiv) (Y := Y.toQuiv) f.toPrefunctor ⋙\n        free.map (X := Y.toQuiv) (Y := Z.toQuiv) g.toPrefunctor := by\n      show _ = _ ≫ _\n      rw [← Functor.map_comp]; rfl\n    rw [this, Functor.assoc]\n    show _ ⋙ _ ⋙ _ = _\n    rw [← Functor.assoc, Quotient.lift_spec, Functor.assoc, FreeRefl.quotientFunctor,\n      Quotient.lift_spec]\n\n"}
{"name":"CategoryTheory.Cat.freeRefl_map_map","module":"Mathlib.CategoryTheory.Category.ReflQuiv","initialProofState":"X✝ Y✝ : CategoryTheory.ReflQuiv\nf : Quiver.Hom X✝ Y✝\na b : CategoryTheory.Quotient CategoryTheory.Cat.FreeReflRel\nhf : Quiver.Hom a b\n⊢ Eq ((CategoryTheory.Cat.freeRefl.map f).map hf) (Quot.liftOn hf (fun f_1 => (CategoryTheory.Cat.FreeRefl.quotientFunctor ↑Y✝).map (f.mapPath f_1)) ⋯)","decl":"/-- The functor sending a reflexive quiver to the free category it generates, a quotient of\nits path category.-/\n@[simps!]\ndef freeRefl : ReflQuiv.{v, u} ⥤ Cat.{max u v, u} where\n  obj V := Cat.of (FreeRefl V)\n  map f := Quotient.lift _ ((by exact Cat.free.map f.toPrefunctor) ⋙ FreeRefl.quotientFunctor _)\n    (fun X Y f g hfg => by\n      apply Quotient.sound\n      cases hfg\n      simp [ReflPrefunctor.map_id]\n      constructor)\n  map_id X := by\n    dsimp\n    refine (Quotient.lift_unique _ _ _ _ ((Functor.comp_id _).trans <|\n      (Functor.id_comp _).symm.trans ?_)).symm\n    congr 1\n    exact (free.map_id X.toQuiv).symm\n  map_comp {X Y Z} f g := by\n    dsimp\n    apply (Quotient.lift_unique _ _ _ _ _).symm\n    have : free.map (f ≫ g).toPrefunctor =\n        free.map (X := X.toQuiv) (Y := Y.toQuiv) f.toPrefunctor ⋙\n        free.map (X := Y.toQuiv) (Y := Z.toQuiv) g.toPrefunctor := by\n      show _ = _ ≫ _\n      rw [← Functor.map_comp]; rfl\n    rw [this, Functor.assoc]\n    show _ ⋙ _ ⋙ _ = _\n    rw [← Functor.assoc, Quotient.lift_spec, Functor.assoc, FreeRefl.quotientFunctor,\n      Quotient.lift_spec]\n\n"}
{"name":"CategoryTheory.Cat.freeRefl_map_obj_as","module":"Mathlib.CategoryTheory.Category.ReflQuiv","initialProofState":"X✝ Y✝ : CategoryTheory.ReflQuiv\nf : Quiver.Hom X✝ Y✝\na : CategoryTheory.Quotient CategoryTheory.Cat.FreeReflRel\n⊢ Eq ((CategoryTheory.Cat.freeRefl.map f).obj a).as (f.obj a.as)","decl":"/-- The functor sending a reflexive quiver to the free category it generates, a quotient of\nits path category.-/\n@[simps!]\ndef freeRefl : ReflQuiv.{v, u} ⥤ Cat.{max u v, u} where\n  obj V := Cat.of (FreeRefl V)\n  map f := Quotient.lift _ ((by exact Cat.free.map f.toPrefunctor) ⋙ FreeRefl.quotientFunctor _)\n    (fun X Y f g hfg => by\n      apply Quotient.sound\n      cases hfg\n      simp [ReflPrefunctor.map_id]\n      constructor)\n  map_id X := by\n    dsimp\n    refine (Quotient.lift_unique _ _ _ _ ((Functor.comp_id _).trans <|\n      (Functor.id_comp _).symm.trans ?_)).symm\n    congr 1\n    exact (free.map_id X.toQuiv).symm\n  map_comp {X Y Z} f g := by\n    dsimp\n    apply (Quotient.lift_unique _ _ _ _ _).symm\n    have : free.map (f ≫ g).toPrefunctor =\n        free.map (X := X.toQuiv) (Y := Y.toQuiv) f.toPrefunctor ⋙\n        free.map (X := Y.toQuiv) (Y := Z.toQuiv) g.toPrefunctor := by\n      show _ = _ ≫ _\n      rw [← Functor.map_comp]; rfl\n    rw [this, Functor.assoc]\n    show _ ⋙ _ ⋙ _ = _\n    rw [← Functor.assoc, Quotient.lift_spec, Functor.assoc, FreeRefl.quotientFunctor,\n      Quotient.lift_spec]\n\n"}
{"name":"CategoryTheory.Cat.freeRefl_obj_str_id","module":"Mathlib.CategoryTheory.Category.ReflQuiv","initialProofState":"V : CategoryTheory.ReflQuiv\na : CategoryTheory.Quotient CategoryTheory.Cat.FreeReflRel\n⊢ Eq (CategoryTheory.CategoryStruct.id a) (Quot.mk (CategoryTheory.Quotient.CompClosure CategoryTheory.Cat.FreeReflRel) (CategoryTheory.CategoryStruct.id a.as))","decl":"/-- The functor sending a reflexive quiver to the free category it generates, a quotient of\nits path category.-/\n@[simps!]\ndef freeRefl : ReflQuiv.{v, u} ⥤ Cat.{max u v, u} where\n  obj V := Cat.of (FreeRefl V)\n  map f := Quotient.lift _ ((by exact Cat.free.map f.toPrefunctor) ⋙ FreeRefl.quotientFunctor _)\n    (fun X Y f g hfg => by\n      apply Quotient.sound\n      cases hfg\n      simp [ReflPrefunctor.map_id]\n      constructor)\n  map_id X := by\n    dsimp\n    refine (Quotient.lift_unique _ _ _ _ ((Functor.comp_id _).trans <|\n      (Functor.id_comp _).symm.trans ?_)).symm\n    congr 1\n    exact (free.map_id X.toQuiv).symm\n  map_comp {X Y Z} f g := by\n    dsimp\n    apply (Quotient.lift_unique _ _ _ _ _).symm\n    have : free.map (f ≫ g).toPrefunctor =\n        free.map (X := X.toQuiv) (Y := Y.toQuiv) f.toPrefunctor ⋙\n        free.map (X := Y.toQuiv) (Y := Z.toQuiv) g.toPrefunctor := by\n      show _ = _ ≫ _\n      rw [← Functor.map_comp]; rfl\n    rw [this, Functor.assoc]\n    show _ ⋙ _ ⋙ _ = _\n    rw [← Functor.assoc, Quotient.lift_spec, Functor.assoc, FreeRefl.quotientFunctor,\n      Quotient.lift_spec]\n\n"}
{"name":"CategoryTheory.Cat.freeRefl_naturality","module":"Mathlib.CategoryTheory.Category.ReflQuiv","initialProofState":"X Y : Type u_1\ninst✝¹ : CategoryTheory.ReflQuiver X\ninst✝ : CategoryTheory.ReflQuiver Y\nf : CategoryTheory.ReflPrefunctor X Y\n⊢ Eq (CategoryTheory.Functor.comp (CategoryTheory.Cat.free.map f.toPrefunctor) (CategoryTheory.Cat.FreeRefl.quotientFunctor Y)) ((CategoryTheory.Cat.FreeRefl.quotientFunctor X).comp (CategoryTheory.Cat.freeRefl.map f))","decl":"theorem freeRefl_naturality {X Y} [ReflQuiver X] [ReflQuiver Y] (f : X ⥤rq Y) :\n    free.map (X := Quiv.of X) (Y := Quiv.of Y) f.toPrefunctor ⋙\n    FreeRefl.quotientFunctor ↑Y =\n    FreeRefl.quotientFunctor ↑X ⋙ freeRefl.map (X := ReflQuiv.of X) (Y := ReflQuiv.of Y) f := by\n  simp only [free_obj, FreeRefl.quotientFunctor, freeRefl, ReflQuiv.of_val]\n  rw [Quotient.lift_spec]\n\n"}
{"name":"CategoryTheory.ReflQuiv.adj.unit.app_toPrefunctor","module":"Mathlib.CategoryTheory.Category.ReflQuiv","initialProofState":"V : CategoryTheory.ReflQuiv\n⊢ Eq (CategoryTheory.ReflQuiv.adj.unit.app V).toPrefunctor (Prefunctor.comp (CategoryTheory.Quiv.adj.unit.app V.toQuiv) (CategoryTheory.Cat.FreeRefl.quotientFunctor ↑V).toPrefunctor)","decl":"/-- The unit components are defined as the composite of the corresponding unit component for the\nadjunction between categories and quivers with the map underlying the quotient functor.-/\n@[simps! toPrefunctor obj map]\ndef adj.unit.app (V : ReflQuiv.{max u v, u}) : V ⥤rq forget.obj (Cat.freeRefl.obj V) where\n  toPrefunctor := Quiv.adj.unit.app (V.toQuiv) ⋙q\n    Quiv.forget.map (Cat.FreeRefl.quotientFunctor V)\n  map_id := fun _ => Quotient.sound _ ⟨⟩\n\n"}
{"name":"CategoryTheory.ReflQuiv.adj.unit.app_map","module":"Mathlib.CategoryTheory.Category.ReflQuiv","initialProofState":"V : CategoryTheory.ReflQuiv\nX✝ Y✝ : ↑V\nf : Quiver.Hom X✝ Y✝\n⊢ Eq ((CategoryTheory.ReflQuiv.adj.unit.app V).map f) ((CategoryTheory.Cat.FreeRefl.quotientFunctor ↑V).map ((CategoryTheory.Quiv.adj.unit.app V.toQuiv).map f))","decl":"/-- The unit components are defined as the composite of the corresponding unit component for the\nadjunction between categories and quivers with the map underlying the quotient functor.-/\n@[simps! toPrefunctor obj map]\ndef adj.unit.app (V : ReflQuiv.{max u v, u}) : V ⥤rq forget.obj (Cat.freeRefl.obj V) where\n  toPrefunctor := Quiv.adj.unit.app (V.toQuiv) ⋙q\n    Quiv.forget.map (Cat.FreeRefl.quotientFunctor V)\n  map_id := fun _ => Quotient.sound _ ⟨⟩\n\n"}
{"name":"CategoryTheory.ReflQuiv.adj.unit.app_obj","module":"Mathlib.CategoryTheory.Category.ReflQuiv","initialProofState":"V : CategoryTheory.ReflQuiv\nX : ↑V\n⊢ Eq ((CategoryTheory.ReflQuiv.adj.unit.app V).obj X) ((CategoryTheory.Cat.FreeRefl.quotientFunctor ↑V).obj ((CategoryTheory.Quiv.adj.unit.app V.toQuiv).obj X))","decl":"/-- The unit components are defined as the composite of the corresponding unit component for the\nadjunction between categories and quivers with the map underlying the quotient functor.-/\n@[simps! toPrefunctor obj map]\ndef adj.unit.app (V : ReflQuiv.{max u v, u}) : V ⥤rq forget.obj (Cat.freeRefl.obj V) where\n  toPrefunctor := Quiv.adj.unit.app (V.toQuiv) ⋙q\n    Quiv.forget.map (Cat.FreeRefl.quotientFunctor V)\n  map_id := fun _ => Quotient.sound _ ⟨⟩\n\n"}
{"name":"CategoryTheory.ReflQuiv.adj.unit.component_eq","module":"Mathlib.CategoryTheory.Category.ReflQuiv","initialProofState":"V : CategoryTheory.ReflQuiv\n⊢ Eq (CategoryTheory.ReflQuiv.forgetToQuiv.map (CategoryTheory.ReflQuiv.adj.unit.app V)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Quiv.adj.unit.app V.toQuiv) (CategoryTheory.Quiv.forget.map (CategoryTheory.Cat.FreeRefl.quotientFunctor ↑V)))","decl":"/-- This is used in the proof of both triangle equalities.-/\ntheorem adj.unit.component_eq (V : ReflQuiv.{max u v, u}) :\n    forgetToQuiv.map (adj.unit.app V) = Quiv.adj.unit.app (V.toQuiv) ≫\n    Quiv.forget.map (Y := Cat.of _) (Cat.FreeRefl.quotientFunctor V) := rfl\n\n"}
{"name":"CategoryTheory.ReflQuiv.adj.counit.app_map","module":"Mathlib.CategoryTheory.Category.ReflQuiv","initialProofState":"C : CategoryTheory.Cat\na b : CategoryTheory.Quotient CategoryTheory.Cat.FreeReflRel\nhf : Quiver.Hom a b\n⊢ Eq ((CategoryTheory.ReflQuiv.adj.counit.app C).map hf) (Quot.liftOn hf (fun f => (CategoryTheory.Quiv.adj.counit.app C).map f) ⋯)","decl":"/-- The counit components are defined using the universal property of the quotient\nfrom the corresponding counit component for the adjunction between categories and quivers.-/\n@[simps!]\ndef adj.counit.app (C : Cat) : Cat.freeRefl.obj (forget.obj C) ⥤ C :=\n  Quotient.lift Cat.FreeReflRel (Quiv.adj.counit.app C) (by\n    intro x y f g rel\n    cases rel\n    unfold Quiv.adj\n    simp only [Adjunction.mkOfHomEquiv_counit_app, Equiv.coe_fn_symm_mk,\n      Quiv.lift_map, Prefunctor.mapPath_toPath, composePath_toPath]\n    rfl)\n\n"}
{"name":"CategoryTheory.ReflQuiv.adj.counit.app_obj","module":"Mathlib.CategoryTheory.Category.ReflQuiv","initialProofState":"C : CategoryTheory.Cat\na : CategoryTheory.Quotient CategoryTheory.Cat.FreeReflRel\n⊢ Eq ((CategoryTheory.ReflQuiv.adj.counit.app C).obj a) ((CategoryTheory.Quiv.adj.counit.app C).obj a.as)","decl":"/-- The counit components are defined using the universal property of the quotient\nfrom the corresponding counit component for the adjunction between categories and quivers.-/\n@[simps!]\ndef adj.counit.app (C : Cat) : Cat.freeRefl.obj (forget.obj C) ⥤ C :=\n  Quotient.lift Cat.FreeReflRel (Quiv.adj.counit.app C) (by\n    intro x y f g rel\n    cases rel\n    unfold Quiv.adj\n    simp only [Adjunction.mkOfHomEquiv_counit_app, Equiv.coe_fn_symm_mk,\n      Quiv.lift_map, Prefunctor.mapPath_toPath, composePath_toPath]\n    rfl)\n\n"}
{"name":"CategoryTheory.ReflQuiv.adj.counit.component_eq","module":"Mathlib.CategoryTheory.Category.ReflQuiv","initialProofState":"C : CategoryTheory.Cat\n⊢ Eq ((CategoryTheory.Cat.FreeRefl.quotientFunctor ↑C).comp (CategoryTheory.ReflQuiv.adj.counit.app C)) (CategoryTheory.Quiv.adj.counit.app C)","decl":"/-- The counit of `ReflQuiv.adj` is closely related to the counit of `Quiv.adj`.-/\n@[simp]\ntheorem adj.counit.component_eq (C : Cat) :\n    Cat.FreeRefl.quotientFunctor C ⋙ adj.counit.app C =\n    Quiv.adj.counit.app C := rfl\n\n"}
{"name":"CategoryTheory.ReflQuiv.adj.counit.component_eq'","module":"Mathlib.CategoryTheory.Category.ReflQuiv","initialProofState":"C : Type u_1\ninst✝ : CategoryTheory.Category.{max u_1 u_2, u_1} C\n⊢ Eq ((CategoryTheory.Cat.FreeRefl.quotientFunctor C).comp (CategoryTheory.ReflQuiv.adj.counit.app (CategoryTheory.Cat.of C))) (CategoryTheory.Quiv.adj.counit.app (CategoryTheory.Cat.of C))","decl":"/-- The counit of `ReflQuiv.adj` is closely related to the counit of `Quiv.adj`. For ease of use,\nwe introduce primed version for unbundled categories.-/\n@[simp]\ntheorem adj.counit.component_eq' (C) [Category C] :\n    Cat.FreeRefl.quotientFunctor C ⋙ adj.counit.app (Cat.of C) =\n    Quiv.adj.counit.app (Cat.of C) := rfl\n\n"}
