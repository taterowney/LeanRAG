{"name":"CategoryTheory.Limits.Types.instPreservesLimitsOfSizeUliftFunctor","module":"Mathlib.CategoryTheory.Limits.Preserves.Ulift","initialProofState":"⊢ CategoryTheory.Limits.PreservesLimitsOfSize.{w', w, u, max u v, u + 1, max (u + 1) (v + 1)} CategoryTheory.uliftFunctor.{v, u}","decl":"/--\nThe functor `uliftFunctor : Type u ⥤ Type (max u v)` preserves limits of arbitrary size.\n-/\nnoncomputable instance : PreservesLimitsOfSize.{w', w} uliftFunctor.{v, u} where\n  preservesLimitsOfShape {J} := {\n    preservesLimit := fun {K} => {\n      preserves := fun {c} hc => by\n        rw [Types.isLimit_iff ((uliftFunctor.{v, u}).mapCone c)]\n        intro s hs\n        obtain ⟨x, hx₁, hx₂⟩ := (Types.isLimit_iff c).mp ⟨hc⟩ _ ((sectionsEquiv K).symm ⟨s, hs⟩).2\n        exact ⟨⟨x⟩, fun i => ULift.ext _ _ (hx₁ i),\n          fun y hy => ULift.ext _ _ (hx₂ y.down fun i ↦ ULift.ext_iff.mp (hy i))⟩ } }\n\n"}
{"name":"CategoryTheory.Limits.Types.instPreservesColimitsOfSizeUliftFunctor","module":"Mathlib.CategoryTheory.Limits.Preserves.Ulift","initialProofState":"⊢ CategoryTheory.Limits.PreservesColimitsOfSize.{w', w, u, max u v, u + 1, max (u + 1) (v + 1)} CategoryTheory.uliftFunctor.{v, u}","decl":"/--\nThe functor `uliftFunctor : Type u ⥤ Type (max u v)` preserves colimits of arbitrary size.\n-/\nnoncomputable instance : PreservesColimitsOfSize.{w', w} uliftFunctor.{v, u} where\n  preservesColimitsOfShape {J _} :=\n  { preservesColimit := fun {F} ↦\n    { preserves := fun {c} hc ↦ by\n        rw [isColimit_iff_bijective_desc, ← Function.Bijective.of_comp_iff _\n          (quotQuotUliftEquiv F).bijective, Quot.desc_quotQuotUliftEquiv]\n        exact ULift.up_bijective.comp ((isColimit_iff_bijective_desc c).mp (Nonempty.intro hc)) } }\n\n"}
