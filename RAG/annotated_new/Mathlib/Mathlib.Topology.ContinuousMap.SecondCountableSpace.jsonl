{"name":"ContinuousMap.compactOpen_eq_generateFrom","module":"Mathlib.Topology.ContinuousMap.SecondCountableSpace","initialProofState":"X : Type u_1\nY : Type u_2\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : TopologicalSpace Y\nS : Set (Set X)\nT : Set (Set Y)\nhSâ‚ : âˆ€ (K : Set X), Membership.mem S K â†’ IsCompact K\nhT : TopologicalSpace.IsTopologicalBasis T\nhSâ‚‚ : âˆ€ (f : ContinuousMap X Y) (x : X) (V : Set Y), Membership.mem T V â†’ Membership.mem V (f x) â†’ Exists fun K => And (Membership.mem S K) (And (Membership.mem (nhds x) K) (Set.MapsTo (â‡‘f) K V))\nâŠ¢ Eq ContinuousMap.compactOpen (TopologicalSpace.generateFrom (Set.image2 (fun K t => setOf fun f => Set.MapsTo (â‡‘f) K t.sUnion) S (setOf fun t => And t.Finite (HasSubset.Subset t T))))","decl":"theorem compactOpen_eq_generateFrom {S : Set (Set X)} {T : Set (Set Y)}\n    (hSâ‚ : âˆ€ K âˆˆ S, IsCompact K) (hT : IsTopologicalBasis T)\n    (hSâ‚‚ : âˆ€ f : C(X, Y), âˆ€ x, âˆ€ V âˆˆ T, f x âˆˆ V â†’ âˆƒ K âˆˆ S, K âˆˆ ğ“ x âˆ§ MapsTo f K V) :\n    compactOpen = .generateFrom (.image2 (fun K t â†¦\n      {f : C(X, Y) | MapsTo f K (â‹ƒâ‚€ t)}) S {t : Set (Set Y) | t.Finite âˆ§ t âŠ† T}) := by\n  apply le_antisymm\n  Â· apply_rules [generateFrom_anti, image2_subset_iff.mpr]\n    intro K hK t ht\n    exact mem_image2_of_mem (hSâ‚ K hK) (isOpen_sUnion fun _ h â†¦ hT.isOpen <| ht.2 h)\n  Â· refine le_of_nhds_le_nhds fun f â†¦ ?_\n    simp only [nhds_compactOpen, le_iInf_iff, le_principal_iff]\n    intro K (hK : IsCompact K) U (hU : IsOpen U) hfKU\n    simp only [TopologicalSpace.nhds_generateFrom]\n    obtain âŸ¨t, htT, htf, hTU, hKTâŸ© : âˆƒ t âŠ† T, t.Finite âˆ§ (âˆ€ V âˆˆ t, V âŠ† U) âˆ§ f '' K âŠ† â‹ƒâ‚€ t := by\n      rw [hT.open_eq_sUnion' hU, mapsTo', sUnion_eq_biUnion] at hfKU\n      obtain âŸ¨t, ht, hfin, htKâŸ© :=\n        (hK.image (map_continuous f)).elim_finite_subcover_image (fun V hV â†¦ hT.isOpen hV.1) hfKU\n      refine âŸ¨t, fun _ h â†¦ (ht h).1, hfin, fun _ h â†¦ (ht h).2, ?_âŸ©\n      rwa [sUnion_eq_biUnion]\n    rw [image_subset_iff] at hKT\n    obtain âŸ¨s, hsS, hsf, hKs, hstâŸ© : âˆƒ s âŠ† S, s.Finite âˆ§ K âŠ† â‹ƒâ‚€ s âˆ§ MapsTo f (â‹ƒâ‚€ s) (â‹ƒâ‚€ t) := by\n      have : âˆ€ x âˆˆ K, âˆƒ L âˆˆ S, L âˆˆ ğ“ x âˆ§ MapsTo f L (â‹ƒâ‚€ t) := by\n        intro x hx\n        rcases hKT hx with âŸ¨V, hVt, hxVâŸ©\n        rcases hSâ‚‚ f x V (htT hVt) hxV with âŸ¨L, hLS, hLx, hLVâŸ©\n        exact âŸ¨L, hLS, hLx, hLV.mono_right <| subset_sUnion_of_mem hVtâŸ©\n      choose! L hLS hLmem hLt using this\n      rcases hK.elim_nhds_subcover L hLmem with âŸ¨s, hsK, hsâŸ©\n      refine âŸ¨L '' s, image_subset_iff.2 fun x hx â†¦ hLS x <| hsK x hx, s.finite_toSet.image _,\n        by rwa [sUnion_image], ?_âŸ©\n      rw [mapsTo_sUnion, forall_mem_image]\n      exact fun x hx â†¦ hLt x <| hsK x hx\n    have hsub : (â‹‚ L âˆˆ s, {g : C(X, Y) | MapsTo g L (â‹ƒâ‚€ t)}) âŠ† {g | MapsTo g K U} := by\n      simp only [â† setOf_forall, â† mapsTo_iUnion, â† sUnion_eq_biUnion]\n      exact fun g hg â†¦ hg.mono hKs (sUnion_subset hTU)\n    refine mem_of_superset ((biInter_mem hsf).2 fun L hL â†¦ ?_) hsub\n    refine mem_iInf_of_mem _ <| mem_iInf_of_mem ?_ <| mem_principal_self _\n    exact âŸ¨hst.mono_left (subset_sUnion_of_mem hL), mem_image2_of_mem (hsS hL) âŸ¨htf, htTâŸ©âŸ©\n\n"}
{"name":"ContinuousMap.secondCountableTopology","module":"Mathlib.Topology.ContinuousMap.SecondCountableSpace","initialProofState":"X : Type u_1\nY : Type u_2\ninstâœÂ² : TopologicalSpace X\ninstâœÂ¹ : TopologicalSpace Y\ninstâœ : SecondCountableTopology Y\nhX : Exists fun S => And S.Countable (And (âˆ€ (K : Set X), Membership.mem S K â†’ IsCompact K) (âˆ€ (f : ContinuousMap X Y) (V : Set Y), IsOpen V â†’ âˆ€ (x : X), Membership.mem (Set.preimage (â‡‘f) V) x â†’ Exists fun K => And (Membership.mem S K) (And (Membership.mem (nhds x) K) (Set.MapsTo (â‡‘f) K V))))\nâŠ¢ SecondCountableTopology (ContinuousMap X Y)","decl":"/-- A version of `instSecondCountableTopology` with a technical assumption\ninstead of `[SecondCountableTopology X] [LocallyCompactSpace X]`.\nIt is here as a reminder of what could be an intermediate goal,\nif someone tries to weaken the assumptions in the instance\n(e.g., from `[LocallyCompactSpace X]` to `[LocallyCompactPair X Y]` - not sure if it's true). -/\ntheorem secondCountableTopology [SecondCountableTopology Y]\n    (hX : âˆƒ S : Set (Set X), S.Countable âˆ§ (âˆ€ K âˆˆ S, IsCompact K) âˆ§\n      âˆ€ f : C(X, Y), âˆ€ V, IsOpen V â†’ âˆ€ x âˆˆ f â»Â¹' V, âˆƒ K âˆˆ S, K âˆˆ ğ“ x âˆ§ MapsTo f K V) :\n    SecondCountableTopology C(X, Y) where\n  is_open_generated_countable := by\n    rcases hX with âŸ¨S, hScount, hScomp, hSâŸ©\n    refine âŸ¨_, ?_, compactOpen_eq_generateFrom (S := S) hScomp (isBasis_countableBasis _) ?_âŸ©\n    Â· exact .image2 hScount (countable_setOf_finite_subset (countable_countableBasis Y)) _\n    Â· intro f x V hV hx\n      apply hS\n      exacts [isOpen_of_mem_countableBasis hV, hx]\n\n"}
{"name":"ContinuousMap.instSecondCountableTopology","module":"Mathlib.Topology.ContinuousMap.SecondCountableSpace","initialProofState":"X : Type u_1\nY : Type u_2\ninstâœâ´ : TopologicalSpace X\ninstâœÂ³ : TopologicalSpace Y\ninstâœÂ² : SecondCountableTopology X\ninstâœÂ¹ : LocallyCompactSpace X\ninstâœ : SecondCountableTopology Y\nâŠ¢ SecondCountableTopology (ContinuousMap X Y)","decl":"instance instSecondCountableTopology [SecondCountableTopology X] [LocallyCompactSpace X]\n    [SecondCountableTopology Y] : SecondCountableTopology C(X, Y) := by\n  apply secondCountableTopology\n  have (U : countableBasis X) : LocallyCompactSpace U.1 :=\n    (isOpen_of_mem_countableBasis U.2).locallyCompactSpace\n  set K := fun U : countableBasis X â†¦ CompactExhaustion.choice U.1\n  use â‹ƒ U : countableBasis X, Set.range fun n â†¦ K U n\n  refine âŸ¨countable_iUnion fun _ â†¦ countable_range _, ?_, ?_âŸ©\n  Â· simp only [mem_iUnion, mem_range]\n    rintro K âŸ¨U, n, rflâŸ©\n    exact ((K U).isCompact _).image continuous_subtype_val\n  Â· intro f V hVo x hxV\n    obtain âŸ¨U, hU, hxU, hUVâŸ© : âˆƒ U âˆˆ countableBasis X, x âˆˆ U âˆ§ U âŠ† f â»Â¹' V := by\n      rw [â† (isBasis_countableBasis _).mem_nhds_iff]\n      exact (hVo.preimage (map_continuous f)).mem_nhds hxV\n    lift x to U using hxU\n    lift U to countableBasis X using hU\n    rcases (K U).exists_mem_nhds x with âŸ¨n, hnâŸ©\n    refine âŸ¨K U n, mem_iUnion.2 âŸ¨U, mem_range_self _âŸ©, ?_, ?_âŸ©\n    Â· rw [â† map_nhds_subtype_coe_eq_nhds x.2]\n      exacts [image_mem_map hn, (isOpen_of_mem_countableBasis U.2).mem_nhds x.2]\n    Â· rw [mapsTo_image_iff]\n      exact fun y _ â†¦ hUV y.2\n\n"}
{"name":"ContinuousMap.instSeparableSpace","module":"Mathlib.Topology.ContinuousMap.SecondCountableSpace","initialProofState":"X : Type u_1\nY : Type u_2\ninstâœâ´ : TopologicalSpace X\ninstâœÂ³ : TopologicalSpace Y\ninstâœÂ² : SecondCountableTopology X\ninstâœÂ¹ : LocallyCompactSpace X\ninstâœ : SecondCountableTopology Y\nâŠ¢ TopologicalSpace.SeparableSpace (ContinuousMap X Y)","decl":"instance instSeparableSpace [SecondCountableTopology X] [LocallyCompactSpace X]\n    [SecondCountableTopology Y] : SeparableSpace C(X, Y) :=\n  inferInstance\n\n"}
