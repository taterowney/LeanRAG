{"name":"ContinuousMap.compactOpen_eq_generateFrom","module":"Mathlib.Topology.ContinuousMap.SecondCountableSpace","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nS : Set (Set X)\nT : Set (Set Y)\nhS₁ : ∀ (K : Set X), Membership.mem S K → IsCompact K\nhT : TopologicalSpace.IsTopologicalBasis T\nhS₂ : ∀ (f : ContinuousMap X Y) (x : X) (V : Set Y), Membership.mem T V → Membership.mem V (f x) → Exists fun K => And (Membership.mem S K) (And (Membership.mem (nhds x) K) (Set.MapsTo (⇑f) K V))\n⊢ Eq ContinuousMap.compactOpen (TopologicalSpace.generateFrom (Set.image2 (fun K t => setOf fun f => Set.MapsTo (⇑f) K t.sUnion) S (setOf fun t => And t.Finite (HasSubset.Subset t T))))","decl":"theorem compactOpen_eq_generateFrom {S : Set (Set X)} {T : Set (Set Y)}\n    (hS₁ : ∀ K ∈ S, IsCompact K) (hT : IsTopologicalBasis T)\n    (hS₂ : ∀ f : C(X, Y), ∀ x, ∀ V ∈ T, f x ∈ V → ∃ K ∈ S, K ∈ 𝓝 x ∧ MapsTo f K V) :\n    compactOpen = .generateFrom (.image2 (fun K t ↦\n      {f : C(X, Y) | MapsTo f K (⋃₀ t)}) S {t : Set (Set Y) | t.Finite ∧ t ⊆ T}) := by\n  apply le_antisymm\n  · apply_rules [generateFrom_anti, image2_subset_iff.mpr]\n    intro K hK t ht\n    exact mem_image2_of_mem (hS₁ K hK) (isOpen_sUnion fun _ h ↦ hT.isOpen <| ht.2 h)\n  · refine le_of_nhds_le_nhds fun f ↦ ?_\n    simp only [nhds_compactOpen, le_iInf_iff, le_principal_iff]\n    intro K (hK : IsCompact K) U (hU : IsOpen U) hfKU\n    simp only [TopologicalSpace.nhds_generateFrom]\n    obtain ⟨t, htT, htf, hTU, hKT⟩ : ∃ t ⊆ T, t.Finite ∧ (∀ V ∈ t, V ⊆ U) ∧ f '' K ⊆ ⋃₀ t := by\n      rw [hT.open_eq_sUnion' hU, mapsTo', sUnion_eq_biUnion] at hfKU\n      obtain ⟨t, ht, hfin, htK⟩ :=\n        (hK.image (map_continuous f)).elim_finite_subcover_image (fun V hV ↦ hT.isOpen hV.1) hfKU\n      refine ⟨t, fun _ h ↦ (ht h).1, hfin, fun _ h ↦ (ht h).2, ?_⟩\n      rwa [sUnion_eq_biUnion]\n    rw [image_subset_iff] at hKT\n    obtain ⟨s, hsS, hsf, hKs, hst⟩ : ∃ s ⊆ S, s.Finite ∧ K ⊆ ⋃₀ s ∧ MapsTo f (⋃₀ s) (⋃₀ t) := by\n      have : ∀ x ∈ K, ∃ L ∈ S, L ∈ 𝓝 x ∧ MapsTo f L (⋃₀ t) := by\n        intro x hx\n        rcases hKT hx with ⟨V, hVt, hxV⟩\n        rcases hS₂ f x V (htT hVt) hxV with ⟨L, hLS, hLx, hLV⟩\n        exact ⟨L, hLS, hLx, hLV.mono_right <| subset_sUnion_of_mem hVt⟩\n      choose! L hLS hLmem hLt using this\n      rcases hK.elim_nhds_subcover L hLmem with ⟨s, hsK, hs⟩\n      refine ⟨L '' s, image_subset_iff.2 fun x hx ↦ hLS x <| hsK x hx, s.finite_toSet.image _,\n        by rwa [sUnion_image], ?_⟩\n      rw [mapsTo_sUnion, forall_mem_image]\n      exact fun x hx ↦ hLt x <| hsK x hx\n    have hsub : (⋂ L ∈ s, {g : C(X, Y) | MapsTo g L (⋃₀ t)}) ⊆ {g | MapsTo g K U} := by\n      simp only [← setOf_forall, ← mapsTo_iUnion, ← sUnion_eq_biUnion]\n      exact fun g hg ↦ hg.mono hKs (sUnion_subset hTU)\n    refine mem_of_superset ((biInter_mem hsf).2 fun L hL ↦ ?_) hsub\n    refine mem_iInf_of_mem _ <| mem_iInf_of_mem ?_ <| mem_principal_self _\n    exact ⟨hst.mono_left (subset_sUnion_of_mem hL), mem_image2_of_mem (hsS hL) ⟨htf, htT⟩⟩\n\n"}
{"name":"ContinuousMap.secondCountableTopology","module":"Mathlib.Topology.ContinuousMap.SecondCountableSpace","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝² : TopologicalSpace X\ninst✝¹ : TopologicalSpace Y\ninst✝ : SecondCountableTopology Y\nhX : Exists fun S => And S.Countable (And (∀ (K : Set X), Membership.mem S K → IsCompact K) (∀ (f : ContinuousMap X Y) (V : Set Y), IsOpen V → ∀ (x : X), Membership.mem (Set.preimage (⇑f) V) x → Exists fun K => And (Membership.mem S K) (And (Membership.mem (nhds x) K) (Set.MapsTo (⇑f) K V))))\n⊢ SecondCountableTopology (ContinuousMap X Y)","decl":"/-- A version of `instSecondCountableTopology` with a technical assumption\ninstead of `[SecondCountableTopology X] [LocallyCompactSpace X]`.\nIt is here as a reminder of what could be an intermediate goal,\nif someone tries to weaken the assumptions in the instance\n(e.g., from `[LocallyCompactSpace X]` to `[LocallyCompactPair X Y]` - not sure if it's true). -/\ntheorem secondCountableTopology [SecondCountableTopology Y]\n    (hX : ∃ S : Set (Set X), S.Countable ∧ (∀ K ∈ S, IsCompact K) ∧\n      ∀ f : C(X, Y), ∀ V, IsOpen V → ∀ x ∈ f ⁻¹' V, ∃ K ∈ S, K ∈ 𝓝 x ∧ MapsTo f K V) :\n    SecondCountableTopology C(X, Y) where\n  is_open_generated_countable := by\n    rcases hX with ⟨S, hScount, hScomp, hS⟩\n    refine ⟨_, ?_, compactOpen_eq_generateFrom (S := S) hScomp (isBasis_countableBasis _) ?_⟩\n    · exact .image2 hScount (countable_setOf_finite_subset (countable_countableBasis Y)) _\n    · intro f x V hV hx\n      apply hS\n      exacts [isOpen_of_mem_countableBasis hV, hx]\n\n"}
{"name":"ContinuousMap.instSecondCountableTopology","module":"Mathlib.Topology.ContinuousMap.SecondCountableSpace","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝⁴ : TopologicalSpace X\ninst✝³ : TopologicalSpace Y\ninst✝² : SecondCountableTopology X\ninst✝¹ : LocallyCompactSpace X\ninst✝ : SecondCountableTopology Y\n⊢ SecondCountableTopology (ContinuousMap X Y)","decl":"instance instSecondCountableTopology [SecondCountableTopology X] [LocallyCompactSpace X]\n    [SecondCountableTopology Y] : SecondCountableTopology C(X, Y) := by\n  apply secondCountableTopology\n  have (U : countableBasis X) : LocallyCompactSpace U.1 :=\n    (isOpen_of_mem_countableBasis U.2).locallyCompactSpace\n  set K := fun U : countableBasis X ↦ CompactExhaustion.choice U.1\n  use ⋃ U : countableBasis X, Set.range fun n ↦ K U n\n  refine ⟨countable_iUnion fun _ ↦ countable_range _, ?_, ?_⟩\n  · simp only [mem_iUnion, mem_range]\n    rintro K ⟨U, n, rfl⟩\n    exact ((K U).isCompact _).image continuous_subtype_val\n  · intro f V hVo x hxV\n    obtain ⟨U, hU, hxU, hUV⟩ : ∃ U ∈ countableBasis X, x ∈ U ∧ U ⊆ f ⁻¹' V := by\n      rw [← (isBasis_countableBasis _).mem_nhds_iff]\n      exact (hVo.preimage (map_continuous f)).mem_nhds hxV\n    lift x to U using hxU\n    lift U to countableBasis X using hU\n    rcases (K U).exists_mem_nhds x with ⟨n, hn⟩\n    refine ⟨K U n, mem_iUnion.2 ⟨U, mem_range_self _⟩, ?_, ?_⟩\n    · rw [← map_nhds_subtype_coe_eq_nhds x.2]\n      exacts [image_mem_map hn, (isOpen_of_mem_countableBasis U.2).mem_nhds x.2]\n    · rw [mapsTo_image_iff]\n      exact fun y _ ↦ hUV y.2\n\n"}
{"name":"ContinuousMap.instSeparableSpace","module":"Mathlib.Topology.ContinuousMap.SecondCountableSpace","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝⁴ : TopologicalSpace X\ninst✝³ : TopologicalSpace Y\ninst✝² : SecondCountableTopology X\ninst✝¹ : LocallyCompactSpace X\ninst✝ : SecondCountableTopology Y\n⊢ TopologicalSpace.SeparableSpace (ContinuousMap X Y)","decl":"instance instSeparableSpace [SecondCountableTopology X] [LocallyCompactSpace X]\n    [SecondCountableTopology Y] : SeparableSpace C(X, Y) :=\n  inferInstance\n\n"}
