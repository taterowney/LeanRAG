{"name":"Finset.prod_eq_zero","module":"Mathlib.Algebra.BigOperators.GroupWithZero.Finset","initialProofState":"ι : Type u_1\nM₀ : Type u_4\ninst✝ : CommMonoidWithZero M₀\nf : ι → M₀\ns : Finset ι\ni : ι\nhi : Membership.mem s i\nh : Eq (f i) 0\n⊢ Eq (s.prod fun j => f j) 0","decl":"lemma prod_eq_zero (hi : i ∈ s) (h : f i = 0) : ∏ j ∈ s, f j = 0 := by\n  classical rw [← prod_erase_mul _ _ hi, h, mul_zero]\n\n"}
{"name":"Finset.prod_ite_zero","module":"Mathlib.Algebra.BigOperators.GroupWithZero.Finset","initialProofState":"ι : Type u_1\nM₀ : Type u_4\ninst✝¹ : CommMonoidWithZero M₀\np : ι → Prop\ninst✝ : DecidablePred p\nf : ι → M₀\ns : Finset ι\n⊢ Eq (s.prod fun i => ite (p i) (f i) 0) (ite (∀ (i : ι), Membership.mem s i → p i) (s.prod fun i => f i) 0)","decl":"lemma prod_ite_zero :\n    (∏ i ∈ s, if p i then f i else 0) = if ∀ i ∈ s, p i then ∏ i ∈ s, f i else 0 := by\n  split_ifs with h\n  · exact prod_congr rfl fun i hi => by simp [h i hi]\n  · push_neg at h\n    rcases h with ⟨i, hi, hq⟩\n    exact prod_eq_zero hi (by simp [hq])\n\n"}
{"name":"Finset.prod_boole","module":"Mathlib.Algebra.BigOperators.GroupWithZero.Finset","initialProofState":"ι : Type u_1\nM₀ : Type u_4\ninst✝¹ : CommMonoidWithZero M₀\np : ι → Prop\ninst✝ : DecidablePred p\ns : Finset ι\n⊢ Eq (s.prod fun i => ite (p i) 1 0) (ite (∀ (i : ι), Membership.mem s i → p i) 1 0)","decl":"lemma prod_boole : ∏ i ∈ s, (ite (p i) 1 0 : M₀) = ite (∀ i ∈ s, p i) 1 0 := by\n  rw [prod_ite_zero, prod_const_one]\n\n"}
{"name":"Finset.support_prod_subset","module":"Mathlib.Algebra.BigOperators.GroupWithZero.Finset","initialProofState":"ι : Type u_1\nκ : Type u_2\nM₀ : Type u_4\ninst✝ : CommMonoidWithZero M₀\ns : Finset ι\nf : ι → κ → M₀\n⊢ HasSubset.Subset (Function.support fun x => s.prod fun i => f i x) (Set.iInter fun i => Set.iInter fun h => Function.support (f i))","decl":"lemma support_prod_subset (s : Finset ι) (f : ι → κ → M₀) :\n    support (fun x ↦ ∏ i ∈ s, f i x) ⊆ ⋂ i ∈ s, support (f i) :=\n  fun _ hx ↦ Set.mem_iInter₂.2 fun _ hi H ↦ hx <| prod_eq_zero hi H\n\n"}
{"name":"Finset.prod_eq_zero_iff","module":"Mathlib.Algebra.BigOperators.GroupWithZero.Finset","initialProofState":"ι : Type u_1\nM₀ : Type u_4\ninst✝² : CommMonoidWithZero M₀\nf : ι → M₀\ns : Finset ι\ninst✝¹ : Nontrivial M₀\ninst✝ : NoZeroDivisors M₀\n⊢ Iff (Eq (s.prod fun x => f x) 0) (Exists fun a => And (Membership.mem s a) (Eq (f a) 0))","decl":"lemma prod_eq_zero_iff : ∏ x ∈ s, f x = 0 ↔ ∃ a ∈ s, f a = 0 := by\n  classical\n    induction s using Finset.induction_on with\n    | empty => exact ⟨Not.elim one_ne_zero, fun ⟨_, H, _⟩ => by simp at H⟩\n    | insert ha ih => rw [prod_insert ha, mul_eq_zero, exists_mem_insert, ih]\n\n"}
{"name":"Finset.prod_ne_zero_iff","module":"Mathlib.Algebra.BigOperators.GroupWithZero.Finset","initialProofState":"ι : Type u_1\nM₀ : Type u_4\ninst✝² : CommMonoidWithZero M₀\nf : ι → M₀\ns : Finset ι\ninst✝¹ : Nontrivial M₀\ninst✝ : NoZeroDivisors M₀\n⊢ Iff (Ne (s.prod fun x => f x) 0) (∀ (a : ι), Membership.mem s a → Ne (f a) 0)","decl":"lemma prod_ne_zero_iff : ∏ x ∈ s, f x ≠ 0 ↔ ∀ a ∈ s, f a ≠ 0 := by\n  rw [Ne, prod_eq_zero_iff]\n  push_neg; rfl\n\n"}
{"name":"Finset.support_prod","module":"Mathlib.Algebra.BigOperators.GroupWithZero.Finset","initialProofState":"ι : Type u_1\nκ : Type u_2\nM₀ : Type u_4\ninst✝² : CommMonoidWithZero M₀\ninst✝¹ : Nontrivial M₀\ninst✝ : NoZeroDivisors M₀\ns : Finset ι\nf : ι → κ → M₀\n⊢ Eq (Function.support fun j => s.prod fun i => f i j) (Set.iInter fun i => Set.iInter fun h => Function.support (f i))","decl":"lemma support_prod (s : Finset ι) (f : ι → κ → M₀) :\n    support (fun j ↦ ∏ i ∈ s, f i j) = ⋂ i ∈ s, support (f i) :=\n  Set.ext fun x ↦ by simp [support, prod_eq_zero_iff]\n\n"}
{"name":"Fintype.prod_ite_zero","module":"Mathlib.Algebra.BigOperators.GroupWithZero.Finset","initialProofState":"ι : Type u_1\nM₀ : Type u_4\ninst✝² : Fintype ι\ninst✝¹ : CommMonoidWithZero M₀\np : ι → Prop\ninst✝ : DecidablePred p\nf : ι → M₀\n⊢ Eq (Finset.univ.prod fun i => ite (p i) (f i) 0) (ite (∀ (i : ι), p i) (Finset.univ.prod fun i => f i) 0)","decl":"lemma prod_ite_zero : (∏ i, if p i then f i else 0) = if ∀ i, p i then ∏ i, f i else 0 := by\n  simp [Finset.prod_ite_zero]\n\n"}
{"name":"Fintype.prod_boole","module":"Mathlib.Algebra.BigOperators.GroupWithZero.Finset","initialProofState":"ι : Type u_1\nM₀ : Type u_4\ninst✝² : Fintype ι\ninst✝¹ : CommMonoidWithZero M₀\np : ι → Prop\ninst✝ : DecidablePred p\n⊢ Eq (Finset.univ.prod fun i => ite (p i) 1 0) (ite (∀ (i : ι), p i) 1 0)","decl":"lemma prod_boole : ∏ i, (ite (p i) 1 0 : M₀) = ite (∀ i, p i) 1 0 := by simp [Finset.prod_boole]\n\n"}
{"name":"Units.mk0_prod","module":"Mathlib.Algebra.BigOperators.GroupWithZero.Finset","initialProofState":"ι : Type u_1\nG₀ : Type u_3\ninst✝ : CommGroupWithZero G₀\ns : Finset ι\nf : ι → G₀\nh : Ne (s.prod fun i => f i) 0\n⊢ Eq (Units.mk0 (s.prod fun i => f i) h) (s.attach.prod fun i => Units.mk0 (f ↑i) ⋯)","decl":"lemma Units.mk0_prod [CommGroupWithZero G₀] (s : Finset ι) (f : ι → G₀) (h) :\n    Units.mk0 (∏ i ∈ s, f i) h =\n      ∏ i ∈ s.attach, Units.mk0 (f i) fun hh ↦ h (Finset.prod_eq_zero i.2 hh) := by\n  classical induction s using Finset.induction_on <;> simp [*]\n"}
