{"name":"Submodule.coe_inner","module":"Mathlib.Analysis.InnerProductSpace.Subspace","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nW : Submodule ğ•œ E\nx y : Subtype fun x => Membership.mem W x\nâŠ¢ Eq (Inner.inner x y) (Inner.inner â†‘x â†‘y)","decl":"/-- The inner product on submodules is the same as on the ambient space. -/\n@[simp]\ntheorem Submodule.coe_inner (W : Submodule ğ•œ E) (x y : W) : âŸªx, yâŸ« = âŸª(x : E), â†‘yâŸ« :=\n  rfl\n\n"}
{"name":"Orthonormal.codRestrict","module":"Mathlib.Analysis.InnerProductSpace.Subspace","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nÎ¹ : Type u_4\nv : Î¹ â†’ E\nhv : Orthonormal ğ•œ v\ns : Submodule ğ•œ E\nhvs : âˆ€ (i : Î¹), Membership.mem s (v i)\nâŠ¢ Orthonormal ğ•œ (Set.codRestrict v (â†‘s) hvs)","decl":"theorem Orthonormal.codRestrict {Î¹ : Type*} {v : Î¹ â†’ E} (hv : Orthonormal ğ•œ v) (s : Submodule ğ•œ E)\n    (hvs : âˆ€ i, v i âˆˆ s) : @Orthonormal ğ•œ s _ _ _ Î¹ (Set.codRestrict v s hvs) :=\n  s.subtypeâ‚—áµ¢.orthonormal_comp_iff.mp hv\n\n"}
{"name":"orthonormal_span","module":"Mathlib.Analysis.InnerProductSpace.Subspace","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nÎ¹ : Type u_4\nv : Î¹ â†’ E\nhv : Orthonormal ğ•œ v\nâŠ¢ Orthonormal ğ•œ fun i => âŸ¨v i, â‹¯âŸ©","decl":"theorem orthonormal_span {Î¹ : Type*} {v : Î¹ â†’ E} (hv : Orthonormal ğ•œ v) :\n    @Orthonormal ğ•œ (Submodule.span ğ•œ (Set.range v)) _ _ _ Î¹ fun i : Î¹ =>\n      âŸ¨v i, Submodule.subset_span (Set.mem_range_self i)âŸ© :=\n  hv.codRestrict (Submodule.span ğ•œ (Set.range v)) fun i =>\n    Submodule.subset_span (Set.mem_range_self i)\n\n"}
{"name":"Orthonormal.orthogonalFamily","module":"Mathlib.Analysis.InnerProductSpace.Subspace","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nÎ¹ : Type u_4\nv : Î¹ â†’ E\nhv : Orthonormal ğ•œ v\nâŠ¢ OrthogonalFamily ğ•œ (fun _i => ğ•œ) fun i => LinearIsometry.toSpanSingleton ğ•œ E â‹¯","decl":"theorem Orthonormal.orthogonalFamily {v : Î¹ â†’ E} (hv : Orthonormal ğ•œ v) :\n    OrthogonalFamily ğ•œ (fun _i : Î¹ => ğ•œ) fun i => LinearIsometry.toSpanSingleton ğ•œ E (hv.1 i) :=\n  fun i j hij a b => by simp [inner_smul_left, inner_smul_right, hv.2 hij]\n\n"}
{"name":"OrthogonalFamily.eq_ite","module":"Mathlib.Analysis.InnerProductSpace.Subspace","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœâµ : RCLike ğ•œ\ninstâœâ´ : SeminormedAddCommGroup E\ninstâœÂ³ : InnerProductSpace ğ•œ E\nÎ¹ : Type u_4\nG : Î¹ â†’ Type u_5\ninstâœÂ² : (i : Î¹) â†’ NormedAddCommGroup (G i)\ninstâœÂ¹ : (i : Î¹) â†’ InnerProductSpace ğ•œ (G i)\nV : (i : Î¹) â†’ LinearIsometry (RingHom.id ğ•œ) (G i) E\nhV : OrthogonalFamily ğ•œ G V\ninstâœ : DecidableEq Î¹\ni j : Î¹\nv : G i\nw : G j\nâŠ¢ Eq (Inner.inner ((V i) v) ((V j) w)) (ite (Eq i j) (Inner.inner ((V i) v) ((V j) w)) 0)","decl":"theorem OrthogonalFamily.eq_ite [DecidableEq Î¹] {i j : Î¹} (v : G i) (w : G j) :\n    âŸªV i v, V j wâŸ« = ite (i = j) âŸªV i v, V j wâŸ« 0 := by\n  split_ifs with h\n  Â· rfl\n  Â· exact hV h v w\n\n"}
{"name":"OrthogonalFamily.inner_right_dfinsupp","module":"Mathlib.Analysis.InnerProductSpace.Subspace","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœâ¶ : RCLike ğ•œ\ninstâœâµ : SeminormedAddCommGroup E\ninstâœâ´ : InnerProductSpace ğ•œ E\nÎ¹ : Type u_4\nG : Î¹ â†’ Type u_5\ninstâœÂ³ : (i : Î¹) â†’ NormedAddCommGroup (G i)\ninstâœÂ² : (i : Î¹) â†’ InnerProductSpace ğ•œ (G i)\nV : (i : Î¹) â†’ LinearIsometry (RingHom.id ğ•œ) (G i) E\nhV : OrthogonalFamily ğ•œ G V\ninstâœÂ¹ : (i : Î¹) â†’ (x : G i) â†’ Decidable (Ne x 0)\ninstâœ : DecidableEq Î¹\nl : DirectSum Î¹ fun i => G i\ni : Î¹\nv : G i\nâŠ¢ Eq (Inner.inner ((V i) v) (DFinsupp.sum l fun j => â‡‘(V j))) (Inner.inner v (l i))","decl":"theorem OrthogonalFamily.inner_right_dfinsupp\n    [âˆ€ (i) (x : G i), Decidable (x â‰  0)] [DecidableEq Î¹] (l : â¨ i, G i) (i : Î¹) (v : G i) :\n    âŸªV i v, l.sum fun j => V jâŸ« = âŸªv, l iâŸ« :=\n  calc\n    âŸªV i v, l.sum fun j => V jâŸ« = l.sum fun j => fun w => âŸªV i v, V j wâŸ« :=\n      DFinsupp.inner_sum (fun j => V j) l (V i v)\n    _ = l.sum fun j => fun w => ite (i = j) âŸªV i v, V j wâŸ« 0 :=\n      (congr_arg l.sum <| funext fun _ => funext <| hV.eq_ite v)\n    _ = âŸªv, l iâŸ« := by\n      simp only [DFinsupp.sum, Submodule.coe_inner, Finset.sum_ite_eq, ite_eq_left_iff,\n        DFinsupp.mem_support_toFun]\n      split_ifs with h\n      Â· simp only [LinearIsometry.inner_map_map]\n      Â· simp only [of_not_not h, inner_zero_right]\n\n"}
{"name":"OrthogonalFamily.inner_right_fintype","module":"Mathlib.Analysis.InnerProductSpace.Subspace","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœâµ : RCLike ğ•œ\ninstâœâ´ : SeminormedAddCommGroup E\ninstâœÂ³ : InnerProductSpace ğ•œ E\nÎ¹ : Type u_4\nG : Î¹ â†’ Type u_5\ninstâœÂ² : (i : Î¹) â†’ NormedAddCommGroup (G i)\ninstâœÂ¹ : (i : Î¹) â†’ InnerProductSpace ğ•œ (G i)\nV : (i : Î¹) â†’ LinearIsometry (RingHom.id ğ•œ) (G i) E\nhV : OrthogonalFamily ğ•œ G V\ninstâœ : Fintype Î¹\nl : (i : Î¹) â†’ G i\ni : Î¹\nv : G i\nâŠ¢ Eq (Inner.inner ((V i) v) (Finset.univ.sum fun j => (V j) (l j))) (Inner.inner v (l i))","decl":"theorem OrthogonalFamily.inner_right_fintype [Fintype Î¹] (l : âˆ€ i, G i) (i : Î¹) (v : G i) :\n    âŸªV i v, âˆ‘ j : Î¹, V j (l j)âŸ« = âŸªv, l iâŸ« := by\n  classical\n  calc\n    âŸªV i v, âˆ‘ j : Î¹, V j (l j)âŸ« = âˆ‘ j : Î¹, âŸªV i v, V j (l j)âŸ« := by rw [inner_sum]\n    _ = âˆ‘ j, ite (i = j) âŸªV i v, V j (l j)âŸ« 0 :=\n      (congr_arg (Finset.sum Finset.univ) <| funext fun j => hV.eq_ite v (l j))\n    _ = âŸªv, l iâŸ« := by\n      simp only [Finset.sum_ite_eq, Finset.mem_univ, (V i).inner_map_map, if_true]\n\n"}
{"name":"OrthogonalFamily.inner_sum","module":"Mathlib.Analysis.InnerProductSpace.Subspace","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœâ´ : RCLike ğ•œ\ninstâœÂ³ : SeminormedAddCommGroup E\ninstâœÂ² : InnerProductSpace ğ•œ E\nÎ¹ : Type u_4\nG : Î¹ â†’ Type u_5\ninstâœÂ¹ : (i : Î¹) â†’ NormedAddCommGroup (G i)\ninstâœ : (i : Î¹) â†’ InnerProductSpace ğ•œ (G i)\nV : (i : Î¹) â†’ LinearIsometry (RingHom.id ğ•œ) (G i) E\nhV : OrthogonalFamily ğ•œ G V\nlâ‚ lâ‚‚ : (i : Î¹) â†’ G i\ns : Finset Î¹\nâŠ¢ Eq (Inner.inner (s.sum fun i => (V i) (lâ‚ i)) (s.sum fun j => (V j) (lâ‚‚ j))) (s.sum fun i => Inner.inner (lâ‚ i) (lâ‚‚ i))","decl":"nonrec theorem OrthogonalFamily.inner_sum (lâ‚ lâ‚‚ : âˆ€ i, G i) (s : Finset Î¹) :\n    âŸªâˆ‘ i âˆˆ s, V i (lâ‚ i), âˆ‘ j âˆˆ s, V j (lâ‚‚ j)âŸ« = âˆ‘ i âˆˆ s, âŸªlâ‚ i, lâ‚‚ iâŸ« := by\n  classical\n  calc\n    âŸªâˆ‘ i âˆˆ s, V i (lâ‚ i), âˆ‘ j âˆˆ s, V j (lâ‚‚ j)âŸ« = âˆ‘ j âˆˆ s, âˆ‘ i âˆˆ s, âŸªV i (lâ‚ i), V j (lâ‚‚ j)âŸ« := by\n      simp only [sum_inner, inner_sum]\n    _ = âˆ‘ j âˆˆ s, âˆ‘ i âˆˆ s, ite (i = j) âŸªV i (lâ‚ i), V j (lâ‚‚ j)âŸ« 0 := by\n      congr with i\n      congr with j\n      apply hV.eq_ite\n    _ = âˆ‘ i âˆˆ s, âŸªlâ‚ i, lâ‚‚ iâŸ« := by\n      simp only [Finset.sum_ite_of_true, Finset.sum_ite_eq', LinearIsometry.inner_map_map,\n        imp_self, imp_true_iff]\n\n"}
{"name":"OrthogonalFamily.norm_sum","module":"Mathlib.Analysis.InnerProductSpace.Subspace","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœâ´ : RCLike ğ•œ\ninstâœÂ³ : SeminormedAddCommGroup E\ninstâœÂ² : InnerProductSpace ğ•œ E\nÎ¹ : Type u_4\nG : Î¹ â†’ Type u_5\ninstâœÂ¹ : (i : Î¹) â†’ NormedAddCommGroup (G i)\ninstâœ : (i : Î¹) â†’ InnerProductSpace ğ•œ (G i)\nV : (i : Î¹) â†’ LinearIsometry (RingHom.id ğ•œ) (G i) E\nhV : OrthogonalFamily ğ•œ G V\nl : (i : Î¹) â†’ G i\ns : Finset Î¹\nâŠ¢ Eq (HPow.hPow (Norm.norm (s.sum fun i => (V i) (l i))) 2) (s.sum fun i => HPow.hPow (Norm.norm (l i)) 2)","decl":"theorem OrthogonalFamily.norm_sum (l : âˆ€ i, G i) (s : Finset Î¹) :\n    â€–âˆ‘ i âˆˆ s, V i (l i)â€– ^ 2 = âˆ‘ i âˆˆ s, â€–l iâ€– ^ 2 := by\n  have : ((â€–âˆ‘ i âˆˆ s, V i (l i)â€– : â„) : ğ•œ) ^ 2 = âˆ‘ i âˆˆ s, ((â€–l iâ€– : â„) : ğ•œ) ^ 2 := by\n    simp only [â† inner_self_eq_norm_sq_to_K, hV.inner_sum]\n  exact mod_cast this\n\n"}
{"name":"OrthogonalFamily.comp","module":"Mathlib.Analysis.InnerProductSpace.Subspace","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœâ´ : RCLike ğ•œ\ninstâœÂ³ : SeminormedAddCommGroup E\ninstâœÂ² : InnerProductSpace ğ•œ E\nÎ¹ : Type u_4\nG : Î¹ â†’ Type u_5\ninstâœÂ¹ : (i : Î¹) â†’ NormedAddCommGroup (G i)\ninstâœ : (i : Î¹) â†’ InnerProductSpace ğ•œ (G i)\nV : (i : Î¹) â†’ LinearIsometry (RingHom.id ğ•œ) (G i) E\nhV : OrthogonalFamily ğ•œ G V\nÎ³ : Type u_6\nf : Î³ â†’ Î¹\nhf : Function.Injective f\nâŠ¢ OrthogonalFamily ğ•œ (fun g => G (f g)) fun g => V (f g)","decl":"/-- The composition of an orthogonal family of subspaces with an injective function is also an\northogonal family. -/\ntheorem OrthogonalFamily.comp {Î³ : Type*} {f : Î³ â†’ Î¹} (hf : Function.Injective f) :\n    OrthogonalFamily ğ•œ (fun g => G (f g)) fun g => V (f g) :=\n  fun _i _j hij v w => hV (hf.ne hij) v w\n\n"}
{"name":"OrthogonalFamily.orthonormal_sigma_orthonormal","module":"Mathlib.Analysis.InnerProductSpace.Subspace","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœâ´ : RCLike ğ•œ\ninstâœÂ³ : SeminormedAddCommGroup E\ninstâœÂ² : InnerProductSpace ğ•œ E\nÎ¹ : Type u_4\nG : Î¹ â†’ Type u_5\ninstâœÂ¹ : (i : Î¹) â†’ NormedAddCommGroup (G i)\ninstâœ : (i : Î¹) â†’ InnerProductSpace ğ•œ (G i)\nV : (i : Î¹) â†’ LinearIsometry (RingHom.id ğ•œ) (G i) E\nhV : OrthogonalFamily ğ•œ G V\nÎ± : Î¹ â†’ Type u_6\nv_family : (i : Î¹) â†’ Î± i â†’ G i\nhv_family : âˆ€ (i : Î¹), Orthonormal ğ•œ (v_family i)\nâŠ¢ Orthonormal ğ•œ fun a => (V a.fst) (v_family a.fst a.snd)","decl":"theorem OrthogonalFamily.orthonormal_sigma_orthonormal {Î± : Î¹ â†’ Type*} {v_family : âˆ€ i, Î± i â†’ G i}\n    (hv_family : âˆ€ i, Orthonormal ğ•œ (v_family i)) :\n    Orthonormal ğ•œ fun a : Î£i, Î± i => V a.1 (v_family a.1 a.2) := by\n  constructor\n  Â· rintro âŸ¨i, vâŸ©\n    simpa only [LinearIsometry.norm_map] using (hv_family i).left v\n  rintro âŸ¨i, vâŸ© âŸ¨j, wâŸ© hvw\n  by_cases hij : i = j\n  Â· subst hij\n    have : v â‰  w := fun h => by\n      subst h\n      exact hvw rfl\n    simpa only [LinearIsometry.inner_map_map] using (hv_family i).2 this\n  Â· exact hV hij (v_family i v) (v_family j w)\n\n"}
{"name":"OrthogonalFamily.norm_sq_diff_sum","module":"Mathlib.Analysis.InnerProductSpace.Subspace","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœâµ : RCLike ğ•œ\ninstâœâ´ : SeminormedAddCommGroup E\ninstâœÂ³ : InnerProductSpace ğ•œ E\nÎ¹ : Type u_4\nG : Î¹ â†’ Type u_5\ninstâœÂ² : (i : Î¹) â†’ NormedAddCommGroup (G i)\ninstâœÂ¹ : (i : Î¹) â†’ InnerProductSpace ğ•œ (G i)\nV : (i : Î¹) â†’ LinearIsometry (RingHom.id ğ•œ) (G i) E\nhV : OrthogonalFamily ğ•œ G V\ninstâœ : DecidableEq Î¹\nf : (i : Î¹) â†’ G i\nsâ‚ sâ‚‚ : Finset Î¹\nâŠ¢ Eq (HPow.hPow (Norm.norm (HSub.hSub (sâ‚.sum fun i => (V i) (f i)) (sâ‚‚.sum fun i => (V i) (f i)))) 2) (HAdd.hAdd ((SDiff.sdiff sâ‚ sâ‚‚).sum fun i => HPow.hPow (Norm.norm (f i)) 2) ((SDiff.sdiff sâ‚‚ sâ‚).sum fun i => HPow.hPow (Norm.norm (f i)) 2))","decl":"theorem OrthogonalFamily.norm_sq_diff_sum [DecidableEq Î¹] (f : âˆ€ i, G i) (sâ‚ sâ‚‚ : Finset Î¹) :\n    â€–(âˆ‘ i âˆˆ sâ‚, V i (f i)) - âˆ‘ i âˆˆ sâ‚‚, V i (f i)â€– ^ 2 =\n      (âˆ‘ i âˆˆ sâ‚ \\ sâ‚‚, â€–f iâ€– ^ 2) + âˆ‘ i âˆˆ sâ‚‚ \\ sâ‚, â€–f iâ€– ^ 2 := by\n  rw [â† Finset.sum_sdiff_sub_sum_sdiff, sub_eq_add_neg, â† Finset.sum_neg_distrib]\n  let F : âˆ€ i, G i := fun i => if i âˆˆ sâ‚ then f i else -f i\n  have hFâ‚ : âˆ€ i âˆˆ sâ‚ \\ sâ‚‚, F i = f i := fun i hi => if_pos (Finset.sdiff_subset hi)\n  have hFâ‚‚ : âˆ€ i âˆˆ sâ‚‚ \\ sâ‚, F i = -f i := fun i hi => if_neg (Finset.mem_sdiff.mp hi).2\n  have hF : âˆ€ i, â€–F iâ€– = â€–f iâ€– := by\n    intro i\n    dsimp only [F]\n    split_ifs <;> simp only [eq_self_iff_true, norm_neg]\n  have :\n    â€–(âˆ‘ i âˆˆ sâ‚ \\ sâ‚‚, V i (F i)) + âˆ‘ i âˆˆ sâ‚‚ \\ sâ‚, V i (F i)â€– ^ 2 =\n      (âˆ‘ i âˆˆ sâ‚ \\ sâ‚‚, â€–F iâ€– ^ 2) + âˆ‘ i âˆˆ sâ‚‚ \\ sâ‚, â€–F iâ€– ^ 2 := by\n    have hs : Disjoint (sâ‚ \\ sâ‚‚) (sâ‚‚ \\ sâ‚) := disjoint_sdiff_sdiff\n    simpa only [Finset.sum_union hs] using hV.norm_sum F (sâ‚ \\ sâ‚‚ âˆª sâ‚‚ \\ sâ‚)\n  convert this using 4\n  Â· refine Finset.sum_congr rfl fun i hi => ?_\n    simp only [hFâ‚ i hi]\n  Â· refine Finset.sum_congr rfl fun i hi => ?_\n    simp only [hFâ‚‚ i hi, LinearIsometry.map_neg]\n  Â· simp only [hF]\n  Â· simp only [hF]\n\n"}
{"name":"OrthogonalFamily.summable_iff_norm_sq_summable","module":"Mathlib.Analysis.InnerProductSpace.Subspace","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœâµ : RCLike ğ•œ\ninstâœâ´ : SeminormedAddCommGroup E\ninstâœÂ³ : InnerProductSpace ğ•œ E\nÎ¹ : Type u_4\nG : Î¹ â†’ Type u_5\ninstâœÂ² : (i : Î¹) â†’ NormedAddCommGroup (G i)\ninstâœÂ¹ : (i : Î¹) â†’ InnerProductSpace ğ•œ (G i)\nV : (i : Î¹) â†’ LinearIsometry (RingHom.id ğ•œ) (G i) E\nhV : OrthogonalFamily ğ•œ G V\ninstâœ : CompleteSpace E\nf : (i : Î¹) â†’ G i\nâŠ¢ Iff (Summable fun i => (V i) (f i)) (Summable fun i => HPow.hPow (Norm.norm (f i)) 2)","decl":"/-- A family `f` of mutually-orthogonal elements of `E` is summable, if and only if\n`(fun i â†¦ â€–f iâ€– ^ 2)` is summable. -/\ntheorem OrthogonalFamily.summable_iff_norm_sq_summable [CompleteSpace E] (f : âˆ€ i, G i) :\n    (Summable fun i => V i (f i)) â†” Summable fun i => â€–f iâ€– ^ 2 := by\n  classical\n    simp only [summable_iff_cauchySeq_finset, NormedAddCommGroup.cauchySeq_iff, Real.norm_eq_abs]\n    constructor\n    Â· intro hf Îµ hÎµ\n      obtain âŸ¨a, HâŸ© := hf _ (sqrt_pos.mpr hÎµ)\n      use a\n      intro sâ‚ hsâ‚ sâ‚‚ hsâ‚‚\n      rw [â† Finset.sum_sdiff_sub_sum_sdiff]\n      refine (abs_sub _ _).trans_lt ?_\n      have : âˆ€ i, 0 â‰¤ â€–f iâ€– ^ 2 := fun i : Î¹ => sq_nonneg _\n      simp only [Finset.abs_sum_of_nonneg' this]\n      have : ((âˆ‘ i âˆˆ sâ‚ \\ sâ‚‚, â€–f iâ€– ^ 2) + âˆ‘ i âˆˆ sâ‚‚ \\ sâ‚, â€–f iâ€– ^ 2) < âˆšÎµ ^ 2 := by\n        rw [â† hV.norm_sq_diff_sum, sq_lt_sq, abs_of_nonneg (sqrt_nonneg _),\n          abs_of_nonneg (norm_nonneg _)]\n        exact H sâ‚ hsâ‚ sâ‚‚ hsâ‚‚\n      have hÎ· := sq_sqrt (le_of_lt hÎµ)\n      linarith\n    Â· intro hf Îµ hÎµ\n      have hÎµ' : 0 < Îµ ^ 2 / 2 := half_pos (sq_pos_of_pos hÎµ)\n      obtain âŸ¨a, HâŸ© := hf _ hÎµ'\n      use a\n      intro sâ‚ hsâ‚ sâ‚‚ hsâ‚‚\n      refine (abs_lt_of_sq_lt_sq' ?_ (le_of_lt hÎµ)).2\n      have has : a â‰¤ sâ‚ âŠ“ sâ‚‚ := le_inf hsâ‚ hsâ‚‚\n      rw [hV.norm_sq_diff_sum]\n      have Hsâ‚ : âˆ‘ x âˆˆ sâ‚ \\ sâ‚‚, â€–f xâ€– ^ 2 < Îµ ^ 2 / 2 := by\n        convert H _ hsâ‚ _ has\n        have : sâ‚ âŠ“ sâ‚‚ âŠ† sâ‚ := Finset.inter_subset_left\n        rw [â† Finset.sum_sdiff this, add_tsub_cancel_right, Finset.abs_sum_of_nonneg']\n        Â· simp\n        Â· exact fun i => sq_nonneg _\n      have Hsâ‚‚ : âˆ‘ x âˆˆ sâ‚‚ \\ sâ‚, â€–f xâ€– ^ 2 < Îµ ^ 2 / 2 := by\n        convert H _ hsâ‚‚ _ has\n        have : sâ‚ âŠ“ sâ‚‚ âŠ† sâ‚‚ := Finset.inter_subset_right\n        rw [â† Finset.sum_sdiff this, add_tsub_cancel_right, Finset.abs_sum_of_nonneg']\n        Â· simp\n        Â· exact fun i => sq_nonneg _\n      linarith\n\n"}
{"name":"OrthogonalFamily.independent","module":"Mathlib.Analysis.InnerProductSpace.Subspace","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nÎ¹ : Type u_4\nV : Î¹ â†’ Submodule ğ•œ E\nhV : OrthogonalFamily ğ•œ (fun i => Subtype fun x => Membership.mem (V i) x) fun i => (V i).subtypeâ‚—áµ¢\nâŠ¢ iSupIndep V","decl":"/-- An orthogonal family forms an independent family of subspaces; that is, any collection of\nelements each from a different subspace in the family is linearly independent. In particular, the\npairwise intersections of elements of the family are 0. -/\ntheorem OrthogonalFamily.independent {V : Î¹ â†’ Submodule ğ•œ E}\n    (hV : OrthogonalFamily ğ•œ (fun i => V i) fun i => (V i).subtypeâ‚—áµ¢) :\n    iSupIndep V := by\n  classical\n  apply iSupIndep_of_dfinsupp_lsum_injective\n  refine LinearMap.ker_eq_bot.mp ?_\n  rw [Submodule.eq_bot_iff]\n  intro v hv\n  rw [LinearMap.mem_ker] at hv\n  ext i\n  suffices âŸª(v i : E), v iâŸ« = 0 by simpa only [inner_self_eq_zero] using this\n  calc\n    âŸª(v i : E), v iâŸ« = âŸª(v i : E), DFinsupp.lsum â„• (fun i => (V i).subtype) vâŸ« := by\n      simpa only [DFinsupp.sumAddHom_apply, DFinsupp.lsum_apply_apply] using\n        (hV.inner_right_dfinsupp v i (v i)).symm\n    _ = 0 := by simp only [hv, inner_zero_right]\n\n"}
{"name":"DirectSum.IsInternal.collectedBasis_orthonormal","module":"Mathlib.Analysis.InnerProductSpace.Subspace","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ³ : RCLike ğ•œ\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : InnerProductSpace ğ•œ E\nÎ¹ : Type u_4\ninstâœ : DecidableEq Î¹\nV : Î¹ â†’ Submodule ğ•œ E\nhV : OrthogonalFamily ğ•œ (fun i => Subtype fun x => Membership.mem (V i) x) fun i => (V i).subtypeâ‚—áµ¢\nhV_sum : DirectSum.IsInternal fun i => V i\nÎ± : Î¹ â†’ Type u_6\nv_family : (i : Î¹) â†’ Basis (Î± i) ğ•œ (Subtype fun x => Membership.mem (V i) x)\nhv_family : âˆ€ (i : Î¹), Orthonormal ğ•œ â‡‘(v_family i)\nâŠ¢ Orthonormal ğ•œ â‡‘(hV_sum.collectedBasis v_family)","decl":"theorem DirectSum.IsInternal.collectedBasis_orthonormal [DecidableEq Î¹] {V : Î¹ â†’ Submodule ğ•œ E}\n    (hV : OrthogonalFamily ğ•œ (fun i => V i) fun i => (V i).subtypeâ‚—áµ¢)\n    (hV_sum : DirectSum.IsInternal fun i => V i) {Î± : Î¹ â†’ Type*}\n    {v_family : âˆ€ i, Basis (Î± i) ğ•œ (V i)} (hv_family : âˆ€ i, Orthonormal ğ•œ (v_family i)) :\n    Orthonormal ğ•œ (hV_sum.collectedBasis v_family) := by\n  simpa only [hV_sum.collectedBasis_coe] using hV.orthonormal_sigma_orthonormal hv_family\n\n"}
