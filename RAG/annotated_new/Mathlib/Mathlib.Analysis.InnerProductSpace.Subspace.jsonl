{"name":"Submodule.coe_inner","module":"Mathlib.Analysis.InnerProductSpace.Subspace","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : RCLike 𝕜\ninst✝¹ : SeminormedAddCommGroup E\ninst✝ : InnerProductSpace 𝕜 E\nW : Submodule 𝕜 E\nx y : Subtype fun x => Membership.mem W x\n⊢ Eq (Inner.inner x y) (Inner.inner ↑x ↑y)","decl":"/-- The inner product on submodules is the same as on the ambient space. -/\n@[simp]\ntheorem Submodule.coe_inner (W : Submodule 𝕜 E) (x y : W) : ⟪x, y⟫ = ⟪(x : E), ↑y⟫ :=\n  rfl\n\n"}
{"name":"Orthonormal.codRestrict","module":"Mathlib.Analysis.InnerProductSpace.Subspace","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : RCLike 𝕜\ninst✝¹ : SeminormedAddCommGroup E\ninst✝ : InnerProductSpace 𝕜 E\nι : Type u_4\nv : ι → E\nhv : Orthonormal 𝕜 v\ns : Submodule 𝕜 E\nhvs : ∀ (i : ι), Membership.mem s (v i)\n⊢ Orthonormal 𝕜 (Set.codRestrict v (↑s) hvs)","decl":"theorem Orthonormal.codRestrict {ι : Type*} {v : ι → E} (hv : Orthonormal 𝕜 v) (s : Submodule 𝕜 E)\n    (hvs : ∀ i, v i ∈ s) : @Orthonormal 𝕜 s _ _ _ ι (Set.codRestrict v s hvs) :=\n  s.subtypeₗᵢ.orthonormal_comp_iff.mp hv\n\n"}
{"name":"orthonormal_span","module":"Mathlib.Analysis.InnerProductSpace.Subspace","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : RCLike 𝕜\ninst✝¹ : SeminormedAddCommGroup E\ninst✝ : InnerProductSpace 𝕜 E\nι : Type u_4\nv : ι → E\nhv : Orthonormal 𝕜 v\n⊢ Orthonormal 𝕜 fun i => ⟨v i, ⋯⟩","decl":"theorem orthonormal_span {ι : Type*} {v : ι → E} (hv : Orthonormal 𝕜 v) :\n    @Orthonormal 𝕜 (Submodule.span 𝕜 (Set.range v)) _ _ _ ι fun i : ι =>\n      ⟨v i, Submodule.subset_span (Set.mem_range_self i)⟩ :=\n  hv.codRestrict (Submodule.span 𝕜 (Set.range v)) fun i =>\n    Submodule.subset_span (Set.mem_range_self i)\n\n"}
{"name":"Orthonormal.orthogonalFamily","module":"Mathlib.Analysis.InnerProductSpace.Subspace","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : RCLike 𝕜\ninst✝¹ : SeminormedAddCommGroup E\ninst✝ : InnerProductSpace 𝕜 E\nι : Type u_4\nv : ι → E\nhv : Orthonormal 𝕜 v\n⊢ OrthogonalFamily 𝕜 (fun _i => 𝕜) fun i => LinearIsometry.toSpanSingleton 𝕜 E ⋯","decl":"theorem Orthonormal.orthogonalFamily {v : ι → E} (hv : Orthonormal 𝕜 v) :\n    OrthogonalFamily 𝕜 (fun _i : ι => 𝕜) fun i => LinearIsometry.toSpanSingleton 𝕜 E (hv.1 i) :=\n  fun i j hij a b => by simp [inner_smul_left, inner_smul_right, hv.2 hij]\n\n"}
{"name":"OrthogonalFamily.eq_ite","module":"Mathlib.Analysis.InnerProductSpace.Subspace","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝⁵ : RCLike 𝕜\ninst✝⁴ : SeminormedAddCommGroup E\ninst✝³ : InnerProductSpace 𝕜 E\nι : Type u_4\nG : ι → Type u_5\ninst✝² : (i : ι) → NormedAddCommGroup (G i)\ninst✝¹ : (i : ι) → InnerProductSpace 𝕜 (G i)\nV : (i : ι) → LinearIsometry (RingHom.id 𝕜) (G i) E\nhV : OrthogonalFamily 𝕜 G V\ninst✝ : DecidableEq ι\ni j : ι\nv : G i\nw : G j\n⊢ Eq (Inner.inner ((V i) v) ((V j) w)) (ite (Eq i j) (Inner.inner ((V i) v) ((V j) w)) 0)","decl":"theorem OrthogonalFamily.eq_ite [DecidableEq ι] {i j : ι} (v : G i) (w : G j) :\n    ⟪V i v, V j w⟫ = ite (i = j) ⟪V i v, V j w⟫ 0 := by\n  split_ifs with h\n  · rfl\n  · exact hV h v w\n\n"}
{"name":"OrthogonalFamily.inner_right_dfinsupp","module":"Mathlib.Analysis.InnerProductSpace.Subspace","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝⁶ : RCLike 𝕜\ninst✝⁵ : SeminormedAddCommGroup E\ninst✝⁴ : InnerProductSpace 𝕜 E\nι : Type u_4\nG : ι → Type u_5\ninst✝³ : (i : ι) → NormedAddCommGroup (G i)\ninst✝² : (i : ι) → InnerProductSpace 𝕜 (G i)\nV : (i : ι) → LinearIsometry (RingHom.id 𝕜) (G i) E\nhV : OrthogonalFamily 𝕜 G V\ninst✝¹ : (i : ι) → (x : G i) → Decidable (Ne x 0)\ninst✝ : DecidableEq ι\nl : DirectSum ι fun i => G i\ni : ι\nv : G i\n⊢ Eq (Inner.inner ((V i) v) (DFinsupp.sum l fun j => ⇑(V j))) (Inner.inner v (l i))","decl":"theorem OrthogonalFamily.inner_right_dfinsupp\n    [∀ (i) (x : G i), Decidable (x ≠ 0)] [DecidableEq ι] (l : ⨁ i, G i) (i : ι) (v : G i) :\n    ⟪V i v, l.sum fun j => V j⟫ = ⟪v, l i⟫ :=\n  calc\n    ⟪V i v, l.sum fun j => V j⟫ = l.sum fun j => fun w => ⟪V i v, V j w⟫ :=\n      DFinsupp.inner_sum (fun j => V j) l (V i v)\n    _ = l.sum fun j => fun w => ite (i = j) ⟪V i v, V j w⟫ 0 :=\n      (congr_arg l.sum <| funext fun _ => funext <| hV.eq_ite v)\n    _ = ⟪v, l i⟫ := by\n      simp only [DFinsupp.sum, Submodule.coe_inner, Finset.sum_ite_eq, ite_eq_left_iff,\n        DFinsupp.mem_support_toFun]\n      split_ifs with h\n      · simp only [LinearIsometry.inner_map_map]\n      · simp only [of_not_not h, inner_zero_right]\n\n"}
{"name":"OrthogonalFamily.inner_right_fintype","module":"Mathlib.Analysis.InnerProductSpace.Subspace","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝⁵ : RCLike 𝕜\ninst✝⁴ : SeminormedAddCommGroup E\ninst✝³ : InnerProductSpace 𝕜 E\nι : Type u_4\nG : ι → Type u_5\ninst✝² : (i : ι) → NormedAddCommGroup (G i)\ninst✝¹ : (i : ι) → InnerProductSpace 𝕜 (G i)\nV : (i : ι) → LinearIsometry (RingHom.id 𝕜) (G i) E\nhV : OrthogonalFamily 𝕜 G V\ninst✝ : Fintype ι\nl : (i : ι) → G i\ni : ι\nv : G i\n⊢ Eq (Inner.inner ((V i) v) (Finset.univ.sum fun j => (V j) (l j))) (Inner.inner v (l i))","decl":"theorem OrthogonalFamily.inner_right_fintype [Fintype ι] (l : ∀ i, G i) (i : ι) (v : G i) :\n    ⟪V i v, ∑ j : ι, V j (l j)⟫ = ⟪v, l i⟫ := by\n  classical\n  calc\n    ⟪V i v, ∑ j : ι, V j (l j)⟫ = ∑ j : ι, ⟪V i v, V j (l j)⟫ := by rw [inner_sum]\n    _ = ∑ j, ite (i = j) ⟪V i v, V j (l j)⟫ 0 :=\n      (congr_arg (Finset.sum Finset.univ) <| funext fun j => hV.eq_ite v (l j))\n    _ = ⟪v, l i⟫ := by\n      simp only [Finset.sum_ite_eq, Finset.mem_univ, (V i).inner_map_map, if_true]\n\n"}
{"name":"OrthogonalFamily.inner_sum","module":"Mathlib.Analysis.InnerProductSpace.Subspace","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝⁴ : RCLike 𝕜\ninst✝³ : SeminormedAddCommGroup E\ninst✝² : InnerProductSpace 𝕜 E\nι : Type u_4\nG : ι → Type u_5\ninst✝¹ : (i : ι) → NormedAddCommGroup (G i)\ninst✝ : (i : ι) → InnerProductSpace 𝕜 (G i)\nV : (i : ι) → LinearIsometry (RingHom.id 𝕜) (G i) E\nhV : OrthogonalFamily 𝕜 G V\nl₁ l₂ : (i : ι) → G i\ns : Finset ι\n⊢ Eq (Inner.inner (s.sum fun i => (V i) (l₁ i)) (s.sum fun j => (V j) (l₂ j))) (s.sum fun i => Inner.inner (l₁ i) (l₂ i))","decl":"nonrec theorem OrthogonalFamily.inner_sum (l₁ l₂ : ∀ i, G i) (s : Finset ι) :\n    ⟪∑ i ∈ s, V i (l₁ i), ∑ j ∈ s, V j (l₂ j)⟫ = ∑ i ∈ s, ⟪l₁ i, l₂ i⟫ := by\n  classical\n  calc\n    ⟪∑ i ∈ s, V i (l₁ i), ∑ j ∈ s, V j (l₂ j)⟫ = ∑ j ∈ s, ∑ i ∈ s, ⟪V i (l₁ i), V j (l₂ j)⟫ := by\n      simp only [sum_inner, inner_sum]\n    _ = ∑ j ∈ s, ∑ i ∈ s, ite (i = j) ⟪V i (l₁ i), V j (l₂ j)⟫ 0 := by\n      congr with i\n      congr with j\n      apply hV.eq_ite\n    _ = ∑ i ∈ s, ⟪l₁ i, l₂ i⟫ := by\n      simp only [Finset.sum_ite_of_true, Finset.sum_ite_eq', LinearIsometry.inner_map_map,\n        imp_self, imp_true_iff]\n\n"}
{"name":"OrthogonalFamily.norm_sum","module":"Mathlib.Analysis.InnerProductSpace.Subspace","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝⁴ : RCLike 𝕜\ninst✝³ : SeminormedAddCommGroup E\ninst✝² : InnerProductSpace 𝕜 E\nι : Type u_4\nG : ι → Type u_5\ninst✝¹ : (i : ι) → NormedAddCommGroup (G i)\ninst✝ : (i : ι) → InnerProductSpace 𝕜 (G i)\nV : (i : ι) → LinearIsometry (RingHom.id 𝕜) (G i) E\nhV : OrthogonalFamily 𝕜 G V\nl : (i : ι) → G i\ns : Finset ι\n⊢ Eq (HPow.hPow (Norm.norm (s.sum fun i => (V i) (l i))) 2) (s.sum fun i => HPow.hPow (Norm.norm (l i)) 2)","decl":"theorem OrthogonalFamily.norm_sum (l : ∀ i, G i) (s : Finset ι) :\n    ‖∑ i ∈ s, V i (l i)‖ ^ 2 = ∑ i ∈ s, ‖l i‖ ^ 2 := by\n  have : ((‖∑ i ∈ s, V i (l i)‖ : ℝ) : 𝕜) ^ 2 = ∑ i ∈ s, ((‖l i‖ : ℝ) : 𝕜) ^ 2 := by\n    simp only [← inner_self_eq_norm_sq_to_K, hV.inner_sum]\n  exact mod_cast this\n\n"}
{"name":"OrthogonalFamily.comp","module":"Mathlib.Analysis.InnerProductSpace.Subspace","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝⁴ : RCLike 𝕜\ninst✝³ : SeminormedAddCommGroup E\ninst✝² : InnerProductSpace 𝕜 E\nι : Type u_4\nG : ι → Type u_5\ninst✝¹ : (i : ι) → NormedAddCommGroup (G i)\ninst✝ : (i : ι) → InnerProductSpace 𝕜 (G i)\nV : (i : ι) → LinearIsometry (RingHom.id 𝕜) (G i) E\nhV : OrthogonalFamily 𝕜 G V\nγ : Type u_6\nf : γ → ι\nhf : Function.Injective f\n⊢ OrthogonalFamily 𝕜 (fun g => G (f g)) fun g => V (f g)","decl":"/-- The composition of an orthogonal family of subspaces with an injective function is also an\northogonal family. -/\ntheorem OrthogonalFamily.comp {γ : Type*} {f : γ → ι} (hf : Function.Injective f) :\n    OrthogonalFamily 𝕜 (fun g => G (f g)) fun g => V (f g) :=\n  fun _i _j hij v w => hV (hf.ne hij) v w\n\n"}
{"name":"OrthogonalFamily.orthonormal_sigma_orthonormal","module":"Mathlib.Analysis.InnerProductSpace.Subspace","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝⁴ : RCLike 𝕜\ninst✝³ : SeminormedAddCommGroup E\ninst✝² : InnerProductSpace 𝕜 E\nι : Type u_4\nG : ι → Type u_5\ninst✝¹ : (i : ι) → NormedAddCommGroup (G i)\ninst✝ : (i : ι) → InnerProductSpace 𝕜 (G i)\nV : (i : ι) → LinearIsometry (RingHom.id 𝕜) (G i) E\nhV : OrthogonalFamily 𝕜 G V\nα : ι → Type u_6\nv_family : (i : ι) → α i → G i\nhv_family : ∀ (i : ι), Orthonormal 𝕜 (v_family i)\n⊢ Orthonormal 𝕜 fun a => (V a.fst) (v_family a.fst a.snd)","decl":"theorem OrthogonalFamily.orthonormal_sigma_orthonormal {α : ι → Type*} {v_family : ∀ i, α i → G i}\n    (hv_family : ∀ i, Orthonormal 𝕜 (v_family i)) :\n    Orthonormal 𝕜 fun a : Σi, α i => V a.1 (v_family a.1 a.2) := by\n  constructor\n  · rintro ⟨i, v⟩\n    simpa only [LinearIsometry.norm_map] using (hv_family i).left v\n  rintro ⟨i, v⟩ ⟨j, w⟩ hvw\n  by_cases hij : i = j\n  · subst hij\n    have : v ≠ w := fun h => by\n      subst h\n      exact hvw rfl\n    simpa only [LinearIsometry.inner_map_map] using (hv_family i).2 this\n  · exact hV hij (v_family i v) (v_family j w)\n\n"}
{"name":"OrthogonalFamily.norm_sq_diff_sum","module":"Mathlib.Analysis.InnerProductSpace.Subspace","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝⁵ : RCLike 𝕜\ninst✝⁴ : SeminormedAddCommGroup E\ninst✝³ : InnerProductSpace 𝕜 E\nι : Type u_4\nG : ι → Type u_5\ninst✝² : (i : ι) → NormedAddCommGroup (G i)\ninst✝¹ : (i : ι) → InnerProductSpace 𝕜 (G i)\nV : (i : ι) → LinearIsometry (RingHom.id 𝕜) (G i) E\nhV : OrthogonalFamily 𝕜 G V\ninst✝ : DecidableEq ι\nf : (i : ι) → G i\ns₁ s₂ : Finset ι\n⊢ Eq (HPow.hPow (Norm.norm (HSub.hSub (s₁.sum fun i => (V i) (f i)) (s₂.sum fun i => (V i) (f i)))) 2) (HAdd.hAdd ((SDiff.sdiff s₁ s₂).sum fun i => HPow.hPow (Norm.norm (f i)) 2) ((SDiff.sdiff s₂ s₁).sum fun i => HPow.hPow (Norm.norm (f i)) 2))","decl":"theorem OrthogonalFamily.norm_sq_diff_sum [DecidableEq ι] (f : ∀ i, G i) (s₁ s₂ : Finset ι) :\n    ‖(∑ i ∈ s₁, V i (f i)) - ∑ i ∈ s₂, V i (f i)‖ ^ 2 =\n      (∑ i ∈ s₁ \\ s₂, ‖f i‖ ^ 2) + ∑ i ∈ s₂ \\ s₁, ‖f i‖ ^ 2 := by\n  rw [← Finset.sum_sdiff_sub_sum_sdiff, sub_eq_add_neg, ← Finset.sum_neg_distrib]\n  let F : ∀ i, G i := fun i => if i ∈ s₁ then f i else -f i\n  have hF₁ : ∀ i ∈ s₁ \\ s₂, F i = f i := fun i hi => if_pos (Finset.sdiff_subset hi)\n  have hF₂ : ∀ i ∈ s₂ \\ s₁, F i = -f i := fun i hi => if_neg (Finset.mem_sdiff.mp hi).2\n  have hF : ∀ i, ‖F i‖ = ‖f i‖ := by\n    intro i\n    dsimp only [F]\n    split_ifs <;> simp only [eq_self_iff_true, norm_neg]\n  have :\n    ‖(∑ i ∈ s₁ \\ s₂, V i (F i)) + ∑ i ∈ s₂ \\ s₁, V i (F i)‖ ^ 2 =\n      (∑ i ∈ s₁ \\ s₂, ‖F i‖ ^ 2) + ∑ i ∈ s₂ \\ s₁, ‖F i‖ ^ 2 := by\n    have hs : Disjoint (s₁ \\ s₂) (s₂ \\ s₁) := disjoint_sdiff_sdiff\n    simpa only [Finset.sum_union hs] using hV.norm_sum F (s₁ \\ s₂ ∪ s₂ \\ s₁)\n  convert this using 4\n  · refine Finset.sum_congr rfl fun i hi => ?_\n    simp only [hF₁ i hi]\n  · refine Finset.sum_congr rfl fun i hi => ?_\n    simp only [hF₂ i hi, LinearIsometry.map_neg]\n  · simp only [hF]\n  · simp only [hF]\n\n"}
{"name":"OrthogonalFamily.summable_iff_norm_sq_summable","module":"Mathlib.Analysis.InnerProductSpace.Subspace","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝⁵ : RCLike 𝕜\ninst✝⁴ : SeminormedAddCommGroup E\ninst✝³ : InnerProductSpace 𝕜 E\nι : Type u_4\nG : ι → Type u_5\ninst✝² : (i : ι) → NormedAddCommGroup (G i)\ninst✝¹ : (i : ι) → InnerProductSpace 𝕜 (G i)\nV : (i : ι) → LinearIsometry (RingHom.id 𝕜) (G i) E\nhV : OrthogonalFamily 𝕜 G V\ninst✝ : CompleteSpace E\nf : (i : ι) → G i\n⊢ Iff (Summable fun i => (V i) (f i)) (Summable fun i => HPow.hPow (Norm.norm (f i)) 2)","decl":"/-- A family `f` of mutually-orthogonal elements of `E` is summable, if and only if\n`(fun i ↦ ‖f i‖ ^ 2)` is summable. -/\ntheorem OrthogonalFamily.summable_iff_norm_sq_summable [CompleteSpace E] (f : ∀ i, G i) :\n    (Summable fun i => V i (f i)) ↔ Summable fun i => ‖f i‖ ^ 2 := by\n  classical\n    simp only [summable_iff_cauchySeq_finset, NormedAddCommGroup.cauchySeq_iff, Real.norm_eq_abs]\n    constructor\n    · intro hf ε hε\n      obtain ⟨a, H⟩ := hf _ (sqrt_pos.mpr hε)\n      use a\n      intro s₁ hs₁ s₂ hs₂\n      rw [← Finset.sum_sdiff_sub_sum_sdiff]\n      refine (abs_sub _ _).trans_lt ?_\n      have : ∀ i, 0 ≤ ‖f i‖ ^ 2 := fun i : ι => sq_nonneg _\n      simp only [Finset.abs_sum_of_nonneg' this]\n      have : ((∑ i ∈ s₁ \\ s₂, ‖f i‖ ^ 2) + ∑ i ∈ s₂ \\ s₁, ‖f i‖ ^ 2) < √ε ^ 2 := by\n        rw [← hV.norm_sq_diff_sum, sq_lt_sq, abs_of_nonneg (sqrt_nonneg _),\n          abs_of_nonneg (norm_nonneg _)]\n        exact H s₁ hs₁ s₂ hs₂\n      have hη := sq_sqrt (le_of_lt hε)\n      linarith\n    · intro hf ε hε\n      have hε' : 0 < ε ^ 2 / 2 := half_pos (sq_pos_of_pos hε)\n      obtain ⟨a, H⟩ := hf _ hε'\n      use a\n      intro s₁ hs₁ s₂ hs₂\n      refine (abs_lt_of_sq_lt_sq' ?_ (le_of_lt hε)).2\n      have has : a ≤ s₁ ⊓ s₂ := le_inf hs₁ hs₂\n      rw [hV.norm_sq_diff_sum]\n      have Hs₁ : ∑ x ∈ s₁ \\ s₂, ‖f x‖ ^ 2 < ε ^ 2 / 2 := by\n        convert H _ hs₁ _ has\n        have : s₁ ⊓ s₂ ⊆ s₁ := Finset.inter_subset_left\n        rw [← Finset.sum_sdiff this, add_tsub_cancel_right, Finset.abs_sum_of_nonneg']\n        · simp\n        · exact fun i => sq_nonneg _\n      have Hs₂ : ∑ x ∈ s₂ \\ s₁, ‖f x‖ ^ 2 < ε ^ 2 / 2 := by\n        convert H _ hs₂ _ has\n        have : s₁ ⊓ s₂ ⊆ s₂ := Finset.inter_subset_right\n        rw [← Finset.sum_sdiff this, add_tsub_cancel_right, Finset.abs_sum_of_nonneg']\n        · simp\n        · exact fun i => sq_nonneg _\n      linarith\n\n"}
{"name":"OrthogonalFamily.independent","module":"Mathlib.Analysis.InnerProductSpace.Subspace","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : RCLike 𝕜\ninst✝¹ : NormedAddCommGroup E\ninst✝ : InnerProductSpace 𝕜 E\nι : Type u_4\nV : ι → Submodule 𝕜 E\nhV : OrthogonalFamily 𝕜 (fun i => Subtype fun x => Membership.mem (V i) x) fun i => (V i).subtypeₗᵢ\n⊢ iSupIndep V","decl":"/-- An orthogonal family forms an independent family of subspaces; that is, any collection of\nelements each from a different subspace in the family is linearly independent. In particular, the\npairwise intersections of elements of the family are 0. -/\ntheorem OrthogonalFamily.independent {V : ι → Submodule 𝕜 E}\n    (hV : OrthogonalFamily 𝕜 (fun i => V i) fun i => (V i).subtypeₗᵢ) :\n    iSupIndep V := by\n  classical\n  apply iSupIndep_of_dfinsupp_lsum_injective\n  refine LinearMap.ker_eq_bot.mp ?_\n  rw [Submodule.eq_bot_iff]\n  intro v hv\n  rw [LinearMap.mem_ker] at hv\n  ext i\n  suffices ⟪(v i : E), v i⟫ = 0 by simpa only [inner_self_eq_zero] using this\n  calc\n    ⟪(v i : E), v i⟫ = ⟪(v i : E), DFinsupp.lsum ℕ (fun i => (V i).subtype) v⟫ := by\n      simpa only [DFinsupp.sumAddHom_apply, DFinsupp.lsum_apply_apply] using\n        (hV.inner_right_dfinsupp v i (v i)).symm\n    _ = 0 := by simp only [hv, inner_zero_right]\n\n"}
{"name":"DirectSum.IsInternal.collectedBasis_orthonormal","module":"Mathlib.Analysis.InnerProductSpace.Subspace","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝³ : RCLike 𝕜\ninst✝² : NormedAddCommGroup E\ninst✝¹ : InnerProductSpace 𝕜 E\nι : Type u_4\ninst✝ : DecidableEq ι\nV : ι → Submodule 𝕜 E\nhV : OrthogonalFamily 𝕜 (fun i => Subtype fun x => Membership.mem (V i) x) fun i => (V i).subtypeₗᵢ\nhV_sum : DirectSum.IsInternal fun i => V i\nα : ι → Type u_6\nv_family : (i : ι) → Basis (α i) 𝕜 (Subtype fun x => Membership.mem (V i) x)\nhv_family : ∀ (i : ι), Orthonormal 𝕜 ⇑(v_family i)\n⊢ Orthonormal 𝕜 ⇑(hV_sum.collectedBasis v_family)","decl":"theorem DirectSum.IsInternal.collectedBasis_orthonormal [DecidableEq ι] {V : ι → Submodule 𝕜 E}\n    (hV : OrthogonalFamily 𝕜 (fun i => V i) fun i => (V i).subtypeₗᵢ)\n    (hV_sum : DirectSum.IsInternal fun i => V i) {α : ι → Type*}\n    {v_family : ∀ i, Basis (α i) 𝕜 (V i)} (hv_family : ∀ i, Orthonormal 𝕜 (v_family i)) :\n    Orthonormal 𝕜 (hV_sum.collectedBasis v_family) := by\n  simpa only [hV_sum.collectedBasis_coe] using hV.orthonormal_sigma_orthonormal hv_family\n\n"}
