{"name":"IsLocalization.instForallPiUniv","module":"Mathlib.RingTheory.Localization.Pi","initialProofState":"ι : Type u_1\nR : ι → Type u_2\nS : ι → Type u_3\ninst✝³ : (i : ι) → CommSemiring (R i)\ninst✝² : (i : ι) → CommSemiring (S i)\ninst✝¹ : (i : ι) → Algebra (R i) (S i)\nM : (i : ι) → Submonoid (R i)\ninst✝ : ∀ (i : ι), IsLocalization (M i) (S i)\n⊢ IsLocalization (Submonoid.pi Set.univ M) ((i : ι) → S i)","decl":"/-- If `S i` is a localization of `R i` at the submonoid `M i` for each `i`,\nthen `Π i, S i` is a localization of `Π i, R i` at the product submonoid. -/\ninstance (M : Π i, Submonoid (R i)) [∀ i, IsLocalization (M i) (S i)] :\n    IsLocalization (.pi .univ M) (Π i, S i) where\n  map_units' m := Pi.isUnit_iff.mpr fun i ↦ map_units _ ⟨m.1 i, m.2 i ⟨⟩⟩\n  surj' z := by\n    choose rm h using fun i ↦ surj (M := M i) (z i)\n    exact ⟨(fun i ↦ (rm i).1, ⟨_, fun i _ ↦ (rm i).2.2⟩), funext h⟩\n  exists_of_eq {x y} eq := by\n    choose c hc using fun i ↦ exists_of_eq (M := M i) (congr_fun eq i)\n    exact ⟨⟨_, fun i _ ↦ (c i).2⟩, funext hc⟩\n\n"}
{"name":"IsLocalization.iff_map_piEvalRingHom","module":"Mathlib.RingTheory.Localization.Pi","initialProofState":"ι : Type u_1\nR : ι → Type u_2\ninst✝³ : (i : ι) → CommSemiring (R i)\nS' : Type u_4\ninst✝² : CommSemiring S'\ninst✝¹ : Algebra ((i : ι) → R i) S'\nM : Submonoid ((i : ι) → R i)\ninst✝ : Finite ι\n⊢ Iff (IsLocalization M S') (IsLocalization (Submonoid.pi Set.univ fun i => Submonoid.map (Pi.evalRingHom R i) M) S')","decl":"theorem iff_map_piEvalRingHom [Finite ι] :\n    IsLocalization M S' ↔ IsLocalization (.pi .univ fun i ↦ M.map (Pi.evalRingHom R i)) S' :=\n  iff_of_le_of_exists_dvd M _ (fun m hm i _ ↦ ⟨m, hm, rfl⟩) fun n hn ↦ by\n    choose m mem eq using hn\n    have := Fintype.ofFinite ι\n    refine ⟨∏ i, m i ⟨⟩, prod_mem fun i _ ↦ mem i _, pi_dvd_iff.mpr fun i ↦ ?_⟩\n    rw [Fintype.prod_apply]\n    exact (eq i ⟨⟩).symm.dvd.trans (Finset.dvd_prod_of_mem _ <| Finset.mem_univ _)\n\n"}
{"name":"IsLocalization.isUnit_piRingHom_algebraMap_comp_piEvalRingHom","module":"Mathlib.RingTheory.Localization.Pi","initialProofState":"ι : Type u_1\nR : ι → Type u_2\nS : ι → Type u_3\ninst✝³ : (i : ι) → CommSemiring (R i)\ninst✝² : (i : ι) → CommSemiring (S i)\ninst✝¹ : (i : ι) → Algebra (R i) (S i)\nM : Submonoid ((i : ι) → R i)\ninst✝ : ∀ (i : ι), IsLocalization (Submonoid.map (Pi.evalRingHom R i) M) (S i)\ny : Subtype fun x => Membership.mem M x\n⊢ IsUnit ((Pi.ringHom fun i => (algebraMap (R i) (S i)).comp (Pi.evalRingHom R i)) ↑y)","decl":"/-- Let `M` be a submonoid of a direct product of commutative rings `R i`, and let `M' i` denote\nthe projection of `M` onto each corresponding factor. Given a ring homomorphism from the direct\nproduct `Π i, R i` to the product of the localizations of each `R i` at `M' i`, every `y : M`\nmaps to a unit under this homomorphism. -/\nlemma isUnit_piRingHom_algebraMap_comp_piEvalRingHom (y : M) :\n    IsUnit ((Pi.ringHom fun i ↦ (algebraMap (R i) (S i)).comp (Pi.evalRingHom R i)) y) :=\n  Pi.isUnit_iff.mpr fun i ↦ map_units _ (⟨y.1 i, y, y.2, rfl⟩ : M.map (Pi.evalRingHom R i))\n\n"}
{"name":"IsLocalization.bijective_lift_piRingHom_algebraMap_comp_piEvalRingHom","module":"Mathlib.RingTheory.Localization.Pi","initialProofState":"ι : Type u_1\nR : ι → Type u_2\nS : ι → Type u_3\ninst✝⁷ : (i : ι) → CommSemiring (R i)\ninst✝⁶ : (i : ι) → CommSemiring (S i)\ninst✝⁵ : (i : ι) → Algebra (R i) (S i)\nS' : Type u_4\ninst✝⁴ : CommSemiring S'\ninst✝³ : Algebra ((i : ι) → R i) S'\nM : Submonoid ((i : ι) → R i)\ninst✝² : ∀ (i : ι), IsLocalization (Submonoid.map (Pi.evalRingHom R i) M) (S i)\ninst✝¹ : IsLocalization M S'\ninst✝ : Finite ι\n⊢ Function.Bijective ⇑(IsLocalization.lift ⋯)","decl":"/-- Let `M` be a submonoid of a direct product of commutative rings `R i`, and let `M' i` denote\nthe projection of `M` onto each factor. Then the canonical map from the localization of the direct\nproduct `Π i, R i` at `M` to the direct product of the localizations of each `R i` at `M' i`\nis bijective. -/\ntheorem bijective_lift_piRingHom_algebraMap_comp_piEvalRingHom [IsLocalization M S'] [Finite ι] :\n    Function.Bijective (lift (S := S') (isUnit_piRingHom_algebraMap_comp_piEvalRingHom R S M)) :=\n  have := (iff_map_piEvalRingHom R (Π i, S i) M).mpr inferInstance\n  (ringEquivOfRingEquiv (M := M) (T := M) _ _ (.refl _) <|\n    Submonoid.map_equiv_eq_comap_symm _ _).bijective\n\n"}
