{"name":"FractionalIdeal.inv_eq","module":"Mathlib.RingTheory.DedekindDomain.Ideal","initialProofState":"K : Type u_3\ninst✝⁴ : Field K\nR₁ : Type u_4\ninst✝³ : CommRing R₁\ninst✝² : IsDomain R₁\ninst✝¹ : Algebra R₁ K\ninst✝ : IsFractionRing R₁ K\nI : FractionalIdeal (nonZeroDivisors R₁) K\n⊢ Eq (Inv.inv I) (HDiv.hDiv 1 I)","decl":"theorem inv_eq : I⁻¹ = 1 / I := rfl\n\n"}
{"name":"FractionalIdeal.inv_zero'","module":"Mathlib.RingTheory.DedekindDomain.Ideal","initialProofState":"K : Type u_3\ninst✝⁴ : Field K\nR₁ : Type u_4\ninst✝³ : CommRing R₁\ninst✝² : IsDomain R₁\ninst✝¹ : Algebra R₁ K\ninst✝ : IsFractionRing R₁ K\n⊢ Eq (Inv.inv 0) 0","decl":"theorem inv_zero' : (0 : FractionalIdeal R₁⁰ K)⁻¹ = 0 := div_zero\n\n"}
{"name":"FractionalIdeal.inv_nonzero","module":"Mathlib.RingTheory.DedekindDomain.Ideal","initialProofState":"K : Type u_3\ninst✝⁴ : Field K\nR₁ : Type u_4\ninst✝³ : CommRing R₁\ninst✝² : IsDomain R₁\ninst✝¹ : Algebra R₁ K\ninst✝ : IsFractionRing R₁ K\nJ : FractionalIdeal (nonZeroDivisors R₁) K\nh : Ne J 0\n⊢ Eq (Inv.inv J) ⟨HDiv.hDiv ↑1 ↑J, ⋯⟩","decl":"theorem inv_nonzero {J : FractionalIdeal R₁⁰ K} (h : J ≠ 0) :\n    J⁻¹ = ⟨(1 : FractionalIdeal R₁⁰ K) / J, fractional_div_of_nonzero h⟩ := div_nonzero h\n\n"}
{"name":"FractionalIdeal.coe_inv_of_nonzero","module":"Mathlib.RingTheory.DedekindDomain.Ideal","initialProofState":"K : Type u_3\ninst✝⁴ : Field K\nR₁ : Type u_4\ninst✝³ : CommRing R₁\ninst✝² : IsDomain R₁\ninst✝¹ : Algebra R₁ K\ninst✝ : IsFractionRing R₁ K\nJ : FractionalIdeal (nonZeroDivisors R₁) K\nh : Ne J 0\n⊢ Eq (↑(Inv.inv J)) (HDiv.hDiv (IsLocalization.coeSubmodule K Top.top) ↑J)","decl":"theorem coe_inv_of_nonzero {J : FractionalIdeal R₁⁰ K} (h : J ≠ 0) :\n    (↑J⁻¹ : Submodule R₁ K) = IsLocalization.coeSubmodule K ⊤ / (J : Submodule R₁ K) := by\n  simp_rw [inv_nonzero _ h, coe_one, coe_mk, IsLocalization.coeSubmodule_top]\n\n"}
{"name":"FractionalIdeal.mem_inv_iff","module":"Mathlib.RingTheory.DedekindDomain.Ideal","initialProofState":"K : Type u_3\ninst✝⁴ : Field K\nR₁ : Type u_4\ninst✝³ : CommRing R₁\ninst✝² : IsDomain R₁\ninst✝¹ : Algebra R₁ K\ninst✝ : IsFractionRing R₁ K\nI : FractionalIdeal (nonZeroDivisors R₁) K\nhI : Ne I 0\nx : K\n⊢ Iff (Membership.mem (Inv.inv I) x) (∀ (y : K), Membership.mem I y → Membership.mem 1 (HMul.hMul x y))","decl":"theorem mem_inv_iff (hI : I ≠ 0) {x : K} : x ∈ I⁻¹ ↔ ∀ y ∈ I, x * y ∈ (1 : FractionalIdeal R₁⁰ K) :=\n  mem_div_iff_of_nonzero hI\n\n"}
{"name":"FractionalIdeal.inv_anti_mono","module":"Mathlib.RingTheory.DedekindDomain.Ideal","initialProofState":"K : Type u_3\ninst✝⁴ : Field K\nR₁ : Type u_4\ninst✝³ : CommRing R₁\ninst✝² : IsDomain R₁\ninst✝¹ : Algebra R₁ K\ninst✝ : IsFractionRing R₁ K\nI J : FractionalIdeal (nonZeroDivisors R₁) K\nhI : Ne I 0\nhJ : Ne J 0\nhIJ : LE.le I J\n⊢ LE.le (Inv.inv J) (Inv.inv I)","decl":"theorem inv_anti_mono (hI : I ≠ 0) (hJ : J ≠ 0) (hIJ : I ≤ J) : J⁻¹ ≤ I⁻¹ := by\n  -- Porting note: in Lean3, introducing `x` would just give `x ∈ J⁻¹ → x ∈ I⁻¹`, but\n  --  in Lean4, it goes all the way down to the subtypes\n  intro x\n  simp only [val_eq_coe, mem_coe, mem_inv_iff hJ, mem_inv_iff hI]\n  exact fun h y hy => h y (hIJ hy)\n\n"}
{"name":"FractionalIdeal.le_self_mul_inv","module":"Mathlib.RingTheory.DedekindDomain.Ideal","initialProofState":"K : Type u_3\ninst✝⁴ : Field K\nR₁ : Type u_4\ninst✝³ : CommRing R₁\ninst✝² : IsDomain R₁\ninst✝¹ : Algebra R₁ K\ninst✝ : IsFractionRing R₁ K\nI : FractionalIdeal (nonZeroDivisors R₁) K\nhI : LE.le I 1\n⊢ LE.le I (HMul.hMul I (Inv.inv I))","decl":"theorem le_self_mul_inv {I : FractionalIdeal R₁⁰ K} (hI : I ≤ (1 : FractionalIdeal R₁⁰ K)) :\n    I ≤ I * I⁻¹ :=\n  le_self_mul_one_div hI\n\n"}
{"name":"FractionalIdeal.coe_ideal_le_self_mul_inv","module":"Mathlib.RingTheory.DedekindDomain.Ideal","initialProofState":"K : Type u_3\ninst✝⁴ : Field K\nR₁ : Type u_4\ninst✝³ : CommRing R₁\ninst✝² : IsDomain R₁\ninst✝¹ : Algebra R₁ K\ninst✝ : IsFractionRing R₁ K\nI : Ideal R₁\n⊢ LE.le (↑I) (HMul.hMul (↑I) (Inv.inv ↑I))","decl":"theorem coe_ideal_le_self_mul_inv (I : Ideal R₁) :\n    (I : FractionalIdeal R₁⁰ K) ≤ I * (I : FractionalIdeal R₁⁰ K)⁻¹ :=\n  le_self_mul_inv coeIdeal_le_one\n\n"}
{"name":"FractionalIdeal.right_inverse_eq","module":"Mathlib.RingTheory.DedekindDomain.Ideal","initialProofState":"K : Type u_3\ninst✝⁴ : Field K\nR₁ : Type u_4\ninst✝³ : CommRing R₁\ninst✝² : IsDomain R₁\ninst✝¹ : Algebra R₁ K\ninst✝ : IsFractionRing R₁ K\nI J : FractionalIdeal (nonZeroDivisors R₁) K\nh : Eq (HMul.hMul I J) 1\n⊢ Eq J (Inv.inv I)","decl":"/-- `I⁻¹` is the inverse of `I` if `I` has an inverse. -/\ntheorem right_inverse_eq (I J : FractionalIdeal R₁⁰ K) (h : I * J = 1) : J = I⁻¹ := by\n  have hI : I ≠ 0 := ne_zero_of_mul_eq_one I J h\n  suffices h' : I * (1 / I) = 1 from\n    congr_arg Units.inv <| @Units.ext _ _ (Units.mkOfMulEqOne _ _ h) (Units.mkOfMulEqOne _ _ h') rfl\n  apply le_antisymm\n  · apply mul_le.mpr _\n    intro x hx y hy\n    rw [mul_comm]\n    exact (mem_div_iff_of_nonzero hI).mp hy x hx\n  rw [← h]\n  apply mul_left_mono I\n  apply (le_div_iff_of_nonzero hI).mpr _\n  intro y hy x hx\n  rw [mul_comm]\n  exact mul_mem_mul hy hx\n\n"}
{"name":"FractionalIdeal.mul_inv_cancel_iff","module":"Mathlib.RingTheory.DedekindDomain.Ideal","initialProofState":"K : Type u_3\ninst✝⁴ : Field K\nR₁ : Type u_4\ninst✝³ : CommRing R₁\ninst✝² : IsDomain R₁\ninst✝¹ : Algebra R₁ K\ninst✝ : IsFractionRing R₁ K\nI : FractionalIdeal (nonZeroDivisors R₁) K\n⊢ Iff (Eq (HMul.hMul I (Inv.inv I)) 1) (Exists fun J => Eq (HMul.hMul I J) 1)","decl":"theorem mul_inv_cancel_iff {I : FractionalIdeal R₁⁰ K} : I * I⁻¹ = 1 ↔ ∃ J, I * J = 1 :=\n  ⟨fun h => ⟨I⁻¹, h⟩, fun ⟨J, hJ⟩ => by rwa [← right_inverse_eq K I J hJ]⟩\n\n"}
{"name":"FractionalIdeal.mul_inv_cancel_iff_isUnit","module":"Mathlib.RingTheory.DedekindDomain.Ideal","initialProofState":"K : Type u_3\ninst✝⁴ : Field K\nR₁ : Type u_4\ninst✝³ : CommRing R₁\ninst✝² : IsDomain R₁\ninst✝¹ : Algebra R₁ K\ninst✝ : IsFractionRing R₁ K\nI : FractionalIdeal (nonZeroDivisors R₁) K\n⊢ Iff (Eq (HMul.hMul I (Inv.inv I)) 1) (IsUnit I)","decl":"theorem mul_inv_cancel_iff_isUnit {I : FractionalIdeal R₁⁰ K} : I * I⁻¹ = 1 ↔ IsUnit I :=\n  (mul_inv_cancel_iff K).trans isUnit_iff_exists_inv.symm\n\n"}
{"name":"FractionalIdeal.map_inv","module":"Mathlib.RingTheory.DedekindDomain.Ideal","initialProofState":"K : Type u_3\ninst✝⁷ : Field K\nR₁ : Type u_4\ninst✝⁶ : CommRing R₁\ninst✝⁵ : IsDomain R₁\ninst✝⁴ : Algebra R₁ K\ninst✝³ : IsFractionRing R₁ K\nK' : Type u_5\ninst✝² : Field K'\ninst✝¹ : Algebra R₁ K'\ninst✝ : IsFractionRing R₁ K'\nI : FractionalIdeal (nonZeroDivisors R₁) K\nh : AlgEquiv R₁ K K'\n⊢ Eq (FractionalIdeal.map (↑h) (Inv.inv I)) (Inv.inv (FractionalIdeal.map (↑h) I))","decl":"@[simp]\ntheorem map_inv (I : FractionalIdeal R₁⁰ K) (h : K ≃ₐ[R₁] K') :\n    I⁻¹.map (h : K →ₐ[R₁] K') = (I.map h)⁻¹ := by rw [inv_eq, map_div, map_one, inv_eq]\n\n"}
{"name":"FractionalIdeal.spanSingleton_inv","module":"Mathlib.RingTheory.DedekindDomain.Ideal","initialProofState":"K : Type u_3\ninst✝⁴ : Field K\nR₁ : Type u_4\ninst✝³ : CommRing R₁\ninst✝² : IsDomain R₁\ninst✝¹ : Algebra R₁ K\ninst✝ : IsFractionRing R₁ K\nx : K\n⊢ Eq (Inv.inv (FractionalIdeal.spanSingleton (nonZeroDivisors R₁) x)) (FractionalIdeal.spanSingleton (nonZeroDivisors R₁) (Inv.inv x))","decl":"@[simp]\ntheorem spanSingleton_inv (x : K) : (spanSingleton R₁⁰ x)⁻¹ = spanSingleton _ x⁻¹ :=\n  one_div_spanSingleton x\n\n"}
{"name":"FractionalIdeal.spanSingleton_div_spanSingleton","module":"Mathlib.RingTheory.DedekindDomain.Ideal","initialProofState":"K : Type u_3\ninst✝⁴ : Field K\nR₁ : Type u_4\ninst✝³ : CommRing R₁\ninst✝² : IsDomain R₁\ninst✝¹ : Algebra R₁ K\ninst✝ : IsFractionRing R₁ K\nx y : K\n⊢ Eq (HDiv.hDiv (FractionalIdeal.spanSingleton (nonZeroDivisors R₁) x) (FractionalIdeal.spanSingleton (nonZeroDivisors R₁) y)) (FractionalIdeal.spanSingleton (nonZeroDivisors R₁) (HDiv.hDiv x y))","decl":"theorem spanSingleton_div_spanSingleton (x y : K) :\n    spanSingleton R₁⁰ x / spanSingleton R₁⁰ y = spanSingleton R₁⁰ (x / y) := by\n  rw [div_spanSingleton, mul_comm, spanSingleton_mul_spanSingleton, div_eq_mul_inv]\n\n"}
{"name":"FractionalIdeal.spanSingleton_div_self","module":"Mathlib.RingTheory.DedekindDomain.Ideal","initialProofState":"K : Type u_3\ninst✝⁴ : Field K\nR₁ : Type u_4\ninst✝³ : CommRing R₁\ninst✝² : IsDomain R₁\ninst✝¹ : Algebra R₁ K\ninst✝ : IsFractionRing R₁ K\nx : K\nhx : Ne x 0\n⊢ Eq (HDiv.hDiv (FractionalIdeal.spanSingleton (nonZeroDivisors R₁) x) (FractionalIdeal.spanSingleton (nonZeroDivisors R₁) x)) 1","decl":"theorem spanSingleton_div_self {x : K} (hx : x ≠ 0) :\n    spanSingleton R₁⁰ x / spanSingleton R₁⁰ x = 1 := by\n  rw [spanSingleton_div_spanSingleton, div_self hx, spanSingleton_one]\n\n"}
{"name":"FractionalIdeal.coe_ideal_span_singleton_div_self","module":"Mathlib.RingTheory.DedekindDomain.Ideal","initialProofState":"K : Type u_3\ninst✝⁴ : Field K\nR₁ : Type u_4\ninst✝³ : CommRing R₁\ninst✝² : IsDomain R₁\ninst✝¹ : Algebra R₁ K\ninst✝ : IsFractionRing R₁ K\nx : R₁\nhx : Ne x 0\n⊢ Eq (HDiv.hDiv ↑(Ideal.span (Singleton.singleton x)) ↑(Ideal.span (Singleton.singleton x))) 1","decl":"theorem coe_ideal_span_singleton_div_self {x : R₁} (hx : x ≠ 0) :\n    (Ideal.span ({x} : Set R₁) : FractionalIdeal R₁⁰ K) / Ideal.span ({x} : Set R₁) = 1 := by\n  rw [coeIdeal_span_singleton,\n    spanSingleton_div_self K <|\n      (map_ne_zero_iff _ <| NoZeroSMulDivisors.algebraMap_injective R₁ K).mpr hx]\n\n"}
{"name":"FractionalIdeal.spanSingleton_mul_inv","module":"Mathlib.RingTheory.DedekindDomain.Ideal","initialProofState":"K : Type u_3\ninst✝⁴ : Field K\nR₁ : Type u_4\ninst✝³ : CommRing R₁\ninst✝² : IsDomain R₁\ninst✝¹ : Algebra R₁ K\ninst✝ : IsFractionRing R₁ K\nx : K\nhx : Ne x 0\n⊢ Eq (HMul.hMul (FractionalIdeal.spanSingleton (nonZeroDivisors R₁) x) (Inv.inv (FractionalIdeal.spanSingleton (nonZeroDivisors R₁) x))) 1","decl":"theorem spanSingleton_mul_inv {x : K} (hx : x ≠ 0) :\n    spanSingleton R₁⁰ x * (spanSingleton R₁⁰ x)⁻¹ = 1 := by\n  rw [spanSingleton_inv, spanSingleton_mul_spanSingleton, mul_inv_cancel₀ hx, spanSingleton_one]\n\n"}
{"name":"FractionalIdeal.coe_ideal_span_singleton_mul_inv","module":"Mathlib.RingTheory.DedekindDomain.Ideal","initialProofState":"K : Type u_3\ninst✝⁴ : Field K\nR₁ : Type u_4\ninst✝³ : CommRing R₁\ninst✝² : IsDomain R₁\ninst✝¹ : Algebra R₁ K\ninst✝ : IsFractionRing R₁ K\nx : R₁\nhx : Ne x 0\n⊢ Eq (HMul.hMul (↑(Ideal.span (Singleton.singleton x))) (Inv.inv ↑(Ideal.span (Singleton.singleton x)))) 1","decl":"theorem coe_ideal_span_singleton_mul_inv {x : R₁} (hx : x ≠ 0) :\n    (Ideal.span ({x} : Set R₁) : FractionalIdeal R₁⁰ K) *\n    (Ideal.span ({x} : Set R₁) : FractionalIdeal R₁⁰ K)⁻¹ = 1 := by\n  rw [coeIdeal_span_singleton,\n    spanSingleton_mul_inv K <|\n      (map_ne_zero_iff _ <| NoZeroSMulDivisors.algebraMap_injective R₁ K).mpr hx]\n\n"}
{"name":"FractionalIdeal.spanSingleton_inv_mul","module":"Mathlib.RingTheory.DedekindDomain.Ideal","initialProofState":"K : Type u_3\ninst✝⁴ : Field K\nR₁ : Type u_4\ninst✝³ : CommRing R₁\ninst✝² : IsDomain R₁\ninst✝¹ : Algebra R₁ K\ninst✝ : IsFractionRing R₁ K\nx : K\nhx : Ne x 0\n⊢ Eq (HMul.hMul (Inv.inv (FractionalIdeal.spanSingleton (nonZeroDivisors R₁) x)) (FractionalIdeal.spanSingleton (nonZeroDivisors R₁) x)) 1","decl":"theorem spanSingleton_inv_mul {x : K} (hx : x ≠ 0) :\n    (spanSingleton R₁⁰ x)⁻¹ * spanSingleton R₁⁰ x = 1 := by\n  rw [mul_comm, spanSingleton_mul_inv K hx]\n\n"}
{"name":"FractionalIdeal.coe_ideal_span_singleton_inv_mul","module":"Mathlib.RingTheory.DedekindDomain.Ideal","initialProofState":"K : Type u_3\ninst✝⁴ : Field K\nR₁ : Type u_4\ninst✝³ : CommRing R₁\ninst✝² : IsDomain R₁\ninst✝¹ : Algebra R₁ K\ninst✝ : IsFractionRing R₁ K\nx : R₁\nhx : Ne x 0\n⊢ Eq (HMul.hMul (Inv.inv ↑(Ideal.span (Singleton.singleton x))) ↑(Ideal.span (Singleton.singleton x))) 1","decl":"theorem coe_ideal_span_singleton_inv_mul {x : R₁} (hx : x ≠ 0) :\n    (Ideal.span ({x} : Set R₁) : FractionalIdeal R₁⁰ K)⁻¹ * Ideal.span ({x} : Set R₁) = 1 := by\n  rw [mul_comm, coe_ideal_span_singleton_mul_inv K hx]\n\n"}
{"name":"FractionalIdeal.mul_generator_self_inv","module":"Mathlib.RingTheory.DedekindDomain.Ideal","initialProofState":"K : Type u_3\ninst✝⁴ : Field K\nR₁ : Type u_6\ninst✝³ : CommRing R₁\ninst✝² : Algebra R₁ K\ninst✝¹ : IsLocalization (nonZeroDivisors R₁) K\nI : FractionalIdeal (nonZeroDivisors R₁) K\ninst✝ : (↑I).IsPrincipal\nh : Ne I 0\n⊢ Eq (HMul.hMul I (FractionalIdeal.spanSingleton (nonZeroDivisors R₁) (Inv.inv (Submodule.IsPrincipal.generator ↑I)))) 1","decl":"theorem mul_generator_self_inv {R₁ : Type*} [CommRing R₁] [Algebra R₁ K] [IsLocalization R₁⁰ K]\n    (I : FractionalIdeal R₁⁰ K) [Submodule.IsPrincipal (I : Submodule R₁ K)] (h : I ≠ 0) :\n    I * spanSingleton _ (generator (I : Submodule R₁ K))⁻¹ = 1 := by\n  -- Rewrite only the `I` that appears alone.\n  conv_lhs => congr; rw [eq_spanSingleton_of_principal I]\n  rw [spanSingleton_mul_spanSingleton, mul_inv_cancel₀, spanSingleton_one]\n  intro generator_I_eq_zero\n  apply h\n  rw [eq_spanSingleton_of_principal I, generator_I_eq_zero, spanSingleton_zero]\n\n"}
{"name":"FractionalIdeal.invertible_of_principal","module":"Mathlib.RingTheory.DedekindDomain.Ideal","initialProofState":"K : Type u_3\ninst✝⁵ : Field K\nR₁ : Type u_4\ninst✝⁴ : CommRing R₁\ninst✝³ : IsDomain R₁\ninst✝² : Algebra R₁ K\ninst✝¹ : IsFractionRing R₁ K\nI : FractionalIdeal (nonZeroDivisors R₁) K\ninst✝ : (↑I).IsPrincipal\nh : Ne I 0\n⊢ Eq (HMul.hMul I (Inv.inv I)) 1","decl":"theorem invertible_of_principal (I : FractionalIdeal R₁⁰ K)\n    [Submodule.IsPrincipal (I : Submodule R₁ K)] (h : I ≠ 0) : I * I⁻¹ = 1 :=\n  mul_div_self_cancel_iff.mpr\n    ⟨spanSingleton _ (generator (I : Submodule R₁ K))⁻¹, mul_generator_self_inv _ I h⟩\n\n"}
{"name":"FractionalIdeal.invertible_iff_generator_nonzero","module":"Mathlib.RingTheory.DedekindDomain.Ideal","initialProofState":"K : Type u_3\ninst✝⁵ : Field K\nR₁ : Type u_4\ninst✝⁴ : CommRing R₁\ninst✝³ : IsDomain R₁\ninst✝² : Algebra R₁ K\ninst✝¹ : IsFractionRing R₁ K\nI : FractionalIdeal (nonZeroDivisors R₁) K\ninst✝ : (↑I).IsPrincipal\n⊢ Iff (Eq (HMul.hMul I (Inv.inv I)) 1) (Ne (Submodule.IsPrincipal.generator ↑I) 0)","decl":"theorem invertible_iff_generator_nonzero (I : FractionalIdeal R₁⁰ K)\n    [Submodule.IsPrincipal (I : Submodule R₁ K)] :\n    I * I⁻¹ = 1 ↔ generator (I : Submodule R₁ K) ≠ 0 := by\n  constructor\n  · intro hI hg\n    apply ne_zero_of_mul_eq_one _ _ hI\n    rw [eq_spanSingleton_of_principal I, hg, spanSingleton_zero]\n  · intro hg\n    apply invertible_of_principal\n    rw [eq_spanSingleton_of_principal I]\n    intro hI\n    have := mem_spanSingleton_self R₁⁰ (generator (I : Submodule R₁ K))\n    rw [hI, mem_zero_iff] at this\n    contradiction\n\n"}
{"name":"FractionalIdeal.isPrincipal_inv","module":"Mathlib.RingTheory.DedekindDomain.Ideal","initialProofState":"K : Type u_3\ninst✝⁵ : Field K\nR₁ : Type u_4\ninst✝⁴ : CommRing R₁\ninst✝³ : IsDomain R₁\ninst✝² : Algebra R₁ K\ninst✝¹ : IsFractionRing R₁ K\nI : FractionalIdeal (nonZeroDivisors R₁) K\ninst✝ : (↑I).IsPrincipal\nh : Ne I 0\n⊢ (↑(Inv.inv I)).IsPrincipal","decl":"theorem isPrincipal_inv (I : FractionalIdeal R₁⁰ K) [Submodule.IsPrincipal (I : Submodule R₁ K)]\n    (h : I ≠ 0) : Submodule.IsPrincipal I⁻¹.1 := by\n  rw [val_eq_coe, isPrincipal_iff]\n  use (generator (I : Submodule R₁ K))⁻¹\n  have hI : I * spanSingleton _ (generator (I : Submodule R₁ K))⁻¹ = 1 :=\n    mul_generator_self_inv _ I h\n  exact (right_inverse_eq _ I (spanSingleton _ (generator (I : Submodule R₁ K))⁻¹) hI).symm\n\n"}
{"name":"FractionalIdeal.den_mem_inv","module":"Mathlib.RingTheory.DedekindDomain.Ideal","initialProofState":"K : Type u_3\ninst✝⁴ : Field K\nR₁ : Type u_4\ninst✝³ : CommRing R₁\ninst✝² : IsDomain R₁\ninst✝¹ : Algebra R₁ K\ninst✝ : IsFractionRing R₁ K\nI : FractionalIdeal (nonZeroDivisors R₁) K\nhI : Ne I Bot.bot\n⊢ Membership.mem (Inv.inv I) ((algebraMap R₁ K) ↑I.den)","decl":"lemma den_mem_inv {I : FractionalIdeal R₁⁰ K} (hI : I ≠ ⊥) :\n    (algebraMap R₁ K) (I.den : R₁) ∈ I⁻¹ := by\n  rw [mem_inv_iff hI]\n  intro i hi\n  rw [← Algebra.smul_def (I.den : R₁) i, ← mem_coe, coe_one]\n  suffices Submodule.map (Algebra.linearMap R₁ K) I.num ≤ 1 from\n    this <| (den_mul_self_eq_num I).symm ▸ smul_mem_pointwise_smul i I.den I.coeToSubmodule hi\n  apply le_trans <| map_mono (show I.num ≤ 1 by simp only [Ideal.one_eq_top, le_top, bot_eq_zero])\n  rw [Ideal.one_eq_top, Submodule.map_top, one_eq_range]\n\n"}
{"name":"FractionalIdeal.num_le_mul_inv","module":"Mathlib.RingTheory.DedekindDomain.Ideal","initialProofState":"K : Type u_3\ninst✝⁴ : Field K\nR₁ : Type u_4\ninst✝³ : CommRing R₁\ninst✝² : IsDomain R₁\ninst✝¹ : Algebra R₁ K\ninst✝ : IsFractionRing R₁ K\nI : FractionalIdeal (nonZeroDivisors R₁) K\n⊢ LE.le (↑I.num) (HMul.hMul I (Inv.inv I))","decl":"lemma num_le_mul_inv (I : FractionalIdeal R₁⁰ K) : I.num ≤ I * I⁻¹ := by\n  by_cases hI : I = 0\n  · rw [hI, num_zero_eq <| NoZeroSMulDivisors.algebraMap_injective R₁ K, zero_mul, zero_eq_bot,\n      coeIdeal_bot]\n  · rw [mul_comm, ← den_mul_self_eq_num']\n    exact mul_right_mono I <| spanSingleton_le_iff_mem.2 (den_mem_inv hI)\n\n"}
{"name":"FractionalIdeal.bot_lt_mul_inv","module":"Mathlib.RingTheory.DedekindDomain.Ideal","initialProofState":"K : Type u_3\ninst✝⁴ : Field K\nR₁ : Type u_4\ninst✝³ : CommRing R₁\ninst✝² : IsDomain R₁\ninst✝¹ : Algebra R₁ K\ninst✝ : IsFractionRing R₁ K\nI : FractionalIdeal (nonZeroDivisors R₁) K\nhI : Ne I Bot.bot\n⊢ LT.lt Bot.bot (HMul.hMul I (Inv.inv I))","decl":"lemma bot_lt_mul_inv {I : FractionalIdeal R₁⁰ K} (hI : I ≠ ⊥) : ⊥ < I * I⁻¹ :=\n  lt_of_lt_of_le (coeIdeal_ne_zero.2 (hI ∘ num_eq_zero_iff.1)).bot_lt I.num_le_mul_inv\n\n"}
{"name":"isDedekindDomainInv_iff","module":"Mathlib.RingTheory.DedekindDomain.Ideal","initialProofState":"A : Type u_2\nK : Type u_3\ninst✝⁴ : CommRing A\ninst✝³ : Field K\ninst✝² : IsDomain A\ninst✝¹ : Algebra A K\ninst✝ : IsFractionRing A K\n⊢ Iff (IsDedekindDomainInv A) (∀ (I : FractionalIdeal (nonZeroDivisors A) K), Ne I Bot.bot → Eq (HMul.hMul I (Inv.inv I)) 1)","decl":"theorem isDedekindDomainInv_iff [Algebra A K] [IsFractionRing A K] :\n    IsDedekindDomainInv A ↔ ∀ I ≠ (⊥ : FractionalIdeal A⁰ K), I * I⁻¹ = 1 := by\n  let h : FractionalIdeal A⁰ (FractionRing A) ≃+* FractionalIdeal A⁰ K :=\n    FractionalIdeal.mapEquiv (FractionRing.algEquiv A K)\n  refine h.toEquiv.forall_congr (fun {x} => ?_)\n  rw [← h.toEquiv.apply_eq_iff_eq]\n  simp [h, IsDedekindDomainInv]\n\n"}
{"name":"FractionalIdeal.adjoinIntegral_eq_one_of_isUnit","module":"Mathlib.RingTheory.DedekindDomain.Ideal","initialProofState":"A : Type u_2\nK : Type u_3\ninst✝⁴ : CommRing A\ninst✝³ : Field K\ninst✝² : IsDomain A\ninst✝¹ : Algebra A K\ninst✝ : IsFractionRing A K\nx : K\nhx : IsIntegral A x\nhI : IsUnit (FractionalIdeal.adjoinIntegral (nonZeroDivisors A) x hx)\n⊢ Eq (FractionalIdeal.adjoinIntegral (nonZeroDivisors A) x hx) 1","decl":"theorem FractionalIdeal.adjoinIntegral_eq_one_of_isUnit [Algebra A K] [IsFractionRing A K] (x : K)\n    (hx : IsIntegral A x) (hI : IsUnit (adjoinIntegral A⁰ x hx)) : adjoinIntegral A⁰ x hx = 1 := by\n  set I := adjoinIntegral A⁰ x hx\n  have mul_self : IsIdempotentElem I := by\n    apply coeToSubmodule_injective\n    simp only [coe_mul, adjoinIntegral_coe, I]\n    rw [(Algebra.adjoin A {x}).isIdempotentElem_toSubmodule]\n  convert congr_arg (· * I⁻¹) mul_self <;>\n    simp only [(mul_inv_cancel_iff_isUnit K).mpr hI, mul_assoc, mul_one]\n\n"}
{"name":"IsDedekindDomainInv.mul_inv_eq_one","module":"Mathlib.RingTheory.DedekindDomain.Ideal","initialProofState":"A : Type u_2\nK : Type u_3\ninst✝⁴ : CommRing A\ninst✝³ : Field K\ninst✝² : IsDomain A\ninst✝¹ : Algebra A K\ninst✝ : IsFractionRing A K\nh : IsDedekindDomainInv A\nI : FractionalIdeal (nonZeroDivisors A) K\nhI : Ne I 0\n⊢ Eq (HMul.hMul I (Inv.inv I)) 1","decl":"theorem mul_inv_eq_one {I : FractionalIdeal A⁰ K} (hI : I ≠ 0) : I * I⁻¹ = 1 :=\n  isDedekindDomainInv_iff.mp h I hI\n\n"}
{"name":"IsDedekindDomainInv.inv_mul_eq_one","module":"Mathlib.RingTheory.DedekindDomain.Ideal","initialProofState":"A : Type u_2\nK : Type u_3\ninst✝⁴ : CommRing A\ninst✝³ : Field K\ninst✝² : IsDomain A\ninst✝¹ : Algebra A K\ninst✝ : IsFractionRing A K\nh : IsDedekindDomainInv A\nI : FractionalIdeal (nonZeroDivisors A) K\nhI : Ne I 0\n⊢ Eq (HMul.hMul (Inv.inv I) I) 1","decl":"theorem inv_mul_eq_one {I : FractionalIdeal A⁰ K} (hI : I ≠ 0) : I⁻¹ * I = 1 :=\n  (mul_comm _ _).trans (h.mul_inv_eq_one hI)\n\n"}
{"name":"IsDedekindDomainInv.isUnit","module":"Mathlib.RingTheory.DedekindDomain.Ideal","initialProofState":"A : Type u_2\nK : Type u_3\ninst✝⁴ : CommRing A\ninst✝³ : Field K\ninst✝² : IsDomain A\ninst✝¹ : Algebra A K\ninst✝ : IsFractionRing A K\nh : IsDedekindDomainInv A\nI : FractionalIdeal (nonZeroDivisors A) K\nhI : Ne I 0\n⊢ IsUnit I","decl":"protected theorem isUnit {I : FractionalIdeal A⁰ K} (hI : I ≠ 0) : IsUnit I :=\n  isUnit_of_mul_eq_one _ _ (h.mul_inv_eq_one hI)\n\n"}
{"name":"IsDedekindDomainInv.isNoetherianRing","module":"Mathlib.RingTheory.DedekindDomain.Ideal","initialProofState":"A : Type u_2\ninst✝¹ : CommRing A\ninst✝ : IsDomain A\nh : IsDedekindDomainInv A\n⊢ IsNoetherianRing A","decl":"theorem isNoetherianRing : IsNoetherianRing A := by\n  refine isNoetherianRing_iff.mpr ⟨fun I : Ideal A => ?_⟩\n  by_cases hI : I = ⊥\n  · rw [hI]; apply Submodule.fg_bot\n  have hI : (I : FractionalIdeal A⁰ (FractionRing A)) ≠ 0 := coeIdeal_ne_zero.mpr hI\n  exact I.fg_of_isUnit (IsFractionRing.injective A (FractionRing A)) (h.isUnit hI)\n\n"}
{"name":"IsDedekindDomainInv.integrallyClosed","module":"Mathlib.RingTheory.DedekindDomain.Ideal","initialProofState":"A : Type u_2\ninst✝¹ : CommRing A\ninst✝ : IsDomain A\nh : IsDedekindDomainInv A\n⊢ IsIntegrallyClosed A","decl":"theorem integrallyClosed : IsIntegrallyClosed A := by\n  -- It suffices to show that for integral `x`,\n  -- `A[x]` (which is a fractional ideal) is in fact equal to `A`.\n  refine (isIntegrallyClosed_iff (FractionRing A)).mpr (fun {x hx} => ?_)\n  rw [← Set.mem_range, ← Algebra.mem_bot, ← Subalgebra.mem_toSubmodule, Algebra.toSubmodule_bot,\n    Submodule.one_eq_span, ← coe_spanSingleton A⁰ (1 : FractionRing A), spanSingleton_one, ←\n    FractionalIdeal.adjoinIntegral_eq_one_of_isUnit x hx (h.isUnit _)]\n  · exact mem_adjoinIntegral_self A⁰ x hx\n  · exact fun h => one_ne_zero (eq_zero_iff.mp h 1 (Algebra.adjoin A {x}).one_mem)\n\n"}
{"name":"IsDedekindDomainInv.dimensionLEOne","module":"Mathlib.RingTheory.DedekindDomain.Ideal","initialProofState":"A : Type u_2\ninst✝¹ : CommRing A\ninst✝ : IsDomain A\nh : IsDedekindDomainInv A\n⊢ Ring.DimensionLEOne A","decl":"theorem dimensionLEOne : DimensionLEOne A := ⟨by\n  -- We're going to show that `P` is maximal because any (maximal) ideal `M`\n  -- that is strictly larger would be `⊤`.\n  rintro P P_ne hP\n  refine Ideal.isMaximal_def.mpr ⟨hP.ne_top, fun M hM => ?_⟩\n  -- We may assume `P` and `M` (as fractional ideals) are nonzero.\n  have P'_ne : (P : FractionalIdeal A⁰ (FractionRing A)) ≠ 0 := coeIdeal_ne_zero.mpr P_ne\n  have M'_ne : (M : FractionalIdeal A⁰ (FractionRing A)) ≠ 0 := coeIdeal_ne_zero.mpr hM.ne_bot\n  -- In particular, we'll show `M⁻¹ * P ≤ P`\n  suffices (M⁻¹ : FractionalIdeal A⁰ (FractionRing A)) * P ≤ P by\n    rw [eq_top_iff, ← coeIdeal_le_coeIdeal (FractionRing A), coeIdeal_top]\n    calc\n      (1 : FractionalIdeal A⁰ (FractionRing A)) = _ * _ * _ := ?_\n      _ ≤ _ * _ := mul_right_mono\n        ((P : FractionalIdeal A⁰ (FractionRing A))⁻¹ * M : FractionalIdeal A⁰ (FractionRing A)) this\n      _ = M := ?_\n    · rw [mul_assoc, ← mul_assoc (P : FractionalIdeal A⁰ (FractionRing A)), h.mul_inv_eq_one P'_ne,\n      one_mul, h.inv_mul_eq_one M'_ne]\n    · rw [← mul_assoc (P : FractionalIdeal A⁰ (FractionRing A)), h.mul_inv_eq_one P'_ne, one_mul]\n  -- Suppose we have `x ∈ M⁻¹ * P`, then in fact `x = algebraMap _ _ y` for some `y`.\n  intro x hx\n  have le_one : (M⁻¹ : FractionalIdeal A⁰ (FractionRing A)) * P ≤ 1 := by\n    rw [← h.inv_mul_eq_one M'_ne]\n    exact mul_left_mono _ ((coeIdeal_le_coeIdeal (FractionRing A)).mpr hM.le)\n  obtain ⟨y, _hy, rfl⟩ := (mem_coeIdeal _).mp (le_one hx)\n  -- Since `M` is strictly greater than `P`, let `z ∈ M \\ P`.\n  obtain ⟨z, hzM, hzp⟩ := SetLike.exists_of_lt hM\n  -- We have `z * y ∈ M * (M⁻¹ * P) = P`.\n  have zy_mem := mul_mem_mul (mem_coeIdeal_of_mem A⁰ hzM) hx\n  rw [← RingHom.map_mul, ← mul_assoc, h.mul_inv_eq_one M'_ne, one_mul] at zy_mem\n  obtain ⟨zy, hzy, zy_eq⟩ := (mem_coeIdeal A⁰).mp zy_mem\n  rw [IsFractionRing.injective A (FractionRing A) zy_eq] at hzy\n  -- But `P` is a prime ideal, so `z ∉ P` implies `y ∈ P`, as desired.\n  exact mem_coeIdeal_of_mem A⁰ (Or.resolve_left (hP.mem_or_mem hzy) hzp)⟩\n\n"}
{"name":"IsDedekindDomainInv.isDedekindDomain","module":"Mathlib.RingTheory.DedekindDomain.Ideal","initialProofState":"A : Type u_2\ninst✝¹ : CommRing A\ninst✝ : IsDomain A\nh : IsDedekindDomainInv A\n⊢ IsDedekindDomain A","decl":"/-- Showing one side of the equivalence between the definitions\n`IsDedekindDomainInv` and `IsDedekindDomain` of Dedekind domains. -/\ntheorem isDedekindDomain : IsDedekindDomain A :=\n  { h.isNoetherianRing, h.dimensionLEOne, h.integrallyClosed with }\n\n"}
{"name":"one_mem_inv_coe_ideal","module":"Mathlib.RingTheory.DedekindDomain.Ideal","initialProofState":"A : Type u_2\nK : Type u_3\ninst✝⁴ : CommRing A\ninst✝³ : Field K\ninst✝² : Algebra A K\ninst✝¹ : IsFractionRing A K\ninst✝ : IsDomain A\nI : Ideal A\nhI : Ne I Bot.bot\n⊢ Membership.mem (Inv.inv ↑I) 1","decl":"theorem one_mem_inv_coe_ideal [IsDomain A] {I : Ideal A} (hI : I ≠ ⊥) :\n    (1 : K) ∈ (I : FractionalIdeal A⁰ K)⁻¹ := by\n  rw [FractionalIdeal.mem_inv_iff (FractionalIdeal.coeIdeal_ne_zero.mpr hI)]\n  intro y hy\n  rw [one_mul]\n  exact FractionalIdeal.coeIdeal_le_one hy\n\n"}
{"name":"exists_multiset_prod_cons_le_and_prod_not_le","module":"Mathlib.RingTheory.DedekindDomain.Ideal","initialProofState":"A : Type u_2\ninst✝¹ : CommRing A\ninst✝ : IsDedekindDomain A\nhNF : Not (IsField A)\nI M : Ideal A\nhI0 : Ne I Bot.bot\nhIM : LE.le I M\nhM : M.IsMaximal\n⊢ Exists fun Z => And (LE.le (Multiset.cons M (Multiset.map PrimeSpectrum.asIdeal Z)).prod I) (Not (LE.le (Multiset.map PrimeSpectrum.asIdeal Z).prod I))","decl":"/-- Specialization of `exists_primeSpectrum_prod_le_and_ne_bot_of_domain` to Dedekind domains:\nLet `I : Ideal A` be a nonzero ideal, where `A` is a Dedekind domain that is not a field.\nThen `exists_primeSpectrum_prod_le_and_ne_bot_of_domain` states we can find a product of prime\nideals that is contained within `I`. This lemma extends that result by making the product minimal:\nlet `M` be a maximal ideal that contains `I`, then the product including `M` is contained within `I`\nand the product excluding `M` is not contained within `I`. -/\ntheorem exists_multiset_prod_cons_le_and_prod_not_le [IsDedekindDomain A] (hNF : ¬IsField A)\n    {I M : Ideal A} (hI0 : I ≠ ⊥) (hIM : I ≤ M) [hM : M.IsMaximal] :\n    ∃ Z : Multiset (PrimeSpectrum A),\n      (M ::ₘ Z.map PrimeSpectrum.asIdeal).prod ≤ I ∧\n        ¬Multiset.prod (Z.map PrimeSpectrum.asIdeal) ≤ I := by\n  -- Let `Z` be a minimal set of prime ideals such that their product is contained in `J`.\n  obtain ⟨Z₀, hZ₀⟩ := PrimeSpectrum.exists_primeSpectrum_prod_le_and_ne_bot_of_domain hNF hI0\n  obtain ⟨Z, ⟨hZI, hprodZ⟩, h_eraseZ⟩ :=\n    wellFounded_lt.has_min\n      {Z | (Z.map PrimeSpectrum.asIdeal).prod ≤ I ∧ (Z.map PrimeSpectrum.asIdeal).prod ≠ ⊥}\n      ⟨Z₀, hZ₀.1, hZ₀.2⟩\n  obtain ⟨_, hPZ', hPM⟩ := hM.isPrime.multiset_prod_le.mp (hZI.trans hIM)\n  -- Then in fact there is a `P ∈ Z` with `P ≤ M`.\n  obtain ⟨P, hPZ, rfl⟩ := Multiset.mem_map.mp hPZ'\n  classical\n    have := Multiset.map_erase PrimeSpectrum.asIdeal (fun _ _ => PrimeSpectrum.ext) P Z\n    obtain ⟨hP0, hZP0⟩ : P.asIdeal ≠ ⊥ ∧ ((Z.erase P).map PrimeSpectrum.asIdeal).prod ≠ ⊥ := by\n      rwa [Ne, ← Multiset.cons_erase hPZ', Multiset.prod_cons, Ideal.mul_eq_bot, not_or, ←\n        this] at hprodZ\n    -- By maximality of `P` and `M`, we have that `P ≤ M` implies `P = M`.\n    have hPM' := (P.isPrime.isMaximal hP0).eq_of_le hM.ne_top hPM\n    subst hPM'\n    -- By minimality of `Z`, erasing `P` from `Z` is exactly what we need.\n    refine ⟨Z.erase P, ?_, ?_⟩\n    · convert hZI\n      rw [this, Multiset.cons_erase hPZ']\n    · refine fun h => h_eraseZ (Z.erase P) ⟨h, ?_⟩ (Multiset.erase_lt.mpr hPZ)\n      exact hZP0\n"}
{"name":"FractionalIdeal.not_inv_le_one_of_ne_bot","module":"Mathlib.RingTheory.DedekindDomain.Ideal","initialProofState":"A : Type u_2\nK : Type u_3\ninst✝⁴ : CommRing A\ninst✝³ : Field K\ninst✝² : Algebra A K\ninst✝¹ : IsFractionRing A K\ninst✝ : IsDedekindDomain A\nI : Ideal A\nhI0 : Ne I Bot.bot\nhI1 : Ne I Top.top\n⊢ Not (LE.le (Inv.inv ↑I) 1)","decl":"lemma not_inv_le_one_of_ne_bot [IsDedekindDomain A] {I : Ideal A}\n    (hI0 : I ≠ ⊥) (hI1 : I ≠ ⊤) : ¬(I⁻¹ : FractionalIdeal A⁰ K) ≤ 1 := by\n  have hNF : ¬IsField A := fun h ↦ letI := h.toField; (eq_bot_or_eq_top I).elim hI0 hI1\n  wlog hM : I.IsMaximal generalizing I\n  · rcases I.exists_le_maximal hI1 with ⟨M, hmax, hIM⟩\n    have hMbot : M ≠ ⊥ := (M.bot_lt_of_maximal hNF).ne'\n    refine mt (le_trans <| inv_anti_mono ?_ ?_ ?_) (this hMbot hmax.ne_top hmax) <;>\n      simpa only [coeIdeal_ne_zero, coeIdeal_le_coeIdeal]\n  have hI0 : ⊥ < I := I.bot_lt_of_maximal hNF\n  obtain ⟨⟨a, haI⟩, ha0⟩ := Submodule.nonzero_mem_of_bot_lt hI0\n  replace ha0 : a ≠ 0 := Subtype.coe_injective.ne ha0\n  let J : Ideal A := Ideal.span {a}\n  have hJ0 : J ≠ ⊥ := mt Ideal.span_singleton_eq_bot.mp ha0\n  have hJI : J ≤ I := I.span_singleton_le_iff_mem.2 haI\n  -- Then we can find a product of prime (hence maximal) ideals contained in `J`,\n  -- such that removing element `M` from the product is not contained in `J`.\n  obtain ⟨Z, hle, hnle⟩ := exists_multiset_prod_cons_le_and_prod_not_le hNF hJ0 hJI\n  -- Choose an element `b` of the product that is not in `J`.\n  obtain ⟨b, hbZ, hbJ⟩ := SetLike.not_le_iff_exists.mp hnle\n  have hnz_fa : algebraMap A K a ≠ 0 :=\n    mt ((injective_iff_map_eq_zero _).mp (IsFractionRing.injective A K) a) ha0\n  -- Then `b a⁻¹ : K` is in `M⁻¹` but not in `1`.\n  refine Set.not_subset.2 ⟨algebraMap A K b * (algebraMap A K a)⁻¹, (mem_inv_iff ?_).mpr ?_, ?_⟩\n  · exact coeIdeal_ne_zero.mpr hI0.ne'\n  · rintro y₀ hy₀\n    obtain ⟨y, h_Iy, rfl⟩ := (mem_coeIdeal _).mp hy₀\n    rw [mul_comm, ← mul_assoc, ← RingHom.map_mul]\n    have h_yb : y * b ∈ J := by\n      apply hle\n      rw [Multiset.prod_cons]\n      exact Submodule.smul_mem_smul h_Iy hbZ\n    rw [Ideal.mem_span_singleton'] at h_yb\n    rcases h_yb with ⟨c, hc⟩\n    rw [← hc, RingHom.map_mul, mul_assoc, mul_inv_cancel₀ hnz_fa, mul_one]\n    apply coe_mem_one\n  · refine mt (mem_one_iff _).mp ?_\n    rintro ⟨x', h₂_abs⟩\n    rw [← div_eq_mul_inv, eq_div_iff_mul_eq hnz_fa, ← RingHom.map_mul] at h₂_abs\n    have := Ideal.mem_span_singleton'.mpr ⟨x', IsFractionRing.injective A K h₂_abs⟩\n    contradiction\n\n"}
{"name":"FractionalIdeal.exists_not_mem_one_of_ne_bot","module":"Mathlib.RingTheory.DedekindDomain.Ideal","initialProofState":"A : Type u_2\nK : Type u_3\ninst✝⁴ : CommRing A\ninst✝³ : Field K\ninst✝² : Algebra A K\ninst✝¹ : IsFractionRing A K\ninst✝ : IsDedekindDomain A\nI : Ideal A\nhI0 : Ne I Bot.bot\nhI1 : Ne I Top.top\n⊢ Exists fun x => And (Membership.mem (Inv.inv ↑I) x) (Not (Membership.mem 1 x))","decl":"theorem exists_not_mem_one_of_ne_bot [IsDedekindDomain A] {I : Ideal A} (hI0 : I ≠ ⊥)\n    (hI1 : I ≠ ⊤) : ∃ x ∈ (I⁻¹ : FractionalIdeal A⁰ K), x ∉ (1 : FractionalIdeal A⁰ K) :=\n  Set.not_subset.1 <| not_inv_le_one_of_ne_bot hI0 hI1\n\n"}
{"name":"FractionalIdeal.mul_inv_cancel_of_le_one","module":"Mathlib.RingTheory.DedekindDomain.Ideal","initialProofState":"A : Type u_2\nK : Type u_3\ninst✝³ : CommRing A\ninst✝² : Field K\ninst✝¹ : Algebra A K\ninst✝ : IsFractionRing A K\nh : IsDedekindDomain A\nI : Ideal A\nhI0 : Ne I Bot.bot\nhI : LE.le (Inv.inv (HMul.hMul (↑I) (Inv.inv ↑I))) 1\n⊢ Eq (HMul.hMul (↑I) (Inv.inv ↑I)) 1","decl":"theorem mul_inv_cancel_of_le_one [h : IsDedekindDomain A] {I : Ideal A} (hI0 : I ≠ ⊥)\n    (hI : (I * (I : FractionalIdeal A⁰ K)⁻¹)⁻¹ ≤ 1) : I * (I : FractionalIdeal A⁰ K)⁻¹ = 1 := by\n  -- We'll show a contradiction with `exists_not_mem_one_of_ne_bot`:\n  -- `J⁻¹ = (I * I⁻¹)⁻¹` cannot have an element `x ∉ 1`, so it must equal `1`.\n  obtain ⟨J, hJ⟩ : ∃ J : Ideal A, (J : FractionalIdeal A⁰ K) = I * (I : FractionalIdeal A⁰ K)⁻¹ :=\n    le_one_iff_exists_coeIdeal.mp mul_one_div_le_one\n  by_cases hJ0 : J = ⊥\n  · subst hJ0\n    refine absurd ?_ hI0\n    rw [eq_bot_iff, ← coeIdeal_le_coeIdeal K, hJ]\n    exact coe_ideal_le_self_mul_inv K I\n  by_cases hJ1 : J = ⊤\n  · rw [← hJ, hJ1, coeIdeal_top]\n  exact (not_inv_le_one_of_ne_bot (K := K) hJ0 hJ1 (hJ ▸ hI)).elim\n\n"}
{"name":"FractionalIdeal.coe_ideal_mul_inv","module":"Mathlib.RingTheory.DedekindDomain.Ideal","initialProofState":"A : Type u_2\nK : Type u_3\ninst✝³ : CommRing A\ninst✝² : Field K\ninst✝¹ : Algebra A K\ninst✝ : IsFractionRing A K\nh : IsDedekindDomain A\nI : Ideal A\nhI0 : Ne I Bot.bot\n⊢ Eq (HMul.hMul (↑I) (Inv.inv ↑I)) 1","decl":"/-- Nonzero integral ideals in a Dedekind domain are invertible.\n\nWe will use this to show that nonzero fractional ideals are invertible,\nand finally conclude that fractional ideals in a Dedekind domain form a group with zero.\n-/\ntheorem coe_ideal_mul_inv [h : IsDedekindDomain A] (I : Ideal A) (hI0 : I ≠ ⊥) :\n    I * (I : FractionalIdeal A⁰ K)⁻¹ = 1 := by\n  -- We'll show `1 ≤ J⁻¹ = (I * I⁻¹)⁻¹ ≤ 1`.\n  apply mul_inv_cancel_of_le_one hI0\n  by_cases hJ0 : I * (I : FractionalIdeal A⁰ K)⁻¹ = 0\n  · rw [hJ0, inv_zero']; exact zero_le _\n  intro x hx\n  -- In particular, we'll show all `x ∈ J⁻¹` are integral.\n  suffices x ∈ integralClosure A K by\n    rwa [IsIntegrallyClosed.integralClosure_eq_bot, Algebra.mem_bot, Set.mem_range,\n      ← mem_one_iff] at this\n  -- For that, we'll find a subalgebra that is f.g. as a module and contains `x`.\n  -- `A` is a noetherian ring, so we just need to find a subalgebra between `{x}` and `I⁻¹`.\n  rw [mem_integralClosure_iff_mem_fg]\n  have x_mul_mem : ∀ b ∈ (I⁻¹ : FractionalIdeal A⁰ K), x * b ∈ (I⁻¹ : FractionalIdeal A⁰ K) := by\n    intro b hb\n    rw [mem_inv_iff (coeIdeal_ne_zero.mpr hI0)]\n    dsimp only at hx\n    rw [val_eq_coe, mem_coe, mem_inv_iff hJ0] at hx\n    simp only [mul_assoc, mul_comm b] at hx ⊢\n    intro y hy\n    exact hx _ (mul_mem_mul hy hb)\n  -- It turns out the subalgebra consisting of all `p(x)` for `p : A[X]` works.\n  refine ⟨AlgHom.range (Polynomial.aeval x : A[X] →ₐ[A] K),\n    isNoetherian_submodule.mp (isNoetherian (I : FractionalIdeal A⁰ K)⁻¹) _ fun y hy => ?_,\n    ⟨Polynomial.X, Polynomial.aeval_X x⟩⟩\n  obtain ⟨p, rfl⟩ := (AlgHom.mem_range _).mp hy\n  rw [Polynomial.aeval_eq_sum_range]\n  refine Submodule.sum_mem _ fun i hi => Submodule.smul_mem _ _ ?_\n  clear hi\n  induction' i with i ih\n  · rw [pow_zero]; exact one_mem_inv_coe_ideal hI0\n  · show x ^ i.succ ∈ (I⁻¹ : FractionalIdeal A⁰ K)\n    rw [pow_succ']; exact x_mul_mem _ ih\n\n"}
{"name":"FractionalIdeal.mul_inv_cancel","module":"Mathlib.RingTheory.DedekindDomain.Ideal","initialProofState":"A : Type u_2\nK : Type u_3\ninst✝⁴ : CommRing A\ninst✝³ : Field K\ninst✝² : Algebra A K\ninst✝¹ : IsFractionRing A K\ninst✝ : IsDedekindDomain A\nI : FractionalIdeal (nonZeroDivisors A) K\nhne : Ne I 0\n⊢ Eq (HMul.hMul I (Inv.inv I)) 1","decl":"/-- Nonzero fractional ideals in a Dedekind domain are units.\n\nThis is also available as `_root_.mul_inv_cancel`, using the\n`Semifield` instance defined below.\n-/\nprotected theorem mul_inv_cancel [IsDedekindDomain A] {I : FractionalIdeal A⁰ K} (hne : I ≠ 0) :\n    I * I⁻¹ = 1 := by\n  obtain ⟨a, J, ha, hJ⟩ :\n    ∃ (a : A) (aI : Ideal A), a ≠ 0 ∧ I = spanSingleton A⁰ (algebraMap A K a)⁻¹ * aI :=\n    exists_eq_spanSingleton_mul I\n  suffices h₂ : I * (spanSingleton A⁰ (algebraMap _ _ a) * (J : FractionalIdeal A⁰ K)⁻¹) = 1 by\n    rw [mul_inv_cancel_iff]\n    exact ⟨spanSingleton A⁰ (algebraMap _ _ a) * (J : FractionalIdeal A⁰ K)⁻¹, h₂⟩\n  subst hJ\n  rw [mul_assoc, mul_left_comm (J : FractionalIdeal A⁰ K), coe_ideal_mul_inv, mul_one,\n    spanSingleton_mul_spanSingleton, inv_mul_cancel₀, spanSingleton_one]\n  · exact mt ((injective_iff_map_eq_zero (algebraMap A K)).mp (IsFractionRing.injective A K) _) ha\n  · exact coeIdeal_ne_zero.mp (right_ne_zero_of_mul hne)\n\n"}
{"name":"FractionalIdeal.mul_right_le_iff","module":"Mathlib.RingTheory.DedekindDomain.Ideal","initialProofState":"A : Type u_2\nK : Type u_3\ninst✝⁴ : CommRing A\ninst✝³ : Field K\ninst✝² : Algebra A K\ninst✝¹ : IsFractionRing A K\ninst✝ : IsDedekindDomain A\nJ : FractionalIdeal (nonZeroDivisors A) K\nhJ : Ne J 0\nI I' : FractionalIdeal (nonZeroDivisors A) K\n⊢ Iff (LE.le (HMul.hMul I J) (HMul.hMul I' J)) (LE.le I I')","decl":"theorem mul_right_le_iff [IsDedekindDomain A] {J : FractionalIdeal A⁰ K} (hJ : J ≠ 0) :\n    ∀ {I I'}, I * J ≤ I' * J ↔ I ≤ I' := by\n  intro I I'\n  constructor\n  · intro h\n    convert mul_right_mono J⁻¹ h <;> dsimp only <;>\n    rw [mul_assoc, FractionalIdeal.mul_inv_cancel hJ, mul_one]\n  · exact fun h => mul_right_mono J h\n\n"}
{"name":"FractionalIdeal.mul_left_le_iff","module":"Mathlib.RingTheory.DedekindDomain.Ideal","initialProofState":"A : Type u_2\nK : Type u_3\ninst✝⁴ : CommRing A\ninst✝³ : Field K\ninst✝² : Algebra A K\ninst✝¹ : IsFractionRing A K\ninst✝ : IsDedekindDomain A\nJ : FractionalIdeal (nonZeroDivisors A) K\nhJ : Ne J 0\nI I' : FractionalIdeal (nonZeroDivisors A) K\n⊢ Iff (LE.le (HMul.hMul J I) (HMul.hMul J I')) (LE.le I I')","decl":"theorem mul_left_le_iff [IsDedekindDomain A] {J : FractionalIdeal A⁰ K} (hJ : J ≠ 0) {I I'} :\n    J * I ≤ J * I' ↔ I ≤ I' := by convert mul_right_le_iff hJ using 1; simp only [mul_comm]\n\n"}
{"name":"FractionalIdeal.mul_right_strictMono","module":"Mathlib.RingTheory.DedekindDomain.Ideal","initialProofState":"A : Type u_2\nK : Type u_3\ninst✝⁴ : CommRing A\ninst✝³ : Field K\ninst✝² : Algebra A K\ninst✝¹ : IsFractionRing A K\ninst✝ : IsDedekindDomain A\nI : FractionalIdeal (nonZeroDivisors A) K\nhI : Ne I 0\n⊢ StrictMono fun x => HMul.hMul x I","decl":"theorem mul_right_strictMono [IsDedekindDomain A] {I : FractionalIdeal A⁰ K} (hI : I ≠ 0) :\n    StrictMono (· * I) :=\n  strictMono_of_le_iff_le fun _ _ => (mul_right_le_iff hI).symm\n\n"}
{"name":"FractionalIdeal.mul_left_strictMono","module":"Mathlib.RingTheory.DedekindDomain.Ideal","initialProofState":"A : Type u_2\nK : Type u_3\ninst✝⁴ : CommRing A\ninst✝³ : Field K\ninst✝² : Algebra A K\ninst✝¹ : IsFractionRing A K\ninst✝ : IsDedekindDomain A\nI : FractionalIdeal (nonZeroDivisors A) K\nhI : Ne I 0\n⊢ StrictMono fun x => HMul.hMul I x","decl":"theorem mul_left_strictMono [IsDedekindDomain A] {I : FractionalIdeal A⁰ K} (hI : I ≠ 0) :\n    StrictMono (I * ·) :=\n  strictMono_of_le_iff_le fun _ _ => (mul_left_le_iff hI).symm\n\n"}
{"name":"FractionalIdeal.div_eq_mul_inv","module":"Mathlib.RingTheory.DedekindDomain.Ideal","initialProofState":"A : Type u_2\nK : Type u_3\ninst✝⁴ : CommRing A\ninst✝³ : Field K\ninst✝² : Algebra A K\ninst✝¹ : IsFractionRing A K\ninst✝ : IsDedekindDomain A\nI J : FractionalIdeal (nonZeroDivisors A) K\n⊢ Eq (HDiv.hDiv I J) (HMul.hMul I (Inv.inv J))","decl":"/-- This is also available as `_root_.div_eq_mul_inv`, using the\n`Semifield` instance defined below.\n-/\nprotected theorem div_eq_mul_inv [IsDedekindDomain A] (I J : FractionalIdeal A⁰ K) :\n    I / J = I * J⁻¹ := by\n  by_cases hJ : J = 0\n  · rw [hJ, div_zero, inv_zero', mul_zero]\n  refine le_antisymm ((mul_right_le_iff hJ).mp ?_) ((le_div_iff_mul_le hJ).mpr ?_)\n  · rw [mul_assoc, mul_comm J⁻¹, FractionalIdeal.mul_inv_cancel hJ, mul_one, mul_le]\n    intro x hx y hy\n    rw [mem_div_iff_of_nonzero hJ] at hx\n    exact hx y hy\n  rw [mul_assoc, mul_comm J⁻¹, FractionalIdeal.mul_inv_cancel hJ, mul_one]\n\n"}
{"name":"isDedekindDomain_iff_isDedekindDomainInv","module":"Mathlib.RingTheory.DedekindDomain.Ideal","initialProofState":"A : Type u_2\ninst✝¹ : CommRing A\ninst✝ : IsDomain A\n⊢ Iff (IsDedekindDomain A) (IsDedekindDomainInv A)","decl":"/-- `IsDedekindDomain` and `IsDedekindDomainInv` are equivalent ways\nto express that an integral domain is a Dedekind domain. -/\ntheorem isDedekindDomain_iff_isDedekindDomainInv [IsDomain A] :\n    IsDedekindDomain A ↔ IsDedekindDomainInv A :=\n  ⟨fun _h _I hI => FractionalIdeal.mul_inv_cancel hI, fun h => h.isDedekindDomain⟩\n\n"}
{"name":"Ideal.isDomain","module":"Mathlib.RingTheory.DedekindDomain.Ideal","initialProofState":"A : Type u_2\ninst✝¹ : CommRing A\ninst✝ : IsDedekindDomain A\n⊢ IsDomain (Ideal A)","decl":"instance Ideal.isDomain : IsDomain (Ideal A) := { }\n\n"}
{"name":"Ideal.dvd_iff_le","module":"Mathlib.RingTheory.DedekindDomain.Ideal","initialProofState":"A : Type u_2\ninst✝¹ : CommRing A\ninst✝ : IsDedekindDomain A\nI J : Ideal A\n⊢ Iff (Dvd.dvd I J) (LE.le J I)","decl":"/-- For ideals in a Dedekind domain, to divide is to contain. -/\ntheorem Ideal.dvd_iff_le {I J : Ideal A} : I ∣ J ↔ J ≤ I :=\n  ⟨Ideal.le_of_dvd, fun h => by\n    by_cases hI : I = ⊥\n    · have hJ : J = ⊥ := by rwa [hI, ← eq_bot_iff] at h\n      rw [hI, hJ]\n    have hI' : (I : FractionalIdeal A⁰ (FractionRing A)) ≠ 0 := coeIdeal_ne_zero.mpr hI\n    have : (I : FractionalIdeal A⁰ (FractionRing A))⁻¹ * J ≤ 1 := by\n      rw [← inv_mul_cancel₀ hI']\n      exact mul_left_mono _ ((coeIdeal_le_coeIdeal _).mpr h)\n    obtain ⟨H, hH⟩ := le_one_iff_exists_coeIdeal.mp this\n    use H\n    refine coeIdeal_injective (show (J : FractionalIdeal A⁰ (FractionRing A)) = ↑(I * H) from ?_)\n    rw [coeIdeal_mul, hH, ← mul_assoc, mul_inv_cancel₀ hI', one_mul]⟩\n\n"}
{"name":"Ideal.dvdNotUnit_iff_lt","module":"Mathlib.RingTheory.DedekindDomain.Ideal","initialProofState":"A : Type u_2\ninst✝¹ : CommRing A\ninst✝ : IsDedekindDomain A\nI J : Ideal A\n⊢ Iff (DvdNotUnit I J) (LT.lt J I)","decl":"theorem Ideal.dvdNotUnit_iff_lt {I J : Ideal A} : DvdNotUnit I J ↔ J < I :=\n  ⟨fun ⟨hI, H, hunit, hmul⟩ =>\n    lt_of_le_of_ne (Ideal.dvd_iff_le.mp ⟨H, hmul⟩)\n      (mt\n        (fun h =>\n          have : H = 1 := mul_left_cancel₀ hI (by rw [← hmul, h, mul_one])\n          show IsUnit H from this.symm ▸ isUnit_one)\n        hunit),\n    fun h =>\n    dvdNotUnit_of_dvd_of_not_dvd (Ideal.dvd_iff_le.mpr (le_of_lt h))\n      (mt Ideal.dvd_iff_le.mp (not_le_of_lt h))⟩\n\n"}
{"name":"instWfDvdMonoidIdeal","module":"Mathlib.RingTheory.DedekindDomain.Ideal","initialProofState":"A : Type u_2\ninst✝ : CommRing A\n⊢ WfDvdMonoid (Ideal A)","decl":"instance : WfDvdMonoid (Ideal A) where\n  wf := by\n    have : WellFoundedGT (Ideal A) := inferInstance\n    convert this.wf\n    ext\n    rw [Ideal.dvdNotUnit_iff_lt]\n\n"}
{"name":"Ideal.uniqueFactorizationMonoid","module":"Mathlib.RingTheory.DedekindDomain.Ideal","initialProofState":"A : Type u_2\ninst✝¹ : CommRing A\ninst✝ : IsDedekindDomain A\n⊢ UniqueFactorizationMonoid (Ideal A)","decl":"instance Ideal.uniqueFactorizationMonoid : UniqueFactorizationMonoid (Ideal A) :=\n  { irreducible_iff_prime := by\n      intro P\n      exact ⟨fun hirr => ⟨hirr.ne_zero, hirr.not_unit, fun I J => by\n        have : P.IsMaximal := by\n          refine ⟨⟨mt Ideal.isUnit_iff.mpr hirr.not_unit, ?_⟩⟩\n          intro J hJ\n          obtain ⟨_J_ne, H, hunit, P_eq⟩ := Ideal.dvdNotUnit_iff_lt.mpr hJ\n          exact Ideal.isUnit_iff.mp ((hirr.isUnit_or_isUnit P_eq).resolve_right hunit)\n        rw [Ideal.dvd_iff_le, Ideal.dvd_iff_le, Ideal.dvd_iff_le, SetLike.le_def, SetLike.le_def,\n          SetLike.le_def]\n        contrapose!\n        rintro ⟨⟨x, x_mem, x_not_mem⟩, ⟨y, y_mem, y_not_mem⟩⟩\n        exact\n          ⟨x * y, Ideal.mul_mem_mul x_mem y_mem,\n            mt this.isPrime.mem_or_mem (not_or_intro x_not_mem y_not_mem)⟩⟩, Prime.irreducible⟩ }\n\n"}
{"name":"Ideal.dvd_span_singleton","module":"Mathlib.RingTheory.DedekindDomain.Ideal","initialProofState":"A : Type u_2\ninst✝¹ : CommRing A\ninst✝ : IsDedekindDomain A\nI : Ideal A\nx : A\n⊢ Iff (Dvd.dvd I (Ideal.span (Singleton.singleton x))) (Membership.mem I x)","decl":"@[simp]\ntheorem Ideal.dvd_span_singleton {I : Ideal A} {x : A} : I ∣ Ideal.span {x} ↔ x ∈ I :=\n  Ideal.dvd_iff_le.trans (Ideal.span_le.trans Set.singleton_subset_iff)\n\n"}
{"name":"Ideal.isPrime_of_prime","module":"Mathlib.RingTheory.DedekindDomain.Ideal","initialProofState":"A : Type u_2\ninst✝¹ : CommRing A\ninst✝ : IsDedekindDomain A\nP : Ideal A\nh : Prime P\n⊢ P.IsPrime","decl":"theorem Ideal.isPrime_of_prime {P : Ideal A} (h : Prime P) : IsPrime P := by\n  refine ⟨?_, fun hxy => ?_⟩\n  · rintro rfl\n    rw [← Ideal.one_eq_top] at h\n    exact h.not_unit isUnit_one\n  · simp only [← Ideal.dvd_span_singleton, ← Ideal.span_singleton_mul_span_singleton] at hxy ⊢\n    exact h.dvd_or_dvd hxy\n\n"}
{"name":"Ideal.prime_of_isPrime","module":"Mathlib.RingTheory.DedekindDomain.Ideal","initialProofState":"A : Type u_2\ninst✝¹ : CommRing A\ninst✝ : IsDedekindDomain A\nP : Ideal A\nhP : Ne P Bot.bot\nh : P.IsPrime\n⊢ Prime P","decl":"theorem Ideal.prime_of_isPrime {P : Ideal A} (hP : P ≠ ⊥) (h : IsPrime P) : Prime P := by\n  refine ⟨hP, mt Ideal.isUnit_iff.mp h.ne_top, fun I J hIJ => ?_⟩\n  simpa only [Ideal.dvd_iff_le] using h.mul_le.mp (Ideal.le_of_dvd hIJ)\n\n"}
{"name":"Ideal.prime_iff_isPrime","module":"Mathlib.RingTheory.DedekindDomain.Ideal","initialProofState":"A : Type u_2\ninst✝¹ : CommRing A\ninst✝ : IsDedekindDomain A\nP : Ideal A\nhP : Ne P Bot.bot\n⊢ Iff (Prime P) P.IsPrime","decl":"/-- In a Dedekind domain, the (nonzero) prime elements of the monoid with zero `Ideal A`\nare exactly the prime ideals. -/\ntheorem Ideal.prime_iff_isPrime {P : Ideal A} (hP : P ≠ ⊥) : Prime P ↔ IsPrime P :=\n  ⟨Ideal.isPrime_of_prime, Ideal.prime_of_isPrime hP⟩\n\n"}
{"name":"Ideal.isPrime_iff_bot_or_prime","module":"Mathlib.RingTheory.DedekindDomain.Ideal","initialProofState":"A : Type u_2\ninst✝¹ : CommRing A\ninst✝ : IsDedekindDomain A\nP : Ideal A\n⊢ Iff P.IsPrime (Or (Eq P Bot.bot) (Prime P))","decl":"/-- In a Dedekind domain, the prime ideals are the zero ideal together with the prime elements\nof the monoid with zero `Ideal A`. -/\ntheorem Ideal.isPrime_iff_bot_or_prime {P : Ideal A} : IsPrime P ↔ P = ⊥ ∨ Prime P :=\n  ⟨fun hp => (eq_or_ne P ⊥).imp_right fun hp0 => Ideal.prime_of_isPrime hp0 hp, fun hp =>\n    hp.elim (fun h => h.symm ▸ Ideal.bot_prime) Ideal.isPrime_of_prime⟩\n\n"}
{"name":"Ideal.prime_span_singleton_iff","module":"Mathlib.RingTheory.DedekindDomain.Ideal","initialProofState":"A : Type u_2\ninst✝¹ : CommRing A\ninst✝ : IsDedekindDomain A\na : A\n⊢ Iff (Prime (Ideal.span (Singleton.singleton a))) (Prime a)","decl":"@[simp]\ntheorem Ideal.prime_span_singleton_iff {a : A} : Prime (Ideal.span {a}) ↔ Prime a := by\n  rcases eq_or_ne a 0 with rfl | ha\n  · rw [Set.singleton_zero, span_zero, ← Ideal.zero_eq_bot, ← not_iff_not]\n    simp only [not_prime_zero, not_false_eq_true]\n  · have ha' : span {a} ≠ ⊥ := by simpa only [ne_eq, span_singleton_eq_bot] using ha\n    rw [Ideal.prime_iff_isPrime ha', Ideal.span_singleton_prime ha]\n\n"}
{"name":"Ideal.prime_generator_of_prime","module":"Mathlib.RingTheory.DedekindDomain.Ideal","initialProofState":"A : Type u_2\ninst✝² : CommRing A\ninst✝¹ : IsDedekindDomain A\nP : Ideal A\nh : Prime P\ninst✝ : Submodule.IsPrincipal P\n⊢ Prime (Submodule.IsPrincipal.generator P)","decl":"open Submodule.IsPrincipal in\ntheorem Ideal.prime_generator_of_prime {P : Ideal A} (h : Prime P) [P.IsPrincipal] :\n    Prime (generator P) :=\n  have : Ideal.IsPrime P := Ideal.isPrime_of_prime h\n  prime_generator_of_isPrime _ h.ne_zero\n\n"}
{"name":"Ideal.mem_normalizedFactors_iff","module":"Mathlib.RingTheory.DedekindDomain.Ideal","initialProofState":"A : Type u_2\ninst✝¹ : CommRing A\ninst✝ : IsDedekindDomain A\np I : Ideal A\nhI : Ne I Bot.bot\n⊢ Iff (Membership.mem (UniqueFactorizationMonoid.normalizedFactors I) p) (And p.IsPrime (LE.le I p))","decl":"open UniqueFactorizationMonoid in\nnonrec theorem Ideal.mem_normalizedFactors_iff {p I : Ideal A} (hI : I ≠ ⊥) :\n    p ∈ normalizedFactors I ↔ p.IsPrime ∧ I ≤ p := by\n  rw [← Ideal.dvd_iff_le]\n  by_cases hp : p = 0\n  · rw [← zero_eq_bot] at hI\n    simp only [hp, zero_not_mem_normalizedFactors, zero_dvd_iff, hI, false_iff, not_and,\n      not_false_eq_true, implies_true]\n  · rwa [mem_normalizedFactors_iff hI, prime_iff_isPrime]\n\n"}
{"name":"Ideal.pow_right_strictAnti","module":"Mathlib.RingTheory.DedekindDomain.Ideal","initialProofState":"A : Type u_2\ninst✝¹ : CommRing A\ninst✝ : IsDedekindDomain A\nI : Ideal A\nhI0 : Ne I Bot.bot\nhI1 : Ne I Top.top\n⊢ StrictAnti fun x => HPow.hPow I x","decl":"theorem Ideal.pow_right_strictAnti (I : Ideal A) (hI0 : I ≠ ⊥) (hI1 : I ≠ ⊤) :\n    StrictAnti (I ^ · : ℕ → Ideal A) :=\n  strictAnti_nat_of_succ_lt fun e =>\n    Ideal.dvdNotUnit_iff_lt.mp ⟨pow_ne_zero _ hI0, I, mt isUnit_iff.mp hI1, pow_succ I e⟩\n\n"}
{"name":"Ideal.pow_lt_self","module":"Mathlib.RingTheory.DedekindDomain.Ideal","initialProofState":"A : Type u_2\ninst✝¹ : CommRing A\ninst✝ : IsDedekindDomain A\nI : Ideal A\nhI0 : Ne I Bot.bot\nhI1 : Ne I Top.top\ne : Nat\nhe : LE.le 2 e\n⊢ LT.lt (HPow.hPow I e) I","decl":"theorem Ideal.pow_lt_self (I : Ideal A) (hI0 : I ≠ ⊥) (hI1 : I ≠ ⊤) (e : ℕ) (he : 2 ≤ e) :\n    I ^ e < I := by\n  convert I.pow_right_strictAnti hI0 hI1 he\n  dsimp only\n  rw [pow_one]\n\n"}
{"name":"Ideal.exists_mem_pow_not_mem_pow_succ","module":"Mathlib.RingTheory.DedekindDomain.Ideal","initialProofState":"A : Type u_2\ninst✝¹ : CommRing A\ninst✝ : IsDedekindDomain A\nI : Ideal A\nhI0 : Ne I Bot.bot\nhI1 : Ne I Top.top\ne : Nat\n⊢ Exists fun x => And (Membership.mem (HPow.hPow I e) x) (Not (Membership.mem (HPow.hPow I (HAdd.hAdd e 1)) x))","decl":"theorem Ideal.exists_mem_pow_not_mem_pow_succ (I : Ideal A) (hI0 : I ≠ ⊥) (hI1 : I ≠ ⊤) (e : ℕ) :\n    ∃ x ∈ I ^ e, x ∉ I ^ (e + 1) :=\n  SetLike.exists_of_lt (I.pow_right_strictAnti hI0 hI1 e.lt_succ_self)\n\n"}
{"name":"Ideal.eq_prime_pow_of_succ_lt_of_le","module":"Mathlib.RingTheory.DedekindDomain.Ideal","initialProofState":"A : Type u_2\ninst✝¹ : CommRing A\ninst✝ : IsDedekindDomain A\nP I : Ideal A\nP_prime : P.IsPrime\nhP : Ne P Bot.bot\ni : Nat\nhlt : LT.lt (HPow.hPow P (HAdd.hAdd i 1)) I\nhle : LE.le I (HPow.hPow P i)\n⊢ Eq I (HPow.hPow P i)","decl":"theorem Ideal.eq_prime_pow_of_succ_lt_of_le {P I : Ideal A} [P_prime : P.IsPrime] (hP : P ≠ ⊥)\n    {i : ℕ} (hlt : P ^ (i + 1) < I) (hle : I ≤ P ^ i) : I = P ^ i := by\n  refine le_antisymm hle ?_\n  have P_prime' := Ideal.prime_of_isPrime hP P_prime\n  have h1 : I ≠ ⊥ := (lt_of_le_of_lt bot_le hlt).ne'\n  have := pow_ne_zero i hP\n  have h3 := pow_ne_zero (i + 1) hP\n  rw [← Ideal.dvdNotUnit_iff_lt, dvdNotUnit_iff_normalizedFactors_lt_normalizedFactors h1 h3,\n    normalizedFactors_pow, normalizedFactors_irreducible P_prime'.irreducible,\n    Multiset.nsmul_singleton, Multiset.lt_replicate_succ] at hlt\n  rw [← Ideal.dvd_iff_le, dvd_iff_normalizedFactors_le_normalizedFactors, normalizedFactors_pow,\n    normalizedFactors_irreducible P_prime'.irreducible, Multiset.nsmul_singleton]\n  all_goals assumption\n\n"}
{"name":"Ideal.pow_succ_lt_pow","module":"Mathlib.RingTheory.DedekindDomain.Ideal","initialProofState":"A : Type u_2\ninst✝¹ : CommRing A\ninst✝ : IsDedekindDomain A\nP : Ideal A\nP_prime : P.IsPrime\nhP : Ne P Bot.bot\ni : Nat\n⊢ LT.lt (HPow.hPow P (HAdd.hAdd i 1)) (HPow.hPow P i)","decl":"theorem Ideal.pow_succ_lt_pow {P : Ideal A} [P_prime : P.IsPrime] (hP : P ≠ ⊥) (i : ℕ) :\n    P ^ (i + 1) < P ^ i :=\n  lt_of_le_of_ne (Ideal.pow_le_pow_right (Nat.le_succ _))\n    (mt (pow_inj_of_not_isUnit (mt Ideal.isUnit_iff.mp P_prime.ne_top) hP).mp i.succ_ne_self)\n\n"}
{"name":"Associates.le_singleton_iff","module":"Mathlib.RingTheory.DedekindDomain.Ideal","initialProofState":"A : Type u_2\ninst✝¹ : CommRing A\ninst✝ : IsDedekindDomain A\nx : A\nn : Nat\nI : Ideal A\n⊢ Iff (LE.le (HPow.hPow (Associates.mk I) n) (Associates.mk (Ideal.span (Singleton.singleton x)))) (Membership.mem (HPow.hPow I n) x)","decl":"theorem Associates.le_singleton_iff (x : A) (n : ℕ) (I : Ideal A) :\n    Associates.mk I ^ n ≤ Associates.mk (Ideal.span {x}) ↔ x ∈ I ^ n := by\n  simp_rw [← Associates.dvd_eq_le, ← Associates.mk_pow, Associates.mk_dvd_mk,\n    Ideal.dvd_span_singleton]\n\n"}
{"name":"FractionalIdeal.le_inv_comm","module":"Mathlib.RingTheory.DedekindDomain.Ideal","initialProofState":"A : Type u_2\nK : Type u_3\ninst✝⁴ : CommRing A\ninst✝³ : Field K\ninst✝² : IsDedekindDomain A\ninst✝¹ : Algebra A K\ninst✝ : IsFractionRing A K\nI J : FractionalIdeal (nonZeroDivisors A) K\nhI : Ne I 0\nhJ : Ne J 0\n⊢ Iff (LE.le I (Inv.inv J)) (LE.le J (Inv.inv I))","decl":"lemma FractionalIdeal.le_inv_comm {I J : FractionalIdeal A⁰ K} (hI : I ≠ 0) (hJ : J ≠ 0) :\n    I ≤ J⁻¹ ↔ J ≤ I⁻¹ := by\n  rw [inv_eq, inv_eq, le_div_iff_mul_le hI, le_div_iff_mul_le hJ, mul_comm]\n\n"}
{"name":"FractionalIdeal.inv_le_comm","module":"Mathlib.RingTheory.DedekindDomain.Ideal","initialProofState":"A : Type u_2\nK : Type u_3\ninst✝⁴ : CommRing A\ninst✝³ : Field K\ninst✝² : IsDedekindDomain A\ninst✝¹ : Algebra A K\ninst✝ : IsFractionRing A K\nI J : FractionalIdeal (nonZeroDivisors A) K\nhI : Ne I 0\nhJ : Ne J 0\n⊢ Iff (LE.le (Inv.inv I) J) (LE.le (Inv.inv J) I)","decl":"lemma FractionalIdeal.inv_le_comm {I J : FractionalIdeal A⁰ K} (hI : I ≠ 0) (hJ : J ≠ 0) :\n    I⁻¹ ≤ J ↔ J⁻¹ ≤ I := by\n  simpa using le_inv_comm (A := A) (K := K) (inv_ne_zero hI) (inv_ne_zero hJ)\n\n"}
{"name":"Ideal.exist_integer_multiples_not_mem","module":"Mathlib.RingTheory.DedekindDomain.Ideal","initialProofState":"A : Type u_2\nK : Type u_3\ninst✝⁴ : CommRing A\ninst✝³ : Field K\ninst✝² : IsDedekindDomain A\ninst✝¹ : Algebra A K\ninst✝ : IsFractionRing A K\nJ : Ideal A\nhJ : Ne J Top.top\nι : Type u_4\ns : Finset ι\nf : ι → K\nj : ι\nhjs : Membership.mem s j\nhjf : Ne (f j) 0\n⊢ Exists fun a => And (∀ (i : ι), Membership.mem s i → IsLocalization.IsInteger A (HMul.hMul a (f i))) (Exists fun i => And (Membership.mem s i) (Not (Membership.mem (↑J) (HMul.hMul a (f i)))))","decl":"/-- Strengthening of `IsLocalization.exist_integer_multiples`:\nLet `J ≠ ⊤` be an ideal in a Dedekind domain `A`, and `f ≠ 0` a finite collection\nof elements of `K = Frac(A)`, then we can multiply the elements of `f` by some `a : K`\nto find a collection of elements of `A` that is not completely contained in `J`. -/\ntheorem Ideal.exist_integer_multiples_not_mem {J : Ideal A} (hJ : J ≠ ⊤) {ι : Type*} (s : Finset ι)\n    (f : ι → K) {j} (hjs : j ∈ s) (hjf : f j ≠ 0) :\n    ∃ a : K,\n      (∀ i ∈ s, IsLocalization.IsInteger A (a * f i)) ∧\n        ∃ i ∈ s, a * f i ∉ (J : FractionalIdeal A⁰ K) := by\n  -- Consider the fractional ideal `I` spanned by the `f`s.\n  let I : FractionalIdeal A⁰ K := spanFinset A s f\n  have hI0 : I ≠ 0 := spanFinset_ne_zero.mpr ⟨j, hjs, hjf⟩\n  -- We claim the multiplier `a` we're looking for is in `I⁻¹ \\ (J / I)`.\n  suffices ↑J / I < I⁻¹ by\n    obtain ⟨_, a, hI, hpI⟩ := SetLike.lt_iff_le_and_exists.mp this\n    rw [mem_inv_iff hI0] at hI\n    refine ⟨a, fun i hi => ?_, ?_⟩\n    -- By definition, `a ∈ I⁻¹` multiplies elements of `I` into elements of `1`,\n    -- in other words, `a * f i` is an integer.\n    · exact (mem_one_iff _).mp (hI (f i) (Submodule.subset_span (Set.mem_image_of_mem f hi)))\n    · contrapose! hpI\n      -- And if all `a`-multiples of `I` are an element of `J`,\n      -- then `a` is actually an element of `J / I`, contradiction.\n      refine (mem_div_iff_of_nonzero hI0).mpr fun y hy => Submodule.span_induction ?_ ?_ ?_ ?_ hy\n      · rintro _ ⟨i, hi, rfl⟩; exact hpI i hi\n      · rw [mul_zero]; exact Submodule.zero_mem _\n      · intro x y _ _ hx hy; rw [mul_add]; exact Submodule.add_mem _ hx hy\n      · intro b x _ hx; rw [mul_smul_comm]; exact Submodule.smul_mem _ b hx\n  -- To show the inclusion of `J / I` into `I⁻¹ = 1 / I`, note that `J < I`.\n  calc\n    ↑J / I = ↑J * I⁻¹ := div_eq_mul_inv (↑J) I\n    _ < 1 * I⁻¹ := mul_right_strictMono (inv_ne_zero hI0) ?_\n    _ = I⁻¹ := one_mul _\n  rw [← coeIdeal_top]\n  -- And multiplying by `I⁻¹` is indeed strictly monotone.\n  exact\n    strictMono_of_le_iff_le (fun _ _ => (coeIdeal_le_coeIdeal K).symm)\n      (lt_top_iff_ne_top.mpr hJ)\n\n"}
{"name":"Ideal.sup_mul_inf","module":"Mathlib.RingTheory.DedekindDomain.Ideal","initialProofState":"A : Type u_2\ninst✝¹ : CommRing A\ninst✝ : IsDedekindDomain A\nI J : Ideal A\n⊢ Eq (HMul.hMul (Max.max I J) (Min.min I J)) (HMul.hMul I J)","decl":"@[simp]\ntheorem sup_mul_inf (I J : Ideal A) : (I ⊔ J) * (I ⊓ J) = I * J := by\n  letI := UniqueFactorizationMonoid.toNormalizedGCDMonoid (Ideal A)\n  have hgcd : gcd I J = I ⊔ J := by\n    rw [gcd_eq_normalize _ _, normalize_eq]\n    · rw [dvd_iff_le, sup_le_iff, ← dvd_iff_le, ← dvd_iff_le]\n      exact ⟨gcd_dvd_left _ _, gcd_dvd_right _ _⟩\n    · rw [dvd_gcd_iff, dvd_iff_le, dvd_iff_le]\n      simp\n  have hlcm : lcm I J = I ⊓ J := by\n    rw [lcm_eq_normalize _ _, normalize_eq]\n    · rw [lcm_dvd_iff, dvd_iff_le, dvd_iff_le]\n      simp\n    · rw [dvd_iff_le, le_inf_iff, ← dvd_iff_le, ← dvd_iff_le]\n      exact ⟨dvd_lcm_left _ _, dvd_lcm_right _ _⟩\n  rw [← hgcd, ← hlcm, associated_iff_eq.mp (gcd_mul_lcm _ _)]\n\n"}
{"name":"Ideal.gcd_eq_sup","module":"Mathlib.RingTheory.DedekindDomain.Ideal","initialProofState":"A : Type u_2\ninst✝¹ : CommRing A\ninst✝ : IsDedekindDomain A\nI J : Ideal A\n⊢ Eq (GCDMonoid.gcd I J) (Max.max I J)","decl":"@[simp]\ntheorem gcd_eq_sup (I J : Ideal A) : gcd I J = I ⊔ J := rfl\n\n"}
{"name":"Ideal.lcm_eq_inf","module":"Mathlib.RingTheory.DedekindDomain.Ideal","initialProofState":"A : Type u_2\ninst✝¹ : CommRing A\ninst✝ : IsDedekindDomain A\nI J : Ideal A\n⊢ Eq (GCDMonoid.lcm I J) (Min.min I J)","decl":"@[simp]\ntheorem lcm_eq_inf (I J : Ideal A) : lcm I J = I ⊓ J := rfl\n\n"}
{"name":"Ideal.isCoprime_iff_gcd","module":"Mathlib.RingTheory.DedekindDomain.Ideal","initialProofState":"A : Type u_2\ninst✝¹ : CommRing A\ninst✝ : IsDedekindDomain A\nI J : Ideal A\n⊢ Iff (IsCoprime I J) (Eq (GCDMonoid.gcd I J) 1)","decl":"theorem isCoprime_iff_gcd {I J : Ideal A} : IsCoprime I J ↔ gcd I J = 1 := by\n  rw [Ideal.isCoprime_iff_codisjoint, codisjoint_iff, one_eq_top, gcd_eq_sup]\n\n"}
{"name":"Ideal.factors_span_eq","module":"Mathlib.RingTheory.DedekindDomain.Ideal","initialProofState":"K : Type u_3\ninst✝ : Field K\np : Polynomial K\n⊢ Eq (UniqueFactorizationMonoid.factors (Ideal.span (Singleton.singleton p))) (Multiset.map (fun q => Ideal.span (Singleton.singleton q)) (UniqueFactorizationMonoid.factors p))","decl":"theorem factors_span_eq {p : K[X]} : factors (span {p}) = (factors p).map (fun q ↦ span {q}) := by\n  rcases eq_or_ne p 0 with rfl | hp; · simpa [Set.singleton_zero] using normalizedFactors_zero\n  have : ∀ q ∈ (factors p).map (fun q ↦ span {q}), Prime q := fun q hq ↦ by\n    obtain ⟨r, hr, rfl⟩ := Multiset.mem_map.mp hq\n    exact prime_span_singleton_iff.mpr <| prime_of_factor r hr\n  rw [← span_singleton_eq_span_singleton.mpr (factors_prod hp), ← multiset_prod_span_singleton,\n    factors_eq_normalizedFactors, normalizedFactors_prod_of_prime this]\n\n"}
{"name":"prod_normalizedFactors_eq_self","module":"Mathlib.RingTheory.DedekindDomain.Ideal","initialProofState":"T : Type u_4\ninst✝¹ : CommRing T\ninst✝ : IsDedekindDomain T\nI : Ideal T\nhI : Ne I Bot.bot\n⊢ Eq (UniqueFactorizationMonoid.normalizedFactors I).prod I","decl":"theorem prod_normalizedFactors_eq_self (hI : I ≠ ⊥) : (normalizedFactors I).prod = I :=\n  associated_iff_eq.1 (prod_normalizedFactors hI)\n\n"}
{"name":"count_le_of_ideal_ge","module":"Mathlib.RingTheory.DedekindDomain.Ideal","initialProofState":"T : Type u_4\ninst✝² : CommRing T\ninst✝¹ : IsDedekindDomain T\ninst✝ : DecidableEq (Ideal T)\nI J : Ideal T\nh : LE.le I J\nhI : Ne I Bot.bot\nK : Ideal T\n⊢ LE.le (Multiset.count K (UniqueFactorizationMonoid.normalizedFactors J)) (Multiset.count K (UniqueFactorizationMonoid.normalizedFactors I))","decl":"theorem count_le_of_ideal_ge [DecidableEq (Ideal T)]\n    {I J : Ideal T} (h : I ≤ J) (hI : I ≠ ⊥) (K : Ideal T) :\n    count K (normalizedFactors J) ≤ count K (normalizedFactors I) :=\n  le_iff_count.1 ((dvd_iff_normalizedFactors_le_normalizedFactors (ne_bot_of_le_ne_bot hI h) hI).1\n    (dvd_iff_le.2 h))\n    _\n\n"}
{"name":"sup_eq_prod_inf_factors","module":"Mathlib.RingTheory.DedekindDomain.Ideal","initialProofState":"T : Type u_4\ninst✝² : CommRing T\ninst✝¹ : IsDedekindDomain T\nI J : Ideal T\ninst✝ : DecidableEq (Ideal T)\nhI : Ne I Bot.bot\nhJ : Ne J Bot.bot\n⊢ Eq (Max.max I J) (Inter.inter (UniqueFactorizationMonoid.normalizedFactors I) (UniqueFactorizationMonoid.normalizedFactors J)).prod","decl":"theorem sup_eq_prod_inf_factors [DecidableEq (Ideal T)] (hI : I ≠ ⊥) (hJ : J ≠ ⊥) :\n    I ⊔ J = (normalizedFactors I ∩ normalizedFactors J).prod := by\n  have H : normalizedFactors (normalizedFactors I ∩ normalizedFactors J).prod =\n      normalizedFactors I ∩ normalizedFactors J := by\n    apply normalizedFactors_prod_of_prime\n    intro p hp\n    rw [mem_inter] at hp\n    exact prime_of_normalized_factor p hp.left\n  have := Multiset.prod_ne_zero_of_prime (normalizedFactors I ∩ normalizedFactors J) fun _ h =>\n      prime_of_normalized_factor _ (Multiset.mem_inter.1 h).1\n  apply le_antisymm\n  · rw [sup_le_iff, ← dvd_iff_le, ← dvd_iff_le]\n    constructor\n    · rw [dvd_iff_normalizedFactors_le_normalizedFactors this hI, H]\n      exact inf_le_left\n    · rw [dvd_iff_normalizedFactors_le_normalizedFactors this hJ, H]\n      exact inf_le_right\n  · rw [← dvd_iff_le, dvd_iff_normalizedFactors_le_normalizedFactors,\n      normalizedFactors_prod_of_prime, le_iff_count]\n    · intro a\n      rw [Multiset.count_inter]\n      exact le_min (count_le_of_ideal_ge le_sup_left hI a) (count_le_of_ideal_ge le_sup_right hJ a)\n    · intro p hp\n      rw [mem_inter] at hp\n      exact prime_of_normalized_factor p hp.left\n    · exact ne_bot_of_le_ne_bot hI le_sup_left\n    · exact this\n\n"}
{"name":"irreducible_pow_sup","module":"Mathlib.RingTheory.DedekindDomain.Ideal","initialProofState":"T : Type u_4\ninst✝² : CommRing T\ninst✝¹ : IsDedekindDomain T\nI J : Ideal T\ninst✝ : DecidableEq (Ideal T)\nhI : Ne I Bot.bot\nhJ : Irreducible J\nn : Nat\n⊢ Eq (Max.max (HPow.hPow J n) I) (HPow.hPow J (Min.min (Multiset.count J (UniqueFactorizationMonoid.normalizedFactors I)) n))","decl":"theorem irreducible_pow_sup [DecidableEq (Ideal T)] (hI : I ≠ ⊥) (hJ : Irreducible J) (n : ℕ) :\n    J ^ n ⊔ I = J ^ min ((normalizedFactors I).count J) n := by\n  rw [sup_eq_prod_inf_factors (pow_ne_zero n hJ.ne_zero) hI, min_comm,\n    normalizedFactors_of_irreducible_pow hJ, normalize_eq J, replicate_inter, prod_replicate]\n\n"}
{"name":"irreducible_pow_sup_of_le","module":"Mathlib.RingTheory.DedekindDomain.Ideal","initialProofState":"T : Type u_4\ninst✝¹ : CommRing T\ninst✝ : IsDedekindDomain T\nI J : Ideal T\nhJ : Irreducible J\nn : Nat\nhn : LE.le (↑n) (emultiplicity J I)\n⊢ Eq (Max.max (HPow.hPow J n) I) (HPow.hPow J n)","decl":"theorem irreducible_pow_sup_of_le (hJ : Irreducible J) (n : ℕ) (hn : n ≤ emultiplicity J I) :\n    J ^ n ⊔ I = J ^ n := by\n  classical\n  by_cases hI : I = ⊥\n  · simp_all\n  rw [irreducible_pow_sup hI hJ, min_eq_right]\n  rw [emultiplicity_eq_count_normalizedFactors hJ hI, normalize_eq J] at hn\n  exact_mod_cast hn\n\n"}
{"name":"irreducible_pow_sup_of_ge","module":"Mathlib.RingTheory.DedekindDomain.Ideal","initialProofState":"T : Type u_4\ninst✝¹ : CommRing T\ninst✝ : IsDedekindDomain T\nI J : Ideal T\nhI : Ne I Bot.bot\nhJ : Irreducible J\nn : Nat\nhn : LE.le (emultiplicity J I) ↑n\n⊢ Eq (Max.max (HPow.hPow J n) I) (HPow.hPow J (multiplicity J I))","decl":"theorem irreducible_pow_sup_of_ge (hI : I ≠ ⊥) (hJ : Irreducible J) (n : ℕ)\n    (hn : emultiplicity J I ≤ n) : J ^ n ⊔ I = J ^ multiplicity J I := by\n  classical\n  rw [irreducible_pow_sup hI hJ, min_eq_left]\n  · congr\n    rw [← Nat.cast_inj (R := ℕ∞), ← FiniteMultiplicity.emultiplicity_eq_multiplicity,\n      emultiplicity_eq_count_normalizedFactors hJ hI, normalize_eq J]\n    rw [← emultiplicity_lt_top]\n    apply hn.trans_lt\n    simp\n  · rw [emultiplicity_eq_count_normalizedFactors hJ hI, normalize_eq J] at hn\n    exact_mod_cast hn\n\n"}
{"name":"Ideal.eq_prime_pow_mul_coprime","module":"Mathlib.RingTheory.DedekindDomain.Ideal","initialProofState":"T : Type u_4\ninst✝² : CommRing T\ninst✝¹ : IsDedekindDomain T\ninst✝ : DecidableEq (Ideal T)\nI : Ideal T\nhI : Ne I Bot.bot\nP : Ideal T\nhpm : P.IsMaximal\n⊢ Exists fun Q => And (Eq (Max.max P Q) Top.top) (Eq I (HMul.hMul (HPow.hPow P (Multiset.count P (UniqueFactorizationMonoid.normalizedFactors I))) Q))","decl":"theorem Ideal.eq_prime_pow_mul_coprime [DecidableEq (Ideal T)] {I : Ideal T} (hI : I ≠ ⊥)\n    (P : Ideal T) [hpm : P.IsMaximal] :\n    ∃ Q : Ideal T, P ⊔ Q = ⊤ ∧ I = P ^ (Multiset.count P (normalizedFactors I)) * Q := by\n  use (filter (¬ P = ·) (normalizedFactors I)).prod\n  constructor\n  · refine P.sup_multiset_prod_eq_top (fun p hpi ↦ ?_)\n    have hp : Prime p := prime_of_normalized_factor p (filter_subset _ (normalizedFactors I) hpi)\n    exact hpm.coprime_of_ne ((isPrime_of_prime hp).isMaximal hp.ne_zero) (of_mem_filter hpi)\n  · nth_rw 1 [← prod_normalizedFactors_eq_self hI, ← filter_add_not (P = ·) (normalizedFactors I)]\n    rw [prod_add, pow_count]\n\n"}
{"name":"IsDedekindDomain.HeightOneSpectrum.ext","module":"Mathlib.RingTheory.DedekindDomain.Ideal","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nx y : IsDedekindDomain.HeightOneSpectrum R\nasIdeal : Eq x.asIdeal y.asIdeal\n⊢ Eq x y","decl":"/-- The height one prime spectrum of a Dedekind domain `R` is the type of nonzero prime ideals of\n`R`. Note that this equals the maximal spectrum if `R` has Krull dimension 1. -/\n@[ext, nolint unusedArguments]\nstructure HeightOneSpectrum where\n  asIdeal : Ideal R\n  isPrime : asIdeal.IsPrime\n  ne_bot : asIdeal ≠ ⊥\n\n"}
{"name":"IsDedekindDomain.HeightOneSpectrum.ne_bot","module":"Mathlib.RingTheory.DedekindDomain.Ideal","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nself : IsDedekindDomain.HeightOneSpectrum R\n⊢ Ne self.asIdeal Bot.bot","decl":"/-- The height one prime spectrum of a Dedekind domain `R` is the type of nonzero prime ideals of\n`R`. Note that this equals the maximal spectrum if `R` has Krull dimension 1. -/\n@[ext, nolint unusedArguments]\nstructure HeightOneSpectrum where\n  asIdeal : Ideal R\n  isPrime : asIdeal.IsPrime\n  ne_bot : asIdeal ≠ ⊥\n\n"}
{"name":"IsDedekindDomain.HeightOneSpectrum.ext_iff","module":"Mathlib.RingTheory.DedekindDomain.Ideal","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nx y : IsDedekindDomain.HeightOneSpectrum R\n⊢ Iff (Eq x y) (Eq x.asIdeal y.asIdeal)","decl":"/-- The height one prime spectrum of a Dedekind domain `R` is the type of nonzero prime ideals of\n`R`. Note that this equals the maximal spectrum if `R` has Krull dimension 1. -/\n@[ext, nolint unusedArguments]\nstructure HeightOneSpectrum where\n  asIdeal : Ideal R\n  isPrime : asIdeal.IsPrime\n  ne_bot : asIdeal ≠ ⊥\n\n"}
{"name":"IsDedekindDomain.HeightOneSpectrum.mk.sizeOf_spec","module":"Mathlib.RingTheory.DedekindDomain.Ideal","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\ninst✝ : SizeOf R\nasIdeal : Ideal R\nisPrime : asIdeal.IsPrime\nne_bot : Ne asIdeal Bot.bot\n⊢ Eq (SizeOf.sizeOf { asIdeal := asIdeal, isPrime := isPrime, ne_bot := ne_bot }) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf asIdeal)) (SizeOf.sizeOf isPrime))","decl":"/-- The height one prime spectrum of a Dedekind domain `R` is the type of nonzero prime ideals of\n`R`. Note that this equals the maximal spectrum if `R` has Krull dimension 1. -/\n@[ext, nolint unusedArguments]\nstructure HeightOneSpectrum where\n  asIdeal : Ideal R\n  isPrime : asIdeal.IsPrime\n  ne_bot : asIdeal ≠ ⊥\n\n"}
{"name":"IsDedekindDomain.HeightOneSpectrum.isPrime","module":"Mathlib.RingTheory.DedekindDomain.Ideal","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nself : IsDedekindDomain.HeightOneSpectrum R\n⊢ self.asIdeal.IsPrime","decl":"/-- The height one prime spectrum of a Dedekind domain `R` is the type of nonzero prime ideals of\n`R`. Note that this equals the maximal spectrum if `R` has Krull dimension 1. -/\n@[ext, nolint unusedArguments]\nstructure HeightOneSpectrum where\n  asIdeal : Ideal R\n  isPrime : asIdeal.IsPrime\n  ne_bot : asIdeal ≠ ⊥\n\n"}
{"name":"IsDedekindDomain.HeightOneSpectrum.mk.injEq","module":"Mathlib.RingTheory.DedekindDomain.Ideal","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nasIdeal✝ : Ideal R\nisPrime✝ : asIdeal✝.IsPrime\nne_bot✝ : Ne asIdeal✝ Bot.bot\nasIdeal : Ideal R\nisPrime : asIdeal.IsPrime\nne_bot : Ne asIdeal Bot.bot\n⊢ Eq (Eq { asIdeal := asIdeal✝, isPrime := isPrime✝, ne_bot := ne_bot✝ } { asIdeal := asIdeal, isPrime := isPrime, ne_bot := ne_bot }) (Eq asIdeal✝ asIdeal)","decl":"/-- The height one prime spectrum of a Dedekind domain `R` is the type of nonzero prime ideals of\n`R`. Note that this equals the maximal spectrum if `R` has Krull dimension 1. -/\n@[ext, nolint unusedArguments]\nstructure HeightOneSpectrum where\n  asIdeal : Ideal R\n  isPrime : asIdeal.IsPrime\n  ne_bot : asIdeal ≠ ⊥\n\n"}
{"name":"IsDedekindDomain.HeightOneSpectrum.mk.inj","module":"Mathlib.RingTheory.DedekindDomain.Ideal","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nasIdeal✝ : Ideal R\nisPrime✝ : asIdeal✝.IsPrime\nne_bot✝ : Ne asIdeal✝ Bot.bot\nasIdeal : Ideal R\nisPrime : asIdeal.IsPrime\nne_bot : Ne asIdeal Bot.bot\nx✝ : Eq { asIdeal := asIdeal✝, isPrime := isPrime✝, ne_bot := ne_bot✝ } { asIdeal := asIdeal, isPrime := isPrime, ne_bot := ne_bot }\n⊢ Eq asIdeal✝ asIdeal","decl":"/-- The height one prime spectrum of a Dedekind domain `R` is the type of nonzero prime ideals of\n`R`. Note that this equals the maximal spectrum if `R` has Krull dimension 1. -/\n@[ext, nolint unusedArguments]\nstructure HeightOneSpectrum where\n  asIdeal : Ideal R\n  isPrime : asIdeal.IsPrime\n  ne_bot : asIdeal ≠ ⊥\n\n"}
{"name":"IsDedekindDomain.HeightOneSpectrum.isMaximal","module":"Mathlib.RingTheory.DedekindDomain.Ideal","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\ninst✝ : IsDedekindDomain R\nv : IsDedekindDomain.HeightOneSpectrum R\n⊢ v.asIdeal.IsMaximal","decl":"instance isMaximal : v.asIdeal.IsMaximal := v.isPrime.isMaximal v.ne_bot\n\n"}
{"name":"IsDedekindDomain.HeightOneSpectrum.prime","module":"Mathlib.RingTheory.DedekindDomain.Ideal","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\ninst✝ : IsDedekindDomain R\nv : IsDedekindDomain.HeightOneSpectrum R\n⊢ Prime v.asIdeal","decl":"theorem prime : Prime v.asIdeal := Ideal.prime_of_isPrime v.ne_bot v.isPrime\n\n"}
{"name":"IsDedekindDomain.HeightOneSpectrum.irreducible","module":"Mathlib.RingTheory.DedekindDomain.Ideal","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\ninst✝ : IsDedekindDomain R\nv : IsDedekindDomain.HeightOneSpectrum R\n⊢ Irreducible v.asIdeal","decl":"theorem irreducible : Irreducible v.asIdeal :=\n  UniqueFactorizationMonoid.irreducible_iff_prime.mpr v.prime\n\n"}
{"name":"IsDedekindDomain.HeightOneSpectrum.associates_irreducible","module":"Mathlib.RingTheory.DedekindDomain.Ideal","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\ninst✝ : IsDedekindDomain R\nv : IsDedekindDomain.HeightOneSpectrum R\n⊢ Irreducible (Associates.mk v.asIdeal)","decl":"theorem associates_irreducible : Irreducible <| Associates.mk v.asIdeal :=\n  Associates.irreducible_mk.mpr v.irreducible\n\n"}
{"name":"IsDedekindDomain.HeightOneSpectrum.iInf_localization_eq_bot","module":"Mathlib.RingTheory.DedekindDomain.Ideal","initialProofState":"R : Type u_1\nK : Type u_3\ninst✝³ : CommRing R\ninst✝² : Field K\ninst✝¹ : IsDedekindDomain R\ninst✝ : Algebra R K\nhK : IsFractionRing R K\n⊢ Eq (iInf fun v => Localization.subalgebra.ofField K v.asIdeal.primeCompl ⋯) Bot.bot","decl":"/-- A Dedekind domain is equal to the intersection of its localizations at all its height one\nnon-zero prime ideals viewed as subalgebras of its field of fractions. -/\ntheorem iInf_localization_eq_bot [Algebra R K] [hK : IsFractionRing R K] :\n    (⨅ v : HeightOneSpectrum R,\n        Localization.subalgebra.ofField K _ v.asIdeal.primeCompl_le_nonZeroDivisors) = ⊥ := by\n  ext x\n  rw [Algebra.mem_iInf]\n  constructor\n  on_goal 1 => by_cases hR : IsField R\n  · rcases Function.bijective_iff_has_inverse.mp\n      (IsField.localization_map_bijective (Rₘ := K) (flip nonZeroDivisors.ne_zero rfl : 0 ∉ R⁰) hR)\n      with ⟨algebra_map_inv, _, algebra_map_right_inv⟩\n    exact fun _ => Algebra.mem_bot.mpr ⟨algebra_map_inv x, algebra_map_right_inv x⟩\n  all_goals rw [← MaximalSpectrum.iInf_localization_eq_bot, Algebra.mem_iInf]\n  · exact fun hx ⟨v, hv⟩ => hx ((equivMaximalSpectrum hR).symm ⟨v, hv⟩)\n  · exact fun hx ⟨v, hv, hbot⟩ => hx ⟨v, hv.isMaximal hbot⟩\n\n"}
{"name":"idealFactorsFunOfQuotHom_coe_coe","module":"Mathlib.RingTheory.DedekindDomain.Ideal","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝¹ : CommRing R\ninst✝ : CommRing A\nI : Ideal R\nJ : Ideal A\nf : RingHom (HasQuotient.Quotient R I) (HasQuotient.Quotient A J)\nhf : Function.Surjective ⇑f\nX : Subtype fun p => Dvd.dvd p I\n⊢ Eq (↑((idealFactorsFunOfQuotHom hf) X)) (Ideal.comap (Ideal.Quotient.mk J) (Ideal.map f (Ideal.map (Ideal.Quotient.mk I) ↑X)))","decl":"/-- The map from ideals of `R` dividing `I` to the ideals of `A` dividing `J` induced by\n  a homomorphism `f : R/I →+* A/J` -/\n@[simps] -- Porting note: use `Subtype` instead of `Set` to make linter happy\ndef idealFactorsFunOfQuotHom {f : R ⧸ I →+* A ⧸ J} (hf : Function.Surjective f) :\n    {p : Ideal R // p ∣ I} →o {p : Ideal A // p ∣ J} where\n  toFun X := ⟨comap (Ideal.Quotient.mk J) (map f (map (Ideal.Quotient.mk I) X)), by\n    have : RingHom.ker (Ideal.Quotient.mk J) ≤\n        comap (Ideal.Quotient.mk J) (map f (map (Ideal.Quotient.mk I) X)) :=\n      ker_le_comap (Ideal.Quotient.mk J)\n    rw [mk_ker] at this\n    exact dvd_iff_le.mpr this⟩\n  monotone' := by\n    rintro ⟨X, hX⟩ ⟨Y, hY⟩ h\n    rw [← Subtype.coe_le_coe, Subtype.coe_mk, Subtype.coe_mk] at h ⊢\n    rw [Subtype.coe_mk, comap_le_comap_iff_of_surjective (Ideal.Quotient.mk J)\n      Ideal.Quotient.mk_surjective, map_le_iff_le_comap, Subtype.coe_mk,\n      comap_map_of_surjective _ hf (map (Ideal.Quotient.mk I) Y)]\n    suffices map (Ideal.Quotient.mk I) X ≤ map (Ideal.Quotient.mk I) Y by\n      exact le_sup_of_le_left this\n    rwa [map_le_iff_le_comap, comap_map_of_surjective (Ideal.Quotient.mk I)\n      Ideal.Quotient.mk_surjective, ← RingHom.ker_eq_comap_bot, mk_ker,\n      sup_eq_left.mpr <| le_of_dvd hY]\n\n"}
{"name":"idealFactorsFunOfQuotHom_id","module":"Mathlib.RingTheory.DedekindDomain.Ideal","initialProofState":"A : Type u_2\ninst✝¹ : CommRing A\ninst✝ : IsDedekindDomain A\nJ : Ideal A\n⊢ Eq (idealFactorsFunOfQuotHom ⋯) OrderHom.id","decl":"@[simp]\ntheorem idealFactorsFunOfQuotHom_id :\n    idealFactorsFunOfQuotHom (RingHom.id (A ⧸ J)).surjective = OrderHom.id :=\n  OrderHom.ext _ _\n    (funext fun X => by\n      simp only [idealFactorsFunOfQuotHom, map_id, OrderHom.coe_mk, OrderHom.id_coe, id,\n        comap_map_of_surjective (Ideal.Quotient.mk J) Ideal.Quotient.mk_surjective, ←\n        RingHom.ker_eq_comap_bot (Ideal.Quotient.mk J), mk_ker,\n        sup_eq_left.mpr (dvd_iff_le.mp X.prop), Subtype.coe_eta])\n\n"}
{"name":"idealFactorsFunOfQuotHom_comp","module":"Mathlib.RingTheory.DedekindDomain.Ideal","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝⁴ : CommRing R\ninst✝³ : CommRing A\ninst✝² : IsDedekindDomain A\nI : Ideal R\nJ : Ideal A\nB : Type u_4\ninst✝¹ : CommRing B\ninst✝ : IsDedekindDomain B\nL : Ideal B\nf : RingHom (HasQuotient.Quotient R I) (HasQuotient.Quotient A J)\ng : RingHom (HasQuotient.Quotient A J) (HasQuotient.Quotient B L)\nhf : Function.Surjective ⇑f\nhg : Function.Surjective ⇑g\n⊢ Eq ((idealFactorsFunOfQuotHom hg).comp (idealFactorsFunOfQuotHom hf)) (idealFactorsFunOfQuotHom ⋯)","decl":"theorem idealFactorsFunOfQuotHom_comp {f : R ⧸ I →+* A ⧸ J} {g : A ⧸ J →+* B ⧸ L}\n    (hf : Function.Surjective f) (hg : Function.Surjective g) :\n    (idealFactorsFunOfQuotHom hg).comp (idealFactorsFunOfQuotHom hf) =\n      idealFactorsFunOfQuotHom (show Function.Surjective (g.comp f) from hg.comp hf) := by\n  refine OrderHom.ext _ _ (funext fun x => ?_)\n  rw [idealFactorsFunOfQuotHom, idealFactorsFunOfQuotHom, OrderHom.comp_coe, OrderHom.coe_mk,\n    OrderHom.coe_mk, Function.comp_apply, idealFactorsFunOfQuotHom, OrderHom.coe_mk,\n    Subtype.mk_eq_mk, Subtype.coe_mk, map_comap_of_surjective (Ideal.Quotient.mk J)\n    Ideal.Quotient.mk_surjective, map_map]\n\n"}
{"name":"idealFactorsEquivOfQuotEquiv_symm","module":"Mathlib.RingTheory.DedekindDomain.Ideal","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝³ : CommRing R\ninst✝² : CommRing A\ninst✝¹ : IsDedekindDomain A\nI : Ideal R\nJ : Ideal A\ninst✝ : IsDedekindDomain R\nf : RingEquiv (HasQuotient.Quotient R I) (HasQuotient.Quotient A J)\n⊢ Eq (idealFactorsEquivOfQuotEquiv f).symm (idealFactorsEquivOfQuotEquiv f.symm)","decl":"theorem idealFactorsEquivOfQuotEquiv_symm :\n    (idealFactorsEquivOfQuotEquiv f).symm = idealFactorsEquivOfQuotEquiv f.symm := rfl\n\n"}
{"name":"idealFactorsEquivOfQuotEquiv_is_dvd_iso","module":"Mathlib.RingTheory.DedekindDomain.Ideal","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝³ : CommRing R\ninst✝² : CommRing A\ninst✝¹ : IsDedekindDomain A\nI : Ideal R\nJ : Ideal A\ninst✝ : IsDedekindDomain R\nf : RingEquiv (HasQuotient.Quotient R I) (HasQuotient.Quotient A J)\nL M : Ideal R\nhL : Dvd.dvd L I\nhM : Dvd.dvd M I\n⊢ Iff (Dvd.dvd ↑((idealFactorsEquivOfQuotEquiv f) ⟨L, hL⟩) ↑((idealFactorsEquivOfQuotEquiv f) ⟨M, hM⟩)) (Dvd.dvd L M)","decl":"theorem idealFactorsEquivOfQuotEquiv_is_dvd_iso {L M : Ideal R} (hL : L ∣ I) (hM : M ∣ I) :\n    (idealFactorsEquivOfQuotEquiv f ⟨L, hL⟩ : Ideal A) ∣ idealFactorsEquivOfQuotEquiv f ⟨M, hM⟩ ↔\n      L ∣ M := by\n  suffices\n    idealFactorsEquivOfQuotEquiv f ⟨M, hM⟩ ≤ idealFactorsEquivOfQuotEquiv f ⟨L, hL⟩ ↔\n      (⟨M, hM⟩ : { p : Ideal R | p ∣ I }) ≤ ⟨L, hL⟩\n    by rw [dvd_iff_le, dvd_iff_le, Subtype.coe_le_coe, this, Subtype.mk_le_mk]\n  exact (idealFactorsEquivOfQuotEquiv f).le_iff_le\n\n"}
{"name":"idealFactorsEquivOfQuotEquiv_mem_normalizedFactors_of_mem_normalizedFactors","module":"Mathlib.RingTheory.DedekindDomain.Ideal","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝³ : CommRing R\ninst✝² : CommRing A\ninst✝¹ : IsDedekindDomain A\nI : Ideal R\nJ : Ideal A\ninst✝ : IsDedekindDomain R\nf : RingEquiv (HasQuotient.Quotient R I) (HasQuotient.Quotient A J)\nhJ : Ne J Bot.bot\nL : Ideal R\nhL : Membership.mem (UniqueFactorizationMonoid.normalizedFactors I) L\n⊢ Membership.mem (UniqueFactorizationMonoid.normalizedFactors J) ↑((idealFactorsEquivOfQuotEquiv f) ⟨L, ⋯⟩)","decl":"theorem idealFactorsEquivOfQuotEquiv_mem_normalizedFactors_of_mem_normalizedFactors (hJ : J ≠ ⊥)\n    {L : Ideal R} (hL : L ∈ normalizedFactors I) :\n    ↑(idealFactorsEquivOfQuotEquiv f ⟨L, dvd_of_mem_normalizedFactors hL⟩)\n      ∈ normalizedFactors J := by\n  have hI : I ≠ ⊥ := by\n    intro hI\n    rw [hI, bot_eq_zero, normalizedFactors_zero, ← Multiset.empty_eq_zero] at hL\n    exact Finset.not_mem_empty _ hL\n  refine mem_normalizedFactors_factor_dvd_iso_of_mem_normalizedFactors hI hJ hL\n    (d := (idealFactorsEquivOfQuotEquiv f).toEquiv) ?_\n  rintro ⟨l, hl⟩ ⟨l', hl'⟩\n  rw [Subtype.coe_mk, Subtype.coe_mk]\n  apply idealFactorsEquivOfQuotEquiv_is_dvd_iso f\n\n"}
{"name":"normalizedFactorsEquivOfQuotEquiv_symm","module":"Mathlib.RingTheory.DedekindDomain.Ideal","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝³ : CommRing R\ninst✝² : CommRing A\ninst✝¹ : IsDedekindDomain A\nI : Ideal R\nJ : Ideal A\ninst✝ : IsDedekindDomain R\nf : RingEquiv (HasQuotient.Quotient R I) (HasQuotient.Quotient A J)\nhI : Ne I Bot.bot\nhJ : Ne J Bot.bot\n⊢ Eq (normalizedFactorsEquivOfQuotEquiv f hI hJ).symm (normalizedFactorsEquivOfQuotEquiv f.symm hJ hI)","decl":"@[simp]\ntheorem normalizedFactorsEquivOfQuotEquiv_symm (hI : I ≠ ⊥) (hJ : J ≠ ⊥) :\n    (normalizedFactorsEquivOfQuotEquiv f hI hJ).symm =\n      normalizedFactorsEquivOfQuotEquiv f.symm hJ hI := rfl\n\n"}
{"name":"normalizedFactorsEquivOfQuotEquiv_emultiplicity_eq_emultiplicity","module":"Mathlib.RingTheory.DedekindDomain.Ideal","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝³ : CommRing R\ninst✝² : CommRing A\ninst✝¹ : IsDedekindDomain A\nI : Ideal R\nJ : Ideal A\ninst✝ : IsDedekindDomain R\nf : RingEquiv (HasQuotient.Quotient R I) (HasQuotient.Quotient A J)\nhI : Ne I Bot.bot\nhJ : Ne J Bot.bot\nL : Ideal R\nhL : Membership.mem (UniqueFactorizationMonoid.normalizedFactors I) L\n⊢ Eq (emultiplicity (↑((normalizedFactorsEquivOfQuotEquiv f hI hJ) ⟨L, hL⟩)) J) (emultiplicity L I)","decl":"/-- The map `normalizedFactorsEquivOfQuotEquiv` preserves multiplicities. -/\ntheorem normalizedFactorsEquivOfQuotEquiv_emultiplicity_eq_emultiplicity (hI : I ≠ ⊥) (hJ : J ≠ ⊥)\n    (L : Ideal R) (hL : L ∈ normalizedFactors I) :\n    emultiplicity (↑(normalizedFactorsEquivOfQuotEquiv f hI hJ ⟨L, hL⟩)) J = emultiplicity L I := by\n  rw [normalizedFactorsEquivOfQuotEquiv, Equiv.coe_fn_mk, Subtype.coe_mk]\n  refine emultiplicity_factor_dvd_iso_eq_emultiplicity_of_mem_normalizedFactors hI hJ hL\n    (d := (idealFactorsEquivOfQuotEquiv f).toEquiv) ?_\n  exact fun ⟨l, hl⟩ ⟨l', hl'⟩ => idealFactorsEquivOfQuotEquiv_is_dvd_iso f hl hl'\n\n"}
{"name":"Ring.DimensionLeOne.prime_le_prime_iff_eq","module":"Mathlib.RingTheory.DedekindDomain.Ideal","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\ninst✝ : Ring.DimensionLEOne R\nP Q : Ideal R\nhP : P.IsPrime\nhQ : Q.IsPrime\nhP0 : Ne P Bot.bot\n⊢ Iff (LE.le P Q) (Eq P Q)","decl":"theorem Ring.DimensionLeOne.prime_le_prime_iff_eq [Ring.DimensionLEOne R] {P Q : Ideal R}\n    [hP : P.IsPrime] [hQ : Q.IsPrime] (hP0 : P ≠ ⊥) : P ≤ Q ↔ P = Q :=\n  ⟨(hP.isMaximal hP0).eq_of_le hQ.ne_top, Eq.le⟩\n\n"}
{"name":"Ideal.coprime_of_no_prime_ge","module":"Mathlib.RingTheory.DedekindDomain.Ideal","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nI J : Ideal R\nh : ∀ (P : Ideal R), LE.le I P → LE.le J P → Not P.IsPrime\n⊢ IsCoprime I J","decl":"theorem Ideal.coprime_of_no_prime_ge {I J : Ideal R} (h : ∀ P, I ≤ P → J ≤ P → ¬IsPrime P) :\n    IsCoprime I J := by\n  rw [isCoprime_iff_sup_eq]\n  by_contra hIJ\n  obtain ⟨P, hP, hIJ⟩ := Ideal.exists_le_maximal _ hIJ\n  exact h P (le_trans le_sup_left hIJ) (le_trans le_sup_right hIJ) hP.isPrime\n\n"}
{"name":"Ideal.IsPrime.mul_mem_pow","module":"Mathlib.RingTheory.DedekindDomain.Ideal","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\ninst✝ : IsDedekindDomain R\nI : Ideal R\nhI : I.IsPrime\na b : R\nn : Nat\nh : Membership.mem (HPow.hPow I n) (HMul.hMul a b)\n⊢ Or (Membership.mem I a) (Membership.mem (HPow.hPow I n) b)","decl":"theorem Ideal.IsPrime.mul_mem_pow (I : Ideal R) [hI : I.IsPrime] {a b : R} {n : ℕ}\n    (h : a * b ∈ I ^ n) : a ∈ I ∨ b ∈ I ^ n := by\n  cases n; · simp\n  by_cases hI0 : I = ⊥; · simpa [pow_succ, hI0] using h\n  simp only [← Submodule.span_singleton_le_iff_mem, Ideal.submodule_span_eq, ← Ideal.dvd_iff_le, ←\n    Ideal.span_singleton_mul_span_singleton] at h ⊢\n  by_cases ha : I ∣ span {a}\n  · exact Or.inl ha\n  rw [mul_comm] at h\n  exact Or.inr (Prime.pow_dvd_of_dvd_mul_right ((Ideal.prime_iff_isPrime hI0).mpr hI) _ ha h)\n\n"}
{"name":"Ideal.IsPrime.mem_pow_mul","module":"Mathlib.RingTheory.DedekindDomain.Ideal","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\ninst✝ : IsDedekindDomain R\nI : Ideal R\nhI : I.IsPrime\na b : R\nn : Nat\nh : Membership.mem (HPow.hPow I n) (HMul.hMul a b)\n⊢ Or (Membership.mem (HPow.hPow I n) a) (Membership.mem I b)","decl":"theorem Ideal.IsPrime.mem_pow_mul (I : Ideal R) [hI : I.IsPrime] {a b : R} {n : ℕ}\n    (h : a * b ∈ I ^ n) : a ∈ I ^ n ∨ b ∈ I := by\n  rw [mul_comm] at h\n  rw [or_comm]\n  exact Ideal.IsPrime.mul_mem_pow _ h\n\n"}
{"name":"Ideal.count_normalizedFactors_eq","module":"Mathlib.RingTheory.DedekindDomain.Ideal","initialProofState":"R : Type u_1\ninst✝² : CommRing R\ninst✝¹ : IsDedekindDomain R\np x : Ideal R\nhp : p.IsPrime\nn : Nat\nhle : LE.le x (HPow.hPow p n)\ninst✝ : DecidableEq (Ideal R)\nhlt : Not (LE.le x (HPow.hPow p (HAdd.hAdd n 1)))\n⊢ Eq (Multiset.count p (UniqueFactorizationMonoid.normalizedFactors x)) n","decl":"theorem Ideal.count_normalizedFactors_eq {p x : Ideal R} [hp : p.IsPrime] {n : ℕ} (hle : x ≤ p ^ n)\n    [DecidableEq (Ideal R)] (hlt : ¬x ≤ p ^ (n + 1)) : (normalizedFactors x).count p = n :=\n  count_normalizedFactors_eq' ((Ideal.isPrime_iff_bot_or_prime.mp hp).imp_right Prime.irreducible)\n    (normalize_eq _) (Ideal.dvd_iff_le.mpr hle) (mt Ideal.le_of_dvd hlt)\n\n"}
{"name":"count_associates_factors_eq","module":"Mathlib.RingTheory.DedekindDomain.Ideal","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\ninst✝³ : IsDedekindDomain R\ninst✝² : DecidableEq (Ideal R)\ninst✝¹ : DecidableEq (Associates (Ideal R))\ninst✝ : (p : Associates (Ideal R)) → Decidable (Irreducible p)\nI J : Ideal R\nhI : Ne I 0\nhJ : J.IsPrime\nhJ₀ : Ne J Bot.bot\n⊢ Eq ((Associates.mk J).count (Associates.mk I).factors) (Multiset.count J (UniqueFactorizationMonoid.normalizedFactors I))","decl":"/-- The number of times an ideal `I` occurs as normalized factor of another ideal `J` is stable\n  when regarding at these ideals as associated elements of the monoid of ideals.-/\ntheorem count_associates_factors_eq [DecidableEq (Ideal R)] [DecidableEq <| Associates (Ideal R)]\n    [∀ (p : Associates <| Ideal R), Decidable (Irreducible p)]\n    {I J : Ideal R} (hI : I ≠ 0) (hJ : J.IsPrime) (hJ₀ : J ≠ ⊥) :\n    (Associates.mk J).count (Associates.mk I).factors = Multiset.count J (normalizedFactors I) := by\n  replace hI : Associates.mk I ≠ 0 := Associates.mk_ne_zero.mpr hI\n  have hJ' : Irreducible (Associates.mk J) := by\n    simpa only [Associates.irreducible_mk] using (Ideal.prime_of_isPrime hJ₀ hJ).irreducible\n  apply (Ideal.count_normalizedFactors_eq (p := J) (x := I) _ _).symm\n  all_goals\n    rw [← Ideal.dvd_iff_le, ← Associates.mk_dvd_mk, Associates.mk_pow]\n    simp only [Associates.dvd_eq_le]\n    rw [Associates.prime_pow_dvd_iff_le hI hJ']\n  omega\n\n"}
{"name":"Ideal.le_mul_of_no_prime_factors","module":"Mathlib.RingTheory.DedekindDomain.Ideal","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\ninst✝ : IsDedekindDomain R\nI J K : Ideal R\ncoprime : ∀ (P : Ideal R), LE.le J P → LE.le K P → Not P.IsPrime\nhJ : LE.le I J\nhK : LE.le I K\n⊢ LE.le I (HMul.hMul J K)","decl":"theorem Ideal.le_mul_of_no_prime_factors {I J K : Ideal R}\n    (coprime : ∀ P, J ≤ P → K ≤ P → ¬IsPrime P) (hJ : I ≤ J) (hK : I ≤ K) : I ≤ J * K := by\n  simp only [← Ideal.dvd_iff_le] at coprime hJ hK ⊢\n  by_cases hJ0 : J = 0\n  · simpa only [hJ0, zero_mul] using hJ\n  obtain ⟨I', rfl⟩ := hK\n  rw [mul_comm]\n  refine mul_dvd_mul_left K\n    (UniqueFactorizationMonoid.dvd_of_dvd_mul_right_of_no_prime_factors (b := K) hJ0 ?_ hJ)\n  exact fun hPJ hPK => mt Ideal.isPrime_of_prime (coprime _ hPJ hPK)\n\n"}
{"name":"IsDedekindDomain.inf_prime_pow_eq_prod","module":"Mathlib.RingTheory.DedekindDomain.Ideal","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\ninst✝ : IsDedekindDomain R\nι : Type u_4\ns : Finset ι\nf : ι → Ideal R\ne : ι → Nat\nprime : ∀ (i : ι), Membership.mem s i → Prime (f i)\ncoprime : ∀ (i : ι), Membership.mem s i → ∀ (j : ι), Membership.mem s j → Ne i j → Ne (f i) (f j)\n⊢ Eq (s.inf fun i => HPow.hPow (f i) (e i)) (s.prod fun i => HPow.hPow (f i) (e i))","decl":"/-- The intersection of distinct prime powers in a Dedekind domain is the product of these\nprime powers. -/\ntheorem IsDedekindDomain.inf_prime_pow_eq_prod {ι : Type*} (s : Finset ι) (f : ι → Ideal R)\n    (e : ι → ℕ) (prime : ∀ i ∈ s, Prime (f i))\n    (coprime : ∀ᵉ (i ∈ s) (j ∈ s), i ≠ j → f i ≠ f j) :\n    (s.inf fun i => f i ^ e i) = ∏ i ∈ s, f i ^ e i := by\n  letI := Classical.decEq ι\n  revert prime coprime\n  refine s.induction ?_ ?_\n  · simp\n  intro a s ha ih prime coprime\n  specialize\n    ih (fun i hi => prime i (Finset.mem_insert_of_mem hi)) fun i hi j hj =>\n      coprime i (Finset.mem_insert_of_mem hi) j (Finset.mem_insert_of_mem hj)\n  rw [Finset.inf_insert, Finset.prod_insert ha, ih]\n  refine le_antisymm (Ideal.le_mul_of_no_prime_factors ?_ inf_le_left inf_le_right) Ideal.mul_le_inf\n  intro P hPa hPs hPp\n  obtain ⟨b, hb, hPb⟩ := hPp.prod_le.mp hPs\n  haveI := Ideal.isPrime_of_prime (prime a (Finset.mem_insert_self a s))\n  haveI := Ideal.isPrime_of_prime (prime b (Finset.mem_insert_of_mem hb))\n  refine coprime a (Finset.mem_insert_self a s) b (Finset.mem_insert_of_mem hb) ?_ ?_\n  · exact (ne_of_mem_of_not_mem hb ha).symm\n  · refine ((Ring.DimensionLeOne.prime_le_prime_iff_eq ?_).mp (hPp.le_of_pow_le hPa)).trans\n      ((Ring.DimensionLeOne.prime_le_prime_iff_eq ?_).mp (hPp.le_of_pow_le hPb)).symm\n    · exact (prime a (Finset.mem_insert_self a s)).ne_zero\n    · exact (prime b (Finset.mem_insert_of_mem hb)).ne_zero\n\n"}
{"name":"IsDedekindDomain.quotientEquivPiFactors_mk","module":"Mathlib.RingTheory.DedekindDomain.Ideal","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\ninst✝ : IsDedekindDomain R\nI : Ideal R\nhI : Ne I Bot.bot\nx : R\n⊢ Eq ((IsDedekindDomain.quotientEquivPiFactors hI) ((Ideal.Quotient.mk I) x)) fun _P => (Ideal.Quotient.mk (HPow.hPow (↑_P) (Multiset.count (↑_P) (UniqueFactorizationMonoid.factors I)))) x","decl":"@[simp]\ntheorem IsDedekindDomain.quotientEquivPiFactors_mk {I : Ideal R} (hI : I ≠ ⊥) (x : R) :\n    IsDedekindDomain.quotientEquivPiFactors hI (Ideal.Quotient.mk I x) = fun _P =>\n      Ideal.Quotient.mk _ x := rfl\n\n"}
{"name":"IsDedekindDomain.exists_representative_mod_finset","module":"Mathlib.RingTheory.DedekindDomain.Ideal","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\ninst✝ : IsDedekindDomain R\nι : Type u_4\ns : Finset ι\nP : ι → Ideal R\ne : ι → Nat\nprime : ∀ (i : ι), Membership.mem s i → Prime (P i)\ncoprime : ∀ (i : ι), Membership.mem s i → ∀ (j : ι), Membership.mem s j → Ne i j → Ne (P i) (P j)\nx : (i : Subtype fun x => Membership.mem s x) → HasQuotient.Quotient R (HPow.hPow (P ↑i) (e ↑i))\n⊢ Exists fun y => ∀ (i : ι) (hi : Membership.mem s i), Eq ((Ideal.Quotient.mk (HPow.hPow (P i) (e i))) y) (x ⟨i, hi⟩)","decl":"/-- Corollary of the Chinese remainder theorem: given elements `x i : R / P i ^ e i`,\nwe can choose a representative `y : R` such that `y ≡ x i (mod P i ^ e i)`. -/\ntheorem IsDedekindDomain.exists_representative_mod_finset {ι : Type*} {s : Finset ι}\n    (P : ι → Ideal R) (e : ι → ℕ) (prime : ∀ i ∈ s, Prime (P i))\n    (coprime : ∀ᵉ (i ∈ s) (j ∈ s), i ≠ j → P i ≠ P j) (x : ∀ i : s, R ⧸ P i ^ e i) :\n    ∃ y, ∀ (i) (hi : i ∈ s), Ideal.Quotient.mk (P i ^ e i) y = x ⟨i, hi⟩ := by\n  let f := IsDedekindDomain.quotientEquivPiOfFinsetProdEq _ P e prime coprime rfl\n  obtain ⟨y, rfl⟩ := f.surjective x\n  obtain ⟨z, rfl⟩ := Ideal.Quotient.mk_surjective y\n  exact ⟨z, fun i _hi => rfl⟩\n\n"}
{"name":"IsDedekindDomain.exists_forall_sub_mem_ideal","module":"Mathlib.RingTheory.DedekindDomain.Ideal","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\ninst✝ : IsDedekindDomain R\nι : Type u_4\ns : Finset ι\nP : ι → Ideal R\ne : ι → Nat\nprime : ∀ (i : ι), Membership.mem s i → Prime (P i)\ncoprime : ∀ (i : ι), Membership.mem s i → ∀ (j : ι), Membership.mem s j → Ne i j → Ne (P i) (P j)\nx : (Subtype fun x => Membership.mem s x) → R\n⊢ Exists fun y => ∀ (i : ι) (hi : Membership.mem s i), Membership.mem (HPow.hPow (P i) (e i)) (HSub.hSub y (x ⟨i, hi⟩))","decl":"/-- Corollary of the Chinese remainder theorem: given elements `x i : R`,\nwe can choose a representative `y : R` such that `y - x i ∈ P i ^ e i`. -/\ntheorem IsDedekindDomain.exists_forall_sub_mem_ideal {ι : Type*} {s : Finset ι} (P : ι → Ideal R)\n    (e : ι → ℕ) (prime : ∀ i ∈ s, Prime (P i))\n    (coprime : ∀ᵉ (i ∈ s) (j ∈ s), i ≠ j → P i ≠ P j) (x : s → R) :\n    ∃ y, ∀ (i) (hi : i ∈ s), y - x ⟨i, hi⟩ ∈ P i ^ e i := by\n  obtain ⟨y, hy⟩ :=\n    IsDedekindDomain.exists_representative_mod_finset P e prime coprime fun i =>\n      Ideal.Quotient.mk _ (x i)\n  exact ⟨y, fun i hi => Ideal.Quotient.eq.mp (hy i hi)⟩\n\n"}
{"name":"span_singleton_dvd_span_singleton_iff_dvd","module":"Mathlib.RingTheory.DedekindDomain.Ideal","initialProofState":"R : Type u_1\ninst✝² : CommRing R\ninst✝¹ : IsDomain R\ninst✝ : IsPrincipalIdealRing R\na b : R\n⊢ Iff (Dvd.dvd (Ideal.span (Singleton.singleton a)) (Ideal.span (Singleton.singleton b))) (Dvd.dvd a b)","decl":"theorem span_singleton_dvd_span_singleton_iff_dvd {a b : R} :\n    Ideal.span {a} ∣ Ideal.span ({b} : Set R) ↔ a ∣ b :=\n  ⟨fun h => mem_span_singleton.mp (dvd_iff_le.mp h (mem_span_singleton.mpr (dvd_refl b))), fun h =>\n    dvd_iff_le.mpr fun _d hd => mem_span_singleton.mpr (dvd_trans h (mem_span_singleton.mp hd))⟩\n\n"}
{"name":"Ideal.squarefree_span_singleton","module":"Mathlib.RingTheory.DedekindDomain.Ideal","initialProofState":"R : Type u_1\ninst✝² : CommRing R\ninst✝¹ : IsDomain R\ninst✝ : IsPrincipalIdealRing R\na : R\n⊢ Iff (Squarefree (Ideal.span (Singleton.singleton a))) (Squarefree a)","decl":"@[simp]\ntheorem Ideal.squarefree_span_singleton {a : R} :\n    Squarefree (span {a}) ↔ Squarefree a := by\n  refine ⟨fun h x hx ↦ ?_, fun h I hI ↦ ?_⟩\n  · rw [← span_singleton_dvd_span_singleton_iff_dvd, ← span_singleton_mul_span_singleton] at hx\n    simpa using h _ hx\n  · rw [← span_singleton_generator I, span_singleton_mul_span_singleton,\n      span_singleton_dvd_span_singleton_iff_dvd] at hI\n    exact isUnit_iff.mpr <| eq_top_of_isUnit_mem _ (Submodule.IsPrincipal.generator_mem I) (h _ hI)\n\n"}
{"name":"singleton_span_mem_normalizedFactors_of_mem_normalizedFactors","module":"Mathlib.RingTheory.DedekindDomain.Ideal","initialProofState":"R : Type u_1\ninst✝³ : CommRing R\ninst✝² : IsDomain R\ninst✝¹ : IsPrincipalIdealRing R\ninst✝ : NormalizationMonoid R\na b : R\nha : Membership.mem (UniqueFactorizationMonoid.normalizedFactors b) a\n⊢ Membership.mem (UniqueFactorizationMonoid.normalizedFactors (Ideal.span (Singleton.singleton b))) (Ideal.span (Singleton.singleton a))","decl":"theorem singleton_span_mem_normalizedFactors_of_mem_normalizedFactors [NormalizationMonoid R]\n    {a b : R} (ha : a ∈ normalizedFactors b) :\n    Ideal.span ({a} : Set R) ∈ normalizedFactors (Ideal.span ({b} : Set R)) := by\n  by_cases hb : b = 0\n  · rw [Ideal.span_singleton_eq_bot.mpr hb, bot_eq_zero, normalizedFactors_zero]\n    rw [hb, normalizedFactors_zero] at ha\n    exact absurd ha (Multiset.not_mem_zero a)\n  · suffices Prime (Ideal.span ({a} : Set R)) by\n      obtain ⟨c, hc, hc'⟩ := exists_mem_normalizedFactors_of_dvd ?_ this.irreducible\n          (dvd_iff_le.mpr (span_singleton_le_span_singleton.mpr (dvd_of_mem_normalizedFactors ha)))\n      rwa [associated_iff_eq.mp hc']\n    · by_contra h\n      exact hb (span_singleton_eq_bot.mp h)\n    rw [prime_iff_isPrime]\n    · exact (span_singleton_prime (prime_of_normalized_factor a ha).ne_zero).mpr\n        (prime_of_normalized_factor a ha)\n    · by_contra h\n      exact (prime_of_normalized_factor a ha).ne_zero (span_singleton_eq_bot.mp h)\n\n"}
{"name":"emultiplicity_eq_emultiplicity_span","module":"Mathlib.RingTheory.DedekindDomain.Ideal","initialProofState":"R : Type u_1\ninst✝² : CommRing R\ninst✝¹ : IsDomain R\ninst✝ : IsPrincipalIdealRing R\na b : R\n⊢ Eq (emultiplicity (Ideal.span (Singleton.singleton a)) (Ideal.span (Singleton.singleton b))) (emultiplicity a b)","decl":"theorem emultiplicity_eq_emultiplicity_span {a b : R} :\n    emultiplicity (Ideal.span {a}) (Ideal.span ({b} : Set R)) = emultiplicity a b := by\n  by_cases h : FiniteMultiplicity a b\n  · rw [h.emultiplicity_eq_multiplicity]\n    apply emultiplicity_eq_of_dvd_of_not_dvd <;>\n      rw [Ideal.span_singleton_pow, span_singleton_dvd_span_singleton_iff_dvd]\n    · exact pow_multiplicity_dvd a b\n    · apply h.not_pow_dvd_of_multiplicity_lt\n      apply lt_add_one\n  · suffices ¬FiniteMultiplicity (Ideal.span ({a} : Set R)) (Ideal.span ({b} : Set R)) by\n      rw [emultiplicity_eq_top.2 h, emultiplicity_eq_top.2 this]\n    exact FiniteMultiplicity.not_iff_forall.mpr fun n => by\n      rw [Ideal.span_singleton_pow, span_singleton_dvd_span_singleton_iff_dvd]\n      exact FiniteMultiplicity.not_iff_forall.mp h n\n\n"}
{"name":"emultiplicity_normalizedFactorsEquivSpanNormalizedFactors_eq_emultiplicity","module":"Mathlib.RingTheory.DedekindDomain.Ideal","initialProofState":"R : Type u_1\ninst✝³ : CommRing R\ninst✝² : IsDomain R\ninst✝¹ : IsPrincipalIdealRing R\ninst✝ : NormalizationMonoid R\nr d : R\nhr : Ne r 0\nhd : Membership.mem (UniqueFactorizationMonoid.normalizedFactors r) d\n⊢ Eq (emultiplicity d r) (emultiplicity (↑((normalizedFactorsEquivSpanNormalizedFactors hr) ⟨d, hd⟩)) (Ideal.span (Singleton.singleton r)))","decl":"/-- The bijection `normalizedFactorsEquivSpanNormalizedFactors` between the set of prime\n    factors of `r` and the set of prime factors of the ideal `⟨r⟩` preserves multiplicities. See\n    `count_normalizedFactorsSpan_eq_count` for the version stated in terms of multisets `count`.-/\ntheorem emultiplicity_normalizedFactorsEquivSpanNormalizedFactors_eq_emultiplicity {r d : R}\n    (hr : r ≠ 0) (hd : d ∈ normalizedFactors r) :\n    emultiplicity d r =\n      emultiplicity (normalizedFactorsEquivSpanNormalizedFactors hr ⟨d, hd⟩ : Ideal R)\n        (Ideal.span {r}) := by\n  simp only [normalizedFactorsEquivSpanNormalizedFactors, emultiplicity_eq_emultiplicity_span,\n    Subtype.coe_mk, Equiv.ofBijective_apply]\n\n"}
{"name":"emultiplicity_normalizedFactorsEquivSpanNormalizedFactors_symm_eq_emultiplicity","module":"Mathlib.RingTheory.DedekindDomain.Ideal","initialProofState":"R : Type u_1\ninst✝³ : CommRing R\ninst✝² : IsDomain R\ninst✝¹ : IsPrincipalIdealRing R\ninst✝ : NormalizationMonoid R\nr : R\nhr : Ne r 0\nI : ↑(setOf fun I => Membership.mem (UniqueFactorizationMonoid.normalizedFactors (Ideal.span (Singleton.singleton r))) I)\n⊢ Eq (emultiplicity (↑((normalizedFactorsEquivSpanNormalizedFactors hr).symm I)) r) (emultiplicity (↑I) (Ideal.span (Singleton.singleton r)))","decl":"/-- The bijection `normalized_factors_equiv_span_normalized_factors.symm` between the set of prime\n    factors of the ideal `⟨r⟩` and the set of prime factors of `r` preserves multiplicities. -/\ntheorem emultiplicity_normalizedFactorsEquivSpanNormalizedFactors_symm_eq_emultiplicity {r : R}\n    (hr : r ≠ 0) (I : { I : Ideal R | I ∈ normalizedFactors (Ideal.span ({r} : Set R)) }) :\n    emultiplicity ((normalizedFactorsEquivSpanNormalizedFactors hr).symm I : R) r =\n      emultiplicity (I : Ideal R) (Ideal.span {r}) := by\n  obtain ⟨x, hx⟩ := (normalizedFactorsEquivSpanNormalizedFactors hr).surjective I\n  obtain ⟨a, ha⟩ := x\n  rw [hx.symm, Equiv.symm_apply_apply, Subtype.coe_mk,\n    emultiplicity_normalizedFactorsEquivSpanNormalizedFactors_eq_emultiplicity hr ha]\n\n"}
{"name":"count_span_normalizedFactors_eq","module":"Mathlib.RingTheory.DedekindDomain.Ideal","initialProofState":"R : Type u_1\ninst✝⁵ : CommRing R\ninst✝⁴ : IsDomain R\ninst✝³ : IsPrincipalIdealRing R\ninst✝² : NormalizationMonoid R\ninst✝¹ : DecidableEq R\ninst✝ : DecidableEq (Ideal R)\nr X : R\nhr : Ne r 0\nhX : Prime X\n⊢ Eq (Multiset.count (Ideal.span (Singleton.singleton X)) (UniqueFactorizationMonoid.normalizedFactors (Ideal.span (Singleton.singleton r)))) (Multiset.count (normalize X) (UniqueFactorizationMonoid.normalizedFactors r))","decl":"/-- The bijection between the set of prime factors of the ideal `⟨r⟩` and the set of prime factors\n  of `r` preserves `count` of the corresponding multisets. See\n  `multiplicity_normalizedFactorsEquivSpanNormalizedFactors_eq_multiplicity` for the version\n  stated in terms of multiplicity. -/\ntheorem count_span_normalizedFactors_eq {r X : R} (hr : r ≠ 0) (hX : Prime X) :\n    Multiset.count (Ideal.span {X} : Ideal R) (normalizedFactors (Ideal.span {r}))  =\n        Multiset.count (normalize X) (normalizedFactors r) := by\n  have := emultiplicity_eq_emultiplicity_span (R := R) (a := X) (b := r)\n  rw [emultiplicity_eq_count_normalizedFactors (Prime.irreducible hX) hr,\n    emultiplicity_eq_count_normalizedFactors (Prime.irreducible ?_), normalize_apply,\n    normUnit_eq_one, Units.val_one, one_eq_top, mul_top, Nat.cast_inj] at this\n  · simp only [normalize_apply, this]\n  · simp only [Submodule.zero_eq_bot, ne_eq, span_singleton_eq_bot, hr, not_false_eq_true]\n  · simpa only [prime_span_singleton_iff]\n\n"}
{"name":"count_span_normalizedFactors_eq_of_normUnit","module":"Mathlib.RingTheory.DedekindDomain.Ideal","initialProofState":"R : Type u_1\ninst✝⁵ : CommRing R\ninst✝⁴ : IsDomain R\ninst✝³ : IsPrincipalIdealRing R\ninst✝² : NormalizationMonoid R\ninst✝¹ : DecidableEq R\ninst✝ : DecidableEq (Ideal R)\nr X : R\nhr : Ne r 0\nhX₁ : Eq (NormalizationMonoid.normUnit X) 1\nhX : Prime X\n⊢ Eq (Multiset.count (Ideal.span (Singleton.singleton X)) (UniqueFactorizationMonoid.normalizedFactors (Ideal.span (Singleton.singleton r)))) (Multiset.count X (UniqueFactorizationMonoid.normalizedFactors r))","decl":"theorem count_span_normalizedFactors_eq_of_normUnit {r X : R}\n    (hr : r ≠ 0) (hX₁ : normUnit X = 1) (hX : Prime X) :\n      Multiset.count (Ideal.span {X} : Ideal R) (normalizedFactors (Ideal.span {r})) =\n        Multiset.count X (normalizedFactors r) := by\n  simpa [hX₁, normalize_apply] using count_span_normalizedFactors_eq hr hX\n\n"}
{"name":"coe_primesOverFinset","module":"Mathlib.RingTheory.DedekindDomain.Ideal","initialProofState":"A : Type u_4\ninst✝⁴ : CommRing A\np : Ideal A\nhpb : Ne p Bot.bot\nhpm : p.IsMaximal\nB : Type u_5\ninst✝³ : CommRing B\ninst✝² : IsDedekindDomain B\ninst✝¹ : Algebra A B\ninst✝ : NoZeroSMulDivisors A B\n⊢ Eq (↑(primesOverFinset p B)) (primesOver p B)","decl":"include hpb in\ntheorem coe_primesOverFinset : primesOverFinset p B = primesOver p B := by\n  classical\n  ext P\n  rw [primesOverFinset, factors_eq_normalizedFactors, Finset.mem_coe, Multiset.mem_toFinset]\n  exact (P.mem_normalizedFactors_iff (map_ne_bot_of_ne_bot hpb)).trans <| Iff.intro\n    (fun ⟨hPp, h⟩ => ⟨hPp, ⟨hpm.eq_of_le (comap_ne_top _ hPp.ne_top) (le_comap_of_map_le h)⟩⟩)\n    (fun ⟨hPp, h⟩ => ⟨hPp, map_le_of_le_comap h.1.le⟩)\n\n"}
{"name":"primesOver_finite","module":"Mathlib.RingTheory.DedekindDomain.Ideal","initialProofState":"A : Type u_4\ninst✝⁵ : CommRing A\np : Ideal A\nhpm : p.IsMaximal\nB : Type u_5\ninst✝⁴ : CommRing B\ninst✝³ : IsDedekindDomain B\ninst✝² : Algebra A B\ninst✝¹ : NoZeroSMulDivisors A B\ninst✝ : Algebra.IsIntegral A B\n⊢ (primesOver p B).Finite","decl":"theorem primesOver_finite : (primesOver p B).Finite := by\n  by_cases hpb : p = ⊥\n  · rw [hpb] at hpm ⊢\n    haveI : IsDomain A := IsDomain.of_bot_isPrime A\n    rw [primesOver_bot A B]\n    exact Set.finite_singleton ⊥\n  · rw [← coe_primesOverFinset hpb B]\n    exact (primesOverFinset p B).finite_toSet\n\n"}
{"name":"primesOver_ncard_ne_zero","module":"Mathlib.RingTheory.DedekindDomain.Ideal","initialProofState":"A : Type u_4\ninst✝⁵ : CommRing A\np : Ideal A\nhpm : p.IsMaximal\nB : Type u_5\ninst✝⁴ : CommRing B\ninst✝³ : IsDedekindDomain B\ninst✝² : Algebra A B\ninst✝¹ : NoZeroSMulDivisors A B\ninst✝ : Algebra.IsIntegral A B\n⊢ Ne (primesOver p B).ncard 0","decl":"theorem primesOver_ncard_ne_zero : (primesOver p B).ncard ≠ 0 := by\n  rcases exists_ideal_liesOver_maximal_of_isIntegral p B with ⟨P, hPm, hp⟩\n  exact Set.ncard_ne_zero_of_mem ⟨hPm.isPrime, hp⟩ (primesOver_finite p B)\n\n"}
{"name":"one_le_primesOver_ncard","module":"Mathlib.RingTheory.DedekindDomain.Ideal","initialProofState":"A : Type u_4\ninst✝⁵ : CommRing A\np : Ideal A\nhpm : p.IsMaximal\nB : Type u_5\ninst✝⁴ : CommRing B\ninst✝³ : IsDedekindDomain B\ninst✝² : Algebra A B\ninst✝¹ : NoZeroSMulDivisors A B\ninst✝ : Algebra.IsIntegral A B\n⊢ LE.le 1 (primesOver p B).ncard","decl":"theorem one_le_primesOver_ncard : 1 ≤ (primesOver p B).ncard :=\n  Nat.one_le_iff_ne_zero.mpr (primesOver_ncard_ne_zero p B)\n\n"}
