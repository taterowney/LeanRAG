{"name":"RelHom.map_rel'","module":"Mathlib.Order.RelIso.Basic","initialProofState":"α : Type u_5\nβ : Type u_6\nr : α → α → Prop\ns : β → β → Prop\nself : RelHom r s\na b : α\na✝ : r a b\n⊢ s (self.toFun a) (self.toFun b)","decl":"/-- A relation homomorphism with respect to a given pair of relations `r` and `s`\nis a function `f : α → β` such that `r a b → s (f a) (f b)`. -/\nstructure RelHom {α β : Type*} (r : α → α → Prop) (s : β → β → Prop) where\n  /-- The underlying function of a `RelHom` -/\n  toFun : α → β\n  /-- A `RelHom` sends related elements to related elements -/\n  map_rel' : ∀ {a b}, r a b → s (toFun a) (toFun b)\n\n"}
{"name":"RelHom.mk.sizeOf_spec","module":"Mathlib.Order.RelIso.Basic","initialProofState":"α : Type u_5\nβ : Type u_6\nr : α → α → Prop\ns : β → β → Prop\ninst✝³ : SizeOf α\ninst✝² : SizeOf β\ninst✝¹ : (a a_1 : α) → SizeOf (r a a_1)\ninst✝ : (a a_1 : β) → SizeOf (s a a_1)\ntoFun : α → β\nmap_rel' : ∀ {a b : α}, r a b → s (toFun a) (toFun b)\n⊢ Eq (SizeOf.sizeOf { toFun := toFun, map_rel' := map_rel' }) 1","decl":"/-- A relation homomorphism with respect to a given pair of relations `r` and `s`\nis a function `f : α → β` such that `r a b → s (f a) (f b)`. -/\nstructure RelHom {α β : Type*} (r : α → α → Prop) (s : β → β → Prop) where\n  /-- The underlying function of a `RelHom` -/\n  toFun : α → β\n  /-- A `RelHom` sends related elements to related elements -/\n  map_rel' : ∀ {a b}, r a b → s (toFun a) (toFun b)\n\n"}
{"name":"RelHom.mk.injEq","module":"Mathlib.Order.RelIso.Basic","initialProofState":"α : Type u_5\nβ : Type u_6\nr : α → α → Prop\ns : β → β → Prop\ntoFun✝ : α → β\nmap_rel'✝ : ∀ {a b : α}, r a b → s (toFun✝ a) (toFun✝ b)\ntoFun : α → β\nmap_rel' : ∀ {a b : α}, r a b → s (toFun a) (toFun b)\n⊢ Eq (Eq { toFun := toFun✝, map_rel' := map_rel'✝ } { toFun := toFun, map_rel' := map_rel' }) (Eq toFun✝ toFun)","decl":"/-- A relation homomorphism with respect to a given pair of relations `r` and `s`\nis a function `f : α → β` such that `r a b → s (f a) (f b)`. -/\nstructure RelHom {α β : Type*} (r : α → α → Prop) (s : β → β → Prop) where\n  /-- The underlying function of a `RelHom` -/\n  toFun : α → β\n  /-- A `RelHom` sends related elements to related elements -/\n  map_rel' : ∀ {a b}, r a b → s (toFun a) (toFun b)\n\n"}
{"name":"RelHom.mk.inj","module":"Mathlib.Order.RelIso.Basic","initialProofState":"α : Type u_5\nβ : Type u_6\nr : α → α → Prop\ns : β → β → Prop\ntoFun✝ : α → β\nmap_rel'✝ : ∀ {a b : α}, r a b → s (toFun✝ a) (toFun✝ b)\ntoFun : α → β\nmap_rel' : ∀ {a b : α}, r a b → s (toFun a) (toFun b)\nx✝ : Eq { toFun := toFun✝, map_rel' := map_rel'✝ } { toFun := toFun, map_rel' := map_rel' }\n⊢ Eq toFun✝ toFun","decl":"/-- A relation homomorphism with respect to a given pair of relations `r` and `s`\nis a function `f : α → β` such that `r a b → s (f a) (f b)`. -/\nstructure RelHom {α β : Type*} (r : α → α → Prop) (s : β → β → Prop) where\n  /-- The underlying function of a `RelHom` -/\n  toFun : α → β\n  /-- A `RelHom` sends related elements to related elements -/\n  map_rel' : ∀ {a b}, r a b → s (toFun a) (toFun b)\n\n"}
{"name":"RelHomClass.map_rel","module":"Mathlib.Order.RelIso.Basic","initialProofState":"F : Type u_5\nα : outParam (Type u_6)\nβ : outParam (Type u_7)\nr : outParam (α → α → Prop)\ns : outParam (β → β → Prop)\ninst✝ : FunLike F α β\nself : RelHomClass F r s\nf : F\na b : α\na✝ : r a b\n⊢ s (f a) (f b)","decl":"/-- `RelHomClass F r s` asserts that `F` is a type of functions such that all `f : F`\nsatisfy `r a b → s (f a) (f b)`.\n\nThe relations `r` and `s` are `outParam`s since figuring them out from a goal is a higher-order\nmatching problem that Lean usually can't do unaided.\n-/\nclass RelHomClass (F : Type*) {α β : outParam Type*} (r : outParam <| α → α → Prop)\n  (s : outParam <| β → β → Prop) [FunLike F α β] : Prop where\n  /-- A `RelHomClass` sends related elements to related elements -/\n  map_rel : ∀ (f : F) {a b}, r a b → s (f a) (f b)\n\n"}
{"name":"RelHomClass.isIrrefl","module":"Mathlib.Order.RelIso.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\ns : β → β → Prop\nF : Type u_5\ninst✝² : FunLike F α β\ninst✝¹ : RelHomClass F r s\nf : F\ninst✝ : IsIrrefl β s\n⊢ IsIrrefl α r","decl":"protected theorem isIrrefl [RelHomClass F r s] (f : F) : ∀ [IsIrrefl β s], IsIrrefl α r\n  | ⟨H⟩ => ⟨fun _ h => H _ (map_rel f h)⟩\n\n"}
{"name":"RelHomClass.isAsymm","module":"Mathlib.Order.RelIso.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\ns : β → β → Prop\nF : Type u_5\ninst✝² : FunLike F α β\ninst✝¹ : RelHomClass F r s\nf : F\ninst✝ : IsAsymm β s\n⊢ IsAsymm α r","decl":"protected theorem isAsymm [RelHomClass F r s] (f : F) : ∀ [IsAsymm β s], IsAsymm α r\n  | ⟨H⟩ => ⟨fun _ _ h₁ h₂ => H _ _ (map_rel f h₁) (map_rel f h₂)⟩\n\n"}
{"name":"RelHomClass.acc","module":"Mathlib.Order.RelIso.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\ns : β → β → Prop\nF : Type u_5\ninst✝¹ : FunLike F α β\ninst✝ : RelHomClass F r s\nf : F\na : α\na✝ : Acc s (f a)\n⊢ Acc r a","decl":"protected theorem acc [RelHomClass F r s] (f : F) (a : α) : Acc s (f a) → Acc r a := by\n  generalize h : f a = b\n  intro ac\n  induction ac generalizing a with | intro _ H IH => ?_\n  subst h\n  exact ⟨_, fun a' h => IH (f a') (map_rel f h) _ rfl⟩\n\n"}
{"name":"RelHomClass.wellFounded","module":"Mathlib.Order.RelIso.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\ns : β → β → Prop\nF : Type u_5\ninst✝¹ : FunLike F α β\ninst✝ : RelHomClass F r s\nf : F\na✝ : WellFounded s\n⊢ WellFounded r","decl":"protected theorem wellFounded [RelHomClass F r s] (f : F) : WellFounded s → WellFounded r\n  | ⟨H⟩ => ⟨fun _ => RelHomClass.acc f _ (H _)⟩\n\n"}
{"name":"RelHomClass.isWellFounded","module":"Mathlib.Order.RelIso.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\ns : β → β → Prop\nF : Type u_5\ninst✝² : FunLike F α β\ninst✝¹ : RelHomClass F r s\nf : F\ninst✝ : IsWellFounded β s\n⊢ IsWellFounded α r","decl":"protected theorem isWellFounded [RelHomClass F r s] (f : F) [IsWellFounded β s] :\n    IsWellFounded α r :=\n  ⟨RelHomClass.wellFounded f IsWellFounded.wf⟩\n\n"}
{"name":"RelHom.instRelHomClass","module":"Mathlib.Order.RelIso.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\ns : β → β → Prop\n⊢ RelHomClass (RelHom r s) r s","decl":"instance : RelHomClass (r →r s) r s where\n  map_rel := map_rel'\n\n"}
{"name":"RelHom.map_rel","module":"Mathlib.Order.RelIso.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\ns : β → β → Prop\nf : RelHom r s\na b : α\na✝ : r a b\n⊢ s (f a) (f b)","decl":"protected theorem map_rel (f : r →r s) {a b} : r a b → s (f a) (f b) :=\n  f.map_rel'\n\n"}
{"name":"RelHom.coe_fn_toFun","module":"Mathlib.Order.RelIso.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\ns : β → β → Prop\nf : RelHom r s\n⊢ Eq f.toFun ⇑f","decl":"@[simp]\ntheorem coe_fn_toFun (f : r →r s) : f.toFun = (f : α → β) :=\n  rfl\n\n"}
{"name":"RelHom.coe_fn_injective","module":"Mathlib.Order.RelIso.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\ns : β → β → Prop\n⊢ Function.Injective fun f => ⇑f","decl":"/-- The map `coe_fn : (r →r s) → (α → β)` is injective. -/\ntheorem coe_fn_injective : Injective fun (f : r →r s) => (f : α → β) :=\n  DFunLike.coe_injective\n\n"}
{"name":"RelHom.ext","module":"Mathlib.Order.RelIso.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\ns : β → β → Prop\nf g : RelHom r s\nh : ∀ (x : α), Eq (f x) (g x)\n⊢ Eq f g","decl":"@[ext]\ntheorem ext ⦃f g : r →r s⦄ (h : ∀ x, f x = g x) : f = g :=\n  DFunLike.ext f g h\n\n"}
{"name":"RelHom.ext_iff","module":"Mathlib.Order.RelIso.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\ns : β → β → Prop\nf g : RelHom r s\n⊢ Iff (Eq f g) (∀ (x : α), Eq (f x) (g x))","decl":"@[ext]\ntheorem ext ⦃f g : r →r s⦄ (h : ∀ x, f x = g x) : f = g :=\n  DFunLike.ext f g h\n\n"}
{"name":"RelHom.id_apply","module":"Mathlib.Order.RelIso.Basic","initialProofState":"α : Type u_1\nr : α → α → Prop\nx : α\n⊢ Eq ((RelHom.id r) x) x","decl":"/-- Identity map is a relation homomorphism. -/\n@[refl, simps]\nprotected def id (r : α → α → Prop) : r →r r :=\n  ⟨fun x => x, fun x => x⟩\n\n"}
{"name":"RelHom.comp_apply","module":"Mathlib.Order.RelIso.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nr : α → α → Prop\ns : β → β → Prop\nt : γ → γ → Prop\ng : RelHom s t\nf : RelHom r s\nx : α\n⊢ Eq ((g.comp f) x) (g (f x))","decl":"/-- Composition of two relation homomorphisms is a relation homomorphism. -/\n@[simps]\nprotected def comp (g : s →r t) (f : r →r s) : r →r t :=\n  ⟨fun x => g (f x), fun h => g.2 (f.2 h)⟩\n\n"}
{"name":"injective_of_increasing","module":"Mathlib.Order.RelIso.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\ns : β → β → Prop\ninst✝¹ : IsTrichotomous α r\ninst✝ : IsIrrefl β s\nf : α → β\nhf : ∀ {x y : α}, r x y → s (f x) (f y)\n⊢ Function.Injective f","decl":"/-- An increasing function is injective -/\ntheorem injective_of_increasing (r : α → α → Prop) (s : β → β → Prop) [IsTrichotomous α r]\n    [IsIrrefl β s] (f : α → β) (hf : ∀ {x y}, r x y → s (f x) (f y)) : Injective f := by\n  intro x y hxy\n  rcases trichotomous_of r x y with (h | h | h)\n  · have := hf h\n    rw [hxy] at this\n    exfalso\n    exact irrefl_of s (f y) this\n  · exact h\n  · have := hf h\n    rw [hxy] at this\n    exfalso\n    exact irrefl_of s (f y) this\n\n"}
{"name":"RelHom.injective_of_increasing","module":"Mathlib.Order.RelIso.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\ns : β → β → Prop\ninst✝¹ : IsTrichotomous α r\ninst✝ : IsIrrefl β s\nf : RelHom r s\n⊢ Function.Injective ⇑f","decl":"/-- An increasing function is injective -/\ntheorem RelHom.injective_of_increasing [IsTrichotomous α r] [IsIrrefl β s] (f : r →r s) :\n    Injective f :=\n  _root_.injective_of_increasing r s f f.map_rel\n\n"}
{"name":"Function.Surjective.wellFounded_iff","module":"Mathlib.Order.RelIso.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\ns : β → β → Prop\nf : α → β\nhf : Function.Surjective f\no : ∀ {a b : α}, Iff (r a b) (s (f a) (f b))\n⊢ Iff (WellFounded r) (WellFounded s)","decl":"theorem Function.Surjective.wellFounded_iff {f : α → β} (hf : Surjective f)\n    (o : ∀ {a b}, r a b ↔ s (f a) (f b)) :\n    WellFounded r ↔ WellFounded s :=\n  Iff.intro\n    (RelHomClass.wellFounded (⟨surjInv hf,\n      fun h => by simpa only [o, surjInv_eq hf] using h⟩ : s →r r))\n    (RelHomClass.wellFounded (⟨f, o.1⟩ : r →r s))\n\n"}
{"name":"RelEmbedding.map_rel_iff'","module":"Mathlib.Order.RelIso.Basic","initialProofState":"α : Type u_5\nβ : Type u_6\nr : α → α → Prop\ns : β → β → Prop\nself : RelEmbedding r s\na b : α\n⊢ Iff (s (self.toEmbedding a) (self.toEmbedding b)) (r a b)","decl":"/-- A relation embedding with respect to a given pair of relations `r` and `s`\nis an embedding `f : α ↪ β` such that `r a b ↔ s (f a) (f b)`. -/\nstructure RelEmbedding {α β : Type*} (r : α → α → Prop) (s : β → β → Prop) extends α ↪ β where\n  /-- Elements are related iff they are related after apply a `RelEmbedding` -/\n  map_rel_iff' : ∀ {a b}, s (toEmbedding a) (toEmbedding b) ↔ r a b\n\n"}
{"name":"RelEmbedding.mk.inj","module":"Mathlib.Order.RelIso.Basic","initialProofState":"α : Type u_5\nβ : Type u_6\nr : α → α → Prop\ns : β → β → Prop\ntoEmbedding✝ : Function.Embedding α β\nmap_rel_iff'✝ : ∀ {a b : α}, Iff (s (toEmbedding✝ a) (toEmbedding✝ b)) (r a b)\ntoEmbedding : Function.Embedding α β\nmap_rel_iff' : ∀ {a b : α}, Iff (s (toEmbedding a) (toEmbedding b)) (r a b)\nx✝ : Eq { toEmbedding := toEmbedding✝, map_rel_iff' := map_rel_iff'✝ } { toEmbedding := toEmbedding, map_rel_iff' := map_rel_iff' }\n⊢ Eq toEmbedding✝ toEmbedding","decl":"/-- A relation embedding with respect to a given pair of relations `r` and `s`\nis an embedding `f : α ↪ β` such that `r a b ↔ s (f a) (f b)`. -/\nstructure RelEmbedding {α β : Type*} (r : α → α → Prop) (s : β → β → Prop) extends α ↪ β where\n  /-- Elements are related iff they are related after apply a `RelEmbedding` -/\n  map_rel_iff' : ∀ {a b}, s (toEmbedding a) (toEmbedding b) ↔ r a b\n\n"}
{"name":"RelEmbedding.mk.sizeOf_spec","module":"Mathlib.Order.RelIso.Basic","initialProofState":"α : Type u_5\nβ : Type u_6\nr : α → α → Prop\ns : β → β → Prop\ninst✝³ : SizeOf α\ninst✝² : SizeOf β\ninst✝¹ : (a a_1 : α) → SizeOf (r a a_1)\ninst✝ : (a a_1 : β) → SizeOf (s a a_1)\ntoEmbedding : Function.Embedding α β\nmap_rel_iff' : ∀ {a b : α}, Iff (s (toEmbedding a) (toEmbedding b)) (r a b)\n⊢ Eq (SizeOf.sizeOf { toEmbedding := toEmbedding, map_rel_iff' := map_rel_iff' }) (HAdd.hAdd 1 (SizeOf.sizeOf toEmbedding))","decl":"/-- A relation embedding with respect to a given pair of relations `r` and `s`\nis an embedding `f : α ↪ β` such that `r a b ↔ s (f a) (f b)`. -/\nstructure RelEmbedding {α β : Type*} (r : α → α → Prop) (s : β → β → Prop) extends α ↪ β where\n  /-- Elements are related iff they are related after apply a `RelEmbedding` -/\n  map_rel_iff' : ∀ {a b}, s (toEmbedding a) (toEmbedding b) ↔ r a b\n\n"}
{"name":"RelEmbedding.mk.injEq","module":"Mathlib.Order.RelIso.Basic","initialProofState":"α : Type u_5\nβ : Type u_6\nr : α → α → Prop\ns : β → β → Prop\ntoEmbedding✝ : Function.Embedding α β\nmap_rel_iff'✝ : ∀ {a b : α}, Iff (s (toEmbedding✝ a) (toEmbedding✝ b)) (r a b)\ntoEmbedding : Function.Embedding α β\nmap_rel_iff' : ∀ {a b : α}, Iff (s (toEmbedding a) (toEmbedding b)) (r a b)\n⊢ Eq (Eq { toEmbedding := toEmbedding✝, map_rel_iff' := map_rel_iff'✝ } { toEmbedding := toEmbedding, map_rel_iff' := map_rel_iff' }) (Eq toEmbedding✝ toEmbedding)","decl":"/-- A relation embedding with respect to a given pair of relations `r` and `s`\nis an embedding `f : α ↪ β` such that `r a b ↔ s (f a) (f b)`. -/\nstructure RelEmbedding {α β : Type*} (r : α → α → Prop) (s : β → β → Prop) extends α ↪ β where\n  /-- Elements are related iff they are related after apply a `RelEmbedding` -/\n  map_rel_iff' : ∀ {a b}, s (toEmbedding a) (toEmbedding b) ↔ r a b\n\n"}
{"name":"preimage_equivalence","module":"Mathlib.Order.RelIso.Basic","initialProofState":"α : Type u_5\nβ : Type u_6\nf : α → β\ns : β → β → Prop\nhs : Equivalence s\n⊢ Equivalence (Order.Preimage f s)","decl":"theorem preimage_equivalence {α β} (f : α → β) {s : β → β → Prop} (hs : Equivalence s) :\n    Equivalence (f ⁻¹'o s) :=\n  ⟨fun _ => hs.1 _, fun h => hs.2 h, fun h₁ h₂ => hs.3 h₁ h₂⟩\n\n"}
{"name":"RelEmbedding.instRelHomClass","module":"Mathlib.Order.RelIso.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\ns : β → β → Prop\n⊢ RelHomClass (RelEmbedding r s) r s","decl":"instance : RelHomClass (r ↪r s) r s where\n  map_rel f _ _ := Iff.mpr (map_rel_iff' f)\n\n"}
{"name":"RelEmbedding.instEmbeddingLike","module":"Mathlib.Order.RelIso.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\ns : β → β → Prop\n⊢ EmbeddingLike (RelEmbedding r s) α β","decl":"instance : EmbeddingLike (r ↪r s) α β where\n  injective' f := f.inj'\n\n"}
{"name":"RelEmbedding.coe_toEmbedding","module":"Mathlib.Order.RelIso.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\ns : β → β → Prop\nf : RelEmbedding r s\n⊢ Eq ⇑f.toEmbedding ⇑f","decl":"@[simp]\ntheorem coe_toEmbedding {f : r ↪r s} : ((f : r ↪r s).toEmbedding : α → β) = f :=\n  rfl\n\n"}
{"name":"RelEmbedding.coe_toRelHom","module":"Mathlib.Order.RelIso.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\ns : β → β → Prop\nf : RelEmbedding r s\n⊢ Eq ⇑f.toRelHom ⇑f","decl":"@[simp]\ntheorem coe_toRelHom {f : r ↪r s} : ((f : r ↪r s).toRelHom : α → β) = f :=\n  rfl\n\n"}
{"name":"RelEmbedding.toEmbedding_injective","module":"Mathlib.Order.RelIso.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\ns : β → β → Prop\n⊢ Function.Injective RelEmbedding.toEmbedding","decl":"theorem toEmbedding_injective : Injective (toEmbedding : r ↪r s → (α ↪ β)) := by\n  rintro ⟨f, -⟩ ⟨g, -⟩; simp\n\n"}
{"name":"RelEmbedding.toEmbedding_inj","module":"Mathlib.Order.RelIso.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\ns : β → β → Prop\nf g : RelEmbedding r s\n⊢ Iff (Eq f.toEmbedding g.toEmbedding) (Eq f g)","decl":"@[simp]\ntheorem toEmbedding_inj {f g : r ↪r s} : f.toEmbedding = g.toEmbedding ↔ f = g :=\n  toEmbedding_injective.eq_iff\n\n"}
{"name":"RelEmbedding.injective","module":"Mathlib.Order.RelIso.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\ns : β → β → Prop\nf : RelEmbedding r s\n⊢ Function.Injective ⇑f","decl":"theorem injective (f : r ↪r s) : Injective f :=\n  f.inj'\n\n"}
{"name":"RelEmbedding.inj","module":"Mathlib.Order.RelIso.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\ns : β → β → Prop\nf : RelEmbedding r s\na b : α\n⊢ Iff (Eq (f a) (f b)) (Eq a b)","decl":"theorem inj (f : r ↪r s) {a b} : f a = f b ↔ a = b := f.injective.eq_iff\n\n"}
{"name":"RelEmbedding.map_rel_iff","module":"Mathlib.Order.RelIso.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\ns : β → β → Prop\nf : RelEmbedding r s\na b : α\n⊢ Iff (s (f a) (f b)) (r a b)","decl":"theorem map_rel_iff (f : r ↪r s) {a b} : s (f a) (f b) ↔ r a b :=\n  f.map_rel_iff'\n\n"}
{"name":"RelEmbedding.coe_mk","module":"Mathlib.Order.RelIso.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\ns : β → β → Prop\nf : Function.Embedding α β\nh : ∀ {a b : α}, Iff (s (f a) (f b)) (r a b)\n⊢ Eq ⇑{ toEmbedding := f, map_rel_iff' := h } ⇑f","decl":"@[simp]\ntheorem coe_mk {f} {h} : ⇑(⟨f, h⟩ : r ↪r s) = f :=\n  rfl\n\n"}
{"name":"RelEmbedding.coe_fn_injective","module":"Mathlib.Order.RelIso.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\ns : β → β → Prop\n⊢ Function.Injective fun f => ⇑f","decl":"/-- The map `coe_fn : (r ↪r s) → (α → β)` is injective. -/\ntheorem coe_fn_injective : Injective fun f : r ↪r s => (f : α → β) :=\n  DFunLike.coe_injective\n\n"}
{"name":"RelEmbedding.ext","module":"Mathlib.Order.RelIso.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\ns : β → β → Prop\nf g : RelEmbedding r s\nh : ∀ (x : α), Eq (f x) (g x)\n⊢ Eq f g","decl":"@[ext]\ntheorem ext ⦃f g : r ↪r s⦄ (h : ∀ x, f x = g x) : f = g :=\n  DFunLike.ext _ _ h\n\n"}
{"name":"RelEmbedding.ext_iff","module":"Mathlib.Order.RelIso.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\ns : β → β → Prop\nf g : RelEmbedding r s\n⊢ Iff (Eq f g) (∀ (x : α), Eq (f x) (g x))","decl":"@[ext]\ntheorem ext ⦃f g : r ↪r s⦄ (h : ∀ x, f x = g x) : f = g :=\n  DFunLike.ext _ _ h\n\n"}
{"name":"RelEmbedding.refl_apply","module":"Mathlib.Order.RelIso.Basic","initialProofState":"α : Type u_1\nr : α → α → Prop\na : α\n⊢ Eq ((RelEmbedding.refl r) a) a","decl":"/-- Identity map is a relation embedding. -/\n@[refl, simps!]\nprotected def refl (r : α → α → Prop) : r ↪r r :=\n  ⟨Embedding.refl _, Iff.rfl⟩\n\n"}
{"name":"RelEmbedding.trans_apply","module":"Mathlib.Order.RelIso.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nr : α → α → Prop\ns : β → β → Prop\nt : γ → γ → Prop\nf : RelEmbedding r s\ng : RelEmbedding s t\na : α\n⊢ Eq ((f.trans g) a) (g (f a))","decl":"theorem trans_apply (f : r ↪r s) (g : s ↪r t) (a : α) : (f.trans g) a = g (f a) :=\n  rfl\n\n"}
{"name":"RelEmbedding.coe_trans","module":"Mathlib.Order.RelIso.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nr : α → α → Prop\ns : β → β → Prop\nt : γ → γ → Prop\nf : RelEmbedding r s\ng : RelEmbedding s t\n⊢ Eq (⇑(f.trans g)) (Function.comp ⇑g ⇑f)","decl":"@[simp]\ntheorem coe_trans (f : r ↪r s) (g : s ↪r t) : (f.trans g) = g ∘ f :=\n  rfl\n\n"}
{"name":"RelEmbedding.eq_preimage","module":"Mathlib.Order.RelIso.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\ns : β → β → Prop\nf : RelEmbedding r s\n⊢ Eq r (Order.Preimage (⇑f) s)","decl":"theorem eq_preimage (f : r ↪r s) : r = f ⁻¹'o s := by\n  ext a b\n  exact f.map_rel_iff.symm\n\n"}
{"name":"RelEmbedding.isIrrefl","module":"Mathlib.Order.RelIso.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\ns : β → β → Prop\nf : RelEmbedding r s\ninst✝ : IsIrrefl β s\n⊢ IsIrrefl α r","decl":"protected theorem isIrrefl (f : r ↪r s) [IsIrrefl β s] : IsIrrefl α r :=\n  ⟨fun a => mt f.map_rel_iff.2 (irrefl (f a))⟩\n\n"}
{"name":"RelEmbedding.isRefl","module":"Mathlib.Order.RelIso.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\ns : β → β → Prop\nf : RelEmbedding r s\ninst✝ : IsRefl β s\n⊢ IsRefl α r","decl":"protected theorem isRefl (f : r ↪r s) [IsRefl β s] : IsRefl α r :=\n  ⟨fun _ => f.map_rel_iff.1 <| refl _⟩\n\n"}
{"name":"RelEmbedding.isSymm","module":"Mathlib.Order.RelIso.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\ns : β → β → Prop\nf : RelEmbedding r s\ninst✝ : IsSymm β s\n⊢ IsSymm α r","decl":"protected theorem isSymm (f : r ↪r s) [IsSymm β s] : IsSymm α r :=\n  ⟨fun _ _ => imp_imp_imp f.map_rel_iff.2 f.map_rel_iff.1 symm⟩\n\n"}
{"name":"RelEmbedding.isAsymm","module":"Mathlib.Order.RelIso.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\ns : β → β → Prop\nf : RelEmbedding r s\ninst✝ : IsAsymm β s\n⊢ IsAsymm α r","decl":"protected theorem isAsymm (f : r ↪r s) [IsAsymm β s] : IsAsymm α r :=\n  ⟨fun _ _ h₁ h₂ => asymm (f.map_rel_iff.2 h₁) (f.map_rel_iff.2 h₂)⟩\n\n"}
{"name":"RelEmbedding.isAntisymm","module":"Mathlib.Order.RelIso.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\ns : β → β → Prop\nx✝ : RelEmbedding r s\ninst✝ : IsAntisymm β s\n⊢ IsAntisymm α r","decl":"protected theorem isAntisymm : ∀ (_ : r ↪r s) [IsAntisymm β s], IsAntisymm α r\n  | ⟨f, o⟩, ⟨H⟩ => ⟨fun _ _ h₁ h₂ => f.inj' (H _ _ (o.2 h₁) (o.2 h₂))⟩\n\n"}
{"name":"RelEmbedding.isTrans","module":"Mathlib.Order.RelIso.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\ns : β → β → Prop\nx✝ : RelEmbedding r s\ninst✝ : IsTrans β s\n⊢ IsTrans α r","decl":"protected theorem isTrans : ∀ (_ : r ↪r s) [IsTrans β s], IsTrans α r\n  | ⟨_, o⟩, ⟨H⟩ => ⟨fun _ _ _ h₁ h₂ => o.1 (H _ _ _ (o.2 h₁) (o.2 h₂))⟩\n\n"}
{"name":"RelEmbedding.isTotal","module":"Mathlib.Order.RelIso.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\ns : β → β → Prop\nx✝ : RelEmbedding r s\ninst✝ : IsTotal β s\n⊢ IsTotal α r","decl":"protected theorem isTotal : ∀ (_ : r ↪r s) [IsTotal β s], IsTotal α r\n  | ⟨_, o⟩, ⟨H⟩ => ⟨fun _ _ => (or_congr o o).1 (H _ _)⟩\n\n"}
{"name":"RelEmbedding.isPreorder","module":"Mathlib.Order.RelIso.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\ns : β → β → Prop\nx✝ : RelEmbedding r s\ninst✝ : IsPreorder β s\n⊢ IsPreorder α r","decl":"protected theorem isPreorder : ∀ (_ : r ↪r s) [IsPreorder β s], IsPreorder α r\n  | f, _ => { f.isRefl, f.isTrans with }\n\n"}
{"name":"RelEmbedding.isPartialOrder","module":"Mathlib.Order.RelIso.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\ns : β → β → Prop\nx✝ : RelEmbedding r s\ninst✝ : IsPartialOrder β s\n⊢ IsPartialOrder α r","decl":"protected theorem isPartialOrder : ∀ (_ : r ↪r s) [IsPartialOrder β s], IsPartialOrder α r\n  | f, _ => { f.isPreorder, f.isAntisymm with }\n\n"}
{"name":"RelEmbedding.isLinearOrder","module":"Mathlib.Order.RelIso.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\ns : β → β → Prop\nx✝ : RelEmbedding r s\ninst✝ : IsLinearOrder β s\n⊢ IsLinearOrder α r","decl":"protected theorem isLinearOrder : ∀ (_ : r ↪r s) [IsLinearOrder β s], IsLinearOrder α r\n  | f, _ => { f.isPartialOrder, f.isTotal with }\n\n"}
{"name":"RelEmbedding.isStrictOrder","module":"Mathlib.Order.RelIso.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\ns : β → β → Prop\nx✝ : RelEmbedding r s\ninst✝ : IsStrictOrder β s\n⊢ IsStrictOrder α r","decl":"protected theorem isStrictOrder : ∀ (_ : r ↪r s) [IsStrictOrder β s], IsStrictOrder α r\n  | f, _ => { f.isIrrefl, f.isTrans with }\n\n"}
{"name":"RelEmbedding.isTrichotomous","module":"Mathlib.Order.RelIso.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\ns : β → β → Prop\nx✝ : RelEmbedding r s\ninst✝ : IsTrichotomous β s\n⊢ IsTrichotomous α r","decl":"protected theorem isTrichotomous : ∀ (_ : r ↪r s) [IsTrichotomous β s], IsTrichotomous α r\n  | ⟨f, o⟩, ⟨H⟩ => ⟨fun _ _ => (or_congr o (or_congr f.inj'.eq_iff o)).1 (H _ _)⟩\n\n"}
{"name":"RelEmbedding.isStrictTotalOrder","module":"Mathlib.Order.RelIso.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\ns : β → β → Prop\nx✝ : RelEmbedding r s\ninst✝ : IsStrictTotalOrder β s\n⊢ IsStrictTotalOrder α r","decl":"protected theorem isStrictTotalOrder : ∀ (_ : r ↪r s) [IsStrictTotalOrder β s],\n    IsStrictTotalOrder α r\n  | f, _ => { f.isTrichotomous, f.isStrictOrder with }\n\n"}
{"name":"RelEmbedding.acc","module":"Mathlib.Order.RelIso.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\ns : β → β → Prop\nf : RelEmbedding r s\na : α\na✝ : Acc s (f a)\n⊢ Acc r a","decl":"protected theorem acc (f : r ↪r s) (a : α) : Acc s (f a) → Acc r a := by\n  generalize h : f a = b\n  intro ac\n  induction ac generalizing a with | intro _ H IH => ?_\n  subst h\n  exact ⟨_, fun a' h => IH (f a') (f.map_rel_iff.2 h) _ rfl⟩\n\n"}
{"name":"RelEmbedding.wellFounded","module":"Mathlib.Order.RelIso.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\ns : β → β → Prop\nx✝¹ : RelEmbedding r s\nx✝ : WellFounded s\n⊢ WellFounded r","decl":"protected theorem wellFounded : ∀ (_ : r ↪r s) (_ : WellFounded s), WellFounded r\n  | f, ⟨H⟩ => ⟨fun _ => f.acc _ (H _)⟩\n\n"}
{"name":"RelEmbedding.isWellFounded","module":"Mathlib.Order.RelIso.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\ns : β → β → Prop\nf : RelEmbedding r s\ninst✝ : IsWellFounded β s\n⊢ IsWellFounded α r","decl":"protected theorem isWellFounded (f : r ↪r s) [IsWellFounded β s] : IsWellFounded α r :=\n  ⟨f.wellFounded IsWellFounded.wf⟩\n\n"}
{"name":"RelEmbedding.isWellOrder","module":"Mathlib.Order.RelIso.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\ns : β → β → Prop\nx✝ : RelEmbedding r s\ninst✝ : IsWellOrder β s\n⊢ IsWellOrder α r","decl":"protected theorem isWellOrder : ∀ (_ : r ↪r s) [IsWellOrder β s], IsWellOrder α r\n  | f, H => { f.isStrictTotalOrder with wf := f.wellFounded H.wf }\n\n"}
{"name":"Subtype.wellFoundedLT","module":"Mathlib.Order.RelIso.Basic","initialProofState":"α : Type u_1\ninst✝¹ : LT α\ninst✝ : WellFoundedLT α\np : α → Prop\n⊢ WellFoundedLT (Subtype p)","decl":"instance Subtype.wellFoundedLT [LT α] [WellFoundedLT α] (p : α → Prop) :\n    WellFoundedLT (Subtype p) :=\n  (Subtype.relEmbedding (· < ·) p).isWellFounded\n\n"}
{"name":"Subtype.wellFoundedGT","module":"Mathlib.Order.RelIso.Basic","initialProofState":"α : Type u_1\ninst✝¹ : LT α\ninst✝ : WellFoundedGT α\np : α → Prop\n⊢ WellFoundedGT (Subtype p)","decl":"instance Subtype.wellFoundedGT [LT α] [WellFoundedGT α] (p : α → Prop) :\n    WellFoundedGT (Subtype p) :=\n  (Subtype.relEmbedding (· > ·) p).isWellFounded\n\n"}
{"name":"Quotient.mkRelHom_apply","module":"Mathlib.Order.RelIso.Basic","initialProofState":"α : Type u_1\nx✝ : Setoid α\nr : α → α → Prop\nH : ∀ (a₁ b₁ a₂ b₂ : α), HasEquiv.Equiv a₁ a₂ → HasEquiv.Equiv b₁ b₂ → Eq (r a₁ b₁) (r a₂ b₂)\na : α\n⊢ Eq ((Quotient.mkRelHom H) a) (Quotient.mk x✝ a)","decl":"/-- `Quotient.mk` as a relation homomorphism between the relation and the lift of a relation. -/\n@[simps]\ndef Quotient.mkRelHom {_ : Setoid α} {r : α → α → Prop}\n    (H : ∀ (a₁ b₁ a₂ b₂ : α), a₁ ≈ a₂ → b₁ ≈ b₂ → r a₁ b₁ = r a₂ b₂) : r →r Quotient.lift₂ r H :=\n  ⟨Quotient.mk _, id⟩\n\n"}
{"name":"Quotient.outRelEmbedding_apply","module":"Mathlib.Order.RelIso.Basic","initialProofState":"α : Type u_1\nx✝ : Setoid α\nr : α → α → Prop\nH : ∀ (a₁ b₁ a₂ b₂ : α), HasEquiv.Equiv a₁ a₂ → HasEquiv.Equiv b₁ b₂ → Eq (r a₁ b₁) (r a₂ b₂)\na✝ : Quotient x✝\n⊢ Eq ((Quotient.outRelEmbedding H) a✝) a✝.out","decl":"/-- `Quotient.out` as a relation embedding between the lift of a relation and the relation. -/\n@[simps!]\nnoncomputable def Quotient.outRelEmbedding {_ : Setoid α} {r : α → α → Prop}\n    (H : ∀ (a₁ b₁ a₂ b₂ : α), a₁ ≈ a₂ → b₁ ≈ b₂ → r a₁ b₁ = r a₂ b₂) : Quotient.lift₂ r H ↪r r :=\n  ⟨Embedding.quotientOut α, by\n    refine @fun x y => Quotient.inductionOn₂ x y fun a b => ?_\n    apply iff_iff_eq.2 (H _ _ _ _ _ _) <;> apply Quotient.mk_out⟩\n\n"}
{"name":"Quotient.out'RelEmbedding_apply","module":"Mathlib.Order.RelIso.Basic","initialProofState":"α : Type u_1\nx✝ : Setoid α\nr : α → α → Prop\nH : ∀ (a₁ b₁ a₂ b₂ : α), HasEquiv.Equiv a₁ a₂ → HasEquiv.Equiv b₁ b₂ → Eq (r a₁ b₁) (r a₂ b₂)\na✝ : Quotient x✝\n⊢ Eq ((Quotient.out'RelEmbedding H) a✝) a✝.out'","decl":"set_option linter.deprecated false in\n/-- `Quotient.out'` as a relation embedding between the lift of a relation and the relation. -/\n@[deprecated Quotient.outRelEmbedding (since := \"2024-10-19\"), simps]\nnoncomputable def Quotient.out'RelEmbedding {_ : Setoid α} {r : α → α → Prop}\n    (H : ∀ (a₁ b₁ a₂ b₂ : α), a₁ ≈ a₂ → b₁ ≈ b₂ → r a₁ b₁ = r a₂ b₂) :\n    (fun a b => Quotient.liftOn₂' a b r H) ↪r r :=\n  { Quotient.outRelEmbedding H with toFun := Quotient.out' }\n\n"}
{"name":"acc_lift₂_iff","module":"Mathlib.Order.RelIso.Basic","initialProofState":"α : Type u_1\nx✝ : Setoid α\nr : α → α → Prop\nH : ∀ (a₁ b₁ a₂ b₂ : α), HasEquiv.Equiv a₁ a₂ → HasEquiv.Equiv b₁ b₂ → Eq (r a₁ b₁) (r a₂ b₂)\na : α\n⊢ Iff (Acc (Quotient.lift₂ r H) (Quotient.mk x✝ a)) (Acc r a)","decl":"@[simp]\ntheorem acc_lift₂_iff {_ : Setoid α} {r : α → α → Prop}\n    {H : ∀ (a₁ b₁ a₂ b₂ : α), a₁ ≈ a₂ → b₁ ≈ b₂ → r a₁ b₁ = r a₂ b₂} {a} :\n    Acc (Quotient.lift₂ r H) ⟦a⟧ ↔ Acc r a := by\n  constructor\n  · exact RelHomClass.acc (Quotient.mkRelHom H) a\n  · intro ac\n    induction ac with | intro _ _ IH => ?_\n    refine ⟨_, fun q h => ?_⟩\n    obtain ⟨a', rfl⟩ := q.exists_rep\n    exact IH a' h\n\n"}
{"name":"acc_liftOn₂'_iff","module":"Mathlib.Order.RelIso.Basic","initialProofState":"α : Type u_1\ns : Setoid α\nr : α → α → Prop\nH : ∀ (a₁ a₂ b₁ b₂ : α), s a₁ b₁ → s a₂ b₂ → Eq (r a₁ a₂) (r b₁ b₂)\na : α\n⊢ Iff (Acc (fun x y => x.liftOn₂' y r H) (Quotient.mk'' a)) (Acc r a)","decl":"@[simp]\ntheorem acc_liftOn₂'_iff {s : Setoid α} {r : α → α → Prop} {H} {a} :\n    Acc (fun x y => Quotient.liftOn₂' x y r H) (Quotient.mk'' a : Quotient s) ↔ Acc r a :=\n  acc_lift₂_iff (H := H)\n\n"}
{"name":"wellFounded_lift₂_iff","module":"Mathlib.Order.RelIso.Basic","initialProofState":"α : Type u_1\nx✝ : Setoid α\nr : α → α → Prop\nH : ∀ (a₁ b₁ a₂ b₂ : α), HasEquiv.Equiv a₁ a₂ → HasEquiv.Equiv b₁ b₂ → Eq (r a₁ b₁) (r a₂ b₂)\n⊢ Iff (WellFounded (Quotient.lift₂ r H)) (WellFounded r)","decl":"/-- A relation is well founded iff its lift to a quotient is. -/\n@[simp]\ntheorem wellFounded_lift₂_iff {_ : Setoid α} {r : α → α → Prop}\n    {H : ∀ (a₁ b₁ a₂ b₂ : α), a₁ ≈ a₂ → b₁ ≈ b₂ → r a₁ b₁ = r a₂ b₂} :\n    WellFounded (Quotient.lift₂ r H) ↔ WellFounded r := by\n  constructor\n  · exact RelHomClass.wellFounded (Quotient.mkRelHom H)\n  · refine fun wf => ⟨fun q => ?_⟩\n    obtain ⟨a, rfl⟩ := q.exists_rep\n    exact acc_lift₂_iff.2 (wf.apply a)\n\n"}
{"name":"WellFounded.of_quotient_lift₂","module":"Mathlib.Order.RelIso.Basic","initialProofState":"α : Type u_1\nx✝ : Setoid α\nr : α → α → Prop\nH : ∀ (a₁ b₁ a₂ b₂ : α), HasEquiv.Equiv a₁ a₂ → HasEquiv.Equiv b₁ b₂ → Eq (r a₁ b₁) (r a₂ b₂)\na✝ : WellFounded (Quotient.lift₂ r H)\n⊢ WellFounded r","decl":"alias ⟨WellFounded.of_quotient_lift₂, WellFounded.quotient_lift₂⟩ := wellFounded_lift₂_iff\n\n"}
{"name":"WellFounded.quotient_lift₂","module":"Mathlib.Order.RelIso.Basic","initialProofState":"α : Type u_1\nx✝ : Setoid α\nr : α → α → Prop\nH : ∀ (a₁ b₁ a₂ b₂ : α), HasEquiv.Equiv a₁ a₂ → HasEquiv.Equiv b₁ b₂ → Eq (r a₁ b₁) (r a₂ b₂)\na✝ : WellFounded r\n⊢ WellFounded (Quotient.lift₂ r H)","decl":"alias ⟨WellFounded.of_quotient_lift₂, WellFounded.quotient_lift₂⟩ := wellFounded_lift₂_iff\n\n"}
{"name":"wellFounded_liftOn₂'_iff","module":"Mathlib.Order.RelIso.Basic","initialProofState":"α : Type u_1\ns : Setoid α\nr : α → α → Prop\nH : ∀ (a₁ a₂ b₁ b₂ : α), s a₁ b₁ → s a₂ b₂ → Eq (r a₁ a₂) (r b₁ b₂)\n⊢ Iff (WellFounded fun x y => x.liftOn₂' y r H) (WellFounded r)","decl":"@[simp]\ntheorem wellFounded_liftOn₂'_iff {s : Setoid α} {r : α → α → Prop} {H} :\n    (WellFounded fun x y : Quotient s => Quotient.liftOn₂' x y r H) ↔ WellFounded r :=\n  wellFounded_lift₂_iff (H := H)\n\n"}
{"name":"WellFounded.quotient_liftOn₂'","module":"Mathlib.Order.RelIso.Basic","initialProofState":"α : Type u_1\ns : Setoid α\nr : α → α → Prop\nH : ∀ (a₁ a₂ b₁ b₂ : α), s a₁ b₁ → s a₂ b₂ → Eq (r a₁ a₂) (r b₁ b₂)\na✝ : WellFounded r\n⊢ WellFounded fun x y => x.liftOn₂' y r H","decl":"alias ⟨WellFounded.of_quotient_liftOn₂', WellFounded.quotient_liftOn₂'⟩ := wellFounded_liftOn₂'_iff\n\n"}
{"name":"WellFounded.of_quotient_liftOn₂'","module":"Mathlib.Order.RelIso.Basic","initialProofState":"α : Type u_1\ns : Setoid α\nr : α → α → Prop\nH : ∀ (a₁ a₂ b₁ b₂ : α), s a₁ b₁ → s a₂ b₂ → Eq (r a₁ a₂) (r b₁ b₂)\na✝ : WellFounded fun x y => x.liftOn₂' y r H\n⊢ WellFounded r","decl":"alias ⟨WellFounded.of_quotient_liftOn₂', WellFounded.quotient_liftOn₂'⟩ := wellFounded_liftOn₂'_iff\n\n"}
{"name":"RelEmbedding.ofMapRelIff_coe","module":"Mathlib.Order.RelIso.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\ns : β → β → Prop\nf : α → β\ninst✝¹ : IsAntisymm α r\ninst✝ : IsRefl β s\nhf : ∀ (a b : α), Iff (s (f a) (f b)) (r a b)\n⊢ Eq (⇑(RelEmbedding.ofMapRelIff f hf)) f","decl":"@[simp]\ntheorem ofMapRelIff_coe (f : α → β) [IsAntisymm α r] [IsRefl β s]\n    (hf : ∀ a b, s (f a) (f b) ↔ r a b) :\n    (ofMapRelIff f hf : r ↪r s) = f :=\n  rfl\n\n"}
{"name":"RelEmbedding.ofMonotone_coe","module":"Mathlib.Order.RelIso.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\ns : β → β → Prop\ninst✝¹ : IsTrichotomous α r\ninst✝ : IsAsymm β s\nf : α → β\nH : ∀ (a b : α), r a b → s (f a) (f b)\n⊢ Eq (⇑(RelEmbedding.ofMonotone f H)) f","decl":"@[simp]\ntheorem ofMonotone_coe [IsTrichotomous α r] [IsAsymm β s] (f : α → β) (H) :\n    (@ofMonotone _ _ r s _ _ f H : α → β) = f :=\n  rfl\n\n"}
{"name":"RelEmbedding.sumLiftRelInl_apply","module":"Mathlib.Order.RelIso.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\ns : β → β → Prop\nval : α\n⊢ Eq ((RelEmbedding.sumLiftRelInl r s) val) (Sum.inl val)","decl":"/-- `Sum.inl` as a relation embedding into `Sum.LiftRel r s`. -/\n@[simps]\ndef sumLiftRelInl (r : α → α → Prop) (s : β → β → Prop) : r ↪r Sum.LiftRel r s where\n  toFun := Sum.inl\n  inj' := Sum.inl_injective\n  map_rel_iff' := Sum.liftRel_inl_inl\n\n"}
{"name":"RelEmbedding.sumLiftRelInr_apply","module":"Mathlib.Order.RelIso.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\ns : β → β → Prop\nval : β\n⊢ Eq ((RelEmbedding.sumLiftRelInr r s) val) (Sum.inr val)","decl":"/-- `Sum.inr` as a relation embedding into `Sum.LiftRel r s`. -/\n@[simps]\ndef sumLiftRelInr (r : α → α → Prop) (s : β → β → Prop) : s ↪r Sum.LiftRel r s where\n  toFun := Sum.inr\n  inj' := Sum.inr_injective\n  map_rel_iff' := Sum.liftRel_inr_inr\n\n"}
{"name":"RelEmbedding.sumLiftRelMap_apply","module":"Mathlib.Order.RelIso.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nδ : Type u_4\nr : α → α → Prop\ns : β → β → Prop\nt : γ → γ → Prop\nu : δ → δ → Prop\nf : RelEmbedding r s\ng : RelEmbedding t u\na✝ : Sum α γ\n⊢ Eq ((f.sumLiftRelMap g) a✝) (Sum.map (⇑f) (⇑g) a✝)","decl":"/-- `Sum.map` as a relation embedding between `Sum.LiftRel` relations. -/\n@[simps]\ndef sumLiftRelMap (f : r ↪r s) (g : t ↪r u) : Sum.LiftRel r t ↪r Sum.LiftRel s u where\n  toFun := Sum.map f g\n  inj' := f.injective.sum_map g.injective\n  map_rel_iff' := by rintro (a | b) (c | d) <;> simp [f.map_rel_iff, g.map_rel_iff]\n\n"}
{"name":"RelEmbedding.sumLexInl_apply","module":"Mathlib.Order.RelIso.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\ns : β → β → Prop\nval : α\n⊢ Eq ((RelEmbedding.sumLexInl r s) val) (Sum.inl val)","decl":"/-- `Sum.inl` as a relation embedding into `Sum.Lex r s`. -/\n@[simps]\ndef sumLexInl (r : α → α → Prop) (s : β → β → Prop) : r ↪r Sum.Lex r s where\n  toFun := Sum.inl\n  inj' := Sum.inl_injective\n  map_rel_iff' := Sum.lex_inl_inl\n\n"}
{"name":"RelEmbedding.sumLexInr_apply","module":"Mathlib.Order.RelIso.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\ns : β → β → Prop\nval : β\n⊢ Eq ((RelEmbedding.sumLexInr r s) val) (Sum.inr val)","decl":"/-- `Sum.inr` as a relation embedding into `Sum.Lex r s`. -/\n@[simps]\ndef sumLexInr (r : α → α → Prop) (s : β → β → Prop) : s ↪r Sum.Lex r s where\n  toFun := Sum.inr\n  inj' := Sum.inr_injective\n  map_rel_iff' := Sum.lex_inr_inr\n\n"}
{"name":"RelEmbedding.sumLexMap_apply","module":"Mathlib.Order.RelIso.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nδ : Type u_4\nr : α → α → Prop\ns : β → β → Prop\nt : γ → γ → Prop\nu : δ → δ → Prop\nf : RelEmbedding r s\ng : RelEmbedding t u\na✝ : Sum α γ\n⊢ Eq ((f.sumLexMap g) a✝) (Sum.map (⇑f) (⇑g) a✝)","decl":"/-- `Sum.map` as a relation embedding between `Sum.Lex` relations. -/\n@[simps]\ndef sumLexMap (f : r ↪r s) (g : t ↪r u) : Sum.Lex r t ↪r Sum.Lex s u where\n  toFun := Sum.map f g\n  inj' := f.injective.sum_map g.injective\n  map_rel_iff' := by rintro (a | b) (c | d) <;> simp [f.map_rel_iff, g.map_rel_iff]\n\n"}
{"name":"RelEmbedding.prodLexMkLeft_apply","module":"Mathlib.Order.RelIso.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\ns : β → β → Prop\na : α\nh : Not (r a a)\nsnd : β\n⊢ Eq ((RelEmbedding.prodLexMkLeft s h) snd) { fst := a, snd := snd }","decl":"/-- `fun b ↦ Prod.mk a b` as a relation embedding. -/\n@[simps]\ndef prodLexMkLeft (s : β → β → Prop) {a : α} (h : ¬r a a) : s ↪r Prod.Lex r s where\n  toFun := Prod.mk a\n  inj' := Prod.mk.inj_left a\n  map_rel_iff' := by simp [Prod.lex_def, h]\n\n"}
{"name":"RelEmbedding.prodLexMkRight_apply","module":"Mathlib.Order.RelIso.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ns : β → β → Prop\nr : α → α → Prop\nb : β\nh : Not (s b b)\na : α\n⊢ Eq ((RelEmbedding.prodLexMkRight r h) a) { fst := a, snd := b }","decl":"/-- `fun a ↦ Prod.mk a b` as a relation embedding. -/\n@[simps]\ndef prodLexMkRight (r : α → α → Prop) {b : β} (h : ¬s b b) : r ↪r Prod.Lex r s where\n  toFun a := (a, b)\n  inj' := Prod.mk.inj_right b\n  map_rel_iff' := by simp [Prod.lex_def, h]\n\n"}
{"name":"RelEmbedding.prodLexMap_apply","module":"Mathlib.Order.RelIso.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nδ : Type u_4\nr : α → α → Prop\ns : β → β → Prop\nt : γ → γ → Prop\nu : δ → δ → Prop\nf : RelEmbedding r s\ng : RelEmbedding t u\na✝ : Prod α γ\n⊢ Eq ((f.prodLexMap g) a✝) (Prod.map (⇑f) (⇑g) a✝)","decl":"/-- `Prod.map` as a relation embedding. -/\n@[simps]\ndef prodLexMap (f : r ↪r s) (g : t ↪r u) : Prod.Lex r t ↪r Prod.Lex s u where\n  toFun := Prod.map f g\n  inj' := f.injective.prodMap g.injective\n  map_rel_iff' := by simp [Prod.lex_def, f.map_rel_iff, g.map_rel_iff, f.inj]\n\n"}
{"name":"RelIso.mk.sizeOf_spec","module":"Mathlib.Order.RelIso.Basic","initialProofState":"α : Type u_5\nβ : Type u_6\nr : α → α → Prop\ns : β → β → Prop\ninst✝³ : SizeOf α\ninst✝² : SizeOf β\ninst✝¹ : (a a_1 : α) → SizeOf (r a a_1)\ninst✝ : (a a_1 : β) → SizeOf (s a a_1)\ntoEquiv : Equiv α β\nmap_rel_iff' : ∀ {a b : α}, Iff (s (toEquiv a) (toEquiv b)) (r a b)\n⊢ Eq (SizeOf.sizeOf { toEquiv := toEquiv, map_rel_iff' := map_rel_iff' }) (HAdd.hAdd 1 (SizeOf.sizeOf toEquiv))","decl":"/-- A relation isomorphism is an equivalence that is also a relation embedding. -/\nstructure RelIso {α β : Type*} (r : α → α → Prop) (s : β → β → Prop) extends α ≃ β where\n  /-- Elements are related iff they are related after apply a `RelIso` -/\n  map_rel_iff' : ∀ {a b}, s (toEquiv a) (toEquiv b) ↔ r a b\n\n"}
{"name":"RelIso.mk.injEq","module":"Mathlib.Order.RelIso.Basic","initialProofState":"α : Type u_5\nβ : Type u_6\nr : α → α → Prop\ns : β → β → Prop\ntoEquiv✝ : Equiv α β\nmap_rel_iff'✝ : ∀ {a b : α}, Iff (s (toEquiv✝ a) (toEquiv✝ b)) (r a b)\ntoEquiv : Equiv α β\nmap_rel_iff' : ∀ {a b : α}, Iff (s (toEquiv a) (toEquiv b)) (r a b)\n⊢ Eq (Eq { toEquiv := toEquiv✝, map_rel_iff' := map_rel_iff'✝ } { toEquiv := toEquiv, map_rel_iff' := map_rel_iff' }) (Eq toEquiv✝ toEquiv)","decl":"/-- A relation isomorphism is an equivalence that is also a relation embedding. -/\nstructure RelIso {α β : Type*} (r : α → α → Prop) (s : β → β → Prop) extends α ≃ β where\n  /-- Elements are related iff they are related after apply a `RelIso` -/\n  map_rel_iff' : ∀ {a b}, s (toEquiv a) (toEquiv b) ↔ r a b\n\n"}
{"name":"RelIso.map_rel_iff'","module":"Mathlib.Order.RelIso.Basic","initialProofState":"α : Type u_5\nβ : Type u_6\nr : α → α → Prop\ns : β → β → Prop\nself : RelIso r s\na b : α\n⊢ Iff (s (self.toEquiv a) (self.toEquiv b)) (r a b)","decl":"/-- A relation isomorphism is an equivalence that is also a relation embedding. -/\nstructure RelIso {α β : Type*} (r : α → α → Prop) (s : β → β → Prop) extends α ≃ β where\n  /-- Elements are related iff they are related after apply a `RelIso` -/\n  map_rel_iff' : ∀ {a b}, s (toEquiv a) (toEquiv b) ↔ r a b\n\n"}
{"name":"RelIso.mk.inj","module":"Mathlib.Order.RelIso.Basic","initialProofState":"α : Type u_5\nβ : Type u_6\nr : α → α → Prop\ns : β → β → Prop\ntoEquiv✝ : Equiv α β\nmap_rel_iff'✝ : ∀ {a b : α}, Iff (s (toEquiv✝ a) (toEquiv✝ b)) (r a b)\ntoEquiv : Equiv α β\nmap_rel_iff' : ∀ {a b : α}, Iff (s (toEquiv a) (toEquiv b)) (r a b)\nx✝ : Eq { toEquiv := toEquiv✝, map_rel_iff' := map_rel_iff'✝ } { toEquiv := toEquiv, map_rel_iff' := map_rel_iff' }\n⊢ Eq toEquiv✝ toEquiv","decl":"/-- A relation isomorphism is an equivalence that is also a relation embedding. -/\nstructure RelIso {α β : Type*} (r : α → α → Prop) (s : β → β → Prop) extends α ≃ β where\n  /-- Elements are related iff they are related after apply a `RelIso` -/\n  map_rel_iff' : ∀ {a b}, s (toEquiv a) (toEquiv b) ↔ r a b\n\n"}
{"name":"RelIso.toEquiv_injective","module":"Mathlib.Order.RelIso.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\ns : β → β → Prop\n⊢ Function.Injective RelIso.toEquiv","decl":"theorem toEquiv_injective : Injective (toEquiv : r ≃r s → α ≃ β)\n  | ⟨e₁, o₁⟩, ⟨e₂, _⟩, h => by congr\n\n"}
{"name":"RelIso.instRelHomClass","module":"Mathlib.Order.RelIso.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\ns : β → β → Prop\n⊢ RelHomClass (RelIso r s) r s","decl":"instance : RelHomClass (r ≃r s) r s where\n  map_rel f _ _ := Iff.mpr (map_rel_iff' f)\n\n"}
{"name":"RelIso.coe_toRelEmbedding","module":"Mathlib.Order.RelIso.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\ns : β → β → Prop\nf : RelIso r s\n⊢ Eq ⇑f.toRelEmbedding ⇑f","decl":"@[simp]\ntheorem coe_toRelEmbedding (f : r ≃r s) : (f.toRelEmbedding : α → β) = f :=\n  rfl\n\n"}
{"name":"RelIso.coe_toEmbedding","module":"Mathlib.Order.RelIso.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\ns : β → β → Prop\nf : RelIso r s\n⊢ Eq ⇑f.toEmbedding ⇑f","decl":"@[simp]\ntheorem coe_toEmbedding (f : r ≃r s) : (f.toEmbedding : α → β) = f :=\n  rfl\n\n"}
{"name":"RelIso.map_rel_iff","module":"Mathlib.Order.RelIso.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\ns : β → β → Prop\nf : RelIso r s\na b : α\n⊢ Iff (s (f a) (f b)) (r a b)","decl":"theorem map_rel_iff (f : r ≃r s) {a b} : s (f a) (f b) ↔ r a b :=\n  f.map_rel_iff'\n\n"}
{"name":"RelIso.coe_fn_mk","module":"Mathlib.Order.RelIso.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\ns : β → β → Prop\nf : Equiv α β\no : ∀ ⦃a b : α⦄, Iff (s (f a) (f b)) (r a b)\n⊢ Eq ⇑{ toEquiv := f, map_rel_iff' := o } ⇑f","decl":"@[simp]\ntheorem coe_fn_mk (f : α ≃ β) (o : ∀ ⦃a b⦄, s (f a) (f b) ↔ r a b) :\n    (RelIso.mk f @o : α → β) = f :=\n  rfl\n\n"}
{"name":"RelIso.coe_fn_toEquiv","module":"Mathlib.Order.RelIso.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\ns : β → β → Prop\nf : RelIso r s\n⊢ Eq ⇑f.toEquiv ⇑f","decl":"@[simp]\ntheorem coe_fn_toEquiv (f : r ≃r s) : (f.toEquiv : α → β) = f :=\n  rfl\n\n"}
{"name":"RelIso.coe_fn_injective","module":"Mathlib.Order.RelIso.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\ns : β → β → Prop\n⊢ Function.Injective fun f => ⇑f","decl":"/-- The map `DFunLike.coe : (r ≃r s) → (α → β)` is injective. -/\ntheorem coe_fn_injective : Injective fun f : r ≃r s => (f : α → β) :=\n  DFunLike.coe_injective\n\n"}
{"name":"RelIso.ext","module":"Mathlib.Order.RelIso.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\ns : β → β → Prop\nf g : RelIso r s\nh : ∀ (x : α), Eq (f x) (g x)\n⊢ Eq f g","decl":"@[ext]\ntheorem ext ⦃f g : r ≃r s⦄ (h : ∀ x, f x = g x) : f = g :=\n  DFunLike.ext f g h\n\n"}
{"name":"RelIso.ext_iff","module":"Mathlib.Order.RelIso.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\ns : β → β → Prop\nf g : RelIso r s\n⊢ Iff (Eq f g) (∀ (x : α), Eq (f x) (g x))","decl":"@[ext]\ntheorem ext ⦃f g : r ≃r s⦄ (h : ∀ x, f x = g x) : f = g :=\n  DFunLike.ext f g h\n\n"}
{"name":"RelIso.refl_apply","module":"Mathlib.Order.RelIso.Basic","initialProofState":"α : Type u_1\nr : α → α → Prop\na : α\n⊢ Eq ((RelIso.refl r) a) a","decl":"/-- Identity map is a relation isomorphism. -/\n@[refl, simps! apply]\nprotected def refl (r : α → α → Prop) : r ≃r r :=\n  ⟨Equiv.refl _, Iff.rfl⟩\n\n"}
{"name":"RelIso.trans_apply","module":"Mathlib.Order.RelIso.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nr : α → α → Prop\ns : β → β → Prop\nt : γ → γ → Prop\nf₁ : RelIso r s\nf₂ : RelIso s t\na✝ : α\n⊢ Eq ((f₁.trans f₂) a✝) (f₂ (f₁ a✝))","decl":"/-- Composition of two relation isomorphisms is a relation isomorphism. -/\n@[simps! apply]\nprotected def trans (f₁ : r ≃r s) (f₂ : s ≃r t) : r ≃r t :=\n  ⟨f₁.toEquiv.trans f₂.toEquiv, f₂.map_rel_iff.trans f₁.map_rel_iff⟩\n\n"}
{"name":"RelIso.default_def","module":"Mathlib.Order.RelIso.Basic","initialProofState":"α : Type u_1\nr : α → α → Prop\n⊢ Eq Inhabited.default (RelIso.refl r)","decl":"@[simp]\ntheorem default_def (r : α → α → Prop) : default = RelIso.refl r :=\n  rfl\n\n"}
{"name":"RelIso.cast_apply","module":"Mathlib.Order.RelIso.Basic","initialProofState":"α β : Type u\nr : α → α → Prop\ns : β → β → Prop\nh₁ : Eq α β\nh₂ : HEq r s\na : α\n⊢ Eq ((RelIso.cast h₁ h₂) a) (cast h₁ a)","decl":"/-- A relation isomorphism between equal relations on equal types. -/\n@[simps! toEquiv apply]\nprotected def cast {α β : Type u} {r : α → α → Prop} {s : β → β → Prop} (h₁ : α = β)\n    (h₂ : HEq r s) : r ≃r s :=\n  ⟨Equiv.cast h₁, @fun a b => by\n    subst h₁\n    rw [eq_of_heq h₂]\n    rfl⟩\n\n"}
{"name":"RelIso.cast_toEquiv","module":"Mathlib.Order.RelIso.Basic","initialProofState":"α β : Type u\nr : α → α → Prop\ns : β → β → Prop\nh₁ : Eq α β\nh₂ : HEq r s\n⊢ Eq (RelIso.cast h₁ h₂).toEquiv (Equiv.cast h₁)","decl":"/-- A relation isomorphism between equal relations on equal types. -/\n@[simps! toEquiv apply]\nprotected def cast {α β : Type u} {r : α → α → Prop} {s : β → β → Prop} (h₁ : α = β)\n    (h₂ : HEq r s) : r ≃r s :=\n  ⟨Equiv.cast h₁, @fun a b => by\n    subst h₁\n    rw [eq_of_heq h₂]\n    rfl⟩\n\n"}
{"name":"RelIso.cast_symm","module":"Mathlib.Order.RelIso.Basic","initialProofState":"α β : Type u\nr : α → α → Prop\ns : β → β → Prop\nh₁ : Eq α β\nh₂ : HEq r s\n⊢ Eq (RelIso.cast h₁ h₂).symm (RelIso.cast ⋯ ⋯)","decl":"@[simp]\nprotected theorem cast_symm {α β : Type u} {r : α → α → Prop} {s : β → β → Prop} (h₁ : α = β)\n    (h₂ : HEq r s) : (RelIso.cast h₁ h₂).symm = RelIso.cast h₁.symm h₂.symm :=\n  rfl\n\n"}
{"name":"RelIso.cast_refl","module":"Mathlib.Order.RelIso.Basic","initialProofState":"α : Type u\nr : α → α → Prop\nh₁ : optParam (Eq α α) ⋯\nh₂ : optParam (HEq r r) ⋯\n⊢ Eq (RelIso.cast h₁ h₂) (RelIso.refl r)","decl":"@[simp]\nprotected theorem cast_refl {α : Type u} {r : α → α → Prop} (h₁ : α = α := rfl)\n    (h₂ : HEq r r := HEq.rfl) : RelIso.cast h₁ h₂ = RelIso.refl r :=\n  rfl\n\n"}
{"name":"RelIso.cast_trans","module":"Mathlib.Order.RelIso.Basic","initialProofState":"α β γ : Type u\nr : α → α → Prop\ns : β → β → Prop\nt : γ → γ → Prop\nh₁ : Eq α β\nh₁' : Eq β γ\nh₂ : HEq r s\nh₂' : HEq s t\n⊢ Eq ((RelIso.cast h₁ h₂).trans (RelIso.cast h₁' h₂')) (RelIso.cast ⋯ ⋯)","decl":"@[simp]\nprotected theorem cast_trans {α β γ : Type u} {r : α → α → Prop} {s : β → β → Prop}\n    {t : γ → γ → Prop} (h₁ : α = β) (h₁' : β = γ) (h₂ : HEq r s) (h₂' : HEq s t) :\n    (RelIso.cast h₁ h₂).trans (RelIso.cast h₁' h₂') = RelIso.cast (h₁.trans h₁') (h₂.trans h₂') :=\n  ext fun x => by subst h₁; rfl\n\n"}
{"name":"RelIso.compl_symm_apply","module":"Mathlib.Order.RelIso.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\ns : β → β → Prop\nf : RelIso r s\na✝ : β\n⊢ Eq (f.compl.symm a✝) (EquivLike.inv f a✝)","decl":"/-- A relation isomorphism is also a relation isomorphism between complemented relations. -/\n@[simps!]\nprotected def compl (f : r ≃r s) : rᶜ ≃r sᶜ :=\n  ⟨f, f.map_rel_iff.not⟩\n\n"}
{"name":"RelIso.compl_apply","module":"Mathlib.Order.RelIso.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\ns : β → β → Prop\nf : RelIso r s\na : α\n⊢ Eq (f.compl a) (f a)","decl":"/-- A relation isomorphism is also a relation isomorphism between complemented relations. -/\n@[simps!]\nprotected def compl (f : r ≃r s) : rᶜ ≃r sᶜ :=\n  ⟨f, f.map_rel_iff.not⟩\n\n"}
{"name":"RelIso.coe_fn_symm_mk","module":"Mathlib.Order.RelIso.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\ns : β → β → Prop\nf : Equiv α β\no : ∀ {a b : α}, Iff (s (f a) (f b)) (r a b)\n⊢ Eq ⇑{ toEquiv := f, map_rel_iff' := o }.symm ⇑f.symm","decl":"@[simp]\ntheorem coe_fn_symm_mk (f o) : ((@RelIso.mk _ _ r s f @o).symm : β → α) = f.symm :=\n  rfl\n\n"}
{"name":"RelIso.apply_symm_apply","module":"Mathlib.Order.RelIso.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\ns : β → β → Prop\ne : RelIso r s\nx : β\n⊢ Eq (e (e.symm x)) x","decl":"@[simp]\ntheorem apply_symm_apply (e : r ≃r s) (x : β) : e (e.symm x) = x :=\n  e.toEquiv.apply_symm_apply x\n\n"}
{"name":"RelIso.symm_apply_apply","module":"Mathlib.Order.RelIso.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\ns : β → β → Prop\ne : RelIso r s\nx : α\n⊢ Eq (e.symm (e x)) x","decl":"@[simp]\ntheorem symm_apply_apply (e : r ≃r s) (x : α) : e.symm (e x) = x :=\n  e.toEquiv.symm_apply_apply x\n\n"}
{"name":"RelIso.rel_symm_apply","module":"Mathlib.Order.RelIso.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\ns : β → β → Prop\ne : RelIso r s\nx : α\ny : β\n⊢ Iff (r x (e.symm y)) (s (e x) y)","decl":"theorem rel_symm_apply (e : r ≃r s) {x y} : r x (e.symm y) ↔ s (e x) y := by\n  rw [← e.map_rel_iff, e.apply_symm_apply]\n\n"}
{"name":"RelIso.symm_apply_rel","module":"Mathlib.Order.RelIso.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\ns : β → β → Prop\ne : RelIso r s\nx : β\ny : α\n⊢ Iff (r (e.symm x) y) (s x (e y))","decl":"theorem symm_apply_rel (e : r ≃r s) {x y} : r (e.symm x) y ↔ s x (e y) := by\n  rw [← e.map_rel_iff, e.apply_symm_apply]\n\n"}
{"name":"RelIso.self_trans_symm","module":"Mathlib.Order.RelIso.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\ns : β → β → Prop\ne : RelIso r s\n⊢ Eq (e.trans e.symm) (RelIso.refl r)","decl":"@[simp]\ntheorem self_trans_symm (e : r ≃r s) : e.trans e.symm = RelIso.refl r :=\n  ext e.symm_apply_apply\n\n"}
{"name":"RelIso.symm_trans_self","module":"Mathlib.Order.RelIso.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\ns : β → β → Prop\ne : RelIso r s\n⊢ Eq (e.symm.trans e) (RelIso.refl s)","decl":"@[simp]\ntheorem symm_trans_self (e : r ≃r s) : e.symm.trans e = RelIso.refl s :=\n  ext e.apply_symm_apply\n\n"}
{"name":"RelIso.bijective","module":"Mathlib.Order.RelIso.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\ns : β → β → Prop\ne : RelIso r s\n⊢ Function.Bijective ⇑e","decl":"protected theorem bijective (e : r ≃r s) : Bijective e :=\n  e.toEquiv.bijective\n\n"}
{"name":"RelIso.injective","module":"Mathlib.Order.RelIso.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\ns : β → β → Prop\ne : RelIso r s\n⊢ Function.Injective ⇑e","decl":"protected theorem injective (e : r ≃r s) : Injective e :=\n  e.toEquiv.injective\n\n"}
{"name":"RelIso.surjective","module":"Mathlib.Order.RelIso.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\ns : β → β → Prop\ne : RelIso r s\n⊢ Function.Surjective ⇑e","decl":"protected theorem surjective (e : r ≃r s) : Surjective e :=\n  e.toEquiv.surjective\n\n"}
{"name":"RelIso.eq_iff_eq","module":"Mathlib.Order.RelIso.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\ns : β → β → Prop\nf : RelIso r s\na b : α\n⊢ Iff (Eq (f a) (f b)) (Eq a b)","decl":"theorem eq_iff_eq (f : r ≃r s) {a b} : f a = f b ↔ a = b :=\n  f.injective.eq_iff\n\n"}
{"name":"RelIso.IsWellOrder.preimage","module":"Mathlib.Order.RelIso.Basic","initialProofState":"β : Type u_2\nα : Type u\nr : α → α → Prop\ninst✝ : IsWellOrder α r\nf : Equiv β α\n⊢ IsWellOrder β (Order.Preimage (⇑f) r)","decl":"instance IsWellOrder.preimage {α : Type u} (r : α → α → Prop) [IsWellOrder α r] (f : β ≃ α) :\n    IsWellOrder β (f ⁻¹'o r) :=\n  @RelEmbedding.isWellOrder _ _ (f ⁻¹'o r) r (RelIso.preimage f r) _\n\n"}
{"name":"RelIso.IsWellOrder.ulift","module":"Mathlib.Order.RelIso.Basic","initialProofState":"α : Type u\nr : α → α → Prop\ninst✝ : IsWellOrder α r\n⊢ IsWellOrder (ULift.{u_5, u} α) (Order.Preimage ULift.down r)","decl":"instance IsWellOrder.ulift {α : Type u} (r : α → α → Prop) [IsWellOrder α r] :\n    IsWellOrder (ULift α) (ULift.down ⁻¹'o r) :=\n  IsWellOrder.preimage r Equiv.ulift\n\n"}
{"name":"RelIso.ofSurjective_apply","module":"Mathlib.Order.RelIso.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\ns : β → β → Prop\nf : RelEmbedding r s\nH : Function.Surjective ⇑f\na : α\n⊢ Eq ((RelIso.ofSurjective f H) a) (f a)","decl":"/-- A surjective relation embedding is a relation isomorphism. -/\n@[simps! apply]\nnoncomputable def ofSurjective (f : r ↪r s) (H : Surjective f) : r ≃r s :=\n  ⟨Equiv.ofBijective f ⟨f.injective, H⟩, f.map_rel_iff⟩\n\n"}
