{"name":"Nat.log_eq_zero_iff","module":"Mathlib.Data.Nat.Log","initialProofState":"b n : Nat\n⊢ Iff (Eq (Nat.log b n) 0) (Or (LT.lt n b) (LE.le b 1))","decl":"@[simp]\ntheorem log_eq_zero_iff {b n : ℕ} : log b n = 0 ↔ n < b ∨ b ≤ 1 := by\n  rw [log, dite_eq_right_iff]\n  simp only [Nat.add_eq_zero_iff, Nat.one_ne_zero, and_false, imp_false, not_and_or, not_le, not_lt]\n\n"}
{"name":"Nat.log_of_lt","module":"Mathlib.Data.Nat.Log","initialProofState":"b n : Nat\nhb : LT.lt n b\n⊢ Eq (Nat.log b n) 0","decl":"theorem log_of_lt {b n : ℕ} (hb : n < b) : log b n = 0 :=\n  log_eq_zero_iff.2 (Or.inl hb)\n\n"}
{"name":"Nat.log_of_left_le_one","module":"Mathlib.Data.Nat.Log","initialProofState":"b : Nat\nhb : LE.le b 1\nn : Nat\n⊢ Eq (Nat.log b n) 0","decl":"theorem log_of_left_le_one {b : ℕ} (hb : b ≤ 1) (n) : log b n = 0 :=\n  log_eq_zero_iff.2 (Or.inr hb)\n\n"}
{"name":"Nat.log_pos_iff","module":"Mathlib.Data.Nat.Log","initialProofState":"b n : Nat\n⊢ Iff (LT.lt 0 (Nat.log b n)) (And (LE.le b n) (LT.lt 1 b))","decl":"@[simp]\ntheorem log_pos_iff {b n : ℕ} : 0 < log b n ↔ b ≤ n ∧ 1 < b := by\n  rw [Nat.pos_iff_ne_zero, Ne, log_eq_zero_iff, not_or, not_lt, not_le]\n\n"}
{"name":"Nat.log_pos","module":"Mathlib.Data.Nat.Log","initialProofState":"b n : Nat\nhb : LT.lt 1 b\nhbn : LE.le b n\n⊢ LT.lt 0 (Nat.log b n)","decl":"@[bound]\ntheorem log_pos {b n : ℕ} (hb : 1 < b) (hbn : b ≤ n) : 0 < log b n :=\n  log_pos_iff.2 ⟨hbn, hb⟩\n\n"}
{"name":"Nat.log_of_one_lt_of_le","module":"Mathlib.Data.Nat.Log","initialProofState":"b n : Nat\nh : LT.lt 1 b\nhn : LE.le b n\n⊢ Eq (Nat.log b n) (HAdd.hAdd (Nat.log b (HDiv.hDiv n b)) 1)","decl":"theorem log_of_one_lt_of_le {b n : ℕ} (h : 1 < b) (hn : b ≤ n) : log b n = log b (n / b) + 1 := by\n  rw [log]\n  exact if_pos ⟨hn, h⟩\n\n"}
{"name":"Nat.log_zero_left","module":"Mathlib.Data.Nat.Log","initialProofState":"n : Nat\n⊢ Eq (Nat.log 0 n) 0","decl":"@[simp] lemma log_zero_left : ∀ n, log 0 n = 0 := log_of_left_le_one <| Nat.zero_le _\n\n"}
{"name":"Nat.log_zero_right","module":"Mathlib.Data.Nat.Log","initialProofState":"b : Nat\n⊢ Eq (Nat.log b 0) 0","decl":"@[simp]\ntheorem log_zero_right (b : ℕ) : log b 0 = 0 :=\n  log_eq_zero_iff.2 (le_total 1 b)\n\n"}
{"name":"Nat.log_one_left","module":"Mathlib.Data.Nat.Log","initialProofState":"n : Nat\n⊢ Eq (Nat.log 1 n) 0","decl":"@[simp]\ntheorem log_one_left : ∀ n, log 1 n = 0 :=\n  log_of_left_le_one le_rfl\n\n"}
{"name":"Nat.log_one_right","module":"Mathlib.Data.Nat.Log","initialProofState":"b : Nat\n⊢ Eq (Nat.log b 1) 0","decl":"@[simp]\ntheorem log_one_right (b : ℕ) : log b 1 = 0 :=\n  log_eq_zero_iff.2 (lt_or_le _ _)\n\n"}
{"name":"Nat.pow_le_iff_le_log","module":"Mathlib.Data.Nat.Log","initialProofState":"b : Nat\nhb : LT.lt 1 b\nx y : Nat\nhy : Ne y 0\n⊢ Iff (LE.le (HPow.hPow b x) y) (LE.le x (Nat.log b y))","decl":"/-- `pow b` and `log b` (almost) form a Galois connection. See also `Nat.pow_le_of_le_log` and\n`Nat.le_log_of_pow_le` for individual implications under weaker assumptions. -/\ntheorem pow_le_iff_le_log {b : ℕ} (hb : 1 < b) {x y : ℕ} (hy : y ≠ 0) :\n    b ^ x ≤ y ↔ x ≤ log b y := by\n  induction y using Nat.strong_induction_on generalizing x with | h y ih => ?_\n  cases x with\n  | zero => dsimp; omega\n  | succ x =>\n    rw [log]; split_ifs with h\n    · have b_pos : 0 < b := lt_of_succ_lt hb\n      rw [Nat.add_le_add_iff_right, ← ih (y / b) (div_lt_self\n        (Nat.pos_iff_ne_zero.2 hy) hb) (Nat.div_pos h.1 b_pos).ne', le_div_iff_mul_le b_pos,\n        pow_succ', Nat.mul_comm]\n    · exact iff_of_false (fun hby => h ⟨(le_self_pow x.succ_ne_zero _).trans hby, hb⟩)\n        (not_succ_le_zero _)\n\n"}
{"name":"Nat.lt_pow_iff_log_lt","module":"Mathlib.Data.Nat.Log","initialProofState":"b : Nat\nhb : LT.lt 1 b\nx y : Nat\nhy : Ne y 0\n⊢ Iff (LT.lt y (HPow.hPow b x)) (LT.lt (Nat.log b y) x)","decl":"theorem lt_pow_iff_log_lt {b : ℕ} (hb : 1 < b) {x y : ℕ} (hy : y ≠ 0) : y < b ^ x ↔ log b y < x :=\n  lt_iff_lt_of_le_iff_le (pow_le_iff_le_log hb hy)\n\n"}
{"name":"Nat.pow_le_of_le_log","module":"Mathlib.Data.Nat.Log","initialProofState":"b x y : Nat\nhy : Ne y 0\nh : LE.le x (Nat.log b y)\n⊢ LE.le (HPow.hPow b x) y","decl":"theorem pow_le_of_le_log {b x y : ℕ} (hy : y ≠ 0) (h : x ≤ log b y) : b ^ x ≤ y := by\n  refine (le_or_lt b 1).elim (fun hb => ?_) fun hb => (pow_le_iff_le_log hb hy).2 h\n  rw [log_of_left_le_one hb, Nat.le_zero] at h\n  rwa [h, Nat.pow_zero, one_le_iff_ne_zero]\n\n"}
{"name":"Nat.le_log_of_pow_le","module":"Mathlib.Data.Nat.Log","initialProofState":"b x y : Nat\nhb : LT.lt 1 b\nh : LE.le (HPow.hPow b x) y\n⊢ LE.le x (Nat.log b y)","decl":"theorem le_log_of_pow_le {b x y : ℕ} (hb : 1 < b) (h : b ^ x ≤ y) : x ≤ log b y := by\n  rcases ne_or_eq y 0 with (hy | rfl)\n  exacts [(pow_le_iff_le_log hb hy).1 h, (h.not_lt (Nat.pow_pos (Nat.zero_lt_one.trans hb))).elim]\n\n"}
{"name":"Nat.pow_log_le_self","module":"Mathlib.Data.Nat.Log","initialProofState":"b x : Nat\nhx : Ne x 0\n⊢ LE.le (HPow.hPow b (Nat.log b x)) x","decl":"theorem pow_log_le_self (b : ℕ) {x : ℕ} (hx : x ≠ 0) : b ^ log b x ≤ x :=\n  pow_le_of_le_log hx le_rfl\n\n"}
{"name":"Nat.log_lt_of_lt_pow","module":"Mathlib.Data.Nat.Log","initialProofState":"b x y : Nat\nhy : Ne y 0\na✝ : LT.lt y (HPow.hPow b x)\n⊢ LT.lt (Nat.log b y) x","decl":"theorem log_lt_of_lt_pow {b x y : ℕ} (hy : y ≠ 0) : y < b ^ x → log b y < x :=\n  lt_imp_lt_of_le_imp_le (pow_le_of_le_log hy)\n\n"}
{"name":"Nat.lt_pow_of_log_lt","module":"Mathlib.Data.Nat.Log","initialProofState":"b x y : Nat\nhb : LT.lt 1 b\na✝ : LT.lt (Nat.log b y) x\n⊢ LT.lt y (HPow.hPow b x)","decl":"theorem lt_pow_of_log_lt {b x y : ℕ} (hb : 1 < b) : log b y < x → y < b ^ x :=\n  lt_imp_lt_of_le_imp_le (le_log_of_pow_le hb)\n\n"}
{"name":"Nat.log_lt_self","module":"Mathlib.Data.Nat.Log","initialProofState":"b x : Nat\nhx : Ne x 0\n⊢ LT.lt (Nat.log b x) x","decl":"lemma log_lt_self (b : ℕ) {x : ℕ} (hx : x ≠ 0) : log b x < x :=\n  match le_or_lt b 1 with\n  | .inl h => log_of_left_le_one h x ▸ Nat.pos_iff_ne_zero.2 hx\n  | .inr h => log_lt_of_lt_pow hx <| Nat.lt_pow_self h\n\n"}
{"name":"Nat.log_le_self","module":"Mathlib.Data.Nat.Log","initialProofState":"b x : Nat\n⊢ LE.le (Nat.log b x) x","decl":"lemma log_le_self (b x : ℕ) : log b x ≤ x :=\n  if hx : x = 0 then by simp [hx]\n  else (log_lt_self b hx).le\n\n"}
{"name":"Nat.lt_pow_succ_log_self","module":"Mathlib.Data.Nat.Log","initialProofState":"b : Nat\nhb : LT.lt 1 b\nx : Nat\n⊢ LT.lt x (HPow.hPow b (Nat.log b x).succ)","decl":"theorem lt_pow_succ_log_self {b : ℕ} (hb : 1 < b) (x : ℕ) : x < b ^ (log b x).succ :=\n  lt_pow_of_log_lt hb (lt_succ_self _)\n\n"}
{"name":"Nat.log_eq_iff","module":"Mathlib.Data.Nat.Log","initialProofState":"b m n : Nat\nh : Or (Ne m 0) (And (LT.lt 1 b) (Ne n 0))\n⊢ Iff (Eq (Nat.log b n) m) (And (LE.le (HPow.hPow b m) n) (LT.lt n (HPow.hPow b (HAdd.hAdd m 1))))","decl":"theorem log_eq_iff {b m n : ℕ} (h : m ≠ 0 ∨ 1 < b ∧ n ≠ 0) :\n    log b n = m ↔ b ^ m ≤ n ∧ n < b ^ (m + 1) := by\n  rcases em (1 < b ∧ n ≠ 0) with (⟨hb, hn⟩ | hbn)\n  · rw [le_antisymm_iff, ← Nat.lt_succ_iff, ← pow_le_iff_le_log, ← lt_pow_iff_log_lt,\n      and_comm] <;> assumption\n  have hm : m ≠ 0 := h.resolve_right hbn\n  rw [not_and_or, not_lt, Ne, not_not] at hbn\n  rcases hbn with (hb | rfl)\n  · obtain rfl | rfl := le_one_iff_eq_zero_or_eq_one.1 hb\n    any_goals\n      simp only [ne_eq, zero_eq, reduceSucc, lt_self_iff_false,  not_lt_zero, false_and, or_false]\n        at h\n      simp [h, eq_comm (a := 0), Nat.zero_pow (Nat.pos_iff_ne_zero.2 _)] <;> omega\n  · simp [@eq_comm _ 0, hm]\n\n"}
{"name":"Nat.log_eq_of_pow_le_of_lt_pow","module":"Mathlib.Data.Nat.Log","initialProofState":"b m n : Nat\nh₁ : LE.le (HPow.hPow b m) n\nh₂ : LT.lt n (HPow.hPow b (HAdd.hAdd m 1))\n⊢ Eq (Nat.log b n) m","decl":"theorem log_eq_of_pow_le_of_lt_pow {b m n : ℕ} (h₁ : b ^ m ≤ n) (h₂ : n < b ^ (m + 1)) :\n    log b n = m := by\n  rcases eq_or_ne m 0 with (rfl | hm)\n  · rw [Nat.pow_one] at h₂\n    exact log_of_lt h₂\n  · exact (log_eq_iff (Or.inl hm)).2 ⟨h₁, h₂⟩\n\n"}
{"name":"Nat.log_pow","module":"Mathlib.Data.Nat.Log","initialProofState":"b : Nat\nhb : LT.lt 1 b\nx : Nat\n⊢ Eq (Nat.log b (HPow.hPow b x)) x","decl":"theorem log_pow {b : ℕ} (hb : 1 < b) (x : ℕ) : log b (b ^ x) = x :=\n  log_eq_of_pow_le_of_lt_pow le_rfl (Nat.pow_lt_pow_right hb x.lt_succ_self)\n\n"}
{"name":"Nat.log_eq_one_iff'","module":"Mathlib.Data.Nat.Log","initialProofState":"b n : Nat\n⊢ Iff (Eq (Nat.log b n) 1) (And (LE.le b n) (LT.lt n (HMul.hMul b b)))","decl":"theorem log_eq_one_iff' {b n : ℕ} : log b n = 1 ↔ b ≤ n ∧ n < b * b := by\n  rw [log_eq_iff (Or.inl Nat.one_ne_zero), Nat.pow_add, Nat.pow_one]\n\n"}
{"name":"Nat.log_eq_one_iff","module":"Mathlib.Data.Nat.Log","initialProofState":"b n : Nat\n⊢ Iff (Eq (Nat.log b n) 1) (And (LT.lt n (HMul.hMul b b)) (And (LT.lt 1 b) (LE.le b n)))","decl":"theorem log_eq_one_iff {b n : ℕ} : log b n = 1 ↔ n < b * b ∧ 1 < b ∧ b ≤ n :=\n  log_eq_one_iff'.trans\n    ⟨fun h => ⟨h.2, lt_mul_self_iff.1 (h.1.trans_lt h.2), h.1⟩, fun h => ⟨h.2.2, h.1⟩⟩\n\n"}
{"name":"Nat.log_mul_base","module":"Mathlib.Data.Nat.Log","initialProofState":"b n : Nat\nhb : LT.lt 1 b\nhn : Ne n 0\n⊢ Eq (Nat.log b (HMul.hMul n b)) (HAdd.hAdd (Nat.log b n) 1)","decl":"theorem log_mul_base {b n : ℕ} (hb : 1 < b) (hn : n ≠ 0) : log b (n * b) = log b n + 1 := by\n  apply log_eq_of_pow_le_of_lt_pow <;> rw [pow_succ', Nat.mul_comm b]\n  exacts [Nat.mul_le_mul_right _ (pow_log_le_self _ hn),\n    (Nat.mul_lt_mul_right (Nat.zero_lt_one.trans hb)).2 (lt_pow_succ_log_self hb _)]\n\n"}
{"name":"Nat.pow_log_le_add_one","module":"Mathlib.Data.Nat.Log","initialProofState":"b x : Nat\n⊢ LE.le (HPow.hPow b (Nat.log b x)) (HAdd.hAdd x 1)","decl":"theorem pow_log_le_add_one (b : ℕ) : ∀ x, b ^ log b x ≤ x + 1\n  | 0 => by rw [log_zero_right, Nat.pow_zero]\n  | x + 1 => (pow_log_le_self b x.succ_ne_zero).trans (x + 1).le_succ\n\n"}
{"name":"Nat.log_monotone","module":"Mathlib.Data.Nat.Log","initialProofState":"b : Nat\n⊢ Monotone (Nat.log b)","decl":"theorem log_monotone {b : ℕ} : Monotone (log b) := by\n  refine monotone_nat_of_le_succ fun n => ?_\n  rcases le_or_lt b 1 with hb | hb\n  · rw [log_of_left_le_one hb]\n    exact zero_le _\n  · exact le_log_of_pow_le hb (pow_log_le_add_one _ _)\n\n"}
{"name":"Nat.log_mono_right","module":"Mathlib.Data.Nat.Log","initialProofState":"b n m : Nat\nh : LE.le n m\n⊢ LE.le (Nat.log b n) (Nat.log b m)","decl":"@[mono]\ntheorem log_mono_right {b n m : ℕ} (h : n ≤ m) : log b n ≤ log b m :=\n  log_monotone h\n\n"}
{"name":"Nat.log_anti_left","module":"Mathlib.Data.Nat.Log","initialProofState":"b c n : Nat\nhc : LT.lt 1 c\nhb : LE.le c b\n⊢ LE.le (Nat.log b n) (Nat.log c n)","decl":"@[mono]\ntheorem log_anti_left {b c n : ℕ} (hc : 1 < c) (hb : c ≤ b) : log b n ≤ log c n := by\n  rcases eq_or_ne n 0 with (rfl | hn); · rw [log_zero_right, log_zero_right]\n  apply le_log_of_pow_le hc\n  calc\n    c ^ log b n ≤ b ^ log b n := Nat.pow_le_pow_left hb _\n    _ ≤ n := pow_log_le_self _ hn\n\n"}
{"name":"Nat.log_antitone_left","module":"Mathlib.Data.Nat.Log","initialProofState":"n : Nat\n⊢ AntitoneOn (fun b => Nat.log b n) (Set.Ioi 1)","decl":"theorem log_antitone_left {n : ℕ} : AntitoneOn (fun b => log b n) (Set.Ioi 1) := fun _ hc _ _ hb =>\n  log_anti_left (Set.mem_Iio.1 hc) hb\n\n"}
{"name":"Nat.log_div_base","module":"Mathlib.Data.Nat.Log","initialProofState":"b n : Nat\n⊢ Eq (Nat.log b (HDiv.hDiv n b)) (HSub.hSub (Nat.log b n) 1)","decl":"@[simp]\ntheorem log_div_base (b n : ℕ) : log b (n / b) = log b n - 1 := by\n  rcases le_or_lt b 1 with hb | hb\n  · rw [log_of_left_le_one hb, log_of_left_le_one hb, Nat.zero_sub]\n  rcases lt_or_le n b with h | h\n  · rw [div_eq_of_lt h, log_of_lt h, log_zero_right]\n  rw [log_of_one_lt_of_le hb h, Nat.add_sub_cancel_right]\n\n"}
{"name":"Nat.log_div_mul_self","module":"Mathlib.Data.Nat.Log","initialProofState":"b n : Nat\n⊢ Eq (Nat.log b (HMul.hMul (HDiv.hDiv n b) b)) (Nat.log b n)","decl":"@[simp]\ntheorem log_div_mul_self (b n : ℕ) : log b (n / b * b) = log b n := by\n  rcases le_or_lt b 1 with hb | hb\n  · rw [log_of_left_le_one hb, log_of_left_le_one hb]\n  rcases lt_or_le n b with h | h\n  · rw [div_eq_of_lt h, Nat.zero_mul, log_zero_right, log_of_lt h]\n  rw [log_mul_base hb (Nat.div_pos h (by omega)).ne', log_div_base,\n    Nat.sub_add_cancel (succ_le_iff.2 <| log_pos hb h)]\n\n"}
{"name":"Nat.add_pred_div_lt","module":"Mathlib.Data.Nat.Log","initialProofState":"b n : Nat\nhb : LT.lt 1 b\nhn : LE.le 2 n\n⊢ LT.lt (HDiv.hDiv (HSub.hSub (HAdd.hAdd n b) 1) b) n","decl":"theorem add_pred_div_lt {b n : ℕ} (hb : 1 < b) (hn : 2 ≤ n) : (n + b - 1) / b < n := by\n  rw [div_lt_iff_lt_mul (by omega), ← succ_le_iff, ← pred_eq_sub_one,\n    succ_pred_eq_of_pos (by omega)]\n  exact Nat.add_le_mul hn hb\n\n"}
{"name":"Nat.log2_eq_log_two","module":"Mathlib.Data.Nat.Log","initialProofState":"n : Nat\n⊢ Eq n.log2 (Nat.log 2 n)","decl":"lemma log2_eq_log_two {n : ℕ} : Nat.log2 n = Nat.log 2 n := by\n  rcases eq_or_ne n 0 with rfl | hn\n  · rw [log2_zero, log_zero_right]\n  apply eq_of_forall_le_iff\n  intro m\n  rw [Nat.le_log2 hn, ← Nat.pow_le_iff_le_log Nat.one_lt_two hn]\n\n"}
{"name":"Nat.clog_of_left_le_one","module":"Mathlib.Data.Nat.Log","initialProofState":"b : Nat\nhb : LE.le b 1\nn : Nat\n⊢ Eq (Nat.clog b n) 0","decl":"theorem clog_of_left_le_one {b : ℕ} (hb : b ≤ 1) (n : ℕ) : clog b n = 0 := by\n  rw [clog, dif_neg fun h : 1 < b ∧ 1 < n => h.1.not_le hb]\n\n"}
{"name":"Nat.clog_of_right_le_one","module":"Mathlib.Data.Nat.Log","initialProofState":"n : Nat\nhn : LE.le n 1\nb : Nat\n⊢ Eq (Nat.clog b n) 0","decl":"theorem clog_of_right_le_one {n : ℕ} (hn : n ≤ 1) (b : ℕ) : clog b n = 0 := by\n  rw [clog, dif_neg fun h : 1 < b ∧ 1 < n => h.2.not_le hn]\n\n"}
{"name":"Nat.clog_zero_left","module":"Mathlib.Data.Nat.Log","initialProofState":"n : Nat\n⊢ Eq (Nat.clog 0 n) 0","decl":"@[simp] lemma clog_zero_left (n : ℕ) : clog 0 n = 0 := clog_of_left_le_one (Nat.zero_le _) _\n\n"}
{"name":"Nat.clog_zero_right","module":"Mathlib.Data.Nat.Log","initialProofState":"b : Nat\n⊢ Eq (Nat.clog b 0) 0","decl":"@[simp] lemma clog_zero_right (b : ℕ) : clog b 0 = 0 := clog_of_right_le_one (Nat.zero_le _) _\n\n"}
{"name":"Nat.clog_one_left","module":"Mathlib.Data.Nat.Log","initialProofState":"n : Nat\n⊢ Eq (Nat.clog 1 n) 0","decl":"@[simp]\ntheorem clog_one_left (n : ℕ) : clog 1 n = 0 :=\n  clog_of_left_le_one le_rfl _\n\n"}
{"name":"Nat.clog_one_right","module":"Mathlib.Data.Nat.Log","initialProofState":"b : Nat\n⊢ Eq (Nat.clog b 1) 0","decl":"@[simp]\ntheorem clog_one_right (b : ℕ) : clog b 1 = 0 :=\n  clog_of_right_le_one le_rfl _\n\n"}
{"name":"Nat.clog_of_two_le","module":"Mathlib.Data.Nat.Log","initialProofState":"b n : Nat\nhb : LT.lt 1 b\nhn : LE.le 2 n\n⊢ Eq (Nat.clog b n) (HAdd.hAdd (Nat.clog b (HDiv.hDiv (HSub.hSub (HAdd.hAdd n b) 1) b)) 1)","decl":"theorem clog_of_two_le {b n : ℕ} (hb : 1 < b) (hn : 2 ≤ n) :\n    clog b n = clog b ((n + b - 1) / b) + 1 := by rw [clog, dif_pos (⟨hb, hn⟩ : 1 < b ∧ 1 < n)]\n\n"}
{"name":"Nat.clog_pos","module":"Mathlib.Data.Nat.Log","initialProofState":"b n : Nat\nhb : LT.lt 1 b\nhn : LE.le 2 n\n⊢ LT.lt 0 (Nat.clog b n)","decl":"theorem clog_pos {b n : ℕ} (hb : 1 < b) (hn : 2 ≤ n) : 0 < clog b n := by\n  rw [clog_of_two_le hb hn]\n  exact zero_lt_succ _\n\n"}
{"name":"Nat.clog_eq_one","module":"Mathlib.Data.Nat.Log","initialProofState":"b n : Nat\nhn : LE.le 2 n\nh : LE.le n b\n⊢ Eq (Nat.clog b n) 1","decl":"theorem clog_eq_one {b n : ℕ} (hn : 2 ≤ n) (h : n ≤ b) : clog b n = 1 := by\n  rw [clog_of_two_le (hn.trans h) hn, clog_of_right_le_one]\n  rw [← Nat.lt_succ_iff, Nat.div_lt_iff_lt_mul] <;> omega\n\n"}
{"name":"Nat.le_pow_iff_clog_le","module":"Mathlib.Data.Nat.Log","initialProofState":"b : Nat\nhb : LT.lt 1 b\nx y : Nat\n⊢ Iff (LE.le x (HPow.hPow b y)) (LE.le (Nat.clog b x) y)","decl":"/-- `clog b` and `pow b` form a Galois connection. -/\ntheorem le_pow_iff_clog_le {b : ℕ} (hb : 1 < b) {x y : ℕ} : x ≤ b ^ y ↔ clog b x ≤ y := by\n  induction x using Nat.strong_induction_on generalizing y with | h x ih => ?_\n  cases y\n  · rw [Nat.pow_zero]\n    refine ⟨fun h => (clog_of_right_le_one h b).le, ?_⟩\n    simp_rw [← not_lt]\n    contrapose!\n    exact clog_pos hb\n  have b_pos : 0 < b := zero_lt_of_lt hb\n  rw [clog]; split_ifs with h\n  · rw [Nat.add_le_add_iff_right, ← ih ((x + b - 1) / b) (add_pred_div_lt hb h.2),\n      Nat.div_le_iff_le_mul_add_pred b_pos, Nat.mul_comm b, ← Nat.pow_succ,\n      Nat.add_sub_assoc (Nat.succ_le_of_lt b_pos), Nat.add_le_add_iff_right]\n  · exact iff_of_true ((not_lt.1 (not_and.1 h hb)).trans <| succ_le_of_lt <| Nat.pow_pos b_pos)\n      (zero_le _)\n\n"}
{"name":"Nat.pow_lt_iff_lt_clog","module":"Mathlib.Data.Nat.Log","initialProofState":"b : Nat\nhb : LT.lt 1 b\nx y : Nat\n⊢ Iff (LT.lt (HPow.hPow b y) x) (LT.lt y (Nat.clog b x))","decl":"theorem pow_lt_iff_lt_clog {b : ℕ} (hb : 1 < b) {x y : ℕ} : b ^ y < x ↔ y < clog b x :=\n  lt_iff_lt_of_le_iff_le (le_pow_iff_clog_le hb)\n\n"}
{"name":"Nat.clog_pow","module":"Mathlib.Data.Nat.Log","initialProofState":"b x : Nat\nhb : LT.lt 1 b\n⊢ Eq (Nat.clog b (HPow.hPow b x)) x","decl":"theorem clog_pow (b x : ℕ) (hb : 1 < b) : clog b (b ^ x) = x :=\n  eq_of_forall_ge_iff fun z ↦ by rw [← le_pow_iff_clog_le hb, Nat.pow_le_pow_iff_right hb]\n\n"}
{"name":"Nat.pow_pred_clog_lt_self","module":"Mathlib.Data.Nat.Log","initialProofState":"b : Nat\nhb : LT.lt 1 b\nx : Nat\nhx : LT.lt 1 x\n⊢ LT.lt (HPow.hPow b (Nat.clog b x).pred) x","decl":"theorem pow_pred_clog_lt_self {b : ℕ} (hb : 1 < b) {x : ℕ} (hx : 1 < x) :\n    b ^ (clog b x).pred < x := by\n  rw [← not_le, le_pow_iff_clog_le hb, not_le]\n  exact pred_lt (clog_pos hb hx).ne'\n\n"}
{"name":"Nat.le_pow_clog","module":"Mathlib.Data.Nat.Log","initialProofState":"b : Nat\nhb : LT.lt 1 b\nx : Nat\n⊢ LE.le x (HPow.hPow b (Nat.clog b x))","decl":"theorem le_pow_clog {b : ℕ} (hb : 1 < b) (x : ℕ) : x ≤ b ^ clog b x :=\n  (le_pow_iff_clog_le hb).2 le_rfl\n\n"}
{"name":"Nat.clog_mono_right","module":"Mathlib.Data.Nat.Log","initialProofState":"b n m : Nat\nh : LE.le n m\n⊢ LE.le (Nat.clog b n) (Nat.clog b m)","decl":"@[mono]\ntheorem clog_mono_right (b : ℕ) {n m : ℕ} (h : n ≤ m) : clog b n ≤ clog b m := by\n  rcases le_or_lt b 1 with hb | hb\n  · rw [clog_of_left_le_one hb]\n    exact zero_le _\n  · rw [← le_pow_iff_clog_le hb]\n    exact h.trans (le_pow_clog hb _)\n\n"}
{"name":"Nat.clog_anti_left","module":"Mathlib.Data.Nat.Log","initialProofState":"b c n : Nat\nhc : LT.lt 1 c\nhb : LE.le c b\n⊢ LE.le (Nat.clog b n) (Nat.clog c n)","decl":"@[mono]\ntheorem clog_anti_left {b c n : ℕ} (hc : 1 < c) (hb : c ≤ b) : clog b n ≤ clog c n := by\n  rw [← le_pow_iff_clog_le (lt_of_lt_of_le hc hb)]\n  calc\n    n ≤ c ^ clog c n := le_pow_clog hc _\n    _ ≤ b ^ clog c n := Nat.pow_le_pow_left hb _\n\n"}
{"name":"Nat.clog_monotone","module":"Mathlib.Data.Nat.Log","initialProofState":"b : Nat\n⊢ Monotone (Nat.clog b)","decl":"theorem clog_monotone (b : ℕ) : Monotone (clog b) := fun _ _ => clog_mono_right _\n\n"}
{"name":"Nat.clog_antitone_left","module":"Mathlib.Data.Nat.Log","initialProofState":"n : Nat\n⊢ AntitoneOn (fun b => Nat.clog b n) (Set.Ioi 1)","decl":"theorem clog_antitone_left {n : ℕ} : AntitoneOn (fun b : ℕ => clog b n) (Set.Ioi 1) :=\n  fun _ hc _ _ hb => clog_anti_left (Set.mem_Iio.1 hc) hb\n\n"}
{"name":"Nat.log_le_clog","module":"Mathlib.Data.Nat.Log","initialProofState":"b n : Nat\n⊢ LE.le (Nat.log b n) (Nat.clog b n)","decl":"theorem log_le_clog (b n : ℕ) : log b n ≤ clog b n := by\n  obtain hb | hb := le_or_lt b 1\n  · rw [log_of_left_le_one hb]\n    exact zero_le _\n  cases n with\n  | zero =>\n    rw [log_zero_right]\n    exact zero_le _\n  | succ n =>\n    exact (Nat.pow_le_pow_iff_right hb).1\n      ((pow_log_le_self b n.succ_ne_zero).trans <| le_pow_clog hb _)\n\n"}
{"name":"Nat.log_eq_logC","module":"Mathlib.Data.Nat.Log","initialProofState":"⊢ Eq Nat.log Nat.logC","decl":"/--\nThe result of `Nat.log` agrees with the result of `Nat.logC`. The latter will be computed more\nefficiently, but the former is easier to prove things about and has more lemmas.\nThis lemma is tagged @[csimp] so that the code generated for `Nat.log` uses `Nat.logC` instead.\n-/\n@[csimp] theorem log_eq_logC : log = logC := by\n  ext b m\n  rcases le_or_lt b 1 with hb | hb\n  case inl => rw [logC_of_left_le_one hb, Nat.log_of_left_le_one hb]\n  case inr =>\n    rcases eq_or_ne m 0 with rfl | hm\n    case inl => rw [Nat.log_zero_right, logC_zero]\n    case inr =>\n      rw [Nat.log_eq_iff (Or.inr ⟨hb, hm⟩)]\n      exact logC_spec hb (zero_lt_of_ne_zero hm)\n\n"}
