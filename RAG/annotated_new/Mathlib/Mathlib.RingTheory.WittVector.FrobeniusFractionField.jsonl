{"name":"WittVector.RecursionMain.succNthDefiningPoly_degree","module":"Mathlib.RingTheory.WittVector.FrobeniusFractionField","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nk : Type u_1\ninst‚úù¬≤ : CommRing k\ninst‚úù¬π : CharP k p\ninst‚úù : IsDomain k\nn : Nat\na‚ÇÅ a‚ÇÇ : WittVector p k\nbs : Fin (HAdd.hAdd n 1) ‚Üí k\nha‚ÇÅ : Ne (a‚ÇÅ.coeff 0) 0\nha‚ÇÇ : Ne (a‚ÇÇ.coeff 0) 0\n‚ä¢ Eq (WittVector.RecursionMain.succNthDefiningPoly p n a‚ÇÅ a‚ÇÇ bs).degree ‚Üëp","decl":"theorem succNthDefiningPoly_degree [IsDomain k] (n : ‚Ñï) (a‚ÇÅ a‚ÇÇ : ùïé k) (bs : Fin (n + 1) ‚Üí k)\n    (ha‚ÇÅ : a‚ÇÅ.coeff 0 ‚â† 0) (ha‚ÇÇ : a‚ÇÇ.coeff 0 ‚â† 0) :\n    (succNthDefiningPoly p n a‚ÇÅ a‚ÇÇ bs).degree = p := by\n  have : (X ^ p * C (a‚ÇÅ.coeff 0 ^ p ^ (n + 1))).degree = (p : WithBot ‚Ñï) := by\n    rw [degree_mul, degree_C]\n    ¬∑ simp only [Nat.cast_withBot, add_zero, degree_X, degree_pow, Nat.smul_one_eq_cast]\n    ¬∑ exact pow_ne_zero _ ha‚ÇÅ\n  have : (X ^ p * C (a‚ÇÅ.coeff 0 ^ p ^ (n + 1)) - X * C (a‚ÇÇ.coeff 0 ^ p ^ (n + 1))).degree =\n      (p : WithBot ‚Ñï) := by\n    rw [degree_sub_eq_left_of_degree_lt, this]\n    rw [this, degree_mul, degree_C, degree_X, add_zero]\n    ¬∑ exact mod_cast hp.out.one_lt\n    ¬∑ exact pow_ne_zero _ ha‚ÇÇ\n  rw [succNthDefiningPoly, degree_add_eq_left_of_degree_lt, this]\n  apply lt_of_le_of_lt degree_C_le\n  rw [this]\n  exact mod_cast hp.out.pos\n\n"}
{"name":"WittVector.RecursionMain.root_exists","module":"Mathlib.RingTheory.WittVector.FrobeniusFractionField","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nk : Type u_1\ninst‚úù¬≤ : Field k\ninst‚úù¬π : CharP k p\ninst‚úù : IsAlgClosed k\nn : Nat\na‚ÇÅ a‚ÇÇ : WittVector p k\nbs : Fin (HAdd.hAdd n 1) ‚Üí k\nha‚ÇÅ : Ne (a‚ÇÅ.coeff 0) 0\nha‚ÇÇ : Ne (a‚ÇÇ.coeff 0) 0\n‚ä¢ Exists fun b => (WittVector.RecursionMain.succNthDefiningPoly p n a‚ÇÅ a‚ÇÇ bs).IsRoot b","decl":"theorem root_exists (n : ‚Ñï) (a‚ÇÅ a‚ÇÇ : ùïé k) (bs : Fin (n + 1) ‚Üí k) (ha‚ÇÅ : a‚ÇÅ.coeff 0 ‚â† 0)\n    (ha‚ÇÇ : a‚ÇÇ.coeff 0 ‚â† 0) : ‚àÉ b : k, (succNthDefiningPoly p n a‚ÇÅ a‚ÇÇ bs).IsRoot b :=\n  IsAlgClosed.exists_root _ <| by\n    simp only [succNthDefiningPoly_degree p n a‚ÇÅ a‚ÇÇ bs ha‚ÇÅ ha‚ÇÇ, ne_eq, Nat.cast_eq_zero,\n      hp.out.ne_zero, not_false_eq_true]\n\n"}
{"name":"WittVector.RecursionMain.succNthVal_spec","module":"Mathlib.RingTheory.WittVector.FrobeniusFractionField","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nk : Type u_1\ninst‚úù¬≤ : Field k\ninst‚úù¬π : CharP k p\ninst‚úù : IsAlgClosed k\nn : Nat\na‚ÇÅ a‚ÇÇ : WittVector p k\nbs : Fin (HAdd.hAdd n 1) ‚Üí k\nha‚ÇÅ : Ne (a‚ÇÅ.coeff 0) 0\nha‚ÇÇ : Ne (a‚ÇÇ.coeff 0) 0\n‚ä¢ (WittVector.RecursionMain.succNthDefiningPoly p n a‚ÇÅ a‚ÇÇ bs).IsRoot (WittVector.RecursionMain.succNthVal p n a‚ÇÅ a‚ÇÇ bs ha‚ÇÅ ha‚ÇÇ)","decl":"theorem succNthVal_spec (n : ‚Ñï) (a‚ÇÅ a‚ÇÇ : ùïé k) (bs : Fin (n + 1) ‚Üí k) (ha‚ÇÅ : a‚ÇÅ.coeff 0 ‚â† 0)\n    (ha‚ÇÇ : a‚ÇÇ.coeff 0 ‚â† 0) :\n    (succNthDefiningPoly p n a‚ÇÅ a‚ÇÇ bs).IsRoot (succNthVal p n a‚ÇÅ a‚ÇÇ bs ha‚ÇÅ ha‚ÇÇ) :=\n  Classical.choose_spec (root_exists p n a‚ÇÅ a‚ÇÇ bs ha‚ÇÅ ha‚ÇÇ)\n\n"}
{"name":"WittVector.RecursionMain.succNthVal_spec'","module":"Mathlib.RingTheory.WittVector.FrobeniusFractionField","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nk : Type u_1\ninst‚úù¬≤ : Field k\ninst‚úù¬π : CharP k p\ninst‚úù : IsAlgClosed k\nn : Nat\na‚ÇÅ a‚ÇÇ : WittVector p k\nbs : Fin (HAdd.hAdd n 1) ‚Üí k\nha‚ÇÅ : Ne (a‚ÇÅ.coeff 0) 0\nha‚ÇÇ : Ne (a‚ÇÇ.coeff 0) 0\n‚ä¢ Eq (HAdd.hAdd (HAdd.hAdd (HMul.hMul (HPow.hPow (WittVector.RecursionMain.succNthVal p n a‚ÇÅ a‚ÇÇ bs ha‚ÇÅ ha‚ÇÇ) p) (HPow.hPow (a‚ÇÅ.coeff 0) (HPow.hPow p (HAdd.hAdd n 1)))) (HMul.hMul (a‚ÇÅ.coeff (HAdd.hAdd n 1)) (HPow.hPow (HPow.hPow (bs 0) p) (HPow.hPow p (HAdd.hAdd n 1))))) (WittVector.nthRemainder p n (fun v => HPow.hPow (bs v) p) (WittVector.truncateFun (HAdd.hAdd n 1) a‚ÇÅ))) (HAdd.hAdd (HAdd.hAdd (HMul.hMul (WittVector.RecursionMain.succNthVal p n a‚ÇÅ a‚ÇÇ bs ha‚ÇÅ ha‚ÇÇ) (HPow.hPow (a‚ÇÇ.coeff 0) (HPow.hPow p (HAdd.hAdd n 1)))) (HMul.hMul (a‚ÇÇ.coeff (HAdd.hAdd n 1)) (HPow.hPow (bs 0) (HPow.hPow p (HAdd.hAdd n 1))))) (WittVector.nthRemainder p n bs (WittVector.truncateFun (HAdd.hAdd n 1) a‚ÇÇ)))","decl":"theorem succNthVal_spec' (n : ‚Ñï) (a‚ÇÅ a‚ÇÇ : ùïé k) (bs : Fin (n + 1) ‚Üí k) (ha‚ÇÅ : a‚ÇÅ.coeff 0 ‚â† 0)\n    (ha‚ÇÇ : a‚ÇÇ.coeff 0 ‚â† 0) :\n    succNthVal p n a‚ÇÅ a‚ÇÇ bs ha‚ÇÅ ha‚ÇÇ ^ p * a‚ÇÅ.coeff 0 ^ p ^ (n + 1) +\n          a‚ÇÅ.coeff (n + 1) * (bs 0 ^ p) ^ p ^ (n + 1) +\n        nthRemainder p n (fun v => bs v ^ p) (truncateFun (n + 1) a‚ÇÅ) =\n      succNthVal p n a‚ÇÅ a‚ÇÇ bs ha‚ÇÅ ha‚ÇÇ * a‚ÇÇ.coeff 0 ^ p ^ (n + 1) +\n          a‚ÇÇ.coeff (n + 1) * bs 0 ^ p ^ (n + 1) +\n        nthRemainder p n bs (truncateFun (n + 1) a‚ÇÇ) := by\n  rw [‚Üê sub_eq_zero]\n  have := succNthVal_spec p n a‚ÇÅ a‚ÇÇ bs ha‚ÇÅ ha‚ÇÇ\n  simp only [Polynomial.map_add, Polynomial.eval_X, Polynomial.map_pow, Polynomial.eval_C,\n    Polynomial.eval_pow, succNthDefiningPoly, Polynomial.eval_mul, Polynomial.eval_add,\n    Polynomial.eval_sub, Polynomial.map_mul, Polynomial.map_sub, Polynomial.IsRoot.def]\n    at this\n  convert this using 1\n  ring\n\n"}
{"name":"WittVector.RecursionBase.solution_pow","module":"Mathlib.RingTheory.WittVector.FrobeniusFractionField","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nk : Type u_1\ninst‚úù¬π : Field k\ninst‚úù : IsAlgClosed k\na‚ÇÅ a‚ÇÇ : WittVector p k\n‚ä¢ Exists fun x => Eq (HPow.hPow x (HSub.hSub p 1)) (HDiv.hDiv (a‚ÇÇ.coeff 0) (a‚ÇÅ.coeff 0))","decl":"theorem solution_pow (a‚ÇÅ a‚ÇÇ : ùïé k) : ‚àÉ x : k, x ^ (p - 1) = a‚ÇÇ.coeff 0 / a‚ÇÅ.coeff 0 :=\n  IsAlgClosed.exists_pow_nat_eq _ <| tsub_pos_of_lt hp.out.one_lt\n\n"}
{"name":"WittVector.RecursionBase.solution_spec","module":"Mathlib.RingTheory.WittVector.FrobeniusFractionField","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nk : Type u_1\ninst‚úù¬π : Field k\ninst‚úù : IsAlgClosed k\na‚ÇÅ a‚ÇÇ : WittVector p k\n‚ä¢ Eq (HPow.hPow (WittVector.RecursionBase.solution p a‚ÇÅ a‚ÇÇ) (HSub.hSub p 1)) (HDiv.hDiv (a‚ÇÇ.coeff 0) (a‚ÇÅ.coeff 0))","decl":"theorem solution_spec (a‚ÇÅ a‚ÇÇ : ùïé k) : solution p a‚ÇÅ a‚ÇÇ ^ (p - 1) = a‚ÇÇ.coeff 0 / a‚ÇÅ.coeff 0 :=\n  Classical.choose_spec <| solution_pow p a‚ÇÅ a‚ÇÇ\n\n"}
{"name":"WittVector.RecursionBase.solution_nonzero","module":"Mathlib.RingTheory.WittVector.FrobeniusFractionField","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nk : Type u_1\ninst‚úù¬π : Field k\ninst‚úù : IsAlgClosed k\na‚ÇÅ a‚ÇÇ : WittVector p k\nha‚ÇÅ : Ne (a‚ÇÅ.coeff 0) 0\nha‚ÇÇ : Ne (a‚ÇÇ.coeff 0) 0\n‚ä¢ Ne (WittVector.RecursionBase.solution p a‚ÇÅ a‚ÇÇ) 0","decl":"theorem solution_nonzero {a‚ÇÅ a‚ÇÇ : ùïé k} (ha‚ÇÅ : a‚ÇÅ.coeff 0 ‚â† 0) (ha‚ÇÇ : a‚ÇÇ.coeff 0 ‚â† 0) :\n    solution p a‚ÇÅ a‚ÇÇ ‚â† 0 := by\n  intro h\n  have := solution_spec p a‚ÇÅ a‚ÇÇ\n  rw [h, zero_pow] at this\n  ¬∑ simpa [ha‚ÇÅ, ha‚ÇÇ] using _root_.div_eq_zero_iff.mp this.symm\n  ¬∑ exact Nat.sub_ne_zero_of_lt hp.out.one_lt\n\n"}
{"name":"WittVector.RecursionBase.solution_spec'","module":"Mathlib.RingTheory.WittVector.FrobeniusFractionField","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nk : Type u_1\ninst‚úù¬π : Field k\ninst‚úù : IsAlgClosed k\na‚ÇÅ : WittVector p k\nha‚ÇÅ : Ne (a‚ÇÅ.coeff 0) 0\na‚ÇÇ : WittVector p k\n‚ä¢ Eq (HMul.hMul (HPow.hPow (WittVector.RecursionBase.solution p a‚ÇÅ a‚ÇÇ) p) (a‚ÇÅ.coeff 0)) (HMul.hMul (WittVector.RecursionBase.solution p a‚ÇÅ a‚ÇÇ) (a‚ÇÇ.coeff 0))","decl":"theorem solution_spec' {a‚ÇÅ : ùïé k} (ha‚ÇÅ : a‚ÇÅ.coeff 0 ‚â† 0) (a‚ÇÇ : ùïé k) :\n    solution p a‚ÇÅ a‚ÇÇ ^ p * a‚ÇÅ.coeff 0 = solution p a‚ÇÅ a‚ÇÇ * a‚ÇÇ.coeff 0 := by\n  have := solution_spec p a‚ÇÅ a‚ÇÇ\n  cases' Nat.exists_eq_succ_of_ne_zero hp.out.ne_zero with q hq\n  have hq' : q = p - 1 := by simp only [hq, tsub_zero, Nat.succ_sub_succ_eq_sub]\n  conv_lhs =>\n    congr\n    congr\n    ¬∑ skip\n    ¬∑ rw [hq]\n  rw [pow_succ', hq', this]\n  field_simp [ha‚ÇÅ, mul_comm]\n\n"}
{"name":"WittVector.frobeniusRotation_nonzero","module":"Mathlib.RingTheory.WittVector.FrobeniusFractionField","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nk : Type u_1\ninst‚úù¬≤ : Field k\ninst‚úù¬π : CharP k p\ninst‚úù : IsAlgClosed k\na‚ÇÅ a‚ÇÇ : WittVector p k\nha‚ÇÅ : Ne (a‚ÇÅ.coeff 0) 0\nha‚ÇÇ : Ne (a‚ÇÇ.coeff 0) 0\n‚ä¢ Ne (WittVector.frobeniusRotation p ha‚ÇÅ ha‚ÇÇ) 0","decl":"theorem frobeniusRotation_nonzero {a‚ÇÅ a‚ÇÇ : ùïé k} (ha‚ÇÅ : a‚ÇÅ.coeff 0 ‚â† 0) (ha‚ÇÇ : a‚ÇÇ.coeff 0 ‚â† 0) :\n    frobeniusRotation p ha‚ÇÅ ha‚ÇÇ ‚â† 0 := by\n  intro h\n  apply solution_nonzero p ha‚ÇÅ ha‚ÇÇ\n  simpa [‚Üê h, frobeniusRotation, frobeniusRotationCoeff] using WittVector.zero_coeff p k 0\n\n"}
{"name":"WittVector.frobenius_frobeniusRotation","module":"Mathlib.RingTheory.WittVector.FrobeniusFractionField","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nk : Type u_1\ninst‚úù¬≤ : Field k\ninst‚úù¬π : CharP k p\ninst‚úù : IsAlgClosed k\na‚ÇÅ a‚ÇÇ : WittVector p k\nha‚ÇÅ : Ne (a‚ÇÅ.coeff 0) 0\nha‚ÇÇ : Ne (a‚ÇÇ.coeff 0) 0\n‚ä¢ Eq (HMul.hMul (WittVector.frobenius (WittVector.frobeniusRotation p ha‚ÇÅ ha‚ÇÇ)) a‚ÇÅ) (HMul.hMul (WittVector.frobeniusRotation p ha‚ÇÅ ha‚ÇÇ) a‚ÇÇ)","decl":"theorem frobenius_frobeniusRotation {a‚ÇÅ a‚ÇÇ : ùïé k} (ha‚ÇÅ : a‚ÇÅ.coeff 0 ‚â† 0) (ha‚ÇÇ : a‚ÇÇ.coeff 0 ‚â† 0) :\n    frobenius (frobeniusRotation p ha‚ÇÅ ha‚ÇÇ) * a‚ÇÅ = frobeniusRotation p ha‚ÇÅ ha‚ÇÇ * a‚ÇÇ := by\n  ext n\n  cases' n with n\n  ¬∑ simp only [WittVector.mul_coeff_zero, WittVector.coeff_frobenius_charP, frobeniusRotation,\n      frobeniusRotationCoeff]\n    apply solution_spec' _ ha‚ÇÅ\n  ¬∑ simp only [nthRemainder_spec, WittVector.coeff_frobenius_charP, frobeniusRotationCoeff,\n      frobeniusRotation]\n    have :=\n      succNthVal_spec' p n a‚ÇÅ a‚ÇÇ (fun i : Fin (n + 1) => frobeniusRotationCoeff p ha‚ÇÅ ha‚ÇÇ i.val)\n        ha‚ÇÅ ha‚ÇÇ\n    simp only [frobeniusRotationCoeff, Fin.val_zero] at this\n    convert this using 3\n    apply TruncatedWittVector.ext\n    intro i\n    simp only [WittVector.coeff_truncateFun, WittVector.coeff_frobenius_charP]\n    rfl\n\n"}
{"name":"WittVector.exists_frobenius_solution_fractionRing_aux","module":"Mathlib.RingTheory.WittVector.FrobeniusFractionField","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nk : Type u_1\ninst‚úù¬≤ : Field k\ninst‚úù¬π : CharP k p\ninst‚úù : IsAlgClosed k\nm n : Nat\nr' q' : WittVector p k\nhr' : Ne (r'.coeff 0) 0\nhq' : Ne (q'.coeff 0) 0\nhq : Membership.mem (nonZeroDivisors (WittVector p k)) (HMul.hMul (HPow.hPow (‚Üëp) n) q')\n‚ä¢ let b := WittVector.frobeniusRotation p hr' hq';\n  Eq (HMul.hMul ((IsFractionRing.ringEquivOfRingEquiv (WittVector.frobeniusEquiv p k)) ((algebraMap (WittVector p k) (FractionRing (WittVector p k))) b)) (Localization.mk (HMul.hMul (HPow.hPow (‚Üëp) m) r') ‚ü®HMul.hMul (HPow.hPow (‚Üëp) n) q', hq‚ü©)) (HMul.hMul (HPow.hPow (‚Üëp) (HSub.hSub ‚Üëm ‚Üën)) ((algebraMap (WittVector p k) (FractionRing (WittVector p k))) b))","decl":"theorem exists_frobenius_solution_fractionRing_aux (m n : ‚Ñï) (r' q' : ùïé k) (hr' : r'.coeff 0 ‚â† 0)\n    (hq' : q'.coeff 0 ‚â† 0) (hq : (p : ùïé k) ^ n * q' ‚àà nonZeroDivisors (ùïé k)) :\n    let b : ùïé k := frobeniusRotation p hr' hq'\n    IsFractionRing.ringEquivOfRingEquiv (frobeniusEquiv p k)\n          (algebraMap (ùïé k) (FractionRing (ùïé k)) b) *\n        Localization.mk ((p : ùïé k) ^ m * r') ‚ü®(p : ùïé k) ^ n * q', hq‚ü© =\n      (p : Localization (nonZeroDivisors (ùïé k))) ^ (m - n : ‚Ñ§) *\n        algebraMap (ùïé k) (FractionRing (ùïé k)) b := by\n  intro b\n  have key : WittVector.frobenius b * (p : ùïé k) ^ m * r' * (p : ùïé k) ^ n =\n      (p : ùïé k) ^ m * b * ((p : ùïé k) ^ n * q') := by\n    have H := congr_arg (fun x : ùïé k => x * (p : ùïé k) ^ m * (p : ùïé k) ^ n)\n      (frobenius_frobeniusRotation p hr' hq')\n    dsimp at H\n    refine (Eq.trans ?_ H).trans ?_ <;> ring\n  have hq'' : algebraMap (ùïé k) (FractionRing (ùïé k)) q' ‚â† 0 := by\n    have hq''' : q' ‚â† 0 := fun h => hq' (by simp [h])\n    simpa only [Ne, map_zero] using\n      (IsFractionRing.injective (ùïé k) (FractionRing (ùïé k))).ne hq'''\n  rw [zpow_sub‚ÇÄ (FractionRing.p_nonzero p k)]\n  field_simp [FractionRing.p_nonzero p k]\n  convert congr_arg (fun x => algebraMap (ùïé k) (FractionRing (ùïé k)) x) key using 1\n  ¬∑ simp only [RingHom.map_mul, RingHom.map_pow, map_natCast, frobeniusEquiv_apply]\n    ring\n  ¬∑ simp only [RingHom.map_mul, RingHom.map_pow, map_natCast]\n\n"}
{"name":"WittVector.exists_frobenius_solution_fractionRing","module":"Mathlib.RingTheory.WittVector.FrobeniusFractionField","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nk : Type u_1\ninst‚úù¬≤ : Field k\ninst‚úù¬π : CharP k p\ninst‚úù : IsAlgClosed k\na : FractionRing (WittVector p k)\nha : Ne a 0\n‚ä¢ Exists fun b => And (Ne b 0) (Exists fun m => Eq (HMul.hMul ((IsFractionRing.ringEquivOfRingEquiv (WittVector.frobeniusEquiv p k)) b) a) (HMul.hMul (HPow.hPow (‚Üëp) m) b))","decl":"theorem exists_frobenius_solution_fractionRing {a : FractionRing (ùïé k)} (ha : a ‚â† 0) :\n    ‚àÉ·µâ (b ‚â† 0) (m : ‚Ñ§), œÜ b * a = (p : FractionRing (ùïé k)) ^ m * b := by\n  revert ha\n  refine Localization.induction_on a ?_\n  rintro ‚ü®r, q, hq‚ü© hrq\n  have hq0 : q ‚â† 0 := mem_nonZeroDivisors_iff_ne_zero.1 hq\n  have hr0 : r ‚â† 0 := fun h => hrq (by simp [h])\n  obtain ‚ü®m, r', hr', rfl‚ü© := exists_eq_pow_p_mul r hr0\n  obtain ‚ü®n, q', hq', rfl‚ü© := exists_eq_pow_p_mul q hq0\n  let b := frobeniusRotation p hr' hq'\n  refine ‚ü®algebraMap (ùïé k) (FractionRing (ùïé k)) b, ?_, m - n, ?_‚ü©\n  ¬∑ simpa only [map_zero] using\n      (IsFractionRing.injective (WittVector p k) (FractionRing (WittVector p k))).ne\n        (frobeniusRotation_nonzero p hr' hq')\n  exact exists_frobenius_solution_fractionRing_aux p m n r' q' hr' hq' hq\n\n"}
