{"name":"WittVector.RecursionMain.succNthDefiningPoly_degree","module":"Mathlib.RingTheory.WittVector.FrobeniusFractionField","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nk : Type u_1\ninstâœÂ² : CommRing k\ninstâœÂ¹ : CharP k p\ninstâœ : IsDomain k\nn : Nat\naâ‚ aâ‚‚ : WittVector p k\nbs : Fin (HAdd.hAdd n 1) â†’ k\nhaâ‚ : Ne (aâ‚.coeff 0) 0\nhaâ‚‚ : Ne (aâ‚‚.coeff 0) 0\nâŠ¢ Eq (WittVector.RecursionMain.succNthDefiningPoly p n aâ‚ aâ‚‚ bs).degree â†‘p","decl":"theorem succNthDefiningPoly_degree [IsDomain k] (n : â„•) (aâ‚ aâ‚‚ : ğ• k) (bs : Fin (n + 1) â†’ k)\n    (haâ‚ : aâ‚.coeff 0 â‰  0) (haâ‚‚ : aâ‚‚.coeff 0 â‰  0) :\n    (succNthDefiningPoly p n aâ‚ aâ‚‚ bs).degree = p := by\n  have : (X ^ p * C (aâ‚.coeff 0 ^ p ^ (n + 1))).degree = (p : WithBot â„•) := by\n    rw [degree_mul, degree_C]\n    Â· simp only [Nat.cast_withBot, add_zero, degree_X, degree_pow, Nat.smul_one_eq_cast]\n    Â· exact pow_ne_zero _ haâ‚\n  have : (X ^ p * C (aâ‚.coeff 0 ^ p ^ (n + 1)) - X * C (aâ‚‚.coeff 0 ^ p ^ (n + 1))).degree =\n      (p : WithBot â„•) := by\n    rw [degree_sub_eq_left_of_degree_lt, this]\n    rw [this, degree_mul, degree_C, degree_X, add_zero]\n    Â· exact mod_cast hp.out.one_lt\n    Â· exact pow_ne_zero _ haâ‚‚\n  rw [succNthDefiningPoly, degree_add_eq_left_of_degree_lt, this]\n  apply lt_of_le_of_lt degree_C_le\n  rw [this]\n  exact mod_cast hp.out.pos\n\n"}
{"name":"WittVector.RecursionMain.root_exists","module":"Mathlib.RingTheory.WittVector.FrobeniusFractionField","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nk : Type u_1\ninstâœÂ² : Field k\ninstâœÂ¹ : CharP k p\ninstâœ : IsAlgClosed k\nn : Nat\naâ‚ aâ‚‚ : WittVector p k\nbs : Fin (HAdd.hAdd n 1) â†’ k\nhaâ‚ : Ne (aâ‚.coeff 0) 0\nhaâ‚‚ : Ne (aâ‚‚.coeff 0) 0\nâŠ¢ Exists fun b => (WittVector.RecursionMain.succNthDefiningPoly p n aâ‚ aâ‚‚ bs).IsRoot b","decl":"theorem root_exists (n : â„•) (aâ‚ aâ‚‚ : ğ• k) (bs : Fin (n + 1) â†’ k) (haâ‚ : aâ‚.coeff 0 â‰  0)\n    (haâ‚‚ : aâ‚‚.coeff 0 â‰  0) : âˆƒ b : k, (succNthDefiningPoly p n aâ‚ aâ‚‚ bs).IsRoot b :=\n  IsAlgClosed.exists_root _ <| by\n    simp only [succNthDefiningPoly_degree p n aâ‚ aâ‚‚ bs haâ‚ haâ‚‚, ne_eq, Nat.cast_eq_zero,\n      hp.out.ne_zero, not_false_eq_true]\n\n"}
{"name":"WittVector.RecursionMain.succNthVal_spec","module":"Mathlib.RingTheory.WittVector.FrobeniusFractionField","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nk : Type u_1\ninstâœÂ² : Field k\ninstâœÂ¹ : CharP k p\ninstâœ : IsAlgClosed k\nn : Nat\naâ‚ aâ‚‚ : WittVector p k\nbs : Fin (HAdd.hAdd n 1) â†’ k\nhaâ‚ : Ne (aâ‚.coeff 0) 0\nhaâ‚‚ : Ne (aâ‚‚.coeff 0) 0\nâŠ¢ (WittVector.RecursionMain.succNthDefiningPoly p n aâ‚ aâ‚‚ bs).IsRoot (WittVector.RecursionMain.succNthVal p n aâ‚ aâ‚‚ bs haâ‚ haâ‚‚)","decl":"theorem succNthVal_spec (n : â„•) (aâ‚ aâ‚‚ : ğ• k) (bs : Fin (n + 1) â†’ k) (haâ‚ : aâ‚.coeff 0 â‰  0)\n    (haâ‚‚ : aâ‚‚.coeff 0 â‰  0) :\n    (succNthDefiningPoly p n aâ‚ aâ‚‚ bs).IsRoot (succNthVal p n aâ‚ aâ‚‚ bs haâ‚ haâ‚‚) :=\n  Classical.choose_spec (root_exists p n aâ‚ aâ‚‚ bs haâ‚ haâ‚‚)\n\n"}
{"name":"WittVector.RecursionMain.succNthVal_spec'","module":"Mathlib.RingTheory.WittVector.FrobeniusFractionField","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nk : Type u_1\ninstâœÂ² : Field k\ninstâœÂ¹ : CharP k p\ninstâœ : IsAlgClosed k\nn : Nat\naâ‚ aâ‚‚ : WittVector p k\nbs : Fin (HAdd.hAdd n 1) â†’ k\nhaâ‚ : Ne (aâ‚.coeff 0) 0\nhaâ‚‚ : Ne (aâ‚‚.coeff 0) 0\nâŠ¢ Eq (HAdd.hAdd (HAdd.hAdd (HMul.hMul (HPow.hPow (WittVector.RecursionMain.succNthVal p n aâ‚ aâ‚‚ bs haâ‚ haâ‚‚) p) (HPow.hPow (aâ‚.coeff 0) (HPow.hPow p (HAdd.hAdd n 1)))) (HMul.hMul (aâ‚.coeff (HAdd.hAdd n 1)) (HPow.hPow (HPow.hPow (bs 0) p) (HPow.hPow p (HAdd.hAdd n 1))))) (WittVector.nthRemainder p n (fun v => HPow.hPow (bs v) p) (WittVector.truncateFun (HAdd.hAdd n 1) aâ‚))) (HAdd.hAdd (HAdd.hAdd (HMul.hMul (WittVector.RecursionMain.succNthVal p n aâ‚ aâ‚‚ bs haâ‚ haâ‚‚) (HPow.hPow (aâ‚‚.coeff 0) (HPow.hPow p (HAdd.hAdd n 1)))) (HMul.hMul (aâ‚‚.coeff (HAdd.hAdd n 1)) (HPow.hPow (bs 0) (HPow.hPow p (HAdd.hAdd n 1))))) (WittVector.nthRemainder p n bs (WittVector.truncateFun (HAdd.hAdd n 1) aâ‚‚)))","decl":"theorem succNthVal_spec' (n : â„•) (aâ‚ aâ‚‚ : ğ• k) (bs : Fin (n + 1) â†’ k) (haâ‚ : aâ‚.coeff 0 â‰  0)\n    (haâ‚‚ : aâ‚‚.coeff 0 â‰  0) :\n    succNthVal p n aâ‚ aâ‚‚ bs haâ‚ haâ‚‚ ^ p * aâ‚.coeff 0 ^ p ^ (n + 1) +\n          aâ‚.coeff (n + 1) * (bs 0 ^ p) ^ p ^ (n + 1) +\n        nthRemainder p n (fun v => bs v ^ p) (truncateFun (n + 1) aâ‚) =\n      succNthVal p n aâ‚ aâ‚‚ bs haâ‚ haâ‚‚ * aâ‚‚.coeff 0 ^ p ^ (n + 1) +\n          aâ‚‚.coeff (n + 1) * bs 0 ^ p ^ (n + 1) +\n        nthRemainder p n bs (truncateFun (n + 1) aâ‚‚) := by\n  rw [â† sub_eq_zero]\n  have := succNthVal_spec p n aâ‚ aâ‚‚ bs haâ‚ haâ‚‚\n  simp only [Polynomial.map_add, Polynomial.eval_X, Polynomial.map_pow, Polynomial.eval_C,\n    Polynomial.eval_pow, succNthDefiningPoly, Polynomial.eval_mul, Polynomial.eval_add,\n    Polynomial.eval_sub, Polynomial.map_mul, Polynomial.map_sub, Polynomial.IsRoot.def]\n    at this\n  convert this using 1\n  ring\n\n"}
{"name":"WittVector.RecursionBase.solution_pow","module":"Mathlib.RingTheory.WittVector.FrobeniusFractionField","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nk : Type u_1\ninstâœÂ¹ : Field k\ninstâœ : IsAlgClosed k\naâ‚ aâ‚‚ : WittVector p k\nâŠ¢ Exists fun x => Eq (HPow.hPow x (HSub.hSub p 1)) (HDiv.hDiv (aâ‚‚.coeff 0) (aâ‚.coeff 0))","decl":"theorem solution_pow (aâ‚ aâ‚‚ : ğ• k) : âˆƒ x : k, x ^ (p - 1) = aâ‚‚.coeff 0 / aâ‚.coeff 0 :=\n  IsAlgClosed.exists_pow_nat_eq _ <| tsub_pos_of_lt hp.out.one_lt\n\n"}
{"name":"WittVector.RecursionBase.solution_spec","module":"Mathlib.RingTheory.WittVector.FrobeniusFractionField","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nk : Type u_1\ninstâœÂ¹ : Field k\ninstâœ : IsAlgClosed k\naâ‚ aâ‚‚ : WittVector p k\nâŠ¢ Eq (HPow.hPow (WittVector.RecursionBase.solution p aâ‚ aâ‚‚) (HSub.hSub p 1)) (HDiv.hDiv (aâ‚‚.coeff 0) (aâ‚.coeff 0))","decl":"theorem solution_spec (aâ‚ aâ‚‚ : ğ• k) : solution p aâ‚ aâ‚‚ ^ (p - 1) = aâ‚‚.coeff 0 / aâ‚.coeff 0 :=\n  Classical.choose_spec <| solution_pow p aâ‚ aâ‚‚\n\n"}
{"name":"WittVector.RecursionBase.solution_nonzero","module":"Mathlib.RingTheory.WittVector.FrobeniusFractionField","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nk : Type u_1\ninstâœÂ¹ : Field k\ninstâœ : IsAlgClosed k\naâ‚ aâ‚‚ : WittVector p k\nhaâ‚ : Ne (aâ‚.coeff 0) 0\nhaâ‚‚ : Ne (aâ‚‚.coeff 0) 0\nâŠ¢ Ne (WittVector.RecursionBase.solution p aâ‚ aâ‚‚) 0","decl":"theorem solution_nonzero {aâ‚ aâ‚‚ : ğ• k} (haâ‚ : aâ‚.coeff 0 â‰  0) (haâ‚‚ : aâ‚‚.coeff 0 â‰  0) :\n    solution p aâ‚ aâ‚‚ â‰  0 := by\n  intro h\n  have := solution_spec p aâ‚ aâ‚‚\n  rw [h, zero_pow] at this\n  Â· simpa [haâ‚, haâ‚‚] using _root_.div_eq_zero_iff.mp this.symm\n  Â· exact Nat.sub_ne_zero_of_lt hp.out.one_lt\n\n"}
{"name":"WittVector.RecursionBase.solution_spec'","module":"Mathlib.RingTheory.WittVector.FrobeniusFractionField","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nk : Type u_1\ninstâœÂ¹ : Field k\ninstâœ : IsAlgClosed k\naâ‚ : WittVector p k\nhaâ‚ : Ne (aâ‚.coeff 0) 0\naâ‚‚ : WittVector p k\nâŠ¢ Eq (HMul.hMul (HPow.hPow (WittVector.RecursionBase.solution p aâ‚ aâ‚‚) p) (aâ‚.coeff 0)) (HMul.hMul (WittVector.RecursionBase.solution p aâ‚ aâ‚‚) (aâ‚‚.coeff 0))","decl":"theorem solution_spec' {aâ‚ : ğ• k} (haâ‚ : aâ‚.coeff 0 â‰  0) (aâ‚‚ : ğ• k) :\n    solution p aâ‚ aâ‚‚ ^ p * aâ‚.coeff 0 = solution p aâ‚ aâ‚‚ * aâ‚‚.coeff 0 := by\n  have := solution_spec p aâ‚ aâ‚‚\n  cases' Nat.exists_eq_succ_of_ne_zero hp.out.ne_zero with q hq\n  have hq' : q = p - 1 := by simp only [hq, tsub_zero, Nat.succ_sub_succ_eq_sub]\n  conv_lhs =>\n    congr\n    congr\n    Â· skip\n    Â· rw [hq]\n  rw [pow_succ', hq', this]\n  field_simp [haâ‚, mul_comm]\n\n"}
{"name":"WittVector.frobeniusRotation_nonzero","module":"Mathlib.RingTheory.WittVector.FrobeniusFractionField","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nk : Type u_1\ninstâœÂ² : Field k\ninstâœÂ¹ : CharP k p\ninstâœ : IsAlgClosed k\naâ‚ aâ‚‚ : WittVector p k\nhaâ‚ : Ne (aâ‚.coeff 0) 0\nhaâ‚‚ : Ne (aâ‚‚.coeff 0) 0\nâŠ¢ Ne (WittVector.frobeniusRotation p haâ‚ haâ‚‚) 0","decl":"theorem frobeniusRotation_nonzero {aâ‚ aâ‚‚ : ğ• k} (haâ‚ : aâ‚.coeff 0 â‰  0) (haâ‚‚ : aâ‚‚.coeff 0 â‰  0) :\n    frobeniusRotation p haâ‚ haâ‚‚ â‰  0 := by\n  intro h\n  apply solution_nonzero p haâ‚ haâ‚‚\n  simpa [â† h, frobeniusRotation, frobeniusRotationCoeff] using WittVector.zero_coeff p k 0\n\n"}
{"name":"WittVector.frobenius_frobeniusRotation","module":"Mathlib.RingTheory.WittVector.FrobeniusFractionField","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nk : Type u_1\ninstâœÂ² : Field k\ninstâœÂ¹ : CharP k p\ninstâœ : IsAlgClosed k\naâ‚ aâ‚‚ : WittVector p k\nhaâ‚ : Ne (aâ‚.coeff 0) 0\nhaâ‚‚ : Ne (aâ‚‚.coeff 0) 0\nâŠ¢ Eq (HMul.hMul (WittVector.frobenius (WittVector.frobeniusRotation p haâ‚ haâ‚‚)) aâ‚) (HMul.hMul (WittVector.frobeniusRotation p haâ‚ haâ‚‚) aâ‚‚)","decl":"theorem frobenius_frobeniusRotation {aâ‚ aâ‚‚ : ğ• k} (haâ‚ : aâ‚.coeff 0 â‰  0) (haâ‚‚ : aâ‚‚.coeff 0 â‰  0) :\n    frobenius (frobeniusRotation p haâ‚ haâ‚‚) * aâ‚ = frobeniusRotation p haâ‚ haâ‚‚ * aâ‚‚ := by\n  ext n\n  cases' n with n\n  Â· simp only [WittVector.mul_coeff_zero, WittVector.coeff_frobenius_charP, frobeniusRotation,\n      frobeniusRotationCoeff]\n    apply solution_spec' _ haâ‚\n  Â· simp only [nthRemainder_spec, WittVector.coeff_frobenius_charP, frobeniusRotationCoeff,\n      frobeniusRotation]\n    have :=\n      succNthVal_spec' p n aâ‚ aâ‚‚ (fun i : Fin (n + 1) => frobeniusRotationCoeff p haâ‚ haâ‚‚ i.val)\n        haâ‚ haâ‚‚\n    simp only [frobeniusRotationCoeff, Fin.val_zero] at this\n    convert this using 3\n    apply TruncatedWittVector.ext\n    intro i\n    simp only [WittVector.coeff_truncateFun, WittVector.coeff_frobenius_charP]\n    rfl\n\n"}
{"name":"WittVector.exists_frobenius_solution_fractionRing_aux","module":"Mathlib.RingTheory.WittVector.FrobeniusFractionField","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nk : Type u_1\ninstâœÂ² : Field k\ninstâœÂ¹ : CharP k p\ninstâœ : IsAlgClosed k\nm n : Nat\nr' q' : WittVector p k\nhr' : Ne (r'.coeff 0) 0\nhq' : Ne (q'.coeff 0) 0\nhq : Membership.mem (nonZeroDivisors (WittVector p k)) (HMul.hMul (HPow.hPow (â†‘p) n) q')\nâŠ¢ let b := WittVector.frobeniusRotation p hr' hq';\n  Eq (HMul.hMul ((IsFractionRing.ringEquivOfRingEquiv (WittVector.frobeniusEquiv p k)) ((algebraMap (WittVector p k) (FractionRing (WittVector p k))) b)) (Localization.mk (HMul.hMul (HPow.hPow (â†‘p) m) r') âŸ¨HMul.hMul (HPow.hPow (â†‘p) n) q', hqâŸ©)) (HMul.hMul (HPow.hPow (â†‘p) (HSub.hSub â†‘m â†‘n)) ((algebraMap (WittVector p k) (FractionRing (WittVector p k))) b))","decl":"theorem exists_frobenius_solution_fractionRing_aux (m n : â„•) (r' q' : ğ• k) (hr' : r'.coeff 0 â‰  0)\n    (hq' : q'.coeff 0 â‰  0) (hq : (p : ğ• k) ^ n * q' âˆˆ nonZeroDivisors (ğ• k)) :\n    let b : ğ• k := frobeniusRotation p hr' hq'\n    IsFractionRing.ringEquivOfRingEquiv (frobeniusEquiv p k)\n          (algebraMap (ğ• k) (FractionRing (ğ• k)) b) *\n        Localization.mk ((p : ğ• k) ^ m * r') âŸ¨(p : ğ• k) ^ n * q', hqâŸ© =\n      (p : Localization (nonZeroDivisors (ğ• k))) ^ (m - n : â„¤) *\n        algebraMap (ğ• k) (FractionRing (ğ• k)) b := by\n  intro b\n  have key : WittVector.frobenius b * (p : ğ• k) ^ m * r' * (p : ğ• k) ^ n =\n      (p : ğ• k) ^ m * b * ((p : ğ• k) ^ n * q') := by\n    have H := congr_arg (fun x : ğ• k => x * (p : ğ• k) ^ m * (p : ğ• k) ^ n)\n      (frobenius_frobeniusRotation p hr' hq')\n    dsimp at H\n    refine (Eq.trans ?_ H).trans ?_ <;> ring\n  have hq'' : algebraMap (ğ• k) (FractionRing (ğ• k)) q' â‰  0 := by\n    have hq''' : q' â‰  0 := fun h => hq' (by simp [h])\n    simpa only [Ne, map_zero] using\n      (IsFractionRing.injective (ğ• k) (FractionRing (ğ• k))).ne hq'''\n  rw [zpow_subâ‚€ (FractionRing.p_nonzero p k)]\n  field_simp [FractionRing.p_nonzero p k]\n  convert congr_arg (fun x => algebraMap (ğ• k) (FractionRing (ğ• k)) x) key using 1\n  Â· simp only [RingHom.map_mul, RingHom.map_pow, map_natCast, frobeniusEquiv_apply]\n    ring\n  Â· simp only [RingHom.map_mul, RingHom.map_pow, map_natCast]\n\n"}
{"name":"WittVector.exists_frobenius_solution_fractionRing","module":"Mathlib.RingTheory.WittVector.FrobeniusFractionField","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nk : Type u_1\ninstâœÂ² : Field k\ninstâœÂ¹ : CharP k p\ninstâœ : IsAlgClosed k\na : FractionRing (WittVector p k)\nha : Ne a 0\nâŠ¢ Exists fun b => And (Ne b 0) (Exists fun m => Eq (HMul.hMul ((IsFractionRing.ringEquivOfRingEquiv (WittVector.frobeniusEquiv p k)) b) a) (HMul.hMul (HPow.hPow (â†‘p) m) b))","decl":"theorem exists_frobenius_solution_fractionRing {a : FractionRing (ğ• k)} (ha : a â‰  0) :\n    âˆƒáµ‰ (b â‰  0) (m : â„¤), Ï† b * a = (p : FractionRing (ğ• k)) ^ m * b := by\n  revert ha\n  refine Localization.induction_on a ?_\n  rintro âŸ¨r, q, hqâŸ© hrq\n  have hq0 : q â‰  0 := mem_nonZeroDivisors_iff_ne_zero.1 hq\n  have hr0 : r â‰  0 := fun h => hrq (by simp [h])\n  obtain âŸ¨m, r', hr', rflâŸ© := exists_eq_pow_p_mul r hr0\n  obtain âŸ¨n, q', hq', rflâŸ© := exists_eq_pow_p_mul q hq0\n  let b := frobeniusRotation p hr' hq'\n  refine âŸ¨algebraMap (ğ• k) (FractionRing (ğ• k)) b, ?_, m - n, ?_âŸ©\n  Â· simpa only [map_zero] using\n      (IsFractionRing.injective (WittVector p k) (FractionRing (WittVector p k))).ne\n        (frobeniusRotation_nonzero p hr' hq')\n  exact exists_frobenius_solution_fractionRing_aux p m n r' q' hr' hq' hq\n\n"}
