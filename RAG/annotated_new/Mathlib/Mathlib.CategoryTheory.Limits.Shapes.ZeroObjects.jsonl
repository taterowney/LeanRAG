{"name":"CategoryTheory.Limits.IsZero.unique_to","module":"Mathlib.CategoryTheory.Limits.Shapes.ZeroObjects","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : C\nself : CategoryTheory.Limits.IsZero X\nY : C\n‚ä¢ Nonempty (Unique (Quiver.Hom X Y))","decl":"/-- An object `X` in a category is a *zero object* if for every object `Y`\nthere is a unique morphism `to : X ‚Üí Y` and a unique morphism `from : Y ‚Üí X`.\n\nThis is a characteristic predicate for `has_zero_object`. -/\nstructure IsZero (X : C) : Prop where\n  /-- there are unique morphisms to the object -/\n  unique_to : ‚àÄ Y, Nonempty (Unique (X ‚ü∂ Y))\n  /-- there are unique morphisms from the object -/\n  unique_from : ‚àÄ Y, Nonempty (Unique (Y ‚ü∂ X))\n\n"}
{"name":"CategoryTheory.Limits.IsZero.unique_from","module":"Mathlib.CategoryTheory.Limits.Shapes.ZeroObjects","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : C\nself : CategoryTheory.Limits.IsZero X\nY : C\n‚ä¢ Nonempty (Unique (Quiver.Hom Y X))","decl":"/-- An object `X` in a category is a *zero object* if for every object `Y`\nthere is a unique morphism `to : X ‚Üí Y` and a unique morphism `from : Y ‚Üí X`.\n\nThis is a characteristic predicate for `has_zero_object`. -/\nstructure IsZero (X : C) : Prop where\n  /-- there are unique morphisms to the object -/\n  unique_to : ‚àÄ Y, Nonempty (Unique (X ‚ü∂ Y))\n  /-- there are unique morphisms from the object -/\n  unique_from : ‚àÄ Y, Nonempty (Unique (Y ‚ü∂ X))\n\n"}
{"name":"CategoryTheory.Limits.IsZero.eq_to","module":"Mathlib.CategoryTheory.Limits.Shapes.ZeroObjects","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nh : CategoryTheory.Limits.IsZero X\nf : Quiver.Hom X Y\n‚ä¢ Eq f (h.to_ Y)","decl":"theorem eq_to (h : IsZero X) (f : X ‚ü∂ Y) : f = h.to_ Y :=\n  @Unique.eq_default _ (id _) _\n\n"}
{"name":"CategoryTheory.Limits.IsZero.to_eq","module":"Mathlib.CategoryTheory.Limits.Shapes.ZeroObjects","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nh : CategoryTheory.Limits.IsZero X\nf : Quiver.Hom X Y\n‚ä¢ Eq (h.to_ Y) f","decl":"theorem to_eq (h : IsZero X) (f : X ‚ü∂ Y) : h.to_ Y = f :=\n  (h.eq_to f).symm\n\n-- Porting note: `from` is a reserved word, it was replaced by `from_`\n"}
{"name":"CategoryTheory.Limits.IsZero.eq_from","module":"Mathlib.CategoryTheory.Limits.Shapes.ZeroObjects","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nh : CategoryTheory.Limits.IsZero X\nf : Quiver.Hom Y X\n‚ä¢ Eq f (h.from_ Y)","decl":"theorem eq_from (h : IsZero X) (f : Y ‚ü∂ X) : f = h.from_ Y :=\n  @Unique.eq_default _ (id _) _\n\n"}
{"name":"CategoryTheory.Limits.IsZero.from_eq","module":"Mathlib.CategoryTheory.Limits.Shapes.ZeroObjects","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nh : CategoryTheory.Limits.IsZero X\nf : Quiver.Hom Y X\n‚ä¢ Eq (h.from_ Y) f","decl":"theorem from_eq (h : IsZero X) (f : Y ‚ü∂ X) : h.from_ Y = f :=\n  (h.eq_from f).symm\n\n"}
{"name":"CategoryTheory.Limits.IsZero.eq_of_src","module":"Mathlib.CategoryTheory.Limits.Shapes.ZeroObjects","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nhX : CategoryTheory.Limits.IsZero X\nf g : Quiver.Hom X Y\n‚ä¢ Eq f g","decl":"theorem eq_of_src (hX : IsZero X) (f g : X ‚ü∂ Y) : f = g :=\n  (hX.eq_to f).trans (hX.eq_to g).symm\n\n"}
{"name":"CategoryTheory.Limits.IsZero.eq_of_tgt","module":"Mathlib.CategoryTheory.Limits.Shapes.ZeroObjects","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nhX : CategoryTheory.Limits.IsZero X\nf g : Quiver.Hom Y X\n‚ä¢ Eq f g","decl":"theorem eq_of_tgt (hX : IsZero X) (f g : Y ‚ü∂ X) : f = g :=\n  (hX.eq_from f).trans (hX.eq_from g).symm\n\n"}
{"name":"CategoryTheory.Limits.IsZero.epi","module":"Mathlib.CategoryTheory.Limits.Shapes.ZeroObjects","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : C\nh : CategoryTheory.Limits.IsZero X\nY : C\nf : Quiver.Hom Y X\n‚ä¢ CategoryTheory.Epi f","decl":"lemma epi (h : IsZero X) {Y : C} (f : Y ‚ü∂ X) : Epi f where\n  left_cancellation _ _ _ := h.eq_of_src _ _\n\n"}
{"name":"CategoryTheory.Limits.IsZero.mono","module":"Mathlib.CategoryTheory.Limits.Shapes.ZeroObjects","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : C\nh : CategoryTheory.Limits.IsZero X\nY : C\nf : Quiver.Hom X Y\n‚ä¢ CategoryTheory.Mono f","decl":"lemma mono (h : IsZero X) {Y : C} (f : X ‚ü∂ Y) : Mono f where\n  right_cancellation _ _ _ := h.eq_of_tgt _ _\n\n"}
{"name":"CategoryTheory.Limits.IsZero.of_iso","module":"Mathlib.CategoryTheory.Limits.Shapes.ZeroObjects","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nhY : CategoryTheory.Limits.IsZero Y\ne : CategoryTheory.Iso X Y\n‚ä¢ CategoryTheory.Limits.IsZero X","decl":"theorem of_iso (hY : IsZero Y) (e : X ‚âÖ Y) : IsZero X := by\n  refine ‚ü®fun Z => ‚ü®‚ü®‚ü®e.hom ‚â´ hY.to_ Z‚ü©, fun f => ?_‚ü©‚ü©,\n    fun Z => ‚ü®‚ü®‚ü®hY.from_ Z ‚â´ e.inv‚ü©, fun f => ?_‚ü©‚ü©‚ü©\n  ¬∑ rw [‚Üê cancel_epi e.inv]\n    apply hY.eq_of_src\n  ¬∑ rw [‚Üê cancel_mono e.hom]\n    apply hY.eq_of_tgt\n\n"}
{"name":"CategoryTheory.Limits.IsZero.op","module":"Mathlib.CategoryTheory.Limits.Shapes.ZeroObjects","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : C\nh : CategoryTheory.Limits.IsZero X\n‚ä¢ CategoryTheory.Limits.IsZero { unop := X }","decl":"theorem op (h : IsZero X) : IsZero (Opposite.op X) :=\n  ‚ü®fun Y => ‚ü®‚ü®‚ü®(h.from_ (Opposite.unop Y)).op‚ü©, fun _ => Quiver.Hom.unop_inj (h.eq_of_tgt _ _)‚ü©‚ü©,\n    fun Y => ‚ü®‚ü®‚ü®(h.to_ (Opposite.unop Y)).op‚ü©, fun _ => Quiver.Hom.unop_inj (h.eq_of_src _ _)‚ü©‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.Limits.IsZero.unop","module":"Mathlib.CategoryTheory.Limits.Shapes.ZeroObjects","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : Opposite C\nh : CategoryTheory.Limits.IsZero X\n‚ä¢ CategoryTheory.Limits.IsZero (Opposite.unop X)","decl":"theorem unop {X : C·µí·µñ} (h : IsZero X) : IsZero (Opposite.unop X) :=\n  ‚ü®fun Y => ‚ü®‚ü®‚ü®(h.from_ (Opposite.op Y)).unop‚ü©, fun _ => Quiver.Hom.op_inj (h.eq_of_tgt _ _)‚ü©‚ü©,\n    fun Y => ‚ü®‚ü®‚ü®(h.to_ (Opposite.op Y)).unop‚ü©, fun _ => Quiver.Hom.op_inj (h.eq_of_src _ _)‚ü©‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.Iso.isZero_iff","module":"Mathlib.CategoryTheory.Limits.Shapes.ZeroObjects","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\ne : CategoryTheory.Iso X Y\n‚ä¢ Iff (CategoryTheory.Limits.IsZero X) (CategoryTheory.Limits.IsZero Y)","decl":"theorem Iso.isZero_iff {X Y : C} (e : X ‚âÖ Y) : IsZero X ‚Üî IsZero Y :=\n  ‚ü®fun h => h.of_iso e.symm, fun h => h.of_iso e‚ü©\n\n"}
{"name":"CategoryTheory.Functor.isZero","module":"Mathlib.CategoryTheory.Limits.Shapes.ZeroObjects","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst‚úù : CategoryTheory.Category.{v', u'} D\nF : CategoryTheory.Functor C D\nhF : ‚àÄ (X : C), CategoryTheory.Limits.IsZero (F.obj X)\n‚ä¢ CategoryTheory.Limits.IsZero F","decl":"theorem Functor.isZero (F : C ‚•§ D) (hF : ‚àÄ X, IsZero (F.obj X)) : IsZero F := by\n  constructor <;> intro G <;> refine ‚ü®‚ü®‚ü®?_‚ü©, ?_‚ü©‚ü©\n  ¬∑ refine\n      { app := fun X => (hF _).to_ _\n        naturality := ?_ }\n    intros\n    exact (hF _).eq_of_src _ _\n  ¬∑ intro f\n    ext\n    apply (hF _).eq_of_src _ _\n  ¬∑ refine\n      { app := fun X => (hF _).from_ _\n        naturality := ?_ }\n    intros\n    exact (hF _).eq_of_tgt _ _\n  ¬∑ intro f\n    ext\n    apply (hF _).eq_of_tgt _ _\n\n"}
{"name":"CategoryTheory.Limits.HasZeroObject.zero","module":"Mathlib.CategoryTheory.Limits.Shapes.ZeroObjects","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nself : CategoryTheory.Limits.HasZeroObject C\n‚ä¢ Exists fun X => CategoryTheory.Limits.IsZero X","decl":"/-- A category \"has a zero object\" if it has an object which is both initial and terminal. -/\nclass HasZeroObject : Prop where\n  /-- there exists a zero object -/\n  zero : ‚àÉ X : C, IsZero X\n\n"}
{"name":"CategoryTheory.Limits.hasZeroObject_pUnit","module":"Mathlib.CategoryTheory.Limits.Shapes.ZeroObjects","initialProofState":"‚ä¢ CategoryTheory.Limits.HasZeroObject (CategoryTheory.Discrete PUnit.{u_1 + 1})","decl":"instance hasZeroObject_pUnit : HasZeroObject (Discrete PUnit) where zero :=\n  ‚ü®‚ü®‚ü®‚ü©‚ü©,\n    { unique_to := fun ‚ü®‚ü®‚ü©‚ü© =>\n      ‚ü®{ default := ùüô _,\n          uniq := by subsingleton }‚ü©\n      unique_from := fun ‚ü®‚ü®‚ü©‚ü© =>\n      ‚ü®{ default := ùüô _,\n          uniq := by subsingleton }‚ü©}‚ü©\n\n"}
{"name":"CategoryTheory.Limits.isZero_zero","module":"Mathlib.CategoryTheory.Limits.Shapes.ZeroObjects","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasZeroObject C\n‚ä¢ CategoryTheory.Limits.IsZero 0","decl":"theorem isZero_zero : IsZero (0 : C) :=\n  HasZeroObject.zero.choose_spec\n\n"}
{"name":"CategoryTheory.Limits.hasZeroObject_op","module":"Mathlib.CategoryTheory.Limits.Shapes.ZeroObjects","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasZeroObject C\n‚ä¢ CategoryTheory.Limits.HasZeroObject (Opposite C)","decl":"instance hasZeroObject_op : HasZeroObject C·µí·µñ :=\n  ‚ü®‚ü®Opposite.op 0, IsZero.op (isZero_zero C)‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.Limits.hasZeroObject_unop","module":"Mathlib.CategoryTheory.Limits.Shapes.ZeroObjects","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasZeroObject (Opposite C)\n‚ä¢ CategoryTheory.Limits.HasZeroObject C","decl":"theorem hasZeroObject_unop [HasZeroObject C·µí·µñ] : HasZeroObject C :=\n  ‚ü®‚ü®Opposite.unop 0, IsZero.unop (isZero_zero C·µí·µñ)‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.Limits.IsZero.hasZeroObject","module":"Mathlib.CategoryTheory.Limits.Shapes.ZeroObjects","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : C\nhX : CategoryTheory.Limits.IsZero X\n‚ä¢ CategoryTheory.Limits.HasZeroObject C","decl":"theorem IsZero.hasZeroObject {X : C} (hX : IsZero X) : HasZeroObject C :=\n  ‚ü®‚ü®X, hX‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.Limits.IsZero.obj","module":"Mathlib.CategoryTheory.Limits.Shapes.ZeroObjects","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst‚úù¬π : CategoryTheory.Category.{v', u'} D\ninst‚úù : CategoryTheory.Limits.HasZeroObject D\nF : CategoryTheory.Functor C D\nhF : CategoryTheory.Limits.IsZero F\nX : C\n‚ä¢ CategoryTheory.Limits.IsZero (F.obj X)","decl":"theorem IsZero.obj [HasZeroObject D] {F : C ‚•§ D} (hF : IsZero F) (X : C) : IsZero (F.obj X) := by\n  let G : C ‚•§ D := (CategoryTheory.Functor.const C).obj 0\n  have hG : IsZero G := Functor.isZero _ fun _ => isZero_zero _\n  let e : F ‚âÖ G := hF.iso hG\n  exact (isZero_zero _).of_iso (e.app X)\n\n"}
{"name":"CategoryTheory.Limits.HasZeroObject.to_zero_ext_iff","module":"Mathlib.CategoryTheory.Limits.Shapes.ZeroObjects","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasZeroObject C\nX : C\nf g : Quiver.Hom X 0\n‚ä¢ Iff (Eq f g) True","decl":"@[ext]\ntheorem to_zero_ext {X : C} (f g : X ‚ü∂ 0) : f = g :=\n  (isZero_zero C).eq_of_tgt _ _\n\n"}
{"name":"CategoryTheory.Limits.HasZeroObject.to_zero_ext","module":"Mathlib.CategoryTheory.Limits.Shapes.ZeroObjects","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasZeroObject C\nX : C\nf g : Quiver.Hom X 0\n‚ä¢ Eq f g","decl":"@[ext]\ntheorem to_zero_ext {X : C} (f g : X ‚ü∂ 0) : f = g :=\n  (isZero_zero C).eq_of_tgt _ _\n\n"}
{"name":"CategoryTheory.Limits.HasZeroObject.from_zero_ext","module":"Mathlib.CategoryTheory.Limits.Shapes.ZeroObjects","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasZeroObject C\nX : C\nf g : Quiver.Hom 0 X\n‚ä¢ Eq f g","decl":"@[ext]\ntheorem from_zero_ext {X : C} (f g : 0 ‚ü∂ X) : f = g :=\n  (isZero_zero C).eq_of_src _ _\n\n"}
{"name":"CategoryTheory.Limits.HasZeroObject.from_zero_ext_iff","module":"Mathlib.CategoryTheory.Limits.Shapes.ZeroObjects","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasZeroObject C\nX : C\nf g : Quiver.Hom 0 X\n‚ä¢ Iff (Eq f g) True","decl":"@[ext]\ntheorem from_zero_ext {X : C} (f g : 0 ‚ü∂ X) : f = g :=\n  (isZero_zero C).eq_of_src _ _\n\n"}
{"name":"CategoryTheory.Limits.HasZeroObject.instSubsingletonIsoOfNat","module":"Mathlib.CategoryTheory.Limits.Shapes.ZeroObjects","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasZeroObject C\nX : C\n‚ä¢ Subsingleton (CategoryTheory.Iso X 0)","decl":"instance (X : C) : Subsingleton (X ‚âÖ 0) := ‚ü®fun f g => by ext‚ü©\n\n"}
{"name":"CategoryTheory.Limits.HasZeroObject.instMono","module":"Mathlib.CategoryTheory.Limits.Shapes.ZeroObjects","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasZeroObject C\nX : C\nf : Quiver.Hom 0 X\n‚ä¢ CategoryTheory.Mono f","decl":"instance {X : C} (f : 0 ‚ü∂ X) : Mono f where right_cancellation g h _ := by ext\n\n"}
{"name":"CategoryTheory.Limits.HasZeroObject.instEpi","module":"Mathlib.CategoryTheory.Limits.Shapes.ZeroObjects","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasZeroObject C\nX : C\nf : Quiver.Hom X 0\n‚ä¢ CategoryTheory.Epi f","decl":"instance {X : C} (f : X ‚ü∂ 0) : Epi f where left_cancellation g h _ := by ext\n\n"}
{"name":"CategoryTheory.Limits.HasZeroObject.zero_to_zero_isIso","module":"Mathlib.CategoryTheory.Limits.Shapes.ZeroObjects","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasZeroObject C\nf : Quiver.Hom 0 0\n‚ä¢ CategoryTheory.IsIso f","decl":"instance zero_to_zero_isIso (f : (0 : C) ‚ü∂ 0) : IsIso f := by\n  convert show IsIso (ùüô (0 : C)) by infer_instance\n  subsingleton\n\n"}
{"name":"CategoryTheory.Limits.HasZeroObject.hasInitial","module":"Mathlib.CategoryTheory.Limits.Shapes.ZeroObjects","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasZeroObject C\n‚ä¢ CategoryTheory.Limits.HasInitial C","decl":"/-- A zero object is in particular initial. -/\ninstance (priority := 10) hasInitial : HasInitial C :=\n  hasInitial_of_unique 0\n\n"}
{"name":"CategoryTheory.Limits.HasZeroObject.hasTerminal","module":"Mathlib.CategoryTheory.Limits.Shapes.ZeroObjects","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasZeroObject C\n‚ä¢ CategoryTheory.Limits.HasTerminal C","decl":"/-- A zero object is in particular terminal. -/\ninstance (priority := 10) hasTerminal : HasTerminal C :=\n  hasTerminal_of_unique 0\n\n"}
{"name":"CategoryTheory.Limits.HasZeroObject.initialMonoClass","module":"Mathlib.CategoryTheory.Limits.Shapes.ZeroObjects","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasZeroObject C\n‚ä¢ CategoryTheory.Limits.InitialMonoClass C","decl":"instance (priority := 100) initialMonoClass : InitialMonoClass C :=\n  InitialMonoClass.of_isInitial zeroIsInitial fun X => by infer_instance\n\n"}
{"name":"CategoryTheory.Functor.isZero_iff","module":"Mathlib.CategoryTheory.Limits.Shapes.ZeroObjects","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst‚úù¬π : CategoryTheory.Category.{v', u'} D\ninst‚úù : CategoryTheory.Limits.HasZeroObject D\nF : CategoryTheory.Functor C D\n‚ä¢ Iff (CategoryTheory.Limits.IsZero F) (‚àÄ (X : C), CategoryTheory.Limits.IsZero (F.obj X))","decl":"theorem Functor.isZero_iff [HasZeroObject D] (F : C ‚•§ D) : IsZero F ‚Üî ‚àÄ X, IsZero (F.obj X) :=\n  ‚ü®fun hF X => hF.obj X, Functor.isZero _‚ü©\n\n"}
