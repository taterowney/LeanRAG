{"name":"isOrderRightAdjoint_sSup","module":"Mathlib.Order.SemiconjSup","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : CompleteLattice α\ninst✝ : Preorder β\nf : α → β\n⊢ IsOrderRightAdjoint f fun y => SupSet.sSup (setOf fun x => LE.le (f x) y)","decl":"theorem isOrderRightAdjoint_sSup [CompleteLattice α] [Preorder β] (f : α → β) :\n    IsOrderRightAdjoint f fun y => sSup { x | f x ≤ y } := fun _ => isLUB_sSup _\n\n"}
{"name":"isOrderRightAdjoint_csSup","module":"Mathlib.Order.SemiconjSup","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : ConditionallyCompleteLattice α\ninst✝ : Preorder β\nf : α → β\nhne : ∀ (y : β), Exists fun x => LE.le (f x) y\nhbdd : ∀ (y : β), BddAbove (setOf fun x => LE.le (f x) y)\n⊢ IsOrderRightAdjoint f fun y => SupSet.sSup (setOf fun x => LE.le (f x) y)","decl":"theorem isOrderRightAdjoint_csSup [ConditionallyCompleteLattice α] [Preorder β] (f : α → β)\n    (hne : ∀ y, ∃ x, f x ≤ y) (hbdd : ∀ y, BddAbove { x | f x ≤ y }) :\n    IsOrderRightAdjoint f fun y => sSup { x | f x ≤ y } := fun y => isLUB_csSup (hne y) (hbdd y)\n\n"}
{"name":"IsOrderRightAdjoint.unique","module":"Mathlib.Order.SemiconjSup","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : PartialOrder α\ninst✝ : Preorder β\nf : α → β\ng₁ g₂ : β → α\nh₁ : IsOrderRightAdjoint f g₁\nh₂ : IsOrderRightAdjoint f g₂\n⊢ Eq g₁ g₂","decl":"protected theorem unique [PartialOrder α] [Preorder β] {f : α → β} {g₁ g₂ : β → α}\n    (h₁ : IsOrderRightAdjoint f g₁) (h₂ : IsOrderRightAdjoint f g₂) : g₁ = g₂ :=\n  funext fun y => (h₁ y).unique (h₂ y)\n\n"}
{"name":"IsOrderRightAdjoint.right_mono","module":"Mathlib.Order.SemiconjSup","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : α → β\ng : β → α\nh : IsOrderRightAdjoint f g\n⊢ Monotone g","decl":"theorem right_mono [Preorder α] [Preorder β] {f : α → β} {g : β → α} (h : IsOrderRightAdjoint f g) :\n    Monotone g := fun y₁ y₂ hy => ((h y₁).mono (h y₂)) fun _ hx => le_trans hx hy\n\n"}
{"name":"IsOrderRightAdjoint.orderIso_comp","module":"Mathlib.Order.SemiconjSup","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝² : Preorder α\ninst✝¹ : Preorder β\ninst✝ : Preorder γ\nf : α → β\ng : β → α\nh : IsOrderRightAdjoint f g\ne : OrderIso β γ\n⊢ IsOrderRightAdjoint (Function.comp (⇑e) f) (Function.comp g ⇑e.symm)","decl":"theorem orderIso_comp [Preorder α] [Preorder β] [Preorder γ] {f : α → β} {g : β → α}\n    (h : IsOrderRightAdjoint f g) (e : β ≃o γ) : IsOrderRightAdjoint (e ∘ f) (g ∘ e.symm) :=\n  fun y => by simpa [e.le_symm_apply] using h (e.symm y)\n\n"}
{"name":"IsOrderRightAdjoint.comp_orderIso","module":"Mathlib.Order.SemiconjSup","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝² : Preorder α\ninst✝¹ : Preorder β\ninst✝ : Preorder γ\nf : α → β\ng : β → α\nh : IsOrderRightAdjoint f g\ne : OrderIso γ α\n⊢ IsOrderRightAdjoint (Function.comp f ⇑e) (Function.comp (⇑e.symm) g)","decl":"theorem comp_orderIso [Preorder α] [Preorder β] [Preorder γ] {f : α → β} {g : β → α}\n    (h : IsOrderRightAdjoint f g) (e : γ ≃o α) : IsOrderRightAdjoint (f ∘ e) (e.symm ∘ g) := by\n  intro y\n  change IsLUB (e ⁻¹' { x | f x ≤ y }) (e.symm (g y))\n  rw [e.isLUB_preimage, e.apply_symm_apply]\n  exact h y\n\n"}
{"name":"Function.Semiconj.symm_adjoint","module":"Mathlib.Order.SemiconjSup","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : PartialOrder α\ninst✝ : Preorder β\nfa : OrderIso α α\nfb : OrderEmbedding β β\ng : α → β\nh : Function.Semiconj g ⇑fa ⇑fb\ng' : β → α\nhg' : IsOrderRightAdjoint g g'\n⊢ Function.Semiconj g' ⇑fb ⇑fa","decl":"/-- If an order automorphism `fa` is semiconjugate to an order embedding `fb` by a function `g`\nand `g'` is an order right adjoint of `g` (i.e. `g' y = sSup {x | f x ≤ y}`), then `fb` is\nsemiconjugate to `fa` by `g'`.\n\nThis is a version of Proposition 2.1 from [Étienne Ghys, Groupes d'homéomorphismes du cercle et\ncohomologie bornée][ghys87:groupes]. -/\ntheorem Semiconj.symm_adjoint [PartialOrder α] [Preorder β] {fa : α ≃o α} {fb : β ↪o β} {g : α → β}\n    (h : Function.Semiconj g fa fb) {g' : β → α} (hg' : IsOrderRightAdjoint g g') :\n    Function.Semiconj g' fb fa := by\n  refine fun y => (hg' _).unique ?_\n  rw [← fa.surjective.image_preimage { x | g x ≤ fb y }, preimage_setOf_eq]\n  simp only [h.eq, fb.le_iff_le, fa.leftOrdContinuous (hg' _)]\n\n"}
{"name":"Function.semiconj_of_isLUB","module":"Mathlib.Order.SemiconjSup","initialProofState":"α : Type u_1\nG : Type u_4\ninst✝¹ : PartialOrder α\ninst✝ : Group G\nf₁ f₂ : MonoidHom G (OrderIso α α)\nh : α → α\nH : ∀ (x : α), IsLUB (Set.range fun g' => (Inv.inv (f₁ g')) ((f₂ g') x)) (h x)\ng : G\n⊢ Function.Semiconj h ⇑(f₂ g) ⇑(f₁ g)","decl":"theorem semiconj_of_isLUB [PartialOrder α] [Group G] (f₁ f₂ : G →* α ≃o α) {h : α → α}\n    (H : ∀ x, IsLUB (range fun g' => (f₁ g')⁻¹ (f₂ g' x)) (h x)) (g : G) :\n    Function.Semiconj h (f₂ g) (f₁ g) := by\n  refine fun y => (H _).unique ?_\n  have := (f₁ g).leftOrdContinuous (H y)\n  rw [← range_comp, ← (Equiv.mulRight g).surjective.range_comp _] at this\n  simpa [comp_def] using this\n\n"}
{"name":"Function.sSup_div_semiconj","module":"Mathlib.Order.SemiconjSup","initialProofState":"α : Type u_1\nG : Type u_4\ninst✝¹ : CompleteLattice α\ninst✝ : Group G\nf₁ f₂ : MonoidHom G (OrderIso α α)\ng : G\n⊢ Function.Semiconj (fun x => iSup fun g' => (Inv.inv (f₁ g')) ((f₂ g') x)) ⇑(f₂ g) ⇑(f₁ g)","decl":"/-- Consider two actions `f₁ f₂ : G → α → α` of a group on a complete lattice by order\nisomorphisms. Then the map `x ↦ ⨆ g : G, (f₁ g)⁻¹ (f₂ g x)` semiconjugates each `f₁ g'` to `f₂ g'`.\n\nThis is a version of Proposition 5.4 from [Étienne Ghys, Groupes d'homéomorphismes du cercle et\ncohomologie bornée][ghys87:groupes]. -/\ntheorem sSup_div_semiconj [CompleteLattice α] [Group G] (f₁ f₂ : G →* α ≃o α) (g : G) :\n    Function.Semiconj (fun x => ⨆ g' : G, (f₁ g')⁻¹ (f₂ g' x)) (f₂ g) (f₁ g) :=\n  semiconj_of_isLUB f₁ f₂ (fun _ => isLUB_iSup) _\n\n"}
{"name":"Function.csSup_div_semiconj","module":"Mathlib.Order.SemiconjSup","initialProofState":"α : Type u_1\nG : Type u_4\ninst✝¹ : ConditionallyCompleteLattice α\ninst✝ : Group G\nf₁ f₂ : MonoidHom G (OrderIso α α)\nhbdd : ∀ (x : α), BddAbove (Set.range fun g => (Inv.inv (f₁ g)) ((f₂ g) x))\ng : G\n⊢ Function.Semiconj (fun x => iSup fun g' => (Inv.inv (f₁ g')) ((f₂ g') x)) ⇑(f₂ g) ⇑(f₁ g)","decl":"/-- Consider two actions `f₁ f₂ : G → α → α` of a group on a conditionally complete lattice by order\nisomorphisms. Suppose that each set $s(x)=\\{f_1(g)^{-1} (f_2(g)(x)) | g \\in G\\}$ is bounded above.\nThen the map `x ↦ sSup s(x)` semiconjugates each `f₁ g'` to `f₂ g'`.\n\nThis is a version of Proposition 5.4 from [Étienne Ghys, Groupes d'homéomorphismes du cercle et\ncohomologie bornée][ghys87:groupes]. -/\ntheorem csSup_div_semiconj [ConditionallyCompleteLattice α] [Group G] (f₁ f₂ : G →* α ≃o α)\n    (hbdd : ∀ x, BddAbove (range fun g => (f₁ g)⁻¹ (f₂ g x))) (g : G) :\n    Function.Semiconj (fun x => ⨆ g' : G, (f₁ g')⁻¹ (f₂ g' x)) (f₂ g) (f₁ g) :=\n  semiconj_of_isLUB f₁ f₂ (fun x => isLUB_csSup (range_nonempty _) (hbdd x)) _\n\n"}
