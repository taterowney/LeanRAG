{"name":"linearIndependent_bounded_of_finset_linearIndependent_bounded","module":"Mathlib.LinearAlgebra.Dimension.Finite","initialProofState":"R : Type u\nM : Type v\ninst✝² : Ring R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nn : Nat\nH : ∀ (s : Finset M), (LinearIndependent R fun i => ↑i) → LE.le s.card n\ns : Set M\na✝ : LinearIndependent R Subtype.val\n⊢ LE.le (Cardinal.mk ↑s) ↑n","decl":"/-- If every finite set of linearly independent vectors has cardinality at most `n`,\nthen the same is true for arbitrary sets of linearly independent vectors.\n-/\ntheorem linearIndependent_bounded_of_finset_linearIndependent_bounded {n : ℕ}\n    (H : ∀ s : Finset M, (LinearIndependent R fun i : s => (i : M)) → s.card ≤ n) :\n    ∀ s : Set M, LinearIndependent R ((↑) : s → M) → #s ≤ n := by\n  intro s li\n  apply Cardinal.card_le_of\n  intro t\n  rw [← Finset.card_map (Embedding.subtype s)]\n  apply H\n  apply linearIndependent_finset_map_embedding_subtype _ li\n\n"}
{"name":"rank_le","module":"Mathlib.LinearAlgebra.Dimension.Finite","initialProofState":"R : Type u\nM : Type v\ninst✝² : Ring R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nn : Nat\nH : ∀ (s : Finset M), (LinearIndependent R fun i => ↑i) → LE.le s.card n\n⊢ LE.le (Module.rank R M) ↑n","decl":"theorem rank_le {n : ℕ}\n    (H : ∀ s : Finset M, (LinearIndependent R fun i : s => (i : M)) → s.card ≤ n) :\n    Module.rank R M ≤ n := by\n  rw [Module.rank_def]\n  apply ciSup_le'\n  rintro ⟨s, li⟩\n  exact linearIndependent_bounded_of_finset_linearIndependent_bounded H _ li\n\n"}
{"name":"rank_eq_zero_iff","module":"Mathlib.LinearAlgebra.Dimension.Finite","initialProofState":"R : Type u\nM : Type v\ninst✝² : Ring R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\n⊢ Iff (Eq (Module.rank R M) 0) (∀ (x : M), Exists fun a => And (Ne a 0) (Eq (HSMul.hSMul a x) 0))","decl":"/-- See `rank_zero_iff` for a stronger version with `NoZeroSMulDivisor R M`. -/\nlemma rank_eq_zero_iff :\n    Module.rank R M = 0 ↔ ∀ x : M, ∃ a : R, a ≠ 0 ∧ a • x = 0 := by\n  nontriviality R\n  constructor\n  · contrapose!\n    rintro ⟨x, hx⟩\n    rw [← Cardinal.one_le_iff_ne_zero]\n    have : LinearIndependent R (fun _ : Unit ↦ x) :=\n      linearIndependent_iff.mpr (fun l hl ↦ Finsupp.unique_ext <| not_not.mp fun H ↦\n        hx _ H ((Finsupp.linearCombination_unique _ _ _).symm.trans hl))\n    simpa using this.cardinal_lift_le_rank\n  · intro h\n    rw [← le_zero_iff, Module.rank_def]\n    apply ciSup_le'\n    intro ⟨s, hs⟩\n    rw [nonpos_iff_eq_zero, Cardinal.mk_eq_zero_iff, ← not_nonempty_iff]\n    rintro ⟨i : s⟩\n    obtain ⟨a, ha, ha'⟩ := h i\n    apply ha\n    simpa using DFunLike.congr_fun (linearIndependent_iff.mp hs (Finsupp.single i a) (by simpa)) i\n\n"}
{"name":"rank_zero_iff_forall_zero","module":"Mathlib.LinearAlgebra.Dimension.Finite","initialProofState":"R : Type u\nM : Type v\ninst✝⁴ : Ring R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : Nontrivial R\ninst✝ : NoZeroSMulDivisors R M\n⊢ Iff (Eq (Module.rank R M) 0) (∀ (x : M), Eq x 0)","decl":"theorem rank_zero_iff_forall_zero :\n    Module.rank R M = 0 ↔ ∀ x : M, x = 0 := by\n  simp_rw [rank_eq_zero_iff, smul_eq_zero, and_or_left, not_and_self_iff, false_or,\n    exists_and_right, and_iff_right (exists_ne (0 : R))]\n\n"}
{"name":"rank_zero_iff","module":"Mathlib.LinearAlgebra.Dimension.Finite","initialProofState":"R : Type u\nM : Type v\ninst✝⁴ : Ring R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : Nontrivial R\ninst✝ : NoZeroSMulDivisors R M\n⊢ Iff (Eq (Module.rank R M) 0) (Subsingleton M)","decl":"/-- See `rank_subsingleton` for the reason that `Nontrivial R` is needed.\nAlso see `rank_eq_zero_iff` for the version without `NoZeroSMulDivisor R M`. -/\ntheorem rank_zero_iff : Module.rank R M = 0 ↔ Subsingleton M :=\n  rank_zero_iff_forall_zero.trans (subsingleton_iff_forall_eq 0).symm\n\n"}
{"name":"rank_pos_iff_exists_ne_zero","module":"Mathlib.LinearAlgebra.Dimension.Finite","initialProofState":"R : Type u\nM : Type v\ninst✝⁴ : Ring R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : Nontrivial R\ninst✝ : NoZeroSMulDivisors R M\n⊢ Iff (LT.lt 0 (Module.rank R M)) (Exists fun x => Ne x 0)","decl":"theorem rank_pos_iff_exists_ne_zero : 0 < Module.rank R M ↔ ∃ x : M, x ≠ 0 := by\n  rw [← not_iff_not]\n  simpa using rank_zero_iff_forall_zero\n\n"}
{"name":"rank_pos_iff_nontrivial","module":"Mathlib.LinearAlgebra.Dimension.Finite","initialProofState":"R : Type u\nM : Type v\ninst✝⁴ : Ring R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : Nontrivial R\ninst✝ : NoZeroSMulDivisors R M\n⊢ Iff (LT.lt 0 (Module.rank R M)) (Nontrivial M)","decl":"theorem rank_pos_iff_nontrivial : 0 < Module.rank R M ↔ Nontrivial M :=\n  rank_pos_iff_exists_ne_zero.trans (nontrivial_iff_exists_ne 0).symm\n\n"}
{"name":"rank_pos","module":"Mathlib.LinearAlgebra.Dimension.Finite","initialProofState":"R : Type u\nM : Type v\ninst✝⁵ : Ring R\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\ninst✝² : Nontrivial R\ninst✝¹ : NoZeroSMulDivisors R M\ninst✝ : Nontrivial M\n⊢ LT.lt 0 (Module.rank R M)","decl":"theorem rank_pos [Nontrivial M] : 0 < Module.rank R M :=\n  rank_pos_iff_nontrivial.mpr ‹_›\n\n"}
{"name":"rank_subsingleton'","module":"Mathlib.LinearAlgebra.Dimension.Finite","initialProofState":"R : Type u\nM : Type v\ninst✝⁴ : Ring R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : Nontrivial R\ninst✝ : Subsingleton M\n⊢ Eq (Module.rank R M) 0","decl":"/-- See `rank_subsingleton` that assumes `Subsingleton R` instead. -/\ntheorem rank_subsingleton' [Subsingleton M] : Module.rank R M = 0 :=\n  rank_eq_zero_iff.mpr fun _ ↦ ⟨1, one_ne_zero, Subsingleton.elim _ _⟩\n\n"}
{"name":"rank_punit","module":"Mathlib.LinearAlgebra.Dimension.Finite","initialProofState":"R : Type u\ninst✝¹ : Ring R\ninst✝ : Nontrivial R\n⊢ Eq (Module.rank R PUnit.{u_1 + 1}) 0","decl":"@[simp]\ntheorem rank_punit : Module.rank R PUnit = 0 := rank_subsingleton' _ _\n\n"}
{"name":"rank_bot","module":"Mathlib.LinearAlgebra.Dimension.Finite","initialProofState":"R : Type u\nM : Type v\ninst✝³ : Ring R\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : Nontrivial R\n⊢ Eq (Module.rank R (Subtype fun x => Membership.mem Bot.bot x)) 0","decl":"@[simp]\ntheorem rank_bot : Module.rank R (⊥ : Submodule R M) = 0 := rank_subsingleton' _ _\n\n"}
{"name":"exists_mem_ne_zero_of_rank_pos","module":"Mathlib.LinearAlgebra.Dimension.Finite","initialProofState":"R : Type u\nM : Type v\ninst✝³ : Ring R\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : Nontrivial R\ns : Submodule R M\nh : LT.lt 0 (Module.rank R (Subtype fun x => Membership.mem s x))\n⊢ Exists fun b => And (Membership.mem s b) (Ne b 0)","decl":"theorem exists_mem_ne_zero_of_rank_pos {s : Submodule R M} (h : 0 < Module.rank R s) :\n    ∃ b : M, b ∈ s ∧ b ≠ 0 :=\n  exists_mem_ne_zero_of_ne_bot fun eq => by rw [eq, rank_bot] at h; exact lt_irrefl _ h\n\n"}
{"name":"Module.finite_of_rank_eq_nat","module":"Mathlib.LinearAlgebra.Dimension.Finite","initialProofState":"R : Type u\nM : Type v\ninst✝³ : Ring R\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : Module.Free R M\nn : Nat\nh : Eq (Module.rank R M) ↑n\n⊢ Module.Finite R M","decl":"theorem Module.finite_of_rank_eq_nat [Module.Free R M] {n : ℕ} (h : Module.rank R M = n) :\n    Module.Finite R M := by\n  nontriviality R\n  obtain ⟨⟨ι, b⟩⟩ := Module.Free.exists_basis (R := R) (M := M)\n  have := mk_lt_aleph0_iff.mp <|\n    b.linearIndependent.cardinal_le_rank |>.trans_eq h |>.trans_lt <| nat_lt_aleph0 n\n  exact Module.Finite.of_basis b\n\n"}
{"name":"Module.finite_of_rank_eq_zero","module":"Mathlib.LinearAlgebra.Dimension.Finite","initialProofState":"R : Type u\nM : Type v\ninst✝³ : Ring R\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : NoZeroSMulDivisors R M\nh : Eq (Module.rank R M) 0\n⊢ Module.Finite R M","decl":"theorem Module.finite_of_rank_eq_zero [NoZeroSMulDivisors R M]\n    (h : Module.rank R M = 0) :\n    Module.Finite R M := by\n  nontriviality R\n  rw [rank_zero_iff] at h\n  infer_instance\n\n"}
{"name":"Module.finite_of_rank_eq_one","module":"Mathlib.LinearAlgebra.Dimension.Finite","initialProofState":"R : Type u\nM : Type v\ninst✝³ : Ring R\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : Module.Free R M\nh : Eq (Module.rank R M) 1\n⊢ Module.Finite R M","decl":"theorem Module.finite_of_rank_eq_one [Module.Free R M] (h : Module.rank R M = 1) :\n    Module.Finite R M :=\n  Module.finite_of_rank_eq_nat <| h.trans Nat.cast_one.symm\n\n"}
{"name":"Basis.nonempty_fintype_index_of_rank_lt_aleph0","module":"Mathlib.LinearAlgebra.Dimension.Finite","initialProofState":"R : Type u\nM : Type v\ninst✝³ : Ring R\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : StrongRankCondition R\nι : Type u_1\nb : Basis ι R M\nh : LT.lt (Module.rank R M) Cardinal.aleph0\n⊢ Nonempty (Fintype ι)","decl":"/-- If a module has a finite dimension, all bases are indexed by a finite type. -/\ntheorem Basis.nonempty_fintype_index_of_rank_lt_aleph0 {ι : Type*} (b : Basis ι R M)\n    (h : Module.rank R M < ℵ₀) : Nonempty (Fintype ι) := by\n  rwa [← Cardinal.lift_lt, ← b.mk_eq_rank, Cardinal.lift_aleph0, Cardinal.lift_lt_aleph0,\n    Cardinal.lt_aleph0_iff_fintype] at h\n\n"}
{"name":"Basis.finite_index_of_rank_lt_aleph0","module":"Mathlib.LinearAlgebra.Dimension.Finite","initialProofState":"R : Type u\nM : Type v\ninst✝³ : Ring R\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : StrongRankCondition R\nι : Type u_1\ns : Set ι\nb : Basis (↑s) R M\nh : LT.lt (Module.rank R M) Cardinal.aleph0\n⊢ s.Finite","decl":"/-- If a module has a finite dimension, all bases are indexed by a finite set. -/\ntheorem Basis.finite_index_of_rank_lt_aleph0 {ι : Type*} {s : Set ι} (b : Basis s R M)\n    (h : Module.rank R M < ℵ₀) : s.Finite :=\n  finite_def.2 (b.nonempty_fintype_index_of_rank_lt_aleph0 h)\n\n"}
{"name":"LinearIndependent.cardinalMk_le_finrank","module":"Mathlib.LinearAlgebra.Dimension.Finite","initialProofState":"R : Type u\nM : Type v\ninst✝⁴ : Ring R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : StrongRankCondition R\ninst✝ : Module.Finite R M\nι : Type w\nb : ι → M\nh : LinearIndependent R b\n⊢ LE.le (Cardinal.mk ι) ↑(Module.finrank R M)","decl":"theorem cardinalMk_le_finrank [Module.Finite R M]\n    {ι : Type w} {b : ι → M} (h : LinearIndependent R b) : #ι ≤ finrank R M := by\n  rw [← lift_le.{max v w}]\n  simpa only [← finrank_eq_rank, lift_natCast, lift_le_nat_iff] using h.cardinal_lift_le_rank\n\n"}
{"name":"LinearIndependent.cardinal_mk_le_finrank","module":"Mathlib.LinearAlgebra.Dimension.Finite","initialProofState":"R : Type u\nM : Type v\ninst✝⁴ : Ring R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : StrongRankCondition R\ninst✝ : Module.Finite R M\nι : Type w\nb : ι → M\nh : LinearIndependent R b\n⊢ LE.le (Cardinal.mk ι) ↑(Module.finrank R M)","decl":"@[deprecated (since := \"2024-11-10\")] alias cardinal_mk_le_finrank := cardinalMk_le_finrank\n\n"}
{"name":"LinearIndependent.fintype_card_le_finrank","module":"Mathlib.LinearAlgebra.Dimension.Finite","initialProofState":"R : Type u\nM : Type v\ninst✝⁵ : Ring R\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\ninst✝² : StrongRankCondition R\ninst✝¹ : Module.Finite R M\nι : Type u_1\ninst✝ : Fintype ι\nb : ι → M\nh : LinearIndependent R b\n⊢ LE.le (Fintype.card ι) (Module.finrank R M)","decl":"theorem fintype_card_le_finrank [Module.Finite R M]\n    {ι : Type*} [Fintype ι] {b : ι → M} (h : LinearIndependent R b) :\n    Fintype.card ι ≤ finrank R M := by\n  simpa using h.cardinalMk_le_finrank\n\n"}
{"name":"LinearIndependent.finset_card_le_finrank","module":"Mathlib.LinearAlgebra.Dimension.Finite","initialProofState":"R : Type u\nM : Type v\ninst✝⁴ : Ring R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : StrongRankCondition R\ninst✝ : Module.Finite R M\nb : Finset M\nh : LinearIndependent R fun x => ↑x\n⊢ LE.le b.card (Module.finrank R M)","decl":"theorem finset_card_le_finrank [Module.Finite R M]\n    {b : Finset M} (h : LinearIndependent R (fun x => x : b → M)) :\n    b.card ≤ finrank R M := by\n  rw [← Fintype.card_coe]\n  exact h.fintype_card_le_finrank\n\n"}
{"name":"LinearIndependent.lt_aleph0_of_finite","module":"Mathlib.LinearAlgebra.Dimension.Finite","initialProofState":"R : Type u\nM : Type v\ninst✝⁴ : Ring R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : StrongRankCondition R\nι : Type w\ninst✝ : Module.Finite R M\nv : ι → M\nh : LinearIndependent R v\n⊢ LT.lt (Cardinal.mk ι) Cardinal.aleph0","decl":"theorem lt_aleph0_of_finite {ι : Type w}\n    [Module.Finite R M] {v : ι → M} (h : LinearIndependent R v) : #ι < ℵ₀ := by\n  apply Cardinal.lift_lt.1\n  apply lt_of_le_of_lt\n  · apply h.cardinal_lift_le_rank\n  · rw [← finrank_eq_rank, Cardinal.lift_aleph0, Cardinal.lift_natCast]\n    apply Cardinal.nat_lt_aleph0\n\n"}
{"name":"LinearIndependent.finite","module":"Mathlib.LinearAlgebra.Dimension.Finite","initialProofState":"R : Type u\nM : Type v\ninst✝⁴ : Ring R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : StrongRankCondition R\ninst✝ : Module.Finite R M\nι : Type u_1\nf : ι → M\nh : LinearIndependent R f\n⊢ Finite ι","decl":"theorem finite [Module.Finite R M] {ι : Type*} {f : ι → M}\n    (h : LinearIndependent R f) : Finite ι :=\n  Cardinal.lt_aleph0_iff_finite.1 <| h.lt_aleph0_of_finite\n\n"}
{"name":"LinearIndependent.setFinite","module":"Mathlib.LinearAlgebra.Dimension.Finite","initialProofState":"R : Type u\nM : Type v\ninst✝⁴ : Ring R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : StrongRankCondition R\ninst✝ : Module.Finite R M\nb : Set M\nh : LinearIndependent R fun x => ↑x\n⊢ b.Finite","decl":"theorem setFinite [Module.Finite R M] {b : Set M}\n    (h : LinearIndependent R fun x : b => (x : M)) : b.Finite :=\n  Cardinal.lt_aleph0_iff_set_finite.mp h.lt_aleph0_of_finite\n\n"}
{"name":"exists_set_linearIndependent_of_lt_rank","module":"Mathlib.LinearAlgebra.Dimension.Finite","initialProofState":"R : Type u\nM : Type v\ninst✝² : Ring R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nn : Cardinal.{v}\nhn : LT.lt n (Module.rank R M)\n⊢ Exists fun s => And (Eq (Cardinal.mk ↑s) n) (LinearIndependent R Subtype.val)","decl":"lemma exists_set_linearIndependent_of_lt_rank {n : Cardinal} (hn : n < Module.rank R M) :\n    ∃ s : Set M, #s = n ∧ LinearIndependent R ((↑) : s → M) := by\n  obtain ⟨⟨s, hs⟩, hs'⟩ := exists_lt_of_lt_ciSup' (hn.trans_eq (Module.rank_def R M))\n  obtain ⟨t, ht, ht'⟩ := le_mk_iff_exists_subset.mp hs'.le\n  exact ⟨t, ht', .mono ht hs⟩\n\n"}
{"name":"exists_finset_linearIndependent_of_le_rank","module":"Mathlib.LinearAlgebra.Dimension.Finite","initialProofState":"R : Type u\nM : Type v\ninst✝² : Ring R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nn : Nat\nhn : LE.le (↑n) (Module.rank R M)\n⊢ Exists fun s => And (Eq s.card n) (LinearIndependent R Subtype.val)","decl":"lemma exists_finset_linearIndependent_of_le_rank {n : ℕ} (hn : n ≤ Module.rank R M) :\n    ∃ s : Finset M, s.card = n ∧ LinearIndependent R ((↑) : s → M) := by\n  have := nonempty_linearIndependent_set\n  cases' hn.eq_or_lt with h h\n  · obtain ⟨⟨s, hs⟩, hs'⟩ := Cardinal.exists_eq_natCast_of_iSup_eq _\n      (Cardinal.bddAbove_range _) _ (h.trans (Module.rank_def R M)).symm\n    have : Finite s := lt_aleph0_iff_finite.mp (hs' ▸ nat_lt_aleph0 n)\n    cases nonempty_fintype s\n    exact ⟨s.toFinset, by simpa using hs', by convert hs using 3 <;> exact Set.mem_toFinset⟩\n  · obtain ⟨s, hs, hs'⟩ := exists_set_linearIndependent_of_lt_rank h\n    have : Finite s := lt_aleph0_iff_finite.mp (hs ▸ nat_lt_aleph0 n)\n    cases nonempty_fintype s\n    exact ⟨s.toFinset, by simpa using hs, by convert hs' using 3 <;> exact Set.mem_toFinset⟩\n\n"}
{"name":"exists_linearIndependent_of_le_rank","module":"Mathlib.LinearAlgebra.Dimension.Finite","initialProofState":"R : Type u\nM : Type v\ninst✝² : Ring R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nn : Nat\nhn : LE.le (↑n) (Module.rank R M)\n⊢ Exists fun f => LinearIndependent R f","decl":"lemma exists_linearIndependent_of_le_rank {n : ℕ} (hn : n ≤ Module.rank R M) :\n    ∃ f : Fin n → M, LinearIndependent R f :=\n  have ⟨_, hs, hs'⟩ := exists_finset_linearIndependent_of_le_rank hn\n  ⟨_, (linearIndependent_equiv (Finset.equivFinOfCardEq hs).symm).mpr hs'⟩\n\n"}
{"name":"natCast_le_rank_iff","module":"Mathlib.LinearAlgebra.Dimension.Finite","initialProofState":"R : Type u\nM : Type v\ninst✝³ : Ring R\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : Nontrivial R\nn : Nat\n⊢ Iff (LE.le (↑n) (Module.rank R M)) (Exists fun f => LinearIndependent R f)","decl":"lemma natCast_le_rank_iff [Nontrivial R] {n : ℕ} :\n    n ≤ Module.rank R M ↔ ∃ f : Fin n → M, LinearIndependent R f :=\n  ⟨exists_linearIndependent_of_le_rank,\n    fun H ↦ by simpa using H.choose_spec.cardinal_lift_le_rank⟩\n\n"}
{"name":"natCast_le_rank_iff_finset","module":"Mathlib.LinearAlgebra.Dimension.Finite","initialProofState":"R : Type u\nM : Type v\ninst✝³ : Ring R\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : Nontrivial R\nn : Nat\n⊢ Iff (LE.le (↑n) (Module.rank R M)) (Exists fun s => And (Eq s.card n) (LinearIndependent R Subtype.val))","decl":"lemma natCast_le_rank_iff_finset [Nontrivial R] {n : ℕ} :\n    n ≤ Module.rank R M ↔ ∃ s : Finset M, s.card = n ∧ LinearIndependent R ((↑) : s → M) :=\n  ⟨exists_finset_linearIndependent_of_le_rank,\n    fun ⟨s, h₁, h₂⟩ ↦ by simpa [h₁] using h₂.cardinal_le_rank⟩\n\n"}
{"name":"exists_finset_linearIndependent_of_le_finrank","module":"Mathlib.LinearAlgebra.Dimension.Finite","initialProofState":"R : Type u\nM : Type v\ninst✝² : Ring R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nn : Nat\nhn : LE.le n (Module.finrank R M)\n⊢ Exists fun s => And (Eq s.card n) (LinearIndependent R Subtype.val)","decl":"lemma exists_finset_linearIndependent_of_le_finrank {n : ℕ} (hn : n ≤ finrank R M) :\n    ∃ s : Finset M, s.card = n ∧ LinearIndependent R ((↑) : s → M) := by\n  by_cases h : finrank R M = 0\n  · rw [le_zero_iff.mp (hn.trans_eq h)]\n    exact ⟨∅, rfl, by convert linearIndependent_empty R M using 2 <;> aesop⟩\n  exact exists_finset_linearIndependent_of_le_rank\n    ((Nat.cast_le.mpr hn).trans_eq (cast_toNat_of_lt_aleph0 (toNat_ne_zero.mp h).2))\n\n"}
{"name":"exists_linearIndependent_of_le_finrank","module":"Mathlib.LinearAlgebra.Dimension.Finite","initialProofState":"R : Type u\nM : Type v\ninst✝² : Ring R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nn : Nat\nhn : LE.le n (Module.finrank R M)\n⊢ Exists fun f => LinearIndependent R f","decl":"lemma exists_linearIndependent_of_le_finrank {n : ℕ} (hn : n ≤ finrank R M) :\n    ∃ f : Fin n → M, LinearIndependent R f :=\n  have ⟨_, hs, hs'⟩ := exists_finset_linearIndependent_of_le_finrank hn\n  ⟨_, (linearIndependent_equiv (Finset.equivFinOfCardEq hs).symm).mpr hs'⟩\n\n"}
{"name":"Module.Finite.not_linearIndependent_of_infinite","module":"Mathlib.LinearAlgebra.Dimension.Finite","initialProofState":"R : Type u\nM : Type v\ninst✝⁵ : Ring R\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\ninst✝² : Module.Finite R M\ninst✝¹ : StrongRankCondition R\nι : Type u_1\ninst✝ : Infinite ι\nv : ι → M\n⊢ Not (LinearIndependent R v)","decl":"variable [Module.Finite R M] [StrongRankCondition R] in\ntheorem Module.Finite.not_linearIndependent_of_infinite {ι : Type*} [Infinite ι]\n    (v : ι → M) : ¬LinearIndependent R v := mt LinearIndependent.finite <| @not_finite _ _\n\n"}
{"name":"iSupIndep.subtype_ne_bot_le_rank","module":"Mathlib.LinearAlgebra.Dimension.Finite","initialProofState":"R : Type u\nM : Type v\nι : Type w\ninst✝⁴ : Ring R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : NoZeroSMulDivisors R M\ninst✝ : Nontrivial R\nV : ι → Submodule R M\nhV : iSupIndep V\n⊢ LE.le (Cardinal.lift.{v, w} (Cardinal.mk (Subtype fun i => Ne (V i) Bot.bot))) (Cardinal.lift.{w, v} (Module.rank R M))","decl":"theorem iSupIndep.subtype_ne_bot_le_rank [Nontrivial R]\n    {V : ι → Submodule R M} (hV : iSupIndep V) :\n    Cardinal.lift.{v} #{ i : ι // V i ≠ ⊥ } ≤ Cardinal.lift.{w} (Module.rank R M) := by\n  set I := { i : ι // V i ≠ ⊥ }\n  have hI : ∀ i : I, ∃ v ∈ V i, v ≠ (0 : M) := by\n    intro i\n    rw [← Submodule.ne_bot_iff]\n    exact i.prop\n  choose v hvV hv using hI\n  have : LinearIndependent R v := (hV.comp Subtype.coe_injective).linearIndependent _ hvV hv\n  exact this.cardinal_lift_le_rank\n\n"}
{"name":"CompleteLattice.Independent.subtype_ne_bot_le_rank","module":"Mathlib.LinearAlgebra.Dimension.Finite","initialProofState":"R : Type u\nM : Type v\nι : Type w\ninst✝⁴ : Ring R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : NoZeroSMulDivisors R M\ninst✝ : Nontrivial R\nV : ι → Submodule R M\nhV : iSupIndep V\n⊢ LE.le (Cardinal.lift.{v, w} (Cardinal.mk (Subtype fun i => Ne (V i) Bot.bot))) (Cardinal.lift.{w, v} (Module.rank R M))","decl":"@[deprecated (since := \"2024-11-24\")]\nalias CompleteLattice.Independent.subtype_ne_bot_le_rank := iSupIndep.subtype_ne_bot_le_rank\n\n"}
{"name":"iSupIndep.subtype_ne_bot_le_finrank_aux","module":"Mathlib.LinearAlgebra.Dimension.Finite","initialProofState":"R : Type u\nM : Type v\nι : Type w\ninst✝⁵ : Ring R\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\ninst✝² : NoZeroSMulDivisors R M\ninst✝¹ : Module.Finite R M\ninst✝ : StrongRankCondition R\np : ι → Submodule R M\nhp : iSupIndep p\n⊢ LE.le (Cardinal.mk (Subtype fun i => Ne (p i) Bot.bot)) ↑(Module.finrank R M)","decl":"theorem iSupIndep.subtype_ne_bot_le_finrank_aux\n    {p : ι → Submodule R M} (hp : iSupIndep p) :\n    #{ i // p i ≠ ⊥ } ≤ (finrank R M : Cardinal.{w}) := by\n  suffices Cardinal.lift.{v} #{ i // p i ≠ ⊥ } ≤ Cardinal.lift.{v} (finrank R M : Cardinal.{w}) by\n    rwa [Cardinal.lift_le] at this\n  calc\n    Cardinal.lift.{v} #{ i // p i ≠ ⊥ } ≤ Cardinal.lift.{w} (Module.rank R M) :=\n      hp.subtype_ne_bot_le_rank\n    _ = Cardinal.lift.{w} (finrank R M : Cardinal.{v}) := by rw [finrank_eq_rank]\n    _ = Cardinal.lift.{v} (finrank R M : Cardinal.{w}) := by simp\n\n"}
{"name":"iSupIndep.subtype_ne_bot_le_finrank","module":"Mathlib.LinearAlgebra.Dimension.Finite","initialProofState":"R : Type u\nM : Type v\nι : Type w\ninst✝⁶ : Ring R\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\ninst✝³ : NoZeroSMulDivisors R M\ninst✝² : Module.Finite R M\ninst✝¹ : StrongRankCondition R\np : ι → Submodule R M\nhp : iSupIndep p\ninst✝ : Fintype (Subtype fun i => Ne (p i) Bot.bot)\n⊢ LE.le (Fintype.card (Subtype fun i => Ne (p i) Bot.bot)) (Module.finrank R M)","decl":"/-- If `p` is an independent family of submodules of a `R`-finite module `M`, then the\nnumber of nontrivial subspaces in the family `p` is bounded above by the dimension of `M`.\n\nNote that the `Fintype` hypothesis required here can be provided by\n`iSupIndep.fintypeNeBotOfFiniteDimensional`. -/\ntheorem iSupIndep.subtype_ne_bot_le_finrank\n    {p : ι → Submodule R M} (hp : iSupIndep p) [Fintype { i // p i ≠ ⊥ }] :\n    Fintype.card { i // p i ≠ ⊥ } ≤ finrank R M := by simpa using hp.subtype_ne_bot_le_finrank_aux\n\n"}
{"name":"Module.exists_nontrivial_relation_of_finrank_lt_card","module":"Mathlib.LinearAlgebra.Dimension.Finite","initialProofState":"R : Type u\nM : Type v\ninst✝⁴ : Ring R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : Module.Finite R M\ninst✝ : StrongRankCondition R\nt : Finset M\nh : LT.lt (Module.finrank R M) t.card\n⊢ Exists fun f => And (Eq (t.sum fun e => HSMul.hSMul (f e) e) 0) (Exists fun x => And (Membership.mem t x) (Ne (f x) 0))","decl":"/-- If a finset has cardinality larger than the rank of a module,\nthen there is a nontrivial linear relation amongst its elements. -/\ntheorem Module.exists_nontrivial_relation_of_finrank_lt_card {t : Finset M}\n    (h : finrank R M < t.card) : ∃ f : M → R, ∑ e ∈ t, f e • e = 0 ∧ ∃ x ∈ t, f x ≠ 0 := by\n  obtain ⟨g, sum, z, nonzero⟩ := Fintype.not_linearIndependent_iff.mp\n    (mt LinearIndependent.finset_card_le_finrank h.not_le)\n  refine ⟨Subtype.val.extend g 0, ?_, z, z.2, by rwa [Subtype.val_injective.extend_apply]⟩\n  rw [← Finset.sum_finset_coe]; convert sum; apply Subtype.val_injective.extend_apply\n\n"}
{"name":"Module.exists_nontrivial_relation_sum_zero_of_finrank_succ_lt_card","module":"Mathlib.LinearAlgebra.Dimension.Finite","initialProofState":"R : Type u\nM : Type v\ninst✝⁴ : Ring R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : Module.Finite R M\ninst✝ : StrongRankCondition R\nt : Finset M\nh : LT.lt (HAdd.hAdd (Module.finrank R M) 1) t.card\n⊢ Exists fun f => And (Eq (t.sum fun e => HSMul.hSMul (f e) e) 0) (And (Eq (t.sum fun e => f e) 0) (Exists fun x => And (Membership.mem t x) (Ne (f x) 0)))","decl":"/-- If a finset has cardinality larger than `finrank + 1`,\nthen there is a nontrivial linear relation amongst its elements,\nsuch that the coefficients of the relation sum to zero. -/\ntheorem Module.exists_nontrivial_relation_sum_zero_of_finrank_succ_lt_card\n    {t : Finset M} (h : finrank R M + 1 < t.card) :\n    ∃ f : M → R, ∑ e ∈ t, f e • e = 0 ∧ ∑ e ∈ t, f e = 0 ∧ ∃ x ∈ t, f x ≠ 0 := by\n  -- Pick an element x₀ ∈ t,\n  obtain ⟨x₀, x₀_mem⟩ := card_pos.1 ((Nat.succ_pos _).trans h)\n  -- and apply the previous lemma to the {xᵢ - x₀}\n  let shift : M ↪ M := ⟨(· - x₀), sub_left_injective⟩\n  classical\n  let t' := (t.erase x₀).map shift\n  have h' : finrank R M < t'.card := by\n    rw [card_map, card_erase_of_mem x₀_mem]\n    exact Nat.lt_pred_iff.mpr h\n  -- to obtain a function `g`.\n  obtain ⟨g, gsum, x₁, x₁_mem, nz⟩ := exists_nontrivial_relation_of_finrank_lt_card h'\n  -- Then obtain `f` by translating back by `x₀`,\n  -- and setting the value of `f` at `x₀` to ensure `∑ e ∈ t, f e = 0`.\n  let f : M → R := fun z ↦ if z = x₀ then -∑ z ∈ t.erase x₀, g (z - x₀) else g (z - x₀)\n  refine ⟨f, ?_, ?_, ?_⟩\n  -- After this, it's a matter of verifying the properties,\n  -- based on the corresponding properties for `g`.\n  · rw [sum_map, Embedding.coeFn_mk] at gsum\n    simp_rw [f, ← t.sum_erase_add _ x₀_mem, if_pos, neg_smul, sum_smul,\n             ← sub_eq_add_neg, ← sum_sub_distrib, ← gsum, smul_sub]\n    refine sum_congr rfl fun x x_mem ↦ ?_\n    rw [if_neg (mem_erase.mp x_mem).1]\n  · simp_rw [f, ← t.sum_erase_add _ x₀_mem, if_pos, add_neg_eq_zero]\n    exact sum_congr rfl fun x x_mem ↦ if_neg (mem_erase.mp x_mem).1\n  · obtain ⟨x₁, x₁_mem', rfl⟩ := Finset.mem_map.mp x₁_mem\n    have := mem_erase.mp x₁_mem'\n    exact ⟨x₁, by\n      simpa only [f, Embedding.coeFn_mk, sub_add_cancel, this.2, true_and, if_neg this.1]⟩\n\n"}
{"name":"Module.finrank_zero_of_subsingleton","module":"Mathlib.LinearAlgebra.Dimension.Finite","initialProofState":"R : Type u\nM : Type v\ninst✝⁴ : Ring R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : Nontrivial R\ninst✝ : Subsingleton M\n⊢ Eq (Module.finrank R M) 0","decl":"/-- A (finite dimensional) space that is a subsingleton has zero `finrank`. -/\n@[nontriviality]\ntheorem Module.finrank_zero_of_subsingleton [Subsingleton M] :\n    finrank R M = 0 := by\n  rw [finrank, rank_subsingleton', _root_.map_zero]\n\n"}
{"name":"LinearIndependent.finrank_eq_zero_of_infinite","module":"Mathlib.LinearAlgebra.Dimension.Finite","initialProofState":"R : Type u\nM : Type v\ninst✝⁴ : Ring R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : Nontrivial R\nι : Type u_1\ninst✝ : Infinite ι\nv : ι → M\nhv : LinearIndependent R v\n⊢ Eq (Module.finrank R M) 0","decl":"lemma LinearIndependent.finrank_eq_zero_of_infinite {ι} [Infinite ι] {v : ι → M}\n    (hv : LinearIndependent R v) : finrank R M = 0 := toNat_eq_zero.mpr <| .inr hv.aleph0_le_rank\n\n"}
{"name":"Module.nontrivial_of_finrank_pos","module":"Mathlib.LinearAlgebra.Dimension.Finite","initialProofState":"R : Type u\nM : Type v\ninst✝⁴ : Ring R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : Nontrivial R\ninst✝ : NoZeroSMulDivisors R M\nh : LT.lt 0 (Module.finrank R M)\n⊢ Nontrivial M","decl":"/-- A finite dimensional space is nontrivial if it has positive `finrank`. -/\ntheorem Module.nontrivial_of_finrank_pos (h : 0 < finrank R M) : Nontrivial M :=\n  rank_pos_iff_nontrivial.mp (lt_rank_of_lt_finrank h)\n\n"}
{"name":"Module.nontrivial_of_finrank_eq_succ","module":"Mathlib.LinearAlgebra.Dimension.Finite","initialProofState":"R : Type u\nM : Type v\ninst✝⁴ : Ring R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : Nontrivial R\ninst✝ : NoZeroSMulDivisors R M\nn : Nat\nhn : Eq (Module.finrank R M) n.succ\n⊢ Nontrivial M","decl":"/-- A finite dimensional space is nontrivial if it has `finrank` equal to the successor of a\nnatural number. -/\ntheorem Module.nontrivial_of_finrank_eq_succ {n : ℕ}\n    (hn : finrank R M = n.succ) : Nontrivial M :=\n  nontrivial_of_finrank_pos (R := R) (by rw [hn]; exact n.succ_pos)\n\n"}
{"name":"finrank_bot","module":"Mathlib.LinearAlgebra.Dimension.Finite","initialProofState":"R : Type u\nM : Type v\ninst✝³ : Ring R\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : Nontrivial R\n⊢ Eq (Module.finrank R (Subtype fun x => Membership.mem Bot.bot x)) 0","decl":"@[simp]\ntheorem finrank_bot : finrank R (⊥ : Submodule R M) = 0 :=\n  finrank_eq_of_rank_eq (rank_bot _ _)\n\n"}
{"name":"Module.finrank_pos_iff_exists_ne_zero","module":"Mathlib.LinearAlgebra.Dimension.Finite","initialProofState":"R : Type u\nM : Type v\ninst✝⁵ : Ring R\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\ninst✝² : StrongRankCondition R\ninst✝¹ : Module.Finite R M\ninst✝ : NoZeroSMulDivisors R M\n⊢ Iff (LT.lt 0 (Module.finrank R M)) (Exists fun x => Ne x 0)","decl":"/-- A finite rank torsion-free module has positive `finrank` iff it has a nonzero element. -/\ntheorem Module.finrank_pos_iff_exists_ne_zero [NoZeroSMulDivisors R M] :\n    0 < finrank R M ↔ ∃ x : M, x ≠ 0 := by\n  rw [← @rank_pos_iff_exists_ne_zero R M, ← finrank_eq_rank]\n  norm_cast\n\n"}
{"name":"Module.finrank_pos_iff","module":"Mathlib.LinearAlgebra.Dimension.Finite","initialProofState":"R : Type u\nM : Type v\ninst✝⁵ : Ring R\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\ninst✝² : StrongRankCondition R\ninst✝¹ : Module.Finite R M\ninst✝ : NoZeroSMulDivisors R M\n⊢ Iff (LT.lt 0 (Module.finrank R M)) (Nontrivial M)","decl":"/-- An `R`-finite torsion-free module has positive `finrank` iff it is nontrivial. -/\ntheorem Module.finrank_pos_iff [NoZeroSMulDivisors R M] :\n    0 < finrank R M ↔ Nontrivial M := by\n  rw [← rank_pos_iff_nontrivial (R := R), ← finrank_eq_rank]\n  norm_cast\n\n"}
{"name":"Module.finrank_pos","module":"Mathlib.LinearAlgebra.Dimension.Finite","initialProofState":"R : Type u\nM : Type v\ninst✝⁵ : Ring R\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\ninst✝² : StrongRankCondition R\ninst✝¹ : Module.Finite R M\ninst✝ : NoZeroSMulDivisors R M\nh : Nontrivial M\n⊢ LT.lt 0 (Module.finrank R M)","decl":"/-- A nontrivial finite dimensional space has positive `finrank`. -/\ntheorem Module.finrank_pos [NoZeroSMulDivisors R M] [h : Nontrivial M] :\n    0 < finrank R M :=\n  finrank_pos_iff.mpr h\n\n"}
{"name":"Module.finrank_eq_zero_iff","module":"Mathlib.LinearAlgebra.Dimension.Finite","initialProofState":"R : Type u\nM : Type v\ninst✝⁴ : Ring R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : StrongRankCondition R\ninst✝ : Module.Finite R M\n⊢ Iff (Eq (Module.finrank R M) 0) (∀ (x : M), Exists fun a => And (Ne a 0) (Eq (HSMul.hSMul a x) 0))","decl":"/-- See `Module.finrank_zero_iff`\n  for the stronger version with `NoZeroSMulDivisors R M`. -/\ntheorem Module.finrank_eq_zero_iff :\n    finrank R M = 0 ↔ ∀ x : M, ∃ a : R, a ≠ 0 ∧ a • x = 0 := by\n  rw [← rank_eq_zero_iff (R := R), ← finrank_eq_rank]\n  norm_cast\n\n"}
{"name":"Module.finrank_zero_iff","module":"Mathlib.LinearAlgebra.Dimension.Finite","initialProofState":"R : Type u\nM : Type v\ninst✝⁵ : Ring R\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\ninst✝² : StrongRankCondition R\ninst✝¹ : Module.Finite R M\ninst✝ : NoZeroSMulDivisors R M\n⊢ Iff (Eq (Module.finrank R M) 0) (Subsingleton M)","decl":"/-- A finite dimensional space has zero `finrank` iff it is a subsingleton.\nThis is the `finrank` version of `rank_zero_iff`. -/\ntheorem Module.finrank_zero_iff [NoZeroSMulDivisors R M] :\n    finrank R M = 0 ↔ Subsingleton M := by\n  rw [← rank_zero_iff (R := R), ← finrank_eq_rank]\n  norm_cast\n\n"}
{"name":"Module.finrank_quotient_add_finrank_le","module":"Mathlib.LinearAlgebra.Dimension.Finite","initialProofState":"R : Type u\nM : Type v\ninst✝⁴ : Ring R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : StrongRankCondition R\ninst✝ : Module.Finite R M\nN : Submodule R M\n⊢ LE.le (HAdd.hAdd (Module.finrank R (HasQuotient.Quotient M N)) (Module.finrank R (Subtype fun x => Membership.mem N x))) (Module.finrank R M)","decl":"/-- Similar to `rank_quotient_add_rank_le` but for `finrank` and a finite `M`. -/\nlemma Module.finrank_quotient_add_finrank_le (N : Submodule R M) :\n    finrank R (M ⧸ N) + finrank R N ≤ finrank R M := by\n  haveI := nontrivial_of_invariantBasisNumber R\n  have := rank_quotient_add_rank_le N\n  rw [← finrank_eq_rank R M, ← finrank_eq_rank R, ← N.finrank_eq_rank] at this\n  exact mod_cast this\n\n"}
{"name":"Module.finrank_eq_zero_of_rank_eq_zero","module":"Mathlib.LinearAlgebra.Dimension.Finite","initialProofState":"R : Type u\nM : Type v\ninst✝² : Ring R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nh : Eq (Module.rank R M) 0\n⊢ Eq (Module.finrank R M) 0","decl":"theorem Module.finrank_eq_zero_of_rank_eq_zero (h : Module.rank R M = 0) :\n    finrank R M = 0 := by\n  delta finrank\n  rw [h, zero_toNat]\n\n"}
{"name":"Submodule.bot_eq_top_of_rank_eq_zero","module":"Mathlib.LinearAlgebra.Dimension.Finite","initialProofState":"R : Type u\nM : Type v\ninst✝³ : Ring R\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : NoZeroSMulDivisors R M\nh : Eq (Module.rank R M) 0\n⊢ Eq Bot.bot Top.top","decl":"theorem Submodule.bot_eq_top_of_rank_eq_zero [NoZeroSMulDivisors R M] (h : Module.rank R M = 0) :\n    (⊥ : Submodule R M) = ⊤ := by\n  nontriviality R\n  rw [rank_zero_iff] at h\n  subsingleton\n\n"}
{"name":"Submodule.rank_eq_zero","module":"Mathlib.LinearAlgebra.Dimension.Finite","initialProofState":"R : Type u\nM : Type v\ninst✝⁴ : Ring R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : Nontrivial R\ninst✝ : NoZeroSMulDivisors R M\nS : Submodule R M\n⊢ Iff (Eq (Module.rank R (Subtype fun x => Membership.mem S x)) 0) (Eq S Bot.bot)","decl":"/-- See `rank_subsingleton` for the reason that `Nontrivial R` is needed. -/\n@[simp]\ntheorem Submodule.rank_eq_zero [Nontrivial R] [NoZeroSMulDivisors R M] {S : Submodule R M} :\n    Module.rank R S = 0 ↔ S = ⊥ :=\n  ⟨fun h =>\n    (Submodule.eq_bot_iff _).2 fun x hx =>\n      congr_arg Subtype.val <|\n        ((Submodule.eq_bot_iff _).1 <| Eq.symm <| Submodule.bot_eq_top_of_rank_eq_zero h) ⟨x, hx⟩\n          Submodule.mem_top,\n    fun h => by rw [h, rank_bot]⟩\n\n"}
{"name":"Submodule.finrank_eq_zero","module":"Mathlib.LinearAlgebra.Dimension.Finite","initialProofState":"R : Type u\nM : Type v\ninst✝⁵ : Ring R\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\ninst✝² : StrongRankCondition R\ninst✝¹ : NoZeroSMulDivisors R M\nS : Submodule R M\ninst✝ : Module.Finite R (Subtype fun x => Membership.mem S x)\n⊢ Iff (Eq (Module.finrank R (Subtype fun x => Membership.mem S x)) 0) (Eq S Bot.bot)","decl":"@[simp]\ntheorem Submodule.finrank_eq_zero [StrongRankCondition R] [NoZeroSMulDivisors R M]\n    {S : Submodule R M} [Module.Finite R S] :\n    finrank R S = 0 ↔ S = ⊥ := by\n  rw [← Submodule.rank_eq_zero, ← finrank_eq_rank, ← @Nat.cast_zero Cardinal, Nat.cast_inj]\n\n"}
{"name":"Submodule.one_le_finrank_iff","module":"Mathlib.LinearAlgebra.Dimension.Finite","initialProofState":"R : Type u\nM : Type v\ninst✝⁵ : Ring R\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\ninst✝² : StrongRankCondition R\ninst✝¹ : NoZeroSMulDivisors R M\nS : Submodule R M\ninst✝ : Module.Finite R (Subtype fun x => Membership.mem S x)\n⊢ Iff (LE.le 1 (Module.finrank R (Subtype fun x => Membership.mem S x))) (Ne S Bot.bot)","decl":"@[simp]\nlemma Submodule.one_le_finrank_iff [StrongRankCondition R] [NoZeroSMulDivisors R M]\n    {S : Submodule R M} [Module.Finite R S] :\n    1 ≤ finrank R S ↔ S ≠ ⊥ := by\n  simp [← not_iff_not]\n\n"}
{"name":"finrank_eq_zero_of_basis_imp_not_finite","module":"Mathlib.LinearAlgebra.Dimension.Finite","initialProofState":"R : Type u\nM : Type v\ninst✝³ : Ring R\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : Module.Free R M\nh : ∀ (s : Set M), Basis (↑s) R M → Not s.Finite\n⊢ Eq (Module.finrank R M) 0","decl":"theorem finrank_eq_zero_of_basis_imp_not_finite\n    (h : ∀ s : Set M, Basis.{v} (s : Set M) R M → ¬s.Finite) : finrank R M = 0 := by\n  cases subsingleton_or_nontrivial R\n  · have := Module.subsingleton R M\n    exact (h ∅ ⟨LinearEquiv.ofSubsingleton _ _⟩ Set.finite_empty).elim\n  obtain ⟨_, ⟨b⟩⟩ := (Module.free_iff_set R M).mp ‹_›\n  have := Set.Infinite.to_subtype (h _ b)\n  exact b.linearIndependent.finrank_eq_zero_of_infinite\n\n"}
{"name":"finrank_eq_zero_of_basis_imp_false","module":"Mathlib.LinearAlgebra.Dimension.Finite","initialProofState":"R : Type u\nM : Type v\ninst✝³ : Ring R\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : Module.Free R M\nh : ∀ (s : Finset M), Basis (↑↑s) R M → False\n⊢ Eq (Module.finrank R M) 0","decl":"theorem finrank_eq_zero_of_basis_imp_false (h : ∀ s : Finset M, Basis.{v} (s : Set M) R M → False) :\n    finrank R M = 0 :=\n  finrank_eq_zero_of_basis_imp_not_finite fun s b hs =>\n    h hs.toFinset\n      (by\n        convert b\n        simp)\n\n"}
{"name":"finrank_eq_zero_of_not_exists_basis","module":"Mathlib.LinearAlgebra.Dimension.Finite","initialProofState":"R : Type u\nM : Type v\ninst✝³ : Ring R\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : Module.Free R M\nh : Not (Exists fun s => Nonempty (Basis (↑↑s) R M))\n⊢ Eq (Module.finrank R M) 0","decl":"theorem finrank_eq_zero_of_not_exists_basis\n    (h : ¬∃ s : Finset M, Nonempty (Basis (s : Set M) R M)) : finrank R M = 0 :=\n  finrank_eq_zero_of_basis_imp_false fun s b => h ⟨s, ⟨b⟩⟩\n\n"}
{"name":"finrank_eq_zero_of_not_exists_basis_finite","module":"Mathlib.LinearAlgebra.Dimension.Finite","initialProofState":"R : Type u\nM : Type v\ninst✝³ : Ring R\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : Module.Free R M\nh : Not (Exists fun s => Exists fun x => s.Finite)\n⊢ Eq (Module.finrank R M) 0","decl":"theorem finrank_eq_zero_of_not_exists_basis_finite\n    (h : ¬∃ (s : Set M) (_ : Basis.{v} (s : Set M) R M), s.Finite) : finrank R M = 0 :=\n  finrank_eq_zero_of_basis_imp_not_finite fun s b hs => h ⟨s, b, hs⟩\n\n"}
{"name":"finrank_eq_zero_of_not_exists_basis_finset","module":"Mathlib.LinearAlgebra.Dimension.Finite","initialProofState":"R : Type u\nM : Type v\ninst✝³ : Ring R\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : Module.Free R M\nh : Not (Exists fun s => Nonempty (Basis (Subtype fun x => Membership.mem s x) R M))\n⊢ Eq (Module.finrank R M) 0","decl":"theorem finrank_eq_zero_of_not_exists_basis_finset (h : ¬∃ s : Finset M, Nonempty (Basis s R M)) :\n    finrank R M = 0 :=\n  finrank_eq_zero_of_basis_imp_false fun s b => h ⟨s, ⟨b⟩⟩\n\n"}
{"name":"rank_eq_one","module":"Mathlib.LinearAlgebra.Dimension.Finite","initialProofState":"R : Type u\nM : Type v\ninst✝⁴ : Ring R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : NoZeroSMulDivisors R M\ninst✝ : StrongRankCondition R\nv : M\nn : Ne v 0\nh : ∀ (w : M), Exists fun c => Eq (HSMul.hSMul c v) w\n⊢ Eq (Module.rank R M) 1","decl":"/-- If there is a nonzero vector and every other vector is a multiple of it,\nthen the module has dimension one. -/\ntheorem rank_eq_one (v : M) (n : v ≠ 0) (h : ∀ w : M, ∃ c : R, c • v = w) :\n    Module.rank R M = 1 := by\n  haveI := nontrivial_of_invariantBasisNumber R\n  obtain ⟨b⟩ := (Basis.basis_singleton_iff.{_, _, u} PUnit).mpr ⟨v, n, h⟩\n  rw [rank_eq_card_basis b, Fintype.card_punit, Nat.cast_one]\n\n"}
{"name":"finrank_eq_one","module":"Mathlib.LinearAlgebra.Dimension.Finite","initialProofState":"R : Type u\nM : Type v\ninst✝⁴ : Ring R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : NoZeroSMulDivisors R M\ninst✝ : StrongRankCondition R\nv : M\nn : Ne v 0\nh : ∀ (w : M), Exists fun c => Eq (HSMul.hSMul c v) w\n⊢ Eq (Module.finrank R M) 1","decl":"/-- If there is a nonzero vector and every other vector is a multiple of it,\nthen the module has dimension one. -/\ntheorem finrank_eq_one (v : M) (n : v ≠ 0) (h : ∀ w : M, ∃ c : R, c • v = w) : finrank R M = 1 :=\n  finrank_eq_of_rank_eq (rank_eq_one v n h)\n\n"}
{"name":"finrank_le_one","module":"Mathlib.LinearAlgebra.Dimension.Finite","initialProofState":"R : Type u\nM : Type v\ninst✝⁴ : Ring R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : NoZeroSMulDivisors R M\ninst✝ : StrongRankCondition R\nv : M\nh : ∀ (w : M), Exists fun c => Eq (HSMul.hSMul c v) w\n⊢ LE.le (Module.finrank R M) 1","decl":"/-- If every vector is a multiple of some `v : M`, then `M` has dimension at most one.\n-/\ntheorem finrank_le_one (v : M) (h : ∀ w : M, ∃ c : R, c • v = w) : finrank R M ≤ 1 := by\n  haveI := nontrivial_of_invariantBasisNumber R\n  rcases eq_or_ne v 0 with (rfl | hn)\n  · haveI :=\n      _root_.subsingleton_of_forall_eq (0 : M) fun w => by\n        obtain ⟨c, rfl⟩ := h w\n        simp\n    rw [finrank_zero_of_subsingleton]\n    exact zero_le_one\n  · exact (finrank_eq_one v hn h).le\n\n"}
