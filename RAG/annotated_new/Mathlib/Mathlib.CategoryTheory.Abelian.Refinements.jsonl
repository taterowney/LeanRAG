{"name":"CategoryTheory.epi_iff_surjective_up_to_refinements","module":"Mathlib.CategoryTheory.Abelian.Refinements","initialProofState":"C : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_1, u_2} C\ninst✝ : CategoryTheory.Abelian C\nX Y : C\nf : Quiver.Hom X Y\n⊢ Iff (CategoryTheory.Epi f) (∀ ⦃A : C⦄ (y : Quiver.Hom A Y), Exists fun A' => Exists fun π => Exists fun x => Exists fun x => Eq (CategoryTheory.CategoryStruct.comp π y) (CategoryTheory.CategoryStruct.comp x f))","decl":"lemma epi_iff_surjective_up_to_refinements (f : X ⟶ Y) :\n    Epi f ↔ ∀ ⦃A : C⦄ (y : A ⟶ Y),\n      ∃ (A' : C) (π : A' ⟶ A) (_ : Epi π) (x : A' ⟶ X), π ≫ y = x ≫ f := by\n  constructor\n  · intro _ A a\n    exact ⟨pullback a f, pullback.fst a f, inferInstance, pullback.snd a f, pullback.condition⟩\n  · intro hf\n    obtain ⟨A, π, hπ, a', fac⟩ := hf (𝟙 Y)\n    rw [comp_id] at fac\n    exact epi_of_epi_fac fac.symm\n\n"}
{"name":"CategoryTheory.surjective_up_to_refinements_of_epi","module":"Mathlib.CategoryTheory.Abelian.Refinements","initialProofState":"C : Type u_2\ninst✝² : CategoryTheory.Category.{u_1, u_2} C\ninst✝¹ : CategoryTheory.Abelian C\nX Y : C\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.Epi f\nA : C\ny : Quiver.Hom A Y\n⊢ Exists fun A' => Exists fun π => Exists fun x => Exists fun x => Eq (CategoryTheory.CategoryStruct.comp π y) (CategoryTheory.CategoryStruct.comp x f)","decl":"lemma surjective_up_to_refinements_of_epi (f : X ⟶ Y) [Epi f] {A : C} (y : A ⟶ Y) :\n    ∃ (A' : C) (π : A' ⟶ A) (_ : Epi π) (x : A' ⟶ X), π ≫ y = x ≫ f :=\n  (epi_iff_surjective_up_to_refinements f).1 inferInstance y\n\n"}
{"name":"CategoryTheory.ShortComplex.exact_iff_exact_up_to_refinements","module":"Mathlib.CategoryTheory.Abelian.Refinements","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nS : CategoryTheory.ShortComplex C\n⊢ Iff S.Exact (∀ ⦃A : C⦄ (x₂ : Quiver.Hom A S.X₂), Eq (CategoryTheory.CategoryStruct.comp x₂ S.g) 0 → Exists fun A' => Exists fun π => Exists fun x => Exists fun x₁ => Eq (CategoryTheory.CategoryStruct.comp π x₂) (CategoryTheory.CategoryStruct.comp x₁ S.f))","decl":"lemma ShortComplex.exact_iff_exact_up_to_refinements :\n    S.Exact ↔ ∀ ⦃A : C⦄ (x₂ : A ⟶ S.X₂) (_ : x₂ ≫ S.g = 0),\n      ∃ (A' : C) (π : A' ⟶ A) (_ : Epi π) (x₁ : A' ⟶ S.X₁), π ≫ x₂ = x₁ ≫ S.f := by\n  rw [S.exact_iff_epi_toCycles, epi_iff_surjective_up_to_refinements]\n  constructor\n  · intro hS A a ha\n    obtain ⟨A', π, hπ, x₁, fac⟩ := hS (S.liftCycles a ha)\n    exact ⟨A', π, hπ, x₁, by simpa only [assoc, liftCycles_i, toCycles_i] using fac =≫ S.iCycles⟩\n  · intro hS A a\n    obtain ⟨A', π, hπ, x₁, fac⟩ := hS (a ≫ S.iCycles) (by simp)\n    exact ⟨A', π, hπ, x₁, by simp only [← cancel_mono S.iCycles, assoc, toCycles_i, fac]⟩\n\n"}
{"name":"CategoryTheory.ShortComplex.Exact.exact_up_to_refinements","module":"Mathlib.CategoryTheory.Abelian.Refinements","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nS : CategoryTheory.ShortComplex C\nhS : S.Exact\nA : C\nx₂ : Quiver.Hom A S.X₂\nhx₂ : Eq (CategoryTheory.CategoryStruct.comp x₂ S.g) 0\n⊢ Exists fun A' => Exists fun π => Exists fun x => Exists fun x₁ => Eq (CategoryTheory.CategoryStruct.comp π x₂) (CategoryTheory.CategoryStruct.comp x₁ S.f)","decl":"lemma ShortComplex.Exact.exact_up_to_refinements\n    (hS : S.Exact) {A : C} (x₂ : A ⟶ S.X₂) (hx₂ : x₂ ≫ S.g = 0) :\n    ∃ (A' : C) (π : A' ⟶ A) (_ : Epi π) (x₁ : A' ⟶ S.X₁), π ≫ x₂ = x₁ ≫ S.f := by\n  rw [ShortComplex.exact_iff_exact_up_to_refinements] at hS\n  exact hS x₂ hx₂\n\n"}
{"name":"CategoryTheory.ShortComplex.eq_liftCycles_homologyπ_up_to_refinements","module":"Mathlib.CategoryTheory.Abelian.Refinements","initialProofState":"C : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_1, u_2} C\ninst✝ : CategoryTheory.Abelian C\nS : CategoryTheory.ShortComplex C\nA : C\nγ : Quiver.Hom A S.homology\n⊢ Exists fun A' => Exists fun π => Exists fun x => Exists fun z => Exists fun hz => Eq (CategoryTheory.CategoryStruct.comp π γ) (CategoryTheory.CategoryStruct.comp (S.liftCycles z hz) S.homologyπ)","decl":"lemma ShortComplex.eq_liftCycles_homologyπ_up_to_refinements {A : C} (γ : A ⟶ S.homology) :\n    ∃ (A' : C) (π : A' ⟶ A) (_ : Epi π) (z : A' ⟶ S.X₂) (hz : z ≫ S.g = 0),\n      π ≫ γ = S.liftCycles z hz ≫ S.homologyπ := by\n  obtain ⟨A', π, hπ, z, hz⟩ := surjective_up_to_refinements_of_epi S.homologyπ γ\n  refine ⟨A', π, hπ, z ≫ S.iCycles, by simp, ?_⟩\n  rw [hz]\n  congr 1\n  rw [← cancel_mono S.iCycles, liftCycles_i]\n\n"}
