{"name":"CategoryTheory.epi_iff_surjective_up_to_refinements","module":"Mathlib.CategoryTheory.Abelian.Refinements","initialProofState":"C : Type u_2\ninstâœÂ¹ : CategoryTheory.Category.{u_1, u_2} C\ninstâœ : CategoryTheory.Abelian C\nX Y : C\nf : Quiver.Hom X Y\nâŠ¢ Iff (CategoryTheory.Epi f) (âˆ€ â¦ƒA : Câ¦„ (y : Quiver.Hom A Y), Exists fun A' => Exists fun Ï€ => Exists fun x => Exists fun x => Eq (CategoryTheory.CategoryStruct.comp Ï€ y) (CategoryTheory.CategoryStruct.comp x f))","decl":"lemma epi_iff_surjective_up_to_refinements (f : X âŸ¶ Y) :\n    Epi f â†” âˆ€ â¦ƒA : Câ¦„ (y : A âŸ¶ Y),\n      âˆƒ (A' : C) (Ï€ : A' âŸ¶ A) (_ : Epi Ï€) (x : A' âŸ¶ X), Ï€ â‰« y = x â‰« f := by\n  constructor\n  Â· intro _ A a\n    exact âŸ¨pullback a f, pullback.fst a f, inferInstance, pullback.snd a f, pullback.conditionâŸ©\n  Â· intro hf\n    obtain âŸ¨A, Ï€, hÏ€, a', facâŸ© := hf (ğŸ™ Y)\n    rw [comp_id] at fac\n    exact epi_of_epi_fac fac.symm\n\n"}
{"name":"CategoryTheory.surjective_up_to_refinements_of_epi","module":"Mathlib.CategoryTheory.Abelian.Refinements","initialProofState":"C : Type u_2\ninstâœÂ² : CategoryTheory.Category.{u_1, u_2} C\ninstâœÂ¹ : CategoryTheory.Abelian C\nX Y : C\nf : Quiver.Hom X Y\ninstâœ : CategoryTheory.Epi f\nA : C\ny : Quiver.Hom A Y\nâŠ¢ Exists fun A' => Exists fun Ï€ => Exists fun x => Exists fun x => Eq (CategoryTheory.CategoryStruct.comp Ï€ y) (CategoryTheory.CategoryStruct.comp x f)","decl":"lemma surjective_up_to_refinements_of_epi (f : X âŸ¶ Y) [Epi f] {A : C} (y : A âŸ¶ Y) :\n    âˆƒ (A' : C) (Ï€ : A' âŸ¶ A) (_ : Epi Ï€) (x : A' âŸ¶ X), Ï€ â‰« y = x â‰« f :=\n  (epi_iff_surjective_up_to_refinements f).1 inferInstance y\n\n"}
{"name":"CategoryTheory.ShortComplex.exact_iff_exact_up_to_refinements","module":"Mathlib.CategoryTheory.Abelian.Refinements","initialProofState":"C : Type u_1\ninstâœÂ¹ : CategoryTheory.Category.{u_2, u_1} C\ninstâœ : CategoryTheory.Abelian C\nS : CategoryTheory.ShortComplex C\nâŠ¢ Iff S.Exact (âˆ€ â¦ƒA : Câ¦„ (xâ‚‚ : Quiver.Hom A S.Xâ‚‚), Eq (CategoryTheory.CategoryStruct.comp xâ‚‚ S.g) 0 â†’ Exists fun A' => Exists fun Ï€ => Exists fun x => Exists fun xâ‚ => Eq (CategoryTheory.CategoryStruct.comp Ï€ xâ‚‚) (CategoryTheory.CategoryStruct.comp xâ‚ S.f))","decl":"lemma ShortComplex.exact_iff_exact_up_to_refinements :\n    S.Exact â†” âˆ€ â¦ƒA : Câ¦„ (xâ‚‚ : A âŸ¶ S.Xâ‚‚) (_ : xâ‚‚ â‰« S.g = 0),\n      âˆƒ (A' : C) (Ï€ : A' âŸ¶ A) (_ : Epi Ï€) (xâ‚ : A' âŸ¶ S.Xâ‚), Ï€ â‰« xâ‚‚ = xâ‚ â‰« S.f := by\n  rw [S.exact_iff_epi_toCycles, epi_iff_surjective_up_to_refinements]\n  constructor\n  Â· intro hS A a ha\n    obtain âŸ¨A', Ï€, hÏ€, xâ‚, facâŸ© := hS (S.liftCycles a ha)\n    exact âŸ¨A', Ï€, hÏ€, xâ‚, by simpa only [assoc, liftCycles_i, toCycles_i] using fac =â‰« S.iCyclesâŸ©\n  Â· intro hS A a\n    obtain âŸ¨A', Ï€, hÏ€, xâ‚, facâŸ© := hS (a â‰« S.iCycles) (by simp)\n    exact âŸ¨A', Ï€, hÏ€, xâ‚, by simp only [â† cancel_mono S.iCycles, assoc, toCycles_i, fac]âŸ©\n\n"}
{"name":"CategoryTheory.ShortComplex.Exact.exact_up_to_refinements","module":"Mathlib.CategoryTheory.Abelian.Refinements","initialProofState":"C : Type u_1\ninstâœÂ¹ : CategoryTheory.Category.{u_2, u_1} C\ninstâœ : CategoryTheory.Abelian C\nS : CategoryTheory.ShortComplex C\nhS : S.Exact\nA : C\nxâ‚‚ : Quiver.Hom A S.Xâ‚‚\nhxâ‚‚ : Eq (CategoryTheory.CategoryStruct.comp xâ‚‚ S.g) 0\nâŠ¢ Exists fun A' => Exists fun Ï€ => Exists fun x => Exists fun xâ‚ => Eq (CategoryTheory.CategoryStruct.comp Ï€ xâ‚‚) (CategoryTheory.CategoryStruct.comp xâ‚ S.f)","decl":"lemma ShortComplex.Exact.exact_up_to_refinements\n    (hS : S.Exact) {A : C} (xâ‚‚ : A âŸ¶ S.Xâ‚‚) (hxâ‚‚ : xâ‚‚ â‰« S.g = 0) :\n    âˆƒ (A' : C) (Ï€ : A' âŸ¶ A) (_ : Epi Ï€) (xâ‚ : A' âŸ¶ S.Xâ‚), Ï€ â‰« xâ‚‚ = xâ‚ â‰« S.f := by\n  rw [ShortComplex.exact_iff_exact_up_to_refinements] at hS\n  exact hS xâ‚‚ hxâ‚‚\n\n"}
{"name":"CategoryTheory.ShortComplex.eq_liftCycles_homologyÏ€_up_to_refinements","module":"Mathlib.CategoryTheory.Abelian.Refinements","initialProofState":"C : Type u_2\ninstâœÂ¹ : CategoryTheory.Category.{u_1, u_2} C\ninstâœ : CategoryTheory.Abelian C\nS : CategoryTheory.ShortComplex C\nA : C\nÎ³ : Quiver.Hom A S.homology\nâŠ¢ Exists fun A' => Exists fun Ï€ => Exists fun x => Exists fun z => Exists fun hz => Eq (CategoryTheory.CategoryStruct.comp Ï€ Î³) (CategoryTheory.CategoryStruct.comp (S.liftCycles z hz) S.homologyÏ€)","decl":"lemma ShortComplex.eq_liftCycles_homologyÏ€_up_to_refinements {A : C} (Î³ : A âŸ¶ S.homology) :\n    âˆƒ (A' : C) (Ï€ : A' âŸ¶ A) (_ : Epi Ï€) (z : A' âŸ¶ S.Xâ‚‚) (hz : z â‰« S.g = 0),\n      Ï€ â‰« Î³ = S.liftCycles z hz â‰« S.homologyÏ€ := by\n  obtain âŸ¨A', Ï€, hÏ€, z, hzâŸ© := surjective_up_to_refinements_of_epi S.homologyÏ€ Î³\n  refine âŸ¨A', Ï€, hÏ€, z â‰« S.iCycles, by simp, ?_âŸ©\n  rw [hz]\n  congr 1\n  rw [â† cancel_mono S.iCycles, liftCycles_i]\n\n"}
