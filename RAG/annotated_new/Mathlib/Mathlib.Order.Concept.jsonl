{"name":"subset_intentClosure_iff_subset_extentClosure","module":"Mathlib.Order.Concept","initialProofState":"α : Type u_2\nβ : Type u_3\nr : α → β → Prop\ns : Set α\nt : Set β\n⊢ Iff (HasSubset.Subset t (intentClosure r s)) (HasSubset.Subset s (extentClosure r t))","decl":"theorem subset_intentClosure_iff_subset_extentClosure :\n    t ⊆ intentClosure r s ↔ s ⊆ extentClosure r t :=\n  ⟨fun h _ ha _ hb => h hb ha, fun h _ hb _ ha => h ha hb⟩\n\n"}
{"name":"gc_intentClosure_extentClosure","module":"Mathlib.Order.Concept","initialProofState":"α : Type u_2\nβ : Type u_3\nr : α → β → Prop\n⊢ GaloisConnection (Function.comp (⇑OrderDual.toDual) (intentClosure r)) (Function.comp (extentClosure r) ⇑OrderDual.ofDual)","decl":"theorem gc_intentClosure_extentClosure :\n    GaloisConnection (toDual ∘ intentClosure r) (extentClosure r ∘ ofDual) := fun _ _ =>\n  subset_intentClosure_iff_subset_extentClosure\n\n"}
{"name":"intentClosure_swap","module":"Mathlib.Order.Concept","initialProofState":"α : Type u_2\nβ : Type u_3\nr : α → β → Prop\nt : Set β\n⊢ Eq (intentClosure (Function.swap r) t) (extentClosure r t)","decl":"theorem intentClosure_swap (t : Set β) : intentClosure (swap r) t = extentClosure r t :=\n  rfl\n\n"}
{"name":"extentClosure_swap","module":"Mathlib.Order.Concept","initialProofState":"α : Type u_2\nβ : Type u_3\nr : α → β → Prop\ns : Set α\n⊢ Eq (extentClosure (Function.swap r) s) (intentClosure r s)","decl":"theorem extentClosure_swap (s : Set α) : extentClosure (swap r) s = intentClosure r s :=\n  rfl\n\n"}
{"name":"intentClosure_empty","module":"Mathlib.Order.Concept","initialProofState":"α : Type u_2\nβ : Type u_3\nr : α → β → Prop\n⊢ Eq (intentClosure r EmptyCollection.emptyCollection) Set.univ","decl":"@[simp]\ntheorem intentClosure_empty : intentClosure r ∅ = univ :=\n  eq_univ_of_forall fun _ _ => False.elim\n\n"}
{"name":"extentClosure_empty","module":"Mathlib.Order.Concept","initialProofState":"α : Type u_2\nβ : Type u_3\nr : α → β → Prop\n⊢ Eq (extentClosure r EmptyCollection.emptyCollection) Set.univ","decl":"@[simp]\ntheorem extentClosure_empty : extentClosure r ∅ = univ :=\n  intentClosure_empty _\n\n"}
{"name":"intentClosure_union","module":"Mathlib.Order.Concept","initialProofState":"α : Type u_2\nβ : Type u_3\nr : α → β → Prop\ns₁ s₂ : Set α\n⊢ Eq (intentClosure r (Union.union s₁ s₂)) (Inter.inter (intentClosure r s₁) (intentClosure r s₂))","decl":"@[simp]\ntheorem intentClosure_union (s₁ s₂ : Set α) :\n    intentClosure r (s₁ ∪ s₂) = intentClosure r s₁ ∩ intentClosure r s₂ :=\n  Set.ext fun _ => forall₂_or_left\n\n"}
{"name":"extentClosure_union","module":"Mathlib.Order.Concept","initialProofState":"α : Type u_2\nβ : Type u_3\nr : α → β → Prop\nt₁ t₂ : Set β\n⊢ Eq (extentClosure r (Union.union t₁ t₂)) (Inter.inter (extentClosure r t₁) (extentClosure r t₂))","decl":"@[simp]\ntheorem extentClosure_union (t₁ t₂ : Set β) :\n    extentClosure r (t₁ ∪ t₂) = extentClosure r t₁ ∩ extentClosure r t₂ :=\n  intentClosure_union _ _ _\n\n"}
{"name":"intentClosure_iUnion","module":"Mathlib.Order.Concept","initialProofState":"ι : Sort u_1\nα : Type u_2\nβ : Type u_3\nr : α → β → Prop\nf : ι → Set α\n⊢ Eq (intentClosure r (Set.iUnion fun i => f i)) (Set.iInter fun i => intentClosure r (f i))","decl":"@[simp]\ntheorem intentClosure_iUnion (f : ι → Set α) :\n    intentClosure r (⋃ i, f i) = ⋂ i, intentClosure r (f i) :=\n  (gc_intentClosure_extentClosure r).l_iSup\n\n"}
{"name":"extentClosure_iUnion","module":"Mathlib.Order.Concept","initialProofState":"ι : Sort u_1\nα : Type u_2\nβ : Type u_3\nr : α → β → Prop\nf : ι → Set β\n⊢ Eq (extentClosure r (Set.iUnion fun i => f i)) (Set.iInter fun i => extentClosure r (f i))","decl":"@[simp]\ntheorem extentClosure_iUnion (f : ι → Set β) :\n    extentClosure r (⋃ i, f i) = ⋂ i, extentClosure r (f i) :=\n  intentClosure_iUnion _ _\n\n"}
{"name":"intentClosure_iUnion₂","module":"Mathlib.Order.Concept","initialProofState":"ι : Sort u_1\nα : Type u_2\nβ : Type u_3\nκ : ι → Sort u_4\nr : α → β → Prop\nf : (i : ι) → κ i → Set α\n⊢ Eq (intentClosure r (Set.iUnion fun i => Set.iUnion fun j => f i j)) (Set.iInter fun i => Set.iInter fun j => intentClosure r (f i j))","decl":"theorem intentClosure_iUnion₂ (f : ∀ i, κ i → Set α) :\n    intentClosure r (⋃ (i) (j), f i j) = ⋂ (i) (j), intentClosure r (f i j) :=\n  (gc_intentClosure_extentClosure r).l_iSup₂\n\n"}
{"name":"extentClosure_iUnion₂","module":"Mathlib.Order.Concept","initialProofState":"ι : Sort u_1\nα : Type u_2\nβ : Type u_3\nκ : ι → Sort u_4\nr : α → β → Prop\nf : (i : ι) → κ i → Set β\n⊢ Eq (extentClosure r (Set.iUnion fun i => Set.iUnion fun j => f i j)) (Set.iInter fun i => Set.iInter fun j => extentClosure r (f i j))","decl":"theorem extentClosure_iUnion₂ (f : ∀ i, κ i → Set β) :\n    extentClosure r (⋃ (i) (j), f i j) = ⋂ (i) (j), extentClosure r (f i j) :=\n  intentClosure_iUnion₂ _ _\n\n"}
{"name":"subset_extentClosure_intentClosure","module":"Mathlib.Order.Concept","initialProofState":"α : Type u_2\nβ : Type u_3\nr : α → β → Prop\ns : Set α\n⊢ HasSubset.Subset s (extentClosure r (intentClosure r s))","decl":"theorem subset_extentClosure_intentClosure (s : Set α) :\n    s ⊆ extentClosure r (intentClosure r s) :=\n  (gc_intentClosure_extentClosure r).le_u_l _\n\n"}
{"name":"subset_intentClosure_extentClosure","module":"Mathlib.Order.Concept","initialProofState":"α : Type u_2\nβ : Type u_3\nr : α → β → Prop\nt : Set β\n⊢ HasSubset.Subset t (intentClosure r (extentClosure r t))","decl":"theorem subset_intentClosure_extentClosure (t : Set β) :\n    t ⊆ intentClosure r (extentClosure r t) :=\n  subset_extentClosure_intentClosure _ t\n\n"}
{"name":"intentClosure_extentClosure_intentClosure","module":"Mathlib.Order.Concept","initialProofState":"α : Type u_2\nβ : Type u_3\nr : α → β → Prop\ns : Set α\n⊢ Eq (intentClosure r (extentClosure r (intentClosure r s))) (intentClosure r s)","decl":"@[simp]\ntheorem intentClosure_extentClosure_intentClosure (s : Set α) :\n    intentClosure r (extentClosure r <| intentClosure r s) = intentClosure r s :=\n  (gc_intentClosure_extentClosure r).l_u_l_eq_l _\n\n"}
{"name":"extentClosure_intentClosure_extentClosure","module":"Mathlib.Order.Concept","initialProofState":"α : Type u_2\nβ : Type u_3\nr : α → β → Prop\nt : Set β\n⊢ Eq (extentClosure r (intentClosure r (extentClosure r t))) (extentClosure r t)","decl":"@[simp]\ntheorem extentClosure_intentClosure_extentClosure (t : Set β) :\n    extentClosure r (intentClosure r <| extentClosure r t) = extentClosure r t :=\n  intentClosure_extentClosure_intentClosure _ t\n\n"}
{"name":"intentClosure_anti","module":"Mathlib.Order.Concept","initialProofState":"α : Type u_2\nβ : Type u_3\nr : α → β → Prop\n⊢ Antitone (intentClosure r)","decl":"theorem intentClosure_anti : Antitone (intentClosure r) :=\n  (gc_intentClosure_extentClosure r).monotone_l\n\n"}
{"name":"extentClosure_anti","module":"Mathlib.Order.Concept","initialProofState":"α : Type u_2\nβ : Type u_3\nr : α → β → Prop\n⊢ Antitone (extentClosure r)","decl":"theorem extentClosure_anti : Antitone (extentClosure r) :=\n  intentClosure_anti _\n\n"}
{"name":"Concept.mk.injEq","module":"Mathlib.Order.Concept","initialProofState":"α : Type u_2\nβ : Type u_3\nr : α → β → Prop\ntoProd✝ : Prod (Set α) (Set β)\nclosure_fst✝ : Eq (intentClosure r toProd✝.1) toProd✝.2\nclosure_snd✝ : Eq (extentClosure r toProd✝.2) toProd✝.1\ntoProd : Prod (Set α) (Set β)\nclosure_fst : Eq (intentClosure r toProd.1) toProd.2\nclosure_snd : Eq (extentClosure r toProd.2) toProd.1\n⊢ Eq (Eq { toProd := toProd✝, closure_fst := closure_fst✝, closure_snd := closure_snd✝ } { toProd := toProd, closure_fst := closure_fst, closure_snd := closure_snd }) (Eq toProd✝ toProd)","decl":"/-- The formal concepts of a relation. A concept of `r : α → β → Prop` is a pair of sets `s`, `t`\nsuch that `s` is the set of all elements that are `r`-related to all of `t` and `t` is the set of\nall elements that are `r`-related to all of `s`. -/\nstructure Concept extends Set α × Set β where\n  /-- The axiom of a `Concept` stating that the closure of the first set is the second set. -/\n  closure_fst : intentClosure r fst = snd\n  /-- The axiom of a `Concept` stating that the closure of the second set is the first set. -/\n  closure_snd : extentClosure r snd = fst\n\n"}
{"name":"Concept.mk.sizeOf_spec","module":"Mathlib.Order.Concept","initialProofState":"α : Type u_2\nβ : Type u_3\nr : α → β → Prop\ninst✝² : SizeOf α\ninst✝¹ : SizeOf β\ninst✝ : (a : α) → (a_1 : β) → SizeOf (r a a_1)\ntoProd : Prod (Set α) (Set β)\nclosure_fst : Eq (intentClosure r toProd.1) toProd.2\nclosure_snd : Eq (extentClosure r toProd.2) toProd.1\n⊢ Eq (SizeOf.sizeOf { toProd := toProd, closure_fst := closure_fst, closure_snd := closure_snd }) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf toProd)) (SizeOf.sizeOf closure_fst)) (SizeOf.sizeOf closure_snd))","decl":"/-- The formal concepts of a relation. A concept of `r : α → β → Prop` is a pair of sets `s`, `t`\nsuch that `s` is the set of all elements that are `r`-related to all of `t` and `t` is the set of\nall elements that are `r`-related to all of `s`. -/\nstructure Concept extends Set α × Set β where\n  /-- The axiom of a `Concept` stating that the closure of the first set is the second set. -/\n  closure_fst : intentClosure r fst = snd\n  /-- The axiom of a `Concept` stating that the closure of the second set is the first set. -/\n  closure_snd : extentClosure r snd = fst\n\n"}
{"name":"Concept.closure_snd","module":"Mathlib.Order.Concept","initialProofState":"α : Type u_2\nβ : Type u_3\nr : α → β → Prop\nself : Concept α β r\n⊢ Eq (extentClosure r self.toProd.2) self.toProd.1","decl":"/-- The formal concepts of a relation. A concept of `r : α → β → Prop` is a pair of sets `s`, `t`\nsuch that `s` is the set of all elements that are `r`-related to all of `t` and `t` is the set of\nall elements that are `r`-related to all of `s`. -/\nstructure Concept extends Set α × Set β where\n  /-- The axiom of a `Concept` stating that the closure of the first set is the second set. -/\n  closure_fst : intentClosure r fst = snd\n  /-- The axiom of a `Concept` stating that the closure of the second set is the first set. -/\n  closure_snd : extentClosure r snd = fst\n\n"}
{"name":"Concept.closure_fst","module":"Mathlib.Order.Concept","initialProofState":"α : Type u_2\nβ : Type u_3\nr : α → β → Prop\nself : Concept α β r\n⊢ Eq (intentClosure r self.toProd.1) self.toProd.2","decl":"/-- The formal concepts of a relation. A concept of `r : α → β → Prop` is a pair of sets `s`, `t`\nsuch that `s` is the set of all elements that are `r`-related to all of `t` and `t` is the set of\nall elements that are `r`-related to all of `s`. -/\nstructure Concept extends Set α × Set β where\n  /-- The axiom of a `Concept` stating that the closure of the first set is the second set. -/\n  closure_fst : intentClosure r fst = snd\n  /-- The axiom of a `Concept` stating that the closure of the second set is the first set. -/\n  closure_snd : extentClosure r snd = fst\n\n"}
{"name":"Concept.mk.inj","module":"Mathlib.Order.Concept","initialProofState":"α : Type u_2\nβ : Type u_3\nr : α → β → Prop\ntoProd✝ : Prod (Set α) (Set β)\nclosure_fst✝ : Eq (intentClosure r toProd✝.1) toProd✝.2\nclosure_snd✝ : Eq (extentClosure r toProd✝.2) toProd✝.1\ntoProd : Prod (Set α) (Set β)\nclosure_fst : Eq (intentClosure r toProd.1) toProd.2\nclosure_snd : Eq (extentClosure r toProd.2) toProd.1\nx✝ : Eq { toProd := toProd✝, closure_fst := closure_fst✝, closure_snd := closure_snd✝ } { toProd := toProd, closure_fst := closure_fst, closure_snd := closure_snd }\n⊢ Eq toProd✝ toProd","decl":"/-- The formal concepts of a relation. A concept of `r : α → β → Prop` is a pair of sets `s`, `t`\nsuch that `s` is the set of all elements that are `r`-related to all of `t` and `t` is the set of\nall elements that are `r`-related to all of `s`. -/\nstructure Concept extends Set α × Set β where\n  /-- The axiom of a `Concept` stating that the closure of the first set is the second set. -/\n  closure_fst : intentClosure r fst = snd\n  /-- The axiom of a `Concept` stating that the closure of the second set is the first set. -/\n  closure_snd : extentClosure r snd = fst\n\n"}
{"name":"Concept.ext","module":"Mathlib.Order.Concept","initialProofState":"α : Type u_2\nβ : Type u_3\nr : α → β → Prop\nc d : Concept α β r\nh : Eq c.toProd.1 d.toProd.1\n⊢ Eq c d","decl":"@[ext]\ntheorem ext (h : c.fst = d.fst) : c = d := by\n  obtain ⟨⟨s₁, t₁⟩, h₁, _⟩ := c\n  obtain ⟨⟨s₂, t₂⟩, h₂, _⟩ := d\n  dsimp at h₁ h₂ h\n  substs h h₁ h₂\n  rfl\n\n"}
{"name":"Concept.ext_iff","module":"Mathlib.Order.Concept","initialProofState":"α : Type u_2\nβ : Type u_3\nr : α → β → Prop\nc d : Concept α β r\n⊢ Iff (Eq c d) (Eq c.toProd.1 d.toProd.1)","decl":"@[ext]\ntheorem ext (h : c.fst = d.fst) : c = d := by\n  obtain ⟨⟨s₁, t₁⟩, h₁, _⟩ := c\n  obtain ⟨⟨s₂, t₂⟩, h₂, _⟩ := d\n  dsimp at h₁ h₂ h\n  substs h h₁ h₂\n  rfl\n\n"}
{"name":"Concept.ext'","module":"Mathlib.Order.Concept","initialProofState":"α : Type u_2\nβ : Type u_3\nr : α → β → Prop\nc d : Concept α β r\nh : Eq c.toProd.2 d.toProd.2\n⊢ Eq c d","decl":"theorem ext' (h : c.snd = d.snd) : c = d := by\n  obtain ⟨⟨s₁, t₁⟩, _, h₁⟩ := c\n  obtain ⟨⟨s₂, t₂⟩, _, h₂⟩ := d\n  dsimp at h₁ h₂ h\n  substs h h₁ h₂\n  rfl\n\n"}
{"name":"Concept.fst_injective","module":"Mathlib.Order.Concept","initialProofState":"α : Type u_2\nβ : Type u_3\nr : α → β → Prop\n⊢ Function.Injective fun c => c.toProd.1","decl":"theorem fst_injective : Injective fun c : Concept α β r => c.fst := fun _ _ => ext\n\n"}
{"name":"Concept.snd_injective","module":"Mathlib.Order.Concept","initialProofState":"α : Type u_2\nβ : Type u_3\nr : α → β → Prop\n⊢ Function.Injective fun c => c.toProd.2","decl":"theorem snd_injective : Injective fun c : Concept α β r => c.snd := fun _ _ => ext'\n\n"}
{"name":"Concept.fst_subset_fst_iff","module":"Mathlib.Order.Concept","initialProofState":"α : Type u_2\nβ : Type u_3\nr : α → β → Prop\nc d : Concept α β r\n⊢ Iff (HasSubset.Subset c.toProd.1 d.toProd.1) (LE.le c d)","decl":"@[simp]\ntheorem fst_subset_fst_iff : c.fst ⊆ d.fst ↔ c ≤ d :=\n  Iff.rfl\n\n"}
{"name":"Concept.fst_ssubset_fst_iff","module":"Mathlib.Order.Concept","initialProofState":"α : Type u_2\nβ : Type u_3\nr : α → β → Prop\nc d : Concept α β r\n⊢ Iff (HasSSubset.SSubset c.toProd.1 d.toProd.1) (LT.lt c d)","decl":"@[simp]\ntheorem fst_ssubset_fst_iff : c.fst ⊂ d.fst ↔ c < d :=\n  Iff.rfl\n\n"}
{"name":"Concept.snd_subset_snd_iff","module":"Mathlib.Order.Concept","initialProofState":"α : Type u_2\nβ : Type u_3\nr : α → β → Prop\nc d : Concept α β r\n⊢ Iff (HasSubset.Subset c.toProd.2 d.toProd.2) (LE.le d c)","decl":"@[simp]\ntheorem snd_subset_snd_iff : c.snd ⊆ d.snd ↔ d ≤ c := by\n  refine ⟨fun h => ?_, fun h => ?_⟩\n  · rw [← fst_subset_fst_iff, ← c.closure_snd, ← d.closure_snd]\n    exact extentClosure_anti _ h\n  · rw [← c.closure_fst, ← d.closure_fst]\n    exact intentClosure_anti _ h\n\n"}
{"name":"Concept.snd_ssubset_snd_iff","module":"Mathlib.Order.Concept","initialProofState":"α : Type u_2\nβ : Type u_3\nr : α → β → Prop\nc d : Concept α β r\n⊢ Iff (HasSSubset.SSubset c.toProd.2 d.toProd.2) (LT.lt d c)","decl":"@[simp]\ntheorem snd_ssubset_snd_iff : c.snd ⊂ d.snd ↔ d < c := by\n  rw [ssubset_iff_subset_not_subset, lt_iff_le_not_le, snd_subset_snd_iff, snd_subset_snd_iff]\n\n"}
{"name":"Concept.strictMono_fst","module":"Mathlib.Order.Concept","initialProofState":"α : Type u_2\nβ : Type u_3\nr : α → β → Prop\n⊢ StrictMono (Function.comp Prod.fst Concept.toProd)","decl":"theorem strictMono_fst : StrictMono (Prod.fst ∘ toProd : Concept α β r → Set α) := fun _ _ =>\n  fst_ssubset_fst_iff.2\n\n"}
{"name":"Concept.strictAnti_snd","module":"Mathlib.Order.Concept","initialProofState":"α : Type u_2\nβ : Type u_3\nr : α → β → Prop\n⊢ StrictAnti (Function.comp Prod.snd Concept.toProd)","decl":"theorem strictAnti_snd : StrictAnti (Prod.snd ∘ toProd : Concept α β r → Set β) := fun _ _ =>\n  snd_ssubset_snd_iff.2\n\n"}
{"name":"Concept.top_fst","module":"Mathlib.Order.Concept","initialProofState":"α : Type u_2\nβ : Type u_3\nr : α → β → Prop\n⊢ Eq Top.top.toProd.1 Set.univ","decl":"@[simp]\ntheorem top_fst : (⊤ : Concept α β r).fst = univ :=\n  rfl\n\n"}
{"name":"Concept.top_snd","module":"Mathlib.Order.Concept","initialProofState":"α : Type u_2\nβ : Type u_3\nr : α → β → Prop\n⊢ Eq Top.top.toProd.2 (intentClosure r Set.univ)","decl":"@[simp]\ntheorem top_snd : (⊤ : Concept α β r).snd = intentClosure r univ :=\n  rfl\n\n"}
{"name":"Concept.bot_fst","module":"Mathlib.Order.Concept","initialProofState":"α : Type u_2\nβ : Type u_3\nr : α → β → Prop\n⊢ Eq Bot.bot.toProd.1 (extentClosure r Set.univ)","decl":"@[simp]\ntheorem bot_fst : (⊥ : Concept α β r).fst = extentClosure r univ :=\n  rfl\n\n"}
{"name":"Concept.bot_snd","module":"Mathlib.Order.Concept","initialProofState":"α : Type u_2\nβ : Type u_3\nr : α → β → Prop\n⊢ Eq Bot.bot.toProd.2 Set.univ","decl":"@[simp]\ntheorem bot_snd : (⊥ : Concept α β r).snd = univ :=\n  rfl\n\n"}
{"name":"Concept.sup_fst","module":"Mathlib.Order.Concept","initialProofState":"α : Type u_2\nβ : Type u_3\nr : α → β → Prop\nc d : Concept α β r\n⊢ Eq (Max.max c d).toProd.1 (extentClosure r (Inter.inter c.toProd.2 d.toProd.2))","decl":"@[simp]\ntheorem sup_fst (c d : Concept α β r) : (c ⊔ d).fst = extentClosure r (c.snd ∩ d.snd) :=\n  rfl\n\n"}
{"name":"Concept.sup_snd","module":"Mathlib.Order.Concept","initialProofState":"α : Type u_2\nβ : Type u_3\nr : α → β → Prop\nc d : Concept α β r\n⊢ Eq (Max.max c d).toProd.2 (Inter.inter c.toProd.2 d.toProd.2)","decl":"@[simp]\ntheorem sup_snd (c d : Concept α β r) : (c ⊔ d).snd = c.snd ∩ d.snd :=\n  rfl\n\n"}
{"name":"Concept.inf_fst","module":"Mathlib.Order.Concept","initialProofState":"α : Type u_2\nβ : Type u_3\nr : α → β → Prop\nc d : Concept α β r\n⊢ Eq (Min.min c d).toProd.1 (Inter.inter c.toProd.1 d.toProd.1)","decl":"@[simp]\ntheorem inf_fst (c d : Concept α β r) : (c ⊓ d).fst = c.fst ∩ d.fst :=\n  rfl\n\n"}
{"name":"Concept.inf_snd","module":"Mathlib.Order.Concept","initialProofState":"α : Type u_2\nβ : Type u_3\nr : α → β → Prop\nc d : Concept α β r\n⊢ Eq (Min.min c d).toProd.2 (intentClosure r (Inter.inter c.toProd.1 d.toProd.1))","decl":"@[simp]\ntheorem inf_snd (c d : Concept α β r) : (c ⊓ d).snd = intentClosure r (c.fst ∩ d.fst) :=\n  rfl\n\n"}
{"name":"Concept.sSup_fst","module":"Mathlib.Order.Concept","initialProofState":"α : Type u_2\nβ : Type u_3\nr : α → β → Prop\nS : Set (Concept α β r)\n⊢ Eq (SupSet.sSup S).toProd.1 (extentClosure r (Set.iInter fun c => Set.iInter fun h => c.toProd.2))","decl":"@[simp]\ntheorem sSup_fst (S : Set (Concept α β r)) :\n    (sSup S).fst = extentClosure r (⋂ c ∈ S, (c : Concept _ _ _).snd) :=\n  rfl\n\n"}
{"name":"Concept.sSup_snd","module":"Mathlib.Order.Concept","initialProofState":"α : Type u_2\nβ : Type u_3\nr : α → β → Prop\nS : Set (Concept α β r)\n⊢ Eq (SupSet.sSup S).toProd.2 (Set.iInter fun c => Set.iInter fun h => c.toProd.2)","decl":"@[simp]\ntheorem sSup_snd (S : Set (Concept α β r)) : (sSup S).snd = ⋂ c ∈ S, (c : Concept _ _ _).snd :=\n  rfl\n\n"}
{"name":"Concept.sInf_fst","module":"Mathlib.Order.Concept","initialProofState":"α : Type u_2\nβ : Type u_3\nr : α → β → Prop\nS : Set (Concept α β r)\n⊢ Eq (InfSet.sInf S).toProd.1 (Set.iInter fun c => Set.iInter fun h => c.toProd.1)","decl":"@[simp]\ntheorem sInf_fst (S : Set (Concept α β r)) : (sInf S).fst = ⋂ c ∈ S, (c : Concept _ _ _).fst :=\n  rfl\n\n"}
{"name":"Concept.sInf_snd","module":"Mathlib.Order.Concept","initialProofState":"α : Type u_2\nβ : Type u_3\nr : α → β → Prop\nS : Set (Concept α β r)\n⊢ Eq (InfSet.sInf S).toProd.2 (intentClosure r (Set.iInter fun c => Set.iInter fun h => c.toProd.1))","decl":"@[simp]\ntheorem sInf_snd (S : Set (Concept α β r)) :\n    (sInf S).snd = intentClosure r (⋂ c ∈ S, (c : Concept _ _ _).fst) :=\n  rfl\n\n"}
{"name":"Concept.swap_toProd","module":"Mathlib.Order.Concept","initialProofState":"α : Type u_2\nβ : Type u_3\nr : α → β → Prop\nc : Concept α β r\n⊢ Eq c.swap.toProd c.swap","decl":"/-- Swap the sets of a concept to make it a concept of the dual context. -/\n@[simps]\ndef swap (c : Concept α β r) : Concept β α (swap r) :=\n  ⟨c.toProd.swap, c.closure_snd, c.closure_fst⟩\n\n"}
{"name":"Concept.swap_swap","module":"Mathlib.Order.Concept","initialProofState":"α : Type u_2\nβ : Type u_3\nr : α → β → Prop\nc : Concept α β r\n⊢ Eq c.swap.swap c","decl":"@[simp]\ntheorem swap_swap (c : Concept α β r) : c.swap.swap = c :=\n  ext rfl\n\n"}
{"name":"Concept.swap_le_swap_iff","module":"Mathlib.Order.Concept","initialProofState":"α : Type u_2\nβ : Type u_3\nr : α → β → Prop\nc d : Concept α β r\n⊢ Iff (LE.le c.swap d.swap) (LE.le d c)","decl":"@[simp]\ntheorem swap_le_swap_iff : c.swap ≤ d.swap ↔ d ≤ c :=\n  snd_subset_snd_iff\n\n"}
{"name":"Concept.swap_lt_swap_iff","module":"Mathlib.Order.Concept","initialProofState":"α : Type u_2\nβ : Type u_3\nr : α → β → Prop\nc d : Concept α β r\n⊢ Iff (LT.lt c.swap d.swap) (LT.lt d c)","decl":"@[simp]\ntheorem swap_lt_swap_iff : c.swap < d.swap ↔ d < c :=\n  snd_ssubset_snd_iff\n\n"}
{"name":"Concept.swapEquiv_symm_apply","module":"Mathlib.Order.Concept","initialProofState":"α : Type u_2\nβ : Type u_3\nr : α → β → Prop\na✝ : Concept β α (Function.swap r)\n⊢ Eq ((RelIso.symm Concept.swapEquiv) a✝) (Function.comp (⇑OrderDual.toDual) Concept.swap a✝)","decl":"/-- The dual of a concept lattice is isomorphic to the concept lattice of the dual context. -/\n@[simps]\ndef swapEquiv : (Concept α β r)ᵒᵈ ≃o Concept β α (Function.swap r) where\n  toFun := swap ∘ ofDual\n  invFun := toDual ∘ swap\n  left_inv := swap_swap\n  right_inv := swap_swap\n  map_rel_iff' := swap_le_swap_iff\n\n"}
{"name":"Concept.swapEquiv_apply","module":"Mathlib.Order.Concept","initialProofState":"α : Type u_2\nβ : Type u_3\nr : α → β → Prop\na✝ : OrderDual (Concept α β r)\n⊢ Eq (Concept.swapEquiv a✝) (Function.comp Concept.swap (⇑OrderDual.ofDual) a✝)","decl":"/-- The dual of a concept lattice is isomorphic to the concept lattice of the dual context. -/\n@[simps]\ndef swapEquiv : (Concept α β r)ᵒᵈ ≃o Concept β α (Function.swap r) where\n  toFun := swap ∘ ofDual\n  invFun := toDual ∘ swap\n  left_inv := swap_swap\n  right_inv := swap_swap\n  map_rel_iff' := swap_le_swap_iff\n\n"}
