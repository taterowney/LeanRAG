{"name":"LieModule.exists_nontrivial_weightSpace_of_lieIdeal","module":"Mathlib.Algebra.Lie.LieTheorem","initialProofState":"k : Type u_1\ninst✝¹⁰ : Field k\nL : Type u_2\ninst✝⁹ : LieRing L\ninst✝⁸ : LieAlgebra k L\nV : Type u_3\ninst✝⁷ : AddCommGroup V\ninst✝⁶ : Module k V\ninst✝⁵ : LieRingModule L V\ninst✝⁴ : LieModule k L V\ninst✝³ : CharZero k\ninst✝² : Module.Finite k V\ninst✝¹ : LieModule.IsTriangularizable k L V\nA : LieIdeal k L\nhA : IsCoatom ↑A\nχ₀ : Module.Dual k (Subtype fun x => Membership.mem A x)\ninst✝ : Nontrivial (Subtype fun x => Membership.mem (LieModule.weightSpace V ⇑χ₀) x)\n⊢ Exists fun χ => Nontrivial (Subtype fun x => Membership.mem (LieModule.weightSpace V ⇑χ) x)","decl":"open Submodule in\ntheorem exists_nontrivial_weightSpace_of_lieIdeal [LieModule.IsTriangularizable k L V]\n    (A : LieIdeal k L) (hA : IsCoatom A.toSubmodule)\n    (χ₀ : Module.Dual k A) [Nontrivial (weightSpace V χ₀)] :\n    ∃ (χ : Module.Dual k L), Nontrivial (weightSpace V χ) := by\n  obtain ⟨z, -, hz⟩ := SetLike.exists_of_lt (hA.lt_top)\n  let e : (k ∙ z) ≃ₗ[k] k := (LinearEquiv.toSpanNonzeroSingleton k L z <| by aesop).symm\n  have he : ∀ x, e x • z = x := by simp [e]\n  have hA : IsCompl A.toSubmodule (k ∙ z) := isCompl_span_singleton_of_isCoatom_of_not_mem hA hz\n  let π₁ : L →ₗ[k] A       := A.toSubmodule.linearProjOfIsCompl (k ∙ z) hA\n  let π₂ : L →ₗ[k] (k ∙ z) := (k ∙ z).linearProjOfIsCompl ↑A hA.symm\n\n  set W : LieSubmodule k L V := weightSpaceOfIsLieTower k V χ₀\n  obtain ⟨c, hc⟩ : ∃ c, (toEnd k _ W z).HasEigenvalue c := by\n    have : Nontrivial W := inferInstanceAs (Nontrivial (weightSpace V χ₀))\n    apply Module.End.exists_hasEigenvalue_of_genEigenspace_eq_top\n    exact LieModule.IsTriangularizable.maxGenEigenspace_eq_top z\n\n  obtain ⟨⟨v, hv⟩, hvc⟩ := hc.exists_hasEigenvector\n  have hv' : ∀ (x : ↥A), ⁅x, v⁆ = χ₀ x • v := by\n    simpa [W, weightSpaceOfIsLieTower, mem_weightSpace] using hv\n\n  use (χ₀.comp π₁) + c • (e.comp π₂)\n  refine nontrivial_of_ne ⟨v, ?_⟩ 0 ?_\n  · rw [mem_weightSpace]\n    intro x\n    have hπ : (π₁ x : L) + π₂ x = x := linear_proj_add_linearProjOfIsCompl_eq_self hA x\n    suffices ⁅(π₂ x : L), v⁆ = (c • e (π₂ x)) • v by\n      calc ⁅x, v⁆\n          = ⁅π₁ x, v⁆       + ⁅(π₂ x : L), v⁆    := congr(⁅$hπ.symm, v⁆) ▸ add_lie _ _ _\n        _ =  χ₀ (π₁ x) • v  + (c • e (π₂ x)) • v := by rw [hv' (π₁ x), this]\n        _ = _ := by simp [add_smul]\n    calc ⁅(π₂ x : L), v⁆\n        = e (π₂ x) • ↑(c • ⟨v, hv⟩ : W) := by rw [← he, smul_lie, ← hvc.apply_eq_smul]; rfl\n      _ = (c • e (π₂ x)) • v              := by rw [smul_assoc, smul_comm]; rfl\n  · simpa [ne_eq, LieSubmodule.mk_eq_zero] using hvc.right\n\n"}
{"name":"LieModule.exists_nontrivial_weightSpace_of_isSolvable","module":"Mathlib.Algebra.Lie.LieTheorem","initialProofState":"k : Type u_1\ninst✝¹¹ : Field k\nL : Type u_2\ninst✝¹⁰ : LieRing L\ninst✝⁹ : LieAlgebra k L\nV : Type u_3\ninst✝⁸ : AddCommGroup V\ninst✝⁷ : Module k V\ninst✝⁶ : LieRingModule L V\ninst✝⁵ : LieModule k L V\ninst✝⁴ : CharZero k\ninst✝³ : Module.Finite k V\ninst✝² : Nontrivial V\ninst✝¹ : LieAlgebra.IsSolvable L\ninst✝ : LieModule.IsTriangularizable k L V\n⊢ Exists fun χ => Nontrivial (Subtype fun x => Membership.mem (LieModule.weightSpace V ⇑χ) x)","decl":"/-- **Lie's theorem**: Lie modules of solvable Lie algebras over fields of characteristic 0\nhave a common eigenvector for the action of all elements of the Lie algebra.\n\nSee `LieModule.exists_nontrivial_weightSpace_of_isNilpotent` for the variant that\nassumes that `L` is nilpotent and drops the condition that `k` is of characteristic zero. -/\ntheorem exists_nontrivial_weightSpace_of_isSolvable\n    [IsSolvable L] [LieModule.IsTriangularizable k L V] :\n    ∃ χ : Module.Dual k L, Nontrivial (weightSpace V χ) := by\n  let imL := (toEnd k L V).range\n  let toEndo : L →ₗ[k] imL := LinearMap.codRestrict imL.toSubmodule (toEnd k L V)\n      (fun x ↦ LinearMap.mem_range.mpr ⟨x, rfl⟩ : ∀ x : L, (toEnd k L V) x ∈ imL)\n  have ⟨χ, h⟩ := exists_forall_lie_eq_smul_of_isSolvable_of_finite k V imL\n  use χ.comp toEndo\n  obtain ⟨⟨v, hv⟩, hv0⟩ := exists_ne (0 : weightSpace V χ)\n  refine nontrivial_of_ne ⟨v, ?_⟩ 0 ?_\n  · rw [mem_weightSpace] at hv ⊢\n    intro x\n    apply hv (toEndo x)\n  · simpa using hv0\n\n"}
