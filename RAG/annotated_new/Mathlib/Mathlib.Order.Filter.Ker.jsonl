{"name":"Filter.ker_def","module":"Mathlib.Order.Filter.Ker","initialProofState":"Œ± : Type u_2\nf : Filter Œ±\n‚ä¢ Eq f.ker (Set.iInter fun s => Set.iInter fun h => s)","decl":"lemma ker_def (f : Filter Œ±) : f.ker = ‚ãÇ s ‚àà f, s := sInter_eq_biInter\n\n"}
{"name":"Filter.mem_ker","module":"Mathlib.Order.Filter.Ker","initialProofState":"Œ± : Type u_2\nf : Filter Œ±\na : Œ±\n‚ä¢ Iff (Membership.mem f.ker a) (‚àÄ (s : Set Œ±), Membership.mem f s ‚Üí Membership.mem s a)","decl":"@[simp] lemma mem_ker : a ‚àà f.ker ‚Üî ‚àÄ s ‚àà f, a ‚àà s := mem_sInter\n"}
{"name":"Filter.subset_ker","module":"Mathlib.Order.Filter.Ker","initialProofState":"Œ± : Type u_2\nf : Filter Œ±\ns : Set Œ±\n‚ä¢ Iff (HasSubset.Subset s f.ker) (‚àÄ (t : Set Œ±), Membership.mem f t ‚Üí HasSubset.Subset s t)","decl":"@[simp] lemma subset_ker : s ‚äÜ f.ker ‚Üî ‚àÄ t ‚àà f, s ‚äÜ t := subset_sInter_iff\n\n"}
{"name":"Filter.ker_mono","module":"Mathlib.Order.Filter.Ker","initialProofState":"Œ± : Type u_2\n‚ä¢ Monotone Filter.ker","decl":"lemma ker_mono : Monotone (ker : Filter Œ± ‚Üí Set Œ±) := gi_principal_ker.gc.monotone_u\n"}
{"name":"Filter.ker_surjective","module":"Mathlib.Order.Filter.Ker","initialProofState":"Œ± : Type u_2\n‚ä¢ Function.Surjective Filter.ker","decl":"lemma ker_surjective : Surjective (ker : Filter Œ± ‚Üí Set Œ±) := gi_principal_ker.u_surjective\n\n"}
{"name":"Filter.ker_bot","module":"Mathlib.Order.Filter.Ker","initialProofState":"Œ± : Type u_2\n‚ä¢ Eq Bot.bot.ker EmptyCollection.emptyCollection","decl":"@[simp] lemma ker_bot : ker (‚ä• : Filter Œ±) = ‚àÖ := sInter_eq_empty_iff.2 fun _ ‚Ü¶ ‚ü®‚àÖ, trivial, id‚ü©\n"}
{"name":"Filter.ker_top","module":"Mathlib.Order.Filter.Ker","initialProofState":"Œ± : Type u_2\n‚ä¢ Eq Top.top.ker Set.univ","decl":"@[simp] lemma ker_top : ker (‚ä§ : Filter Œ±) = univ := gi_principal_ker.gc.u_top\n"}
{"name":"Filter.ker_eq_univ","module":"Mathlib.Order.Filter.Ker","initialProofState":"Œ± : Type u_2\nf : Filter Œ±\n‚ä¢ Iff (Eq f.ker Set.univ) (Eq f Top.top)","decl":"@[simp] lemma ker_eq_univ : ker f = univ ‚Üî f = ‚ä§ := gi_principal_ker.gc.u_eq_top.trans <| by simp\n"}
{"name":"Filter.ker_inf","module":"Mathlib.Order.Filter.Ker","initialProofState":"Œ± : Type u_2\nf g : Filter Œ±\n‚ä¢ Eq (Min.min f g).ker (Inter.inter f.ker g.ker)","decl":"@[simp] lemma ker_inf (f g : Filter Œ±) : ker (f ‚äì g) = ker f ‚à© ker g := gi_principal_ker.gc.u_inf\n"}
{"name":"Filter.ker_iInf","module":"Mathlib.Order.Filter.Ker","initialProofState":"Œπ : Sort u_1\nŒ± : Type u_2\nf : Œπ ‚Üí Filter Œ±\n‚ä¢ Eq (iInf fun i => f i).ker (Set.iInter fun i => (f i).ker)","decl":"@[simp] lemma ker_iInf (f : Œπ ‚Üí Filter Œ±) : ker (‚®Ö i, f i) = ‚ãÇ i, ker (f i) :=\n  gi_principal_ker.gc.u_iInf\n"}
{"name":"Filter.ker_sInf","module":"Mathlib.Order.Filter.Ker","initialProofState":"Œ± : Type u_2\nS : Set (Filter Œ±)\n‚ä¢ Eq (InfSet.sInf S).ker (Set.iInter fun f => Set.iInter fun h => f.ker)","decl":"@[simp] lemma ker_sInf (S : Set (Filter Œ±)) : ker (sInf S) = ‚ãÇ f ‚àà S, ker f :=\n  gi_principal_ker.gc.u_sInf\n"}
{"name":"Filter.ker_principal","module":"Mathlib.Order.Filter.Ker","initialProofState":"Œ± : Type u_2\ns : Set Œ±\n‚ä¢ Eq (Filter.principal s).ker s","decl":"@[simp] lemma ker_principal (s : Set Œ±) : ker (ùìü s) = s := gi_principal_ker.u_l_eq _\n\n"}
{"name":"Filter.ker_pure","module":"Mathlib.Order.Filter.Ker","initialProofState":"Œ± : Type u_2\na : Œ±\n‚ä¢ Eq (Pure.pure a).ker (Singleton.singleton a)","decl":"@[simp] lemma ker_pure (a : Œ±) : ker (pure a) = {a} := by rw [‚Üê principal_singleton, ker_principal]\n\n"}
{"name":"Filter.ker_comap","module":"Mathlib.Order.Filter.Ker","initialProofState":"Œ± : Type u_2\nŒ≤ : Type u_3\nm : Œ± ‚Üí Œ≤\nf : Filter Œ≤\n‚ä¢ Eq (Filter.comap m f).ker (Set.preimage m f.ker)","decl":"@[simp] lemma ker_comap (m : Œ± ‚Üí Œ≤) (f : Filter Œ≤) : ker (comap m f) = m ‚Åª¬π' ker f := by\n  ext a\n  simp only [mem_ker, mem_comap, forall_exists_index, and_imp, @forall_swap (Set Œ±), mem_preimage]\n  exact forall‚ÇÇ_congr fun s _ ‚Ü¶ ‚ü®fun h ‚Ü¶ h _ Subset.rfl, fun ha t ht ‚Ü¶ ht ha‚ü©\n\n"}
{"name":"Filter.ker_iSup","module":"Mathlib.Order.Filter.Ker","initialProofState":"Œπ : Sort u_1\nŒ± : Type u_2\nf : Œπ ‚Üí Filter Œ±\n‚ä¢ Eq (iSup fun i => f i).ker (Set.iUnion fun i => (f i).ker)","decl":"@[simp]\ntheorem ker_iSup (f : Œπ ‚Üí Filter Œ±) : ker (‚®Ü i, f i) = ‚ãÉ i, ker (f i) := by\n  refine subset_antisymm (fun x hx ‚Ü¶ ?_) ker_mono.le_map_iSup\n  simp only [mem_iUnion, mem_ker] at hx ‚ä¢\n  contrapose! hx\n  choose s hsf hxs using hx\n  refine ‚ü®‚ãÉ i, s i, ?_, by simpa‚ü©\n  exact mem_iSup.2 fun i ‚Ü¶ mem_of_superset (hsf i) (subset_iUnion s i)\n\n"}
{"name":"Filter.ker_sSup","module":"Mathlib.Order.Filter.Ker","initialProofState":"Œ± : Type u_2\nS : Set (Filter Œ±)\n‚ä¢ Eq (SupSet.sSup S).ker (Set.iUnion fun f => Set.iUnion fun h => f.ker)","decl":"@[simp]\ntheorem ker_sSup (S : Set (Filter Œ±)) : ker (sSup S) = ‚ãÉ f ‚àà S, ker f := by\n  simp [sSup_eq_iSup]\n\n"}
{"name":"Filter.ker_sup","module":"Mathlib.Order.Filter.Ker","initialProofState":"Œ± : Type u_2\nf g : Filter Œ±\n‚ä¢ Eq (Max.max f g).ker (Union.union f.ker g.ker)","decl":"@[simp]\ntheorem ker_sup (f g : Filter Œ±) : ker (f ‚äî g) = ker f ‚à™ ker g := by\n  rw [‚Üê sSup_pair, ker_sSup, biUnion_pair]\n\n"}
