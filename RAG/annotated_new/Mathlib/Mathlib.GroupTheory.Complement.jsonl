{"name":"Subgroup.isComplement'_def","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝ : Group G\nH K : Subgroup G\n⊢ Iff (H.IsComplement' K) (Subgroup.IsComplement ↑H ↑K)","decl":"@[to_additive]\ntheorem isComplement'_def : IsComplement' H K ↔ IsComplement (H : Set G) (K : Set G) :=\n  Iff.rfl\n\n"}
{"name":"AddSubgroup.isComplement'_def","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH K : AddSubgroup G\n⊢ Iff (H.IsComplement' K) (AddSubgroup.IsComplement ↑H ↑K)","decl":"@[to_additive]\ntheorem isComplement'_def : IsComplement' H K ↔ IsComplement (H : Set G) (K : Set G) :=\n  Iff.rfl\n\n"}
{"name":"Subgroup.isComplement_iff_existsUnique","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝ : Group G\nS T : Set G\n⊢ Iff (Subgroup.IsComplement S T) (∀ (g : G), ExistsUnique fun x => Eq (HMul.hMul ↑x.1 ↑x.2) g)","decl":"@[to_additive]\ntheorem isComplement_iff_existsUnique :\n    IsComplement S T ↔ ∀ g : G, ∃! x : S × T, x.1.1 * x.2.1 = g :=\n  Function.bijective_iff_existsUnique _\n\n"}
{"name":"AddSubgroup.isComplement_iff_existsUnique","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nS T : Set G\n⊢ Iff (AddSubgroup.IsComplement S T) (∀ (g : G), ExistsUnique fun x => Eq (HAdd.hAdd ↑x.1 ↑x.2) g)","decl":"@[to_additive]\ntheorem isComplement_iff_existsUnique :\n    IsComplement S T ↔ ∀ g : G, ∃! x : S × T, x.1.1 * x.2.1 = g :=\n  Function.bijective_iff_existsUnique _\n\n"}
{"name":"AddSubgroup.IsComplement.existsUnique","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nS T : Set G\nh : AddSubgroup.IsComplement S T\ng : G\n⊢ ExistsUnique fun x => Eq (HAdd.hAdd ↑x.1 ↑x.2) g","decl":"@[to_additive]\ntheorem IsComplement.existsUnique (h : IsComplement S T) (g : G) :\n    ∃! x : S × T, x.1.1 * x.2.1 = g :=\n  isComplement_iff_existsUnique.mp h g\n\n"}
{"name":"Subgroup.IsComplement.existsUnique","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝ : Group G\nS T : Set G\nh : Subgroup.IsComplement S T\ng : G\n⊢ ExistsUnique fun x => Eq (HMul.hMul ↑x.1 ↑x.2) g","decl":"@[to_additive]\ntheorem IsComplement.existsUnique (h : IsComplement S T) (g : G) :\n    ∃! x : S × T, x.1.1 * x.2.1 = g :=\n  isComplement_iff_existsUnique.mp h g\n\n"}
{"name":"AddSubgroup.IsComplement'.symm","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH K : AddSubgroup G\nh : H.IsComplement' K\n⊢ K.IsComplement' H","decl":"@[to_additive]\ntheorem IsComplement'.symm (h : IsComplement' H K) : IsComplement' K H := by\n  let ϕ : H × K ≃ K × H :=\n    Equiv.mk (fun x => ⟨x.2⁻¹, x.1⁻¹⟩) (fun x => ⟨x.2⁻¹, x.1⁻¹⟩)\n      (fun x => Prod.ext (inv_inv _) (inv_inv _)) fun x => Prod.ext (inv_inv _) (inv_inv _)\n  let ψ : G ≃ G := Equiv.mk (fun g : G => g⁻¹) (fun g : G => g⁻¹) inv_inv inv_inv\n  suffices hf : (ψ ∘ fun x : H × K => x.1.1 * x.2.1) = (fun x : K × H => x.1.1 * x.2.1) ∘ ϕ by\n    rw [isComplement'_def, IsComplement, ← Equiv.bijective_comp ϕ]\n    apply (congr_arg Function.Bijective hf).mp -- Porting note: This was a `rw` in mathlib3\n    rwa [ψ.comp_bijective]\n  exact funext fun x => mul_inv_rev _ _\n\n"}
{"name":"Subgroup.IsComplement'.symm","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝ : Group G\nH K : Subgroup G\nh : H.IsComplement' K\n⊢ K.IsComplement' H","decl":"@[to_additive]\ntheorem IsComplement'.symm (h : IsComplement' H K) : IsComplement' K H := by\n  let ϕ : H × K ≃ K × H :=\n    Equiv.mk (fun x => ⟨x.2⁻¹, x.1⁻¹⟩) (fun x => ⟨x.2⁻¹, x.1⁻¹⟩)\n      (fun x => Prod.ext (inv_inv _) (inv_inv _)) fun x => Prod.ext (inv_inv _) (inv_inv _)\n  let ψ : G ≃ G := Equiv.mk (fun g : G => g⁻¹) (fun g : G => g⁻¹) inv_inv inv_inv\n  suffices hf : (ψ ∘ fun x : H × K => x.1.1 * x.2.1) = (fun x : K × H => x.1.1 * x.2.1) ∘ ϕ by\n    rw [isComplement'_def, IsComplement, ← Equiv.bijective_comp ϕ]\n    apply (congr_arg Function.Bijective hf).mp -- Porting note: This was a `rw` in mathlib3\n    rwa [ψ.comp_bijective]\n  exact funext fun x => mul_inv_rev _ _\n\n"}
{"name":"AddSubgroup.isComplement'_comm","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH K : AddSubgroup G\n⊢ Iff (H.IsComplement' K) (K.IsComplement' H)","decl":"@[to_additive]\ntheorem isComplement'_comm : IsComplement' H K ↔ IsComplement' K H :=\n  ⟨IsComplement'.symm, IsComplement'.symm⟩\n\n"}
{"name":"Subgroup.isComplement'_comm","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝ : Group G\nH K : Subgroup G\n⊢ Iff (H.IsComplement' K) (K.IsComplement' H)","decl":"@[to_additive]\ntheorem isComplement'_comm : IsComplement' H K ↔ IsComplement' K H :=\n  ⟨IsComplement'.symm, IsComplement'.symm⟩\n\n"}
{"name":"AddSubgroup.isComplement_univ_singleton","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\ng : G\n⊢ AddSubgroup.IsComplement Set.univ (Singleton.singleton g)","decl":"@[to_additive]\ntheorem isComplement_univ_singleton {g : G} : IsComplement (univ : Set G) {g} :=\n  ⟨fun ⟨_, _, rfl⟩ ⟨_, _, rfl⟩ h => Prod.ext (Subtype.ext (mul_right_cancel h)) rfl, fun x =>\n    ⟨⟨⟨x * g⁻¹, ⟨⟩⟩, g, rfl⟩, inv_mul_cancel_right x g⟩⟩\n\n"}
{"name":"Subgroup.isComplement_univ_singleton","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝ : Group G\ng : G\n⊢ Subgroup.IsComplement Set.univ (Singleton.singleton g)","decl":"@[to_additive]\ntheorem isComplement_univ_singleton {g : G} : IsComplement (univ : Set G) {g} :=\n  ⟨fun ⟨_, _, rfl⟩ ⟨_, _, rfl⟩ h => Prod.ext (Subtype.ext (mul_right_cancel h)) rfl, fun x =>\n    ⟨⟨⟨x * g⁻¹, ⟨⟩⟩, g, rfl⟩, inv_mul_cancel_right x g⟩⟩\n\n"}
{"name":"Subgroup.isComplement_singleton_univ","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝ : Group G\ng : G\n⊢ Subgroup.IsComplement (Singleton.singleton g) Set.univ","decl":"@[to_additive]\ntheorem isComplement_singleton_univ {g : G} : IsComplement ({g} : Set G) univ :=\n  ⟨fun ⟨⟨_, rfl⟩, _⟩ ⟨⟨_, rfl⟩, _⟩ h => Prod.ext rfl (Subtype.ext (mul_left_cancel h)), fun x =>\n    ⟨⟨⟨g, rfl⟩, g⁻¹ * x, ⟨⟩⟩, mul_inv_cancel_left g x⟩⟩\n\n"}
{"name":"AddSubgroup.isComplement_singleton_univ","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\ng : G\n⊢ AddSubgroup.IsComplement (Singleton.singleton g) Set.univ","decl":"@[to_additive]\ntheorem isComplement_singleton_univ {g : G} : IsComplement ({g} : Set G) univ :=\n  ⟨fun ⟨⟨_, rfl⟩, _⟩ ⟨⟨_, rfl⟩, _⟩ h => Prod.ext rfl (Subtype.ext (mul_left_cancel h)), fun x =>\n    ⟨⟨⟨g, rfl⟩, g⁻¹ * x, ⟨⟩⟩, mul_inv_cancel_left g x⟩⟩\n\n"}
{"name":"AddSubgroup.isComplement_singleton_left","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nS : Set G\ng : G\n⊢ Iff (AddSubgroup.IsComplement (Singleton.singleton g) S) (Eq S Set.univ)","decl":"@[to_additive]\ntheorem isComplement_singleton_left {g : G} : IsComplement {g} S ↔ S = univ := by\n  refine\n    ⟨fun h => top_le_iff.mp fun x _ => ?_, fun h => (congr_arg _ h).mpr isComplement_singleton_univ⟩\n  obtain ⟨⟨⟨z, rfl : z = g⟩, y, _⟩, hy⟩ := h.2 (g * x)\n  rwa [← mul_left_cancel hy]\n\n"}
{"name":"Subgroup.isComplement_singleton_left","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝ : Group G\nS : Set G\ng : G\n⊢ Iff (Subgroup.IsComplement (Singleton.singleton g) S) (Eq S Set.univ)","decl":"@[to_additive]\ntheorem isComplement_singleton_left {g : G} : IsComplement {g} S ↔ S = univ := by\n  refine\n    ⟨fun h => top_le_iff.mp fun x _ => ?_, fun h => (congr_arg _ h).mpr isComplement_singleton_univ⟩\n  obtain ⟨⟨⟨z, rfl : z = g⟩, y, _⟩, hy⟩ := h.2 (g * x)\n  rwa [← mul_left_cancel hy]\n\n"}
{"name":"AddSubgroup.isComplement_singleton_right","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nS : Set G\ng : G\n⊢ Iff (AddSubgroup.IsComplement S (Singleton.singleton g)) (Eq S Set.univ)","decl":"@[to_additive]\ntheorem isComplement_singleton_right {g : G} : IsComplement S {g} ↔ S = univ := by\n  refine\n    ⟨fun h => top_le_iff.mp fun x _ => ?_, fun h => h ▸ isComplement_univ_singleton⟩\n  obtain ⟨y, hy⟩ := h.2 (x * g)\n  conv_rhs at hy => rw [← show y.2.1 = g from y.2.2]\n  rw [← mul_right_cancel hy]\n  exact y.1.2\n\n"}
{"name":"Subgroup.isComplement_singleton_right","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝ : Group G\nS : Set G\ng : G\n⊢ Iff (Subgroup.IsComplement S (Singleton.singleton g)) (Eq S Set.univ)","decl":"@[to_additive]\ntheorem isComplement_singleton_right {g : G} : IsComplement S {g} ↔ S = univ := by\n  refine\n    ⟨fun h => top_le_iff.mp fun x _ => ?_, fun h => h ▸ isComplement_univ_singleton⟩\n  obtain ⟨y, hy⟩ := h.2 (x * g)\n  conv_rhs at hy => rw [← show y.2.1 = g from y.2.2]\n  rw [← mul_right_cancel hy]\n  exact y.1.2\n\n"}
{"name":"AddSubgroup.isComplement_univ_left","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nS : Set G\n⊢ Iff (AddSubgroup.IsComplement Set.univ S) (Exists fun g => Eq S (Singleton.singleton g))","decl":"@[to_additive]\ntheorem isComplement_univ_left : IsComplement univ S ↔ ∃ g : G, S = {g} := by\n  refine\n    ⟨fun h => Set.exists_eq_singleton_iff_nonempty_subsingleton.mpr ⟨?_, fun a ha b hb => ?_⟩, ?_⟩\n  · obtain ⟨a, _⟩ := h.2 1\n    exact ⟨a.2.1, a.2.2⟩\n  · have : (⟨⟨_, mem_top a⁻¹⟩, ⟨a, ha⟩⟩ : (⊤ : Set G) × S) = ⟨⟨_, mem_top b⁻¹⟩, ⟨b, hb⟩⟩ :=\n      h.1 ((inv_mul_cancel a).trans (inv_mul_cancel b).symm)\n    exact Subtype.ext_iff.mp (Prod.ext_iff.mp this).2\n  · rintro ⟨g, rfl⟩\n    exact isComplement_univ_singleton\n\n"}
{"name":"Subgroup.isComplement_univ_left","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝ : Group G\nS : Set G\n⊢ Iff (Subgroup.IsComplement Set.univ S) (Exists fun g => Eq S (Singleton.singleton g))","decl":"@[to_additive]\ntheorem isComplement_univ_left : IsComplement univ S ↔ ∃ g : G, S = {g} := by\n  refine\n    ⟨fun h => Set.exists_eq_singleton_iff_nonempty_subsingleton.mpr ⟨?_, fun a ha b hb => ?_⟩, ?_⟩\n  · obtain ⟨a, _⟩ := h.2 1\n    exact ⟨a.2.1, a.2.2⟩\n  · have : (⟨⟨_, mem_top a⁻¹⟩, ⟨a, ha⟩⟩ : (⊤ : Set G) × S) = ⟨⟨_, mem_top b⁻¹⟩, ⟨b, hb⟩⟩ :=\n      h.1 ((inv_mul_cancel a).trans (inv_mul_cancel b).symm)\n    exact Subtype.ext_iff.mp (Prod.ext_iff.mp this).2\n  · rintro ⟨g, rfl⟩\n    exact isComplement_univ_singleton\n\n"}
{"name":"AddSubgroup.isComplement_univ_right","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nS : Set G\n⊢ Iff (AddSubgroup.IsComplement S Set.univ) (Exists fun g => Eq S (Singleton.singleton g))","decl":"@[to_additive]\ntheorem isComplement_univ_right : IsComplement S univ ↔ ∃ g : G, S = {g} := by\n  refine\n    ⟨fun h => Set.exists_eq_singleton_iff_nonempty_subsingleton.mpr ⟨?_, fun a ha b hb => ?_⟩, ?_⟩\n  · obtain ⟨a, _⟩ := h.2 1\n    exact ⟨a.1.1, a.1.2⟩\n  · have : (⟨⟨a, ha⟩, ⟨_, mem_top a⁻¹⟩⟩ : S × (⊤ : Set G)) = ⟨⟨b, hb⟩, ⟨_, mem_top b⁻¹⟩⟩ :=\n      h.1 ((mul_inv_cancel a).trans (mul_inv_cancel b).symm)\n    exact Subtype.ext_iff.mp (Prod.ext_iff.mp this).1\n  · rintro ⟨g, rfl⟩\n    exact isComplement_singleton_univ\n\n"}
{"name":"Subgroup.isComplement_univ_right","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝ : Group G\nS : Set G\n⊢ Iff (Subgroup.IsComplement S Set.univ) (Exists fun g => Eq S (Singleton.singleton g))","decl":"@[to_additive]\ntheorem isComplement_univ_right : IsComplement S univ ↔ ∃ g : G, S = {g} := by\n  refine\n    ⟨fun h => Set.exists_eq_singleton_iff_nonempty_subsingleton.mpr ⟨?_, fun a ha b hb => ?_⟩, ?_⟩\n  · obtain ⟨a, _⟩ := h.2 1\n    exact ⟨a.1.1, a.1.2⟩\n  · have : (⟨⟨a, ha⟩, ⟨_, mem_top a⁻¹⟩⟩ : S × (⊤ : Set G)) = ⟨⟨b, hb⟩, ⟨_, mem_top b⁻¹⟩⟩ :=\n      h.1 ((mul_inv_cancel a).trans (mul_inv_cancel b).symm)\n    exact Subtype.ext_iff.mp (Prod.ext_iff.mp this).1\n  · rintro ⟨g, rfl⟩\n    exact isComplement_singleton_univ\n\n"}
{"name":"AddSubgroup.IsComplement.add_eq","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nS T : Set G\nh : AddSubgroup.IsComplement S T\n⊢ Eq (HAdd.hAdd S T) Set.univ","decl":"@[to_additive]\nlemma IsComplement.mul_eq (h : IsComplement S T) : S * T = univ :=\n  eq_univ_of_forall fun x ↦ by simpa [mem_mul] using (h.existsUnique x).exists\n\n"}
{"name":"Subgroup.IsComplement.mul_eq","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝ : Group G\nS T : Set G\nh : Subgroup.IsComplement S T\n⊢ Eq (HMul.hMul S T) Set.univ","decl":"@[to_additive]\nlemma IsComplement.mul_eq (h : IsComplement S T) : S * T = univ :=\n  eq_univ_of_forall fun x ↦ by simpa [mem_mul] using (h.existsUnique x).exists\n\n"}
{"name":"AddSubgroup.not_isComplement_empty_left","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nT : Set G\n⊢ Not (AddSubgroup.IsComplement EmptyCollection.emptyCollection T)","decl":"@[to_additive (attr := simp)]\nlemma not_isComplement_empty_left : ¬ IsComplement ∅ T :=\n  fun h ↦ by simpa [eq_comm (a := ∅)] using h.mul_eq\n\n"}
{"name":"Subgroup.not_isComplement_empty_left","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝ : Group G\nT : Set G\n⊢ Not (Subgroup.IsComplement EmptyCollection.emptyCollection T)","decl":"@[to_additive (attr := simp)]\nlemma not_isComplement_empty_left : ¬ IsComplement ∅ T :=\n  fun h ↦ by simpa [eq_comm (a := ∅)] using h.mul_eq\n\n"}
{"name":"Subgroup.not_isComplement_empty_right","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝ : Group G\nS : Set G\n⊢ Not (Subgroup.IsComplement S EmptyCollection.emptyCollection)","decl":"@[to_additive (attr := simp)]\nlemma not_isComplement_empty_right : ¬ IsComplement S ∅ :=\n  fun h ↦ by simpa [eq_comm (a := ∅)] using h.mul_eq\n\n"}
{"name":"AddSubgroup.not_isComplement_empty_right","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nS : Set G\n⊢ Not (AddSubgroup.IsComplement S EmptyCollection.emptyCollection)","decl":"@[to_additive (attr := simp)]\nlemma not_isComplement_empty_right : ¬ IsComplement S ∅ :=\n  fun h ↦ by simpa [eq_comm (a := ∅)] using h.mul_eq\n\n"}
{"name":"Subgroup.IsComplement.nonempty_left","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝ : Group G\nS T : Set G\nhst : Subgroup.IsComplement S T\n⊢ S.Nonempty","decl":"@[to_additive]\nlemma IsComplement.nonempty_left (hst : IsComplement S T) : S.Nonempty := by\n  contrapose! hst; simp [hst]\n\n"}
{"name":"AddSubgroup.IsComplement.nonempty_left","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nS T : Set G\nhst : AddSubgroup.IsComplement S T\n⊢ S.Nonempty","decl":"@[to_additive]\nlemma IsComplement.nonempty_left (hst : IsComplement S T) : S.Nonempty := by\n  contrapose! hst; simp [hst]\n\n"}
{"name":"AddSubgroup.IsComplement.nonempty_right","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nS T : Set G\nhst : AddSubgroup.IsComplement S T\n⊢ T.Nonempty","decl":"@[to_additive]\nlemma IsComplement.nonempty_right (hst : IsComplement S T) : T.Nonempty := by\n  contrapose! hst; simp [hst]\n\n"}
{"name":"Subgroup.IsComplement.nonempty_right","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝ : Group G\nS T : Set G\nhst : Subgroup.IsComplement S T\n⊢ T.Nonempty","decl":"@[to_additive]\nlemma IsComplement.nonempty_right (hst : IsComplement S T) : T.Nonempty := by\n  contrapose! hst; simp [hst]\n\n"}
{"name":"Subgroup.IsComplement.pairwiseDisjoint_smul","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝ : Group G\nS T : Set G\nhst : Subgroup.IsComplement S T\n⊢ S.PairwiseDisjoint fun x => HSMul.hSMul x T","decl":"@[to_additive] lemma IsComplement.pairwiseDisjoint_smul (hst : IsComplement S T) :\n    S.PairwiseDisjoint (· • T) := fun a ha b hb hab ↦ disjoint_iff_forall_ne.2 <| by\n  rintro _ ⟨c, hc, rfl⟩ _ ⟨d, hd, rfl⟩\n  exact hst.1.ne (a₁ := (⟨a, ha⟩, ⟨c, hc⟩)) (a₂:= (⟨b, hb⟩, ⟨d, hd⟩)) (by simp [hab])\n\n"}
{"name":"AddSubgroup.IsComplement.pairwiseDisjoint_vadd","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nS T : Set G\nhst : AddSubgroup.IsComplement S T\n⊢ S.PairwiseDisjoint fun x => HVAdd.hVAdd x T","decl":"@[to_additive] lemma IsComplement.pairwiseDisjoint_smul (hst : IsComplement S T) :\n    S.PairwiseDisjoint (· • T) := fun a ha b hb hab ↦ disjoint_iff_forall_ne.2 <| by\n  rintro _ ⟨c, hc, rfl⟩ _ ⟨d, hd, rfl⟩\n  exact hst.1.ne (a₁ := (⟨a, ha⟩, ⟨c, hc⟩)) (a₂:= (⟨b, hb⟩, ⟨d, hd⟩)) (by simp [hab])\n\n"}
{"name":"Subgroup.IsComplement.card_mul_card","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝ : Group G\nS T : Set G\nh : Subgroup.IsComplement S T\n⊢ Eq (HMul.hMul (Nat.card ↑S) (Nat.card ↑T)) (Nat.card G)","decl":"@[to_additive AddSubgroup.IsComplement.card_mul_card]\nlemma IsComplement.card_mul_card (h : IsComplement S T) : Nat.card S * Nat.card T = Nat.card G :=\n  (Nat.card_prod _ _).symm.trans <| Nat.card_congr <| Equiv.ofBijective _ h\n\n"}
{"name":"AddSubgroup.IsComplement.card_mul_card","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nS T : Set G\nh : AddSubgroup.IsComplement S T\n⊢ Eq (HMul.hMul (Nat.card ↑S) (Nat.card ↑T)) (Nat.card G)","decl":"@[to_additive AddSubgroup.IsComplement.card_mul_card]\nlemma IsComplement.card_mul_card (h : IsComplement S T) : Nat.card S * Nat.card T = Nat.card G :=\n  (Nat.card_prod _ _).symm.trans <| Nat.card_congr <| Equiv.ofBijective _ h\n\n"}
{"name":"AddSubgroup.isComplement'_top_bot","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\n⊢ Top.top.IsComplement' Bot.bot","decl":"@[to_additive]\ntheorem isComplement'_top_bot : IsComplement' (⊤ : Subgroup G) ⊥ :=\n  isComplement_univ_singleton\n\n"}
{"name":"Subgroup.isComplement'_top_bot","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝ : Group G\n⊢ Top.top.IsComplement' Bot.bot","decl":"@[to_additive]\ntheorem isComplement'_top_bot : IsComplement' (⊤ : Subgroup G) ⊥ :=\n  isComplement_univ_singleton\n\n"}
{"name":"Subgroup.isComplement'_bot_top","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝ : Group G\n⊢ Bot.bot.IsComplement' Top.top","decl":"@[to_additive]\ntheorem isComplement'_bot_top : IsComplement' (⊥ : Subgroup G) ⊤ :=\n  isComplement_singleton_univ\n\n"}
{"name":"AddSubgroup.isComplement'_bot_top","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\n⊢ Bot.bot.IsComplement' Top.top","decl":"@[to_additive]\ntheorem isComplement'_bot_top : IsComplement' (⊥ : Subgroup G) ⊤ :=\n  isComplement_singleton_univ\n\n"}
{"name":"AddSubgroup.isComplement'_bot_left","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH : AddSubgroup G\n⊢ Iff (Bot.bot.IsComplement' H) (Eq H Top.top)","decl":"@[to_additive (attr := simp)]\ntheorem isComplement'_bot_left : IsComplement' ⊥ H ↔ H = ⊤ :=\n  isComplement_singleton_left.trans coe_eq_univ\n\n"}
{"name":"Subgroup.isComplement'_bot_left","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝ : Group G\nH : Subgroup G\n⊢ Iff (Bot.bot.IsComplement' H) (Eq H Top.top)","decl":"@[to_additive (attr := simp)]\ntheorem isComplement'_bot_left : IsComplement' ⊥ H ↔ H = ⊤ :=\n  isComplement_singleton_left.trans coe_eq_univ\n\n"}
{"name":"Subgroup.isComplement'_bot_right","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝ : Group G\nH : Subgroup G\n⊢ Iff (H.IsComplement' Bot.bot) (Eq H Top.top)","decl":"@[to_additive (attr := simp)]\ntheorem isComplement'_bot_right : IsComplement' H ⊥ ↔ H = ⊤ :=\n  isComplement_singleton_right.trans coe_eq_univ\n\n"}
{"name":"AddSubgroup.isComplement'_bot_right","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH : AddSubgroup G\n⊢ Iff (H.IsComplement' Bot.bot) (Eq H Top.top)","decl":"@[to_additive (attr := simp)]\ntheorem isComplement'_bot_right : IsComplement' H ⊥ ↔ H = ⊤ :=\n  isComplement_singleton_right.trans coe_eq_univ\n\n"}
{"name":"AddSubgroup.isComplement'_top_left","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH : AddSubgroup G\n⊢ Iff (Top.top.IsComplement' H) (Eq H Bot.bot)","decl":"@[to_additive (attr := simp)]\ntheorem isComplement'_top_left : IsComplement' ⊤ H ↔ H = ⊥ :=\n  isComplement_univ_left.trans coe_eq_singleton\n\n"}
{"name":"Subgroup.isComplement'_top_left","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝ : Group G\nH : Subgroup G\n⊢ Iff (Top.top.IsComplement' H) (Eq H Bot.bot)","decl":"@[to_additive (attr := simp)]\ntheorem isComplement'_top_left : IsComplement' ⊤ H ↔ H = ⊥ :=\n  isComplement_univ_left.trans coe_eq_singleton\n\n"}
{"name":"Subgroup.isComplement'_top_right","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝ : Group G\nH : Subgroup G\n⊢ Iff (H.IsComplement' Top.top) (Eq H Bot.bot)","decl":"@[to_additive (attr := simp)]\ntheorem isComplement'_top_right : IsComplement' H ⊤ ↔ H = ⊥ :=\n  isComplement_univ_right.trans coe_eq_singleton\n\n"}
{"name":"AddSubgroup.isComplement'_top_right","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH : AddSubgroup G\n⊢ Iff (H.IsComplement' Top.top) (Eq H Bot.bot)","decl":"@[to_additive (attr := simp)]\ntheorem isComplement'_top_right : IsComplement' H ⊤ ↔ H = ⊥ :=\n  isComplement_univ_right.trans coe_eq_singleton\n\n"}
{"name":"AddSubgroup.isComplement_iff_existsUnique_neg_add_mem","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nS T : Set G\n⊢ Iff (AddSubgroup.IsComplement S T) (∀ (g : G), ExistsUnique fun s => Membership.mem T (HAdd.hAdd (Neg.neg ↑s) g))","decl":"@[to_additive]\nlemma isComplement_iff_existsUnique_inv_mul_mem :\n    IsComplement S T ↔ ∀ g, ∃! s : S, (s : G)⁻¹ * g ∈ T := by\n  convert isComplement_iff_existsUnique with g\n  constructor <;> rintro ⟨x, hx, hx'⟩\n  · exact ⟨(x, ⟨_, hx⟩), by simp, by aesop⟩\n  · exact ⟨x.1, by simp [← hx], fun y hy ↦ (Prod.ext_iff.1 <| by simpa using hx' (y, ⟨_, hy⟩)).1⟩\n\n"}
{"name":"Subgroup.isComplement_iff_existsUnique_inv_mul_mem","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝ : Group G\nS T : Set G\n⊢ Iff (Subgroup.IsComplement S T) (∀ (g : G), ExistsUnique fun s => Membership.mem T (HMul.hMul (Inv.inv ↑s) g))","decl":"@[to_additive]\nlemma isComplement_iff_existsUnique_inv_mul_mem :\n    IsComplement S T ↔ ∀ g, ∃! s : S, (s : G)⁻¹ * g ∈ T := by\n  convert isComplement_iff_existsUnique with g\n  constructor <;> rintro ⟨x, hx, hx'⟩\n  · exact ⟨(x, ⟨_, hx⟩), by simp, by aesop⟩\n  · exact ⟨x.1, by simp [← hx], fun y hy ↦ (Prod.ext_iff.1 <| by simpa using hx' (y, ⟨_, hy⟩)).1⟩\n\n"}
{"name":"AddSubgroup.mem_leftTransversals_iff_existsUnique_neg_add_mem","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nS T : Set G\n⊢ Iff (Membership.mem (AddSubgroup.leftTransversals T) S) (∀ (g : G), ExistsUnique fun s => Membership.mem T (HAdd.hAdd (Neg.neg ↑s) g))","decl":"set_option linter.deprecated false in\n@[to_additive\n  (attr := deprecated isComplement_iff_existsUnique_inv_mul_mem (since := \"2024-12-18\"))]\ntheorem mem_leftTransversals_iff_existsUnique_inv_mul_mem :\n    S ∈ leftTransversals T ↔ ∀ g : G, ∃! s : S, (s : G)⁻¹ * g ∈ T := by\n  rw [leftTransversals, Set.mem_setOf_eq, isComplement_iff_existsUnique]\n  refine ⟨fun h g => ?_, fun h g => ?_⟩\n  · obtain ⟨x, h1, h2⟩ := h g\n    exact\n      ⟨x.1, (congr_arg (· ∈ T) (eq_inv_mul_of_mul_eq h1)).mp x.2.2, fun y hy =>\n        (Prod.ext_iff.mp (h2 ⟨y, (↑y)⁻¹ * g, hy⟩ (mul_inv_cancel_left ↑y g))).1⟩\n  · obtain ⟨x, h1, h2⟩ := h g\n    refine ⟨⟨x, (↑x)⁻¹ * g, h1⟩, mul_inv_cancel_left (↑x) g, fun y hy => ?_⟩\n    have hf := h2 y.1 ((congr_arg (· ∈ T) (eq_inv_mul_of_mul_eq hy)).mp y.2.2)\n    exact Prod.ext hf (Subtype.ext (eq_inv_mul_of_mul_eq (hf ▸ hy)))\n\n"}
{"name":"Subgroup.mem_leftTransversals_iff_existsUnique_inv_mul_mem","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝ : Group G\nS T : Set G\n⊢ Iff (Membership.mem (Subgroup.leftTransversals T) S) (∀ (g : G), ExistsUnique fun s => Membership.mem T (HMul.hMul (Inv.inv ↑s) g))","decl":"set_option linter.deprecated false in\n@[to_additive\n  (attr := deprecated isComplement_iff_existsUnique_inv_mul_mem (since := \"2024-12-18\"))]\ntheorem mem_leftTransversals_iff_existsUnique_inv_mul_mem :\n    S ∈ leftTransversals T ↔ ∀ g : G, ∃! s : S, (s : G)⁻¹ * g ∈ T := by\n  rw [leftTransversals, Set.mem_setOf_eq, isComplement_iff_existsUnique]\n  refine ⟨fun h g => ?_, fun h g => ?_⟩\n  · obtain ⟨x, h1, h2⟩ := h g\n    exact\n      ⟨x.1, (congr_arg (· ∈ T) (eq_inv_mul_of_mul_eq h1)).mp x.2.2, fun y hy =>\n        (Prod.ext_iff.mp (h2 ⟨y, (↑y)⁻¹ * g, hy⟩ (mul_inv_cancel_left ↑y g))).1⟩\n  · obtain ⟨x, h1, h2⟩ := h g\n    refine ⟨⟨x, (↑x)⁻¹ * g, h1⟩, mul_inv_cancel_left (↑x) g, fun y hy => ?_⟩\n    have hf := h2 y.1 ((congr_arg (· ∈ T) (eq_inv_mul_of_mul_eq hy)).mp y.2.2)\n    exact Prod.ext hf (Subtype.ext (eq_inv_mul_of_mul_eq (hf ▸ hy)))\n\n"}
{"name":"Subgroup.isComplement_iff_existsUnique_mul_inv_mem","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝ : Group G\nS T : Set G\n⊢ Iff (Subgroup.IsComplement S T) (∀ (g : G), ExistsUnique fun t => Membership.mem S (HMul.hMul g (Inv.inv ↑t)))","decl":"@[to_additive]\nlemma isComplement_iff_existsUnique_mul_inv_mem :\n    IsComplement S T ↔ ∀ g, ∃! t : T, g * (t : G)⁻¹ ∈ S := by\n  convert isComplement_iff_existsUnique with g\n  constructor <;> rintro ⟨x, hx, hx'⟩\n  · exact ⟨(⟨_, hx⟩, x), by simp, by aesop⟩\n  · exact ⟨x.2, by simp [← hx], fun y hy ↦ (Prod.ext_iff.1 <| by simpa using hx' (⟨_, hy⟩, y)).2⟩\n\n"}
{"name":"AddSubgroup.isComplement_iff_existsUnique_add_neg_mem","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nS T : Set G\n⊢ Iff (AddSubgroup.IsComplement S T) (∀ (g : G), ExistsUnique fun t => Membership.mem S (HAdd.hAdd g (Neg.neg ↑t)))","decl":"@[to_additive]\nlemma isComplement_iff_existsUnique_mul_inv_mem :\n    IsComplement S T ↔ ∀ g, ∃! t : T, g * (t : G)⁻¹ ∈ S := by\n  convert isComplement_iff_existsUnique with g\n  constructor <;> rintro ⟨x, hx, hx'⟩\n  · exact ⟨(⟨_, hx⟩, x), by simp, by aesop⟩\n  · exact ⟨x.2, by simp [← hx], fun y hy ↦ (Prod.ext_iff.1 <| by simpa using hx' (⟨_, hy⟩, y)).2⟩\n\n"}
{"name":"AddSubgroup.mem_rightTransversals_iff_existsUnique_add_neg_mem","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nS T : Set G\n⊢ Iff (Membership.mem (AddSubgroup.rightTransversals T) S) (∀ (g : G), ExistsUnique fun s => Membership.mem T (HAdd.hAdd g (Neg.neg ↑s)))","decl":"set_option linter.deprecated false in\n@[to_additive\n  (attr := deprecated isComplement_iff_existsUnique_mul_inv_mem (since := \"2024-12-18\"))]\ntheorem mem_rightTransversals_iff_existsUnique_mul_inv_mem :\n    S ∈ rightTransversals T ↔ ∀ g : G, ∃! s : S, g * (s : G)⁻¹ ∈ T := by\n  rw [rightTransversals, Set.mem_setOf_eq, isComplement_iff_existsUnique]\n  refine ⟨fun h g => ?_, fun h g => ?_⟩\n  · obtain ⟨x, h1, h2⟩ := h g\n    exact\n      ⟨x.2, (congr_arg (· ∈ T) (eq_mul_inv_of_mul_eq h1)).mp x.1.2, fun y hy =>\n        (Prod.ext_iff.mp (h2 ⟨⟨g * (↑y)⁻¹, hy⟩, y⟩ (inv_mul_cancel_right g y))).2⟩\n  · obtain ⟨x, h1, h2⟩ := h g\n    refine ⟨⟨⟨g * (↑x)⁻¹, h1⟩, x⟩, inv_mul_cancel_right g x, fun y hy => ?_⟩\n    have hf := h2 y.2 ((congr_arg (· ∈ T) (eq_mul_inv_of_mul_eq hy)).mp y.1.2)\n    exact Prod.ext (Subtype.ext (eq_mul_inv_of_mul_eq (hf ▸ hy))) hf\n\n"}
{"name":"Subgroup.mem_rightTransversals_iff_existsUnique_mul_inv_mem","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝ : Group G\nS T : Set G\n⊢ Iff (Membership.mem (Subgroup.rightTransversals T) S) (∀ (g : G), ExistsUnique fun s => Membership.mem T (HMul.hMul g (Inv.inv ↑s)))","decl":"set_option linter.deprecated false in\n@[to_additive\n  (attr := deprecated isComplement_iff_existsUnique_mul_inv_mem (since := \"2024-12-18\"))]\ntheorem mem_rightTransversals_iff_existsUnique_mul_inv_mem :\n    S ∈ rightTransversals T ↔ ∀ g : G, ∃! s : S, g * (s : G)⁻¹ ∈ T := by\n  rw [rightTransversals, Set.mem_setOf_eq, isComplement_iff_existsUnique]\n  refine ⟨fun h g => ?_, fun h g => ?_⟩\n  · obtain ⟨x, h1, h2⟩ := h g\n    exact\n      ⟨x.2, (congr_arg (· ∈ T) (eq_mul_inv_of_mul_eq h1)).mp x.1.2, fun y hy =>\n        (Prod.ext_iff.mp (h2 ⟨⟨g * (↑y)⁻¹, hy⟩, y⟩ (inv_mul_cancel_right g y))).2⟩\n  · obtain ⟨x, h1, h2⟩ := h g\n    refine ⟨⟨⟨g * (↑x)⁻¹, h1⟩, x⟩, inv_mul_cancel_right g x, fun y hy => ?_⟩\n    have hf := h2 y.2 ((congr_arg (· ∈ T) (eq_mul_inv_of_mul_eq hy)).mp y.1.2)\n    exact Prod.ext (Subtype.ext (eq_mul_inv_of_mul_eq (hf ▸ hy))) hf\n\n"}
{"name":"Subgroup.isComplement_subgroup_right_iff_existsUnique_quotientGroupMk","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝ : Group G\nH : Subgroup G\nS : Set G\n⊢ Iff (Subgroup.IsComplement S ↑H) (∀ (q : HasQuotient.Quotient G H), ExistsUnique fun s => Eq (↑↑s) q)","decl":"@[to_additive]\nlemma isComplement_subgroup_right_iff_existsUnique_quotientGroupMk :\n    IsComplement S H ↔ ∀ q : G ⧸ H, ∃! s : S, QuotientGroup.mk s.1 = q := by\n  simp_rw [isComplement_iff_existsUnique_inv_mul_mem, SetLike.mem_coe, ← QuotientGroup.eq,\n    QuotientGroup.forall_mk]\n\n"}
{"name":"AddSubgroup.isComplement_addSubgroup_right_iff_existsUnique_quotientAddGroupMk","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH : AddSubgroup G\nS : Set G\n⊢ Iff (AddSubgroup.IsComplement S ↑H) (∀ (q : HasQuotient.Quotient G H), ExistsUnique fun s => Eq (↑↑s) q)","decl":"@[to_additive]\nlemma isComplement_subgroup_right_iff_existsUnique_quotientGroupMk :\n    IsComplement S H ↔ ∀ q : G ⧸ H, ∃! s : S, QuotientGroup.mk s.1 = q := by\n  simp_rw [isComplement_iff_existsUnique_inv_mul_mem, SetLike.mem_coe, ← QuotientGroup.eq,\n    QuotientGroup.forall_mk]\n\n"}
{"name":"AddSubgroup.mem_leftTransversals_iff_existsUnique_quotient_mk''_eq","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH : AddSubgroup G\nS : Set G\n⊢ Iff (Membership.mem (AddSubgroup.leftTransversals ↑H) S) (∀ (q : Quotient (QuotientAddGroup.leftRel H)), ExistsUnique fun s => Eq (Quotient.mk'' ↑s) q)","decl":"set_option linter.deprecated false in\n@[to_additive\n  (attr := deprecated isComplement_subgroup_right_iff_existsUnique_quotientGroupMk\n    (since := \"2024-12-18\"))]\ntheorem mem_leftTransversals_iff_existsUnique_quotient_mk''_eq :\n    S ∈ leftTransversals (H : Set G) ↔\n      ∀ q : Quotient (QuotientGroup.leftRel H), ∃! s : S, Quotient.mk'' s.1 = q := by\n  simp_rw [mem_leftTransversals_iff_existsUnique_inv_mul_mem, SetLike.mem_coe, ←\n    QuotientGroup.eq]\n  exact ⟨fun h q => Quotient.inductionOn' q h, fun h g => h (Quotient.mk'' g)⟩\n\n"}
{"name":"Subgroup.mem_leftTransversals_iff_existsUnique_quotient_mk''_eq","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝ : Group G\nH : Subgroup G\nS : Set G\n⊢ Iff (Membership.mem (Subgroup.leftTransversals ↑H) S) (∀ (q : Quotient (QuotientGroup.leftRel H)), ExistsUnique fun s => Eq (Quotient.mk'' ↑s) q)","decl":"set_option linter.deprecated false in\n@[to_additive\n  (attr := deprecated isComplement_subgroup_right_iff_existsUnique_quotientGroupMk\n    (since := \"2024-12-18\"))]\ntheorem mem_leftTransversals_iff_existsUnique_quotient_mk''_eq :\n    S ∈ leftTransversals (H : Set G) ↔\n      ∀ q : Quotient (QuotientGroup.leftRel H), ∃! s : S, Quotient.mk'' s.1 = q := by\n  simp_rw [mem_leftTransversals_iff_existsUnique_inv_mul_mem, SetLike.mem_coe, ←\n    QuotientGroup.eq]\n  exact ⟨fun h q => Quotient.inductionOn' q h, fun h g => h (Quotient.mk'' g)⟩\n\n"}
{"name":"AddSubgroup.isComplement_addSubgroup_left_iff_existsUnique_quotientMk''","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH : AddSubgroup G\nT : Set G\n⊢ Iff (AddSubgroup.IsComplement (↑H) T) (∀ (q : Quotient (QuotientAddGroup.rightRel H)), ExistsUnique fun t => Eq (Quotient.mk'' ↑t) q)","decl":"set_option linter.docPrime false in\n@[to_additive]\nlemma isComplement_subgroup_left_iff_existsUnique_quotientMk'' :\n    IsComplement H T ↔\n      ∀ q : Quotient (QuotientGroup.rightRel H), ∃! t : T, Quotient.mk'' t.1 = q := by\n  simp_rw [isComplement_iff_existsUnique_mul_inv_mem, SetLike.mem_coe,\n    ← QuotientGroup.rightRel_apply, ← Quotient.eq'', Quotient.forall]\n\n"}
{"name":"Subgroup.isComplement_subgroup_left_iff_existsUnique_quotientMk''","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝ : Group G\nH : Subgroup G\nT : Set G\n⊢ Iff (Subgroup.IsComplement (↑H) T) (∀ (q : Quotient (QuotientGroup.rightRel H)), ExistsUnique fun t => Eq (Quotient.mk'' ↑t) q)","decl":"set_option linter.docPrime false in\n@[to_additive]\nlemma isComplement_subgroup_left_iff_existsUnique_quotientMk'' :\n    IsComplement H T ↔\n      ∀ q : Quotient (QuotientGroup.rightRel H), ∃! t : T, Quotient.mk'' t.1 = q := by\n  simp_rw [isComplement_iff_existsUnique_mul_inv_mem, SetLike.mem_coe,\n    ← QuotientGroup.rightRel_apply, ← Quotient.eq'', Quotient.forall]\n\n"}
{"name":"Subgroup.mem_rightTransversals_iff_existsUnique_quotient_mk''_eq","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝ : Group G\nH : Subgroup G\nS : Set G\n⊢ Iff (Membership.mem (Subgroup.rightTransversals ↑H) S) (∀ (q : Quotient (QuotientGroup.rightRel H)), ExistsUnique fun s => Eq (Quotient.mk'' ↑s) q)","decl":"set_option linter.deprecated false in\n@[to_additive\n  (attr := deprecated isComplement_subgroup_left_iff_existsUnique_quotientMk''\n    (since := \"2024-12-18\"))]\ntheorem mem_rightTransversals_iff_existsUnique_quotient_mk''_eq :\n    S ∈ rightTransversals (H : Set G) ↔\n      ∀ q : Quotient (QuotientGroup.rightRel H), ∃! s : S, Quotient.mk'' s.1 = q := by\n  simp_rw [mem_rightTransversals_iff_existsUnique_mul_inv_mem, SetLike.mem_coe, ←\n    QuotientGroup.rightRel_apply, ← Quotient.eq'']\n  exact ⟨fun h q => Quotient.inductionOn' q h, fun h g => h (Quotient.mk'' g)⟩\n\n"}
{"name":"AddSubgroup.mem_rightTransversals_iff_existsUnique_quotient_mk''_eq","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH : AddSubgroup G\nS : Set G\n⊢ Iff (Membership.mem (AddSubgroup.rightTransversals ↑H) S) (∀ (q : Quotient (QuotientAddGroup.rightRel H)), ExistsUnique fun s => Eq (Quotient.mk'' ↑s) q)","decl":"set_option linter.deprecated false in\n@[to_additive\n  (attr := deprecated isComplement_subgroup_left_iff_existsUnique_quotientMk''\n    (since := \"2024-12-18\"))]\ntheorem mem_rightTransversals_iff_existsUnique_quotient_mk''_eq :\n    S ∈ rightTransversals (H : Set G) ↔\n      ∀ q : Quotient (QuotientGroup.rightRel H), ∃! s : S, Quotient.mk'' s.1 = q := by\n  simp_rw [mem_rightTransversals_iff_existsUnique_mul_inv_mem, SetLike.mem_coe, ←\n    QuotientGroup.rightRel_apply, ← Quotient.eq'']\n  exact ⟨fun h q => Quotient.inductionOn' q h, fun h g => h (Quotient.mk'' g)⟩\n\n"}
{"name":"Subgroup.isComplement_subgroup_right_iff_bijective","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝ : Group G\nH : Subgroup G\nS : Set G\n⊢ Iff (Subgroup.IsComplement S ↑H) (Function.Bijective (S.restrict QuotientGroup.mk))","decl":"@[to_additive]\nlemma isComplement_subgroup_right_iff_bijective :\n    IsComplement S H ↔ Bijective (S.restrict (QuotientGroup.mk : G → G ⧸ H)) :=\n  isComplement_subgroup_right_iff_existsUnique_quotientGroupMk.trans\n    (bijective_iff_existsUnique (S.restrict QuotientGroup.mk)).symm\n\n"}
{"name":"AddSubgroup.isComplement_addSubgroup_right_iff_bijective","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH : AddSubgroup G\nS : Set G\n⊢ Iff (AddSubgroup.IsComplement S ↑H) (Function.Bijective (S.restrict QuotientAddGroup.mk))","decl":"@[to_additive]\nlemma isComplement_subgroup_right_iff_bijective :\n    IsComplement S H ↔ Bijective (S.restrict (QuotientGroup.mk : G → G ⧸ H)) :=\n  isComplement_subgroup_right_iff_existsUnique_quotientGroupMk.trans\n    (bijective_iff_existsUnique (S.restrict QuotientGroup.mk)).symm\n\n"}
{"name":"AddSubgroup.mem_leftTransversals_iff_bijective","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH : AddSubgroup G\nS : Set G\n⊢ Iff (Membership.mem (AddSubgroup.leftTransversals ↑H) S) (Function.Bijective (S.restrict Quotient.mk''))","decl":"set_option linter.deprecated false in\n@[to_additive\n  (attr := deprecated isComplement_subgroup_right_iff_bijective (since := \"2024-12-18\"))]\ntheorem mem_leftTransversals_iff_bijective :\n    S ∈ leftTransversals (H : Set G) ↔\n      Function.Bijective (S.restrict (Quotient.mk'' : G → Quotient (QuotientGroup.leftRel H))) :=\n  mem_leftTransversals_iff_existsUnique_quotient_mk''_eq.trans\n    (Function.bijective_iff_existsUnique (S.restrict Quotient.mk'')).symm\n\n"}
{"name":"Subgroup.mem_leftTransversals_iff_bijective","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝ : Group G\nH : Subgroup G\nS : Set G\n⊢ Iff (Membership.mem (Subgroup.leftTransversals ↑H) S) (Function.Bijective (S.restrict Quotient.mk''))","decl":"set_option linter.deprecated false in\n@[to_additive\n  (attr := deprecated isComplement_subgroup_right_iff_bijective (since := \"2024-12-18\"))]\ntheorem mem_leftTransversals_iff_bijective :\n    S ∈ leftTransversals (H : Set G) ↔\n      Function.Bijective (S.restrict (Quotient.mk'' : G → Quotient (QuotientGroup.leftRel H))) :=\n  mem_leftTransversals_iff_existsUnique_quotient_mk''_eq.trans\n    (Function.bijective_iff_existsUnique (S.restrict Quotient.mk'')).symm\n\n"}
{"name":"Subgroup.isComplement_subgroup_left_iff_bijective","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝ : Group G\nH : Subgroup G\nT : Set G\n⊢ Iff (Subgroup.IsComplement (↑H) T) (Function.Bijective (T.restrict Quotient.mk''))","decl":"@[to_additive]\nlemma isComplement_subgroup_left_iff_bijective :\n    IsComplement H T ↔\n      Bijective (T.restrict (Quotient.mk'' : G → Quotient (QuotientGroup.rightRel H))) :=\n  isComplement_subgroup_left_iff_existsUnique_quotientMk''.trans\n    (bijective_iff_existsUnique (T.restrict Quotient.mk'')).symm\n\n"}
{"name":"AddSubgroup.isComplement_addSubgroup_left_iff_bijective","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH : AddSubgroup G\nT : Set G\n⊢ Iff (AddSubgroup.IsComplement (↑H) T) (Function.Bijective (T.restrict Quotient.mk''))","decl":"@[to_additive]\nlemma isComplement_subgroup_left_iff_bijective :\n    IsComplement H T ↔\n      Bijective (T.restrict (Quotient.mk'' : G → Quotient (QuotientGroup.rightRel H))) :=\n  isComplement_subgroup_left_iff_existsUnique_quotientMk''.trans\n    (bijective_iff_existsUnique (T.restrict Quotient.mk'')).symm\n\n"}
{"name":"AddSubgroup.mem_rightTransversals_iff_bijective","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH : AddSubgroup G\nS : Set G\n⊢ Iff (Membership.mem (AddSubgroup.rightTransversals ↑H) S) (Function.Bijective (S.restrict Quotient.mk''))","decl":"set_option linter.deprecated false in\n@[to_additive\n  (attr := deprecated isComplement_subgroup_left_iff_bijective (since := \"2024-12-18\"))]\ntheorem mem_rightTransversals_iff_bijective :\n    S ∈ rightTransversals (H : Set G) ↔\n      Function.Bijective (S.restrict (Quotient.mk'' : G → Quotient (QuotientGroup.rightRel H))) :=\n  mem_rightTransversals_iff_existsUnique_quotient_mk''_eq.trans\n    (Function.bijective_iff_existsUnique (S.restrict Quotient.mk'')).symm\n\n"}
{"name":"Subgroup.mem_rightTransversals_iff_bijective","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝ : Group G\nH : Subgroup G\nS : Set G\n⊢ Iff (Membership.mem (Subgroup.rightTransversals ↑H) S) (Function.Bijective (S.restrict Quotient.mk''))","decl":"set_option linter.deprecated false in\n@[to_additive\n  (attr := deprecated isComplement_subgroup_left_iff_bijective (since := \"2024-12-18\"))]\ntheorem mem_rightTransversals_iff_bijective :\n    S ∈ rightTransversals (H : Set G) ↔\n      Function.Bijective (S.restrict (Quotient.mk'' : G → Quotient (QuotientGroup.rightRel H))) :=\n  mem_rightTransversals_iff_existsUnique_quotient_mk''_eq.trans\n    (Function.bijective_iff_existsUnique (S.restrict Quotient.mk'')).symm\n\n"}
{"name":"AddSubgroup.IsComplement.card_left","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH : AddSubgroup G\nS : Set G\nh : AddSubgroup.IsComplement S ↑H\n⊢ Eq (Nat.card ↑S) H.index","decl":"@[to_additive]\nlemma IsComplement.card_left (h : IsComplement S H) : Nat.card S = H.index :=\n  Nat.card_congr <| .ofBijective _ <| isComplement_subgroup_right_iff_bijective.mp h\n\n"}
{"name":"Subgroup.IsComplement.card_left","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝ : Group G\nH : Subgroup G\nS : Set G\nh : Subgroup.IsComplement S ↑H\n⊢ Eq (Nat.card ↑S) H.index","decl":"@[to_additive]\nlemma IsComplement.card_left (h : IsComplement S H) : Nat.card S = H.index :=\n  Nat.card_congr <| .ofBijective _ <| isComplement_subgroup_right_iff_bijective.mp h\n\n"}
{"name":"Subgroup.card_left_transversal","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝ : Group G\nH : Subgroup G\nS : Set G\nh : Membership.mem (Subgroup.leftTransversals ↑H) S\n⊢ Eq (Nat.card ↑S) H.index","decl":"set_option linter.deprecated false in\n@[to_additive (attr := deprecated IsComplement.card_left (since := \"2024-12-18\"))]\ntheorem card_left_transversal (h : S ∈ leftTransversals (H : Set G)) : Nat.card S = H.index :=\n  Nat.card_congr <| Equiv.ofBijective _ <| mem_leftTransversals_iff_bijective.mp h\n\n"}
{"name":"AddSubgroup.card_left_transversal","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH : AddSubgroup G\nS : Set G\nh : Membership.mem (AddSubgroup.leftTransversals ↑H) S\n⊢ Eq (Nat.card ↑S) H.index","decl":"set_option linter.deprecated false in\n@[to_additive (attr := deprecated IsComplement.card_left (since := \"2024-12-18\"))]\ntheorem card_left_transversal (h : S ∈ leftTransversals (H : Set G)) : Nat.card S = H.index :=\n  Nat.card_congr <| Equiv.ofBijective _ <| mem_leftTransversals_iff_bijective.mp h\n\n"}
{"name":"AddSubgroup.IsComplement.card_right","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH : AddSubgroup G\nT : Set G\nh : AddSubgroup.IsComplement (↑H) T\n⊢ Eq (Nat.card ↑T) H.index","decl":"@[to_additive]\nlemma IsComplement.card_right (h : IsComplement H T) : Nat.card T = H.index :=\n  Nat.card_congr <| (Equiv.ofBijective _ <| isComplement_subgroup_left_iff_bijective.mp h).trans <|\n    QuotientGroup.quotientRightRelEquivQuotientLeftRel H\n\n"}
{"name":"Subgroup.IsComplement.card_right","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝ : Group G\nH : Subgroup G\nT : Set G\nh : Subgroup.IsComplement (↑H) T\n⊢ Eq (Nat.card ↑T) H.index","decl":"@[to_additive]\nlemma IsComplement.card_right (h : IsComplement H T) : Nat.card T = H.index :=\n  Nat.card_congr <| (Equiv.ofBijective _ <| isComplement_subgroup_left_iff_bijective.mp h).trans <|\n    QuotientGroup.quotientRightRelEquivQuotientLeftRel H\n\n"}
{"name":"AddSubgroup.card_right_transversal","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH : AddSubgroup G\nS : Set G\nh : Membership.mem (AddSubgroup.rightTransversals ↑H) S\n⊢ Eq (Nat.card ↑S) H.index","decl":"set_option linter.deprecated false in\n@[to_additive (attr := deprecated IsComplement.card_right (since := \"2024-12-18\"))]\ntheorem card_right_transversal (h : S ∈ rightTransversals (H : Set G)) : Nat.card S = H.index :=\n  Nat.card_congr <|\n    (Equiv.ofBijective _ <| mem_rightTransversals_iff_bijective.mp h).trans <|\n      QuotientGroup.quotientRightRelEquivQuotientLeftRel H\n\n"}
{"name":"Subgroup.card_right_transversal","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝ : Group G\nH : Subgroup G\nS : Set G\nh : Membership.mem (Subgroup.rightTransversals ↑H) S\n⊢ Eq (Nat.card ↑S) H.index","decl":"set_option linter.deprecated false in\n@[to_additive (attr := deprecated IsComplement.card_right (since := \"2024-12-18\"))]\ntheorem card_right_transversal (h : S ∈ rightTransversals (H : Set G)) : Nat.card S = H.index :=\n  Nat.card_congr <|\n    (Equiv.ofBijective _ <| mem_rightTransversals_iff_bijective.mp h).trans <|\n      QuotientGroup.quotientRightRelEquivQuotientLeftRel H\n\n"}
{"name":"AddSubgroup.isComplement_range_left","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH : AddSubgroup G\nf : HasQuotient.Quotient G H → G\nhf : ∀ (q : HasQuotient.Quotient G H), Eq (↑(f q)) q\n⊢ AddSubgroup.IsComplement (Set.range f) ↑H","decl":"@[to_additive]\nlemma isComplement_range_left {f : G ⧸ H → G} (hf : ∀ q, ↑(f q) = q) :\n    IsComplement (range f) H := by\n  rw [isComplement_subgroup_right_iff_bijective]\n  refine ⟨?_, fun q ↦ ⟨⟨f q, q, rfl⟩, hf q⟩⟩\n  rintro ⟨-, q₁, rfl⟩ ⟨-, q₂, rfl⟩ h\n  exact Subtype.ext <| congr_arg f <| ((hf q₁).symm.trans h).trans (hf q₂)\n\n"}
{"name":"Subgroup.isComplement_range_left","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝ : Group G\nH : Subgroup G\nf : HasQuotient.Quotient G H → G\nhf : ∀ (q : HasQuotient.Quotient G H), Eq (↑(f q)) q\n⊢ Subgroup.IsComplement (Set.range f) ↑H","decl":"@[to_additive]\nlemma isComplement_range_left {f : G ⧸ H → G} (hf : ∀ q, ↑(f q) = q) :\n    IsComplement (range f) H := by\n  rw [isComplement_subgroup_right_iff_bijective]\n  refine ⟨?_, fun q ↦ ⟨⟨f q, q, rfl⟩, hf q⟩⟩\n  rintro ⟨-, q₁, rfl⟩ ⟨-, q₂, rfl⟩ h\n  exact Subtype.ext <| congr_arg f <| ((hf q₁).symm.trans h).trans (hf q₂)\n\n"}
{"name":"AddSubgroup.range_mem_leftTransversals","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH : AddSubgroup G\nf : HasQuotient.Quotient G H → G\nhf : ∀ (q : HasQuotient.Quotient G H), Eq (↑(f q)) q\n⊢ Membership.mem (AddSubgroup.leftTransversals ↑H) (Set.range f)","decl":"set_option linter.deprecated false in\n@[to_additive (attr := deprecated isComplement_range_left (since := \"2024-12-18\"))]\ntheorem range_mem_leftTransversals {f : G ⧸ H → G} (hf : ∀ q, ↑(f q) = q) :\n    Set.range f ∈ leftTransversals (H : Set G) :=\n  mem_leftTransversals_iff_bijective.mpr\n    ⟨by rintro ⟨-, q₁, rfl⟩ ⟨-, q₂, rfl⟩ h\n        exact Subtype.ext <| congr_arg f <| ((hf q₁).symm.trans h).trans (hf q₂),\n      fun q => ⟨⟨f q, q, rfl⟩, hf q⟩⟩\n\n"}
{"name":"Subgroup.range_mem_leftTransversals","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝ : Group G\nH : Subgroup G\nf : HasQuotient.Quotient G H → G\nhf : ∀ (q : HasQuotient.Quotient G H), Eq (↑(f q)) q\n⊢ Membership.mem (Subgroup.leftTransversals ↑H) (Set.range f)","decl":"set_option linter.deprecated false in\n@[to_additive (attr := deprecated isComplement_range_left (since := \"2024-12-18\"))]\ntheorem range_mem_leftTransversals {f : G ⧸ H → G} (hf : ∀ q, ↑(f q) = q) :\n    Set.range f ∈ leftTransversals (H : Set G) :=\n  mem_leftTransversals_iff_bijective.mpr\n    ⟨by rintro ⟨-, q₁, rfl⟩ ⟨-, q₂, rfl⟩ h\n        exact Subtype.ext <| congr_arg f <| ((hf q₁).symm.trans h).trans (hf q₂),\n      fun q => ⟨⟨f q, q, rfl⟩, hf q⟩⟩\n\n"}
{"name":"AddSubgroup.isComplement_range_right","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH : AddSubgroup G\nf : Quotient (QuotientAddGroup.rightRel H) → G\nhf : ∀ (q : Quotient (QuotientAddGroup.rightRel H)), Eq (Quotient.mk'' (f q)) q\n⊢ AddSubgroup.IsComplement (↑H) (Set.range f)","decl":"@[to_additive]\nlemma isComplement_range_right {f : Quotient (QuotientGroup.rightRel H) → G}\n    (hf : ∀ q, Quotient.mk'' (f q) = q) : IsComplement H (range f) := by\n  rw [isComplement_subgroup_left_iff_bijective]\n  refine ⟨?_, fun q ↦ ⟨⟨f q, q, rfl⟩, hf q⟩⟩\n  rintro ⟨-, q₁, rfl⟩ ⟨-, q₂, rfl⟩ h\n  exact Subtype.ext <| congr_arg f <| ((hf q₁).symm.trans h).trans (hf q₂)\n\n"}
{"name":"Subgroup.isComplement_range_right","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝ : Group G\nH : Subgroup G\nf : Quotient (QuotientGroup.rightRel H) → G\nhf : ∀ (q : Quotient (QuotientGroup.rightRel H)), Eq (Quotient.mk'' (f q)) q\n⊢ Subgroup.IsComplement (↑H) (Set.range f)","decl":"@[to_additive]\nlemma isComplement_range_right {f : Quotient (QuotientGroup.rightRel H) → G}\n    (hf : ∀ q, Quotient.mk'' (f q) = q) : IsComplement H (range f) := by\n  rw [isComplement_subgroup_left_iff_bijective]\n  refine ⟨?_, fun q ↦ ⟨⟨f q, q, rfl⟩, hf q⟩⟩\n  rintro ⟨-, q₁, rfl⟩ ⟨-, q₂, rfl⟩ h\n  exact Subtype.ext <| congr_arg f <| ((hf q₁).symm.trans h).trans (hf q₂)\n\n"}
{"name":"Subgroup.range_mem_rightTransversals","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝ : Group G\nH : Subgroup G\nf : Quotient (QuotientGroup.rightRel H) → G\nhf : ∀ (q : Quotient (QuotientGroup.rightRel H)), Eq (Quotient.mk'' (f q)) q\n⊢ Membership.mem (Subgroup.rightTransversals ↑H) (Set.range f)","decl":"set_option linter.deprecated false in\n@[to_additive (attr := deprecated isComplement_range_right (since := \"2024-12-18\"))]\ntheorem range_mem_rightTransversals {f : Quotient (QuotientGroup.rightRel H) → G}\n    (hf : ∀ q, Quotient.mk'' (f q) = q) : Set.range f ∈ rightTransversals (H : Set G) :=\n  mem_rightTransversals_iff_bijective.mpr\n    ⟨by rintro ⟨-, q₁, rfl⟩ ⟨-, q₂, rfl⟩ h\n        exact Subtype.ext <| congr_arg f <| ((hf q₁).symm.trans h).trans (hf q₂),\n      fun q => ⟨⟨f q, q, rfl⟩, hf q⟩⟩\n\n"}
{"name":"AddSubgroup.range_mem_rightTransversals","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH : AddSubgroup G\nf : Quotient (QuotientAddGroup.rightRel H) → G\nhf : ∀ (q : Quotient (QuotientAddGroup.rightRel H)), Eq (Quotient.mk'' (f q)) q\n⊢ Membership.mem (AddSubgroup.rightTransversals ↑H) (Set.range f)","decl":"set_option linter.deprecated false in\n@[to_additive (attr := deprecated isComplement_range_right (since := \"2024-12-18\"))]\ntheorem range_mem_rightTransversals {f : Quotient (QuotientGroup.rightRel H) → G}\n    (hf : ∀ q, Quotient.mk'' (f q) = q) : Set.range f ∈ rightTransversals (H : Set G) :=\n  mem_rightTransversals_iff_bijective.mpr\n    ⟨by rintro ⟨-, q₁, rfl⟩ ⟨-, q₂, rfl⟩ h\n        exact Subtype.ext <| congr_arg f <| ((hf q₁).symm.trans h).trans (hf q₂),\n      fun q => ⟨⟨f q, q, rfl⟩, hf q⟩⟩\n\n"}
{"name":"AddSubgroup.exists_isComplement_left","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH : AddSubgroup G\ng : G\n⊢ Exists fun S => And (AddSubgroup.IsComplement S ↑H) (Membership.mem S g)","decl":"@[to_additive]\nlemma exists_isComplement_left (H : Subgroup G) (g : G) : ∃ S, IsComplement S H ∧ g ∈ S := by\n  classical\n  refine ⟨Set.range (Function.update Quotient.out _ g), isComplement_range_left fun q ↦ ?_,\n    QuotientGroup.mk g, Function.update_self (Quotient.mk'' g) g Quotient.out⟩\n  by_cases hq : q = Quotient.mk'' g\n  · exact hq.symm ▸ congr_arg _ (Function.update_self (Quotient.mk'' g) g Quotient.out)\n  · refine Function.update_of_ne ?_ g Quotient.out ▸ q.out_eq'\n    exact hq\n\n"}
{"name":"Subgroup.exists_isComplement_left","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝ : Group G\nH : Subgroup G\ng : G\n⊢ Exists fun S => And (Subgroup.IsComplement S ↑H) (Membership.mem S g)","decl":"@[to_additive]\nlemma exists_isComplement_left (H : Subgroup G) (g : G) : ∃ S, IsComplement S H ∧ g ∈ S := by\n  classical\n  refine ⟨Set.range (Function.update Quotient.out _ g), isComplement_range_left fun q ↦ ?_,\n    QuotientGroup.mk g, Function.update_self (Quotient.mk'' g) g Quotient.out⟩\n  by_cases hq : q = Quotient.mk'' g\n  · exact hq.symm ▸ congr_arg _ (Function.update_self (Quotient.mk'' g) g Quotient.out)\n  · refine Function.update_of_ne ?_ g Quotient.out ▸ q.out_eq'\n    exact hq\n\n"}
{"name":"Subgroup.exists_left_transversal","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝ : Group G\nH : Subgroup G\ng : G\n⊢ Exists fun S => And (Membership.mem (Subgroup.leftTransversals ↑H) S) (Membership.mem S g)","decl":"set_option linter.deprecated false in\n@[to_additive (attr := deprecated exists_isComplement_left (since := \"2024-12-18\"))]\nlemma exists_left_transversal (H : Subgroup G) (g : G) :\n    ∃ S ∈ leftTransversals (H : Set G), g ∈ S := by\n  classical\n    refine\n      ⟨Set.range (Function.update Quotient.out _ g), range_mem_leftTransversals fun q => ?_,\n        Quotient.mk'' g, Function.update_self (Quotient.mk'' g) g Quotient.out⟩\n    by_cases hq : q = Quotient.mk'' g\n    · exact hq.symm ▸ congr_arg _ (Function.update_self (Quotient.mk'' g) g Quotient.out)\n    · refine (Function.update_of_ne ?_ g Quotient.out) ▸ q.out_eq'\n      exact hq\n\n"}
{"name":"AddSubgroup.exists_left_transversal","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH : AddSubgroup G\ng : G\n⊢ Exists fun S => And (Membership.mem (AddSubgroup.leftTransversals ↑H) S) (Membership.mem S g)","decl":"set_option linter.deprecated false in\n@[to_additive (attr := deprecated exists_isComplement_left (since := \"2024-12-18\"))]\nlemma exists_left_transversal (H : Subgroup G) (g : G) :\n    ∃ S ∈ leftTransversals (H : Set G), g ∈ S := by\n  classical\n    refine\n      ⟨Set.range (Function.update Quotient.out _ g), range_mem_leftTransversals fun q => ?_,\n        Quotient.mk'' g, Function.update_self (Quotient.mk'' g) g Quotient.out⟩\n    by_cases hq : q = Quotient.mk'' g\n    · exact hq.symm ▸ congr_arg _ (Function.update_self (Quotient.mk'' g) g Quotient.out)\n    · refine (Function.update_of_ne ?_ g Quotient.out) ▸ q.out_eq'\n      exact hq\n\n"}
{"name":"AddSubgroup.exists_isComplement_right","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH : AddSubgroup G\ng : G\n⊢ Exists fun T => And (AddSubgroup.IsComplement (↑H) T) (Membership.mem T g)","decl":"@[to_additive]\nlemma exists_isComplement_right (H : Subgroup G) (g : G) :\n    ∃ T, IsComplement H T ∧ g ∈ T := by\n  classical\n  refine ⟨Set.range (Function.update Quotient.out _ g), isComplement_range_right fun q ↦ ?_,\n    Quotient.mk'' g, Function.update_self (Quotient.mk'' g) g Quotient.out⟩\n  by_cases hq : q = Quotient.mk'' g\n  · exact hq.symm ▸ congr_arg _ (Function.update_self (Quotient.mk'' g) g Quotient.out)\n  · refine Function.update_of_ne ?_ g Quotient.out ▸ q.out_eq'\n    exact hq\n\n"}
{"name":"Subgroup.exists_isComplement_right","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝ : Group G\nH : Subgroup G\ng : G\n⊢ Exists fun T => And (Subgroup.IsComplement (↑H) T) (Membership.mem T g)","decl":"@[to_additive]\nlemma exists_isComplement_right (H : Subgroup G) (g : G) :\n    ∃ T, IsComplement H T ∧ g ∈ T := by\n  classical\n  refine ⟨Set.range (Function.update Quotient.out _ g), isComplement_range_right fun q ↦ ?_,\n    Quotient.mk'' g, Function.update_self (Quotient.mk'' g) g Quotient.out⟩\n  by_cases hq : q = Quotient.mk'' g\n  · exact hq.symm ▸ congr_arg _ (Function.update_self (Quotient.mk'' g) g Quotient.out)\n  · refine Function.update_of_ne ?_ g Quotient.out ▸ q.out_eq'\n    exact hq\n\n"}
{"name":"Subgroup.exists_right_transversal","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝ : Group G\nH : Subgroup G\ng : G\n⊢ Exists fun S => And (Membership.mem (Subgroup.rightTransversals ↑H) S) (Membership.mem S g)","decl":"set_option linter.deprecated false in\n@[to_additive (attr := deprecated exists_isComplement_right (since := \"2024-12-18\"))]\nlemma exists_right_transversal (H : Subgroup G) (g : G) :\n    ∃ S ∈ rightTransversals (H : Set G), g ∈ S := by\n  classical\n    refine\n      ⟨Set.range (Function.update Quotient.out _ g), range_mem_rightTransversals fun q => ?_,\n        Quotient.mk'' g, Function.update_self (Quotient.mk'' g) g Quotient.out⟩\n    by_cases hq : q = Quotient.mk'' g\n    · exact hq.symm ▸ congr_arg _ (Function.update_self (Quotient.mk'' g) g Quotient.out)\n    · exact Eq.trans (congr_arg _ (Function.update_of_ne hq g Quotient.out)) q.out_eq'\n\n"}
{"name":"AddSubgroup.exists_right_transversal","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH : AddSubgroup G\ng : G\n⊢ Exists fun S => And (Membership.mem (AddSubgroup.rightTransversals ↑H) S) (Membership.mem S g)","decl":"set_option linter.deprecated false in\n@[to_additive (attr := deprecated exists_isComplement_right (since := \"2024-12-18\"))]\nlemma exists_right_transversal (H : Subgroup G) (g : G) :\n    ∃ S ∈ rightTransversals (H : Set G), g ∈ S := by\n  classical\n    refine\n      ⟨Set.range (Function.update Quotient.out _ g), range_mem_rightTransversals fun q => ?_,\n        Quotient.mk'' g, Function.update_self (Quotient.mk'' g) g Quotient.out⟩\n    by_cases hq : q = Quotient.mk'' g\n    · exact hq.symm ▸ congr_arg _ (Function.update_self (Quotient.mk'' g) g Quotient.out)\n    · exact Eq.trans (congr_arg _ (Function.update_of_ne hq g Quotient.out)) q.out_eq'\n\n"}
{"name":"Subgroup.exists_left_transversal_of_le","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝ : Group G\nH' H : Subgroup G\nh : LE.le H' H\n⊢ Exists fun S => And (Eq (HMul.hMul S ↑H') ↑H) (Eq (HMul.hMul (Nat.card ↑S) (Nat.card (Subtype fun x => Membership.mem H' x))) (Nat.card (Subtype fun x => Membership.mem H x)))","decl":"/-- Given two subgroups `H' ⊆ H`, there exists a left transversal to `H'` inside `H`. -/\n@[to_additive \"Given two subgroups `H' ⊆ H`, there exists a transversal to `H'` inside `H`\"]\nlemma exists_left_transversal_of_le {H' H : Subgroup G} (h : H' ≤ H) :\n    ∃ S : Set G, S * H' = H ∧ Nat.card S * Nat.card H' = Nat.card H := by\n  let H'' : Subgroup H := H'.comap H.subtype\n  have : H' = H''.map H.subtype := by simp [H'', h]\n  rw [this]\n  obtain ⟨S, cmem, -⟩ := H''.exists_isComplement_left 1\n  refine ⟨H.subtype '' S, ?_, ?_⟩\n  · have : H.subtype '' (S * H'') = H.subtype '' S * H''.map H.subtype := image_mul H.subtype\n    rw [← this, cmem.mul_eq]\n    simp [Set.ext_iff]\n  · rw [← cmem.card_mul_card]\n    refine congr_arg₂ (· * ·) ?_ ?_ <;>\n      exact Nat.card_congr (Equiv.Set.image _ _ <| subtype_injective H).symm\n\n"}
{"name":"AddSubgroup.exists_left_transversal_of_le","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH' H : AddSubgroup G\nh : LE.le H' H\n⊢ Exists fun S => And (Eq (HAdd.hAdd S ↑H') ↑H) (Eq (HMul.hMul (Nat.card ↑S) (Nat.card (Subtype fun x => Membership.mem H' x))) (Nat.card (Subtype fun x => Membership.mem H x)))","decl":"/-- Given two subgroups `H' ⊆ H`, there exists a left transversal to `H'` inside `H`. -/\n@[to_additive \"Given two subgroups `H' ⊆ H`, there exists a transversal to `H'` inside `H`\"]\nlemma exists_left_transversal_of_le {H' H : Subgroup G} (h : H' ≤ H) :\n    ∃ S : Set G, S * H' = H ∧ Nat.card S * Nat.card H' = Nat.card H := by\n  let H'' : Subgroup H := H'.comap H.subtype\n  have : H' = H''.map H.subtype := by simp [H'', h]\n  rw [this]\n  obtain ⟨S, cmem, -⟩ := H''.exists_isComplement_left 1\n  refine ⟨H.subtype '' S, ?_, ?_⟩\n  · have : H.subtype '' (S * H'') = H.subtype '' S * H''.map H.subtype := image_mul H.subtype\n    rw [← this, cmem.mul_eq]\n    simp [Set.ext_iff]\n  · rw [← cmem.card_mul_card]\n    refine congr_arg₂ (· * ·) ?_ ?_ <;>\n      exact Nat.card_congr (Equiv.Set.image _ _ <| subtype_injective H).symm\n\n"}
{"name":"AddSubgroup.exists_right_transversal_of_le","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH' H : AddSubgroup G\nh : LE.le H' H\n⊢ Exists fun S => And (Eq (HAdd.hAdd (↑H') S) ↑H) (Eq (HMul.hMul (Nat.card (Subtype fun x => Membership.mem H' x)) (Nat.card ↑S)) (Nat.card (Subtype fun x => Membership.mem H x)))","decl":"/-- Given two subgroups `H' ⊆ H`, there exists a right transversal to `H'` inside `H`. -/\n@[to_additive \"Given two subgroups `H' ⊆ H`, there exists a transversal to `H'` inside `H`\"]\nlemma exists_right_transversal_of_le {H' H : Subgroup G} (h : H' ≤ H) :\n    ∃ S : Set G, H' * S = H ∧ Nat.card H' * Nat.card S = Nat.card H := by\n  let H'' : Subgroup H := H'.comap H.subtype\n  have : H' = H''.map H.subtype := by simp [H'', h]\n  rw [this]\n  obtain ⟨S, cmem, -⟩ := H''.exists_isComplement_right 1\n  refine ⟨H.subtype '' S, ?_, ?_⟩\n  · have : H.subtype '' (H'' * S) = H''.map H.subtype * H.subtype '' S := image_mul H.subtype\n    rw [← this, cmem.mul_eq]\n    simp [Set.ext_iff]\n  · have : Nat.card H'' * Nat.card S = Nat.card H := cmem.card_mul_card\n    rw [← this]\n    refine congr_arg₂ (· * ·) ?_ ?_ <;>\n      exact Nat.card_congr (Equiv.Set.image _ _ <| subtype_injective H).symm\n\n"}
{"name":"Subgroup.exists_right_transversal_of_le","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝ : Group G\nH' H : Subgroup G\nh : LE.le H' H\n⊢ Exists fun S => And (Eq (HMul.hMul (↑H') S) ↑H) (Eq (HMul.hMul (Nat.card (Subtype fun x => Membership.mem H' x)) (Nat.card ↑S)) (Nat.card (Subtype fun x => Membership.mem H x)))","decl":"/-- Given two subgroups `H' ⊆ H`, there exists a right transversal to `H'` inside `H`. -/\n@[to_additive \"Given two subgroups `H' ⊆ H`, there exists a transversal to `H'` inside `H`\"]\nlemma exists_right_transversal_of_le {H' H : Subgroup G} (h : H' ≤ H) :\n    ∃ S : Set G, H' * S = H ∧ Nat.card H' * Nat.card S = Nat.card H := by\n  let H'' : Subgroup H := H'.comap H.subtype\n  have : H' = H''.map H.subtype := by simp [H'', h]\n  rw [this]\n  obtain ⟨S, cmem, -⟩ := H''.exists_isComplement_right 1\n  refine ⟨H.subtype '' S, ?_, ?_⟩\n  · have : H.subtype '' (H'' * S) = H''.map H.subtype * H.subtype '' S := image_mul H.subtype\n    rw [← this, cmem.mul_eq]\n    simp [Set.ext_iff]\n  · have : Nat.card H'' * Nat.card S = Nat.card H := cmem.card_mul_card\n    rw [← this]\n    refine congr_arg₂ (· * ·) ?_ ?_ <;>\n      exact Nat.card_congr (Equiv.Set.image _ _ <| subtype_injective H).symm\n\n"}
{"name":"Subgroup.IsComplement.equiv_symm_apply","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝ : Group G\nS T : Set G\nhST : Subgroup.IsComplement S T\nx : Prod ↑S ↑T\n⊢ Eq (hST.equiv.symm x) (HMul.hMul ↑x.1 ↑x.2)","decl":"@[simp] theorem equiv_symm_apply (x : S × T) : (hST.equiv.symm x : G) = x.1.1 * x.2.1 := rfl\n\n"}
{"name":"Subgroup.IsComplement.equiv_fst_mul_equiv_snd","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝ : Group G\nS T : Set G\nhST : Subgroup.IsComplement S T\ng : G\n⊢ Eq (HMul.hMul ↑(hST.equiv g).1 ↑(hST.equiv g).2) g","decl":"@[simp]\ntheorem equiv_fst_mul_equiv_snd (g : G) : ↑(hST.equiv g).fst * (hST.equiv g).snd = g :=\n  (Equiv.ofBijective (fun x : S × T => x.1.1 * x.2.1) hST).right_inv g\n\n"}
{"name":"Subgroup.IsComplement.equiv_fst_eq_mul_inv","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝ : Group G\nS T : Set G\nhST : Subgroup.IsComplement S T\ng : G\n⊢ Eq (↑(hST.equiv g).1) (HMul.hMul g (Inv.inv ↑(hST.equiv g).2))","decl":"theorem equiv_fst_eq_mul_inv (g : G) : ↑(hST.equiv g).fst = g * ((hST.equiv g).snd : G)⁻¹ :=\n  eq_mul_inv_of_mul_eq (hST.equiv_fst_mul_equiv_snd g)\n\n"}
{"name":"Subgroup.IsComplement.equiv_snd_eq_inv_mul","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝ : Group G\nS T : Set G\nhST : Subgroup.IsComplement S T\ng : G\n⊢ Eq (↑(hST.equiv g).2) (HMul.hMul (Inv.inv ↑(hST.equiv g).1) g)","decl":"theorem equiv_snd_eq_inv_mul (g : G) : ↑(hST.equiv g).snd = ((hST.equiv g).fst : G)⁻¹ * g :=\n  eq_inv_mul_of_mul_eq (hST.equiv_fst_mul_equiv_snd g)\n\n"}
{"name":"Subgroup.IsComplement.equiv_fst_eq_iff_leftCosetEquivalence","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝ : Group G\nK : Subgroup G\nS : Set G\nhSK : Subgroup.IsComplement S ↑K\ng₁ g₂ : G\n⊢ Iff (Eq (hSK.equiv g₁).1 (hSK.equiv g₂).1) (LeftCosetEquivalence (↑K) g₁ g₂)","decl":"theorem equiv_fst_eq_iff_leftCosetEquivalence {g₁ g₂ : G} :\n    (hSK.equiv g₁).fst = (hSK.equiv g₂).fst ↔ LeftCosetEquivalence K g₁ g₂ := by\n  rw [LeftCosetEquivalence, leftCoset_eq_iff]\n  constructor\n  · intro h\n    rw [← hSK.equiv_fst_mul_equiv_snd g₂, ← hSK.equiv_fst_mul_equiv_snd g₁, ← h,\n      mul_inv_rev, ← mul_assoc, inv_mul_cancel_right, ← coe_inv, ← coe_mul]\n    exact Subtype.property _\n  · intro h\n    apply (isComplement_iff_existsUnique_inv_mul_mem.1 hSK g₁).unique\n    · -- This used to be `simp [...]` before https://github.com/leanprover/lean4/pull/2644\n      rw [equiv_fst_eq_mul_inv]; simp\n    · rw [SetLike.mem_coe, ← mul_mem_cancel_right h]\n      -- This used to be `simp [...]` before https://github.com/leanprover/lean4/pull/2644\n      rw [equiv_fst_eq_mul_inv]; simp [equiv_fst_eq_mul_inv, ← mul_assoc]\n\n"}
{"name":"Subgroup.IsComplement.equiv_snd_eq_iff_rightCosetEquivalence","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝ : Group G\nH : Subgroup G\nT : Set G\nhHT : Subgroup.IsComplement (↑H) T\ng₁ g₂ : G\n⊢ Iff (Eq (hHT.equiv g₁).2 (hHT.equiv g₂).2) (RightCosetEquivalence (↑H) g₁ g₂)","decl":"theorem equiv_snd_eq_iff_rightCosetEquivalence {g₁ g₂ : G} :\n    (hHT.equiv g₁).snd = (hHT.equiv g₂).snd ↔ RightCosetEquivalence H g₁ g₂ := by\n  rw [RightCosetEquivalence, rightCoset_eq_iff]\n  constructor\n  · intro h\n    rw [← hHT.equiv_fst_mul_equiv_snd g₂, ← hHT.equiv_fst_mul_equiv_snd g₁, ← h,\n      mul_inv_rev, mul_assoc, mul_inv_cancel_left, ← coe_inv, ← coe_mul]\n    exact Subtype.property _\n  · intro h\n    apply (isComplement_iff_existsUnique_mul_inv_mem.1 hHT g₁).unique\n    · -- This used to be `simp [...]` before https://github.com/leanprover/lean4/pull/2644\n      rw [equiv_snd_eq_inv_mul]; simp\n    · rw [SetLike.mem_coe, ← mul_mem_cancel_left h]\n      -- This used to be `simp [...]` before https://github.com/leanprover/lean4/pull/2644\n      rw [equiv_snd_eq_inv_mul, mul_assoc]; simp\n\n"}
{"name":"Subgroup.IsComplement.leftCosetEquivalence_equiv_fst","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝ : Group G\nK : Subgroup G\nS : Set G\nhSK : Subgroup.IsComplement S ↑K\ng : G\n⊢ LeftCosetEquivalence (↑K) g ↑(hSK.equiv g).1","decl":"theorem leftCosetEquivalence_equiv_fst (g : G) :\n    LeftCosetEquivalence K g ((hSK.equiv g).fst : G) := by\n  -- This used to be `simp [...]` before https://github.com/leanprover/lean4/pull/2644\n  rw [equiv_fst_eq_mul_inv]; simp [LeftCosetEquivalence, leftCoset_eq_iff]\n\n"}
{"name":"Subgroup.IsComplement.rightCosetEquivalence_equiv_snd","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝ : Group G\nH : Subgroup G\nT : Set G\nhHT : Subgroup.IsComplement (↑H) T\ng : G\n⊢ RightCosetEquivalence (↑H) g ↑(hHT.equiv g).2","decl":"theorem rightCosetEquivalence_equiv_snd (g : G) :\n    RightCosetEquivalence H g ((hHT.equiv g).snd : G) := by\n  -- This used to be `simp [...]` before https://github.com/leanprover/lean4/pull/2644\n  rw [RightCosetEquivalence, rightCoset_eq_iff, equiv_snd_eq_inv_mul]; simp\n\n"}
{"name":"Subgroup.IsComplement.equiv_fst_eq_self_of_mem_of_one_mem","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝ : Group G\nS T : Set G\nhST : Subgroup.IsComplement S T\ng : G\nh1 : Membership.mem T 1\nhg : Membership.mem S g\n⊢ Eq (hST.equiv g).1 ⟨g, hg⟩","decl":"theorem equiv_fst_eq_self_of_mem_of_one_mem {g : G} (h1 : 1 ∈ T) (hg : g ∈ S) :\n    (hST.equiv g).fst = ⟨g, hg⟩ := by\n  have : hST.equiv.symm (⟨g, hg⟩, ⟨1, h1⟩) = g := by\n    rw [equiv, Equiv.ofBijective]; simp\n  conv_lhs => rw [← this, Equiv.apply_symm_apply]\n\n"}
{"name":"Subgroup.IsComplement.equiv_snd_eq_self_of_mem_of_one_mem","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝ : Group G\nS T : Set G\nhST : Subgroup.IsComplement S T\ng : G\nh1 : Membership.mem S 1\nhg : Membership.mem T g\n⊢ Eq (hST.equiv g).2 ⟨g, hg⟩","decl":"theorem equiv_snd_eq_self_of_mem_of_one_mem {g : G} (h1 : 1 ∈ S) (hg : g ∈ T) :\n    (hST.equiv g).snd = ⟨g, hg⟩ := by\n  have : hST.equiv.symm (⟨1, h1⟩, ⟨g, hg⟩) = g := by\n    rw [equiv, Equiv.ofBijective]; simp\n  conv_lhs => rw [← this, Equiv.apply_symm_apply]\n\n"}
{"name":"Subgroup.IsComplement.equiv_snd_eq_one_of_mem_of_one_mem","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝ : Group G\nS T : Set G\nhST : Subgroup.IsComplement S T\ng : G\nh1 : Membership.mem T 1\nhg : Membership.mem S g\n⊢ Eq (hST.equiv g).2 ⟨1, h1⟩","decl":"theorem equiv_snd_eq_one_of_mem_of_one_mem {g : G} (h1 : 1 ∈ T) (hg : g ∈ S) :\n    (hST.equiv g).snd = ⟨1, h1⟩ := by\n  ext\n  rw [equiv_snd_eq_inv_mul, equiv_fst_eq_self_of_mem_of_one_mem _ h1 hg, inv_mul_cancel]\n\n"}
{"name":"Subgroup.IsComplement.equiv_fst_eq_one_of_mem_of_one_mem","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝ : Group G\nS T : Set G\nhST : Subgroup.IsComplement S T\ng : G\nh1 : Membership.mem S 1\nhg : Membership.mem T g\n⊢ Eq (hST.equiv g).1 ⟨1, h1⟩","decl":"theorem equiv_fst_eq_one_of_mem_of_one_mem {g : G} (h1 : 1 ∈ S) (hg : g ∈ T) :\n    (hST.equiv g).fst = ⟨1, h1⟩ := by\n  ext\n  rw [equiv_fst_eq_mul_inv, equiv_snd_eq_self_of_mem_of_one_mem _ h1 hg, mul_inv_cancel]\n\n"}
{"name":"Subgroup.IsComplement.equiv_mul_right","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝ : Group G\nK : Subgroup G\nS : Set G\nhSK : Subgroup.IsComplement S ↑K\ng : G\nk : Subtype fun x => Membership.mem K x\n⊢ Eq (hSK.equiv (HMul.hMul g ↑k)) { fst := (hSK.equiv g).1, snd := HMul.hMul (hSK.equiv g).2 k }","decl":"theorem equiv_mul_right (g : G) (k : K) :\n    hSK.equiv (g * k) = ((hSK.equiv g).fst, (hSK.equiv g).snd * k) := by\n  have : (hSK.equiv (g * k)).fst = (hSK.equiv g).fst :=\n    hSK.equiv_fst_eq_iff_leftCosetEquivalence.2\n      (by simp [LeftCosetEquivalence, leftCoset_eq_iff])\n  ext\n  · rw [this]\n  · rw [coe_mul, equiv_snd_eq_inv_mul, this, equiv_snd_eq_inv_mul, mul_assoc]\n\n"}
{"name":"Subgroup.IsComplement.equiv_mul_right_of_mem","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝ : Group G\nK : Subgroup G\nS : Set G\nhSK : Subgroup.IsComplement S ↑K\ng k : G\nh : Membership.mem K k\n⊢ Eq (hSK.equiv (HMul.hMul g k)) { fst := (hSK.equiv g).1, snd := HMul.hMul (hSK.equiv g).2 ⟨k, h⟩ }","decl":"theorem equiv_mul_right_of_mem {g k : G} (h : k ∈ K) :\n    hSK.equiv (g * k) = ((hSK.equiv g).fst, (hSK.equiv g).snd * ⟨k, h⟩) :=\n  equiv_mul_right _ g ⟨k, h⟩\n\n"}
{"name":"Subgroup.IsComplement.equiv_mul_left","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝ : Group G\nH : Subgroup G\nT : Set G\nhHT : Subgroup.IsComplement (↑H) T\nh : Subtype fun x => Membership.mem H x\ng : G\n⊢ Eq (hHT.equiv (HMul.hMul (↑h) g)) { fst := HMul.hMul h (hHT.equiv g).1, snd := (hHT.equiv g).2 }","decl":"theorem equiv_mul_left (h : H) (g : G) :\n    hHT.equiv (h * g) = (h * (hHT.equiv g).fst, (hHT.equiv g).snd) := by\n  have : (hHT.equiv (h * g)).2 = (hHT.equiv g).2 := hHT.equiv_snd_eq_iff_rightCosetEquivalence.2 ?_\n  · ext\n    · rw [coe_mul, equiv_fst_eq_mul_inv, this, equiv_fst_eq_mul_inv, mul_assoc]\n    · rw [this]\n  · simp [RightCosetEquivalence, ← smul_smul]\n\n"}
{"name":"Subgroup.IsComplement.equiv_mul_left_of_mem","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝ : Group G\nH : Subgroup G\nT : Set G\nhHT : Subgroup.IsComplement (↑H) T\nh g : G\nhh : Membership.mem H h\n⊢ Eq (hHT.equiv (HMul.hMul h g)) { fst := HMul.hMul ⟨h, hh⟩ (hHT.equiv g).1, snd := (hHT.equiv g).2 }","decl":"theorem equiv_mul_left_of_mem {h g : G} (hh : h ∈ H) :\n    hHT.equiv (h * g) = (⟨h, hh⟩ * (hHT.equiv g).fst, (hHT.equiv g).snd) :=\n  equiv_mul_left _ ⟨h, hh⟩ g\n\n"}
{"name":"Subgroup.IsComplement.equiv_one","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝ : Group G\nS T : Set G\nhST : Subgroup.IsComplement S T\nhs1 : Membership.mem S 1\nht1 : Membership.mem T 1\n⊢ Eq (hST.equiv 1) { fst := ⟨1, hs1⟩, snd := ⟨1, ht1⟩ }","decl":"theorem equiv_one (hs1 : 1 ∈ S) (ht1 : 1 ∈ T) :\n    hST.equiv 1 = (⟨1, hs1⟩, ⟨1, ht1⟩) := by\n  rw [Equiv.apply_eq_iff_eq_symm_apply]; simp [equiv]\n\n"}
{"name":"Subgroup.IsComplement.equiv_fst_eq_self_iff_mem","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝ : Group G\nS T : Set G\nhST : Subgroup.IsComplement S T\ng : G\nh1 : Membership.mem T 1\n⊢ Iff (Eq (↑(hST.equiv g).1) g) (Membership.mem S g)","decl":"theorem equiv_fst_eq_self_iff_mem {g : G} (h1 : 1 ∈ T) :\n    ((hST.equiv g).fst : G) = g ↔ g ∈ S := by\n  constructor\n  · intro h\n    rw [← h]\n    exact Subtype.prop _\n  · intro h\n    rw [hST.equiv_fst_eq_self_of_mem_of_one_mem h1 h]\n\n"}
{"name":"Subgroup.IsComplement.equiv_snd_eq_self_iff_mem","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝ : Group G\nS T : Set G\nhST : Subgroup.IsComplement S T\ng : G\nh1 : Membership.mem S 1\n⊢ Iff (Eq (↑(hST.equiv g).2) g) (Membership.mem T g)","decl":"theorem equiv_snd_eq_self_iff_mem {g : G} (h1 : 1 ∈ S) :\n    ((hST.equiv g).snd : G) = g ↔ g ∈ T := by\n  constructor\n  · intro h\n    rw [← h]\n    exact Subtype.prop _\n  · intro h\n    rw [hST.equiv_snd_eq_self_of_mem_of_one_mem h1 h]\n\n"}
{"name":"Subgroup.IsComplement.coe_equiv_fst_eq_one_iff_mem","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝ : Group G\nS T : Set G\nhST : Subgroup.IsComplement S T\ng : G\nh1 : Membership.mem S 1\n⊢ Iff (Eq (↑(hST.equiv g).1) 1) (Membership.mem T g)","decl":"theorem coe_equiv_fst_eq_one_iff_mem {g : G} (h1 : 1 ∈ S) :\n    ((hST.equiv g).fst : G) = 1 ↔ g ∈ T := by\n  rw [equiv_fst_eq_mul_inv, mul_inv_eq_one, eq_comm, equiv_snd_eq_self_iff_mem _ h1]\n\n"}
{"name":"Subgroup.IsComplement.coe_equiv_snd_eq_one_iff_mem","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝ : Group G\nS T : Set G\nhST : Subgroup.IsComplement S T\ng : G\nh1 : Membership.mem T 1\n⊢ Iff (Eq (↑(hST.equiv g).2) 1) (Membership.mem S g)","decl":"theorem coe_equiv_snd_eq_one_iff_mem {g : G} (h1 : 1 ∈ T) :\n    ((hST.equiv g).snd : G) = 1 ↔ g ∈ S := by\n  rw [equiv_snd_eq_inv_mul, inv_mul_eq_one, equiv_fst_eq_self_iff_mem _ h1]\n\n"}
{"name":"Subgroup.IsComplement.finite_left_iff","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝ : Group G\nH : Subgroup G\nS : Set G\nh : Subgroup.IsComplement S ↑H\n⊢ Iff (Finite ↑S) H.FiniteIndex","decl":"/-- A left transversal is finite iff the subgroup has finite index.-/\n@[to_additive \"A left transversal is finite iff the subgroup has finite index.\"]\ntheorem finite_left_iff (h : IsComplement S H) : Finite S ↔ H.FiniteIndex := by\n  rw [← h.leftQuotientEquiv.finite_iff]\n  exact ⟨fun _ ↦ finiteIndex_of_finite_quotient H, fun _ ↦ finite_quotient_of_finiteIndex H⟩\n\n"}
{"name":"AddSubgroup.IsComplement.finite_left_iff","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH : AddSubgroup G\nS : Set G\nh : AddSubgroup.IsComplement S ↑H\n⊢ Iff (Finite ↑S) H.FiniteIndex","decl":"/-- A left transversal is finite iff the subgroup has finite index.-/\n@[to_additive \"A left transversal is finite iff the subgroup has finite index.\"]\ntheorem finite_left_iff (h : IsComplement S H) : Finite S ↔ H.FiniteIndex := by\n  rw [← h.leftQuotientEquiv.finite_iff]\n  exact ⟨fun _ ↦ finiteIndex_of_finite_quotient H, fun _ ↦ finite_quotient_of_finiteIndex H⟩\n\n"}
{"name":"Subgroup.MemLeftTransversals.finite_iff","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝ : Group G\nH : Subgroup G\nS : Set G\nh : Subgroup.IsComplement S ↑H\n⊢ Iff (Finite ↑S) H.FiniteIndex","decl":"@[deprecated (since := \"2024-12-28\")]\nalias _root_.Subgroup.MemLeftTransversals.finite_iff := finite_left_iff\n\n"}
{"name":"Subgroup.IsComplement.finite_left","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nH : Subgroup G\nS : Set G\ninst✝ : H.FiniteIndex\nhS : Subgroup.IsComplement S ↑H\n⊢ S.Finite","decl":"@[to_additive]\nlemma finite_left [H.FiniteIndex] (hS : IsComplement S H) : S.Finite := hS.finite_left_iff.2 ‹_›\n\n"}
{"name":"AddSubgroup.IsComplement.finite_left","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nH : AddSubgroup G\nS : Set G\ninst✝ : H.FiniteIndex\nhS : AddSubgroup.IsComplement S ↑H\n⊢ S.Finite","decl":"@[to_additive]\nlemma finite_left [H.FiniteIndex] (hS : IsComplement S H) : S.Finite := hS.finite_left_iff.2 ‹_›\n\n"}
{"name":"Subgroup.IsComplement.quotientGroupMk_leftQuotientEquiv","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝ : Group G\nH : Subgroup G\nS : Set G\nhS : Subgroup.IsComplement S ↑H\nq : HasQuotient.Quotient G H\n⊢ Eq (Quotient.mk'' ↑(hS.leftQuotientEquiv q)) q","decl":"@[to_additive]\ntheorem quotientGroupMk_leftQuotientEquiv (hS : IsComplement S H) (q : G ⧸ H) :\n    Quotient.mk'' (leftQuotientEquiv hS q : G) = q :=\n  hS.leftQuotientEquiv.symm_apply_apply q\n\n"}
{"name":"AddSubgroup.IsComplement.quotientAddGroupMk_leftQuotientEquiv","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH : AddSubgroup G\nS : Set G\nhS : AddSubgroup.IsComplement S ↑H\nq : HasQuotient.Quotient G H\n⊢ Eq (Quotient.mk'' ↑(hS.leftQuotientEquiv q)) q","decl":"@[to_additive]\ntheorem quotientGroupMk_leftQuotientEquiv (hS : IsComplement S H) (q : G ⧸ H) :\n    Quotient.mk'' (leftQuotientEquiv hS q : G) = q :=\n  hS.leftQuotientEquiv.symm_apply_apply q\n\n"}
{"name":"Subgroup.MemLeftTransversals.mk''_toEquiv","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝ : Group G\nH : Subgroup G\nS : Set G\nhS : Subgroup.IsComplement S ↑H\nq : HasQuotient.Quotient G H\n⊢ Eq (Quotient.mk'' ↑(hS.leftQuotientEquiv q)) q","decl":"@[deprecated (since := \"2024-12-28\")]\nalias _root_.Subgroup.MemLeftTransversals.mk''_toEquiv := quotientGroupMk_leftQuotientEquiv\n\n"}
{"name":"AddSubgroup.IsComplement.leftQuotientEquiv_apply","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH : AddSubgroup G\nf : HasQuotient.Quotient G H → G\nhf : ∀ (q : HasQuotient.Quotient G H), Eq (↑(f q)) q\nq : HasQuotient.Quotient G H\n⊢ Eq (↑(⋯.leftQuotientEquiv q)) (f q)","decl":"@[to_additive]\ntheorem leftQuotientEquiv_apply {f : G ⧸ H → G} (hf : ∀ q, (f q : G ⧸ H) = q) (q : G ⧸ H) :\n    (leftQuotientEquiv (isComplement_range_left hf) q : G) = f q := by\n  refine (Subtype.ext_iff.mp ?_).trans (Subtype.coe_mk (f q) ⟨q, rfl⟩)\n  exact (leftQuotientEquiv (isComplement_range_left hf)).apply_eq_iff_eq_symm_apply.mpr (hf q).symm\n\n"}
{"name":"Subgroup.IsComplement.leftQuotientEquiv_apply","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝ : Group G\nH : Subgroup G\nf : HasQuotient.Quotient G H → G\nhf : ∀ (q : HasQuotient.Quotient G H), Eq (↑(f q)) q\nq : HasQuotient.Quotient G H\n⊢ Eq (↑(⋯.leftQuotientEquiv q)) (f q)","decl":"@[to_additive]\ntheorem leftQuotientEquiv_apply {f : G ⧸ H → G} (hf : ∀ q, (f q : G ⧸ H) = q) (q : G ⧸ H) :\n    (leftQuotientEquiv (isComplement_range_left hf) q : G) = f q := by\n  refine (Subtype.ext_iff.mp ?_).trans (Subtype.coe_mk (f q) ⟨q, rfl⟩)\n  exact (leftQuotientEquiv (isComplement_range_left hf)).apply_eq_iff_eq_symm_apply.mpr (hf q).symm\n\n"}
{"name":"Subgroup.MemLeftTransversals.toEquiv_apply","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝ : Group G\nH : Subgroup G\nf : HasQuotient.Quotient G H → G\nhf : ∀ (q : HasQuotient.Quotient G H), Eq (↑(f q)) q\nq : HasQuotient.Quotient G H\n⊢ Eq (↑(⋯.leftQuotientEquiv q)) (f q)","decl":"@[deprecated (since := \"2024-12-28\")]\nalias _root_.Subgroup.MemLeftTransversals.toEquiv_apply := leftQuotientEquiv_apply\n\n"}
{"name":"AddSubgroup.IsComplement.neg_toLeftFun_add_mem","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH : AddSubgroup G\nS : Set G\nhS : AddSubgroup.IsComplement S ↑H\ng : G\n⊢ Membership.mem H (HAdd.hAdd (Neg.neg ↑(hS.toLeftFun g)) g)","decl":"@[to_additive]\ntheorem inv_toLeftFun_mul_mem (hS : IsComplement S H) (g : G) :\n    (toLeftFun hS g : G)⁻¹ * g ∈ H :=\n  QuotientGroup.leftRel_apply.mp <| Quotient.exact' <| quotientGroupMk_leftQuotientEquiv _ _\n\n"}
{"name":"Subgroup.IsComplement.inv_toLeftFun_mul_mem","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝ : Group G\nH : Subgroup G\nS : Set G\nhS : Subgroup.IsComplement S ↑H\ng : G\n⊢ Membership.mem H (HMul.hMul (Inv.inv ↑(hS.toLeftFun g)) g)","decl":"@[to_additive]\ntheorem inv_toLeftFun_mul_mem (hS : IsComplement S H) (g : G) :\n    (toLeftFun hS g : G)⁻¹ * g ∈ H :=\n  QuotientGroup.leftRel_apply.mp <| Quotient.exact' <| quotientGroupMk_leftQuotientEquiv _ _\n\n"}
{"name":"Subgroup.MemLeftTransversals.inv_toFun_mul_mem","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝ : Group G\nH : Subgroup G\nS : Set G\nhS : Subgroup.IsComplement S ↑H\ng : G\n⊢ Membership.mem H (HMul.hMul (Inv.inv ↑(hS.toLeftFun g)) g)","decl":"@[deprecated (since := \"2024-12-28\")]\nalias _root_.Subgroup.MemLeftTransversals.inv_toFun_mul_mem := inv_toLeftFun_mul_mem\n\n"}
{"name":"AddSubgroup.IsComplement.neg_add_toLeftFun_mem","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH : AddSubgroup G\nS : Set G\nhS : AddSubgroup.IsComplement S ↑H\ng : G\n⊢ Membership.mem H (HAdd.hAdd (Neg.neg g) ↑(hS.toLeftFun g))","decl":"@[to_additive]\ntheorem inv_mul_toLeftFun_mem (hS : IsComplement S H) (g : G) :\n    g⁻¹ * toLeftFun hS g ∈ H :=\n  (congr_arg (· ∈ H) (by rw [mul_inv_rev, inv_inv])).mp (H.inv_mem (inv_toLeftFun_mul_mem hS g))\n\n"}
{"name":"Subgroup.IsComplement.inv_mul_toLeftFun_mem","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝ : Group G\nH : Subgroup G\nS : Set G\nhS : Subgroup.IsComplement S ↑H\ng : G\n⊢ Membership.mem H (HMul.hMul (Inv.inv g) ↑(hS.toLeftFun g))","decl":"@[to_additive]\ntheorem inv_mul_toLeftFun_mem (hS : IsComplement S H) (g : G) :\n    g⁻¹ * toLeftFun hS g ∈ H :=\n  (congr_arg (· ∈ H) (by rw [mul_inv_rev, inv_inv])).mp (H.inv_mem (inv_toLeftFun_mul_mem hS g))\n\n"}
{"name":"Subgroup.MemLeftTransversals.inv_mul_toFun_mem","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝ : Group G\nH : Subgroup G\nS : Set G\nhS : Subgroup.IsComplement S ↑H\ng : G\n⊢ Membership.mem H (HMul.hMul (Inv.inv g) ↑(hS.toLeftFun g))","decl":"@[deprecated (since := \"2024-12-28\")]\nalias _root_.Subgroup.MemLeftTransversals.inv_mul_toFun_mem := inv_mul_toLeftFun_mem\n\n"}
{"name":"AddSubgroup.IsComplement.finite_right_iff","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH : AddSubgroup G\nT : Set G\nh : AddSubgroup.IsComplement (↑H) T\n⊢ Iff (Finite ↑T) H.FiniteIndex","decl":"/-- A right transversal is finite iff the subgroup has finite index. -/\n@[to_additive \"A right transversal is finite iff the subgroup has finite index.\"]\ntheorem finite_right_iff (h : IsComplement H T) : Finite T ↔ H.FiniteIndex := by\n  rw [← h.rightQuotientEquiv.finite_iff,\n    (QuotientGroup.quotientRightRelEquivQuotientLeftRel H).finite_iff]\n  exact ⟨fun _ ↦ finiteIndex_of_finite_quotient H, fun _ ↦ finite_quotient_of_finiteIndex H⟩\n\n"}
{"name":"Subgroup.IsComplement.finite_right_iff","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝ : Group G\nH : Subgroup G\nT : Set G\nh : Subgroup.IsComplement (↑H) T\n⊢ Iff (Finite ↑T) H.FiniteIndex","decl":"/-- A right transversal is finite iff the subgroup has finite index. -/\n@[to_additive \"A right transversal is finite iff the subgroup has finite index.\"]\ntheorem finite_right_iff (h : IsComplement H T) : Finite T ↔ H.FiniteIndex := by\n  rw [← h.rightQuotientEquiv.finite_iff,\n    (QuotientGroup.quotientRightRelEquivQuotientLeftRel H).finite_iff]\n  exact ⟨fun _ ↦ finiteIndex_of_finite_quotient H, fun _ ↦ finite_quotient_of_finiteIndex H⟩\n\n"}
{"name":"Subgroup.MemRightTransversals.finite_iff","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝ : Group G\nH : Subgroup G\nT : Set G\nh : Subgroup.IsComplement (↑H) T\n⊢ Iff (Finite ↑T) H.FiniteIndex","decl":"@[deprecated (since := \"2024-12-28\")]\nalias _root_.Subgroup.MemRightTransversals.finite_iff := finite_right_iff\n\n"}
{"name":"AddSubgroup.IsComplement.finite_right","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nH : AddSubgroup G\nT : Set G\ninst✝ : H.FiniteIndex\nhT : AddSubgroup.IsComplement (↑H) T\n⊢ T.Finite","decl":"@[to_additive]\nlemma finite_right [H.FiniteIndex] (hT : IsComplement H T) : T.Finite := hT.finite_right_iff.2 ‹_›\n\n"}
{"name":"Subgroup.IsComplement.finite_right","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nH : Subgroup G\nT : Set G\ninst✝ : H.FiniteIndex\nhT : Subgroup.IsComplement (↑H) T\n⊢ T.Finite","decl":"@[to_additive]\nlemma finite_right [H.FiniteIndex] (hT : IsComplement H T) : T.Finite := hT.finite_right_iff.2 ‹_›\n\n"}
{"name":"Subgroup.IsComplement.mk''_rightQuotientEquiv","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝ : Group G\nH : Subgroup G\nT : Set G\nhT : Subgroup.IsComplement (↑H) T\nq : Quotient (QuotientGroup.rightRel H)\n⊢ Eq (Quotient.mk'' ↑(hT.rightQuotientEquiv q)) q","decl":"@[to_additive]\ntheorem mk''_rightQuotientEquiv (hT : IsComplement H T)\n     (q : Quotient (QuotientGroup.rightRel H)) : Quotient.mk'' (rightQuotientEquiv hT q : G) = q :=\n  (rightQuotientEquiv hT).symm_apply_apply q\n\n"}
{"name":"AddSubgroup.IsComplement.mk''_rightQuotientEquiv","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH : AddSubgroup G\nT : Set G\nhT : AddSubgroup.IsComplement (↑H) T\nq : Quotient (QuotientAddGroup.rightRel H)\n⊢ Eq (Quotient.mk'' ↑(hT.rightQuotientEquiv q)) q","decl":"@[to_additive]\ntheorem mk''_rightQuotientEquiv (hT : IsComplement H T)\n     (q : Quotient (QuotientGroup.rightRel H)) : Quotient.mk'' (rightQuotientEquiv hT q : G) = q :=\n  (rightQuotientEquiv hT).symm_apply_apply q\n\n"}
{"name":"Subgroup.MemRightTransversals.mk''_toEquiv","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝ : Group G\nH : Subgroup G\nT : Set G\nhT : Subgroup.IsComplement (↑H) T\nq : Quotient (QuotientGroup.rightRel H)\n⊢ Eq (Quotient.mk'' ↑(hT.rightQuotientEquiv q)) q","decl":"@[deprecated (since := \"2024-12-28\")]\nalias _root_.Subgroup.MemRightTransversals.mk''_toEquiv := mk''_rightQuotientEquiv\n\n"}
{"name":"Subgroup.IsComplement.rightQuotientEquiv_apply","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝ : Group G\nH : Subgroup G\nf : Quotient (QuotientGroup.rightRel H) → G\nhf : ∀ (q : Quotient (QuotientGroup.rightRel H)), Eq (Quotient.mk'' (f q)) q\nq : Quotient (QuotientGroup.rightRel H)\n⊢ Eq (↑(⋯.rightQuotientEquiv q)) (f q)","decl":"@[to_additive]\ntheorem rightQuotientEquiv_apply {f : Quotient (QuotientGroup.rightRel H) → G}\n    (hf : ∀ q, Quotient.mk'' (f q) = q) (q : Quotient (QuotientGroup.rightRel H)) :\n    (rightQuotientEquiv (isComplement_range_right hf) q : G) = f q := by\n  refine (Subtype.ext_iff.mp ?_).trans (Subtype.coe_mk (f q) ⟨q, rfl⟩)\n  exact (rightQuotientEquiv (isComplement_range_right hf)).apply_eq_iff_eq_symm_apply.2 (hf q).symm\n\n"}
{"name":"AddSubgroup.IsComplement.rightQuotientEquiv_apply","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH : AddSubgroup G\nf : Quotient (QuotientAddGroup.rightRel H) → G\nhf : ∀ (q : Quotient (QuotientAddGroup.rightRel H)), Eq (Quotient.mk'' (f q)) q\nq : Quotient (QuotientAddGroup.rightRel H)\n⊢ Eq (↑(⋯.rightQuotientEquiv q)) (f q)","decl":"@[to_additive]\ntheorem rightQuotientEquiv_apply {f : Quotient (QuotientGroup.rightRel H) → G}\n    (hf : ∀ q, Quotient.mk'' (f q) = q) (q : Quotient (QuotientGroup.rightRel H)) :\n    (rightQuotientEquiv (isComplement_range_right hf) q : G) = f q := by\n  refine (Subtype.ext_iff.mp ?_).trans (Subtype.coe_mk (f q) ⟨q, rfl⟩)\n  exact (rightQuotientEquiv (isComplement_range_right hf)).apply_eq_iff_eq_symm_apply.2 (hf q).symm\n\n"}
{"name":"Subgroup.MemRightTransversals.toEquiv_apply","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝ : Group G\nH : Subgroup G\nf : Quotient (QuotientGroup.rightRel H) → G\nhf : ∀ (q : Quotient (QuotientGroup.rightRel H)), Eq (Quotient.mk'' (f q)) q\nq : Quotient (QuotientGroup.rightRel H)\n⊢ Eq (↑(⋯.rightQuotientEquiv q)) (f q)","decl":"@[deprecated (since := \"2024-12-28\")]\nalias _root_.Subgroup.MemRightTransversals.toEquiv_apply := rightQuotientEquiv_apply\n\n"}
{"name":"AddSubgroup.IsComplement.add_neg_toRightFun_mem","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH : AddSubgroup G\nT : Set G\nhT : AddSubgroup.IsComplement (↑H) T\ng : G\n⊢ Membership.mem H (HAdd.hAdd g (Neg.neg ↑(hT.toRightFun g)))","decl":"@[to_additive]\ntheorem mul_inv_toRightFun_mem (hT : IsComplement H T) (g : G) :\n    g * (toRightFun hT g : G)⁻¹ ∈ H :=\n  QuotientGroup.rightRel_apply.mp <| Quotient.exact' <| mk''_rightQuotientEquiv _ _\n\n"}
{"name":"Subgroup.IsComplement.mul_inv_toRightFun_mem","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝ : Group G\nH : Subgroup G\nT : Set G\nhT : Subgroup.IsComplement (↑H) T\ng : G\n⊢ Membership.mem H (HMul.hMul g (Inv.inv ↑(hT.toRightFun g)))","decl":"@[to_additive]\ntheorem mul_inv_toRightFun_mem (hT : IsComplement H T) (g : G) :\n    g * (toRightFun hT g : G)⁻¹ ∈ H :=\n  QuotientGroup.rightRel_apply.mp <| Quotient.exact' <| mk''_rightQuotientEquiv _ _\n\n"}
{"name":"Subgroup.MemRighTransversals.mul_inv_toFun_mem","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝ : Group G\nH : Subgroup G\nT : Set G\nhT : Subgroup.IsComplement (↑H) T\ng : G\n⊢ Membership.mem H (HMul.hMul g (Inv.inv ↑(hT.toRightFun g)))","decl":"@[deprecated (since := \"2024-12-28\")]\nalias _root_.Subgroup.MemRighTransversals.mul_inv_toFun_mem := mul_inv_toRightFun_mem\n\n"}
{"name":"AddSubgroup.IsComplement.toRightFun_add_neg_mem","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH : AddSubgroup G\nT : Set G\nhT : AddSubgroup.IsComplement (↑H) T\ng : G\n⊢ Membership.mem H (HAdd.hAdd (↑(hT.toRightFun g)) (Neg.neg g))","decl":"@[to_additive]\ntheorem toRightFun_mul_inv_mem (hT : IsComplement H T) (g : G) :\n    (toRightFun hT g : G) * g⁻¹ ∈ H :=\n  (congr_arg (· ∈ H) (by rw [mul_inv_rev, inv_inv])).mp (H.inv_mem (mul_inv_toRightFun_mem hT g))\n\n"}
{"name":"Subgroup.IsComplement.toRightFun_mul_inv_mem","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝ : Group G\nH : Subgroup G\nT : Set G\nhT : Subgroup.IsComplement (↑H) T\ng : G\n⊢ Membership.mem H (HMul.hMul (↑(hT.toRightFun g)) (Inv.inv g))","decl":"@[to_additive]\ntheorem toRightFun_mul_inv_mem (hT : IsComplement H T) (g : G) :\n    (toRightFun hT g : G) * g⁻¹ ∈ H :=\n  (congr_arg (· ∈ H) (by rw [mul_inv_rev, inv_inv])).mp (H.inv_mem (mul_inv_toRightFun_mem hT g))\n\n"}
{"name":"Subgroup.MemRighTransversals.toFun_mul_inv_mem","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝ : Group G\nH : Subgroup G\nT : Set G\nhT : Subgroup.IsComplement (↑H) T\ng : G\n⊢ Membership.mem H (HMul.hMul (↑(hT.toRightFun g)) (Inv.inv g))","decl":"@[deprecated (since := \"2024-12-28\")]\nalias _root_.Subgroup.MemRighTransversals.toFun_mul_inv_mem := toRightFun_mul_inv_mem\n\n"}
{"name":"Subgroup.smul_toLeftFun","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝³ : Group G\nH : Subgroup G\nF : Type u_2\ninst✝² : Group F\ninst✝¹ : MulAction F G\ninst✝ : MulAction.QuotientAction F H\nf : F\nS : H.LeftTransversal\ng : G\n⊢ Eq (HSMul.hSMul f ↑(⋯.toLeftFun g)) ↑(⋯.toLeftFun (HSMul.hSMul f g))","decl":"@[to_additive]\ntheorem smul_toLeftFun (f : F) (S : H.LeftTransversal) (g : G) :\n    (f • (S.2.toLeftFun g : G)) = (f • S).2.toLeftFun (f • g) :=\n  Subtype.ext_iff.mp <| @ExistsUnique.unique (↥(f • (S : Set G))) (fun s => (↑s)⁻¹ * f • g ∈ H)\n    (isComplement_iff_existsUnique_inv_mul_mem.mp (f • S).2 (f • g))\n    ⟨f • (S.2.toLeftFun g : G), Set.smul_mem_smul_set (Subtype.coe_prop _)⟩\n      ((f • S).2.toLeftFun (f • g))\n    (QuotientAction.inv_mul_mem f (S.2.inv_toLeftFun_mul_mem g))\n      ((f • S).2.inv_toLeftFun_mul_mem (f • g))\n\n"}
{"name":"AddSubgroup.vadd_toLeftFun","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝³ : AddGroup G\nH : AddSubgroup G\nF : Type u_2\ninst✝² : AddGroup F\ninst✝¹ : AddAction F G\ninst✝ : AddAction.QuotientAction F H\nf : F\nS : H.LeftTransversal\ng : G\n⊢ Eq (HVAdd.hVAdd f ↑(⋯.toLeftFun g)) ↑(⋯.toLeftFun (HVAdd.hVAdd f g))","decl":"@[to_additive]\ntheorem smul_toLeftFun (f : F) (S : H.LeftTransversal) (g : G) :\n    (f • (S.2.toLeftFun g : G)) = (f • S).2.toLeftFun (f • g) :=\n  Subtype.ext_iff.mp <| @ExistsUnique.unique (↥(f • (S : Set G))) (fun s => (↑s)⁻¹ * f • g ∈ H)\n    (isComplement_iff_existsUnique_inv_mul_mem.mp (f • S).2 (f • g))\n    ⟨f • (S.2.toLeftFun g : G), Set.smul_mem_smul_set (Subtype.coe_prop _)⟩\n      ((f • S).2.toLeftFun (f • g))\n    (QuotientAction.inv_mul_mem f (S.2.inv_toLeftFun_mul_mem g))\n      ((f • S).2.inv_toLeftFun_mul_mem (f • g))\n\n"}
{"name":"AddSubgroup.vadd_leftQuotientEquiv","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝³ : AddGroup G\nH : AddSubgroup G\nF : Type u_2\ninst✝² : AddGroup F\ninst✝¹ : AddAction F G\ninst✝ : AddAction.QuotientAction F H\nf : F\nS : H.LeftTransversal\nq : HasQuotient.Quotient G H\n⊢ Eq (HVAdd.hVAdd f ↑(⋯.leftQuotientEquiv q)) ↑(⋯.leftQuotientEquiv (HVAdd.hVAdd f q))","decl":"@[to_additive]\ntheorem smul_leftQuotientEquiv (f : F) (S : H.LeftTransversal) (q : G ⧸ H) :\n    f • (S.2.leftQuotientEquiv  q : G) = (f • S).2.leftQuotientEquiv (f • q) :=\n  Quotient.inductionOn' q fun g => smul_toLeftFun f S g\n\n"}
{"name":"Subgroup.smul_leftQuotientEquiv","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝³ : Group G\nH : Subgroup G\nF : Type u_2\ninst✝² : Group F\ninst✝¹ : MulAction F G\ninst✝ : MulAction.QuotientAction F H\nf : F\nS : H.LeftTransversal\nq : HasQuotient.Quotient G H\n⊢ Eq (HSMul.hSMul f ↑(⋯.leftQuotientEquiv q)) ↑(⋯.leftQuotientEquiv (HSMul.hSMul f q))","decl":"@[to_additive]\ntheorem smul_leftQuotientEquiv (f : F) (S : H.LeftTransversal) (q : G ⧸ H) :\n    f • (S.2.leftQuotientEquiv  q : G) = (f • S).2.leftQuotientEquiv (f • q) :=\n  Quotient.inductionOn' q fun g => smul_toLeftFun f S g\n\n"}
{"name":"Subgroup.smul_apply_eq_smul_apply_inv_smul","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝³ : Group G\nH : Subgroup G\nF : Type u_2\ninst✝² : Group F\ninst✝¹ : MulAction F G\ninst✝ : MulAction.QuotientAction F H\nf : F\nS : H.LeftTransversal\nq : HasQuotient.Quotient G H\n⊢ Eq (↑(⋯.leftQuotientEquiv q)) (HSMul.hSMul f ↑(⋯.leftQuotientEquiv (HSMul.hSMul (Inv.inv f) q)))","decl":"@[to_additive]\ntheorem smul_apply_eq_smul_apply_inv_smul (f : F) (S : H.LeftTransversal) (q : G ⧸ H) :\n    ((f • S).2.leftQuotientEquiv q : G) = f • (S.2.leftQuotientEquiv (f⁻¹ • q) : G) := by\n  rw [smul_leftQuotientEquiv, smul_inv_smul]\n\n"}
{"name":"AddSubgroup.vadd_apply_eq_vadd_apply_neg_vadd","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝³ : AddGroup G\nH : AddSubgroup G\nF : Type u_2\ninst✝² : AddGroup F\ninst✝¹ : AddAction F G\ninst✝ : AddAction.QuotientAction F H\nf : F\nS : H.LeftTransversal\nq : HasQuotient.Quotient G H\n⊢ Eq (↑(⋯.leftQuotientEquiv q)) (HVAdd.hVAdd f ↑(⋯.leftQuotientEquiv (HVAdd.hVAdd (Neg.neg f) q)))","decl":"@[to_additive]\ntheorem smul_apply_eq_smul_apply_inv_smul (f : F) (S : H.LeftTransversal) (q : G ⧸ H) :\n    ((f • S).2.leftQuotientEquiv q : G) = f • (S.2.leftQuotientEquiv (f⁻¹ • q) : G) := by\n  rw [smul_leftQuotientEquiv, smul_inv_smul]\n\n"}
{"name":"Subgroup.IsComplement'.isCompl","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝ : Group G\nH K : Subgroup G\nh : H.IsComplement' K\n⊢ IsCompl H K","decl":"theorem IsComplement'.isCompl (h : IsComplement' H K) : IsCompl H K := by\n  refine\n    ⟨disjoint_iff_inf_le.mpr fun g ⟨p, q⟩ =>\n        let x : H × K := ⟨⟨g, p⟩, 1⟩\n        let y : H × K := ⟨1, g, q⟩\n        Subtype.ext_iff.mp\n          (Prod.ext_iff.mp (show x = y from h.1 ((mul_one g).trans (one_mul g).symm))).1,\n      codisjoint_iff_le_sup.mpr fun g _ => ?_⟩\n  obtain ⟨⟨h, k⟩, rfl⟩ := h.2 g\n  exact Subgroup.mul_mem_sup h.2 k.2\n\n"}
{"name":"Subgroup.IsComplement'.sup_eq_top","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝ : Group G\nH K : Subgroup G\nh : H.IsComplement' K\n⊢ Eq (Max.max H K) Top.top","decl":"theorem IsComplement'.sup_eq_top (h : IsComplement' H K) : H ⊔ K = ⊤ :=\n  h.isCompl.sup_eq_top\n\n"}
{"name":"Subgroup.IsComplement'.disjoint","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝ : Group G\nH K : Subgroup G\nh : H.IsComplement' K\n⊢ Disjoint H K","decl":"theorem IsComplement'.disjoint (h : IsComplement' H K) : Disjoint H K :=\n  h.isCompl.disjoint\n\n"}
{"name":"Subgroup.IsComplement'.index_eq_card","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝ : Group G\nH K : Subgroup G\nh : H.IsComplement' K\n⊢ Eq K.index (Nat.card (Subtype fun x => Membership.mem H x))","decl":"theorem IsComplement'.index_eq_card (h : IsComplement' H K) : K.index = Nat.card H :=\n  h.card_left.symm\n\n"}
{"name":"Subgroup.IsComplement'.QuotientMulEquiv_apply","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nH K : Subgroup G\ninst✝ : K.Normal\nh : H.IsComplement' K\na✝ : HasQuotient.Quotient G K\n⊢ Eq (h.QuotientMulEquiv a✝) ((Subgroup.IsComplement.leftQuotientEquiv h) a✝)","decl":"/-- If `H` and `K` are complementary with `K` normal, then `G ⧸ K` is isomorphic to `H`. -/\n@[simps!]\nnoncomputable def IsComplement'.QuotientMulEquiv [K.Normal] (h : H.IsComplement' K) :\n    G ⧸ K ≃* H :=\n  MulEquiv.symm\n  { h.leftQuotientEquiv.symm with\n    map_mul' := fun _ _ ↦ rfl }\n\n"}
{"name":"Subgroup.IsComplement'.QuotientMulEquiv_symm_apply","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nH K : Subgroup G\ninst✝ : K.Normal\nh : H.IsComplement' K\na✝ : Subtype fun x => Membership.mem H x\n⊢ Eq (h.QuotientMulEquiv.symm a✝) ((Subgroup.IsComplement.leftQuotientEquiv h).symm a✝)","decl":"/-- If `H` and `K` are complementary with `K` normal, then `G ⧸ K` is isomorphic to `H`. -/\n@[simps!]\nnoncomputable def IsComplement'.QuotientMulEquiv [K.Normal] (h : H.IsComplement' K) :\n    G ⧸ K ≃* H :=\n  MulEquiv.symm\n  { h.leftQuotientEquiv.symm with\n    map_mul' := fun _ _ ↦ rfl }\n\n"}
{"name":"Subgroup.IsComplement.card_mul","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝ : Group G\nS T : Set G\nh : Subgroup.IsComplement S T\n⊢ Eq (HMul.hMul (Nat.card ↑S) (Nat.card ↑T)) (Nat.card G)","decl":"theorem IsComplement.card_mul (h : IsComplement S T) :\n    Nat.card S * Nat.card T = Nat.card G :=\n  (Nat.card_prod _ _).symm.trans (Nat.card_eq_of_bijective _ h)\n\n"}
{"name":"Subgroup.IsComplement'.card_mul","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝ : Group G\nH K : Subgroup G\nh : H.IsComplement' K\n⊢ Eq (HMul.hMul (Nat.card (Subtype fun x => Membership.mem H x)) (Nat.card (Subtype fun x => Membership.mem K x))) (Nat.card G)","decl":"theorem IsComplement'.card_mul (h : IsComplement' H K) :\n    Nat.card H * Nat.card K = Nat.card G :=\n  IsComplement.card_mul h\n\n"}
{"name":"Subgroup.isComplement'_of_disjoint_and_mul_eq_univ","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝ : Group G\nH K : Subgroup G\nh1 : Disjoint H K\nh2 : Eq (HMul.hMul ↑H ↑K) Set.univ\n⊢ H.IsComplement' K","decl":"theorem isComplement'_of_disjoint_and_mul_eq_univ (h1 : Disjoint H K)\n    (h2 : ↑H * ↑K = (Set.univ : Set G)) : IsComplement' H K := by\n  refine ⟨mul_injective_of_disjoint h1, fun g => ?_⟩\n  obtain ⟨h, hh, k, hk, hg⟩ := Set.eq_univ_iff_forall.mp h2 g\n  exact ⟨(⟨h, hh⟩, ⟨k, hk⟩), hg⟩\n\n"}
{"name":"Subgroup.isComplement'_of_card_mul_and_disjoint","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nH K : Subgroup G\ninst✝ : Finite G\nh1 : Eq (HMul.hMul (Nat.card (Subtype fun x => Membership.mem H x)) (Nat.card (Subtype fun x => Membership.mem K x))) (Nat.card G)\nh2 : Disjoint H K\n⊢ H.IsComplement' K","decl":"theorem isComplement'_of_card_mul_and_disjoint [Finite G]\n    (h1 : Nat.card H * Nat.card K = Nat.card G) (h2 : Disjoint H K) :\n    IsComplement' H K :=\n  (Nat.bijective_iff_injective_and_card _).mpr\n    ⟨mul_injective_of_disjoint h2, (Nat.card_prod H K).trans h1⟩\n\n"}
{"name":"Subgroup.isComplement'_iff_card_mul_and_disjoint","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nH K : Subgroup G\ninst✝ : Finite G\n⊢ Iff (H.IsComplement' K) (And (Eq (HMul.hMul (Nat.card (Subtype fun x => Membership.mem H x)) (Nat.card (Subtype fun x => Membership.mem K x))) (Nat.card G)) (Disjoint H K))","decl":"theorem isComplement'_iff_card_mul_and_disjoint [Finite G] :\n    IsComplement' H K ↔ Nat.card H * Nat.card K = Nat.card G ∧ Disjoint H K :=\n  ⟨fun h => ⟨h.card_mul, h.disjoint⟩, fun h => isComplement'_of_card_mul_and_disjoint h.1 h.2⟩\n\n"}
{"name":"Subgroup.isComplement'_of_coprime","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nH K : Subgroup G\ninst✝ : Finite G\nh1 : Eq (HMul.hMul (Nat.card (Subtype fun x => Membership.mem H x)) (Nat.card (Subtype fun x => Membership.mem K x))) (Nat.card G)\nh2 : (Nat.card (Subtype fun x => Membership.mem H x)).Coprime (Nat.card (Subtype fun x => Membership.mem K x))\n⊢ H.IsComplement' K","decl":"theorem isComplement'_of_coprime [Finite G]\n    (h1 : Nat.card H * Nat.card K = Nat.card G)\n    (h2 : Nat.Coprime (Nat.card H) (Nat.card K)) : IsComplement' H K :=\n  isComplement'_of_card_mul_and_disjoint h1 (disjoint_iff.mpr (inf_eq_bot_of_coprime h2))\n\n"}
{"name":"Subgroup.isComplement'_stabilizer","module":"Mathlib.GroupTheory.Complement","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nH : Subgroup G\nα : Type u_2\ninst✝ : MulAction G α\na : α\nh1 : ∀ (h : Subtype fun x => Membership.mem H x), Eq (HSMul.hSMul h a) a → Eq h 1\nh2 : ∀ (g : G), Exists fun h => Eq (HSMul.hSMul h (HSMul.hSMul g a)) a\n⊢ H.IsComplement' (MulAction.stabilizer G a)","decl":"theorem isComplement'_stabilizer {α : Type*} [MulAction G α] (a : α)\n    (h1 : ∀ h : H, h • a = a → h = 1) (h2 : ∀ g : G, ∃ h : H, h • g • a = a) :\n    IsComplement' H (MulAction.stabilizer G a) := by\n  refine isComplement_iff_existsUnique.mpr fun g => ?_\n  obtain ⟨h, hh⟩ := h2 g\n  have hh' : (↑h * g) • a = a := by rwa [mul_smul]\n  refine ⟨⟨h⁻¹, h * g, hh'⟩, inv_mul_cancel_left ↑h g, ?_⟩\n  rintro ⟨h', g, hg : g • a = a⟩ rfl\n  specialize h1 (h * h') (by rwa [mul_smul, smul_def h', ← hg, ← mul_smul, hg])\n  refine Prod.ext (eq_inv_of_mul_eq_one_right h1) (Subtype.ext ?_)\n  rwa [Subtype.ext_iff, coe_one, coe_mul, ← self_eq_mul_left, mul_assoc (↑h) (↑h') g] at h1\n\n"}
