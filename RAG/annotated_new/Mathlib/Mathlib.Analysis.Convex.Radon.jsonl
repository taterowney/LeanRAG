{"name":"Convex.radon_partition","module":"Mathlib.Analysis.Convex.Radon","initialProofState":"Î¹ : Type u_1\nğ•œ : Type u_2\nE : Type u_3\ninstâœÂ² : LinearOrderedField ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module ğ•œ E\nf : Î¹ â†’ E\nh : Not (AffineIndependent ğ•œ f)\nâŠ¢ Exists fun I => (Inter.inter ((convexHull ğ•œ) (Set.image f I)) ((convexHull ğ•œ) (Set.image f (HasCompl.compl I)))).Nonempty","decl":"/-- **Radon's theorem on convex sets**.\n\nAny family `f` of affine dependent vectors contains a set `I` with the property that convex hulls of\n`I` and `Iá¶œ` intersect nontrivially. -/\ntheorem radon_partition {f : Î¹ â†’ E} (h : Â¬ AffineIndependent ğ•œ f) :\n    âˆƒ I, (convexHull ğ•œ (f '' I) âˆ© convexHull ğ•œ (f '' Iá¶œ)).Nonempty := by\n  rw [affineIndependent_iff] at h\n  push_neg at h\n  obtain âŸ¨s, w, h_wsum, h_vsum, nonzero_w_index, h1, h2âŸ© := h\n  let I : Finset Î¹ := {i âˆˆ s | 0 â‰¤ w i}\n  let J : Finset Î¹ := {i âˆˆ s | w i < 0}\n  let p : E := centerMass I w f -- point of intersection\n  have hJI : âˆ‘ j âˆˆ J, w j + âˆ‘ i âˆˆ I, w i = 0 := by\n    simpa only [h_wsum, not_lt] using sum_filter_add_sum_filter_not s (fun i â†¦ w i < 0) w\n  have hI : 0 < âˆ‘ i âˆˆ I, w i := by\n    rcases exists_pos_of_sum_zero_of_exists_nonzero _ h_wsum âŸ¨nonzero_w_index, h1, h2âŸ©\n      with âŸ¨pos_w_index, h1', h2'âŸ©\n    exact sum_pos' (fun _i hi â†¦ (mem_filter.1 hi).2)\n      âŸ¨pos_w_index, by simp only [I, mem_filter, h1', h2'.le, and_self, h2']âŸ©\n  have hp : centerMass J w f = p := centerMass_of_sum_add_sum_eq_zero hJI <| by\n    simpa only [â† h_vsum, not_lt] using sum_filter_add_sum_filter_not s (fun i â†¦ w i < 0) _\n  refine âŸ¨I, p, ?_, ?_âŸ©\n  Â· exact centerMass_mem_convexHull _ (fun _i hi â†¦ (mem_filter.mp hi).2) hI\n      (fun _i hi â†¦ mem_image_of_mem _ hi)\n  rw [â† hp]\n  refine centerMass_mem_convexHull_of_nonpos _ (fun _ hi â†¦ (mem_filter.mp hi).2.le) ?_\n    (fun _i hi â†¦ mem_image_of_mem _ fun hi' â†¦ ?_)\n  Â· linarith only [hI, hJI]\n  Â· exact (mem_filter.mp hi').2.not_lt (mem_filter.mp hi).2\n\n"}
{"name":"Convex.helly_theorem'","module":"Mathlib.Analysis.Convex.Radon","initialProofState":"Î¹ : Type u_1\nğ•œ : Type u_2\nE : Type u_3\ninstâœÂ³ : LinearOrderedField ğ•œ\ninstâœÂ² : AddCommGroup E\ninstâœÂ¹ : Module ğ•œ E\ninstâœ : FiniteDimensional ğ•œ E\nF : Î¹ â†’ Set E\ns : Finset Î¹\nh_convex : âˆ€ (i : Î¹), Membership.mem s i â†’ Convex ğ•œ (F i)\nh_inter : âˆ€ (I : Finset Î¹), HasSubset.Subset I s â†’ LE.le I.card (HAdd.hAdd (Module.finrank ğ•œ E) 1) â†’ (Set.iInter fun i => Set.iInter fun h => F i).Nonempty\nâŠ¢ (Set.iInter fun i => Set.iInter fun h => F i).Nonempty","decl":"/-- **Helly's theorem** for finite families of convex sets.\n\nIf `F` is a finite family of convex sets in a vector space of finite dimension `d`, and any\n`k â‰¤ d + 1` sets of `F` intersect nontrivially, then all sets of `F` intersect nontrivially. -/\ntheorem helly_theorem' {F : Î¹ â†’ Set E} {s : Finset Î¹}\n    (h_convex : âˆ€ i âˆˆ s, Convex ğ•œ (F i))\n    (h_inter : âˆ€ I âŠ† s, #I â‰¤ finrank ğ•œ E + 1 â†’ (â‹‚ i âˆˆ I, F i).Nonempty) :\n    (â‹‚ i âˆˆ s, F i).Nonempty := by\n  classical\n  obtain h_card | h_card := lt_or_le #s (finrank ğ•œ E + 1)\n  Â· exact helly_theorem_corner (le_of_lt h_card) h_inter\n  generalize hn : #s = n\n  rw [hn] at h_card\n  induction' n, h_card using Nat.le_induction with k h_card hk generalizing Î¹\n  Â· exact helly_theorem_corner (le_of_eq hn) h_inter\n  /- Construct a family of vectors indexed by `Î¹` such that the vector corresponding to `i : Î¹`\n  is an arbitrary element of the intersection of all `F j` except `F i`. -/\n  let a (i : s) : E := Set.Nonempty.some (s := â‹‚ j âˆˆ s.erase i, F j) <| by\n    apply hk (s := s.erase i)\n    Â· exact fun i hi â†¦ h_convex i (mem_of_mem_erase hi)\n    Â· intro J hJ_ss hJ_card\n      exact h_inter J (subset_trans hJ_ss (erase_subset i.val s)) hJ_card\n    Â· simp only [coe_mem, card_erase_of_mem]; omega\n  /- This family of vectors is not affine independent because the number of them exceeds the\n  dimension of the space. -/\n  have h_ind : Â¬AffineIndependent ğ•œ a := by\n    rw [â† finrank_vectorSpan_le_iff_not_affineIndependent ğ•œ a (n := (k - 1))]\n    Â· exact (Submodule.finrank_le (vectorSpan ğ•œ (range a))).trans (Nat.le_pred_of_lt h_card)\n    Â· simp only [card_coe]; omega\n  /- Use `radon_partition` to conclude there is a subset `I` of `s` and a point `p : E` which\n  lies in the convex hull of either `a '' I` or `a '' Iá¶œ`. We claim that `p âˆˆ â‹‚ i âˆˆ s, F i`. -/\n  obtain âŸ¨I, p, hp_I, hp_IcâŸ© := radon_partition h_ind\n  use p\n  apply mem_biInter\n  intro i hi\n  let i : s := âŸ¨i, hiâŸ©\n  /- It suffices to show that for any subcollection `J` of `s` containing `i`, the convex\n  hull of `a '' (s \\ J)` is contained in `F i`. -/\n  suffices âˆ€ J : Set s, (i âˆˆ J) â†’ (convexHull ğ•œ) (a '' Já¶œ) âŠ† F i by\n    by_cases h : i âˆˆ I\n    Â· exact this I h hp_Ic\n    Â· apply this Iá¶œ h; rwa [compl_compl]\n  /- Given any subcollection `J` of `Î¹` containing `i`, because `F i` is convex, we need only\n  show that `a j âˆˆ F i` for each `j âˆˆ s \\ J`. -/\n  intro J hi\n  rw [convexHull_subset_iff (h_convex i.1 i.2)]\n  rintro v âŸ¨j, hj, hj_vâŸ©\n  rw [â† hj_v]\n  /- Since `j âˆˆ Já¶œ` and `i âˆˆ J`, we conclude that `i â‰  j`, and hence by the definition of `a`:\n  `a j âˆˆ â‹‚ F '' (Set.univ \\ {j}) âŠ† F i`. -/\n  apply mem_of_subset_of_mem (sâ‚ := â‹‚ k âˆˆ (s.erase j), F k)\n  Â· apply biInter_subset_of_mem\n    simp only [erase_val]\n    suffices h : i.val âˆˆ s.erase j by assumption\n    simp only [mem_erase]\n    constructor\n    Â· exact fun h' â†¦ hj ((show i = j from SetCoe.ext h') â–¸ hi)\n    Â· assumption\n  Â· apply Nonempty.some_mem\n\n"}
{"name":"Convex.helly_theorem","module":"Mathlib.Analysis.Convex.Radon","initialProofState":"Î¹ : Type u_1\nğ•œ : Type u_2\nE : Type u_3\ninstâœÂ³ : LinearOrderedField ğ•œ\ninstâœÂ² : AddCommGroup E\ninstâœÂ¹ : Module ğ•œ E\ninstâœ : FiniteDimensional ğ•œ E\nF : Î¹ â†’ Set E\ns : Finset Î¹\nh_card : LE.le (HAdd.hAdd (Module.finrank ğ•œ E) 1) s.card\nh_convex : âˆ€ (i : Î¹), Membership.mem s i â†’ Convex ğ•œ (F i)\nh_inter : âˆ€ (I : Finset Î¹), HasSubset.Subset I s â†’ Eq I.card (HAdd.hAdd (Module.finrank ğ•œ E) 1) â†’ (Set.iInter fun i => Set.iInter fun h => F i).Nonempty\nâŠ¢ (Set.iInter fun i => Set.iInter fun h => F i).Nonempty","decl":"/-- **Helly's theorem** for finite families of convex sets in its classical form.\n\nIf `F` is a family of `n` convex sets in a vector space of finite dimension `d`, with `n â‰¥ d + 1`,\nand any `d + 1` sets of `F` intersect nontrivially, then all sets of `F` intersect nontrivially. -/\ntheorem helly_theorem {F : Î¹ â†’ Set E} {s : Finset Î¹}\n    (h_card : finrank ğ•œ E + 1 â‰¤ #s)\n    (h_convex : âˆ€ i âˆˆ s, Convex ğ•œ (F i))\n    (h_inter : âˆ€ I âŠ† s, #I = finrank ğ•œ E + 1 â†’ (â‹‚ i âˆˆ I, F i).Nonempty) :\n    (â‹‚ i âˆˆ s, F i).Nonempty := by\n  apply helly_theorem' h_convex\n  intro I hI_ss hI_card\n  obtain âŸ¨J, hI_ss_J, hJ_ss, hJ_cardâŸ© := exists_subsuperset_card_eq hI_ss hI_card h_card\n  apply Set.Nonempty.mono <| biInter_mono hI_ss_J (fun _ _ â†¦ Set.Subset.rfl)\n  exact h_inter J hJ_ss hJ_card\n\n"}
{"name":"Convex.helly_theorem_set'","module":"Mathlib.Analysis.Convex.Radon","initialProofState":"ğ•œ : Type u_2\nE : Type u_3\ninstâœÂ³ : LinearOrderedField ğ•œ\ninstâœÂ² : AddCommGroup E\ninstâœÂ¹ : Module ğ•œ E\ninstâœ : FiniteDimensional ğ•œ E\nF : Finset (Set E)\nh_convex : âˆ€ (X : Set E), Membership.mem F X â†’ Convex ğ•œ X\nh_inter : âˆ€ (G : Finset (Set E)), HasSubset.Subset G F â†’ LE.le G.card (HAdd.hAdd (Module.finrank ğ•œ E) 1) â†’ (â†‘G).sInter.Nonempty\nâŠ¢ (â†‘F).sInter.Nonempty","decl":"/-- **Helly's theorem** for finite sets of convex sets.\n\nIf `F` is a finite set of convex sets in a vector space of finite dimension `d`, and any `k â‰¤ d + 1`\nsets from `F` intersect nontrivially, then all sets from `F` intersect nontrivially. -/\ntheorem helly_theorem_set' {F : Finset (Set E)}\n    (h_convex : âˆ€ X âˆˆ F, Convex ğ•œ X)\n    (h_inter : âˆ€ G : Finset (Set E), G âŠ† F â†’ #G â‰¤ finrank ğ•œ E + 1 â†’ (â‹‚â‚€ G : Set E).Nonempty) :\n    (â‹‚â‚€ (F : Set (Set E))).Nonempty := by\n  classical -- for DecidableEq, required for the family version\n  rw [show â‹‚â‚€ F = â‹‚ X âˆˆ F, (X : Set E) by ext; simp]\n  apply helly_theorem' h_convex\n  intro G hG_ss hG_card\n  rw [show â‹‚ X âˆˆ G, X = â‹‚â‚€ G by ext; simp]\n  exact h_inter G hG_ss hG_card\n\n"}
{"name":"Convex.helly_theorem_set","module":"Mathlib.Analysis.Convex.Radon","initialProofState":"ğ•œ : Type u_2\nE : Type u_3\ninstâœÂ³ : LinearOrderedField ğ•œ\ninstâœÂ² : AddCommGroup E\ninstâœÂ¹ : Module ğ•œ E\ninstâœ : FiniteDimensional ğ•œ E\nF : Finset (Set E)\nh_card : LE.le (HAdd.hAdd (Module.finrank ğ•œ E) 1) F.card\nh_convex : âˆ€ (X : Set E), Membership.mem F X â†’ Convex ğ•œ X\nh_inter : âˆ€ (G : Finset (Set E)), HasSubset.Subset G F â†’ Eq G.card (HAdd.hAdd (Module.finrank ğ•œ E) 1) â†’ (â†‘G).sInter.Nonempty\nâŠ¢ (â†‘F).sInter.Nonempty","decl":"/-- **Helly's theorem** for finite sets of convex sets in its classical form.\n\nIf `F` is a finite set of convex sets in a vector space of finite dimension `d`, with `n â‰¥ d + 1`,\nand any `d + 1` sets from `F` intersect nontrivially,\nthen all sets from `F` intersect nontrivially. -/\ntheorem helly_theorem_set {F : Finset (Set E)}\n    (h_card : finrank ğ•œ E + 1 â‰¤ #F)\n    (h_convex : âˆ€ X âˆˆ F, Convex ğ•œ X)\n    (h_inter : âˆ€ G : Finset (Set E), G âŠ† F â†’ #G = finrank ğ•œ E + 1 â†’ (â‹‚â‚€ G : Set E).Nonempty) :\n    (â‹‚â‚€ (F : Set (Set E))).Nonempty := by\n  apply helly_theorem_set' h_convex\n  intro I hI_ss hI_card\n  obtain âŸ¨J, _, hJ_ss, hJ_cardâŸ© := exists_subsuperset_card_eq hI_ss hI_card h_card\n  have : â‹‚â‚€ (J : Set (Set E)) âŠ† â‹‚â‚€ I := sInter_mono (by simpa [hI_ss])\n  apply Set.Nonempty.mono this\n  exact h_inter J hJ_ss (by omega)\n\n"}
{"name":"Convex.helly_theorem_compact'","module":"Mathlib.Analysis.Convex.Radon","initialProofState":"Î¹ : Type u_1\nğ•œ : Type u_2\nE : Type u_3\ninstâœâµ : LinearOrderedField ğ•œ\ninstâœâ´ : AddCommGroup E\ninstâœÂ³ : Module ğ•œ E\ninstâœÂ² : FiniteDimensional ğ•œ E\ninstâœÂ¹ : TopologicalSpace E\ninstâœ : T2Space E\nF : Î¹ â†’ Set E\nh_convex : âˆ€ (i : Î¹), Convex ğ•œ (F i)\nh_compact : âˆ€ (i : Î¹), IsCompact (F i)\nh_inter : âˆ€ (I : Finset Î¹), LE.le I.card (HAdd.hAdd (Module.finrank ğ•œ E) 1) â†’ (Set.iInter fun i => Set.iInter fun h => F i).Nonempty\nâŠ¢ (Set.iInter fun i => F i).Nonempty","decl":"/-- **Helly's theorem** for families of compact convex sets.\n\nIf `F` is a family of compact convex sets in a vector space of finite dimension `d`, and any\n`k â‰¤ d + 1` sets of `F` intersect nontrivially, then all sets of `F` intersect nontrivially. -/\ntheorem helly_theorem_compact' [TopologicalSpace E] [T2Space E] {F : Î¹ â†’ Set E}\n    (h_convex : âˆ€ i, Convex ğ•œ (F i)) (h_compact : âˆ€ i, IsCompact (F i))\n    (h_inter : âˆ€ I : Finset Î¹, #I â‰¤ finrank ğ•œ E + 1 â†’ (â‹‚ i âˆˆ I, F i).Nonempty) :\n    (â‹‚ i, F i).Nonempty := by\n  classical\n  /- If `Î¹` is empty the statement is trivial. -/\n  cases' isEmpty_or_nonempty Î¹ with _ h_nonempty\n  Â· simp only [iInter_of_empty, Set.univ_nonempty]\n  /- By the finite version of theorem, every finite subfamily has an intersection. -/\n  have h_fin (I : Finset Î¹) : (â‹‚ i âˆˆ I, F i).Nonempty := by\n    apply helly_theorem' (s := I) (ğ•œ := ğ•œ) (by simp [h_convex])\n    exact fun J _ hJ_card â†¦ h_inter J hJ_card\n  /- The following is a clumsy proof that family of compact sets with the finite intersection\n  property has a nonempty intersection. -/\n  have i0 : Î¹ := Nonempty.some h_nonempty\n  rw [show â‹‚ i, F i = (F i0) âˆ© â‹‚ i, F i by simp [iInter_subset]]\n  apply IsCompact.inter_iInter_nonempty\n  Â· exact h_compact i0\n  Â· intro i\n    exact (h_compact i).isClosed\n  Â· intro I\n    simpa using h_fin ({i0} âˆª I)\n\n"}
{"name":"Convex.helly_theorem_compact","module":"Mathlib.Analysis.Convex.Radon","initialProofState":"Î¹ : Type u_1\nğ•œ : Type u_2\nE : Type u_3\ninstâœâµ : LinearOrderedField ğ•œ\ninstâœâ´ : AddCommGroup E\ninstâœÂ³ : Module ğ•œ E\ninstâœÂ² : FiniteDimensional ğ•œ E\ninstâœÂ¹ : TopologicalSpace E\ninstâœ : T2Space E\nF : Î¹ â†’ Set E\nh_card : LE.le (HAdd.hAdd (â†‘(Module.finrank ğ•œ E)) 1) (ENat.card Î¹)\nh_convex : âˆ€ (i : Î¹), Convex ğ•œ (F i)\nh_compact : âˆ€ (i : Î¹), IsCompact (F i)\nh_inter : âˆ€ (I : Finset Î¹), Eq I.card (HAdd.hAdd (Module.finrank ğ•œ E) 1) â†’ (Set.iInter fun i => Set.iInter fun h => F i).Nonempty\nâŠ¢ (Set.iInter fun i => F i).Nonempty","decl":"/-- **Helly's theorem** for families of compact convex sets in its classical form.\n\nIf `F` is a (possibly infinite) family of more than `d + 1` compact convex sets in a vector space of\nfinite dimension `d`, and any `d + 1` sets of `F` intersect nontrivially,\nthen all sets of `F` intersect nontrivially. -/\ntheorem helly_theorem_compact [TopologicalSpace E] [T2Space E] {F : Î¹ â†’ Set E}\n    (h_card : finrank ğ•œ E + 1 â‰¤ ENat.card Î¹)\n    (h_convex : âˆ€ i, Convex ğ•œ (F i)) (h_compact : âˆ€ i, IsCompact (F i))\n    (h_inter : âˆ€ I : Finset Î¹, #I = finrank ğ•œ E + 1 â†’ (â‹‚ i âˆˆ I, F i).Nonempty) :\n    (â‹‚ i, F i).Nonempty := by\n  apply helly_theorem_compact' h_convex h_compact\n  intro I hI_card\n  have hJ : âˆƒ J : Finset Î¹, I âŠ† J âˆ§ #J = finrank ğ•œ E + 1 := by\n    by_cases h : Infinite Î¹\n    Â· exact Infinite.exists_superset_card_eq _ _ hI_card\n    Â· have : Finite Î¹ := Finite.of_not_infinite h\n      have : Fintype Î¹ := Fintype.ofFinite Î¹\n      apply exists_superset_card_eq hI_card\n      simp only [ENat.card_eq_coe_fintype_card] at h_card\n      rwa [â† Nat.cast_one, â† Nat.cast_add, Nat.cast_le] at h_card\n  obtain âŸ¨J, hJ_ss, hJ_cardâŸ© := hJ\n  apply Set.Nonempty.mono <| biInter_mono hJ_ss (by intro _ _; rfl)\n  exact h_inter J hJ_card\n\n"}
{"name":"Convex.helly_theorem_set_compact'","module":"Mathlib.Analysis.Convex.Radon","initialProofState":"ğ•œ : Type u_2\nE : Type u_3\ninstâœâµ : LinearOrderedField ğ•œ\ninstâœâ´ : AddCommGroup E\ninstâœÂ³ : Module ğ•œ E\ninstâœÂ² : FiniteDimensional ğ•œ E\ninstâœÂ¹ : TopologicalSpace E\ninstâœ : T2Space E\nF : Set (Set E)\nh_convex : âˆ€ (X : Set E), Membership.mem F X â†’ Convex ğ•œ X\nh_compact : âˆ€ (X : Set E), Membership.mem F X â†’ IsCompact X\nh_inter : âˆ€ (G : Finset (Set E)), HasSubset.Subset (â†‘G) F â†’ LE.le G.card (HAdd.hAdd (Module.finrank ğ•œ E) 1) â†’ (â†‘G).sInter.Nonempty\nâŠ¢ F.sInter.Nonempty","decl":"/-- **Helly's theorem** for sets of compact convex sets.\n\nIf `F` is a set of compact convex sets in a vector space of finite dimension `d`, and any\n`k â‰¤ d + 1` sets from `F` intersect nontrivially, then all sets from `F` intersect nontrivially. -/\ntheorem helly_theorem_set_compact' [TopologicalSpace E] [T2Space E] {F : Set (Set E)}\n    (h_convex : âˆ€ X âˆˆ F, Convex ğ•œ X) (h_compact : âˆ€ X âˆˆ F, IsCompact X)\n    (h_inter : âˆ€ G : Finset (Set E), (G : Set (Set E)) âŠ† F â†’ #G â‰¤ finrank ğ•œ E + 1 â†’\n    (â‹‚â‚€ G : Set E).Nonempty) :\n    (â‹‚â‚€ (F : Set (Set E))).Nonempty := by\n  classical -- for DecidableEq, required for the family version\n  rw [show â‹‚â‚€ F = â‹‚ X : F, (X : Set E) by ext; simp]\n  refine helly_theorem_compact' (F := fun x : F â†¦ x.val)\n    (fun X â†¦ h_convex X (by simp)) (fun X â†¦ h_compact X (by simp)) ?_\n  intro G _\n  let G' : Finset (Set E) := image Subtype.val G\n  rw [show â‹‚ i âˆˆ G, â†‘i = â‹‚â‚€ (G' : Set (Set E)) by simp [G']]\n  apply h_inter G'\n  Â· simp [G']\n  Â· apply le_trans card_image_le\n    assumption\n\n"}
{"name":"Convex.helly_theorem_set_compact","module":"Mathlib.Analysis.Convex.Radon","initialProofState":"ğ•œ : Type u_2\nE : Type u_3\ninstâœâµ : LinearOrderedField ğ•œ\ninstâœâ´ : AddCommGroup E\ninstâœÂ³ : Module ğ•œ E\ninstâœÂ² : FiniteDimensional ğ•œ E\ninstâœÂ¹ : TopologicalSpace E\ninstâœ : T2Space E\nF : Set (Set E)\nh_card : LE.le (HAdd.hAdd (â†‘(Module.finrank ğ•œ E)) 1) F.encard\nh_convex : âˆ€ (X : Set E), Membership.mem F X â†’ Convex ğ•œ X\nh_compact : âˆ€ (X : Set E), Membership.mem F X â†’ IsCompact X\nh_inter : âˆ€ (G : Finset (Set E)), HasSubset.Subset (â†‘G) F â†’ Eq G.card (HAdd.hAdd (Module.finrank ğ•œ E) 1) â†’ (â†‘G).sInter.Nonempty\nâŠ¢ F.sInter.Nonempty","decl":"/-- **Helly's theorem** for sets of compact convex sets in its classical version.\n\nIf `F` is a (possibly infinite) set of more than `d + 1` compact convex sets in a vector space of\nfinite dimension `d`, and any `d + 1` sets from `F` intersect nontrivially,\nthen all sets from `F` intersect nontrivially. -/\ntheorem helly_theorem_set_compact [TopologicalSpace E] [T2Space E] {F : Set (Set E)}\n    (h_card : finrank ğ•œ E + 1 â‰¤ F.encard)\n    (h_convex : âˆ€ X âˆˆ F, Convex ğ•œ X) (h_compact : âˆ€ X âˆˆ F, IsCompact X)\n    (h_inter : âˆ€ G : Finset (Set E), (G : Set (Set E)) âŠ† F â†’ #G = finrank ğ•œ E + 1 â†’\n    (â‹‚â‚€ G : Set E).Nonempty) :\n    (â‹‚â‚€ (F : Set (Set E))).Nonempty := by\n  apply helly_theorem_set_compact' h_convex h_compact\n  intro I hI_ss hI_card\n  obtain âŸ¨J, _, hJ_ss, hJ_cardâŸ© := exists_superset_subset_encard_eq hI_ss (hkt := h_card)\n    (by simpa only [encard_coe_eq_coe_finsetCard, â† ENat.coe_one, â† ENat.coe_add, Nat.cast_le])\n  apply Set.Nonempty.mono <| sInter_mono (by simpa [hI_ss])\n  have hJ_fin : Fintype J := Finite.fintype <| finite_of_encard_eq_coe hJ_card\n  let J' := J.toFinset\n  rw [â† coe_toFinset J]\n  apply h_inter J'\n  Â· simpa [J']\n  Â· rwa [encard_eq_coe_toFinset_card J, â† ENat.coe_one, â† ENat.coe_add, Nat.cast_inj] at hJ_card\n\n"}
