{"name":"WithTop.iInf_empty","module":"Mathlib.Order.ConditionallyCompleteLattice.Indexed","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝² : Preorder α\ninst✝¹ : IsEmpty ι\ninst✝ : InfSet α\nf : ι → WithTop α\n⊢ Eq (iInf fun i => f i) Top.top","decl":"@[simp]\ntheorem WithTop.iInf_empty [IsEmpty ι] [InfSet α] (f : ι → WithTop α) :\n    ⨅ i, f i = ⊤ := by rw [iInf, range_eq_empty, WithTop.sInf_empty]\n\n"}
{"name":"WithTop.coe_iInf","module":"Mathlib.Order.ConditionallyCompleteLattice.Indexed","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝² : Preorder α\ninst✝¹ : Nonempty ι\ninst✝ : InfSet α\nf : ι → α\nhf : BddBelow (Set.range f)\n⊢ Eq (↑(iInf fun i => f i)) (iInf fun i => ↑(f i))","decl":"@[norm_cast]\ntheorem WithTop.coe_iInf [Nonempty ι] [InfSet α] {f : ι → α} (hf : BddBelow (range f)) :\n    ↑(⨅ i, f i) = (⨅ i, f i : WithTop α) := by\n  rw [iInf, iInf, WithTop.coe_sInf' (range_nonempty f) hf, ← range_comp, Function.comp_def]\n\n"}
{"name":"WithTop.coe_iSup","module":"Mathlib.Order.ConditionallyCompleteLattice.Indexed","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝¹ : Preorder α\ninst✝ : SupSet α\nf : ι → α\nh : BddAbove (Set.range f)\n⊢ Eq (↑(iSup fun i => f i)) (iSup fun i => ↑(f i))","decl":"@[norm_cast]\ntheorem WithTop.coe_iSup [SupSet α] (f : ι → α) (h : BddAbove (Set.range f)) :\n    ↑(⨆ i, f i) = (⨆ i, f i : WithTop α) := by\n  rw [iSup, iSup, WithTop.coe_sSup' h, ← range_comp, Function.comp_def]\n\n"}
{"name":"WithBot.ciSup_empty","module":"Mathlib.Order.ConditionallyCompleteLattice.Indexed","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝² : Preorder α\ninst✝¹ : IsEmpty ι\ninst✝ : SupSet α\nf : ι → WithBot α\n⊢ Eq (iSup fun i => f i) Bot.bot","decl":"@[simp]\ntheorem WithBot.ciSup_empty [IsEmpty ι] [SupSet α] (f : ι → WithBot α) :\n    ⨆ i, f i = ⊥ :=\n  WithTop.iInf_empty (α := αᵒᵈ) _\n\n"}
{"name":"WithBot.coe_iSup","module":"Mathlib.Order.ConditionallyCompleteLattice.Indexed","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝² : Preorder α\ninst✝¹ : Nonempty ι\ninst✝ : SupSet α\nf : ι → α\nhf : BddAbove (Set.range f)\n⊢ Eq (↑(iSup fun i => f i)) (iSup fun i => ↑(f i))","decl":"@[norm_cast]\ntheorem WithBot.coe_iSup [Nonempty ι] [SupSet α] {f : ι → α} (hf : BddAbove (range f)) :\n    ↑(⨆ i, f i) = (⨆ i, f i : WithBot α) :=\n  WithTop.coe_iInf (α := αᵒᵈ) hf\n\n"}
{"name":"WithBot.coe_iInf","module":"Mathlib.Order.ConditionallyCompleteLattice.Indexed","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝¹ : Preorder α\ninst✝ : InfSet α\nf : ι → α\nh : BddBelow (Set.range f)\n⊢ Eq (↑(iInf fun i => f i)) (iInf fun i => ↑(f i))","decl":"@[norm_cast]\ntheorem WithBot.coe_iInf [InfSet α] (f : ι → α) (h : BddBelow (Set.range f)) :\n    ↑(⨅ i, f i) = (⨅ i, f i : WithBot α) :=\n  WithTop.coe_iSup (α := αᵒᵈ) _ h\n\n"}
{"name":"isLUB_ciSup","module":"Mathlib.Order.ConditionallyCompleteLattice.Indexed","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝¹ : ConditionallyCompleteLattice α\ninst✝ : Nonempty ι\nf : ι → α\nH : BddAbove (Set.range f)\n⊢ IsLUB (Set.range f) (iSup fun i => f i)","decl":"theorem isLUB_ciSup [Nonempty ι] {f : ι → α} (H : BddAbove (range f)) :\n    IsLUB (range f) (⨆ i, f i) :=\n  isLUB_csSup (range_nonempty f) H\n\n"}
{"name":"isLUB_ciSup_set","module":"Mathlib.Order.ConditionallyCompleteLattice.Indexed","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : ConditionallyCompleteLattice α\nf : β → α\ns : Set β\nH : BddAbove (Set.image f s)\nHne : s.Nonempty\n⊢ IsLUB (Set.image f s) (iSup fun i => f ↑i)","decl":"theorem isLUB_ciSup_set {f : β → α} {s : Set β} (H : BddAbove (f '' s)) (Hne : s.Nonempty) :\n    IsLUB (f '' s) (⨆ i : s, f i) := by\n  rw [← sSup_image']\n  exact isLUB_csSup (Hne.image _) H\n\n"}
{"name":"isGLB_ciInf","module":"Mathlib.Order.ConditionallyCompleteLattice.Indexed","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝¹ : ConditionallyCompleteLattice α\ninst✝ : Nonempty ι\nf : ι → α\nH : BddBelow (Set.range f)\n⊢ IsGLB (Set.range f) (iInf fun i => f i)","decl":"theorem isGLB_ciInf [Nonempty ι] {f : ι → α} (H : BddBelow (range f)) :\n    IsGLB (range f) (⨅ i, f i) :=\n  isGLB_csInf (range_nonempty f) H\n\n"}
{"name":"isGLB_ciInf_set","module":"Mathlib.Order.ConditionallyCompleteLattice.Indexed","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : ConditionallyCompleteLattice α\nf : β → α\ns : Set β\nH : BddBelow (Set.image f s)\nHne : s.Nonempty\n⊢ IsGLB (Set.image f s) (iInf fun i => f ↑i)","decl":"theorem isGLB_ciInf_set {f : β → α} {s : Set β} (H : BddBelow (f '' s)) (Hne : s.Nonempty) :\n    IsGLB (f '' s) (⨅ i : s, f i) :=\n  isLUB_ciSup_set (α := αᵒᵈ) H Hne\n\n"}
{"name":"ciSup_le_iff","module":"Mathlib.Order.ConditionallyCompleteLattice.Indexed","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝¹ : ConditionallyCompleteLattice α\ninst✝ : Nonempty ι\nf : ι → α\na : α\nhf : BddAbove (Set.range f)\n⊢ Iff (LE.le (iSup f) a) (∀ (i : ι), LE.le (f i) a)","decl":"theorem ciSup_le_iff [Nonempty ι] {f : ι → α} {a : α} (hf : BddAbove (range f)) :\n    iSup f ≤ a ↔ ∀ i, f i ≤ a :=\n  (isLUB_le_iff <| isLUB_ciSup hf).trans forall_mem_range\n\n"}
{"name":"le_ciInf_iff","module":"Mathlib.Order.ConditionallyCompleteLattice.Indexed","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝¹ : ConditionallyCompleteLattice α\ninst✝ : Nonempty ι\nf : ι → α\na : α\nhf : BddBelow (Set.range f)\n⊢ Iff (LE.le a (iInf f)) (∀ (i : ι), LE.le a (f i))","decl":"theorem le_ciInf_iff [Nonempty ι] {f : ι → α} {a : α} (hf : BddBelow (range f)) :\n    a ≤ iInf f ↔ ∀ i, a ≤ f i :=\n  (le_isGLB_iff <| isGLB_ciInf hf).trans forall_mem_range\n\n"}
{"name":"ciSup_set_le_iff","module":"Mathlib.Order.ConditionallyCompleteLattice.Indexed","initialProofState":"α : Type u_1\ninst✝ : ConditionallyCompleteLattice α\nι : Type u_5\ns : Set ι\nf : ι → α\na : α\nhs : s.Nonempty\nhf : BddAbove (Set.image f s)\n⊢ Iff (LE.le (iSup fun i => f ↑i) a) (∀ (i : ι), Membership.mem s i → LE.le (f i) a)","decl":"theorem ciSup_set_le_iff {ι : Type*} {s : Set ι} {f : ι → α} {a : α} (hs : s.Nonempty)\n    (hf : BddAbove (f '' s)) : ⨆ i : s, f i ≤ a ↔ ∀ i ∈ s, f i ≤ a :=\n  (isLUB_le_iff <| isLUB_ciSup_set hf hs).trans forall_mem_image\n\n"}
{"name":"le_ciInf_set_iff","module":"Mathlib.Order.ConditionallyCompleteLattice.Indexed","initialProofState":"α : Type u_1\ninst✝ : ConditionallyCompleteLattice α\nι : Type u_5\ns : Set ι\nf : ι → α\na : α\nhs : s.Nonempty\nhf : BddBelow (Set.image f s)\n⊢ Iff (LE.le a (iInf fun i => f ↑i)) (∀ (i : ι), Membership.mem s i → LE.le a (f i))","decl":"theorem le_ciInf_set_iff {ι : Type*} {s : Set ι} {f : ι → α} {a : α} (hs : s.Nonempty)\n    (hf : BddBelow (f '' s)) : (a ≤ ⨅ i : s, f i) ↔ ∀ i ∈ s, a ≤ f i :=\n  (le_isGLB_iff <| isGLB_ciInf_set hf hs).trans forall_mem_image\n\n"}
{"name":"IsLUB.ciSup_eq","module":"Mathlib.Order.ConditionallyCompleteLattice.Indexed","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝¹ : ConditionallyCompleteLattice α\na : α\ninst✝ : Nonempty ι\nf : ι → α\nH : IsLUB (Set.range f) a\n⊢ Eq (iSup fun i => f i) a","decl":"theorem IsLUB.ciSup_eq [Nonempty ι] {f : ι → α} (H : IsLUB (range f) a) : ⨆ i, f i = a :=\n  H.csSup_eq (range_nonempty f)\n\n"}
{"name":"IsLUB.ciSup_set_eq","module":"Mathlib.Order.ConditionallyCompleteLattice.Indexed","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : ConditionallyCompleteLattice α\na : α\ns : Set β\nf : β → α\nH : IsLUB (Set.image f s) a\nHne : s.Nonempty\n⊢ Eq (iSup fun i => f ↑i) a","decl":"theorem IsLUB.ciSup_set_eq {s : Set β} {f : β → α} (H : IsLUB (f '' s) a) (Hne : s.Nonempty) :\n    ⨆ i : s, f i = a :=\n  IsLUB.csSup_eq (image_eq_range f s ▸ H) (image_eq_range f s ▸ Hne.image f)\n\n"}
{"name":"IsGLB.ciInf_eq","module":"Mathlib.Order.ConditionallyCompleteLattice.Indexed","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝¹ : ConditionallyCompleteLattice α\na : α\ninst✝ : Nonempty ι\nf : ι → α\nH : IsGLB (Set.range f) a\n⊢ Eq (iInf fun i => f i) a","decl":"theorem IsGLB.ciInf_eq [Nonempty ι] {f : ι → α} (H : IsGLB (range f) a) : ⨅ i, f i = a :=\n  H.csInf_eq (range_nonempty f)\n\n"}
{"name":"IsGLB.ciInf_set_eq","module":"Mathlib.Order.ConditionallyCompleteLattice.Indexed","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : ConditionallyCompleteLattice α\na : α\ns : Set β\nf : β → α\nH : IsGLB (Set.image f s) a\nHne : s.Nonempty\n⊢ Eq (iInf fun i => f ↑i) a","decl":"theorem IsGLB.ciInf_set_eq {s : Set β} {f : β → α} (H : IsGLB (f '' s) a) (Hne : s.Nonempty) :\n    ⨅ i : s, f i = a :=\n  IsGLB.csInf_eq (image_eq_range f s ▸ H) (image_eq_range f s ▸ Hne.image f)\n\n"}
{"name":"ciSup_le","module":"Mathlib.Order.ConditionallyCompleteLattice.Indexed","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝¹ : ConditionallyCompleteLattice α\ninst✝ : Nonempty ι\nf : ι → α\nc : α\nH : ∀ (x : ι), LE.le (f x) c\n⊢ LE.le (iSup f) c","decl":"/-- The indexed supremum of a function is bounded above by a uniform bound -/\ntheorem ciSup_le [Nonempty ι] {f : ι → α} {c : α} (H : ∀ x, f x ≤ c) : iSup f ≤ c :=\n  csSup_le (range_nonempty f) (by rwa [forall_mem_range])\n\n"}
{"name":"le_ciSup","module":"Mathlib.Order.ConditionallyCompleteLattice.Indexed","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝ : ConditionallyCompleteLattice α\nf : ι → α\nH : BddAbove (Set.range f)\nc : ι\n⊢ LE.le (f c) (iSup f)","decl":"/-- The indexed supremum of a function is bounded below by the value taken at one point -/\ntheorem le_ciSup {f : ι → α} (H : BddAbove (range f)) (c : ι) : f c ≤ iSup f :=\n  le_csSup H (mem_range_self _)\n\n"}
{"name":"le_ciSup_of_le","module":"Mathlib.Order.ConditionallyCompleteLattice.Indexed","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝ : ConditionallyCompleteLattice α\na : α\nf : ι → α\nH : BddAbove (Set.range f)\nc : ι\nh : LE.le a (f c)\n⊢ LE.le a (iSup f)","decl":"theorem le_ciSup_of_le {f : ι → α} (H : BddAbove (range f)) (c : ι) (h : a ≤ f c) : a ≤ iSup f :=\n  le_trans h (le_ciSup H c)\n\n"}
{"name":"ciSup_mono","module":"Mathlib.Order.ConditionallyCompleteLattice.Indexed","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝ : ConditionallyCompleteLattice α\nf g : ι → α\nB : BddAbove (Set.range g)\nH : ∀ (x : ι), LE.le (f x) (g x)\n⊢ LE.le (iSup f) (iSup g)","decl":"/-- The indexed suprema of two functions are comparable if the functions are pointwise comparable -/\ntheorem ciSup_mono {f g : ι → α} (B : BddAbove (range g)) (H : ∀ x, f x ≤ g x) :\n    iSup f ≤ iSup g := by\n  cases isEmpty_or_nonempty ι\n  · rw [iSup_of_empty', iSup_of_empty']\n  · exact ciSup_le fun x => le_ciSup_of_le B x (H x)\n\n"}
{"name":"le_ciSup_set","module":"Mathlib.Order.ConditionallyCompleteLattice.Indexed","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : ConditionallyCompleteLattice α\nf : β → α\ns : Set β\nH : BddAbove (Set.image f s)\nc : β\nhc : Membership.mem s c\n⊢ LE.le (f c) (iSup fun i => f ↑i)","decl":"theorem le_ciSup_set {f : β → α} {s : Set β} (H : BddAbove (f '' s)) {c : β} (hc : c ∈ s) :\n    f c ≤ ⨆ i : s, f i :=\n  (le_csSup H <| mem_image_of_mem f hc).trans_eq sSup_image'\n\n"}
{"name":"ciInf_mono","module":"Mathlib.Order.ConditionallyCompleteLattice.Indexed","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝ : ConditionallyCompleteLattice α\nf g : ι → α\nB : BddBelow (Set.range f)\nH : ∀ (x : ι), LE.le (f x) (g x)\n⊢ LE.le (iInf f) (iInf g)","decl":"/-- The indexed infimum of two functions are comparable if the functions are pointwise comparable -/\ntheorem ciInf_mono {f g : ι → α} (B : BddBelow (range f)) (H : ∀ x, f x ≤ g x) : iInf f ≤ iInf g :=\n  ciSup_mono (α := αᵒᵈ) B H\n\n"}
{"name":"le_ciInf","module":"Mathlib.Order.ConditionallyCompleteLattice.Indexed","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝¹ : ConditionallyCompleteLattice α\ninst✝ : Nonempty ι\nf : ι → α\nc : α\nH : ∀ (x : ι), LE.le c (f x)\n⊢ LE.le c (iInf f)","decl":"/-- The indexed minimum of a function is bounded below by a uniform lower bound -/\ntheorem le_ciInf [Nonempty ι] {f : ι → α} {c : α} (H : ∀ x, c ≤ f x) : c ≤ iInf f :=\n  ciSup_le (α := αᵒᵈ) H\n\n"}
{"name":"ciInf_le","module":"Mathlib.Order.ConditionallyCompleteLattice.Indexed","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝ : ConditionallyCompleteLattice α\nf : ι → α\nH : BddBelow (Set.range f)\nc : ι\n⊢ LE.le (iInf f) (f c)","decl":"/-- The indexed infimum of a function is bounded above by the value taken at one point -/\ntheorem ciInf_le {f : ι → α} (H : BddBelow (range f)) (c : ι) : iInf f ≤ f c :=\n  le_ciSup (α := αᵒᵈ) H c\n\n"}
{"name":"ciInf_le_of_le","module":"Mathlib.Order.ConditionallyCompleteLattice.Indexed","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝ : ConditionallyCompleteLattice α\na : α\nf : ι → α\nH : BddBelow (Set.range f)\nc : ι\nh : LE.le (f c) a\n⊢ LE.le (iInf f) a","decl":"theorem ciInf_le_of_le {f : ι → α} (H : BddBelow (range f)) (c : ι) (h : f c ≤ a) : iInf f ≤ a :=\n  le_ciSup_of_le (α := αᵒᵈ) H c h\n\n"}
{"name":"ciInf_set_le","module":"Mathlib.Order.ConditionallyCompleteLattice.Indexed","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : ConditionallyCompleteLattice α\nf : β → α\ns : Set β\nH : BddBelow (Set.image f s)\nc : β\nhc : Membership.mem s c\n⊢ LE.le (iInf fun i => f ↑i) (f c)","decl":"theorem ciInf_set_le {f : β → α} {s : Set β} (H : BddBelow (f '' s)) {c : β} (hc : c ∈ s) :\n    ⨅ i : s, f i ≤ f c :=\n  le_ciSup_set (α := αᵒᵈ) H hc\n\n"}
{"name":"ciInf_le_ciSup","module":"Mathlib.Order.ConditionallyCompleteLattice.Indexed","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝¹ : ConditionallyCompleteLattice α\ninst✝ : Nonempty ι\nf : ι → α\nhf : BddBelow (Set.range f)\nhf' : BddAbove (Set.range f)\n⊢ LE.le (iInf fun i => f i) (iSup fun i => f i)","decl":"lemma ciInf_le_ciSup [Nonempty ι] {f : ι → α} (hf : BddBelow (range f)) (hf' : BddAbove (range f)) :\n    ⨅ i, f i ≤ ⨆ i, f i :=\n  (ciInf_le hf (Classical.arbitrary _)).trans <| le_ciSup hf' (Classical.arbitrary _)\n\n"}
{"name":"ciSup_const","module":"Mathlib.Order.ConditionallyCompleteLattice.Indexed","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝ : ConditionallyCompleteLattice α\nhι : Nonempty ι\na : α\n⊢ Eq (iSup fun x => a) a","decl":"@[simp]\ntheorem ciSup_const [hι : Nonempty ι] {a : α} : ⨆ _ : ι, a = a := by\n  rw [iSup, range_const, csSup_singleton]\n\n"}
{"name":"ciInf_const","module":"Mathlib.Order.ConditionallyCompleteLattice.Indexed","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝¹ : ConditionallyCompleteLattice α\ninst✝ : Nonempty ι\na : α\n⊢ Eq (iInf fun x => a) a","decl":"@[simp]\ntheorem ciInf_const [Nonempty ι] {a : α} : ⨅ _ : ι, a = a :=\n  ciSup_const (α := αᵒᵈ)\n\n"}
{"name":"ciSup_unique","module":"Mathlib.Order.ConditionallyCompleteLattice.Indexed","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝¹ : ConditionallyCompleteLattice α\ninst✝ : Unique ι\ns : ι → α\n⊢ Eq (iSup fun i => s i) (s Inhabited.default)","decl":"@[simp]\ntheorem ciSup_unique [Unique ι] {s : ι → α} : ⨆ i, s i = s default := by\n  have : ∀ i, s i = s default := fun i => congr_arg s (Unique.eq_default i)\n  simp only [this, ciSup_const]\n\n"}
{"name":"ciInf_unique","module":"Mathlib.Order.ConditionallyCompleteLattice.Indexed","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝¹ : ConditionallyCompleteLattice α\ninst✝ : Unique ι\ns : ι → α\n⊢ Eq (iInf fun i => s i) (s Inhabited.default)","decl":"@[simp]\ntheorem ciInf_unique [Unique ι] {s : ι → α} : ⨅ i, s i = s default :=\n  ciSup_unique (α := αᵒᵈ)\n\n"}
{"name":"ciSup_subsingleton","module":"Mathlib.Order.ConditionallyCompleteLattice.Indexed","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝¹ : ConditionallyCompleteLattice α\ninst✝ : Subsingleton ι\ni : ι\ns : ι → α\n⊢ Eq (iSup fun i => s i) (s i)","decl":"theorem ciSup_subsingleton [Subsingleton ι] (i : ι) (s : ι → α) : ⨆ i, s i = s i :=\n  @ciSup_unique α ι _ ⟨⟨i⟩, fun j => Subsingleton.elim j i⟩ _\n\n"}
{"name":"ciInf_subsingleton","module":"Mathlib.Order.ConditionallyCompleteLattice.Indexed","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝¹ : ConditionallyCompleteLattice α\ninst✝ : Subsingleton ι\ni : ι\ns : ι → α\n⊢ Eq (iInf fun i => s i) (s i)","decl":"theorem ciInf_subsingleton [Subsingleton ι] (i : ι) (s : ι → α) : ⨅ i, s i = s i :=\n  @ciInf_unique α ι _ ⟨⟨i⟩, fun j => Subsingleton.elim j i⟩ _\n\n"}
{"name":"ciSup_pos","module":"Mathlib.Order.ConditionallyCompleteLattice.Indexed","initialProofState":"α : Type u_1\ninst✝ : ConditionallyCompleteLattice α\np : Prop\nf : p → α\nhp : p\n⊢ Eq (iSup fun h => f h) (f hp)","decl":"@[simp]\ntheorem ciSup_pos {p : Prop} {f : p → α} (hp : p) : ⨆ h : p, f h = f hp :=\n  ciSup_subsingleton hp f\n\n"}
{"name":"ciInf_pos","module":"Mathlib.Order.ConditionallyCompleteLattice.Indexed","initialProofState":"α : Type u_1\ninst✝ : ConditionallyCompleteLattice α\np : Prop\nf : p → α\nhp : p\n⊢ Eq (iInf fun h => f h) (f hp)","decl":"@[simp]\ntheorem ciInf_pos {p : Prop} {f : p → α} (hp : p) : ⨅ h : p, f h = f hp :=\n  ciSup_pos (α := αᵒᵈ) hp\n\n"}
{"name":"ciSup_neg","module":"Mathlib.Order.ConditionallyCompleteLattice.Indexed","initialProofState":"α : Type u_1\ninst✝ : ConditionallyCompleteLattice α\np : Prop\nf : p → α\nhp : Not p\n⊢ Eq (iSup fun h => f h) (SupSet.sSup EmptyCollection.emptyCollection)","decl":"lemma ciSup_neg {p : Prop} {f : p → α} (hp : ¬ p) :\n    ⨆ (h : p), f h = sSup (∅ : Set α) := by\n  rw [iSup]\n  congr\n  rwa [range_eq_empty_iff, isEmpty_Prop]\n\n"}
{"name":"ciInf_neg","module":"Mathlib.Order.ConditionallyCompleteLattice.Indexed","initialProofState":"α : Type u_1\ninst✝ : ConditionallyCompleteLattice α\np : Prop\nf : p → α\nhp : Not p\n⊢ Eq (iInf fun h => f h) (InfSet.sInf EmptyCollection.emptyCollection)","decl":"lemma ciInf_neg {p : Prop} {f : p → α} (hp : ¬ p) :\n    ⨅ (h : p), f h = sInf (∅ : Set α) :=\n  ciSup_neg (α := αᵒᵈ) hp\n\n"}
{"name":"ciSup_eq_ite","module":"Mathlib.Order.ConditionallyCompleteLattice.Indexed","initialProofState":"α : Type u_1\ninst✝¹ : ConditionallyCompleteLattice α\np : Prop\ninst✝ : Decidable p\nf : p → α\n⊢ Eq (iSup fun h => f h) (dite p (fun h => f h) fun h => SupSet.sSup EmptyCollection.emptyCollection)","decl":"lemma ciSup_eq_ite {p : Prop} [Decidable p] {f : p → α} :\n    (⨆ h : p, f h) = if h : p then f h else sSup (∅ : Set α) := by\n  by_cases H : p <;> simp [ciSup_neg, H]\n\n"}
{"name":"ciInf_eq_ite","module":"Mathlib.Order.ConditionallyCompleteLattice.Indexed","initialProofState":"α : Type u_1\ninst✝¹ : ConditionallyCompleteLattice α\np : Prop\ninst✝ : Decidable p\nf : p → α\n⊢ Eq (iInf fun h => f h) (dite p (fun h => f h) fun h => InfSet.sInf EmptyCollection.emptyCollection)","decl":"lemma ciInf_eq_ite {p : Prop} [Decidable p] {f : p → α} :\n    (⨅ h : p, f h) = if h : p then f h else sInf (∅ : Set α) :=\n  ciSup_eq_ite (α := αᵒᵈ)\n\n"}
{"name":"cbiSup_eq_of_forall","module":"Mathlib.Order.ConditionallyCompleteLattice.Indexed","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝ : ConditionallyCompleteLattice α\np : ι → Prop\nf : Subtype p → α\nhp : ∀ (i : ι), p i\n⊢ Eq (iSup fun i => iSup fun h => f ⟨i, h⟩) (iSup f)","decl":"theorem cbiSup_eq_of_forall {p : ι → Prop} {f : Subtype p → α} (hp : ∀ i, p i) :\n    ⨆ (i) (h : p i), f ⟨i, h⟩ = iSup f := by\n  simp only [hp, ciSup_unique]\n  simp only [iSup]\n  congr\n  apply Subset.antisymm\n  · rintro - ⟨i, rfl⟩\n    simp [hp i]\n  · rintro - ⟨i, rfl⟩\n    simp\n\n"}
{"name":"cbiInf_eq_of_forall","module":"Mathlib.Order.ConditionallyCompleteLattice.Indexed","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝ : ConditionallyCompleteLattice α\np : ι → Prop\nf : Subtype p → α\nhp : ∀ (i : ι), p i\n⊢ Eq (iInf fun i => iInf fun h => f ⟨i, h⟩) (iInf f)","decl":"theorem cbiInf_eq_of_forall {p : ι → Prop} {f : Subtype p → α} (hp : ∀ i, p i) :\n    ⨅ (i) (h : p i), f ⟨i, h⟩ = iInf f :=\n  cbiSup_eq_of_forall (α := αᵒᵈ) hp\n\n"}
{"name":"ciSup_eq_of_forall_le_of_forall_lt_exists_gt","module":"Mathlib.Order.ConditionallyCompleteLattice.Indexed","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝¹ : ConditionallyCompleteLattice α\nb : α\ninst✝ : Nonempty ι\nf : ι → α\nh₁ : ∀ (i : ι), LE.le (f i) b\nh₂ : ∀ (w : α), LT.lt w b → Exists fun i => LT.lt w (f i)\n⊢ Eq (iSup fun i => f i) b","decl":"/-- Introduction rule to prove that `b` is the supremum of `f`: it suffices to check that `b`\nis larger than `f i` for all `i`, and that this is not the case of any `w<b`.\nSee `iSup_eq_of_forall_le_of_forall_lt_exists_gt` for a version in complete lattices. -/\ntheorem ciSup_eq_of_forall_le_of_forall_lt_exists_gt [Nonempty ι] {f : ι → α} (h₁ : ∀ i, f i ≤ b)\n    (h₂ : ∀ w, w < b → ∃ i, w < f i) : ⨆ i : ι, f i = b :=\n  csSup_eq_of_forall_le_of_forall_lt_exists_gt (range_nonempty f) (forall_mem_range.mpr h₁)\n    fun w hw => exists_range_iff.mpr <| h₂ w hw\n\n-- Porting note: in mathlib3 `by exact` is not needed\n"}
{"name":"ciInf_eq_of_forall_ge_of_forall_gt_exists_lt","module":"Mathlib.Order.ConditionallyCompleteLattice.Indexed","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝¹ : ConditionallyCompleteLattice α\nb : α\ninst✝ : Nonempty ι\nf : ι → α\nh₁ : ∀ (i : ι), LE.le b (f i)\nh₂ : ∀ (w : α), LT.lt b w → Exists fun i => LT.lt (f i) w\n⊢ Eq (iInf fun i => f i) b","decl":"/-- Introduction rule to prove that `b` is the infimum of `f`: it suffices to check that `b`\nis smaller than `f i` for all `i`, and that this is not the case of any `w>b`.\nSee `iInf_eq_of_forall_ge_of_forall_gt_exists_lt` for a version in complete lattices. -/\ntheorem ciInf_eq_of_forall_ge_of_forall_gt_exists_lt [Nonempty ι] {f : ι → α} (h₁ : ∀ i, b ≤ f i)\n    (h₂ : ∀ w, b < w → ∃ i, f i < w) : ⨅ i : ι, f i = b := by\n  exact ciSup_eq_of_forall_le_of_forall_lt_exists_gt (α := αᵒᵈ) (f := ‹_›) ‹_› ‹_›\n\n"}
{"name":"Monotone.ciSup_mem_iInter_Icc_of_antitone","module":"Mathlib.Order.ConditionallyCompleteLattice.Indexed","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : ConditionallyCompleteLattice α\ninst✝ : SemilatticeSup β\nf g : β → α\nhf : Monotone f\nhg : Antitone g\nh : LE.le f g\n⊢ Membership.mem (Set.iInter fun n => Set.Icc (f n) (g n)) (iSup fun n => f n)","decl":"/-- **Nested intervals lemma**: if `f` is a monotone sequence, `g` is an antitone sequence, and\n`f n ≤ g n` for all `n`, then `⨆ n, f n` belongs to all the intervals `[f n, g n]`. -/\ntheorem Monotone.ciSup_mem_iInter_Icc_of_antitone [SemilatticeSup β] {f g : β → α} (hf : Monotone f)\n    (hg : Antitone g) (h : f ≤ g) : (⨆ n, f n) ∈ ⋂ n, Icc (f n) (g n) := by\n  refine mem_iInter.2 fun n => ?_\n  haveI : Nonempty β := ⟨n⟩\n  have : ∀ m, f m ≤ g n := fun m => hf.forall_le_of_antitone hg h m n\n  exact ⟨le_ciSup ⟨g <| n, forall_mem_range.2 this⟩ _, ciSup_le this⟩\n\n"}
{"name":"ciSup_mem_iInter_Icc_of_antitone_Icc","module":"Mathlib.Order.ConditionallyCompleteLattice.Indexed","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : ConditionallyCompleteLattice α\ninst✝ : SemilatticeSup β\nf g : β → α\nh : Antitone fun n => Set.Icc (f n) (g n)\nh' : ∀ (n : β), LE.le (f n) (g n)\n⊢ Membership.mem (Set.iInter fun n => Set.Icc (f n) (g n)) (iSup fun n => f n)","decl":"/-- Nested intervals lemma: if `[f n, g n]` is an antitone sequence of nonempty\nclosed intervals, then `⨆ n, f n` belongs to all the intervals `[f n, g n]`. -/\ntheorem ciSup_mem_iInter_Icc_of_antitone_Icc [SemilatticeSup β] {f g : β → α}\n    (h : Antitone fun n => Icc (f n) (g n)) (h' : ∀ n, f n ≤ g n) :\n    (⨆ n, f n) ∈ ⋂ n, Icc (f n) (g n) :=\n  Monotone.ciSup_mem_iInter_Icc_of_antitone\n    (fun _ n hmn => ((Icc_subset_Icc_iff (h' n)).1 (h hmn)).1)\n    (fun _ n hmn => ((Icc_subset_Icc_iff (h' n)).1 (h hmn)).2) h'\n\n"}
{"name":"Set.Iic_ciInf","module":"Mathlib.Order.ConditionallyCompleteLattice.Indexed","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝¹ : ConditionallyCompleteLattice α\ninst✝ : Nonempty ι\nf : ι → α\nhf : BddBelow (Set.range f)\n⊢ Eq (Set.Iic (iInf fun i => f i)) (Set.iInter fun i => Set.Iic (f i))","decl":"lemma Set.Iic_ciInf [Nonempty ι] {f : ι → α} (hf : BddBelow (range f)) :\n    Iic (⨅ i, f i) = ⋂ i, Iic (f i) := by\n  apply Subset.antisymm\n  · rintro x hx - ⟨i, rfl⟩\n    exact hx.trans (ciInf_le hf _)\n  · rintro x hx\n    apply le_ciInf\n    simpa using hx\n\n"}
{"name":"Set.Ici_ciSup","module":"Mathlib.Order.ConditionallyCompleteLattice.Indexed","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝¹ : ConditionallyCompleteLattice α\ninst✝ : Nonempty ι\nf : ι → α\nhf : BddAbove (Set.range f)\n⊢ Eq (Set.Ici (iSup fun i => f i)) (Set.iInter fun i => Set.Ici (f i))","decl":"lemma Set.Ici_ciSup [Nonempty ι] {f : ι → α} (hf : BddAbove (range f)) :\n    Ici (⨆ i, f i) = ⋂ i, Ici (f i) :=\n  Iic_ciInf (α := αᵒᵈ) hf\n\n"}
{"name":"ciSup_subtype","module":"Mathlib.Order.ConditionallyCompleteLattice.Indexed","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝² : ConditionallyCompleteLattice α\ninst✝¹ : Nonempty ι\np : ι → Prop\ninst✝ : Nonempty (Subtype p)\nf : Subtype p → α\nhf : BddAbove (Set.range f)\nhf' : LE.le (SupSet.sSup EmptyCollection.emptyCollection) (iSup f)\n⊢ Eq (iSup f) (iSup fun i => iSup fun h => f ⟨i, h⟩)","decl":"theorem ciSup_subtype [Nonempty ι] {p : ι → Prop} [Nonempty (Subtype p)] {f : Subtype p → α}\n    (hf : BddAbove (Set.range f)) (hf' : sSup ∅ ≤ iSup f) :\n    iSup f = ⨆ (i) (h : p i), f ⟨i, h⟩ := by\n  classical\n  refine le_antisymm (ciSup_le ?_) ?_\n  · intro ⟨i, h⟩\n    have : f ⟨i, h⟩ = (fun i : ι ↦ ⨆ (h : p i), f ⟨i, h⟩) i := by simp [h]\n    rw [this]\n    refine le_ciSup (f := (fun i : ι ↦ ⨆ (h : p i), f ⟨i, h⟩)) ?_ i\n    simp_rw [ciSup_eq_ite]\n    refine (hf.union (bddAbove_singleton (a := sSup ∅))).mono ?_\n    intro\n    simp only [Set.mem_range, Set.union_singleton, Set.mem_insert_iff, Subtype.exists,\n      forall_exists_index]\n    intro b hb\n    split_ifs at hb\n    · exact Or.inr ⟨_, _, hb⟩\n    · simp_all\n  · refine ciSup_le fun i ↦ ?_\n    simp_rw [ciSup_eq_ite]\n    split_ifs\n    · exact le_ciSup hf ?_\n    · exact hf'\n\n"}
{"name":"ciInf_subtype","module":"Mathlib.Order.ConditionallyCompleteLattice.Indexed","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝² : ConditionallyCompleteLattice α\ninst✝¹ : Nonempty ι\np : ι → Prop\ninst✝ : Nonempty (Subtype p)\nf : Subtype p → α\nhf : BddBelow (Set.range f)\nhf' : LE.le (iInf f) (InfSet.sInf EmptyCollection.emptyCollection)\n⊢ Eq (iInf f) (iInf fun i => iInf fun h => f ⟨i, h⟩)","decl":"theorem ciInf_subtype [Nonempty ι] {p : ι → Prop} [Nonempty (Subtype p)] {f : Subtype p → α}\n    (hf : BddBelow (Set.range f)) (hf' : iInf f ≤ sInf ∅) :\n    iInf f = ⨅ (i) (h : p i), f ⟨i, h⟩ :=\n  ciSup_subtype (α := αᵒᵈ) hf hf'\n\n"}
{"name":"ciSup_subtype'","module":"Mathlib.Order.ConditionallyCompleteLattice.Indexed","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝² : ConditionallyCompleteLattice α\ninst✝¹ : Nonempty ι\np : ι → Prop\ninst✝ : Nonempty (Subtype p)\nf : (i : ι) → p i → α\nhf : BddAbove (Set.range fun i => f ↑i ⋯)\nhf' : LE.le (SupSet.sSup EmptyCollection.emptyCollection) (iSup fun i => f ↑i ⋯)\n⊢ Eq (iSup fun i => iSup fun h => f i h) (iSup fun x => f ↑x ⋯)","decl":"theorem ciSup_subtype' [Nonempty ι] {p : ι → Prop} [Nonempty (Subtype p)] {f : ∀ i, p i → α}\n    (hf : BddAbove (Set.range (fun i : Subtype p ↦ f i i.prop)))\n    (hf' : sSup ∅ ≤ ⨆ (i : Subtype p), f i i.prop) :\n    ⨆ (i) (h), f i h = ⨆ x : Subtype p, f x x.property :=\n  (ciSup_subtype (f := fun x => f x.val x.property) hf hf').symm\n\n"}
{"name":"ciInf_subtype'","module":"Mathlib.Order.ConditionallyCompleteLattice.Indexed","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝² : ConditionallyCompleteLattice α\ninst✝¹ : Nonempty ι\np : ι → Prop\ninst✝ : Nonempty (Subtype p)\nf : (i : ι) → p i → α\nhf : BddBelow (Set.range fun i => f ↑i ⋯)\nhf' : LE.le (iInf fun i => f ↑i ⋯) (InfSet.sInf EmptyCollection.emptyCollection)\n⊢ Eq (iInf fun i => iInf fun h => f i h) (iInf fun x => f ↑x ⋯)","decl":"theorem ciInf_subtype' [Nonempty ι] {p : ι → Prop} [Nonempty (Subtype p)] {f : ∀ i, p i → α}\n    (hf : BddBelow (Set.range (fun i : Subtype p ↦ f i i.prop)))\n    (hf' : ⨅ (i : Subtype p), f i i.prop ≤ sInf ∅) :\n    ⨅ (i) (h), f i h = ⨅ x : Subtype p, f x x.property :=\n  (ciInf_subtype (f := fun x => f x.val x.property) hf hf').symm\n\n"}
{"name":"ciSup_subtype''","module":"Mathlib.Order.ConditionallyCompleteLattice.Indexed","initialProofState":"α : Type u_1\ninst✝¹ : ConditionallyCompleteLattice α\nι : Type u_5\ninst✝ : Nonempty ι\ns : Set ι\nhs : s.Nonempty\nf : ι → α\nhf : BddAbove (Set.range fun i => f ↑i)\nhf' : LE.le (SupSet.sSup EmptyCollection.emptyCollection) (iSup fun i => f ↑i)\n⊢ Eq (iSup fun i => f ↑i) (iSup fun t => iSup fun x => f t)","decl":"theorem ciSup_subtype'' {ι} [Nonempty ι] {s : Set ι} (hs : s.Nonempty) {f : ι → α}\n    (hf : BddAbove (Set.range fun i : s ↦ f i)) (hf' : sSup ∅ ≤ ⨆ i : s, f i) :\n    ⨆ i : s, f i = ⨆ (t : ι) (_ : t ∈ s), f t :=\n  haveI : Nonempty s := Set.Nonempty.to_subtype hs\n  ciSup_subtype hf hf'\n\n"}
{"name":"ciInf_subtype''","module":"Mathlib.Order.ConditionallyCompleteLattice.Indexed","initialProofState":"α : Type u_1\ninst✝¹ : ConditionallyCompleteLattice α\nι : Type u_5\ninst✝ : Nonempty ι\ns : Set ι\nhs : s.Nonempty\nf : ι → α\nhf : BddBelow (Set.range fun i => f ↑i)\nhf' : LE.le (iInf fun i => f ↑i) (InfSet.sInf EmptyCollection.emptyCollection)\n⊢ Eq (iInf fun i => f ↑i) (iInf fun t => iInf fun x => f t)","decl":"theorem ciInf_subtype'' {ι} [Nonempty ι] {s : Set ι} (hs : s.Nonempty) {f : ι → α}\n    (hf : BddBelow (Set.range fun i : s ↦ f i)) (hf' : ⨅ i : s, f i ≤ sInf ∅) :\n    ⨅ i : s, f i = ⨅ (t : ι) (_ : t ∈ s), f t :=\n  haveI : Nonempty s := Set.Nonempty.to_subtype hs\n  ciInf_subtype hf hf'\n\n"}
{"name":"csSup_image","module":"Mathlib.Order.ConditionallyCompleteLattice.Indexed","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : ConditionallyCompleteLattice α\ninst✝ : Nonempty β\ns : Set β\nhs : s.Nonempty\nf : β → α\nhf : BddAbove (Set.range fun i => f ↑i)\nhf' : LE.le (SupSet.sSup EmptyCollection.emptyCollection) (iSup fun i => f ↑i)\n⊢ Eq (SupSet.sSup (Set.image f s)) (iSup fun a => iSup fun h => f a)","decl":"theorem csSup_image [Nonempty β] {s : Set β} (hs : s.Nonempty) {f : β → α}\n    (hf : BddAbove (Set.range fun i : s ↦ f i)) (hf' : sSup ∅ ≤ ⨆ i : s, f i) :\n    sSup (f '' s) = ⨆ a ∈ s, f a := by\n  rw [← ciSup_subtype'' hs hf hf', iSup, Set.image_eq_range]\n\n"}
{"name":"csInf_image","module":"Mathlib.Order.ConditionallyCompleteLattice.Indexed","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : ConditionallyCompleteLattice α\ninst✝ : Nonempty β\ns : Set β\nhs : s.Nonempty\nf : β → α\nhf : BddBelow (Set.range fun i => f ↑i)\nhf' : LE.le (iInf fun i => f ↑i) (InfSet.sInf EmptyCollection.emptyCollection)\n⊢ Eq (InfSet.sInf (Set.image f s)) (iInf fun a => iInf fun h => f a)","decl":"theorem csInf_image [Nonempty β] {s : Set β} (hs : s.Nonempty) {f : β → α}\n    (hf : BddBelow (Set.range fun i : s ↦ f i)) (hf' : ⨅ i : s, f i ≤ sInf ∅) :\n    sInf (f '' s) = ⨅ a ∈ s, f a :=\n  csSup_image (α := αᵒᵈ) hs hf hf'\n\n"}
{"name":"ciSup_image","module":"Mathlib.Order.ConditionallyCompleteLattice.Indexed","initialProofState":"α : Type u_5\nι : Type u_6\nι' : Type u_7\ninst✝² : ConditionallyCompleteLattice α\ninst✝¹ : Nonempty ι\ninst✝ : Nonempty ι'\ns : Set ι\nhs : s.Nonempty\nf : ι → ι'\ng : ι' → α\nhf : BddAbove (Set.range fun i => g (f ↑i))\nhg' : LE.le (SupSet.sSup EmptyCollection.emptyCollection) (iSup fun i => g (f ↑i))\n⊢ Eq (iSup fun i => iSup fun h => g i) (iSup fun x => iSup fun h => g (f x))","decl":"lemma ciSup_image {α ι ι' : Type*} [ConditionallyCompleteLattice α] [Nonempty ι] [Nonempty ι']\n    {s : Set ι} (hs : s.Nonempty) {f : ι → ι'} {g : ι' → α}\n    (hf : BddAbove (Set.range fun i : s ↦ g (f i))) (hg' : sSup ∅ ≤ ⨆ i : s, g (f i)) :\n    ⨆ i ∈ (f '' s), g i = ⨆ x ∈ s, g (f x) := by\n  have hg : BddAbove (Set.range fun i : f '' s ↦ g i) := by\n    simpa [bddAbove_def] using hf\n  have hf' : sSup ∅ ≤ ⨆ i : f '' s, g i := by\n    refine hg'.trans ?_\n    have : Nonempty s := Set.Nonempty.to_subtype hs\n    refine ciSup_le ?_\n    intro ⟨i, h⟩\n    obtain ⟨t, ht⟩ : ∃ t : f '' s, g t = g (f (Subtype.mk i h)) := by\n      have : f i ∈ f '' s := Set.mem_image_of_mem _ h\n      exact ⟨⟨f i, this⟩, by simp [this]⟩\n    rw [← ht]\n    refine le_ciSup_set ?_ t.prop\n    simpa [bddAbove_def] using hf\n  rw [← csSup_image (by simpa using hs) hg hf', ← csSup_image hs hf hg', ← Set.image_comp, comp_def]\n\n"}
{"name":"ciInf_image","module":"Mathlib.Order.ConditionallyCompleteLattice.Indexed","initialProofState":"α : Type u_5\nι : Type u_6\nι' : Type u_7\ninst✝² : ConditionallyCompleteLattice α\ninst✝¹ : Nonempty ι\ninst✝ : Nonempty ι'\ns : Set ι\nhs : s.Nonempty\nf : ι → ι'\ng : ι' → α\nhf : BddBelow (Set.range fun i => g (f ↑i))\nhg' : LE.le (iInf fun i => g (f ↑i)) (InfSet.sInf EmptyCollection.emptyCollection)\n⊢ Eq (iInf fun i => iInf fun h => g i) (iInf fun x => iInf fun h => g (f x))","decl":"lemma ciInf_image {α ι ι' : Type*} [ConditionallyCompleteLattice α] [Nonempty ι] [Nonempty ι']\n    {s : Set ι} (hs : s.Nonempty) {f : ι → ι'} {g : ι' → α}\n    (hf : BddBelow (Set.range fun i : s ↦ g (f i))) (hg' : ⨅ i : s, g (f i) ≤ sInf ∅) :\n    ⨅ i ∈ (f '' s), g i = ⨅ x ∈ s, g (f x) :=\n  ciSup_image (α := αᵒᵈ) hs hf hg'\n\n"}
{"name":"exists_lt_of_lt_ciSup","module":"Mathlib.Order.ConditionallyCompleteLattice.Indexed","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝¹ : ConditionallyCompleteLinearOrder α\nb : α\ninst✝ : Nonempty ι\nf : ι → α\nh : LT.lt b (iSup f)\n⊢ Exists fun i => LT.lt b (f i)","decl":"/-- Indexed version of `exists_lt_of_lt_csSup`.\nWhen `b < iSup f`, there is an element `i` such that `b < f i`.\n-/\ntheorem exists_lt_of_lt_ciSup [Nonempty ι] {f : ι → α} (h : b < iSup f) : ∃ i, b < f i :=\n  let ⟨_, ⟨i, rfl⟩, h⟩ := exists_lt_of_lt_csSup (range_nonempty f) h\n  ⟨i, h⟩\n\n"}
{"name":"exists_lt_of_ciInf_lt","module":"Mathlib.Order.ConditionallyCompleteLattice.Indexed","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝¹ : ConditionallyCompleteLinearOrder α\na : α\ninst✝ : Nonempty ι\nf : ι → α\nh : LT.lt (iInf f) a\n⊢ Exists fun i => LT.lt (f i) a","decl":"/-- Indexed version of `exists_lt_of_csInf_lt`.\nWhen `iInf f < a`, there is an element `i` such that `f i < a`.\n-/\ntheorem exists_lt_of_ciInf_lt [Nonempty ι] {f : ι → α} (h : iInf f < a) : ∃ i, f i < a :=\n  exists_lt_of_lt_ciSup (α := αᵒᵈ) h\n\n"}
{"name":"lt_ciSup_iff","module":"Mathlib.Order.ConditionallyCompleteLattice.Indexed","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝¹ : ConditionallyCompleteLinearOrder α\na : α\ninst✝ : Nonempty ι\nf : ι → α\nhb : BddAbove (Set.range f)\n⊢ Iff (LT.lt a (iSup f)) (Exists fun i => LT.lt a (f i))","decl":"theorem lt_ciSup_iff [Nonempty ι] {f : ι → α} (hb : BddAbove (range f)) :\n    a < iSup f ↔ ∃ i, a < f i := by\n  simpa only [mem_range, exists_exists_eq_and] using lt_csSup_iff hb (range_nonempty _)\n\n"}
{"name":"ciInf_lt_iff","module":"Mathlib.Order.ConditionallyCompleteLattice.Indexed","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝¹ : ConditionallyCompleteLinearOrder α\na : α\ninst✝ : Nonempty ι\nf : ι → α\nhb : BddBelow (Set.range f)\n⊢ Iff (LT.lt (iInf f) a) (Exists fun i => LT.lt (f i) a)","decl":"theorem ciInf_lt_iff [Nonempty ι] {f : ι → α} (hb : BddBelow (range f)) :\n    iInf f < a ↔ ∃ i, f i < a := by\n  simpa only [mem_range, exists_exists_eq_and] using csInf_lt_iff hb (range_nonempty _)\n\n"}
{"name":"cbiSup_eq_of_not_forall","module":"Mathlib.Order.ConditionallyCompleteLattice.Indexed","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝ : ConditionallyCompleteLinearOrder α\np : ι → Prop\nf : Subtype p → α\nhp : Not (∀ (i : ι), p i)\n⊢ Eq (iSup fun i => iSup fun h => f ⟨i, h⟩) (Max.max (iSup f) (SupSet.sSup EmptyCollection.emptyCollection))","decl":"theorem cbiSup_eq_of_not_forall {p : ι → Prop} {f : Subtype p → α} (hp : ¬ (∀ i, p i)) :\n    ⨆ (i) (h : p i), f ⟨i, h⟩ = iSup f ⊔ sSup ∅ := by\n  classical\n  rcases not_forall.1 hp with ⟨i₀, hi₀⟩\n  have : Nonempty ι := ⟨i₀⟩\n  simp only [ciSup_eq_ite]\n  by_cases H : BddAbove (range f)\n  · have B : BddAbove (range fun i ↦ if h : p i then f ⟨i, h⟩ else sSup ∅) := by\n      rcases H with ⟨c, hc⟩\n      refine ⟨c ⊔ sSup ∅, ?_⟩\n      rintro - ⟨i, rfl⟩\n      by_cases hi : p i\n      · simp only [hi, dite_true, le_sup_iff, hc (mem_range_self _), true_or]\n      · simp only [hi, dite_false, le_sup_right]\n    apply le_antisymm\n    · apply ciSup_le (fun i ↦ ?_)\n      by_cases hi : p i\n      · simp only [hi, dite_true, le_sup_iff]\n        left\n        exact le_ciSup H _\n      · simp [hi]\n    · apply sup_le\n      · rcases isEmpty_or_nonempty (Subtype p) with hp|hp\n        · rw [iSup_of_empty']\n          convert le_ciSup B i₀\n          simp [hi₀]\n        · apply ciSup_le\n          rintro ⟨i, hi⟩\n          convert le_ciSup B i\n          simp [hi]\n      · convert le_ciSup B i₀\n        simp [hi₀]\n  · have : iSup f = sSup (∅ : Set α) := csSup_of_not_bddAbove H\n    simp only [this, le_refl, sup_of_le_left]\n    apply csSup_of_not_bddAbove\n    contrapose! H\n    apply H.mono\n    rintro - ⟨i, rfl⟩\n    convert mem_range_self i.1\n    simp [i.2]\n\n"}
{"name":"cbiInf_eq_of_not_forall","module":"Mathlib.Order.ConditionallyCompleteLattice.Indexed","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝ : ConditionallyCompleteLinearOrder α\np : ι → Prop\nf : Subtype p → α\nhp : Not (∀ (i : ι), p i)\n⊢ Eq (iInf fun i => iInf fun h => f ⟨i, h⟩) (Min.min (iInf f) (InfSet.sInf EmptyCollection.emptyCollection))","decl":"theorem cbiInf_eq_of_not_forall {p : ι → Prop} {f : Subtype p → α} (hp : ¬ (∀ i, p i)) :\n    ⨅ (i) (h : p i), f ⟨i, h⟩ = iInf f ⊓ sInf ∅ :=\n  cbiSup_eq_of_not_forall (α := αᵒᵈ) hp\n\n"}
{"name":"ciInf_eq_bot_of_bot_mem","module":"Mathlib.Order.ConditionallyCompleteLattice.Indexed","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝¹ : ConditionallyCompleteLinearOrder α\ninst✝ : OrderBot α\nf : ι → α\nhs : Membership.mem (Set.range f) Bot.bot\n⊢ Eq (iInf f) Bot.bot","decl":"theorem ciInf_eq_bot_of_bot_mem [OrderBot α] {f : ι → α} (hs : ⊥ ∈ range f) : iInf f = ⊥ :=\n  csInf_eq_bot_of_bot_mem hs\n\n"}
{"name":"ciInf_eq_top_of_top_mem","module":"Mathlib.Order.ConditionallyCompleteLattice.Indexed","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝¹ : ConditionallyCompleteLinearOrder α\ninst✝ : OrderTop α\nf : ι → α\nhs : Membership.mem (Set.range f) Top.top\n⊢ Eq (iSup f) Top.top","decl":"theorem ciInf_eq_top_of_top_mem [OrderTop α] {f : ι → α} (hs : ⊤ ∈ range f) : iSup f = ⊤ :=\n  csSup_eq_top_of_top_mem hs\n\n"}
{"name":"ciInf_mem","module":"Mathlib.Order.ConditionallyCompleteLattice.Indexed","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝² : ConditionallyCompleteLinearOrder α\ninst✝¹ : WellFoundedLT α\ninst✝ : Nonempty ι\nf : ι → α\n⊢ Membership.mem (Set.range f) (iInf f)","decl":"theorem ciInf_mem [Nonempty ι] (f : ι → α) : iInf f ∈ range f :=\n  csInf_mem (range_nonempty f)\n\n"}
{"name":"ciSup_of_empty","module":"Mathlib.Order.ConditionallyCompleteLattice.Indexed","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝¹ : ConditionallyCompleteLinearOrderBot α\ninst✝ : IsEmpty ι\nf : ι → α\n⊢ Eq (iSup fun i => f i) Bot.bot","decl":"@[simp]\ntheorem ciSup_of_empty [IsEmpty ι] (f : ι → α) : ⨆ i, f i = ⊥ := by\n  rw [iSup_of_empty', csSup_empty]\n\n"}
{"name":"ciSup_false","module":"Mathlib.Order.ConditionallyCompleteLattice.Indexed","initialProofState":"α : Type u_1\ninst✝ : ConditionallyCompleteLinearOrderBot α\nf : False → α\n⊢ Eq (iSup fun i => f i) Bot.bot","decl":"theorem ciSup_false (f : False → α) : ⨆ i, f i = ⊥ :=\n  ciSup_of_empty f\n\n"}
{"name":"le_ciSup_iff'","module":"Mathlib.Order.ConditionallyCompleteLattice.Indexed","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝ : ConditionallyCompleteLinearOrderBot α\ns : ι → α\na : α\nh : BddAbove (Set.range s)\n⊢ Iff (LE.le a (iSup s)) (∀ (b : α), (∀ (i : ι), LE.le (s i) b) → LE.le a b)","decl":"theorem le_ciSup_iff' {s : ι → α} {a : α} (h : BddAbove (range s)) :\n    a ≤ iSup s ↔ ∀ b, (∀ i, s i ≤ b) → a ≤ b := by simp [iSup, h, le_csSup_iff', upperBounds]\n\n"}
{"name":"le_ciInf_iff'","module":"Mathlib.Order.ConditionallyCompleteLattice.Indexed","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝¹ : ConditionallyCompleteLinearOrderBot α\ninst✝ : Nonempty ι\nf : ι → α\na : α\n⊢ Iff (LE.le a (iInf f)) (∀ (i : ι), LE.le a (f i))","decl":"theorem le_ciInf_iff' [Nonempty ι] {f : ι → α} {a : α} : a ≤ iInf f ↔ ∀ i, a ≤ f i :=\n  le_ciInf_iff (OrderBot.bddBelow _)\n\n"}
{"name":"ciInf_le'","module":"Mathlib.Order.ConditionallyCompleteLattice.Indexed","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝ : ConditionallyCompleteLinearOrderBot α\nf : ι → α\ni : ι\n⊢ LE.le (iInf f) (f i)","decl":"theorem ciInf_le' (f : ι → α) (i : ι) : iInf f ≤ f i := ciInf_le (OrderBot.bddBelow _) _\n\n"}
{"name":"ciInf_le_of_le'","module":"Mathlib.Order.ConditionallyCompleteLattice.Indexed","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝ : ConditionallyCompleteLinearOrderBot α\nf : ι → α\na : α\nc : ι\na✝ : LE.le (f c) a\n⊢ LE.le (iInf f) a","decl":"lemma ciInf_le_of_le' (c : ι) : f c ≤ a → iInf f ≤ a := ciInf_le_of_le (OrderBot.bddBelow _) _\n\n"}
{"name":"ciSup_le_iff'","module":"Mathlib.Order.ConditionallyCompleteLattice.Indexed","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝ : ConditionallyCompleteLinearOrderBot α\nf : ι → α\nh : BddAbove (Set.range f)\na : α\n⊢ Iff (LE.le (iSup fun i => f i) a) (∀ (i : ι), LE.le (f i) a)","decl":"/-- In conditionally complete orders with a bottom element, the nonempty condition can be omitted\nfrom `ciSup_le_iff`. -/\ntheorem ciSup_le_iff' {f : ι → α} (h : BddAbove (range f)) {a : α} :\n    ⨆ i, f i ≤ a ↔ ∀ i, f i ≤ a :=\n  (csSup_le_iff' h).trans forall_mem_range\n\n"}
{"name":"ciSup_le'","module":"Mathlib.Order.ConditionallyCompleteLattice.Indexed","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝ : ConditionallyCompleteLinearOrderBot α\nf : ι → α\na : α\nh : ∀ (i : ι), LE.le (f i) a\n⊢ LE.le (iSup fun i => f i) a","decl":"theorem ciSup_le' {f : ι → α} {a : α} (h : ∀ i, f i ≤ a) : ⨆ i, f i ≤ a :=\n  csSup_le' <| forall_mem_range.2 h\n\n"}
{"name":"lt_ciSup_iff'","module":"Mathlib.Order.ConditionallyCompleteLattice.Indexed","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝ : ConditionallyCompleteLinearOrderBot α\na : α\nf : ι → α\nh : BddAbove (Set.range f)\n⊢ Iff (LT.lt a (iSup f)) (Exists fun i => LT.lt a (f i))","decl":"/-- In conditionally complete orders with a bottom element, the nonempty condition can be omitted\nfrom `lt_ciSup_iff`. -/\ntheorem lt_ciSup_iff' {f : ι → α} (h : BddAbove (range f)) : a < iSup f ↔ ∃ i, a < f i := by\n  simpa only [not_le, not_forall] using (ciSup_le_iff' h).not\n\n"}
{"name":"exists_lt_of_lt_ciSup'","module":"Mathlib.Order.ConditionallyCompleteLattice.Indexed","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝ : ConditionallyCompleteLinearOrderBot α\nf : ι → α\na : α\nh : LT.lt a (iSup fun i => f i)\n⊢ Exists fun i => LT.lt a (f i)","decl":"theorem exists_lt_of_lt_ciSup' {f : ι → α} {a : α} (h : a < ⨆ i, f i) : ∃ i, a < f i := by\n  contrapose! h\n  exact ciSup_le' h\n\n"}
{"name":"ciSup_mono'","module":"Mathlib.Order.ConditionallyCompleteLattice.Indexed","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝ : ConditionallyCompleteLinearOrderBot α\nι' : Sort u_5\nf : ι → α\ng : ι' → α\nhg : BddAbove (Set.range g)\nh : ∀ (i : ι), Exists fun i' => LE.le (f i) (g i')\n⊢ LE.le (iSup f) (iSup g)","decl":"theorem ciSup_mono' {ι'} {f : ι → α} {g : ι' → α} (hg : BddAbove (range g))\n    (h : ∀ i, ∃ i', f i ≤ g i') : iSup f ≤ iSup g :=\n  ciSup_le' fun i => Exists.elim (h i) (le_ciSup_of_le hg)\n\n"}
{"name":"ciSup_or'","module":"Mathlib.Order.ConditionallyCompleteLattice.Indexed","initialProofState":"α : Type u_1\ninst✝ : ConditionallyCompleteLinearOrderBot α\np q : Prop\nf : Or p q → α\n⊢ Eq (iSup fun h => f h) (Max.max (iSup fun h => f ⋯) (iSup fun h => f ⋯))","decl":"lemma ciSup_or' (p q : Prop) (f : p ∨ q → α) :\n    ⨆ (h : p ∨ q), f h = (⨆ h : p, f (.inl h)) ⊔ ⨆ h : q, f (.inr h) := by\n  by_cases hp : p <;>\n  by_cases hq : q <;>\n  simp [hp, hq]\n\n"}
{"name":"GaloisConnection.l_csSup","module":"Mathlib.Order.ConditionallyCompleteLattice.Indexed","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : ConditionallyCompleteLattice α\ninst✝ : ConditionallyCompleteLattice β\nl : α → β\nu : β → α\ngc : GaloisConnection l u\ns : Set α\nhne : s.Nonempty\nhbdd : BddAbove s\n⊢ Eq (l (SupSet.sSup s)) (iSup fun x => l ↑x)","decl":"theorem l_csSup (gc : GaloisConnection l u) {s : Set α} (hne : s.Nonempty) (hbdd : BddAbove s) :\n    l (sSup s) = ⨆ x : s, l x :=\n  Eq.symm <| IsLUB.ciSup_set_eq (gc.isLUB_l_image <| isLUB_csSup hne hbdd) hne\n\n"}
{"name":"GaloisConnection.l_csSup'","module":"Mathlib.Order.ConditionallyCompleteLattice.Indexed","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : ConditionallyCompleteLattice α\ninst✝ : ConditionallyCompleteLattice β\nl : α → β\nu : β → α\ngc : GaloisConnection l u\ns : Set α\nhne : s.Nonempty\nhbdd : BddAbove s\n⊢ Eq (l (SupSet.sSup s)) (SupSet.sSup (Set.image l s))","decl":"theorem l_csSup' (gc : GaloisConnection l u) {s : Set α} (hne : s.Nonempty) (hbdd : BddAbove s) :\n    l (sSup s) = sSup (l '' s) := by rw [gc.l_csSup hne hbdd, sSup_image']\n\n"}
{"name":"GaloisConnection.l_ciSup","module":"Mathlib.Order.ConditionallyCompleteLattice.Indexed","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Sort u_4\ninst✝² : ConditionallyCompleteLattice α\ninst✝¹ : ConditionallyCompleteLattice β\ninst✝ : Nonempty ι\nl : α → β\nu : β → α\ngc : GaloisConnection l u\nf : ι → α\nhf : BddAbove (Set.range f)\n⊢ Eq (l (iSup fun i => f i)) (iSup fun i => l (f i))","decl":"theorem l_ciSup (gc : GaloisConnection l u) {f : ι → α} (hf : BddAbove (range f)) :\n    l (⨆ i, f i) = ⨆ i, l (f i) := by rw [iSup, gc.l_csSup (range_nonempty _) hf, iSup_range']\n\n"}
{"name":"GaloisConnection.l_ciSup_set","module":"Mathlib.Order.ConditionallyCompleteLattice.Indexed","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝¹ : ConditionallyCompleteLattice α\ninst✝ : ConditionallyCompleteLattice β\nl : α → β\nu : β → α\ngc : GaloisConnection l u\ns : Set γ\nf : γ → α\nhf : BddAbove (Set.image f s)\nhne : s.Nonempty\n⊢ Eq (l (iSup fun i => f ↑i)) (iSup fun i => l (f ↑i))","decl":"theorem l_ciSup_set (gc : GaloisConnection l u) {s : Set γ} {f : γ → α} (hf : BddAbove (f '' s))\n    (hne : s.Nonempty) : l (⨆ i : s, f i) = ⨆ i : s, l (f i) := by\n  haveI := hne.to_subtype\n  rw [image_eq_range] at hf\n  exact gc.l_ciSup hf\n\n"}
{"name":"GaloisConnection.u_csInf","module":"Mathlib.Order.ConditionallyCompleteLattice.Indexed","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : ConditionallyCompleteLattice α\ninst✝ : ConditionallyCompleteLattice β\nl : α → β\nu : β → α\ngc : GaloisConnection l u\ns : Set β\nhne : s.Nonempty\nhbdd : BddBelow s\n⊢ Eq (u (InfSet.sInf s)) (iInf fun x => u ↑x)","decl":"theorem u_csInf (gc : GaloisConnection l u) {s : Set β} (hne : s.Nonempty) (hbdd : BddBelow s) :\n    u (sInf s) = ⨅ x : s, u x :=\n  gc.dual.l_csSup hne hbdd\n\n"}
{"name":"GaloisConnection.u_csInf'","module":"Mathlib.Order.ConditionallyCompleteLattice.Indexed","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : ConditionallyCompleteLattice α\ninst✝ : ConditionallyCompleteLattice β\nl : α → β\nu : β → α\ngc : GaloisConnection l u\ns : Set β\nhne : s.Nonempty\nhbdd : BddBelow s\n⊢ Eq (u (InfSet.sInf s)) (InfSet.sInf (Set.image u s))","decl":"theorem u_csInf' (gc : GaloisConnection l u) {s : Set β} (hne : s.Nonempty) (hbdd : BddBelow s) :\n    u (sInf s) = sInf (u '' s) :=\n  gc.dual.l_csSup' hne hbdd\n\n"}
{"name":"GaloisConnection.u_ciInf","module":"Mathlib.Order.ConditionallyCompleteLattice.Indexed","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Sort u_4\ninst✝² : ConditionallyCompleteLattice α\ninst✝¹ : ConditionallyCompleteLattice β\ninst✝ : Nonempty ι\nl : α → β\nu : β → α\ngc : GaloisConnection l u\nf : ι → β\nhf : BddBelow (Set.range f)\n⊢ Eq (u (iInf fun i => f i)) (iInf fun i => u (f i))","decl":"theorem u_ciInf (gc : GaloisConnection l u) {f : ι → β} (hf : BddBelow (range f)) :\n    u (⨅ i, f i) = ⨅ i, u (f i) :=\n  gc.dual.l_ciSup hf\n\n"}
{"name":"GaloisConnection.u_ciInf_set","module":"Mathlib.Order.ConditionallyCompleteLattice.Indexed","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝¹ : ConditionallyCompleteLattice α\ninst✝ : ConditionallyCompleteLattice β\nl : α → β\nu : β → α\ngc : GaloisConnection l u\ns : Set γ\nf : γ → β\nhf : BddBelow (Set.image f s)\nhne : s.Nonempty\n⊢ Eq (u (iInf fun i => f ↑i)) (iInf fun i => u (f ↑i))","decl":"theorem u_ciInf_set (gc : GaloisConnection l u) {s : Set γ} {f : γ → β} (hf : BddBelow (f '' s))\n    (hne : s.Nonempty) : u (⨅ i : s, f i) = ⨅ i : s, u (f i) :=\n  gc.dual.l_ciSup_set hf hne\n\n"}
{"name":"OrderIso.map_csSup","module":"Mathlib.Order.ConditionallyCompleteLattice.Indexed","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : ConditionallyCompleteLattice α\ninst✝ : ConditionallyCompleteLattice β\ne : OrderIso α β\ns : Set α\nhne : s.Nonempty\nhbdd : BddAbove s\n⊢ Eq (e (SupSet.sSup s)) (iSup fun x => e ↑x)","decl":"theorem map_csSup (e : α ≃o β) {s : Set α} (hne : s.Nonempty) (hbdd : BddAbove s) :\n    e (sSup s) = ⨆ x : s, e x :=\n  e.to_galoisConnection.l_csSup hne hbdd\n\n"}
{"name":"OrderIso.map_csSup'","module":"Mathlib.Order.ConditionallyCompleteLattice.Indexed","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : ConditionallyCompleteLattice α\ninst✝ : ConditionallyCompleteLattice β\ne : OrderIso α β\ns : Set α\nhne : s.Nonempty\nhbdd : BddAbove s\n⊢ Eq (e (SupSet.sSup s)) (SupSet.sSup (Set.image (⇑e) s))","decl":"theorem map_csSup' (e : α ≃o β) {s : Set α} (hne : s.Nonempty) (hbdd : BddAbove s) :\n    e (sSup s) = sSup (e '' s) :=\n  e.to_galoisConnection.l_csSup' hne hbdd\n\n"}
{"name":"OrderIso.map_ciSup","module":"Mathlib.Order.ConditionallyCompleteLattice.Indexed","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Sort u_4\ninst✝² : ConditionallyCompleteLattice α\ninst✝¹ : ConditionallyCompleteLattice β\ninst✝ : Nonempty ι\ne : OrderIso α β\nf : ι → α\nhf : BddAbove (Set.range f)\n⊢ Eq (e (iSup fun i => f i)) (iSup fun i => e (f i))","decl":"theorem map_ciSup (e : α ≃o β) {f : ι → α} (hf : BddAbove (range f)) :\n    e (⨆ i, f i) = ⨆ i, e (f i) :=\n  e.to_galoisConnection.l_ciSup hf\n\n"}
{"name":"OrderIso.map_ciSup_set","module":"Mathlib.Order.ConditionallyCompleteLattice.Indexed","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝¹ : ConditionallyCompleteLattice α\ninst✝ : ConditionallyCompleteLattice β\ne : OrderIso α β\ns : Set γ\nf : γ → α\nhf : BddAbove (Set.image f s)\nhne : s.Nonempty\n⊢ Eq (e (iSup fun i => f ↑i)) (iSup fun i => e (f ↑i))","decl":"theorem map_ciSup_set (e : α ≃o β) {s : Set γ} {f : γ → α} (hf : BddAbove (f '' s))\n    (hne : s.Nonempty) : e (⨆ i : s, f i) = ⨆ i : s, e (f i) :=\n  e.to_galoisConnection.l_ciSup_set hf hne\n\n"}
{"name":"OrderIso.map_csInf","module":"Mathlib.Order.ConditionallyCompleteLattice.Indexed","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : ConditionallyCompleteLattice α\ninst✝ : ConditionallyCompleteLattice β\ne : OrderIso α β\ns : Set α\nhne : s.Nonempty\nhbdd : BddBelow s\n⊢ Eq (e (InfSet.sInf s)) (iInf fun x => e ↑x)","decl":"theorem map_csInf (e : α ≃o β) {s : Set α} (hne : s.Nonempty) (hbdd : BddBelow s) :\n    e (sInf s) = ⨅ x : s, e x :=\n  e.dual.map_csSup hne hbdd\n\n"}
{"name":"OrderIso.map_csInf'","module":"Mathlib.Order.ConditionallyCompleteLattice.Indexed","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : ConditionallyCompleteLattice α\ninst✝ : ConditionallyCompleteLattice β\ne : OrderIso α β\ns : Set α\nhne : s.Nonempty\nhbdd : BddBelow s\n⊢ Eq (e (InfSet.sInf s)) (InfSet.sInf (Set.image (⇑e) s))","decl":"theorem map_csInf' (e : α ≃o β) {s : Set α} (hne : s.Nonempty) (hbdd : BddBelow s) :\n    e (sInf s) = sInf (e '' s) :=\n  e.dual.map_csSup' hne hbdd\n\n"}
{"name":"OrderIso.map_ciInf","module":"Mathlib.Order.ConditionallyCompleteLattice.Indexed","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Sort u_4\ninst✝² : ConditionallyCompleteLattice α\ninst✝¹ : ConditionallyCompleteLattice β\ninst✝ : Nonempty ι\ne : OrderIso α β\nf : ι → α\nhf : BddBelow (Set.range f)\n⊢ Eq (e (iInf fun i => f i)) (iInf fun i => e (f i))","decl":"theorem map_ciInf (e : α ≃o β) {f : ι → α} (hf : BddBelow (range f)) :\n    e (⨅ i, f i) = ⨅ i, e (f i) :=\n  e.dual.map_ciSup hf\n\n"}
{"name":"OrderIso.map_ciInf_set","module":"Mathlib.Order.ConditionallyCompleteLattice.Indexed","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝¹ : ConditionallyCompleteLattice α\ninst✝ : ConditionallyCompleteLattice β\ne : OrderIso α β\ns : Set γ\nf : γ → α\nhf : BddBelow (Set.image f s)\nhne : s.Nonempty\n⊢ Eq (e (iInf fun i => f ↑i)) (iInf fun i => e (f ↑i))","decl":"theorem map_ciInf_set (e : α ≃o β) {s : Set γ} {f : γ → α} (hf : BddBelow (f '' s))\n    (hne : s.Nonempty) : e (⨅ i : s, f i) = ⨅ i : s, e (f i) :=\n  e.dual.map_ciSup_set hf hne\n\n"}
{"name":"WithTop.iSup_coe_eq_top","module":"Mathlib.Order.ConditionallyCompleteLattice.Indexed","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝ : ConditionallyCompleteLinearOrderBot α\nf : ι → α\n⊢ Iff (Eq (iSup fun x => ↑(f x)) Top.top) (Not (BddAbove (Set.range f)))","decl":"lemma iSup_coe_eq_top : ⨆ x, (f x : WithTop α) = ⊤ ↔ ¬BddAbove (range f) := by\n  rw [iSup_eq_top, not_bddAbove_iff]\n  refine ⟨fun hf r => ?_, fun hf a ha => ?_⟩\n  · rcases hf r (WithTop.coe_lt_top r) with ⟨i, hi⟩\n    exact ⟨f i, ⟨i, rfl⟩, WithTop.coe_lt_coe.mp hi⟩\n  · rcases hf (a.untop ha.ne) with ⟨-, ⟨i, rfl⟩, hi⟩\n    exact ⟨i, by simpa only [WithTop.coe_untop _ ha.ne] using WithTop.coe_lt_coe.mpr hi⟩\n\n"}
{"name":"WithTop.iSup_coe_lt_top","module":"Mathlib.Order.ConditionallyCompleteLattice.Indexed","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝ : ConditionallyCompleteLinearOrderBot α\nf : ι → α\n⊢ Iff (LT.lt (iSup fun x => ↑(f x)) Top.top) (BddAbove (Set.range f))","decl":"lemma iSup_coe_lt_top : ⨆ x, (f x : WithTop α) < ⊤ ↔ BddAbove (range f) :=\n  lt_top_iff_ne_top.trans iSup_coe_eq_top.not_left\n\n"}
{"name":"WithTop.iInf_coe_eq_top","module":"Mathlib.Order.ConditionallyCompleteLattice.Indexed","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝ : ConditionallyCompleteLinearOrderBot α\nf : ι → α\n⊢ Iff (Eq (iInf fun x => ↑(f x)) Top.top) (IsEmpty ι)","decl":"lemma iInf_coe_eq_top : ⨅ x, (f x : WithTop α) = ⊤ ↔ IsEmpty ι := by simp [isEmpty_iff]\n\n"}
{"name":"WithTop.iInf_coe_lt_top","module":"Mathlib.Order.ConditionallyCompleteLattice.Indexed","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝ : ConditionallyCompleteLinearOrderBot α\nf : ι → α\n⊢ Iff (LT.lt (iInf fun i => ↑(f i)) Top.top) (Nonempty ι)","decl":"lemma iInf_coe_lt_top : ⨅ i, (f i : WithTop α) < ⊤ ↔ Nonempty ι := by\n  rw [lt_top_iff_ne_top, Ne, iInf_coe_eq_top, not_isEmpty_iff]\n\n"}
