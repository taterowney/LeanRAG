{"name":"PiTensorProduct.projectiveSeminormAux_nonneg","module":"Mathlib.Analysis.NormedSpace.PiTensorProduct.ProjectiveSeminorm","initialProofState":"Œπ : Type uŒπ\ninst‚úù¬≤ : Fintype Œπ\nùïú : Type uùïú\ninst‚úù¬π : NontriviallyNormedField ùïú\nE : Œπ ‚Üí Type uE\ninst‚úù : (i : Œπ) ‚Üí SeminormedAddCommGroup (E i)\np : FreeAddMonoid (Prod ùïú ((i : Œπ) ‚Üí E i))\n‚ä¢ LE.le 0 (PiTensorProduct.projectiveSeminormAux p)","decl":"theorem projectiveSeminormAux_nonneg (p : FreeAddMonoid (ùïú √ó Œ† i, E i)) :\n    0 ‚â§ projectiveSeminormAux p := by\n  simp only [projectiveSeminormAux, Function.comp_apply]\n  refine List.sum_nonneg ?_\n  intro a\n  simp only [Multiset.map_coe, Multiset.mem_coe, List.mem_map, Prod.exists, forall_exists_index,\n    and_imp]\n  intro x m _ h\n  rw [‚Üê h]\n  exact mul_nonneg (norm_nonneg _) (Finset.prod_nonneg (fun _ _ ‚Ü¶ norm_nonneg _))\n\n"}
{"name":"PiTensorProduct.projectiveSeminormAux_add_le","module":"Mathlib.Analysis.NormedSpace.PiTensorProduct.ProjectiveSeminorm","initialProofState":"Œπ : Type uŒπ\ninst‚úù¬≤ : Fintype Œπ\nùïú : Type uùïú\ninst‚úù¬π : NontriviallyNormedField ùïú\nE : Œπ ‚Üí Type uE\ninst‚úù : (i : Œπ) ‚Üí SeminormedAddCommGroup (E i)\np q : FreeAddMonoid (Prod ùïú ((i : Œπ) ‚Üí E i))\n‚ä¢ LE.le (PiTensorProduct.projectiveSeminormAux (HAdd.hAdd p q)) (HAdd.hAdd (PiTensorProduct.projectiveSeminormAux p) (PiTensorProduct.projectiveSeminormAux q))","decl":"theorem projectiveSeminormAux_add_le (p q : FreeAddMonoid (ùïú √ó Œ† i, E i)) :\n    projectiveSeminormAux (p + q) ‚â§ projectiveSeminormAux p + projectiveSeminormAux q := by\n  simp only [projectiveSeminormAux, Function.comp_apply, Multiset.map_coe, Multiset.sum_coe]\n  erw [List.map_append]\n  rw [List.sum_append]\n  rfl\n\n"}
{"name":"PiTensorProduct.projectiveSeminormAux_smul","module":"Mathlib.Analysis.NormedSpace.PiTensorProduct.ProjectiveSeminorm","initialProofState":"Œπ : Type uŒπ\ninst‚úù¬≤ : Fintype Œπ\nùïú : Type uùïú\ninst‚úù¬π : NontriviallyNormedField ùïú\nE : Œπ ‚Üí Type uE\ninst‚úù : (i : Œπ) ‚Üí SeminormedAddCommGroup (E i)\np : FreeAddMonoid (Prod ùïú ((i : Œπ) ‚Üí E i))\na : ùïú\n‚ä¢ Eq (PiTensorProduct.projectiveSeminormAux (List.map (fun y => { fst := HMul.hMul a y.1, snd := y.2 }) p)) (HMul.hMul (Norm.norm a) (PiTensorProduct.projectiveSeminormAux p))","decl":"theorem projectiveSeminormAux_smul (p : FreeAddMonoid (ùïú √ó Œ† i, E i)) (a : ùïú) :\n    projectiveSeminormAux (List.map (fun (y : ùïú √ó Œ† i, E i) ‚Ü¶ (a * y.1, y.2)) p) =\n    ‚Äña‚Äñ * projectiveSeminormAux p := by\n  simp only [projectiveSeminormAux, Function.comp_apply, Multiset.map_coe, List.map_map,\n    Multiset.sum_coe]\n  rw [‚Üê smul_eq_mul, List.smul_sum, ‚Üê List.comp_map]\n  congr 2\n  ext x\n  simp only [Function.comp_apply, norm_mul, smul_eq_mul]\n  rw [mul_assoc]\n\n"}
{"name":"PiTensorProduct.bddBelow_projectiveSemiNormAux","module":"Mathlib.Analysis.NormedSpace.PiTensorProduct.ProjectiveSeminorm","initialProofState":"Œπ : Type uŒπ\ninst‚úù¬≥ : Fintype Œπ\nùïú : Type uùïú\ninst‚úù¬≤ : NontriviallyNormedField ùïú\nE : Œπ ‚Üí Type uE\ninst‚úù¬π : (i : Œπ) ‚Üí SeminormedAddCommGroup (E i)\ninst‚úù : (i : Œπ) ‚Üí NormedSpace ùïú (E i)\nx : PiTensorProduct ùïú fun i => E i\n‚ä¢ BddBelow (Set.range fun p => PiTensorProduct.projectiveSeminormAux ‚Üëp)","decl":"theorem bddBelow_projectiveSemiNormAux (x : ‚®Ç[ùïú] i, E i) :\n    BddBelow (Set.range (fun (p : lifts x) ‚Ü¶ projectiveSeminormAux p.1)) := by\n  existsi 0\n  rw [mem_lowerBounds]\n  simp only [Set.mem_range, Subtype.exists, exists_prop, forall_exists_index, and_imp,\n    forall_apply_eq_imp_iff‚ÇÇ]\n  exact fun p _ ‚Ü¶ projectiveSeminormAux_nonneg p\n\n"}
{"name":"PiTensorProduct.projectiveSeminorm_apply","module":"Mathlib.Analysis.NormedSpace.PiTensorProduct.ProjectiveSeminorm","initialProofState":"Œπ : Type uŒπ\ninst‚úù¬≥ : Fintype Œπ\nùïú : Type uùïú\ninst‚úù¬≤ : NontriviallyNormedField ùïú\nE : Œπ ‚Üí Type uE\ninst‚úù¬π : (i : Œπ) ‚Üí SeminormedAddCommGroup (E i)\ninst‚úù : (i : Œπ) ‚Üí NormedSpace ùïú (E i)\nx : PiTensorProduct ùïú fun i => E i\n‚ä¢ Eq (PiTensorProduct.projectiveSeminorm x) (iInf fun p => PiTensorProduct.projectiveSeminormAux ‚Üëp)","decl":"theorem projectiveSeminorm_apply (x : ‚®Ç[ùïú] i, E i) :\n    projectiveSeminorm x = iInf (fun (p : lifts x) ‚Ü¶ projectiveSeminormAux p.1) := rfl\n\n"}
{"name":"PiTensorProduct.projectiveSeminorm_tprod_le","module":"Mathlib.Analysis.NormedSpace.PiTensorProduct.ProjectiveSeminorm","initialProofState":"Œπ : Type uŒπ\ninst‚úù¬≥ : Fintype Œπ\nùïú : Type uùïú\ninst‚úù¬≤ : NontriviallyNormedField ùïú\nE : Œπ ‚Üí Type uE\ninst‚úù¬π : (i : Œπ) ‚Üí SeminormedAddCommGroup (E i)\ninst‚úù : (i : Œπ) ‚Üí NormedSpace ùïú (E i)\nm : (i : Œπ) ‚Üí E i\n‚ä¢ LE.le (PiTensorProduct.projectiveSeminorm ((PiTensorProduct.tprod ùïú) fun i => m i)) (Finset.univ.prod fun i => Norm.norm (m i))","decl":"theorem projectiveSeminorm_tprod_le (m : Œ† i, E i) :\n    projectiveSeminorm (‚®Ç‚Çú[ùïú] i, m i) ‚â§ ‚àè i, ‚Äñm i‚Äñ := by\n  rw [projectiveSeminorm_apply]\n  convert ciInf_le (bddBelow_projectiveSemiNormAux _) ‚ü®[((1 : ùïú), m)] ,?_‚ü©\n  ¬∑ simp only [projectiveSeminormAux, Function.comp_apply, List.map_cons, norm_one, one_mul,\n    List.map_nil, List.sum_cons, List.sum_nil, add_zero]\n  ¬∑ rw [mem_lifts_iff, List.map_singleton, List.sum_singleton, one_smul]\n\n"}
{"name":"PiTensorProduct.norm_eval_le_projectiveSeminorm","module":"Mathlib.Analysis.NormedSpace.PiTensorProduct.ProjectiveSeminorm","initialProofState":"Œπ : Type uŒπ\ninst‚úù‚Åµ : Fintype Œπ\nùïú : Type uùïú\ninst‚úù‚Å¥ : NontriviallyNormedField ùïú\nE : Œπ ‚Üí Type uE\ninst‚úù¬≥ : (i : Œπ) ‚Üí SeminormedAddCommGroup (E i)\ninst‚úù¬≤ : (i : Œπ) ‚Üí NormedSpace ùïú (E i)\nx : PiTensorProduct ùïú fun i => E i\nG : Type u_1\ninst‚úù¬π : SeminormedAddCommGroup G\ninst‚úù : NormedSpace ùïú G\nf : ContinuousMultilinearMap ùïú E G\n‚ä¢ LE.le (Norm.norm ((PiTensorProduct.lift f.toMultilinearMap) x)) (HMul.hMul (PiTensorProduct.projectiveSeminorm x) (Norm.norm f))","decl":"theorem norm_eval_le_projectiveSeminorm (x : ‚®Ç[ùïú] i, E i) (G : Type*) [SeminormedAddCommGroup G]\n    [NormedSpace ùïú G] (f : ContinuousMultilinearMap ùïú E G) :\n    ‚Äñlift f.toMultilinearMap x‚Äñ ‚â§ projectiveSeminorm x * ‚Äñf‚Äñ := by\n  letI := nonempty_subtype.mpr (nonempty_lifts x)\n  rw [projectiveSeminorm_apply, Real.iInf_mul_of_nonneg (norm_nonneg _), projectiveSeminormAux]\n  refine le_ciInf ?_\n  intro ‚ü®p, hp‚ü©\n  rw [mem_lifts_iff] at hp\n  conv_lhs => rw [‚Üê hp, ‚Üê List.sum_map_hom, ‚Üê Multiset.sum_coe]\n  refine le_trans (norm_multiset_sum_le _) ?_\n  simp only [tprodCoeff_eq_smul_tprod, Multiset.map_coe, List.map_map, Multiset.sum_coe,\n    Function.comp_apply]\n  rw [mul_comm, ‚Üê smul_eq_mul, List.smul_sum]\n  refine List.Forall‚ÇÇ.sum_le_sum ?_\n  simp only [smul_eq_mul, List.map_map, List.forall‚ÇÇ_map_right_iff, Function.comp_apply,\n    List.forall‚ÇÇ_map_left_iff, map_smul, lift.tprod, ContinuousMultilinearMap.coe_coe,\n    List.forall‚ÇÇ_same, Prod.forall]\n  intro a m _\n  rw [norm_smul, ‚Üê mul_assoc, mul_comm ‚Äñf‚Äñ _, mul_assoc]\n  exact mul_le_mul_of_nonneg_left (f.le_opNorm _) (norm_nonneg _)\n\n"}
