{"name":"exists_seq_covby_of_forall_covby_finite","module":"Mathlib.Order.KonigLemma","initialProofState":"α : Type u_1\ninst✝¹ : PartialOrder α\ninst✝ : IsStronglyAtomic α\nb : α\nhfin : ∀ (a : α), (setOf fun x => CovBy a x).Finite\nhb : (Set.Ici b).Infinite\n⊢ Exists fun f => And (Eq (f 0) b) (∀ (i : Nat), CovBy (f i) (f (HAdd.hAdd i 1)))","decl":"/-- **Kőnig's infinity lemma** : if each element in a strongly atomic order\nis covered by only finitely many others, and `b` is an element with infinitely many things above it,\nthen there is a sequence starting with `b` in which each element is covered by the next. -/\ntheorem exists_seq_covby_of_forall_covby_finite (hfin : ∀ (a : α), {x | a ⋖ x}.Finite)\n    (hb : (Ici b).Infinite) : ∃ f : ℕ → α, f 0 = b ∧ ∀ i, f i ⋖ f (i+1) :=\n  let h := fun a : {a : α // (Ici a).Infinite} ↦\n    exists_covby_infinite_Ici_of_infinite_Ici a.2 (hfin a)\n  let ks : ℕ → {a : α // (Ici a).Infinite} := Nat.rec ⟨b, hb⟩ fun _ a ↦ ⟨_, (h a).choose_spec.2⟩\n  ⟨fun i ↦ (ks i).1, by simp [ks], fun i ↦ by simpa using (h (ks i)).choose_spec.1⟩\n\n"}
{"name":"exists_orderEmbedding_covby_of_forall_covby_finite","module":"Mathlib.Order.KonigLemma","initialProofState":"α : Type u_1\ninst✝¹ : PartialOrder α\ninst✝ : IsStronglyAtomic α\nb : α\nhfin : ∀ (a : α), (setOf fun x => CovBy a x).Finite\nhb : (Set.Ici b).Infinite\n⊢ Exists fun f => And (Eq (f 0) b) (∀ (i : Nat), CovBy (f i) (f (HAdd.hAdd i 1)))","decl":"/-- The sequence given by Kőnig's lemma as an order embedding -/\ntheorem exists_orderEmbedding_covby_of_forall_covby_finite (hfin : ∀ (a : α), {x | a ⋖ x}.Finite)\n    (hb : (Ici b).Infinite) : ∃ f : ℕ ↪o α, f 0 = b ∧ ∀ i, f i ⋖ f (i+1) := by\n  obtain ⟨f, hf⟩ := exists_seq_covby_of_forall_covby_finite hfin hb\n  exact ⟨OrderEmbedding.ofStrictMono f (strictMono_nat_of_lt_succ (fun i ↦ (hf.2 i).lt)), hf⟩\n\n"}
{"name":"exists_orderEmbedding_covby_of_forall_covby_finite_of_bot","module":"Mathlib.Order.KonigLemma","initialProofState":"α : Type u_1\ninst✝³ : PartialOrder α\ninst✝² : IsStronglyAtomic α\ninst✝¹ : OrderBot α\ninst✝ : Infinite α\nhfin : ∀ (a : α), (setOf fun x => CovBy a x).Finite\n⊢ Exists fun f => And (Eq (f 0) Bot.bot) (∀ (i : Nat), CovBy (f i) (f (HAdd.hAdd i 1)))","decl":"/-- A version of Kőnig's lemma where the sequence starts at the minimum of an infinite order. -/\ntheorem exists_orderEmbedding_covby_of_forall_covby_finite_of_bot [OrderBot α] [Infinite α]\n    (hfin : ∀ (a : α), {x | a ⋖ x}.Finite) : ∃ f : ℕ ↪o α, f 0 = ⊥ ∧ ∀ i, f i ⋖ f (i+1) :=\n  exists_orderEmbedding_covby_of_forall_covby_finite hfin (by simpa using infinite_univ)\n\n"}
{"name":"GradeMinOrder.exists_nat_orderEmbedding_of_forall_covby_finite","module":"Mathlib.Order.KonigLemma","initialProofState":"α : Type u_1\ninst✝⁴ : PartialOrder α\ninst✝³ : IsStronglyAtomic α\ninst✝² : GradeMinOrder Nat α\ninst✝¹ : OrderBot α\ninst✝ : Infinite α\nhfin : ∀ (a : α), (setOf fun x => CovBy a x).Finite\n⊢ Exists fun f => And (Eq (f 0) Bot.bot) (And (∀ (i : Nat), CovBy (f i) (f (HAdd.hAdd i 1))) (∀ (i : Nat), Eq (grade Nat (f i)) i))","decl":"theorem GradeMinOrder.exists_nat_orderEmbedding_of_forall_covby_finite\n    [GradeMinOrder ℕ α] [OrderBot α] [Infinite α] (hfin : ∀ (a : α), {x | a ⋖ x}.Finite) :\n    ∃ f : ℕ ↪o α, f 0 = ⊥ ∧ (∀ i, f i ⋖ f (i+1)) ∧ ∀ i, grade ℕ (f i) = i := by\n  obtain ⟨f, h0, hf⟩ := exists_orderEmbedding_covby_of_forall_covby_finite_of_bot hfin\n  refine ⟨f, h0, hf, fun i ↦ ?_⟩\n  induction' i with i ih\n  · simp [h0]\n  · simpa [Order.covBy_iff_add_one_eq, ih, eq_comm] using CovBy.grade ℕ <| hf i\n\n"}
{"name":"exists_seq_forall_proj_of_forall_finite","module":"Mathlib.Order.KonigLemma","initialProofState":"α : Nat → Type u_1\ninst✝¹ : Finite (α 0)\ninst✝ : ∀ (i : Nat), Nonempty (α i)\nπ : {i j : Nat} → LE.le i j → α j → α i\nπ_refl : ∀ ⦃i : Nat⦄ (a : α i), Eq (π ⋯ a) a\nπ_trans : ∀ ⦃i j k : Nat⦄ (hij : LE.le i j) (hjk : LE.le j k) (a : α k), Eq (π hij (π hjk a)) (π ⋯ a)\nhfin : ∀ (i : Nat) (a : α i), (setOf fun b => Eq (π ⋯ b) a).Finite\n⊢ Exists fun f => ∀ ⦃i j : Nat⦄ (hij : LE.le i j), Eq (π hij (f j)) (f i)","decl":"/-- A formulation of Kőnig's infinity lemma, useful in applications.\nGiven a sequence `α 0, α 1, ...` of nonempty types with `α 0` finite,\nand a well-behaved family of projections `π : α j → α i` for all `i ≤ j`,\nif each term in each `α i` is the projection of only finitely many terms in `α (i+1)`,\nthen we can find a sequence `(f 0 : α 0), (f 1 : α 1), ...`\nwhere `f i` is the projection of `f j` for all `i ≤ j`.\n\nIn a typical application, the `α i` are function types with increasingly large domains,\nand `π hij (f : α j)` is the restriction of the domain of `f` to that of `α i`.\nIn this case, the sequence given by the lemma is essentially a function whose domain\nis the limit of the `α i`.\n\nSee also `nonempty_sections_of_finite_cofiltered_system`. -/\ntheorem exists_seq_forall_proj_of_forall_finite {α : ℕ → Type*} [Finite (α 0)] [∀ i, Nonempty (α i)]\n    (π : {i j : ℕ} → (hij : i ≤ j) → α j → α i)\n    (π_refl : ∀ ⦃i⦄ (a : α i), π rfl.le a = a)\n    (π_trans : ∀ ⦃i j k⦄ (hij : i ≤ j) (hjk : j ≤ k) a, π hij (π hjk a) = π (hij.trans hjk) a)\n    (hfin : ∀ i a, {b : α (i+1) | π (Nat.le_add_right i 1) b = a}.Finite) :\n    ∃ f : (i : ℕ) → α i, ∀ ⦃i j⦄ (hij : i ≤ j), π hij (f j) = f i := by\n\n  set αs := (i : ℕ) × α i\n\n  let _ : PartialOrder αs := {\n    le := fun a b ↦ ∃ h, π h b.2 = a.2\n    le_refl := fun a ↦ ⟨rfl.le, π_refl _⟩\n    le_trans := fun _ _ c h h' ↦ ⟨h.1.trans h'.1, by rw [← π_trans h.1 h'.1 c.2, h'.2, h.2]⟩\n    le_antisymm := by\n      rintro ⟨i, a⟩ ⟨j, b⟩ ⟨hij : i ≤ j, hab : π hij b = a⟩ ⟨hji : j ≤ i, hba : π hji a = b⟩\n      obtain rfl := hij.antisymm hji\n      rw [show a = b by rwa [π_refl] at hba] }\n\n  have hcovby : ∀ {a b : αs}, a ⋖ b ↔ a ≤ b ∧ a.1 + 1 = b.1 := by\n    simp only [αs, covBy_iff_lt_and_eq_or_eq, lt_iff_le_and_ne, ne_eq, Sigma.forall, and_assoc,\n      and_congr_right_iff, or_iff_not_imp_left]\n    rintro i a j b ⟨h : i ≤ j, rfl : π h b = a⟩\n    refine ⟨fun ⟨hne, h'⟩ ↦ ?_, ?_⟩\n    · have hle' : i + 1 ≤ j := h.lt_of_ne <| by rintro rfl; simp [π_refl] at hne\n      exact congr_arg Sigma.fst <| h' (i+1) (π hle' b) ⟨by simp, by rw [π_trans]⟩ ⟨hle', by simp⟩\n        (fun h ↦ by apply_fun Sigma.fst at h; simp at h)\n    rintro rfl\n    refine ⟨fun h ↦ by apply_fun Sigma.fst at h; simp at h, ?_⟩\n    rintro j c ⟨hij : i ≤ j, hcb : π _ c = π _ b⟩ ⟨hji : j ≤ i + 1, rfl : π hji b = c⟩ hne\n    replace hne := show i ≠ j by rintro rfl; contradiction\n    obtain rfl := hji.antisymm (hij.lt_of_ne hne)\n    rw [π_refl]\n\n  have : IsStronglyAtomic αs := by\n    simp_rw [isStronglyAtomic_iff, lt_iff_le_and_ne, hcovby]\n    rintro ⟨i, a⟩ ⟨j, b⟩ ⟨⟨hij : i ≤ j, h2 : π hij b = a⟩, hne⟩\n    have hle : i + 1 ≤ j := hij.lt_of_ne (by rintro rfl; simp [← h2, π_refl] at hne)\n    exact ⟨⟨_, π hle b⟩, ⟨⟨by simp, by rw [π_trans, ← h2]⟩, by simp⟩, ⟨hle, by simp⟩⟩\n\n  obtain ⟨a₀, ha₀, ha₀inf⟩ : ∃ a₀ : αs, a₀.1 = 0 ∧ (Ici a₀).Infinite := by\n    obtain ⟨a₀, ha₀⟩ := Finite.exists_infinite_fiber (fun (a : αs) ↦ π (zero_le a.1) a.2)\n    refine ⟨⟨0, a₀⟩, rfl, (infinite_coe_iff.1 ha₀).mono ?_⟩\n    simp only [αs, subset_def, mem_preimage, mem_singleton_iff, mem_Ici, Sigma.forall]\n    exact fun i x h ↦ ⟨zero_le i, h⟩\n\n  have hfin : ∀ (a : αs), {x | a ⋖ x}.Finite := by\n    refine fun ⟨i,a⟩ ↦ ((hfin i a).image (fun b ↦ ⟨_,b⟩)).subset ?_\n    simp only [αs, hcovby, subset_def, mem_setOf_eq, mem_image, and_imp, Sigma.forall]\n    exact fun j b ⟨_, _⟩ hj ↦ ⟨π hj.le b, by rwa [π_trans], by cases hj; rw [π_refl]⟩\n\n  obtain ⟨f, hf0, hf⟩ := exists_orderEmbedding_covby_of_forall_covby_finite hfin ha₀inf\n\n  have hr : ∀ i, (f i).1 = i :=\n    Nat.rec (by rw [hf0, ha₀]) (fun i ih ↦ by rw [← (hcovby.1 (hf i)).2, ih])\n\n  refine ⟨fun i ↦ by rw [← hr i]; exact (f i).2, fun i j hij ↦ ?_⟩\n  convert (f.monotone hij).2 <;>\n  simp [hr]\n\n"}
