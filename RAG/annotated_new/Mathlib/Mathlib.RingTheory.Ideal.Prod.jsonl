{"name":"Ideal.mem_prod","module":"Mathlib.RingTheory.Ideal.Prod","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Semiring R\ninst✝ : Semiring S\nI : Ideal R\nJ : Ideal S\nr : R\ns : S\n⊢ Iff (Membership.mem (I.prod J) { fst := r, snd := s }) (And (Membership.mem I r) (Membership.mem J s))","decl":"@[simp]\ntheorem mem_prod {r : R} {s : S} : (⟨r, s⟩ : R × S) ∈ prod I J ↔ r ∈ I ∧ s ∈ J :=\n  Iff.rfl\n\n"}
{"name":"Ideal.prod_top_top","module":"Mathlib.RingTheory.Ideal.Prod","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Semiring R\ninst✝ : Semiring S\n⊢ Eq (Top.top.prod Top.top) Top.top","decl":"@[simp]\ntheorem prod_top_top : prod (⊤ : Ideal R) (⊤ : Ideal S) = ⊤ :=\n  Ideal.ext <| by simp\n\n"}
{"name":"Ideal.ideal_prod_eq","module":"Mathlib.RingTheory.Ideal.Prod","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Semiring R\ninst✝ : Semiring S\nI : Ideal (Prod R S)\n⊢ Eq I ((Ideal.map (RingHom.fst R S) I).prod (Ideal.map (RingHom.snd R S) I))","decl":"/-- Every ideal of the product ring is of the form `I × J`, where `I` and `J` can be explicitly\n    given as the image under the projection maps. -/\ntheorem ideal_prod_eq (I : Ideal (R × S)) :\n    I = Ideal.prod (map (RingHom.fst R S) I : Ideal R) (map (RingHom.snd R S) I) := by\n  apply Ideal.ext\n  rintro ⟨r, s⟩\n  rw [mem_prod, mem_map_iff_of_surjective (RingHom.fst R S) Prod.fst_surjective,\n    mem_map_iff_of_surjective (RingHom.snd R S) Prod.snd_surjective]\n  refine ⟨fun h => ⟨⟨_, ⟨h, rfl⟩⟩, ⟨_, ⟨h, rfl⟩⟩⟩, ?_⟩\n  rintro ⟨⟨⟨r, s'⟩, ⟨h₁, rfl⟩⟩, ⟨⟨r', s⟩, ⟨h₂, rfl⟩⟩⟩\n  simpa using I.add_mem (I.mul_mem_left (1, 0) h₁) (I.mul_mem_left (0, 1) h₂)\n\n"}
{"name":"Ideal.map_fst_prod","module":"Mathlib.RingTheory.Ideal.Prod","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Semiring R\ninst✝ : Semiring S\nI : Ideal R\nJ : Ideal S\n⊢ Eq (Ideal.map (RingHom.fst R S) (I.prod J)) I","decl":"@[simp]\ntheorem map_fst_prod (I : Ideal R) (J : Ideal S) : map (RingHom.fst R S) (prod I J) = I := by\n  ext x\n  rw [mem_map_iff_of_surjective (RingHom.fst R S) Prod.fst_surjective]\n  exact\n    ⟨by\n      rintro ⟨x, ⟨h, rfl⟩⟩\n      exact h.1, fun h => ⟨⟨x, 0⟩, ⟨⟨h, Ideal.zero_mem _⟩, rfl⟩⟩⟩\n\n"}
{"name":"Ideal.map_snd_prod","module":"Mathlib.RingTheory.Ideal.Prod","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Semiring R\ninst✝ : Semiring S\nI : Ideal R\nJ : Ideal S\n⊢ Eq (Ideal.map (RingHom.snd R S) (I.prod J)) J","decl":"@[simp]\ntheorem map_snd_prod (I : Ideal R) (J : Ideal S) : map (RingHom.snd R S) (prod I J) = J := by\n  ext x\n  rw [mem_map_iff_of_surjective (RingHom.snd R S) Prod.snd_surjective]\n  exact\n    ⟨by\n      rintro ⟨x, ⟨h, rfl⟩⟩\n      exact h.2, fun h => ⟨⟨0, x⟩, ⟨⟨Ideal.zero_mem _, h⟩, rfl⟩⟩⟩\n\n"}
{"name":"Ideal.map_prodComm_prod","module":"Mathlib.RingTheory.Ideal.Prod","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Semiring R\ninst✝ : Semiring S\nI : Ideal R\nJ : Ideal S\n⊢ Eq (Ideal.map (↑RingEquiv.prodComm) (I.prod J)) (J.prod I)","decl":"@[simp]\ntheorem map_prodComm_prod :\n    map ((RingEquiv.prodComm : R × S ≃+* S × R) : R × S →+* S × R) (prod I J) = prod J I := by\n  refine Trans.trans (ideal_prod_eq _) ?_\n  simp [map_map]\n\n"}
{"name":"Ideal.idealProdEquiv_symm_apply","module":"Mathlib.RingTheory.Ideal.Prod","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Semiring R\ninst✝ : Semiring S\nI : Ideal R\nJ : Ideal S\n⊢ Eq (Ideal.idealProdEquiv.symm { fst := I, snd := J }) (I.prod J)","decl":"@[simp]\ntheorem idealProdEquiv_symm_apply (I : Ideal R) (J : Ideal S) :\n    idealProdEquiv.symm ⟨I, J⟩ = prod I J :=\n  rfl\n\n"}
{"name":"Ideal.prod.ext_iff","module":"Mathlib.RingTheory.Ideal.Prod","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Semiring R\ninst✝ : Semiring S\nI I' : Ideal R\nJ J' : Ideal S\n⊢ Iff (Eq (I.prod J) (I'.prod J')) (And (Eq I I') (Eq J J'))","decl":"theorem prod.ext_iff {I I' : Ideal R} {J J' : Ideal S} :\n    prod I J = prod I' J' ↔ I = I' ∧ J = J' := by\n  simp only [← idealProdEquiv_symm_apply, idealProdEquiv.symm.injective.eq_iff, Prod.mk.inj_iff]\n\n"}
{"name":"Ideal.isPrime_of_isPrime_prod_top","module":"Mathlib.RingTheory.Ideal.Prod","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Semiring R\ninst✝ : Semiring S\nI : Ideal R\nh : (I.prod Top.top).IsPrime\n⊢ I.IsPrime","decl":"theorem isPrime_of_isPrime_prod_top {I : Ideal R} (h : (Ideal.prod I (⊤ : Ideal S)).IsPrime) :\n    I.IsPrime := by\n  constructor\n  · contrapose! h\n    rw [h, prod_top_top, isPrime_iff]\n    simp [isPrime_iff, h]\n  · intro x y hxy\n    have : (⟨x, 1⟩ : R × S) * ⟨y, 1⟩ ∈ prod I ⊤ := by\n      rw [Prod.mk_mul_mk, mul_one, mem_prod]\n      exact ⟨hxy, trivial⟩\n    simpa using h.mem_or_mem this\n\n"}
{"name":"Ideal.isPrime_of_isPrime_prod_top'","module":"Mathlib.RingTheory.Ideal.Prod","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Semiring R\ninst✝ : Semiring S\nI : Ideal S\nh : (Top.top.prod I).IsPrime\n⊢ I.IsPrime","decl":"theorem isPrime_of_isPrime_prod_top' {I : Ideal S} (h : (Ideal.prod (⊤ : Ideal R) I).IsPrime) :\n    I.IsPrime := by\n  apply isPrime_of_isPrime_prod_top (S := R)\n  rw [← map_prodComm_prod]\n  -- Note: couldn't synthesize the right instances without the `R` and `S` hints\n  exact map_isPrime_of_equiv (RingEquiv.prodComm (R := R) (S := S))\n\n"}
{"name":"Ideal.isPrime_ideal_prod_top","module":"Mathlib.RingTheory.Ideal.Prod","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Semiring R\ninst✝ : Semiring S\nI : Ideal R\nh : I.IsPrime\n⊢ (I.prod Top.top).IsPrime","decl":"theorem isPrime_ideal_prod_top {I : Ideal R} [h : I.IsPrime] : (prod I (⊤ : Ideal S)).IsPrime := by\n  constructor\n  · rcases h with ⟨h, -⟩\n    contrapose! h\n    rw [← prod_top_top, prod.ext_iff] at h\n    exact h.1\n  rintro ⟨r₁, s₁⟩ ⟨r₂, s₂⟩ ⟨h₁, _⟩\n  cases' h.mem_or_mem h₁ with h h\n  · exact Or.inl ⟨h, trivial⟩\n  · exact Or.inr ⟨h, trivial⟩\n\n"}
{"name":"Ideal.isPrime_ideal_prod_top'","module":"Mathlib.RingTheory.Ideal.Prod","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Semiring R\ninst✝ : Semiring S\nI : Ideal S\nh : I.IsPrime\n⊢ (Top.top.prod I).IsPrime","decl":"theorem isPrime_ideal_prod_top' {I : Ideal S} [h : I.IsPrime] : (prod (⊤ : Ideal R) I).IsPrime := by\n  letI : IsPrime (prod I (⊤ : Ideal R)) := isPrime_ideal_prod_top\n  rw [← map_prodComm_prod]\n  -- Note: couldn't synthesize the right instances without the `R` and `S` hints\n  exact map_isPrime_of_equiv (RingEquiv.prodComm (R := S) (S := R))\n\n"}
{"name":"Ideal.ideal_prod_prime_aux","module":"Mathlib.RingTheory.Ideal.Prod","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Semiring R\ninst✝ : Semiring S\nI : Ideal R\nJ : Ideal S\na✝ : (I.prod J).IsPrime\n⊢ Or (Eq I Top.top) (Eq J Top.top)","decl":"theorem ideal_prod_prime_aux {I : Ideal R} {J : Ideal S} :\n    (Ideal.prod I J).IsPrime → I = ⊤ ∨ J = ⊤ := by\n  contrapose!\n  simp only [ne_top_iff_one, isPrime_iff, not_and, not_forall, not_or]\n  exact fun ⟨hI, hJ⟩ _ => ⟨⟨0, 1⟩, ⟨1, 0⟩, by simp, by simp [hJ], by simp [hI]⟩\n\n"}
{"name":"Ideal.ideal_prod_prime","module":"Mathlib.RingTheory.Ideal.Prod","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Semiring R\ninst✝ : Semiring S\nI : Ideal (Prod R S)\n⊢ Iff I.IsPrime (Or (Exists fun p => And p.IsPrime (Eq I (p.prod Top.top))) (Exists fun p => And p.IsPrime (Eq I (Top.top.prod p))))","decl":"/-- Classification of prime ideals in product rings: the prime ideals of `R × S` are precisely the\n    ideals of the form `p × S` or `R × p`, where `p` is a prime ideal of `R` or `S`. -/\ntheorem ideal_prod_prime (I : Ideal (R × S)) :\n    I.IsPrime ↔\n      (∃ p : Ideal R, p.IsPrime ∧ I = Ideal.prod p ⊤) ∨\n        ∃ p : Ideal S, p.IsPrime ∧ I = Ideal.prod ⊤ p := by\n  constructor\n  · rw [ideal_prod_eq I]\n    intro hI\n    rcases ideal_prod_prime_aux hI with (h | h)\n    · right\n      rw [h] at hI ⊢\n      exact ⟨_, ⟨isPrime_of_isPrime_prod_top' hI, rfl⟩⟩\n    · left\n      rw [h] at hI ⊢\n      exact ⟨_, ⟨isPrime_of_isPrime_prod_top hI, rfl⟩⟩\n  · rintro (⟨p, ⟨h, rfl⟩⟩ | ⟨p, ⟨h, rfl⟩⟩)\n    · exact isPrime_ideal_prod_top\n    · exact isPrime_ideal_prod_top'\n\n"}
