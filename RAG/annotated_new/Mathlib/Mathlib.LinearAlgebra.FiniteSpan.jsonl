{"name":"LinearEquiv.isOfFinOrder_of_finite_of_span_eq_top_of_mapsTo","module":"Mathlib.LinearAlgebra.FiniteSpan","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nΦ : Set M\nhΦ₁ : Φ.Finite\nhΦ₂ : Eq (Submodule.span R Φ) Top.top\ne : LinearEquiv (RingHom.id R) M M\nhe : Set.MapsTo (⇑e) Φ Φ\n⊢ IsOfFinOrder e","decl":"/-- A linear equivalence which preserves a finite spanning set must have finite order. -/\nlemma LinearEquiv.isOfFinOrder_of_finite_of_span_eq_top_of_mapsTo\n    {R M : Type*} [CommSemiring R] [AddCommMonoid M] [Module R M]\n    {Φ : Set M} (hΦ₁ : Φ.Finite) (hΦ₂ : span R Φ = ⊤) {e : M ≃ₗ[R] M} (he : MapsTo e Φ Φ) :\n    IsOfFinOrder e := by\n  replace he : BijOn e Φ Φ := (hΦ₁.injOn_iff_bijOn_of_mapsTo he).mp e.injective.injOn\n  let e' := he.equiv\n  have : Finite Φ := finite_coe_iff.mpr hΦ₁\n  obtain ⟨k, hk₀, hk⟩ := isOfFinOrder_of_finite e'\n  refine ⟨k, hk₀, ?_⟩\n  ext m\n  have hm : m ∈ span R Φ := hΦ₂ ▸ Submodule.mem_top\n  simp only [mul_left_iterate, mul_one, LinearEquiv.coe_one, id_eq]\n  refine Submodule.span_induction (fun x hx ↦ ?_) (by simp)\n    (fun x y _ _ hx hy ↦ by simp [map_add, hx, hy]) (fun t x _ hx ↦ by simp [map_smul, hx]) hm\n  rw [LinearEquiv.pow_apply, ← he.1.coe_iterate_restrict ⟨x, hx⟩ k]\n  replace hk : (e') ^ k = 1 := by simpa [IsPeriodicPt, IsFixedPt] using hk\n  replace hk := Equiv.congr_fun hk ⟨x, hx⟩\n  rwa [Equiv.Perm.coe_one, id_eq, Subtype.ext_iff, Equiv.Perm.coe_pow] at hk\n"}
