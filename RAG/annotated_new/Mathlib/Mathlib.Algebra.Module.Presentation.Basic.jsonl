{"name":"Module.Relations.mk.sizeOf_spec","module":"Mathlib.Algebra.Module.Presentation.Basic","initialProofState":"A : Type u\ninst✝¹ : Ring A\ninst✝ : SizeOf A\nG : Type w₀\nR : Type w₁\nrelation : R → Finsupp G A\n⊢ Eq (SizeOf.sizeOf { G := G, R := R, relation := relation }) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf G)) (SizeOf.sizeOf R))","decl":"/-- Given a ring `A`, this structure involves a family of elements (indexed by a type `R`)\nin a free module `G →₀ A`. This allows to define an `A`-module by generators and relations,\nsee `Relations.Quotient`. -/\n@[nolint checkUnivs]\nstructure Relations where\n  /-- the index type for generators -/\n  G : Type w₀\n  /-- the index type for relations -/\n  R : Type w₁\n  /-- the coefficients of the linear relations that are expected between the generators -/\n  relation (r : R) : G →₀ A\n\n"}
{"name":"Module.Relations.mk.injEq","module":"Mathlib.Algebra.Module.Presentation.Basic","initialProofState":"A : Type u\ninst✝ : Ring A\nG✝ : Type w₀\nR✝ : Type w₁\nrelation✝ : R✝ → Finsupp G✝ A\nG : Type w₀\nR : Type w₁\nrelation : R → Finsupp G A\n⊢ Eq (Eq { G := G✝, R := R✝, relation := relation✝ } { G := G, R := R, relation := relation }) (And (Eq G✝ G) (And (Eq R✝ R) (HEq relation✝ relation)))","decl":"/-- Given a ring `A`, this structure involves a family of elements (indexed by a type `R`)\nin a free module `G →₀ A`. This allows to define an `A`-module by generators and relations,\nsee `Relations.Quotient`. -/\n@[nolint checkUnivs]\nstructure Relations where\n  /-- the index type for generators -/\n  G : Type w₀\n  /-- the index type for relations -/\n  R : Type w₁\n  /-- the coefficients of the linear relations that are expected between the generators -/\n  relation (r : R) : G →₀ A\n\n"}
{"name":"Module.Relations.mk.inj","module":"Mathlib.Algebra.Module.Presentation.Basic","initialProofState":"A : Type u\ninst✝ : Ring A\nG✝ : Type w₀\nR✝ : Type w₁\nrelation✝ : R✝ → Finsupp G✝ A\nG : Type w₀\nR : Type w₁\nrelation : R → Finsupp G A\nx✝ : Eq { G := G✝, R := R✝, relation := relation✝ } { G := G, R := R, relation := relation }\n⊢ And (Eq G✝ G) (And (Eq R✝ R) (HEq relation✝ relation))","decl":"/-- Given a ring `A`, this structure involves a family of elements (indexed by a type `R`)\nin a free module `G →₀ A`. This allows to define an `A`-module by generators and relations,\nsee `Relations.Quotient`. -/\n@[nolint checkUnivs]\nstructure Relations where\n  /-- the index type for generators -/\n  G : Type w₀\n  /-- the index type for relations -/\n  R : Type w₁\n  /-- the coefficients of the linear relations that are expected between the generators -/\n  relation (r : R) : G →₀ A\n\n"}
{"name":"Module.Relations.Quotient.linearMap_ext_iff","module":"Mathlib.Algebra.Module.Presentation.Basic","initialProofState":"A : Type u\ninst✝² : Ring A\nrelations : Module.Relations A\nM : Type v\ninst✝¹ : AddCommGroup M\ninst✝ : Module A M\nf f' : LinearMap (RingHom.id A) relations.Quotient M\n⊢ Iff (Eq f f') (∀ (g : relations.G), Eq (f (relations.toQuotient (Finsupp.single g 1))) (f' (relations.toQuotient (Finsupp.single g 1))))","decl":"variable {relations} in\n@[ext]\nlemma Quotient.linearMap_ext {M : Type v} [AddCommGroup M] [Module A M]\n    {f f' : relations.Quotient →ₗ[A] M}\n    (h : ∀ (g : relations.G), f (relations.toQuotient (Finsupp.single g 1)) =\n      f' (relations.toQuotient (Finsupp.single g 1))) :\n    f = f' :=\n  Submodule.linearMap_qext _ (Finsupp.lhom_ext' (fun g ↦ LinearMap.ext_ring (h g)))\n\n"}
{"name":"Module.Relations.Quotient.linearMap_ext","module":"Mathlib.Algebra.Module.Presentation.Basic","initialProofState":"A : Type u\ninst✝² : Ring A\nrelations : Module.Relations A\nM : Type v\ninst✝¹ : AddCommGroup M\ninst✝ : Module A M\nf f' : LinearMap (RingHom.id A) relations.Quotient M\nh : ∀ (g : relations.G), Eq (f (relations.toQuotient (Finsupp.single g 1))) (f' (relations.toQuotient (Finsupp.single g 1)))\n⊢ Eq f f'","decl":"variable {relations} in\n@[ext]\nlemma Quotient.linearMap_ext {M : Type v} [AddCommGroup M] [Module A M]\n    {f f' : relations.Quotient →ₗ[A] M}\n    (h : ∀ (g : relations.G), f (relations.toQuotient (Finsupp.single g 1)) =\n      f' (relations.toQuotient (Finsupp.single g 1))) :\n    f = f' :=\n  Submodule.linearMap_qext _ (Finsupp.lhom_ext' (fun g ↦ LinearMap.ext_ring (h g)))\n\n"}
{"name":"Module.Relations.surjective_toQuotient","module":"Mathlib.Algebra.Module.Presentation.Basic","initialProofState":"A : Type u\ninst✝ : Ring A\nrelations : Module.Relations A\n⊢ Function.Surjective ⇑relations.toQuotient","decl":"lemma surjective_toQuotient : Function.Surjective relations.toQuotient :=\n  Submodule.mkQ_surjective _\n\n"}
{"name":"Module.Relations.ker_toQuotient","module":"Mathlib.Algebra.Module.Presentation.Basic","initialProofState":"A : Type u\ninst✝ : Ring A\nrelations : Module.Relations A\n⊢ Eq (LinearMap.ker relations.toQuotient) (Submodule.span A (Set.range relations.relation))","decl":"lemma ker_toQuotient :\n    LinearMap.ker relations.toQuotient = Submodule.span A (Set.range relations.relation) :=\n  Submodule.ker_mkQ _\n\n"}
{"name":"Module.Relations.toQuotient_relation","module":"Mathlib.Algebra.Module.Presentation.Basic","initialProofState":"A : Type u\ninst✝ : Ring A\nrelations : Module.Relations A\nr : relations.R\n⊢ Eq (relations.toQuotient (relations.relation r)) 0","decl":"@[simp]\nlemma toQuotient_relation (r : relations.R) :\n    relations.toQuotient (relations.relation r) = 0 := by\n  dsimp only [toQuotient, Quotient]\n  rw [Submodule.mkQ_apply, Submodule.Quotient.mk_eq_zero]\n  exact Submodule.subset_span (by simp)\n\n"}
{"name":"Module.Relations.map_single","module":"Mathlib.Algebra.Module.Presentation.Basic","initialProofState":"A : Type u\ninst✝ : Ring A\nrelations : Module.Relations A\nr : relations.R\n⊢ Eq (relations.map (Finsupp.single r 1)) (relations.relation r)","decl":"@[simp]\nlemma map_single (r : relations.R) :\n    relations.map (Finsupp.single r 1) = relations.relation r := by\n  simp [map]\n\n"}
{"name":"Module.Relations.range_map","module":"Mathlib.Algebra.Module.Presentation.Basic","initialProofState":"A : Type u\ninst✝ : Ring A\nrelations : Module.Relations A\n⊢ Eq (LinearMap.range relations.map) (Submodule.span A (Set.range relations.relation))","decl":"@[simp]\nlemma range_map :\n    LinearMap.range relations.map = Submodule.span A (Set.range relations.relation) :=\n  Finsupp.range_linearCombination _\n\n"}
{"name":"Module.Relations.toQuotient_map","module":"Mathlib.Algebra.Module.Presentation.Basic","initialProofState":"A : Type u\ninst✝ : Ring A\nrelations : Module.Relations A\n⊢ Eq (relations.toQuotient.comp relations.map) 0","decl":"@[simp]\nlemma toQuotient_map : relations.toQuotient.comp relations.map = 0 := by aesop\n\n"}
{"name":"Module.Relations.toQuotient_map_apply","module":"Mathlib.Algebra.Module.Presentation.Basic","initialProofState":"A : Type u\ninst✝ : Ring A\nrelations : Module.Relations A\nx : Finsupp relations.R A\n⊢ Eq (relations.toQuotient (relations.map x)) 0","decl":"@[simp]\nlemma toQuotient_map_apply (x : relations.R →₀ A) :\n    relations.toQuotient (relations.map x) = 0 :=\n  DFunLike.congr_fun relations.toQuotient_map x\n\n"}
{"name":"Module.Relations.Solution.mk.inj","module":"Mathlib.Algebra.Module.Presentation.Basic","initialProofState":"A : Type u\ninst✝² : Ring A\nrelations : Module.Relations A\nM : Type v\ninst✝¹ : AddCommGroup M\ninst✝ : Module A M\nvar✝ : relations.G → M\nlinearCombination_var_relation✝ : ∀ (r : relations.R), Eq ((Finsupp.linearCombination A var✝) (relations.relation r)) 0\nvar : relations.G → M\nlinearCombination_var_relation : ∀ (r : relations.R), Eq ((Finsupp.linearCombination A var) (relations.relation r)) 0\nx✝ : Eq { var := var✝, linearCombination_var_relation := linearCombination_var_relation✝ } { var := var, linearCombination_var_relation := linearCombination_var_relation }\n⊢ Eq var✝ var","decl":"/-- The type of solutions in a module `M` of the equations given by `relations : Relations A`. -/\n@[ext]\nstructure Solution where\n  /-- the image in `M` of each variable -/\n  var (g : relations.G) : M\n  linearCombination_var_relation (r : relations.R) :\n    Finsupp.linearCombination _ var (relations.relation r) = 0\n\n"}
{"name":"Module.Relations.Solution.ext","module":"Mathlib.Algebra.Module.Presentation.Basic","initialProofState":"A : Type u\ninst✝² : Ring A\nrelations : Module.Relations A\nM : Type v\ninst✝¹ : AddCommGroup M\ninst✝ : Module A M\nx y : relations.Solution M\nvar : Eq x.var y.var\n⊢ Eq x y","decl":"/-- The type of solutions in a module `M` of the equations given by `relations : Relations A`. -/\n@[ext]\nstructure Solution where\n  /-- the image in `M` of each variable -/\n  var (g : relations.G) : M\n  linearCombination_var_relation (r : relations.R) :\n    Finsupp.linearCombination _ var (relations.relation r) = 0\n\n"}
{"name":"Module.Relations.Solution.ext_iff","module":"Mathlib.Algebra.Module.Presentation.Basic","initialProofState":"A : Type u\ninst✝² : Ring A\nrelations : Module.Relations A\nM : Type v\ninst✝¹ : AddCommGroup M\ninst✝ : Module A M\nx y : relations.Solution M\n⊢ Iff (Eq x y) (Eq x.var y.var)","decl":"/-- The type of solutions in a module `M` of the equations given by `relations : Relations A`. -/\n@[ext]\nstructure Solution where\n  /-- the image in `M` of each variable -/\n  var (g : relations.G) : M\n  linearCombination_var_relation (r : relations.R) :\n    Finsupp.linearCombination _ var (relations.relation r) = 0\n\n"}
{"name":"Module.Relations.Solution.linearCombination_var_relation","module":"Mathlib.Algebra.Module.Presentation.Basic","initialProofState":"A : Type u\ninst✝² : Ring A\nrelations : Module.Relations A\nM : Type v\ninst✝¹ : AddCommGroup M\ninst✝ : Module A M\nself : relations.Solution M\nr : relations.R\n⊢ Eq ((Finsupp.linearCombination A self.var) (relations.relation r)) 0","decl":"/-- The type of solutions in a module `M` of the equations given by `relations : Relations A`. -/\n@[ext]\nstructure Solution where\n  /-- the image in `M` of each variable -/\n  var (g : relations.G) : M\n  linearCombination_var_relation (r : relations.R) :\n    Finsupp.linearCombination _ var (relations.relation r) = 0\n\n"}
{"name":"Module.Relations.Solution.mk.injEq","module":"Mathlib.Algebra.Module.Presentation.Basic","initialProofState":"A : Type u\ninst✝² : Ring A\nrelations : Module.Relations A\nM : Type v\ninst✝¹ : AddCommGroup M\ninst✝ : Module A M\nvar✝ : relations.G → M\nlinearCombination_var_relation✝ : ∀ (r : relations.R), Eq ((Finsupp.linearCombination A var✝) (relations.relation r)) 0\nvar : relations.G → M\nlinearCombination_var_relation : ∀ (r : relations.R), Eq ((Finsupp.linearCombination A var) (relations.relation r)) 0\n⊢ Eq (Eq { var := var✝, linearCombination_var_relation := linearCombination_var_relation✝ } { var := var, linearCombination_var_relation := linearCombination_var_relation }) (Eq var✝ var)","decl":"/-- The type of solutions in a module `M` of the equations given by `relations : Relations A`. -/\n@[ext]\nstructure Solution where\n  /-- the image in `M` of each variable -/\n  var (g : relations.G) : M\n  linearCombination_var_relation (r : relations.R) :\n    Finsupp.linearCombination _ var (relations.relation r) = 0\n\n"}
{"name":"Module.Relations.Solution.mk.sizeOf_spec","module":"Mathlib.Algebra.Module.Presentation.Basic","initialProofState":"A : Type u\ninst✝⁴ : Ring A\nrelations : Module.Relations A\nM : Type v\ninst✝³ : AddCommGroup M\ninst✝² : Module A M\ninst✝¹ : SizeOf A\ninst✝ : SizeOf M\nvar : relations.G → M\nlinearCombination_var_relation : ∀ (r : relations.R), Eq ((Finsupp.linearCombination A var) (relations.relation r)) 0\n⊢ Eq (SizeOf.sizeOf { var := var, linearCombination_var_relation := linearCombination_var_relation }) 1","decl":"/-- The type of solutions in a module `M` of the equations given by `relations : Relations A`. -/\n@[ext]\nstructure Solution where\n  /-- the image in `M` of each variable -/\n  var (g : relations.G) : M\n  linearCombination_var_relation (r : relations.R) :\n    Finsupp.linearCombination _ var (relations.relation r) = 0\n\n"}
{"name":"Module.Relations.Solution.π_single","module":"Mathlib.Algebra.Module.Presentation.Basic","initialProofState":"A : Type u\ninst✝² : Ring A\nrelations : Module.Relations A\nM : Type v\ninst✝¹ : AddCommGroup M\ninst✝ : Module A M\nsolution : relations.Solution M\ng : relations.G\n⊢ Eq (solution.π (Finsupp.single g 1)) (solution.var g)","decl":"@[simp]\nlemma π_single (g : relations.G) :\n    solution.π (Finsupp.single g 1) = solution.var g := by simp [π]\n\n"}
{"name":"Module.Relations.Solution.π_relation","module":"Mathlib.Algebra.Module.Presentation.Basic","initialProofState":"A : Type u\ninst✝² : Ring A\nrelations : Module.Relations A\nM : Type v\ninst✝¹ : AddCommGroup M\ninst✝ : Module A M\nsolution : relations.Solution M\nr : relations.R\n⊢ Eq (solution.π (relations.relation r)) 0","decl":"@[simp]\nlemma π_relation (r : relations.R) : solution.π (relations.relation r) = 0 :=\n  solution.linearCombination_var_relation r\n\n"}
{"name":"Module.Relations.Solution.π_comp_map","module":"Mathlib.Algebra.Module.Presentation.Basic","initialProofState":"A : Type u\ninst✝² : Ring A\nrelations : Module.Relations A\nM : Type v\ninst✝¹ : AddCommGroup M\ninst✝ : Module A M\nsolution : relations.Solution M\n⊢ Eq (solution.π.comp relations.map) 0","decl":"@[simp]\nlemma π_comp_map : solution.π.comp relations.map = 0 := by aesop\n\n"}
{"name":"Module.Relations.Solution.π_comp_map_apply","module":"Mathlib.Algebra.Module.Presentation.Basic","initialProofState":"A : Type u\ninst✝² : Ring A\nrelations : Module.Relations A\nM : Type v\ninst✝¹ : AddCommGroup M\ninst✝ : Module A M\nsolution : relations.Solution M\nx : Finsupp relations.R A\n⊢ Eq (solution.π (relations.map x)) 0","decl":"@[simp]\nlemma π_comp_map_apply (x : relations.R →₀ A) : solution.π (relations.map x) = 0 := by\n  change solution.π.comp relations.map x = 0\n  rw [π_comp_map, LinearMap.zero_apply]\n\n"}
{"name":"Module.Relations.Solution.range_π","module":"Mathlib.Algebra.Module.Presentation.Basic","initialProofState":"A : Type u\ninst✝² : Ring A\nrelations : Module.Relations A\nM : Type v\ninst✝¹ : AddCommGroup M\ninst✝ : Module A M\nsolution : relations.Solution M\n⊢ Eq (LinearMap.range solution.π) (Submodule.span A (Set.range solution.var))","decl":"lemma range_π : LinearMap.range solution.π = Submodule.span A (Set.range solution.var) :=\n  Finsupp.range_linearCombination _\n\n"}
{"name":"Module.Relations.Solution.span_relation_le_ker_π","module":"Mathlib.Algebra.Module.Presentation.Basic","initialProofState":"A : Type u\ninst✝² : Ring A\nrelations : Module.Relations A\nM : Type v\ninst✝¹ : AddCommGroup M\ninst✝ : Module A M\nsolution : relations.Solution M\n⊢ LE.le (Submodule.span A (Set.range relations.relation)) (LinearMap.ker solution.π)","decl":"lemma span_relation_le_ker_π :\n    Submodule.span A (Set.range relations.relation) ≤ LinearMap.ker solution.π := by\n  rw [Submodule.span_le]\n  rintro _ ⟨r, rfl⟩\n  simp only [SetLike.mem_coe, LinearMap.mem_ker, π_relation]\n\n"}
{"name":"Module.Relations.Solution.fromQuotient_comp_toQuotient","module":"Mathlib.Algebra.Module.Presentation.Basic","initialProofState":"A : Type u\ninst✝² : Ring A\nrelations : Module.Relations A\nM : Type v\ninst✝¹ : AddCommGroup M\ninst✝ : Module A M\nsolution : relations.Solution M\n⊢ Eq (solution.fromQuotient.comp relations.toQuotient) solution.π","decl":"@[simp]\nlemma fromQuotient_comp_toQuotient :\n    solution.fromQuotient.comp relations.toQuotient = solution.π := rfl\n\n"}
{"name":"Module.Relations.Solution.fromQuotient_toQuotient","module":"Mathlib.Algebra.Module.Presentation.Basic","initialProofState":"A : Type u\ninst✝² : Ring A\nrelations : Module.Relations A\nM : Type v\ninst✝¹ : AddCommGroup M\ninst✝ : Module A M\nsolution : relations.Solution M\nx : Finsupp relations.G A\n⊢ Eq (solution.fromQuotient (relations.toQuotient x)) (solution.π x)","decl":"@[simp]\nlemma fromQuotient_toQuotient (x : relations.G →₀ A) :\n    solution.fromQuotient (relations.toQuotient x) = solution.π x := rfl\n\n"}
{"name":"Module.Relations.Solution.postcomp_var","module":"Mathlib.Algebra.Module.Presentation.Basic","initialProofState":"A : Type u\ninst✝⁴ : Ring A\nrelations : Module.Relations A\nM : Type v\ninst✝³ : AddCommGroup M\ninst✝² : Module A M\nsolution : relations.Solution M\nN : Type v'\ninst✝¹ : AddCommGroup N\ninst✝ : Module A N\nf : LinearMap (RingHom.id A) M N\ng : relations.G\n⊢ Eq ((solution.postcomp f).var g) (f (solution.var g))","decl":"/-- The image of a solution to `relations : Relation A` by a linear map `M →ₗ[A] N`. -/\n@[simps]\ndef postcomp : relations.Solution N where\n  var g := f (solution.var g)\n  linearCombination_var_relation r := by\n    have : Finsupp.linearCombination _ (fun g ↦ f (solution.var g)) = f.comp solution.π := by aesop\n    simp [this]\n\n"}
{"name":"Module.Relations.Solution.postcomp_comp","module":"Mathlib.Algebra.Module.Presentation.Basic","initialProofState":"A : Type u\ninst✝⁶ : Ring A\nrelations : Module.Relations A\nM : Type v\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module A M\nsolution : relations.Solution M\nN : Type v'\ninst✝³ : AddCommGroup N\ninst✝² : Module A N\nf : LinearMap (RingHom.id A) M N\nN' : Type v''\ninst✝¹ : AddCommGroup N'\ninst✝ : Module A N'\ng : LinearMap (RingHom.id A) N N'\n⊢ Eq (solution.postcomp (g.comp f)) ((solution.postcomp f).postcomp g)","decl":"@[simp]\nlemma postcomp_comp {N' : Type v''} [AddCommGroup N'] [Module A N'] (g : N →ₗ[A] N') :\n    solution.postcomp (g.comp f) = (solution.postcomp f).postcomp g := rfl\n\n"}
{"name":"Module.Relations.Solution.postcomp_id","module":"Mathlib.Algebra.Module.Presentation.Basic","initialProofState":"A : Type u\ninst✝² : Ring A\nrelations : Module.Relations A\nM : Type v\ninst✝¹ : AddCommGroup M\ninst✝ : Module A M\nsolution : relations.Solution M\n⊢ Eq (solution.postcomp LinearMap.id) solution","decl":"@[simp]\nlemma postcomp_id : solution.postcomp LinearMap.id = solution := rfl\n\n"}
{"name":"Module.Relations.Solution.congr_var","module":"Mathlib.Algebra.Module.Presentation.Basic","initialProofState":"A : Type u\ninst✝² : Ring A\nrelations : Module.Relations A\nM : Type v\ninst✝¹ : AddCommGroup M\ninst✝ : Module A M\nsolution solution' : relations.Solution M\nh : Eq solution solution'\ng : relations.G\n⊢ Eq (solution.var g) (solution'.var g)","decl":"lemma congr_var {solution' : relations.Solution M} (h : solution = solution') (g : relations.G) :\n    solution.var g = solution'.var g := by rw [h]\n\n"}
{"name":"Module.Relations.Solution.congr_postcomp","module":"Mathlib.Algebra.Module.Presentation.Basic","initialProofState":"A : Type u\ninst✝⁴ : Ring A\nrelations : Module.Relations A\nM : Type v\ninst✝³ : AddCommGroup M\ninst✝² : Module A M\nsolution : relations.Solution M\nN : Type v'\ninst✝¹ : AddCommGroup N\ninst✝ : Module A N\nsolution' : relations.Solution M\nh : Eq solution solution'\nf : LinearMap (RingHom.id A) M N\n⊢ Eq (solution.postcomp f) (solution'.postcomp f)","decl":"lemma congr_postcomp {solution' : relations.Solution M} (h : solution = solution')\n    (f : M →ₗ[A] N) : solution.postcomp f = solution'.postcomp f := by rw [h]\n\n"}
{"name":"Module.Relations.Solution.ofπ_var","module":"Mathlib.Algebra.Module.Presentation.Basic","initialProofState":"A : Type u\ninst✝² : Ring A\nrelations : Module.Relations A\nM : Type v\ninst✝¹ : AddCommGroup M\ninst✝ : Module A M\nπ : LinearMap (RingHom.id A) (Finsupp relations.G A) M\ng : relations.G\n⊢ Eq ((Module.Relations.Solution.ofπ π).var g) (π (Finsupp.single g 1))","decl":"/-- Given `relations : Relations A` and an `A`-module `M`, this is a constructor\nfor `relations.Solution M` for which the data is given as\na linear map `π : (relations.G →₀ A) →ₗ[A] M`. (See also `ofπ'` for an alternate\nvanishing criterion.) -/\n@[simps (config := .lemmasOnly)]\nnoncomputable def ofπ : relations.Solution M where\n  var g := π (Finsupp.single g 1)\n  linearCombination_var_relation r := by\n    have : π = Finsupp.linearCombination _ (fun g ↦ π (Finsupp.single g 1)) := by ext; simp\n    rw [← this]\n    exact hπ r\n\n"}
{"name":"Module.Relations.Solution.ofπ_π","module":"Mathlib.Algebra.Module.Presentation.Basic","initialProofState":"A : Type u\ninst✝² : Ring A\nrelations : Module.Relations A\nM : Type v\ninst✝¹ : AddCommGroup M\ninst✝ : Module A M\nπ : LinearMap (RingHom.id A) (Finsupp relations.G A) M\n⊢ Eq (sorryAx (Unit → LinearMap (RingHom.id A) (Finsupp relations.G A) M) Bool.true (Function.const Lean.Name Unit.unit ((((((((((Lean.Name.anonymous.num 226).num 14).num 226).num 26).num 14).num 26).str \"_sorry\").str \"_@\").str \"_hyg\").num 1506))) π","decl":"@[simp]\nlemma ofπ_π : (ofπ π hπ).π = π := by ext; simp [ofπ]\n\n"}
{"name":"Module.Relations.Solution.ofπ'_π","module":"Mathlib.Algebra.Module.Presentation.Basic","initialProofState":"A : Type u\ninst✝² : Ring A\nrelations : Module.Relations A\nM : Type v\ninst✝¹ : AddCommGroup M\ninst✝ : Module A M\nπ : LinearMap (RingHom.id A) (Finsupp relations.G A) M\n⊢ Eq (sorryAx (Unit → LinearMap (RingHom.id A) (Finsupp relations.G A) M) Bool.true (Function.const Lean.Name Unit.unit ((((((((((Lean.Name.anonymous.num 242).num 15).num 242).num 28).num 15).num 28).str \"_sorry\").str \"_@\").str \"_hyg\").num 1716))) π","decl":"@[simp]\nlemma ofπ'_π : (ofπ' π hπ).π = π := by simp [ofπ']\n\n"}
{"name":"Module.Relations.Solution.injective_fromQuotient_iff_ker_π_eq_span","module":"Mathlib.Algebra.Module.Presentation.Basic","initialProofState":"A : Type u\ninst✝² : Ring A\nrelations : Module.Relations A\nM : Type v\ninst✝¹ : AddCommGroup M\ninst✝ : Module A M\nsolution : relations.Solution M\n⊢ Iff (Function.Injective ⇑solution.fromQuotient) (Eq (LinearMap.ker solution.π) (Submodule.span A (Set.range relations.relation)))","decl":"lemma injective_fromQuotient_iff_ker_π_eq_span :\n    Function.Injective solution.fromQuotient ↔\n      LinearMap.ker solution.π = Submodule.span A (Set.range relations.relation) := by\n  constructor\n  · intro h\n    rw [← ker_toQuotient, ← fromQuotient_comp_toQuotient, LinearMap.ker_comp,\n      LinearMap.ker_eq_bot.2 h, Submodule.comap_bot]\n  · intro h\n    rw [← LinearMap.ker_eq_bot, eq_bot_iff]\n    intro x hx\n    obtain ⟨x, rfl⟩ := relations.surjective_toQuotient x\n    replace hx : x ∈ LinearMap.ker solution.π := by\n      simpa only [LinearMap.mem_ker, fromQuotient_toQuotient] using hx\n    rw [h, ← range_map] at hx\n    obtain ⟨x, rfl⟩ := hx\n    simp only [toQuotient_map_apply, Submodule.zero_mem]\n\n"}
{"name":"Module.Relations.Solution.surjective_fromQuotient_iff_surjective_π","module":"Mathlib.Algebra.Module.Presentation.Basic","initialProofState":"A : Type u\ninst✝² : Ring A\nrelations : Module.Relations A\nM : Type v\ninst✝¹ : AddCommGroup M\ninst✝ : Module A M\nsolution : relations.Solution M\n⊢ Iff (Function.Surjective ⇑solution.fromQuotient) (Function.Surjective ⇑solution.π)","decl":"lemma surjective_fromQuotient_iff_surjective_π :\n    Function.Surjective solution.fromQuotient ↔ Function.Surjective solution.π := by\n  simpa only [← fromQuotient_comp_toQuotient] using\n    (Function.Surjective.of_comp_iff (f := solution.fromQuotient)\n      relations.surjective_toQuotient).symm\n\n"}
{"name":"Module.Relations.Solution.surjective_π_iff_span_eq_top","module":"Mathlib.Algebra.Module.Presentation.Basic","initialProofState":"A : Type u\ninst✝² : Ring A\nrelations : Module.Relations A\nM : Type v\ninst✝¹ : AddCommGroup M\ninst✝ : Module A M\nsolution : relations.Solution M\n⊢ Iff (Function.Surjective ⇑solution.π) (Eq (Submodule.span A (Set.range solution.var)) Top.top)","decl":"lemma surjective_π_iff_span_eq_top :\n    Function.Surjective solution.π ↔\n      Submodule.span A (Set.range solution.var) = ⊤ := by\n  rw [← LinearMap.range_eq_top, range_π]\n\n"}
{"name":"Module.Relations.Solution.IsPresentation.bijective","module":"Mathlib.Algebra.Module.Presentation.Basic","initialProofState":"A : Type u\ninst✝² : Ring A\nrelations : Module.Relations A\nM : Type v\ninst✝¹ : AddCommGroup M\ninst✝ : Module A M\nsolution : relations.Solution M\nself : solution.IsPresentation\n⊢ Function.Bijective ⇑solution.fromQuotient","decl":"/-- Given `relations : Relations A`, an `A`-module `M` and `solution : relations.Solution M`,\nthis property asserts that `solution` gives a presentation of `M` by generators and relations. -/\nstructure IsPresentation (solution : relations.Solution M) : Prop where\n  bijective : Function.Bijective solution.fromQuotient\n\n"}
{"name":"Module.Relations.Solution.IsPresentation.linearEquiv_apply","module":"Mathlib.Algebra.Module.Presentation.Basic","initialProofState":"A : Type u\ninst✝² : Ring A\nrelations : Module.Relations A\nM : Type v\ninst✝¹ : AddCommGroup M\ninst✝ : Module A M\nsolution : relations.Solution M\nh : solution.IsPresentation\nx : relations.Quotient\n⊢ Eq (h.linearEquiv x) (solution.fromQuotient x)","decl":"@[simp]\nlemma linearEquiv_apply (x : relations.Quotient) :\n    h.linearEquiv x = solution.fromQuotient x := rfl\n\n"}
{"name":"Module.Relations.Solution.IsPresentation.linearEquiv_symm_var","module":"Mathlib.Algebra.Module.Presentation.Basic","initialProofState":"A : Type u\ninst✝² : Ring A\nrelations : Module.Relations A\nM : Type v\ninst✝¹ : AddCommGroup M\ninst✝ : Module A M\nsolution : relations.Solution M\nh : solution.IsPresentation\ng : relations.G\n⊢ Eq (h.linearEquiv.symm (solution.var g)) (relations.toQuotient (Finsupp.single g 1))","decl":"@[simp]\nlemma linearEquiv_symm_var (g : relations.G) :\n    h.linearEquiv.symm (solution.var g) = relations.toQuotient (Finsupp.single g 1) :=\n  h.linearEquiv.injective (by simp)\n\n"}
{"name":"Module.Relations.Solution.IsPresentation.surjective_π","module":"Mathlib.Algebra.Module.Presentation.Basic","initialProofState":"A : Type u\ninst✝² : Ring A\nrelations : Module.Relations A\nM : Type v\ninst✝¹ : AddCommGroup M\ninst✝ : Module A M\nsolution : relations.Solution M\nh : solution.IsPresentation\n⊢ Function.Surjective ⇑solution.π","decl":"lemma surjective_π : Function.Surjective solution.π := by\n  simpa only [← surjective_fromQuotient_iff_surjective_π] using h.bijective.2\n\n"}
{"name":"Module.Relations.Solution.IsPresentation.ker_π","module":"Mathlib.Algebra.Module.Presentation.Basic","initialProofState":"A : Type u\ninst✝² : Ring A\nrelations : Module.Relations A\nM : Type v\ninst✝¹ : AddCommGroup M\ninst✝ : Module A M\nsolution : relations.Solution M\nh : solution.IsPresentation\n⊢ Eq (LinearMap.ker solution.π) (Submodule.span A (Set.range relations.relation))","decl":"lemma ker_π : LinearMap.ker solution.π = Submodule.span A (Set.range relations.relation) := by\n  simpa only [← injective_fromQuotient_iff_ker_π_eq_span] using h.bijective.1\n\n"}
{"name":"Module.Relations.Solution.IsPresentation.exact","module":"Mathlib.Algebra.Module.Presentation.Basic","initialProofState":"A : Type u\ninst✝² : Ring A\nrelations : Module.Relations A\nM : Type v\ninst✝¹ : AddCommGroup M\ninst✝ : Module A M\nsolution : relations.Solution M\nh : solution.IsPresentation\n⊢ Function.Exact ⇑relations.map ⇑solution.π","decl":"/-- The sequence `(relations.R →₀ A) → (relations.G →₀ A) → M → 0` is exact. -/\nlemma exact : Function.Exact relations.map solution.π := by\n  rw [LinearMap.exact_iff, range_map, ← solution.injective_fromQuotient_iff_ker_π_eq_span]\n  exact h.bijective.1\n\n"}
{"name":"Module.Relations.Solution.IsPresentation.desc_var","module":"Mathlib.Algebra.Module.Presentation.Basic","initialProofState":"A : Type u\ninst✝⁴ : Ring A\nrelations : Module.Relations A\nM : Type v\ninst✝³ : AddCommGroup M\ninst✝² : Module A M\nsolution : relations.Solution M\nh : solution.IsPresentation\nN : Type v'\ninst✝¹ : AddCommGroup N\ninst✝ : Module A N\ns : relations.Solution N\ng : relations.G\n⊢ Eq ((h.desc s) (solution.var g)) (s.var g)","decl":"@[simp]\nlemma desc_var (s : relations.Solution N) (g : relations.G) :\n    h.desc s (solution.var g) = s.var g := by\n  dsimp [desc]\n  simp only [linearEquiv_symm_var, fromQuotient_toQuotient, π_single]\n\n"}
{"name":"Module.Relations.Solution.IsPresentation.desc_comp_π","module":"Mathlib.Algebra.Module.Presentation.Basic","initialProofState":"A : Type u\ninst✝⁴ : Ring A\nrelations : Module.Relations A\nM : Type v\ninst✝³ : AddCommGroup M\ninst✝² : Module A M\nsolution : relations.Solution M\nh : solution.IsPresentation\nN : Type v'\ninst✝¹ : AddCommGroup N\ninst✝ : Module A N\ns : relations.Solution N\n⊢ Eq ((h.desc s).comp solution.π) s.π","decl":"@[simp]\nlemma desc_comp_π (s : relations.Solution N) : (h.desc s).comp solution.π = s.π := by aesop\n\n"}
{"name":"Module.Relations.Solution.IsPresentation.π_desc_apply","module":"Mathlib.Algebra.Module.Presentation.Basic","initialProofState":"A : Type u\ninst✝⁴ : Ring A\nrelations : Module.Relations A\nM : Type v\ninst✝³ : AddCommGroup M\ninst✝² : Module A M\nsolution : relations.Solution M\nh : solution.IsPresentation\nN : Type v'\ninst✝¹ : AddCommGroup N\ninst✝ : Module A N\ns : relations.Solution N\nx : Finsupp relations.G A\n⊢ Eq ((h.desc s) (solution.π x)) (s.π x)","decl":"@[simp]\nlemma π_desc_apply (s : relations.Solution N) (x : relations.G →₀ A) :\n    h.desc s (solution.π x) = s.π x :=\n  DFunLike.congr_fun (h.desc_comp_π s) x\n\n"}
{"name":"Module.Relations.Solution.IsPresentation.postcomp_desc","module":"Mathlib.Algebra.Module.Presentation.Basic","initialProofState":"A : Type u\ninst✝⁴ : Ring A\nrelations : Module.Relations A\nM : Type v\ninst✝³ : AddCommGroup M\ninst✝² : Module A M\nsolution : relations.Solution M\nh : solution.IsPresentation\nN : Type v'\ninst✝¹ : AddCommGroup N\ninst✝ : Module A N\ns : relations.Solution N\n⊢ Eq (solution.postcomp (h.desc s)) s","decl":"@[simp]\nlemma postcomp_desc (s : relations.Solution N) :\n    solution.postcomp (h.desc s) = s := by aesop\n\n"}
{"name":"Module.Relations.Solution.IsPresentation.postcomp_injective","module":"Mathlib.Algebra.Module.Presentation.Basic","initialProofState":"A : Type u\ninst✝⁴ : Ring A\nrelations : Module.Relations A\nM : Type v\ninst✝³ : AddCommGroup M\ninst✝² : Module A M\nsolution : relations.Solution M\nh : solution.IsPresentation\nN : Type v'\ninst✝¹ : AddCommGroup N\ninst✝ : Module A N\nf f' : LinearMap (RingHom.id A) M N\nh' : Eq (solution.postcomp f) (solution.postcomp f')\n⊢ Eq f f'","decl":"lemma postcomp_injective {f f' : M →ₗ[A] N}\n    (h' : solution.postcomp f = solution.postcomp f') : f = f' := by\n  suffices f.comp solution.fromQuotient = f'.comp solution.fromQuotient by\n    ext x\n    obtain ⟨y, rfl⟩ := h.bijective.2 x\n    exact DFunLike.congr_fun this y\n  ext g\n  simpa using congr_var h' g\n\n"}
{"name":"Module.Relations.Solution.IsPresentation.linearMapEquiv_symm_apply","module":"Mathlib.Algebra.Module.Presentation.Basic","initialProofState":"A : Type u\ninst✝⁴ : Ring A\nrelations : Module.Relations A\nM : Type v\ninst✝³ : AddCommGroup M\ninst✝² : Module A M\nsolution : relations.Solution M\nh : solution.IsPresentation\nN : Type v'\ninst✝¹ : AddCommGroup N\ninst✝ : Module A N\ns : relations.Solution N\n⊢ Eq (h.linearMapEquiv.symm s) (h.desc s)","decl":"/-- If `M` admits a presentation by generators and relations, then\nlinear maps from `M` can be (naturally) identified to the solutions of\ncertain linear equations. -/\n@[simps]\nnoncomputable def linearMapEquiv : (M →ₗ[A] N) ≃ relations.Solution N where\n  toFun f := solution.postcomp f\n  invFun s := h.desc s\n  left_inv f := h.postcomp_injective (by simp)\n  right_inv s := by simp\n\n"}
{"name":"Module.Relations.Solution.IsPresentation.linearMapEquiv_apply","module":"Mathlib.Algebra.Module.Presentation.Basic","initialProofState":"A : Type u\ninst✝⁴ : Ring A\nrelations : Module.Relations A\nM : Type v\ninst✝³ : AddCommGroup M\ninst✝² : Module A M\nsolution : relations.Solution M\nh : solution.IsPresentation\nN : Type v'\ninst✝¹ : AddCommGroup N\ninst✝ : Module A N\nf : LinearMap (RingHom.id A) M N\n⊢ Eq (h.linearMapEquiv f) (solution.postcomp f)","decl":"/-- If `M` admits a presentation by generators and relations, then\nlinear maps from `M` can be (naturally) identified to the solutions of\ncertain linear equations. -/\n@[simps]\nnoncomputable def linearMapEquiv : (M →ₗ[A] N) ≃ relations.Solution N where\n  toFun f := solution.postcomp f\n  invFun s := h.desc s\n  left_inv f := h.postcomp_injective (by simp)\n  right_inv s := by simp\n\n"}
{"name":"Module.Relations.Solution.IsPresentation.postcomp_uniq","module":"Mathlib.Algebra.Module.Presentation.Basic","initialProofState":"A : Type u\ninst✝⁴ : Ring A\nrelations : Module.Relations A\nM : Type v\ninst✝³ : AddCommGroup M\ninst✝² : Module A M\nsolution : relations.Solution M\nh : solution.IsPresentation\nN : Type v'\ninst✝¹ : AddCommGroup N\ninst✝ : Module A N\nsolution' : relations.Solution N\nh' : solution'.IsPresentation\n⊢ Eq (solution.postcomp ↑(h.uniq h')) solution'","decl":"@[simp]\nlemma postcomp_uniq : solution.postcomp (uniq h h').toLinearMap = solution' := by\n  simp [uniq]\n\n"}
{"name":"Module.Relations.Solution.IsPresentation.postcomp_uniq_symm","module":"Mathlib.Algebra.Module.Presentation.Basic","initialProofState":"A : Type u\ninst✝⁴ : Ring A\nrelations : Module.Relations A\nM : Type v\ninst✝³ : AddCommGroup M\ninst✝² : Module A M\nsolution : relations.Solution M\nh : solution.IsPresentation\nN : Type v'\ninst✝¹ : AddCommGroup N\ninst✝ : Module A N\nsolution' : relations.Solution N\nh' : solution'.IsPresentation\n⊢ Eq (solution'.postcomp ↑(h.uniq h').symm) solution","decl":"@[simp]\nlemma postcomp_uniq_symm : solution'.postcomp (uniq h h').symm.toLinearMap = solution := by\n  simp [uniq]\n\n"}
{"name":"Module.Relations.Solution.IsPresentation.uniq_var","module":"Mathlib.Algebra.Module.Presentation.Basic","initialProofState":"A : Type u\ninst✝⁴ : Ring A\nrelations : Module.Relations A\nM : Type v\ninst✝³ : AddCommGroup M\ninst✝² : Module A M\nsolution : relations.Solution M\nh : solution.IsPresentation\nN : Type v'\ninst✝¹ : AddCommGroup N\ninst✝ : Module A N\nsolution' : relations.Solution N\nh' : solution'.IsPresentation\ng : relations.G\n⊢ Eq ((h.uniq h') (solution.var g)) (solution'.var g)","decl":"@[simp]\nlemma uniq_var (g : relations.G) : uniq h h' (solution.var g) = solution'.var g := by\n  simp [uniq]\n\n"}
{"name":"Module.Relations.Solution.IsPresentation.uniq_symm_var","module":"Mathlib.Algebra.Module.Presentation.Basic","initialProofState":"A : Type u\ninst✝⁴ : Ring A\nrelations : Module.Relations A\nM : Type v\ninst✝³ : AddCommGroup M\ninst✝² : Module A M\nsolution : relations.Solution M\nh : solution.IsPresentation\nN : Type v'\ninst✝¹ : AddCommGroup N\ninst✝ : Module A N\nsolution' : relations.Solution N\nh' : solution'.IsPresentation\ng : relations.G\n⊢ Eq ((h.uniq h').symm (solution'.var g)) (solution.var g)","decl":"@[simp]\nlemma uniq_symm_var (g : relations.G) : (uniq h h').symm (solution'.var g) = solution.var g := by\n  simp [uniq]\n\n"}
{"name":"Module.Relations.Solution.IsPresentation.of_linearEquiv","module":"Mathlib.Algebra.Module.Presentation.Basic","initialProofState":"A : Type u\ninst✝⁴ : Ring A\nrelations : Module.Relations A\nM : Type v\ninst✝³ : AddCommGroup M\ninst✝² : Module A M\nsolution : relations.Solution M\nh : solution.IsPresentation\nN : Type v'\ninst✝¹ : AddCommGroup N\ninst✝ : Module A N\ne : LinearEquiv (RingHom.id A) M N\n⊢ (solution.postcomp ↑e).IsPresentation","decl":"lemma of_linearEquiv (e : M ≃ₗ[A] N) : (solution.postcomp e.toLinearMap).IsPresentation where\n  bijective := by\n    have : (solution.postcomp e.toLinearMap).fromQuotient =\n      e.toLinearMap.comp (solution.fromQuotient) := by aesop\n    rw [this, LinearMap.coe_comp, LinearEquiv.coe_coe]\n    exact Function.Bijective.comp e.bijective h.bijective\n\n"}
{"name":"Module.Relations.Solution.ofQuotient_π","module":"Mathlib.Algebra.Module.Presentation.Basic","initialProofState":"A : Type u\ninst✝ : Ring A\nrelations : Module.Relations A\n⊢ Eq (Module.Relations.Solution.ofQuotient relations).π (Submodule.span A (Set.range relations.relation)).mkQ","decl":"@[simp]\nlemma ofQuotient_π : (ofQuotient relations).π = Submodule.mkQ _ := ofπ_π _ _\n\n"}
{"name":"Module.Relations.Solution.ofQuotient_fromQuotient","module":"Mathlib.Algebra.Module.Presentation.Basic","initialProofState":"A : Type u\ninst✝ : Ring A\nrelations : Module.Relations A\n⊢ Eq (Module.Relations.Solution.ofQuotient relations).fromQuotient LinearMap.id","decl":"@[simp]\nlemma ofQuotient_fromQuotient : (ofQuotient relations).fromQuotient = .id := by aesop\n\n"}
{"name":"Module.Relations.Solution.ofQuotient_isPresentation","module":"Mathlib.Algebra.Module.Presentation.Basic","initialProofState":"A : Type u\ninst✝ : Ring A\nrelations : Module.Relations A\n⊢ (Module.Relations.Solution.ofQuotient relations).IsPresentation","decl":"lemma ofQuotient_isPresentation : (ofQuotient relations).IsPresentation where\n  bijective := by\n    simpa only [ofQuotient_fromQuotient, LinearMap.id_coe] using Function.bijective_id\n\n"}
{"name":"Module.Relations.Solution.IsPresentationCore.postcomp_injective","module":"Mathlib.Algebra.Module.Presentation.Basic","initialProofState":"A : Type u\ninst✝⁴ : Ring A\nrelations : Module.Relations A\nM : Type v\ninst✝³ : AddCommGroup M\ninst✝² : Module A M\nsolution : relations.Solution M\nself : solution.IsPresentationCore\nN : Type w'\ninst✝¹ : AddCommGroup N\ninst✝ : Module A N\nf f' : LinearMap (RingHom.id A) M N\nh : Eq (solution.postcomp f) (solution.postcomp f')\n⊢ Eq f f'","decl":"/-- Helper structure in order to prove `Module.Relations.Solutions.IsPresentation`\nby showing the universal property of the module defined by generators and relations.\nThe universal property is restricted to modules that are in `Type w'` for\nan auxiliary universe `w'`. See `IsPresentationCore.isPresentation`. -/\nstructure IsPresentationCore (solution : relations.Solution M) where\n  /-- any solution in a module `N : Type w'` is obtained in a unique way\n  by postcomposing `solution : relations.Solution M` by a linear map `M →ₗ[A] N`. -/\n  desc {N : Type w'} [AddCommGroup N] [Module A N] (s : relations.Solution N) : M →ₗ[A] N\n  postcomp_desc {N : Type w'} [AddCommGroup N] [Module A N] (s : relations.Solution N) :\n    solution.postcomp (desc s) = s\n  postcomp_injective {N : Type w'} [AddCommGroup N] [Module A N] {f f' : M →ₗ[A] N}\n      (h : solution.postcomp f = solution.postcomp f') : f = f'\n\n"}
{"name":"Module.Relations.Solution.IsPresentationCore.postcomp_desc","module":"Mathlib.Algebra.Module.Presentation.Basic","initialProofState":"A : Type u\ninst✝⁴ : Ring A\nrelations : Module.Relations A\nM : Type v\ninst✝³ : AddCommGroup M\ninst✝² : Module A M\nsolution : relations.Solution M\nself : solution.IsPresentationCore\nN : Type w'\ninst✝¹ : AddCommGroup N\ninst✝ : Module A N\ns : relations.Solution N\n⊢ Eq (solution.postcomp (self.desc s)) s","decl":"/-- Helper structure in order to prove `Module.Relations.Solutions.IsPresentation`\nby showing the universal property of the module defined by generators and relations.\nThe universal property is restricted to modules that are in `Type w'` for\nan auxiliary universe `w'`. See `IsPresentationCore.isPresentation`. -/\nstructure IsPresentationCore (solution : relations.Solution M) where\n  /-- any solution in a module `N : Type w'` is obtained in a unique way\n  by postcomposing `solution : relations.Solution M` by a linear map `M →ₗ[A] N`. -/\n  desc {N : Type w'} [AddCommGroup N] [Module A N] (s : relations.Solution N) : M →ₗ[A] N\n  postcomp_desc {N : Type w'} [AddCommGroup N] [Module A N] (s : relations.Solution N) :\n    solution.postcomp (desc s) = s\n  postcomp_injective {N : Type w'} [AddCommGroup N] [Module A N] {f f' : M →ₗ[A] N}\n      (h : solution.postcomp f = solution.postcomp f') : f = f'\n\n"}
{"name":"Module.Relations.Solution.IsPresentationCore.mk.sizeOf_spec","module":"Mathlib.Algebra.Module.Presentation.Basic","initialProofState":"A : Type u\ninst✝⁴ : Ring A\nrelations : Module.Relations A\nM : Type v\ninst✝³ : AddCommGroup M\ninst✝² : Module A M\nsolution : relations.Solution M\ninst✝¹ : SizeOf A\ninst✝ : SizeOf M\ndesc : {N : Type w'} → [inst : AddCommGroup N] → [inst_1 : Module A N] → relations.Solution N → LinearMap (RingHom.id A) M N\npostcomp_desc : ∀ {N : Type w'} [inst : AddCommGroup N] [inst_1 : Module A N] (s : relations.Solution N), Eq (solution.postcomp (desc s)) s\npostcomp_injective : ∀ {N : Type w'} [inst : AddCommGroup N] [inst_1 : Module A N] {f f' : LinearMap (RingHom.id A) M N}, Eq (solution.postcomp f) (solution.postcomp f') → Eq f f'\n⊢ Eq (SizeOf.sizeOf { desc := desc, postcomp_desc := postcomp_desc, postcomp_injective := postcomp_injective }) 1","decl":"/-- Helper structure in order to prove `Module.Relations.Solutions.IsPresentation`\nby showing the universal property of the module defined by generators and relations.\nThe universal property is restricted to modules that are in `Type w'` for\nan auxiliary universe `w'`. See `IsPresentationCore.isPresentation`. -/\nstructure IsPresentationCore (solution : relations.Solution M) where\n  /-- any solution in a module `N : Type w'` is obtained in a unique way\n  by postcomposing `solution : relations.Solution M` by a linear map `M →ₗ[A] N`. -/\n  desc {N : Type w'} [AddCommGroup N] [Module A N] (s : relations.Solution N) : M →ₗ[A] N\n  postcomp_desc {N : Type w'} [AddCommGroup N] [Module A N] (s : relations.Solution N) :\n    solution.postcomp (desc s) = s\n  postcomp_injective {N : Type w'} [AddCommGroup N] [Module A N] {f f' : M →ₗ[A] N}\n      (h : solution.postcomp f = solution.postcomp f') : f = f'\n\n"}
{"name":"Module.Relations.Solution.IsPresentationCore.mk.inj","module":"Mathlib.Algebra.Module.Presentation.Basic","initialProofState":"A : Type u\ninst✝² : Ring A\nrelations : Module.Relations A\nM : Type v\ninst✝¹ : AddCommGroup M\ninst✝ : Module A M\nsolution : relations.Solution M\ndesc✝ : {N : Type w'} → [inst : AddCommGroup N] → [inst_1 : Module A N] → relations.Solution N → LinearMap (RingHom.id A) M N\npostcomp_desc✝ : ∀ {N : Type w'} [inst : AddCommGroup N] [inst_1 : Module A N] (s : relations.Solution N), Eq (solution.postcomp (desc✝ s)) s\npostcomp_injective✝ : ∀ {N : Type w'} [inst : AddCommGroup N] [inst_1 : Module A N] {f f' : LinearMap (RingHom.id A) M N}, Eq (solution.postcomp f) (solution.postcomp f') → Eq f f'\ndesc : {N : Type w'} → [inst : AddCommGroup N] → [inst_1 : Module A N] → relations.Solution N → LinearMap (RingHom.id A) M N\npostcomp_desc : ∀ {N : Type w'} [inst : AddCommGroup N] [inst_1 : Module A N] (s : relations.Solution N), Eq (solution.postcomp (desc s)) s\npostcomp_injective : ∀ {N : Type w'} [inst : AddCommGroup N] [inst_1 : Module A N] {f f' : LinearMap (RingHom.id A) M N}, Eq (solution.postcomp f) (solution.postcomp f') → Eq f f'\nx✝ : Eq { desc := desc✝, postcomp_desc := postcomp_desc✝, postcomp_injective := postcomp_injective✝ } { desc := desc, postcomp_desc := postcomp_desc, postcomp_injective := postcomp_injective }\n⊢ Eq desc✝ desc","decl":"/-- Helper structure in order to prove `Module.Relations.Solutions.IsPresentation`\nby showing the universal property of the module defined by generators and relations.\nThe universal property is restricted to modules that are in `Type w'` for\nan auxiliary universe `w'`. See `IsPresentationCore.isPresentation`. -/\nstructure IsPresentationCore (solution : relations.Solution M) where\n  /-- any solution in a module `N : Type w'` is obtained in a unique way\n  by postcomposing `solution : relations.Solution M` by a linear map `M →ₗ[A] N`. -/\n  desc {N : Type w'} [AddCommGroup N] [Module A N] (s : relations.Solution N) : M →ₗ[A] N\n  postcomp_desc {N : Type w'} [AddCommGroup N] [Module A N] (s : relations.Solution N) :\n    solution.postcomp (desc s) = s\n  postcomp_injective {N : Type w'} [AddCommGroup N] [Module A N] {f f' : M →ₗ[A] N}\n      (h : solution.postcomp f = solution.postcomp f') : f = f'\n\n"}
{"name":"Module.Relations.Solution.IsPresentationCore.mk.injEq","module":"Mathlib.Algebra.Module.Presentation.Basic","initialProofState":"A : Type u\ninst✝² : Ring A\nrelations : Module.Relations A\nM : Type v\ninst✝¹ : AddCommGroup M\ninst✝ : Module A M\nsolution : relations.Solution M\ndesc✝ : {N : Type w'} → [inst : AddCommGroup N] → [inst_1 : Module A N] → relations.Solution N → LinearMap (RingHom.id A) M N\npostcomp_desc✝ : ∀ {N : Type w'} [inst : AddCommGroup N] [inst_1 : Module A N] (s : relations.Solution N), Eq (solution.postcomp (desc✝ s)) s\npostcomp_injective✝ : ∀ {N : Type w'} [inst : AddCommGroup N] [inst_1 : Module A N] {f f' : LinearMap (RingHom.id A) M N}, Eq (solution.postcomp f) (solution.postcomp f') → Eq f f'\ndesc : {N : Type w'} → [inst : AddCommGroup N] → [inst_1 : Module A N] → relations.Solution N → LinearMap (RingHom.id A) M N\npostcomp_desc : ∀ {N : Type w'} [inst : AddCommGroup N] [inst_1 : Module A N] (s : relations.Solution N), Eq (solution.postcomp (desc s)) s\npostcomp_injective : ∀ {N : Type w'} [inst : AddCommGroup N] [inst_1 : Module A N] {f f' : LinearMap (RingHom.id A) M N}, Eq (solution.postcomp f) (solution.postcomp f') → Eq f f'\n⊢ Eq (Eq { desc := desc✝, postcomp_desc := postcomp_desc✝, postcomp_injective := postcomp_injective✝ } { desc := desc, postcomp_desc := postcomp_desc, postcomp_injective := postcomp_injective }) (Eq desc✝ desc)","decl":"/-- Helper structure in order to prove `Module.Relations.Solutions.IsPresentation`\nby showing the universal property of the module defined by generators and relations.\nThe universal property is restricted to modules that are in `Type w'` for\nan auxiliary universe `w'`. See `IsPresentationCore.isPresentation`. -/\nstructure IsPresentationCore (solution : relations.Solution M) where\n  /-- any solution in a module `N : Type w'` is obtained in a unique way\n  by postcomposing `solution : relations.Solution M` by a linear map `M →ₗ[A] N`. -/\n  desc {N : Type w'} [AddCommGroup N] [Module A N] (s : relations.Solution N) : M →ₗ[A] N\n  postcomp_desc {N : Type w'} [AddCommGroup N] [Module A N] (s : relations.Solution N) :\n    solution.postcomp (desc s) = s\n  postcomp_injective {N : Type w'} [AddCommGroup N] [Module A N] {f f' : M →ₗ[A] N}\n      (h : solution.postcomp f = solution.postcomp f') : f = f'\n\n"}
{"name":"Module.Relations.Solution.IsPresentationCore.desc_var","module":"Mathlib.Algebra.Module.Presentation.Basic","initialProofState":"A : Type u\ninst✝⁴ : Ring A\nrelations : Module.Relations A\nM : Type v\ninst✝³ : AddCommGroup M\ninst✝² : Module A M\nsolution : relations.Solution M\nh : solution.IsPresentationCore\nN : Type w'\ninst✝¹ : AddCommGroup N\ninst✝ : Module A N\ns : relations.Solution N\ng : relations.G\n⊢ Eq ((h.desc s) (solution.var g)) (s.var g)","decl":"@[simp]\nlemma desc_var (h : IsPresentationCore.{w'} solution)\n    {N : Type w'} [AddCommGroup N] [Module A N] (s : relations.Solution N) (g : relations.G) :\n    h.desc s (solution.var g) = s.var g :=\n  congr_var (h.postcomp_desc s) g\n\n"}
{"name":"Module.Relations.Solution.IsPresentationCore.isPresentation","module":"Mathlib.Algebra.Module.Presentation.Basic","initialProofState":"A : Type u\ninst✝² : Ring A\nrelations : Module.Relations A\nM : Type v\ninst✝¹ : AddCommGroup M\ninst✝ : Module A M\nsolution : relations.Solution M\nh : solution.IsPresentationCore\n⊢ solution.IsPresentation","decl":"lemma isPresentation {solution : relations.Solution M}\n    (h : IsPresentationCore.{max u v w₀} solution) :\n    solution.IsPresentation where\n  bijective := by\n    let e : relations.Quotient ≃ₗ[A] M :=\n      LinearEquiv.ofLinear solution.fromQuotient\n      ((down.{v} h).desc (ofQuotient relations))\n      ((down.{max u w₀} h).postcomp_injective (by aesop)) (by aesop)\n    exact e.bijective\n\n"}
{"name":"Module.Relations.Solution.isPresentation_iff","module":"Mathlib.Algebra.Module.Presentation.Basic","initialProofState":"A : Type u\ninst✝² : Ring A\nrelations : Module.Relations A\nM : Type v\ninst✝¹ : AddCommGroup M\ninst✝ : Module A M\nsolution : relations.Solution M\n⊢ Iff solution.IsPresentation (And (Eq (Submodule.span A (Set.range solution.var)) Top.top) (Eq (LinearMap.ker solution.π) (Submodule.span A (Set.range relations.relation))))","decl":"lemma isPresentation_iff :\n    solution.IsPresentation ↔\n      Submodule.span A (Set.range solution.var) = ⊤ ∧\n      LinearMap.ker solution.π = Submodule.span A (Set.range relations.relation) := by\n  rw [← injective_fromQuotient_iff_ker_π_eq_span,\n    ← surjective_π_iff_span_eq_top, ← surjective_fromQuotient_iff_surjective_π, ]\n  exact ⟨fun h ↦ ⟨h.bijective.2, h.bijective.1⟩, fun h ↦ ⟨⟨h.2, h.1⟩⟩⟩\n\n"}
{"name":"Module.Relations.Solution.isPresentation_mk","module":"Mathlib.Algebra.Module.Presentation.Basic","initialProofState":"A : Type u\ninst✝² : Ring A\nrelations : Module.Relations A\nM : Type v\ninst✝¹ : AddCommGroup M\ninst✝ : Module A M\nsolution : relations.Solution M\nh₁ : Eq (Submodule.span A (Set.range solution.var)) Top.top\nh₂ : Eq (LinearMap.ker solution.π) (Submodule.span A (Set.range relations.relation))\n⊢ solution.IsPresentation","decl":"lemma isPresentation_mk\n    (h₁ : Submodule.span A (Set.range solution.var) = ⊤)\n    (h₂ : LinearMap.ker solution.π = Submodule.span A (Set.range relations.relation)) :\n    solution.IsPresentation := by\n  rw [isPresentation_iff]; constructor <;> assumption\n\n"}
{"name":"Module.Presentation.mk.inj","module":"Mathlib.Algebra.Module.Presentation.Basic","initialProofState":"A : Type u\ninst✝² : Ring A\nM : Type v\ninst✝¹ : AddCommGroup M\ninst✝ : Module A M\ntoRelations✝ : Module.Relations A\ntoSolution✝ : toRelations✝.Solution M\ntoIsPresentation✝ : toSolution✝.IsPresentation\ntoRelations : Module.Relations A\ntoSolution : toRelations.Solution M\ntoIsPresentation : toSolution.IsPresentation\nx✝ : Eq { toRelations := toRelations✝, toSolution := toSolution✝, toIsPresentation := toIsPresentation✝ } { toRelations := toRelations, toSolution := toSolution, toIsPresentation := toIsPresentation }\n⊢ And (Eq toRelations✝ toRelations) (HEq toSolution✝ toSolution)","decl":"/-- Given an `A`-module `M`, a term in this type is a presentation by `M` by\ngenerators and relations. -/\n@[nolint checkUnivs]\nstructure Presentation extends Relations.{w₀, w₁} A,\n  toRelations.Solution M, toSolution.IsPresentation where\n\n"}
{"name":"Module.Presentation.mk.injEq","module":"Mathlib.Algebra.Module.Presentation.Basic","initialProofState":"A : Type u\ninst✝² : Ring A\nM : Type v\ninst✝¹ : AddCommGroup M\ninst✝ : Module A M\ntoRelations✝ : Module.Relations A\ntoSolution✝ : toRelations✝.Solution M\ntoIsPresentation✝ : toSolution✝.IsPresentation\ntoRelations : Module.Relations A\ntoSolution : toRelations.Solution M\ntoIsPresentation : toSolution.IsPresentation\n⊢ Eq (Eq { toRelations := toRelations✝, toSolution := toSolution✝, toIsPresentation := toIsPresentation✝ } { toRelations := toRelations, toSolution := toSolution, toIsPresentation := toIsPresentation }) (And (Eq toRelations✝ toRelations) (HEq toSolution✝ toSolution))","decl":"/-- Given an `A`-module `M`, a term in this type is a presentation by `M` by\ngenerators and relations. -/\n@[nolint checkUnivs]\nstructure Presentation extends Relations.{w₀, w₁} A,\n  toRelations.Solution M, toSolution.IsPresentation where\n\n"}
{"name":"Module.Presentation.mk.sizeOf_spec","module":"Mathlib.Algebra.Module.Presentation.Basic","initialProofState":"A : Type u\ninst✝⁴ : Ring A\nM : Type v\ninst✝³ : AddCommGroup M\ninst✝² : Module A M\ninst✝¹ : SizeOf A\ninst✝ : SizeOf M\ntoRelations : Module.Relations A\ntoSolution : toRelations.Solution M\ntoIsPresentation : toSolution.IsPresentation\n⊢ Eq (SizeOf.sizeOf { toRelations := toRelations, toSolution := toSolution, toIsPresentation := toIsPresentation }) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf toRelations)) (SizeOf.sizeOf toSolution)) (SizeOf.sizeOf toIsPresentation))","decl":"/-- Given an `A`-module `M`, a term in this type is a presentation by `M` by\ngenerators and relations. -/\n@[nolint checkUnivs]\nstructure Presentation extends Relations.{w₀, w₁} A,\n  toRelations.Solution M, toSolution.IsPresentation where\n\n"}
{"name":"Module.Presentation.toIsPresentation","module":"Mathlib.Algebra.Module.Presentation.Basic","initialProofState":"A : Type u\ninst✝² : Ring A\nM : Type v\ninst✝¹ : AddCommGroup M\ninst✝ : Module A M\nself : Module.Presentation A M\n⊢ self.IsPresentation","decl":"/-- Given an `A`-module `M`, a term in this type is a presentation by `M` by\ngenerators and relations. -/\n@[nolint checkUnivs]\nstructure Presentation extends Relations.{w₀, w₁} A,\n  toRelations.Solution M, toSolution.IsPresentation where\n\n"}
{"name":"Module.Presentation.ofIsPresentation_toSolution","module":"Mathlib.Algebra.Module.Presentation.Basic","initialProofState":"A : Type u\ninst✝² : Ring A\nM : Type v\ninst✝¹ : AddCommGroup M\ninst✝ : Module A M\nrelations : Module.Relations A\nsolution : relations.Solution M\nh : solution.IsPresentation\n⊢ Eq (Module.Presentation.ofIsPresentation h).toSolution solution","decl":"/-- Constructor for `Module.Presentation`. -/\n@[simps toRelations toSolution]\ndef Presentation.ofIsPresentation {relations : Relations.{w₀, w₁} A}\n    {solution : relations.Solution M} (h : solution.IsPresentation) :\n    Presentation.{w₀, w₁} A M where\n  toSolution := solution\n  toIsPresentation := h\n\n"}
{"name":"Module.Presentation.ofIsPresentation_toRelations","module":"Mathlib.Algebra.Module.Presentation.Basic","initialProofState":"A : Type u\ninst✝² : Ring A\nM : Type v\ninst✝¹ : AddCommGroup M\ninst✝ : Module A M\nrelations : Module.Relations A\nsolution : relations.Solution M\nh : solution.IsPresentation\n⊢ Eq (Module.Presentation.ofIsPresentation h).toRelations { G := relations.G, R := relations.R, relation := relations.relation }","decl":"/-- Constructor for `Module.Presentation`. -/\n@[simps toRelations toSolution]\ndef Presentation.ofIsPresentation {relations : Relations.{w₀, w₁} A}\n    {solution : relations.Solution M} (h : solution.IsPresentation) :\n    Presentation.{w₀, w₁} A M where\n  toSolution := solution\n  toIsPresentation := h\n\n"}
{"name":"Module.Presentation.ofLinearEquiv_toRelations","module":"Mathlib.Algebra.Module.Presentation.Basic","initialProofState":"A : Type u\ninst✝⁴ : Ring A\nM : Type v\ninst✝³ : AddCommGroup M\ninst✝² : Module A M\npres : Module.Presentation A M\nN : Type v'\ninst✝¹ : AddCommGroup N\ninst✝ : Module A N\ne : LinearEquiv (RingHom.id A) M N\n⊢ Eq (pres.ofLinearEquiv e).toRelations { G := pres.G, R := pres.R, relation := pres.relation }","decl":"/-- The presentation of an `A`-module `N` that is deduced from a presentation of\na module `M` and a linear equivalence `e : M ≃ₗ[A] N`. -/\n@[simps! toRelations toSolution]\ndef Presentation.ofLinearEquiv (pres : Presentation.{w₀, w₁} A M)\n    {N : Type v'} [AddCommGroup N] [Module A N] (e : M ≃ₗ[A] N) :\n    Presentation A N :=\n  ofIsPresentation (pres.toIsPresentation.of_linearEquiv e)\n\n"}
{"name":"Module.Presentation.ofLinearEquiv_toSolution","module":"Mathlib.Algebra.Module.Presentation.Basic","initialProofState":"A : Type u\ninst✝⁴ : Ring A\nM : Type v\ninst✝³ : AddCommGroup M\ninst✝² : Module A M\npres : Module.Presentation A M\nN : Type v'\ninst✝¹ : AddCommGroup N\ninst✝ : Module A N\ne : LinearEquiv (RingHom.id A) M N\n⊢ Eq (pres.ofLinearEquiv e).toSolution (pres.postcomp ↑e)","decl":"/-- The presentation of an `A`-module `N` that is deduced from a presentation of\na module `M` and a linear equivalence `e : M ≃ₗ[A] N`. -/\n@[simps! toRelations toSolution]\ndef Presentation.ofLinearEquiv (pres : Presentation.{w₀, w₁} A M)\n    {N : Type v'} [AddCommGroup N] [Module A N] (e : M ≃ₗ[A] N) :\n    Presentation A N :=\n  ofIsPresentation (pres.toIsPresentation.of_linearEquiv e)\n\n"}
