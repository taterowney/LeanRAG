{"name":"PosNum.one.sizeOf_spec","module":"Mathlib.Data.Num.Basic","initialProofState":"⊢ Eq (SizeOf.sizeOf PosNum.one) 1","decl":"/-- The type of positive binary numbers.\n\n     13 = 1101(base 2) = bit1 (bit0 (bit1 one)) -/\ninductive PosNum : Type\n  | one : PosNum\n  | bit1 : PosNum → PosNum\n  | bit0 : PosNum → PosNum\n  deriving DecidableEq\n\n"}
{"name":"PosNum.bit1.inj","module":"Mathlib.Data.Num.Basic","initialProofState":"a✝¹ a✝ : PosNum\nx✝ : Eq a✝¹.bit1 a✝.bit1\n⊢ Eq a✝¹ a✝","decl":"/-- The type of positive binary numbers.\n\n     13 = 1101(base 2) = bit1 (bit0 (bit1 one)) -/\ninductive PosNum : Type\n  | one : PosNum\n  | bit1 : PosNum → PosNum\n  | bit0 : PosNum → PosNum\n  deriving DecidableEq\n\n"}
{"name":"PosNum.bit0.sizeOf_spec","module":"Mathlib.Data.Num.Basic","initialProofState":"a✝ : PosNum\n⊢ Eq (SizeOf.sizeOf a✝.bit0) (HAdd.hAdd 1 (SizeOf.sizeOf a✝))","decl":"/-- The type of positive binary numbers.\n\n     13 = 1101(base 2) = bit1 (bit0 (bit1 one)) -/\ninductive PosNum : Type\n  | one : PosNum\n  | bit1 : PosNum → PosNum\n  | bit0 : PosNum → PosNum\n  deriving DecidableEq\n\n"}
{"name":"PosNum.bit1.injEq","module":"Mathlib.Data.Num.Basic","initialProofState":"a✝¹ a✝ : PosNum\n⊢ Eq (Eq a✝¹.bit1 a✝.bit1) (Eq a✝¹ a✝)","decl":"/-- The type of positive binary numbers.\n\n     13 = 1101(base 2) = bit1 (bit0 (bit1 one)) -/\ninductive PosNum : Type\n  | one : PosNum\n  | bit1 : PosNum → PosNum\n  | bit0 : PosNum → PosNum\n  deriving DecidableEq\n\n"}
{"name":"PosNum.bit0.inj","module":"Mathlib.Data.Num.Basic","initialProofState":"a✝¹ a✝ : PosNum\nx✝ : Eq a✝¹.bit0 a✝.bit0\n⊢ Eq a✝¹ a✝","decl":"/-- The type of positive binary numbers.\n\n     13 = 1101(base 2) = bit1 (bit0 (bit1 one)) -/\ninductive PosNum : Type\n  | one : PosNum\n  | bit1 : PosNum → PosNum\n  | bit0 : PosNum → PosNum\n  deriving DecidableEq\n\n"}
{"name":"PosNum.bit1.sizeOf_spec","module":"Mathlib.Data.Num.Basic","initialProofState":"a✝ : PosNum\n⊢ Eq (SizeOf.sizeOf a✝.bit1) (HAdd.hAdd 1 (SizeOf.sizeOf a✝))","decl":"/-- The type of positive binary numbers.\n\n     13 = 1101(base 2) = bit1 (bit0 (bit1 one)) -/\ninductive PosNum : Type\n  | one : PosNum\n  | bit1 : PosNum → PosNum\n  | bit0 : PosNum → PosNum\n  deriving DecidableEq\n\n"}
{"name":"PosNum.bit0.injEq","module":"Mathlib.Data.Num.Basic","initialProofState":"a✝¹ a✝ : PosNum\n⊢ Eq (Eq a✝¹.bit0 a✝.bit0) (Eq a✝¹ a✝)","decl":"/-- The type of positive binary numbers.\n\n     13 = 1101(base 2) = bit1 (bit0 (bit1 one)) -/\ninductive PosNum : Type\n  | one : PosNum\n  | bit1 : PosNum → PosNum\n  | bit0 : PosNum → PosNum\n  deriving DecidableEq\n\n"}
{"name":"Num.pos.sizeOf_spec","module":"Mathlib.Data.Num.Basic","initialProofState":"a✝ : PosNum\n⊢ Eq (SizeOf.sizeOf (Num.pos a✝)) (HAdd.hAdd 1 (SizeOf.sizeOf a✝))","decl":"/-- The type of nonnegative binary numbers, using `PosNum`.\n\n     13 = 1101(base 2) = pos (bit1 (bit0 (bit1 one))) -/\ninductive Num : Type\n  | zero : Num\n  | pos : PosNum → Num\n  deriving DecidableEq\n\n"}
{"name":"Num.zero.sizeOf_spec","module":"Mathlib.Data.Num.Basic","initialProofState":"⊢ Eq (SizeOf.sizeOf Num.zero) 1","decl":"/-- The type of nonnegative binary numbers, using `PosNum`.\n\n     13 = 1101(base 2) = pos (bit1 (bit0 (bit1 one))) -/\ninductive Num : Type\n  | zero : Num\n  | pos : PosNum → Num\n  deriving DecidableEq\n\n"}
{"name":"Num.pos.inj","module":"Mathlib.Data.Num.Basic","initialProofState":"a✝¹ a✝ : PosNum\nx✝ : Eq (Num.pos a✝¹) (Num.pos a✝)\n⊢ Eq a✝¹ a✝","decl":"/-- The type of nonnegative binary numbers, using `PosNum`.\n\n     13 = 1101(base 2) = pos (bit1 (bit0 (bit1 one))) -/\ninductive Num : Type\n  | zero : Num\n  | pos : PosNum → Num\n  deriving DecidableEq\n\n"}
{"name":"Num.pos.injEq","module":"Mathlib.Data.Num.Basic","initialProofState":"a✝¹ a✝ : PosNum\n⊢ Eq (Eq (Num.pos a✝¹) (Num.pos a✝)) (Eq a✝¹ a✝)","decl":"/-- The type of nonnegative binary numbers, using `PosNum`.\n\n     13 = 1101(base 2) = pos (bit1 (bit0 (bit1 one))) -/\ninductive Num : Type\n  | zero : Num\n  | pos : PosNum → Num\n  deriving DecidableEq\n\n"}
{"name":"ZNum.neg.sizeOf_spec","module":"Mathlib.Data.Num.Basic","initialProofState":"a✝ : PosNum\n⊢ Eq (SizeOf.sizeOf (ZNum.neg a✝)) (HAdd.hAdd 1 (SizeOf.sizeOf a✝))","decl":"/-- Representation of integers using trichotomy around zero.\n\n     13 = 1101(base 2) = pos (bit1 (bit0 (bit1 one)))\n     -13 = -1101(base 2) = neg (bit1 (bit0 (bit1 one))) -/\ninductive ZNum : Type\n  | zero : ZNum\n  | pos : PosNum → ZNum\n  | neg : PosNum → ZNum\n  deriving DecidableEq\n\n"}
{"name":"ZNum.neg.inj","module":"Mathlib.Data.Num.Basic","initialProofState":"a✝¹ a✝ : PosNum\nx✝ : Eq (ZNum.neg a✝¹) (ZNum.neg a✝)\n⊢ Eq a✝¹ a✝","decl":"/-- Representation of integers using trichotomy around zero.\n\n     13 = 1101(base 2) = pos (bit1 (bit0 (bit1 one)))\n     -13 = -1101(base 2) = neg (bit1 (bit0 (bit1 one))) -/\ninductive ZNum : Type\n  | zero : ZNum\n  | pos : PosNum → ZNum\n  | neg : PosNum → ZNum\n  deriving DecidableEq\n\n"}
{"name":"ZNum.neg.injEq","module":"Mathlib.Data.Num.Basic","initialProofState":"a✝¹ a✝ : PosNum\n⊢ Eq (Eq (ZNum.neg a✝¹) (ZNum.neg a✝)) (Eq a✝¹ a✝)","decl":"/-- Representation of integers using trichotomy around zero.\n\n     13 = 1101(base 2) = pos (bit1 (bit0 (bit1 one)))\n     -13 = -1101(base 2) = neg (bit1 (bit0 (bit1 one))) -/\ninductive ZNum : Type\n  | zero : ZNum\n  | pos : PosNum → ZNum\n  | neg : PosNum → ZNum\n  deriving DecidableEq\n\n"}
{"name":"ZNum.pos.injEq","module":"Mathlib.Data.Num.Basic","initialProofState":"a✝¹ a✝ : PosNum\n⊢ Eq (Eq (ZNum.pos a✝¹) (ZNum.pos a✝)) (Eq a✝¹ a✝)","decl":"/-- Representation of integers using trichotomy around zero.\n\n     13 = 1101(base 2) = pos (bit1 (bit0 (bit1 one)))\n     -13 = -1101(base 2) = neg (bit1 (bit0 (bit1 one))) -/\ninductive ZNum : Type\n  | zero : ZNum\n  | pos : PosNum → ZNum\n  | neg : PosNum → ZNum\n  deriving DecidableEq\n\n"}
{"name":"ZNum.pos.sizeOf_spec","module":"Mathlib.Data.Num.Basic","initialProofState":"a✝ : PosNum\n⊢ Eq (SizeOf.sizeOf (ZNum.pos a✝)) (HAdd.hAdd 1 (SizeOf.sizeOf a✝))","decl":"/-- Representation of integers using trichotomy around zero.\n\n     13 = 1101(base 2) = pos (bit1 (bit0 (bit1 one)))\n     -13 = -1101(base 2) = neg (bit1 (bit0 (bit1 one))) -/\ninductive ZNum : Type\n  | zero : ZNum\n  | pos : PosNum → ZNum\n  | neg : PosNum → ZNum\n  deriving DecidableEq\n\n"}
{"name":"ZNum.pos.inj","module":"Mathlib.Data.Num.Basic","initialProofState":"a✝¹ a✝ : PosNum\nx✝ : Eq (ZNum.pos a✝¹) (ZNum.pos a✝)\n⊢ Eq a✝¹ a✝","decl":"/-- Representation of integers using trichotomy around zero.\n\n     13 = 1101(base 2) = pos (bit1 (bit0 (bit1 one)))\n     -13 = -1101(base 2) = neg (bit1 (bit0 (bit1 one))) -/\ninductive ZNum : Type\n  | zero : ZNum\n  | pos : PosNum → ZNum\n  | neg : PosNum → ZNum\n  deriving DecidableEq\n\n"}
{"name":"ZNum.zero.sizeOf_spec","module":"Mathlib.Data.Num.Basic","initialProofState":"⊢ Eq (SizeOf.sizeOf ZNum.zero) 1","decl":"/-- Representation of integers using trichotomy around zero.\n\n     13 = 1101(base 2) = pos (bit1 (bit0 (bit1 one)))\n     -13 = -1101(base 2) = neg (bit1 (bit0 (bit1 one))) -/\ninductive ZNum : Type\n  | zero : ZNum\n  | pos : PosNum → ZNum\n  | neg : PosNum → ZNum\n  deriving DecidableEq\n\n"}
