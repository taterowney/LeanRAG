{"name":"CategoryTheory.Enriched.FunctorCategory.diagram_obj_map","module":"Mathlib.CategoryTheory.Enriched.FunctorCategory","initialProofState":"V : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} V\ninst✝³ : CategoryTheory.MonoidalCategory V\nC : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} C\nJ : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} J\ninst✝ : CategoryTheory.EnrichedOrdinaryCategory V C\nF₁ F₂ : CategoryTheory.Functor J C\nX : Opposite J\nX✝ Y✝ : J\nf : Quiver.Hom X✝ Y✝\n⊢ Eq (((CategoryTheory.Enriched.FunctorCategory.diagram V F₁ F₂).obj X).map f) (CategoryTheory.eHomWhiskerLeft V (F₁.obj (Opposite.unop X)) (F₂.map f))","decl":"/-- Given two functors `F₁` and `F₂` from a category `J` to a `V`-enriched\nordinary category `C`, this is the diagram `Jᵒᵖ ⥤ J ⥤ V` whose end shall be\nthe `V`-morphisms in `J ⥤ V` from `F₁` to `F₂`. -/\n@[simps!]\ndef diagram : Jᵒᵖ ⥤ J ⥤ V := F₁.op ⋙ eHomFunctor V C ⋙ (whiskeringLeft J C V).obj F₂\n\n"}
{"name":"CategoryTheory.Enriched.FunctorCategory.diagram_map_app","module":"Mathlib.CategoryTheory.Enriched.FunctorCategory","initialProofState":"V : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} V\ninst✝³ : CategoryTheory.MonoidalCategory V\nC : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} C\nJ : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} J\ninst✝ : CategoryTheory.EnrichedOrdinaryCategory V C\nF₁ F₂ : CategoryTheory.Functor J C\nX✝ Y✝ : Opposite J\nf : Quiver.Hom X✝ Y✝\nX : J\n⊢ Eq (((CategoryTheory.Enriched.FunctorCategory.diagram V F₁ F₂).map f).app X) (CategoryTheory.eHomWhiskerRight V (F₁.map f.unop) (F₂.obj X))","decl":"/-- Given two functors `F₁` and `F₂` from a category `J` to a `V`-enriched\nordinary category `C`, this is the diagram `Jᵒᵖ ⥤ J ⥤ V` whose end shall be\nthe `V`-morphisms in `J ⥤ V` from `F₁` to `F₂`. -/\n@[simps!]\ndef diagram : Jᵒᵖ ⥤ J ⥤ V := F₁.op ⋙ eHomFunctor V C ⋙ (whiskeringLeft J C V).obj F₂\n\n"}
{"name":"CategoryTheory.Enriched.FunctorCategory.diagram_obj_obj","module":"Mathlib.CategoryTheory.Enriched.FunctorCategory","initialProofState":"V : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} V\ninst✝³ : CategoryTheory.MonoidalCategory V\nC : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} C\nJ : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} J\ninst✝ : CategoryTheory.EnrichedOrdinaryCategory V C\nF₁ F₂ : CategoryTheory.Functor J C\nX✝ : Opposite J\nX : J\n⊢ Eq (((CategoryTheory.Enriched.FunctorCategory.diagram V F₁ F₂).obj X✝).obj X) (CategoryTheory.EnrichedCategory.Hom (F₁.obj (Opposite.unop X✝)) (F₂.obj X))","decl":"/-- Given two functors `F₁` and `F₂` from a category `J` to a `V`-enriched\nordinary category `C`, this is the diagram `Jᵒᵖ ⥤ J ⥤ V` whose end shall be\nthe `V`-morphisms in `J ⥤ V` from `F₁` to `F₂`. -/\n@[simps!]\ndef diagram : Jᵒᵖ ⥤ J ⥤ V := F₁.op ⋙ eHomFunctor V C ⋙ (whiskeringLeft J C V).obj F₂\n\n"}
{"name":"CategoryTheory.Enriched.FunctorCategory.enrichedHom_condition","module":"Mathlib.CategoryTheory.Enriched.FunctorCategory","initialProofState":"V : Type u₁\ninst✝⁵ : CategoryTheory.Category.{v₁, u₁} V\ninst✝⁴ : CategoryTheory.MonoidalCategory V\nC : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} C\nJ : Type u₃\ninst✝² : CategoryTheory.Category.{v₃, u₃} J\ninst✝¹ : CategoryTheory.EnrichedOrdinaryCategory V C\nF₁ F₂ : CategoryTheory.Functor J C\ninst✝ : CategoryTheory.Enriched.FunctorCategory.HasEnrichedHom V F₁ F₂\ni j : J\nf : Quiver.Hom i j\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Enriched.FunctorCategory.enrichedHomπ V F₁ F₂ i) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.rightUnitor (CategoryTheory.EnrichedCategory.Hom (F₁.obj i) (F₂.obj i))).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (CategoryTheory.EnrichedCategory.Hom (F₁.obj i) (F₂.obj i)) ((CategoryTheory.eHomEquiv V) (F₂.map f))) (CategoryTheory.eComp V (F₁.obj i) (F₂.obj i) (F₂.obj j))))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Enriched.FunctorCategory.enrichedHomπ V F₁ F₂ j) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.leftUnitor (CategoryTheory.EnrichedCategory.Hom (F₁.obj j) (F₂.obj j))).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight ((CategoryTheory.eHomEquiv V) (F₁.map f)) (CategoryTheory.EnrichedCategory.Hom (F₁.obj j) (F₂.obj j))) (CategoryTheory.eComp V (F₁.obj i) (F₁.obj j) (F₂.obj j)))))","decl":"@[reassoc]\nlemma enrichedHom_condition {i j : J} (f : i ⟶ j) :\n    enrichedHomπ V F₁ F₂ i ≫ (ρ_ _).inv ≫\n      _ ◁ (eHomEquiv V) (F₂.map f) ≫ eComp V _ _ _  =\n    enrichedHomπ V F₁ F₂ j ≫ (λ_ _).inv ≫\n      (eHomEquiv V) (F₁.map f) ▷ _ ≫ eComp V _ _ _ :=\n  end_.condition (diagram V F₁ F₂) f\n\n"}
{"name":"CategoryTheory.Enriched.FunctorCategory.enrichedHom_condition_assoc","module":"Mathlib.CategoryTheory.Enriched.FunctorCategory","initialProofState":"V : Type u₁\ninst✝⁵ : CategoryTheory.Category.{v₁, u₁} V\ninst✝⁴ : CategoryTheory.MonoidalCategory V\nC : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} C\nJ : Type u₃\ninst✝² : CategoryTheory.Category.{v₃, u₃} J\ninst✝¹ : CategoryTheory.EnrichedOrdinaryCategory V C\nF₁ F₂ : CategoryTheory.Functor J C\ninst✝ : CategoryTheory.Enriched.FunctorCategory.HasEnrichedHom V F₁ F₂\ni j : J\nf : Quiver.Hom i j\nZ : V\nh : Quiver.Hom (CategoryTheory.EnrichedCategory.Hom (F₁.obj i) (F₂.obj j)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Enriched.FunctorCategory.enrichedHomπ V F₁ F₂ i) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.rightUnitor (CategoryTheory.EnrichedCategory.Hom (F₁.obj i) (F₂.obj i))).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (CategoryTheory.EnrichedCategory.Hom (F₁.obj i) (F₂.obj i)) ((CategoryTheory.eHomEquiv V) (F₂.map f))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.eComp V (F₁.obj i) (F₂.obj i) (F₂.obj j)) h)))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Enriched.FunctorCategory.enrichedHomπ V F₁ F₂ j) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.leftUnitor (CategoryTheory.EnrichedCategory.Hom (F₁.obj j) (F₂.obj j))).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight ((CategoryTheory.eHomEquiv V) (F₁.map f)) (CategoryTheory.EnrichedCategory.Hom (F₁.obj j) (F₂.obj j))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.eComp V (F₁.obj i) (F₁.obj j) (F₂.obj j)) h))))","decl":"@[reassoc]\nlemma enrichedHom_condition {i j : J} (f : i ⟶ j) :\n    enrichedHomπ V F₁ F₂ i ≫ (ρ_ _).inv ≫\n      _ ◁ (eHomEquiv V) (F₂.map f) ≫ eComp V _ _ _  =\n    enrichedHomπ V F₁ F₂ j ≫ (λ_ _).inv ≫\n      (eHomEquiv V) (F₁.map f) ▷ _ ≫ eComp V _ _ _ :=\n  end_.condition (diagram V F₁ F₂) f\n\n"}
{"name":"CategoryTheory.Enriched.FunctorCategory.homEquiv_apply_π","module":"Mathlib.CategoryTheory.Enriched.FunctorCategory","initialProofState":"V : Type u₁\ninst✝⁵ : CategoryTheory.Category.{v₁, u₁} V\ninst✝⁴ : CategoryTheory.MonoidalCategory V\nC : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} C\nJ : Type u₃\ninst✝² : CategoryTheory.Category.{v₃, u₃} J\ninst✝¹ : CategoryTheory.EnrichedOrdinaryCategory V C\nF₁ F₂ : CategoryTheory.Functor J C\ninst✝ : CategoryTheory.Enriched.FunctorCategory.HasEnrichedHom V F₁ F₂\nτ : Quiver.Hom F₁ F₂\nj : J\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Enriched.FunctorCategory.homEquiv V) τ) (CategoryTheory.Enriched.FunctorCategory.enrichedHomπ V F₁ F₂ j)) ((CategoryTheory.eHomEquiv V) (τ.app j))","decl":"@[reassoc (attr := simp)]\nlemma homEquiv_apply_π (τ : F₁ ⟶ F₂) (j : J) :\n    homEquiv V τ ≫ enrichedHomπ V _ _ j = eHomEquiv V (τ.app j) := by\n  simp [homEquiv]\n\n"}
{"name":"CategoryTheory.Enriched.FunctorCategory.homEquiv_apply_π_assoc","module":"Mathlib.CategoryTheory.Enriched.FunctorCategory","initialProofState":"V : Type u₁\ninst✝⁵ : CategoryTheory.Category.{v₁, u₁} V\ninst✝⁴ : CategoryTheory.MonoidalCategory V\nC : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} C\nJ : Type u₃\ninst✝² : CategoryTheory.Category.{v₃, u₃} J\ninst✝¹ : CategoryTheory.EnrichedOrdinaryCategory V C\nF₁ F₂ : CategoryTheory.Functor J C\ninst✝ : CategoryTheory.Enriched.FunctorCategory.HasEnrichedHom V F₁ F₂\nτ : Quiver.Hom F₁ F₂\nj : J\nZ : V\nh : Quiver.Hom (CategoryTheory.EnrichedCategory.Hom (F₁.obj j) (F₂.obj j)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Enriched.FunctorCategory.homEquiv V) τ) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Enriched.FunctorCategory.enrichedHomπ V F₁ F₂ j) h)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.eHomEquiv V) (τ.app j)) h)","decl":"@[reassoc (attr := simp)]\nlemma homEquiv_apply_π (τ : F₁ ⟶ F₂) (j : J) :\n    homEquiv V τ ≫ enrichedHomπ V _ _ j = eHomEquiv V (τ.app j) := by\n  simp [homEquiv]\n\n"}
{"name":"CategoryTheory.Enriched.FunctorCategory.enrichedId_π_assoc","module":"Mathlib.CategoryTheory.Enriched.FunctorCategory","initialProofState":"V : Type u₁\ninst✝⁵ : CategoryTheory.Category.{v₁, u₁} V\ninst✝⁴ : CategoryTheory.MonoidalCategory V\nC : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} C\nJ : Type u₃\ninst✝² : CategoryTheory.Category.{v₃, u₃} J\ninst✝¹ : CategoryTheory.EnrichedOrdinaryCategory V C\nF₁ : CategoryTheory.Functor J C\ninst✝ : CategoryTheory.Enriched.FunctorCategory.HasEnrichedHom V F₁ F₁\nj : J\nZ : V\nh : Quiver.Hom (((CategoryTheory.Enriched.FunctorCategory.diagram V F₁ F₁).obj { unop := j }).obj j) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Enriched.FunctorCategory.enrichedId V F₁) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.end_.π (CategoryTheory.Enriched.FunctorCategory.diagram V F₁ F₁) j) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.eId V (F₁.obj j)) h)","decl":"@[reassoc (attr := simp)]\nlemma enrichedId_π (j : J) : enrichedId V F₁ ≫ end_.π _ j = eId V (F₁.obj j) := by\n  simp [enrichedId]\n\n"}
{"name":"CategoryTheory.Enriched.FunctorCategory.enrichedId_π","module":"Mathlib.CategoryTheory.Enriched.FunctorCategory","initialProofState":"V : Type u₁\ninst✝⁵ : CategoryTheory.Category.{v₁, u₁} V\ninst✝⁴ : CategoryTheory.MonoidalCategory V\nC : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} C\nJ : Type u₃\ninst✝² : CategoryTheory.Category.{v₃, u₃} J\ninst✝¹ : CategoryTheory.EnrichedOrdinaryCategory V C\nF₁ : CategoryTheory.Functor J C\ninst✝ : CategoryTheory.Enriched.FunctorCategory.HasEnrichedHom V F₁ F₁\nj : J\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Enriched.FunctorCategory.enrichedId V F₁) (CategoryTheory.Limits.end_.π (CategoryTheory.Enriched.FunctorCategory.diagram V F₁ F₁) j)) (CategoryTheory.eId V (F₁.obj j))","decl":"@[reassoc (attr := simp)]\nlemma enrichedId_π (j : J) : enrichedId V F₁ ≫ end_.π _ j = eId V (F₁.obj j) := by\n  simp [enrichedId]\n\n"}
{"name":"CategoryTheory.Enriched.FunctorCategory.homEquiv_id","module":"Mathlib.CategoryTheory.Enriched.FunctorCategory","initialProofState":"V : Type u₁\ninst✝⁵ : CategoryTheory.Category.{v₁, u₁} V\ninst✝⁴ : CategoryTheory.MonoidalCategory V\nC : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} C\nJ : Type u₃\ninst✝² : CategoryTheory.Category.{v₃, u₃} J\ninst✝¹ : CategoryTheory.EnrichedOrdinaryCategory V C\nF₁ : CategoryTheory.Functor J C\ninst✝ : CategoryTheory.Enriched.FunctorCategory.HasEnrichedHom V F₁ F₁\n⊢ Eq ((CategoryTheory.Enriched.FunctorCategory.homEquiv V) (CategoryTheory.CategoryStruct.id F₁)) (CategoryTheory.Enriched.FunctorCategory.enrichedId V F₁)","decl":"@[simp]\nlemma homEquiv_id : homEquiv V (𝟙 F₁) = enrichedId V F₁ := rfl\n\n"}
{"name":"CategoryTheory.Enriched.FunctorCategory.enrichedComp_π","module":"Mathlib.CategoryTheory.Enriched.FunctorCategory","initialProofState":"V : Type u₁\ninst✝⁷ : CategoryTheory.Category.{v₁, u₁} V\ninst✝⁶ : CategoryTheory.MonoidalCategory V\nC : Type u₂\ninst✝⁵ : CategoryTheory.Category.{v₂, u₂} C\nJ : Type u₃\ninst✝⁴ : CategoryTheory.Category.{v₃, u₃} J\ninst✝³ : CategoryTheory.EnrichedOrdinaryCategory V C\nF₁ F₂ F₃ : CategoryTheory.Functor J C\ninst✝² : CategoryTheory.Enriched.FunctorCategory.HasEnrichedHom V F₁ F₂\ninst✝¹ : CategoryTheory.Enriched.FunctorCategory.HasEnrichedHom V F₂ F₃\ninst✝ : CategoryTheory.Enriched.FunctorCategory.HasEnrichedHom V F₁ F₃\nj : J\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Enriched.FunctorCategory.enrichedComp V F₁ F₂ F₃) (CategoryTheory.Limits.end_.π (CategoryTheory.Enriched.FunctorCategory.diagram V F₁ F₃) j)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom (CategoryTheory.Limits.end_.π (CategoryTheory.Enriched.FunctorCategory.diagram V F₁ F₂) j) (CategoryTheory.Limits.end_.π (CategoryTheory.Enriched.FunctorCategory.diagram V F₂ F₃) j)) (CategoryTheory.eComp V (Opposite.unop (F₁.op.obj { unop := j })) (F₂.obj j) (F₃.obj j)))","decl":"@[reassoc (attr := simp)]\nlemma enrichedComp_π (j : J) :\n    enrichedComp V F₁ F₂ F₃ ≫ end_.π _ j =\n      (end_.π (diagram V F₁ F₂) j ⊗ end_.π (diagram V F₂ F₃) j) ≫ eComp V _ _ _ := by\n  simp [enrichedComp]\n\n"}
{"name":"CategoryTheory.Enriched.FunctorCategory.enrichedComp_π_assoc","module":"Mathlib.CategoryTheory.Enriched.FunctorCategory","initialProofState":"V : Type u₁\ninst✝⁷ : CategoryTheory.Category.{v₁, u₁} V\ninst✝⁶ : CategoryTheory.MonoidalCategory V\nC : Type u₂\ninst✝⁵ : CategoryTheory.Category.{v₂, u₂} C\nJ : Type u₃\ninst✝⁴ : CategoryTheory.Category.{v₃, u₃} J\ninst✝³ : CategoryTheory.EnrichedOrdinaryCategory V C\nF₁ F₂ F₃ : CategoryTheory.Functor J C\ninst✝² : CategoryTheory.Enriched.FunctorCategory.HasEnrichedHom V F₁ F₂\ninst✝¹ : CategoryTheory.Enriched.FunctorCategory.HasEnrichedHom V F₂ F₃\ninst✝ : CategoryTheory.Enriched.FunctorCategory.HasEnrichedHom V F₁ F₃\nj : J\nZ : V\nh : Quiver.Hom (((CategoryTheory.Enriched.FunctorCategory.diagram V F₁ F₃).obj { unop := j }).obj j) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Enriched.FunctorCategory.enrichedComp V F₁ F₂ F₃) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.end_.π (CategoryTheory.Enriched.FunctorCategory.diagram V F₁ F₃) j) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom (CategoryTheory.Limits.end_.π (CategoryTheory.Enriched.FunctorCategory.diagram V F₁ F₂) j) (CategoryTheory.Limits.end_.π (CategoryTheory.Enriched.FunctorCategory.diagram V F₂ F₃) j)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.eComp V (Opposite.unop (F₁.op.obj { unop := j })) (F₂.obj j) (F₃.obj j)) h))","decl":"@[reassoc (attr := simp)]\nlemma enrichedComp_π (j : J) :\n    enrichedComp V F₁ F₂ F₃ ≫ end_.π _ j =\n      (end_.π (diagram V F₁ F₂) j ⊗ end_.π (diagram V F₂ F₃) j) ≫ eComp V _ _ _ := by\n  simp [enrichedComp]\n\n"}
{"name":"CategoryTheory.Enriched.FunctorCategory.homEquiv_comp","module":"Mathlib.CategoryTheory.Enriched.FunctorCategory","initialProofState":"V : Type u₁\ninst✝⁷ : CategoryTheory.Category.{v₁, u₁} V\ninst✝⁶ : CategoryTheory.MonoidalCategory V\nC : Type u₂\ninst✝⁵ : CategoryTheory.Category.{v₂, u₂} C\nJ : Type u₃\ninst✝⁴ : CategoryTheory.Category.{v₃, u₃} J\ninst✝³ : CategoryTheory.EnrichedOrdinaryCategory V C\nF₁ F₂ F₃ : CategoryTheory.Functor J C\ninst✝² : CategoryTheory.Enriched.FunctorCategory.HasEnrichedHom V F₁ F₂\ninst✝¹ : CategoryTheory.Enriched.FunctorCategory.HasEnrichedHom V F₂ F₃\ninst✝ : CategoryTheory.Enriched.FunctorCategory.HasEnrichedHom V F₁ F₃\nf : Quiver.Hom F₁ F₂\ng : Quiver.Hom F₂ F₃\n⊢ Eq ((CategoryTheory.Enriched.FunctorCategory.homEquiv V) (CategoryTheory.CategoryStruct.comp f g)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.leftUnitor CategoryTheory.MonoidalCategoryStruct.tensorUnit).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom ((CategoryTheory.Enriched.FunctorCategory.homEquiv V) f) ((CategoryTheory.Enriched.FunctorCategory.homEquiv V) g)) (CategoryTheory.Enriched.FunctorCategory.enrichedComp V F₁ F₂ F₃)))","decl":"@[reassoc]\nlemma homEquiv_comp (f : F₁ ⟶ F₂) (g : F₂ ⟶ F₃) :\n    (homEquiv V) (f ≫ g) = (λ_ (𝟙_ V)).inv ≫ ((homEquiv V) f ⊗ (homEquiv V) g) ≫\n    enrichedComp V F₁ F₂ F₃ := by\n  ext j\n  simp only [homEquiv_apply_π, NatTrans.comp_app, eHomEquiv_comp, assoc,\n    enrichedComp_π, Functor.op_obj, ← tensor_comp_assoc]\n\n"}
{"name":"CategoryTheory.Enriched.FunctorCategory.homEquiv_comp_assoc","module":"Mathlib.CategoryTheory.Enriched.FunctorCategory","initialProofState":"V : Type u₁\ninst✝⁷ : CategoryTheory.Category.{v₁, u₁} V\ninst✝⁶ : CategoryTheory.MonoidalCategory V\nC : Type u₂\ninst✝⁵ : CategoryTheory.Category.{v₂, u₂} C\nJ : Type u₃\ninst✝⁴ : CategoryTheory.Category.{v₃, u₃} J\ninst✝³ : CategoryTheory.EnrichedOrdinaryCategory V C\nF₁ F₂ F₃ : CategoryTheory.Functor J C\ninst✝² : CategoryTheory.Enriched.FunctorCategory.HasEnrichedHom V F₁ F₂\ninst✝¹ : CategoryTheory.Enriched.FunctorCategory.HasEnrichedHom V F₂ F₃\ninst✝ : CategoryTheory.Enriched.FunctorCategory.HasEnrichedHom V F₁ F₃\nf : Quiver.Hom F₁ F₂\ng : Quiver.Hom F₂ F₃\nZ : V\nh : Quiver.Hom (CategoryTheory.Enriched.FunctorCategory.enrichedHom V F₁ F₃) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Enriched.FunctorCategory.homEquiv V) (CategoryTheory.CategoryStruct.comp f g)) h) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.leftUnitor CategoryTheory.MonoidalCategoryStruct.tensorUnit).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom ((CategoryTheory.Enriched.FunctorCategory.homEquiv V) f) ((CategoryTheory.Enriched.FunctorCategory.homEquiv V) g)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Enriched.FunctorCategory.enrichedComp V F₁ F₂ F₃) h)))","decl":"@[reassoc]\nlemma homEquiv_comp (f : F₁ ⟶ F₂) (g : F₂ ⟶ F₃) :\n    (homEquiv V) (f ≫ g) = (λ_ (𝟙_ V)).inv ≫ ((homEquiv V) f ⊗ (homEquiv V) g) ≫\n    enrichedComp V F₁ F₂ F₃ := by\n  ext j\n  simp only [homEquiv_apply_π, NatTrans.comp_app, eHomEquiv_comp, assoc,\n    enrichedComp_π, Functor.op_obj, ← tensor_comp_assoc]\n\n"}
{"name":"CategoryTheory.Enriched.FunctorCategory.enriched_id_comp_assoc","module":"Mathlib.CategoryTheory.Enriched.FunctorCategory","initialProofState":"V : Type u₁\ninst✝⁶ : CategoryTheory.Category.{v₁, u₁} V\ninst✝⁵ : CategoryTheory.MonoidalCategory V\nC : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₂, u₂} C\nJ : Type u₃\ninst✝³ : CategoryTheory.Category.{v₃, u₃} J\ninst✝² : CategoryTheory.EnrichedOrdinaryCategory V C\nF₁ F₂ : CategoryTheory.Functor J C\ninst✝¹ : CategoryTheory.Enriched.FunctorCategory.HasEnrichedHom V F₁ F₁\ninst✝ : CategoryTheory.Enriched.FunctorCategory.HasEnrichedHom V F₁ F₂\nZ : V\nh : Quiver.Hom (CategoryTheory.Enriched.FunctorCategory.enrichedHom V F₁ F₂) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.leftUnitor (CategoryTheory.Enriched.FunctorCategory.enrichedHom V F₁ F₂)).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.Enriched.FunctorCategory.enrichedId V F₁) (CategoryTheory.Enriched.FunctorCategory.enrichedHom V F₁ F₂)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Enriched.FunctorCategory.enrichedComp V F₁ F₁ F₂) h))) h","decl":"@[reassoc (attr := simp)]\nlemma enriched_id_comp [HasEnrichedHom V F₁ F₁] [HasEnrichedHom V F₁ F₂] :\n    (λ_ (enrichedHom V F₁ F₂)).inv ≫ enrichedId V F₁ ▷ enrichedHom V F₁ F₂ ≫\n      enrichedComp V F₁ F₁ F₂ = 𝟙 _ := by\n  ext j\n  rw [assoc, assoc, enrichedComp_π, id_comp, tensorHom_def, assoc,\n    ← comp_whiskerRight_assoc, enrichedId_π, ← whisker_exchange_assoc,\n    id_whiskerLeft, assoc, assoc, Iso.inv_hom_id_assoc]\n  dsimp\n  rw [e_id_comp, comp_id]\n\n"}
{"name":"CategoryTheory.Enriched.FunctorCategory.enriched_id_comp","module":"Mathlib.CategoryTheory.Enriched.FunctorCategory","initialProofState":"V : Type u₁\ninst✝⁶ : CategoryTheory.Category.{v₁, u₁} V\ninst✝⁵ : CategoryTheory.MonoidalCategory V\nC : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₂, u₂} C\nJ : Type u₃\ninst✝³ : CategoryTheory.Category.{v₃, u₃} J\ninst✝² : CategoryTheory.EnrichedOrdinaryCategory V C\nF₁ F₂ : CategoryTheory.Functor J C\ninst✝¹ : CategoryTheory.Enriched.FunctorCategory.HasEnrichedHom V F₁ F₁\ninst✝ : CategoryTheory.Enriched.FunctorCategory.HasEnrichedHom V F₁ F₂\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.leftUnitor (CategoryTheory.Enriched.FunctorCategory.enrichedHom V F₁ F₂)).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.Enriched.FunctorCategory.enrichedId V F₁) (CategoryTheory.Enriched.FunctorCategory.enrichedHom V F₁ F₂)) (CategoryTheory.Enriched.FunctorCategory.enrichedComp V F₁ F₁ F₂))) (CategoryTheory.CategoryStruct.id (CategoryTheory.Enriched.FunctorCategory.enrichedHom V F₁ F₂))","decl":"@[reassoc (attr := simp)]\nlemma enriched_id_comp [HasEnrichedHom V F₁ F₁] [HasEnrichedHom V F₁ F₂] :\n    (λ_ (enrichedHom V F₁ F₂)).inv ≫ enrichedId V F₁ ▷ enrichedHom V F₁ F₂ ≫\n      enrichedComp V F₁ F₁ F₂ = 𝟙 _ := by\n  ext j\n  rw [assoc, assoc, enrichedComp_π, id_comp, tensorHom_def, assoc,\n    ← comp_whiskerRight_assoc, enrichedId_π, ← whisker_exchange_assoc,\n    id_whiskerLeft, assoc, assoc, Iso.inv_hom_id_assoc]\n  dsimp\n  rw [e_id_comp, comp_id]\n\n"}
{"name":"CategoryTheory.Enriched.FunctorCategory.enriched_comp_id","module":"Mathlib.CategoryTheory.Enriched.FunctorCategory","initialProofState":"V : Type u₁\ninst✝⁶ : CategoryTheory.Category.{v₁, u₁} V\ninst✝⁵ : CategoryTheory.MonoidalCategory V\nC : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₂, u₂} C\nJ : Type u₃\ninst✝³ : CategoryTheory.Category.{v₃, u₃} J\ninst✝² : CategoryTheory.EnrichedOrdinaryCategory V C\nF₁ F₂ : CategoryTheory.Functor J C\ninst✝¹ : CategoryTheory.Enriched.FunctorCategory.HasEnrichedHom V F₁ F₂\ninst✝ : CategoryTheory.Enriched.FunctorCategory.HasEnrichedHom V F₂ F₂\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.rightUnitor (CategoryTheory.Enriched.FunctorCategory.enrichedHom V F₁ F₂)).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (CategoryTheory.Enriched.FunctorCategory.enrichedHom V F₁ F₂) (CategoryTheory.Enriched.FunctorCategory.enrichedId V F₂)) (CategoryTheory.Enriched.FunctorCategory.enrichedComp V F₁ F₂ F₂))) (CategoryTheory.CategoryStruct.id (CategoryTheory.Enriched.FunctorCategory.enrichedHom V F₁ F₂))","decl":"@[reassoc (attr := simp)]\nlemma enriched_comp_id [HasEnrichedHom V F₁ F₂] [HasEnrichedHom V F₂ F₂] :\n    (ρ_ (enrichedHom V F₁ F₂)).inv ≫ enrichedHom V F₁ F₂ ◁ enrichedId V F₂ ≫\n      enrichedComp V F₁ F₂ F₂ = 𝟙 _ := by\n  ext j\n  rw [assoc, assoc, enrichedComp_π, id_comp, tensorHom_def', assoc,\n    ← MonoidalCategory.whiskerLeft_comp_assoc, enrichedId_π,\n    whisker_exchange_assoc, MonoidalCategory.whiskerRight_id, assoc, assoc,\n    Iso.inv_hom_id_assoc]\n  dsimp\n  rw [e_comp_id, comp_id]\n\n"}
{"name":"CategoryTheory.Enriched.FunctorCategory.enriched_comp_id_assoc","module":"Mathlib.CategoryTheory.Enriched.FunctorCategory","initialProofState":"V : Type u₁\ninst✝⁶ : CategoryTheory.Category.{v₁, u₁} V\ninst✝⁵ : CategoryTheory.MonoidalCategory V\nC : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₂, u₂} C\nJ : Type u₃\ninst✝³ : CategoryTheory.Category.{v₃, u₃} J\ninst✝² : CategoryTheory.EnrichedOrdinaryCategory V C\nF₁ F₂ : CategoryTheory.Functor J C\ninst✝¹ : CategoryTheory.Enriched.FunctorCategory.HasEnrichedHom V F₁ F₂\ninst✝ : CategoryTheory.Enriched.FunctorCategory.HasEnrichedHom V F₂ F₂\nZ : V\nh : Quiver.Hom (CategoryTheory.Enriched.FunctorCategory.enrichedHom V F₁ F₂) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.rightUnitor (CategoryTheory.Enriched.FunctorCategory.enrichedHom V F₁ F₂)).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (CategoryTheory.Enriched.FunctorCategory.enrichedHom V F₁ F₂) (CategoryTheory.Enriched.FunctorCategory.enrichedId V F₂)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Enriched.FunctorCategory.enrichedComp V F₁ F₂ F₂) h))) h","decl":"@[reassoc (attr := simp)]\nlemma enriched_comp_id [HasEnrichedHom V F₁ F₂] [HasEnrichedHom V F₂ F₂] :\n    (ρ_ (enrichedHom V F₁ F₂)).inv ≫ enrichedHom V F₁ F₂ ◁ enrichedId V F₂ ≫\n      enrichedComp V F₁ F₂ F₂ = 𝟙 _ := by\n  ext j\n  rw [assoc, assoc, enrichedComp_π, id_comp, tensorHom_def', assoc,\n    ← MonoidalCategory.whiskerLeft_comp_assoc, enrichedId_π,\n    whisker_exchange_assoc, MonoidalCategory.whiskerRight_id, assoc, assoc,\n    Iso.inv_hom_id_assoc]\n  dsimp\n  rw [e_comp_id, comp_id]\n\n"}
{"name":"CategoryTheory.Enriched.FunctorCategory.enriched_assoc_assoc","module":"Mathlib.CategoryTheory.Enriched.FunctorCategory","initialProofState":"V : Type u₁\ninst✝¹⁰ : CategoryTheory.Category.{v₁, u₁} V\ninst✝⁹ : CategoryTheory.MonoidalCategory V\nC : Type u₂\ninst✝⁸ : CategoryTheory.Category.{v₂, u₂} C\nJ : Type u₃\ninst✝⁷ : CategoryTheory.Category.{v₃, u₃} J\ninst✝⁶ : CategoryTheory.EnrichedOrdinaryCategory V C\nF₁ F₂ F₃ F₄ : CategoryTheory.Functor J C\ninst✝⁵ : CategoryTheory.Enriched.FunctorCategory.HasEnrichedHom V F₁ F₂\ninst✝⁴ : CategoryTheory.Enriched.FunctorCategory.HasEnrichedHom V F₁ F₃\ninst✝³ : CategoryTheory.Enriched.FunctorCategory.HasEnrichedHom V F₁ F₄\ninst✝² : CategoryTheory.Enriched.FunctorCategory.HasEnrichedHom V F₂ F₃\ninst✝¹ : CategoryTheory.Enriched.FunctorCategory.HasEnrichedHom V F₂ F₄\ninst✝ : CategoryTheory.Enriched.FunctorCategory.HasEnrichedHom V F₃ F₄\nZ : V\nh : Quiver.Hom (CategoryTheory.Enriched.FunctorCategory.enrichedHom V F₁ F₄) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator (CategoryTheory.Enriched.FunctorCategory.enrichedHom V F₁ F₂) (CategoryTheory.Enriched.FunctorCategory.enrichedHom V F₂ F₃) (CategoryTheory.Enriched.FunctorCategory.enrichedHom V F₃ F₄)).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.Enriched.FunctorCategory.enrichedComp V F₁ F₂ F₃) (CategoryTheory.Enriched.FunctorCategory.enrichedHom V F₃ F₄)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Enriched.FunctorCategory.enrichedComp V F₁ F₃ F₄) h))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (CategoryTheory.Enriched.FunctorCategory.enrichedHom V F₁ F₂) (CategoryTheory.Enriched.FunctorCategory.enrichedComp V F₂ F₃ F₄)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Enriched.FunctorCategory.enrichedComp V F₁ F₂ F₄) h))","decl":"@[reassoc]\nlemma enriched_assoc [HasEnrichedHom V F₁ F₂] [HasEnrichedHom V F₁ F₃] [HasEnrichedHom V F₁ F₄]\n    [HasEnrichedHom V F₂ F₃] [HasEnrichedHom V F₂ F₄] [HasEnrichedHom V F₃ F₄] :\n    (α_ (enrichedHom V F₁ F₂) (enrichedHom V F₂ F₃) (enrichedHom V F₃ F₄)).inv ≫\n      enrichedComp V F₁ F₂ F₃ ▷ enrichedHom V F₃ F₄ ≫ enrichedComp V F₁ F₃ F₄ =\n      enrichedHom V F₁ F₂ ◁ enrichedComp V F₂ F₃ F₄ ≫ enrichedComp V F₁ F₂ F₄ := by\n  ext j\n  conv_lhs =>\n    rw [assoc, assoc, enrichedComp_π,\n      tensorHom_def_assoc, ← comp_whiskerRight_assoc, enrichedComp_π,\n      comp_whiskerRight_assoc, ← whisker_exchange_assoc,\n      ← whisker_exchange_assoc, ← tensorHom_def'_assoc, ← associator_inv_naturality_assoc]\n  conv_rhs =>\n    rw [assoc, enrichedComp_π, tensorHom_def'_assoc, ← MonoidalCategory.whiskerLeft_comp_assoc,\n      enrichedComp_π, MonoidalCategory.whiskerLeft_comp_assoc, whisker_exchange_assoc,\n      whisker_exchange_assoc, ← tensorHom_def_assoc]\n  dsimp\n  rw [e_assoc]\n\n"}
{"name":"CategoryTheory.Enriched.FunctorCategory.enriched_assoc","module":"Mathlib.CategoryTheory.Enriched.FunctorCategory","initialProofState":"V : Type u₁\ninst✝¹⁰ : CategoryTheory.Category.{v₁, u₁} V\ninst✝⁹ : CategoryTheory.MonoidalCategory V\nC : Type u₂\ninst✝⁸ : CategoryTheory.Category.{v₂, u₂} C\nJ : Type u₃\ninst✝⁷ : CategoryTheory.Category.{v₃, u₃} J\ninst✝⁶ : CategoryTheory.EnrichedOrdinaryCategory V C\nF₁ F₂ F₃ F₄ : CategoryTheory.Functor J C\ninst✝⁵ : CategoryTheory.Enriched.FunctorCategory.HasEnrichedHom V F₁ F₂\ninst✝⁴ : CategoryTheory.Enriched.FunctorCategory.HasEnrichedHom V F₁ F₃\ninst✝³ : CategoryTheory.Enriched.FunctorCategory.HasEnrichedHom V F₁ F₄\ninst✝² : CategoryTheory.Enriched.FunctorCategory.HasEnrichedHom V F₂ F₃\ninst✝¹ : CategoryTheory.Enriched.FunctorCategory.HasEnrichedHom V F₂ F₄\ninst✝ : CategoryTheory.Enriched.FunctorCategory.HasEnrichedHom V F₃ F₄\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator (CategoryTheory.Enriched.FunctorCategory.enrichedHom V F₁ F₂) (CategoryTheory.Enriched.FunctorCategory.enrichedHom V F₂ F₃) (CategoryTheory.Enriched.FunctorCategory.enrichedHom V F₃ F₄)).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.Enriched.FunctorCategory.enrichedComp V F₁ F₂ F₃) (CategoryTheory.Enriched.FunctorCategory.enrichedHom V F₃ F₄)) (CategoryTheory.Enriched.FunctorCategory.enrichedComp V F₁ F₃ F₄))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (CategoryTheory.Enriched.FunctorCategory.enrichedHom V F₁ F₂) (CategoryTheory.Enriched.FunctorCategory.enrichedComp V F₂ F₃ F₄)) (CategoryTheory.Enriched.FunctorCategory.enrichedComp V F₁ F₂ F₄))","decl":"@[reassoc]\nlemma enriched_assoc [HasEnrichedHom V F₁ F₂] [HasEnrichedHom V F₁ F₃] [HasEnrichedHom V F₁ F₄]\n    [HasEnrichedHom V F₂ F₃] [HasEnrichedHom V F₂ F₄] [HasEnrichedHom V F₃ F₄] :\n    (α_ (enrichedHom V F₁ F₂) (enrichedHom V F₂ F₃) (enrichedHom V F₃ F₄)).inv ≫\n      enrichedComp V F₁ F₂ F₃ ▷ enrichedHom V F₃ F₄ ≫ enrichedComp V F₁ F₃ F₄ =\n      enrichedHom V F₁ F₂ ◁ enrichedComp V F₂ F₃ F₄ ≫ enrichedComp V F₁ F₂ F₄ := by\n  ext j\n  conv_lhs =>\n    rw [assoc, assoc, enrichedComp_π,\n      tensorHom_def_assoc, ← comp_whiskerRight_assoc, enrichedComp_π,\n      comp_whiskerRight_assoc, ← whisker_exchange_assoc,\n      ← whisker_exchange_assoc, ← tensorHom_def'_assoc, ← associator_inv_naturality_assoc]\n  conv_rhs =>\n    rw [assoc, enrichedComp_π, tensorHom_def'_assoc, ← MonoidalCategory.whiskerLeft_comp_assoc,\n      enrichedComp_π, MonoidalCategory.whiskerLeft_comp_assoc, whisker_exchange_assoc,\n      whisker_exchange_assoc, ← tensorHom_def_assoc]\n  dsimp\n  rw [e_assoc]\n\n"}
{"name":"CategoryTheory.Enriched.FunctorCategory.instHasEnrichedHomUnderCompMapForget","module":"Mathlib.CategoryTheory.Enriched.FunctorCategory","initialProofState":"V : Type u₁\ninst✝⁵ : CategoryTheory.Category.{v₁, u₁} V\ninst✝⁴ : CategoryTheory.MonoidalCategory V\nC : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} C\nJ : Type u₃\ninst✝² : CategoryTheory.Category.{v₃, u₃} J\ninst✝¹ : CategoryTheory.EnrichedOrdinaryCategory V C\nF₁ F₂ : CategoryTheory.Functor J C\ninst✝ : CategoryTheory.Enriched.FunctorCategory.HasFunctorEnrichedHom V F₁ F₂\nj j' : J\nf : Quiver.Hom j j'\n⊢ CategoryTheory.Enriched.FunctorCategory.HasEnrichedHom V ((CategoryTheory.Under.map f).comp ((CategoryTheory.Under.forget j).comp F₁)) ((CategoryTheory.Under.map f).comp ((CategoryTheory.Under.forget j).comp F₂))","decl":"instance {j j' : J} (f : j ⟶ j') :\n    HasEnrichedHom V (Under.map f ⋙ Under.forget j ⋙ F₁)\n      (Under.map f ⋙ Under.forget j ⋙ F₂) :=\n  inferInstanceAs (HasEnrichedHom V (Under.forget j' ⋙ F₁) (Under.forget j' ⋙ F₂))\n\n"}
{"name":"CategoryTheory.Enriched.FunctorCategory.functorEnrichedHom_obj","module":"Mathlib.CategoryTheory.Enriched.FunctorCategory","initialProofState":"V : Type u₁\ninst✝⁵ : CategoryTheory.Category.{v₁, u₁} V\ninst✝⁴ : CategoryTheory.MonoidalCategory V\nC : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} C\nJ : Type u₃\ninst✝² : CategoryTheory.Category.{v₃, u₃} J\ninst✝¹ : CategoryTheory.EnrichedOrdinaryCategory V C\nF₁ F₂ : CategoryTheory.Functor J C\ninst✝ : CategoryTheory.Enriched.FunctorCategory.HasFunctorEnrichedHom V F₁ F₂\nj : J\n⊢ Eq ((CategoryTheory.Enriched.FunctorCategory.functorEnrichedHom V F₁ F₂).obj j) (CategoryTheory.Enriched.FunctorCategory.enrichedHom V ((CategoryTheory.Under.forget j).comp F₁) ((CategoryTheory.Under.forget j).comp F₂))","decl":"/-- Given functors `F₁` and `F₂` in `J ⥤ C`, where `C` is a category enriched in `V`,\nthis is the enriched hom functor from `F₁` to `F₂` in `J ⥤ V`. -/\n@[simps!]\nnoncomputable def functorEnrichedHom : J ⥤ V where\n  obj j := enrichedHom V (Under.forget j ⋙ F₁) (Under.forget j ⋙ F₂)\n  map f := precompEnrichedHom V (Under.forget _ ⋙ F₁) (Under.forget _ ⋙ F₂) (Under.map f)\n  map_id X := by\n    dsimp\n    ext j\n    dsimp\n    simp only [end_.lift_π, id_comp]\n    congr 1\n    simp [Under.map, Comma.mapLeft]\n    rfl\n  map_comp f g := by\n    dsimp\n    ext j\n    rw [end_.lift_π, assoc]\n    erw [end_.lift_π, end_.lift_π]\n    congr 1\n    simp [Under.map, Comma.mapLeft]\n\n"}
{"name":"CategoryTheory.Enriched.FunctorCategory.functorEnrichedHom_map","module":"Mathlib.CategoryTheory.Enriched.FunctorCategory","initialProofState":"V : Type u₁\ninst✝⁵ : CategoryTheory.Category.{v₁, u₁} V\ninst✝⁴ : CategoryTheory.MonoidalCategory V\nC : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} C\nJ : Type u₃\ninst✝² : CategoryTheory.Category.{v₃, u₃} J\ninst✝¹ : CategoryTheory.EnrichedOrdinaryCategory V C\nF₁ F₂ : CategoryTheory.Functor J C\ninst✝ : CategoryTheory.Enriched.FunctorCategory.HasFunctorEnrichedHom V F₁ F₂\nX✝ Y✝ : J\nf : Quiver.Hom X✝ Y✝\n⊢ Eq ((CategoryTheory.Enriched.FunctorCategory.functorEnrichedHom V F₁ F₂).map f) (CategoryTheory.Enriched.FunctorCategory.precompEnrichedHom V ((CategoryTheory.Under.forget X✝).comp F₁) ((CategoryTheory.Under.forget X✝).comp F₂) (CategoryTheory.Under.map f))","decl":"/-- Given functors `F₁` and `F₂` in `J ⥤ C`, where `C` is a category enriched in `V`,\nthis is the enriched hom functor from `F₁` to `F₂` in `J ⥤ V`. -/\n@[simps!]\nnoncomputable def functorEnrichedHom : J ⥤ V where\n  obj j := enrichedHom V (Under.forget j ⋙ F₁) (Under.forget j ⋙ F₂)\n  map f := precompEnrichedHom V (Under.forget _ ⋙ F₁) (Under.forget _ ⋙ F₂) (Under.map f)\n  map_id X := by\n    dsimp\n    ext j\n    dsimp\n    simp only [end_.lift_π, id_comp]\n    congr 1\n    simp [Under.map, Comma.mapLeft]\n    rfl\n  map_comp f g := by\n    dsimp\n    ext j\n    rw [end_.lift_π, assoc]\n    erw [end_.lift_π, end_.lift_π]\n    congr 1\n    simp [Under.map, Comma.mapLeft]\n\n"}
{"name":"CategoryTheory.Enriched.FunctorCategory.coneFunctorEnrichedHom_pt","module":"Mathlib.CategoryTheory.Enriched.FunctorCategory","initialProofState":"V : Type u₁\ninst✝⁶ : CategoryTheory.Category.{v₁, u₁} V\ninst✝⁵ : CategoryTheory.MonoidalCategory V\nC : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₂, u₂} C\nJ : Type u₃\ninst✝³ : CategoryTheory.Category.{v₃, u₃} J\ninst✝² : CategoryTheory.EnrichedOrdinaryCategory V C\nF₁ F₂ : CategoryTheory.Functor J C\ninst✝¹ : CategoryTheory.Enriched.FunctorCategory.HasFunctorEnrichedHom V F₁ F₂\ninst✝ : CategoryTheory.Enriched.FunctorCategory.HasEnrichedHom V F₁ F₂\n⊢ Eq (CategoryTheory.Enriched.FunctorCategory.coneFunctorEnrichedHom V F₁ F₂).pt (CategoryTheory.Enriched.FunctorCategory.enrichedHom V F₁ F₂)","decl":"/-- The (limit) cone expressing that the limit of `functorEnrichedHom V F₁ F₂`\nis `enrichedHom V F₁ F₂`. -/\n@[simps pt]\nnoncomputable def coneFunctorEnrichedHom : Cone (functorEnrichedHom V F₁ F₂) where\n  pt := enrichedHom V F₁ F₂\n  π :=\n    { app := fun j ↦ precompEnrichedHom V F₁ F₂ (Under.forget j)\n      naturality := fun j j' f ↦ by\n        dsimp\n        rw [id_comp]\n        ext k\n        rw [assoc, end_.lift_π]\n        erw [end_.lift_π]\n        rw [end_.lift_π]\n        rfl }\n\n"}
{"name":"CategoryTheory.Enriched.FunctorCategory.isLimitConeFunctorEnrichedHom.fac","module":"Mathlib.CategoryTheory.Enriched.FunctorCategory","initialProofState":"V : Type u₁\ninst✝⁶ : CategoryTheory.Category.{v₁, u₁} V\ninst✝⁵ : CategoryTheory.MonoidalCategory V\nC : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₂, u₂} C\nJ : Type u₃\ninst✝³ : CategoryTheory.Category.{v₃, u₃} J\ninst✝² : CategoryTheory.EnrichedOrdinaryCategory V C\nF₁ F₂ : CategoryTheory.Functor J C\ninst✝¹ : CategoryTheory.Enriched.FunctorCategory.HasFunctorEnrichedHom V F₁ F₂\ninst✝ : CategoryTheory.Enriched.FunctorCategory.HasEnrichedHom V F₁ F₂\ns : CategoryTheory.Limits.Cone (CategoryTheory.Enriched.FunctorCategory.functorEnrichedHom V F₁ F₂)\nj : J\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Enriched.FunctorCategory.isLimitConeFunctorEnrichedHom.lift s) ((CategoryTheory.Enriched.FunctorCategory.coneFunctorEnrichedHom V F₁ F₂).π.app j)) (s.π.app j)","decl":"lemma fac (j : J) : lift s ≫ (coneFunctorEnrichedHom V F₁ F₂).π.app j = s.π.app j := by\n  dsimp [coneFunctorEnrichedHom]\n  ext k\n  rw [assoc]\n  erw [end_.lift_π, end_.lift_π, ← s.w k.hom]\n  rw [assoc]\n  dsimp\n  erw [end_.lift_π]\n  congr\n  simp [Under.map, Comma.mapLeft]\n  rfl\n\n"}
