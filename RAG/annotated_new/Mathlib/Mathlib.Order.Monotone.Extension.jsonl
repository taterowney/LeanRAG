{"name":"MonotoneOn.exists_monotone_extension","module":"Mathlib.Order.Monotone.Extension","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : LinearOrder α\ninst✝ : ConditionallyCompleteLinearOrder β\nf : α → β\ns : Set α\nh : MonotoneOn f s\nhl : BddBelow (Set.image f s)\nhu : BddAbove (Set.image f s)\n⊢ Exists fun g => And (Monotone g) (Set.EqOn f g s)","decl":"/-- If a function is monotone and is bounded on a set `s`, then it admits a monotone extension to\nthe whole space. -/\ntheorem MonotoneOn.exists_monotone_extension (h : MonotoneOn f s) (hl : BddBelow (f '' s))\n    (hu : BddAbove (f '' s)) : ∃ g : α → β, Monotone g ∧ EqOn f g s := by\n  classical\n    /- The extension is defined by `f x = f a` for `x ≤ a`, and `f x` is the supremum of the values\n      of `f` to the left of `x` for `x ≥ a`. -/\n    rcases hl with ⟨a, ha⟩\n    have hu' : ∀ x, BddAbove (f '' (Iic x ∩ s)) := fun x =>\n      hu.mono (image_subset _ inter_subset_right)\n    let g : α → β := fun x => if Disjoint (Iic x) s then a else sSup (f '' (Iic x ∩ s))\n    have hgs : EqOn f g s := by\n      intro x hx\n      simp only [g]\n      have : IsGreatest (Iic x ∩ s) x := ⟨⟨right_mem_Iic, hx⟩, fun y hy => hy.1⟩\n      rw [if_neg this.nonempty.not_disjoint,\n        ((h.mono inter_subset_right).map_isGreatest this).csSup_eq]\n    refine ⟨g, fun x y hxy => ?_, hgs⟩\n    by_cases hx : Disjoint (Iic x) s <;> by_cases hy : Disjoint (Iic y) s <;>\n      simp only [g, if_pos, if_neg, not_false_iff, *, refl]\n    · rcases not_disjoint_iff_nonempty_inter.1 hy with ⟨z, hz⟩\n      exact le_csSup_of_le (hu' _) (mem_image_of_mem _ hz) (ha <| mem_image_of_mem _ hz.2)\n    · exact (hx <| hy.mono_left <| Iic_subset_Iic.2 hxy).elim\n    · rw [not_disjoint_iff_nonempty_inter] at hx hy\n      refine csSup_le_csSup (hu' _) (hx.image _) (image_subset _ ?_)\n      exact inter_subset_inter_left _ (Iic_subset_Iic.2 hxy)\n\n"}
{"name":"AntitoneOn.exists_antitone_extension","module":"Mathlib.Order.Monotone.Extension","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : LinearOrder α\ninst✝ : ConditionallyCompleteLinearOrder β\nf : α → β\ns : Set α\nh : AntitoneOn f s\nhl : BddBelow (Set.image f s)\nhu : BddAbove (Set.image f s)\n⊢ Exists fun g => And (Antitone g) (Set.EqOn f g s)","decl":"/-- If a function is antitone and is bounded on a set `s`, then it admits an antitone extension to\nthe whole space. -/\ntheorem AntitoneOn.exists_antitone_extension (h : AntitoneOn f s) (hl : BddBelow (f '' s))\n    (hu : BddAbove (f '' s)) : ∃ g : α → β, Antitone g ∧ EqOn f g s :=\n  h.dual_right.exists_monotone_extension hu hl\n"}
