{"name":"CategoryTheory.leftAdjointOfStructuredArrowInitialsAux_apply","module":"Mathlib.CategoryTheory.Adjunction.Comma","initialProofState":"C : Type u₁\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nG : CategoryTheory.Functor D C\ninst✝ : ∀ (A : C), CategoryTheory.Limits.HasInitial (CategoryTheory.StructuredArrow A G)\nA : C\nB : D\ng : Quiver.Hom (CategoryTheory.Limits.initial (CategoryTheory.StructuredArrow A G)).right B\n⊢ Eq ((CategoryTheory.leftAdjointOfStructuredArrowInitialsAux G A B) g) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.initial (CategoryTheory.StructuredArrow A G)).hom (G.map g))","decl":"attribute [local simp] eq_iff_true_of_subsingleton in\n/-- Implementation: If each structured arrow category on `G` has an initial object, an equivalence\nwhich is helpful for constructing a left adjoint to `G`.\n-/\n@[simps]\ndef leftAdjointOfStructuredArrowInitialsAux (A : C) (B : D) :\n    ((⊥_ StructuredArrow A G).right ⟶ B) ≃ (A ⟶ G.obj B) where\n  toFun g := (⊥_ StructuredArrow A G).hom ≫ G.map g\n  invFun f := CommaMorphism.right (initial.to (StructuredArrow.mk f))\n  left_inv g := by\n    let B' : StructuredArrow A G := StructuredArrow.mk ((⊥_ StructuredArrow A G).hom ≫ G.map g)\n    let g' : ⊥_ StructuredArrow A G ⟶ B' := StructuredArrow.homMk g rfl\n    have : initial.to _ = g' := by aesop_cat\n    change CommaMorphism.right (initial.to B') = _\n    rw [this]\n    rfl\n  right_inv f := by\n    let B' : StructuredArrow A G := StructuredArrow.mk f\n    apply (CommaMorphism.w (initial.to B')).symm.trans (Category.id_comp _)\n\n"}
{"name":"CategoryTheory.leftAdjointOfStructuredArrowInitialsAux_symm_apply","module":"Mathlib.CategoryTheory.Adjunction.Comma","initialProofState":"C : Type u₁\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nG : CategoryTheory.Functor D C\ninst✝ : ∀ (A : C), CategoryTheory.Limits.HasInitial (CategoryTheory.StructuredArrow A G)\nA : C\nB : D\nf : Quiver.Hom A (G.obj B)\n⊢ Eq ((CategoryTheory.leftAdjointOfStructuredArrowInitialsAux G A B).symm f) (CategoryTheory.Limits.initial.to (CategoryTheory.StructuredArrow.mk f)).right","decl":"attribute [local simp] eq_iff_true_of_subsingleton in\n/-- Implementation: If each structured arrow category on `G` has an initial object, an equivalence\nwhich is helpful for constructing a left adjoint to `G`.\n-/\n@[simps]\ndef leftAdjointOfStructuredArrowInitialsAux (A : C) (B : D) :\n    ((⊥_ StructuredArrow A G).right ⟶ B) ≃ (A ⟶ G.obj B) where\n  toFun g := (⊥_ StructuredArrow A G).hom ≫ G.map g\n  invFun f := CommaMorphism.right (initial.to (StructuredArrow.mk f))\n  left_inv g := by\n    let B' : StructuredArrow A G := StructuredArrow.mk ((⊥_ StructuredArrow A G).hom ≫ G.map g)\n    let g' : ⊥_ StructuredArrow A G ⟶ B' := StructuredArrow.homMk g rfl\n    have : initial.to _ = g' := by aesop_cat\n    change CommaMorphism.right (initial.to B') = _\n    rw [this]\n    rfl\n  right_inv f := by\n    let B' : StructuredArrow A G := StructuredArrow.mk f\n    apply (CommaMorphism.w (initial.to B')).symm.trans (Category.id_comp _)\n\n"}
{"name":"CategoryTheory.isRightAdjointOfStructuredArrowInitials","module":"Mathlib.CategoryTheory.Adjunction.Comma","initialProofState":"C : Type u₁\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nG : CategoryTheory.Functor D C\ninst✝ : ∀ (A : C), CategoryTheory.Limits.HasInitial (CategoryTheory.StructuredArrow A G)\n⊢ G.IsRightAdjoint","decl":"/-- If each structured arrow category on `G` has an initial object, `G` is a right adjoint. -/\nlemma isRightAdjointOfStructuredArrowInitials : G.IsRightAdjoint where\n  exists_leftAdjoint := ⟨_, ⟨adjunctionOfStructuredArrowInitials G⟩⟩\n\n"}
{"name":"CategoryTheory.rightAdjointOfCostructuredArrowTerminalsAux_symm_apply","module":"Mathlib.CategoryTheory.Adjunction.Comma","initialProofState":"C : Type u₁\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nG : CategoryTheory.Functor D C\ninst✝ : ∀ (A : C), CategoryTheory.Limits.HasTerminal (CategoryTheory.CostructuredArrow G A)\nB : D\nA : C\ng : Quiver.Hom B (CategoryTheory.Limits.terminal (CategoryTheory.CostructuredArrow G A)).left\n⊢ Eq ((CategoryTheory.rightAdjointOfCostructuredArrowTerminalsAux G B A).symm g) (CategoryTheory.CategoryStruct.comp (G.map g) (CategoryTheory.Limits.terminal (CategoryTheory.CostructuredArrow G A)).hom)","decl":"attribute [local simp] eq_iff_true_of_subsingleton in\n/-- Implementation: If each costructured arrow category on `G` has a terminal object, an equivalence\nwhich is helpful for constructing a right adjoint to `G`.\n-/\n@[simps]\ndef rightAdjointOfCostructuredArrowTerminalsAux (B : D) (A : C) :\n    (G.obj B ⟶ A) ≃ (B ⟶ (⊤_ CostructuredArrow G A).left) where\n  toFun g := CommaMorphism.left (terminal.from (CostructuredArrow.mk g))\n  invFun g := G.map g ≫ (⊤_ CostructuredArrow G A).hom\n  left_inv := by aesop_cat\n  right_inv g := by\n    let B' : CostructuredArrow G A :=\n      CostructuredArrow.mk (G.map g ≫ (⊤_ CostructuredArrow G A).hom)\n    let g' : B' ⟶ ⊤_ CostructuredArrow G A := CostructuredArrow.homMk g rfl\n    have : terminal.from _ = g' := by aesop_cat\n    change CommaMorphism.left (terminal.from B') = _\n    rw [this]\n    rfl\n\n"}
{"name":"CategoryTheory.rightAdjointOfCostructuredArrowTerminalsAux_apply","module":"Mathlib.CategoryTheory.Adjunction.Comma","initialProofState":"C : Type u₁\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nG : CategoryTheory.Functor D C\ninst✝ : ∀ (A : C), CategoryTheory.Limits.HasTerminal (CategoryTheory.CostructuredArrow G A)\nB : D\nA : C\ng : Quiver.Hom (G.obj B) A\n⊢ Eq ((CategoryTheory.rightAdjointOfCostructuredArrowTerminalsAux G B A) g) (CategoryTheory.Limits.terminal.from (CategoryTheory.CostructuredArrow.mk g)).left","decl":"attribute [local simp] eq_iff_true_of_subsingleton in\n/-- Implementation: If each costructured arrow category on `G` has a terminal object, an equivalence\nwhich is helpful for constructing a right adjoint to `G`.\n-/\n@[simps]\ndef rightAdjointOfCostructuredArrowTerminalsAux (B : D) (A : C) :\n    (G.obj B ⟶ A) ≃ (B ⟶ (⊤_ CostructuredArrow G A).left) where\n  toFun g := CommaMorphism.left (terminal.from (CostructuredArrow.mk g))\n  invFun g := G.map g ≫ (⊤_ CostructuredArrow G A).hom\n  left_inv := by aesop_cat\n  right_inv g := by\n    let B' : CostructuredArrow G A :=\n      CostructuredArrow.mk (G.map g ≫ (⊤_ CostructuredArrow G A).hom)\n    let g' : B' ⟶ ⊤_ CostructuredArrow G A := CostructuredArrow.homMk g rfl\n    have : terminal.from _ = g' := by aesop_cat\n    change CommaMorphism.left (terminal.from B') = _\n    rw [this]\n    rfl\n\n"}
{"name":"CategoryTheory.isLeftAdjoint_of_costructuredArrowTerminals","module":"Mathlib.CategoryTheory.Adjunction.Comma","initialProofState":"C : Type u₁\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nG : CategoryTheory.Functor D C\ninst✝ : ∀ (A : C), CategoryTheory.Limits.HasTerminal (CategoryTheory.CostructuredArrow G A)\n⊢ G.IsLeftAdjoint","decl":"/-- If each costructured arrow category on `G` has a terminal object, `G` is a left adjoint. -/\nlemma isLeftAdjoint_of_costructuredArrowTerminals : G.IsLeftAdjoint where\n  exists_rightAdjoint :=\n    ⟨rightAdjointOfCostructuredArrowTerminals G, ⟨Adjunction.adjunctionOfEquivRight _ _⟩⟩\n\n"}
{"name":"CategoryTheory.isRightAdjoint_iff_hasInitial_structuredArrow","module":"Mathlib.CategoryTheory.Adjunction.Comma","initialProofState":"C : Type u₁\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nG : CategoryTheory.Functor D C\n⊢ Iff G.IsRightAdjoint (∀ (A : C), CategoryTheory.Limits.HasInitial (CategoryTheory.StructuredArrow A G))","decl":"theorem isRightAdjoint_iff_hasInitial_structuredArrow {G : D ⥤ C} :\n    G.IsRightAdjoint ↔ ∀ A, HasInitial (StructuredArrow A G) :=\n  ⟨fun _ A => (mkInitialOfLeftAdjoint _ (Adjunction.ofIsRightAdjoint G) A).hasInitial,\n    fun _ => isRightAdjointOfStructuredArrowInitials _⟩\n\n"}
{"name":"CategoryTheory.isLeftAdjoint_iff_hasTerminal_costructuredArrow","module":"Mathlib.CategoryTheory.Adjunction.Comma","initialProofState":"C : Type u₁\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\n⊢ Iff F.IsLeftAdjoint (∀ (A : D), CategoryTheory.Limits.HasTerminal (CategoryTheory.CostructuredArrow F A))","decl":"theorem isLeftAdjoint_iff_hasTerminal_costructuredArrow {F : C ⥤ D} :\n    F.IsLeftAdjoint ↔ ∀ A, HasTerminal (CostructuredArrow F A) :=\n  ⟨fun _ A => (mkTerminalOfRightAdjoint _ (Adjunction.ofIsLeftAdjoint F) A).hasTerminal,\n    fun _ => isLeftAdjoint_of_costructuredArrowTerminals _⟩\n\n"}
