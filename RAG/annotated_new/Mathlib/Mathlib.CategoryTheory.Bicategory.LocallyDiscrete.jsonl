{"name":"CategoryTheory.LocallyDiscrete.ext","module":"Mathlib.CategoryTheory.Bicategory.LocallyDiscrete","initialProofState":"C : Type u\nx y : CategoryTheory.LocallyDiscrete C\nas : Eq x.as y.as\n‚ä¢ Eq x y","decl":"/-- A wrapper for promoting any category to a bicategory,\nwith the only 2-morphisms being equalities.\n-/\n@[ext]\nstructure LocallyDiscrete (C : Type u) where\n  /-- A wrapper for promoting any category to a bicategory,\n  with the only 2-morphisms being equalities.\n  -/\n  as : C\n\n"}
{"name":"CategoryTheory.LocallyDiscrete.mk.inj","module":"Mathlib.CategoryTheory.Bicategory.LocallyDiscrete","initialProofState":"C : Type u\nas‚úù as : C\nx‚úù : Eq { as := as‚úù } { as := as }\n‚ä¢ Eq as‚úù as","decl":"/-- A wrapper for promoting any category to a bicategory,\nwith the only 2-morphisms being equalities.\n-/\n@[ext]\nstructure LocallyDiscrete (C : Type u) where\n  /-- A wrapper for promoting any category to a bicategory,\n  with the only 2-morphisms being equalities.\n  -/\n  as : C\n\n"}
{"name":"CategoryTheory.LocallyDiscrete.ext_iff","module":"Mathlib.CategoryTheory.Bicategory.LocallyDiscrete","initialProofState":"C : Type u\nx y : CategoryTheory.LocallyDiscrete C\n‚ä¢ Iff (Eq x y) (Eq x.as y.as)","decl":"/-- A wrapper for promoting any category to a bicategory,\nwith the only 2-morphisms being equalities.\n-/\n@[ext]\nstructure LocallyDiscrete (C : Type u) where\n  /-- A wrapper for promoting any category to a bicategory,\n  with the only 2-morphisms being equalities.\n  -/\n  as : C\n\n"}
{"name":"CategoryTheory.LocallyDiscrete.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Bicategory.LocallyDiscrete","initialProofState":"C : Type u\ninst‚úù : SizeOf C\nas : C\n‚ä¢ Eq (SizeOf.sizeOf { as := as }) (HAdd.hAdd 1 (SizeOf.sizeOf as))","decl":"/-- A wrapper for promoting any category to a bicategory,\nwith the only 2-morphisms being equalities.\n-/\n@[ext]\nstructure LocallyDiscrete (C : Type u) where\n  /-- A wrapper for promoting any category to a bicategory,\n  with the only 2-morphisms being equalities.\n  -/\n  as : C\n\n"}
{"name":"CategoryTheory.LocallyDiscrete.mk.injEq","module":"Mathlib.CategoryTheory.Bicategory.LocallyDiscrete","initialProofState":"C : Type u\nas‚úù as : C\n‚ä¢ Eq (Eq { as := as‚úù } { as := as }) (Eq as‚úù as)","decl":"/-- A wrapper for promoting any category to a bicategory,\nwith the only 2-morphisms being equalities.\n-/\n@[ext]\nstructure LocallyDiscrete (C : Type u) where\n  /-- A wrapper for promoting any category to a bicategory,\n  with the only 2-morphisms being equalities.\n  -/\n  as : C\n\n"}
{"name":"CategoryTheory.LocallyDiscrete.mk_as","module":"Mathlib.CategoryTheory.Bicategory.LocallyDiscrete","initialProofState":"C : Type u\na : CategoryTheory.LocallyDiscrete C\n‚ä¢ Eq { as := a.as } a","decl":"@[simp]\ntheorem mk_as (a : LocallyDiscrete C) : mk a.as = a := rfl\n\n"}
{"name":"CategoryTheory.LocallyDiscrete.locallyDiscreteEquiv_apply","module":"Mathlib.CategoryTheory.Bicategory.LocallyDiscrete","initialProofState":"C : Type u\nself : CategoryTheory.LocallyDiscrete C\n‚ä¢ Eq (CategoryTheory.LocallyDiscrete.locallyDiscreteEquiv self) self.as","decl":"/-- `LocallyDiscrete C` is equivalent to the original type `C`. -/\n@[simps]\ndef locallyDiscreteEquiv : LocallyDiscrete C ‚âÉ C where\n  toFun := LocallyDiscrete.as\n  invFun := LocallyDiscrete.mk\n  left_inv := by aesop_cat\n  right_inv := by aesop_cat\n\n"}
{"name":"CategoryTheory.LocallyDiscrete.locallyDiscreteEquiv_symm_apply_as","module":"Mathlib.CategoryTheory.Bicategory.LocallyDiscrete","initialProofState":"C : Type u\nas : C\n‚ä¢ Eq (CategoryTheory.LocallyDiscrete.locallyDiscreteEquiv.symm as).as as","decl":"/-- `LocallyDiscrete C` is equivalent to the original type `C`. -/\n@[simps]\ndef locallyDiscreteEquiv : LocallyDiscrete C ‚âÉ C where\n  toFun := LocallyDiscrete.as\n  invFun := LocallyDiscrete.mk\n  left_inv := by aesop_cat\n  right_inv := by aesop_cat\n\n"}
{"name":"CategoryTheory.LocallyDiscrete.id_as","module":"Mathlib.CategoryTheory.Bicategory.LocallyDiscrete","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.CategoryStruct.{v, u} C\na : CategoryTheory.LocallyDiscrete C\n‚ä¢ Eq (CategoryTheory.CategoryStruct.id a).as (CategoryTheory.CategoryStruct.id a.as)","decl":"@[simp]\nlemma id_as (a : LocallyDiscrete C) : (ùüô a : Discrete (a.as ‚ü∂ a.as)).as = ùüô a.as :=\n  rfl\n\n"}
{"name":"CategoryTheory.LocallyDiscrete.comp_as","module":"Mathlib.CategoryTheory.Bicategory.LocallyDiscrete","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.CategoryStruct.{v, u} C\na b c : CategoryTheory.LocallyDiscrete C\nf : Quiver.Hom a b\ng : Quiver.Hom b c\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp f g).as (CategoryTheory.CategoryStruct.comp f.as g.as)","decl":"@[simp]\nlemma comp_as {a b c : LocallyDiscrete C} (f : a ‚ü∂ b) (g : b ‚ü∂ c) : (f ‚â´ g).as = f.as ‚â´ g.as :=\n  rfl\n\n"}
{"name":"CategoryTheory.LocallyDiscrete.subsingleton2Hom","module":"Mathlib.CategoryTheory.Bicategory.LocallyDiscrete","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.CategoryStruct.{v, u} C\na b : CategoryTheory.LocallyDiscrete C\nf g : Quiver.Hom a b\n‚ä¢ Subsingleton (Quiver.Hom f g)","decl":"instance subsingleton2Hom {a b : LocallyDiscrete C} (f g : a ‚ü∂ b) : Subsingleton (f ‚ü∂ g) :=\n  instSubsingletonDiscreteHom f g\n\n"}
{"name":"CategoryTheory.LocallyDiscrete.eq_of_hom","module":"Mathlib.CategoryTheory.Bicategory.LocallyDiscrete","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.CategoryStruct.{v, u} C\nX Y : CategoryTheory.LocallyDiscrete C\nf g : Quiver.Hom X Y\nŒ∑ : Quiver.Hom f g\n‚ä¢ Eq f g","decl":"/-- Extract the equation from a 2-morphism in a locally discrete 2-category. -/\ntheorem eq_of_hom {X Y : LocallyDiscrete C} {f g : X ‚ü∂ Y} (Œ∑ : f ‚ü∂ g) : f = g :=\n  Discrete.ext Œ∑.1.1\n\n"}
{"name":"CategoryTheory.locallyDiscreteBicategory.strict","module":"Mathlib.CategoryTheory.Bicategory.LocallyDiscrete","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\n‚ä¢ CategoryTheory.Bicategory.Strict (CategoryTheory.LocallyDiscrete C)","decl":"/-- A locally discrete bicategory is strict. -/\ninstance locallyDiscreteBicategory.strict : Strict (LocallyDiscrete C) where\n  id_comp _ := Discrete.ext (Category.id_comp _)\n  comp_id _ := Discrete.ext (Category.comp_id _)\n  assoc _ _ _ := Discrete.ext (Category.assoc _ _ _)\n\n"}
{"name":"CategoryTheory.PrelaxFunctor.map‚ÇÇ_eqToHom","module":"Mathlib.CategoryTheory.Bicategory.LocallyDiscrete","initialProofState":"B : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Bicategory B\nC : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Bicategory C\nF : CategoryTheory.PrelaxFunctor B C\na b : B\nf g : Quiver.Hom a b\nh : Eq f g\n‚ä¢ Eq (F.map‚ÇÇ (CategoryTheory.eqToHom h)) (CategoryTheory.eqToHom ‚ãØ)","decl":"@[simp]\nlemma PrelaxFunctor.map‚ÇÇ_eqToHom (F : PrelaxFunctor B C) {a b : B} {f g : a ‚ü∂ b} (h : f = g) :\n    F.map‚ÇÇ (eqToHom h) = eqToHom (F.congr_map h) := by\n  subst h; simp only [eqToHom_refl, PrelaxFunctor.map‚ÇÇ_id]\n\n"}
{"name":"CategoryTheory.Bicategory.instIsLocallyDiscreteLocallyDiscrete","module":"Mathlib.CategoryTheory.Bicategory.LocallyDiscrete","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\n‚ä¢ CategoryTheory.Bicategory.IsLocallyDiscrete (CategoryTheory.LocallyDiscrete C)","decl":"instance (C : Type*) [Category C] : IsLocallyDiscrete (LocallyDiscrete C) :=\n  fun _ _ ‚Ü¶ Discrete.isDiscrete _\n\n"}
{"name":"CategoryTheory.Bicategory.instStrictOfIsLocallyDiscrete","module":"Mathlib.CategoryTheory.Bicategory.LocallyDiscrete","initialProofState":"B : Type u_1\ninst‚úù¬π : CategoryTheory.Bicategory B\ninst‚úù : CategoryTheory.Bicategory.IsLocallyDiscrete B\n‚ä¢ CategoryTheory.Bicategory.Strict B","decl":"instance (B : Type*) [Bicategory B] [IsLocallyDiscrete B] : Strict B where\n  id_comp f := obj_ext_of_isDiscrete (leftUnitor f).hom\n  comp_id f := obj_ext_of_isDiscrete (rightUnitor f).hom\n  assoc f g h := obj_ext_of_isDiscrete (associator f g h).hom\n\n"}
{"name":"Quiver.Hom.toLoc_as","module":"Mathlib.CategoryTheory.Bicategory.LocallyDiscrete","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.CategoryStruct.{v, u} C\na b : C\nf : Quiver.Hom a b\n‚ä¢ Eq f.toLoc.as f","decl":"/-- The 1-morphism in `LocallyDiscrete C` associated to a given morphism `f : a ‚ü∂ b` in `C` -/\n@[simps]\ndef toLoc {a b : C} (f : a ‚ü∂ b) : LocallyDiscrete.mk a ‚ü∂ LocallyDiscrete.mk b :=\n  ‚ü®f‚ü©\n\n"}
{"name":"Quiver.Hom.id_toLoc","module":"Mathlib.CategoryTheory.Bicategory.LocallyDiscrete","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.CategoryStruct.{v, u} C\na : C\n‚ä¢ Eq (CategoryTheory.CategoryStruct.id a).toLoc (CategoryTheory.CategoryStruct.id { as := a })","decl":"@[simp]\nlemma id_toLoc (a : C) : (ùüô a).toLoc = ùüô (LocallyDiscrete.mk a) :=\n  rfl\n\n"}
{"name":"Quiver.Hom.comp_toLoc","module":"Mathlib.CategoryTheory.Bicategory.LocallyDiscrete","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.CategoryStruct.{v, u} C\na b c : C\nf : Quiver.Hom a b\ng : Quiver.Hom b c\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp f g).toLoc (CategoryTheory.CategoryStruct.comp f.toLoc g.toLoc)","decl":"@[simp]\nlemma comp_toLoc {a b c : C} (f : a ‚ü∂ b) (g : b ‚ü∂ c) : (f ‚â´ g).toLoc = f.toLoc ‚â´ g.toLoc :=\n  rfl\n\n"}
{"name":"CategoryTheory.LocallyDiscrete.eqToHom_toLoc","module":"Mathlib.CategoryTheory.Bicategory.LocallyDiscrete","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\na b : C\nh : Eq a b\n‚ä¢ Eq (CategoryTheory.eqToHom h).toLoc (CategoryTheory.eqToHom ‚ãØ)","decl":"@[simp]\nlemma CategoryTheory.LocallyDiscrete.eqToHom_toLoc {C : Type u} [Category.{v} C] {a b : C}\n    (h : a = b) : (eqToHom h).toLoc = eqToHom (congrArg LocallyDiscrete.mk h) := by\n  subst h; rfl\n\n"}
