{"name":"IncidenceAlgebra.eq_zero_of_not_le'","module":"Mathlib.Combinatorics.Enumerative.IncidenceAlgebra","initialProofState":"ğ•œ : Type u_7\nÎ± : Type u_8\ninstâœÂ¹ : Zero ğ•œ\ninstâœ : LE Î±\nself : IncidenceAlgebra ğ•œ Î±\na b : Î±\naâœ : Not (LE.le a b)\nâŠ¢ Eq (self.toFun a b) 0","decl":"/-- The `ğ•œ`-incidence algebra over `Î±`. -/\nstructure IncidenceAlgebra (ğ•œ Î± : Type*) [Zero ğ•œ] [LE Î±] where\n  /-- The underlying function of an element of the incidence algebra.\n\n  Do not use this function directly. Instead use the coercion coming from the `FunLike`\n  instance. -/\n  toFun : Î± â†’ Î± â†’ ğ•œ\n  eq_zero_of_not_le' â¦ƒa b : Î±â¦„ : Â¬a â‰¤ b â†’ toFun a b = 0\n\n"}
{"name":"IncidenceAlgebra.mk.inj","module":"Mathlib.Combinatorics.Enumerative.IncidenceAlgebra","initialProofState":"ğ•œ : Type u_7\nÎ± : Type u_8\ninstâœÂ¹ : Zero ğ•œ\ninstâœ : LE Î±\ntoFunâœ : Î± â†’ Î± â†’ ğ•œ\neq_zero_of_not_le'âœ : âˆ€ â¦ƒa b : Î±â¦„, Not (LE.le a b) â†’ Eq (toFunâœ a b) 0\ntoFun : Î± â†’ Î± â†’ ğ•œ\neq_zero_of_not_le' : âˆ€ â¦ƒa b : Î±â¦„, Not (LE.le a b) â†’ Eq (toFun a b) 0\nxâœ : Eq { toFun := toFunâœ, eq_zero_of_not_le' := eq_zero_of_not_le'âœ } { toFun := toFun, eq_zero_of_not_le' := eq_zero_of_not_le' }\nâŠ¢ Eq toFunâœ toFun","decl":"/-- The `ğ•œ`-incidence algebra over `Î±`. -/\nstructure IncidenceAlgebra (ğ•œ Î± : Type*) [Zero ğ•œ] [LE Î±] where\n  /-- The underlying function of an element of the incidence algebra.\n\n  Do not use this function directly. Instead use the coercion coming from the `FunLike`\n  instance. -/\n  toFun : Î± â†’ Î± â†’ ğ•œ\n  eq_zero_of_not_le' â¦ƒa b : Î±â¦„ : Â¬a â‰¤ b â†’ toFun a b = 0\n\n"}
{"name":"IncidenceAlgebra.mk.sizeOf_spec","module":"Mathlib.Combinatorics.Enumerative.IncidenceAlgebra","initialProofState":"ğ•œ : Type u_7\nÎ± : Type u_8\ninstâœÂ³ : Zero ğ•œ\ninstâœÂ² : LE Î±\ninstâœÂ¹ : SizeOf ğ•œ\ninstâœ : SizeOf Î±\ntoFun : Î± â†’ Î± â†’ ğ•œ\neq_zero_of_not_le' : âˆ€ â¦ƒa b : Î±â¦„, Not (LE.le a b) â†’ Eq (toFun a b) 0\nâŠ¢ Eq (SizeOf.sizeOf { toFun := toFun, eq_zero_of_not_le' := eq_zero_of_not_le' }) 1","decl":"/-- The `ğ•œ`-incidence algebra over `Î±`. -/\nstructure IncidenceAlgebra (ğ•œ Î± : Type*) [Zero ğ•œ] [LE Î±] where\n  /-- The underlying function of an element of the incidence algebra.\n\n  Do not use this function directly. Instead use the coercion coming from the `FunLike`\n  instance. -/\n  toFun : Î± â†’ Î± â†’ ğ•œ\n  eq_zero_of_not_le' â¦ƒa b : Î±â¦„ : Â¬a â‰¤ b â†’ toFun a b = 0\n\n"}
{"name":"IncidenceAlgebra.mk.injEq","module":"Mathlib.Combinatorics.Enumerative.IncidenceAlgebra","initialProofState":"ğ•œ : Type u_7\nÎ± : Type u_8\ninstâœÂ¹ : Zero ğ•œ\ninstâœ : LE Î±\ntoFunâœ : Î± â†’ Î± â†’ ğ•œ\neq_zero_of_not_le'âœ : âˆ€ â¦ƒa b : Î±â¦„, Not (LE.le a b) â†’ Eq (toFunâœ a b) 0\ntoFun : Î± â†’ Î± â†’ ğ•œ\neq_zero_of_not_le' : âˆ€ â¦ƒa b : Î±â¦„, Not (LE.le a b) â†’ Eq (toFun a b) 0\nâŠ¢ Eq (Eq { toFun := toFunâœ, eq_zero_of_not_le' := eq_zero_of_not_le'âœ } { toFun := toFun, eq_zero_of_not_le' := eq_zero_of_not_le' }) (Eq toFunâœ toFun)","decl":"/-- The `ğ•œ`-incidence algebra over `Î±`. -/\nstructure IncidenceAlgebra (ğ•œ Î± : Type*) [Zero ğ•œ] [LE Î±] where\n  /-- The underlying function of an element of the incidence algebra.\n\n  Do not use this function directly. Instead use the coercion coming from the `FunLike`\n  instance. -/\n  toFun : Î± â†’ Î± â†’ ğ•œ\n  eq_zero_of_not_le' â¦ƒa b : Î±â¦„ : Â¬a â‰¤ b â†’ toFun a b = 0\n\n"}
{"name":"IncidenceAlgebra.apply_eq_zero_of_not_le","module":"Mathlib.Combinatorics.Enumerative.IncidenceAlgebra","initialProofState":"ğ•œ : Type u_2\nÎ± : Type u_5\ninstâœÂ¹ : Zero ğ•œ\ninstâœ : LE Î±\na b : Î±\nh : Not (LE.le a b)\nf : IncidenceAlgebra ğ•œ Î±\nâŠ¢ Eq (f a b) 0","decl":"lemma apply_eq_zero_of_not_le (h : Â¬a â‰¤ b) (f : IncidenceAlgebra ğ•œ Î±) : f a b = 0 :=\n  eq_zero_of_not_le' _ h\n\n"}
{"name":"IncidenceAlgebra.le_of_ne_zero","module":"Mathlib.Combinatorics.Enumerative.IncidenceAlgebra","initialProofState":"ğ•œ : Type u_2\nÎ± : Type u_5\ninstâœÂ¹ : Zero ğ•œ\ninstâœ : LE Î±\na b : Î±\nf : IncidenceAlgebra ğ•œ Î±\naâœ : Ne (f a b) 0\nâŠ¢ LE.le a b","decl":"lemma le_of_ne_zero {f : IncidenceAlgebra ğ•œ Î±} : f a b â‰  0 â†’ a â‰¤ b :=\n  not_imp_comm.1 fun h â†¦ apply_eq_zero_of_not_le h _\n\n"}
{"name":"IncidenceAlgebra.toFun_eq_coe","module":"Mathlib.Combinatorics.Enumerative.IncidenceAlgebra","initialProofState":"ğ•œ : Type u_2\nÎ± : Type u_5\ninstâœÂ¹ : Zero ğ•œ\ninstâœ : LE Î±\nf : IncidenceAlgebra ğ•œ Î±\nâŠ¢ Eq f.toFun â‡‘f","decl":"@[simp] lemma toFun_eq_coe (f : IncidenceAlgebra ğ•œ Î±) : f.toFun = f := rfl\n"}
{"name":"IncidenceAlgebra.coe_mk","module":"Mathlib.Combinatorics.Enumerative.IncidenceAlgebra","initialProofState":"ğ•œ : Type u_2\nÎ± : Type u_5\ninstâœÂ¹ : Zero ğ•œ\ninstâœ : LE Î±\nf : Î± â†’ Î± â†’ ğ•œ\nh : âˆ€ â¦ƒa b : Î±â¦„, Not (LE.le a b) â†’ Eq (f a b) 0\nâŠ¢ Eq (â‡‘{ toFun := f, eq_zero_of_not_le' := h }) f","decl":"@[simp, norm_cast] lemma coe_mk (f : Î± â†’ Î± â†’ ğ•œ) (h) : (mk f h : Î± â†’ Î± â†’ ğ•œ) = f := rfl\n\n"}
{"name":"IncidenceAlgebra.coe_inj","module":"Mathlib.Combinatorics.Enumerative.IncidenceAlgebra","initialProofState":"ğ•œ : Type u_2\nÎ± : Type u_5\ninstâœÂ¹ : Zero ğ•œ\ninstâœ : LE Î±\nf g : IncidenceAlgebra ğ•œ Î±\nâŠ¢ Iff (Eq â‡‘f â‡‘g) (Eq f g)","decl":"lemma coe_inj {f g : IncidenceAlgebra ğ•œ Î±} : (f : Î± â†’ Î± â†’ ğ•œ) = g â†” f = g :=\n  DFunLike.coe_injective.eq_iff\n\n"}
{"name":"IncidenceAlgebra.ext","module":"Mathlib.Combinatorics.Enumerative.IncidenceAlgebra","initialProofState":"ğ•œ : Type u_2\nÎ± : Type u_5\ninstâœÂ¹ : Zero ğ•œ\ninstâœ : LE Î±\nf g : IncidenceAlgebra ğ•œ Î±\nh : âˆ€ (a b : Î±), LE.le a b â†’ Eq (f a b) (g a b)\nâŠ¢ Eq f g","decl":"@[ext]\nlemma ext â¦ƒf g : IncidenceAlgebra ğ•œ Î±â¦„ (h : âˆ€ a b, a â‰¤ b â†’ f a b = g a b) : f = g := by\n  refine DFunLike.coe_injective' (funextâ‚‚ fun a b â†¦ ?_)\n  by_cases hab : a â‰¤ b\n  Â· exact h _ _ hab\n  Â· rw [apply_eq_zero_of_not_le hab, apply_eq_zero_of_not_le hab]\n\n"}
{"name":"IncidenceAlgebra.ext_iff","module":"Mathlib.Combinatorics.Enumerative.IncidenceAlgebra","initialProofState":"ğ•œ : Type u_2\nÎ± : Type u_5\ninstâœÂ¹ : Zero ğ•œ\ninstâœ : LE Î±\nf g : IncidenceAlgebra ğ•œ Î±\nâŠ¢ Iff (Eq f g) (âˆ€ (a b : Î±), LE.le a b â†’ Eq (f a b) (g a b))","decl":"@[ext]\nlemma ext â¦ƒf g : IncidenceAlgebra ğ•œ Î±â¦„ (h : âˆ€ a b, a â‰¤ b â†’ f a b = g a b) : f = g := by\n  refine DFunLike.coe_injective' (funextâ‚‚ fun a b â†¦ ?_)\n  by_cases hab : a â‰¤ b\n  Â· exact h _ _ hab\n  Â· rw [apply_eq_zero_of_not_le hab, apply_eq_zero_of_not_le hab]\n\n"}
{"name":"IncidenceAlgebra.mk_coe","module":"Mathlib.Combinatorics.Enumerative.IncidenceAlgebra","initialProofState":"ğ•œ : Type u_2\nÎ± : Type u_5\ninstâœÂ¹ : Zero ğ•œ\ninstâœ : LE Î±\nf : IncidenceAlgebra ğ•œ Î±\nh : âˆ€ â¦ƒa b : Î±â¦„, Not (LE.le a b) â†’ Eq (f a b) 0\nâŠ¢ Eq { toFun := â‡‘f, eq_zero_of_not_le' := h } f","decl":"@[simp] lemma mk_coe (f : IncidenceAlgebra ğ•œ Î±) (h) : mk f h = f := rfl\n\n"}
{"name":"IncidenceAlgebra.coe_zero","module":"Mathlib.Combinatorics.Enumerative.IncidenceAlgebra","initialProofState":"ğ•œ : Type u_2\nÎ± : Type u_5\ninstâœÂ¹ : Zero ğ•œ\ninstâœ : LE Î±\nâŠ¢ Eq (â‡‘0) 0","decl":"@[simp, norm_cast] lemma coe_zero : â‡‘(0 : IncidenceAlgebra ğ•œ Î±) = 0 := rfl\n"}
{"name":"IncidenceAlgebra.zero_apply","module":"Mathlib.Combinatorics.Enumerative.IncidenceAlgebra","initialProofState":"ğ•œ : Type u_2\nÎ± : Type u_5\ninstâœÂ¹ : Zero ğ•œ\ninstâœ : LE Î±\na b : Î±\nâŠ¢ Eq (0 a b) 0","decl":"lemma zero_apply (a b : Î±) : (0 : IncidenceAlgebra ğ•œ Î±) a b = 0 := rfl\n\n"}
{"name":"IncidenceAlgebra.coe_add","module":"Mathlib.Combinatorics.Enumerative.IncidenceAlgebra","initialProofState":"ğ•œ : Type u_2\nÎ± : Type u_5\ninstâœÂ¹ : AddZeroClass ğ•œ\ninstâœ : LE Î±\nf g : IncidenceAlgebra ğ•œ Î±\nâŠ¢ Eq (â‡‘(HAdd.hAdd f g)) (HAdd.hAdd â‡‘f â‡‘g)","decl":"@[simp, norm_cast] lemma coe_add (f g : IncidenceAlgebra ğ•œ Î±) : â‡‘(f + g) = f + g := rfl\n"}
{"name":"IncidenceAlgebra.add_apply","module":"Mathlib.Combinatorics.Enumerative.IncidenceAlgebra","initialProofState":"ğ•œ : Type u_2\nÎ± : Type u_5\ninstâœÂ¹ : AddZeroClass ğ•œ\ninstâœ : LE Î±\nf g : IncidenceAlgebra ğ•œ Î±\na b : Î±\nâŠ¢ Eq ((HAdd.hAdd f g) a b) (HAdd.hAdd (f a b) (g a b))","decl":"lemma add_apply (f g : IncidenceAlgebra ğ•œ Î±) (a b : Î±) : (f + g) a b = f a b + g a b := rfl\n\n"}
{"name":"IncidenceAlgebra.coe_constSMul","module":"Mathlib.Combinatorics.Enumerative.IncidenceAlgebra","initialProofState":"ğ•œ : Type u_2\nÎ± : Type u_5\nM : Type u_7\ninstâœÂ² : Zero ğ•œ\ninstâœÂ¹ : LE Î±\ninstâœ : SMulZeroClass M ğ•œ\nc : M\nf : IncidenceAlgebra ğ•œ Î±\nâŠ¢ Eq (â‡‘(HSMul.hSMul c f)) (HSMul.hSMul c â‡‘f)","decl":"@[simp, norm_cast] lemma coe_constSMul (c : M) (f : IncidenceAlgebra ğ•œ Î±) : â‡‘(c â€¢ f) = c â€¢ â‡‘f := rfl\n\n"}
{"name":"IncidenceAlgebra.constSMul_apply","module":"Mathlib.Combinatorics.Enumerative.IncidenceAlgebra","initialProofState":"ğ•œ : Type u_2\nÎ± : Type u_5\nM : Type u_7\ninstâœÂ² : Zero ğ•œ\ninstâœÂ¹ : LE Î±\ninstâœ : SMulZeroClass M ğ•œ\nc : M\nf : IncidenceAlgebra ğ•œ Î±\na b : Î±\nâŠ¢ Eq ((HSMul.hSMul c f) a b) (HSMul.hSMul c (f a b))","decl":"lemma constSMul_apply (c : M) (f : IncidenceAlgebra ğ•œ Î±) (a b : Î±) : (c â€¢ f) a b = c â€¢ f a b := rfl\n\n"}
{"name":"IncidenceAlgebra.coe_neg","module":"Mathlib.Combinatorics.Enumerative.IncidenceAlgebra","initialProofState":"ğ•œ : Type u_2\nÎ± : Type u_5\ninstâœÂ¹ : AddGroup ğ•œ\ninstâœ : LE Î±\nf : IncidenceAlgebra ğ•œ Î±\nâŠ¢ Eq (â‡‘(Neg.neg f)) (Neg.neg â‡‘f)","decl":"@[simp, norm_cast] lemma coe_neg (f : IncidenceAlgebra ğ•œ Î±) : â‡‘(-f) = -f := rfl\n"}
{"name":"IncidenceAlgebra.coe_sub","module":"Mathlib.Combinatorics.Enumerative.IncidenceAlgebra","initialProofState":"ğ•œ : Type u_2\nÎ± : Type u_5\ninstâœÂ¹ : AddGroup ğ•œ\ninstâœ : LE Î±\nf g : IncidenceAlgebra ğ•œ Î±\nâŠ¢ Eq (â‡‘(HSub.hSub f g)) (HSub.hSub â‡‘f â‡‘g)","decl":"@[simp, norm_cast] lemma coe_sub (f g : IncidenceAlgebra ğ•œ Î±) : â‡‘(f - g) = f - g := rfl\n"}
{"name":"IncidenceAlgebra.neg_apply","module":"Mathlib.Combinatorics.Enumerative.IncidenceAlgebra","initialProofState":"ğ•œ : Type u_2\nÎ± : Type u_5\ninstâœÂ¹ : AddGroup ğ•œ\ninstâœ : LE Î±\nf : IncidenceAlgebra ğ•œ Î±\na b : Î±\nâŠ¢ Eq ((Neg.neg f) a b) (Neg.neg (f a b))","decl":"lemma neg_apply (f : IncidenceAlgebra ğ•œ Î±) (a b : Î±) : (-f) a b = -f a b := rfl\n"}
{"name":"IncidenceAlgebra.sub_apply","module":"Mathlib.Combinatorics.Enumerative.IncidenceAlgebra","initialProofState":"ğ•œ : Type u_2\nÎ± : Type u_5\ninstâœÂ¹ : AddGroup ğ•œ\ninstâœ : LE Î±\nf g : IncidenceAlgebra ğ•œ Î±\na b : Î±\nâŠ¢ Eq ((HSub.hSub f g) a b) (HSub.hSub (f a b) (g a b))","decl":"lemma sub_apply (f g : IncidenceAlgebra ğ•œ Î±) (a b : Î±) : (f - g) a b = f a b - g a b := rfl\n\n"}
{"name":"IncidenceAlgebra.one_apply","module":"Mathlib.Combinatorics.Enumerative.IncidenceAlgebra","initialProofState":"ğ•œ : Type u_2\nÎ± : Type u_5\ninstâœÂ³ : Preorder Î±\ninstâœÂ² : DecidableEq Î±\ninstâœÂ¹ : Zero ğ•œ\ninstâœ : One ğ•œ\na b : Î±\nâŠ¢ Eq (1 a b) (ite (Eq a b) 1 0)","decl":"@[simp] lemma one_apply (a b : Î±) : (1 : IncidenceAlgebra ğ•œ Î±) a b = if a = b then 1 else 0 := rfl\n\n"}
{"name":"IncidenceAlgebra.mul_apply","module":"Mathlib.Combinatorics.Enumerative.IncidenceAlgebra","initialProofState":"ğ•œ : Type u_2\nÎ± : Type u_5\ninstâœÂ³ : Preorder Î±\ninstâœÂ² : LocallyFiniteOrder Î±\ninstâœÂ¹ : AddCommMonoid ğ•œ\ninstâœ : Mul ğ•œ\nf g : IncidenceAlgebra ğ•œ Î±\na b : Î±\nâŠ¢ Eq ((HMul.hMul f g) a b) ((Finset.Icc a b).sum fun x => HMul.hMul (f a x) (g x b))","decl":"@[simp] lemma mul_apply (f g : IncidenceAlgebra ğ•œ Î±) (a b : Î±) :\n    (f * g) a b = âˆ‘ x âˆˆ Icc a b, f a x * g x b := rfl\n\n"}
{"name":"IncidenceAlgebra.smul_apply","module":"Mathlib.Combinatorics.Enumerative.IncidenceAlgebra","initialProofState":"ğ•œ : Type u_2\nğ• : Type u_3\nÎ± : Type u_5\ninstâœâ´ : Preorder Î±\ninstâœÂ³ : LocallyFiniteOrder Î±\ninstâœÂ² : AddCommMonoid ğ•œ\ninstâœÂ¹ : AddCommMonoid ğ•\ninstâœ : SMul ğ•œ ğ•\nf : IncidenceAlgebra ğ•œ Î±\ng : IncidenceAlgebra ğ• Î±\na b : Î±\nâŠ¢ Eq ((HSMul.hSMul f g) a b) ((Finset.Icc a b).sum fun x => HSMul.hSMul (f a x) (g x b))","decl":"@[simp]\nlemma smul_apply (f : IncidenceAlgebra ğ•œ Î±) (g : IncidenceAlgebra ğ• Î±) (a b : Î±) :\n    (f â€¢ g) a b = âˆ‘ x âˆˆ Icc a b, f a x â€¢ g x b :=\n  rfl\n\n"}
{"name":"IncidenceAlgebra.instIsScalarTower","module":"Mathlib.Combinatorics.Enumerative.IncidenceAlgebra","initialProofState":"ğ•œ : Type u_2\nğ• : Type u_3\nğ• : Type u_4\nÎ± : Type u_5\ninstâœâ¹ : Preorder Î±\ninstâœâ¸ : LocallyFiniteOrder Î±\ninstâœâ· : AddCommMonoid ğ•œ\ninstâœâ¶ : Monoid ğ•œ\ninstâœâµ : Semiring ğ•\ninstâœâ´ : AddCommMonoid ğ•\ninstâœÂ³ : SMul ğ•œ ğ•\ninstâœÂ² : Module ğ• ğ•\ninstâœÂ¹ : DistribMulAction ğ•œ ğ•\ninstâœ : IsScalarTower ğ•œ ğ• ğ•\nâŠ¢ IsScalarTower (IncidenceAlgebra ğ•œ Î±) (IncidenceAlgebra ğ• Î±) (IncidenceAlgebra ğ• Î±)","decl":"instance instIsScalarTower [Preorder Î±] [LocallyFiniteOrder Î±] [AddCommMonoid ğ•œ] [Monoid ğ•œ]\n    [Semiring ğ•] [AddCommMonoid ğ•] [SMul ğ•œ ğ•] [Module ğ• ğ•] [DistribMulAction ğ•œ ğ•]\n    [IsScalarTower ğ•œ ğ• ğ•] :\n    IsScalarTower (IncidenceAlgebra ğ•œ Î±) (IncidenceAlgebra ğ• Î±) (IncidenceAlgebra ğ• Î±) where\n  smul_assoc f g h := by\n    ext a b\n    simp only [smul_apply, sum_smul, smul_sum, sum_sigma']\n    apply sum_nbij' (fun âŸ¨a, bâŸ© â†¦ âŸ¨b, aâŸ©) (fun âŸ¨a, bâŸ© â†¦ âŸ¨b, aâŸ©) <;> aesop (add unsafe le_trans)\n\n"}
{"name":"IncidenceAlgebra.lambda_apply","module":"Mathlib.Combinatorics.Enumerative.IncidenceAlgebra","initialProofState":"ğ•œ : Type u_2\nÎ± : Type u_5\ninstâœÂ³ : Zero ğ•œ\ninstâœÂ² : One ğ•œ\ninstâœÂ¹ : Preorder Î±\ninstâœ : DecidableRel fun x1 x2 => WCovBy x1 x2\na b : Î±\nâŠ¢ Eq ((IncidenceAlgebra.lambda ğ•œ) a b) (ite (WCovBy a b) 1 0)","decl":"/-- The lambda function of the incidence algebra is the function that assigns `1` to every nonempty\ninterval of cardinality one or two. -/\n@[simps]\ndef lambda : IncidenceAlgebra ğ•œ Î± :=\n  âŸ¨fun a b â†¦ if a â©¿ b then 1 else 0, fun _a _b h â†¦ if_neg fun hh â†¦ h hh.leâŸ©\n\n"}
{"name":"IncidenceAlgebra.zeta_apply","module":"Mathlib.Combinatorics.Enumerative.IncidenceAlgebra","initialProofState":"ğ•œ : Type u_2\nÎ± : Type u_5\ninstâœÂ³ : Zero ğ•œ\ninstâœÂ² : One ğ•œ\ninstâœÂ¹ : LE Î±\ninstâœ : DecidableRel fun x1 x2 => LE.le x1 x2\na b : Î±\nâŠ¢ Eq ((IncidenceAlgebra.zeta ğ•œ) a b) (ite (LE.le a b) 1 0)","decl":"@[simp] lemma zeta_apply (a b : Î±) : zeta ğ•œ a b = if a â‰¤ b then 1 else 0 := rfl\n\n"}
{"name":"IncidenceAlgebra.zeta_of_le","module":"Mathlib.Combinatorics.Enumerative.IncidenceAlgebra","initialProofState":"ğ•œ : Type u_2\nÎ± : Type u_5\ninstâœÂ³ : Zero ğ•œ\ninstâœÂ² : One ğ•œ\ninstâœÂ¹ : LE Î±\ninstâœ : DecidableRel fun x1 x2 => LE.le x1 x2\na b : Î±\nh : LE.le a b\nâŠ¢ Eq ((IncidenceAlgebra.zeta ğ•œ) a b) 1","decl":"lemma zeta_of_le (h : a â‰¤ b) : zeta ğ•œ a b = 1 := if_pos h\n\n"}
{"name":"IncidenceAlgebra.zeta_mul_zeta","module":"Mathlib.Combinatorics.Enumerative.IncidenceAlgebra","initialProofState":"ğ•œ : Type u_2\nÎ± : Type u_5\ninstâœÂ³ : Semiring ğ•œ\ninstâœÂ² : Preorder Î±\ninstâœÂ¹ : LocallyFiniteOrder Î±\ninstâœ : DecidableRel fun x1 x2 => LE.le x1 x2\na b : Î±\nâŠ¢ Eq ((HMul.hMul (IncidenceAlgebra.zeta ğ•œ) (IncidenceAlgebra.zeta ğ•œ)) a b) â†‘(Finset.Icc a b).card","decl":"lemma zeta_mul_zeta [Semiring ğ•œ] [Preorder Î±] [LocallyFiniteOrder Î±] [DecidableRel (Î± := Î±) (Â· â‰¤ Â·)]\n    (a b : Î±) : (zeta ğ•œ * zeta ğ•œ : IncidenceAlgebra ğ•œ Î±) a b = (Icc a b).card := by\n  rw [mul_apply, card_eq_sum_ones, Nat.cast_sum, Nat.cast_one]\n  refine sum_congr rfl fun x hx â†¦ ?_\n  rw [mem_Icc] at hx\n  rw [zeta_of_le hx.1, zeta_of_le hx.2, one_mul]\n\n"}
{"name":"IncidenceAlgebra.zeta_mul_kappa","module":"Mathlib.Combinatorics.Enumerative.IncidenceAlgebra","initialProofState":"ğ•œ : Type u_2\nÎ± : Type u_5\ninstâœÂ³ : Semiring ğ•œ\ninstâœÂ² : Preorder Î±\ninstâœÂ¹ : LocallyFiniteOrder Î±\ninstâœ : DecidableRel fun x1 x2 => LE.le x1 x2\na b : Î±\nâŠ¢ Eq ((HMul.hMul (IncidenceAlgebra.zeta ğ•œ) (IncidenceAlgebra.zeta ğ•œ)) a b) â†‘(Finset.Icc a b).card","decl":"lemma zeta_mul_kappa [Semiring ğ•œ] [Preorder Î±] [LocallyFiniteOrder Î±]\n    [DecidableRel (Î± := Î±) (Â· â‰¤ Â·)] (a b : Î±) :\n    (zeta ğ•œ * zeta ğ•œ : IncidenceAlgebra ğ•œ Î±) a b = (Icc a b).card := by\n  rw [mul_apply, card_eq_sum_ones, Nat.cast_sum, Nat.cast_one]\n  refine sum_congr rfl fun x hx â†¦ ?_\n  rw [mem_Icc] at hx\n  rw [zeta_of_le hx.1, zeta_of_le hx.2, one_mul]\n\n"}
{"name":"IncidenceAlgebra.mu_apply","module":"Mathlib.Combinatorics.Enumerative.IncidenceAlgebra","initialProofState":"ğ•œ : Type u_2\nÎ± : Type u_5\ninstâœâ´ : AddCommGroup ğ•œ\ninstâœÂ³ : One ğ•œ\ninstâœÂ² : Preorder Î±\ninstâœÂ¹ : LocallyFiniteOrder Î±\ninstâœ : DecidableEq Î±\na b : Î±\nâŠ¢ Eq ((IncidenceAlgebra.mu ğ•œ) a b) (ite (Eq a b) 1 (Neg.neg ((Finset.Ico a b).sum fun x => (IncidenceAlgebra.mu ğ•œ) a x)))","decl":"lemma mu_apply (a b : Î±) : mu ğ•œ a b = if a = b then 1 else -âˆ‘ x âˆˆ Ico a b, mu ğ•œ a x := by\n  rw [mu, coe_mk, muFun_apply, sum_attach]\n\n"}
{"name":"IncidenceAlgebra.mu_self","module":"Mathlib.Combinatorics.Enumerative.IncidenceAlgebra","initialProofState":"ğ•œ : Type u_2\nÎ± : Type u_5\ninstâœâ´ : AddCommGroup ğ•œ\ninstâœÂ³ : One ğ•œ\ninstâœÂ² : Preorder Î±\ninstâœÂ¹ : LocallyFiniteOrder Î±\ninstâœ : DecidableEq Î±\na : Î±\nâŠ¢ Eq ((IncidenceAlgebra.mu ğ•œ) a a) 1","decl":"@[simp] lemma mu_self (a : Î±) : mu ğ•œ a a = 1 := by simp [mu_apply]\n\n"}
{"name":"IncidenceAlgebra.mu_eq_neg_sum_Ico_of_ne","module":"Mathlib.Combinatorics.Enumerative.IncidenceAlgebra","initialProofState":"ğ•œ : Type u_2\nÎ± : Type u_5\ninstâœâ´ : AddCommGroup ğ•œ\ninstâœÂ³ : One ğ•œ\ninstâœÂ² : Preorder Î±\ninstâœÂ¹ : LocallyFiniteOrder Î±\ninstâœ : DecidableEq Î±\na b : Î±\nhab : Ne a b\nâŠ¢ Eq ((IncidenceAlgebra.mu ğ•œ) a b) (Neg.neg ((Finset.Ico a b).sum fun x => (IncidenceAlgebra.mu ğ•œ) a x))","decl":"lemma mu_eq_neg_sum_Ico_of_ne (hab : a â‰  b) :\n    mu ğ•œ a b = -âˆ‘ x âˆˆ Ico a b, mu ğ•œ a x := by rw [mu_apply, if_neg hab]\n\n"}
{"name":"IncidenceAlgebra.sum_Icc_mu_right","module":"Mathlib.Combinatorics.Enumerative.IncidenceAlgebra","initialProofState":"ğ•œ : Type u_2\nÎ± : Type u_5\ninstâœâ´ : AddCommGroup ğ•œ\ninstâœÂ³ : One ğ•œ\ninstâœÂ² : PartialOrder Î±\ninstâœÂ¹ : LocallyFiniteOrder Î±\ninstâœ : DecidableEq Î±\na b : Î±\nâŠ¢ Eq ((Finset.Icc a b).sum fun x => (IncidenceAlgebra.mu ğ•œ) a x) (ite (Eq a b) 1 0)","decl":"lemma sum_Icc_mu_right (a b : Î±) : âˆ‘ x âˆˆ Icc a b, mu ğ•œ a x = if a = b then 1 else 0 := by\n  split_ifs with hab\n  Â· simp [hab]\n  by_cases hab : a â‰¤ b\n  Â· simp [Icc_eq_cons_Ico hab, mu_eq_neg_sum_Ico_of_ne â€¹_â€º]\n  Â· exact sum_eq_zero fun x hx â†¦ apply_eq_zero_of_not_le\n      (fun hax â†¦ hab <| hax.trans (mem_Icc.1 hx).2) _\n\n"}
{"name":"IncidenceAlgebra.mu_mul_zeta","module":"Mathlib.Combinatorics.Enumerative.IncidenceAlgebra","initialProofState":"ğ•œ : Type u_2\nÎ± : Type u_5\ninstâœâµ : AddCommGroup ğ•œ\ninstâœâ´ : MulOneClass ğ•œ\ninstâœÂ³ : PartialOrder Î±\ninstâœÂ² : LocallyFiniteOrder Î±\ninstâœÂ¹ : DecidableEq Î±\ninstâœ : DecidableRel fun x1 x2 => LE.le x1 x2\nâŠ¢ Eq (HMul.hMul (IncidenceAlgebra.mu ğ•œ) (IncidenceAlgebra.zeta ğ•œ)) 1","decl":"lemma mu_mul_zeta : (mu ğ•œ * zeta ğ•œ : IncidenceAlgebra ğ•œ Î±) = 1 := by\n  ext a b\n  calc\n    _ = âˆ‘ x âˆˆ Icc a b, mu ğ•œ a x := by rw [mul_apply]; congr! with x hx; simp [(mem_Icc.1 hx).2]\n    _ = (1 : IncidenceAlgebra ğ•œ Î±) a b := sum_Icc_mu_right ..\n\n"}
{"name":"IncidenceAlgebra.mu_eq_neg_sum_Ioc_of_ne","module":"Mathlib.Combinatorics.Enumerative.IncidenceAlgebra","initialProofState":"ğ•œ : Type u_2\nÎ± : Type u_5\ninstâœÂ³ : Ring ğ•œ\ninstâœÂ² : PartialOrder Î±\ninstâœÂ¹ : LocallyFiniteOrder Î±\ninstâœ : DecidableEq Î±\na b : Î±\nhab : Ne a b\nâŠ¢ Eq ((IncidenceAlgebra.mu ğ•œ) a b) (Neg.neg ((Finset.Ioc a b).sum fun x => (IncidenceAlgebra.mu ğ•œ) x b))","decl":"lemma mu_eq_neg_sum_Ioc_of_ne (hab : a â‰  b) : mu ğ•œ a b = -âˆ‘ x âˆˆ Ioc a b, mu ğ•œ x b := by\n  rw [mu_eq_mu', mu'_eq_sum_Ioc_of_ne hab]\n\n"}
{"name":"IncidenceAlgebra.zeta_mul_mu","module":"Mathlib.Combinatorics.Enumerative.IncidenceAlgebra","initialProofState":"ğ•œ : Type u_2\nÎ± : Type u_5\ninstâœâ´ : Ring ğ•œ\ninstâœÂ³ : PartialOrder Î±\ninstâœÂ² : LocallyFiniteOrder Î±\ninstâœÂ¹ : DecidableEq Î±\ninstâœ : DecidableRel fun x1 x2 => LE.le x1 x2\nâŠ¢ Eq (HMul.hMul (IncidenceAlgebra.zeta ğ•œ) (IncidenceAlgebra.mu ğ•œ)) 1","decl":"lemma zeta_mul_mu [DecidableRel (Î± := Î±) (Â· â‰¤ Â·)] : (zeta ğ•œ * mu ğ•œ : IncidenceAlgebra ğ•œ Î±) = 1 := by\n  rw [mu_eq_mu', zeta_mul_mu']\n\n"}
{"name":"IncidenceAlgebra.sum_Icc_mu_left","module":"Mathlib.Combinatorics.Enumerative.IncidenceAlgebra","initialProofState":"ğ•œ : Type u_2\nÎ± : Type u_5\ninstâœÂ³ : Ring ğ•œ\ninstâœÂ² : PartialOrder Î±\ninstâœÂ¹ : LocallyFiniteOrder Î±\ninstâœ : DecidableEq Î±\na b : Î±\nâŠ¢ Eq ((Finset.Icc a b).sum fun x => (IncidenceAlgebra.mu ğ•œ) x b) (ite (Eq a b) 1 0)","decl":"lemma sum_Icc_mu_left (a b : Î±) : âˆ‘ x âˆˆ Icc a b, mu ğ•œ x b = if a = b then 1 else 0 := by\n  rw [mu_eq_mu', sum_Icc_mu'_left]\n\n"}
{"name":"IncidenceAlgebra.mu_toDual","module":"Mathlib.Combinatorics.Enumerative.IncidenceAlgebra","initialProofState":"ğ•œ : Type u_2\nÎ± : Type u_5\ninstâœÂ³ : Ring ğ•œ\ninstâœÂ² : PartialOrder Î±\ninstâœÂ¹ : LocallyFiniteOrder Î±\ninstâœ : DecidableEq Î±\na b : Î±\nâŠ¢ Eq ((IncidenceAlgebra.mu ğ•œ) (OrderDual.toDual a) (OrderDual.toDual b)) ((IncidenceAlgebra.mu ğ•œ) b a)","decl":"@[simp]\nlemma mu_toDual (a b : Î±) : mu ğ•œ (toDual a) (toDual b) = mu ğ•œ b a := by\n  letI : DecidableRel (Î± := Î±) (Â· â‰¤ Â·) := Classical.decRel _\n  let mud : IncidenceAlgebra ğ•œ Î±áµ’áµˆ :=\n    { toFun := fun a b â†¦ mu ğ•œ (ofDual b) (ofDual a)\n      eq_zero_of_not_le' := fun a b hab â†¦ apply_eq_zero_of_not_le (by exact hab) _ }\n  suffices mu ğ•œ = mud by rw [this]; rfl\n  suffices mud * zeta ğ•œ = 1 by\n    rw [â† mu_mul_zeta] at this\n    apply_fun (Â· * mu ğ•œ) at this\n    symm\n    simpa [mul_assoc, zeta_mul_mu] using this\n  clear a b\n  ext a b\n  simp only [mul_boole, one_apply, mul_apply, coe_mk, zeta_apply]\n  calc\n    âˆ‘ x âˆˆ Icc a b, (if x â‰¤ b then mud a x else 0) = âˆ‘ x âˆˆ Icc a b, mud a x := by\n      congr! with x hx; exact if_pos (mem_Icc.1 hx).2\n    _ = âˆ‘ x âˆˆ Icc (ofDual b) (ofDual a), mu ğ•œ x (ofDual a) := by simp [Icc_orderDual_def, mud]\n    _ = if ofDual b = ofDual a then 1 else 0 := sum_Icc_mu_left ..\n    _ = if a = b then 1 else 0 := by simp [eq_comm]\n\n"}
{"name":"IncidenceAlgebra.mu_ofDual","module":"Mathlib.Combinatorics.Enumerative.IncidenceAlgebra","initialProofState":"ğ•œ : Type u_2\nÎ± : Type u_5\ninstâœÂ³ : Ring ğ•œ\ninstâœÂ² : PartialOrder Î±\ninstâœÂ¹ : LocallyFiniteOrder Î±\ninstâœ : DecidableEq Î±\na b : OrderDual Î±\nâŠ¢ Eq ((IncidenceAlgebra.mu ğ•œ) (OrderDual.ofDual a) (OrderDual.ofDual b)) ((IncidenceAlgebra.mu ğ•œ) b a)","decl":"@[simp] lemma mu_ofDual (a b : Î±áµ’áµˆ) : mu ğ•œ (ofDual a) (ofDual b) = mu ğ•œ b a := (mu_toDual ..).symm\n\n"}
{"name":"IncidenceAlgebra.eulerChar_orderDual","module":"Mathlib.Combinatorics.Enumerative.IncidenceAlgebra","initialProofState":"ğ•œ : Type u_2\nÎ± : Type u_5\ninstâœâ´ : Ring ğ•œ\ninstâœÂ³ : PartialOrder Î±\ninstâœÂ² : LocallyFiniteOrder Î±\ninstâœÂ¹ : DecidableEq Î±\ninstâœ : BoundedOrder Î±\nâŠ¢ Eq (IncidenceAlgebra.eulerChar ğ•œ (OrderDual Î±)) (IncidenceAlgebra.eulerChar ğ•œ Î±)","decl":"@[simp]\nlemma eulerChar_orderDual [BoundedOrder Î±] : eulerChar ğ•œ Î±áµ’áµˆ = eulerChar ğ•œ Î± := by\n  simp [eulerChar, â† mu_toDual ğ•œ (Î± := Î±)]\n\n"}
{"name":"IncidenceAlgebra.moebius_inversion_top","module":"Mathlib.Combinatorics.Enumerative.IncidenceAlgebra","initialProofState":"ğ•œ : Type u_2\nÎ± : Type u_5\ninstâœâ´ : Ring ğ•œ\ninstâœÂ³ : PartialOrder Î±\ninstâœÂ² : OrderTop Î±\ninstâœÂ¹ : LocallyFiniteOrder Î±\ninstâœ : DecidableEq Î±\nf g : Î± â†’ ğ•œ\nh : âˆ€ (x : Î±), Eq (g x) ((Finset.Ici x).sum fun y => f y)\nx : Î±\nâŠ¢ Eq (f x) ((Finset.Ici x).sum fun y => HMul.hMul ((IncidenceAlgebra.mu ğ•œ) x y) (g y))","decl":"/-- A general form of MÃ¶bius inversion. Based on lemma 2.1.2 of Incidence Algebras by Spiegel and\nO'Donnell. -/\nlemma moebius_inversion_top (f g : Î± â†’ ğ•œ) (h : âˆ€ x, g x = âˆ‘ y âˆˆ Ici x, f y) (x : Î±) :\n    f x = âˆ‘ y âˆˆ Ici x, mu ğ•œ x y * g y := by\n  letI : DecidableRel (Î± := Î±) (Â· â‰¤ Â·) := Classical.decRel _\n  symm\n  calc\n    âˆ‘ y âˆˆ Ici x, mu ğ•œ x y * g y = âˆ‘ y âˆˆ Ici x, mu ğ•œ x y * âˆ‘ z âˆˆ Ici y, f z := by simp_rw [h]\n    _ = âˆ‘ y âˆˆ Ici x, mu ğ•œ x y * âˆ‘ z âˆˆ Ici y, zeta ğ•œ y z * f z := by\n      congr with y\n      rw [sum_congr rfl fun z hz â†¦ ?_]\n      rw [zeta_apply, if_pos (mem_Ici.mp â€¹_â€º), one_mul]\n    _ = âˆ‘ y âˆˆ Ici x, âˆ‘ z âˆˆ Ici y, mu ğ•œ x y * zeta ğ•œ y z * f z := by simp [mul_sum]\n    _ = âˆ‘ z âˆˆ Ici x, âˆ‘ y âˆˆ Icc x z, mu ğ•œ x y * zeta ğ•œ y z * f z := by\n      rw [sum_sigma' (Ici x) fun y â†¦ Ici y]\n      rw [sum_sigma' (Ici x) fun z â†¦ Icc x z]\n      simp only [mul_boole, MulZeroClass.zero_mul, ite_mul, zeta_apply]\n      apply sum_nbij' (fun âŸ¨a, bâŸ© â†¦ âŸ¨b, aâŸ©) (fun âŸ¨a, bâŸ© â†¦ âŸ¨b, aâŸ©) <;>\n        aesop (add simp mul_assoc) (add unsafe le_trans)\n    _ = âˆ‘ z âˆˆ Ici x, (mu ğ•œ * zeta ğ•œ : IncidenceAlgebra ğ•œ Î±) x z * f z := by\n      simp_rw [mul_apply, sum_mul]\n    _ = âˆ‘ y âˆˆ Ici x, âˆ‘ z âˆˆ Ici y, (1 : IncidenceAlgebra ğ•œ Î±) x z * f z := by\n      simp [mu_mul_zeta ğ•œ, â† add_sum_Ioi_eq_sum_Ici]\n      exact sum_eq_zero fun y hy â†¦ if_neg (mem_Ioi.mp hy).not_le\n    _ = f x := by\n      simp [one_apply, â† add_sum_Ioi_eq_sum_Ici]\n      exact sum_eq_zero fun y hy â†¦ if_neg (mem_Ioi.mp hy).not_le\n\n"}
{"name":"IncidenceAlgebra.moebius_inversion_bot","module":"Mathlib.Combinatorics.Enumerative.IncidenceAlgebra","initialProofState":"ğ•œ : Type u_2\nÎ± : Type u_5\ninstâœâ´ : Ring ğ•œ\ninstâœÂ³ : PartialOrder Î±\ninstâœÂ² : OrderBot Î±\ninstâœÂ¹ : LocallyFiniteOrder Î±\ninstâœ : DecidableEq Î±\nf g : Î± â†’ ğ•œ\nh : âˆ€ (x : Î±), Eq (g x) ((Finset.Iic x).sum fun y => f y)\nx : Î±\nâŠ¢ Eq (f x) ((Finset.Iic x).sum fun y => HMul.hMul ((IncidenceAlgebra.mu ğ•œ) y x) (g y))","decl":"/-- A general form of MÃ¶bius inversion. Based on lemma 2.1.3 of Incidence Algebras by Spiegel and\nO'Donnell. -/\nlemma moebius_inversion_bot (f g : Î± â†’ ğ•œ) (h : âˆ€ x, g x = âˆ‘ y âˆˆ Iic x, f y) (x : Î±) :\n    f x = âˆ‘ y âˆˆ Iic x, mu ğ•œ y x * g y := by\n  convert moebius_inversion_top (Î± := Î±áµ’áµˆ) f g h x using 3; erw [mu_toDual]\n\n"}
{"name":"IncidenceAlgebra.zeta_prod_apply","module":"Mathlib.Combinatorics.Enumerative.IncidenceAlgebra","initialProofState":"ğ•œ : Type u_2\nÎ± : Type u_5\nÎ² : Type u_6\ninstâœâ´ : Ring ğ•œ\ninstâœÂ³ : Preorder Î±\ninstâœÂ² : Preorder Î²\ninstâœÂ¹ : DecidableRel fun x1 x2 => LE.le x1 x2\ninstâœ : DecidableRel fun x1 x2 => LE.le x1 x2\na b : Prod Î± Î²\nâŠ¢ Eq ((IncidenceAlgebra.zeta ğ•œ) a b) (HMul.hMul ((IncidenceAlgebra.zeta ğ•œ) a.1 b.1) ((IncidenceAlgebra.zeta ğ•œ) a.2 b.2))","decl":"lemma zeta_prod_apply (a b : Î± Ã— Î²) : zeta ğ•œ a b = zeta ğ•œ a.1 b.1 * zeta ğ•œ a.2 b.2 := by\n  simp [â† ite_and, Prod.le_def, and_comm]\n\n"}
{"name":"IncidenceAlgebra.zeta_prod_mk","module":"Mathlib.Combinatorics.Enumerative.IncidenceAlgebra","initialProofState":"ğ•œ : Type u_2\nÎ± : Type u_5\nÎ² : Type u_6\ninstâœâ´ : Ring ğ•œ\ninstâœÂ³ : Preorder Î±\ninstâœÂ² : Preorder Î²\ninstâœÂ¹ : DecidableRel fun x1 x2 => LE.le x1 x2\ninstâœ : DecidableRel fun x1 x2 => LE.le x1 x2\naâ‚ aâ‚‚ : Î±\nbâ‚ bâ‚‚ : Î²\nâŠ¢ Eq ((IncidenceAlgebra.zeta ğ•œ) { fst := aâ‚, snd := bâ‚ } { fst := aâ‚‚, snd := bâ‚‚ }) (HMul.hMul ((IncidenceAlgebra.zeta ğ•œ) aâ‚ aâ‚‚) ((IncidenceAlgebra.zeta ğ•œ) bâ‚ bâ‚‚))","decl":"lemma zeta_prod_mk (aâ‚ aâ‚‚ : Î±) (bâ‚ bâ‚‚ : Î²) :\n    zeta ğ•œ (aâ‚, bâ‚) (aâ‚‚, bâ‚‚) = zeta ğ•œ aâ‚ aâ‚‚ * zeta ğ•œ bâ‚ bâ‚‚ := zeta_prod_apply _ _ _\n\n"}
{"name":"IncidenceAlgebra.prod_mk","module":"Mathlib.Combinatorics.Enumerative.IncidenceAlgebra","initialProofState":"ğ•œ : Type u_2\nÎ± : Type u_5\nÎ² : Type u_6\ninstâœÂ² : Ring ğ•œ\ninstâœÂ¹ : Preorder Î±\ninstâœ : Preorder Î²\nf : IncidenceAlgebra ğ•œ Î±\ng : IncidenceAlgebra ğ•œ Î²\naâ‚ aâ‚‚ : Î±\nbâ‚ bâ‚‚ : Î²\nâŠ¢ Eq ((f.prod g) { fst := aâ‚, snd := bâ‚ } { fst := aâ‚‚, snd := bâ‚‚ }) (HMul.hMul (f aâ‚ aâ‚‚) (g bâ‚ bâ‚‚))","decl":"lemma prod_mk (aâ‚ aâ‚‚ : Î±) (bâ‚ bâ‚‚ : Î²) : f.prod g (aâ‚, bâ‚) (aâ‚‚, bâ‚‚) = f aâ‚ aâ‚‚ * g bâ‚ bâ‚‚ := rfl\n"}
{"name":"IncidenceAlgebra.prod_apply","module":"Mathlib.Combinatorics.Enumerative.IncidenceAlgebra","initialProofState":"ğ•œ : Type u_2\nÎ± : Type u_5\nÎ² : Type u_6\ninstâœÂ² : Ring ğ•œ\ninstâœÂ¹ : Preorder Î±\ninstâœ : Preorder Î²\nf : IncidenceAlgebra ğ•œ Î±\ng : IncidenceAlgebra ğ•œ Î²\nx y : Prod Î± Î²\nâŠ¢ Eq ((f.prod g) x y) (HMul.hMul (f x.1 y.1) (g x.2 y.2))","decl":"@[simp] lemma prod_apply (x y : Î± Ã— Î²) : f.prod g x y = f x.1 y.1 * g x.2 y.2 := rfl\n\n"}
{"name":"IncidenceAlgebra.prod_mul_prod'","module":"Mathlib.Combinatorics.Enumerative.IncidenceAlgebra","initialProofState":"ğ•œ : Type u_2\nÎ± : Type u_5\nÎ² : Type u_6\ninstâœâµ : Ring ğ•œ\ninstâœâ´ : Preorder Î±\ninstâœÂ³ : Preorder Î²\nfâ‚ fâ‚‚ : IncidenceAlgebra ğ•œ Î±\ngâ‚ gâ‚‚ : IncidenceAlgebra ğ•œ Î²\ninstâœÂ² : LocallyFiniteOrder Î±\ninstâœÂ¹ : LocallyFiniteOrder Î²\ninstâœ : DecidableRel fun x1 x2 => LE.le x1 x2\nh : âˆ€ (aâ‚ aâ‚‚ aâ‚ƒ : Î±) (bâ‚ bâ‚‚ bâ‚ƒ : Î²), Eq (HMul.hMul (HMul.hMul (fâ‚ aâ‚ aâ‚‚) (gâ‚ bâ‚ bâ‚‚)) (HMul.hMul (fâ‚‚ aâ‚‚ aâ‚ƒ) (gâ‚‚ bâ‚‚ bâ‚ƒ))) (HMul.hMul (HMul.hMul (fâ‚ aâ‚ aâ‚‚) (fâ‚‚ aâ‚‚ aâ‚ƒ)) (HMul.hMul (gâ‚ bâ‚ bâ‚‚) (gâ‚‚ bâ‚‚ bâ‚ƒ)))\nâŠ¢ Eq (HMul.hMul (fâ‚.prod gâ‚) (fâ‚‚.prod gâ‚‚)) ((HMul.hMul fâ‚ fâ‚‚).prod (HMul.hMul gâ‚ gâ‚‚))","decl":"/-- This is a version of `IncidenceAlgebra.prod_mul_prod` that works over non-commutative rings. -/\nlemma prod_mul_prod' [LocallyFiniteOrder Î±] [LocallyFiniteOrder Î²]\n    [DecidableRel (Î± := Î± Ã— Î²) (Â· â‰¤ Â·)]\n    (h : âˆ€ aâ‚ aâ‚‚ aâ‚ƒ bâ‚ bâ‚‚ bâ‚ƒ,\n        fâ‚ aâ‚ aâ‚‚ * gâ‚ bâ‚ bâ‚‚ * (fâ‚‚ aâ‚‚ aâ‚ƒ * gâ‚‚ bâ‚‚ bâ‚ƒ) = fâ‚ aâ‚ aâ‚‚ * fâ‚‚ aâ‚‚ aâ‚ƒ * (gâ‚ bâ‚ bâ‚‚ * gâ‚‚ bâ‚‚ bâ‚ƒ)) :\n    fâ‚.prod gâ‚ * fâ‚‚.prod gâ‚‚ = (fâ‚ * fâ‚‚).prod (gâ‚ * gâ‚‚) := by\n  ext x y; simp [Icc_prod_def, sum_mul_sum, h, sum_product]\n\n"}
{"name":"IncidenceAlgebra.one_prod_one","module":"Mathlib.Combinatorics.Enumerative.IncidenceAlgebra","initialProofState":"ğ•œ : Type u_2\nÎ± : Type u_5\nÎ² : Type u_6\ninstâœâ´ : Ring ğ•œ\ninstâœÂ³ : Preorder Î±\ninstâœÂ² : Preorder Î²\ninstâœÂ¹ : DecidableEq Î±\ninstâœ : DecidableEq Î²\nâŠ¢ Eq (IncidenceAlgebra.prod 1 1) 1","decl":"@[simp]\nlemma one_prod_one [DecidableEq Î±] [DecidableEq Î²] :\n    (.prod 1 1 : IncidenceAlgebra ğ•œ (Î± Ã— Î²)) = 1 := by\n  ext x y; simp [Prod.ext_iff, â† ite_and, and_comm]\n\n"}
{"name":"IncidenceAlgebra.zeta_prod_zeta","module":"Mathlib.Combinatorics.Enumerative.IncidenceAlgebra","initialProofState":"ğ•œ : Type u_2\nÎ± : Type u_5\nÎ² : Type u_6\ninstâœâ´ : Ring ğ•œ\ninstâœÂ³ : Preorder Î±\ninstâœÂ² : Preorder Î²\ninstâœÂ¹ : DecidableRel fun x1 x2 => LE.le x1 x2\ninstâœ : DecidableRel fun x1 x2 => LE.le x1 x2\nâŠ¢ Eq ((IncidenceAlgebra.zeta ğ•œ).prod (IncidenceAlgebra.zeta ğ•œ)) (IncidenceAlgebra.zeta ğ•œ)","decl":"@[simp]\nlemma zeta_prod_zeta [DecidableRel (Î± := Î±) (Â· â‰¤ Â·)] [DecidableRel (Î± := Î²) (Â· â‰¤ Â·)] :\n    (zeta ğ•œ).prod (zeta ğ•œ) = (zeta ğ•œ : IncidenceAlgebra ğ•œ (Î± Ã— Î²)) := by\n  ext x y hxy; simp [hxy, hxy.1, hxy.2]\n\n"}
{"name":"IncidenceAlgebra.prod_mul_prod","module":"Mathlib.Combinatorics.Enumerative.IncidenceAlgebra","initialProofState":"ğ•œ : Type u_2\nÎ± : Type u_5\nÎ² : Type u_6\ninstâœâµ : CommRing ğ•œ\ninstâœâ´ : Preorder Î±\ninstâœÂ³ : Preorder Î²\ninstâœÂ² : LocallyFiniteOrder Î±\ninstâœÂ¹ : LocallyFiniteOrder Î²\ninstâœ : DecidableRel fun x1 x2 => LE.le x1 x2\nfâ‚ fâ‚‚ : IncidenceAlgebra ğ•œ Î±\ngâ‚ gâ‚‚ : IncidenceAlgebra ğ•œ Î²\nâŠ¢ Eq (HMul.hMul (fâ‚.prod gâ‚) (fâ‚‚.prod gâ‚‚)) ((HMul.hMul fâ‚ fâ‚‚).prod (HMul.hMul gâ‚ gâ‚‚))","decl":"@[simp]\nlemma prod_mul_prod : fâ‚.prod gâ‚ * fâ‚‚.prod gâ‚‚ = (fâ‚ * fâ‚‚).prod (gâ‚ * gâ‚‚) :=\n  prod_mul_prod' _ _ _ _ fun _ _ _ _ _ _ â†¦ mul_mul_mul_comm ..\n\n"}
{"name":"IncidenceAlgebra.mu_prod_mu","module":"Mathlib.Combinatorics.Enumerative.IncidenceAlgebra","initialProofState":"ğ•œ : Type u_2\nÎ± : Type u_5\nÎ² : Type u_6\ninstâœâ¸ : Ring ğ•œ\ninstâœâ· : PartialOrder Î±\ninstâœâ¶ : PartialOrder Î²\ninstâœâµ : LocallyFiniteOrder Î±\ninstâœâ´ : LocallyFiniteOrder Î²\ninstâœÂ³ : DecidableEq Î±\ninstâœÂ² : DecidableEq Î²\ninstâœÂ¹ : DecidableRel fun x1 x2 => LE.le x1 x2\ninstâœ : DecidableRel fun x1 x2 => LE.le x1 x2\nâŠ¢ Eq ((IncidenceAlgebra.mu ğ•œ).prod (IncidenceAlgebra.mu ğ•œ)) (IncidenceAlgebra.mu ğ•œ)","decl":"/-- The MÃ¶bius function on a product order. Based on lemma 2.1.13 of Incidence Algebras by Spiegel\nand O'Donnell. -/\n@[simp]\nlemma mu_prod_mu : (mu ğ•œ).prod (mu ğ•œ) = (mu ğ•œ : IncidenceAlgebra ğ•œ (Î± Ã— Î²)) := by\n  refine left_inv_eq_right_inv ?_ zeta_mul_mu\n  rw [â† zeta_prod_zeta, prod_mul_prod', mu_mul_zeta, mu_mul_zeta, one_prod_one]\n  exact fun _ _ _ _ _ _ â†¦ Commute.mul_mul_mul_comm (by simp : _ = _) _ _\n\n"}
{"name":"IncidenceAlgebra.eulerChar_prod","module":"Mathlib.Combinatorics.Enumerative.IncidenceAlgebra","initialProofState":"ğ•œ : Type u_2\nÎ± : Type u_5\nÎ² : Type u_6\ninstâœÂ¹â° : Ring ğ•œ\ninstâœâ¹ : PartialOrder Î±\ninstâœâ¸ : PartialOrder Î²\ninstâœâ· : LocallyFiniteOrder Î±\ninstâœâ¶ : LocallyFiniteOrder Î²\ninstâœâµ : DecidableEq Î±\ninstâœâ´ : DecidableEq Î²\ninstâœÂ³ : DecidableRel fun x1 x2 => LE.le x1 x2\ninstâœÂ² : DecidableRel fun x1 x2 => LE.le x1 x2\ninstâœÂ¹ : BoundedOrder Î±\ninstâœ : BoundedOrder Î²\nâŠ¢ Eq (IncidenceAlgebra.eulerChar ğ•œ (Prod Î± Î²)) (HMul.hMul (IncidenceAlgebra.eulerChar ğ•œ Î±) (IncidenceAlgebra.eulerChar ğ•œ Î²))","decl":"@[simp]\nlemma eulerChar_prod [BoundedOrder Î±] [BoundedOrder Î²] :\n    eulerChar ğ•œ (Î± Ã— Î²) = eulerChar ğ•œ Î± * eulerChar ğ•œ Î² := by simp [eulerChar, â† mu_prod_mu]\n\n"}
