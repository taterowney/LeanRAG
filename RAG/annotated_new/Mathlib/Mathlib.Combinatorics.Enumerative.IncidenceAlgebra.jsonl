{"name":"IncidenceAlgebra.eq_zero_of_not_le'","module":"Mathlib.Combinatorics.Enumerative.IncidenceAlgebra","initialProofState":"𝕜 : Type u_7\nα : Type u_8\ninst✝¹ : Zero 𝕜\ninst✝ : LE α\nself : IncidenceAlgebra 𝕜 α\na b : α\na✝ : Not (LE.le a b)\n⊢ Eq (self.toFun a b) 0","decl":"/-- The `𝕜`-incidence algebra over `α`. -/\nstructure IncidenceAlgebra (𝕜 α : Type*) [Zero 𝕜] [LE α] where\n  /-- The underlying function of an element of the incidence algebra.\n\n  Do not use this function directly. Instead use the coercion coming from the `FunLike`\n  instance. -/\n  toFun : α → α → 𝕜\n  eq_zero_of_not_le' ⦃a b : α⦄ : ¬a ≤ b → toFun a b = 0\n\n"}
{"name":"IncidenceAlgebra.mk.inj","module":"Mathlib.Combinatorics.Enumerative.IncidenceAlgebra","initialProofState":"𝕜 : Type u_7\nα : Type u_8\ninst✝¹ : Zero 𝕜\ninst✝ : LE α\ntoFun✝ : α → α → 𝕜\neq_zero_of_not_le'✝ : ∀ ⦃a b : α⦄, Not (LE.le a b) → Eq (toFun✝ a b) 0\ntoFun : α → α → 𝕜\neq_zero_of_not_le' : ∀ ⦃a b : α⦄, Not (LE.le a b) → Eq (toFun a b) 0\nx✝ : Eq { toFun := toFun✝, eq_zero_of_not_le' := eq_zero_of_not_le'✝ } { toFun := toFun, eq_zero_of_not_le' := eq_zero_of_not_le' }\n⊢ Eq toFun✝ toFun","decl":"/-- The `𝕜`-incidence algebra over `α`. -/\nstructure IncidenceAlgebra (𝕜 α : Type*) [Zero 𝕜] [LE α] where\n  /-- The underlying function of an element of the incidence algebra.\n\n  Do not use this function directly. Instead use the coercion coming from the `FunLike`\n  instance. -/\n  toFun : α → α → 𝕜\n  eq_zero_of_not_le' ⦃a b : α⦄ : ¬a ≤ b → toFun a b = 0\n\n"}
{"name":"IncidenceAlgebra.mk.sizeOf_spec","module":"Mathlib.Combinatorics.Enumerative.IncidenceAlgebra","initialProofState":"𝕜 : Type u_7\nα : Type u_8\ninst✝³ : Zero 𝕜\ninst✝² : LE α\ninst✝¹ : SizeOf 𝕜\ninst✝ : SizeOf α\ntoFun : α → α → 𝕜\neq_zero_of_not_le' : ∀ ⦃a b : α⦄, Not (LE.le a b) → Eq (toFun a b) 0\n⊢ Eq (SizeOf.sizeOf { toFun := toFun, eq_zero_of_not_le' := eq_zero_of_not_le' }) 1","decl":"/-- The `𝕜`-incidence algebra over `α`. -/\nstructure IncidenceAlgebra (𝕜 α : Type*) [Zero 𝕜] [LE α] where\n  /-- The underlying function of an element of the incidence algebra.\n\n  Do not use this function directly. Instead use the coercion coming from the `FunLike`\n  instance. -/\n  toFun : α → α → 𝕜\n  eq_zero_of_not_le' ⦃a b : α⦄ : ¬a ≤ b → toFun a b = 0\n\n"}
{"name":"IncidenceAlgebra.mk.injEq","module":"Mathlib.Combinatorics.Enumerative.IncidenceAlgebra","initialProofState":"𝕜 : Type u_7\nα : Type u_8\ninst✝¹ : Zero 𝕜\ninst✝ : LE α\ntoFun✝ : α → α → 𝕜\neq_zero_of_not_le'✝ : ∀ ⦃a b : α⦄, Not (LE.le a b) → Eq (toFun✝ a b) 0\ntoFun : α → α → 𝕜\neq_zero_of_not_le' : ∀ ⦃a b : α⦄, Not (LE.le a b) → Eq (toFun a b) 0\n⊢ Eq (Eq { toFun := toFun✝, eq_zero_of_not_le' := eq_zero_of_not_le'✝ } { toFun := toFun, eq_zero_of_not_le' := eq_zero_of_not_le' }) (Eq toFun✝ toFun)","decl":"/-- The `𝕜`-incidence algebra over `α`. -/\nstructure IncidenceAlgebra (𝕜 α : Type*) [Zero 𝕜] [LE α] where\n  /-- The underlying function of an element of the incidence algebra.\n\n  Do not use this function directly. Instead use the coercion coming from the `FunLike`\n  instance. -/\n  toFun : α → α → 𝕜\n  eq_zero_of_not_le' ⦃a b : α⦄ : ¬a ≤ b → toFun a b = 0\n\n"}
{"name":"IncidenceAlgebra.apply_eq_zero_of_not_le","module":"Mathlib.Combinatorics.Enumerative.IncidenceAlgebra","initialProofState":"𝕜 : Type u_2\nα : Type u_5\ninst✝¹ : Zero 𝕜\ninst✝ : LE α\na b : α\nh : Not (LE.le a b)\nf : IncidenceAlgebra 𝕜 α\n⊢ Eq (f a b) 0","decl":"lemma apply_eq_zero_of_not_le (h : ¬a ≤ b) (f : IncidenceAlgebra 𝕜 α) : f a b = 0 :=\n  eq_zero_of_not_le' _ h\n\n"}
{"name":"IncidenceAlgebra.le_of_ne_zero","module":"Mathlib.Combinatorics.Enumerative.IncidenceAlgebra","initialProofState":"𝕜 : Type u_2\nα : Type u_5\ninst✝¹ : Zero 𝕜\ninst✝ : LE α\na b : α\nf : IncidenceAlgebra 𝕜 α\na✝ : Ne (f a b) 0\n⊢ LE.le a b","decl":"lemma le_of_ne_zero {f : IncidenceAlgebra 𝕜 α} : f a b ≠ 0 → a ≤ b :=\n  not_imp_comm.1 fun h ↦ apply_eq_zero_of_not_le h _\n\n"}
{"name":"IncidenceAlgebra.toFun_eq_coe","module":"Mathlib.Combinatorics.Enumerative.IncidenceAlgebra","initialProofState":"𝕜 : Type u_2\nα : Type u_5\ninst✝¹ : Zero 𝕜\ninst✝ : LE α\nf : IncidenceAlgebra 𝕜 α\n⊢ Eq f.toFun ⇑f","decl":"@[simp] lemma toFun_eq_coe (f : IncidenceAlgebra 𝕜 α) : f.toFun = f := rfl\n"}
{"name":"IncidenceAlgebra.coe_mk","module":"Mathlib.Combinatorics.Enumerative.IncidenceAlgebra","initialProofState":"𝕜 : Type u_2\nα : Type u_5\ninst✝¹ : Zero 𝕜\ninst✝ : LE α\nf : α → α → 𝕜\nh : ∀ ⦃a b : α⦄, Not (LE.le a b) → Eq (f a b) 0\n⊢ Eq (⇑{ toFun := f, eq_zero_of_not_le' := h }) f","decl":"@[simp, norm_cast] lemma coe_mk (f : α → α → 𝕜) (h) : (mk f h : α → α → 𝕜) = f := rfl\n\n"}
{"name":"IncidenceAlgebra.coe_inj","module":"Mathlib.Combinatorics.Enumerative.IncidenceAlgebra","initialProofState":"𝕜 : Type u_2\nα : Type u_5\ninst✝¹ : Zero 𝕜\ninst✝ : LE α\nf g : IncidenceAlgebra 𝕜 α\n⊢ Iff (Eq ⇑f ⇑g) (Eq f g)","decl":"lemma coe_inj {f g : IncidenceAlgebra 𝕜 α} : (f : α → α → 𝕜) = g ↔ f = g :=\n  DFunLike.coe_injective.eq_iff\n\n"}
{"name":"IncidenceAlgebra.ext","module":"Mathlib.Combinatorics.Enumerative.IncidenceAlgebra","initialProofState":"𝕜 : Type u_2\nα : Type u_5\ninst✝¹ : Zero 𝕜\ninst✝ : LE α\nf g : IncidenceAlgebra 𝕜 α\nh : ∀ (a b : α), LE.le a b → Eq (f a b) (g a b)\n⊢ Eq f g","decl":"@[ext]\nlemma ext ⦃f g : IncidenceAlgebra 𝕜 α⦄ (h : ∀ a b, a ≤ b → f a b = g a b) : f = g := by\n  refine DFunLike.coe_injective' (funext₂ fun a b ↦ ?_)\n  by_cases hab : a ≤ b\n  · exact h _ _ hab\n  · rw [apply_eq_zero_of_not_le hab, apply_eq_zero_of_not_le hab]\n\n"}
{"name":"IncidenceAlgebra.ext_iff","module":"Mathlib.Combinatorics.Enumerative.IncidenceAlgebra","initialProofState":"𝕜 : Type u_2\nα : Type u_5\ninst✝¹ : Zero 𝕜\ninst✝ : LE α\nf g : IncidenceAlgebra 𝕜 α\n⊢ Iff (Eq f g) (∀ (a b : α), LE.le a b → Eq (f a b) (g a b))","decl":"@[ext]\nlemma ext ⦃f g : IncidenceAlgebra 𝕜 α⦄ (h : ∀ a b, a ≤ b → f a b = g a b) : f = g := by\n  refine DFunLike.coe_injective' (funext₂ fun a b ↦ ?_)\n  by_cases hab : a ≤ b\n  · exact h _ _ hab\n  · rw [apply_eq_zero_of_not_le hab, apply_eq_zero_of_not_le hab]\n\n"}
{"name":"IncidenceAlgebra.mk_coe","module":"Mathlib.Combinatorics.Enumerative.IncidenceAlgebra","initialProofState":"𝕜 : Type u_2\nα : Type u_5\ninst✝¹ : Zero 𝕜\ninst✝ : LE α\nf : IncidenceAlgebra 𝕜 α\nh : ∀ ⦃a b : α⦄, Not (LE.le a b) → Eq (f a b) 0\n⊢ Eq { toFun := ⇑f, eq_zero_of_not_le' := h } f","decl":"@[simp] lemma mk_coe (f : IncidenceAlgebra 𝕜 α) (h) : mk f h = f := rfl\n\n"}
{"name":"IncidenceAlgebra.coe_zero","module":"Mathlib.Combinatorics.Enumerative.IncidenceAlgebra","initialProofState":"𝕜 : Type u_2\nα : Type u_5\ninst✝¹ : Zero 𝕜\ninst✝ : LE α\n⊢ Eq (⇑0) 0","decl":"@[simp, norm_cast] lemma coe_zero : ⇑(0 : IncidenceAlgebra 𝕜 α) = 0 := rfl\n"}
{"name":"IncidenceAlgebra.zero_apply","module":"Mathlib.Combinatorics.Enumerative.IncidenceAlgebra","initialProofState":"𝕜 : Type u_2\nα : Type u_5\ninst✝¹ : Zero 𝕜\ninst✝ : LE α\na b : α\n⊢ Eq (0 a b) 0","decl":"lemma zero_apply (a b : α) : (0 : IncidenceAlgebra 𝕜 α) a b = 0 := rfl\n\n"}
{"name":"IncidenceAlgebra.coe_add","module":"Mathlib.Combinatorics.Enumerative.IncidenceAlgebra","initialProofState":"𝕜 : Type u_2\nα : Type u_5\ninst✝¹ : AddZeroClass 𝕜\ninst✝ : LE α\nf g : IncidenceAlgebra 𝕜 α\n⊢ Eq (⇑(HAdd.hAdd f g)) (HAdd.hAdd ⇑f ⇑g)","decl":"@[simp, norm_cast] lemma coe_add (f g : IncidenceAlgebra 𝕜 α) : ⇑(f + g) = f + g := rfl\n"}
{"name":"IncidenceAlgebra.add_apply","module":"Mathlib.Combinatorics.Enumerative.IncidenceAlgebra","initialProofState":"𝕜 : Type u_2\nα : Type u_5\ninst✝¹ : AddZeroClass 𝕜\ninst✝ : LE α\nf g : IncidenceAlgebra 𝕜 α\na b : α\n⊢ Eq ((HAdd.hAdd f g) a b) (HAdd.hAdd (f a b) (g a b))","decl":"lemma add_apply (f g : IncidenceAlgebra 𝕜 α) (a b : α) : (f + g) a b = f a b + g a b := rfl\n\n"}
{"name":"IncidenceAlgebra.coe_constSMul","module":"Mathlib.Combinatorics.Enumerative.IncidenceAlgebra","initialProofState":"𝕜 : Type u_2\nα : Type u_5\nM : Type u_7\ninst✝² : Zero 𝕜\ninst✝¹ : LE α\ninst✝ : SMulZeroClass M 𝕜\nc : M\nf : IncidenceAlgebra 𝕜 α\n⊢ Eq (⇑(HSMul.hSMul c f)) (HSMul.hSMul c ⇑f)","decl":"@[simp, norm_cast] lemma coe_constSMul (c : M) (f : IncidenceAlgebra 𝕜 α) : ⇑(c • f) = c • ⇑f := rfl\n\n"}
{"name":"IncidenceAlgebra.constSMul_apply","module":"Mathlib.Combinatorics.Enumerative.IncidenceAlgebra","initialProofState":"𝕜 : Type u_2\nα : Type u_5\nM : Type u_7\ninst✝² : Zero 𝕜\ninst✝¹ : LE α\ninst✝ : SMulZeroClass M 𝕜\nc : M\nf : IncidenceAlgebra 𝕜 α\na b : α\n⊢ Eq ((HSMul.hSMul c f) a b) (HSMul.hSMul c (f a b))","decl":"lemma constSMul_apply (c : M) (f : IncidenceAlgebra 𝕜 α) (a b : α) : (c • f) a b = c • f a b := rfl\n\n"}
{"name":"IncidenceAlgebra.coe_neg","module":"Mathlib.Combinatorics.Enumerative.IncidenceAlgebra","initialProofState":"𝕜 : Type u_2\nα : Type u_5\ninst✝¹ : AddGroup 𝕜\ninst✝ : LE α\nf : IncidenceAlgebra 𝕜 α\n⊢ Eq (⇑(Neg.neg f)) (Neg.neg ⇑f)","decl":"@[simp, norm_cast] lemma coe_neg (f : IncidenceAlgebra 𝕜 α) : ⇑(-f) = -f := rfl\n"}
{"name":"IncidenceAlgebra.coe_sub","module":"Mathlib.Combinatorics.Enumerative.IncidenceAlgebra","initialProofState":"𝕜 : Type u_2\nα : Type u_5\ninst✝¹ : AddGroup 𝕜\ninst✝ : LE α\nf g : IncidenceAlgebra 𝕜 α\n⊢ Eq (⇑(HSub.hSub f g)) (HSub.hSub ⇑f ⇑g)","decl":"@[simp, norm_cast] lemma coe_sub (f g : IncidenceAlgebra 𝕜 α) : ⇑(f - g) = f - g := rfl\n"}
{"name":"IncidenceAlgebra.neg_apply","module":"Mathlib.Combinatorics.Enumerative.IncidenceAlgebra","initialProofState":"𝕜 : Type u_2\nα : Type u_5\ninst✝¹ : AddGroup 𝕜\ninst✝ : LE α\nf : IncidenceAlgebra 𝕜 α\na b : α\n⊢ Eq ((Neg.neg f) a b) (Neg.neg (f a b))","decl":"lemma neg_apply (f : IncidenceAlgebra 𝕜 α) (a b : α) : (-f) a b = -f a b := rfl\n"}
{"name":"IncidenceAlgebra.sub_apply","module":"Mathlib.Combinatorics.Enumerative.IncidenceAlgebra","initialProofState":"𝕜 : Type u_2\nα : Type u_5\ninst✝¹ : AddGroup 𝕜\ninst✝ : LE α\nf g : IncidenceAlgebra 𝕜 α\na b : α\n⊢ Eq ((HSub.hSub f g) a b) (HSub.hSub (f a b) (g a b))","decl":"lemma sub_apply (f g : IncidenceAlgebra 𝕜 α) (a b : α) : (f - g) a b = f a b - g a b := rfl\n\n"}
{"name":"IncidenceAlgebra.one_apply","module":"Mathlib.Combinatorics.Enumerative.IncidenceAlgebra","initialProofState":"𝕜 : Type u_2\nα : Type u_5\ninst✝³ : Preorder α\ninst✝² : DecidableEq α\ninst✝¹ : Zero 𝕜\ninst✝ : One 𝕜\na b : α\n⊢ Eq (1 a b) (ite (Eq a b) 1 0)","decl":"@[simp] lemma one_apply (a b : α) : (1 : IncidenceAlgebra 𝕜 α) a b = if a = b then 1 else 0 := rfl\n\n"}
{"name":"IncidenceAlgebra.mul_apply","module":"Mathlib.Combinatorics.Enumerative.IncidenceAlgebra","initialProofState":"𝕜 : Type u_2\nα : Type u_5\ninst✝³ : Preorder α\ninst✝² : LocallyFiniteOrder α\ninst✝¹ : AddCommMonoid 𝕜\ninst✝ : Mul 𝕜\nf g : IncidenceAlgebra 𝕜 α\na b : α\n⊢ Eq ((HMul.hMul f g) a b) ((Finset.Icc a b).sum fun x => HMul.hMul (f a x) (g x b))","decl":"@[simp] lemma mul_apply (f g : IncidenceAlgebra 𝕜 α) (a b : α) :\n    (f * g) a b = ∑ x ∈ Icc a b, f a x * g x b := rfl\n\n"}
{"name":"IncidenceAlgebra.smul_apply","module":"Mathlib.Combinatorics.Enumerative.IncidenceAlgebra","initialProofState":"𝕜 : Type u_2\n𝕝 : Type u_3\nα : Type u_5\ninst✝⁴ : Preorder α\ninst✝³ : LocallyFiniteOrder α\ninst✝² : AddCommMonoid 𝕜\ninst✝¹ : AddCommMonoid 𝕝\ninst✝ : SMul 𝕜 𝕝\nf : IncidenceAlgebra 𝕜 α\ng : IncidenceAlgebra 𝕝 α\na b : α\n⊢ Eq ((HSMul.hSMul f g) a b) ((Finset.Icc a b).sum fun x => HSMul.hSMul (f a x) (g x b))","decl":"@[simp]\nlemma smul_apply (f : IncidenceAlgebra 𝕜 α) (g : IncidenceAlgebra 𝕝 α) (a b : α) :\n    (f • g) a b = ∑ x ∈ Icc a b, f a x • g x b :=\n  rfl\n\n"}
{"name":"IncidenceAlgebra.instIsScalarTower","module":"Mathlib.Combinatorics.Enumerative.IncidenceAlgebra","initialProofState":"𝕜 : Type u_2\n𝕝 : Type u_3\n𝕞 : Type u_4\nα : Type u_5\ninst✝⁹ : Preorder α\ninst✝⁸ : LocallyFiniteOrder α\ninst✝⁷ : AddCommMonoid 𝕜\ninst✝⁶ : Monoid 𝕜\ninst✝⁵ : Semiring 𝕝\ninst✝⁴ : AddCommMonoid 𝕞\ninst✝³ : SMul 𝕜 𝕝\ninst✝² : Module 𝕝 𝕞\ninst✝¹ : DistribMulAction 𝕜 𝕞\ninst✝ : IsScalarTower 𝕜 𝕝 𝕞\n⊢ IsScalarTower (IncidenceAlgebra 𝕜 α) (IncidenceAlgebra 𝕝 α) (IncidenceAlgebra 𝕞 α)","decl":"instance instIsScalarTower [Preorder α] [LocallyFiniteOrder α] [AddCommMonoid 𝕜] [Monoid 𝕜]\n    [Semiring 𝕝] [AddCommMonoid 𝕞] [SMul 𝕜 𝕝] [Module 𝕝 𝕞] [DistribMulAction 𝕜 𝕞]\n    [IsScalarTower 𝕜 𝕝 𝕞] :\n    IsScalarTower (IncidenceAlgebra 𝕜 α) (IncidenceAlgebra 𝕝 α) (IncidenceAlgebra 𝕞 α) where\n  smul_assoc f g h := by\n    ext a b\n    simp only [smul_apply, sum_smul, smul_sum, sum_sigma']\n    apply sum_nbij' (fun ⟨a, b⟩ ↦ ⟨b, a⟩) (fun ⟨a, b⟩ ↦ ⟨b, a⟩) <;> aesop (add unsafe le_trans)\n\n"}
{"name":"IncidenceAlgebra.lambda_apply","module":"Mathlib.Combinatorics.Enumerative.IncidenceAlgebra","initialProofState":"𝕜 : Type u_2\nα : Type u_5\ninst✝³ : Zero 𝕜\ninst✝² : One 𝕜\ninst✝¹ : Preorder α\ninst✝ : DecidableRel fun x1 x2 => WCovBy x1 x2\na b : α\n⊢ Eq ((IncidenceAlgebra.lambda 𝕜) a b) (ite (WCovBy a b) 1 0)","decl":"/-- The lambda function of the incidence algebra is the function that assigns `1` to every nonempty\ninterval of cardinality one or two. -/\n@[simps]\ndef lambda : IncidenceAlgebra 𝕜 α :=\n  ⟨fun a b ↦ if a ⩿ b then 1 else 0, fun _a _b h ↦ if_neg fun hh ↦ h hh.le⟩\n\n"}
{"name":"IncidenceAlgebra.zeta_apply","module":"Mathlib.Combinatorics.Enumerative.IncidenceAlgebra","initialProofState":"𝕜 : Type u_2\nα : Type u_5\ninst✝³ : Zero 𝕜\ninst✝² : One 𝕜\ninst✝¹ : LE α\ninst✝ : DecidableRel fun x1 x2 => LE.le x1 x2\na b : α\n⊢ Eq ((IncidenceAlgebra.zeta 𝕜) a b) (ite (LE.le a b) 1 0)","decl":"@[simp] lemma zeta_apply (a b : α) : zeta 𝕜 a b = if a ≤ b then 1 else 0 := rfl\n\n"}
{"name":"IncidenceAlgebra.zeta_of_le","module":"Mathlib.Combinatorics.Enumerative.IncidenceAlgebra","initialProofState":"𝕜 : Type u_2\nα : Type u_5\ninst✝³ : Zero 𝕜\ninst✝² : One 𝕜\ninst✝¹ : LE α\ninst✝ : DecidableRel fun x1 x2 => LE.le x1 x2\na b : α\nh : LE.le a b\n⊢ Eq ((IncidenceAlgebra.zeta 𝕜) a b) 1","decl":"lemma zeta_of_le (h : a ≤ b) : zeta 𝕜 a b = 1 := if_pos h\n\n"}
{"name":"IncidenceAlgebra.zeta_mul_zeta","module":"Mathlib.Combinatorics.Enumerative.IncidenceAlgebra","initialProofState":"𝕜 : Type u_2\nα : Type u_5\ninst✝³ : Semiring 𝕜\ninst✝² : Preorder α\ninst✝¹ : LocallyFiniteOrder α\ninst✝ : DecidableRel fun x1 x2 => LE.le x1 x2\na b : α\n⊢ Eq ((HMul.hMul (IncidenceAlgebra.zeta 𝕜) (IncidenceAlgebra.zeta 𝕜)) a b) ↑(Finset.Icc a b).card","decl":"lemma zeta_mul_zeta [Semiring 𝕜] [Preorder α] [LocallyFiniteOrder α] [DecidableRel (α := α) (· ≤ ·)]\n    (a b : α) : (zeta 𝕜 * zeta 𝕜 : IncidenceAlgebra 𝕜 α) a b = (Icc a b).card := by\n  rw [mul_apply, card_eq_sum_ones, Nat.cast_sum, Nat.cast_one]\n  refine sum_congr rfl fun x hx ↦ ?_\n  rw [mem_Icc] at hx\n  rw [zeta_of_le hx.1, zeta_of_le hx.2, one_mul]\n\n"}
{"name":"IncidenceAlgebra.zeta_mul_kappa","module":"Mathlib.Combinatorics.Enumerative.IncidenceAlgebra","initialProofState":"𝕜 : Type u_2\nα : Type u_5\ninst✝³ : Semiring 𝕜\ninst✝² : Preorder α\ninst✝¹ : LocallyFiniteOrder α\ninst✝ : DecidableRel fun x1 x2 => LE.le x1 x2\na b : α\n⊢ Eq ((HMul.hMul (IncidenceAlgebra.zeta 𝕜) (IncidenceAlgebra.zeta 𝕜)) a b) ↑(Finset.Icc a b).card","decl":"lemma zeta_mul_kappa [Semiring 𝕜] [Preorder α] [LocallyFiniteOrder α]\n    [DecidableRel (α := α) (· ≤ ·)] (a b : α) :\n    (zeta 𝕜 * zeta 𝕜 : IncidenceAlgebra 𝕜 α) a b = (Icc a b).card := by\n  rw [mul_apply, card_eq_sum_ones, Nat.cast_sum, Nat.cast_one]\n  refine sum_congr rfl fun x hx ↦ ?_\n  rw [mem_Icc] at hx\n  rw [zeta_of_le hx.1, zeta_of_le hx.2, one_mul]\n\n"}
{"name":"IncidenceAlgebra.mu_apply","module":"Mathlib.Combinatorics.Enumerative.IncidenceAlgebra","initialProofState":"𝕜 : Type u_2\nα : Type u_5\ninst✝⁴ : AddCommGroup 𝕜\ninst✝³ : One 𝕜\ninst✝² : Preorder α\ninst✝¹ : LocallyFiniteOrder α\ninst✝ : DecidableEq α\na b : α\n⊢ Eq ((IncidenceAlgebra.mu 𝕜) a b) (ite (Eq a b) 1 (Neg.neg ((Finset.Ico a b).sum fun x => (IncidenceAlgebra.mu 𝕜) a x)))","decl":"lemma mu_apply (a b : α) : mu 𝕜 a b = if a = b then 1 else -∑ x ∈ Ico a b, mu 𝕜 a x := by\n  rw [mu, coe_mk, muFun_apply, sum_attach]\n\n"}
{"name":"IncidenceAlgebra.mu_self","module":"Mathlib.Combinatorics.Enumerative.IncidenceAlgebra","initialProofState":"𝕜 : Type u_2\nα : Type u_5\ninst✝⁴ : AddCommGroup 𝕜\ninst✝³ : One 𝕜\ninst✝² : Preorder α\ninst✝¹ : LocallyFiniteOrder α\ninst✝ : DecidableEq α\na : α\n⊢ Eq ((IncidenceAlgebra.mu 𝕜) a a) 1","decl":"@[simp] lemma mu_self (a : α) : mu 𝕜 a a = 1 := by simp [mu_apply]\n\n"}
{"name":"IncidenceAlgebra.mu_eq_neg_sum_Ico_of_ne","module":"Mathlib.Combinatorics.Enumerative.IncidenceAlgebra","initialProofState":"𝕜 : Type u_2\nα : Type u_5\ninst✝⁴ : AddCommGroup 𝕜\ninst✝³ : One 𝕜\ninst✝² : Preorder α\ninst✝¹ : LocallyFiniteOrder α\ninst✝ : DecidableEq α\na b : α\nhab : Ne a b\n⊢ Eq ((IncidenceAlgebra.mu 𝕜) a b) (Neg.neg ((Finset.Ico a b).sum fun x => (IncidenceAlgebra.mu 𝕜) a x))","decl":"lemma mu_eq_neg_sum_Ico_of_ne (hab : a ≠ b) :\n    mu 𝕜 a b = -∑ x ∈ Ico a b, mu 𝕜 a x := by rw [mu_apply, if_neg hab]\n\n"}
{"name":"IncidenceAlgebra.sum_Icc_mu_right","module":"Mathlib.Combinatorics.Enumerative.IncidenceAlgebra","initialProofState":"𝕜 : Type u_2\nα : Type u_5\ninst✝⁴ : AddCommGroup 𝕜\ninst✝³ : One 𝕜\ninst✝² : PartialOrder α\ninst✝¹ : LocallyFiniteOrder α\ninst✝ : DecidableEq α\na b : α\n⊢ Eq ((Finset.Icc a b).sum fun x => (IncidenceAlgebra.mu 𝕜) a x) (ite (Eq a b) 1 0)","decl":"lemma sum_Icc_mu_right (a b : α) : ∑ x ∈ Icc a b, mu 𝕜 a x = if a = b then 1 else 0 := by\n  split_ifs with hab\n  · simp [hab]\n  by_cases hab : a ≤ b\n  · simp [Icc_eq_cons_Ico hab, mu_eq_neg_sum_Ico_of_ne ‹_›]\n  · exact sum_eq_zero fun x hx ↦ apply_eq_zero_of_not_le\n      (fun hax ↦ hab <| hax.trans (mem_Icc.1 hx).2) _\n\n"}
{"name":"IncidenceAlgebra.mu_mul_zeta","module":"Mathlib.Combinatorics.Enumerative.IncidenceAlgebra","initialProofState":"𝕜 : Type u_2\nα : Type u_5\ninst✝⁵ : AddCommGroup 𝕜\ninst✝⁴ : MulOneClass 𝕜\ninst✝³ : PartialOrder α\ninst✝² : LocallyFiniteOrder α\ninst✝¹ : DecidableEq α\ninst✝ : DecidableRel fun x1 x2 => LE.le x1 x2\n⊢ Eq (HMul.hMul (IncidenceAlgebra.mu 𝕜) (IncidenceAlgebra.zeta 𝕜)) 1","decl":"lemma mu_mul_zeta : (mu 𝕜 * zeta 𝕜 : IncidenceAlgebra 𝕜 α) = 1 := by\n  ext a b\n  calc\n    _ = ∑ x ∈ Icc a b, mu 𝕜 a x := by rw [mul_apply]; congr! with x hx; simp [(mem_Icc.1 hx).2]\n    _ = (1 : IncidenceAlgebra 𝕜 α) a b := sum_Icc_mu_right ..\n\n"}
{"name":"IncidenceAlgebra.mu_eq_neg_sum_Ioc_of_ne","module":"Mathlib.Combinatorics.Enumerative.IncidenceAlgebra","initialProofState":"𝕜 : Type u_2\nα : Type u_5\ninst✝³ : Ring 𝕜\ninst✝² : PartialOrder α\ninst✝¹ : LocallyFiniteOrder α\ninst✝ : DecidableEq α\na b : α\nhab : Ne a b\n⊢ Eq ((IncidenceAlgebra.mu 𝕜) a b) (Neg.neg ((Finset.Ioc a b).sum fun x => (IncidenceAlgebra.mu 𝕜) x b))","decl":"lemma mu_eq_neg_sum_Ioc_of_ne (hab : a ≠ b) : mu 𝕜 a b = -∑ x ∈ Ioc a b, mu 𝕜 x b := by\n  rw [mu_eq_mu', mu'_eq_sum_Ioc_of_ne hab]\n\n"}
{"name":"IncidenceAlgebra.zeta_mul_mu","module":"Mathlib.Combinatorics.Enumerative.IncidenceAlgebra","initialProofState":"𝕜 : Type u_2\nα : Type u_5\ninst✝⁴ : Ring 𝕜\ninst✝³ : PartialOrder α\ninst✝² : LocallyFiniteOrder α\ninst✝¹ : DecidableEq α\ninst✝ : DecidableRel fun x1 x2 => LE.le x1 x2\n⊢ Eq (HMul.hMul (IncidenceAlgebra.zeta 𝕜) (IncidenceAlgebra.mu 𝕜)) 1","decl":"lemma zeta_mul_mu [DecidableRel (α := α) (· ≤ ·)] : (zeta 𝕜 * mu 𝕜 : IncidenceAlgebra 𝕜 α) = 1 := by\n  rw [mu_eq_mu', zeta_mul_mu']\n\n"}
{"name":"IncidenceAlgebra.sum_Icc_mu_left","module":"Mathlib.Combinatorics.Enumerative.IncidenceAlgebra","initialProofState":"𝕜 : Type u_2\nα : Type u_5\ninst✝³ : Ring 𝕜\ninst✝² : PartialOrder α\ninst✝¹ : LocallyFiniteOrder α\ninst✝ : DecidableEq α\na b : α\n⊢ Eq ((Finset.Icc a b).sum fun x => (IncidenceAlgebra.mu 𝕜) x b) (ite (Eq a b) 1 0)","decl":"lemma sum_Icc_mu_left (a b : α) : ∑ x ∈ Icc a b, mu 𝕜 x b = if a = b then 1 else 0 := by\n  rw [mu_eq_mu', sum_Icc_mu'_left]\n\n"}
{"name":"IncidenceAlgebra.mu_toDual","module":"Mathlib.Combinatorics.Enumerative.IncidenceAlgebra","initialProofState":"𝕜 : Type u_2\nα : Type u_5\ninst✝³ : Ring 𝕜\ninst✝² : PartialOrder α\ninst✝¹ : LocallyFiniteOrder α\ninst✝ : DecidableEq α\na b : α\n⊢ Eq ((IncidenceAlgebra.mu 𝕜) (OrderDual.toDual a) (OrderDual.toDual b)) ((IncidenceAlgebra.mu 𝕜) b a)","decl":"@[simp]\nlemma mu_toDual (a b : α) : mu 𝕜 (toDual a) (toDual b) = mu 𝕜 b a := by\n  letI : DecidableRel (α := α) (· ≤ ·) := Classical.decRel _\n  let mud : IncidenceAlgebra 𝕜 αᵒᵈ :=\n    { toFun := fun a b ↦ mu 𝕜 (ofDual b) (ofDual a)\n      eq_zero_of_not_le' := fun a b hab ↦ apply_eq_zero_of_not_le (by exact hab) _ }\n  suffices mu 𝕜 = mud by rw [this]; rfl\n  suffices mud * zeta 𝕜 = 1 by\n    rw [← mu_mul_zeta] at this\n    apply_fun (· * mu 𝕜) at this\n    symm\n    simpa [mul_assoc, zeta_mul_mu] using this\n  clear a b\n  ext a b\n  simp only [mul_boole, one_apply, mul_apply, coe_mk, zeta_apply]\n  calc\n    ∑ x ∈ Icc a b, (if x ≤ b then mud a x else 0) = ∑ x ∈ Icc a b, mud a x := by\n      congr! with x hx; exact if_pos (mem_Icc.1 hx).2\n    _ = ∑ x ∈ Icc (ofDual b) (ofDual a), mu 𝕜 x (ofDual a) := by simp [Icc_orderDual_def, mud]\n    _ = if ofDual b = ofDual a then 1 else 0 := sum_Icc_mu_left ..\n    _ = if a = b then 1 else 0 := by simp [eq_comm]\n\n"}
{"name":"IncidenceAlgebra.mu_ofDual","module":"Mathlib.Combinatorics.Enumerative.IncidenceAlgebra","initialProofState":"𝕜 : Type u_2\nα : Type u_5\ninst✝³ : Ring 𝕜\ninst✝² : PartialOrder α\ninst✝¹ : LocallyFiniteOrder α\ninst✝ : DecidableEq α\na b : OrderDual α\n⊢ Eq ((IncidenceAlgebra.mu 𝕜) (OrderDual.ofDual a) (OrderDual.ofDual b)) ((IncidenceAlgebra.mu 𝕜) b a)","decl":"@[simp] lemma mu_ofDual (a b : αᵒᵈ) : mu 𝕜 (ofDual a) (ofDual b) = mu 𝕜 b a := (mu_toDual ..).symm\n\n"}
{"name":"IncidenceAlgebra.eulerChar_orderDual","module":"Mathlib.Combinatorics.Enumerative.IncidenceAlgebra","initialProofState":"𝕜 : Type u_2\nα : Type u_5\ninst✝⁴ : Ring 𝕜\ninst✝³ : PartialOrder α\ninst✝² : LocallyFiniteOrder α\ninst✝¹ : DecidableEq α\ninst✝ : BoundedOrder α\n⊢ Eq (IncidenceAlgebra.eulerChar 𝕜 (OrderDual α)) (IncidenceAlgebra.eulerChar 𝕜 α)","decl":"@[simp]\nlemma eulerChar_orderDual [BoundedOrder α] : eulerChar 𝕜 αᵒᵈ = eulerChar 𝕜 α := by\n  simp [eulerChar, ← mu_toDual 𝕜 (α := α)]\n\n"}
{"name":"IncidenceAlgebra.moebius_inversion_top","module":"Mathlib.Combinatorics.Enumerative.IncidenceAlgebra","initialProofState":"𝕜 : Type u_2\nα : Type u_5\ninst✝⁴ : Ring 𝕜\ninst✝³ : PartialOrder α\ninst✝² : OrderTop α\ninst✝¹ : LocallyFiniteOrder α\ninst✝ : DecidableEq α\nf g : α → 𝕜\nh : ∀ (x : α), Eq (g x) ((Finset.Ici x).sum fun y => f y)\nx : α\n⊢ Eq (f x) ((Finset.Ici x).sum fun y => HMul.hMul ((IncidenceAlgebra.mu 𝕜) x y) (g y))","decl":"/-- A general form of Möbius inversion. Based on lemma 2.1.2 of Incidence Algebras by Spiegel and\nO'Donnell. -/\nlemma moebius_inversion_top (f g : α → 𝕜) (h : ∀ x, g x = ∑ y ∈ Ici x, f y) (x : α) :\n    f x = ∑ y ∈ Ici x, mu 𝕜 x y * g y := by\n  letI : DecidableRel (α := α) (· ≤ ·) := Classical.decRel _\n  symm\n  calc\n    ∑ y ∈ Ici x, mu 𝕜 x y * g y = ∑ y ∈ Ici x, mu 𝕜 x y * ∑ z ∈ Ici y, f z := by simp_rw [h]\n    _ = ∑ y ∈ Ici x, mu 𝕜 x y * ∑ z ∈ Ici y, zeta 𝕜 y z * f z := by\n      congr with y\n      rw [sum_congr rfl fun z hz ↦ ?_]\n      rw [zeta_apply, if_pos (mem_Ici.mp ‹_›), one_mul]\n    _ = ∑ y ∈ Ici x, ∑ z ∈ Ici y, mu 𝕜 x y * zeta 𝕜 y z * f z := by simp [mul_sum]\n    _ = ∑ z ∈ Ici x, ∑ y ∈ Icc x z, mu 𝕜 x y * zeta 𝕜 y z * f z := by\n      rw [sum_sigma' (Ici x) fun y ↦ Ici y]\n      rw [sum_sigma' (Ici x) fun z ↦ Icc x z]\n      simp only [mul_boole, MulZeroClass.zero_mul, ite_mul, zeta_apply]\n      apply sum_nbij' (fun ⟨a, b⟩ ↦ ⟨b, a⟩) (fun ⟨a, b⟩ ↦ ⟨b, a⟩) <;>\n        aesop (add simp mul_assoc) (add unsafe le_trans)\n    _ = ∑ z ∈ Ici x, (mu 𝕜 * zeta 𝕜 : IncidenceAlgebra 𝕜 α) x z * f z := by\n      simp_rw [mul_apply, sum_mul]\n    _ = ∑ y ∈ Ici x, ∑ z ∈ Ici y, (1 : IncidenceAlgebra 𝕜 α) x z * f z := by\n      simp [mu_mul_zeta 𝕜, ← add_sum_Ioi_eq_sum_Ici]\n      exact sum_eq_zero fun y hy ↦ if_neg (mem_Ioi.mp hy).not_le\n    _ = f x := by\n      simp [one_apply, ← add_sum_Ioi_eq_sum_Ici]\n      exact sum_eq_zero fun y hy ↦ if_neg (mem_Ioi.mp hy).not_le\n\n"}
{"name":"IncidenceAlgebra.moebius_inversion_bot","module":"Mathlib.Combinatorics.Enumerative.IncidenceAlgebra","initialProofState":"𝕜 : Type u_2\nα : Type u_5\ninst✝⁴ : Ring 𝕜\ninst✝³ : PartialOrder α\ninst✝² : OrderBot α\ninst✝¹ : LocallyFiniteOrder α\ninst✝ : DecidableEq α\nf g : α → 𝕜\nh : ∀ (x : α), Eq (g x) ((Finset.Iic x).sum fun y => f y)\nx : α\n⊢ Eq (f x) ((Finset.Iic x).sum fun y => HMul.hMul ((IncidenceAlgebra.mu 𝕜) y x) (g y))","decl":"/-- A general form of Möbius inversion. Based on lemma 2.1.3 of Incidence Algebras by Spiegel and\nO'Donnell. -/\nlemma moebius_inversion_bot (f g : α → 𝕜) (h : ∀ x, g x = ∑ y ∈ Iic x, f y) (x : α) :\n    f x = ∑ y ∈ Iic x, mu 𝕜 y x * g y := by\n  convert moebius_inversion_top (α := αᵒᵈ) f g h x using 3; erw [mu_toDual]\n\n"}
{"name":"IncidenceAlgebra.zeta_prod_apply","module":"Mathlib.Combinatorics.Enumerative.IncidenceAlgebra","initialProofState":"𝕜 : Type u_2\nα : Type u_5\nβ : Type u_6\ninst✝⁴ : Ring 𝕜\ninst✝³ : Preorder α\ninst✝² : Preorder β\ninst✝¹ : DecidableRel fun x1 x2 => LE.le x1 x2\ninst✝ : DecidableRel fun x1 x2 => LE.le x1 x2\na b : Prod α β\n⊢ Eq ((IncidenceAlgebra.zeta 𝕜) a b) (HMul.hMul ((IncidenceAlgebra.zeta 𝕜) a.1 b.1) ((IncidenceAlgebra.zeta 𝕜) a.2 b.2))","decl":"lemma zeta_prod_apply (a b : α × β) : zeta 𝕜 a b = zeta 𝕜 a.1 b.1 * zeta 𝕜 a.2 b.2 := by\n  simp [← ite_and, Prod.le_def, and_comm]\n\n"}
{"name":"IncidenceAlgebra.zeta_prod_mk","module":"Mathlib.Combinatorics.Enumerative.IncidenceAlgebra","initialProofState":"𝕜 : Type u_2\nα : Type u_5\nβ : Type u_6\ninst✝⁴ : Ring 𝕜\ninst✝³ : Preorder α\ninst✝² : Preorder β\ninst✝¹ : DecidableRel fun x1 x2 => LE.le x1 x2\ninst✝ : DecidableRel fun x1 x2 => LE.le x1 x2\na₁ a₂ : α\nb₁ b₂ : β\n⊢ Eq ((IncidenceAlgebra.zeta 𝕜) { fst := a₁, snd := b₁ } { fst := a₂, snd := b₂ }) (HMul.hMul ((IncidenceAlgebra.zeta 𝕜) a₁ a₂) ((IncidenceAlgebra.zeta 𝕜) b₁ b₂))","decl":"lemma zeta_prod_mk (a₁ a₂ : α) (b₁ b₂ : β) :\n    zeta 𝕜 (a₁, b₁) (a₂, b₂) = zeta 𝕜 a₁ a₂ * zeta 𝕜 b₁ b₂ := zeta_prod_apply _ _ _\n\n"}
{"name":"IncidenceAlgebra.prod_mk","module":"Mathlib.Combinatorics.Enumerative.IncidenceAlgebra","initialProofState":"𝕜 : Type u_2\nα : Type u_5\nβ : Type u_6\ninst✝² : Ring 𝕜\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : IncidenceAlgebra 𝕜 α\ng : IncidenceAlgebra 𝕜 β\na₁ a₂ : α\nb₁ b₂ : β\n⊢ Eq ((f.prod g) { fst := a₁, snd := b₁ } { fst := a₂, snd := b₂ }) (HMul.hMul (f a₁ a₂) (g b₁ b₂))","decl":"lemma prod_mk (a₁ a₂ : α) (b₁ b₂ : β) : f.prod g (a₁, b₁) (a₂, b₂) = f a₁ a₂ * g b₁ b₂ := rfl\n"}
{"name":"IncidenceAlgebra.prod_apply","module":"Mathlib.Combinatorics.Enumerative.IncidenceAlgebra","initialProofState":"𝕜 : Type u_2\nα : Type u_5\nβ : Type u_6\ninst✝² : Ring 𝕜\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : IncidenceAlgebra 𝕜 α\ng : IncidenceAlgebra 𝕜 β\nx y : Prod α β\n⊢ Eq ((f.prod g) x y) (HMul.hMul (f x.1 y.1) (g x.2 y.2))","decl":"@[simp] lemma prod_apply (x y : α × β) : f.prod g x y = f x.1 y.1 * g x.2 y.2 := rfl\n\n"}
{"name":"IncidenceAlgebra.prod_mul_prod'","module":"Mathlib.Combinatorics.Enumerative.IncidenceAlgebra","initialProofState":"𝕜 : Type u_2\nα : Type u_5\nβ : Type u_6\ninst✝⁵ : Ring 𝕜\ninst✝⁴ : Preorder α\ninst✝³ : Preorder β\nf₁ f₂ : IncidenceAlgebra 𝕜 α\ng₁ g₂ : IncidenceAlgebra 𝕜 β\ninst✝² : LocallyFiniteOrder α\ninst✝¹ : LocallyFiniteOrder β\ninst✝ : DecidableRel fun x1 x2 => LE.le x1 x2\nh : ∀ (a₁ a₂ a₃ : α) (b₁ b₂ b₃ : β), Eq (HMul.hMul (HMul.hMul (f₁ a₁ a₂) (g₁ b₁ b₂)) (HMul.hMul (f₂ a₂ a₃) (g₂ b₂ b₃))) (HMul.hMul (HMul.hMul (f₁ a₁ a₂) (f₂ a₂ a₃)) (HMul.hMul (g₁ b₁ b₂) (g₂ b₂ b₃)))\n⊢ Eq (HMul.hMul (f₁.prod g₁) (f₂.prod g₂)) ((HMul.hMul f₁ f₂).prod (HMul.hMul g₁ g₂))","decl":"/-- This is a version of `IncidenceAlgebra.prod_mul_prod` that works over non-commutative rings. -/\nlemma prod_mul_prod' [LocallyFiniteOrder α] [LocallyFiniteOrder β]\n    [DecidableRel (α := α × β) (· ≤ ·)]\n    (h : ∀ a₁ a₂ a₃ b₁ b₂ b₃,\n        f₁ a₁ a₂ * g₁ b₁ b₂ * (f₂ a₂ a₃ * g₂ b₂ b₃) = f₁ a₁ a₂ * f₂ a₂ a₃ * (g₁ b₁ b₂ * g₂ b₂ b₃)) :\n    f₁.prod g₁ * f₂.prod g₂ = (f₁ * f₂).prod (g₁ * g₂) := by\n  ext x y; simp [Icc_prod_def, sum_mul_sum, h, sum_product]\n\n"}
{"name":"IncidenceAlgebra.one_prod_one","module":"Mathlib.Combinatorics.Enumerative.IncidenceAlgebra","initialProofState":"𝕜 : Type u_2\nα : Type u_5\nβ : Type u_6\ninst✝⁴ : Ring 𝕜\ninst✝³ : Preorder α\ninst✝² : Preorder β\ninst✝¹ : DecidableEq α\ninst✝ : DecidableEq β\n⊢ Eq (IncidenceAlgebra.prod 1 1) 1","decl":"@[simp]\nlemma one_prod_one [DecidableEq α] [DecidableEq β] :\n    (.prod 1 1 : IncidenceAlgebra 𝕜 (α × β)) = 1 := by\n  ext x y; simp [Prod.ext_iff, ← ite_and, and_comm]\n\n"}
{"name":"IncidenceAlgebra.zeta_prod_zeta","module":"Mathlib.Combinatorics.Enumerative.IncidenceAlgebra","initialProofState":"𝕜 : Type u_2\nα : Type u_5\nβ : Type u_6\ninst✝⁴ : Ring 𝕜\ninst✝³ : Preorder α\ninst✝² : Preorder β\ninst✝¹ : DecidableRel fun x1 x2 => LE.le x1 x2\ninst✝ : DecidableRel fun x1 x2 => LE.le x1 x2\n⊢ Eq ((IncidenceAlgebra.zeta 𝕜).prod (IncidenceAlgebra.zeta 𝕜)) (IncidenceAlgebra.zeta 𝕜)","decl":"@[simp]\nlemma zeta_prod_zeta [DecidableRel (α := α) (· ≤ ·)] [DecidableRel (α := β) (· ≤ ·)] :\n    (zeta 𝕜).prod (zeta 𝕜) = (zeta 𝕜 : IncidenceAlgebra 𝕜 (α × β)) := by\n  ext x y hxy; simp [hxy, hxy.1, hxy.2]\n\n"}
{"name":"IncidenceAlgebra.prod_mul_prod","module":"Mathlib.Combinatorics.Enumerative.IncidenceAlgebra","initialProofState":"𝕜 : Type u_2\nα : Type u_5\nβ : Type u_6\ninst✝⁵ : CommRing 𝕜\ninst✝⁴ : Preorder α\ninst✝³ : Preorder β\ninst✝² : LocallyFiniteOrder α\ninst✝¹ : LocallyFiniteOrder β\ninst✝ : DecidableRel fun x1 x2 => LE.le x1 x2\nf₁ f₂ : IncidenceAlgebra 𝕜 α\ng₁ g₂ : IncidenceAlgebra 𝕜 β\n⊢ Eq (HMul.hMul (f₁.prod g₁) (f₂.prod g₂)) ((HMul.hMul f₁ f₂).prod (HMul.hMul g₁ g₂))","decl":"@[simp]\nlemma prod_mul_prod : f₁.prod g₁ * f₂.prod g₂ = (f₁ * f₂).prod (g₁ * g₂) :=\n  prod_mul_prod' _ _ _ _ fun _ _ _ _ _ _ ↦ mul_mul_mul_comm ..\n\n"}
{"name":"IncidenceAlgebra.mu_prod_mu","module":"Mathlib.Combinatorics.Enumerative.IncidenceAlgebra","initialProofState":"𝕜 : Type u_2\nα : Type u_5\nβ : Type u_6\ninst✝⁸ : Ring 𝕜\ninst✝⁷ : PartialOrder α\ninst✝⁶ : PartialOrder β\ninst✝⁵ : LocallyFiniteOrder α\ninst✝⁴ : LocallyFiniteOrder β\ninst✝³ : DecidableEq α\ninst✝² : DecidableEq β\ninst✝¹ : DecidableRel fun x1 x2 => LE.le x1 x2\ninst✝ : DecidableRel fun x1 x2 => LE.le x1 x2\n⊢ Eq ((IncidenceAlgebra.mu 𝕜).prod (IncidenceAlgebra.mu 𝕜)) (IncidenceAlgebra.mu 𝕜)","decl":"/-- The Möbius function on a product order. Based on lemma 2.1.13 of Incidence Algebras by Spiegel\nand O'Donnell. -/\n@[simp]\nlemma mu_prod_mu : (mu 𝕜).prod (mu 𝕜) = (mu 𝕜 : IncidenceAlgebra 𝕜 (α × β)) := by\n  refine left_inv_eq_right_inv ?_ zeta_mul_mu\n  rw [← zeta_prod_zeta, prod_mul_prod', mu_mul_zeta, mu_mul_zeta, one_prod_one]\n  exact fun _ _ _ _ _ _ ↦ Commute.mul_mul_mul_comm (by simp : _ = _) _ _\n\n"}
{"name":"IncidenceAlgebra.eulerChar_prod","module":"Mathlib.Combinatorics.Enumerative.IncidenceAlgebra","initialProofState":"𝕜 : Type u_2\nα : Type u_5\nβ : Type u_6\ninst✝¹⁰ : Ring 𝕜\ninst✝⁹ : PartialOrder α\ninst✝⁸ : PartialOrder β\ninst✝⁷ : LocallyFiniteOrder α\ninst✝⁶ : LocallyFiniteOrder β\ninst✝⁵ : DecidableEq α\ninst✝⁴ : DecidableEq β\ninst✝³ : DecidableRel fun x1 x2 => LE.le x1 x2\ninst✝² : DecidableRel fun x1 x2 => LE.le x1 x2\ninst✝¹ : BoundedOrder α\ninst✝ : BoundedOrder β\n⊢ Eq (IncidenceAlgebra.eulerChar 𝕜 (Prod α β)) (HMul.hMul (IncidenceAlgebra.eulerChar 𝕜 α) (IncidenceAlgebra.eulerChar 𝕜 β))","decl":"@[simp]\nlemma eulerChar_prod [BoundedOrder α] [BoundedOrder β] :\n    eulerChar 𝕜 (α × β) = eulerChar 𝕜 α * eulerChar 𝕜 β := by simp [eulerChar, ← mu_prod_mu]\n\n"}
