{"name":"AddMonoid.End.natCast_def","module":"Mathlib.Algebra.Module.End","initialProofState":"M : Type u_3\ninst✝ : AddCommMonoid M\nn : Nat\n⊢ Eq (↑n) ((DistribMulAction.toAddMonoidEnd Nat M) n)","decl":"theorem AddMonoid.End.natCast_def (n : ℕ) :\n    (↑n : AddMonoid.End M) = DistribMulAction.toAddMonoidEnd ℕ M n :=\n  rfl\n\n"}
{"name":"Module.toAddMonoidEnd_apply_apply","module":"Mathlib.Algebra.Module.End","initialProofState":"R : Type u_1\nM : Type u_3\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nx : R\nx✝ : M\n⊢ Eq (((Module.toAddMonoidEnd R M) x) x✝) (HSMul.hSMul x x✝)","decl":"/-- `(•)` as an `AddMonoidHom`.\n\nThis is a stronger version of `DistribMulAction.toAddMonoidEnd` -/\n@[simps! apply_apply]\ndef Module.toAddMonoidEnd : R →+* AddMonoid.End M :=\n  { DistribMulAction.toAddMonoidEnd R M with\n    -- Porting note: the two `show`s weren't needed in mathlib3.\n    -- Somehow, now that `SMul` is heterogeneous, it can't unfold earlier fields of a definition for\n    -- use in later fields.  See\n    -- https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Heterogeneous.20scalar.20multiplication\n    map_zero' := AddMonoidHom.ext fun r => show (0 : R) • r = 0 by simp\n    map_add' := fun x y =>\n      AddMonoidHom.ext fun r => show (x + y) • r = x • r + y • r by simp [add_smul] }\n\n"}
{"name":"smulAddHom_apply","module":"Mathlib.Algebra.Module.End","initialProofState":"R : Type u_1\nM : Type u_3\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nr : R\nx : M\n⊢ Eq (((smulAddHom R M) r) x) (HSMul.hSMul r x)","decl":"@[simp]\ntheorem smulAddHom_apply : smulAddHom R M r x = r • x :=\n  rfl\n\n"}
{"name":"IsAddUnit.smul_left","module":"Mathlib.Algebra.Module.End","initialProofState":"S : Type u_2\nM : Type u_3\ninst✝² : AddCommMonoid M\nx : M\ninst✝¹ : Monoid S\ninst✝ : DistribMulAction S M\nhx : IsAddUnit x\ns : S\n⊢ IsAddUnit (HSMul.hSMul s x)","decl":"lemma IsAddUnit.smul_left [Monoid S] [DistribMulAction S M] (hx : IsAddUnit x) (s : S) :\n    IsAddUnit (s • x) :=\n  hx.map (DistribMulAction.toAddMonoidHom M s)\n\n"}
{"name":"IsAddUnit.smul_right","module":"Mathlib.Algebra.Module.End","initialProofState":"R : Type u_1\nM : Type u_3\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nr : R\nx : M\nhr : IsAddUnit r\n⊢ IsAddUnit (HSMul.hSMul r x)","decl":"lemma IsAddUnit.smul_right (hr : IsAddUnit r) : IsAddUnit (r • x) :=\n  hr.map (AddMonoidHom.flip (smulAddHom R M) x)\n\n"}
{"name":"AddMonoid.End.intCast_def","module":"Mathlib.Algebra.Module.End","initialProofState":"M : Type u_3\ninst✝ : AddCommGroup M\nz : Int\n⊢ Eq (↑z) ((DistribMulAction.toAddMonoidEnd Int M) z)","decl":"theorem AddMonoid.End.intCast_def (z : ℤ) :\n    (↑z : AddMonoid.End M) = DistribMulAction.toAddMonoidEnd ℤ M z :=\n  rfl\n\n"}
{"name":"Int.cast_smul_eq_zsmul","module":"Mathlib.Algebra.Module.End","initialProofState":"R : Type u_1\nM : Type u_3\ninst✝² : Ring R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nn : Int\nb : M\n⊢ Eq (HSMul.hSMul (↑n) b) (HSMul.hSMul n b)","decl":"/-- `zsmul` is equal to any other module structure via a cast. -/\n@[norm_cast]\nlemma Int.cast_smul_eq_zsmul (n : ℤ) (b : M) : (n : R) • b = n • b :=\n  have : ((smulAddHom R M).flip b).comp (Int.castAddHom R) = (smulAddHom ℤ M).flip b := by\n    apply AddMonoidHom.ext_int\n    simp\n  DFunLike.congr_fun this n\n\n"}
{"name":"int_smul_eq_zsmul","module":"Mathlib.Algebra.Module.End","initialProofState":"M : Type u_3\ninst✝ : AddCommGroup M\nh : Module Int M\nn : Int\nx : M\n⊢ Eq (SMul.smul n x) (HSMul.hSMul n x)","decl":"/-- Convert back any exotic `ℤ`-smul to the canonical instance. This should not be needed since in\nmathlib all `AddCommGroup`s should normally have exactly one `ℤ`-module structure by design. -/\ntheorem int_smul_eq_zsmul (h : Module ℤ M) (n : ℤ) (x : M) : @SMul.smul ℤ M h.toSMul n x = n • x :=\n  Int.cast_smul_eq_zsmul ..\n\n"}
{"name":"map_intCast_smul","module":"Mathlib.Algebra.Module.End","initialProofState":"M : Type u_3\nM₂ : Type u_4\ninst✝⁷ : AddCommGroup M\ninst✝⁶ : AddCommGroup M₂\nF : Type u_5\ninst✝⁵ : FunLike F M M₂\ninst✝⁴ : AddMonoidHomClass F M M₂\nf : F\nR : Type u_6\nS : Type u_7\ninst✝³ : Ring R\ninst✝² : Ring S\ninst✝¹ : Module R M\ninst✝ : Module S M₂\nx : Int\na : M\n⊢ Eq (f (HSMul.hSMul (↑x) a)) (HSMul.hSMul (↑x) (f a))","decl":"theorem map_intCast_smul [AddCommGroup M] [AddCommGroup M₂] {F : Type*} [FunLike F M M₂]\n    [AddMonoidHomClass F M M₂] (f : F) (R S : Type*) [Ring R] [Ring S] [Module R M] [Module S M₂]\n    (x : ℤ) (a : M) :\n    f ((x : R) • a) = (x : S) • f a := by simp only [Int.cast_smul_eq_zsmul, map_zsmul]\n\n"}
{"name":"AddCommGroup.intIsScalarTower","module":"Mathlib.Algebra.Module.End","initialProofState":"R : Type u\nM : Type v\ninst✝² : Ring R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\n⊢ IsScalarTower Int R M","decl":"instance AddCommGroup.intIsScalarTower {R : Type u} {M : Type v} [Ring R] [AddCommGroup M]\n    [Module R M] : IsScalarTower ℤ R M where\n  smul_assoc n x y := ((smulAddHom R M).flip y).map_zsmul x n\n"}
