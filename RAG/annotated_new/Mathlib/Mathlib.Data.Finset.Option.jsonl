{"name":"Option.toFinset_none","module":"Mathlib.Data.Finset.Option","initialProofState":"α : Type u_1\n⊢ Eq Option.none.toFinset EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem toFinset_none : none.toFinset = (∅ : Finset α) :=\n  rfl\n\n"}
{"name":"Option.toFinset_some","module":"Mathlib.Data.Finset.Option","initialProofState":"α : Type u_1\na : α\n⊢ Eq (Option.some a).toFinset (Singleton.singleton a)","decl":"@[simp]\ntheorem toFinset_some {a : α} : (some a).toFinset = {a} :=\n  rfl\n\n"}
{"name":"Option.mem_toFinset","module":"Mathlib.Data.Finset.Option","initialProofState":"α : Type u_1\na : α\no : Option α\n⊢ Iff (Membership.mem o.toFinset a) (Membership.mem o a)","decl":"@[simp]\ntheorem mem_toFinset {a : α} {o : Option α} : a ∈ o.toFinset ↔ a ∈ o := by\n  cases o <;> simp [eq_comm]\n\n"}
{"name":"Option.card_toFinset","module":"Mathlib.Data.Finset.Option","initialProofState":"α : Type u_1\no : Option α\n⊢ Eq o.toFinset.card (o.elim 0 1)","decl":"theorem card_toFinset (o : Option α) : o.toFinset.card = o.elim 0 1 := by cases o <;> rfl\n\n"}
{"name":"Finset.mem_insertNone","module":"Mathlib.Data.Finset.Option","initialProofState":"α : Type u_1\ns : Finset α\no : Option α\n⊢ Iff (Membership.mem (Finset.insertNone s) o) (∀ (a : α), Membership.mem o a → Membership.mem s a)","decl":"@[simp]\ntheorem mem_insertNone {s : Finset α} : ∀ {o : Option α}, o ∈ insertNone s ↔ ∀ a ∈ o, a ∈ s\n  | none => iff_of_true (Multiset.mem_cons_self _ _) fun a h => by cases h\n  | some a => Multiset.mem_cons.trans <| by simp\n\n"}
{"name":"Finset.forall_mem_insertNone","module":"Mathlib.Data.Finset.Option","initialProofState":"α : Type u_1\ns : Finset α\np : Option α → Prop\n⊢ Iff (∀ (a : Option α), Membership.mem (Finset.insertNone s) a → p a) (And (p Option.none) (∀ (a : α), Membership.mem s a → p (Option.some a)))","decl":"lemma forall_mem_insertNone {s : Finset α} {p : Option α → Prop} :\n    (∀ a ∈ insertNone s, p a) ↔ p none ∧ ∀ a ∈ s, p a := by simp [Option.forall]\n\n"}
{"name":"Finset.some_mem_insertNone","module":"Mathlib.Data.Finset.Option","initialProofState":"α : Type u_1\ns : Finset α\na : α\n⊢ Iff (Membership.mem (Finset.insertNone s) (Option.some a)) (Membership.mem s a)","decl":"theorem some_mem_insertNone {s : Finset α} {a : α} : some a ∈ insertNone s ↔ a ∈ s := by simp\n\n"}
{"name":"Finset.none_mem_insertNone","module":"Mathlib.Data.Finset.Option","initialProofState":"α : Type u_1\ns : Finset α\n⊢ Membership.mem (Finset.insertNone s) Option.none","decl":"lemma none_mem_insertNone {s : Finset α} : none ∈ insertNone s := by simp\n\n"}
{"name":"Finset.insertNone_nonempty","module":"Mathlib.Data.Finset.Option","initialProofState":"α : Type u_1\ns : Finset α\n⊢ (Finset.insertNone s).Nonempty","decl":"@[aesop safe apply (rule_sets := [finsetNonempty])]\nlemma insertNone_nonempty {s : Finset α} : insertNone s |>.Nonempty := ⟨none, none_mem_insertNone⟩\n\n"}
{"name":"Finset.card_insertNone","module":"Mathlib.Data.Finset.Option","initialProofState":"α : Type u_1\ns : Finset α\n⊢ Eq (Finset.insertNone s).card (HAdd.hAdd s.card 1)","decl":"@[simp]\ntheorem card_insertNone (s : Finset α) : s.insertNone.card = s.card + 1 := by simp [insertNone]\n\n"}
{"name":"Finset.mem_eraseNone","module":"Mathlib.Data.Finset.Option","initialProofState":"α : Type u_1\ns : Finset (Option α)\nx : α\n⊢ Iff (Membership.mem (Finset.eraseNone s) x) (Membership.mem s (Option.some x))","decl":"@[simp]\ntheorem mem_eraseNone {s : Finset (Option α)} {x : α} : x ∈ eraseNone s ↔ some x ∈ s := by\n  simp [eraseNone]\n\n"}
{"name":"Finset.forall_mem_eraseNone","module":"Mathlib.Data.Finset.Option","initialProofState":"α : Type u_1\ns : Finset (Option α)\np : Option α → Prop\n⊢ Iff (∀ (a : α), Membership.mem (Finset.eraseNone s) a → p (Option.some a)) (∀ (a : α), Membership.mem s (Option.some a) → p (Option.some a))","decl":"lemma forall_mem_eraseNone {s : Finset (Option α)} {p : Option α → Prop} :\n    (∀ a ∈ eraseNone s, p a) ↔ ∀ a : α, (a : Option α) ∈ s → p a := by simp [Option.forall]\n\n"}
{"name":"Finset.eraseNone_eq_biUnion","module":"Mathlib.Data.Finset.Option","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : Finset (Option α)\n⊢ Eq (Finset.eraseNone s) (s.biUnion Option.toFinset)","decl":"theorem eraseNone_eq_biUnion [DecidableEq α] (s : Finset (Option α)) :\n    eraseNone s = s.biUnion Option.toFinset := by\n  ext\n  simp\n\n"}
{"name":"Finset.eraseNone_map_some","module":"Mathlib.Data.Finset.Option","initialProofState":"α : Type u_1\ns : Finset α\n⊢ Eq (Finset.eraseNone (Finset.map Function.Embedding.some s)) s","decl":"@[simp]\ntheorem eraseNone_map_some (s : Finset α) : eraseNone (s.map Embedding.some) = s := by\n  ext\n  simp\n\n"}
{"name":"Finset.eraseNone_image_some","module":"Mathlib.Data.Finset.Option","initialProofState":"α : Type u_1\ninst✝ : DecidableEq (Option α)\ns : Finset α\n⊢ Eq (Finset.eraseNone (Finset.image Option.some s)) s","decl":"@[simp]\ntheorem eraseNone_image_some [DecidableEq (Option α)] (s : Finset α) :\n    eraseNone (s.image some) = s := by simpa only [map_eq_image] using eraseNone_map_some s\n\n"}
{"name":"Finset.coe_eraseNone","module":"Mathlib.Data.Finset.Option","initialProofState":"α : Type u_1\ns : Finset (Option α)\n⊢ Eq (↑(Finset.eraseNone s)) (Set.preimage Option.some ↑s)","decl":"@[simp]\ntheorem coe_eraseNone (s : Finset (Option α)) : (eraseNone s : Set α) = some ⁻¹' s :=\n  Set.ext fun _ => mem_eraseNone\n\n"}
{"name":"Finset.eraseNone_union","module":"Mathlib.Data.Finset.Option","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq (Option α)\ninst✝ : DecidableEq α\ns t : Finset (Option α)\n⊢ Eq (Finset.eraseNone (Union.union s t)) (Union.union (Finset.eraseNone s) (Finset.eraseNone t))","decl":"@[simp]\ntheorem eraseNone_union [DecidableEq (Option α)] [DecidableEq α] (s t : Finset (Option α)) :\n    eraseNone (s ∪ t) = eraseNone s ∪ eraseNone t := by\n  ext\n  simp\n\n"}
{"name":"Finset.eraseNone_inter","module":"Mathlib.Data.Finset.Option","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq (Option α)\ninst✝ : DecidableEq α\ns t : Finset (Option α)\n⊢ Eq (Finset.eraseNone (Inter.inter s t)) (Inter.inter (Finset.eraseNone s) (Finset.eraseNone t))","decl":"@[simp]\ntheorem eraseNone_inter [DecidableEq (Option α)] [DecidableEq α] (s t : Finset (Option α)) :\n    eraseNone (s ∩ t) = eraseNone s ∩ eraseNone t := by\n  ext\n  simp\n\n"}
{"name":"Finset.eraseNone_empty","module":"Mathlib.Data.Finset.Option","initialProofState":"α : Type u_1\n⊢ Eq (Finset.eraseNone EmptyCollection.emptyCollection) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem eraseNone_empty : eraseNone (∅ : Finset (Option α)) = ∅ := by\n  ext\n  simp\n\n"}
{"name":"Finset.eraseNone_none","module":"Mathlib.Data.Finset.Option","initialProofState":"α : Type u_1\n⊢ Eq (Finset.eraseNone (Singleton.singleton Option.none)) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem eraseNone_none : eraseNone ({none} : Finset (Option α)) = ∅ := by\n  ext\n  simp\n\n"}
{"name":"Finset.image_some_eraseNone","module":"Mathlib.Data.Finset.Option","initialProofState":"α : Type u_1\ninst✝ : DecidableEq (Option α)\ns : Finset (Option α)\n⊢ Eq (Finset.image Option.some (Finset.eraseNone s)) (s.erase Option.none)","decl":"@[simp]\ntheorem image_some_eraseNone [DecidableEq (Option α)] (s : Finset (Option α)) :\n    (eraseNone s).image some = s.erase none := by ext (_ | x) <;> simp\n\n"}
{"name":"Finset.map_some_eraseNone","module":"Mathlib.Data.Finset.Option","initialProofState":"α : Type u_1\ninst✝ : DecidableEq (Option α)\ns : Finset (Option α)\n⊢ Eq (Finset.map Function.Embedding.some (Finset.eraseNone s)) (s.erase Option.none)","decl":"@[simp]\ntheorem map_some_eraseNone [DecidableEq (Option α)] (s : Finset (Option α)) :\n    (eraseNone s).map Embedding.some = s.erase none := by\n  rw [map_eq_image, Embedding.some_apply, image_some_eraseNone]\n\n"}
{"name":"Finset.insertNone_eraseNone","module":"Mathlib.Data.Finset.Option","initialProofState":"α : Type u_1\ninst✝ : DecidableEq (Option α)\ns : Finset (Option α)\n⊢ Eq (Finset.insertNone (Finset.eraseNone s)) (Insert.insert Option.none s)","decl":"@[simp]\ntheorem insertNone_eraseNone [DecidableEq (Option α)] (s : Finset (Option α)) :\n    insertNone (eraseNone s) = insert none s := by ext (_ | x) <;> simp\n\n"}
{"name":"Finset.eraseNone_insertNone","module":"Mathlib.Data.Finset.Option","initialProofState":"α : Type u_1\ns : Finset α\n⊢ Eq (Finset.eraseNone (Finset.insertNone s)) s","decl":"@[simp]\ntheorem eraseNone_insertNone (s : Finset α) : eraseNone (insertNone s) = s := by\n  ext\n  simp\n\n"}
