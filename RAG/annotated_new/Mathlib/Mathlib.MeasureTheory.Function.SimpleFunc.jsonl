{"name":"MeasureTheory.SimpleFunc.mk.sizeOf_spec","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u\ninst✝² : MeasurableSpace α\nβ : Type v\ninst✝¹ : SizeOf α\ninst✝ : SizeOf β\ntoFun : α → β\nmeasurableSet_fiber' : ∀ (x : β), MeasurableSet (Set.preimage toFun (Singleton.singleton x))\nfinite_range' : (Set.range toFun).Finite\n⊢ Eq (SizeOf.sizeOf { toFun := toFun, measurableSet_fiber' := measurableSet_fiber', finite_range' := finite_range' }) (HAdd.hAdd 1 (SizeOf.sizeOf finite_range'))","decl":"/-- A function `f` from a measurable space to any type is called *simple*,\nif every preimage `f ⁻¹' {x}` is measurable, and the range is finite. This structure bundles\na function with these properties. -/\nstructure SimpleFunc.{u, v} (α : Type u) [MeasurableSpace α] (β : Type v) where\n  toFun : α → β\n  measurableSet_fiber' : ∀ x, MeasurableSet (toFun ⁻¹' {x})\n  finite_range' : (Set.range toFun).Finite\n\n"}
{"name":"MeasureTheory.SimpleFunc.mk.injEq","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u\ninst✝ : MeasurableSpace α\nβ : Type v\ntoFun✝ : α → β\nmeasurableSet_fiber'✝ : ∀ (x : β), MeasurableSet (Set.preimage toFun✝ (Singleton.singleton x))\nfinite_range'✝ : (Set.range toFun✝).Finite\ntoFun : α → β\nmeasurableSet_fiber' : ∀ (x : β), MeasurableSet (Set.preimage toFun (Singleton.singleton x))\nfinite_range' : (Set.range toFun).Finite\n⊢ Eq (Eq { toFun := toFun✝, measurableSet_fiber' := measurableSet_fiber'✝, finite_range' := finite_range'✝ } { toFun := toFun, measurableSet_fiber' := measurableSet_fiber', finite_range' := finite_range' }) (Eq toFun✝ toFun)","decl":"/-- A function `f` from a measurable space to any type is called *simple*,\nif every preimage `f ⁻¹' {x}` is measurable, and the range is finite. This structure bundles\na function with these properties. -/\nstructure SimpleFunc.{u, v} (α : Type u) [MeasurableSpace α] (β : Type v) where\n  toFun : α → β\n  measurableSet_fiber' : ∀ x, MeasurableSet (toFun ⁻¹' {x})\n  finite_range' : (Set.range toFun).Finite\n\n"}
{"name":"MeasureTheory.SimpleFunc.finite_range'","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u\ninst✝ : MeasurableSpace α\nβ : Type v\nself : MeasureTheory.SimpleFunc α β\n⊢ (Set.range self.toFun).Finite","decl":"/-- A function `f` from a measurable space to any type is called *simple*,\nif every preimage `f ⁻¹' {x}` is measurable, and the range is finite. This structure bundles\na function with these properties. -/\nstructure SimpleFunc.{u, v} (α : Type u) [MeasurableSpace α] (β : Type v) where\n  toFun : α → β\n  measurableSet_fiber' : ∀ x, MeasurableSet (toFun ⁻¹' {x})\n  finite_range' : (Set.range toFun).Finite\n\n"}
{"name":"MeasureTheory.SimpleFunc.measurableSet_fiber'","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u\ninst✝ : MeasurableSpace α\nβ : Type v\nself : MeasureTheory.SimpleFunc α β\nx : β\n⊢ MeasurableSet (Set.preimage self.toFun (Singleton.singleton x))","decl":"/-- A function `f` from a measurable space to any type is called *simple*,\nif every preimage `f ⁻¹' {x}` is measurable, and the range is finite. This structure bundles\na function with these properties. -/\nstructure SimpleFunc.{u, v} (α : Type u) [MeasurableSpace α] (β : Type v) where\n  toFun : α → β\n  measurableSet_fiber' : ∀ x, MeasurableSet (toFun ⁻¹' {x})\n  finite_range' : (Set.range toFun).Finite\n\n"}
{"name":"MeasureTheory.SimpleFunc.mk.inj","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u\ninst✝ : MeasurableSpace α\nβ : Type v\ntoFun✝ : α → β\nmeasurableSet_fiber'✝ : ∀ (x : β), MeasurableSet (Set.preimage toFun✝ (Singleton.singleton x))\nfinite_range'✝ : (Set.range toFun✝).Finite\ntoFun : α → β\nmeasurableSet_fiber' : ∀ (x : β), MeasurableSet (Set.preimage toFun (Singleton.singleton x))\nfinite_range' : (Set.range toFun).Finite\nx✝ : Eq { toFun := toFun✝, measurableSet_fiber' := measurableSet_fiber'✝, finite_range' := finite_range'✝ } { toFun := toFun, measurableSet_fiber' := measurableSet_fiber', finite_range' := finite_range' }\n⊢ Eq toFun✝ toFun","decl":"/-- A function `f` from a measurable space to any type is called *simple*,\nif every preimage `f ⁻¹' {x}` is measurable, and the range is finite. This structure bundles\na function with these properties. -/\nstructure SimpleFunc.{u, v} (α : Type u) [MeasurableSpace α] (β : Type v) where\n  toFun : α → β\n  measurableSet_fiber' : ∀ x, MeasurableSet (toFun ⁻¹' {x})\n  finite_range' : (Set.range toFun).Finite\n\n"}
{"name":"MeasureTheory.SimpleFunc.coe_injective","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : MeasurableSpace α\nf g : MeasureTheory.SimpleFunc α β\nH : Eq ⇑f ⇑g\n⊢ Eq f g","decl":"theorem coe_injective ⦃f g : α →ₛ β⦄ (H : (f : α → β) = g) : f = g := DFunLike.ext' H\n\n"}
{"name":"MeasureTheory.SimpleFunc.ext_iff","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : MeasurableSpace α\nf g : MeasureTheory.SimpleFunc α β\n⊢ Iff (Eq f g) (∀ (a : α), Eq (f a) (g a))","decl":"@[ext]\ntheorem ext {f g : α →ₛ β} (H : ∀ a, f a = g a) : f = g := DFunLike.ext _ _ H\n\n"}
{"name":"MeasureTheory.SimpleFunc.ext","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : MeasurableSpace α\nf g : MeasureTheory.SimpleFunc α β\nH : ∀ (a : α), Eq (f a) (g a)\n⊢ Eq f g","decl":"@[ext]\ntheorem ext {f g : α →ₛ β} (H : ∀ a, f a = g a) : f = g := DFunLike.ext _ _ H\n\n"}
{"name":"MeasureTheory.SimpleFunc.finite_range","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : MeasurableSpace α\nf : MeasureTheory.SimpleFunc α β\n⊢ (Set.range ⇑f).Finite","decl":"theorem finite_range (f : α →ₛ β) : (Set.range f).Finite :=\n  f.finite_range'\n\n"}
{"name":"MeasureTheory.SimpleFunc.measurableSet_fiber","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : MeasurableSpace α\nf : MeasureTheory.SimpleFunc α β\nx : β\n⊢ MeasurableSet (Set.preimage (⇑f) (Singleton.singleton x))","decl":"theorem measurableSet_fiber (f : α →ₛ β) (x : β) : MeasurableSet (f ⁻¹' {x}) :=\n  f.measurableSet_fiber' x\n\n"}
{"name":"MeasureTheory.SimpleFunc.coe_mk","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : MeasurableSpace α\nf : α → β\nh : ∀ (x : β), MeasurableSet (Set.preimage f (Singleton.singleton x))\nh' : (Set.range f).Finite\n⊢ Eq (⇑{ toFun := f, measurableSet_fiber' := h, finite_range' := h' }) f","decl":"@[simp] theorem coe_mk (f : α → β) (h h') : ⇑(mk f h h') = f := rfl\n\n"}
{"name":"MeasureTheory.SimpleFunc.apply_mk","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : MeasurableSpace α\nf : α → β\nh : ∀ (x : β), MeasurableSet (Set.preimage f (Singleton.singleton x))\nh' : (Set.range f).Finite\nx : α\n⊢ Eq ({ toFun := f, measurableSet_fiber' := h, finite_range' := h' } x) (f x)","decl":"theorem apply_mk (f : α → β) (h h') (x : α) : SimpleFunc.mk f h h' x = f x :=\n  rfl\n\n"}
{"name":"MeasureTheory.SimpleFunc.mem_range","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : MeasurableSpace α\nf : MeasureTheory.SimpleFunc α β\nb : β\n⊢ Iff (Membership.mem f.range b) (Membership.mem (Set.range ⇑f) b)","decl":"@[simp]\ntheorem mem_range {f : α →ₛ β} {b} : b ∈ f.range ↔ b ∈ range f :=\n  Finite.mem_toFinset _\n\n"}
{"name":"MeasureTheory.SimpleFunc.mem_range_self","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : MeasurableSpace α\nf : MeasureTheory.SimpleFunc α β\nx : α\n⊢ Membership.mem f.range (f x)","decl":"theorem mem_range_self (f : α →ₛ β) (x : α) : f x ∈ f.range :=\n  mem_range.2 ⟨x, rfl⟩\n\n"}
{"name":"MeasureTheory.SimpleFunc.coe_range","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : MeasurableSpace α\nf : MeasureTheory.SimpleFunc α β\n⊢ Eq (↑f.range) (Set.range ⇑f)","decl":"@[simp]\ntheorem coe_range (f : α →ₛ β) : (↑f.range : Set β) = Set.range f :=\n  f.finite_range.coe_toFinset\n\n"}
{"name":"MeasureTheory.SimpleFunc.mem_range_of_measure_ne_zero","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : MeasurableSpace α\nf : MeasureTheory.SimpleFunc α β\nx : β\nμ : MeasureTheory.Measure α\nH : Ne (μ (Set.preimage (⇑f) (Singleton.singleton x))) 0\n⊢ Membership.mem f.range x","decl":"theorem mem_range_of_measure_ne_zero {f : α →ₛ β} {x : β} {μ : Measure α} (H : μ (f ⁻¹' {x}) ≠ 0) :\n    x ∈ f.range :=\n  let ⟨a, ha⟩ := nonempty_of_measure_ne_zero H\n  mem_range.2 ⟨a, ha⟩\n\n"}
{"name":"MeasureTheory.SimpleFunc.forall_mem_range","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : MeasurableSpace α\nf : MeasureTheory.SimpleFunc α β\np : β → Prop\n⊢ Iff (∀ (y : β), Membership.mem f.range y → p y) (∀ (x : α), p (f x))","decl":"theorem forall_mem_range {f : α →ₛ β} {p : β → Prop} : (∀ y ∈ f.range, p y) ↔ ∀ x, p (f x) := by\n  simp only [mem_range, Set.forall_mem_range]\n\n"}
{"name":"MeasureTheory.SimpleFunc.exists_range_iff","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : MeasurableSpace α\nf : MeasureTheory.SimpleFunc α β\np : β → Prop\n⊢ Iff (Exists fun y => And (Membership.mem f.range y) (p y)) (Exists fun x => p (f x))","decl":"theorem exists_range_iff {f : α →ₛ β} {p : β → Prop} : (∃ y ∈ f.range, p y) ↔ ∃ x, p (f x) := by\n  simpa only [mem_range, exists_prop] using Set.exists_range_iff\n\n"}
{"name":"MeasureTheory.SimpleFunc.preimage_eq_empty_iff","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : MeasurableSpace α\nf : MeasureTheory.SimpleFunc α β\nb : β\n⊢ Iff (Eq (Set.preimage (⇑f) (Singleton.singleton b)) EmptyCollection.emptyCollection) (Not (Membership.mem f.range b))","decl":"theorem preimage_eq_empty_iff (f : α →ₛ β) (b : β) : f ⁻¹' {b} = ∅ ↔ b ∉ f.range :=\n  preimage_singleton_eq_empty.trans <| not_congr mem_range.symm\n\n"}
{"name":"MeasureTheory.SimpleFunc.exists_forall_le","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : MeasurableSpace α\ninst✝² : Nonempty β\ninst✝¹ : Preorder β\ninst✝ : IsDirected β fun x1 x2 => LE.le x1 x2\nf : MeasureTheory.SimpleFunc α β\n⊢ Exists fun C => ∀ (x : α), LE.le (f x) C","decl":"theorem exists_forall_le [Nonempty β] [Preorder β] [IsDirected β (· ≤ ·)] (f : α →ₛ β) :\n    ∃ C, ∀ x, f x ≤ C :=\n  f.range.exists_le.imp fun _ => forall_mem_range.1\n\n"}
{"name":"MeasureTheory.SimpleFunc.const_apply","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : MeasurableSpace α\na : α\nb : β\n⊢ Eq ((MeasureTheory.SimpleFunc.const α b) a) b","decl":"theorem const_apply (a : α) (b : β) : (const α b) a = b :=\n  rfl\n\n"}
{"name":"MeasureTheory.SimpleFunc.coe_const","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : MeasurableSpace α\nb : β\n⊢ Eq (⇑(MeasureTheory.SimpleFunc.const α b)) (Function.const α b)","decl":"@[simp]\ntheorem coe_const (b : β) : ⇑(const α b) = Function.const α b :=\n  rfl\n\n"}
{"name":"MeasureTheory.SimpleFunc.range_const","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"β : Type u_2\nα : Type u_5\ninst✝¹ : MeasurableSpace α\ninst✝ : Nonempty α\nb : β\n⊢ Eq (MeasureTheory.SimpleFunc.const α b).range (Singleton.singleton b)","decl":"@[simp]\ntheorem range_const (α) [MeasurableSpace α] [Nonempty α] (b : β) : (const α b).range = {b} :=\n  Finset.coe_injective <| by simp (config := { unfoldPartialApp := true }) [Function.const]\n\n"}
{"name":"MeasureTheory.SimpleFunc.range_const_subset","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"β : Type u_2\nα : Type u_5\ninst✝ : MeasurableSpace α\nb : β\n⊢ HasSubset.Subset (MeasureTheory.SimpleFunc.const α b).range (Singleton.singleton b)","decl":"theorem range_const_subset (α) [MeasurableSpace α] (b : β) : (const α b).range ⊆ {b} :=\n  Finset.coe_subset.1 <| by simp\n\n"}
{"name":"MeasureTheory.SimpleFunc.simpleFunc_bot","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"β : Type u_2\nα : Type u_5\nf : MeasureTheory.SimpleFunc α β\ninst✝ : Nonempty β\n⊢ Exists fun c => ∀ (x : α), Eq (f x) c","decl":"theorem simpleFunc_bot {α} (f : @SimpleFunc α ⊥ β) [Nonempty β] : ∃ c, ∀ x, f x = c := by\n  have hf_meas := @SimpleFunc.measurableSet_fiber α _ ⊥ f\n  simp_rw [MeasurableSpace.measurableSet_bot_iff] at hf_meas\n  exact (exists_eq_const_of_preimage_singleton hf_meas).imp fun c hc ↦ congr_fun hc\n\n"}
{"name":"MeasureTheory.SimpleFunc.simpleFunc_bot'","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"β : Type u_2\nα : Type u_5\ninst✝ : Nonempty β\nf : MeasureTheory.SimpleFunc α β\n⊢ Exists fun c => Eq f (MeasureTheory.SimpleFunc.const α c)","decl":"theorem simpleFunc_bot' {α} [Nonempty β] (f : @SimpleFunc α ⊥ β) :\n    ∃ c, f = @SimpleFunc.const α _ ⊥ c :=\n  letI : MeasurableSpace α := ⊥; (simpleFunc_bot f).imp fun _ ↦ ext\n\n"}
{"name":"MeasureTheory.SimpleFunc.measurableSet_cut","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : MeasurableSpace α\nr : α → β → Prop\nf : MeasureTheory.SimpleFunc α β\nh : ∀ (b : β), MeasurableSet (setOf fun a => r a b)\n⊢ MeasurableSet (setOf fun a => r a (f a))","decl":"theorem measurableSet_cut (r : α → β → Prop) (f : α →ₛ β) (h : ∀ b, MeasurableSet { a | r a b }) :\n    MeasurableSet { a | r a (f a) } := by\n  have : { a | r a (f a) } = ⋃ b ∈ range f, { a | r a b } ∩ f ⁻¹' {b} := by\n    ext a\n    suffices r a (f a) ↔ ∃ i, r a (f i) ∧ f a = f i by simpa\n    exact ⟨fun h => ⟨a, ⟨h, rfl⟩⟩, fun ⟨a', ⟨h', e⟩⟩ => e.symm ▸ h'⟩\n  rw [this]\n  exact\n    MeasurableSet.biUnion f.finite_range.countable fun b _ =>\n      MeasurableSet.inter (h b) (f.measurableSet_fiber _)\n\n"}
{"name":"MeasureTheory.SimpleFunc.measurableSet_preimage","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : MeasurableSpace α\nf : MeasureTheory.SimpleFunc α β\ns : Set β\n⊢ MeasurableSet (Set.preimage (⇑f) s)","decl":"@[measurability]\ntheorem measurableSet_preimage (f : α →ₛ β) (s) : MeasurableSet (f ⁻¹' s) :=\n  measurableSet_cut (fun _ b => b ∈ s) f fun b => MeasurableSet.const (b ∈ s)\n\n"}
{"name":"MeasureTheory.SimpleFunc.measurable","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : MeasurableSpace α\ninst✝ : MeasurableSpace β\nf : MeasureTheory.SimpleFunc α β\n⊢ Measurable ⇑f","decl":"/-- A simple function is measurable -/\n@[measurability, fun_prop]\nprotected theorem measurable [MeasurableSpace β] (f : α →ₛ β) : Measurable f := fun s _ =>\n  measurableSet_preimage f s\n\n"}
{"name":"MeasureTheory.SimpleFunc.aemeasurable","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : MeasurableSpace α\ninst✝ : MeasurableSpace β\nμ : MeasureTheory.Measure α\nf : MeasureTheory.SimpleFunc α β\n⊢ AEMeasurable (⇑f) μ","decl":"@[measurability]\nprotected theorem aemeasurable [MeasurableSpace β] {μ : Measure α} (f : α →ₛ β) :\n    AEMeasurable f μ :=\n  f.measurable.aemeasurable\n\n"}
{"name":"MeasureTheory.SimpleFunc.sum_measure_preimage_singleton","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : MeasurableSpace α\nf : MeasureTheory.SimpleFunc α β\nμ : MeasureTheory.Measure α\ns : Finset β\n⊢ Eq (s.sum fun y => μ (Set.preimage (⇑f) (Singleton.singleton y))) (μ (Set.preimage ⇑f ↑s))","decl":"protected theorem sum_measure_preimage_singleton (f : α →ₛ β) {μ : Measure α} (s : Finset β) :\n    (∑ y ∈ s, μ (f ⁻¹' {y})) = μ (f ⁻¹' ↑s) :=\n  sum_measure_preimage_singleton _ fun _ _ => f.measurableSet_fiber _\n\n"}
{"name":"MeasureTheory.SimpleFunc.sum_range_measure_preimage_singleton","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : MeasurableSpace α\nf : MeasureTheory.SimpleFunc α β\nμ : MeasureTheory.Measure α\n⊢ Eq (f.range.sum fun y => μ (Set.preimage (⇑f) (Singleton.singleton y))) (μ Set.univ)","decl":"theorem sum_range_measure_preimage_singleton (f : α →ₛ β) (μ : Measure α) :\n    (∑ y ∈ f.range, μ (f ⁻¹' {y})) = μ univ := by\n  rw [f.sum_measure_preimage_singleton, coe_range, preimage_range]\n\n"}
{"name":"MeasureTheory.SimpleFunc.coe_piecewise","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : MeasurableSpace α\ns : Set α\nhs : MeasurableSet s\nf g : MeasureTheory.SimpleFunc α β\n⊢ Eq (⇑(MeasureTheory.SimpleFunc.piecewise s hs f g)) (s.piecewise ⇑f ⇑g)","decl":"open scoped Classical in\n@[simp]\ntheorem coe_piecewise {s : Set α} (hs : MeasurableSet s) (f g : α →ₛ β) :\n    ⇑(piecewise s hs f g) = s.piecewise f g :=\n  rfl\n\n"}
{"name":"MeasureTheory.SimpleFunc.piecewise_apply","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : MeasurableSpace α\ns : Set α\nhs : MeasurableSet s\nf g : MeasureTheory.SimpleFunc α β\na : α\n⊢ Eq ((MeasureTheory.SimpleFunc.piecewise s hs f g) a) (ite (Membership.mem s a) (f a) (g a))","decl":"open scoped Classical in\ntheorem piecewise_apply {s : Set α} (hs : MeasurableSet s) (f g : α →ₛ β) (a) :\n    piecewise s hs f g a = if a ∈ s then f a else g a :=\n  rfl\n\n"}
{"name":"MeasureTheory.SimpleFunc.piecewise_compl","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : MeasurableSpace α\ns : Set α\nhs : MeasurableSet (HasCompl.compl s)\nf g : MeasureTheory.SimpleFunc α β\n⊢ Eq (MeasureTheory.SimpleFunc.piecewise (HasCompl.compl s) hs f g) (MeasureTheory.SimpleFunc.piecewise s ⋯ g f)","decl":"open scoped Classical in\n@[simp]\ntheorem piecewise_compl {s : Set α} (hs : MeasurableSet sᶜ) (f g : α →ₛ β) :\n    piecewise sᶜ hs f g = piecewise s hs.of_compl g f :=\n  coe_injective <| by simp [hs]\n\n"}
{"name":"MeasureTheory.SimpleFunc.piecewise_univ","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : MeasurableSpace α\nf g : MeasureTheory.SimpleFunc α β\n⊢ Eq (MeasureTheory.SimpleFunc.piecewise Set.univ ⋯ f g) f","decl":"@[simp]\ntheorem piecewise_univ (f g : α →ₛ β) : piecewise univ MeasurableSet.univ f g = f :=\n  coe_injective <| by simp\n\n"}
{"name":"MeasureTheory.SimpleFunc.piecewise_empty","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : MeasurableSpace α\nf g : MeasureTheory.SimpleFunc α β\n⊢ Eq (MeasureTheory.SimpleFunc.piecewise EmptyCollection.emptyCollection ⋯ f g) g","decl":"@[simp]\ntheorem piecewise_empty (f g : α →ₛ β) : piecewise ∅ MeasurableSet.empty f g = g :=\n  coe_injective <| by simp\n\n"}
{"name":"MeasureTheory.SimpleFunc.piecewise_same","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : MeasurableSpace α\nf : MeasureTheory.SimpleFunc α β\ns : Set α\nhs : MeasurableSet s\n⊢ Eq (MeasureTheory.SimpleFunc.piecewise s hs f f) f","decl":"open scoped Classical in\n@[simp]\ntheorem piecewise_same (f : α →ₛ β) {s : Set α} (hs : MeasurableSet s) :\n    piecewise s hs f f = f :=\n  coe_injective <| Set.piecewise_same _ _\n\n"}
{"name":"MeasureTheory.SimpleFunc.support_indicator","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : MeasurableSpace α\ninst✝ : Zero β\ns : Set α\nhs : MeasurableSet s\nf : MeasureTheory.SimpleFunc α β\n⊢ Eq (Function.support ⇑(MeasureTheory.SimpleFunc.piecewise s hs f (MeasureTheory.SimpleFunc.const α 0))) (Inter.inter s (Function.support ⇑f))","decl":"theorem support_indicator [Zero β] {s : Set α} (hs : MeasurableSet s) (f : α →ₛ β) :\n    Function.support (f.piecewise s hs (SimpleFunc.const α 0)) = s ∩ Function.support f :=\n  Set.support_indicator\n\n"}
{"name":"MeasureTheory.SimpleFunc.range_indicator","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : MeasurableSpace α\ns : Set α\nhs : MeasurableSet s\nhs_nonempty : s.Nonempty\nhs_ne_univ : Ne s Set.univ\nx y : β\n⊢ Eq (MeasureTheory.SimpleFunc.piecewise s hs (MeasureTheory.SimpleFunc.const α x) (MeasureTheory.SimpleFunc.const α y)).range (Insert.insert x (Singleton.singleton y))","decl":"open scoped Classical in\ntheorem range_indicator {s : Set α} (hs : MeasurableSet s) (hs_nonempty : s.Nonempty)\n    (hs_ne_univ : s ≠ univ) (x y : β) :\n    (piecewise s hs (const α x) (const α y)).range = {x, y} := by\n  simp only [← Finset.coe_inj, coe_range, coe_piecewise, range_piecewise, coe_const,\n    Finset.coe_insert, Finset.coe_singleton, hs_nonempty.image_const,\n    (nonempty_compl.2 hs_ne_univ).image_const, singleton_union, Function.const]\n\n"}
{"name":"MeasureTheory.SimpleFunc.measurable_bind","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝¹ : MeasurableSpace α\ninst✝ : MeasurableSpace γ\nf : MeasureTheory.SimpleFunc α β\ng : β → α → γ\nhg : ∀ (b : β), Measurable (g b)\n⊢ Measurable fun a => g (f a) a","decl":"theorem measurable_bind [MeasurableSpace γ] (f : α →ₛ β) (g : β → α → γ)\n    (hg : ∀ b, Measurable (g b)) : Measurable fun a => g (f a) a := fun s hs =>\n  f.measurableSet_cut (fun a b => g b a ∈ s) fun b => hg b hs\n\n"}
{"name":"MeasureTheory.SimpleFunc.bind_apply","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝ : MeasurableSpace α\nf : MeasureTheory.SimpleFunc α β\ng : β → MeasureTheory.SimpleFunc α γ\na : α\n⊢ Eq ((f.bind g) a) ((g (f a)) a)","decl":"@[simp]\ntheorem bind_apply (f : α →ₛ β) (g : β → α →ₛ γ) (a) : f.bind g a = g (f a) a :=\n  rfl\n\n"}
{"name":"MeasureTheory.SimpleFunc.map_apply","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝ : MeasurableSpace α\ng : β → γ\nf : MeasureTheory.SimpleFunc α β\na : α\n⊢ Eq ((MeasureTheory.SimpleFunc.map g f) a) (g (f a))","decl":"theorem map_apply (g : β → γ) (f : α →ₛ β) (a) : f.map g a = g (f a) :=\n  rfl\n\n"}
{"name":"MeasureTheory.SimpleFunc.map_map","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nδ : Type u_4\ninst✝ : MeasurableSpace α\ng : β → γ\nh : γ → δ\nf : MeasureTheory.SimpleFunc α β\n⊢ Eq (MeasureTheory.SimpleFunc.map h (MeasureTheory.SimpleFunc.map g f)) (MeasureTheory.SimpleFunc.map (Function.comp h g) f)","decl":"theorem map_map (g : β → γ) (h : γ → δ) (f : α →ₛ β) : (f.map g).map h = f.map (h ∘ g) :=\n  rfl\n\n"}
{"name":"MeasureTheory.SimpleFunc.coe_map","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝ : MeasurableSpace α\ng : β → γ\nf : MeasureTheory.SimpleFunc α β\n⊢ Eq (⇑(MeasureTheory.SimpleFunc.map g f)) (Function.comp g ⇑f)","decl":"@[simp]\ntheorem coe_map (g : β → γ) (f : α →ₛ β) : (f.map g : α → γ) = g ∘ f :=\n  rfl\n\n"}
{"name":"MeasureTheory.SimpleFunc.range_map","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝¹ : MeasurableSpace α\ninst✝ : DecidableEq γ\ng : β → γ\nf : MeasureTheory.SimpleFunc α β\n⊢ Eq (MeasureTheory.SimpleFunc.map g f).range (Finset.image g f.range)","decl":"@[simp]\ntheorem range_map [DecidableEq γ] (g : β → γ) (f : α →ₛ β) : (f.map g).range = f.range.image g :=\n  Finset.coe_injective <| by simp only [coe_range, coe_map, Finset.coe_image, range_comp]\n\n"}
{"name":"MeasureTheory.SimpleFunc.map_const","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝ : MeasurableSpace α\ng : β → γ\nb : β\n⊢ Eq (MeasureTheory.SimpleFunc.map g (MeasureTheory.SimpleFunc.const α b)) (MeasureTheory.SimpleFunc.const α (g b))","decl":"@[simp]\ntheorem map_const (g : β → γ) (b : β) : (const α b).map g = const α (g b) :=\n  rfl\n\n"}
{"name":"MeasureTheory.SimpleFunc.map_preimage","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝ : MeasurableSpace α\nf : MeasureTheory.SimpleFunc α β\ng : β → γ\ns : Set γ\n⊢ Eq (Set.preimage (⇑(MeasureTheory.SimpleFunc.map g f)) s) (Set.preimage ⇑f ↑(Finset.filter (fun b => Membership.mem s (g b)) f.range))","decl":"open scoped Classical in\ntheorem map_preimage (f : α →ₛ β) (g : β → γ) (s : Set γ) :\n    f.map g ⁻¹' s = f ⁻¹' ↑{b ∈ f.range | g b ∈ s} := by\n  simp only [coe_range, sep_mem_eq, coe_map, Finset.coe_filter,\n    ← mem_preimage, inter_comm, preimage_inter_range, ← Finset.mem_coe]\n  exact preimage_comp\n\n"}
{"name":"MeasureTheory.SimpleFunc.map_preimage_singleton","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝ : MeasurableSpace α\nf : MeasureTheory.SimpleFunc α β\ng : β → γ\nc : γ\n⊢ Eq (Set.preimage (⇑(MeasureTheory.SimpleFunc.map g f)) (Singleton.singleton c)) (Set.preimage ⇑f ↑(Finset.filter (fun b => Eq (g b) c) f.range))","decl":"open scoped Classical in\ntheorem map_preimage_singleton (f : α →ₛ β) (g : β → γ) (c : γ) :\n    f.map g ⁻¹' {c} = f ⁻¹' ↑{b ∈ f.range | g b = c} :=\n  map_preimage _ _ _\n\n"}
{"name":"MeasureTheory.SimpleFunc.coe_comp","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝¹ : MeasurableSpace α\ninst✝ : MeasurableSpace β\nf : MeasureTheory.SimpleFunc β γ\ng : α → β\nhgm : Measurable g\n⊢ Eq (⇑(f.comp g hgm)) (Function.comp (⇑f) g)","decl":"@[simp]\ntheorem coe_comp [MeasurableSpace β] (f : β →ₛ γ) {g : α → β} (hgm : Measurable g) :\n    ⇑(f.comp g hgm) = f ∘ g :=\n  rfl\n\n"}
{"name":"MeasureTheory.SimpleFunc.range_comp_subset_range","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝¹ : MeasurableSpace α\ninst✝ : MeasurableSpace β\nf : MeasureTheory.SimpleFunc β γ\ng : α → β\nhgm : Measurable g\n⊢ HasSubset.Subset (f.comp g hgm).range f.range","decl":"theorem range_comp_subset_range [MeasurableSpace β] (f : β →ₛ γ) {g : α → β} (hgm : Measurable g) :\n    (f.comp g hgm).range ⊆ f.range :=\n  Finset.coe_subset.1 <| by simp only [coe_range, coe_comp, Set.range_comp_subset_range]\n\n"}
{"name":"MeasureTheory.SimpleFunc.extend_apply","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝¹ : MeasurableSpace α\ninst✝ : MeasurableSpace β\nf₁ : MeasureTheory.SimpleFunc α γ\ng : α → β\nhg : MeasurableEmbedding g\nf₂ : MeasureTheory.SimpleFunc β γ\nx : α\n⊢ Eq ((f₁.extend g hg f₂) (g x)) (f₁ x)","decl":"@[simp]\ntheorem extend_apply [MeasurableSpace β] (f₁ : α →ₛ γ) {g : α → β} (hg : MeasurableEmbedding g)\n    (f₂ : β →ₛ γ) (x : α) : (f₁.extend g hg f₂) (g x) = f₁ x :=\n  hg.injective.extend_apply _ _ _\n\n"}
{"name":"MeasureTheory.SimpleFunc.extend_apply'","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝¹ : MeasurableSpace α\ninst✝ : MeasurableSpace β\nf₁ : MeasureTheory.SimpleFunc α γ\ng : α → β\nhg : MeasurableEmbedding g\nf₂ : MeasureTheory.SimpleFunc β γ\ny : β\nh : Not (Exists fun x => Eq (g x) y)\n⊢ Eq ((f₁.extend g hg f₂) y) (f₂ y)","decl":"@[simp]\ntheorem extend_apply' [MeasurableSpace β] (f₁ : α →ₛ γ) {g : α → β} (hg : MeasurableEmbedding g)\n    (f₂ : β →ₛ γ) {y : β} (h : ¬∃ x, g x = y) : (f₁.extend g hg f₂) y = f₂ y :=\n  Function.extend_apply' _ _ _ h\n\n"}
{"name":"MeasureTheory.SimpleFunc.extend_comp_eq'","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝¹ : MeasurableSpace α\ninst✝ : MeasurableSpace β\nf₁ : MeasureTheory.SimpleFunc α γ\ng : α → β\nhg : MeasurableEmbedding g\nf₂ : MeasureTheory.SimpleFunc β γ\n⊢ Eq (Function.comp (⇑(f₁.extend g hg f₂)) g) ⇑f₁","decl":"@[simp]\ntheorem extend_comp_eq' [MeasurableSpace β] (f₁ : α →ₛ γ) {g : α → β} (hg : MeasurableEmbedding g)\n    (f₂ : β →ₛ γ) : f₁.extend g hg f₂ ∘ g = f₁ :=\n  funext fun _ => extend_apply _ _ _ _\n\n"}
{"name":"MeasureTheory.SimpleFunc.extend_comp_eq","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝¹ : MeasurableSpace α\ninst✝ : MeasurableSpace β\nf₁ : MeasureTheory.SimpleFunc α γ\ng : α → β\nhg : MeasurableEmbedding g\nf₂ : MeasureTheory.SimpleFunc β γ\n⊢ Eq ((f₁.extend g hg f₂).comp g ⋯) f₁","decl":"@[simp]\ntheorem extend_comp_eq [MeasurableSpace β] (f₁ : α →ₛ γ) {g : α → β} (hg : MeasurableEmbedding g)\n    (f₂ : β →ₛ γ) : (f₁.extend g hg f₂).comp g hg.measurable = f₁ :=\n  coe_injective <| extend_comp_eq' _ hg _\n\n"}
{"name":"MeasureTheory.SimpleFunc.seq_apply","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝ : MeasurableSpace α\nf : MeasureTheory.SimpleFunc α (β → γ)\ng : MeasureTheory.SimpleFunc α β\na : α\n⊢ Eq ((f.seq g) a) (f a (g a))","decl":"@[simp]\ntheorem seq_apply (f : α →ₛ β → γ) (g : α →ₛ β) (a : α) : f.seq g a = f a (g a) :=\n  rfl\n\n"}
{"name":"MeasureTheory.SimpleFunc.pair_apply","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝ : MeasurableSpace α\nf : MeasureTheory.SimpleFunc α β\ng : MeasureTheory.SimpleFunc α γ\na : α\n⊢ Eq ((f.pair g) a) { fst := f a, snd := g a }","decl":"@[simp]\ntheorem pair_apply (f : α →ₛ β) (g : α →ₛ γ) (a) : pair f g a = (f a, g a) :=\n  rfl\n\n"}
{"name":"MeasureTheory.SimpleFunc.pair_preimage","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝ : MeasurableSpace α\nf : MeasureTheory.SimpleFunc α β\ng : MeasureTheory.SimpleFunc α γ\ns : Set β\nt : Set γ\n⊢ Eq (Set.preimage (⇑(f.pair g)) (SProd.sprod s t)) (Inter.inter (Set.preimage (⇑f) s) (Set.preimage (⇑g) t))","decl":"theorem pair_preimage (f : α →ₛ β) (g : α →ₛ γ) (s : Set β) (t : Set γ) :\n    pair f g ⁻¹' s ×ˢ t = f ⁻¹' s ∩ g ⁻¹' t :=\n  rfl\n\n-- A special form of `pair_preimage`\n"}
{"name":"MeasureTheory.SimpleFunc.pair_preimage_singleton","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝ : MeasurableSpace α\nf : MeasureTheory.SimpleFunc α β\ng : MeasureTheory.SimpleFunc α γ\nb : β\nc : γ\n⊢ Eq (Set.preimage (⇑(f.pair g)) (Singleton.singleton { fst := b, snd := c })) (Inter.inter (Set.preimage (⇑f) (Singleton.singleton b)) (Set.preimage (⇑g) (Singleton.singleton c)))","decl":"theorem pair_preimage_singleton (f : α →ₛ β) (g : α →ₛ γ) (b : β) (c : γ) :\n    pair f g ⁻¹' {(b, c)} = f ⁻¹' {b} ∩ g ⁻¹' {c} := by\n  rw [← singleton_prod_singleton]\n  exact pair_preimage _ _ _ _\n\n"}
{"name":"MeasureTheory.SimpleFunc.map_fst_pair","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝ : MeasurableSpace α\nf : MeasureTheory.SimpleFunc α β\ng : MeasureTheory.SimpleFunc α γ\n⊢ Eq (MeasureTheory.SimpleFunc.map Prod.fst (f.pair g)) f","decl":"@[simp] theorem map_fst_pair (f : α →ₛ β) (g : α →ₛ γ) : (f.pair g).map Prod.fst = f := rfl\n"}
{"name":"MeasureTheory.SimpleFunc.map_snd_pair","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝ : MeasurableSpace α\nf : MeasureTheory.SimpleFunc α β\ng : MeasureTheory.SimpleFunc α γ\n⊢ Eq (MeasureTheory.SimpleFunc.map Prod.snd (f.pair g)) g","decl":"@[simp] theorem map_snd_pair (f : α →ₛ β) (g : α →ₛ γ) : (f.pair g).map Prod.snd = g := rfl\n\n"}
{"name":"MeasureTheory.SimpleFunc.bind_const","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : MeasurableSpace α\nf : MeasureTheory.SimpleFunc α β\n⊢ Eq (f.bind (MeasureTheory.SimpleFunc.const α)) f","decl":"@[simp]\ntheorem bind_const (f : α →ₛ β) : f.bind (const α) = f := by ext; simp\n\n"}
{"name":"MeasureTheory.SimpleFunc.const_zero","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : MeasurableSpace α\ninst✝ : Zero β\n⊢ Eq (MeasureTheory.SimpleFunc.const α 0) 0","decl":"@[to_additive (attr := simp)]\ntheorem const_one [One β] : const α (1 : β) = 1 :=\n  rfl\n\n"}
{"name":"MeasureTheory.SimpleFunc.const_one","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : MeasurableSpace α\ninst✝ : One β\n⊢ Eq (MeasureTheory.SimpleFunc.const α 1) 1","decl":"@[to_additive (attr := simp)]\ntheorem const_one [One β] : const α (1 : β) = 1 :=\n  rfl\n\n"}
{"name":"MeasureTheory.SimpleFunc.coe_one","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : MeasurableSpace α\ninst✝ : One β\n⊢ Eq (⇑1) 1","decl":"@[to_additive (attr := simp, norm_cast)]\ntheorem coe_one [One β] : ⇑(1 : α →ₛ β) = 1 :=\n  rfl\n\n"}
{"name":"MeasureTheory.SimpleFunc.coe_zero","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : MeasurableSpace α\ninst✝ : Zero β\n⊢ Eq (⇑0) 0","decl":"@[to_additive (attr := simp, norm_cast)]\ntheorem coe_one [One β] : ⇑(1 : α →ₛ β) = 1 :=\n  rfl\n\n"}
{"name":"MeasureTheory.SimpleFunc.coe_mul","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : MeasurableSpace α\ninst✝ : Mul β\nf g : MeasureTheory.SimpleFunc α β\n⊢ Eq (⇑(HMul.hMul f g)) (HMul.hMul ⇑f ⇑g)","decl":"@[to_additive (attr := simp, norm_cast)]\ntheorem coe_mul [Mul β] (f g : α →ₛ β) : ⇑(f * g) = ⇑f * ⇑g :=\n  rfl\n\n"}
{"name":"MeasureTheory.SimpleFunc.coe_add","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : MeasurableSpace α\ninst✝ : Add β\nf g : MeasureTheory.SimpleFunc α β\n⊢ Eq (⇑(HAdd.hAdd f g)) (HAdd.hAdd ⇑f ⇑g)","decl":"@[to_additive (attr := simp, norm_cast)]\ntheorem coe_mul [Mul β] (f g : α →ₛ β) : ⇑(f * g) = ⇑f * ⇑g :=\n  rfl\n\n"}
{"name":"MeasureTheory.SimpleFunc.coe_inv","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : MeasurableSpace α\ninst✝ : Inv β\nf : MeasureTheory.SimpleFunc α β\n⊢ Eq (⇑(Inv.inv f)) (Inv.inv ⇑f)","decl":"@[to_additive (attr := simp, norm_cast)]\ntheorem coe_inv [Inv β] (f : α →ₛ β) : ⇑(f⁻¹) = (⇑f)⁻¹ :=\n  rfl\n\n"}
{"name":"MeasureTheory.SimpleFunc.coe_neg","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : MeasurableSpace α\ninst✝ : Neg β\nf : MeasureTheory.SimpleFunc α β\n⊢ Eq (⇑(Neg.neg f)) (Neg.neg ⇑f)","decl":"@[to_additive (attr := simp, norm_cast)]\ntheorem coe_inv [Inv β] (f : α →ₛ β) : ⇑(f⁻¹) = (⇑f)⁻¹ :=\n  rfl\n\n"}
{"name":"MeasureTheory.SimpleFunc.coe_div","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : MeasurableSpace α\ninst✝ : Div β\nf g : MeasureTheory.SimpleFunc α β\n⊢ Eq (⇑(HDiv.hDiv f g)) (HDiv.hDiv ⇑f ⇑g)","decl":"@[to_additive (attr := simp, norm_cast)]\ntheorem coe_div [Div β] (f g : α →ₛ β) : ⇑(f / g) = ⇑f / ⇑g :=\n  rfl\n\n"}
{"name":"MeasureTheory.SimpleFunc.coe_sub","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : MeasurableSpace α\ninst✝ : Sub β\nf g : MeasureTheory.SimpleFunc α β\n⊢ Eq (⇑(HSub.hSub f g)) (HSub.hSub ⇑f ⇑g)","decl":"@[to_additive (attr := simp, norm_cast)]\ntheorem coe_div [Div β] (f g : α →ₛ β) : ⇑(f / g) = ⇑f / ⇑g :=\n  rfl\n\n"}
{"name":"MeasureTheory.SimpleFunc.coe_le","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : MeasurableSpace α\ninst✝ : Preorder β\nf g : MeasureTheory.SimpleFunc α β\n⊢ Iff (LE.le ⇑f ⇑g) (LE.le f g)","decl":"@[simp, norm_cast]\ntheorem coe_le [Preorder β] {f g : α →ₛ β} : (f : α → β) ≤ g ↔ f ≤ g :=\n  Iff.rfl\n\n"}
{"name":"MeasureTheory.SimpleFunc.coe_sup","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : MeasurableSpace α\ninst✝ : Max β\nf g : MeasureTheory.SimpleFunc α β\n⊢ Eq (⇑(Max.max f g)) (Max.max ⇑f ⇑g)","decl":"@[simp, norm_cast]\ntheorem coe_sup [Max β] (f g : α →ₛ β) : ⇑(f ⊔ g) = ⇑f ⊔ ⇑g :=\n  rfl\n\n"}
{"name":"MeasureTheory.SimpleFunc.coe_inf","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : MeasurableSpace α\ninst✝ : Min β\nf g : MeasureTheory.SimpleFunc α β\n⊢ Eq (⇑(Min.min f g)) (Min.min ⇑f ⇑g)","decl":"@[simp, norm_cast]\ntheorem coe_inf [Min β] (f g : α →ₛ β) : ⇑(f ⊓ g) = ⇑f ⊓ ⇑g :=\n  rfl\n\n"}
{"name":"MeasureTheory.SimpleFunc.add_apply","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : MeasurableSpace α\ninst✝ : Add β\nf g : MeasureTheory.SimpleFunc α β\na : α\n⊢ Eq ((HAdd.hAdd f g) a) (HAdd.hAdd (f a) (g a))","decl":"@[to_additive]\ntheorem mul_apply [Mul β] (f g : α →ₛ β) (a : α) : (f * g) a = f a * g a :=\n  rfl\n\n"}
{"name":"MeasureTheory.SimpleFunc.mul_apply","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : MeasurableSpace α\ninst✝ : Mul β\nf g : MeasureTheory.SimpleFunc α β\na : α\n⊢ Eq ((HMul.hMul f g) a) (HMul.hMul (f a) (g a))","decl":"@[to_additive]\ntheorem mul_apply [Mul β] (f g : α →ₛ β) (a : α) : (f * g) a = f a * g a :=\n  rfl\n\n"}
{"name":"MeasureTheory.SimpleFunc.div_apply","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : MeasurableSpace α\ninst✝ : Div β\nf g : MeasureTheory.SimpleFunc α β\nx : α\n⊢ Eq ((HDiv.hDiv f g) x) (HDiv.hDiv (f x) (g x))","decl":"@[to_additive]\ntheorem div_apply [Div β] (f g : α →ₛ β) (x : α) : (f / g) x = f x / g x :=\n  rfl\n\n"}
{"name":"MeasureTheory.SimpleFunc.sub_apply","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : MeasurableSpace α\ninst✝ : Sub β\nf g : MeasureTheory.SimpleFunc α β\nx : α\n⊢ Eq ((HSub.hSub f g) x) (HSub.hSub (f x) (g x))","decl":"@[to_additive]\ntheorem div_apply [Div β] (f g : α →ₛ β) (x : α) : (f / g) x = f x / g x :=\n  rfl\n\n"}
{"name":"MeasureTheory.SimpleFunc.inv_apply","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : MeasurableSpace α\ninst✝ : Inv β\nf : MeasureTheory.SimpleFunc α β\nx : α\n⊢ Eq ((Inv.inv f) x) (Inv.inv (f x))","decl":"@[to_additive]\ntheorem inv_apply [Inv β] (f : α →ₛ β) (x : α) : f⁻¹ x = (f x)⁻¹ :=\n  rfl\n\n"}
{"name":"MeasureTheory.SimpleFunc.neg_apply","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : MeasurableSpace α\ninst✝ : Neg β\nf : MeasureTheory.SimpleFunc α β\nx : α\n⊢ Eq ((Neg.neg f) x) (Neg.neg (f x))","decl":"@[to_additive]\ntheorem inv_apply [Inv β] (f : α →ₛ β) (x : α) : f⁻¹ x = (f x)⁻¹ :=\n  rfl\n\n"}
{"name":"MeasureTheory.SimpleFunc.sup_apply","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : MeasurableSpace α\ninst✝ : Max β\nf g : MeasureTheory.SimpleFunc α β\na : α\n⊢ Eq ((Max.max f g) a) (Max.max (f a) (g a))","decl":"theorem sup_apply [Max β] (f g : α →ₛ β) (a : α) : (f ⊔ g) a = f a ⊔ g a :=\n  rfl\n\n"}
{"name":"MeasureTheory.SimpleFunc.inf_apply","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : MeasurableSpace α\ninst✝ : Min β\nf g : MeasureTheory.SimpleFunc α β\na : α\n⊢ Eq ((Min.min f g) a) (Min.min (f a) (g a))","decl":"theorem inf_apply [Min β] (f g : α →ₛ β) (a : α) : (f ⊓ g) a = f a ⊓ g a :=\n  rfl\n\n"}
{"name":"MeasureTheory.SimpleFunc.range_zero","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : MeasurableSpace α\ninst✝¹ : Nonempty α\ninst✝ : Zero β\n⊢ Eq (MeasureTheory.SimpleFunc.range 0) (Singleton.singleton 0)","decl":"@[to_additive (attr := simp)]\ntheorem range_one [Nonempty α] [One β] : (1 : α →ₛ β).range = {1} :=\n  Finset.ext fun x => by simp [eq_comm]\n\n"}
{"name":"MeasureTheory.SimpleFunc.range_one","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : MeasurableSpace α\ninst✝¹ : Nonempty α\ninst✝ : One β\n⊢ Eq (MeasureTheory.SimpleFunc.range 1) (Singleton.singleton 1)","decl":"@[to_additive (attr := simp)]\ntheorem range_one [Nonempty α] [One β] : (1 : α →ₛ β).range = {1} :=\n  Finset.ext fun x => by simp [eq_comm]\n\n"}
{"name":"MeasureTheory.SimpleFunc.range_eq_empty_of_isEmpty","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nβ : Type u_5\nhα : IsEmpty α\nf : MeasureTheory.SimpleFunc α β\n⊢ Eq f.range EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem range_eq_empty_of_isEmpty {β} [hα : IsEmpty α] (f : α →ₛ β) : f.range = ∅ := by\n  rw [← Finset.not_nonempty_iff_eq_empty]\n  by_contra h\n  obtain ⟨y, hy_mem⟩ := h\n  rw [SimpleFunc.mem_range, Set.mem_range] at hy_mem\n  obtain ⟨x, hxy⟩ := hy_mem\n  rw [isEmpty_iff] at hα\n  exact hα x\n\n"}
{"name":"MeasureTheory.SimpleFunc.eq_zero_of_mem_range_zero","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : MeasurableSpace α\ninst✝ : Zero β\ny : β\na✝ : Membership.mem (MeasureTheory.SimpleFunc.range 0) y\n⊢ Eq y 0","decl":"theorem eq_zero_of_mem_range_zero [Zero β] : ∀ {y : β}, y ∈ (0 : α →ₛ β).range → y = 0 :=\n  @(forall_mem_range.2 fun _ => rfl)\n\n"}
{"name":"MeasureTheory.SimpleFunc.mul_eq_map₂","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : MeasurableSpace α\ninst✝ : Mul β\nf g : MeasureTheory.SimpleFunc α β\n⊢ Eq (HMul.hMul f g) (MeasureTheory.SimpleFunc.map (fun p => HMul.hMul p.1 p.2) (f.pair g))","decl":"@[to_additive]\ntheorem mul_eq_map₂ [Mul β] (f g : α →ₛ β) : f * g = (pair f g).map fun p : β × β => p.1 * p.2 :=\n  rfl\n\n"}
{"name":"MeasureTheory.SimpleFunc.add_eq_map₂","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : MeasurableSpace α\ninst✝ : Add β\nf g : MeasureTheory.SimpleFunc α β\n⊢ Eq (HAdd.hAdd f g) (MeasureTheory.SimpleFunc.map (fun p => HAdd.hAdd p.1 p.2) (f.pair g))","decl":"@[to_additive]\ntheorem mul_eq_map₂ [Mul β] (f g : α →ₛ β) : f * g = (pair f g).map fun p : β × β => p.1 * p.2 :=\n  rfl\n\n"}
{"name":"MeasureTheory.SimpleFunc.sup_eq_map₂","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : MeasurableSpace α\ninst✝ : Max β\nf g : MeasureTheory.SimpleFunc α β\n⊢ Eq (Max.max f g) (MeasureTheory.SimpleFunc.map (fun p => Max.max p.1 p.2) (f.pair g))","decl":"theorem sup_eq_map₂ [Max β] (f g : α →ₛ β) : f ⊔ g = (pair f g).map fun p : β × β => p.1 ⊔ p.2 :=\n  rfl\n\n"}
{"name":"MeasureTheory.SimpleFunc.const_mul_eq_map","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : MeasurableSpace α\ninst✝ : Mul β\nf : MeasureTheory.SimpleFunc α β\nb : β\n⊢ Eq (HMul.hMul (MeasureTheory.SimpleFunc.const α b) f) (MeasureTheory.SimpleFunc.map (fun a => HMul.hMul b a) f)","decl":"@[to_additive]\ntheorem const_mul_eq_map [Mul β] (f : α →ₛ β) (b : β) : const α b * f = f.map fun a => b * a :=\n  rfl\n\n"}
{"name":"MeasureTheory.SimpleFunc.const_add_eq_map","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : MeasurableSpace α\ninst✝ : Add β\nf : MeasureTheory.SimpleFunc α β\nb : β\n⊢ Eq (HAdd.hAdd (MeasureTheory.SimpleFunc.const α b) f) (MeasureTheory.SimpleFunc.map (fun a => HAdd.hAdd b a) f)","decl":"@[to_additive]\ntheorem const_mul_eq_map [Mul β] (f : α →ₛ β) (b : β) : const α b * f = f.map fun a => b * a :=\n  rfl\n\n"}
{"name":"MeasureTheory.SimpleFunc.map_add","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝² : MeasurableSpace α\ninst✝¹ : Add β\ninst✝ : Add γ\ng : β → γ\nhg : ∀ (x y : β), Eq (g (HAdd.hAdd x y)) (HAdd.hAdd (g x) (g y))\nf₁ f₂ : MeasureTheory.SimpleFunc α β\n⊢ Eq (MeasureTheory.SimpleFunc.map g (HAdd.hAdd f₁ f₂)) (HAdd.hAdd (MeasureTheory.SimpleFunc.map g f₁) (MeasureTheory.SimpleFunc.map g f₂))","decl":"@[to_additive]\ntheorem map_mul [Mul β] [Mul γ] {g : β → γ} (hg : ∀ x y, g (x * y) = g x * g y) (f₁ f₂ : α →ₛ β) :\n    (f₁ * f₂).map g = f₁.map g * f₂.map g :=\n  ext fun _ => hg _ _\n\n"}
{"name":"MeasureTheory.SimpleFunc.map_mul","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝² : MeasurableSpace α\ninst✝¹ : Mul β\ninst✝ : Mul γ\ng : β → γ\nhg : ∀ (x y : β), Eq (g (HMul.hMul x y)) (HMul.hMul (g x) (g y))\nf₁ f₂ : MeasureTheory.SimpleFunc α β\n⊢ Eq (MeasureTheory.SimpleFunc.map g (HMul.hMul f₁ f₂)) (HMul.hMul (MeasureTheory.SimpleFunc.map g f₁) (MeasureTheory.SimpleFunc.map g f₂))","decl":"@[to_additive]\ntheorem map_mul [Mul β] [Mul γ] {g : β → γ} (hg : ∀ x y, g (x * y) = g x * g y) (f₁ f₂ : α →ₛ β) :\n    (f₁ * f₂).map g = f₁.map g * f₂.map g :=\n  ext fun _ => hg _ _\n\n"}
{"name":"MeasureTheory.SimpleFunc.coe_vadd","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : MeasurableSpace α\nK : Type u_5\ninst✝ : VAdd K β\nc : K\nf : MeasureTheory.SimpleFunc α β\n⊢ Eq (⇑(HVAdd.hVAdd c f)) (HVAdd.hVAdd c ⇑f)","decl":"@[to_additive (attr := simp)]\ntheorem coe_smul [SMul K β] (c : K) (f : α →ₛ β) : ⇑(c • f) = c • ⇑f :=\n  rfl\n\n"}
{"name":"MeasureTheory.SimpleFunc.coe_smul","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : MeasurableSpace α\nK : Type u_5\ninst✝ : SMul K β\nc : K\nf : MeasureTheory.SimpleFunc α β\n⊢ Eq (⇑(HSMul.hSMul c f)) (HSMul.hSMul c ⇑f)","decl":"@[to_additive (attr := simp)]\ntheorem coe_smul [SMul K β] (c : K) (f : α →ₛ β) : ⇑(c • f) = c • ⇑f :=\n  rfl\n\n"}
{"name":"MeasureTheory.SimpleFunc.vadd_apply","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : MeasurableSpace α\nK : Type u_5\ninst✝ : VAdd K β\nk : K\nf : MeasureTheory.SimpleFunc α β\na : α\n⊢ Eq ((HVAdd.hVAdd k f) a) (HVAdd.hVAdd k (f a))","decl":"@[to_additive (attr := simp)]\ntheorem smul_apply [SMul K β] (k : K) (f : α →ₛ β) (a : α) : (k • f) a = k • f a :=\n  rfl\n\n"}
{"name":"MeasureTheory.SimpleFunc.smul_apply","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : MeasurableSpace α\nK : Type u_5\ninst✝ : SMul K β\nk : K\nf : MeasureTheory.SimpleFunc α β\na : α\n⊢ Eq ((HSMul.hSMul k f) a) (HSMul.hSMul k (f a))","decl":"@[to_additive (attr := simp)]\ntheorem smul_apply [SMul K β] (k : K) (f : α →ₛ β) (a : α) : (k • f) a = k • f a :=\n  rfl\n\n"}
{"name":"MeasureTheory.SimpleFunc.coe_pow","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : MeasurableSpace α\ninst✝ : Monoid β\nf : MeasureTheory.SimpleFunc α β\nn : Nat\n⊢ Eq (⇑(HPow.hPow f n)) (HPow.hPow (⇑f) n)","decl":"@[simp]\ntheorem coe_pow [Monoid β] (f : α →ₛ β) (n : ℕ) : ⇑(f ^ n) = (⇑f) ^ n :=\n  rfl\n\n"}
{"name":"MeasureTheory.SimpleFunc.pow_apply","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : MeasurableSpace α\ninst✝ : Monoid β\nn : Nat\nf : MeasureTheory.SimpleFunc α β\na : α\n⊢ Eq ((HPow.hPow f n) a) (HPow.hPow (f a) n)","decl":"theorem pow_apply [Monoid β] (n : ℕ) (f : α →ₛ β) (a : α) : (f ^ n) a = f a ^ n :=\n  rfl\n\n"}
{"name":"MeasureTheory.SimpleFunc.coe_zpow","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : MeasurableSpace α\ninst✝ : DivInvMonoid β\nf : MeasureTheory.SimpleFunc α β\nz : Int\n⊢ Eq (⇑(HPow.hPow f z)) (HPow.hPow (⇑f) z)","decl":"@[simp]\ntheorem coe_zpow [DivInvMonoid β] (f : α →ₛ β) (z : ℤ) : ⇑(f ^ z) = (⇑f) ^ z :=\n  rfl\n\n"}
{"name":"MeasureTheory.SimpleFunc.zpow_apply","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : MeasurableSpace α\ninst✝ : DivInvMonoid β\nz : Int\nf : MeasureTheory.SimpleFunc α β\na : α\n⊢ Eq ((HPow.hPow f z) a) (HPow.hPow (f a) z)","decl":"theorem zpow_apply [DivInvMonoid β] (z : ℤ) (f : α →ₛ β) (a : α) : (f ^ z) a = f a ^ z :=\n  rfl\n\n-- TODO: work out how to generate these instances with `to_additive`, which gets confused by the\n-- argument order swap between `coe_smul` and `coe_pow`.\n"}
{"name":"MeasureTheory.SimpleFunc.smul_eq_map","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : MeasurableSpace α\nK : Type u_5\ninst✝ : SMul K β\nk : K\nf : MeasureTheory.SimpleFunc α β\n⊢ Eq (HSMul.hSMul k f) (MeasureTheory.SimpleFunc.map (fun x => HSMul.hSMul k x) f)","decl":"theorem smul_eq_map [SMul K β] (k : K) (f : α →ₛ β) : k • f = f.map (k • ·) :=\n  rfl\n\n"}
{"name":"MeasureTheory.SimpleFunc.coe_le_coe","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : MeasurableSpace α\ninst✝ : Preorder β\nf g : MeasureTheory.SimpleFunc α β\n⊢ Iff (LE.le ⇑f ⇑g) (LE.le f g)","decl":"@[norm_cast] lemma coe_le_coe : ⇑f ≤ g ↔ f ≤ g := .rfl\n"}
{"name":"MeasureTheory.SimpleFunc.coe_lt_coe","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : MeasurableSpace α\ninst✝ : Preorder β\nf g : MeasureTheory.SimpleFunc α β\n⊢ Iff (LT.lt ⇑f ⇑g) (LT.lt f g)","decl":"@[simp, norm_cast] lemma coe_lt_coe : ⇑f < g ↔ f < g := .rfl\n\n"}
{"name":"MeasureTheory.SimpleFunc.mk_le_mk","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : MeasurableSpace α\ninst✝ : Preorder β\nf g : α → β\nhf : ∀ (x : β), MeasurableSet (Set.preimage f (Singleton.singleton x))\nhg : ∀ (x : β), MeasurableSet (Set.preimage g (Singleton.singleton x))\nhf' : (Set.range f).Finite\nhg' : (Set.range g).Finite\n⊢ Iff (LE.le { toFun := f, measurableSet_fiber' := hf, finite_range' := hf' } { toFun := g, measurableSet_fiber' := hg, finite_range' := hg' }) (LE.le f g)","decl":"@[simp] lemma mk_le_mk {f g : α → β} {hf hg hf' hg'} : mk f hf hf' ≤ mk g hg hg' ↔ f ≤ g := Iff.rfl\n"}
{"name":"MeasureTheory.SimpleFunc.mk_lt_mk","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : MeasurableSpace α\ninst✝ : Preorder β\nf g : α → β\nhf : ∀ (x : β), MeasurableSet (Set.preimage f (Singleton.singleton x))\nhg : ∀ (x : β), MeasurableSet (Set.preimage g (Singleton.singleton x))\nhf' : (Set.range f).Finite\nhg' : (Set.range g).Finite\n⊢ Iff (LT.lt { toFun := f, measurableSet_fiber' := hf, finite_range' := hf' } { toFun := g, measurableSet_fiber' := hg, finite_range' := hg' }) (LT.lt f g)","decl":"@[simp] lemma mk_lt_mk {f g : α → β} {hf hg hf' hg'} : mk f hf hf' < mk g hg hg' ↔ f < g := Iff.rfl\n\n"}
{"name":"MeasureTheory.SimpleFunc.GCongr.mk_le_mk","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : MeasurableSpace α\ninst✝ : Preorder β\nf g : α → β\nhf : ∀ (x : β), MeasurableSet (Set.preimage f (Singleton.singleton x))\nhg : ∀ (x : β), MeasurableSet (Set.preimage g (Singleton.singleton x))\nhf' : (Set.range f).Finite\nhg' : (Set.range g).Finite\na✝ : LE.le f g\n⊢ LE.le { toFun := f, measurableSet_fiber' := hf, finite_range' := hf' } { toFun := g, measurableSet_fiber' := hg, finite_range' := hg' }","decl":"@[gcongr] protected alias ⟨_, GCongr.mk_le_mk⟩ := mk_le_mk\n"}
{"name":"MeasureTheory.SimpleFunc.GCongr.mk_lt_mk","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : MeasurableSpace α\ninst✝ : Preorder β\nf g : α → β\nhf : ∀ (x : β), MeasurableSet (Set.preimage f (Singleton.singleton x))\nhg : ∀ (x : β), MeasurableSet (Set.preimage g (Singleton.singleton x))\nhf' : (Set.range f).Finite\nhg' : (Set.range g).Finite\na✝ : LT.lt f g\n⊢ LT.lt { toFun := f, measurableSet_fiber' := hf, finite_range' := hf' } { toFun := g, measurableSet_fiber' := hg, finite_range' := hg' }","decl":"@[gcongr] protected alias ⟨_, GCongr.mk_lt_mk⟩ := mk_lt_mk\n"}
{"name":"MeasureTheory.SimpleFunc.GCongr.coe_le_coe","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : MeasurableSpace α\ninst✝ : Preorder β\nf g : MeasureTheory.SimpleFunc α β\na✝ : LE.le f g\n⊢ LE.le ⇑f ⇑g","decl":"@[gcongr] protected alias ⟨_, GCongr.coe_le_coe⟩ := coe_le_coe\n"}
{"name":"MeasureTheory.SimpleFunc.GCongr.coe_lt_coe","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : MeasurableSpace α\ninst✝ : Preorder β\nf g : MeasureTheory.SimpleFunc α β\na✝ : LT.lt f g\n⊢ LT.lt ⇑f ⇑g","decl":"@[gcongr] protected alias ⟨_, GCongr.coe_lt_coe⟩ := coe_lt_coe\n\n"}
{"name":"MeasureTheory.SimpleFunc.piecewise_mono","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : MeasurableSpace α\ninst✝ : Preorder β\ns : Set α\nf₁ f₂ g₁ g₂ : MeasureTheory.SimpleFunc α β\nhs : MeasurableSet s\nhf : ∀ (a : α), Membership.mem s a → LE.le (f₁ a) (f₂ a)\nhg : ∀ (a : α), Not (Membership.mem s a) → LE.le (g₁ a) (g₂ a)\n⊢ LE.le (MeasureTheory.SimpleFunc.piecewise s hs f₁ g₁) (MeasureTheory.SimpleFunc.piecewise s hs f₂ g₂)","decl":"open scoped Classical in\n@[gcongr]\nlemma piecewise_mono (hf : ∀ a ∈ s, f₁ a ≤ f₂ a) (hg : ∀ a ∉ s, g₁ a ≤ g₂ a) :\n    piecewise s hs f₁ g₁ ≤ piecewise s hs f₂ g₂ := Set.piecewise_mono hf hg\n\n"}
{"name":"MeasureTheory.SimpleFunc.finset_sup_apply","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝² : MeasurableSpace α\ninst✝¹ : SemilatticeSup β\ninst✝ : OrderBot β\nf : γ → MeasureTheory.SimpleFunc α β\ns : Finset γ\na : α\n⊢ Eq ((s.sup f) a) (s.sup fun c => (f c) a)","decl":"theorem finset_sup_apply [SemilatticeSup β] [OrderBot β] {f : γ → α →ₛ β} (s : Finset γ) (a : α) :\n    s.sup f a = s.sup fun c => f c a := by\n  classical\n  refine Finset.induction_on s rfl ?_\n  intro a s _ ih\n  rw [Finset.sup_insert, Finset.sup_insert, sup_apply, ih]\n\n"}
{"name":"MeasureTheory.SimpleFunc.restrict_of_not_measurable","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : MeasurableSpace α\ninst✝ : Zero β\nf : MeasureTheory.SimpleFunc α β\ns : Set α\nhs : Not (MeasurableSet s)\n⊢ Eq (f.restrict s) 0","decl":"theorem restrict_of_not_measurable {f : α →ₛ β} {s : Set α} (hs : ¬MeasurableSet s) :\n    restrict f s = 0 :=\n  dif_neg hs\n\n"}
{"name":"MeasureTheory.SimpleFunc.coe_restrict","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : MeasurableSpace α\ninst✝ : Zero β\nf : MeasureTheory.SimpleFunc α β\ns : Set α\nhs : MeasurableSet s\n⊢ Eq (⇑(f.restrict s)) (s.indicator ⇑f)","decl":"@[simp]\ntheorem coe_restrict (f : α →ₛ β) {s : Set α} (hs : MeasurableSet s) :\n    ⇑(restrict f s) = indicator s f := by\n  classical\n  rw [restrict, dif_pos hs, coe_piecewise, coe_zero, piecewise_eq_indicator]\n\n"}
{"name":"MeasureTheory.SimpleFunc.restrict_univ","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : MeasurableSpace α\ninst✝ : Zero β\nf : MeasureTheory.SimpleFunc α β\n⊢ Eq (f.restrict Set.univ) f","decl":"@[simp]\ntheorem restrict_univ (f : α →ₛ β) : restrict f univ = f := by simp [restrict]\n\n"}
{"name":"MeasureTheory.SimpleFunc.restrict_empty","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : MeasurableSpace α\ninst✝ : Zero β\nf : MeasureTheory.SimpleFunc α β\n⊢ Eq (f.restrict EmptyCollection.emptyCollection) 0","decl":"@[simp]\ntheorem restrict_empty (f : α →ₛ β) : restrict f ∅ = 0 := by simp [restrict]\n\n"}
{"name":"MeasureTheory.SimpleFunc.map_restrict_of_zero","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝² : MeasurableSpace α\ninst✝¹ : Zero β\ninst✝ : Zero γ\ng : β → γ\nhg : Eq (g 0) 0\nf : MeasureTheory.SimpleFunc α β\ns : Set α\n⊢ Eq (MeasureTheory.SimpleFunc.map g (f.restrict s)) ((MeasureTheory.SimpleFunc.map g f).restrict s)","decl":"open scoped Classical in\ntheorem map_restrict_of_zero [Zero γ] {g : β → γ} (hg : g 0 = 0) (f : α →ₛ β) (s : Set α) :\n    (f.restrict s).map g = (f.map g).restrict s :=\n  ext fun x =>\n    if hs : MeasurableSet s then by simp [hs, Set.indicator_comp_of_zero hg]\n    else by simp [restrict_of_not_measurable hs, hg]\n\n"}
{"name":"MeasureTheory.SimpleFunc.map_coe_ennreal_restrict","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nf : MeasureTheory.SimpleFunc α NNReal\ns : Set α\n⊢ Eq (MeasureTheory.SimpleFunc.map ENNReal.ofNNReal (f.restrict s)) ((MeasureTheory.SimpleFunc.map ENNReal.ofNNReal f).restrict s)","decl":"theorem map_coe_ennreal_restrict (f : α →ₛ ℝ≥0) (s : Set α) :\n    (f.restrict s).map ((↑) : ℝ≥0 → ℝ≥0∞) = (f.map (↑)).restrict s :=\n  map_restrict_of_zero ENNReal.coe_zero _ _\n\n"}
{"name":"MeasureTheory.SimpleFunc.map_coe_nnreal_restrict","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nf : MeasureTheory.SimpleFunc α NNReal\ns : Set α\n⊢ Eq (MeasureTheory.SimpleFunc.map NNReal.toReal (f.restrict s)) ((MeasureTheory.SimpleFunc.map NNReal.toReal f).restrict s)","decl":"theorem map_coe_nnreal_restrict (f : α →ₛ ℝ≥0) (s : Set α) :\n    (f.restrict s).map ((↑) : ℝ≥0 → ℝ) = (f.map (↑)).restrict s :=\n  map_restrict_of_zero NNReal.coe_zero _ _\n\n"}
{"name":"MeasureTheory.SimpleFunc.restrict_apply","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : MeasurableSpace α\ninst✝ : Zero β\nf : MeasureTheory.SimpleFunc α β\ns : Set α\nhs : MeasurableSet s\na : α\n⊢ Eq ((f.restrict s) a) (s.indicator (⇑f) a)","decl":"theorem restrict_apply (f : α →ₛ β) {s : Set α} (hs : MeasurableSet s) (a) :\n    restrict f s a = indicator s f a := by simp only [f.coe_restrict hs]\n\n"}
{"name":"MeasureTheory.SimpleFunc.restrict_preimage","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : MeasurableSpace α\ninst✝ : Zero β\nf : MeasureTheory.SimpleFunc α β\ns : Set α\nhs : MeasurableSet s\nt : Set β\nht : Not (Membership.mem t 0)\n⊢ Eq (Set.preimage (⇑(f.restrict s)) t) (Inter.inter s (Set.preimage (⇑f) t))","decl":"theorem restrict_preimage (f : α →ₛ β) {s : Set α} (hs : MeasurableSet s) {t : Set β}\n    (ht : (0 : β) ∉ t) : restrict f s ⁻¹' t = s ∩ f ⁻¹' t := by\n  simp [hs, indicator_preimage_of_not_mem _ _ ht, inter_comm]\n\n"}
{"name":"MeasureTheory.SimpleFunc.restrict_preimage_singleton","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : MeasurableSpace α\ninst✝ : Zero β\nf : MeasureTheory.SimpleFunc α β\ns : Set α\nhs : MeasurableSet s\nr : β\nhr : Ne r 0\n⊢ Eq (Set.preimage (⇑(f.restrict s)) (Singleton.singleton r)) (Inter.inter s (Set.preimage (⇑f) (Singleton.singleton r)))","decl":"theorem restrict_preimage_singleton (f : α →ₛ β) {s : Set α} (hs : MeasurableSet s) {r : β}\n    (hr : r ≠ 0) : restrict f s ⁻¹' {r} = s ∩ f ⁻¹' {r} :=\n  f.restrict_preimage hs hr.symm\n\n"}
{"name":"MeasureTheory.SimpleFunc.mem_restrict_range","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : MeasurableSpace α\ninst✝ : Zero β\nr : β\ns : Set α\nf : MeasureTheory.SimpleFunc α β\nhs : MeasurableSet s\n⊢ Iff (Membership.mem (f.restrict s).range r) (Or (And (Eq r 0) (Ne s Set.univ)) (Membership.mem (Set.image (⇑f) s) r))","decl":"theorem mem_restrict_range {r : β} {s : Set α} {f : α →ₛ β} (hs : MeasurableSet s) :\n    r ∈ (restrict f s).range ↔ r = 0 ∧ s ≠ univ ∨ r ∈ f '' s := by\n  rw [← Finset.mem_coe, coe_range, coe_restrict _ hs, mem_range_indicator]\n\n"}
{"name":"MeasureTheory.SimpleFunc.mem_image_of_mem_range_restrict","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : MeasurableSpace α\ninst✝ : Zero β\nr : β\ns : Set α\nf : MeasureTheory.SimpleFunc α β\nhr : Membership.mem (f.restrict s).range r\nh0 : Ne r 0\n⊢ Membership.mem (Set.image (⇑f) s) r","decl":"open scoped Classical in\ntheorem mem_image_of_mem_range_restrict {r : β} {s : Set α} {f : α →ₛ β}\n    (hr : r ∈ (restrict f s).range) (h0 : r ≠ 0) : r ∈ f '' s :=\n  if hs : MeasurableSet s then by simpa [mem_restrict_range hs, h0, -mem_range] using hr\n  else by\n    rw [restrict_of_not_measurable hs] at hr\n    exact (h0 <| eq_zero_of_mem_range_zero hr).elim\n\n"}
{"name":"MeasureTheory.SimpleFunc.restrict_mono","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : MeasurableSpace α\ninst✝¹ : Zero β\ninst✝ : Preorder β\ns : Set α\nf g : MeasureTheory.SimpleFunc α β\nH : LE.le f g\n⊢ LE.le (f.restrict s) (g.restrict s)","decl":"open scoped Classical in\n@[gcongr, mono]\ntheorem restrict_mono [Preorder β] (s : Set α) {f g : α →ₛ β} (H : f ≤ g) :\n    f.restrict s ≤ g.restrict s :=\n  if hs : MeasurableSet s then fun x => by\n    simp only [coe_restrict _ hs, indicator_le_indicator (H x)]\n  else by simp only [restrict_of_not_measurable hs, le_refl]\n\n"}
{"name":"MeasureTheory.SimpleFunc.approx_apply","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝⁷ : MeasurableSpace α\ninst✝⁶ : SemilatticeSup β\ninst✝⁵ : OrderBot β\ninst✝⁴ : Zero β\ninst✝³ : TopologicalSpace β\ninst✝² : OrderClosedTopology β\ninst✝¹ : MeasurableSpace β\ninst✝ : OpensMeasurableSpace β\ni : Nat → β\nf : α → β\nn : Nat\na : α\nhf : Measurable f\n⊢ Eq ((MeasureTheory.SimpleFunc.approx i f n) a) ((Finset.range n).sup fun k => ite (LE.le (i k) (f a)) (i k) 0)","decl":"open scoped Classical in\ntheorem approx_apply [TopologicalSpace β] [OrderClosedTopology β] [MeasurableSpace β]\n    [OpensMeasurableSpace β] {i : ℕ → β} {f : α → β} {n : ℕ} (a : α) (hf : Measurable f) :\n    (approx i f n : α →ₛ β) a = (Finset.range n).sup fun k => if i k ≤ f a then i k else 0 := by\n  dsimp only [approx]\n  rw [finset_sup_apply]\n  congr\n  funext k\n  rw [restrict_apply]\n  · simp only [coe_const, mem_setOf_eq, indicator_apply, Function.const_apply]\n  · exact hf measurableSet_Ici\n\n"}
{"name":"MeasureTheory.SimpleFunc.monotone_approx","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : MeasurableSpace α\ninst✝² : SemilatticeSup β\ninst✝¹ : OrderBot β\ninst✝ : Zero β\ni : Nat → β\nf : α → β\n⊢ Monotone (MeasureTheory.SimpleFunc.approx i f)","decl":"theorem monotone_approx (i : ℕ → β) (f : α → β) : Monotone (approx i f) := fun _ _ h =>\n  Finset.sup_mono <| Finset.range_subset.2 h\n\n"}
{"name":"MeasureTheory.SimpleFunc.approx_comp","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝⁸ : MeasurableSpace α\ninst✝⁷ : SemilatticeSup β\ninst✝⁶ : OrderBot β\ninst✝⁵ : Zero β\ninst✝⁴ : TopologicalSpace β\ninst✝³ : OrderClosedTopology β\ninst✝² : MeasurableSpace β\ninst✝¹ : OpensMeasurableSpace β\ninst✝ : MeasurableSpace γ\ni : Nat → β\nf : γ → β\ng : α → γ\nn : Nat\na : α\nhf : Measurable f\nhg : Measurable g\n⊢ Eq ((MeasureTheory.SimpleFunc.approx i (Function.comp f g) n) a) ((MeasureTheory.SimpleFunc.approx i f n) (g a))","decl":"theorem approx_comp [TopologicalSpace β] [OrderClosedTopology β] [MeasurableSpace β]\n    [OpensMeasurableSpace β] [MeasurableSpace γ] {i : ℕ → β} {f : γ → β} {g : α → γ} {n : ℕ} (a : α)\n    (hf : Measurable f) (hg : Measurable g) :\n    (approx i (f ∘ g) n : α →ₛ β) a = (approx i f n : γ →ₛ β) (g a) := by\n  rw [approx_apply _ hf, approx_apply _ (hf.comp hg), Function.comp_apply]\n\n"}
{"name":"MeasureTheory.SimpleFunc.iSup_approx_apply","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝⁶ : MeasurableSpace α\ninst✝⁵ : TopologicalSpace β\ninst✝⁴ : CompleteLattice β\ninst✝³ : OrderClosedTopology β\ninst✝² : Zero β\ninst✝¹ : MeasurableSpace β\ninst✝ : OpensMeasurableSpace β\ni : Nat → β\nf : α → β\na : α\nhf : Measurable f\nh_zero : Eq 0 Bot.bot\n⊢ Eq (iSup fun n => (MeasureTheory.SimpleFunc.approx i f n) a) (iSup fun k => iSup fun x => i k)","decl":"theorem iSup_approx_apply [TopologicalSpace β] [CompleteLattice β] [OrderClosedTopology β] [Zero β]\n    [MeasurableSpace β] [OpensMeasurableSpace β] (i : ℕ → β) (f : α → β) (a : α) (hf : Measurable f)\n    (h_zero : (0 : β) = ⊥) : ⨆ n, (approx i f n : α →ₛ β) a = ⨆ (k) (_ : i k ≤ f a), i k := by\n  refine le_antisymm (iSup_le fun n => ?_) (iSup_le fun k => iSup_le fun hk => ?_)\n  · rw [approx_apply a hf, h_zero]\n    refine Finset.sup_le fun k _ => ?_\n    split_ifs with h\n    · exact le_iSup_of_le k (le_iSup (fun _ : i k ≤ f a => i k) h)\n    · exact bot_le\n  · refine le_iSup_of_le (k + 1) ?_\n    rw [approx_apply a hf]\n    have : k ∈ Finset.range (k + 1) := Finset.mem_range.2 (Nat.lt_succ_self _)\n    refine le_trans (le_of_eq ?_) (Finset.le_sup this)\n    rw [if_pos hk]\n\n"}
{"name":"MeasureTheory.SimpleFunc.ennrealRatEmbed_encode","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"q : Rat\n⊢ Eq (MeasureTheory.SimpleFunc.ennrealRatEmbed (Encodable.encode q)) ↑(↑q).toNNReal","decl":"theorem ennrealRatEmbed_encode (q : ℚ) :\n    ennrealRatEmbed (Encodable.encode q) = Real.toNNReal q := by\n  rw [ennrealRatEmbed, Encodable.encodek]; rfl\n\n"}
{"name":"MeasureTheory.SimpleFunc.eapprox_lt_top","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nf : α → ENNReal\nn : Nat\na : α\n⊢ LT.lt ((MeasureTheory.SimpleFunc.eapprox f n) a) Top.top","decl":"theorem eapprox_lt_top (f : α → ℝ≥0∞) (n : ℕ) (a : α) : eapprox f n a < ∞ := by\n  simp only [eapprox, approx, finset_sup_apply, Finset.mem_range, ENNReal.bot_eq_zero, restrict]\n  rw [Finset.sup_lt_iff (α := ℝ≥0∞) WithTop.top_pos]\n  intro b _\n  split_ifs\n  · simp only [coe_zero, coe_piecewise, piecewise_eq_indicator, coe_const]\n    calc\n      { a : α | ennrealRatEmbed b ≤ f a }.indicator (fun _ => ennrealRatEmbed b) a ≤\n          ennrealRatEmbed b :=\n        indicator_le_self _ _ a\n      _ < ⊤ := ENNReal.coe_lt_top\n  · exact WithTop.top_pos\n\n"}
{"name":"MeasureTheory.SimpleFunc.monotone_eapprox","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nf : α → ENNReal\n⊢ Monotone (MeasureTheory.SimpleFunc.eapprox f)","decl":"@[mono]\ntheorem monotone_eapprox (f : α → ℝ≥0∞) : Monotone (eapprox f) :=\n  monotone_approx _ f\n\n"}
{"name":"MeasureTheory.SimpleFunc.eapprox_mono","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nf : α → ENNReal\nm n : Nat\nhmn : LE.le m n\n⊢ LE.le (MeasureTheory.SimpleFunc.eapprox f m) (MeasureTheory.SimpleFunc.eapprox f n)","decl":"@[gcongr]\nlemma eapprox_mono {m n : ℕ} (hmn : m ≤ n) : eapprox f m ≤ eapprox f n := monotone_eapprox _ hmn\n\n"}
{"name":"MeasureTheory.SimpleFunc.iSup_eapprox_apply","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nf : α → ENNReal\nhf : Measurable f\na : α\n⊢ Eq (iSup fun n => (MeasureTheory.SimpleFunc.eapprox f n) a) (f a)","decl":"lemma iSup_eapprox_apply (hf : Measurable f) (a : α) : ⨆ n, (eapprox f n : α →ₛ ℝ≥0∞) a = f a := by\n  rw [eapprox, iSup_approx_apply ennrealRatEmbed f a hf rfl]\n  refine le_antisymm (iSup_le fun i => iSup_le fun hi => hi) (le_of_not_gt ?_)\n  intro h\n  rcases ENNReal.lt_iff_exists_rat_btwn.1 h with ⟨q, _, lt_q, q_lt⟩\n  have :\n    (Real.toNNReal q : ℝ≥0∞) ≤ ⨆ (k : ℕ) (_ : ennrealRatEmbed k ≤ f a), ennrealRatEmbed k := by\n    refine le_iSup_of_le (Encodable.encode q) ?_\n    rw [ennrealRatEmbed_encode q]\n    exact le_iSup_of_le (le_of_lt q_lt) le_rfl\n  exact lt_irrefl _ (lt_of_le_of_lt this lt_q)\n\n"}
{"name":"MeasureTheory.SimpleFunc.iSup_coe_eapprox","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nf : α → ENNReal\nhf : Measurable f\n⊢ Eq (iSup fun n => ⇑(MeasureTheory.SimpleFunc.eapprox f n)) f","decl":"lemma iSup_coe_eapprox (hf : Measurable f) : ⨆ n, ⇑(eapprox f n) = f := by\n  simpa [funext_iff] using iSup_eapprox_apply hf\n\n"}
{"name":"MeasureTheory.SimpleFunc.eapprox_comp","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\nγ : Type u_3\ninst✝¹ : MeasurableSpace α\ninst✝ : MeasurableSpace γ\nf : γ → ENNReal\ng : α → γ\nn : Nat\nhf : Measurable f\nhg : Measurable g\n⊢ Eq (⇑(MeasureTheory.SimpleFunc.eapprox (Function.comp f g) n)) (Function.comp (⇑(MeasureTheory.SimpleFunc.eapprox f n)) g)","decl":"theorem eapprox_comp [MeasurableSpace γ] {f : γ → ℝ≥0∞} {g : α → γ} {n : ℕ} (hf : Measurable f)\n    (hg : Measurable g) : (eapprox (f ∘ g) n : α → ℝ≥0∞) = (eapprox f n : γ →ₛ ℝ≥0∞) ∘ g :=\n  funext fun a => approx_comp a hf hg\n\n"}
{"name":"MeasureTheory.SimpleFunc.tendsto_eapprox","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nf : α → ENNReal\nhf_meas : Measurable f\na : α\n⊢ Filter.Tendsto (fun n => (MeasureTheory.SimpleFunc.eapprox f n) a) Filter.atTop (nhds (f a))","decl":"lemma tendsto_eapprox {f : α → ℝ≥0∞} (hf_meas : Measurable f) (a : α) :\n    Tendsto (fun n ↦ eapprox f n a) atTop (𝓝 (f a)) := by\n  nth_rw 2 [← iSup_coe_eapprox hf_meas]\n  rw [iSup_apply]\n  exact tendsto_atTop_iSup fun _ _ hnm ↦ monotone_eapprox f hnm a\n\n"}
{"name":"MeasureTheory.SimpleFunc.sum_eapproxDiff","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nf : α → ENNReal\nn : Nat\na : α\n⊢ Eq ((Finset.range (HAdd.hAdd n 1)).sum fun k => ↑((MeasureTheory.SimpleFunc.eapproxDiff f k) a)) ((MeasureTheory.SimpleFunc.eapprox f n) a)","decl":"theorem sum_eapproxDiff (f : α → ℝ≥0∞) (n : ℕ) (a : α) :\n    (∑ k ∈ Finset.range (n + 1), (eapproxDiff f k a : ℝ≥0∞)) = eapprox f n a := by\n  induction' n with n IH\n  · simp only [Nat.zero_add, Finset.sum_singleton, Finset.range_one]\n    rfl\n  · rw [Finset.sum_range_succ, IH, eapproxDiff, coe_map, Function.comp_apply,\n      coe_sub, Pi.sub_apply, ENNReal.coe_toNNReal,\n      add_tsub_cancel_of_le (monotone_eapprox f (Nat.le_succ _) _)]\n    apply (lt_of_le_of_lt _ (eapprox_lt_top f (n + 1) a)).ne\n    rw [tsub_le_iff_right]\n    exact le_self_add\n\n"}
{"name":"MeasureTheory.SimpleFunc.tsum_eapproxDiff","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nf : α → ENNReal\nhf : Measurable f\na : α\n⊢ Eq (tsum fun n => ↑((MeasureTheory.SimpleFunc.eapproxDiff f n) a)) (f a)","decl":"theorem tsum_eapproxDiff (f : α → ℝ≥0∞) (hf : Measurable f) (a : α) :\n    (∑' n, (eapproxDiff f n a : ℝ≥0∞)) = f a := by\n  simp_rw [ENNReal.tsum_eq_iSup_nat' (tendsto_add_atTop_nat 1), sum_eapproxDiff,\n    iSup_eapprox_apply hf a]\n\n"}
{"name":"MeasureTheory.SimpleFunc.lintegral_eq_of_subset","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : MeasureTheory.SimpleFunc α ENNReal\ns : Finset ENNReal\nhs : ∀ (x : α), Ne (f x) 0 → Ne (μ (Set.preimage (⇑f) (Singleton.singleton (f x)))) 0 → Membership.mem s (f x)\n⊢ Eq (f.lintegral μ) (s.sum fun x => HMul.hMul x (μ (Set.preimage (⇑f) (Singleton.singleton x))))","decl":"theorem lintegral_eq_of_subset (f : α →ₛ ℝ≥0∞) {s : Finset ℝ≥0∞}\n    (hs : ∀ x, f x ≠ 0 → μ (f ⁻¹' {f x}) ≠ 0 → f x ∈ s) :\n    f.lintegral μ = ∑ x ∈ s, x * μ (f ⁻¹' {x}) := by\n  refine Finset.sum_bij_ne_zero (fun r _ _ => r) ?_ ?_ ?_ ?_\n  · simpa only [forall_mem_range, mul_ne_zero_iff, and_imp]\n  · intros\n    assumption\n  · intro b _ hb\n    refine ⟨b, ?_, hb, rfl⟩\n    rw [mem_range, ← preimage_singleton_nonempty]\n    exact nonempty_of_measure_ne_zero (mul_ne_zero_iff.1 hb).2\n  · intros\n    rfl\n\n"}
{"name":"MeasureTheory.SimpleFunc.lintegral_eq_of_subset'","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : MeasureTheory.SimpleFunc α ENNReal\ns : Finset ENNReal\nhs : HasSubset.Subset (SDiff.sdiff f.range (Singleton.singleton 0)) s\n⊢ Eq (f.lintegral μ) (s.sum fun x => HMul.hMul x (μ (Set.preimage (⇑f) (Singleton.singleton x))))","decl":"theorem lintegral_eq_of_subset' (f : α →ₛ ℝ≥0∞) {s : Finset ℝ≥0∞} (hs : f.range \\ {0} ⊆ s) :\n    f.lintegral μ = ∑ x ∈ s, x * μ (f ⁻¹' {x}) :=\n  f.lintegral_eq_of_subset fun x hfx _ =>\n    hs <| Finset.mem_sdiff.2 ⟨f.mem_range_self x, mt Finset.mem_singleton.1 hfx⟩\n\n"}
{"name":"MeasureTheory.SimpleFunc.map_lintegral","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ng : β → ENNReal\nf : MeasureTheory.SimpleFunc α β\n⊢ Eq ((MeasureTheory.SimpleFunc.map g f).lintegral μ) (f.range.sum fun x => HMul.hMul (g x) (μ (Set.preimage (⇑f) (Singleton.singleton x))))","decl":"/-- Calculate the integral of `(g ∘ f)`, where `g : β → ℝ≥0∞` and `f : α →ₛ β`. -/\ntheorem map_lintegral (g : β → ℝ≥0∞) (f : α →ₛ β) :\n    (f.map g).lintegral μ = ∑ x ∈ f.range, g x * μ (f ⁻¹' {x}) := by\n  simp only [lintegral, range_map]\n  refine Finset.sum_image' _ fun b hb => ?_\n  rcases mem_range.1 hb with ⟨a, rfl⟩\n  rw [map_preimage_singleton, ← f.sum_measure_preimage_singleton, Finset.mul_sum]\n  refine Finset.sum_congr ?_ ?_\n  · congr\n  · intro x\n    simp only [Finset.mem_filter]\n    rintro ⟨_, h⟩\n    rw [h]\n\n"}
{"name":"MeasureTheory.SimpleFunc.add_lintegral","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf g : MeasureTheory.SimpleFunc α ENNReal\n⊢ Eq ((HAdd.hAdd f g).lintegral μ) (HAdd.hAdd (f.lintegral μ) (g.lintegral μ))","decl":"theorem add_lintegral (f g : α →ₛ ℝ≥0∞) : (f + g).lintegral μ = f.lintegral μ + g.lintegral μ :=\n  calc\n    (f + g).lintegral μ =\n        ∑ x ∈ (pair f g).range, (x.1 * μ (pair f g ⁻¹' {x}) + x.2 * μ (pair f g ⁻¹' {x})) := by\n      rw [add_eq_map₂, map_lintegral]; exact Finset.sum_congr rfl fun a _ => add_mul _ _ _\n    _ = (∑ x ∈ (pair f g).range, x.1 * μ (pair f g ⁻¹' {x})) +\n          ∑ x ∈ (pair f g).range, x.2 * μ (pair f g ⁻¹' {x}) := by\n      rw [Finset.sum_add_distrib]\n    _ = ((pair f g).map Prod.fst).lintegral μ + ((pair f g).map Prod.snd).lintegral μ := by\n      rw [map_lintegral, map_lintegral]\n    _ = lintegral f μ + lintegral g μ := rfl\n\n"}
{"name":"MeasureTheory.SimpleFunc.const_mul_lintegral","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : MeasureTheory.SimpleFunc α ENNReal\nx : ENNReal\n⊢ Eq ((HMul.hMul (MeasureTheory.SimpleFunc.const α x) f).lintegral μ) (HMul.hMul x (f.lintegral μ))","decl":"theorem const_mul_lintegral (f : α →ₛ ℝ≥0∞) (x : ℝ≥0∞) :\n    (const α x * f).lintegral μ = x * f.lintegral μ :=\n  calc\n    (f.map fun a => x * a).lintegral μ = ∑ r ∈ f.range, x * r * μ (f ⁻¹' {r}) := map_lintegral _ _\n    _ = x * ∑ r ∈ f.range, r * μ (f ⁻¹' {r}) := by simp_rw [Finset.mul_sum, mul_assoc]\n\n"}
{"name":"MeasureTheory.SimpleFunc.zero_lintegral","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\n⊢ Eq (MeasureTheory.SimpleFunc.lintegral 0 μ) 0","decl":"@[simp]\ntheorem zero_lintegral : (0 : α →ₛ ℝ≥0∞).lintegral μ = 0 :=\n  LinearMap.ext_iff.1 lintegralₗ.map_zero μ\n\n"}
{"name":"MeasureTheory.SimpleFunc.lintegral_add","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\nf : MeasureTheory.SimpleFunc α ENNReal\n⊢ Eq (f.lintegral (HAdd.hAdd μ ν)) (HAdd.hAdd (f.lintegral μ) (f.lintegral ν))","decl":"theorem lintegral_add {ν} (f : α →ₛ ℝ≥0∞) : f.lintegral (μ + ν) = f.lintegral μ + f.lintegral ν :=\n  (lintegralₗ f).map_add μ ν\n\n"}
{"name":"MeasureTheory.SimpleFunc.lintegral_smul","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : MeasureTheory.SimpleFunc α ENNReal\nc : ENNReal\n⊢ Eq (f.lintegral (HSMul.hSMul c μ)) (HSMul.hSMul c (f.lintegral μ))","decl":"theorem lintegral_smul (f : α →ₛ ℝ≥0∞) (c : ℝ≥0∞) : f.lintegral (c • μ) = c • f.lintegral μ :=\n  (lintegralₗ f).map_smul c μ\n\n"}
{"name":"MeasureTheory.SimpleFunc.lintegral_zero","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nf : MeasureTheory.SimpleFunc α ENNReal\n⊢ Eq (f.lintegral 0) 0","decl":"@[simp]\ntheorem lintegral_zero [MeasurableSpace α] (f : α →ₛ ℝ≥0∞) : f.lintegral 0 = 0 :=\n  (lintegralₗ f).map_zero\n\n"}
{"name":"MeasureTheory.SimpleFunc.lintegral_finset_sum","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nι : Type u_5\nf : MeasureTheory.SimpleFunc α ENNReal\nμ : ι → MeasureTheory.Measure α\ns : Finset ι\n⊢ Eq (f.lintegral (s.sum fun i => μ i)) (s.sum fun i => f.lintegral (μ i))","decl":"theorem lintegral_finset_sum {ι} (f : α →ₛ ℝ≥0∞) (μ : ι → Measure α) (s : Finset ι) :\n    f.lintegral (∑ i ∈ s, μ i) = ∑ i ∈ s, f.lintegral (μ i) :=\n  map_sum (lintegralₗ f) ..\n\n"}
{"name":"MeasureTheory.SimpleFunc.lintegral_sum","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nι : Type u_5\nf : MeasureTheory.SimpleFunc α ENNReal\nμ : ι → MeasureTheory.Measure α\n⊢ Eq (f.lintegral (MeasureTheory.Measure.sum μ)) (tsum fun i => f.lintegral (μ i))","decl":"theorem lintegral_sum {m : MeasurableSpace α} {ι} (f : α →ₛ ℝ≥0∞) (μ : ι → Measure α) :\n    f.lintegral (Measure.sum μ) = ∑' i, f.lintegral (μ i) := by\n  simp only [lintegral, Measure.sum_apply, f.measurableSet_preimage, ← Finset.tsum_subtype, ←\n    ENNReal.tsum_mul_left]\n  apply ENNReal.tsum_comm\n\n"}
{"name":"MeasureTheory.SimpleFunc.restrict_lintegral","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : MeasureTheory.SimpleFunc α ENNReal\ns : Set α\nhs : MeasurableSet s\n⊢ Eq ((f.restrict s).lintegral μ) (f.range.sum fun r => HMul.hMul r (μ (Inter.inter (Set.preimage (⇑f) (Singleton.singleton r)) s)))","decl":"open scoped Classical in\ntheorem restrict_lintegral (f : α →ₛ ℝ≥0∞) {s : Set α} (hs : MeasurableSet s) :\n    (restrict f s).lintegral μ = ∑ r ∈ f.range, r * μ (f ⁻¹' {r} ∩ s) :=\n  calc\n    (restrict f s).lintegral μ = ∑ r ∈ f.range, r * μ (restrict f s ⁻¹' {r}) :=\n      lintegral_eq_of_subset _ fun x hx =>\n        if hxs : x ∈ s then fun _ => by\n          simp only [f.restrict_apply hs, indicator_of_mem hxs, mem_range_self]\n        else False.elim <| hx <| by simp [*]\n    _ = ∑ r ∈ f.range, r * μ (f ⁻¹' {r} ∩ s) :=\n      Finset.sum_congr rfl <|\n        forall_mem_range.2 fun b =>\n          if hb : f b = 0 then by simp only [hb, zero_mul]\n          else by rw [restrict_preimage_singleton _ hs hb, inter_comm]\n\n"}
{"name":"MeasureTheory.SimpleFunc.lintegral_restrict","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nf : MeasureTheory.SimpleFunc α ENNReal\ns : Set α\nμ : MeasureTheory.Measure α\n⊢ Eq (f.lintegral (μ.restrict s)) (f.range.sum fun y => HMul.hMul y (μ (Inter.inter (Set.preimage (⇑f) (Singleton.singleton y)) s)))","decl":"theorem lintegral_restrict {m : MeasurableSpace α} (f : α →ₛ ℝ≥0∞) (s : Set α) (μ : Measure α) :\n    f.lintegral (μ.restrict s) = ∑ y ∈ f.range, y * μ (f ⁻¹' {y} ∩ s) := by\n  simp only [lintegral, Measure.restrict_apply, f.measurableSet_preimage]\n\n"}
{"name":"MeasureTheory.SimpleFunc.restrict_lintegral_eq_lintegral_restrict","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : MeasureTheory.SimpleFunc α ENNReal\ns : Set α\nhs : MeasurableSet s\n⊢ Eq ((f.restrict s).lintegral μ) (f.lintegral (μ.restrict s))","decl":"theorem restrict_lintegral_eq_lintegral_restrict (f : α →ₛ ℝ≥0∞) {s : Set α}\n    (hs : MeasurableSet s) : (restrict f s).lintegral μ = f.lintegral (μ.restrict s) := by\n  rw [f.restrict_lintegral hs, lintegral_restrict]\n\n"}
{"name":"MeasureTheory.SimpleFunc.lintegral_restrict_iUnion_of_directed","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nι : Type u_5\ninst✝ : Countable ι\nf : MeasureTheory.SimpleFunc α ENNReal\ns : ι → Set α\nhd : Directed (fun x1 x2 => HasSubset.Subset x1 x2) s\nμ : MeasureTheory.Measure α\n⊢ Eq (f.lintegral (μ.restrict (Set.iUnion fun i => s i))) (iSup fun i => f.lintegral (μ.restrict (s i)))","decl":"theorem lintegral_restrict_iUnion_of_directed {ι : Type*} [Countable ι]\n    (f : α →ₛ ℝ≥0∞) {s : ι → Set α} (hd : Directed (· ⊆ ·) s) (μ : Measure α) :\n    f.lintegral (μ.restrict (⋃ i, s i)) = ⨆ i, f.lintegral (μ.restrict (s i)) := by\n  simp only [lintegral, Measure.restrict_iUnion_apply_eq_iSup hd (measurableSet_preimage ..),\n    ENNReal.mul_iSup]\n  refine finsetSum_iSup fun i j ↦ (hd i j).imp fun k ⟨hik, hjk⟩ ↦ fun a ↦ ?_\n  -- TODO https://github.com/leanprover-community/mathlib4/pull/14739 make `gcongr` close this goal\n  constructor <;> · gcongr; refine Measure.restrict_mono ?_ le_rfl _; assumption\n\n"}
{"name":"MeasureTheory.SimpleFunc.const_lintegral","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nc : ENNReal\n⊢ Eq ((MeasureTheory.SimpleFunc.const α c).lintegral μ) (HMul.hMul c (μ Set.univ))","decl":"theorem const_lintegral (c : ℝ≥0∞) : (const α c).lintegral μ = c * μ univ := by\n  rw [lintegral]\n  cases isEmpty_or_nonempty α\n  · simp [μ.eq_zero_of_isEmpty]\n  · simp only [range_const, coe_const, Finset.sum_singleton]\n    unfold Function.const; rw [preimage_const_of_mem (mem_singleton c)]\n\n"}
{"name":"MeasureTheory.SimpleFunc.const_lintegral_restrict","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nc : ENNReal\ns : Set α\n⊢ Eq ((MeasureTheory.SimpleFunc.const α c).lintegral (μ.restrict s)) (HMul.hMul c (μ s))","decl":"theorem const_lintegral_restrict (c : ℝ≥0∞) (s : Set α) :\n    (const α c).lintegral (μ.restrict s) = c * μ s := by\n  rw [const_lintegral, Measure.restrict_apply MeasurableSet.univ, univ_inter]\n\n"}
{"name":"MeasureTheory.SimpleFunc.restrict_const_lintegral","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nc : ENNReal\ns : Set α\nhs : MeasurableSet s\n⊢ Eq (((MeasureTheory.SimpleFunc.const α c).restrict s).lintegral μ) (HMul.hMul c (μ s))","decl":"theorem restrict_const_lintegral (c : ℝ≥0∞) {s : Set α} (hs : MeasurableSet s) :\n    ((const α c).restrict s).lintegral μ = c * μ s := by\n  rw [restrict_lintegral_eq_lintegral_restrict _ hs, const_lintegral_restrict]\n\n"}
{"name":"MeasureTheory.SimpleFunc.lintegral_mono_fun","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf g : MeasureTheory.SimpleFunc α ENNReal\nh : LE.le f g\n⊢ LE.le (f.lintegral μ) (g.lintegral μ)","decl":"@[gcongr]\ntheorem lintegral_mono_fun {f g : α →ₛ ℝ≥0∞} (h : f ≤ g) : f.lintegral μ ≤ g.lintegral μ := by\n  refine Monotone.of_left_le_map_sup (f := (lintegral · μ)) (fun f g ↦ ?_) h\n  calc\n    f.lintegral μ = ((pair f g).map Prod.fst).lintegral μ := by rw [map_fst_pair]\n    _ ≤ ((pair f g).map fun p ↦ p.1 ⊔ p.2).lintegral μ := by\n      simp only [map_lintegral]\n      gcongr\n      exact le_sup_left\n\n"}
{"name":"MeasureTheory.SimpleFunc.le_sup_lintegral","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf g : MeasureTheory.SimpleFunc α ENNReal\n⊢ LE.le (Max.max (f.lintegral μ) (g.lintegral μ)) ((Max.max f g).lintegral μ)","decl":"theorem le_sup_lintegral (f g : α →ₛ ℝ≥0∞) : f.lintegral μ ⊔ g.lintegral μ ≤ (f ⊔ g).lintegral μ :=\n  Monotone.le_map_sup (fun _ _ ↦ lintegral_mono_fun) f g\n\n"}
{"name":"MeasureTheory.SimpleFunc.lintegral_mono_measure","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\nf : MeasureTheory.SimpleFunc α ENNReal\nh : LE.le μ ν\n⊢ LE.le (f.lintegral μ) (f.lintegral ν)","decl":"@[gcongr]\ntheorem lintegral_mono_measure {f : α →ₛ ℝ≥0∞} (h : μ ≤ ν) : f.lintegral μ ≤ f.lintegral ν := by\n  simp only [lintegral]\n  gcongr\n  apply h\n\n"}
{"name":"MeasureTheory.SimpleFunc.lintegral_mono","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\nf g : MeasureTheory.SimpleFunc α ENNReal\nhfg : LE.le f g\nhμν : LE.le μ ν\n⊢ LE.le (f.lintegral μ) (g.lintegral ν)","decl":"/-- `SimpleFunc.lintegral` is monotone both in function and in measure. -/\n@[mono, gcongr]\ntheorem lintegral_mono {f g : α →ₛ ℝ≥0∞} (hfg : f ≤ g) (hμν : μ ≤ ν) :\n    f.lintegral μ ≤ g.lintegral ν :=\n  (lintegral_mono_fun hfg).trans (lintegral_mono_measure hμν)\n\n"}
{"name":"MeasureTheory.SimpleFunc.lintegral_eq_of_measure_preimage","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : MeasurableSpace β\nf : MeasureTheory.SimpleFunc α ENNReal\ng : MeasureTheory.SimpleFunc β ENNReal\nν : MeasureTheory.Measure β\nH : ∀ (y : ENNReal), Eq (μ (Set.preimage (⇑f) (Singleton.singleton y))) (ν (Set.preimage (⇑g) (Singleton.singleton y)))\n⊢ Eq (f.lintegral μ) (g.lintegral ν)","decl":"/-- `SimpleFunc.lintegral` depends only on the measures of `f ⁻¹' {y}`. -/\ntheorem lintegral_eq_of_measure_preimage [MeasurableSpace β] {f : α →ₛ ℝ≥0∞} {g : β →ₛ ℝ≥0∞}\n    {ν : Measure β} (H : ∀ y, μ (f ⁻¹' {y}) = ν (g ⁻¹' {y})) : f.lintegral μ = g.lintegral ν := by\n  simp only [lintegral, ← H]\n  apply lintegral_eq_of_subset\n  simp only [H]\n  intros\n  exact mem_range_of_measure_ne_zero ‹_›\n\n"}
{"name":"MeasureTheory.SimpleFunc.lintegral_congr","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf g : MeasureTheory.SimpleFunc α ENNReal\nh : (MeasureTheory.ae μ).EventuallyEq ⇑f ⇑g\n⊢ Eq (f.lintegral μ) (g.lintegral μ)","decl":"/-- If two simple functions are equal a.e., then their `lintegral`s are equal. -/\ntheorem lintegral_congr {f g : α →ₛ ℝ≥0∞} (h : f =ᵐ[μ] g) : f.lintegral μ = g.lintegral μ :=\n  lintegral_eq_of_measure_preimage fun y =>\n    measure_congr <| Eventually.set_eq <| h.mono fun x hx => by simp [hx]\n\n"}
{"name":"MeasureTheory.SimpleFunc.lintegral_map'","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nβ : Type u_5\ninst✝ : MeasurableSpace β\nμ' : MeasureTheory.Measure β\nf : MeasureTheory.SimpleFunc α ENNReal\ng : MeasureTheory.SimpleFunc β ENNReal\nm' : α → β\neq : ∀ (a : α), Eq (f a) (g (m' a))\nh : ∀ (s : Set β), MeasurableSet s → Eq (μ' s) (μ (Set.preimage m' s))\n⊢ Eq (f.lintegral μ) (g.lintegral μ')","decl":"theorem lintegral_map' {β} [MeasurableSpace β] {μ' : Measure β} (f : α →ₛ ℝ≥0∞) (g : β →ₛ ℝ≥0∞)\n    (m' : α → β) (eq : ∀ a, f a = g (m' a)) (h : ∀ s, MeasurableSet s → μ' s = μ (m' ⁻¹' s)) :\n    f.lintegral μ = g.lintegral μ' :=\n  lintegral_eq_of_measure_preimage fun y => by\n    simp only [preimage, eq]\n    exact (h (g ⁻¹' {y}) (g.measurableSet_preimage _)).symm\n\n"}
{"name":"MeasureTheory.SimpleFunc.lintegral_map","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nβ : Type u_5\ninst✝ : MeasurableSpace β\ng : MeasureTheory.SimpleFunc β ENNReal\nf : α → β\nhf : Measurable f\n⊢ Eq (g.lintegral (MeasureTheory.Measure.map f μ)) ((g.comp f hf).lintegral μ)","decl":"theorem lintegral_map {β} [MeasurableSpace β] (g : β →ₛ ℝ≥0∞) {f : α → β} (hf : Measurable f) :\n    g.lintegral (Measure.map f μ) = (g.comp f hf).lintegral μ :=\n  Eq.symm <| lintegral_map' _ _ f (fun _ => rfl) fun _s hs => Measure.map_apply hf hs\n\n"}
{"name":"MeasureTheory.SimpleFunc.support_eq","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : MeasurableSpace α\ninst✝ : Zero β\nf : MeasureTheory.SimpleFunc α β\n⊢ Eq (Function.support ⇑f) (Set.iUnion fun y => Set.iUnion fun h => Set.preimage (⇑f) (Singleton.singleton y))","decl":"open scoped Classical in\ntheorem support_eq [MeasurableSpace α] [Zero β] (f : α →ₛ β) :\n    support f = ⋃ y ∈ {y ∈ f.range | y ≠ 0}, f ⁻¹' {y} :=\n  Set.ext fun x => by\n    simp only [mem_support, Set.mem_preimage, mem_filter, mem_range_self, true_and, exists_prop,\n      mem_iUnion, Set.mem_range, mem_singleton_iff, exists_eq_right']\n\n"}
{"name":"MeasureTheory.SimpleFunc.measurableSet_support","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Zero β\ninst✝ : MeasurableSpace α\nf : MeasureTheory.SimpleFunc α β\n⊢ MeasurableSet (Function.support ⇑f)","decl":"theorem measurableSet_support [MeasurableSpace α] (f : α →ₛ β) : MeasurableSet (support f) := by\n  rw [f.support_eq]\n  exact Finset.measurableSet_biUnion _ fun y _ => measurableSet_fiber _ _\n\n"}
{"name":"MeasureTheory.SimpleFunc.measure_support_lt_top","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\ninst✝ : Zero β\nμ : MeasureTheory.Measure α\nf : MeasureTheory.SimpleFunc α β\nhf : ∀ (y : β), Ne y 0 → LT.lt (μ (Set.preimage (⇑f) (Singleton.singleton y))) Top.top\n⊢ LT.lt (μ (Function.support ⇑f)) Top.top","decl":"lemma measure_support_lt_top (f : α →ₛ β) (hf : ∀ y, y ≠ 0 → μ (f ⁻¹' {y}) < ∞) :\n    μ (support f) < ∞ := by\n  classical\n  rw [support_eq]\n  refine (measure_biUnion_finset_le _ _).trans_lt (ENNReal.sum_lt_top.mpr fun y hy => ?_)\n  rw [Finset.mem_filter] at hy\n  exact hf y hy.2\n\n"}
{"name":"MeasureTheory.SimpleFunc.finMeasSupp_iff_support","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\ninst✝ : Zero β\nμ : MeasureTheory.Measure α\nf : MeasureTheory.SimpleFunc α β\n⊢ Iff (f.FinMeasSupp μ) (LT.lt (μ (Function.support ⇑f)) Top.top)","decl":"theorem finMeasSupp_iff_support : f.FinMeasSupp μ ↔ μ (support f) < ∞ :=\n  Iff.rfl\n\n"}
{"name":"MeasureTheory.SimpleFunc.finMeasSupp_iff","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\ninst✝ : Zero β\nμ : MeasureTheory.Measure α\nf : MeasureTheory.SimpleFunc α β\n⊢ Iff (f.FinMeasSupp μ) (∀ (y : β), Ne y 0 → LT.lt (μ (Set.preimage (⇑f) (Singleton.singleton y))) Top.top)","decl":"theorem finMeasSupp_iff : f.FinMeasSupp μ ↔ ∀ y, y ≠ 0 → μ (f ⁻¹' {y}) < ∞ := by\n  classical\n  constructor\n  · refine fun h y hy => lt_of_le_of_lt (measure_mono ?_) h\n    exact fun x hx (H : f x = 0) => hy <| H ▸ Eq.symm hx\n  · intro H\n    rw [finMeasSupp_iff_support, support_eq]\n    exact measure_biUnion_lt_top (finite_toSet _) fun y hy ↦ H y (mem_filter.1 hy).2\n\n"}
{"name":"MeasureTheory.SimpleFunc.FinMeasSupp.meas_preimage_singleton_ne_zero","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\ninst✝ : Zero β\nμ : MeasureTheory.Measure α\nf : MeasureTheory.SimpleFunc α β\nh : f.FinMeasSupp μ\ny : β\nhy : Ne y 0\n⊢ LT.lt (μ (Set.preimage (⇑f) (Singleton.singleton y))) Top.top","decl":"theorem meas_preimage_singleton_ne_zero (h : f.FinMeasSupp μ) {y : β} (hy : y ≠ 0) :\n    μ (f ⁻¹' {y}) < ∞ :=\n  finMeasSupp_iff.1 h y hy\n\n"}
{"name":"MeasureTheory.SimpleFunc.FinMeasSupp.map","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nm : MeasurableSpace α\ninst✝¹ : Zero β\ninst✝ : Zero γ\nμ : MeasureTheory.Measure α\nf : MeasureTheory.SimpleFunc α β\ng : β → γ\nhf : f.FinMeasSupp μ\nhg : Eq (g 0) 0\n⊢ (MeasureTheory.SimpleFunc.map g f).FinMeasSupp μ","decl":"protected theorem map {g : β → γ} (hf : f.FinMeasSupp μ) (hg : g 0 = 0) : (f.map g).FinMeasSupp μ :=\n  flip lt_of_le_of_lt hf (measure_mono <| support_comp_subset hg f)\n\n"}
{"name":"MeasureTheory.SimpleFunc.FinMeasSupp.of_map","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nm : MeasurableSpace α\ninst✝¹ : Zero β\ninst✝ : Zero γ\nμ : MeasureTheory.Measure α\nf : MeasureTheory.SimpleFunc α β\ng : β → γ\nh : (MeasureTheory.SimpleFunc.map g f).FinMeasSupp μ\nhg : ∀ (b : β), Eq (g b) 0 → Eq b 0\n⊢ f.FinMeasSupp μ","decl":"theorem of_map {g : β → γ} (h : (f.map g).FinMeasSupp μ) (hg : ∀ b, g b = 0 → b = 0) :\n    f.FinMeasSupp μ :=\n  flip lt_of_le_of_lt h <| measure_mono <| support_subset_comp @(hg) _\n\n"}
{"name":"MeasureTheory.SimpleFunc.FinMeasSupp.map_iff","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nm : MeasurableSpace α\ninst✝¹ : Zero β\ninst✝ : Zero γ\nμ : MeasureTheory.Measure α\nf : MeasureTheory.SimpleFunc α β\ng : β → γ\nhg : ∀ {b : β}, Iff (Eq (g b) 0) (Eq b 0)\n⊢ Iff ((MeasureTheory.SimpleFunc.map g f).FinMeasSupp μ) (f.FinMeasSupp μ)","decl":"theorem map_iff {g : β → γ} (hg : ∀ {b}, g b = 0 ↔ b = 0) :\n    (f.map g).FinMeasSupp μ ↔ f.FinMeasSupp μ :=\n  ⟨fun h => h.of_map fun _ => hg.1, fun h => h.map <| hg.2 rfl⟩\n\n"}
{"name":"MeasureTheory.SimpleFunc.FinMeasSupp.pair","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nm : MeasurableSpace α\ninst✝¹ : Zero β\ninst✝ : Zero γ\nμ : MeasureTheory.Measure α\nf : MeasureTheory.SimpleFunc α β\ng : MeasureTheory.SimpleFunc α γ\nhf : f.FinMeasSupp μ\nhg : g.FinMeasSupp μ\n⊢ (f.pair g).FinMeasSupp μ","decl":"protected theorem pair {g : α →ₛ γ} (hf : f.FinMeasSupp μ) (hg : g.FinMeasSupp μ) :\n    (pair f g).FinMeasSupp μ :=\n  calc\n    μ (support <| pair f g) = μ (support f ∪ support g) := congr_arg μ <| support_prod_mk f g\n    _ ≤ μ (support f) + μ (support g) := measure_union_le _ _\n    _ < _ := add_lt_top.2 ⟨hf, hg⟩\n\n"}
{"name":"MeasureTheory.SimpleFunc.FinMeasSupp.map₂","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nδ : Type u_4\nm : MeasurableSpace α\ninst✝² : Zero β\ninst✝¹ : Zero γ\nμ : MeasureTheory.Measure α\nf : MeasureTheory.SimpleFunc α β\ninst✝ : Zero δ\nhf : f.FinMeasSupp μ\ng : MeasureTheory.SimpleFunc α γ\nhg : g.FinMeasSupp μ\nop : β → γ → δ\nH : Eq (op 0 0) 0\n⊢ (MeasureTheory.SimpleFunc.map (Function.uncurry op) (f.pair g)).FinMeasSupp μ","decl":"protected theorem map₂ [Zero δ] (hf : f.FinMeasSupp μ) {g : α →ₛ γ} (hg : g.FinMeasSupp μ)\n    {op : β → γ → δ} (H : op 0 0 = 0) : ((pair f g).map (Function.uncurry op)).FinMeasSupp μ :=\n  (hf.pair hg).map H\n\n"}
{"name":"MeasureTheory.SimpleFunc.FinMeasSupp.add","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nβ : Type u_5\ninst✝ : AddMonoid β\nf g : MeasureTheory.SimpleFunc α β\nhf : f.FinMeasSupp μ\nhg : g.FinMeasSupp μ\n⊢ (HAdd.hAdd f g).FinMeasSupp μ","decl":"protected theorem add {β} [AddMonoid β] {f g : α →ₛ β} (hf : f.FinMeasSupp μ)\n    (hg : g.FinMeasSupp μ) : (f + g).FinMeasSupp μ := by\n  rw [add_eq_map₂]\n  exact hf.map₂ hg (zero_add 0)\n\n"}
{"name":"MeasureTheory.SimpleFunc.FinMeasSupp.mul","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nβ : Type u_5\ninst✝ : MonoidWithZero β\nf g : MeasureTheory.SimpleFunc α β\nhf : f.FinMeasSupp μ\nhg : g.FinMeasSupp μ\n⊢ (HMul.hMul f g).FinMeasSupp μ","decl":"protected theorem mul {β} [MonoidWithZero β] {f g : α →ₛ β} (hf : f.FinMeasSupp μ)\n    (hg : g.FinMeasSupp μ) : (f * g).FinMeasSupp μ := by\n  rw [mul_eq_map₂]\n  exact hf.map₂ hg (zero_mul 0)\n\n"}
{"name":"MeasureTheory.SimpleFunc.FinMeasSupp.lintegral_lt_top","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : MeasureTheory.SimpleFunc α ENNReal\nhm : f.FinMeasSupp μ\nhf : Filter.Eventually (fun a => Ne (f a) Top.top) (MeasureTheory.ae μ)\n⊢ LT.lt (f.lintegral μ) Top.top","decl":"theorem lintegral_lt_top {f : α →ₛ ℝ≥0∞} (hm : f.FinMeasSupp μ) (hf : ∀ᵐ a ∂μ, f a ≠ ∞) :\n    f.lintegral μ < ∞ := by\n  refine sum_lt_top.2 fun a ha => ?_\n  rcases eq_or_ne a ∞ with (rfl | ha)\n  · simp only [ae_iff, Ne, Classical.not_not] at hf\n    simp [Set.preimage, hf]\n  · by_cases ha0 : a = 0\n    · subst a\n      simp\n    · exact mul_lt_top ha.lt_top (finMeasSupp_iff.1 hm _ ha0)\n\n"}
{"name":"MeasureTheory.SimpleFunc.FinMeasSupp.of_lintegral_ne_top","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : MeasureTheory.SimpleFunc α ENNReal\nh : Ne (f.lintegral μ) Top.top\n⊢ f.FinMeasSupp μ","decl":"theorem of_lintegral_ne_top {f : α →ₛ ℝ≥0∞} (h : f.lintegral μ ≠ ∞) : f.FinMeasSupp μ := by\n  refine finMeasSupp_iff.2 fun b hb => ?_\n  rw [f.lintegral_eq_of_subset' (Finset.subset_insert b _)] at h\n  refine ENNReal.lt_top_of_mul_ne_top_right ?_ hb\n  exact (lt_top_of_sum_ne_top h (Finset.mem_insert_self _ _)).ne\n\n"}
{"name":"MeasureTheory.SimpleFunc.FinMeasSupp.iff_lintegral_lt_top","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : MeasureTheory.SimpleFunc α ENNReal\nhf : Filter.Eventually (fun a => Ne (f a) Top.top) (MeasureTheory.ae μ)\n⊢ Iff (f.FinMeasSupp μ) (LT.lt (f.lintegral μ) Top.top)","decl":"theorem iff_lintegral_lt_top {f : α →ₛ ℝ≥0∞} (hf : ∀ᵐ a ∂μ, f a ≠ ∞) :\n    f.FinMeasSupp μ ↔ f.lintegral μ < ∞ :=\n  ⟨fun h => h.lintegral_lt_top hf, fun h => of_lintegral_ne_top h.ne⟩\n\n"}
{"name":"MeasureTheory.SimpleFunc.measure_support_lt_top_of_lintegral_ne_top","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : MeasureTheory.SimpleFunc α ENNReal\nhf : Ne (f.lintegral μ) Top.top\n⊢ LT.lt (μ (Function.support ⇑f)) Top.top","decl":"lemma measure_support_lt_top_of_lintegral_ne_top {f : α →ₛ ℝ≥0∞} (hf : f.lintegral μ ≠ ∞) :\n    μ (support f) < ∞ := by\n  refine measure_support_lt_top f ?_\n  rw [← finMeasSupp_iff]\n  exact FinMeasSupp.of_lintegral_ne_top hf\n\n"}
{"name":"MeasureTheory.SimpleFunc.induction","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_5\nγ : Type u_6\ninst✝¹ : MeasurableSpace α\ninst✝ : AddMonoid γ\nP : MeasureTheory.SimpleFunc α γ → Prop\nh_ind : ∀ (c : γ) {s : Set α} (hs : MeasurableSet s), P (MeasureTheory.SimpleFunc.piecewise s hs (MeasureTheory.SimpleFunc.const α c) (MeasureTheory.SimpleFunc.const α 0))\nh_add : ∀ ⦃f g : MeasureTheory.SimpleFunc α γ⦄, Disjoint (Function.support ⇑f) (Function.support ⇑g) → P f → P g → P (HAdd.hAdd f g)\nf : MeasureTheory.SimpleFunc α γ\n⊢ P f","decl":"/-- To prove something for an arbitrary simple function, it suffices to show\nthat the property holds for (multiples of) characteristic functions and is closed under\naddition (of functions with disjoint support).\n\nIt is possible to make the hypotheses in `h_add` a bit stronger, and such conditions can be added\nonce we need them (for example it is only necessary to consider the case where `g` is a multiple\nof a characteristic function, and that this multiple doesn't appear in the image of `f`) -/\n@[elab_as_elim]\nprotected theorem induction {α γ} [MeasurableSpace α] [AddMonoid γ] {P : SimpleFunc α γ → Prop}\n    (h_ind :\n      ∀ (c) {s} (hs : MeasurableSet s),\n        P (SimpleFunc.piecewise s hs (SimpleFunc.const _ c) (SimpleFunc.const _ 0)))\n    (h_add : ∀ ⦃f g : SimpleFunc α γ⦄, Disjoint (support f) (support g) → P f → P g → P (f + g))\n    (f : SimpleFunc α γ) : P f := by\n  classical\n  generalize h : f.range \\ {0} = s\n  rw [← Finset.coe_inj, Finset.coe_sdiff, Finset.coe_singleton, SimpleFunc.coe_range] at h\n  induction s using Finset.induction generalizing f with\n  | empty =>\n    rw [Finset.coe_empty, diff_eq_empty, range_subset_singleton] at h\n    convert h_ind 0 MeasurableSet.univ\n    ext x\n    simp [h]\n  | @insert x s hxs ih =>\n    have mx := f.measurableSet_preimage {x}\n    let g := SimpleFunc.piecewise (f ⁻¹' {x}) mx 0 f\n    have Pg : P g := by\n      apply ih\n      simp only [g, SimpleFunc.coe_piecewise, range_piecewise]\n      rw [image_compl_preimage, union_diff_distrib, diff_diff_comm, h, Finset.coe_insert,\n        insert_diff_self_of_not_mem, diff_eq_empty.mpr, Set.empty_union]\n      · rw [Set.image_subset_iff]\n        convert Set.subset_univ _\n        exact preimage_const_of_mem (mem_singleton _)\n      · rwa [Finset.mem_coe]\n    convert h_add _ Pg (h_ind x mx)\n    · ext1 y\n      by_cases hy : y ∈ f ⁻¹' {x}\n      · simpa [g, piecewise_eq_of_mem _ _ _ hy, -piecewise_eq_indicator]\n      · simp [g, piecewise_eq_of_not_mem _ _ _ hy, -piecewise_eq_indicator]\n    rw [disjoint_iff_inf_le]\n    rintro y\n    by_cases hy : y ∈ f ⁻¹' {x}\n    · simp [g, piecewise_eq_of_mem _ _ _ hy, -piecewise_eq_indicator]\n    · simp [piecewise_eq_of_not_mem _ _ _ hy, -piecewise_eq_indicator]\n\n"}
{"name":"Measurable.add_simpleFunc","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\nE : Type u_5\nx✝ : MeasurableSpace α\ninst✝² : MeasurableSpace E\ninst✝¹ : AddGroup E\ninst✝ : MeasurableAdd E\ng : α → E\nhg : Measurable g\nf : MeasureTheory.SimpleFunc α E\n⊢ Measurable (HAdd.hAdd g ⇑f)","decl":"/-- In a topological vector space, the addition of a measurable function and a simple function is\nmeasurable. -/\ntheorem _root_.Measurable.add_simpleFunc\n    {E : Type*} {_ : MeasurableSpace α} [MeasurableSpace E] [AddGroup E] [MeasurableAdd E]\n    {g : α → E} (hg : Measurable g) (f : SimpleFunc α E) :\n    Measurable (g + (f : α → E)) := by\n  classical\n  induction' f using SimpleFunc.induction with c s hs f f' hff' hf hf'\n  · simp only [SimpleFunc.const_zero, SimpleFunc.coe_piecewise, SimpleFunc.coe_const,\n      SimpleFunc.coe_zero]\n    rw [← s.piecewise_same g, ← piecewise_add]\n    exact Measurable.piecewise hs (hg.add_const _) (hg.add_const _)\n  · have : (g + ↑(f + f')) = (Function.support f).piecewise (g + (f : α → E)) (g + f') := by\n      ext x\n      by_cases hx : x ∈ Function.support f\n      · simpa only [SimpleFunc.coe_add, Pi.add_apply, Function.mem_support, ne_eq, not_not,\n          Set.piecewise_eq_of_mem _ _ _ hx, _root_.add_right_inj, add_right_eq_self]\n          using Set.disjoint_left.1 hff' hx\n      · simpa only [SimpleFunc.coe_add, Pi.add_apply, Function.mem_support, ne_eq, not_not,\n          Set.piecewise_eq_of_not_mem _ _ _ hx, _root_.add_right_inj, add_left_eq_self] using hx\n    rw [this]\n    exact Measurable.piecewise f.measurableSet_support hf hf'\n\n"}
{"name":"Measurable.simpleFunc_add","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\nE : Type u_5\nx✝ : MeasurableSpace α\ninst✝² : MeasurableSpace E\ninst✝¹ : AddGroup E\ninst✝ : MeasurableAdd E\ng : α → E\nhg : Measurable g\nf : MeasureTheory.SimpleFunc α E\n⊢ Measurable (HAdd.hAdd (⇑f) g)","decl":"/-- In a topological vector space, the addition of a simple function and a measurable function is\nmeasurable. -/\ntheorem _root_.Measurable.simpleFunc_add\n    {E : Type*} {_ : MeasurableSpace α} [MeasurableSpace E] [AddGroup E] [MeasurableAdd E]\n    {g : α → E} (hg : Measurable g) (f : SimpleFunc α E) :\n    Measurable ((f : α → E) + g) := by\n  classical\n  induction' f using SimpleFunc.induction with c s hs f f' hff' hf hf'\n  · simp only [SimpleFunc.const_zero, SimpleFunc.coe_piecewise, SimpleFunc.coe_const,\n      SimpleFunc.coe_zero]\n    rw [← s.piecewise_same g, ← piecewise_add]\n    exact Measurable.piecewise hs (hg.const_add _) (hg.const_add _)\n  · have : (↑(f + f') + g) = (Function.support f).piecewise ((f : α → E) + g) (f' + g) := by\n      ext x\n      by_cases hx : x ∈ Function.support f\n      · simpa only [coe_add, Pi.add_apply, Function.mem_support, ne_eq, not_not,\n          Set.piecewise_eq_of_mem _ _ _ hx, _root_.add_left_inj, add_right_eq_self]\n          using Set.disjoint_left.1 hff' hx\n      · simpa only [SimpleFunc.coe_add, Pi.add_apply, Function.mem_support, ne_eq, not_not,\n          Set.piecewise_eq_of_not_mem _ _ _ hx, _root_.add_left_inj, add_left_eq_self] using hx\n    rw [this]\n    exact Measurable.piecewise f.measurableSet_support hf hf'\n\n"}
{"name":"Measurable.ennreal_induction","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\nmα : MeasurableSpace α\nP : (α → ENNReal) → Prop\nh_ind : ∀ (c : ENNReal) ⦃s : Set α⦄, MeasurableSet s → P (s.indicator fun x => c)\nh_add : ∀ ⦃f g : α → ENNReal⦄, Disjoint (Function.support f) (Function.support g) → Measurable f → Measurable g → P f → P g → P (HAdd.hAdd f g)\nh_iSup : ∀ ⦃f : Nat → α → ENNReal⦄, (∀ (n : Nat), Measurable (f n)) → Monotone f → (∀ (n : Nat), P (f n)) → P fun x => iSup fun n => f n x\nf : α → ENNReal\nhf : Measurable f\n⊢ P f","decl":"/-- To prove something for an arbitrary measurable function into `ℝ≥0∞`, it suffices to show\nthat the property holds for (multiples of) characteristic functions and is closed under addition\nand supremum of increasing sequences of functions.\n\nIt is possible to make the hypotheses in the induction steps a bit stronger, and such conditions\ncan be added once we need them (for example in `h_add` it is only necessary to consider the sum of\na simple function with a multiple of a characteristic function and that the intersection\nof their images is a subset of `{0}`. -/\n@[elab_as_elim]\ntheorem Measurable.ennreal_induction {P : (α → ℝ≥0∞) → Prop}\n    (h_ind : ∀ (c : ℝ≥0∞) ⦃s⦄, MeasurableSet s → P (Set.indicator s fun _ => c))\n    (h_add :\n      ∀ ⦃f g : α → ℝ≥0∞⦄,\n        Disjoint (support f) (support g) → Measurable f → Measurable g → P f → P g → P (f + g))\n    (h_iSup :\n      ∀ ⦃f : ℕ → α → ℝ≥0∞⦄, (∀ n, Measurable (f n)) → Monotone f → (∀ n, P (f n)) →\n        P fun x => ⨆ n, f n x)\n    ⦃f : α → ℝ≥0∞⦄ (hf : Measurable f) : P f := by\n  convert h_iSup (fun n => (eapprox f n).measurable) (monotone_eapprox f) _ using 2\n  · rw [iSup_eapprox_apply hf]\n  · exact fun n =>\n      SimpleFunc.induction (fun c s hs => h_ind c hs)\n        (fun f g hfg hf hg => h_add hfg f.measurable g.measurable hf hg) (eapprox f n)\n\n"}
{"name":"Measurable.ennreal_sigmaFinite_induction","module":"Mathlib.MeasureTheory.Function.SimpleFunc","initialProofState":"α : Type u_1\nmα : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.SigmaFinite μ\nP : (α → ENNReal) → Prop\nh_ind : ∀ (c : ENNReal) ⦃s : Set α⦄, MeasurableSet s → LT.lt (μ s) Top.top → P (s.indicator fun x => c)\nh_add : ∀ ⦃f g : α → ENNReal⦄, Disjoint (Function.support f) (Function.support g) → Measurable f → Measurable g → P f → P g → P (HAdd.hAdd f g)\nh_iSup : ∀ ⦃f : Nat → α → ENNReal⦄, (∀ (n : Nat), Measurable (f n)) → Monotone f → (∀ (n : Nat), P (f n)) → P fun x => iSup fun n => f n x\nf : α → ENNReal\nhf : Measurable f\n⊢ P f","decl":"/-- To prove something for an arbitrary measurable function into `ℝ≥0∞`, it suffices to show\nthat the property holds for (multiples of) characteristic functions with finite mass according to\nsome sigma-finite measure and is closed under addition and supremum of increasing sequences of\nfunctions.\n\nIt is possible to make the hypotheses in the induction steps a bit stronger, and such conditions\ncan be added once we need them (for example in `h_add` it is only necessary to consider the sum of\na simple function with a multiple of a characteristic function and that the intersection\nof their images is a subset of `{0}`. -/\n@[elab_as_elim]\nlemma Measurable.ennreal_sigmaFinite_induction [SigmaFinite μ] {P : (α → ℝ≥0∞) → Prop}\n    (h_ind : ∀ (c : ℝ≥0∞) ⦃s⦄, MeasurableSet s → μ s < ∞ → P (Set.indicator s fun _ ↦ c))\n    (h_add :\n      ∀ ⦃f g : α → ℝ≥0∞⦄,\n        Disjoint (support f) (support g) → Measurable f → Measurable g → P f → P g → P (f + g))\n    (h_iSup :\n      ∀ ⦃f : ℕ → α → ℝ≥0∞⦄, (∀ n, Measurable (f n)) → Monotone f → (∀ n, P (f n)) →\n        P fun x => ⨆ n, f n x)\n    ⦃f : α → ℝ≥0∞⦄ (hf : Measurable f) : P f := by\n  refine Measurable.ennreal_induction (fun c s hs ↦ ?_) h_add h_iSup hf\n  convert h_iSup (f := fun n ↦ (s ∩ spanningSets μ n).indicator fun _ ↦ c)\n    (fun n ↦ measurable_const.indicator (hs.inter (measurableSet_spanningSets ..)))\n    (fun m n hmn a ↦ Set.indicator_le_indicator_of_subset (by gcongr) (by simp) _)\n    (fun n ↦ h_ind _ (hs.inter (measurableSet_spanningSets ..))\n      (measure_inter_lt_top_of_right_ne_top (measure_spanningSets_lt_top ..).ne)) with a\n  simp [← Set.indicator_iUnion_apply (M := ℝ≥0∞) rfl, ← Set.inter_iUnion]\n"}
