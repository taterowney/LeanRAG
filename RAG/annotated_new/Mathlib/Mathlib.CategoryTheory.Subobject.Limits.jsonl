{"name":"CategoryTheory.Limits.equalizerSubobject_arrow_assoc","module":"Mathlib.CategoryTheory.Subobject.Limits","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\ninst‚úù : CategoryTheory.Limits.HasEqualizer f g\nZ : C\nh : Quiver.Hom X Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.equalizerSubobjectIso f g).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.equalizer.Œπ f g) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.equalizerSubobject f g).arrow h)","decl":"@[reassoc (attr := simp)]\ntheorem equalizerSubobject_arrow :\n    (equalizerSubobjectIso f g).hom ‚â´ equalizer.Œπ f g = (equalizerSubobject f g).arrow := by\n  simp [equalizerSubobjectIso]\n\n"}
{"name":"CategoryTheory.Limits.equalizerSubobject_arrow","module":"Mathlib.CategoryTheory.Subobject.Limits","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\ninst‚úù : CategoryTheory.Limits.HasEqualizer f g\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.equalizerSubobjectIso f g).hom (CategoryTheory.Limits.equalizer.Œπ f g)) (CategoryTheory.Limits.equalizerSubobject f g).arrow","decl":"@[reassoc (attr := simp)]\ntheorem equalizerSubobject_arrow :\n    (equalizerSubobjectIso f g).hom ‚â´ equalizer.Œπ f g = (equalizerSubobject f g).arrow := by\n  simp [equalizerSubobjectIso]\n\n"}
{"name":"CategoryTheory.Limits.equalizerSubobject_arrow'","module":"Mathlib.CategoryTheory.Subobject.Limits","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\ninst‚úù : CategoryTheory.Limits.HasEqualizer f g\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.equalizerSubobjectIso f g).inv (CategoryTheory.Limits.equalizerSubobject f g).arrow) (CategoryTheory.Limits.equalizer.Œπ f g)","decl":"@[reassoc (attr := simp)]\ntheorem equalizerSubobject_arrow' :\n    (equalizerSubobjectIso f g).inv ‚â´ (equalizerSubobject f g).arrow = equalizer.Œπ f g := by\n  simp [equalizerSubobjectIso]\n\n"}
{"name":"CategoryTheory.Limits.equalizerSubobject_arrow'_assoc","module":"Mathlib.CategoryTheory.Subobject.Limits","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\ninst‚úù : CategoryTheory.Limits.HasEqualizer f g\nZ : C\nh : Quiver.Hom X Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.equalizerSubobjectIso f g).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.equalizerSubobject f g).arrow h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.equalizer.Œπ f g) h)","decl":"@[reassoc (attr := simp)]\ntheorem equalizerSubobject_arrow' :\n    (equalizerSubobjectIso f g).inv ‚â´ (equalizerSubobject f g).arrow = equalizer.Œπ f g := by\n  simp [equalizerSubobjectIso]\n\n"}
{"name":"CategoryTheory.Limits.equalizerSubobject_arrow_comp","module":"Mathlib.CategoryTheory.Subobject.Limits","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\ninst‚úù : CategoryTheory.Limits.HasEqualizer f g\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.equalizerSubobject f g).arrow f) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.equalizerSubobject f g).arrow g)","decl":"@[reassoc]\ntheorem equalizerSubobject_arrow_comp :\n    (equalizerSubobject f g).arrow ‚â´ f = (equalizerSubobject f g).arrow ‚â´ g := by\n  rw [‚Üê equalizerSubobject_arrow, Category.assoc, Category.assoc, equalizer.condition]\n\n"}
{"name":"CategoryTheory.Limits.equalizerSubobject_arrow_comp_assoc","module":"Mathlib.CategoryTheory.Subobject.Limits","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\ninst‚úù : CategoryTheory.Limits.HasEqualizer f g\nZ : C\nh : Quiver.Hom Y Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.equalizerSubobject f g).arrow (CategoryTheory.CategoryStruct.comp f h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.equalizerSubobject f g).arrow (CategoryTheory.CategoryStruct.comp g h))","decl":"@[reassoc]\ntheorem equalizerSubobject_arrow_comp :\n    (equalizerSubobject f g).arrow ‚â´ f = (equalizerSubobject f g).arrow ‚â´ g := by\n  rw [‚Üê equalizerSubobject_arrow, Category.assoc, Category.assoc, equalizer.condition]\n\n"}
{"name":"CategoryTheory.Limits.equalizerSubobject_factors","module":"Mathlib.CategoryTheory.Subobject.Limits","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\ninst‚úù : CategoryTheory.Limits.HasEqualizer f g\nW : C\nh : Quiver.Hom W X\nw : Eq (CategoryTheory.CategoryStruct.comp h f) (CategoryTheory.CategoryStruct.comp h g)\n‚ä¢ (CategoryTheory.Limits.equalizerSubobject f g).Factors h","decl":"theorem equalizerSubobject_factors {W : C} (h : W ‚ü∂ X) (w : h ‚â´ f = h ‚â´ g) :\n    (equalizerSubobject f g).Factors h :=\n  ‚ü®equalizer.lift h w, by simp‚ü©\n\n"}
{"name":"CategoryTheory.Limits.equalizerSubobject_factors_iff","module":"Mathlib.CategoryTheory.Subobject.Limits","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\ninst‚úù : CategoryTheory.Limits.HasEqualizer f g\nW : C\nh : Quiver.Hom W X\n‚ä¢ Iff ((CategoryTheory.Limits.equalizerSubobject f g).Factors h) (Eq (CategoryTheory.CategoryStruct.comp h f) (CategoryTheory.CategoryStruct.comp h g))","decl":"theorem equalizerSubobject_factors_iff {W : C} (h : W ‚ü∂ X) :\n    (equalizerSubobject f g).Factors h ‚Üî h ‚â´ f = h ‚â´ g :=\n  ‚ü®fun w => by\n    rw [‚Üê Subobject.factorThru_arrow _ _ w, Category.assoc, equalizerSubobject_arrow_comp,\n      Category.assoc],\n    equalizerSubobject_factors f g h‚ü©\n\n"}
{"name":"CategoryTheory.Limits.kernelSubobject_arrow_apply","module":"Mathlib.CategoryTheory.Subobject.Limits","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nX Y : C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms C\nf : Quiver.Hom X Y\ninst‚úù : CategoryTheory.Limits.HasKernel f\ninst : CategoryTheory.HasForget C\nx : (CategoryTheory.forget C).obj (CategoryTheory.Subobject.underlying.obj (CategoryTheory.Limits.kernelSubobject f))\n‚ä¢ Eq ((CategoryTheory.Limits.kernel.Œπ f) ((CategoryTheory.Limits.kernelSubobjectIso f).hom x)) ((CategoryTheory.Limits.kernelSubobject f).arrow x)","decl":"@[reassoc (attr := simp), elementwise (attr := simp)]\ntheorem kernelSubobject_arrow :\n    (kernelSubobjectIso f).hom ‚â´ kernel.Œπ f = (kernelSubobject f).arrow := by\n  simp [kernelSubobjectIso]\n\n"}
{"name":"CategoryTheory.Limits.kernelSubobject_arrow","module":"Mathlib.CategoryTheory.Subobject.Limits","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nX Y : C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms C\nf : Quiver.Hom X Y\ninst‚úù : CategoryTheory.Limits.HasKernel f\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.kernelSubobjectIso f).hom (CategoryTheory.Limits.kernel.Œπ f)) (CategoryTheory.Limits.kernelSubobject f).arrow","decl":"@[reassoc (attr := simp), elementwise (attr := simp)]\ntheorem kernelSubobject_arrow :\n    (kernelSubobjectIso f).hom ‚â´ kernel.Œπ f = (kernelSubobject f).arrow := by\n  simp [kernelSubobjectIso]\n\n"}
{"name":"CategoryTheory.Limits.kernelSubobject_arrow_assoc","module":"Mathlib.CategoryTheory.Subobject.Limits","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nX Y : C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms C\nf : Quiver.Hom X Y\ninst‚úù : CategoryTheory.Limits.HasKernel f\nZ : C\nh : Quiver.Hom X Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.kernelSubobjectIso f).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.kernel.Œπ f) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.kernelSubobject f).arrow h)","decl":"@[reassoc (attr := simp), elementwise (attr := simp)]\ntheorem kernelSubobject_arrow :\n    (kernelSubobjectIso f).hom ‚â´ kernel.Œπ f = (kernelSubobject f).arrow := by\n  simp [kernelSubobjectIso]\n\n"}
{"name":"CategoryTheory.Limits.kernelSubobject_arrow'","module":"Mathlib.CategoryTheory.Subobject.Limits","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nX Y : C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms C\nf : Quiver.Hom X Y\ninst‚úù : CategoryTheory.Limits.HasKernel f\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.kernelSubobjectIso f).inv (CategoryTheory.Limits.kernelSubobject f).arrow) (CategoryTheory.Limits.kernel.Œπ f)","decl":"@[reassoc (attr := simp), elementwise (attr := simp)]\ntheorem kernelSubobject_arrow' :\n    (kernelSubobjectIso f).inv ‚â´ (kernelSubobject f).arrow = kernel.Œπ f := by\n  simp [kernelSubobjectIso]\n\n"}
{"name":"CategoryTheory.Limits.kernelSubobject_arrow'_apply","module":"Mathlib.CategoryTheory.Subobject.Limits","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nX Y : C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms C\nf : Quiver.Hom X Y\ninst‚úù : CategoryTheory.Limits.HasKernel f\ninst : CategoryTheory.HasForget C\nx : (CategoryTheory.forget C).obj (CategoryTheory.Limits.kernel f)\n‚ä¢ Eq ((CategoryTheory.Limits.kernelSubobject f).arrow ((CategoryTheory.Limits.kernelSubobjectIso f).inv x)) ((CategoryTheory.Limits.kernel.Œπ f) x)","decl":"@[reassoc (attr := simp), elementwise (attr := simp)]\ntheorem kernelSubobject_arrow' :\n    (kernelSubobjectIso f).inv ‚â´ (kernelSubobject f).arrow = kernel.Œπ f := by\n  simp [kernelSubobjectIso]\n\n"}
{"name":"CategoryTheory.Limits.kernelSubobject_arrow'_assoc","module":"Mathlib.CategoryTheory.Subobject.Limits","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nX Y : C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms C\nf : Quiver.Hom X Y\ninst‚úù : CategoryTheory.Limits.HasKernel f\nZ : C\nh : Quiver.Hom X Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.kernelSubobjectIso f).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.kernelSubobject f).arrow h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.kernel.Œπ f) h)","decl":"@[reassoc (attr := simp), elementwise (attr := simp)]\ntheorem kernelSubobject_arrow' :\n    (kernelSubobjectIso f).inv ‚â´ (kernelSubobject f).arrow = kernel.Œπ f := by\n  simp [kernelSubobjectIso]\n\n"}
{"name":"CategoryTheory.Limits.kernelSubobject_arrow_comp_apply","module":"Mathlib.CategoryTheory.Subobject.Limits","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nX Y : C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms C\nf : Quiver.Hom X Y\ninst‚úù : CategoryTheory.Limits.HasKernel f\ninst : CategoryTheory.HasForget C\nx : (CategoryTheory.forget C).obj (CategoryTheory.Subobject.underlying.obj (CategoryTheory.Limits.kernelSubobject f))\n‚ä¢ Eq (f ((CategoryTheory.Limits.kernelSubobject f).arrow x)) (0 x)","decl":"@[reassoc (attr := simp), elementwise (attr := simp)]\ntheorem kernelSubobject_arrow_comp : (kernelSubobject f).arrow ‚â´ f = 0 := by\n  rw [‚Üê kernelSubobject_arrow]\n  simp only [Category.assoc, kernel.condition, comp_zero]\n\n"}
{"name":"CategoryTheory.Limits.kernelSubobject_arrow_comp_assoc","module":"Mathlib.CategoryTheory.Subobject.Limits","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nX Y : C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms C\nf : Quiver.Hom X Y\ninst‚úù : CategoryTheory.Limits.HasKernel f\nZ : C\nh : Quiver.Hom Y Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.kernelSubobject f).arrow (CategoryTheory.CategoryStruct.comp f h)) (CategoryTheory.CategoryStruct.comp 0 h)","decl":"@[reassoc (attr := simp), elementwise (attr := simp)]\ntheorem kernelSubobject_arrow_comp : (kernelSubobject f).arrow ‚â´ f = 0 := by\n  rw [‚Üê kernelSubobject_arrow]\n  simp only [Category.assoc, kernel.condition, comp_zero]\n\n"}
{"name":"CategoryTheory.Limits.kernelSubobject_arrow_comp","module":"Mathlib.CategoryTheory.Subobject.Limits","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nX Y : C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms C\nf : Quiver.Hom X Y\ninst‚úù : CategoryTheory.Limits.HasKernel f\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.kernelSubobject f).arrow f) 0","decl":"@[reassoc (attr := simp), elementwise (attr := simp)]\ntheorem kernelSubobject_arrow_comp : (kernelSubobject f).arrow ‚â´ f = 0 := by\n  rw [‚Üê kernelSubobject_arrow]\n  simp only [Category.assoc, kernel.condition, comp_zero]\n\n"}
{"name":"CategoryTheory.Limits.kernelSubobject_factors","module":"Mathlib.CategoryTheory.Subobject.Limits","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nX Y : C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms C\nf : Quiver.Hom X Y\ninst‚úù : CategoryTheory.Limits.HasKernel f\nW : C\nh : Quiver.Hom W X\nw : Eq (CategoryTheory.CategoryStruct.comp h f) 0\n‚ä¢ (CategoryTheory.Limits.kernelSubobject f).Factors h","decl":"theorem kernelSubobject_factors {W : C} (h : W ‚ü∂ X) (w : h ‚â´ f = 0) :\n    (kernelSubobject f).Factors h :=\n  ‚ü®kernel.lift _ h w, by simp‚ü©\n\n"}
{"name":"CategoryTheory.Limits.kernelSubobject_factors_iff","module":"Mathlib.CategoryTheory.Subobject.Limits","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nX Y : C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms C\nf : Quiver.Hom X Y\ninst‚úù : CategoryTheory.Limits.HasKernel f\nW : C\nh : Quiver.Hom W X\n‚ä¢ Iff ((CategoryTheory.Limits.kernelSubobject f).Factors h) (Eq (CategoryTheory.CategoryStruct.comp h f) 0)","decl":"theorem kernelSubobject_factors_iff {W : C} (h : W ‚ü∂ X) :\n    (kernelSubobject f).Factors h ‚Üî h ‚â´ f = 0 :=\n  ‚ü®fun w => by\n    rw [‚Üê Subobject.factorThru_arrow _ _ w, Category.assoc, kernelSubobject_arrow_comp,\n      comp_zero],\n    kernelSubobject_factors f h‚ü©\n\n"}
{"name":"CategoryTheory.Limits.factorThruKernelSubobject_comp_arrow","module":"Mathlib.CategoryTheory.Subobject.Limits","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nX Y : C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms C\nf : Quiver.Hom X Y\ninst‚úù : CategoryTheory.Limits.HasKernel f\nW : C\nh : Quiver.Hom W X\nw : Eq (CategoryTheory.CategoryStruct.comp h f) 0\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.factorThruKernelSubobject f h w) (CategoryTheory.Limits.kernelSubobject f).arrow) h","decl":"@[simp]\ntheorem factorThruKernelSubobject_comp_arrow {W : C} (h : W ‚ü∂ X) (w : h ‚â´ f = 0) :\n    factorThruKernelSubobject f h w ‚â´ (kernelSubobject f).arrow = h := by\n  dsimp [factorThruKernelSubobject]\n  simp\n\n"}
{"name":"CategoryTheory.Limits.factorThruKernelSubobject_comp_kernelSubobjectIso","module":"Mathlib.CategoryTheory.Subobject.Limits","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nX Y : C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms C\nf : Quiver.Hom X Y\ninst‚úù : CategoryTheory.Limits.HasKernel f\nW : C\nh : Quiver.Hom W X\nw : Eq (CategoryTheory.CategoryStruct.comp h f) 0\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.factorThruKernelSubobject f h w) (CategoryTheory.Limits.kernelSubobjectIso f).hom) (CategoryTheory.Limits.kernel.lift f h w)","decl":"@[simp]\ntheorem factorThruKernelSubobject_comp_kernelSubobjectIso {W : C} (h : W ‚ü∂ X) (w : h ‚â´ f = 0) :\n    factorThruKernelSubobject f h w ‚â´ (kernelSubobjectIso f).hom = kernel.lift f h w :=\n  (cancel_mono (kernel.Œπ f)).1 <| by simp\n\n"}
{"name":"CategoryTheory.Limits.kernelSubobjectMap_arrow_apply","module":"Mathlib.CategoryTheory.Subobject.Limits","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nX Y : C\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroMorphisms C\nf : Quiver.Hom X Y\ninst‚úù¬π : CategoryTheory.Limits.HasKernel f\nX' Y' : C\nf' : Quiver.Hom X' Y'\ninst‚úù : CategoryTheory.Limits.HasKernel f'\nsq : Quiver.Hom (CategoryTheory.Arrow.mk f) (CategoryTheory.Arrow.mk f')\ninst : CategoryTheory.HasForget C\nx : (CategoryTheory.forget C).obj (CategoryTheory.Subobject.underlying.obj (CategoryTheory.Limits.kernelSubobject f))\n‚ä¢ Eq ((CategoryTheory.Limits.kernelSubobject f').arrow ((CategoryTheory.Limits.kernelSubobjectMap sq) x)) (sq.left ((CategoryTheory.Limits.kernelSubobject f).arrow x))","decl":"@[reassoc (attr := simp), elementwise (attr := simp)]\ntheorem kernelSubobjectMap_arrow (sq : Arrow.mk f ‚ü∂ Arrow.mk f') :\n    kernelSubobjectMap sq ‚â´ (kernelSubobject f').arrow = (kernelSubobject f).arrow ‚â´ sq.left := by\n  simp [kernelSubobjectMap]\n\n"}
{"name":"CategoryTheory.Limits.kernelSubobjectMap_arrow_assoc","module":"Mathlib.CategoryTheory.Subobject.Limits","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nX Y : C\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroMorphisms C\nf : Quiver.Hom X Y\ninst‚úù¬π : CategoryTheory.Limits.HasKernel f\nX' Y' : C\nf' : Quiver.Hom X' Y'\ninst‚úù : CategoryTheory.Limits.HasKernel f'\nsq : Quiver.Hom (CategoryTheory.Arrow.mk f) (CategoryTheory.Arrow.mk f')\nZ : C\nh : Quiver.Hom X' Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.kernelSubobjectMap sq) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.kernelSubobject f').arrow h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.kernelSubobject f).arrow (CategoryTheory.CategoryStruct.comp sq.left h))","decl":"@[reassoc (attr := simp), elementwise (attr := simp)]\ntheorem kernelSubobjectMap_arrow (sq : Arrow.mk f ‚ü∂ Arrow.mk f') :\n    kernelSubobjectMap sq ‚â´ (kernelSubobject f').arrow = (kernelSubobject f).arrow ‚â´ sq.left := by\n  simp [kernelSubobjectMap]\n\n"}
{"name":"CategoryTheory.Limits.kernelSubobjectMap_arrow","module":"Mathlib.CategoryTheory.Subobject.Limits","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nX Y : C\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroMorphisms C\nf : Quiver.Hom X Y\ninst‚úù¬π : CategoryTheory.Limits.HasKernel f\nX' Y' : C\nf' : Quiver.Hom X' Y'\ninst‚úù : CategoryTheory.Limits.HasKernel f'\nsq : Quiver.Hom (CategoryTheory.Arrow.mk f) (CategoryTheory.Arrow.mk f')\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.kernelSubobjectMap sq) (CategoryTheory.Limits.kernelSubobject f').arrow) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.kernelSubobject f).arrow sq.left)","decl":"@[reassoc (attr := simp), elementwise (attr := simp)]\ntheorem kernelSubobjectMap_arrow (sq : Arrow.mk f ‚ü∂ Arrow.mk f') :\n    kernelSubobjectMap sq ‚â´ (kernelSubobject f').arrow = (kernelSubobject f).arrow ‚â´ sq.left := by\n  simp [kernelSubobjectMap]\n\n"}
{"name":"CategoryTheory.Limits.kernelSubobjectMap_id","module":"Mathlib.CategoryTheory.Subobject.Limits","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nX Y : C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms C\nf : Quiver.Hom X Y\ninst‚úù : CategoryTheory.Limits.HasKernel f\n‚ä¢ Eq (CategoryTheory.Limits.kernelSubobjectMap (CategoryTheory.CategoryStruct.id (CategoryTheory.Arrow.mk f))) (CategoryTheory.CategoryStruct.id (CategoryTheory.Subobject.underlying.obj (CategoryTheory.Limits.kernelSubobject f)))","decl":"@[simp]\ntheorem kernelSubobjectMap_id : kernelSubobjectMap (ùüô (Arrow.mk f)) = ùüô _ := by aesop_cat\n\n"}
{"name":"CategoryTheory.Limits.kernelSubobjectMap_comp","module":"Mathlib.CategoryTheory.Subobject.Limits","initialProofState":"C : Type u\ninst‚úù‚Å¥ : CategoryTheory.Category.{v, u} C\nX Y : C\ninst‚úù¬≥ : CategoryTheory.Limits.HasZeroMorphisms C\nf : Quiver.Hom X Y\ninst‚úù¬≤ : CategoryTheory.Limits.HasKernel f\nX' Y' : C\nf' : Quiver.Hom X' Y'\ninst‚úù¬π : CategoryTheory.Limits.HasKernel f'\nX'' Y'' : C\nf'' : Quiver.Hom X'' Y''\ninst‚úù : CategoryTheory.Limits.HasKernel f''\nsq : Quiver.Hom (CategoryTheory.Arrow.mk f) (CategoryTheory.Arrow.mk f')\nsq' : Quiver.Hom (CategoryTheory.Arrow.mk f') (CategoryTheory.Arrow.mk f'')\n‚ä¢ Eq (CategoryTheory.Limits.kernelSubobjectMap (CategoryTheory.CategoryStruct.comp sq sq')) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.kernelSubobjectMap sq) (CategoryTheory.Limits.kernelSubobjectMap sq'))","decl":"@[simp]\ntheorem kernelSubobjectMap_comp {X'' Y'' : C} {f'' : X'' ‚ü∂ Y''} [HasKernel f'']\n    (sq : Arrow.mk f ‚ü∂ Arrow.mk f') (sq' : Arrow.mk f' ‚ü∂ Arrow.mk f'') :\n    kernelSubobjectMap (sq ‚â´ sq') = kernelSubobjectMap sq ‚â´ kernelSubobjectMap sq' := by\n  aesop_cat\n\n"}
{"name":"CategoryTheory.Limits.kernel_map_comp_kernelSubobjectIso_inv_assoc","module":"Mathlib.CategoryTheory.Subobject.Limits","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nX Y : C\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroMorphisms C\nf : Quiver.Hom X Y\ninst‚úù¬π : CategoryTheory.Limits.HasKernel f\nX' Y' : C\nf' : Quiver.Hom X' Y'\ninst‚úù : CategoryTheory.Limits.HasKernel f'\nsq : Quiver.Hom (CategoryTheory.Arrow.mk f) (CategoryTheory.Arrow.mk f')\nZ : C\nh : Quiver.Hom (CategoryTheory.Subobject.underlying.obj (CategoryTheory.Limits.kernelSubobject f')) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.kernel.map f f' sq.left sq.right ‚ãØ) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.kernelSubobjectIso f').inv h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.kernelSubobjectIso f).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.kernelSubobjectMap sq) h))","decl":"@[reassoc]\ntheorem kernel_map_comp_kernelSubobjectIso_inv (sq : Arrow.mk f ‚ü∂ Arrow.mk f') :\n    kernel.map f f' sq.1 sq.2 sq.3.symm ‚â´ (kernelSubobjectIso _).inv =\n      (kernelSubobjectIso _).inv ‚â´ kernelSubobjectMap sq := by aesop_cat\n\n"}
{"name":"CategoryTheory.Limits.kernel_map_comp_kernelSubobjectIso_inv","module":"Mathlib.CategoryTheory.Subobject.Limits","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nX Y : C\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroMorphisms C\nf : Quiver.Hom X Y\ninst‚úù¬π : CategoryTheory.Limits.HasKernel f\nX' Y' : C\nf' : Quiver.Hom X' Y'\ninst‚úù : CategoryTheory.Limits.HasKernel f'\nsq : Quiver.Hom (CategoryTheory.Arrow.mk f) (CategoryTheory.Arrow.mk f')\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.kernel.map f f' sq.left sq.right ‚ãØ) (CategoryTheory.Limits.kernelSubobjectIso f').inv) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.kernelSubobjectIso f).inv (CategoryTheory.Limits.kernelSubobjectMap sq))","decl":"@[reassoc]\ntheorem kernel_map_comp_kernelSubobjectIso_inv (sq : Arrow.mk f ‚ü∂ Arrow.mk f') :\n    kernel.map f f' sq.1 sq.2 sq.3.symm ‚â´ (kernelSubobjectIso _).inv =\n      (kernelSubobjectIso _).inv ‚â´ kernelSubobjectMap sq := by aesop_cat\n\n"}
{"name":"CategoryTheory.Limits.kernelSubobjectIso_comp_kernel_map_assoc","module":"Mathlib.CategoryTheory.Subobject.Limits","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nX Y : C\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroMorphisms C\nf : Quiver.Hom X Y\ninst‚úù¬π : CategoryTheory.Limits.HasKernel f\nX' Y' : C\nf' : Quiver.Hom X' Y'\ninst‚úù : CategoryTheory.Limits.HasKernel f'\nsq : Quiver.Hom (CategoryTheory.Arrow.mk f) (CategoryTheory.Arrow.mk f')\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.kernel f') Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.kernelSubobjectIso f).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.kernel.map f f' sq.left sq.right ‚ãØ) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.kernelSubobjectMap sq) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.kernelSubobjectIso f').hom h))","decl":"@[reassoc]\ntheorem kernelSubobjectIso_comp_kernel_map (sq : Arrow.mk f ‚ü∂ Arrow.mk f') :\n    (kernelSubobjectIso _).hom ‚â´ kernel.map f f' sq.1 sq.2 sq.3.symm =\n      kernelSubobjectMap sq ‚â´ (kernelSubobjectIso _).hom := by\n  simp [‚Üê Iso.comp_inv_eq, kernel_map_comp_kernelSubobjectIso_inv]\n\n"}
{"name":"CategoryTheory.Limits.kernelSubobjectIso_comp_kernel_map","module":"Mathlib.CategoryTheory.Subobject.Limits","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nX Y : C\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroMorphisms C\nf : Quiver.Hom X Y\ninst‚úù¬π : CategoryTheory.Limits.HasKernel f\nX' Y' : C\nf' : Quiver.Hom X' Y'\ninst‚úù : CategoryTheory.Limits.HasKernel f'\nsq : Quiver.Hom (CategoryTheory.Arrow.mk f) (CategoryTheory.Arrow.mk f')\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.kernelSubobjectIso f).hom (CategoryTheory.Limits.kernel.map f f' sq.left sq.right ‚ãØ)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.kernelSubobjectMap sq) (CategoryTheory.Limits.kernelSubobjectIso f').hom)","decl":"@[reassoc]\ntheorem kernelSubobjectIso_comp_kernel_map (sq : Arrow.mk f ‚ü∂ Arrow.mk f') :\n    (kernelSubobjectIso _).hom ‚â´ kernel.map f f' sq.1 sq.2 sq.3.symm =\n      kernelSubobjectMap sq ‚â´ (kernelSubobjectIso _).hom := by\n  simp [‚Üê Iso.comp_inv_eq, kernel_map_comp_kernelSubobjectIso_inv]\n\n"}
{"name":"CategoryTheory.Limits.kernelSubobject_zero","module":"Mathlib.CategoryTheory.Subobject.Limits","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nA B : C\n‚ä¢ Eq (CategoryTheory.Limits.kernelSubobject 0) Top.top","decl":"@[simp]\ntheorem kernelSubobject_zero {A B : C} : kernelSubobject (0 : A ‚ü∂ B) = ‚ä§ :=\n  (isIso_iff_mk_eq_top _).mp (by infer_instance)\n\n"}
{"name":"CategoryTheory.Limits.isIso_kernelSubobject_zero_arrow","module":"Mathlib.CategoryTheory.Subobject.Limits","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y : C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\n‚ä¢ CategoryTheory.IsIso (CategoryTheory.Limits.kernelSubobject 0).arrow","decl":"instance isIso_kernelSubobject_zero_arrow : IsIso (kernelSubobject (0 : X ‚ü∂ Y)).arrow :=\n  (isIso_arrow_iff_eq_top _).mpr kernelSubobject_zero\n\n"}
{"name":"CategoryTheory.Limits.le_kernelSubobject","module":"Mathlib.CategoryTheory.Subobject.Limits","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nX Y : C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms C\nf : Quiver.Hom X Y\ninst‚úù : CategoryTheory.Limits.HasKernel f\nA : CategoryTheory.Subobject X\nh : Eq (CategoryTheory.CategoryStruct.comp A.arrow f) 0\n‚ä¢ LE.le A (CategoryTheory.Limits.kernelSubobject f)","decl":"theorem le_kernelSubobject (A : Subobject X) (h : A.arrow ‚â´ f = 0) : A ‚â§ kernelSubobject f :=\n  Subobject.le_mk_of_comm (kernel.lift f A.arrow h) (by simp)\n\n"}
{"name":"CategoryTheory.Limits.kernelSubobjectIsoComp_hom_arrow","module":"Mathlib.CategoryTheory.Subobject.Limits","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nX Y : C\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroMorphisms C\nX' : C\nf : Quiver.Hom X' X\ninst‚úù¬π : CategoryTheory.IsIso f\ng : Quiver.Hom X Y\ninst‚úù : CategoryTheory.Limits.HasKernel g\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.kernelSubobjectIsoComp f g).hom (CategoryTheory.Limits.kernelSubobject g).arrow) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.kernelSubobject (CategoryTheory.CategoryStruct.comp f g)).arrow f)","decl":"@[simp]\ntheorem kernelSubobjectIsoComp_hom_arrow {X' : C} (f : X' ‚ü∂ X) [IsIso f] (g : X ‚ü∂ Y) [HasKernel g] :\n    (kernelSubobjectIsoComp f g).hom ‚â´ (kernelSubobject g).arrow =\n      (kernelSubobject (f ‚â´ g)).arrow ‚â´ f := by\n  simp [kernelSubobjectIsoComp]\n\n"}
{"name":"CategoryTheory.Limits.kernelSubobjectIsoComp_inv_arrow","module":"Mathlib.CategoryTheory.Subobject.Limits","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nX Y : C\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroMorphisms C\nX' : C\nf : Quiver.Hom X' X\ninst‚úù¬π : CategoryTheory.IsIso f\ng : Quiver.Hom X Y\ninst‚úù : CategoryTheory.Limits.HasKernel g\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.kernelSubobjectIsoComp f g).inv (CategoryTheory.Limits.kernelSubobject (CategoryTheory.CategoryStruct.comp f g)).arrow) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.kernelSubobject g).arrow (CategoryTheory.inv f))","decl":"@[simp]\ntheorem kernelSubobjectIsoComp_inv_arrow {X' : C} (f : X' ‚ü∂ X) [IsIso f] (g : X ‚ü∂ Y) [HasKernel g] :\n    (kernelSubobjectIsoComp f g).inv ‚â´ (kernelSubobject (f ‚â´ g)).arrow =\n      (kernelSubobject g).arrow ‚â´ inv f := by\n  simp [kernelSubobjectIsoComp]\n\n"}
{"name":"CategoryTheory.Limits.kernelSubobject_comp_le","module":"Mathlib.CategoryTheory.Subobject.Limits","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nX Y : C\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroMorphisms C\nf : Quiver.Hom X Y\ninst‚úù¬π : CategoryTheory.Limits.HasKernel f\nZ : C\nh : Quiver.Hom Y Z\ninst‚úù : CategoryTheory.Limits.HasKernel (CategoryTheory.CategoryStruct.comp f h)\n‚ä¢ LE.le (CategoryTheory.Limits.kernelSubobject f) (CategoryTheory.Limits.kernelSubobject (CategoryTheory.CategoryStruct.comp f h))","decl":"/-- The kernel of `f` is always a smaller subobject than the kernel of `f ‚â´ h`. -/\ntheorem kernelSubobject_comp_le (f : X ‚ü∂ Y) [HasKernel f] {Z : C} (h : Y ‚ü∂ Z) [HasKernel (f ‚â´ h)] :\n    kernelSubobject f ‚â§ kernelSubobject (f ‚â´ h) :=\n  le_kernelSubobject _ _ (by simp)\n\n"}
{"name":"CategoryTheory.Limits.kernelSubobject_comp_mono","module":"Mathlib.CategoryTheory.Subobject.Limits","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nX Y : C\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroMorphisms C\nf : Quiver.Hom X Y\ninst‚úù¬π : CategoryTheory.Limits.HasKernel f\nZ : C\nh : Quiver.Hom Y Z\ninst‚úù : CategoryTheory.Mono h\n‚ä¢ Eq (CategoryTheory.Limits.kernelSubobject (CategoryTheory.CategoryStruct.comp f h)) (CategoryTheory.Limits.kernelSubobject f)","decl":"/-- Postcomposing by a monomorphism does not change the kernel subobject. -/\n@[simp]\ntheorem kernelSubobject_comp_mono (f : X ‚ü∂ Y) [HasKernel f] {Z : C} (h : Y ‚ü∂ Z) [Mono h] :\n    kernelSubobject (f ‚â´ h) = kernelSubobject f :=\n  le_antisymm (le_kernelSubobject _ _ ((cancel_mono h).mp (by simp))) (kernelSubobject_comp_le f h)\n\n"}
{"name":"CategoryTheory.Limits.kernelSubobject_comp_mono_isIso","module":"Mathlib.CategoryTheory.Subobject.Limits","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nX Y : C\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroMorphisms C\nf : Quiver.Hom X Y\ninst‚úù¬π : CategoryTheory.Limits.HasKernel f\nZ : C\nh : Quiver.Hom Y Z\ninst‚úù : CategoryTheory.Mono h\n‚ä¢ CategoryTheory.IsIso ((CategoryTheory.Limits.kernelSubobject f).ofLE (CategoryTheory.Limits.kernelSubobject (CategoryTheory.CategoryStruct.comp f h)) ‚ãØ)","decl":"instance kernelSubobject_comp_mono_isIso (f : X ‚ü∂ Y) [HasKernel f] {Z : C} (h : Y ‚ü∂ Z) [Mono h] :\n    IsIso (Subobject.ofLE _ _ (kernelSubobject_comp_le f h)) := by\n  rw [ofLE_mk_le_mk_of_comm (kernelCompMono f h).inv]\n  ¬∑ infer_instance\n  ¬∑ simp\n\n"}
{"name":"CategoryTheory.Limits.cokernelOrderHom_coe","module":"Mathlib.CategoryTheory.Subobject.Limits","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms C\ninst‚úù : CategoryTheory.Limits.HasCokernels C\nX : C\na‚úù : CategoryTheory.Subobject X\n‚ä¢ Eq ((CategoryTheory.Limits.cokernelOrderHom X) a‚úù) (CategoryTheory.Subobject.lift (fun x f x_1 => CategoryTheory.Subobject.mk (CategoryTheory.Limits.cokernel.œÄ f).op) ‚ãØ a‚úù)","decl":"/-- Taking cokernels is an order-reversing map from the subobjects of `X` to the quotient objects\n    of `X`. -/\n@[simps]\ndef cokernelOrderHom [HasCokernels C] (X : C) : Subobject X ‚Üío (Subobject (op X))·µí·µà where\n  toFun :=\n    Subobject.lift (fun _ f _ => Subobject.mk (cokernel.œÄ f).op)\n      (by\n        rintro A B f g hf hg i rfl\n        refine Subobject.mk_eq_mk_of_comm _ _ (Iso.op ?_) (Quiver.Hom.unop_inj ?_)\n        ¬∑ exact (IsColimit.coconePointUniqueUpToIso (colimit.isColimit _)\n            (isCokernelEpiComp (colimit.isColimit _) i.hom rfl)).symm\n        ¬∑ simp only [Iso.comp_inv_eq, Iso.op_hom, Iso.symm_hom, unop_comp, Quiver.Hom.unop_op,\n            colimit.comp_coconePointUniqueUpToIso_hom, Cofork.ofœÄ_Œπ_app,\n            coequalizer.cofork_œÄ])\n  monotone' :=\n    Subobject.ind‚ÇÇ _ <| by\n      intro A B f g hf hg h\n      dsimp only [Subobject.lift_mk]\n      refine Subobject.mk_le_mk_of_comm (cokernel.desc f (cokernel.œÄ g) ?_).op ?_\n      ¬∑ rw [‚Üê Subobject.ofMkLEMk_comp h, Category.assoc, cokernel.condition, comp_zero]\n      ¬∑ exact Quiver.Hom.unop_inj (cokernel.œÄ_desc _ _ _)\n\n"}
{"name":"CategoryTheory.Limits.kernelOrderHom_coe","module":"Mathlib.CategoryTheory.Subobject.Limits","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms C\ninst‚úù : CategoryTheory.Limits.HasKernels C\nX : C\na‚úù : CategoryTheory.Subobject { unop := X }\n‚ä¢ Eq ((CategoryTheory.Limits.kernelOrderHom X) a‚úù) (CategoryTheory.Subobject.lift (fun x f x_1 => CategoryTheory.Subobject.mk (CategoryTheory.Limits.kernel.Œπ f.unop)) ‚ãØ a‚úù)","decl":"/-- Taking kernels is an order-reversing map from the quotient objects of `X` to the subobjects of\n    `X`. -/\n@[simps]\ndef kernelOrderHom [HasKernels C] (X : C) : (Subobject (op X))·µí·µà ‚Üío Subobject X where\n  toFun :=\n    Subobject.lift (fun _ f _ => Subobject.mk (kernel.Œπ f.unop))\n      (by\n        rintro A B f g hf hg i rfl\n        refine Subobject.mk_eq_mk_of_comm _ _ ?_ ?_\n        ¬∑ exact\n            IsLimit.conePointUniqueUpToIso (limit.isLimit _)\n              (isKernelCompMono (limit.isLimit (parallelPair g.unop 0)) i.unop.hom rfl)\n        ¬∑ dsimp\n          simp only [‚Üê Iso.eq_inv_comp, limit.conePointUniqueUpToIso_inv_comp,\n            Fork.ofŒπ_œÄ_app])\n  monotone' :=\n    Subobject.ind‚ÇÇ _ <| by\n      intro A B f g hf hg h\n      dsimp only [Subobject.lift_mk]\n      refine Subobject.mk_le_mk_of_comm (kernel.lift g.unop (kernel.Œπ f.unop) ?_) ?_\n      ¬∑ rw [‚Üê Subobject.ofMkLEMk_comp h, unop_comp, kernel.condition_assoc, zero_comp]\n      ¬∑ exact Quiver.Hom.op_inj (by simp)\n\n"}
{"name":"CategoryTheory.Limits.imageSubobject_arrow","module":"Mathlib.CategoryTheory.Subobject.Limits","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\ninst‚úù : CategoryTheory.Limits.HasImage f\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.imageSubobjectIso f).hom (CategoryTheory.Limits.image.Œπ f)) (CategoryTheory.Limits.imageSubobject f).arrow","decl":"@[reassoc (attr := simp)]\ntheorem imageSubobject_arrow :\n    (imageSubobjectIso f).hom ‚â´ image.Œπ f = (imageSubobject f).arrow := by simp [imageSubobjectIso]\n\n"}
{"name":"CategoryTheory.Limits.imageSubobject_arrow_assoc","module":"Mathlib.CategoryTheory.Subobject.Limits","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\ninst‚úù : CategoryTheory.Limits.HasImage f\nZ : C\nh : Quiver.Hom Y Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.imageSubobjectIso f).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.image.Œπ f) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.imageSubobject f).arrow h)","decl":"@[reassoc (attr := simp)]\ntheorem imageSubobject_arrow :\n    (imageSubobjectIso f).hom ‚â´ image.Œπ f = (imageSubobject f).arrow := by simp [imageSubobjectIso]\n\n"}
{"name":"CategoryTheory.Limits.imageSubobject_arrow'","module":"Mathlib.CategoryTheory.Subobject.Limits","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\ninst‚úù : CategoryTheory.Limits.HasImage f\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.imageSubobjectIso f).inv (CategoryTheory.Limits.imageSubobject f).arrow) (CategoryTheory.Limits.image.Œπ f)","decl":"@[reassoc (attr := simp)]\ntheorem imageSubobject_arrow' :\n    (imageSubobjectIso f).inv ‚â´ (imageSubobject f).arrow = image.Œπ f := by simp [imageSubobjectIso]\n\n"}
{"name":"CategoryTheory.Limits.imageSubobject_arrow'_assoc","module":"Mathlib.CategoryTheory.Subobject.Limits","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\ninst‚úù : CategoryTheory.Limits.HasImage f\nZ : C\nh : Quiver.Hom Y Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.imageSubobjectIso f).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.imageSubobject f).arrow h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.image.Œπ f) h)","decl":"@[reassoc (attr := simp)]\ntheorem imageSubobject_arrow' :\n    (imageSubobjectIso f).inv ‚â´ (imageSubobject f).arrow = image.Œπ f := by simp [imageSubobjectIso]\n\n"}
{"name":"CategoryTheory.Limits.instEpiFactorThruImageSubobjectOfHasEqualizers","module":"Mathlib.CategoryTheory.Subobject.Limits","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\ninst‚úù¬π : CategoryTheory.Limits.HasImage f\ninst‚úù : CategoryTheory.Limits.HasEqualizers C\n‚ä¢ CategoryTheory.Epi (CategoryTheory.Limits.factorThruImageSubobject f)","decl":"instance [HasEqualizers C] : Epi (factorThruImageSubobject f) := by\n  dsimp [factorThruImageSubobject]\n  apply epi_comp\n\n"}
{"name":"CategoryTheory.Limits.imageSubobject_arrow_comp_assoc","module":"Mathlib.CategoryTheory.Subobject.Limits","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\ninst‚úù : CategoryTheory.Limits.HasImage f\nZ : C\nh : Quiver.Hom Y Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.factorThruImageSubobject f) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.imageSubobject f).arrow h)) (CategoryTheory.CategoryStruct.comp f h)","decl":"@[reassoc (attr := simp), elementwise (attr := simp)]\ntheorem imageSubobject_arrow_comp : factorThruImageSubobject f ‚â´ (imageSubobject f).arrow = f := by\n  simp [factorThruImageSubobject, imageSubobject_arrow]\n\n"}
{"name":"CategoryTheory.Limits.imageSubobject_arrow_comp","module":"Mathlib.CategoryTheory.Subobject.Limits","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\ninst‚úù : CategoryTheory.Limits.HasImage f\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.factorThruImageSubobject f) (CategoryTheory.Limits.imageSubobject f).arrow) f","decl":"@[reassoc (attr := simp), elementwise (attr := simp)]\ntheorem imageSubobject_arrow_comp : factorThruImageSubobject f ‚â´ (imageSubobject f).arrow = f := by\n  simp [factorThruImageSubobject, imageSubobject_arrow]\n\n"}
{"name":"CategoryTheory.Limits.imageSubobject_arrow_comp_apply","module":"Mathlib.CategoryTheory.Subobject.Limits","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\ninst‚úù : CategoryTheory.Limits.HasImage f\ninst : CategoryTheory.HasForget C\nx : (CategoryTheory.forget C).obj X\n‚ä¢ Eq ((CategoryTheory.Limits.imageSubobject f).arrow ((CategoryTheory.Limits.factorThruImageSubobject f) x)) (f x)","decl":"@[reassoc (attr := simp), elementwise (attr := simp)]\ntheorem imageSubobject_arrow_comp : factorThruImageSubobject f ‚â´ (imageSubobject f).arrow = f := by\n  simp [factorThruImageSubobject, imageSubobject_arrow]\n\n"}
{"name":"CategoryTheory.Limits.imageSubobject_arrow_comp_eq_zero","module":"Mathlib.CategoryTheory.Subobject.Limits","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y Z : C\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\ninst‚úù¬π : CategoryTheory.Limits.HasImage f\ninst‚úù : CategoryTheory.Epi (CategoryTheory.Limits.factorThruImageSubobject f)\nh : Eq (CategoryTheory.CategoryStruct.comp f g) 0\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.imageSubobject f).arrow g) 0","decl":"theorem imageSubobject_arrow_comp_eq_zero [HasZeroMorphisms C] {X Y Z : C} {f : X ‚ü∂ Y} {g : Y ‚ü∂ Z}\n    [HasImage f] [Epi (factorThruImageSubobject f)] (h : f ‚â´ g = 0) :\n    (imageSubobject f).arrow ‚â´ g = 0 :=\n  zero_of_epi_comp (factorThruImageSubobject f) <| by simp [h]\n\n"}
{"name":"CategoryTheory.Limits.imageSubobject_factors_comp_self","module":"Mathlib.CategoryTheory.Subobject.Limits","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\ninst‚úù : CategoryTheory.Limits.HasImage f\nW : C\nk : Quiver.Hom W X\n‚ä¢ (CategoryTheory.Limits.imageSubobject f).Factors (CategoryTheory.CategoryStruct.comp k f)","decl":"theorem imageSubobject_factors_comp_self {W : C} (k : W ‚ü∂ X) : (imageSubobject f).Factors (k ‚â´ f) :=\n  ‚ü®k ‚â´ factorThruImage f, by simp‚ü©\n\n"}
{"name":"CategoryTheory.Limits.factorThruImageSubobject_comp_self","module":"Mathlib.CategoryTheory.Subobject.Limits","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\ninst‚úù : CategoryTheory.Limits.HasImage f\nW : C\nk : Quiver.Hom W X\nh : (CategoryTheory.Limits.imageSubobject f).Factors (CategoryTheory.CategoryStruct.comp k f)\n‚ä¢ Eq ((CategoryTheory.Limits.imageSubobject f).factorThru (CategoryTheory.CategoryStruct.comp k f) h) (CategoryTheory.CategoryStruct.comp k (CategoryTheory.Limits.factorThruImageSubobject f))","decl":"@[simp]\ntheorem factorThruImageSubobject_comp_self {W : C} (k : W ‚ü∂ X) (h) :\n    (imageSubobject f).factorThru (k ‚â´ f) h = k ‚â´ factorThruImageSubobject f := by\n  ext\n  simp\n\n"}
{"name":"CategoryTheory.Limits.factorThruImageSubobject_comp_self_assoc","module":"Mathlib.CategoryTheory.Subobject.Limits","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\ninst‚úù : CategoryTheory.Limits.HasImage f\nW W' : C\nk : Quiver.Hom W W'\nk' : Quiver.Hom W' X\nh : (CategoryTheory.Limits.imageSubobject f).Factors (CategoryTheory.CategoryStruct.comp k (CategoryTheory.CategoryStruct.comp k' f))\n‚ä¢ Eq ((CategoryTheory.Limits.imageSubobject f).factorThru (CategoryTheory.CategoryStruct.comp k (CategoryTheory.CategoryStruct.comp k' f)) h) (CategoryTheory.CategoryStruct.comp k (CategoryTheory.CategoryStruct.comp k' (CategoryTheory.Limits.factorThruImageSubobject f)))","decl":"@[simp]\ntheorem factorThruImageSubobject_comp_self_assoc {W W' : C} (k : W ‚ü∂ W') (k' : W' ‚ü∂ X) (h) :\n    (imageSubobject f).factorThru (k ‚â´ k' ‚â´ f) h = k ‚â´ k' ‚â´ factorThruImageSubobject f := by\n  ext\n  simp\n\n"}
{"name":"CategoryTheory.Limits.imageSubobject_comp_le","module":"Mathlib.CategoryTheory.Subobject.Limits","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nX Y X' : C\nh : Quiver.Hom X' X\nf : Quiver.Hom X Y\ninst‚úù¬π : CategoryTheory.Limits.HasImage f\ninst‚úù : CategoryTheory.Limits.HasImage (CategoryTheory.CategoryStruct.comp h f)\n‚ä¢ LE.le (CategoryTheory.Limits.imageSubobject (CategoryTheory.CategoryStruct.comp h f)) (CategoryTheory.Limits.imageSubobject f)","decl":"/-- The image of `h ‚â´ f` is always a smaller subobject than the image of `f`. -/\ntheorem imageSubobject_comp_le {X' : C} (h : X' ‚ü∂ X) (f : X ‚ü∂ Y) [HasImage f] [HasImage (h ‚â´ f)] :\n    imageSubobject (h ‚â´ f) ‚â§ imageSubobject f :=\n  Subobject.mk_le_mk_of_comm (image.preComp h f) (by simp)\n\n"}
{"name":"CategoryTheory.Limits.imageSubobject_zero_arrow","module":"Mathlib.CategoryTheory.Subobject.Limits","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nX Y : C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms C\ninst‚úù : CategoryTheory.Limits.HasZeroObject C\n‚ä¢ Eq (CategoryTheory.Limits.imageSubobject 0).arrow 0","decl":"@[simp]\ntheorem imageSubobject_zero_arrow : (imageSubobject (0 : X ‚ü∂ Y)).arrow = 0 := by\n  rw [‚Üê imageSubobject_arrow]\n  simp\n\n"}
{"name":"CategoryTheory.Limits.imageSubobject_zero","module":"Mathlib.CategoryTheory.Subobject.Limits","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms C\ninst‚úù : CategoryTheory.Limits.HasZeroObject C\nA B : C\n‚ä¢ Eq (CategoryTheory.Limits.imageSubobject 0) Bot.bot","decl":"@[simp]\ntheorem imageSubobject_zero {A B : C} : imageSubobject (0 : A ‚ü∂ B) = ‚ä• :=\n  Subobject.eq_of_comm (imageSubobjectIso _ ‚â™‚â´ imageZero ‚â™‚â´ Subobject.botCoeIsoZero.symm) (by simp)\n\n"}
{"name":"CategoryTheory.Limits.imageSubobject_comp_le_epi_of_epi","module":"Mathlib.CategoryTheory.Subobject.Limits","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nX Y X' : C\nh : Quiver.Hom X' X\ninst‚úù¬≤ : CategoryTheory.Epi h\nf : Quiver.Hom X Y\ninst‚úù¬π : CategoryTheory.Limits.HasImage f\ninst‚úù : CategoryTheory.Limits.HasImage (CategoryTheory.CategoryStruct.comp h f)\n‚ä¢ CategoryTheory.Epi ((CategoryTheory.Limits.imageSubobject (CategoryTheory.CategoryStruct.comp h f)).ofLE (CategoryTheory.Limits.imageSubobject f) ‚ãØ)","decl":"/-- The morphism `imageSubobject (h ‚â´ f) ‚ü∂ imageSubobject f`\nis an epimorphism when `h` is an epimorphism.\nIn general this does not imply that `imageSubobject (h ‚â´ f) = imageSubobject f`,\nalthough it will when the ambient category is abelian.\n -/\ninstance imageSubobject_comp_le_epi_of_epi {X' : C} (h : X' ‚ü∂ X) [Epi h] (f : X ‚ü∂ Y) [HasImage f]\n    [HasImage (h ‚â´ f)] : Epi (Subobject.ofLE _ _ (imageSubobject_comp_le h f)) := by\n  rw [ofLE_mk_le_mk_of_comm (image.preComp h f)]\n  ¬∑ infer_instance\n  ¬∑ simp\n\n"}
{"name":"CategoryTheory.Limits.imageSubobjectCompIso_hom_arrow","module":"Mathlib.CategoryTheory.Subobject.Limits","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nX Y : C\ninst‚úù¬≤ : CategoryTheory.Limits.HasEqualizers C\nf : Quiver.Hom X Y\ninst‚úù¬π : CategoryTheory.Limits.HasImage f\nY' : C\nh : Quiver.Hom Y Y'\ninst‚úù : CategoryTheory.IsIso h\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.imageSubobjectCompIso f h).hom (CategoryTheory.Limits.imageSubobject f).arrow) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.imageSubobject (CategoryTheory.CategoryStruct.comp f h)).arrow (CategoryTheory.inv h))","decl":"@[reassoc (attr := simp)]\ntheorem imageSubobjectCompIso_hom_arrow (f : X ‚ü∂ Y) [HasImage f] {Y' : C} (h : Y ‚ü∂ Y') [IsIso h] :\n    (imageSubobjectCompIso f h).hom ‚â´ (imageSubobject f).arrow =\n      (imageSubobject (f ‚â´ h)).arrow ‚â´ inv h := by\n  simp [imageSubobjectCompIso]\n\n"}
{"name":"CategoryTheory.Limits.imageSubobjectCompIso_hom_arrow_assoc","module":"Mathlib.CategoryTheory.Subobject.Limits","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nX Y : C\ninst‚úù¬≤ : CategoryTheory.Limits.HasEqualizers C\nf : Quiver.Hom X Y\ninst‚úù¬π : CategoryTheory.Limits.HasImage f\nY' : C\nh‚úù : Quiver.Hom Y Y'\ninst‚úù : CategoryTheory.IsIso h‚úù\nZ : C\nh : Quiver.Hom Y Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.imageSubobjectCompIso f h‚úù).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.imageSubobject f).arrow h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.imageSubobject (CategoryTheory.CategoryStruct.comp f h‚úù)).arrow (CategoryTheory.CategoryStruct.comp (CategoryTheory.inv h‚úù) h))","decl":"@[reassoc (attr := simp)]\ntheorem imageSubobjectCompIso_hom_arrow (f : X ‚ü∂ Y) [HasImage f] {Y' : C} (h : Y ‚ü∂ Y') [IsIso h] :\n    (imageSubobjectCompIso f h).hom ‚â´ (imageSubobject f).arrow =\n      (imageSubobject (f ‚â´ h)).arrow ‚â´ inv h := by\n  simp [imageSubobjectCompIso]\n\n"}
{"name":"CategoryTheory.Limits.imageSubobjectCompIso_inv_arrow","module":"Mathlib.CategoryTheory.Subobject.Limits","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nX Y : C\ninst‚úù¬≤ : CategoryTheory.Limits.HasEqualizers C\nf : Quiver.Hom X Y\ninst‚úù¬π : CategoryTheory.Limits.HasImage f\nY' : C\nh : Quiver.Hom Y Y'\ninst‚úù : CategoryTheory.IsIso h\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.imageSubobjectCompIso f h).inv (CategoryTheory.Limits.imageSubobject (CategoryTheory.CategoryStruct.comp f h)).arrow) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.imageSubobject f).arrow h)","decl":"@[reassoc (attr := simp)]\ntheorem imageSubobjectCompIso_inv_arrow (f : X ‚ü∂ Y) [HasImage f] {Y' : C} (h : Y ‚ü∂ Y') [IsIso h] :\n    (imageSubobjectCompIso f h).inv ‚â´ (imageSubobject (f ‚â´ h)).arrow =\n      (imageSubobject f).arrow ‚â´ h := by\n  simp [imageSubobjectCompIso]\n\n"}
{"name":"CategoryTheory.Limits.imageSubobjectCompIso_inv_arrow_assoc","module":"Mathlib.CategoryTheory.Subobject.Limits","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nX Y : C\ninst‚úù¬≤ : CategoryTheory.Limits.HasEqualizers C\nf : Quiver.Hom X Y\ninst‚úù¬π : CategoryTheory.Limits.HasImage f\nY' : C\nh‚úù : Quiver.Hom Y Y'\ninst‚úù : CategoryTheory.IsIso h‚úù\nZ : C\nh : Quiver.Hom Y' Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.imageSubobjectCompIso f h‚úù).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.imageSubobject (CategoryTheory.CategoryStruct.comp f h‚úù)).arrow h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.imageSubobject f).arrow (CategoryTheory.CategoryStruct.comp h‚úù h))","decl":"@[reassoc (attr := simp)]\ntheorem imageSubobjectCompIso_inv_arrow (f : X ‚ü∂ Y) [HasImage f] {Y' : C} (h : Y ‚ü∂ Y') [IsIso h] :\n    (imageSubobjectCompIso f h).inv ‚â´ (imageSubobject (f ‚â´ h)).arrow =\n      (imageSubobject f).arrow ‚â´ h := by\n  simp [imageSubobjectCompIso]\n\n"}
{"name":"CategoryTheory.Limits.imageSubobject_mono","module":"Mathlib.CategoryTheory.Subobject.Limits","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\ninst‚úù : CategoryTheory.Mono f\n‚ä¢ Eq (CategoryTheory.Limits.imageSubobject f) (CategoryTheory.Subobject.mk f)","decl":"theorem imageSubobject_mono (f : X ‚ü∂ Y) [Mono f] : imageSubobject f = Subobject.mk f :=\n  eq_of_comm (imageSubobjectIso f ‚â™‚â´ imageMonoIsoSource f ‚â™‚â´ (underlyingIso f).symm) (by simp)\n\n"}
{"name":"CategoryTheory.Limits.imageSubobject_iso_comp","module":"Mathlib.CategoryTheory.Subobject.Limits","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nX Y : C\ninst‚úù¬≤ : CategoryTheory.Limits.HasEqualizers C\nX' : C\nh : Quiver.Hom X' X\ninst‚úù¬π : CategoryTheory.IsIso h\nf : Quiver.Hom X Y\ninst‚úù : CategoryTheory.Limits.HasImage f\n‚ä¢ Eq (CategoryTheory.Limits.imageSubobject (CategoryTheory.CategoryStruct.comp h f)) (CategoryTheory.Limits.imageSubobject f)","decl":"/-- Precomposing by an isomorphism does not change the image subobject. -/\ntheorem imageSubobject_iso_comp [HasEqualizers C] {X' : C} (h : X' ‚ü∂ X) [IsIso h] (f : X ‚ü∂ Y)\n    [HasImage f] : imageSubobject (h ‚â´ f) = imageSubobject f :=\n  le_antisymm (imageSubobject_comp_le h f)\n    (Subobject.mk_le_mk_of_comm (inv (image.preComp h f)) (by simp))\n\n"}
{"name":"CategoryTheory.Limits.imageSubobject_le","module":"Mathlib.CategoryTheory.Subobject.Limits","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nA B : C\nX : CategoryTheory.Subobject B\nf : Quiver.Hom A B\ninst‚úù : CategoryTheory.Limits.HasImage f\nh : Quiver.Hom A (CategoryTheory.Subobject.underlying.obj X)\nw : Eq (CategoryTheory.CategoryStruct.comp h X.arrow) f\n‚ä¢ LE.le (CategoryTheory.Limits.imageSubobject f) X","decl":"theorem imageSubobject_le {A B : C} {X : Subobject B} (f : A ‚ü∂ B) [HasImage f] (h : A ‚ü∂ X)\n    (w : h ‚â´ X.arrow = f) : imageSubobject f ‚â§ X :=\n  Subobject.le_of_comm\n    ((imageSubobjectIso f).hom ‚â´\n      image.lift\n        { I := (X : C)\n          e := h\n          m := X.arrow })\n    (by rw [assoc, image.lift_fac, imageSubobject_arrow])\n\n"}
{"name":"CategoryTheory.Limits.imageSubobject_le_mk","module":"Mathlib.CategoryTheory.Subobject.Limits","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nA B X : C\ng : Quiver.Hom X B\ninst‚úù¬π : CategoryTheory.Mono g\nf : Quiver.Hom A B\ninst‚úù : CategoryTheory.Limits.HasImage f\nh : Quiver.Hom A X\nw : Eq (CategoryTheory.CategoryStruct.comp h g) f\n‚ä¢ LE.le (CategoryTheory.Limits.imageSubobject f) (CategoryTheory.Subobject.mk g)","decl":"theorem imageSubobject_le_mk {A B : C} {X : C} (g : X ‚ü∂ B) [Mono g] (f : A ‚ü∂ B) [HasImage f]\n    (h : A ‚ü∂ X) (w : h ‚â´ g = f) : imageSubobject f ‚â§ Subobject.mk g :=\n  imageSubobject_le f (h ‚â´ (Subobject.underlyingIso g).inv) (by simp [w])\n\n"}
{"name":"CategoryTheory.Limits.imageSubobjectMap_arrow_assoc","module":"Mathlib.CategoryTheory.Subobject.Limits","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nW X Y Z‚úù : C\nf : Quiver.Hom W X\ninst‚úù¬≤ : CategoryTheory.Limits.HasImage f\ng : Quiver.Hom Y Z‚úù\ninst‚úù¬π : CategoryTheory.Limits.HasImage g\nsq : Quiver.Hom (CategoryTheory.Arrow.mk f) (CategoryTheory.Arrow.mk g)\ninst‚úù : CategoryTheory.Limits.HasImageMap sq\nZ : C\nh : Quiver.Hom Z‚úù Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.imageSubobjectMap sq) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.imageSubobject g).arrow h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.imageSubobject f).arrow (CategoryTheory.CategoryStruct.comp sq.right h))","decl":"@[reassoc (attr := simp)]\ntheorem imageSubobjectMap_arrow {W X Y Z : C} {f : W ‚ü∂ X} [HasImage f] {g : Y ‚ü∂ Z} [HasImage g]\n    (sq : Arrow.mk f ‚ü∂ Arrow.mk g) [HasImageMap sq] :\n    imageSubobjectMap sq ‚â´ (imageSubobject g).arrow = (imageSubobject f).arrow ‚â´ sq.right := by\n  simp only [imageSubobjectMap, Category.assoc, imageSubobject_arrow']\n  erw [image.map_Œπ, ‚Üê Category.assoc, imageSubobject_arrow]\n\n"}
{"name":"CategoryTheory.Limits.imageSubobjectMap_arrow","module":"Mathlib.CategoryTheory.Subobject.Limits","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nW X Y Z : C\nf : Quiver.Hom W X\ninst‚úù¬≤ : CategoryTheory.Limits.HasImage f\ng : Quiver.Hom Y Z\ninst‚úù¬π : CategoryTheory.Limits.HasImage g\nsq : Quiver.Hom (CategoryTheory.Arrow.mk f) (CategoryTheory.Arrow.mk g)\ninst‚úù : CategoryTheory.Limits.HasImageMap sq\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.imageSubobjectMap sq) (CategoryTheory.Limits.imageSubobject g).arrow) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.imageSubobject f).arrow sq.right)","decl":"@[reassoc (attr := simp)]\ntheorem imageSubobjectMap_arrow {W X Y Z : C} {f : W ‚ü∂ X} [HasImage f] {g : Y ‚ü∂ Z} [HasImage g]\n    (sq : Arrow.mk f ‚ü∂ Arrow.mk g) [HasImageMap sq] :\n    imageSubobjectMap sq ‚â´ (imageSubobject g).arrow = (imageSubobject f).arrow ‚â´ sq.right := by\n  simp only [imageSubobjectMap, Category.assoc, imageSubobject_arrow']\n  erw [image.map_Œπ, ‚Üê Category.assoc, imageSubobject_arrow]\n\n"}
{"name":"CategoryTheory.Limits.image_map_comp_imageSubobjectIso_inv","module":"Mathlib.CategoryTheory.Subobject.Limits","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nW X Y Z : C\nf : Quiver.Hom W X\ninst‚úù¬≤ : CategoryTheory.Limits.HasImage f\ng : Quiver.Hom Y Z\ninst‚úù¬π : CategoryTheory.Limits.HasImage g\nsq : Quiver.Hom (CategoryTheory.Arrow.mk f) (CategoryTheory.Arrow.mk g)\ninst‚úù : CategoryTheory.Limits.HasImageMap sq\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.image.map sq) (CategoryTheory.Limits.imageSubobjectIso (CategoryTheory.Arrow.mk g).hom).inv) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.imageSubobjectIso f).inv (CategoryTheory.Limits.imageSubobjectMap sq))","decl":"theorem image_map_comp_imageSubobjectIso_inv {W X Y Z : C} {f : W ‚ü∂ X} [HasImage f] {g : Y ‚ü∂ Z}\n    [HasImage g] (sq : Arrow.mk f ‚ü∂ Arrow.mk g) [HasImageMap sq] :\n    image.map sq ‚â´ (imageSubobjectIso _).inv =\n      (imageSubobjectIso _).inv ‚â´ imageSubobjectMap sq := by\n  ext\n  simpa using image.map_Œπ sq\n\n"}
{"name":"CategoryTheory.Limits.imageSubobjectIso_comp_image_map","module":"Mathlib.CategoryTheory.Subobject.Limits","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nW X Y Z : C\nf : Quiver.Hom W X\ninst‚úù¬≤ : CategoryTheory.Limits.HasImage f\ng : Quiver.Hom Y Z\ninst‚úù¬π : CategoryTheory.Limits.HasImage g\nsq : Quiver.Hom (CategoryTheory.Arrow.mk f) (CategoryTheory.Arrow.mk g)\ninst‚úù : CategoryTheory.Limits.HasImageMap sq\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.imageSubobjectIso (CategoryTheory.Arrow.mk f).hom).hom (CategoryTheory.Limits.image.map sq)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.imageSubobjectMap sq) (CategoryTheory.Limits.imageSubobjectIso g).hom)","decl":"theorem imageSubobjectIso_comp_image_map {W X Y Z : C} {f : W ‚ü∂ X} [HasImage f] {g : Y ‚ü∂ Z}\n    [HasImage g] (sq : Arrow.mk f ‚ü∂ Arrow.mk g) [HasImageMap sq] :\n    (imageSubobjectIso _).hom ‚â´ image.map sq =\n      imageSubobjectMap sq ‚â´ (imageSubobjectIso _).hom := by\n  erw [‚Üê Iso.comp_inv_eq, Category.assoc, ‚Üê (imageSubobjectIso f).eq_inv_comp,\n    image_map_comp_imageSubobjectIso_inv sq]\n\n"}
