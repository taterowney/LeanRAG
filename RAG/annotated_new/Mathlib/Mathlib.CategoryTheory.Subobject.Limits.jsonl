{"name":"CategoryTheory.Limits.equalizerSubobject_arrow_assoc","module":"Mathlib.CategoryTheory.Subobject.Limits","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\ninst✝ : CategoryTheory.Limits.HasEqualizer f g\nZ : C\nh : Quiver.Hom X Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.equalizerSubobjectIso f g).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.equalizer.ι f g) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.equalizerSubobject f g).arrow h)","decl":"@[reassoc (attr := simp)]\ntheorem equalizerSubobject_arrow :\n    (equalizerSubobjectIso f g).hom ≫ equalizer.ι f g = (equalizerSubobject f g).arrow := by\n  simp [equalizerSubobjectIso]\n\n"}
{"name":"CategoryTheory.Limits.equalizerSubobject_arrow","module":"Mathlib.CategoryTheory.Subobject.Limits","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\ninst✝ : CategoryTheory.Limits.HasEqualizer f g\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.equalizerSubobjectIso f g).hom (CategoryTheory.Limits.equalizer.ι f g)) (CategoryTheory.Limits.equalizerSubobject f g).arrow","decl":"@[reassoc (attr := simp)]\ntheorem equalizerSubobject_arrow :\n    (equalizerSubobjectIso f g).hom ≫ equalizer.ι f g = (equalizerSubobject f g).arrow := by\n  simp [equalizerSubobjectIso]\n\n"}
{"name":"CategoryTheory.Limits.equalizerSubobject_arrow'","module":"Mathlib.CategoryTheory.Subobject.Limits","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\ninst✝ : CategoryTheory.Limits.HasEqualizer f g\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.equalizerSubobjectIso f g).inv (CategoryTheory.Limits.equalizerSubobject f g).arrow) (CategoryTheory.Limits.equalizer.ι f g)","decl":"@[reassoc (attr := simp)]\ntheorem equalizerSubobject_arrow' :\n    (equalizerSubobjectIso f g).inv ≫ (equalizerSubobject f g).arrow = equalizer.ι f g := by\n  simp [equalizerSubobjectIso]\n\n"}
{"name":"CategoryTheory.Limits.equalizerSubobject_arrow'_assoc","module":"Mathlib.CategoryTheory.Subobject.Limits","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\ninst✝ : CategoryTheory.Limits.HasEqualizer f g\nZ : C\nh : Quiver.Hom X Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.equalizerSubobjectIso f g).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.equalizerSubobject f g).arrow h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.equalizer.ι f g) h)","decl":"@[reassoc (attr := simp)]\ntheorem equalizerSubobject_arrow' :\n    (equalizerSubobjectIso f g).inv ≫ (equalizerSubobject f g).arrow = equalizer.ι f g := by\n  simp [equalizerSubobjectIso]\n\n"}
{"name":"CategoryTheory.Limits.equalizerSubobject_arrow_comp","module":"Mathlib.CategoryTheory.Subobject.Limits","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\ninst✝ : CategoryTheory.Limits.HasEqualizer f g\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.equalizerSubobject f g).arrow f) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.equalizerSubobject f g).arrow g)","decl":"@[reassoc]\ntheorem equalizerSubobject_arrow_comp :\n    (equalizerSubobject f g).arrow ≫ f = (equalizerSubobject f g).arrow ≫ g := by\n  rw [← equalizerSubobject_arrow, Category.assoc, Category.assoc, equalizer.condition]\n\n"}
{"name":"CategoryTheory.Limits.equalizerSubobject_arrow_comp_assoc","module":"Mathlib.CategoryTheory.Subobject.Limits","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\ninst✝ : CategoryTheory.Limits.HasEqualizer f g\nZ : C\nh : Quiver.Hom Y Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.equalizerSubobject f g).arrow (CategoryTheory.CategoryStruct.comp f h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.equalizerSubobject f g).arrow (CategoryTheory.CategoryStruct.comp g h))","decl":"@[reassoc]\ntheorem equalizerSubobject_arrow_comp :\n    (equalizerSubobject f g).arrow ≫ f = (equalizerSubobject f g).arrow ≫ g := by\n  rw [← equalizerSubobject_arrow, Category.assoc, Category.assoc, equalizer.condition]\n\n"}
{"name":"CategoryTheory.Limits.equalizerSubobject_factors","module":"Mathlib.CategoryTheory.Subobject.Limits","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\ninst✝ : CategoryTheory.Limits.HasEqualizer f g\nW : C\nh : Quiver.Hom W X\nw : Eq (CategoryTheory.CategoryStruct.comp h f) (CategoryTheory.CategoryStruct.comp h g)\n⊢ (CategoryTheory.Limits.equalizerSubobject f g).Factors h","decl":"theorem equalizerSubobject_factors {W : C} (h : W ⟶ X) (w : h ≫ f = h ≫ g) :\n    (equalizerSubobject f g).Factors h :=\n  ⟨equalizer.lift h w, by simp⟩\n\n"}
{"name":"CategoryTheory.Limits.equalizerSubobject_factors_iff","module":"Mathlib.CategoryTheory.Subobject.Limits","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\ninst✝ : CategoryTheory.Limits.HasEqualizer f g\nW : C\nh : Quiver.Hom W X\n⊢ Iff ((CategoryTheory.Limits.equalizerSubobject f g).Factors h) (Eq (CategoryTheory.CategoryStruct.comp h f) (CategoryTheory.CategoryStruct.comp h g))","decl":"theorem equalizerSubobject_factors_iff {W : C} (h : W ⟶ X) :\n    (equalizerSubobject f g).Factors h ↔ h ≫ f = h ≫ g :=\n  ⟨fun w => by\n    rw [← Subobject.factorThru_arrow _ _ w, Category.assoc, equalizerSubobject_arrow_comp,\n      Category.assoc],\n    equalizerSubobject_factors f g h⟩\n\n"}
{"name":"CategoryTheory.Limits.kernelSubobject_arrow_apply","module":"Mathlib.CategoryTheory.Subobject.Limits","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nX Y : C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.Limits.HasKernel f\ninst : CategoryTheory.HasForget C\nx : (CategoryTheory.forget C).obj (CategoryTheory.Subobject.underlying.obj (CategoryTheory.Limits.kernelSubobject f))\n⊢ Eq ((CategoryTheory.Limits.kernel.ι f) ((CategoryTheory.Limits.kernelSubobjectIso f).hom x)) ((CategoryTheory.Limits.kernelSubobject f).arrow x)","decl":"@[reassoc (attr := simp), elementwise (attr := simp)]\ntheorem kernelSubobject_arrow :\n    (kernelSubobjectIso f).hom ≫ kernel.ι f = (kernelSubobject f).arrow := by\n  simp [kernelSubobjectIso]\n\n"}
{"name":"CategoryTheory.Limits.kernelSubobject_arrow","module":"Mathlib.CategoryTheory.Subobject.Limits","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nX Y : C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.Limits.HasKernel f\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.kernelSubobjectIso f).hom (CategoryTheory.Limits.kernel.ι f)) (CategoryTheory.Limits.kernelSubobject f).arrow","decl":"@[reassoc (attr := simp), elementwise (attr := simp)]\ntheorem kernelSubobject_arrow :\n    (kernelSubobjectIso f).hom ≫ kernel.ι f = (kernelSubobject f).arrow := by\n  simp [kernelSubobjectIso]\n\n"}
{"name":"CategoryTheory.Limits.kernelSubobject_arrow_assoc","module":"Mathlib.CategoryTheory.Subobject.Limits","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nX Y : C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.Limits.HasKernel f\nZ : C\nh : Quiver.Hom X Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.kernelSubobjectIso f).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.kernel.ι f) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.kernelSubobject f).arrow h)","decl":"@[reassoc (attr := simp), elementwise (attr := simp)]\ntheorem kernelSubobject_arrow :\n    (kernelSubobjectIso f).hom ≫ kernel.ι f = (kernelSubobject f).arrow := by\n  simp [kernelSubobjectIso]\n\n"}
{"name":"CategoryTheory.Limits.kernelSubobject_arrow'","module":"Mathlib.CategoryTheory.Subobject.Limits","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nX Y : C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.Limits.HasKernel f\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.kernelSubobjectIso f).inv (CategoryTheory.Limits.kernelSubobject f).arrow) (CategoryTheory.Limits.kernel.ι f)","decl":"@[reassoc (attr := simp), elementwise (attr := simp)]\ntheorem kernelSubobject_arrow' :\n    (kernelSubobjectIso f).inv ≫ (kernelSubobject f).arrow = kernel.ι f := by\n  simp [kernelSubobjectIso]\n\n"}
{"name":"CategoryTheory.Limits.kernelSubobject_arrow'_apply","module":"Mathlib.CategoryTheory.Subobject.Limits","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nX Y : C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.Limits.HasKernel f\ninst : CategoryTheory.HasForget C\nx : (CategoryTheory.forget C).obj (CategoryTheory.Limits.kernel f)\n⊢ Eq ((CategoryTheory.Limits.kernelSubobject f).arrow ((CategoryTheory.Limits.kernelSubobjectIso f).inv x)) ((CategoryTheory.Limits.kernel.ι f) x)","decl":"@[reassoc (attr := simp), elementwise (attr := simp)]\ntheorem kernelSubobject_arrow' :\n    (kernelSubobjectIso f).inv ≫ (kernelSubobject f).arrow = kernel.ι f := by\n  simp [kernelSubobjectIso]\n\n"}
{"name":"CategoryTheory.Limits.kernelSubobject_arrow'_assoc","module":"Mathlib.CategoryTheory.Subobject.Limits","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nX Y : C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.Limits.HasKernel f\nZ : C\nh : Quiver.Hom X Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.kernelSubobjectIso f).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.kernelSubobject f).arrow h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.kernel.ι f) h)","decl":"@[reassoc (attr := simp), elementwise (attr := simp)]\ntheorem kernelSubobject_arrow' :\n    (kernelSubobjectIso f).inv ≫ (kernelSubobject f).arrow = kernel.ι f := by\n  simp [kernelSubobjectIso]\n\n"}
{"name":"CategoryTheory.Limits.kernelSubobject_arrow_comp_apply","module":"Mathlib.CategoryTheory.Subobject.Limits","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nX Y : C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.Limits.HasKernel f\ninst : CategoryTheory.HasForget C\nx : (CategoryTheory.forget C).obj (CategoryTheory.Subobject.underlying.obj (CategoryTheory.Limits.kernelSubobject f))\n⊢ Eq (f ((CategoryTheory.Limits.kernelSubobject f).arrow x)) (0 x)","decl":"@[reassoc (attr := simp), elementwise (attr := simp)]\ntheorem kernelSubobject_arrow_comp : (kernelSubobject f).arrow ≫ f = 0 := by\n  rw [← kernelSubobject_arrow]\n  simp only [Category.assoc, kernel.condition, comp_zero]\n\n"}
{"name":"CategoryTheory.Limits.kernelSubobject_arrow_comp_assoc","module":"Mathlib.CategoryTheory.Subobject.Limits","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nX Y : C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.Limits.HasKernel f\nZ : C\nh : Quiver.Hom Y Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.kernelSubobject f).arrow (CategoryTheory.CategoryStruct.comp f h)) (CategoryTheory.CategoryStruct.comp 0 h)","decl":"@[reassoc (attr := simp), elementwise (attr := simp)]\ntheorem kernelSubobject_arrow_comp : (kernelSubobject f).arrow ≫ f = 0 := by\n  rw [← kernelSubobject_arrow]\n  simp only [Category.assoc, kernel.condition, comp_zero]\n\n"}
{"name":"CategoryTheory.Limits.kernelSubobject_arrow_comp","module":"Mathlib.CategoryTheory.Subobject.Limits","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nX Y : C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.Limits.HasKernel f\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.kernelSubobject f).arrow f) 0","decl":"@[reassoc (attr := simp), elementwise (attr := simp)]\ntheorem kernelSubobject_arrow_comp : (kernelSubobject f).arrow ≫ f = 0 := by\n  rw [← kernelSubobject_arrow]\n  simp only [Category.assoc, kernel.condition, comp_zero]\n\n"}
{"name":"CategoryTheory.Limits.kernelSubobject_factors","module":"Mathlib.CategoryTheory.Subobject.Limits","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nX Y : C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.Limits.HasKernel f\nW : C\nh : Quiver.Hom W X\nw : Eq (CategoryTheory.CategoryStruct.comp h f) 0\n⊢ (CategoryTheory.Limits.kernelSubobject f).Factors h","decl":"theorem kernelSubobject_factors {W : C} (h : W ⟶ X) (w : h ≫ f = 0) :\n    (kernelSubobject f).Factors h :=\n  ⟨kernel.lift _ h w, by simp⟩\n\n"}
{"name":"CategoryTheory.Limits.kernelSubobject_factors_iff","module":"Mathlib.CategoryTheory.Subobject.Limits","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nX Y : C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.Limits.HasKernel f\nW : C\nh : Quiver.Hom W X\n⊢ Iff ((CategoryTheory.Limits.kernelSubobject f).Factors h) (Eq (CategoryTheory.CategoryStruct.comp h f) 0)","decl":"theorem kernelSubobject_factors_iff {W : C} (h : W ⟶ X) :\n    (kernelSubobject f).Factors h ↔ h ≫ f = 0 :=\n  ⟨fun w => by\n    rw [← Subobject.factorThru_arrow _ _ w, Category.assoc, kernelSubobject_arrow_comp,\n      comp_zero],\n    kernelSubobject_factors f h⟩\n\n"}
{"name":"CategoryTheory.Limits.factorThruKernelSubobject_comp_arrow","module":"Mathlib.CategoryTheory.Subobject.Limits","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nX Y : C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.Limits.HasKernel f\nW : C\nh : Quiver.Hom W X\nw : Eq (CategoryTheory.CategoryStruct.comp h f) 0\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.factorThruKernelSubobject f h w) (CategoryTheory.Limits.kernelSubobject f).arrow) h","decl":"@[simp]\ntheorem factorThruKernelSubobject_comp_arrow {W : C} (h : W ⟶ X) (w : h ≫ f = 0) :\n    factorThruKernelSubobject f h w ≫ (kernelSubobject f).arrow = h := by\n  dsimp [factorThruKernelSubobject]\n  simp\n\n"}
{"name":"CategoryTheory.Limits.factorThruKernelSubobject_comp_kernelSubobjectIso","module":"Mathlib.CategoryTheory.Subobject.Limits","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nX Y : C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.Limits.HasKernel f\nW : C\nh : Quiver.Hom W X\nw : Eq (CategoryTheory.CategoryStruct.comp h f) 0\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.factorThruKernelSubobject f h w) (CategoryTheory.Limits.kernelSubobjectIso f).hom) (CategoryTheory.Limits.kernel.lift f h w)","decl":"@[simp]\ntheorem factorThruKernelSubobject_comp_kernelSubobjectIso {W : C} (h : W ⟶ X) (w : h ≫ f = 0) :\n    factorThruKernelSubobject f h w ≫ (kernelSubobjectIso f).hom = kernel.lift f h w :=\n  (cancel_mono (kernel.ι f)).1 <| by simp\n\n"}
{"name":"CategoryTheory.Limits.kernelSubobjectMap_arrow_apply","module":"Mathlib.CategoryTheory.Subobject.Limits","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nX Y : C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nf : Quiver.Hom X Y\ninst✝¹ : CategoryTheory.Limits.HasKernel f\nX' Y' : C\nf' : Quiver.Hom X' Y'\ninst✝ : CategoryTheory.Limits.HasKernel f'\nsq : Quiver.Hom (CategoryTheory.Arrow.mk f) (CategoryTheory.Arrow.mk f')\ninst : CategoryTheory.HasForget C\nx : (CategoryTheory.forget C).obj (CategoryTheory.Subobject.underlying.obj (CategoryTheory.Limits.kernelSubobject f))\n⊢ Eq ((CategoryTheory.Limits.kernelSubobject f').arrow ((CategoryTheory.Limits.kernelSubobjectMap sq) x)) (sq.left ((CategoryTheory.Limits.kernelSubobject f).arrow x))","decl":"@[reassoc (attr := simp), elementwise (attr := simp)]\ntheorem kernelSubobjectMap_arrow (sq : Arrow.mk f ⟶ Arrow.mk f') :\n    kernelSubobjectMap sq ≫ (kernelSubobject f').arrow = (kernelSubobject f).arrow ≫ sq.left := by\n  simp [kernelSubobjectMap]\n\n"}
{"name":"CategoryTheory.Limits.kernelSubobjectMap_arrow_assoc","module":"Mathlib.CategoryTheory.Subobject.Limits","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nX Y : C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nf : Quiver.Hom X Y\ninst✝¹ : CategoryTheory.Limits.HasKernel f\nX' Y' : C\nf' : Quiver.Hom X' Y'\ninst✝ : CategoryTheory.Limits.HasKernel f'\nsq : Quiver.Hom (CategoryTheory.Arrow.mk f) (CategoryTheory.Arrow.mk f')\nZ : C\nh : Quiver.Hom X' Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.kernelSubobjectMap sq) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.kernelSubobject f').arrow h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.kernelSubobject f).arrow (CategoryTheory.CategoryStruct.comp sq.left h))","decl":"@[reassoc (attr := simp), elementwise (attr := simp)]\ntheorem kernelSubobjectMap_arrow (sq : Arrow.mk f ⟶ Arrow.mk f') :\n    kernelSubobjectMap sq ≫ (kernelSubobject f').arrow = (kernelSubobject f).arrow ≫ sq.left := by\n  simp [kernelSubobjectMap]\n\n"}
{"name":"CategoryTheory.Limits.kernelSubobjectMap_arrow","module":"Mathlib.CategoryTheory.Subobject.Limits","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nX Y : C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nf : Quiver.Hom X Y\ninst✝¹ : CategoryTheory.Limits.HasKernel f\nX' Y' : C\nf' : Quiver.Hom X' Y'\ninst✝ : CategoryTheory.Limits.HasKernel f'\nsq : Quiver.Hom (CategoryTheory.Arrow.mk f) (CategoryTheory.Arrow.mk f')\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.kernelSubobjectMap sq) (CategoryTheory.Limits.kernelSubobject f').arrow) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.kernelSubobject f).arrow sq.left)","decl":"@[reassoc (attr := simp), elementwise (attr := simp)]\ntheorem kernelSubobjectMap_arrow (sq : Arrow.mk f ⟶ Arrow.mk f') :\n    kernelSubobjectMap sq ≫ (kernelSubobject f').arrow = (kernelSubobject f).arrow ≫ sq.left := by\n  simp [kernelSubobjectMap]\n\n"}
{"name":"CategoryTheory.Limits.kernelSubobjectMap_id","module":"Mathlib.CategoryTheory.Subobject.Limits","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nX Y : C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.Limits.HasKernel f\n⊢ Eq (CategoryTheory.Limits.kernelSubobjectMap (CategoryTheory.CategoryStruct.id (CategoryTheory.Arrow.mk f))) (CategoryTheory.CategoryStruct.id (CategoryTheory.Subobject.underlying.obj (CategoryTheory.Limits.kernelSubobject f)))","decl":"@[simp]\ntheorem kernelSubobjectMap_id : kernelSubobjectMap (𝟙 (Arrow.mk f)) = 𝟙 _ := by aesop_cat\n\n"}
{"name":"CategoryTheory.Limits.kernelSubobjectMap_comp","module":"Mathlib.CategoryTheory.Subobject.Limits","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\nX Y : C\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\nf : Quiver.Hom X Y\ninst✝² : CategoryTheory.Limits.HasKernel f\nX' Y' : C\nf' : Quiver.Hom X' Y'\ninst✝¹ : CategoryTheory.Limits.HasKernel f'\nX'' Y'' : C\nf'' : Quiver.Hom X'' Y''\ninst✝ : CategoryTheory.Limits.HasKernel f''\nsq : Quiver.Hom (CategoryTheory.Arrow.mk f) (CategoryTheory.Arrow.mk f')\nsq' : Quiver.Hom (CategoryTheory.Arrow.mk f') (CategoryTheory.Arrow.mk f'')\n⊢ Eq (CategoryTheory.Limits.kernelSubobjectMap (CategoryTheory.CategoryStruct.comp sq sq')) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.kernelSubobjectMap sq) (CategoryTheory.Limits.kernelSubobjectMap sq'))","decl":"@[simp]\ntheorem kernelSubobjectMap_comp {X'' Y'' : C} {f'' : X'' ⟶ Y''} [HasKernel f'']\n    (sq : Arrow.mk f ⟶ Arrow.mk f') (sq' : Arrow.mk f' ⟶ Arrow.mk f'') :\n    kernelSubobjectMap (sq ≫ sq') = kernelSubobjectMap sq ≫ kernelSubobjectMap sq' := by\n  aesop_cat\n\n"}
{"name":"CategoryTheory.Limits.kernel_map_comp_kernelSubobjectIso_inv_assoc","module":"Mathlib.CategoryTheory.Subobject.Limits","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nX Y : C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nf : Quiver.Hom X Y\ninst✝¹ : CategoryTheory.Limits.HasKernel f\nX' Y' : C\nf' : Quiver.Hom X' Y'\ninst✝ : CategoryTheory.Limits.HasKernel f'\nsq : Quiver.Hom (CategoryTheory.Arrow.mk f) (CategoryTheory.Arrow.mk f')\nZ : C\nh : Quiver.Hom (CategoryTheory.Subobject.underlying.obj (CategoryTheory.Limits.kernelSubobject f')) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.kernel.map f f' sq.left sq.right ⋯) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.kernelSubobjectIso f').inv h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.kernelSubobjectIso f).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.kernelSubobjectMap sq) h))","decl":"@[reassoc]\ntheorem kernel_map_comp_kernelSubobjectIso_inv (sq : Arrow.mk f ⟶ Arrow.mk f') :\n    kernel.map f f' sq.1 sq.2 sq.3.symm ≫ (kernelSubobjectIso _).inv =\n      (kernelSubobjectIso _).inv ≫ kernelSubobjectMap sq := by aesop_cat\n\n"}
{"name":"CategoryTheory.Limits.kernel_map_comp_kernelSubobjectIso_inv","module":"Mathlib.CategoryTheory.Subobject.Limits","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nX Y : C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nf : Quiver.Hom X Y\ninst✝¹ : CategoryTheory.Limits.HasKernel f\nX' Y' : C\nf' : Quiver.Hom X' Y'\ninst✝ : CategoryTheory.Limits.HasKernel f'\nsq : Quiver.Hom (CategoryTheory.Arrow.mk f) (CategoryTheory.Arrow.mk f')\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.kernel.map f f' sq.left sq.right ⋯) (CategoryTheory.Limits.kernelSubobjectIso f').inv) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.kernelSubobjectIso f).inv (CategoryTheory.Limits.kernelSubobjectMap sq))","decl":"@[reassoc]\ntheorem kernel_map_comp_kernelSubobjectIso_inv (sq : Arrow.mk f ⟶ Arrow.mk f') :\n    kernel.map f f' sq.1 sq.2 sq.3.symm ≫ (kernelSubobjectIso _).inv =\n      (kernelSubobjectIso _).inv ≫ kernelSubobjectMap sq := by aesop_cat\n\n"}
{"name":"CategoryTheory.Limits.kernelSubobjectIso_comp_kernel_map_assoc","module":"Mathlib.CategoryTheory.Subobject.Limits","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nX Y : C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nf : Quiver.Hom X Y\ninst✝¹ : CategoryTheory.Limits.HasKernel f\nX' Y' : C\nf' : Quiver.Hom X' Y'\ninst✝ : CategoryTheory.Limits.HasKernel f'\nsq : Quiver.Hom (CategoryTheory.Arrow.mk f) (CategoryTheory.Arrow.mk f')\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.kernel f') Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.kernelSubobjectIso f).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.kernel.map f f' sq.left sq.right ⋯) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.kernelSubobjectMap sq) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.kernelSubobjectIso f').hom h))","decl":"@[reassoc]\ntheorem kernelSubobjectIso_comp_kernel_map (sq : Arrow.mk f ⟶ Arrow.mk f') :\n    (kernelSubobjectIso _).hom ≫ kernel.map f f' sq.1 sq.2 sq.3.symm =\n      kernelSubobjectMap sq ≫ (kernelSubobjectIso _).hom := by\n  simp [← Iso.comp_inv_eq, kernel_map_comp_kernelSubobjectIso_inv]\n\n"}
{"name":"CategoryTheory.Limits.kernelSubobjectIso_comp_kernel_map","module":"Mathlib.CategoryTheory.Subobject.Limits","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nX Y : C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nf : Quiver.Hom X Y\ninst✝¹ : CategoryTheory.Limits.HasKernel f\nX' Y' : C\nf' : Quiver.Hom X' Y'\ninst✝ : CategoryTheory.Limits.HasKernel f'\nsq : Quiver.Hom (CategoryTheory.Arrow.mk f) (CategoryTheory.Arrow.mk f')\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.kernelSubobjectIso f).hom (CategoryTheory.Limits.kernel.map f f' sq.left sq.right ⋯)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.kernelSubobjectMap sq) (CategoryTheory.Limits.kernelSubobjectIso f').hom)","decl":"@[reassoc]\ntheorem kernelSubobjectIso_comp_kernel_map (sq : Arrow.mk f ⟶ Arrow.mk f') :\n    (kernelSubobjectIso _).hom ≫ kernel.map f f' sq.1 sq.2 sq.3.symm =\n      kernelSubobjectMap sq ≫ (kernelSubobjectIso _).hom := by\n  simp [← Iso.comp_inv_eq, kernel_map_comp_kernelSubobjectIso_inv]\n\n"}
{"name":"CategoryTheory.Limits.kernelSubobject_zero","module":"Mathlib.CategoryTheory.Subobject.Limits","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nA B : C\n⊢ Eq (CategoryTheory.Limits.kernelSubobject 0) Top.top","decl":"@[simp]\ntheorem kernelSubobject_zero {A B : C} : kernelSubobject (0 : A ⟶ B) = ⊤ :=\n  (isIso_iff_mk_eq_top _).mp (by infer_instance)\n\n"}
{"name":"CategoryTheory.Limits.isIso_kernelSubobject_zero_arrow","module":"Mathlib.CategoryTheory.Subobject.Limits","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX Y : C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\n⊢ CategoryTheory.IsIso (CategoryTheory.Limits.kernelSubobject 0).arrow","decl":"instance isIso_kernelSubobject_zero_arrow : IsIso (kernelSubobject (0 : X ⟶ Y)).arrow :=\n  (isIso_arrow_iff_eq_top _).mpr kernelSubobject_zero\n\n"}
{"name":"CategoryTheory.Limits.le_kernelSubobject","module":"Mathlib.CategoryTheory.Subobject.Limits","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nX Y : C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.Limits.HasKernel f\nA : CategoryTheory.Subobject X\nh : Eq (CategoryTheory.CategoryStruct.comp A.arrow f) 0\n⊢ LE.le A (CategoryTheory.Limits.kernelSubobject f)","decl":"theorem le_kernelSubobject (A : Subobject X) (h : A.arrow ≫ f = 0) : A ≤ kernelSubobject f :=\n  Subobject.le_mk_of_comm (kernel.lift f A.arrow h) (by simp)\n\n"}
{"name":"CategoryTheory.Limits.kernelSubobjectIsoComp_hom_arrow","module":"Mathlib.CategoryTheory.Subobject.Limits","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nX Y : C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nX' : C\nf : Quiver.Hom X' X\ninst✝¹ : CategoryTheory.IsIso f\ng : Quiver.Hom X Y\ninst✝ : CategoryTheory.Limits.HasKernel g\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.kernelSubobjectIsoComp f g).hom (CategoryTheory.Limits.kernelSubobject g).arrow) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.kernelSubobject (CategoryTheory.CategoryStruct.comp f g)).arrow f)","decl":"@[simp]\ntheorem kernelSubobjectIsoComp_hom_arrow {X' : C} (f : X' ⟶ X) [IsIso f] (g : X ⟶ Y) [HasKernel g] :\n    (kernelSubobjectIsoComp f g).hom ≫ (kernelSubobject g).arrow =\n      (kernelSubobject (f ≫ g)).arrow ≫ f := by\n  simp [kernelSubobjectIsoComp]\n\n"}
{"name":"CategoryTheory.Limits.kernelSubobjectIsoComp_inv_arrow","module":"Mathlib.CategoryTheory.Subobject.Limits","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nX Y : C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nX' : C\nf : Quiver.Hom X' X\ninst✝¹ : CategoryTheory.IsIso f\ng : Quiver.Hom X Y\ninst✝ : CategoryTheory.Limits.HasKernel g\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.kernelSubobjectIsoComp f g).inv (CategoryTheory.Limits.kernelSubobject (CategoryTheory.CategoryStruct.comp f g)).arrow) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.kernelSubobject g).arrow (CategoryTheory.inv f))","decl":"@[simp]\ntheorem kernelSubobjectIsoComp_inv_arrow {X' : C} (f : X' ⟶ X) [IsIso f] (g : X ⟶ Y) [HasKernel g] :\n    (kernelSubobjectIsoComp f g).inv ≫ (kernelSubobject (f ≫ g)).arrow =\n      (kernelSubobject g).arrow ≫ inv f := by\n  simp [kernelSubobjectIsoComp]\n\n"}
{"name":"CategoryTheory.Limits.kernelSubobject_comp_le","module":"Mathlib.CategoryTheory.Subobject.Limits","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nX Y : C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nf : Quiver.Hom X Y\ninst✝¹ : CategoryTheory.Limits.HasKernel f\nZ : C\nh : Quiver.Hom Y Z\ninst✝ : CategoryTheory.Limits.HasKernel (CategoryTheory.CategoryStruct.comp f h)\n⊢ LE.le (CategoryTheory.Limits.kernelSubobject f) (CategoryTheory.Limits.kernelSubobject (CategoryTheory.CategoryStruct.comp f h))","decl":"/-- The kernel of `f` is always a smaller subobject than the kernel of `f ≫ h`. -/\ntheorem kernelSubobject_comp_le (f : X ⟶ Y) [HasKernel f] {Z : C} (h : Y ⟶ Z) [HasKernel (f ≫ h)] :\n    kernelSubobject f ≤ kernelSubobject (f ≫ h) :=\n  le_kernelSubobject _ _ (by simp)\n\n"}
{"name":"CategoryTheory.Limits.kernelSubobject_comp_mono","module":"Mathlib.CategoryTheory.Subobject.Limits","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nX Y : C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nf : Quiver.Hom X Y\ninst✝¹ : CategoryTheory.Limits.HasKernel f\nZ : C\nh : Quiver.Hom Y Z\ninst✝ : CategoryTheory.Mono h\n⊢ Eq (CategoryTheory.Limits.kernelSubobject (CategoryTheory.CategoryStruct.comp f h)) (CategoryTheory.Limits.kernelSubobject f)","decl":"/-- Postcomposing by a monomorphism does not change the kernel subobject. -/\n@[simp]\ntheorem kernelSubobject_comp_mono (f : X ⟶ Y) [HasKernel f] {Z : C} (h : Y ⟶ Z) [Mono h] :\n    kernelSubobject (f ≫ h) = kernelSubobject f :=\n  le_antisymm (le_kernelSubobject _ _ ((cancel_mono h).mp (by simp))) (kernelSubobject_comp_le f h)\n\n"}
{"name":"CategoryTheory.Limits.kernelSubobject_comp_mono_isIso","module":"Mathlib.CategoryTheory.Subobject.Limits","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nX Y : C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nf : Quiver.Hom X Y\ninst✝¹ : CategoryTheory.Limits.HasKernel f\nZ : C\nh : Quiver.Hom Y Z\ninst✝ : CategoryTheory.Mono h\n⊢ CategoryTheory.IsIso ((CategoryTheory.Limits.kernelSubobject f).ofLE (CategoryTheory.Limits.kernelSubobject (CategoryTheory.CategoryStruct.comp f h)) ⋯)","decl":"instance kernelSubobject_comp_mono_isIso (f : X ⟶ Y) [HasKernel f] {Z : C} (h : Y ⟶ Z) [Mono h] :\n    IsIso (Subobject.ofLE _ _ (kernelSubobject_comp_le f h)) := by\n  rw [ofLE_mk_le_mk_of_comm (kernelCompMono f h).inv]\n  · infer_instance\n  · simp\n\n"}
{"name":"CategoryTheory.Limits.cokernelOrderHom_coe","module":"Mathlib.CategoryTheory.Subobject.Limits","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝ : CategoryTheory.Limits.HasCokernels C\nX : C\na✝ : CategoryTheory.Subobject X\n⊢ Eq ((CategoryTheory.Limits.cokernelOrderHom X) a✝) (CategoryTheory.Subobject.lift (fun x f x_1 => CategoryTheory.Subobject.mk (CategoryTheory.Limits.cokernel.π f).op) ⋯ a✝)","decl":"/-- Taking cokernels is an order-reversing map from the subobjects of `X` to the quotient objects\n    of `X`. -/\n@[simps]\ndef cokernelOrderHom [HasCokernels C] (X : C) : Subobject X →o (Subobject (op X))ᵒᵈ where\n  toFun :=\n    Subobject.lift (fun _ f _ => Subobject.mk (cokernel.π f).op)\n      (by\n        rintro A B f g hf hg i rfl\n        refine Subobject.mk_eq_mk_of_comm _ _ (Iso.op ?_) (Quiver.Hom.unop_inj ?_)\n        · exact (IsColimit.coconePointUniqueUpToIso (colimit.isColimit _)\n            (isCokernelEpiComp (colimit.isColimit _) i.hom rfl)).symm\n        · simp only [Iso.comp_inv_eq, Iso.op_hom, Iso.symm_hom, unop_comp, Quiver.Hom.unop_op,\n            colimit.comp_coconePointUniqueUpToIso_hom, Cofork.ofπ_ι_app,\n            coequalizer.cofork_π])\n  monotone' :=\n    Subobject.ind₂ _ <| by\n      intro A B f g hf hg h\n      dsimp only [Subobject.lift_mk]\n      refine Subobject.mk_le_mk_of_comm (cokernel.desc f (cokernel.π g) ?_).op ?_\n      · rw [← Subobject.ofMkLEMk_comp h, Category.assoc, cokernel.condition, comp_zero]\n      · exact Quiver.Hom.unop_inj (cokernel.π_desc _ _ _)\n\n"}
{"name":"CategoryTheory.Limits.kernelOrderHom_coe","module":"Mathlib.CategoryTheory.Subobject.Limits","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝ : CategoryTheory.Limits.HasKernels C\nX : C\na✝ : CategoryTheory.Subobject { unop := X }\n⊢ Eq ((CategoryTheory.Limits.kernelOrderHom X) a✝) (CategoryTheory.Subobject.lift (fun x f x_1 => CategoryTheory.Subobject.mk (CategoryTheory.Limits.kernel.ι f.unop)) ⋯ a✝)","decl":"/-- Taking kernels is an order-reversing map from the quotient objects of `X` to the subobjects of\n    `X`. -/\n@[simps]\ndef kernelOrderHom [HasKernels C] (X : C) : (Subobject (op X))ᵒᵈ →o Subobject X where\n  toFun :=\n    Subobject.lift (fun _ f _ => Subobject.mk (kernel.ι f.unop))\n      (by\n        rintro A B f g hf hg i rfl\n        refine Subobject.mk_eq_mk_of_comm _ _ ?_ ?_\n        · exact\n            IsLimit.conePointUniqueUpToIso (limit.isLimit _)\n              (isKernelCompMono (limit.isLimit (parallelPair g.unop 0)) i.unop.hom rfl)\n        · dsimp\n          simp only [← Iso.eq_inv_comp, limit.conePointUniqueUpToIso_inv_comp,\n            Fork.ofι_π_app])\n  monotone' :=\n    Subobject.ind₂ _ <| by\n      intro A B f g hf hg h\n      dsimp only [Subobject.lift_mk]\n      refine Subobject.mk_le_mk_of_comm (kernel.lift g.unop (kernel.ι f.unop) ?_) ?_\n      · rw [← Subobject.ofMkLEMk_comp h, unop_comp, kernel.condition_assoc, zero_comp]\n      · exact Quiver.Hom.op_inj (by simp)\n\n"}
{"name":"CategoryTheory.Limits.imageSubobject_arrow","module":"Mathlib.CategoryTheory.Subobject.Limits","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.Limits.HasImage f\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.imageSubobjectIso f).hom (CategoryTheory.Limits.image.ι f)) (CategoryTheory.Limits.imageSubobject f).arrow","decl":"@[reassoc (attr := simp)]\ntheorem imageSubobject_arrow :\n    (imageSubobjectIso f).hom ≫ image.ι f = (imageSubobject f).arrow := by simp [imageSubobjectIso]\n\n"}
{"name":"CategoryTheory.Limits.imageSubobject_arrow_assoc","module":"Mathlib.CategoryTheory.Subobject.Limits","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.Limits.HasImage f\nZ : C\nh : Quiver.Hom Y Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.imageSubobjectIso f).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.image.ι f) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.imageSubobject f).arrow h)","decl":"@[reassoc (attr := simp)]\ntheorem imageSubobject_arrow :\n    (imageSubobjectIso f).hom ≫ image.ι f = (imageSubobject f).arrow := by simp [imageSubobjectIso]\n\n"}
{"name":"CategoryTheory.Limits.imageSubobject_arrow'","module":"Mathlib.CategoryTheory.Subobject.Limits","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.Limits.HasImage f\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.imageSubobjectIso f).inv (CategoryTheory.Limits.imageSubobject f).arrow) (CategoryTheory.Limits.image.ι f)","decl":"@[reassoc (attr := simp)]\ntheorem imageSubobject_arrow' :\n    (imageSubobjectIso f).inv ≫ (imageSubobject f).arrow = image.ι f := by simp [imageSubobjectIso]\n\n"}
{"name":"CategoryTheory.Limits.imageSubobject_arrow'_assoc","module":"Mathlib.CategoryTheory.Subobject.Limits","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.Limits.HasImage f\nZ : C\nh : Quiver.Hom Y Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.imageSubobjectIso f).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.imageSubobject f).arrow h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.image.ι f) h)","decl":"@[reassoc (attr := simp)]\ntheorem imageSubobject_arrow' :\n    (imageSubobjectIso f).inv ≫ (imageSubobject f).arrow = image.ι f := by simp [imageSubobjectIso]\n\n"}
{"name":"CategoryTheory.Limits.instEpiFactorThruImageSubobjectOfHasEqualizers","module":"Mathlib.CategoryTheory.Subobject.Limits","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\ninst✝¹ : CategoryTheory.Limits.HasImage f\ninst✝ : CategoryTheory.Limits.HasEqualizers C\n⊢ CategoryTheory.Epi (CategoryTheory.Limits.factorThruImageSubobject f)","decl":"instance [HasEqualizers C] : Epi (factorThruImageSubobject f) := by\n  dsimp [factorThruImageSubobject]\n  apply epi_comp\n\n"}
{"name":"CategoryTheory.Limits.imageSubobject_arrow_comp_assoc","module":"Mathlib.CategoryTheory.Subobject.Limits","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.Limits.HasImage f\nZ : C\nh : Quiver.Hom Y Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.factorThruImageSubobject f) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.imageSubobject f).arrow h)) (CategoryTheory.CategoryStruct.comp f h)","decl":"@[reassoc (attr := simp), elementwise (attr := simp)]\ntheorem imageSubobject_arrow_comp : factorThruImageSubobject f ≫ (imageSubobject f).arrow = f := by\n  simp [factorThruImageSubobject, imageSubobject_arrow]\n\n"}
{"name":"CategoryTheory.Limits.imageSubobject_arrow_comp","module":"Mathlib.CategoryTheory.Subobject.Limits","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.Limits.HasImage f\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.factorThruImageSubobject f) (CategoryTheory.Limits.imageSubobject f).arrow) f","decl":"@[reassoc (attr := simp), elementwise (attr := simp)]\ntheorem imageSubobject_arrow_comp : factorThruImageSubobject f ≫ (imageSubobject f).arrow = f := by\n  simp [factorThruImageSubobject, imageSubobject_arrow]\n\n"}
{"name":"CategoryTheory.Limits.imageSubobject_arrow_comp_apply","module":"Mathlib.CategoryTheory.Subobject.Limits","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.Limits.HasImage f\ninst : CategoryTheory.HasForget C\nx : (CategoryTheory.forget C).obj X\n⊢ Eq ((CategoryTheory.Limits.imageSubobject f).arrow ((CategoryTheory.Limits.factorThruImageSubobject f) x)) (f x)","decl":"@[reassoc (attr := simp), elementwise (attr := simp)]\ntheorem imageSubobject_arrow_comp : factorThruImageSubobject f ≫ (imageSubobject f).arrow = f := by\n  simp [factorThruImageSubobject, imageSubobject_arrow]\n\n"}
{"name":"CategoryTheory.Limits.imageSubobject_arrow_comp_eq_zero","module":"Mathlib.CategoryTheory.Subobject.Limits","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nX Y Z : C\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\ninst✝¹ : CategoryTheory.Limits.HasImage f\ninst✝ : CategoryTheory.Epi (CategoryTheory.Limits.factorThruImageSubobject f)\nh : Eq (CategoryTheory.CategoryStruct.comp f g) 0\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.imageSubobject f).arrow g) 0","decl":"theorem imageSubobject_arrow_comp_eq_zero [HasZeroMorphisms C] {X Y Z : C} {f : X ⟶ Y} {g : Y ⟶ Z}\n    [HasImage f] [Epi (factorThruImageSubobject f)] (h : f ≫ g = 0) :\n    (imageSubobject f).arrow ≫ g = 0 :=\n  zero_of_epi_comp (factorThruImageSubobject f) <| by simp [h]\n\n"}
{"name":"CategoryTheory.Limits.imageSubobject_factors_comp_self","module":"Mathlib.CategoryTheory.Subobject.Limits","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.Limits.HasImage f\nW : C\nk : Quiver.Hom W X\n⊢ (CategoryTheory.Limits.imageSubobject f).Factors (CategoryTheory.CategoryStruct.comp k f)","decl":"theorem imageSubobject_factors_comp_self {W : C} (k : W ⟶ X) : (imageSubobject f).Factors (k ≫ f) :=\n  ⟨k ≫ factorThruImage f, by simp⟩\n\n"}
{"name":"CategoryTheory.Limits.factorThruImageSubobject_comp_self","module":"Mathlib.CategoryTheory.Subobject.Limits","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.Limits.HasImage f\nW : C\nk : Quiver.Hom W X\nh : (CategoryTheory.Limits.imageSubobject f).Factors (CategoryTheory.CategoryStruct.comp k f)\n⊢ Eq ((CategoryTheory.Limits.imageSubobject f).factorThru (CategoryTheory.CategoryStruct.comp k f) h) (CategoryTheory.CategoryStruct.comp k (CategoryTheory.Limits.factorThruImageSubobject f))","decl":"@[simp]\ntheorem factorThruImageSubobject_comp_self {W : C} (k : W ⟶ X) (h) :\n    (imageSubobject f).factorThru (k ≫ f) h = k ≫ factorThruImageSubobject f := by\n  ext\n  simp\n\n"}
{"name":"CategoryTheory.Limits.factorThruImageSubobject_comp_self_assoc","module":"Mathlib.CategoryTheory.Subobject.Limits","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.Limits.HasImage f\nW W' : C\nk : Quiver.Hom W W'\nk' : Quiver.Hom W' X\nh : (CategoryTheory.Limits.imageSubobject f).Factors (CategoryTheory.CategoryStruct.comp k (CategoryTheory.CategoryStruct.comp k' f))\n⊢ Eq ((CategoryTheory.Limits.imageSubobject f).factorThru (CategoryTheory.CategoryStruct.comp k (CategoryTheory.CategoryStruct.comp k' f)) h) (CategoryTheory.CategoryStruct.comp k (CategoryTheory.CategoryStruct.comp k' (CategoryTheory.Limits.factorThruImageSubobject f)))","decl":"@[simp]\ntheorem factorThruImageSubobject_comp_self_assoc {W W' : C} (k : W ⟶ W') (k' : W' ⟶ X) (h) :\n    (imageSubobject f).factorThru (k ≫ k' ≫ f) h = k ≫ k' ≫ factorThruImageSubobject f := by\n  ext\n  simp\n\n"}
{"name":"CategoryTheory.Limits.imageSubobject_comp_le","module":"Mathlib.CategoryTheory.Subobject.Limits","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nX Y X' : C\nh : Quiver.Hom X' X\nf : Quiver.Hom X Y\ninst✝¹ : CategoryTheory.Limits.HasImage f\ninst✝ : CategoryTheory.Limits.HasImage (CategoryTheory.CategoryStruct.comp h f)\n⊢ LE.le (CategoryTheory.Limits.imageSubobject (CategoryTheory.CategoryStruct.comp h f)) (CategoryTheory.Limits.imageSubobject f)","decl":"/-- The image of `h ≫ f` is always a smaller subobject than the image of `f`. -/\ntheorem imageSubobject_comp_le {X' : C} (h : X' ⟶ X) (f : X ⟶ Y) [HasImage f] [HasImage (h ≫ f)] :\n    imageSubobject (h ≫ f) ≤ imageSubobject f :=\n  Subobject.mk_le_mk_of_comm (image.preComp h f) (by simp)\n\n"}
{"name":"CategoryTheory.Limits.imageSubobject_zero_arrow","module":"Mathlib.CategoryTheory.Subobject.Limits","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nX Y : C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝ : CategoryTheory.Limits.HasZeroObject C\n⊢ Eq (CategoryTheory.Limits.imageSubobject 0).arrow 0","decl":"@[simp]\ntheorem imageSubobject_zero_arrow : (imageSubobject (0 : X ⟶ Y)).arrow = 0 := by\n  rw [← imageSubobject_arrow]\n  simp\n\n"}
{"name":"CategoryTheory.Limits.imageSubobject_zero","module":"Mathlib.CategoryTheory.Subobject.Limits","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝ : CategoryTheory.Limits.HasZeroObject C\nA B : C\n⊢ Eq (CategoryTheory.Limits.imageSubobject 0) Bot.bot","decl":"@[simp]\ntheorem imageSubobject_zero {A B : C} : imageSubobject (0 : A ⟶ B) = ⊥ :=\n  Subobject.eq_of_comm (imageSubobjectIso _ ≪≫ imageZero ≪≫ Subobject.botCoeIsoZero.symm) (by simp)\n\n"}
{"name":"CategoryTheory.Limits.imageSubobject_comp_le_epi_of_epi","module":"Mathlib.CategoryTheory.Subobject.Limits","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nX Y X' : C\nh : Quiver.Hom X' X\ninst✝² : CategoryTheory.Epi h\nf : Quiver.Hom X Y\ninst✝¹ : CategoryTheory.Limits.HasImage f\ninst✝ : CategoryTheory.Limits.HasImage (CategoryTheory.CategoryStruct.comp h f)\n⊢ CategoryTheory.Epi ((CategoryTheory.Limits.imageSubobject (CategoryTheory.CategoryStruct.comp h f)).ofLE (CategoryTheory.Limits.imageSubobject f) ⋯)","decl":"/-- The morphism `imageSubobject (h ≫ f) ⟶ imageSubobject f`\nis an epimorphism when `h` is an epimorphism.\nIn general this does not imply that `imageSubobject (h ≫ f) = imageSubobject f`,\nalthough it will when the ambient category is abelian.\n -/\ninstance imageSubobject_comp_le_epi_of_epi {X' : C} (h : X' ⟶ X) [Epi h] (f : X ⟶ Y) [HasImage f]\n    [HasImage (h ≫ f)] : Epi (Subobject.ofLE _ _ (imageSubobject_comp_le h f)) := by\n  rw [ofLE_mk_le_mk_of_comm (image.preComp h f)]\n  · infer_instance\n  · simp\n\n"}
{"name":"CategoryTheory.Limits.imageSubobjectCompIso_hom_arrow","module":"Mathlib.CategoryTheory.Subobject.Limits","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nX Y : C\ninst✝² : CategoryTheory.Limits.HasEqualizers C\nf : Quiver.Hom X Y\ninst✝¹ : CategoryTheory.Limits.HasImage f\nY' : C\nh : Quiver.Hom Y Y'\ninst✝ : CategoryTheory.IsIso h\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.imageSubobjectCompIso f h).hom (CategoryTheory.Limits.imageSubobject f).arrow) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.imageSubobject (CategoryTheory.CategoryStruct.comp f h)).arrow (CategoryTheory.inv h))","decl":"@[reassoc (attr := simp)]\ntheorem imageSubobjectCompIso_hom_arrow (f : X ⟶ Y) [HasImage f] {Y' : C} (h : Y ⟶ Y') [IsIso h] :\n    (imageSubobjectCompIso f h).hom ≫ (imageSubobject f).arrow =\n      (imageSubobject (f ≫ h)).arrow ≫ inv h := by\n  simp [imageSubobjectCompIso]\n\n"}
{"name":"CategoryTheory.Limits.imageSubobjectCompIso_hom_arrow_assoc","module":"Mathlib.CategoryTheory.Subobject.Limits","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nX Y : C\ninst✝² : CategoryTheory.Limits.HasEqualizers C\nf : Quiver.Hom X Y\ninst✝¹ : CategoryTheory.Limits.HasImage f\nY' : C\nh✝ : Quiver.Hom Y Y'\ninst✝ : CategoryTheory.IsIso h✝\nZ : C\nh : Quiver.Hom Y Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.imageSubobjectCompIso f h✝).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.imageSubobject f).arrow h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.imageSubobject (CategoryTheory.CategoryStruct.comp f h✝)).arrow (CategoryTheory.CategoryStruct.comp (CategoryTheory.inv h✝) h))","decl":"@[reassoc (attr := simp)]\ntheorem imageSubobjectCompIso_hom_arrow (f : X ⟶ Y) [HasImage f] {Y' : C} (h : Y ⟶ Y') [IsIso h] :\n    (imageSubobjectCompIso f h).hom ≫ (imageSubobject f).arrow =\n      (imageSubobject (f ≫ h)).arrow ≫ inv h := by\n  simp [imageSubobjectCompIso]\n\n"}
{"name":"CategoryTheory.Limits.imageSubobjectCompIso_inv_arrow","module":"Mathlib.CategoryTheory.Subobject.Limits","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nX Y : C\ninst✝² : CategoryTheory.Limits.HasEqualizers C\nf : Quiver.Hom X Y\ninst✝¹ : CategoryTheory.Limits.HasImage f\nY' : C\nh : Quiver.Hom Y Y'\ninst✝ : CategoryTheory.IsIso h\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.imageSubobjectCompIso f h).inv (CategoryTheory.Limits.imageSubobject (CategoryTheory.CategoryStruct.comp f h)).arrow) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.imageSubobject f).arrow h)","decl":"@[reassoc (attr := simp)]\ntheorem imageSubobjectCompIso_inv_arrow (f : X ⟶ Y) [HasImage f] {Y' : C} (h : Y ⟶ Y') [IsIso h] :\n    (imageSubobjectCompIso f h).inv ≫ (imageSubobject (f ≫ h)).arrow =\n      (imageSubobject f).arrow ≫ h := by\n  simp [imageSubobjectCompIso]\n\n"}
{"name":"CategoryTheory.Limits.imageSubobjectCompIso_inv_arrow_assoc","module":"Mathlib.CategoryTheory.Subobject.Limits","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nX Y : C\ninst✝² : CategoryTheory.Limits.HasEqualizers C\nf : Quiver.Hom X Y\ninst✝¹ : CategoryTheory.Limits.HasImage f\nY' : C\nh✝ : Quiver.Hom Y Y'\ninst✝ : CategoryTheory.IsIso h✝\nZ : C\nh : Quiver.Hom Y' Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.imageSubobjectCompIso f h✝).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.imageSubobject (CategoryTheory.CategoryStruct.comp f h✝)).arrow h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.imageSubobject f).arrow (CategoryTheory.CategoryStruct.comp h✝ h))","decl":"@[reassoc (attr := simp)]\ntheorem imageSubobjectCompIso_inv_arrow (f : X ⟶ Y) [HasImage f] {Y' : C} (h : Y ⟶ Y') [IsIso h] :\n    (imageSubobjectCompIso f h).inv ≫ (imageSubobject (f ≫ h)).arrow =\n      (imageSubobject f).arrow ≫ h := by\n  simp [imageSubobjectCompIso]\n\n"}
{"name":"CategoryTheory.Limits.imageSubobject_mono","module":"Mathlib.CategoryTheory.Subobject.Limits","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.Mono f\n⊢ Eq (CategoryTheory.Limits.imageSubobject f) (CategoryTheory.Subobject.mk f)","decl":"theorem imageSubobject_mono (f : X ⟶ Y) [Mono f] : imageSubobject f = Subobject.mk f :=\n  eq_of_comm (imageSubobjectIso f ≪≫ imageMonoIsoSource f ≪≫ (underlyingIso f).symm) (by simp)\n\n"}
{"name":"CategoryTheory.Limits.imageSubobject_iso_comp","module":"Mathlib.CategoryTheory.Subobject.Limits","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nX Y : C\ninst✝² : CategoryTheory.Limits.HasEqualizers C\nX' : C\nh : Quiver.Hom X' X\ninst✝¹ : CategoryTheory.IsIso h\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.Limits.HasImage f\n⊢ Eq (CategoryTheory.Limits.imageSubobject (CategoryTheory.CategoryStruct.comp h f)) (CategoryTheory.Limits.imageSubobject f)","decl":"/-- Precomposing by an isomorphism does not change the image subobject. -/\ntheorem imageSubobject_iso_comp [HasEqualizers C] {X' : C} (h : X' ⟶ X) [IsIso h] (f : X ⟶ Y)\n    [HasImage f] : imageSubobject (h ≫ f) = imageSubobject f :=\n  le_antisymm (imageSubobject_comp_le h f)\n    (Subobject.mk_le_mk_of_comm (inv (image.preComp h f)) (by simp))\n\n"}
{"name":"CategoryTheory.Limits.imageSubobject_le","module":"Mathlib.CategoryTheory.Subobject.Limits","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nA B : C\nX : CategoryTheory.Subobject B\nf : Quiver.Hom A B\ninst✝ : CategoryTheory.Limits.HasImage f\nh : Quiver.Hom A (CategoryTheory.Subobject.underlying.obj X)\nw : Eq (CategoryTheory.CategoryStruct.comp h X.arrow) f\n⊢ LE.le (CategoryTheory.Limits.imageSubobject f) X","decl":"theorem imageSubobject_le {A B : C} {X : Subobject B} (f : A ⟶ B) [HasImage f] (h : A ⟶ X)\n    (w : h ≫ X.arrow = f) : imageSubobject f ≤ X :=\n  Subobject.le_of_comm\n    ((imageSubobjectIso f).hom ≫\n      image.lift\n        { I := (X : C)\n          e := h\n          m := X.arrow })\n    (by rw [assoc, image.lift_fac, imageSubobject_arrow])\n\n"}
{"name":"CategoryTheory.Limits.imageSubobject_le_mk","module":"Mathlib.CategoryTheory.Subobject.Limits","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nA B X : C\ng : Quiver.Hom X B\ninst✝¹ : CategoryTheory.Mono g\nf : Quiver.Hom A B\ninst✝ : CategoryTheory.Limits.HasImage f\nh : Quiver.Hom A X\nw : Eq (CategoryTheory.CategoryStruct.comp h g) f\n⊢ LE.le (CategoryTheory.Limits.imageSubobject f) (CategoryTheory.Subobject.mk g)","decl":"theorem imageSubobject_le_mk {A B : C} {X : C} (g : X ⟶ B) [Mono g] (f : A ⟶ B) [HasImage f]\n    (h : A ⟶ X) (w : h ≫ g = f) : imageSubobject f ≤ Subobject.mk g :=\n  imageSubobject_le f (h ≫ (Subobject.underlyingIso g).inv) (by simp [w])\n\n"}
{"name":"CategoryTheory.Limits.imageSubobjectMap_arrow_assoc","module":"Mathlib.CategoryTheory.Subobject.Limits","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nW X Y Z✝ : C\nf : Quiver.Hom W X\ninst✝² : CategoryTheory.Limits.HasImage f\ng : Quiver.Hom Y Z✝\ninst✝¹ : CategoryTheory.Limits.HasImage g\nsq : Quiver.Hom (CategoryTheory.Arrow.mk f) (CategoryTheory.Arrow.mk g)\ninst✝ : CategoryTheory.Limits.HasImageMap sq\nZ : C\nh : Quiver.Hom Z✝ Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.imageSubobjectMap sq) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.imageSubobject g).arrow h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.imageSubobject f).arrow (CategoryTheory.CategoryStruct.comp sq.right h))","decl":"@[reassoc (attr := simp)]\ntheorem imageSubobjectMap_arrow {W X Y Z : C} {f : W ⟶ X} [HasImage f] {g : Y ⟶ Z} [HasImage g]\n    (sq : Arrow.mk f ⟶ Arrow.mk g) [HasImageMap sq] :\n    imageSubobjectMap sq ≫ (imageSubobject g).arrow = (imageSubobject f).arrow ≫ sq.right := by\n  simp only [imageSubobjectMap, Category.assoc, imageSubobject_arrow']\n  erw [image.map_ι, ← Category.assoc, imageSubobject_arrow]\n\n"}
{"name":"CategoryTheory.Limits.imageSubobjectMap_arrow","module":"Mathlib.CategoryTheory.Subobject.Limits","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nW X Y Z : C\nf : Quiver.Hom W X\ninst✝² : CategoryTheory.Limits.HasImage f\ng : Quiver.Hom Y Z\ninst✝¹ : CategoryTheory.Limits.HasImage g\nsq : Quiver.Hom (CategoryTheory.Arrow.mk f) (CategoryTheory.Arrow.mk g)\ninst✝ : CategoryTheory.Limits.HasImageMap sq\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.imageSubobjectMap sq) (CategoryTheory.Limits.imageSubobject g).arrow) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.imageSubobject f).arrow sq.right)","decl":"@[reassoc (attr := simp)]\ntheorem imageSubobjectMap_arrow {W X Y Z : C} {f : W ⟶ X} [HasImage f] {g : Y ⟶ Z} [HasImage g]\n    (sq : Arrow.mk f ⟶ Arrow.mk g) [HasImageMap sq] :\n    imageSubobjectMap sq ≫ (imageSubobject g).arrow = (imageSubobject f).arrow ≫ sq.right := by\n  simp only [imageSubobjectMap, Category.assoc, imageSubobject_arrow']\n  erw [image.map_ι, ← Category.assoc, imageSubobject_arrow]\n\n"}
{"name":"CategoryTheory.Limits.image_map_comp_imageSubobjectIso_inv","module":"Mathlib.CategoryTheory.Subobject.Limits","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nW X Y Z : C\nf : Quiver.Hom W X\ninst✝² : CategoryTheory.Limits.HasImage f\ng : Quiver.Hom Y Z\ninst✝¹ : CategoryTheory.Limits.HasImage g\nsq : Quiver.Hom (CategoryTheory.Arrow.mk f) (CategoryTheory.Arrow.mk g)\ninst✝ : CategoryTheory.Limits.HasImageMap sq\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.image.map sq) (CategoryTheory.Limits.imageSubobjectIso (CategoryTheory.Arrow.mk g).hom).inv) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.imageSubobjectIso f).inv (CategoryTheory.Limits.imageSubobjectMap sq))","decl":"theorem image_map_comp_imageSubobjectIso_inv {W X Y Z : C} {f : W ⟶ X} [HasImage f] {g : Y ⟶ Z}\n    [HasImage g] (sq : Arrow.mk f ⟶ Arrow.mk g) [HasImageMap sq] :\n    image.map sq ≫ (imageSubobjectIso _).inv =\n      (imageSubobjectIso _).inv ≫ imageSubobjectMap sq := by\n  ext\n  simpa using image.map_ι sq\n\n"}
{"name":"CategoryTheory.Limits.imageSubobjectIso_comp_image_map","module":"Mathlib.CategoryTheory.Subobject.Limits","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nW X Y Z : C\nf : Quiver.Hom W X\ninst✝² : CategoryTheory.Limits.HasImage f\ng : Quiver.Hom Y Z\ninst✝¹ : CategoryTheory.Limits.HasImage g\nsq : Quiver.Hom (CategoryTheory.Arrow.mk f) (CategoryTheory.Arrow.mk g)\ninst✝ : CategoryTheory.Limits.HasImageMap sq\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.imageSubobjectIso (CategoryTheory.Arrow.mk f).hom).hom (CategoryTheory.Limits.image.map sq)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.imageSubobjectMap sq) (CategoryTheory.Limits.imageSubobjectIso g).hom)","decl":"theorem imageSubobjectIso_comp_image_map {W X Y Z : C} {f : W ⟶ X} [HasImage f] {g : Y ⟶ Z}\n    [HasImage g] (sq : Arrow.mk f ⟶ Arrow.mk g) [HasImageMap sq] :\n    (imageSubobjectIso _).hom ≫ image.map sq =\n      imageSubobjectMap sq ≫ (imageSubobjectIso _).hom := by\n  erw [← Iso.comp_inv_eq, Category.assoc, ← (imageSubobjectIso f).eq_inv_comp,\n    image_map_comp_imageSubobjectIso_inv sq]\n\n"}
