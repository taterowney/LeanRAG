{"name":"FloorDiv.zero_floorDiv","module":"Mathlib.Algebra.Order.Floor.Div","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝² : OrderedAddCommMonoid α\ninst✝¹ : OrderedAddCommMonoid β\ninst✝ : SMulZeroClass α β\nself : FloorDiv α β\na : α\n⊢ Eq (FloorDiv.floorDiv 0 a) 0","decl":"/-- Typeclass for division rounded down. For each `a > 0`, this asserts the existence of a right\nadjoint to the map `b ↦ a • b : β → β`. -/\nclass FloorDiv where\n  /-- Flooring division. If `a > 0`, then `b ⌊/⌋ a` is the greatest `c` such that `a • c ≤ b`. -/\n  floorDiv : β → α → β\n  /-- Do not use this. Use `gc_floorDiv_smul` or `gc_floorDiv_mul` instead. -/\n  protected floorDiv_gc ⦃a⦄ : 0 < a → GaloisConnection (a • ·) (floorDiv · a)\n  /-- Do not use this. Use `floorDiv_nonpos` instead. -/\n  protected floorDiv_nonpos ⦃a⦄ : a ≤ 0 → ∀ b, floorDiv b a = 0\n  /-- Do not use this. Use `zero_floorDiv` instead. -/\n  protected zero_floorDiv (a) : floorDiv 0 a = 0\n\n"}
{"name":"FloorDiv.floorDiv_gc","module":"Mathlib.Algebra.Order.Floor.Div","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝² : OrderedAddCommMonoid α\ninst✝¹ : OrderedAddCommMonoid β\ninst✝ : SMulZeroClass α β\nself : FloorDiv α β\na : α\na✝ : LT.lt 0 a\n⊢ GaloisConnection (fun x => HSMul.hSMul a x) fun x => FloorDiv.floorDiv x a","decl":"/-- Typeclass for division rounded down. For each `a > 0`, this asserts the existence of a right\nadjoint to the map `b ↦ a • b : β → β`. -/\nclass FloorDiv where\n  /-- Flooring division. If `a > 0`, then `b ⌊/⌋ a` is the greatest `c` such that `a • c ≤ b`. -/\n  floorDiv : β → α → β\n  /-- Do not use this. Use `gc_floorDiv_smul` or `gc_floorDiv_mul` instead. -/\n  protected floorDiv_gc ⦃a⦄ : 0 < a → GaloisConnection (a • ·) (floorDiv · a)\n  /-- Do not use this. Use `floorDiv_nonpos` instead. -/\n  protected floorDiv_nonpos ⦃a⦄ : a ≤ 0 → ∀ b, floorDiv b a = 0\n  /-- Do not use this. Use `zero_floorDiv` instead. -/\n  protected zero_floorDiv (a) : floorDiv 0 a = 0\n\n"}
{"name":"FloorDiv.floorDiv_nonpos","module":"Mathlib.Algebra.Order.Floor.Div","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝² : OrderedAddCommMonoid α\ninst✝¹ : OrderedAddCommMonoid β\ninst✝ : SMulZeroClass α β\nself : FloorDiv α β\na : α\na✝ : LE.le a 0\nb : β\n⊢ Eq (FloorDiv.floorDiv b a) 0","decl":"/-- Typeclass for division rounded down. For each `a > 0`, this asserts the existence of a right\nadjoint to the map `b ↦ a • b : β → β`. -/\nclass FloorDiv where\n  /-- Flooring division. If `a > 0`, then `b ⌊/⌋ a` is the greatest `c` such that `a • c ≤ b`. -/\n  floorDiv : β → α → β\n  /-- Do not use this. Use `gc_floorDiv_smul` or `gc_floorDiv_mul` instead. -/\n  protected floorDiv_gc ⦃a⦄ : 0 < a → GaloisConnection (a • ·) (floorDiv · a)\n  /-- Do not use this. Use `floorDiv_nonpos` instead. -/\n  protected floorDiv_nonpos ⦃a⦄ : a ≤ 0 → ∀ b, floorDiv b a = 0\n  /-- Do not use this. Use `zero_floorDiv` instead. -/\n  protected zero_floorDiv (a) : floorDiv 0 a = 0\n\n"}
{"name":"CeilDiv.zero_ceilDiv","module":"Mathlib.Algebra.Order.Floor.Div","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝² : OrderedAddCommMonoid α\ninst✝¹ : OrderedAddCommMonoid β\ninst✝ : SMulZeroClass α β\nself : CeilDiv α β\na : α\n⊢ Eq (CeilDiv.ceilDiv 0 a) 0","decl":"/-- Typeclass for division rounded up. For each `a > 0`, this asserts the existence of a left\nadjoint to the map `b ↦ a • b : β → β`. -/\nclass CeilDiv where\n  /-- Ceiling division. If `a > 0`, then `b ⌈/⌉ a` is the least `c` such that `b ≤ a • c`. -/\n  ceilDiv : β → α → β\n  /-- Do not use this. Use `gc_smul_ceilDiv` or `gc_mul_ceilDiv` instead. -/\n  protected ceilDiv_gc ⦃a⦄ : 0 < a → GaloisConnection (ceilDiv · a) (a • ·)\n  /-- Do not use this. Use `ceilDiv_nonpos` instead. -/\n  protected ceilDiv_nonpos ⦃a⦄ : a ≤ 0 → ∀ b, ceilDiv b a = 0\n  /-- Do not use this. Use `zero_ceilDiv` instead. -/\n  protected zero_ceilDiv (a) : ceilDiv 0 a = 0\n\n"}
{"name":"CeilDiv.ceilDiv_gc","module":"Mathlib.Algebra.Order.Floor.Div","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝² : OrderedAddCommMonoid α\ninst✝¹ : OrderedAddCommMonoid β\ninst✝ : SMulZeroClass α β\nself : CeilDiv α β\na : α\na✝ : LT.lt 0 a\n⊢ GaloisConnection (fun x => CeilDiv.ceilDiv x a) fun x => HSMul.hSMul a x","decl":"/-- Typeclass for division rounded up. For each `a > 0`, this asserts the existence of a left\nadjoint to the map `b ↦ a • b : β → β`. -/\nclass CeilDiv where\n  /-- Ceiling division. If `a > 0`, then `b ⌈/⌉ a` is the least `c` such that `b ≤ a • c`. -/\n  ceilDiv : β → α → β\n  /-- Do not use this. Use `gc_smul_ceilDiv` or `gc_mul_ceilDiv` instead. -/\n  protected ceilDiv_gc ⦃a⦄ : 0 < a → GaloisConnection (ceilDiv · a) (a • ·)\n  /-- Do not use this. Use `ceilDiv_nonpos` instead. -/\n  protected ceilDiv_nonpos ⦃a⦄ : a ≤ 0 → ∀ b, ceilDiv b a = 0\n  /-- Do not use this. Use `zero_ceilDiv` instead. -/\n  protected zero_ceilDiv (a) : ceilDiv 0 a = 0\n\n"}
{"name":"CeilDiv.ceilDiv_nonpos","module":"Mathlib.Algebra.Order.Floor.Div","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝² : OrderedAddCommMonoid α\ninst✝¹ : OrderedAddCommMonoid β\ninst✝ : SMulZeroClass α β\nself : CeilDiv α β\na : α\na✝ : LE.le a 0\nb : β\n⊢ Eq (CeilDiv.ceilDiv b a) 0","decl":"/-- Typeclass for division rounded up. For each `a > 0`, this asserts the existence of a left\nadjoint to the map `b ↦ a • b : β → β`. -/\nclass CeilDiv where\n  /-- Ceiling division. If `a > 0`, then `b ⌈/⌉ a` is the least `c` such that `b ≤ a • c`. -/\n  ceilDiv : β → α → β\n  /-- Do not use this. Use `gc_smul_ceilDiv` or `gc_mul_ceilDiv` instead. -/\n  protected ceilDiv_gc ⦃a⦄ : 0 < a → GaloisConnection (ceilDiv · a) (a • ·)\n  /-- Do not use this. Use `ceilDiv_nonpos` instead. -/\n  protected ceilDiv_nonpos ⦃a⦄ : a ≤ 0 → ∀ b, ceilDiv b a = 0\n  /-- Do not use this. Use `zero_ceilDiv` instead. -/\n  protected zero_ceilDiv (a) : ceilDiv 0 a = 0\n\n"}
{"name":"gc_floorDiv_smul","module":"Mathlib.Algebra.Order.Floor.Div","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : OrderedAddCommMonoid α\ninst✝² : OrderedAddCommMonoid β\ninst✝¹ : SMulZeroClass α β\ninst✝ : FloorDiv α β\na : α\nha : LT.lt 0 a\n⊢ GaloisConnection (fun x => HSMul.hSMul a x) fun x => FloorDiv.floorDiv x a","decl":"lemma gc_floorDiv_smul (ha : 0 < a) : GaloisConnection (a • · : β → β) (· ⌊/⌋ a) :=\n  FloorDiv.floorDiv_gc ha\n\n"}
{"name":"le_floorDiv_iff_smul_le","module":"Mathlib.Algebra.Order.Floor.Div","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : OrderedAddCommMonoid α\ninst✝² : OrderedAddCommMonoid β\ninst✝¹ : SMulZeroClass α β\ninst✝ : FloorDiv α β\na : α\nb c : β\nha : LT.lt 0 a\n⊢ Iff (LE.le c (FloorDiv.floorDiv b a)) (LE.le (HSMul.hSMul a c) b)","decl":"@[simp] lemma le_floorDiv_iff_smul_le (ha : 0 < a) : c ≤ b ⌊/⌋ a ↔ a • c ≤ b :=\n  (gc_floorDiv_smul ha _ _).symm\n\n"}
{"name":"floorDiv_of_nonpos","module":"Mathlib.Algebra.Order.Floor.Div","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : OrderedAddCommMonoid α\ninst✝² : OrderedAddCommMonoid β\ninst✝¹ : SMulZeroClass α β\ninst✝ : FloorDiv α β\na : α\nha : LE.le a 0\nb : β\n⊢ Eq (FloorDiv.floorDiv b a) 0","decl":"@[simp] lemma floorDiv_of_nonpos (ha : a ≤ 0) (b : β) : b ⌊/⌋ a = 0 := FloorDiv.floorDiv_nonpos ha _\n"}
{"name":"floorDiv_zero","module":"Mathlib.Algebra.Order.Floor.Div","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : OrderedAddCommMonoid α\ninst✝² : OrderedAddCommMonoid β\ninst✝¹ : SMulZeroClass α β\ninst✝ : FloorDiv α β\nb : β\n⊢ Eq (FloorDiv.floorDiv b 0) 0","decl":"lemma floorDiv_zero (b : β) : b ⌊/⌋ (0 : α) = 0 := by simp\n"}
{"name":"zero_floorDiv","module":"Mathlib.Algebra.Order.Floor.Div","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : OrderedAddCommMonoid α\ninst✝² : OrderedAddCommMonoid β\ninst✝¹ : SMulZeroClass α β\ninst✝ : FloorDiv α β\na : α\n⊢ Eq (FloorDiv.floorDiv 0 a) 0","decl":"@[simp] lemma zero_floorDiv (a : α) : (0 : β) ⌊/⌋ a = 0 := FloorDiv.zero_floorDiv _\n\n"}
{"name":"smul_floorDiv_le","module":"Mathlib.Algebra.Order.Floor.Div","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : OrderedAddCommMonoid α\ninst✝² : OrderedAddCommMonoid β\ninst✝¹ : SMulZeroClass α β\ninst✝ : FloorDiv α β\na : α\nb : β\nha : LT.lt 0 a\n⊢ LE.le (HSMul.hSMul a (FloorDiv.floorDiv b a)) b","decl":"lemma smul_floorDiv_le (ha : 0 < a) : a • (b ⌊/⌋ a) ≤ b := (le_floorDiv_iff_smul_le ha).1 le_rfl\n\n"}
{"name":"gc_smul_ceilDiv","module":"Mathlib.Algebra.Order.Floor.Div","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : OrderedAddCommMonoid α\ninst✝² : OrderedAddCommMonoid β\ninst✝¹ : SMulZeroClass α β\ninst✝ : CeilDiv α β\na : α\nha : LT.lt 0 a\n⊢ GaloisConnection (fun x => CeilDiv.ceilDiv x a) fun x => HSMul.hSMul a x","decl":"lemma gc_smul_ceilDiv (ha : 0 < a) : GaloisConnection (· ⌈/⌉ a) (a • · : β → β) :=\n  CeilDiv.ceilDiv_gc ha\n\n"}
{"name":"ceilDiv_le_iff_le_smul","module":"Mathlib.Algebra.Order.Floor.Div","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : OrderedAddCommMonoid α\ninst✝² : OrderedAddCommMonoid β\ninst✝¹ : SMulZeroClass α β\ninst✝ : CeilDiv α β\na : α\nb c : β\nha : LT.lt 0 a\n⊢ Iff (LE.le (CeilDiv.ceilDiv b a) c) (LE.le b (HSMul.hSMul a c))","decl":"@[simp]\nlemma ceilDiv_le_iff_le_smul (ha : 0 < a) : b ⌈/⌉ a ≤ c ↔ b ≤ a • c := gc_smul_ceilDiv ha _ _\n\n"}
{"name":"ceilDiv_of_nonpos","module":"Mathlib.Algebra.Order.Floor.Div","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : OrderedAddCommMonoid α\ninst✝² : OrderedAddCommMonoid β\ninst✝¹ : SMulZeroClass α β\ninst✝ : CeilDiv α β\na : α\nha : LE.le a 0\nb : β\n⊢ Eq (CeilDiv.ceilDiv b a) 0","decl":"@[simp] lemma ceilDiv_of_nonpos (ha : a ≤ 0) (b : β) : b ⌈/⌉ a = 0 := CeilDiv.ceilDiv_nonpos ha _\n"}
{"name":"ceilDiv_zero","module":"Mathlib.Algebra.Order.Floor.Div","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : OrderedAddCommMonoid α\ninst✝² : OrderedAddCommMonoid β\ninst✝¹ : SMulZeroClass α β\ninst✝ : CeilDiv α β\nb : β\n⊢ Eq (CeilDiv.ceilDiv b 0) 0","decl":"lemma ceilDiv_zero (b : β) : b ⌈/⌉ (0 : α) = 0 := by simp\n"}
{"name":"zero_ceilDiv","module":"Mathlib.Algebra.Order.Floor.Div","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : OrderedAddCommMonoid α\ninst✝² : OrderedAddCommMonoid β\ninst✝¹ : SMulZeroClass α β\ninst✝ : CeilDiv α β\na : α\n⊢ Eq (CeilDiv.ceilDiv 0 a) 0","decl":"@[simp] lemma zero_ceilDiv (a : α) : (0 : β) ⌈/⌉ a = 0 := CeilDiv.zero_ceilDiv _\n\n"}
{"name":"le_smul_ceilDiv","module":"Mathlib.Algebra.Order.Floor.Div","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : OrderedAddCommMonoid α\ninst✝² : OrderedAddCommMonoid β\ninst✝¹ : SMulZeroClass α β\ninst✝ : CeilDiv α β\na : α\nb : β\nha : LT.lt 0 a\n⊢ LE.le b (HSMul.hSMul a (CeilDiv.ceilDiv b a))","decl":"lemma le_smul_ceilDiv (ha : 0 < a) : b ≤ a • (b ⌈/⌉ a) := (ceilDiv_le_iff_le_smul ha).1 le_rfl\n\n"}
{"name":"floorDiv_le_ceilDiv","module":"Mathlib.Algebra.Order.Floor.Div","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝⁵ : LinearOrderedAddCommMonoid α\ninst✝⁴ : OrderedAddCommMonoid β\ninst✝³ : SMulZeroClass α β\ninst✝² : PosSMulReflectLE α β\ninst✝¹ : FloorDiv α β\ninst✝ : CeilDiv α β\na : α\nb : β\n⊢ LE.le (FloorDiv.floorDiv b a) (CeilDiv.ceilDiv b a)","decl":"lemma floorDiv_le_ceilDiv : b ⌊/⌋ a ≤ b ⌈/⌉ a := by\n  obtain ha | ha := le_or_lt a 0\n  · simp [ha]\n  · exact le_of_smul_le_smul_left ((smul_floorDiv_le ha).trans <| le_smul_ceilDiv ha) ha\n\n"}
{"name":"floorDiv_one","module":"Mathlib.Algebra.Order.Floor.Div","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝⁴ : OrderedSemiring α\ninst✝³ : OrderedAddCommMonoid β\ninst✝² : MulActionWithZero α β\ninst✝¹ : FloorDiv α β\ninst✝ : Nontrivial α\nb : β\n⊢ Eq (FloorDiv.floorDiv b 1) b","decl":"@[simp] lemma floorDiv_one [Nontrivial α] (b : β) : b ⌊/⌋ (1 : α) = b :=\n  eq_of_forall_le_iff <| fun c ↦ by simp [zero_lt_one' α]\n\n"}
{"name":"smul_floorDiv","module":"Mathlib.Algebra.Order.Floor.Div","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝⁵ : OrderedSemiring α\ninst✝⁴ : OrderedAddCommMonoid β\ninst✝³ : MulActionWithZero α β\ninst✝² : FloorDiv α β\na : α\ninst✝¹ : PosSMulMono α β\ninst✝ : PosSMulReflectLE α β\nha : LT.lt 0 a\nb : β\n⊢ Eq (FloorDiv.floorDiv (HSMul.hSMul a b) a) b","decl":"@[simp] lemma smul_floorDiv [PosSMulMono α β] [PosSMulReflectLE α β] (ha : 0 < a) (b : β) :\n    a • b ⌊/⌋ a = b :=\n  eq_of_forall_le_iff <| by simp [smul_le_smul_iff_of_pos_left, ha]\n\n"}
{"name":"ceilDiv_one","module":"Mathlib.Algebra.Order.Floor.Div","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝⁴ : OrderedSemiring α\ninst✝³ : OrderedAddCommMonoid β\ninst✝² : MulActionWithZero α β\ninst✝¹ : CeilDiv α β\ninst✝ : Nontrivial α\nb : β\n⊢ Eq (CeilDiv.ceilDiv b 1) b","decl":"@[simp] lemma ceilDiv_one [Nontrivial α] (b : β) : b ⌈/⌉ (1 : α) = b :=\n  eq_of_forall_ge_iff <| fun c ↦ by simp [zero_lt_one' α]\n\n"}
{"name":"smul_ceilDiv","module":"Mathlib.Algebra.Order.Floor.Div","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝⁵ : OrderedSemiring α\ninst✝⁴ : OrderedAddCommMonoid β\ninst✝³ : MulActionWithZero α β\ninst✝² : CeilDiv α β\na : α\ninst✝¹ : PosSMulMono α β\ninst✝ : PosSMulReflectLE α β\nha : LT.lt 0 a\nb : β\n⊢ Eq (CeilDiv.ceilDiv (HSMul.hSMul a b) a) b","decl":"@[simp] lemma smul_ceilDiv [PosSMulMono α β] [PosSMulReflectLE α β] (ha : 0 < a) (b : β) :\n    a • b ⌈/⌉ a = b :=\n  eq_of_forall_ge_iff <| by simp [smul_le_smul_iff_of_pos_left, ha]\n\n"}
{"name":"gc_floorDiv_mul","module":"Mathlib.Algebra.Order.Floor.Div","initialProofState":"α : Type u_2\ninst✝¹ : OrderedSemiring α\ninst✝ : FloorDiv α α\na : α\nha : LT.lt 0 a\n⊢ GaloisConnection (fun x => HMul.hMul a x) fun x => FloorDiv.floorDiv x a","decl":"lemma gc_floorDiv_mul (ha : 0 < a) : GaloisConnection (a * ·) (· ⌊/⌋ a) := gc_floorDiv_smul ha\n"}
{"name":"le_floorDiv_iff_mul_le","module":"Mathlib.Algebra.Order.Floor.Div","initialProofState":"α : Type u_2\ninst✝¹ : OrderedSemiring α\ninst✝ : FloorDiv α α\na b c : α\nha : LT.lt 0 a\n⊢ Iff (LE.le c (FloorDiv.floorDiv b a)) (LE.le (HSMul.hSMul a c) b)","decl":"lemma le_floorDiv_iff_mul_le (ha : 0 < a) : c ≤ b ⌊/⌋ a ↔ a • c ≤ b := le_floorDiv_iff_smul_le ha\n\n"}
{"name":"gc_mul_ceilDiv","module":"Mathlib.Algebra.Order.Floor.Div","initialProofState":"α : Type u_2\ninst✝¹ : OrderedSemiring α\ninst✝ : CeilDiv α α\na : α\nha : LT.lt 0 a\n⊢ GaloisConnection (fun x => CeilDiv.ceilDiv x a) fun x => HMul.hMul a x","decl":"lemma gc_mul_ceilDiv (ha : 0 < a) : GaloisConnection (· ⌈/⌉ a) (a * ·) := gc_smul_ceilDiv ha\n"}
{"name":"ceilDiv_le_iff_le_mul","module":"Mathlib.Algebra.Order.Floor.Div","initialProofState":"α : Type u_2\ninst✝¹ : OrderedSemiring α\ninst✝ : CeilDiv α α\na b c : α\nha : LT.lt 0 a\n⊢ Iff (LE.le (CeilDiv.ceilDiv b a) c) (LE.le b (HMul.hMul a c))","decl":"lemma ceilDiv_le_iff_le_mul (ha : 0 < a) : b ⌈/⌉ a ≤ c ↔ b ≤ a * c := ceilDiv_le_iff_le_smul ha\n\n"}
{"name":"Nat.floorDiv_eq_div","module":"Mathlib.Algebra.Order.Floor.Div","initialProofState":"a b : Nat\n⊢ Eq (FloorDiv.floorDiv a b) (HDiv.hDiv a b)","decl":"@[simp] lemma floorDiv_eq_div (a b : ℕ) : a ⌊/⌋ b = a / b := rfl\n"}
{"name":"Nat.ceilDiv_eq_add_pred_div","module":"Mathlib.Algebra.Order.Floor.Div","initialProofState":"a b : Nat\n⊢ Eq (CeilDiv.ceilDiv a b) (HDiv.hDiv (HSub.hSub (HAdd.hAdd a b) 1) b)","decl":"lemma ceilDiv_eq_add_pred_div (a b : ℕ) : a ⌈/⌉ b = (a + b - 1) / b := rfl\n\n"}
{"name":"Pi.floorDiv_def","module":"Mathlib.Algebra.Order.Floor.Div","initialProofState":"ι : Type u_1\nα : Type u_2\nπ : ι → Type u_4\ninst✝³ : OrderedAddCommMonoid α\ninst✝² : (i : ι) → OrderedAddCommMonoid (π i)\ninst✝¹ : (i : ι) → SMulZeroClass α (π i)\ninst✝ : (i : ι) → FloorDiv α (π i)\nf : (i : ι) → π i\na : α\n⊢ Eq (FloorDiv.floorDiv f a) fun i => FloorDiv.floorDiv (f i) a","decl":"lemma floorDiv_def (f : ∀ i, π i) (a : α) : f ⌊/⌋ a = fun i ↦ f i ⌊/⌋ a := rfl\n"}
{"name":"Pi.floorDiv_apply","module":"Mathlib.Algebra.Order.Floor.Div","initialProofState":"ι : Type u_1\nα : Type u_2\nπ : ι → Type u_4\ninst✝³ : OrderedAddCommMonoid α\ninst✝² : (i : ι) → OrderedAddCommMonoid (π i)\ninst✝¹ : (i : ι) → SMulZeroClass α (π i)\ninst✝ : (i : ι) → FloorDiv α (π i)\nf : (i : ι) → π i\na : α\ni : ι\n⊢ Eq (FloorDiv.floorDiv f a i) (FloorDiv.floorDiv (f i) a)","decl":"@[simp] lemma floorDiv_apply (f : ∀ i, π i) (a : α) (i : ι) : (f ⌊/⌋ a) i = f i ⌊/⌋ a := rfl\n\n"}
{"name":"Pi.ceilDiv_def","module":"Mathlib.Algebra.Order.Floor.Div","initialProofState":"ι : Type u_1\nα : Type u_2\nπ : ι → Type u_4\ninst✝³ : OrderedAddCommMonoid α\ninst✝² : (i : ι) → OrderedAddCommMonoid (π i)\ninst✝¹ : (i : ι) → SMulZeroClass α (π i)\ninst✝ : (i : ι) → CeilDiv α (π i)\nf : (i : ι) → π i\na : α\n⊢ Eq (CeilDiv.ceilDiv f a) fun i => CeilDiv.ceilDiv (f i) a","decl":"lemma ceilDiv_def (f : ∀ i, π i) (a : α) : f ⌈/⌉ a = fun i ↦ f i ⌈/⌉ a := rfl\n"}
{"name":"Pi.ceilDiv_apply","module":"Mathlib.Algebra.Order.Floor.Div","initialProofState":"ι : Type u_1\nα : Type u_2\nπ : ι → Type u_4\ninst✝³ : OrderedAddCommMonoid α\ninst✝² : (i : ι) → OrderedAddCommMonoid (π i)\ninst✝¹ : (i : ι) → SMulZeroClass α (π i)\ninst✝ : (i : ι) → CeilDiv α (π i)\nf : (i : ι) → π i\na : α\ni : ι\n⊢ Eq (CeilDiv.ceilDiv f a i) (CeilDiv.ceilDiv (f i) a)","decl":"@[simp] lemma ceilDiv_apply (f : ∀ i, π i) (a : α) (i : ι) : (f ⌈/⌉ a) i = f i ⌈/⌉ a := rfl\n\n"}
{"name":"Finsupp.floorDiv_def","module":"Mathlib.Algebra.Order.Floor.Div","initialProofState":"ι : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝³ : OrderedAddCommMonoid α\ninst✝² : OrderedAddCommMonoid β\ninst✝¹ : SMulZeroClass α β\ninst✝ : FloorDiv α β\nf : Finsupp ι β\na : α\n⊢ Eq (FloorDiv.floorDiv f a) (Finsupp.mapRange (fun x => FloorDiv.floorDiv x a) ⋯ f)","decl":"lemma floorDiv_def (f : ι →₀ β) (a : α) : f ⌊/⌋ a = f.mapRange (· ⌊/⌋ a) (zero_floorDiv _) := rfl\n"}
{"name":"Finsupp.coe_floorDiv","module":"Mathlib.Algebra.Order.Floor.Div","initialProofState":"ι : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝³ : OrderedAddCommMonoid α\ninst✝² : OrderedAddCommMonoid β\ninst✝¹ : SMulZeroClass α β\ninst✝ : FloorDiv α β\nf : Finsupp ι β\na : α\n⊢ Eq ⇑(FloorDiv.floorDiv f a) fun i => FloorDiv.floorDiv (f i) a","decl":"@[norm_cast] lemma coe_floorDiv (f : ι →₀ β) (a : α) : f ⌊/⌋ a = fun i ↦ f i ⌊/⌋ a := rfl\n"}
{"name":"Finsupp.floorDiv_apply","module":"Mathlib.Algebra.Order.Floor.Div","initialProofState":"ι : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝³ : OrderedAddCommMonoid α\ninst✝² : OrderedAddCommMonoid β\ninst✝¹ : SMulZeroClass α β\ninst✝ : FloorDiv α β\nf : Finsupp ι β\na : α\ni : ι\n⊢ Eq ((FloorDiv.floorDiv f a) i) (FloorDiv.floorDiv (f i) a)","decl":"@[simp] lemma floorDiv_apply (f : ι →₀ β) (a : α) (i : ι) : (f ⌊/⌋ a) i = f i ⌊/⌋ a := rfl\n\n"}
{"name":"Finsupp.support_floorDiv_subset","module":"Mathlib.Algebra.Order.Floor.Div","initialProofState":"ι : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝³ : OrderedAddCommMonoid α\ninst✝² : OrderedAddCommMonoid β\ninst✝¹ : SMulZeroClass α β\ninst✝ : FloorDiv α β\nf : Finsupp ι β\na : α\n⊢ HasSubset.Subset (FloorDiv.floorDiv f a).support f.support","decl":"lemma support_floorDiv_subset : (f ⌊/⌋ a).support ⊆ f.support := by\n  simp +contextual [Finset.subset_iff, not_imp_not]\n\n"}
{"name":"Finsupp.ceilDiv_def","module":"Mathlib.Algebra.Order.Floor.Div","initialProofState":"ι : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝³ : OrderedAddCommMonoid α\ninst✝² : OrderedAddCommMonoid β\ninst✝¹ : SMulZeroClass α β\ninst✝ : CeilDiv α β\nf : Finsupp ι β\na : α\n⊢ Eq (CeilDiv.ceilDiv f a) (Finsupp.mapRange (fun x => CeilDiv.ceilDiv x a) ⋯ f)","decl":"lemma ceilDiv_def (f : ι →₀ β) (a : α) : f ⌈/⌉ a = f.mapRange (· ⌈/⌉ a) (zero_ceilDiv _) := rfl\n"}
{"name":"Finsupp.coe_ceilDiv_def","module":"Mathlib.Algebra.Order.Floor.Div","initialProofState":"ι : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝³ : OrderedAddCommMonoid α\ninst✝² : OrderedAddCommMonoid β\ninst✝¹ : SMulZeroClass α β\ninst✝ : CeilDiv α β\nf : Finsupp ι β\na : α\n⊢ Eq ⇑(CeilDiv.ceilDiv f a) fun i => CeilDiv.ceilDiv (f i) a","decl":"@[norm_cast] lemma coe_ceilDiv_def (f : ι →₀ β) (a : α) : f ⌈/⌉ a = fun i ↦ f i ⌈/⌉ a := rfl\n"}
{"name":"Finsupp.ceilDiv_apply","module":"Mathlib.Algebra.Order.Floor.Div","initialProofState":"ι : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝³ : OrderedAddCommMonoid α\ninst✝² : OrderedAddCommMonoid β\ninst✝¹ : SMulZeroClass α β\ninst✝ : CeilDiv α β\nf : Finsupp ι β\na : α\ni : ι\n⊢ Eq ((CeilDiv.ceilDiv f a) i) (CeilDiv.ceilDiv (f i) a)","decl":"@[simp] lemma ceilDiv_apply (f : ι →₀ β) (a : α) (i : ι) : (f ⌈/⌉ a) i = f i ⌈/⌉ a := rfl\n\n"}
{"name":"Finsupp.support_ceilDiv_subset","module":"Mathlib.Algebra.Order.Floor.Div","initialProofState":"ι : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝³ : OrderedAddCommMonoid α\ninst✝² : OrderedAddCommMonoid β\ninst✝¹ : SMulZeroClass α β\ninst✝ : CeilDiv α β\nf : Finsupp ι β\na : α\n⊢ HasSubset.Subset (CeilDiv.ceilDiv f a).support f.support","decl":"lemma support_ceilDiv_subset : (f ⌈/⌉ a).support ⊆ f.support := by\n  simp +contextual [Finset.subset_iff, not_imp_not]\n\n"}
