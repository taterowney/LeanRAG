{"name":"Finsupp.ker_lsingle","module":"Mathlib.LinearAlgebra.Finsupp.Span","initialProofState":"α : Type u_1\nM : Type u_2\nR : Type u_5\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\na : α\n⊢ Eq (LinearMap.ker (Finsupp.lsingle a)) Bot.bot","decl":"@[simp]\ntheorem ker_lsingle (a : α) : ker (lsingle a : M →ₗ[R] α →₀ M) = ⊥ :=\n  ker_eq_bot_of_injective (single_injective a)\n\n"}
{"name":"Finsupp.lsingle_range_le_ker_lapply","module":"Mathlib.LinearAlgebra.Finsupp.Span","initialProofState":"α : Type u_1\nM : Type u_2\nR : Type u_5\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\ns t : Set α\nh : Disjoint s t\n⊢ LE.le (iSup fun a => iSup fun h => LinearMap.range (Finsupp.lsingle a)) (iInf fun a => iInf fun h => LinearMap.ker (Finsupp.lapply a))","decl":"theorem lsingle_range_le_ker_lapply (s t : Set α) (h : Disjoint s t) :\n    ⨆ a ∈ s, LinearMap.range (lsingle a : M →ₗ[R] α →₀ M) ≤\n      ⨅ a ∈ t, ker (lapply a : (α →₀ M) →ₗ[R] M) := by\n  refine iSup_le fun a₁ => iSup_le fun h₁ => range_le_iff_comap.2 ?_\n  simp only [(ker_comp _ _).symm, eq_top_iff, SetLike.le_def, mem_ker, comap_iInf, mem_iInf]\n  intro b _ a₂ h₂\n  have : a₁ ≠ a₂ := fun eq => h.le_bot ⟨h₁, eq.symm ▸ h₂⟩\n  exact single_eq_of_ne this\n\n"}
{"name":"Finsupp.iInf_ker_lapply_le_bot","module":"Mathlib.LinearAlgebra.Finsupp.Span","initialProofState":"α : Type u_1\nM : Type u_2\nR : Type u_5\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\n⊢ LE.le (iInf fun a => LinearMap.ker (Finsupp.lapply a)) Bot.bot","decl":"theorem iInf_ker_lapply_le_bot : ⨅ a, ker (lapply a : (α →₀ M) →ₗ[R] M) ≤ ⊥ := by\n  simp only [SetLike.le_def, mem_iInf, mem_ker, mem_bot, lapply_apply]\n  exact fun a h => Finsupp.ext h\n\n"}
{"name":"Finsupp.iSup_lsingle_range","module":"Mathlib.LinearAlgebra.Finsupp.Span","initialProofState":"α : Type u_1\nM : Type u_2\nR : Type u_5\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\n⊢ Eq (iSup fun a => LinearMap.range (Finsupp.lsingle a)) Top.top","decl":"theorem iSup_lsingle_range : ⨆ a, LinearMap.range (lsingle a : M →ₗ[R] α →₀ M) = ⊤ := by\n  refine eq_top_iff.2 <| SetLike.le_def.2 fun f _ => ?_\n  rw [← sum_single f]\n  exact sum_mem fun a _ => Submodule.mem_iSup_of_mem a ⟨_, rfl⟩\n\n"}
{"name":"Finsupp.disjoint_lsingle_lsingle","module":"Mathlib.LinearAlgebra.Finsupp.Span","initialProofState":"α : Type u_1\nM : Type u_2\nR : Type u_5\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\ns t : Set α\nhs : Disjoint s t\n⊢ Disjoint (iSup fun a => iSup fun h => LinearMap.range (Finsupp.lsingle a)) (iSup fun a => iSup fun h => LinearMap.range (Finsupp.lsingle a))","decl":"theorem disjoint_lsingle_lsingle (s t : Set α) (hs : Disjoint s t) :\n    Disjoint (⨆ a ∈ s, LinearMap.range (lsingle a : M →ₗ[R] α →₀ M))\n      (⨆ a ∈ t, LinearMap.range (lsingle a : M →ₗ[R] α →₀ M)) := by\n  -- Porting note: 2 placeholders are added to prevent timeout.\n  refine\n    (Disjoint.mono\n      (lsingle_range_le_ker_lapply s sᶜ ?_)\n      (lsingle_range_le_ker_lapply t tᶜ ?_))\n      ?_\n  · apply disjoint_compl_right\n  · apply disjoint_compl_right\n  rw [disjoint_iff_inf_le]\n  refine le_trans (le_iInf fun i => ?_) iInf_ker_lapply_le_bot\n  classical\n    by_cases his : i ∈ s\n    · by_cases hit : i ∈ t\n      · exact (hs.le_bot ⟨his, hit⟩).elim\n      exact inf_le_of_right_le (iInf_le_of_le i <| iInf_le _ hit)\n    exact inf_le_of_left_le (iInf_le_of_le i <| iInf_le _ his)\n\n"}
{"name":"Finsupp.span_single_image","module":"Mathlib.LinearAlgebra.Finsupp.Span","initialProofState":"α : Type u_1\nM : Type u_2\nR : Type u_5\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\ns : Set M\na : α\n⊢ Eq (Submodule.span R (Set.image (Finsupp.single a) s)) (Submodule.map (Finsupp.lsingle a) (Submodule.span R s))","decl":"theorem span_single_image (s : Set M) (a : α) :\n    Submodule.span R (single a '' s) = (Submodule.span R s).map (lsingle a : M →ₗ[R] α →₀ M) := by\n  rw [← span_image]; rfl\n\n"}
{"name":"Submodule.exists_finset_of_mem_iSup","module":"Mathlib.LinearAlgebra.Finsupp.Span","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nι : Type u_4\np : ι → Submodule R M\nm : M\nhm : Membership.mem (iSup fun i => p i) m\n⊢ Exists fun s => Membership.mem (iSup fun i => iSup fun h => p i) m","decl":"theorem Submodule.exists_finset_of_mem_iSup {ι : Sort _} (p : ι → Submodule R M) {m : M}\n    (hm : m ∈ ⨆ i, p i) : ∃ s : Finset ι, m ∈ ⨆ i ∈ s, p i := by\n  have :=\n    CompleteLattice.IsCompactElement.exists_finset_of_le_iSup (Submodule R M)\n      (Submodule.singleton_span_isCompactElement m) p\n  simp only [Submodule.span_singleton_le_iff_mem] at this\n  exact this hm\n\n"}
{"name":"Submodule.mem_iSup_iff_exists_finset","module":"Mathlib.LinearAlgebra.Finsupp.Span","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nι : Type u_4\np : ι → Submodule R M\nm : M\n⊢ Iff (Membership.mem (iSup fun i => p i) m) (Exists fun s => Membership.mem (iSup fun i => iSup fun h => p i) m)","decl":"/-- `Submodule.exists_finset_of_mem_iSup` as an `iff` -/\ntheorem Submodule.mem_iSup_iff_exists_finset {ι : Sort _} {p : ι → Submodule R M} {m : M} :\n    (m ∈ ⨆ i, p i) ↔ ∃ s : Finset ι, m ∈ ⨆ i ∈ s, p i :=\n  ⟨Submodule.exists_finset_of_mem_iSup p, fun ⟨_, hs⟩ =>\n    iSup_mono (fun i => (iSup_const_le : _ ≤ p i)) hs⟩\n\n"}
{"name":"Submodule.mem_sSup_iff_exists_finset","module":"Mathlib.LinearAlgebra.Finsupp.Span","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nS : Set (Submodule R M)\nm : M\n⊢ Iff (Membership.mem (SupSet.sSup S) m) (Exists fun s => And (HasSubset.Subset (↑s) S) (Membership.mem (iSup fun i => iSup fun h => i) m))","decl":"theorem Submodule.mem_sSup_iff_exists_finset {S : Set (Submodule R M)} {m : M} :\n    m ∈ sSup S ↔ ∃ s : Finset (Submodule R M), ↑s ⊆ S ∧ m ∈ ⨆ i ∈ s, i := by\n  rw [sSup_eq_iSup, iSup_subtype', Submodule.mem_iSup_iff_exists_finset]\n  refine ⟨fun ⟨s, hs⟩ ↦ ⟨s.map (Function.Embedding.subtype S), ?_, ?_⟩,\n          fun ⟨s, hsS, hs⟩ ↦ ⟨s.preimage (↑) Subtype.coe_injective.injOn, ?_⟩⟩\n  · simpa using fun x _ ↦ x.property\n  · suffices m ∈ ⨆ (i) (hi : i ∈ S) (_ : ⟨i, hi⟩ ∈ s), i by simpa\n    rwa [iSup_subtype']\n  · have : ⨆ (i) (_ : i ∈ S ∧ i ∈ s), i = ⨆ (i) (_ : i ∈ s), i := by convert rfl; aesop\n    simpa only [Finset.mem_preimage, iSup_subtype, iSup_and', this]\n"}
