{"name":"SimpleGraph.ComponentCompl.supp_injective_iff","module":"Mathlib.Combinatorics.SimpleGraph.Ends.Defs","initialProofState":"V : Type u\nG : SimpleGraph V\nK : Set V\na₁ a₂ : G.ComponentCompl K\n⊢ Iff (Eq a₁ a₂) (Eq a₁.supp a₂.supp)","decl":"@[ext]\ntheorem ComponentCompl.supp_injective :\n    Function.Injective (ComponentCompl.supp : G.ComponentCompl K → Set V) := by\n  refine ConnectedComponent.ind₂ ?_\n  rintro ⟨v, hv⟩ ⟨w, hw⟩ h\n  simp only [Set.ext_iff, ConnectedComponent.eq, Set.mem_setOf_eq, ComponentCompl.supp] at h ⊢\n  exact ((h v).mp ⟨hv, Reachable.refl _⟩).choose_spec\n\n"}
{"name":"SimpleGraph.ComponentCompl.supp_injective","module":"Mathlib.Combinatorics.SimpleGraph.Ends.Defs","initialProofState":"V : Type u\nG : SimpleGraph V\nK : Set V\n⊢ Function.Injective SimpleGraph.ComponentCompl.supp","decl":"@[ext]\ntheorem ComponentCompl.supp_injective :\n    Function.Injective (ComponentCompl.supp : G.ComponentCompl K → Set V) := by\n  refine ConnectedComponent.ind₂ ?_\n  rintro ⟨v, hv⟩ ⟨w, hw⟩ h\n  simp only [Set.ext_iff, ConnectedComponent.eq, Set.mem_setOf_eq, ComponentCompl.supp] at h ⊢\n  exact ((h v).mp ⟨hv, Reachable.refl _⟩).choose_spec\n\n"}
{"name":"SimpleGraph.ComponentCompl.supp_inj","module":"Mathlib.Combinatorics.SimpleGraph.Ends.Defs","initialProofState":"V : Type u\nG : SimpleGraph V\nK : Set V\nC D : G.ComponentCompl K\n⊢ Iff (Eq C.supp D.supp) (Eq C D)","decl":"theorem ComponentCompl.supp_inj {C D : G.ComponentCompl K} : C.supp = D.supp ↔ C = D :=\n  ComponentCompl.supp_injective.eq_iff\n\n"}
{"name":"SimpleGraph.ComponentCompl.mem_supp_iff","module":"Mathlib.Combinatorics.SimpleGraph.Ends.Defs","initialProofState":"V : Type u\nG : SimpleGraph V\nK : Set V\nv : V\nC : G.ComponentCompl K\n⊢ Iff (Membership.mem C v) (Exists fun vK => Eq (G.componentComplMk vK) C)","decl":"@[simp]\ntheorem ComponentCompl.mem_supp_iff {v : V} {C : ComponentCompl G K} :\n    v ∈ C ↔ ∃ vK : v ∉ K, G.componentComplMk vK = C :=\n  Iff.rfl\n\n"}
{"name":"SimpleGraph.componentComplMk_mem","module":"Mathlib.Combinatorics.SimpleGraph.Ends.Defs","initialProofState":"V : Type u\nK : Set V\nG : SimpleGraph V\nv : V\nvK : Not (Membership.mem K v)\n⊢ Membership.mem (G.componentComplMk vK) v","decl":"theorem componentComplMk_mem (G : SimpleGraph V) {v : V} (vK : v ∉ K) : v ∈ G.componentComplMk vK :=\n  ⟨vK, rfl⟩\n\n"}
{"name":"SimpleGraph.componentComplMk_eq_of_adj","module":"Mathlib.Combinatorics.SimpleGraph.Ends.Defs","initialProofState":"V : Type u\nK : Set V\nG : SimpleGraph V\nv w : V\nvK : Not (Membership.mem K v)\nwK : Not (Membership.mem K w)\na : G.Adj v w\n⊢ Eq (G.componentComplMk vK) (G.componentComplMk wK)","decl":"theorem componentComplMk_eq_of_adj (G : SimpleGraph V) {v w : V} (vK : v ∉ K) (wK : w ∉ K)\n    (a : G.Adj v w) : G.componentComplMk vK = G.componentComplMk wK := by\n  rw [ConnectedComponent.eq]\n  apply Adj.reachable\n  exact a\n\n"}
{"name":"SimpleGraph.componentCompl_nonempty_of_infinite","module":"Mathlib.Combinatorics.SimpleGraph.Ends.Defs","initialProofState":"V : Type u\nG : SimpleGraph V\ninst✝ : Infinite V\nK : Finset V\n⊢ Nonempty (G.ComponentCompl ↑K)","decl":"/-- In an infinite graph, the set of components out of a finite set is nonempty. -/\ninstance componentCompl_nonempty_of_infinite (G : SimpleGraph V) [Infinite V] (K : Finset V) :\n    Nonempty (G.ComponentCompl K) :=\n  let ⟨_, kK⟩ := K.finite_toSet.infinite_compl.nonempty\n  ⟨componentComplMk _ kK⟩\n\n"}
{"name":"SimpleGraph.ComponentCompl.ind","module":"Mathlib.Combinatorics.SimpleGraph.Ends.Defs","initialProofState":"V : Type u\nG : SimpleGraph V\nK : Set V\nβ : G.ComponentCompl K → Prop\nf : ∀ ⦃v : V⦄ (hv : Not (Membership.mem K v)), β (G.componentComplMk hv)\nC : G.ComponentCompl K\n⊢ β C","decl":"@[elab_as_elim]\nprotected theorem ind {β : G.ComponentCompl K → Prop}\n    (f : ∀ ⦃v⦄ (hv : v ∉ K), β (G.componentComplMk hv)) : ∀ C : G.ComponentCompl K, β C := by\n  apply ConnectedComponent.ind\n  exact fun ⟨v, vnK⟩ => f vnK\n\n"}
{"name":"SimpleGraph.ComponentCompl.coe_inj","module":"Mathlib.Combinatorics.SimpleGraph.Ends.Defs","initialProofState":"V : Type u\nG : SimpleGraph V\nK : Set V\nC D : G.ComponentCompl K\n⊢ Iff (Eq ↑C ↑D) (Eq C D)","decl":"theorem coe_inj {C D : G.ComponentCompl K} : (C : Set V) = (D : Set V) ↔ C = D :=\n  SetLike.coe_set_eq\n\n"}
{"name":"SimpleGraph.ComponentCompl.nonempty","module":"Mathlib.Combinatorics.SimpleGraph.Ends.Defs","initialProofState":"V : Type u\nG : SimpleGraph V\nK : Set V\nC : G.ComponentCompl K\n⊢ (↑C).Nonempty","decl":"@[simp]\nprotected theorem nonempty (C : G.ComponentCompl K) : (C : Set V).Nonempty :=\n  C.ind fun v vnK => ⟨v, vnK, rfl⟩\n\n"}
{"name":"SimpleGraph.ComponentCompl.exists_eq_mk","module":"Mathlib.Combinatorics.SimpleGraph.Ends.Defs","initialProofState":"V : Type u\nG : SimpleGraph V\nK : Set V\nC : G.ComponentCompl K\n⊢ Exists fun v => Exists fun h => Eq (G.componentComplMk h) C","decl":"protected theorem exists_eq_mk (C : G.ComponentCompl K) :\n    ∃ (v : _) (h : v ∉ K), G.componentComplMk h = C :=\n  C.nonempty\n\n"}
{"name":"SimpleGraph.ComponentCompl.disjoint_right","module":"Mathlib.Combinatorics.SimpleGraph.Ends.Defs","initialProofState":"V : Type u\nG : SimpleGraph V\nK : Set V\nC : G.ComponentCompl K\n⊢ Disjoint K ↑C","decl":"protected theorem disjoint_right (C : G.ComponentCompl K) : Disjoint K C := by\n  rw [Set.disjoint_iff]\n  exact fun v ⟨vK, vC⟩ => vC.choose vK\n\n"}
{"name":"SimpleGraph.ComponentCompl.not_mem_of_mem","module":"Mathlib.Combinatorics.SimpleGraph.Ends.Defs","initialProofState":"V : Type u\nG : SimpleGraph V\nK : Set V\nC : G.ComponentCompl K\nc : V\ncC : Membership.mem C c\n⊢ Not (Membership.mem K c)","decl":"theorem not_mem_of_mem {C : G.ComponentCompl K} {c : V} (cC : c ∈ C) : c ∉ K := fun cK =>\n  Set.disjoint_iff.mp C.disjoint_right ⟨cK, cC⟩\n\n"}
{"name":"SimpleGraph.ComponentCompl.pairwise_disjoint","module":"Mathlib.Combinatorics.SimpleGraph.Ends.Defs","initialProofState":"V : Type u\nG : SimpleGraph V\nK : Set V\n⊢ Pairwise fun C D => Disjoint ↑C ↑D","decl":"protected theorem pairwise_disjoint :\n    Pairwise fun C D : G.ComponentCompl K => Disjoint (C : Set V) (D : Set V) := by\n  rintro C D ne\n  rw [Set.disjoint_iff]\n  exact fun u ⟨uC, uD⟩ => ne (uC.choose_spec.symm.trans uD.choose_spec)\n\n"}
{"name":"SimpleGraph.ComponentCompl.mem_of_adj","module":"Mathlib.Combinatorics.SimpleGraph.Ends.Defs","initialProofState":"V : Type u\nG : SimpleGraph V\nK : Set V\nC : G.ComponentCompl K\nc d : V\na✝² : Membership.mem C c\na✝¹ : Not (Membership.mem K d)\na✝ : G.Adj c d\n⊢ Membership.mem C d","decl":"/-- Any vertex adjacent to a vertex of `C` and not lying in `K` must lie in `C`.\n-/\ntheorem mem_of_adj : ∀ {C : G.ComponentCompl K} (c d : V), c ∈ C → d ∉ K → G.Adj c d → d ∈ C :=\n  fun {C} c d ⟨cnK, h⟩ dnK cd =>\n  ⟨dnK, by\n    rw [← h, ConnectedComponent.eq]\n    exact Adj.reachable cd.symm⟩\n\n"}
{"name":"SimpleGraph.ComponentCompl.exists_adj_boundary_pair","module":"Mathlib.Combinatorics.SimpleGraph.Ends.Defs","initialProofState":"V : Type u\nG : SimpleGraph V\nK : Set V\nGc : G.Preconnected\nhK : K.Nonempty\nC : G.ComponentCompl K\n⊢ Exists fun ck => And (Membership.mem C ck.1) (And (Membership.mem K ck.2) (G.Adj ck.1 ck.2))","decl":"/--\nAssuming `G` is preconnected and `K` not empty, given any connected component `C` outside of `K`,\nthere exists a vertex `k ∈ K` adjacent to a vertex `v ∈ C`.\n-/\ntheorem exists_adj_boundary_pair (Gc : G.Preconnected) (hK : K.Nonempty) :\n    ∀ C : G.ComponentCompl K, ∃ ck : V × V, ck.1 ∈ C ∧ ck.2 ∈ K ∧ G.Adj ck.1 ck.2 := by\n  refine ComponentCompl.ind fun v vnK => ?_\n  let C : G.ComponentCompl K := G.componentComplMk vnK\n  let dis := Set.disjoint_iff.mp C.disjoint_right\n  by_contra! h\n  suffices Set.univ = (C : Set V) by exact dis ⟨hK.choose_spec, this ▸ Set.mem_univ hK.some⟩\n  symm\n  rw [Set.eq_univ_iff_forall]\n  rintro u\n  by_contra unC\n  obtain ⟨p⟩ := Gc v u\n  obtain ⟨⟨⟨x, y⟩, xy⟩, -, xC, ynC⟩ :=\n    p.exists_boundary_dart (C : Set V) (G.componentComplMk_mem vnK) unC\n  exact ynC (mem_of_adj x y xC (fun yK : y ∈ K => h ⟨x, y⟩ xC yK xy) xy)\n\n"}
{"name":"SimpleGraph.ComponentCompl.subset_hom","module":"Mathlib.Combinatorics.SimpleGraph.Ends.Defs","initialProofState":"V : Type u\nG : SimpleGraph V\nK L : Set V\nC : G.ComponentCompl L\nh : HasSubset.Subset K L\n⊢ HasSubset.Subset ↑C ↑(SimpleGraph.ComponentCompl.hom h C)","decl":"theorem subset_hom (C : G.ComponentCompl L) (h : K ⊆ L) : (C : Set V) ⊆ (C.hom h : Set V) := by\n  rintro c ⟨cL, rfl⟩\n  exact ⟨fun h' => cL (h h'), rfl⟩\n\n"}
{"name":"SimpleGraph.componentComplMk_mem_hom","module":"Mathlib.Combinatorics.SimpleGraph.Ends.Defs","initialProofState":"V : Type u\nK L : Set V\nG : SimpleGraph V\nv : V\nvK : Not (Membership.mem K v)\nh : HasSubset.Subset L K\n⊢ Membership.mem (SimpleGraph.ComponentCompl.hom h (G.componentComplMk vK)) v","decl":"theorem _root_.SimpleGraph.componentComplMk_mem_hom\n    (G : SimpleGraph V) {v : V} (vK : v ∉ K) (h : L ⊆ K) :\n    v ∈ (G.componentComplMk vK).hom h :=\n  subset_hom (G.componentComplMk vK) h (G.componentComplMk_mem vK)\n\n"}
{"name":"SimpleGraph.ComponentCompl.hom_eq_iff_le","module":"Mathlib.Combinatorics.SimpleGraph.Ends.Defs","initialProofState":"V : Type u\nG : SimpleGraph V\nK L : Set V\nC : G.ComponentCompl L\nh : HasSubset.Subset K L\nD : G.ComponentCompl K\n⊢ Iff (Eq (SimpleGraph.ComponentCompl.hom h C) D) (HasSubset.Subset ↑C ↑D)","decl":"theorem hom_eq_iff_le (C : G.ComponentCompl L) (h : K ⊆ L) (D : G.ComponentCompl K) :\n    C.hom h = D ↔ (C : Set V) ⊆ (D : Set V) :=\n  ⟨fun h' => h' ▸ C.subset_hom h, C.ind fun _ vnL vD => (vD ⟨vnL, rfl⟩).choose_spec⟩\n\n"}
{"name":"SimpleGraph.ComponentCompl.hom_eq_iff_not_disjoint","module":"Mathlib.Combinatorics.SimpleGraph.Ends.Defs","initialProofState":"V : Type u\nG : SimpleGraph V\nK L : Set V\nC : G.ComponentCompl L\nh : HasSubset.Subset K L\nD : G.ComponentCompl K\n⊢ Iff (Eq (SimpleGraph.ComponentCompl.hom h C) D) (Not (Disjoint ↑C ↑D))","decl":"theorem hom_eq_iff_not_disjoint (C : G.ComponentCompl L) (h : K ⊆ L) (D : G.ComponentCompl K) :\n    C.hom h = D ↔ ¬Disjoint (C : Set V) (D : Set V) := by\n  rw [Set.not_disjoint_iff]\n  constructor\n  · rintro rfl\n    refine C.ind fun x xnL => ?_\n    exact ⟨x, ⟨xnL, rfl⟩, ⟨fun xK => xnL (h xK), rfl⟩⟩\n  · refine C.ind fun x xnL => ?_\n    rintro ⟨x, ⟨_, e₁⟩, _, rfl⟩\n    rw [← e₁]\n    rfl\n\n"}
{"name":"SimpleGraph.ComponentCompl.hom_refl","module":"Mathlib.Combinatorics.SimpleGraph.Ends.Defs","initialProofState":"V : Type u\nG : SimpleGraph V\nL : Set V\nC : G.ComponentCompl L\n⊢ Eq (SimpleGraph.ComponentCompl.hom ⋯ C) C","decl":"theorem hom_refl (C : G.ComponentCompl L) : C.hom (subset_refl L) = C := by\n  change C.map _ = C\n  rw [induceHom_id G Lᶜ, ConnectedComponent.map_id]\n\n"}
{"name":"SimpleGraph.ComponentCompl.hom_trans","module":"Mathlib.Combinatorics.SimpleGraph.Ends.Defs","initialProofState":"V : Type u\nG : SimpleGraph V\nK L M : Set V\nC : G.ComponentCompl L\nh : HasSubset.Subset K L\nh' : HasSubset.Subset M K\n⊢ Eq (SimpleGraph.ComponentCompl.hom ⋯ C) (SimpleGraph.ComponentCompl.hom h' (SimpleGraph.ComponentCompl.hom h C))","decl":"theorem hom_trans (C : G.ComponentCompl L) (h : K ⊆ L) (h' : M ⊆ K) :\n    C.hom (h'.trans h) = (C.hom h).hom h' := by\n  change C.map _ = (C.map _).map _\n  rw [ConnectedComponent.map_comp, induceHom_comp]\n  rfl\n\n"}
{"name":"SimpleGraph.ComponentCompl.hom_mk","module":"Mathlib.Combinatorics.SimpleGraph.Ends.Defs","initialProofState":"V : Type u\nG : SimpleGraph V\nK L : Set V\nv : V\nvnL : Not (Membership.mem L v)\nh : HasSubset.Subset K L\n⊢ Eq (SimpleGraph.ComponentCompl.hom h (G.componentComplMk vnL)) (G.componentComplMk ⋯)","decl":"theorem hom_mk {v : V} (vnL : v ∉ L) (h : K ⊆ L) :\n    (G.componentComplMk vnL).hom h = G.componentComplMk (Set.not_mem_subset h vnL) :=\n  rfl\n\n"}
{"name":"SimpleGraph.ComponentCompl.hom_infinite","module":"Mathlib.Combinatorics.SimpleGraph.Ends.Defs","initialProofState":"V : Type u\nG : SimpleGraph V\nK L : Set V\nC : G.ComponentCompl L\nh : HasSubset.Subset K L\nCinf : (↑C).Infinite\n⊢ (↑(SimpleGraph.ComponentCompl.hom h C)).Infinite","decl":"theorem hom_infinite (C : G.ComponentCompl L) (h : K ⊆ L) (Cinf : (C : Set V).Infinite) :\n    (C.hom h : Set V).Infinite :=\n  Set.Infinite.mono (C.subset_hom h) Cinf\n\n"}
{"name":"SimpleGraph.ComponentCompl.infinite_iff_in_all_ranges","module":"Mathlib.Combinatorics.SimpleGraph.Ends.Defs","initialProofState":"V : Type u\nG : SimpleGraph V\nK : Finset V\nC : G.ComponentCompl ↑K\n⊢ Iff C.supp.Infinite (∀ (L : Finset V) (h : HasSubset.Subset K L), Exists fun D => Eq (SimpleGraph.ComponentCompl.hom h D) C)","decl":"theorem infinite_iff_in_all_ranges {K : Finset V} (C : G.ComponentCompl K) :\n    C.supp.Infinite ↔ ∀ (L) (h : K ⊆ L), ∃ D : G.ComponentCompl L, D.hom h = C := by\n  classical\n    constructor\n    · rintro Cinf L h\n      obtain ⟨v, ⟨vK, rfl⟩, vL⟩ := Set.Infinite.nonempty (Set.Infinite.diff Cinf L.finite_toSet)\n      exact ⟨componentComplMk _ vL, rfl⟩\n    · rintro h Cfin\n      obtain ⟨D, e⟩ := h (K ∪ Cfin.toFinset) Finset.subset_union_left\n      obtain ⟨v, vD⟩ := D.nonempty\n      let Ddis := D.disjoint_right\n      simp_rw [Finset.coe_union, Set.Finite.coe_toFinset, Set.disjoint_union_left,\n        Set.disjoint_iff] at Ddis\n      exact Ddis.right ⟨(ComponentCompl.hom_eq_iff_le _ _ _).mp e vD, vD⟩\n\n"}
{"name":"SimpleGraph.componentCompl_finite","module":"Mathlib.Combinatorics.SimpleGraph.Ends.Defs","initialProofState":"V : Type u\nG : SimpleGraph V\ninst✝ : G.LocallyFinite\nGpc : Fact G.Preconnected\nK : Finset V\n⊢ Finite (G.ComponentCompl ↑K)","decl":"/-- For a locally finite preconnected graph, the number of components outside of any finite set\nis finite. -/\ninstance componentCompl_finite [LocallyFinite G] [Gpc : Fact G.Preconnected] (K : Finset V) :\n    Finite (G.ComponentCompl K) := by\n  classical\n  rcases K.eq_empty_or_nonempty with rfl | h\n  -- If K is empty, then removing K doesn't change the graph, which is connected, hence has a\n  -- single connected component\n  · dsimp [ComponentCompl]\n    rw [Finset.coe_empty, Set.compl_empty]\n    have := Gpc.out.subsingleton_connectedComponent\n    exact Finite.of_equiv _ (induceUnivIso G).connectedComponentEquiv.symm\n  -- Otherwise, we consider the function `touch` mapping a connected component to one of its\n  -- vertices adjacent to `K`.\n  · let touch (C : G.ComponentCompl K) : {v : V | ∃ k : V, k ∈ K ∧ G.Adj k v} :=\n      let p := C.exists_adj_boundary_pair Gpc.out h\n      ⟨p.choose.1, p.choose.2, p.choose_spec.2.1, p.choose_spec.2.2.symm⟩\n    -- `touch` is injective\n    have touch_inj : touch.Injective := fun C D h' => ComponentCompl.pairwise_disjoint.eq\n      (Set.not_disjoint_iff.mpr ⟨touch C, (C.exists_adj_boundary_pair Gpc.out h).choose_spec.1,\n                                 h'.symm ▸ (D.exists_adj_boundary_pair Gpc.out h).choose_spec.1⟩)\n    -- `touch` has finite range\n    have : Finite (Set.range touch) := by\n      refine @Subtype.finite _ (Set.Finite.to_subtype ?_) _\n      apply Set.Finite.ofFinset (K.biUnion (fun v => G.neighborFinset v))\n      simp only [Finset.mem_biUnion, mem_neighborFinset, Set.mem_setOf_eq, implies_true]\n    -- hence `touch` has a finite domain\n    apply Finite.of_injective_finite_range touch_inj\n\n"}
{"name":"SimpleGraph.componentComplFunctor_map","module":"Mathlib.Combinatorics.SimpleGraph.Ends.Defs","initialProofState":"V : Type u\nG : SimpleGraph V\nX✝ Y✝ : Opposite (Finset V)\nf : Quiver.Hom X✝ Y✝\nC : G.ComponentCompl ↑(Opposite.unop X✝)\n⊢ Eq (G.componentComplFunctor.map f C) (SimpleGraph.ComponentCompl.hom ⋯ C)","decl":"/--\nThe functor assigning, to a finite set in `V`, the set of connected components in its complement.\n-/\n@[simps]\ndef componentComplFunctor : (Finset V)ᵒᵖ ⥤ Type u where\n  obj K := G.ComponentCompl K.unop\n  map f := ComponentCompl.hom (le_of_op_hom f)\n  map_id _ := funext fun C => C.hom_refl\n  map_comp {_ Y Z} h h' := funext fun C => by\n    convert C.hom_trans (le_of_op_hom h) (le_of_op_hom _)\n    exact h'\n\n"}
{"name":"SimpleGraph.componentComplFunctor_obj","module":"Mathlib.Combinatorics.SimpleGraph.Ends.Defs","initialProofState":"V : Type u\nG : SimpleGraph V\nK : Opposite (Finset V)\n⊢ Eq (G.componentComplFunctor.obj K) (G.ComponentCompl ↑(Opposite.unop K))","decl":"/--\nThe functor assigning, to a finite set in `V`, the set of connected components in its complement.\n-/\n@[simps]\ndef componentComplFunctor : (Finset V)ᵒᵖ ⥤ Type u where\n  obj K := G.ComponentCompl K.unop\n  map f := ComponentCompl.hom (le_of_op_hom f)\n  map_id _ := funext fun C => C.hom_refl\n  map_comp {_ Y Z} h h' := funext fun C => by\n    convert C.hom_trans (le_of_op_hom h) (le_of_op_hom _)\n    exact h'\n\n"}
{"name":"SimpleGraph.end_hom_mk_of_mk","module":"Mathlib.Combinatorics.SimpleGraph.Ends.Defs","initialProofState":"V : Type u\nG : SimpleGraph V\ns : (j : Opposite (Finset V)) → G.componentComplFunctor.obj j\nsec : Membership.mem G.end s\nK L : Opposite (Finset V)\nh : Quiver.Hom L K\nv : V\nvnL : Not (Membership.mem (Opposite.unop L) v)\nhs : Eq (s L) (G.componentComplMk vnL)\n⊢ Eq (s K) (G.componentComplMk ⋯)","decl":"theorem end_hom_mk_of_mk {s} (sec : s ∈ G.end) {K L : (Finset V)ᵒᵖ} (h : L ⟶ K) {v : V}\n    (vnL : v ∉ L.unop) (hs : s L = G.componentComplMk vnL) :\n    s K = G.componentComplMk (Set.not_mem_subset (le_of_op_hom h : _ ⊆ _) vnL) := by\n  rw [← sec h, hs]\n  apply ComponentCompl.hom_mk _ (le_of_op_hom h : _ ⊆ _)\n\n"}
{"name":"SimpleGraph.infinite_iff_in_eventualRange","module":"Mathlib.Combinatorics.SimpleGraph.Ends.Defs","initialProofState":"V : Type u\nG : SimpleGraph V\nK : Opposite (Finset V)\nC : G.componentComplFunctor.obj K\n⊢ Iff (SimpleGraph.ComponentCompl.supp C).Infinite (Membership.mem (G.componentComplFunctor.eventualRange K) C)","decl":"theorem infinite_iff_in_eventualRange {K : (Finset V)ᵒᵖ} (C : G.componentComplFunctor.obj K) :\n    C.supp.Infinite ↔ C ∈ G.componentComplFunctor.eventualRange K := by\n  simp only [C.infinite_iff_in_all_ranges, CategoryTheory.Functor.eventualRange, Set.mem_iInter,\n    Set.mem_range, componentComplFunctor_map]\n  exact\n    ⟨fun h Lop KL => h Lop.unop (le_of_op_hom KL), fun h L KL =>\n      h (Opposite.op L) (opHomOfLE KL)⟩\n\n"}
