{"name":"hyperoperation_zero","module":"Mathlib.Data.Nat.Hyperoperation","initialProofState":"m : Nat\n⊢ Eq (hyperoperation 0 m) Nat.succ","decl":"@[simp]\ntheorem hyperoperation_zero (m : ℕ) : hyperoperation 0 m = Nat.succ :=\n  funext fun k => by rw [hyperoperation, Nat.succ_eq_add_one]\n\n"}
{"name":"hyperoperation_ge_three_eq_one","module":"Mathlib.Data.Nat.Hyperoperation","initialProofState":"n m : Nat\n⊢ Eq (hyperoperation (HAdd.hAdd n 3) m 0) 1","decl":"theorem hyperoperation_ge_three_eq_one (n m : ℕ) : hyperoperation (n + 3) m 0 = 1 := by\n  rw [hyperoperation]\n\n"}
{"name":"hyperoperation_recursion","module":"Mathlib.Data.Nat.Hyperoperation","initialProofState":"n m k : Nat\n⊢ Eq (hyperoperation (HAdd.hAdd n 1) m (HAdd.hAdd k 1)) (hyperoperation n m (hyperoperation (HAdd.hAdd n 1) m k))","decl":"theorem hyperoperation_recursion (n m k : ℕ) :\n    hyperoperation (n + 1) m (k + 1) = hyperoperation n m (hyperoperation (n + 1) m k) := by\n  rw [hyperoperation]\n\n-- Interesting hyperoperation lemmas\n"}
{"name":"hyperoperation_one","module":"Mathlib.Data.Nat.Hyperoperation","initialProofState":"⊢ Eq (hyperoperation 1) fun x1 x2 => HAdd.hAdd x1 x2","decl":"@[simp]\ntheorem hyperoperation_one : hyperoperation 1 = (· + ·) := by\n  ext m k\n  induction' k with bn bih\n  · rw [Nat.add_zero m, hyperoperation]\n  · rw [hyperoperation_recursion, bih, hyperoperation_zero]\n    exact Nat.add_assoc m bn 1\n\n"}
{"name":"hyperoperation_two","module":"Mathlib.Data.Nat.Hyperoperation","initialProofState":"⊢ Eq (hyperoperation 2) fun x1 x2 => HMul.hMul x1 x2","decl":"@[simp]\ntheorem hyperoperation_two : hyperoperation 2 = (· * ·) := by\n  ext m k\n  induction' k with bn bih\n  · rw [hyperoperation]\n    exact (Nat.mul_zero m).symm\n  · rw [hyperoperation_recursion, hyperoperation_one, bih]\n    -- Porting note: was `ring`\n    dsimp only\n    nth_rewrite 1 [← mul_one m]\n    rw [← mul_add, add_comm]\n\n"}
{"name":"hyperoperation_three","module":"Mathlib.Data.Nat.Hyperoperation","initialProofState":"⊢ Eq (hyperoperation 3) fun x1 x2 => HPow.hPow x1 x2","decl":"@[simp]\ntheorem hyperoperation_three : hyperoperation 3 = (· ^ ·) := by\n  ext m k\n  induction' k with bn bih\n  · rw [hyperoperation_ge_three_eq_one]\n    exact (pow_zero m).symm\n  · rw [hyperoperation_recursion, hyperoperation_two, bih]\n    exact (pow_succ' m bn).symm\n\n"}
{"name":"hyperoperation_ge_two_eq_self","module":"Mathlib.Data.Nat.Hyperoperation","initialProofState":"n m : Nat\n⊢ Eq (hyperoperation (HAdd.hAdd n 2) m 1) m","decl":"theorem hyperoperation_ge_two_eq_self (n m : ℕ) : hyperoperation (n + 2) m 1 = m := by\n  induction' n with nn nih\n  · rw [hyperoperation_two]\n    ring\n  · rw [hyperoperation_recursion, hyperoperation_ge_three_eq_one, nih]\n\n"}
{"name":"hyperoperation_two_two_eq_four","module":"Mathlib.Data.Nat.Hyperoperation","initialProofState":"n : Nat\n⊢ Eq (hyperoperation (HAdd.hAdd n 1) 2 2) 4","decl":"theorem hyperoperation_two_two_eq_four (n : ℕ) : hyperoperation (n + 1) 2 2 = 4 := by\n  induction' n with nn nih\n  · rw [hyperoperation_one]\n  · rw [hyperoperation_recursion, hyperoperation_ge_two_eq_self, nih]\n\n"}
{"name":"hyperoperation_ge_three_one","module":"Mathlib.Data.Nat.Hyperoperation","initialProofState":"n k : Nat\n⊢ Eq (hyperoperation (HAdd.hAdd n 3) 1 k) 1","decl":"theorem hyperoperation_ge_three_one (n : ℕ) : ∀ k : ℕ, hyperoperation (n + 3) 1 k = 1 := by\n  induction' n with nn nih\n  · intro k\n    rw [hyperoperation_three]\n    dsimp\n    rw [one_pow]\n  · intro k\n    cases k\n    · rw [hyperoperation_ge_three_eq_one]\n    · rw [hyperoperation_recursion, nih]\n\n"}
{"name":"hyperoperation_ge_four_zero","module":"Mathlib.Data.Nat.Hyperoperation","initialProofState":"n k : Nat\n⊢ Eq (hyperoperation (HAdd.hAdd n 4) 0 k) (ite (Even k) 1 0)","decl":"theorem hyperoperation_ge_four_zero (n k : ℕ) :\n    hyperoperation (n + 4) 0 k = if Even k then 1 else 0 := by\n  induction' k with kk kih\n  · rw [hyperoperation_ge_three_eq_one]\n    simp only [Even.zero, if_true]\n  · rw [hyperoperation_recursion]\n    rw [kih]\n    simp_rw [Nat.even_add_one]\n    split_ifs\n    · exact hyperoperation_ge_two_eq_self (n + 1) 0\n    · exact hyperoperation_ge_three_eq_one n 0\n"}
