{"name":"BoxIntegral.IntegrationParams.ext_iff","module":"Mathlib.Analysis.BoxIntegral.Partition.Filter","initialProofState":"x y : BoxIntegral.IntegrationParams\n⊢ Iff (Eq x y) (And (Eq x.bRiemann y.bRiemann) (And (Eq x.bHenstock y.bHenstock) (Eq x.bDistortion y.bDistortion)))","decl":"/-- An `IntegrationParams` is a structure holding 3 boolean values used to define a filter to be\nused in the definition of a box-integrable function.\n\n* `bRiemann`: the value `true` means that the filter corresponds to a Riemann-style integral, i.e.\n  in the definition of integrability we require a constant upper estimate `r` on the size of boxes\n  of a tagged partition; the value `false` means that the estimate may depend on the position of the\n  tag.\n\n* `bHenstock`: the value `true` means that we require that each tag belongs to its own closed box;\n  the value `false` means that we only require that tags belong to the ambient box.\n\n* `bDistortion`: the value `true` means that `r` can depend on the maximal ratio of sides of the\n  same box of a partition. Presence of this case makes quite a few proofs harder but we can prove\n  the divergence theorem only for the filter `BoxIntegral.IntegrationParams.GP = ⊥ =\n  {bRiemann := false, bHenstock := true, bDistortion := true}`.\n-/\n@[ext]\nstructure IntegrationParams : Type where\n  (bRiemann bHenstock bDistortion : Bool)\n\n"}
{"name":"BoxIntegral.IntegrationParams.mk.sizeOf_spec","module":"Mathlib.Analysis.BoxIntegral.Partition.Filter","initialProofState":"bRiemann bHenstock bDistortion : Bool\n⊢ Eq (SizeOf.sizeOf { bRiemann := bRiemann, bHenstock := bHenstock, bDistortion := bDistortion }) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf bRiemann)) (SizeOf.sizeOf bHenstock)) (SizeOf.sizeOf bDistortion))","decl":"/-- An `IntegrationParams` is a structure holding 3 boolean values used to define a filter to be\nused in the definition of a box-integrable function.\n\n* `bRiemann`: the value `true` means that the filter corresponds to a Riemann-style integral, i.e.\n  in the definition of integrability we require a constant upper estimate `r` on the size of boxes\n  of a tagged partition; the value `false` means that the estimate may depend on the position of the\n  tag.\n\n* `bHenstock`: the value `true` means that we require that each tag belongs to its own closed box;\n  the value `false` means that we only require that tags belong to the ambient box.\n\n* `bDistortion`: the value `true` means that `r` can depend on the maximal ratio of sides of the\n  same box of a partition. Presence of this case makes quite a few proofs harder but we can prove\n  the divergence theorem only for the filter `BoxIntegral.IntegrationParams.GP = ⊥ =\n  {bRiemann := false, bHenstock := true, bDistortion := true}`.\n-/\n@[ext]\nstructure IntegrationParams : Type where\n  (bRiemann bHenstock bDistortion : Bool)\n\n"}
{"name":"BoxIntegral.IntegrationParams.mk.inj","module":"Mathlib.Analysis.BoxIntegral.Partition.Filter","initialProofState":"bRiemann✝ bHenstock✝ bDistortion✝ bRiemann bHenstock bDistortion : Bool\nx✝ : Eq { bRiemann := bRiemann✝, bHenstock := bHenstock✝, bDistortion := bDistortion✝ } { bRiemann := bRiemann, bHenstock := bHenstock, bDistortion := bDistortion }\n⊢ And (Eq bRiemann✝ bRiemann) (And (Eq bHenstock✝ bHenstock) (Eq bDistortion✝ bDistortion))","decl":"/-- An `IntegrationParams` is a structure holding 3 boolean values used to define a filter to be\nused in the definition of a box-integrable function.\n\n* `bRiemann`: the value `true` means that the filter corresponds to a Riemann-style integral, i.e.\n  in the definition of integrability we require a constant upper estimate `r` on the size of boxes\n  of a tagged partition; the value `false` means that the estimate may depend on the position of the\n  tag.\n\n* `bHenstock`: the value `true` means that we require that each tag belongs to its own closed box;\n  the value `false` means that we only require that tags belong to the ambient box.\n\n* `bDistortion`: the value `true` means that `r` can depend on the maximal ratio of sides of the\n  same box of a partition. Presence of this case makes quite a few proofs harder but we can prove\n  the divergence theorem only for the filter `BoxIntegral.IntegrationParams.GP = ⊥ =\n  {bRiemann := false, bHenstock := true, bDistortion := true}`.\n-/\n@[ext]\nstructure IntegrationParams : Type where\n  (bRiemann bHenstock bDistortion : Bool)\n\n"}
{"name":"BoxIntegral.IntegrationParams.ext","module":"Mathlib.Analysis.BoxIntegral.Partition.Filter","initialProofState":"x y : BoxIntegral.IntegrationParams\nbRiemann : Eq x.bRiemann y.bRiemann\nbHenstock : Eq x.bHenstock y.bHenstock\nbDistortion : Eq x.bDistortion y.bDistortion\n⊢ Eq x y","decl":"/-- An `IntegrationParams` is a structure holding 3 boolean values used to define a filter to be\nused in the definition of a box-integrable function.\n\n* `bRiemann`: the value `true` means that the filter corresponds to a Riemann-style integral, i.e.\n  in the definition of integrability we require a constant upper estimate `r` on the size of boxes\n  of a tagged partition; the value `false` means that the estimate may depend on the position of the\n  tag.\n\n* `bHenstock`: the value `true` means that we require that each tag belongs to its own closed box;\n  the value `false` means that we only require that tags belong to the ambient box.\n\n* `bDistortion`: the value `true` means that `r` can depend on the maximal ratio of sides of the\n  same box of a partition. Presence of this case makes quite a few proofs harder but we can prove\n  the divergence theorem only for the filter `BoxIntegral.IntegrationParams.GP = ⊥ =\n  {bRiemann := false, bHenstock := true, bDistortion := true}`.\n-/\n@[ext]\nstructure IntegrationParams : Type where\n  (bRiemann bHenstock bDistortion : Bool)\n\n"}
{"name":"BoxIntegral.IntegrationParams.mk.injEq","module":"Mathlib.Analysis.BoxIntegral.Partition.Filter","initialProofState":"bRiemann✝ bHenstock✝ bDistortion✝ bRiemann bHenstock bDistortion : Bool\n⊢ Eq (Eq { bRiemann := bRiemann✝, bHenstock := bHenstock✝, bDistortion := bDistortion✝ } { bRiemann := bRiemann, bHenstock := bHenstock, bDistortion := bDistortion }) (And (Eq bRiemann✝ bRiemann) (And (Eq bHenstock✝ bHenstock) (Eq bDistortion✝ bDistortion)))","decl":"/-- An `IntegrationParams` is a structure holding 3 boolean values used to define a filter to be\nused in the definition of a box-integrable function.\n\n* `bRiemann`: the value `true` means that the filter corresponds to a Riemann-style integral, i.e.\n  in the definition of integrability we require a constant upper estimate `r` on the size of boxes\n  of a tagged partition; the value `false` means that the estimate may depend on the position of the\n  tag.\n\n* `bHenstock`: the value `true` means that we require that each tag belongs to its own closed box;\n  the value `false` means that we only require that tags belong to the ambient box.\n\n* `bDistortion`: the value `true` means that `r` can depend on the maximal ratio of sides of the\n  same box of a partition. Presence of this case makes quite a few proofs harder but we can prove\n  the divergence theorem only for the filter `BoxIntegral.IntegrationParams.GP = ⊥ =\n  {bRiemann := false, bHenstock := true, bDistortion := true}`.\n-/\n@[ext]\nstructure IntegrationParams : Type where\n  (bRiemann bHenstock bDistortion : Bool)\n\n"}
{"name":"BoxIntegral.IntegrationParams.henstock_le_riemann","module":"Mathlib.Analysis.BoxIntegral.Partition.Filter","initialProofState":"⊢ LE.le BoxIntegral.IntegrationParams.Henstock BoxIntegral.IntegrationParams.Riemann","decl":"theorem henstock_le_riemann : Henstock ≤ Riemann := by trivial\n\n"}
{"name":"BoxIntegral.IntegrationParams.henstock_le_mcShane","module":"Mathlib.Analysis.BoxIntegral.Partition.Filter","initialProofState":"⊢ LE.le BoxIntegral.IntegrationParams.Henstock BoxIntegral.IntegrationParams.McShane","decl":"theorem henstock_le_mcShane : Henstock ≤ McShane := by trivial\n\n"}
{"name":"BoxIntegral.IntegrationParams.gp_le","module":"Mathlib.Analysis.BoxIntegral.Partition.Filter","initialProofState":"l : BoxIntegral.IntegrationParams\n⊢ LE.le BoxIntegral.IntegrationParams.GP l","decl":"theorem gp_le : GP ≤ l :=\n  bot_le\n\n"}
{"name":"BoxIntegral.IntegrationParams.MemBaseSet.exists_compl","module":"Mathlib.Analysis.BoxIntegral.Partition.Filter","initialProofState":"ι : Type u_1\ninst✝ : Fintype ι\nl : BoxIntegral.IntegrationParams\nI : BoxIntegral.Box ι\nc : NNReal\nr : (ι → Real) → ↑(Set.Ioi 0)\nπ : BoxIntegral.TaggedPrepartition I\nself : l.MemBaseSet I c r π\na✝ : Eq l.bDistortion Bool.true\n⊢ Exists fun π' => And (Eq π'.iUnion (SDiff.sdiff (↑I) π.iUnion)) (LE.le π'.distortion c)","decl":"/-- The predicate corresponding to a base set of the filter defined by an\n`IntegrationParams`. It says that\n\n* if `l.bHenstock`, then `π` is a Henstock prepartition, i.e. each tag belongs to the corresponding\n  closed box;\n* `π` is subordinate to `r`;\n* if `l.bDistortion`, then the distortion of each box in `π` is less than or equal to `c`;\n* if `l.bDistortion`, then there exists a prepartition `π'` with distortion `≤ c` that covers\n  exactly `I \\ π.iUnion`.\n\nThe last condition is automatically verified for partitions, and is used in the proof of the\nSacks-Henstock inequality to compare two prepartitions covering the same part of the box.\n\nIt is also automatically satisfied for any `c > 1`, see TODO section of the module docstring for\ndetails. -/\nstructure MemBaseSet (l : IntegrationParams) (I : Box ι) (c : ℝ≥0) (r : (ι → ℝ) → Ioi (0 : ℝ))\n    (π : TaggedPrepartition I) : Prop where\n  protected isSubordinate : π.IsSubordinate r\n  protected isHenstock : l.bHenstock → π.IsHenstock\n  protected distortion_le : l.bDistortion → π.distortion ≤ c\n  protected exists_compl : l.bDistortion → ∃ π' : Prepartition I,\n    π'.iUnion = ↑I \\ π.iUnion ∧ π'.distortion ≤ c\n\n"}
{"name":"BoxIntegral.IntegrationParams.MemBaseSet.distortion_le","module":"Mathlib.Analysis.BoxIntegral.Partition.Filter","initialProofState":"ι : Type u_1\ninst✝ : Fintype ι\nl : BoxIntegral.IntegrationParams\nI : BoxIntegral.Box ι\nc : NNReal\nr : (ι → Real) → ↑(Set.Ioi 0)\nπ : BoxIntegral.TaggedPrepartition I\nself : l.MemBaseSet I c r π\na✝ : Eq l.bDistortion Bool.true\n⊢ LE.le π.distortion c","decl":"/-- The predicate corresponding to a base set of the filter defined by an\n`IntegrationParams`. It says that\n\n* if `l.bHenstock`, then `π` is a Henstock prepartition, i.e. each tag belongs to the corresponding\n  closed box;\n* `π` is subordinate to `r`;\n* if `l.bDistortion`, then the distortion of each box in `π` is less than or equal to `c`;\n* if `l.bDistortion`, then there exists a prepartition `π'` with distortion `≤ c` that covers\n  exactly `I \\ π.iUnion`.\n\nThe last condition is automatically verified for partitions, and is used in the proof of the\nSacks-Henstock inequality to compare two prepartitions covering the same part of the box.\n\nIt is also automatically satisfied for any `c > 1`, see TODO section of the module docstring for\ndetails. -/\nstructure MemBaseSet (l : IntegrationParams) (I : Box ι) (c : ℝ≥0) (r : (ι → ℝ) → Ioi (0 : ℝ))\n    (π : TaggedPrepartition I) : Prop where\n  protected isSubordinate : π.IsSubordinate r\n  protected isHenstock : l.bHenstock → π.IsHenstock\n  protected distortion_le : l.bDistortion → π.distortion ≤ c\n  protected exists_compl : l.bDistortion → ∃ π' : Prepartition I,\n    π'.iUnion = ↑I \\ π.iUnion ∧ π'.distortion ≤ c\n\n"}
{"name":"BoxIntegral.IntegrationParams.MemBaseSet.isSubordinate","module":"Mathlib.Analysis.BoxIntegral.Partition.Filter","initialProofState":"ι : Type u_1\ninst✝ : Fintype ι\nl : BoxIntegral.IntegrationParams\nI : BoxIntegral.Box ι\nc : NNReal\nr : (ι → Real) → ↑(Set.Ioi 0)\nπ : BoxIntegral.TaggedPrepartition I\nself : l.MemBaseSet I c r π\n⊢ π.IsSubordinate r","decl":"/-- The predicate corresponding to a base set of the filter defined by an\n`IntegrationParams`. It says that\n\n* if `l.bHenstock`, then `π` is a Henstock prepartition, i.e. each tag belongs to the corresponding\n  closed box;\n* `π` is subordinate to `r`;\n* if `l.bDistortion`, then the distortion of each box in `π` is less than or equal to `c`;\n* if `l.bDistortion`, then there exists a prepartition `π'` with distortion `≤ c` that covers\n  exactly `I \\ π.iUnion`.\n\nThe last condition is automatically verified for partitions, and is used in the proof of the\nSacks-Henstock inequality to compare two prepartitions covering the same part of the box.\n\nIt is also automatically satisfied for any `c > 1`, see TODO section of the module docstring for\ndetails. -/\nstructure MemBaseSet (l : IntegrationParams) (I : Box ι) (c : ℝ≥0) (r : (ι → ℝ) → Ioi (0 : ℝ))\n    (π : TaggedPrepartition I) : Prop where\n  protected isSubordinate : π.IsSubordinate r\n  protected isHenstock : l.bHenstock → π.IsHenstock\n  protected distortion_le : l.bDistortion → π.distortion ≤ c\n  protected exists_compl : l.bDistortion → ∃ π' : Prepartition I,\n    π'.iUnion = ↑I \\ π.iUnion ∧ π'.distortion ≤ c\n\n"}
{"name":"BoxIntegral.IntegrationParams.MemBaseSet.isHenstock","module":"Mathlib.Analysis.BoxIntegral.Partition.Filter","initialProofState":"ι : Type u_1\ninst✝ : Fintype ι\nl : BoxIntegral.IntegrationParams\nI : BoxIntegral.Box ι\nc : NNReal\nr : (ι → Real) → ↑(Set.Ioi 0)\nπ : BoxIntegral.TaggedPrepartition I\nself : l.MemBaseSet I c r π\na✝ : Eq l.bHenstock Bool.true\n⊢ π.IsHenstock","decl":"/-- The predicate corresponding to a base set of the filter defined by an\n`IntegrationParams`. It says that\n\n* if `l.bHenstock`, then `π` is a Henstock prepartition, i.e. each tag belongs to the corresponding\n  closed box;\n* `π` is subordinate to `r`;\n* if `l.bDistortion`, then the distortion of each box in `π` is less than or equal to `c`;\n* if `l.bDistortion`, then there exists a prepartition `π'` with distortion `≤ c` that covers\n  exactly `I \\ π.iUnion`.\n\nThe last condition is automatically verified for partitions, and is used in the proof of the\nSacks-Henstock inequality to compare two prepartitions covering the same part of the box.\n\nIt is also automatically satisfied for any `c > 1`, see TODO section of the module docstring for\ndetails. -/\nstructure MemBaseSet (l : IntegrationParams) (I : Box ι) (c : ℝ≥0) (r : (ι → ℝ) → Ioi (0 : ℝ))\n    (π : TaggedPrepartition I) : Prop where\n  protected isSubordinate : π.IsSubordinate r\n  protected isHenstock : l.bHenstock → π.IsHenstock\n  protected distortion_le : l.bDistortion → π.distortion ≤ c\n  protected exists_compl : l.bDistortion → ∃ π' : Prepartition I,\n    π'.iUnion = ↑I \\ π.iUnion ∧ π'.distortion ≤ c\n\n"}
{"name":"BoxIntegral.IntegrationParams.rCond_of_bRiemann_eq_false","module":"Mathlib.Analysis.BoxIntegral.Partition.Filter","initialProofState":"ι : Type u_2\nl : BoxIntegral.IntegrationParams\nhl : Eq l.bRiemann Bool.false\nr : (ι → Real) → ↑(Set.Ioi 0)\n⊢ l.RCond r","decl":"theorem rCond_of_bRiemann_eq_false {ι} (l : IntegrationParams) (hl : l.bRiemann = false)\n    {r : (ι → ℝ) → Ioi (0 : ℝ)} : l.RCond r := by\n  simp [RCond, hl]\n\n"}
{"name":"BoxIntegral.IntegrationParams.toFilter_inf_iUnion_eq","module":"Mathlib.Analysis.BoxIntegral.Partition.Filter","initialProofState":"ι : Type u_1\ninst✝ : Fintype ι\nl : BoxIntegral.IntegrationParams\nI : BoxIntegral.Box ι\nπ₀ : BoxIntegral.Prepartition I\n⊢ Eq (Min.min (l.toFilter I) (Filter.principal (setOf fun π => Eq π.iUnion π₀.iUnion))) (BoxIntegral.IntegrationParams.toFilteriUnion I π₀)","decl":"theorem toFilter_inf_iUnion_eq (l : IntegrationParams) (I : Box ι) (π₀ : Prepartition I) :\n    l.toFilter I ⊓ 𝓟 { π | π.iUnion = π₀.iUnion } = l.toFilteriUnion I π₀ :=\n  (iSup_inf_principal _ _).symm\n\n"}
{"name":"BoxIntegral.IntegrationParams.MemBaseSet.mono'","module":"Mathlib.Analysis.BoxIntegral.Partition.Filter","initialProofState":"ι : Type u_1\ninst✝ : Fintype ι\nI : BoxIntegral.Box ι\nc₁ c₂ : NNReal\nl₁ l₂ : BoxIntegral.IntegrationParams\nr₁ r₂ : (ι → Real) → ↑(Set.Ioi 0)\nπ : BoxIntegral.TaggedPrepartition I\nh : LE.le l₁ l₂\nhc : LE.le c₁ c₂\nhr : ∀ (J : BoxIntegral.Box ι), Membership.mem π J → LE.le (r₁ (π.tag J)) (r₂ (π.tag J))\nhπ : l₁.MemBaseSet I c₁ r₁ π\n⊢ l₂.MemBaseSet I c₂ r₂ π","decl":"variable (I) in\ntheorem MemBaseSet.mono' (h : l₁ ≤ l₂) (hc : c₁ ≤ c₂)\n    (hr : ∀ J ∈ π, r₁ (π.tag J) ≤ r₂ (π.tag J)) (hπ : l₁.MemBaseSet I c₁ r₁ π) :\n    l₂.MemBaseSet I c₂ r₂ π :=\n  ⟨hπ.1.mono' hr, fun h₂ => hπ.2 (le_iff_imp.1 h.2.1 h₂),\n    fun hD => (hπ.3 (le_iff_imp.1 h.2.2 hD)).trans hc,\n    fun hD => (hπ.4 (le_iff_imp.1 h.2.2 hD)).imp fun _ hπ => ⟨hπ.1, hπ.2.trans hc⟩⟩\n\n"}
{"name":"BoxIntegral.IntegrationParams.MemBaseSet.mono","module":"Mathlib.Analysis.BoxIntegral.Partition.Filter","initialProofState":"ι : Type u_1\ninst✝ : Fintype ι\nI : BoxIntegral.Box ι\nc₁ c₂ : NNReal\nl₁ l₂ : BoxIntegral.IntegrationParams\nr₁ r₂ : (ι → Real) → ↑(Set.Ioi 0)\nπ : BoxIntegral.TaggedPrepartition I\nh : LE.le l₁ l₂\nhc : LE.le c₁ c₂\nhr : ∀ (x : ι → Real), Membership.mem (BoxIntegral.Box.Icc I) x → LE.le (r₁ x) (r₂ x)\nhπ : l₁.MemBaseSet I c₁ r₁ π\n⊢ l₂.MemBaseSet I c₂ r₂ π","decl":"variable (I) in\n@[mono]\ntheorem MemBaseSet.mono (h : l₁ ≤ l₂) (hc : c₁ ≤ c₂)\n    (hr : ∀ x ∈ Box.Icc I, r₁ x ≤ r₂ x) (hπ : l₁.MemBaseSet I c₁ r₁ π) : l₂.MemBaseSet I c₂ r₂ π :=\n  hπ.mono' I h hc fun J _ => hr _ <| π.tag_mem_Icc J\n\n"}
{"name":"BoxIntegral.IntegrationParams.MemBaseSet.exists_common_compl","module":"Mathlib.Analysis.BoxIntegral.Partition.Filter","initialProofState":"ι : Type u_1\ninst✝ : Fintype ι\nI : BoxIntegral.Box ι\nc₁ c₂ : NNReal\nl : BoxIntegral.IntegrationParams\nr₁ r₂ : (ι → Real) → ↑(Set.Ioi 0)\nπ₁ π₂ : BoxIntegral.TaggedPrepartition I\nh₁ : l.MemBaseSet I c₁ r₁ π₁\nh₂ : l.MemBaseSet I c₂ r₂ π₂\nhU : Eq π₁.iUnion π₂.iUnion\n⊢ Exists fun π => And (Eq π.iUnion (SDiff.sdiff (↑I) π₁.iUnion)) (And (Eq l.bDistortion Bool.true → LE.le π.distortion c₁) (Eq l.bDistortion Bool.true → LE.le π.distortion c₂))","decl":"theorem MemBaseSet.exists_common_compl\n    (h₁ : l.MemBaseSet I c₁ r₁ π₁) (h₂ : l.MemBaseSet I c₂ r₂ π₂)\n    (hU : π₁.iUnion = π₂.iUnion) :\n    ∃ π : Prepartition I, π.iUnion = ↑I \\ π₁.iUnion ∧\n      (l.bDistortion → π.distortion ≤ c₁) ∧ (l.bDistortion → π.distortion ≤ c₂) := by\n  wlog hc : c₁ ≤ c₂ with H\n  · simpa [hU, _root_.and_comm] using\n      @H _ _ I c₂ c₁ l r₂ r₁ π₂ π₁ h₂ h₁ hU.symm (le_of_not_le hc)\n  by_cases hD : (l.bDistortion : Prop)\n  · rcases h₁.4 hD with ⟨π, hπU, hπc⟩\n    exact ⟨π, hπU, fun _ => hπc, fun _ => hπc.trans hc⟩\n  · exact ⟨π₁.toPrepartition.compl, π₁.toPrepartition.iUnion_compl,\n      fun h => (hD h).elim, fun h => (hD h).elim⟩\n\n"}
{"name":"BoxIntegral.IntegrationParams.MemBaseSet.unionComplToSubordinate","module":"Mathlib.Analysis.BoxIntegral.Partition.Filter","initialProofState":"ι : Type u_1\ninst✝ : Fintype ι\nI : BoxIntegral.Box ι\nc : NNReal\nl : BoxIntegral.IntegrationParams\nr₁ r₂ : (ι → Real) → ↑(Set.Ioi 0)\nπ₁ : BoxIntegral.TaggedPrepartition I\nhπ₁ : l.MemBaseSet I c r₁ π₁\nhle : ∀ (x : ι → Real), Membership.mem (BoxIntegral.Box.Icc I) x → LE.le (r₂ x) (r₁ x)\nπ₂ : BoxIntegral.Prepartition I\nhU : Eq π₂.iUnion (SDiff.sdiff (↑I) π₁.iUnion)\nhc : Eq l.bDistortion Bool.true → LE.le π₂.distortion c\n⊢ l.MemBaseSet I c r₁ (π₁.unionComplToSubordinate π₂ hU r₂)","decl":"protected theorem MemBaseSet.unionComplToSubordinate (hπ₁ : l.MemBaseSet I c r₁ π₁)\n    (hle : ∀ x ∈ Box.Icc I, r₂ x ≤ r₁ x) {π₂ : Prepartition I} (hU : π₂.iUnion = ↑I \\ π₁.iUnion)\n    (hc : l.bDistortion → π₂.distortion ≤ c) :\n    l.MemBaseSet I c r₁ (π₁.unionComplToSubordinate π₂ hU r₂) :=\n  ⟨hπ₁.1.disjUnion ((π₂.isSubordinate_toSubordinate r₂).mono hle) _,\n    fun h => (hπ₁.2 h).disjUnion (π₂.isHenstock_toSubordinate _) _,\n    fun h => (distortion_unionComplToSubordinate _ _ _ _).trans_le (max_le (hπ₁.3 h) (hc h)),\n    fun _ => ⟨⊥, by simp⟩⟩\n\n"}
{"name":"BoxIntegral.IntegrationParams.MemBaseSet.filter","module":"Mathlib.Analysis.BoxIntegral.Partition.Filter","initialProofState":"ι : Type u_1\ninst✝ : Fintype ι\nI : BoxIntegral.Box ι\nc : NNReal\nl : BoxIntegral.IntegrationParams\nπ : BoxIntegral.TaggedPrepartition I\nr : (ι → Real) → ↑(Set.Ioi 0)\nhπ : l.MemBaseSet I c r π\np : BoxIntegral.Box ι → Prop\n⊢ l.MemBaseSet I c r (π.filter p)","decl":"protected theorem MemBaseSet.filter (hπ : l.MemBaseSet I c r π) (p : Box ι → Prop) :\n    l.MemBaseSet I c r (π.filter p) := by\n  classical\n  refine ⟨fun J hJ => hπ.1 J (π.mem_filter.1 hJ).1, fun hH J hJ => hπ.2 hH J (π.mem_filter.1 hJ).1,\n    fun hD => (distortion_filter_le _ _).trans (hπ.3 hD), fun hD => ?_⟩\n  rcases hπ.4 hD with ⟨π₁, hπ₁U, hc⟩\n  set π₂ := π.filter fun J => ¬p J\n  have : Disjoint π₁.iUnion π₂.iUnion := by\n    simpa [π₂, hπ₁U] using disjoint_sdiff_self_left.mono_right sdiff_le\n  refine ⟨π₁.disjUnion π₂.toPrepartition this, ?_, ?_⟩\n  · suffices ↑I \\ π.iUnion ∪ π.iUnion \\ (π.filter p).iUnion = ↑I \\ (π.filter p).iUnion by\n      simp [π₂, *]\n    have h : (π.filter p).iUnion ⊆ π.iUnion :=\n      biUnion_subset_biUnion_left (Finset.filter_subset _ _)\n    ext x\n    fconstructor\n    · rintro (⟨hxI, hxπ⟩ | ⟨hxπ, hxp⟩)\n      exacts [⟨hxI, mt (@h x) hxπ⟩, ⟨π.iUnion_subset hxπ, hxp⟩]\n    · rintro ⟨hxI, hxp⟩\n      by_cases hxπ : x ∈ π.iUnion\n      exacts [Or.inr ⟨hxπ, hxp⟩, Or.inl ⟨hxI, hxπ⟩]\n  · have : (π.filter fun J => ¬p J).distortion ≤ c := (distortion_filter_le _ _).trans (hπ.3 hD)\n    simpa [hc]\n\n"}
{"name":"BoxIntegral.IntegrationParams.biUnionTagged_memBaseSet","module":"Mathlib.Analysis.BoxIntegral.Partition.Filter","initialProofState":"ι : Type u_1\ninst✝ : Fintype ι\nI : BoxIntegral.Box ι\nc : NNReal\nl : BoxIntegral.IntegrationParams\nr : (ι → Real) → ↑(Set.Ioi 0)\nπ : BoxIntegral.Prepartition I\nπi : (J : BoxIntegral.Box ι) → BoxIntegral.TaggedPrepartition J\nh : ∀ (J : BoxIntegral.Box ι), Membership.mem π J → l.MemBaseSet J c r (πi J)\nhp : ∀ (J : BoxIntegral.Box ι), Membership.mem π J → (πi J).IsPartition\nhc : Eq l.bDistortion Bool.true → LE.le π.compl.distortion c\n⊢ l.MemBaseSet I c r (π.biUnionTagged πi)","decl":"theorem biUnionTagged_memBaseSet {π : Prepartition I} {πi : ∀ J, TaggedPrepartition J}\n    (h : ∀ J ∈ π, l.MemBaseSet J c r (πi J)) (hp : ∀ J ∈ π, (πi J).IsPartition)\n    (hc : l.bDistortion → π.compl.distortion ≤ c) : l.MemBaseSet I c r (π.biUnionTagged πi) := by\n  refine ⟨TaggedPrepartition.isSubordinate_biUnionTagged.2 fun J hJ => (h J hJ).1,\n    fun hH => TaggedPrepartition.isHenstock_biUnionTagged.2 fun J hJ => (h J hJ).2 hH,\n    fun hD => ?_, fun hD => ?_⟩\n  · rw [Prepartition.distortion_biUnionTagged, Finset.sup_le_iff]\n    exact fun J hJ => (h J hJ).3 hD\n  · refine ⟨_, ?_, hc hD⟩\n    rw [π.iUnion_compl, ← π.iUnion_biUnion_partition hp]\n    rfl\n\n"}
{"name":"BoxIntegral.IntegrationParams.RCond.mono","module":"Mathlib.Analysis.BoxIntegral.Partition.Filter","initialProofState":"l₁ l₂ : BoxIntegral.IntegrationParams\nι : Type u_2\nr : (ι → Real) → ↑(Set.Ioi 0)\nh : LE.le l₁ l₂\nhr : l₂.RCond r\n⊢ l₁.RCond r","decl":"@[mono]\ntheorem RCond.mono {ι : Type*} {r : (ι → ℝ) → Ioi (0 : ℝ)} (h : l₁ ≤ l₂) (hr : l₂.RCond r) :\n    l₁.RCond r :=\n  fun hR => hr (le_iff_imp.1 h.1 hR)\n\n"}
{"name":"BoxIntegral.IntegrationParams.RCond.min","module":"Mathlib.Analysis.BoxIntegral.Partition.Filter","initialProofState":"l : BoxIntegral.IntegrationParams\nι : Type u_2\nr₁ r₂ : (ι → Real) → ↑(Set.Ioi 0)\nh₁ : l.RCond r₁\nh₂ : l.RCond r₂\n⊢ l.RCond fun x => Min.min (r₁ x) (r₂ x)","decl":"nonrec theorem RCond.min {ι : Type*} {r₁ r₂ : (ι → ℝ) → Ioi (0 : ℝ)} (h₁ : l.RCond r₁)\n    (h₂ : l.RCond r₂) : l.RCond fun x => min (r₁ x) (r₂ x) :=\n  fun hR x => congr_arg₂ min (h₁ hR x) (h₂ hR x)\n\n"}
{"name":"BoxIntegral.IntegrationParams.toFilterDistortion_mono","module":"Mathlib.Analysis.BoxIntegral.Partition.Filter","initialProofState":"ι : Type u_1\ninst✝ : Fintype ι\nc₁ c₂ : NNReal\nl₁ l₂ : BoxIntegral.IntegrationParams\nI : BoxIntegral.Box ι\nh : LE.le l₁ l₂\nhc : LE.le c₁ c₂\n⊢ LE.le (l₁.toFilterDistortion I c₁) (l₂.toFilterDistortion I c₂)","decl":"@[gcongr, mono]\ntheorem toFilterDistortion_mono (I : Box ι) (h : l₁ ≤ l₂) (hc : c₁ ≤ c₂) :\n    l₁.toFilterDistortion I c₁ ≤ l₂.toFilterDistortion I c₂ :=\n  iInf_mono fun _ =>\n    iInf_mono' fun hr =>\n      ⟨hr.mono h, principal_mono.2 fun _ => MemBaseSet.mono I h hc fun _ _ => le_rfl⟩\n\n"}
{"name":"BoxIntegral.IntegrationParams.toFilter_mono","module":"Mathlib.Analysis.BoxIntegral.Partition.Filter","initialProofState":"ι : Type u_1\ninst✝ : Fintype ι\nI : BoxIntegral.Box ι\nl₁ l₂ : BoxIntegral.IntegrationParams\nh : LE.le l₁ l₂\n⊢ LE.le (l₁.toFilter I) (l₂.toFilter I)","decl":"@[gcongr, mono]\ntheorem toFilter_mono (I : Box ι) {l₁ l₂ : IntegrationParams} (h : l₁ ≤ l₂) :\n    l₁.toFilter I ≤ l₂.toFilter I :=\n  iSup_mono fun _ => toFilterDistortion_mono I h le_rfl\n\n"}
{"name":"BoxIntegral.IntegrationParams.toFilteriUnion_mono","module":"Mathlib.Analysis.BoxIntegral.Partition.Filter","initialProofState":"ι : Type u_1\ninst✝ : Fintype ι\nI : BoxIntegral.Box ι\nl₁ l₂ : BoxIntegral.IntegrationParams\nh : LE.le l₁ l₂\nπ₀ : BoxIntegral.Prepartition I\n⊢ LE.le (BoxIntegral.IntegrationParams.toFilteriUnion I π₀) (BoxIntegral.IntegrationParams.toFilteriUnion I π₀)","decl":"@[gcongr, mono]\ntheorem toFilteriUnion_mono (I : Box ι) {l₁ l₂ : IntegrationParams} (h : l₁ ≤ l₂)\n    (π₀ : Prepartition I) : l₁.toFilteriUnion I π₀ ≤ l₂.toFilteriUnion I π₀ :=\n  iSup_mono fun _ => inf_le_inf_right _ <| toFilterDistortion_mono _ h le_rfl\n\n"}
{"name":"BoxIntegral.IntegrationParams.toFilteriUnion_congr","module":"Mathlib.Analysis.BoxIntegral.Partition.Filter","initialProofState":"ι : Type u_1\ninst✝ : Fintype ι\nI : BoxIntegral.Box ι\nl : BoxIntegral.IntegrationParams\nπ₁ π₂ : BoxIntegral.Prepartition I\nh : Eq π₁.iUnion π₂.iUnion\n⊢ Eq (BoxIntegral.IntegrationParams.toFilteriUnion I π₁) (BoxIntegral.IntegrationParams.toFilteriUnion I π₂)","decl":"theorem toFilteriUnion_congr (I : Box ι) (l : IntegrationParams) {π₁ π₂ : Prepartition I}\n    (h : π₁.iUnion = π₂.iUnion) : l.toFilteriUnion I π₁ = l.toFilteriUnion I π₂ := by\n  simp only [toFilteriUnion, toFilterDistortioniUnion, h]\n\n"}
{"name":"BoxIntegral.IntegrationParams.hasBasis_toFilterDistortion","module":"Mathlib.Analysis.BoxIntegral.Partition.Filter","initialProofState":"ι : Type u_1\ninst✝ : Fintype ι\nl : BoxIntegral.IntegrationParams\nI : BoxIntegral.Box ι\nc : NNReal\n⊢ (l.toFilterDistortion I c).HasBasis l.RCond fun r => setOf fun π => l.MemBaseSet I c r π","decl":"theorem hasBasis_toFilterDistortion (l : IntegrationParams) (I : Box ι) (c : ℝ≥0) :\n    (l.toFilterDistortion I c).HasBasis l.RCond fun r => { π | l.MemBaseSet I c r π } :=\n  hasBasis_biInf_principal'\n    (fun _ hr₁ _ hr₂ =>\n      ⟨_, hr₁.min hr₂, fun _ => MemBaseSet.mono _ le_rfl le_rfl fun _ _ => min_le_left _ _,\n        fun _ => MemBaseSet.mono _ le_rfl le_rfl fun _ _ => min_le_right _ _⟩)\n    ⟨fun _ => ⟨1, Set.mem_Ioi.2 zero_lt_one⟩, fun _ _ => rfl⟩\n\n"}
{"name":"BoxIntegral.IntegrationParams.hasBasis_toFilterDistortioniUnion","module":"Mathlib.Analysis.BoxIntegral.Partition.Filter","initialProofState":"ι : Type u_1\ninst✝ : Fintype ι\nl : BoxIntegral.IntegrationParams\nI : BoxIntegral.Box ι\nc : NNReal\nπ₀ : BoxIntegral.Prepartition I\n⊢ (l.toFilterDistortioniUnion I c π₀).HasBasis l.RCond fun r => setOf fun π => And (l.MemBaseSet I c r π) (Eq π.iUnion π₀.iUnion)","decl":"theorem hasBasis_toFilterDistortioniUnion (l : IntegrationParams) (I : Box ι) (c : ℝ≥0)\n    (π₀ : Prepartition I) :\n    (l.toFilterDistortioniUnion I c π₀).HasBasis l.RCond fun r =>\n      { π | l.MemBaseSet I c r π ∧ π.iUnion = π₀.iUnion } :=\n  (l.hasBasis_toFilterDistortion I c).inf_principal _\n\n"}
{"name":"BoxIntegral.IntegrationParams.hasBasis_toFilteriUnion","module":"Mathlib.Analysis.BoxIntegral.Partition.Filter","initialProofState":"ι : Type u_1\ninst✝ : Fintype ι\nl : BoxIntegral.IntegrationParams\nI : BoxIntegral.Box ι\nπ₀ : BoxIntegral.Prepartition I\n⊢ (BoxIntegral.IntegrationParams.toFilteriUnion I π₀).HasBasis (fun r => ∀ (c : NNReal), l.RCond (r c)) fun r => setOf fun π => Exists fun c => And (l.MemBaseSet I c (r c) π) (Eq π.iUnion π₀.iUnion)","decl":"theorem hasBasis_toFilteriUnion (l : IntegrationParams) (I : Box ι) (π₀ : Prepartition I) :\n    (l.toFilteriUnion I π₀).HasBasis (fun r : ℝ≥0 → (ι → ℝ) → Ioi (0 : ℝ) => ∀ c, l.RCond (r c))\n      fun r => { π | ∃ c, l.MemBaseSet I c (r c) π ∧ π.iUnion = π₀.iUnion } := by\n  have := fun c => l.hasBasis_toFilterDistortioniUnion I c π₀\n  simpa only [setOf_and, setOf_exists] using hasBasis_iSup this\n\n"}
{"name":"BoxIntegral.IntegrationParams.hasBasis_toFilteriUnion_top","module":"Mathlib.Analysis.BoxIntegral.Partition.Filter","initialProofState":"ι : Type u_1\ninst✝ : Fintype ι\nl : BoxIntegral.IntegrationParams\nI : BoxIntegral.Box ι\n⊢ (BoxIntegral.IntegrationParams.toFilteriUnion I Top.top).HasBasis (fun r => ∀ (c : NNReal), l.RCond (r c)) fun r => setOf fun π => Exists fun c => And (l.MemBaseSet I c (r c) π) π.IsPartition","decl":"theorem hasBasis_toFilteriUnion_top (l : IntegrationParams) (I : Box ι) :\n    (l.toFilteriUnion I ⊤).HasBasis (fun r : ℝ≥0 → (ι → ℝ) → Ioi (0 : ℝ) => ∀ c, l.RCond (r c))\n      fun r => { π | ∃ c, l.MemBaseSet I c (r c) π ∧ π.IsPartition } := by\n  simpa only [TaggedPrepartition.isPartition_iff_iUnion_eq, Prepartition.iUnion_top] using\n    l.hasBasis_toFilteriUnion I ⊤\n\n"}
{"name":"BoxIntegral.IntegrationParams.hasBasis_toFilter","module":"Mathlib.Analysis.BoxIntegral.Partition.Filter","initialProofState":"ι : Type u_1\ninst✝ : Fintype ι\nl : BoxIntegral.IntegrationParams\nI : BoxIntegral.Box ι\n⊢ (l.toFilter I).HasBasis (fun r => ∀ (c : NNReal), l.RCond (r c)) fun r => setOf fun π => Exists fun c => l.MemBaseSet I c (r c) π","decl":"theorem hasBasis_toFilter (l : IntegrationParams) (I : Box ι) :\n    (l.toFilter I).HasBasis (fun r : ℝ≥0 → (ι → ℝ) → Ioi (0 : ℝ) => ∀ c, l.RCond (r c))\n      fun r => { π | ∃ c, l.MemBaseSet I c (r c) π } := by\n  simpa only [setOf_exists] using hasBasis_iSup (l.hasBasis_toFilterDistortion I)\n\n"}
{"name":"BoxIntegral.IntegrationParams.tendsto_embedBox_toFilteriUnion_top","module":"Mathlib.Analysis.BoxIntegral.Partition.Filter","initialProofState":"ι : Type u_1\ninst✝ : Fintype ι\nI J : BoxIntegral.Box ι\nl : BoxIntegral.IntegrationParams\nh : LE.le I J\n⊢ Filter.Tendsto (⇑(BoxIntegral.TaggedPrepartition.embedBox I J h)) (BoxIntegral.IntegrationParams.toFilteriUnion I Top.top) (BoxIntegral.IntegrationParams.toFilteriUnion J (BoxIntegral.Prepartition.single J I h))","decl":"theorem tendsto_embedBox_toFilteriUnion_top (l : IntegrationParams) (h : I ≤ J) :\n    Tendsto (TaggedPrepartition.embedBox I J h) (l.toFilteriUnion I ⊤)\n      (l.toFilteriUnion J (Prepartition.single J I h)) := by\n  simp only [toFilteriUnion, tendsto_iSup]; intro c\n  set π₀ := Prepartition.single J I h\n  refine le_iSup_of_le (max c π₀.compl.distortion) ?_\n  refine ((l.hasBasis_toFilterDistortioniUnion I c ⊤).tendsto_iff\n    (l.hasBasis_toFilterDistortioniUnion J _ _)).2 fun r hr => ?_\n  refine ⟨r, hr, fun π hπ => ?_⟩\n  rw [mem_setOf_eq, Prepartition.iUnion_top] at hπ\n  refine ⟨⟨hπ.1.1, hπ.1.2, fun hD => le_trans (hπ.1.3 hD) (le_max_left _ _), fun _ => ?_⟩, ?_⟩\n  · refine ⟨_, π₀.iUnion_compl.trans ?_, le_max_right _ _⟩\n    congr 1\n    exact (Prepartition.iUnion_single h).trans hπ.2.symm\n  · exact hπ.2.trans (Prepartition.iUnion_single _).symm\n\n"}
{"name":"BoxIntegral.IntegrationParams.exists_memBaseSet_le_iUnion_eq","module":"Mathlib.Analysis.BoxIntegral.Partition.Filter","initialProofState":"ι : Type u_1\ninst✝ : Fintype ι\nI : BoxIntegral.Box ι\nc : NNReal\nl : BoxIntegral.IntegrationParams\nπ₀ : BoxIntegral.Prepartition I\nhc₁ : LE.le π₀.distortion c\nhc₂ : LE.le π₀.compl.distortion c\nr : (ι → Real) → ↑(Set.Ioi 0)\n⊢ Exists fun π => And (l.MemBaseSet I c r π) (And (LE.le π.toPrepartition π₀) (Eq π.iUnion π₀.iUnion))","decl":"theorem exists_memBaseSet_le_iUnion_eq (l : IntegrationParams) (π₀ : Prepartition I)\n    (hc₁ : π₀.distortion ≤ c) (hc₂ : π₀.compl.distortion ≤ c) (r : (ι → ℝ) → Ioi (0 : ℝ)) :\n    ∃ π, l.MemBaseSet I c r π ∧ π.toPrepartition ≤ π₀ ∧ π.iUnion = π₀.iUnion := by\n  rcases π₀.exists_tagged_le_isHenstock_isSubordinate_iUnion_eq r with ⟨π, hle, hH, hr, hd, hU⟩\n  refine ⟨π, ⟨hr, fun _ => hH, fun _ => hd.trans_le hc₁, fun _ => ⟨π₀.compl, ?_, hc₂⟩⟩, ⟨hle, hU⟩⟩\n  exact Prepartition.compl_congr hU ▸ π.toPrepartition.iUnion_compl\n\n"}
{"name":"BoxIntegral.IntegrationParams.exists_memBaseSet_isPartition","module":"Mathlib.Analysis.BoxIntegral.Partition.Filter","initialProofState":"ι : Type u_1\ninst✝ : Fintype ι\nc : NNReal\nl : BoxIntegral.IntegrationParams\nI : BoxIntegral.Box ι\nhc : LE.le I.distortion c\nr : (ι → Real) → ↑(Set.Ioi 0)\n⊢ Exists fun π => And (l.MemBaseSet I c r π) π.IsPartition","decl":"theorem exists_memBaseSet_isPartition (l : IntegrationParams) (I : Box ι) (hc : I.distortion ≤ c)\n    (r : (ι → ℝ) → Ioi (0 : ℝ)) : ∃ π, l.MemBaseSet I c r π ∧ π.IsPartition := by\n  rw [← Prepartition.distortion_top] at hc\n  have hc' : (⊤ : Prepartition I).compl.distortion ≤ c := by simp\n  simpa [isPartition_iff_iUnion_eq] using l.exists_memBaseSet_le_iUnion_eq ⊤ hc hc' r\n\n"}
{"name":"BoxIntegral.IntegrationParams.toFilterDistortioniUnion_neBot","module":"Mathlib.Analysis.BoxIntegral.Partition.Filter","initialProofState":"ι : Type u_1\ninst✝ : Fintype ι\nc : NNReal\nl : BoxIntegral.IntegrationParams\nI : BoxIntegral.Box ι\nπ₀ : BoxIntegral.Prepartition I\nhc₁ : LE.le π₀.distortion c\nhc₂ : LE.le π₀.compl.distortion c\n⊢ (l.toFilterDistortioniUnion I c π₀).NeBot","decl":"theorem toFilterDistortioniUnion_neBot (l : IntegrationParams) (I : Box ι) (π₀ : Prepartition I)\n    (hc₁ : π₀.distortion ≤ c) (hc₂ : π₀.compl.distortion ≤ c) :\n    (l.toFilterDistortioniUnion I c π₀).NeBot :=\n  ((l.hasBasis_toFilterDistortion I _).inf_principal _).neBot_iff.2\n    fun {r} _ => (l.exists_memBaseSet_le_iUnion_eq π₀ hc₁ hc₂ r).imp fun _ hπ => ⟨hπ.1, hπ.2.2⟩\n\n"}
{"name":"BoxIntegral.IntegrationParams.toFilterDistortioniUnion_neBot'","module":"Mathlib.Analysis.BoxIntegral.Partition.Filter","initialProofState":"ι : Type u_1\ninst✝ : Fintype ι\nl : BoxIntegral.IntegrationParams\nI : BoxIntegral.Box ι\nπ₀ : BoxIntegral.Prepartition I\n⊢ (l.toFilterDistortioniUnion I (Max.max π₀.distortion π₀.compl.distortion) π₀).NeBot","decl":"instance toFilterDistortioniUnion_neBot' (l : IntegrationParams) (I : Box ι) (π₀ : Prepartition I) :\n    (l.toFilterDistortioniUnion I (max π₀.distortion π₀.compl.distortion) π₀).NeBot :=\n  l.toFilterDistortioniUnion_neBot I π₀ (le_max_left _ _) (le_max_right _ _)\n\n"}
{"name":"BoxIntegral.IntegrationParams.toFilterDistortion_neBot","module":"Mathlib.Analysis.BoxIntegral.Partition.Filter","initialProofState":"ι : Type u_1\ninst✝ : Fintype ι\nl : BoxIntegral.IntegrationParams\nI : BoxIntegral.Box ι\n⊢ (l.toFilterDistortion I I.distortion).NeBot","decl":"instance toFilterDistortion_neBot (l : IntegrationParams) (I : Box ι) :\n    (l.toFilterDistortion I I.distortion).NeBot := by\n  simpa using (l.toFilterDistortioniUnion_neBot' I ⊤).mono inf_le_left\n\n"}
{"name":"BoxIntegral.IntegrationParams.toFilter_neBot","module":"Mathlib.Analysis.BoxIntegral.Partition.Filter","initialProofState":"ι : Type u_1\ninst✝ : Fintype ι\nl : BoxIntegral.IntegrationParams\nI : BoxIntegral.Box ι\n⊢ (l.toFilter I).NeBot","decl":"instance toFilter_neBot (l : IntegrationParams) (I : Box ι) : (l.toFilter I).NeBot :=\n  (l.toFilterDistortion_neBot I).mono <| le_iSup _ _\n\n"}
{"name":"BoxIntegral.IntegrationParams.toFilteriUnion_neBot","module":"Mathlib.Analysis.BoxIntegral.Partition.Filter","initialProofState":"ι : Type u_1\ninst✝ : Fintype ι\nl : BoxIntegral.IntegrationParams\nI : BoxIntegral.Box ι\nπ₀ : BoxIntegral.Prepartition I\n⊢ (BoxIntegral.IntegrationParams.toFilteriUnion I π₀).NeBot","decl":"instance toFilteriUnion_neBot (l : IntegrationParams) (I : Box ι) (π₀ : Prepartition I) :\n    (l.toFilteriUnion I π₀).NeBot :=\n  (l.toFilterDistortioniUnion_neBot' I π₀).mono <|\n    le_iSup (fun c => l.toFilterDistortioniUnion I c π₀) _\n\n"}
{"name":"BoxIntegral.IntegrationParams.eventually_isPartition","module":"Mathlib.Analysis.BoxIntegral.Partition.Filter","initialProofState":"ι : Type u_1\ninst✝ : Fintype ι\nl : BoxIntegral.IntegrationParams\nI : BoxIntegral.Box ι\n⊢ Filter.Eventually (fun π => π.IsPartition) (BoxIntegral.IntegrationParams.toFilteriUnion I Top.top)","decl":"theorem eventually_isPartition (l : IntegrationParams) (I : Box ι) :\n    ∀ᶠ π in l.toFilteriUnion I ⊤, TaggedPrepartition.IsPartition π :=\n  eventually_iSup.2 fun _ =>\n    eventually_inf_principal.2 <|\n      Eventually.of_forall fun π h =>\n        π.isPartition_iff_iUnion_eq.2 (h.trans Prepartition.iUnion_top)\n\n"}
