{"name":"BoxIntegral.IntegrationParams.ext_iff","module":"Mathlib.Analysis.BoxIntegral.Partition.Filter","initialProofState":"x y : BoxIntegral.IntegrationParams\n‚ä¢ Iff (Eq x y) (And (Eq x.bRiemann y.bRiemann) (And (Eq x.bHenstock y.bHenstock) (Eq x.bDistortion y.bDistortion)))","decl":"/-- An `IntegrationParams` is a structure holding 3 boolean values used to define a filter to be\nused in the definition of a box-integrable function.\n\n* `bRiemann`: the value `true` means that the filter corresponds to a Riemann-style integral, i.e.\n  in the definition of integrability we require a constant upper estimate `r` on the size of boxes\n  of a tagged partition; the value `false` means that the estimate may depend on the position of the\n  tag.\n\n* `bHenstock`: the value `true` means that we require that each tag belongs to its own closed box;\n  the value `false` means that we only require that tags belong to the ambient box.\n\n* `bDistortion`: the value `true` means that `r` can depend on the maximal ratio of sides of the\n  same box of a partition. Presence of this case makes quite a few proofs harder but we can prove\n  the divergence theorem only for the filter `BoxIntegral.IntegrationParams.GP = ‚ä• =\n  {bRiemann := false, bHenstock := true, bDistortion := true}`.\n-/\n@[ext]\nstructure IntegrationParams : Type where\n  (bRiemann bHenstock bDistortion : Bool)\n\n"}
{"name":"BoxIntegral.IntegrationParams.mk.sizeOf_spec","module":"Mathlib.Analysis.BoxIntegral.Partition.Filter","initialProofState":"bRiemann bHenstock bDistortion : Bool\n‚ä¢ Eq (SizeOf.sizeOf { bRiemann := bRiemann, bHenstock := bHenstock, bDistortion := bDistortion }) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf bRiemann)) (SizeOf.sizeOf bHenstock)) (SizeOf.sizeOf bDistortion))","decl":"/-- An `IntegrationParams` is a structure holding 3 boolean values used to define a filter to be\nused in the definition of a box-integrable function.\n\n* `bRiemann`: the value `true` means that the filter corresponds to a Riemann-style integral, i.e.\n  in the definition of integrability we require a constant upper estimate `r` on the size of boxes\n  of a tagged partition; the value `false` means that the estimate may depend on the position of the\n  tag.\n\n* `bHenstock`: the value `true` means that we require that each tag belongs to its own closed box;\n  the value `false` means that we only require that tags belong to the ambient box.\n\n* `bDistortion`: the value `true` means that `r` can depend on the maximal ratio of sides of the\n  same box of a partition. Presence of this case makes quite a few proofs harder but we can prove\n  the divergence theorem only for the filter `BoxIntegral.IntegrationParams.GP = ‚ä• =\n  {bRiemann := false, bHenstock := true, bDistortion := true}`.\n-/\n@[ext]\nstructure IntegrationParams : Type where\n  (bRiemann bHenstock bDistortion : Bool)\n\n"}
{"name":"BoxIntegral.IntegrationParams.mk.inj","module":"Mathlib.Analysis.BoxIntegral.Partition.Filter","initialProofState":"bRiemann‚úù bHenstock‚úù bDistortion‚úù bRiemann bHenstock bDistortion : Bool\nx‚úù : Eq { bRiemann := bRiemann‚úù, bHenstock := bHenstock‚úù, bDistortion := bDistortion‚úù } { bRiemann := bRiemann, bHenstock := bHenstock, bDistortion := bDistortion }\n‚ä¢ And (Eq bRiemann‚úù bRiemann) (And (Eq bHenstock‚úù bHenstock) (Eq bDistortion‚úù bDistortion))","decl":"/-- An `IntegrationParams` is a structure holding 3 boolean values used to define a filter to be\nused in the definition of a box-integrable function.\n\n* `bRiemann`: the value `true` means that the filter corresponds to a Riemann-style integral, i.e.\n  in the definition of integrability we require a constant upper estimate `r` on the size of boxes\n  of a tagged partition; the value `false` means that the estimate may depend on the position of the\n  tag.\n\n* `bHenstock`: the value `true` means that we require that each tag belongs to its own closed box;\n  the value `false` means that we only require that tags belong to the ambient box.\n\n* `bDistortion`: the value `true` means that `r` can depend on the maximal ratio of sides of the\n  same box of a partition. Presence of this case makes quite a few proofs harder but we can prove\n  the divergence theorem only for the filter `BoxIntegral.IntegrationParams.GP = ‚ä• =\n  {bRiemann := false, bHenstock := true, bDistortion := true}`.\n-/\n@[ext]\nstructure IntegrationParams : Type where\n  (bRiemann bHenstock bDistortion : Bool)\n\n"}
{"name":"BoxIntegral.IntegrationParams.ext","module":"Mathlib.Analysis.BoxIntegral.Partition.Filter","initialProofState":"x y : BoxIntegral.IntegrationParams\nbRiemann : Eq x.bRiemann y.bRiemann\nbHenstock : Eq x.bHenstock y.bHenstock\nbDistortion : Eq x.bDistortion y.bDistortion\n‚ä¢ Eq x y","decl":"/-- An `IntegrationParams` is a structure holding 3 boolean values used to define a filter to be\nused in the definition of a box-integrable function.\n\n* `bRiemann`: the value `true` means that the filter corresponds to a Riemann-style integral, i.e.\n  in the definition of integrability we require a constant upper estimate `r` on the size of boxes\n  of a tagged partition; the value `false` means that the estimate may depend on the position of the\n  tag.\n\n* `bHenstock`: the value `true` means that we require that each tag belongs to its own closed box;\n  the value `false` means that we only require that tags belong to the ambient box.\n\n* `bDistortion`: the value `true` means that `r` can depend on the maximal ratio of sides of the\n  same box of a partition. Presence of this case makes quite a few proofs harder but we can prove\n  the divergence theorem only for the filter `BoxIntegral.IntegrationParams.GP = ‚ä• =\n  {bRiemann := false, bHenstock := true, bDistortion := true}`.\n-/\n@[ext]\nstructure IntegrationParams : Type where\n  (bRiemann bHenstock bDistortion : Bool)\n\n"}
{"name":"BoxIntegral.IntegrationParams.mk.injEq","module":"Mathlib.Analysis.BoxIntegral.Partition.Filter","initialProofState":"bRiemann‚úù bHenstock‚úù bDistortion‚úù bRiemann bHenstock bDistortion : Bool\n‚ä¢ Eq (Eq { bRiemann := bRiemann‚úù, bHenstock := bHenstock‚úù, bDistortion := bDistortion‚úù } { bRiemann := bRiemann, bHenstock := bHenstock, bDistortion := bDistortion }) (And (Eq bRiemann‚úù bRiemann) (And (Eq bHenstock‚úù bHenstock) (Eq bDistortion‚úù bDistortion)))","decl":"/-- An `IntegrationParams` is a structure holding 3 boolean values used to define a filter to be\nused in the definition of a box-integrable function.\n\n* `bRiemann`: the value `true` means that the filter corresponds to a Riemann-style integral, i.e.\n  in the definition of integrability we require a constant upper estimate `r` on the size of boxes\n  of a tagged partition; the value `false` means that the estimate may depend on the position of the\n  tag.\n\n* `bHenstock`: the value `true` means that we require that each tag belongs to its own closed box;\n  the value `false` means that we only require that tags belong to the ambient box.\n\n* `bDistortion`: the value `true` means that `r` can depend on the maximal ratio of sides of the\n  same box of a partition. Presence of this case makes quite a few proofs harder but we can prove\n  the divergence theorem only for the filter `BoxIntegral.IntegrationParams.GP = ‚ä• =\n  {bRiemann := false, bHenstock := true, bDistortion := true}`.\n-/\n@[ext]\nstructure IntegrationParams : Type where\n  (bRiemann bHenstock bDistortion : Bool)\n\n"}
{"name":"BoxIntegral.IntegrationParams.henstock_le_riemann","module":"Mathlib.Analysis.BoxIntegral.Partition.Filter","initialProofState":"‚ä¢ LE.le BoxIntegral.IntegrationParams.Henstock BoxIntegral.IntegrationParams.Riemann","decl":"theorem henstock_le_riemann : Henstock ‚â§ Riemann := by trivial\n\n"}
{"name":"BoxIntegral.IntegrationParams.henstock_le_mcShane","module":"Mathlib.Analysis.BoxIntegral.Partition.Filter","initialProofState":"‚ä¢ LE.le BoxIntegral.IntegrationParams.Henstock BoxIntegral.IntegrationParams.McShane","decl":"theorem henstock_le_mcShane : Henstock ‚â§ McShane := by trivial\n\n"}
{"name":"BoxIntegral.IntegrationParams.gp_le","module":"Mathlib.Analysis.BoxIntegral.Partition.Filter","initialProofState":"l : BoxIntegral.IntegrationParams\n‚ä¢ LE.le BoxIntegral.IntegrationParams.GP l","decl":"theorem gp_le : GP ‚â§ l :=\n  bot_le\n\n"}
{"name":"BoxIntegral.IntegrationParams.MemBaseSet.exists_compl","module":"Mathlib.Analysis.BoxIntegral.Partition.Filter","initialProofState":"Œπ : Type u_1\ninst‚úù : Fintype Œπ\nl : BoxIntegral.IntegrationParams\nI : BoxIntegral.Box Œπ\nc : NNReal\nr : (Œπ ‚Üí Real) ‚Üí ‚Üë(Set.Ioi 0)\nœÄ : BoxIntegral.TaggedPrepartition I\nself : l.MemBaseSet I c r œÄ\na‚úù : Eq l.bDistortion Bool.true\n‚ä¢ Exists fun œÄ' => And (Eq œÄ'.iUnion (SDiff.sdiff (‚ÜëI) œÄ.iUnion)) (LE.le œÄ'.distortion c)","decl":"/-- The predicate corresponding to a base set of the filter defined by an\n`IntegrationParams`. It says that\n\n* if `l.bHenstock`, then `œÄ` is a Henstock prepartition, i.e. each tag belongs to the corresponding\n  closed box;\n* `œÄ` is subordinate to `r`;\n* if `l.bDistortion`, then the distortion of each box in `œÄ` is less than or equal to `c`;\n* if `l.bDistortion`, then there exists a prepartition `œÄ'` with distortion `‚â§ c` that covers\n  exactly `I \\ œÄ.iUnion`.\n\nThe last condition is automatically verified for partitions, and is used in the proof of the\nSacks-Henstock inequality to compare two prepartitions covering the same part of the box.\n\nIt is also automatically satisfied for any `c > 1`, see TODO section of the module docstring for\ndetails. -/\nstructure MemBaseSet (l : IntegrationParams) (I : Box Œπ) (c : ‚Ñù‚â•0) (r : (Œπ ‚Üí ‚Ñù) ‚Üí Ioi (0 : ‚Ñù))\n    (œÄ : TaggedPrepartition I) : Prop where\n  protected isSubordinate : œÄ.IsSubordinate r\n  protected isHenstock : l.bHenstock ‚Üí œÄ.IsHenstock\n  protected distortion_le : l.bDistortion ‚Üí œÄ.distortion ‚â§ c\n  protected exists_compl : l.bDistortion ‚Üí ‚àÉ œÄ' : Prepartition I,\n    œÄ'.iUnion = ‚ÜëI \\ œÄ.iUnion ‚àß œÄ'.distortion ‚â§ c\n\n"}
{"name":"BoxIntegral.IntegrationParams.MemBaseSet.distortion_le","module":"Mathlib.Analysis.BoxIntegral.Partition.Filter","initialProofState":"Œπ : Type u_1\ninst‚úù : Fintype Œπ\nl : BoxIntegral.IntegrationParams\nI : BoxIntegral.Box Œπ\nc : NNReal\nr : (Œπ ‚Üí Real) ‚Üí ‚Üë(Set.Ioi 0)\nœÄ : BoxIntegral.TaggedPrepartition I\nself : l.MemBaseSet I c r œÄ\na‚úù : Eq l.bDistortion Bool.true\n‚ä¢ LE.le œÄ.distortion c","decl":"/-- The predicate corresponding to a base set of the filter defined by an\n`IntegrationParams`. It says that\n\n* if `l.bHenstock`, then `œÄ` is a Henstock prepartition, i.e. each tag belongs to the corresponding\n  closed box;\n* `œÄ` is subordinate to `r`;\n* if `l.bDistortion`, then the distortion of each box in `œÄ` is less than or equal to `c`;\n* if `l.bDistortion`, then there exists a prepartition `œÄ'` with distortion `‚â§ c` that covers\n  exactly `I \\ œÄ.iUnion`.\n\nThe last condition is automatically verified for partitions, and is used in the proof of the\nSacks-Henstock inequality to compare two prepartitions covering the same part of the box.\n\nIt is also automatically satisfied for any `c > 1`, see TODO section of the module docstring for\ndetails. -/\nstructure MemBaseSet (l : IntegrationParams) (I : Box Œπ) (c : ‚Ñù‚â•0) (r : (Œπ ‚Üí ‚Ñù) ‚Üí Ioi (0 : ‚Ñù))\n    (œÄ : TaggedPrepartition I) : Prop where\n  protected isSubordinate : œÄ.IsSubordinate r\n  protected isHenstock : l.bHenstock ‚Üí œÄ.IsHenstock\n  protected distortion_le : l.bDistortion ‚Üí œÄ.distortion ‚â§ c\n  protected exists_compl : l.bDistortion ‚Üí ‚àÉ œÄ' : Prepartition I,\n    œÄ'.iUnion = ‚ÜëI \\ œÄ.iUnion ‚àß œÄ'.distortion ‚â§ c\n\n"}
{"name":"BoxIntegral.IntegrationParams.MemBaseSet.isSubordinate","module":"Mathlib.Analysis.BoxIntegral.Partition.Filter","initialProofState":"Œπ : Type u_1\ninst‚úù : Fintype Œπ\nl : BoxIntegral.IntegrationParams\nI : BoxIntegral.Box Œπ\nc : NNReal\nr : (Œπ ‚Üí Real) ‚Üí ‚Üë(Set.Ioi 0)\nœÄ : BoxIntegral.TaggedPrepartition I\nself : l.MemBaseSet I c r œÄ\n‚ä¢ œÄ.IsSubordinate r","decl":"/-- The predicate corresponding to a base set of the filter defined by an\n`IntegrationParams`. It says that\n\n* if `l.bHenstock`, then `œÄ` is a Henstock prepartition, i.e. each tag belongs to the corresponding\n  closed box;\n* `œÄ` is subordinate to `r`;\n* if `l.bDistortion`, then the distortion of each box in `œÄ` is less than or equal to `c`;\n* if `l.bDistortion`, then there exists a prepartition `œÄ'` with distortion `‚â§ c` that covers\n  exactly `I \\ œÄ.iUnion`.\n\nThe last condition is automatically verified for partitions, and is used in the proof of the\nSacks-Henstock inequality to compare two prepartitions covering the same part of the box.\n\nIt is also automatically satisfied for any `c > 1`, see TODO section of the module docstring for\ndetails. -/\nstructure MemBaseSet (l : IntegrationParams) (I : Box Œπ) (c : ‚Ñù‚â•0) (r : (Œπ ‚Üí ‚Ñù) ‚Üí Ioi (0 : ‚Ñù))\n    (œÄ : TaggedPrepartition I) : Prop where\n  protected isSubordinate : œÄ.IsSubordinate r\n  protected isHenstock : l.bHenstock ‚Üí œÄ.IsHenstock\n  protected distortion_le : l.bDistortion ‚Üí œÄ.distortion ‚â§ c\n  protected exists_compl : l.bDistortion ‚Üí ‚àÉ œÄ' : Prepartition I,\n    œÄ'.iUnion = ‚ÜëI \\ œÄ.iUnion ‚àß œÄ'.distortion ‚â§ c\n\n"}
{"name":"BoxIntegral.IntegrationParams.MemBaseSet.isHenstock","module":"Mathlib.Analysis.BoxIntegral.Partition.Filter","initialProofState":"Œπ : Type u_1\ninst‚úù : Fintype Œπ\nl : BoxIntegral.IntegrationParams\nI : BoxIntegral.Box Œπ\nc : NNReal\nr : (Œπ ‚Üí Real) ‚Üí ‚Üë(Set.Ioi 0)\nœÄ : BoxIntegral.TaggedPrepartition I\nself : l.MemBaseSet I c r œÄ\na‚úù : Eq l.bHenstock Bool.true\n‚ä¢ œÄ.IsHenstock","decl":"/-- The predicate corresponding to a base set of the filter defined by an\n`IntegrationParams`. It says that\n\n* if `l.bHenstock`, then `œÄ` is a Henstock prepartition, i.e. each tag belongs to the corresponding\n  closed box;\n* `œÄ` is subordinate to `r`;\n* if `l.bDistortion`, then the distortion of each box in `œÄ` is less than or equal to `c`;\n* if `l.bDistortion`, then there exists a prepartition `œÄ'` with distortion `‚â§ c` that covers\n  exactly `I \\ œÄ.iUnion`.\n\nThe last condition is automatically verified for partitions, and is used in the proof of the\nSacks-Henstock inequality to compare two prepartitions covering the same part of the box.\n\nIt is also automatically satisfied for any `c > 1`, see TODO section of the module docstring for\ndetails. -/\nstructure MemBaseSet (l : IntegrationParams) (I : Box Œπ) (c : ‚Ñù‚â•0) (r : (Œπ ‚Üí ‚Ñù) ‚Üí Ioi (0 : ‚Ñù))\n    (œÄ : TaggedPrepartition I) : Prop where\n  protected isSubordinate : œÄ.IsSubordinate r\n  protected isHenstock : l.bHenstock ‚Üí œÄ.IsHenstock\n  protected distortion_le : l.bDistortion ‚Üí œÄ.distortion ‚â§ c\n  protected exists_compl : l.bDistortion ‚Üí ‚àÉ œÄ' : Prepartition I,\n    œÄ'.iUnion = ‚ÜëI \\ œÄ.iUnion ‚àß œÄ'.distortion ‚â§ c\n\n"}
{"name":"BoxIntegral.IntegrationParams.rCond_of_bRiemann_eq_false","module":"Mathlib.Analysis.BoxIntegral.Partition.Filter","initialProofState":"Œπ : Type u_2\nl : BoxIntegral.IntegrationParams\nhl : Eq l.bRiemann Bool.false\nr : (Œπ ‚Üí Real) ‚Üí ‚Üë(Set.Ioi 0)\n‚ä¢ l.RCond r","decl":"theorem rCond_of_bRiemann_eq_false {Œπ} (l : IntegrationParams) (hl : l.bRiemann = false)\n    {r : (Œπ ‚Üí ‚Ñù) ‚Üí Ioi (0 : ‚Ñù)} : l.RCond r := by\n  simp [RCond, hl]\n\n"}
{"name":"BoxIntegral.IntegrationParams.toFilter_inf_iUnion_eq","module":"Mathlib.Analysis.BoxIntegral.Partition.Filter","initialProofState":"Œπ : Type u_1\ninst‚úù : Fintype Œπ\nl : BoxIntegral.IntegrationParams\nI : BoxIntegral.Box Œπ\nœÄ‚ÇÄ : BoxIntegral.Prepartition I\n‚ä¢ Eq (Min.min (l.toFilter I) (Filter.principal (setOf fun œÄ => Eq œÄ.iUnion œÄ‚ÇÄ.iUnion))) (BoxIntegral.IntegrationParams.toFilteriUnion I œÄ‚ÇÄ)","decl":"theorem toFilter_inf_iUnion_eq (l : IntegrationParams) (I : Box Œπ) (œÄ‚ÇÄ : Prepartition I) :\n    l.toFilter I ‚äì ùìü { œÄ | œÄ.iUnion = œÄ‚ÇÄ.iUnion } = l.toFilteriUnion I œÄ‚ÇÄ :=\n  (iSup_inf_principal _ _).symm\n\n"}
{"name":"BoxIntegral.IntegrationParams.MemBaseSet.mono'","module":"Mathlib.Analysis.BoxIntegral.Partition.Filter","initialProofState":"Œπ : Type u_1\ninst‚úù : Fintype Œπ\nI : BoxIntegral.Box Œπ\nc‚ÇÅ c‚ÇÇ : NNReal\nl‚ÇÅ l‚ÇÇ : BoxIntegral.IntegrationParams\nr‚ÇÅ r‚ÇÇ : (Œπ ‚Üí Real) ‚Üí ‚Üë(Set.Ioi 0)\nœÄ : BoxIntegral.TaggedPrepartition I\nh : LE.le l‚ÇÅ l‚ÇÇ\nhc : LE.le c‚ÇÅ c‚ÇÇ\nhr : ‚àÄ (J : BoxIntegral.Box Œπ), Membership.mem œÄ J ‚Üí LE.le (r‚ÇÅ (œÄ.tag J)) (r‚ÇÇ (œÄ.tag J))\nhœÄ : l‚ÇÅ.MemBaseSet I c‚ÇÅ r‚ÇÅ œÄ\n‚ä¢ l‚ÇÇ.MemBaseSet I c‚ÇÇ r‚ÇÇ œÄ","decl":"variable (I) in\ntheorem MemBaseSet.mono' (h : l‚ÇÅ ‚â§ l‚ÇÇ) (hc : c‚ÇÅ ‚â§ c‚ÇÇ)\n    (hr : ‚àÄ J ‚àà œÄ, r‚ÇÅ (œÄ.tag J) ‚â§ r‚ÇÇ (œÄ.tag J)) (hœÄ : l‚ÇÅ.MemBaseSet I c‚ÇÅ r‚ÇÅ œÄ) :\n    l‚ÇÇ.MemBaseSet I c‚ÇÇ r‚ÇÇ œÄ :=\n  ‚ü®hœÄ.1.mono' hr, fun h‚ÇÇ => hœÄ.2 (le_iff_imp.1 h.2.1 h‚ÇÇ),\n    fun hD => (hœÄ.3 (le_iff_imp.1 h.2.2 hD)).trans hc,\n    fun hD => (hœÄ.4 (le_iff_imp.1 h.2.2 hD)).imp fun _ hœÄ => ‚ü®hœÄ.1, hœÄ.2.trans hc‚ü©‚ü©\n\n"}
{"name":"BoxIntegral.IntegrationParams.MemBaseSet.mono","module":"Mathlib.Analysis.BoxIntegral.Partition.Filter","initialProofState":"Œπ : Type u_1\ninst‚úù : Fintype Œπ\nI : BoxIntegral.Box Œπ\nc‚ÇÅ c‚ÇÇ : NNReal\nl‚ÇÅ l‚ÇÇ : BoxIntegral.IntegrationParams\nr‚ÇÅ r‚ÇÇ : (Œπ ‚Üí Real) ‚Üí ‚Üë(Set.Ioi 0)\nœÄ : BoxIntegral.TaggedPrepartition I\nh : LE.le l‚ÇÅ l‚ÇÇ\nhc : LE.le c‚ÇÅ c‚ÇÇ\nhr : ‚àÄ (x : Œπ ‚Üí Real), Membership.mem (BoxIntegral.Box.Icc I) x ‚Üí LE.le (r‚ÇÅ x) (r‚ÇÇ x)\nhœÄ : l‚ÇÅ.MemBaseSet I c‚ÇÅ r‚ÇÅ œÄ\n‚ä¢ l‚ÇÇ.MemBaseSet I c‚ÇÇ r‚ÇÇ œÄ","decl":"variable (I) in\n@[mono]\ntheorem MemBaseSet.mono (h : l‚ÇÅ ‚â§ l‚ÇÇ) (hc : c‚ÇÅ ‚â§ c‚ÇÇ)\n    (hr : ‚àÄ x ‚àà Box.Icc I, r‚ÇÅ x ‚â§ r‚ÇÇ x) (hœÄ : l‚ÇÅ.MemBaseSet I c‚ÇÅ r‚ÇÅ œÄ) : l‚ÇÇ.MemBaseSet I c‚ÇÇ r‚ÇÇ œÄ :=\n  hœÄ.mono' I h hc fun J _ => hr _ <| œÄ.tag_mem_Icc J\n\n"}
{"name":"BoxIntegral.IntegrationParams.MemBaseSet.exists_common_compl","module":"Mathlib.Analysis.BoxIntegral.Partition.Filter","initialProofState":"Œπ : Type u_1\ninst‚úù : Fintype Œπ\nI : BoxIntegral.Box Œπ\nc‚ÇÅ c‚ÇÇ : NNReal\nl : BoxIntegral.IntegrationParams\nr‚ÇÅ r‚ÇÇ : (Œπ ‚Üí Real) ‚Üí ‚Üë(Set.Ioi 0)\nœÄ‚ÇÅ œÄ‚ÇÇ : BoxIntegral.TaggedPrepartition I\nh‚ÇÅ : l.MemBaseSet I c‚ÇÅ r‚ÇÅ œÄ‚ÇÅ\nh‚ÇÇ : l.MemBaseSet I c‚ÇÇ r‚ÇÇ œÄ‚ÇÇ\nhU : Eq œÄ‚ÇÅ.iUnion œÄ‚ÇÇ.iUnion\n‚ä¢ Exists fun œÄ => And (Eq œÄ.iUnion (SDiff.sdiff (‚ÜëI) œÄ‚ÇÅ.iUnion)) (And (Eq l.bDistortion Bool.true ‚Üí LE.le œÄ.distortion c‚ÇÅ) (Eq l.bDistortion Bool.true ‚Üí LE.le œÄ.distortion c‚ÇÇ))","decl":"theorem MemBaseSet.exists_common_compl\n    (h‚ÇÅ : l.MemBaseSet I c‚ÇÅ r‚ÇÅ œÄ‚ÇÅ) (h‚ÇÇ : l.MemBaseSet I c‚ÇÇ r‚ÇÇ œÄ‚ÇÇ)\n    (hU : œÄ‚ÇÅ.iUnion = œÄ‚ÇÇ.iUnion) :\n    ‚àÉ œÄ : Prepartition I, œÄ.iUnion = ‚ÜëI \\ œÄ‚ÇÅ.iUnion ‚àß\n      (l.bDistortion ‚Üí œÄ.distortion ‚â§ c‚ÇÅ) ‚àß (l.bDistortion ‚Üí œÄ.distortion ‚â§ c‚ÇÇ) := by\n  wlog hc : c‚ÇÅ ‚â§ c‚ÇÇ with H\n  ¬∑ simpa [hU, _root_.and_comm] using\n      @H _ _ I c‚ÇÇ c‚ÇÅ l r‚ÇÇ r‚ÇÅ œÄ‚ÇÇ œÄ‚ÇÅ h‚ÇÇ h‚ÇÅ hU.symm (le_of_not_le hc)\n  by_cases hD : (l.bDistortion : Prop)\n  ¬∑ rcases h‚ÇÅ.4 hD with ‚ü®œÄ, hœÄU, hœÄc‚ü©\n    exact ‚ü®œÄ, hœÄU, fun _ => hœÄc, fun _ => hœÄc.trans hc‚ü©\n  ¬∑ exact ‚ü®œÄ‚ÇÅ.toPrepartition.compl, œÄ‚ÇÅ.toPrepartition.iUnion_compl,\n      fun h => (hD h).elim, fun h => (hD h).elim‚ü©\n\n"}
{"name":"BoxIntegral.IntegrationParams.MemBaseSet.unionComplToSubordinate","module":"Mathlib.Analysis.BoxIntegral.Partition.Filter","initialProofState":"Œπ : Type u_1\ninst‚úù : Fintype Œπ\nI : BoxIntegral.Box Œπ\nc : NNReal\nl : BoxIntegral.IntegrationParams\nr‚ÇÅ r‚ÇÇ : (Œπ ‚Üí Real) ‚Üí ‚Üë(Set.Ioi 0)\nœÄ‚ÇÅ : BoxIntegral.TaggedPrepartition I\nhœÄ‚ÇÅ : l.MemBaseSet I c r‚ÇÅ œÄ‚ÇÅ\nhle : ‚àÄ (x : Œπ ‚Üí Real), Membership.mem (BoxIntegral.Box.Icc I) x ‚Üí LE.le (r‚ÇÇ x) (r‚ÇÅ x)\nœÄ‚ÇÇ : BoxIntegral.Prepartition I\nhU : Eq œÄ‚ÇÇ.iUnion (SDiff.sdiff (‚ÜëI) œÄ‚ÇÅ.iUnion)\nhc : Eq l.bDistortion Bool.true ‚Üí LE.le œÄ‚ÇÇ.distortion c\n‚ä¢ l.MemBaseSet I c r‚ÇÅ (œÄ‚ÇÅ.unionComplToSubordinate œÄ‚ÇÇ hU r‚ÇÇ)","decl":"protected theorem MemBaseSet.unionComplToSubordinate (hœÄ‚ÇÅ : l.MemBaseSet I c r‚ÇÅ œÄ‚ÇÅ)\n    (hle : ‚àÄ x ‚àà Box.Icc I, r‚ÇÇ x ‚â§ r‚ÇÅ x) {œÄ‚ÇÇ : Prepartition I} (hU : œÄ‚ÇÇ.iUnion = ‚ÜëI \\ œÄ‚ÇÅ.iUnion)\n    (hc : l.bDistortion ‚Üí œÄ‚ÇÇ.distortion ‚â§ c) :\n    l.MemBaseSet I c r‚ÇÅ (œÄ‚ÇÅ.unionComplToSubordinate œÄ‚ÇÇ hU r‚ÇÇ) :=\n  ‚ü®hœÄ‚ÇÅ.1.disjUnion ((œÄ‚ÇÇ.isSubordinate_toSubordinate r‚ÇÇ).mono hle) _,\n    fun h => (hœÄ‚ÇÅ.2 h).disjUnion (œÄ‚ÇÇ.isHenstock_toSubordinate _) _,\n    fun h => (distortion_unionComplToSubordinate _ _ _ _).trans_le (max_le (hœÄ‚ÇÅ.3 h) (hc h)),\n    fun _ => ‚ü®‚ä•, by simp‚ü©‚ü©\n\n"}
{"name":"BoxIntegral.IntegrationParams.MemBaseSet.filter","module":"Mathlib.Analysis.BoxIntegral.Partition.Filter","initialProofState":"Œπ : Type u_1\ninst‚úù : Fintype Œπ\nI : BoxIntegral.Box Œπ\nc : NNReal\nl : BoxIntegral.IntegrationParams\nœÄ : BoxIntegral.TaggedPrepartition I\nr : (Œπ ‚Üí Real) ‚Üí ‚Üë(Set.Ioi 0)\nhœÄ : l.MemBaseSet I c r œÄ\np : BoxIntegral.Box Œπ ‚Üí Prop\n‚ä¢ l.MemBaseSet I c r (œÄ.filter p)","decl":"protected theorem MemBaseSet.filter (hœÄ : l.MemBaseSet I c r œÄ) (p : Box Œπ ‚Üí Prop) :\n    l.MemBaseSet I c r (œÄ.filter p) := by\n  classical\n  refine ‚ü®fun J hJ => hœÄ.1 J (œÄ.mem_filter.1 hJ).1, fun hH J hJ => hœÄ.2 hH J (œÄ.mem_filter.1 hJ).1,\n    fun hD => (distortion_filter_le _ _).trans (hœÄ.3 hD), fun hD => ?_‚ü©\n  rcases hœÄ.4 hD with ‚ü®œÄ‚ÇÅ, hœÄ‚ÇÅU, hc‚ü©\n  set œÄ‚ÇÇ := œÄ.filter fun J => ¬¨p J\n  have : Disjoint œÄ‚ÇÅ.iUnion œÄ‚ÇÇ.iUnion := by\n    simpa [œÄ‚ÇÇ, hœÄ‚ÇÅU] using disjoint_sdiff_self_left.mono_right sdiff_le\n  refine ‚ü®œÄ‚ÇÅ.disjUnion œÄ‚ÇÇ.toPrepartition this, ?_, ?_‚ü©\n  ¬∑ suffices ‚ÜëI \\ œÄ.iUnion ‚à™ œÄ.iUnion \\ (œÄ.filter p).iUnion = ‚ÜëI \\ (œÄ.filter p).iUnion by\n      simp [œÄ‚ÇÇ, *]\n    have h : (œÄ.filter p).iUnion ‚äÜ œÄ.iUnion :=\n      biUnion_subset_biUnion_left (Finset.filter_subset _ _)\n    ext x\n    fconstructor\n    ¬∑ rintro (‚ü®hxI, hxœÄ‚ü© | ‚ü®hxœÄ, hxp‚ü©)\n      exacts [‚ü®hxI, mt (@h x) hxœÄ‚ü©, ‚ü®œÄ.iUnion_subset hxœÄ, hxp‚ü©]\n    ¬∑ rintro ‚ü®hxI, hxp‚ü©\n      by_cases hxœÄ : x ‚àà œÄ.iUnion\n      exacts [Or.inr ‚ü®hxœÄ, hxp‚ü©, Or.inl ‚ü®hxI, hxœÄ‚ü©]\n  ¬∑ have : (œÄ.filter fun J => ¬¨p J).distortion ‚â§ c := (distortion_filter_le _ _).trans (hœÄ.3 hD)\n    simpa [hc]\n\n"}
{"name":"BoxIntegral.IntegrationParams.biUnionTagged_memBaseSet","module":"Mathlib.Analysis.BoxIntegral.Partition.Filter","initialProofState":"Œπ : Type u_1\ninst‚úù : Fintype Œπ\nI : BoxIntegral.Box Œπ\nc : NNReal\nl : BoxIntegral.IntegrationParams\nr : (Œπ ‚Üí Real) ‚Üí ‚Üë(Set.Ioi 0)\nœÄ : BoxIntegral.Prepartition I\nœÄi : (J : BoxIntegral.Box Œπ) ‚Üí BoxIntegral.TaggedPrepartition J\nh : ‚àÄ (J : BoxIntegral.Box Œπ), Membership.mem œÄ J ‚Üí l.MemBaseSet J c r (œÄi J)\nhp : ‚àÄ (J : BoxIntegral.Box Œπ), Membership.mem œÄ J ‚Üí (œÄi J).IsPartition\nhc : Eq l.bDistortion Bool.true ‚Üí LE.le œÄ.compl.distortion c\n‚ä¢ l.MemBaseSet I c r (œÄ.biUnionTagged œÄi)","decl":"theorem biUnionTagged_memBaseSet {œÄ : Prepartition I} {œÄi : ‚àÄ J, TaggedPrepartition J}\n    (h : ‚àÄ J ‚àà œÄ, l.MemBaseSet J c r (œÄi J)) (hp : ‚àÄ J ‚àà œÄ, (œÄi J).IsPartition)\n    (hc : l.bDistortion ‚Üí œÄ.compl.distortion ‚â§ c) : l.MemBaseSet I c r (œÄ.biUnionTagged œÄi) := by\n  refine ‚ü®TaggedPrepartition.isSubordinate_biUnionTagged.2 fun J hJ => (h J hJ).1,\n    fun hH => TaggedPrepartition.isHenstock_biUnionTagged.2 fun J hJ => (h J hJ).2 hH,\n    fun hD => ?_, fun hD => ?_‚ü©\n  ¬∑ rw [Prepartition.distortion_biUnionTagged, Finset.sup_le_iff]\n    exact fun J hJ => (h J hJ).3 hD\n  ¬∑ refine ‚ü®_, ?_, hc hD‚ü©\n    rw [œÄ.iUnion_compl, ‚Üê œÄ.iUnion_biUnion_partition hp]\n    rfl\n\n"}
{"name":"BoxIntegral.IntegrationParams.RCond.mono","module":"Mathlib.Analysis.BoxIntegral.Partition.Filter","initialProofState":"l‚ÇÅ l‚ÇÇ : BoxIntegral.IntegrationParams\nŒπ : Type u_2\nr : (Œπ ‚Üí Real) ‚Üí ‚Üë(Set.Ioi 0)\nh : LE.le l‚ÇÅ l‚ÇÇ\nhr : l‚ÇÇ.RCond r\n‚ä¢ l‚ÇÅ.RCond r","decl":"@[mono]\ntheorem RCond.mono {Œπ : Type*} {r : (Œπ ‚Üí ‚Ñù) ‚Üí Ioi (0 : ‚Ñù)} (h : l‚ÇÅ ‚â§ l‚ÇÇ) (hr : l‚ÇÇ.RCond r) :\n    l‚ÇÅ.RCond r :=\n  fun hR => hr (le_iff_imp.1 h.1 hR)\n\n"}
{"name":"BoxIntegral.IntegrationParams.RCond.min","module":"Mathlib.Analysis.BoxIntegral.Partition.Filter","initialProofState":"l : BoxIntegral.IntegrationParams\nŒπ : Type u_2\nr‚ÇÅ r‚ÇÇ : (Œπ ‚Üí Real) ‚Üí ‚Üë(Set.Ioi 0)\nh‚ÇÅ : l.RCond r‚ÇÅ\nh‚ÇÇ : l.RCond r‚ÇÇ\n‚ä¢ l.RCond fun x => Min.min (r‚ÇÅ x) (r‚ÇÇ x)","decl":"nonrec theorem RCond.min {Œπ : Type*} {r‚ÇÅ r‚ÇÇ : (Œπ ‚Üí ‚Ñù) ‚Üí Ioi (0 : ‚Ñù)} (h‚ÇÅ : l.RCond r‚ÇÅ)\n    (h‚ÇÇ : l.RCond r‚ÇÇ) : l.RCond fun x => min (r‚ÇÅ x) (r‚ÇÇ x) :=\n  fun hR x => congr_arg‚ÇÇ min (h‚ÇÅ hR x) (h‚ÇÇ hR x)\n\n"}
{"name":"BoxIntegral.IntegrationParams.toFilterDistortion_mono","module":"Mathlib.Analysis.BoxIntegral.Partition.Filter","initialProofState":"Œπ : Type u_1\ninst‚úù : Fintype Œπ\nc‚ÇÅ c‚ÇÇ : NNReal\nl‚ÇÅ l‚ÇÇ : BoxIntegral.IntegrationParams\nI : BoxIntegral.Box Œπ\nh : LE.le l‚ÇÅ l‚ÇÇ\nhc : LE.le c‚ÇÅ c‚ÇÇ\n‚ä¢ LE.le (l‚ÇÅ.toFilterDistortion I c‚ÇÅ) (l‚ÇÇ.toFilterDistortion I c‚ÇÇ)","decl":"@[gcongr, mono]\ntheorem toFilterDistortion_mono (I : Box Œπ) (h : l‚ÇÅ ‚â§ l‚ÇÇ) (hc : c‚ÇÅ ‚â§ c‚ÇÇ) :\n    l‚ÇÅ.toFilterDistortion I c‚ÇÅ ‚â§ l‚ÇÇ.toFilterDistortion I c‚ÇÇ :=\n  iInf_mono fun _ =>\n    iInf_mono' fun hr =>\n      ‚ü®hr.mono h, principal_mono.2 fun _ => MemBaseSet.mono I h hc fun _ _ => le_rfl‚ü©\n\n"}
{"name":"BoxIntegral.IntegrationParams.toFilter_mono","module":"Mathlib.Analysis.BoxIntegral.Partition.Filter","initialProofState":"Œπ : Type u_1\ninst‚úù : Fintype Œπ\nI : BoxIntegral.Box Œπ\nl‚ÇÅ l‚ÇÇ : BoxIntegral.IntegrationParams\nh : LE.le l‚ÇÅ l‚ÇÇ\n‚ä¢ LE.le (l‚ÇÅ.toFilter I) (l‚ÇÇ.toFilter I)","decl":"@[gcongr, mono]\ntheorem toFilter_mono (I : Box Œπ) {l‚ÇÅ l‚ÇÇ : IntegrationParams} (h : l‚ÇÅ ‚â§ l‚ÇÇ) :\n    l‚ÇÅ.toFilter I ‚â§ l‚ÇÇ.toFilter I :=\n  iSup_mono fun _ => toFilterDistortion_mono I h le_rfl\n\n"}
{"name":"BoxIntegral.IntegrationParams.toFilteriUnion_mono","module":"Mathlib.Analysis.BoxIntegral.Partition.Filter","initialProofState":"Œπ : Type u_1\ninst‚úù : Fintype Œπ\nI : BoxIntegral.Box Œπ\nl‚ÇÅ l‚ÇÇ : BoxIntegral.IntegrationParams\nh : LE.le l‚ÇÅ l‚ÇÇ\nœÄ‚ÇÄ : BoxIntegral.Prepartition I\n‚ä¢ LE.le (BoxIntegral.IntegrationParams.toFilteriUnion I œÄ‚ÇÄ) (BoxIntegral.IntegrationParams.toFilteriUnion I œÄ‚ÇÄ)","decl":"@[gcongr, mono]\ntheorem toFilteriUnion_mono (I : Box Œπ) {l‚ÇÅ l‚ÇÇ : IntegrationParams} (h : l‚ÇÅ ‚â§ l‚ÇÇ)\n    (œÄ‚ÇÄ : Prepartition I) : l‚ÇÅ.toFilteriUnion I œÄ‚ÇÄ ‚â§ l‚ÇÇ.toFilteriUnion I œÄ‚ÇÄ :=\n  iSup_mono fun _ => inf_le_inf_right _ <| toFilterDistortion_mono _ h le_rfl\n\n"}
{"name":"BoxIntegral.IntegrationParams.toFilteriUnion_congr","module":"Mathlib.Analysis.BoxIntegral.Partition.Filter","initialProofState":"Œπ : Type u_1\ninst‚úù : Fintype Œπ\nI : BoxIntegral.Box Œπ\nl : BoxIntegral.IntegrationParams\nœÄ‚ÇÅ œÄ‚ÇÇ : BoxIntegral.Prepartition I\nh : Eq œÄ‚ÇÅ.iUnion œÄ‚ÇÇ.iUnion\n‚ä¢ Eq (BoxIntegral.IntegrationParams.toFilteriUnion I œÄ‚ÇÅ) (BoxIntegral.IntegrationParams.toFilteriUnion I œÄ‚ÇÇ)","decl":"theorem toFilteriUnion_congr (I : Box Œπ) (l : IntegrationParams) {œÄ‚ÇÅ œÄ‚ÇÇ : Prepartition I}\n    (h : œÄ‚ÇÅ.iUnion = œÄ‚ÇÇ.iUnion) : l.toFilteriUnion I œÄ‚ÇÅ = l.toFilteriUnion I œÄ‚ÇÇ := by\n  simp only [toFilteriUnion, toFilterDistortioniUnion, h]\n\n"}
{"name":"BoxIntegral.IntegrationParams.hasBasis_toFilterDistortion","module":"Mathlib.Analysis.BoxIntegral.Partition.Filter","initialProofState":"Œπ : Type u_1\ninst‚úù : Fintype Œπ\nl : BoxIntegral.IntegrationParams\nI : BoxIntegral.Box Œπ\nc : NNReal\n‚ä¢ (l.toFilterDistortion I c).HasBasis l.RCond fun r => setOf fun œÄ => l.MemBaseSet I c r œÄ","decl":"theorem hasBasis_toFilterDistortion (l : IntegrationParams) (I : Box Œπ) (c : ‚Ñù‚â•0) :\n    (l.toFilterDistortion I c).HasBasis l.RCond fun r => { œÄ | l.MemBaseSet I c r œÄ } :=\n  hasBasis_biInf_principal'\n    (fun _ hr‚ÇÅ _ hr‚ÇÇ =>\n      ‚ü®_, hr‚ÇÅ.min hr‚ÇÇ, fun _ => MemBaseSet.mono _ le_rfl le_rfl fun _ _ => min_le_left _ _,\n        fun _ => MemBaseSet.mono _ le_rfl le_rfl fun _ _ => min_le_right _ _‚ü©)\n    ‚ü®fun _ => ‚ü®1, Set.mem_Ioi.2 zero_lt_one‚ü©, fun _ _ => rfl‚ü©\n\n"}
{"name":"BoxIntegral.IntegrationParams.hasBasis_toFilterDistortioniUnion","module":"Mathlib.Analysis.BoxIntegral.Partition.Filter","initialProofState":"Œπ : Type u_1\ninst‚úù : Fintype Œπ\nl : BoxIntegral.IntegrationParams\nI : BoxIntegral.Box Œπ\nc : NNReal\nœÄ‚ÇÄ : BoxIntegral.Prepartition I\n‚ä¢ (l.toFilterDistortioniUnion I c œÄ‚ÇÄ).HasBasis l.RCond fun r => setOf fun œÄ => And (l.MemBaseSet I c r œÄ) (Eq œÄ.iUnion œÄ‚ÇÄ.iUnion)","decl":"theorem hasBasis_toFilterDistortioniUnion (l : IntegrationParams) (I : Box Œπ) (c : ‚Ñù‚â•0)\n    (œÄ‚ÇÄ : Prepartition I) :\n    (l.toFilterDistortioniUnion I c œÄ‚ÇÄ).HasBasis l.RCond fun r =>\n      { œÄ | l.MemBaseSet I c r œÄ ‚àß œÄ.iUnion = œÄ‚ÇÄ.iUnion } :=\n  (l.hasBasis_toFilterDistortion I c).inf_principal _\n\n"}
{"name":"BoxIntegral.IntegrationParams.hasBasis_toFilteriUnion","module":"Mathlib.Analysis.BoxIntegral.Partition.Filter","initialProofState":"Œπ : Type u_1\ninst‚úù : Fintype Œπ\nl : BoxIntegral.IntegrationParams\nI : BoxIntegral.Box Œπ\nœÄ‚ÇÄ : BoxIntegral.Prepartition I\n‚ä¢ (BoxIntegral.IntegrationParams.toFilteriUnion I œÄ‚ÇÄ).HasBasis (fun r => ‚àÄ (c : NNReal), l.RCond (r c)) fun r => setOf fun œÄ => Exists fun c => And (l.MemBaseSet I c (r c) œÄ) (Eq œÄ.iUnion œÄ‚ÇÄ.iUnion)","decl":"theorem hasBasis_toFilteriUnion (l : IntegrationParams) (I : Box Œπ) (œÄ‚ÇÄ : Prepartition I) :\n    (l.toFilteriUnion I œÄ‚ÇÄ).HasBasis (fun r : ‚Ñù‚â•0 ‚Üí (Œπ ‚Üí ‚Ñù) ‚Üí Ioi (0 : ‚Ñù) => ‚àÄ c, l.RCond (r c))\n      fun r => { œÄ | ‚àÉ c, l.MemBaseSet I c (r c) œÄ ‚àß œÄ.iUnion = œÄ‚ÇÄ.iUnion } := by\n  have := fun c => l.hasBasis_toFilterDistortioniUnion I c œÄ‚ÇÄ\n  simpa only [setOf_and, setOf_exists] using hasBasis_iSup this\n\n"}
{"name":"BoxIntegral.IntegrationParams.hasBasis_toFilteriUnion_top","module":"Mathlib.Analysis.BoxIntegral.Partition.Filter","initialProofState":"Œπ : Type u_1\ninst‚úù : Fintype Œπ\nl : BoxIntegral.IntegrationParams\nI : BoxIntegral.Box Œπ\n‚ä¢ (BoxIntegral.IntegrationParams.toFilteriUnion I Top.top).HasBasis (fun r => ‚àÄ (c : NNReal), l.RCond (r c)) fun r => setOf fun œÄ => Exists fun c => And (l.MemBaseSet I c (r c) œÄ) œÄ.IsPartition","decl":"theorem hasBasis_toFilteriUnion_top (l : IntegrationParams) (I : Box Œπ) :\n    (l.toFilteriUnion I ‚ä§).HasBasis (fun r : ‚Ñù‚â•0 ‚Üí (Œπ ‚Üí ‚Ñù) ‚Üí Ioi (0 : ‚Ñù) => ‚àÄ c, l.RCond (r c))\n      fun r => { œÄ | ‚àÉ c, l.MemBaseSet I c (r c) œÄ ‚àß œÄ.IsPartition } := by\n  simpa only [TaggedPrepartition.isPartition_iff_iUnion_eq, Prepartition.iUnion_top] using\n    l.hasBasis_toFilteriUnion I ‚ä§\n\n"}
{"name":"BoxIntegral.IntegrationParams.hasBasis_toFilter","module":"Mathlib.Analysis.BoxIntegral.Partition.Filter","initialProofState":"Œπ : Type u_1\ninst‚úù : Fintype Œπ\nl : BoxIntegral.IntegrationParams\nI : BoxIntegral.Box Œπ\n‚ä¢ (l.toFilter I).HasBasis (fun r => ‚àÄ (c : NNReal), l.RCond (r c)) fun r => setOf fun œÄ => Exists fun c => l.MemBaseSet I c (r c) œÄ","decl":"theorem hasBasis_toFilter (l : IntegrationParams) (I : Box Œπ) :\n    (l.toFilter I).HasBasis (fun r : ‚Ñù‚â•0 ‚Üí (Œπ ‚Üí ‚Ñù) ‚Üí Ioi (0 : ‚Ñù) => ‚àÄ c, l.RCond (r c))\n      fun r => { œÄ | ‚àÉ c, l.MemBaseSet I c (r c) œÄ } := by\n  simpa only [setOf_exists] using hasBasis_iSup (l.hasBasis_toFilterDistortion I)\n\n"}
{"name":"BoxIntegral.IntegrationParams.tendsto_embedBox_toFilteriUnion_top","module":"Mathlib.Analysis.BoxIntegral.Partition.Filter","initialProofState":"Œπ : Type u_1\ninst‚úù : Fintype Œπ\nI J : BoxIntegral.Box Œπ\nl : BoxIntegral.IntegrationParams\nh : LE.le I J\n‚ä¢ Filter.Tendsto (‚áë(BoxIntegral.TaggedPrepartition.embedBox I J h)) (BoxIntegral.IntegrationParams.toFilteriUnion I Top.top) (BoxIntegral.IntegrationParams.toFilteriUnion J (BoxIntegral.Prepartition.single J I h))","decl":"theorem tendsto_embedBox_toFilteriUnion_top (l : IntegrationParams) (h : I ‚â§ J) :\n    Tendsto (TaggedPrepartition.embedBox I J h) (l.toFilteriUnion I ‚ä§)\n      (l.toFilteriUnion J (Prepartition.single J I h)) := by\n  simp only [toFilteriUnion, tendsto_iSup]; intro c\n  set œÄ‚ÇÄ := Prepartition.single J I h\n  refine le_iSup_of_le (max c œÄ‚ÇÄ.compl.distortion) ?_\n  refine ((l.hasBasis_toFilterDistortioniUnion I c ‚ä§).tendsto_iff\n    (l.hasBasis_toFilterDistortioniUnion J _ _)).2 fun r hr => ?_\n  refine ‚ü®r, hr, fun œÄ hœÄ => ?_‚ü©\n  rw [mem_setOf_eq, Prepartition.iUnion_top] at hœÄ\n  refine ‚ü®‚ü®hœÄ.1.1, hœÄ.1.2, fun hD => le_trans (hœÄ.1.3 hD) (le_max_left _ _), fun _ => ?_‚ü©, ?_‚ü©\n  ¬∑ refine ‚ü®_, œÄ‚ÇÄ.iUnion_compl.trans ?_, le_max_right _ _‚ü©\n    congr 1\n    exact (Prepartition.iUnion_single h).trans hœÄ.2.symm\n  ¬∑ exact hœÄ.2.trans (Prepartition.iUnion_single _).symm\n\n"}
{"name":"BoxIntegral.IntegrationParams.exists_memBaseSet_le_iUnion_eq","module":"Mathlib.Analysis.BoxIntegral.Partition.Filter","initialProofState":"Œπ : Type u_1\ninst‚úù : Fintype Œπ\nI : BoxIntegral.Box Œπ\nc : NNReal\nl : BoxIntegral.IntegrationParams\nœÄ‚ÇÄ : BoxIntegral.Prepartition I\nhc‚ÇÅ : LE.le œÄ‚ÇÄ.distortion c\nhc‚ÇÇ : LE.le œÄ‚ÇÄ.compl.distortion c\nr : (Œπ ‚Üí Real) ‚Üí ‚Üë(Set.Ioi 0)\n‚ä¢ Exists fun œÄ => And (l.MemBaseSet I c r œÄ) (And (LE.le œÄ.toPrepartition œÄ‚ÇÄ) (Eq œÄ.iUnion œÄ‚ÇÄ.iUnion))","decl":"theorem exists_memBaseSet_le_iUnion_eq (l : IntegrationParams) (œÄ‚ÇÄ : Prepartition I)\n    (hc‚ÇÅ : œÄ‚ÇÄ.distortion ‚â§ c) (hc‚ÇÇ : œÄ‚ÇÄ.compl.distortion ‚â§ c) (r : (Œπ ‚Üí ‚Ñù) ‚Üí Ioi (0 : ‚Ñù)) :\n    ‚àÉ œÄ, l.MemBaseSet I c r œÄ ‚àß œÄ.toPrepartition ‚â§ œÄ‚ÇÄ ‚àß œÄ.iUnion = œÄ‚ÇÄ.iUnion := by\n  rcases œÄ‚ÇÄ.exists_tagged_le_isHenstock_isSubordinate_iUnion_eq r with ‚ü®œÄ, hle, hH, hr, hd, hU‚ü©\n  refine ‚ü®œÄ, ‚ü®hr, fun _ => hH, fun _ => hd.trans_le hc‚ÇÅ, fun _ => ‚ü®œÄ‚ÇÄ.compl, ?_, hc‚ÇÇ‚ü©‚ü©, ‚ü®hle, hU‚ü©‚ü©\n  exact Prepartition.compl_congr hU ‚ñ∏ œÄ.toPrepartition.iUnion_compl\n\n"}
{"name":"BoxIntegral.IntegrationParams.exists_memBaseSet_isPartition","module":"Mathlib.Analysis.BoxIntegral.Partition.Filter","initialProofState":"Œπ : Type u_1\ninst‚úù : Fintype Œπ\nc : NNReal\nl : BoxIntegral.IntegrationParams\nI : BoxIntegral.Box Œπ\nhc : LE.le I.distortion c\nr : (Œπ ‚Üí Real) ‚Üí ‚Üë(Set.Ioi 0)\n‚ä¢ Exists fun œÄ => And (l.MemBaseSet I c r œÄ) œÄ.IsPartition","decl":"theorem exists_memBaseSet_isPartition (l : IntegrationParams) (I : Box Œπ) (hc : I.distortion ‚â§ c)\n    (r : (Œπ ‚Üí ‚Ñù) ‚Üí Ioi (0 : ‚Ñù)) : ‚àÉ œÄ, l.MemBaseSet I c r œÄ ‚àß œÄ.IsPartition := by\n  rw [‚Üê Prepartition.distortion_top] at hc\n  have hc' : (‚ä§ : Prepartition I).compl.distortion ‚â§ c := by simp\n  simpa [isPartition_iff_iUnion_eq] using l.exists_memBaseSet_le_iUnion_eq ‚ä§ hc hc' r\n\n"}
{"name":"BoxIntegral.IntegrationParams.toFilterDistortioniUnion_neBot","module":"Mathlib.Analysis.BoxIntegral.Partition.Filter","initialProofState":"Œπ : Type u_1\ninst‚úù : Fintype Œπ\nc : NNReal\nl : BoxIntegral.IntegrationParams\nI : BoxIntegral.Box Œπ\nœÄ‚ÇÄ : BoxIntegral.Prepartition I\nhc‚ÇÅ : LE.le œÄ‚ÇÄ.distortion c\nhc‚ÇÇ : LE.le œÄ‚ÇÄ.compl.distortion c\n‚ä¢ (l.toFilterDistortioniUnion I c œÄ‚ÇÄ).NeBot","decl":"theorem toFilterDistortioniUnion_neBot (l : IntegrationParams) (I : Box Œπ) (œÄ‚ÇÄ : Prepartition I)\n    (hc‚ÇÅ : œÄ‚ÇÄ.distortion ‚â§ c) (hc‚ÇÇ : œÄ‚ÇÄ.compl.distortion ‚â§ c) :\n    (l.toFilterDistortioniUnion I c œÄ‚ÇÄ).NeBot :=\n  ((l.hasBasis_toFilterDistortion I _).inf_principal _).neBot_iff.2\n    fun {r} _ => (l.exists_memBaseSet_le_iUnion_eq œÄ‚ÇÄ hc‚ÇÅ hc‚ÇÇ r).imp fun _ hœÄ => ‚ü®hœÄ.1, hœÄ.2.2‚ü©\n\n"}
{"name":"BoxIntegral.IntegrationParams.toFilterDistortioniUnion_neBot'","module":"Mathlib.Analysis.BoxIntegral.Partition.Filter","initialProofState":"Œπ : Type u_1\ninst‚úù : Fintype Œπ\nl : BoxIntegral.IntegrationParams\nI : BoxIntegral.Box Œπ\nœÄ‚ÇÄ : BoxIntegral.Prepartition I\n‚ä¢ (l.toFilterDistortioniUnion I (Max.max œÄ‚ÇÄ.distortion œÄ‚ÇÄ.compl.distortion) œÄ‚ÇÄ).NeBot","decl":"instance toFilterDistortioniUnion_neBot' (l : IntegrationParams) (I : Box Œπ) (œÄ‚ÇÄ : Prepartition I) :\n    (l.toFilterDistortioniUnion I (max œÄ‚ÇÄ.distortion œÄ‚ÇÄ.compl.distortion) œÄ‚ÇÄ).NeBot :=\n  l.toFilterDistortioniUnion_neBot I œÄ‚ÇÄ (le_max_left _ _) (le_max_right _ _)\n\n"}
{"name":"BoxIntegral.IntegrationParams.toFilterDistortion_neBot","module":"Mathlib.Analysis.BoxIntegral.Partition.Filter","initialProofState":"Œπ : Type u_1\ninst‚úù : Fintype Œπ\nl : BoxIntegral.IntegrationParams\nI : BoxIntegral.Box Œπ\n‚ä¢ (l.toFilterDistortion I I.distortion).NeBot","decl":"instance toFilterDistortion_neBot (l : IntegrationParams) (I : Box Œπ) :\n    (l.toFilterDistortion I I.distortion).NeBot := by\n  simpa using (l.toFilterDistortioniUnion_neBot' I ‚ä§).mono inf_le_left\n\n"}
{"name":"BoxIntegral.IntegrationParams.toFilter_neBot","module":"Mathlib.Analysis.BoxIntegral.Partition.Filter","initialProofState":"Œπ : Type u_1\ninst‚úù : Fintype Œπ\nl : BoxIntegral.IntegrationParams\nI : BoxIntegral.Box Œπ\n‚ä¢ (l.toFilter I).NeBot","decl":"instance toFilter_neBot (l : IntegrationParams) (I : Box Œπ) : (l.toFilter I).NeBot :=\n  (l.toFilterDistortion_neBot I).mono <| le_iSup _ _\n\n"}
{"name":"BoxIntegral.IntegrationParams.toFilteriUnion_neBot","module":"Mathlib.Analysis.BoxIntegral.Partition.Filter","initialProofState":"Œπ : Type u_1\ninst‚úù : Fintype Œπ\nl : BoxIntegral.IntegrationParams\nI : BoxIntegral.Box Œπ\nœÄ‚ÇÄ : BoxIntegral.Prepartition I\n‚ä¢ (BoxIntegral.IntegrationParams.toFilteriUnion I œÄ‚ÇÄ).NeBot","decl":"instance toFilteriUnion_neBot (l : IntegrationParams) (I : Box Œπ) (œÄ‚ÇÄ : Prepartition I) :\n    (l.toFilteriUnion I œÄ‚ÇÄ).NeBot :=\n  (l.toFilterDistortioniUnion_neBot' I œÄ‚ÇÄ).mono <|\n    le_iSup (fun c => l.toFilterDistortioniUnion I c œÄ‚ÇÄ) _\n\n"}
{"name":"BoxIntegral.IntegrationParams.eventually_isPartition","module":"Mathlib.Analysis.BoxIntegral.Partition.Filter","initialProofState":"Œπ : Type u_1\ninst‚úù : Fintype Œπ\nl : BoxIntegral.IntegrationParams\nI : BoxIntegral.Box Œπ\n‚ä¢ Filter.Eventually (fun œÄ => œÄ.IsPartition) (BoxIntegral.IntegrationParams.toFilteriUnion I Top.top)","decl":"theorem eventually_isPartition (l : IntegrationParams) (I : Box Œπ) :\n    ‚àÄ·∂† œÄ in l.toFilteriUnion I ‚ä§, TaggedPrepartition.IsPartition œÄ :=\n  eventually_iSup.2 fun _ =>\n    eventually_inf_principal.2 <|\n      Eventually.of_forall fun œÄ h =>\n        œÄ.isPartition_iff_iUnion_eq.2 (h.trans Prepartition.iUnion_top)\n\n"}
