{"name":"IsConnected.nonempty","module":"Mathlib.Topology.Connected.Basic","initialProofState":"α : Type u\ninst✝ : TopologicalSpace α\ns : Set α\nh : IsConnected s\n⊢ s.Nonempty","decl":"theorem IsConnected.nonempty {s : Set α} (h : IsConnected s) : s.Nonempty :=\n  h.1\n\n"}
{"name":"IsConnected.isPreconnected","module":"Mathlib.Topology.Connected.Basic","initialProofState":"α : Type u\ninst✝ : TopologicalSpace α\ns : Set α\nh : IsConnected s\n⊢ IsPreconnected s","decl":"theorem IsConnected.isPreconnected {s : Set α} (h : IsConnected s) : IsPreconnected s :=\n  h.2\n\n"}
{"name":"IsPreirreducible.isPreconnected","module":"Mathlib.Topology.Connected.Basic","initialProofState":"α : Type u\ninst✝ : TopologicalSpace α\ns : Set α\nH : IsPreirreducible s\n⊢ IsPreconnected s","decl":"theorem IsPreirreducible.isPreconnected {s : Set α} (H : IsPreirreducible s) : IsPreconnected s :=\n  fun _ _ hu hv _ => H _ _ hu hv\n\n"}
{"name":"IsIrreducible.isConnected","module":"Mathlib.Topology.Connected.Basic","initialProofState":"α : Type u\ninst✝ : TopologicalSpace α\ns : Set α\nH : IsIrreducible s\n⊢ IsConnected s","decl":"theorem IsIrreducible.isConnected {s : Set α} (H : IsIrreducible s) : IsConnected s :=\n  ⟨H.nonempty, H.isPreirreducible.isPreconnected⟩\n\n"}
{"name":"isPreconnected_empty","module":"Mathlib.Topology.Connected.Basic","initialProofState":"α : Type u\ninst✝ : TopologicalSpace α\n⊢ IsPreconnected EmptyCollection.emptyCollection","decl":"theorem isPreconnected_empty : IsPreconnected (∅ : Set α) :=\n  isPreirreducible_empty.isPreconnected\n\n"}
{"name":"isConnected_singleton","module":"Mathlib.Topology.Connected.Basic","initialProofState":"α : Type u\ninst✝ : TopologicalSpace α\nx : α\n⊢ IsConnected (Singleton.singleton x)","decl":"theorem isConnected_singleton {x} : IsConnected ({x} : Set α) :=\n  isIrreducible_singleton.isConnected\n\n"}
{"name":"isPreconnected_singleton","module":"Mathlib.Topology.Connected.Basic","initialProofState":"α : Type u\ninst✝ : TopologicalSpace α\nx : α\n⊢ IsPreconnected (Singleton.singleton x)","decl":"theorem isPreconnected_singleton {x} : IsPreconnected ({x} : Set α) :=\n  isConnected_singleton.isPreconnected\n\n"}
{"name":"Set.Subsingleton.isPreconnected","module":"Mathlib.Topology.Connected.Basic","initialProofState":"α : Type u\ninst✝ : TopologicalSpace α\ns : Set α\nhs : s.Subsingleton\n⊢ IsPreconnected s","decl":"theorem Set.Subsingleton.isPreconnected {s : Set α} (hs : s.Subsingleton) : IsPreconnected s :=\n  hs.induction_on isPreconnected_empty fun _ => isPreconnected_singleton\n\n"}
{"name":"isPreconnected_of_forall","module":"Mathlib.Topology.Connected.Basic","initialProofState":"α : Type u\ninst✝ : TopologicalSpace α\ns : Set α\nx : α\nH : ∀ (y : α), Membership.mem s y → Exists fun t => And (HasSubset.Subset t s) (And (Membership.mem t x) (And (Membership.mem t y) (IsPreconnected t)))\n⊢ IsPreconnected s","decl":"/-- If any point of a set is joined to a fixed point by a preconnected subset,\nthen the original set is preconnected as well. -/\ntheorem isPreconnected_of_forall {s : Set α} (x : α)\n    (H : ∀ y ∈ s, ∃ t, t ⊆ s ∧ x ∈ t ∧ y ∈ t ∧ IsPreconnected t) : IsPreconnected s := by\n  rintro u v hu hv hs ⟨z, zs, zu⟩ ⟨y, ys, yv⟩\n  have xs : x ∈ s := by\n    rcases H y ys with ⟨t, ts, xt, -, -⟩\n    exact ts xt\n  -- Porting note (https://github.com/leanprover-community/mathlib4/issues/11215): TODO: use `wlog xu : x ∈ u := hs xs using u v y z, v u z y`\n  cases hs xs with\n  | inl xu =>\n    rcases H y ys with ⟨t, ts, xt, yt, ht⟩\n    have := ht u v hu hv (ts.trans hs) ⟨x, xt, xu⟩ ⟨y, yt, yv⟩\n    exact this.imp fun z hz => ⟨ts hz.1, hz.2⟩\n  | inr xv =>\n    rcases H z zs with ⟨t, ts, xt, zt, ht⟩\n    have := ht v u hv hu (ts.trans <| by rwa [union_comm]) ⟨x, xt, xv⟩ ⟨z, zt, zu⟩\n    exact this.imp fun _ h => ⟨ts h.1, h.2.2, h.2.1⟩\n\n"}
{"name":"isPreconnected_of_forall_pair","module":"Mathlib.Topology.Connected.Basic","initialProofState":"α : Type u\ninst✝ : TopologicalSpace α\ns : Set α\nH : ∀ (x : α), Membership.mem s x → ∀ (y : α), Membership.mem s y → Exists fun t => And (HasSubset.Subset t s) (And (Membership.mem t x) (And (Membership.mem t y) (IsPreconnected t)))\n⊢ IsPreconnected s","decl":"/-- If any two points of a set are contained in a preconnected subset,\nthen the original set is preconnected as well. -/\ntheorem isPreconnected_of_forall_pair {s : Set α}\n    (H : ∀ x ∈ s, ∀ y ∈ s, ∃ t, t ⊆ s ∧ x ∈ t ∧ y ∈ t ∧ IsPreconnected t) :\n    IsPreconnected s := by\n  rcases eq_empty_or_nonempty s with (rfl | ⟨x, hx⟩)\n  exacts [isPreconnected_empty, isPreconnected_of_forall x fun y => H x hx y]\n\n"}
{"name":"isPreconnected_sUnion","module":"Mathlib.Topology.Connected.Basic","initialProofState":"α : Type u\ninst✝ : TopologicalSpace α\nx : α\nc : Set (Set α)\nH1 : ∀ (s : Set α), Membership.mem c s → Membership.mem s x\nH2 : ∀ (s : Set α), Membership.mem c s → IsPreconnected s\n⊢ IsPreconnected c.sUnion","decl":"/-- A union of a family of preconnected sets with a common point is preconnected as well. -/\ntheorem isPreconnected_sUnion (x : α) (c : Set (Set α)) (H1 : ∀ s ∈ c, x ∈ s)\n    (H2 : ∀ s ∈ c, IsPreconnected s) : IsPreconnected (⋃₀ c) := by\n  apply isPreconnected_of_forall x\n  rintro y ⟨s, sc, ys⟩\n  exact ⟨s, subset_sUnion_of_mem sc, H1 s sc, ys, H2 s sc⟩\n\n"}
{"name":"isPreconnected_iUnion","module":"Mathlib.Topology.Connected.Basic","initialProofState":"α : Type u\ninst✝ : TopologicalSpace α\nι : Sort u_3\ns : ι → Set α\nh₁ : (Set.iInter fun i => s i).Nonempty\nh₂ : ∀ (i : ι), IsPreconnected (s i)\n⊢ IsPreconnected (Set.iUnion fun i => s i)","decl":"theorem isPreconnected_iUnion {ι : Sort*} {s : ι → Set α} (h₁ : (⋂ i, s i).Nonempty)\n    (h₂ : ∀ i, IsPreconnected (s i)) : IsPreconnected (⋃ i, s i) :=\n  Exists.elim h₁ fun f hf => isPreconnected_sUnion f _ hf (forall_mem_range.2 h₂)\n\n"}
{"name":"IsPreconnected.union","module":"Mathlib.Topology.Connected.Basic","initialProofState":"α : Type u\ninst✝ : TopologicalSpace α\nx : α\ns t : Set α\nH1 : Membership.mem s x\nH2 : Membership.mem t x\nH3 : IsPreconnected s\nH4 : IsPreconnected t\n⊢ IsPreconnected (Union.union s t)","decl":"theorem IsPreconnected.union (x : α) {s t : Set α} (H1 : x ∈ s) (H2 : x ∈ t) (H3 : IsPreconnected s)\n    (H4 : IsPreconnected t) : IsPreconnected (s ∪ t) :=\n  sUnion_pair s t ▸ isPreconnected_sUnion x {s, t} (by rintro r (rfl | rfl | h) <;> assumption)\n    (by rintro r (rfl | rfl | h) <;> assumption)\n\n"}
{"name":"IsPreconnected.union'","module":"Mathlib.Topology.Connected.Basic","initialProofState":"α : Type u\ninst✝ : TopologicalSpace α\ns t : Set α\nH : (Inter.inter s t).Nonempty\nhs : IsPreconnected s\nht : IsPreconnected t\n⊢ IsPreconnected (Union.union s t)","decl":"theorem IsPreconnected.union' {s t : Set α} (H : (s ∩ t).Nonempty) (hs : IsPreconnected s)\n    (ht : IsPreconnected t) : IsPreconnected (s ∪ t) := by\n  rcases H with ⟨x, hxs, hxt⟩\n  exact hs.union x hxs hxt ht\n\n"}
{"name":"IsConnected.union","module":"Mathlib.Topology.Connected.Basic","initialProofState":"α : Type u\ninst✝ : TopologicalSpace α\ns t : Set α\nH : (Inter.inter s t).Nonempty\nHs : IsConnected s\nHt : IsConnected t\n⊢ IsConnected (Union.union s t)","decl":"theorem IsConnected.union {s t : Set α} (H : (s ∩ t).Nonempty) (Hs : IsConnected s)\n    (Ht : IsConnected t) : IsConnected (s ∪ t) := by\n  rcases H with ⟨x, hx⟩\n  refine ⟨⟨x, mem_union_left t (mem_of_mem_inter_left hx)⟩, ?_⟩\n  exact Hs.isPreconnected.union x (mem_of_mem_inter_left hx) (mem_of_mem_inter_right hx)\n    Ht.isPreconnected\n\n"}
{"name":"IsPreconnected.sUnion_directed","module":"Mathlib.Topology.Connected.Basic","initialProofState":"α : Type u\ninst✝ : TopologicalSpace α\nS : Set (Set α)\nK : DirectedOn (fun x1 x2 => HasSubset.Subset x1 x2) S\nH : ∀ (s : Set α), Membership.mem S s → IsPreconnected s\n⊢ IsPreconnected S.sUnion","decl":"/-- The directed sUnion of a set S of preconnected subsets is preconnected. -/\ntheorem IsPreconnected.sUnion_directed {S : Set (Set α)} (K : DirectedOn (· ⊆ ·) S)\n    (H : ∀ s ∈ S, IsPreconnected s) : IsPreconnected (⋃₀ S) := by\n  rintro u v hu hv Huv ⟨a, ⟨s, hsS, has⟩, hau⟩ ⟨b, ⟨t, htS, hbt⟩, hbv⟩\n  obtain ⟨r, hrS, hsr, htr⟩ : ∃ r ∈ S, s ⊆ r ∧ t ⊆ r := K s hsS t htS\n  have Hnuv : (r ∩ (u ∩ v)).Nonempty :=\n    H _ hrS u v hu hv ((subset_sUnion_of_mem hrS).trans Huv) ⟨a, hsr has, hau⟩ ⟨b, htr hbt, hbv⟩\n  have Kruv : r ∩ (u ∩ v) ⊆ ⋃₀ S ∩ (u ∩ v) := inter_subset_inter_left _ (subset_sUnion_of_mem hrS)\n  exact Hnuv.mono Kruv\n\n"}
{"name":"IsPreconnected.biUnion_of_reflTransGen","module":"Mathlib.Topology.Connected.Basic","initialProofState":"α : Type u\ninst✝ : TopologicalSpace α\nι : Type u_3\nt : Set ι\ns : ι → Set α\nH : ∀ (i : ι), Membership.mem t i → IsPreconnected (s i)\nK : ∀ (i : ι), Membership.mem t i → ∀ (j : ι), Membership.mem t j → Relation.ReflTransGen (fun i j => And (Inter.inter (s i) (s j)).Nonempty (Membership.mem t i)) i j\n⊢ IsPreconnected (Set.iUnion fun n => Set.iUnion fun h => s n)","decl":"/-- The biUnion of a family of preconnected sets is preconnected if the graph determined by\nwhether two sets intersect is preconnected. -/\ntheorem IsPreconnected.biUnion_of_reflTransGen {ι : Type*} {t : Set ι} {s : ι → Set α}\n    (H : ∀ i ∈ t, IsPreconnected (s i))\n    (K : ∀ i, i ∈ t → ∀ j, j ∈ t → ReflTransGen (fun i j => (s i ∩ s j).Nonempty ∧ i ∈ t) i j) :\n    IsPreconnected (⋃ n ∈ t, s n) := by\n  let R := fun i j : ι => (s i ∩ s j).Nonempty ∧ i ∈ t\n  have P : ∀ i, i ∈ t → ∀ j, j ∈ t → ReflTransGen R i j →\n      ∃ p, p ⊆ t ∧ i ∈ p ∧ j ∈ p ∧ IsPreconnected (⋃ j ∈ p, s j) := fun i hi j hj h => by\n    induction h with\n    | refl =>\n      refine ⟨{i}, singleton_subset_iff.mpr hi, mem_singleton i, mem_singleton i, ?_⟩\n      rw [biUnion_singleton]\n      exact H i hi\n    | @tail j k _ hjk ih =>\n      obtain ⟨p, hpt, hip, hjp, hp⟩ := ih hjk.2\n      refine ⟨insert k p, insert_subset_iff.mpr ⟨hj, hpt⟩, mem_insert_of_mem k hip,\n        mem_insert k p, ?_⟩\n      rw [biUnion_insert]\n      refine (H k hj).union' (hjk.1.mono ?_) hp\n      rw [inter_comm]\n      exact inter_subset_inter_right _ (subset_biUnion_of_mem hjp)\n  refine isPreconnected_of_forall_pair ?_\n  intro x hx y hy\n  obtain ⟨i : ι, hi : i ∈ t, hxi : x ∈ s i⟩ := mem_iUnion₂.1 hx\n  obtain ⟨j : ι, hj : j ∈ t, hyj : y ∈ s j⟩ := mem_iUnion₂.1 hy\n  obtain ⟨p, hpt, hip, hjp, hp⟩ := P i hi j hj (K i hi j hj)\n  exact ⟨⋃ j ∈ p, s j, biUnion_subset_biUnion_left hpt, mem_biUnion hip hxi,\n    mem_biUnion hjp hyj, hp⟩\n\n"}
{"name":"IsConnected.biUnion_of_reflTransGen","module":"Mathlib.Topology.Connected.Basic","initialProofState":"α : Type u\ninst✝ : TopologicalSpace α\nι : Type u_3\nt : Set ι\ns : ι → Set α\nht : t.Nonempty\nH : ∀ (i : ι), Membership.mem t i → IsConnected (s i)\nK : ∀ (i : ι), Membership.mem t i → ∀ (j : ι), Membership.mem t j → Relation.ReflTransGen (fun i j => And (Inter.inter (s i) (s j)).Nonempty (Membership.mem t i)) i j\n⊢ IsConnected (Set.iUnion fun n => Set.iUnion fun h => s n)","decl":"/-- The biUnion of a family of preconnected sets is preconnected if the graph determined by\nwhether two sets intersect is preconnected. -/\ntheorem IsConnected.biUnion_of_reflTransGen {ι : Type*} {t : Set ι} {s : ι → Set α}\n    (ht : t.Nonempty) (H : ∀ i ∈ t, IsConnected (s i))\n    (K : ∀ i, i ∈ t → ∀ j, j ∈ t → ReflTransGen (fun i j : ι => (s i ∩ s j).Nonempty ∧ i ∈ t) i j) :\n    IsConnected (⋃ n ∈ t, s n) :=\n  ⟨nonempty_biUnion.2 <| ⟨ht.some, ht.some_mem, (H _ ht.some_mem).nonempty⟩,\n    IsPreconnected.biUnion_of_reflTransGen (fun i hi => (H i hi).isPreconnected) K⟩\n\n"}
{"name":"IsPreconnected.iUnion_of_reflTransGen","module":"Mathlib.Topology.Connected.Basic","initialProofState":"α : Type u\ninst✝ : TopologicalSpace α\nι : Type u_3\ns : ι → Set α\nH : ∀ (i : ι), IsPreconnected (s i)\nK : ∀ (i j : ι), Relation.ReflTransGen (fun i j => (Inter.inter (s i) (s j)).Nonempty) i j\n⊢ IsPreconnected (Set.iUnion fun n => s n)","decl":"/-- Preconnectedness of the iUnion of a family of preconnected sets\nindexed by the vertices of a preconnected graph,\nwhere two vertices are joined when the corresponding sets intersect. -/\ntheorem IsPreconnected.iUnion_of_reflTransGen {ι : Type*} {s : ι → Set α}\n    (H : ∀ i, IsPreconnected (s i))\n    (K : ∀ i j, ReflTransGen (fun i j : ι => (s i ∩ s j).Nonempty) i j) :\n    IsPreconnected (⋃ n, s n) := by\n  rw [← biUnion_univ]\n  exact IsPreconnected.biUnion_of_reflTransGen (fun i _ => H i) fun i _ j _ => by\n    simpa [mem_univ] using K i j\n\n"}
{"name":"IsConnected.iUnion_of_reflTransGen","module":"Mathlib.Topology.Connected.Basic","initialProofState":"α : Type u\ninst✝¹ : TopologicalSpace α\nι : Type u_3\ninst✝ : Nonempty ι\ns : ι → Set α\nH : ∀ (i : ι), IsConnected (s i)\nK : ∀ (i j : ι), Relation.ReflTransGen (fun i j => (Inter.inter (s i) (s j)).Nonempty) i j\n⊢ IsConnected (Set.iUnion fun n => s n)","decl":"theorem IsConnected.iUnion_of_reflTransGen {ι : Type*} [Nonempty ι] {s : ι → Set α}\n    (H : ∀ i, IsConnected (s i))\n    (K : ∀ i j, ReflTransGen (fun i j : ι => (s i ∩ s j).Nonempty) i j) : IsConnected (⋃ n, s n) :=\n  ⟨nonempty_iUnion.2 <| Nonempty.elim ‹_› fun i : ι => ⟨i, (H _).nonempty⟩,\n    IsPreconnected.iUnion_of_reflTransGen (fun i => (H i).isPreconnected) K⟩\n\n"}
{"name":"IsPreconnected.iUnion_of_chain","module":"Mathlib.Topology.Connected.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝³ : TopologicalSpace α\ninst✝² : LinearOrder β\ninst✝¹ : SuccOrder β\ninst✝ : IsSuccArchimedean β\ns : β → Set α\nH : ∀ (n : β), IsPreconnected (s n)\nK : ∀ (n : β), (Inter.inter (s n) (s (Order.succ n))).Nonempty\n⊢ IsPreconnected (Set.iUnion fun n => s n)","decl":"/-- The iUnion of connected sets indexed by a type with an archimedean successor (like `ℕ` or `ℤ`)\n  such that any two neighboring sets meet is preconnected. -/\ntheorem IsPreconnected.iUnion_of_chain {s : β → Set α} (H : ∀ n, IsPreconnected (s n))\n    (K : ∀ n, (s n ∩ s (succ n)).Nonempty) : IsPreconnected (⋃ n, s n) :=\n  IsPreconnected.iUnion_of_reflTransGen H fun _ _ =>\n    reflTransGen_of_succ _ (fun i _ => K i) fun i _ => by\n      rw [inter_comm]\n      exact K i\n\n"}
{"name":"IsConnected.iUnion_of_chain","module":"Mathlib.Topology.Connected.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝⁴ : TopologicalSpace α\ninst✝³ : LinearOrder β\ninst✝² : SuccOrder β\ninst✝¹ : IsSuccArchimedean β\ninst✝ : Nonempty β\ns : β → Set α\nH : ∀ (n : β), IsConnected (s n)\nK : ∀ (n : β), (Inter.inter (s n) (s (Order.succ n))).Nonempty\n⊢ IsConnected (Set.iUnion fun n => s n)","decl":"/-- The iUnion of connected sets indexed by a type with an archimedean successor (like `ℕ` or `ℤ`)\n  such that any two neighboring sets meet is connected. -/\ntheorem IsConnected.iUnion_of_chain [Nonempty β] {s : β → Set α} (H : ∀ n, IsConnected (s n))\n    (K : ∀ n, (s n ∩ s (succ n)).Nonempty) : IsConnected (⋃ n, s n) :=\n  IsConnected.iUnion_of_reflTransGen H fun _ _ =>\n    reflTransGen_of_succ _ (fun i _ => K i) fun i _ => by\n      rw [inter_comm]\n      exact K i\n\n"}
{"name":"IsPreconnected.biUnion_of_chain","module":"Mathlib.Topology.Connected.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝³ : TopologicalSpace α\ninst✝² : LinearOrder β\ninst✝¹ : SuccOrder β\ninst✝ : IsSuccArchimedean β\ns : β → Set α\nt : Set β\nht : t.OrdConnected\nH : ∀ (n : β), Membership.mem t n → IsPreconnected (s n)\nK : ∀ (n : β), Membership.mem t n → Membership.mem t (Order.succ n) → (Inter.inter (s n) (s (Order.succ n))).Nonempty\n⊢ IsPreconnected (Set.iUnion fun n => Set.iUnion fun h => s n)","decl":"/-- The iUnion of preconnected sets indexed by a subset of a type with an archimedean successor\n  (like `ℕ` or `ℤ`) such that any two neighboring sets meet is preconnected. -/\ntheorem IsPreconnected.biUnion_of_chain {s : β → Set α} {t : Set β} (ht : OrdConnected t)\n    (H : ∀ n ∈ t, IsPreconnected (s n))\n    (K : ∀ n : β, n ∈ t → succ n ∈ t → (s n ∩ s (succ n)).Nonempty) :\n    IsPreconnected (⋃ n ∈ t, s n) := by\n  have h1 : ∀ {i j k : β}, i ∈ t → j ∈ t → k ∈ Ico i j → k ∈ t := fun hi hj hk =>\n    ht.out hi hj (Ico_subset_Icc_self hk)\n  have h2 : ∀ {i j k : β}, i ∈ t → j ∈ t → k ∈ Ico i j → succ k ∈ t := fun hi hj hk =>\n    ht.out hi hj ⟨hk.1.trans <| le_succ _, succ_le_of_lt hk.2⟩\n  have h3 : ∀ {i j k : β}, i ∈ t → j ∈ t → k ∈ Ico i j → (s k ∩ s (succ k)).Nonempty :=\n    fun hi hj hk => K _ (h1 hi hj hk) (h2 hi hj hk)\n  refine IsPreconnected.biUnion_of_reflTransGen H fun i hi j hj => ?_\n  exact reflTransGen_of_succ _ (fun k hk => ⟨h3 hi hj hk, h1 hi hj hk⟩) fun k hk =>\n      ⟨by rw [inter_comm]; exact h3 hj hi hk, h2 hj hi hk⟩\n\n"}
{"name":"IsConnected.biUnion_of_chain","module":"Mathlib.Topology.Connected.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝³ : TopologicalSpace α\ninst✝² : LinearOrder β\ninst✝¹ : SuccOrder β\ninst✝ : IsSuccArchimedean β\ns : β → Set α\nt : Set β\nhnt : t.Nonempty\nht : t.OrdConnected\nH : ∀ (n : β), Membership.mem t n → IsConnected (s n)\nK : ∀ (n : β), Membership.mem t n → Membership.mem t (Order.succ n) → (Inter.inter (s n) (s (Order.succ n))).Nonempty\n⊢ IsConnected (Set.iUnion fun n => Set.iUnion fun h => s n)","decl":"/-- The iUnion of connected sets indexed by a subset of a type with an archimedean successor\n  (like `ℕ` or `ℤ`) such that any two neighboring sets meet is preconnected. -/\ntheorem IsConnected.biUnion_of_chain {s : β → Set α} {t : Set β} (hnt : t.Nonempty)\n    (ht : OrdConnected t) (H : ∀ n ∈ t, IsConnected (s n))\n    (K : ∀ n : β, n ∈ t → succ n ∈ t → (s n ∩ s (succ n)).Nonempty) : IsConnected (⋃ n ∈ t, s n) :=\n  ⟨nonempty_biUnion.2 <| ⟨hnt.some, hnt.some_mem, (H _ hnt.some_mem).nonempty⟩,\n    IsPreconnected.biUnion_of_chain ht (fun i hi => (H i hi).isPreconnected) K⟩\n\n"}
{"name":"IsPreconnected.subset_closure","module":"Mathlib.Topology.Connected.Basic","initialProofState":"α : Type u\ninst✝ : TopologicalSpace α\ns t : Set α\nH : IsPreconnected s\nKst : HasSubset.Subset s t\nKtcs : HasSubset.Subset t (closure s)\n⊢ IsPreconnected t","decl":"/-- Theorem of bark and tree: if a set is within a preconnected set and its closure, then it is\npreconnected as well. See also `IsConnected.subset_closure`. -/\nprotected theorem IsPreconnected.subset_closure {s : Set α} {t : Set α} (H : IsPreconnected s)\n    (Kst : s ⊆ t) (Ktcs : t ⊆ closure s) : IsPreconnected t :=\n  fun u v hu hv htuv ⟨_y, hyt, hyu⟩ ⟨_z, hzt, hzv⟩ =>\n  let ⟨p, hpu, hps⟩ := mem_closure_iff.1 (Ktcs hyt) u hu hyu\n  let ⟨q, hqv, hqs⟩ := mem_closure_iff.1 (Ktcs hzt) v hv hzv\n  let ⟨r, hrs, hruv⟩ := H u v hu hv (Subset.trans Kst htuv) ⟨p, hps, hpu⟩ ⟨q, hqs, hqv⟩\n  ⟨r, Kst hrs, hruv⟩\n\n"}
{"name":"IsConnected.subset_closure","module":"Mathlib.Topology.Connected.Basic","initialProofState":"α : Type u\ninst✝ : TopologicalSpace α\ns t : Set α\nH : IsConnected s\nKst : HasSubset.Subset s t\nKtcs : HasSubset.Subset t (closure s)\n⊢ IsConnected t","decl":"/-- Theorem of bark and tree: if a set is within a connected set and its closure, then it is\nconnected as well. See also `IsPreconnected.subset_closure`. -/\nprotected theorem IsConnected.subset_closure {s : Set α} {t : Set α} (H : IsConnected s)\n    (Kst : s ⊆ t) (Ktcs : t ⊆ closure s) : IsConnected t :=\n  ⟨Nonempty.mono Kst H.left, IsPreconnected.subset_closure H.right Kst Ktcs⟩\n\n"}
{"name":"IsPreconnected.closure","module":"Mathlib.Topology.Connected.Basic","initialProofState":"α : Type u\ninst✝ : TopologicalSpace α\ns : Set α\nH : IsPreconnected s\n⊢ IsPreconnected (closure s)","decl":"/-- The closure of a preconnected set is preconnected as well. -/\nprotected theorem IsPreconnected.closure {s : Set α} (H : IsPreconnected s) :\n    IsPreconnected (closure s) :=\n  IsPreconnected.subset_closure H subset_closure Subset.rfl\n\n"}
{"name":"IsConnected.closure","module":"Mathlib.Topology.Connected.Basic","initialProofState":"α : Type u\ninst✝ : TopologicalSpace α\ns : Set α\nH : IsConnected s\n⊢ IsConnected (closure s)","decl":"/-- The closure of a connected set is connected as well. -/\nprotected theorem IsConnected.closure {s : Set α} (H : IsConnected s) : IsConnected (closure s) :=\n  IsConnected.subset_closure H subset_closure <| Subset.rfl\n\n"}
{"name":"IsPreconnected.image","module":"Mathlib.Topology.Connected.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : TopologicalSpace α\ninst✝ : TopologicalSpace β\ns : Set α\nH : IsPreconnected s\nf : α → β\nhf : ContinuousOn f s\n⊢ IsPreconnected (Set.image f s)","decl":"/-- The image of a preconnected set is preconnected as well. -/\nprotected theorem IsPreconnected.image [TopologicalSpace β] {s : Set α} (H : IsPreconnected s)\n    (f : α → β) (hf : ContinuousOn f s) : IsPreconnected (f '' s) := by\n  -- Unfold/destruct definitions in hypotheses\n  rintro u v hu hv huv ⟨_, ⟨x, xs, rfl⟩, xu⟩ ⟨_, ⟨y, ys, rfl⟩, yv⟩\n  rcases continuousOn_iff'.1 hf u hu with ⟨u', hu', u'_eq⟩\n  rcases continuousOn_iff'.1 hf v hv with ⟨v', hv', v'_eq⟩\n  -- Reformulate `huv : f '' s ⊆ u ∪ v` in terms of `u'` and `v'`\n  replace huv : s ⊆ u' ∪ v' := by\n    rw [image_subset_iff, preimage_union] at huv\n    replace huv := subset_inter huv Subset.rfl\n    rw [union_inter_distrib_right, u'_eq, v'_eq, ← union_inter_distrib_right] at huv\n    exact (subset_inter_iff.1 huv).1\n  -- Now `s ⊆ u' ∪ v'`, so we can apply `‹IsPreconnected s›`\n  obtain ⟨z, hz⟩ : (s ∩ (u' ∩ v')).Nonempty := by\n    refine H u' v' hu' hv' huv ⟨x, ?_⟩ ⟨y, ?_⟩ <;> rw [inter_comm]\n    exacts [u'_eq ▸ ⟨xu, xs⟩, v'_eq ▸ ⟨yv, ys⟩]\n  rw [← inter_self s, inter_assoc, inter_left_comm s u', ← inter_assoc, inter_comm s, inter_comm s,\n    ← u'_eq, ← v'_eq] at hz\n  exact ⟨f z, ⟨z, hz.1.2, rfl⟩, hz.1.1, hz.2.1⟩\n\n"}
{"name":"IsConnected.image","module":"Mathlib.Topology.Connected.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : TopologicalSpace α\ninst✝ : TopologicalSpace β\ns : Set α\nH : IsConnected s\nf : α → β\nhf : ContinuousOn f s\n⊢ IsConnected (Set.image f s)","decl":"/-- The image of a connected set is connected as well. -/\nprotected theorem IsConnected.image [TopologicalSpace β] {s : Set α} (H : IsConnected s) (f : α → β)\n    (hf : ContinuousOn f s) : IsConnected (f '' s) :=\n  ⟨image_nonempty.mpr H.nonempty, H.isPreconnected.image f hf⟩\n\n"}
{"name":"isPreconnected_closed_iff","module":"Mathlib.Topology.Connected.Basic","initialProofState":"α : Type u\ninst✝ : TopologicalSpace α\ns : Set α\n⊢ Iff (IsPreconnected s) (∀ (t t' : Set α), IsClosed t → IsClosed t' → HasSubset.Subset s (Union.union t t') → (Inter.inter s t).Nonempty → (Inter.inter s t').Nonempty → (Inter.inter s (Inter.inter t t')).Nonempty)","decl":"theorem isPreconnected_closed_iff {s : Set α} :\n    IsPreconnected s ↔ ∀ t t', IsClosed t → IsClosed t' →\n      s ⊆ t ∪ t' → (s ∩ t).Nonempty → (s ∩ t').Nonempty → (s ∩ (t ∩ t')).Nonempty :=\n  ⟨by\n      rintro h t t' ht ht' htt' ⟨x, xs, xt⟩ ⟨y, ys, yt'⟩\n      rw [← not_disjoint_iff_nonempty_inter, ← subset_compl_iff_disjoint_right, compl_inter]\n      intro h'\n      have xt' : x ∉ t' := (h' xs).resolve_left (absurd xt)\n      have yt : y ∉ t := (h' ys).resolve_right (absurd yt')\n      have := h _ _ ht.isOpen_compl ht'.isOpen_compl h' ⟨y, ys, yt⟩ ⟨x, xs, xt'⟩\n      rw [← compl_union] at this\n      exact this.ne_empty htt'.disjoint_compl_right.inter_eq,\n    by\n      rintro h u v hu hv huv ⟨x, xs, xu⟩ ⟨y, ys, yv⟩\n      rw [← not_disjoint_iff_nonempty_inter, ← subset_compl_iff_disjoint_right, compl_inter]\n      intro h'\n      have xv : x ∉ v := (h' xs).elim (absurd xu) id\n      have yu : y ∉ u := (h' ys).elim id (absurd yv)\n      have := h _ _ hu.isClosed_compl hv.isClosed_compl h' ⟨y, ys, yu⟩ ⟨x, xs, xv⟩\n      rw [← compl_union] at this\n      exact this.ne_empty huv.disjoint_compl_right.inter_eq⟩\n\n"}
{"name":"Topology.IsInducing.isPreconnected_image","module":"Mathlib.Topology.Connected.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : TopologicalSpace α\ninst✝ : TopologicalSpace β\ns : Set α\nf : α → β\nhf : Topology.IsInducing f\n⊢ Iff (IsPreconnected (Set.image f s)) (IsPreconnected s)","decl":"theorem Topology.IsInducing.isPreconnected_image [TopologicalSpace β] {s : Set α} {f : α → β}\n    (hf : IsInducing f) : IsPreconnected (f '' s) ↔ IsPreconnected s := by\n  refine ⟨fun h => ?_, fun h => h.image _ hf.continuous.continuousOn⟩\n  rintro u v hu' hv' huv ⟨x, hxs, hxu⟩ ⟨y, hys, hyv⟩\n  rcases hf.isOpen_iff.1 hu' with ⟨u, hu, rfl⟩\n  rcases hf.isOpen_iff.1 hv' with ⟨v, hv, rfl⟩\n  replace huv : f '' s ⊆ u ∪ v := by rwa [image_subset_iff]\n  rcases h u v hu hv huv ⟨f x, mem_image_of_mem _ hxs, hxu⟩ ⟨f y, mem_image_of_mem _ hys, hyv⟩ with\n    ⟨_, ⟨z, hzs, rfl⟩, hzuv⟩\n  exact ⟨z, hzs, hzuv⟩\n\n"}
{"name":"Inducing.isPreconnected_image","module":"Mathlib.Topology.Connected.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : TopologicalSpace α\ninst✝ : TopologicalSpace β\ns : Set α\nf : α → β\nhf : Topology.IsInducing f\n⊢ Iff (IsPreconnected (Set.image f s)) (IsPreconnected s)","decl":"@[deprecated (since := \"2024-10-28\")]\nalias Inducing.isPreconnected_image := IsInducing.isPreconnected_image\n\n/- TODO: The following lemmas about connection of preimages hold more generally for strict maps\n(the quotient and subspace topologies of the image agree) whose fibers are preconnected. -/\n\n"}
{"name":"IsPreconnected.preimage_of_isOpenMap","module":"Mathlib.Topology.Connected.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : TopologicalSpace α\ninst✝ : TopologicalSpace β\nf : α → β\ns : Set β\nhs : IsPreconnected s\nhinj : Function.Injective f\nhf : IsOpenMap f\nhsf : HasSubset.Subset s (Set.range f)\n⊢ IsPreconnected (Set.preimage f s)","decl":"theorem IsPreconnected.preimage_of_isOpenMap [TopologicalSpace β] {f : α → β} {s : Set β}\n    (hs : IsPreconnected s) (hinj : Function.Injective f) (hf : IsOpenMap f) (hsf : s ⊆ range f) :\n    IsPreconnected (f ⁻¹' s) := fun u v hu hv hsuv hsu hsv => by\n  replace hsf : f '' (f ⁻¹' s) = s := image_preimage_eq_of_subset hsf\n  obtain ⟨_, has, ⟨a, hau, rfl⟩, hav⟩ : (s ∩ (f '' u ∩ f '' v)).Nonempty := by\n    refine hs (f '' u) (f '' v) (hf u hu) (hf v hv) ?_ ?_ ?_\n    · simpa only [hsf, image_union] using image_subset f hsuv\n    · simpa only [image_preimage_inter] using hsu.image f\n    · simpa only [image_preimage_inter] using hsv.image f\n  · exact ⟨a, has, hau, hinj.mem_set_image.1 hav⟩\n\n"}
{"name":"IsPreconnected.preimage_of_isClosedMap","module":"Mathlib.Topology.Connected.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : TopologicalSpace α\ninst✝ : TopologicalSpace β\ns : Set β\nhs : IsPreconnected s\nf : α → β\nhinj : Function.Injective f\nhf : IsClosedMap f\nhsf : HasSubset.Subset s (Set.range f)\n⊢ IsPreconnected (Set.preimage f s)","decl":"theorem IsPreconnected.preimage_of_isClosedMap [TopologicalSpace β] {s : Set β}\n    (hs : IsPreconnected s) {f : α → β} (hinj : Function.Injective f) (hf : IsClosedMap f)\n    (hsf : s ⊆ range f) : IsPreconnected (f ⁻¹' s) :=\n  isPreconnected_closed_iff.2 fun u v hu hv hsuv hsu hsv => by\n    replace hsf : f '' (f ⁻¹' s) = s := image_preimage_eq_of_subset hsf\n    obtain ⟨_, has, ⟨a, hau, rfl⟩, hav⟩ : (s ∩ (f '' u ∩ f '' v)).Nonempty := by\n      refine isPreconnected_closed_iff.1 hs (f '' u) (f '' v) (hf u hu) (hf v hv) ?_ ?_ ?_\n      · simpa only [hsf, image_union] using image_subset f hsuv\n      · simpa only [image_preimage_inter] using hsu.image f\n      · simpa only [image_preimage_inter] using hsv.image f\n    · exact ⟨a, has, hau, hinj.mem_set_image.1 hav⟩\n\n"}
{"name":"IsConnected.preimage_of_isOpenMap","module":"Mathlib.Topology.Connected.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : TopologicalSpace α\ninst✝ : TopologicalSpace β\ns : Set β\nhs : IsConnected s\nf : α → β\nhinj : Function.Injective f\nhf : IsOpenMap f\nhsf : HasSubset.Subset s (Set.range f)\n⊢ IsConnected (Set.preimage f s)","decl":"theorem IsConnected.preimage_of_isOpenMap [TopologicalSpace β] {s : Set β} (hs : IsConnected s)\n    {f : α → β} (hinj : Function.Injective f) (hf : IsOpenMap f) (hsf : s ⊆ range f) :\n    IsConnected (f ⁻¹' s) :=\n  ⟨hs.nonempty.preimage' hsf, hs.isPreconnected.preimage_of_isOpenMap hinj hf hsf⟩\n\n"}
{"name":"IsConnected.preimage_of_isClosedMap","module":"Mathlib.Topology.Connected.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : TopologicalSpace α\ninst✝ : TopologicalSpace β\ns : Set β\nhs : IsConnected s\nf : α → β\nhinj : Function.Injective f\nhf : IsClosedMap f\nhsf : HasSubset.Subset s (Set.range f)\n⊢ IsConnected (Set.preimage f s)","decl":"theorem IsConnected.preimage_of_isClosedMap [TopologicalSpace β] {s : Set β} (hs : IsConnected s)\n    {f : α → β} (hinj : Function.Injective f) (hf : IsClosedMap f) (hsf : s ⊆ range f) :\n    IsConnected (f ⁻¹' s) :=\n  ⟨hs.nonempty.preimage' hsf, hs.isPreconnected.preimage_of_isClosedMap hinj hf hsf⟩\n\n"}
{"name":"IsPreconnected.subset_or_subset","module":"Mathlib.Topology.Connected.Basic","initialProofState":"α : Type u\ninst✝ : TopologicalSpace α\ns u v : Set α\nhu : IsOpen u\nhv : IsOpen v\nhuv : Disjoint u v\nhsuv : HasSubset.Subset s (Union.union u v)\nhs : IsPreconnected s\n⊢ Or (HasSubset.Subset s u) (HasSubset.Subset s v)","decl":"theorem IsPreconnected.subset_or_subset (hu : IsOpen u) (hv : IsOpen v) (huv : Disjoint u v)\n    (hsuv : s ⊆ u ∪ v) (hs : IsPreconnected s) : s ⊆ u ∨ s ⊆ v := by\n  specialize hs u v hu hv hsuv\n  obtain hsu | hsu := (s ∩ u).eq_empty_or_nonempty\n  · exact Or.inr ((Set.disjoint_iff_inter_eq_empty.2 hsu).subset_right_of_subset_union hsuv)\n  · replace hs := mt (hs hsu)\n    simp_rw [Set.not_nonempty_iff_eq_empty, ← Set.disjoint_iff_inter_eq_empty,\n      disjoint_iff_inter_eq_empty.1 huv] at hs\n    exact Or.inl ((hs s.disjoint_empty).subset_left_of_subset_union hsuv)\n\n"}
{"name":"IsPreconnected.subset_left_of_subset_union","module":"Mathlib.Topology.Connected.Basic","initialProofState":"α : Type u\ninst✝ : TopologicalSpace α\ns u v : Set α\nhu : IsOpen u\nhv : IsOpen v\nhuv : Disjoint u v\nhsuv : HasSubset.Subset s (Union.union u v)\nhsu : (Inter.inter s u).Nonempty\nhs : IsPreconnected s\n⊢ HasSubset.Subset s u","decl":"theorem IsPreconnected.subset_left_of_subset_union (hu : IsOpen u) (hv : IsOpen v)\n    (huv : Disjoint u v) (hsuv : s ⊆ u ∪ v) (hsu : (s ∩ u).Nonempty) (hs : IsPreconnected s) :\n    s ⊆ u :=\n  Disjoint.subset_left_of_subset_union hsuv\n    (by\n      by_contra hsv\n      rw [not_disjoint_iff_nonempty_inter] at hsv\n      obtain ⟨x, _, hx⟩ := hs u v hu hv hsuv hsu hsv\n      exact Set.disjoint_iff.1 huv hx)\n\n"}
{"name":"IsPreconnected.subset_right_of_subset_union","module":"Mathlib.Topology.Connected.Basic","initialProofState":"α : Type u\ninst✝ : TopologicalSpace α\ns u v : Set α\nhu : IsOpen u\nhv : IsOpen v\nhuv : Disjoint u v\nhsuv : HasSubset.Subset s (Union.union u v)\nhsv : (Inter.inter s v).Nonempty\nhs : IsPreconnected s\n⊢ HasSubset.Subset s v","decl":"theorem IsPreconnected.subset_right_of_subset_union (hu : IsOpen u) (hv : IsOpen v)\n    (huv : Disjoint u v) (hsuv : s ⊆ u ∪ v) (hsv : (s ∩ v).Nonempty) (hs : IsPreconnected s) :\n    s ⊆ v :=\n  hs.subset_left_of_subset_union hv hu huv.symm (union_comm u v ▸ hsuv) hsv\n\n"}
{"name":"IsPreconnected.subset_of_closure_inter_subset","module":"Mathlib.Topology.Connected.Basic","initialProofState":"α : Type u\ninst✝ : TopologicalSpace α\ns u : Set α\nhs : IsPreconnected s\nhu : IsOpen u\nh'u : (Inter.inter s u).Nonempty\nh : HasSubset.Subset (Inter.inter (closure u) s) u\n⊢ HasSubset.Subset s u","decl":"/-- If a preconnected set `s` intersects an open set `u`, and limit points of `u` inside `s` are\ncontained in `u`, then the whole set `s` is contained in `u`. -/\ntheorem IsPreconnected.subset_of_closure_inter_subset (hs : IsPreconnected s) (hu : IsOpen u)\n    (h'u : (s ∩ u).Nonempty) (h : closure u ∩ s ⊆ u) : s ⊆ u := by\n  have A : s ⊆ u ∪ (closure u)ᶜ := by\n    intro x hx\n    by_cases xu : x ∈ u\n    · exact Or.inl xu\n    · right\n      intro h'x\n      exact xu (h (mem_inter h'x hx))\n  apply hs.subset_left_of_subset_union hu isClosed_closure.isOpen_compl _ A h'u\n  exact disjoint_compl_right.mono_right (compl_subset_compl.2 subset_closure)\n\n"}
{"name":"IsPreconnected.prod","module":"Mathlib.Topology.Connected.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : TopologicalSpace α\ninst✝ : TopologicalSpace β\ns : Set α\nt : Set β\nhs : IsPreconnected s\nht : IsPreconnected t\n⊢ IsPreconnected (SProd.sprod s t)","decl":"theorem IsPreconnected.prod [TopologicalSpace β] {s : Set α} {t : Set β} (hs : IsPreconnected s)\n    (ht : IsPreconnected t) : IsPreconnected (s ×ˢ t) := by\n  apply isPreconnected_of_forall_pair\n  rintro ⟨a₁, b₁⟩ ⟨ha₁, hb₁⟩ ⟨a₂, b₂⟩ ⟨ha₂, hb₂⟩\n  refine ⟨Prod.mk a₁ '' t ∪ flip Prod.mk b₂ '' s, ?_, .inl ⟨b₁, hb₁, rfl⟩, .inr ⟨a₂, ha₂, rfl⟩, ?_⟩\n  · rintro _ (⟨y, hy, rfl⟩ | ⟨x, hx, rfl⟩)\n    exacts [⟨ha₁, hy⟩, ⟨hx, hb₂⟩]\n  · exact (ht.image _ (Continuous.Prod.mk _).continuousOn).union (a₁, b₂) ⟨b₂, hb₂, rfl⟩\n      ⟨a₁, ha₁, rfl⟩ (hs.image _ (continuous_id.prod_mk continuous_const).continuousOn)\n\n"}
{"name":"IsConnected.prod","module":"Mathlib.Topology.Connected.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : TopologicalSpace α\ninst✝ : TopologicalSpace β\ns : Set α\nt : Set β\nhs : IsConnected s\nht : IsConnected t\n⊢ IsConnected (SProd.sprod s t)","decl":"theorem IsConnected.prod [TopologicalSpace β] {s : Set α} {t : Set β} (hs : IsConnected s)\n    (ht : IsConnected t) : IsConnected (s ×ˢ t) :=\n  ⟨hs.1.prod ht.1, hs.2.prod ht.2⟩\n\n"}
{"name":"isPreconnected_univ_pi","module":"Mathlib.Topology.Connected.Basic","initialProofState":"ι : Type u_1\nπ : ι → Type u_2\ninst✝ : (i : ι) → TopologicalSpace (π i)\ns : (i : ι) → Set (π i)\nhs : ∀ (i : ι), IsPreconnected (s i)\n⊢ IsPreconnected (Set.univ.pi s)","decl":"theorem isPreconnected_univ_pi [∀ i, TopologicalSpace (π i)] {s : ∀ i, Set (π i)}\n    (hs : ∀ i, IsPreconnected (s i)) : IsPreconnected (pi univ s) := by\n  rintro u v uo vo hsuv ⟨f, hfs, hfu⟩ ⟨g, hgs, hgv⟩\n  classical\n  rcases exists_finset_piecewise_mem_of_mem_nhds (uo.mem_nhds hfu) g with ⟨I, hI⟩\n  induction' I using Finset.induction_on with i I _ ihI\n  · refine ⟨g, hgs, ⟨?_, hgv⟩⟩\n    simpa using hI\n  · rw [Finset.piecewise_insert] at hI\n    have := I.piecewise_mem_set_pi hfs hgs\n    refine (hsuv this).elim ihI fun h => ?_\n    set S := update (I.piecewise f g) i '' s i\n    have hsub : S ⊆ pi univ s := by\n      refine image_subset_iff.2 fun z hz => ?_\n      rwa [update_preimage_univ_pi]\n      exact fun j _ => this j trivial\n    have hconn : IsPreconnected S :=\n      (hs i).image _ (continuous_const.update i continuous_id).continuousOn\n    have hSu : (S ∩ u).Nonempty := ⟨_, mem_image_of_mem _ (hfs _ trivial), hI⟩\n    have hSv : (S ∩ v).Nonempty := ⟨_, ⟨_, this _ trivial, update_eq_self _ _⟩, h⟩\n    refine (hconn u v uo vo (hsub.trans hsuv) hSu hSv).mono ?_\n    exact inter_subset_inter_left _ hsub\n\n"}
{"name":"isConnected_univ_pi","module":"Mathlib.Topology.Connected.Basic","initialProofState":"ι : Type u_1\nπ : ι → Type u_2\ninst✝ : (i : ι) → TopologicalSpace (π i)\ns : (i : ι) → Set (π i)\n⊢ Iff (IsConnected (Set.univ.pi s)) (∀ (i : ι), IsConnected (s i))","decl":"@[simp]\ntheorem isConnected_univ_pi [∀ i, TopologicalSpace (π i)] {s : ∀ i, Set (π i)} :\n    IsConnected (pi univ s) ↔ ∀ i, IsConnected (s i) := by\n  simp only [IsConnected, ← univ_pi_nonempty_iff, forall_and, and_congr_right_iff]\n  refine fun hne => ⟨fun hc i => ?_, isPreconnected_univ_pi⟩\n  rw [← eval_image_univ_pi hne]\n  exact hc.image _ (continuous_apply _).continuousOn\n\n"}
{"name":"connectedComponentIn_eq_image","module":"Mathlib.Topology.Connected.Basic","initialProofState":"α : Type u\ninst✝ : TopologicalSpace α\nF : Set α\nx : α\nh : Membership.mem F x\n⊢ Eq (connectedComponentIn F x) (Set.image Subtype.val (connectedComponent ⟨x, h⟩))","decl":"theorem connectedComponentIn_eq_image {F : Set α} {x : α} (h : x ∈ F) :\n    connectedComponentIn F x = (↑) '' connectedComponent (⟨x, h⟩ : F) :=\n  dif_pos h\n\n"}
{"name":"connectedComponentIn_eq_empty","module":"Mathlib.Topology.Connected.Basic","initialProofState":"α : Type u\ninst✝ : TopologicalSpace α\nF : Set α\nx : α\nh : Not (Membership.mem F x)\n⊢ Eq (connectedComponentIn F x) EmptyCollection.emptyCollection","decl":"theorem connectedComponentIn_eq_empty {F : Set α} {x : α} (h : x ∉ F) :\n    connectedComponentIn F x = ∅ :=\n  dif_neg h\n\n"}
{"name":"mem_connectedComponent","module":"Mathlib.Topology.Connected.Basic","initialProofState":"α : Type u\ninst✝ : TopologicalSpace α\nx : α\n⊢ Membership.mem (connectedComponent x) x","decl":"theorem mem_connectedComponent {x : α} : x ∈ connectedComponent x :=\n  mem_sUnion_of_mem (mem_singleton x) ⟨isPreconnected_singleton, mem_singleton x⟩\n\n"}
{"name":"mem_connectedComponentIn","module":"Mathlib.Topology.Connected.Basic","initialProofState":"α : Type u\ninst✝ : TopologicalSpace α\nx : α\nF : Set α\nhx : Membership.mem F x\n⊢ Membership.mem (connectedComponentIn F x) x","decl":"theorem mem_connectedComponentIn {x : α} {F : Set α} (hx : x ∈ F) :\n    x ∈ connectedComponentIn F x := by\n  simp [connectedComponentIn_eq_image hx, mem_connectedComponent, hx]\n\n"}
{"name":"connectedComponent_nonempty","module":"Mathlib.Topology.Connected.Basic","initialProofState":"α : Type u\ninst✝ : TopologicalSpace α\nx : α\n⊢ (connectedComponent x).Nonempty","decl":"theorem connectedComponent_nonempty {x : α} : (connectedComponent x).Nonempty :=\n  ⟨x, mem_connectedComponent⟩\n\n"}
{"name":"connectedComponentIn_nonempty_iff","module":"Mathlib.Topology.Connected.Basic","initialProofState":"α : Type u\ninst✝ : TopologicalSpace α\nx : α\nF : Set α\n⊢ Iff (connectedComponentIn F x).Nonempty (Membership.mem F x)","decl":"theorem connectedComponentIn_nonempty_iff {x : α} {F : Set α} :\n    (connectedComponentIn F x).Nonempty ↔ x ∈ F := by\n  rw [connectedComponentIn]\n  split_ifs <;> simp [connectedComponent_nonempty, *]\n\n"}
{"name":"connectedComponentIn_subset","module":"Mathlib.Topology.Connected.Basic","initialProofState":"α : Type u\ninst✝ : TopologicalSpace α\nF : Set α\nx : α\n⊢ HasSubset.Subset (connectedComponentIn F x) F","decl":"theorem connectedComponentIn_subset (F : Set α) (x : α) : connectedComponentIn F x ⊆ F := by\n  rw [connectedComponentIn]\n  split_ifs <;> simp\n\n"}
{"name":"isPreconnected_connectedComponent","module":"Mathlib.Topology.Connected.Basic","initialProofState":"α : Type u\ninst✝ : TopologicalSpace α\nx : α\n⊢ IsPreconnected (connectedComponent x)","decl":"theorem isPreconnected_connectedComponent {x : α} : IsPreconnected (connectedComponent x) :=\n  isPreconnected_sUnion x _ (fun _ => And.right) fun _ => And.left\n\n"}
{"name":"isPreconnected_connectedComponentIn","module":"Mathlib.Topology.Connected.Basic","initialProofState":"α : Type u\ninst✝ : TopologicalSpace α\nx : α\nF : Set α\n⊢ IsPreconnected (connectedComponentIn F x)","decl":"theorem isPreconnected_connectedComponentIn {x : α} {F : Set α} :\n    IsPreconnected (connectedComponentIn F x) := by\n  rw [connectedComponentIn]; split_ifs\n  · exact IsInducing.subtypeVal.isPreconnected_image.mpr isPreconnected_connectedComponent\n  · exact isPreconnected_empty\n\n"}
{"name":"isConnected_connectedComponent","module":"Mathlib.Topology.Connected.Basic","initialProofState":"α : Type u\ninst✝ : TopologicalSpace α\nx : α\n⊢ IsConnected (connectedComponent x)","decl":"theorem isConnected_connectedComponent {x : α} : IsConnected (connectedComponent x) :=\n  ⟨⟨x, mem_connectedComponent⟩, isPreconnected_connectedComponent⟩\n\n"}
{"name":"isConnected_connectedComponentIn_iff","module":"Mathlib.Topology.Connected.Basic","initialProofState":"α : Type u\ninst✝ : TopologicalSpace α\nx : α\nF : Set α\n⊢ Iff (IsConnected (connectedComponentIn F x)) (Membership.mem F x)","decl":"theorem isConnected_connectedComponentIn_iff {x : α} {F : Set α} :\n    IsConnected (connectedComponentIn F x) ↔ x ∈ F := by\n  simp_rw [← connectedComponentIn_nonempty_iff, IsConnected, isPreconnected_connectedComponentIn,\n    and_true]\n\n"}
{"name":"IsPreconnected.subset_connectedComponent","module":"Mathlib.Topology.Connected.Basic","initialProofState":"α : Type u\ninst✝ : TopologicalSpace α\nx : α\ns : Set α\nH1 : IsPreconnected s\nH2 : Membership.mem s x\n⊢ HasSubset.Subset s (connectedComponent x)","decl":"theorem IsPreconnected.subset_connectedComponent {x : α} {s : Set α} (H1 : IsPreconnected s)\n    (H2 : x ∈ s) : s ⊆ connectedComponent x := fun _z hz => mem_sUnion_of_mem hz ⟨H1, H2⟩\n\n"}
{"name":"IsPreconnected.subset_connectedComponentIn","module":"Mathlib.Topology.Connected.Basic","initialProofState":"α : Type u\ninst✝ : TopologicalSpace α\ns : Set α\nx : α\nF : Set α\nhs : IsPreconnected s\nhxs : Membership.mem s x\nhsF : HasSubset.Subset s F\n⊢ HasSubset.Subset s (connectedComponentIn F x)","decl":"theorem IsPreconnected.subset_connectedComponentIn {x : α} {F : Set α} (hs : IsPreconnected s)\n    (hxs : x ∈ s) (hsF : s ⊆ F) : s ⊆ connectedComponentIn F x := by\n  have : IsPreconnected (((↑) : F → α) ⁻¹' s) := by\n    refine IsInducing.subtypeVal.isPreconnected_image.mp ?_\n    rwa [Subtype.image_preimage_coe, inter_eq_right.mpr hsF]\n  have h2xs : (⟨x, hsF hxs⟩ : F) ∈ (↑) ⁻¹' s := by\n    rw [mem_preimage]\n    exact hxs\n  have := this.subset_connectedComponent h2xs\n  rw [connectedComponentIn_eq_image (hsF hxs)]\n  refine Subset.trans ?_ (image_subset _ this)\n  rw [Subtype.image_preimage_coe, inter_eq_right.mpr hsF]\n\n"}
{"name":"IsConnected.subset_connectedComponent","module":"Mathlib.Topology.Connected.Basic","initialProofState":"α : Type u\ninst✝ : TopologicalSpace α\nx : α\ns : Set α\nH1 : IsConnected s\nH2 : Membership.mem s x\n⊢ HasSubset.Subset s (connectedComponent x)","decl":"theorem IsConnected.subset_connectedComponent {x : α} {s : Set α} (H1 : IsConnected s)\n    (H2 : x ∈ s) : s ⊆ connectedComponent x :=\n  H1.2.subset_connectedComponent H2\n\n"}
{"name":"IsPreconnected.connectedComponentIn","module":"Mathlib.Topology.Connected.Basic","initialProofState":"α : Type u\ninst✝ : TopologicalSpace α\nx : α\nF : Set α\nh : IsPreconnected F\nhx : Membership.mem F x\n⊢ Eq (connectedComponentIn F x) F","decl":"theorem IsPreconnected.connectedComponentIn {x : α} {F : Set α} (h : IsPreconnected F)\n    (hx : x ∈ F) : connectedComponentIn F x = F :=\n  (connectedComponentIn_subset F x).antisymm (h.subset_connectedComponentIn hx subset_rfl)\n\n"}
{"name":"connectedComponent_eq","module":"Mathlib.Topology.Connected.Basic","initialProofState":"α : Type u\ninst✝ : TopologicalSpace α\nx y : α\nh : Membership.mem (connectedComponent x) y\n⊢ Eq (connectedComponent x) (connectedComponent y)","decl":"theorem connectedComponent_eq {x y : α} (h : y ∈ connectedComponent x) :\n    connectedComponent x = connectedComponent y :=\n  eq_of_subset_of_subset (isConnected_connectedComponent.subset_connectedComponent h)\n    (isConnected_connectedComponent.subset_connectedComponent\n      (Set.mem_of_mem_of_subset mem_connectedComponent\n        (isConnected_connectedComponent.subset_connectedComponent h)))\n\n"}
{"name":"connectedComponent_eq_iff_mem","module":"Mathlib.Topology.Connected.Basic","initialProofState":"α : Type u\ninst✝ : TopologicalSpace α\nx y : α\n⊢ Iff (Eq (connectedComponent x) (connectedComponent y)) (Membership.mem (connectedComponent y) x)","decl":"theorem connectedComponent_eq_iff_mem {x y : α} :\n    connectedComponent x = connectedComponent y ↔ x ∈ connectedComponent y :=\n  ⟨fun h => h ▸ mem_connectedComponent, fun h => (connectedComponent_eq h).symm⟩\n\n"}
{"name":"connectedComponentIn_eq","module":"Mathlib.Topology.Connected.Basic","initialProofState":"α : Type u\ninst✝ : TopologicalSpace α\nx y : α\nF : Set α\nh : Membership.mem (connectedComponentIn F x) y\n⊢ Eq (connectedComponentIn F x) (connectedComponentIn F y)","decl":"theorem connectedComponentIn_eq {x y : α} {F : Set α} (h : y ∈ connectedComponentIn F x) :\n    connectedComponentIn F x = connectedComponentIn F y := by\n  have hx : x ∈ F := connectedComponentIn_nonempty_iff.mp ⟨y, h⟩\n  simp_rw [connectedComponentIn_eq_image hx] at h ⊢\n  obtain ⟨⟨y, hy⟩, h2y, rfl⟩ := h\n  simp_rw [connectedComponentIn_eq_image hy, connectedComponent_eq h2y]\n\n"}
{"name":"connectedComponentIn_univ","module":"Mathlib.Topology.Connected.Basic","initialProofState":"α : Type u\ninst✝ : TopologicalSpace α\nx : α\n⊢ Eq (connectedComponentIn Set.univ x) (connectedComponent x)","decl":"theorem connectedComponentIn_univ (x : α) : connectedComponentIn univ x = connectedComponent x :=\n  subset_antisymm\n    (isPreconnected_connectedComponentIn.subset_connectedComponent <|\n      mem_connectedComponentIn trivial)\n    (isPreconnected_connectedComponent.subset_connectedComponentIn mem_connectedComponent <|\n      subset_univ _)\n\n"}
{"name":"connectedComponent_disjoint","module":"Mathlib.Topology.Connected.Basic","initialProofState":"α : Type u\ninst✝ : TopologicalSpace α\nx y : α\nh : Ne (connectedComponent x) (connectedComponent y)\n⊢ Disjoint (connectedComponent x) (connectedComponent y)","decl":"theorem connectedComponent_disjoint {x y : α} (h : connectedComponent x ≠ connectedComponent y) :\n    Disjoint (connectedComponent x) (connectedComponent y) :=\n  Set.disjoint_left.2 fun _ h1 h2 =>\n    h ((connectedComponent_eq h1).trans (connectedComponent_eq h2).symm)\n\n"}
{"name":"isClosed_connectedComponent","module":"Mathlib.Topology.Connected.Basic","initialProofState":"α : Type u\ninst✝ : TopologicalSpace α\nx : α\n⊢ IsClosed (connectedComponent x)","decl":"theorem isClosed_connectedComponent {x : α} : IsClosed (connectedComponent x) :=\n  closure_subset_iff_isClosed.1 <|\n    isConnected_connectedComponent.closure.subset_connectedComponent <|\n      subset_closure mem_connectedComponent\n\n"}
{"name":"Continuous.image_connectedComponent_subset","module":"Mathlib.Topology.Connected.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : TopologicalSpace α\ninst✝ : TopologicalSpace β\nf : α → β\nh : Continuous f\na : α\n⊢ HasSubset.Subset (Set.image f (connectedComponent a)) (connectedComponent (f a))","decl":"theorem Continuous.image_connectedComponent_subset [TopologicalSpace β] {f : α → β}\n    (h : Continuous f) (a : α) : f '' connectedComponent a ⊆ connectedComponent (f a) :=\n  (isConnected_connectedComponent.image f h.continuousOn).subset_connectedComponent\n    ((mem_image f (connectedComponent a) (f a)).2 ⟨a, mem_connectedComponent, rfl⟩)\n\n"}
{"name":"Continuous.image_connectedComponentIn_subset","module":"Mathlib.Topology.Connected.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : TopologicalSpace α\ninst✝ : TopologicalSpace β\nf : α → β\ns : Set α\na : α\nhf : Continuous f\nhx : Membership.mem s a\n⊢ HasSubset.Subset (Set.image f (connectedComponentIn s a)) (connectedComponentIn (Set.image f s) (f a))","decl":"theorem Continuous.image_connectedComponentIn_subset [TopologicalSpace β] {f : α → β} {s : Set α}\n    {a : α} (hf : Continuous f) (hx : a ∈ s) :\n    f '' connectedComponentIn s a ⊆ connectedComponentIn (f '' s) (f a) :=\n  (isPreconnected_connectedComponentIn.image _ hf.continuousOn).subset_connectedComponentIn\n    (mem_image_of_mem _ <| mem_connectedComponentIn hx)\n    (image_subset _ <| connectedComponentIn_subset _ _)\n\n"}
{"name":"Continuous.mapsTo_connectedComponent","module":"Mathlib.Topology.Connected.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : TopologicalSpace α\ninst✝ : TopologicalSpace β\nf : α → β\nh : Continuous f\na : α\n⊢ Set.MapsTo f (connectedComponent a) (connectedComponent (f a))","decl":"theorem Continuous.mapsTo_connectedComponent [TopologicalSpace β] {f : α → β} (h : Continuous f)\n    (a : α) : MapsTo f (connectedComponent a) (connectedComponent (f a)) :=\n  mapsTo'.2 <| h.image_connectedComponent_subset a\n\n"}
{"name":"Continuous.mapsTo_connectedComponentIn","module":"Mathlib.Topology.Connected.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : TopologicalSpace α\ninst✝ : TopologicalSpace β\nf : α → β\ns : Set α\nh : Continuous f\na : α\nhx : Membership.mem s a\n⊢ Set.MapsTo f (connectedComponentIn s a) (connectedComponentIn (Set.image f s) (f a))","decl":"theorem Continuous.mapsTo_connectedComponentIn [TopologicalSpace β] {f : α → β} {s : Set α}\n    (h : Continuous f) {a : α} (hx : a ∈ s) :\n    MapsTo f (connectedComponentIn s a) (connectedComponentIn (f '' s) (f a)) :=\n  mapsTo'.2 <| image_connectedComponentIn_subset h hx\n\n"}
{"name":"irreducibleComponent_subset_connectedComponent","module":"Mathlib.Topology.Connected.Basic","initialProofState":"α : Type u\ninst✝ : TopologicalSpace α\nx : α\n⊢ HasSubset.Subset (irreducibleComponent x) (connectedComponent x)","decl":"theorem irreducibleComponent_subset_connectedComponent {x : α} :\n    irreducibleComponent x ⊆ connectedComponent x :=\n  isIrreducible_irreducibleComponent.isConnected.subset_connectedComponent mem_irreducibleComponent\n\n"}
{"name":"connectedComponentIn_mono","module":"Mathlib.Topology.Connected.Basic","initialProofState":"α : Type u\ninst✝ : TopologicalSpace α\nx : α\nF G : Set α\nh : HasSubset.Subset F G\n⊢ HasSubset.Subset (connectedComponentIn F x) (connectedComponentIn G x)","decl":"@[mono]\ntheorem connectedComponentIn_mono (x : α) {F G : Set α} (h : F ⊆ G) :\n    connectedComponentIn F x ⊆ connectedComponentIn G x := by\n  by_cases hx : x ∈ F\n  · rw [connectedComponentIn_eq_image hx, connectedComponentIn_eq_image (h hx), ←\n      show ((↑) : G → α) ∘ inclusion h = (↑) from rfl, image_comp]\n    exact image_subset _ ((continuous_inclusion h).image_connectedComponent_subset ⟨x, hx⟩)\n  · rw [connectedComponentIn_eq_empty hx]\n    exact Set.empty_subset _\n\n"}
{"name":"PreconnectedSpace.isPreconnected_univ","module":"Mathlib.Topology.Connected.Basic","initialProofState":"α : Type u\ninst✝ : TopologicalSpace α\nself : PreconnectedSpace α\n⊢ IsPreconnected Set.univ","decl":"/-- A preconnected space is one where there is no non-trivial open partition. -/\nclass PreconnectedSpace (α : Type u) [TopologicalSpace α] : Prop where\n  /-- The universal set `Set.univ` in a preconnected space is a preconnected set. -/\n  isPreconnected_univ : IsPreconnected (univ : Set α)\n\n"}
{"name":"ConnectedSpace.toNonempty","module":"Mathlib.Topology.Connected.Basic","initialProofState":"α : Type u\ninst✝ : TopologicalSpace α\nself : ConnectedSpace α\n⊢ Nonempty α","decl":"/-- A connected space is a nonempty one where there is no non-trivial open partition. -/\nclass ConnectedSpace (α : Type u) [TopologicalSpace α] extends PreconnectedSpace α : Prop where\n  /-- A connected space is nonempty. -/\n  toNonempty : Nonempty α\n\n"}
{"name":"ConnectedSpace.toPreconnectedSpace","module":"Mathlib.Topology.Connected.Basic","initialProofState":"α : Type u\ninst✝ : TopologicalSpace α\nself : ConnectedSpace α\n⊢ PreconnectedSpace α","decl":"/-- A connected space is a nonempty one where there is no non-trivial open partition. -/\nclass ConnectedSpace (α : Type u) [TopologicalSpace α] extends PreconnectedSpace α : Prop where\n  /-- A connected space is nonempty. -/\n  toNonempty : Nonempty α\n\n"}
{"name":"isConnected_univ","module":"Mathlib.Topology.Connected.Basic","initialProofState":"α : Type u\ninst✝¹ : TopologicalSpace α\ninst✝ : ConnectedSpace α\n⊢ IsConnected Set.univ","decl":"theorem isConnected_univ [ConnectedSpace α] : IsConnected (univ : Set α) :=\n  ⟨univ_nonempty, isPreconnected_univ⟩\n\n"}
{"name":"preconnectedSpace_iff_univ","module":"Mathlib.Topology.Connected.Basic","initialProofState":"α : Type u\ninst✝ : TopologicalSpace α\n⊢ Iff (PreconnectedSpace α) (IsPreconnected Set.univ)","decl":"lemma preconnectedSpace_iff_univ : PreconnectedSpace α ↔ IsPreconnected (univ : Set α) :=\n  ⟨fun h ↦ h.1, fun h ↦ ⟨h⟩⟩\n\n"}
{"name":"connectedSpace_iff_univ","module":"Mathlib.Topology.Connected.Basic","initialProofState":"α : Type u\ninst✝ : TopologicalSpace α\n⊢ Iff (ConnectedSpace α) (IsConnected Set.univ)","decl":"lemma connectedSpace_iff_univ : ConnectedSpace α ↔ IsConnected (univ : Set α) :=\n  ⟨fun h ↦ ⟨univ_nonempty, h.1.1⟩,\n   fun h ↦ ConnectedSpace.mk (toPreconnectedSpace := ⟨h.2⟩) ⟨h.1.some⟩⟩\n\n"}
{"name":"isPreconnected_range","module":"Mathlib.Topology.Connected.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝² : TopologicalSpace α\ninst✝¹ : TopologicalSpace β\ninst✝ : PreconnectedSpace α\nf : α → β\nh : Continuous f\n⊢ IsPreconnected (Set.range f)","decl":"theorem isPreconnected_range [TopologicalSpace β] [PreconnectedSpace α] {f : α → β}\n    (h : Continuous f) : IsPreconnected (range f) :=\n  @image_univ _ _ f ▸ isPreconnected_univ.image _ h.continuousOn\n\n"}
{"name":"isConnected_range","module":"Mathlib.Topology.Connected.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝² : TopologicalSpace α\ninst✝¹ : TopologicalSpace β\ninst✝ : ConnectedSpace α\nf : α → β\nh : Continuous f\n⊢ IsConnected (Set.range f)","decl":"theorem isConnected_range [TopologicalSpace β] [ConnectedSpace α] {f : α → β} (h : Continuous f) :\n    IsConnected (range f) :=\n  ⟨range_nonempty f, isPreconnected_range h⟩\n\n"}
{"name":"Function.Surjective.connectedSpace","module":"Mathlib.Topology.Connected.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝² : TopologicalSpace α\ninst✝¹ : ConnectedSpace α\ninst✝ : TopologicalSpace β\nf : α → β\nhf : Function.Surjective f\nhf' : Continuous f\n⊢ ConnectedSpace β","decl":"theorem Function.Surjective.connectedSpace [ConnectedSpace α] [TopologicalSpace β]\n    {f : α → β} (hf : Surjective f) (hf' : Continuous f) : ConnectedSpace β := by\n  rw [connectedSpace_iff_univ, ← hf.range_eq]\n  exact isConnected_range hf'\n\n"}
{"name":"Quotient.instConnectedSpace","module":"Mathlib.Topology.Connected.Basic","initialProofState":"α : Type u\ninst✝¹ : TopologicalSpace α\ns : Setoid α\ninst✝ : ConnectedSpace α\n⊢ ConnectedSpace (Quotient s)","decl":"instance Quotient.instConnectedSpace {s : Setoid α} [ConnectedSpace α] :\n    ConnectedSpace (Quotient s) :=\n  Quotient.mk'_surjective.connectedSpace continuous_coinduced_rng\n\n"}
{"name":"DenseRange.preconnectedSpace","module":"Mathlib.Topology.Connected.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝² : TopologicalSpace α\ninst✝¹ : TopologicalSpace β\ninst✝ : PreconnectedSpace α\nf : α → β\nhf : DenseRange f\nhc : Continuous f\n⊢ PreconnectedSpace β","decl":"theorem DenseRange.preconnectedSpace [TopologicalSpace β] [PreconnectedSpace α] {f : α → β}\n    (hf : DenseRange f) (hc : Continuous f) : PreconnectedSpace β :=\n  ⟨hf.closure_eq ▸ (isPreconnected_range hc).closure⟩\n\n"}
{"name":"connectedSpace_iff_connectedComponent","module":"Mathlib.Topology.Connected.Basic","initialProofState":"α : Type u\ninst✝ : TopologicalSpace α\n⊢ Iff (ConnectedSpace α) (Exists fun x => Eq (connectedComponent x) Set.univ)","decl":"theorem connectedSpace_iff_connectedComponent :\n    ConnectedSpace α ↔ ∃ x : α, connectedComponent x = univ := by\n  constructor\n  · rintro ⟨⟨x⟩⟩\n    exact\n      ⟨x, eq_univ_of_univ_subset <| isPreconnected_univ.subset_connectedComponent (mem_univ x)⟩\n  · rintro ⟨x, h⟩\n    haveI : PreconnectedSpace α :=\n      ⟨by rw [← h]; exact isPreconnected_connectedComponent⟩\n    exact ⟨⟨x⟩⟩\n\n"}
{"name":"preconnectedSpace_iff_connectedComponent","module":"Mathlib.Topology.Connected.Basic","initialProofState":"α : Type u\ninst✝ : TopologicalSpace α\n⊢ Iff (PreconnectedSpace α) (∀ (x : α), Eq (connectedComponent x) Set.univ)","decl":"theorem preconnectedSpace_iff_connectedComponent :\n    PreconnectedSpace α ↔ ∀ x : α, connectedComponent x = univ := by\n  constructor\n  · intro h x\n    exact eq_univ_of_univ_subset <| isPreconnected_univ.subset_connectedComponent (mem_univ x)\n  · intro h\n    cases' isEmpty_or_nonempty α with hα hα\n    · exact ⟨by rw [univ_eq_empty_iff.mpr hα]; exact isPreconnected_empty⟩\n    · exact ⟨by rw [← h (Classical.choice hα)]; exact isPreconnected_connectedComponent⟩\n\n"}
{"name":"PreconnectedSpace.connectedComponent_eq_univ","module":"Mathlib.Topology.Connected.Basic","initialProofState":"X : Type u_3\ninst✝ : TopologicalSpace X\nh : PreconnectedSpace X\nx : X\n⊢ Eq (connectedComponent x) Set.univ","decl":"@[simp]\ntheorem PreconnectedSpace.connectedComponent_eq_univ {X : Type*} [TopologicalSpace X]\n    [h : PreconnectedSpace X] (x : X) : connectedComponent x = univ :=\n  preconnectedSpace_iff_connectedComponent.mp h x\n\n"}
{"name":"instPreconnectedSpaceProd","module":"Mathlib.Topology.Connected.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝³ : TopologicalSpace α\ninst✝² : TopologicalSpace β\ninst✝¹ : PreconnectedSpace α\ninst✝ : PreconnectedSpace β\n⊢ PreconnectedSpace (Prod α β)","decl":"instance [TopologicalSpace β] [PreconnectedSpace α] [PreconnectedSpace β] :\n    PreconnectedSpace (α × β) :=\n  ⟨by\n    rw [← univ_prod_univ]\n    exact isPreconnected_univ.prod isPreconnected_univ⟩\n\n"}
{"name":"instConnectedSpaceProd","module":"Mathlib.Topology.Connected.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝³ : TopologicalSpace α\ninst✝² : TopologicalSpace β\ninst✝¹ : ConnectedSpace α\ninst✝ : ConnectedSpace β\n⊢ ConnectedSpace (Prod α β)","decl":"instance [TopologicalSpace β] [ConnectedSpace α] [ConnectedSpace β] : ConnectedSpace (α × β) :=\n  ⟨inferInstance⟩\n\n"}
{"name":"instPreconnectedSpaceForall","module":"Mathlib.Topology.Connected.Basic","initialProofState":"ι : Type u_1\nπ : ι → Type u_2\ninst✝¹ : (i : ι) → TopologicalSpace (π i)\ninst✝ : ∀ (i : ι), PreconnectedSpace (π i)\n⊢ PreconnectedSpace ((i : ι) → π i)","decl":"instance [∀ i, TopologicalSpace (π i)] [∀ i, PreconnectedSpace (π i)] :\n    PreconnectedSpace (∀ i, π i) :=\n  ⟨by rw [← pi_univ univ]; exact isPreconnected_univ_pi fun i => isPreconnected_univ⟩\n\n"}
{"name":"instConnectedSpaceForall","module":"Mathlib.Topology.Connected.Basic","initialProofState":"ι : Type u_1\nπ : ι → Type u_2\ninst✝¹ : (i : ι) → TopologicalSpace (π i)\ninst✝ : ∀ (i : ι), ConnectedSpace (π i)\n⊢ ConnectedSpace ((i : ι) → π i)","decl":"instance [∀ i, TopologicalSpace (π i)] [∀ i, ConnectedSpace (π i)] : ConnectedSpace (∀ i, π i) :=\n  ⟨inferInstance⟩\n\n-- see Note [lower instance priority]\n"}
{"name":"PreirreducibleSpace.preconnectedSpace","module":"Mathlib.Topology.Connected.Basic","initialProofState":"α : Type u\ninst✝¹ : TopologicalSpace α\ninst✝ : PreirreducibleSpace α\n⊢ PreconnectedSpace α","decl":"instance (priority := 100) PreirreducibleSpace.preconnectedSpace (α : Type u) [TopologicalSpace α]\n    [PreirreducibleSpace α] : PreconnectedSpace α :=\n  ⟨isPreirreducible_univ.isPreconnected⟩\n\n-- see Note [lower instance priority]\n"}
{"name":"IrreducibleSpace.connectedSpace","module":"Mathlib.Topology.Connected.Basic","initialProofState":"α : Type u\ninst✝¹ : TopologicalSpace α\ninst✝ : IrreducibleSpace α\n⊢ ConnectedSpace α","decl":"instance (priority := 100) IrreducibleSpace.connectedSpace (α : Type u) [TopologicalSpace α]\n    [IrreducibleSpace α] : ConnectedSpace α where toNonempty := IrreducibleSpace.toNonempty\n\n"}
{"name":"Subtype.preconnectedSpace","module":"Mathlib.Topology.Connected.Basic","initialProofState":"α : Type u\ninst✝ : TopologicalSpace α\ns : Set α\nh : IsPreconnected s\n⊢ PreconnectedSpace ↑s","decl":"theorem Subtype.preconnectedSpace {s : Set α} (h : IsPreconnected s) : PreconnectedSpace s where\n  isPreconnected_univ := by\n    rwa [← IsInducing.subtypeVal.isPreconnected_image, image_univ, Subtype.range_val]\n\n"}
{"name":"Subtype.connectedSpace","module":"Mathlib.Topology.Connected.Basic","initialProofState":"α : Type u\ninst✝ : TopologicalSpace α\ns : Set α\nh : IsConnected s\n⊢ ConnectedSpace ↑s","decl":"theorem Subtype.connectedSpace {s : Set α} (h : IsConnected s) : ConnectedSpace s where\n  toPreconnectedSpace := Subtype.preconnectedSpace h.isPreconnected\n  toNonempty := h.nonempty.to_subtype\n\n"}
{"name":"isPreconnected_iff_preconnectedSpace","module":"Mathlib.Topology.Connected.Basic","initialProofState":"α : Type u\ninst✝ : TopologicalSpace α\ns : Set α\n⊢ Iff (IsPreconnected s) (PreconnectedSpace ↑s)","decl":"theorem isPreconnected_iff_preconnectedSpace {s : Set α} : IsPreconnected s ↔ PreconnectedSpace s :=\n  ⟨Subtype.preconnectedSpace, fun h => by\n    simpa using isPreconnected_univ.image ((↑) : s → α) continuous_subtype_val.continuousOn⟩\n\n"}
{"name":"isConnected_iff_connectedSpace","module":"Mathlib.Topology.Connected.Basic","initialProofState":"α : Type u\ninst✝ : TopologicalSpace α\ns : Set α\n⊢ Iff (IsConnected s) (ConnectedSpace ↑s)","decl":"theorem isConnected_iff_connectedSpace {s : Set α} : IsConnected s ↔ ConnectedSpace s :=\n  ⟨Subtype.connectedSpace, fun h =>\n    ⟨nonempty_subtype.mp h.2, isPreconnected_iff_preconnectedSpace.mpr h.1⟩⟩\n\n"}
