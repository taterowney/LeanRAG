{"name":"List.coe_toFinsupp","module":"Mathlib.Data.List.ToFinsupp","initialProofState":"M : Type u_1\ninst✝¹ : Zero M\nl : List M\ninst✝ : DecidablePred fun x => Ne (l.getD x 0) 0\n⊢ Eq ⇑l.toFinsupp fun x => l.getD x 0","decl":"@[norm_cast]\ntheorem coe_toFinsupp : (l.toFinsupp : ℕ → M) = (l.getD · 0) :=\n  rfl\n\n"}
{"name":"List.toFinsupp_apply","module":"Mathlib.Data.List.ToFinsupp","initialProofState":"M : Type u_1\ninst✝¹ : Zero M\nl : List M\ninst✝ : DecidablePred fun x => Ne (l.getD x 0) 0\ni : Nat\n⊢ Eq (l.toFinsupp i) (l.getD i 0)","decl":"@[simp, norm_cast]\ntheorem toFinsupp_apply (i : ℕ) : (l.toFinsupp : ℕ → M) i = l.getD i 0 :=\n  rfl\n\n"}
{"name":"List.toFinsupp_support","module":"Mathlib.Data.List.ToFinsupp","initialProofState":"M : Type u_1\ninst✝¹ : Zero M\nl : List M\ninst✝ : DecidablePred fun x => Ne (l.getD x 0) 0\n⊢ Eq l.toFinsupp.support (Finset.filter (fun x => Ne (l.getD x 0) 0) (Finset.range l.length))","decl":"theorem toFinsupp_support :\n    l.toFinsupp.support = (Finset.range l.length).filter (getD l · 0 ≠ 0) :=\n  rfl\n\n"}
{"name":"List.toFinsupp_apply_lt","module":"Mathlib.Data.List.ToFinsupp","initialProofState":"M : Type u_1\ninst✝¹ : Zero M\nl : List M\ninst✝ : DecidablePred fun x => Ne (l.getD x 0) 0\nn : Nat\nhn : LT.lt n l.length\n⊢ Eq (l.toFinsupp n) (GetElem.getElem l n ⋯)","decl":"theorem toFinsupp_apply_lt (hn : n < l.length) : l.toFinsupp n = l[n] :=\n  getD_eq_getElem _ _ hn\n\n"}
{"name":"List.toFinsupp_apply_fin","module":"Mathlib.Data.List.ToFinsupp","initialProofState":"M : Type u_1\ninst✝¹ : Zero M\nl : List M\ninst✝ : DecidablePred fun x => Ne (l.getD x 0) 0\nn : Fin l.length\n⊢ Eq (l.toFinsupp ↑n) (GetElem.getElem l n ⋯)","decl":"theorem toFinsupp_apply_fin (n : Fin l.length) : l.toFinsupp n = l[n] :=\n  getD_eq_getElem _ _ n.isLt\n\n"}
{"name":"List.toFinsupp_apply_le","module":"Mathlib.Data.List.ToFinsupp","initialProofState":"M : Type u_1\ninst✝¹ : Zero M\nl : List M\ninst✝ : DecidablePred fun x => Ne (l.getD x 0) 0\nn : Nat\nhn : LE.le l.length n\n⊢ Eq (l.toFinsupp n) 0","decl":"theorem toFinsupp_apply_le (hn : l.length ≤ n) : l.toFinsupp n = 0 :=\n  getD_eq_default _ _ hn\n\n"}
{"name":"List.toFinsupp_nil","module":"Mathlib.Data.List.ToFinsupp","initialProofState":"M : Type u_1\ninst✝¹ : Zero M\ninst✝ : DecidablePred fun i => Ne (List.nil.getD i 0) 0\n⊢ Eq List.nil.toFinsupp 0","decl":"@[simp]\ntheorem toFinsupp_nil [DecidablePred fun i => getD ([] : List M) i 0 ≠ 0] :\n    toFinsupp ([] : List M) = 0 := by\n  ext\n  simp\n\n"}
{"name":"List.toFinsupp_singleton","module":"Mathlib.Data.List.ToFinsupp","initialProofState":"M : Type u_1\ninst✝¹ : Zero M\nx : M\ninst✝ : DecidablePred fun x_1 => Ne ((List.cons x List.nil).getD x_1 0) 0\n⊢ Eq (List.cons x List.nil).toFinsupp (Finsupp.single 0 x)","decl":"theorem toFinsupp_singleton (x : M) [DecidablePred (getD [x] · 0 ≠ 0)] :\n    toFinsupp [x] = Finsupp.single 0 x := by\n  ext ⟨_ | i⟩ <;> simp [Finsupp.single_apply, (Nat.zero_lt_succ _).ne]\n\n"}
{"name":"List.toFinsupp_append","module":"Mathlib.Data.List.ToFinsupp","initialProofState":"R : Type u_2\ninst✝³ : AddZeroClass R\nl₁ l₂ : List R\ninst✝² : DecidablePred fun x => Ne ((HAppend.hAppend l₁ l₂).getD x 0) 0\ninst✝¹ : DecidablePred fun x => Ne (l₁.getD x 0) 0\ninst✝ : DecidablePred fun x => Ne (l₂.getD x 0) 0\n⊢ Eq (HAppend.hAppend l₁ l₂).toFinsupp (HAdd.hAdd l₁.toFinsupp (Finsupp.embDomain (addLeftEmbedding l₁.length) l₂.toFinsupp))","decl":"theorem toFinsupp_append {R : Type*} [AddZeroClass R] (l₁ l₂ : List R)\n    [DecidablePred (getD (l₁ ++ l₂) · 0 ≠ 0)] [DecidablePred (getD l₁ · 0 ≠ 0)]\n    [DecidablePred (getD l₂ · 0 ≠ 0)] :\n    toFinsupp (l₁ ++ l₂) =\n      toFinsupp l₁ + (toFinsupp l₂).embDomain (addLeftEmbedding l₁.length) := by\n  ext n\n  simp only [toFinsupp_apply, Finsupp.add_apply]\n  cases lt_or_le n l₁.length with\n  | inl h =>\n    rw [getD_append _ _ _ _ h, Finsupp.embDomain_notin_range, add_zero]\n    rintro ⟨k, rfl : length l₁ + k = n⟩\n    omega\n  | inr h =>\n    rcases Nat.exists_eq_add_of_le h with ⟨k, rfl⟩\n    rw [getD_append_right _ _ _ _ h, Nat.add_sub_cancel_left, getD_eq_default _ _ h, zero_add]\n    exact Eq.symm (Finsupp.embDomain_apply _ _ _)\n\n"}
{"name":"List.toFinsupp_cons_eq_single_add_embDomain","module":"Mathlib.Data.List.ToFinsupp","initialProofState":"R : Type u_2\ninst✝² : AddZeroClass R\nx : R\nxs : List R\ninst✝¹ : DecidablePred fun x_1 => Ne ((List.cons x xs).getD x_1 0) 0\ninst✝ : DecidablePred fun x => Ne (xs.getD x 0) 0\n⊢ Eq (List.cons x xs).toFinsupp (HAdd.hAdd (Finsupp.single 0 x) (Finsupp.embDomain { toFun := Nat.succ, inj' := Nat.succ_injective } xs.toFinsupp))","decl":"theorem toFinsupp_cons_eq_single_add_embDomain {R : Type*} [AddZeroClass R] (x : R) (xs : List R)\n    [DecidablePred (getD (x::xs) · 0 ≠ 0)] [DecidablePred (getD xs · 0 ≠ 0)] :\n    toFinsupp (x::xs) =\n      Finsupp.single 0 x + (toFinsupp xs).embDomain ⟨Nat.succ, Nat.succ_injective⟩ := by\n  classical\n    convert toFinsupp_append [x] xs using 3\n    · exact (toFinsupp_singleton x).symm\n    · ext n\n      exact add_comm n 1\n\n"}
{"name":"List.toFinsupp_concat_eq_toFinsupp_add_single","module":"Mathlib.Data.List.ToFinsupp","initialProofState":"R : Type u_2\ninst✝² : AddZeroClass R\nx : R\nxs : List R\ninst✝¹ : DecidablePred fun i => Ne ((HAppend.hAppend xs (List.cons x List.nil)).getD i 0) 0\ninst✝ : DecidablePred fun i => Ne (xs.getD i 0) 0\n⊢ Eq (HAppend.hAppend xs (List.cons x List.nil)).toFinsupp (HAdd.hAdd xs.toFinsupp (Finsupp.single xs.length x))","decl":"theorem toFinsupp_concat_eq_toFinsupp_add_single {R : Type*} [AddZeroClass R] (x : R) (xs : List R)\n    [DecidablePred fun i => getD (xs ++ [x]) i 0 ≠ 0] [DecidablePred fun i => getD xs i 0 ≠ 0] :\n    toFinsupp (xs ++ [x]) = toFinsupp xs + Finsupp.single xs.length x := by\n  classical rw [toFinsupp_append, toFinsupp_singleton, Finsupp.embDomain_single,\n    addLeftEmbedding_apply, add_zero]\n\n\n"}
{"name":"List.toFinsupp_eq_sum_map_enum_single","module":"Mathlib.Data.List.ToFinsupp","initialProofState":"R : Type u_2\ninst✝¹ : AddMonoid R\nl : List R\ninst✝ : DecidablePred fun x => Ne (l.getD x 0) 0\n⊢ Eq l.toFinsupp (List.map (fun nr => Finsupp.single nr.1 nr.2) l.enum).sum","decl":"theorem toFinsupp_eq_sum_map_enum_single {R : Type*} [AddMonoid R] (l : List R)\n    [DecidablePred (getD l · 0 ≠ 0)] :\n    toFinsupp l = (l.enum.map fun nr : ℕ × R => Finsupp.single nr.1 nr.2).sum := by\n  /- Porting note (https://github.com/leanprover-community/mathlib4/issues/11215): TODO: `induction` fails to substitute `l = []` in\n  `[DecidablePred (getD l · 0 ≠ 0)]`, so we manually do some `revert`/`intro` as a workaround -/\n  revert l; intro l\n  induction l using List.reverseRecOn with\n  | nil => exact toFinsupp_nil\n  | append_singleton x xs ih =>\n    classical simp [toFinsupp_concat_eq_toFinsupp_add_single, enum_append, ih]\n\n"}
