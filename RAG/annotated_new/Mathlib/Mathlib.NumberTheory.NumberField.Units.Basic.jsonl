{"name":"Rat.RingOfIntegers.isUnit_iff","module":"Mathlib.NumberTheory.NumberField.Units.Basic","initialProofState":"x : NumberField.RingOfIntegers Rat\n⊢ Iff (IsUnit x) (Or (Eq (↑x) 1) (Eq (↑x) (-1)))","decl":"theorem Rat.RingOfIntegers.isUnit_iff {x : 𝓞 ℚ} : IsUnit x ↔ (x : ℚ) = 1 ∨ (x : ℚ) = -1 := by\n  simp_rw [(isUnit_map_iff (Rat.ringOfIntegersEquiv : 𝓞 ℚ →+* ℤ) x).symm, Int.isUnit_iff,\n    RingEquiv.coe_toRingHom, RingEquiv.map_eq_one_iff, RingEquiv.map_eq_neg_one_iff, ←\n    Subtype.coe_injective.eq_iff]; rfl\n\n"}
{"name":"NumberField.isUnit_iff_norm","module":"Mathlib.NumberTheory.NumberField.Units.Basic","initialProofState":"K : Type u_1\ninst✝¹ : Field K\ninst✝ : NumberField K\nx : NumberField.RingOfIntegers K\n⊢ Iff (IsUnit x) (Eq (abs ↑((RingOfIntegers.norm Rat) x)) 1)","decl":"theorem NumberField.isUnit_iff_norm [NumberField K] {x : 𝓞 K} :\n    IsUnit x ↔ |(RingOfIntegers.norm ℚ x : ℚ)| = 1 := by\n  convert (RingOfIntegers.isUnit_norm ℚ (F := K)).symm\n  rw [← abs_one, abs_eq_abs, ← Rat.RingOfIntegers.isUnit_iff]\n\n"}
{"name":"NumberField.Units.coe_injective","module":"Mathlib.NumberTheory.NumberField.Units.Basic","initialProofState":"K : Type u_1\ninst✝ : Field K\n⊢ Function.Injective fun x => (algebraMap (NumberField.RingOfIntegers K) K) ↑x","decl":"theorem coe_injective : Function.Injective ((↑) : (𝓞 K)ˣ → K) :=\n  RingOfIntegers.coe_injective.comp Units.ext\n\n"}
{"name":"NumberField.Units.coe_coe","module":"Mathlib.NumberTheory.NumberField.Units.Basic","initialProofState":"K : Type u_1\ninst✝ : Field K\nu : Units (NumberField.RingOfIntegers K)\n⊢ Eq (↑↑u) ((algebraMap (NumberField.RingOfIntegers K) K) ↑u)","decl":"theorem coe_coe (u : (𝓞 K)ˣ) : ((u : 𝓞 K) : K) = (u : K) := rfl\n\n"}
{"name":"NumberField.Units.coe_mul","module":"Mathlib.NumberTheory.NumberField.Units.Basic","initialProofState":"K : Type u_1\ninst✝ : Field K\nx y : Units (NumberField.RingOfIntegers K)\n⊢ Eq ((algebraMap (NumberField.RingOfIntegers K) K) ↑(HMul.hMul x y)) (HMul.hMul ((algebraMap (NumberField.RingOfIntegers K) K) ↑x) ((algebraMap (NumberField.RingOfIntegers K) K) ↑y))","decl":"theorem coe_mul (x y : (𝓞 K)ˣ) : ((x * y : (𝓞 K)ˣ) : K) = (x : K) * (y : K) := rfl\n\n"}
{"name":"NumberField.Units.coe_pow","module":"Mathlib.NumberTheory.NumberField.Units.Basic","initialProofState":"K : Type u_1\ninst✝ : Field K\nx : Units (NumberField.RingOfIntegers K)\nn : Nat\n⊢ Eq ((algebraMap (NumberField.RingOfIntegers K) K) ↑(HPow.hPow x n)) (HPow.hPow ((algebraMap (NumberField.RingOfIntegers K) K) ↑x) n)","decl":"theorem coe_pow (x : (𝓞 K)ˣ) (n : ℕ) : ((x ^ n : (𝓞 K)ˣ) : K) = (x : K) ^ n := by\n  rw [← map_pow, ← val_pow_eq_pow_val]\n\n"}
{"name":"NumberField.Units.coe_zpow","module":"Mathlib.NumberTheory.NumberField.Units.Basic","initialProofState":"K : Type u_1\ninst✝ : Field K\nx : Units (NumberField.RingOfIntegers K)\nn : Int\n⊢ Eq ((algebraMap (NumberField.RingOfIntegers K) K) ↑(HPow.hPow x n)) (HPow.hPow ((algebraMap (NumberField.RingOfIntegers K) K) ↑x) n)","decl":"theorem coe_zpow (x : (𝓞 K)ˣ) (n : ℤ) : (↑(x ^ n) : K) = (x : K) ^ n := by\n  change ((Units.coeHom K).comp (map (algebraMap (𝓞 K) K))) (x ^ n) = _\n  exact map_zpow _ x n\n\n"}
{"name":"NumberField.Units.coe_one","module":"Mathlib.NumberTheory.NumberField.Units.Basic","initialProofState":"K : Type u_1\ninst✝ : Field K\n⊢ Eq ((algebraMap (NumberField.RingOfIntegers K) K) ↑1) 1","decl":"theorem coe_one : ((1 : (𝓞 K)ˣ) : K) = (1 : K) := rfl\n\n"}
{"name":"NumberField.Units.coe_neg_one","module":"Mathlib.NumberTheory.NumberField.Units.Basic","initialProofState":"K : Type u_1\ninst✝ : Field K\n⊢ Eq ((algebraMap (NumberField.RingOfIntegers K) K) ↑(-1)) (-1)","decl":"theorem coe_neg_one : ((-1 : (𝓞 K)ˣ) : K) = (-1 : K) := rfl\n\n"}
{"name":"NumberField.Units.coe_ne_zero","module":"Mathlib.NumberTheory.NumberField.Units.Basic","initialProofState":"K : Type u_1\ninst✝ : Field K\nx : Units (NumberField.RingOfIntegers K)\n⊢ Ne ((algebraMap (NumberField.RingOfIntegers K) K) ↑x) 0","decl":"theorem coe_ne_zero (x : (𝓞 K)ˣ) : (x : K) ≠ 0 :=\n  Subtype.coe_injective.ne_iff.mpr (_root_.Units.ne_zero x)\n\n"}
{"name":"NumberField.Units.norm","module":"Mathlib.NumberTheory.NumberField.Units.Basic","initialProofState":"K : Type u_1\ninst✝¹ : Field K\ninst✝ : NumberField K\nx : Units (NumberField.RingOfIntegers K)\n⊢ Eq (abs ((Algebra.norm Rat) ((algebraMap (NumberField.RingOfIntegers K) K) ↑x))) 1","decl":"@[simp]\nprotected theorem norm [NumberField K] (x : (𝓞 K)ˣ) :\n    |Algebra.norm ℚ (x : K)| = 1 := by\n  rw [← RingOfIntegers.coe_norm, isUnit_iff_norm.mp x.isUnit]\n\n"}
{"name":"NumberField.Units.mem_torsion","module":"Mathlib.NumberTheory.NumberField.Units.Basic","initialProofState":"K : Type u_1\ninst✝¹ : Field K\nx : Units (NumberField.RingOfIntegers K)\ninst✝ : NumberField K\n⊢ Iff (Membership.mem (NumberField.Units.torsion K) x) (∀ (w : NumberField.InfinitePlace K), Eq (w ((algebraMap (NumberField.RingOfIntegers K) K) ↑x)) 1)","decl":"theorem mem_torsion {x : (𝓞 K)ˣ} [NumberField K] :\n    x ∈ torsion K ↔ ∀ w : InfinitePlace K, w x = 1 := by\n  rw [eq_iff_eq (x : K) 1, torsion, CommGroup.mem_torsion]\n  refine ⟨fun hx φ ↦ (((φ.comp <| algebraMap (𝓞 K) K).toMonoidHom.comp <|\n    Units.coeHom _).isOfFinOrder hx).norm_eq_one, fun h ↦ isOfFinOrder_iff_pow_eq_one.2 ?_⟩\n  obtain ⟨n, hn, hx⟩ := Embeddings.pow_eq_one_of_norm_eq_one K ℂ x.val.isIntegral_coe h\n  exact ⟨n, hn, by ext; rw [NumberField.RingOfIntegers.coe_eq_algebraMap, coe_pow, hx,\n    NumberField.RingOfIntegers.coe_eq_algebraMap, coe_one]⟩\n\n"}
{"name":"NumberField.Units.instNonemptySubtypeUnitsRingOfIntegersMemSubgroupTorsion","module":"Mathlib.NumberTheory.NumberField.Units.Basic","initialProofState":"K : Type u_1\ninst✝ : Field K\n⊢ Nonempty (Subtype fun x => Membership.mem (NumberField.Units.torsion K) x)","decl":"instance : Nonempty (torsion K) := One.instNonempty\n\n"}
{"name":"NumberField.Units.instIsCyclicSubtypeUnitsRingOfIntegersMemSubgroupTorsion","module":"Mathlib.NumberTheory.NumberField.Units.Basic","initialProofState":"K : Type u_1\ninst✝¹ : Field K\ninst✝ : NumberField K\n⊢ IsCyclic (Subtype fun x => Membership.mem (NumberField.Units.torsion K) x)","decl":"/-- The torsion subgroup is cyclic. -/\ninstance [NumberField K] : IsCyclic (torsion K) := subgroup_units_cyclic _\n\n"}
{"name":"NumberField.Units.rootsOfUnity_eq_one","module":"Mathlib.NumberTheory.NumberField.Units.Basic","initialProofState":"K : Type u_1\ninst✝¹ : Field K\ninst✝ : NumberField K\nk : PNat\nhc : (↑k).Coprime ↑(NumberField.Units.torsionOrder K)\nζ : Units (NumberField.RingOfIntegers K)\n⊢ Iff (Membership.mem (rootsOfUnity (↑k) (NumberField.RingOfIntegers K)) ζ) (Eq ζ 1)","decl":"/-- If `k` does not divide `torsionOrder` then there are no nontrivial roots of unity of\n  order dividing `k`. -/\ntheorem rootsOfUnity_eq_one [NumberField K] {k : ℕ+} (hc : Nat.Coprime k (torsionOrder K))\n    {ζ : (𝓞 K)ˣ} : ζ ∈ rootsOfUnity k (𝓞 K) ↔ ζ = 1 := by\n  rw [mem_rootsOfUnity]\n  refine ⟨fun h => ?_, fun h => by rw [h, one_pow]⟩\n  refine orderOf_eq_one_iff.mp (Nat.eq_one_of_dvd_coprimes hc ?_ ?_)\n  · exact orderOf_dvd_of_pow_eq_one h\n  · have hζ : ζ ∈ torsion K := by\n      rw [torsion, CommGroup.mem_torsion, isOfFinOrder_iff_pow_eq_one]\n      exact ⟨k, k.prop, h⟩\n    rw [orderOf_submonoid (⟨ζ, hζ⟩ : torsion K)]\n    exact orderOf_dvd_card\n\n"}
{"name":"NumberField.Units.rootsOfUnity_eq_torsion","module":"Mathlib.NumberTheory.NumberField.Units.Basic","initialProofState":"K : Type u_1\ninst✝¹ : Field K\ninst✝ : NumberField K\n⊢ Eq (rootsOfUnity (↑(NumberField.Units.torsionOrder K)) (NumberField.RingOfIntegers K)) (NumberField.Units.torsion K)","decl":"/-- The group of roots of unity of order dividing `torsionOrder` is equal to the torsion\ngroup. -/\ntheorem rootsOfUnity_eq_torsion [NumberField K] :\n    rootsOfUnity (torsionOrder K) (𝓞 K) = torsion K := by\n  ext ζ\n  rw [torsion, mem_rootsOfUnity]\n  refine ⟨fun h => ?_, fun h => ?_⟩\n  · rw [CommGroup.mem_torsion, isOfFinOrder_iff_pow_eq_one]\n    exact ⟨↑(torsionOrder K), (torsionOrder K).prop, h⟩\n  · exact Subtype.ext_iff.mp (@pow_card_eq_one (torsion K) _ _ ⟨ζ, h⟩)\n\n"}
