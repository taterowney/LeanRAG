{"name":"Rat.RingOfIntegers.isUnit_iff","module":"Mathlib.NumberTheory.NumberField.Units.Basic","initialProofState":"x : NumberField.RingOfIntegers Rat\nâŠ¢ Iff (IsUnit x) (Or (Eq (â†‘x) 1) (Eq (â†‘x) (-1)))","decl":"theorem Rat.RingOfIntegers.isUnit_iff {x : ğ“ â„š} : IsUnit x â†” (x : â„š) = 1 âˆ¨ (x : â„š) = -1 := by\n  simp_rw [(isUnit_map_iff (Rat.ringOfIntegersEquiv : ğ“ â„š â†’+* â„¤) x).symm, Int.isUnit_iff,\n    RingEquiv.coe_toRingHom, RingEquiv.map_eq_one_iff, RingEquiv.map_eq_neg_one_iff, â†\n    Subtype.coe_injective.eq_iff]; rfl\n\n"}
{"name":"NumberField.isUnit_iff_norm","module":"Mathlib.NumberTheory.NumberField.Units.Basic","initialProofState":"K : Type u_1\ninstâœÂ¹ : Field K\ninstâœ : NumberField K\nx : NumberField.RingOfIntegers K\nâŠ¢ Iff (IsUnit x) (Eq (abs â†‘((RingOfIntegers.norm Rat) x)) 1)","decl":"theorem NumberField.isUnit_iff_norm [NumberField K] {x : ğ“ K} :\n    IsUnit x â†” |(RingOfIntegers.norm â„š x : â„š)| = 1 := by\n  convert (RingOfIntegers.isUnit_norm â„š (F := K)).symm\n  rw [â† abs_one, abs_eq_abs, â† Rat.RingOfIntegers.isUnit_iff]\n\n"}
{"name":"NumberField.Units.coe_injective","module":"Mathlib.NumberTheory.NumberField.Units.Basic","initialProofState":"K : Type u_1\ninstâœ : Field K\nâŠ¢ Function.Injective fun x => (algebraMap (NumberField.RingOfIntegers K) K) â†‘x","decl":"theorem coe_injective : Function.Injective ((â†‘) : (ğ“ K)Ë£ â†’ K) :=\n  RingOfIntegers.coe_injective.comp Units.ext\n\n"}
{"name":"NumberField.Units.coe_coe","module":"Mathlib.NumberTheory.NumberField.Units.Basic","initialProofState":"K : Type u_1\ninstâœ : Field K\nu : Units (NumberField.RingOfIntegers K)\nâŠ¢ Eq (â†‘â†‘u) ((algebraMap (NumberField.RingOfIntegers K) K) â†‘u)","decl":"theorem coe_coe (u : (ğ“ K)Ë£) : ((u : ğ“ K) : K) = (u : K) := rfl\n\n"}
{"name":"NumberField.Units.coe_mul","module":"Mathlib.NumberTheory.NumberField.Units.Basic","initialProofState":"K : Type u_1\ninstâœ : Field K\nx y : Units (NumberField.RingOfIntegers K)\nâŠ¢ Eq ((algebraMap (NumberField.RingOfIntegers K) K) â†‘(HMul.hMul x y)) (HMul.hMul ((algebraMap (NumberField.RingOfIntegers K) K) â†‘x) ((algebraMap (NumberField.RingOfIntegers K) K) â†‘y))","decl":"theorem coe_mul (x y : (ğ“ K)Ë£) : ((x * y : (ğ“ K)Ë£) : K) = (x : K) * (y : K) := rfl\n\n"}
{"name":"NumberField.Units.coe_pow","module":"Mathlib.NumberTheory.NumberField.Units.Basic","initialProofState":"K : Type u_1\ninstâœ : Field K\nx : Units (NumberField.RingOfIntegers K)\nn : Nat\nâŠ¢ Eq ((algebraMap (NumberField.RingOfIntegers K) K) â†‘(HPow.hPow x n)) (HPow.hPow ((algebraMap (NumberField.RingOfIntegers K) K) â†‘x) n)","decl":"theorem coe_pow (x : (ğ“ K)Ë£) (n : â„•) : ((x ^ n : (ğ“ K)Ë£) : K) = (x : K) ^ n := by\n  rw [â† map_pow, â† val_pow_eq_pow_val]\n\n"}
{"name":"NumberField.Units.coe_zpow","module":"Mathlib.NumberTheory.NumberField.Units.Basic","initialProofState":"K : Type u_1\ninstâœ : Field K\nx : Units (NumberField.RingOfIntegers K)\nn : Int\nâŠ¢ Eq ((algebraMap (NumberField.RingOfIntegers K) K) â†‘(HPow.hPow x n)) (HPow.hPow ((algebraMap (NumberField.RingOfIntegers K) K) â†‘x) n)","decl":"theorem coe_zpow (x : (ğ“ K)Ë£) (n : â„¤) : (â†‘(x ^ n) : K) = (x : K) ^ n := by\n  change ((Units.coeHom K).comp (map (algebraMap (ğ“ K) K))) (x ^ n) = _\n  exact map_zpow _ x n\n\n"}
{"name":"NumberField.Units.coe_one","module":"Mathlib.NumberTheory.NumberField.Units.Basic","initialProofState":"K : Type u_1\ninstâœ : Field K\nâŠ¢ Eq ((algebraMap (NumberField.RingOfIntegers K) K) â†‘1) 1","decl":"theorem coe_one : ((1 : (ğ“ K)Ë£) : K) = (1 : K) := rfl\n\n"}
{"name":"NumberField.Units.coe_neg_one","module":"Mathlib.NumberTheory.NumberField.Units.Basic","initialProofState":"K : Type u_1\ninstâœ : Field K\nâŠ¢ Eq ((algebraMap (NumberField.RingOfIntegers K) K) â†‘(-1)) (-1)","decl":"theorem coe_neg_one : ((-1 : (ğ“ K)Ë£) : K) = (-1 : K) := rfl\n\n"}
{"name":"NumberField.Units.coe_ne_zero","module":"Mathlib.NumberTheory.NumberField.Units.Basic","initialProofState":"K : Type u_1\ninstâœ : Field K\nx : Units (NumberField.RingOfIntegers K)\nâŠ¢ Ne ((algebraMap (NumberField.RingOfIntegers K) K) â†‘x) 0","decl":"theorem coe_ne_zero (x : (ğ“ K)Ë£) : (x : K) â‰  0 :=\n  Subtype.coe_injective.ne_iff.mpr (_root_.Units.ne_zero x)\n\n"}
{"name":"NumberField.Units.norm","module":"Mathlib.NumberTheory.NumberField.Units.Basic","initialProofState":"K : Type u_1\ninstâœÂ¹ : Field K\ninstâœ : NumberField K\nx : Units (NumberField.RingOfIntegers K)\nâŠ¢ Eq (abs ((Algebra.norm Rat) ((algebraMap (NumberField.RingOfIntegers K) K) â†‘x))) 1","decl":"@[simp]\nprotected theorem norm [NumberField K] (x : (ğ“ K)Ë£) :\n    |Algebra.norm â„š (x : K)| = 1 := by\n  rw [â† RingOfIntegers.coe_norm, isUnit_iff_norm.mp x.isUnit]\n\n"}
{"name":"NumberField.Units.mem_torsion","module":"Mathlib.NumberTheory.NumberField.Units.Basic","initialProofState":"K : Type u_1\ninstâœÂ¹ : Field K\nx : Units (NumberField.RingOfIntegers K)\ninstâœ : NumberField K\nâŠ¢ Iff (Membership.mem (NumberField.Units.torsion K) x) (âˆ€ (w : NumberField.InfinitePlace K), Eq (w ((algebraMap (NumberField.RingOfIntegers K) K) â†‘x)) 1)","decl":"theorem mem_torsion {x : (ğ“ K)Ë£} [NumberField K] :\n    x âˆˆ torsion K â†” âˆ€ w : InfinitePlace K, w x = 1 := by\n  rw [eq_iff_eq (x : K) 1, torsion, CommGroup.mem_torsion]\n  refine âŸ¨fun hx Ï† â†¦ (((Ï†.comp <| algebraMap (ğ“ K) K).toMonoidHom.comp <|\n    Units.coeHom _).isOfFinOrder hx).norm_eq_one, fun h â†¦ isOfFinOrder_iff_pow_eq_one.2 ?_âŸ©\n  obtain âŸ¨n, hn, hxâŸ© := Embeddings.pow_eq_one_of_norm_eq_one K â„‚ x.val.isIntegral_coe h\n  exact âŸ¨n, hn, by ext; rw [NumberField.RingOfIntegers.coe_eq_algebraMap, coe_pow, hx,\n    NumberField.RingOfIntegers.coe_eq_algebraMap, coe_one]âŸ©\n\n"}
{"name":"NumberField.Units.instNonemptySubtypeUnitsRingOfIntegersMemSubgroupTorsion","module":"Mathlib.NumberTheory.NumberField.Units.Basic","initialProofState":"K : Type u_1\ninstâœ : Field K\nâŠ¢ Nonempty (Subtype fun x => Membership.mem (NumberField.Units.torsion K) x)","decl":"instance : Nonempty (torsion K) := One.instNonempty\n\n"}
{"name":"NumberField.Units.instIsCyclicSubtypeUnitsRingOfIntegersMemSubgroupTorsion","module":"Mathlib.NumberTheory.NumberField.Units.Basic","initialProofState":"K : Type u_1\ninstâœÂ¹ : Field K\ninstâœ : NumberField K\nâŠ¢ IsCyclic (Subtype fun x => Membership.mem (NumberField.Units.torsion K) x)","decl":"/-- The torsion subgroup is cyclic. -/\ninstance [NumberField K] : IsCyclic (torsion K) := subgroup_units_cyclic _\n\n"}
{"name":"NumberField.Units.rootsOfUnity_eq_one","module":"Mathlib.NumberTheory.NumberField.Units.Basic","initialProofState":"K : Type u_1\ninstâœÂ¹ : Field K\ninstâœ : NumberField K\nk : PNat\nhc : (â†‘k).Coprime â†‘(NumberField.Units.torsionOrder K)\nÎ¶ : Units (NumberField.RingOfIntegers K)\nâŠ¢ Iff (Membership.mem (rootsOfUnity (â†‘k) (NumberField.RingOfIntegers K)) Î¶) (Eq Î¶ 1)","decl":"/-- If `k` does not divide `torsionOrder` then there are no nontrivial roots of unity of\n  order dividing `k`. -/\ntheorem rootsOfUnity_eq_one [NumberField K] {k : â„•+} (hc : Nat.Coprime k (torsionOrder K))\n    {Î¶ : (ğ“ K)Ë£} : Î¶ âˆˆ rootsOfUnity k (ğ“ K) â†” Î¶ = 1 := by\n  rw [mem_rootsOfUnity]\n  refine âŸ¨fun h => ?_, fun h => by rw [h, one_pow]âŸ©\n  refine orderOf_eq_one_iff.mp (Nat.eq_one_of_dvd_coprimes hc ?_ ?_)\n  Â· exact orderOf_dvd_of_pow_eq_one h\n  Â· have hÎ¶ : Î¶ âˆˆ torsion K := by\n      rw [torsion, CommGroup.mem_torsion, isOfFinOrder_iff_pow_eq_one]\n      exact âŸ¨k, k.prop, hâŸ©\n    rw [orderOf_submonoid (âŸ¨Î¶, hÎ¶âŸ© : torsion K)]\n    exact orderOf_dvd_card\n\n"}
{"name":"NumberField.Units.rootsOfUnity_eq_torsion","module":"Mathlib.NumberTheory.NumberField.Units.Basic","initialProofState":"K : Type u_1\ninstâœÂ¹ : Field K\ninstâœ : NumberField K\nâŠ¢ Eq (rootsOfUnity (â†‘(NumberField.Units.torsionOrder K)) (NumberField.RingOfIntegers K)) (NumberField.Units.torsion K)","decl":"/-- The group of roots of unity of order dividing `torsionOrder` is equal to the torsion\ngroup. -/\ntheorem rootsOfUnity_eq_torsion [NumberField K] :\n    rootsOfUnity (torsionOrder K) (ğ“ K) = torsion K := by\n  ext Î¶\n  rw [torsion, mem_rootsOfUnity]\n  refine âŸ¨fun h => ?_, fun h => ?_âŸ©\n  Â· rw [CommGroup.mem_torsion, isOfFinOrder_iff_pow_eq_one]\n    exact âŸ¨â†‘(torsionOrder K), (torsionOrder K).prop, hâŸ©\n  Â· exact Subtype.ext_iff.mp (@pow_card_eq_one (torsion K) _ _ âŸ¨Î¶, hâŸ©)\n\n"}
