{"name":"Multiset.Nat.mem_antidiagonal","module":"Mathlib.Data.Multiset.NatAntidiagonal","initialProofState":"n : Nat\nx : Prod Nat Nat\n⊢ Iff (Membership.mem (Multiset.Nat.antidiagonal n) x) (Eq (HAdd.hAdd x.1 x.2) n)","decl":"/-- A pair (i, j) is contained in the antidiagonal of `n` if and only if `i + j = n`. -/\n@[simp]\ntheorem mem_antidiagonal {n : ℕ} {x : ℕ × ℕ} : x ∈ antidiagonal n ↔ x.1 + x.2 = n := by\n  rw [antidiagonal, mem_coe, List.Nat.mem_antidiagonal]\n\n"}
{"name":"Multiset.Nat.card_antidiagonal","module":"Mathlib.Data.Multiset.NatAntidiagonal","initialProofState":"n : Nat\n⊢ Eq (Multiset.Nat.antidiagonal n).card (HAdd.hAdd n 1)","decl":"/-- The cardinality of the antidiagonal of `n` is `n+1`. -/\n@[simp]\ntheorem card_antidiagonal (n : ℕ) : card (antidiagonal n) = n + 1 := by\n  rw [antidiagonal, coe_card, List.Nat.length_antidiagonal]\n\n"}
{"name":"Multiset.Nat.antidiagonal_zero","module":"Mathlib.Data.Multiset.NatAntidiagonal","initialProofState":"⊢ Eq (Multiset.Nat.antidiagonal 0) (Singleton.singleton { fst := 0, snd := 0 })","decl":"/-- The antidiagonal of `0` is the list `[(0, 0)]` -/\n@[simp]\ntheorem antidiagonal_zero : antidiagonal 0 = {(0, 0)} :=\n  rfl\n\n"}
{"name":"Multiset.Nat.nodup_antidiagonal","module":"Mathlib.Data.Multiset.NatAntidiagonal","initialProofState":"n : Nat\n⊢ (Multiset.Nat.antidiagonal n).Nodup","decl":"/-- The antidiagonal of `n` does not contain duplicate entries. -/\n@[simp]\ntheorem nodup_antidiagonal (n : ℕ) : Nodup (antidiagonal n) :=\n  coe_nodup.2 <| List.Nat.nodup_antidiagonal n\n\n"}
{"name":"Multiset.Nat.antidiagonal_succ","module":"Mathlib.Data.Multiset.NatAntidiagonal","initialProofState":"n : Nat\n⊢ Eq (Multiset.Nat.antidiagonal (HAdd.hAdd n 1)) (Multiset.cons { fst := 0, snd := HAdd.hAdd n 1 } (Multiset.map (Prod.map Nat.succ id) (Multiset.Nat.antidiagonal n)))","decl":"@[simp]\ntheorem antidiagonal_succ {n : ℕ} :\n    antidiagonal (n + 1) = (0, n + 1) ::ₘ (antidiagonal n).map (Prod.map Nat.succ id) := by\n  simp only [antidiagonal, List.Nat.antidiagonal_succ, map_coe, cons_coe]\n\n"}
{"name":"Multiset.Nat.antidiagonal_succ'","module":"Mathlib.Data.Multiset.NatAntidiagonal","initialProofState":"n : Nat\n⊢ Eq (Multiset.Nat.antidiagonal (HAdd.hAdd n 1)) (Multiset.cons { fst := HAdd.hAdd n 1, snd := 0 } (Multiset.map (Prod.map id Nat.succ) (Multiset.Nat.antidiagonal n)))","decl":"theorem antidiagonal_succ' {n : ℕ} :\n    antidiagonal (n + 1) = (n + 1, 0) ::ₘ (antidiagonal n).map (Prod.map id Nat.succ) := by\n  rw [antidiagonal, List.Nat.antidiagonal_succ', ← coe_add, Multiset.add_comm, antidiagonal,\n    map_coe, coe_add, List.singleton_append, cons_coe]\n\n"}
{"name":"Multiset.Nat.antidiagonal_succ_succ'","module":"Mathlib.Data.Multiset.NatAntidiagonal","initialProofState":"n : Nat\n⊢ Eq (Multiset.Nat.antidiagonal (HAdd.hAdd n 2)) (Multiset.cons { fst := 0, snd := HAdd.hAdd n 2 } (Multiset.cons { fst := HAdd.hAdd n 2, snd := 0 } (Multiset.map (Prod.map Nat.succ Nat.succ) (Multiset.Nat.antidiagonal n))))","decl":"theorem antidiagonal_succ_succ' {n : ℕ} :\n    antidiagonal (n + 2) =\n      (0, n + 2) ::ₘ (n + 2, 0) ::ₘ (antidiagonal n).map (Prod.map Nat.succ Nat.succ) := by\n  rw [antidiagonal_succ, antidiagonal_succ', map_cons, map_map, Prod.map_apply]\n  rfl\n\n"}
{"name":"Multiset.Nat.map_swap_antidiagonal","module":"Mathlib.Data.Multiset.NatAntidiagonal","initialProofState":"n : Nat\n⊢ Eq (Multiset.map Prod.swap (Multiset.Nat.antidiagonal n)) (Multiset.Nat.antidiagonal n)","decl":"theorem map_swap_antidiagonal {n : ℕ} : (antidiagonal n).map Prod.swap = antidiagonal n := by\n  rw [antidiagonal, map_coe, List.Nat.map_swap_antidiagonal, coe_reverse]\n\n"}
