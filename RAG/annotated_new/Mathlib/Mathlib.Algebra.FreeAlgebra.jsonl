{"name":"FreeAlgebra.Pre.of.sizeOf_spec","module":"Mathlib.Algebra.FreeAlgebra","initialProofState":"R : Type u_1\nX : Type u_2\ninst✝¹ : SizeOf R\ninst✝ : SizeOf X\na✝ : X\n⊢ Eq (SizeOf.sizeOf (FreeAlgebra.Pre.of a✝)) (HAdd.hAdd 1 (SizeOf.sizeOf a✝))","decl":"/-- This inductive type is used to express representatives of the free algebra.\n-/\ninductive Pre\n  | of : X → Pre\n  | ofScalar : R → Pre\n  | add : Pre → Pre → Pre\n  | mul : Pre → Pre → Pre\n\n"}
{"name":"FreeAlgebra.Pre.add.inj","module":"Mathlib.Algebra.FreeAlgebra","initialProofState":"R : Type u_1\nX : Type u_2\na✝³ a✝² a✝¹ a✝ : FreeAlgebra.Pre R X\nx✝ : Eq (a✝³.add a✝²) (a✝¹.add a✝)\n⊢ And (Eq a✝³ a✝¹) (Eq a✝² a✝)","decl":"/-- This inductive type is used to express representatives of the free algebra.\n-/\ninductive Pre\n  | of : X → Pre\n  | ofScalar : R → Pre\n  | add : Pre → Pre → Pre\n  | mul : Pre → Pre → Pre\n\n"}
{"name":"FreeAlgebra.Pre.add.injEq","module":"Mathlib.Algebra.FreeAlgebra","initialProofState":"R : Type u_1\nX : Type u_2\na✝³ a✝² a✝¹ a✝ : FreeAlgebra.Pre R X\n⊢ Eq (Eq (a✝³.add a✝²) (a✝¹.add a✝)) (And (Eq a✝³ a✝¹) (Eq a✝² a✝))","decl":"/-- This inductive type is used to express representatives of the free algebra.\n-/\ninductive Pre\n  | of : X → Pre\n  | ofScalar : R → Pre\n  | add : Pre → Pre → Pre\n  | mul : Pre → Pre → Pre\n\n"}
{"name":"FreeAlgebra.Pre.of.injEq","module":"Mathlib.Algebra.FreeAlgebra","initialProofState":"R : Type u_1\nX : Type u_2\na✝¹ a✝ : X\n⊢ Eq (Eq (FreeAlgebra.Pre.of a✝¹) (FreeAlgebra.Pre.of a✝)) (Eq a✝¹ a✝)","decl":"/-- This inductive type is used to express representatives of the free algebra.\n-/\ninductive Pre\n  | of : X → Pre\n  | ofScalar : R → Pre\n  | add : Pre → Pre → Pre\n  | mul : Pre → Pre → Pre\n\n"}
{"name":"FreeAlgebra.Pre.mul.sizeOf_spec","module":"Mathlib.Algebra.FreeAlgebra","initialProofState":"R : Type u_1\nX : Type u_2\ninst✝¹ : SizeOf R\ninst✝ : SizeOf X\na✝¹ a✝ : FreeAlgebra.Pre R X\n⊢ Eq (SizeOf.sizeOf (a✝¹.mul a✝)) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf a✝¹)) (SizeOf.sizeOf a✝))","decl":"/-- This inductive type is used to express representatives of the free algebra.\n-/\ninductive Pre\n  | of : X → Pre\n  | ofScalar : R → Pre\n  | add : Pre → Pre → Pre\n  | mul : Pre → Pre → Pre\n\n"}
{"name":"FreeAlgebra.Pre.of.inj","module":"Mathlib.Algebra.FreeAlgebra","initialProofState":"R : Type u_1\nX : Type u_2\na✝¹ a✝ : X\nx✝ : Eq (FreeAlgebra.Pre.of a✝¹) (FreeAlgebra.Pre.of a✝)\n⊢ Eq a✝¹ a✝","decl":"/-- This inductive type is used to express representatives of the free algebra.\n-/\ninductive Pre\n  | of : X → Pre\n  | ofScalar : R → Pre\n  | add : Pre → Pre → Pre\n  | mul : Pre → Pre → Pre\n\n"}
{"name":"FreeAlgebra.Pre.add.sizeOf_spec","module":"Mathlib.Algebra.FreeAlgebra","initialProofState":"R : Type u_1\nX : Type u_2\ninst✝¹ : SizeOf R\ninst✝ : SizeOf X\na✝¹ a✝ : FreeAlgebra.Pre R X\n⊢ Eq (SizeOf.sizeOf (a✝¹.add a✝)) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf a✝¹)) (SizeOf.sizeOf a✝))","decl":"/-- This inductive type is used to express representatives of the free algebra.\n-/\ninductive Pre\n  | of : X → Pre\n  | ofScalar : R → Pre\n  | add : Pre → Pre → Pre\n  | mul : Pre → Pre → Pre\n\n"}
{"name":"FreeAlgebra.Pre.ofScalar.inj","module":"Mathlib.Algebra.FreeAlgebra","initialProofState":"R : Type u_1\nX : Type u_2\na✝¹ a✝ : R\nx✝ : Eq (FreeAlgebra.Pre.ofScalar a✝¹) (FreeAlgebra.Pre.ofScalar a✝)\n⊢ Eq a✝¹ a✝","decl":"/-- This inductive type is used to express representatives of the free algebra.\n-/\ninductive Pre\n  | of : X → Pre\n  | ofScalar : R → Pre\n  | add : Pre → Pre → Pre\n  | mul : Pre → Pre → Pre\n\n"}
{"name":"FreeAlgebra.Pre.ofScalar.sizeOf_spec","module":"Mathlib.Algebra.FreeAlgebra","initialProofState":"R : Type u_1\nX : Type u_2\ninst✝¹ : SizeOf R\ninst✝ : SizeOf X\na✝ : R\n⊢ Eq (SizeOf.sizeOf (FreeAlgebra.Pre.ofScalar a✝)) (HAdd.hAdd 1 (SizeOf.sizeOf a✝))","decl":"/-- This inductive type is used to express representatives of the free algebra.\n-/\ninductive Pre\n  | of : X → Pre\n  | ofScalar : R → Pre\n  | add : Pre → Pre → Pre\n  | mul : Pre → Pre → Pre\n\n"}
{"name":"FreeAlgebra.Pre.ofScalar.injEq","module":"Mathlib.Algebra.FreeAlgebra","initialProofState":"R : Type u_1\nX : Type u_2\na✝¹ a✝ : R\n⊢ Eq (Eq (FreeAlgebra.Pre.ofScalar a✝¹) (FreeAlgebra.Pre.ofScalar a✝)) (Eq a✝¹ a✝)","decl":"/-- This inductive type is used to express representatives of the free algebra.\n-/\ninductive Pre\n  | of : X → Pre\n  | ofScalar : R → Pre\n  | add : Pre → Pre → Pre\n  | mul : Pre → Pre → Pre\n\n"}
{"name":"FreeAlgebra.Pre.mul.inj","module":"Mathlib.Algebra.FreeAlgebra","initialProofState":"R : Type u_1\nX : Type u_2\na✝³ a✝² a✝¹ a✝ : FreeAlgebra.Pre R X\nx✝ : Eq (a✝³.mul a✝²) (a✝¹.mul a✝)\n⊢ And (Eq a✝³ a✝¹) (Eq a✝² a✝)","decl":"/-- This inductive type is used to express representatives of the free algebra.\n-/\ninductive Pre\n  | of : X → Pre\n  | ofScalar : R → Pre\n  | add : Pre → Pre → Pre\n  | mul : Pre → Pre → Pre\n\n"}
{"name":"FreeAlgebra.Pre.mul.injEq","module":"Mathlib.Algebra.FreeAlgebra","initialProofState":"R : Type u_1\nX : Type u_2\na✝³ a✝² a✝¹ a✝ : FreeAlgebra.Pre R X\n⊢ Eq (Eq (a✝³.mul a✝²) (a✝¹.mul a✝)) (And (Eq a✝³ a✝¹) (Eq a✝² a✝))","decl":"/-- This inductive type is used to express representatives of the free algebra.\n-/\ninductive Pre\n  | of : X → Pre\n  | ofScalar : R → Pre\n  | add : Pre → Pre → Pre\n  | mul : Pre → Pre → Pre\n\n"}
{"name":"FreeAlgebra.Rel.brecOn","module":"Mathlib.Algebra.FreeAlgebra","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\nX : Type u_2\nmotive✝ : (a a_1 : FreeAlgebra.Pre R X) → FreeAlgebra.Rel R X a a_1 → Prop\na✝¹ a✝ : FreeAlgebra.Pre R X\nx✝ : FreeAlgebra.Rel R X a✝¹ a✝\nih✝ : ∀ (a a_1 : FreeAlgebra.Pre R X) (x : FreeAlgebra.Rel R X a a_1), x.below → motive✝ a a_1 x\n⊢ motive✝ a✝¹ a✝ x✝","decl":"/-- An inductively defined relation on `Pre R X` used to force the initial algebra structure on\nthe associated quotient.\n-/\ninductive Rel : Pre R X → Pre R X → Prop\n  -- force `ofScalar` to be a central semiring morphism\n  | add_scalar {r s : R} : Rel (↑(r + s)) (↑r + ↑s)\n  | mul_scalar {r s : R} : Rel (↑(r * s)) (↑r * ↑s)\n  | central_scalar {r : R} {a : Pre R X} : Rel (r * a) (a * r)\n\n  -- commutative additive semigroup\n  | add_assoc {a b c : Pre R X} : Rel (a + b + c) (a + (b + c))\n  | add_comm {a b : Pre R X} : Rel (a + b) (b + a)\n  | zero_add {a : Pre R X} : Rel (0 + a) a\n\n  -- multiplicative monoid\n  | mul_assoc {a b c : Pre R X} : Rel (a * b * c) (a * (b * c))\n  | one_mul {a : Pre R X} : Rel (1 * a) a\n  | mul_one {a : Pre R X} : Rel (a * 1) a\n\n  -- distributivity\n  | left_distrib {a b c : Pre R X} : Rel (a * (b + c)) (a * b + a * c)\n  | right_distrib {a b c : Pre R X} :\n      Rel ((a + b) * c) (a * c + b * c)\n\n  -- other relations needed for semiring\n  | zero_mul {a : Pre R X} : Rel (0 * a) 0\n  | mul_zero {a : Pre R X} : Rel (a * 0) 0\n\n  -- compatibility\n  | add_compat_left {a b c : Pre R X} : Rel a b → Rel (a + c) (b + c)\n  | add_compat_right {a b c : Pre R X} : Rel a b → Rel (c + a) (c + b)\n  | mul_compat_left {a b c : Pre R X} : Rel a b → Rel (a * c) (b * c)\n  | mul_compat_right {a b c : Pre R X} : Rel a b → Rel (c * a) (c * b)\n\n"}
{"name":"FreeAlgebra.instIsScalarTower","module":"Mathlib.Algebra.FreeAlgebra","initialProofState":"X : Type u_2\nR : Type u_3\nS : Type u_4\nA : Type u_5\ninst✝⁶ : CommSemiring R\ninst✝⁵ : CommSemiring S\ninst✝⁴ : CommSemiring A\ninst✝³ : SMul R S\ninst✝² : Algebra R A\ninst✝¹ : Algebra S A\ninst✝ : IsScalarTower R S A\n⊢ IsScalarTower R S (FreeAlgebra A X)","decl":"instance {R S A} [CommSemiring R] [CommSemiring S] [CommSemiring A]\n    [SMul R S] [Algebra R A] [Algebra S A] [IsScalarTower R S A] :\n    IsScalarTower R S (FreeAlgebra A X) where\n  smul_assoc r s x := by\n    change algebraMap S A (r • s) • x = algebraMap R A _ • (algebraMap S A _ • x)\n    rw [← smul_assoc]\n    congr\n    simp only [Algebra.algebraMap_eq_smul_one, smul_eq_mul]\n    rw [smul_assoc, ← smul_one_mul]\n\n"}
{"name":"FreeAlgebra.instSMulCommClass","module":"Mathlib.Algebra.FreeAlgebra","initialProofState":"X : Type u_2\nR : Type u_3\nS : Type u_4\nA : Type u_5\ninst✝⁴ : CommSemiring R\ninst✝³ : CommSemiring S\ninst✝² : CommSemiring A\ninst✝¹ : Algebra R A\ninst✝ : Algebra S A\n⊢ SMulCommClass R S (FreeAlgebra A X)","decl":"instance {R S A} [CommSemiring R] [CommSemiring S] [CommSemiring A] [Algebra R A] [Algebra S A] :\n    SMulCommClass R S (FreeAlgebra A X) where\n  smul_comm r s x := smul_comm (algebraMap R A r) (algebraMap S A s) x\n\n"}
{"name":"FreeAlgebra.ι_def","module":"Mathlib.Algebra.FreeAlgebra","initialProofState":"R : Type u_3\ninst✝ : CommSemiring R\nX : Type u_4\nm : X\n⊢ Eq (FreeAlgebra.ι R m) (Quot.mk (FreeAlgebra.Rel R X) (FreeAlgebra.Pre.of m))","decl":"/-- The canonical function `X → FreeAlgebra R X`.\n-/\nirreducible_def ι : X → FreeAlgebra R X := fun m ↦ Quot.mk _ m\n\n"}
{"name":"FreeAlgebra.quot_mk_eq_ι","module":"Mathlib.Algebra.FreeAlgebra","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\nX : Type u_2\nm : X\n⊢ Eq (Quot.mk (FreeAlgebra.Rel R X) (FreeAlgebra.Pre.of m)) (FreeAlgebra.ι R m)","decl":"@[simp]\ntheorem quot_mk_eq_ι (m : X) : Quot.mk (FreeAlgebra.Rel R X) m = ι R m := by rw [ι_def]\n\n"}
{"name":"FreeAlgebra.liftAux_eq","module":"Mathlib.Algebra.FreeAlgebra","initialProofState":"R : Type u_1\ninst✝² : CommSemiring R\nX : Type u_2\nA : Type u_3\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\nf : X → A\n⊢ Eq (FreeAlgebra.liftAux R f) ((FreeAlgebra.lift R) f)","decl":"@[simp]\ntheorem liftAux_eq (f : X → A) : liftAux R f = lift R f := by\n  rw [lift]\n  rfl\n\n"}
{"name":"FreeAlgebra.lift_symm_apply","module":"Mathlib.Algebra.FreeAlgebra","initialProofState":"R : Type u_1\ninst✝² : CommSemiring R\nX : Type u_2\nA : Type u_3\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\nF : AlgHom R (FreeAlgebra R X) A\n⊢ Eq ((FreeAlgebra.lift R).symm F) (Function.comp (⇑F) (FreeAlgebra.ι R))","decl":"@[simp]\ntheorem lift_symm_apply (F : FreeAlgebra R X →ₐ[R] A) : (lift R).symm F = F ∘ ι R := by\n  rw [lift]\n  rfl\n\n"}
{"name":"FreeAlgebra.ι_comp_lift","module":"Mathlib.Algebra.FreeAlgebra","initialProofState":"R : Type u_1\ninst✝² : CommSemiring R\nX : Type u_2\nA : Type u_3\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\nf : X → A\n⊢ Eq (Function.comp (⇑((FreeAlgebra.lift R) f)) (FreeAlgebra.ι R)) f","decl":"@[simp]\ntheorem ι_comp_lift (f : X → A) : (lift R f : FreeAlgebra R X → A) ∘ ι R = f := by\n  ext\n  rw [Function.comp_apply, ι_def, lift]\n  rfl\n\n"}
{"name":"FreeAlgebra.lift_ι_apply","module":"Mathlib.Algebra.FreeAlgebra","initialProofState":"R : Type u_1\ninst✝² : CommSemiring R\nX : Type u_2\nA : Type u_3\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\nf : X → A\nx : X\n⊢ Eq (((FreeAlgebra.lift R) f) (FreeAlgebra.ι R x)) (f x)","decl":"@[simp]\ntheorem lift_ι_apply (f : X → A) (x) : lift R f (ι R x) = f x := by\n  rw [ι_def, lift]\n  rfl\n\n"}
{"name":"FreeAlgebra.lift_unique","module":"Mathlib.Algebra.FreeAlgebra","initialProofState":"R : Type u_1\ninst✝² : CommSemiring R\nX : Type u_2\nA : Type u_3\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\nf : X → A\ng : AlgHom R (FreeAlgebra R X) A\n⊢ Iff (Eq (Function.comp (⇑g) (FreeAlgebra.ι R)) f) (Eq g ((FreeAlgebra.lift R) f))","decl":"@[simp]\ntheorem lift_unique (f : X → A) (g : FreeAlgebra R X →ₐ[R] A) :\n    (g : FreeAlgebra R X → A) ∘ ι R = f ↔ g = lift R f := by\n  rw [← (lift R).symm_apply_eq, lift]\n  rfl\n\n"}
{"name":"FreeAlgebra.lift_comp_ι","module":"Mathlib.Algebra.FreeAlgebra","initialProofState":"R : Type u_1\ninst✝² : CommSemiring R\nX : Type u_2\nA : Type u_3\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\ng : AlgHom R (FreeAlgebra R X) A\n⊢ Eq ((FreeAlgebra.lift R) (Function.comp (⇑g) (FreeAlgebra.ι R))) g","decl":"@[simp]\ntheorem lift_comp_ι (g : FreeAlgebra R X →ₐ[R] A) :\n    lift R ((g : FreeAlgebra R X → A) ∘ ι R) = g := by\n  rw [← lift_symm_apply]\n  exact (lift R).apply_symm_apply g\n\n"}
{"name":"FreeAlgebra.hom_ext_iff","module":"Mathlib.Algebra.FreeAlgebra","initialProofState":"R : Type u_1\ninst✝² : CommSemiring R\nX : Type u_2\nA : Type u_3\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\nf g : AlgHom R (FreeAlgebra R X) A\n⊢ Iff (Eq f g) (Eq (Function.comp (⇑f) (FreeAlgebra.ι R)) (Function.comp (⇑g) (FreeAlgebra.ι R)))","decl":"/-- See note [partially-applied ext lemmas]. -/\n@[ext high]\ntheorem hom_ext {f g : FreeAlgebra R X →ₐ[R] A}\n    (w : (f : FreeAlgebra R X → A) ∘ ι R = (g : FreeAlgebra R X → A) ∘ ι R) : f = g := by\n  rw [← lift_symm_apply, ← lift_symm_apply] at w\n  exact (lift R).symm.injective w\n\n"}
{"name":"FreeAlgebra.hom_ext","module":"Mathlib.Algebra.FreeAlgebra","initialProofState":"R : Type u_1\ninst✝² : CommSemiring R\nX : Type u_2\nA : Type u_3\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\nf g : AlgHom R (FreeAlgebra R X) A\nw : Eq (Function.comp (⇑f) (FreeAlgebra.ι R)) (Function.comp (⇑g) (FreeAlgebra.ι R))\n⊢ Eq f g","decl":"/-- See note [partially-applied ext lemmas]. -/\n@[ext high]\ntheorem hom_ext {f g : FreeAlgebra R X →ₐ[R] A}\n    (w : (f : FreeAlgebra R X → A) ∘ ι R = (g : FreeAlgebra R X → A) ∘ ι R) : f = g := by\n  rw [← lift_symm_apply, ← lift_symm_apply] at w\n  exact (lift R).symm.injective w\n\n"}
{"name":"FreeAlgebra.instNontrivial","module":"Mathlib.Algebra.FreeAlgebra","initialProofState":"R : Type u_1\ninst✝¹ : CommSemiring R\nX : Type u_2\ninst✝ : Nontrivial R\n⊢ Nontrivial (FreeAlgebra R X)","decl":"/-- `FreeAlgebra R X` is nontrivial when `R` is. -/\ninstance [Nontrivial R] : Nontrivial (FreeAlgebra R X) :=\n  equivMonoidAlgebraFreeMonoid.surjective.nontrivial\n\n"}
{"name":"FreeAlgebra.instNoZeroDivisors","module":"Mathlib.Algebra.FreeAlgebra","initialProofState":"R : Type u_1\ninst✝¹ : CommSemiring R\nX : Type u_2\ninst✝ : NoZeroDivisors R\n⊢ NoZeroDivisors (FreeAlgebra R X)","decl":"/-- `FreeAlgebra R X` has no zero-divisors when `R` has no zero-divisors. -/\ninstance instNoZeroDivisors [NoZeroDivisors R] : NoZeroDivisors (FreeAlgebra R X) :=\n  equivMonoidAlgebraFreeMonoid.toMulEquiv.noZeroDivisors\n\n"}
{"name":"FreeAlgebra.instIsDomain","module":"Mathlib.Algebra.FreeAlgebra","initialProofState":"R : Type u_4\nX : Type u_5\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\n⊢ IsDomain (FreeAlgebra R X)","decl":"/-- `FreeAlgebra R X` is a domain when `R` is an integral domain. -/\ninstance instIsDomain {R X} [CommRing R] [IsDomain R] : IsDomain (FreeAlgebra R X) :=\n  NoZeroDivisors.to_isDomain _\n\n"}
{"name":"FreeAlgebra.algebraMap_leftInverse","module":"Mathlib.Algebra.FreeAlgebra","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\nX : Type u_2\n⊢ Function.LeftInverse ⇑FreeAlgebra.algebraMapInv ⇑(algebraMap R (FreeAlgebra R X))","decl":"theorem algebraMap_leftInverse :\n    Function.LeftInverse algebraMapInv (algebraMap R <| FreeAlgebra R X) := fun x ↦ by\n  simp [algebraMapInv]\n\n"}
{"name":"FreeAlgebra.algebraMap_inj","module":"Mathlib.Algebra.FreeAlgebra","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\nX : Type u_2\nx y : R\n⊢ Iff (Eq ((algebraMap R (FreeAlgebra R X)) x) ((algebraMap R (FreeAlgebra R X)) y)) (Eq x y)","decl":"@[simp]\ntheorem algebraMap_inj (x y : R) :\n    algebraMap R (FreeAlgebra R X) x = algebraMap R (FreeAlgebra R X) y ↔ x = y :=\n  algebraMap_leftInverse.injective.eq_iff\n\n"}
{"name":"FreeAlgebra.algebraMap_eq_zero_iff","module":"Mathlib.Algebra.FreeAlgebra","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\nX : Type u_2\nx : R\n⊢ Iff (Eq ((algebraMap R (FreeAlgebra R X)) x) 0) (Eq x 0)","decl":"@[simp]\ntheorem algebraMap_eq_zero_iff (x : R) : algebraMap R (FreeAlgebra R X) x = 0 ↔ x = 0 :=\n  map_eq_zero_iff (algebraMap _ _) algebraMap_leftInverse.injective\n\n"}
{"name":"FreeAlgebra.algebraMap_eq_one_iff","module":"Mathlib.Algebra.FreeAlgebra","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\nX : Type u_2\nx : R\n⊢ Iff (Eq ((algebraMap R (FreeAlgebra R X)) x) 1) (Eq x 1)","decl":"@[simp]\ntheorem algebraMap_eq_one_iff (x : R) : algebraMap R (FreeAlgebra R X) x = 1 ↔ x = 1 :=\n  map_eq_one_iff (algebraMap _ _) algebraMap_leftInverse.injective\n\n-- this proof is copied from the approach in `FreeAbelianGroup.of_injective`\n"}
{"name":"FreeAlgebra.ι_injective","module":"Mathlib.Algebra.FreeAlgebra","initialProofState":"R : Type u_1\ninst✝¹ : CommSemiring R\nX : Type u_2\ninst✝ : Nontrivial R\n⊢ Function.Injective (FreeAlgebra.ι R)","decl":"theorem ι_injective [Nontrivial R] : Function.Injective (ι R : X → FreeAlgebra R X) :=\n  fun x y hoxy ↦\n  by_contradiction <| by\n    classical exact fun hxy : x ≠ y ↦\n        let f : FreeAlgebra R X →ₐ[R] R := lift R fun z ↦ if x = z then (1 : R) else 0\n        have hfx1 : f (ι R x) = 1 := (lift_ι_apply _ _).trans <| if_pos rfl\n        have hfy1 : f (ι R y) = 1 := hoxy ▸ hfx1\n        have hfy0 : f (ι R y) = 0 := (lift_ι_apply _ _).trans <| if_neg hxy\n        one_ne_zero <| hfy1.symm.trans hfy0\n\n"}
{"name":"FreeAlgebra.ι_inj","module":"Mathlib.Algebra.FreeAlgebra","initialProofState":"R : Type u_1\ninst✝¹ : CommSemiring R\nX : Type u_2\ninst✝ : Nontrivial R\nx y : X\n⊢ Iff (Eq (FreeAlgebra.ι R x) (FreeAlgebra.ι R y)) (Eq x y)","decl":"@[simp]\ntheorem ι_inj [Nontrivial R] (x y : X) : ι R x = ι R y ↔ x = y :=\n  ι_injective.eq_iff\n\n"}
{"name":"FreeAlgebra.ι_ne_algebraMap","module":"Mathlib.Algebra.FreeAlgebra","initialProofState":"R : Type u_1\ninst✝¹ : CommSemiring R\nX : Type u_2\ninst✝ : Nontrivial R\nx : X\nr : R\n⊢ Ne (FreeAlgebra.ι R x) ((algebraMap R (FreeAlgebra R X)) r)","decl":"@[simp]\ntheorem ι_ne_algebraMap [Nontrivial R] (x : X) (r : R) : ι R x ≠ algebraMap R _ r := fun h ↦ by\n  let f0 : FreeAlgebra R X →ₐ[R] R := lift R 0\n  let f1 : FreeAlgebra R X →ₐ[R] R := lift R 1\n  have hf0 : f0 (ι R x) = 0 := lift_ι_apply _ _\n  have hf1 : f1 (ι R x) = 1 := lift_ι_apply _ _\n  rw [h, f0.commutes, Algebra.id.map_eq_self] at hf0\n  rw [h, f1.commutes, Algebra.id.map_eq_self] at hf1\n  exact zero_ne_one (hf0.symm.trans hf1)\n\n"}
{"name":"FreeAlgebra.ι_ne_zero","module":"Mathlib.Algebra.FreeAlgebra","initialProofState":"R : Type u_1\ninst✝¹ : CommSemiring R\nX : Type u_2\ninst✝ : Nontrivial R\nx : X\n⊢ Ne (FreeAlgebra.ι R x) 0","decl":"@[simp]\ntheorem ι_ne_zero [Nontrivial R] (x : X) : ι R x ≠ 0 :=\n  ι_ne_algebraMap x 0\n\n"}
{"name":"FreeAlgebra.ι_ne_one","module":"Mathlib.Algebra.FreeAlgebra","initialProofState":"R : Type u_1\ninst✝¹ : CommSemiring R\nX : Type u_2\ninst✝ : Nontrivial R\nx : X\n⊢ Ne (FreeAlgebra.ι R x) 1","decl":"@[simp]\ntheorem ι_ne_one [Nontrivial R] (x : X) : ι R x ≠ 1 :=\n  ι_ne_algebraMap x 1\n\n"}
{"name":"FreeAlgebra.induction","module":"Mathlib.Algebra.FreeAlgebra","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\nX : Type u_2\nC : FreeAlgebra R X → Prop\nh_grade0 : ∀ (r : R), C ((algebraMap R (FreeAlgebra R X)) r)\nh_grade1 : ∀ (x : X), C (FreeAlgebra.ι R x)\nh_mul : ∀ (a b : FreeAlgebra R X), C a → C b → C (HMul.hMul a b)\nh_add : ∀ (a b : FreeAlgebra R X), C a → C b → C (HAdd.hAdd a b)\na : FreeAlgebra R X\n⊢ C a","decl":"/-- An induction principle for the free algebra.\n\nIf `C` holds for the `algebraMap` of `r : R` into `FreeAlgebra R X`, the `ι` of `x : X`, and is\npreserved under addition and multiplication, then it holds for all of `FreeAlgebra R X`.\n-/\n@[elab_as_elim, induction_eliminator]\ntheorem induction {C : FreeAlgebra R X → Prop}\n    (h_grade0 : ∀ r, C (algebraMap R (FreeAlgebra R X) r)) (h_grade1 : ∀ x, C (ι R x))\n    (h_mul : ∀ a b, C a → C b → C (a * b)) (h_add : ∀ a b, C a → C b → C (a + b))\n    (a : FreeAlgebra R X) : C a := by\n  -- the arguments are enough to construct a subalgebra, and a mapping into it from X\n  let s : Subalgebra R (FreeAlgebra R X) :=\n    { carrier := C\n      mul_mem' := h_mul _ _\n      add_mem' := h_add _ _\n      algebraMap_mem' := h_grade0 }\n  let of : X → s := Subtype.coind (ι R) h_grade1\n  -- the mapping through the subalgebra is the identity\n  have of_id : AlgHom.id R (FreeAlgebra R X) = s.val.comp (lift R of) := by\n    ext\n    simp [of, Subtype.coind]\n  -- finding a proof is finding an element of the subalgebra\n  suffices a = lift R of a by\n    rw [this]\n    exact Subtype.prop (lift R of a)\n  simp [AlgHom.ext_iff] at of_id\n  exact of_id a\n\n"}
{"name":"FreeAlgebra.adjoin_range_ι","module":"Mathlib.Algebra.FreeAlgebra","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\nX : Type u_2\n⊢ Eq (Algebra.adjoin R (Set.range (FreeAlgebra.ι R))) Top.top","decl":"@[simp]\ntheorem adjoin_range_ι : Algebra.adjoin R (Set.range (ι R : X → FreeAlgebra R X)) = ⊤ := by\n  set S := Algebra.adjoin R (Set.range (ι R : X → FreeAlgebra R X))\n  refine top_unique fun x hx => ?_; clear hx\n  induction x with\n  | h_grade0 => exact S.algebraMap_mem _\n  | h_add x y hx hy => exact S.add_mem hx hy\n  | h_mul x y hx hy => exact S.mul_mem hx hy\n  | h_grade1 x => exact Algebra.subset_adjoin (Set.mem_range_self _)\n\n"}
{"name":"Algebra.adjoin_range_eq_range_freeAlgebra_lift","module":"Mathlib.Algebra.FreeAlgebra","initialProofState":"R : Type u_1\ninst✝² : CommSemiring R\nX : Type u_2\nA : Type u_3\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\nf : X → A\n⊢ Eq (Algebra.adjoin R (Set.range f)) ((FreeAlgebra.lift R) f).range","decl":"/-- Noncommutative version of `Algebra.adjoin_range_eq_range_aeval`. -/\ntheorem _root_.Algebra.adjoin_range_eq_range_freeAlgebra_lift (f : X → A) :\n    Algebra.adjoin R (Set.range f) = (FreeAlgebra.lift R f).range := by\n  simp only [← Algebra.map_top, ← adjoin_range_ι, AlgHom.map_adjoin, ← Set.range_comp,\n    Function.comp_def, lift_ι_apply]\n\n"}
{"name":"Algebra.adjoin_eq_range_freeAlgebra_lift","module":"Mathlib.Algebra.FreeAlgebra","initialProofState":"R : Type u_1\ninst✝² : CommSemiring R\nA : Type u_3\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\ns : Set A\n⊢ Eq (Algebra.adjoin R s) ((FreeAlgebra.lift R) Subtype.val).range","decl":"/-- Noncommutative version of `Algebra.adjoin_range_eq_range`. -/\ntheorem _root_.Algebra.adjoin_eq_range_freeAlgebra_lift (s : Set A) :\n    Algebra.adjoin R s = (FreeAlgebra.lift R ((↑) : s → A)).range := by\n  rw [← Algebra.adjoin_range_eq_range_freeAlgebra_lift, Subtype.range_coe]\n\n"}
