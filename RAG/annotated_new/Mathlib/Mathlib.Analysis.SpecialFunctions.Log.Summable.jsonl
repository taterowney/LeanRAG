{"name":"Complex.summable_log_one_add_of_summable","module":"Mathlib.Analysis.SpecialFunctions.Log.Summable","initialProofState":"ι : Type u_1\nf : ι → Complex\nhf : Summable f\n⊢ Summable fun i => Complex.log (HAdd.hAdd 1 (f i))","decl":"lemma Complex.summable_log_one_add_of_summable {f : ι → ℂ} (hf : Summable f) :\n    Summable (fun i : ι => Complex.log (1 + f i)) := by\n  apply (hf.norm.const_smul (3 / 2 : ℝ)).of_norm_bounded_eventually\n  filter_upwards [hf.norm.tendsto_cofinite_zero.eventually_le_const one_half_pos] with i hi\n  exact norm_log_one_add_half_le_self hi\n\n"}
{"name":"Real.summable_log_one_add_of_summable","module":"Mathlib.Analysis.SpecialFunctions.Log.Summable","initialProofState":"ι : Type u_1\nf : ι → Real\nhf : Summable f\n⊢ Summable fun i => Real.log (HAdd.hAdd 1 (abs (f i)))","decl":"lemma Real.summable_log_one_add_of_summable {f : ι → ℝ} (hf : Summable f) :\n     Summable (fun i : ι => log (1 + |f i|)) := by\n  have : Summable (fun n ↦ Complex.ofRealCLM (log (1 + |f n|))) := by\n    convert Complex.summable_log_one_add_of_summable (Complex.ofRealCLM.summable hf.norm) with x\n    rw [ofRealCLM_apply, ofReal_log (by positivity)]\n    simp only [ofReal_add, ofReal_one, norm_eq_abs, ofRealCLM_apply]\n  convert Complex.reCLM.summable this\n\n"}
{"name":"Complex.multipliable_one_add_of_summable","module":"Mathlib.Analysis.SpecialFunctions.Log.Summable","initialProofState":"ι : Type u_1\nf : ι → Complex\nhf : Summable f\nhff : ∀ (n : ι), Ne (HAdd.hAdd 1 (f n)) 0\n⊢ Multipliable fun n => HAdd.hAdd 1 (f n)","decl":"lemma Complex.multipliable_one_add_of_summable (f : ι → ℂ) (hf : Summable f)\n    (hff : ∀ n : ι, 1 + f n ≠ 0) : Multipliable (fun n : ι => 1 + f n) := by\n  refine Complex.multipliable_of_summable_log (fun n => 1 + f n) (by simpa) ?_\n  simpa only [forall_const] using Complex.summable_log_one_add_of_summable hf\n\n"}
{"name":"Real.multipliable_one_add_of_summable","module":"Mathlib.Analysis.SpecialFunctions.Log.Summable","initialProofState":"ι : Type u_1\nf : ι → Real\nhf : Summable f\n⊢ Multipliable fun n => HAdd.hAdd 1 (abs (f n))","decl":"lemma Real.multipliable_one_add_of_summable (f : ι → ℝ) (hf : Summable f) :\n    Multipliable (fun n : ι => 1 + |f n|) := by\n  refine Real.multipliable_of_summable_log (fun n => 1 + |f n|) (fun _ ↦ by positivity) ?_\n  simpa only [forall_const] using Real.summable_log_one_add_of_summable  hf\n\n"}
{"name":"Complex.tendstoUniformlyOn_tsum_nat_log_one_add","module":"Mathlib.Analysis.SpecialFunctions.Log.Summable","initialProofState":"α : Type u_2\nf : Nat → α → Complex\nK : Set α\nu : Nat → Real\nhu : Summable u\nh : Filter.Eventually (fun n => ∀ (x : α), Membership.mem K x → LE.le (Norm.norm (f n x)) (u n)) Filter.atTop\n⊢ TendstoUniformlyOn (fun n a => (Finset.range n).sum fun i => Complex.log (HAdd.hAdd 1 (f i a))) (fun a => tsum fun i => Complex.log (HAdd.hAdd 1 (f i a))) Filter.atTop K","decl":"lemma Complex.tendstoUniformlyOn_tsum_nat_log_one_add {α : Type*} {f : ℕ → α → ℂ} (K : Set α)\n    {u : ℕ → ℝ} (hu : Summable u) (h : ∀ᶠ n in atTop, ∀ x ∈ K, ‖f n x‖ ≤ u n) :\n    TendstoUniformlyOn (fun (n : ℕ) (a : α) => ∑ i ∈ Finset.range n,\n    (Complex.log (1 + f i a))) (fun a => ∑' i : ℕ, Complex.log (1 + f i a)) atTop K := by\n  apply tendstoUniformlyOn_tsum_nat_eventually (hu.mul_left (3/2))\n  obtain ⟨N, hN⟩ := Metric.tendsto_atTop.mp (Summable.tendsto_atTop_zero hu) (1/2) (one_half_pos)\n  simp only [Complex.norm_eq_abs, eventually_atTop, ge_iff_le] at *\n  obtain ⟨N2, hN2⟩ := h\n  refine ⟨max N N2, fun n hn x hx => ?_⟩\n  apply le_trans (Complex.norm_log_one_add_half_le_self (z := (f n x)) ?_)\n  · simp only [Complex.norm_eq_abs, Nat.ofNat_pos, div_pos_iff_of_pos_left, mul_le_mul_left]\n    exact hN2 n (le_of_max_le_right hn) x hx\n  · apply le_trans (le_trans (hN2 n (le_of_max_le_right hn) x hx)\n    (by simpa using Real.le_norm_self (u n))) (hN n (le_of_max_le_left hn)).le\n"}
