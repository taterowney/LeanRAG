{"name":"CategoryTheory.Functor.mapTriangle_map_homâ‚","module":"Mathlib.CategoryTheory.Triangulated.Functor","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœâ´ : CategoryTheory.Category.{u_4, u_1} C\ninstâœÂ³ : CategoryTheory.Category.{u_5, u_2} D\ninstâœÂ² : CategoryTheory.HasShift C Int\ninstâœÂ¹ : CategoryTheory.HasShift D Int\nF : CategoryTheory.Functor C D\ninstâœ : F.CommShift Int\nXâœ Yâœ : CategoryTheory.Pretriangulated.Triangle C\nf : Quiver.Hom Xâœ Yâœ\nâŠ¢ Eq (F.mapTriangle.map f).homâ‚ (F.map f.homâ‚)","decl":"/-- The functor `Triangle C â¥¤ Triangle D` that is induced by a functor `F : C â¥¤ D`\nwhich commutes with shift by `â„¤`. -/\n@[simps]\ndef mapTriangle : Triangle C â¥¤ Triangle D where\n  obj T := Triangle.mk (F.map T.morâ‚) (F.map T.morâ‚‚)\n    (F.map T.morâ‚ƒ â‰« (F.commShiftIso (1 : â„¤)).hom.app T.objâ‚)\n  map f :=\n    { homâ‚ := F.map f.homâ‚\n      homâ‚‚ := F.map f.homâ‚‚\n      homâ‚ƒ := F.map f.homâ‚ƒ\n      commâ‚ := by dsimp; simp only [â† F.map_comp, f.commâ‚]\n      commâ‚‚ := by dsimp; simp only [â† F.map_comp, f.commâ‚‚]\n      commâ‚ƒ := by\n        dsimp [Functor.comp]\n        simp only [Category.assoc, â† NatTrans.naturality,\n          â† F.map_comp_assoc, f.commâ‚ƒ] }\n\n"}
{"name":"CategoryTheory.Functor.mapTriangle_map_homâ‚‚","module":"Mathlib.CategoryTheory.Triangulated.Functor","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœâ´ : CategoryTheory.Category.{u_4, u_1} C\ninstâœÂ³ : CategoryTheory.Category.{u_5, u_2} D\ninstâœÂ² : CategoryTheory.HasShift C Int\ninstâœÂ¹ : CategoryTheory.HasShift D Int\nF : CategoryTheory.Functor C D\ninstâœ : F.CommShift Int\nXâœ Yâœ : CategoryTheory.Pretriangulated.Triangle C\nf : Quiver.Hom Xâœ Yâœ\nâŠ¢ Eq (F.mapTriangle.map f).homâ‚‚ (F.map f.homâ‚‚)","decl":"/-- The functor `Triangle C â¥¤ Triangle D` that is induced by a functor `F : C â¥¤ D`\nwhich commutes with shift by `â„¤`. -/\n@[simps]\ndef mapTriangle : Triangle C â¥¤ Triangle D where\n  obj T := Triangle.mk (F.map T.morâ‚) (F.map T.morâ‚‚)\n    (F.map T.morâ‚ƒ â‰« (F.commShiftIso (1 : â„¤)).hom.app T.objâ‚)\n  map f :=\n    { homâ‚ := F.map f.homâ‚\n      homâ‚‚ := F.map f.homâ‚‚\n      homâ‚ƒ := F.map f.homâ‚ƒ\n      commâ‚ := by dsimp; simp only [â† F.map_comp, f.commâ‚]\n      commâ‚‚ := by dsimp; simp only [â† F.map_comp, f.commâ‚‚]\n      commâ‚ƒ := by\n        dsimp [Functor.comp]\n        simp only [Category.assoc, â† NatTrans.naturality,\n          â† F.map_comp_assoc, f.commâ‚ƒ] }\n\n"}
{"name":"CategoryTheory.Functor.mapTriangle_map_homâ‚ƒ","module":"Mathlib.CategoryTheory.Triangulated.Functor","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœâ´ : CategoryTheory.Category.{u_4, u_1} C\ninstâœÂ³ : CategoryTheory.Category.{u_5, u_2} D\ninstâœÂ² : CategoryTheory.HasShift C Int\ninstâœÂ¹ : CategoryTheory.HasShift D Int\nF : CategoryTheory.Functor C D\ninstâœ : F.CommShift Int\nXâœ Yâœ : CategoryTheory.Pretriangulated.Triangle C\nf : Quiver.Hom Xâœ Yâœ\nâŠ¢ Eq (F.mapTriangle.map f).homâ‚ƒ (F.map f.homâ‚ƒ)","decl":"/-- The functor `Triangle C â¥¤ Triangle D` that is induced by a functor `F : C â¥¤ D`\nwhich commutes with shift by `â„¤`. -/\n@[simps]\ndef mapTriangle : Triangle C â¥¤ Triangle D where\n  obj T := Triangle.mk (F.map T.morâ‚) (F.map T.morâ‚‚)\n    (F.map T.morâ‚ƒ â‰« (F.commShiftIso (1 : â„¤)).hom.app T.objâ‚)\n  map f :=\n    { homâ‚ := F.map f.homâ‚\n      homâ‚‚ := F.map f.homâ‚‚\n      homâ‚ƒ := F.map f.homâ‚ƒ\n      commâ‚ := by dsimp; simp only [â† F.map_comp, f.commâ‚]\n      commâ‚‚ := by dsimp; simp only [â† F.map_comp, f.commâ‚‚]\n      commâ‚ƒ := by\n        dsimp [Functor.comp]\n        simp only [Category.assoc, â† NatTrans.naturality,\n          â† F.map_comp_assoc, f.commâ‚ƒ] }\n\n"}
{"name":"CategoryTheory.Functor.mapTriangle_obj","module":"Mathlib.CategoryTheory.Triangulated.Functor","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœâ´ : CategoryTheory.Category.{u_4, u_1} C\ninstâœÂ³ : CategoryTheory.Category.{u_5, u_2} D\ninstâœÂ² : CategoryTheory.HasShift C Int\ninstâœÂ¹ : CategoryTheory.HasShift D Int\nF : CategoryTheory.Functor C D\ninstâœ : F.CommShift Int\nT : CategoryTheory.Pretriangulated.Triangle C\nâŠ¢ Eq (F.mapTriangle.obj T) (CategoryTheory.Pretriangulated.Triangle.mk (F.map T.morâ‚) (F.map T.morâ‚‚) (CategoryTheory.CategoryStruct.comp (F.map T.morâ‚ƒ) ((F.commShiftIso 1).hom.app T.objâ‚)))","decl":"/-- The functor `Triangle C â¥¤ Triangle D` that is induced by a functor `F : C â¥¤ D`\nwhich commutes with shift by `â„¤`. -/\n@[simps]\ndef mapTriangle : Triangle C â¥¤ Triangle D where\n  obj T := Triangle.mk (F.map T.morâ‚) (F.map T.morâ‚‚)\n    (F.map T.morâ‚ƒ â‰« (F.commShiftIso (1 : â„¤)).hom.app T.objâ‚)\n  map f :=\n    { homâ‚ := F.map f.homâ‚\n      homâ‚‚ := F.map f.homâ‚‚\n      homâ‚ƒ := F.map f.homâ‚ƒ\n      commâ‚ := by dsimp; simp only [â† F.map_comp, f.commâ‚]\n      commâ‚‚ := by dsimp; simp only [â† F.map_comp, f.commâ‚‚]\n      commâ‚ƒ := by\n        dsimp [Functor.comp]\n        simp only [Category.assoc, â† NatTrans.naturality,\n          â† F.map_comp_assoc, f.commâ‚ƒ] }\n\n"}
{"name":"CategoryTheory.Functor.instFaithfulTriangleMapTriangle","module":"Mathlib.CategoryTheory.Triangulated.Functor","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœâµ : CategoryTheory.Category.{u_4, u_1} C\ninstâœâ´ : CategoryTheory.Category.{u_5, u_2} D\ninstâœÂ³ : CategoryTheory.HasShift C Int\ninstâœÂ² : CategoryTheory.HasShift D Int\nF : CategoryTheory.Functor C D\ninstâœÂ¹ : F.CommShift Int\ninstâœ : F.Faithful\nâŠ¢ F.mapTriangle.Faithful","decl":"instance [Faithful F] : Faithful F.mapTriangle where\n  map_injective {X Y} f g h := by\n    ext <;> apply F.map_injective\n    Â· exact congr_arg TriangleMorphism.homâ‚ h\n    Â· exact congr_arg TriangleMorphism.homâ‚‚ h\n    Â· exact congr_arg TriangleMorphism.homâ‚ƒ h\n\n"}
{"name":"CategoryTheory.Functor.instFullTriangleMapTriangleOfFaithful","module":"Mathlib.CategoryTheory.Triangulated.Functor","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœâ¶ : CategoryTheory.Category.{u_4, u_1} C\ninstâœâµ : CategoryTheory.Category.{u_5, u_2} D\ninstâœâ´ : CategoryTheory.HasShift C Int\ninstâœÂ³ : CategoryTheory.HasShift D Int\nF : CategoryTheory.Functor C D\ninstâœÂ² : F.CommShift Int\ninstâœÂ¹ : F.Full\ninstâœ : F.Faithful\nâŠ¢ F.mapTriangle.Full","decl":"instance [Full F] [Faithful F] : Full F.mapTriangle where\n  map_surjective {X Y} f :=\n   âŸ¨{ homâ‚ := F.preimage f.homâ‚\n      homâ‚‚ := F.preimage f.homâ‚‚\n      homâ‚ƒ := F.preimage f.homâ‚ƒ\n      commâ‚ := F.map_injective\n        (by simpa only [mapTriangle_obj, map_comp, map_preimage] using f.commâ‚)\n      commâ‚‚ := F.map_injective\n        (by simpa only [mapTriangle_obj, map_comp, map_preimage] using f.commâ‚‚)\n      commâ‚ƒ := F.map_injective (by\n        rw [â† cancel_mono ((F.commShiftIso (1 : â„¤)).hom.app Y.objâ‚)]\n        simpa only [mapTriangle_obj, map_comp, assoc, commShiftIso_hom_naturality,\n          map_preimage, Triangle.mk_morâ‚ƒ] using f.commâ‚ƒ) }, by aesop_catâŸ©\n\n"}
{"name":"CategoryTheory.Functor.mapTriangleCommShiftIso_inv_app_homâ‚","module":"Mathlib.CategoryTheory.Triangulated.Functor","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœâ¶ : CategoryTheory.Category.{u_4, u_1} C\ninstâœâµ : CategoryTheory.Category.{u_5, u_2} D\ninstâœâ´ : CategoryTheory.HasShift C Int\ninstâœÂ³ : CategoryTheory.HasShift D Int\nF : CategoryTheory.Functor C D\ninstâœÂ² : F.CommShift Int\ninstâœÂ¹ : CategoryTheory.Preadditive C\ninstâœ : CategoryTheory.Preadditive D\nn : Int\nX : CategoryTheory.Pretriangulated.Triangle C\nâŠ¢ Eq ((F.mapTriangleCommShiftIso n).inv.app X).homâ‚ ((F.commShiftIso n).inv.app X.objâ‚)","decl":"attribute [simps!] mapTriangleCommShiftIso\n\n"}
{"name":"CategoryTheory.Functor.mapTriangleCommShiftIso_hom_app_homâ‚","module":"Mathlib.CategoryTheory.Triangulated.Functor","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœâ¶ : CategoryTheory.Category.{u_4, u_1} C\ninstâœâµ : CategoryTheory.Category.{u_5, u_2} D\ninstâœâ´ : CategoryTheory.HasShift C Int\ninstâœÂ³ : CategoryTheory.HasShift D Int\nF : CategoryTheory.Functor C D\ninstâœÂ² : F.CommShift Int\ninstâœÂ¹ : CategoryTheory.Preadditive C\ninstâœ : CategoryTheory.Preadditive D\nn : Int\nX : CategoryTheory.Pretriangulated.Triangle C\nâŠ¢ Eq ((F.mapTriangleCommShiftIso n).hom.app X).homâ‚ ((F.commShiftIso n).hom.app X.objâ‚)","decl":"attribute [simps!] mapTriangleCommShiftIso\n\n"}
{"name":"CategoryTheory.Functor.mapTriangleCommShiftIso_inv_app_homâ‚ƒ","module":"Mathlib.CategoryTheory.Triangulated.Functor","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœâ¶ : CategoryTheory.Category.{u_4, u_1} C\ninstâœâµ : CategoryTheory.Category.{u_5, u_2} D\ninstâœâ´ : CategoryTheory.HasShift C Int\ninstâœÂ³ : CategoryTheory.HasShift D Int\nF : CategoryTheory.Functor C D\ninstâœÂ² : F.CommShift Int\ninstâœÂ¹ : CategoryTheory.Preadditive C\ninstâœ : CategoryTheory.Preadditive D\nn : Int\nX : CategoryTheory.Pretriangulated.Triangle C\nâŠ¢ Eq ((F.mapTriangleCommShiftIso n).inv.app X).homâ‚ƒ ((F.commShiftIso n).inv.app X.objâ‚ƒ)","decl":"attribute [simps!] mapTriangleCommShiftIso\n\n"}
{"name":"CategoryTheory.Functor.mapTriangleCommShiftIso_hom_app_homâ‚‚","module":"Mathlib.CategoryTheory.Triangulated.Functor","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœâ¶ : CategoryTheory.Category.{u_4, u_1} C\ninstâœâµ : CategoryTheory.Category.{u_5, u_2} D\ninstâœâ´ : CategoryTheory.HasShift C Int\ninstâœÂ³ : CategoryTheory.HasShift D Int\nF : CategoryTheory.Functor C D\ninstâœÂ² : F.CommShift Int\ninstâœÂ¹ : CategoryTheory.Preadditive C\ninstâœ : CategoryTheory.Preadditive D\nn : Int\nX : CategoryTheory.Pretriangulated.Triangle C\nâŠ¢ Eq ((F.mapTriangleCommShiftIso n).hom.app X).homâ‚‚ ((F.commShiftIso n).hom.app X.objâ‚‚)","decl":"attribute [simps!] mapTriangleCommShiftIso\n\n"}
{"name":"CategoryTheory.Functor.mapTriangleCommShiftIso_inv_app_homâ‚‚","module":"Mathlib.CategoryTheory.Triangulated.Functor","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœâ¶ : CategoryTheory.Category.{u_4, u_1} C\ninstâœâµ : CategoryTheory.Category.{u_5, u_2} D\ninstâœâ´ : CategoryTheory.HasShift C Int\ninstâœÂ³ : CategoryTheory.HasShift D Int\nF : CategoryTheory.Functor C D\ninstâœÂ² : F.CommShift Int\ninstâœÂ¹ : CategoryTheory.Preadditive C\ninstâœ : CategoryTheory.Preadditive D\nn : Int\nX : CategoryTheory.Pretriangulated.Triangle C\nâŠ¢ Eq ((F.mapTriangleCommShiftIso n).inv.app X).homâ‚‚ ((F.commShiftIso n).inv.app X.objâ‚‚)","decl":"attribute [simps!] mapTriangleCommShiftIso\n\n"}
{"name":"CategoryTheory.Functor.mapTriangleCommShiftIso_hom_app_homâ‚ƒ","module":"Mathlib.CategoryTheory.Triangulated.Functor","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœâ¶ : CategoryTheory.Category.{u_4, u_1} C\ninstâœâµ : CategoryTheory.Category.{u_5, u_2} D\ninstâœâ´ : CategoryTheory.HasShift C Int\ninstâœÂ³ : CategoryTheory.HasShift D Int\nF : CategoryTheory.Functor C D\ninstâœÂ² : F.CommShift Int\ninstâœÂ¹ : CategoryTheory.Preadditive C\ninstâœ : CategoryTheory.Preadditive D\nn : Int\nX : CategoryTheory.Pretriangulated.Triangle C\nâŠ¢ Eq ((F.mapTriangleCommShiftIso n).hom.app X).homâ‚ƒ ((F.commShiftIso n).hom.app X.objâ‚ƒ)","decl":"attribute [simps!] mapTriangleCommShiftIso\n\n"}
{"name":"CategoryTheory.Functor.mapTriangleRotateIso_inv_app_homâ‚ƒ","module":"Mathlib.CategoryTheory.Triangulated.Functor","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœâ¶ : CategoryTheory.Category.{u_4, u_1} C\ninstâœâµ : CategoryTheory.Category.{u_5, u_2} D\ninstâœâ´ : CategoryTheory.HasShift C Int\ninstâœÂ³ : CategoryTheory.HasShift D Int\nF : CategoryTheory.Functor C D\ninstâœÂ² : F.CommShift Int\ninstâœÂ¹ : CategoryTheory.Preadditive C\ninstâœ : CategoryTheory.Preadditive D\nX : CategoryTheory.Pretriangulated.Triangle C\nâŠ¢ Eq (F.mapTriangleRotateIso.inv.app X).homâ‚ƒ ((F.commShiftIso 1).hom.app X.objâ‚)","decl":"/-- `F.mapTriangle` commutes with the rotation of triangles. -/\n@[simps!]\ndef mapTriangleRotateIso :\n    F.mapTriangle â‹™ Pretriangulated.rotate D â‰…\n      Pretriangulated.rotate C â‹™ F.mapTriangle :=\n  NatIso.ofComponents\n    (fun T => Triangle.isoMk _ _ (Iso.refl _) (Iso.refl _)\n      ((F.commShiftIso (1 : â„¤)).symm.app _)\n      (by simp) (by simp) (by simp)) (by aesop_cat)\n\n"}
{"name":"CategoryTheory.Functor.mapTriangleRotateIso_inv_app_homâ‚","module":"Mathlib.CategoryTheory.Triangulated.Functor","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœâ¶ : CategoryTheory.Category.{u_4, u_1} C\ninstâœâµ : CategoryTheory.Category.{u_5, u_2} D\ninstâœâ´ : CategoryTheory.HasShift C Int\ninstâœÂ³ : CategoryTheory.HasShift D Int\nF : CategoryTheory.Functor C D\ninstâœÂ² : F.CommShift Int\ninstâœÂ¹ : CategoryTheory.Preadditive C\ninstâœ : CategoryTheory.Preadditive D\nX : CategoryTheory.Pretriangulated.Triangle C\nâŠ¢ Eq (F.mapTriangleRotateIso.inv.app X).homâ‚ (CategoryTheory.CategoryStruct.id (F.obj X.objâ‚‚))","decl":"/-- `F.mapTriangle` commutes with the rotation of triangles. -/\n@[simps!]\ndef mapTriangleRotateIso :\n    F.mapTriangle â‹™ Pretriangulated.rotate D â‰…\n      Pretriangulated.rotate C â‹™ F.mapTriangle :=\n  NatIso.ofComponents\n    (fun T => Triangle.isoMk _ _ (Iso.refl _) (Iso.refl _)\n      ((F.commShiftIso (1 : â„¤)).symm.app _)\n      (by simp) (by simp) (by simp)) (by aesop_cat)\n\n"}
{"name":"CategoryTheory.Functor.mapTriangleRotateIso_inv_app_homâ‚‚","module":"Mathlib.CategoryTheory.Triangulated.Functor","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœâ¶ : CategoryTheory.Category.{u_4, u_1} C\ninstâœâµ : CategoryTheory.Category.{u_5, u_2} D\ninstâœâ´ : CategoryTheory.HasShift C Int\ninstâœÂ³ : CategoryTheory.HasShift D Int\nF : CategoryTheory.Functor C D\ninstâœÂ² : F.CommShift Int\ninstâœÂ¹ : CategoryTheory.Preadditive C\ninstâœ : CategoryTheory.Preadditive D\nX : CategoryTheory.Pretriangulated.Triangle C\nâŠ¢ Eq (F.mapTriangleRotateIso.inv.app X).homâ‚‚ (CategoryTheory.CategoryStruct.id (F.obj X.objâ‚ƒ))","decl":"/-- `F.mapTriangle` commutes with the rotation of triangles. -/\n@[simps!]\ndef mapTriangleRotateIso :\n    F.mapTriangle â‹™ Pretriangulated.rotate D â‰…\n      Pretriangulated.rotate C â‹™ F.mapTriangle :=\n  NatIso.ofComponents\n    (fun T => Triangle.isoMk _ _ (Iso.refl _) (Iso.refl _)\n      ((F.commShiftIso (1 : â„¤)).symm.app _)\n      (by simp) (by simp) (by simp)) (by aesop_cat)\n\n"}
{"name":"CategoryTheory.Functor.mapTriangleRotateIso_hom_app_homâ‚","module":"Mathlib.CategoryTheory.Triangulated.Functor","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœâ¶ : CategoryTheory.Category.{u_4, u_1} C\ninstâœâµ : CategoryTheory.Category.{u_5, u_2} D\ninstâœâ´ : CategoryTheory.HasShift C Int\ninstâœÂ³ : CategoryTheory.HasShift D Int\nF : CategoryTheory.Functor C D\ninstâœÂ² : F.CommShift Int\ninstâœÂ¹ : CategoryTheory.Preadditive C\ninstâœ : CategoryTheory.Preadditive D\nX : CategoryTheory.Pretriangulated.Triangle C\nâŠ¢ Eq (F.mapTriangleRotateIso.hom.app X).homâ‚ (CategoryTheory.CategoryStruct.id (F.obj X.objâ‚‚))","decl":"/-- `F.mapTriangle` commutes with the rotation of triangles. -/\n@[simps!]\ndef mapTriangleRotateIso :\n    F.mapTriangle â‹™ Pretriangulated.rotate D â‰…\n      Pretriangulated.rotate C â‹™ F.mapTriangle :=\n  NatIso.ofComponents\n    (fun T => Triangle.isoMk _ _ (Iso.refl _) (Iso.refl _)\n      ((F.commShiftIso (1 : â„¤)).symm.app _)\n      (by simp) (by simp) (by simp)) (by aesop_cat)\n\n"}
{"name":"CategoryTheory.Functor.mapTriangleRotateIso_hom_app_homâ‚ƒ","module":"Mathlib.CategoryTheory.Triangulated.Functor","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœâ¶ : CategoryTheory.Category.{u_4, u_1} C\ninstâœâµ : CategoryTheory.Category.{u_5, u_2} D\ninstâœâ´ : CategoryTheory.HasShift C Int\ninstâœÂ³ : CategoryTheory.HasShift D Int\nF : CategoryTheory.Functor C D\ninstâœÂ² : F.CommShift Int\ninstâœÂ¹ : CategoryTheory.Preadditive C\ninstâœ : CategoryTheory.Preadditive D\nX : CategoryTheory.Pretriangulated.Triangle C\nâŠ¢ Eq (F.mapTriangleRotateIso.hom.app X).homâ‚ƒ ((F.commShiftIso 1).inv.app X.objâ‚)","decl":"/-- `F.mapTriangle` commutes with the rotation of triangles. -/\n@[simps!]\ndef mapTriangleRotateIso :\n    F.mapTriangle â‹™ Pretriangulated.rotate D â‰…\n      Pretriangulated.rotate C â‹™ F.mapTriangle :=\n  NatIso.ofComponents\n    (fun T => Triangle.isoMk _ _ (Iso.refl _) (Iso.refl _)\n      ((F.commShiftIso (1 : â„¤)).symm.app _)\n      (by simp) (by simp) (by simp)) (by aesop_cat)\n\n"}
{"name":"CategoryTheory.Functor.mapTriangleRotateIso_hom_app_homâ‚‚","module":"Mathlib.CategoryTheory.Triangulated.Functor","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœâ¶ : CategoryTheory.Category.{u_4, u_1} C\ninstâœâµ : CategoryTheory.Category.{u_5, u_2} D\ninstâœâ´ : CategoryTheory.HasShift C Int\ninstâœÂ³ : CategoryTheory.HasShift D Int\nF : CategoryTheory.Functor C D\ninstâœÂ² : F.CommShift Int\ninstâœÂ¹ : CategoryTheory.Preadditive C\ninstâœ : CategoryTheory.Preadditive D\nX : CategoryTheory.Pretriangulated.Triangle C\nâŠ¢ Eq (F.mapTriangleRotateIso.hom.app X).homâ‚‚ (CategoryTheory.CategoryStruct.id (F.obj X.objâ‚ƒ))","decl":"/-- `F.mapTriangle` commutes with the rotation of triangles. -/\n@[simps!]\ndef mapTriangleRotateIso :\n    F.mapTriangle â‹™ Pretriangulated.rotate D â‰…\n      Pretriangulated.rotate C â‹™ F.mapTriangle :=\n  NatIso.ofComponents\n    (fun T => Triangle.isoMk _ _ (Iso.refl _) (Iso.refl _)\n      ((F.commShiftIso (1 : â„¤)).symm.app _)\n      (by simp) (by simp) (by simp)) (by aesop_cat)\n\n"}
{"name":"CategoryTheory.Functor.mapTriangleInvRotateIso_inv_app_homâ‚ƒ","module":"Mathlib.CategoryTheory.Triangulated.Functor","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœâ· : CategoryTheory.Category.{u_4, u_1} C\ninstâœâ¶ : CategoryTheory.Category.{u_5, u_2} D\ninstâœâµ : CategoryTheory.HasShift C Int\ninstâœâ´ : CategoryTheory.HasShift D Int\nF : CategoryTheory.Functor C D\ninstâœÂ³ : F.CommShift Int\ninstâœÂ² : CategoryTheory.Preadditive C\ninstâœÂ¹ : CategoryTheory.Preadditive D\ninstâœ : F.Additive\nX : CategoryTheory.Pretriangulated.Triangle C\nâŠ¢ Eq (F.mapTriangleInvRotateIso.inv.app X).homâ‚ƒ (CategoryTheory.CategoryStruct.id (F.obj X.objâ‚‚))","decl":"/-- `F.mapTriangle` commutes with the inverse of the rotation of triangles. -/\n@[simps!]\nnoncomputable def mapTriangleInvRotateIso [F.Additive] :\n    F.mapTriangle â‹™ Pretriangulated.invRotate D â‰…\n      Pretriangulated.invRotate C â‹™ F.mapTriangle :=\n  NatIso.ofComponents\n    (fun T => Triangle.isoMk _ _ ((F.commShiftIso (-1 : â„¤)).symm.app _) (Iso.refl _) (Iso.refl _)\n      (by simp) (by simp) (by simp)) (by aesop_cat)\n\n\n"}
{"name":"CategoryTheory.Functor.mapTriangleInvRotateIso_hom_app_homâ‚‚","module":"Mathlib.CategoryTheory.Triangulated.Functor","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœâ· : CategoryTheory.Category.{u_4, u_1} C\ninstâœâ¶ : CategoryTheory.Category.{u_5, u_2} D\ninstâœâµ : CategoryTheory.HasShift C Int\ninstâœâ´ : CategoryTheory.HasShift D Int\nF : CategoryTheory.Functor C D\ninstâœÂ³ : F.CommShift Int\ninstâœÂ² : CategoryTheory.Preadditive C\ninstâœÂ¹ : CategoryTheory.Preadditive D\ninstâœ : F.Additive\nX : CategoryTheory.Pretriangulated.Triangle C\nâŠ¢ Eq (F.mapTriangleInvRotateIso.hom.app X).homâ‚‚ (CategoryTheory.CategoryStruct.id (F.obj X.objâ‚))","decl":"/-- `F.mapTriangle` commutes with the inverse of the rotation of triangles. -/\n@[simps!]\nnoncomputable def mapTriangleInvRotateIso [F.Additive] :\n    F.mapTriangle â‹™ Pretriangulated.invRotate D â‰…\n      Pretriangulated.invRotate C â‹™ F.mapTriangle :=\n  NatIso.ofComponents\n    (fun T => Triangle.isoMk _ _ ((F.commShiftIso (-1 : â„¤)).symm.app _) (Iso.refl _) (Iso.refl _)\n      (by simp) (by simp) (by simp)) (by aesop_cat)\n\n\n"}
{"name":"CategoryTheory.Functor.mapTriangleInvRotateIso_inv_app_homâ‚‚","module":"Mathlib.CategoryTheory.Triangulated.Functor","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœâ· : CategoryTheory.Category.{u_4, u_1} C\ninstâœâ¶ : CategoryTheory.Category.{u_5, u_2} D\ninstâœâµ : CategoryTheory.HasShift C Int\ninstâœâ´ : CategoryTheory.HasShift D Int\nF : CategoryTheory.Functor C D\ninstâœÂ³ : F.CommShift Int\ninstâœÂ² : CategoryTheory.Preadditive C\ninstâœÂ¹ : CategoryTheory.Preadditive D\ninstâœ : F.Additive\nX : CategoryTheory.Pretriangulated.Triangle C\nâŠ¢ Eq (F.mapTriangleInvRotateIso.inv.app X).homâ‚‚ (CategoryTheory.CategoryStruct.id (F.obj X.objâ‚))","decl":"/-- `F.mapTriangle` commutes with the inverse of the rotation of triangles. -/\n@[simps!]\nnoncomputable def mapTriangleInvRotateIso [F.Additive] :\n    F.mapTriangle â‹™ Pretriangulated.invRotate D â‰…\n      Pretriangulated.invRotate C â‹™ F.mapTriangle :=\n  NatIso.ofComponents\n    (fun T => Triangle.isoMk _ _ ((F.commShiftIso (-1 : â„¤)).symm.app _) (Iso.refl _) (Iso.refl _)\n      (by simp) (by simp) (by simp)) (by aesop_cat)\n\n\n"}
{"name":"CategoryTheory.Functor.mapTriangleInvRotateIso_hom_app_homâ‚","module":"Mathlib.CategoryTheory.Triangulated.Functor","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœâ· : CategoryTheory.Category.{u_4, u_1} C\ninstâœâ¶ : CategoryTheory.Category.{u_5, u_2} D\ninstâœâµ : CategoryTheory.HasShift C Int\ninstâœâ´ : CategoryTheory.HasShift D Int\nF : CategoryTheory.Functor C D\ninstâœÂ³ : F.CommShift Int\ninstâœÂ² : CategoryTheory.Preadditive C\ninstâœÂ¹ : CategoryTheory.Preadditive D\ninstâœ : F.Additive\nX : CategoryTheory.Pretriangulated.Triangle C\nâŠ¢ Eq (F.mapTriangleInvRotateIso.hom.app X).homâ‚ ((F.commShiftIso (-1)).inv.app X.objâ‚ƒ)","decl":"/-- `F.mapTriangle` commutes with the inverse of the rotation of triangles. -/\n@[simps!]\nnoncomputable def mapTriangleInvRotateIso [F.Additive] :\n    F.mapTriangle â‹™ Pretriangulated.invRotate D â‰…\n      Pretriangulated.invRotate C â‹™ F.mapTriangle :=\n  NatIso.ofComponents\n    (fun T => Triangle.isoMk _ _ ((F.commShiftIso (-1 : â„¤)).symm.app _) (Iso.refl _) (Iso.refl _)\n      (by simp) (by simp) (by simp)) (by aesop_cat)\n\n\n"}
{"name":"CategoryTheory.Functor.mapTriangleInvRotateIso_inv_app_homâ‚","module":"Mathlib.CategoryTheory.Triangulated.Functor","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœâ· : CategoryTheory.Category.{u_4, u_1} C\ninstâœâ¶ : CategoryTheory.Category.{u_5, u_2} D\ninstâœâµ : CategoryTheory.HasShift C Int\ninstâœâ´ : CategoryTheory.HasShift D Int\nF : CategoryTheory.Functor C D\ninstâœÂ³ : F.CommShift Int\ninstâœÂ² : CategoryTheory.Preadditive C\ninstâœÂ¹ : CategoryTheory.Preadditive D\ninstâœ : F.Additive\nX : CategoryTheory.Pretriangulated.Triangle C\nâŠ¢ Eq (F.mapTriangleInvRotateIso.inv.app X).homâ‚ ((F.commShiftIso (-1)).hom.app X.objâ‚ƒ)","decl":"/-- `F.mapTriangle` commutes with the inverse of the rotation of triangles. -/\n@[simps!]\nnoncomputable def mapTriangleInvRotateIso [F.Additive] :\n    F.mapTriangle â‹™ Pretriangulated.invRotate D â‰…\n      Pretriangulated.invRotate C â‹™ F.mapTriangle :=\n  NatIso.ofComponents\n    (fun T => Triangle.isoMk _ _ ((F.commShiftIso (-1 : â„¤)).symm.app _) (Iso.refl _) (Iso.refl _)\n      (by simp) (by simp) (by simp)) (by aesop_cat)\n\n\n"}
{"name":"CategoryTheory.Functor.mapTriangleInvRotateIso_hom_app_homâ‚ƒ","module":"Mathlib.CategoryTheory.Triangulated.Functor","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœâ· : CategoryTheory.Category.{u_4, u_1} C\ninstâœâ¶ : CategoryTheory.Category.{u_5, u_2} D\ninstâœâµ : CategoryTheory.HasShift C Int\ninstâœâ´ : CategoryTheory.HasShift D Int\nF : CategoryTheory.Functor C D\ninstâœÂ³ : F.CommShift Int\ninstâœÂ² : CategoryTheory.Preadditive C\ninstâœÂ¹ : CategoryTheory.Preadditive D\ninstâœ : F.Additive\nX : CategoryTheory.Pretriangulated.Triangle C\nâŠ¢ Eq (F.mapTriangleInvRotateIso.hom.app X).homâ‚ƒ (CategoryTheory.CategoryStruct.id (F.obj X.objâ‚‚))","decl":"/-- `F.mapTriangle` commutes with the inverse of the rotation of triangles. -/\n@[simps!]\nnoncomputable def mapTriangleInvRotateIso [F.Additive] :\n    F.mapTriangle â‹™ Pretriangulated.invRotate D â‰…\n      Pretriangulated.invRotate C â‹™ F.mapTriangle :=\n  NatIso.ofComponents\n    (fun T => Triangle.isoMk _ _ ((F.commShiftIso (-1 : â„¤)).symm.app _) (Iso.refl _) (Iso.refl _)\n      (by simp) (by simp) (by simp)) (by aesop_cat)\n\n\n"}
{"name":"CategoryTheory.Functor.mapTriangleIdIso_inv_app_homâ‚‚","module":"Mathlib.CategoryTheory.Triangulated.Functor","initialProofState":"C : Type u_1\ninstâœÂ¹ : CategoryTheory.Category.{u_4, u_1} C\ninstâœ : CategoryTheory.HasShift C Int\nX : CategoryTheory.Pretriangulated.Triangle C\nâŠ¢ Eq ((CategoryTheory.Functor.mapTriangleIdIso C).inv.app X).homâ‚‚ (CategoryTheory.CategoryStruct.id X.objâ‚‚)","decl":"variable (C) in\n/-- The canonical isomorphism `(ğŸ­ C).mapTriangle â‰… ğŸ­ (Triangle C)`. -/\n@[simps!]\ndef mapTriangleIdIso : (ğŸ­ C).mapTriangle â‰… ğŸ­ _ :=\n  NatIso.ofComponents (fun T â†¦ Triangle.isoMk _ _ (Iso.refl _) (Iso.refl _) (Iso.refl _))\n\n"}
{"name":"CategoryTheory.Functor.mapTriangleIdIso_inv_app_homâ‚ƒ","module":"Mathlib.CategoryTheory.Triangulated.Functor","initialProofState":"C : Type u_1\ninstâœÂ¹ : CategoryTheory.Category.{u_4, u_1} C\ninstâœ : CategoryTheory.HasShift C Int\nX : CategoryTheory.Pretriangulated.Triangle C\nâŠ¢ Eq ((CategoryTheory.Functor.mapTriangleIdIso C).inv.app X).homâ‚ƒ (CategoryTheory.CategoryStruct.id X.objâ‚ƒ)","decl":"variable (C) in\n/-- The canonical isomorphism `(ğŸ­ C).mapTriangle â‰… ğŸ­ (Triangle C)`. -/\n@[simps!]\ndef mapTriangleIdIso : (ğŸ­ C).mapTriangle â‰… ğŸ­ _ :=\n  NatIso.ofComponents (fun T â†¦ Triangle.isoMk _ _ (Iso.refl _) (Iso.refl _) (Iso.refl _))\n\n"}
{"name":"CategoryTheory.Functor.mapTriangleIdIso_hom_app_homâ‚","module":"Mathlib.CategoryTheory.Triangulated.Functor","initialProofState":"C : Type u_1\ninstâœÂ¹ : CategoryTheory.Category.{u_4, u_1} C\ninstâœ : CategoryTheory.HasShift C Int\nX : CategoryTheory.Pretriangulated.Triangle C\nâŠ¢ Eq ((CategoryTheory.Functor.mapTriangleIdIso C).hom.app X).homâ‚ (CategoryTheory.CategoryStruct.id X.objâ‚)","decl":"variable (C) in\n/-- The canonical isomorphism `(ğŸ­ C).mapTriangle â‰… ğŸ­ (Triangle C)`. -/\n@[simps!]\ndef mapTriangleIdIso : (ğŸ­ C).mapTriangle â‰… ğŸ­ _ :=\n  NatIso.ofComponents (fun T â†¦ Triangle.isoMk _ _ (Iso.refl _) (Iso.refl _) (Iso.refl _))\n\n"}
{"name":"CategoryTheory.Functor.mapTriangleIdIso_hom_app_homâ‚‚","module":"Mathlib.CategoryTheory.Triangulated.Functor","initialProofState":"C : Type u_1\ninstâœÂ¹ : CategoryTheory.Category.{u_4, u_1} C\ninstâœ : CategoryTheory.HasShift C Int\nX : CategoryTheory.Pretriangulated.Triangle C\nâŠ¢ Eq ((CategoryTheory.Functor.mapTriangleIdIso C).hom.app X).homâ‚‚ (CategoryTheory.CategoryStruct.id X.objâ‚‚)","decl":"variable (C) in\n/-- The canonical isomorphism `(ğŸ­ C).mapTriangle â‰… ğŸ­ (Triangle C)`. -/\n@[simps!]\ndef mapTriangleIdIso : (ğŸ­ C).mapTriangle â‰… ğŸ­ _ :=\n  NatIso.ofComponents (fun T â†¦ Triangle.isoMk _ _ (Iso.refl _) (Iso.refl _) (Iso.refl _))\n\n"}
{"name":"CategoryTheory.Functor.mapTriangleIdIso_hom_app_homâ‚ƒ","module":"Mathlib.CategoryTheory.Triangulated.Functor","initialProofState":"C : Type u_1\ninstâœÂ¹ : CategoryTheory.Category.{u_4, u_1} C\ninstâœ : CategoryTheory.HasShift C Int\nX : CategoryTheory.Pretriangulated.Triangle C\nâŠ¢ Eq ((CategoryTheory.Functor.mapTriangleIdIso C).hom.app X).homâ‚ƒ (CategoryTheory.CategoryStruct.id X.objâ‚ƒ)","decl":"variable (C) in\n/-- The canonical isomorphism `(ğŸ­ C).mapTriangle â‰… ğŸ­ (Triangle C)`. -/\n@[simps!]\ndef mapTriangleIdIso : (ğŸ­ C).mapTriangle â‰… ğŸ­ _ :=\n  NatIso.ofComponents (fun T â†¦ Triangle.isoMk _ _ (Iso.refl _) (Iso.refl _) (Iso.refl _))\n\n"}
{"name":"CategoryTheory.Functor.mapTriangleIdIso_inv_app_homâ‚","module":"Mathlib.CategoryTheory.Triangulated.Functor","initialProofState":"C : Type u_1\ninstâœÂ¹ : CategoryTheory.Category.{u_4, u_1} C\ninstâœ : CategoryTheory.HasShift C Int\nX : CategoryTheory.Pretriangulated.Triangle C\nâŠ¢ Eq ((CategoryTheory.Functor.mapTriangleIdIso C).inv.app X).homâ‚ (CategoryTheory.CategoryStruct.id X.objâ‚)","decl":"variable (C) in\n/-- The canonical isomorphism `(ğŸ­ C).mapTriangle â‰… ğŸ­ (Triangle C)`. -/\n@[simps!]\ndef mapTriangleIdIso : (ğŸ­ C).mapTriangle â‰… ğŸ­ _ :=\n  NatIso.ofComponents (fun T â†¦ Triangle.isoMk _ _ (Iso.refl _) (Iso.refl _) (Iso.refl _))\n\n"}
{"name":"CategoryTheory.Functor.mapTriangleCompIso_hom_app_homâ‚","module":"Mathlib.CategoryTheory.Triangulated.Functor","initialProofState":"C : Type u_1\nD : Type u_2\nE : Type u_3\ninstâœâ· : CategoryTheory.Category.{u_4, u_1} C\ninstâœâ¶ : CategoryTheory.Category.{u_5, u_2} D\ninstâœâµ : CategoryTheory.Category.{u_6, u_3} E\ninstâœâ´ : CategoryTheory.HasShift C Int\ninstâœÂ³ : CategoryTheory.HasShift D Int\ninstâœÂ² : CategoryTheory.HasShift E Int\nF : CategoryTheory.Functor C D\ninstâœÂ¹ : F.CommShift Int\nG : CategoryTheory.Functor D E\ninstâœ : G.CommShift Int\nX : CategoryTheory.Pretriangulated.Triangle C\nâŠ¢ Eq ((F.mapTriangleCompIso G).hom.app X).homâ‚ (CategoryTheory.CategoryStruct.id (G.obj (F.obj X.objâ‚)))","decl":"/-- The canonical isomorphism `(F â‹™ G).mapTriangle â‰… F.mapTriangle â‹™ G.mapTriangle`. -/\n@[simps!]\ndef mapTriangleCompIso : (F â‹™ G).mapTriangle â‰… F.mapTriangle â‹™ G.mapTriangle :=\n  NatIso.ofComponents (fun T => Triangle.isoMk _ _ (Iso.refl _) (Iso.refl _) (Iso.refl _))\n\n"}
{"name":"CategoryTheory.Functor.mapTriangleCompIso_hom_app_homâ‚ƒ","module":"Mathlib.CategoryTheory.Triangulated.Functor","initialProofState":"C : Type u_1\nD : Type u_2\nE : Type u_3\ninstâœâ· : CategoryTheory.Category.{u_4, u_1} C\ninstâœâ¶ : CategoryTheory.Category.{u_5, u_2} D\ninstâœâµ : CategoryTheory.Category.{u_6, u_3} E\ninstâœâ´ : CategoryTheory.HasShift C Int\ninstâœÂ³ : CategoryTheory.HasShift D Int\ninstâœÂ² : CategoryTheory.HasShift E Int\nF : CategoryTheory.Functor C D\ninstâœÂ¹ : F.CommShift Int\nG : CategoryTheory.Functor D E\ninstâœ : G.CommShift Int\nX : CategoryTheory.Pretriangulated.Triangle C\nâŠ¢ Eq ((F.mapTriangleCompIso G).hom.app X).homâ‚ƒ (CategoryTheory.CategoryStruct.id (G.obj (F.obj X.objâ‚ƒ)))","decl":"/-- The canonical isomorphism `(F â‹™ G).mapTriangle â‰… F.mapTriangle â‹™ G.mapTriangle`. -/\n@[simps!]\ndef mapTriangleCompIso : (F â‹™ G).mapTriangle â‰… F.mapTriangle â‹™ G.mapTriangle :=\n  NatIso.ofComponents (fun T => Triangle.isoMk _ _ (Iso.refl _) (Iso.refl _) (Iso.refl _))\n\n"}
{"name":"CategoryTheory.Functor.mapTriangleCompIso_inv_app_homâ‚‚","module":"Mathlib.CategoryTheory.Triangulated.Functor","initialProofState":"C : Type u_1\nD : Type u_2\nE : Type u_3\ninstâœâ· : CategoryTheory.Category.{u_4, u_1} C\ninstâœâ¶ : CategoryTheory.Category.{u_5, u_2} D\ninstâœâµ : CategoryTheory.Category.{u_6, u_3} E\ninstâœâ´ : CategoryTheory.HasShift C Int\ninstâœÂ³ : CategoryTheory.HasShift D Int\ninstâœÂ² : CategoryTheory.HasShift E Int\nF : CategoryTheory.Functor C D\ninstâœÂ¹ : F.CommShift Int\nG : CategoryTheory.Functor D E\ninstâœ : G.CommShift Int\nX : CategoryTheory.Pretriangulated.Triangle C\nâŠ¢ Eq ((F.mapTriangleCompIso G).inv.app X).homâ‚‚ (CategoryTheory.CategoryStruct.id (G.obj (F.obj X.objâ‚‚)))","decl":"/-- The canonical isomorphism `(F â‹™ G).mapTriangle â‰… F.mapTriangle â‹™ G.mapTriangle`. -/\n@[simps!]\ndef mapTriangleCompIso : (F â‹™ G).mapTriangle â‰… F.mapTriangle â‹™ G.mapTriangle :=\n  NatIso.ofComponents (fun T => Triangle.isoMk _ _ (Iso.refl _) (Iso.refl _) (Iso.refl _))\n\n"}
{"name":"CategoryTheory.Functor.mapTriangleCompIso_inv_app_homâ‚ƒ","module":"Mathlib.CategoryTheory.Triangulated.Functor","initialProofState":"C : Type u_1\nD : Type u_2\nE : Type u_3\ninstâœâ· : CategoryTheory.Category.{u_4, u_1} C\ninstâœâ¶ : CategoryTheory.Category.{u_5, u_2} D\ninstâœâµ : CategoryTheory.Category.{u_6, u_3} E\ninstâœâ´ : CategoryTheory.HasShift C Int\ninstâœÂ³ : CategoryTheory.HasShift D Int\ninstâœÂ² : CategoryTheory.HasShift E Int\nF : CategoryTheory.Functor C D\ninstâœÂ¹ : F.CommShift Int\nG : CategoryTheory.Functor D E\ninstâœ : G.CommShift Int\nX : CategoryTheory.Pretriangulated.Triangle C\nâŠ¢ Eq ((F.mapTriangleCompIso G).inv.app X).homâ‚ƒ (CategoryTheory.CategoryStruct.id (G.obj (F.obj X.objâ‚ƒ)))","decl":"/-- The canonical isomorphism `(F â‹™ G).mapTriangle â‰… F.mapTriangle â‹™ G.mapTriangle`. -/\n@[simps!]\ndef mapTriangleCompIso : (F â‹™ G).mapTriangle â‰… F.mapTriangle â‹™ G.mapTriangle :=\n  NatIso.ofComponents (fun T => Triangle.isoMk _ _ (Iso.refl _) (Iso.refl _) (Iso.refl _))\n\n"}
{"name":"CategoryTheory.Functor.mapTriangleCompIso_inv_app_homâ‚","module":"Mathlib.CategoryTheory.Triangulated.Functor","initialProofState":"C : Type u_1\nD : Type u_2\nE : Type u_3\ninstâœâ· : CategoryTheory.Category.{u_4, u_1} C\ninstâœâ¶ : CategoryTheory.Category.{u_5, u_2} D\ninstâœâµ : CategoryTheory.Category.{u_6, u_3} E\ninstâœâ´ : CategoryTheory.HasShift C Int\ninstâœÂ³ : CategoryTheory.HasShift D Int\ninstâœÂ² : CategoryTheory.HasShift E Int\nF : CategoryTheory.Functor C D\ninstâœÂ¹ : F.CommShift Int\nG : CategoryTheory.Functor D E\ninstâœ : G.CommShift Int\nX : CategoryTheory.Pretriangulated.Triangle C\nâŠ¢ Eq ((F.mapTriangleCompIso G).inv.app X).homâ‚ (CategoryTheory.CategoryStruct.id (G.obj (F.obj X.objâ‚)))","decl":"/-- The canonical isomorphism `(F â‹™ G).mapTriangle â‰… F.mapTriangle â‹™ G.mapTriangle`. -/\n@[simps!]\ndef mapTriangleCompIso : (F â‹™ G).mapTriangle â‰… F.mapTriangle â‹™ G.mapTriangle :=\n  NatIso.ofComponents (fun T => Triangle.isoMk _ _ (Iso.refl _) (Iso.refl _) (Iso.refl _))\n\n"}
{"name":"CategoryTheory.Functor.mapTriangleCompIso_hom_app_homâ‚‚","module":"Mathlib.CategoryTheory.Triangulated.Functor","initialProofState":"C : Type u_1\nD : Type u_2\nE : Type u_3\ninstâœâ· : CategoryTheory.Category.{u_4, u_1} C\ninstâœâ¶ : CategoryTheory.Category.{u_5, u_2} D\ninstâœâµ : CategoryTheory.Category.{u_6, u_3} E\ninstâœâ´ : CategoryTheory.HasShift C Int\ninstâœÂ³ : CategoryTheory.HasShift D Int\ninstâœÂ² : CategoryTheory.HasShift E Int\nF : CategoryTheory.Functor C D\ninstâœÂ¹ : F.CommShift Int\nG : CategoryTheory.Functor D E\ninstâœ : G.CommShift Int\nX : CategoryTheory.Pretriangulated.Triangle C\nâŠ¢ Eq ((F.mapTriangleCompIso G).hom.app X).homâ‚‚ (CategoryTheory.CategoryStruct.id (G.obj (F.obj X.objâ‚‚)))","decl":"/-- The canonical isomorphism `(F â‹™ G).mapTriangle â‰… F.mapTriangle â‹™ G.mapTriangle`. -/\n@[simps!]\ndef mapTriangleCompIso : (F â‹™ G).mapTriangle â‰… F.mapTriangle â‹™ G.mapTriangle :=\n  NatIso.ofComponents (fun T => Triangle.isoMk _ _ (Iso.refl _) (Iso.refl _) (Iso.refl _))\n\n"}
{"name":"CategoryTheory.Functor.mapTriangleIso_hom_app_homâ‚‚","module":"Mathlib.CategoryTheory.Triangulated.Functor","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœâ¶ : CategoryTheory.Category.{u_4, u_1} C\ninstâœâµ : CategoryTheory.Category.{u_5, u_2} D\ninstâœâ´ : CategoryTheory.HasShift C Int\ninstâœÂ³ : CategoryTheory.HasShift D Int\nFâ‚ Fâ‚‚ : CategoryTheory.Functor C D\ne : CategoryTheory.Iso Fâ‚ Fâ‚‚\ninstâœÂ² : Fâ‚.CommShift Int\ninstâœÂ¹ : Fâ‚‚.CommShift Int\ninstâœ : CategoryTheory.NatTrans.CommShift e.hom Int\nX : CategoryTheory.Pretriangulated.Triangle C\nâŠ¢ Eq ((CategoryTheory.Functor.mapTriangleIso e).hom.app X).homâ‚‚ (e.hom.app X.objâ‚‚)","decl":"/-- Two isomorphic functors `Fâ‚` and `Fâ‚‚` induce isomorphic functors\n`Fâ‚.mapTriangle` and `Fâ‚‚.mapTriangle` if the isomorphism `Fâ‚ â‰… Fâ‚‚` is compatible\nwith the shifts. -/\n@[simps!]\ndef mapTriangleIso {Fâ‚ Fâ‚‚ : C â¥¤ D} (e : Fâ‚ â‰… Fâ‚‚) [Fâ‚.CommShift â„¤] [Fâ‚‚.CommShift â„¤]\n    [NatTrans.CommShift e.hom â„¤] : Fâ‚.mapTriangle â‰… Fâ‚‚.mapTriangle :=\n  NatIso.ofComponents (fun T =>\n    Triangle.isoMk _ _ (e.app _) (e.app _) (e.app _) (by simp) (by simp) (by\n      dsimp\n      simp only [assoc, NatTrans.shift_app_comm e.hom (1 : â„¤) T.objâ‚,\n        NatTrans.naturality_assoc])) (by aesop_cat)\n\n"}
{"name":"CategoryTheory.Functor.mapTriangleIso_hom_app_homâ‚","module":"Mathlib.CategoryTheory.Triangulated.Functor","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœâ¶ : CategoryTheory.Category.{u_4, u_1} C\ninstâœâµ : CategoryTheory.Category.{u_5, u_2} D\ninstâœâ´ : CategoryTheory.HasShift C Int\ninstâœÂ³ : CategoryTheory.HasShift D Int\nFâ‚ Fâ‚‚ : CategoryTheory.Functor C D\ne : CategoryTheory.Iso Fâ‚ Fâ‚‚\ninstâœÂ² : Fâ‚.CommShift Int\ninstâœÂ¹ : Fâ‚‚.CommShift Int\ninstâœ : CategoryTheory.NatTrans.CommShift e.hom Int\nX : CategoryTheory.Pretriangulated.Triangle C\nâŠ¢ Eq ((CategoryTheory.Functor.mapTriangleIso e).hom.app X).homâ‚ (e.hom.app X.objâ‚)","decl":"/-- Two isomorphic functors `Fâ‚` and `Fâ‚‚` induce isomorphic functors\n`Fâ‚.mapTriangle` and `Fâ‚‚.mapTriangle` if the isomorphism `Fâ‚ â‰… Fâ‚‚` is compatible\nwith the shifts. -/\n@[simps!]\ndef mapTriangleIso {Fâ‚ Fâ‚‚ : C â¥¤ D} (e : Fâ‚ â‰… Fâ‚‚) [Fâ‚.CommShift â„¤] [Fâ‚‚.CommShift â„¤]\n    [NatTrans.CommShift e.hom â„¤] : Fâ‚.mapTriangle â‰… Fâ‚‚.mapTriangle :=\n  NatIso.ofComponents (fun T =>\n    Triangle.isoMk _ _ (e.app _) (e.app _) (e.app _) (by simp) (by simp) (by\n      dsimp\n      simp only [assoc, NatTrans.shift_app_comm e.hom (1 : â„¤) T.objâ‚,\n        NatTrans.naturality_assoc])) (by aesop_cat)\n\n"}
{"name":"CategoryTheory.Functor.mapTriangleIso_hom_app_homâ‚ƒ","module":"Mathlib.CategoryTheory.Triangulated.Functor","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœâ¶ : CategoryTheory.Category.{u_4, u_1} C\ninstâœâµ : CategoryTheory.Category.{u_5, u_2} D\ninstâœâ´ : CategoryTheory.HasShift C Int\ninstâœÂ³ : CategoryTheory.HasShift D Int\nFâ‚ Fâ‚‚ : CategoryTheory.Functor C D\ne : CategoryTheory.Iso Fâ‚ Fâ‚‚\ninstâœÂ² : Fâ‚.CommShift Int\ninstâœÂ¹ : Fâ‚‚.CommShift Int\ninstâœ : CategoryTheory.NatTrans.CommShift e.hom Int\nX : CategoryTheory.Pretriangulated.Triangle C\nâŠ¢ Eq ((CategoryTheory.Functor.mapTriangleIso e).hom.app X).homâ‚ƒ (e.hom.app X.objâ‚ƒ)","decl":"/-- Two isomorphic functors `Fâ‚` and `Fâ‚‚` induce isomorphic functors\n`Fâ‚.mapTriangle` and `Fâ‚‚.mapTriangle` if the isomorphism `Fâ‚ â‰… Fâ‚‚` is compatible\nwith the shifts. -/\n@[simps!]\ndef mapTriangleIso {Fâ‚ Fâ‚‚ : C â¥¤ D} (e : Fâ‚ â‰… Fâ‚‚) [Fâ‚.CommShift â„¤] [Fâ‚‚.CommShift â„¤]\n    [NatTrans.CommShift e.hom â„¤] : Fâ‚.mapTriangle â‰… Fâ‚‚.mapTriangle :=\n  NatIso.ofComponents (fun T =>\n    Triangle.isoMk _ _ (e.app _) (e.app _) (e.app _) (by simp) (by simp) (by\n      dsimp\n      simp only [assoc, NatTrans.shift_app_comm e.hom (1 : â„¤) T.objâ‚,\n        NatTrans.naturality_assoc])) (by aesop_cat)\n\n"}
{"name":"CategoryTheory.Functor.mapTriangleIso_inv_app_homâ‚‚","module":"Mathlib.CategoryTheory.Triangulated.Functor","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœâ¶ : CategoryTheory.Category.{u_4, u_1} C\ninstâœâµ : CategoryTheory.Category.{u_5, u_2} D\ninstâœâ´ : CategoryTheory.HasShift C Int\ninstâœÂ³ : CategoryTheory.HasShift D Int\nFâ‚ Fâ‚‚ : CategoryTheory.Functor C D\ne : CategoryTheory.Iso Fâ‚ Fâ‚‚\ninstâœÂ² : Fâ‚.CommShift Int\ninstâœÂ¹ : Fâ‚‚.CommShift Int\ninstâœ : CategoryTheory.NatTrans.CommShift e.hom Int\nX : CategoryTheory.Pretriangulated.Triangle C\nâŠ¢ Eq ((CategoryTheory.Functor.mapTriangleIso e).inv.app X).homâ‚‚ (e.inv.app X.objâ‚‚)","decl":"/-- Two isomorphic functors `Fâ‚` and `Fâ‚‚` induce isomorphic functors\n`Fâ‚.mapTriangle` and `Fâ‚‚.mapTriangle` if the isomorphism `Fâ‚ â‰… Fâ‚‚` is compatible\nwith the shifts. -/\n@[simps!]\ndef mapTriangleIso {Fâ‚ Fâ‚‚ : C â¥¤ D} (e : Fâ‚ â‰… Fâ‚‚) [Fâ‚.CommShift â„¤] [Fâ‚‚.CommShift â„¤]\n    [NatTrans.CommShift e.hom â„¤] : Fâ‚.mapTriangle â‰… Fâ‚‚.mapTriangle :=\n  NatIso.ofComponents (fun T =>\n    Triangle.isoMk _ _ (e.app _) (e.app _) (e.app _) (by simp) (by simp) (by\n      dsimp\n      simp only [assoc, NatTrans.shift_app_comm e.hom (1 : â„¤) T.objâ‚,\n        NatTrans.naturality_assoc])) (by aesop_cat)\n\n"}
{"name":"CategoryTheory.Functor.mapTriangleIso_inv_app_homâ‚","module":"Mathlib.CategoryTheory.Triangulated.Functor","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœâ¶ : CategoryTheory.Category.{u_4, u_1} C\ninstâœâµ : CategoryTheory.Category.{u_5, u_2} D\ninstâœâ´ : CategoryTheory.HasShift C Int\ninstâœÂ³ : CategoryTheory.HasShift D Int\nFâ‚ Fâ‚‚ : CategoryTheory.Functor C D\ne : CategoryTheory.Iso Fâ‚ Fâ‚‚\ninstâœÂ² : Fâ‚.CommShift Int\ninstâœÂ¹ : Fâ‚‚.CommShift Int\ninstâœ : CategoryTheory.NatTrans.CommShift e.hom Int\nX : CategoryTheory.Pretriangulated.Triangle C\nâŠ¢ Eq ((CategoryTheory.Functor.mapTriangleIso e).inv.app X).homâ‚ (e.inv.app X.objâ‚)","decl":"/-- Two isomorphic functors `Fâ‚` and `Fâ‚‚` induce isomorphic functors\n`Fâ‚.mapTriangle` and `Fâ‚‚.mapTriangle` if the isomorphism `Fâ‚ â‰… Fâ‚‚` is compatible\nwith the shifts. -/\n@[simps!]\ndef mapTriangleIso {Fâ‚ Fâ‚‚ : C â¥¤ D} (e : Fâ‚ â‰… Fâ‚‚) [Fâ‚.CommShift â„¤] [Fâ‚‚.CommShift â„¤]\n    [NatTrans.CommShift e.hom â„¤] : Fâ‚.mapTriangle â‰… Fâ‚‚.mapTriangle :=\n  NatIso.ofComponents (fun T =>\n    Triangle.isoMk _ _ (e.app _) (e.app _) (e.app _) (by simp) (by simp) (by\n      dsimp\n      simp only [assoc, NatTrans.shift_app_comm e.hom (1 : â„¤) T.objâ‚,\n        NatTrans.naturality_assoc])) (by aesop_cat)\n\n"}
{"name":"CategoryTheory.Functor.mapTriangleIso_inv_app_homâ‚ƒ","module":"Mathlib.CategoryTheory.Triangulated.Functor","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœâ¶ : CategoryTheory.Category.{u_4, u_1} C\ninstâœâµ : CategoryTheory.Category.{u_5, u_2} D\ninstâœâ´ : CategoryTheory.HasShift C Int\ninstâœÂ³ : CategoryTheory.HasShift D Int\nFâ‚ Fâ‚‚ : CategoryTheory.Functor C D\ne : CategoryTheory.Iso Fâ‚ Fâ‚‚\ninstâœÂ² : Fâ‚.CommShift Int\ninstâœÂ¹ : Fâ‚‚.CommShift Int\ninstâœ : CategoryTheory.NatTrans.CommShift e.hom Int\nX : CategoryTheory.Pretriangulated.Triangle C\nâŠ¢ Eq ((CategoryTheory.Functor.mapTriangleIso e).inv.app X).homâ‚ƒ (e.inv.app X.objâ‚ƒ)","decl":"/-- Two isomorphic functors `Fâ‚` and `Fâ‚‚` induce isomorphic functors\n`Fâ‚.mapTriangle` and `Fâ‚‚.mapTriangle` if the isomorphism `Fâ‚ â‰… Fâ‚‚` is compatible\nwith the shifts. -/\n@[simps!]\ndef mapTriangleIso {Fâ‚ Fâ‚‚ : C â¥¤ D} (e : Fâ‚ â‰… Fâ‚‚) [Fâ‚.CommShift â„¤] [Fâ‚‚.CommShift â„¤]\n    [NatTrans.CommShift e.hom â„¤] : Fâ‚.mapTriangle â‰… Fâ‚‚.mapTriangle :=\n  NatIso.ofComponents (fun T =>\n    Triangle.isoMk _ _ (e.app _) (e.app _) (e.app _) (by simp) (by simp) (by\n      dsimp\n      simp only [assoc, NatTrans.shift_app_comm e.hom (1 : â„¤) T.objâ‚,\n        NatTrans.naturality_assoc])) (by aesop_cat)\n\n"}
{"name":"CategoryTheory.Functor.IsTriangulated.map_distinguished","module":"Mathlib.CategoryTheory.Triangulated.Functor","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœÂ¹Â² : CategoryTheory.Category.{u_4, u_1} C\ninstâœÂ¹Â¹ : CategoryTheory.Category.{u_5, u_2} D\ninstâœÂ¹â° : CategoryTheory.HasShift C Int\ninstâœâ¹ : CategoryTheory.HasShift D Int\nF : CategoryTheory.Functor C D\ninstâœâ¸ : F.CommShift Int\ninstâœâ· : CategoryTheory.Limits.HasZeroObject C\ninstâœâ¶ : CategoryTheory.Limits.HasZeroObject D\ninstâœâµ : CategoryTheory.Preadditive C\ninstâœâ´ : CategoryTheory.Preadditive D\ninstâœÂ³ : âˆ€ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\ninstâœÂ² : âˆ€ (n : Int), (CategoryTheory.shiftFunctor D n).Additive\ninstâœÂ¹ : CategoryTheory.Pretriangulated C\ninstâœ : CategoryTheory.Pretriangulated D\nself : F.IsTriangulated\nT : CategoryTheory.Pretriangulated.Triangle C\naâœ : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T\nâŠ¢ Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles (F.mapTriangle.obj T)","decl":"/-- A functor which commutes with the shift by `â„¤` is triangulated if\nit sends distinguished triangles to distinguished triangles. -/\nclass IsTriangulated : Prop where\n  map_distinguished (T : Triangle C) : (T âˆˆ distTriang C) â†’ F.mapTriangle.obj T âˆˆ distTriang D\n\n"}
{"name":"CategoryTheory.Functor.map_distinguished","module":"Mathlib.CategoryTheory.Triangulated.Functor","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœÂ¹Â³ : CategoryTheory.Category.{u_4, u_1} C\ninstâœÂ¹Â² : CategoryTheory.Category.{u_5, u_2} D\ninstâœÂ¹Â¹ : CategoryTheory.HasShift C Int\ninstâœÂ¹â° : CategoryTheory.HasShift D Int\nF : CategoryTheory.Functor C D\ninstâœâ¹ : F.CommShift Int\ninstâœâ¸ : CategoryTheory.Limits.HasZeroObject C\ninstâœâ· : CategoryTheory.Limits.HasZeroObject D\ninstâœâ¶ : CategoryTheory.Preadditive C\ninstâœâµ : CategoryTheory.Preadditive D\ninstâœâ´ : âˆ€ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\ninstâœÂ³ : âˆ€ (n : Int), (CategoryTheory.shiftFunctor D n).Additive\ninstâœÂ² : CategoryTheory.Pretriangulated C\ninstâœÂ¹ : CategoryTheory.Pretriangulated D\ninstâœ : F.IsTriangulated\nT : CategoryTheory.Pretriangulated.Triangle C\nhT : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T\nâŠ¢ Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles (F.mapTriangle.obj T)","decl":"lemma map_distinguished [F.IsTriangulated] (T : Triangle C) (hT : T âˆˆ distTriang C) :\n    F.mapTriangle.obj T âˆˆ distTriang D :=\n  IsTriangulated.map_distinguished _ hT\n\n"}
{"name":"CategoryTheory.Functor.IsTriangulated.instPreservesZeroMorphisms","module":"Mathlib.CategoryTheory.Triangulated.Functor","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœÂ¹Â³ : CategoryTheory.Category.{u_4, u_1} C\ninstâœÂ¹Â² : CategoryTheory.Category.{u_5, u_2} D\ninstâœÂ¹Â¹ : CategoryTheory.HasShift C Int\ninstâœÂ¹â° : CategoryTheory.HasShift D Int\nF : CategoryTheory.Functor C D\ninstâœâ¹ : F.CommShift Int\ninstâœâ¸ : CategoryTheory.Limits.HasZeroObject C\ninstâœâ· : CategoryTheory.Limits.HasZeroObject D\ninstâœâ¶ : CategoryTheory.Preadditive C\ninstâœâµ : CategoryTheory.Preadditive D\ninstâœâ´ : âˆ€ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\ninstâœÂ³ : âˆ€ (n : Int), (CategoryTheory.shiftFunctor D n).Additive\ninstâœÂ² : CategoryTheory.Pretriangulated C\ninstâœÂ¹ : CategoryTheory.Pretriangulated D\ninstâœ : F.IsTriangulated\nâŠ¢ F.PreservesZeroMorphisms","decl":"instance (priority := 100) [F.IsTriangulated] : PreservesZeroMorphisms F where\n  map_zero X Y := by\n    have hâ‚ : (0 : X âŸ¶ Y) = 0 â‰« ğŸ™ 0 â‰« 0 := by simp\n    have hâ‚‚ : ğŸ™ (F.obj 0) = 0 := by\n      rw [â† IsZero.iff_id_eq_zero]\n      apply Triangle.isZeroâ‚ƒ_of_isIsoâ‚ _\n        (F.map_distinguished _ (contractible_distinguished (0 : C)))\n      dsimp\n      infer_instance\n    rw [hâ‚, F.map_comp, F.map_comp, F.map_id, hâ‚‚, zero_comp, comp_zero]\n\n"}
{"name":"CategoryTheory.Functor.IsTriangulated.instPreservesLimitsOfShapeDiscreteWalkingPair","module":"Mathlib.CategoryTheory.Triangulated.Functor","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœÂ¹Â³ : CategoryTheory.Category.{u_4, u_1} C\ninstâœÂ¹Â² : CategoryTheory.Category.{u_5, u_2} D\ninstâœÂ¹Â¹ : CategoryTheory.HasShift C Int\ninstâœÂ¹â° : CategoryTheory.HasShift D Int\nF : CategoryTheory.Functor C D\ninstâœâ¹ : F.CommShift Int\ninstâœâ¸ : CategoryTheory.Limits.HasZeroObject C\ninstâœâ· : CategoryTheory.Limits.HasZeroObject D\ninstâœâ¶ : CategoryTheory.Preadditive C\ninstâœâµ : CategoryTheory.Preadditive D\ninstâœâ´ : âˆ€ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\ninstâœÂ³ : âˆ€ (n : Int), (CategoryTheory.shiftFunctor D n).Additive\ninstâœÂ² : CategoryTheory.Pretriangulated C\ninstâœÂ¹ : CategoryTheory.Pretriangulated D\ninstâœ : F.IsTriangulated\nâŠ¢ CategoryTheory.Limits.PreservesLimitsOfShape (CategoryTheory.Discrete CategoryTheory.Limits.WalkingPair) F","decl":"noncomputable instance [F.IsTriangulated] :\n    PreservesLimitsOfShape (Discrete WalkingPair) F := by\n  suffices âˆ€ (Xâ‚ Xâ‚ƒ : C), IsIso (prodComparison F Xâ‚ Xâ‚ƒ) by\n    have := fun (Xâ‚ Xâ‚ƒ : C) â†¦ PreservesLimitPair.of_iso_prod_comparison F Xâ‚ Xâ‚ƒ\n    exact âŸ¨fun {K} â†¦ preservesLimit_of_iso_diagram F (diagramIsoPair K).symmâŸ©\n  intro Xâ‚ Xâ‚ƒ\n  let Ï† : F.mapTriangle.obj (binaryProductTriangle Xâ‚ Xâ‚ƒ) âŸ¶\n      binaryProductTriangle (F.obj Xâ‚) (F.obj Xâ‚ƒ) :=\n    { homâ‚ := ğŸ™ _\n      homâ‚‚ := prodComparison F Xâ‚ Xâ‚ƒ\n      homâ‚ƒ := ğŸ™ _\n      commâ‚ := by\n        dsimp\n        ext\n        Â· simp only [assoc, prodComparison_fst, prod.comp_lift, comp_id, comp_zero,\n            limit.lift_Ï€, BinaryFan.mk_pt, BinaryFan.Ï€_app_left, BinaryFan.mk_fst,\n            â† F.map_comp, F.map_id]\n        Â· simp only [assoc, prodComparison_snd, prod.comp_lift, comp_id, comp_zero,\n            limit.lift_Ï€, BinaryFan.mk_pt, BinaryFan.Ï€_app_right, BinaryFan.mk_snd,\n            â† F.map_comp, F.map_zero]\n      commâ‚‚ := by simp\n      commâ‚ƒ := by simp }\n  exact isIsoâ‚‚_of_isIsoâ‚â‚ƒ Ï† (F.map_distinguished _ (binaryProductTriangle_distinguished Xâ‚ Xâ‚ƒ))\n    (binaryProductTriangle_distinguished _ _)\n    (by dsimp [Ï†]; infer_instance) (by dsimp [Ï†]; infer_instance)\n\n"}
{"name":"CategoryTheory.Functor.IsTriangulated.instAdditive","module":"Mathlib.CategoryTheory.Triangulated.Functor","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœÂ¹Â³ : CategoryTheory.Category.{u_4, u_1} C\ninstâœÂ¹Â² : CategoryTheory.Category.{u_5, u_2} D\ninstâœÂ¹Â¹ : CategoryTheory.HasShift C Int\ninstâœÂ¹â° : CategoryTheory.HasShift D Int\nF : CategoryTheory.Functor C D\ninstâœâ¹ : F.CommShift Int\ninstâœâ¸ : CategoryTheory.Limits.HasZeroObject C\ninstâœâ· : CategoryTheory.Limits.HasZeroObject D\ninstâœâ¶ : CategoryTheory.Preadditive C\ninstâœâµ : CategoryTheory.Preadditive D\ninstâœâ´ : âˆ€ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\ninstâœÂ³ : âˆ€ (n : Int), (CategoryTheory.shiftFunctor D n).Additive\ninstâœÂ² : CategoryTheory.Pretriangulated C\ninstâœÂ¹ : CategoryTheory.Pretriangulated D\ninstâœ : F.IsTriangulated\nâŠ¢ F.Additive","decl":"instance (priority := 100) [F.IsTriangulated] : F.Additive :=\n  F.additive_of_preserves_binary_products\n\n"}
{"name":"CategoryTheory.Functor.IsTriangulated.instId","module":"Mathlib.CategoryTheory.Triangulated.Functor","initialProofState":"C : Type u_1\ninstâœâµ : CategoryTheory.Category.{u_4, u_1} C\ninstâœâ´ : CategoryTheory.HasShift C Int\ninstâœÂ³ : CategoryTheory.Limits.HasZeroObject C\ninstâœÂ² : CategoryTheory.Preadditive C\ninstâœÂ¹ : âˆ€ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\ninstâœ : CategoryTheory.Pretriangulated C\nâŠ¢ (CategoryTheory.Functor.id C).IsTriangulated","decl":"instance : (ğŸ­ C).IsTriangulated where\n  map_distinguished T hT :=\n    isomorphic_distinguished _ hT _ ((mapTriangleIdIso C).app T)\n\n"}
{"name":"CategoryTheory.Functor.IsTriangulated.instComp","module":"Mathlib.CategoryTheory.Triangulated.Functor","initialProofState":"C : Type u_1\nD : Type u_2\nE : Type u_3\ninstâœÂ²Â¹ : CategoryTheory.Category.{u_4, u_1} C\ninstâœÂ²â° : CategoryTheory.Category.{u_5, u_2} D\ninstâœÂ¹â¹ : CategoryTheory.Category.{u_6, u_3} E\ninstâœÂ¹â¸ : CategoryTheory.HasShift C Int\ninstâœÂ¹â· : CategoryTheory.HasShift D Int\ninstâœÂ¹â¶ : CategoryTheory.HasShift E Int\nF : CategoryTheory.Functor C D\ninstâœÂ¹âµ : F.CommShift Int\nG : CategoryTheory.Functor D E\ninstâœÂ¹â´ : G.CommShift Int\ninstâœÂ¹Â³ : CategoryTheory.Limits.HasZeroObject C\ninstâœÂ¹Â² : CategoryTheory.Limits.HasZeroObject D\ninstâœÂ¹Â¹ : CategoryTheory.Limits.HasZeroObject E\ninstâœÂ¹â° : CategoryTheory.Preadditive C\ninstâœâ¹ : CategoryTheory.Preadditive D\ninstâœâ¸ : CategoryTheory.Preadditive E\ninstâœâ· : âˆ€ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\ninstâœâ¶ : âˆ€ (n : Int), (CategoryTheory.shiftFunctor D n).Additive\ninstâœâµ : âˆ€ (n : Int), (CategoryTheory.shiftFunctor E n).Additive\ninstâœâ´ : CategoryTheory.Pretriangulated C\ninstâœÂ³ : CategoryTheory.Pretriangulated D\ninstâœÂ² : CategoryTheory.Pretriangulated E\ninstâœÂ¹ : F.IsTriangulated\ninstâœ : G.IsTriangulated\nâŠ¢ (F.comp G).IsTriangulated","decl":"instance [F.IsTriangulated] [G.IsTriangulated] : (F â‹™ G).IsTriangulated where\n  map_distinguished T hT :=\n    isomorphic_distinguished _ (G.map_distinguished _ (F.map_distinguished T hT)) _\n      ((mapTriangleCompIso F G).app T)\n\n"}
{"name":"CategoryTheory.Functor.isTriangulated_of_iso","module":"Mathlib.CategoryTheory.Triangulated.Functor","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœÂ¹âµ : CategoryTheory.Category.{u_4, u_1} C\ninstâœÂ¹â´ : CategoryTheory.Category.{u_5, u_2} D\ninstâœÂ¹Â³ : CategoryTheory.HasShift C Int\ninstâœÂ¹Â² : CategoryTheory.HasShift D Int\ninstâœÂ¹Â¹ : CategoryTheory.Limits.HasZeroObject C\ninstâœÂ¹â° : CategoryTheory.Limits.HasZeroObject D\ninstâœâ¹ : CategoryTheory.Preadditive C\ninstâœâ¸ : CategoryTheory.Preadditive D\ninstâœâ· : âˆ€ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\ninstâœâ¶ : âˆ€ (n : Int), (CategoryTheory.shiftFunctor D n).Additive\ninstâœâµ : CategoryTheory.Pretriangulated C\ninstâœâ´ : CategoryTheory.Pretriangulated D\nFâ‚ Fâ‚‚ : CategoryTheory.Functor C D\ne : CategoryTheory.Iso Fâ‚ Fâ‚‚\ninstâœÂ³ : Fâ‚.CommShift Int\ninstâœÂ² : Fâ‚‚.CommShift Int\ninstâœÂ¹ : CategoryTheory.NatTrans.CommShift e.hom Int\ninstâœ : Fâ‚.IsTriangulated\nâŠ¢ Fâ‚‚.IsTriangulated","decl":"lemma isTriangulated_of_iso {Fâ‚ Fâ‚‚ : C â¥¤ D} (e : Fâ‚ â‰… Fâ‚‚) [Fâ‚.CommShift â„¤] [Fâ‚‚.CommShift â„¤]\n    [NatTrans.CommShift e.hom â„¤] [Fâ‚.IsTriangulated] : Fâ‚‚.IsTriangulated where\n  map_distinguished T hT :=\n    isomorphic_distinguished _ (Fâ‚.map_distinguished T hT) _ ((mapTriangleIso e).app T).symm\n\n"}
{"name":"CategoryTheory.Functor.isTriangulated_iff_of_iso","module":"Mathlib.CategoryTheory.Triangulated.Functor","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœÂ¹â´ : CategoryTheory.Category.{u_4, u_1} C\ninstâœÂ¹Â³ : CategoryTheory.Category.{u_5, u_2} D\ninstâœÂ¹Â² : CategoryTheory.HasShift C Int\ninstâœÂ¹Â¹ : CategoryTheory.HasShift D Int\ninstâœÂ¹â° : CategoryTheory.Limits.HasZeroObject C\ninstâœâ¹ : CategoryTheory.Limits.HasZeroObject D\ninstâœâ¸ : CategoryTheory.Preadditive C\ninstâœâ· : CategoryTheory.Preadditive D\ninstâœâ¶ : âˆ€ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\ninstâœâµ : âˆ€ (n : Int), (CategoryTheory.shiftFunctor D n).Additive\ninstâœâ´ : CategoryTheory.Pretriangulated C\ninstâœÂ³ : CategoryTheory.Pretriangulated D\nFâ‚ Fâ‚‚ : CategoryTheory.Functor C D\ne : CategoryTheory.Iso Fâ‚ Fâ‚‚\ninstâœÂ² : Fâ‚.CommShift Int\ninstâœÂ¹ : Fâ‚‚.CommShift Int\ninstâœ : CategoryTheory.NatTrans.CommShift e.hom Int\nâŠ¢ Iff Fâ‚.IsTriangulated Fâ‚‚.IsTriangulated","decl":"lemma isTriangulated_iff_of_iso {Fâ‚ Fâ‚‚ : C â¥¤ D} (e : Fâ‚ â‰… Fâ‚‚) [Fâ‚.CommShift â„¤] [Fâ‚‚.CommShift â„¤]\n    [NatTrans.CommShift e.hom â„¤] : Fâ‚.IsTriangulated â†” Fâ‚‚.IsTriangulated := by\n  constructor\n  Â· intro\n    exact isTriangulated_of_iso e\n  Â· intro\n    have : NatTrans.CommShift e.symm.hom â„¤ := inferInstanceAs (NatTrans.CommShift e.inv â„¤)\n    exact isTriangulated_of_iso e.symm\n\n"}
{"name":"CategoryTheory.Functor.mem_mapTriangle_essImage_of_distinguished","module":"Mathlib.CategoryTheory.Triangulated.Functor","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœÂ¹â´ : CategoryTheory.Category.{u_4, u_1} C\ninstâœÂ¹Â³ : CategoryTheory.Category.{u_5, u_2} D\ninstâœÂ¹Â² : CategoryTheory.HasShift C Int\ninstâœÂ¹Â¹ : CategoryTheory.HasShift D Int\nF : CategoryTheory.Functor C D\ninstâœÂ¹â° : F.CommShift Int\ninstâœâ¹ : CategoryTheory.Limits.HasZeroObject C\ninstâœâ¸ : CategoryTheory.Limits.HasZeroObject D\ninstâœâ· : CategoryTheory.Preadditive C\ninstâœâ¶ : CategoryTheory.Preadditive D\ninstâœâµ : âˆ€ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\ninstâœâ´ : âˆ€ (n : Int), (CategoryTheory.shiftFunctor D n).Additive\ninstâœÂ³ : CategoryTheory.Pretriangulated C\ninstâœÂ² : CategoryTheory.Pretriangulated D\ninstâœÂ¹ : F.IsTriangulated\ninstâœ : F.mapArrow.EssSurj\nT : CategoryTheory.Pretriangulated.Triangle D\nhT : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T\nâŠ¢ Exists fun T' => Exists fun x => Nonempty (CategoryTheory.Iso (F.mapTriangle.obj T') T)","decl":"lemma mem_mapTriangle_essImage_of_distinguished\n    [F.IsTriangulated] [F.mapArrow.EssSurj] (T : Triangle D) (hT : T âˆˆ distTriang D) :\n    âˆƒ (T' : Triangle C) (_ : T' âˆˆ distTriang C), Nonempty (F.mapTriangle.obj T' â‰… T) := by\n  obtain âŸ¨X, Y, f, eâ‚, eâ‚‚, wâŸ© : âˆƒ (X Y : C) (f : X âŸ¶ Y) (eâ‚ : F.obj X â‰… T.objâ‚)\n    (eâ‚‚ : F.obj Y â‰… T.objâ‚‚), F.map f â‰« eâ‚‚.hom = eâ‚.hom â‰« T.morâ‚ := by\n      let e := F.mapArrow.objObjPreimageIso (Arrow.mk T.morâ‚)\n      exact âŸ¨_, _, _, Arrow.leftFunc.mapIso e, Arrow.rightFunc.mapIso e, e.hom.w.symmâŸ©\n  obtain âŸ¨W, g, h, HâŸ© := distinguished_cocone_triangle f\n  exact âŸ¨_, H, âŸ¨isoTriangleOfIsoâ‚â‚‚ _ _ (F.map_distinguished _ H) hT eâ‚ eâ‚‚ wâŸ©âŸ©\n\n"}
{"name":"CategoryTheory.Functor.isTriangulated_of_precomp","module":"Mathlib.CategoryTheory.Triangulated.Functor","initialProofState":"C : Type u_1\nD : Type u_2\nE : Type u_3\ninstâœÂ²Â² : CategoryTheory.Category.{u_4, u_1} C\ninstâœÂ²Â¹ : CategoryTheory.Category.{u_6, u_2} D\ninstâœÂ²â° : CategoryTheory.Category.{u_5, u_3} E\ninstâœÂ¹â¹ : CategoryTheory.HasShift C Int\ninstâœÂ¹â¸ : CategoryTheory.HasShift D Int\ninstâœÂ¹â· : CategoryTheory.HasShift E Int\nF : CategoryTheory.Functor C D\ninstâœÂ¹â¶ : F.CommShift Int\nG : CategoryTheory.Functor D E\ninstâœÂ¹âµ : G.CommShift Int\ninstâœÂ¹â´ : CategoryTheory.Limits.HasZeroObject C\ninstâœÂ¹Â³ : CategoryTheory.Limits.HasZeroObject D\ninstâœÂ¹Â² : CategoryTheory.Limits.HasZeroObject E\ninstâœÂ¹Â¹ : CategoryTheory.Preadditive C\ninstâœÂ¹â° : CategoryTheory.Preadditive D\ninstâœâ¹ : CategoryTheory.Preadditive E\ninstâœâ¸ : âˆ€ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\ninstâœâ· : âˆ€ (n : Int), (CategoryTheory.shiftFunctor D n).Additive\ninstâœâ¶ : âˆ€ (n : Int), (CategoryTheory.shiftFunctor E n).Additive\ninstâœâµ : CategoryTheory.Pretriangulated C\ninstâœâ´ : CategoryTheory.Pretriangulated D\ninstâœÂ³ : CategoryTheory.Pretriangulated E\ninstâœÂ² : (F.comp G).IsTriangulated\ninstâœÂ¹ : F.IsTriangulated\ninstâœ : F.mapArrow.EssSurj\nâŠ¢ G.IsTriangulated","decl":"lemma isTriangulated_of_precomp\n    [(F â‹™ G).IsTriangulated] [F.IsTriangulated] [F.mapArrow.EssSurj] :\n    G.IsTriangulated where\n  map_distinguished T hT := by\n    obtain âŸ¨T', hT', âŸ¨eâŸ©âŸ© := F.mem_mapTriangle_essImage_of_distinguished T hT\n    exact isomorphic_distinguished _ ((F â‹™ G).map_distinguished T' hT') _\n      (G.mapTriangle.mapIso e.symm â‰ªâ‰« (mapTriangleCompIso F G).symm.app _)\n\n"}
{"name":"CategoryTheory.Functor.isTriangulated_of_precomp_iso","module":"Mathlib.CategoryTheory.Triangulated.Functor","initialProofState":"C : Type u_1\nD : Type u_2\nE : Type u_3\ninstâœÂ²â´ : CategoryTheory.Category.{u_4, u_1} C\ninstâœÂ²Â³ : CategoryTheory.Category.{u_6, u_2} D\ninstâœÂ²Â² : CategoryTheory.Category.{u_5, u_3} E\ninstâœÂ²Â¹ : CategoryTheory.HasShift C Int\ninstâœÂ²â° : CategoryTheory.HasShift D Int\ninstâœÂ¹â¹ : CategoryTheory.HasShift E Int\nF : CategoryTheory.Functor C D\ninstâœÂ¹â¸ : F.CommShift Int\nG : CategoryTheory.Functor D E\ninstâœÂ¹â· : G.CommShift Int\ninstâœÂ¹â¶ : CategoryTheory.Limits.HasZeroObject C\ninstâœÂ¹âµ : CategoryTheory.Limits.HasZeroObject D\ninstâœÂ¹â´ : CategoryTheory.Limits.HasZeroObject E\ninstâœÂ¹Â³ : CategoryTheory.Preadditive C\ninstâœÂ¹Â² : CategoryTheory.Preadditive D\ninstâœÂ¹Â¹ : CategoryTheory.Preadditive E\ninstâœÂ¹â° : âˆ€ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\ninstâœâ¹ : âˆ€ (n : Int), (CategoryTheory.shiftFunctor D n).Additive\ninstâœâ¸ : âˆ€ (n : Int), (CategoryTheory.shiftFunctor E n).Additive\ninstâœâ· : CategoryTheory.Pretriangulated C\ninstâœâ¶ : CategoryTheory.Pretriangulated D\ninstâœâµ : CategoryTheory.Pretriangulated E\nH : CategoryTheory.Functor C E\ne : CategoryTheory.Iso (F.comp G) H\ninstâœâ´ : H.CommShift Int\ninstâœÂ³ : H.IsTriangulated\ninstâœÂ² : F.IsTriangulated\ninstâœÂ¹ : F.mapArrow.EssSurj\ninstâœ : CategoryTheory.NatTrans.CommShift e.hom Int\nâŠ¢ G.IsTriangulated","decl":"variable {F G} in\nlemma isTriangulated_of_precomp_iso {H : C â¥¤ E} (e : F â‹™ G â‰… H) [H.CommShift â„¤]\n    [H.IsTriangulated] [F.IsTriangulated] [F.mapArrow.EssSurj] [NatTrans.CommShift e.hom â„¤] :\n    G.IsTriangulated := by\n  have := (isTriangulated_iff_of_iso e).2 inferInstance\n  exact isTriangulated_of_precomp F G\n\n"}
{"name":"CategoryTheory.Triangulated.Octahedron.map_mâ‚","module":"Mathlib.CategoryTheory.Triangulated.Functor","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœÂ¹Â³ : CategoryTheory.Category.{u_3, u_1} C\ninstâœÂ¹Â² : CategoryTheory.Category.{u_4, u_2} D\ninstâœÂ¹Â¹ : CategoryTheory.HasShift C Int\ninstâœÂ¹â° : CategoryTheory.HasShift D Int\ninstâœâ¹ : CategoryTheory.Limits.HasZeroObject C\ninstâœâ¸ : CategoryTheory.Limits.HasZeroObject D\ninstâœâ· : CategoryTheory.Preadditive C\ninstâœâ¶ : CategoryTheory.Preadditive D\ninstâœâµ : âˆ€ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\ninstâœâ´ : âˆ€ (n : Int), (CategoryTheory.shiftFunctor D n).Additive\ninstâœÂ³ : CategoryTheory.Pretriangulated C\ninstâœÂ² : CategoryTheory.Pretriangulated D\nXâ‚ Xâ‚‚ Xâ‚ƒ Zâ‚â‚‚ Zâ‚‚â‚ƒ Zâ‚â‚ƒ : C\nuâ‚â‚‚ : Quiver.Hom Xâ‚ Xâ‚‚\nuâ‚‚â‚ƒ : Quiver.Hom Xâ‚‚ Xâ‚ƒ\nuâ‚â‚ƒ : Quiver.Hom Xâ‚ Xâ‚ƒ\ncomm : Eq (CategoryTheory.CategoryStruct.comp uâ‚â‚‚ uâ‚‚â‚ƒ) uâ‚â‚ƒ\nvâ‚â‚‚ : Quiver.Hom Xâ‚‚ Zâ‚â‚‚\nwâ‚â‚‚ : Quiver.Hom Zâ‚â‚‚ ((CategoryTheory.shiftFunctor C 1).obj Xâ‚)\nhâ‚â‚‚ : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles (CategoryTheory.Pretriangulated.Triangle.mk uâ‚â‚‚ vâ‚â‚‚ wâ‚â‚‚)\nvâ‚‚â‚ƒ : Quiver.Hom Xâ‚ƒ Zâ‚‚â‚ƒ\nwâ‚‚â‚ƒ : Quiver.Hom Zâ‚‚â‚ƒ ((CategoryTheory.shiftFunctor C 1).obj Xâ‚‚)\nhâ‚‚â‚ƒ : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles (CategoryTheory.Pretriangulated.Triangle.mk uâ‚‚â‚ƒ vâ‚‚â‚ƒ wâ‚‚â‚ƒ)\nvâ‚â‚ƒ : Quiver.Hom Xâ‚ƒ Zâ‚â‚ƒ\nwâ‚â‚ƒ : Quiver.Hom Zâ‚â‚ƒ ((CategoryTheory.shiftFunctor C 1).obj Xâ‚)\nhâ‚â‚ƒ : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles (CategoryTheory.Pretriangulated.Triangle.mk uâ‚â‚ƒ vâ‚â‚ƒ wâ‚â‚ƒ)\nh : CategoryTheory.Triangulated.Octahedron comm hâ‚â‚‚ hâ‚‚â‚ƒ hâ‚â‚ƒ\nF : CategoryTheory.Functor C D\ninstâœÂ¹ : F.CommShift Int\ninstâœ : F.IsTriangulated\nâŠ¢ Eq (h.map F).mâ‚ (F.map h.mâ‚)","decl":"/-- The image of an octahedron by a triangulated functor. -/\n@[simps]\ndef map : Octahedron (by dsimp; rw [â† F.map_comp, comm])\n    (F.map_distinguished _ hâ‚â‚‚) (F.map_distinguished _ hâ‚‚â‚ƒ) (F.map_distinguished _ hâ‚â‚ƒ) where\n  mâ‚ := F.map h.mâ‚\n  mâ‚ƒ := F.map h.mâ‚ƒ\n  commâ‚ := by simpa using F.congr_map h.commâ‚\n  commâ‚‚ := by simpa using F.congr_map h.commâ‚‚ =â‰« (F.commShiftIso 1).hom.app Xâ‚\n  commâ‚ƒ := by simpa using F.congr_map h.commâ‚ƒ\n  commâ‚„ := by simpa using F.congr_map h.commâ‚„ =â‰« (F.commShiftIso 1).hom.app Xâ‚‚\n  mem := isomorphic_distinguished _ (F.map_distinguished _ h.mem) _\n    (Triangle.isoMk _ _ (Iso.refl _) (Iso.refl _) (Iso.refl _))\n\n"}
{"name":"CategoryTheory.Triangulated.Octahedron.map_mâ‚ƒ","module":"Mathlib.CategoryTheory.Triangulated.Functor","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœÂ¹Â³ : CategoryTheory.Category.{u_3, u_1} C\ninstâœÂ¹Â² : CategoryTheory.Category.{u_4, u_2} D\ninstâœÂ¹Â¹ : CategoryTheory.HasShift C Int\ninstâœÂ¹â° : CategoryTheory.HasShift D Int\ninstâœâ¹ : CategoryTheory.Limits.HasZeroObject C\ninstâœâ¸ : CategoryTheory.Limits.HasZeroObject D\ninstâœâ· : CategoryTheory.Preadditive C\ninstâœâ¶ : CategoryTheory.Preadditive D\ninstâœâµ : âˆ€ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\ninstâœâ´ : âˆ€ (n : Int), (CategoryTheory.shiftFunctor D n).Additive\ninstâœÂ³ : CategoryTheory.Pretriangulated C\ninstâœÂ² : CategoryTheory.Pretriangulated D\nXâ‚ Xâ‚‚ Xâ‚ƒ Zâ‚â‚‚ Zâ‚‚â‚ƒ Zâ‚â‚ƒ : C\nuâ‚â‚‚ : Quiver.Hom Xâ‚ Xâ‚‚\nuâ‚‚â‚ƒ : Quiver.Hom Xâ‚‚ Xâ‚ƒ\nuâ‚â‚ƒ : Quiver.Hom Xâ‚ Xâ‚ƒ\ncomm : Eq (CategoryTheory.CategoryStruct.comp uâ‚â‚‚ uâ‚‚â‚ƒ) uâ‚â‚ƒ\nvâ‚â‚‚ : Quiver.Hom Xâ‚‚ Zâ‚â‚‚\nwâ‚â‚‚ : Quiver.Hom Zâ‚â‚‚ ((CategoryTheory.shiftFunctor C 1).obj Xâ‚)\nhâ‚â‚‚ : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles (CategoryTheory.Pretriangulated.Triangle.mk uâ‚â‚‚ vâ‚â‚‚ wâ‚â‚‚)\nvâ‚‚â‚ƒ : Quiver.Hom Xâ‚ƒ Zâ‚‚â‚ƒ\nwâ‚‚â‚ƒ : Quiver.Hom Zâ‚‚â‚ƒ ((CategoryTheory.shiftFunctor C 1).obj Xâ‚‚)\nhâ‚‚â‚ƒ : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles (CategoryTheory.Pretriangulated.Triangle.mk uâ‚‚â‚ƒ vâ‚‚â‚ƒ wâ‚‚â‚ƒ)\nvâ‚â‚ƒ : Quiver.Hom Xâ‚ƒ Zâ‚â‚ƒ\nwâ‚â‚ƒ : Quiver.Hom Zâ‚â‚ƒ ((CategoryTheory.shiftFunctor C 1).obj Xâ‚)\nhâ‚â‚ƒ : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles (CategoryTheory.Pretriangulated.Triangle.mk uâ‚â‚ƒ vâ‚â‚ƒ wâ‚â‚ƒ)\nh : CategoryTheory.Triangulated.Octahedron comm hâ‚â‚‚ hâ‚‚â‚ƒ hâ‚â‚ƒ\nF : CategoryTheory.Functor C D\ninstâœÂ¹ : F.CommShift Int\ninstâœ : F.IsTriangulated\nâŠ¢ Eq (h.map F).mâ‚ƒ (F.map h.mâ‚ƒ)","decl":"/-- The image of an octahedron by a triangulated functor. -/\n@[simps]\ndef map : Octahedron (by dsimp; rw [â† F.map_comp, comm])\n    (F.map_distinguished _ hâ‚â‚‚) (F.map_distinguished _ hâ‚‚â‚ƒ) (F.map_distinguished _ hâ‚â‚ƒ) where\n  mâ‚ := F.map h.mâ‚\n  mâ‚ƒ := F.map h.mâ‚ƒ\n  commâ‚ := by simpa using F.congr_map h.commâ‚\n  commâ‚‚ := by simpa using F.congr_map h.commâ‚‚ =â‰« (F.commShiftIso 1).hom.app Xâ‚\n  commâ‚ƒ := by simpa using F.congr_map h.commâ‚ƒ\n  commâ‚„ := by simpa using F.congr_map h.commâ‚„ =â‰« (F.commShiftIso 1).hom.app Xâ‚‚\n  mem := isomorphic_distinguished _ (F.map_distinguished _ h.mem) _\n    (Triangle.isoMk _ _ (Iso.refl _) (Iso.refl _) (Iso.refl _))\n\n"}
{"name":"CategoryTheory.isTriangulated_of_essSurj_mapComposableArrows_two","module":"Mathlib.CategoryTheory.Triangulated.Functor","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœÂ¹âµ : CategoryTheory.Category.{u_3, u_1} C\ninstâœÂ¹â´ : CategoryTheory.Category.{u_4, u_2} D\ninstâœÂ¹Â³ : CategoryTheory.HasShift C Int\ninstâœÂ¹Â² : CategoryTheory.HasShift D Int\ninstâœÂ¹Â¹ : CategoryTheory.Limits.HasZeroObject C\ninstâœÂ¹â° : CategoryTheory.Limits.HasZeroObject D\ninstâœâ¹ : CategoryTheory.Preadditive C\ninstâœâ¸ : CategoryTheory.Preadditive D\ninstâœâ· : âˆ€ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\ninstâœâ¶ : âˆ€ (n : Int), (CategoryTheory.shiftFunctor D n).Additive\ninstâœâµ : CategoryTheory.Pretriangulated C\ninstâœâ´ : CategoryTheory.Pretriangulated D\nF : CategoryTheory.Functor C D\ninstâœÂ³ : F.CommShift Int\ninstâœÂ² : F.IsTriangulated\ninstâœÂ¹ : (F.mapComposableArrows 2).EssSurj\ninstâœ : CategoryTheory.IsTriangulated C\nâŠ¢ CategoryTheory.IsTriangulated D","decl":"/-- If `F : C â¥¤ D` is a triangulated functor from a triangulated category, then `D`\nis also triangulated if tuples of composables arrows in `D` can be lifted to `C`. -/\nlemma isTriangulated_of_essSurj_mapComposableArrows_two\n    (F : C â¥¤ D) [F.CommShift â„¤] [F.IsTriangulated]\n    [(F.mapComposableArrows 2).EssSurj] [IsTriangulated C] :\n    IsTriangulated D := by\n  apply IsTriangulated.mk\n  intro Yâ‚ Yâ‚‚ Yâ‚ƒ Zâ‚â‚‚ Zâ‚‚â‚ƒ Zâ‚â‚ƒ uâ‚â‚‚ uâ‚‚â‚ƒ uâ‚â‚ƒ comm vâ‚â‚‚ wâ‚â‚‚ hâ‚â‚‚ vâ‚‚â‚ƒ wâ‚‚â‚ƒ hâ‚‚â‚ƒ vâ‚â‚ƒ wâ‚â‚ƒ hâ‚â‚ƒ\n  obtain âŸ¨Î±, âŸ¨eâŸ©âŸ© : âˆƒ (Î± : ComposableArrows C 2),\n      Nonempty ((F.mapComposableArrows 2).obj Î± â‰… ComposableArrows.mkâ‚‚ uâ‚â‚‚ uâ‚‚â‚ƒ) :=\n    âŸ¨_, âŸ¨Functor.objObjPreimageIso _ _âŸ©âŸ©\n  obtain âŸ¨Xâ‚, Xâ‚‚, Xâ‚ƒ, f, g, rflâŸ© := ComposableArrows.mkâ‚‚_surjective Î±\n  obtain âŸ¨_, _, _, hâ‚â‚‚'âŸ© := distinguished_cocone_triangle f\n  obtain âŸ¨_, _, _, hâ‚‚â‚ƒ'âŸ© := distinguished_cocone_triangle g\n  obtain âŸ¨_, _, _, hâ‚â‚ƒ'âŸ© := distinguished_cocone_triangle (f â‰« g)\n  exact âŸ¨Octahedron.ofIso (eâ‚ := (e.app 0).symm) (eâ‚‚ := (e.app 1).symm) (eâ‚ƒ := (e.app 2).symm)\n    (commâ‚â‚‚ := ComposableArrows.naturality' e.inv 0 1)\n    (commâ‚‚â‚ƒ := ComposableArrows.naturality' e.inv 1 2)\n    (H := (someOctahedron rfl hâ‚â‚‚' hâ‚‚â‚ƒ' hâ‚â‚ƒ').map F) ..âŸ©\n\n"}
