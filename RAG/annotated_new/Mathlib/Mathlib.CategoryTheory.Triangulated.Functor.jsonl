{"name":"CategoryTheory.Functor.mapTriangle_map_hom₁","module":"Mathlib.CategoryTheory.Triangulated.Functor","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁴ : CategoryTheory.Category.{u_4, u_1} C\ninst✝³ : CategoryTheory.Category.{u_5, u_2} D\ninst✝² : CategoryTheory.HasShift C Int\ninst✝¹ : CategoryTheory.HasShift D Int\nF : CategoryTheory.Functor C D\ninst✝ : F.CommShift Int\nX✝ Y✝ : CategoryTheory.Pretriangulated.Triangle C\nf : Quiver.Hom X✝ Y✝\n⊢ Eq (F.mapTriangle.map f).hom₁ (F.map f.hom₁)","decl":"/-- The functor `Triangle C ⥤ Triangle D` that is induced by a functor `F : C ⥤ D`\nwhich commutes with shift by `ℤ`. -/\n@[simps]\ndef mapTriangle : Triangle C ⥤ Triangle D where\n  obj T := Triangle.mk (F.map T.mor₁) (F.map T.mor₂)\n    (F.map T.mor₃ ≫ (F.commShiftIso (1 : ℤ)).hom.app T.obj₁)\n  map f :=\n    { hom₁ := F.map f.hom₁\n      hom₂ := F.map f.hom₂\n      hom₃ := F.map f.hom₃\n      comm₁ := by dsimp; simp only [← F.map_comp, f.comm₁]\n      comm₂ := by dsimp; simp only [← F.map_comp, f.comm₂]\n      comm₃ := by\n        dsimp [Functor.comp]\n        simp only [Category.assoc, ← NatTrans.naturality,\n          ← F.map_comp_assoc, f.comm₃] }\n\n"}
{"name":"CategoryTheory.Functor.mapTriangle_map_hom₂","module":"Mathlib.CategoryTheory.Triangulated.Functor","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁴ : CategoryTheory.Category.{u_4, u_1} C\ninst✝³ : CategoryTheory.Category.{u_5, u_2} D\ninst✝² : CategoryTheory.HasShift C Int\ninst✝¹ : CategoryTheory.HasShift D Int\nF : CategoryTheory.Functor C D\ninst✝ : F.CommShift Int\nX✝ Y✝ : CategoryTheory.Pretriangulated.Triangle C\nf : Quiver.Hom X✝ Y✝\n⊢ Eq (F.mapTriangle.map f).hom₂ (F.map f.hom₂)","decl":"/-- The functor `Triangle C ⥤ Triangle D` that is induced by a functor `F : C ⥤ D`\nwhich commutes with shift by `ℤ`. -/\n@[simps]\ndef mapTriangle : Triangle C ⥤ Triangle D where\n  obj T := Triangle.mk (F.map T.mor₁) (F.map T.mor₂)\n    (F.map T.mor₃ ≫ (F.commShiftIso (1 : ℤ)).hom.app T.obj₁)\n  map f :=\n    { hom₁ := F.map f.hom₁\n      hom₂ := F.map f.hom₂\n      hom₃ := F.map f.hom₃\n      comm₁ := by dsimp; simp only [← F.map_comp, f.comm₁]\n      comm₂ := by dsimp; simp only [← F.map_comp, f.comm₂]\n      comm₃ := by\n        dsimp [Functor.comp]\n        simp only [Category.assoc, ← NatTrans.naturality,\n          ← F.map_comp_assoc, f.comm₃] }\n\n"}
{"name":"CategoryTheory.Functor.mapTriangle_map_hom₃","module":"Mathlib.CategoryTheory.Triangulated.Functor","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁴ : CategoryTheory.Category.{u_4, u_1} C\ninst✝³ : CategoryTheory.Category.{u_5, u_2} D\ninst✝² : CategoryTheory.HasShift C Int\ninst✝¹ : CategoryTheory.HasShift D Int\nF : CategoryTheory.Functor C D\ninst✝ : F.CommShift Int\nX✝ Y✝ : CategoryTheory.Pretriangulated.Triangle C\nf : Quiver.Hom X✝ Y✝\n⊢ Eq (F.mapTriangle.map f).hom₃ (F.map f.hom₃)","decl":"/-- The functor `Triangle C ⥤ Triangle D` that is induced by a functor `F : C ⥤ D`\nwhich commutes with shift by `ℤ`. -/\n@[simps]\ndef mapTriangle : Triangle C ⥤ Triangle D where\n  obj T := Triangle.mk (F.map T.mor₁) (F.map T.mor₂)\n    (F.map T.mor₃ ≫ (F.commShiftIso (1 : ℤ)).hom.app T.obj₁)\n  map f :=\n    { hom₁ := F.map f.hom₁\n      hom₂ := F.map f.hom₂\n      hom₃ := F.map f.hom₃\n      comm₁ := by dsimp; simp only [← F.map_comp, f.comm₁]\n      comm₂ := by dsimp; simp only [← F.map_comp, f.comm₂]\n      comm₃ := by\n        dsimp [Functor.comp]\n        simp only [Category.assoc, ← NatTrans.naturality,\n          ← F.map_comp_assoc, f.comm₃] }\n\n"}
{"name":"CategoryTheory.Functor.mapTriangle_obj","module":"Mathlib.CategoryTheory.Triangulated.Functor","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁴ : CategoryTheory.Category.{u_4, u_1} C\ninst✝³ : CategoryTheory.Category.{u_5, u_2} D\ninst✝² : CategoryTheory.HasShift C Int\ninst✝¹ : CategoryTheory.HasShift D Int\nF : CategoryTheory.Functor C D\ninst✝ : F.CommShift Int\nT : CategoryTheory.Pretriangulated.Triangle C\n⊢ Eq (F.mapTriangle.obj T) (CategoryTheory.Pretriangulated.Triangle.mk (F.map T.mor₁) (F.map T.mor₂) (CategoryTheory.CategoryStruct.comp (F.map T.mor₃) ((F.commShiftIso 1).hom.app T.obj₁)))","decl":"/-- The functor `Triangle C ⥤ Triangle D` that is induced by a functor `F : C ⥤ D`\nwhich commutes with shift by `ℤ`. -/\n@[simps]\ndef mapTriangle : Triangle C ⥤ Triangle D where\n  obj T := Triangle.mk (F.map T.mor₁) (F.map T.mor₂)\n    (F.map T.mor₃ ≫ (F.commShiftIso (1 : ℤ)).hom.app T.obj₁)\n  map f :=\n    { hom₁ := F.map f.hom₁\n      hom₂ := F.map f.hom₂\n      hom₃ := F.map f.hom₃\n      comm₁ := by dsimp; simp only [← F.map_comp, f.comm₁]\n      comm₂ := by dsimp; simp only [← F.map_comp, f.comm₂]\n      comm₃ := by\n        dsimp [Functor.comp]\n        simp only [Category.assoc, ← NatTrans.naturality,\n          ← F.map_comp_assoc, f.comm₃] }\n\n"}
{"name":"CategoryTheory.Functor.instFaithfulTriangleMapTriangle","module":"Mathlib.CategoryTheory.Triangulated.Functor","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁵ : CategoryTheory.Category.{u_4, u_1} C\ninst✝⁴ : CategoryTheory.Category.{u_5, u_2} D\ninst✝³ : CategoryTheory.HasShift C Int\ninst✝² : CategoryTheory.HasShift D Int\nF : CategoryTheory.Functor C D\ninst✝¹ : F.CommShift Int\ninst✝ : F.Faithful\n⊢ F.mapTriangle.Faithful","decl":"instance [Faithful F] : Faithful F.mapTriangle where\n  map_injective {X Y} f g h := by\n    ext <;> apply F.map_injective\n    · exact congr_arg TriangleMorphism.hom₁ h\n    · exact congr_arg TriangleMorphism.hom₂ h\n    · exact congr_arg TriangleMorphism.hom₃ h\n\n"}
{"name":"CategoryTheory.Functor.instFullTriangleMapTriangleOfFaithful","module":"Mathlib.CategoryTheory.Triangulated.Functor","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁶ : CategoryTheory.Category.{u_4, u_1} C\ninst✝⁵ : CategoryTheory.Category.{u_5, u_2} D\ninst✝⁴ : CategoryTheory.HasShift C Int\ninst✝³ : CategoryTheory.HasShift D Int\nF : CategoryTheory.Functor C D\ninst✝² : F.CommShift Int\ninst✝¹ : F.Full\ninst✝ : F.Faithful\n⊢ F.mapTriangle.Full","decl":"instance [Full F] [Faithful F] : Full F.mapTriangle where\n  map_surjective {X Y} f :=\n   ⟨{ hom₁ := F.preimage f.hom₁\n      hom₂ := F.preimage f.hom₂\n      hom₃ := F.preimage f.hom₃\n      comm₁ := F.map_injective\n        (by simpa only [mapTriangle_obj, map_comp, map_preimage] using f.comm₁)\n      comm₂ := F.map_injective\n        (by simpa only [mapTriangle_obj, map_comp, map_preimage] using f.comm₂)\n      comm₃ := F.map_injective (by\n        rw [← cancel_mono ((F.commShiftIso (1 : ℤ)).hom.app Y.obj₁)]\n        simpa only [mapTriangle_obj, map_comp, assoc, commShiftIso_hom_naturality,\n          map_preimage, Triangle.mk_mor₃] using f.comm₃) }, by aesop_cat⟩\n\n"}
{"name":"CategoryTheory.Functor.mapTriangleCommShiftIso_inv_app_hom₁","module":"Mathlib.CategoryTheory.Triangulated.Functor","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁶ : CategoryTheory.Category.{u_4, u_1} C\ninst✝⁵ : CategoryTheory.Category.{u_5, u_2} D\ninst✝⁴ : CategoryTheory.HasShift C Int\ninst✝³ : CategoryTheory.HasShift D Int\nF : CategoryTheory.Functor C D\ninst✝² : F.CommShift Int\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.Preadditive D\nn : Int\nX : CategoryTheory.Pretriangulated.Triangle C\n⊢ Eq ((F.mapTriangleCommShiftIso n).inv.app X).hom₁ ((F.commShiftIso n).inv.app X.obj₁)","decl":"attribute [simps!] mapTriangleCommShiftIso\n\n"}
{"name":"CategoryTheory.Functor.mapTriangleCommShiftIso_hom_app_hom₁","module":"Mathlib.CategoryTheory.Triangulated.Functor","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁶ : CategoryTheory.Category.{u_4, u_1} C\ninst✝⁵ : CategoryTheory.Category.{u_5, u_2} D\ninst✝⁴ : CategoryTheory.HasShift C Int\ninst✝³ : CategoryTheory.HasShift D Int\nF : CategoryTheory.Functor C D\ninst✝² : F.CommShift Int\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.Preadditive D\nn : Int\nX : CategoryTheory.Pretriangulated.Triangle C\n⊢ Eq ((F.mapTriangleCommShiftIso n).hom.app X).hom₁ ((F.commShiftIso n).hom.app X.obj₁)","decl":"attribute [simps!] mapTriangleCommShiftIso\n\n"}
{"name":"CategoryTheory.Functor.mapTriangleCommShiftIso_inv_app_hom₃","module":"Mathlib.CategoryTheory.Triangulated.Functor","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁶ : CategoryTheory.Category.{u_4, u_1} C\ninst✝⁵ : CategoryTheory.Category.{u_5, u_2} D\ninst✝⁴ : CategoryTheory.HasShift C Int\ninst✝³ : CategoryTheory.HasShift D Int\nF : CategoryTheory.Functor C D\ninst✝² : F.CommShift Int\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.Preadditive D\nn : Int\nX : CategoryTheory.Pretriangulated.Triangle C\n⊢ Eq ((F.mapTriangleCommShiftIso n).inv.app X).hom₃ ((F.commShiftIso n).inv.app X.obj₃)","decl":"attribute [simps!] mapTriangleCommShiftIso\n\n"}
{"name":"CategoryTheory.Functor.mapTriangleCommShiftIso_hom_app_hom₂","module":"Mathlib.CategoryTheory.Triangulated.Functor","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁶ : CategoryTheory.Category.{u_4, u_1} C\ninst✝⁵ : CategoryTheory.Category.{u_5, u_2} D\ninst✝⁴ : CategoryTheory.HasShift C Int\ninst✝³ : CategoryTheory.HasShift D Int\nF : CategoryTheory.Functor C D\ninst✝² : F.CommShift Int\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.Preadditive D\nn : Int\nX : CategoryTheory.Pretriangulated.Triangle C\n⊢ Eq ((F.mapTriangleCommShiftIso n).hom.app X).hom₂ ((F.commShiftIso n).hom.app X.obj₂)","decl":"attribute [simps!] mapTriangleCommShiftIso\n\n"}
{"name":"CategoryTheory.Functor.mapTriangleCommShiftIso_inv_app_hom₂","module":"Mathlib.CategoryTheory.Triangulated.Functor","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁶ : CategoryTheory.Category.{u_4, u_1} C\ninst✝⁵ : CategoryTheory.Category.{u_5, u_2} D\ninst✝⁴ : CategoryTheory.HasShift C Int\ninst✝³ : CategoryTheory.HasShift D Int\nF : CategoryTheory.Functor C D\ninst✝² : F.CommShift Int\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.Preadditive D\nn : Int\nX : CategoryTheory.Pretriangulated.Triangle C\n⊢ Eq ((F.mapTriangleCommShiftIso n).inv.app X).hom₂ ((F.commShiftIso n).inv.app X.obj₂)","decl":"attribute [simps!] mapTriangleCommShiftIso\n\n"}
{"name":"CategoryTheory.Functor.mapTriangleCommShiftIso_hom_app_hom₃","module":"Mathlib.CategoryTheory.Triangulated.Functor","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁶ : CategoryTheory.Category.{u_4, u_1} C\ninst✝⁵ : CategoryTheory.Category.{u_5, u_2} D\ninst✝⁴ : CategoryTheory.HasShift C Int\ninst✝³ : CategoryTheory.HasShift D Int\nF : CategoryTheory.Functor C D\ninst✝² : F.CommShift Int\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.Preadditive D\nn : Int\nX : CategoryTheory.Pretriangulated.Triangle C\n⊢ Eq ((F.mapTriangleCommShiftIso n).hom.app X).hom₃ ((F.commShiftIso n).hom.app X.obj₃)","decl":"attribute [simps!] mapTriangleCommShiftIso\n\n"}
{"name":"CategoryTheory.Functor.mapTriangleRotateIso_inv_app_hom₃","module":"Mathlib.CategoryTheory.Triangulated.Functor","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁶ : CategoryTheory.Category.{u_4, u_1} C\ninst✝⁵ : CategoryTheory.Category.{u_5, u_2} D\ninst✝⁴ : CategoryTheory.HasShift C Int\ninst✝³ : CategoryTheory.HasShift D Int\nF : CategoryTheory.Functor C D\ninst✝² : F.CommShift Int\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.Preadditive D\nX : CategoryTheory.Pretriangulated.Triangle C\n⊢ Eq (F.mapTriangleRotateIso.inv.app X).hom₃ ((F.commShiftIso 1).hom.app X.obj₁)","decl":"/-- `F.mapTriangle` commutes with the rotation of triangles. -/\n@[simps!]\ndef mapTriangleRotateIso :\n    F.mapTriangle ⋙ Pretriangulated.rotate D ≅\n      Pretriangulated.rotate C ⋙ F.mapTriangle :=\n  NatIso.ofComponents\n    (fun T => Triangle.isoMk _ _ (Iso.refl _) (Iso.refl _)\n      ((F.commShiftIso (1 : ℤ)).symm.app _)\n      (by simp) (by simp) (by simp)) (by aesop_cat)\n\n"}
{"name":"CategoryTheory.Functor.mapTriangleRotateIso_inv_app_hom₁","module":"Mathlib.CategoryTheory.Triangulated.Functor","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁶ : CategoryTheory.Category.{u_4, u_1} C\ninst✝⁵ : CategoryTheory.Category.{u_5, u_2} D\ninst✝⁴ : CategoryTheory.HasShift C Int\ninst✝³ : CategoryTheory.HasShift D Int\nF : CategoryTheory.Functor C D\ninst✝² : F.CommShift Int\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.Preadditive D\nX : CategoryTheory.Pretriangulated.Triangle C\n⊢ Eq (F.mapTriangleRotateIso.inv.app X).hom₁ (CategoryTheory.CategoryStruct.id (F.obj X.obj₂))","decl":"/-- `F.mapTriangle` commutes with the rotation of triangles. -/\n@[simps!]\ndef mapTriangleRotateIso :\n    F.mapTriangle ⋙ Pretriangulated.rotate D ≅\n      Pretriangulated.rotate C ⋙ F.mapTriangle :=\n  NatIso.ofComponents\n    (fun T => Triangle.isoMk _ _ (Iso.refl _) (Iso.refl _)\n      ((F.commShiftIso (1 : ℤ)).symm.app _)\n      (by simp) (by simp) (by simp)) (by aesop_cat)\n\n"}
{"name":"CategoryTheory.Functor.mapTriangleRotateIso_inv_app_hom₂","module":"Mathlib.CategoryTheory.Triangulated.Functor","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁶ : CategoryTheory.Category.{u_4, u_1} C\ninst✝⁵ : CategoryTheory.Category.{u_5, u_2} D\ninst✝⁴ : CategoryTheory.HasShift C Int\ninst✝³ : CategoryTheory.HasShift D Int\nF : CategoryTheory.Functor C D\ninst✝² : F.CommShift Int\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.Preadditive D\nX : CategoryTheory.Pretriangulated.Triangle C\n⊢ Eq (F.mapTriangleRotateIso.inv.app X).hom₂ (CategoryTheory.CategoryStruct.id (F.obj X.obj₃))","decl":"/-- `F.mapTriangle` commutes with the rotation of triangles. -/\n@[simps!]\ndef mapTriangleRotateIso :\n    F.mapTriangle ⋙ Pretriangulated.rotate D ≅\n      Pretriangulated.rotate C ⋙ F.mapTriangle :=\n  NatIso.ofComponents\n    (fun T => Triangle.isoMk _ _ (Iso.refl _) (Iso.refl _)\n      ((F.commShiftIso (1 : ℤ)).symm.app _)\n      (by simp) (by simp) (by simp)) (by aesop_cat)\n\n"}
{"name":"CategoryTheory.Functor.mapTriangleRotateIso_hom_app_hom₁","module":"Mathlib.CategoryTheory.Triangulated.Functor","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁶ : CategoryTheory.Category.{u_4, u_1} C\ninst✝⁵ : CategoryTheory.Category.{u_5, u_2} D\ninst✝⁴ : CategoryTheory.HasShift C Int\ninst✝³ : CategoryTheory.HasShift D Int\nF : CategoryTheory.Functor C D\ninst✝² : F.CommShift Int\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.Preadditive D\nX : CategoryTheory.Pretriangulated.Triangle C\n⊢ Eq (F.mapTriangleRotateIso.hom.app X).hom₁ (CategoryTheory.CategoryStruct.id (F.obj X.obj₂))","decl":"/-- `F.mapTriangle` commutes with the rotation of triangles. -/\n@[simps!]\ndef mapTriangleRotateIso :\n    F.mapTriangle ⋙ Pretriangulated.rotate D ≅\n      Pretriangulated.rotate C ⋙ F.mapTriangle :=\n  NatIso.ofComponents\n    (fun T => Triangle.isoMk _ _ (Iso.refl _) (Iso.refl _)\n      ((F.commShiftIso (1 : ℤ)).symm.app _)\n      (by simp) (by simp) (by simp)) (by aesop_cat)\n\n"}
{"name":"CategoryTheory.Functor.mapTriangleRotateIso_hom_app_hom₃","module":"Mathlib.CategoryTheory.Triangulated.Functor","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁶ : CategoryTheory.Category.{u_4, u_1} C\ninst✝⁵ : CategoryTheory.Category.{u_5, u_2} D\ninst✝⁴ : CategoryTheory.HasShift C Int\ninst✝³ : CategoryTheory.HasShift D Int\nF : CategoryTheory.Functor C D\ninst✝² : F.CommShift Int\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.Preadditive D\nX : CategoryTheory.Pretriangulated.Triangle C\n⊢ Eq (F.mapTriangleRotateIso.hom.app X).hom₃ ((F.commShiftIso 1).inv.app X.obj₁)","decl":"/-- `F.mapTriangle` commutes with the rotation of triangles. -/\n@[simps!]\ndef mapTriangleRotateIso :\n    F.mapTriangle ⋙ Pretriangulated.rotate D ≅\n      Pretriangulated.rotate C ⋙ F.mapTriangle :=\n  NatIso.ofComponents\n    (fun T => Triangle.isoMk _ _ (Iso.refl _) (Iso.refl _)\n      ((F.commShiftIso (1 : ℤ)).symm.app _)\n      (by simp) (by simp) (by simp)) (by aesop_cat)\n\n"}
{"name":"CategoryTheory.Functor.mapTriangleRotateIso_hom_app_hom₂","module":"Mathlib.CategoryTheory.Triangulated.Functor","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁶ : CategoryTheory.Category.{u_4, u_1} C\ninst✝⁵ : CategoryTheory.Category.{u_5, u_2} D\ninst✝⁴ : CategoryTheory.HasShift C Int\ninst✝³ : CategoryTheory.HasShift D Int\nF : CategoryTheory.Functor C D\ninst✝² : F.CommShift Int\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.Preadditive D\nX : CategoryTheory.Pretriangulated.Triangle C\n⊢ Eq (F.mapTriangleRotateIso.hom.app X).hom₂ (CategoryTheory.CategoryStruct.id (F.obj X.obj₃))","decl":"/-- `F.mapTriangle` commutes with the rotation of triangles. -/\n@[simps!]\ndef mapTriangleRotateIso :\n    F.mapTriangle ⋙ Pretriangulated.rotate D ≅\n      Pretriangulated.rotate C ⋙ F.mapTriangle :=\n  NatIso.ofComponents\n    (fun T => Triangle.isoMk _ _ (Iso.refl _) (Iso.refl _)\n      ((F.commShiftIso (1 : ℤ)).symm.app _)\n      (by simp) (by simp) (by simp)) (by aesop_cat)\n\n"}
{"name":"CategoryTheory.Functor.mapTriangleInvRotateIso_inv_app_hom₃","module":"Mathlib.CategoryTheory.Triangulated.Functor","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁷ : CategoryTheory.Category.{u_4, u_1} C\ninst✝⁶ : CategoryTheory.Category.{u_5, u_2} D\ninst✝⁵ : CategoryTheory.HasShift C Int\ninst✝⁴ : CategoryTheory.HasShift D Int\nF : CategoryTheory.Functor C D\ninst✝³ : F.CommShift Int\ninst✝² : CategoryTheory.Preadditive C\ninst✝¹ : CategoryTheory.Preadditive D\ninst✝ : F.Additive\nX : CategoryTheory.Pretriangulated.Triangle C\n⊢ Eq (F.mapTriangleInvRotateIso.inv.app X).hom₃ (CategoryTheory.CategoryStruct.id (F.obj X.obj₂))","decl":"/-- `F.mapTriangle` commutes with the inverse of the rotation of triangles. -/\n@[simps!]\nnoncomputable def mapTriangleInvRotateIso [F.Additive] :\n    F.mapTriangle ⋙ Pretriangulated.invRotate D ≅\n      Pretriangulated.invRotate C ⋙ F.mapTriangle :=\n  NatIso.ofComponents\n    (fun T => Triangle.isoMk _ _ ((F.commShiftIso (-1 : ℤ)).symm.app _) (Iso.refl _) (Iso.refl _)\n      (by simp) (by simp) (by simp)) (by aesop_cat)\n\n\n"}
{"name":"CategoryTheory.Functor.mapTriangleInvRotateIso_hom_app_hom₂","module":"Mathlib.CategoryTheory.Triangulated.Functor","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁷ : CategoryTheory.Category.{u_4, u_1} C\ninst✝⁶ : CategoryTheory.Category.{u_5, u_2} D\ninst✝⁵ : CategoryTheory.HasShift C Int\ninst✝⁴ : CategoryTheory.HasShift D Int\nF : CategoryTheory.Functor C D\ninst✝³ : F.CommShift Int\ninst✝² : CategoryTheory.Preadditive C\ninst✝¹ : CategoryTheory.Preadditive D\ninst✝ : F.Additive\nX : CategoryTheory.Pretriangulated.Triangle C\n⊢ Eq (F.mapTriangleInvRotateIso.hom.app X).hom₂ (CategoryTheory.CategoryStruct.id (F.obj X.obj₁))","decl":"/-- `F.mapTriangle` commutes with the inverse of the rotation of triangles. -/\n@[simps!]\nnoncomputable def mapTriangleInvRotateIso [F.Additive] :\n    F.mapTriangle ⋙ Pretriangulated.invRotate D ≅\n      Pretriangulated.invRotate C ⋙ F.mapTriangle :=\n  NatIso.ofComponents\n    (fun T => Triangle.isoMk _ _ ((F.commShiftIso (-1 : ℤ)).symm.app _) (Iso.refl _) (Iso.refl _)\n      (by simp) (by simp) (by simp)) (by aesop_cat)\n\n\n"}
{"name":"CategoryTheory.Functor.mapTriangleInvRotateIso_inv_app_hom₂","module":"Mathlib.CategoryTheory.Triangulated.Functor","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁷ : CategoryTheory.Category.{u_4, u_1} C\ninst✝⁶ : CategoryTheory.Category.{u_5, u_2} D\ninst✝⁵ : CategoryTheory.HasShift C Int\ninst✝⁴ : CategoryTheory.HasShift D Int\nF : CategoryTheory.Functor C D\ninst✝³ : F.CommShift Int\ninst✝² : CategoryTheory.Preadditive C\ninst✝¹ : CategoryTheory.Preadditive D\ninst✝ : F.Additive\nX : CategoryTheory.Pretriangulated.Triangle C\n⊢ Eq (F.mapTriangleInvRotateIso.inv.app X).hom₂ (CategoryTheory.CategoryStruct.id (F.obj X.obj₁))","decl":"/-- `F.mapTriangle` commutes with the inverse of the rotation of triangles. -/\n@[simps!]\nnoncomputable def mapTriangleInvRotateIso [F.Additive] :\n    F.mapTriangle ⋙ Pretriangulated.invRotate D ≅\n      Pretriangulated.invRotate C ⋙ F.mapTriangle :=\n  NatIso.ofComponents\n    (fun T => Triangle.isoMk _ _ ((F.commShiftIso (-1 : ℤ)).symm.app _) (Iso.refl _) (Iso.refl _)\n      (by simp) (by simp) (by simp)) (by aesop_cat)\n\n\n"}
{"name":"CategoryTheory.Functor.mapTriangleInvRotateIso_hom_app_hom₁","module":"Mathlib.CategoryTheory.Triangulated.Functor","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁷ : CategoryTheory.Category.{u_4, u_1} C\ninst✝⁶ : CategoryTheory.Category.{u_5, u_2} D\ninst✝⁵ : CategoryTheory.HasShift C Int\ninst✝⁴ : CategoryTheory.HasShift D Int\nF : CategoryTheory.Functor C D\ninst✝³ : F.CommShift Int\ninst✝² : CategoryTheory.Preadditive C\ninst✝¹ : CategoryTheory.Preadditive D\ninst✝ : F.Additive\nX : CategoryTheory.Pretriangulated.Triangle C\n⊢ Eq (F.mapTriangleInvRotateIso.hom.app X).hom₁ ((F.commShiftIso (-1)).inv.app X.obj₃)","decl":"/-- `F.mapTriangle` commutes with the inverse of the rotation of triangles. -/\n@[simps!]\nnoncomputable def mapTriangleInvRotateIso [F.Additive] :\n    F.mapTriangle ⋙ Pretriangulated.invRotate D ≅\n      Pretriangulated.invRotate C ⋙ F.mapTriangle :=\n  NatIso.ofComponents\n    (fun T => Triangle.isoMk _ _ ((F.commShiftIso (-1 : ℤ)).symm.app _) (Iso.refl _) (Iso.refl _)\n      (by simp) (by simp) (by simp)) (by aesop_cat)\n\n\n"}
{"name":"CategoryTheory.Functor.mapTriangleInvRotateIso_inv_app_hom₁","module":"Mathlib.CategoryTheory.Triangulated.Functor","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁷ : CategoryTheory.Category.{u_4, u_1} C\ninst✝⁶ : CategoryTheory.Category.{u_5, u_2} D\ninst✝⁵ : CategoryTheory.HasShift C Int\ninst✝⁴ : CategoryTheory.HasShift D Int\nF : CategoryTheory.Functor C D\ninst✝³ : F.CommShift Int\ninst✝² : CategoryTheory.Preadditive C\ninst✝¹ : CategoryTheory.Preadditive D\ninst✝ : F.Additive\nX : CategoryTheory.Pretriangulated.Triangle C\n⊢ Eq (F.mapTriangleInvRotateIso.inv.app X).hom₁ ((F.commShiftIso (-1)).hom.app X.obj₃)","decl":"/-- `F.mapTriangle` commutes with the inverse of the rotation of triangles. -/\n@[simps!]\nnoncomputable def mapTriangleInvRotateIso [F.Additive] :\n    F.mapTriangle ⋙ Pretriangulated.invRotate D ≅\n      Pretriangulated.invRotate C ⋙ F.mapTriangle :=\n  NatIso.ofComponents\n    (fun T => Triangle.isoMk _ _ ((F.commShiftIso (-1 : ℤ)).symm.app _) (Iso.refl _) (Iso.refl _)\n      (by simp) (by simp) (by simp)) (by aesop_cat)\n\n\n"}
{"name":"CategoryTheory.Functor.mapTriangleInvRotateIso_hom_app_hom₃","module":"Mathlib.CategoryTheory.Triangulated.Functor","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁷ : CategoryTheory.Category.{u_4, u_1} C\ninst✝⁶ : CategoryTheory.Category.{u_5, u_2} D\ninst✝⁵ : CategoryTheory.HasShift C Int\ninst✝⁴ : CategoryTheory.HasShift D Int\nF : CategoryTheory.Functor C D\ninst✝³ : F.CommShift Int\ninst✝² : CategoryTheory.Preadditive C\ninst✝¹ : CategoryTheory.Preadditive D\ninst✝ : F.Additive\nX : CategoryTheory.Pretriangulated.Triangle C\n⊢ Eq (F.mapTriangleInvRotateIso.hom.app X).hom₃ (CategoryTheory.CategoryStruct.id (F.obj X.obj₂))","decl":"/-- `F.mapTriangle` commutes with the inverse of the rotation of triangles. -/\n@[simps!]\nnoncomputable def mapTriangleInvRotateIso [F.Additive] :\n    F.mapTriangle ⋙ Pretriangulated.invRotate D ≅\n      Pretriangulated.invRotate C ⋙ F.mapTriangle :=\n  NatIso.ofComponents\n    (fun T => Triangle.isoMk _ _ ((F.commShiftIso (-1 : ℤ)).symm.app _) (Iso.refl _) (Iso.refl _)\n      (by simp) (by simp) (by simp)) (by aesop_cat)\n\n\n"}
{"name":"CategoryTheory.Functor.mapTriangleIdIso_inv_app_hom₂","module":"Mathlib.CategoryTheory.Triangulated.Functor","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_4, u_1} C\ninst✝ : CategoryTheory.HasShift C Int\nX : CategoryTheory.Pretriangulated.Triangle C\n⊢ Eq ((CategoryTheory.Functor.mapTriangleIdIso C).inv.app X).hom₂ (CategoryTheory.CategoryStruct.id X.obj₂)","decl":"variable (C) in\n/-- The canonical isomorphism `(𝟭 C).mapTriangle ≅ 𝟭 (Triangle C)`. -/\n@[simps!]\ndef mapTriangleIdIso : (𝟭 C).mapTriangle ≅ 𝟭 _ :=\n  NatIso.ofComponents (fun T ↦ Triangle.isoMk _ _ (Iso.refl _) (Iso.refl _) (Iso.refl _))\n\n"}
{"name":"CategoryTheory.Functor.mapTriangleIdIso_inv_app_hom₃","module":"Mathlib.CategoryTheory.Triangulated.Functor","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_4, u_1} C\ninst✝ : CategoryTheory.HasShift C Int\nX : CategoryTheory.Pretriangulated.Triangle C\n⊢ Eq ((CategoryTheory.Functor.mapTriangleIdIso C).inv.app X).hom₃ (CategoryTheory.CategoryStruct.id X.obj₃)","decl":"variable (C) in\n/-- The canonical isomorphism `(𝟭 C).mapTriangle ≅ 𝟭 (Triangle C)`. -/\n@[simps!]\ndef mapTriangleIdIso : (𝟭 C).mapTriangle ≅ 𝟭 _ :=\n  NatIso.ofComponents (fun T ↦ Triangle.isoMk _ _ (Iso.refl _) (Iso.refl _) (Iso.refl _))\n\n"}
{"name":"CategoryTheory.Functor.mapTriangleIdIso_hom_app_hom₁","module":"Mathlib.CategoryTheory.Triangulated.Functor","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_4, u_1} C\ninst✝ : CategoryTheory.HasShift C Int\nX : CategoryTheory.Pretriangulated.Triangle C\n⊢ Eq ((CategoryTheory.Functor.mapTriangleIdIso C).hom.app X).hom₁ (CategoryTheory.CategoryStruct.id X.obj₁)","decl":"variable (C) in\n/-- The canonical isomorphism `(𝟭 C).mapTriangle ≅ 𝟭 (Triangle C)`. -/\n@[simps!]\ndef mapTriangleIdIso : (𝟭 C).mapTriangle ≅ 𝟭 _ :=\n  NatIso.ofComponents (fun T ↦ Triangle.isoMk _ _ (Iso.refl _) (Iso.refl _) (Iso.refl _))\n\n"}
{"name":"CategoryTheory.Functor.mapTriangleIdIso_hom_app_hom₂","module":"Mathlib.CategoryTheory.Triangulated.Functor","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_4, u_1} C\ninst✝ : CategoryTheory.HasShift C Int\nX : CategoryTheory.Pretriangulated.Triangle C\n⊢ Eq ((CategoryTheory.Functor.mapTriangleIdIso C).hom.app X).hom₂ (CategoryTheory.CategoryStruct.id X.obj₂)","decl":"variable (C) in\n/-- The canonical isomorphism `(𝟭 C).mapTriangle ≅ 𝟭 (Triangle C)`. -/\n@[simps!]\ndef mapTriangleIdIso : (𝟭 C).mapTriangle ≅ 𝟭 _ :=\n  NatIso.ofComponents (fun T ↦ Triangle.isoMk _ _ (Iso.refl _) (Iso.refl _) (Iso.refl _))\n\n"}
{"name":"CategoryTheory.Functor.mapTriangleIdIso_hom_app_hom₃","module":"Mathlib.CategoryTheory.Triangulated.Functor","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_4, u_1} C\ninst✝ : CategoryTheory.HasShift C Int\nX : CategoryTheory.Pretriangulated.Triangle C\n⊢ Eq ((CategoryTheory.Functor.mapTriangleIdIso C).hom.app X).hom₃ (CategoryTheory.CategoryStruct.id X.obj₃)","decl":"variable (C) in\n/-- The canonical isomorphism `(𝟭 C).mapTriangle ≅ 𝟭 (Triangle C)`. -/\n@[simps!]\ndef mapTriangleIdIso : (𝟭 C).mapTriangle ≅ 𝟭 _ :=\n  NatIso.ofComponents (fun T ↦ Triangle.isoMk _ _ (Iso.refl _) (Iso.refl _) (Iso.refl _))\n\n"}
{"name":"CategoryTheory.Functor.mapTriangleIdIso_inv_app_hom₁","module":"Mathlib.CategoryTheory.Triangulated.Functor","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_4, u_1} C\ninst✝ : CategoryTheory.HasShift C Int\nX : CategoryTheory.Pretriangulated.Triangle C\n⊢ Eq ((CategoryTheory.Functor.mapTriangleIdIso C).inv.app X).hom₁ (CategoryTheory.CategoryStruct.id X.obj₁)","decl":"variable (C) in\n/-- The canonical isomorphism `(𝟭 C).mapTriangle ≅ 𝟭 (Triangle C)`. -/\n@[simps!]\ndef mapTriangleIdIso : (𝟭 C).mapTriangle ≅ 𝟭 _ :=\n  NatIso.ofComponents (fun T ↦ Triangle.isoMk _ _ (Iso.refl _) (Iso.refl _) (Iso.refl _))\n\n"}
{"name":"CategoryTheory.Functor.mapTriangleCompIso_hom_app_hom₁","module":"Mathlib.CategoryTheory.Triangulated.Functor","initialProofState":"C : Type u_1\nD : Type u_2\nE : Type u_3\ninst✝⁷ : CategoryTheory.Category.{u_4, u_1} C\ninst✝⁶ : CategoryTheory.Category.{u_5, u_2} D\ninst✝⁵ : CategoryTheory.Category.{u_6, u_3} E\ninst✝⁴ : CategoryTheory.HasShift C Int\ninst✝³ : CategoryTheory.HasShift D Int\ninst✝² : CategoryTheory.HasShift E Int\nF : CategoryTheory.Functor C D\ninst✝¹ : F.CommShift Int\nG : CategoryTheory.Functor D E\ninst✝ : G.CommShift Int\nX : CategoryTheory.Pretriangulated.Triangle C\n⊢ Eq ((F.mapTriangleCompIso G).hom.app X).hom₁ (CategoryTheory.CategoryStruct.id (G.obj (F.obj X.obj₁)))","decl":"/-- The canonical isomorphism `(F ⋙ G).mapTriangle ≅ F.mapTriangle ⋙ G.mapTriangle`. -/\n@[simps!]\ndef mapTriangleCompIso : (F ⋙ G).mapTriangle ≅ F.mapTriangle ⋙ G.mapTriangle :=\n  NatIso.ofComponents (fun T => Triangle.isoMk _ _ (Iso.refl _) (Iso.refl _) (Iso.refl _))\n\n"}
{"name":"CategoryTheory.Functor.mapTriangleCompIso_hom_app_hom₃","module":"Mathlib.CategoryTheory.Triangulated.Functor","initialProofState":"C : Type u_1\nD : Type u_2\nE : Type u_3\ninst✝⁷ : CategoryTheory.Category.{u_4, u_1} C\ninst✝⁶ : CategoryTheory.Category.{u_5, u_2} D\ninst✝⁵ : CategoryTheory.Category.{u_6, u_3} E\ninst✝⁴ : CategoryTheory.HasShift C Int\ninst✝³ : CategoryTheory.HasShift D Int\ninst✝² : CategoryTheory.HasShift E Int\nF : CategoryTheory.Functor C D\ninst✝¹ : F.CommShift Int\nG : CategoryTheory.Functor D E\ninst✝ : G.CommShift Int\nX : CategoryTheory.Pretriangulated.Triangle C\n⊢ Eq ((F.mapTriangleCompIso G).hom.app X).hom₃ (CategoryTheory.CategoryStruct.id (G.obj (F.obj X.obj₃)))","decl":"/-- The canonical isomorphism `(F ⋙ G).mapTriangle ≅ F.mapTriangle ⋙ G.mapTriangle`. -/\n@[simps!]\ndef mapTriangleCompIso : (F ⋙ G).mapTriangle ≅ F.mapTriangle ⋙ G.mapTriangle :=\n  NatIso.ofComponents (fun T => Triangle.isoMk _ _ (Iso.refl _) (Iso.refl _) (Iso.refl _))\n\n"}
{"name":"CategoryTheory.Functor.mapTriangleCompIso_inv_app_hom₂","module":"Mathlib.CategoryTheory.Triangulated.Functor","initialProofState":"C : Type u_1\nD : Type u_2\nE : Type u_3\ninst✝⁷ : CategoryTheory.Category.{u_4, u_1} C\ninst✝⁶ : CategoryTheory.Category.{u_5, u_2} D\ninst✝⁵ : CategoryTheory.Category.{u_6, u_3} E\ninst✝⁴ : CategoryTheory.HasShift C Int\ninst✝³ : CategoryTheory.HasShift D Int\ninst✝² : CategoryTheory.HasShift E Int\nF : CategoryTheory.Functor C D\ninst✝¹ : F.CommShift Int\nG : CategoryTheory.Functor D E\ninst✝ : G.CommShift Int\nX : CategoryTheory.Pretriangulated.Triangle C\n⊢ Eq ((F.mapTriangleCompIso G).inv.app X).hom₂ (CategoryTheory.CategoryStruct.id (G.obj (F.obj X.obj₂)))","decl":"/-- The canonical isomorphism `(F ⋙ G).mapTriangle ≅ F.mapTriangle ⋙ G.mapTriangle`. -/\n@[simps!]\ndef mapTriangleCompIso : (F ⋙ G).mapTriangle ≅ F.mapTriangle ⋙ G.mapTriangle :=\n  NatIso.ofComponents (fun T => Triangle.isoMk _ _ (Iso.refl _) (Iso.refl _) (Iso.refl _))\n\n"}
{"name":"CategoryTheory.Functor.mapTriangleCompIso_inv_app_hom₃","module":"Mathlib.CategoryTheory.Triangulated.Functor","initialProofState":"C : Type u_1\nD : Type u_2\nE : Type u_3\ninst✝⁷ : CategoryTheory.Category.{u_4, u_1} C\ninst✝⁶ : CategoryTheory.Category.{u_5, u_2} D\ninst✝⁵ : CategoryTheory.Category.{u_6, u_3} E\ninst✝⁴ : CategoryTheory.HasShift C Int\ninst✝³ : CategoryTheory.HasShift D Int\ninst✝² : CategoryTheory.HasShift E Int\nF : CategoryTheory.Functor C D\ninst✝¹ : F.CommShift Int\nG : CategoryTheory.Functor D E\ninst✝ : G.CommShift Int\nX : CategoryTheory.Pretriangulated.Triangle C\n⊢ Eq ((F.mapTriangleCompIso G).inv.app X).hom₃ (CategoryTheory.CategoryStruct.id (G.obj (F.obj X.obj₃)))","decl":"/-- The canonical isomorphism `(F ⋙ G).mapTriangle ≅ F.mapTriangle ⋙ G.mapTriangle`. -/\n@[simps!]\ndef mapTriangleCompIso : (F ⋙ G).mapTriangle ≅ F.mapTriangle ⋙ G.mapTriangle :=\n  NatIso.ofComponents (fun T => Triangle.isoMk _ _ (Iso.refl _) (Iso.refl _) (Iso.refl _))\n\n"}
{"name":"CategoryTheory.Functor.mapTriangleCompIso_inv_app_hom₁","module":"Mathlib.CategoryTheory.Triangulated.Functor","initialProofState":"C : Type u_1\nD : Type u_2\nE : Type u_3\ninst✝⁷ : CategoryTheory.Category.{u_4, u_1} C\ninst✝⁶ : CategoryTheory.Category.{u_5, u_2} D\ninst✝⁵ : CategoryTheory.Category.{u_6, u_3} E\ninst✝⁴ : CategoryTheory.HasShift C Int\ninst✝³ : CategoryTheory.HasShift D Int\ninst✝² : CategoryTheory.HasShift E Int\nF : CategoryTheory.Functor C D\ninst✝¹ : F.CommShift Int\nG : CategoryTheory.Functor D E\ninst✝ : G.CommShift Int\nX : CategoryTheory.Pretriangulated.Triangle C\n⊢ Eq ((F.mapTriangleCompIso G).inv.app X).hom₁ (CategoryTheory.CategoryStruct.id (G.obj (F.obj X.obj₁)))","decl":"/-- The canonical isomorphism `(F ⋙ G).mapTriangle ≅ F.mapTriangle ⋙ G.mapTriangle`. -/\n@[simps!]\ndef mapTriangleCompIso : (F ⋙ G).mapTriangle ≅ F.mapTriangle ⋙ G.mapTriangle :=\n  NatIso.ofComponents (fun T => Triangle.isoMk _ _ (Iso.refl _) (Iso.refl _) (Iso.refl _))\n\n"}
{"name":"CategoryTheory.Functor.mapTriangleCompIso_hom_app_hom₂","module":"Mathlib.CategoryTheory.Triangulated.Functor","initialProofState":"C : Type u_1\nD : Type u_2\nE : Type u_3\ninst✝⁷ : CategoryTheory.Category.{u_4, u_1} C\ninst✝⁶ : CategoryTheory.Category.{u_5, u_2} D\ninst✝⁵ : CategoryTheory.Category.{u_6, u_3} E\ninst✝⁴ : CategoryTheory.HasShift C Int\ninst✝³ : CategoryTheory.HasShift D Int\ninst✝² : CategoryTheory.HasShift E Int\nF : CategoryTheory.Functor C D\ninst✝¹ : F.CommShift Int\nG : CategoryTheory.Functor D E\ninst✝ : G.CommShift Int\nX : CategoryTheory.Pretriangulated.Triangle C\n⊢ Eq ((F.mapTriangleCompIso G).hom.app X).hom₂ (CategoryTheory.CategoryStruct.id (G.obj (F.obj X.obj₂)))","decl":"/-- The canonical isomorphism `(F ⋙ G).mapTriangle ≅ F.mapTriangle ⋙ G.mapTriangle`. -/\n@[simps!]\ndef mapTriangleCompIso : (F ⋙ G).mapTriangle ≅ F.mapTriangle ⋙ G.mapTriangle :=\n  NatIso.ofComponents (fun T => Triangle.isoMk _ _ (Iso.refl _) (Iso.refl _) (Iso.refl _))\n\n"}
{"name":"CategoryTheory.Functor.mapTriangleIso_hom_app_hom₂","module":"Mathlib.CategoryTheory.Triangulated.Functor","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁶ : CategoryTheory.Category.{u_4, u_1} C\ninst✝⁵ : CategoryTheory.Category.{u_5, u_2} D\ninst✝⁴ : CategoryTheory.HasShift C Int\ninst✝³ : CategoryTheory.HasShift D Int\nF₁ F₂ : CategoryTheory.Functor C D\ne : CategoryTheory.Iso F₁ F₂\ninst✝² : F₁.CommShift Int\ninst✝¹ : F₂.CommShift Int\ninst✝ : CategoryTheory.NatTrans.CommShift e.hom Int\nX : CategoryTheory.Pretriangulated.Triangle C\n⊢ Eq ((CategoryTheory.Functor.mapTriangleIso e).hom.app X).hom₂ (e.hom.app X.obj₂)","decl":"/-- Two isomorphic functors `F₁` and `F₂` induce isomorphic functors\n`F₁.mapTriangle` and `F₂.mapTriangle` if the isomorphism `F₁ ≅ F₂` is compatible\nwith the shifts. -/\n@[simps!]\ndef mapTriangleIso {F₁ F₂ : C ⥤ D} (e : F₁ ≅ F₂) [F₁.CommShift ℤ] [F₂.CommShift ℤ]\n    [NatTrans.CommShift e.hom ℤ] : F₁.mapTriangle ≅ F₂.mapTriangle :=\n  NatIso.ofComponents (fun T =>\n    Triangle.isoMk _ _ (e.app _) (e.app _) (e.app _) (by simp) (by simp) (by\n      dsimp\n      simp only [assoc, NatTrans.shift_app_comm e.hom (1 : ℤ) T.obj₁,\n        NatTrans.naturality_assoc])) (by aesop_cat)\n\n"}
{"name":"CategoryTheory.Functor.mapTriangleIso_hom_app_hom₁","module":"Mathlib.CategoryTheory.Triangulated.Functor","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁶ : CategoryTheory.Category.{u_4, u_1} C\ninst✝⁵ : CategoryTheory.Category.{u_5, u_2} D\ninst✝⁴ : CategoryTheory.HasShift C Int\ninst✝³ : CategoryTheory.HasShift D Int\nF₁ F₂ : CategoryTheory.Functor C D\ne : CategoryTheory.Iso F₁ F₂\ninst✝² : F₁.CommShift Int\ninst✝¹ : F₂.CommShift Int\ninst✝ : CategoryTheory.NatTrans.CommShift e.hom Int\nX : CategoryTheory.Pretriangulated.Triangle C\n⊢ Eq ((CategoryTheory.Functor.mapTriangleIso e).hom.app X).hom₁ (e.hom.app X.obj₁)","decl":"/-- Two isomorphic functors `F₁` and `F₂` induce isomorphic functors\n`F₁.mapTriangle` and `F₂.mapTriangle` if the isomorphism `F₁ ≅ F₂` is compatible\nwith the shifts. -/\n@[simps!]\ndef mapTriangleIso {F₁ F₂ : C ⥤ D} (e : F₁ ≅ F₂) [F₁.CommShift ℤ] [F₂.CommShift ℤ]\n    [NatTrans.CommShift e.hom ℤ] : F₁.mapTriangle ≅ F₂.mapTriangle :=\n  NatIso.ofComponents (fun T =>\n    Triangle.isoMk _ _ (e.app _) (e.app _) (e.app _) (by simp) (by simp) (by\n      dsimp\n      simp only [assoc, NatTrans.shift_app_comm e.hom (1 : ℤ) T.obj₁,\n        NatTrans.naturality_assoc])) (by aesop_cat)\n\n"}
{"name":"CategoryTheory.Functor.mapTriangleIso_hom_app_hom₃","module":"Mathlib.CategoryTheory.Triangulated.Functor","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁶ : CategoryTheory.Category.{u_4, u_1} C\ninst✝⁵ : CategoryTheory.Category.{u_5, u_2} D\ninst✝⁴ : CategoryTheory.HasShift C Int\ninst✝³ : CategoryTheory.HasShift D Int\nF₁ F₂ : CategoryTheory.Functor C D\ne : CategoryTheory.Iso F₁ F₂\ninst✝² : F₁.CommShift Int\ninst✝¹ : F₂.CommShift Int\ninst✝ : CategoryTheory.NatTrans.CommShift e.hom Int\nX : CategoryTheory.Pretriangulated.Triangle C\n⊢ Eq ((CategoryTheory.Functor.mapTriangleIso e).hom.app X).hom₃ (e.hom.app X.obj₃)","decl":"/-- Two isomorphic functors `F₁` and `F₂` induce isomorphic functors\n`F₁.mapTriangle` and `F₂.mapTriangle` if the isomorphism `F₁ ≅ F₂` is compatible\nwith the shifts. -/\n@[simps!]\ndef mapTriangleIso {F₁ F₂ : C ⥤ D} (e : F₁ ≅ F₂) [F₁.CommShift ℤ] [F₂.CommShift ℤ]\n    [NatTrans.CommShift e.hom ℤ] : F₁.mapTriangle ≅ F₂.mapTriangle :=\n  NatIso.ofComponents (fun T =>\n    Triangle.isoMk _ _ (e.app _) (e.app _) (e.app _) (by simp) (by simp) (by\n      dsimp\n      simp only [assoc, NatTrans.shift_app_comm e.hom (1 : ℤ) T.obj₁,\n        NatTrans.naturality_assoc])) (by aesop_cat)\n\n"}
{"name":"CategoryTheory.Functor.mapTriangleIso_inv_app_hom₂","module":"Mathlib.CategoryTheory.Triangulated.Functor","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁶ : CategoryTheory.Category.{u_4, u_1} C\ninst✝⁵ : CategoryTheory.Category.{u_5, u_2} D\ninst✝⁴ : CategoryTheory.HasShift C Int\ninst✝³ : CategoryTheory.HasShift D Int\nF₁ F₂ : CategoryTheory.Functor C D\ne : CategoryTheory.Iso F₁ F₂\ninst✝² : F₁.CommShift Int\ninst✝¹ : F₂.CommShift Int\ninst✝ : CategoryTheory.NatTrans.CommShift e.hom Int\nX : CategoryTheory.Pretriangulated.Triangle C\n⊢ Eq ((CategoryTheory.Functor.mapTriangleIso e).inv.app X).hom₂ (e.inv.app X.obj₂)","decl":"/-- Two isomorphic functors `F₁` and `F₂` induce isomorphic functors\n`F₁.mapTriangle` and `F₂.mapTriangle` if the isomorphism `F₁ ≅ F₂` is compatible\nwith the shifts. -/\n@[simps!]\ndef mapTriangleIso {F₁ F₂ : C ⥤ D} (e : F₁ ≅ F₂) [F₁.CommShift ℤ] [F₂.CommShift ℤ]\n    [NatTrans.CommShift e.hom ℤ] : F₁.mapTriangle ≅ F₂.mapTriangle :=\n  NatIso.ofComponents (fun T =>\n    Triangle.isoMk _ _ (e.app _) (e.app _) (e.app _) (by simp) (by simp) (by\n      dsimp\n      simp only [assoc, NatTrans.shift_app_comm e.hom (1 : ℤ) T.obj₁,\n        NatTrans.naturality_assoc])) (by aesop_cat)\n\n"}
{"name":"CategoryTheory.Functor.mapTriangleIso_inv_app_hom₁","module":"Mathlib.CategoryTheory.Triangulated.Functor","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁶ : CategoryTheory.Category.{u_4, u_1} C\ninst✝⁵ : CategoryTheory.Category.{u_5, u_2} D\ninst✝⁴ : CategoryTheory.HasShift C Int\ninst✝³ : CategoryTheory.HasShift D Int\nF₁ F₂ : CategoryTheory.Functor C D\ne : CategoryTheory.Iso F₁ F₂\ninst✝² : F₁.CommShift Int\ninst✝¹ : F₂.CommShift Int\ninst✝ : CategoryTheory.NatTrans.CommShift e.hom Int\nX : CategoryTheory.Pretriangulated.Triangle C\n⊢ Eq ((CategoryTheory.Functor.mapTriangleIso e).inv.app X).hom₁ (e.inv.app X.obj₁)","decl":"/-- Two isomorphic functors `F₁` and `F₂` induce isomorphic functors\n`F₁.mapTriangle` and `F₂.mapTriangle` if the isomorphism `F₁ ≅ F₂` is compatible\nwith the shifts. -/\n@[simps!]\ndef mapTriangleIso {F₁ F₂ : C ⥤ D} (e : F₁ ≅ F₂) [F₁.CommShift ℤ] [F₂.CommShift ℤ]\n    [NatTrans.CommShift e.hom ℤ] : F₁.mapTriangle ≅ F₂.mapTriangle :=\n  NatIso.ofComponents (fun T =>\n    Triangle.isoMk _ _ (e.app _) (e.app _) (e.app _) (by simp) (by simp) (by\n      dsimp\n      simp only [assoc, NatTrans.shift_app_comm e.hom (1 : ℤ) T.obj₁,\n        NatTrans.naturality_assoc])) (by aesop_cat)\n\n"}
{"name":"CategoryTheory.Functor.mapTriangleIso_inv_app_hom₃","module":"Mathlib.CategoryTheory.Triangulated.Functor","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁶ : CategoryTheory.Category.{u_4, u_1} C\ninst✝⁵ : CategoryTheory.Category.{u_5, u_2} D\ninst✝⁴ : CategoryTheory.HasShift C Int\ninst✝³ : CategoryTheory.HasShift D Int\nF₁ F₂ : CategoryTheory.Functor C D\ne : CategoryTheory.Iso F₁ F₂\ninst✝² : F₁.CommShift Int\ninst✝¹ : F₂.CommShift Int\ninst✝ : CategoryTheory.NatTrans.CommShift e.hom Int\nX : CategoryTheory.Pretriangulated.Triangle C\n⊢ Eq ((CategoryTheory.Functor.mapTriangleIso e).inv.app X).hom₃ (e.inv.app X.obj₃)","decl":"/-- Two isomorphic functors `F₁` and `F₂` induce isomorphic functors\n`F₁.mapTriangle` and `F₂.mapTriangle` if the isomorphism `F₁ ≅ F₂` is compatible\nwith the shifts. -/\n@[simps!]\ndef mapTriangleIso {F₁ F₂ : C ⥤ D} (e : F₁ ≅ F₂) [F₁.CommShift ℤ] [F₂.CommShift ℤ]\n    [NatTrans.CommShift e.hom ℤ] : F₁.mapTriangle ≅ F₂.mapTriangle :=\n  NatIso.ofComponents (fun T =>\n    Triangle.isoMk _ _ (e.app _) (e.app _) (e.app _) (by simp) (by simp) (by\n      dsimp\n      simp only [assoc, NatTrans.shift_app_comm e.hom (1 : ℤ) T.obj₁,\n        NatTrans.naturality_assoc])) (by aesop_cat)\n\n"}
{"name":"CategoryTheory.Functor.IsTriangulated.map_distinguished","module":"Mathlib.CategoryTheory.Triangulated.Functor","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝¹² : CategoryTheory.Category.{u_4, u_1} C\ninst✝¹¹ : CategoryTheory.Category.{u_5, u_2} D\ninst✝¹⁰ : CategoryTheory.HasShift C Int\ninst✝⁹ : CategoryTheory.HasShift D Int\nF : CategoryTheory.Functor C D\ninst✝⁸ : F.CommShift Int\ninst✝⁷ : CategoryTheory.Limits.HasZeroObject C\ninst✝⁶ : CategoryTheory.Limits.HasZeroObject D\ninst✝⁵ : CategoryTheory.Preadditive C\ninst✝⁴ : CategoryTheory.Preadditive D\ninst✝³ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\ninst✝² : ∀ (n : Int), (CategoryTheory.shiftFunctor D n).Additive\ninst✝¹ : CategoryTheory.Pretriangulated C\ninst✝ : CategoryTheory.Pretriangulated D\nself : F.IsTriangulated\nT : CategoryTheory.Pretriangulated.Triangle C\na✝ : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T\n⊢ Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles (F.mapTriangle.obj T)","decl":"/-- A functor which commutes with the shift by `ℤ` is triangulated if\nit sends distinguished triangles to distinguished triangles. -/\nclass IsTriangulated : Prop where\n  map_distinguished (T : Triangle C) : (T ∈ distTriang C) → F.mapTriangle.obj T ∈ distTriang D\n\n"}
{"name":"CategoryTheory.Functor.map_distinguished","module":"Mathlib.CategoryTheory.Triangulated.Functor","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝¹³ : CategoryTheory.Category.{u_4, u_1} C\ninst✝¹² : CategoryTheory.Category.{u_5, u_2} D\ninst✝¹¹ : CategoryTheory.HasShift C Int\ninst✝¹⁰ : CategoryTheory.HasShift D Int\nF : CategoryTheory.Functor C D\ninst✝⁹ : F.CommShift Int\ninst✝⁸ : CategoryTheory.Limits.HasZeroObject C\ninst✝⁷ : CategoryTheory.Limits.HasZeroObject D\ninst✝⁶ : CategoryTheory.Preadditive C\ninst✝⁵ : CategoryTheory.Preadditive D\ninst✝⁴ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\ninst✝³ : ∀ (n : Int), (CategoryTheory.shiftFunctor D n).Additive\ninst✝² : CategoryTheory.Pretriangulated C\ninst✝¹ : CategoryTheory.Pretriangulated D\ninst✝ : F.IsTriangulated\nT : CategoryTheory.Pretriangulated.Triangle C\nhT : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T\n⊢ Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles (F.mapTriangle.obj T)","decl":"lemma map_distinguished [F.IsTriangulated] (T : Triangle C) (hT : T ∈ distTriang C) :\n    F.mapTriangle.obj T ∈ distTriang D :=\n  IsTriangulated.map_distinguished _ hT\n\n"}
{"name":"CategoryTheory.Functor.IsTriangulated.instPreservesZeroMorphisms","module":"Mathlib.CategoryTheory.Triangulated.Functor","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝¹³ : CategoryTheory.Category.{u_4, u_1} C\ninst✝¹² : CategoryTheory.Category.{u_5, u_2} D\ninst✝¹¹ : CategoryTheory.HasShift C Int\ninst✝¹⁰ : CategoryTheory.HasShift D Int\nF : CategoryTheory.Functor C D\ninst✝⁹ : F.CommShift Int\ninst✝⁸ : CategoryTheory.Limits.HasZeroObject C\ninst✝⁷ : CategoryTheory.Limits.HasZeroObject D\ninst✝⁶ : CategoryTheory.Preadditive C\ninst✝⁵ : CategoryTheory.Preadditive D\ninst✝⁴ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\ninst✝³ : ∀ (n : Int), (CategoryTheory.shiftFunctor D n).Additive\ninst✝² : CategoryTheory.Pretriangulated C\ninst✝¹ : CategoryTheory.Pretriangulated D\ninst✝ : F.IsTriangulated\n⊢ F.PreservesZeroMorphisms","decl":"instance (priority := 100) [F.IsTriangulated] : PreservesZeroMorphisms F where\n  map_zero X Y := by\n    have h₁ : (0 : X ⟶ Y) = 0 ≫ 𝟙 0 ≫ 0 := by simp\n    have h₂ : 𝟙 (F.obj 0) = 0 := by\n      rw [← IsZero.iff_id_eq_zero]\n      apply Triangle.isZero₃_of_isIso₁ _\n        (F.map_distinguished _ (contractible_distinguished (0 : C)))\n      dsimp\n      infer_instance\n    rw [h₁, F.map_comp, F.map_comp, F.map_id, h₂, zero_comp, comp_zero]\n\n"}
{"name":"CategoryTheory.Functor.IsTriangulated.instPreservesLimitsOfShapeDiscreteWalkingPair","module":"Mathlib.CategoryTheory.Triangulated.Functor","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝¹³ : CategoryTheory.Category.{u_4, u_1} C\ninst✝¹² : CategoryTheory.Category.{u_5, u_2} D\ninst✝¹¹ : CategoryTheory.HasShift C Int\ninst✝¹⁰ : CategoryTheory.HasShift D Int\nF : CategoryTheory.Functor C D\ninst✝⁹ : F.CommShift Int\ninst✝⁸ : CategoryTheory.Limits.HasZeroObject C\ninst✝⁷ : CategoryTheory.Limits.HasZeroObject D\ninst✝⁶ : CategoryTheory.Preadditive C\ninst✝⁵ : CategoryTheory.Preadditive D\ninst✝⁴ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\ninst✝³ : ∀ (n : Int), (CategoryTheory.shiftFunctor D n).Additive\ninst✝² : CategoryTheory.Pretriangulated C\ninst✝¹ : CategoryTheory.Pretriangulated D\ninst✝ : F.IsTriangulated\n⊢ CategoryTheory.Limits.PreservesLimitsOfShape (CategoryTheory.Discrete CategoryTheory.Limits.WalkingPair) F","decl":"noncomputable instance [F.IsTriangulated] :\n    PreservesLimitsOfShape (Discrete WalkingPair) F := by\n  suffices ∀ (X₁ X₃ : C), IsIso (prodComparison F X₁ X₃) by\n    have := fun (X₁ X₃ : C) ↦ PreservesLimitPair.of_iso_prod_comparison F X₁ X₃\n    exact ⟨fun {K} ↦ preservesLimit_of_iso_diagram F (diagramIsoPair K).symm⟩\n  intro X₁ X₃\n  let φ : F.mapTriangle.obj (binaryProductTriangle X₁ X₃) ⟶\n      binaryProductTriangle (F.obj X₁) (F.obj X₃) :=\n    { hom₁ := 𝟙 _\n      hom₂ := prodComparison F X₁ X₃\n      hom₃ := 𝟙 _\n      comm₁ := by\n        dsimp\n        ext\n        · simp only [assoc, prodComparison_fst, prod.comp_lift, comp_id, comp_zero,\n            limit.lift_π, BinaryFan.mk_pt, BinaryFan.π_app_left, BinaryFan.mk_fst,\n            ← F.map_comp, F.map_id]\n        · simp only [assoc, prodComparison_snd, prod.comp_lift, comp_id, comp_zero,\n            limit.lift_π, BinaryFan.mk_pt, BinaryFan.π_app_right, BinaryFan.mk_snd,\n            ← F.map_comp, F.map_zero]\n      comm₂ := by simp\n      comm₃ := by simp }\n  exact isIso₂_of_isIso₁₃ φ (F.map_distinguished _ (binaryProductTriangle_distinguished X₁ X₃))\n    (binaryProductTriangle_distinguished _ _)\n    (by dsimp [φ]; infer_instance) (by dsimp [φ]; infer_instance)\n\n"}
{"name":"CategoryTheory.Functor.IsTriangulated.instAdditive","module":"Mathlib.CategoryTheory.Triangulated.Functor","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝¹³ : CategoryTheory.Category.{u_4, u_1} C\ninst✝¹² : CategoryTheory.Category.{u_5, u_2} D\ninst✝¹¹ : CategoryTheory.HasShift C Int\ninst✝¹⁰ : CategoryTheory.HasShift D Int\nF : CategoryTheory.Functor C D\ninst✝⁹ : F.CommShift Int\ninst✝⁸ : CategoryTheory.Limits.HasZeroObject C\ninst✝⁷ : CategoryTheory.Limits.HasZeroObject D\ninst✝⁶ : CategoryTheory.Preadditive C\ninst✝⁵ : CategoryTheory.Preadditive D\ninst✝⁴ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\ninst✝³ : ∀ (n : Int), (CategoryTheory.shiftFunctor D n).Additive\ninst✝² : CategoryTheory.Pretriangulated C\ninst✝¹ : CategoryTheory.Pretriangulated D\ninst✝ : F.IsTriangulated\n⊢ F.Additive","decl":"instance (priority := 100) [F.IsTriangulated] : F.Additive :=\n  F.additive_of_preserves_binary_products\n\n"}
{"name":"CategoryTheory.Functor.IsTriangulated.instId","module":"Mathlib.CategoryTheory.Triangulated.Functor","initialProofState":"C : Type u_1\ninst✝⁵ : CategoryTheory.Category.{u_4, u_1} C\ninst✝⁴ : CategoryTheory.HasShift C Int\ninst✝³ : CategoryTheory.Limits.HasZeroObject C\ninst✝² : CategoryTheory.Preadditive C\ninst✝¹ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\ninst✝ : CategoryTheory.Pretriangulated C\n⊢ (CategoryTheory.Functor.id C).IsTriangulated","decl":"instance : (𝟭 C).IsTriangulated where\n  map_distinguished T hT :=\n    isomorphic_distinguished _ hT _ ((mapTriangleIdIso C).app T)\n\n"}
{"name":"CategoryTheory.Functor.IsTriangulated.instComp","module":"Mathlib.CategoryTheory.Triangulated.Functor","initialProofState":"C : Type u_1\nD : Type u_2\nE : Type u_3\ninst✝²¹ : CategoryTheory.Category.{u_4, u_1} C\ninst✝²⁰ : CategoryTheory.Category.{u_5, u_2} D\ninst✝¹⁹ : CategoryTheory.Category.{u_6, u_3} E\ninst✝¹⁸ : CategoryTheory.HasShift C Int\ninst✝¹⁷ : CategoryTheory.HasShift D Int\ninst✝¹⁶ : CategoryTheory.HasShift E Int\nF : CategoryTheory.Functor C D\ninst✝¹⁵ : F.CommShift Int\nG : CategoryTheory.Functor D E\ninst✝¹⁴ : G.CommShift Int\ninst✝¹³ : CategoryTheory.Limits.HasZeroObject C\ninst✝¹² : CategoryTheory.Limits.HasZeroObject D\ninst✝¹¹ : CategoryTheory.Limits.HasZeroObject E\ninst✝¹⁰ : CategoryTheory.Preadditive C\ninst✝⁹ : CategoryTheory.Preadditive D\ninst✝⁸ : CategoryTheory.Preadditive E\ninst✝⁷ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\ninst✝⁶ : ∀ (n : Int), (CategoryTheory.shiftFunctor D n).Additive\ninst✝⁵ : ∀ (n : Int), (CategoryTheory.shiftFunctor E n).Additive\ninst✝⁴ : CategoryTheory.Pretriangulated C\ninst✝³ : CategoryTheory.Pretriangulated D\ninst✝² : CategoryTheory.Pretriangulated E\ninst✝¹ : F.IsTriangulated\ninst✝ : G.IsTriangulated\n⊢ (F.comp G).IsTriangulated","decl":"instance [F.IsTriangulated] [G.IsTriangulated] : (F ⋙ G).IsTriangulated where\n  map_distinguished T hT :=\n    isomorphic_distinguished _ (G.map_distinguished _ (F.map_distinguished T hT)) _\n      ((mapTriangleCompIso F G).app T)\n\n"}
{"name":"CategoryTheory.Functor.isTriangulated_of_iso","module":"Mathlib.CategoryTheory.Triangulated.Functor","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝¹⁵ : CategoryTheory.Category.{u_4, u_1} C\ninst✝¹⁴ : CategoryTheory.Category.{u_5, u_2} D\ninst✝¹³ : CategoryTheory.HasShift C Int\ninst✝¹² : CategoryTheory.HasShift D Int\ninst✝¹¹ : CategoryTheory.Limits.HasZeroObject C\ninst✝¹⁰ : CategoryTheory.Limits.HasZeroObject D\ninst✝⁹ : CategoryTheory.Preadditive C\ninst✝⁸ : CategoryTheory.Preadditive D\ninst✝⁷ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\ninst✝⁶ : ∀ (n : Int), (CategoryTheory.shiftFunctor D n).Additive\ninst✝⁵ : CategoryTheory.Pretriangulated C\ninst✝⁴ : CategoryTheory.Pretriangulated D\nF₁ F₂ : CategoryTheory.Functor C D\ne : CategoryTheory.Iso F₁ F₂\ninst✝³ : F₁.CommShift Int\ninst✝² : F₂.CommShift Int\ninst✝¹ : CategoryTheory.NatTrans.CommShift e.hom Int\ninst✝ : F₁.IsTriangulated\n⊢ F₂.IsTriangulated","decl":"lemma isTriangulated_of_iso {F₁ F₂ : C ⥤ D} (e : F₁ ≅ F₂) [F₁.CommShift ℤ] [F₂.CommShift ℤ]\n    [NatTrans.CommShift e.hom ℤ] [F₁.IsTriangulated] : F₂.IsTriangulated where\n  map_distinguished T hT :=\n    isomorphic_distinguished _ (F₁.map_distinguished T hT) _ ((mapTriangleIso e).app T).symm\n\n"}
{"name":"CategoryTheory.Functor.isTriangulated_iff_of_iso","module":"Mathlib.CategoryTheory.Triangulated.Functor","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝¹⁴ : CategoryTheory.Category.{u_4, u_1} C\ninst✝¹³ : CategoryTheory.Category.{u_5, u_2} D\ninst✝¹² : CategoryTheory.HasShift C Int\ninst✝¹¹ : CategoryTheory.HasShift D Int\ninst✝¹⁰ : CategoryTheory.Limits.HasZeroObject C\ninst✝⁹ : CategoryTheory.Limits.HasZeroObject D\ninst✝⁸ : CategoryTheory.Preadditive C\ninst✝⁷ : CategoryTheory.Preadditive D\ninst✝⁶ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\ninst✝⁵ : ∀ (n : Int), (CategoryTheory.shiftFunctor D n).Additive\ninst✝⁴ : CategoryTheory.Pretriangulated C\ninst✝³ : CategoryTheory.Pretriangulated D\nF₁ F₂ : CategoryTheory.Functor C D\ne : CategoryTheory.Iso F₁ F₂\ninst✝² : F₁.CommShift Int\ninst✝¹ : F₂.CommShift Int\ninst✝ : CategoryTheory.NatTrans.CommShift e.hom Int\n⊢ Iff F₁.IsTriangulated F₂.IsTriangulated","decl":"lemma isTriangulated_iff_of_iso {F₁ F₂ : C ⥤ D} (e : F₁ ≅ F₂) [F₁.CommShift ℤ] [F₂.CommShift ℤ]\n    [NatTrans.CommShift e.hom ℤ] : F₁.IsTriangulated ↔ F₂.IsTriangulated := by\n  constructor\n  · intro\n    exact isTriangulated_of_iso e\n  · intro\n    have : NatTrans.CommShift e.symm.hom ℤ := inferInstanceAs (NatTrans.CommShift e.inv ℤ)\n    exact isTriangulated_of_iso e.symm\n\n"}
{"name":"CategoryTheory.Functor.mem_mapTriangle_essImage_of_distinguished","module":"Mathlib.CategoryTheory.Triangulated.Functor","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝¹⁴ : CategoryTheory.Category.{u_4, u_1} C\ninst✝¹³ : CategoryTheory.Category.{u_5, u_2} D\ninst✝¹² : CategoryTheory.HasShift C Int\ninst✝¹¹ : CategoryTheory.HasShift D Int\nF : CategoryTheory.Functor C D\ninst✝¹⁰ : F.CommShift Int\ninst✝⁹ : CategoryTheory.Limits.HasZeroObject C\ninst✝⁸ : CategoryTheory.Limits.HasZeroObject D\ninst✝⁷ : CategoryTheory.Preadditive C\ninst✝⁶ : CategoryTheory.Preadditive D\ninst✝⁵ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\ninst✝⁴ : ∀ (n : Int), (CategoryTheory.shiftFunctor D n).Additive\ninst✝³ : CategoryTheory.Pretriangulated C\ninst✝² : CategoryTheory.Pretriangulated D\ninst✝¹ : F.IsTriangulated\ninst✝ : F.mapArrow.EssSurj\nT : CategoryTheory.Pretriangulated.Triangle D\nhT : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T\n⊢ Exists fun T' => Exists fun x => Nonempty (CategoryTheory.Iso (F.mapTriangle.obj T') T)","decl":"lemma mem_mapTriangle_essImage_of_distinguished\n    [F.IsTriangulated] [F.mapArrow.EssSurj] (T : Triangle D) (hT : T ∈ distTriang D) :\n    ∃ (T' : Triangle C) (_ : T' ∈ distTriang C), Nonempty (F.mapTriangle.obj T' ≅ T) := by\n  obtain ⟨X, Y, f, e₁, e₂, w⟩ : ∃ (X Y : C) (f : X ⟶ Y) (e₁ : F.obj X ≅ T.obj₁)\n    (e₂ : F.obj Y ≅ T.obj₂), F.map f ≫ e₂.hom = e₁.hom ≫ T.mor₁ := by\n      let e := F.mapArrow.objObjPreimageIso (Arrow.mk T.mor₁)\n      exact ⟨_, _, _, Arrow.leftFunc.mapIso e, Arrow.rightFunc.mapIso e, e.hom.w.symm⟩\n  obtain ⟨W, g, h, H⟩ := distinguished_cocone_triangle f\n  exact ⟨_, H, ⟨isoTriangleOfIso₁₂ _ _ (F.map_distinguished _ H) hT e₁ e₂ w⟩⟩\n\n"}
{"name":"CategoryTheory.Functor.isTriangulated_of_precomp","module":"Mathlib.CategoryTheory.Triangulated.Functor","initialProofState":"C : Type u_1\nD : Type u_2\nE : Type u_3\ninst✝²² : CategoryTheory.Category.{u_4, u_1} C\ninst✝²¹ : CategoryTheory.Category.{u_6, u_2} D\ninst✝²⁰ : CategoryTheory.Category.{u_5, u_3} E\ninst✝¹⁹ : CategoryTheory.HasShift C Int\ninst✝¹⁸ : CategoryTheory.HasShift D Int\ninst✝¹⁷ : CategoryTheory.HasShift E Int\nF : CategoryTheory.Functor C D\ninst✝¹⁶ : F.CommShift Int\nG : CategoryTheory.Functor D E\ninst✝¹⁵ : G.CommShift Int\ninst✝¹⁴ : CategoryTheory.Limits.HasZeroObject C\ninst✝¹³ : CategoryTheory.Limits.HasZeroObject D\ninst✝¹² : CategoryTheory.Limits.HasZeroObject E\ninst✝¹¹ : CategoryTheory.Preadditive C\ninst✝¹⁰ : CategoryTheory.Preadditive D\ninst✝⁹ : CategoryTheory.Preadditive E\ninst✝⁸ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\ninst✝⁷ : ∀ (n : Int), (CategoryTheory.shiftFunctor D n).Additive\ninst✝⁶ : ∀ (n : Int), (CategoryTheory.shiftFunctor E n).Additive\ninst✝⁵ : CategoryTheory.Pretriangulated C\ninst✝⁴ : CategoryTheory.Pretriangulated D\ninst✝³ : CategoryTheory.Pretriangulated E\ninst✝² : (F.comp G).IsTriangulated\ninst✝¹ : F.IsTriangulated\ninst✝ : F.mapArrow.EssSurj\n⊢ G.IsTriangulated","decl":"lemma isTriangulated_of_precomp\n    [(F ⋙ G).IsTriangulated] [F.IsTriangulated] [F.mapArrow.EssSurj] :\n    G.IsTriangulated where\n  map_distinguished T hT := by\n    obtain ⟨T', hT', ⟨e⟩⟩ := F.mem_mapTriangle_essImage_of_distinguished T hT\n    exact isomorphic_distinguished _ ((F ⋙ G).map_distinguished T' hT') _\n      (G.mapTriangle.mapIso e.symm ≪≫ (mapTriangleCompIso F G).symm.app _)\n\n"}
{"name":"CategoryTheory.Functor.isTriangulated_of_precomp_iso","module":"Mathlib.CategoryTheory.Triangulated.Functor","initialProofState":"C : Type u_1\nD : Type u_2\nE : Type u_3\ninst✝²⁴ : CategoryTheory.Category.{u_4, u_1} C\ninst✝²³ : CategoryTheory.Category.{u_6, u_2} D\ninst✝²² : CategoryTheory.Category.{u_5, u_3} E\ninst✝²¹ : CategoryTheory.HasShift C Int\ninst✝²⁰ : CategoryTheory.HasShift D Int\ninst✝¹⁹ : CategoryTheory.HasShift E Int\nF : CategoryTheory.Functor C D\ninst✝¹⁸ : F.CommShift Int\nG : CategoryTheory.Functor D E\ninst✝¹⁷ : G.CommShift Int\ninst✝¹⁶ : CategoryTheory.Limits.HasZeroObject C\ninst✝¹⁵ : CategoryTheory.Limits.HasZeroObject D\ninst✝¹⁴ : CategoryTheory.Limits.HasZeroObject E\ninst✝¹³ : CategoryTheory.Preadditive C\ninst✝¹² : CategoryTheory.Preadditive D\ninst✝¹¹ : CategoryTheory.Preadditive E\ninst✝¹⁰ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\ninst✝⁹ : ∀ (n : Int), (CategoryTheory.shiftFunctor D n).Additive\ninst✝⁸ : ∀ (n : Int), (CategoryTheory.shiftFunctor E n).Additive\ninst✝⁷ : CategoryTheory.Pretriangulated C\ninst✝⁶ : CategoryTheory.Pretriangulated D\ninst✝⁵ : CategoryTheory.Pretriangulated E\nH : CategoryTheory.Functor C E\ne : CategoryTheory.Iso (F.comp G) H\ninst✝⁴ : H.CommShift Int\ninst✝³ : H.IsTriangulated\ninst✝² : F.IsTriangulated\ninst✝¹ : F.mapArrow.EssSurj\ninst✝ : CategoryTheory.NatTrans.CommShift e.hom Int\n⊢ G.IsTriangulated","decl":"variable {F G} in\nlemma isTriangulated_of_precomp_iso {H : C ⥤ E} (e : F ⋙ G ≅ H) [H.CommShift ℤ]\n    [H.IsTriangulated] [F.IsTriangulated] [F.mapArrow.EssSurj] [NatTrans.CommShift e.hom ℤ] :\n    G.IsTriangulated := by\n  have := (isTriangulated_iff_of_iso e).2 inferInstance\n  exact isTriangulated_of_precomp F G\n\n"}
{"name":"CategoryTheory.Triangulated.Octahedron.map_m₁","module":"Mathlib.CategoryTheory.Triangulated.Functor","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝¹³ : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹² : CategoryTheory.Category.{u_4, u_2} D\ninst✝¹¹ : CategoryTheory.HasShift C Int\ninst✝¹⁰ : CategoryTheory.HasShift D Int\ninst✝⁹ : CategoryTheory.Limits.HasZeroObject C\ninst✝⁸ : CategoryTheory.Limits.HasZeroObject D\ninst✝⁷ : CategoryTheory.Preadditive C\ninst✝⁶ : CategoryTheory.Preadditive D\ninst✝⁵ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\ninst✝⁴ : ∀ (n : Int), (CategoryTheory.shiftFunctor D n).Additive\ninst✝³ : CategoryTheory.Pretriangulated C\ninst✝² : CategoryTheory.Pretriangulated D\nX₁ X₂ X₃ Z₁₂ Z₂₃ Z₁₃ : C\nu₁₂ : Quiver.Hom X₁ X₂\nu₂₃ : Quiver.Hom X₂ X₃\nu₁₃ : Quiver.Hom X₁ X₃\ncomm : Eq (CategoryTheory.CategoryStruct.comp u₁₂ u₂₃) u₁₃\nv₁₂ : Quiver.Hom X₂ Z₁₂\nw₁₂ : Quiver.Hom Z₁₂ ((CategoryTheory.shiftFunctor C 1).obj X₁)\nh₁₂ : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles (CategoryTheory.Pretriangulated.Triangle.mk u₁₂ v₁₂ w₁₂)\nv₂₃ : Quiver.Hom X₃ Z₂₃\nw₂₃ : Quiver.Hom Z₂₃ ((CategoryTheory.shiftFunctor C 1).obj X₂)\nh₂₃ : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles (CategoryTheory.Pretriangulated.Triangle.mk u₂₃ v₂₃ w₂₃)\nv₁₃ : Quiver.Hom X₃ Z₁₃\nw₁₃ : Quiver.Hom Z₁₃ ((CategoryTheory.shiftFunctor C 1).obj X₁)\nh₁₃ : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles (CategoryTheory.Pretriangulated.Triangle.mk u₁₃ v₁₃ w₁₃)\nh : CategoryTheory.Triangulated.Octahedron comm h₁₂ h₂₃ h₁₃\nF : CategoryTheory.Functor C D\ninst✝¹ : F.CommShift Int\ninst✝ : F.IsTriangulated\n⊢ Eq (h.map F).m₁ (F.map h.m₁)","decl":"/-- The image of an octahedron by a triangulated functor. -/\n@[simps]\ndef map : Octahedron (by dsimp; rw [← F.map_comp, comm])\n    (F.map_distinguished _ h₁₂) (F.map_distinguished _ h₂₃) (F.map_distinguished _ h₁₃) where\n  m₁ := F.map h.m₁\n  m₃ := F.map h.m₃\n  comm₁ := by simpa using F.congr_map h.comm₁\n  comm₂ := by simpa using F.congr_map h.comm₂ =≫ (F.commShiftIso 1).hom.app X₁\n  comm₃ := by simpa using F.congr_map h.comm₃\n  comm₄ := by simpa using F.congr_map h.comm₄ =≫ (F.commShiftIso 1).hom.app X₂\n  mem := isomorphic_distinguished _ (F.map_distinguished _ h.mem) _\n    (Triangle.isoMk _ _ (Iso.refl _) (Iso.refl _) (Iso.refl _))\n\n"}
{"name":"CategoryTheory.Triangulated.Octahedron.map_m₃","module":"Mathlib.CategoryTheory.Triangulated.Functor","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝¹³ : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹² : CategoryTheory.Category.{u_4, u_2} D\ninst✝¹¹ : CategoryTheory.HasShift C Int\ninst✝¹⁰ : CategoryTheory.HasShift D Int\ninst✝⁹ : CategoryTheory.Limits.HasZeroObject C\ninst✝⁸ : CategoryTheory.Limits.HasZeroObject D\ninst✝⁷ : CategoryTheory.Preadditive C\ninst✝⁶ : CategoryTheory.Preadditive D\ninst✝⁵ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\ninst✝⁴ : ∀ (n : Int), (CategoryTheory.shiftFunctor D n).Additive\ninst✝³ : CategoryTheory.Pretriangulated C\ninst✝² : CategoryTheory.Pretriangulated D\nX₁ X₂ X₃ Z₁₂ Z₂₃ Z₁₃ : C\nu₁₂ : Quiver.Hom X₁ X₂\nu₂₃ : Quiver.Hom X₂ X₃\nu₁₃ : Quiver.Hom X₁ X₃\ncomm : Eq (CategoryTheory.CategoryStruct.comp u₁₂ u₂₃) u₁₃\nv₁₂ : Quiver.Hom X₂ Z₁₂\nw₁₂ : Quiver.Hom Z₁₂ ((CategoryTheory.shiftFunctor C 1).obj X₁)\nh₁₂ : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles (CategoryTheory.Pretriangulated.Triangle.mk u₁₂ v₁₂ w₁₂)\nv₂₃ : Quiver.Hom X₃ Z₂₃\nw₂₃ : Quiver.Hom Z₂₃ ((CategoryTheory.shiftFunctor C 1).obj X₂)\nh₂₃ : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles (CategoryTheory.Pretriangulated.Triangle.mk u₂₃ v₂₃ w₂₃)\nv₁₃ : Quiver.Hom X₃ Z₁₃\nw₁₃ : Quiver.Hom Z₁₃ ((CategoryTheory.shiftFunctor C 1).obj X₁)\nh₁₃ : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles (CategoryTheory.Pretriangulated.Triangle.mk u₁₃ v₁₃ w₁₃)\nh : CategoryTheory.Triangulated.Octahedron comm h₁₂ h₂₃ h₁₃\nF : CategoryTheory.Functor C D\ninst✝¹ : F.CommShift Int\ninst✝ : F.IsTriangulated\n⊢ Eq (h.map F).m₃ (F.map h.m₃)","decl":"/-- The image of an octahedron by a triangulated functor. -/\n@[simps]\ndef map : Octahedron (by dsimp; rw [← F.map_comp, comm])\n    (F.map_distinguished _ h₁₂) (F.map_distinguished _ h₂₃) (F.map_distinguished _ h₁₃) where\n  m₁ := F.map h.m₁\n  m₃ := F.map h.m₃\n  comm₁ := by simpa using F.congr_map h.comm₁\n  comm₂ := by simpa using F.congr_map h.comm₂ =≫ (F.commShiftIso 1).hom.app X₁\n  comm₃ := by simpa using F.congr_map h.comm₃\n  comm₄ := by simpa using F.congr_map h.comm₄ =≫ (F.commShiftIso 1).hom.app X₂\n  mem := isomorphic_distinguished _ (F.map_distinguished _ h.mem) _\n    (Triangle.isoMk _ _ (Iso.refl _) (Iso.refl _) (Iso.refl _))\n\n"}
{"name":"CategoryTheory.isTriangulated_of_essSurj_mapComposableArrows_two","module":"Mathlib.CategoryTheory.Triangulated.Functor","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝¹⁵ : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹⁴ : CategoryTheory.Category.{u_4, u_2} D\ninst✝¹³ : CategoryTheory.HasShift C Int\ninst✝¹² : CategoryTheory.HasShift D Int\ninst✝¹¹ : CategoryTheory.Limits.HasZeroObject C\ninst✝¹⁰ : CategoryTheory.Limits.HasZeroObject D\ninst✝⁹ : CategoryTheory.Preadditive C\ninst✝⁸ : CategoryTheory.Preadditive D\ninst✝⁷ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\ninst✝⁶ : ∀ (n : Int), (CategoryTheory.shiftFunctor D n).Additive\ninst✝⁵ : CategoryTheory.Pretriangulated C\ninst✝⁴ : CategoryTheory.Pretriangulated D\nF : CategoryTheory.Functor C D\ninst✝³ : F.CommShift Int\ninst✝² : F.IsTriangulated\ninst✝¹ : (F.mapComposableArrows 2).EssSurj\ninst✝ : CategoryTheory.IsTriangulated C\n⊢ CategoryTheory.IsTriangulated D","decl":"/-- If `F : C ⥤ D` is a triangulated functor from a triangulated category, then `D`\nis also triangulated if tuples of composables arrows in `D` can be lifted to `C`. -/\nlemma isTriangulated_of_essSurj_mapComposableArrows_two\n    (F : C ⥤ D) [F.CommShift ℤ] [F.IsTriangulated]\n    [(F.mapComposableArrows 2).EssSurj] [IsTriangulated C] :\n    IsTriangulated D := by\n  apply IsTriangulated.mk\n  intro Y₁ Y₂ Y₃ Z₁₂ Z₂₃ Z₁₃ u₁₂ u₂₃ u₁₃ comm v₁₂ w₁₂ h₁₂ v₂₃ w₂₃ h₂₃ v₁₃ w₁₃ h₁₃\n  obtain ⟨α, ⟨e⟩⟩ : ∃ (α : ComposableArrows C 2),\n      Nonempty ((F.mapComposableArrows 2).obj α ≅ ComposableArrows.mk₂ u₁₂ u₂₃) :=\n    ⟨_, ⟨Functor.objObjPreimageIso _ _⟩⟩\n  obtain ⟨X₁, X₂, X₃, f, g, rfl⟩ := ComposableArrows.mk₂_surjective α\n  obtain ⟨_, _, _, h₁₂'⟩ := distinguished_cocone_triangle f\n  obtain ⟨_, _, _, h₂₃'⟩ := distinguished_cocone_triangle g\n  obtain ⟨_, _, _, h₁₃'⟩ := distinguished_cocone_triangle (f ≫ g)\n  exact ⟨Octahedron.ofIso (e₁ := (e.app 0).symm) (e₂ := (e.app 1).symm) (e₃ := (e.app 2).symm)\n    (comm₁₂ := ComposableArrows.naturality' e.inv 0 1)\n    (comm₂₃ := ComposableArrows.naturality' e.inv 1 2)\n    (H := (someOctahedron rfl h₁₂' h₂₃' h₁₃').map F) ..⟩\n\n"}
