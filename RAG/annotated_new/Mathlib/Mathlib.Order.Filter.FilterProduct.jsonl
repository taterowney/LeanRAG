{"name":"Filter.Germ.coe_lt","module":"Mathlib.Order.Filter.FilterProduct","initialProofState":"α : Type u\nβ : Type v\nφ : Ultrafilter α\ninst✝ : Preorder β\nf g : α → β\n⊢ Iff (LT.lt ↑f ↑g) (Filter.Eventually (fun x => LT.lt (f x) (g x)) ↑φ)","decl":"theorem coe_lt [Preorder β] {f g : α → β} : (f : β*) < g ↔ ∀* x, f x < g x := by\n  simp only [lt_iff_le_not_le, eventually_and, coe_le, eventually_not, EventuallyLE]\n\n"}
{"name":"Filter.Germ.coe_pos","module":"Mathlib.Order.Filter.FilterProduct","initialProofState":"α : Type u\nβ : Type v\nφ : Ultrafilter α\ninst✝¹ : Preorder β\ninst✝ : Zero β\nf : α → β\n⊢ Iff (LT.lt 0 ↑f) (Filter.Eventually (fun x => LT.lt 0 (f x)) ↑φ)","decl":"theorem coe_pos [Preorder β] [Zero β] {f : α → β} : 0 < (f : β*) ↔ ∀* x, 0 < f x :=\n  coe_lt\n\n"}
{"name":"Filter.Germ.const_lt","module":"Mathlib.Order.Filter.FilterProduct","initialProofState":"α : Type u\nβ : Type v\nφ : Ultrafilter α\ninst✝ : Preorder β\nx y : β\na✝ : LT.lt x y\n⊢ LT.lt ↑x ↑y","decl":"theorem const_lt [Preorder β] {x y : β} : x < y → (↑x : β*) < ↑y :=\n  coe_lt.mpr ∘ liftRel_const\n\n"}
{"name":"Filter.Germ.const_lt_iff","module":"Mathlib.Order.Filter.FilterProduct","initialProofState":"α : Type u\nβ : Type v\nφ : Ultrafilter α\ninst✝ : Preorder β\nx y : β\n⊢ Iff (LT.lt ↑x ↑y) (LT.lt x y)","decl":"@[simp, norm_cast]\ntheorem const_lt_iff [Preorder β] {x y : β} : (↑x : β*) < ↑y ↔ x < y :=\n  coe_lt.trans liftRel_const_iff\n\n"}
{"name":"Filter.Germ.lt_def","module":"Mathlib.Order.Filter.FilterProduct","initialProofState":"α : Type u\nβ : Type v\nφ : Ultrafilter α\ninst✝ : Preorder β\n⊢ Eq (fun x1 x2 => LT.lt x1 x2) (Filter.Germ.LiftRel fun x1 x2 => LT.lt x1 x2)","decl":"theorem lt_def [Preorder β] : ((· < ·) : β* → β* → Prop) = LiftRel (· < ·) := by\n  ext ⟨f⟩ ⟨g⟩\n  exact coe_lt\n\n"}
{"name":"Filter.Germ.isTotal","module":"Mathlib.Order.Filter.FilterProduct","initialProofState":"α : Type u\nβ : Type v\nφ : Ultrafilter α\ninst✝¹ : LE β\ninst✝ : IsTotal β fun x1 x2 => LE.le x1 x2\n⊢ IsTotal ((↑φ).Germ β) fun x1 x2 => LE.le x1 x2","decl":"instance isTotal [LE β] [IsTotal β (· ≤ ·)] : IsTotal β* (· ≤ ·) :=\n  ⟨fun f g =>\n    inductionOn₂ f g fun _f _g => eventually_or.1 <| Eventually.of_forall fun _x => total_of _ _ _⟩\n\n"}
{"name":"Filter.Germ.max_def","module":"Mathlib.Order.Filter.FilterProduct","initialProofState":"α : Type u\nβ : Type v\nφ : Ultrafilter α\ninst✝ : LinearOrder β\nx y : (↑φ).Germ β\n⊢ Eq (Max.max x y) (Filter.Germ.map₂ Max.max x y)","decl":"theorem max_def [LinearOrder β] (x y : β*) : max x y = map₂ max x y :=\n  inductionOn₂ x y fun a b => by\n    rcases le_total (a : β*) b with h | h\n    · rw [max_eq_right h, map₂_coe, coe_eq]\n      exact h.mono fun i hi => (max_eq_right hi).symm\n    · rw [max_eq_left h, map₂_coe, coe_eq]\n      exact h.mono fun i hi => (max_eq_left hi).symm\n\n"}
{"name":"Filter.Germ.min_def","module":"Mathlib.Order.Filter.FilterProduct","initialProofState":"α : Type u\nβ : Type v\nφ : Ultrafilter α\nK : LinearOrder β\nx y : (↑φ).Germ β\n⊢ Eq (Min.min x y) (Filter.Germ.map₂ Min.min x y)","decl":"theorem min_def [K : LinearOrder β] (x y : β*) : min x y = map₂ min x y :=\n  inductionOn₂ x y fun a b => by\n    rcases le_total (a : β*) b with h | h\n    · rw [min_eq_left h, map₂_coe, coe_eq]\n      exact h.mono fun i hi => (min_eq_left hi).symm\n    · rw [min_eq_right h, map₂_coe, coe_eq]\n      exact h.mono fun i hi => (min_eq_right hi).symm\n\n"}
{"name":"Filter.Germ.abs_def","module":"Mathlib.Order.Filter.FilterProduct","initialProofState":"α : Type u\nβ : Type v\nφ : Ultrafilter α\ninst✝ : LinearOrderedAddCommGroup β\nx : (↑φ).Germ β\n⊢ Eq (abs x) (Filter.Germ.map abs x)","decl":"theorem abs_def [LinearOrderedAddCommGroup β] (x : β*) : |x| = map abs x :=\n  inductionOn x fun _a => rfl\n\n"}
{"name":"Filter.Germ.const_max","module":"Mathlib.Order.Filter.FilterProduct","initialProofState":"α : Type u\nβ : Type v\nφ : Ultrafilter α\ninst✝ : LinearOrder β\nx y : β\n⊢ Eq (↑(Max.max x y)) (Max.max ↑x ↑y)","decl":"@[simp]\ntheorem const_max [LinearOrder β] (x y : β) : (↑(max x y : β) : β*) = max ↑x ↑y := by\n  rw [max_def, map₂_const]\n\n"}
{"name":"Filter.Germ.const_min","module":"Mathlib.Order.Filter.FilterProduct","initialProofState":"α : Type u\nβ : Type v\nφ : Ultrafilter α\ninst✝ : LinearOrder β\nx y : β\n⊢ Eq (↑(Min.min x y)) (Min.min ↑x ↑y)","decl":"@[simp]\ntheorem const_min [LinearOrder β] (x y : β) : (↑(min x y : β) : β*) = min ↑x ↑y := by\n  rw [min_def, map₂_const]\n\n"}
{"name":"Filter.Germ.const_abs","module":"Mathlib.Order.Filter.FilterProduct","initialProofState":"α : Type u\nβ : Type v\nφ : Ultrafilter α\ninst✝ : LinearOrderedAddCommGroup β\nx : β\n⊢ Eq (↑(abs x)) (abs ↑x)","decl":"@[simp]\ntheorem const_abs [LinearOrderedAddCommGroup β] (x : β) : (↑|x| : β*) = |↑x| := by\n  rw [abs_def, map_const]\n\n"}
