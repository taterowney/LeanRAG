{"name":"Filter.const_eventuallyEq'","module":"Mathlib.Order.Filter.Germ.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nl : Filter α\ninst✝ : l.NeBot\na b : β\n⊢ Iff (Filter.Eventually (fun x => Eq a b) l) (Eq a b)","decl":"theorem const_eventuallyEq' [NeBot l] {a b : β} : (∀ᶠ _ in l, a = b) ↔ a = b :=\n  eventually_const\n\n"}
{"name":"Filter.const_eventuallyEq","module":"Mathlib.Order.Filter.Germ.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nl : Filter α\ninst✝ : l.NeBot\na b : β\n⊢ Iff (l.EventuallyEq (fun x => a) fun x => b) (Eq a b)","decl":"theorem const_eventuallyEq [NeBot l] {a b : β} : ((fun _ => a) =ᶠ[l] fun _ => b) ↔ a = b :=\n  @const_eventuallyEq' _ _ _ _ a b\n\n"}
{"name":"Filter.Germ.isConstant_coe","module":"Mathlib.Order.Filter.Germ.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nl : Filter α\nb : β\nh : ∀ (x' : α), Eq (f x') b\n⊢ (↑f).IsConstant","decl":"theorem isConstant_coe {l : Filter α} {b} (h : ∀ x', f x' = b) : (↑f : Germ l β).IsConstant :=\n  ⟨b, Eventually.of_forall h⟩\n\n"}
{"name":"Filter.Germ.isConstant_coe_const","module":"Mathlib.Order.Filter.Germ.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nl : Filter α\nb : β\n⊢ (↑fun x => b).IsConstant","decl":"@[simp]\ntheorem isConstant_coe_const {l : Filter α} {b : β} : (fun _ : α ↦ b : Germ l β).IsConstant := by\n  use b\n\n"}
{"name":"Filter.Germ.isConstant_comp","module":"Mathlib.Order.Filter.Germ.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nl : Filter α\nf : α → β\ng : β → γ\nh : (↑f).IsConstant\n⊢ (↑(Function.comp g f)).IsConstant","decl":"/-- If `f : α → β` is constant w.r.t. `l` and `g : β → γ`, then `g ∘ f : α → γ` also is. -/\nlemma isConstant_comp {l : Filter α} {f : α → β} {g : β → γ}\n    (h : (f : Germ l β).IsConstant) : ((g ∘ f) : Germ l γ).IsConstant := by\n  obtain ⟨b, hb⟩ := h\n  exact ⟨g b, hb.fun_comp g⟩\n\n"}
{"name":"Filter.Germ.quot_mk_eq_coe","module":"Mathlib.Order.Filter.Germ.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nl : Filter α\nf : α → β\n⊢ Eq (Quot.mk (⇑(l.germSetoid β)) f) ↑f","decl":"@[simp]\ntheorem quot_mk_eq_coe (l : Filter α) (f : α → β) : Quot.mk _ f = (f : Germ l β) :=\n  rfl\n\n"}
{"name":"Filter.Germ.mk'_eq_coe","module":"Mathlib.Order.Filter.Germ.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nl : Filter α\nf : α → β\n⊢ Eq (Quotient.mk' f) ↑f","decl":"@[simp]\ntheorem mk'_eq_coe (l : Filter α) (f : α → β) :\n    @Quotient.mk' _ (germSetoid _ _) f = (f : Germ l β) :=\n  rfl\n\n"}
{"name":"Filter.Germ.inductionOn","module":"Mathlib.Order.Filter.Germ.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nl : Filter α\nf : l.Germ β\np : l.Germ β → Prop\nh : ∀ (f : α → β), p ↑f\n⊢ p f","decl":"@[elab_as_elim]\ntheorem inductionOn (f : Germ l β) {p : Germ l β → Prop} (h : ∀ f : α → β, p f) : p f :=\n  Quotient.inductionOn' f h\n\n"}
{"name":"Filter.Germ.inductionOn₂","module":"Mathlib.Order.Filter.Germ.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nl : Filter α\nf : l.Germ β\ng : l.Germ γ\np : l.Germ β → l.Germ γ → Prop\nh : ∀ (f : α → β) (g : α → γ), p ↑f ↑g\n⊢ p f g","decl":"@[elab_as_elim]\ntheorem inductionOn₂ (f : Germ l β) (g : Germ l γ) {p : Germ l β → Germ l γ → Prop}\n    (h : ∀ (f : α → β) (g : α → γ), p f g) : p f g :=\n  Quotient.inductionOn₂' f g h\n\n"}
{"name":"Filter.Germ.inductionOn₃","module":"Mathlib.Order.Filter.Germ.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nδ : Type u_4\nl : Filter α\nf : l.Germ β\ng : l.Germ γ\nh : l.Germ δ\np : l.Germ β → l.Germ γ → l.Germ δ → Prop\nH : ∀ (f : α → β) (g : α → γ) (h : α → δ), p ↑f ↑g ↑h\n⊢ p f g h","decl":"@[elab_as_elim]\ntheorem inductionOn₃ (f : Germ l β) (g : Germ l γ) (h : Germ l δ)\n    {p : Germ l β → Germ l γ → Germ l δ → Prop}\n    (H : ∀ (f : α → β) (g : α → γ) (h : α → δ), p f g h) : p f g h :=\n  Quotient.inductionOn₃' f g h H\n\n"}
{"name":"Filter.Germ.map'_coe","module":"Mathlib.Order.Filter.Germ.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nδ : Type u_4\nl : Filter α\nlc : Filter γ\nF : (α → β) → γ → δ\nhF : Relator.LiftFun l.EventuallyEq lc.EventuallyEq F F\nf : α → β\n⊢ Eq (Filter.Germ.map' F hF ↑f) ↑(F f)","decl":"@[simp]\ntheorem map'_coe {lc : Filter γ} (F : (α → β) → γ → δ) (hF : (l.EventuallyEq ⇒ lc.EventuallyEq) F F)\n    (f : α → β) : map' F hF f = F f :=\n  rfl\n\n"}
{"name":"Filter.Germ.coe_eq","module":"Mathlib.Order.Filter.Germ.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nl : Filter α\nf g : α → β\n⊢ Iff (Eq ↑f ↑g) (l.EventuallyEq f g)","decl":"@[simp, norm_cast]\ntheorem coe_eq : (f : Germ l β) = g ↔ f =ᶠ[l] g :=\n  Quotient.eq''\n\n"}
{"name":"Filter.EventuallyEq.germ_eq","module":"Mathlib.Order.Filter.Germ.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nl : Filter α\nf g : α → β\na✝ : l.EventuallyEq f g\n⊢ Eq ↑f ↑g","decl":"alias ⟨_, _root_.Filter.EventuallyEq.germ_eq⟩ := coe_eq\n\n"}
{"name":"Filter.Germ.map_coe","module":"Mathlib.Order.Filter.Germ.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nl : Filter α\nop : β → γ\nf : α → β\n⊢ Eq (Filter.Germ.map op ↑f) ↑(Function.comp op f)","decl":"@[simp]\ntheorem map_coe (op : β → γ) (f : α → β) : map op (f : Germ l β) = op ∘ f :=\n  rfl\n\n"}
{"name":"Filter.Germ.map_id","module":"Mathlib.Order.Filter.Germ.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nl : Filter α\n⊢ Eq (Filter.Germ.map id) id","decl":"@[simp]\ntheorem map_id : map id = (id : Germ l β → Germ l β) := by\n  ext ⟨f⟩\n  rfl\n\n"}
{"name":"Filter.Germ.map_map","module":"Mathlib.Order.Filter.Germ.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nδ : Type u_4\nl : Filter α\nop₁ : γ → δ\nop₂ : β → γ\nf : l.Germ β\n⊢ Eq (Filter.Germ.map op₁ (Filter.Germ.map op₂ f)) (Filter.Germ.map (Function.comp op₁ op₂) f)","decl":"theorem map_map (op₁ : γ → δ) (op₂ : β → γ) (f : Germ l β) :\n    map op₁ (map op₂ f) = map (op₁ ∘ op₂) f :=\n  inductionOn f fun _ => rfl\n\n"}
{"name":"Filter.Germ.map₂_coe","module":"Mathlib.Order.Filter.Germ.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nδ : Type u_4\nl : Filter α\nop : β → γ → δ\nf : α → β\ng : α → γ\n⊢ Eq (Filter.Germ.map₂ op ↑f ↑g) ↑fun x => op (f x) (g x)","decl":"@[simp]\ntheorem map₂_coe (op : β → γ → δ) (f : α → β) (g : α → γ) :\n    map₂ op (f : Germ l β) g = fun x => op (f x) (g x) :=\n  rfl\n\n"}
{"name":"Filter.Germ.coe_tendsto","module":"Mathlib.Order.Filter.Germ.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nl : Filter α\nf : α → β\nlb : Filter β\n⊢ Iff ((↑f).Tendsto lb) (Filter.Tendsto f l lb)","decl":"@[simp, norm_cast]\ntheorem coe_tendsto {f : α → β} {lb : Filter β} : (f : Germ l β).Tendsto lb ↔ Tendsto f l lb :=\n  Iff.rfl\n\n"}
{"name":"Filter.Tendsto.germ_tendsto","module":"Mathlib.Order.Filter.Germ.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nl : Filter α\nf : α → β\nlb : Filter β\na✝ : Filter.Tendsto f l lb\n⊢ (↑f).Tendsto lb","decl":"alias ⟨_, _root_.Filter.Tendsto.germ_tendsto⟩ := coe_tendsto\n\n"}
{"name":"Filter.Germ.coe_compTendsto'","module":"Mathlib.Order.Filter.Germ.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nl : Filter α\nf : α → β\nlc : Filter γ\ng : lc.Germ α\nhg : g.Tendsto l\n⊢ Eq ((↑f).compTendsto' g hg) (Filter.Germ.map f g)","decl":"@[simp]\ntheorem coe_compTendsto' (f : α → β) {lc : Filter γ} {g : Germ lc α} (hg : g.Tendsto l) :\n    (f : Germ l β).compTendsto' g hg = g.map f :=\n  rfl\n\n"}
{"name":"Filter.Germ.coe_compTendsto","module":"Mathlib.Order.Filter.Germ.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nl : Filter α\nf : α → β\nlc : Filter γ\ng : γ → α\nhg : Filter.Tendsto g lc l\n⊢ Eq ((↑f).compTendsto g hg) ↑(Function.comp f g)","decl":"@[simp]\ntheorem coe_compTendsto (f : α → β) {lc : Filter γ} {g : γ → α} (hg : Tendsto g lc l) :\n    (f : Germ l β).compTendsto g hg = f ∘ g :=\n  rfl\n\n-- Porting note https://github.com/leanprover-community/mathlib4/issues/10959\n-- simp can't match the LHS.\n"}
{"name":"Filter.Germ.compTendsto'_coe","module":"Mathlib.Order.Filter.Germ.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nl : Filter α\nf : l.Germ β\nlc : Filter γ\ng : γ → α\nhg : Filter.Tendsto g lc l\n⊢ Eq (f.compTendsto' ↑g ⋯) (f.compTendsto g hg)","decl":"@[simp, nolint simpNF]\ntheorem compTendsto'_coe (f : Germ l β) {lc : Filter γ} {g : γ → α} (hg : Tendsto g lc l) :\n    f.compTendsto' _ hg.germ_tendsto = f.compTendsto g hg :=\n  rfl\n\n"}
{"name":"Filter.Germ.Filter.Tendsto.congr_germ","module":"Mathlib.Order.Filter.Germ.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nf g : β → γ\nl : Filter α\nl' : Filter β\nh : l'.EventuallyEq f g\nφ : α → β\nhφ : Filter.Tendsto φ l l'\n⊢ Eq ↑(Function.comp f φ) ↑(Function.comp g φ)","decl":"theorem Filter.Tendsto.congr_germ {f g : β → γ} {l : Filter α} {l' : Filter β} (h : f =ᶠ[l'] g)\n    {φ : α → β} (hφ : Tendsto φ l l') : (f ∘ φ : Germ l γ) = g ∘ φ :=\n  EventuallyEq.germ_eq (h.comp_tendsto hφ)\n\n"}
{"name":"Filter.Germ.isConstant_comp_tendsto","module":"Mathlib.Order.Filter.Germ.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nl : Filter α\nf : α → β\nlc : Filter γ\ng : γ → α\nhf : (↑f).IsConstant\nhg : Filter.Tendsto g lc l\n⊢ (↑(Function.comp f g)).IsConstant","decl":"lemma isConstant_comp_tendsto {lc : Filter γ} {g : γ → α}\n    (hf : (f : Germ l β).IsConstant) (hg : Tendsto g lc l) : IsConstant (f ∘ g : Germ lc β) := by\n  rcases hf with ⟨b, hb⟩\n  exact ⟨b, hb.comp_tendsto hg⟩\n\n"}
{"name":"Filter.Germ.isConstant_compTendsto","module":"Mathlib.Order.Filter.Germ.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nl : Filter α\nf : l.Germ β\nlc : Filter γ\ng : γ → α\nhf : f.IsConstant\nhg : Filter.Tendsto g lc l\n⊢ (f.compTendsto g hg).IsConstant","decl":"/-- If a germ `f : Germ l β` is constant, where `l : Filter α`,\nand a function `g : γ → α` tends to `l` along `lc : Filter γ`,\nthe germ of the composition `f ∘ g` is also constant. -/\nlemma isConstant_compTendsto {f : Germ l β} {lc : Filter γ} {g : γ → α}\n    (hf : f.IsConstant) (hg : Tendsto g lc l) : (f.compTendsto g hg).IsConstant := by\n  induction f using Quotient.inductionOn with | _ f => ?_\n  exact isConstant_comp_tendsto hf hg\n\n"}
{"name":"Filter.Germ.const_inj","module":"Mathlib.Order.Filter.Germ.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nl : Filter α\ninst✝ : l.NeBot\na b : β\n⊢ Iff (Eq ↑a ↑b) (Eq a b)","decl":"@[simp, norm_cast]\ntheorem const_inj [NeBot l] {a b : β} : (↑a : Germ l β) = ↑b ↔ a = b :=\n  coe_eq.trans const_eventuallyEq\n\n"}
{"name":"Filter.Germ.map_const","module":"Mathlib.Order.Filter.Germ.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nl : Filter α\na : β\nf : β → γ\n⊢ Eq (Filter.Germ.map f ↑a) ↑(f a)","decl":"@[simp]\ntheorem map_const (l : Filter α) (a : β) (f : β → γ) : (↑a : Germ l β).map f = ↑(f a) :=\n  rfl\n\n"}
{"name":"Filter.Germ.map₂_const","module":"Mathlib.Order.Filter.Germ.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nδ : Type u_4\nl : Filter α\nb : β\nc : γ\nf : β → γ → δ\n⊢ Eq (Filter.Germ.map₂ f ↑b ↑c) ↑(f b c)","decl":"@[simp]\ntheorem map₂_const (l : Filter α) (b : β) (c : γ) (f : β → γ → δ) :\n    map₂ f (↑b : Germ l β) ↑c = ↑(f b c) :=\n  rfl\n\n"}
{"name":"Filter.Germ.const_compTendsto","module":"Mathlib.Order.Filter.Germ.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nl : Filter α\nb : β\nlc : Filter γ\ng : γ → α\nhg : Filter.Tendsto g lc l\n⊢ Eq ((↑b).compTendsto g hg) ↑b","decl":"@[simp]\ntheorem const_compTendsto {l : Filter α} (b : β) {lc : Filter γ} {g : γ → α} (hg : Tendsto g lc l) :\n    (↑b : Germ l β).compTendsto g hg = ↑b :=\n  rfl\n\n"}
{"name":"Filter.Germ.const_compTendsto'","module":"Mathlib.Order.Filter.Germ.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nl : Filter α\nb : β\nlc : Filter γ\ng : lc.Germ α\nhg : g.Tendsto l\n⊢ Eq ((↑b).compTendsto' g hg) ↑b","decl":"@[simp]\ntheorem const_compTendsto' {l : Filter α} (b : β) {lc : Filter γ} {g : Germ lc α}\n    (hg : g.Tendsto l) : (↑b : Germ l β).compTendsto' g hg = ↑b :=\n  inductionOn g (fun _ _ => rfl) hg\n\n"}
{"name":"Filter.Germ.liftPred_coe","module":"Mathlib.Order.Filter.Germ.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nl : Filter α\np : β → Prop\nf : α → β\n⊢ Iff (Filter.Germ.LiftPred p ↑f) (Filter.Eventually (fun x => p (f x)) l)","decl":"@[simp]\ntheorem liftPred_coe {p : β → Prop} {f : α → β} : LiftPred p (f : Germ l β) ↔ ∀ᶠ x in l, p (f x) :=\n  Iff.rfl\n\n"}
{"name":"Filter.Germ.liftPred_const","module":"Mathlib.Order.Filter.Germ.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nl : Filter α\np : β → Prop\nx : β\nhx : p x\n⊢ Filter.Germ.LiftPred p ↑x","decl":"theorem liftPred_const {p : β → Prop} {x : β} (hx : p x) : LiftPred p (↑x : Germ l β) :=\n  Eventually.of_forall fun _y => hx\n\n"}
{"name":"Filter.Germ.liftPred_const_iff","module":"Mathlib.Order.Filter.Germ.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nl : Filter α\ninst✝ : l.NeBot\np : β → Prop\nx : β\n⊢ Iff (Filter.Germ.LiftPred p ↑x) (p x)","decl":"@[simp]\ntheorem liftPred_const_iff [NeBot l] {p : β → Prop} {x : β} : LiftPred p (↑x : Germ l β) ↔ p x :=\n  @eventually_const _ _ _ (p x)\n\n"}
{"name":"Filter.Germ.liftRel_coe","module":"Mathlib.Order.Filter.Germ.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nl : Filter α\nr : β → γ → Prop\nf : α → β\ng : α → γ\n⊢ Iff (Filter.Germ.LiftRel r ↑f ↑g) (Filter.Eventually (fun x => r (f x) (g x)) l)","decl":"@[simp]\ntheorem liftRel_coe {r : β → γ → Prop} {f : α → β} {g : α → γ} :\n    LiftRel r (f : Germ l β) g ↔ ∀ᶠ x in l, r (f x) (g x) :=\n  Iff.rfl\n\n"}
{"name":"Filter.Germ.liftRel_const","module":"Mathlib.Order.Filter.Germ.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nl : Filter α\nr : β → γ → Prop\nx : β\ny : γ\nh : r x y\n⊢ Filter.Germ.LiftRel r ↑x ↑y","decl":"theorem liftRel_const {r : β → γ → Prop} {x : β} {y : γ} (h : r x y) :\n    LiftRel r (↑x : Germ l β) ↑y :=\n  Eventually.of_forall fun _ => h\n\n"}
{"name":"Filter.Germ.liftRel_const_iff","module":"Mathlib.Order.Filter.Germ.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nl : Filter α\ninst✝ : l.NeBot\nr : β → γ → Prop\nx : β\ny : γ\n⊢ Iff (Filter.Germ.LiftRel r ↑x ↑y) (r x y)","decl":"@[simp]\ntheorem liftRel_const_iff [NeBot l] {r : β → γ → Prop} {x : β} {y : γ} :\n    LiftRel r (↑x : Germ l β) ↑y ↔ r x y :=\n  @eventually_const _ _ _ (r x y)\n\n"}
{"name":"Filter.Germ.coe_mul","module":"Mathlib.Order.Filter.Germ.Basic","initialProofState":"α : Type u_1\nl : Filter α\nM : Type u_5\ninst✝ : Mul M\nf g : α → M\n⊢ Eq (↑(HMul.hMul f g)) (HMul.hMul ↑f ↑g)","decl":"@[to_additive (attr := simp, norm_cast)]\ntheorem coe_mul [Mul M] (f g : α → M) : ↑(f * g) = (f * g : Germ l M) :=\n  rfl\n\n"}
{"name":"Filter.Germ.coe_add","module":"Mathlib.Order.Filter.Germ.Basic","initialProofState":"α : Type u_1\nl : Filter α\nM : Type u_5\ninst✝ : Add M\nf g : α → M\n⊢ Eq (↑(HAdd.hAdd f g)) (HAdd.hAdd ↑f ↑g)","decl":"@[to_additive (attr := simp, norm_cast)]\ntheorem coe_mul [Mul M] (f g : α → M) : ↑(f * g) = (f * g : Germ l M) :=\n  rfl\n\n"}
{"name":"Filter.Germ.coe_zero","module":"Mathlib.Order.Filter.Germ.Basic","initialProofState":"α : Type u_1\nl : Filter α\nM : Type u_5\ninst✝ : Zero M\n⊢ Eq (↑0) 0","decl":"@[to_additive (attr := simp, norm_cast)]\ntheorem coe_one [One M] : ↑(1 : α → M) = (1 : Germ l M) :=\n  rfl\n\n"}
{"name":"Filter.Germ.coe_one","module":"Mathlib.Order.Filter.Germ.Basic","initialProofState":"α : Type u_1\nl : Filter α\nM : Type u_5\ninst✝ : One M\n⊢ Eq (↑1) 1","decl":"@[to_additive (attr := simp, norm_cast)]\ntheorem coe_one [One M] : ↑(1 : α → M) = (1 : Germ l M) :=\n  rfl\n\n"}
{"name":"Filter.Germ.instIsLeftCancelMul","module":"Mathlib.Order.Filter.Germ.Basic","initialProofState":"α : Type u_1\nl : Filter α\nM : Type u_5\ninst✝¹ : Mul M\ninst✝ : IsLeftCancelMul M\n⊢ IsLeftCancelMul (l.Germ M)","decl":"@[to_additive]\ninstance instIsLeftCancelMul [Mul M] [IsLeftCancelMul M] : IsLeftCancelMul (Germ l M) where\n  mul_left_cancel f₁ f₂ f₃ :=\n    inductionOn₃ f₁ f₂ f₃ fun _f₁ _f₂ _f₃ H =>\n      coe_eq.2 ((coe_eq.1 H).mono fun _x => mul_left_cancel)\n\n"}
{"name":"Filter.Germ.instIsAddLeftCancel","module":"Mathlib.Order.Filter.Germ.Basic","initialProofState":"α : Type u_1\nl : Filter α\nM : Type u_5\ninst✝¹ : Add M\ninst✝ : IsLeftCancelAdd M\n⊢ IsLeftCancelAdd (l.Germ M)","decl":"@[to_additive]\ninstance instIsLeftCancelMul [Mul M] [IsLeftCancelMul M] : IsLeftCancelMul (Germ l M) where\n  mul_left_cancel f₁ f₂ f₃ :=\n    inductionOn₃ f₁ f₂ f₃ fun _f₁ _f₂ _f₃ H =>\n      coe_eq.2 ((coe_eq.1 H).mono fun _x => mul_left_cancel)\n\n"}
{"name":"Filter.Germ.instIsAddRightCancel","module":"Mathlib.Order.Filter.Germ.Basic","initialProofState":"α : Type u_1\nl : Filter α\nM : Type u_5\ninst✝¹ : Add M\ninst✝ : IsRightCancelAdd M\n⊢ IsRightCancelAdd (l.Germ M)","decl":"@[to_additive]\ninstance instIsRightCancelMul [Mul M] [IsRightCancelMul M] : IsRightCancelMul (Germ l M) where\n  mul_right_cancel f₁ f₂ f₃ :=\n    inductionOn₃ f₁ f₂ f₃ fun _f₁ _f₂ _f₃ H =>\n      coe_eq.2 <| (coe_eq.1 H).mono fun _x => mul_right_cancel\n\n"}
{"name":"Filter.Germ.instIsRightCancelMul","module":"Mathlib.Order.Filter.Germ.Basic","initialProofState":"α : Type u_1\nl : Filter α\nM : Type u_5\ninst✝¹ : Mul M\ninst✝ : IsRightCancelMul M\n⊢ IsRightCancelMul (l.Germ M)","decl":"@[to_additive]\ninstance instIsRightCancelMul [Mul M] [IsRightCancelMul M] : IsRightCancelMul (Germ l M) where\n  mul_right_cancel f₁ f₂ f₃ :=\n    inductionOn₃ f₁ f₂ f₃ fun _f₁ _f₂ _f₃ H =>\n      coe_eq.2 <| (coe_eq.1 H).mono fun _x => mul_right_cancel\n\n"}
{"name":"Filter.Germ.instIsCancelMul","module":"Mathlib.Order.Filter.Germ.Basic","initialProofState":"α : Type u_1\nl : Filter α\nM : Type u_5\ninst✝¹ : Mul M\ninst✝ : IsCancelMul M\n⊢ IsCancelMul (l.Germ M)","decl":"@[to_additive]\ninstance instIsCancelMul [Mul M] [IsCancelMul M] : IsCancelMul (Germ l M) where\n\n"}
{"name":"Filter.Germ.instIsAddCancel","module":"Mathlib.Order.Filter.Germ.Basic","initialProofState":"α : Type u_1\nl : Filter α\nM : Type u_5\ninst✝¹ : Add M\ninst✝ : IsCancelAdd M\n⊢ IsCancelAdd (l.Germ M)","decl":"@[to_additive]\ninstance instIsCancelMul [Mul M] [IsCancelMul M] : IsCancelMul (Germ l M) where\n\n"}
{"name":"Filter.Germ.coe_vadd","module":"Mathlib.Order.Filter.Germ.Basic","initialProofState":"α : Type u_1\nl : Filter α\nM : Type u_5\nG : Type u_6\ninst✝ : VAdd M G\nn : M\nf : α → G\n⊢ Eq (↑(HVAdd.hVAdd n f)) (HVAdd.hVAdd n ↑f)","decl":"@[to_additive (attr := simp, norm_cast)]\ntheorem coe_smul [SMul M G] (n : M) (f : α → G) : ↑(n • f) = n • (f : Germ l G) :=\n  rfl\n\n"}
{"name":"Filter.Germ.coe_smul","module":"Mathlib.Order.Filter.Germ.Basic","initialProofState":"α : Type u_1\nl : Filter α\nM : Type u_5\nG : Type u_6\ninst✝ : SMul M G\nn : M\nf : α → G\n⊢ Eq (↑(HSMul.hSMul n f)) (HSMul.hSMul n ↑f)","decl":"@[to_additive (attr := simp, norm_cast)]\ntheorem coe_smul [SMul M G] (n : M) (f : α → G) : ↑(n • f) = n • (f : Germ l G) :=\n  rfl\n\n"}
{"name":"Filter.Germ.const_smul","module":"Mathlib.Order.Filter.Germ.Basic","initialProofState":"α : Type u_1\nl : Filter α\nM : Type u_5\nG : Type u_6\ninst✝ : SMul M G\nn : M\na : G\n⊢ Eq (↑(HSMul.hSMul n a)) (HSMul.hSMul n ↑a)","decl":"@[to_additive (attr := simp, norm_cast)]\ntheorem const_smul [SMul M G] (n : M) (a : G) : (↑(n • a) : Germ l G) = n • (↑a : Germ l G) :=\n  rfl\n\n"}
{"name":"Filter.Germ.const_vadd","module":"Mathlib.Order.Filter.Germ.Basic","initialProofState":"α : Type u_1\nl : Filter α\nM : Type u_5\nG : Type u_6\ninst✝ : VAdd M G\nn : M\na : G\n⊢ Eq (↑(HVAdd.hVAdd n a)) (HVAdd.hVAdd n ↑a)","decl":"@[to_additive (attr := simp, norm_cast)]\ntheorem const_smul [SMul M G] (n : M) (a : G) : (↑(n • a) : Germ l G) = n • (↑a : Germ l G) :=\n  rfl\n\n"}
{"name":"Filter.Germ.coe_nsmul","module":"Mathlib.Order.Filter.Germ.Basic","initialProofState":"α : Type u_1\nl : Filter α\nM : Type u_5\nG : Type u_6\ninst✝ : SMul M G\nf : α → G\nn : M\n⊢ Eq (↑(HSMul.hSMul n f)) (HSMul.hSMul n ↑f)","decl":"@[to_additive (attr := simp, norm_cast)]\ntheorem coe_pow [Pow G M] (f : α → G) (n : M) : ↑(f ^ n) = (f : Germ l G) ^ n :=\n  rfl\n\n"}
{"name":"Filter.Germ.coe_pow","module":"Mathlib.Order.Filter.Germ.Basic","initialProofState":"α : Type u_1\nl : Filter α\nM : Type u_5\nG : Type u_6\ninst✝ : Pow G M\nf : α → G\nn : M\n⊢ Eq (↑(HPow.hPow f n)) (HPow.hPow (↑f) n)","decl":"@[to_additive (attr := simp, norm_cast)]\ntheorem coe_pow [Pow G M] (f : α → G) (n : M) : ↑(f ^ n) = (f : Germ l G) ^ n :=\n  rfl\n\n"}
{"name":"Filter.Germ.const_pow","module":"Mathlib.Order.Filter.Germ.Basic","initialProofState":"α : Type u_1\nl : Filter α\nM : Type u_5\nG : Type u_6\ninst✝ : Pow G M\na : G\nn : M\n⊢ Eq (↑(HPow.hPow a n)) (HPow.hPow (↑a) n)","decl":"@[to_additive (attr := simp, norm_cast)]\ntheorem const_pow [Pow G M] (a : G) (n : M) : (↑(a ^ n) : Germ l G) = (↑a : Germ l G) ^ n :=\n  rfl\n\n-- TODO: https://github.com/leanprover-community/mathlib4/pull/7432\n"}
{"name":"Filter.Germ.const_nsmul","module":"Mathlib.Order.Filter.Germ.Basic","initialProofState":"α : Type u_1\nl : Filter α\nM : Type u_5\nG : Type u_6\ninst✝ : SMul M G\na : G\nn : M\n⊢ Eq (↑(HSMul.hSMul n a)) (HSMul.hSMul n ↑a)","decl":"@[to_additive (attr := simp, norm_cast)]\ntheorem const_pow [Pow G M] (a : G) (n : M) : (↑(a ^ n) : Germ l G) = (↑a : Germ l G) ^ n :=\n  rfl\n\n-- TODO: https://github.com/leanprover-community/mathlib4/pull/7432\n"}
{"name":"Filter.Germ.coe_coeAddHom","module":"Mathlib.Order.Filter.Germ.Basic","initialProofState":"α : Type u_1\nl : Filter α\nM : Type u_5\ninst✝ : AddMonoid M\n⊢ Eq (⇑(Filter.Germ.coeAddHom l)) Filter.Germ.ofFun","decl":"@[to_additive (attr := simp)]\ntheorem coe_coeMulHom [Monoid M] : (coeMulHom l : (α → M) → Germ l M) = ofFun :=\n  rfl\n\n"}
{"name":"Filter.Germ.coe_coeMulHom","module":"Mathlib.Order.Filter.Germ.Basic","initialProofState":"α : Type u_1\nl : Filter α\nM : Type u_5\ninst✝ : Monoid M\n⊢ Eq (⇑(Filter.Germ.coeMulHom l)) Filter.Germ.ofFun","decl":"@[to_additive (attr := simp)]\ntheorem coe_coeMulHom [Monoid M] : (coeMulHom l : (α → M) → Germ l M) = ofFun :=\n  rfl\n\n"}
{"name":"Filter.Germ.natCast_def","module":"Mathlib.Order.Filter.Germ.Basic","initialProofState":"α : Type u_1\nl : Filter α\nM : Type u_5\ninst✝ : NatCast M\nn : Nat\n⊢ Eq (↑fun x => ↑n) ↑n","decl":"@[simp]\ntheorem natCast_def [NatCast M] (n : ℕ) : ((fun _ ↦ n : α → M) : Germ l M) = n := rfl\n\n"}
{"name":"Filter.Germ.const_nat","module":"Mathlib.Order.Filter.Germ.Basic","initialProofState":"α : Type u_1\nl : Filter α\nM : Type u_5\ninst✝ : NatCast M\nn : Nat\n⊢ Eq ↑↑n ↑n","decl":"@[simp, norm_cast]\ntheorem const_nat [NatCast M] (n : ℕ) : ((n : M) : Germ l M) = n := rfl\n\n"}
{"name":"Filter.Germ.coe_ofNat","module":"Mathlib.Order.Filter.Germ.Basic","initialProofState":"α : Type u_1\nl : Filter α\nM : Type u_5\ninst✝¹ : NatCast M\nn : Nat\ninst✝ : n.AtLeastTwo\n⊢ Eq (↑(OfNat.ofNat n)) (OfNat.ofNat n)","decl":"@[simp, norm_cast]\ntheorem coe_ofNat [NatCast M] (n : ℕ) [n.AtLeastTwo] :\n    ((ofNat(n) : α → M) : Germ l M) = OfNat.ofNat n :=\n  rfl\n\n"}
{"name":"Filter.Germ.const_ofNat","module":"Mathlib.Order.Filter.Germ.Basic","initialProofState":"α : Type u_1\nl : Filter α\nM : Type u_5\ninst✝¹ : NatCast M\nn : Nat\ninst✝ : n.AtLeastTwo\n⊢ Eq (↑(OfNat.ofNat n)) (OfNat.ofNat n)","decl":"@[simp, norm_cast]\ntheorem const_ofNat [NatCast M] (n : ℕ) [n.AtLeastTwo] :\n    ((ofNat(n) : M) : Germ l M) = OfNat.ofNat n :=\n  rfl\n\n"}
{"name":"Filter.Germ.intCast_def","module":"Mathlib.Order.Filter.Germ.Basic","initialProofState":"α : Type u_1\nl : Filter α\nM : Type u_5\ninst✝ : IntCast M\nn : Int\n⊢ Eq (↑fun x => ↑n) ↑n","decl":"@[simp]\ntheorem intCast_def [IntCast M] (n : ℤ) : ((fun _ ↦ n : α → M) : Germ l M) = n := rfl\n\n"}
{"name":"Filter.Germ.coe_inv","module":"Mathlib.Order.Filter.Germ.Basic","initialProofState":"α : Type u_1\nl : Filter α\nG : Type u_6\ninst✝ : Inv G\nf : α → G\n⊢ Eq (↑(Inv.inv f)) (Inv.inv ↑f)","decl":"@[to_additive (attr := simp, norm_cast)]\ntheorem coe_inv [Inv G] (f : α → G) : ↑f⁻¹ = (f⁻¹ : Germ l G) :=\n  rfl\n\n"}
{"name":"Filter.Germ.coe_neg","module":"Mathlib.Order.Filter.Germ.Basic","initialProofState":"α : Type u_1\nl : Filter α\nG : Type u_6\ninst✝ : Neg G\nf : α → G\n⊢ Eq (↑(Neg.neg f)) (Neg.neg ↑f)","decl":"@[to_additive (attr := simp, norm_cast)]\ntheorem coe_inv [Inv G] (f : α → G) : ↑f⁻¹ = (f⁻¹ : Germ l G) :=\n  rfl\n\n"}
{"name":"Filter.Germ.const_inv","module":"Mathlib.Order.Filter.Germ.Basic","initialProofState":"α : Type u_1\nl : Filter α\nG : Type u_6\ninst✝ : Inv G\na : G\n⊢ Eq (↑(Inv.inv a)) (Inv.inv ↑a)","decl":"@[to_additive (attr := simp, norm_cast)]\ntheorem const_inv [Inv G] (a : G) : (↑(a⁻¹) : Germ l G) = (↑a)⁻¹ :=\n  rfl\n\n"}
{"name":"Filter.Germ.const_neg","module":"Mathlib.Order.Filter.Germ.Basic","initialProofState":"α : Type u_1\nl : Filter α\nG : Type u_6\ninst✝ : Neg G\na : G\n⊢ Eq (↑(Neg.neg a)) (Neg.neg ↑a)","decl":"@[to_additive (attr := simp, norm_cast)]\ntheorem const_inv [Inv G] (a : G) : (↑(a⁻¹) : Germ l G) = (↑a)⁻¹ :=\n  rfl\n\n"}
{"name":"Filter.Germ.coe_div","module":"Mathlib.Order.Filter.Germ.Basic","initialProofState":"α : Type u_1\nl : Filter α\nM : Type u_5\ninst✝ : Div M\nf g : α → M\n⊢ Eq (↑(HDiv.hDiv f g)) (HDiv.hDiv ↑f ↑g)","decl":"@[to_additive (attr := simp, norm_cast)]\ntheorem coe_div [Div M] (f g : α → M) : ↑(f / g) = (f / g : Germ l M) :=\n  rfl\n\n"}
{"name":"Filter.Germ.coe_sub","module":"Mathlib.Order.Filter.Germ.Basic","initialProofState":"α : Type u_1\nl : Filter α\nM : Type u_5\ninst✝ : Sub M\nf g : α → M\n⊢ Eq (↑(HSub.hSub f g)) (HSub.hSub ↑f ↑g)","decl":"@[to_additive (attr := simp, norm_cast)]\ntheorem coe_div [Div M] (f g : α → M) : ↑(f / g) = (f / g : Germ l M) :=\n  rfl\n\n"}
{"name":"Filter.Germ.const_sub","module":"Mathlib.Order.Filter.Germ.Basic","initialProofState":"α : Type u_1\nl : Filter α\nM : Type u_5\ninst✝ : Sub M\na b : M\n⊢ Eq (↑(HSub.hSub a b)) (HSub.hSub ↑a ↑b)","decl":"@[to_additive (attr := simp, norm_cast)]\ntheorem const_div [Div M] (a b : M) : (↑(a / b) : Germ l M) = ↑a / ↑b :=\n  rfl\n\n"}
{"name":"Filter.Germ.const_div","module":"Mathlib.Order.Filter.Germ.Basic","initialProofState":"α : Type u_1\nl : Filter α\nM : Type u_5\ninst✝ : Div M\na b : M\n⊢ Eq (↑(HDiv.hDiv a b)) (HDiv.hDiv ↑a ↑b)","decl":"@[to_additive (attr := simp, norm_cast)]\ntheorem const_div [Div M] (a b : M) : (↑(a / b) : Germ l M) = ↑a / ↑b :=\n  rfl\n\n"}
{"name":"Filter.Germ.instNontrivial","module":"Mathlib.Order.Filter.Germ.Basic","initialProofState":"α : Type u_1\nl : Filter α\nR : Type u_5\ninst✝¹ : Nontrivial R\ninst✝ : l.NeBot\n⊢ Nontrivial (l.Germ R)","decl":"instance instNontrivial [Nontrivial R] [NeBot l] : Nontrivial (Germ l R) :=\n  let ⟨x, y, h⟩ := exists_pair_ne R\n  ⟨⟨↑x, ↑y, mt const_inj.1 h⟩⟩\n\n"}
{"name":"Filter.Germ.coe_coeRingHom","module":"Mathlib.Order.Filter.Germ.Basic","initialProofState":"α : Type u_1\nl : Filter α\nR : Type u_5\ninst✝ : Semiring R\n⊢ Eq (⇑(Filter.Germ.coeRingHom l)) Filter.Germ.ofFun","decl":"@[simp]\ntheorem coe_coeRingHom [Semiring R] : (coeRingHom l : (α → R) → Germ l R) = ofFun :=\n  rfl\n\n"}
{"name":"Filter.Germ.coe_vadd'","module":"Mathlib.Order.Filter.Germ.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nl : Filter α\nM : Type u_5\ninst✝ : VAdd M β\nc : α → M\nf : α → β\n⊢ Eq (↑(HVAdd.hVAdd c f)) (HVAdd.hVAdd ↑c ↑f)","decl":"@[to_additive (attr := simp, norm_cast)]\ntheorem coe_smul' [SMul M β] (c : α → M) (f : α → β) : ↑(c • f) = (c : Germ l M) • (f : Germ l β) :=\n  rfl\n\n"}
{"name":"Filter.Germ.coe_smul'","module":"Mathlib.Order.Filter.Germ.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nl : Filter α\nM : Type u_5\ninst✝ : SMul M β\nc : α → M\nf : α → β\n⊢ Eq (↑(HSMul.hSMul c f)) (HSMul.hSMul ↑c ↑f)","decl":"@[to_additive (attr := simp, norm_cast)]\ntheorem coe_smul' [SMul M β] (c : α → M) (f : α → β) : ↑(c • f) = (c : Germ l M) • (f : Germ l β) :=\n  rfl\n\n"}
{"name":"Filter.Germ.le_def","module":"Mathlib.Order.Filter.Germ.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nl : Filter α\ninst✝ : LE β\n⊢ Eq (fun x1 x2 => LE.le x1 x2) (Filter.Germ.LiftRel fun x1 x2 => LE.le x1 x2)","decl":"theorem le_def [LE β] : ((· ≤ ·) : Germ l β → Germ l β → Prop) = LiftRel (· ≤ ·) :=\n  rfl\n\n"}
{"name":"Filter.Germ.coe_le","module":"Mathlib.Order.Filter.Germ.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nl : Filter α\nf g : α → β\ninst✝ : LE β\n⊢ Iff (LE.le ↑f ↑g) (l.EventuallyLE f g)","decl":"@[simp]\ntheorem coe_le [LE β] : (f : Germ l β) ≤ g ↔ f ≤ᶠ[l] g :=\n  Iff.rfl\n\n"}
{"name":"Filter.Germ.coe_nonneg","module":"Mathlib.Order.Filter.Germ.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nl : Filter α\ninst✝¹ : LE β\ninst✝ : Zero β\nf : α → β\n⊢ Iff (LE.le 0 ↑f) (Filter.Eventually (fun x => LE.le 0 (f x)) l)","decl":"theorem coe_nonneg [LE β] [Zero β] {f : α → β} : 0 ≤ (f : Germ l β) ↔ ∀ᶠ x in l, 0 ≤ f x :=\n  Iff.rfl\n\n"}
{"name":"Filter.Germ.const_le","module":"Mathlib.Order.Filter.Germ.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nl : Filter α\ninst✝ : LE β\nx y : β\na✝ : LE.le x y\n⊢ LE.le ↑x ↑y","decl":"theorem const_le [LE β] {x y : β} : x ≤ y → (↑x : Germ l β) ≤ ↑y :=\n  liftRel_const\n\n"}
{"name":"Filter.Germ.const_le_iff","module":"Mathlib.Order.Filter.Germ.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nl : Filter α\ninst✝¹ : LE β\ninst✝ : l.NeBot\nx y : β\n⊢ Iff (LE.le ↑x ↑y) (LE.le x y)","decl":"@[simp, norm_cast]\ntheorem const_le_iff [LE β] [NeBot l] {x y : β} : (↑x : Germ l β) ≤ ↑y ↔ x ≤ y :=\n  liftRel_const_iff\n\n"}
{"name":"Filter.Germ.const_bot","module":"Mathlib.Order.Filter.Germ.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nl : Filter α\ninst✝ : Bot β\n⊢ Eq (↑Bot.bot) Bot.bot","decl":"@[simp, norm_cast]\ntheorem const_bot [Bot β] : (↑(⊥ : β) : Germ l β) = ⊥ :=\n  rfl\n\n"}
{"name":"Filter.Germ.const_top","module":"Mathlib.Order.Filter.Germ.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nl : Filter α\ninst✝ : Top β\n⊢ Eq (↑Top.top) Top.top","decl":"@[simp, norm_cast]\ntheorem const_top [Top β] : (↑(⊤ : β) : Germ l β) = ⊤ :=\n  rfl\n\n"}
{"name":"Filter.Germ.const_sup","module":"Mathlib.Order.Filter.Germ.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nl : Filter α\ninst✝ : Max β\na b : β\n⊢ Eq (↑(Max.max a b)) (Max.max ↑a ↑b)","decl":"@[simp, norm_cast]\ntheorem const_sup [Max β] (a b : β) : ↑(a ⊔ b) = (↑a ⊔ ↑b : Germ l β) :=\n  rfl\n\n"}
{"name":"Filter.Germ.const_inf","module":"Mathlib.Order.Filter.Germ.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nl : Filter α\ninst✝ : Min β\na b : β\n⊢ Eq (↑(Min.min a b)) (Min.min ↑a ↑b)","decl":"@[simp, norm_cast]\ntheorem const_inf [Min β] (a b : β) : ↑(a ⊓ b) = (↑a ⊓ ↑b : Germ l β) :=\n  rfl\n\n"}
{"name":"Filter.Germ.instExistsAddOfLE","module":"Mathlib.Order.Filter.Germ.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nl : Filter α\ninst✝² : Add β\ninst✝¹ : LE β\ninst✝ : ExistsAddOfLE β\n⊢ ExistsAddOfLE (l.Germ β)","decl":"@[to_additive]\ninstance instExistsMulOfLE [Mul β] [LE β] [ExistsMulOfLE β] : ExistsMulOfLE (Germ l β) where\n  exists_mul_of_le {x y} := inductionOn₂ x y fun f g (h : f ≤ᶠ[l] g) ↦ by\n    classical\n    choose c hc using fun x (hx : f x ≤ g x) ↦ exists_mul_of_le hx\n    refine ⟨ofFun fun x ↦ if hx : f x ≤ g x then c x hx else f x, coe_eq.2 ?_⟩\n    filter_upwards [h] with x hx\n    rw [dif_pos hx, hc]\n\n"}
{"name":"Filter.Germ.instExistsMulOfLE","module":"Mathlib.Order.Filter.Germ.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nl : Filter α\ninst✝² : Mul β\ninst✝¹ : LE β\ninst✝ : ExistsMulOfLE β\n⊢ ExistsMulOfLE (l.Germ β)","decl":"@[to_additive]\ninstance instExistsMulOfLE [Mul β] [LE β] [ExistsMulOfLE β] : ExistsMulOfLE (Germ l β) where\n  exists_mul_of_le {x y} := inductionOn₂ x y fun f g (h : f ≤ᶠ[l] g) ↦ by\n    classical\n    choose c hc using fun x (hx : f x ≤ g x) ↦ exists_mul_of_le hx\n    refine ⟨ofFun fun x ↦ if hx : f x ≤ g x then c x hx else f x, coe_eq.2 ?_⟩\n    filter_upwards [h] with x hx\n    rw [dif_pos hx, hc]\n\n"}
