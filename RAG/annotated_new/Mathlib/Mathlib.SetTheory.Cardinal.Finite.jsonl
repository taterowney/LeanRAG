{"name":"Nat.card_eq_fintype_card","module":"Mathlib.SetTheory.Cardinal.Finite","initialProofState":"α : Type u_1\ninst✝ : Fintype α\n⊢ Eq (Nat.card α) (Fintype.card α)","decl":"@[simp]\ntheorem card_eq_fintype_card [Fintype α] : Nat.card α = Fintype.card α :=\n  mk_toNat_eq_card\n\n"}
{"name":"Fintype.card_eq_nat_card","module":"Mathlib.SetTheory.Cardinal.Finite","initialProofState":"α : Type u_1\nx✝ : Fintype α\n⊢ Eq (Fintype.card α) (Nat.card α)","decl":"/-- Because this theorem takes `Fintype α` as a non-instance argument, it can be used in particular\nwhen `Fintype.card` ends up with different instance than the one found by inference  -/\ntheorem _root_.Fintype.card_eq_nat_card {_ : Fintype α} : Fintype.card α = Nat.card α :=\n  mk_toNat_eq_card.symm\n\n"}
{"name":"Nat.card_eq_finsetCard","module":"Mathlib.SetTheory.Cardinal.Finite","initialProofState":"α : Type u_1\ns : Finset α\n⊢ Eq (Nat.card (Subtype fun x => Membership.mem s x)) s.card","decl":"lemma card_eq_finsetCard (s : Finset α) : Nat.card s = s.card := by\n  simp only [Nat.card_eq_fintype_card, Fintype.card_coe]\n\n"}
{"name":"Nat.card_eq_card_toFinset","module":"Mathlib.SetTheory.Cardinal.Finite","initialProofState":"α : Type u_1\ns : Set α\ninst✝ : Fintype ↑s\n⊢ Eq (Nat.card ↑s) s.toFinset.card","decl":"lemma card_eq_card_toFinset (s : Set α) [Fintype s] : Nat.card s = s.toFinset.card := by\n  simp only [← Nat.card_eq_finsetCard, s.mem_toFinset]\n\n"}
{"name":"Nat.card_eq_card_finite_toFinset","module":"Mathlib.SetTheory.Cardinal.Finite","initialProofState":"α : Type u_1\ns : Set α\nhs : s.Finite\n⊢ Eq (Nat.card ↑s) hs.toFinset.card","decl":"lemma card_eq_card_finite_toFinset {s : Set α} (hs : s.Finite) : Nat.card s = hs.toFinset.card := by\n  simp only [← Nat.card_eq_finsetCard, hs.mem_toFinset]\n\n"}
{"name":"Nat.card_of_isEmpty","module":"Mathlib.SetTheory.Cardinal.Finite","initialProofState":"α : Type u_1\ninst✝ : IsEmpty α\n⊢ Eq (Nat.card α) 0","decl":"@[simp] theorem card_of_isEmpty [IsEmpty α] : Nat.card α = 0 := by simp [Nat.card]\n\n"}
{"name":"Nat.card_eq_zero_of_infinite","module":"Mathlib.SetTheory.Cardinal.Finite","initialProofState":"α : Type u_1\ninst✝ : Infinite α\n⊢ Eq (Nat.card α) 0","decl":"@[simp] lemma card_eq_zero_of_infinite [Infinite α] : Nat.card α = 0 := mk_toNat_of_infinite\n\n"}
{"name":"Nat.cast_card","module":"Mathlib.SetTheory.Cardinal.Finite","initialProofState":"α : Type u_1\ninst✝ : Finite α\n⊢ Eq (↑(Nat.card α)) (Cardinal.mk α)","decl":"lemma cast_card [Finite α] : (Nat.card α : Cardinal) = Cardinal.mk α := by\n  rw [Nat.card, Cardinal.cast_toNat_of_lt_aleph0]\n  exact Cardinal.lt_aleph0_of_finite _\n\n"}
{"name":"Set.Infinite.card_eq_zero","module":"Mathlib.SetTheory.Cardinal.Finite","initialProofState":"α : Type u_1\ns : Set α\nhs : s.Infinite\n⊢ Eq (Nat.card ↑s) 0","decl":"lemma _root_.Set.Infinite.card_eq_zero {s : Set α} (hs : s.Infinite) : Nat.card s = 0 :=\n  @card_eq_zero_of_infinite _ hs.to_subtype\n\n"}
{"name":"Nat.card_eq_zero","module":"Mathlib.SetTheory.Cardinal.Finite","initialProofState":"α : Type u_1\n⊢ Iff (Eq (Nat.card α) 0) (Or (IsEmpty α) (Infinite α))","decl":"lemma card_eq_zero : Nat.card α = 0 ↔ IsEmpty α ∨ Infinite α := by\n  simp [Nat.card, mk_eq_zero_iff, aleph0_le_mk_iff]\n\n"}
{"name":"Nat.card_ne_zero","module":"Mathlib.SetTheory.Cardinal.Finite","initialProofState":"α : Type u_1\n⊢ Iff (Ne (Nat.card α) 0) (And (Nonempty α) (Finite α))","decl":"lemma card_ne_zero : Nat.card α ≠ 0 ↔ Nonempty α ∧ Finite α := by simp [card_eq_zero, not_or]\n\n"}
{"name":"Nat.card_pos_iff","module":"Mathlib.SetTheory.Cardinal.Finite","initialProofState":"α : Type u_1\n⊢ Iff (LT.lt 0 (Nat.card α)) (And (Nonempty α) (Finite α))","decl":"lemma card_pos_iff : 0 < Nat.card α ↔ Nonempty α ∧ Finite α := by\n  simp [Nat.card, mk_eq_zero_iff, mk_lt_aleph0_iff]\n\n"}
{"name":"Nat.card_pos","module":"Mathlib.SetTheory.Cardinal.Finite","initialProofState":"α : Type u_1\ninst✝¹ : Nonempty α\ninst✝ : Finite α\n⊢ LT.lt 0 (Nat.card α)","decl":"@[simp] lemma card_pos [Nonempty α] [Finite α] : 0 < Nat.card α := card_pos_iff.2 ⟨‹_›, ‹_›⟩\n\n"}
{"name":"Nat.finite_of_card_ne_zero","module":"Mathlib.SetTheory.Cardinal.Finite","initialProofState":"α : Type u_1\nh : Ne (Nat.card α) 0\n⊢ Finite α","decl":"theorem finite_of_card_ne_zero (h : Nat.card α ≠ 0) : Finite α := (card_ne_zero.1 h).2\n\n"}
{"name":"Nat.card_congr","module":"Mathlib.SetTheory.Cardinal.Finite","initialProofState":"α : Type u_1\nβ : Type u_2\nf : Equiv α β\n⊢ Eq (Nat.card α) (Nat.card β)","decl":"theorem card_congr (f : α ≃ β) : Nat.card α = Nat.card β :=\n  Cardinal.toNat_congr f\n\n"}
{"name":"Nat.card_le_card_of_injective","module":"Mathlib.SetTheory.Cardinal.Finite","initialProofState":"α : Type u\nβ : Type v\ninst✝ : Finite β\nf : α → β\nhf : Function.Injective f\n⊢ LE.le (Nat.card α) (Nat.card β)","decl":"lemma card_le_card_of_injective {α : Type u} {β : Type v} [Finite β] (f : α → β)\n    (hf : Injective f) : Nat.card α ≤ Nat.card β := by\n  simpa using toNat_le_toNat (lift_mk_le_lift_mk_of_injective hf) (by simp [lt_aleph0_of_finite])\n\n"}
{"name":"Nat.card_le_card_of_surjective","module":"Mathlib.SetTheory.Cardinal.Finite","initialProofState":"α : Type u\nβ : Type v\ninst✝ : Finite α\nf : α → β\nhf : Function.Surjective f\n⊢ LE.le (Nat.card β) (Nat.card α)","decl":"lemma card_le_card_of_surjective {α : Type u} {β : Type v} [Finite α] (f : α → β)\n    (hf : Surjective f) : Nat.card β ≤ Nat.card α := by\n  have : lift.{u} #β ≤ lift.{v} #α := mk_le_of_surjective (ULift.map_surjective.2 hf)\n  simpa using toNat_le_toNat this (by simp [lt_aleph0_of_finite])\n\n"}
{"name":"Nat.card_eq_of_bijective","module":"Mathlib.SetTheory.Cardinal.Finite","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nhf : Function.Bijective f\n⊢ Eq (Nat.card α) (Nat.card β)","decl":"theorem card_eq_of_bijective (f : α → β) (hf : Function.Bijective f) : Nat.card α = Nat.card β :=\n  card_congr (Equiv.ofBijective f hf)\n\n"}
{"name":"Nat.bijective_iff_injective_and_card","module":"Mathlib.SetTheory.Cardinal.Finite","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : Finite β\nf : α → β\n⊢ Iff (Function.Bijective f) (And (Function.Injective f) (Eq (Nat.card α) (Nat.card β)))","decl":"protected theorem bijective_iff_injective_and_card [Finite β] (f : α → β) :\n    Bijective f ↔ Injective f ∧ Nat.card α = Nat.card β := by\n  rw [Bijective, and_congr_right_iff]\n  intro h\n  have := Fintype.ofFinite β\n  have := Fintype.ofInjective f h\n  revert h\n  rw [← and_congr_right_iff, ← Bijective,\n    card_eq_fintype_card, card_eq_fintype_card, Fintype.bijective_iff_injective_and_card]\n\n"}
{"name":"Nat.bijective_iff_surjective_and_card","module":"Mathlib.SetTheory.Cardinal.Finite","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : Finite α\nf : α → β\n⊢ Iff (Function.Bijective f) (And (Function.Surjective f) (Eq (Nat.card α) (Nat.card β)))","decl":"protected theorem bijective_iff_surjective_and_card [Finite α] (f : α → β) :\n    Bijective f ↔ Surjective f ∧ Nat.card α = Nat.card β := by\n  classical\n  rw [_root_.and_comm, Bijective, and_congr_left_iff]\n  intro h\n  have := Fintype.ofFinite α\n  have := Fintype.ofSurjective f h\n  revert h\n  rw [← and_congr_left_iff, ← Bijective, ← and_comm,\n    card_eq_fintype_card, card_eq_fintype_card, Fintype.bijective_iff_surjective_and_card]\n\n"}
{"name":"Function.Injective.bijective_of_nat_card_le","module":"Mathlib.SetTheory.Cardinal.Finite","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : Finite β\nf : α → β\ninj : Function.Injective f\nhc : LE.le (Nat.card β) (Nat.card α)\n⊢ Function.Bijective f","decl":"theorem _root_.Function.Injective.bijective_of_nat_card_le [Finite β] {f : α → β}\n    (inj : Injective f) (hc : Nat.card β ≤ Nat.card α) : Bijective f :=\n  (Nat.bijective_iff_injective_and_card f).mpr\n    ⟨inj, hc.antisymm (card_le_card_of_injective f inj) |>.symm⟩\n\n"}
{"name":"Function.Surjective.bijective_of_nat_card_le","module":"Mathlib.SetTheory.Cardinal.Finite","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : Finite α\nf : α → β\nsurj : Function.Surjective f\nhc : LE.le (Nat.card α) (Nat.card β)\n⊢ Function.Bijective f","decl":"theorem _root_.Function.Surjective.bijective_of_nat_card_le [Finite α] {f : α → β}\n    (surj : Surjective f) (hc : Nat.card α ≤ Nat.card β) : Bijective f :=\n  (Nat.bijective_iff_surjective_and_card f).mpr\n    ⟨surj, hc.antisymm (card_le_card_of_surjective f surj)⟩\n\n"}
{"name":"Nat.card_eq_of_equiv_fin","module":"Mathlib.SetTheory.Cardinal.Finite","initialProofState":"α : Type u_3\nn : Nat\nf : Equiv α (Fin n)\n⊢ Eq (Nat.card α) n","decl":"theorem card_eq_of_equiv_fin {α : Type*} {n : ℕ} (f : α ≃ Fin n) : Nat.card α = n := by\n  simpa only [card_eq_fintype_card, Fintype.card_fin] using card_congr f\n\n"}
{"name":"Nat.card_mono","module":"Mathlib.SetTheory.Cardinal.Finite","initialProofState":"α : Type u_1\ns t : Set α\nht : t.Finite\nh : HasSubset.Subset s t\n⊢ LE.le (Nat.card ↑s) (Nat.card ↑t)","decl":"lemma card_mono (ht : t.Finite) (h : s ⊆ t) : Nat.card s ≤ Nat.card t :=\n  toNat_le_toNat (mk_le_mk_of_subset h) ht.lt_aleph0\n\n"}
{"name":"Nat.card_image_le","module":"Mathlib.SetTheory.Cardinal.Finite","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nf : α → β\nhs : s.Finite\n⊢ LE.le (Nat.card ↑(Set.image f s)) (Nat.card ↑s)","decl":"lemma card_image_le {f : α → β} (hs : s.Finite) : Nat.card (f '' s) ≤ Nat.card s :=\n  have := hs.to_subtype; card_le_card_of_surjective (imageFactorization f s) surjective_onto_image\n\n"}
{"name":"Nat.card_image_of_injOn","module":"Mathlib.SetTheory.Cardinal.Finite","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nf : α → β\nhf : Set.InjOn f s\n⊢ Eq (Nat.card ↑(Set.image f s)) (Nat.card ↑s)","decl":"lemma card_image_of_injOn {f : α → β} (hf : s.InjOn f) : Nat.card (f '' s) = Nat.card s := by\n  classical\n  obtain hs | hs := s.finite_or_infinite\n  · have := hs.fintype\n    have := fintypeImage s f\n    simp_rw [Nat.card_eq_fintype_card, Set.card_image_of_inj_on hf]\n  · have := hs.to_subtype\n    have := (hs.image hf).to_subtype\n    simp [Nat.card_eq_zero_of_infinite]\n\n"}
{"name":"Nat.card_image_of_injective","module":"Mathlib.SetTheory.Cardinal.Finite","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nhf : Function.Injective f\ns : Set α\n⊢ Eq (Nat.card ↑(Set.image f s)) (Nat.card ↑s)","decl":"lemma card_image_of_injective {f : α → β} (hf : Injective f) (s : Set α) :\n    Nat.card (f '' s) = Nat.card s := card_image_of_injOn hf.injOn\n\n"}
{"name":"Nat.card_image_equiv","module":"Mathlib.SetTheory.Cardinal.Finite","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\ne : Equiv α β\n⊢ Eq (Nat.card ↑(Set.image (⇑e) s)) (Nat.card ↑s)","decl":"lemma card_image_equiv (e : α ≃ β) : Nat.card (e '' s) = Nat.card s :=\n    Nat.card_congr (e.image s).symm\n\n"}
{"name":"Nat.card_preimage_of_injOn","module":"Mathlib.SetTheory.Cardinal.Finite","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\ns : Set β\nhf : Set.InjOn f (Set.preimage f s)\nhsf : HasSubset.Subset s (Set.range f)\n⊢ Eq (Nat.card ↑(Set.preimage f s)) (Nat.card ↑s)","decl":"lemma card_preimage_of_injOn {f : α → β} {s : Set β} (hf : (f ⁻¹' s).InjOn f) (hsf : s ⊆ range f) :\n    Nat.card (f ⁻¹' s) = Nat.card s := by\n  rw [← Nat.card_image_of_injOn hf, image_preimage_eq_iff.2 hsf]\n\n"}
{"name":"Nat.card_preimage_of_injective","module":"Mathlib.SetTheory.Cardinal.Finite","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\ns : Set β\nhf : Function.Injective f\nhsf : HasSubset.Subset s (Set.range f)\n⊢ Eq (Nat.card ↑(Set.preimage f s)) (Nat.card ↑s)","decl":"lemma card_preimage_of_injective {f : α → β} {s : Set β} (hf : Injective f) (hsf : s ⊆ range f) :\n    Nat.card (f ⁻¹' s) = Nat.card s := card_preimage_of_injOn hf.injOn hsf\n\n"}
{"name":"Nat.card_univ","module":"Mathlib.SetTheory.Cardinal.Finite","initialProofState":"α : Type u_1\n⊢ Eq (Nat.card ↑Set.univ) (Nat.card α)","decl":"@[simp] lemma card_univ : Nat.card (univ : Set α) = Nat.card α :=\n  card_congr (Equiv.Set.univ α)\n\n"}
{"name":"Nat.card_range_of_injective","module":"Mathlib.SetTheory.Cardinal.Finite","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nhf : Function.Injective f\n⊢ Eq (Nat.card ↑(Set.range f)) (Nat.card α)","decl":"lemma card_range_of_injective {f : α → β} (hf : Injective f) :\n    Nat.card (range f) = Nat.card α := by\n  rw [← Nat.card_preimage_of_injective hf le_rfl]\n  simp\n\n"}
{"name":"Nat.card_of_subsingleton","module":"Mathlib.SetTheory.Cardinal.Finite","initialProofState":"α : Type u_1\na : α\ninst✝ : Subsingleton α\n⊢ Eq (Nat.card α) 1","decl":"theorem card_of_subsingleton (a : α) [Subsingleton α] : Nat.card α = 1 := by\n  letI := Fintype.ofSubsingleton a\n  rw [card_eq_fintype_card, Fintype.card_ofSubsingleton a]\n\n"}
{"name":"Nat.card_eq_one_iff_unique","module":"Mathlib.SetTheory.Cardinal.Finite","initialProofState":"α : Type u_1\n⊢ Iff (Eq (Nat.card α) 1) (And (Subsingleton α) (Nonempty α))","decl":"theorem card_eq_one_iff_unique : Nat.card α = 1 ↔ Subsingleton α ∧ Nonempty α :=\n  Cardinal.toNat_eq_one_iff_unique\n\n"}
{"name":"Nat.card_unique","module":"Mathlib.SetTheory.Cardinal.Finite","initialProofState":"α : Type u_1\ninst✝¹ : Nonempty α\ninst✝ : Subsingleton α\n⊢ Eq (Nat.card α) 1","decl":"@[simp]\ntheorem card_unique [Nonempty α] [Subsingleton α] : Nat.card α = 1 := by\n  simp [card_eq_one_iff_unique, *]\n\n"}
{"name":"Nat.card_eq_one_iff_exists","module":"Mathlib.SetTheory.Cardinal.Finite","initialProofState":"α : Type u_1\n⊢ Iff (Eq (Nat.card α) 1) (Exists fun x => ∀ (y : α), Eq y x)","decl":"theorem card_eq_one_iff_exists : Nat.card α = 1 ↔ ∃ x : α, ∀ y : α, y = x := by\n  rw [card_eq_one_iff_unique]\n  exact ⟨fun ⟨s, ⟨a⟩⟩ ↦ ⟨a, fun x ↦ s.elim x a⟩, fun ⟨x, h⟩ ↦ ⟨subsingleton_of_forall_eq x h, ⟨x⟩⟩⟩\n\n"}
{"name":"Nat.card_eq_two_iff","module":"Mathlib.SetTheory.Cardinal.Finite","initialProofState":"α : Type u_1\n⊢ Iff (Eq (Nat.card α) 2) (Exists fun x => Exists fun y => And (Ne x y) (Eq (Insert.insert x (Singleton.singleton y)) Set.univ))","decl":"theorem card_eq_two_iff : Nat.card α = 2 ↔ ∃ x y : α, x ≠ y ∧ {x, y} = @Set.univ α :=\n  toNat_eq_ofNat.trans mk_eq_two_iff\n\n"}
{"name":"Nat.card_eq_two_iff'","module":"Mathlib.SetTheory.Cardinal.Finite","initialProofState":"α : Type u_1\nx : α\n⊢ Iff (Eq (Nat.card α) 2) (ExistsUnique fun y => Ne y x)","decl":"theorem card_eq_two_iff' (x : α) : Nat.card α = 2 ↔ ∃! y, y ≠ x :=\n  toNat_eq_ofNat.trans (mk_eq_two_iff' x)\n\n"}
{"name":"Nat.card_sum","module":"Mathlib.SetTheory.Cardinal.Finite","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Finite α\ninst✝ : Finite β\n⊢ Eq (Nat.card (Sum α β)) (HAdd.hAdd (Nat.card α) (Nat.card β))","decl":"@[simp]\ntheorem card_sum [Finite α] [Finite β] : Nat.card (α ⊕ β) = Nat.card α + Nat.card β := by\n  have := Fintype.ofFinite α\n  have := Fintype.ofFinite β\n  simp_rw [Nat.card_eq_fintype_card, Fintype.card_sum]\n\n"}
{"name":"Nat.card_prod","module":"Mathlib.SetTheory.Cardinal.Finite","initialProofState":"α : Type u_3\nβ : Type u_4\n⊢ Eq (Nat.card (Prod α β)) (HMul.hMul (Nat.card α) (Nat.card β))","decl":"@[simp]\ntheorem card_prod (α β : Type*) : Nat.card (α × β) = Nat.card α * Nat.card β := by\n  simp only [Nat.card, mk_prod, toNat_mul, toNat_lift]\n\n"}
{"name":"Nat.card_ulift","module":"Mathlib.SetTheory.Cardinal.Finite","initialProofState":"α : Type u_3\n⊢ Eq (Nat.card (ULift.{u_4, u_3} α)) (Nat.card α)","decl":"@[simp]\ntheorem card_ulift (α : Type*) : Nat.card (ULift α) = Nat.card α :=\n  card_congr Equiv.ulift\n\n"}
{"name":"Nat.card_plift","module":"Mathlib.SetTheory.Cardinal.Finite","initialProofState":"α : Type u_3\n⊢ Eq (Nat.card (PLift α)) (Nat.card α)","decl":"@[simp]\ntheorem card_plift (α : Type*) : Nat.card (PLift α) = Nat.card α :=\n  card_congr Equiv.plift\n\n"}
{"name":"Nat.card_pi","module":"Mathlib.SetTheory.Cardinal.Finite","initialProofState":"α : Type u_1\nβ : α → Type u_3\ninst✝ : Fintype α\n⊢ Eq (Nat.card ((a : α) → β a)) (Finset.univ.prod fun a => Nat.card (β a))","decl":"theorem card_pi {β : α → Type*} [Fintype α] : Nat.card (∀ a, β a) = ∏ a, Nat.card (β a) := by\n  simp_rw [Nat.card, mk_pi, prod_eq_of_fintype, toNat_lift, map_prod]\n\n"}
{"name":"Nat.card_fun","module":"Mathlib.SetTheory.Cardinal.Finite","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : Finite α\n⊢ Eq (Nat.card (α → β)) (HPow.hPow (Nat.card β) (Nat.card α))","decl":"theorem card_fun [Finite α] : Nat.card (α → β) = Nat.card β ^ Nat.card α := by\n  haveI := Fintype.ofFinite α\n  rw [Nat.card_pi, Finset.prod_const, Finset.card_univ, ← Nat.card_eq_fintype_card]\n\n"}
{"name":"Nat.card_zmod","module":"Mathlib.SetTheory.Cardinal.Finite","initialProofState":"n : Nat\n⊢ Eq (Nat.card (ZMod n)) n","decl":"@[simp]\ntheorem card_zmod (n : ℕ) : Nat.card (ZMod n) = n := by\n  cases n\n  · exact @Nat.card_eq_zero_of_infinite _ Int.infinite\n  · rw [Nat.card_eq_fintype_card, ZMod.card]\n\n"}
{"name":"Set.card_singleton_prod","module":"Mathlib.SetTheory.Cardinal.Finite","initialProofState":"α : Type u_1\nβ : Type u_2\na : α\nt : Set β\n⊢ Eq (Nat.card ↑(SProd.sprod (Singleton.singleton a) t)) (Nat.card ↑t)","decl":"lemma card_singleton_prod (a : α) (t : Set β) : Nat.card ({a} ×ˢ t) = Nat.card t := by\n  rw [singleton_prod, Nat.card_image_of_injective (Prod.mk.inj_left a)]\n\n"}
{"name":"Set.card_prod_singleton","module":"Mathlib.SetTheory.Cardinal.Finite","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nb : β\n⊢ Eq (Nat.card ↑(SProd.sprod s (Singleton.singleton b))) (Nat.card ↑s)","decl":"lemma card_prod_singleton (s : Set α) (b : β) : Nat.card (s ×ˢ {b}) = Nat.card s := by\n  rw [prod_singleton, Nat.card_image_of_injective (Prod.mk.inj_right b)]\n\n"}
{"name":"Set.natCard_pos","module":"Mathlib.SetTheory.Cardinal.Finite","initialProofState":"α : Type u_1\ns : Set α\nhs : s.Finite\n⊢ Iff (LT.lt 0 (Nat.card ↑s)) s.Nonempty","decl":"theorem natCard_pos (hs : s.Finite) : 0 < Nat.card s ↔ s.Nonempty := by\n  simp [pos_iff_ne_zero, Nat.card_eq_zero, hs.to_subtype, nonempty_iff_ne_empty]\n\n"}
{"name":"Set.Nonempty.natCard_pos","module":"Mathlib.SetTheory.Cardinal.Finite","initialProofState":"α : Type u_1\ns : Set α\nhs : s.Finite\na✝ : s.Nonempty\n⊢ LT.lt 0 (Nat.card ↑s)","decl":"protected alias ⟨_, Nonempty.natCard_pos⟩ := natCard_pos\n\n"}
{"name":"Set.natCard_graphOn","module":"Mathlib.SetTheory.Cardinal.Finite","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nf : α → β\n⊢ Eq (Nat.card ↑(Set.graphOn f s)) (Nat.card ↑s)","decl":"@[simp] lemma natCard_graphOn (s : Set α) (f : α → β) : Nat.card (s.graphOn f) = Nat.card s := by\n  rw [← Nat.card_image_of_injOn fst_injOn_graph, image_fst_graphOn]\n\n"}
{"name":"ENat.card_eq_coe_fintype_card","module":"Mathlib.SetTheory.Cardinal.Finite","initialProofState":"α : Type u_1\ninst✝ : Fintype α\n⊢ Eq (ENat.card α) ↑(Fintype.card α)","decl":"@[simp]\ntheorem card_eq_coe_fintype_card [Fintype α] : card α = Fintype.card α := by\n  simp [card]\n\n"}
{"name":"ENat.card_eq_top_of_infinite","module":"Mathlib.SetTheory.Cardinal.Finite","initialProofState":"α : Type u_1\ninst✝ : Infinite α\n⊢ Eq (ENat.card α) Top.top","decl":"@[simp]\ntheorem card_eq_top_of_infinite [Infinite α] : card α = ⊤ := by\n  simp [card]\n\n"}
{"name":"ENat.card_sum","module":"Mathlib.SetTheory.Cardinal.Finite","initialProofState":"α : Type u_3\nβ : Type u_4\n⊢ Eq (ENat.card (Sum α β)) (HAdd.hAdd (ENat.card α) (ENat.card β))","decl":"@[simp]\ntheorem card_sum (α β : Type*) :\n    card (α ⊕ β) = card α + card β := by\n  simp only [card, mk_sum, map_add, toENat_lift]\n\n"}
{"name":"ENat.card_congr","module":"Mathlib.SetTheory.Cardinal.Finite","initialProofState":"α : Type u_3\nβ : Type u_4\nf : Equiv α β\n⊢ Eq (ENat.card α) (ENat.card β)","decl":"theorem card_congr {α β : Type*} (f : α ≃ β) : card α = card β :=\n  Cardinal.toENat_congr f\n\n"}
{"name":"ENat.card_ulift","module":"Mathlib.SetTheory.Cardinal.Finite","initialProofState":"α : Type u_3\n⊢ Eq (ENat.card (ULift.{u_4, u_3} α)) (ENat.card α)","decl":"@[simp] lemma card_ulift (α : Type*) : card (ULift α) = card α := card_congr Equiv.ulift\n\n"}
{"name":"ENat.card_plift","module":"Mathlib.SetTheory.Cardinal.Finite","initialProofState":"α : Type u_3\n⊢ Eq (ENat.card (PLift α)) (ENat.card α)","decl":"@[simp] lemma card_plift (α : Type*) : card (PLift α) = card α := card_congr Equiv.plift\n\n"}
{"name":"ENat.card_image_of_injOn","module":"Mathlib.SetTheory.Cardinal.Finite","initialProofState":"α : Type u_3\nβ : Type u_4\nf : α → β\ns : Set α\nh : Set.InjOn f s\n⊢ Eq (ENat.card ↑(Set.image f s)) (ENat.card ↑s)","decl":"theorem card_image_of_injOn {α β : Type*} {f : α → β} {s : Set α} (h : Set.InjOn f s) :\n    card (f '' s) = card s :=\n  card_congr (Equiv.Set.imageOfInjOn f s h).symm\n\n"}
{"name":"ENat.card_image_of_injective","module":"Mathlib.SetTheory.Cardinal.Finite","initialProofState":"α : Type u_3\nβ : Type u_4\nf : α → β\ns : Set α\nh : Function.Injective f\n⊢ Eq (ENat.card ↑(Set.image f s)) (ENat.card ↑s)","decl":"theorem card_image_of_injective {α β : Type*} (f : α → β) (s : Set α)\n    (h : Function.Injective f) : card (f '' s) = card s := card_image_of_injOn h.injOn\n\n"}
{"name":"Cardinal.natCast_le_toENat_iff","module":"Mathlib.SetTheory.Cardinal.Finite","initialProofState":"n : Nat\nc : Cardinal.{u_3}\n⊢ Iff (LE.le (↑n) (Cardinal.toENat c)) (LE.le (↑n) c)","decl":"@[simp]\ntheorem _root_.Cardinal.natCast_le_toENat_iff {n : ℕ} {c : Cardinal} :\n    ↑n ≤ toENat c ↔ ↑n ≤ c := by\n  rw [← toENat_nat n, toENat_le_iff_of_le_aleph0 (le_of_lt (nat_lt_aleph0 n))]\n\n"}
{"name":"Cardinal.toENat_le_natCast_iff","module":"Mathlib.SetTheory.Cardinal.Finite","initialProofState":"c : Cardinal.{u_3}\nn : Nat\n⊢ Iff (LE.le (Cardinal.toENat c) ↑n) (LE.le c ↑n)","decl":"theorem _root_.Cardinal.toENat_le_natCast_iff {c : Cardinal} {n : ℕ} :\n    toENat c ≤ n ↔ c ≤ n := by simp\n\n"}
{"name":"Cardinal.natCast_eq_toENat_iff","module":"Mathlib.SetTheory.Cardinal.Finite","initialProofState":"n : Nat\nc : Cardinal.{u_3}\n⊢ Iff (Eq (↑n) (Cardinal.toENat c)) (Eq (↑n) c)","decl":"@[simp]\ntheorem _root_.Cardinal.natCast_eq_toENat_iff {n : ℕ} {c : Cardinal} :\n    ↑n = toENat c ↔ ↑n = c := by\n  rw [le_antisymm_iff, le_antisymm_iff, Cardinal.toENat_le_natCast_iff,\n    Cardinal.natCast_le_toENat_iff]\n\n"}
{"name":"Cardinal.toENat_eq_natCast_iff","module":"Mathlib.SetTheory.Cardinal.Finite","initialProofState":"c : Cardinal.{u_3}\nn : Nat\n⊢ Iff (Eq (Cardinal.toENat c) ↑n) (Eq c ↑n)","decl":"theorem _root_.Cardinal.toENat_eq_natCast_iff {c : Cardinal} {n : ℕ} :\n    Cardinal.toENat c = n ↔ c = n := by simp\n\n"}
{"name":"Cardinal.natCast_lt_toENat_iff","module":"Mathlib.SetTheory.Cardinal.Finite","initialProofState":"n : Nat\nc : Cardinal.{u_3}\n⊢ Iff (LT.lt (↑n) (Cardinal.toENat c)) (LT.lt (↑n) c)","decl":"@[simp]\ntheorem _root_.Cardinal.natCast_lt_toENat_iff {n : ℕ} {c : Cardinal} :\n    ↑n < toENat c ↔ ↑n < c := by\n  simp only [← not_le, Cardinal.toENat_le_natCast_iff]\n\n"}
{"name":"Cardinal.toENat_lt_natCast_iff","module":"Mathlib.SetTheory.Cardinal.Finite","initialProofState":"n : Nat\nc : Cardinal.{u_3}\n⊢ Iff (LT.lt (Cardinal.toENat c) ↑n) (LT.lt c ↑n)","decl":"@[simp]\ntheorem _root_.Cardinal.toENat_lt_natCast_iff {n : ℕ} {c : Cardinal} :\n    toENat c < ↑n ↔ c < ↑n := by\n  simp only [← not_le, Cardinal.natCast_le_toENat_iff]\n\n"}
{"name":"ENat.card_eq_zero_iff_empty","module":"Mathlib.SetTheory.Cardinal.Finite","initialProofState":"α : Type u_3\n⊢ Iff (Eq (ENat.card α) 0) (IsEmpty α)","decl":"theorem card_eq_zero_iff_empty (α : Type*) : card α = 0 ↔ IsEmpty α := by\n  rw [← Cardinal.mk_eq_zero_iff]\n  simp [card]\n\n"}
{"name":"ENat.card_le_one_iff_subsingleton","module":"Mathlib.SetTheory.Cardinal.Finite","initialProofState":"α : Type u_3\n⊢ Iff (LE.le (ENat.card α) 1) (Subsingleton α)","decl":"theorem card_le_one_iff_subsingleton (α : Type*) : card α ≤ 1 ↔ Subsingleton α := by\n  rw [← le_one_iff_subsingleton]\n  simp [card]\n\n"}
{"name":"ENat.one_lt_card_iff_nontrivial","module":"Mathlib.SetTheory.Cardinal.Finite","initialProofState":"α : Type u_3\n⊢ Iff (LT.lt 1 (ENat.card α)) (Nontrivial α)","decl":"theorem one_lt_card_iff_nontrivial (α : Type*) : 1 < card α ↔ Nontrivial α := by\n  rw [← Cardinal.one_lt_iff_nontrivial]\n  conv_rhs => rw [← Nat.cast_one]\n  rw [← natCast_lt_toENat_iff]\n  simp only [ENat.card, Nat.cast_one]\n\n"}
