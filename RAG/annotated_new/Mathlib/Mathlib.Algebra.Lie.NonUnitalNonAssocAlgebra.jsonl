{"name":"LieAlgebra.instNonemptyCommutatorRing","module":"Mathlib.Algebra.Lie.NonUnitalNonAssocAlgebra","initialProofState":"L : Type v\ninst✝ : Nonempty L\n⊢ Nonempty (CommutatorRing L)","decl":"instance (L : Type v) [Nonempty L] : Nonempty (CommutatorRing L) := ‹Nonempty L›\n\n"}
{"name":"LieAlgebra.isScalarTower","module":"Mathlib.Algebra.Lie.NonUnitalNonAssocAlgebra","initialProofState":"R : Type u\nL : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\n⊢ IsScalarTower R (CommutatorRing L) (CommutatorRing L)","decl":"/-- Regarding the `LieRing` of a `LieAlgebra` as a `NonUnitalNonAssocRing`, we can\nreinterpret the `smul_lie` law as an `IsScalarTower`. -/\ninstance isScalarTower : IsScalarTower R (CommutatorRing L) (CommutatorRing L) := ⟨smul_lie⟩\n\n"}
{"name":"LieAlgebra.smulCommClass","module":"Mathlib.Algebra.Lie.NonUnitalNonAssocAlgebra","initialProofState":"R : Type u\nL : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\n⊢ SMulCommClass R (CommutatorRing L) (CommutatorRing L)","decl":"/-- Regarding the `LieRing` of a `LieAlgebra` as a `NonUnitalNonAssocRing`, we can\nreinterpret the `lie_smul` law as an `SMulCommClass`. -/\ninstance smulCommClass : SMulCommClass R (CommutatorRing L) (CommutatorRing L) :=\n  ⟨fun t x y => (lie_smul t x y).symm⟩\n\n"}
{"name":"LieHom.toNonUnitalAlgHom_toFun","module":"Mathlib.Algebra.Lie.NonUnitalNonAssocAlgebra","initialProofState":"R : Type u\nL : Type v\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : LieAlgebra R L\nL₂ : Type w\ninst✝¹ : LieRing L₂\ninst✝ : LieAlgebra R L₂\nf : LieHom R L L₂\na : L\n⊢ Eq (f.toNonUnitalAlgHom a) (f a)","decl":"/-- Regarding the `LieRing` of a `LieAlgebra` as a `NonUnitalNonAssocRing`, we can\nregard a `LieHom` as a `NonUnitalAlgHom`. -/\n@[simps]\ndef toNonUnitalAlgHom (f : L →ₗ⁅R⁆ L₂) : CommutatorRing L →ₙₐ[R] CommutatorRing L₂ :=\n  { f with\n    toFun := f\n    map_zero' := f.map_zero\n    map_mul' := f.map_lie }\n\n"}
{"name":"LieHom.toNonUnitalAlgHom_apply","module":"Mathlib.Algebra.Lie.NonUnitalNonAssocAlgebra","initialProofState":"R : Type u\nL : Type v\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : LieAlgebra R L\nL₂ : Type w\ninst✝¹ : LieRing L₂\ninst✝ : LieAlgebra R L₂\nf : LieHom R L L₂\na : L\n⊢ Eq (f.toNonUnitalAlgHom a) (f a)","decl":"/-- Regarding the `LieRing` of a `LieAlgebra` as a `NonUnitalNonAssocRing`, we can\nregard a `LieHom` as a `NonUnitalAlgHom`. -/\n@[simps]\ndef toNonUnitalAlgHom (f : L →ₗ⁅R⁆ L₂) : CommutatorRing L →ₙₐ[R] CommutatorRing L₂ :=\n  { f with\n    toFun := f\n    map_zero' := f.map_zero\n    map_mul' := f.map_lie }\n\n"}
{"name":"LieHom.toNonUnitalAlgHom_injective","module":"Mathlib.Algebra.Lie.NonUnitalNonAssocAlgebra","initialProofState":"R : Type u\nL : Type v\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : LieAlgebra R L\nL₂ : Type w\ninst✝¹ : LieRing L₂\ninst✝ : LieAlgebra R L₂\n⊢ Function.Injective LieHom.toNonUnitalAlgHom","decl":"theorem toNonUnitalAlgHom_injective :\n    Function.Injective (toNonUnitalAlgHom : _ → CommutatorRing L →ₙₐ[R] CommutatorRing L₂) :=\n  fun _ _ h => ext <| NonUnitalAlgHom.congr_fun h\n\n"}
