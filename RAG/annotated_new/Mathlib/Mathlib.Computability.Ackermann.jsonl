{"name":"ack_zero","module":"Mathlib.Computability.Ackermann","initialProofState":"n : Nat\n⊢ Eq (ack 0 n) (HAdd.hAdd n 1)","decl":"@[simp]\ntheorem ack_zero (n : ℕ) : ack 0 n = n + 1 := by rw [ack]\n\n"}
{"name":"ack_succ_zero","module":"Mathlib.Computability.Ackermann","initialProofState":"m : Nat\n⊢ Eq (ack (HAdd.hAdd m 1) 0) (ack m 1)","decl":"@[simp]\ntheorem ack_succ_zero (m : ℕ) : ack (m + 1) 0 = ack m 1 := by rw [ack]\n\n"}
{"name":"ack_succ_succ","module":"Mathlib.Computability.Ackermann","initialProofState":"m n : Nat\n⊢ Eq (ack (HAdd.hAdd m 1) (HAdd.hAdd n 1)) (ack m (ack (HAdd.hAdd m 1) n))","decl":"@[simp]\ntheorem ack_succ_succ (m n : ℕ) : ack (m + 1) (n + 1) = ack m (ack (m + 1) n) := by rw [ack]\n\n"}
{"name":"ack_one","module":"Mathlib.Computability.Ackermann","initialProofState":"n : Nat\n⊢ Eq (ack 1 n) (HAdd.hAdd n 2)","decl":"@[simp]\ntheorem ack_one (n : ℕ) : ack 1 n = n + 2 := by\n  induction' n with n IH\n  · simp\n  · simp [IH]\n\n"}
{"name":"ack_two","module":"Mathlib.Computability.Ackermann","initialProofState":"n : Nat\n⊢ Eq (ack 2 n) (HAdd.hAdd (HMul.hMul 2 n) 3)","decl":"@[simp]\ntheorem ack_two (n : ℕ) : ack 2 n = 2 * n + 3 := by\n  induction' n with n IH\n  · simp\n  · simpa [mul_succ]\n\n"}
{"name":"ack_three","module":"Mathlib.Computability.Ackermann","initialProofState":"n : Nat\n⊢ Eq (ack 3 n) (HSub.hSub (HPow.hPow 2 (HAdd.hAdd n 3)) 3)","decl":"@[simp]\ntheorem ack_three (n : ℕ) : ack 3 n = 2 ^ (n + 3) - 3 := by\n  induction' n with n IH\n  · simp\n  · rw [ack_succ_succ, IH, ack_two, Nat.succ_add, Nat.pow_succ 2 (n + 3), mul_comm _ 2,\n        Nat.mul_sub_left_distrib, ← Nat.sub_add_comm, two_mul 3, Nat.add_sub_add_right]\n    have H : 2 * 3 ≤ 2 * 2 ^ 3 := by norm_num\n    apply H.trans\n    rw [_root_.mul_le_mul_left two_pos]\n    exact pow_right_mono₀ one_le_two (Nat.le_add_left 3 n)\n\n"}
{"name":"ack_pos","module":"Mathlib.Computability.Ackermann","initialProofState":"m n : Nat\n⊢ LT.lt 0 (ack m n)","decl":"theorem ack_pos : ∀ m n, 0 < ack m n\n  | 0, n => by simp\n  | m + 1, 0 => by\n    rw [ack_succ_zero]\n    apply ack_pos\n  | m + 1, n + 1 => by\n    rw [ack_succ_succ]\n    apply ack_pos\n\n"}
{"name":"one_lt_ack_succ_left","module":"Mathlib.Computability.Ackermann","initialProofState":"m n : Nat\n⊢ LT.lt 1 (ack (HAdd.hAdd m 1) n)","decl":"theorem one_lt_ack_succ_left : ∀ m n, 1 < ack (m + 1) n\n  | 0, n => by simp\n  | m + 1, 0 => by\n    rw [ack_succ_zero]\n    apply one_lt_ack_succ_left\n  | m + 1, n + 1 => by\n    rw [ack_succ_succ]\n    apply one_lt_ack_succ_left\n\n"}
{"name":"one_lt_ack_succ_right","module":"Mathlib.Computability.Ackermann","initialProofState":"m n : Nat\n⊢ LT.lt 1 (ack m (HAdd.hAdd n 1))","decl":"theorem one_lt_ack_succ_right : ∀ m n, 1 < ack m (n + 1)\n  | 0, n => by simp\n  | m + 1, n => by\n    rw [ack_succ_succ]\n    cases' exists_eq_succ_of_ne_zero (ack_pos (m + 1) n).ne' with h h\n    rw [h]\n    apply one_lt_ack_succ_right\n\n"}
{"name":"ack_strictMono_right","module":"Mathlib.Computability.Ackermann","initialProofState":"m : Nat\n⊢ StrictMono (ack m)","decl":"theorem ack_strictMono_right : ∀ m, StrictMono (ack m)\n  | 0, n₁, n₂, h => by simpa using h\n  | m + 1, 0, n + 1, _h => by\n    rw [ack_succ_zero, ack_succ_succ]\n    exact ack_strictMono_right _ (one_lt_ack_succ_left m n)\n  | m + 1, n₁ + 1, n₂ + 1, h => by\n    rw [ack_succ_succ, ack_succ_succ]\n    apply ack_strictMono_right _ (ack_strictMono_right _ _)\n    rwa [add_lt_add_iff_right] at h\n\n"}
{"name":"ack_mono_right","module":"Mathlib.Computability.Ackermann","initialProofState":"m : Nat\n⊢ Monotone (ack m)","decl":"theorem ack_mono_right (m : ℕ) : Monotone (ack m) :=\n  (ack_strictMono_right m).monotone\n\n"}
{"name":"ack_injective_right","module":"Mathlib.Computability.Ackermann","initialProofState":"m : Nat\n⊢ Function.Injective (ack m)","decl":"theorem ack_injective_right (m : ℕ) : Function.Injective (ack m) :=\n  (ack_strictMono_right m).injective\n\n"}
{"name":"ack_lt_iff_right","module":"Mathlib.Computability.Ackermann","initialProofState":"m n₁ n₂ : Nat\n⊢ Iff (LT.lt (ack m n₁) (ack m n₂)) (LT.lt n₁ n₂)","decl":"@[simp]\ntheorem ack_lt_iff_right {m n₁ n₂ : ℕ} : ack m n₁ < ack m n₂ ↔ n₁ < n₂ :=\n  (ack_strictMono_right m).lt_iff_lt\n\n"}
{"name":"ack_le_iff_right","module":"Mathlib.Computability.Ackermann","initialProofState":"m n₁ n₂ : Nat\n⊢ Iff (LE.le (ack m n₁) (ack m n₂)) (LE.le n₁ n₂)","decl":"@[simp]\ntheorem ack_le_iff_right {m n₁ n₂ : ℕ} : ack m n₁ ≤ ack m n₂ ↔ n₁ ≤ n₂ :=\n  (ack_strictMono_right m).le_iff_le\n\n"}
{"name":"ack_inj_right","module":"Mathlib.Computability.Ackermann","initialProofState":"m n₁ n₂ : Nat\n⊢ Iff (Eq (ack m n₁) (ack m n₂)) (Eq n₁ n₂)","decl":"@[simp]\ntheorem ack_inj_right {m n₁ n₂ : ℕ} : ack m n₁ = ack m n₂ ↔ n₁ = n₂ :=\n  (ack_injective_right m).eq_iff\n\n"}
{"name":"max_ack_right","module":"Mathlib.Computability.Ackermann","initialProofState":"m n₁ n₂ : Nat\n⊢ Eq (ack m (Max.max n₁ n₂)) (Max.max (ack m n₁) (ack m n₂))","decl":"theorem max_ack_right (m n₁ n₂ : ℕ) : ack m (max n₁ n₂) = max (ack m n₁) (ack m n₂) :=\n  (ack_mono_right m).map_max\n\n"}
{"name":"add_lt_ack","module":"Mathlib.Computability.Ackermann","initialProofState":"m n : Nat\n⊢ LT.lt (HAdd.hAdd m n) (ack m n)","decl":"theorem add_lt_ack : ∀ m n, m + n < ack m n\n  | 0, n => by simp\n  | m + 1, 0 => by simpa using add_lt_ack m 1\n  | m + 1, n + 1 =>\n    calc\n      m + 1 + n + 1 ≤ m + (m + n + 2) := by omega\n      _ < ack m (m + n + 2) := add_lt_ack _ _\n      _ ≤ ack m (ack (m + 1) n) :=\n        ack_mono_right m <| le_of_eq_of_le (by rw [succ_eq_add_one]; ring_nf)\n        <| succ_le_of_lt <| add_lt_ack (m + 1) n\n      _ = ack (m + 1) (n + 1) := (ack_succ_succ m n).symm\n\n"}
{"name":"add_add_one_le_ack","module":"Mathlib.Computability.Ackermann","initialProofState":"m n : Nat\n⊢ LE.le (HAdd.hAdd (HAdd.hAdd m n) 1) (ack m n)","decl":"theorem add_add_one_le_ack (m n : ℕ) : m + n + 1 ≤ ack m n :=\n  succ_le_of_lt (add_lt_ack m n)\n\n"}
{"name":"lt_ack_left","module":"Mathlib.Computability.Ackermann","initialProofState":"m n : Nat\n⊢ LT.lt m (ack m n)","decl":"theorem lt_ack_left (m n : ℕ) : m < ack m n :=\n  (self_le_add_right m n).trans_lt <| add_lt_ack m n\n\n"}
{"name":"lt_ack_right","module":"Mathlib.Computability.Ackermann","initialProofState":"m n : Nat\n⊢ LT.lt n (ack m n)","decl":"theorem lt_ack_right (m n : ℕ) : n < ack m n :=\n  (self_le_add_left n m).trans_lt <| add_lt_ack m n\n\n-- we reorder the arguments to appease the equation compiler\n"}
{"name":"ack_strictMono_left","module":"Mathlib.Computability.Ackermann","initialProofState":"n : Nat\n⊢ StrictMono fun m => ack m n","decl":"theorem ack_strictMono_left (n : ℕ) : StrictMono fun m => ack m n := fun _m₁ _m₂ =>\n  ack_strict_mono_left' n\n\n"}
{"name":"ack_mono_left","module":"Mathlib.Computability.Ackermann","initialProofState":"n : Nat\n⊢ Monotone fun m => ack m n","decl":"theorem ack_mono_left (n : ℕ) : Monotone fun m => ack m n :=\n  (ack_strictMono_left n).monotone\n\n"}
{"name":"ack_injective_left","module":"Mathlib.Computability.Ackermann","initialProofState":"n : Nat\n⊢ Function.Injective fun m => ack m n","decl":"theorem ack_injective_left (n : ℕ) : Function.Injective fun m => ack m n :=\n  (ack_strictMono_left n).injective\n\n"}
{"name":"ack_lt_iff_left","module":"Mathlib.Computability.Ackermann","initialProofState":"m₁ m₂ n : Nat\n⊢ Iff (LT.lt (ack m₁ n) (ack m₂ n)) (LT.lt m₁ m₂)","decl":"@[simp]\ntheorem ack_lt_iff_left {m₁ m₂ n : ℕ} : ack m₁ n < ack m₂ n ↔ m₁ < m₂ :=\n  (ack_strictMono_left n).lt_iff_lt\n\n"}
{"name":"ack_le_iff_left","module":"Mathlib.Computability.Ackermann","initialProofState":"m₁ m₂ n : Nat\n⊢ Iff (LE.le (ack m₁ n) (ack m₂ n)) (LE.le m₁ m₂)","decl":"@[simp]\ntheorem ack_le_iff_left {m₁ m₂ n : ℕ} : ack m₁ n ≤ ack m₂ n ↔ m₁ ≤ m₂ :=\n  (ack_strictMono_left n).le_iff_le\n\n"}
{"name":"ack_inj_left","module":"Mathlib.Computability.Ackermann","initialProofState":"m₁ m₂ n : Nat\n⊢ Iff (Eq (ack m₁ n) (ack m₂ n)) (Eq m₁ m₂)","decl":"@[simp]\ntheorem ack_inj_left {m₁ m₂ n : ℕ} : ack m₁ n = ack m₂ n ↔ m₁ = m₂ :=\n  (ack_injective_left n).eq_iff\n\n"}
{"name":"max_ack_left","module":"Mathlib.Computability.Ackermann","initialProofState":"m₁ m₂ n : Nat\n⊢ Eq (ack (Max.max m₁ m₂) n) (Max.max (ack m₁ n) (ack m₂ n))","decl":"theorem max_ack_left (m₁ m₂ n : ℕ) : ack (max m₁ m₂) n = max (ack m₁ n) (ack m₂ n) :=\n  (ack_mono_left n).map_max\n\n"}
{"name":"ack_le_ack","module":"Mathlib.Computability.Ackermann","initialProofState":"m₁ m₂ n₁ n₂ : Nat\nhm : LE.le m₁ m₂\nhn : LE.le n₁ n₂\n⊢ LE.le (ack m₁ n₁) (ack m₂ n₂)","decl":"theorem ack_le_ack {m₁ m₂ n₁ n₂ : ℕ} (hm : m₁ ≤ m₂) (hn : n₁ ≤ n₂) : ack m₁ n₁ ≤ ack m₂ n₂ :=\n  (ack_mono_left n₁ hm).trans <| ack_mono_right m₂ hn\n\n"}
{"name":"ack_succ_right_le_ack_succ_left","module":"Mathlib.Computability.Ackermann","initialProofState":"m n : Nat\n⊢ LE.le (ack m (HAdd.hAdd n 1)) (ack (HAdd.hAdd m 1) n)","decl":"theorem ack_succ_right_le_ack_succ_left (m n : ℕ) : ack m (n + 1) ≤ ack (m + 1) n := by\n  cases' n with n n\n  · simp\n  · rw [ack_succ_succ]\n    apply ack_mono_right m (le_trans _ <| add_add_one_le_ack _ n)\n    omega\n\n-- All the inequalities from this point onwards are specific to the main proof.\n"}
{"name":"ack_add_one_sq_lt_ack_add_three","module":"Mathlib.Computability.Ackermann","initialProofState":"m n : Nat\n⊢ LE.le (HPow.hPow (HAdd.hAdd (ack m n) 1) 2) (ack (HAdd.hAdd m 3) n)","decl":"theorem ack_add_one_sq_lt_ack_add_three : ∀ m n, (ack m n + 1) ^ 2 ≤ ack (m + 3) n\n  | 0, n => by simpa using sq_le_two_pow_add_one_minus_three (n + 2)\n  | m + 1, 0 => by\n    rw [ack_succ_zero, ack_succ_zero]\n    apply ack_add_one_sq_lt_ack_add_three\n  | m + 1, n + 1 => by\n    rw [ack_succ_succ, ack_succ_succ]\n    apply (ack_add_one_sq_lt_ack_add_three _ _).trans (ack_mono_right _ <| ack_mono_left _ _)\n    omega\n\n"}
{"name":"ack_ack_lt_ack_max_add_two","module":"Mathlib.Computability.Ackermann","initialProofState":"m n k : Nat\n⊢ LT.lt (ack m (ack n k)) (ack (HAdd.hAdd (Max.max m n) 2) k)","decl":"theorem ack_ack_lt_ack_max_add_two (m n k : ℕ) : ack m (ack n k) < ack (max m n + 2) k :=\n  calc\n    ack m (ack n k) ≤ ack (max m n) (ack n k) := ack_mono_left _ (le_max_left _ _)\n    _ < ack (max m n) (ack (max m n + 1) k) :=\n      ack_strictMono_right _ <| ack_strictMono_left k <| lt_succ_of_le <| le_max_right m n\n    _ = ack (max m n + 1) (k + 1) := (ack_succ_succ _ _).symm\n    _ ≤ ack (max m n + 2) k := ack_succ_right_le_ack_succ_left _ _\n\n"}
{"name":"ack_add_one_sq_lt_ack_add_four","module":"Mathlib.Computability.Ackermann","initialProofState":"m n : Nat\n⊢ LT.lt (ack m (HPow.hPow (HAdd.hAdd n 1) 2)) (ack (HAdd.hAdd m 4) n)","decl":"theorem ack_add_one_sq_lt_ack_add_four (m n : ℕ) : ack m ((n + 1) ^ 2) < ack (m + 4) n :=\n  calc\n    ack m ((n + 1) ^ 2) < ack m ((ack m n + 1) ^ 2) :=\n      ack_strictMono_right m <| Nat.pow_lt_pow_left (succ_lt_succ <| lt_ack_right m n) two_ne_zero\n    _ ≤ ack m (ack (m + 3) n) := ack_mono_right m <| ack_add_one_sq_lt_ack_add_three m n\n    _ ≤ ack (m + 2) (ack (m + 3) n) := ack_mono_left _ <| by omega\n    _ = ack (m + 3) (n + 1) := (ack_succ_succ _ n).symm\n    _ ≤ ack (m + 4) n := ack_succ_right_le_ack_succ_left _ n\n\n"}
{"name":"ack_pair_lt","module":"Mathlib.Computability.Ackermann","initialProofState":"m n k : Nat\n⊢ LT.lt (ack m (Nat.pair n k)) (ack (HAdd.hAdd m 4) (Max.max n k))","decl":"theorem ack_pair_lt (m n k : ℕ) : ack m (pair n k) < ack (m + 4) (max n k) :=\n  (ack_strictMono_right m <| pair_lt_max_add_one_sq n k).trans <|\n    ack_add_one_sq_lt_ack_add_four _ _\n\n"}
{"name":"exists_lt_ack_of_nat_primrec","module":"Mathlib.Computability.Ackermann","initialProofState":"f : Nat → Nat\nhf : Nat.Primrec f\n⊢ Exists fun m => ∀ (n : Nat), LT.lt (f n) (ack m n)","decl":"/-- If `f` is primitive recursive, there exists `m` such that `f n < ack m n` for all `n`. -/\ntheorem exists_lt_ack_of_nat_primrec {f : ℕ → ℕ} (hf : Nat.Primrec f) :\n    ∃ m, ∀ n, f n < ack m n := by\n  induction' hf with f g hf hg IHf IHg f g hf hg IHf IHg f g hf hg IHf IHg\n  -- Zero function:\n  · exact ⟨0, ack_pos 0⟩\n  -- Successor function:\n  · refine ⟨1, fun n => ?_⟩\n    rw [succ_eq_one_add]\n    apply add_lt_ack\n  -- Left projection:\n  · refine ⟨0, fun n => ?_⟩\n    rw [ack_zero, Nat.lt_succ_iff]\n    exact unpair_left_le n\n  -- Right projection:\n  · refine ⟨0, fun n => ?_⟩\n    rw [ack_zero, Nat.lt_succ_iff]\n    exact unpair_right_le n\n  all_goals cases' IHf with a ha; cases' IHg with b hb\n  -- Pairing:\n  · refine\n      ⟨max a b + 3, fun n =>\n        (pair_lt_max_add_one_sq _ _).trans_le <|\n          (Nat.pow_le_pow_left (add_le_add_right ?_ _) 2).trans <|\n            ack_add_one_sq_lt_ack_add_three _ _⟩\n    rw [max_ack_left]\n    exact max_le_max (ha n).le (hb n).le\n  -- Composition:\n  · exact\n      ⟨max a b + 2, fun n =>\n        (ha _).trans <| (ack_strictMono_right a <| hb n).trans <| ack_ack_lt_ack_max_add_two a b n⟩\n  -- Primitive recursion operator:\n  · -- We prove this simpler inequality first.\n    have :\n      ∀ {m n},\n        rec (f m) (fun y IH => g <| pair m <| pair y IH) n < ack (max a b + 9) (m + n) := by\n      intro m n\n      -- We induct on n.\n      induction' n with n IH\n      -- The base case is easy.\n      · apply (ha m).trans (ack_strictMono_left m <| (le_max_left a b).trans_lt _)\n        omega\n      · -- We get rid of the first `pair`.\n        simp only\n        apply (hb _).trans ((ack_pair_lt _ _ _).trans_le _)\n        -- If m is the maximum, we get a very weak inequality.\n        cases' lt_or_le _ m with h₁ h₁\n        · rw [max_eq_left h₁.le]\n          exact ack_le_ack (Nat.add_le_add (le_max_right a b) <| by norm_num)\n                           (self_le_add_right m _)\n        rw [max_eq_right h₁]\n        -- We get rid of the second `pair`.\n        apply (ack_pair_lt _ _ _).le.trans\n        -- If n is the maximum, we get a very weak inequality.\n        cases' lt_or_le _ n with h₂ h₂\n        · rw [max_eq_left h₂.le, add_assoc]\n          exact\n            ack_le_ack (Nat.add_le_add (le_max_right a b) <| by norm_num)\n              ((le_succ n).trans <| self_le_add_left _ _)\n        rw [max_eq_right h₂]\n        -- We now use the inductive hypothesis, and some simple algebraic manipulation.\n        apply (ack_strictMono_right _ IH).le.trans\n        rw [add_succ m, add_succ _ 8, succ_eq_add_one, succ_eq_add_one,\n            ack_succ_succ (_ + 8), add_assoc]\n        exact ack_mono_left _ (Nat.add_le_add (le_max_right a b) le_rfl)\n    -- The proof is now simple.\n    exact ⟨max a b + 9, fun n => this.trans_le <| ack_mono_right _ <| unpair_add_le n⟩\n\n"}
{"name":"not_nat_primrec_ack_self","module":"Mathlib.Computability.Ackermann","initialProofState":"⊢ Not (Nat.Primrec fun n => ack n n)","decl":"theorem not_nat_primrec_ack_self : ¬Nat.Primrec fun n => ack n n := fun h => by\n  cases' exists_lt_ack_of_nat_primrec h with m hm\n  exact (hm m).false\n\n"}
{"name":"not_primrec_ack_self","module":"Mathlib.Computability.Ackermann","initialProofState":"⊢ Not (Primrec fun n => ack n n)","decl":"theorem not_primrec_ack_self : ¬Primrec fun n => ack n n := by\n  rw [Primrec.nat_iff]\n  exact not_nat_primrec_ack_self\n\n"}
{"name":"not_primrec₂_ack","module":"Mathlib.Computability.Ackermann","initialProofState":"⊢ Not (Primrec₂ ack)","decl":"/-- The Ackermann function is not primitive recursive. -/\ntheorem not_primrec₂_ack : ¬Primrec₂ ack := fun h =>\n  not_primrec_ack_self <| h.comp Primrec.id Primrec.id\n"}
