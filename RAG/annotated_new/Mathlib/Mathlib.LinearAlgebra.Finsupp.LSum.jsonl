{"name":"Finsupp.smul_sum","module":"Mathlib.LinearAlgebra.Finsupp.LSum","initialProofState":"α : Type u_1\nβ : Type u_2\nR : Type u_3\nM : Type u_4\ninst✝² : Zero β\ninst✝¹ : AddCommMonoid M\ninst✝ : DistribSMul R M\nv : Finsupp α β\nc : R\nh : α → β → M\n⊢ Eq (HSMul.hSMul c (v.sum h)) (v.sum fun a b => HSMul.hSMul c (h a b))","decl":"theorem smul_sum [Zero β] [AddCommMonoid M] [DistribSMul R M] {v : α →₀ β} {c : R} {h : α → β → M} :\n    c • v.sum h = v.sum fun a b => c • h a b :=\n  Finset.smul_sum\n\n"}
{"name":"Finsupp.sum_smul_index_linearMap'","module":"Mathlib.LinearAlgebra.Finsupp.LSum","initialProofState":"α : Type u_1\nR : Type u_3\nM : Type u_4\nM₂ : Type u_5\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : AddCommMonoid M₂\ninst✝ : Module R M₂\nv : Finsupp α M\nc : R\nh : α → LinearMap (RingHom.id R) M M₂\n⊢ Eq ((HSMul.hSMul c v).sum fun a => ⇑(h a)) (HSMul.hSMul c (v.sum fun a => ⇑(h a)))","decl":"@[simp]\ntheorem sum_smul_index_linearMap' [Semiring R] [AddCommMonoid M] [Module R M] [AddCommMonoid M₂]\n    [Module R M₂] {v : α →₀ M} {c : R} {h : α → M →ₗ[R] M₂} :\n    ((c • v).sum fun a => h a) = c • v.sum fun a => h a := by\n  rw [Finsupp.sum_smul_index', Finsupp.smul_sum]\n  · simp only [map_smul]\n  · intro i\n    exact (h i).map_zero\n\n"}
{"name":"LinearMap.CompatibleSMul.finsupp_dom","module":"Mathlib.LinearAlgebra.Finsupp.LSum","initialProofState":"R : Type u_7\nS : Type u_8\nM : Type u_9\nN : Type u_10\nι : Type u_11\ninst✝⁷ : Semiring S\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : AddCommMonoid N\ninst✝⁴ : Module S M\ninst✝³ : Module S N\ninst✝² : SMulZeroClass R M\ninst✝¹ : DistribSMul R N\ninst✝ : LinearMap.CompatibleSMul M N R S\n⊢ LinearMap.CompatibleSMul (Finsupp ι M) N R S","decl":"instance _root_.LinearMap.CompatibleSMul.finsupp_dom [SMulZeroClass R M] [DistribSMul R N]\n    [LinearMap.CompatibleSMul M N R S] : LinearMap.CompatibleSMul (ι →₀ M) N R S where\n  map_smul f r m := by\n    conv_rhs => rw [← sum_single m, map_finsupp_sum, smul_sum]\n    erw [← sum_single (r • m), sum_mapRange_index single_zero, map_finsupp_sum]\n    congr; ext i m; exact (f.comp <| lsingle i).map_smul_of_tower r m\n\n"}
{"name":"LinearMap.CompatibleSMul.finsupp_cod","module":"Mathlib.LinearAlgebra.Finsupp.LSum","initialProofState":"R : Type u_7\nS : Type u_8\nM : Type u_9\nN : Type u_10\nι : Type u_11\ninst✝⁷ : Semiring S\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : AddCommMonoid N\ninst✝⁴ : Module S M\ninst✝³ : Module S N\ninst✝² : SMul R M\ninst✝¹ : SMulZeroClass R N\ninst✝ : LinearMap.CompatibleSMul M N R S\n⊢ LinearMap.CompatibleSMul M (Finsupp ι N) R S","decl":"instance _root_.LinearMap.CompatibleSMul.finsupp_cod [SMul R M] [SMulZeroClass R N]\n    [LinearMap.CompatibleSMul M N R S] : LinearMap.CompatibleSMul M (ι →₀ N) R S where\n  map_smul f r m := by ext i; apply ((lapply i).comp f).map_smul_of_tower\n\n"}
{"name":"Finsupp.coe_lsum","module":"Mathlib.LinearAlgebra.Finsupp.LSum","initialProofState":"α : Type u_1\nM : Type u_2\nN : Type u_3\nR : Type u_5\nS : Type u_6\ninst✝⁷ : Semiring R\ninst✝⁶ : Semiring S\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Module R M\ninst✝³ : AddCommMonoid N\ninst✝² : Module R N\ninst✝¹ : Module S N\ninst✝ : SMulCommClass R S N\nf : α → LinearMap (RingHom.id R) M N\n⊢ Eq ⇑((Finsupp.lsum S) f) fun d => d.sum fun i => ⇑(f i)","decl":"@[simp]\ntheorem coe_lsum (f : α → M →ₗ[R] N) : (lsum S f : (α →₀ M) → N) = fun d => d.sum fun i => f i :=\n  rfl\n\n"}
{"name":"Finsupp.lsum_apply","module":"Mathlib.LinearAlgebra.Finsupp.LSum","initialProofState":"α : Type u_1\nM : Type u_2\nN : Type u_3\nR : Type u_5\nS : Type u_6\ninst✝⁷ : Semiring R\ninst✝⁶ : Semiring S\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Module R M\ninst✝³ : AddCommMonoid N\ninst✝² : Module R N\ninst✝¹ : Module S N\ninst✝ : SMulCommClass R S N\nf : α → LinearMap (RingHom.id R) M N\nl : Finsupp α M\n⊢ Eq (((Finsupp.lsum S) f) l) (l.sum fun b => ⇑(f b))","decl":"theorem lsum_apply (f : α → M →ₗ[R] N) (l : α →₀ M) : Finsupp.lsum S f l = l.sum fun b => f b :=\n  rfl\n\n"}
{"name":"Finsupp.lsum_single","module":"Mathlib.LinearAlgebra.Finsupp.LSum","initialProofState":"α : Type u_1\nM : Type u_2\nN : Type u_3\nR : Type u_5\nS : Type u_6\ninst✝⁷ : Semiring R\ninst✝⁶ : Semiring S\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Module R M\ninst✝³ : AddCommMonoid N\ninst✝² : Module R N\ninst✝¹ : Module S N\ninst✝ : SMulCommClass R S N\nf : α → LinearMap (RingHom.id R) M N\ni : α\nm : M\n⊢ Eq (((Finsupp.lsum S) f) (Finsupp.single i m)) ((f i) m)","decl":"theorem lsum_single (f : α → M →ₗ[R] N) (i : α) (m : M) :\n    Finsupp.lsum S f (Finsupp.single i m) = f i m :=\n  Finsupp.sum_single_index (f i).map_zero\n\n"}
{"name":"Finsupp.lsum_comp_lsingle","module":"Mathlib.LinearAlgebra.Finsupp.LSum","initialProofState":"α : Type u_1\nM : Type u_2\nN : Type u_3\nR : Type u_5\nS : Type u_6\ninst✝⁷ : Semiring R\ninst✝⁶ : Semiring S\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Module R M\ninst✝³ : AddCommMonoid N\ninst✝² : Module R N\ninst✝¹ : Module S N\ninst✝ : SMulCommClass R S N\nf : α → LinearMap (RingHom.id R) M N\ni : α\n⊢ Eq (((Finsupp.lsum S) f).comp (Finsupp.lsingle i)) (f i)","decl":"@[simp] theorem lsum_comp_lsingle (f : α → M →ₗ[R] N) (i : α) :\n    Finsupp.lsum S f ∘ₗ lsingle i = f i := by ext; simp\n\n"}
{"name":"Finsupp.lsum_symm_apply","module":"Mathlib.LinearAlgebra.Finsupp.LSum","initialProofState":"α : Type u_1\nM : Type u_2\nN : Type u_3\nR : Type u_5\nS : Type u_6\ninst✝⁷ : Semiring R\ninst✝⁶ : Semiring S\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Module R M\ninst✝³ : AddCommMonoid N\ninst✝² : Module R N\ninst✝¹ : Module S N\ninst✝ : SMulCommClass R S N\nf : LinearMap (RingHom.id R) (Finsupp α M) N\nx : α\n⊢ Eq ((Finsupp.lsum S).symm f x) (f.comp (Finsupp.lsingle x))","decl":"theorem lsum_symm_apply (f : (α →₀ M) →ₗ[R] N) (x : α) : (lsum S).symm f x = f.comp (lsingle x) :=\n  rfl\n\n"}
{"name":"Finsupp.lift_symm_apply","module":"Mathlib.LinearAlgebra.Finsupp.LSum","initialProofState":"M : Type u_2\nR : Type u_5\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nX : Type u_7\nf : LinearMap (RingHom.id R) (Finsupp X R) M\nx : X\n⊢ Eq ((Finsupp.lift M R X).symm f x) (f (Finsupp.single x 1))","decl":"@[simp]\ntheorem lift_symm_apply (f) (x) : ((lift M R X).symm f) x = f (single x 1) :=\n  rfl\n\n"}
{"name":"Finsupp.lift_apply","module":"Mathlib.LinearAlgebra.Finsupp.LSum","initialProofState":"M : Type u_2\nR : Type u_5\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nX : Type u_7\nf : X → M\ng : Finsupp X R\n⊢ Eq (((Finsupp.lift M R X) f) g) (g.sum fun x r => HSMul.hSMul r (f x))","decl":"@[simp]\ntheorem lift_apply (f) (g) : ((lift M R X) f) g = g.sum fun x r => r • f x :=\n  rfl\n\n"}
{"name":"Finsupp.llift_apply","module":"Mathlib.LinearAlgebra.Finsupp.LSum","initialProofState":"M : Type u_2\nR : Type u_5\nS : Type u_6\ninst✝⁵ : Semiring R\ninst✝⁴ : Semiring S\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\nX : Type u_7\ninst✝¹ : Module S M\ninst✝ : SMulCommClass R S M\nf : X → M\nx : Finsupp X R\n⊢ Eq (((Finsupp.llift M R S X) f) x) (((Finsupp.lift M R X) f) x)","decl":"@[simp]\ntheorem llift_apply (f : X → M) (x : X →₀ R) : llift M R S X f x = lift M R X f x :=\n  rfl\n\n"}
{"name":"Finsupp.llift_symm_apply","module":"Mathlib.LinearAlgebra.Finsupp.LSum","initialProofState":"M : Type u_2\nR : Type u_5\nS : Type u_6\ninst✝⁵ : Semiring R\ninst✝⁴ : Semiring S\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\nX : Type u_7\ninst✝¹ : Module S M\ninst✝ : SMulCommClass R S M\nf : LinearMap (RingHom.id R) (Finsupp X R) M\nx : X\n⊢ Eq ((Finsupp.llift M R S X).symm f x) (f (Finsupp.single x 1))","decl":"@[simp]\ntheorem llift_symm_apply (f : (X →₀ R) →ₗ[R] M) (x : X) :\n    (llift M R S X).symm f x = f (single x 1) :=\n  rfl\n\n"}
{"name":"Finsupp.domLCongr_apply","module":"Mathlib.LinearAlgebra.Finsupp.LSum","initialProofState":"M : Type u_2\nR : Type u_5\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nα₁ : Type u_7\nα₂ : Type u_8\ne : Equiv α₁ α₂\nv : Finsupp α₁ M\n⊢ Eq ((Finsupp.domLCongr e) v) ((Finsupp.domCongr e) v)","decl":"@[simp]\ntheorem domLCongr_apply {α₁ : Type*} {α₂ : Type*} (e : α₁ ≃ α₂) (v : α₁ →₀ M) :\n    (Finsupp.domLCongr e : _ ≃ₗ[R] _) v = Finsupp.domCongr e v :=\n  rfl\n\n"}
{"name":"Finsupp.domLCongr_refl","module":"Mathlib.LinearAlgebra.Finsupp.LSum","initialProofState":"α : Type u_1\nM : Type u_2\nR : Type u_5\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\n⊢ Eq (Finsupp.domLCongr (Equiv.refl α)) (LinearEquiv.refl R (Finsupp α M))","decl":"@[simp]\ntheorem domLCongr_refl : Finsupp.domLCongr (Equiv.refl α) = LinearEquiv.refl R (α →₀ M) :=\n  LinearEquiv.ext fun _ => equivMapDomain_refl _\n\n"}
{"name":"Finsupp.domLCongr_trans","module":"Mathlib.LinearAlgebra.Finsupp.LSum","initialProofState":"M : Type u_2\nR : Type u_5\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nα₁ : Type u_7\nα₂ : Type u_8\nα₃ : Type u_9\nf : Equiv α₁ α₂\nf₂ : Equiv α₂ α₃\n⊢ Eq ((Finsupp.domLCongr f).trans (Finsupp.domLCongr f₂)) (Finsupp.domLCongr (f.trans f₂))","decl":"theorem domLCongr_trans {α₁ α₂ α₃ : Type*} (f : α₁ ≃ α₂) (f₂ : α₂ ≃ α₃) :\n    (Finsupp.domLCongr f).trans (Finsupp.domLCongr f₂) =\n      (Finsupp.domLCongr (f.trans f₂) : (_ →₀ M) ≃ₗ[R] _) :=\n  LinearEquiv.ext fun _ => (equivMapDomain_trans _ _ _).symm\n\n"}
{"name":"Finsupp.domLCongr_symm","module":"Mathlib.LinearAlgebra.Finsupp.LSum","initialProofState":"M : Type u_2\nR : Type u_5\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nα₁ : Type u_7\nα₂ : Type u_8\nf : Equiv α₁ α₂\n⊢ Eq (Finsupp.domLCongr f).symm (Finsupp.domLCongr f.symm)","decl":"@[simp]\ntheorem domLCongr_symm {α₁ α₂ : Type*} (f : α₁ ≃ α₂) :\n    ((Finsupp.domLCongr f).symm : (_ →₀ M) ≃ₗ[R] _) = Finsupp.domLCongr f.symm :=\n  LinearEquiv.ext fun _ => rfl\n\n"}
{"name":"Finsupp.domLCongr_single","module":"Mathlib.LinearAlgebra.Finsupp.LSum","initialProofState":"M : Type u_2\nR : Type u_5\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nα₁ : Type u_7\nα₂ : Type u_8\ne : Equiv α₁ α₂\ni : α₁\nm : M\n⊢ Eq ((Finsupp.domLCongr e) (Finsupp.single i m)) (Finsupp.single (e i) m)","decl":"theorem domLCongr_single {α₁ : Type*} {α₂ : Type*} (e : α₁ ≃ α₂) (i : α₁) (m : M) :\n    (Finsupp.domLCongr e : _ ≃ₗ[R] _) (Finsupp.single i m) = Finsupp.single (e i) m := by\n  simp\n\n"}
{"name":"Finsupp.lcongr_single","module":"Mathlib.LinearAlgebra.Finsupp.LSum","initialProofState":"M : Type u_2\nN : Type u_3\nR : Type u_5\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : AddCommMonoid N\ninst✝ : Module R N\nι : Type u_7\nκ : Type u_8\ne₁ : Equiv ι κ\ne₂ : LinearEquiv (RingHom.id R) M N\ni : ι\nm : M\n⊢ Eq ((Finsupp.lcongr e₁ e₂) (Finsupp.single i m)) (Finsupp.single (e₁ i) (e₂ m))","decl":"@[simp]\ntheorem lcongr_single {ι κ : Sort _} (e₁ : ι ≃ κ) (e₂ : M ≃ₗ[R] N) (i : ι) (m : M) :\n    lcongr e₁ e₂ (Finsupp.single i m) = Finsupp.single (e₁ i) (e₂ m) := by simp [lcongr]\n\n"}
{"name":"Finsupp.lcongr_apply_apply","module":"Mathlib.LinearAlgebra.Finsupp.LSum","initialProofState":"M : Type u_2\nN : Type u_3\nR : Type u_5\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : AddCommMonoid N\ninst✝ : Module R N\nι : Type u_7\nκ : Type u_8\ne₁ : Equiv ι κ\ne₂ : LinearEquiv (RingHom.id R) M N\nf : Finsupp ι M\nk : κ\n⊢ Eq (((Finsupp.lcongr e₁ e₂) f) k) (e₂ (f (e₁.symm k)))","decl":"@[simp]\ntheorem lcongr_apply_apply {ι κ : Sort _} (e₁ : ι ≃ κ) (e₂ : M ≃ₗ[R] N) (f : ι →₀ M) (k : κ) :\n    lcongr e₁ e₂ f k = e₂ (f (e₁.symm k)) :=\n  rfl\n\n"}
{"name":"Finsupp.lcongr_symm_single","module":"Mathlib.LinearAlgebra.Finsupp.LSum","initialProofState":"M : Type u_2\nN : Type u_3\nR : Type u_5\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : AddCommMonoid N\ninst✝ : Module R N\nι : Type u_7\nκ : Type u_8\ne₁ : Equiv ι κ\ne₂ : LinearEquiv (RingHom.id R) M N\nk : κ\nn : N\n⊢ Eq ((Finsupp.lcongr e₁ e₂).symm (Finsupp.single k n)) (Finsupp.single (e₁.symm k) (e₂.symm n))","decl":"theorem lcongr_symm_single {ι κ : Sort _} (e₁ : ι ≃ κ) (e₂ : M ≃ₗ[R] N) (k : κ) (n : N) :\n    (lcongr e₁ e₂).symm (Finsupp.single k n) = Finsupp.single (e₁.symm k) (e₂.symm n) := by\n  apply_fun (lcongr e₁ e₂ : (ι →₀ M) → (κ →₀ N)) using (lcongr e₁ e₂).injective\n  simp\n\n"}
{"name":"Finsupp.lcongr_symm","module":"Mathlib.LinearAlgebra.Finsupp.LSum","initialProofState":"M : Type u_2\nN : Type u_3\nR : Type u_5\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : AddCommMonoid N\ninst✝ : Module R N\nι : Type u_7\nκ : Type u_8\ne₁ : Equiv ι κ\ne₂ : LinearEquiv (RingHom.id R) M N\n⊢ Eq (Finsupp.lcongr e₁ e₂).symm (Finsupp.lcongr e₁.symm e₂.symm)","decl":"@[simp]\ntheorem lcongr_symm {ι κ : Sort _} (e₁ : ι ≃ κ) (e₂ : M ≃ₗ[R] N) :\n    (lcongr e₁ e₂).symm = lcongr e₁.symm e₂.symm := by\n  ext\n  rfl\n\n"}
{"name":"Submodule.finsupp_sum_mem","module":"Mathlib.LinearAlgebra.Finsupp.LSum","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝³ : Semiring R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\nι : Type u_4\nβ : Type u_5\ninst✝ : Zero β\nS : Submodule R M\nf : Finsupp ι β\ng : ι → β → M\nh : ∀ (c : ι), Ne (f c) 0 → Membership.mem S (g c (f c))\n⊢ Membership.mem S (f.sum g)","decl":"protected theorem Submodule.finsupp_sum_mem {ι β : Type*} [Zero β] (S : Submodule R M) (f : ι →₀ β)\n    (g : ι → β → M) (h : ∀ c, f c ≠ 0 → g c (f c) ∈ S) : f.sum g ∈ S :=\n  AddSubmonoidClass.finsupp_sum_mem S f g h\n\n"}
{"name":"LinearMap.splittingOfFinsuppSurjective_splits","module":"Mathlib.LinearAlgebra.Finsupp.LSum","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nα : Type u_4\nf : LinearMap (RingHom.id R) M (Finsupp α R)\ns : Function.Surjective ⇑f\n⊢ Eq (f.comp (f.splittingOfFinsuppSurjective s)) LinearMap.id","decl":"theorem splittingOfFinsuppSurjective_splits (f : M →ₗ[R] α →₀ R) (s : Surjective f) :\n    f.comp (splittingOfFinsuppSurjective f s) = LinearMap.id := by\n  ext x\n  dsimp [splittingOfFinsuppSurjective]\n  congr\n  rw [sum_single_index, one_smul]\n  · exact (s (Finsupp.single x 1)).choose_spec\n  · rw [zero_smul]\n\n"}
{"name":"LinearMap.leftInverse_splittingOfFinsuppSurjective","module":"Mathlib.LinearAlgebra.Finsupp.LSum","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nα : Type u_4\nf : LinearMap (RingHom.id R) M (Finsupp α R)\ns : Function.Surjective ⇑f\n⊢ Function.LeftInverse ⇑f ⇑(f.splittingOfFinsuppSurjective s)","decl":"theorem leftInverse_splittingOfFinsuppSurjective (f : M →ₗ[R] α →₀ R) (s : Surjective f) :\n    LeftInverse f (splittingOfFinsuppSurjective f s) := fun g =>\n  LinearMap.congr_fun (splittingOfFinsuppSurjective_splits f s) g\n\n"}
{"name":"LinearMap.splittingOfFinsuppSurjective_injective","module":"Mathlib.LinearAlgebra.Finsupp.LSum","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nα : Type u_4\nf : LinearMap (RingHom.id R) M (Finsupp α R)\ns : Function.Surjective ⇑f\n⊢ Function.Injective ⇑(f.splittingOfFinsuppSurjective s)","decl":"theorem splittingOfFinsuppSurjective_injective (f : M →ₗ[R] α →₀ R) (s : Surjective f) :\n    Injective (splittingOfFinsuppSurjective f s) :=\n  (leftInverse_splittingOfFinsuppSurjective f s).injective\n\n"}
{"name":"LinearMap.coe_finsupp_sum","module":"Mathlib.LinearAlgebra.Finsupp.LSum","initialProofState":"R : Type u_4\nR₂ : Type u_5\nM : Type u_6\nM₂ : Type u_7\nι : Type u_8\ninst✝⁶ : Semiring R\ninst✝⁵ : Semiring R₂\ninst✝⁴ : AddCommMonoid M\ninst✝³ : AddCommMonoid M₂\nσ₁₂ : RingHom R R₂\ninst✝² : Module R M\ninst✝¹ : Module R₂ M₂\nγ : Type u_9\ninst✝ : Zero γ\nt : Finsupp ι γ\ng : ι → γ → LinearMap σ₁₂ M M₂\n⊢ Eq ⇑(t.sum g) ⇑(t.sum fun i d => g i d)","decl":"theorem coe_finsupp_sum (t : ι →₀ γ) (g : ι → γ → M →ₛₗ[σ₁₂] M₂) :\n    ⇑(t.sum g) = t.sum fun i d => g i d := rfl\n\n"}
{"name":"LinearMap.finsupp_sum_apply","module":"Mathlib.LinearAlgebra.Finsupp.LSum","initialProofState":"R : Type u_4\nR₂ : Type u_5\nM : Type u_6\nM₂ : Type u_7\nι : Type u_8\ninst✝⁶ : Semiring R\ninst✝⁵ : Semiring R₂\ninst✝⁴ : AddCommMonoid M\ninst✝³ : AddCommMonoid M₂\nσ₁₂ : RingHom R R₂\ninst✝² : Module R M\ninst✝¹ : Module R₂ M₂\nγ : Type u_9\ninst✝ : Zero γ\nt : Finsupp ι γ\ng : ι → γ → LinearMap σ₁₂ M M₂\nb : M\n⊢ Eq ((t.sum g) b) (t.sum fun i d => (g i d) b)","decl":"@[simp]\ntheorem finsupp_sum_apply (t : ι →₀ γ) (g : ι → γ → M →ₛₗ[σ₁₂] M₂) (b : M) :\n    (t.sum g) b = t.sum fun i d => g i d b :=\n  sum_apply _ _ _\n\n"}
{"name":"Submodule.mulLeftMap_apply","module":"Mathlib.LinearAlgebra.Finsupp.LSum","initialProofState":"R : Type u_1\ninst✝⁴ : Semiring R\nS : Type u_4\ninst✝³ : Semiring S\ninst✝² : Module R S\ninst✝¹ : SMulCommClass R R S\ninst✝ : SMulCommClass R S S\nM N : Submodule R S\nι : Type u_5\nm : ι → Subtype fun x => Membership.mem M x\nn : Finsupp ι (Subtype fun x => Membership.mem N x)\n⊢ Eq ((Submodule.mulLeftMap N m) n) (n.sum fun i n => HMul.hMul ↑(m i) ↑n)","decl":"theorem mulLeftMap_apply {M N : Submodule R S} {ι : Type*} (m : ι → M) (n : ι →₀ N) :\n    mulLeftMap N m n = Finsupp.sum n fun (i : ι) (n : N) ↦ (m i).1 * n.1 := rfl\n\n"}
{"name":"Submodule.mulLeftMap_apply_single","module":"Mathlib.LinearAlgebra.Finsupp.LSum","initialProofState":"R : Type u_1\ninst✝⁴ : Semiring R\nS : Type u_4\ninst✝³ : Semiring S\ninst✝² : Module R S\ninst✝¹ : SMulCommClass R R S\ninst✝ : SMulCommClass R S S\nM N : Submodule R S\nι : Type u_5\nm : ι → Subtype fun x => Membership.mem M x\ni : ι\nn : Subtype fun x => Membership.mem N x\n⊢ Eq ((Submodule.mulLeftMap N m) (Finsupp.single i n)) (HMul.hMul ↑(m i) ↑n)","decl":"@[simp]\ntheorem mulLeftMap_apply_single {M N : Submodule R S} {ι : Type*} (m : ι → M) (i : ι) (n : N) :\n    mulLeftMap N m (Finsupp.single i n) = (m i).1 * n.1 := by\n  simp [mulLeftMap]\n\n"}
{"name":"Submodule.mulRightMap_apply","module":"Mathlib.LinearAlgebra.Finsupp.LSum","initialProofState":"R : Type u_1\ninst✝⁴ : Semiring R\nS : Type u_4\ninst✝³ : Semiring S\ninst✝² : Module R S\ninst✝¹ : SMulCommClass R R S\ninst✝ : IsScalarTower R S S\nM N : Submodule R S\nι : Type u_5\nn : ι → Subtype fun x => Membership.mem N x\nm : Finsupp ι (Subtype fun x => Membership.mem M x)\n⊢ Eq ((M.mulRightMap n) m) (m.sum fun i m => HMul.hMul ↑m ↑(n i))","decl":"theorem mulRightMap_apply {M N : Submodule R S} {ι : Type*} (n : ι → N) (m : ι →₀ M) :\n    mulRightMap M n m = Finsupp.sum m fun (i : ι) (m : M) ↦ m.1 * (n i).1 := rfl\n\n"}
{"name":"Submodule.mulRightMap_apply_single","module":"Mathlib.LinearAlgebra.Finsupp.LSum","initialProofState":"R : Type u_1\ninst✝⁴ : Semiring R\nS : Type u_4\ninst✝³ : Semiring S\ninst✝² : Module R S\ninst✝¹ : SMulCommClass R R S\ninst✝ : IsScalarTower R S S\nM N : Submodule R S\nι : Type u_5\nn : ι → Subtype fun x => Membership.mem N x\ni : ι\nm : Subtype fun x => Membership.mem M x\n⊢ Eq ((M.mulRightMap n) (Finsupp.single i m)) (HMul.hMul ↑m ↑(n i))","decl":"@[simp]\ntheorem mulRightMap_apply_single {M N : Submodule R S} {ι : Type*} (n : ι → N) (i : ι) (m : M) :\n    mulRightMap M n (Finsupp.single i m) = m.1 * (n i).1 := by\n  simp [mulRightMap]\n\n"}
{"name":"Submodule.mulLeftMap_eq_mulRightMap_of_commute","module":"Mathlib.LinearAlgebra.Finsupp.LSum","initialProofState":"R : Type u_1\ninst✝⁵ : Semiring R\nS : Type u_4\ninst✝⁴ : Semiring S\ninst✝³ : Module R S\ninst✝² : SMulCommClass R R S\ninst✝¹ : IsScalarTower R S S\ninst✝ : SMulCommClass R S S\nM N : Submodule R S\nι : Type u_5\nm : ι → Subtype fun x => Membership.mem M x\nhc : ∀ (i : ι) (n : Subtype fun x => Membership.mem N x), Commute ↑(m i) ↑n\n⊢ Eq (Submodule.mulLeftMap N m) (N.mulRightMap m)","decl":"theorem mulLeftMap_eq_mulRightMap_of_commute [SMulCommClass R S S]\n    {M : Submodule R S} (N : Submodule R S) {ι : Type*} (m : ι → M)\n    (hc : ∀ (i : ι) (n : N), Commute (m i).1 n.1) : mulLeftMap N m = mulRightMap N m := by\n  ext i n; simp [(hc i n).eq]\n\n"}
{"name":"Submodule.mulLeftMap_eq_mulRightMap","module":"Mathlib.LinearAlgebra.Finsupp.LSum","initialProofState":"R : Type u_1\ninst✝⁵ : Semiring R\nS : Type u_5\ninst✝⁴ : CommSemiring S\ninst✝³ : Module R S\ninst✝² : SMulCommClass R R S\ninst✝¹ : SMulCommClass R S S\ninst✝ : IsScalarTower R S S\nM N : Submodule R S\nι : Type u_6\nm : ι → Subtype fun x => Membership.mem M x\n⊢ Eq (Submodule.mulLeftMap N m) (N.mulRightMap m)","decl":"theorem mulLeftMap_eq_mulRightMap {S : Type*} [CommSemiring S] [Module R S] [SMulCommClass R R S]\n    [SMulCommClass R S S] [IsScalarTower R S S] {M : Submodule R S} (N : Submodule R S)\n    {ι : Type*} (m : ι → M) : mulLeftMap N m = mulRightMap N m :=\n  mulLeftMap_eq_mulRightMap_of_commute N m fun _ _ ↦ mul_comm _ _\n\n"}
