{"name":"CategoryTheory.Pretriangulated.isomorphic_distinguished","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\ninst✝³ : CategoryTheory.Limits.HasZeroObject C\ninst✝² : CategoryTheory.HasShift C Int\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nself : CategoryTheory.Pretriangulated C\nT₁ : CategoryTheory.Pretriangulated.Triangle C\na✝ : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T₁\nT₂ : CategoryTheory.Pretriangulated.Triangle C\nx✝ : CategoryTheory.Iso T₂ T₁\n⊢ Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T₂","decl":"/-- A preadditive category `C` with an additive shift, and a class of \"distinguished triangles\"\nrelative to that shift is called pretriangulated if the following hold:\n* Any triangle that is isomorphic to a distinguished triangle is also distinguished.\n* Any triangle of the form `(X,X,0,id,0,0)` is distinguished.\n* For any morphism `f : X ⟶ Y` there exists a distinguished triangle of the form `(X,Y,Z,f,g,h)`.\n* The triangle `(X,Y,Z,f,g,h)` is distinguished if and only if `(Y,Z,X⟦1⟧,g,h,-f⟦1⟧)` is.\n* Given a diagram:\n  ```\n        f       g       h\n    X  ───> Y  ───> Z  ───> X⟦1⟧\n    │       │                │\n    │a      │b               │a⟦1⟧'\n    V       V                V\n    X' ───> Y' ───> Z' ───> X'⟦1⟧\n        f'      g'      h'\n  ```\n  where the left square commutes, and whose rows are distinguished triangles,\n  there exists a morphism `c : Z ⟶ Z'` such that `(a,b,c)` is a triangle morphism.\n-/\n@[stacks 0145]\nclass Pretriangulated [∀ n : ℤ, Functor.Additive (shiftFunctor C n)] where\n  /-- a class of triangle which are called `distinguished` -/\n  distinguishedTriangles : Set (Triangle C)\n  /-- a triangle that is isomorphic to a distinguished triangle is distinguished -/\n  isomorphic_distinguished :\n    ∀ T₁ ∈ distinguishedTriangles, ∀ (T₂) (_ : T₂ ≅ T₁), T₂ ∈ distinguishedTriangles\n  /-- obvious triangles `X ⟶ X ⟶ 0 ⟶ X⟦1⟧` are distinguished -/\n  contractible_distinguished : ∀ X : C, contractibleTriangle X ∈ distinguishedTriangles\n  /-- any morphism `X ⟶ Y` is part of a distinguished triangle `X ⟶ Y ⟶ Z ⟶ X⟦1⟧` -/\n  distinguished_cocone_triangle :\n    ∀ {X Y : C} (f : X ⟶ Y),\n      ∃ (Z : C) (g : Y ⟶ Z) (h : Z ⟶ X⟦(1 : ℤ)⟧), Triangle.mk f g h ∈ distinguishedTriangles\n  /-- a triangle is distinguished iff it is so after rotating it -/\n  rotate_distinguished_triangle :\n    ∀ T : Triangle C, T ∈ distinguishedTriangles ↔ T.rotate ∈ distinguishedTriangles\n  /-- given two distinguished triangle, a commutative square\n        can be extended as morphism of triangles -/\n  complete_distinguished_triangle_morphism :\n    ∀ (T₁ T₂ : Triangle C) (_ : T₁ ∈ distinguishedTriangles) (_ : T₂ ∈ distinguishedTriangles)\n      (a : T₁.obj₁ ⟶ T₂.obj₁) (b : T₁.obj₂ ⟶ T₂.obj₂) (_ : T₁.mor₁ ≫ b = a ≫ T₂.mor₁),\n      ∃ c : T₁.obj₃ ⟶ T₂.obj₃, T₁.mor₂ ≫ c = b ≫ T₂.mor₂ ∧ T₁.mor₃ ≫ a⟦1⟧' = c ≫ T₂.mor₃\n\n\n"}
{"name":"CategoryTheory.Pretriangulated.contractible_distinguished","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\ninst✝³ : CategoryTheory.Limits.HasZeroObject C\ninst✝² : CategoryTheory.HasShift C Int\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nself : CategoryTheory.Pretriangulated C\nX : C\n⊢ Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles (CategoryTheory.Pretriangulated.contractibleTriangle X)","decl":"/-- A preadditive category `C` with an additive shift, and a class of \"distinguished triangles\"\nrelative to that shift is called pretriangulated if the following hold:\n* Any triangle that is isomorphic to a distinguished triangle is also distinguished.\n* Any triangle of the form `(X,X,0,id,0,0)` is distinguished.\n* For any morphism `f : X ⟶ Y` there exists a distinguished triangle of the form `(X,Y,Z,f,g,h)`.\n* The triangle `(X,Y,Z,f,g,h)` is distinguished if and only if `(Y,Z,X⟦1⟧,g,h,-f⟦1⟧)` is.\n* Given a diagram:\n  ```\n        f       g       h\n    X  ───> Y  ───> Z  ───> X⟦1⟧\n    │       │                │\n    │a      │b               │a⟦1⟧'\n    V       V                V\n    X' ───> Y' ───> Z' ───> X'⟦1⟧\n        f'      g'      h'\n  ```\n  where the left square commutes, and whose rows are distinguished triangles,\n  there exists a morphism `c : Z ⟶ Z'` such that `(a,b,c)` is a triangle morphism.\n-/\n@[stacks 0145]\nclass Pretriangulated [∀ n : ℤ, Functor.Additive (shiftFunctor C n)] where\n  /-- a class of triangle which are called `distinguished` -/\n  distinguishedTriangles : Set (Triangle C)\n  /-- a triangle that is isomorphic to a distinguished triangle is distinguished -/\n  isomorphic_distinguished :\n    ∀ T₁ ∈ distinguishedTriangles, ∀ (T₂) (_ : T₂ ≅ T₁), T₂ ∈ distinguishedTriangles\n  /-- obvious triangles `X ⟶ X ⟶ 0 ⟶ X⟦1⟧` are distinguished -/\n  contractible_distinguished : ∀ X : C, contractibleTriangle X ∈ distinguishedTriangles\n  /-- any morphism `X ⟶ Y` is part of a distinguished triangle `X ⟶ Y ⟶ Z ⟶ X⟦1⟧` -/\n  distinguished_cocone_triangle :\n    ∀ {X Y : C} (f : X ⟶ Y),\n      ∃ (Z : C) (g : Y ⟶ Z) (h : Z ⟶ X⟦(1 : ℤ)⟧), Triangle.mk f g h ∈ distinguishedTriangles\n  /-- a triangle is distinguished iff it is so after rotating it -/\n  rotate_distinguished_triangle :\n    ∀ T : Triangle C, T ∈ distinguishedTriangles ↔ T.rotate ∈ distinguishedTriangles\n  /-- given two distinguished triangle, a commutative square\n        can be extended as morphism of triangles -/\n  complete_distinguished_triangle_morphism :\n    ∀ (T₁ T₂ : Triangle C) (_ : T₁ ∈ distinguishedTriangles) (_ : T₂ ∈ distinguishedTriangles)\n      (a : T₁.obj₁ ⟶ T₂.obj₁) (b : T₁.obj₂ ⟶ T₂.obj₂) (_ : T₁.mor₁ ≫ b = a ≫ T₂.mor₁),\n      ∃ c : T₁.obj₃ ⟶ T₂.obj₃, T₁.mor₂ ≫ c = b ≫ T₂.mor₂ ∧ T₁.mor₃ ≫ a⟦1⟧' = c ≫ T₂.mor₃\n\n\n"}
{"name":"CategoryTheory.Pretriangulated.complete_distinguished_triangle_morphism","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\ninst✝³ : CategoryTheory.Limits.HasZeroObject C\ninst✝² : CategoryTheory.HasShift C Int\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nself : CategoryTheory.Pretriangulated C\nT₁ T₂ : CategoryTheory.Pretriangulated.Triangle C\nx✝² : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T₁\nx✝¹ : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T₂\na : Quiver.Hom T₁.obj₁ T₂.obj₁\nb : Quiver.Hom T₁.obj₂ T₂.obj₂\nx✝ : Eq (CategoryTheory.CategoryStruct.comp T₁.mor₁ b) (CategoryTheory.CategoryStruct.comp a T₂.mor₁)\n⊢ Exists fun c => And (Eq (CategoryTheory.CategoryStruct.comp T₁.mor₂ c) (CategoryTheory.CategoryStruct.comp b T₂.mor₂)) (Eq (CategoryTheory.CategoryStruct.comp T₁.mor₃ ((CategoryTheory.shiftFunctor C 1).map a)) (CategoryTheory.CategoryStruct.comp c T₂.mor₃))","decl":"/-- A preadditive category `C` with an additive shift, and a class of \"distinguished triangles\"\nrelative to that shift is called pretriangulated if the following hold:\n* Any triangle that is isomorphic to a distinguished triangle is also distinguished.\n* Any triangle of the form `(X,X,0,id,0,0)` is distinguished.\n* For any morphism `f : X ⟶ Y` there exists a distinguished triangle of the form `(X,Y,Z,f,g,h)`.\n* The triangle `(X,Y,Z,f,g,h)` is distinguished if and only if `(Y,Z,X⟦1⟧,g,h,-f⟦1⟧)` is.\n* Given a diagram:\n  ```\n        f       g       h\n    X  ───> Y  ───> Z  ───> X⟦1⟧\n    │       │                │\n    │a      │b               │a⟦1⟧'\n    V       V                V\n    X' ───> Y' ───> Z' ───> X'⟦1⟧\n        f'      g'      h'\n  ```\n  where the left square commutes, and whose rows are distinguished triangles,\n  there exists a morphism `c : Z ⟶ Z'` such that `(a,b,c)` is a triangle morphism.\n-/\n@[stacks 0145]\nclass Pretriangulated [∀ n : ℤ, Functor.Additive (shiftFunctor C n)] where\n  /-- a class of triangle which are called `distinguished` -/\n  distinguishedTriangles : Set (Triangle C)\n  /-- a triangle that is isomorphic to a distinguished triangle is distinguished -/\n  isomorphic_distinguished :\n    ∀ T₁ ∈ distinguishedTriangles, ∀ (T₂) (_ : T₂ ≅ T₁), T₂ ∈ distinguishedTriangles\n  /-- obvious triangles `X ⟶ X ⟶ 0 ⟶ X⟦1⟧` are distinguished -/\n  contractible_distinguished : ∀ X : C, contractibleTriangle X ∈ distinguishedTriangles\n  /-- any morphism `X ⟶ Y` is part of a distinguished triangle `X ⟶ Y ⟶ Z ⟶ X⟦1⟧` -/\n  distinguished_cocone_triangle :\n    ∀ {X Y : C} (f : X ⟶ Y),\n      ∃ (Z : C) (g : Y ⟶ Z) (h : Z ⟶ X⟦(1 : ℤ)⟧), Triangle.mk f g h ∈ distinguishedTriangles\n  /-- a triangle is distinguished iff it is so after rotating it -/\n  rotate_distinguished_triangle :\n    ∀ T : Triangle C, T ∈ distinguishedTriangles ↔ T.rotate ∈ distinguishedTriangles\n  /-- given two distinguished triangle, a commutative square\n        can be extended as morphism of triangles -/\n  complete_distinguished_triangle_morphism :\n    ∀ (T₁ T₂ : Triangle C) (_ : T₁ ∈ distinguishedTriangles) (_ : T₂ ∈ distinguishedTriangles)\n      (a : T₁.obj₁ ⟶ T₂.obj₁) (b : T₁.obj₂ ⟶ T₂.obj₂) (_ : T₁.mor₁ ≫ b = a ≫ T₂.mor₁),\n      ∃ c : T₁.obj₃ ⟶ T₂.obj₃, T₁.mor₂ ≫ c = b ≫ T₂.mor₂ ∧ T₁.mor₃ ≫ a⟦1⟧' = c ≫ T₂.mor₃\n\n\n"}
{"name":"CategoryTheory.Pretriangulated.rotate_distinguished_triangle","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\ninst✝³ : CategoryTheory.Limits.HasZeroObject C\ninst✝² : CategoryTheory.HasShift C Int\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nself : CategoryTheory.Pretriangulated C\nT : CategoryTheory.Pretriangulated.Triangle C\n⊢ Iff (Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T) (Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T.rotate)","decl":"/-- A preadditive category `C` with an additive shift, and a class of \"distinguished triangles\"\nrelative to that shift is called pretriangulated if the following hold:\n* Any triangle that is isomorphic to a distinguished triangle is also distinguished.\n* Any triangle of the form `(X,X,0,id,0,0)` is distinguished.\n* For any morphism `f : X ⟶ Y` there exists a distinguished triangle of the form `(X,Y,Z,f,g,h)`.\n* The triangle `(X,Y,Z,f,g,h)` is distinguished if and only if `(Y,Z,X⟦1⟧,g,h,-f⟦1⟧)` is.\n* Given a diagram:\n  ```\n        f       g       h\n    X  ───> Y  ───> Z  ───> X⟦1⟧\n    │       │                │\n    │a      │b               │a⟦1⟧'\n    V       V                V\n    X' ───> Y' ───> Z' ───> X'⟦1⟧\n        f'      g'      h'\n  ```\n  where the left square commutes, and whose rows are distinguished triangles,\n  there exists a morphism `c : Z ⟶ Z'` such that `(a,b,c)` is a triangle morphism.\n-/\n@[stacks 0145]\nclass Pretriangulated [∀ n : ℤ, Functor.Additive (shiftFunctor C n)] where\n  /-- a class of triangle which are called `distinguished` -/\n  distinguishedTriangles : Set (Triangle C)\n  /-- a triangle that is isomorphic to a distinguished triangle is distinguished -/\n  isomorphic_distinguished :\n    ∀ T₁ ∈ distinguishedTriangles, ∀ (T₂) (_ : T₂ ≅ T₁), T₂ ∈ distinguishedTriangles\n  /-- obvious triangles `X ⟶ X ⟶ 0 ⟶ X⟦1⟧` are distinguished -/\n  contractible_distinguished : ∀ X : C, contractibleTriangle X ∈ distinguishedTriangles\n  /-- any morphism `X ⟶ Y` is part of a distinguished triangle `X ⟶ Y ⟶ Z ⟶ X⟦1⟧` -/\n  distinguished_cocone_triangle :\n    ∀ {X Y : C} (f : X ⟶ Y),\n      ∃ (Z : C) (g : Y ⟶ Z) (h : Z ⟶ X⟦(1 : ℤ)⟧), Triangle.mk f g h ∈ distinguishedTriangles\n  /-- a triangle is distinguished iff it is so after rotating it -/\n  rotate_distinguished_triangle :\n    ∀ T : Triangle C, T ∈ distinguishedTriangles ↔ T.rotate ∈ distinguishedTriangles\n  /-- given two distinguished triangle, a commutative square\n        can be extended as morphism of triangles -/\n  complete_distinguished_triangle_morphism :\n    ∀ (T₁ T₂ : Triangle C) (_ : T₁ ∈ distinguishedTriangles) (_ : T₂ ∈ distinguishedTriangles)\n      (a : T₁.obj₁ ⟶ T₂.obj₁) (b : T₁.obj₂ ⟶ T₂.obj₂) (_ : T₁.mor₁ ≫ b = a ≫ T₂.mor₁),\n      ∃ c : T₁.obj₃ ⟶ T₂.obj₃, T₁.mor₂ ≫ c = b ≫ T₂.mor₂ ∧ T₁.mor₃ ≫ a⟦1⟧' = c ≫ T₂.mor₃\n\n\n"}
{"name":"CategoryTheory.Pretriangulated.distinguished_cocone_triangle","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\ninst✝³ : CategoryTheory.Limits.HasZeroObject C\ninst✝² : CategoryTheory.HasShift C Int\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nself : CategoryTheory.Pretriangulated C\nX Y : C\nf : Quiver.Hom X Y\n⊢ Exists fun Z => Exists fun g => Exists fun h => Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles (CategoryTheory.Pretriangulated.Triangle.mk f g h)","decl":"/-- A preadditive category `C` with an additive shift, and a class of \"distinguished triangles\"\nrelative to that shift is called pretriangulated if the following hold:\n* Any triangle that is isomorphic to a distinguished triangle is also distinguished.\n* Any triangle of the form `(X,X,0,id,0,0)` is distinguished.\n* For any morphism `f : X ⟶ Y` there exists a distinguished triangle of the form `(X,Y,Z,f,g,h)`.\n* The triangle `(X,Y,Z,f,g,h)` is distinguished if and only if `(Y,Z,X⟦1⟧,g,h,-f⟦1⟧)` is.\n* Given a diagram:\n  ```\n        f       g       h\n    X  ───> Y  ───> Z  ───> X⟦1⟧\n    │       │                │\n    │a      │b               │a⟦1⟧'\n    V       V                V\n    X' ───> Y' ───> Z' ───> X'⟦1⟧\n        f'      g'      h'\n  ```\n  where the left square commutes, and whose rows are distinguished triangles,\n  there exists a morphism `c : Z ⟶ Z'` such that `(a,b,c)` is a triangle morphism.\n-/\n@[stacks 0145]\nclass Pretriangulated [∀ n : ℤ, Functor.Additive (shiftFunctor C n)] where\n  /-- a class of triangle which are called `distinguished` -/\n  distinguishedTriangles : Set (Triangle C)\n  /-- a triangle that is isomorphic to a distinguished triangle is distinguished -/\n  isomorphic_distinguished :\n    ∀ T₁ ∈ distinguishedTriangles, ∀ (T₂) (_ : T₂ ≅ T₁), T₂ ∈ distinguishedTriangles\n  /-- obvious triangles `X ⟶ X ⟶ 0 ⟶ X⟦1⟧` are distinguished -/\n  contractible_distinguished : ∀ X : C, contractibleTriangle X ∈ distinguishedTriangles\n  /-- any morphism `X ⟶ Y` is part of a distinguished triangle `X ⟶ Y ⟶ Z ⟶ X⟦1⟧` -/\n  distinguished_cocone_triangle :\n    ∀ {X Y : C} (f : X ⟶ Y),\n      ∃ (Z : C) (g : Y ⟶ Z) (h : Z ⟶ X⟦(1 : ℤ)⟧), Triangle.mk f g h ∈ distinguishedTriangles\n  /-- a triangle is distinguished iff it is so after rotating it -/\n  rotate_distinguished_triangle :\n    ∀ T : Triangle C, T ∈ distinguishedTriangles ↔ T.rotate ∈ distinguishedTriangles\n  /-- given two distinguished triangle, a commutative square\n        can be extended as morphism of triangles -/\n  complete_distinguished_triangle_morphism :\n    ∀ (T₁ T₂ : Triangle C) (_ : T₁ ∈ distinguishedTriangles) (_ : T₂ ∈ distinguishedTriangles)\n      (a : T₁.obj₁ ⟶ T₂.obj₁) (b : T₁.obj₂ ⟶ T₂.obj₂) (_ : T₁.mor₁ ≫ b = a ≫ T₂.mor₁),\n      ∃ c : T₁.obj₃ ⟶ T₂.obj₃, T₁.mor₂ ≫ c = b ≫ T₂.mor₂ ∧ T₁.mor₃ ≫ a⟦1⟧' = c ≫ T₂.mor₃\n\n\n"}
{"name":"CategoryTheory.Pretriangulated.distinguished_iff_of_iso","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\ninst✝³ : CategoryTheory.Limits.HasZeroObject C\ninst✝² : CategoryTheory.HasShift C Int\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nhC : CategoryTheory.Pretriangulated C\nT₁ T₂ : CategoryTheory.Pretriangulated.Triangle C\ne : CategoryTheory.Iso T₁ T₂\n⊢ Iff (Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T₁) (Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T₂)","decl":"lemma distinguished_iff_of_iso {T₁ T₂ : Triangle C} (e : T₁ ≅ T₂) :\n    (T₁ ∈ distTriang C) ↔ T₂ ∈ distTriang C :=\n  ⟨fun hT₁ => isomorphic_distinguished _ hT₁ _ e.symm,\n    fun hT₂ => isomorphic_distinguished _ hT₂ _ e⟩\n\n"}
{"name":"CategoryTheory.Pretriangulated.rot_of_distTriang","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\ninst✝³ : CategoryTheory.Limits.HasZeroObject C\ninst✝² : CategoryTheory.HasShift C Int\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nhC : CategoryTheory.Pretriangulated C\nT : CategoryTheory.Pretriangulated.Triangle C\nH : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T\n⊢ Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T.rotate","decl":"/-- Given any distinguished triangle `T`, then we know `T.rotate` is also distinguished.\n-/\ntheorem rot_of_distTriang (T : Triangle C) (H : T ∈ distTriang C) : T.rotate ∈ distTriang C :=\n  (rotate_distinguished_triangle T).mp H\n\n"}
{"name":"CategoryTheory.Pretriangulated.inv_rot_of_distTriang","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\ninst✝³ : CategoryTheory.Limits.HasZeroObject C\ninst✝² : CategoryTheory.HasShift C Int\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nhC : CategoryTheory.Pretriangulated C\nT : CategoryTheory.Pretriangulated.Triangle C\nH : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T\n⊢ Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T.invRotate","decl":"/-- Given any distinguished triangle `T`, then we know `T.inv_rotate` is also distinguished.\n-/\ntheorem inv_rot_of_distTriang (T : Triangle C) (H : T ∈ distTriang C) :\n    T.invRotate ∈ distTriang C :=\n  (rotate_distinguished_triangle T.invRotate).mpr\n    (isomorphic_distinguished T H T.invRotate.rotate (invRotCompRot.app T))\n\n"}
{"name":"CategoryTheory.Pretriangulated.comp_distTriang_mor_zero₁₂","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\ninst✝³ : CategoryTheory.Limits.HasZeroObject C\ninst✝² : CategoryTheory.HasShift C Int\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nhC : CategoryTheory.Pretriangulated C\nT : CategoryTheory.Pretriangulated.Triangle C\nH : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T\n⊢ Eq (CategoryTheory.CategoryStruct.comp T.mor₁ T.mor₂) 0","decl":"/-- Given any distinguished triangle\n```\n      f       g       h\n  X  ───> Y  ───> Z  ───> X⟦1⟧\n```\nthe composition `f ≫ g = 0`. -/\n@[reassoc, stacks 0146]\ntheorem comp_distTriang_mor_zero₁₂ (T) (H : T ∈ (distTriang C)) : T.mor₁ ≫ T.mor₂ = 0 := by\n  obtain ⟨c, hc⟩ :=\n    complete_distinguished_triangle_morphism _ _ (contractible_distinguished T.obj₁) H (𝟙 T.obj₁)\n      T.mor₁ rfl\n  simpa only [contractibleTriangle_mor₂, zero_comp] using hc.left.symm\n\n"}
{"name":"CategoryTheory.Pretriangulated.comp_distTriang_mor_zero₁₂_assoc","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\ninst✝³ : CategoryTheory.Limits.HasZeroObject C\ninst✝² : CategoryTheory.HasShift C Int\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nhC : CategoryTheory.Pretriangulated C\nT : CategoryTheory.Pretriangulated.Triangle C\nH : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T\nZ : C\nh : Quiver.Hom T.obj₃ Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp T.mor₁ (CategoryTheory.CategoryStruct.comp T.mor₂ h)) (CategoryTheory.CategoryStruct.comp 0 h)","decl":"/-- Given any distinguished triangle\n```\n      f       g       h\n  X  ───> Y  ───> Z  ───> X⟦1⟧\n```\nthe composition `f ≫ g = 0`. -/\n@[reassoc, stacks 0146]\ntheorem comp_distTriang_mor_zero₁₂ (T) (H : T ∈ (distTriang C)) : T.mor₁ ≫ T.mor₂ = 0 := by\n  obtain ⟨c, hc⟩ :=\n    complete_distinguished_triangle_morphism _ _ (contractible_distinguished T.obj₁) H (𝟙 T.obj₁)\n      T.mor₁ rfl\n  simpa only [contractibleTriangle_mor₂, zero_comp] using hc.left.symm\n\n"}
{"name":"CategoryTheory.Pretriangulated.comp_distTriang_mor_zero₂₃","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\ninst✝³ : CategoryTheory.Limits.HasZeroObject C\ninst✝² : CategoryTheory.HasShift C Int\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nhC : CategoryTheory.Pretriangulated C\nT : CategoryTheory.Pretriangulated.Triangle C\nH : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T\n⊢ Eq (CategoryTheory.CategoryStruct.comp T.mor₂ T.mor₃) 0","decl":"/-- Given any distinguished triangle\n```\n      f       g       h\n  X  ───> Y  ───> Z  ───> X⟦1⟧\n```\nthe composition `g ≫ h = 0`. -/\n@[reassoc, stacks 0146]\ntheorem comp_distTriang_mor_zero₂₃ (T : Triangle C) (H : T ∈ distTriang C) :\n    T.mor₂ ≫ T.mor₃ = 0 :=\n  comp_distTriang_mor_zero₁₂ T.rotate (rot_of_distTriang T H)\n\n"}
{"name":"CategoryTheory.Pretriangulated.comp_distTriang_mor_zero₂₃_assoc","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\ninst✝³ : CategoryTheory.Limits.HasZeroObject C\ninst✝² : CategoryTheory.HasShift C Int\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nhC : CategoryTheory.Pretriangulated C\nT : CategoryTheory.Pretriangulated.Triangle C\nH : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T\nZ : C\nh : Quiver.Hom ((CategoryTheory.shiftFunctor C 1).obj T.obj₁) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp T.mor₂ (CategoryTheory.CategoryStruct.comp T.mor₃ h)) (CategoryTheory.CategoryStruct.comp 0 h)","decl":"/-- Given any distinguished triangle\n```\n      f       g       h\n  X  ───> Y  ───> Z  ───> X⟦1⟧\n```\nthe composition `g ≫ h = 0`. -/\n@[reassoc, stacks 0146]\ntheorem comp_distTriang_mor_zero₂₃ (T : Triangle C) (H : T ∈ distTriang C) :\n    T.mor₂ ≫ T.mor₃ = 0 :=\n  comp_distTriang_mor_zero₁₂ T.rotate (rot_of_distTriang T H)\n\n"}
{"name":"CategoryTheory.Pretriangulated.comp_distTriang_mor_zero₃₁_assoc","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\ninst✝³ : CategoryTheory.Limits.HasZeroObject C\ninst✝² : CategoryTheory.HasShift C Int\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nhC : CategoryTheory.Pretriangulated C\nT : CategoryTheory.Pretriangulated.Triangle C\nH : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T\nZ : C\nh : Quiver.Hom ((CategoryTheory.shiftFunctor C 1).obj T.obj₂) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp T.mor₃ (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor C 1).map T.mor₁) h)) (CategoryTheory.CategoryStruct.comp 0 h)","decl":"/-- Given any distinguished triangle\n```\n      f       g       h\n  X  ───> Y  ───> Z  ───> X⟦1⟧\n```\nthe composition `h ≫ f⟦1⟧ = 0`. -/\n@[reassoc, stacks 0146]\ntheorem comp_distTriang_mor_zero₃₁ (T : Triangle C) (H : T ∈ distTriang C) :\n    T.mor₃ ≫ T.mor₁⟦1⟧' = 0 := by\n  have H₂ := rot_of_distTriang T.rotate (rot_of_distTriang T H)\n  simpa using comp_distTriang_mor_zero₁₂ T.rotate.rotate H₂\n\n"}
{"name":"CategoryTheory.Pretriangulated.comp_distTriang_mor_zero₃₁","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\ninst✝³ : CategoryTheory.Limits.HasZeroObject C\ninst✝² : CategoryTheory.HasShift C Int\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nhC : CategoryTheory.Pretriangulated C\nT : CategoryTheory.Pretriangulated.Triangle C\nH : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T\n⊢ Eq (CategoryTheory.CategoryStruct.comp T.mor₃ ((CategoryTheory.shiftFunctor C 1).map T.mor₁)) 0","decl":"/-- Given any distinguished triangle\n```\n      f       g       h\n  X  ───> Y  ───> Z  ───> X⟦1⟧\n```\nthe composition `h ≫ f⟦1⟧ = 0`. -/\n@[reassoc, stacks 0146]\ntheorem comp_distTriang_mor_zero₃₁ (T : Triangle C) (H : T ∈ distTriang C) :\n    T.mor₃ ≫ T.mor₁⟦1⟧' = 0 := by\n  have H₂ := rot_of_distTriang T.rotate (rot_of_distTriang T H)\n  simpa using comp_distTriang_mor_zero₁₂ T.rotate.rotate H₂\n\n"}
{"name":"CategoryTheory.Pretriangulated.shortComplexOfDistTriangle_X₂","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\ninst✝³ : CategoryTheory.Limits.HasZeroObject C\ninst✝² : CategoryTheory.HasShift C Int\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nhC : CategoryTheory.Pretriangulated C\nT : CategoryTheory.Pretriangulated.Triangle C\nhT : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T\n⊢ Eq (CategoryTheory.Pretriangulated.shortComplexOfDistTriangle T hT).X₂ T.obj₂","decl":"/-- The short complex `T.obj₁ ⟶ T.obj₂ ⟶ T.obj₃` attached to a distinguished triangle. -/\n@[simps]\ndef shortComplexOfDistTriangle (T : Triangle C) (hT : T ∈ distTriang C) : ShortComplex C :=\n  ShortComplex.mk T.mor₁ T.mor₂ (comp_distTriang_mor_zero₁₂ _ hT)\n\n"}
{"name":"CategoryTheory.Pretriangulated.shortComplexOfDistTriangle_X₃","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\ninst✝³ : CategoryTheory.Limits.HasZeroObject C\ninst✝² : CategoryTheory.HasShift C Int\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nhC : CategoryTheory.Pretriangulated C\nT : CategoryTheory.Pretriangulated.Triangle C\nhT : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T\n⊢ Eq (CategoryTheory.Pretriangulated.shortComplexOfDistTriangle T hT).X₃ T.obj₃","decl":"/-- The short complex `T.obj₁ ⟶ T.obj₂ ⟶ T.obj₃` attached to a distinguished triangle. -/\n@[simps]\ndef shortComplexOfDistTriangle (T : Triangle C) (hT : T ∈ distTriang C) : ShortComplex C :=\n  ShortComplex.mk T.mor₁ T.mor₂ (comp_distTriang_mor_zero₁₂ _ hT)\n\n"}
{"name":"CategoryTheory.Pretriangulated.shortComplexOfDistTriangle_X₁","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\ninst✝³ : CategoryTheory.Limits.HasZeroObject C\ninst✝² : CategoryTheory.HasShift C Int\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nhC : CategoryTheory.Pretriangulated C\nT : CategoryTheory.Pretriangulated.Triangle C\nhT : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T\n⊢ Eq (CategoryTheory.Pretriangulated.shortComplexOfDistTriangle T hT).X₁ T.obj₁","decl":"/-- The short complex `T.obj₁ ⟶ T.obj₂ ⟶ T.obj₃` attached to a distinguished triangle. -/\n@[simps]\ndef shortComplexOfDistTriangle (T : Triangle C) (hT : T ∈ distTriang C) : ShortComplex C :=\n  ShortComplex.mk T.mor₁ T.mor₂ (comp_distTriang_mor_zero₁₂ _ hT)\n\n"}
{"name":"CategoryTheory.Pretriangulated.shortComplexOfDistTriangle_f","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\ninst✝³ : CategoryTheory.Limits.HasZeroObject C\ninst✝² : CategoryTheory.HasShift C Int\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nhC : CategoryTheory.Pretriangulated C\nT : CategoryTheory.Pretriangulated.Triangle C\nhT : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T\n⊢ Eq (CategoryTheory.Pretriangulated.shortComplexOfDistTriangle T hT).f T.mor₁","decl":"/-- The short complex `T.obj₁ ⟶ T.obj₂ ⟶ T.obj₃` attached to a distinguished triangle. -/\n@[simps]\ndef shortComplexOfDistTriangle (T : Triangle C) (hT : T ∈ distTriang C) : ShortComplex C :=\n  ShortComplex.mk T.mor₁ T.mor₂ (comp_distTriang_mor_zero₁₂ _ hT)\n\n"}
{"name":"CategoryTheory.Pretriangulated.shortComplexOfDistTriangle_g","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\ninst✝³ : CategoryTheory.Limits.HasZeroObject C\ninst✝² : CategoryTheory.HasShift C Int\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nhC : CategoryTheory.Pretriangulated C\nT : CategoryTheory.Pretriangulated.Triangle C\nhT : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T\n⊢ Eq (CategoryTheory.Pretriangulated.shortComplexOfDistTriangle T hT).g T.mor₂","decl":"/-- The short complex `T.obj₁ ⟶ T.obj₂ ⟶ T.obj₃` attached to a distinguished triangle. -/\n@[simps]\ndef shortComplexOfDistTriangle (T : Triangle C) (hT : T ∈ distTriang C) : ShortComplex C :=\n  ShortComplex.mk T.mor₁ T.mor₂ (comp_distTriang_mor_zero₁₂ _ hT)\n\n"}
{"name":"CategoryTheory.Pretriangulated.shortComplexOfDistTriangleIsoOfIso_hom_τ₂","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\ninst✝³ : CategoryTheory.Limits.HasZeroObject C\ninst✝² : CategoryTheory.HasShift C Int\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nhC : CategoryTheory.Pretriangulated C\nT T' : CategoryTheory.Pretriangulated.Triangle C\ne : CategoryTheory.Iso T T'\nhT : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T\n⊢ Eq (CategoryTheory.Pretriangulated.shortComplexOfDistTriangleIsoOfIso e hT).hom.τ₂ e.hom.hom₂","decl":"/-- The isomorphism between the short complex attached to\ntwo isomorphic distinguished triangles. -/\n@[simps!]\ndef shortComplexOfDistTriangleIsoOfIso {T T' : Triangle C} (e : T ≅ T') (hT : T ∈ distTriang C) :\n    shortComplexOfDistTriangle T hT ≅ shortComplexOfDistTriangle T'\n      (isomorphic_distinguished _ hT _ e.symm) :=\n  ShortComplex.isoMk (Triangle.π₁.mapIso e) (Triangle.π₂.mapIso e) (Triangle.π₃.mapIso e)\n\n"}
{"name":"CategoryTheory.Pretriangulated.shortComplexOfDistTriangleIsoOfIso_hom_τ₁","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\ninst✝³ : CategoryTheory.Limits.HasZeroObject C\ninst✝² : CategoryTheory.HasShift C Int\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nhC : CategoryTheory.Pretriangulated C\nT T' : CategoryTheory.Pretriangulated.Triangle C\ne : CategoryTheory.Iso T T'\nhT : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T\n⊢ Eq (CategoryTheory.Pretriangulated.shortComplexOfDistTriangleIsoOfIso e hT).hom.τ₁ e.hom.hom₁","decl":"/-- The isomorphism between the short complex attached to\ntwo isomorphic distinguished triangles. -/\n@[simps!]\ndef shortComplexOfDistTriangleIsoOfIso {T T' : Triangle C} (e : T ≅ T') (hT : T ∈ distTriang C) :\n    shortComplexOfDistTriangle T hT ≅ shortComplexOfDistTriangle T'\n      (isomorphic_distinguished _ hT _ e.symm) :=\n  ShortComplex.isoMk (Triangle.π₁.mapIso e) (Triangle.π₂.mapIso e) (Triangle.π₃.mapIso e)\n\n"}
{"name":"CategoryTheory.Pretriangulated.shortComplexOfDistTriangleIsoOfIso_hom_τ₃","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\ninst✝³ : CategoryTheory.Limits.HasZeroObject C\ninst✝² : CategoryTheory.HasShift C Int\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nhC : CategoryTheory.Pretriangulated C\nT T' : CategoryTheory.Pretriangulated.Triangle C\ne : CategoryTheory.Iso T T'\nhT : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T\n⊢ Eq (CategoryTheory.Pretriangulated.shortComplexOfDistTriangleIsoOfIso e hT).hom.τ₃ e.hom.hom₃","decl":"/-- The isomorphism between the short complex attached to\ntwo isomorphic distinguished triangles. -/\n@[simps!]\ndef shortComplexOfDistTriangleIsoOfIso {T T' : Triangle C} (e : T ≅ T') (hT : T ∈ distTriang C) :\n    shortComplexOfDistTriangle T hT ≅ shortComplexOfDistTriangle T'\n      (isomorphic_distinguished _ hT _ e.symm) :=\n  ShortComplex.isoMk (Triangle.π₁.mapIso e) (Triangle.π₂.mapIso e) (Triangle.π₃.mapIso e)\n\n"}
{"name":"CategoryTheory.Pretriangulated.shortComplexOfDistTriangleIsoOfIso_inv_τ₂","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\ninst✝³ : CategoryTheory.Limits.HasZeroObject C\ninst✝² : CategoryTheory.HasShift C Int\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nhC : CategoryTheory.Pretriangulated C\nT T' : CategoryTheory.Pretriangulated.Triangle C\ne : CategoryTheory.Iso T T'\nhT : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T\n⊢ Eq (CategoryTheory.Pretriangulated.shortComplexOfDistTriangleIsoOfIso e hT).inv.τ₂ e.inv.hom₂","decl":"/-- The isomorphism between the short complex attached to\ntwo isomorphic distinguished triangles. -/\n@[simps!]\ndef shortComplexOfDistTriangleIsoOfIso {T T' : Triangle C} (e : T ≅ T') (hT : T ∈ distTriang C) :\n    shortComplexOfDistTriangle T hT ≅ shortComplexOfDistTriangle T'\n      (isomorphic_distinguished _ hT _ e.symm) :=\n  ShortComplex.isoMk (Triangle.π₁.mapIso e) (Triangle.π₂.mapIso e) (Triangle.π₃.mapIso e)\n\n"}
{"name":"CategoryTheory.Pretriangulated.shortComplexOfDistTriangleIsoOfIso_inv_τ₃","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\ninst✝³ : CategoryTheory.Limits.HasZeroObject C\ninst✝² : CategoryTheory.HasShift C Int\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nhC : CategoryTheory.Pretriangulated C\nT T' : CategoryTheory.Pretriangulated.Triangle C\ne : CategoryTheory.Iso T T'\nhT : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T\n⊢ Eq (CategoryTheory.Pretriangulated.shortComplexOfDistTriangleIsoOfIso e hT).inv.τ₃ e.inv.hom₃","decl":"/-- The isomorphism between the short complex attached to\ntwo isomorphic distinguished triangles. -/\n@[simps!]\ndef shortComplexOfDistTriangleIsoOfIso {T T' : Triangle C} (e : T ≅ T') (hT : T ∈ distTriang C) :\n    shortComplexOfDistTriangle T hT ≅ shortComplexOfDistTriangle T'\n      (isomorphic_distinguished _ hT _ e.symm) :=\n  ShortComplex.isoMk (Triangle.π₁.mapIso e) (Triangle.π₂.mapIso e) (Triangle.π₃.mapIso e)\n\n"}
{"name":"CategoryTheory.Pretriangulated.shortComplexOfDistTriangleIsoOfIso_inv_τ₁","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\ninst✝³ : CategoryTheory.Limits.HasZeroObject C\ninst✝² : CategoryTheory.HasShift C Int\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nhC : CategoryTheory.Pretriangulated C\nT T' : CategoryTheory.Pretriangulated.Triangle C\ne : CategoryTheory.Iso T T'\nhT : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T\n⊢ Eq (CategoryTheory.Pretriangulated.shortComplexOfDistTriangleIsoOfIso e hT).inv.τ₁ e.inv.hom₁","decl":"/-- The isomorphism between the short complex attached to\ntwo isomorphic distinguished triangles. -/\n@[simps!]\ndef shortComplexOfDistTriangleIsoOfIso {T T' : Triangle C} (e : T ≅ T') (hT : T ∈ distTriang C) :\n    shortComplexOfDistTriangle T hT ≅ shortComplexOfDistTriangle T'\n      (isomorphic_distinguished _ hT _ e.symm) :=\n  ShortComplex.isoMk (Triangle.π₁.mapIso e) (Triangle.π₂.mapIso e) (Triangle.π₃.mapIso e)\n\n"}
{"name":"CategoryTheory.Pretriangulated.distinguished_cocone_triangle₁","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\ninst✝³ : CategoryTheory.Limits.HasZeroObject C\ninst✝² : CategoryTheory.HasShift C Int\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nhC : CategoryTheory.Pretriangulated C\nY Z : C\ng : Quiver.Hom Y Z\n⊢ Exists fun X => Exists fun f => Exists fun h => Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles (CategoryTheory.Pretriangulated.Triangle.mk f g h)","decl":"/-- Any morphism `Y ⟶ Z` is part of a distinguished triangle `X ⟶ Y ⟶ Z ⟶ X⟦1⟧` -/\nlemma distinguished_cocone_triangle₁ {Y Z : C} (g : Y ⟶ Z) :\n    ∃ (X : C) (f : X ⟶ Y) (h : Z ⟶ X⟦(1 : ℤ)⟧), Triangle.mk f g h ∈ distTriang C := by\n  obtain ⟨X', f', g', mem⟩ := distinguished_cocone_triangle g\n  exact ⟨_, _, _, inv_rot_of_distTriang _ mem⟩\n\n"}
{"name":"CategoryTheory.Pretriangulated.distinguished_cocone_triangle₂","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\ninst✝³ : CategoryTheory.Limits.HasZeroObject C\ninst✝² : CategoryTheory.HasShift C Int\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nhC : CategoryTheory.Pretriangulated C\nZ X : C\nh : Quiver.Hom Z ((CategoryTheory.shiftFunctor C 1).obj X)\n⊢ Exists fun Y => Exists fun f => Exists fun g => Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles (CategoryTheory.Pretriangulated.Triangle.mk f g h)","decl":"/-- Any morphism `Z ⟶ X⟦1⟧` is part of a distinguished triangle `X ⟶ Y ⟶ Z ⟶ X⟦1⟧` -/\nlemma distinguished_cocone_triangle₂ {Z X : C} (h : Z ⟶ X⟦(1 : ℤ)⟧) :\n    ∃ (Y : C) (f : X ⟶ Y) (g : Y ⟶ Z), Triangle.mk f g h ∈ distTriang C := by\n  obtain ⟨Y', f', g', mem⟩ := distinguished_cocone_triangle h\n  let T' := (Triangle.mk h f' g').invRotate.invRotate\n  refine ⟨T'.obj₂, ((shiftEquiv C (1 : ℤ)).unitIso.app X).hom ≫ T'.mor₁, T'.mor₂,\n    isomorphic_distinguished _ (inv_rot_of_distTriang _ (inv_rot_of_distTriang _ mem)) _ ?_⟩\n  exact Triangle.isoMk _ _ ((shiftEquiv C (1 : ℤ)).unitIso.app X) (Iso.refl _) (Iso.refl _)\n    (by aesop_cat) (by aesop_cat)\n    (by dsimp; simp only [shift_shiftFunctorCompIsoId_inv_app, id_comp])\n\n"}
{"name":"CategoryTheory.Pretriangulated.complete_distinguished_triangle_morphism₁","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\ninst✝³ : CategoryTheory.Limits.HasZeroObject C\ninst✝² : CategoryTheory.HasShift C Int\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nhC : CategoryTheory.Pretriangulated C\nT₁ T₂ : CategoryTheory.Pretriangulated.Triangle C\nhT₁ : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T₁\nhT₂ : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T₂\nb : Quiver.Hom T₁.obj₂ T₂.obj₂\nc : Quiver.Hom T₁.obj₃ T₂.obj₃\ncomm : Eq (CategoryTheory.CategoryStruct.comp T₁.mor₂ c) (CategoryTheory.CategoryStruct.comp b T₂.mor₂)\n⊢ Exists fun a => And (Eq (CategoryTheory.CategoryStruct.comp T₁.mor₁ b) (CategoryTheory.CategoryStruct.comp a T₂.mor₁)) (Eq (CategoryTheory.CategoryStruct.comp T₁.mor₃ ((CategoryTheory.shiftFunctor C 1).map a)) (CategoryTheory.CategoryStruct.comp c T₂.mor₃))","decl":"/-- A commutative square involving the morphisms `mor₂` of two distinguished triangles\ncan be extended as morphism of triangles -/\nlemma complete_distinguished_triangle_morphism₁ (T₁ T₂ : Triangle C)\n    (hT₁ : T₁ ∈ distTriang C) (hT₂ : T₂ ∈ distTriang C) (b : T₁.obj₂ ⟶ T₂.obj₂)\n    (c : T₁.obj₃ ⟶ T₂.obj₃) (comm : T₁.mor₂ ≫ c = b ≫ T₂.mor₂) :\n    ∃ (a : T₁.obj₁ ⟶ T₂.obj₁), T₁.mor₁ ≫ b = a ≫ T₂.mor₁ ∧\n      T₁.mor₃ ≫ a⟦(1 : ℤ)⟧' = c ≫ T₂.mor₃ := by\n  obtain ⟨a, ⟨ha₁, ha₂⟩⟩ := complete_distinguished_triangle_morphism _ _\n    (rot_of_distTriang _ hT₁) (rot_of_distTriang _ hT₂) b c comm\n  refine ⟨(shiftFunctor C (1 : ℤ)).preimage a, ⟨?_, ?_⟩⟩\n  · apply (shiftFunctor C (1 : ℤ)).map_injective\n    dsimp at ha₂\n    rw [neg_comp, comp_neg, neg_inj] at ha₂\n    simpa only [Functor.map_comp, Functor.map_preimage] using ha₂\n  · simpa only [Functor.map_preimage] using ha₁\n\n"}
{"name":"CategoryTheory.Pretriangulated.complete_distinguished_triangle_morphism₂","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\ninst✝³ : CategoryTheory.Limits.HasZeroObject C\ninst✝² : CategoryTheory.HasShift C Int\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nhC : CategoryTheory.Pretriangulated C\nT₁ T₂ : CategoryTheory.Pretriangulated.Triangle C\nhT₁ : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T₁\nhT₂ : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T₂\na : Quiver.Hom T₁.obj₁ T₂.obj₁\nc : Quiver.Hom T₁.obj₃ T₂.obj₃\ncomm : Eq (CategoryTheory.CategoryStruct.comp T₁.mor₃ ((CategoryTheory.shiftFunctor C 1).map a)) (CategoryTheory.CategoryStruct.comp c T₂.mor₃)\n⊢ Exists fun b => And (Eq (CategoryTheory.CategoryStruct.comp T₁.mor₁ b) (CategoryTheory.CategoryStruct.comp a T₂.mor₁)) (Eq (CategoryTheory.CategoryStruct.comp T₁.mor₂ c) (CategoryTheory.CategoryStruct.comp b T₂.mor₂))","decl":"/-- A commutative square involving the morphisms `mor₃` of two distinguished triangles\ncan be extended as morphism of triangles -/\nlemma complete_distinguished_triangle_morphism₂ (T₁ T₂ : Triangle C)\n    (hT₁ : T₁ ∈ distTriang C) (hT₂ : T₂ ∈ distTriang C) (a : T₁.obj₁ ⟶ T₂.obj₁)\n    (c : T₁.obj₃ ⟶ T₂.obj₃) (comm : T₁.mor₃ ≫ a⟦(1 : ℤ)⟧' = c ≫ T₂.mor₃) :\n    ∃ (b : T₁.obj₂ ⟶ T₂.obj₂), T₁.mor₁ ≫ b = a ≫ T₂.mor₁ ∧ T₁.mor₂ ≫ c = b ≫ T₂.mor₂ := by\n  obtain ⟨a, ⟨ha₁, ha₂⟩⟩ := complete_distinguished_triangle_morphism _ _\n    (inv_rot_of_distTriang _ hT₁) (inv_rot_of_distTriang _ hT₂) (c⟦(-1 : ℤ)⟧') a (by\n    dsimp\n    simp only [neg_comp, comp_neg, ← Functor.map_comp_assoc, ← comm,\n      Functor.map_comp, shift_shift_neg', Functor.id_obj, assoc, Iso.inv_hom_id_app, comp_id])\n  refine ⟨a, ⟨ha₁, ?_⟩⟩\n  dsimp only [Triangle.invRotate, Triangle.mk] at ha₂\n  rw [← cancel_mono ((shiftEquiv C (1 : ℤ)).counitIso.inv.app T₂.obj₃), assoc, assoc, ← ha₂]\n  simp only [shiftEquiv'_counitIso, shift_neg_shift', assoc, Iso.inv_hom_id_app_assoc]\n\n"}
{"name":"CategoryTheory.Pretriangulated.contractible_distinguished₁","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\ninst✝³ : CategoryTheory.Limits.HasZeroObject C\ninst✝² : CategoryTheory.HasShift C Int\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nhC : CategoryTheory.Pretriangulated C\nX : C\n⊢ Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles (CategoryTheory.Pretriangulated.Triangle.mk 0 (CategoryTheory.CategoryStruct.id X) 0)","decl":"/-- Obvious triangles `0 ⟶ X ⟶ X ⟶ 0⟦1⟧` are distinguished -/\nlemma contractible_distinguished₁ (X : C) :\n    Triangle.mk (0 : 0 ⟶ X) (𝟙 X) 0 ∈ distTriang C := by\n  refine isomorphic_distinguished _\n    (inv_rot_of_distTriang _ (contractible_distinguished X)) _ ?_\n  exact Triangle.isoMk _ _ (Functor.mapZeroObject _).symm (Iso.refl _) (Iso.refl _)\n    (by simp) (by simp) (by simp)\n\n"}
{"name":"CategoryTheory.Pretriangulated.contractible_distinguished₂","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\ninst✝³ : CategoryTheory.Limits.HasZeroObject C\ninst✝² : CategoryTheory.HasShift C Int\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nhC : CategoryTheory.Pretriangulated C\nX : C\n⊢ Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles (CategoryTheory.Pretriangulated.Triangle.mk 0 0 (CategoryTheory.CategoryStruct.id ((CategoryTheory.shiftFunctor C 1).obj X)))","decl":"/-- Obvious triangles `X ⟶ 0 ⟶ X⟦1⟧ ⟶ X⟦1⟧` are distinguished -/\nlemma contractible_distinguished₂ (X : C) :\n    Triangle.mk (0 : X ⟶ 0) 0 (𝟙 (X⟦1⟧)) ∈ distTriang C := by\n  refine isomorphic_distinguished _\n    (inv_rot_of_distTriang _ (contractible_distinguished₁ (X⟦(1 : ℤ)⟧))) _ ?_\n  exact Triangle.isoMk _ _ ((shiftEquiv C (1 : ℤ)).unitIso.app X) (Iso.refl _) (Iso.refl _)\n    (by simp) (by simp)\n    (by dsimp; simp only [shift_shiftFunctorCompIsoId_inv_app, id_comp])\n\n"}
{"name":"CategoryTheory.Pretriangulated.Triangle.yoneda_exact₂","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\ninst✝³ : CategoryTheory.Limits.HasZeroObject C\ninst✝² : CategoryTheory.HasShift C Int\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nhC : CategoryTheory.Pretriangulated C\nT : CategoryTheory.Pretriangulated.Triangle C\nhT : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T\nX : C\nf : Quiver.Hom T.obj₂ X\nhf : Eq (CategoryTheory.CategoryStruct.comp T.mor₁ f) 0\n⊢ Exists fun g => Eq f (CategoryTheory.CategoryStruct.comp T.mor₂ g)","decl":"lemma yoneda_exact₂ {X : C} (f : T.obj₂ ⟶ X) (hf : T.mor₁ ≫ f = 0) :\n    ∃ (g : T.obj₃ ⟶ X), f = T.mor₂ ≫ g := by\n  obtain ⟨g, ⟨hg₁, _⟩⟩ := complete_distinguished_triangle_morphism T _ hT\n    (contractible_distinguished₁ X) 0 f (by aesop_cat)\n  exact ⟨g, by simpa using hg₁.symm⟩\n\n"}
{"name":"CategoryTheory.Pretriangulated.Triangle.yoneda_exact₃","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\ninst✝³ : CategoryTheory.Limits.HasZeroObject C\ninst✝² : CategoryTheory.HasShift C Int\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nhC : CategoryTheory.Pretriangulated C\nT : CategoryTheory.Pretriangulated.Triangle C\nhT : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T\nX : C\nf : Quiver.Hom T.obj₃ X\nhf : Eq (CategoryTheory.CategoryStruct.comp T.mor₂ f) 0\n⊢ Exists fun g => Eq f (CategoryTheory.CategoryStruct.comp T.mor₃ g)","decl":"lemma yoneda_exact₃ {X : C} (f : T.obj₃ ⟶ X) (hf : T.mor₂ ≫ f = 0) :\n    ∃ (g : T.obj₁⟦(1 : ℤ)⟧ ⟶ X), f = T.mor₃ ≫ g :=\n  yoneda_exact₂ _ (rot_of_distTriang _ hT) f hf\n\n"}
{"name":"CategoryTheory.Pretriangulated.Triangle.coyoneda_exact₂","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\ninst✝³ : CategoryTheory.Limits.HasZeroObject C\ninst✝² : CategoryTheory.HasShift C Int\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nhC : CategoryTheory.Pretriangulated C\nT : CategoryTheory.Pretriangulated.Triangle C\nhT : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T\nX : C\nf : Quiver.Hom X T.obj₂\nhf : Eq (CategoryTheory.CategoryStruct.comp f T.mor₂) 0\n⊢ Exists fun g => Eq f (CategoryTheory.CategoryStruct.comp g T.mor₁)","decl":"lemma coyoneda_exact₂ {X : C} (f : X ⟶ T.obj₂) (hf : f ≫ T.mor₂ = 0) :\n    ∃ (g : X ⟶ T.obj₁), f = g ≫ T.mor₁ := by\n  obtain ⟨a, ⟨ha₁, _⟩⟩ := complete_distinguished_triangle_morphism₁ _ T\n    (contractible_distinguished X) hT f 0 (by aesop_cat)\n  exact ⟨a, by simpa using ha₁⟩\n\n"}
{"name":"CategoryTheory.Pretriangulated.Triangle.coyoneda_exact₁","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\ninst✝³ : CategoryTheory.Limits.HasZeroObject C\ninst✝² : CategoryTheory.HasShift C Int\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nhC : CategoryTheory.Pretriangulated C\nT : CategoryTheory.Pretriangulated.Triangle C\nhT : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T\nX : C\nf : Quiver.Hom X ((CategoryTheory.shiftFunctor C 1).obj T.obj₁)\nhf : Eq (CategoryTheory.CategoryStruct.comp f ((CategoryTheory.shiftFunctor C 1).map T.mor₁)) 0\n⊢ Exists fun g => Eq f (CategoryTheory.CategoryStruct.comp g T.mor₃)","decl":"lemma coyoneda_exact₁ {X : C} (f : X ⟶ T.obj₁⟦(1 : ℤ)⟧) (hf : f ≫ T.mor₁⟦1⟧' = 0) :\n    ∃ (g : X ⟶ T.obj₃), f = g ≫ T.mor₃ :=\n  coyoneda_exact₂ _ (rot_of_distTriang _ (rot_of_distTriang _ hT)) f (by aesop_cat)\n\n"}
{"name":"CategoryTheory.Pretriangulated.Triangle.coyoneda_exact₃","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\ninst✝³ : CategoryTheory.Limits.HasZeroObject C\ninst✝² : CategoryTheory.HasShift C Int\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nhC : CategoryTheory.Pretriangulated C\nT : CategoryTheory.Pretriangulated.Triangle C\nhT : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T\nX : C\nf : Quiver.Hom X T.obj₃\nhf : Eq (CategoryTheory.CategoryStruct.comp f T.mor₃) 0\n⊢ Exists fun g => Eq f (CategoryTheory.CategoryStruct.comp g T.mor₂)","decl":"lemma coyoneda_exact₃ {X : C} (f : X ⟶ T.obj₃) (hf : f ≫ T.mor₃ = 0) :\n    ∃ (g : X ⟶ T.obj₂), f = g ≫ T.mor₂ :=\n  coyoneda_exact₂ _ (rot_of_distTriang _ hT) f hf\n\n"}
{"name":"CategoryTheory.Pretriangulated.Triangle.mor₃_eq_zero_iff_epi₂","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\ninst✝³ : CategoryTheory.Limits.HasZeroObject C\ninst✝² : CategoryTheory.HasShift C Int\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nhC : CategoryTheory.Pretriangulated C\nT : CategoryTheory.Pretriangulated.Triangle C\nhT : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T\n⊢ Iff (Eq T.mor₃ 0) (CategoryTheory.Epi T.mor₂)","decl":"lemma mor₃_eq_zero_iff_epi₂ : T.mor₃ = 0 ↔ Epi T.mor₂ := by\n  constructor\n  · intro h\n    rw [epi_iff_cancel_zero]\n    intro X g hg\n    obtain ⟨f, rfl⟩ := yoneda_exact₃ T hT g hg\n    rw [h, zero_comp]\n  · intro\n    rw [← cancel_epi T.mor₂, comp_distTriang_mor_zero₂₃ _ hT, comp_zero]\n\n"}
{"name":"CategoryTheory.Pretriangulated.Triangle.mor₂_eq_zero_iff_epi₁","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\ninst✝³ : CategoryTheory.Limits.HasZeroObject C\ninst✝² : CategoryTheory.HasShift C Int\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nhC : CategoryTheory.Pretriangulated C\nT : CategoryTheory.Pretriangulated.Triangle C\nhT : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T\n⊢ Iff (Eq T.mor₂ 0) (CategoryTheory.Epi T.mor₁)","decl":"lemma mor₂_eq_zero_iff_epi₁ : T.mor₂ = 0 ↔ Epi T.mor₁ := by\n  have h := mor₃_eq_zero_iff_epi₂ _ (inv_rot_of_distTriang _ hT)\n  dsimp at h\n  rw [← h, IsIso.comp_right_eq_zero]\n\n"}
{"name":"CategoryTheory.Pretriangulated.Triangle.mor₁_eq_zero_iff_epi₃","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\ninst✝³ : CategoryTheory.Limits.HasZeroObject C\ninst✝² : CategoryTheory.HasShift C Int\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nhC : CategoryTheory.Pretriangulated C\nT : CategoryTheory.Pretriangulated.Triangle C\nhT : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T\n⊢ Iff (Eq T.mor₁ 0) (CategoryTheory.Epi T.mor₃)","decl":"lemma mor₁_eq_zero_iff_epi₃ : T.mor₁ = 0 ↔ Epi T.mor₃ := by\n  have h := mor₃_eq_zero_iff_epi₂ _ (rot_of_distTriang _ hT)\n  dsimp at h\n  rw [← h, neg_eq_zero]\n  constructor\n  · intro h\n    simp only [h, Functor.map_zero]\n  · intro h\n    rw [← (CategoryTheory.shiftFunctor C (1 : ℤ)).map_eq_zero_iff, h]\n\n"}
{"name":"CategoryTheory.Pretriangulated.Triangle.mor₃_eq_zero_of_epi₂","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\ninst✝³ : CategoryTheory.Limits.HasZeroObject C\ninst✝² : CategoryTheory.HasShift C Int\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nhC : CategoryTheory.Pretriangulated C\nT : CategoryTheory.Pretriangulated.Triangle C\nhT : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T\nh : CategoryTheory.Epi T.mor₂\n⊢ Eq T.mor₃ 0","decl":"lemma mor₃_eq_zero_of_epi₂ (h : Epi T.mor₂) : T.mor₃ = 0 := (T.mor₃_eq_zero_iff_epi₂ hT).2 h\n"}
{"name":"CategoryTheory.Pretriangulated.Triangle.mor₂_eq_zero_of_epi₁","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\ninst✝³ : CategoryTheory.Limits.HasZeroObject C\ninst✝² : CategoryTheory.HasShift C Int\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nhC : CategoryTheory.Pretriangulated C\nT : CategoryTheory.Pretriangulated.Triangle C\nhT : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T\nh : CategoryTheory.Epi T.mor₁\n⊢ Eq T.mor₂ 0","decl":"lemma mor₂_eq_zero_of_epi₁ (h : Epi T.mor₁) : T.mor₂ = 0 := (T.mor₂_eq_zero_iff_epi₁ hT).2 h\n"}
{"name":"CategoryTheory.Pretriangulated.Triangle.mor₁_eq_zero_of_epi₃","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\ninst✝³ : CategoryTheory.Limits.HasZeroObject C\ninst✝² : CategoryTheory.HasShift C Int\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nhC : CategoryTheory.Pretriangulated C\nT : CategoryTheory.Pretriangulated.Triangle C\nhT : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T\nh : CategoryTheory.Epi T.mor₃\n⊢ Eq T.mor₁ 0","decl":"lemma mor₁_eq_zero_of_epi₃ (h : Epi T.mor₃) : T.mor₁ = 0 := (T.mor₁_eq_zero_iff_epi₃ hT).2 h\n\n"}
{"name":"CategoryTheory.Pretriangulated.Triangle.epi₂","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\ninst✝³ : CategoryTheory.Limits.HasZeroObject C\ninst✝² : CategoryTheory.HasShift C Int\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nhC : CategoryTheory.Pretriangulated C\nT : CategoryTheory.Pretriangulated.Triangle C\nhT : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T\nh : Eq T.mor₃ 0\n⊢ CategoryTheory.Epi T.mor₂","decl":"lemma epi₂ (h : T.mor₃ = 0) : Epi T.mor₂ := (T.mor₃_eq_zero_iff_epi₂ hT).1 h\n"}
{"name":"CategoryTheory.Pretriangulated.Triangle.epi₁","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\ninst✝³ : CategoryTheory.Limits.HasZeroObject C\ninst✝² : CategoryTheory.HasShift C Int\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nhC : CategoryTheory.Pretriangulated C\nT : CategoryTheory.Pretriangulated.Triangle C\nhT : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T\nh : Eq T.mor₂ 0\n⊢ CategoryTheory.Epi T.mor₁","decl":"lemma epi₁ (h : T.mor₂ = 0) : Epi T.mor₁ := (T.mor₂_eq_zero_iff_epi₁ hT).1 h\n"}
{"name":"CategoryTheory.Pretriangulated.Triangle.epi₃","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\ninst✝³ : CategoryTheory.Limits.HasZeroObject C\ninst✝² : CategoryTheory.HasShift C Int\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nhC : CategoryTheory.Pretriangulated C\nT : CategoryTheory.Pretriangulated.Triangle C\nhT : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T\nh : Eq T.mor₁ 0\n⊢ CategoryTheory.Epi T.mor₃","decl":"lemma epi₃ (h : T.mor₁ = 0) : Epi T.mor₃ := (T.mor₁_eq_zero_iff_epi₃ hT).1 h\n\n"}
{"name":"CategoryTheory.Pretriangulated.Triangle.mor₁_eq_zero_iff_mono₂","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\ninst✝³ : CategoryTheory.Limits.HasZeroObject C\ninst✝² : CategoryTheory.HasShift C Int\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nhC : CategoryTheory.Pretriangulated C\nT : CategoryTheory.Pretriangulated.Triangle C\nhT : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T\n⊢ Iff (Eq T.mor₁ 0) (CategoryTheory.Mono T.mor₂)","decl":"lemma mor₁_eq_zero_iff_mono₂ : T.mor₁ = 0 ↔ Mono T.mor₂ := by\n  constructor\n  · intro h\n    rw [mono_iff_cancel_zero]\n    intro X g hg\n    obtain ⟨f, rfl⟩ := coyoneda_exact₂ T hT g hg\n    rw [h, comp_zero]\n  · intro\n    rw [← cancel_mono T.mor₂, comp_distTriang_mor_zero₁₂ _ hT, zero_comp]\n\n"}
{"name":"CategoryTheory.Pretriangulated.Triangle.mor₂_eq_zero_iff_mono₃","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\ninst✝³ : CategoryTheory.Limits.HasZeroObject C\ninst✝² : CategoryTheory.HasShift C Int\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nhC : CategoryTheory.Pretriangulated C\nT : CategoryTheory.Pretriangulated.Triangle C\nhT : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T\n⊢ Iff (Eq T.mor₂ 0) (CategoryTheory.Mono T.mor₃)","decl":"lemma mor₂_eq_zero_iff_mono₃ : T.mor₂ = 0 ↔ Mono T.mor₃ :=\n  mor₁_eq_zero_iff_mono₂ _ (rot_of_distTriang _ hT)\n\n"}
{"name":"CategoryTheory.Pretriangulated.Triangle.mor₃_eq_zero_iff_mono₁","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\ninst✝³ : CategoryTheory.Limits.HasZeroObject C\ninst✝² : CategoryTheory.HasShift C Int\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nhC : CategoryTheory.Pretriangulated C\nT : CategoryTheory.Pretriangulated.Triangle C\nhT : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T\n⊢ Iff (Eq T.mor₃ 0) (CategoryTheory.Mono T.mor₁)","decl":"lemma mor₃_eq_zero_iff_mono₁ : T.mor₃ = 0 ↔ Mono T.mor₁ := by\n  have h := mor₁_eq_zero_iff_mono₂ _ (inv_rot_of_distTriang _ hT)\n  dsimp at h\n  rw [← h, neg_eq_zero, IsIso.comp_right_eq_zero]\n  constructor\n  · intro h\n    simp only [h, Functor.map_zero]\n  · intro h\n    rw [← (CategoryTheory.shiftFunctor C (-1 : ℤ)).map_eq_zero_iff, h]\n\n"}
{"name":"CategoryTheory.Pretriangulated.Triangle.mor₁_eq_zero_of_mono₂","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\ninst✝³ : CategoryTheory.Limits.HasZeroObject C\ninst✝² : CategoryTheory.HasShift C Int\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nhC : CategoryTheory.Pretriangulated C\nT : CategoryTheory.Pretriangulated.Triangle C\nhT : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T\nh : CategoryTheory.Mono T.mor₂\n⊢ Eq T.mor₁ 0","decl":"lemma mor₁_eq_zero_of_mono₂ (h : Mono T.mor₂) : T.mor₁ = 0 := (T.mor₁_eq_zero_iff_mono₂ hT).2 h\n"}
{"name":"CategoryTheory.Pretriangulated.Triangle.mor₂_eq_zero_of_mono₃","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\ninst✝³ : CategoryTheory.Limits.HasZeroObject C\ninst✝² : CategoryTheory.HasShift C Int\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nhC : CategoryTheory.Pretriangulated C\nT : CategoryTheory.Pretriangulated.Triangle C\nhT : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T\nh : CategoryTheory.Mono T.mor₃\n⊢ Eq T.mor₂ 0","decl":"lemma mor₂_eq_zero_of_mono₃ (h : Mono T.mor₃) : T.mor₂ = 0 := (T.mor₂_eq_zero_iff_mono₃ hT).2 h\n"}
{"name":"CategoryTheory.Pretriangulated.Triangle.mor₃_eq_zero_of_mono₁","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\ninst✝³ : CategoryTheory.Limits.HasZeroObject C\ninst✝² : CategoryTheory.HasShift C Int\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nhC : CategoryTheory.Pretriangulated C\nT : CategoryTheory.Pretriangulated.Triangle C\nhT : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T\nh : CategoryTheory.Mono T.mor₁\n⊢ Eq T.mor₃ 0","decl":"lemma mor₃_eq_zero_of_mono₁ (h : Mono T.mor₁) : T.mor₃ = 0 := (T.mor₃_eq_zero_iff_mono₁ hT).2 h\n\n"}
{"name":"CategoryTheory.Pretriangulated.Triangle.mono₂","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\ninst✝³ : CategoryTheory.Limits.HasZeroObject C\ninst✝² : CategoryTheory.HasShift C Int\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nhC : CategoryTheory.Pretriangulated C\nT : CategoryTheory.Pretriangulated.Triangle C\nhT : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T\nh : Eq T.mor₁ 0\n⊢ CategoryTheory.Mono T.mor₂","decl":"lemma mono₂ (h : T.mor₁ = 0) : Mono T.mor₂ := (T.mor₁_eq_zero_iff_mono₂ hT).1 h\n"}
{"name":"CategoryTheory.Pretriangulated.Triangle.mono₃","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\ninst✝³ : CategoryTheory.Limits.HasZeroObject C\ninst✝² : CategoryTheory.HasShift C Int\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nhC : CategoryTheory.Pretriangulated C\nT : CategoryTheory.Pretriangulated.Triangle C\nhT : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T\nh : Eq T.mor₂ 0\n⊢ CategoryTheory.Mono T.mor₃","decl":"lemma mono₃ (h : T.mor₂ = 0) : Mono T.mor₃ := (T.mor₂_eq_zero_iff_mono₃ hT).1 h\n"}
{"name":"CategoryTheory.Pretriangulated.Triangle.mono₁","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\ninst✝³ : CategoryTheory.Limits.HasZeroObject C\ninst✝² : CategoryTheory.HasShift C Int\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nhC : CategoryTheory.Pretriangulated C\nT : CategoryTheory.Pretriangulated.Triangle C\nhT : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T\nh : Eq T.mor₃ 0\n⊢ CategoryTheory.Mono T.mor₁","decl":"lemma mono₁ (h : T.mor₃ = 0) : Mono T.mor₁ := (T.mor₃_eq_zero_iff_mono₁ hT).1 h\n\n"}
{"name":"CategoryTheory.Pretriangulated.Triangle.isZero₂_iff","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\ninst✝³ : CategoryTheory.Limits.HasZeroObject C\ninst✝² : CategoryTheory.HasShift C Int\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nhC : CategoryTheory.Pretriangulated C\nT : CategoryTheory.Pretriangulated.Triangle C\nhT : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T\n⊢ Iff (CategoryTheory.Limits.IsZero T.obj₂) (And (Eq T.mor₁ 0) (Eq T.mor₂ 0))","decl":"lemma isZero₂_iff : IsZero T.obj₂ ↔ (T.mor₁ = 0 ∧ T.mor₂ = 0) := by\n  constructor\n  · intro h\n    exact ⟨h.eq_of_tgt _ _, h.eq_of_src _ _⟩\n  · intro ⟨h₁, h₂⟩\n    obtain ⟨f, hf⟩ := coyoneda_exact₂ T hT (𝟙 _) (by rw [h₂, comp_zero])\n    rw [IsZero.iff_id_eq_zero, hf, h₁, comp_zero]\n\n"}
{"name":"CategoryTheory.Pretriangulated.Triangle.isZero₁_iff","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\ninst✝³ : CategoryTheory.Limits.HasZeroObject C\ninst✝² : CategoryTheory.HasShift C Int\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nhC : CategoryTheory.Pretriangulated C\nT : CategoryTheory.Pretriangulated.Triangle C\nhT : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T\n⊢ Iff (CategoryTheory.Limits.IsZero T.obj₁) (And (Eq T.mor₁ 0) (Eq T.mor₃ 0))","decl":"lemma isZero₁_iff : IsZero T.obj₁ ↔ (T.mor₁ = 0 ∧ T.mor₃ = 0) := by\n  refine (isZero₂_iff _ (inv_rot_of_distTriang _ hT)).trans ?_\n  dsimp\n  simp only [neg_eq_zero, IsIso.comp_right_eq_zero, Functor.map_eq_zero_iff]\n  tauto\n\n"}
{"name":"CategoryTheory.Pretriangulated.Triangle.isZero₃_iff","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\ninst✝³ : CategoryTheory.Limits.HasZeroObject C\ninst✝² : CategoryTheory.HasShift C Int\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nhC : CategoryTheory.Pretriangulated C\nT : CategoryTheory.Pretriangulated.Triangle C\nhT : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T\n⊢ Iff (CategoryTheory.Limits.IsZero T.obj₃) (And (Eq T.mor₂ 0) (Eq T.mor₃ 0))","decl":"lemma isZero₃_iff : IsZero T.obj₃ ↔ (T.mor₂ = 0 ∧ T.mor₃ = 0) := by\n  refine (isZero₂_iff _ (rot_of_distTriang _ hT)).trans ?_\n  dsimp\n  tauto\n\n"}
{"name":"CategoryTheory.Pretriangulated.Triangle.isZero₁_of_isZero₂₃","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\ninst✝³ : CategoryTheory.Limits.HasZeroObject C\ninst✝² : CategoryTheory.HasShift C Int\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nhC : CategoryTheory.Pretriangulated C\nT : CategoryTheory.Pretriangulated.Triangle C\nhT : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T\nh₂ : CategoryTheory.Limits.IsZero T.obj₂\nh₃ : CategoryTheory.Limits.IsZero T.obj₃\n⊢ CategoryTheory.Limits.IsZero T.obj₁","decl":"lemma isZero₁_of_isZero₂₃ (h₂ : IsZero T.obj₂) (h₃ : IsZero T.obj₃) : IsZero T.obj₁ := by\n  rw [T.isZero₁_iff hT]\n  exact ⟨h₂.eq_of_tgt _ _, h₃.eq_of_src _ _⟩\n\n"}
{"name":"CategoryTheory.Pretriangulated.Triangle.isZero₂_of_isZero₁₃","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\ninst✝³ : CategoryTheory.Limits.HasZeroObject C\ninst✝² : CategoryTheory.HasShift C Int\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nhC : CategoryTheory.Pretriangulated C\nT : CategoryTheory.Pretriangulated.Triangle C\nhT : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T\nh₁ : CategoryTheory.Limits.IsZero T.obj₁\nh₃ : CategoryTheory.Limits.IsZero T.obj₃\n⊢ CategoryTheory.Limits.IsZero T.obj₂","decl":"lemma isZero₂_of_isZero₁₃ (h₁ : IsZero T.obj₁) (h₃ : IsZero T.obj₃) : IsZero T.obj₂ := by\n  rw [T.isZero₂_iff hT]\n  exact ⟨h₁.eq_of_src _ _, h₃.eq_of_tgt _ _⟩\n\n"}
{"name":"CategoryTheory.Pretriangulated.Triangle.isZero₃_of_isZero₁₂","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\ninst✝³ : CategoryTheory.Limits.HasZeroObject C\ninst✝² : CategoryTheory.HasShift C Int\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nhC : CategoryTheory.Pretriangulated C\nT : CategoryTheory.Pretriangulated.Triangle C\nhT : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T\nh₁ : CategoryTheory.Limits.IsZero T.obj₁\nh₂ : CategoryTheory.Limits.IsZero T.obj₂\n⊢ CategoryTheory.Limits.IsZero T.obj₃","decl":"lemma isZero₃_of_isZero₁₂ (h₁ : IsZero T.obj₁) (h₂ : IsZero T.obj₂) : IsZero T.obj₃ :=\n  isZero₂_of_isZero₁₃ _ (rot_of_distTriang _ hT) h₂ (by\n    dsimp\n    simp only [IsZero.iff_id_eq_zero] at h₁ ⊢\n    rw [← Functor.map_id, h₁, Functor.map_zero])\n\n"}
{"name":"CategoryTheory.Pretriangulated.Triangle.isZero₁_iff_isIso₂","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\ninst✝³ : CategoryTheory.Limits.HasZeroObject C\ninst✝² : CategoryTheory.HasShift C Int\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nhC : CategoryTheory.Pretriangulated C\nT : CategoryTheory.Pretriangulated.Triangle C\nhT : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T\n⊢ Iff (CategoryTheory.Limits.IsZero T.obj₁) (CategoryTheory.IsIso T.mor₂)","decl":"lemma isZero₁_iff_isIso₂ :\n    IsZero T.obj₁ ↔ IsIso T.mor₂ := by\n  rw [T.isZero₁_iff hT]\n  constructor\n  · intro ⟨h₁, h₃⟩\n    have := T.epi₂ hT h₃\n    obtain ⟨f, hf⟩ := yoneda_exact₂ T hT (𝟙 _) (by rw [h₁, zero_comp])\n    exact ⟨f, hf.symm, by rw [← cancel_epi T.mor₂, comp_id, ← reassoc_of% hf]⟩\n  · intro\n    rw [T.mor₁_eq_zero_iff_mono₂ hT, T.mor₃_eq_zero_iff_epi₂ hT]\n    constructor <;> infer_instance\n\n"}
{"name":"CategoryTheory.Pretriangulated.Triangle.isZero₂_iff_isIso₃","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\ninst✝³ : CategoryTheory.Limits.HasZeroObject C\ninst✝² : CategoryTheory.HasShift C Int\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nhC : CategoryTheory.Pretriangulated C\nT : CategoryTheory.Pretriangulated.Triangle C\nhT : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T\n⊢ Iff (CategoryTheory.Limits.IsZero T.obj₂) (CategoryTheory.IsIso T.mor₃)","decl":"lemma isZero₂_iff_isIso₃ : IsZero T.obj₂ ↔ IsIso T.mor₃ :=\n  isZero₁_iff_isIso₂ _ (rot_of_distTriang _ hT)\n\n"}
{"name":"CategoryTheory.Pretriangulated.Triangle.isZero₃_iff_isIso₁","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\ninst✝³ : CategoryTheory.Limits.HasZeroObject C\ninst✝² : CategoryTheory.HasShift C Int\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nhC : CategoryTheory.Pretriangulated C\nT : CategoryTheory.Pretriangulated.Triangle C\nhT : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T\n⊢ Iff (CategoryTheory.Limits.IsZero T.obj₃) (CategoryTheory.IsIso T.mor₁)","decl":"lemma isZero₃_iff_isIso₁ : IsZero T.obj₃ ↔ IsIso T.mor₁ := by\n  refine Iff.trans ?_ (Triangle.isZero₁_iff_isIso₂ _ (inv_rot_of_distTriang _ hT))\n  dsimp\n  simp only [IsZero.iff_id_eq_zero, ← Functor.map_id, Functor.map_eq_zero_iff]\n\n"}
{"name":"CategoryTheory.Pretriangulated.Triangle.isZero₁_of_isIso₂","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\ninst✝³ : CategoryTheory.Limits.HasZeroObject C\ninst✝² : CategoryTheory.HasShift C Int\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nhC : CategoryTheory.Pretriangulated C\nT : CategoryTheory.Pretriangulated.Triangle C\nhT : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T\nh : CategoryTheory.IsIso T.mor₂\n⊢ CategoryTheory.Limits.IsZero T.obj₁","decl":"lemma isZero₁_of_isIso₂ (h : IsIso T.mor₂) : IsZero T.obj₁ := (T.isZero₁_iff_isIso₂ hT).2 h\n"}
{"name":"CategoryTheory.Pretriangulated.Triangle.isZero₂_of_isIso₃","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\ninst✝³ : CategoryTheory.Limits.HasZeroObject C\ninst✝² : CategoryTheory.HasShift C Int\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nhC : CategoryTheory.Pretriangulated C\nT : CategoryTheory.Pretriangulated.Triangle C\nhT : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T\nh : CategoryTheory.IsIso T.mor₃\n⊢ CategoryTheory.Limits.IsZero T.obj₂","decl":"lemma isZero₂_of_isIso₃ (h : IsIso T.mor₃) : IsZero T.obj₂ := (T.isZero₂_iff_isIso₃ hT).2 h\n"}
{"name":"CategoryTheory.Pretriangulated.Triangle.isZero₃_of_isIso₁","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\ninst✝³ : CategoryTheory.Limits.HasZeroObject C\ninst✝² : CategoryTheory.HasShift C Int\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nhC : CategoryTheory.Pretriangulated C\nT : CategoryTheory.Pretriangulated.Triangle C\nhT : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T\nh : CategoryTheory.IsIso T.mor₁\n⊢ CategoryTheory.Limits.IsZero T.obj₃","decl":"lemma isZero₃_of_isIso₁ (h : IsIso T.mor₁) : IsZero T.obj₃ := (T.isZero₃_iff_isIso₁ hT).2 h\n\n"}
{"name":"CategoryTheory.Pretriangulated.Triangle.shift_distinguished","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\ninst✝³ : CategoryTheory.Limits.HasZeroObject C\ninst✝² : CategoryTheory.HasShift C Int\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nhC : CategoryTheory.Pretriangulated C\nT : CategoryTheory.Pretriangulated.Triangle C\nhT : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T\nn : Int\n⊢ Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles ((CategoryTheory.shiftFunctor (CategoryTheory.Pretriangulated.Triangle C) n).obj T)","decl":"lemma shift_distinguished (n : ℤ) :\n    (CategoryTheory.shiftFunctor (Triangle C) n).obj T ∈ distTriang C := by\n  revert T hT\n  let H : ℤ → Prop := fun n => ∀ (T : Triangle C) (_ : T ∈ distTriang C),\n    (Triangle.shiftFunctor C n).obj T ∈ distTriang C\n  change H n\n  have H_zero : H 0 := fun T hT =>\n    isomorphic_distinguished _ hT _ ((Triangle.shiftFunctorZero C).app T)\n  have H_one : H 1 := fun T hT =>\n    isomorphic_distinguished _ (rot_of_distTriang _\n      (rot_of_distTriang _ (rot_of_distTriang _ hT))) _\n        ((rotateRotateRotateIso C).symm.app T)\n  have H_neg_one : H (-1) := fun T hT =>\n    isomorphic_distinguished _ (inv_rot_of_distTriang _\n      (inv_rot_of_distTriang _ (inv_rot_of_distTriang _ hT))) _\n        ((invRotateInvRotateInvRotateIso C).symm.app T)\n  have H_add : ∀ {a b c : ℤ}, H a → H b → a + b = c → H c := fun {a b c} ha hb hc T hT =>\n    isomorphic_distinguished _ (hb _ (ha _ hT)) _\n      ((Triangle.shiftFunctorAdd' C _ _ _ hc).app T)\n  obtain (n|n) := n\n  · induction n with\n    | zero =>  exact H_zero\n    | succ n hn => exact H_add hn H_one rfl\n  · induction n with\n    | zero => exact H_neg_one\n    | succ n hn => exact H_add hn H_neg_one rfl\n\n"}
{"name":"CategoryTheory.Pretriangulated.instSplitEpiCategory","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\n⊢ CategoryTheory.SplitEpiCategory C","decl":"instance : SplitEpiCategory C where\n  isSplitEpi_of_epi f hf := by\n    obtain ⟨Z, g, h, hT⟩ := distinguished_cocone_triangle f\n    obtain ⟨r, hr⟩ := Triangle.coyoneda_exact₂ _ hT (𝟙 _)\n      (by rw [Triangle.mor₂_eq_zero_of_epi₁ _ hT hf, comp_zero])\n    exact ⟨r, hr.symm⟩\n\n"}
{"name":"CategoryTheory.Pretriangulated.instSplitMonoCategory","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\n⊢ CategoryTheory.SplitMonoCategory C","decl":"instance : SplitMonoCategory C where\n  isSplitMono_of_mono f hf := by\n    obtain ⟨X, g, h, hT⟩ := distinguished_cocone_triangle₁ f\n    obtain ⟨r, hr⟩ := Triangle.yoneda_exact₂ _ hT (𝟙 _) (by\n      rw [Triangle.mor₁_eq_zero_of_mono₂ _ hT hf, zero_comp])\n    exact ⟨r, hr.symm⟩\n\n"}
{"name":"CategoryTheory.Pretriangulated.isIso₂_of_isIso₁₃","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\ninst✝³ : CategoryTheory.Limits.HasZeroObject C\ninst✝² : CategoryTheory.HasShift C Int\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nhC : CategoryTheory.Pretriangulated C\nT T' : CategoryTheory.Pretriangulated.Triangle C\nφ : Quiver.Hom T T'\nhT : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T\nhT' : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T'\nh₁ : CategoryTheory.IsIso φ.hom₁\nh₃ : CategoryTheory.IsIso φ.hom₃\n⊢ CategoryTheory.IsIso φ.hom₂","decl":"lemma isIso₂_of_isIso₁₃ {T T' : Triangle C} (φ : T ⟶ T') (hT : T ∈ distTriang C)\n    (hT' : T' ∈ distTriang C) (h₁ : IsIso φ.hom₁) (h₃ : IsIso φ.hom₃) : IsIso φ.hom₂ := by\n  have : Mono φ.hom₂ := by\n    rw [mono_iff_cancel_zero]\n    intro A f hf\n    obtain ⟨g, rfl⟩ := Triangle.coyoneda_exact₂ _ hT f\n      (by rw [← cancel_mono φ.hom₃, assoc, φ.comm₂, reassoc_of% hf, zero_comp, zero_comp])\n    rw [assoc] at hf\n    obtain ⟨h, hh⟩ := Triangle.coyoneda_exact₂ T'.invRotate (inv_rot_of_distTriang _ hT')\n      (g ≫ φ.hom₁) (by dsimp; rw [assoc, ← φ.comm₁, hf])\n    obtain ⟨k, rfl⟩ : ∃ (k : A ⟶ T.invRotate.obj₁), k ≫ T.invRotate.mor₁ = g := by\n      refine ⟨h ≫ inv (φ.hom₃⟦(-1 : ℤ)⟧'), ?_⟩\n      have eq := ((invRotate C).map φ).comm₁\n      dsimp only [invRotate] at eq\n      rw [← cancel_mono φ.hom₁, assoc, assoc, eq, IsIso.inv_hom_id_assoc, hh]\n    erw [assoc, comp_distTriang_mor_zero₁₂ _ (inv_rot_of_distTriang _ hT), comp_zero]\n  refine isIso_of_yoneda_map_bijective _ (fun A => ⟨?_, ?_⟩)\n  · intro f₁ f₂ h\n    simpa only [← cancel_mono φ.hom₂] using h\n  · intro y₂\n    obtain ⟨x₃, hx₃⟩ : ∃ (x₃ : A ⟶ T.obj₃), x₃ ≫ φ.hom₃ = y₂ ≫ T'.mor₂ :=\n      ⟨y₂ ≫ T'.mor₂ ≫ inv φ.hom₃, by simp⟩\n    obtain ⟨x₂, hx₂⟩ := Triangle.coyoneda_exact₃ _ hT x₃\n      (by rw [← cancel_mono (φ.hom₁⟦(1 : ℤ)⟧'), assoc, zero_comp, φ.comm₃, reassoc_of% hx₃,\n        comp_distTriang_mor_zero₂₃ _ hT', comp_zero])\n    obtain ⟨y₁, hy₁⟩ := Triangle.coyoneda_exact₂ _ hT' (y₂ - x₂ ≫ φ.hom₂)\n      (by rw [sub_comp, assoc, ← φ.comm₂, ← reassoc_of% hx₂, hx₃, sub_self])\n    obtain ⟨x₁, hx₁⟩ : ∃ (x₁ : A ⟶ T.obj₁), x₁ ≫ φ.hom₁ = y₁ := ⟨y₁ ≫ inv φ.hom₁, by simp⟩\n    refine ⟨x₂ + x₁ ≫ T.mor₁, ?_⟩\n    dsimp\n    rw [add_comp, assoc, φ.comm₁, reassoc_of% hx₁, ← hy₁, add_sub_cancel]\n\n"}
{"name":"CategoryTheory.Pretriangulated.isIso₃_of_isIso₁₂","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\ninst✝³ : CategoryTheory.Limits.HasZeroObject C\ninst✝² : CategoryTheory.HasShift C Int\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nhC : CategoryTheory.Pretriangulated C\nT T' : CategoryTheory.Pretriangulated.Triangle C\nφ : Quiver.Hom T T'\nhT : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T\nhT' : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T'\nh₁ : CategoryTheory.IsIso φ.hom₁\nh₂ : CategoryTheory.IsIso φ.hom₂\n⊢ CategoryTheory.IsIso φ.hom₃","decl":"lemma isIso₃_of_isIso₁₂ {T T' : Triangle C} (φ : T ⟶ T') (hT : T ∈ distTriang C)\n    (hT' : T' ∈ distTriang C) (h₁ : IsIso φ.hom₁) (h₂ : IsIso φ.hom₂) : IsIso φ.hom₃ :=\n  isIso₂_of_isIso₁₃ ((rotate C).map φ) (rot_of_distTriang _ hT)\n    (rot_of_distTriang _ hT') h₂ (by dsimp; infer_instance)\n\n"}
{"name":"CategoryTheory.Pretriangulated.isIso₁_of_isIso₂₃","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\ninst✝³ : CategoryTheory.Limits.HasZeroObject C\ninst✝² : CategoryTheory.HasShift C Int\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nhC : CategoryTheory.Pretriangulated C\nT T' : CategoryTheory.Pretriangulated.Triangle C\nφ : Quiver.Hom T T'\nhT : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T\nhT' : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T'\nh₂ : CategoryTheory.IsIso φ.hom₂\nh₃ : CategoryTheory.IsIso φ.hom₃\n⊢ CategoryTheory.IsIso φ.hom₁","decl":"lemma isIso₁_of_isIso₂₃ {T T' : Triangle C} (φ : T ⟶ T') (hT : T ∈ distTriang C)\n    (hT' : T' ∈ distTriang C) (h₂ : IsIso φ.hom₂) (h₃ : IsIso φ.hom₃) : IsIso φ.hom₁ :=\n  isIso₂_of_isIso₁₃ ((invRotate C).map φ) (inv_rot_of_distTriang _ hT)\n    (inv_rot_of_distTriang _ hT') (by dsimp; infer_instance) (by dsimp; infer_instance)\n\n"}
{"name":"CategoryTheory.Pretriangulated.binaryBiproductData_isBilimit","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\ninst✝³ : CategoryTheory.Limits.HasZeroObject C\ninst✝² : CategoryTheory.HasShift C Int\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nhC : CategoryTheory.Pretriangulated C\nT : CategoryTheory.Pretriangulated.Triangle C\nhT : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T\nhT₀ : Eq T.mor₃ 0\ninr : Quiver.Hom T.obj₃ T.obj₂\ninr_snd : Eq (CategoryTheory.CategoryStruct.comp inr T.mor₂) (CategoryTheory.CategoryStruct.id T.obj₃)\nfst : Quiver.Hom T.obj₂ T.obj₁\ntotal : Eq (HAdd.hAdd (CategoryTheory.CategoryStruct.comp fst T.mor₁) (CategoryTheory.CategoryStruct.comp T.mor₂ inr)) (CategoryTheory.CategoryStruct.id T.obj₂)\n⊢ Eq (CategoryTheory.Pretriangulated.binaryBiproductData T hT hT₀ inr inr_snd fst total).isBilimit (CategoryTheory.Limits.isBinaryBilimitOfTotal { pt := T.obj₂, fst := fst, snd := T.mor₂, inl := T.mor₁, inr := inr, inl_fst := ⋯, inl_snd := ⋯, inr_fst := ⋯, inr_snd := inr_snd } total)","decl":"/-- Given a distinguished triangle `T` such that `T.mor₃ = 0` and the datum of morphisms\n`inr : T.obj₃ ⟶ T.obj₂` and `fst : T.obj₂ ⟶ T.obj₁` satisfying suitable relations, this\nis the binary biproduct data expressing that `T.obj₂` identifies to the binary\nbiproduct of `T.obj₁` and `T.obj₃`.\nSee also `exists_iso_binaryBiproduct_of_distTriang`. -/\n@[simps]\ndef binaryBiproductData (T : Triangle C) (hT : T ∈ distTriang C) (hT₀ : T.mor₃ = 0)\n    (inr : T.obj₃ ⟶ T.obj₂) (inr_snd : inr ≫ T.mor₂ = 𝟙 _) (fst : T.obj₂ ⟶ T.obj₁)\n    (total : fst ≫ T.mor₁ + T.mor₂ ≫ inr = 𝟙 T.obj₂) :\n    BinaryBiproductData T.obj₁ T.obj₃ := by\n  have : Mono T.mor₁ := T.mono₁ hT hT₀\n  have eq : fst ≫ T.mor₁ = 𝟙 T.obj₂ - T.mor₂ ≫ inr := by rw [← total, add_sub_cancel_right]\n  exact\n    { bicone :=\n      { pt := T.obj₂\n        fst := fst\n        snd := T.mor₂\n        inl := T.mor₁\n        inr := inr\n        inl_fst := by\n          simp only [← cancel_mono T.mor₁, assoc, id_comp, eq, comp_sub, comp_id,\n            comp_distTriang_mor_zero₁₂_assoc _ hT, zero_comp, sub_zero]\n        inl_snd := comp_distTriang_mor_zero₁₂ _ hT\n        inr_fst := by\n          simp only [← cancel_mono T.mor₁, assoc, eq, comp_sub, reassoc_of% inr_snd,\n            comp_id, sub_self, zero_comp]\n        inr_snd := inr_snd }\n      isBilimit := isBinaryBilimitOfTotal _ total }\n\n"}
{"name":"CategoryTheory.Pretriangulated.binaryBiproductData_bicone_inr","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\ninst✝³ : CategoryTheory.Limits.HasZeroObject C\ninst✝² : CategoryTheory.HasShift C Int\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nhC : CategoryTheory.Pretriangulated C\nT : CategoryTheory.Pretriangulated.Triangle C\nhT : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T\nhT₀ : Eq T.mor₃ 0\ninr : Quiver.Hom T.obj₃ T.obj₂\ninr_snd : Eq (CategoryTheory.CategoryStruct.comp inr T.mor₂) (CategoryTheory.CategoryStruct.id T.obj₃)\nfst : Quiver.Hom T.obj₂ T.obj₁\ntotal : Eq (HAdd.hAdd (CategoryTheory.CategoryStruct.comp fst T.mor₁) (CategoryTheory.CategoryStruct.comp T.mor₂ inr)) (CategoryTheory.CategoryStruct.id T.obj₂)\n⊢ Eq (CategoryTheory.Pretriangulated.binaryBiproductData T hT hT₀ inr inr_snd fst total).bicone.inr inr","decl":"/-- Given a distinguished triangle `T` such that `T.mor₃ = 0` and the datum of morphisms\n`inr : T.obj₃ ⟶ T.obj₂` and `fst : T.obj₂ ⟶ T.obj₁` satisfying suitable relations, this\nis the binary biproduct data expressing that `T.obj₂` identifies to the binary\nbiproduct of `T.obj₁` and `T.obj₃`.\nSee also `exists_iso_binaryBiproduct_of_distTriang`. -/\n@[simps]\ndef binaryBiproductData (T : Triangle C) (hT : T ∈ distTriang C) (hT₀ : T.mor₃ = 0)\n    (inr : T.obj₃ ⟶ T.obj₂) (inr_snd : inr ≫ T.mor₂ = 𝟙 _) (fst : T.obj₂ ⟶ T.obj₁)\n    (total : fst ≫ T.mor₁ + T.mor₂ ≫ inr = 𝟙 T.obj₂) :\n    BinaryBiproductData T.obj₁ T.obj₃ := by\n  have : Mono T.mor₁ := T.mono₁ hT hT₀\n  have eq : fst ≫ T.mor₁ = 𝟙 T.obj₂ - T.mor₂ ≫ inr := by rw [← total, add_sub_cancel_right]\n  exact\n    { bicone :=\n      { pt := T.obj₂\n        fst := fst\n        snd := T.mor₂\n        inl := T.mor₁\n        inr := inr\n        inl_fst := by\n          simp only [← cancel_mono T.mor₁, assoc, id_comp, eq, comp_sub, comp_id,\n            comp_distTriang_mor_zero₁₂_assoc _ hT, zero_comp, sub_zero]\n        inl_snd := comp_distTriang_mor_zero₁₂ _ hT\n        inr_fst := by\n          simp only [← cancel_mono T.mor₁, assoc, eq, comp_sub, reassoc_of% inr_snd,\n            comp_id, sub_self, zero_comp]\n        inr_snd := inr_snd }\n      isBilimit := isBinaryBilimitOfTotal _ total }\n\n"}
{"name":"CategoryTheory.Pretriangulated.binaryBiproductData_bicone_fst","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\ninst✝³ : CategoryTheory.Limits.HasZeroObject C\ninst✝² : CategoryTheory.HasShift C Int\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nhC : CategoryTheory.Pretriangulated C\nT : CategoryTheory.Pretriangulated.Triangle C\nhT : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T\nhT₀ : Eq T.mor₃ 0\ninr : Quiver.Hom T.obj₃ T.obj₂\ninr_snd : Eq (CategoryTheory.CategoryStruct.comp inr T.mor₂) (CategoryTheory.CategoryStruct.id T.obj₃)\nfst : Quiver.Hom T.obj₂ T.obj₁\ntotal : Eq (HAdd.hAdd (CategoryTheory.CategoryStruct.comp fst T.mor₁) (CategoryTheory.CategoryStruct.comp T.mor₂ inr)) (CategoryTheory.CategoryStruct.id T.obj₂)\n⊢ Eq (CategoryTheory.Pretriangulated.binaryBiproductData T hT hT₀ inr inr_snd fst total).bicone.fst fst","decl":"/-- Given a distinguished triangle `T` such that `T.mor₃ = 0` and the datum of morphisms\n`inr : T.obj₃ ⟶ T.obj₂` and `fst : T.obj₂ ⟶ T.obj₁` satisfying suitable relations, this\nis the binary biproduct data expressing that `T.obj₂` identifies to the binary\nbiproduct of `T.obj₁` and `T.obj₃`.\nSee also `exists_iso_binaryBiproduct_of_distTriang`. -/\n@[simps]\ndef binaryBiproductData (T : Triangle C) (hT : T ∈ distTriang C) (hT₀ : T.mor₃ = 0)\n    (inr : T.obj₃ ⟶ T.obj₂) (inr_snd : inr ≫ T.mor₂ = 𝟙 _) (fst : T.obj₂ ⟶ T.obj₁)\n    (total : fst ≫ T.mor₁ + T.mor₂ ≫ inr = 𝟙 T.obj₂) :\n    BinaryBiproductData T.obj₁ T.obj₃ := by\n  have : Mono T.mor₁ := T.mono₁ hT hT₀\n  have eq : fst ≫ T.mor₁ = 𝟙 T.obj₂ - T.mor₂ ≫ inr := by rw [← total, add_sub_cancel_right]\n  exact\n    { bicone :=\n      { pt := T.obj₂\n        fst := fst\n        snd := T.mor₂\n        inl := T.mor₁\n        inr := inr\n        inl_fst := by\n          simp only [← cancel_mono T.mor₁, assoc, id_comp, eq, comp_sub, comp_id,\n            comp_distTriang_mor_zero₁₂_assoc _ hT, zero_comp, sub_zero]\n        inl_snd := comp_distTriang_mor_zero₁₂ _ hT\n        inr_fst := by\n          simp only [← cancel_mono T.mor₁, assoc, eq, comp_sub, reassoc_of% inr_snd,\n            comp_id, sub_self, zero_comp]\n        inr_snd := inr_snd }\n      isBilimit := isBinaryBilimitOfTotal _ total }\n\n"}
{"name":"CategoryTheory.Pretriangulated.binaryBiproductData_bicone_inl","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\ninst✝³ : CategoryTheory.Limits.HasZeroObject C\ninst✝² : CategoryTheory.HasShift C Int\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nhC : CategoryTheory.Pretriangulated C\nT : CategoryTheory.Pretriangulated.Triangle C\nhT : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T\nhT₀ : Eq T.mor₃ 0\ninr : Quiver.Hom T.obj₃ T.obj₂\ninr_snd : Eq (CategoryTheory.CategoryStruct.comp inr T.mor₂) (CategoryTheory.CategoryStruct.id T.obj₃)\nfst : Quiver.Hom T.obj₂ T.obj₁\ntotal : Eq (HAdd.hAdd (CategoryTheory.CategoryStruct.comp fst T.mor₁) (CategoryTheory.CategoryStruct.comp T.mor₂ inr)) (CategoryTheory.CategoryStruct.id T.obj₂)\n⊢ Eq (CategoryTheory.Pretriangulated.binaryBiproductData T hT hT₀ inr inr_snd fst total).bicone.inl T.mor₁","decl":"/-- Given a distinguished triangle `T` such that `T.mor₃ = 0` and the datum of morphisms\n`inr : T.obj₃ ⟶ T.obj₂` and `fst : T.obj₂ ⟶ T.obj₁` satisfying suitable relations, this\nis the binary biproduct data expressing that `T.obj₂` identifies to the binary\nbiproduct of `T.obj₁` and `T.obj₃`.\nSee also `exists_iso_binaryBiproduct_of_distTriang`. -/\n@[simps]\ndef binaryBiproductData (T : Triangle C) (hT : T ∈ distTriang C) (hT₀ : T.mor₃ = 0)\n    (inr : T.obj₃ ⟶ T.obj₂) (inr_snd : inr ≫ T.mor₂ = 𝟙 _) (fst : T.obj₂ ⟶ T.obj₁)\n    (total : fst ≫ T.mor₁ + T.mor₂ ≫ inr = 𝟙 T.obj₂) :\n    BinaryBiproductData T.obj₁ T.obj₃ := by\n  have : Mono T.mor₁ := T.mono₁ hT hT₀\n  have eq : fst ≫ T.mor₁ = 𝟙 T.obj₂ - T.mor₂ ≫ inr := by rw [← total, add_sub_cancel_right]\n  exact\n    { bicone :=\n      { pt := T.obj₂\n        fst := fst\n        snd := T.mor₂\n        inl := T.mor₁\n        inr := inr\n        inl_fst := by\n          simp only [← cancel_mono T.mor₁, assoc, id_comp, eq, comp_sub, comp_id,\n            comp_distTriang_mor_zero₁₂_assoc _ hT, zero_comp, sub_zero]\n        inl_snd := comp_distTriang_mor_zero₁₂ _ hT\n        inr_fst := by\n          simp only [← cancel_mono T.mor₁, assoc, eq, comp_sub, reassoc_of% inr_snd,\n            comp_id, sub_self, zero_comp]\n        inr_snd := inr_snd }\n      isBilimit := isBinaryBilimitOfTotal _ total }\n\n"}
{"name":"CategoryTheory.Pretriangulated.binaryBiproductData_bicone_snd","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\ninst✝³ : CategoryTheory.Limits.HasZeroObject C\ninst✝² : CategoryTheory.HasShift C Int\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nhC : CategoryTheory.Pretriangulated C\nT : CategoryTheory.Pretriangulated.Triangle C\nhT : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T\nhT₀ : Eq T.mor₃ 0\ninr : Quiver.Hom T.obj₃ T.obj₂\ninr_snd : Eq (CategoryTheory.CategoryStruct.comp inr T.mor₂) (CategoryTheory.CategoryStruct.id T.obj₃)\nfst : Quiver.Hom T.obj₂ T.obj₁\ntotal : Eq (HAdd.hAdd (CategoryTheory.CategoryStruct.comp fst T.mor₁) (CategoryTheory.CategoryStruct.comp T.mor₂ inr)) (CategoryTheory.CategoryStruct.id T.obj₂)\n⊢ Eq (CategoryTheory.Pretriangulated.binaryBiproductData T hT hT₀ inr inr_snd fst total).bicone.snd T.mor₂","decl":"/-- Given a distinguished triangle `T` such that `T.mor₃ = 0` and the datum of morphisms\n`inr : T.obj₃ ⟶ T.obj₂` and `fst : T.obj₂ ⟶ T.obj₁` satisfying suitable relations, this\nis the binary biproduct data expressing that `T.obj₂` identifies to the binary\nbiproduct of `T.obj₁` and `T.obj₃`.\nSee also `exists_iso_binaryBiproduct_of_distTriang`. -/\n@[simps]\ndef binaryBiproductData (T : Triangle C) (hT : T ∈ distTriang C) (hT₀ : T.mor₃ = 0)\n    (inr : T.obj₃ ⟶ T.obj₂) (inr_snd : inr ≫ T.mor₂ = 𝟙 _) (fst : T.obj₂ ⟶ T.obj₁)\n    (total : fst ≫ T.mor₁ + T.mor₂ ≫ inr = 𝟙 T.obj₂) :\n    BinaryBiproductData T.obj₁ T.obj₃ := by\n  have : Mono T.mor₁ := T.mono₁ hT hT₀\n  have eq : fst ≫ T.mor₁ = 𝟙 T.obj₂ - T.mor₂ ≫ inr := by rw [← total, add_sub_cancel_right]\n  exact\n    { bicone :=\n      { pt := T.obj₂\n        fst := fst\n        snd := T.mor₂\n        inl := T.mor₁\n        inr := inr\n        inl_fst := by\n          simp only [← cancel_mono T.mor₁, assoc, id_comp, eq, comp_sub, comp_id,\n            comp_distTriang_mor_zero₁₂_assoc _ hT, zero_comp, sub_zero]\n        inl_snd := comp_distTriang_mor_zero₁₂ _ hT\n        inr_fst := by\n          simp only [← cancel_mono T.mor₁, assoc, eq, comp_sub, reassoc_of% inr_snd,\n            comp_id, sub_self, zero_comp]\n        inr_snd := inr_snd }\n      isBilimit := isBinaryBilimitOfTotal _ total }\n\n"}
{"name":"CategoryTheory.Pretriangulated.binaryBiproductData_bicone_pt","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\ninst✝³ : CategoryTheory.Limits.HasZeroObject C\ninst✝² : CategoryTheory.HasShift C Int\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nhC : CategoryTheory.Pretriangulated C\nT : CategoryTheory.Pretriangulated.Triangle C\nhT : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T\nhT₀ : Eq T.mor₃ 0\ninr : Quiver.Hom T.obj₃ T.obj₂\ninr_snd : Eq (CategoryTheory.CategoryStruct.comp inr T.mor₂) (CategoryTheory.CategoryStruct.id T.obj₃)\nfst : Quiver.Hom T.obj₂ T.obj₁\ntotal : Eq (HAdd.hAdd (CategoryTheory.CategoryStruct.comp fst T.mor₁) (CategoryTheory.CategoryStruct.comp T.mor₂ inr)) (CategoryTheory.CategoryStruct.id T.obj₂)\n⊢ Eq (CategoryTheory.Pretriangulated.binaryBiproductData T hT hT₀ inr inr_snd fst total).bicone.pt T.obj₂","decl":"/-- Given a distinguished triangle `T` such that `T.mor₃ = 0` and the datum of morphisms\n`inr : T.obj₃ ⟶ T.obj₂` and `fst : T.obj₂ ⟶ T.obj₁` satisfying suitable relations, this\nis the binary biproduct data expressing that `T.obj₂` identifies to the binary\nbiproduct of `T.obj₁` and `T.obj₃`.\nSee also `exists_iso_binaryBiproduct_of_distTriang`. -/\n@[simps]\ndef binaryBiproductData (T : Triangle C) (hT : T ∈ distTriang C) (hT₀ : T.mor₃ = 0)\n    (inr : T.obj₃ ⟶ T.obj₂) (inr_snd : inr ≫ T.mor₂ = 𝟙 _) (fst : T.obj₂ ⟶ T.obj₁)\n    (total : fst ≫ T.mor₁ + T.mor₂ ≫ inr = 𝟙 T.obj₂) :\n    BinaryBiproductData T.obj₁ T.obj₃ := by\n  have : Mono T.mor₁ := T.mono₁ hT hT₀\n  have eq : fst ≫ T.mor₁ = 𝟙 T.obj₂ - T.mor₂ ≫ inr := by rw [← total, add_sub_cancel_right]\n  exact\n    { bicone :=\n      { pt := T.obj₂\n        fst := fst\n        snd := T.mor₂\n        inl := T.mor₁\n        inr := inr\n        inl_fst := by\n          simp only [← cancel_mono T.mor₁, assoc, id_comp, eq, comp_sub, comp_id,\n            comp_distTriang_mor_zero₁₂_assoc _ hT, zero_comp, sub_zero]\n        inl_snd := comp_distTriang_mor_zero₁₂ _ hT\n        inr_fst := by\n          simp only [← cancel_mono T.mor₁, assoc, eq, comp_sub, reassoc_of% inr_snd,\n            comp_id, sub_self, zero_comp]\n        inr_snd := inr_snd }\n      isBilimit := isBinaryBilimitOfTotal _ total }\n\n"}
{"name":"CategoryTheory.Pretriangulated.instHasBinaryBiproducts","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\n⊢ CategoryTheory.Limits.HasBinaryBiproducts C","decl":"instance : HasBinaryBiproducts C := ⟨fun X₁ X₃ => by\n  obtain ⟨X₂, inl, snd, mem⟩ := distinguished_cocone_triangle₂ (0 : X₃ ⟶ X₁⟦(1 : ℤ)⟧)\n  obtain ⟨inr : X₃ ⟶ X₂, inr_snd : 𝟙 _ = inr ≫ snd⟩ :=\n    Triangle.coyoneda_exact₃ _ mem (𝟙 X₃) (by simp)\n  obtain ⟨fst : X₂ ⟶ X₁, hfst : 𝟙 X₂ - snd ≫ inr = fst ≫ inl⟩ :=\n    Triangle.coyoneda_exact₂ _ mem (𝟙 X₂ - snd ≫ inr) (by\n      dsimp\n      simp only [sub_comp, assoc, id_comp, ← inr_snd, comp_id, sub_self])\n  refine ⟨⟨binaryBiproductData _ mem rfl inr inr_snd.symm fst ?_⟩⟩\n  dsimp\n  simp only [← hfst, sub_add_cancel]⟩\n\n"}
{"name":"CategoryTheory.Pretriangulated.instHasFiniteProducts","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroObject C\ninst✝ : CategoryTheory.Preadditive C\n⊢ CategoryTheory.Limits.HasFiniteProducts C","decl":"instance : HasFiniteProducts C := hasFiniteProducts_of_has_binary_and_terminal\n"}
{"name":"CategoryTheory.Pretriangulated.instHasFiniteCoproducts","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroObject C\ninst✝ : CategoryTheory.Preadditive C\n⊢ CategoryTheory.Limits.HasFiniteCoproducts C","decl":"instance : HasFiniteCoproducts C := hasFiniteCoproducts_of_has_binary_and_initial\n"}
{"name":"CategoryTheory.Pretriangulated.instHasFiniteBiproducts","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroObject C\ninst✝ : CategoryTheory.Preadditive C\n⊢ CategoryTheory.Limits.HasFiniteBiproducts C","decl":"instance : HasFiniteBiproducts C := HasFiniteBiproducts.of_hasFiniteProducts\n\n"}
{"name":"CategoryTheory.Pretriangulated.exists_iso_binaryBiproduct_of_distTriang","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\ninst✝³ : CategoryTheory.Limits.HasZeroObject C\ninst✝² : CategoryTheory.HasShift C Int\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nhC : CategoryTheory.Pretriangulated C\nT : CategoryTheory.Pretriangulated.Triangle C\nhT : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T\nzero : Eq T.mor₃ 0\n⊢ Exists fun e => And (Eq (CategoryTheory.CategoryStruct.comp T.mor₁ e.hom) CategoryTheory.Limits.biprod.inl) (Eq T.mor₂ (CategoryTheory.CategoryStruct.comp e.hom CategoryTheory.Limits.biprod.snd))","decl":"lemma exists_iso_binaryBiproduct_of_distTriang (T : Triangle C) (hT : T ∈ distTriang C)\n    (zero : T.mor₃ = 0) :\n    ∃ (e : T.obj₂ ≅ T.obj₁ ⊞ T.obj₃), T.mor₁ ≫ e.hom = biprod.inl ∧\n      T.mor₂ = e.hom ≫ biprod.snd := by\n  have := T.epi₂ hT zero\n  have := isSplitEpi_of_epi T.mor₂\n  obtain ⟨fst, hfst⟩ := T.coyoneda_exact₂ hT (𝟙 T.obj₂ - T.mor₂ ≫ section_ T.mor₂) (by simp)\n  let d := binaryBiproductData _ hT zero (section_ T.mor₂) (by simp) fst\n    (by simp only [← hfst, sub_add_cancel])\n  refine ⟨biprod.uniqueUpToIso _ _ d.isBilimit, ⟨?_, by simp [d]⟩⟩\n  ext\n  · simpa [d] using d.bicone.inl_fst\n  · simpa [d] using d.bicone.inl_snd\n\n"}
{"name":"CategoryTheory.Pretriangulated.binaryBiproductTriangle_distinguished","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\ninst✝³ : CategoryTheory.Limits.HasZeroObject C\ninst✝² : CategoryTheory.HasShift C Int\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nhC : CategoryTheory.Pretriangulated C\nX₁ X₂ : C\n⊢ Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles (CategoryTheory.Pretriangulated.binaryBiproductTriangle X₁ X₂)","decl":"lemma binaryBiproductTriangle_distinguished (X₁ X₂ : C) :\n    binaryBiproductTriangle X₁ X₂ ∈ distTriang C := by\n  obtain ⟨Y, g, h, mem⟩ := distinguished_cocone_triangle₂ (0 : X₂ ⟶ X₁⟦(1 : ℤ)⟧)\n  obtain ⟨e, ⟨he₁, he₂⟩⟩ := exists_iso_binaryBiproduct_of_distTriang _ mem rfl\n  dsimp at he₁ he₂\n  refine isomorphic_distinguished _ mem _ (Iso.symm ?_)\n  refine Triangle.isoMk _ _ (Iso.refl _) e (Iso.refl _)\n    (by aesop_cat) (by aesop_cat) (by simp)\n\n"}
{"name":"CategoryTheory.Pretriangulated.binaryProductTriangle_distinguished","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\ninst✝³ : CategoryTheory.Limits.HasZeroObject C\ninst✝² : CategoryTheory.HasShift C Int\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nhC : CategoryTheory.Pretriangulated C\nX₁ X₂ : C\n⊢ Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles (CategoryTheory.Pretriangulated.binaryProductTriangle X₁ X₂)","decl":"lemma binaryProductTriangle_distinguished (X₁ X₂ : C) :\n    binaryProductTriangle X₁ X₂ ∈ distTriang C :=\n  isomorphic_distinguished _ (binaryBiproductTriangle_distinguished X₁ X₂) _\n    (binaryProductTriangleIsoBinaryBiproductTriangle X₁ X₂)\n\n"}
{"name":"CategoryTheory.Pretriangulated.completeDistinguishedTriangleMorphism_hom₁","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\ninst✝³ : CategoryTheory.Limits.HasZeroObject C\ninst✝² : CategoryTheory.HasShift C Int\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nhC : CategoryTheory.Pretriangulated C\nT₁ T₂ : CategoryTheory.Pretriangulated.Triangle C\nhT₁ : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T₁\nhT₂ : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T₂\na : Quiver.Hom T₁.obj₁ T₂.obj₁\nb : Quiver.Hom T₁.obj₂ T₂.obj₂\ncomm : Eq (CategoryTheory.CategoryStruct.comp T₁.mor₁ b) (CategoryTheory.CategoryStruct.comp a T₂.mor₁)\n⊢ Eq (CategoryTheory.Pretriangulated.completeDistinguishedTriangleMorphism T₁ T₂ hT₁ hT₂ a b comm).hom₁ a","decl":"/-- A chosen extension of a commutative square into a morphism of distinguished triangles. -/\n@[simps hom₁ hom₂]\ndef completeDistinguishedTriangleMorphism (T₁ T₂ : Triangle C)\n    (hT₁ : T₁ ∈ distTriang C) (hT₂ : T₂ ∈ distTriang C)\n    (a : T₁.obj₁ ⟶ T₂.obj₁) (b : T₁.obj₂ ⟶ T₂.obj₂) (comm : T₁.mor₁ ≫ b = a ≫ T₂.mor₁) :\n    T₁ ⟶ T₂ :=\n    have h := complete_distinguished_triangle_morphism _ _ hT₁ hT₂ a b comm\n    { hom₁ := a\n      hom₂ := b\n      hom₃ := h.choose\n      comm₁ := comm\n      comm₂ := h.choose_spec.1\n      comm₃ := h.choose_spec.2 }\n\n"}
{"name":"CategoryTheory.Pretriangulated.completeDistinguishedTriangleMorphism_hom₂","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\ninst✝³ : CategoryTheory.Limits.HasZeroObject C\ninst✝² : CategoryTheory.HasShift C Int\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nhC : CategoryTheory.Pretriangulated C\nT₁ T₂ : CategoryTheory.Pretriangulated.Triangle C\nhT₁ : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T₁\nhT₂ : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T₂\na : Quiver.Hom T₁.obj₁ T₂.obj₁\nb : Quiver.Hom T₁.obj₂ T₂.obj₂\ncomm : Eq (CategoryTheory.CategoryStruct.comp T₁.mor₁ b) (CategoryTheory.CategoryStruct.comp a T₂.mor₁)\n⊢ Eq (CategoryTheory.Pretriangulated.completeDistinguishedTriangleMorphism T₁ T₂ hT₁ hT₂ a b comm).hom₂ b","decl":"/-- A chosen extension of a commutative square into a morphism of distinguished triangles. -/\n@[simps hom₁ hom₂]\ndef completeDistinguishedTriangleMorphism (T₁ T₂ : Triangle C)\n    (hT₁ : T₁ ∈ distTriang C) (hT₂ : T₂ ∈ distTriang C)\n    (a : T₁.obj₁ ⟶ T₂.obj₁) (b : T₁.obj₂ ⟶ T₂.obj₂) (comm : T₁.mor₁ ≫ b = a ≫ T₂.mor₁) :\n    T₁ ⟶ T₂ :=\n    have h := complete_distinguished_triangle_morphism _ _ hT₁ hT₂ a b comm\n    { hom₁ := a\n      hom₂ := b\n      hom₃ := h.choose\n      comm₁ := comm\n      comm₂ := h.choose_spec.1\n      comm₃ := h.choose_spec.2 }\n\n"}
{"name":"CategoryTheory.Pretriangulated.productTriangle_distinguished","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninst✝⁸ : CategoryTheory.Category.{v, u} C\ninst✝⁷ : CategoryTheory.Limits.HasZeroObject C\ninst✝⁶ : CategoryTheory.HasShift C Int\ninst✝⁵ : CategoryTheory.Preadditive C\ninst✝⁴ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nhC : CategoryTheory.Pretriangulated C\nJ : Type u_1\nT : J → CategoryTheory.Pretriangulated.Triangle C\nhT : ∀ (j : J), Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles (T j)\ninst✝³ : CategoryTheory.Limits.HasProduct fun j => (T j).obj₁\ninst✝² : CategoryTheory.Limits.HasProduct fun j => (T j).obj₂\ninst✝¹ : CategoryTheory.Limits.HasProduct fun j => (T j).obj₃\ninst✝ : CategoryTheory.Limits.HasProduct fun j => (CategoryTheory.shiftFunctor C 1).obj (T j).obj₁\n⊢ Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles (CategoryTheory.Pretriangulated.productTriangle T)","decl":"/-- A product of distinguished triangles is distinguished -/\nlemma productTriangle_distinguished {J : Type*} (T : J → Triangle C)\n    (hT : ∀ j, T j ∈ distTriang C)\n    [HasProduct (fun j => (T j).obj₁)] [HasProduct (fun j => (T j).obj₂)]\n    [HasProduct (fun j => (T j).obj₃)] [HasProduct (fun j => (T j).obj₁⟦(1 : ℤ)⟧)] :\n    productTriangle T ∈ distTriang C := by\n  /- The proof proceeds by constructing a morphism of triangles\n    `φ' : T' ⟶ productTriangle T` with `T'` distinguished, and such that\n    `φ'.hom₁` and `φ'.hom₂` are identities. Then, it suffices to show that\n    `φ'.hom₃` is an isomorphism, which is achieved by using Yoneda's lemma\n    and diagram chases. -/\n  let f₁ := Limits.Pi.map (fun j => (T j).mor₁)\n  obtain ⟨Z, f₂, f₃, hT'⟩ := distinguished_cocone_triangle f₁\n  let T' := Triangle.mk f₁ f₂ f₃\n  change T' ∈ distTriang C at hT'\n  let φ : ∀ j, T' ⟶ T j := fun j => completeDistinguishedTriangleMorphism _ _\n    hT' (hT j) (Pi.π _ j) (Pi.π _ j) (by simp [f₁, T'])\n  let φ' := productTriangle.lift _ φ\n  have h₁ : φ'.hom₁ = 𝟙 _ := by aesop_cat\n  have h₂ : φ'.hom₂ = 𝟙 _ := by aesop_cat\n  have : IsIso φ'.hom₁ := by rw [h₁]; infer_instance\n  have : IsIso φ'.hom₂ := by rw [h₂]; infer_instance\n  suffices IsIso φ'.hom₃ by\n    have : IsIso φ' := by\n      apply Triangle.isIso_of_isIsos\n      all_goals infer_instance\n    exact isomorphic_distinguished _ hT' _ (asIso φ').symm\n  refine isIso_of_yoneda_map_bijective _ (fun A => ⟨?_, ?_⟩)\n  /- the proofs by diagram chase start here -/\n  · suffices Mono φ'.hom₃ by\n      intro a₁ a₂ ha\n      simpa only [← cancel_mono φ'.hom₃] using ha\n    rw [mono_iff_cancel_zero]\n    intro A f hf\n    have hf' : f ≫ T'.mor₃ = 0 := by\n      rw [← cancel_mono (φ'.hom₁⟦1⟧'), zero_comp, assoc, φ'.comm₃, reassoc_of% hf, zero_comp]\n    obtain ⟨g, hg⟩ := T'.coyoneda_exact₃ hT' f hf'\n    have hg' : ∀ j, (g ≫ Pi.π _ j) ≫ (T j).mor₂ = 0 := fun j => by\n      have : g ≫ T'.mor₂ ≫ φ'.hom₃ ≫ Pi.π _ j = 0 := by\n        rw [← reassoc_of% hg, reassoc_of% hf, zero_comp]\n      rw [φ'.comm₂_assoc, h₂, id_comp] at this\n      simpa using this\n    have hg'' := fun j => (T j).coyoneda_exact₂ (hT j) _ (hg' j)\n    let α := fun j => (hg'' j).choose\n    have hα : ∀ j, _ = α j ≫ _ := fun j => (hg'' j).choose_spec\n    have hg''' : g = Pi.lift α ≫ T'.mor₁ := by dsimp [f₁, T']; ext j; rw [hα]; simp\n    rw [hg, hg''', assoc, comp_distTriang_mor_zero₁₂ _ hT', comp_zero]\n  · intro a\n    obtain ⟨a', ha'⟩ : ∃ (a' : A ⟶ Z), a' ≫ T'.mor₃ = a ≫ (productTriangle T).mor₃ := by\n      have zero : ((productTriangle T).mor₃) ≫ (shiftFunctor C 1).map T'.mor₁ = 0 := by\n        rw [← cancel_mono (φ'.hom₂⟦1⟧'), zero_comp, assoc, ← Functor.map_comp, φ'.comm₁, h₁,\n          id_comp, productTriangle.zero₃₁]\n        intro j\n        exact comp_distTriang_mor_zero₃₁ _ (hT j)\n      have ⟨g, hg⟩ := T'.coyoneda_exact₁ hT' (a ≫ (productTriangle T).mor₃) (by\n        rw [assoc, zero, comp_zero])\n      exact ⟨g, hg.symm⟩\n    have ha'' := fun (j : J) => (T j).coyoneda_exact₃ (hT j) ((a - a' ≫ φ'.hom₃) ≫ Pi.π _ j) (by\n      simp only [sub_comp, assoc]\n      erw [← (productTriangle.π T j).comm₃]\n      rw [← φ'.comm₃_assoc]\n      rw [reassoc_of% ha', sub_eq_zero, h₁, Functor.map_id, id_comp])\n    let b := fun j => (ha'' j).choose\n    have hb : ∀ j, _  = b j ≫ _ := fun j => (ha'' j).choose_spec\n    have hb' : a - a' ≫ φ'.hom₃ = Pi.lift b ≫ (productTriangle T).mor₂ :=\n      Limits.Pi.hom_ext _ _ (fun j => by rw [hb]; simp)\n    have : (a' + (by exact Pi.lift b) ≫ T'.mor₂) ≫ φ'.hom₃ = a := by\n      rw [add_comp, assoc, φ'.comm₂, h₂, id_comp, ← hb', add_sub_cancel]\n    exact ⟨_, this⟩\n\n"}
{"name":"CategoryTheory.Pretriangulated.exists_iso_of_arrow_iso","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\ninst✝³ : CategoryTheory.Limits.HasZeroObject C\ninst✝² : CategoryTheory.HasShift C Int\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nhC : CategoryTheory.Pretriangulated C\nT₁ T₂ : CategoryTheory.Pretriangulated.Triangle C\nhT₁ : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T₁\nhT₂ : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T₂\ne : CategoryTheory.Iso (CategoryTheory.Arrow.mk T₁.mor₁) (CategoryTheory.Arrow.mk T₂.mor₁)\n⊢ Exists fun e' => And (Eq e'.hom.hom₁ e.hom.left) (Eq e'.hom.hom₂ e.hom.right)","decl":"lemma exists_iso_of_arrow_iso (T₁ T₂ : Triangle C) (hT₁ : T₁ ∈ distTriang C)\n    (hT₂ : T₂ ∈ distTriang C) (e : Arrow.mk T₁.mor₁ ≅ Arrow.mk T₂.mor₁) :\n    ∃ (e' : T₁ ≅ T₂), e'.hom.hom₁ = e.hom.left ∧ e'.hom.hom₂ = e.hom.right := by\n  let φ := completeDistinguishedTriangleMorphism T₁ T₂ hT₁ hT₂ e.hom.left e.hom.right e.hom.w.symm\n  have : IsIso φ.hom₁ := by dsimp [φ]; infer_instance\n  have : IsIso φ.hom₂ := by dsimp [φ]; infer_instance\n  have : IsIso φ.hom₃ := isIso₃_of_isIso₁₂ φ hT₁ hT₂ inferInstance inferInstance\n  have : IsIso φ := by\n    apply Triangle.isIso_of_isIsos\n    all_goals infer_instance\n  exact ⟨asIso φ, by simp [φ], by simp [φ]⟩\n\n"}
{"name":"CategoryTheory.Pretriangulated.isoTriangleOfIso₁₂_hom_hom₁","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\ninst✝³ : CategoryTheory.Limits.HasZeroObject C\ninst✝² : CategoryTheory.HasShift C Int\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nhC : CategoryTheory.Pretriangulated C\nT₁ T₂ : CategoryTheory.Pretriangulated.Triangle C\nhT₁ : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T₁\nhT₂ : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T₂\ne₁ : CategoryTheory.Iso T₁.obj₁ T₂.obj₁\ne₂ : CategoryTheory.Iso T₁.obj₂ T₂.obj₂\ncomm : Eq (CategoryTheory.CategoryStruct.comp T₁.mor₁ e₂.hom) (CategoryTheory.CategoryStruct.comp e₁.hom T₂.mor₁)\n⊢ Eq (CategoryTheory.Pretriangulated.isoTriangleOfIso₁₂ T₁ T₂ hT₁ hT₂ e₁ e₂ comm).hom.hom₁ e₁.hom","decl":"/-- A choice of isomorphism `T₁ ≅ T₂` between two distinguished triangles\nwhen we are given two isomorphisms `e₁ : T₁.obj₁ ≅ T₂.obj₁` and `e₂ : T₁.obj₂ ≅ T₂.obj₂`. -/\n@[simps! hom_hom₁ hom_hom₂ inv_hom₁ inv_hom₂]\ndef isoTriangleOfIso₁₂ (T₁ T₂ : Triangle C) (hT₁ : T₁ ∈ distTriang C)\n    (hT₂ : T₂ ∈ distTriang C) (e₁ : T₁.obj₁ ≅ T₂.obj₁) (e₂ : T₁.obj₂ ≅ T₂.obj₂)\n    (comm : T₁.mor₁ ≫ e₂.hom = e₁.hom ≫ T₂.mor₁) : T₁ ≅ T₂ := by\n  have h := exists_iso_of_arrow_iso T₁ T₂ hT₁ hT₂ (Arrow.isoMk e₁ e₂ comm.symm)\n  exact Triangle.isoMk _ _ e₁ e₂ (Triangle.π₃.mapIso h.choose) comm (by\n    have eq := h.choose_spec.2\n    dsimp at eq ⊢\n    conv_rhs => rw [← eq, ← TriangleMorphism.comm₂]) (by\n    have eq := h.choose_spec.1\n    dsimp at eq ⊢\n    conv_lhs => rw [← eq, TriangleMorphism.comm₃])\n\n"}
{"name":"CategoryTheory.Pretriangulated.isoTriangleOfIso₁₂_hom_hom₂","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\ninst✝³ : CategoryTheory.Limits.HasZeroObject C\ninst✝² : CategoryTheory.HasShift C Int\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nhC : CategoryTheory.Pretriangulated C\nT₁ T₂ : CategoryTheory.Pretriangulated.Triangle C\nhT₁ : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T₁\nhT₂ : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T₂\ne₁ : CategoryTheory.Iso T₁.obj₁ T₂.obj₁\ne₂ : CategoryTheory.Iso T₁.obj₂ T₂.obj₂\ncomm : Eq (CategoryTheory.CategoryStruct.comp T₁.mor₁ e₂.hom) (CategoryTheory.CategoryStruct.comp e₁.hom T₂.mor₁)\n⊢ Eq (CategoryTheory.Pretriangulated.isoTriangleOfIso₁₂ T₁ T₂ hT₁ hT₂ e₁ e₂ comm).hom.hom₂ e₂.hom","decl":"/-- A choice of isomorphism `T₁ ≅ T₂` between two distinguished triangles\nwhen we are given two isomorphisms `e₁ : T₁.obj₁ ≅ T₂.obj₁` and `e₂ : T₁.obj₂ ≅ T₂.obj₂`. -/\n@[simps! hom_hom₁ hom_hom₂ inv_hom₁ inv_hom₂]\ndef isoTriangleOfIso₁₂ (T₁ T₂ : Triangle C) (hT₁ : T₁ ∈ distTriang C)\n    (hT₂ : T₂ ∈ distTriang C) (e₁ : T₁.obj₁ ≅ T₂.obj₁) (e₂ : T₁.obj₂ ≅ T₂.obj₂)\n    (comm : T₁.mor₁ ≫ e₂.hom = e₁.hom ≫ T₂.mor₁) : T₁ ≅ T₂ := by\n  have h := exists_iso_of_arrow_iso T₁ T₂ hT₁ hT₂ (Arrow.isoMk e₁ e₂ comm.symm)\n  exact Triangle.isoMk _ _ e₁ e₂ (Triangle.π₃.mapIso h.choose) comm (by\n    have eq := h.choose_spec.2\n    dsimp at eq ⊢\n    conv_rhs => rw [← eq, ← TriangleMorphism.comm₂]) (by\n    have eq := h.choose_spec.1\n    dsimp at eq ⊢\n    conv_lhs => rw [← eq, TriangleMorphism.comm₃])\n\n"}
{"name":"CategoryTheory.Pretriangulated.isoTriangleOfIso₁₂_inv_hom₁","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\ninst✝³ : CategoryTheory.Limits.HasZeroObject C\ninst✝² : CategoryTheory.HasShift C Int\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nhC : CategoryTheory.Pretriangulated C\nT₁ T₂ : CategoryTheory.Pretriangulated.Triangle C\nhT₁ : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T₁\nhT₂ : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T₂\ne₁ : CategoryTheory.Iso T₁.obj₁ T₂.obj₁\ne₂ : CategoryTheory.Iso T₁.obj₂ T₂.obj₂\ncomm : Eq (CategoryTheory.CategoryStruct.comp T₁.mor₁ e₂.hom) (CategoryTheory.CategoryStruct.comp e₁.hom T₂.mor₁)\n⊢ Eq (CategoryTheory.Pretriangulated.isoTriangleOfIso₁₂ T₁ T₂ hT₁ hT₂ e₁ e₂ comm).inv.hom₁ e₁.inv","decl":"/-- A choice of isomorphism `T₁ ≅ T₂` between two distinguished triangles\nwhen we are given two isomorphisms `e₁ : T₁.obj₁ ≅ T₂.obj₁` and `e₂ : T₁.obj₂ ≅ T₂.obj₂`. -/\n@[simps! hom_hom₁ hom_hom₂ inv_hom₁ inv_hom₂]\ndef isoTriangleOfIso₁₂ (T₁ T₂ : Triangle C) (hT₁ : T₁ ∈ distTriang C)\n    (hT₂ : T₂ ∈ distTriang C) (e₁ : T₁.obj₁ ≅ T₂.obj₁) (e₂ : T₁.obj₂ ≅ T₂.obj₂)\n    (comm : T₁.mor₁ ≫ e₂.hom = e₁.hom ≫ T₂.mor₁) : T₁ ≅ T₂ := by\n  have h := exists_iso_of_arrow_iso T₁ T₂ hT₁ hT₂ (Arrow.isoMk e₁ e₂ comm.symm)\n  exact Triangle.isoMk _ _ e₁ e₂ (Triangle.π₃.mapIso h.choose) comm (by\n    have eq := h.choose_spec.2\n    dsimp at eq ⊢\n    conv_rhs => rw [← eq, ← TriangleMorphism.comm₂]) (by\n    have eq := h.choose_spec.1\n    dsimp at eq ⊢\n    conv_lhs => rw [← eq, TriangleMorphism.comm₃])\n\n"}
{"name":"CategoryTheory.Pretriangulated.isoTriangleOfIso₁₂_inv_hom₂","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\ninst✝³ : CategoryTheory.Limits.HasZeroObject C\ninst✝² : CategoryTheory.HasShift C Int\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nhC : CategoryTheory.Pretriangulated C\nT₁ T₂ : CategoryTheory.Pretriangulated.Triangle C\nhT₁ : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T₁\nhT₂ : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T₂\ne₁ : CategoryTheory.Iso T₁.obj₁ T₂.obj₁\ne₂ : CategoryTheory.Iso T₁.obj₂ T₂.obj₂\ncomm : Eq (CategoryTheory.CategoryStruct.comp T₁.mor₁ e₂.hom) (CategoryTheory.CategoryStruct.comp e₁.hom T₂.mor₁)\n⊢ Eq (CategoryTheory.Pretriangulated.isoTriangleOfIso₁₂ T₁ T₂ hT₁ hT₂ e₁ e₂ comm).inv.hom₂ e₂.inv","decl":"/-- A choice of isomorphism `T₁ ≅ T₂` between two distinguished triangles\nwhen we are given two isomorphisms `e₁ : T₁.obj₁ ≅ T₂.obj₁` and `e₂ : T₁.obj₂ ≅ T₂.obj₂`. -/\n@[simps! hom_hom₁ hom_hom₂ inv_hom₁ inv_hom₂]\ndef isoTriangleOfIso₁₂ (T₁ T₂ : Triangle C) (hT₁ : T₁ ∈ distTriang C)\n    (hT₂ : T₂ ∈ distTriang C) (e₁ : T₁.obj₁ ≅ T₂.obj₁) (e₂ : T₁.obj₂ ≅ T₂.obj₂)\n    (comm : T₁.mor₁ ≫ e₂.hom = e₁.hom ≫ T₂.mor₁) : T₁ ≅ T₂ := by\n  have h := exists_iso_of_arrow_iso T₁ T₂ hT₁ hT₂ (Arrow.isoMk e₁ e₂ comm.symm)\n  exact Triangle.isoMk _ _ e₁ e₂ (Triangle.π₃.mapIso h.choose) comm (by\n    have eq := h.choose_spec.2\n    dsimp at eq ⊢\n    conv_rhs => rw [← eq, ← TriangleMorphism.comm₂]) (by\n    have eq := h.choose_spec.1\n    dsimp at eq ⊢\n    conv_lhs => rw [← eq, TriangleMorphism.comm₃])\n\n"}
