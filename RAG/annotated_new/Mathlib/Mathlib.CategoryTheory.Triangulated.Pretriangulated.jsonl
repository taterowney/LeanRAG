{"name":"CategoryTheory.Pretriangulated.isomorphic_distinguished","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninstâœâ´ : CategoryTheory.Category.{v, u} C\ninstâœÂ³ : CategoryTheory.Limits.HasZeroObject C\ninstâœÂ² : CategoryTheory.HasShift C Int\ninstâœÂ¹ : CategoryTheory.Preadditive C\ninstâœ : âˆ€ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nself : CategoryTheory.Pretriangulated C\nTâ‚ : CategoryTheory.Pretriangulated.Triangle C\naâœ : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles Tâ‚\nTâ‚‚ : CategoryTheory.Pretriangulated.Triangle C\nxâœ : CategoryTheory.Iso Tâ‚‚ Tâ‚\nâŠ¢ Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles Tâ‚‚","decl":"/-- A preadditive category `C` with an additive shift, and a class of \"distinguished triangles\"\nrelative to that shift is called pretriangulated if the following hold:\n* Any triangle that is isomorphic to a distinguished triangle is also distinguished.\n* Any triangle of the form `(X,X,0,id,0,0)` is distinguished.\n* For any morphism `f : X âŸ¶ Y` there exists a distinguished triangle of the form `(X,Y,Z,f,g,h)`.\n* The triangle `(X,Y,Z,f,g,h)` is distinguished if and only if `(Y,Z,XâŸ¦1âŸ§,g,h,-fâŸ¦1âŸ§)` is.\n* Given a diagram:\n  ```\n        f       g       h\n    X  â”€â”€â”€> Y  â”€â”€â”€> Z  â”€â”€â”€> XâŸ¦1âŸ§\n    â”‚       â”‚                â”‚\n    â”‚a      â”‚b               â”‚aâŸ¦1âŸ§'\n    V       V                V\n    X' â”€â”€â”€> Y' â”€â”€â”€> Z' â”€â”€â”€> X'âŸ¦1âŸ§\n        f'      g'      h'\n  ```\n  where the left square commutes, and whose rows are distinguished triangles,\n  there exists a morphism `c : Z âŸ¶ Z'` such that `(a,b,c)` is a triangle morphism.\n-/\n@[stacks 0145]\nclass Pretriangulated [âˆ€ n : â„¤, Functor.Additive (shiftFunctor C n)] where\n  /-- a class of triangle which are called `distinguished` -/\n  distinguishedTriangles : Set (Triangle C)\n  /-- a triangle that is isomorphic to a distinguished triangle is distinguished -/\n  isomorphic_distinguished :\n    âˆ€ Tâ‚ âˆˆ distinguishedTriangles, âˆ€ (Tâ‚‚) (_ : Tâ‚‚ â‰… Tâ‚), Tâ‚‚ âˆˆ distinguishedTriangles\n  /-- obvious triangles `X âŸ¶ X âŸ¶ 0 âŸ¶ XâŸ¦1âŸ§` are distinguished -/\n  contractible_distinguished : âˆ€ X : C, contractibleTriangle X âˆˆ distinguishedTriangles\n  /-- any morphism `X âŸ¶ Y` is part of a distinguished triangle `X âŸ¶ Y âŸ¶ Z âŸ¶ XâŸ¦1âŸ§` -/\n  distinguished_cocone_triangle :\n    âˆ€ {X Y : C} (f : X âŸ¶ Y),\n      âˆƒ (Z : C) (g : Y âŸ¶ Z) (h : Z âŸ¶ XâŸ¦(1 : â„¤)âŸ§), Triangle.mk f g h âˆˆ distinguishedTriangles\n  /-- a triangle is distinguished iff it is so after rotating it -/\n  rotate_distinguished_triangle :\n    âˆ€ T : Triangle C, T âˆˆ distinguishedTriangles â†” T.rotate âˆˆ distinguishedTriangles\n  /-- given two distinguished triangle, a commutative square\n        can be extended as morphism of triangles -/\n  complete_distinguished_triangle_morphism :\n    âˆ€ (Tâ‚ Tâ‚‚ : Triangle C) (_ : Tâ‚ âˆˆ distinguishedTriangles) (_ : Tâ‚‚ âˆˆ distinguishedTriangles)\n      (a : Tâ‚.objâ‚ âŸ¶ Tâ‚‚.objâ‚) (b : Tâ‚.objâ‚‚ âŸ¶ Tâ‚‚.objâ‚‚) (_ : Tâ‚.morâ‚ â‰« b = a â‰« Tâ‚‚.morâ‚),\n      âˆƒ c : Tâ‚.objâ‚ƒ âŸ¶ Tâ‚‚.objâ‚ƒ, Tâ‚.morâ‚‚ â‰« c = b â‰« Tâ‚‚.morâ‚‚ âˆ§ Tâ‚.morâ‚ƒ â‰« aâŸ¦1âŸ§' = c â‰« Tâ‚‚.morâ‚ƒ\n\n\n"}
{"name":"CategoryTheory.Pretriangulated.contractible_distinguished","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninstâœâ´ : CategoryTheory.Category.{v, u} C\ninstâœÂ³ : CategoryTheory.Limits.HasZeroObject C\ninstâœÂ² : CategoryTheory.HasShift C Int\ninstâœÂ¹ : CategoryTheory.Preadditive C\ninstâœ : âˆ€ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nself : CategoryTheory.Pretriangulated C\nX : C\nâŠ¢ Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles (CategoryTheory.Pretriangulated.contractibleTriangle X)","decl":"/-- A preadditive category `C` with an additive shift, and a class of \"distinguished triangles\"\nrelative to that shift is called pretriangulated if the following hold:\n* Any triangle that is isomorphic to a distinguished triangle is also distinguished.\n* Any triangle of the form `(X,X,0,id,0,0)` is distinguished.\n* For any morphism `f : X âŸ¶ Y` there exists a distinguished triangle of the form `(X,Y,Z,f,g,h)`.\n* The triangle `(X,Y,Z,f,g,h)` is distinguished if and only if `(Y,Z,XâŸ¦1âŸ§,g,h,-fâŸ¦1âŸ§)` is.\n* Given a diagram:\n  ```\n        f       g       h\n    X  â”€â”€â”€> Y  â”€â”€â”€> Z  â”€â”€â”€> XâŸ¦1âŸ§\n    â”‚       â”‚                â”‚\n    â”‚a      â”‚b               â”‚aâŸ¦1âŸ§'\n    V       V                V\n    X' â”€â”€â”€> Y' â”€â”€â”€> Z' â”€â”€â”€> X'âŸ¦1âŸ§\n        f'      g'      h'\n  ```\n  where the left square commutes, and whose rows are distinguished triangles,\n  there exists a morphism `c : Z âŸ¶ Z'` such that `(a,b,c)` is a triangle morphism.\n-/\n@[stacks 0145]\nclass Pretriangulated [âˆ€ n : â„¤, Functor.Additive (shiftFunctor C n)] where\n  /-- a class of triangle which are called `distinguished` -/\n  distinguishedTriangles : Set (Triangle C)\n  /-- a triangle that is isomorphic to a distinguished triangle is distinguished -/\n  isomorphic_distinguished :\n    âˆ€ Tâ‚ âˆˆ distinguishedTriangles, âˆ€ (Tâ‚‚) (_ : Tâ‚‚ â‰… Tâ‚), Tâ‚‚ âˆˆ distinguishedTriangles\n  /-- obvious triangles `X âŸ¶ X âŸ¶ 0 âŸ¶ XâŸ¦1âŸ§` are distinguished -/\n  contractible_distinguished : âˆ€ X : C, contractibleTriangle X âˆˆ distinguishedTriangles\n  /-- any morphism `X âŸ¶ Y` is part of a distinguished triangle `X âŸ¶ Y âŸ¶ Z âŸ¶ XâŸ¦1âŸ§` -/\n  distinguished_cocone_triangle :\n    âˆ€ {X Y : C} (f : X âŸ¶ Y),\n      âˆƒ (Z : C) (g : Y âŸ¶ Z) (h : Z âŸ¶ XâŸ¦(1 : â„¤)âŸ§), Triangle.mk f g h âˆˆ distinguishedTriangles\n  /-- a triangle is distinguished iff it is so after rotating it -/\n  rotate_distinguished_triangle :\n    âˆ€ T : Triangle C, T âˆˆ distinguishedTriangles â†” T.rotate âˆˆ distinguishedTriangles\n  /-- given two distinguished triangle, a commutative square\n        can be extended as morphism of triangles -/\n  complete_distinguished_triangle_morphism :\n    âˆ€ (Tâ‚ Tâ‚‚ : Triangle C) (_ : Tâ‚ âˆˆ distinguishedTriangles) (_ : Tâ‚‚ âˆˆ distinguishedTriangles)\n      (a : Tâ‚.objâ‚ âŸ¶ Tâ‚‚.objâ‚) (b : Tâ‚.objâ‚‚ âŸ¶ Tâ‚‚.objâ‚‚) (_ : Tâ‚.morâ‚ â‰« b = a â‰« Tâ‚‚.morâ‚),\n      âˆƒ c : Tâ‚.objâ‚ƒ âŸ¶ Tâ‚‚.objâ‚ƒ, Tâ‚.morâ‚‚ â‰« c = b â‰« Tâ‚‚.morâ‚‚ âˆ§ Tâ‚.morâ‚ƒ â‰« aâŸ¦1âŸ§' = c â‰« Tâ‚‚.morâ‚ƒ\n\n\n"}
{"name":"CategoryTheory.Pretriangulated.complete_distinguished_triangle_morphism","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninstâœâ´ : CategoryTheory.Category.{v, u} C\ninstâœÂ³ : CategoryTheory.Limits.HasZeroObject C\ninstâœÂ² : CategoryTheory.HasShift C Int\ninstâœÂ¹ : CategoryTheory.Preadditive C\ninstâœ : âˆ€ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nself : CategoryTheory.Pretriangulated C\nTâ‚ Tâ‚‚ : CategoryTheory.Pretriangulated.Triangle C\nxâœÂ² : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles Tâ‚\nxâœÂ¹ : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles Tâ‚‚\na : Quiver.Hom Tâ‚.objâ‚ Tâ‚‚.objâ‚\nb : Quiver.Hom Tâ‚.objâ‚‚ Tâ‚‚.objâ‚‚\nxâœ : Eq (CategoryTheory.CategoryStruct.comp Tâ‚.morâ‚ b) (CategoryTheory.CategoryStruct.comp a Tâ‚‚.morâ‚)\nâŠ¢ Exists fun c => And (Eq (CategoryTheory.CategoryStruct.comp Tâ‚.morâ‚‚ c) (CategoryTheory.CategoryStruct.comp b Tâ‚‚.morâ‚‚)) (Eq (CategoryTheory.CategoryStruct.comp Tâ‚.morâ‚ƒ ((CategoryTheory.shiftFunctor C 1).map a)) (CategoryTheory.CategoryStruct.comp c Tâ‚‚.morâ‚ƒ))","decl":"/-- A preadditive category `C` with an additive shift, and a class of \"distinguished triangles\"\nrelative to that shift is called pretriangulated if the following hold:\n* Any triangle that is isomorphic to a distinguished triangle is also distinguished.\n* Any triangle of the form `(X,X,0,id,0,0)` is distinguished.\n* For any morphism `f : X âŸ¶ Y` there exists a distinguished triangle of the form `(X,Y,Z,f,g,h)`.\n* The triangle `(X,Y,Z,f,g,h)` is distinguished if and only if `(Y,Z,XâŸ¦1âŸ§,g,h,-fâŸ¦1âŸ§)` is.\n* Given a diagram:\n  ```\n        f       g       h\n    X  â”€â”€â”€> Y  â”€â”€â”€> Z  â”€â”€â”€> XâŸ¦1âŸ§\n    â”‚       â”‚                â”‚\n    â”‚a      â”‚b               â”‚aâŸ¦1âŸ§'\n    V       V                V\n    X' â”€â”€â”€> Y' â”€â”€â”€> Z' â”€â”€â”€> X'âŸ¦1âŸ§\n        f'      g'      h'\n  ```\n  where the left square commutes, and whose rows are distinguished triangles,\n  there exists a morphism `c : Z âŸ¶ Z'` such that `(a,b,c)` is a triangle morphism.\n-/\n@[stacks 0145]\nclass Pretriangulated [âˆ€ n : â„¤, Functor.Additive (shiftFunctor C n)] where\n  /-- a class of triangle which are called `distinguished` -/\n  distinguishedTriangles : Set (Triangle C)\n  /-- a triangle that is isomorphic to a distinguished triangle is distinguished -/\n  isomorphic_distinguished :\n    âˆ€ Tâ‚ âˆˆ distinguishedTriangles, âˆ€ (Tâ‚‚) (_ : Tâ‚‚ â‰… Tâ‚), Tâ‚‚ âˆˆ distinguishedTriangles\n  /-- obvious triangles `X âŸ¶ X âŸ¶ 0 âŸ¶ XâŸ¦1âŸ§` are distinguished -/\n  contractible_distinguished : âˆ€ X : C, contractibleTriangle X âˆˆ distinguishedTriangles\n  /-- any morphism `X âŸ¶ Y` is part of a distinguished triangle `X âŸ¶ Y âŸ¶ Z âŸ¶ XâŸ¦1âŸ§` -/\n  distinguished_cocone_triangle :\n    âˆ€ {X Y : C} (f : X âŸ¶ Y),\n      âˆƒ (Z : C) (g : Y âŸ¶ Z) (h : Z âŸ¶ XâŸ¦(1 : â„¤)âŸ§), Triangle.mk f g h âˆˆ distinguishedTriangles\n  /-- a triangle is distinguished iff it is so after rotating it -/\n  rotate_distinguished_triangle :\n    âˆ€ T : Triangle C, T âˆˆ distinguishedTriangles â†” T.rotate âˆˆ distinguishedTriangles\n  /-- given two distinguished triangle, a commutative square\n        can be extended as morphism of triangles -/\n  complete_distinguished_triangle_morphism :\n    âˆ€ (Tâ‚ Tâ‚‚ : Triangle C) (_ : Tâ‚ âˆˆ distinguishedTriangles) (_ : Tâ‚‚ âˆˆ distinguishedTriangles)\n      (a : Tâ‚.objâ‚ âŸ¶ Tâ‚‚.objâ‚) (b : Tâ‚.objâ‚‚ âŸ¶ Tâ‚‚.objâ‚‚) (_ : Tâ‚.morâ‚ â‰« b = a â‰« Tâ‚‚.morâ‚),\n      âˆƒ c : Tâ‚.objâ‚ƒ âŸ¶ Tâ‚‚.objâ‚ƒ, Tâ‚.morâ‚‚ â‰« c = b â‰« Tâ‚‚.morâ‚‚ âˆ§ Tâ‚.morâ‚ƒ â‰« aâŸ¦1âŸ§' = c â‰« Tâ‚‚.morâ‚ƒ\n\n\n"}
{"name":"CategoryTheory.Pretriangulated.rotate_distinguished_triangle","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninstâœâ´ : CategoryTheory.Category.{v, u} C\ninstâœÂ³ : CategoryTheory.Limits.HasZeroObject C\ninstâœÂ² : CategoryTheory.HasShift C Int\ninstâœÂ¹ : CategoryTheory.Preadditive C\ninstâœ : âˆ€ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nself : CategoryTheory.Pretriangulated C\nT : CategoryTheory.Pretriangulated.Triangle C\nâŠ¢ Iff (Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T) (Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T.rotate)","decl":"/-- A preadditive category `C` with an additive shift, and a class of \"distinguished triangles\"\nrelative to that shift is called pretriangulated if the following hold:\n* Any triangle that is isomorphic to a distinguished triangle is also distinguished.\n* Any triangle of the form `(X,X,0,id,0,0)` is distinguished.\n* For any morphism `f : X âŸ¶ Y` there exists a distinguished triangle of the form `(X,Y,Z,f,g,h)`.\n* The triangle `(X,Y,Z,f,g,h)` is distinguished if and only if `(Y,Z,XâŸ¦1âŸ§,g,h,-fâŸ¦1âŸ§)` is.\n* Given a diagram:\n  ```\n        f       g       h\n    X  â”€â”€â”€> Y  â”€â”€â”€> Z  â”€â”€â”€> XâŸ¦1âŸ§\n    â”‚       â”‚                â”‚\n    â”‚a      â”‚b               â”‚aâŸ¦1âŸ§'\n    V       V                V\n    X' â”€â”€â”€> Y' â”€â”€â”€> Z' â”€â”€â”€> X'âŸ¦1âŸ§\n        f'      g'      h'\n  ```\n  where the left square commutes, and whose rows are distinguished triangles,\n  there exists a morphism `c : Z âŸ¶ Z'` such that `(a,b,c)` is a triangle morphism.\n-/\n@[stacks 0145]\nclass Pretriangulated [âˆ€ n : â„¤, Functor.Additive (shiftFunctor C n)] where\n  /-- a class of triangle which are called `distinguished` -/\n  distinguishedTriangles : Set (Triangle C)\n  /-- a triangle that is isomorphic to a distinguished triangle is distinguished -/\n  isomorphic_distinguished :\n    âˆ€ Tâ‚ âˆˆ distinguishedTriangles, âˆ€ (Tâ‚‚) (_ : Tâ‚‚ â‰… Tâ‚), Tâ‚‚ âˆˆ distinguishedTriangles\n  /-- obvious triangles `X âŸ¶ X âŸ¶ 0 âŸ¶ XâŸ¦1âŸ§` are distinguished -/\n  contractible_distinguished : âˆ€ X : C, contractibleTriangle X âˆˆ distinguishedTriangles\n  /-- any morphism `X âŸ¶ Y` is part of a distinguished triangle `X âŸ¶ Y âŸ¶ Z âŸ¶ XâŸ¦1âŸ§` -/\n  distinguished_cocone_triangle :\n    âˆ€ {X Y : C} (f : X âŸ¶ Y),\n      âˆƒ (Z : C) (g : Y âŸ¶ Z) (h : Z âŸ¶ XâŸ¦(1 : â„¤)âŸ§), Triangle.mk f g h âˆˆ distinguishedTriangles\n  /-- a triangle is distinguished iff it is so after rotating it -/\n  rotate_distinguished_triangle :\n    âˆ€ T : Triangle C, T âˆˆ distinguishedTriangles â†” T.rotate âˆˆ distinguishedTriangles\n  /-- given two distinguished triangle, a commutative square\n        can be extended as morphism of triangles -/\n  complete_distinguished_triangle_morphism :\n    âˆ€ (Tâ‚ Tâ‚‚ : Triangle C) (_ : Tâ‚ âˆˆ distinguishedTriangles) (_ : Tâ‚‚ âˆˆ distinguishedTriangles)\n      (a : Tâ‚.objâ‚ âŸ¶ Tâ‚‚.objâ‚) (b : Tâ‚.objâ‚‚ âŸ¶ Tâ‚‚.objâ‚‚) (_ : Tâ‚.morâ‚ â‰« b = a â‰« Tâ‚‚.morâ‚),\n      âˆƒ c : Tâ‚.objâ‚ƒ âŸ¶ Tâ‚‚.objâ‚ƒ, Tâ‚.morâ‚‚ â‰« c = b â‰« Tâ‚‚.morâ‚‚ âˆ§ Tâ‚.morâ‚ƒ â‰« aâŸ¦1âŸ§' = c â‰« Tâ‚‚.morâ‚ƒ\n\n\n"}
{"name":"CategoryTheory.Pretriangulated.distinguished_cocone_triangle","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninstâœâ´ : CategoryTheory.Category.{v, u} C\ninstâœÂ³ : CategoryTheory.Limits.HasZeroObject C\ninstâœÂ² : CategoryTheory.HasShift C Int\ninstâœÂ¹ : CategoryTheory.Preadditive C\ninstâœ : âˆ€ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nself : CategoryTheory.Pretriangulated C\nX Y : C\nf : Quiver.Hom X Y\nâŠ¢ Exists fun Z => Exists fun g => Exists fun h => Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles (CategoryTheory.Pretriangulated.Triangle.mk f g h)","decl":"/-- A preadditive category `C` with an additive shift, and a class of \"distinguished triangles\"\nrelative to that shift is called pretriangulated if the following hold:\n* Any triangle that is isomorphic to a distinguished triangle is also distinguished.\n* Any triangle of the form `(X,X,0,id,0,0)` is distinguished.\n* For any morphism `f : X âŸ¶ Y` there exists a distinguished triangle of the form `(X,Y,Z,f,g,h)`.\n* The triangle `(X,Y,Z,f,g,h)` is distinguished if and only if `(Y,Z,XâŸ¦1âŸ§,g,h,-fâŸ¦1âŸ§)` is.\n* Given a diagram:\n  ```\n        f       g       h\n    X  â”€â”€â”€> Y  â”€â”€â”€> Z  â”€â”€â”€> XâŸ¦1âŸ§\n    â”‚       â”‚                â”‚\n    â”‚a      â”‚b               â”‚aâŸ¦1âŸ§'\n    V       V                V\n    X' â”€â”€â”€> Y' â”€â”€â”€> Z' â”€â”€â”€> X'âŸ¦1âŸ§\n        f'      g'      h'\n  ```\n  where the left square commutes, and whose rows are distinguished triangles,\n  there exists a morphism `c : Z âŸ¶ Z'` such that `(a,b,c)` is a triangle morphism.\n-/\n@[stacks 0145]\nclass Pretriangulated [âˆ€ n : â„¤, Functor.Additive (shiftFunctor C n)] where\n  /-- a class of triangle which are called `distinguished` -/\n  distinguishedTriangles : Set (Triangle C)\n  /-- a triangle that is isomorphic to a distinguished triangle is distinguished -/\n  isomorphic_distinguished :\n    âˆ€ Tâ‚ âˆˆ distinguishedTriangles, âˆ€ (Tâ‚‚) (_ : Tâ‚‚ â‰… Tâ‚), Tâ‚‚ âˆˆ distinguishedTriangles\n  /-- obvious triangles `X âŸ¶ X âŸ¶ 0 âŸ¶ XâŸ¦1âŸ§` are distinguished -/\n  contractible_distinguished : âˆ€ X : C, contractibleTriangle X âˆˆ distinguishedTriangles\n  /-- any morphism `X âŸ¶ Y` is part of a distinguished triangle `X âŸ¶ Y âŸ¶ Z âŸ¶ XâŸ¦1âŸ§` -/\n  distinguished_cocone_triangle :\n    âˆ€ {X Y : C} (f : X âŸ¶ Y),\n      âˆƒ (Z : C) (g : Y âŸ¶ Z) (h : Z âŸ¶ XâŸ¦(1 : â„¤)âŸ§), Triangle.mk f g h âˆˆ distinguishedTriangles\n  /-- a triangle is distinguished iff it is so after rotating it -/\n  rotate_distinguished_triangle :\n    âˆ€ T : Triangle C, T âˆˆ distinguishedTriangles â†” T.rotate âˆˆ distinguishedTriangles\n  /-- given two distinguished triangle, a commutative square\n        can be extended as morphism of triangles -/\n  complete_distinguished_triangle_morphism :\n    âˆ€ (Tâ‚ Tâ‚‚ : Triangle C) (_ : Tâ‚ âˆˆ distinguishedTriangles) (_ : Tâ‚‚ âˆˆ distinguishedTriangles)\n      (a : Tâ‚.objâ‚ âŸ¶ Tâ‚‚.objâ‚) (b : Tâ‚.objâ‚‚ âŸ¶ Tâ‚‚.objâ‚‚) (_ : Tâ‚.morâ‚ â‰« b = a â‰« Tâ‚‚.morâ‚),\n      âˆƒ c : Tâ‚.objâ‚ƒ âŸ¶ Tâ‚‚.objâ‚ƒ, Tâ‚.morâ‚‚ â‰« c = b â‰« Tâ‚‚.morâ‚‚ âˆ§ Tâ‚.morâ‚ƒ â‰« aâŸ¦1âŸ§' = c â‰« Tâ‚‚.morâ‚ƒ\n\n\n"}
{"name":"CategoryTheory.Pretriangulated.distinguished_iff_of_iso","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninstâœâ´ : CategoryTheory.Category.{v, u} C\ninstâœÂ³ : CategoryTheory.Limits.HasZeroObject C\ninstâœÂ² : CategoryTheory.HasShift C Int\ninstâœÂ¹ : CategoryTheory.Preadditive C\ninstâœ : âˆ€ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nhC : CategoryTheory.Pretriangulated C\nTâ‚ Tâ‚‚ : CategoryTheory.Pretriangulated.Triangle C\ne : CategoryTheory.Iso Tâ‚ Tâ‚‚\nâŠ¢ Iff (Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles Tâ‚) (Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles Tâ‚‚)","decl":"lemma distinguished_iff_of_iso {Tâ‚ Tâ‚‚ : Triangle C} (e : Tâ‚ â‰… Tâ‚‚) :\n    (Tâ‚ âˆˆ distTriang C) â†” Tâ‚‚ âˆˆ distTriang C :=\n  âŸ¨fun hTâ‚ => isomorphic_distinguished _ hTâ‚ _ e.symm,\n    fun hTâ‚‚ => isomorphic_distinguished _ hTâ‚‚ _ eâŸ©\n\n"}
{"name":"CategoryTheory.Pretriangulated.rot_of_distTriang","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninstâœâ´ : CategoryTheory.Category.{v, u} C\ninstâœÂ³ : CategoryTheory.Limits.HasZeroObject C\ninstâœÂ² : CategoryTheory.HasShift C Int\ninstâœÂ¹ : CategoryTheory.Preadditive C\ninstâœ : âˆ€ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nhC : CategoryTheory.Pretriangulated C\nT : CategoryTheory.Pretriangulated.Triangle C\nH : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T\nâŠ¢ Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T.rotate","decl":"/-- Given any distinguished triangle `T`, then we know `T.rotate` is also distinguished.\n-/\ntheorem rot_of_distTriang (T : Triangle C) (H : T âˆˆ distTriang C) : T.rotate âˆˆ distTriang C :=\n  (rotate_distinguished_triangle T).mp H\n\n"}
{"name":"CategoryTheory.Pretriangulated.inv_rot_of_distTriang","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninstâœâ´ : CategoryTheory.Category.{v, u} C\ninstâœÂ³ : CategoryTheory.Limits.HasZeroObject C\ninstâœÂ² : CategoryTheory.HasShift C Int\ninstâœÂ¹ : CategoryTheory.Preadditive C\ninstâœ : âˆ€ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nhC : CategoryTheory.Pretriangulated C\nT : CategoryTheory.Pretriangulated.Triangle C\nH : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T\nâŠ¢ Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T.invRotate","decl":"/-- Given any distinguished triangle `T`, then we know `T.inv_rotate` is also distinguished.\n-/\ntheorem inv_rot_of_distTriang (T : Triangle C) (H : T âˆˆ distTriang C) :\n    T.invRotate âˆˆ distTriang C :=\n  (rotate_distinguished_triangle T.invRotate).mpr\n    (isomorphic_distinguished T H T.invRotate.rotate (invRotCompRot.app T))\n\n"}
{"name":"CategoryTheory.Pretriangulated.comp_distTriang_mor_zeroâ‚â‚‚","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninstâœâ´ : CategoryTheory.Category.{v, u} C\ninstâœÂ³ : CategoryTheory.Limits.HasZeroObject C\ninstâœÂ² : CategoryTheory.HasShift C Int\ninstâœÂ¹ : CategoryTheory.Preadditive C\ninstâœ : âˆ€ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nhC : CategoryTheory.Pretriangulated C\nT : CategoryTheory.Pretriangulated.Triangle C\nH : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp T.morâ‚ T.morâ‚‚) 0","decl":"/-- Given any distinguished triangle\n```\n      f       g       h\n  X  â”€â”€â”€> Y  â”€â”€â”€> Z  â”€â”€â”€> XâŸ¦1âŸ§\n```\nthe composition `f â‰« g = 0`. -/\n@[reassoc, stacks 0146]\ntheorem comp_distTriang_mor_zeroâ‚â‚‚ (T) (H : T âˆˆ (distTriang C)) : T.morâ‚ â‰« T.morâ‚‚ = 0 := by\n  obtain âŸ¨c, hcâŸ© :=\n    complete_distinguished_triangle_morphism _ _ (contractible_distinguished T.objâ‚) H (ğŸ™ T.objâ‚)\n      T.morâ‚ rfl\n  simpa only [contractibleTriangle_morâ‚‚, zero_comp] using hc.left.symm\n\n"}
{"name":"CategoryTheory.Pretriangulated.comp_distTriang_mor_zeroâ‚â‚‚_assoc","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninstâœâ´ : CategoryTheory.Category.{v, u} C\ninstâœÂ³ : CategoryTheory.Limits.HasZeroObject C\ninstâœÂ² : CategoryTheory.HasShift C Int\ninstâœÂ¹ : CategoryTheory.Preadditive C\ninstâœ : âˆ€ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nhC : CategoryTheory.Pretriangulated C\nT : CategoryTheory.Pretriangulated.Triangle C\nH : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T\nZ : C\nh : Quiver.Hom T.objâ‚ƒ Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp T.morâ‚ (CategoryTheory.CategoryStruct.comp T.morâ‚‚ h)) (CategoryTheory.CategoryStruct.comp 0 h)","decl":"/-- Given any distinguished triangle\n```\n      f       g       h\n  X  â”€â”€â”€> Y  â”€â”€â”€> Z  â”€â”€â”€> XâŸ¦1âŸ§\n```\nthe composition `f â‰« g = 0`. -/\n@[reassoc, stacks 0146]\ntheorem comp_distTriang_mor_zeroâ‚â‚‚ (T) (H : T âˆˆ (distTriang C)) : T.morâ‚ â‰« T.morâ‚‚ = 0 := by\n  obtain âŸ¨c, hcâŸ© :=\n    complete_distinguished_triangle_morphism _ _ (contractible_distinguished T.objâ‚) H (ğŸ™ T.objâ‚)\n      T.morâ‚ rfl\n  simpa only [contractibleTriangle_morâ‚‚, zero_comp] using hc.left.symm\n\n"}
{"name":"CategoryTheory.Pretriangulated.comp_distTriang_mor_zeroâ‚‚â‚ƒ","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninstâœâ´ : CategoryTheory.Category.{v, u} C\ninstâœÂ³ : CategoryTheory.Limits.HasZeroObject C\ninstâœÂ² : CategoryTheory.HasShift C Int\ninstâœÂ¹ : CategoryTheory.Preadditive C\ninstâœ : âˆ€ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nhC : CategoryTheory.Pretriangulated C\nT : CategoryTheory.Pretriangulated.Triangle C\nH : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp T.morâ‚‚ T.morâ‚ƒ) 0","decl":"/-- Given any distinguished triangle\n```\n      f       g       h\n  X  â”€â”€â”€> Y  â”€â”€â”€> Z  â”€â”€â”€> XâŸ¦1âŸ§\n```\nthe composition `g â‰« h = 0`. -/\n@[reassoc, stacks 0146]\ntheorem comp_distTriang_mor_zeroâ‚‚â‚ƒ (T : Triangle C) (H : T âˆˆ distTriang C) :\n    T.morâ‚‚ â‰« T.morâ‚ƒ = 0 :=\n  comp_distTriang_mor_zeroâ‚â‚‚ T.rotate (rot_of_distTriang T H)\n\n"}
{"name":"CategoryTheory.Pretriangulated.comp_distTriang_mor_zeroâ‚‚â‚ƒ_assoc","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninstâœâ´ : CategoryTheory.Category.{v, u} C\ninstâœÂ³ : CategoryTheory.Limits.HasZeroObject C\ninstâœÂ² : CategoryTheory.HasShift C Int\ninstâœÂ¹ : CategoryTheory.Preadditive C\ninstâœ : âˆ€ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nhC : CategoryTheory.Pretriangulated C\nT : CategoryTheory.Pretriangulated.Triangle C\nH : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T\nZ : C\nh : Quiver.Hom ((CategoryTheory.shiftFunctor C 1).obj T.objâ‚) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp T.morâ‚‚ (CategoryTheory.CategoryStruct.comp T.morâ‚ƒ h)) (CategoryTheory.CategoryStruct.comp 0 h)","decl":"/-- Given any distinguished triangle\n```\n      f       g       h\n  X  â”€â”€â”€> Y  â”€â”€â”€> Z  â”€â”€â”€> XâŸ¦1âŸ§\n```\nthe composition `g â‰« h = 0`. -/\n@[reassoc, stacks 0146]\ntheorem comp_distTriang_mor_zeroâ‚‚â‚ƒ (T : Triangle C) (H : T âˆˆ distTriang C) :\n    T.morâ‚‚ â‰« T.morâ‚ƒ = 0 :=\n  comp_distTriang_mor_zeroâ‚â‚‚ T.rotate (rot_of_distTriang T H)\n\n"}
{"name":"CategoryTheory.Pretriangulated.comp_distTriang_mor_zeroâ‚ƒâ‚_assoc","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninstâœâ´ : CategoryTheory.Category.{v, u} C\ninstâœÂ³ : CategoryTheory.Limits.HasZeroObject C\ninstâœÂ² : CategoryTheory.HasShift C Int\ninstâœÂ¹ : CategoryTheory.Preadditive C\ninstâœ : âˆ€ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nhC : CategoryTheory.Pretriangulated C\nT : CategoryTheory.Pretriangulated.Triangle C\nH : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T\nZ : C\nh : Quiver.Hom ((CategoryTheory.shiftFunctor C 1).obj T.objâ‚‚) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp T.morâ‚ƒ (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor C 1).map T.morâ‚) h)) (CategoryTheory.CategoryStruct.comp 0 h)","decl":"/-- Given any distinguished triangle\n```\n      f       g       h\n  X  â”€â”€â”€> Y  â”€â”€â”€> Z  â”€â”€â”€> XâŸ¦1âŸ§\n```\nthe composition `h â‰« fâŸ¦1âŸ§ = 0`. -/\n@[reassoc, stacks 0146]\ntheorem comp_distTriang_mor_zeroâ‚ƒâ‚ (T : Triangle C) (H : T âˆˆ distTriang C) :\n    T.morâ‚ƒ â‰« T.morâ‚âŸ¦1âŸ§' = 0 := by\n  have Hâ‚‚ := rot_of_distTriang T.rotate (rot_of_distTriang T H)\n  simpa using comp_distTriang_mor_zeroâ‚â‚‚ T.rotate.rotate Hâ‚‚\n\n"}
{"name":"CategoryTheory.Pretriangulated.comp_distTriang_mor_zeroâ‚ƒâ‚","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninstâœâ´ : CategoryTheory.Category.{v, u} C\ninstâœÂ³ : CategoryTheory.Limits.HasZeroObject C\ninstâœÂ² : CategoryTheory.HasShift C Int\ninstâœÂ¹ : CategoryTheory.Preadditive C\ninstâœ : âˆ€ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nhC : CategoryTheory.Pretriangulated C\nT : CategoryTheory.Pretriangulated.Triangle C\nH : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp T.morâ‚ƒ ((CategoryTheory.shiftFunctor C 1).map T.morâ‚)) 0","decl":"/-- Given any distinguished triangle\n```\n      f       g       h\n  X  â”€â”€â”€> Y  â”€â”€â”€> Z  â”€â”€â”€> XâŸ¦1âŸ§\n```\nthe composition `h â‰« fâŸ¦1âŸ§ = 0`. -/\n@[reassoc, stacks 0146]\ntheorem comp_distTriang_mor_zeroâ‚ƒâ‚ (T : Triangle C) (H : T âˆˆ distTriang C) :\n    T.morâ‚ƒ â‰« T.morâ‚âŸ¦1âŸ§' = 0 := by\n  have Hâ‚‚ := rot_of_distTriang T.rotate (rot_of_distTriang T H)\n  simpa using comp_distTriang_mor_zeroâ‚â‚‚ T.rotate.rotate Hâ‚‚\n\n"}
{"name":"CategoryTheory.Pretriangulated.shortComplexOfDistTriangle_Xâ‚‚","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninstâœâ´ : CategoryTheory.Category.{v, u} C\ninstâœÂ³ : CategoryTheory.Limits.HasZeroObject C\ninstâœÂ² : CategoryTheory.HasShift C Int\ninstâœÂ¹ : CategoryTheory.Preadditive C\ninstâœ : âˆ€ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nhC : CategoryTheory.Pretriangulated C\nT : CategoryTheory.Pretriangulated.Triangle C\nhT : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T\nâŠ¢ Eq (CategoryTheory.Pretriangulated.shortComplexOfDistTriangle T hT).Xâ‚‚ T.objâ‚‚","decl":"/-- The short complex `T.objâ‚ âŸ¶ T.objâ‚‚ âŸ¶ T.objâ‚ƒ` attached to a distinguished triangle. -/\n@[simps]\ndef shortComplexOfDistTriangle (T : Triangle C) (hT : T âˆˆ distTriang C) : ShortComplex C :=\n  ShortComplex.mk T.morâ‚ T.morâ‚‚ (comp_distTriang_mor_zeroâ‚â‚‚ _ hT)\n\n"}
{"name":"CategoryTheory.Pretriangulated.shortComplexOfDistTriangle_Xâ‚ƒ","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninstâœâ´ : CategoryTheory.Category.{v, u} C\ninstâœÂ³ : CategoryTheory.Limits.HasZeroObject C\ninstâœÂ² : CategoryTheory.HasShift C Int\ninstâœÂ¹ : CategoryTheory.Preadditive C\ninstâœ : âˆ€ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nhC : CategoryTheory.Pretriangulated C\nT : CategoryTheory.Pretriangulated.Triangle C\nhT : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T\nâŠ¢ Eq (CategoryTheory.Pretriangulated.shortComplexOfDistTriangle T hT).Xâ‚ƒ T.objâ‚ƒ","decl":"/-- The short complex `T.objâ‚ âŸ¶ T.objâ‚‚ âŸ¶ T.objâ‚ƒ` attached to a distinguished triangle. -/\n@[simps]\ndef shortComplexOfDistTriangle (T : Triangle C) (hT : T âˆˆ distTriang C) : ShortComplex C :=\n  ShortComplex.mk T.morâ‚ T.morâ‚‚ (comp_distTriang_mor_zeroâ‚â‚‚ _ hT)\n\n"}
{"name":"CategoryTheory.Pretriangulated.shortComplexOfDistTriangle_Xâ‚","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninstâœâ´ : CategoryTheory.Category.{v, u} C\ninstâœÂ³ : CategoryTheory.Limits.HasZeroObject C\ninstâœÂ² : CategoryTheory.HasShift C Int\ninstâœÂ¹ : CategoryTheory.Preadditive C\ninstâœ : âˆ€ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nhC : CategoryTheory.Pretriangulated C\nT : CategoryTheory.Pretriangulated.Triangle C\nhT : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T\nâŠ¢ Eq (CategoryTheory.Pretriangulated.shortComplexOfDistTriangle T hT).Xâ‚ T.objâ‚","decl":"/-- The short complex `T.objâ‚ âŸ¶ T.objâ‚‚ âŸ¶ T.objâ‚ƒ` attached to a distinguished triangle. -/\n@[simps]\ndef shortComplexOfDistTriangle (T : Triangle C) (hT : T âˆˆ distTriang C) : ShortComplex C :=\n  ShortComplex.mk T.morâ‚ T.morâ‚‚ (comp_distTriang_mor_zeroâ‚â‚‚ _ hT)\n\n"}
{"name":"CategoryTheory.Pretriangulated.shortComplexOfDistTriangle_f","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninstâœâ´ : CategoryTheory.Category.{v, u} C\ninstâœÂ³ : CategoryTheory.Limits.HasZeroObject C\ninstâœÂ² : CategoryTheory.HasShift C Int\ninstâœÂ¹ : CategoryTheory.Preadditive C\ninstâœ : âˆ€ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nhC : CategoryTheory.Pretriangulated C\nT : CategoryTheory.Pretriangulated.Triangle C\nhT : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T\nâŠ¢ Eq (CategoryTheory.Pretriangulated.shortComplexOfDistTriangle T hT).f T.morâ‚","decl":"/-- The short complex `T.objâ‚ âŸ¶ T.objâ‚‚ âŸ¶ T.objâ‚ƒ` attached to a distinguished triangle. -/\n@[simps]\ndef shortComplexOfDistTriangle (T : Triangle C) (hT : T âˆˆ distTriang C) : ShortComplex C :=\n  ShortComplex.mk T.morâ‚ T.morâ‚‚ (comp_distTriang_mor_zeroâ‚â‚‚ _ hT)\n\n"}
{"name":"CategoryTheory.Pretriangulated.shortComplexOfDistTriangle_g","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninstâœâ´ : CategoryTheory.Category.{v, u} C\ninstâœÂ³ : CategoryTheory.Limits.HasZeroObject C\ninstâœÂ² : CategoryTheory.HasShift C Int\ninstâœÂ¹ : CategoryTheory.Preadditive C\ninstâœ : âˆ€ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nhC : CategoryTheory.Pretriangulated C\nT : CategoryTheory.Pretriangulated.Triangle C\nhT : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T\nâŠ¢ Eq (CategoryTheory.Pretriangulated.shortComplexOfDistTriangle T hT).g T.morâ‚‚","decl":"/-- The short complex `T.objâ‚ âŸ¶ T.objâ‚‚ âŸ¶ T.objâ‚ƒ` attached to a distinguished triangle. -/\n@[simps]\ndef shortComplexOfDistTriangle (T : Triangle C) (hT : T âˆˆ distTriang C) : ShortComplex C :=\n  ShortComplex.mk T.morâ‚ T.morâ‚‚ (comp_distTriang_mor_zeroâ‚â‚‚ _ hT)\n\n"}
{"name":"CategoryTheory.Pretriangulated.shortComplexOfDistTriangleIsoOfIso_hom_Ï„â‚‚","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninstâœâ´ : CategoryTheory.Category.{v, u} C\ninstâœÂ³ : CategoryTheory.Limits.HasZeroObject C\ninstâœÂ² : CategoryTheory.HasShift C Int\ninstâœÂ¹ : CategoryTheory.Preadditive C\ninstâœ : âˆ€ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nhC : CategoryTheory.Pretriangulated C\nT T' : CategoryTheory.Pretriangulated.Triangle C\ne : CategoryTheory.Iso T T'\nhT : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T\nâŠ¢ Eq (CategoryTheory.Pretriangulated.shortComplexOfDistTriangleIsoOfIso e hT).hom.Ï„â‚‚ e.hom.homâ‚‚","decl":"/-- The isomorphism between the short complex attached to\ntwo isomorphic distinguished triangles. -/\n@[simps!]\ndef shortComplexOfDistTriangleIsoOfIso {T T' : Triangle C} (e : T â‰… T') (hT : T âˆˆ distTriang C) :\n    shortComplexOfDistTriangle T hT â‰… shortComplexOfDistTriangle T'\n      (isomorphic_distinguished _ hT _ e.symm) :=\n  ShortComplex.isoMk (Triangle.Ï€â‚.mapIso e) (Triangle.Ï€â‚‚.mapIso e) (Triangle.Ï€â‚ƒ.mapIso e)\n\n"}
{"name":"CategoryTheory.Pretriangulated.shortComplexOfDistTriangleIsoOfIso_hom_Ï„â‚","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninstâœâ´ : CategoryTheory.Category.{v, u} C\ninstâœÂ³ : CategoryTheory.Limits.HasZeroObject C\ninstâœÂ² : CategoryTheory.HasShift C Int\ninstâœÂ¹ : CategoryTheory.Preadditive C\ninstâœ : âˆ€ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nhC : CategoryTheory.Pretriangulated C\nT T' : CategoryTheory.Pretriangulated.Triangle C\ne : CategoryTheory.Iso T T'\nhT : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T\nâŠ¢ Eq (CategoryTheory.Pretriangulated.shortComplexOfDistTriangleIsoOfIso e hT).hom.Ï„â‚ e.hom.homâ‚","decl":"/-- The isomorphism between the short complex attached to\ntwo isomorphic distinguished triangles. -/\n@[simps!]\ndef shortComplexOfDistTriangleIsoOfIso {T T' : Triangle C} (e : T â‰… T') (hT : T âˆˆ distTriang C) :\n    shortComplexOfDistTriangle T hT â‰… shortComplexOfDistTriangle T'\n      (isomorphic_distinguished _ hT _ e.symm) :=\n  ShortComplex.isoMk (Triangle.Ï€â‚.mapIso e) (Triangle.Ï€â‚‚.mapIso e) (Triangle.Ï€â‚ƒ.mapIso e)\n\n"}
{"name":"CategoryTheory.Pretriangulated.shortComplexOfDistTriangleIsoOfIso_hom_Ï„â‚ƒ","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninstâœâ´ : CategoryTheory.Category.{v, u} C\ninstâœÂ³ : CategoryTheory.Limits.HasZeroObject C\ninstâœÂ² : CategoryTheory.HasShift C Int\ninstâœÂ¹ : CategoryTheory.Preadditive C\ninstâœ : âˆ€ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nhC : CategoryTheory.Pretriangulated C\nT T' : CategoryTheory.Pretriangulated.Triangle C\ne : CategoryTheory.Iso T T'\nhT : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T\nâŠ¢ Eq (CategoryTheory.Pretriangulated.shortComplexOfDistTriangleIsoOfIso e hT).hom.Ï„â‚ƒ e.hom.homâ‚ƒ","decl":"/-- The isomorphism between the short complex attached to\ntwo isomorphic distinguished triangles. -/\n@[simps!]\ndef shortComplexOfDistTriangleIsoOfIso {T T' : Triangle C} (e : T â‰… T') (hT : T âˆˆ distTriang C) :\n    shortComplexOfDistTriangle T hT â‰… shortComplexOfDistTriangle T'\n      (isomorphic_distinguished _ hT _ e.symm) :=\n  ShortComplex.isoMk (Triangle.Ï€â‚.mapIso e) (Triangle.Ï€â‚‚.mapIso e) (Triangle.Ï€â‚ƒ.mapIso e)\n\n"}
{"name":"CategoryTheory.Pretriangulated.shortComplexOfDistTriangleIsoOfIso_inv_Ï„â‚‚","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninstâœâ´ : CategoryTheory.Category.{v, u} C\ninstâœÂ³ : CategoryTheory.Limits.HasZeroObject C\ninstâœÂ² : CategoryTheory.HasShift C Int\ninstâœÂ¹ : CategoryTheory.Preadditive C\ninstâœ : âˆ€ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nhC : CategoryTheory.Pretriangulated C\nT T' : CategoryTheory.Pretriangulated.Triangle C\ne : CategoryTheory.Iso T T'\nhT : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T\nâŠ¢ Eq (CategoryTheory.Pretriangulated.shortComplexOfDistTriangleIsoOfIso e hT).inv.Ï„â‚‚ e.inv.homâ‚‚","decl":"/-- The isomorphism between the short complex attached to\ntwo isomorphic distinguished triangles. -/\n@[simps!]\ndef shortComplexOfDistTriangleIsoOfIso {T T' : Triangle C} (e : T â‰… T') (hT : T âˆˆ distTriang C) :\n    shortComplexOfDistTriangle T hT â‰… shortComplexOfDistTriangle T'\n      (isomorphic_distinguished _ hT _ e.symm) :=\n  ShortComplex.isoMk (Triangle.Ï€â‚.mapIso e) (Triangle.Ï€â‚‚.mapIso e) (Triangle.Ï€â‚ƒ.mapIso e)\n\n"}
{"name":"CategoryTheory.Pretriangulated.shortComplexOfDistTriangleIsoOfIso_inv_Ï„â‚ƒ","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninstâœâ´ : CategoryTheory.Category.{v, u} C\ninstâœÂ³ : CategoryTheory.Limits.HasZeroObject C\ninstâœÂ² : CategoryTheory.HasShift C Int\ninstâœÂ¹ : CategoryTheory.Preadditive C\ninstâœ : âˆ€ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nhC : CategoryTheory.Pretriangulated C\nT T' : CategoryTheory.Pretriangulated.Triangle C\ne : CategoryTheory.Iso T T'\nhT : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T\nâŠ¢ Eq (CategoryTheory.Pretriangulated.shortComplexOfDistTriangleIsoOfIso e hT).inv.Ï„â‚ƒ e.inv.homâ‚ƒ","decl":"/-- The isomorphism between the short complex attached to\ntwo isomorphic distinguished triangles. -/\n@[simps!]\ndef shortComplexOfDistTriangleIsoOfIso {T T' : Triangle C} (e : T â‰… T') (hT : T âˆˆ distTriang C) :\n    shortComplexOfDistTriangle T hT â‰… shortComplexOfDistTriangle T'\n      (isomorphic_distinguished _ hT _ e.symm) :=\n  ShortComplex.isoMk (Triangle.Ï€â‚.mapIso e) (Triangle.Ï€â‚‚.mapIso e) (Triangle.Ï€â‚ƒ.mapIso e)\n\n"}
{"name":"CategoryTheory.Pretriangulated.shortComplexOfDistTriangleIsoOfIso_inv_Ï„â‚","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninstâœâ´ : CategoryTheory.Category.{v, u} C\ninstâœÂ³ : CategoryTheory.Limits.HasZeroObject C\ninstâœÂ² : CategoryTheory.HasShift C Int\ninstâœÂ¹ : CategoryTheory.Preadditive C\ninstâœ : âˆ€ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nhC : CategoryTheory.Pretriangulated C\nT T' : CategoryTheory.Pretriangulated.Triangle C\ne : CategoryTheory.Iso T T'\nhT : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T\nâŠ¢ Eq (CategoryTheory.Pretriangulated.shortComplexOfDistTriangleIsoOfIso e hT).inv.Ï„â‚ e.inv.homâ‚","decl":"/-- The isomorphism between the short complex attached to\ntwo isomorphic distinguished triangles. -/\n@[simps!]\ndef shortComplexOfDistTriangleIsoOfIso {T T' : Triangle C} (e : T â‰… T') (hT : T âˆˆ distTriang C) :\n    shortComplexOfDistTriangle T hT â‰… shortComplexOfDistTriangle T'\n      (isomorphic_distinguished _ hT _ e.symm) :=\n  ShortComplex.isoMk (Triangle.Ï€â‚.mapIso e) (Triangle.Ï€â‚‚.mapIso e) (Triangle.Ï€â‚ƒ.mapIso e)\n\n"}
{"name":"CategoryTheory.Pretriangulated.distinguished_cocone_triangleâ‚","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninstâœâ´ : CategoryTheory.Category.{v, u} C\ninstâœÂ³ : CategoryTheory.Limits.HasZeroObject C\ninstâœÂ² : CategoryTheory.HasShift C Int\ninstâœÂ¹ : CategoryTheory.Preadditive C\ninstâœ : âˆ€ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nhC : CategoryTheory.Pretriangulated C\nY Z : C\ng : Quiver.Hom Y Z\nâŠ¢ Exists fun X => Exists fun f => Exists fun h => Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles (CategoryTheory.Pretriangulated.Triangle.mk f g h)","decl":"/-- Any morphism `Y âŸ¶ Z` is part of a distinguished triangle `X âŸ¶ Y âŸ¶ Z âŸ¶ XâŸ¦1âŸ§` -/\nlemma distinguished_cocone_triangleâ‚ {Y Z : C} (g : Y âŸ¶ Z) :\n    âˆƒ (X : C) (f : X âŸ¶ Y) (h : Z âŸ¶ XâŸ¦(1 : â„¤)âŸ§), Triangle.mk f g h âˆˆ distTriang C := by\n  obtain âŸ¨X', f', g', memâŸ© := distinguished_cocone_triangle g\n  exact âŸ¨_, _, _, inv_rot_of_distTriang _ memâŸ©\n\n"}
{"name":"CategoryTheory.Pretriangulated.distinguished_cocone_triangleâ‚‚","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninstâœâ´ : CategoryTheory.Category.{v, u} C\ninstâœÂ³ : CategoryTheory.Limits.HasZeroObject C\ninstâœÂ² : CategoryTheory.HasShift C Int\ninstâœÂ¹ : CategoryTheory.Preadditive C\ninstâœ : âˆ€ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nhC : CategoryTheory.Pretriangulated C\nZ X : C\nh : Quiver.Hom Z ((CategoryTheory.shiftFunctor C 1).obj X)\nâŠ¢ Exists fun Y => Exists fun f => Exists fun g => Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles (CategoryTheory.Pretriangulated.Triangle.mk f g h)","decl":"/-- Any morphism `Z âŸ¶ XâŸ¦1âŸ§` is part of a distinguished triangle `X âŸ¶ Y âŸ¶ Z âŸ¶ XâŸ¦1âŸ§` -/\nlemma distinguished_cocone_triangleâ‚‚ {Z X : C} (h : Z âŸ¶ XâŸ¦(1 : â„¤)âŸ§) :\n    âˆƒ (Y : C) (f : X âŸ¶ Y) (g : Y âŸ¶ Z), Triangle.mk f g h âˆˆ distTriang C := by\n  obtain âŸ¨Y', f', g', memâŸ© := distinguished_cocone_triangle h\n  let T' := (Triangle.mk h f' g').invRotate.invRotate\n  refine âŸ¨T'.objâ‚‚, ((shiftEquiv C (1 : â„¤)).unitIso.app X).hom â‰« T'.morâ‚, T'.morâ‚‚,\n    isomorphic_distinguished _ (inv_rot_of_distTriang _ (inv_rot_of_distTriang _ mem)) _ ?_âŸ©\n  exact Triangle.isoMk _ _ ((shiftEquiv C (1 : â„¤)).unitIso.app X) (Iso.refl _) (Iso.refl _)\n    (by aesop_cat) (by aesop_cat)\n    (by dsimp; simp only [shift_shiftFunctorCompIsoId_inv_app, id_comp])\n\n"}
{"name":"CategoryTheory.Pretriangulated.complete_distinguished_triangle_morphismâ‚","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninstâœâ´ : CategoryTheory.Category.{v, u} C\ninstâœÂ³ : CategoryTheory.Limits.HasZeroObject C\ninstâœÂ² : CategoryTheory.HasShift C Int\ninstâœÂ¹ : CategoryTheory.Preadditive C\ninstâœ : âˆ€ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nhC : CategoryTheory.Pretriangulated C\nTâ‚ Tâ‚‚ : CategoryTheory.Pretriangulated.Triangle C\nhTâ‚ : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles Tâ‚\nhTâ‚‚ : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles Tâ‚‚\nb : Quiver.Hom Tâ‚.objâ‚‚ Tâ‚‚.objâ‚‚\nc : Quiver.Hom Tâ‚.objâ‚ƒ Tâ‚‚.objâ‚ƒ\ncomm : Eq (CategoryTheory.CategoryStruct.comp Tâ‚.morâ‚‚ c) (CategoryTheory.CategoryStruct.comp b Tâ‚‚.morâ‚‚)\nâŠ¢ Exists fun a => And (Eq (CategoryTheory.CategoryStruct.comp Tâ‚.morâ‚ b) (CategoryTheory.CategoryStruct.comp a Tâ‚‚.morâ‚)) (Eq (CategoryTheory.CategoryStruct.comp Tâ‚.morâ‚ƒ ((CategoryTheory.shiftFunctor C 1).map a)) (CategoryTheory.CategoryStruct.comp c Tâ‚‚.morâ‚ƒ))","decl":"/-- A commutative square involving the morphisms `morâ‚‚` of two distinguished triangles\ncan be extended as morphism of triangles -/\nlemma complete_distinguished_triangle_morphismâ‚ (Tâ‚ Tâ‚‚ : Triangle C)\n    (hTâ‚ : Tâ‚ âˆˆ distTriang C) (hTâ‚‚ : Tâ‚‚ âˆˆ distTriang C) (b : Tâ‚.objâ‚‚ âŸ¶ Tâ‚‚.objâ‚‚)\n    (c : Tâ‚.objâ‚ƒ âŸ¶ Tâ‚‚.objâ‚ƒ) (comm : Tâ‚.morâ‚‚ â‰« c = b â‰« Tâ‚‚.morâ‚‚) :\n    âˆƒ (a : Tâ‚.objâ‚ âŸ¶ Tâ‚‚.objâ‚), Tâ‚.morâ‚ â‰« b = a â‰« Tâ‚‚.morâ‚ âˆ§\n      Tâ‚.morâ‚ƒ â‰« aâŸ¦(1 : â„¤)âŸ§' = c â‰« Tâ‚‚.morâ‚ƒ := by\n  obtain âŸ¨a, âŸ¨haâ‚, haâ‚‚âŸ©âŸ© := complete_distinguished_triangle_morphism _ _\n    (rot_of_distTriang _ hTâ‚) (rot_of_distTriang _ hTâ‚‚) b c comm\n  refine âŸ¨(shiftFunctor C (1 : â„¤)).preimage a, âŸ¨?_, ?_âŸ©âŸ©\n  Â· apply (shiftFunctor C (1 : â„¤)).map_injective\n    dsimp at haâ‚‚\n    rw [neg_comp, comp_neg, neg_inj] at haâ‚‚\n    simpa only [Functor.map_comp, Functor.map_preimage] using haâ‚‚\n  Â· simpa only [Functor.map_preimage] using haâ‚\n\n"}
{"name":"CategoryTheory.Pretriangulated.complete_distinguished_triangle_morphismâ‚‚","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninstâœâ´ : CategoryTheory.Category.{v, u} C\ninstâœÂ³ : CategoryTheory.Limits.HasZeroObject C\ninstâœÂ² : CategoryTheory.HasShift C Int\ninstâœÂ¹ : CategoryTheory.Preadditive C\ninstâœ : âˆ€ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nhC : CategoryTheory.Pretriangulated C\nTâ‚ Tâ‚‚ : CategoryTheory.Pretriangulated.Triangle C\nhTâ‚ : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles Tâ‚\nhTâ‚‚ : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles Tâ‚‚\na : Quiver.Hom Tâ‚.objâ‚ Tâ‚‚.objâ‚\nc : Quiver.Hom Tâ‚.objâ‚ƒ Tâ‚‚.objâ‚ƒ\ncomm : Eq (CategoryTheory.CategoryStruct.comp Tâ‚.morâ‚ƒ ((CategoryTheory.shiftFunctor C 1).map a)) (CategoryTheory.CategoryStruct.comp c Tâ‚‚.morâ‚ƒ)\nâŠ¢ Exists fun b => And (Eq (CategoryTheory.CategoryStruct.comp Tâ‚.morâ‚ b) (CategoryTheory.CategoryStruct.comp a Tâ‚‚.morâ‚)) (Eq (CategoryTheory.CategoryStruct.comp Tâ‚.morâ‚‚ c) (CategoryTheory.CategoryStruct.comp b Tâ‚‚.morâ‚‚))","decl":"/-- A commutative square involving the morphisms `morâ‚ƒ` of two distinguished triangles\ncan be extended as morphism of triangles -/\nlemma complete_distinguished_triangle_morphismâ‚‚ (Tâ‚ Tâ‚‚ : Triangle C)\n    (hTâ‚ : Tâ‚ âˆˆ distTriang C) (hTâ‚‚ : Tâ‚‚ âˆˆ distTriang C) (a : Tâ‚.objâ‚ âŸ¶ Tâ‚‚.objâ‚)\n    (c : Tâ‚.objâ‚ƒ âŸ¶ Tâ‚‚.objâ‚ƒ) (comm : Tâ‚.morâ‚ƒ â‰« aâŸ¦(1 : â„¤)âŸ§' = c â‰« Tâ‚‚.morâ‚ƒ) :\n    âˆƒ (b : Tâ‚.objâ‚‚ âŸ¶ Tâ‚‚.objâ‚‚), Tâ‚.morâ‚ â‰« b = a â‰« Tâ‚‚.morâ‚ âˆ§ Tâ‚.morâ‚‚ â‰« c = b â‰« Tâ‚‚.morâ‚‚ := by\n  obtain âŸ¨a, âŸ¨haâ‚, haâ‚‚âŸ©âŸ© := complete_distinguished_triangle_morphism _ _\n    (inv_rot_of_distTriang _ hTâ‚) (inv_rot_of_distTriang _ hTâ‚‚) (câŸ¦(-1 : â„¤)âŸ§') a (by\n    dsimp\n    simp only [neg_comp, comp_neg, â† Functor.map_comp_assoc, â† comm,\n      Functor.map_comp, shift_shift_neg', Functor.id_obj, assoc, Iso.inv_hom_id_app, comp_id])\n  refine âŸ¨a, âŸ¨haâ‚, ?_âŸ©âŸ©\n  dsimp only [Triangle.invRotate, Triangle.mk] at haâ‚‚\n  rw [â† cancel_mono ((shiftEquiv C (1 : â„¤)).counitIso.inv.app Tâ‚‚.objâ‚ƒ), assoc, assoc, â† haâ‚‚]\n  simp only [shiftEquiv'_counitIso, shift_neg_shift', assoc, Iso.inv_hom_id_app_assoc]\n\n"}
{"name":"CategoryTheory.Pretriangulated.contractible_distinguishedâ‚","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninstâœâ´ : CategoryTheory.Category.{v, u} C\ninstâœÂ³ : CategoryTheory.Limits.HasZeroObject C\ninstâœÂ² : CategoryTheory.HasShift C Int\ninstâœÂ¹ : CategoryTheory.Preadditive C\ninstâœ : âˆ€ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nhC : CategoryTheory.Pretriangulated C\nX : C\nâŠ¢ Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles (CategoryTheory.Pretriangulated.Triangle.mk 0 (CategoryTheory.CategoryStruct.id X) 0)","decl":"/-- Obvious triangles `0 âŸ¶ X âŸ¶ X âŸ¶ 0âŸ¦1âŸ§` are distinguished -/\nlemma contractible_distinguishedâ‚ (X : C) :\n    Triangle.mk (0 : 0 âŸ¶ X) (ğŸ™ X) 0 âˆˆ distTriang C := by\n  refine isomorphic_distinguished _\n    (inv_rot_of_distTriang _ (contractible_distinguished X)) _ ?_\n  exact Triangle.isoMk _ _ (Functor.mapZeroObject _).symm (Iso.refl _) (Iso.refl _)\n    (by simp) (by simp) (by simp)\n\n"}
{"name":"CategoryTheory.Pretriangulated.contractible_distinguishedâ‚‚","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninstâœâ´ : CategoryTheory.Category.{v, u} C\ninstâœÂ³ : CategoryTheory.Limits.HasZeroObject C\ninstâœÂ² : CategoryTheory.HasShift C Int\ninstâœÂ¹ : CategoryTheory.Preadditive C\ninstâœ : âˆ€ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nhC : CategoryTheory.Pretriangulated C\nX : C\nâŠ¢ Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles (CategoryTheory.Pretriangulated.Triangle.mk 0 0 (CategoryTheory.CategoryStruct.id ((CategoryTheory.shiftFunctor C 1).obj X)))","decl":"/-- Obvious triangles `X âŸ¶ 0 âŸ¶ XâŸ¦1âŸ§ âŸ¶ XâŸ¦1âŸ§` are distinguished -/\nlemma contractible_distinguishedâ‚‚ (X : C) :\n    Triangle.mk (0 : X âŸ¶ 0) 0 (ğŸ™ (XâŸ¦1âŸ§)) âˆˆ distTriang C := by\n  refine isomorphic_distinguished _\n    (inv_rot_of_distTriang _ (contractible_distinguishedâ‚ (XâŸ¦(1 : â„¤)âŸ§))) _ ?_\n  exact Triangle.isoMk _ _ ((shiftEquiv C (1 : â„¤)).unitIso.app X) (Iso.refl _) (Iso.refl _)\n    (by simp) (by simp)\n    (by dsimp; simp only [shift_shiftFunctorCompIsoId_inv_app, id_comp])\n\n"}
{"name":"CategoryTheory.Pretriangulated.Triangle.yoneda_exactâ‚‚","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninstâœâ´ : CategoryTheory.Category.{v, u} C\ninstâœÂ³ : CategoryTheory.Limits.HasZeroObject C\ninstâœÂ² : CategoryTheory.HasShift C Int\ninstâœÂ¹ : CategoryTheory.Preadditive C\ninstâœ : âˆ€ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nhC : CategoryTheory.Pretriangulated C\nT : CategoryTheory.Pretriangulated.Triangle C\nhT : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T\nX : C\nf : Quiver.Hom T.objâ‚‚ X\nhf : Eq (CategoryTheory.CategoryStruct.comp T.morâ‚ f) 0\nâŠ¢ Exists fun g => Eq f (CategoryTheory.CategoryStruct.comp T.morâ‚‚ g)","decl":"lemma yoneda_exactâ‚‚ {X : C} (f : T.objâ‚‚ âŸ¶ X) (hf : T.morâ‚ â‰« f = 0) :\n    âˆƒ (g : T.objâ‚ƒ âŸ¶ X), f = T.morâ‚‚ â‰« g := by\n  obtain âŸ¨g, âŸ¨hgâ‚, _âŸ©âŸ© := complete_distinguished_triangle_morphism T _ hT\n    (contractible_distinguishedâ‚ X) 0 f (by aesop_cat)\n  exact âŸ¨g, by simpa using hgâ‚.symmâŸ©\n\n"}
{"name":"CategoryTheory.Pretriangulated.Triangle.yoneda_exactâ‚ƒ","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninstâœâ´ : CategoryTheory.Category.{v, u} C\ninstâœÂ³ : CategoryTheory.Limits.HasZeroObject C\ninstâœÂ² : CategoryTheory.HasShift C Int\ninstâœÂ¹ : CategoryTheory.Preadditive C\ninstâœ : âˆ€ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nhC : CategoryTheory.Pretriangulated C\nT : CategoryTheory.Pretriangulated.Triangle C\nhT : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T\nX : C\nf : Quiver.Hom T.objâ‚ƒ X\nhf : Eq (CategoryTheory.CategoryStruct.comp T.morâ‚‚ f) 0\nâŠ¢ Exists fun g => Eq f (CategoryTheory.CategoryStruct.comp T.morâ‚ƒ g)","decl":"lemma yoneda_exactâ‚ƒ {X : C} (f : T.objâ‚ƒ âŸ¶ X) (hf : T.morâ‚‚ â‰« f = 0) :\n    âˆƒ (g : T.objâ‚âŸ¦(1 : â„¤)âŸ§ âŸ¶ X), f = T.morâ‚ƒ â‰« g :=\n  yoneda_exactâ‚‚ _ (rot_of_distTriang _ hT) f hf\n\n"}
{"name":"CategoryTheory.Pretriangulated.Triangle.coyoneda_exactâ‚‚","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninstâœâ´ : CategoryTheory.Category.{v, u} C\ninstâœÂ³ : CategoryTheory.Limits.HasZeroObject C\ninstâœÂ² : CategoryTheory.HasShift C Int\ninstâœÂ¹ : CategoryTheory.Preadditive C\ninstâœ : âˆ€ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nhC : CategoryTheory.Pretriangulated C\nT : CategoryTheory.Pretriangulated.Triangle C\nhT : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T\nX : C\nf : Quiver.Hom X T.objâ‚‚\nhf : Eq (CategoryTheory.CategoryStruct.comp f T.morâ‚‚) 0\nâŠ¢ Exists fun g => Eq f (CategoryTheory.CategoryStruct.comp g T.morâ‚)","decl":"lemma coyoneda_exactâ‚‚ {X : C} (f : X âŸ¶ T.objâ‚‚) (hf : f â‰« T.morâ‚‚ = 0) :\n    âˆƒ (g : X âŸ¶ T.objâ‚), f = g â‰« T.morâ‚ := by\n  obtain âŸ¨a, âŸ¨haâ‚, _âŸ©âŸ© := complete_distinguished_triangle_morphismâ‚ _ T\n    (contractible_distinguished X) hT f 0 (by aesop_cat)\n  exact âŸ¨a, by simpa using haâ‚âŸ©\n\n"}
{"name":"CategoryTheory.Pretriangulated.Triangle.coyoneda_exactâ‚","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninstâœâ´ : CategoryTheory.Category.{v, u} C\ninstâœÂ³ : CategoryTheory.Limits.HasZeroObject C\ninstâœÂ² : CategoryTheory.HasShift C Int\ninstâœÂ¹ : CategoryTheory.Preadditive C\ninstâœ : âˆ€ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nhC : CategoryTheory.Pretriangulated C\nT : CategoryTheory.Pretriangulated.Triangle C\nhT : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T\nX : C\nf : Quiver.Hom X ((CategoryTheory.shiftFunctor C 1).obj T.objâ‚)\nhf : Eq (CategoryTheory.CategoryStruct.comp f ((CategoryTheory.shiftFunctor C 1).map T.morâ‚)) 0\nâŠ¢ Exists fun g => Eq f (CategoryTheory.CategoryStruct.comp g T.morâ‚ƒ)","decl":"lemma coyoneda_exactâ‚ {X : C} (f : X âŸ¶ T.objâ‚âŸ¦(1 : â„¤)âŸ§) (hf : f â‰« T.morâ‚âŸ¦1âŸ§' = 0) :\n    âˆƒ (g : X âŸ¶ T.objâ‚ƒ), f = g â‰« T.morâ‚ƒ :=\n  coyoneda_exactâ‚‚ _ (rot_of_distTriang _ (rot_of_distTriang _ hT)) f (by aesop_cat)\n\n"}
{"name":"CategoryTheory.Pretriangulated.Triangle.coyoneda_exactâ‚ƒ","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninstâœâ´ : CategoryTheory.Category.{v, u} C\ninstâœÂ³ : CategoryTheory.Limits.HasZeroObject C\ninstâœÂ² : CategoryTheory.HasShift C Int\ninstâœÂ¹ : CategoryTheory.Preadditive C\ninstâœ : âˆ€ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nhC : CategoryTheory.Pretriangulated C\nT : CategoryTheory.Pretriangulated.Triangle C\nhT : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T\nX : C\nf : Quiver.Hom X T.objâ‚ƒ\nhf : Eq (CategoryTheory.CategoryStruct.comp f T.morâ‚ƒ) 0\nâŠ¢ Exists fun g => Eq f (CategoryTheory.CategoryStruct.comp g T.morâ‚‚)","decl":"lemma coyoneda_exactâ‚ƒ {X : C} (f : X âŸ¶ T.objâ‚ƒ) (hf : f â‰« T.morâ‚ƒ = 0) :\n    âˆƒ (g : X âŸ¶ T.objâ‚‚), f = g â‰« T.morâ‚‚ :=\n  coyoneda_exactâ‚‚ _ (rot_of_distTriang _ hT) f hf\n\n"}
{"name":"CategoryTheory.Pretriangulated.Triangle.morâ‚ƒ_eq_zero_iff_epiâ‚‚","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninstâœâ´ : CategoryTheory.Category.{v, u} C\ninstâœÂ³ : CategoryTheory.Limits.HasZeroObject C\ninstâœÂ² : CategoryTheory.HasShift C Int\ninstâœÂ¹ : CategoryTheory.Preadditive C\ninstâœ : âˆ€ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nhC : CategoryTheory.Pretriangulated C\nT : CategoryTheory.Pretriangulated.Triangle C\nhT : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T\nâŠ¢ Iff (Eq T.morâ‚ƒ 0) (CategoryTheory.Epi T.morâ‚‚)","decl":"lemma morâ‚ƒ_eq_zero_iff_epiâ‚‚ : T.morâ‚ƒ = 0 â†” Epi T.morâ‚‚ := by\n  constructor\n  Â· intro h\n    rw [epi_iff_cancel_zero]\n    intro X g hg\n    obtain âŸ¨f, rflâŸ© := yoneda_exactâ‚ƒ T hT g hg\n    rw [h, zero_comp]\n  Â· intro\n    rw [â† cancel_epi T.morâ‚‚, comp_distTriang_mor_zeroâ‚‚â‚ƒ _ hT, comp_zero]\n\n"}
{"name":"CategoryTheory.Pretriangulated.Triangle.morâ‚‚_eq_zero_iff_epiâ‚","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninstâœâ´ : CategoryTheory.Category.{v, u} C\ninstâœÂ³ : CategoryTheory.Limits.HasZeroObject C\ninstâœÂ² : CategoryTheory.HasShift C Int\ninstâœÂ¹ : CategoryTheory.Preadditive C\ninstâœ : âˆ€ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nhC : CategoryTheory.Pretriangulated C\nT : CategoryTheory.Pretriangulated.Triangle C\nhT : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T\nâŠ¢ Iff (Eq T.morâ‚‚ 0) (CategoryTheory.Epi T.morâ‚)","decl":"lemma morâ‚‚_eq_zero_iff_epiâ‚ : T.morâ‚‚ = 0 â†” Epi T.morâ‚ := by\n  have h := morâ‚ƒ_eq_zero_iff_epiâ‚‚ _ (inv_rot_of_distTriang _ hT)\n  dsimp at h\n  rw [â† h, IsIso.comp_right_eq_zero]\n\n"}
{"name":"CategoryTheory.Pretriangulated.Triangle.morâ‚_eq_zero_iff_epiâ‚ƒ","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninstâœâ´ : CategoryTheory.Category.{v, u} C\ninstâœÂ³ : CategoryTheory.Limits.HasZeroObject C\ninstâœÂ² : CategoryTheory.HasShift C Int\ninstâœÂ¹ : CategoryTheory.Preadditive C\ninstâœ : âˆ€ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nhC : CategoryTheory.Pretriangulated C\nT : CategoryTheory.Pretriangulated.Triangle C\nhT : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T\nâŠ¢ Iff (Eq T.morâ‚ 0) (CategoryTheory.Epi T.morâ‚ƒ)","decl":"lemma morâ‚_eq_zero_iff_epiâ‚ƒ : T.morâ‚ = 0 â†” Epi T.morâ‚ƒ := by\n  have h := morâ‚ƒ_eq_zero_iff_epiâ‚‚ _ (rot_of_distTriang _ hT)\n  dsimp at h\n  rw [â† h, neg_eq_zero]\n  constructor\n  Â· intro h\n    simp only [h, Functor.map_zero]\n  Â· intro h\n    rw [â† (CategoryTheory.shiftFunctor C (1 : â„¤)).map_eq_zero_iff, h]\n\n"}
{"name":"CategoryTheory.Pretriangulated.Triangle.morâ‚ƒ_eq_zero_of_epiâ‚‚","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninstâœâ´ : CategoryTheory.Category.{v, u} C\ninstâœÂ³ : CategoryTheory.Limits.HasZeroObject C\ninstâœÂ² : CategoryTheory.HasShift C Int\ninstâœÂ¹ : CategoryTheory.Preadditive C\ninstâœ : âˆ€ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nhC : CategoryTheory.Pretriangulated C\nT : CategoryTheory.Pretriangulated.Triangle C\nhT : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T\nh : CategoryTheory.Epi T.morâ‚‚\nâŠ¢ Eq T.morâ‚ƒ 0","decl":"lemma morâ‚ƒ_eq_zero_of_epiâ‚‚ (h : Epi T.morâ‚‚) : T.morâ‚ƒ = 0 := (T.morâ‚ƒ_eq_zero_iff_epiâ‚‚ hT).2 h\n"}
{"name":"CategoryTheory.Pretriangulated.Triangle.morâ‚‚_eq_zero_of_epiâ‚","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninstâœâ´ : CategoryTheory.Category.{v, u} C\ninstâœÂ³ : CategoryTheory.Limits.HasZeroObject C\ninstâœÂ² : CategoryTheory.HasShift C Int\ninstâœÂ¹ : CategoryTheory.Preadditive C\ninstâœ : âˆ€ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nhC : CategoryTheory.Pretriangulated C\nT : CategoryTheory.Pretriangulated.Triangle C\nhT : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T\nh : CategoryTheory.Epi T.morâ‚\nâŠ¢ Eq T.morâ‚‚ 0","decl":"lemma morâ‚‚_eq_zero_of_epiâ‚ (h : Epi T.morâ‚) : T.morâ‚‚ = 0 := (T.morâ‚‚_eq_zero_iff_epiâ‚ hT).2 h\n"}
{"name":"CategoryTheory.Pretriangulated.Triangle.morâ‚_eq_zero_of_epiâ‚ƒ","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninstâœâ´ : CategoryTheory.Category.{v, u} C\ninstâœÂ³ : CategoryTheory.Limits.HasZeroObject C\ninstâœÂ² : CategoryTheory.HasShift C Int\ninstâœÂ¹ : CategoryTheory.Preadditive C\ninstâœ : âˆ€ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nhC : CategoryTheory.Pretriangulated C\nT : CategoryTheory.Pretriangulated.Triangle C\nhT : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T\nh : CategoryTheory.Epi T.morâ‚ƒ\nâŠ¢ Eq T.morâ‚ 0","decl":"lemma morâ‚_eq_zero_of_epiâ‚ƒ (h : Epi T.morâ‚ƒ) : T.morâ‚ = 0 := (T.morâ‚_eq_zero_iff_epiâ‚ƒ hT).2 h\n\n"}
{"name":"CategoryTheory.Pretriangulated.Triangle.epiâ‚‚","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninstâœâ´ : CategoryTheory.Category.{v, u} C\ninstâœÂ³ : CategoryTheory.Limits.HasZeroObject C\ninstâœÂ² : CategoryTheory.HasShift C Int\ninstâœÂ¹ : CategoryTheory.Preadditive C\ninstâœ : âˆ€ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nhC : CategoryTheory.Pretriangulated C\nT : CategoryTheory.Pretriangulated.Triangle C\nhT : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T\nh : Eq T.morâ‚ƒ 0\nâŠ¢ CategoryTheory.Epi T.morâ‚‚","decl":"lemma epiâ‚‚ (h : T.morâ‚ƒ = 0) : Epi T.morâ‚‚ := (T.morâ‚ƒ_eq_zero_iff_epiâ‚‚ hT).1 h\n"}
{"name":"CategoryTheory.Pretriangulated.Triangle.epiâ‚","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninstâœâ´ : CategoryTheory.Category.{v, u} C\ninstâœÂ³ : CategoryTheory.Limits.HasZeroObject C\ninstâœÂ² : CategoryTheory.HasShift C Int\ninstâœÂ¹ : CategoryTheory.Preadditive C\ninstâœ : âˆ€ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nhC : CategoryTheory.Pretriangulated C\nT : CategoryTheory.Pretriangulated.Triangle C\nhT : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T\nh : Eq T.morâ‚‚ 0\nâŠ¢ CategoryTheory.Epi T.morâ‚","decl":"lemma epiâ‚ (h : T.morâ‚‚ = 0) : Epi T.morâ‚ := (T.morâ‚‚_eq_zero_iff_epiâ‚ hT).1 h\n"}
{"name":"CategoryTheory.Pretriangulated.Triangle.epiâ‚ƒ","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninstâœâ´ : CategoryTheory.Category.{v, u} C\ninstâœÂ³ : CategoryTheory.Limits.HasZeroObject C\ninstâœÂ² : CategoryTheory.HasShift C Int\ninstâœÂ¹ : CategoryTheory.Preadditive C\ninstâœ : âˆ€ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nhC : CategoryTheory.Pretriangulated C\nT : CategoryTheory.Pretriangulated.Triangle C\nhT : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T\nh : Eq T.morâ‚ 0\nâŠ¢ CategoryTheory.Epi T.morâ‚ƒ","decl":"lemma epiâ‚ƒ (h : T.morâ‚ = 0) : Epi T.morâ‚ƒ := (T.morâ‚_eq_zero_iff_epiâ‚ƒ hT).1 h\n\n"}
{"name":"CategoryTheory.Pretriangulated.Triangle.morâ‚_eq_zero_iff_monoâ‚‚","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninstâœâ´ : CategoryTheory.Category.{v, u} C\ninstâœÂ³ : CategoryTheory.Limits.HasZeroObject C\ninstâœÂ² : CategoryTheory.HasShift C Int\ninstâœÂ¹ : CategoryTheory.Preadditive C\ninstâœ : âˆ€ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nhC : CategoryTheory.Pretriangulated C\nT : CategoryTheory.Pretriangulated.Triangle C\nhT : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T\nâŠ¢ Iff (Eq T.morâ‚ 0) (CategoryTheory.Mono T.morâ‚‚)","decl":"lemma morâ‚_eq_zero_iff_monoâ‚‚ : T.morâ‚ = 0 â†” Mono T.morâ‚‚ := by\n  constructor\n  Â· intro h\n    rw [mono_iff_cancel_zero]\n    intro X g hg\n    obtain âŸ¨f, rflâŸ© := coyoneda_exactâ‚‚ T hT g hg\n    rw [h, comp_zero]\n  Â· intro\n    rw [â† cancel_mono T.morâ‚‚, comp_distTriang_mor_zeroâ‚â‚‚ _ hT, zero_comp]\n\n"}
{"name":"CategoryTheory.Pretriangulated.Triangle.morâ‚‚_eq_zero_iff_monoâ‚ƒ","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninstâœâ´ : CategoryTheory.Category.{v, u} C\ninstâœÂ³ : CategoryTheory.Limits.HasZeroObject C\ninstâœÂ² : CategoryTheory.HasShift C Int\ninstâœÂ¹ : CategoryTheory.Preadditive C\ninstâœ : âˆ€ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nhC : CategoryTheory.Pretriangulated C\nT : CategoryTheory.Pretriangulated.Triangle C\nhT : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T\nâŠ¢ Iff (Eq T.morâ‚‚ 0) (CategoryTheory.Mono T.morâ‚ƒ)","decl":"lemma morâ‚‚_eq_zero_iff_monoâ‚ƒ : T.morâ‚‚ = 0 â†” Mono T.morâ‚ƒ :=\n  morâ‚_eq_zero_iff_monoâ‚‚ _ (rot_of_distTriang _ hT)\n\n"}
{"name":"CategoryTheory.Pretriangulated.Triangle.morâ‚ƒ_eq_zero_iff_monoâ‚","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninstâœâ´ : CategoryTheory.Category.{v, u} C\ninstâœÂ³ : CategoryTheory.Limits.HasZeroObject C\ninstâœÂ² : CategoryTheory.HasShift C Int\ninstâœÂ¹ : CategoryTheory.Preadditive C\ninstâœ : âˆ€ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nhC : CategoryTheory.Pretriangulated C\nT : CategoryTheory.Pretriangulated.Triangle C\nhT : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T\nâŠ¢ Iff (Eq T.morâ‚ƒ 0) (CategoryTheory.Mono T.morâ‚)","decl":"lemma morâ‚ƒ_eq_zero_iff_monoâ‚ : T.morâ‚ƒ = 0 â†” Mono T.morâ‚ := by\n  have h := morâ‚_eq_zero_iff_monoâ‚‚ _ (inv_rot_of_distTriang _ hT)\n  dsimp at h\n  rw [â† h, neg_eq_zero, IsIso.comp_right_eq_zero]\n  constructor\n  Â· intro h\n    simp only [h, Functor.map_zero]\n  Â· intro h\n    rw [â† (CategoryTheory.shiftFunctor C (-1 : â„¤)).map_eq_zero_iff, h]\n\n"}
{"name":"CategoryTheory.Pretriangulated.Triangle.morâ‚_eq_zero_of_monoâ‚‚","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninstâœâ´ : CategoryTheory.Category.{v, u} C\ninstâœÂ³ : CategoryTheory.Limits.HasZeroObject C\ninstâœÂ² : CategoryTheory.HasShift C Int\ninstâœÂ¹ : CategoryTheory.Preadditive C\ninstâœ : âˆ€ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nhC : CategoryTheory.Pretriangulated C\nT : CategoryTheory.Pretriangulated.Triangle C\nhT : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T\nh : CategoryTheory.Mono T.morâ‚‚\nâŠ¢ Eq T.morâ‚ 0","decl":"lemma morâ‚_eq_zero_of_monoâ‚‚ (h : Mono T.morâ‚‚) : T.morâ‚ = 0 := (T.morâ‚_eq_zero_iff_monoâ‚‚ hT).2 h\n"}
{"name":"CategoryTheory.Pretriangulated.Triangle.morâ‚‚_eq_zero_of_monoâ‚ƒ","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninstâœâ´ : CategoryTheory.Category.{v, u} C\ninstâœÂ³ : CategoryTheory.Limits.HasZeroObject C\ninstâœÂ² : CategoryTheory.HasShift C Int\ninstâœÂ¹ : CategoryTheory.Preadditive C\ninstâœ : âˆ€ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nhC : CategoryTheory.Pretriangulated C\nT : CategoryTheory.Pretriangulated.Triangle C\nhT : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T\nh : CategoryTheory.Mono T.morâ‚ƒ\nâŠ¢ Eq T.morâ‚‚ 0","decl":"lemma morâ‚‚_eq_zero_of_monoâ‚ƒ (h : Mono T.morâ‚ƒ) : T.morâ‚‚ = 0 := (T.morâ‚‚_eq_zero_iff_monoâ‚ƒ hT).2 h\n"}
{"name":"CategoryTheory.Pretriangulated.Triangle.morâ‚ƒ_eq_zero_of_monoâ‚","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninstâœâ´ : CategoryTheory.Category.{v, u} C\ninstâœÂ³ : CategoryTheory.Limits.HasZeroObject C\ninstâœÂ² : CategoryTheory.HasShift C Int\ninstâœÂ¹ : CategoryTheory.Preadditive C\ninstâœ : âˆ€ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nhC : CategoryTheory.Pretriangulated C\nT : CategoryTheory.Pretriangulated.Triangle C\nhT : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T\nh : CategoryTheory.Mono T.morâ‚\nâŠ¢ Eq T.morâ‚ƒ 0","decl":"lemma morâ‚ƒ_eq_zero_of_monoâ‚ (h : Mono T.morâ‚) : T.morâ‚ƒ = 0 := (T.morâ‚ƒ_eq_zero_iff_monoâ‚ hT).2 h\n\n"}
{"name":"CategoryTheory.Pretriangulated.Triangle.monoâ‚‚","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninstâœâ´ : CategoryTheory.Category.{v, u} C\ninstâœÂ³ : CategoryTheory.Limits.HasZeroObject C\ninstâœÂ² : CategoryTheory.HasShift C Int\ninstâœÂ¹ : CategoryTheory.Preadditive C\ninstâœ : âˆ€ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nhC : CategoryTheory.Pretriangulated C\nT : CategoryTheory.Pretriangulated.Triangle C\nhT : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T\nh : Eq T.morâ‚ 0\nâŠ¢ CategoryTheory.Mono T.morâ‚‚","decl":"lemma monoâ‚‚ (h : T.morâ‚ = 0) : Mono T.morâ‚‚ := (T.morâ‚_eq_zero_iff_monoâ‚‚ hT).1 h\n"}
{"name":"CategoryTheory.Pretriangulated.Triangle.monoâ‚ƒ","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninstâœâ´ : CategoryTheory.Category.{v, u} C\ninstâœÂ³ : CategoryTheory.Limits.HasZeroObject C\ninstâœÂ² : CategoryTheory.HasShift C Int\ninstâœÂ¹ : CategoryTheory.Preadditive C\ninstâœ : âˆ€ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nhC : CategoryTheory.Pretriangulated C\nT : CategoryTheory.Pretriangulated.Triangle C\nhT : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T\nh : Eq T.morâ‚‚ 0\nâŠ¢ CategoryTheory.Mono T.morâ‚ƒ","decl":"lemma monoâ‚ƒ (h : T.morâ‚‚ = 0) : Mono T.morâ‚ƒ := (T.morâ‚‚_eq_zero_iff_monoâ‚ƒ hT).1 h\n"}
{"name":"CategoryTheory.Pretriangulated.Triangle.monoâ‚","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninstâœâ´ : CategoryTheory.Category.{v, u} C\ninstâœÂ³ : CategoryTheory.Limits.HasZeroObject C\ninstâœÂ² : CategoryTheory.HasShift C Int\ninstâœÂ¹ : CategoryTheory.Preadditive C\ninstâœ : âˆ€ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nhC : CategoryTheory.Pretriangulated C\nT : CategoryTheory.Pretriangulated.Triangle C\nhT : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T\nh : Eq T.morâ‚ƒ 0\nâŠ¢ CategoryTheory.Mono T.morâ‚","decl":"lemma monoâ‚ (h : T.morâ‚ƒ = 0) : Mono T.morâ‚ := (T.morâ‚ƒ_eq_zero_iff_monoâ‚ hT).1 h\n\n"}
{"name":"CategoryTheory.Pretriangulated.Triangle.isZeroâ‚‚_iff","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninstâœâ´ : CategoryTheory.Category.{v, u} C\ninstâœÂ³ : CategoryTheory.Limits.HasZeroObject C\ninstâœÂ² : CategoryTheory.HasShift C Int\ninstâœÂ¹ : CategoryTheory.Preadditive C\ninstâœ : âˆ€ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nhC : CategoryTheory.Pretriangulated C\nT : CategoryTheory.Pretriangulated.Triangle C\nhT : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T\nâŠ¢ Iff (CategoryTheory.Limits.IsZero T.objâ‚‚) (And (Eq T.morâ‚ 0) (Eq T.morâ‚‚ 0))","decl":"lemma isZeroâ‚‚_iff : IsZero T.objâ‚‚ â†” (T.morâ‚ = 0 âˆ§ T.morâ‚‚ = 0) := by\n  constructor\n  Â· intro h\n    exact âŸ¨h.eq_of_tgt _ _, h.eq_of_src _ _âŸ©\n  Â· intro âŸ¨hâ‚, hâ‚‚âŸ©\n    obtain âŸ¨f, hfâŸ© := coyoneda_exactâ‚‚ T hT (ğŸ™ _) (by rw [hâ‚‚, comp_zero])\n    rw [IsZero.iff_id_eq_zero, hf, hâ‚, comp_zero]\n\n"}
{"name":"CategoryTheory.Pretriangulated.Triangle.isZeroâ‚_iff","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninstâœâ´ : CategoryTheory.Category.{v, u} C\ninstâœÂ³ : CategoryTheory.Limits.HasZeroObject C\ninstâœÂ² : CategoryTheory.HasShift C Int\ninstâœÂ¹ : CategoryTheory.Preadditive C\ninstâœ : âˆ€ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nhC : CategoryTheory.Pretriangulated C\nT : CategoryTheory.Pretriangulated.Triangle C\nhT : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T\nâŠ¢ Iff (CategoryTheory.Limits.IsZero T.objâ‚) (And (Eq T.morâ‚ 0) (Eq T.morâ‚ƒ 0))","decl":"lemma isZeroâ‚_iff : IsZero T.objâ‚ â†” (T.morâ‚ = 0 âˆ§ T.morâ‚ƒ = 0) := by\n  refine (isZeroâ‚‚_iff _ (inv_rot_of_distTriang _ hT)).trans ?_\n  dsimp\n  simp only [neg_eq_zero, IsIso.comp_right_eq_zero, Functor.map_eq_zero_iff]\n  tauto\n\n"}
{"name":"CategoryTheory.Pretriangulated.Triangle.isZeroâ‚ƒ_iff","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninstâœâ´ : CategoryTheory.Category.{v, u} C\ninstâœÂ³ : CategoryTheory.Limits.HasZeroObject C\ninstâœÂ² : CategoryTheory.HasShift C Int\ninstâœÂ¹ : CategoryTheory.Preadditive C\ninstâœ : âˆ€ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nhC : CategoryTheory.Pretriangulated C\nT : CategoryTheory.Pretriangulated.Triangle C\nhT : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T\nâŠ¢ Iff (CategoryTheory.Limits.IsZero T.objâ‚ƒ) (And (Eq T.morâ‚‚ 0) (Eq T.morâ‚ƒ 0))","decl":"lemma isZeroâ‚ƒ_iff : IsZero T.objâ‚ƒ â†” (T.morâ‚‚ = 0 âˆ§ T.morâ‚ƒ = 0) := by\n  refine (isZeroâ‚‚_iff _ (rot_of_distTriang _ hT)).trans ?_\n  dsimp\n  tauto\n\n"}
{"name":"CategoryTheory.Pretriangulated.Triangle.isZeroâ‚_of_isZeroâ‚‚â‚ƒ","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninstâœâ´ : CategoryTheory.Category.{v, u} C\ninstâœÂ³ : CategoryTheory.Limits.HasZeroObject C\ninstâœÂ² : CategoryTheory.HasShift C Int\ninstâœÂ¹ : CategoryTheory.Preadditive C\ninstâœ : âˆ€ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nhC : CategoryTheory.Pretriangulated C\nT : CategoryTheory.Pretriangulated.Triangle C\nhT : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T\nhâ‚‚ : CategoryTheory.Limits.IsZero T.objâ‚‚\nhâ‚ƒ : CategoryTheory.Limits.IsZero T.objâ‚ƒ\nâŠ¢ CategoryTheory.Limits.IsZero T.objâ‚","decl":"lemma isZeroâ‚_of_isZeroâ‚‚â‚ƒ (hâ‚‚ : IsZero T.objâ‚‚) (hâ‚ƒ : IsZero T.objâ‚ƒ) : IsZero T.objâ‚ := by\n  rw [T.isZeroâ‚_iff hT]\n  exact âŸ¨hâ‚‚.eq_of_tgt _ _, hâ‚ƒ.eq_of_src _ _âŸ©\n\n"}
{"name":"CategoryTheory.Pretriangulated.Triangle.isZeroâ‚‚_of_isZeroâ‚â‚ƒ","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninstâœâ´ : CategoryTheory.Category.{v, u} C\ninstâœÂ³ : CategoryTheory.Limits.HasZeroObject C\ninstâœÂ² : CategoryTheory.HasShift C Int\ninstâœÂ¹ : CategoryTheory.Preadditive C\ninstâœ : âˆ€ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nhC : CategoryTheory.Pretriangulated C\nT : CategoryTheory.Pretriangulated.Triangle C\nhT : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T\nhâ‚ : CategoryTheory.Limits.IsZero T.objâ‚\nhâ‚ƒ : CategoryTheory.Limits.IsZero T.objâ‚ƒ\nâŠ¢ CategoryTheory.Limits.IsZero T.objâ‚‚","decl":"lemma isZeroâ‚‚_of_isZeroâ‚â‚ƒ (hâ‚ : IsZero T.objâ‚) (hâ‚ƒ : IsZero T.objâ‚ƒ) : IsZero T.objâ‚‚ := by\n  rw [T.isZeroâ‚‚_iff hT]\n  exact âŸ¨hâ‚.eq_of_src _ _, hâ‚ƒ.eq_of_tgt _ _âŸ©\n\n"}
{"name":"CategoryTheory.Pretriangulated.Triangle.isZeroâ‚ƒ_of_isZeroâ‚â‚‚","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninstâœâ´ : CategoryTheory.Category.{v, u} C\ninstâœÂ³ : CategoryTheory.Limits.HasZeroObject C\ninstâœÂ² : CategoryTheory.HasShift C Int\ninstâœÂ¹ : CategoryTheory.Preadditive C\ninstâœ : âˆ€ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nhC : CategoryTheory.Pretriangulated C\nT : CategoryTheory.Pretriangulated.Triangle C\nhT : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T\nhâ‚ : CategoryTheory.Limits.IsZero T.objâ‚\nhâ‚‚ : CategoryTheory.Limits.IsZero T.objâ‚‚\nâŠ¢ CategoryTheory.Limits.IsZero T.objâ‚ƒ","decl":"lemma isZeroâ‚ƒ_of_isZeroâ‚â‚‚ (hâ‚ : IsZero T.objâ‚) (hâ‚‚ : IsZero T.objâ‚‚) : IsZero T.objâ‚ƒ :=\n  isZeroâ‚‚_of_isZeroâ‚â‚ƒ _ (rot_of_distTriang _ hT) hâ‚‚ (by\n    dsimp\n    simp only [IsZero.iff_id_eq_zero] at hâ‚ âŠ¢\n    rw [â† Functor.map_id, hâ‚, Functor.map_zero])\n\n"}
{"name":"CategoryTheory.Pretriangulated.Triangle.isZeroâ‚_iff_isIsoâ‚‚","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninstâœâ´ : CategoryTheory.Category.{v, u} C\ninstâœÂ³ : CategoryTheory.Limits.HasZeroObject C\ninstâœÂ² : CategoryTheory.HasShift C Int\ninstâœÂ¹ : CategoryTheory.Preadditive C\ninstâœ : âˆ€ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nhC : CategoryTheory.Pretriangulated C\nT : CategoryTheory.Pretriangulated.Triangle C\nhT : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T\nâŠ¢ Iff (CategoryTheory.Limits.IsZero T.objâ‚) (CategoryTheory.IsIso T.morâ‚‚)","decl":"lemma isZeroâ‚_iff_isIsoâ‚‚ :\n    IsZero T.objâ‚ â†” IsIso T.morâ‚‚ := by\n  rw [T.isZeroâ‚_iff hT]\n  constructor\n  Â· intro âŸ¨hâ‚, hâ‚ƒâŸ©\n    have := T.epiâ‚‚ hT hâ‚ƒ\n    obtain âŸ¨f, hfâŸ© := yoneda_exactâ‚‚ T hT (ğŸ™ _) (by rw [hâ‚, zero_comp])\n    exact âŸ¨f, hf.symm, by rw [â† cancel_epi T.morâ‚‚, comp_id, â† reassoc_of% hf]âŸ©\n  Â· intro\n    rw [T.morâ‚_eq_zero_iff_monoâ‚‚ hT, T.morâ‚ƒ_eq_zero_iff_epiâ‚‚ hT]\n    constructor <;> infer_instance\n\n"}
{"name":"CategoryTheory.Pretriangulated.Triangle.isZeroâ‚‚_iff_isIsoâ‚ƒ","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninstâœâ´ : CategoryTheory.Category.{v, u} C\ninstâœÂ³ : CategoryTheory.Limits.HasZeroObject C\ninstâœÂ² : CategoryTheory.HasShift C Int\ninstâœÂ¹ : CategoryTheory.Preadditive C\ninstâœ : âˆ€ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nhC : CategoryTheory.Pretriangulated C\nT : CategoryTheory.Pretriangulated.Triangle C\nhT : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T\nâŠ¢ Iff (CategoryTheory.Limits.IsZero T.objâ‚‚) (CategoryTheory.IsIso T.morâ‚ƒ)","decl":"lemma isZeroâ‚‚_iff_isIsoâ‚ƒ : IsZero T.objâ‚‚ â†” IsIso T.morâ‚ƒ :=\n  isZeroâ‚_iff_isIsoâ‚‚ _ (rot_of_distTriang _ hT)\n\n"}
{"name":"CategoryTheory.Pretriangulated.Triangle.isZeroâ‚ƒ_iff_isIsoâ‚","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninstâœâ´ : CategoryTheory.Category.{v, u} C\ninstâœÂ³ : CategoryTheory.Limits.HasZeroObject C\ninstâœÂ² : CategoryTheory.HasShift C Int\ninstâœÂ¹ : CategoryTheory.Preadditive C\ninstâœ : âˆ€ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nhC : CategoryTheory.Pretriangulated C\nT : CategoryTheory.Pretriangulated.Triangle C\nhT : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T\nâŠ¢ Iff (CategoryTheory.Limits.IsZero T.objâ‚ƒ) (CategoryTheory.IsIso T.morâ‚)","decl":"lemma isZeroâ‚ƒ_iff_isIsoâ‚ : IsZero T.objâ‚ƒ â†” IsIso T.morâ‚ := by\n  refine Iff.trans ?_ (Triangle.isZeroâ‚_iff_isIsoâ‚‚ _ (inv_rot_of_distTriang _ hT))\n  dsimp\n  simp only [IsZero.iff_id_eq_zero, â† Functor.map_id, Functor.map_eq_zero_iff]\n\n"}
{"name":"CategoryTheory.Pretriangulated.Triangle.isZeroâ‚_of_isIsoâ‚‚","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninstâœâ´ : CategoryTheory.Category.{v, u} C\ninstâœÂ³ : CategoryTheory.Limits.HasZeroObject C\ninstâœÂ² : CategoryTheory.HasShift C Int\ninstâœÂ¹ : CategoryTheory.Preadditive C\ninstâœ : âˆ€ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nhC : CategoryTheory.Pretriangulated C\nT : CategoryTheory.Pretriangulated.Triangle C\nhT : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T\nh : CategoryTheory.IsIso T.morâ‚‚\nâŠ¢ CategoryTheory.Limits.IsZero T.objâ‚","decl":"lemma isZeroâ‚_of_isIsoâ‚‚ (h : IsIso T.morâ‚‚) : IsZero T.objâ‚ := (T.isZeroâ‚_iff_isIsoâ‚‚ hT).2 h\n"}
{"name":"CategoryTheory.Pretriangulated.Triangle.isZeroâ‚‚_of_isIsoâ‚ƒ","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninstâœâ´ : CategoryTheory.Category.{v, u} C\ninstâœÂ³ : CategoryTheory.Limits.HasZeroObject C\ninstâœÂ² : CategoryTheory.HasShift C Int\ninstâœÂ¹ : CategoryTheory.Preadditive C\ninstâœ : âˆ€ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nhC : CategoryTheory.Pretriangulated C\nT : CategoryTheory.Pretriangulated.Triangle C\nhT : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T\nh : CategoryTheory.IsIso T.morâ‚ƒ\nâŠ¢ CategoryTheory.Limits.IsZero T.objâ‚‚","decl":"lemma isZeroâ‚‚_of_isIsoâ‚ƒ (h : IsIso T.morâ‚ƒ) : IsZero T.objâ‚‚ := (T.isZeroâ‚‚_iff_isIsoâ‚ƒ hT).2 h\n"}
{"name":"CategoryTheory.Pretriangulated.Triangle.isZeroâ‚ƒ_of_isIsoâ‚","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninstâœâ´ : CategoryTheory.Category.{v, u} C\ninstâœÂ³ : CategoryTheory.Limits.HasZeroObject C\ninstâœÂ² : CategoryTheory.HasShift C Int\ninstâœÂ¹ : CategoryTheory.Preadditive C\ninstâœ : âˆ€ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nhC : CategoryTheory.Pretriangulated C\nT : CategoryTheory.Pretriangulated.Triangle C\nhT : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T\nh : CategoryTheory.IsIso T.morâ‚\nâŠ¢ CategoryTheory.Limits.IsZero T.objâ‚ƒ","decl":"lemma isZeroâ‚ƒ_of_isIsoâ‚ (h : IsIso T.morâ‚) : IsZero T.objâ‚ƒ := (T.isZeroâ‚ƒ_iff_isIsoâ‚ hT).2 h\n\n"}
{"name":"CategoryTheory.Pretriangulated.Triangle.shift_distinguished","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninstâœâ´ : CategoryTheory.Category.{v, u} C\ninstâœÂ³ : CategoryTheory.Limits.HasZeroObject C\ninstâœÂ² : CategoryTheory.HasShift C Int\ninstâœÂ¹ : CategoryTheory.Preadditive C\ninstâœ : âˆ€ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nhC : CategoryTheory.Pretriangulated C\nT : CategoryTheory.Pretriangulated.Triangle C\nhT : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T\nn : Int\nâŠ¢ Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles ((CategoryTheory.shiftFunctor (CategoryTheory.Pretriangulated.Triangle C) n).obj T)","decl":"lemma shift_distinguished (n : â„¤) :\n    (CategoryTheory.shiftFunctor (Triangle C) n).obj T âˆˆ distTriang C := by\n  revert T hT\n  let H : â„¤ â†’ Prop := fun n => âˆ€ (T : Triangle C) (_ : T âˆˆ distTriang C),\n    (Triangle.shiftFunctor C n).obj T âˆˆ distTriang C\n  change H n\n  have H_zero : H 0 := fun T hT =>\n    isomorphic_distinguished _ hT _ ((Triangle.shiftFunctorZero C).app T)\n  have H_one : H 1 := fun T hT =>\n    isomorphic_distinguished _ (rot_of_distTriang _\n      (rot_of_distTriang _ (rot_of_distTriang _ hT))) _\n        ((rotateRotateRotateIso C).symm.app T)\n  have H_neg_one : H (-1) := fun T hT =>\n    isomorphic_distinguished _ (inv_rot_of_distTriang _\n      (inv_rot_of_distTriang _ (inv_rot_of_distTriang _ hT))) _\n        ((invRotateInvRotateInvRotateIso C).symm.app T)\n  have H_add : âˆ€ {a b c : â„¤}, H a â†’ H b â†’ a + b = c â†’ H c := fun {a b c} ha hb hc T hT =>\n    isomorphic_distinguished _ (hb _ (ha _ hT)) _\n      ((Triangle.shiftFunctorAdd' C _ _ _ hc).app T)\n  obtain (n|n) := n\n  Â· induction n with\n    | zero =>  exact H_zero\n    | succ n hn => exact H_add hn H_one rfl\n  Â· induction n with\n    | zero => exact H_neg_one\n    | succ n hn => exact H_add hn H_neg_one rfl\n\n"}
{"name":"CategoryTheory.Pretriangulated.instSplitEpiCategory","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninstâœ : CategoryTheory.Category.{v, u} C\nâŠ¢ CategoryTheory.SplitEpiCategory C","decl":"instance : SplitEpiCategory C where\n  isSplitEpi_of_epi f hf := by\n    obtain âŸ¨Z, g, h, hTâŸ© := distinguished_cocone_triangle f\n    obtain âŸ¨r, hrâŸ© := Triangle.coyoneda_exactâ‚‚ _ hT (ğŸ™ _)\n      (by rw [Triangle.morâ‚‚_eq_zero_of_epiâ‚ _ hT hf, comp_zero])\n    exact âŸ¨r, hr.symmâŸ©\n\n"}
{"name":"CategoryTheory.Pretriangulated.instSplitMonoCategory","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninstâœ : CategoryTheory.Category.{v, u} C\nâŠ¢ CategoryTheory.SplitMonoCategory C","decl":"instance : SplitMonoCategory C where\n  isSplitMono_of_mono f hf := by\n    obtain âŸ¨X, g, h, hTâŸ© := distinguished_cocone_triangleâ‚ f\n    obtain âŸ¨r, hrâŸ© := Triangle.yoneda_exactâ‚‚ _ hT (ğŸ™ _) (by\n      rw [Triangle.morâ‚_eq_zero_of_monoâ‚‚ _ hT hf, zero_comp])\n    exact âŸ¨r, hr.symmâŸ©\n\n"}
{"name":"CategoryTheory.Pretriangulated.isIsoâ‚‚_of_isIsoâ‚â‚ƒ","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninstâœâ´ : CategoryTheory.Category.{v, u} C\ninstâœÂ³ : CategoryTheory.Limits.HasZeroObject C\ninstâœÂ² : CategoryTheory.HasShift C Int\ninstâœÂ¹ : CategoryTheory.Preadditive C\ninstâœ : âˆ€ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nhC : CategoryTheory.Pretriangulated C\nT T' : CategoryTheory.Pretriangulated.Triangle C\nÏ† : Quiver.Hom T T'\nhT : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T\nhT' : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T'\nhâ‚ : CategoryTheory.IsIso Ï†.homâ‚\nhâ‚ƒ : CategoryTheory.IsIso Ï†.homâ‚ƒ\nâŠ¢ CategoryTheory.IsIso Ï†.homâ‚‚","decl":"lemma isIsoâ‚‚_of_isIsoâ‚â‚ƒ {T T' : Triangle C} (Ï† : T âŸ¶ T') (hT : T âˆˆ distTriang C)\n    (hT' : T' âˆˆ distTriang C) (hâ‚ : IsIso Ï†.homâ‚) (hâ‚ƒ : IsIso Ï†.homâ‚ƒ) : IsIso Ï†.homâ‚‚ := by\n  have : Mono Ï†.homâ‚‚ := by\n    rw [mono_iff_cancel_zero]\n    intro A f hf\n    obtain âŸ¨g, rflâŸ© := Triangle.coyoneda_exactâ‚‚ _ hT f\n      (by rw [â† cancel_mono Ï†.homâ‚ƒ, assoc, Ï†.commâ‚‚, reassoc_of% hf, zero_comp, zero_comp])\n    rw [assoc] at hf\n    obtain âŸ¨h, hhâŸ© := Triangle.coyoneda_exactâ‚‚ T'.invRotate (inv_rot_of_distTriang _ hT')\n      (g â‰« Ï†.homâ‚) (by dsimp; rw [assoc, â† Ï†.commâ‚, hf])\n    obtain âŸ¨k, rflâŸ© : âˆƒ (k : A âŸ¶ T.invRotate.objâ‚), k â‰« T.invRotate.morâ‚ = g := by\n      refine âŸ¨h â‰« inv (Ï†.homâ‚ƒâŸ¦(-1 : â„¤)âŸ§'), ?_âŸ©\n      have eq := ((invRotate C).map Ï†).commâ‚\n      dsimp only [invRotate] at eq\n      rw [â† cancel_mono Ï†.homâ‚, assoc, assoc, eq, IsIso.inv_hom_id_assoc, hh]\n    erw [assoc, comp_distTriang_mor_zeroâ‚â‚‚ _ (inv_rot_of_distTriang _ hT), comp_zero]\n  refine isIso_of_yoneda_map_bijective _ (fun A => âŸ¨?_, ?_âŸ©)\n  Â· intro fâ‚ fâ‚‚ h\n    simpa only [â† cancel_mono Ï†.homâ‚‚] using h\n  Â· intro yâ‚‚\n    obtain âŸ¨xâ‚ƒ, hxâ‚ƒâŸ© : âˆƒ (xâ‚ƒ : A âŸ¶ T.objâ‚ƒ), xâ‚ƒ â‰« Ï†.homâ‚ƒ = yâ‚‚ â‰« T'.morâ‚‚ :=\n      âŸ¨yâ‚‚ â‰« T'.morâ‚‚ â‰« inv Ï†.homâ‚ƒ, by simpâŸ©\n    obtain âŸ¨xâ‚‚, hxâ‚‚âŸ© := Triangle.coyoneda_exactâ‚ƒ _ hT xâ‚ƒ\n      (by rw [â† cancel_mono (Ï†.homâ‚âŸ¦(1 : â„¤)âŸ§'), assoc, zero_comp, Ï†.commâ‚ƒ, reassoc_of% hxâ‚ƒ,\n        comp_distTriang_mor_zeroâ‚‚â‚ƒ _ hT', comp_zero])\n    obtain âŸ¨yâ‚, hyâ‚âŸ© := Triangle.coyoneda_exactâ‚‚ _ hT' (yâ‚‚ - xâ‚‚ â‰« Ï†.homâ‚‚)\n      (by rw [sub_comp, assoc, â† Ï†.commâ‚‚, â† reassoc_of% hxâ‚‚, hxâ‚ƒ, sub_self])\n    obtain âŸ¨xâ‚, hxâ‚âŸ© : âˆƒ (xâ‚ : A âŸ¶ T.objâ‚), xâ‚ â‰« Ï†.homâ‚ = yâ‚ := âŸ¨yâ‚ â‰« inv Ï†.homâ‚, by simpâŸ©\n    refine âŸ¨xâ‚‚ + xâ‚ â‰« T.morâ‚, ?_âŸ©\n    dsimp\n    rw [add_comp, assoc, Ï†.commâ‚, reassoc_of% hxâ‚, â† hyâ‚, add_sub_cancel]\n\n"}
{"name":"CategoryTheory.Pretriangulated.isIsoâ‚ƒ_of_isIsoâ‚â‚‚","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninstâœâ´ : CategoryTheory.Category.{v, u} C\ninstâœÂ³ : CategoryTheory.Limits.HasZeroObject C\ninstâœÂ² : CategoryTheory.HasShift C Int\ninstâœÂ¹ : CategoryTheory.Preadditive C\ninstâœ : âˆ€ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nhC : CategoryTheory.Pretriangulated C\nT T' : CategoryTheory.Pretriangulated.Triangle C\nÏ† : Quiver.Hom T T'\nhT : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T\nhT' : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T'\nhâ‚ : CategoryTheory.IsIso Ï†.homâ‚\nhâ‚‚ : CategoryTheory.IsIso Ï†.homâ‚‚\nâŠ¢ CategoryTheory.IsIso Ï†.homâ‚ƒ","decl":"lemma isIsoâ‚ƒ_of_isIsoâ‚â‚‚ {T T' : Triangle C} (Ï† : T âŸ¶ T') (hT : T âˆˆ distTriang C)\n    (hT' : T' âˆˆ distTriang C) (hâ‚ : IsIso Ï†.homâ‚) (hâ‚‚ : IsIso Ï†.homâ‚‚) : IsIso Ï†.homâ‚ƒ :=\n  isIsoâ‚‚_of_isIsoâ‚â‚ƒ ((rotate C).map Ï†) (rot_of_distTriang _ hT)\n    (rot_of_distTriang _ hT') hâ‚‚ (by dsimp; infer_instance)\n\n"}
{"name":"CategoryTheory.Pretriangulated.isIsoâ‚_of_isIsoâ‚‚â‚ƒ","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninstâœâ´ : CategoryTheory.Category.{v, u} C\ninstâœÂ³ : CategoryTheory.Limits.HasZeroObject C\ninstâœÂ² : CategoryTheory.HasShift C Int\ninstâœÂ¹ : CategoryTheory.Preadditive C\ninstâœ : âˆ€ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nhC : CategoryTheory.Pretriangulated C\nT T' : CategoryTheory.Pretriangulated.Triangle C\nÏ† : Quiver.Hom T T'\nhT : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T\nhT' : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T'\nhâ‚‚ : CategoryTheory.IsIso Ï†.homâ‚‚\nhâ‚ƒ : CategoryTheory.IsIso Ï†.homâ‚ƒ\nâŠ¢ CategoryTheory.IsIso Ï†.homâ‚","decl":"lemma isIsoâ‚_of_isIsoâ‚‚â‚ƒ {T T' : Triangle C} (Ï† : T âŸ¶ T') (hT : T âˆˆ distTriang C)\n    (hT' : T' âˆˆ distTriang C) (hâ‚‚ : IsIso Ï†.homâ‚‚) (hâ‚ƒ : IsIso Ï†.homâ‚ƒ) : IsIso Ï†.homâ‚ :=\n  isIsoâ‚‚_of_isIsoâ‚â‚ƒ ((invRotate C).map Ï†) (inv_rot_of_distTriang _ hT)\n    (inv_rot_of_distTriang _ hT') (by dsimp; infer_instance) (by dsimp; infer_instance)\n\n"}
{"name":"CategoryTheory.Pretriangulated.binaryBiproductData_isBilimit","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninstâœâ´ : CategoryTheory.Category.{v, u} C\ninstâœÂ³ : CategoryTheory.Limits.HasZeroObject C\ninstâœÂ² : CategoryTheory.HasShift C Int\ninstâœÂ¹ : CategoryTheory.Preadditive C\ninstâœ : âˆ€ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nhC : CategoryTheory.Pretriangulated C\nT : CategoryTheory.Pretriangulated.Triangle C\nhT : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T\nhTâ‚€ : Eq T.morâ‚ƒ 0\ninr : Quiver.Hom T.objâ‚ƒ T.objâ‚‚\ninr_snd : Eq (CategoryTheory.CategoryStruct.comp inr T.morâ‚‚) (CategoryTheory.CategoryStruct.id T.objâ‚ƒ)\nfst : Quiver.Hom T.objâ‚‚ T.objâ‚\ntotal : Eq (HAdd.hAdd (CategoryTheory.CategoryStruct.comp fst T.morâ‚) (CategoryTheory.CategoryStruct.comp T.morâ‚‚ inr)) (CategoryTheory.CategoryStruct.id T.objâ‚‚)\nâŠ¢ Eq (CategoryTheory.Pretriangulated.binaryBiproductData T hT hTâ‚€ inr inr_snd fst total).isBilimit (CategoryTheory.Limits.isBinaryBilimitOfTotal { pt := T.objâ‚‚, fst := fst, snd := T.morâ‚‚, inl := T.morâ‚, inr := inr, inl_fst := â‹¯, inl_snd := â‹¯, inr_fst := â‹¯, inr_snd := inr_snd } total)","decl":"/-- Given a distinguished triangle `T` such that `T.morâ‚ƒ = 0` and the datum of morphisms\n`inr : T.objâ‚ƒ âŸ¶ T.objâ‚‚` and `fst : T.objâ‚‚ âŸ¶ T.objâ‚` satisfying suitable relations, this\nis the binary biproduct data expressing that `T.objâ‚‚` identifies to the binary\nbiproduct of `T.objâ‚` and `T.objâ‚ƒ`.\nSee also `exists_iso_binaryBiproduct_of_distTriang`. -/\n@[simps]\ndef binaryBiproductData (T : Triangle C) (hT : T âˆˆ distTriang C) (hTâ‚€ : T.morâ‚ƒ = 0)\n    (inr : T.objâ‚ƒ âŸ¶ T.objâ‚‚) (inr_snd : inr â‰« T.morâ‚‚ = ğŸ™ _) (fst : T.objâ‚‚ âŸ¶ T.objâ‚)\n    (total : fst â‰« T.morâ‚ + T.morâ‚‚ â‰« inr = ğŸ™ T.objâ‚‚) :\n    BinaryBiproductData T.objâ‚ T.objâ‚ƒ := by\n  have : Mono T.morâ‚ := T.monoâ‚ hT hTâ‚€\n  have eq : fst â‰« T.morâ‚ = ğŸ™ T.objâ‚‚ - T.morâ‚‚ â‰« inr := by rw [â† total, add_sub_cancel_right]\n  exact\n    { bicone :=\n      { pt := T.objâ‚‚\n        fst := fst\n        snd := T.morâ‚‚\n        inl := T.morâ‚\n        inr := inr\n        inl_fst := by\n          simp only [â† cancel_mono T.morâ‚, assoc, id_comp, eq, comp_sub, comp_id,\n            comp_distTriang_mor_zeroâ‚â‚‚_assoc _ hT, zero_comp, sub_zero]\n        inl_snd := comp_distTriang_mor_zeroâ‚â‚‚ _ hT\n        inr_fst := by\n          simp only [â† cancel_mono T.morâ‚, assoc, eq, comp_sub, reassoc_of% inr_snd,\n            comp_id, sub_self, zero_comp]\n        inr_snd := inr_snd }\n      isBilimit := isBinaryBilimitOfTotal _ total }\n\n"}
{"name":"CategoryTheory.Pretriangulated.binaryBiproductData_bicone_inr","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninstâœâ´ : CategoryTheory.Category.{v, u} C\ninstâœÂ³ : CategoryTheory.Limits.HasZeroObject C\ninstâœÂ² : CategoryTheory.HasShift C Int\ninstâœÂ¹ : CategoryTheory.Preadditive C\ninstâœ : âˆ€ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nhC : CategoryTheory.Pretriangulated C\nT : CategoryTheory.Pretriangulated.Triangle C\nhT : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T\nhTâ‚€ : Eq T.morâ‚ƒ 0\ninr : Quiver.Hom T.objâ‚ƒ T.objâ‚‚\ninr_snd : Eq (CategoryTheory.CategoryStruct.comp inr T.morâ‚‚) (CategoryTheory.CategoryStruct.id T.objâ‚ƒ)\nfst : Quiver.Hom T.objâ‚‚ T.objâ‚\ntotal : Eq (HAdd.hAdd (CategoryTheory.CategoryStruct.comp fst T.morâ‚) (CategoryTheory.CategoryStruct.comp T.morâ‚‚ inr)) (CategoryTheory.CategoryStruct.id T.objâ‚‚)\nâŠ¢ Eq (CategoryTheory.Pretriangulated.binaryBiproductData T hT hTâ‚€ inr inr_snd fst total).bicone.inr inr","decl":"/-- Given a distinguished triangle `T` such that `T.morâ‚ƒ = 0` and the datum of morphisms\n`inr : T.objâ‚ƒ âŸ¶ T.objâ‚‚` and `fst : T.objâ‚‚ âŸ¶ T.objâ‚` satisfying suitable relations, this\nis the binary biproduct data expressing that `T.objâ‚‚` identifies to the binary\nbiproduct of `T.objâ‚` and `T.objâ‚ƒ`.\nSee also `exists_iso_binaryBiproduct_of_distTriang`. -/\n@[simps]\ndef binaryBiproductData (T : Triangle C) (hT : T âˆˆ distTriang C) (hTâ‚€ : T.morâ‚ƒ = 0)\n    (inr : T.objâ‚ƒ âŸ¶ T.objâ‚‚) (inr_snd : inr â‰« T.morâ‚‚ = ğŸ™ _) (fst : T.objâ‚‚ âŸ¶ T.objâ‚)\n    (total : fst â‰« T.morâ‚ + T.morâ‚‚ â‰« inr = ğŸ™ T.objâ‚‚) :\n    BinaryBiproductData T.objâ‚ T.objâ‚ƒ := by\n  have : Mono T.morâ‚ := T.monoâ‚ hT hTâ‚€\n  have eq : fst â‰« T.morâ‚ = ğŸ™ T.objâ‚‚ - T.morâ‚‚ â‰« inr := by rw [â† total, add_sub_cancel_right]\n  exact\n    { bicone :=\n      { pt := T.objâ‚‚\n        fst := fst\n        snd := T.morâ‚‚\n        inl := T.morâ‚\n        inr := inr\n        inl_fst := by\n          simp only [â† cancel_mono T.morâ‚, assoc, id_comp, eq, comp_sub, comp_id,\n            comp_distTriang_mor_zeroâ‚â‚‚_assoc _ hT, zero_comp, sub_zero]\n        inl_snd := comp_distTriang_mor_zeroâ‚â‚‚ _ hT\n        inr_fst := by\n          simp only [â† cancel_mono T.morâ‚, assoc, eq, comp_sub, reassoc_of% inr_snd,\n            comp_id, sub_self, zero_comp]\n        inr_snd := inr_snd }\n      isBilimit := isBinaryBilimitOfTotal _ total }\n\n"}
{"name":"CategoryTheory.Pretriangulated.binaryBiproductData_bicone_fst","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninstâœâ´ : CategoryTheory.Category.{v, u} C\ninstâœÂ³ : CategoryTheory.Limits.HasZeroObject C\ninstâœÂ² : CategoryTheory.HasShift C Int\ninstâœÂ¹ : CategoryTheory.Preadditive C\ninstâœ : âˆ€ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nhC : CategoryTheory.Pretriangulated C\nT : CategoryTheory.Pretriangulated.Triangle C\nhT : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T\nhTâ‚€ : Eq T.morâ‚ƒ 0\ninr : Quiver.Hom T.objâ‚ƒ T.objâ‚‚\ninr_snd : Eq (CategoryTheory.CategoryStruct.comp inr T.morâ‚‚) (CategoryTheory.CategoryStruct.id T.objâ‚ƒ)\nfst : Quiver.Hom T.objâ‚‚ T.objâ‚\ntotal : Eq (HAdd.hAdd (CategoryTheory.CategoryStruct.comp fst T.morâ‚) (CategoryTheory.CategoryStruct.comp T.morâ‚‚ inr)) (CategoryTheory.CategoryStruct.id T.objâ‚‚)\nâŠ¢ Eq (CategoryTheory.Pretriangulated.binaryBiproductData T hT hTâ‚€ inr inr_snd fst total).bicone.fst fst","decl":"/-- Given a distinguished triangle `T` such that `T.morâ‚ƒ = 0` and the datum of morphisms\n`inr : T.objâ‚ƒ âŸ¶ T.objâ‚‚` and `fst : T.objâ‚‚ âŸ¶ T.objâ‚` satisfying suitable relations, this\nis the binary biproduct data expressing that `T.objâ‚‚` identifies to the binary\nbiproduct of `T.objâ‚` and `T.objâ‚ƒ`.\nSee also `exists_iso_binaryBiproduct_of_distTriang`. -/\n@[simps]\ndef binaryBiproductData (T : Triangle C) (hT : T âˆˆ distTriang C) (hTâ‚€ : T.morâ‚ƒ = 0)\n    (inr : T.objâ‚ƒ âŸ¶ T.objâ‚‚) (inr_snd : inr â‰« T.morâ‚‚ = ğŸ™ _) (fst : T.objâ‚‚ âŸ¶ T.objâ‚)\n    (total : fst â‰« T.morâ‚ + T.morâ‚‚ â‰« inr = ğŸ™ T.objâ‚‚) :\n    BinaryBiproductData T.objâ‚ T.objâ‚ƒ := by\n  have : Mono T.morâ‚ := T.monoâ‚ hT hTâ‚€\n  have eq : fst â‰« T.morâ‚ = ğŸ™ T.objâ‚‚ - T.morâ‚‚ â‰« inr := by rw [â† total, add_sub_cancel_right]\n  exact\n    { bicone :=\n      { pt := T.objâ‚‚\n        fst := fst\n        snd := T.morâ‚‚\n        inl := T.morâ‚\n        inr := inr\n        inl_fst := by\n          simp only [â† cancel_mono T.morâ‚, assoc, id_comp, eq, comp_sub, comp_id,\n            comp_distTriang_mor_zeroâ‚â‚‚_assoc _ hT, zero_comp, sub_zero]\n        inl_snd := comp_distTriang_mor_zeroâ‚â‚‚ _ hT\n        inr_fst := by\n          simp only [â† cancel_mono T.morâ‚, assoc, eq, comp_sub, reassoc_of% inr_snd,\n            comp_id, sub_self, zero_comp]\n        inr_snd := inr_snd }\n      isBilimit := isBinaryBilimitOfTotal _ total }\n\n"}
{"name":"CategoryTheory.Pretriangulated.binaryBiproductData_bicone_inl","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninstâœâ´ : CategoryTheory.Category.{v, u} C\ninstâœÂ³ : CategoryTheory.Limits.HasZeroObject C\ninstâœÂ² : CategoryTheory.HasShift C Int\ninstâœÂ¹ : CategoryTheory.Preadditive C\ninstâœ : âˆ€ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nhC : CategoryTheory.Pretriangulated C\nT : CategoryTheory.Pretriangulated.Triangle C\nhT : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T\nhTâ‚€ : Eq T.morâ‚ƒ 0\ninr : Quiver.Hom T.objâ‚ƒ T.objâ‚‚\ninr_snd : Eq (CategoryTheory.CategoryStruct.comp inr T.morâ‚‚) (CategoryTheory.CategoryStruct.id T.objâ‚ƒ)\nfst : Quiver.Hom T.objâ‚‚ T.objâ‚\ntotal : Eq (HAdd.hAdd (CategoryTheory.CategoryStruct.comp fst T.morâ‚) (CategoryTheory.CategoryStruct.comp T.morâ‚‚ inr)) (CategoryTheory.CategoryStruct.id T.objâ‚‚)\nâŠ¢ Eq (CategoryTheory.Pretriangulated.binaryBiproductData T hT hTâ‚€ inr inr_snd fst total).bicone.inl T.morâ‚","decl":"/-- Given a distinguished triangle `T` such that `T.morâ‚ƒ = 0` and the datum of morphisms\n`inr : T.objâ‚ƒ âŸ¶ T.objâ‚‚` and `fst : T.objâ‚‚ âŸ¶ T.objâ‚` satisfying suitable relations, this\nis the binary biproduct data expressing that `T.objâ‚‚` identifies to the binary\nbiproduct of `T.objâ‚` and `T.objâ‚ƒ`.\nSee also `exists_iso_binaryBiproduct_of_distTriang`. -/\n@[simps]\ndef binaryBiproductData (T : Triangle C) (hT : T âˆˆ distTriang C) (hTâ‚€ : T.morâ‚ƒ = 0)\n    (inr : T.objâ‚ƒ âŸ¶ T.objâ‚‚) (inr_snd : inr â‰« T.morâ‚‚ = ğŸ™ _) (fst : T.objâ‚‚ âŸ¶ T.objâ‚)\n    (total : fst â‰« T.morâ‚ + T.morâ‚‚ â‰« inr = ğŸ™ T.objâ‚‚) :\n    BinaryBiproductData T.objâ‚ T.objâ‚ƒ := by\n  have : Mono T.morâ‚ := T.monoâ‚ hT hTâ‚€\n  have eq : fst â‰« T.morâ‚ = ğŸ™ T.objâ‚‚ - T.morâ‚‚ â‰« inr := by rw [â† total, add_sub_cancel_right]\n  exact\n    { bicone :=\n      { pt := T.objâ‚‚\n        fst := fst\n        snd := T.morâ‚‚\n        inl := T.morâ‚\n        inr := inr\n        inl_fst := by\n          simp only [â† cancel_mono T.morâ‚, assoc, id_comp, eq, comp_sub, comp_id,\n            comp_distTriang_mor_zeroâ‚â‚‚_assoc _ hT, zero_comp, sub_zero]\n        inl_snd := comp_distTriang_mor_zeroâ‚â‚‚ _ hT\n        inr_fst := by\n          simp only [â† cancel_mono T.morâ‚, assoc, eq, comp_sub, reassoc_of% inr_snd,\n            comp_id, sub_self, zero_comp]\n        inr_snd := inr_snd }\n      isBilimit := isBinaryBilimitOfTotal _ total }\n\n"}
{"name":"CategoryTheory.Pretriangulated.binaryBiproductData_bicone_snd","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninstâœâ´ : CategoryTheory.Category.{v, u} C\ninstâœÂ³ : CategoryTheory.Limits.HasZeroObject C\ninstâœÂ² : CategoryTheory.HasShift C Int\ninstâœÂ¹ : CategoryTheory.Preadditive C\ninstâœ : âˆ€ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nhC : CategoryTheory.Pretriangulated C\nT : CategoryTheory.Pretriangulated.Triangle C\nhT : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T\nhTâ‚€ : Eq T.morâ‚ƒ 0\ninr : Quiver.Hom T.objâ‚ƒ T.objâ‚‚\ninr_snd : Eq (CategoryTheory.CategoryStruct.comp inr T.morâ‚‚) (CategoryTheory.CategoryStruct.id T.objâ‚ƒ)\nfst : Quiver.Hom T.objâ‚‚ T.objâ‚\ntotal : Eq (HAdd.hAdd (CategoryTheory.CategoryStruct.comp fst T.morâ‚) (CategoryTheory.CategoryStruct.comp T.morâ‚‚ inr)) (CategoryTheory.CategoryStruct.id T.objâ‚‚)\nâŠ¢ Eq (CategoryTheory.Pretriangulated.binaryBiproductData T hT hTâ‚€ inr inr_snd fst total).bicone.snd T.morâ‚‚","decl":"/-- Given a distinguished triangle `T` such that `T.morâ‚ƒ = 0` and the datum of morphisms\n`inr : T.objâ‚ƒ âŸ¶ T.objâ‚‚` and `fst : T.objâ‚‚ âŸ¶ T.objâ‚` satisfying suitable relations, this\nis the binary biproduct data expressing that `T.objâ‚‚` identifies to the binary\nbiproduct of `T.objâ‚` and `T.objâ‚ƒ`.\nSee also `exists_iso_binaryBiproduct_of_distTriang`. -/\n@[simps]\ndef binaryBiproductData (T : Triangle C) (hT : T âˆˆ distTriang C) (hTâ‚€ : T.morâ‚ƒ = 0)\n    (inr : T.objâ‚ƒ âŸ¶ T.objâ‚‚) (inr_snd : inr â‰« T.morâ‚‚ = ğŸ™ _) (fst : T.objâ‚‚ âŸ¶ T.objâ‚)\n    (total : fst â‰« T.morâ‚ + T.morâ‚‚ â‰« inr = ğŸ™ T.objâ‚‚) :\n    BinaryBiproductData T.objâ‚ T.objâ‚ƒ := by\n  have : Mono T.morâ‚ := T.monoâ‚ hT hTâ‚€\n  have eq : fst â‰« T.morâ‚ = ğŸ™ T.objâ‚‚ - T.morâ‚‚ â‰« inr := by rw [â† total, add_sub_cancel_right]\n  exact\n    { bicone :=\n      { pt := T.objâ‚‚\n        fst := fst\n        snd := T.morâ‚‚\n        inl := T.morâ‚\n        inr := inr\n        inl_fst := by\n          simp only [â† cancel_mono T.morâ‚, assoc, id_comp, eq, comp_sub, comp_id,\n            comp_distTriang_mor_zeroâ‚â‚‚_assoc _ hT, zero_comp, sub_zero]\n        inl_snd := comp_distTriang_mor_zeroâ‚â‚‚ _ hT\n        inr_fst := by\n          simp only [â† cancel_mono T.morâ‚, assoc, eq, comp_sub, reassoc_of% inr_snd,\n            comp_id, sub_self, zero_comp]\n        inr_snd := inr_snd }\n      isBilimit := isBinaryBilimitOfTotal _ total }\n\n"}
{"name":"CategoryTheory.Pretriangulated.binaryBiproductData_bicone_pt","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninstâœâ´ : CategoryTheory.Category.{v, u} C\ninstâœÂ³ : CategoryTheory.Limits.HasZeroObject C\ninstâœÂ² : CategoryTheory.HasShift C Int\ninstâœÂ¹ : CategoryTheory.Preadditive C\ninstâœ : âˆ€ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nhC : CategoryTheory.Pretriangulated C\nT : CategoryTheory.Pretriangulated.Triangle C\nhT : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T\nhTâ‚€ : Eq T.morâ‚ƒ 0\ninr : Quiver.Hom T.objâ‚ƒ T.objâ‚‚\ninr_snd : Eq (CategoryTheory.CategoryStruct.comp inr T.morâ‚‚) (CategoryTheory.CategoryStruct.id T.objâ‚ƒ)\nfst : Quiver.Hom T.objâ‚‚ T.objâ‚\ntotal : Eq (HAdd.hAdd (CategoryTheory.CategoryStruct.comp fst T.morâ‚) (CategoryTheory.CategoryStruct.comp T.morâ‚‚ inr)) (CategoryTheory.CategoryStruct.id T.objâ‚‚)\nâŠ¢ Eq (CategoryTheory.Pretriangulated.binaryBiproductData T hT hTâ‚€ inr inr_snd fst total).bicone.pt T.objâ‚‚","decl":"/-- Given a distinguished triangle `T` such that `T.morâ‚ƒ = 0` and the datum of morphisms\n`inr : T.objâ‚ƒ âŸ¶ T.objâ‚‚` and `fst : T.objâ‚‚ âŸ¶ T.objâ‚` satisfying suitable relations, this\nis the binary biproduct data expressing that `T.objâ‚‚` identifies to the binary\nbiproduct of `T.objâ‚` and `T.objâ‚ƒ`.\nSee also `exists_iso_binaryBiproduct_of_distTriang`. -/\n@[simps]\ndef binaryBiproductData (T : Triangle C) (hT : T âˆˆ distTriang C) (hTâ‚€ : T.morâ‚ƒ = 0)\n    (inr : T.objâ‚ƒ âŸ¶ T.objâ‚‚) (inr_snd : inr â‰« T.morâ‚‚ = ğŸ™ _) (fst : T.objâ‚‚ âŸ¶ T.objâ‚)\n    (total : fst â‰« T.morâ‚ + T.morâ‚‚ â‰« inr = ğŸ™ T.objâ‚‚) :\n    BinaryBiproductData T.objâ‚ T.objâ‚ƒ := by\n  have : Mono T.morâ‚ := T.monoâ‚ hT hTâ‚€\n  have eq : fst â‰« T.morâ‚ = ğŸ™ T.objâ‚‚ - T.morâ‚‚ â‰« inr := by rw [â† total, add_sub_cancel_right]\n  exact\n    { bicone :=\n      { pt := T.objâ‚‚\n        fst := fst\n        snd := T.morâ‚‚\n        inl := T.morâ‚\n        inr := inr\n        inl_fst := by\n          simp only [â† cancel_mono T.morâ‚, assoc, id_comp, eq, comp_sub, comp_id,\n            comp_distTriang_mor_zeroâ‚â‚‚_assoc _ hT, zero_comp, sub_zero]\n        inl_snd := comp_distTriang_mor_zeroâ‚â‚‚ _ hT\n        inr_fst := by\n          simp only [â† cancel_mono T.morâ‚, assoc, eq, comp_sub, reassoc_of% inr_snd,\n            comp_id, sub_self, zero_comp]\n        inr_snd := inr_snd }\n      isBilimit := isBinaryBilimitOfTotal _ total }\n\n"}
{"name":"CategoryTheory.Pretriangulated.instHasBinaryBiproducts","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.Preadditive C\nâŠ¢ CategoryTheory.Limits.HasBinaryBiproducts C","decl":"instance : HasBinaryBiproducts C := âŸ¨fun Xâ‚ Xâ‚ƒ => by\n  obtain âŸ¨Xâ‚‚, inl, snd, memâŸ© := distinguished_cocone_triangleâ‚‚ (0 : Xâ‚ƒ âŸ¶ Xâ‚âŸ¦(1 : â„¤)âŸ§)\n  obtain âŸ¨inr : Xâ‚ƒ âŸ¶ Xâ‚‚, inr_snd : ğŸ™ _ = inr â‰« sndâŸ© :=\n    Triangle.coyoneda_exactâ‚ƒ _ mem (ğŸ™ Xâ‚ƒ) (by simp)\n  obtain âŸ¨fst : Xâ‚‚ âŸ¶ Xâ‚, hfst : ğŸ™ Xâ‚‚ - snd â‰« inr = fst â‰« inlâŸ© :=\n    Triangle.coyoneda_exactâ‚‚ _ mem (ğŸ™ Xâ‚‚ - snd â‰« inr) (by\n      dsimp\n      simp only [sub_comp, assoc, id_comp, â† inr_snd, comp_id, sub_self])\n  refine âŸ¨âŸ¨binaryBiproductData _ mem rfl inr inr_snd.symm fst ?_âŸ©âŸ©\n  dsimp\n  simp only [â† hfst, sub_add_cancel]âŸ©\n\n"}
{"name":"CategoryTheory.Pretriangulated.instHasFiniteProducts","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroObject C\ninstâœ : CategoryTheory.Preadditive C\nâŠ¢ CategoryTheory.Limits.HasFiniteProducts C","decl":"instance : HasFiniteProducts C := hasFiniteProducts_of_has_binary_and_terminal\n"}
{"name":"CategoryTheory.Pretriangulated.instHasFiniteCoproducts","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroObject C\ninstâœ : CategoryTheory.Preadditive C\nâŠ¢ CategoryTheory.Limits.HasFiniteCoproducts C","decl":"instance : HasFiniteCoproducts C := hasFiniteCoproducts_of_has_binary_and_initial\n"}
{"name":"CategoryTheory.Pretriangulated.instHasFiniteBiproducts","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroObject C\ninstâœ : CategoryTheory.Preadditive C\nâŠ¢ CategoryTheory.Limits.HasFiniteBiproducts C","decl":"instance : HasFiniteBiproducts C := HasFiniteBiproducts.of_hasFiniteProducts\n\n"}
{"name":"CategoryTheory.Pretriangulated.exists_iso_binaryBiproduct_of_distTriang","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninstâœâ´ : CategoryTheory.Category.{v, u} C\ninstâœÂ³ : CategoryTheory.Limits.HasZeroObject C\ninstâœÂ² : CategoryTheory.HasShift C Int\ninstâœÂ¹ : CategoryTheory.Preadditive C\ninstâœ : âˆ€ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nhC : CategoryTheory.Pretriangulated C\nT : CategoryTheory.Pretriangulated.Triangle C\nhT : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T\nzero : Eq T.morâ‚ƒ 0\nâŠ¢ Exists fun e => And (Eq (CategoryTheory.CategoryStruct.comp T.morâ‚ e.hom) CategoryTheory.Limits.biprod.inl) (Eq T.morâ‚‚ (CategoryTheory.CategoryStruct.comp e.hom CategoryTheory.Limits.biprod.snd))","decl":"lemma exists_iso_binaryBiproduct_of_distTriang (T : Triangle C) (hT : T âˆˆ distTriang C)\n    (zero : T.morâ‚ƒ = 0) :\n    âˆƒ (e : T.objâ‚‚ â‰… T.objâ‚ âŠ T.objâ‚ƒ), T.morâ‚ â‰« e.hom = biprod.inl âˆ§\n      T.morâ‚‚ = e.hom â‰« biprod.snd := by\n  have := T.epiâ‚‚ hT zero\n  have := isSplitEpi_of_epi T.morâ‚‚\n  obtain âŸ¨fst, hfstâŸ© := T.coyoneda_exactâ‚‚ hT (ğŸ™ T.objâ‚‚ - T.morâ‚‚ â‰« section_ T.morâ‚‚) (by simp)\n  let d := binaryBiproductData _ hT zero (section_ T.morâ‚‚) (by simp) fst\n    (by simp only [â† hfst, sub_add_cancel])\n  refine âŸ¨biprod.uniqueUpToIso _ _ d.isBilimit, âŸ¨?_, by simp [d]âŸ©âŸ©\n  ext\n  Â· simpa [d] using d.bicone.inl_fst\n  Â· simpa [d] using d.bicone.inl_snd\n\n"}
{"name":"CategoryTheory.Pretriangulated.binaryBiproductTriangle_distinguished","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninstâœâ´ : CategoryTheory.Category.{v, u} C\ninstâœÂ³ : CategoryTheory.Limits.HasZeroObject C\ninstâœÂ² : CategoryTheory.HasShift C Int\ninstâœÂ¹ : CategoryTheory.Preadditive C\ninstâœ : âˆ€ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nhC : CategoryTheory.Pretriangulated C\nXâ‚ Xâ‚‚ : C\nâŠ¢ Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles (CategoryTheory.Pretriangulated.binaryBiproductTriangle Xâ‚ Xâ‚‚)","decl":"lemma binaryBiproductTriangle_distinguished (Xâ‚ Xâ‚‚ : C) :\n    binaryBiproductTriangle Xâ‚ Xâ‚‚ âˆˆ distTriang C := by\n  obtain âŸ¨Y, g, h, memâŸ© := distinguished_cocone_triangleâ‚‚ (0 : Xâ‚‚ âŸ¶ Xâ‚âŸ¦(1 : â„¤)âŸ§)\n  obtain âŸ¨e, âŸ¨heâ‚, heâ‚‚âŸ©âŸ© := exists_iso_binaryBiproduct_of_distTriang _ mem rfl\n  dsimp at heâ‚ heâ‚‚\n  refine isomorphic_distinguished _ mem _ (Iso.symm ?_)\n  refine Triangle.isoMk _ _ (Iso.refl _) e (Iso.refl _)\n    (by aesop_cat) (by aesop_cat) (by simp)\n\n"}
{"name":"CategoryTheory.Pretriangulated.binaryProductTriangle_distinguished","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninstâœâ´ : CategoryTheory.Category.{v, u} C\ninstâœÂ³ : CategoryTheory.Limits.HasZeroObject C\ninstâœÂ² : CategoryTheory.HasShift C Int\ninstâœÂ¹ : CategoryTheory.Preadditive C\ninstâœ : âˆ€ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nhC : CategoryTheory.Pretriangulated C\nXâ‚ Xâ‚‚ : C\nâŠ¢ Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles (CategoryTheory.Pretriangulated.binaryProductTriangle Xâ‚ Xâ‚‚)","decl":"lemma binaryProductTriangle_distinguished (Xâ‚ Xâ‚‚ : C) :\n    binaryProductTriangle Xâ‚ Xâ‚‚ âˆˆ distTriang C :=\n  isomorphic_distinguished _ (binaryBiproductTriangle_distinguished Xâ‚ Xâ‚‚) _\n    (binaryProductTriangleIsoBinaryBiproductTriangle Xâ‚ Xâ‚‚)\n\n"}
{"name":"CategoryTheory.Pretriangulated.completeDistinguishedTriangleMorphism_homâ‚","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninstâœâ´ : CategoryTheory.Category.{v, u} C\ninstâœÂ³ : CategoryTheory.Limits.HasZeroObject C\ninstâœÂ² : CategoryTheory.HasShift C Int\ninstâœÂ¹ : CategoryTheory.Preadditive C\ninstâœ : âˆ€ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nhC : CategoryTheory.Pretriangulated C\nTâ‚ Tâ‚‚ : CategoryTheory.Pretriangulated.Triangle C\nhTâ‚ : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles Tâ‚\nhTâ‚‚ : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles Tâ‚‚\na : Quiver.Hom Tâ‚.objâ‚ Tâ‚‚.objâ‚\nb : Quiver.Hom Tâ‚.objâ‚‚ Tâ‚‚.objâ‚‚\ncomm : Eq (CategoryTheory.CategoryStruct.comp Tâ‚.morâ‚ b) (CategoryTheory.CategoryStruct.comp a Tâ‚‚.morâ‚)\nâŠ¢ Eq (CategoryTheory.Pretriangulated.completeDistinguishedTriangleMorphism Tâ‚ Tâ‚‚ hTâ‚ hTâ‚‚ a b comm).homâ‚ a","decl":"/-- A chosen extension of a commutative square into a morphism of distinguished triangles. -/\n@[simps homâ‚ homâ‚‚]\ndef completeDistinguishedTriangleMorphism (Tâ‚ Tâ‚‚ : Triangle C)\n    (hTâ‚ : Tâ‚ âˆˆ distTriang C) (hTâ‚‚ : Tâ‚‚ âˆˆ distTriang C)\n    (a : Tâ‚.objâ‚ âŸ¶ Tâ‚‚.objâ‚) (b : Tâ‚.objâ‚‚ âŸ¶ Tâ‚‚.objâ‚‚) (comm : Tâ‚.morâ‚ â‰« b = a â‰« Tâ‚‚.morâ‚) :\n    Tâ‚ âŸ¶ Tâ‚‚ :=\n    have h := complete_distinguished_triangle_morphism _ _ hTâ‚ hTâ‚‚ a b comm\n    { homâ‚ := a\n      homâ‚‚ := b\n      homâ‚ƒ := h.choose\n      commâ‚ := comm\n      commâ‚‚ := h.choose_spec.1\n      commâ‚ƒ := h.choose_spec.2 }\n\n"}
{"name":"CategoryTheory.Pretriangulated.completeDistinguishedTriangleMorphism_homâ‚‚","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninstâœâ´ : CategoryTheory.Category.{v, u} C\ninstâœÂ³ : CategoryTheory.Limits.HasZeroObject C\ninstâœÂ² : CategoryTheory.HasShift C Int\ninstâœÂ¹ : CategoryTheory.Preadditive C\ninstâœ : âˆ€ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nhC : CategoryTheory.Pretriangulated C\nTâ‚ Tâ‚‚ : CategoryTheory.Pretriangulated.Triangle C\nhTâ‚ : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles Tâ‚\nhTâ‚‚ : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles Tâ‚‚\na : Quiver.Hom Tâ‚.objâ‚ Tâ‚‚.objâ‚\nb : Quiver.Hom Tâ‚.objâ‚‚ Tâ‚‚.objâ‚‚\ncomm : Eq (CategoryTheory.CategoryStruct.comp Tâ‚.morâ‚ b) (CategoryTheory.CategoryStruct.comp a Tâ‚‚.morâ‚)\nâŠ¢ Eq (CategoryTheory.Pretriangulated.completeDistinguishedTriangleMorphism Tâ‚ Tâ‚‚ hTâ‚ hTâ‚‚ a b comm).homâ‚‚ b","decl":"/-- A chosen extension of a commutative square into a morphism of distinguished triangles. -/\n@[simps homâ‚ homâ‚‚]\ndef completeDistinguishedTriangleMorphism (Tâ‚ Tâ‚‚ : Triangle C)\n    (hTâ‚ : Tâ‚ âˆˆ distTriang C) (hTâ‚‚ : Tâ‚‚ âˆˆ distTriang C)\n    (a : Tâ‚.objâ‚ âŸ¶ Tâ‚‚.objâ‚) (b : Tâ‚.objâ‚‚ âŸ¶ Tâ‚‚.objâ‚‚) (comm : Tâ‚.morâ‚ â‰« b = a â‰« Tâ‚‚.morâ‚) :\n    Tâ‚ âŸ¶ Tâ‚‚ :=\n    have h := complete_distinguished_triangle_morphism _ _ hTâ‚ hTâ‚‚ a b comm\n    { homâ‚ := a\n      homâ‚‚ := b\n      homâ‚ƒ := h.choose\n      commâ‚ := comm\n      commâ‚‚ := h.choose_spec.1\n      commâ‚ƒ := h.choose_spec.2 }\n\n"}
{"name":"CategoryTheory.Pretriangulated.productTriangle_distinguished","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninstâœâ¸ : CategoryTheory.Category.{v, u} C\ninstâœâ· : CategoryTheory.Limits.HasZeroObject C\ninstâœâ¶ : CategoryTheory.HasShift C Int\ninstâœâµ : CategoryTheory.Preadditive C\ninstâœâ´ : âˆ€ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nhC : CategoryTheory.Pretriangulated C\nJ : Type u_1\nT : J â†’ CategoryTheory.Pretriangulated.Triangle C\nhT : âˆ€ (j : J), Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles (T j)\ninstâœÂ³ : CategoryTheory.Limits.HasProduct fun j => (T j).objâ‚\ninstâœÂ² : CategoryTheory.Limits.HasProduct fun j => (T j).objâ‚‚\ninstâœÂ¹ : CategoryTheory.Limits.HasProduct fun j => (T j).objâ‚ƒ\ninstâœ : CategoryTheory.Limits.HasProduct fun j => (CategoryTheory.shiftFunctor C 1).obj (T j).objâ‚\nâŠ¢ Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles (CategoryTheory.Pretriangulated.productTriangle T)","decl":"/-- A product of distinguished triangles is distinguished -/\nlemma productTriangle_distinguished {J : Type*} (T : J â†’ Triangle C)\n    (hT : âˆ€ j, T j âˆˆ distTriang C)\n    [HasProduct (fun j => (T j).objâ‚)] [HasProduct (fun j => (T j).objâ‚‚)]\n    [HasProduct (fun j => (T j).objâ‚ƒ)] [HasProduct (fun j => (T j).objâ‚âŸ¦(1 : â„¤)âŸ§)] :\n    productTriangle T âˆˆ distTriang C := by\n  /- The proof proceeds by constructing a morphism of triangles\n    `Ï†' : T' âŸ¶ productTriangle T` with `T'` distinguished, and such that\n    `Ï†'.homâ‚` and `Ï†'.homâ‚‚` are identities. Then, it suffices to show that\n    `Ï†'.homâ‚ƒ` is an isomorphism, which is achieved by using Yoneda's lemma\n    and diagram chases. -/\n  let fâ‚ := Limits.Pi.map (fun j => (T j).morâ‚)\n  obtain âŸ¨Z, fâ‚‚, fâ‚ƒ, hT'âŸ© := distinguished_cocone_triangle fâ‚\n  let T' := Triangle.mk fâ‚ fâ‚‚ fâ‚ƒ\n  change T' âˆˆ distTriang C at hT'\n  let Ï† : âˆ€ j, T' âŸ¶ T j := fun j => completeDistinguishedTriangleMorphism _ _\n    hT' (hT j) (Pi.Ï€ _ j) (Pi.Ï€ _ j) (by simp [fâ‚, T'])\n  let Ï†' := productTriangle.lift _ Ï†\n  have hâ‚ : Ï†'.homâ‚ = ğŸ™ _ := by aesop_cat\n  have hâ‚‚ : Ï†'.homâ‚‚ = ğŸ™ _ := by aesop_cat\n  have : IsIso Ï†'.homâ‚ := by rw [hâ‚]; infer_instance\n  have : IsIso Ï†'.homâ‚‚ := by rw [hâ‚‚]; infer_instance\n  suffices IsIso Ï†'.homâ‚ƒ by\n    have : IsIso Ï†' := by\n      apply Triangle.isIso_of_isIsos\n      all_goals infer_instance\n    exact isomorphic_distinguished _ hT' _ (asIso Ï†').symm\n  refine isIso_of_yoneda_map_bijective _ (fun A => âŸ¨?_, ?_âŸ©)\n  /- the proofs by diagram chase start here -/\n  Â· suffices Mono Ï†'.homâ‚ƒ by\n      intro aâ‚ aâ‚‚ ha\n      simpa only [â† cancel_mono Ï†'.homâ‚ƒ] using ha\n    rw [mono_iff_cancel_zero]\n    intro A f hf\n    have hf' : f â‰« T'.morâ‚ƒ = 0 := by\n      rw [â† cancel_mono (Ï†'.homâ‚âŸ¦1âŸ§'), zero_comp, assoc, Ï†'.commâ‚ƒ, reassoc_of% hf, zero_comp]\n    obtain âŸ¨g, hgâŸ© := T'.coyoneda_exactâ‚ƒ hT' f hf'\n    have hg' : âˆ€ j, (g â‰« Pi.Ï€ _ j) â‰« (T j).morâ‚‚ = 0 := fun j => by\n      have : g â‰« T'.morâ‚‚ â‰« Ï†'.homâ‚ƒ â‰« Pi.Ï€ _ j = 0 := by\n        rw [â† reassoc_of% hg, reassoc_of% hf, zero_comp]\n      rw [Ï†'.commâ‚‚_assoc, hâ‚‚, id_comp] at this\n      simpa using this\n    have hg'' := fun j => (T j).coyoneda_exactâ‚‚ (hT j) _ (hg' j)\n    let Î± := fun j => (hg'' j).choose\n    have hÎ± : âˆ€ j, _ = Î± j â‰« _ := fun j => (hg'' j).choose_spec\n    have hg''' : g = Pi.lift Î± â‰« T'.morâ‚ := by dsimp [fâ‚, T']; ext j; rw [hÎ±]; simp\n    rw [hg, hg''', assoc, comp_distTriang_mor_zeroâ‚â‚‚ _ hT', comp_zero]\n  Â· intro a\n    obtain âŸ¨a', ha'âŸ© : âˆƒ (a' : A âŸ¶ Z), a' â‰« T'.morâ‚ƒ = a â‰« (productTriangle T).morâ‚ƒ := by\n      have zero : ((productTriangle T).morâ‚ƒ) â‰« (shiftFunctor C 1).map T'.morâ‚ = 0 := by\n        rw [â† cancel_mono (Ï†'.homâ‚‚âŸ¦1âŸ§'), zero_comp, assoc, â† Functor.map_comp, Ï†'.commâ‚, hâ‚,\n          id_comp, productTriangle.zeroâ‚ƒâ‚]\n        intro j\n        exact comp_distTriang_mor_zeroâ‚ƒâ‚ _ (hT j)\n      have âŸ¨g, hgâŸ© := T'.coyoneda_exactâ‚ hT' (a â‰« (productTriangle T).morâ‚ƒ) (by\n        rw [assoc, zero, comp_zero])\n      exact âŸ¨g, hg.symmâŸ©\n    have ha'' := fun (j : J) => (T j).coyoneda_exactâ‚ƒ (hT j) ((a - a' â‰« Ï†'.homâ‚ƒ) â‰« Pi.Ï€ _ j) (by\n      simp only [sub_comp, assoc]\n      erw [â† (productTriangle.Ï€ T j).commâ‚ƒ]\n      rw [â† Ï†'.commâ‚ƒ_assoc]\n      rw [reassoc_of% ha', sub_eq_zero, hâ‚, Functor.map_id, id_comp])\n    let b := fun j => (ha'' j).choose\n    have hb : âˆ€ j, _  = b j â‰« _ := fun j => (ha'' j).choose_spec\n    have hb' : a - a' â‰« Ï†'.homâ‚ƒ = Pi.lift b â‰« (productTriangle T).morâ‚‚ :=\n      Limits.Pi.hom_ext _ _ (fun j => by rw [hb]; simp)\n    have : (a' + (by exact Pi.lift b) â‰« T'.morâ‚‚) â‰« Ï†'.homâ‚ƒ = a := by\n      rw [add_comp, assoc, Ï†'.commâ‚‚, hâ‚‚, id_comp, â† hb', add_sub_cancel]\n    exact âŸ¨_, thisâŸ©\n\n"}
{"name":"CategoryTheory.Pretriangulated.exists_iso_of_arrow_iso","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninstâœâ´ : CategoryTheory.Category.{v, u} C\ninstâœÂ³ : CategoryTheory.Limits.HasZeroObject C\ninstâœÂ² : CategoryTheory.HasShift C Int\ninstâœÂ¹ : CategoryTheory.Preadditive C\ninstâœ : âˆ€ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nhC : CategoryTheory.Pretriangulated C\nTâ‚ Tâ‚‚ : CategoryTheory.Pretriangulated.Triangle C\nhTâ‚ : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles Tâ‚\nhTâ‚‚ : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles Tâ‚‚\ne : CategoryTheory.Iso (CategoryTheory.Arrow.mk Tâ‚.morâ‚) (CategoryTheory.Arrow.mk Tâ‚‚.morâ‚)\nâŠ¢ Exists fun e' => And (Eq e'.hom.homâ‚ e.hom.left) (Eq e'.hom.homâ‚‚ e.hom.right)","decl":"lemma exists_iso_of_arrow_iso (Tâ‚ Tâ‚‚ : Triangle C) (hTâ‚ : Tâ‚ âˆˆ distTriang C)\n    (hTâ‚‚ : Tâ‚‚ âˆˆ distTriang C) (e : Arrow.mk Tâ‚.morâ‚ â‰… Arrow.mk Tâ‚‚.morâ‚) :\n    âˆƒ (e' : Tâ‚ â‰… Tâ‚‚), e'.hom.homâ‚ = e.hom.left âˆ§ e'.hom.homâ‚‚ = e.hom.right := by\n  let Ï† := completeDistinguishedTriangleMorphism Tâ‚ Tâ‚‚ hTâ‚ hTâ‚‚ e.hom.left e.hom.right e.hom.w.symm\n  have : IsIso Ï†.homâ‚ := by dsimp [Ï†]; infer_instance\n  have : IsIso Ï†.homâ‚‚ := by dsimp [Ï†]; infer_instance\n  have : IsIso Ï†.homâ‚ƒ := isIsoâ‚ƒ_of_isIsoâ‚â‚‚ Ï† hTâ‚ hTâ‚‚ inferInstance inferInstance\n  have : IsIso Ï† := by\n    apply Triangle.isIso_of_isIsos\n    all_goals infer_instance\n  exact âŸ¨asIso Ï†, by simp [Ï†], by simp [Ï†]âŸ©\n\n"}
{"name":"CategoryTheory.Pretriangulated.isoTriangleOfIsoâ‚â‚‚_hom_homâ‚","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninstâœâ´ : CategoryTheory.Category.{v, u} C\ninstâœÂ³ : CategoryTheory.Limits.HasZeroObject C\ninstâœÂ² : CategoryTheory.HasShift C Int\ninstâœÂ¹ : CategoryTheory.Preadditive C\ninstâœ : âˆ€ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nhC : CategoryTheory.Pretriangulated C\nTâ‚ Tâ‚‚ : CategoryTheory.Pretriangulated.Triangle C\nhTâ‚ : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles Tâ‚\nhTâ‚‚ : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles Tâ‚‚\neâ‚ : CategoryTheory.Iso Tâ‚.objâ‚ Tâ‚‚.objâ‚\neâ‚‚ : CategoryTheory.Iso Tâ‚.objâ‚‚ Tâ‚‚.objâ‚‚\ncomm : Eq (CategoryTheory.CategoryStruct.comp Tâ‚.morâ‚ eâ‚‚.hom) (CategoryTheory.CategoryStruct.comp eâ‚.hom Tâ‚‚.morâ‚)\nâŠ¢ Eq (CategoryTheory.Pretriangulated.isoTriangleOfIsoâ‚â‚‚ Tâ‚ Tâ‚‚ hTâ‚ hTâ‚‚ eâ‚ eâ‚‚ comm).hom.homâ‚ eâ‚.hom","decl":"/-- A choice of isomorphism `Tâ‚ â‰… Tâ‚‚` between two distinguished triangles\nwhen we are given two isomorphisms `eâ‚ : Tâ‚.objâ‚ â‰… Tâ‚‚.objâ‚` and `eâ‚‚ : Tâ‚.objâ‚‚ â‰… Tâ‚‚.objâ‚‚`. -/\n@[simps! hom_homâ‚ hom_homâ‚‚ inv_homâ‚ inv_homâ‚‚]\ndef isoTriangleOfIsoâ‚â‚‚ (Tâ‚ Tâ‚‚ : Triangle C) (hTâ‚ : Tâ‚ âˆˆ distTriang C)\n    (hTâ‚‚ : Tâ‚‚ âˆˆ distTriang C) (eâ‚ : Tâ‚.objâ‚ â‰… Tâ‚‚.objâ‚) (eâ‚‚ : Tâ‚.objâ‚‚ â‰… Tâ‚‚.objâ‚‚)\n    (comm : Tâ‚.morâ‚ â‰« eâ‚‚.hom = eâ‚.hom â‰« Tâ‚‚.morâ‚) : Tâ‚ â‰… Tâ‚‚ := by\n  have h := exists_iso_of_arrow_iso Tâ‚ Tâ‚‚ hTâ‚ hTâ‚‚ (Arrow.isoMk eâ‚ eâ‚‚ comm.symm)\n  exact Triangle.isoMk _ _ eâ‚ eâ‚‚ (Triangle.Ï€â‚ƒ.mapIso h.choose) comm (by\n    have eq := h.choose_spec.2\n    dsimp at eq âŠ¢\n    conv_rhs => rw [â† eq, â† TriangleMorphism.commâ‚‚]) (by\n    have eq := h.choose_spec.1\n    dsimp at eq âŠ¢\n    conv_lhs => rw [â† eq, TriangleMorphism.commâ‚ƒ])\n\n"}
{"name":"CategoryTheory.Pretriangulated.isoTriangleOfIsoâ‚â‚‚_hom_homâ‚‚","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninstâœâ´ : CategoryTheory.Category.{v, u} C\ninstâœÂ³ : CategoryTheory.Limits.HasZeroObject C\ninstâœÂ² : CategoryTheory.HasShift C Int\ninstâœÂ¹ : CategoryTheory.Preadditive C\ninstâœ : âˆ€ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nhC : CategoryTheory.Pretriangulated C\nTâ‚ Tâ‚‚ : CategoryTheory.Pretriangulated.Triangle C\nhTâ‚ : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles Tâ‚\nhTâ‚‚ : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles Tâ‚‚\neâ‚ : CategoryTheory.Iso Tâ‚.objâ‚ Tâ‚‚.objâ‚\neâ‚‚ : CategoryTheory.Iso Tâ‚.objâ‚‚ Tâ‚‚.objâ‚‚\ncomm : Eq (CategoryTheory.CategoryStruct.comp Tâ‚.morâ‚ eâ‚‚.hom) (CategoryTheory.CategoryStruct.comp eâ‚.hom Tâ‚‚.morâ‚)\nâŠ¢ Eq (CategoryTheory.Pretriangulated.isoTriangleOfIsoâ‚â‚‚ Tâ‚ Tâ‚‚ hTâ‚ hTâ‚‚ eâ‚ eâ‚‚ comm).hom.homâ‚‚ eâ‚‚.hom","decl":"/-- A choice of isomorphism `Tâ‚ â‰… Tâ‚‚` between two distinguished triangles\nwhen we are given two isomorphisms `eâ‚ : Tâ‚.objâ‚ â‰… Tâ‚‚.objâ‚` and `eâ‚‚ : Tâ‚.objâ‚‚ â‰… Tâ‚‚.objâ‚‚`. -/\n@[simps! hom_homâ‚ hom_homâ‚‚ inv_homâ‚ inv_homâ‚‚]\ndef isoTriangleOfIsoâ‚â‚‚ (Tâ‚ Tâ‚‚ : Triangle C) (hTâ‚ : Tâ‚ âˆˆ distTriang C)\n    (hTâ‚‚ : Tâ‚‚ âˆˆ distTriang C) (eâ‚ : Tâ‚.objâ‚ â‰… Tâ‚‚.objâ‚) (eâ‚‚ : Tâ‚.objâ‚‚ â‰… Tâ‚‚.objâ‚‚)\n    (comm : Tâ‚.morâ‚ â‰« eâ‚‚.hom = eâ‚.hom â‰« Tâ‚‚.morâ‚) : Tâ‚ â‰… Tâ‚‚ := by\n  have h := exists_iso_of_arrow_iso Tâ‚ Tâ‚‚ hTâ‚ hTâ‚‚ (Arrow.isoMk eâ‚ eâ‚‚ comm.symm)\n  exact Triangle.isoMk _ _ eâ‚ eâ‚‚ (Triangle.Ï€â‚ƒ.mapIso h.choose) comm (by\n    have eq := h.choose_spec.2\n    dsimp at eq âŠ¢\n    conv_rhs => rw [â† eq, â† TriangleMorphism.commâ‚‚]) (by\n    have eq := h.choose_spec.1\n    dsimp at eq âŠ¢\n    conv_lhs => rw [â† eq, TriangleMorphism.commâ‚ƒ])\n\n"}
{"name":"CategoryTheory.Pretriangulated.isoTriangleOfIsoâ‚â‚‚_inv_homâ‚","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninstâœâ´ : CategoryTheory.Category.{v, u} C\ninstâœÂ³ : CategoryTheory.Limits.HasZeroObject C\ninstâœÂ² : CategoryTheory.HasShift C Int\ninstâœÂ¹ : CategoryTheory.Preadditive C\ninstâœ : âˆ€ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nhC : CategoryTheory.Pretriangulated C\nTâ‚ Tâ‚‚ : CategoryTheory.Pretriangulated.Triangle C\nhTâ‚ : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles Tâ‚\nhTâ‚‚ : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles Tâ‚‚\neâ‚ : CategoryTheory.Iso Tâ‚.objâ‚ Tâ‚‚.objâ‚\neâ‚‚ : CategoryTheory.Iso Tâ‚.objâ‚‚ Tâ‚‚.objâ‚‚\ncomm : Eq (CategoryTheory.CategoryStruct.comp Tâ‚.morâ‚ eâ‚‚.hom) (CategoryTheory.CategoryStruct.comp eâ‚.hom Tâ‚‚.morâ‚)\nâŠ¢ Eq (CategoryTheory.Pretriangulated.isoTriangleOfIsoâ‚â‚‚ Tâ‚ Tâ‚‚ hTâ‚ hTâ‚‚ eâ‚ eâ‚‚ comm).inv.homâ‚ eâ‚.inv","decl":"/-- A choice of isomorphism `Tâ‚ â‰… Tâ‚‚` between two distinguished triangles\nwhen we are given two isomorphisms `eâ‚ : Tâ‚.objâ‚ â‰… Tâ‚‚.objâ‚` and `eâ‚‚ : Tâ‚.objâ‚‚ â‰… Tâ‚‚.objâ‚‚`. -/\n@[simps! hom_homâ‚ hom_homâ‚‚ inv_homâ‚ inv_homâ‚‚]\ndef isoTriangleOfIsoâ‚â‚‚ (Tâ‚ Tâ‚‚ : Triangle C) (hTâ‚ : Tâ‚ âˆˆ distTriang C)\n    (hTâ‚‚ : Tâ‚‚ âˆˆ distTriang C) (eâ‚ : Tâ‚.objâ‚ â‰… Tâ‚‚.objâ‚) (eâ‚‚ : Tâ‚.objâ‚‚ â‰… Tâ‚‚.objâ‚‚)\n    (comm : Tâ‚.morâ‚ â‰« eâ‚‚.hom = eâ‚.hom â‰« Tâ‚‚.morâ‚) : Tâ‚ â‰… Tâ‚‚ := by\n  have h := exists_iso_of_arrow_iso Tâ‚ Tâ‚‚ hTâ‚ hTâ‚‚ (Arrow.isoMk eâ‚ eâ‚‚ comm.symm)\n  exact Triangle.isoMk _ _ eâ‚ eâ‚‚ (Triangle.Ï€â‚ƒ.mapIso h.choose) comm (by\n    have eq := h.choose_spec.2\n    dsimp at eq âŠ¢\n    conv_rhs => rw [â† eq, â† TriangleMorphism.commâ‚‚]) (by\n    have eq := h.choose_spec.1\n    dsimp at eq âŠ¢\n    conv_lhs => rw [â† eq, TriangleMorphism.commâ‚ƒ])\n\n"}
{"name":"CategoryTheory.Pretriangulated.isoTriangleOfIsoâ‚â‚‚_inv_homâ‚‚","module":"Mathlib.CategoryTheory.Triangulated.Pretriangulated","initialProofState":"C : Type u\ninstâœâ´ : CategoryTheory.Category.{v, u} C\ninstâœÂ³ : CategoryTheory.Limits.HasZeroObject C\ninstâœÂ² : CategoryTheory.HasShift C Int\ninstâœÂ¹ : CategoryTheory.Preadditive C\ninstâœ : âˆ€ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nhC : CategoryTheory.Pretriangulated C\nTâ‚ Tâ‚‚ : CategoryTheory.Pretriangulated.Triangle C\nhTâ‚ : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles Tâ‚\nhTâ‚‚ : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles Tâ‚‚\neâ‚ : CategoryTheory.Iso Tâ‚.objâ‚ Tâ‚‚.objâ‚\neâ‚‚ : CategoryTheory.Iso Tâ‚.objâ‚‚ Tâ‚‚.objâ‚‚\ncomm : Eq (CategoryTheory.CategoryStruct.comp Tâ‚.morâ‚ eâ‚‚.hom) (CategoryTheory.CategoryStruct.comp eâ‚.hom Tâ‚‚.morâ‚)\nâŠ¢ Eq (CategoryTheory.Pretriangulated.isoTriangleOfIsoâ‚â‚‚ Tâ‚ Tâ‚‚ hTâ‚ hTâ‚‚ eâ‚ eâ‚‚ comm).inv.homâ‚‚ eâ‚‚.inv","decl":"/-- A choice of isomorphism `Tâ‚ â‰… Tâ‚‚` between two distinguished triangles\nwhen we are given two isomorphisms `eâ‚ : Tâ‚.objâ‚ â‰… Tâ‚‚.objâ‚` and `eâ‚‚ : Tâ‚.objâ‚‚ â‰… Tâ‚‚.objâ‚‚`. -/\n@[simps! hom_homâ‚ hom_homâ‚‚ inv_homâ‚ inv_homâ‚‚]\ndef isoTriangleOfIsoâ‚â‚‚ (Tâ‚ Tâ‚‚ : Triangle C) (hTâ‚ : Tâ‚ âˆˆ distTriang C)\n    (hTâ‚‚ : Tâ‚‚ âˆˆ distTriang C) (eâ‚ : Tâ‚.objâ‚ â‰… Tâ‚‚.objâ‚) (eâ‚‚ : Tâ‚.objâ‚‚ â‰… Tâ‚‚.objâ‚‚)\n    (comm : Tâ‚.morâ‚ â‰« eâ‚‚.hom = eâ‚.hom â‰« Tâ‚‚.morâ‚) : Tâ‚ â‰… Tâ‚‚ := by\n  have h := exists_iso_of_arrow_iso Tâ‚ Tâ‚‚ hTâ‚ hTâ‚‚ (Arrow.isoMk eâ‚ eâ‚‚ comm.symm)\n  exact Triangle.isoMk _ _ eâ‚ eâ‚‚ (Triangle.Ï€â‚ƒ.mapIso h.choose) comm (by\n    have eq := h.choose_spec.2\n    dsimp at eq âŠ¢\n    conv_rhs => rw [â† eq, â† TriangleMorphism.commâ‚‚]) (by\n    have eq := h.choose_spec.1\n    dsimp at eq âŠ¢\n    conv_lhs => rw [â† eq, TriangleMorphism.commâ‚ƒ])\n\n"}
