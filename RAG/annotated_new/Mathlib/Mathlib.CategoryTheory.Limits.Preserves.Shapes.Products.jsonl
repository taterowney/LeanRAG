{"name":"CategoryTheory.Limits.PreservesProduct.of_iso_comparison","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Products","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nG : CategoryTheory.Functor C D\nJ : Type w\nf : J → C\ninst✝¹ : CategoryTheory.Limits.HasProduct f\ninst✝ : CategoryTheory.Limits.HasProduct fun j => G.obj (f j)\ni : CategoryTheory.IsIso (CategoryTheory.Limits.piComparison G f)\n⊢ CategoryTheory.Limits.PreservesLimit (CategoryTheory.Discrete.functor f) G","decl":"/-- If `pi_comparison G f` is an isomorphism, then `G` preserves the limit of `f`. -/\nlemma PreservesProduct.of_iso_comparison [i : IsIso (piComparison G f)] :\n    PreservesLimit (Discrete.functor f) G := by\n  apply preservesLimit_of_preserves_limit_cone (productIsProduct f)\n  apply (isLimitMapConeFanMkEquiv _ _ _).symm _\n  exact @IsLimit.ofPointIso _ _ _ _ _ _ _\n    (limit.isLimit (Discrete.functor fun j : J => G.obj (f j))) i\n\n"}
{"name":"CategoryTheory.Limits.PreservesProduct.iso_hom","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Products","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\nG : CategoryTheory.Functor C D\nJ : Type w\nf : J → C\ninst✝² : CategoryTheory.Limits.HasProduct f\ninst✝¹ : CategoryTheory.Limits.HasProduct fun j => G.obj (f j)\ninst✝ : CategoryTheory.Limits.PreservesLimit (CategoryTheory.Discrete.functor f) G\n⊢ Eq (CategoryTheory.Limits.PreservesProduct.iso G f).hom (CategoryTheory.Limits.piComparison G f)","decl":"@[simp]\ntheorem PreservesProduct.iso_hom : (PreservesProduct.iso G f).hom = piComparison G f :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.instIsIsoPiComparison","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Products","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nG : CategoryTheory.Functor C D\nJ : Type w\nf : J → C\ninst✝¹ : CategoryTheory.Limits.HasProduct f\ninst✝ : CategoryTheory.Limits.HasProduct fun j => G.obj (f j)\n⊢ CategoryTheory.IsIso (CategoryTheory.Limits.piComparison G f)","decl":"instance : IsIso (piComparison G f) := by\n  rw [← PreservesProduct.iso_hom]\n  infer_instance\n\n"}
{"name":"CategoryTheory.Limits.PreservesCoproduct.of_iso_comparison","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Products","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nG : CategoryTheory.Functor C D\nJ : Type w\nf : J → C\ninst✝¹ : CategoryTheory.Limits.HasCoproduct f\ninst✝ : CategoryTheory.Limits.HasCoproduct fun j => G.obj (f j)\ni : CategoryTheory.IsIso (CategoryTheory.Limits.sigmaComparison G f)\n⊢ CategoryTheory.Limits.PreservesColimit (CategoryTheory.Discrete.functor f) G","decl":"/-- If `sigma_comparison G f` is an isomorphism, then `G` preserves the colimit of `f`. -/\nlemma PreservesCoproduct.of_iso_comparison [i : IsIso (sigmaComparison G f)] :\n    PreservesColimit (Discrete.functor f) G := by\n  apply preservesColimit_of_preserves_colimit_cocone (coproductIsCoproduct f)\n  apply (isColimitMapCoconeCofanMkEquiv _ _ _).symm _\n  exact @IsColimit.ofPointIso _ _ _ _ _ _ _\n    (colimit.isColimit (Discrete.functor fun j : J => G.obj (f j))) i\n\n"}
{"name":"CategoryTheory.Limits.PreservesCoproduct.inv_hom","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Products","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\nG : CategoryTheory.Functor C D\nJ : Type w\nf : J → C\ninst✝² : CategoryTheory.Limits.HasCoproduct f\ninst✝¹ : CategoryTheory.Limits.HasCoproduct fun j => G.obj (f j)\ninst✝ : CategoryTheory.Limits.PreservesColimit (CategoryTheory.Discrete.functor f) G\n⊢ Eq (CategoryTheory.Limits.PreservesCoproduct.iso G f).inv (CategoryTheory.Limits.sigmaComparison G f)","decl":"@[simp]\ntheorem PreservesCoproduct.inv_hom : (PreservesCoproduct.iso G f).inv = sigmaComparison G f := rfl\n\n"}
{"name":"CategoryTheory.Limits.instIsIsoSigmaComparison","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Products","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nG : CategoryTheory.Functor C D\nJ : Type w\nf : J → C\ninst✝¹ : CategoryTheory.Limits.HasCoproduct f\ninst✝ : CategoryTheory.Limits.HasCoproduct fun j => G.obj (f j)\n⊢ CategoryTheory.IsIso (CategoryTheory.Limits.sigmaComparison G f)","decl":"instance : IsIso (sigmaComparison G f) := by\n  rw [← PreservesCoproduct.inv_hom]\n  infer_instance\n\n"}
{"name":"CategoryTheory.Limits.preservesLimitsOfShape_of_discrete","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Products","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nJ : Type w\nF : CategoryTheory.Functor C D\ninst✝ : ∀ (f : J → C), CategoryTheory.Limits.PreservesLimit (CategoryTheory.Discrete.functor f) F\n⊢ CategoryTheory.Limits.PreservesLimitsOfShape (CategoryTheory.Discrete J) F","decl":"/-- If `F` preserves the limit of every `Discrete.functor f`, it preserves all limits of shape\n`Discrete J`. -/\nlemma preservesLimitsOfShape_of_discrete (F : C ⥤ D)\n    [∀ (f : J → C), PreservesLimit (Discrete.functor f) F] :\n    PreservesLimitsOfShape (Discrete J) F where\n  preservesLimit := preservesLimit_of_iso_diagram F (Discrete.natIsoFunctor).symm\n\n"}
{"name":"CategoryTheory.Limits.preservesColimitsOfShape_of_discrete","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Products","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nJ : Type w\nF : CategoryTheory.Functor C D\ninst✝ : ∀ (f : J → C), CategoryTheory.Limits.PreservesColimit (CategoryTheory.Discrete.functor f) F\n⊢ CategoryTheory.Limits.PreservesColimitsOfShape (CategoryTheory.Discrete J) F","decl":"/-- If `F` preserves the colimit of every `Discrete.functor f`, it preserves all colimits of shape\n`Discrete J`. -/\nlemma preservesColimitsOfShape_of_discrete (F : C ⥤ D)\n    [∀ (f : J → C), PreservesColimit (Discrete.functor f) F] :\n    PreservesColimitsOfShape (Discrete J) F where\n  preservesColimit := preservesColimit_of_iso_diagram F (Discrete.natIsoFunctor).symm\n\n"}
