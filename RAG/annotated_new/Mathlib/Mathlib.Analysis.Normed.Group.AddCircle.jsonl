{"name":"AddCircle.norm_coe_mul","module":"Mathlib.Analysis.Normed.Group.AddCircle","initialProofState":"p x t : Real\n⊢ Eq (Norm.norm ↑(HMul.hMul t x)) (HMul.hMul (abs t) (Norm.norm ↑x))","decl":"@[simp]\ntheorem norm_coe_mul (x : ℝ) (t : ℝ) :\n    ‖(↑(t * x) : AddCircle (t * p))‖ = |t| * ‖(x : AddCircle p)‖ := by\n  have aux : ∀ {a b c : ℝ}, a ∈ zmultiples b → c * a ∈ zmultiples (c * b) := fun {a b c} h => by\n    simp only [mem_zmultiples_iff] at h ⊢\n    obtain ⟨n, rfl⟩ := h\n    exact ⟨n, (mul_smul_comm n c b).symm⟩\n  rcases eq_or_ne t 0 with (rfl | ht); · simp\n  have ht' : |t| ≠ 0 := (not_congr abs_eq_zero).mpr ht\n  simp only [quotient_norm_eq, Real.norm_eq_abs]\n  conv_rhs => rw [← smul_eq_mul, ← Real.sInf_smul_of_nonneg (abs_nonneg t)]\n  simp only [QuotientAddGroup.mk'_apply, QuotientAddGroup.eq_iff_sub_mem]\n  congr 1\n  ext z\n  rw [mem_smul_set_iff_inv_smul_mem₀ ht']\n  show\n    (∃ y, y - t * x ∈ zmultiples (t * p) ∧ |y| = z) ↔ ∃ w, w - x ∈ zmultiples p ∧ |w| = |t|⁻¹ * z\n  constructor\n  · rintro ⟨y, hy, rfl⟩\n    refine ⟨t⁻¹ * y, ?_, by rw [abs_mul, abs_inv]⟩\n    rw [← inv_mul_cancel_left₀ ht x, ← inv_mul_cancel_left₀ ht p, ← mul_sub]\n    exact aux hy\n  · rintro ⟨w, hw, hw'⟩\n    refine ⟨t * w, ?_, by rw [← (eq_inv_mul_iff_mul_eq₀ ht').mp hw', abs_mul]⟩\n    rw [← mul_sub]\n    exact aux hw\n\n"}
{"name":"AddCircle.norm_neg_period","module":"Mathlib.Analysis.Normed.Group.AddCircle","initialProofState":"p x : Real\n⊢ Eq (Norm.norm ↑x) (Norm.norm ↑x)","decl":"theorem norm_neg_period (x : ℝ) : ‖(x : AddCircle (-p))‖ = ‖(x : AddCircle p)‖ := by\n  suffices ‖(↑(-1 * x) : AddCircle (-1 * p))‖ = ‖(x : AddCircle p)‖ by\n    rw [← this, neg_one_mul]\n    simp\n  simp only [norm_coe_mul, abs_neg, abs_one, one_mul]\n\n"}
{"name":"AddCircle.norm_eq_of_zero","module":"Mathlib.Analysis.Normed.Group.AddCircle","initialProofState":"x : Real\n⊢ Eq (Norm.norm ↑x) (abs x)","decl":"@[simp]\ntheorem norm_eq_of_zero {x : ℝ} : ‖(x : AddCircle (0 : ℝ))‖ = |x| := by\n  suffices { y : ℝ | (y : AddCircle (0 : ℝ)) = (x : AddCircle (0 : ℝ)) } = {x} by\n    rw [quotient_norm_eq, this, image_singleton, Real.norm_eq_abs, csInf_singleton]\n  ext y\n  simp [QuotientAddGroup.eq_iff_sub_mem, mem_zmultiples_iff, sub_eq_zero]\n\n"}
{"name":"AddCircle.norm_eq","module":"Mathlib.Analysis.Normed.Group.AddCircle","initialProofState":"p x : Real\n⊢ Eq (Norm.norm ↑x) (abs (HSub.hSub x (HMul.hMul (↑(round (HMul.hMul (Inv.inv p) x))) p)))","decl":"theorem norm_eq {x : ℝ} : ‖(x : AddCircle p)‖ = |x - round (p⁻¹ * x) * p| := by\n  suffices ∀ x : ℝ, ‖(x : AddCircle (1 : ℝ))‖ = |x - round x| by\n    rcases eq_or_ne p 0 with (rfl | hp)\n    · simp\n    have hx := norm_coe_mul p x p⁻¹\n    rw [abs_inv, eq_inv_mul_iff_mul_eq₀ ((not_congr abs_eq_zero).mpr hp)] at hx\n    rw [← hx, inv_mul_cancel₀ hp, this, ← abs_mul, mul_sub, mul_inv_cancel_left₀ hp, mul_comm p]\n  clear! x p\n  intros x\n  rw [quotient_norm_eq, abs_sub_round_eq_min]\n  have h₁ : BddBelow (abs '' { m : ℝ | (m : AddCircle (1 : ℝ)) = x }) :=\n    ⟨0, by simp [mem_lowerBounds]⟩\n  have h₂ : (abs '' { m : ℝ | (m : AddCircle (1 : ℝ)) = x }).Nonempty := ⟨|x|, ⟨x, rfl, rfl⟩⟩\n  apply le_antisymm\n  · simp_rw [Real.norm_eq_abs, csInf_le_iff h₁ h₂, le_min_iff]\n    intro b h\n    refine\n      ⟨mem_lowerBounds.1 h _ ⟨fract x, ?_, abs_fract⟩,\n        mem_lowerBounds.1 h _ ⟨fract x - 1, ?_, by rw [abs_sub_comm, abs_one_sub_fract]⟩⟩\n    · simp only [mem_setOf, fract, sub_eq_self, QuotientAddGroup.mk_sub,\n        QuotientAddGroup.eq_zero_iff, intCast_mem_zmultiples_one]\n    · simp only [mem_setOf, fract, sub_eq_self, QuotientAddGroup.mk_sub,\n        QuotientAddGroup.eq_zero_iff, intCast_mem_zmultiples_one, sub_sub,\n        (by norm_cast : (⌊x⌋ : ℝ) + 1 = (↑(⌊x⌋ + 1) : ℝ))]\n  · simp only [QuotientAddGroup.mk'_apply, Real.norm_eq_abs, le_csInf_iff h₁ h₂]\n    rintro b' ⟨b, hb, rfl⟩\n    simp only [mem_setOf, QuotientAddGroup.eq_iff_sub_mem, mem_zmultiples_iff,\n      smul_one_eq_cast] at hb\n    obtain ⟨z, hz⟩ := hb\n    rw [(by rw [hz]; abel : x = b - z), fract_sub_int, ← abs_sub_round_eq_min]\n    convert round_le b 0\n    simp\n\n"}
{"name":"AddCircle.norm_eq'","module":"Mathlib.Analysis.Normed.Group.AddCircle","initialProofState":"p : Real\nhp : LT.lt 0 p\nx : Real\n⊢ Eq (Norm.norm ↑x) (HMul.hMul p (abs (HSub.hSub (HMul.hMul (Inv.inv p) x) ↑(round (HMul.hMul (Inv.inv p) x)))))","decl":"theorem norm_eq' (hp : 0 < p) {x : ℝ} : ‖(x : AddCircle p)‖ = p * |p⁻¹ * x - round (p⁻¹ * x)| := by\n  conv_rhs =>\n    congr\n    rw [← abs_eq_self.mpr hp.le]\n  rw [← abs_mul, mul_sub, mul_inv_cancel_left₀ hp.ne.symm, norm_eq, mul_comm p]\n\n"}
{"name":"AddCircle.norm_le_half_period","module":"Mathlib.Analysis.Normed.Group.AddCircle","initialProofState":"p : Real\nx : AddCircle p\nhp : Ne p 0\n⊢ LE.le (Norm.norm x) (HDiv.hDiv (abs p) 2)","decl":"theorem norm_le_half_period {x : AddCircle p} (hp : p ≠ 0) : ‖x‖ ≤ |p| / 2 := by\n  obtain ⟨x⟩ := x\n  change ‖(x : AddCircle p)‖ ≤ |p| / 2\n  rw [norm_eq, ← mul_le_mul_left (abs_pos.mpr (inv_ne_zero hp)), ← abs_mul, mul_sub, mul_left_comm,\n    ← mul_div_assoc, ← abs_mul, inv_mul_cancel₀ hp, mul_one, abs_one]\n  exact abs_sub_round (p⁻¹ * x)\n\n"}
{"name":"AddCircle.norm_half_period_eq","module":"Mathlib.Analysis.Normed.Group.AddCircle","initialProofState":"p : Real\n⊢ Eq (Norm.norm ↑(HDiv.hDiv p 2)) (HDiv.hDiv (abs p) 2)","decl":"@[simp]\ntheorem norm_half_period_eq : ‖(↑(p / 2) : AddCircle p)‖ = |p| / 2 := by\n  rcases eq_or_ne p 0 with (rfl | hp); · simp\n  rw [norm_eq, ← mul_div_assoc, inv_mul_cancel₀ hp, one_div, round_two_inv, Int.cast_one,\n    one_mul, (by linarith : p / 2 - p = -(p / 2)), abs_neg, abs_div, abs_two]\n\n"}
{"name":"AddCircle.norm_coe_eq_abs_iff","module":"Mathlib.Analysis.Normed.Group.AddCircle","initialProofState":"p x : Real\nhp : Ne p 0\n⊢ Iff (Eq (Norm.norm ↑x) (abs x)) (LE.le (abs x) (HDiv.hDiv (abs p) 2))","decl":"theorem norm_coe_eq_abs_iff {x : ℝ} (hp : p ≠ 0) : ‖(x : AddCircle p)‖ = |x| ↔ |x| ≤ |p| / 2 := by\n  refine ⟨fun hx => hx ▸ norm_le_half_period p hp, fun hx => ?_⟩\n  suffices ∀ p : ℝ, 0 < p → |x| ≤ p / 2 → ‖(x : AddCircle p)‖ = |x| by\n    -- Porting note: replaced `lt_trichotomy` which had trouble substituting `p = 0`.\n    rcases hp.symm.lt_or_lt with (hp | hp)\n    · rw [abs_eq_self.mpr hp.le] at hx\n      exact this p hp hx\n    · rw [← norm_neg_period]\n      rw [abs_eq_neg_self.mpr hp.le] at hx\n      exact this (-p) (neg_pos.mpr hp) hx\n  clear hx\n  intro p hp hx\n  rcases eq_or_ne x (p / (2 : ℝ)) with (rfl | hx')\n  · simp [abs_div, abs_two]\n  suffices round (p⁻¹ * x) = 0 by simp [norm_eq, this]\n  rw [round_eq_zero_iff]\n  obtain ⟨hx₁, hx₂⟩ := abs_le.mp hx\n  replace hx₂ := Ne.lt_of_le hx' hx₂\n  constructor\n  · rwa [← mul_le_mul_left hp, ← mul_assoc, mul_inv_cancel₀ hp.ne.symm, one_mul, mul_neg, ←\n      mul_div_assoc, mul_one]\n  · rwa [← mul_lt_mul_left hp, ← mul_assoc, mul_inv_cancel₀ hp.ne.symm, one_mul, ← mul_div_assoc,\n      mul_one]\n\n"}
{"name":"AddCircle.closedBall_eq_univ_of_half_period_le","module":"Mathlib.Analysis.Normed.Group.AddCircle","initialProofState":"p : Real\nhp : Ne p 0\nx : AddCircle p\nε : Real\nhε : LE.le (HDiv.hDiv (abs p) 2) ε\n⊢ Eq (Metric.closedBall x ε) Set.univ","decl":"theorem closedBall_eq_univ_of_half_period_le (hp : p ≠ 0) (x : AddCircle p) {ε : ℝ}\n    (hε : |p| / 2 ≤ ε) : closedBall x ε = univ :=\n  eq_univ_iff_forall.mpr fun x => by\n    simpa only [mem_closedBall, dist_eq_norm] using (norm_le_half_period p hp).trans hε\n\n"}
{"name":"AddCircle.coe_real_preimage_closedBall_period_zero","module":"Mathlib.Analysis.Normed.Group.AddCircle","initialProofState":"x ε : Real\n⊢ Eq (Set.preimage QuotientAddGroup.mk (Metric.closedBall (↑x) ε)) (Metric.closedBall x ε)","decl":"@[simp]\ntheorem coe_real_preimage_closedBall_period_zero (x ε : ℝ) :\n    (↑) ⁻¹' closedBall (x : AddCircle (0 : ℝ)) ε = closedBall x ε := by\n  ext y\n  -- Porting note: squeezed the simp\n  simp only [Set.mem_preimage, dist_eq_norm, AddCircle.norm_eq_of_zero, iff_self,\n    ← QuotientAddGroup.mk_sub, Metric.mem_closedBall, Real.norm_eq_abs]\n\n"}
{"name":"AddCircle.coe_real_preimage_closedBall_eq_iUnion","module":"Mathlib.Analysis.Normed.Group.AddCircle","initialProofState":"p x ε : Real\n⊢ Eq (Set.preimage QuotientAddGroup.mk (Metric.closedBall (↑x) ε)) (Set.iUnion fun z => Metric.closedBall (HAdd.hAdd x (HSMul.hSMul z p)) ε)","decl":"theorem coe_real_preimage_closedBall_eq_iUnion (x ε : ℝ) :\n    (↑) ⁻¹' closedBall (x : AddCircle p) ε = ⋃ z : ℤ, closedBall (x + z • p) ε := by\n  rcases eq_or_ne p 0 with (rfl | hp)\n  · simp [iUnion_const]\n  ext y\n  simp only [dist_eq_norm, mem_preimage, mem_closedBall, zsmul_eq_mul, mem_iUnion, Real.norm_eq_abs,\n    ← QuotientAddGroup.mk_sub, norm_eq, ← sub_sub]\n  refine ⟨fun h => ⟨round (p⁻¹ * (y - x)), h⟩, ?_⟩\n  rintro ⟨n, hn⟩\n  rw [← mul_le_mul_left (abs_pos.mpr <| inv_ne_zero hp), ← abs_mul, mul_sub, mul_comm _ p,\n    inv_mul_cancel_left₀ hp] at hn ⊢\n  exact (round_le (p⁻¹ * (y - x)) n).trans hn\n\n"}
{"name":"AddCircle.coe_real_preimage_closedBall_inter_eq","module":"Mathlib.Analysis.Normed.Group.AddCircle","initialProofState":"p x ε : Real\ns : Set Real\nhs : HasSubset.Subset s (Metric.closedBall x (HDiv.hDiv (abs p) 2))\n⊢ Eq (Inter.inter (Set.preimage QuotientAddGroup.mk (Metric.closedBall (↑x) ε)) s) (ite (LT.lt ε (HDiv.hDiv (abs p) 2)) (Inter.inter (Metric.closedBall x ε) s) s)","decl":"theorem coe_real_preimage_closedBall_inter_eq {x ε : ℝ} (s : Set ℝ)\n    (hs : s ⊆ closedBall x (|p| / 2)) :\n    (↑) ⁻¹' closedBall (x : AddCircle p) ε ∩ s = if ε < |p| / 2 then closedBall x ε ∩ s else s := by\n  rcases le_or_lt (|p| / 2) ε with hε | hε\n  · rcases eq_or_ne p 0 with (rfl | hp)\n    · simp only [abs_zero, zero_div] at hε\n      simp only [not_lt.mpr hε, coe_real_preimage_closedBall_period_zero, abs_zero, zero_div,\n        if_false, inter_eq_right]\n      exact hs.trans (closedBall_subset_closedBall <| by simp [hε])\n    -- Porting note: was\n    -- simp [closedBall_eq_univ_of_half_period_le p hp (↑x) hε, not_lt.mpr hε]\n    simp only [not_lt.mpr hε, ite_false, inter_eq_right]\n    rw [closedBall_eq_univ_of_half_period_le p hp (↑x : ℝ ⧸ zmultiples p) hε, preimage_univ]\n    apply subset_univ\n  · suffices ∀ z : ℤ, closedBall (x + z • p) ε ∩ s = if z = 0 then closedBall x ε ∩ s else ∅ by\n      simp [-zsmul_eq_mul, ← QuotientAddGroup.mk_zero, coe_real_preimage_closedBall_eq_iUnion,\n        iUnion_inter, iUnion_ite, this, hε]\n    intro z\n    simp only [Real.closedBall_eq_Icc, zero_sub, zero_add] at hs ⊢\n    rcases eq_or_ne z 0 with (rfl | hz)\n    · simp\n    simp only [hz, zsmul_eq_mul, if_false, eq_empty_iff_forall_not_mem]\n    rintro y ⟨⟨hy₁, hy₂⟩, hy₀⟩\n    obtain ⟨hy₃, hy₄⟩ := hs hy₀\n    rcases lt_trichotomy 0 p with (hp | (rfl : 0 = p) | hp)\n    · cases' Int.cast_le_neg_one_or_one_le_cast_of_ne_zero ℝ hz with hz' hz'\n      · have : ↑z * p ≤ -p := by nlinarith\n        linarith [abs_eq_self.mpr hp.le]\n      · have : p ≤ ↑z * p := by nlinarith\n        linarith [abs_eq_self.mpr hp.le]\n    · simp only [mul_zero, add_zero, abs_zero, zero_div] at hy₁ hy₂ hε\n      linarith\n    · cases' Int.cast_le_neg_one_or_one_le_cast_of_ne_zero ℝ hz with hz' hz'\n      · have : -p ≤ ↑z * p := by nlinarith\n        linarith [abs_eq_neg_self.mpr hp.le]\n      · have : ↑z * p ≤ p := by nlinarith\n        linarith [abs_eq_neg_self.mpr hp.le]\n\n"}
{"name":"AddCircle.norm_div_natCast","module":"Mathlib.Analysis.Normed.Group.AddCircle","initialProofState":"p : Real\nhp : Fact (LT.lt 0 p)\nm n : Nat\n⊢ Eq (Norm.norm ↑(HMul.hMul (HDiv.hDiv ↑m ↑n) p)) (HMul.hMul p (HDiv.hDiv ↑(Min.min (HMod.hMod m n) (HSub.hSub n (HMod.hMod m n))) ↑n))","decl":"theorem norm_div_natCast {m n : ℕ} :\n    ‖(↑(↑m / ↑n * p) : AddCircle p)‖ = p * (↑(min (m % n) (n - m % n)) / n) := by\n  have : p⁻¹ * (↑m / ↑n * p) = ↑m / ↑n := by rw [mul_comm _ p, inv_mul_cancel_left₀ hp.out.ne.symm]\n  rw [norm_eq' p hp.out, this, abs_sub_round_div_natCast_eq]\n\n"}
{"name":"AddCircle.exists_norm_eq_of_isOfFinAddOrder","module":"Mathlib.Analysis.Normed.Group.AddCircle","initialProofState":"p : Real\nhp : Fact (LT.lt 0 p)\nu : AddCircle p\nhu : IsOfFinAddOrder u\n⊢ Exists fun k => Eq (Norm.norm u) (HMul.hMul p (HDiv.hDiv ↑k ↑(addOrderOf u)))","decl":"theorem exists_norm_eq_of_isOfFinAddOrder {u : AddCircle p} (hu : IsOfFinAddOrder u) :\n    ∃ k : ℕ, ‖u‖ = p * (k / addOrderOf u) := by\n  let n := addOrderOf u\n  change ∃ k : ℕ, ‖u‖ = p * (k / n)\n  obtain ⟨m, -, -, hm⟩ := exists_gcd_eq_one_of_isOfFinAddOrder hu\n  refine ⟨min (m % n) (n - m % n), ?_⟩\n  rw [← hm, norm_div_natCast]\n\n"}
{"name":"AddCircle.le_add_order_smul_norm_of_isOfFinAddOrder","module":"Mathlib.Analysis.Normed.Group.AddCircle","initialProofState":"p : Real\nhp : Fact (LT.lt 0 p)\nu : AddCircle p\nhu : IsOfFinAddOrder u\nhu' : Ne u 0\n⊢ LE.le p (HSMul.hSMul (addOrderOf u) (Norm.norm u))","decl":"theorem le_add_order_smul_norm_of_isOfFinAddOrder {u : AddCircle p} (hu : IsOfFinAddOrder u)\n    (hu' : u ≠ 0) : p ≤ addOrderOf u • ‖u‖ := by\n  obtain ⟨n, hn⟩ := exists_norm_eq_of_isOfFinAddOrder hu\n  replace hu : (addOrderOf u : ℝ) ≠ 0 := by\n    norm_cast\n    exact (addOrderOf_pos_iff.mpr hu).ne'\n  conv_lhs => rw [← mul_one p]\n  rw [hn, nsmul_eq_mul, ← mul_assoc, mul_comm _ p, mul_assoc, mul_div_cancel₀ _ hu,\n    mul_le_mul_left hp.out, Nat.one_le_cast, Nat.one_le_iff_ne_zero]\n  contrapose! hu'\n  simpa only [hu', Nat.cast_zero, zero_div, mul_zero, norm_eq_zero] using hn\n\n"}
{"name":"UnitAddCircle.norm_eq","module":"Mathlib.Analysis.Normed.Group.AddCircle","initialProofState":"x : Real\n⊢ Eq (Norm.norm ↑x) (abs (HSub.hSub x ↑(round x)))","decl":"theorem norm_eq {x : ℝ} : ‖(x : UnitAddCircle)‖ = |x - round x| := by simp [AddCircle.norm_eq]\n\n"}
