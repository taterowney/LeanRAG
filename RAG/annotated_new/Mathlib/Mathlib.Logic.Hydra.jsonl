{"name":"Relation.cutExpand_le_invImage_lex","module":"Mathlib.Logic.Hydra","initialProofState":"α : Type u_1\nr : α → α → Prop\ninst✝¹ : DecidableEq α\ninst✝ : IsIrrefl α r\n⊢ LE.le (Relation.CutExpand r) (InvImage (Finsupp.Lex (Min.min (HasCompl.compl r) fun x1 x2 => Ne x1 x2) fun x1 x2 => LT.lt x1 x2) ⇑Multiset.toFinsupp)","decl":"theorem cutExpand_le_invImage_lex [DecidableEq α] [IsIrrefl α r] :\n    CutExpand r ≤ InvImage (Finsupp.Lex (rᶜ ⊓ (· ≠ ·)) (· < ·)) toFinsupp := by\n  rintro s t ⟨u, a, hr, he⟩\n  replace hr := fun a' ↦ mt (hr a')\n  classical\n  refine ⟨a, fun b h ↦ ?_, ?_⟩ <;> simp_rw [toFinsupp_apply]\n  · apply_fun count b at he\n    simpa only [count_add, count_singleton, if_neg h.2, add_zero, count_eq_zero.2 (hr b h.1)]\n      using he\n  · apply_fun count a at he\n    simp only [count_add, count_singleton_self, count_eq_zero.2 (hr _ (irrefl_of r a)),\n      add_zero] at he\n    exact he ▸ Nat.lt_succ_self _\n\n"}
{"name":"Relation.cutExpand_singleton","module":"Mathlib.Logic.Hydra","initialProofState":"α : Type u_1\nr : α → α → Prop\ns : Multiset α\nx : α\nh : ∀ (x' : α), Membership.mem s x' → r x' x\n⊢ Relation.CutExpand r s (Singleton.singleton x)","decl":"theorem cutExpand_singleton {s x} (h : ∀ x' ∈ s, r x' x) : CutExpand r s {x} :=\n  ⟨s, x, h, add_comm s _⟩\n\n"}
{"name":"Relation.cutExpand_singleton_singleton","module":"Mathlib.Logic.Hydra","initialProofState":"α : Type u_1\nr : α → α → Prop\nx' x : α\nh : r x' x\n⊢ Relation.CutExpand r (Singleton.singleton x') (Singleton.singleton x)","decl":"theorem cutExpand_singleton_singleton {x' x} (h : r x' x) : CutExpand r {x'} {x} :=\n  cutExpand_singleton fun a h ↦ by rwa [mem_singleton.1 h]\n\n"}
{"name":"Relation.cutExpand_add_left","module":"Mathlib.Logic.Hydra","initialProofState":"α : Type u_1\nr : α → α → Prop\nt u s : Multiset α\n⊢ Iff (Relation.CutExpand r (HAdd.hAdd s t) (HAdd.hAdd s u)) (Relation.CutExpand r t u)","decl":"theorem cutExpand_add_left {t u} (s) : CutExpand r (s + t) (s + u) ↔ CutExpand r t u :=\n  exists₂_congr fun _ _ ↦ and_congr Iff.rfl <| by rw [add_assoc, add_assoc, add_left_cancel_iff]\n\n"}
{"name":"Relation.cutExpand_add_right","module":"Mathlib.Logic.Hydra","initialProofState":"α : Type u_1\nr : α → α → Prop\ns' s t : Multiset α\n⊢ Iff (Relation.CutExpand r (HAdd.hAdd s' t) (HAdd.hAdd s t)) (Relation.CutExpand r s' s)","decl":"lemma cutExpand_add_right {s' s} (t) : CutExpand r (s' + t) (s + t) ↔ CutExpand r s' s := by\n  convert cutExpand_add_left t using 2 <;> apply add_comm\n\n"}
{"name":"Relation.cutExpand_iff","module":"Mathlib.Logic.Hydra","initialProofState":"α : Type u_1\nr : α → α → Prop\ninst✝¹ : DecidableEq α\ninst✝ : IsIrrefl α r\ns' s : Multiset α\n⊢ Iff (Relation.CutExpand r s' s) (Exists fun t => Exists fun a => And (∀ (a' : α), Membership.mem t a' → r a' a) (And (Membership.mem s a) (Eq s' (HAdd.hAdd (s.erase a) t))))","decl":"theorem cutExpand_iff [DecidableEq α] [IsIrrefl α r] {s' s : Multiset α} :\n    CutExpand r s' s ↔\n      ∃ (t : Multiset α) (a : α), (∀ a' ∈ t, r a' a) ∧ a ∈ s ∧ s' = s.erase a + t := by\n  simp_rw [CutExpand, add_singleton_eq_iff]\n  refine exists₂_congr fun t a ↦ ⟨?_, ?_⟩\n  · rintro ⟨ht, ha, rfl⟩\n    obtain h | h := mem_add.1 ha\n    exacts [⟨ht, h, erase_add_left_pos t h⟩, (@irrefl α r _ a (ht a h)).elim]\n  · rintro ⟨ht, h, rfl⟩\n    exact ⟨ht, mem_add.2 (Or.inl h), (erase_add_left_pos t h).symm⟩\n\n"}
{"name":"Relation.not_cutExpand_zero","module":"Mathlib.Logic.Hydra","initialProofState":"α : Type u_1\nr : α → α → Prop\ninst✝ : IsIrrefl α r\ns : Multiset α\n⊢ Not (Relation.CutExpand r s 0)","decl":"theorem not_cutExpand_zero [IsIrrefl α r] (s) : ¬CutExpand r s 0 := by\n  classical\n  rw [cutExpand_iff]\n  rintro ⟨_, _, _, ⟨⟩, _⟩\n\n"}
{"name":"Relation.cutExpand_zero","module":"Mathlib.Logic.Hydra","initialProofState":"α : Type u_1\nr : α → α → Prop\nx : α\n⊢ Relation.CutExpand r 0 (Singleton.singleton x)","decl":"lemma cutExpand_zero {x} : CutExpand r 0 {x} := ⟨0, x, nofun, add_comm 0 _⟩\n\n"}
{"name":"Relation.cutExpand_fibration","module":"Mathlib.Logic.Hydra","initialProofState":"α : Type u_1\nr : α → α → Prop\n⊢ Relation.Fibration (Prod.GameAdd (Relation.CutExpand r) (Relation.CutExpand r)) (Relation.CutExpand r) fun s => HAdd.hAdd s.1 s.2","decl":"/-- For any relation `r` on `α`, multiset addition `Multiset α × Multiset α → Multiset α` is a\n  fibration between the game sum of `CutExpand r` with itself and `CutExpand r` itself. -/\ntheorem cutExpand_fibration (r : α → α → Prop) :\n    Fibration (GameAdd (CutExpand r) (CutExpand r)) (CutExpand r) fun s ↦ s.1 + s.2 := by\n  rintro ⟨s₁, s₂⟩ s ⟨t, a, hr, he⟩; dsimp at he ⊢\n  classical\n  obtain ⟨ha, rfl⟩ := add_singleton_eq_iff.1 he\n  rw [add_assoc, mem_add] at ha\n  obtain h | h := ha\n  · refine ⟨(s₁.erase a + t, s₂), GameAdd.fst ⟨t, a, hr, ?_⟩, ?_⟩\n    · rw [add_comm, ← add_assoc, singleton_add, cons_erase h]\n    · rw [add_assoc s₁, erase_add_left_pos _ h, add_right_comm, add_assoc]\n  · refine ⟨(s₁, (s₂ + t).erase a), GameAdd.snd ⟨t, a, hr, ?_⟩, ?_⟩\n    · rw [add_comm, singleton_add, cons_erase h]\n    · rw [add_assoc, erase_add_right_pos _ h]\n\n"}
{"name":"Relation.cutExpand_closed","module":"Mathlib.Logic.Hydra","initialProofState":"α : Type u_1\nr : α → α → Prop\ninst✝ : IsIrrefl α r\np : α → Prop\nh : ∀ {a' a : α}, r a' a → p a → p a'\ns' s : Multiset α\na✝² : Relation.CutExpand r s' s\na✝¹ : ∀ (a : α), Membership.mem s a → p a\na : α\na✝ : Membership.mem s' a\n⊢ p a","decl":"/-- `CutExpand` preserves leftward-closedness under a relation. -/\nlemma cutExpand_closed [IsIrrefl α r] (p : α → Prop)\n    (h : ∀ {a' a}, r a' a → p a → p a') :\n    ∀ {s' s}, CutExpand r s' s → (∀ a ∈ s, p a) → ∀ a ∈ s', p a := by\n  intros s' s\n  classical\n  rw [cutExpand_iff]\n  rintro ⟨t, a, hr, ha, rfl⟩ hsp a' h'\n  obtain (h'|h') := mem_add.1 h'\n  exacts [hsp a' (mem_of_mem_erase h'), h (hr a' h') (hsp a ha)]\n\n"}
{"name":"Relation.cutExpand_double","module":"Mathlib.Logic.Hydra","initialProofState":"α : Type u_1\nr : α → α → Prop\na a₁ a₂ : α\nh₁ : r a₁ a\nh₂ : r a₂ a\n⊢ Relation.CutExpand r (Insert.insert a₁ (Singleton.singleton a₂)) (Singleton.singleton a)","decl":"lemma cutExpand_double {a a₁ a₂} (h₁ : r a₁ a) (h₂ : r a₂ a) : CutExpand r {a₁, a₂} {a} :=\n  cutExpand_singleton <| by\n    simp only [insert_eq_cons, mem_cons, mem_singleton, forall_eq_or_imp, forall_eq]\n    tauto\n\n"}
{"name":"Relation.cutExpand_pair_left","module":"Mathlib.Logic.Hydra","initialProofState":"α : Type u_1\nr : α → α → Prop\na' a b : α\nhr : r a' a\n⊢ Relation.CutExpand r (Insert.insert a' (Singleton.singleton b)) (Insert.insert a (Singleton.singleton b))","decl":"lemma cutExpand_pair_left {a' a b} (hr : r a' a) : CutExpand r {a', b} {a, b} :=\n  (cutExpand_add_right {b}).2 (cutExpand_singleton_singleton hr)\n\n"}
{"name":"Relation.cutExpand_pair_right","module":"Mathlib.Logic.Hydra","initialProofState":"α : Type u_1\nr : α → α → Prop\na b' b : α\nhr : r b' b\n⊢ Relation.CutExpand r (Insert.insert a (Singleton.singleton b')) (Insert.insert a (Singleton.singleton b))","decl":"lemma cutExpand_pair_right {a b' b} (hr : r b' b) : CutExpand r {a, b'} {a, b} :=\n  (cutExpand_add_left {a}).2 (cutExpand_singleton_singleton hr)\n\n"}
{"name":"Relation.cutExpand_double_left","module":"Mathlib.Logic.Hydra","initialProofState":"α : Type u_1\nr : α → α → Prop\na a₁ a₂ b : α\nh₁ : r a₁ a\nh₂ : r a₂ a\n⊢ Relation.CutExpand r (Insert.insert a₁ (Insert.insert a₂ (Singleton.singleton b))) (Insert.insert a (Singleton.singleton b))","decl":"lemma cutExpand_double_left {a a₁ a₂ b} (h₁ : r a₁ a) (h₂ : r a₂ a) :\n    CutExpand r {a₁, a₂, b} {a, b} :=\n  (cutExpand_add_right {b}).2 (cutExpand_double h₁ h₂)\n\n"}
{"name":"Relation.acc_of_singleton","module":"Mathlib.Logic.Hydra","initialProofState":"α : Type u_1\nr : α → α → Prop\ninst✝ : IsIrrefl α r\ns : Multiset α\nhs : ∀ (a : α), Membership.mem s a → Acc (Relation.CutExpand r) (Singleton.singleton a)\n⊢ Acc (Relation.CutExpand r) s","decl":"/-- A multiset is accessible under `CutExpand` if all its singleton subsets are,\n  assuming `r` is irreflexive. -/\ntheorem acc_of_singleton [IsIrrefl α r] {s : Multiset α} (hs : ∀ a ∈ s, Acc (CutExpand r) {a}) :\n    Acc (CutExpand r) s := by\n  induction s using Multiset.induction with\n  | empty => exact Acc.intro 0 fun s h ↦ (not_cutExpand_zero s h).elim\n  | cons a s ihs =>\n    rw [← s.singleton_add a]\n    rw [forall_mem_cons] at hs\n    exact (hs.1.prod_gameAdd <| ihs fun a ha ↦ hs.2 a ha).of_fibration _ (cutExpand_fibration r)\n\n"}
{"name":"Acc.cutExpand","module":"Mathlib.Logic.Hydra","initialProofState":"α : Type u_1\nr : α → α → Prop\ninst✝ : IsIrrefl α r\na : α\nhacc : Acc r a\n⊢ Acc (Relation.CutExpand r) (Singleton.singleton a)","decl":"/-- A singleton `{a}` is accessible under `CutExpand r` if `a` is accessible under `r`,\n  assuming `r` is irreflexive. -/\ntheorem _root_.Acc.cutExpand [IsIrrefl α r] {a : α} (hacc : Acc r a) : Acc (CutExpand r) {a} := by\n  induction' hacc with a h ih\n  refine Acc.intro _ fun s ↦ ?_\n  classical\n  simp only [cutExpand_iff, mem_singleton]\n  rintro ⟨t, a, hr, rfl, rfl⟩\n  refine acc_of_singleton fun a' ↦ ?_\n  rw [erase_singleton, zero_add]\n  exact ih a' ∘ hr a'\n\n"}
{"name":"WellFounded.cutExpand","module":"Mathlib.Logic.Hydra","initialProofState":"α : Type u_1\nr : α → α → Prop\nhr : WellFounded r\n⊢ WellFounded (Relation.CutExpand r)","decl":"/-- `CutExpand r` is well-founded when `r` is. -/\ntheorem _root_.WellFounded.cutExpand (hr : WellFounded r) : WellFounded (CutExpand r) :=\n  ⟨have := hr.isIrrefl; fun _ ↦ acc_of_singleton fun a _ ↦ (hr.apply a).cutExpand⟩\n\n"}
