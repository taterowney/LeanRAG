{"name":"IsVisible.rfl","module":"Mathlib.Analysis.Convex.Visible","initialProofState":"ğ•œ : Type u_1\nV : Type u_2\nP : Type u_3\ninstâœÂ³ : LinearOrderedField ğ•œ\ninstâœÂ² : AddCommGroup V\ninstâœÂ¹ : Module ğ•œ V\ninstâœ : AddTorsor V P\ns : Set P\nx : P\nâŠ¢ IsVisible ğ•œ s x x","decl":"@[simp, refl] lemma IsVisible.rfl : IsVisible ğ•œ s x x := by simp [IsVisible]\n\n"}
{"name":"isVisible_comm","module":"Mathlib.Analysis.Convex.Visible","initialProofState":"ğ•œ : Type u_1\nV : Type u_2\nP : Type u_3\ninstâœÂ³ : LinearOrderedField ğ•œ\ninstâœÂ² : AddCommGroup V\ninstâœÂ¹ : Module ğ•œ V\ninstâœ : AddTorsor V P\ns : Set P\nx y : P\nâŠ¢ Iff (IsVisible ğ•œ s x y) (IsVisible ğ•œ s y x)","decl":"lemma isVisible_comm : IsVisible ğ•œ s x y â†” IsVisible ğ•œ s y x := by simp [IsVisible, sbtw_comm]\n\n"}
{"name":"IsVisible.symm","module":"Mathlib.Analysis.Convex.Visible","initialProofState":"ğ•œ : Type u_1\nV : Type u_2\nP : Type u_3\ninstâœÂ³ : LinearOrderedField ğ•œ\ninstâœÂ² : AddCommGroup V\ninstâœÂ¹ : Module ğ•œ V\ninstâœ : AddTorsor V P\ns : Set P\nx y : P\naâœ : IsVisible ğ•œ s x y\nâŠ¢ IsVisible ğ•œ s y x","decl":"@[symm] alias âŸ¨IsVisible.symm, _âŸ© := isVisible_comm\n\n"}
{"name":"IsVisible.mono","module":"Mathlib.Analysis.Convex.Visible","initialProofState":"ğ•œ : Type u_1\nV : Type u_2\nP : Type u_3\ninstâœÂ³ : LinearOrderedField ğ•œ\ninstâœÂ² : AddCommGroup V\ninstâœÂ¹ : Module ğ•œ V\ninstâœ : AddTorsor V P\ns t : Set P\nx y : P\nhst : HasSubset.Subset s t\nht : IsVisible ğ•œ t x y\nâŠ¢ IsVisible ğ•œ s x y","decl":"lemma IsVisible.mono (hst : s âŠ† t) (ht : IsVisible ğ•œ t x y) : IsVisible ğ•œ s x y :=\n  fun _z hz â†¦ ht <| hst hz\n\n"}
{"name":"isVisible_iff_lineMap","module":"Mathlib.Analysis.Convex.Visible","initialProofState":"ğ•œ : Type u_1\nV : Type u_2\nP : Type u_3\ninstâœÂ³ : LinearOrderedField ğ•œ\ninstâœÂ² : AddCommGroup V\ninstâœÂ¹ : Module ğ•œ V\ninstâœ : AddTorsor V P\ns : Set P\nx y : P\nhxy : Ne x y\nâŠ¢ Iff (IsVisible ğ•œ s x y) (âˆ€ (Î´ : ğ•œ), Membership.mem (Set.Ioo 0 1) Î´ â†’ Not (Membership.mem s ((AffineMap.lineMap x y) Î´)))","decl":"lemma isVisible_iff_lineMap (hxy : x â‰  y) :\n    IsVisible ğ•œ s x y â†” âˆ€ Î´ âˆˆ Set.Ioo (0 : ğ•œ) 1, lineMap x y Î´ âˆ‰ s := by\n  simp [IsVisible, sbtw_iff_mem_image_Ioo_and_ne, hxy]\n  aesop\n\n"}
{"name":"IsVisible.of_convexHull_of_pos","module":"Mathlib.Analysis.Convex.Visible","initialProofState":"ğ•œ : Type u_1\nV : Type u_2\ninstâœÂ² : LinearOrderedField ğ•œ\ninstâœÂ¹ : AddCommGroup V\ninstâœ : Module ğ•œ V\ns : Set V\nx : V\nÎ¹ : Type u_4\nt : Finset Î¹\na : Î¹ â†’ V\nw : Î¹ â†’ ğ•œ\nhwâ‚€ : âˆ€ (i : Î¹), Membership.mem t i â†’ LE.le 0 (w i)\nhwâ‚ : Eq (t.sum fun i => w i) 1\nha : âˆ€ (i : Î¹), Membership.mem t i â†’ Membership.mem s (a i)\nhx : Not (Membership.mem ((convexHull ğ•œ) s) x)\nhw : IsVisible ğ•œ ((convexHull ğ•œ) s) x (t.sum fun i => HSMul.hSMul (w i) (a i))\ni : Î¹\nhi : Membership.mem t i\nhwi : LT.lt 0 (w i)\nâŠ¢ IsVisible ğ•œ ((convexHull ğ•œ) s) x (a i)","decl":"/-- If a point `x` sees a convex combination of points of a set `s` through `convexHull â„ s âˆŒ x`,\nthen it sees all terms of that combination.\n\nNote that the converse does not hold. -/\nlemma IsVisible.of_convexHull_of_pos {Î¹ : Type*} {t : Finset Î¹} {a : Î¹ â†’ V} {w : Î¹ â†’ ğ•œ}\n    (hwâ‚€ : âˆ€ i âˆˆ t, 0 â‰¤ w i) (hwâ‚ : âˆ‘ i âˆˆ t, w i = 1) (ha : âˆ€ i âˆˆ t, a i âˆˆ s)\n    (hx : x âˆ‰ convexHull ğ•œ s) (hw : IsVisible ğ•œ (convexHull ğ•œ s) x (âˆ‘ i âˆˆ t, w i â€¢ a i)) {i : Î¹}\n    (hi : i âˆˆ t) (hwi : 0 < w i) : IsVisible ğ•œ (convexHull ğ•œ s) x (a i) := by\n  classical\n  obtain hwi | hwi : w i = 1 âˆ¨ w i < 1 := eq_or_lt_of_le <| (single_le_sum hwâ‚€ hi).trans_eq hwâ‚\n  Â· convert hw\n    rw [â† one_smul ğ•œ (a i), â† hwi, eq_comm]\n    rw [â† hwi, â† sub_eq_zero, â† sum_erase_eq_sub hi,\n      sum_eq_zero_iff_of_nonneg fun j hj â†¦ hwâ‚€ _ <| erase_subset _ _ hj] at hwâ‚\n    refine sum_eq_single _ (fun j hj hji â†¦ ?_) (by simp [hi])\n    rw [hwâ‚ _ <| mem_erase.2 âŸ¨hji, hjâŸ©, zero_smul]\n  rintro _ hÎµ âŸ¨âŸ¨Îµ, âŸ¨hÎµâ‚€, hÎµâ‚âŸ©, rflâŸ©, hâŸ©\n  replace hÎµâ‚€ : 0 < Îµ := hÎµâ‚€.lt_of_ne <| by rintro rfl; simp at h\n  replace hÎµâ‚ : Îµ < 1 := hÎµâ‚.lt_of_ne <| by rintro rfl; simp at h\n  have : 0 < 1 - Îµ := by linarith\n  have hwi : 0 < 1 - w i := by linarith\n  refine hw (z := lineMap x (âˆ‘ j âˆˆ t, w j â€¢ a j) ((w i)â»Â¹ / ((1 - Îµ) / Îµ + (w i)â»Â¹)))\n    ?_ <| sbtw_lineMap_iff.2 âŸ¨(ne_of_mem_of_not_mem ((convex_convexHull ..).sum_mem hwâ‚€ hwâ‚\n    fun i hi â†¦ subset_convexHull _ _ <| ha _ hi) hx).symm, by positivity,\n    (div_lt_one <| by positivity).2 ?_âŸ©\n  Â· have : Wbtw ğ•œ\n      (lineMap x (a i) Îµ)\n      (lineMap x (âˆ‘ j âˆˆ t, w j â€¢ a j) ((w i)â»Â¹ / ((1 - Îµ) / Îµ + (w i)â»Â¹)))\n      (âˆ‘ j âˆˆ t.erase i, (w j / (1 - w i)) â€¢ a j) := by\n      refine âŸ¨((1 - w i) / w i) / ((1 - Îµ) / Îµ + (1 - w i) / w i + 1), âŸ¨by positivity, ?_âŸ©, ?_âŸ©\n      Â· refine (div_le_one <| by positivity).2 ?_\n        calc\n          (1 - w i) / w i = 0 + (1 - w i) / w i + 0 := by simp\n          _ â‰¤ (1 - Îµ) / Îµ + (1 - w i) / w i + 1 := by gcongr <;> positivity\n      have :\n        w i â€¢ a i + (1 - w i) â€¢ âˆ‘ j âˆˆ t.erase i, (w j / (1 - w i)) â€¢ a j = âˆ‘ j âˆˆ t, w j â€¢ a j := by\n        rw [smul_sum]\n        simp_rw [smul_smul, mul_div_cancelâ‚€ _ hwi.ne']\n        exact add_sum_erase _ (fun i â†¦ w i â€¢ a i) hi\n      simp_rw [lineMap_apply_module, â† this, smul_add, smul_smul]\n      match_scalars <;> field_simp <;> ring\n    refine (convex_convexHull _ _).mem_of_wbtw this hÎµ <| (convex_convexHull _ _).sum_mem ?_ ?_ ?_\n    Â· intros j hj\n      have := hwâ‚€ j <| erase_subset _ _ hj\n      positivity\n    Â· rw [â† sum_div, sum_erase_eq_sub hi, hwâ‚, div_self hwi.ne']\n    Â· exact fun j hj â†¦ subset_convexHull _ _ <| ha _ <| erase_subset _ _ hj\n  Â· exact lt_add_of_pos_left _ <| by positivity\n\n"}
{"name":"IsVisible.eq_of_mem_interior","module":"Mathlib.Analysis.Convex.Visible","initialProofState":"ğ•œ : Type u_1\nV : Type u_2\ninstâœâ· : LinearOrderedField ğ•œ\ninstâœâ¶ : AddCommGroup V\ninstâœâµ : Module ğ•œ V\ns : Set V\nx y : V\ninstâœâ´ : TopologicalSpace ğ•œ\ninstâœÂ³ : OrderTopology ğ•œ\ninstâœÂ² : TopologicalSpace V\ninstâœÂ¹ : TopologicalAddGroup V\ninstâœ : ContinuousSMul ğ•œ V\nhsxy : IsVisible ğ•œ s x y\nhy : Membership.mem (interior s) y\nâŠ¢ Eq x y","decl":"/-- One cannot see any point in the interior of a set. -/\nlemma IsVisible.eq_of_mem_interior (hsxy : IsVisible ğ•œ s x y) (hy : y âˆˆ interior s) :\n    x = y := by\n  by_contra! hxy\n  suffices h : âˆ€á¶  (_Î´ : ğ•œ) in ğ“[>] 0, False by obtain âŸ¨_, âŸ¨âŸ©âŸ© := h.exists\n  have hmem : âˆ€á¶  (Î´ : ğ•œ) in ğ“[>] 0, lineMap y x Î´ âˆˆ s :=\n    lineMap_continuous.continuousWithinAt.eventually_mem\n      (by simpa using mem_interior_iff_mem_nhds.1 hy)\n  filter_upwards [hmem, Ioo_mem_nhdsGT zero_lt_one] with Î´ hmem hsbt using hsxy.symm hmem (by aesop)\n\n"}
{"name":"IsOpen.eq_of_isVisible_of_left_mem","module":"Mathlib.Analysis.Convex.Visible","initialProofState":"ğ•œ : Type u_1\nV : Type u_2\ninstâœâ· : LinearOrderedField ğ•œ\ninstâœâ¶ : AddCommGroup V\ninstâœâµ : Module ğ•œ V\ns : Set V\nx y : V\ninstâœâ´ : TopologicalSpace ğ•œ\ninstâœÂ³ : OrderTopology ğ•œ\ninstâœÂ² : TopologicalSpace V\ninstâœÂ¹ : TopologicalAddGroup V\ninstâœ : ContinuousSMul ğ•œ V\nhs : IsOpen s\nhsxy : IsVisible ğ•œ s x y\nhy : Membership.mem s y\nâŠ¢ Eq x y","decl":"/-- One cannot see any point of an open set. -/\nlemma IsOpen.eq_of_isVisible_of_left_mem (hs : IsOpen s) (hsxy : IsVisible ğ•œ s x y) (hy : y âˆˆ s) :\n    x = y :=\n  hsxy.eq_of_mem_interior (by simpa [hs.interior_eq])\n\n"}
{"name":"IsVisible.mem_convexHull_isVisible","module":"Mathlib.Analysis.Convex.Visible","initialProofState":"V : Type u_2\ninstâœÂ¹ : AddCommGroup V\ninstâœ : Module Real V\ns : Set V\nx y : V\nhx : Not (Membership.mem ((convexHull Real) s) x)\nhy : Membership.mem ((convexHull Real) s) y\nhxy : IsVisible Real ((convexHull Real) s) x y\nâŠ¢ Membership.mem ((convexHull Real) (setOf fun z => And (Membership.mem s z) (IsVisible Real ((convexHull Real) s) x z))) y","decl":"/-- All points of the convex hull of a set `s` visible from a point `x âˆ‰ convexHull â„ s` lie in the\nconvex hull of such points that actually lie in `s`.\n\nNote that the converse does not hold. -/\nlemma IsVisible.mem_convexHull_isVisible (hx : x âˆ‰ convexHull â„ s) (hy : y âˆˆ convexHull â„ s)\n    (hxy : IsVisible â„ (convexHull â„ s) x y) :\n    y âˆˆ convexHull â„ {z âˆˆ s | IsVisible â„ (convexHull â„ s) x z} := by\n  classical\n  obtain âŸ¨Î¹, _, w, a, hwâ‚€, hwâ‚, ha, rflâŸ© := mem_convexHull_iff_exists_fintype.1 hy\n  rw [â† Fintype.sum_subset (s := {i | w i â‰  0})\n    fun i hi â†¦ mem_filter.2 âŸ¨mem_univ _, left_ne_zero_of_smul hiâŸ©]\n  exact (convex_convexHull ..).sum_mem (fun i _ â†¦ hwâ‚€ _) (by rwa [sum_filter_ne_zero])\n    fun i hi â†¦ subset_convexHull _ _ âŸ¨ha _, IsVisible.of_convexHull_of_pos (fun _ _ â†¦ hwâ‚€ _) hwâ‚\n      (by simpa) hx hxy (mem_univ _) <| (hwâ‚€ _).lt_of_ne' (mem_filter.1 hi).2âŸ©\n\n"}
{"name":"IsClosed.exists_wbtw_isVisible","module":"Mathlib.Analysis.Convex.Visible","initialProofState":"V : Type u_2\ninstâœâ´ : AddCommGroup V\ninstâœÂ³ : Module Real V\ns : Set V\ny : V\ninstâœÂ² : TopologicalSpace V\ninstâœÂ¹ : TopologicalAddGroup V\ninstâœ : ContinuousSMul Real V\nhs : IsClosed s\nhy : Membership.mem s y\nx : V\nâŠ¢ Exists fun z => And (Membership.mem s z) (And (Wbtw Real x z y) (IsVisible Real s x z))","decl":"/-- If `s` is a closed set, then any point `x` sees some point of `s` in any direction where there\nis something to see. -/\nlemma IsClosed.exists_wbtw_isVisible (hs : IsClosed s) (hy : y âˆˆ s) (x : V) :\n    âˆƒ z âˆˆ s, Wbtw â„ x z y âˆ§ IsVisible â„ s x z := by\n  let t : Set â„ := Ici 0 âˆ© lineMap x y â»Â¹' s\n  have htâ‚ : 1 âˆˆ t := by simpa [t]\n  have ht : BddBelow t := bddBelow_Ici.inter_of_left\n  let Î´ : â„ := sInf t\n  have hÎ´â‚ : Î´ â‰¤ 1 := csInf_le ht htâ‚\n  obtain âŸ¨hÎ´â‚€, hÎ´âŸ© : 0 â‰¤ Î´ âˆ§ lineMap x y Î´ âˆˆ s :=\n    (isClosed_Ici.inter <| hs.preimage lineMap_continuous).csInf_mem âŸ¨1, htâ‚âŸ© ht\n  refine âŸ¨lineMap x y Î´, hÎ´, wbtw_lineMap_iff.2 <| .inr âŸ¨hÎ´â‚€, hÎ´â‚âŸ©, ?_âŸ©\n  rintro _ hÎµ âŸ¨âŸ¨Îµ, âŸ¨hÎµâ‚€, hÎµâ‚âŸ©, rflâŸ©, -, hâŸ©\n  replace hÎ´â‚€ : 0 < Î´ := hÎ´â‚€.lt_of_ne' <| by rintro hÎ´â‚€; simp [hÎ´â‚€] at h\n  replace hÎµâ‚ : Îµ < 1 := hÎµâ‚.lt_of_ne <| by rintro rfl; simp at h\n  rw [lineMap_lineMap_right] at hÎµ\n  exact (csInf_le ht âŸ¨mul_nonneg hÎµâ‚€ hÎ´â‚€.le, hÎµâŸ©).not_lt <| mul_lt_of_lt_one_left hÎ´â‚€ hÎµâ‚\n\n-- TODO: Once we have cone hulls, the RHS can be strengthened to\n-- `coneHull â„ x {y âˆˆ s | IsVisible â„ (convexHull â„ s) x y}`\n"}
{"name":"IsClosed.convexHull_subset_affineSpan_isVisible","module":"Mathlib.Analysis.Convex.Visible","initialProofState":"V : Type u_2\ninstâœâ´ : AddCommGroup V\ninstâœÂ³ : Module Real V\ns : Set V\nx : V\ninstâœÂ² : TopologicalSpace V\ninstâœÂ¹ : TopologicalAddGroup V\ninstâœ : ContinuousSMul Real V\nhs : IsClosed ((convexHull Real) s)\nhx : Not (Membership.mem ((convexHull Real) s) x)\nâŠ¢ HasSubset.Subset ((convexHull Real) s) â†‘(affineSpan Real (Union.union (Singleton.singleton x) (setOf fun y => And (Membership.mem s y) (IsVisible Real ((convexHull Real) s) x y))))","decl":"/-- A set whose convex hull is closed lies in the cone based at a point `x` generated by its points\nvisible from `x` through its convex hull. -/\nlemma IsClosed.convexHull_subset_affineSpan_isVisible (hs : IsClosed (convexHull â„ s))\n    (hx : x âˆ‰ convexHull â„ s) :\n    convexHull â„ s âŠ† affineSpan â„ ({x} âˆª {y âˆˆ s | IsVisible â„ (convexHull â„ s) x y}) := by\n  rintro y hy\n  obtain âŸ¨z, hz, hxzy, hxzâŸ© := hs.exists_wbtw_isVisible hy x\n  -- TODO: `calc` doesn't work with `âˆˆ` :(\n  exact AffineSubspace.right_mem_of_wbtw hxzy (subset_affineSpan _ _ <| subset_union_left rfl)\n    (affineSpan_mono _ subset_union_right <| convexHull_subset_affineSpan _ <|\n      hxz.mem_convexHull_isVisible hx hz) (ne_of_mem_of_not_mem hz hx).symm\n\n"}
{"name":"rank_le_card_isVisible","module":"Mathlib.Analysis.Convex.Visible","initialProofState":"V : Type u_2\ninstâœâ´ : AddCommGroup V\ninstâœÂ³ : Module Real V\ns : Set V\nx : V\ninstâœÂ² : TopologicalSpace V\ninstâœÂ¹ : TopologicalAddGroup V\ninstâœ : ContinuousSMul Real V\nhs : IsClosed ((convexHull Real) s)\nhx : Not (Membership.mem ((convexHull Real) s) x)\nâŠ¢ LE.le (Module.rank Real (Subtype fun x_1 => Membership.mem (Submodule.span Real (HVAdd.hVAdd (Neg.neg x) s)) x_1)) (Cardinal.mk â†‘(setOf fun y => And (Membership.mem s y) (IsVisible Real ((convexHull Real) s) x y)))","decl":"open Submodule in\n/-- If `s` is a closed set of dimension `d` and `x` is a point outside of its convex hull,\nthen `x` sees at least `d` points of the convex hull of `s` that actually lie in `s`. -/\nlemma rank_le_card_isVisible (hs : IsClosed (convexHull â„ s)) (hx : x âˆ‰ convexHull â„ s) :\n    Module.rank â„ (span â„ (-x +áµ¥ s)) â‰¤ #{y âˆˆ s | IsVisible â„ (convexHull â„ s) x y} := by\n  calc\n    Module.rank â„ (span â„ (-x +áµ¥ s)) â‰¤\n      Module.rank â„ (span â„\n        (-x +áµ¥ affineSpan â„ ({x} âˆª {y âˆˆ s | IsVisible â„ (convexHull â„ s) x y}) : Set V)) := by\n      push_cast\n      refine Submodule.rank_mono ?_\n      gcongr\n      exact (subset_convexHull ..).trans <| hs.convexHull_subset_affineSpan_isVisible hx\n    _ = Module.rank â„ (span â„ (-x +áµ¥ {y âˆˆ s | IsVisible â„ (convexHull â„ s) x y})) := by\n      suffices h :\n        -x +áµ¥ (affineSpan â„ ({x} âˆª {y âˆˆ s | IsVisible â„ (convexHull â„ s) x y}) : Set V) =\n          span â„ (-x +áµ¥ {y âˆˆ s | IsVisible â„ (convexHull â„ s) x y}) by\n        rw [AffineSubspace.coe_pointwise_vadd, h, span_span]\n      simp [â† AffineSubspace.coe_pointwise_vadd, AffineSubspace.pointwise_vadd_span,\n        vadd_set_insert, -coe_affineSpan, affineSpan_insert_zero]\n    _ â‰¤ #(-x +áµ¥ {y âˆˆ s | IsVisible â„ (convexHull â„ s) x y}) := rank_span_le _\n    _ = #{y âˆˆ s | IsVisible â„ (convexHull â„ s) x y} := by simp\n\n"}
