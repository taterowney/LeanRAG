{"name":"IsVisible.rfl","module":"Mathlib.Analysis.Convex.Visible","initialProofState":"𝕜 : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : LinearOrderedField 𝕜\ninst✝² : AddCommGroup V\ninst✝¹ : Module 𝕜 V\ninst✝ : AddTorsor V P\ns : Set P\nx : P\n⊢ IsVisible 𝕜 s x x","decl":"@[simp, refl] lemma IsVisible.rfl : IsVisible 𝕜 s x x := by simp [IsVisible]\n\n"}
{"name":"isVisible_comm","module":"Mathlib.Analysis.Convex.Visible","initialProofState":"𝕜 : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : LinearOrderedField 𝕜\ninst✝² : AddCommGroup V\ninst✝¹ : Module 𝕜 V\ninst✝ : AddTorsor V P\ns : Set P\nx y : P\n⊢ Iff (IsVisible 𝕜 s x y) (IsVisible 𝕜 s y x)","decl":"lemma isVisible_comm : IsVisible 𝕜 s x y ↔ IsVisible 𝕜 s y x := by simp [IsVisible, sbtw_comm]\n\n"}
{"name":"IsVisible.symm","module":"Mathlib.Analysis.Convex.Visible","initialProofState":"𝕜 : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : LinearOrderedField 𝕜\ninst✝² : AddCommGroup V\ninst✝¹ : Module 𝕜 V\ninst✝ : AddTorsor V P\ns : Set P\nx y : P\na✝ : IsVisible 𝕜 s x y\n⊢ IsVisible 𝕜 s y x","decl":"@[symm] alias ⟨IsVisible.symm, _⟩ := isVisible_comm\n\n"}
{"name":"IsVisible.mono","module":"Mathlib.Analysis.Convex.Visible","initialProofState":"𝕜 : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : LinearOrderedField 𝕜\ninst✝² : AddCommGroup V\ninst✝¹ : Module 𝕜 V\ninst✝ : AddTorsor V P\ns t : Set P\nx y : P\nhst : HasSubset.Subset s t\nht : IsVisible 𝕜 t x y\n⊢ IsVisible 𝕜 s x y","decl":"lemma IsVisible.mono (hst : s ⊆ t) (ht : IsVisible 𝕜 t x y) : IsVisible 𝕜 s x y :=\n  fun _z hz ↦ ht <| hst hz\n\n"}
{"name":"isVisible_iff_lineMap","module":"Mathlib.Analysis.Convex.Visible","initialProofState":"𝕜 : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : LinearOrderedField 𝕜\ninst✝² : AddCommGroup V\ninst✝¹ : Module 𝕜 V\ninst✝ : AddTorsor V P\ns : Set P\nx y : P\nhxy : Ne x y\n⊢ Iff (IsVisible 𝕜 s x y) (∀ (δ : 𝕜), Membership.mem (Set.Ioo 0 1) δ → Not (Membership.mem s ((AffineMap.lineMap x y) δ)))","decl":"lemma isVisible_iff_lineMap (hxy : x ≠ y) :\n    IsVisible 𝕜 s x y ↔ ∀ δ ∈ Set.Ioo (0 : 𝕜) 1, lineMap x y δ ∉ s := by\n  simp [IsVisible, sbtw_iff_mem_image_Ioo_and_ne, hxy]\n  aesop\n\n"}
{"name":"IsVisible.of_convexHull_of_pos","module":"Mathlib.Analysis.Convex.Visible","initialProofState":"𝕜 : Type u_1\nV : Type u_2\ninst✝² : LinearOrderedField 𝕜\ninst✝¹ : AddCommGroup V\ninst✝ : Module 𝕜 V\ns : Set V\nx : V\nι : Type u_4\nt : Finset ι\na : ι → V\nw : ι → 𝕜\nhw₀ : ∀ (i : ι), Membership.mem t i → LE.le 0 (w i)\nhw₁ : Eq (t.sum fun i => w i) 1\nha : ∀ (i : ι), Membership.mem t i → Membership.mem s (a i)\nhx : Not (Membership.mem ((convexHull 𝕜) s) x)\nhw : IsVisible 𝕜 ((convexHull 𝕜) s) x (t.sum fun i => HSMul.hSMul (w i) (a i))\ni : ι\nhi : Membership.mem t i\nhwi : LT.lt 0 (w i)\n⊢ IsVisible 𝕜 ((convexHull 𝕜) s) x (a i)","decl":"/-- If a point `x` sees a convex combination of points of a set `s` through `convexHull ℝ s ∌ x`,\nthen it sees all terms of that combination.\n\nNote that the converse does not hold. -/\nlemma IsVisible.of_convexHull_of_pos {ι : Type*} {t : Finset ι} {a : ι → V} {w : ι → 𝕜}\n    (hw₀ : ∀ i ∈ t, 0 ≤ w i) (hw₁ : ∑ i ∈ t, w i = 1) (ha : ∀ i ∈ t, a i ∈ s)\n    (hx : x ∉ convexHull 𝕜 s) (hw : IsVisible 𝕜 (convexHull 𝕜 s) x (∑ i ∈ t, w i • a i)) {i : ι}\n    (hi : i ∈ t) (hwi : 0 < w i) : IsVisible 𝕜 (convexHull 𝕜 s) x (a i) := by\n  classical\n  obtain hwi | hwi : w i = 1 ∨ w i < 1 := eq_or_lt_of_le <| (single_le_sum hw₀ hi).trans_eq hw₁\n  · convert hw\n    rw [← one_smul 𝕜 (a i), ← hwi, eq_comm]\n    rw [← hwi, ← sub_eq_zero, ← sum_erase_eq_sub hi,\n      sum_eq_zero_iff_of_nonneg fun j hj ↦ hw₀ _ <| erase_subset _ _ hj] at hw₁\n    refine sum_eq_single _ (fun j hj hji ↦ ?_) (by simp [hi])\n    rw [hw₁ _ <| mem_erase.2 ⟨hji, hj⟩, zero_smul]\n  rintro _ hε ⟨⟨ε, ⟨hε₀, hε₁⟩, rfl⟩, h⟩\n  replace hε₀ : 0 < ε := hε₀.lt_of_ne <| by rintro rfl; simp at h\n  replace hε₁ : ε < 1 := hε₁.lt_of_ne <| by rintro rfl; simp at h\n  have : 0 < 1 - ε := by linarith\n  have hwi : 0 < 1 - w i := by linarith\n  refine hw (z := lineMap x (∑ j ∈ t, w j • a j) ((w i)⁻¹ / ((1 - ε) / ε + (w i)⁻¹)))\n    ?_ <| sbtw_lineMap_iff.2 ⟨(ne_of_mem_of_not_mem ((convex_convexHull ..).sum_mem hw₀ hw₁\n    fun i hi ↦ subset_convexHull _ _ <| ha _ hi) hx).symm, by positivity,\n    (div_lt_one <| by positivity).2 ?_⟩\n  · have : Wbtw 𝕜\n      (lineMap x (a i) ε)\n      (lineMap x (∑ j ∈ t, w j • a j) ((w i)⁻¹ / ((1 - ε) / ε + (w i)⁻¹)))\n      (∑ j ∈ t.erase i, (w j / (1 - w i)) • a j) := by\n      refine ⟨((1 - w i) / w i) / ((1 - ε) / ε + (1 - w i) / w i + 1), ⟨by positivity, ?_⟩, ?_⟩\n      · refine (div_le_one <| by positivity).2 ?_\n        calc\n          (1 - w i) / w i = 0 + (1 - w i) / w i + 0 := by simp\n          _ ≤ (1 - ε) / ε + (1 - w i) / w i + 1 := by gcongr <;> positivity\n      have :\n        w i • a i + (1 - w i) • ∑ j ∈ t.erase i, (w j / (1 - w i)) • a j = ∑ j ∈ t, w j • a j := by\n        rw [smul_sum]\n        simp_rw [smul_smul, mul_div_cancel₀ _ hwi.ne']\n        exact add_sum_erase _ (fun i ↦ w i • a i) hi\n      simp_rw [lineMap_apply_module, ← this, smul_add, smul_smul]\n      match_scalars <;> field_simp <;> ring\n    refine (convex_convexHull _ _).mem_of_wbtw this hε <| (convex_convexHull _ _).sum_mem ?_ ?_ ?_\n    · intros j hj\n      have := hw₀ j <| erase_subset _ _ hj\n      positivity\n    · rw [← sum_div, sum_erase_eq_sub hi, hw₁, div_self hwi.ne']\n    · exact fun j hj ↦ subset_convexHull _ _ <| ha _ <| erase_subset _ _ hj\n  · exact lt_add_of_pos_left _ <| by positivity\n\n"}
{"name":"IsVisible.eq_of_mem_interior","module":"Mathlib.Analysis.Convex.Visible","initialProofState":"𝕜 : Type u_1\nV : Type u_2\ninst✝⁷ : LinearOrderedField 𝕜\ninst✝⁶ : AddCommGroup V\ninst✝⁵ : Module 𝕜 V\ns : Set V\nx y : V\ninst✝⁴ : TopologicalSpace 𝕜\ninst✝³ : OrderTopology 𝕜\ninst✝² : TopologicalSpace V\ninst✝¹ : TopologicalAddGroup V\ninst✝ : ContinuousSMul 𝕜 V\nhsxy : IsVisible 𝕜 s x y\nhy : Membership.mem (interior s) y\n⊢ Eq x y","decl":"/-- One cannot see any point in the interior of a set. -/\nlemma IsVisible.eq_of_mem_interior (hsxy : IsVisible 𝕜 s x y) (hy : y ∈ interior s) :\n    x = y := by\n  by_contra! hxy\n  suffices h : ∀ᶠ (_δ : 𝕜) in 𝓝[>] 0, False by obtain ⟨_, ⟨⟩⟩ := h.exists\n  have hmem : ∀ᶠ (δ : 𝕜) in 𝓝[>] 0, lineMap y x δ ∈ s :=\n    lineMap_continuous.continuousWithinAt.eventually_mem\n      (by simpa using mem_interior_iff_mem_nhds.1 hy)\n  filter_upwards [hmem, Ioo_mem_nhdsGT zero_lt_one] with δ hmem hsbt using hsxy.symm hmem (by aesop)\n\n"}
{"name":"IsOpen.eq_of_isVisible_of_left_mem","module":"Mathlib.Analysis.Convex.Visible","initialProofState":"𝕜 : Type u_1\nV : Type u_2\ninst✝⁷ : LinearOrderedField 𝕜\ninst✝⁶ : AddCommGroup V\ninst✝⁵ : Module 𝕜 V\ns : Set V\nx y : V\ninst✝⁴ : TopologicalSpace 𝕜\ninst✝³ : OrderTopology 𝕜\ninst✝² : TopologicalSpace V\ninst✝¹ : TopologicalAddGroup V\ninst✝ : ContinuousSMul 𝕜 V\nhs : IsOpen s\nhsxy : IsVisible 𝕜 s x y\nhy : Membership.mem s y\n⊢ Eq x y","decl":"/-- One cannot see any point of an open set. -/\nlemma IsOpen.eq_of_isVisible_of_left_mem (hs : IsOpen s) (hsxy : IsVisible 𝕜 s x y) (hy : y ∈ s) :\n    x = y :=\n  hsxy.eq_of_mem_interior (by simpa [hs.interior_eq])\n\n"}
{"name":"IsVisible.mem_convexHull_isVisible","module":"Mathlib.Analysis.Convex.Visible","initialProofState":"V : Type u_2\ninst✝¹ : AddCommGroup V\ninst✝ : Module Real V\ns : Set V\nx y : V\nhx : Not (Membership.mem ((convexHull Real) s) x)\nhy : Membership.mem ((convexHull Real) s) y\nhxy : IsVisible Real ((convexHull Real) s) x y\n⊢ Membership.mem ((convexHull Real) (setOf fun z => And (Membership.mem s z) (IsVisible Real ((convexHull Real) s) x z))) y","decl":"/-- All points of the convex hull of a set `s` visible from a point `x ∉ convexHull ℝ s` lie in the\nconvex hull of such points that actually lie in `s`.\n\nNote that the converse does not hold. -/\nlemma IsVisible.mem_convexHull_isVisible (hx : x ∉ convexHull ℝ s) (hy : y ∈ convexHull ℝ s)\n    (hxy : IsVisible ℝ (convexHull ℝ s) x y) :\n    y ∈ convexHull ℝ {z ∈ s | IsVisible ℝ (convexHull ℝ s) x z} := by\n  classical\n  obtain ⟨ι, _, w, a, hw₀, hw₁, ha, rfl⟩ := mem_convexHull_iff_exists_fintype.1 hy\n  rw [← Fintype.sum_subset (s := {i | w i ≠ 0})\n    fun i hi ↦ mem_filter.2 ⟨mem_univ _, left_ne_zero_of_smul hi⟩]\n  exact (convex_convexHull ..).sum_mem (fun i _ ↦ hw₀ _) (by rwa [sum_filter_ne_zero])\n    fun i hi ↦ subset_convexHull _ _ ⟨ha _, IsVisible.of_convexHull_of_pos (fun _ _ ↦ hw₀ _) hw₁\n      (by simpa) hx hxy (mem_univ _) <| (hw₀ _).lt_of_ne' (mem_filter.1 hi).2⟩\n\n"}
{"name":"IsClosed.exists_wbtw_isVisible","module":"Mathlib.Analysis.Convex.Visible","initialProofState":"V : Type u_2\ninst✝⁴ : AddCommGroup V\ninst✝³ : Module Real V\ns : Set V\ny : V\ninst✝² : TopologicalSpace V\ninst✝¹ : TopologicalAddGroup V\ninst✝ : ContinuousSMul Real V\nhs : IsClosed s\nhy : Membership.mem s y\nx : V\n⊢ Exists fun z => And (Membership.mem s z) (And (Wbtw Real x z y) (IsVisible Real s x z))","decl":"/-- If `s` is a closed set, then any point `x` sees some point of `s` in any direction where there\nis something to see. -/\nlemma IsClosed.exists_wbtw_isVisible (hs : IsClosed s) (hy : y ∈ s) (x : V) :\n    ∃ z ∈ s, Wbtw ℝ x z y ∧ IsVisible ℝ s x z := by\n  let t : Set ℝ := Ici 0 ∩ lineMap x y ⁻¹' s\n  have ht₁ : 1 ∈ t := by simpa [t]\n  have ht : BddBelow t := bddBelow_Ici.inter_of_left\n  let δ : ℝ := sInf t\n  have hδ₁ : δ ≤ 1 := csInf_le ht ht₁\n  obtain ⟨hδ₀, hδ⟩ : 0 ≤ δ ∧ lineMap x y δ ∈ s :=\n    (isClosed_Ici.inter <| hs.preimage lineMap_continuous).csInf_mem ⟨1, ht₁⟩ ht\n  refine ⟨lineMap x y δ, hδ, wbtw_lineMap_iff.2 <| .inr ⟨hδ₀, hδ₁⟩, ?_⟩\n  rintro _ hε ⟨⟨ε, ⟨hε₀, hε₁⟩, rfl⟩, -, h⟩\n  replace hδ₀ : 0 < δ := hδ₀.lt_of_ne' <| by rintro hδ₀; simp [hδ₀] at h\n  replace hε₁ : ε < 1 := hε₁.lt_of_ne <| by rintro rfl; simp at h\n  rw [lineMap_lineMap_right] at hε\n  exact (csInf_le ht ⟨mul_nonneg hε₀ hδ₀.le, hε⟩).not_lt <| mul_lt_of_lt_one_left hδ₀ hε₁\n\n-- TODO: Once we have cone hulls, the RHS can be strengthened to\n-- `coneHull ℝ x {y ∈ s | IsVisible ℝ (convexHull ℝ s) x y}`\n"}
{"name":"IsClosed.convexHull_subset_affineSpan_isVisible","module":"Mathlib.Analysis.Convex.Visible","initialProofState":"V : Type u_2\ninst✝⁴ : AddCommGroup V\ninst✝³ : Module Real V\ns : Set V\nx : V\ninst✝² : TopologicalSpace V\ninst✝¹ : TopologicalAddGroup V\ninst✝ : ContinuousSMul Real V\nhs : IsClosed ((convexHull Real) s)\nhx : Not (Membership.mem ((convexHull Real) s) x)\n⊢ HasSubset.Subset ((convexHull Real) s) ↑(affineSpan Real (Union.union (Singleton.singleton x) (setOf fun y => And (Membership.mem s y) (IsVisible Real ((convexHull Real) s) x y))))","decl":"/-- A set whose convex hull is closed lies in the cone based at a point `x` generated by its points\nvisible from `x` through its convex hull. -/\nlemma IsClosed.convexHull_subset_affineSpan_isVisible (hs : IsClosed (convexHull ℝ s))\n    (hx : x ∉ convexHull ℝ s) :\n    convexHull ℝ s ⊆ affineSpan ℝ ({x} ∪ {y ∈ s | IsVisible ℝ (convexHull ℝ s) x y}) := by\n  rintro y hy\n  obtain ⟨z, hz, hxzy, hxz⟩ := hs.exists_wbtw_isVisible hy x\n  -- TODO: `calc` doesn't work with `∈` :(\n  exact AffineSubspace.right_mem_of_wbtw hxzy (subset_affineSpan _ _ <| subset_union_left rfl)\n    (affineSpan_mono _ subset_union_right <| convexHull_subset_affineSpan _ <|\n      hxz.mem_convexHull_isVisible hx hz) (ne_of_mem_of_not_mem hz hx).symm\n\n"}
{"name":"rank_le_card_isVisible","module":"Mathlib.Analysis.Convex.Visible","initialProofState":"V : Type u_2\ninst✝⁴ : AddCommGroup V\ninst✝³ : Module Real V\ns : Set V\nx : V\ninst✝² : TopologicalSpace V\ninst✝¹ : TopologicalAddGroup V\ninst✝ : ContinuousSMul Real V\nhs : IsClosed ((convexHull Real) s)\nhx : Not (Membership.mem ((convexHull Real) s) x)\n⊢ LE.le (Module.rank Real (Subtype fun x_1 => Membership.mem (Submodule.span Real (HVAdd.hVAdd (Neg.neg x) s)) x_1)) (Cardinal.mk ↑(setOf fun y => And (Membership.mem s y) (IsVisible Real ((convexHull Real) s) x y)))","decl":"open Submodule in\n/-- If `s` is a closed set of dimension `d` and `x` is a point outside of its convex hull,\nthen `x` sees at least `d` points of the convex hull of `s` that actually lie in `s`. -/\nlemma rank_le_card_isVisible (hs : IsClosed (convexHull ℝ s)) (hx : x ∉ convexHull ℝ s) :\n    Module.rank ℝ (span ℝ (-x +ᵥ s)) ≤ #{y ∈ s | IsVisible ℝ (convexHull ℝ s) x y} := by\n  calc\n    Module.rank ℝ (span ℝ (-x +ᵥ s)) ≤\n      Module.rank ℝ (span ℝ\n        (-x +ᵥ affineSpan ℝ ({x} ∪ {y ∈ s | IsVisible ℝ (convexHull ℝ s) x y}) : Set V)) := by\n      push_cast\n      refine Submodule.rank_mono ?_\n      gcongr\n      exact (subset_convexHull ..).trans <| hs.convexHull_subset_affineSpan_isVisible hx\n    _ = Module.rank ℝ (span ℝ (-x +ᵥ {y ∈ s | IsVisible ℝ (convexHull ℝ s) x y})) := by\n      suffices h :\n        -x +ᵥ (affineSpan ℝ ({x} ∪ {y ∈ s | IsVisible ℝ (convexHull ℝ s) x y}) : Set V) =\n          span ℝ (-x +ᵥ {y ∈ s | IsVisible ℝ (convexHull ℝ s) x y}) by\n        rw [AffineSubspace.coe_pointwise_vadd, h, span_span]\n      simp [← AffineSubspace.coe_pointwise_vadd, AffineSubspace.pointwise_vadd_span,\n        vadd_set_insert, -coe_affineSpan, affineSpan_insert_zero]\n    _ ≤ #(-x +ᵥ {y ∈ s | IsVisible ℝ (convexHull ℝ s) x y}) := rank_span_le _\n    _ = #{y ∈ s | IsVisible ℝ (convexHull ℝ s) x y} := by simp\n\n"}
