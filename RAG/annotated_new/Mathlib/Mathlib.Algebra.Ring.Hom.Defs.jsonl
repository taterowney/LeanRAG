{"name":"NonUnitalRingHom.map_zero'","module":"Mathlib.Algebra.Ring.Hom.Defs","initialProofState":"α : Type u_5\nβ : Type u_6\ninst✝¹ : NonUnitalNonAssocSemiring α\ninst✝ : NonUnitalNonAssocSemiring β\nself : NonUnitalRingHom α β\n⊢ Eq (self.toFun 0) 0","decl":"/-- Bundled non-unital semiring homomorphisms `α →ₙ+* β`; use this for bundled non-unital ring\nhomomorphisms too.\n\nWhen possible, instead of parametrizing results over `(f : α →ₙ+* β)`,\nyou should parametrize over `(F : Type*) [NonUnitalRingHomClass F α β] (f : F)`.\n\nWhen you extend this structure, make sure to extend `NonUnitalRingHomClass`. -/\nstructure NonUnitalRingHom (α β : Type*) [NonUnitalNonAssocSemiring α]\n  [NonUnitalNonAssocSemiring β] extends α →ₙ* β, α →+ β\n\n"}
{"name":"NonUnitalRingHom.mk.sizeOf_spec","module":"Mathlib.Algebra.Ring.Hom.Defs","initialProofState":"α : Type u_5\nβ : Type u_6\ninst✝³ : NonUnitalNonAssocSemiring α\ninst✝² : NonUnitalNonAssocSemiring β\ninst✝¹ : SizeOf α\ninst✝ : SizeOf β\ntoMulHom : MulHom α β\nmap_zero' : Eq (toMulHom.toFun 0) 0\nmap_add' : ∀ (x y : α), Eq (toMulHom.toFun (HAdd.hAdd x y)) (HAdd.hAdd (toMulHom.toFun x) (toMulHom.toFun y))\n⊢ Eq (SizeOf.sizeOf { toMulHom := toMulHom, map_zero' := map_zero', map_add' := map_add' }) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf toMulHom)) (SizeOf.sizeOf map_zero'))","decl":"/-- Bundled non-unital semiring homomorphisms `α →ₙ+* β`; use this for bundled non-unital ring\nhomomorphisms too.\n\nWhen possible, instead of parametrizing results over `(f : α →ₙ+* β)`,\nyou should parametrize over `(F : Type*) [NonUnitalRingHomClass F α β] (f : F)`.\n\nWhen you extend this structure, make sure to extend `NonUnitalRingHomClass`. -/\nstructure NonUnitalRingHom (α β : Type*) [NonUnitalNonAssocSemiring α]\n  [NonUnitalNonAssocSemiring β] extends α →ₙ* β, α →+ β\n\n"}
{"name":"NonUnitalRingHom.mk.injEq","module":"Mathlib.Algebra.Ring.Hom.Defs","initialProofState":"α : Type u_5\nβ : Type u_6\ninst✝¹ : NonUnitalNonAssocSemiring α\ninst✝ : NonUnitalNonAssocSemiring β\ntoMulHom✝ : MulHom α β\nmap_zero'✝ : Eq (toMulHom✝.toFun 0) 0\nmap_add'✝ : ∀ (x y : α), Eq (toMulHom✝.toFun (HAdd.hAdd x y)) (HAdd.hAdd (toMulHom✝.toFun x) (toMulHom✝.toFun y))\ntoMulHom : MulHom α β\nmap_zero' : Eq (toMulHom.toFun 0) 0\nmap_add' : ∀ (x y : α), Eq (toMulHom.toFun (HAdd.hAdd x y)) (HAdd.hAdd (toMulHom.toFun x) (toMulHom.toFun y))\n⊢ Eq (Eq { toMulHom := toMulHom✝, map_zero' := map_zero'✝, map_add' := map_add'✝ } { toMulHom := toMulHom, map_zero' := map_zero', map_add' := map_add' }) (Eq toMulHom✝ toMulHom)","decl":"/-- Bundled non-unital semiring homomorphisms `α →ₙ+* β`; use this for bundled non-unital ring\nhomomorphisms too.\n\nWhen possible, instead of parametrizing results over `(f : α →ₙ+* β)`,\nyou should parametrize over `(F : Type*) [NonUnitalRingHomClass F α β] (f : F)`.\n\nWhen you extend this structure, make sure to extend `NonUnitalRingHomClass`. -/\nstructure NonUnitalRingHom (α β : Type*) [NonUnitalNonAssocSemiring α]\n  [NonUnitalNonAssocSemiring β] extends α →ₙ* β, α →+ β\n\n"}
{"name":"NonUnitalRingHom.mk.inj","module":"Mathlib.Algebra.Ring.Hom.Defs","initialProofState":"α : Type u_5\nβ : Type u_6\ninst✝¹ : NonUnitalNonAssocSemiring α\ninst✝ : NonUnitalNonAssocSemiring β\ntoMulHom✝ : MulHom α β\nmap_zero'✝ : Eq (toMulHom✝.toFun 0) 0\nmap_add'✝ : ∀ (x y : α), Eq (toMulHom✝.toFun (HAdd.hAdd x y)) (HAdd.hAdd (toMulHom✝.toFun x) (toMulHom✝.toFun y))\ntoMulHom : MulHom α β\nmap_zero' : Eq (toMulHom.toFun 0) 0\nmap_add' : ∀ (x y : α), Eq (toMulHom.toFun (HAdd.hAdd x y)) (HAdd.hAdd (toMulHom.toFun x) (toMulHom.toFun y))\nx✝ : Eq { toMulHom := toMulHom✝, map_zero' := map_zero'✝, map_add' := map_add'✝ } { toMulHom := toMulHom, map_zero' := map_zero', map_add' := map_add' }\n⊢ Eq toMulHom✝ toMulHom","decl":"/-- Bundled non-unital semiring homomorphisms `α →ₙ+* β`; use this for bundled non-unital ring\nhomomorphisms too.\n\nWhen possible, instead of parametrizing results over `(f : α →ₙ+* β)`,\nyou should parametrize over `(F : Type*) [NonUnitalRingHomClass F α β] (f : F)`.\n\nWhen you extend this structure, make sure to extend `NonUnitalRingHomClass`. -/\nstructure NonUnitalRingHom (α β : Type*) [NonUnitalNonAssocSemiring α]\n  [NonUnitalNonAssocSemiring β] extends α →ₙ* β, α →+ β\n\n"}
{"name":"NonUnitalRingHom.map_add'","module":"Mathlib.Algebra.Ring.Hom.Defs","initialProofState":"α : Type u_5\nβ : Type u_6\ninst✝¹ : NonUnitalNonAssocSemiring α\ninst✝ : NonUnitalNonAssocSemiring β\nself : NonUnitalRingHom α β\nx y : α\n⊢ Eq (self.toFun (HAdd.hAdd x y)) (HAdd.hAdd (self.toFun x) (self.toFun y))","decl":"/-- Bundled non-unital semiring homomorphisms `α →ₙ+* β`; use this for bundled non-unital ring\nhomomorphisms too.\n\nWhen possible, instead of parametrizing results over `(f : α →ₙ+* β)`,\nyou should parametrize over `(F : Type*) [NonUnitalRingHomClass F α β] (f : F)`.\n\nWhen you extend this structure, make sure to extend `NonUnitalRingHomClass`. -/\nstructure NonUnitalRingHom (α β : Type*) [NonUnitalNonAssocSemiring α]\n  [NonUnitalNonAssocSemiring β] extends α →ₙ* β, α →+ β\n\n"}
{"name":"NonUnitalRingHomClass.toAddMonoidHomClass","module":"Mathlib.Algebra.Ring.Hom.Defs","initialProofState":"F : Type u_5\nα : outParam (Type u_6)\nβ : outParam (Type u_7)\ninst✝² : NonUnitalNonAssocSemiring α\ninst✝¹ : NonUnitalNonAssocSemiring β\ninst✝ : FunLike F α β\nself : NonUnitalRingHomClass F α β\n⊢ AddMonoidHomClass F α β","decl":"/-- `NonUnitalRingHomClass F α β` states that `F` is a type of non-unital (semi)ring\nhomomorphisms. You should extend this class when you extend `NonUnitalRingHom`. -/\nclass NonUnitalRingHomClass (F : Type*) (α β : outParam Type*) [NonUnitalNonAssocSemiring α]\n  [NonUnitalNonAssocSemiring β] [FunLike F α β]\n  extends MulHomClass F α β, AddMonoidHomClass F α β : Prop\n\n"}
{"name":"NonUnitalRingHomClass.toMulHomClass","module":"Mathlib.Algebra.Ring.Hom.Defs","initialProofState":"F : Type u_5\nα : outParam (Type u_6)\nβ : outParam (Type u_7)\ninst✝² : NonUnitalNonAssocSemiring α\ninst✝¹ : NonUnitalNonAssocSemiring β\ninst✝ : FunLike F α β\nself : NonUnitalRingHomClass F α β\n⊢ MulHomClass F α β","decl":"/-- `NonUnitalRingHomClass F α β` states that `F` is a type of non-unital (semi)ring\nhomomorphisms. You should extend this class when you extend `NonUnitalRingHom`. -/\nclass NonUnitalRingHomClass (F : Type*) (α β : outParam Type*) [NonUnitalNonAssocSemiring α]\n  [NonUnitalNonAssocSemiring β] [FunLike F α β]\n  extends MulHomClass F α β, AddMonoidHomClass F α β : Prop\n\n"}
{"name":"NonUnitalRingHom.instNonUnitalRingHomClass","module":"Mathlib.Algebra.Ring.Hom.Defs","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : NonUnitalNonAssocSemiring α\ninst✝ : NonUnitalNonAssocSemiring β\n⊢ NonUnitalRingHomClass (NonUnitalRingHom α β) α β","decl":"instance : NonUnitalRingHomClass (α →ₙ+* β) α β where\n  map_add := NonUnitalRingHom.map_add'\n  map_zero := NonUnitalRingHom.map_zero'\n  map_mul f := f.map_mul'\n\n-- Porting note: removed due to new `coe` in Lean4\n\n"}
{"name":"NonUnitalRingHom.coe_toMulHom","module":"Mathlib.Algebra.Ring.Hom.Defs","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : NonUnitalNonAssocSemiring α\ninst✝ : NonUnitalNonAssocSemiring β\nf : NonUnitalRingHom α β\n⊢ Eq ⇑f.toMulHom ⇑f","decl":"@[simp]\ntheorem coe_toMulHom (f : α →ₙ+* β) : ⇑f.toMulHom = f :=\n  rfl\n\n"}
{"name":"NonUnitalRingHom.coe_mulHom_mk","module":"Mathlib.Algebra.Ring.Hom.Defs","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : NonUnitalNonAssocSemiring α\ninst✝ : NonUnitalNonAssocSemiring β\nf : α → β\nh₁ : ∀ (x y : α), Eq (f (HMul.hMul x y)) (HMul.hMul (f x) (f y))\nh₂ : Eq ({ toFun := f, map_mul' := h₁ }.toFun 0) 0\nh₃ : ∀ (x y : α), Eq ({ toFun := f, map_mul' := h₁ }.toFun (HAdd.hAdd x y)) (HAdd.hAdd ({ toFun := f, map_mul' := h₁ }.toFun x) ({ toFun := f, map_mul' := h₁ }.toFun y))\n⊢ Eq ↑{ toFun := f, map_mul' := h₁, map_zero' := h₂, map_add' := h₃ } { toFun := f, map_mul' := h₁ }","decl":"@[simp]\ntheorem coe_mulHom_mk (f : α → β) (h₁ h₂ h₃) :\n    ((⟨⟨f, h₁⟩, h₂, h₃⟩ : α →ₙ+* β) : α →ₙ* β) = ⟨f, h₁⟩ :=\n  rfl\n\n"}
{"name":"NonUnitalRingHom.coe_toAddMonoidHom","module":"Mathlib.Algebra.Ring.Hom.Defs","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : NonUnitalNonAssocSemiring α\ninst✝ : NonUnitalNonAssocSemiring β\nf : NonUnitalRingHom α β\n⊢ Eq ⇑f.toAddMonoidHom ⇑f","decl":"theorem coe_toAddMonoidHom (f : α →ₙ+* β) : ⇑f.toAddMonoidHom = f := rfl\n\n"}
{"name":"NonUnitalRingHom.coe_addMonoidHom_mk","module":"Mathlib.Algebra.Ring.Hom.Defs","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : NonUnitalNonAssocSemiring α\ninst✝ : NonUnitalNonAssocSemiring β\nf : α → β\nh₁ : ∀ (x y : α), Eq (f (HMul.hMul x y)) (HMul.hMul (f x) (f y))\nh₂ : Eq ({ toFun := f, map_mul' := h₁ }.toFun 0) 0\nh₃ : ∀ (x y : α), Eq ({ toFun := f, map_mul' := h₁ }.toFun (HAdd.hAdd x y)) (HAdd.hAdd ({ toFun := f, map_mul' := h₁ }.toFun x) ({ toFun := f, map_mul' := h₁ }.toFun y))\n⊢ Eq ↑{ toFun := f, map_mul' := h₁, map_zero' := h₂, map_add' := h₃ } { toFun := f, map_zero' := h₂, map_add' := h₃ }","decl":"@[simp]\ntheorem coe_addMonoidHom_mk (f : α → β) (h₁ h₂ h₃) :\n    ((⟨⟨f, h₁⟩, h₂, h₃⟩ : α →ₙ+* β) : α →+ β) = ⟨⟨f, h₂⟩, h₃⟩ :=\n  rfl\n\n"}
{"name":"NonUnitalRingHom.coe_copy","module":"Mathlib.Algebra.Ring.Hom.Defs","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : NonUnitalNonAssocSemiring α\ninst✝ : NonUnitalNonAssocSemiring β\nf : NonUnitalRingHom α β\nf' : α → β\nh : Eq f' ⇑f\n⊢ Eq (⇑(f.copy f' h)) f'","decl":"@[simp]\ntheorem coe_copy (f : α →ₙ+* β) (f' : α → β) (h : f' = f) : ⇑(f.copy f' h) = f' :=\n  rfl\n\n"}
{"name":"NonUnitalRingHom.copy_eq","module":"Mathlib.Algebra.Ring.Hom.Defs","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : NonUnitalNonAssocSemiring α\ninst✝ : NonUnitalNonAssocSemiring β\nf : NonUnitalRingHom α β\nf' : α → β\nh : Eq f' ⇑f\n⊢ Eq (f.copy f' h) f","decl":"theorem copy_eq (f : α →ₙ+* β) (f' : α → β) (h : f' = f) : f.copy f' h = f :=\n  DFunLike.ext' h\n\n"}
{"name":"NonUnitalRingHom.ext_iff","module":"Mathlib.Algebra.Ring.Hom.Defs","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : NonUnitalNonAssocSemiring α\ninst✝ : NonUnitalNonAssocSemiring β\nf g : NonUnitalRingHom α β\n⊢ Iff (Eq f g) (∀ (x : α), Eq (f x) (g x))","decl":"@[ext]\ntheorem ext ⦃f g : α →ₙ+* β⦄ : (∀ x, f x = g x) → f = g :=\n  DFunLike.ext _ _\n\n"}
{"name":"NonUnitalRingHom.ext","module":"Mathlib.Algebra.Ring.Hom.Defs","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : NonUnitalNonAssocSemiring α\ninst✝ : NonUnitalNonAssocSemiring β\nf g : NonUnitalRingHom α β\na✝ : ∀ (x : α), Eq (f x) (g x)\n⊢ Eq f g","decl":"@[ext]\ntheorem ext ⦃f g : α →ₙ+* β⦄ : (∀ x, f x = g x) → f = g :=\n  DFunLike.ext _ _\n\n"}
{"name":"NonUnitalRingHom.mk_coe","module":"Mathlib.Algebra.Ring.Hom.Defs","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : NonUnitalNonAssocSemiring α\ninst✝ : NonUnitalNonAssocSemiring β\nf : NonUnitalRingHom α β\nh₁ : ∀ (x y : α), Eq (f (HMul.hMul x y)) (HMul.hMul (f x) (f y))\nh₂ : Eq ({ toFun := ⇑f, map_mul' := h₁ }.toFun 0) 0\nh₃ : ∀ (x y : α), Eq ({ toFun := ⇑f, map_mul' := h₁ }.toFun (HAdd.hAdd x y)) (HAdd.hAdd ({ toFun := ⇑f, map_mul' := h₁ }.toFun x) ({ toFun := ⇑f, map_mul' := h₁ }.toFun y))\n⊢ Eq { toFun := ⇑f, map_mul' := h₁, map_zero' := h₂, map_add' := h₃ } f","decl":"@[simp]\ntheorem mk_coe (f : α →ₙ+* β) (h₁ h₂ h₃) : NonUnitalRingHom.mk (MulHom.mk f h₁) h₂ h₃ = f :=\n  ext fun _ => rfl\n\n"}
{"name":"NonUnitalRingHom.coe_addMonoidHom_injective","module":"Mathlib.Algebra.Ring.Hom.Defs","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : NonUnitalNonAssocSemiring α\ninst✝ : NonUnitalNonAssocSemiring β\n⊢ Function.Injective fun f => ↑f","decl":"theorem coe_addMonoidHom_injective : Injective fun f : α →ₙ+* β => (f : α →+ β) :=\n  Injective.of_comp (f := DFunLike.coe) DFunLike.coe_injective\n\n"}
{"name":"NonUnitalRingHom.coe_mulHom_injective","module":"Mathlib.Algebra.Ring.Hom.Defs","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : NonUnitalNonAssocSemiring α\ninst✝ : NonUnitalNonAssocSemiring β\n⊢ Function.Injective fun f => ↑f","decl":"theorem coe_mulHom_injective : Injective fun f : α →ₙ+* β => (f : α →ₙ* β) :=\n  Injective.of_comp (f := DFunLike.coe) DFunLike.coe_injective\n\n"}
{"name":"NonUnitalRingHom.coe_zero","module":"Mathlib.Algebra.Ring.Hom.Defs","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : NonUnitalNonAssocSemiring α\ninst✝ : NonUnitalNonAssocSemiring β\n⊢ Eq (⇑0) 0","decl":"@[simp]\ntheorem coe_zero : ⇑(0 : α →ₙ+* β) = 0 :=\n  rfl\n\n"}
{"name":"NonUnitalRingHom.zero_apply","module":"Mathlib.Algebra.Ring.Hom.Defs","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : NonUnitalNonAssocSemiring α\ninst✝ : NonUnitalNonAssocSemiring β\nx : α\n⊢ Eq (0 x) 0","decl":"@[simp]\ntheorem zero_apply (x : α) : (0 : α →ₙ+* β) x = 0 :=\n  rfl\n\n"}
{"name":"NonUnitalRingHom.id_apply","module":"Mathlib.Algebra.Ring.Hom.Defs","initialProofState":"α : Type u_2\ninst✝ : NonUnitalNonAssocSemiring α\nx : α\n⊢ Eq ((NonUnitalRingHom.id α) x) x","decl":"@[simp]\ntheorem id_apply (x : α) : NonUnitalRingHom.id α x = x :=\n  rfl\n\n"}
{"name":"NonUnitalRingHom.coe_addMonoidHom_id","module":"Mathlib.Algebra.Ring.Hom.Defs","initialProofState":"α : Type u_2\ninst✝ : NonUnitalNonAssocSemiring α\n⊢ Eq (↑(NonUnitalRingHom.id α)) (AddMonoidHom.id α)","decl":"@[simp]\ntheorem coe_addMonoidHom_id : (NonUnitalRingHom.id α : α →+ α) = AddMonoidHom.id α :=\n  rfl\n\n"}
{"name":"NonUnitalRingHom.coe_mulHom_id","module":"Mathlib.Algebra.Ring.Hom.Defs","initialProofState":"α : Type u_2\ninst✝ : NonUnitalNonAssocSemiring α\n⊢ Eq (↑(NonUnitalRingHom.id α)) (MulHom.id α)","decl":"@[simp]\ntheorem coe_mulHom_id : (NonUnitalRingHom.id α : α →ₙ* α) = MulHom.id α :=\n  rfl\n\n"}
{"name":"NonUnitalRingHom.comp_assoc","module":"Mathlib.Algebra.Ring.Hom.Defs","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝² : NonUnitalNonAssocSemiring α\ninst✝¹ : NonUnitalNonAssocSemiring β\ninst✝ : NonUnitalNonAssocSemiring γ\nδ : Type u_5\nx✝ : NonUnitalNonAssocSemiring δ\nf : NonUnitalRingHom α β\ng : NonUnitalRingHom β γ\nh : NonUnitalRingHom γ δ\n⊢ Eq ((h.comp g).comp f) (h.comp (g.comp f))","decl":"/-- Composition of non-unital ring homomorphisms is associative. -/\ntheorem comp_assoc {δ} {_ : NonUnitalNonAssocSemiring δ} (f : α →ₙ+* β) (g : β →ₙ+* γ)\n    (h : γ →ₙ+* δ) : (h.comp g).comp f = h.comp (g.comp f) :=\n  rfl\n\n"}
{"name":"NonUnitalRingHom.coe_comp","module":"Mathlib.Algebra.Ring.Hom.Defs","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝² : NonUnitalNonAssocSemiring α\ninst✝¹ : NonUnitalNonAssocSemiring β\ninst✝ : NonUnitalNonAssocSemiring γ\ng : NonUnitalRingHom β γ\nf : NonUnitalRingHom α β\n⊢ Eq (⇑(g.comp f)) (Function.comp ⇑g ⇑f)","decl":"@[simp]\ntheorem coe_comp (g : β →ₙ+* γ) (f : α →ₙ+* β) : ⇑(g.comp f) = g ∘ f :=\n  rfl\n\n"}
{"name":"NonUnitalRingHom.comp_apply","module":"Mathlib.Algebra.Ring.Hom.Defs","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝² : NonUnitalNonAssocSemiring α\ninst✝¹ : NonUnitalNonAssocSemiring β\ninst✝ : NonUnitalNonAssocSemiring γ\ng : NonUnitalRingHom β γ\nf : NonUnitalRingHom α β\nx : α\n⊢ Eq ((g.comp f) x) (g (f x))","decl":"@[simp]\ntheorem comp_apply (g : β →ₙ+* γ) (f : α →ₙ+* β) (x : α) : g.comp f x = g (f x) :=\n  rfl\n\n"}
{"name":"NonUnitalRingHom.coe_comp_addMonoidHom","module":"Mathlib.Algebra.Ring.Hom.Defs","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝² : NonUnitalNonAssocSemiring α\ninst✝¹ : NonUnitalNonAssocSemiring β\ninst✝ : NonUnitalNonAssocSemiring γ\ng : NonUnitalRingHom β γ\nf : NonUnitalRingHom α β\n⊢ Eq { toFun := Function.comp ⇑g ⇑f, map_zero' := ⋯, map_add' := ⋯ } ((↑g).comp ↑f)","decl":"@[simp]\ntheorem coe_comp_addMonoidHom (g : β →ₙ+* γ) (f : α →ₙ+* β) :\n    AddMonoidHom.mk ⟨g ∘ f, (g.comp f).map_zero'⟩ (g.comp f).map_add' = (g : β →+ γ).comp f :=\n  rfl\n\n"}
{"name":"NonUnitalRingHom.coe_comp_mulHom","module":"Mathlib.Algebra.Ring.Hom.Defs","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝² : NonUnitalNonAssocSemiring α\ninst✝¹ : NonUnitalNonAssocSemiring β\ninst✝ : NonUnitalNonAssocSemiring γ\ng : NonUnitalRingHom β γ\nf : NonUnitalRingHom α β\n⊢ Eq { toFun := Function.comp ⇑g ⇑f, map_mul' := ⋯ } ((↑g).comp ↑f)","decl":"@[simp]\ntheorem coe_comp_mulHom (g : β →ₙ+* γ) (f : α →ₙ+* β) :\n    MulHom.mk (g ∘ f) (g.comp f).map_mul' = (g : β →ₙ* γ).comp f :=\n  rfl\n\n"}
{"name":"NonUnitalRingHom.comp_zero","module":"Mathlib.Algebra.Ring.Hom.Defs","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝² : NonUnitalNonAssocSemiring α\ninst✝¹ : NonUnitalNonAssocSemiring β\ninst✝ : NonUnitalNonAssocSemiring γ\ng : NonUnitalRingHom β γ\n⊢ Eq (g.comp 0) 0","decl":"@[simp]\ntheorem comp_zero (g : β →ₙ+* γ) : g.comp (0 : α →ₙ+* β) = 0 := by\n  ext\n  simp\n\n"}
{"name":"NonUnitalRingHom.zero_comp","module":"Mathlib.Algebra.Ring.Hom.Defs","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝² : NonUnitalNonAssocSemiring α\ninst✝¹ : NonUnitalNonAssocSemiring β\ninst✝ : NonUnitalNonAssocSemiring γ\nf : NonUnitalRingHom α β\n⊢ Eq (NonUnitalRingHom.comp 0 f) 0","decl":"@[simp]\ntheorem zero_comp (f : α →ₙ+* β) : (0 : β →ₙ+* γ).comp f = 0 := by\n  ext\n  rfl\n\n"}
{"name":"NonUnitalRingHom.comp_id","module":"Mathlib.Algebra.Ring.Hom.Defs","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : NonUnitalNonAssocSemiring α\ninst✝ : NonUnitalNonAssocSemiring β\nf : NonUnitalRingHom α β\n⊢ Eq (f.comp (NonUnitalRingHom.id α)) f","decl":"@[simp]\ntheorem comp_id (f : α →ₙ+* β) : f.comp (NonUnitalRingHom.id α) = f :=\n  ext fun _ => rfl\n\n"}
{"name":"NonUnitalRingHom.id_comp","module":"Mathlib.Algebra.Ring.Hom.Defs","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : NonUnitalNonAssocSemiring α\ninst✝ : NonUnitalNonAssocSemiring β\nf : NonUnitalRingHom α β\n⊢ Eq ((NonUnitalRingHom.id β).comp f) f","decl":"@[simp]\ntheorem id_comp (f : α →ₙ+* β) : (NonUnitalRingHom.id β).comp f = f :=\n  ext fun _ => rfl\n\n"}
{"name":"NonUnitalRingHom.one_def","module":"Mathlib.Algebra.Ring.Hom.Defs","initialProofState":"α : Type u_2\ninst✝ : NonUnitalNonAssocSemiring α\n⊢ Eq 1 (NonUnitalRingHom.id α)","decl":"theorem one_def : (1 : α →ₙ+* α) = NonUnitalRingHom.id α :=\n  rfl\n\n"}
{"name":"NonUnitalRingHom.coe_one","module":"Mathlib.Algebra.Ring.Hom.Defs","initialProofState":"α : Type u_2\ninst✝ : NonUnitalNonAssocSemiring α\n⊢ Eq (⇑1) id","decl":"@[simp]\ntheorem coe_one : ⇑(1 : α →ₙ+* α) = id :=\n  rfl\n\n"}
{"name":"NonUnitalRingHom.mul_def","module":"Mathlib.Algebra.Ring.Hom.Defs","initialProofState":"α : Type u_2\ninst✝ : NonUnitalNonAssocSemiring α\nf g : NonUnitalRingHom α α\n⊢ Eq (HMul.hMul f g) (f.comp g)","decl":"theorem mul_def (f g : α →ₙ+* α) : f * g = f.comp g :=\n  rfl\n\n"}
{"name":"NonUnitalRingHom.coe_mul","module":"Mathlib.Algebra.Ring.Hom.Defs","initialProofState":"α : Type u_2\ninst✝ : NonUnitalNonAssocSemiring α\nf g : NonUnitalRingHom α α\n⊢ Eq (⇑(HMul.hMul f g)) (Function.comp ⇑f ⇑g)","decl":"@[simp]\ntheorem coe_mul (f g : α →ₙ+* α) : ⇑(f * g) = f ∘ g :=\n  rfl\n\n"}
{"name":"NonUnitalRingHom.cancel_right","module":"Mathlib.Algebra.Ring.Hom.Defs","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝² : NonUnitalNonAssocSemiring α\ninst✝¹ : NonUnitalNonAssocSemiring β\ninst✝ : NonUnitalNonAssocSemiring γ\ng₁ g₂ : NonUnitalRingHom β γ\nf : NonUnitalRingHom α β\nhf : Function.Surjective ⇑f\n⊢ Iff (Eq (g₁.comp f) (g₂.comp f)) (Eq g₁ g₂)","decl":"@[simp]\ntheorem cancel_right {g₁ g₂ : β →ₙ+* γ} {f : α →ₙ+* β} (hf : Surjective f) :\n    g₁.comp f = g₂.comp f ↔ g₁ = g₂ :=\n  ⟨fun h => ext <| hf.forall.2 (NonUnitalRingHom.ext_iff.1 h), fun h => h ▸ rfl⟩\n\n"}
{"name":"NonUnitalRingHom.cancel_left","module":"Mathlib.Algebra.Ring.Hom.Defs","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝² : NonUnitalNonAssocSemiring α\ninst✝¹ : NonUnitalNonAssocSemiring β\ninst✝ : NonUnitalNonAssocSemiring γ\ng : NonUnitalRingHom β γ\nf₁ f₂ : NonUnitalRingHom α β\nhg : Function.Injective ⇑g\n⊢ Iff (Eq (g.comp f₁) (g.comp f₂)) (Eq f₁ f₂)","decl":"@[simp]\ntheorem cancel_left {g : β →ₙ+* γ} {f₁ f₂ : α →ₙ+* β} (hg : Injective g) :\n    g.comp f₁ = g.comp f₂ ↔ f₁ = f₂ :=\n  ⟨fun h => ext fun x => hg <| by rw [← comp_apply, h, comp_apply], fun h => h ▸ rfl⟩\n\n"}
{"name":"RingHom.mk.injEq","module":"Mathlib.Algebra.Ring.Hom.Defs","initialProofState":"α : Type u_5\nβ : Type u_6\ninst✝¹ : NonAssocSemiring α\ninst✝ : NonAssocSemiring β\ntoMonoidHom✝ : MonoidHom α β\nmap_zero'✝ : Eq ((↑toMonoidHom✝).toFun 0) 0\nmap_add'✝ : ∀ (x y : α), Eq ((↑toMonoidHom✝).toFun (HAdd.hAdd x y)) (HAdd.hAdd ((↑toMonoidHom✝).toFun x) ((↑toMonoidHom✝).toFun y))\ntoMonoidHom : MonoidHom α β\nmap_zero' : Eq ((↑toMonoidHom).toFun 0) 0\nmap_add' : ∀ (x y : α), Eq ((↑toMonoidHom).toFun (HAdd.hAdd x y)) (HAdd.hAdd ((↑toMonoidHom).toFun x) ((↑toMonoidHom).toFun y))\n⊢ Eq (Eq { toMonoidHom := toMonoidHom✝, map_zero' := map_zero'✝, map_add' := map_add'✝ } { toMonoidHom := toMonoidHom, map_zero' := map_zero', map_add' := map_add' }) (Eq toMonoidHom✝ toMonoidHom)","decl":"/-- Bundled semiring homomorphisms; use this for bundled ring homomorphisms too.\n\nThis extends from both `MonoidHom` and `MonoidWithZeroHom` in order to put the fields in a\nsensible order, even though `MonoidWithZeroHom` already extends `MonoidHom`. -/\nstructure RingHom (α : Type*) (β : Type*) [NonAssocSemiring α] [NonAssocSemiring β] extends\n  α →* β, α →+ β, α →ₙ+* β, α →*₀ β\n\n"}
{"name":"RingHom.map_add'","module":"Mathlib.Algebra.Ring.Hom.Defs","initialProofState":"α : Type u_5\nβ : Type u_6\ninst✝¹ : NonAssocSemiring α\ninst✝ : NonAssocSemiring β\nself : RingHom α β\nx y : α\n⊢ Eq ((↑self.toMonoidHom).toFun (HAdd.hAdd x y)) (HAdd.hAdd ((↑self.toMonoidHom).toFun x) ((↑self.toMonoidHom).toFun y))","decl":"/-- Bundled semiring homomorphisms; use this for bundled ring homomorphisms too.\n\nThis extends from both `MonoidHom` and `MonoidWithZeroHom` in order to put the fields in a\nsensible order, even though `MonoidWithZeroHom` already extends `MonoidHom`. -/\nstructure RingHom (α : Type*) (β : Type*) [NonAssocSemiring α] [NonAssocSemiring β] extends\n  α →* β, α →+ β, α →ₙ+* β, α →*₀ β\n\n"}
{"name":"RingHom.mk.inj","module":"Mathlib.Algebra.Ring.Hom.Defs","initialProofState":"α : Type u_5\nβ : Type u_6\ninst✝¹ : NonAssocSemiring α\ninst✝ : NonAssocSemiring β\ntoMonoidHom✝ : MonoidHom α β\nmap_zero'✝ : Eq ((↑toMonoidHom✝).toFun 0) 0\nmap_add'✝ : ∀ (x y : α), Eq ((↑toMonoidHom✝).toFun (HAdd.hAdd x y)) (HAdd.hAdd ((↑toMonoidHom✝).toFun x) ((↑toMonoidHom✝).toFun y))\ntoMonoidHom : MonoidHom α β\nmap_zero' : Eq ((↑toMonoidHom).toFun 0) 0\nmap_add' : ∀ (x y : α), Eq ((↑toMonoidHom).toFun (HAdd.hAdd x y)) (HAdd.hAdd ((↑toMonoidHom).toFun x) ((↑toMonoidHom).toFun y))\nx✝ : Eq { toMonoidHom := toMonoidHom✝, map_zero' := map_zero'✝, map_add' := map_add'✝ } { toMonoidHom := toMonoidHom, map_zero' := map_zero', map_add' := map_add' }\n⊢ Eq toMonoidHom✝ toMonoidHom","decl":"/-- Bundled semiring homomorphisms; use this for bundled ring homomorphisms too.\n\nThis extends from both `MonoidHom` and `MonoidWithZeroHom` in order to put the fields in a\nsensible order, even though `MonoidWithZeroHom` already extends `MonoidHom`. -/\nstructure RingHom (α : Type*) (β : Type*) [NonAssocSemiring α] [NonAssocSemiring β] extends\n  α →* β, α →+ β, α →ₙ+* β, α →*₀ β\n\n"}
{"name":"RingHom.map_zero'","module":"Mathlib.Algebra.Ring.Hom.Defs","initialProofState":"α : Type u_5\nβ : Type u_6\ninst✝¹ : NonAssocSemiring α\ninst✝ : NonAssocSemiring β\nself : RingHom α β\n⊢ Eq ((↑self.toMonoidHom).toFun 0) 0","decl":"/-- Bundled semiring homomorphisms; use this for bundled ring homomorphisms too.\n\nThis extends from both `MonoidHom` and `MonoidWithZeroHom` in order to put the fields in a\nsensible order, even though `MonoidWithZeroHom` already extends `MonoidHom`. -/\nstructure RingHom (α : Type*) (β : Type*) [NonAssocSemiring α] [NonAssocSemiring β] extends\n  α →* β, α →+ β, α →ₙ+* β, α →*₀ β\n\n"}
{"name":"RingHom.mk.sizeOf_spec","module":"Mathlib.Algebra.Ring.Hom.Defs","initialProofState":"α : Type u_5\nβ : Type u_6\ninst✝³ : NonAssocSemiring α\ninst✝² : NonAssocSemiring β\ninst✝¹ : SizeOf α\ninst✝ : SizeOf β\ntoMonoidHom : MonoidHom α β\nmap_zero' : Eq ((↑toMonoidHom).toFun 0) 0\nmap_add' : ∀ (x y : α), Eq ((↑toMonoidHom).toFun (HAdd.hAdd x y)) (HAdd.hAdd ((↑toMonoidHom).toFun x) ((↑toMonoidHom).toFun y))\n⊢ Eq (SizeOf.sizeOf { toMonoidHom := toMonoidHom, map_zero' := map_zero', map_add' := map_add' }) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf toMonoidHom)) (SizeOf.sizeOf map_zero'))","decl":"/-- Bundled semiring homomorphisms; use this for bundled ring homomorphisms too.\n\nThis extends from both `MonoidHom` and `MonoidWithZeroHom` in order to put the fields in a\nsensible order, even though `MonoidWithZeroHom` already extends `MonoidHom`. -/\nstructure RingHom (α : Type*) (β : Type*) [NonAssocSemiring α] [NonAssocSemiring β] extends\n  α →* β, α →+ β, α →ₙ+* β, α →*₀ β\n\n"}
{"name":"RingHomClass.toMonoidWithZeroHomClass","module":"Mathlib.Algebra.Ring.Hom.Defs","initialProofState":"F : Type u_5\nα : outParam (Type u_6)\nβ : outParam (Type u_7)\ninst✝² : NonAssocSemiring α\ninst✝¹ : NonAssocSemiring β\ninst✝ : FunLike F α β\nself : RingHomClass F α β\n⊢ MonoidWithZeroHomClass F α β","decl":"/-- `RingHomClass F α β` states that `F` is a type of (semi)ring homomorphisms.\nYou should extend this class when you extend `RingHom`.\n\nThis extends from both `MonoidHomClass` and `MonoidWithZeroHomClass` in\norder to put the fields in a sensible order, even though\n`MonoidWithZeroHomClass` already extends `MonoidHomClass`. -/\nclass RingHomClass (F : Type*) (α β : outParam Type*)\n    [NonAssocSemiring α] [NonAssocSemiring β] [FunLike F α β]\n  extends MonoidHomClass F α β, AddMonoidHomClass F α β, MonoidWithZeroHomClass F α β : Prop\n\n"}
{"name":"RingHomClass.toMonoidHomClass","module":"Mathlib.Algebra.Ring.Hom.Defs","initialProofState":"F : Type u_5\nα : outParam (Type u_6)\nβ : outParam (Type u_7)\ninst✝² : NonAssocSemiring α\ninst✝¹ : NonAssocSemiring β\ninst✝ : FunLike F α β\nself : RingHomClass F α β\n⊢ MonoidHomClass F α β","decl":"/-- `RingHomClass F α β` states that `F` is a type of (semi)ring homomorphisms.\nYou should extend this class when you extend `RingHom`.\n\nThis extends from both `MonoidHomClass` and `MonoidWithZeroHomClass` in\norder to put the fields in a sensible order, even though\n`MonoidWithZeroHomClass` already extends `MonoidHomClass`. -/\nclass RingHomClass (F : Type*) (α β : outParam Type*)\n    [NonAssocSemiring α] [NonAssocSemiring β] [FunLike F α β]\n  extends MonoidHomClass F α β, AddMonoidHomClass F α β, MonoidWithZeroHomClass F α β : Prop\n\n"}
{"name":"RingHomClass.toAddMonoidHomClass","module":"Mathlib.Algebra.Ring.Hom.Defs","initialProofState":"F : Type u_5\nα : outParam (Type u_6)\nβ : outParam (Type u_7)\ninst✝² : NonAssocSemiring α\ninst✝¹ : NonAssocSemiring β\ninst✝ : FunLike F α β\nself : RingHomClass F α β\n⊢ AddMonoidHomClass F α β","decl":"/-- `RingHomClass F α β` states that `F` is a type of (semi)ring homomorphisms.\nYou should extend this class when you extend `RingHom`.\n\nThis extends from both `MonoidHomClass` and `MonoidWithZeroHomClass` in\norder to put the fields in a sensible order, even though\n`MonoidWithZeroHomClass` already extends `MonoidHomClass`. -/\nclass RingHomClass (F : Type*) (α β : outParam Type*)\n    [NonAssocSemiring α] [NonAssocSemiring β] [FunLike F α β]\n  extends MonoidHomClass F α β, AddMonoidHomClass F α β, MonoidWithZeroHomClass F α β : Prop\n\n"}
{"name":"RingHomClass.toNonUnitalRingHomClass","module":"Mathlib.Algebra.Ring.Hom.Defs","initialProofState":"F : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝ : FunLike F α β\nx✝¹ : NonAssocSemiring α\nx✝ : NonAssocSemiring β\n⊢ NonUnitalRingHomClass F α β","decl":"instance (priority := 100) RingHomClass.toNonUnitalRingHomClass : NonUnitalRingHomClass F α β :=\n  { ‹RingHomClass F α β› with }\n\n"}
{"name":"RingHom.instRingHomClass","module":"Mathlib.Algebra.Ring.Hom.Defs","initialProofState":"α : Type u_2\nβ : Type u_3\nx✝¹ : NonAssocSemiring α\nx✝ : NonAssocSemiring β\n⊢ RingHomClass (RingHom α β) α β","decl":"instance instRingHomClass : RingHomClass (α →+* β) α β where\n  map_add := RingHom.map_add'\n  map_zero := RingHom.map_zero'\n  map_mul f := f.map_mul'\n  map_one f := f.map_one'\n\n"}
{"name":"RingHom.toFun_eq_coe","module":"Mathlib.Algebra.Ring.Hom.Defs","initialProofState":"α : Type u_2\nβ : Type u_3\nx✝¹ : NonAssocSemiring α\nx✝ : NonAssocSemiring β\nf : RingHom α β\n⊢ Eq (↑f.toMonoidHom).toFun ⇑f","decl":"theorem toFun_eq_coe (f : α →+* β) : f.toFun = f :=\n  rfl\n\n"}
{"name":"RingHom.coe_mk","module":"Mathlib.Algebra.Ring.Hom.Defs","initialProofState":"α : Type u_2\nβ : Type u_3\nx✝¹ : NonAssocSemiring α\nx✝ : NonAssocSemiring β\nf : MonoidHom α β\nh₁ : Eq ((↑f).toFun 0) 0\nh₂ : ∀ (x y : α), Eq ((↑f).toFun (HAdd.hAdd x y)) (HAdd.hAdd ((↑f).toFun x) ((↑f).toFun y))\n⊢ Eq ⇑{ toMonoidHom := f, map_zero' := h₁, map_add' := h₂ } ⇑f","decl":"@[simp]\ntheorem coe_mk (f : α →* β) (h₁ h₂) : ((⟨f, h₁, h₂⟩ : α →+* β) : α → β) = f :=\n  rfl\n\n"}
{"name":"RingHom.coe_coe","module":"Mathlib.Algebra.Ring.Hom.Defs","initialProofState":"α : Type u_2\nβ : Type u_3\nx✝¹ : NonAssocSemiring α\nx✝ : NonAssocSemiring β\nF : Type u_5\ninst✝¹ : FunLike F α β\ninst✝ : RingHomClass F α β\nf : F\n⊢ Eq ⇑↑f ⇑f","decl":"@[simp]\ntheorem coe_coe {F : Type*} [FunLike F α β] [RingHomClass F α β] (f : F) :\n    ((f : α →+* β) : α → β) = f :=\n  rfl\n\n"}
{"name":"RingHom.toMonoidHom_eq_coe","module":"Mathlib.Algebra.Ring.Hom.Defs","initialProofState":"α : Type u_2\nβ : Type u_3\nx✝¹ : NonAssocSemiring α\nx✝ : NonAssocSemiring β\nf : RingHom α β\n⊢ Eq ↑f ↑f","decl":"@[simp]\ntheorem toMonoidHom_eq_coe (f : α →+* β) : f.toMonoidHom = f :=\n  rfl\n\n-- Porting note: this can't be a simp lemma anymore\n-- @[simp]\n"}
{"name":"RingHom.toMonoidWithZeroHom_eq_coe","module":"Mathlib.Algebra.Ring.Hom.Defs","initialProofState":"α : Type u_2\nβ : Type u_3\nx✝¹ : NonAssocSemiring α\nx✝ : NonAssocSemiring β\nf : RingHom α β\n⊢ Eq ⇑f.toMonoidWithZeroHom ⇑f","decl":"theorem toMonoidWithZeroHom_eq_coe (f : α →+* β) : (f.toMonoidWithZeroHom : α → β) = f := by\n  rfl\n\n"}
{"name":"RingHom.coe_monoidHom_mk","module":"Mathlib.Algebra.Ring.Hom.Defs","initialProofState":"α : Type u_2\nβ : Type u_3\nx✝¹ : NonAssocSemiring α\nx✝ : NonAssocSemiring β\nf : MonoidHom α β\nh₁ : Eq ((↑f).toFun 0) 0\nh₂ : ∀ (x y : α), Eq ((↑f).toFun (HAdd.hAdd x y)) (HAdd.hAdd ((↑f).toFun x) ((↑f).toFun y))\n⊢ Eq (↑{ toMonoidHom := f, map_zero' := h₁, map_add' := h₂ }) f","decl":"@[simp]\ntheorem coe_monoidHom_mk (f : α →* β) (h₁ h₂) : ((⟨f, h₁, h₂⟩ : α →+* β) : α →* β) = f :=\n  rfl\n\n-- Porting note: `dsimp only` can prove this\n\n"}
{"name":"RingHom.toAddMonoidHom_eq_coe","module":"Mathlib.Algebra.Ring.Hom.Defs","initialProofState":"α : Type u_2\nβ : Type u_3\nx✝¹ : NonAssocSemiring α\nx✝ : NonAssocSemiring β\nf : RingHom α β\n⊢ Eq f.toAddMonoidHom ↑f","decl":"@[simp]\ntheorem toAddMonoidHom_eq_coe (f : α →+* β) : f.toAddMonoidHom = f :=\n  rfl\n\n"}
{"name":"RingHom.coe_addMonoidHom_mk","module":"Mathlib.Algebra.Ring.Hom.Defs","initialProofState":"α : Type u_2\nβ : Type u_3\nx✝¹ : NonAssocSemiring α\nx✝ : NonAssocSemiring β\nf : α → β\nh₁ : Eq (f 1) 1\nh₂ : ∀ (x y : α), Eq ({ toFun := f, map_one' := h₁ }.toFun (HMul.hMul x y)) (HMul.hMul ({ toFun := f, map_one' := h₁ }.toFun x) ({ toFun := f, map_one' := h₁ }.toFun y))\nh₃ : Eq ((↑{ toFun := f, map_one' := h₁, map_mul' := h₂ }).toFun 0) 0\nh₄ : ∀ (x y : α), Eq ((↑{ toFun := f, map_one' := h₁, map_mul' := h₂ }).toFun (HAdd.hAdd x y)) (HAdd.hAdd ((↑{ toFun := f, map_one' := h₁, map_mul' := h₂ }).toFun x) ((↑{ toFun := f, map_one' := h₁, map_mul' := h₂ }).toFun y))\n⊢ Eq ↑{ toFun := f, map_one' := h₁, map_mul' := h₂, map_zero' := h₃, map_add' := h₄ } { toFun := f, map_zero' := h₃, map_add' := h₄ }","decl":"@[simp]\ntheorem coe_addMonoidHom_mk (f : α → β) (h₁ h₂ h₃ h₄) :\n    ((⟨⟨⟨f, h₁⟩, h₂⟩, h₃, h₄⟩ : α →+* β) : α →+ β) = ⟨⟨f, h₃⟩, h₄⟩ :=\n  rfl\n\n"}
{"name":"RingHom.coe_copy","module":"Mathlib.Algebra.Ring.Hom.Defs","initialProofState":"α : Type u_2\nβ : Type u_3\nx✝¹ : NonAssocSemiring α\nx✝ : NonAssocSemiring β\nf : RingHom α β\nf' : α → β\nh : Eq f' ⇑f\n⊢ Eq (⇑(f.copy f' h)) f'","decl":"@[simp]\ntheorem coe_copy (f : α →+* β) (f' : α → β) (h : f' = f) : ⇑(f.copy f' h) = f' :=\n  rfl\n\n"}
{"name":"RingHom.copy_eq","module":"Mathlib.Algebra.Ring.Hom.Defs","initialProofState":"α : Type u_2\nβ : Type u_3\nx✝¹ : NonAssocSemiring α\nx✝ : NonAssocSemiring β\nf : RingHom α β\nf' : α → β\nh : Eq f' ⇑f\n⊢ Eq (f.copy f' h) f","decl":"theorem copy_eq (f : α →+* β) (f' : α → β) (h : f' = f) : f.copy f' h = f :=\n  DFunLike.ext' h\n\n"}
{"name":"RingHom.congr_fun","module":"Mathlib.Algebra.Ring.Hom.Defs","initialProofState":"α : Type u_2\nβ : Type u_3\nx✝¹ : NonAssocSemiring α\nx✝ : NonAssocSemiring β\nf g : RingHom α β\nh : Eq f g\nx : α\n⊢ Eq (f x) (g x)","decl":"protected theorem congr_fun {f g : α →+* β} (h : f = g) (x : α) : f x = g x :=\n  DFunLike.congr_fun h x\n\n"}
{"name":"RingHom.congr_arg","module":"Mathlib.Algebra.Ring.Hom.Defs","initialProofState":"α : Type u_2\nβ : Type u_3\nx✝¹ : NonAssocSemiring α\nx✝ : NonAssocSemiring β\nf : RingHom α β\nx y : α\nh : Eq x y\n⊢ Eq (f x) (f y)","decl":"protected theorem congr_arg (f : α →+* β) {x y : α} (h : x = y) : f x = f y :=\n  DFunLike.congr_arg f h\n\n"}
{"name":"RingHom.coe_inj","module":"Mathlib.Algebra.Ring.Hom.Defs","initialProofState":"α : Type u_2\nβ : Type u_3\nx✝¹ : NonAssocSemiring α\nx✝ : NonAssocSemiring β\nf g : RingHom α β\nh : Eq ⇑f ⇑g\n⊢ Eq f g","decl":"theorem coe_inj ⦃f g : α →+* β⦄ (h : (f : α → β) = g) : f = g :=\n  DFunLike.coe_injective h\n\n"}
{"name":"RingHom.ext_iff","module":"Mathlib.Algebra.Ring.Hom.Defs","initialProofState":"α : Type u_2\nβ : Type u_3\nx✝¹ : NonAssocSemiring α\nx✝ : NonAssocSemiring β\nf g : RingHom α β\n⊢ Iff (Eq f g) (∀ (x : α), Eq (f x) (g x))","decl":"@[ext]\ntheorem ext ⦃f g : α →+* β⦄ : (∀ x, f x = g x) → f = g :=\n  DFunLike.ext _ _\n\n"}
{"name":"RingHom.ext","module":"Mathlib.Algebra.Ring.Hom.Defs","initialProofState":"α : Type u_2\nβ : Type u_3\nx✝¹ : NonAssocSemiring α\nx✝ : NonAssocSemiring β\nf g : RingHom α β\na✝ : ∀ (x : α), Eq (f x) (g x)\n⊢ Eq f g","decl":"@[ext]\ntheorem ext ⦃f g : α →+* β⦄ : (∀ x, f x = g x) → f = g :=\n  DFunLike.ext _ _\n\n"}
{"name":"RingHom.mk_coe","module":"Mathlib.Algebra.Ring.Hom.Defs","initialProofState":"α : Type u_2\nβ : Type u_3\nx✝¹ : NonAssocSemiring α\nx✝ : NonAssocSemiring β\nf : RingHom α β\nh₁ : Eq (f 1) 1\nh₂ : ∀ (x y : α), Eq ({ toFun := ⇑f, map_one' := h₁ }.toFun (HMul.hMul x y)) (HMul.hMul ({ toFun := ⇑f, map_one' := h₁ }.toFun x) ({ toFun := ⇑f, map_one' := h₁ }.toFun y))\nh₃ : Eq ((↑{ toFun := ⇑f, map_one' := h₁, map_mul' := h₂ }).toFun 0) 0\nh₄ : ∀ (x y : α), Eq ((↑{ toFun := ⇑f, map_one' := h₁, map_mul' := h₂ }).toFun (HAdd.hAdd x y)) (HAdd.hAdd ((↑{ toFun := ⇑f, map_one' := h₁, map_mul' := h₂ }).toFun x) ((↑{ toFun := ⇑f, map_one' := h₁, map_mul' := h₂ }).toFun y))\n⊢ Eq { toFun := ⇑f, map_one' := h₁, map_mul' := h₂, map_zero' := h₃, map_add' := h₄ } f","decl":"@[simp]\ntheorem mk_coe (f : α →+* β) (h₁ h₂ h₃ h₄) : RingHom.mk ⟨⟨f, h₁⟩, h₂⟩ h₃ h₄ = f :=\n  ext fun _ => rfl\n\n"}
{"name":"RingHom.coe_addMonoidHom_injective","module":"Mathlib.Algebra.Ring.Hom.Defs","initialProofState":"α : Type u_2\nβ : Type u_3\nx✝¹ : NonAssocSemiring α\nx✝ : NonAssocSemiring β\n⊢ Function.Injective fun f => ↑f","decl":"theorem coe_addMonoidHom_injective : Injective (fun f : α →+* β => (f : α →+ β)) := fun _ _ h =>\n  ext <| DFunLike.congr_fun (F := α →+ β) h\n\n"}
{"name":"RingHom.coe_monoidHom_injective","module":"Mathlib.Algebra.Ring.Hom.Defs","initialProofState":"α : Type u_2\nβ : Type u_3\nx✝¹ : NonAssocSemiring α\nx✝ : NonAssocSemiring β\n⊢ Function.Injective fun f => ↑f","decl":"theorem coe_monoidHom_injective : Injective (fun f : α →+* β => (f : α →* β)) :=\n  Injective.of_comp (f := DFunLike.coe) DFunLike.coe_injective\n\n"}
{"name":"RingHom.map_zero","module":"Mathlib.Algebra.Ring.Hom.Defs","initialProofState":"α : Type u_2\nβ : Type u_3\nx✝¹ : NonAssocSemiring α\nx✝ : NonAssocSemiring β\nf : RingHom α β\n⊢ Eq (f 0) 0","decl":"/-- Ring homomorphisms map zero to zero. -/\nprotected theorem map_zero (f : α →+* β) : f 0 = 0 :=\n  map_zero f\n\n"}
{"name":"RingHom.map_one","module":"Mathlib.Algebra.Ring.Hom.Defs","initialProofState":"α : Type u_2\nβ : Type u_3\nx✝¹ : NonAssocSemiring α\nx✝ : NonAssocSemiring β\nf : RingHom α β\n⊢ Eq (f 1) 1","decl":"/-- Ring homomorphisms map one to one. -/\nprotected theorem map_one (f : α →+* β) : f 1 = 1 :=\n  map_one f\n\n"}
{"name":"RingHom.map_add","module":"Mathlib.Algebra.Ring.Hom.Defs","initialProofState":"α : Type u_2\nβ : Type u_3\nx✝¹ : NonAssocSemiring α\nx✝ : NonAssocSemiring β\nf : RingHom α β\na b : α\n⊢ Eq (f (HAdd.hAdd a b)) (HAdd.hAdd (f a) (f b))","decl":"/-- Ring homomorphisms preserve addition. -/\nprotected theorem map_add (f : α →+* β) : ∀ a b, f (a + b) = f a + f b :=\n  map_add f\n\n"}
{"name":"RingHom.map_mul","module":"Mathlib.Algebra.Ring.Hom.Defs","initialProofState":"α : Type u_2\nβ : Type u_3\nx✝¹ : NonAssocSemiring α\nx✝ : NonAssocSemiring β\nf : RingHom α β\na b : α\n⊢ Eq (f (HMul.hMul a b)) (HMul.hMul (f a) (f b))","decl":"/-- Ring homomorphisms preserve multiplication. -/\nprotected theorem map_mul (f : α →+* β) : ∀ a b, f (a * b) = f a * f b :=\n  map_mul f\n\n"}
{"name":"RingHom.map_ite_zero_one","module":"Mathlib.Algebra.Ring.Hom.Defs","initialProofState":"α : Type u_2\nβ : Type u_3\nx✝¹ : NonAssocSemiring α\nx✝ : NonAssocSemiring β\nF : Type u_5\ninst✝² : FunLike F α β\ninst✝¹ : RingHomClass F α β\nf : F\np : Prop\ninst✝ : Decidable p\n⊢ Eq (f (ite p 0 1)) (ite p 0 1)","decl":"@[simp]\ntheorem map_ite_zero_one {F : Type*} [FunLike F α β] [RingHomClass F α β] (f : F)\n    (p : Prop) [Decidable p] :\n    f (ite p 0 1) = ite p 0 1 := by\n  split_ifs with h <;> simp [h]\n\n"}
{"name":"RingHom.map_ite_one_zero","module":"Mathlib.Algebra.Ring.Hom.Defs","initialProofState":"α : Type u_2\nβ : Type u_3\nx✝¹ : NonAssocSemiring α\nx✝ : NonAssocSemiring β\nF : Type u_5\ninst✝² : FunLike F α β\ninst✝¹ : RingHomClass F α β\nf : F\np : Prop\ninst✝ : Decidable p\n⊢ Eq (f (ite p 1 0)) (ite p 1 0)","decl":"@[simp]\ntheorem map_ite_one_zero {F : Type*} [FunLike F α β] [RingHomClass F α β] (f : F)\n    (p : Prop) [Decidable p] :\n    f (ite p 1 0) = ite p 1 0 := by\n  split_ifs with h <;> simp [h]\n\n"}
{"name":"RingHom.codomain_trivial_iff_map_one_eq_zero","module":"Mathlib.Algebra.Ring.Hom.Defs","initialProofState":"α : Type u_2\nβ : Type u_3\nx✝¹ : NonAssocSemiring α\nx✝ : NonAssocSemiring β\nf : RingHom α β\n⊢ Iff (Eq 0 1) (Eq (f 1) 0)","decl":"/-- `f : α →+* β` has a trivial codomain iff `f 1 = 0`. -/\ntheorem codomain_trivial_iff_map_one_eq_zero : (0 : β) = 1 ↔ f 1 = 0 := by rw [map_one, eq_comm]\n\n"}
{"name":"RingHom.codomain_trivial_iff_range_trivial","module":"Mathlib.Algebra.Ring.Hom.Defs","initialProofState":"α : Type u_2\nβ : Type u_3\nx✝¹ : NonAssocSemiring α\nx✝ : NonAssocSemiring β\nf : RingHom α β\n⊢ Iff (Eq 0 1) (∀ (x : α), Eq (f x) 0)","decl":"/-- `f : α →+* β` has a trivial codomain iff it has a trivial range. -/\ntheorem codomain_trivial_iff_range_trivial : (0 : β) = 1 ↔ ∀ x, f x = 0 :=\n  f.codomain_trivial_iff_map_one_eq_zero.trans\n    ⟨fun h x => by rw [← mul_one x, map_mul, h, mul_zero], fun h => h 1⟩\n\n"}
{"name":"RingHom.map_one_ne_zero","module":"Mathlib.Algebra.Ring.Hom.Defs","initialProofState":"α : Type u_2\nβ : Type u_3\nx✝¹ : NonAssocSemiring α\nx✝ : NonAssocSemiring β\nf : RingHom α β\ninst✝ : Nontrivial β\n⊢ Ne (f 1) 0","decl":"/-- `f : α →+* β` doesn't map `1` to `0` if `β` is nontrivial -/\ntheorem map_one_ne_zero [Nontrivial β] : f 1 ≠ 0 :=\n  mt f.codomain_trivial_iff_map_one_eq_zero.mpr zero_ne_one\n\n"}
{"name":"RingHom.domain_nontrivial","module":"Mathlib.Algebra.Ring.Hom.Defs","initialProofState":"α : Type u_2\nβ : Type u_3\nx✝¹ : NonAssocSemiring α\nx✝ : NonAssocSemiring β\nf : RingHom α β\ninst✝ : Nontrivial β\n⊢ Nontrivial α","decl":"include f in\n/-- If there is a homomorphism `f : α →+* β` and `β` is nontrivial, then `α` is nontrivial. -/\ntheorem domain_nontrivial [Nontrivial β] : Nontrivial α :=\n  ⟨⟨1, 0, mt (fun h => show f 1 = 0 by rw [h, map_zero]) f.map_one_ne_zero⟩⟩\n\n"}
{"name":"RingHom.codomain_trivial","module":"Mathlib.Algebra.Ring.Hom.Defs","initialProofState":"α : Type u_2\nβ : Type u_3\nx✝¹ : NonAssocSemiring α\nx✝ : NonAssocSemiring β\nf : RingHom α β\nh : Subsingleton α\n⊢ Subsingleton β","decl":"theorem codomain_trivial (f : α →+* β) [h : Subsingleton α] : Subsingleton β :=\n  (subsingleton_or_nontrivial β).resolve_right fun _ =>\n    not_nontrivial_iff_subsingleton.mpr h f.domain_nontrivial\n\n"}
{"name":"RingHom.map_neg","module":"Mathlib.Algebra.Ring.Hom.Defs","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : NonAssocRing α\ninst✝ : NonAssocRing β\nf : RingHom α β\nx : α\n⊢ Eq (f (Neg.neg x)) (Neg.neg (f x))","decl":"/-- Ring homomorphisms preserve additive inverse. -/\nprotected theorem map_neg [NonAssocRing α] [NonAssocRing β] (f : α →+* β) (x : α) : f (-x) = -f x :=\n  map_neg f x\n\n"}
{"name":"RingHom.map_sub","module":"Mathlib.Algebra.Ring.Hom.Defs","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : NonAssocRing α\ninst✝ : NonAssocRing β\nf : RingHom α β\nx y : α\n⊢ Eq (f (HSub.hSub x y)) (HSub.hSub (f x) (f y))","decl":"/-- Ring homomorphisms preserve subtraction. -/\nprotected theorem map_sub [NonAssocRing α] [NonAssocRing β] (f : α →+* β) (x y : α) :\n    f (x - y) = f x - f y :=\n  map_sub f x y\n\n"}
{"name":"RingHom.coe_id","module":"Mathlib.Algebra.Ring.Hom.Defs","initialProofState":"α : Type u_2\nx✝ : NonAssocSemiring α\n⊢ Eq (⇑(RingHom.id α)) id","decl":"@[simp, norm_cast]\ntheorem coe_id : ⇑(RingHom.id α) = _root_.id := rfl\n\n"}
{"name":"RingHom.id_apply","module":"Mathlib.Algebra.Ring.Hom.Defs","initialProofState":"α : Type u_2\nx✝ : NonAssocSemiring α\nx : α\n⊢ Eq ((RingHom.id α) x) x","decl":"@[simp]\ntheorem id_apply (x : α) : RingHom.id α x = x :=\n  rfl\n\n"}
{"name":"RingHom.coe_addMonoidHom_id","module":"Mathlib.Algebra.Ring.Hom.Defs","initialProofState":"α : Type u_2\nx✝ : NonAssocSemiring α\n⊢ Eq (↑(RingHom.id α)) (AddMonoidHom.id α)","decl":"@[simp]\ntheorem coe_addMonoidHom_id : (id α : α →+ α) = AddMonoidHom.id α :=\n  rfl\n\n"}
{"name":"RingHom.coe_monoidHom_id","module":"Mathlib.Algebra.Ring.Hom.Defs","initialProofState":"α : Type u_2\nx✝ : NonAssocSemiring α\n⊢ Eq (↑(RingHom.id α)) (MonoidHom.id α)","decl":"@[simp]\ntheorem coe_monoidHom_id : (id α : α →* α) = MonoidHom.id α :=\n  rfl\n\n"}
{"name":"RingHom.comp_assoc","module":"Mathlib.Algebra.Ring.Hom.Defs","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\nx✝³ : NonAssocSemiring α\nx✝² : NonAssocSemiring β\nx✝¹ : NonAssocSemiring γ\nδ : Type u_5\nx✝ : NonAssocSemiring δ\nf : RingHom α β\ng : RingHom β γ\nh : RingHom γ δ\n⊢ Eq ((h.comp g).comp f) (h.comp (g.comp f))","decl":"/-- Composition of semiring homomorphisms is associative. -/\ntheorem comp_assoc {δ} {_ : NonAssocSemiring δ} (f : α →+* β) (g : β →+* γ) (h : γ →+* δ) :\n    (h.comp g).comp f = h.comp (g.comp f) :=\n  rfl\n\n"}
{"name":"RingHom.coe_comp","module":"Mathlib.Algebra.Ring.Hom.Defs","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\nx✝² : NonAssocSemiring α\nx✝¹ : NonAssocSemiring β\nx✝ : NonAssocSemiring γ\nhnp : RingHom β γ\nhmn : RingHom α β\n⊢ Eq (⇑(hnp.comp hmn)) (Function.comp ⇑hnp ⇑hmn)","decl":"@[simp]\ntheorem coe_comp (hnp : β →+* γ) (hmn : α →+* β) : (hnp.comp hmn : α → γ) = hnp ∘ hmn :=\n  rfl\n\n"}
{"name":"RingHom.comp_apply","module":"Mathlib.Algebra.Ring.Hom.Defs","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\nx✝² : NonAssocSemiring α\nx✝¹ : NonAssocSemiring β\nx✝ : NonAssocSemiring γ\nhnp : RingHom β γ\nhmn : RingHom α β\nx : α\n⊢ Eq ((hnp.comp hmn) x) (hnp (hmn x))","decl":"theorem comp_apply (hnp : β →+* γ) (hmn : α →+* β) (x : α) :\n    (hnp.comp hmn : α → γ) x = hnp (hmn x) :=\n  rfl\n\n"}
{"name":"RingHom.comp_id","module":"Mathlib.Algebra.Ring.Hom.Defs","initialProofState":"α : Type u_2\nβ : Type u_3\nx✝¹ : NonAssocSemiring α\nx✝ : NonAssocSemiring β\nf : RingHom α β\n⊢ Eq (f.comp (RingHom.id α)) f","decl":"@[simp]\ntheorem comp_id (f : α →+* β) : f.comp (id α) = f :=\n  ext fun _ => rfl\n\n"}
{"name":"RingHom.id_comp","module":"Mathlib.Algebra.Ring.Hom.Defs","initialProofState":"α : Type u_2\nβ : Type u_3\nx✝¹ : NonAssocSemiring α\nx✝ : NonAssocSemiring β\nf : RingHom α β\n⊢ Eq ((RingHom.id β).comp f) f","decl":"@[simp]\ntheorem id_comp (f : α →+* β) : (id β).comp f = f :=\n  ext fun _ => rfl\n\n"}
{"name":"RingHom.one_def","module":"Mathlib.Algebra.Ring.Hom.Defs","initialProofState":"α : Type u_2\nx✝ : NonAssocSemiring α\n⊢ Eq 1 (RingHom.id α)","decl":"lemma one_def : (1 : α →+* α) = id α := rfl\n\n"}
{"name":"RingHom.mul_def","module":"Mathlib.Algebra.Ring.Hom.Defs","initialProofState":"α : Type u_2\nx✝ : NonAssocSemiring α\nf g : RingHom α α\n⊢ Eq (HMul.hMul f g) (f.comp g)","decl":"lemma mul_def (f g : α →+* α) : f * g = f.comp g := rfl\n\n"}
{"name":"RingHom.coe_one","module":"Mathlib.Algebra.Ring.Hom.Defs","initialProofState":"α : Type u_2\nx✝ : NonAssocSemiring α\n⊢ Eq (⇑1) id","decl":"@[simp, norm_cast] lemma coe_one : ⇑(1 : α →+* α) = _root_.id := rfl\n\n"}
{"name":"RingHom.coe_mul","module":"Mathlib.Algebra.Ring.Hom.Defs","initialProofState":"α : Type u_2\nx✝ : NonAssocSemiring α\nf g : RingHom α α\n⊢ Eq (⇑(HMul.hMul f g)) (Function.comp ⇑f ⇑g)","decl":"@[simp, norm_cast] lemma coe_mul (f g : α →+* α) : ⇑(f * g) = f ∘ g := rfl\n\n"}
{"name":"RingHom.coe_pow","module":"Mathlib.Algebra.Ring.Hom.Defs","initialProofState":"α : Type u_2\nx✝ : NonAssocSemiring α\nf : RingHom α α\nn : Nat\n⊢ Eq (⇑(HPow.hPow f n)) (Nat.iterate (⇑f) n)","decl":"@[simp, norm_cast] lemma coe_pow (f : α →+* α) (n : ℕ) : ⇑(f ^ n) = f^[n] := rfl\n\n"}
{"name":"RingHom.cancel_right","module":"Mathlib.Algebra.Ring.Hom.Defs","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\nx✝² : NonAssocSemiring α\nx✝¹ : NonAssocSemiring β\nx✝ : NonAssocSemiring γ\ng₁ g₂ : RingHom β γ\nf : RingHom α β\nhf : Function.Surjective ⇑f\n⊢ Iff (Eq (g₁.comp f) (g₂.comp f)) (Eq g₁ g₂)","decl":"@[simp]\ntheorem cancel_right {g₁ g₂ : β →+* γ} {f : α →+* β} (hf : Surjective f) :\n    g₁.comp f = g₂.comp f ↔ g₁ = g₂ :=\n  ⟨fun h => RingHom.ext <| hf.forall.2 (RingHom.ext_iff.1 h), fun h => h ▸ rfl⟩\n\n"}
{"name":"RingHom.cancel_left","module":"Mathlib.Algebra.Ring.Hom.Defs","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\nx✝² : NonAssocSemiring α\nx✝¹ : NonAssocSemiring β\nx✝ : NonAssocSemiring γ\ng : RingHom β γ\nf₁ f₂ : RingHom α β\nhg : Function.Injective ⇑g\n⊢ Iff (Eq (g.comp f₁) (g.comp f₂)) (Eq f₁ f₂)","decl":"@[simp]\ntheorem cancel_left {g : β →+* γ} {f₁ f₂ : α →+* β} (hg : Injective g) :\n    g.comp f₁ = g.comp f₂ ↔ f₁ = f₂ :=\n  ⟨fun h => RingHom.ext fun x => hg <| by rw [← comp_apply, h, comp_apply], fun h => h ▸ rfl⟩\n\n"}
{"name":"RingHom.map_pow","module":"Mathlib.Algebra.Ring.Hom.Defs","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Semiring α\ninst✝ : Semiring β\nf : RingHom α β\na : α\nn : Nat\n⊢ Eq (f (HPow.hPow a n)) (HPow.hPow (f a) n)","decl":"protected lemma RingHom.map_pow (f : α →+* β) (a) : ∀ n : ℕ, f (a ^ n) = f a ^ n := map_pow f a\n\n"}
{"name":"AddMonoidHom.coe_fn_mkRingHomOfMulSelfOfTwoNeZero","module":"Mathlib.Algebra.Ring.Hom.Defs","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝² : CommRing α\ninst✝¹ : IsDomain α\ninst✝ : CommRing β\nf : AddMonoidHom β α\nh : ∀ (x : β), Eq (f (HMul.hMul x x)) (HMul.hMul (f x) (f x))\nh_two : Ne 2 0\nh_one : Eq (f 1) 1\n⊢ Eq ⇑(f.mkRingHomOfMulSelfOfTwoNeZero h h_two h_one) ⇑f","decl":"@[simp]\ntheorem coe_fn_mkRingHomOfMulSelfOfTwoNeZero (h h_two h_one) :\n    (f.mkRingHomOfMulSelfOfTwoNeZero h h_two h_one : β → α) = f :=\n  rfl\n\n"}
{"name":"AddMonoidHom.coe_addMonoidHom_mkRingHomOfMulSelfOfTwoNeZero","module":"Mathlib.Algebra.Ring.Hom.Defs","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝² : CommRing α\ninst✝¹ : IsDomain α\ninst✝ : CommRing β\nf : AddMonoidHom β α\nh : ∀ (x : β), Eq (f (HMul.hMul x x)) (HMul.hMul (f x) (f x))\nh_two : Ne 2 0\nh_one : Eq (f 1) 1\n⊢ Eq (↑(f.mkRingHomOfMulSelfOfTwoNeZero h h_two h_one)) f","decl":"@[simp]\ntheorem coe_addMonoidHom_mkRingHomOfMulSelfOfTwoNeZero (h h_two h_one) :\n    (f.mkRingHomOfMulSelfOfTwoNeZero h h_two h_one : β →+ α) = f := by\n  ext\n  rfl\n\n"}
