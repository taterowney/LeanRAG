{"name":"Function.Embedding.schroeder_bernstein","module":"Mathlib.SetTheory.Cardinal.SchroederBernstein","initialProofState":"α : Type u\nβ : Type v\nf : α → β\ng : β → α\nhf : Function.Injective f\nhg : Function.Injective g\n⊢ Exists fun h => Function.Bijective h","decl":"/-- **The Schröder-Bernstein Theorem**:\nGiven injections `α → β` and `β → α`, we can get a bijection `α → β`. -/\ntheorem schroeder_bernstein {f : α → β} {g : β → α} (hf : Function.Injective f)\n    (hg : Function.Injective g) : ∃ h : α → β, Bijective h := by\n  classical\n  cases' isEmpty_or_nonempty β with hβ hβ\n  · have : IsEmpty α := Function.isEmpty f\n    exact ⟨_, ((Equiv.equivEmpty α).trans (Equiv.equivEmpty β).symm).bijective⟩\n  set F : Set α →o Set α :=\n    { toFun := fun s => (g '' (f '' s)ᶜ)ᶜ\n      monotone' := fun s t hst =>\n        compl_subset_compl.mpr <| image_subset _ <| compl_subset_compl.mpr <| image_subset _ hst }\n  set s : Set α := F.lfp\n  have hs : (g '' (f '' s)ᶜ)ᶜ = s := F.map_lfp\n  have hns : g '' (f '' s)ᶜ = sᶜ := compl_injective (by simp [hs])\n  set g' := invFun g\n  have g'g : LeftInverse g' g := leftInverse_invFun hg\n  have hg'ns : g' '' sᶜ = (f '' s)ᶜ := by rw [← hns, g'g.image_image]\n  set h : α → β := s.piecewise f g'\n  have : Surjective h := by rw [← range_eq_univ, range_piecewise, hg'ns, union_compl_self]\n  have : Injective h := by\n    refine (injective_piecewise_iff _).2 ⟨hf.injOn, ?_, ?_⟩\n    · intro x hx y hy hxy\n      obtain ⟨x', _, rfl⟩ : x ∈ g '' (f '' s)ᶜ := by rwa [hns]\n      obtain ⟨y', _, rfl⟩ : y ∈ g '' (f '' s)ᶜ := by rwa [hns]\n      rw [g'g _, g'g _] at hxy\n      rw [hxy]\n    · intro x hx y hy hxy\n      obtain ⟨y', hy', rfl⟩ : y ∈ g '' (f '' s)ᶜ := by rwa [hns]\n      rw [g'g _] at hxy\n      exact hy' ⟨x, hx, hxy⟩\n  exact ⟨h, ‹Injective h›, ‹Surjective h›⟩\n\n"}
{"name":"Function.Embedding.antisymm","module":"Mathlib.SetTheory.Cardinal.SchroederBernstein","initialProofState":"α : Type u\nβ : Type v\na✝¹ : Function.Embedding α β\na✝ : Function.Embedding β α\n⊢ Nonempty (Equiv α β)","decl":"/-- **The Schröder-Bernstein Theorem**: Given embeddings `α ↪ β` and `β ↪ α`, there exists an\nequivalence `α ≃ β`. -/\ntheorem antisymm : (α ↪ β) → (β ↪ α) → Nonempty (α ≃ β)\n  | ⟨_, h₁⟩, ⟨_, h₂⟩ =>\n    let ⟨f, hf⟩ := schroeder_bernstein h₁ h₂\n    ⟨Equiv.ofBijective f hf⟩\n\n"}
{"name":"Function.Embedding.min_injective","module":"Mathlib.SetTheory.Cardinal.SchroederBernstein","initialProofState":"ι : Type u\nβ : ι → Type v\nI : Nonempty ι\n⊢ Exists fun i => Nonempty ((j : ι) → Function.Embedding (β i) (β j))","decl":"/-- The cardinals are well-ordered. We express it here by the fact that in any set of cardinals\nthere is an element that injects into the others.\nSee `Cardinal.conditionallyCompleteLinearOrderBot` for (one of) the lattice instances. -/\ntheorem min_injective [I : Nonempty ι] : ∃ i, Nonempty (∀ j, β i ↪ β j) :=\n  let ⟨s, hs⟩ := show ∃ s, Maximal (· ∈ sets β) s by\n    refine zorn_subset _ fun c hc hcc ↦\n      ⟨⋃₀ c, fun i x ⟨p, hpc, hxp⟩ y ⟨q, hqc, hyq⟩ hi ↦ ?_, fun _ ↦ subset_sUnion_of_mem⟩\n    exact (hcc.total hpc hqc).elim (fun h ↦ hc hqc i (h hxp) hyq hi)\n      fun h ↦ hc hpc i hxp (h hyq) hi\n  let ⟨i, e⟩ :=\n    show ∃ i, Surjective fun x : s => x.val i from\n      Classical.by_contradiction fun h =>\n        have h : ∀ i, ∃ y, ∀ x ∈ s, (x : ∀ i, β i) i ≠ y := by\n          simpa [Surjective] using h\n        let ⟨f, hf⟩ := Classical.axiom_of_choice h\n        have : f ∈ s :=\n          have : insert f s ∈ sets β := fun i x hx y hy => by\n            cases' hx with hx hx <;> cases' hy with hy hy; · simp [hx, hy]\n            · subst x\n              exact fun e => (hf i y hy e.symm).elim\n            · subst y\n              exact fun e => (hf i x hx e).elim\n            · exact hs.prop i hx hy\n          hs.eq_of_subset this (subset_insert _ _) ▸ mem_insert ..\n        let ⟨i⟩ := I\n        hf i f this rfl\n  ⟨i, ⟨fun j => ⟨s.restrict (fun x => x j) ∘ surjInv e,\n    ((hs.1 j).injective).comp (injective_surjInv _)⟩⟩⟩\n\n"}
{"name":"Function.Embedding.total","module":"Mathlib.SetTheory.Cardinal.SchroederBernstein","initialProofState":"α : Type u\nβ : Type v\n⊢ Or (Nonempty (Function.Embedding α β)) (Nonempty (Function.Embedding β α))","decl":"/-- The cardinals are totally ordered. See\n`Cardinal.conditionallyCompleteLinearOrderBot` for (one of) the lattice\ninstance. -/\n-- Porting note: `ULift.{max u v, u} α` was `ULift α`\ntheorem total (α : Type u) (β : Type v) : Nonempty (α ↪ β) ∨ Nonempty (β ↪ α) :=\n  match @min_injective Bool (fun b => cond b (ULift.{max u v, u} α) (ULift.{max u v, v} β)) ⟨true⟩\n    with\n  | ⟨true, ⟨h⟩⟩ =>\n    let ⟨f, hf⟩ := h false\n    Or.inl ⟨Embedding.congr Equiv.ulift Equiv.ulift ⟨f, hf⟩⟩\n  | ⟨false, ⟨h⟩⟩ =>\n    let ⟨f, hf⟩ := h true\n    Or.inr ⟨Embedding.congr Equiv.ulift Equiv.ulift ⟨f, hf⟩⟩\n\n"}
