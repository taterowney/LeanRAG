{"name":"UniqueFactorizationMonoid.prime_pow_coprime_prod_of_coprime_insert","module":"Mathlib.RingTheory.UniqueFactorizationDomain.Multiplicative","initialProofState":"α : Type u_1\ninst✝² : CancelCommMonoidWithZero α\ninst✝¹ : UniqueFactorizationMonoid α\ninst✝ : DecidableEq α\ns : Finset α\ni : α → Nat\np : α\nhps : Not (Membership.mem s p)\nis_prime : ∀ (q : α), Membership.mem (Insert.insert p s) q → Prime q\nis_coprime : ∀ (q : α), Membership.mem (Insert.insert p s) q → ∀ (q' : α), Membership.mem (Insert.insert p s) q' → Dvd.dvd q q' → Eq q q'\n⊢ IsRelPrime (HPow.hPow p (i p)) (s.prod fun p' => HPow.hPow p' (i p'))","decl":"theorem prime_pow_coprime_prod_of_coprime_insert [DecidableEq α] {s : Finset α} (i : α → ℕ) (p : α)\n    (hps : p ∉ s) (is_prime : ∀ q ∈ insert p s, Prime q)\n    (is_coprime : ∀ᵉ (q ∈ insert p s) (q' ∈ insert p s), q ∣ q' → q = q') :\n    IsRelPrime (p ^ i p) (∏ p' ∈ s, p' ^ i p') := by\n  have hp := is_prime _ (Finset.mem_insert_self _ _)\n  refine (isRelPrime_iff_no_prime_factors <| pow_ne_zero _ hp.ne_zero).mpr ?_\n  intro d hdp hdprod hd\n  apply hps\n  replace hdp := hd.dvd_of_dvd_pow hdp\n  obtain ⟨q, q_mem', hdq⟩ := hd.exists_mem_multiset_dvd hdprod\n  obtain ⟨q, q_mem, rfl⟩ := Multiset.mem_map.mp q_mem'\n  replace hdq := hd.dvd_of_dvd_pow hdq\n  have : p ∣ q := dvd_trans (hd.irreducible.dvd_symm hp.irreducible hdp) hdq\n  convert q_mem using 0\n  rw [Finset.mem_val,\n    is_coprime _ (Finset.mem_insert_self p s) _ (Finset.mem_insert_of_mem q_mem) this]\n\n"}
{"name":"UniqueFactorizationMonoid.induction_on_prime_power","module":"Mathlib.RingTheory.UniqueFactorizationDomain.Multiplicative","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : UniqueFactorizationMonoid α\nP : α → Prop\ns : Finset α\ni : α → Nat\nis_prime : ∀ (p : α), Membership.mem s p → Prime p\nis_coprime : ∀ (p : α), Membership.mem s p → ∀ (q : α), Membership.mem s q → Dvd.dvd p q → Eq p q\nh1 : ∀ {x : α}, IsUnit x → P x\nhpr : ∀ {p : α} (i : Nat), Prime p → P (HPow.hPow p i)\nhcp : ∀ {x y : α}, IsRelPrime x y → P x → P y → P (HMul.hMul x y)\n⊢ P (s.prod fun p => HPow.hPow p (i p))","decl":"/-- If `P` holds for units and powers of primes,\nand `P x ∧ P y` for coprime `x, y` implies `P (x * y)`,\nthen `P` holds on a product of powers of distinct primes. -/\n@[elab_as_elim]\ntheorem induction_on_prime_power {P : α → Prop} (s : Finset α) (i : α → ℕ)\n    (is_prime : ∀ p ∈ s, Prime p) (is_coprime : ∀ᵉ (p ∈ s) (q ∈ s), p ∣ q → p = q)\n    (h1 : ∀ {x}, IsUnit x → P x) (hpr : ∀ {p} (i : ℕ), Prime p → P (p ^ i))\n    (hcp : ∀ {x y}, IsRelPrime x y → P x → P y → P (x * y)) :\n    P (∏ p ∈ s, p ^ i p) := by\n  letI := Classical.decEq α\n  induction' s using Finset.induction_on with p f' hpf' ih\n  · simpa using h1 isUnit_one\n  rw [Finset.prod_insert hpf']\n  exact\n    hcp (prime_pow_coprime_prod_of_coprime_insert i p hpf' is_prime is_coprime)\n      (hpr (i p) (is_prime _ (Finset.mem_insert_self _ _)))\n      (ih (fun q hq => is_prime _ (Finset.mem_insert_of_mem hq)) fun q hq q' hq' =>\n        is_coprime _ (Finset.mem_insert_of_mem hq) _ (Finset.mem_insert_of_mem hq'))\n\n"}
{"name":"UniqueFactorizationMonoid.induction_on_coprime","module":"Mathlib.RingTheory.UniqueFactorizationDomain.Multiplicative","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : UniqueFactorizationMonoid α\nP : α → Prop\na : α\nh0 : P 0\nh1 : ∀ {x : α}, IsUnit x → P x\nhpr : ∀ {p : α} (i : Nat), Prime p → P (HPow.hPow p i)\nhcp : ∀ {x y : α}, IsRelPrime x y → P x → P y → P (HMul.hMul x y)\n⊢ P a","decl":"/-- If `P` holds for `0`, units and powers of primes,\nand `P x ∧ P y` for coprime `x, y` implies `P (x * y)`,\nthen `P` holds on all `a : α`. -/\n@[elab_as_elim]\ntheorem induction_on_coprime {P : α → Prop} (a : α) (h0 : P 0) (h1 : ∀ {x}, IsUnit x → P x)\n    (hpr : ∀ {p} (i : ℕ), Prime p → P (p ^ i))\n    (hcp : ∀ {x y}, IsRelPrime x y → P x → P y → P (x * y)) : P a := by\n  letI := Classical.decEq α\n  have P_of_associated : ∀ {x y}, Associated x y → P x → P y := by\n    rintro x y ⟨u, rfl⟩ hx\n    exact hcp (fun p _ hpx => isUnit_of_dvd_unit hpx u.isUnit) hx (h1 u.isUnit)\n  by_cases ha0 : a = 0\n  · rwa [ha0]\n  haveI : Nontrivial α := ⟨⟨_, _, ha0⟩⟩\n  letI : NormalizationMonoid α := UniqueFactorizationMonoid.normalizationMonoid\n  refine P_of_associated (prod_normalizedFactors ha0) ?_\n  rw [← (normalizedFactors a).map_id, Finset.prod_multiset_map_count]\n  refine induction_on_prime_power _ _ ?_ ?_ @h1 @hpr @hcp <;> simp only [Multiset.mem_toFinset]\n  · apply prime_of_normalized_factor\n  · apply normalizedFactors_eq_of_dvd\n\n"}
{"name":"UniqueFactorizationMonoid.multiplicative_prime_power","module":"Mathlib.RingTheory.UniqueFactorizationDomain.Multiplicative","initialProofState":"α : Type u_1\ninst✝² : CancelCommMonoidWithZero α\ninst✝¹ : UniqueFactorizationMonoid α\nβ : Type u_3\ninst✝ : CancelCommMonoidWithZero β\nf : α → β\ns : Finset α\ni j : α → Nat\nis_prime : ∀ (p : α), Membership.mem s p → Prime p\nis_coprime : ∀ (p : α), Membership.mem s p → ∀ (q : α), Membership.mem s q → Dvd.dvd p q → Eq p q\nh1 : ∀ {x y : α}, IsUnit y → Eq (f (HMul.hMul x y)) (HMul.hMul (f x) (f y))\nhpr : ∀ {p : α} (i : Nat), Prime p → Eq (f (HPow.hPow p i)) (HPow.hPow (f p) i)\nhcp : ∀ {x y : α}, IsRelPrime x y → Eq (f (HMul.hMul x y)) (HMul.hMul (f x) (f y))\n⊢ Eq (f (s.prod fun p => HPow.hPow p (HAdd.hAdd (i p) (j p)))) (HMul.hMul (f (s.prod fun p => HPow.hPow p (i p))) (f (s.prod fun p => HPow.hPow p (j p))))","decl":"/-- If `f` maps `p ^ i` to `(f p) ^ i` for primes `p`, and `f`\nis multiplicative on coprime elements, then `f` is multiplicative on all products of primes. -/\ntheorem multiplicative_prime_power {f : α → β} (s : Finset α) (i j : α → ℕ)\n    (is_prime : ∀ p ∈ s, Prime p) (is_coprime : ∀ᵉ (p ∈ s) (q ∈ s), p ∣ q → p = q)\n    (h1 : ∀ {x y}, IsUnit y → f (x * y) = f x * f y)\n    (hpr : ∀ {p} (i : ℕ), Prime p → f (p ^ i) = f p ^ i)\n    (hcp : ∀ {x y}, IsRelPrime x y → f (x * y) = f x * f y) :\n    f (∏ p ∈ s, p ^ (i p + j p)) = f (∏ p ∈ s, p ^ i p) * f (∏ p ∈ s, p ^ j p) := by\n  letI := Classical.decEq α\n  induction' s using Finset.induction_on with p s hps ih\n  · simpa using h1 isUnit_one\n  have hpr_p := is_prime _ (Finset.mem_insert_self _ _)\n  have hpr_s : ∀ p ∈ s, Prime p := fun p hp => is_prime _ (Finset.mem_insert_of_mem hp)\n  have hcp_p := fun i => prime_pow_coprime_prod_of_coprime_insert i p hps is_prime is_coprime\n  have hcp_s : ∀ᵉ (p ∈ s) (q ∈ s), p ∣ q → p = q := fun p hp q hq =>\n    is_coprime p (Finset.mem_insert_of_mem hp) q (Finset.mem_insert_of_mem hq)\n  rw [Finset.prod_insert hps, Finset.prod_insert hps, Finset.prod_insert hps, hcp (hcp_p _),\n    hpr _ hpr_p, hcp (hcp_p _), hpr _ hpr_p, hcp (hcp_p (fun p => i p + j p)), hpr _ hpr_p,\n    ih hpr_s hcp_s, pow_add, mul_assoc, mul_left_comm (f p ^ j p), mul_assoc]\n\n"}
{"name":"UniqueFactorizationMonoid.multiplicative_of_coprime","module":"Mathlib.RingTheory.UniqueFactorizationDomain.Multiplicative","initialProofState":"α : Type u_1\ninst✝² : CancelCommMonoidWithZero α\ninst✝¹ : UniqueFactorizationMonoid α\nβ : Type u_3\ninst✝ : CancelCommMonoidWithZero β\nf : α → β\na b : α\nh0 : Eq (f 0) 0\nh1 : ∀ {x y : α}, IsUnit y → Eq (f (HMul.hMul x y)) (HMul.hMul (f x) (f y))\nhpr : ∀ {p : α} (i : Nat), Prime p → Eq (f (HPow.hPow p i)) (HPow.hPow (f p) i)\nhcp : ∀ {x y : α}, IsRelPrime x y → Eq (f (HMul.hMul x y)) (HMul.hMul (f x) (f y))\n⊢ Eq (f (HMul.hMul a b)) (HMul.hMul (f a) (f b))","decl":"/-- If `f` maps `p ^ i` to `(f p) ^ i` for primes `p`, and `f`\nis multiplicative on coprime elements, then `f` is multiplicative everywhere. -/\ntheorem multiplicative_of_coprime (f : α → β) (a b : α) (h0 : f 0 = 0)\n    (h1 : ∀ {x y}, IsUnit y → f (x * y) = f x * f y)\n    (hpr : ∀ {p} (i : ℕ), Prime p → f (p ^ i) = f p ^ i)\n    (hcp : ∀ {x y}, IsRelPrime x y → f (x * y) = f x * f y) :\n    f (a * b) = f a * f b := by\n  letI := Classical.decEq α\n  by_cases ha0 : a = 0\n  · rw [ha0, zero_mul, h0, zero_mul]\n  by_cases hb0 : b = 0\n  · rw [hb0, mul_zero, h0, mul_zero]\n  by_cases hf1 : f 1 = 0\n  · calc\n      f (a * b) = f (a * b * 1) := by rw [mul_one]\n      _ = 0 := by simp only [h1 isUnit_one, hf1, mul_zero]\n      _ = f a * f (b * 1) := by simp only [h1 isUnit_one, hf1, mul_zero]\n      _ = f a * f b := by rw [mul_one]\n  haveI : Nontrivial α := ⟨⟨_, _, ha0⟩⟩\n  letI : NormalizationMonoid α := UniqueFactorizationMonoid.normalizationMonoid\n  suffices\n      f (∏ p ∈ (normalizedFactors a).toFinset ∪ (normalizedFactors b).toFinset,\n        p ^ ((normalizedFactors a).count p + (normalizedFactors b).count p)) =\n      f (∏ p ∈ (normalizedFactors a).toFinset ∪ (normalizedFactors b).toFinset,\n        p ^ (normalizedFactors a).count p) *\n      f (∏ p ∈ (normalizedFactors a).toFinset ∪ (normalizedFactors b).toFinset,\n        p ^ (normalizedFactors b).count p) by\n    obtain ⟨ua, a_eq⟩ := prod_normalizedFactors ha0\n    obtain ⟨ub, b_eq⟩ := prod_normalizedFactors hb0\n    rw [← a_eq, ← b_eq, mul_right_comm (Multiset.prod (normalizedFactors a)) ua\n        (Multiset.prod (normalizedFactors b) * ub), h1 ua.isUnit, h1 ub.isUnit, h1 ua.isUnit, ←\n      mul_assoc, h1 ub.isUnit, mul_right_comm _ (f ua), ← mul_assoc]\n    congr\n    rw [← (normalizedFactors a).map_id, ← (normalizedFactors b).map_id,\n      Finset.prod_multiset_map_count, Finset.prod_multiset_map_count,\n      Finset.prod_subset (Finset.subset_union_left (s₂ := (normalizedFactors b).toFinset)),\n      Finset.prod_subset (Finset.subset_union_right (s₂ := (normalizedFactors b).toFinset)), ←\n      Finset.prod_mul_distrib]\n    · simp_rw [id, ← pow_add, this]\n    all_goals simp only [Multiset.mem_toFinset]\n    · intro p _ hpb\n      simp [hpb]\n    · intro p _ hpa\n      simp [hpa]\n  refine multiplicative_prime_power _ _ _ ?_ ?_ @h1 @hpr @hcp\n  all_goals simp only [Multiset.mem_toFinset, Finset.mem_union]\n  · rintro p (hpa | hpb) <;> apply prime_of_normalized_factor <;> assumption\n  · rintro p (hp | hp) q (hq | hq) hdvd <;>\n      rw [← normalize_normalized_factor _ hp, ← normalize_normalized_factor _ hq] <;>\n      exact\n        normalize_eq_normalize hdvd\n          ((prime_of_normalized_factor _ hp).irreducible.dvd_symm\n            (prime_of_normalized_factor _ hq).irreducible hdvd)\n\n"}
