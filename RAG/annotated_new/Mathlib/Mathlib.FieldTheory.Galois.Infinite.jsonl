{"name":"InfiniteGalois.fixingSubgroup_isClosed","module":"Mathlib.FieldTheory.Galois.Infinite","initialProofState":"k : Type u_1\nK : Type u_2\ninst✝³ : Field k\ninst✝² : Field K\ninst✝¹ : Algebra k K\nL : IntermediateField k K\ninst✝ : IsGalois k K\n⊢ IsClosed ↑L.fixingSubgroup","decl":"lemma fixingSubgroup_isClosed (L : IntermediateField k K) [IsGalois k K] :\n    IsClosed (L.fixingSubgroup : Set (K ≃ₐ[k] K)) where\n    isOpen_compl := isOpen_iff_mem_nhds.mpr fun σ h => by\n      apply mem_nhds_iff.mpr\n      rcases Set.not_subset.mp ((mem_fixingSubgroup_iff (K ≃ₐ[k] K)).not.mp h) with ⟨y, yL, ne⟩\n      use σ • ((adjoin k {y}).1.fixingSubgroup : Set (K ≃ₐ[k] K))\n      constructor\n      · intro f hf\n        rcases (Set.mem_smul_set.mp hf) with ⟨g, hg, eq⟩\n        simp only [Set.mem_compl_iff, SetLike.mem_coe, ← eq]\n        apply (mem_fixingSubgroup_iff (K ≃ₐ[k] K)).not.mpr\n        push_neg\n        use y\n        simp only [yL, smul_eq_mul, AlgEquiv.smul_def, AlgEquiv.mul_apply, ne_eq, true_and]\n        have : g y = y := (mem_fixingSubgroup_iff (K ≃ₐ[k] K)).mp hg y <|\n          adjoin_simple_le_iff.mp le_rfl\n        simpa only [this, ne_eq, AlgEquiv.smul_def] using ne\n      · simp only [(IntermediateField.fixingSubgroup_isOpen (adjoin k {y}).1).smul σ, true_and]\n        use 1\n        simp only [SetLike.mem_coe, smul_eq_mul, mul_one, and_true, Subgroup.one_mem]\n\n"}
{"name":"InfiniteGalois.fixedField_fixingSubgroup","module":"Mathlib.FieldTheory.Galois.Infinite","initialProofState":"k : Type u_1\nK : Type u_2\ninst✝³ : Field k\ninst✝² : Field K\ninst✝¹ : Algebra k K\nL : IntermediateField k K\ninst✝ : IsGalois k K\n⊢ Eq (IntermediateField.fixedField L.fixingSubgroup) L","decl":"lemma fixedField_fixingSubgroup (L : IntermediateField k K) [IsGalois k K] :\n    IntermediateField.fixedField L.fixingSubgroup = L := by\n  apply le_antisymm\n  · intro x hx\n    rw [IntermediateField.mem_fixedField_iff] at hx\n    have mem : x ∈ (adjoin L {x}).1 := subset_adjoin _ _ rfl\n    have : IntermediateField.fixedField (⊤ : Subgroup ((adjoin L {x}) ≃ₐ[L] (adjoin L {x}))) = ⊥ :=\n      (IsGalois.tfae.out 0 1).mp (by infer_instance)\n    have : ⟨x, mem⟩ ∈ (⊥ : IntermediateField L (adjoin L {x})) := by\n      rw [← this, IntermediateField.mem_fixedField_iff]\n      intro f _\n      rcases restrictNormalHom_surjective K f with ⟨σ,hσ⟩\n      apply Subtype.val_injective\n      rw [← hσ, restrictNormalHom_apply (adjoin L {x}).1 σ ⟨x, mem⟩]\n      have := hx ((IntermediateField.fixingSubgroupEquiv L).symm σ)\n      simpa only [SetLike.coe_mem, true_implies]\n    rcases IntermediateField.mem_bot.mp this with ⟨y, hy⟩\n    obtain ⟨rfl⟩ : y = x := congrArg Subtype.val hy\n    exact y.2\n  · exact (IntermediateField.le_iff_le L.fixingSubgroup L).mpr le_rfl\n\n"}
{"name":"InfiniteGalois.fixedField_bot","module":"Mathlib.FieldTheory.Galois.Infinite","initialProofState":"k : Type u_1\nK : Type u_2\ninst✝³ : Field k\ninst✝² : Field K\ninst✝¹ : Algebra k K\ninst✝ : IsGalois k K\n⊢ Eq (IntermediateField.fixedField Top.top) Bot.bot","decl":"lemma fixedField_bot [IsGalois k K] :\n    IntermediateField.fixedField (⊤ : Subgroup (K ≃ₐ[k] K)) = ⊥ := by\n  rw [← IntermediateField.fixingSubgroup_bot, fixedField_fixingSubgroup]\n\n"}
{"name":"InfiniteGalois.restrict_fixedField","module":"Mathlib.FieldTheory.Galois.Infinite","initialProofState":"k : Type u_1\nK : Type u_2\ninst✝³ : Field k\ninst✝² : Field K\ninst✝¹ : Algebra k K\nH : Subgroup (AlgEquiv k K K)\nL : IntermediateField k K\ninst✝ : Normal k (Subtype fun x => Membership.mem L x)\n⊢ Eq (Min.min (IntermediateField.fixedField H) L) (IntermediateField.lift (IntermediateField.fixedField (Subgroup.map (AlgEquiv.restrictNormalHom (Subtype fun x => Membership.mem L x)) H)))","decl":"open IntermediateField in\n/--For a subgroup `H` of `Gal(K/k)`, the fixed field of the image of `H` under the restriction to\na normal intermediate field `E` is equal to the fixed field of `H` in `K` intersecting with `E`.-/\nlemma restrict_fixedField (H : Subgroup (K ≃ₐ[k] K)) (L : IntermediateField k K) [Normal k L] :\n    fixedField H ⊓ L = lift (fixedField (Subgroup.map (restrictNormalHom L) H)) := by\n  apply SetLike.ext'\n  ext x\n  refine ⟨fun h ↦ ?_, fun h ↦ ?_⟩\n  · have xL := h.out.2\n    apply (mem_lift (⟨x, xL⟩ : L)).mpr\n    simp only [mem_fixedField_iff, Subgroup.mem_map, forall_exists_index, and_imp,\n      forall_apply_eq_imp_iff₂]\n    intro σ hσ\n    apply Subtype.val_injective\n    dsimp only\n    nth_rw 2 [← (h.out.1 ⟨σ, hσ⟩)]\n    exact AlgEquiv.restrictNormal_commutes σ L ⟨x, xL⟩\n  · have xL := lift_le _ h\n    apply (mem_lift (⟨x,xL⟩ : L)).mp at h\n    simp only [mem_fixedField_iff, Subgroup.mem_map, forall_exists_index, and_imp,\n      forall_apply_eq_imp_iff₂] at h\n    simp only [coe_inf, Set.mem_inter_iff, SetLike.mem_coe, mem_fixedField_iff, xL, and_true]\n    intro σ hσ\n    have : ((restrictNormalHom L σ) ⟨x, xL⟩).1 = x := by rw [h σ hσ]\n    nth_rw 2 [← this]\n    exact (AlgEquiv.restrictNormal_commutes σ L ⟨x, xL⟩).symm\n\n"}
{"name":"InfiniteGalois.fixingSubgroup_fixedField","module":"Mathlib.FieldTheory.Galois.Infinite","initialProofState":"k : Type u_1\nK : Type u_2\ninst✝³ : Field k\ninst✝² : Field K\ninst✝¹ : Algebra k K\nH : ClosedSubgroup (AlgEquiv k K K)\ninst✝ : IsGalois k K\n⊢ Eq (IntermediateField.fixedField ↑H).fixingSubgroup ↑H","decl":"lemma fixingSubgroup_fixedField (H : ClosedSubgroup (K ≃ₐ[k] K)) [IsGalois k K] :\n    (IntermediateField.fixedField H).fixingSubgroup = H.1 := by\n  apply le_antisymm _ ((IntermediateField.le_iff_le H.toSubgroup\n    (IntermediateField.fixedField H.toSubgroup)).mp le_rfl)\n  intro σ hσ\n  by_contra h\n  have nhd : H.carrierᶜ ∈ nhds σ := H.isClosed'.isOpen_compl.mem_nhds h\n  rw [GroupFilterBasis.nhds_eq (x₀ := σ) (galGroupBasis k K)] at nhd\n  rcases nhd with ⟨b, ⟨gp, ⟨L, hL, eq'⟩, eq⟩, sub⟩\n  rw [← eq'] at eq\n  have := hL.out\n  let L' : FiniteGaloisIntermediateField k K := {\n    normalClosure k L K with\n    finiteDimensional := normalClosure.is_finiteDimensional k L K\n    isGalois := IsGalois.normalClosure k L K }\n  have compl : σ • L'.1.fixingSubgroup.carrier ⊆ H.carrierᶜ := by\n    rintro φ ⟨τ, hτ, muleq⟩\n    have sub' : σ • b ⊆ H.carrierᶜ := Set.smul_set_subset_iff.mpr sub\n    apply sub'\n    simp only [← muleq, ← eq]\n    apply Set.smul_mem_smul_set\n    exact (IntermediateField.fixingSubgroup.antimono (IntermediateField.le_normalClosure L) hτ)\n  have fix : ∀ x ∈ IntermediateField.fixedField H.toSubgroup ⊓ ↑L', σ x = x :=\n    fun x hx ↦ ((mem_fixingSubgroup_iff (K ≃ₐ[k] K)).mp hσ) x hx.1\n  rw [restrict_fixedField H.1 L'.1] at fix\n  have : (restrictNormalHom L') σ ∈ (Subgroup.map (restrictNormalHom L') H.1) := by\n    rw [← IntermediateField.fixingSubgroup_fixedField (Subgroup.map (restrictNormalHom L') H.1)]\n    apply (mem_fixingSubgroup_iff (L' ≃ₐ[k] L')).mpr\n    intro y hy\n    apply Subtype.val_injective\n    simp only [AlgEquiv.smul_def, restrictNormalHom_apply L'.1 σ y,\n      fix y.1 ((IntermediateField.mem_lift y).mpr hy)]\n  rcases this with ⟨h, mem, eq⟩\n  have : h ∈ σ • L'.1.fixingSubgroup.carrier := by\n    use σ⁻¹ * h\n    simp only [Subsemigroup.mem_carrier, Submonoid.mem_toSubsemigroup, Subgroup.mem_toSubmonoid,\n      smul_eq_mul, mul_inv_cancel_left, and_true]\n    apply (mem_fixingSubgroup_iff (K ≃ₐ[k] K)).mpr\n    intro y hy\n    simp only [AlgEquiv.smul_def, AlgEquiv.mul_apply]\n    have : ((restrictNormalHom L') h ⟨y,hy⟩).1 = ((restrictNormalHom L') σ ⟨y,hy⟩).1 := by rw [eq]\n    rw [restrictNormalHom_apply L'.1 h ⟨y, hy⟩, restrictNormalHom_apply L'.1 σ ⟨y, hy⟩] at this\n    simp only [this, ← AlgEquiv.mul_apply, inv_mul_cancel, one_apply]\n  absurd compl\n  apply Set.not_subset.mpr\n  use h\n  simpa only [this, Set.mem_compl_iff, Subsemigroup.mem_carrier, Submonoid.mem_toSubsemigroup,\n    Subgroup.mem_toSubmonoid, not_not, true_and] using mem\n\n"}
{"name":"InfiniteGalois.isOpen_iff_finite","module":"Mathlib.FieldTheory.Galois.Infinite","initialProofState":"k : Type u_1\nK : Type u_2\ninst✝³ : Field k\ninst✝² : Field K\ninst✝¹ : Algebra k K\nL : IntermediateField k K\ninst✝ : IsGalois k K\n⊢ Iff (IsOpen L.fixingSubgroup.carrier) (FiniteDimensional k (Subtype fun x => Membership.mem L x))","decl":"theorem isOpen_iff_finite (L : IntermediateField k K) [IsGalois k K] :\n    IsOpen L.fixingSubgroup.carrier ↔ FiniteDimensional k L := by\n  refine ⟨fun h ↦ ?_, fun h ↦ IntermediateField.fixingSubgroup_isOpen L⟩\n  have : (IntermediateFieldEquivClosedSubgroup.toFun L).carrier ∈ nhds 1 :=\n    IsOpen.mem_nhds h (congrFun rfl)\n  rw [GroupFilterBasis.nhds_one_eq] at this\n  rcases this with ⟨S, ⟨gp, ⟨M, hM, eq'⟩, eq⟩, sub⟩\n  rw [← eq, ← eq'] at sub\n  have := hM.out\n  let L' : FiniteGaloisIntermediateField k K := {\n    normalClosure k M K with\n    finiteDimensional := normalClosure.is_finiteDimensional k M K\n    isGalois := IsGalois.normalClosure k M K }\n  have : L ≤ L'.1 := by\n    apply LE.le.trans _ (IntermediateField.le_normalClosure M)\n    rw [←  fixedField_fixingSubgroup M, IntermediateField.le_iff_le]\n    exact sub\n  let _ : Algebra L L'.1 := RingHom.toAlgebra (IntermediateField.inclusion this)\n  exact FiniteDimensional.left k L L'.1\n\n"}
{"name":"InfiniteGalois.normal_iff_isGalois","module":"Mathlib.FieldTheory.Galois.Infinite","initialProofState":"k : Type u_1\nK : Type u_2\ninst✝³ : Field k\ninst✝² : Field K\ninst✝¹ : Algebra k K\nL : IntermediateField k K\ninst✝ : IsGalois k K\n⊢ Iff L.fixingSubgroup.Normal (IsGalois k (Subtype fun x => Membership.mem L x))","decl":"theorem normal_iff_isGalois (L : IntermediateField k K) [IsGalois k K] :\n    L.fixingSubgroup.Normal ↔ IsGalois k L := by\n  refine ⟨fun h ↦ ?_, fun h ↦ ?_⟩\n  · let f : L → IntermediateField k K := fun x => IntermediateField.lift <|\n      IntermediateField.fixedField <| Subgroup.map (restrictNormalHom (adjoin k {x.1}))\n      L.fixingSubgroup\n    have h' (x : K) : (Subgroup.map (restrictNormalHom (adjoin k {x})) L.fixingSubgroup).Normal :=\n      Subgroup.Normal.map h (restrictNormalHom (adjoin k {x})) (restrictNormalHom_surjective K)\n    have n' (l : L) : IsGalois k (IntermediateField.fixedField <| Subgroup.map\n      (restrictNormalHom (adjoin k {l.1})) L.fixingSubgroup) := by\n      let _ := IsGalois.of_fixedField_normal_subgroup (Subgroup.map (restrictNormalHom\n        (adjoin k {l.1})) L.fixingSubgroup)\n      let cH := (Subgroup.map (restrictNormalHom (adjoin k {l.1})) L.fixingSubgroup)\n      exact IsGalois.of_algEquiv <| IntermediateField.liftAlgEquiv (IntermediateField.fixedField cH)\n    have n : Normal k ↥(⨆ (l : L), f l) := IntermediateField.normal_iSup k K f\n    have : (⨆ (l : L), f l) = L := by\n      apply le_antisymm\n      · apply iSup_le\n        intro l\n        simpa only [f, ← restrict_fixedField L.fixingSubgroup (adjoin k {l.1}),\n          fixedField_fixingSubgroup L] using inf_le_left\n      · intro l hl\n        apply le_iSup f ⟨l,hl⟩\n        simpa only [f, ← restrict_fixedField L.fixingSubgroup (adjoin k {l}),\n          fixedField_fixingSubgroup L, IntermediateField.mem_inf, hl, true_and]\n          using adjoin_simple_le_iff.mp le_rfl\n    rw [this] at n\n    let _ : Algebra.IsSeparable k L := Algebra.isSeparable_tower_bot_of_isSeparable k L K\n    apply IsGalois.mk\n  · simpa only [IntermediateFieldEquivClosedSubgroup, RelIso.coe_fn_mk, Equiv.coe_fn_mk,\n      ← L.restrictNormalHom_ker] using MonoidHom.normal_ker (restrictNormalHom L)\n\n"}
{"name":"InfiniteGalois.isOpen_and_normal_iff_finite_and_isGalois","module":"Mathlib.FieldTheory.Galois.Infinite","initialProofState":"k : Type u_1\nK : Type u_2\ninst✝³ : Field k\ninst✝² : Field K\ninst✝¹ : Algebra k K\nL : IntermediateField k K\ninst✝ : IsGalois k K\n⊢ Iff (And (IsOpen L.fixingSubgroup.carrier) L.fixingSubgroup.Normal) (And (FiniteDimensional k (Subtype fun x => Membership.mem L x)) (IsGalois k (Subtype fun x => Membership.mem L x)))","decl":"theorem isOpen_and_normal_iff_finite_and_isGalois (L : IntermediateField k K) [IsGalois k K] :\n    IsOpen L.fixingSubgroup.carrier ∧ L.fixingSubgroup.Normal ↔\n    FiniteDimensional k L ∧ IsGalois k L := by\n  rw [isOpen_iff_finite, normal_iff_isGalois]\n\n"}
