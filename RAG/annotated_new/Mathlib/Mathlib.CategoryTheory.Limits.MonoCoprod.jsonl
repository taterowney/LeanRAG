{"name":"CategoryTheory.Limits.MonoCoprod.binaryCofan_inl","module":"Mathlib.CategoryTheory.Limits.MonoCoprod","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nself : CategoryTheory.Limits.MonoCoprod C\nA B : C\nc : CategoryTheory.Limits.BinaryCofan A B\nx‚úù : CategoryTheory.Limits.IsColimit c\n‚ä¢ CategoryTheory.Mono c.inl","decl":"/-- This condition expresses that inclusion morphisms into coproducts are monomorphisms. -/\nclass MonoCoprod : Prop where\n  /-- the left inclusion of a colimit binary cofan is mono -/\n  binaryCofan_inl : ‚àÄ ‚¶ÉA B : C‚¶Ñ (c : BinaryCofan A B) (_ : IsColimit c), Mono c.inl\n\n"}
{"name":"CategoryTheory.Limits.monoCoprodOfHasZeroMorphisms","module":"Mathlib.CategoryTheory.Limits.MonoCoprod","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\n‚ä¢ CategoryTheory.Limits.MonoCoprod C","decl":"instance (priority := 100) monoCoprodOfHasZeroMorphisms [HasZeroMorphisms C] : MonoCoprod C :=\n  ‚ü®fun A B c hc => by\n    haveI : IsSplitMono c.inl :=\n      IsSplitMono.mk' (SplitMono.mk (hc.desc (BinaryCofan.mk (ùüô A) 0)) (IsColimit.fac _ _ _))\n    infer_instance‚ü©\n\n"}
{"name":"CategoryTheory.Limits.MonoCoprod.binaryCofan_inr","module":"Mathlib.CategoryTheory.Limits.MonoCoprod","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\nA B : C\ninst‚úù : CategoryTheory.Limits.MonoCoprod C\nc : CategoryTheory.Limits.BinaryCofan A B\nhc : CategoryTheory.Limits.IsColimit c\n‚ä¢ CategoryTheory.Mono c.inr","decl":"theorem binaryCofan_inr {A B : C} [MonoCoprod C] (c : BinaryCofan A B) (hc : IsColimit c) :\n    Mono c.inr := by\n  haveI hc' : IsColimit (BinaryCofan.mk c.inr c.inl) :=\n    BinaryCofan.IsColimit.mk _ (fun f‚ÇÅ f‚ÇÇ => hc.desc (BinaryCofan.mk f‚ÇÇ f‚ÇÅ))\n      (by simp) (by simp)\n      (fun f‚ÇÅ f‚ÇÇ m h‚ÇÅ h‚ÇÇ => BinaryCofan.IsColimit.hom_ext hc (by aesop_cat) (by aesop_cat))\n  exact binaryCofan_inl _ hc'\n\n"}
{"name":"CategoryTheory.Limits.MonoCoprod.instMonoInl","module":"Mathlib.CategoryTheory.Limits.MonoCoprod","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} C\nA B : C\ninst‚úù¬π : CategoryTheory.Limits.MonoCoprod C\ninst‚úù : CategoryTheory.Limits.HasBinaryCoproduct A B\n‚ä¢ CategoryTheory.Mono CategoryTheory.Limits.coprod.inl","decl":"instance {A B : C} [MonoCoprod C] [HasBinaryCoproduct A B] : Mono (coprod.inl : A ‚ü∂ A ‚®ø B) :=\n  binaryCofan_inl _ (colimit.isColimit _)\n\n"}
{"name":"CategoryTheory.Limits.MonoCoprod.instMonoInr","module":"Mathlib.CategoryTheory.Limits.MonoCoprod","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} C\nA B : C\ninst‚úù¬π : CategoryTheory.Limits.MonoCoprod C\ninst‚úù : CategoryTheory.Limits.HasBinaryCoproduct A B\n‚ä¢ CategoryTheory.Mono CategoryTheory.Limits.coprod.inr","decl":"instance {A B : C} [MonoCoprod C] [HasBinaryCoproduct A B] : Mono (coprod.inr : B ‚ü∂ A ‚®ø B) :=\n  binaryCofan_inr _ (colimit.isColimit _)\n\n"}
{"name":"CategoryTheory.Limits.MonoCoprod.mono_inl_iff","module":"Mathlib.CategoryTheory.Limits.MonoCoprod","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nA B : C\nc‚ÇÅ c‚ÇÇ : CategoryTheory.Limits.BinaryCofan A B\nhc‚ÇÅ : CategoryTheory.Limits.IsColimit c‚ÇÅ\nhc‚ÇÇ : CategoryTheory.Limits.IsColimit c‚ÇÇ\n‚ä¢ Iff (CategoryTheory.Mono c‚ÇÅ.inl) (CategoryTheory.Mono c‚ÇÇ.inl)","decl":"theorem mono_inl_iff {A B : C} {c‚ÇÅ c‚ÇÇ : BinaryCofan A B} (hc‚ÇÅ : IsColimit c‚ÇÅ) (hc‚ÇÇ : IsColimit c‚ÇÇ) :\n    Mono c‚ÇÅ.inl ‚Üî Mono c‚ÇÇ.inl := by\n  suffices\n    ‚àÄ (c‚ÇÅ c‚ÇÇ : BinaryCofan A B) (_ : IsColimit c‚ÇÅ) (_ : IsColimit c‚ÇÇ) (_ : Mono c‚ÇÅ.inl),\n      Mono c‚ÇÇ.inl\n    by exact ‚ü®fun h‚ÇÅ => this _ _ hc‚ÇÅ hc‚ÇÇ h‚ÇÅ, fun h‚ÇÇ => this _ _ hc‚ÇÇ hc‚ÇÅ h‚ÇÇ‚ü©\n  intro c‚ÇÅ c‚ÇÇ hc‚ÇÅ hc‚ÇÇ\n  intro\n  simpa only [IsColimit.comp_coconePointUniqueUpToIso_hom] using\n    mono_comp c‚ÇÅ.inl (hc‚ÇÅ.coconePointUniqueUpToIso hc‚ÇÇ).hom\n\n"}
{"name":"CategoryTheory.Limits.MonoCoprod.mk'","module":"Mathlib.CategoryTheory.Limits.MonoCoprod","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nh : ‚àÄ (A B : C), Exists fun c => Exists fun x => CategoryTheory.Mono c.inl\n‚ä¢ CategoryTheory.Limits.MonoCoprod C","decl":"theorem mk' (h : ‚àÄ A B : C, ‚àÉ (c : BinaryCofan A B) (_ : IsColimit c), Mono c.inl) : MonoCoprod C :=\n  ‚ü®fun A B c' hc' => by\n    obtain ‚ü®c, hc‚ÇÅ, hc‚ÇÇ‚ü© := h A B\n    simpa only [mono_inl_iff hc' hc‚ÇÅ] using hc‚ÇÇ‚ü©\n\n"}
{"name":"CategoryTheory.Limits.MonoCoprod.monoCoprodType","module":"Mathlib.CategoryTheory.Limits.MonoCoprod","initialProofState":"‚ä¢ CategoryTheory.Limits.MonoCoprod (Type u)","decl":"instance monoCoprodType : MonoCoprod (Type u) :=\n  MonoCoprod.mk' fun A B => by\n    refine ‚ü®BinaryCofan.mk (Sum.inl : A ‚ü∂ A ‚äï B) Sum.inr, ?_, ?_‚ü©\n    ¬∑ exact BinaryCofan.IsColimit.mk _\n        (fun f‚ÇÅ f‚ÇÇ x => by\n          rcases x with x | x\n          exacts [f‚ÇÅ x, f‚ÇÇ x])\n        (fun f‚ÇÅ f‚ÇÇ => by rfl)\n        (fun f‚ÇÅ f‚ÇÇ => by rfl)\n        (fun f‚ÇÅ f‚ÇÇ m h‚ÇÅ h‚ÇÇ => by\n          funext x\n          rcases x with x | x\n          ¬∑ exact congr_fun h‚ÇÅ x\n          ¬∑ exact congr_fun h‚ÇÇ x)\n    ¬∑ rw [mono_iff_injective]\n      intro a‚ÇÅ a‚ÇÇ h\n      simpa using h\n\n"}
{"name":"CategoryTheory.Limits.MonoCoprod.mono_binaryCofanSum_inl","module":"Mathlib.CategoryTheory.Limits.MonoCoprod","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_4, u_1} C\nI‚ÇÅ : Type u_2\nI‚ÇÇ : Type u_3\nX : Sum I‚ÇÅ I‚ÇÇ ‚Üí C\nc : CategoryTheory.Limits.Cofan X\nc‚ÇÅ : CategoryTheory.Limits.Cofan (Function.comp X Sum.inl)\nc‚ÇÇ : CategoryTheory.Limits.Cofan (Function.comp X Sum.inr)\nhc : CategoryTheory.Limits.IsColimit c\nhc‚ÇÅ : CategoryTheory.Limits.IsColimit c‚ÇÅ\nhc‚ÇÇ : CategoryTheory.Limits.IsColimit c‚ÇÇ\ninst‚úù : CategoryTheory.Limits.MonoCoprod C\n‚ä¢ CategoryTheory.Mono (CategoryTheory.Limits.MonoCoprod.binaryCofanSum c c‚ÇÅ c‚ÇÇ hc‚ÇÅ hc‚ÇÇ).inl","decl":"lemma mono_binaryCofanSum_inl [MonoCoprod C] :\n    Mono (binaryCofanSum c c‚ÇÅ c‚ÇÇ hc‚ÇÅ hc‚ÇÇ).inl :=\n  MonoCoprod.binaryCofan_inl _ (isColimitBinaryCofanSum c c‚ÇÅ c‚ÇÇ hc hc‚ÇÅ hc‚ÇÇ)\n\n"}
{"name":"CategoryTheory.Limits.MonoCoprod.mono_binaryCofanSum_inr","module":"Mathlib.CategoryTheory.Limits.MonoCoprod","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_4, u_1} C\nI‚ÇÅ : Type u_2\nI‚ÇÇ : Type u_3\nX : Sum I‚ÇÅ I‚ÇÇ ‚Üí C\nc : CategoryTheory.Limits.Cofan X\nc‚ÇÅ : CategoryTheory.Limits.Cofan (Function.comp X Sum.inl)\nc‚ÇÇ : CategoryTheory.Limits.Cofan (Function.comp X Sum.inr)\nhc : CategoryTheory.Limits.IsColimit c\nhc‚ÇÅ : CategoryTheory.Limits.IsColimit c‚ÇÅ\nhc‚ÇÇ : CategoryTheory.Limits.IsColimit c‚ÇÇ\ninst‚úù : CategoryTheory.Limits.MonoCoprod C\n‚ä¢ CategoryTheory.Mono (CategoryTheory.Limits.MonoCoprod.binaryCofanSum c c‚ÇÅ c‚ÇÇ hc‚ÇÅ hc‚ÇÇ).inr","decl":"lemma mono_binaryCofanSum_inr [MonoCoprod C] :\n    Mono (binaryCofanSum c c‚ÇÅ c‚ÇÇ hc‚ÇÅ hc‚ÇÇ).inr :=\n  MonoCoprod.binaryCofan_inr _ (isColimitBinaryCofanSum c c‚ÇÅ c‚ÇÇ hc hc‚ÇÅ hc‚ÇÇ)\n\n"}
{"name":"CategoryTheory.Limits.MonoCoprod.mono_binaryCofanSum_inl'","module":"Mathlib.CategoryTheory.Limits.MonoCoprod","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_4, u_1} C\nI‚ÇÅ : Type u_2\nI‚ÇÇ : Type u_3\nX : Sum I‚ÇÅ I‚ÇÇ ‚Üí C\nc : CategoryTheory.Limits.Cofan X\nc‚ÇÅ : CategoryTheory.Limits.Cofan (Function.comp X Sum.inl)\nc‚ÇÇ : CategoryTheory.Limits.Cofan (Function.comp X Sum.inr)\nhc : CategoryTheory.Limits.IsColimit c\nhc‚ÇÅ : CategoryTheory.Limits.IsColimit c‚ÇÅ\nhc‚ÇÇ : CategoryTheory.Limits.IsColimit c‚ÇÇ\ninst‚úù : CategoryTheory.Limits.MonoCoprod C\ninl : Quiver.Hom c‚ÇÅ.pt c.pt\nhinl : ‚àÄ (i‚ÇÅ : I‚ÇÅ), Eq (CategoryTheory.CategoryStruct.comp (c‚ÇÅ.inj i‚ÇÅ) inl) (c.inj (Sum.inl i‚ÇÅ))\n‚ä¢ CategoryTheory.Mono inl","decl":"lemma mono_binaryCofanSum_inl' [MonoCoprod C] (inl : c‚ÇÅ.pt ‚ü∂ c.pt)\n    (hinl : ‚àÄ (i‚ÇÅ : I‚ÇÅ), c‚ÇÅ.inj i‚ÇÅ ‚â´ inl = c.inj (Sum.inl i‚ÇÅ)) :\n    Mono inl := by\n  suffices inl = (binaryCofanSum c c‚ÇÅ c‚ÇÇ hc‚ÇÅ hc‚ÇÇ).inl by\n    rw [this]\n    exact MonoCoprod.binaryCofan_inl _ (isColimitBinaryCofanSum c c‚ÇÅ c‚ÇÇ hc hc‚ÇÅ hc‚ÇÇ)\n  exact Cofan.IsColimit.hom_ext hc‚ÇÅ _ _ (by simpa using hinl)\n\n"}
{"name":"CategoryTheory.Limits.MonoCoprod.mono_binaryCofanSum_inr'","module":"Mathlib.CategoryTheory.Limits.MonoCoprod","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_4, u_1} C\nI‚ÇÅ : Type u_2\nI‚ÇÇ : Type u_3\nX : Sum I‚ÇÅ I‚ÇÇ ‚Üí C\nc : CategoryTheory.Limits.Cofan X\nc‚ÇÅ : CategoryTheory.Limits.Cofan (Function.comp X Sum.inl)\nc‚ÇÇ : CategoryTheory.Limits.Cofan (Function.comp X Sum.inr)\nhc : CategoryTheory.Limits.IsColimit c\nhc‚ÇÅ : CategoryTheory.Limits.IsColimit c‚ÇÅ\nhc‚ÇÇ : CategoryTheory.Limits.IsColimit c‚ÇÇ\ninst‚úù : CategoryTheory.Limits.MonoCoprod C\ninr : Quiver.Hom c‚ÇÇ.pt c.pt\nhinr : ‚àÄ (i‚ÇÇ : I‚ÇÇ), Eq (CategoryTheory.CategoryStruct.comp (c‚ÇÇ.inj i‚ÇÇ) inr) (c.inj (Sum.inr i‚ÇÇ))\n‚ä¢ CategoryTheory.Mono inr","decl":"lemma mono_binaryCofanSum_inr' [MonoCoprod C] (inr : c‚ÇÇ.pt ‚ü∂ c.pt)\n    (hinr : ‚àÄ (i‚ÇÇ : I‚ÇÇ), c‚ÇÇ.inj i‚ÇÇ ‚â´ inr = c.inj (Sum.inr i‚ÇÇ)) :\n    Mono inr := by\n  suffices inr = (binaryCofanSum c c‚ÇÅ c‚ÇÇ hc‚ÇÅ hc‚ÇÇ).inr by\n    rw [this]\n    exact MonoCoprod.binaryCofan_inr _ (isColimitBinaryCofanSum c c‚ÇÅ c‚ÇÇ hc hc‚ÇÅ hc‚ÇÇ)\n  exact Cofan.IsColimit.hom_ext hc‚ÇÇ _ _ (by simpa using hinr)\n\n"}
{"name":"CategoryTheory.Limits.MonoCoprod.mono_of_injective_aux","module":"Mathlib.CategoryTheory.Limits.MonoCoprod","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù : CategoryTheory.Limits.MonoCoprod C\nI : Type u_2\nJ : Type u_3\nX : I ‚Üí C\nŒπ : J ‚Üí I\nhŒπ : Function.Injective Œπ\nc : CategoryTheory.Limits.Cofan X\nc‚ÇÅ : CategoryTheory.Limits.Cofan (Function.comp X Œπ)\nhc : CategoryTheory.Limits.IsColimit c\nhc‚ÇÅ : CategoryTheory.Limits.IsColimit c‚ÇÅ\nc‚ÇÇ : CategoryTheory.Limits.Cofan fun k => X ‚Üëk\nhc‚ÇÇ : CategoryTheory.Limits.IsColimit c‚ÇÇ\n‚ä¢ CategoryTheory.Mono (CategoryTheory.Limits.Cofan.IsColimit.desc hc‚ÇÅ fun i => c.inj (Œπ i))","decl":"lemma mono_of_injective_aux (hŒπ : Function.Injective Œπ) (c : Cofan X) (c‚ÇÅ : Cofan (X ‚àò Œπ))\n    (hc : IsColimit c) (hc‚ÇÅ : IsColimit c‚ÇÅ)\n    (c‚ÇÇ : Cofan (fun (k : ((Set.range Œπ)·∂ú : Set I)) => X k.1))\n    (hc‚ÇÇ : IsColimit c‚ÇÇ) : Mono (Cofan.IsColimit.desc hc‚ÇÅ (fun i => c.inj (Œπ i))) := by\n  classical\n  let e := ((Equiv.ofInjective Œπ hŒπ).sumCongr (Equiv.refl _)).trans (Equiv.Set.sumCompl _)\n  refine mono_binaryCofanSum_inl' (Cofan.mk c.pt (fun i' => c.inj (e i'))) _ _ ?_\n    hc‚ÇÅ hc‚ÇÇ _ (by simp [e])\n  exact IsColimit.ofIsoColimit ((IsColimit.ofCoconeEquiv (Cocones.equivalenceOfReindexing\n    (Discrete.equivalence e) (Iso.refl _))).symm hc) (Cocones.ext (Iso.refl _))\n\n"}
{"name":"CategoryTheory.Limits.MonoCoprod.mono_of_injective","module":"Mathlib.CategoryTheory.Limits.MonoCoprod","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù¬π : CategoryTheory.Limits.MonoCoprod C\nI : Type u_2\nJ : Type u_3\nX : I ‚Üí C\nŒπ : J ‚Üí I\nhŒπ : Function.Injective Œπ\nc : CategoryTheory.Limits.Cofan X\nc‚ÇÅ : CategoryTheory.Limits.Cofan (Function.comp X Œπ)\nhc : CategoryTheory.Limits.IsColimit c\nhc‚ÇÅ : CategoryTheory.Limits.IsColimit c‚ÇÅ\ninst‚úù : CategoryTheory.Limits.HasCoproduct fun k => X ‚Üëk\n‚ä¢ CategoryTheory.Mono (CategoryTheory.Limits.Cofan.IsColimit.desc hc‚ÇÅ fun i => c.inj (Œπ i))","decl":"include hc in\nlemma mono_of_injective [HasCoproduct (fun (k : ((Set.range Œπ)·∂ú : Set I)) => X k.1)] :\n    Mono (Cofan.IsColimit.desc hc‚ÇÅ (fun i => c.inj (Œπ i))) :=\n  mono_of_injective_aux X Œπ hŒπ c c‚ÇÅ hc hc‚ÇÅ _ (colimit.isColimit _)\n\n"}
{"name":"CategoryTheory.Limits.MonoCoprod.mono_of_injective'","module":"Mathlib.CategoryTheory.Limits.MonoCoprod","initialProofState":"C : Type u_1\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù¬≥ : CategoryTheory.Limits.MonoCoprod C\nI : Type u_2\nJ : Type u_3\nX : I ‚Üí C\nŒπ : J ‚Üí I\nhŒπ : Function.Injective Œπ\ninst‚úù¬≤ : CategoryTheory.Limits.HasCoproduct (Function.comp X Œπ)\ninst‚úù¬π : CategoryTheory.Limits.HasCoproduct X\ninst‚úù : CategoryTheory.Limits.HasCoproduct fun k => X ‚Üëk\n‚ä¢ CategoryTheory.Mono (CategoryTheory.Limits.Sigma.desc fun j => CategoryTheory.Limits.Sigma.Œπ X (Œπ j))","decl":"lemma mono_of_injective' [HasCoproduct (X ‚àò Œπ)] [HasCoproduct X]\n    [HasCoproduct (fun (k : ((Set.range Œπ)·∂ú : Set I)) => X k.1)] :\n    Mono (Sigma.desc (f := X ‚àò Œπ) (fun j => Sigma.Œπ X (Œπ j))) :=\n  mono_of_injective X Œπ hŒπ _ _ (colimit.isColimit _) (colimit.isColimit _)\n\n"}
{"name":"CategoryTheory.Limits.MonoCoprod.mono_map'_of_injective","module":"Mathlib.CategoryTheory.Limits.MonoCoprod","initialProofState":"C : Type u_1\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù¬≥ : CategoryTheory.Limits.MonoCoprod C\nI : Type u_2\nJ : Type u_3\nX : I ‚Üí C\nŒπ : J ‚Üí I\nhŒπ : Function.Injective Œπ\ninst‚úù¬≤ : CategoryTheory.Limits.HasCoproduct (Function.comp X Œπ)\ninst‚úù¬π : CategoryTheory.Limits.HasCoproduct X\ninst‚úù : CategoryTheory.Limits.HasCoproduct fun k => X ‚Üëk\n‚ä¢ CategoryTheory.Mono (CategoryTheory.Limits.Sigma.map' Œπ fun j => CategoryTheory.CategoryStruct.id (Function.comp X Œπ j))","decl":"lemma mono_map'_of_injective [HasCoproduct (X ‚àò Œπ)] [HasCoproduct X]\n    [HasCoproduct (fun (k : ((Set.range Œπ)·∂ú : Set I)) => X k.1)] :\n    Mono (Sigma.map' Œπ (fun j => ùüô ((X ‚àò Œπ) j))) := by\n  convert mono_of_injective' X Œπ hŒπ\n  apply Sigma.hom_ext\n  intro j\n  rw [Sigma.Œπ_comp_map', id_comp, colimit.Œπ_desc]\n  simp\n\n"}
{"name":"CategoryTheory.Limits.MonoCoprod.mono_inj","module":"Mathlib.CategoryTheory.Limits.MonoCoprod","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_3, u_1} C\ninst‚úù¬π : CategoryTheory.Limits.MonoCoprod C\nI : Type u_2\nX : I ‚Üí C\nc : CategoryTheory.Limits.Cofan X\nh : CategoryTheory.Limits.IsColimit c\ni : I\ninst‚úù : CategoryTheory.Limits.HasCoproduct fun k => X ‚Üëk\n‚ä¢ CategoryTheory.Mono (c.inj i)","decl":"lemma mono_inj (c : Cofan X) (h : IsColimit c) (i : I)\n    [HasCoproduct (fun (k : ((Set.range (fun _ : Unit ‚Ü¶ i))·∂ú : Set I)) => X k.1)] :\n    Mono (Cofan.inj c i) := by\n  let Œπ : Unit ‚Üí I := fun _ ‚Ü¶ i\n  have hŒπ : Function.Injective Œπ := fun _ _ _ ‚Ü¶ rfl\n  exact mono_of_injective X Œπ hŒπ c (Cofan.mk (X i) (fun _ ‚Ü¶ ùüô _)) h\n    (mkCofanColimit _ (fun s => s.inj ()))\n\n"}
{"name":"CategoryTheory.Limits.MonoCoprod.mono_Œπ","module":"Mathlib.CategoryTheory.Limits.MonoCoprod","initialProofState":"C : Type u_1\ninst‚úù¬≥ : CategoryTheory.Category.{u_3, u_1} C\ninst‚úù¬≤ : CategoryTheory.Limits.MonoCoprod C\nI : Type u_2\nX : I ‚Üí C\ninst‚úù¬π : CategoryTheory.Limits.HasCoproduct X\ni : I\ninst‚úù : CategoryTheory.Limits.HasCoproduct fun k => X ‚Üëk\n‚ä¢ CategoryTheory.Mono (CategoryTheory.Limits.Sigma.Œπ X i)","decl":"instance mono_Œπ [HasCoproduct X] (i : I)\n    [HasCoproduct (fun (k : ((Set.range (fun _ : Unit ‚Ü¶ i))·∂ú : Set I)) => X k.1)] :\n    Mono (Sigma.Œπ X i) :=\n  mono_inj X _ (colimit.isColimit _) i\n\n"}
{"name":"CategoryTheory.Limits.MonoCoprod.monoCoprod_of_preservesCoprod_of_reflectsMono","module":"Mathlib.CategoryTheory.Limits.MonoCoprod","initialProofState":"C : Type u_1\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_4, u_1} C\nD : Type u_2\ninst‚úù¬≥ : CategoryTheory.Category.{u_3, u_2} D\nF : CategoryTheory.Functor C D\ninst‚úù¬≤ : CategoryTheory.Limits.MonoCoprod D\ninst‚úù¬π : CategoryTheory.Limits.PreservesColimitsOfShape (CategoryTheory.Discrete CategoryTheory.Limits.WalkingPair) F\ninst‚úù : F.ReflectsMonomorphisms\n‚ä¢ CategoryTheory.Limits.MonoCoprod C","decl":"theorem monoCoprod_of_preservesCoprod_of_reflectsMono [MonoCoprod D]\n    [PreservesColimitsOfShape (Discrete WalkingPair) F]\n    [ReflectsMonomorphisms F] : MonoCoprod C where\n  binaryCofan_inl {A B} c h := by\n    let c' := BinaryCofan.mk (F.map c.inl) (F.map c.inr)\n    apply mono_of_mono_map F\n    show Mono c'.inl\n    apply MonoCoprod.binaryCofan_inl\n    apply mapIsColimitOfPreservesOfIsColimit F\n    apply IsColimit.ofIsoColimit h\n    refine Cocones.ext (œÜ := eqToIso rfl) ?_\n    rintro ‚ü®(j‚ÇÅ|j‚ÇÇ)‚ü© <;> simp only [const_obj_obj, eqToIso_refl, Iso.refl_hom,\n      Category.comp_id, BinaryCofan.mk_inl, BinaryCofan.mk_inr]\n\n"}
{"name":"CategoryTheory.Limits.MonoCoprod.instOfPreservesColimitsOfShapeDiscreteWalkingPairOfReflectsMonomorphismsForget","module":"Mathlib.CategoryTheory.Limits.MonoCoprod","initialProofState":"C : Type u_1\ninst‚úù¬≥ : CategoryTheory.Category.{u_3, u_1} C\ninst‚úù¬≤ : CategoryTheory.HasForget C\ninst‚úù¬π : CategoryTheory.Limits.PreservesColimitsOfShape (CategoryTheory.Discrete CategoryTheory.Limits.WalkingPair) (CategoryTheory.forget C)\ninst‚úù : (CategoryTheory.forget C).ReflectsMonomorphisms\n‚ä¢ CategoryTheory.Limits.MonoCoprod C","decl":"instance [HasForget C] [PreservesColimitsOfShape (Discrete WalkingPair) (forget C)]\n    [ReflectsMonomorphisms (forget C)] : MonoCoprod C :=\n  monoCoprod_of_preservesCoprod_of_reflectsMono (forget C)\n\n"}
