{"name":"RootPairing.IsRootPositive.zero_lt_apply_root","module":"Mathlib.LinearAlgebra.RootSystem.RootPositive","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁴ : LinearOrderedCommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nP : RootPairing ι R M N\nB : LinearMap (RingHom.id R) M (LinearMap (RingHom.id R) M R)\nself : P.IsRootPositive B\ni : ι\n⊢ LT.lt 0 ((B (P.root i)) (P.root i))","decl":"/-- A Prop-valued class for a bilinear form to be compatible with a root pairing. -/\nclass IsRootPositive (P : RootPairing ι R M N) (B : M →ₗ[R] M →ₗ[R] R) : Prop where\n  zero_lt_apply_root : ∀ i, 0 < B (P.root i) (P.root i)\n  symm : ∀ x y, B x y = B y x\n  apply_reflection_eq : ∀ i x y, B (P.reflection i x) (P.reflection i y) = B x y\n\n"}
{"name":"RootPairing.IsRootPositive.symm","module":"Mathlib.LinearAlgebra.RootSystem.RootPositive","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁴ : LinearOrderedCommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nP : RootPairing ι R M N\nB : LinearMap (RingHom.id R) M (LinearMap (RingHom.id R) M R)\nself : P.IsRootPositive B\nx y : M\n⊢ Eq ((B x) y) ((B y) x)","decl":"/-- A Prop-valued class for a bilinear form to be compatible with a root pairing. -/\nclass IsRootPositive (P : RootPairing ι R M N) (B : M →ₗ[R] M →ₗ[R] R) : Prop where\n  zero_lt_apply_root : ∀ i, 0 < B (P.root i) (P.root i)\n  symm : ∀ x y, B x y = B y x\n  apply_reflection_eq : ∀ i x y, B (P.reflection i x) (P.reflection i y) = B x y\n\n"}
{"name":"RootPairing.IsRootPositive.apply_reflection_eq","module":"Mathlib.LinearAlgebra.RootSystem.RootPositive","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁴ : LinearOrderedCommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nP : RootPairing ι R M N\nB : LinearMap (RingHom.id R) M (LinearMap (RingHom.id R) M R)\nself : P.IsRootPositive B\ni : ι\nx y : M\n⊢ Eq ((B ((P.reflection i) x)) ((P.reflection i) y)) ((B x) y)","decl":"/-- A Prop-valued class for a bilinear form to be compatible with a root pairing. -/\nclass IsRootPositive (P : RootPairing ι R M N) (B : M →ₗ[R] M →ₗ[R] R) : Prop where\n  zero_lt_apply_root : ∀ i, 0 < B (P.root i) (P.root i)\n  symm : ∀ x y, B x y = B y x\n  apply_reflection_eq : ∀ i x y, B (P.reflection i x) (P.reflection i y) = B x y\n\n"}
{"name":"RootPairing.two_mul_apply_root_root","module":"Mathlib.LinearAlgebra.RootSystem.RootPositive","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁵ : LinearOrderedCommRing R\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\ninst✝² : AddCommGroup N\ninst✝¹ : Module R N\nP : RootPairing ι R M N\nB : LinearMap (RingHom.id R) M (LinearMap (RingHom.id R) M R)\ninst✝ : P.IsRootPositive B\ni j : ι\n⊢ Eq (HMul.hMul 2 ((B (P.root i)) (P.root j))) (HMul.hMul (P.pairing i j) ((B (P.root j)) (P.root j)))","decl":"lemma two_mul_apply_root_root :\n    2 * B (P.root i) (P.root j) = P.pairing i j * B (P.root j) (P.root j) := by\n  rw [two_mul, ← eq_sub_iff_add_eq]\n  nth_rw 1 [← IsRootPositive.apply_reflection_eq (P := P) (B := B) j (P.root i) (P.root j)]\n  rw [reflection_apply, reflection_apply_self, root_coroot'_eq_pairing, LinearMap.map_sub₂,\n    LinearMap.map_smul₂, smul_eq_mul, LinearMap.map_neg, LinearMap.map_neg, mul_neg, neg_sub_neg]\n\n"}
{"name":"RootPairing.zero_lt_apply_root_root_iff","module":"Mathlib.LinearAlgebra.RootSystem.RootPositive","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁵ : LinearOrderedCommRing R\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\ninst✝² : AddCommGroup N\ninst✝¹ : Module R N\nP : RootPairing ι R M N\nB : LinearMap (RingHom.id R) M (LinearMap (RingHom.id R) M R)\ninst✝ : P.IsRootPositive B\ni j : ι\n⊢ Iff (LT.lt 0 ((B (P.root i)) (P.root j))) (LT.lt 0 (P.pairing i j))","decl":"@[simp]\nlemma zero_lt_apply_root_root_iff : 0 < B (P.root i) (P.root j) ↔ 0 < P.pairing i j := by\n  refine ⟨fun h ↦ (mul_pos_iff_of_pos_right\n    (IsRootPositive.zero_lt_apply_root (P := P) (B := B) j)).mp ?_,\n      fun h ↦ (mul_pos_iff_of_pos_left zero_lt_two).mp ?_⟩\n  · rw [← two_mul_apply_root_root]\n    exact mul_pos zero_lt_two h\n  · rw [two_mul_apply_root_root]\n    exact mul_pos h (IsRootPositive.zero_lt_apply_root (P := P) (B := B) j)\n\n"}
{"name":"RootPairing.zero_lt_pairing_iff","module":"Mathlib.LinearAlgebra.RootSystem.RootPositive","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁵ : LinearOrderedCommRing R\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\ninst✝² : AddCommGroup N\ninst✝¹ : Module R N\nP : RootPairing ι R M N\nB : LinearMap (RingHom.id R) M (LinearMap (RingHom.id R) M R)\ninst✝ : P.IsRootPositive B\ni j : ι\n⊢ Iff (LT.lt 0 (P.pairing i j)) (LT.lt 0 (P.pairing j i))","decl":"lemma zero_lt_pairing_iff : 0 < P.pairing i j ↔ 0 < P.pairing j i := by\n  rw [← zero_lt_apply_root_root_iff B, IsRootPositive.symm P, zero_lt_apply_root_root_iff]\n\n"}
{"name":"RootPairing.coxeterWeight_non_neg","module":"Mathlib.LinearAlgebra.RootSystem.RootPositive","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁵ : LinearOrderedCommRing R\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\ninst✝² : AddCommGroup N\ninst✝¹ : Module R N\nP : RootPairing ι R M N\nB : LinearMap (RingHom.id R) M (LinearMap (RingHom.id R) M R)\ninst✝ : P.IsRootPositive B\ni j : ι\n⊢ LE.le 0 (P.coxeterWeight i j)","decl":"lemma coxeterWeight_non_neg : 0 ≤ P.coxeterWeight i j := by\n  dsimp [coxeterWeight]\n  by_cases h : 0 < P.pairing i j\n  · exact le_of_lt <| mul_pos h ((zero_lt_pairing_iff B i j).mp h)\n  · have hn : ¬ 0 < P.pairing j i := fun hc ↦ h ((zero_lt_pairing_iff B i j).mpr hc)\n    simp_all only [not_lt, ge_iff_le]\n    exact mul_nonneg_of_nonpos_of_nonpos h hn\n\n"}
{"name":"RootPairing.apply_root_root_zero_iff","module":"Mathlib.LinearAlgebra.RootSystem.RootPositive","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁵ : LinearOrderedCommRing R\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\ninst✝² : AddCommGroup N\ninst✝¹ : Module R N\nP : RootPairing ι R M N\nB : LinearMap (RingHom.id R) M (LinearMap (RingHom.id R) M R)\ninst✝ : P.IsRootPositive B\ni j : ι\n⊢ Iff (Eq ((B (P.root i)) (P.root j)) 0) (Eq (P.pairing i j) 0)","decl":"@[simp]\nlemma apply_root_root_zero_iff : B (P.root i) (P.root j) = 0 ↔ P.pairing i j = 0 := by\n  refine ⟨fun hB => ?_, fun hP => ?_⟩\n  · have h2 : 2 * (B (P.root i)) (P.root j) = 0 := mul_eq_zero_of_right 2 hB\n    rw [two_mul_apply_root_root] at h2\n    exact eq_zero_of_ne_zero_of_mul_right_eq_zero (IsRootPositive.zero_lt_apply_root j).ne' h2\n  · have h2 : 2 * B (P.root i) (P.root j) = 0 := by rw [two_mul_apply_root_root, hP, zero_mul]\n    exact (mul_eq_zero.mp h2).resolve_left two_ne_zero\n\n"}
{"name":"RootPairing.pairing_zero_iff","module":"Mathlib.LinearAlgebra.RootSystem.RootPositive","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁵ : LinearOrderedCommRing R\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\ninst✝² : AddCommGroup N\ninst✝¹ : Module R N\nP : RootPairing ι R M N\nB : LinearMap (RingHom.id R) M (LinearMap (RingHom.id R) M R)\ninst✝ : P.IsRootPositive B\ni j : ι\n⊢ Iff (Eq (P.pairing i j) 0) (Eq (P.pairing j i) 0)","decl":"lemma pairing_zero_iff : P.pairing i j = 0 ↔ P.pairing j i = 0 := by\n  rw [← apply_root_root_zero_iff B, IsRootPositive.symm P, apply_root_root_zero_iff B]\n\n"}
{"name":"RootPairing.coxeterWeight_zero_iff_isOrthogonal","module":"Mathlib.LinearAlgebra.RootSystem.RootPositive","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁵ : LinearOrderedCommRing R\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\ninst✝² : AddCommGroup N\ninst✝¹ : Module R N\nP : RootPairing ι R M N\nB : LinearMap (RingHom.id R) M (LinearMap (RingHom.id R) M R)\ninst✝ : P.IsRootPositive B\ni j : ι\n⊢ Iff (Eq (P.coxeterWeight i j) 0) (P.IsOrthogonal i j)","decl":"lemma coxeterWeight_zero_iff_isOrthogonal : P.coxeterWeight i j = 0 ↔ P.IsOrthogonal i j := by\n  rw [coxeterWeight, mul_eq_zero]\n  refine ⟨fun h => ?_, fun h => Or.inl h.1⟩\n  rcases h with h | h\n  · exact ⟨h, (pairing_zero_iff B i j).mp h⟩\n  · exact ⟨(pairing_zero_iff B j i).mp h, h⟩\n\n"}
