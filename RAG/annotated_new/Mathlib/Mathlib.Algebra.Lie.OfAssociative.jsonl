{"name":"LieRing.of_associative_ring_bracket","module":"Mathlib.Algebra.Lie.OfAssociative","initialProofState":"A : Type v\ninst✝ : Ring A\nx y : A\n⊢ Eq (Bracket.bracket x y) (HSub.hSub (HMul.hMul x y) (HMul.hMul y x))","decl":"theorem of_associative_ring_bracket (x y : A) : ⁅x, y⁆ = x * y - y * x :=\n  rfl\n\n"}
{"name":"LieRing.lie_apply","module":"Mathlib.Algebra.Lie.OfAssociative","initialProofState":"A : Type v\ninst✝ : Ring A\nα : Type u_1\nf g : α → A\na : α\n⊢ Eq (Bracket.bracket f g a) (Bracket.bracket (f a) (g a))","decl":"@[simp]\ntheorem lie_apply {α : Type*} (f g : α → A) (a : α) : ⁅f, g⁆ a = ⁅f a, g a⁆ :=\n  rfl\n\n"}
{"name":"lie_eq_smul","module":"Mathlib.Algebra.Lie.OfAssociative","initialProofState":"A : Type v\ninst✝² : Ring A\nM : Type w\ninst✝¹ : AddCommGroup M\ninst✝ : Module A M\na : A\nm : M\n⊢ Eq (Bracket.bracket a m) (HSMul.hSMul a m)","decl":"theorem lie_eq_smul (a : A) (m : M) : ⁅a, m⁆ = a • m :=\n  rfl\n\n"}
{"name":"LieModule.ofAssociativeModule","module":"Mathlib.Algebra.Lie.OfAssociative","initialProofState":"A : Type v\ninst✝⁶ : Ring A\nR : Type u\ninst✝⁵ : CommRing R\ninst✝⁴ : Algebra R A\nM : Type w\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : Module A M\ninst✝ : IsScalarTower R A M\n⊢ LieModule R A M","decl":"/-- A representation of an associative algebra `A` is also a representation of `A`, regarded as a\nLie algebra via the ring commutator.\n\nSee the comment at `LieRingModule.ofAssociativeModule` for why the possibility `M = A` means\nthis cannot be a global instance. -/\ntheorem LieModule.ofAssociativeModule : LieModule R A M where\n  smul_lie := smul_assoc\n  lie_smul := smul_algebra_smul_comm\n\n"}
{"name":"Module.End.instLieModule","module":"Mathlib.Algebra.Lie.OfAssociative","initialProofState":"R : Type u\ninst✝² : CommRing R\nM : Type w\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\n⊢ LieModule R (Module.End R M) M","decl":"instance Module.End.instLieModule : LieModule R (Module.End R M) M :=\n  LieModule.ofAssociativeModule\n\n"}
{"name":"Module.End.lie_apply","module":"Mathlib.Algebra.Lie.OfAssociative","initialProofState":"R : Type u\ninst✝² : CommRing R\nM : Type w\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nf : Module.End R M\nm : M\n⊢ Eq (Bracket.bracket f m) (f m)","decl":"@[simp] lemma Module.End.lie_apply (f : Module.End R M) (m : M) : ⁅f, m⁆ = f m := rfl\n\n"}
{"name":"AlgHom.coe_toLieHom","module":"Mathlib.Algebra.Lie.OfAssociative","initialProofState":"A : Type v\ninst✝⁴ : Ring A\nR : Type u\ninst✝³ : CommRing R\ninst✝² : Algebra R A\nB : Type w\ninst✝¹ : Ring B\ninst✝ : Algebra R B\nf : AlgHom R A B\n⊢ Eq ⇑f.toLieHom ⇑f","decl":"@[simp]\ntheorem coe_toLieHom : ((f : A →ₗ⁅R⁆ B) : A → B) = f :=\n  rfl\n\n"}
{"name":"AlgHom.toLieHom_apply","module":"Mathlib.Algebra.Lie.OfAssociative","initialProofState":"A : Type v\ninst✝⁴ : Ring A\nR : Type u\ninst✝³ : CommRing R\ninst✝² : Algebra R A\nB : Type w\ninst✝¹ : Ring B\ninst✝ : Algebra R B\nf : AlgHom R A B\nx : A\n⊢ Eq (f.toLieHom x) (f x)","decl":"theorem toLieHom_apply (x : A) : f.toLieHom x = f x :=\n  rfl\n\n"}
{"name":"AlgHom.toLieHom_id","module":"Mathlib.Algebra.Lie.OfAssociative","initialProofState":"A : Type v\ninst✝² : Ring A\nR : Type u\ninst✝¹ : CommRing R\ninst✝ : Algebra R A\n⊢ Eq (AlgHom.id R A).toLieHom LieHom.id","decl":"@[simp]\ntheorem toLieHom_id : (AlgHom.id R A : A →ₗ⁅R⁆ A) = LieHom.id :=\n  rfl\n\n"}
{"name":"AlgHom.toLieHom_comp","module":"Mathlib.Algebra.Lie.OfAssociative","initialProofState":"A : Type v\ninst✝⁶ : Ring A\nR : Type u\ninst✝⁵ : CommRing R\ninst✝⁴ : Algebra R A\nB : Type w\nC : Type w₁\ninst✝³ : Ring B\ninst✝² : Ring C\ninst✝¹ : Algebra R B\ninst✝ : Algebra R C\nf : AlgHom R A B\ng : AlgHom R B C\n⊢ Eq (g.comp f).toLieHom (g.toLieHom.comp f.toLieHom)","decl":"@[simp]\ntheorem toLieHom_comp : (g.comp f : A →ₗ⁅R⁆ C) = (g : B →ₗ⁅R⁆ C).comp (f : A →ₗ⁅R⁆ B) :=\n  rfl\n\n"}
{"name":"AlgHom.toLieHom_injective","module":"Mathlib.Algebra.Lie.OfAssociative","initialProofState":"A : Type v\ninst✝⁴ : Ring A\nR : Type u\ninst✝³ : CommRing R\ninst✝² : Algebra R A\nB : Type w\ninst✝¹ : Ring B\ninst✝ : Algebra R B\nf g : AlgHom R A B\nh : Eq f.toLieHom g.toLieHom\n⊢ Eq f g","decl":"theorem toLieHom_injective {f g : A →ₐ[R] B} (h : (f : A →ₗ⁅R⁆ B) = (g : A →ₗ⁅R⁆ B)) : f = g := by\n  ext a; exact LieHom.congr_fun h a\n\n"}
{"name":"LieModule.toEnd_apply_apply","module":"Mathlib.Algebra.Lie.OfAssociative","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁶ : CommRing R\ninst✝⁵ : LieRing L\ninst✝⁴ : LieAlgebra R L\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : LieRingModule L M\ninst✝ : LieModule R L M\nx : L\nm : M\n⊢ Eq (((LieModule.toEnd R L M) x) m) (Bracket.bracket x m)","decl":"/-- A Lie module yields a Lie algebra morphism into the linear endomorphisms of the module.\n\nSee also `LieModule.toModuleHom`. -/\n@[simps]\ndef LieModule.toEnd : L →ₗ⁅R⁆ Module.End R M where\n  toFun x :=\n    { toFun := fun m => ⁅x, m⁆\n      map_add' := lie_add x\n      map_smul' := fun t => lie_smul t x }\n  map_add' x y := by ext m; apply add_lie\n  map_smul' t x := by ext m; apply smul_lie\n  map_lie' {x y} := by ext m; apply lie_lie\n\n"}
{"name":"LieAlgebra.ad_apply","module":"Mathlib.Algebra.Lie.OfAssociative","initialProofState":"R : Type u\nL : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\nx y : L\n⊢ Eq (((LieAlgebra.ad R L) x) y) (Bracket.bracket x y)","decl":"@[simp]\ntheorem LieAlgebra.ad_apply (x y : L) : LieAlgebra.ad R L x y = ⁅x, y⁆ :=\n  rfl\n\n"}
{"name":"LieModule.toEnd_module_end","module":"Mathlib.Algebra.Lie.OfAssociative","initialProofState":"R : Type u\nM : Type w\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\n⊢ Eq (LieModule.toEnd R (Module.End R M) M) LieHom.id","decl":"@[simp]\ntheorem LieModule.toEnd_module_end :\n    LieModule.toEnd R (Module.End R M) M = LieHom.id := by ext g m; simp [lie_eq_smul]\n\n"}
{"name":"LieSubalgebra.toEnd_eq","module":"Mathlib.Algebra.Lie.OfAssociative","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁶ : CommRing R\ninst✝⁵ : LieRing L\ninst✝⁴ : LieAlgebra R L\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : LieRingModule L M\ninst✝ : LieModule R L M\nK : LieSubalgebra R L\nx : Subtype fun x => Membership.mem K x\n⊢ Eq ((LieModule.toEnd R (Subtype fun x => Membership.mem K x) M) x) ((LieModule.toEnd R L M) ↑x)","decl":"theorem LieSubalgebra.toEnd_eq (K : LieSubalgebra R L) {x : K} :\n    LieModule.toEnd R K M x = LieModule.toEnd R L M x :=\n  rfl\n\n"}
{"name":"LieSubalgebra.toEnd_mk","module":"Mathlib.Algebra.Lie.OfAssociative","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁶ : CommRing R\ninst✝⁵ : LieRing L\ninst✝⁴ : LieAlgebra R L\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : LieRingModule L M\ninst✝ : LieModule R L M\nK : LieSubalgebra R L\nx : L\nhx : Membership.mem K x\n⊢ Eq ((LieModule.toEnd R (Subtype fun x => Membership.mem K x) M) ⟨x, hx⟩) ((LieModule.toEnd R L M) x)","decl":"@[simp]\ntheorem LieSubalgebra.toEnd_mk (K : LieSubalgebra R L) {x : L} (hx : x ∈ K) :\n    LieModule.toEnd R K M ⟨x, hx⟩ = LieModule.toEnd R L M x :=\n  rfl\n\n"}
{"name":"LieSubmodule.coe_toEnd","module":"Mathlib.Algebra.Lie.OfAssociative","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁶ : CommRing R\ninst✝⁵ : LieRing L\ninst✝⁴ : LieAlgebra R L\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : LieRingModule L M\ninst✝ : LieModule R L M\nN : LieSubmodule R L M\nx : L\ny : Subtype fun x => Membership.mem N x\n⊢ Eq (↑(((LieModule.toEnd R L (Subtype fun x => Membership.mem N x)) x) y)) (((LieModule.toEnd R L M) x) ↑y)","decl":"lemma LieSubmodule.coe_toEnd (N : LieSubmodule R L M) (x : L) (y : N) :\n    (toEnd R L N x y : M) = toEnd R L M x y := rfl\n\n"}
{"name":"LieSubmodule.coe_toEnd_pow","module":"Mathlib.Algebra.Lie.OfAssociative","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁶ : CommRing R\ninst✝⁵ : LieRing L\ninst✝⁴ : LieAlgebra R L\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : LieRingModule L M\ninst✝ : LieModule R L M\nN : LieSubmodule R L M\nx : L\ny : Subtype fun x => Membership.mem N x\nn : Nat\n⊢ Eq (↑((HPow.hPow ((LieModule.toEnd R L (Subtype fun x => Membership.mem N x)) x) n) y)) ((HPow.hPow ((LieModule.toEnd R L M) x) n) ↑y)","decl":"lemma LieSubmodule.coe_toEnd_pow (N : LieSubmodule R L M) (x : L) (y : N) (n : ℕ) :\n    ((toEnd R L N x ^ n) y : M) = (toEnd R L M x ^ n) y := by\n  induction n generalizing y with\n  | zero => rfl\n  | succ n ih => simp only [pow_succ', LinearMap.mul_apply, ih, LieSubmodule.coe_toEnd]\n\n"}
{"name":"LieSubalgebra.coe_ad","module":"Mathlib.Algebra.Lie.OfAssociative","initialProofState":"R : Type u\nL : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\nH : LieSubalgebra R L\nx y : Subtype fun x => Membership.mem H x\n⊢ Eq (↑(((LieAlgebra.ad R (Subtype fun x => Membership.mem H x)) x) y)) (((LieAlgebra.ad R L) ↑x) ↑y)","decl":"lemma LieSubalgebra.coe_ad (H : LieSubalgebra R L) (x y : H) :\n    (ad R H x y : L) = ad R L x y := rfl\n\n"}
{"name":"LieSubalgebra.coe_ad_pow","module":"Mathlib.Algebra.Lie.OfAssociative","initialProofState":"R : Type u\nL : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\nH : LieSubalgebra R L\nx y : Subtype fun x => Membership.mem H x\nn : Nat\n⊢ Eq (↑((HPow.hPow ((LieAlgebra.ad R (Subtype fun x => Membership.mem H x)) x) n) y)) ((HPow.hPow ((LieAlgebra.ad R L) ↑x) n) ↑y)","decl":"lemma LieSubalgebra.coe_ad_pow (H : LieSubalgebra R L) (x y : H) (n : ℕ) :\n    ((ad R H x ^ n) y : L) = (ad R L x ^ n) y :=\n  LieSubmodule.coe_toEnd_pow R H L H.toLieSubmodule x y n\n\n"}
{"name":"LieModule.toEnd_lie","module":"Mathlib.Algebra.Lie.OfAssociative","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁶ : CommRing R\ninst✝⁵ : LieRing L\ninst✝⁴ : LieAlgebra R L\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : LieRingModule L M\ninst✝ : LieModule R L M\nx y : L\nz : M\n⊢ Eq (((LieModule.toEnd R L M) x) (Bracket.bracket y z)) (HAdd.hAdd (Bracket.bracket (((LieAlgebra.ad R L) x) y) z) (Bracket.bracket y (((LieModule.toEnd R L M) x) z)))","decl":"lemma LieModule.toEnd_lie (x y : L) (z : M) :\n    (φ x) ⁅y, z⁆ = ⁅ad R L x y, z⁆ + ⁅y, φ x z⁆ := by\n  simp\n\n"}
{"name":"LieAlgebra.ad_lie","module":"Mathlib.Algebra.Lie.OfAssociative","initialProofState":"R : Type u\nL : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\nx y z : L\n⊢ Eq (((LieAlgebra.ad R L) x) (Bracket.bracket y z)) (HAdd.hAdd (Bracket.bracket (((LieAlgebra.ad R L) x) y) z) (Bracket.bracket y (((LieAlgebra.ad R L) x) z)))","decl":"lemma LieAlgebra.ad_lie (x y z : L) :\n    (ad R L x) ⁅y, z⁆ = ⁅ad R L x y, z⁆ + ⁅y, ad R L x z⁆ :=\n  toEnd_lie _ x y z\n\n"}
{"name":"LieModule.toEnd_pow_lie","module":"Mathlib.Algebra.Lie.OfAssociative","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁶ : CommRing R\ninst✝⁵ : LieRing L\ninst✝⁴ : LieAlgebra R L\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : LieRingModule L M\ninst✝ : LieModule R L M\nx y : L\nz : M\nn : Nat\n⊢ Eq ((HPow.hPow ((LieModule.toEnd R L M) x) n) (Bracket.bracket y z)) ((Finset.HasAntidiagonal.antidiagonal n).sum fun ij => HSMul.hSMul (n.choose ij.1) (Bracket.bracket ((HPow.hPow ((LieAlgebra.ad R L) x) ij.1) y) ((HPow.hPow ((LieModule.toEnd R L M) x) ij.2) z)))","decl":"open Finset in\nlemma LieModule.toEnd_pow_lie (x y : L) (z : M) (n : ℕ) :\n    ((φ x) ^ n) ⁅y, z⁆ =\n      ∑ ij ∈ antidiagonal n, n.choose ij.1 • ⁅((ad R L x) ^ ij.1) y, ((φ x) ^ ij.2) z⁆ := by\n  induction n with\n  | zero => simp\n  | succ n ih =>\n    rw [Finset.sum_antidiagonal_choose_succ_nsmul\n      (fun i j ↦ ⁅((ad R L x) ^ i) y, ((φ x) ^ j) z⁆) n]\n    simp only [pow_succ', LinearMap.mul_apply, ih, map_sum, map_nsmul,\n      toEnd_lie, nsmul_add, sum_add_distrib]\n    rw [add_comm, add_left_cancel_iff, sum_congr rfl]\n    rintro ⟨i, j⟩ hij\n    rw [mem_antidiagonal] at hij\n    rw [Nat.choose_symm_of_eq_add hij.symm]\n\n"}
{"name":"LieAlgebra.ad_pow_lie","module":"Mathlib.Algebra.Lie.OfAssociative","initialProofState":"R : Type u\nL : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\nx y z : L\nn : Nat\n⊢ Eq ((HPow.hPow ((LieAlgebra.ad R L) x) n) (Bracket.bracket y z)) ((Finset.HasAntidiagonal.antidiagonal n).sum fun ij => HSMul.hSMul (n.choose ij.1) (Bracket.bracket ((HPow.hPow ((LieAlgebra.ad R L) x) ij.1) y) ((HPow.hPow ((LieAlgebra.ad R L) x) ij.2) z)))","decl":"open Finset in\nlemma LieAlgebra.ad_pow_lie (x y z : L) (n : ℕ) :\n    ((ad R L x) ^ n) ⁅y, z⁆ =\n      ∑ ij ∈ antidiagonal n, n.choose ij.1 • ⁅((ad R L x) ^ ij.1) y, ((ad R L x) ^ ij.2) z⁆ :=\n  toEnd_pow_lie _ x y z n\n\n"}
{"name":"LieModule.toEnd_pow_comp_lieHom","module":"Mathlib.Algebra.Lie.OfAssociative","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝¹⁰ : CommRing R\ninst✝⁹ : LieRing L\ninst✝⁸ : LieAlgebra R L\ninst✝⁷ : AddCommGroup M\ninst✝⁶ : Module R M\ninst✝⁵ : LieRingModule L M\ninst✝⁴ : LieModule R L M\nM₂ : Type w₁\ninst✝³ : AddCommGroup M₂\ninst✝² : Module R M₂\ninst✝¹ : LieRingModule L M₂\ninst✝ : LieModule R L M₂\nf : LieModuleHom R L M M₂\nk : Nat\nx : L\n⊢ Eq (LinearMap.comp (HPow.hPow ((LieModule.toEnd R L M₂) x) k) ↑f) ((↑f).comp (HPow.hPow ((LieModule.toEnd R L M) x) k))","decl":"lemma toEnd_pow_comp_lieHom :\n    (toEnd R L M₂ x ^ k) ∘ₗ f = f ∘ₗ toEnd R L M x ^ k := by\n  apply LinearMap.commute_pow_left_of_commute\n  ext\n  simp\n\n"}
{"name":"LieModule.toEnd_pow_apply_map","module":"Mathlib.Algebra.Lie.OfAssociative","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝¹⁰ : CommRing R\ninst✝⁹ : LieRing L\ninst✝⁸ : LieAlgebra R L\ninst✝⁷ : AddCommGroup M\ninst✝⁶ : Module R M\ninst✝⁵ : LieRingModule L M\ninst✝⁴ : LieModule R L M\nM₂ : Type w₁\ninst✝³ : AddCommGroup M₂\ninst✝² : Module R M₂\ninst✝¹ : LieRingModule L M₂\ninst✝ : LieModule R L M₂\nf : LieModuleHom R L M M₂\nk : Nat\nx : L\nm : M\n⊢ Eq ((HPow.hPow ((LieModule.toEnd R L M₂) x) k) (f m)) (f ((HPow.hPow ((LieModule.toEnd R L M) x) k) m))","decl":"lemma toEnd_pow_apply_map (m : M) :\n    (toEnd R L M₂ x ^ k) (f m) = f ((toEnd R L M x ^ k) m) :=\n  LinearMap.congr_fun (toEnd_pow_comp_lieHom f k x) m\n\n"}
{"name":"LieSubmodule.coe_map_toEnd_le","module":"Mathlib.Algebra.Lie.OfAssociative","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁶ : CommRing R\ninst✝⁵ : LieRing L\ninst✝⁴ : LieAlgebra R L\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : LieRingModule L M\ninst✝ : LieModule R L M\nN : LieSubmodule R L M\nx : L\n⊢ LE.le (Submodule.map ((LieModule.toEnd R L M) x) ↑N) ↑N","decl":"theorem coe_map_toEnd_le :\n    (N : Submodule R M).map (LieModule.toEnd R L M x) ≤ N := by\n  rintro n ⟨m, hm, rfl⟩\n  exact N.lie_mem hm\n\n"}
{"name":"LieSubmodule.toEnd_comp_subtype_mem","module":"Mathlib.Algebra.Lie.OfAssociative","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁶ : CommRing R\ninst✝⁵ : LieRing L\ninst✝⁴ : LieAlgebra R L\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : LieRingModule L M\ninst✝ : LieModule R L M\nN : LieSubmodule R L M\nx : L\nm : M\nhm : Membership.mem (↑N) m\n⊢ Membership.mem (↑N) ((LinearMap.comp ((LieModule.toEnd R L M) x) (↑N).subtype) ⟨m, hm⟩)","decl":"theorem toEnd_comp_subtype_mem (m : M) (hm : m ∈ (N : Submodule R M)) :\n    (toEnd R L M x).comp (N : Submodule R M).subtype ⟨m, hm⟩ ∈ (N : Submodule R M) := by\n  simpa using N.lie_mem hm\n\n"}
{"name":"LieSubmodule.toEnd_restrict_eq_toEnd","module":"Mathlib.Algebra.Lie.OfAssociative","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁶ : CommRing R\ninst✝⁵ : LieRing L\ninst✝⁴ : LieAlgebra R L\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : LieRingModule L M\ninst✝ : LieModule R L M\nN : LieSubmodule R L M\nx : L\nh : optParam (∀ (m : M) (hm : Membership.mem (↑N) m), Membership.mem (↑N) ((LinearMap.comp ((LieModule.toEnd R L M) x) (↑N).subtype) ⟨m, hm⟩)) ⋯\n⊢ Eq (LinearMap.restrict ((LieModule.toEnd R L M) x) h) ((LieModule.toEnd R L (Subtype fun x => Membership.mem N x)) x)","decl":"@[simp]\ntheorem toEnd_restrict_eq_toEnd (h := N.toEnd_comp_subtype_mem x) :\n    (toEnd R L M x).restrict h = toEnd R L N x := by\n  ext\n  simp only [LinearMap.restrict_coe_apply, toEnd_apply_apply, ← coe_bracket,\n    SetLike.coe_eq_coe]\n  rfl\n\n"}
{"name":"LieSubmodule.mapsTo_pow_toEnd_sub_algebraMap","module":"Mathlib.Algebra.Lie.OfAssociative","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁶ : CommRing R\ninst✝⁵ : LieRing L\ninst✝⁴ : LieAlgebra R L\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : LieRingModule L M\ninst✝ : LieModule R L M\nN : LieSubmodule R L M\nφ : R\nk : Nat\nx : L\n⊢ Set.MapsTo ⇑(HPow.hPow (HSub.hSub ((LieModule.toEnd R L M) x) ((algebraMap R (Module.End R M)) φ)) k) ↑N ↑N","decl":"lemma mapsTo_pow_toEnd_sub_algebraMap {φ : R} {k : ℕ} {x : L} :\n    MapsTo ((toEnd R L M x - algebraMap R (Module.End R M) φ) ^ k) N N := by\n  rw [LinearMap.coe_pow]\n  exact MapsTo.iterate (fun m hm ↦ N.sub_mem (N.lie_mem hm) (N.smul_mem _ hm)) k\n\n"}
{"name":"LieAlgebra.ad_eq_lmul_left_sub_lmul_right","module":"Mathlib.Algebra.Lie.OfAssociative","initialProofState":"R : Type u\ninst✝² : CommRing R\nA : Type v\ninst✝¹ : Ring A\ninst✝ : Algebra R A\n⊢ Eq (⇑(LieAlgebra.ad R A)) (HSub.hSub (LinearMap.mulLeft R) (LinearMap.mulRight R))","decl":"theorem LieAlgebra.ad_eq_lmul_left_sub_lmul_right (A : Type v) [Ring A] [Algebra R A] :\n    (ad R A : A → Module.End R A) = LinearMap.mulLeft R - LinearMap.mulRight R := by\n  ext a b; simp [LieRing.of_associative_ring_bracket]\n\n"}
{"name":"LieSubalgebra.ad_comp_incl_eq","module":"Mathlib.Algebra.Lie.OfAssociative","initialProofState":"R : Type u\nL : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\nK : LieSubalgebra R L\nx : Subtype fun x => Membership.mem K x\n⊢ Eq (LinearMap.comp ((LieAlgebra.ad R L) ↑x) ↑K.incl) ((↑K.incl).comp ((LieAlgebra.ad R (Subtype fun x => Membership.mem K x)) x))","decl":"theorem LieSubalgebra.ad_comp_incl_eq (K : LieSubalgebra R L) (x : K) :\n    (ad R L ↑x).comp (K.incl : K →ₗ[R] L) = (K.incl : K →ₗ[R] L).comp (ad R K x) := by\n  ext y\n  simp only [ad_apply, LieHom.coe_toLinearMap, LieSubalgebra.coe_incl, LinearMap.coe_comp,\n    LieSubalgebra.coe_bracket, Function.comp_apply]\n\n"}
{"name":"LinearEquiv.lieConj_apply","module":"Mathlib.Algebra.Lie.OfAssociative","initialProofState":"R : Type u\nM₁ : Type v\nM₂ : Type w\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M₁\ninst✝² : Module R M₁\ninst✝¹ : AddCommGroup M₂\ninst✝ : Module R M₂\ne : LinearEquiv (RingHom.id R) M₁ M₂\nf : Module.End R M₁\n⊢ Eq (e.lieConj f) (e.conj f)","decl":"@[simp]\ntheorem lieConj_apply (f : Module.End R M₁) : e.lieConj f = e.conj f :=\n  rfl\n\n"}
{"name":"LinearEquiv.lieConj_symm","module":"Mathlib.Algebra.Lie.OfAssociative","initialProofState":"R : Type u\nM₁ : Type v\nM₂ : Type w\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M₁\ninst✝² : Module R M₁\ninst✝¹ : AddCommGroup M₂\ninst✝ : Module R M₂\ne : LinearEquiv (RingHom.id R) M₁ M₂\n⊢ Eq e.lieConj.symm e.symm.lieConj","decl":"@[simp]\ntheorem lieConj_symm : e.lieConj.symm = e.symm.lieConj :=\n  rfl\n\n"}
{"name":"AlgEquiv.toLieEquiv_apply","module":"Mathlib.Algebra.Lie.OfAssociative","initialProofState":"R : Type u\nA₁ : Type v\nA₂ : Type w\ninst✝⁴ : CommRing R\ninst✝³ : Ring A₁\ninst✝² : Ring A₂\ninst✝¹ : Algebra R A₁\ninst✝ : Algebra R A₂\ne : AlgEquiv R A₁ A₂\nx : A₁\n⊢ Eq (e.toLieEquiv x) (e x)","decl":"@[simp]\ntheorem toLieEquiv_apply (x : A₁) : e.toLieEquiv x = e x :=\n  rfl\n\n"}
{"name":"AlgEquiv.toLieEquiv_symm_apply","module":"Mathlib.Algebra.Lie.OfAssociative","initialProofState":"R : Type u\nA₁ : Type v\nA₂ : Type w\ninst✝⁴ : CommRing R\ninst✝³ : Ring A₁\ninst✝² : Ring A₂\ninst✝¹ : Algebra R A₁\ninst✝ : Algebra R A₂\ne : AlgEquiv R A₁ A₂\nx : A₂\n⊢ Eq (e.toLieEquiv.symm x) (e.symm x)","decl":"@[simp]\ntheorem toLieEquiv_symm_apply (x : A₂) : e.toLieEquiv.symm x = e.symm x :=\n  rfl\n\n"}
{"name":"LieAlgebra.conj_ad_apply","module":"Mathlib.Algebra.Lie.OfAssociative","initialProofState":"R : Type u_1\nL : Type u_2\nL' : Type u_3\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : LieAlgebra R L\ninst✝¹ : LieRing L'\ninst✝ : LieAlgebra R L'\ne : LieEquiv R L L'\nx : L\n⊢ Eq (e.toLinearEquiv.conj ((LieAlgebra.ad R L) x)) ((LieAlgebra.ad R L') (e x))","decl":"/-- Given an equivalence `e` of Lie algebras from `L` to `L'`, and an element `x : L`, the conjugate\nof the endomorphism `ad(x)` of `L` by `e` is the endomorphism `ad(e x)` of `L'`. -/\n@[simp]\nlemma conj_ad_apply (e : L ≃ₗ⁅R⁆ L') (x : L) : LinearEquiv.conj e (ad R L x) = ad R L' (e x) := by\n  ext y'\n  rw [LinearEquiv.conj_apply_apply, ad_apply, ad_apply, coe_toLinearEquiv, map_lie,\n    ← coe_toLinearEquiv, LinearEquiv.apply_symm_apply]\n\n"}
