{"name":"CategoryTheory.Triangulated.Subcategory.mk.inj","module":"Mathlib.CategoryTheory.Triangulated.Subcategory","initialProofState":"C : Type u_1\ninst✝⁵ : CategoryTheory.Category.{u_2, u_1} C\ninst✝⁴ : CategoryTheory.Limits.HasZeroObject C\ninst✝³ : CategoryTheory.HasShift C Int\ninst✝² : CategoryTheory.Preadditive C\ninst✝¹ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\ninst✝ : CategoryTheory.Pretriangulated C\nP✝ : C → Prop\nzero'✝ : Exists fun Z => Exists fun x => P✝ Z\nshift✝ : ∀ (X : C) (n : Int), P✝ X → P✝ ((CategoryTheory.shiftFunctor C n).obj X)\next₂'✝ : ∀ (T : CategoryTheory.Pretriangulated.Triangle C), Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T → P✝ T.obj₁ → P✝ T.obj₃ → CategoryTheory.isoClosure P✝ T.obj₂\nP : C → Prop\nzero' : Exists fun Z => Exists fun x => P Z\nshift : ∀ (X : C) (n : Int), P X → P ((CategoryTheory.shiftFunctor C n).obj X)\next₂' : ∀ (T : CategoryTheory.Pretriangulated.Triangle C), Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T → P T.obj₁ → P T.obj₃ → CategoryTheory.isoClosure P T.obj₂\nx✝ : Eq { P := P✝, zero' := zero'✝, shift := shift✝, ext₂' := ext₂'✝ } { P := P, zero' := zero', shift := shift, ext₂' := ext₂' }\n⊢ Eq P✝ P","decl":"/-- A triangulated subcategory of a pretriangulated category `C` consists of\na predicate `P : C → Prop` which contains a zero object, is stable by shifts, and such that\nif `X₁ ⟶ X₂ ⟶ X₃ ⟶ X₁⟦1⟧` is a distinguished triangle such that if `X₁` and `X₃` satisfy\n`P` then `X₂` is isomorphic to an object satisfying `P`. -/\nstructure Subcategory where\n  /-- the underlying predicate on objects of a triangulated subcategory -/\n  P : C → Prop\n  zero' : ∃ (Z : C) (_ : IsZero Z), P Z\n  shift (X : C) (n : ℤ) : P X → P (X⟦n⟧)\n  ext₂' (T : Triangle C) (_ : T ∈ distTriang C) : P T.obj₁ → P T.obj₃ → isoClosure P T.obj₂\n\n"}
{"name":"CategoryTheory.Triangulated.Subcategory.zero'","module":"Mathlib.CategoryTheory.Triangulated.Subcategory","initialProofState":"C : Type u_1\ninst✝⁵ : CategoryTheory.Category.{u_2, u_1} C\ninst✝⁴ : CategoryTheory.Limits.HasZeroObject C\ninst✝³ : CategoryTheory.HasShift C Int\ninst✝² : CategoryTheory.Preadditive C\ninst✝¹ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\ninst✝ : CategoryTheory.Pretriangulated C\nself : CategoryTheory.Triangulated.Subcategory C\n⊢ Exists fun Z => Exists fun x => self.P Z","decl":"/-- A triangulated subcategory of a pretriangulated category `C` consists of\na predicate `P : C → Prop` which contains a zero object, is stable by shifts, and such that\nif `X₁ ⟶ X₂ ⟶ X₃ ⟶ X₁⟦1⟧` is a distinguished triangle such that if `X₁` and `X₃` satisfy\n`P` then `X₂` is isomorphic to an object satisfying `P`. -/\nstructure Subcategory where\n  /-- the underlying predicate on objects of a triangulated subcategory -/\n  P : C → Prop\n  zero' : ∃ (Z : C) (_ : IsZero Z), P Z\n  shift (X : C) (n : ℤ) : P X → P (X⟦n⟧)\n  ext₂' (T : Triangle C) (_ : T ∈ distTriang C) : P T.obj₁ → P T.obj₃ → isoClosure P T.obj₂\n\n"}
{"name":"CategoryTheory.Triangulated.Subcategory.ext₂'","module":"Mathlib.CategoryTheory.Triangulated.Subcategory","initialProofState":"C : Type u_1\ninst✝⁵ : CategoryTheory.Category.{u_2, u_1} C\ninst✝⁴ : CategoryTheory.Limits.HasZeroObject C\ninst✝³ : CategoryTheory.HasShift C Int\ninst✝² : CategoryTheory.Preadditive C\ninst✝¹ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\ninst✝ : CategoryTheory.Pretriangulated C\nself : CategoryTheory.Triangulated.Subcategory C\nT : CategoryTheory.Pretriangulated.Triangle C\nx✝ : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T\na✝¹ : self.P T.obj₁\na✝ : self.P T.obj₃\n⊢ CategoryTheory.isoClosure self.P T.obj₂","decl":"/-- A triangulated subcategory of a pretriangulated category `C` consists of\na predicate `P : C → Prop` which contains a zero object, is stable by shifts, and such that\nif `X₁ ⟶ X₂ ⟶ X₃ ⟶ X₁⟦1⟧` is a distinguished triangle such that if `X₁` and `X₃` satisfy\n`P` then `X₂` is isomorphic to an object satisfying `P`. -/\nstructure Subcategory where\n  /-- the underlying predicate on objects of a triangulated subcategory -/\n  P : C → Prop\n  zero' : ∃ (Z : C) (_ : IsZero Z), P Z\n  shift (X : C) (n : ℤ) : P X → P (X⟦n⟧)\n  ext₂' (T : Triangle C) (_ : T ∈ distTriang C) : P T.obj₁ → P T.obj₃ → isoClosure P T.obj₂\n\n"}
{"name":"CategoryTheory.Triangulated.Subcategory.shift","module":"Mathlib.CategoryTheory.Triangulated.Subcategory","initialProofState":"C : Type u_1\ninst✝⁵ : CategoryTheory.Category.{u_2, u_1} C\ninst✝⁴ : CategoryTheory.Limits.HasZeroObject C\ninst✝³ : CategoryTheory.HasShift C Int\ninst✝² : CategoryTheory.Preadditive C\ninst✝¹ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\ninst✝ : CategoryTheory.Pretriangulated C\nself : CategoryTheory.Triangulated.Subcategory C\nX : C\nn : Int\na✝ : self.P X\n⊢ self.P ((CategoryTheory.shiftFunctor C n).obj X)","decl":"/-- A triangulated subcategory of a pretriangulated category `C` consists of\na predicate `P : C → Prop` which contains a zero object, is stable by shifts, and such that\nif `X₁ ⟶ X₂ ⟶ X₃ ⟶ X₁⟦1⟧` is a distinguished triangle such that if `X₁` and `X₃` satisfy\n`P` then `X₂` is isomorphic to an object satisfying `P`. -/\nstructure Subcategory where\n  /-- the underlying predicate on objects of a triangulated subcategory -/\n  P : C → Prop\n  zero' : ∃ (Z : C) (_ : IsZero Z), P Z\n  shift (X : C) (n : ℤ) : P X → P (X⟦n⟧)\n  ext₂' (T : Triangle C) (_ : T ∈ distTriang C) : P T.obj₁ → P T.obj₃ → isoClosure P T.obj₂\n\n"}
{"name":"CategoryTheory.Triangulated.Subcategory.mk.injEq","module":"Mathlib.CategoryTheory.Triangulated.Subcategory","initialProofState":"C : Type u_1\ninst✝⁵ : CategoryTheory.Category.{u_2, u_1} C\ninst✝⁴ : CategoryTheory.Limits.HasZeroObject C\ninst✝³ : CategoryTheory.HasShift C Int\ninst✝² : CategoryTheory.Preadditive C\ninst✝¹ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\ninst✝ : CategoryTheory.Pretriangulated C\nP✝ : C → Prop\nzero'✝ : Exists fun Z => Exists fun x => P✝ Z\nshift✝ : ∀ (X : C) (n : Int), P✝ X → P✝ ((CategoryTheory.shiftFunctor C n).obj X)\next₂'✝ : ∀ (T : CategoryTheory.Pretriangulated.Triangle C), Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T → P✝ T.obj₁ → P✝ T.obj₃ → CategoryTheory.isoClosure P✝ T.obj₂\nP : C → Prop\nzero' : Exists fun Z => Exists fun x => P Z\nshift : ∀ (X : C) (n : Int), P X → P ((CategoryTheory.shiftFunctor C n).obj X)\next₂' : ∀ (T : CategoryTheory.Pretriangulated.Triangle C), Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T → P T.obj₁ → P T.obj₃ → CategoryTheory.isoClosure P T.obj₂\n⊢ Eq (Eq { P := P✝, zero' := zero'✝, shift := shift✝, ext₂' := ext₂'✝ } { P := P, zero' := zero', shift := shift, ext₂' := ext₂' }) (Eq P✝ P)","decl":"/-- A triangulated subcategory of a pretriangulated category `C` consists of\na predicate `P : C → Prop` which contains a zero object, is stable by shifts, and such that\nif `X₁ ⟶ X₂ ⟶ X₃ ⟶ X₁⟦1⟧` is a distinguished triangle such that if `X₁` and `X₃` satisfy\n`P` then `X₂` is isomorphic to an object satisfying `P`. -/\nstructure Subcategory where\n  /-- the underlying predicate on objects of a triangulated subcategory -/\n  P : C → Prop\n  zero' : ∃ (Z : C) (_ : IsZero Z), P Z\n  shift (X : C) (n : ℤ) : P X → P (X⟦n⟧)\n  ext₂' (T : Triangle C) (_ : T ∈ distTriang C) : P T.obj₁ → P T.obj₃ → isoClosure P T.obj₂\n\n"}
{"name":"CategoryTheory.Triangulated.Subcategory.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Triangulated.Subcategory","initialProofState":"C : Type u_1\ninst✝⁶ : CategoryTheory.Category.{u_2, u_1} C\ninst✝⁵ : CategoryTheory.Limits.HasZeroObject C\ninst✝⁴ : CategoryTheory.HasShift C Int\ninst✝³ : CategoryTheory.Preadditive C\ninst✝² : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\ninst✝¹ : CategoryTheory.Pretriangulated C\ninst✝ : SizeOf C\nP : C → Prop\nzero' : Exists fun Z => Exists fun x => P Z\nshift : ∀ (X : C) (n : Int), P X → P ((CategoryTheory.shiftFunctor C n).obj X)\next₂' : ∀ (T : CategoryTheory.Pretriangulated.Triangle C), Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T → P T.obj₁ → P T.obj₃ → CategoryTheory.isoClosure P T.obj₂\n⊢ Eq (SizeOf.sizeOf { P := P, zero' := zero', shift := shift, ext₂' := ext₂' }) (HAdd.hAdd 1 (SizeOf.sizeOf zero'))","decl":"/-- A triangulated subcategory of a pretriangulated category `C` consists of\na predicate `P : C → Prop` which contains a zero object, is stable by shifts, and such that\nif `X₁ ⟶ X₂ ⟶ X₃ ⟶ X₁⟦1⟧` is a distinguished triangle such that if `X₁` and `X₃` satisfy\n`P` then `X₂` is isomorphic to an object satisfying `P`. -/\nstructure Subcategory where\n  /-- the underlying predicate on objects of a triangulated subcategory -/\n  P : C → Prop\n  zero' : ∃ (Z : C) (_ : IsZero Z), P Z\n  shift (X : C) (n : ℤ) : P X → P (X⟦n⟧)\n  ext₂' (T : Triangle C) (_ : T ∈ distTriang C) : P T.obj₁ → P T.obj₃ → isoClosure P T.obj₂\n\n"}
{"name":"CategoryTheory.Triangulated.Subcategory.zero","module":"Mathlib.CategoryTheory.Triangulated.Subcategory","initialProofState":"C : Type u_1\ninst✝⁶ : CategoryTheory.Category.{u_2, u_1} C\ninst✝⁵ : CategoryTheory.Limits.HasZeroObject C\ninst✝⁴ : CategoryTheory.HasShift C Int\ninst✝³ : CategoryTheory.Preadditive C\ninst✝² : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\ninst✝¹ : CategoryTheory.Pretriangulated C\nS : CategoryTheory.Triangulated.Subcategory C\ninst✝ : CategoryTheory.ClosedUnderIsomorphisms S.P\n⊢ S.P 0","decl":"lemma zero [ClosedUnderIsomorphisms S.P] : S.P 0 := by\n  obtain ⟨X, hX, mem⟩ := S.zero'\n  exact mem_of_iso _ hX.isoZero mem\n\n"}
{"name":"CategoryTheory.Triangulated.Subcategory.instClosedUnderIsomorphismsPIsoClosure","module":"Mathlib.CategoryTheory.Triangulated.Subcategory","initialProofState":"C : Type u_1\ninst✝⁵ : CategoryTheory.Category.{u_2, u_1} C\ninst✝⁴ : CategoryTheory.Limits.HasZeroObject C\ninst✝³ : CategoryTheory.HasShift C Int\ninst✝² : CategoryTheory.Preadditive C\ninst✝¹ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\ninst✝ : CategoryTheory.Pretriangulated C\nS : CategoryTheory.Triangulated.Subcategory C\n⊢ CategoryTheory.ClosedUnderIsomorphisms S.isoClosure.P","decl":"instance : ClosedUnderIsomorphisms S.isoClosure.P := by\n  dsimp only [isoClosure]\n  infer_instance\n\n"}
{"name":"CategoryTheory.Triangulated.Subcategory.instClosedUnderIsomorphismsPMk'","module":"Mathlib.CategoryTheory.Triangulated.Subcategory","initialProofState":"C : Type u_1\ninst✝⁵ : CategoryTheory.Category.{u_2, u_1} C\ninst✝⁴ : CategoryTheory.Limits.HasZeroObject C\ninst✝³ : CategoryTheory.HasShift C Int\ninst✝² : CategoryTheory.Preadditive C\ninst✝¹ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\ninst✝ : CategoryTheory.Pretriangulated C\nP : C → Prop\nzero : P 0\nshift : ∀ (X : C) (n : Int), P X → P ((CategoryTheory.shiftFunctor C n).obj X)\next₂ : ∀ (T : CategoryTheory.Pretriangulated.Triangle C), Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T → P T.obj₁ → P T.obj₃ → P T.obj₂\n⊢ CategoryTheory.ClosedUnderIsomorphisms (CategoryTheory.Triangulated.Subcategory.mk' P zero shift ext₂).P","decl":"instance : ClosedUnderIsomorphisms (mk' P zero shift ext₂).P where\n  of_iso {X Y} e hX := by\n    refine ext₂ (Triangle.mk e.hom (0 : Y ⟶ 0) 0) ?_ hX zero\n    refine isomorphic_distinguished _ (contractible_distinguished X) _ ?_\n    exact Triangle.isoMk _ _ (Iso.refl _) e.symm (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Triangulated.Subcategory.ext₂","module":"Mathlib.CategoryTheory.Triangulated.Subcategory","initialProofState":"C : Type u_1\ninst✝⁶ : CategoryTheory.Category.{u_2, u_1} C\ninst✝⁵ : CategoryTheory.Limits.HasZeroObject C\ninst✝⁴ : CategoryTheory.HasShift C Int\ninst✝³ : CategoryTheory.Preadditive C\ninst✝² : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\ninst✝¹ : CategoryTheory.Pretriangulated C\nS : CategoryTheory.Triangulated.Subcategory C\ninst✝ : CategoryTheory.ClosedUnderIsomorphisms S.P\nT : CategoryTheory.Pretriangulated.Triangle C\nhT : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T\nh₁ : S.P T.obj₁\nh₃ : S.P T.obj₃\n⊢ S.P T.obj₂","decl":"lemma ext₂ [ClosedUnderIsomorphisms S.P]\n    (T : Triangle C) (hT : T ∈ distTriang C) (h₁ : S.P T.obj₁)\n    (h₃ : S.P T.obj₃) : S.P T.obj₂ := by\n  simpa only [isoClosure_eq_self] using S.ext₂' T hT h₁ h₃\n\n"}
{"name":"CategoryTheory.Triangulated.Subcategory.W_iff","module":"Mathlib.CategoryTheory.Triangulated.Subcategory","initialProofState":"C : Type u_1\ninst✝⁵ : CategoryTheory.Category.{u_2, u_1} C\ninst✝⁴ : CategoryTheory.Limits.HasZeroObject C\ninst✝³ : CategoryTheory.HasShift C Int\ninst✝² : CategoryTheory.Preadditive C\ninst✝¹ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\ninst✝ : CategoryTheory.Pretriangulated C\nS : CategoryTheory.Triangulated.Subcategory C\nX Y : C\nf : Quiver.Hom X Y\n⊢ Iff (S.W f) (Exists fun Z => Exists fun g => Exists fun h => Exists fun x => S.P Z)","decl":"lemma W_iff {X Y : C} (f : X ⟶ Y) :\n    S.W f ↔ ∃ (Z : C) (g : Y ⟶ Z) (h : Z ⟶ X⟦(1 : ℤ)⟧)\n      (_ : Triangle.mk f g h ∈ distTriang C), S.P Z := by rfl\n\n"}
{"name":"CategoryTheory.Triangulated.Subcategory.W_iff'","module":"Mathlib.CategoryTheory.Triangulated.Subcategory","initialProofState":"C : Type u_1\ninst✝⁵ : CategoryTheory.Category.{u_2, u_1} C\ninst✝⁴ : CategoryTheory.Limits.HasZeroObject C\ninst✝³ : CategoryTheory.HasShift C Int\ninst✝² : CategoryTheory.Preadditive C\ninst✝¹ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\ninst✝ : CategoryTheory.Pretriangulated C\nS : CategoryTheory.Triangulated.Subcategory C\nY Z : C\ng : Quiver.Hom Y Z\n⊢ Iff (S.W g) (Exists fun X => Exists fun f => Exists fun h => Exists fun x => S.P X)","decl":"lemma W_iff' {Y Z : C} (g : Y ⟶ Z) :\n    S.W g ↔ ∃ (X : C) (f : X ⟶ Y) (h : Z ⟶ X⟦(1 : ℤ)⟧)\n      (_ : Triangle.mk f g h ∈ distTriang C), S.P X := by\n  rw [S.W_iff]\n  constructor\n  · rintro ⟨Z, g, h, H, mem⟩\n    exact ⟨_, _, _, inv_rot_of_distTriang _ H, S.shift _ (-1) mem⟩\n  · rintro ⟨Z, g, h, H, mem⟩\n    exact ⟨_, _, _, rot_of_distTriang _ H, S.shift _ 1 mem⟩\n\n"}
{"name":"CategoryTheory.Triangulated.Subcategory.W.mk","module":"Mathlib.CategoryTheory.Triangulated.Subcategory","initialProofState":"C : Type u_1\ninst✝⁵ : CategoryTheory.Category.{u_2, u_1} C\ninst✝⁴ : CategoryTheory.Limits.HasZeroObject C\ninst✝³ : CategoryTheory.HasShift C Int\ninst✝² : CategoryTheory.Preadditive C\ninst✝¹ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\ninst✝ : CategoryTheory.Pretriangulated C\nS : CategoryTheory.Triangulated.Subcategory C\nT : CategoryTheory.Pretriangulated.Triangle C\nhT : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T\nh : S.P T.obj₃\n⊢ S.W T.mor₁","decl":"lemma W.mk {T : Triangle C} (hT : T ∈ distTriang C) (h : S.P T.obj₃) : S.W T.mor₁ :=\n  ⟨_, _, _, hT, h⟩\n\n"}
{"name":"CategoryTheory.Triangulated.Subcategory.W.mk'","module":"Mathlib.CategoryTheory.Triangulated.Subcategory","initialProofState":"C : Type u_1\ninst✝⁵ : CategoryTheory.Category.{u_2, u_1} C\ninst✝⁴ : CategoryTheory.Limits.HasZeroObject C\ninst✝³ : CategoryTheory.HasShift C Int\ninst✝² : CategoryTheory.Preadditive C\ninst✝¹ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\ninst✝ : CategoryTheory.Pretriangulated C\nS : CategoryTheory.Triangulated.Subcategory C\nT : CategoryTheory.Pretriangulated.Triangle C\nhT : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T\nh : S.P T.obj₁\n⊢ S.W T.mor₂","decl":"lemma W.mk' {T : Triangle C} (hT : T ∈ distTriang C) (h : S.P T.obj₁) : S.W T.mor₂ := by\n  rw [W_iff']\n  exact ⟨_, _, _, hT, h⟩\n\n"}
{"name":"CategoryTheory.Triangulated.Subcategory.isoClosure_W","module":"Mathlib.CategoryTheory.Triangulated.Subcategory","initialProofState":"C : Type u_1\ninst✝⁵ : CategoryTheory.Category.{u_2, u_1} C\ninst✝⁴ : CategoryTheory.Limits.HasZeroObject C\ninst✝³ : CategoryTheory.HasShift C Int\ninst✝² : CategoryTheory.Preadditive C\ninst✝¹ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\ninst✝ : CategoryTheory.Pretriangulated C\nS : CategoryTheory.Triangulated.Subcategory C\n⊢ Eq S.isoClosure.W S.W","decl":"lemma isoClosure_W : S.isoClosure.W = S.W := by\n  ext X Y f\n  constructor\n  · rintro ⟨Z, g, h, mem, ⟨Z', hZ', ⟨e⟩⟩⟩\n    refine ⟨Z', g ≫ e.hom, e.inv ≫ h, isomorphic_distinguished _ mem _ ?_, hZ'⟩\n    exact Triangle.isoMk _ _ (Iso.refl _) (Iso.refl _) e.symm\n  · rintro ⟨Z, g, h, mem, hZ⟩\n    exact ⟨Z, g, h, mem, le_isoClosure _ _ hZ⟩\n\n"}
{"name":"CategoryTheory.Triangulated.Subcategory.respectsIso_W","module":"Mathlib.CategoryTheory.Triangulated.Subcategory","initialProofState":"C : Type u_1\ninst✝⁵ : CategoryTheory.Category.{u_2, u_1} C\ninst✝⁴ : CategoryTheory.Limits.HasZeroObject C\ninst✝³ : CategoryTheory.HasShift C Int\ninst✝² : CategoryTheory.Preadditive C\ninst✝¹ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\ninst✝ : CategoryTheory.Pretriangulated C\nS : CategoryTheory.Triangulated.Subcategory C\n⊢ S.W.RespectsIso","decl":"instance respectsIso_W : S.W.RespectsIso where\n  precomp {X' X Y} e (he : IsIso e) := by\n    rintro f ⟨Z, g, h, mem, mem'⟩\n    refine ⟨Z, g, h ≫ inv e⟦(1 : ℤ)⟧', isomorphic_distinguished _ mem _ ?_, mem'⟩\n    refine Triangle.isoMk _ _ (asIso e) (Iso.refl _) (Iso.refl _) (by simp) (by simp) ?_\n    dsimp\n    simp only [Functor.map_inv, assoc, IsIso.inv_hom_id, comp_id, id_comp]\n  postcomp {X Y Y'} e (he : IsIso e) := by\n    rintro f ⟨Z, g, h, mem, mem'⟩\n    refine ⟨Z, inv e ≫ g, h, isomorphic_distinguished _ mem _ ?_, mem'⟩\n    exact Triangle.isoMk _ _ (Iso.refl _) (asIso e).symm (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Triangulated.Subcategory.instContainsIdentitiesW","module":"Mathlib.CategoryTheory.Triangulated.Subcategory","initialProofState":"C : Type u_1\ninst✝⁵ : CategoryTheory.Category.{u_2, u_1} C\ninst✝⁴ : CategoryTheory.Limits.HasZeroObject C\ninst✝³ : CategoryTheory.HasShift C Int\ninst✝² : CategoryTheory.Preadditive C\ninst✝¹ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\ninst✝ : CategoryTheory.Pretriangulated C\nS : CategoryTheory.Triangulated.Subcategory C\n⊢ S.W.ContainsIdentities","decl":"instance : S.W.ContainsIdentities := by\n  rw [← isoClosure_W]\n  exact ⟨fun X => ⟨_, _, _, contractible_distinguished X, zero _⟩⟩\n\n"}
{"name":"CategoryTheory.Triangulated.Subcategory.W_of_isIso","module":"Mathlib.CategoryTheory.Triangulated.Subcategory","initialProofState":"C : Type u_1\ninst✝⁶ : CategoryTheory.Category.{u_2, u_1} C\ninst✝⁵ : CategoryTheory.Limits.HasZeroObject C\ninst✝⁴ : CategoryTheory.HasShift C Int\ninst✝³ : CategoryTheory.Preadditive C\ninst✝² : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\ninst✝¹ : CategoryTheory.Pretriangulated C\nS : CategoryTheory.Triangulated.Subcategory C\nX Y : C\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.IsIso f\n⊢ S.W f","decl":"lemma W_of_isIso {X Y : C} (f : X ⟶ Y) [IsIso f] : S.W f := by\n  refine (S.W.arrow_mk_iso_iff ?_).1 (MorphismProperty.id_mem _ X)\n  exact Arrow.isoMk (Iso.refl _) (asIso f)\n\n"}
{"name":"CategoryTheory.Triangulated.Subcategory.smul_mem_W_iff","module":"Mathlib.CategoryTheory.Triangulated.Subcategory","initialProofState":"C : Type u_1\ninst✝⁵ : CategoryTheory.Category.{u_2, u_1} C\ninst✝⁴ : CategoryTheory.Limits.HasZeroObject C\ninst✝³ : CategoryTheory.HasShift C Int\ninst✝² : CategoryTheory.Preadditive C\ninst✝¹ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\ninst✝ : CategoryTheory.Pretriangulated C\nS : CategoryTheory.Triangulated.Subcategory C\nX Y : C\nf : Quiver.Hom X Y\nn : Units Int\n⊢ Iff (S.W (HSMul.hSMul n f)) (S.W f)","decl":"lemma smul_mem_W_iff {X Y : C} (f : X ⟶ Y) (n : ℤˣ) :\n    S.W (n • f) ↔ S.W f :=\n  S.W.arrow_mk_iso_iff (Arrow.isoMk (n • (Iso.refl _)) (Iso.refl _))\n\n"}
{"name":"CategoryTheory.Triangulated.Subcategory.W.shift","module":"Mathlib.CategoryTheory.Triangulated.Subcategory","initialProofState":"C : Type u_1\ninst✝⁵ : CategoryTheory.Category.{u_2, u_1} C\ninst✝⁴ : CategoryTheory.Limits.HasZeroObject C\ninst✝³ : CategoryTheory.HasShift C Int\ninst✝² : CategoryTheory.Preadditive C\ninst✝¹ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\ninst✝ : CategoryTheory.Pretriangulated C\nS : CategoryTheory.Triangulated.Subcategory C\nX₁ X₂ : C\nf : Quiver.Hom X₁ X₂\nhf : S.W f\nn : Int\n⊢ S.W ((CategoryTheory.shiftFunctor C n).map f)","decl":"lemma W.shift {X₁ X₂ : C} {f : X₁ ⟶ X₂} (hf : S.W f) (n : ℤ) : S.W (f⟦n⟧') := by\n  rw [← smul_mem_W_iff _ _ (n.negOnePow)]\n  obtain ⟨X₃, g, h, hT, mem⟩ := hf\n  exact ⟨_, _, _, Pretriangulated.Triangle.shift_distinguished _ hT n, S.shift _ _ mem⟩\n\n"}
{"name":"CategoryTheory.Triangulated.Subcategory.W.unshift","module":"Mathlib.CategoryTheory.Triangulated.Subcategory","initialProofState":"C : Type u_1\ninst✝⁵ : CategoryTheory.Category.{u_2, u_1} C\ninst✝⁴ : CategoryTheory.Limits.HasZeroObject C\ninst✝³ : CategoryTheory.HasShift C Int\ninst✝² : CategoryTheory.Preadditive C\ninst✝¹ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\ninst✝ : CategoryTheory.Pretriangulated C\nS : CategoryTheory.Triangulated.Subcategory C\nX₁ X₂ : C\nf : Quiver.Hom X₁ X₂\nn : Int\nhf : S.W ((CategoryTheory.shiftFunctor C n).map f)\n⊢ S.W f","decl":"lemma W.unshift {X₁ X₂ : C} {f : X₁ ⟶ X₂} {n : ℤ} (hf : S.W (f⟦n⟧')) : S.W f :=\n  (S.W.arrow_mk_iso_iff\n     (Arrow.isoOfNatIso (shiftEquiv C n).unitIso (Arrow.mk f))).2 (hf.shift (-n))\n\n"}
{"name":"CategoryTheory.Triangulated.Subcategory.instIsCompatibleWithShiftWInt","module":"Mathlib.CategoryTheory.Triangulated.Subcategory","initialProofState":"C : Type u_1\ninst✝⁵ : CategoryTheory.Category.{u_2, u_1} C\ninst✝⁴ : CategoryTheory.Limits.HasZeroObject C\ninst✝³ : CategoryTheory.HasShift C Int\ninst✝² : CategoryTheory.Preadditive C\ninst✝¹ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\ninst✝ : CategoryTheory.Pretriangulated C\nS : CategoryTheory.Triangulated.Subcategory C\n⊢ S.W.IsCompatibleWithShift Int","decl":"instance : S.W.IsCompatibleWithShift ℤ where\n  condition n := by\n    ext K L f\n    exact ⟨fun hf => hf.unshift, fun hf => hf.shift n⟩\n\n"}
{"name":"CategoryTheory.Triangulated.Subcategory.instIsMultiplicativeWOfIsTriangulated","module":"Mathlib.CategoryTheory.Triangulated.Subcategory","initialProofState":"C : Type u_1\ninst✝⁶ : CategoryTheory.Category.{u_2, u_1} C\ninst✝⁵ : CategoryTheory.Limits.HasZeroObject C\ninst✝⁴ : CategoryTheory.HasShift C Int\ninst✝³ : CategoryTheory.Preadditive C\ninst✝² : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\ninst✝¹ : CategoryTheory.Pretriangulated C\nS : CategoryTheory.Triangulated.Subcategory C\ninst✝ : CategoryTheory.IsTriangulated C\n⊢ S.W.IsMultiplicative","decl":"instance [IsTriangulated C] : S.W.IsMultiplicative where\n  comp_mem := by\n    rw [← isoClosure_W]\n    rintro X₁ X₂ X₃ u₁₂ u₂₃ ⟨Z₁₂, v₁₂, w₁₂, H₁₂, mem₁₂⟩ ⟨Z₂₃, v₂₃, w₂₃, H₂₃, mem₂₃⟩\n    obtain ⟨Z₁₃, v₁₃, w₁₂, H₁₃⟩ := distinguished_cocone_triangle (u₁₂ ≫ u₂₃)\n    exact ⟨_, _, _, H₁₃, S.isoClosure.ext₂ _ (someOctahedron rfl H₁₂ H₂₃ H₁₃).mem mem₁₂ mem₂₃⟩\n\n"}
{"name":"CategoryTheory.Triangulated.Subcategory.mem_W_iff_of_distinguished","module":"Mathlib.CategoryTheory.Triangulated.Subcategory","initialProofState":"C : Type u_1\ninst✝⁶ : CategoryTheory.Category.{u_2, u_1} C\ninst✝⁵ : CategoryTheory.Limits.HasZeroObject C\ninst✝⁴ : CategoryTheory.HasShift C Int\ninst✝³ : CategoryTheory.Preadditive C\ninst✝² : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\ninst✝¹ : CategoryTheory.Pretriangulated C\nS : CategoryTheory.Triangulated.Subcategory C\ninst✝ : CategoryTheory.ClosedUnderIsomorphisms S.P\nT : CategoryTheory.Pretriangulated.Triangle C\nhT : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T\n⊢ Iff (S.W T.mor₁) (S.P T.obj₃)","decl":"lemma mem_W_iff_of_distinguished\n    [ClosedUnderIsomorphisms S.P] (T : Triangle C) (hT : T ∈ distTriang C) :\n    S.W T.mor₁ ↔ S.P T.obj₃ := by\n  constructor\n  · rintro ⟨Z, g, h, hT', mem⟩\n    obtain ⟨e, _⟩ := exists_iso_of_arrow_iso _ _ hT' hT (Iso.refl _)\n    exact mem_of_iso S.P (Triangle.π₃.mapIso e) mem\n  · intro h\n    exact ⟨_, _, _, hT, h⟩\n\n"}
{"name":"CategoryTheory.Triangulated.Subcategory.instHasLeftCalculusOfFractionsWOfIsTriangulated","module":"Mathlib.CategoryTheory.Triangulated.Subcategory","initialProofState":"C : Type u_1\ninst✝⁶ : CategoryTheory.Category.{u_2, u_1} C\ninst✝⁵ : CategoryTheory.Limits.HasZeroObject C\ninst✝⁴ : CategoryTheory.HasShift C Int\ninst✝³ : CategoryTheory.Preadditive C\ninst✝² : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\ninst✝¹ : CategoryTheory.Pretriangulated C\nS : CategoryTheory.Triangulated.Subcategory C\ninst✝ : CategoryTheory.IsTriangulated C\n⊢ S.W.HasLeftCalculusOfFractions","decl":"instance [IsTriangulated C] : S.W.HasLeftCalculusOfFractions where\n  exists_leftFraction X Y φ := by\n    obtain ⟨Z, f, g, H, mem⟩ := φ.hs\n    obtain ⟨Y', s', f', mem'⟩ := distinguished_cocone_triangle₂ (g ≫ φ.f⟦1⟧')\n    obtain ⟨b, ⟨hb₁, _⟩⟩ :=\n      complete_distinguished_triangle_morphism₂ _ _ H mem' φ.f (𝟙 Z) (by simp)\n    exact ⟨MorphismProperty.LeftFraction.mk b s' ⟨_, _, _, mem', mem⟩, hb₁.symm⟩\n  ext := by\n    rintro X' X Y f₁ f₂ s ⟨Z, g, h, H, mem⟩ hf₁\n    have hf₂ : s ≫ (f₁ - f₂) = 0 := by rw [comp_sub, hf₁, sub_self]\n    obtain ⟨q, hq⟩ := Triangle.yoneda_exact₂ _ H _ hf₂\n    obtain ⟨Y', r, t, mem'⟩ := distinguished_cocone_triangle q\n    refine ⟨Y', r, ?_, ?_⟩\n    · exact ⟨_, _, _, rot_of_distTriang _ mem', S.shift _ _ mem⟩\n    · have eq := comp_distTriang_mor_zero₁₂ _ mem'\n      dsimp at eq\n      rw [← sub_eq_zero, ← sub_comp, hq, assoc, eq, comp_zero]\n\n"}
{"name":"CategoryTheory.Triangulated.Subcategory.instHasRightCalculusOfFractionsWOfIsTriangulated","module":"Mathlib.CategoryTheory.Triangulated.Subcategory","initialProofState":"C : Type u_1\ninst✝⁶ : CategoryTheory.Category.{u_2, u_1} C\ninst✝⁵ : CategoryTheory.Limits.HasZeroObject C\ninst✝⁴ : CategoryTheory.HasShift C Int\ninst✝³ : CategoryTheory.Preadditive C\ninst✝² : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\ninst✝¹ : CategoryTheory.Pretriangulated C\nS : CategoryTheory.Triangulated.Subcategory C\ninst✝ : CategoryTheory.IsTriangulated C\n⊢ S.W.HasRightCalculusOfFractions","decl":"instance [IsTriangulated C] : S.W.HasRightCalculusOfFractions where\n  exists_rightFraction X Y φ := by\n    obtain ⟨Z, f, g, H, mem⟩ := φ.hs\n    obtain ⟨X', f', h', mem'⟩ := distinguished_cocone_triangle₁ (φ.f ≫ f)\n    obtain ⟨a, ⟨ha₁, _⟩⟩ := complete_distinguished_triangle_morphism₁ _ _\n      mem' H φ.f (𝟙 Z) (by simp)\n    exact ⟨MorphismProperty.RightFraction.mk f' ⟨_, _, _, mem', mem⟩ a, ha₁⟩\n  ext Y Z Z' f₁ f₂ s hs hf₁ := by\n    rw [S.W_iff'] at hs\n    obtain ⟨Z, g, h, H, mem⟩ := hs\n    have hf₂ : (f₁ - f₂) ≫ s = 0 := by rw [sub_comp, hf₁, sub_self]\n    obtain ⟨q, hq⟩ := Triangle.coyoneda_exact₂ _ H _ hf₂\n    obtain ⟨Y', r, t, mem'⟩ := distinguished_cocone_triangle₁ q\n    refine ⟨Y', r, ?_, ?_⟩\n    · exact ⟨_, _, _, mem', mem⟩\n    · have eq := comp_distTriang_mor_zero₁₂ _ mem'\n      dsimp at eq\n      rw [← sub_eq_zero, ← comp_sub, hq, reassoc_of% eq, zero_comp]\n\n"}
{"name":"CategoryTheory.Triangulated.Subcategory.instIsCompatibleWithTriangulationWOfIsTriangulated","module":"Mathlib.CategoryTheory.Triangulated.Subcategory","initialProofState":"C : Type u_1\ninst✝⁶ : CategoryTheory.Category.{u_2, u_1} C\ninst✝⁵ : CategoryTheory.Limits.HasZeroObject C\ninst✝⁴ : CategoryTheory.HasShift C Int\ninst✝³ : CategoryTheory.Preadditive C\ninst✝² : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\ninst✝¹ : CategoryTheory.Pretriangulated C\nS : CategoryTheory.Triangulated.Subcategory C\ninst✝ : CategoryTheory.IsTriangulated C\n⊢ S.W.IsCompatibleWithTriangulation","decl":"instance [IsTriangulated C] : S.W.IsCompatibleWithTriangulation := ⟨by\n  rintro T₁ T₃ mem₁ mem₃ a b ⟨Z₅, g₅, h₅, mem₅, mem₅'⟩ ⟨Z₄, g₄, h₄, mem₄, mem₄'⟩ comm\n  obtain ⟨Z₂, g₂, h₂, mem₂⟩ := distinguished_cocone_triangle (T₁.mor₁ ≫ b)\n  have H := someOctahedron rfl mem₁ mem₄ mem₂\n  have H' := someOctahedron comm.symm mem₅ mem₃ mem₂\n  let φ : T₁ ⟶ T₃ := H.triangleMorphism₁ ≫ H'.triangleMorphism₂\n  exact ⟨φ.hom₃, S.W.comp_mem _ _ (W.mk S H.mem mem₄') (W.mk' S H'.mem mem₅'),\n    by simpa [φ] using φ.comm₂, by simpa [φ] using φ.comm₃⟩⟩\n\n"}
{"name":"CategoryTheory.Triangulated.Subcategory.ext₁","module":"Mathlib.CategoryTheory.Triangulated.Subcategory","initialProofState":"C : Type u_1\ninst✝⁶ : CategoryTheory.Category.{u_2, u_1} C\ninst✝⁵ : CategoryTheory.Limits.HasZeroObject C\ninst✝⁴ : CategoryTheory.HasShift C Int\ninst✝³ : CategoryTheory.Preadditive C\ninst✝² : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\ninst✝¹ : CategoryTheory.Pretriangulated C\nS : CategoryTheory.Triangulated.Subcategory C\nT : CategoryTheory.Pretriangulated.Triangle C\nhT : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T\ninst✝ : CategoryTheory.ClosedUnderIsomorphisms S.P\nh₂ : S.P T.obj₂\nh₃ : S.P T.obj₃\n⊢ S.P T.obj₁","decl":"lemma ext₁ [ClosedUnderIsomorphisms S.P] (h₂ : S.P T.obj₂) (h₃ : S.P T.obj₃) :\n    S.P T.obj₁ :=\n  S.ext₂ _ (inv_rot_of_distTriang _ hT) (S.shift _ _ h₃) h₂\n\n"}
{"name":"CategoryTheory.Triangulated.Subcategory.ext₃","module":"Mathlib.CategoryTheory.Triangulated.Subcategory","initialProofState":"C : Type u_1\ninst✝⁶ : CategoryTheory.Category.{u_2, u_1} C\ninst✝⁵ : CategoryTheory.Limits.HasZeroObject C\ninst✝⁴ : CategoryTheory.HasShift C Int\ninst✝³ : CategoryTheory.Preadditive C\ninst✝² : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\ninst✝¹ : CategoryTheory.Pretriangulated C\nS : CategoryTheory.Triangulated.Subcategory C\nT : CategoryTheory.Pretriangulated.Triangle C\nhT : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T\ninst✝ : CategoryTheory.ClosedUnderIsomorphisms S.P\nh₁ : S.P T.obj₁\nh₂ : S.P T.obj₂\n⊢ S.P T.obj₃","decl":"lemma ext₃ [ClosedUnderIsomorphisms S.P] (h₁ : S.P T.obj₁) (h₂ : S.P T.obj₂) :\n    S.P T.obj₃ :=\n  S.ext₂ _ (rot_of_distTriang _ hT) h₂ (S.shift _ _ h₁)\n\n"}
{"name":"CategoryTheory.Triangulated.Subcategory.ext₁'","module":"Mathlib.CategoryTheory.Triangulated.Subcategory","initialProofState":"C : Type u_1\ninst✝⁵ : CategoryTheory.Category.{u_2, u_1} C\ninst✝⁴ : CategoryTheory.Limits.HasZeroObject C\ninst✝³ : CategoryTheory.HasShift C Int\ninst✝² : CategoryTheory.Preadditive C\ninst✝¹ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\ninst✝ : CategoryTheory.Pretriangulated C\nS : CategoryTheory.Triangulated.Subcategory C\nT : CategoryTheory.Pretriangulated.Triangle C\nhT : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T\nh₂ : S.P T.obj₂\nh₃ : S.P T.obj₃\n⊢ CategoryTheory.isoClosure S.P T.obj₁","decl":"lemma ext₁' (h₂ : S.P T.obj₂) (h₃ : S.P T.obj₃) :\n    CategoryTheory.isoClosure S.P T.obj₁ :=\n  S.ext₂' _ (inv_rot_of_distTriang _ hT) (S.shift _ _ h₃) h₂\n\n"}
{"name":"CategoryTheory.Triangulated.Subcategory.ext₃'","module":"Mathlib.CategoryTheory.Triangulated.Subcategory","initialProofState":"C : Type u_1\ninst✝⁵ : CategoryTheory.Category.{u_2, u_1} C\ninst✝⁴ : CategoryTheory.Limits.HasZeroObject C\ninst✝³ : CategoryTheory.HasShift C Int\ninst✝² : CategoryTheory.Preadditive C\ninst✝¹ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\ninst✝ : CategoryTheory.Pretriangulated C\nS : CategoryTheory.Triangulated.Subcategory C\nT : CategoryTheory.Pretriangulated.Triangle C\nhT : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T\nh₁ : S.P T.obj₁\nh₂ : S.P T.obj₂\n⊢ CategoryTheory.isoClosure S.P T.obj₃","decl":"lemma ext₃' (h₁ : S.P T.obj₁) (h₂ : S.P T.obj₂) :\n    CategoryTheory.isoClosure S.P T.obj₃ :=\n  S.ext₂' _ (rot_of_distTriang _ hT) h₂ (S.shift _ _ h₁)\n\n"}
