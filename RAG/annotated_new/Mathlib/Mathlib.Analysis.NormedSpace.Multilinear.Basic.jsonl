{"name":"ContinuousMultilinearMap.instContinuousEval","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"𝕜 : Type u_1\nι : Type u_2\nE : ι → Type u_3\nF : Type u_4\ninst✝⁶ : NormedField 𝕜\ninst✝⁵ : (i : ι) → SeminormedAddCommGroup (E i)\ninst✝⁴ : (i : ι) → NormedSpace 𝕜 (E i)\ninst✝³ : TopologicalSpace F\ninst✝² : AddCommGroup F\ninst✝¹ : TopologicalAddGroup F\ninst✝ : Module 𝕜 F\n⊢ ContinuousEval (ContinuousMultilinearMap 𝕜 E F) ((i : ι) → E i) F","decl":"instance ContinuousMultilinearMap.instContinuousEval :\n    ContinuousEval (ContinuousMultilinearMap 𝕜 E F) (Π i, E i) F where\n  continuous_eval := by\n    cases nonempty_fintype ι\n    let _ := TopologicalAddGroup.toUniformSpace F\n    have := comm_topologicalAddGroup_is_uniform (G := F)\n    refine (UniformOnFun.continuousOn_eval₂ fun m ↦ ?_).comp_continuous\n      (isEmbedding_toUniformOnFun.continuous.prodMap continuous_id) fun (f, x) ↦ f.cont.continuousAt\n    exact ⟨ball m 1, NormedSpace.isVonNBounded_of_isBounded _ isBounded_ball,\n      ball_mem_nhds _ one_pos⟩\n\n"}
{"name":"ContinuousMultilinearMap.continuous_eval","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"F : Type u_1\nX : outParam (Type u_2)\nY : outParam (Type u_3)\ninst✝³ : FunLike F X Y\ninst✝² : TopologicalSpace F\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nself : ContinuousEval F X Y\n⊢ Continuous fun fx => fx.1 fx.2","decl":"@[deprecated (since := \"2024-10-05\")]\nprotected alias ContinuousMultilinearMap.continuous_eval := continuous_eval\n\n"}
{"name":"ContinuousLinearMap.continuous_uncurry_of_multilinear","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"𝕜 : Type u_1\nι : Type u_2\nE : ι → Type u_3\nF : Type u_4\ninst✝¹¹ : NormedField 𝕜\ninst✝¹⁰ : Finite ι\ninst✝⁹ : (i : ι) → SeminormedAddCommGroup (E i)\ninst✝⁸ : (i : ι) → NormedSpace 𝕜 (E i)\ninst✝⁷ : TopologicalSpace F\ninst✝⁶ : AddCommGroup F\ninst✝⁵ : TopologicalAddGroup F\ninst✝⁴ : Module 𝕜 F\nG : Type u_5\ninst✝³ : AddCommGroup G\ninst✝² : TopologicalSpace G\ninst✝¹ : Module 𝕜 G\ninst✝ : ContinuousConstSMul 𝕜 F\nf : ContinuousLinearMap (RingHom.id 𝕜) G (ContinuousMultilinearMap 𝕜 E F)\n⊢ Continuous fun p => (f p.1) p.2","decl":"lemma continuous_uncurry_of_multilinear (f : G →L[𝕜] ContinuousMultilinearMap 𝕜 E F) :\n    Continuous (fun (p : G × (Π i, E i)) ↦ f p.1 p.2) := by\n  fun_prop\n\n"}
{"name":"ContinuousLinearMap.continuousOn_uncurry_of_multilinear","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"𝕜 : Type u_1\nι : Type u_2\nE : ι → Type u_3\nF : Type u_4\ninst✝¹¹ : NormedField 𝕜\ninst✝¹⁰ : Finite ι\ninst✝⁹ : (i : ι) → SeminormedAddCommGroup (E i)\ninst✝⁸ : (i : ι) → NormedSpace 𝕜 (E i)\ninst✝⁷ : TopologicalSpace F\ninst✝⁶ : AddCommGroup F\ninst✝⁵ : TopologicalAddGroup F\ninst✝⁴ : Module 𝕜 F\nG : Type u_5\ninst✝³ : AddCommGroup G\ninst✝² : TopologicalSpace G\ninst✝¹ : Module 𝕜 G\ninst✝ : ContinuousConstSMul 𝕜 F\nf : ContinuousLinearMap (RingHom.id 𝕜) G (ContinuousMultilinearMap 𝕜 E F)\ns : Set (Prod G ((i : ι) → E i))\n⊢ ContinuousOn (fun p => (f p.1) p.2) s","decl":"lemma continuousOn_uncurry_of_multilinear (f : G →L[𝕜] ContinuousMultilinearMap 𝕜 E F) {s} :\n    ContinuousOn (fun (p : G × (Π i, E i)) ↦ f p.1 p.2) s :=\n  f.continuous_uncurry_of_multilinear.continuousOn\n\n"}
{"name":"ContinuousLinearMap.continuousAt_uncurry_of_multilinear","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"𝕜 : Type u_1\nι : Type u_2\nE : ι → Type u_3\nF : Type u_4\ninst✝¹¹ : NormedField 𝕜\ninst✝¹⁰ : Finite ι\ninst✝⁹ : (i : ι) → SeminormedAddCommGroup (E i)\ninst✝⁸ : (i : ι) → NormedSpace 𝕜 (E i)\ninst✝⁷ : TopologicalSpace F\ninst✝⁶ : AddCommGroup F\ninst✝⁵ : TopologicalAddGroup F\ninst✝⁴ : Module 𝕜 F\nG : Type u_5\ninst✝³ : AddCommGroup G\ninst✝² : TopologicalSpace G\ninst✝¹ : Module 𝕜 G\ninst✝ : ContinuousConstSMul 𝕜 F\nf : ContinuousLinearMap (RingHom.id 𝕜) G (ContinuousMultilinearMap 𝕜 E F)\nx : Prod G ((i : ι) → E i)\n⊢ ContinuousAt (fun p => (f p.1) p.2) x","decl":"lemma continuousAt_uncurry_of_multilinear (f : G →L[𝕜] ContinuousMultilinearMap 𝕜 E F) {x} :\n    ContinuousAt (fun (p : G × (Π i, E i)) ↦ f p.1 p.2) x :=\n  f.continuous_uncurry_of_multilinear.continuousAt\n\n"}
{"name":"ContinuousLinearMap.continuousWithinAt_uncurry_of_multilinear","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"𝕜 : Type u_1\nι : Type u_2\nE : ι → Type u_3\nF : Type u_4\ninst✝¹¹ : NormedField 𝕜\ninst✝¹⁰ : Finite ι\ninst✝⁹ : (i : ι) → SeminormedAddCommGroup (E i)\ninst✝⁸ : (i : ι) → NormedSpace 𝕜 (E i)\ninst✝⁷ : TopologicalSpace F\ninst✝⁶ : AddCommGroup F\ninst✝⁵ : TopologicalAddGroup F\ninst✝⁴ : Module 𝕜 F\nG : Type u_5\ninst✝³ : AddCommGroup G\ninst✝² : TopologicalSpace G\ninst✝¹ : Module 𝕜 G\ninst✝ : ContinuousConstSMul 𝕜 F\nf : ContinuousLinearMap (RingHom.id 𝕜) G (ContinuousMultilinearMap 𝕜 E F)\ns : Set (Prod G ((i : ι) → E i))\nx : Prod G ((i : ι) → E i)\n⊢ ContinuousWithinAt (fun p => (f p.1) p.2) s x","decl":"lemma continuousWithinAt_uncurry_of_multilinear (f : G →L[𝕜] ContinuousMultilinearMap 𝕜 E F) {s x} :\n    ContinuousWithinAt (fun (p : G × (Π i, E i)) ↦ f p.1 p.2) s x :=\n  f.continuous_uncurry_of_multilinear.continuousWithinAt\n\n"}
{"name":"MultilinearMap.norm_map_coord_zero","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"𝕜 : Type u\nι : Type v\nE : ι → Type wE\nG : Type wG\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : (i : ι) → SeminormedAddCommGroup (E i)\ninst✝² : (i : ι) → NormedSpace 𝕜 (E i)\ninst✝¹ : SeminormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nf : MultilinearMap 𝕜 E G\nhf : Continuous ⇑f\nm : (i : ι) → E i\ni : ι\nhi : Eq (Norm.norm (m i)) 0\n⊢ Eq (Norm.norm (f m)) 0","decl":"/-- If `f` is a continuous multilinear map on `E`\nand `m` is an element of `∀ i, E i` such that one of the `m i` has norm `0`,\nthen `f m` has norm `0`.\n\nNote that we cannot drop the continuity assumption because `f (m : Unit → E) = f (m ())`,\nwhere the domain has zero norm and the codomain has a nonzero norm\ndoes not satisfy this condition. -/\nlemma norm_map_coord_zero (f : MultilinearMap 𝕜 E G) (hf : Continuous f)\n    {m : ∀ i, E i} {i : ι} (hi : ‖m i‖ = 0) : ‖f m‖ = 0 := by\n  classical\n  rw [← inseparable_zero_iff_norm] at hi ⊢\n  have : Inseparable (update m i 0) m := inseparable_pi.2 <|\n    (forall_update_iff m fun i a ↦ Inseparable a (m i)).2 ⟨hi.symm, fun _ _ ↦ rfl⟩\n  simpa only [map_update_zero] using this.symm.map hf\n\n"}
{"name":"MultilinearMap.bound_of_shell_of_norm_map_coord_zero","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"𝕜 : Type u\nι : Type v\nE : ι → Type wE\nG : Type wG\ninst✝⁵ : NontriviallyNormedField 𝕜\ninst✝⁴ : (i : ι) → SeminormedAddCommGroup (E i)\ninst✝³ : (i : ι) → NormedSpace 𝕜 (E i)\ninst✝² : SeminormedAddCommGroup G\ninst✝¹ : NormedSpace 𝕜 G\ninst✝ : Fintype ι\nf : MultilinearMap 𝕜 E G\nhf₀ : ∀ {m : (i : ι) → E i} {i : ι}, Eq (Norm.norm (m i)) 0 → Eq (Norm.norm (f m)) 0\nε : ι → Real\nC : Real\nhε : ∀ (i : ι), LT.lt 0 (ε i)\nc : ι → 𝕜\nhc : ∀ (i : ι), LT.lt 1 (Norm.norm (c i))\nhf : ∀ (m : (i : ι) → E i), (∀ (i : ι), LE.le (HDiv.hDiv (ε i) (Norm.norm (c i))) (Norm.norm (m i))) → (∀ (i : ι), LT.lt (Norm.norm (m i)) (ε i)) → LE.le (Norm.norm (f m)) (HMul.hMul C (Finset.univ.prod fun i => Norm.norm (m i)))\nm : (i : ι) → E i\n⊢ LE.le (Norm.norm (f m)) (HMul.hMul C (Finset.univ.prod fun i => Norm.norm (m i)))","decl":"/-- If a multilinear map in finitely many variables on seminormed spaces\nsends vectors with a component of norm zero to vectors of norm zero\nand satisfies the inequality `‖f m‖ ≤ C * ∏ i, ‖m i‖` on a shell `ε i / ‖c i‖ < ‖m i‖ < ε i`\nfor some positive numbers `ε i` and elements `c i : 𝕜`, `1 < ‖c i‖`,\nthen it satisfies this inequality for all `m`.\n\nThe first assumption is automatically satisfied on normed spaces, see `bound_of_shell` below.\nFor seminormed spaces, it follows from continuity of `f`, see next lemma,\nsee `bound_of_shell_of_continuous` below. -/\ntheorem bound_of_shell_of_norm_map_coord_zero (f : MultilinearMap 𝕜 E G)\n    (hf₀ : ∀ {m i}, ‖m i‖ = 0 → ‖f m‖ = 0)\n    {ε : ι → ℝ} {C : ℝ} (hε : ∀ i, 0 < ε i) {c : ι → 𝕜} (hc : ∀ i, 1 < ‖c i‖)\n    (hf : ∀ m : ∀ i, E i, (∀ i, ε i / ‖c i‖ ≤ ‖m i‖) → (∀ i, ‖m i‖ < ε i) → ‖f m‖ ≤ C * ∏ i, ‖m i‖)\n    (m : ∀ i, E i) : ‖f m‖ ≤ C * ∏ i, ‖m i‖ := by\n  rcases em (∃ i, ‖m i‖ = 0) with (⟨i, hi⟩ | hm)\n  · rw [hf₀ hi, prod_eq_zero (mem_univ i) hi, mul_zero]\n  push_neg at hm\n  choose δ hδ0 hδm_lt hle_δm _ using fun i => rescale_to_shell_semi_normed (hc i) (hε i) (hm i)\n  have hδ0 : 0 < ∏ i, ‖δ i‖ := prod_pos fun i _ => norm_pos_iff.2 (hδ0 i)\n  simpa [map_smul_univ, norm_smul, prod_mul_distrib, mul_left_comm C, mul_le_mul_left hδ0] using\n    hf (fun i => δ i • m i) hle_δm hδm_lt\n\n"}
{"name":"MultilinearMap.bound_of_shell_of_continuous","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"𝕜 : Type u\nι : Type v\nE : ι → Type wE\nG : Type wG\ninst✝⁵ : NontriviallyNormedField 𝕜\ninst✝⁴ : (i : ι) → SeminormedAddCommGroup (E i)\ninst✝³ : (i : ι) → NormedSpace 𝕜 (E i)\ninst✝² : SeminormedAddCommGroup G\ninst✝¹ : NormedSpace 𝕜 G\ninst✝ : Fintype ι\nf : MultilinearMap 𝕜 E G\nhfc : Continuous ⇑f\nε : ι → Real\nC : Real\nhε : ∀ (i : ι), LT.lt 0 (ε i)\nc : ι → 𝕜\nhc : ∀ (i : ι), LT.lt 1 (Norm.norm (c i))\nhf : ∀ (m : (i : ι) → E i), (∀ (i : ι), LE.le (HDiv.hDiv (ε i) (Norm.norm (c i))) (Norm.norm (m i))) → (∀ (i : ι), LT.lt (Norm.norm (m i)) (ε i)) → LE.le (Norm.norm (f m)) (HMul.hMul C (Finset.univ.prod fun i => Norm.norm (m i)))\nm : (i : ι) → E i\n⊢ LE.le (Norm.norm (f m)) (HMul.hMul C (Finset.univ.prod fun i => Norm.norm (m i)))","decl":"/-- If a continuous multilinear map in finitely many variables on normed spaces satisfies\nthe inequality `‖f m‖ ≤ C * ∏ i, ‖m i‖` on a shell `ε i / ‖c i‖ < ‖m i‖ < ε i` for some positive\nnumbers `ε i` and elements `c i : 𝕜`, `1 < ‖c i‖`, then it satisfies this inequality for all `m`. -/\ntheorem bound_of_shell_of_continuous (f : MultilinearMap 𝕜 E G) (hfc : Continuous f)\n    {ε : ι → ℝ} {C : ℝ} (hε : ∀ i, 0 < ε i) {c : ι → 𝕜} (hc : ∀ i, 1 < ‖c i‖)\n    (hf : ∀ m : ∀ i, E i, (∀ i, ε i / ‖c i‖ ≤ ‖m i‖) → (∀ i, ‖m i‖ < ε i) → ‖f m‖ ≤ C * ∏ i, ‖m i‖)\n    (m : ∀ i, E i) : ‖f m‖ ≤ C * ∏ i, ‖m i‖ :=\n  bound_of_shell_of_norm_map_coord_zero f (norm_map_coord_zero f hfc) hε hc hf m\n\n"}
{"name":"MultilinearMap.exists_bound_of_continuous","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"𝕜 : Type u\nι : Type v\nE : ι → Type wE\nG : Type wG\ninst✝⁵ : NontriviallyNormedField 𝕜\ninst✝⁴ : (i : ι) → SeminormedAddCommGroup (E i)\ninst✝³ : (i : ι) → NormedSpace 𝕜 (E i)\ninst✝² : SeminormedAddCommGroup G\ninst✝¹ : NormedSpace 𝕜 G\ninst✝ : Fintype ι\nf : MultilinearMap 𝕜 E G\nhf : Continuous ⇑f\n⊢ Exists fun C => And (LT.lt 0 C) (∀ (m : (i : ι) → E i), LE.le (Norm.norm (f m)) (HMul.hMul C (Finset.univ.prod fun i => Norm.norm (m i))))","decl":"/-- If a multilinear map in finitely many variables on normed spaces is continuous, then it\nsatisfies the inequality `‖f m‖ ≤ C * ∏ i, ‖m i‖`, for some `C` which can be chosen to be\npositive. -/\ntheorem exists_bound_of_continuous (f : MultilinearMap 𝕜 E G) (hf : Continuous f) :\n    ∃ C : ℝ, 0 < C ∧ ∀ m, ‖f m‖ ≤ C * ∏ i, ‖m i‖ := by\n  cases isEmpty_or_nonempty ι\n  · refine ⟨‖f 0‖ + 1, add_pos_of_nonneg_of_pos (norm_nonneg _) zero_lt_one, fun m => ?_⟩\n    obtain rfl : m = 0 := funext (IsEmpty.elim ‹_›)\n    simp [univ_eq_empty, zero_le_one]\n  obtain ⟨ε : ℝ, ε0 : 0 < ε, hε : ∀ m : ∀ i, E i, ‖m - 0‖ < ε → ‖f m - f 0‖ < 1⟩ :=\n    NormedAddCommGroup.tendsto_nhds_nhds.1 (hf.tendsto 0) 1 zero_lt_one\n  simp only [sub_zero, f.map_zero] at hε\n  rcases NormedField.exists_one_lt_norm 𝕜 with ⟨c, hc⟩\n  have : 0 < (‖c‖ / ε) ^ Fintype.card ι := pow_pos (div_pos (zero_lt_one.trans hc) ε0) _\n  refine ⟨_, this, ?_⟩\n  refine f.bound_of_shell_of_continuous hf (fun _ => ε0) (fun _ => hc) fun m hcm hm => ?_\n  refine (hε m ((pi_norm_lt_iff ε0).2 hm)).le.trans ?_\n  rw [← div_le_iff₀' this, one_div, ← inv_pow, inv_div, Fintype.card, ← prod_const]\n  exact prod_le_prod (fun _ _ => div_nonneg ε0.le (norm_nonneg _)) fun i _ => hcm i\n\n"}
{"name":"MultilinearMap.norm_image_sub_le_of_bound'","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"𝕜 : Type u\nι : Type v\nE : ι → Type wE\nG : Type wG\ninst✝⁶ : NontriviallyNormedField 𝕜\ninst✝⁵ : (i : ι) → SeminormedAddCommGroup (E i)\ninst✝⁴ : (i : ι) → NormedSpace 𝕜 (E i)\ninst✝³ : SeminormedAddCommGroup G\ninst✝² : NormedSpace 𝕜 G\ninst✝¹ : Fintype ι\ninst✝ : DecidableEq ι\nf : MultilinearMap 𝕜 E G\nC : Real\nhC : LE.le 0 C\nH : ∀ (m : (i : ι) → E i), LE.le (Norm.norm (f m)) (HMul.hMul C (Finset.univ.prod fun i => Norm.norm (m i)))\nm₁ m₂ : (i : ι) → E i\n⊢ LE.le (Norm.norm (HSub.hSub (f m₁) (f m₂))) (HMul.hMul C (Finset.univ.sum fun i => Finset.univ.prod fun j => ite (Eq j i) (Norm.norm (HSub.hSub (m₁ i) (m₂ i))) (Max.max (Norm.norm (m₁ j)) (Norm.norm (m₂ j)))))","decl":"/-- If a multilinear map `f` satisfies a boundedness property around `0`,\none can deduce a bound on `f m₁ - f m₂` using the multilinearity.\nHere, we give a precise but hard to use version.\nSee `norm_image_sub_le_of_bound` for a less precise but more usable version.\nThe bound reads\n`‖f m - f m'‖ ≤\n  C * ‖m 1 - m' 1‖ * max ‖m 2‖ ‖m' 2‖ * max ‖m 3‖ ‖m' 3‖ * ... * max ‖m n‖ ‖m' n‖ + ...`,\nwhere the other terms in the sum are the same products where `1` is replaced by any `i`. -/\ntheorem norm_image_sub_le_of_bound' [DecidableEq ι] (f : MultilinearMap 𝕜 E G) {C : ℝ} (hC : 0 ≤ C)\n    (H : ∀ m, ‖f m‖ ≤ C * ∏ i, ‖m i‖) (m₁ m₂ : ∀ i, E i) :\n    ‖f m₁ - f m₂‖ ≤ C * ∑ i, ∏ j, if j = i then ‖m₁ i - m₂ i‖ else max ‖m₁ j‖ ‖m₂ j‖ := by\n  have A :\n    ∀ s : Finset ι,\n      ‖f m₁ - f (s.piecewise m₂ m₁)‖ ≤\n        C * ∑ i ∈ s, ∏ j, if j = i then ‖m₁ i - m₂ i‖ else max ‖m₁ j‖ ‖m₂ j‖ := by\n    intro s\n    induction' s using Finset.induction with i s his Hrec\n    · simp\n    have I :\n      ‖f (s.piecewise m₂ m₁) - f ((insert i s).piecewise m₂ m₁)‖ ≤\n        C * ∏ j, if j = i then ‖m₁ i - m₂ i‖ else max ‖m₁ j‖ ‖m₂ j‖ := by\n      have A : (insert i s).piecewise m₂ m₁ = Function.update (s.piecewise m₂ m₁) i (m₂ i) :=\n        s.piecewise_insert _ _ _\n      have B : s.piecewise m₂ m₁ = Function.update (s.piecewise m₂ m₁) i (m₁ i) := by\n        simp [eq_update_iff, his]\n      rw [B, A, ← f.map_update_sub]\n      apply le_trans (H _)\n      gcongr with j\n      by_cases h : j = i\n      · rw [h]\n        simp\n      · by_cases h' : j ∈ s <;> simp [h', h, le_refl]\n    calc\n      ‖f m₁ - f ((insert i s).piecewise m₂ m₁)‖ ≤\n          ‖f m₁ - f (s.piecewise m₂ m₁)‖ +\n            ‖f (s.piecewise m₂ m₁) - f ((insert i s).piecewise m₂ m₁)‖ := by\n        rw [← dist_eq_norm, ← dist_eq_norm, ← dist_eq_norm]\n        exact dist_triangle _ _ _\n      _ ≤ (C * ∑ i ∈ s, ∏ j, if j = i then ‖m₁ i - m₂ i‖ else max ‖m₁ j‖ ‖m₂ j‖) +\n            C * ∏ j, if j = i then ‖m₁ i - m₂ i‖ else max ‖m₁ j‖ ‖m₂ j‖ :=\n        (add_le_add Hrec I)\n      _ = C * ∑ i ∈ insert i s, ∏ j, if j = i then ‖m₁ i - m₂ i‖ else max ‖m₁ j‖ ‖m₂ j‖ := by\n        simp [his, add_comm, left_distrib]\n  convert A univ\n  simp\n\n"}
{"name":"MultilinearMap.norm_image_sub_le_of_bound","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"𝕜 : Type u\nι : Type v\nE : ι → Type wE\nG : Type wG\ninst✝⁵ : NontriviallyNormedField 𝕜\ninst✝⁴ : (i : ι) → SeminormedAddCommGroup (E i)\ninst✝³ : (i : ι) → NormedSpace 𝕜 (E i)\ninst✝² : SeminormedAddCommGroup G\ninst✝¹ : NormedSpace 𝕜 G\ninst✝ : Fintype ι\nf : MultilinearMap 𝕜 E G\nC : Real\nhC : LE.le 0 C\nH : ∀ (m : (i : ι) → E i), LE.le (Norm.norm (f m)) (HMul.hMul C (Finset.univ.prod fun i => Norm.norm (m i)))\nm₁ m₂ : (i : ι) → E i\n⊢ LE.le (Norm.norm (HSub.hSub (f m₁) (f m₂))) (HMul.hMul (HMul.hMul (HMul.hMul C ↑(Fintype.card ι)) (HPow.hPow (Max.max (Norm.norm m₁) (Norm.norm m₂)) (HSub.hSub (Fintype.card ι) 1))) (Norm.norm (HSub.hSub m₁ m₂)))","decl":"/-- If `f` satisfies a boundedness property around `0`, one can deduce a bound on `f m₁ - f m₂`\nusing the multilinearity. Here, we give a usable but not very precise version. See\n`norm_image_sub_le_of_bound'` for a more precise but less usable version. The bound is\n`‖f m - f m'‖ ≤ C * card ι * ‖m - m'‖ * (max ‖m‖ ‖m'‖) ^ (card ι - 1)`. -/\ntheorem norm_image_sub_le_of_bound (f : MultilinearMap 𝕜 E G)\n    {C : ℝ} (hC : 0 ≤ C) (H : ∀ m, ‖f m‖ ≤ C * ∏ i, ‖m i‖) (m₁ m₂ : ∀ i, E i) :\n    ‖f m₁ - f m₂‖ ≤ C * Fintype.card ι * max ‖m₁‖ ‖m₂‖ ^ (Fintype.card ι - 1) * ‖m₁ - m₂‖ := by\n  classical\n  have A :\n    ∀ i : ι,\n      ∏ j, (if j = i then ‖m₁ i - m₂ i‖ else max ‖m₁ j‖ ‖m₂ j‖) ≤\n        ‖m₁ - m₂‖ * max ‖m₁‖ ‖m₂‖ ^ (Fintype.card ι - 1) := by\n    intro i\n    calc\n      ∏ j, (if j = i then ‖m₁ i - m₂ i‖ else max ‖m₁ j‖ ‖m₂ j‖) ≤\n          ∏ j : ι, Function.update (fun _ => max ‖m₁‖ ‖m₂‖) i ‖m₁ - m₂‖ j := by\n        apply Finset.prod_le_prod\n        · intro j _\n          by_cases h : j = i <;> simp [h, norm_nonneg]\n        · intro j _\n          by_cases h : j = i\n          · rw [h]\n            simp only [ite_true, Function.update_self]\n            exact norm_le_pi_norm (m₁ - m₂) i\n          · simp [h, - le_sup_iff, - sup_le_iff, sup_le_sup, norm_le_pi_norm]\n      _ = ‖m₁ - m₂‖ * max ‖m₁‖ ‖m₂‖ ^ (Fintype.card ι - 1) := by\n        rw [prod_update_of_mem (Finset.mem_univ _)]\n        simp [card_univ_diff]\n  calc\n    ‖f m₁ - f m₂‖ ≤ C * ∑ i, ∏ j, if j = i then ‖m₁ i - m₂ i‖ else max ‖m₁ j‖ ‖m₂ j‖ :=\n      f.norm_image_sub_le_of_bound' hC H m₁ m₂\n    _ ≤ C * ∑ _i, ‖m₁ - m₂‖ * max ‖m₁‖ ‖m₂‖ ^ (Fintype.card ι - 1) := by gcongr; apply A\n    _ = C * Fintype.card ι * max ‖m₁‖ ‖m₂‖ ^ (Fintype.card ι - 1) * ‖m₁ - m₂‖ := by\n      rw [sum_const, card_univ, nsmul_eq_mul]\n      ring\n\n"}
{"name":"MultilinearMap.continuous_of_bound","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"𝕜 : Type u\nι : Type v\nE : ι → Type wE\nG : Type wG\ninst✝⁵ : NontriviallyNormedField 𝕜\ninst✝⁴ : (i : ι) → SeminormedAddCommGroup (E i)\ninst✝³ : (i : ι) → NormedSpace 𝕜 (E i)\ninst✝² : SeminormedAddCommGroup G\ninst✝¹ : NormedSpace 𝕜 G\ninst✝ : Fintype ι\nf : MultilinearMap 𝕜 E G\nC : Real\nH : ∀ (m : (i : ι) → E i), LE.le (Norm.norm (f m)) (HMul.hMul C (Finset.univ.prod fun i => Norm.norm (m i)))\n⊢ Continuous ⇑f","decl":"/-- If a multilinear map satisfies an inequality `‖f m‖ ≤ C * ∏ i, ‖m i‖`, then it is\ncontinuous. -/\ntheorem continuous_of_bound (f : MultilinearMap 𝕜 E G) (C : ℝ) (H : ∀ m, ‖f m‖ ≤ C * ∏ i, ‖m i‖) :\n    Continuous f := by\n  let D := max C 1\n  have D_pos : 0 ≤ D := le_trans zero_le_one (le_max_right _ _)\n  replace H (m) : ‖f m‖ ≤ D * ∏ i, ‖m i‖ :=\n    (H m).trans (mul_le_mul_of_nonneg_right (le_max_left _ _) <| by positivity)\n  refine continuous_iff_continuousAt.2 fun m => ?_\n  refine\n    continuousAt_of_locally_lipschitz zero_lt_one\n      (D * Fintype.card ι * (‖m‖ + 1) ^ (Fintype.card ι - 1)) fun m' h' => ?_\n  rw [dist_eq_norm, dist_eq_norm]\n  have : max ‖m'‖ ‖m‖ ≤ ‖m‖ + 1 := by\n    simp [zero_le_one, norm_le_of_mem_closedBall (le_of_lt h')]\n  calc\n    ‖f m' - f m‖ ≤ D * Fintype.card ι * max ‖m'‖ ‖m‖ ^ (Fintype.card ι - 1) * ‖m' - m‖ :=\n      f.norm_image_sub_le_of_bound D_pos H m' m\n    _ ≤ D * Fintype.card ι * (‖m‖ + 1) ^ (Fintype.card ι - 1) * ‖m' - m‖ := by gcongr\n\n"}
{"name":"MultilinearMap.coe_mkContinuous","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"𝕜 : Type u\nι : Type v\nE : ι → Type wE\nG : Type wG\ninst✝⁵ : NontriviallyNormedField 𝕜\ninst✝⁴ : (i : ι) → SeminormedAddCommGroup (E i)\ninst✝³ : (i : ι) → NormedSpace 𝕜 (E i)\ninst✝² : SeminormedAddCommGroup G\ninst✝¹ : NormedSpace 𝕜 G\ninst✝ : Fintype ι\nf : MultilinearMap 𝕜 E G\nC : Real\nH : ∀ (m : (i : ι) → E i), LE.le (Norm.norm (f m)) (HMul.hMul C (Finset.univ.prod fun i => Norm.norm (m i)))\n⊢ Eq ⇑(f.mkContinuous C H) ⇑f","decl":"@[simp]\ntheorem coe_mkContinuous (f : MultilinearMap 𝕜 E G) (C : ℝ) (H : ∀ m, ‖f m‖ ≤ C * ∏ i, ‖m i‖) :\n    ⇑(f.mkContinuous C H) = f :=\n  rfl\n\n"}
{"name":"MultilinearMap.restr_norm_le","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"𝕜 : Type u\nG : Type wG\nG' : Type wG'\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : SeminormedAddCommGroup G\ninst✝² : NormedSpace 𝕜 G\ninst✝¹ : SeminormedAddCommGroup G'\ninst✝ : NormedSpace 𝕜 G'\nk n : Nat\nf : MultilinearMap 𝕜 (fun x => G) G'\ns : Finset (Fin n)\nhk : Eq s.card k\nz : G\nC : Real\nH : ∀ (m : Fin n → G), LE.le (Norm.norm (f m)) (HMul.hMul C (Finset.univ.prod fun i => Norm.norm (m i)))\nv : Fin k → G\n⊢ LE.le (Norm.norm ((f.restr s hk z) v)) (HMul.hMul (HMul.hMul C (HPow.hPow (Norm.norm z) (HSub.hSub n k))) (Finset.univ.prod fun i => Norm.norm (v i)))","decl":"/-- Given a multilinear map in `n` variables, if one restricts it to `k` variables putting `z` on\nthe other coordinates, then the resulting restricted function satisfies an inequality\n`‖f.restr v‖ ≤ C * ‖z‖^(n-k) * Π ‖v i‖` if the original function satisfies `‖f v‖ ≤ C * Π ‖v i‖`. -/\ntheorem restr_norm_le {k n : ℕ} (f : MultilinearMap 𝕜 (fun _ : Fin n => G) G')\n    (s : Finset (Fin n)) (hk : #s = k) (z : G) {C : ℝ} (H : ∀ m, ‖f m‖ ≤ C * ∏ i, ‖m i‖)\n    (v : Fin k → G) : ‖f.restr s hk z v‖ ≤ C * ‖z‖ ^ (n - k) * ∏ i, ‖v i‖ := by\n  rw [mul_right_comm, mul_assoc]\n  convert H _ using 2\n  simp only [apply_dite norm, Fintype.prod_dite, prod_const ‖z‖, Finset.card_univ,\n    Fintype.card_of_subtype sᶜ fun _ => mem_compl, card_compl, Fintype.card_fin, hk, mk_coe, ←\n    (s.orderIsoOfFin hk).symm.bijective.prod_comp fun x => ‖v x‖]\n  convert rfl\n\n"}
{"name":"ContinuousMultilinearMap.bound","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"𝕜 : Type u\nι : Type v\nE : ι → Type wE\nG : Type wG\ninst✝⁵ : NontriviallyNormedField 𝕜\ninst✝⁴ : (i : ι) → SeminormedAddCommGroup (E i)\ninst✝³ : (i : ι) → NormedSpace 𝕜 (E i)\ninst✝² : SeminormedAddCommGroup G\ninst✝¹ : NormedSpace 𝕜 G\ninst✝ : Fintype ι\nf : ContinuousMultilinearMap 𝕜 E G\n⊢ Exists fun C => And (LT.lt 0 C) (∀ (m : (i : ι) → E i), LE.le (Norm.norm (f m)) (HMul.hMul C (Finset.univ.prod fun i => Norm.norm (m i))))","decl":"theorem bound (f : ContinuousMultilinearMap 𝕜 E G) :\n    ∃ C : ℝ, 0 < C ∧ ∀ m, ‖f m‖ ≤ C * ∏ i, ‖m i‖ :=\n  f.toMultilinearMap.exists_bound_of_continuous f.2\n\n"}
{"name":"ContinuousMultilinearMap.norm_def","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"𝕜 : Type u\nι : Type v\nE : ι → Type wE\nG : Type wG\ninst✝⁵ : NontriviallyNormedField 𝕜\ninst✝⁴ : (i : ι) → SeminormedAddCommGroup (E i)\ninst✝³ : (i : ι) → NormedSpace 𝕜 (E i)\ninst✝² : SeminormedAddCommGroup G\ninst✝¹ : NormedSpace 𝕜 G\ninst✝ : Fintype ι\nf : ContinuousMultilinearMap 𝕜 E G\n⊢ Eq (Norm.norm f) (InfSet.sInf (setOf fun c => And (LE.le 0 c) (∀ (m : (i : ι) → E i), LE.le (Norm.norm (f m)) (HMul.hMul c (Finset.univ.prod fun i => Norm.norm (m i))))))","decl":"theorem norm_def (f : ContinuousMultilinearMap 𝕜 E G) :\n    ‖f‖ = sInf { c | 0 ≤ (c : ℝ) ∧ ∀ m, ‖f m‖ ≤ c * ∏ i, ‖m i‖ } :=\n  rfl\n\n-- So that invocations of `le_csInf` make sense: we show that the set of\n-- bounds is nonempty and bounded below.\n"}
{"name":"ContinuousMultilinearMap.bounds_nonempty","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"𝕜 : Type u\nι : Type v\nE : ι → Type wE\nG : Type wG\ninst✝⁵ : NontriviallyNormedField 𝕜\ninst✝⁴ : (i : ι) → SeminormedAddCommGroup (E i)\ninst✝³ : (i : ι) → NormedSpace 𝕜 (E i)\ninst✝² : SeminormedAddCommGroup G\ninst✝¹ : NormedSpace 𝕜 G\ninst✝ : Fintype ι\nf : ContinuousMultilinearMap 𝕜 E G\n⊢ Exists fun c => Membership.mem (setOf fun c => And (LE.le 0 c) (∀ (m : (i : ι) → E i), LE.le (Norm.norm (f m)) (HMul.hMul c (Finset.univ.prod fun i => Norm.norm (m i))))) c","decl":"theorem bounds_nonempty {f : ContinuousMultilinearMap 𝕜 E G} :\n    ∃ c, c ∈ { c | 0 ≤ c ∧ ∀ m, ‖f m‖ ≤ c * ∏ i, ‖m i‖ } :=\n  let ⟨M, hMp, hMb⟩ := f.bound\n  ⟨M, le_of_lt hMp, hMb⟩\n\n"}
{"name":"ContinuousMultilinearMap.bounds_bddBelow","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"𝕜 : Type u\nι : Type v\nE : ι → Type wE\nG : Type wG\ninst✝⁵ : NontriviallyNormedField 𝕜\ninst✝⁴ : (i : ι) → SeminormedAddCommGroup (E i)\ninst✝³ : (i : ι) → NormedSpace 𝕜 (E i)\ninst✝² : SeminormedAddCommGroup G\ninst✝¹ : NormedSpace 𝕜 G\ninst✝ : Fintype ι\nf : ContinuousMultilinearMap 𝕜 E G\n⊢ BddBelow (setOf fun c => And (LE.le 0 c) (∀ (m : (i : ι) → E i), LE.le (Norm.norm (f m)) (HMul.hMul c (Finset.univ.prod fun i => Norm.norm (m i)))))","decl":"theorem bounds_bddBelow {f : ContinuousMultilinearMap 𝕜 E G} :\n    BddBelow { c | 0 ≤ c ∧ ∀ m, ‖f m‖ ≤ c * ∏ i, ‖m i‖ } :=\n  ⟨0, fun _ ⟨hn, _⟩ => hn⟩\n\n"}
{"name":"ContinuousMultilinearMap.isLeast_opNorm","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"𝕜 : Type u\nι : Type v\nE : ι → Type wE\nG : Type wG\ninst✝⁵ : NontriviallyNormedField 𝕜\ninst✝⁴ : (i : ι) → SeminormedAddCommGroup (E i)\ninst✝³ : (i : ι) → NormedSpace 𝕜 (E i)\ninst✝² : SeminormedAddCommGroup G\ninst✝¹ : NormedSpace 𝕜 G\ninst✝ : Fintype ι\nf : ContinuousMultilinearMap 𝕜 E G\n⊢ IsLeast (setOf fun c => And (LE.le 0 c) (∀ (m : (i : ι) → E i), LE.le (Norm.norm (f m)) (HMul.hMul c (Finset.univ.prod fun i => Norm.norm (m i))))) (Norm.norm f)","decl":"theorem isLeast_opNorm (f : ContinuousMultilinearMap 𝕜 E G) :\n    IsLeast {c : ℝ | 0 ≤ c ∧ ∀ m, ‖f m‖ ≤ c * ∏ i, ‖m i‖} ‖f‖ := by\n  refine IsClosed.isLeast_csInf ?_ bounds_nonempty bounds_bddBelow\n  simp only [Set.setOf_and, Set.setOf_forall]\n  exact isClosed_Ici.inter (isClosed_iInter fun m ↦\n    isClosed_le continuous_const (continuous_id.mul continuous_const))\n\n"}
{"name":"ContinuousMultilinearMap.opNorm_nonneg","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"𝕜 : Type u\nι : Type v\nE : ι → Type wE\nG : Type wG\ninst✝⁵ : NontriviallyNormedField 𝕜\ninst✝⁴ : (i : ι) → SeminormedAddCommGroup (E i)\ninst✝³ : (i : ι) → NormedSpace 𝕜 (E i)\ninst✝² : SeminormedAddCommGroup G\ninst✝¹ : NormedSpace 𝕜 G\ninst✝ : Fintype ι\nf : ContinuousMultilinearMap 𝕜 E G\n⊢ LE.le 0 (Norm.norm f)","decl":"theorem opNorm_nonneg (f : ContinuousMultilinearMap 𝕜 E G) : 0 ≤ ‖f‖ :=\n  Real.sInf_nonneg fun _ ⟨hx, _⟩ => hx\n\n"}
{"name":"ContinuousMultilinearMap.le_opNorm","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"𝕜 : Type u\nι : Type v\nE : ι → Type wE\nG : Type wG\ninst✝⁵ : NontriviallyNormedField 𝕜\ninst✝⁴ : (i : ι) → SeminormedAddCommGroup (E i)\ninst✝³ : (i : ι) → NormedSpace 𝕜 (E i)\ninst✝² : SeminormedAddCommGroup G\ninst✝¹ : NormedSpace 𝕜 G\ninst✝ : Fintype ι\nf : ContinuousMultilinearMap 𝕜 E G\nm : (i : ι) → E i\n⊢ LE.le (Norm.norm (f m)) (HMul.hMul (Norm.norm f) (Finset.univ.prod fun i => Norm.norm (m i)))","decl":"/-- The fundamental property of the operator norm of a continuous multilinear map:\n`‖f m‖` is bounded by `‖f‖` times the product of the `‖m i‖`. -/\ntheorem le_opNorm (f : ContinuousMultilinearMap 𝕜 E G) (m : ∀ i, E i) :\n    ‖f m‖ ≤ ‖f‖ * ∏ i, ‖m i‖ :=\n  f.isLeast_opNorm.1.2 m\n\n"}
{"name":"ContinuousMultilinearMap.le_mul_prod_of_opNorm_le_of_le","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"𝕜 : Type u\nι : Type v\nE : ι → Type wE\nG : Type wG\ninst✝⁵ : NontriviallyNormedField 𝕜\ninst✝⁴ : (i : ι) → SeminormedAddCommGroup (E i)\ninst✝³ : (i : ι) → NormedSpace 𝕜 (E i)\ninst✝² : SeminormedAddCommGroup G\ninst✝¹ : NormedSpace 𝕜 G\ninst✝ : Fintype ι\nf : ContinuousMultilinearMap 𝕜 E G\nm : (i : ι) → E i\nC : Real\nb : ι → Real\nhC : LE.le (Norm.norm f) C\nhm : ∀ (i : ι), LE.le (Norm.norm (m i)) (b i)\n⊢ LE.le (Norm.norm (f m)) (HMul.hMul C (Finset.univ.prod fun i => b i))","decl":"theorem le_mul_prod_of_opNorm_le_of_le {f : ContinuousMultilinearMap 𝕜 E G}\n    {m : ∀ i, E i} {C : ℝ} {b : ι → ℝ} (hC : ‖f‖ ≤ C) (hm : ∀ i, ‖m i‖ ≤ b i) :\n    ‖f m‖ ≤ C * ∏ i, b i :=\n  (f.le_opNorm m).trans <| by gcongr; exacts [f.opNorm_nonneg.trans hC, hm _]\n\n"}
{"name":"ContinuousMultilinearMap.le_mul_prod_of_le_opNorm_of_le","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"𝕜 : Type u\nι : Type v\nE : ι → Type wE\nG : Type wG\ninst✝⁵ : NontriviallyNormedField 𝕜\ninst✝⁴ : (i : ι) → SeminormedAddCommGroup (E i)\ninst✝³ : (i : ι) → NormedSpace 𝕜 (E i)\ninst✝² : SeminormedAddCommGroup G\ninst✝¹ : NormedSpace 𝕜 G\ninst✝ : Fintype ι\nf : ContinuousMultilinearMap 𝕜 E G\nm : (i : ι) → E i\nC : Real\nb : ι → Real\nhC : LE.le (Norm.norm f) C\nhm : ∀ (i : ι), LE.le (Norm.norm (m i)) (b i)\n⊢ LE.le (Norm.norm (f m)) (HMul.hMul C (Finset.univ.prod fun i => b i))","decl":"@[deprecated (since := \"2024-11-27\")]\nalias le_mul_prod_of_le_opNorm_of_le := le_mul_prod_of_opNorm_le_of_le\n\n"}
{"name":"ContinuousMultilinearMap.le_opNorm_mul_prod_of_le","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"𝕜 : Type u\nι : Type v\nE : ι → Type wE\nG : Type wG\ninst✝⁵ : NontriviallyNormedField 𝕜\ninst✝⁴ : (i : ι) → SeminormedAddCommGroup (E i)\ninst✝³ : (i : ι) → NormedSpace 𝕜 (E i)\ninst✝² : SeminormedAddCommGroup G\ninst✝¹ : NormedSpace 𝕜 G\ninst✝ : Fintype ι\nf : ContinuousMultilinearMap 𝕜 E G\nm : (i : ι) → E i\nb : ι → Real\nhm : ∀ (i : ι), LE.le (Norm.norm (m i)) (b i)\n⊢ LE.le (Norm.norm (f m)) (HMul.hMul (Norm.norm f) (Finset.univ.prod fun i => b i))","decl":"theorem le_opNorm_mul_prod_of_le (f : ContinuousMultilinearMap 𝕜 E G)\n    {m : ∀ i, E i} {b : ι → ℝ} (hm : ∀ i, ‖m i‖ ≤ b i) : ‖f m‖ ≤ ‖f‖ * ∏ i, b i :=\n  le_mul_prod_of_opNorm_le_of_le le_rfl hm\n\n"}
{"name":"ContinuousMultilinearMap.le_opNorm_mul_pow_card_of_le","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"𝕜 : Type u\nι : Type v\nE : ι → Type wE\nG : Type wG\ninst✝⁵ : NontriviallyNormedField 𝕜\ninst✝⁴ : (i : ι) → SeminormedAddCommGroup (E i)\ninst✝³ : (i : ι) → NormedSpace 𝕜 (E i)\ninst✝² : SeminormedAddCommGroup G\ninst✝¹ : NormedSpace 𝕜 G\ninst✝ : Fintype ι\nf : ContinuousMultilinearMap 𝕜 E G\nm : (i : ι) → E i\nb : Real\nhm : LE.le (Norm.norm m) b\n⊢ LE.le (Norm.norm (f m)) (HMul.hMul (Norm.norm f) (HPow.hPow b (Fintype.card ι)))","decl":"theorem le_opNorm_mul_pow_card_of_le (f : ContinuousMultilinearMap 𝕜 E G) {m b} (hm : ‖m‖ ≤ b) :\n    ‖f m‖ ≤ ‖f‖ * b ^ Fintype.card ι := by\n  simpa only [prod_const] using f.le_opNorm_mul_prod_of_le fun i => (norm_le_pi_norm m i).trans hm\n\n"}
{"name":"ContinuousMultilinearMap.le_opNorm_mul_pow_of_le","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"𝕜 : Type u\nG : Type wG\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : SeminormedAddCommGroup G\ninst✝² : NormedSpace 𝕜 G\nn : Nat\nEi : Fin n → Type u_1\ninst✝¹ : (i : Fin n) → SeminormedAddCommGroup (Ei i)\ninst✝ : (i : Fin n) → NormedSpace 𝕜 (Ei i)\nf : ContinuousMultilinearMap 𝕜 Ei G\nm : (i : Fin n) → Ei i\nb : Real\nhm : LE.le (Norm.norm m) b\n⊢ LE.le (Norm.norm (f m)) (HMul.hMul (Norm.norm f) (HPow.hPow b n))","decl":"theorem le_opNorm_mul_pow_of_le {n : ℕ} {Ei : Fin n → Type*} [∀ i, SeminormedAddCommGroup (Ei i)]\n    [∀ i, NormedSpace 𝕜 (Ei i)] (f : ContinuousMultilinearMap 𝕜 Ei G) {m : ∀ i, Ei i} {b : ℝ}\n    (hm : ‖m‖ ≤ b) : ‖f m‖ ≤ ‖f‖ * b ^ n := by\n  simpa only [Fintype.card_fin] using f.le_opNorm_mul_pow_card_of_le hm\n\n"}
{"name":"ContinuousMultilinearMap.le_of_opNorm_le","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"𝕜 : Type u\nι : Type v\nE : ι → Type wE\nG : Type wG\ninst✝⁵ : NontriviallyNormedField 𝕜\ninst✝⁴ : (i : ι) → SeminormedAddCommGroup (E i)\ninst✝³ : (i : ι) → NormedSpace 𝕜 (E i)\ninst✝² : SeminormedAddCommGroup G\ninst✝¹ : NormedSpace 𝕜 G\ninst✝ : Fintype ι\nf : ContinuousMultilinearMap 𝕜 E G\nC : Real\nh : LE.le (Norm.norm f) C\nm : (i : ι) → E i\n⊢ LE.le (Norm.norm (f m)) (HMul.hMul C (Finset.univ.prod fun i => Norm.norm (m i)))","decl":"theorem le_of_opNorm_le {f : ContinuousMultilinearMap 𝕜 E G} {C : ℝ} (h : ‖f‖ ≤ C) (m : ∀ i, E i) :\n    ‖f m‖ ≤ C * ∏ i, ‖m i‖ :=\n  le_mul_prod_of_opNorm_le_of_le h fun _ ↦ le_rfl\n\n"}
{"name":"ContinuousMultilinearMap.ratio_le_opNorm","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"𝕜 : Type u\nι : Type v\nE : ι → Type wE\nG : Type wG\ninst✝⁵ : NontriviallyNormedField 𝕜\ninst✝⁴ : (i : ι) → SeminormedAddCommGroup (E i)\ninst✝³ : (i : ι) → NormedSpace 𝕜 (E i)\ninst✝² : SeminormedAddCommGroup G\ninst✝¹ : NormedSpace 𝕜 G\ninst✝ : Fintype ι\nf : ContinuousMultilinearMap 𝕜 E G\nm : (i : ι) → E i\n⊢ LE.le (HDiv.hDiv (Norm.norm (f m)) (Finset.univ.prod fun i => Norm.norm (m i))) (Norm.norm f)","decl":"theorem ratio_le_opNorm (f : ContinuousMultilinearMap 𝕜 E G) (m : ∀ i, E i) :\n    (‖f m‖ / ∏ i, ‖m i‖) ≤ ‖f‖ :=\n  div_le_of_le_mul₀ (by positivity) (opNorm_nonneg _) (f.le_opNorm m)\n\n"}
{"name":"ContinuousMultilinearMap.unit_le_opNorm","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"𝕜 : Type u\nι : Type v\nE : ι → Type wE\nG : Type wG\ninst✝⁵ : NontriviallyNormedField 𝕜\ninst✝⁴ : (i : ι) → SeminormedAddCommGroup (E i)\ninst✝³ : (i : ι) → NormedSpace 𝕜 (E i)\ninst✝² : SeminormedAddCommGroup G\ninst✝¹ : NormedSpace 𝕜 G\ninst✝ : Fintype ι\nf : ContinuousMultilinearMap 𝕜 E G\nm : (i : ι) → E i\nh : LE.le (Norm.norm m) 1\n⊢ LE.le (Norm.norm (f m)) (Norm.norm f)","decl":"/-- The image of the unit ball under a continuous multilinear map is bounded. -/\ntheorem unit_le_opNorm (f : ContinuousMultilinearMap 𝕜 E G) {m : ∀ i, E i} (h : ‖m‖ ≤ 1) :\n    ‖f m‖ ≤ ‖f‖ :=\n  (le_opNorm_mul_pow_card_of_le f h).trans <| by simp\n\n"}
{"name":"ContinuousMultilinearMap.opNorm_le_bound","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"𝕜 : Type u\nι : Type v\nE : ι → Type wE\nG : Type wG\ninst✝⁵ : NontriviallyNormedField 𝕜\ninst✝⁴ : (i : ι) → SeminormedAddCommGroup (E i)\ninst✝³ : (i : ι) → NormedSpace 𝕜 (E i)\ninst✝² : SeminormedAddCommGroup G\ninst✝¹ : NormedSpace 𝕜 G\ninst✝ : Fintype ι\nf : ContinuousMultilinearMap 𝕜 E G\nM : Real\nhMp : LE.le 0 M\nhM : ∀ (m : (i : ι) → E i), LE.le (Norm.norm (f m)) (HMul.hMul M (Finset.univ.prod fun i => Norm.norm (m i)))\n⊢ LE.le (Norm.norm f) M","decl":"/-- If one controls the norm of every `f x`, then one controls the norm of `f`. -/\ntheorem opNorm_le_bound {f : ContinuousMultilinearMap 𝕜 E G}\n    {M : ℝ} (hMp : 0 ≤ M) (hM : ∀ m, ‖f m‖ ≤ M * ∏ i, ‖m i‖) : ‖f‖ ≤ M :=\n  csInf_le bounds_bddBelow ⟨hMp, hM⟩\n\n"}
{"name":"ContinuousMultilinearMap.opNorm_le_iff","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"𝕜 : Type u\nι : Type v\nE : ι → Type wE\nG : Type wG\ninst✝⁵ : NontriviallyNormedField 𝕜\ninst✝⁴ : (i : ι) → SeminormedAddCommGroup (E i)\ninst✝³ : (i : ι) → NormedSpace 𝕜 (E i)\ninst✝² : SeminormedAddCommGroup G\ninst✝¹ : NormedSpace 𝕜 G\ninst✝ : Fintype ι\nf : ContinuousMultilinearMap 𝕜 E G\nC : Real\nhC : LE.le 0 C\n⊢ Iff (LE.le (Norm.norm f) C) (∀ (m : (i : ι) → E i), LE.le (Norm.norm (f m)) (HMul.hMul C (Finset.univ.prod fun i => Norm.norm (m i))))","decl":"theorem opNorm_le_iff {f : ContinuousMultilinearMap 𝕜 E G} {C : ℝ} (hC : 0 ≤ C) :\n    ‖f‖ ≤ C ↔ ∀ m, ‖f m‖ ≤ C * ∏ i, ‖m i‖ :=\n  ⟨fun h _ ↦ le_of_opNorm_le h _, opNorm_le_bound hC⟩\n\n"}
{"name":"ContinuousMultilinearMap.opNorm_add_le","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"𝕜 : Type u\nι : Type v\nE : ι → Type wE\nG : Type wG\ninst✝⁵ : NontriviallyNormedField 𝕜\ninst✝⁴ : (i : ι) → SeminormedAddCommGroup (E i)\ninst✝³ : (i : ι) → NormedSpace 𝕜 (E i)\ninst✝² : SeminormedAddCommGroup G\ninst✝¹ : NormedSpace 𝕜 G\ninst✝ : Fintype ι\nf g : ContinuousMultilinearMap 𝕜 E G\n⊢ LE.le (Norm.norm (HAdd.hAdd f g)) (HAdd.hAdd (Norm.norm f) (Norm.norm g))","decl":"/-- The operator norm satisfies the triangle inequality. -/\ntheorem opNorm_add_le (f g : ContinuousMultilinearMap 𝕜 E G) : ‖f + g‖ ≤ ‖f‖ + ‖g‖ :=\n  opNorm_le_bound (add_nonneg (opNorm_nonneg f) (opNorm_nonneg g)) fun x => by\n    rw [add_mul]\n    exact norm_add_le_of_le (le_opNorm _ _) (le_opNorm _ _)\n\n"}
{"name":"ContinuousMultilinearMap.opNorm_zero","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"𝕜 : Type u\nι : Type v\nE : ι → Type wE\nG : Type wG\ninst✝⁵ : NontriviallyNormedField 𝕜\ninst✝⁴ : (i : ι) → SeminormedAddCommGroup (E i)\ninst✝³ : (i : ι) → NormedSpace 𝕜 (E i)\ninst✝² : SeminormedAddCommGroup G\ninst✝¹ : NormedSpace 𝕜 G\ninst✝ : Fintype ι\n⊢ Eq (Norm.norm 0) 0","decl":"theorem opNorm_zero : ‖(0 : ContinuousMultilinearMap 𝕜 E G)‖ = 0 :=\n  (opNorm_nonneg _).antisymm' <| opNorm_le_bound le_rfl fun m => by simp\n\n"}
{"name":"ContinuousMultilinearMap.opNorm_smul_le","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"𝕜 : Type u\nι : Type v\nE : ι → Type wE\nG : Type wG\ninst✝⁸ : NontriviallyNormedField 𝕜\ninst✝⁷ : (i : ι) → SeminormedAddCommGroup (E i)\ninst✝⁶ : (i : ι) → NormedSpace 𝕜 (E i)\ninst✝⁵ : SeminormedAddCommGroup G\ninst✝⁴ : NormedSpace 𝕜 G\ninst✝³ : Fintype ι\n𝕜' : Type u_1\ninst✝² : NormedField 𝕜'\ninst✝¹ : NormedSpace 𝕜' G\ninst✝ : SMulCommClass 𝕜 𝕜' G\nc : 𝕜'\nf : ContinuousMultilinearMap 𝕜 E G\n⊢ LE.le (Norm.norm (HSMul.hSMul c f)) (HMul.hMul (Norm.norm c) (Norm.norm f))","decl":"theorem opNorm_smul_le (c : 𝕜') (f : ContinuousMultilinearMap 𝕜 E G) : ‖c • f‖ ≤ ‖c‖ * ‖f‖ :=\n  (c • f).opNorm_le_bound (mul_nonneg (norm_nonneg _) (opNorm_nonneg _)) fun m ↦ by\n    rw [smul_apply, norm_smul, mul_assoc]\n    exact mul_le_mul_of_nonneg_left (le_opNorm _ _) (norm_nonneg _)\n\n"}
{"name":"ContinuousMultilinearMap.opNorm_neg","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"𝕜 : Type u\nι : Type v\nE : ι → Type wE\nG : Type wG\ninst✝⁵ : NontriviallyNormedField 𝕜\ninst✝⁴ : (i : ι) → SeminormedAddCommGroup (E i)\ninst✝³ : (i : ι) → NormedSpace 𝕜 (E i)\ninst✝² : SeminormedAddCommGroup G\ninst✝¹ : NormedSpace 𝕜 G\ninst✝ : Fintype ι\nf : ContinuousMultilinearMap 𝕜 E G\n⊢ Eq (Norm.norm (Neg.neg f)) (Norm.norm f)","decl":"@[deprecated norm_neg (since := \"2024-11-24\")]\ntheorem opNorm_neg (f : ContinuousMultilinearMap 𝕜 E G) : ‖-f‖ = ‖f‖ := norm_neg f\n\n"}
{"name":"ContinuousMultilinearMap.le_opNNNorm","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"𝕜 : Type u\nι : Type v\nE : ι → Type wE\nG : Type wG\ninst✝⁵ : NontriviallyNormedField 𝕜\ninst✝⁴ : (i : ι) → SeminormedAddCommGroup (E i)\ninst✝³ : (i : ι) → NormedSpace 𝕜 (E i)\ninst✝² : SeminormedAddCommGroup G\ninst✝¹ : NormedSpace 𝕜 G\ninst✝ : Fintype ι\nf : ContinuousMultilinearMap 𝕜 E G\nm : (i : ι) → E i\n⊢ LE.le (NNNorm.nnnorm (f m)) (HMul.hMul (NNNorm.nnnorm f) (Finset.univ.prod fun i => NNNorm.nnnorm (m i)))","decl":"/-- The fundamental property of the operator norm of a continuous multilinear map:\n`‖f m‖` is bounded by `‖f‖` times the product of the `‖m i‖`, `nnnorm` version. -/\ntheorem le_opNNNorm (f : ContinuousMultilinearMap 𝕜 E G) (m : ∀ i, E i) :\n    ‖f m‖₊ ≤ ‖f‖₊ * ∏ i, ‖m i‖₊ :=\n  NNReal.coe_le_coe.1 <| by\n    push_cast\n    exact f.le_opNorm m\n\n"}
{"name":"ContinuousMultilinearMap.le_of_opNNNorm_le","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"𝕜 : Type u\nι : Type v\nE : ι → Type wE\nG : Type wG\ninst✝⁵ : NontriviallyNormedField 𝕜\ninst✝⁴ : (i : ι) → SeminormedAddCommGroup (E i)\ninst✝³ : (i : ι) → NormedSpace 𝕜 (E i)\ninst✝² : SeminormedAddCommGroup G\ninst✝¹ : NormedSpace 𝕜 G\ninst✝ : Fintype ι\nf : ContinuousMultilinearMap 𝕜 E G\nC : NNReal\nh : LE.le (NNNorm.nnnorm f) C\nm : (i : ι) → E i\n⊢ LE.le (NNNorm.nnnorm (f m)) (HMul.hMul C (Finset.univ.prod fun i => NNNorm.nnnorm (m i)))","decl":"theorem le_of_opNNNorm_le (f : ContinuousMultilinearMap 𝕜 E G)\n    {C : ℝ≥0} (h : ‖f‖₊ ≤ C) (m : ∀ i, E i) : ‖f m‖₊ ≤ C * ∏ i, ‖m i‖₊ :=\n  (f.le_opNNNorm m).trans <| mul_le_mul' h le_rfl\n\n"}
{"name":"ContinuousMultilinearMap.opNNNorm_le_iff","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"𝕜 : Type u\nι : Type v\nE : ι → Type wE\nG : Type wG\ninst✝⁵ : NontriviallyNormedField 𝕜\ninst✝⁴ : (i : ι) → SeminormedAddCommGroup (E i)\ninst✝³ : (i : ι) → NormedSpace 𝕜 (E i)\ninst✝² : SeminormedAddCommGroup G\ninst✝¹ : NormedSpace 𝕜 G\ninst✝ : Fintype ι\nf : ContinuousMultilinearMap 𝕜 E G\nC : NNReal\n⊢ Iff (LE.le (NNNorm.nnnorm f) C) (∀ (m : (i : ι) → E i), LE.le (NNNorm.nnnorm (f m)) (HMul.hMul C (Finset.univ.prod fun i => NNNorm.nnnorm (m i))))","decl":"theorem opNNNorm_le_iff {f : ContinuousMultilinearMap 𝕜 E G} {C : ℝ≥0} :\n    ‖f‖₊ ≤ C ↔ ∀ m, ‖f m‖₊ ≤ C * ∏ i, ‖m i‖₊ := by\n  simp only [← NNReal.coe_le_coe]; simp [opNorm_le_iff C.coe_nonneg, NNReal.coe_prod]\n\n"}
{"name":"ContinuousMultilinearMap.isLeast_opNNNorm","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"𝕜 : Type u\nι : Type v\nE : ι → Type wE\nG : Type wG\ninst✝⁵ : NontriviallyNormedField 𝕜\ninst✝⁴ : (i : ι) → SeminormedAddCommGroup (E i)\ninst✝³ : (i : ι) → NormedSpace 𝕜 (E i)\ninst✝² : SeminormedAddCommGroup G\ninst✝¹ : NormedSpace 𝕜 G\ninst✝ : Fintype ι\nf : ContinuousMultilinearMap 𝕜 E G\n⊢ IsLeast (setOf fun C => ∀ (m : (i : ι) → E i), LE.le (NNNorm.nnnorm (f m)) (HMul.hMul C (Finset.univ.prod fun i => NNNorm.nnnorm (m i)))) (NNNorm.nnnorm f)","decl":"theorem isLeast_opNNNorm (f : ContinuousMultilinearMap 𝕜 E G) :\n    IsLeast {C : ℝ≥0 | ∀ m, ‖f m‖₊ ≤ C * ∏ i, ‖m i‖₊} ‖f‖₊ := by\n  simpa only [← opNNNorm_le_iff] using isLeast_Ici\n\n"}
{"name":"ContinuousMultilinearMap.opNNNorm_prod","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"𝕜 : Type u\nι : Type v\nE : ι → Type wE\nG : Type wG\nG' : Type wG'\ninst✝⁷ : NontriviallyNormedField 𝕜\ninst✝⁶ : (i : ι) → SeminormedAddCommGroup (E i)\ninst✝⁵ : (i : ι) → NormedSpace 𝕜 (E i)\ninst✝⁴ : SeminormedAddCommGroup G\ninst✝³ : NormedSpace 𝕜 G\ninst✝² : SeminormedAddCommGroup G'\ninst✝¹ : NormedSpace 𝕜 G'\ninst✝ : Fintype ι\nf : ContinuousMultilinearMap 𝕜 E G\ng : ContinuousMultilinearMap 𝕜 E G'\n⊢ Eq (NNNorm.nnnorm (f.prod g)) (Max.max (NNNorm.nnnorm f) (NNNorm.nnnorm g))","decl":"theorem opNNNorm_prod (f : ContinuousMultilinearMap 𝕜 E G) (g : ContinuousMultilinearMap 𝕜 E G') :\n    ‖f.prod g‖₊ = max ‖f‖₊ ‖g‖₊ :=\n  eq_of_forall_ge_iff fun _ ↦ by\n    simp only [opNNNorm_le_iff, prod_apply, Prod.nnnorm_def, max_le_iff, forall_and]\n\n"}
{"name":"ContinuousMultilinearMap.opNorm_prod","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"𝕜 : Type u\nι : Type v\nE : ι → Type wE\nG : Type wG\nG' : Type wG'\ninst✝⁷ : NontriviallyNormedField 𝕜\ninst✝⁶ : (i : ι) → SeminormedAddCommGroup (E i)\ninst✝⁵ : (i : ι) → NormedSpace 𝕜 (E i)\ninst✝⁴ : SeminormedAddCommGroup G\ninst✝³ : NormedSpace 𝕜 G\ninst✝² : SeminormedAddCommGroup G'\ninst✝¹ : NormedSpace 𝕜 G'\ninst✝ : Fintype ι\nf : ContinuousMultilinearMap 𝕜 E G\ng : ContinuousMultilinearMap 𝕜 E G'\n⊢ Eq (Norm.norm (f.prod g)) (Max.max (Norm.norm f) (Norm.norm g))","decl":"theorem opNorm_prod (f : ContinuousMultilinearMap 𝕜 E G) (g : ContinuousMultilinearMap 𝕜 E G') :\n    ‖f.prod g‖ = max ‖f‖ ‖g‖ :=\n  congr_arg NNReal.toReal (opNNNorm_prod f g)\n\n"}
{"name":"ContinuousMultilinearMap.opNNNorm_pi","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"𝕜 : Type u\nι : Type v\nι' : Type v'\nE : ι → Type wE\nE' : ι' → Type wE'\ninst✝⁶ : Fintype ι'\ninst✝⁵ : NontriviallyNormedField 𝕜\ninst✝⁴ : (i : ι) → SeminormedAddCommGroup (E i)\ninst✝³ : (i : ι) → NormedSpace 𝕜 (E i)\ninst✝² : Fintype ι\ninst✝¹ : (i' : ι') → SeminormedAddCommGroup (E' i')\ninst✝ : (i' : ι') → NormedSpace 𝕜 (E' i')\nf : (i' : ι') → ContinuousMultilinearMap 𝕜 E (E' i')\n⊢ Eq (NNNorm.nnnorm (ContinuousMultilinearMap.pi f)) (NNNorm.nnnorm f)","decl":"theorem opNNNorm_pi\n    [∀ i', SeminormedAddCommGroup (E' i')] [∀ i', NormedSpace 𝕜 (E' i')]\n    (f : ∀ i', ContinuousMultilinearMap 𝕜 E (E' i')) : ‖pi f‖₊ = ‖f‖₊ :=\n  eq_of_forall_ge_iff fun _ ↦ by simpa [opNNNorm_le_iff, pi_nnnorm_le_iff] using forall_swap\n\n"}
{"name":"ContinuousMultilinearMap.opNorm_pi","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"𝕜 : Type u\nι : Type v\nE : ι → Type wE\ninst✝⁶ : NontriviallyNormedField 𝕜\ninst✝⁵ : (i : ι) → SeminormedAddCommGroup (E i)\ninst✝⁴ : (i : ι) → NormedSpace 𝕜 (E i)\ninst✝³ : Fintype ι\nι' : Type v'\ninst✝² : Fintype ι'\nE' : ι' → Type wE'\ninst✝¹ : (i' : ι') → SeminormedAddCommGroup (E' i')\ninst✝ : (i' : ι') → NormedSpace 𝕜 (E' i')\nf : (i' : ι') → ContinuousMultilinearMap 𝕜 E (E' i')\n⊢ Eq (Norm.norm (ContinuousMultilinearMap.pi f)) (Norm.norm f)","decl":"theorem opNorm_pi {ι' : Type v'} [Fintype ι'] {E' : ι' → Type wE'}\n    [∀ i', SeminormedAddCommGroup (E' i')] [∀ i', NormedSpace 𝕜 (E' i')]\n    (f : ∀ i', ContinuousMultilinearMap 𝕜 E (E' i')) :\n    ‖pi f‖ = ‖f‖ :=\n  congr_arg NNReal.toReal (opNNNorm_pi f)\n\n"}
{"name":"ContinuousMultilinearMap.norm_ofSubsingleton","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"𝕜 : Type u\nι : Type v\nG : Type wG\nG' : Type wG'\ninst✝⁶ : NontriviallyNormedField 𝕜\ninst✝⁵ : SeminormedAddCommGroup G\ninst✝⁴ : NormedSpace 𝕜 G\ninst✝³ : SeminormedAddCommGroup G'\ninst✝² : NormedSpace 𝕜 G'\ninst✝¹ : Fintype ι\ninst✝ : Subsingleton ι\ni : ι\nf : ContinuousLinearMap (RingHom.id 𝕜) G G'\n⊢ Eq (Norm.norm ((ContinuousMultilinearMap.ofSubsingleton 𝕜 G G' i) f)) (Norm.norm f)","decl":"@[simp]\ntheorem norm_ofSubsingleton [Subsingleton ι] (i : ι) (f : G →L[𝕜] G') :\n    ‖ofSubsingleton 𝕜 G G' i f‖ = ‖f‖ := by\n  letI : Unique ι := uniqueOfSubsingleton i\n  simp [norm_def, ContinuousLinearMap.norm_def, (Equiv.funUnique _ _).symm.surjective.forall]\n\n"}
{"name":"ContinuousMultilinearMap.nnnorm_ofSubsingleton","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"𝕜 : Type u\nι : Type v\nG : Type wG\nG' : Type wG'\ninst✝⁶ : NontriviallyNormedField 𝕜\ninst✝⁵ : SeminormedAddCommGroup G\ninst✝⁴ : NormedSpace 𝕜 G\ninst✝³ : SeminormedAddCommGroup G'\ninst✝² : NormedSpace 𝕜 G'\ninst✝¹ : Fintype ι\ninst✝ : Subsingleton ι\ni : ι\nf : ContinuousLinearMap (RingHom.id 𝕜) G G'\n⊢ Eq (NNNorm.nnnorm ((ContinuousMultilinearMap.ofSubsingleton 𝕜 G G' i) f)) (NNNorm.nnnorm f)","decl":"@[simp]\ntheorem nnnorm_ofSubsingleton [Subsingleton ι] (i : ι) (f : G →L[𝕜] G') :\n    ‖ofSubsingleton 𝕜 G G' i f‖₊ = ‖f‖₊ :=\n  NNReal.eq <| norm_ofSubsingleton i f\n\n"}
{"name":"ContinuousMultilinearMap.ofSubsingletonₗᵢ_apply","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"𝕜 : Type u\nι : Type v\nG : Type wG\nG' : Type wG'\ninst✝⁶ : NontriviallyNormedField 𝕜\ninst✝⁵ : SeminormedAddCommGroup G\ninst✝⁴ : NormedSpace 𝕜 G\ninst✝³ : SeminormedAddCommGroup G'\ninst✝² : NormedSpace 𝕜 G'\ninst✝¹ : Fintype ι\ninst✝ : Subsingleton ι\ni : ι\na✝ : ContinuousLinearMap (RingHom.id 𝕜) G G'\n⊢ Eq ((ContinuousMultilinearMap.ofSubsingletonₗᵢ 𝕜 G i) a✝) ((ContinuousMultilinearMap.ofSubsingleton 𝕜 G G' i).toFun a✝)","decl":"/-- Linear isometry between continuous linear maps from `G` to `G'`\nand continuous `1`-multilinear maps from `G` to `G'`. -/\n@[simps apply symm_apply]\ndef ofSubsingletonₗᵢ [Subsingleton ι] (i : ι) :\n    (G →L[𝕜] G') ≃ₗᵢ[𝕜] ContinuousMultilinearMap 𝕜 (fun _ : ι ↦ G) G' :=\n  { ofSubsingleton 𝕜 G G' i with\n    map_add' := fun _ _ ↦ rfl\n    map_smul' := fun _ _ ↦ rfl\n    norm_map' := norm_ofSubsingleton i }\n\n"}
{"name":"ContinuousMultilinearMap.ofSubsingletonₗᵢ_symm_apply","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"𝕜 : Type u\nι : Type v\nG : Type wG\nG' : Type wG'\ninst✝⁶ : NontriviallyNormedField 𝕜\ninst✝⁵ : SeminormedAddCommGroup G\ninst✝⁴ : NormedSpace 𝕜 G\ninst✝³ : SeminormedAddCommGroup G'\ninst✝² : NormedSpace 𝕜 G'\ninst✝¹ : Fintype ι\ninst✝ : Subsingleton ι\ni : ι\na✝ : ContinuousMultilinearMap 𝕜 (fun x => G) G'\n⊢ Eq ((ContinuousMultilinearMap.ofSubsingletonₗᵢ 𝕜 G i).symm a✝) ((ContinuousMultilinearMap.ofSubsingleton 𝕜 G G' i).invFun a✝)","decl":"/-- Linear isometry between continuous linear maps from `G` to `G'`\nand continuous `1`-multilinear maps from `G` to `G'`. -/\n@[simps apply symm_apply]\ndef ofSubsingletonₗᵢ [Subsingleton ι] (i : ι) :\n    (G →L[𝕜] G') ≃ₗᵢ[𝕜] ContinuousMultilinearMap 𝕜 (fun _ : ι ↦ G) G' :=\n  { ofSubsingleton 𝕜 G G' i with\n    map_add' := fun _ _ ↦ rfl\n    map_smul' := fun _ _ ↦ rfl\n    norm_map' := norm_ofSubsingleton i }\n\n"}
{"name":"ContinuousMultilinearMap.norm_ofSubsingleton_id_le","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"𝕜 : Type u\nι : Type v\nG : Type wG\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : SeminormedAddCommGroup G\ninst✝² : NormedSpace 𝕜 G\ninst✝¹ : Fintype ι\ninst✝ : Subsingleton ι\ni : ι\n⊢ LE.le (Norm.norm ((ContinuousMultilinearMap.ofSubsingleton 𝕜 G G i) (ContinuousLinearMap.id 𝕜 G))) 1","decl":"theorem norm_ofSubsingleton_id_le [Subsingleton ι] (i : ι) :\n    ‖ofSubsingleton 𝕜 G G i (.id _ _)‖ ≤ 1 := by\n  rw [norm_ofSubsingleton]\n  apply ContinuousLinearMap.norm_id_le\n\n"}
{"name":"ContinuousMultilinearMap.nnnorm_ofSubsingleton_id_le","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"𝕜 : Type u\nι : Type v\nG : Type wG\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : SeminormedAddCommGroup G\ninst✝² : NormedSpace 𝕜 G\ninst✝¹ : Fintype ι\ninst✝ : Subsingleton ι\ni : ι\n⊢ LE.le (NNNorm.nnnorm ((ContinuousMultilinearMap.ofSubsingleton 𝕜 G G i) (ContinuousLinearMap.id 𝕜 G))) 1","decl":"theorem nnnorm_ofSubsingleton_id_le [Subsingleton ι] (i : ι) :\n    ‖ofSubsingleton 𝕜 G G i (.id _ _)‖₊ ≤ 1 :=\n  norm_ofSubsingleton_id_le _ _ _\n\n"}
{"name":"ContinuousMultilinearMap.norm_constOfIsEmpty","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"𝕜 : Type u\nι : Type v\nE : ι → Type wE\nG : Type wG\ninst✝⁶ : NontriviallyNormedField 𝕜\ninst✝⁵ : (i : ι) → SeminormedAddCommGroup (E i)\ninst✝⁴ : (i : ι) → NormedSpace 𝕜 (E i)\ninst✝³ : SeminormedAddCommGroup G\ninst✝² : NormedSpace 𝕜 G\ninst✝¹ : Fintype ι\ninst✝ : IsEmpty ι\nx : G\n⊢ Eq (Norm.norm (ContinuousMultilinearMap.constOfIsEmpty 𝕜 E x)) (Norm.norm x)","decl":"@[simp]\ntheorem norm_constOfIsEmpty [IsEmpty ι] (x : G) : ‖constOfIsEmpty 𝕜 E x‖ = ‖x‖ := by\n  apply le_antisymm\n  · refine opNorm_le_bound (norm_nonneg _) fun x => ?_\n    rw [Fintype.prod_empty, mul_one, constOfIsEmpty_apply]\n  · simpa using (constOfIsEmpty 𝕜 E x).le_opNorm 0\n\n"}
{"name":"ContinuousMultilinearMap.nnnorm_constOfIsEmpty","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"𝕜 : Type u\nι : Type v\nE : ι → Type wE\nG : Type wG\ninst✝⁶ : NontriviallyNormedField 𝕜\ninst✝⁵ : (i : ι) → SeminormedAddCommGroup (E i)\ninst✝⁴ : (i : ι) → NormedSpace 𝕜 (E i)\ninst✝³ : SeminormedAddCommGroup G\ninst✝² : NormedSpace 𝕜 G\ninst✝¹ : Fintype ι\ninst✝ : IsEmpty ι\nx : G\n⊢ Eq (NNNorm.nnnorm (ContinuousMultilinearMap.constOfIsEmpty 𝕜 E x)) (NNNorm.nnnorm x)","decl":"@[simp]\ntheorem nnnorm_constOfIsEmpty [IsEmpty ι] (x : G) : ‖constOfIsEmpty 𝕜 E x‖₊ = ‖x‖₊ :=\n  NNReal.eq <| norm_constOfIsEmpty _ _ _\n\n"}
{"name":"ContinuousMultilinearMap.prodL_apply","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"𝕜 : Type u\nι : Type v\nE : ι → Type wE\nG : Type wG\nG' : Type wG'\ninst✝⁷ : NontriviallyNormedField 𝕜\ninst✝⁶ : (i : ι) → SeminormedAddCommGroup (E i)\ninst✝⁵ : (i : ι) → NormedSpace 𝕜 (E i)\ninst✝⁴ : SeminormedAddCommGroup G\ninst✝³ : NormedSpace 𝕜 G\ninst✝² : SeminormedAddCommGroup G'\ninst✝¹ : NormedSpace 𝕜 G'\ninst✝ : Fintype ι\na✝ : Prod (ContinuousMultilinearMap 𝕜 E G) (ContinuousMultilinearMap 𝕜 E G')\n⊢ Eq ((ContinuousMultilinearMap.prodL 𝕜 E G G') a✝) (ContinuousMultilinearMap.prodEquiv.toFun a✝)","decl":"/-- `ContinuousMultilinearMap.prod` as a `LinearIsometryEquiv`. -/\n@[simps]\ndef prodL :\n    ContinuousMultilinearMap 𝕜 E G × ContinuousMultilinearMap 𝕜 E G' ≃ₗᵢ[𝕜]\n      ContinuousMultilinearMap 𝕜 E (G × G') where\n  __ := prodEquiv\n  map_add' _ _ := rfl\n  map_smul' _ _ := rfl\n  norm_map' f := opNorm_prod f.1 f.2\n\n"}
{"name":"ContinuousMultilinearMap.prodL_symm_apply","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"𝕜 : Type u\nι : Type v\nE : ι → Type wE\nG : Type wG\nG' : Type wG'\ninst✝⁷ : NontriviallyNormedField 𝕜\ninst✝⁶ : (i : ι) → SeminormedAddCommGroup (E i)\ninst✝⁵ : (i : ι) → NormedSpace 𝕜 (E i)\ninst✝⁴ : SeminormedAddCommGroup G\ninst✝³ : NormedSpace 𝕜 G\ninst✝² : SeminormedAddCommGroup G'\ninst✝¹ : NormedSpace 𝕜 G'\ninst✝ : Fintype ι\na✝ : ContinuousMultilinearMap 𝕜 E (Prod G G')\n⊢ Eq ((ContinuousMultilinearMap.prodL 𝕜 E G G').symm a✝) (ContinuousMultilinearMap.prodEquiv.invFun a✝)","decl":"/-- `ContinuousMultilinearMap.prod` as a `LinearIsometryEquiv`. -/\n@[simps]\ndef prodL :\n    ContinuousMultilinearMap 𝕜 E G × ContinuousMultilinearMap 𝕜 E G' ≃ₗᵢ[𝕜]\n      ContinuousMultilinearMap 𝕜 E (G × G') where\n  __ := prodEquiv\n  map_add' _ _ := rfl\n  map_smul' _ _ := rfl\n  norm_map' f := opNorm_prod f.1 f.2\n\n"}
{"name":"ContinuousMultilinearMap.piₗᵢ_symm_apply","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"𝕜 : Type u\nι : Type v\nE : ι → Type wE\ninst✝⁶ : NontriviallyNormedField 𝕜\ninst✝⁵ : (i : ι) → SeminormedAddCommGroup (E i)\ninst✝⁴ : (i : ι) → NormedSpace 𝕜 (E i)\ninst✝³ : Fintype ι\nι' : Type v'\ninst✝² : Fintype ι'\nE' : ι' → Type wE'\ninst✝¹ : (i' : ι') → NormedAddCommGroup (E' i')\ninst✝ : (i' : ι') → NormedSpace 𝕜 (E' i')\na✝ : ContinuousMultilinearMap 𝕜 E ((i : ι') → E' i)\ni : ι'\n⊢ Eq ((ContinuousMultilinearMap.piₗᵢ 𝕜 E).symm a✝ i) ((ContinuousLinearMap.proj i).compContinuousMultilinearMap a✝)","decl":"/-- `ContinuousMultilinearMap.pi` as a `LinearIsometryEquiv`. -/\n@[simps! apply symm_apply]\ndef piₗᵢ {ι' : Type v'} [Fintype ι'] {E' : ι' → Type wE'} [∀ i', NormedAddCommGroup (E' i')]\n    [∀ i', NormedSpace 𝕜 (E' i')] :\n    (Π i', ContinuousMultilinearMap 𝕜 E (E' i'))\n      ≃ₗᵢ[𝕜] (ContinuousMultilinearMap 𝕜 E (Π i, E' i)) where\n  toLinearEquiv := piLinearEquiv\n  norm_map' := opNorm_pi\n\n"}
{"name":"ContinuousMultilinearMap.piₗᵢ_apply","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"𝕜 : Type u\nι : Type v\nE : ι → Type wE\ninst✝⁶ : NontriviallyNormedField 𝕜\ninst✝⁵ : (i : ι) → SeminormedAddCommGroup (E i)\ninst✝⁴ : (i : ι) → NormedSpace 𝕜 (E i)\ninst✝³ : Fintype ι\nι' : Type v'\ninst✝² : Fintype ι'\nE' : ι' → Type wE'\ninst✝¹ : (i' : ι') → NormedAddCommGroup (E' i')\ninst✝ : (i' : ι') → NormedSpace 𝕜 (E' i')\na✝ : (i : ι') → ContinuousMultilinearMap 𝕜 E (E' i)\n⊢ Eq ((ContinuousMultilinearMap.piₗᵢ 𝕜 E) a✝) (ContinuousMultilinearMap.pi a✝)","decl":"/-- `ContinuousMultilinearMap.pi` as a `LinearIsometryEquiv`. -/\n@[simps! apply symm_apply]\ndef piₗᵢ {ι' : Type v'} [Fintype ι'] {E' : ι' → Type wE'} [∀ i', NormedAddCommGroup (E' i')]\n    [∀ i', NormedSpace 𝕜 (E' i')] :\n    (Π i', ContinuousMultilinearMap 𝕜 E (E' i'))\n      ≃ₗᵢ[𝕜] (ContinuousMultilinearMap 𝕜 E (Π i, E' i)) where\n  toLinearEquiv := piLinearEquiv\n  norm_map' := opNorm_pi\n\n"}
{"name":"ContinuousMultilinearMap.norm_restrictScalars","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"𝕜 : Type u\nι : Type v\nE : ι → Type wE\nG : Type wG\ninst✝¹¹ : NontriviallyNormedField 𝕜\ninst✝¹⁰ : (i : ι) → SeminormedAddCommGroup (E i)\ninst✝⁹ : (i : ι) → NormedSpace 𝕜 (E i)\ninst✝⁸ : SeminormedAddCommGroup G\ninst✝⁷ : NormedSpace 𝕜 G\ninst✝⁶ : Fintype ι\n𝕜' : Type u_1\ninst✝⁵ : NontriviallyNormedField 𝕜'\ninst✝⁴ : NormedAlgebra 𝕜' 𝕜\ninst✝³ : NormedSpace 𝕜' G\ninst✝² : IsScalarTower 𝕜' 𝕜 G\ninst✝¹ : (i : ι) → NormedSpace 𝕜' (E i)\ninst✝ : ∀ (i : ι), IsScalarTower 𝕜' 𝕜 (E i)\nf : ContinuousMultilinearMap 𝕜 E G\n⊢ Eq (Norm.norm (ContinuousMultilinearMap.restrictScalars 𝕜' f)) (Norm.norm f)","decl":"@[simp]\ntheorem norm_restrictScalars (f : ContinuousMultilinearMap 𝕜 E G) :\n    ‖f.restrictScalars 𝕜'‖ = ‖f‖ :=\n  rfl\n\n"}
{"name":"ContinuousMultilinearMap.norm_image_sub_le'","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"𝕜 : Type u\nι : Type v\nE : ι → Type wE\nG : Type wG\ninst✝⁶ : NontriviallyNormedField 𝕜\ninst✝⁵ : (i : ι) → SeminormedAddCommGroup (E i)\ninst✝⁴ : (i : ι) → NormedSpace 𝕜 (E i)\ninst✝³ : SeminormedAddCommGroup G\ninst✝² : NormedSpace 𝕜 G\ninst✝¹ : Fintype ι\ninst✝ : DecidableEq ι\nf : ContinuousMultilinearMap 𝕜 E G\nm₁ m₂ : (i : ι) → E i\n⊢ LE.le (Norm.norm (HSub.hSub (f m₁) (f m₂))) (HMul.hMul (Norm.norm f) (Finset.univ.sum fun i => Finset.univ.prod fun j => ite (Eq j i) (Norm.norm (HSub.hSub (m₁ i) (m₂ i))) (Max.max (Norm.norm (m₁ j)) (Norm.norm (m₂ j)))))","decl":"/-- The difference `f m₁ - f m₂` is controlled in terms of `‖f‖` and `‖m₁ - m₂‖`, precise version.\nFor a less precise but more usable version, see `norm_image_sub_le`. The bound reads\n`‖f m - f m'‖ ≤\n  ‖f‖ * ‖m 1 - m' 1‖ * max ‖m 2‖ ‖m' 2‖ * max ‖m 3‖ ‖m' 3‖ * ... * max ‖m n‖ ‖m' n‖ + ...`,\nwhere the other terms in the sum are the same products where `1` is replaced by any `i`. -/\ntheorem norm_image_sub_le' [DecidableEq ι] (f : ContinuousMultilinearMap 𝕜 E G) (m₁ m₂ : ∀ i, E i) :\n    ‖f m₁ - f m₂‖ ≤ ‖f‖ * ∑ i, ∏ j, if j = i then ‖m₁ i - m₂ i‖ else max ‖m₁ j‖ ‖m₂ j‖ :=\n  f.toMultilinearMap.norm_image_sub_le_of_bound' (norm_nonneg _) f.le_opNorm _ _\n\n"}
{"name":"ContinuousMultilinearMap.norm_image_sub_le","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"𝕜 : Type u\nι : Type v\nE : ι → Type wE\nG : Type wG\ninst✝⁵ : NontriviallyNormedField 𝕜\ninst✝⁴ : (i : ι) → SeminormedAddCommGroup (E i)\ninst✝³ : (i : ι) → NormedSpace 𝕜 (E i)\ninst✝² : SeminormedAddCommGroup G\ninst✝¹ : NormedSpace 𝕜 G\ninst✝ : Fintype ι\nf : ContinuousMultilinearMap 𝕜 E G\nm₁ m₂ : (i : ι) → E i\n⊢ LE.le (Norm.norm (HSub.hSub (f m₁) (f m₂))) (HMul.hMul (HMul.hMul (HMul.hMul (Norm.norm f) ↑(Fintype.card ι)) (HPow.hPow (Max.max (Norm.norm m₁) (Norm.norm m₂)) (HSub.hSub (Fintype.card ι) 1))) (Norm.norm (HSub.hSub m₁ m₂)))","decl":"/-- The difference `f m₁ - f m₂` is controlled in terms of `‖f‖` and `‖m₁ - m₂‖`, less precise\nversion. For a more precise but less usable version, see `norm_image_sub_le'`.\nThe bound is `‖f m - f m'‖ ≤ ‖f‖ * card ι * ‖m - m'‖ * (max ‖m‖ ‖m'‖) ^ (card ι - 1)`. -/\ntheorem norm_image_sub_le (f : ContinuousMultilinearMap 𝕜 E G) (m₁ m₂ : ∀ i, E i) :\n    ‖f m₁ - f m₂‖ ≤ ‖f‖ * Fintype.card ι * max ‖m₁‖ ‖m₂‖ ^ (Fintype.card ι - 1) * ‖m₁ - m₂‖ :=\n  f.toMultilinearMap.norm_image_sub_le_of_bound (norm_nonneg _) f.le_opNorm _ _\n\n"}
{"name":"MultilinearMap.mkContinuous_norm_le","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"𝕜 : Type u\nι : Type v\nE : ι → Type wE\nG : Type wG\ninst✝⁵ : NontriviallyNormedField 𝕜\ninst✝⁴ : (i : ι) → SeminormedAddCommGroup (E i)\ninst✝³ : (i : ι) → NormedSpace 𝕜 (E i)\ninst✝² : SeminormedAddCommGroup G\ninst✝¹ : NormedSpace 𝕜 G\ninst✝ : Fintype ι\nf : MultilinearMap 𝕜 E G\nC : Real\nhC : LE.le 0 C\nH : ∀ (m : (i : ι) → E i), LE.le (Norm.norm (f m)) (HMul.hMul C (Finset.univ.prod fun i => Norm.norm (m i)))\n⊢ LE.le (Norm.norm (f.mkContinuous C H)) C","decl":"/-- If a continuous multilinear map is constructed from a multilinear map via the constructor\n`mkContinuous`, then its norm is bounded by the bound given to the constructor if it is\nnonnegative. -/\ntheorem MultilinearMap.mkContinuous_norm_le (f : MultilinearMap 𝕜 E G) {C : ℝ} (hC : 0 ≤ C)\n    (H : ∀ m, ‖f m‖ ≤ C * ∏ i, ‖m i‖) : ‖f.mkContinuous C H‖ ≤ C :=\n  ContinuousMultilinearMap.opNorm_le_bound hC fun m => H m\n\n"}
{"name":"MultilinearMap.mkContinuous_norm_le'","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"𝕜 : Type u\nι : Type v\nE : ι → Type wE\nG : Type wG\ninst✝⁵ : NontriviallyNormedField 𝕜\ninst✝⁴ : (i : ι) → SeminormedAddCommGroup (E i)\ninst✝³ : (i : ι) → NormedSpace 𝕜 (E i)\ninst✝² : SeminormedAddCommGroup G\ninst✝¹ : NormedSpace 𝕜 G\ninst✝ : Fintype ι\nf : MultilinearMap 𝕜 E G\nC : Real\nH : ∀ (m : (i : ι) → E i), LE.le (Norm.norm (f m)) (HMul.hMul C (Finset.univ.prod fun i => Norm.norm (m i)))\n⊢ LE.le (Norm.norm (f.mkContinuous C H)) (Max.max C 0)","decl":"/-- If a continuous multilinear map is constructed from a multilinear map via the constructor\n`mkContinuous`, then its norm is bounded by the bound given to the constructor if it is\nnonnegative. -/\ntheorem MultilinearMap.mkContinuous_norm_le' (f : MultilinearMap 𝕜 E G) {C : ℝ}\n    (H : ∀ m, ‖f m‖ ≤ C * ∏ i, ‖m i‖) : ‖f.mkContinuous C H‖ ≤ max C 0 :=\n  ContinuousMultilinearMap.opNorm_le_bound (le_max_right _ _) fun m ↦ (H m).trans <|\n    mul_le_mul_of_nonneg_right (le_max_left _ _) <| by positivity\n\n"}
{"name":"ContinuousMultilinearMap.norm_restr","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"𝕜 : Type u\nG : Type wG\nG' : Type wG'\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : SeminormedAddCommGroup G\ninst✝² : NormedSpace 𝕜 G\ninst✝¹ : SeminormedAddCommGroup G'\ninst✝ : NormedSpace 𝕜 G'\nk n : Nat\nf : ContinuousMultilinearMap 𝕜 (fun i => G) G'\ns : Finset (Fin n)\nhk : Eq s.card k\nz : G\n⊢ LE.le (Norm.norm (f.restr s hk z)) (HMul.hMul (Norm.norm f) (HPow.hPow (Norm.norm z) (HSub.hSub n k)))","decl":"theorem norm_restr {k n : ℕ} (f : G[×n]→L[𝕜] G') (s : Finset (Fin n)) (hk : #s = k) (z : G) :\n    ‖f.restr s hk z‖ ≤ ‖f‖ * ‖z‖ ^ (n - k) := by\n  apply MultilinearMap.mkContinuous_norm_le\n  exact mul_nonneg (norm_nonneg _) (pow_nonneg (norm_nonneg _) _)\n\n"}
{"name":"ContinuousMultilinearMap.norm_mkPiAlgebra_le","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"𝕜 : Type u\nι : Type v\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : Fintype ι\nA : Type u_1\ninst✝² : NormedCommRing A\ninst✝¹ : NormedAlgebra 𝕜 A\ninst✝ : Nonempty ι\n⊢ LE.le (Norm.norm (ContinuousMultilinearMap.mkPiAlgebra 𝕜 ι A)) 1","decl":"@[simp]\ntheorem norm_mkPiAlgebra_le [Nonempty ι] : ‖ContinuousMultilinearMap.mkPiAlgebra 𝕜 ι A‖ ≤ 1 := by\n  refine opNorm_le_bound zero_le_one fun m => ?_\n  simp only [ContinuousMultilinearMap.mkPiAlgebra_apply, one_mul]\n  exact norm_prod_le' _ univ_nonempty _\n\n"}
{"name":"ContinuousMultilinearMap.norm_mkPiAlgebra_of_empty","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"𝕜 : Type u\nι : Type v\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : Fintype ι\nA : Type u_1\ninst✝² : NormedCommRing A\ninst✝¹ : NormedAlgebra 𝕜 A\ninst✝ : IsEmpty ι\n⊢ Eq (Norm.norm (ContinuousMultilinearMap.mkPiAlgebra 𝕜 ι A)) (Norm.norm 1)","decl":"theorem norm_mkPiAlgebra_of_empty [IsEmpty ι] :\n    ‖ContinuousMultilinearMap.mkPiAlgebra 𝕜 ι A‖ = ‖(1 : A)‖ := by\n  apply le_antisymm\n  · apply opNorm_le_bound <;> simp\n  · -- Porting note: have to annotate types to get mvars to unify\n    convert ratio_le_opNorm (ContinuousMultilinearMap.mkPiAlgebra 𝕜 ι A) fun _ => (1 : A)\n    simp [eq_empty_of_isEmpty (univ : Finset ι)]\n\n"}
{"name":"ContinuousMultilinearMap.norm_mkPiAlgebra","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"𝕜 : Type u\nι : Type v\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : Fintype ι\nA : Type u_1\ninst✝² : NormedCommRing A\ninst✝¹ : NormedAlgebra 𝕜 A\ninst✝ : NormOneClass A\n⊢ Eq (Norm.norm (ContinuousMultilinearMap.mkPiAlgebra 𝕜 ι A)) 1","decl":"@[simp]\ntheorem norm_mkPiAlgebra [NormOneClass A] : ‖ContinuousMultilinearMap.mkPiAlgebra 𝕜 ι A‖ = 1 := by\n  cases isEmpty_or_nonempty ι\n  · simp [norm_mkPiAlgebra_of_empty]\n  · refine le_antisymm norm_mkPiAlgebra_le ?_\n    convert ratio_le_opNorm (ContinuousMultilinearMap.mkPiAlgebra 𝕜 ι A) fun _ => 1\n    simp\n\n"}
{"name":"ContinuousMultilinearMap.norm_mkPiAlgebraFin_succ_le","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"𝕜 : Type u\ninst✝² : NontriviallyNormedField 𝕜\nn : Nat\nA : Type u_1\ninst✝¹ : SeminormedRing A\ninst✝ : NormedAlgebra 𝕜 A\n⊢ LE.le (Norm.norm (ContinuousMultilinearMap.mkPiAlgebraFin 𝕜 n.succ A)) 1","decl":"theorem norm_mkPiAlgebraFin_succ_le : ‖ContinuousMultilinearMap.mkPiAlgebraFin 𝕜 n.succ A‖ ≤ 1 := by\n  refine opNorm_le_bound zero_le_one fun m => ?_\n  simp only [ContinuousMultilinearMap.mkPiAlgebraFin_apply, one_mul, List.ofFn_eq_map,\n    Fin.prod_univ_def, Multiset.map_coe, Multiset.prod_coe]\n  refine (List.norm_prod_le' ?_).trans_eq ?_\n  · rw [Ne, List.map_eq_nil_iff, List.finRange_eq_nil]\n    exact Nat.succ_ne_zero _\n  rw [List.map_map, Function.comp_def]\n\n"}
{"name":"ContinuousMultilinearMap.norm_mkPiAlgebraFin_le_of_pos","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"𝕜 : Type u\ninst✝² : NontriviallyNormedField 𝕜\nn : Nat\nA : Type u_1\ninst✝¹ : SeminormedRing A\ninst✝ : NormedAlgebra 𝕜 A\nhn : LT.lt 0 n\n⊢ LE.le (Norm.norm (ContinuousMultilinearMap.mkPiAlgebraFin 𝕜 n A)) 1","decl":"theorem norm_mkPiAlgebraFin_le_of_pos (hn : 0 < n) :\n    ‖ContinuousMultilinearMap.mkPiAlgebraFin 𝕜 n A‖ ≤ 1 := by\n  obtain ⟨n, rfl⟩ := Nat.exists_eq_succ_of_ne_zero hn.ne'\n  exact norm_mkPiAlgebraFin_succ_le\n\n"}
{"name":"ContinuousMultilinearMap.norm_mkPiAlgebraFin_zero","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"𝕜 : Type u\ninst✝² : NontriviallyNormedField 𝕜\nA : Type u_1\ninst✝¹ : SeminormedRing A\ninst✝ : NormedAlgebra 𝕜 A\n⊢ Eq (Norm.norm (ContinuousMultilinearMap.mkPiAlgebraFin 𝕜 0 A)) (Norm.norm 1)","decl":"theorem norm_mkPiAlgebraFin_zero : ‖ContinuousMultilinearMap.mkPiAlgebraFin 𝕜 0 A‖ = ‖(1 : A)‖ := by\n  refine le_antisymm ?_ ?_\n  · refine opNorm_le_bound (norm_nonneg (1 : A)) ?_\n    simp\n  · convert ratio_le_opNorm (ContinuousMultilinearMap.mkPiAlgebraFin 𝕜 0 A) fun _ => (1 : A)\n    simp\n\n"}
{"name":"ContinuousMultilinearMap.norm_mkPiAlgebraFin_le","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"𝕜 : Type u\ninst✝² : NontriviallyNormedField 𝕜\nn : Nat\nA : Type u_1\ninst✝¹ : SeminormedRing A\ninst✝ : NormedAlgebra 𝕜 A\n⊢ LE.le (Norm.norm (ContinuousMultilinearMap.mkPiAlgebraFin 𝕜 n A)) (Max.max 1 (Norm.norm 1))","decl":"theorem norm_mkPiAlgebraFin_le :\n    ‖ContinuousMultilinearMap.mkPiAlgebraFin 𝕜 n A‖ ≤ max 1 ‖(1 : A)‖ := by\n  cases n\n  · exact norm_mkPiAlgebraFin_zero.le.trans (le_max_right _ _)\n  · exact (norm_mkPiAlgebraFin_le_of_pos (Nat.zero_lt_succ _)).trans (le_max_left _ _)\n\n"}
{"name":"ContinuousMultilinearMap.norm_mkPiAlgebraFin","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"𝕜 : Type u\ninst✝³ : NontriviallyNormedField 𝕜\nn : Nat\nA : Type u_1\ninst✝² : SeminormedRing A\ninst✝¹ : NormedAlgebra 𝕜 A\ninst✝ : NormOneClass A\n⊢ Eq (Norm.norm (ContinuousMultilinearMap.mkPiAlgebraFin 𝕜 n A)) 1","decl":"@[simp]\ntheorem norm_mkPiAlgebraFin [NormOneClass A] :\n    ‖ContinuousMultilinearMap.mkPiAlgebraFin 𝕜 n A‖ = 1 := by\n  cases n\n  · rw [norm_mkPiAlgebraFin_zero]\n    simp\n  · refine le_antisymm norm_mkPiAlgebraFin_succ_le ?_\n    refine le_of_eq_of_le ?_ <|\n      ratio_le_opNorm (ContinuousMultilinearMap.mkPiAlgebraFin 𝕜 (Nat.succ _) A) fun _ => 1\n    simp\n\n"}
{"name":"ContinuousMultilinearMap.nnnorm_smulRight","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"𝕜 : Type u\nι : Type v\nE : ι → Type wE\nG : Type wG\ninst✝⁵ : NontriviallyNormedField 𝕜\ninst✝⁴ : (i : ι) → SeminormedAddCommGroup (E i)\ninst✝³ : (i : ι) → NormedSpace 𝕜 (E i)\ninst✝² : SeminormedAddCommGroup G\ninst✝¹ : NormedSpace 𝕜 G\ninst✝ : Fintype ι\nf : ContinuousMultilinearMap 𝕜 E 𝕜\nz : G\n⊢ Eq (NNNorm.nnnorm (f.smulRight z)) (HMul.hMul (NNNorm.nnnorm f) (NNNorm.nnnorm z))","decl":"@[simp]\ntheorem nnnorm_smulRight (f : ContinuousMultilinearMap 𝕜 E 𝕜) (z : G) :\n    ‖f.smulRight z‖₊ = ‖f‖₊ * ‖z‖₊ := by\n  refine le_antisymm ?_ ?_\n  · refine opNNNorm_le_iff.2 fun m => (nnnorm_smul_le _ _).trans ?_\n    rw [mul_right_comm]\n    gcongr\n    exact le_opNNNorm _ _\n  · obtain hz | hz := eq_zero_or_pos ‖z‖₊\n    · simp [hz]\n    rw [← le_div_iff₀ hz, opNNNorm_le_iff]\n    intro m\n    rw [div_mul_eq_mul_div, le_div_iff₀ hz]\n    refine le_trans ?_ ((f.smulRight z).le_opNNNorm m)\n    rw [smulRight_apply, nnnorm_smul]\n\n"}
{"name":"ContinuousMultilinearMap.norm_smulRight","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"𝕜 : Type u\nι : Type v\nE : ι → Type wE\nG : Type wG\ninst✝⁵ : NontriviallyNormedField 𝕜\ninst✝⁴ : (i : ι) → SeminormedAddCommGroup (E i)\ninst✝³ : (i : ι) → NormedSpace 𝕜 (E i)\ninst✝² : SeminormedAddCommGroup G\ninst✝¹ : NormedSpace 𝕜 G\ninst✝ : Fintype ι\nf : ContinuousMultilinearMap 𝕜 E 𝕜\nz : G\n⊢ Eq (Norm.norm (f.smulRight z)) (HMul.hMul (Norm.norm f) (Norm.norm z))","decl":"@[simp]\ntheorem norm_smulRight (f : ContinuousMultilinearMap 𝕜 E 𝕜) (z : G) :\n    ‖f.smulRight z‖ = ‖f‖ * ‖z‖ :=\n  congr_arg NNReal.toReal (nnnorm_smulRight f z)\n\n"}
{"name":"ContinuousMultilinearMap.norm_mkPiRing","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"𝕜 : Type u\nι : Type v\nG : Type wG\ninst✝³ : NontriviallyNormedField 𝕜\ninst✝² : SeminormedAddCommGroup G\ninst✝¹ : NormedSpace 𝕜 G\ninst✝ : Fintype ι\nz : G\n⊢ Eq (Norm.norm (ContinuousMultilinearMap.mkPiRing 𝕜 ι z)) (Norm.norm z)","decl":"@[simp]\ntheorem norm_mkPiRing (z : G) : ‖ContinuousMultilinearMap.mkPiRing 𝕜 ι z‖ = ‖z‖ := by\n  rw [ContinuousMultilinearMap.mkPiRing, norm_smulRight, norm_mkPiAlgebra, one_mul]\n\n"}
{"name":"ContinuousMultilinearMap.smulRightL_apply","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"𝕜 : Type u\nι : Type v\nE : ι → Type wE\nG : Type wG\ninst✝⁵ : NontriviallyNormedField 𝕜\ninst✝⁴ : (i : ι) → SeminormedAddCommGroup (E i)\ninst✝³ : (i : ι) → NormedSpace 𝕜 (E i)\ninst✝² : SeminormedAddCommGroup G\ninst✝¹ : NormedSpace 𝕜 G\ninst✝ : Fintype ι\nf : ContinuousMultilinearMap 𝕜 E 𝕜\nz : G\n⊢ Eq (((ContinuousMultilinearMap.smulRightL 𝕜 E G) f) z) (f.smulRight z)","decl":"@[simp] lemma smulRightL_apply (f : ContinuousMultilinearMap 𝕜 E 𝕜) (z : G) :\n  smulRightL 𝕜 E G f z = f.smulRight z := rfl\n\n"}
{"name":"ContinuousMultilinearMap.norm_smulRightL_le","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"𝕜 : Type u\nι : Type v\nE : ι → Type wE\nG : Type wG\ninst✝⁵ : NontriviallyNormedField 𝕜\ninst✝⁴ : (i : ι) → SeminormedAddCommGroup (E i)\ninst✝³ : (i : ι) → NormedSpace 𝕜 (E i)\ninst✝² : SeminormedAddCommGroup G\ninst✝¹ : NormedSpace 𝕜 G\ninst✝ : Fintype ι\n⊢ LE.le (Norm.norm (ContinuousMultilinearMap.smulRightL 𝕜 E G)) 1","decl":"set_option maxSynthPendingDepth 2 in\nlemma norm_smulRightL_le : ‖smulRightL 𝕜 E G‖ ≤ 1 :=\n  LinearMap.mkContinuous₂_norm_le _ zero_le_one _\n\n"}
{"name":"ContinuousLinearMap.norm_compContinuousMultilinearMap_le","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"𝕜 : Type u\nι : Type v\nE : ι → Type wE\nG : Type wG\nG' : Type wG'\ninst✝⁷ : NontriviallyNormedField 𝕜\ninst✝⁶ : (i : ι) → SeminormedAddCommGroup (E i)\ninst✝⁵ : (i : ι) → NormedSpace 𝕜 (E i)\ninst✝⁴ : SeminormedAddCommGroup G\ninst✝³ : NormedSpace 𝕜 G\ninst✝² : SeminormedAddCommGroup G'\ninst✝¹ : NormedSpace 𝕜 G'\ninst✝ : Fintype ι\ng : ContinuousLinearMap (RingHom.id 𝕜) G G'\nf : ContinuousMultilinearMap 𝕜 E G\n⊢ LE.le (Norm.norm (g.compContinuousMultilinearMap f)) (HMul.hMul (Norm.norm g) (Norm.norm f))","decl":"theorem norm_compContinuousMultilinearMap_le (g : G →L[𝕜] G') (f : ContinuousMultilinearMap 𝕜 E G) :\n    ‖g.compContinuousMultilinearMap f‖ ≤ ‖g‖ * ‖f‖ :=\n  ContinuousMultilinearMap.opNorm_le_bound (by positivity) fun m ↦\n    calc\n      ‖g (f m)‖ ≤ ‖g‖ * (‖f‖ * ∏ i, ‖m i‖) := g.le_opNorm_of_le <| f.le_opNorm _\n      _ = _ := (mul_assoc _ _ _).symm\n\n"}
{"name":"ContinuousLinearEquiv.compContinuousMultilinearMapL_symm","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"𝕜 : Type u\nι : Type v\nE : ι → Type wE\nG : Type wG\nG' : Type wG'\ninst✝⁷ : NontriviallyNormedField 𝕜\ninst✝⁶ : (i : ι) → SeminormedAddCommGroup (E i)\ninst✝⁵ : (i : ι) → NormedSpace 𝕜 (E i)\ninst✝⁴ : SeminormedAddCommGroup G\ninst✝³ : NormedSpace 𝕜 G\ninst✝² : SeminormedAddCommGroup G'\ninst✝¹ : NormedSpace 𝕜 G'\ninst✝ : Fintype ι\ng : ContinuousLinearEquiv (RingHom.id 𝕜) G G'\n⊢ Eq (ContinuousLinearEquiv.compContinuousMultilinearMapL E g).symm (ContinuousLinearEquiv.compContinuousMultilinearMapL E g.symm)","decl":"@[simp]\ntheorem _root_.ContinuousLinearEquiv.compContinuousMultilinearMapL_symm (g : G ≃L[𝕜] G') :\n    (g.compContinuousMultilinearMapL E).symm = g.symm.compContinuousMultilinearMapL E :=\n  rfl\n\n"}
{"name":"ContinuousLinearEquiv.compContinuousMultilinearMapL_apply","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"𝕜 : Type u\nι : Type v\nE : ι → Type wE\nG : Type wG\nG' : Type wG'\ninst✝⁷ : NontriviallyNormedField 𝕜\ninst✝⁶ : (i : ι) → SeminormedAddCommGroup (E i)\ninst✝⁵ : (i : ι) → NormedSpace 𝕜 (E i)\ninst✝⁴ : SeminormedAddCommGroup G\ninst✝³ : NormedSpace 𝕜 G\ninst✝² : SeminormedAddCommGroup G'\ninst✝¹ : NormedSpace 𝕜 G'\ninst✝ : Fintype ι\ng : ContinuousLinearEquiv (RingHom.id 𝕜) G G'\nf : ContinuousMultilinearMap 𝕜 E G\n⊢ Eq ((ContinuousLinearEquiv.compContinuousMultilinearMapL E g) f) ((↑g).compContinuousMultilinearMap f)","decl":"@[simp]\ntheorem _root_.ContinuousLinearEquiv.compContinuousMultilinearMapL_apply (g : G ≃L[𝕜] G')\n    (f : ContinuousMultilinearMap 𝕜 E G) :\n    g.compContinuousMultilinearMapL E f = (g : G →L[𝕜] G').compContinuousMultilinearMap f :=\n  rfl\n\n"}
{"name":"ContinuousLinearMap.flipMultilinear_apply_apply","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"𝕜 : Type u\nι : Type v\nE : ι → Type wE\nG : Type wG\nG' : Type wG'\ninst✝⁷ : NontriviallyNormedField 𝕜\ninst✝⁶ : (i : ι) → SeminormedAddCommGroup (E i)\ninst✝⁵ : (i : ι) → NormedSpace 𝕜 (E i)\ninst✝⁴ : SeminormedAddCommGroup G\ninst✝³ : NormedSpace 𝕜 G\ninst✝² : SeminormedAddCommGroup G'\ninst✝¹ : NormedSpace 𝕜 G'\ninst✝ : Fintype ι\nf : ContinuousLinearMap (RingHom.id 𝕜) G (ContinuousMultilinearMap 𝕜 E G')\nm : (i : ι) → E i\nx : G\n⊢ Eq ((f.flipMultilinear m) x) ((f x) m)","decl":"/-- Flip arguments in `f : G →L[𝕜] ContinuousMultilinearMap 𝕜 E G'` to get\n`ContinuousMultilinearMap 𝕜 E (G →L[𝕜] G')` -/\n@[simps! apply_apply]\ndef flipMultilinear (f : G →L[𝕜] ContinuousMultilinearMap 𝕜 E G') :\n    ContinuousMultilinearMap 𝕜 E (G →L[𝕜] G') :=\n  MultilinearMap.mkContinuous\n    { toFun := fun m =>\n        LinearMap.mkContinuous\n          { toFun := fun x => f x m\n            map_add' := fun x y => by simp only [map_add, ContinuousMultilinearMap.add_apply]\n            map_smul' := fun c x => by\n              simp only [ContinuousMultilinearMap.smul_apply, map_smul, RingHom.id_apply] }\n          (‖f‖ * ∏ i, ‖m i‖) fun x => by\n          rw [mul_right_comm]\n          exact (f x).le_of_opNorm_le (f.le_opNorm x) _\n      map_update_add' := fun m i x y => by\n        ext1\n        simp only [add_apply, ContinuousMultilinearMap.map_update_add, LinearMap.coe_mk,\n          LinearMap.mkContinuous_apply, AddHom.coe_mk]\n      map_update_smul' := fun m i c x => by\n        ext1\n        simp only [coe_smul', ContinuousMultilinearMap.map_update_smul, LinearMap.coe_mk,\n          LinearMap.mkContinuous_apply, Pi.smul_apply, AddHom.coe_mk] }\n    ‖f‖ fun m => by\n      dsimp only [MultilinearMap.coe_mk]\n      exact LinearMap.mkContinuous_norm_le _ (by positivity) _\n\n"}
{"name":"LinearIsometry.norm_compContinuousMultilinearMap","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"𝕜 : Type u\nι : Type v\nE : ι → Type wE\nG : Type wG\nG' : Type wG'\ninst✝⁷ : NontriviallyNormedField 𝕜\ninst✝⁶ : (i : ι) → SeminormedAddCommGroup (E i)\ninst✝⁵ : (i : ι) → NormedSpace 𝕜 (E i)\ninst✝⁴ : SeminormedAddCommGroup G\ninst✝³ : NormedSpace 𝕜 G\ninst✝² : SeminormedAddCommGroup G'\ninst✝¹ : NormedSpace 𝕜 G'\ninst✝ : Fintype ι\ng : LinearIsometry (RingHom.id 𝕜) G G'\nf : ContinuousMultilinearMap 𝕜 E G\n⊢ Eq (Norm.norm (g.toContinuousLinearMap.compContinuousMultilinearMap f)) (Norm.norm f)","decl":"theorem LinearIsometry.norm_compContinuousMultilinearMap (g : G →ₗᵢ[𝕜] G')\n    (f : ContinuousMultilinearMap 𝕜 E G) :\n    ‖g.toContinuousLinearMap.compContinuousMultilinearMap f‖ = ‖f‖ := by\n  simp only [ContinuousLinearMap.compContinuousMultilinearMap_coe,\n    LinearIsometry.coe_toContinuousLinearMap, LinearIsometry.norm_map,\n    ContinuousMultilinearMap.norm_def, Function.comp_apply]\n\n"}
{"name":"MultilinearMap.mkContinuousLinear_norm_le'","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"𝕜 : Type u\nι : Type v\nE : ι → Type wE\nG : Type wG\nG' : Type wG'\ninst✝⁷ : NontriviallyNormedField 𝕜\ninst✝⁶ : (i : ι) → SeminormedAddCommGroup (E i)\ninst✝⁵ : (i : ι) → NormedSpace 𝕜 (E i)\ninst✝⁴ : SeminormedAddCommGroup G\ninst✝³ : NormedSpace 𝕜 G\ninst✝² : SeminormedAddCommGroup G'\ninst✝¹ : NormedSpace 𝕜 G'\ninst✝ : Fintype ι\nf : LinearMap (RingHom.id 𝕜) G (MultilinearMap 𝕜 E G')\nC : Real\nH : ∀ (x : G) (m : (i : ι) → E i), LE.le (Norm.norm ((f x) m)) (HMul.hMul (HMul.hMul C (Norm.norm x)) (Finset.univ.prod fun i => Norm.norm (m i)))\n⊢ LE.le (Norm.norm (MultilinearMap.mkContinuousLinear f C H)) (Max.max C 0)","decl":"theorem mkContinuousLinear_norm_le' (f : G →ₗ[𝕜] MultilinearMap 𝕜 E G') (C : ℝ)\n    (H : ∀ x m, ‖f x m‖ ≤ C * ‖x‖ * ∏ i, ‖m i‖) : ‖mkContinuousLinear f C H‖ ≤ max C 0 := by\n  dsimp only [mkContinuousLinear]\n  exact LinearMap.mkContinuous_norm_le _ (le_max_right _ _) _\n\n"}
{"name":"MultilinearMap.mkContinuousLinear_norm_le","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"𝕜 : Type u\nι : Type v\nE : ι → Type wE\nG : Type wG\nG' : Type wG'\ninst✝⁷ : NontriviallyNormedField 𝕜\ninst✝⁶ : (i : ι) → SeminormedAddCommGroup (E i)\ninst✝⁵ : (i : ι) → NormedSpace 𝕜 (E i)\ninst✝⁴ : SeminormedAddCommGroup G\ninst✝³ : NormedSpace 𝕜 G\ninst✝² : SeminormedAddCommGroup G'\ninst✝¹ : NormedSpace 𝕜 G'\ninst✝ : Fintype ι\nf : LinearMap (RingHom.id 𝕜) G (MultilinearMap 𝕜 E G')\nC : Real\nhC : LE.le 0 C\nH : ∀ (x : G) (m : (i : ι) → E i), LE.le (Norm.norm ((f x) m)) (HMul.hMul (HMul.hMul C (Norm.norm x)) (Finset.univ.prod fun i => Norm.norm (m i)))\n⊢ LE.le (Norm.norm (MultilinearMap.mkContinuousLinear f C H)) C","decl":"theorem mkContinuousLinear_norm_le (f : G →ₗ[𝕜] MultilinearMap 𝕜 E G') {C : ℝ} (hC : 0 ≤ C)\n    (H : ∀ x m, ‖f x m‖ ≤ C * ‖x‖ * ∏ i, ‖m i‖) : ‖mkContinuousLinear f C H‖ ≤ C :=\n  (mkContinuousLinear_norm_le' f C H).trans_eq (max_eq_left hC)\n\n"}
{"name":"MultilinearMap.mkContinuousMultilinear_apply","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"𝕜 : Type u\nι : Type v\nι' : Type v'\nE : ι → Type wE\nE' : ι' → Type wE'\nG : Type wG\ninst✝⁸ : Fintype ι'\ninst✝⁷ : NontriviallyNormedField 𝕜\ninst✝⁶ : (i : ι) → SeminormedAddCommGroup (E i)\ninst✝⁵ : (i : ι) → NormedSpace 𝕜 (E i)\ninst✝⁴ : SeminormedAddCommGroup G\ninst✝³ : NormedSpace 𝕜 G\ninst✝² : Fintype ι\ninst✝¹ : (i : ι') → SeminormedAddCommGroup (E' i)\ninst✝ : (i : ι') → NormedSpace 𝕜 (E' i)\nf : MultilinearMap 𝕜 E (MultilinearMap 𝕜 E' G)\nC : Real\nH : ∀ (m₁ : (i : ι) → E i) (m₂ : (i : ι') → E' i), LE.le (Norm.norm ((f m₁) m₂)) (HMul.hMul (HMul.hMul C (Finset.univ.prod fun i => Norm.norm (m₁ i))) (Finset.univ.prod fun i => Norm.norm (m₂ i)))\nm : (i : ι) → E i\n⊢ Eq ⇑((f.mkContinuousMultilinear C H) m) ⇑(f m)","decl":"@[simp]\ntheorem mkContinuousMultilinear_apply (f : MultilinearMap 𝕜 E (MultilinearMap 𝕜 E' G)) {C : ℝ}\n    (H : ∀ m₁ m₂, ‖f m₁ m₂‖ ≤ (C * ∏ i, ‖m₁ i‖) * ∏ i, ‖m₂ i‖) (m : ∀ i, E i) :\n    ⇑(mkContinuousMultilinear f C H m) = f m :=\n  rfl\n\n"}
{"name":"MultilinearMap.mkContinuousMultilinear_norm_le'","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"𝕜 : Type u\nι : Type v\nι' : Type v'\nE : ι → Type wE\nE' : ι' → Type wE'\nG : Type wG\ninst✝⁸ : Fintype ι'\ninst✝⁷ : NontriviallyNormedField 𝕜\ninst✝⁶ : (i : ι) → SeminormedAddCommGroup (E i)\ninst✝⁵ : (i : ι) → NormedSpace 𝕜 (E i)\ninst✝⁴ : SeminormedAddCommGroup G\ninst✝³ : NormedSpace 𝕜 G\ninst✝² : Fintype ι\ninst✝¹ : (i : ι') → SeminormedAddCommGroup (E' i)\ninst✝ : (i : ι') → NormedSpace 𝕜 (E' i)\nf : MultilinearMap 𝕜 E (MultilinearMap 𝕜 E' G)\nC : Real\nH : ∀ (m₁ : (i : ι) → E i) (m₂ : (i : ι') → E' i), LE.le (Norm.norm ((f m₁) m₂)) (HMul.hMul (HMul.hMul C (Finset.univ.prod fun i => Norm.norm (m₁ i))) (Finset.univ.prod fun i => Norm.norm (m₂ i)))\n⊢ LE.le (Norm.norm (f.mkContinuousMultilinear C H)) (Max.max C 0)","decl":"theorem mkContinuousMultilinear_norm_le' (f : MultilinearMap 𝕜 E (MultilinearMap 𝕜 E' G)) (C : ℝ)\n    (H : ∀ m₁ m₂, ‖f m₁ m₂‖ ≤ (C * ∏ i, ‖m₁ i‖) * ∏ i, ‖m₂ i‖) :\n    ‖mkContinuousMultilinear f C H‖ ≤ max C 0 := by\n  dsimp only [mkContinuousMultilinear]\n  exact mkContinuous_norm_le _ (le_max_right _ _) _\n\n"}
{"name":"MultilinearMap.mkContinuousMultilinear_norm_le","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"𝕜 : Type u\nι : Type v\nι' : Type v'\nE : ι → Type wE\nE' : ι' → Type wE'\nG : Type wG\ninst✝⁸ : Fintype ι'\ninst✝⁷ : NontriviallyNormedField 𝕜\ninst✝⁶ : (i : ι) → SeminormedAddCommGroup (E i)\ninst✝⁵ : (i : ι) → NormedSpace 𝕜 (E i)\ninst✝⁴ : SeminormedAddCommGroup G\ninst✝³ : NormedSpace 𝕜 G\ninst✝² : Fintype ι\ninst✝¹ : (i : ι') → SeminormedAddCommGroup (E' i)\ninst✝ : (i : ι') → NormedSpace 𝕜 (E' i)\nf : MultilinearMap 𝕜 E (MultilinearMap 𝕜 E' G)\nC : Real\nhC : LE.le 0 C\nH : ∀ (m₁ : (i : ι) → E i) (m₂ : (i : ι') → E' i), LE.le (Norm.norm ((f m₁) m₂)) (HMul.hMul (HMul.hMul C (Finset.univ.prod fun i => Norm.norm (m₁ i))) (Finset.univ.prod fun i => Norm.norm (m₂ i)))\n⊢ LE.le (Norm.norm (f.mkContinuousMultilinear C H)) C","decl":"theorem mkContinuousMultilinear_norm_le (f : MultilinearMap 𝕜 E (MultilinearMap 𝕜 E' G)) {C : ℝ}\n    (hC : 0 ≤ C) (H : ∀ m₁ m₂, ‖f m₁ m₂‖ ≤ (C * ∏ i, ‖m₁ i‖) * ∏ i, ‖m₂ i‖) :\n    ‖mkContinuousMultilinear f C H‖ ≤ C :=\n  (mkContinuousMultilinear_norm_le' f C H).trans_eq (max_eq_left hC)\n\n"}
{"name":"ContinuousMultilinearMap.norm_compContinuousLinearMap_le","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"𝕜 : Type u\nι : Type v\nE : ι → Type wE\nE₁ : ι → Type wE₁\nG : Type wG\ninst✝⁷ : NontriviallyNormedField 𝕜\ninst✝⁶ : (i : ι) → SeminormedAddCommGroup (E i)\ninst✝⁵ : (i : ι) → NormedSpace 𝕜 (E i)\ninst✝⁴ : (i : ι) → SeminormedAddCommGroup (E₁ i)\ninst✝³ : (i : ι) → NormedSpace 𝕜 (E₁ i)\ninst✝² : SeminormedAddCommGroup G\ninst✝¹ : NormedSpace 𝕜 G\ninst✝ : Fintype ι\ng : ContinuousMultilinearMap 𝕜 E₁ G\nf : (i : ι) → ContinuousLinearMap (RingHom.id 𝕜) (E i) (E₁ i)\n⊢ LE.le (Norm.norm (g.compContinuousLinearMap f)) (HMul.hMul (Norm.norm g) (Finset.univ.prod fun i => Norm.norm (f i)))","decl":"theorem norm_compContinuousLinearMap_le (g : ContinuousMultilinearMap 𝕜 E₁ G)\n    (f : ∀ i, E i →L[𝕜] E₁ i) : ‖g.compContinuousLinearMap f‖ ≤ ‖g‖ * ∏ i, ‖f i‖ :=\n  opNorm_le_bound (by positivity) fun m =>\n    calc\n      ‖g fun i => f i (m i)‖ ≤ ‖g‖ * ∏ i, ‖f i (m i)‖ := g.le_opNorm _\n      _ ≤ ‖g‖ * ∏ i, ‖f i‖ * ‖m i‖ :=\n        (mul_le_mul_of_nonneg_left\n          (prod_le_prod (fun _ _ => norm_nonneg _) fun i _ => (f i).le_opNorm (m i))\n          (norm_nonneg g))\n      _ = (‖g‖ * ∏ i, ‖f i‖) * ∏ i, ‖m i‖ := by rw [prod_mul_distrib, mul_assoc]\n\n"}
{"name":"ContinuousMultilinearMap.norm_compContinuous_linearIsometry_le","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"𝕜 : Type u\nι : Type v\nE : ι → Type wE\nE₁ : ι → Type wE₁\nG : Type wG\ninst✝⁷ : NontriviallyNormedField 𝕜\ninst✝⁶ : (i : ι) → SeminormedAddCommGroup (E i)\ninst✝⁵ : (i : ι) → NormedSpace 𝕜 (E i)\ninst✝⁴ : (i : ι) → SeminormedAddCommGroup (E₁ i)\ninst✝³ : (i : ι) → NormedSpace 𝕜 (E₁ i)\ninst✝² : SeminormedAddCommGroup G\ninst✝¹ : NormedSpace 𝕜 G\ninst✝ : Fintype ι\ng : ContinuousMultilinearMap 𝕜 E₁ G\nf : (i : ι) → LinearIsometry (RingHom.id 𝕜) (E i) (E₁ i)\n⊢ LE.le (Norm.norm (g.compContinuousLinearMap fun i => (f i).toContinuousLinearMap)) (Norm.norm g)","decl":"theorem norm_compContinuous_linearIsometry_le (g : ContinuousMultilinearMap 𝕜 E₁ G)\n    (f : ∀ i, E i →ₗᵢ[𝕜] E₁ i) :\n    ‖g.compContinuousLinearMap fun i => (f i).toContinuousLinearMap‖ ≤ ‖g‖ := by\n  refine opNorm_le_bound (norm_nonneg _) fun m => ?_\n  apply (g.le_opNorm _).trans _\n  simp only [ContinuousLinearMap.coe_coe, LinearIsometry.coe_toContinuousLinearMap,\n    LinearIsometry.norm_map, le_rfl]\n\n"}
{"name":"ContinuousMultilinearMap.norm_compContinuous_linearIsometryEquiv","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"𝕜 : Type u\nι : Type v\nE : ι → Type wE\nE₁ : ι → Type wE₁\nG : Type wG\ninst✝⁷ : NontriviallyNormedField 𝕜\ninst✝⁶ : (i : ι) → SeminormedAddCommGroup (E i)\ninst✝⁵ : (i : ι) → NormedSpace 𝕜 (E i)\ninst✝⁴ : (i : ι) → SeminormedAddCommGroup (E₁ i)\ninst✝³ : (i : ι) → NormedSpace 𝕜 (E₁ i)\ninst✝² : SeminormedAddCommGroup G\ninst✝¹ : NormedSpace 𝕜 G\ninst✝ : Fintype ι\ng : ContinuousMultilinearMap 𝕜 E₁ G\nf : (i : ι) → LinearIsometryEquiv (RingHom.id 𝕜) (E i) (E₁ i)\n⊢ Eq (Norm.norm (g.compContinuousLinearMap fun i => ↑{ toLinearEquiv := (f i).toLinearEquiv, continuous_toFun := ⋯, continuous_invFun := ⋯ })) (Norm.norm g)","decl":"theorem norm_compContinuous_linearIsometryEquiv (g : ContinuousMultilinearMap 𝕜 E₁ G)\n    (f : ∀ i, E i ≃ₗᵢ[𝕜] E₁ i) :\n    ‖g.compContinuousLinearMap fun i => (f i : E i →L[𝕜] E₁ i)‖ = ‖g‖ := by\n  apply le_antisymm (g.norm_compContinuous_linearIsometry_le fun i => (f i).toLinearIsometry)\n  have : g = (g.compContinuousLinearMap fun i => (f i : E i →L[𝕜] E₁ i)).compContinuousLinearMap\n      fun i => ((f i).symm : E₁ i →L[𝕜] E i) := by\n    ext1 m\n    simp only [compContinuousLinearMap_apply, LinearIsometryEquiv.coe_coe'',\n      LinearIsometryEquiv.apply_symm_apply]\n  conv_lhs => rw [this]\n  apply (g.compContinuousLinearMap fun i =>\n    (f i : E i →L[𝕜] E₁ i)).norm_compContinuous_linearIsometry_le\n      fun i => (f i).symm.toLinearIsometry\n\n"}
{"name":"ContinuousMultilinearMap.compContinuousLinearMapL_apply","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"𝕜 : Type u\nι : Type v\nE : ι → Type wE\nE₁ : ι → Type wE₁\nG : Type wG\ninst✝⁷ : NontriviallyNormedField 𝕜\ninst✝⁶ : (i : ι) → SeminormedAddCommGroup (E i)\ninst✝⁵ : (i : ι) → NormedSpace 𝕜 (E i)\ninst✝⁴ : (i : ι) → SeminormedAddCommGroup (E₁ i)\ninst✝³ : (i : ι) → NormedSpace 𝕜 (E₁ i)\ninst✝² : SeminormedAddCommGroup G\ninst✝¹ : NormedSpace 𝕜 G\ninst✝ : Fintype ι\ng : ContinuousMultilinearMap 𝕜 E₁ G\nf : (i : ι) → ContinuousLinearMap (RingHom.id 𝕜) (E i) (E₁ i)\n⊢ Eq ((ContinuousMultilinearMap.compContinuousLinearMapL f) g) (g.compContinuousLinearMap f)","decl":"@[simp]\ntheorem compContinuousLinearMapL_apply (g : ContinuousMultilinearMap 𝕜 E₁ G)\n    (f : ∀ i, E i →L[𝕜] E₁ i) : compContinuousLinearMapL f g = g.compContinuousLinearMap f :=\n  rfl\n\n"}
{"name":"ContinuousMultilinearMap.norm_compContinuousLinearMapL_le","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"𝕜 : Type u\nι : Type v\nE : ι → Type wE\nE₁ : ι → Type wE₁\nG : Type wG\ninst✝⁷ : NontriviallyNormedField 𝕜\ninst✝⁶ : (i : ι) → SeminormedAddCommGroup (E i)\ninst✝⁵ : (i : ι) → NormedSpace 𝕜 (E i)\ninst✝⁴ : (i : ι) → SeminormedAddCommGroup (E₁ i)\ninst✝³ : (i : ι) → NormedSpace 𝕜 (E₁ i)\ninst✝² : SeminormedAddCommGroup G\ninst✝¹ : NormedSpace 𝕜 G\ninst✝ : Fintype ι\nf : (i : ι) → ContinuousLinearMap (RingHom.id 𝕜) (E i) (E₁ i)\n⊢ LE.le (Norm.norm (ContinuousMultilinearMap.compContinuousLinearMapL f)) (Finset.univ.prod fun i => Norm.norm (f i))","decl":"variable (G) in\ntheorem norm_compContinuousLinearMapL_le (f : ∀ i, E i →L[𝕜] E₁ i) :\n    ‖compContinuousLinearMapL (G := G) f‖ ≤ ∏ i, ‖f i‖ :=\n  LinearMap.mkContinuous_norm_le _ (by positivity) _\n\n"}
{"name":"ContinuousMultilinearMap.compContinuousLinearMapLRight_apply","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"𝕜 : Type u\nι : Type v\nE : ι → Type wE\nE₁ : ι → Type wE₁\nG : Type wG\ninst✝⁷ : NontriviallyNormedField 𝕜\ninst✝⁶ : (i : ι) → SeminormedAddCommGroup (E i)\ninst✝⁵ : (i : ι) → NormedSpace 𝕜 (E i)\ninst✝⁴ : (i : ι) → SeminormedAddCommGroup (E₁ i)\ninst✝³ : (i : ι) → NormedSpace 𝕜 (E₁ i)\ninst✝² : SeminormedAddCommGroup G\ninst✝¹ : NormedSpace 𝕜 G\ninst✝ : Fintype ι\ng : ContinuousMultilinearMap 𝕜 E₁ G\nf : (i : ι) → ContinuousLinearMap (RingHom.id 𝕜) (E i) (E₁ i)\n⊢ Eq (g.compContinuousLinearMapLRight f) (g.compContinuousLinearMap f)","decl":"@[simp]\ntheorem compContinuousLinearMapLRight_apply (g : ContinuousMultilinearMap 𝕜 E₁ G)\n    (f : ∀ i, E i →L[𝕜] E₁ i) : compContinuousLinearMapLRight g f = g.compContinuousLinearMap f :=\n  rfl\n\n"}
{"name":"ContinuousMultilinearMap.norm_compContinuousLinearMapLRight_le","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"𝕜 : Type u\nι : Type v\nE : ι → Type wE\nE₁ : ι → Type wE₁\nG : Type wG\ninst✝⁷ : NontriviallyNormedField 𝕜\ninst✝⁶ : (i : ι) → SeminormedAddCommGroup (E i)\ninst✝⁵ : (i : ι) → NormedSpace 𝕜 (E i)\ninst✝⁴ : (i : ι) → SeminormedAddCommGroup (E₁ i)\ninst✝³ : (i : ι) → NormedSpace 𝕜 (E₁ i)\ninst✝² : SeminormedAddCommGroup G\ninst✝¹ : NormedSpace 𝕜 G\ninst✝ : Fintype ι\ng : ContinuousMultilinearMap 𝕜 E₁ G\n⊢ LE.le (Norm.norm g.compContinuousLinearMapLRight) (Norm.norm g)","decl":"variable (E) in\ntheorem norm_compContinuousLinearMapLRight_le (g : ContinuousMultilinearMap 𝕜 E₁ G) :\n    ‖compContinuousLinearMapLRight (E := E) g‖ ≤ ‖g‖ :=\n  MultilinearMap.mkContinuous_norm_le _ (norm_nonneg _) _\n\n"}
{"name":"ContinuousMultilinearMap.compContinuousLinearMapEquivL_symm","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"𝕜 : Type u\nι : Type v\nE : ι → Type wE\nE₁ : ι → Type wE₁\nG : Type wG\ninst✝⁷ : NontriviallyNormedField 𝕜\ninst✝⁶ : (i : ι) → SeminormedAddCommGroup (E i)\ninst✝⁵ : (i : ι) → NormedSpace 𝕜 (E i)\ninst✝⁴ : (i : ι) → SeminormedAddCommGroup (E₁ i)\ninst✝³ : (i : ι) → NormedSpace 𝕜 (E₁ i)\ninst✝² : SeminormedAddCommGroup G\ninst✝¹ : NormedSpace 𝕜 G\ninst✝ : Fintype ι\nf : (i : ι) → ContinuousLinearEquiv (RingHom.id 𝕜) (E i) (E₁ i)\n⊢ Eq (ContinuousMultilinearMap.compContinuousLinearMapEquivL G f).symm (ContinuousMultilinearMap.compContinuousLinearMapEquivL G fun i => (f i).symm)","decl":"@[simp]\ntheorem compContinuousLinearMapEquivL_symm (f : ∀ i, E i ≃L[𝕜] E₁ i) :\n    (compContinuousLinearMapEquivL G f).symm =\n      compContinuousLinearMapEquivL G fun i : ι => (f i).symm :=\n  rfl\n\n"}
{"name":"ContinuousMultilinearMap.compContinuousLinearMapEquivL_apply","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"𝕜 : Type u\nι : Type v\nE : ι → Type wE\nE₁ : ι → Type wE₁\nG : Type wG\ninst✝⁷ : NontriviallyNormedField 𝕜\ninst✝⁶ : (i : ι) → SeminormedAddCommGroup (E i)\ninst✝⁵ : (i : ι) → NormedSpace 𝕜 (E i)\ninst✝⁴ : (i : ι) → SeminormedAddCommGroup (E₁ i)\ninst✝³ : (i : ι) → NormedSpace 𝕜 (E₁ i)\ninst✝² : SeminormedAddCommGroup G\ninst✝¹ : NormedSpace 𝕜 G\ninst✝ : Fintype ι\ng : ContinuousMultilinearMap 𝕜 E₁ G\nf : (i : ι) → ContinuousLinearEquiv (RingHom.id 𝕜) (E i) (E₁ i)\n⊢ Eq ((ContinuousMultilinearMap.compContinuousLinearMapEquivL G f) g) (g.compContinuousLinearMap fun i => ↑(f i))","decl":"@[simp]\ntheorem compContinuousLinearMapEquivL_apply (g : ContinuousMultilinearMap 𝕜 E₁ G)\n    (f : ∀ i, E i ≃L[𝕜] E₁ i) :\n    compContinuousLinearMapEquivL G f g =\n      g.compContinuousLinearMap fun i => (f i : E i →L[𝕜] E₁ i) :=\n  rfl\n\n"}
{"name":"ContinuousMultilinearMap.iteratedFDerivComponent_apply","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"𝕜 : Type u\nι : Type v\nE₁ : ι → Type wE₁\nG : Type wG\ninst✝⁷ : NontriviallyNormedField 𝕜\ninst✝⁶ : (i : ι) → SeminormedAddCommGroup (E₁ i)\ninst✝⁵ : (i : ι) → NormedSpace 𝕜 (E₁ i)\ninst✝⁴ : SeminormedAddCommGroup G\ninst✝³ : NormedSpace 𝕜 G\ninst✝² : Fintype ι\nα : Type u_1\ninst✝¹ : Fintype α\nf : ContinuousMultilinearMap 𝕜 E₁ G\ns : Set ι\ne : Equiv α ↑s\ninst✝ : DecidablePred fun x => Membership.mem s x\nv : (i : Subtype fun a => Not (Membership.mem s a)) → E₁ ↑i\nw : α → (i : ι) → E₁ i\n⊢ Eq (((f.iteratedFDerivComponent e) v) w) (f fun j => dite (Membership.mem s j) (fun h => w (e.symm ⟨j, h⟩) j) fun h => v ⟨j, h⟩)","decl":"@[simp] lemma iteratedFDerivComponent_apply {α : Type*} [Fintype α]\n    (f : ContinuousMultilinearMap 𝕜 E₁ G) {s : Set ι} (e : α ≃ s) [DecidablePred (· ∈ s)]\n    (v : ∀ i : {a : ι // a ∉ s}, E₁ i) (w : α → (∀ i, E₁ i)) :\n    f.iteratedFDerivComponent e v w =\n      f (fun j ↦ if h : j ∈ s then w (e.symm ⟨j, h⟩) j else v ⟨j, h⟩) := by\n  simp [iteratedFDerivComponent, MultilinearMap.iteratedFDerivComponent,\n    MultilinearMap.domDomRestrictₗ]\n\n"}
{"name":"ContinuousMultilinearMap.norm_iteratedFDerivComponent_le","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"𝕜 : Type u\nι : Type v\nE₁ : ι → Type wE₁\nG : Type wG\ninst✝⁷ : NontriviallyNormedField 𝕜\ninst✝⁶ : (i : ι) → SeminormedAddCommGroup (E₁ i)\ninst✝⁵ : (i : ι) → NormedSpace 𝕜 (E₁ i)\ninst✝⁴ : SeminormedAddCommGroup G\ninst✝³ : NormedSpace 𝕜 G\ninst✝² : Fintype ι\nα : Type u_1\ninst✝¹ : Fintype α\nf : ContinuousMultilinearMap 𝕜 E₁ G\ns : Set ι\ne : Equiv α ↑s\ninst✝ : DecidablePred fun x => Membership.mem s x\nx : (i : ι) → E₁ i\n⊢ LE.le (Norm.norm ((f.iteratedFDerivComponent e) fun x_1 => x ↑x_1)) (HMul.hMul (Norm.norm f) (HPow.hPow (Norm.norm x) (HSub.hSub (Fintype.card ι) (Fintype.card α))))","decl":"lemma norm_iteratedFDerivComponent_le {α : Type*} [Fintype α]\n    (f : ContinuousMultilinearMap 𝕜 E₁ G) {s : Set ι} (e : α ≃ s) [DecidablePred (· ∈ s)]\n    (x : (i : ι) → E₁ i) :\n    ‖f.iteratedFDerivComponent e (x ·)‖ ≤ ‖f‖ * ‖x‖ ^ (Fintype.card ι - Fintype.card α) := calc\n  ‖f.iteratedFDerivComponent e (fun i ↦ x i)‖\n    ≤ ‖f.iteratedFDerivComponent e‖ * ∏ i : {a : ι // a ∉ s}, ‖x i‖ :=\n      ContinuousMultilinearMap.le_opNorm _ _\n  _ ≤ ‖f‖ * ∏ _i : {a : ι // a ∉ s}, ‖x‖ := by\n      gcongr\n      · exact MultilinearMap.mkContinuousMultilinear_norm_le _ (norm_nonneg _) _\n      · exact norm_le_pi_norm _ _\n  _ = ‖f‖ * ‖x‖ ^ (Fintype.card {a : ι // a ∉ s}) := by rw [prod_const, card_univ]\n  _ = ‖f‖ * ‖x‖ ^ (Fintype.card ι - Fintype.card α) := by simp [Fintype.card_congr e]\n\n"}
{"name":"ContinuousMultilinearMap.norm_iteratedFDeriv_le'","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"𝕜 : Type u\nι : Type v\nE₁ : ι → Type wE₁\nG : Type wG\ninst✝⁵ : NontriviallyNormedField 𝕜\ninst✝⁴ : (i : ι) → SeminormedAddCommGroup (E₁ i)\ninst✝³ : (i : ι) → NormedSpace 𝕜 (E₁ i)\ninst✝² : SeminormedAddCommGroup G\ninst✝¹ : NormedSpace 𝕜 G\ninst✝ : Fintype ι\nf : ContinuousMultilinearMap 𝕜 E₁ G\nk : Nat\nx : (i : ι) → E₁ i\n⊢ LE.le (Norm.norm (f.iteratedFDeriv k x)) (HMul.hMul (HMul.hMul (↑((Fintype.card ι).descFactorial k)) (Norm.norm f)) (HPow.hPow (Norm.norm x) (HSub.hSub (Fintype.card ι) k)))","decl":"/-- Controlling the norm of `f.iteratedFDeriv` when `f` is continuous multilinear. For the same\nbound on the iterated derivative of `f` in the calculus sense,\nsee `ContinuousMultilinearMap.norm_iteratedFDeriv_le`. -/\nlemma norm_iteratedFDeriv_le' (f : ContinuousMultilinearMap 𝕜 E₁ G) (k : ℕ) (x : (i : ι) → E₁ i) :\n    ‖f.iteratedFDeriv k x‖\n      ≤ Nat.descFactorial (Fintype.card ι) k * ‖f‖ * ‖x‖ ^ (Fintype.card ι - k) := by\n  classical\n  calc ‖f.iteratedFDeriv k x‖\n  _ ≤ ∑ e : Fin k ↪ ι, ‖iteratedFDerivComponent f e.toEquivRange (fun i ↦ x i)‖ := norm_sum_le _ _\n  _ ≤ ∑ _ : Fin k ↪ ι, ‖f‖ * ‖x‖ ^ (Fintype.card ι - k) := by\n    gcongr with e _\n    simpa using norm_iteratedFDerivComponent_le f e.toEquivRange x\n  _ = Nat.descFactorial (Fintype.card ι) k * ‖f‖ * ‖x‖ ^ (Fintype.card ι - k) := by\n    simp [card_univ, mul_assoc]\n\n"}
{"name":"ContinuousMultilinearMap.opNorm_zero_iff","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"𝕜 : Type u\nι : Type v\nE : ι → Type wE\nG : Type wG\ninst✝⁵ : Fintype ι\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : (i : ι) → SeminormedAddCommGroup (E i)\ninst✝² : (i : ι) → NormedSpace 𝕜 (E i)\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nf : ContinuousMultilinearMap 𝕜 E G\n⊢ Iff (Eq (Norm.norm f) 0) (Eq f 0)","decl":"/-- A continuous linear map is zero iff its norm vanishes. -/\ntheorem opNorm_zero_iff {f : ContinuousMultilinearMap 𝕜 E G} : ‖f‖ = 0 ↔ f = 0 := by\n  simp [← (opNorm_nonneg f).le_iff_eq, opNorm_le_iff le_rfl, ContinuousMultilinearMap.ext_iff]\n\n"}
{"name":"ContinuousMultilinearMap.norm_ofSubsingleton_id","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"𝕜 : Type u\nι : Type v\nG : Type wG\ninst✝⁵ : Fintype ι\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup G\ninst✝² : NormedSpace 𝕜 G\ninst✝¹ : Subsingleton ι\ninst✝ : Nontrivial G\ni : ι\n⊢ Eq (Norm.norm ((ContinuousMultilinearMap.ofSubsingleton 𝕜 G G i) (ContinuousLinearMap.id 𝕜 G))) 1","decl":"theorem norm_ofSubsingleton_id [Subsingleton ι] [Nontrivial G] (i : ι) :\n    ‖ofSubsingleton 𝕜 G G i (.id _ _)‖ = 1 := by\n  simp\n\n"}
{"name":"ContinuousMultilinearMap.nnnorm_ofSubsingleton_id","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"𝕜 : Type u\nι : Type v\nG : Type wG\ninst✝⁵ : Fintype ι\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup G\ninst✝² : NormedSpace 𝕜 G\ninst✝¹ : Subsingleton ι\ninst✝ : Nontrivial G\ni : ι\n⊢ Eq (NNNorm.nnnorm ((ContinuousMultilinearMap.ofSubsingleton 𝕜 G G i) (ContinuousLinearMap.id 𝕜 G))) 1","decl":"theorem nnnorm_ofSubsingleton_id [Subsingleton ι] [Nontrivial G] (i : ι) :\n    ‖ofSubsingleton 𝕜 G G i (.id _ _)‖₊ = 1 :=\n  NNReal.eq <| norm_ofSubsingleton_id ..\n\n"}
{"name":"MultilinearMap.bound_of_shell","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"𝕜 : Type u\nι : Type v\nE : ι → Type wE\nG : Type wG\ninst✝⁵ : Fintype ι\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : (i : ι) → NormedAddCommGroup (E i)\ninst✝² : (i : ι) → NormedSpace 𝕜 (E i)\ninst✝¹ : SeminormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nf : MultilinearMap 𝕜 E G\nε : ι → Real\nC : Real\nc : ι → 𝕜\nhε : ∀ (i : ι), LT.lt 0 (ε i)\nhc : ∀ (i : ι), LT.lt 1 (Norm.norm (c i))\nhf : ∀ (m : (i : ι) → E i), (∀ (i : ι), LE.le (HDiv.hDiv (ε i) (Norm.norm (c i))) (Norm.norm (m i))) → (∀ (i : ι), LT.lt (Norm.norm (m i)) (ε i)) → LE.le (Norm.norm (f m)) (HMul.hMul C (Finset.univ.prod fun i => Norm.norm (m i)))\nm : (i : ι) → E i\n⊢ LE.le (Norm.norm (f m)) (HMul.hMul C (Finset.univ.prod fun i => Norm.norm (m i)))","decl":"/-- If a multilinear map in finitely many variables on normed spaces satisfies the inequality\n`‖f m‖ ≤ C * ∏ i, ‖m i‖` on a shell `ε i / ‖c i‖ < ‖m i‖ < ε i` for some positive numbers `ε i`\nand elements `c i : 𝕜`, `1 < ‖c i‖`, then it satisfies this inequality for all `m`. -/\ntheorem bound_of_shell (f : MultilinearMap 𝕜 E G) {ε : ι → ℝ} {C : ℝ} {c : ι → 𝕜}\n    (hε : ∀ i, 0 < ε i) (hc : ∀ i, 1 < ‖c i‖)\n    (hf : ∀ m : ∀ i, E i, (∀ i, ε i / ‖c i‖ ≤ ‖m i‖) → (∀ i, ‖m i‖ < ε i) → ‖f m‖ ≤ C * ∏ i, ‖m i‖)\n    (m : ∀ i, E i) : ‖f m‖ ≤ C * ∏ i, ‖m i‖ :=\n  bound_of_shell_of_norm_map_coord_zero f\n    (fun h ↦ by rw [map_coord_zero f _ (norm_eq_zero.1 h), norm_zero]) hε hc hf m\n\n"}
