{"name":"ContinuousMultilinearMap.instContinuousEval","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"ğ•œ : Type u_1\nÎ¹ : Type u_2\nE : Î¹ â†’ Type u_3\nF : Type u_4\ninstâœâ¶ : NormedField ğ•œ\ninstâœâµ : (i : Î¹) â†’ SeminormedAddCommGroup (E i)\ninstâœâ´ : (i : Î¹) â†’ NormedSpace ğ•œ (E i)\ninstâœÂ³ : TopologicalSpace F\ninstâœÂ² : AddCommGroup F\ninstâœÂ¹ : TopologicalAddGroup F\ninstâœ : Module ğ•œ F\nâŠ¢ ContinuousEval (ContinuousMultilinearMap ğ•œ E F) ((i : Î¹) â†’ E i) F","decl":"instance ContinuousMultilinearMap.instContinuousEval :\n    ContinuousEval (ContinuousMultilinearMap ğ•œ E F) (Î  i, E i) F where\n  continuous_eval := by\n    cases nonempty_fintype Î¹\n    let _ := TopologicalAddGroup.toUniformSpace F\n    have := comm_topologicalAddGroup_is_uniform (G := F)\n    refine (UniformOnFun.continuousOn_evalâ‚‚ fun m â†¦ ?_).comp_continuous\n      (isEmbedding_toUniformOnFun.continuous.prodMap continuous_id) fun (f, x) â†¦ f.cont.continuousAt\n    exact âŸ¨ball m 1, NormedSpace.isVonNBounded_of_isBounded _ isBounded_ball,\n      ball_mem_nhds _ one_posâŸ©\n\n"}
{"name":"ContinuousMultilinearMap.continuous_eval","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"F : Type u_1\nX : outParam (Type u_2)\nY : outParam (Type u_3)\ninstâœÂ³ : FunLike F X Y\ninstâœÂ² : TopologicalSpace F\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : TopologicalSpace Y\nself : ContinuousEval F X Y\nâŠ¢ Continuous fun fx => fx.1 fx.2","decl":"@[deprecated (since := \"2024-10-05\")]\nprotected alias ContinuousMultilinearMap.continuous_eval := continuous_eval\n\n"}
{"name":"ContinuousLinearMap.continuous_uncurry_of_multilinear","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"ğ•œ : Type u_1\nÎ¹ : Type u_2\nE : Î¹ â†’ Type u_3\nF : Type u_4\ninstâœÂ¹Â¹ : NormedField ğ•œ\ninstâœÂ¹â° : Finite Î¹\ninstâœâ¹ : (i : Î¹) â†’ SeminormedAddCommGroup (E i)\ninstâœâ¸ : (i : Î¹) â†’ NormedSpace ğ•œ (E i)\ninstâœâ· : TopologicalSpace F\ninstâœâ¶ : AddCommGroup F\ninstâœâµ : TopologicalAddGroup F\ninstâœâ´ : Module ğ•œ F\nG : Type u_5\ninstâœÂ³ : AddCommGroup G\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : Module ğ•œ G\ninstâœ : ContinuousConstSMul ğ•œ F\nf : ContinuousLinearMap (RingHom.id ğ•œ) G (ContinuousMultilinearMap ğ•œ E F)\nâŠ¢ Continuous fun p => (f p.1) p.2","decl":"lemma continuous_uncurry_of_multilinear (f : G â†’L[ğ•œ] ContinuousMultilinearMap ğ•œ E F) :\n    Continuous (fun (p : G Ã— (Î  i, E i)) â†¦ f p.1 p.2) := by\n  fun_prop\n\n"}
{"name":"ContinuousLinearMap.continuousOn_uncurry_of_multilinear","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"ğ•œ : Type u_1\nÎ¹ : Type u_2\nE : Î¹ â†’ Type u_3\nF : Type u_4\ninstâœÂ¹Â¹ : NormedField ğ•œ\ninstâœÂ¹â° : Finite Î¹\ninstâœâ¹ : (i : Î¹) â†’ SeminormedAddCommGroup (E i)\ninstâœâ¸ : (i : Î¹) â†’ NormedSpace ğ•œ (E i)\ninstâœâ· : TopologicalSpace F\ninstâœâ¶ : AddCommGroup F\ninstâœâµ : TopologicalAddGroup F\ninstâœâ´ : Module ğ•œ F\nG : Type u_5\ninstâœÂ³ : AddCommGroup G\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : Module ğ•œ G\ninstâœ : ContinuousConstSMul ğ•œ F\nf : ContinuousLinearMap (RingHom.id ğ•œ) G (ContinuousMultilinearMap ğ•œ E F)\ns : Set (Prod G ((i : Î¹) â†’ E i))\nâŠ¢ ContinuousOn (fun p => (f p.1) p.2) s","decl":"lemma continuousOn_uncurry_of_multilinear (f : G â†’L[ğ•œ] ContinuousMultilinearMap ğ•œ E F) {s} :\n    ContinuousOn (fun (p : G Ã— (Î  i, E i)) â†¦ f p.1 p.2) s :=\n  f.continuous_uncurry_of_multilinear.continuousOn\n\n"}
{"name":"ContinuousLinearMap.continuousAt_uncurry_of_multilinear","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"ğ•œ : Type u_1\nÎ¹ : Type u_2\nE : Î¹ â†’ Type u_3\nF : Type u_4\ninstâœÂ¹Â¹ : NormedField ğ•œ\ninstâœÂ¹â° : Finite Î¹\ninstâœâ¹ : (i : Î¹) â†’ SeminormedAddCommGroup (E i)\ninstâœâ¸ : (i : Î¹) â†’ NormedSpace ğ•œ (E i)\ninstâœâ· : TopologicalSpace F\ninstâœâ¶ : AddCommGroup F\ninstâœâµ : TopologicalAddGroup F\ninstâœâ´ : Module ğ•œ F\nG : Type u_5\ninstâœÂ³ : AddCommGroup G\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : Module ğ•œ G\ninstâœ : ContinuousConstSMul ğ•œ F\nf : ContinuousLinearMap (RingHom.id ğ•œ) G (ContinuousMultilinearMap ğ•œ E F)\nx : Prod G ((i : Î¹) â†’ E i)\nâŠ¢ ContinuousAt (fun p => (f p.1) p.2) x","decl":"lemma continuousAt_uncurry_of_multilinear (f : G â†’L[ğ•œ] ContinuousMultilinearMap ğ•œ E F) {x} :\n    ContinuousAt (fun (p : G Ã— (Î  i, E i)) â†¦ f p.1 p.2) x :=\n  f.continuous_uncurry_of_multilinear.continuousAt\n\n"}
{"name":"ContinuousLinearMap.continuousWithinAt_uncurry_of_multilinear","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"ğ•œ : Type u_1\nÎ¹ : Type u_2\nE : Î¹ â†’ Type u_3\nF : Type u_4\ninstâœÂ¹Â¹ : NormedField ğ•œ\ninstâœÂ¹â° : Finite Î¹\ninstâœâ¹ : (i : Î¹) â†’ SeminormedAddCommGroup (E i)\ninstâœâ¸ : (i : Î¹) â†’ NormedSpace ğ•œ (E i)\ninstâœâ· : TopologicalSpace F\ninstâœâ¶ : AddCommGroup F\ninstâœâµ : TopologicalAddGroup F\ninstâœâ´ : Module ğ•œ F\nG : Type u_5\ninstâœÂ³ : AddCommGroup G\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : Module ğ•œ G\ninstâœ : ContinuousConstSMul ğ•œ F\nf : ContinuousLinearMap (RingHom.id ğ•œ) G (ContinuousMultilinearMap ğ•œ E F)\ns : Set (Prod G ((i : Î¹) â†’ E i))\nx : Prod G ((i : Î¹) â†’ E i)\nâŠ¢ ContinuousWithinAt (fun p => (f p.1) p.2) s x","decl":"lemma continuousWithinAt_uncurry_of_multilinear (f : G â†’L[ğ•œ] ContinuousMultilinearMap ğ•œ E F) {s x} :\n    ContinuousWithinAt (fun (p : G Ã— (Î  i, E i)) â†¦ f p.1 p.2) s x :=\n  f.continuous_uncurry_of_multilinear.continuousWithinAt\n\n"}
{"name":"MultilinearMap.norm_map_coord_zero","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"ğ•œ : Type u\nÎ¹ : Type v\nE : Î¹ â†’ Type wE\nG : Type wG\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : (i : Î¹) â†’ SeminormedAddCommGroup (E i)\ninstâœÂ² : (i : Î¹) â†’ NormedSpace ğ•œ (E i)\ninstâœÂ¹ : SeminormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nf : MultilinearMap ğ•œ E G\nhf : Continuous â‡‘f\nm : (i : Î¹) â†’ E i\ni : Î¹\nhi : Eq (Norm.norm (m i)) 0\nâŠ¢ Eq (Norm.norm (f m)) 0","decl":"/-- If `f` is a continuous multilinear map on `E`\nand `m` is an element of `âˆ€ i, E i` such that one of the `m i` has norm `0`,\nthen `f m` has norm `0`.\n\nNote that we cannot drop the continuity assumption because `f (m : Unit â†’ E) = f (m ())`,\nwhere the domain has zero norm and the codomain has a nonzero norm\ndoes not satisfy this condition. -/\nlemma norm_map_coord_zero (f : MultilinearMap ğ•œ E G) (hf : Continuous f)\n    {m : âˆ€ i, E i} {i : Î¹} (hi : â€–m iâ€– = 0) : â€–f mâ€– = 0 := by\n  classical\n  rw [â† inseparable_zero_iff_norm] at hi âŠ¢\n  have : Inseparable (update m i 0) m := inseparable_pi.2 <|\n    (forall_update_iff m fun i a â†¦ Inseparable a (m i)).2 âŸ¨hi.symm, fun _ _ â†¦ rflâŸ©\n  simpa only [map_update_zero] using this.symm.map hf\n\n"}
{"name":"MultilinearMap.bound_of_shell_of_norm_map_coord_zero","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"ğ•œ : Type u\nÎ¹ : Type v\nE : Î¹ â†’ Type wE\nG : Type wG\ninstâœâµ : NontriviallyNormedField ğ•œ\ninstâœâ´ : (i : Î¹) â†’ SeminormedAddCommGroup (E i)\ninstâœÂ³ : (i : Î¹) â†’ NormedSpace ğ•œ (E i)\ninstâœÂ² : SeminormedAddCommGroup G\ninstâœÂ¹ : NormedSpace ğ•œ G\ninstâœ : Fintype Î¹\nf : MultilinearMap ğ•œ E G\nhfâ‚€ : âˆ€ {m : (i : Î¹) â†’ E i} {i : Î¹}, Eq (Norm.norm (m i)) 0 â†’ Eq (Norm.norm (f m)) 0\nÎµ : Î¹ â†’ Real\nC : Real\nhÎµ : âˆ€ (i : Î¹), LT.lt 0 (Îµ i)\nc : Î¹ â†’ ğ•œ\nhc : âˆ€ (i : Î¹), LT.lt 1 (Norm.norm (c i))\nhf : âˆ€ (m : (i : Î¹) â†’ E i), (âˆ€ (i : Î¹), LE.le (HDiv.hDiv (Îµ i) (Norm.norm (c i))) (Norm.norm (m i))) â†’ (âˆ€ (i : Î¹), LT.lt (Norm.norm (m i)) (Îµ i)) â†’ LE.le (Norm.norm (f m)) (HMul.hMul C (Finset.univ.prod fun i => Norm.norm (m i)))\nm : (i : Î¹) â†’ E i\nâŠ¢ LE.le (Norm.norm (f m)) (HMul.hMul C (Finset.univ.prod fun i => Norm.norm (m i)))","decl":"/-- If a multilinear map in finitely many variables on seminormed spaces\nsends vectors with a component of norm zero to vectors of norm zero\nand satisfies the inequality `â€–f mâ€– â‰¤ C * âˆ i, â€–m iâ€–` on a shell `Îµ i / â€–c iâ€– < â€–m iâ€– < Îµ i`\nfor some positive numbers `Îµ i` and elements `c i : ğ•œ`, `1 < â€–c iâ€–`,\nthen it satisfies this inequality for all `m`.\n\nThe first assumption is automatically satisfied on normed spaces, see `bound_of_shell` below.\nFor seminormed spaces, it follows from continuity of `f`, see next lemma,\nsee `bound_of_shell_of_continuous` below. -/\ntheorem bound_of_shell_of_norm_map_coord_zero (f : MultilinearMap ğ•œ E G)\n    (hfâ‚€ : âˆ€ {m i}, â€–m iâ€– = 0 â†’ â€–f mâ€– = 0)\n    {Îµ : Î¹ â†’ â„} {C : â„} (hÎµ : âˆ€ i, 0 < Îµ i) {c : Î¹ â†’ ğ•œ} (hc : âˆ€ i, 1 < â€–c iâ€–)\n    (hf : âˆ€ m : âˆ€ i, E i, (âˆ€ i, Îµ i / â€–c iâ€– â‰¤ â€–m iâ€–) â†’ (âˆ€ i, â€–m iâ€– < Îµ i) â†’ â€–f mâ€– â‰¤ C * âˆ i, â€–m iâ€–)\n    (m : âˆ€ i, E i) : â€–f mâ€– â‰¤ C * âˆ i, â€–m iâ€– := by\n  rcases em (âˆƒ i, â€–m iâ€– = 0) with (âŸ¨i, hiâŸ© | hm)\n  Â· rw [hfâ‚€ hi, prod_eq_zero (mem_univ i) hi, mul_zero]\n  push_neg at hm\n  choose Î´ hÎ´0 hÎ´m_lt hle_Î´m _ using fun i => rescale_to_shell_semi_normed (hc i) (hÎµ i) (hm i)\n  have hÎ´0 : 0 < âˆ i, â€–Î´ iâ€– := prod_pos fun i _ => norm_pos_iff.2 (hÎ´0 i)\n  simpa [map_smul_univ, norm_smul, prod_mul_distrib, mul_left_comm C, mul_le_mul_left hÎ´0] using\n    hf (fun i => Î´ i â€¢ m i) hle_Î´m hÎ´m_lt\n\n"}
{"name":"MultilinearMap.bound_of_shell_of_continuous","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"ğ•œ : Type u\nÎ¹ : Type v\nE : Î¹ â†’ Type wE\nG : Type wG\ninstâœâµ : NontriviallyNormedField ğ•œ\ninstâœâ´ : (i : Î¹) â†’ SeminormedAddCommGroup (E i)\ninstâœÂ³ : (i : Î¹) â†’ NormedSpace ğ•œ (E i)\ninstâœÂ² : SeminormedAddCommGroup G\ninstâœÂ¹ : NormedSpace ğ•œ G\ninstâœ : Fintype Î¹\nf : MultilinearMap ğ•œ E G\nhfc : Continuous â‡‘f\nÎµ : Î¹ â†’ Real\nC : Real\nhÎµ : âˆ€ (i : Î¹), LT.lt 0 (Îµ i)\nc : Î¹ â†’ ğ•œ\nhc : âˆ€ (i : Î¹), LT.lt 1 (Norm.norm (c i))\nhf : âˆ€ (m : (i : Î¹) â†’ E i), (âˆ€ (i : Î¹), LE.le (HDiv.hDiv (Îµ i) (Norm.norm (c i))) (Norm.norm (m i))) â†’ (âˆ€ (i : Î¹), LT.lt (Norm.norm (m i)) (Îµ i)) â†’ LE.le (Norm.norm (f m)) (HMul.hMul C (Finset.univ.prod fun i => Norm.norm (m i)))\nm : (i : Î¹) â†’ E i\nâŠ¢ LE.le (Norm.norm (f m)) (HMul.hMul C (Finset.univ.prod fun i => Norm.norm (m i)))","decl":"/-- If a continuous multilinear map in finitely many variables on normed spaces satisfies\nthe inequality `â€–f mâ€– â‰¤ C * âˆ i, â€–m iâ€–` on a shell `Îµ i / â€–c iâ€– < â€–m iâ€– < Îµ i` for some positive\nnumbers `Îµ i` and elements `c i : ğ•œ`, `1 < â€–c iâ€–`, then it satisfies this inequality for all `m`. -/\ntheorem bound_of_shell_of_continuous (f : MultilinearMap ğ•œ E G) (hfc : Continuous f)\n    {Îµ : Î¹ â†’ â„} {C : â„} (hÎµ : âˆ€ i, 0 < Îµ i) {c : Î¹ â†’ ğ•œ} (hc : âˆ€ i, 1 < â€–c iâ€–)\n    (hf : âˆ€ m : âˆ€ i, E i, (âˆ€ i, Îµ i / â€–c iâ€– â‰¤ â€–m iâ€–) â†’ (âˆ€ i, â€–m iâ€– < Îµ i) â†’ â€–f mâ€– â‰¤ C * âˆ i, â€–m iâ€–)\n    (m : âˆ€ i, E i) : â€–f mâ€– â‰¤ C * âˆ i, â€–m iâ€– :=\n  bound_of_shell_of_norm_map_coord_zero f (norm_map_coord_zero f hfc) hÎµ hc hf m\n\n"}
{"name":"MultilinearMap.exists_bound_of_continuous","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"ğ•œ : Type u\nÎ¹ : Type v\nE : Î¹ â†’ Type wE\nG : Type wG\ninstâœâµ : NontriviallyNormedField ğ•œ\ninstâœâ´ : (i : Î¹) â†’ SeminormedAddCommGroup (E i)\ninstâœÂ³ : (i : Î¹) â†’ NormedSpace ğ•œ (E i)\ninstâœÂ² : SeminormedAddCommGroup G\ninstâœÂ¹ : NormedSpace ğ•œ G\ninstâœ : Fintype Î¹\nf : MultilinearMap ğ•œ E G\nhf : Continuous â‡‘f\nâŠ¢ Exists fun C => And (LT.lt 0 C) (âˆ€ (m : (i : Î¹) â†’ E i), LE.le (Norm.norm (f m)) (HMul.hMul C (Finset.univ.prod fun i => Norm.norm (m i))))","decl":"/-- If a multilinear map in finitely many variables on normed spaces is continuous, then it\nsatisfies the inequality `â€–f mâ€– â‰¤ C * âˆ i, â€–m iâ€–`, for some `C` which can be chosen to be\npositive. -/\ntheorem exists_bound_of_continuous (f : MultilinearMap ğ•œ E G) (hf : Continuous f) :\n    âˆƒ C : â„, 0 < C âˆ§ âˆ€ m, â€–f mâ€– â‰¤ C * âˆ i, â€–m iâ€– := by\n  cases isEmpty_or_nonempty Î¹\n  Â· refine âŸ¨â€–f 0â€– + 1, add_pos_of_nonneg_of_pos (norm_nonneg _) zero_lt_one, fun m => ?_âŸ©\n    obtain rfl : m = 0 := funext (IsEmpty.elim â€¹_â€º)\n    simp [univ_eq_empty, zero_le_one]\n  obtain âŸ¨Îµ : â„, Îµ0 : 0 < Îµ, hÎµ : âˆ€ m : âˆ€ i, E i, â€–m - 0â€– < Îµ â†’ â€–f m - f 0â€– < 1âŸ© :=\n    NormedAddCommGroup.tendsto_nhds_nhds.1 (hf.tendsto 0) 1 zero_lt_one\n  simp only [sub_zero, f.map_zero] at hÎµ\n  rcases NormedField.exists_one_lt_norm ğ•œ with âŸ¨c, hcâŸ©\n  have : 0 < (â€–câ€– / Îµ) ^ Fintype.card Î¹ := pow_pos (div_pos (zero_lt_one.trans hc) Îµ0) _\n  refine âŸ¨_, this, ?_âŸ©\n  refine f.bound_of_shell_of_continuous hf (fun _ => Îµ0) (fun _ => hc) fun m hcm hm => ?_\n  refine (hÎµ m ((pi_norm_lt_iff Îµ0).2 hm)).le.trans ?_\n  rw [â† div_le_iffâ‚€' this, one_div, â† inv_pow, inv_div, Fintype.card, â† prod_const]\n  exact prod_le_prod (fun _ _ => div_nonneg Îµ0.le (norm_nonneg _)) fun i _ => hcm i\n\n"}
{"name":"MultilinearMap.norm_image_sub_le_of_bound'","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"ğ•œ : Type u\nÎ¹ : Type v\nE : Î¹ â†’ Type wE\nG : Type wG\ninstâœâ¶ : NontriviallyNormedField ğ•œ\ninstâœâµ : (i : Î¹) â†’ SeminormedAddCommGroup (E i)\ninstâœâ´ : (i : Î¹) â†’ NormedSpace ğ•œ (E i)\ninstâœÂ³ : SeminormedAddCommGroup G\ninstâœÂ² : NormedSpace ğ•œ G\ninstâœÂ¹ : Fintype Î¹\ninstâœ : DecidableEq Î¹\nf : MultilinearMap ğ•œ E G\nC : Real\nhC : LE.le 0 C\nH : âˆ€ (m : (i : Î¹) â†’ E i), LE.le (Norm.norm (f m)) (HMul.hMul C (Finset.univ.prod fun i => Norm.norm (m i)))\nmâ‚ mâ‚‚ : (i : Î¹) â†’ E i\nâŠ¢ LE.le (Norm.norm (HSub.hSub (f mâ‚) (f mâ‚‚))) (HMul.hMul C (Finset.univ.sum fun i => Finset.univ.prod fun j => ite (Eq j i) (Norm.norm (HSub.hSub (mâ‚ i) (mâ‚‚ i))) (Max.max (Norm.norm (mâ‚ j)) (Norm.norm (mâ‚‚ j)))))","decl":"/-- If a multilinear map `f` satisfies a boundedness property around `0`,\none can deduce a bound on `f mâ‚ - f mâ‚‚` using the multilinearity.\nHere, we give a precise but hard to use version.\nSee `norm_image_sub_le_of_bound` for a less precise but more usable version.\nThe bound reads\n`â€–f m - f m'â€– â‰¤\n  C * â€–m 1 - m' 1â€– * max â€–m 2â€– â€–m' 2â€– * max â€–m 3â€– â€–m' 3â€– * ... * max â€–m nâ€– â€–m' nâ€– + ...`,\nwhere the other terms in the sum are the same products where `1` is replaced by any `i`. -/\ntheorem norm_image_sub_le_of_bound' [DecidableEq Î¹] (f : MultilinearMap ğ•œ E G) {C : â„} (hC : 0 â‰¤ C)\n    (H : âˆ€ m, â€–f mâ€– â‰¤ C * âˆ i, â€–m iâ€–) (mâ‚ mâ‚‚ : âˆ€ i, E i) :\n    â€–f mâ‚ - f mâ‚‚â€– â‰¤ C * âˆ‘ i, âˆ j, if j = i then â€–mâ‚ i - mâ‚‚ iâ€– else max â€–mâ‚ jâ€– â€–mâ‚‚ jâ€– := by\n  have A :\n    âˆ€ s : Finset Î¹,\n      â€–f mâ‚ - f (s.piecewise mâ‚‚ mâ‚)â€– â‰¤\n        C * âˆ‘ i âˆˆ s, âˆ j, if j = i then â€–mâ‚ i - mâ‚‚ iâ€– else max â€–mâ‚ jâ€– â€–mâ‚‚ jâ€– := by\n    intro s\n    induction' s using Finset.induction with i s his Hrec\n    Â· simp\n    have I :\n      â€–f (s.piecewise mâ‚‚ mâ‚) - f ((insert i s).piecewise mâ‚‚ mâ‚)â€– â‰¤\n        C * âˆ j, if j = i then â€–mâ‚ i - mâ‚‚ iâ€– else max â€–mâ‚ jâ€– â€–mâ‚‚ jâ€– := by\n      have A : (insert i s).piecewise mâ‚‚ mâ‚ = Function.update (s.piecewise mâ‚‚ mâ‚) i (mâ‚‚ i) :=\n        s.piecewise_insert _ _ _\n      have B : s.piecewise mâ‚‚ mâ‚ = Function.update (s.piecewise mâ‚‚ mâ‚) i (mâ‚ i) := by\n        simp [eq_update_iff, his]\n      rw [B, A, â† f.map_update_sub]\n      apply le_trans (H _)\n      gcongr with j\n      by_cases h : j = i\n      Â· rw [h]\n        simp\n      Â· by_cases h' : j âˆˆ s <;> simp [h', h, le_refl]\n    calc\n      â€–f mâ‚ - f ((insert i s).piecewise mâ‚‚ mâ‚)â€– â‰¤\n          â€–f mâ‚ - f (s.piecewise mâ‚‚ mâ‚)â€– +\n            â€–f (s.piecewise mâ‚‚ mâ‚) - f ((insert i s).piecewise mâ‚‚ mâ‚)â€– := by\n        rw [â† dist_eq_norm, â† dist_eq_norm, â† dist_eq_norm]\n        exact dist_triangle _ _ _\n      _ â‰¤ (C * âˆ‘ i âˆˆ s, âˆ j, if j = i then â€–mâ‚ i - mâ‚‚ iâ€– else max â€–mâ‚ jâ€– â€–mâ‚‚ jâ€–) +\n            C * âˆ j, if j = i then â€–mâ‚ i - mâ‚‚ iâ€– else max â€–mâ‚ jâ€– â€–mâ‚‚ jâ€– :=\n        (add_le_add Hrec I)\n      _ = C * âˆ‘ i âˆˆ insert i s, âˆ j, if j = i then â€–mâ‚ i - mâ‚‚ iâ€– else max â€–mâ‚ jâ€– â€–mâ‚‚ jâ€– := by\n        simp [his, add_comm, left_distrib]\n  convert A univ\n  simp\n\n"}
{"name":"MultilinearMap.norm_image_sub_le_of_bound","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"ğ•œ : Type u\nÎ¹ : Type v\nE : Î¹ â†’ Type wE\nG : Type wG\ninstâœâµ : NontriviallyNormedField ğ•œ\ninstâœâ´ : (i : Î¹) â†’ SeminormedAddCommGroup (E i)\ninstâœÂ³ : (i : Î¹) â†’ NormedSpace ğ•œ (E i)\ninstâœÂ² : SeminormedAddCommGroup G\ninstâœÂ¹ : NormedSpace ğ•œ G\ninstâœ : Fintype Î¹\nf : MultilinearMap ğ•œ E G\nC : Real\nhC : LE.le 0 C\nH : âˆ€ (m : (i : Î¹) â†’ E i), LE.le (Norm.norm (f m)) (HMul.hMul C (Finset.univ.prod fun i => Norm.norm (m i)))\nmâ‚ mâ‚‚ : (i : Î¹) â†’ E i\nâŠ¢ LE.le (Norm.norm (HSub.hSub (f mâ‚) (f mâ‚‚))) (HMul.hMul (HMul.hMul (HMul.hMul C â†‘(Fintype.card Î¹)) (HPow.hPow (Max.max (Norm.norm mâ‚) (Norm.norm mâ‚‚)) (HSub.hSub (Fintype.card Î¹) 1))) (Norm.norm (HSub.hSub mâ‚ mâ‚‚)))","decl":"/-- If `f` satisfies a boundedness property around `0`, one can deduce a bound on `f mâ‚ - f mâ‚‚`\nusing the multilinearity. Here, we give a usable but not very precise version. See\n`norm_image_sub_le_of_bound'` for a more precise but less usable version. The bound is\n`â€–f m - f m'â€– â‰¤ C * card Î¹ * â€–m - m'â€– * (max â€–mâ€– â€–m'â€–) ^ (card Î¹ - 1)`. -/\ntheorem norm_image_sub_le_of_bound (f : MultilinearMap ğ•œ E G)\n    {C : â„} (hC : 0 â‰¤ C) (H : âˆ€ m, â€–f mâ€– â‰¤ C * âˆ i, â€–m iâ€–) (mâ‚ mâ‚‚ : âˆ€ i, E i) :\n    â€–f mâ‚ - f mâ‚‚â€– â‰¤ C * Fintype.card Î¹ * max â€–mâ‚â€– â€–mâ‚‚â€– ^ (Fintype.card Î¹ - 1) * â€–mâ‚ - mâ‚‚â€– := by\n  classical\n  have A :\n    âˆ€ i : Î¹,\n      âˆ j, (if j = i then â€–mâ‚ i - mâ‚‚ iâ€– else max â€–mâ‚ jâ€– â€–mâ‚‚ jâ€–) â‰¤\n        â€–mâ‚ - mâ‚‚â€– * max â€–mâ‚â€– â€–mâ‚‚â€– ^ (Fintype.card Î¹ - 1) := by\n    intro i\n    calc\n      âˆ j, (if j = i then â€–mâ‚ i - mâ‚‚ iâ€– else max â€–mâ‚ jâ€– â€–mâ‚‚ jâ€–) â‰¤\n          âˆ j : Î¹, Function.update (fun _ => max â€–mâ‚â€– â€–mâ‚‚â€–) i â€–mâ‚ - mâ‚‚â€– j := by\n        apply Finset.prod_le_prod\n        Â· intro j _\n          by_cases h : j = i <;> simp [h, norm_nonneg]\n        Â· intro j _\n          by_cases h : j = i\n          Â· rw [h]\n            simp only [ite_true, Function.update_self]\n            exact norm_le_pi_norm (mâ‚ - mâ‚‚) i\n          Â· simp [h, - le_sup_iff, - sup_le_iff, sup_le_sup, norm_le_pi_norm]\n      _ = â€–mâ‚ - mâ‚‚â€– * max â€–mâ‚â€– â€–mâ‚‚â€– ^ (Fintype.card Î¹ - 1) := by\n        rw [prod_update_of_mem (Finset.mem_univ _)]\n        simp [card_univ_diff]\n  calc\n    â€–f mâ‚ - f mâ‚‚â€– â‰¤ C * âˆ‘ i, âˆ j, if j = i then â€–mâ‚ i - mâ‚‚ iâ€– else max â€–mâ‚ jâ€– â€–mâ‚‚ jâ€– :=\n      f.norm_image_sub_le_of_bound' hC H mâ‚ mâ‚‚\n    _ â‰¤ C * âˆ‘ _i, â€–mâ‚ - mâ‚‚â€– * max â€–mâ‚â€– â€–mâ‚‚â€– ^ (Fintype.card Î¹ - 1) := by gcongr; apply A\n    _ = C * Fintype.card Î¹ * max â€–mâ‚â€– â€–mâ‚‚â€– ^ (Fintype.card Î¹ - 1) * â€–mâ‚ - mâ‚‚â€– := by\n      rw [sum_const, card_univ, nsmul_eq_mul]\n      ring\n\n"}
{"name":"MultilinearMap.continuous_of_bound","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"ğ•œ : Type u\nÎ¹ : Type v\nE : Î¹ â†’ Type wE\nG : Type wG\ninstâœâµ : NontriviallyNormedField ğ•œ\ninstâœâ´ : (i : Î¹) â†’ SeminormedAddCommGroup (E i)\ninstâœÂ³ : (i : Î¹) â†’ NormedSpace ğ•œ (E i)\ninstâœÂ² : SeminormedAddCommGroup G\ninstâœÂ¹ : NormedSpace ğ•œ G\ninstâœ : Fintype Î¹\nf : MultilinearMap ğ•œ E G\nC : Real\nH : âˆ€ (m : (i : Î¹) â†’ E i), LE.le (Norm.norm (f m)) (HMul.hMul C (Finset.univ.prod fun i => Norm.norm (m i)))\nâŠ¢ Continuous â‡‘f","decl":"/-- If a multilinear map satisfies an inequality `â€–f mâ€– â‰¤ C * âˆ i, â€–m iâ€–`, then it is\ncontinuous. -/\ntheorem continuous_of_bound (f : MultilinearMap ğ•œ E G) (C : â„) (H : âˆ€ m, â€–f mâ€– â‰¤ C * âˆ i, â€–m iâ€–) :\n    Continuous f := by\n  let D := max C 1\n  have D_pos : 0 â‰¤ D := le_trans zero_le_one (le_max_right _ _)\n  replace H (m) : â€–f mâ€– â‰¤ D * âˆ i, â€–m iâ€– :=\n    (H m).trans (mul_le_mul_of_nonneg_right (le_max_left _ _) <| by positivity)\n  refine continuous_iff_continuousAt.2 fun m => ?_\n  refine\n    continuousAt_of_locally_lipschitz zero_lt_one\n      (D * Fintype.card Î¹ * (â€–mâ€– + 1) ^ (Fintype.card Î¹ - 1)) fun m' h' => ?_\n  rw [dist_eq_norm, dist_eq_norm]\n  have : max â€–m'â€– â€–mâ€– â‰¤ â€–mâ€– + 1 := by\n    simp [zero_le_one, norm_le_of_mem_closedBall (le_of_lt h')]\n  calc\n    â€–f m' - f mâ€– â‰¤ D * Fintype.card Î¹ * max â€–m'â€– â€–mâ€– ^ (Fintype.card Î¹ - 1) * â€–m' - mâ€– :=\n      f.norm_image_sub_le_of_bound D_pos H m' m\n    _ â‰¤ D * Fintype.card Î¹ * (â€–mâ€– + 1) ^ (Fintype.card Î¹ - 1) * â€–m' - mâ€– := by gcongr\n\n"}
{"name":"MultilinearMap.coe_mkContinuous","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"ğ•œ : Type u\nÎ¹ : Type v\nE : Î¹ â†’ Type wE\nG : Type wG\ninstâœâµ : NontriviallyNormedField ğ•œ\ninstâœâ´ : (i : Î¹) â†’ SeminormedAddCommGroup (E i)\ninstâœÂ³ : (i : Î¹) â†’ NormedSpace ğ•œ (E i)\ninstâœÂ² : SeminormedAddCommGroup G\ninstâœÂ¹ : NormedSpace ğ•œ G\ninstâœ : Fintype Î¹\nf : MultilinearMap ğ•œ E G\nC : Real\nH : âˆ€ (m : (i : Î¹) â†’ E i), LE.le (Norm.norm (f m)) (HMul.hMul C (Finset.univ.prod fun i => Norm.norm (m i)))\nâŠ¢ Eq â‡‘(f.mkContinuous C H) â‡‘f","decl":"@[simp]\ntheorem coe_mkContinuous (f : MultilinearMap ğ•œ E G) (C : â„) (H : âˆ€ m, â€–f mâ€– â‰¤ C * âˆ i, â€–m iâ€–) :\n    â‡‘(f.mkContinuous C H) = f :=\n  rfl\n\n"}
{"name":"MultilinearMap.restr_norm_le","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"ğ•œ : Type u\nG : Type wG\nG' : Type wG'\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : SeminormedAddCommGroup G\ninstâœÂ² : NormedSpace ğ•œ G\ninstâœÂ¹ : SeminormedAddCommGroup G'\ninstâœ : NormedSpace ğ•œ G'\nk n : Nat\nf : MultilinearMap ğ•œ (fun x => G) G'\ns : Finset (Fin n)\nhk : Eq s.card k\nz : G\nC : Real\nH : âˆ€ (m : Fin n â†’ G), LE.le (Norm.norm (f m)) (HMul.hMul C (Finset.univ.prod fun i => Norm.norm (m i)))\nv : Fin k â†’ G\nâŠ¢ LE.le (Norm.norm ((f.restr s hk z) v)) (HMul.hMul (HMul.hMul C (HPow.hPow (Norm.norm z) (HSub.hSub n k))) (Finset.univ.prod fun i => Norm.norm (v i)))","decl":"/-- Given a multilinear map in `n` variables, if one restricts it to `k` variables putting `z` on\nthe other coordinates, then the resulting restricted function satisfies an inequality\n`â€–f.restr vâ€– â‰¤ C * â€–zâ€–^(n-k) * Î  â€–v iâ€–` if the original function satisfies `â€–f vâ€– â‰¤ C * Î  â€–v iâ€–`. -/\ntheorem restr_norm_le {k n : â„•} (f : MultilinearMap ğ•œ (fun _ : Fin n => G) G')\n    (s : Finset (Fin n)) (hk : #s = k) (z : G) {C : â„} (H : âˆ€ m, â€–f mâ€– â‰¤ C * âˆ i, â€–m iâ€–)\n    (v : Fin k â†’ G) : â€–f.restr s hk z vâ€– â‰¤ C * â€–zâ€– ^ (n - k) * âˆ i, â€–v iâ€– := by\n  rw [mul_right_comm, mul_assoc]\n  convert H _ using 2\n  simp only [apply_dite norm, Fintype.prod_dite, prod_const â€–zâ€–, Finset.card_univ,\n    Fintype.card_of_subtype sá¶œ fun _ => mem_compl, card_compl, Fintype.card_fin, hk, mk_coe, â†\n    (s.orderIsoOfFin hk).symm.bijective.prod_comp fun x => â€–v xâ€–]\n  convert rfl\n\n"}
{"name":"ContinuousMultilinearMap.bound","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"ğ•œ : Type u\nÎ¹ : Type v\nE : Î¹ â†’ Type wE\nG : Type wG\ninstâœâµ : NontriviallyNormedField ğ•œ\ninstâœâ´ : (i : Î¹) â†’ SeminormedAddCommGroup (E i)\ninstâœÂ³ : (i : Î¹) â†’ NormedSpace ğ•œ (E i)\ninstâœÂ² : SeminormedAddCommGroup G\ninstâœÂ¹ : NormedSpace ğ•œ G\ninstâœ : Fintype Î¹\nf : ContinuousMultilinearMap ğ•œ E G\nâŠ¢ Exists fun C => And (LT.lt 0 C) (âˆ€ (m : (i : Î¹) â†’ E i), LE.le (Norm.norm (f m)) (HMul.hMul C (Finset.univ.prod fun i => Norm.norm (m i))))","decl":"theorem bound (f : ContinuousMultilinearMap ğ•œ E G) :\n    âˆƒ C : â„, 0 < C âˆ§ âˆ€ m, â€–f mâ€– â‰¤ C * âˆ i, â€–m iâ€– :=\n  f.toMultilinearMap.exists_bound_of_continuous f.2\n\n"}
{"name":"ContinuousMultilinearMap.norm_def","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"ğ•œ : Type u\nÎ¹ : Type v\nE : Î¹ â†’ Type wE\nG : Type wG\ninstâœâµ : NontriviallyNormedField ğ•œ\ninstâœâ´ : (i : Î¹) â†’ SeminormedAddCommGroup (E i)\ninstâœÂ³ : (i : Î¹) â†’ NormedSpace ğ•œ (E i)\ninstâœÂ² : SeminormedAddCommGroup G\ninstâœÂ¹ : NormedSpace ğ•œ G\ninstâœ : Fintype Î¹\nf : ContinuousMultilinearMap ğ•œ E G\nâŠ¢ Eq (Norm.norm f) (InfSet.sInf (setOf fun c => And (LE.le 0 c) (âˆ€ (m : (i : Î¹) â†’ E i), LE.le (Norm.norm (f m)) (HMul.hMul c (Finset.univ.prod fun i => Norm.norm (m i))))))","decl":"theorem norm_def (f : ContinuousMultilinearMap ğ•œ E G) :\n    â€–fâ€– = sInf { c | 0 â‰¤ (c : â„) âˆ§ âˆ€ m, â€–f mâ€– â‰¤ c * âˆ i, â€–m iâ€– } :=\n  rfl\n\n-- So that invocations of `le_csInf` make sense: we show that the set of\n-- bounds is nonempty and bounded below.\n"}
{"name":"ContinuousMultilinearMap.bounds_nonempty","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"ğ•œ : Type u\nÎ¹ : Type v\nE : Î¹ â†’ Type wE\nG : Type wG\ninstâœâµ : NontriviallyNormedField ğ•œ\ninstâœâ´ : (i : Î¹) â†’ SeminormedAddCommGroup (E i)\ninstâœÂ³ : (i : Î¹) â†’ NormedSpace ğ•œ (E i)\ninstâœÂ² : SeminormedAddCommGroup G\ninstâœÂ¹ : NormedSpace ğ•œ G\ninstâœ : Fintype Î¹\nf : ContinuousMultilinearMap ğ•œ E G\nâŠ¢ Exists fun c => Membership.mem (setOf fun c => And (LE.le 0 c) (âˆ€ (m : (i : Î¹) â†’ E i), LE.le (Norm.norm (f m)) (HMul.hMul c (Finset.univ.prod fun i => Norm.norm (m i))))) c","decl":"theorem bounds_nonempty {f : ContinuousMultilinearMap ğ•œ E G} :\n    âˆƒ c, c âˆˆ { c | 0 â‰¤ c âˆ§ âˆ€ m, â€–f mâ€– â‰¤ c * âˆ i, â€–m iâ€– } :=\n  let âŸ¨M, hMp, hMbâŸ© := f.bound\n  âŸ¨M, le_of_lt hMp, hMbâŸ©\n\n"}
{"name":"ContinuousMultilinearMap.bounds_bddBelow","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"ğ•œ : Type u\nÎ¹ : Type v\nE : Î¹ â†’ Type wE\nG : Type wG\ninstâœâµ : NontriviallyNormedField ğ•œ\ninstâœâ´ : (i : Î¹) â†’ SeminormedAddCommGroup (E i)\ninstâœÂ³ : (i : Î¹) â†’ NormedSpace ğ•œ (E i)\ninstâœÂ² : SeminormedAddCommGroup G\ninstâœÂ¹ : NormedSpace ğ•œ G\ninstâœ : Fintype Î¹\nf : ContinuousMultilinearMap ğ•œ E G\nâŠ¢ BddBelow (setOf fun c => And (LE.le 0 c) (âˆ€ (m : (i : Î¹) â†’ E i), LE.le (Norm.norm (f m)) (HMul.hMul c (Finset.univ.prod fun i => Norm.norm (m i)))))","decl":"theorem bounds_bddBelow {f : ContinuousMultilinearMap ğ•œ E G} :\n    BddBelow { c | 0 â‰¤ c âˆ§ âˆ€ m, â€–f mâ€– â‰¤ c * âˆ i, â€–m iâ€– } :=\n  âŸ¨0, fun _ âŸ¨hn, _âŸ© => hnâŸ©\n\n"}
{"name":"ContinuousMultilinearMap.isLeast_opNorm","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"ğ•œ : Type u\nÎ¹ : Type v\nE : Î¹ â†’ Type wE\nG : Type wG\ninstâœâµ : NontriviallyNormedField ğ•œ\ninstâœâ´ : (i : Î¹) â†’ SeminormedAddCommGroup (E i)\ninstâœÂ³ : (i : Î¹) â†’ NormedSpace ğ•œ (E i)\ninstâœÂ² : SeminormedAddCommGroup G\ninstâœÂ¹ : NormedSpace ğ•œ G\ninstâœ : Fintype Î¹\nf : ContinuousMultilinearMap ğ•œ E G\nâŠ¢ IsLeast (setOf fun c => And (LE.le 0 c) (âˆ€ (m : (i : Î¹) â†’ E i), LE.le (Norm.norm (f m)) (HMul.hMul c (Finset.univ.prod fun i => Norm.norm (m i))))) (Norm.norm f)","decl":"theorem isLeast_opNorm (f : ContinuousMultilinearMap ğ•œ E G) :\n    IsLeast {c : â„ | 0 â‰¤ c âˆ§ âˆ€ m, â€–f mâ€– â‰¤ c * âˆ i, â€–m iâ€–} â€–fâ€– := by\n  refine IsClosed.isLeast_csInf ?_ bounds_nonempty bounds_bddBelow\n  simp only [Set.setOf_and, Set.setOf_forall]\n  exact isClosed_Ici.inter (isClosed_iInter fun m â†¦\n    isClosed_le continuous_const (continuous_id.mul continuous_const))\n\n"}
{"name":"ContinuousMultilinearMap.opNorm_nonneg","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"ğ•œ : Type u\nÎ¹ : Type v\nE : Î¹ â†’ Type wE\nG : Type wG\ninstâœâµ : NontriviallyNormedField ğ•œ\ninstâœâ´ : (i : Î¹) â†’ SeminormedAddCommGroup (E i)\ninstâœÂ³ : (i : Î¹) â†’ NormedSpace ğ•œ (E i)\ninstâœÂ² : SeminormedAddCommGroup G\ninstâœÂ¹ : NormedSpace ğ•œ G\ninstâœ : Fintype Î¹\nf : ContinuousMultilinearMap ğ•œ E G\nâŠ¢ LE.le 0 (Norm.norm f)","decl":"theorem opNorm_nonneg (f : ContinuousMultilinearMap ğ•œ E G) : 0 â‰¤ â€–fâ€– :=\n  Real.sInf_nonneg fun _ âŸ¨hx, _âŸ© => hx\n\n"}
{"name":"ContinuousMultilinearMap.le_opNorm","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"ğ•œ : Type u\nÎ¹ : Type v\nE : Î¹ â†’ Type wE\nG : Type wG\ninstâœâµ : NontriviallyNormedField ğ•œ\ninstâœâ´ : (i : Î¹) â†’ SeminormedAddCommGroup (E i)\ninstâœÂ³ : (i : Î¹) â†’ NormedSpace ğ•œ (E i)\ninstâœÂ² : SeminormedAddCommGroup G\ninstâœÂ¹ : NormedSpace ğ•œ G\ninstâœ : Fintype Î¹\nf : ContinuousMultilinearMap ğ•œ E G\nm : (i : Î¹) â†’ E i\nâŠ¢ LE.le (Norm.norm (f m)) (HMul.hMul (Norm.norm f) (Finset.univ.prod fun i => Norm.norm (m i)))","decl":"/-- The fundamental property of the operator norm of a continuous multilinear map:\n`â€–f mâ€–` is bounded by `â€–fâ€–` times the product of the `â€–m iâ€–`. -/\ntheorem le_opNorm (f : ContinuousMultilinearMap ğ•œ E G) (m : âˆ€ i, E i) :\n    â€–f mâ€– â‰¤ â€–fâ€– * âˆ i, â€–m iâ€– :=\n  f.isLeast_opNorm.1.2 m\n\n"}
{"name":"ContinuousMultilinearMap.le_mul_prod_of_opNorm_le_of_le","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"ğ•œ : Type u\nÎ¹ : Type v\nE : Î¹ â†’ Type wE\nG : Type wG\ninstâœâµ : NontriviallyNormedField ğ•œ\ninstâœâ´ : (i : Î¹) â†’ SeminormedAddCommGroup (E i)\ninstâœÂ³ : (i : Î¹) â†’ NormedSpace ğ•œ (E i)\ninstâœÂ² : SeminormedAddCommGroup G\ninstâœÂ¹ : NormedSpace ğ•œ G\ninstâœ : Fintype Î¹\nf : ContinuousMultilinearMap ğ•œ E G\nm : (i : Î¹) â†’ E i\nC : Real\nb : Î¹ â†’ Real\nhC : LE.le (Norm.norm f) C\nhm : âˆ€ (i : Î¹), LE.le (Norm.norm (m i)) (b i)\nâŠ¢ LE.le (Norm.norm (f m)) (HMul.hMul C (Finset.univ.prod fun i => b i))","decl":"theorem le_mul_prod_of_opNorm_le_of_le {f : ContinuousMultilinearMap ğ•œ E G}\n    {m : âˆ€ i, E i} {C : â„} {b : Î¹ â†’ â„} (hC : â€–fâ€– â‰¤ C) (hm : âˆ€ i, â€–m iâ€– â‰¤ b i) :\n    â€–f mâ€– â‰¤ C * âˆ i, b i :=\n  (f.le_opNorm m).trans <| by gcongr; exacts [f.opNorm_nonneg.trans hC, hm _]\n\n"}
{"name":"ContinuousMultilinearMap.le_mul_prod_of_le_opNorm_of_le","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"ğ•œ : Type u\nÎ¹ : Type v\nE : Î¹ â†’ Type wE\nG : Type wG\ninstâœâµ : NontriviallyNormedField ğ•œ\ninstâœâ´ : (i : Î¹) â†’ SeminormedAddCommGroup (E i)\ninstâœÂ³ : (i : Î¹) â†’ NormedSpace ğ•œ (E i)\ninstâœÂ² : SeminormedAddCommGroup G\ninstâœÂ¹ : NormedSpace ğ•œ G\ninstâœ : Fintype Î¹\nf : ContinuousMultilinearMap ğ•œ E G\nm : (i : Î¹) â†’ E i\nC : Real\nb : Î¹ â†’ Real\nhC : LE.le (Norm.norm f) C\nhm : âˆ€ (i : Î¹), LE.le (Norm.norm (m i)) (b i)\nâŠ¢ LE.le (Norm.norm (f m)) (HMul.hMul C (Finset.univ.prod fun i => b i))","decl":"@[deprecated (since := \"2024-11-27\")]\nalias le_mul_prod_of_le_opNorm_of_le := le_mul_prod_of_opNorm_le_of_le\n\n"}
{"name":"ContinuousMultilinearMap.le_opNorm_mul_prod_of_le","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"ğ•œ : Type u\nÎ¹ : Type v\nE : Î¹ â†’ Type wE\nG : Type wG\ninstâœâµ : NontriviallyNormedField ğ•œ\ninstâœâ´ : (i : Î¹) â†’ SeminormedAddCommGroup (E i)\ninstâœÂ³ : (i : Î¹) â†’ NormedSpace ğ•œ (E i)\ninstâœÂ² : SeminormedAddCommGroup G\ninstâœÂ¹ : NormedSpace ğ•œ G\ninstâœ : Fintype Î¹\nf : ContinuousMultilinearMap ğ•œ E G\nm : (i : Î¹) â†’ E i\nb : Î¹ â†’ Real\nhm : âˆ€ (i : Î¹), LE.le (Norm.norm (m i)) (b i)\nâŠ¢ LE.le (Norm.norm (f m)) (HMul.hMul (Norm.norm f) (Finset.univ.prod fun i => b i))","decl":"theorem le_opNorm_mul_prod_of_le (f : ContinuousMultilinearMap ğ•œ E G)\n    {m : âˆ€ i, E i} {b : Î¹ â†’ â„} (hm : âˆ€ i, â€–m iâ€– â‰¤ b i) : â€–f mâ€– â‰¤ â€–fâ€– * âˆ i, b i :=\n  le_mul_prod_of_opNorm_le_of_le le_rfl hm\n\n"}
{"name":"ContinuousMultilinearMap.le_opNorm_mul_pow_card_of_le","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"ğ•œ : Type u\nÎ¹ : Type v\nE : Î¹ â†’ Type wE\nG : Type wG\ninstâœâµ : NontriviallyNormedField ğ•œ\ninstâœâ´ : (i : Î¹) â†’ SeminormedAddCommGroup (E i)\ninstâœÂ³ : (i : Î¹) â†’ NormedSpace ğ•œ (E i)\ninstâœÂ² : SeminormedAddCommGroup G\ninstâœÂ¹ : NormedSpace ğ•œ G\ninstâœ : Fintype Î¹\nf : ContinuousMultilinearMap ğ•œ E G\nm : (i : Î¹) â†’ E i\nb : Real\nhm : LE.le (Norm.norm m) b\nâŠ¢ LE.le (Norm.norm (f m)) (HMul.hMul (Norm.norm f) (HPow.hPow b (Fintype.card Î¹)))","decl":"theorem le_opNorm_mul_pow_card_of_le (f : ContinuousMultilinearMap ğ•œ E G) {m b} (hm : â€–mâ€– â‰¤ b) :\n    â€–f mâ€– â‰¤ â€–fâ€– * b ^ Fintype.card Î¹ := by\n  simpa only [prod_const] using f.le_opNorm_mul_prod_of_le fun i => (norm_le_pi_norm m i).trans hm\n\n"}
{"name":"ContinuousMultilinearMap.le_opNorm_mul_pow_of_le","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"ğ•œ : Type u\nG : Type wG\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : SeminormedAddCommGroup G\ninstâœÂ² : NormedSpace ğ•œ G\nn : Nat\nEi : Fin n â†’ Type u_1\ninstâœÂ¹ : (i : Fin n) â†’ SeminormedAddCommGroup (Ei i)\ninstâœ : (i : Fin n) â†’ NormedSpace ğ•œ (Ei i)\nf : ContinuousMultilinearMap ğ•œ Ei G\nm : (i : Fin n) â†’ Ei i\nb : Real\nhm : LE.le (Norm.norm m) b\nâŠ¢ LE.le (Norm.norm (f m)) (HMul.hMul (Norm.norm f) (HPow.hPow b n))","decl":"theorem le_opNorm_mul_pow_of_le {n : â„•} {Ei : Fin n â†’ Type*} [âˆ€ i, SeminormedAddCommGroup (Ei i)]\n    [âˆ€ i, NormedSpace ğ•œ (Ei i)] (f : ContinuousMultilinearMap ğ•œ Ei G) {m : âˆ€ i, Ei i} {b : â„}\n    (hm : â€–mâ€– â‰¤ b) : â€–f mâ€– â‰¤ â€–fâ€– * b ^ n := by\n  simpa only [Fintype.card_fin] using f.le_opNorm_mul_pow_card_of_le hm\n\n"}
{"name":"ContinuousMultilinearMap.le_of_opNorm_le","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"ğ•œ : Type u\nÎ¹ : Type v\nE : Î¹ â†’ Type wE\nG : Type wG\ninstâœâµ : NontriviallyNormedField ğ•œ\ninstâœâ´ : (i : Î¹) â†’ SeminormedAddCommGroup (E i)\ninstâœÂ³ : (i : Î¹) â†’ NormedSpace ğ•œ (E i)\ninstâœÂ² : SeminormedAddCommGroup G\ninstâœÂ¹ : NormedSpace ğ•œ G\ninstâœ : Fintype Î¹\nf : ContinuousMultilinearMap ğ•œ E G\nC : Real\nh : LE.le (Norm.norm f) C\nm : (i : Î¹) â†’ E i\nâŠ¢ LE.le (Norm.norm (f m)) (HMul.hMul C (Finset.univ.prod fun i => Norm.norm (m i)))","decl":"theorem le_of_opNorm_le {f : ContinuousMultilinearMap ğ•œ E G} {C : â„} (h : â€–fâ€– â‰¤ C) (m : âˆ€ i, E i) :\n    â€–f mâ€– â‰¤ C * âˆ i, â€–m iâ€– :=\n  le_mul_prod_of_opNorm_le_of_le h fun _ â†¦ le_rfl\n\n"}
{"name":"ContinuousMultilinearMap.ratio_le_opNorm","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"ğ•œ : Type u\nÎ¹ : Type v\nE : Î¹ â†’ Type wE\nG : Type wG\ninstâœâµ : NontriviallyNormedField ğ•œ\ninstâœâ´ : (i : Î¹) â†’ SeminormedAddCommGroup (E i)\ninstâœÂ³ : (i : Î¹) â†’ NormedSpace ğ•œ (E i)\ninstâœÂ² : SeminormedAddCommGroup G\ninstâœÂ¹ : NormedSpace ğ•œ G\ninstâœ : Fintype Î¹\nf : ContinuousMultilinearMap ğ•œ E G\nm : (i : Î¹) â†’ E i\nâŠ¢ LE.le (HDiv.hDiv (Norm.norm (f m)) (Finset.univ.prod fun i => Norm.norm (m i))) (Norm.norm f)","decl":"theorem ratio_le_opNorm (f : ContinuousMultilinearMap ğ•œ E G) (m : âˆ€ i, E i) :\n    (â€–f mâ€– / âˆ i, â€–m iâ€–) â‰¤ â€–fâ€– :=\n  div_le_of_le_mulâ‚€ (by positivity) (opNorm_nonneg _) (f.le_opNorm m)\n\n"}
{"name":"ContinuousMultilinearMap.unit_le_opNorm","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"ğ•œ : Type u\nÎ¹ : Type v\nE : Î¹ â†’ Type wE\nG : Type wG\ninstâœâµ : NontriviallyNormedField ğ•œ\ninstâœâ´ : (i : Î¹) â†’ SeminormedAddCommGroup (E i)\ninstâœÂ³ : (i : Î¹) â†’ NormedSpace ğ•œ (E i)\ninstâœÂ² : SeminormedAddCommGroup G\ninstâœÂ¹ : NormedSpace ğ•œ G\ninstâœ : Fintype Î¹\nf : ContinuousMultilinearMap ğ•œ E G\nm : (i : Î¹) â†’ E i\nh : LE.le (Norm.norm m) 1\nâŠ¢ LE.le (Norm.norm (f m)) (Norm.norm f)","decl":"/-- The image of the unit ball under a continuous multilinear map is bounded. -/\ntheorem unit_le_opNorm (f : ContinuousMultilinearMap ğ•œ E G) {m : âˆ€ i, E i} (h : â€–mâ€– â‰¤ 1) :\n    â€–f mâ€– â‰¤ â€–fâ€– :=\n  (le_opNorm_mul_pow_card_of_le f h).trans <| by simp\n\n"}
{"name":"ContinuousMultilinearMap.opNorm_le_bound","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"ğ•œ : Type u\nÎ¹ : Type v\nE : Î¹ â†’ Type wE\nG : Type wG\ninstâœâµ : NontriviallyNormedField ğ•œ\ninstâœâ´ : (i : Î¹) â†’ SeminormedAddCommGroup (E i)\ninstâœÂ³ : (i : Î¹) â†’ NormedSpace ğ•œ (E i)\ninstâœÂ² : SeminormedAddCommGroup G\ninstâœÂ¹ : NormedSpace ğ•œ G\ninstâœ : Fintype Î¹\nf : ContinuousMultilinearMap ğ•œ E G\nM : Real\nhMp : LE.le 0 M\nhM : âˆ€ (m : (i : Î¹) â†’ E i), LE.le (Norm.norm (f m)) (HMul.hMul M (Finset.univ.prod fun i => Norm.norm (m i)))\nâŠ¢ LE.le (Norm.norm f) M","decl":"/-- If one controls the norm of every `f x`, then one controls the norm of `f`. -/\ntheorem opNorm_le_bound {f : ContinuousMultilinearMap ğ•œ E G}\n    {M : â„} (hMp : 0 â‰¤ M) (hM : âˆ€ m, â€–f mâ€– â‰¤ M * âˆ i, â€–m iâ€–) : â€–fâ€– â‰¤ M :=\n  csInf_le bounds_bddBelow âŸ¨hMp, hMâŸ©\n\n"}
{"name":"ContinuousMultilinearMap.opNorm_le_iff","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"ğ•œ : Type u\nÎ¹ : Type v\nE : Î¹ â†’ Type wE\nG : Type wG\ninstâœâµ : NontriviallyNormedField ğ•œ\ninstâœâ´ : (i : Î¹) â†’ SeminormedAddCommGroup (E i)\ninstâœÂ³ : (i : Î¹) â†’ NormedSpace ğ•œ (E i)\ninstâœÂ² : SeminormedAddCommGroup G\ninstâœÂ¹ : NormedSpace ğ•œ G\ninstâœ : Fintype Î¹\nf : ContinuousMultilinearMap ğ•œ E G\nC : Real\nhC : LE.le 0 C\nâŠ¢ Iff (LE.le (Norm.norm f) C) (âˆ€ (m : (i : Î¹) â†’ E i), LE.le (Norm.norm (f m)) (HMul.hMul C (Finset.univ.prod fun i => Norm.norm (m i))))","decl":"theorem opNorm_le_iff {f : ContinuousMultilinearMap ğ•œ E G} {C : â„} (hC : 0 â‰¤ C) :\n    â€–fâ€– â‰¤ C â†” âˆ€ m, â€–f mâ€– â‰¤ C * âˆ i, â€–m iâ€– :=\n  âŸ¨fun h _ â†¦ le_of_opNorm_le h _, opNorm_le_bound hCâŸ©\n\n"}
{"name":"ContinuousMultilinearMap.opNorm_add_le","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"ğ•œ : Type u\nÎ¹ : Type v\nE : Î¹ â†’ Type wE\nG : Type wG\ninstâœâµ : NontriviallyNormedField ğ•œ\ninstâœâ´ : (i : Î¹) â†’ SeminormedAddCommGroup (E i)\ninstâœÂ³ : (i : Î¹) â†’ NormedSpace ğ•œ (E i)\ninstâœÂ² : SeminormedAddCommGroup G\ninstâœÂ¹ : NormedSpace ğ•œ G\ninstâœ : Fintype Î¹\nf g : ContinuousMultilinearMap ğ•œ E G\nâŠ¢ LE.le (Norm.norm (HAdd.hAdd f g)) (HAdd.hAdd (Norm.norm f) (Norm.norm g))","decl":"/-- The operator norm satisfies the triangle inequality. -/\ntheorem opNorm_add_le (f g : ContinuousMultilinearMap ğ•œ E G) : â€–f + gâ€– â‰¤ â€–fâ€– + â€–gâ€– :=\n  opNorm_le_bound (add_nonneg (opNorm_nonneg f) (opNorm_nonneg g)) fun x => by\n    rw [add_mul]\n    exact norm_add_le_of_le (le_opNorm _ _) (le_opNorm _ _)\n\n"}
{"name":"ContinuousMultilinearMap.opNorm_zero","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"ğ•œ : Type u\nÎ¹ : Type v\nE : Î¹ â†’ Type wE\nG : Type wG\ninstâœâµ : NontriviallyNormedField ğ•œ\ninstâœâ´ : (i : Î¹) â†’ SeminormedAddCommGroup (E i)\ninstâœÂ³ : (i : Î¹) â†’ NormedSpace ğ•œ (E i)\ninstâœÂ² : SeminormedAddCommGroup G\ninstâœÂ¹ : NormedSpace ğ•œ G\ninstâœ : Fintype Î¹\nâŠ¢ Eq (Norm.norm 0) 0","decl":"theorem opNorm_zero : â€–(0 : ContinuousMultilinearMap ğ•œ E G)â€– = 0 :=\n  (opNorm_nonneg _).antisymm' <| opNorm_le_bound le_rfl fun m => by simp\n\n"}
{"name":"ContinuousMultilinearMap.opNorm_smul_le","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"ğ•œ : Type u\nÎ¹ : Type v\nE : Î¹ â†’ Type wE\nG : Type wG\ninstâœâ¸ : NontriviallyNormedField ğ•œ\ninstâœâ· : (i : Î¹) â†’ SeminormedAddCommGroup (E i)\ninstâœâ¶ : (i : Î¹) â†’ NormedSpace ğ•œ (E i)\ninstâœâµ : SeminormedAddCommGroup G\ninstâœâ´ : NormedSpace ğ•œ G\ninstâœÂ³ : Fintype Î¹\nğ•œ' : Type u_1\ninstâœÂ² : NormedField ğ•œ'\ninstâœÂ¹ : NormedSpace ğ•œ' G\ninstâœ : SMulCommClass ğ•œ ğ•œ' G\nc : ğ•œ'\nf : ContinuousMultilinearMap ğ•œ E G\nâŠ¢ LE.le (Norm.norm (HSMul.hSMul c f)) (HMul.hMul (Norm.norm c) (Norm.norm f))","decl":"theorem opNorm_smul_le (c : ğ•œ') (f : ContinuousMultilinearMap ğ•œ E G) : â€–c â€¢ fâ€– â‰¤ â€–câ€– * â€–fâ€– :=\n  (c â€¢ f).opNorm_le_bound (mul_nonneg (norm_nonneg _) (opNorm_nonneg _)) fun m â†¦ by\n    rw [smul_apply, norm_smul, mul_assoc]\n    exact mul_le_mul_of_nonneg_left (le_opNorm _ _) (norm_nonneg _)\n\n"}
{"name":"ContinuousMultilinearMap.opNorm_neg","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"ğ•œ : Type u\nÎ¹ : Type v\nE : Î¹ â†’ Type wE\nG : Type wG\ninstâœâµ : NontriviallyNormedField ğ•œ\ninstâœâ´ : (i : Î¹) â†’ SeminormedAddCommGroup (E i)\ninstâœÂ³ : (i : Î¹) â†’ NormedSpace ğ•œ (E i)\ninstâœÂ² : SeminormedAddCommGroup G\ninstâœÂ¹ : NormedSpace ğ•œ G\ninstâœ : Fintype Î¹\nf : ContinuousMultilinearMap ğ•œ E G\nâŠ¢ Eq (Norm.norm (Neg.neg f)) (Norm.norm f)","decl":"@[deprecated norm_neg (since := \"2024-11-24\")]\ntheorem opNorm_neg (f : ContinuousMultilinearMap ğ•œ E G) : â€–-fâ€– = â€–fâ€– := norm_neg f\n\n"}
{"name":"ContinuousMultilinearMap.le_opNNNorm","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"ğ•œ : Type u\nÎ¹ : Type v\nE : Î¹ â†’ Type wE\nG : Type wG\ninstâœâµ : NontriviallyNormedField ğ•œ\ninstâœâ´ : (i : Î¹) â†’ SeminormedAddCommGroup (E i)\ninstâœÂ³ : (i : Î¹) â†’ NormedSpace ğ•œ (E i)\ninstâœÂ² : SeminormedAddCommGroup G\ninstâœÂ¹ : NormedSpace ğ•œ G\ninstâœ : Fintype Î¹\nf : ContinuousMultilinearMap ğ•œ E G\nm : (i : Î¹) â†’ E i\nâŠ¢ LE.le (NNNorm.nnnorm (f m)) (HMul.hMul (NNNorm.nnnorm f) (Finset.univ.prod fun i => NNNorm.nnnorm (m i)))","decl":"/-- The fundamental property of the operator norm of a continuous multilinear map:\n`â€–f mâ€–` is bounded by `â€–fâ€–` times the product of the `â€–m iâ€–`, `nnnorm` version. -/\ntheorem le_opNNNorm (f : ContinuousMultilinearMap ğ•œ E G) (m : âˆ€ i, E i) :\n    â€–f mâ€–â‚Š â‰¤ â€–fâ€–â‚Š * âˆ i, â€–m iâ€–â‚Š :=\n  NNReal.coe_le_coe.1 <| by\n    push_cast\n    exact f.le_opNorm m\n\n"}
{"name":"ContinuousMultilinearMap.le_of_opNNNorm_le","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"ğ•œ : Type u\nÎ¹ : Type v\nE : Î¹ â†’ Type wE\nG : Type wG\ninstâœâµ : NontriviallyNormedField ğ•œ\ninstâœâ´ : (i : Î¹) â†’ SeminormedAddCommGroup (E i)\ninstâœÂ³ : (i : Î¹) â†’ NormedSpace ğ•œ (E i)\ninstâœÂ² : SeminormedAddCommGroup G\ninstâœÂ¹ : NormedSpace ğ•œ G\ninstâœ : Fintype Î¹\nf : ContinuousMultilinearMap ğ•œ E G\nC : NNReal\nh : LE.le (NNNorm.nnnorm f) C\nm : (i : Î¹) â†’ E i\nâŠ¢ LE.le (NNNorm.nnnorm (f m)) (HMul.hMul C (Finset.univ.prod fun i => NNNorm.nnnorm (m i)))","decl":"theorem le_of_opNNNorm_le (f : ContinuousMultilinearMap ğ•œ E G)\n    {C : â„â‰¥0} (h : â€–fâ€–â‚Š â‰¤ C) (m : âˆ€ i, E i) : â€–f mâ€–â‚Š â‰¤ C * âˆ i, â€–m iâ€–â‚Š :=\n  (f.le_opNNNorm m).trans <| mul_le_mul' h le_rfl\n\n"}
{"name":"ContinuousMultilinearMap.opNNNorm_le_iff","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"ğ•œ : Type u\nÎ¹ : Type v\nE : Î¹ â†’ Type wE\nG : Type wG\ninstâœâµ : NontriviallyNormedField ğ•œ\ninstâœâ´ : (i : Î¹) â†’ SeminormedAddCommGroup (E i)\ninstâœÂ³ : (i : Î¹) â†’ NormedSpace ğ•œ (E i)\ninstâœÂ² : SeminormedAddCommGroup G\ninstâœÂ¹ : NormedSpace ğ•œ G\ninstâœ : Fintype Î¹\nf : ContinuousMultilinearMap ğ•œ E G\nC : NNReal\nâŠ¢ Iff (LE.le (NNNorm.nnnorm f) C) (âˆ€ (m : (i : Î¹) â†’ E i), LE.le (NNNorm.nnnorm (f m)) (HMul.hMul C (Finset.univ.prod fun i => NNNorm.nnnorm (m i))))","decl":"theorem opNNNorm_le_iff {f : ContinuousMultilinearMap ğ•œ E G} {C : â„â‰¥0} :\n    â€–fâ€–â‚Š â‰¤ C â†” âˆ€ m, â€–f mâ€–â‚Š â‰¤ C * âˆ i, â€–m iâ€–â‚Š := by\n  simp only [â† NNReal.coe_le_coe]; simp [opNorm_le_iff C.coe_nonneg, NNReal.coe_prod]\n\n"}
{"name":"ContinuousMultilinearMap.isLeast_opNNNorm","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"ğ•œ : Type u\nÎ¹ : Type v\nE : Î¹ â†’ Type wE\nG : Type wG\ninstâœâµ : NontriviallyNormedField ğ•œ\ninstâœâ´ : (i : Î¹) â†’ SeminormedAddCommGroup (E i)\ninstâœÂ³ : (i : Î¹) â†’ NormedSpace ğ•œ (E i)\ninstâœÂ² : SeminormedAddCommGroup G\ninstâœÂ¹ : NormedSpace ğ•œ G\ninstâœ : Fintype Î¹\nf : ContinuousMultilinearMap ğ•œ E G\nâŠ¢ IsLeast (setOf fun C => âˆ€ (m : (i : Î¹) â†’ E i), LE.le (NNNorm.nnnorm (f m)) (HMul.hMul C (Finset.univ.prod fun i => NNNorm.nnnorm (m i)))) (NNNorm.nnnorm f)","decl":"theorem isLeast_opNNNorm (f : ContinuousMultilinearMap ğ•œ E G) :\n    IsLeast {C : â„â‰¥0 | âˆ€ m, â€–f mâ€–â‚Š â‰¤ C * âˆ i, â€–m iâ€–â‚Š} â€–fâ€–â‚Š := by\n  simpa only [â† opNNNorm_le_iff] using isLeast_Ici\n\n"}
{"name":"ContinuousMultilinearMap.opNNNorm_prod","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"ğ•œ : Type u\nÎ¹ : Type v\nE : Î¹ â†’ Type wE\nG : Type wG\nG' : Type wG'\ninstâœâ· : NontriviallyNormedField ğ•œ\ninstâœâ¶ : (i : Î¹) â†’ SeminormedAddCommGroup (E i)\ninstâœâµ : (i : Î¹) â†’ NormedSpace ğ•œ (E i)\ninstâœâ´ : SeminormedAddCommGroup G\ninstâœÂ³ : NormedSpace ğ•œ G\ninstâœÂ² : SeminormedAddCommGroup G'\ninstâœÂ¹ : NormedSpace ğ•œ G'\ninstâœ : Fintype Î¹\nf : ContinuousMultilinearMap ğ•œ E G\ng : ContinuousMultilinearMap ğ•œ E G'\nâŠ¢ Eq (NNNorm.nnnorm (f.prod g)) (Max.max (NNNorm.nnnorm f) (NNNorm.nnnorm g))","decl":"theorem opNNNorm_prod (f : ContinuousMultilinearMap ğ•œ E G) (g : ContinuousMultilinearMap ğ•œ E G') :\n    â€–f.prod gâ€–â‚Š = max â€–fâ€–â‚Š â€–gâ€–â‚Š :=\n  eq_of_forall_ge_iff fun _ â†¦ by\n    simp only [opNNNorm_le_iff, prod_apply, Prod.nnnorm_def, max_le_iff, forall_and]\n\n"}
{"name":"ContinuousMultilinearMap.opNorm_prod","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"ğ•œ : Type u\nÎ¹ : Type v\nE : Î¹ â†’ Type wE\nG : Type wG\nG' : Type wG'\ninstâœâ· : NontriviallyNormedField ğ•œ\ninstâœâ¶ : (i : Î¹) â†’ SeminormedAddCommGroup (E i)\ninstâœâµ : (i : Î¹) â†’ NormedSpace ğ•œ (E i)\ninstâœâ´ : SeminormedAddCommGroup G\ninstâœÂ³ : NormedSpace ğ•œ G\ninstâœÂ² : SeminormedAddCommGroup G'\ninstâœÂ¹ : NormedSpace ğ•œ G'\ninstâœ : Fintype Î¹\nf : ContinuousMultilinearMap ğ•œ E G\ng : ContinuousMultilinearMap ğ•œ E G'\nâŠ¢ Eq (Norm.norm (f.prod g)) (Max.max (Norm.norm f) (Norm.norm g))","decl":"theorem opNorm_prod (f : ContinuousMultilinearMap ğ•œ E G) (g : ContinuousMultilinearMap ğ•œ E G') :\n    â€–f.prod gâ€– = max â€–fâ€– â€–gâ€– :=\n  congr_arg NNReal.toReal (opNNNorm_prod f g)\n\n"}
{"name":"ContinuousMultilinearMap.opNNNorm_pi","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"ğ•œ : Type u\nÎ¹ : Type v\nÎ¹' : Type v'\nE : Î¹ â†’ Type wE\nE' : Î¹' â†’ Type wE'\ninstâœâ¶ : Fintype Î¹'\ninstâœâµ : NontriviallyNormedField ğ•œ\ninstâœâ´ : (i : Î¹) â†’ SeminormedAddCommGroup (E i)\ninstâœÂ³ : (i : Î¹) â†’ NormedSpace ğ•œ (E i)\ninstâœÂ² : Fintype Î¹\ninstâœÂ¹ : (i' : Î¹') â†’ SeminormedAddCommGroup (E' i')\ninstâœ : (i' : Î¹') â†’ NormedSpace ğ•œ (E' i')\nf : (i' : Î¹') â†’ ContinuousMultilinearMap ğ•œ E (E' i')\nâŠ¢ Eq (NNNorm.nnnorm (ContinuousMultilinearMap.pi f)) (NNNorm.nnnorm f)","decl":"theorem opNNNorm_pi\n    [âˆ€ i', SeminormedAddCommGroup (E' i')] [âˆ€ i', NormedSpace ğ•œ (E' i')]\n    (f : âˆ€ i', ContinuousMultilinearMap ğ•œ E (E' i')) : â€–pi fâ€–â‚Š = â€–fâ€–â‚Š :=\n  eq_of_forall_ge_iff fun _ â†¦ by simpa [opNNNorm_le_iff, pi_nnnorm_le_iff] using forall_swap\n\n"}
{"name":"ContinuousMultilinearMap.opNorm_pi","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"ğ•œ : Type u\nÎ¹ : Type v\nE : Î¹ â†’ Type wE\ninstâœâ¶ : NontriviallyNormedField ğ•œ\ninstâœâµ : (i : Î¹) â†’ SeminormedAddCommGroup (E i)\ninstâœâ´ : (i : Î¹) â†’ NormedSpace ğ•œ (E i)\ninstâœÂ³ : Fintype Î¹\nÎ¹' : Type v'\ninstâœÂ² : Fintype Î¹'\nE' : Î¹' â†’ Type wE'\ninstâœÂ¹ : (i' : Î¹') â†’ SeminormedAddCommGroup (E' i')\ninstâœ : (i' : Î¹') â†’ NormedSpace ğ•œ (E' i')\nf : (i' : Î¹') â†’ ContinuousMultilinearMap ğ•œ E (E' i')\nâŠ¢ Eq (Norm.norm (ContinuousMultilinearMap.pi f)) (Norm.norm f)","decl":"theorem opNorm_pi {Î¹' : Type v'} [Fintype Î¹'] {E' : Î¹' â†’ Type wE'}\n    [âˆ€ i', SeminormedAddCommGroup (E' i')] [âˆ€ i', NormedSpace ğ•œ (E' i')]\n    (f : âˆ€ i', ContinuousMultilinearMap ğ•œ E (E' i')) :\n    â€–pi fâ€– = â€–fâ€– :=\n  congr_arg NNReal.toReal (opNNNorm_pi f)\n\n"}
{"name":"ContinuousMultilinearMap.norm_ofSubsingleton","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"ğ•œ : Type u\nÎ¹ : Type v\nG : Type wG\nG' : Type wG'\ninstâœâ¶ : NontriviallyNormedField ğ•œ\ninstâœâµ : SeminormedAddCommGroup G\ninstâœâ´ : NormedSpace ğ•œ G\ninstâœÂ³ : SeminormedAddCommGroup G'\ninstâœÂ² : NormedSpace ğ•œ G'\ninstâœÂ¹ : Fintype Î¹\ninstâœ : Subsingleton Î¹\ni : Î¹\nf : ContinuousLinearMap (RingHom.id ğ•œ) G G'\nâŠ¢ Eq (Norm.norm ((ContinuousMultilinearMap.ofSubsingleton ğ•œ G G' i) f)) (Norm.norm f)","decl":"@[simp]\ntheorem norm_ofSubsingleton [Subsingleton Î¹] (i : Î¹) (f : G â†’L[ğ•œ] G') :\n    â€–ofSubsingleton ğ•œ G G' i fâ€– = â€–fâ€– := by\n  letI : Unique Î¹ := uniqueOfSubsingleton i\n  simp [norm_def, ContinuousLinearMap.norm_def, (Equiv.funUnique _ _).symm.surjective.forall]\n\n"}
{"name":"ContinuousMultilinearMap.nnnorm_ofSubsingleton","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"ğ•œ : Type u\nÎ¹ : Type v\nG : Type wG\nG' : Type wG'\ninstâœâ¶ : NontriviallyNormedField ğ•œ\ninstâœâµ : SeminormedAddCommGroup G\ninstâœâ´ : NormedSpace ğ•œ G\ninstâœÂ³ : SeminormedAddCommGroup G'\ninstâœÂ² : NormedSpace ğ•œ G'\ninstâœÂ¹ : Fintype Î¹\ninstâœ : Subsingleton Î¹\ni : Î¹\nf : ContinuousLinearMap (RingHom.id ğ•œ) G G'\nâŠ¢ Eq (NNNorm.nnnorm ((ContinuousMultilinearMap.ofSubsingleton ğ•œ G G' i) f)) (NNNorm.nnnorm f)","decl":"@[simp]\ntheorem nnnorm_ofSubsingleton [Subsingleton Î¹] (i : Î¹) (f : G â†’L[ğ•œ] G') :\n    â€–ofSubsingleton ğ•œ G G' i fâ€–â‚Š = â€–fâ€–â‚Š :=\n  NNReal.eq <| norm_ofSubsingleton i f\n\n"}
{"name":"ContinuousMultilinearMap.ofSubsingletonâ‚—áµ¢_apply","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"ğ•œ : Type u\nÎ¹ : Type v\nG : Type wG\nG' : Type wG'\ninstâœâ¶ : NontriviallyNormedField ğ•œ\ninstâœâµ : SeminormedAddCommGroup G\ninstâœâ´ : NormedSpace ğ•œ G\ninstâœÂ³ : SeminormedAddCommGroup G'\ninstâœÂ² : NormedSpace ğ•œ G'\ninstâœÂ¹ : Fintype Î¹\ninstâœ : Subsingleton Î¹\ni : Î¹\naâœ : ContinuousLinearMap (RingHom.id ğ•œ) G G'\nâŠ¢ Eq ((ContinuousMultilinearMap.ofSubsingletonâ‚—áµ¢ ğ•œ G i) aâœ) ((ContinuousMultilinearMap.ofSubsingleton ğ•œ G G' i).toFun aâœ)","decl":"/-- Linear isometry between continuous linear maps from `G` to `G'`\nand continuous `1`-multilinear maps from `G` to `G'`. -/\n@[simps apply symm_apply]\ndef ofSubsingletonâ‚—áµ¢ [Subsingleton Î¹] (i : Î¹) :\n    (G â†’L[ğ•œ] G') â‰ƒâ‚—áµ¢[ğ•œ] ContinuousMultilinearMap ğ•œ (fun _ : Î¹ â†¦ G) G' :=\n  { ofSubsingleton ğ•œ G G' i with\n    map_add' := fun _ _ â†¦ rfl\n    map_smul' := fun _ _ â†¦ rfl\n    norm_map' := norm_ofSubsingleton i }\n\n"}
{"name":"ContinuousMultilinearMap.ofSubsingletonâ‚—áµ¢_symm_apply","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"ğ•œ : Type u\nÎ¹ : Type v\nG : Type wG\nG' : Type wG'\ninstâœâ¶ : NontriviallyNormedField ğ•œ\ninstâœâµ : SeminormedAddCommGroup G\ninstâœâ´ : NormedSpace ğ•œ G\ninstâœÂ³ : SeminormedAddCommGroup G'\ninstâœÂ² : NormedSpace ğ•œ G'\ninstâœÂ¹ : Fintype Î¹\ninstâœ : Subsingleton Î¹\ni : Î¹\naâœ : ContinuousMultilinearMap ğ•œ (fun x => G) G'\nâŠ¢ Eq ((ContinuousMultilinearMap.ofSubsingletonâ‚—áµ¢ ğ•œ G i).symm aâœ) ((ContinuousMultilinearMap.ofSubsingleton ğ•œ G G' i).invFun aâœ)","decl":"/-- Linear isometry between continuous linear maps from `G` to `G'`\nand continuous `1`-multilinear maps from `G` to `G'`. -/\n@[simps apply symm_apply]\ndef ofSubsingletonâ‚—áµ¢ [Subsingleton Î¹] (i : Î¹) :\n    (G â†’L[ğ•œ] G') â‰ƒâ‚—áµ¢[ğ•œ] ContinuousMultilinearMap ğ•œ (fun _ : Î¹ â†¦ G) G' :=\n  { ofSubsingleton ğ•œ G G' i with\n    map_add' := fun _ _ â†¦ rfl\n    map_smul' := fun _ _ â†¦ rfl\n    norm_map' := norm_ofSubsingleton i }\n\n"}
{"name":"ContinuousMultilinearMap.norm_ofSubsingleton_id_le","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"ğ•œ : Type u\nÎ¹ : Type v\nG : Type wG\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : SeminormedAddCommGroup G\ninstâœÂ² : NormedSpace ğ•œ G\ninstâœÂ¹ : Fintype Î¹\ninstâœ : Subsingleton Î¹\ni : Î¹\nâŠ¢ LE.le (Norm.norm ((ContinuousMultilinearMap.ofSubsingleton ğ•œ G G i) (ContinuousLinearMap.id ğ•œ G))) 1","decl":"theorem norm_ofSubsingleton_id_le [Subsingleton Î¹] (i : Î¹) :\n    â€–ofSubsingleton ğ•œ G G i (.id _ _)â€– â‰¤ 1 := by\n  rw [norm_ofSubsingleton]\n  apply ContinuousLinearMap.norm_id_le\n\n"}
{"name":"ContinuousMultilinearMap.nnnorm_ofSubsingleton_id_le","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"ğ•œ : Type u\nÎ¹ : Type v\nG : Type wG\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : SeminormedAddCommGroup G\ninstâœÂ² : NormedSpace ğ•œ G\ninstâœÂ¹ : Fintype Î¹\ninstâœ : Subsingleton Î¹\ni : Î¹\nâŠ¢ LE.le (NNNorm.nnnorm ((ContinuousMultilinearMap.ofSubsingleton ğ•œ G G i) (ContinuousLinearMap.id ğ•œ G))) 1","decl":"theorem nnnorm_ofSubsingleton_id_le [Subsingleton Î¹] (i : Î¹) :\n    â€–ofSubsingleton ğ•œ G G i (.id _ _)â€–â‚Š â‰¤ 1 :=\n  norm_ofSubsingleton_id_le _ _ _\n\n"}
{"name":"ContinuousMultilinearMap.norm_constOfIsEmpty","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"ğ•œ : Type u\nÎ¹ : Type v\nE : Î¹ â†’ Type wE\nG : Type wG\ninstâœâ¶ : NontriviallyNormedField ğ•œ\ninstâœâµ : (i : Î¹) â†’ SeminormedAddCommGroup (E i)\ninstâœâ´ : (i : Î¹) â†’ NormedSpace ğ•œ (E i)\ninstâœÂ³ : SeminormedAddCommGroup G\ninstâœÂ² : NormedSpace ğ•œ G\ninstâœÂ¹ : Fintype Î¹\ninstâœ : IsEmpty Î¹\nx : G\nâŠ¢ Eq (Norm.norm (ContinuousMultilinearMap.constOfIsEmpty ğ•œ E x)) (Norm.norm x)","decl":"@[simp]\ntheorem norm_constOfIsEmpty [IsEmpty Î¹] (x : G) : â€–constOfIsEmpty ğ•œ E xâ€– = â€–xâ€– := by\n  apply le_antisymm\n  Â· refine opNorm_le_bound (norm_nonneg _) fun x => ?_\n    rw [Fintype.prod_empty, mul_one, constOfIsEmpty_apply]\n  Â· simpa using (constOfIsEmpty ğ•œ E x).le_opNorm 0\n\n"}
{"name":"ContinuousMultilinearMap.nnnorm_constOfIsEmpty","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"ğ•œ : Type u\nÎ¹ : Type v\nE : Î¹ â†’ Type wE\nG : Type wG\ninstâœâ¶ : NontriviallyNormedField ğ•œ\ninstâœâµ : (i : Î¹) â†’ SeminormedAddCommGroup (E i)\ninstâœâ´ : (i : Î¹) â†’ NormedSpace ğ•œ (E i)\ninstâœÂ³ : SeminormedAddCommGroup G\ninstâœÂ² : NormedSpace ğ•œ G\ninstâœÂ¹ : Fintype Î¹\ninstâœ : IsEmpty Î¹\nx : G\nâŠ¢ Eq (NNNorm.nnnorm (ContinuousMultilinearMap.constOfIsEmpty ğ•œ E x)) (NNNorm.nnnorm x)","decl":"@[simp]\ntheorem nnnorm_constOfIsEmpty [IsEmpty Î¹] (x : G) : â€–constOfIsEmpty ğ•œ E xâ€–â‚Š = â€–xâ€–â‚Š :=\n  NNReal.eq <| norm_constOfIsEmpty _ _ _\n\n"}
{"name":"ContinuousMultilinearMap.prodL_apply","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"ğ•œ : Type u\nÎ¹ : Type v\nE : Î¹ â†’ Type wE\nG : Type wG\nG' : Type wG'\ninstâœâ· : NontriviallyNormedField ğ•œ\ninstâœâ¶ : (i : Î¹) â†’ SeminormedAddCommGroup (E i)\ninstâœâµ : (i : Î¹) â†’ NormedSpace ğ•œ (E i)\ninstâœâ´ : SeminormedAddCommGroup G\ninstâœÂ³ : NormedSpace ğ•œ G\ninstâœÂ² : SeminormedAddCommGroup G'\ninstâœÂ¹ : NormedSpace ğ•œ G'\ninstâœ : Fintype Î¹\naâœ : Prod (ContinuousMultilinearMap ğ•œ E G) (ContinuousMultilinearMap ğ•œ E G')\nâŠ¢ Eq ((ContinuousMultilinearMap.prodL ğ•œ E G G') aâœ) (ContinuousMultilinearMap.prodEquiv.toFun aâœ)","decl":"/-- `ContinuousMultilinearMap.prod` as a `LinearIsometryEquiv`. -/\n@[simps]\ndef prodL :\n    ContinuousMultilinearMap ğ•œ E G Ã— ContinuousMultilinearMap ğ•œ E G' â‰ƒâ‚—áµ¢[ğ•œ]\n      ContinuousMultilinearMap ğ•œ E (G Ã— G') where\n  __ := prodEquiv\n  map_add' _ _ := rfl\n  map_smul' _ _ := rfl\n  norm_map' f := opNorm_prod f.1 f.2\n\n"}
{"name":"ContinuousMultilinearMap.prodL_symm_apply","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"ğ•œ : Type u\nÎ¹ : Type v\nE : Î¹ â†’ Type wE\nG : Type wG\nG' : Type wG'\ninstâœâ· : NontriviallyNormedField ğ•œ\ninstâœâ¶ : (i : Î¹) â†’ SeminormedAddCommGroup (E i)\ninstâœâµ : (i : Î¹) â†’ NormedSpace ğ•œ (E i)\ninstâœâ´ : SeminormedAddCommGroup G\ninstâœÂ³ : NormedSpace ğ•œ G\ninstâœÂ² : SeminormedAddCommGroup G'\ninstâœÂ¹ : NormedSpace ğ•œ G'\ninstâœ : Fintype Î¹\naâœ : ContinuousMultilinearMap ğ•œ E (Prod G G')\nâŠ¢ Eq ((ContinuousMultilinearMap.prodL ğ•œ E G G').symm aâœ) (ContinuousMultilinearMap.prodEquiv.invFun aâœ)","decl":"/-- `ContinuousMultilinearMap.prod` as a `LinearIsometryEquiv`. -/\n@[simps]\ndef prodL :\n    ContinuousMultilinearMap ğ•œ E G Ã— ContinuousMultilinearMap ğ•œ E G' â‰ƒâ‚—áµ¢[ğ•œ]\n      ContinuousMultilinearMap ğ•œ E (G Ã— G') where\n  __ := prodEquiv\n  map_add' _ _ := rfl\n  map_smul' _ _ := rfl\n  norm_map' f := opNorm_prod f.1 f.2\n\n"}
{"name":"ContinuousMultilinearMap.piâ‚—áµ¢_symm_apply","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"ğ•œ : Type u\nÎ¹ : Type v\nE : Î¹ â†’ Type wE\ninstâœâ¶ : NontriviallyNormedField ğ•œ\ninstâœâµ : (i : Î¹) â†’ SeminormedAddCommGroup (E i)\ninstâœâ´ : (i : Î¹) â†’ NormedSpace ğ•œ (E i)\ninstâœÂ³ : Fintype Î¹\nÎ¹' : Type v'\ninstâœÂ² : Fintype Î¹'\nE' : Î¹' â†’ Type wE'\ninstâœÂ¹ : (i' : Î¹') â†’ NormedAddCommGroup (E' i')\ninstâœ : (i' : Î¹') â†’ NormedSpace ğ•œ (E' i')\naâœ : ContinuousMultilinearMap ğ•œ E ((i : Î¹') â†’ E' i)\ni : Î¹'\nâŠ¢ Eq ((ContinuousMultilinearMap.piâ‚—áµ¢ ğ•œ E).symm aâœ i) ((ContinuousLinearMap.proj i).compContinuousMultilinearMap aâœ)","decl":"/-- `ContinuousMultilinearMap.pi` as a `LinearIsometryEquiv`. -/\n@[simps! apply symm_apply]\ndef piâ‚—áµ¢ {Î¹' : Type v'} [Fintype Î¹'] {E' : Î¹' â†’ Type wE'} [âˆ€ i', NormedAddCommGroup (E' i')]\n    [âˆ€ i', NormedSpace ğ•œ (E' i')] :\n    (Î  i', ContinuousMultilinearMap ğ•œ E (E' i'))\n      â‰ƒâ‚—áµ¢[ğ•œ] (ContinuousMultilinearMap ğ•œ E (Î  i, E' i)) where\n  toLinearEquiv := piLinearEquiv\n  norm_map' := opNorm_pi\n\n"}
{"name":"ContinuousMultilinearMap.piâ‚—áµ¢_apply","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"ğ•œ : Type u\nÎ¹ : Type v\nE : Î¹ â†’ Type wE\ninstâœâ¶ : NontriviallyNormedField ğ•œ\ninstâœâµ : (i : Î¹) â†’ SeminormedAddCommGroup (E i)\ninstâœâ´ : (i : Î¹) â†’ NormedSpace ğ•œ (E i)\ninstâœÂ³ : Fintype Î¹\nÎ¹' : Type v'\ninstâœÂ² : Fintype Î¹'\nE' : Î¹' â†’ Type wE'\ninstâœÂ¹ : (i' : Î¹') â†’ NormedAddCommGroup (E' i')\ninstâœ : (i' : Î¹') â†’ NormedSpace ğ•œ (E' i')\naâœ : (i : Î¹') â†’ ContinuousMultilinearMap ğ•œ E (E' i)\nâŠ¢ Eq ((ContinuousMultilinearMap.piâ‚—áµ¢ ğ•œ E) aâœ) (ContinuousMultilinearMap.pi aâœ)","decl":"/-- `ContinuousMultilinearMap.pi` as a `LinearIsometryEquiv`. -/\n@[simps! apply symm_apply]\ndef piâ‚—áµ¢ {Î¹' : Type v'} [Fintype Î¹'] {E' : Î¹' â†’ Type wE'} [âˆ€ i', NormedAddCommGroup (E' i')]\n    [âˆ€ i', NormedSpace ğ•œ (E' i')] :\n    (Î  i', ContinuousMultilinearMap ğ•œ E (E' i'))\n      â‰ƒâ‚—áµ¢[ğ•œ] (ContinuousMultilinearMap ğ•œ E (Î  i, E' i)) where\n  toLinearEquiv := piLinearEquiv\n  norm_map' := opNorm_pi\n\n"}
{"name":"ContinuousMultilinearMap.norm_restrictScalars","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"ğ•œ : Type u\nÎ¹ : Type v\nE : Î¹ â†’ Type wE\nG : Type wG\ninstâœÂ¹Â¹ : NontriviallyNormedField ğ•œ\ninstâœÂ¹â° : (i : Î¹) â†’ SeminormedAddCommGroup (E i)\ninstâœâ¹ : (i : Î¹) â†’ NormedSpace ğ•œ (E i)\ninstâœâ¸ : SeminormedAddCommGroup G\ninstâœâ· : NormedSpace ğ•œ G\ninstâœâ¶ : Fintype Î¹\nğ•œ' : Type u_1\ninstâœâµ : NontriviallyNormedField ğ•œ'\ninstâœâ´ : NormedAlgebra ğ•œ' ğ•œ\ninstâœÂ³ : NormedSpace ğ•œ' G\ninstâœÂ² : IsScalarTower ğ•œ' ğ•œ G\ninstâœÂ¹ : (i : Î¹) â†’ NormedSpace ğ•œ' (E i)\ninstâœ : âˆ€ (i : Î¹), IsScalarTower ğ•œ' ğ•œ (E i)\nf : ContinuousMultilinearMap ğ•œ E G\nâŠ¢ Eq (Norm.norm (ContinuousMultilinearMap.restrictScalars ğ•œ' f)) (Norm.norm f)","decl":"@[simp]\ntheorem norm_restrictScalars (f : ContinuousMultilinearMap ğ•œ E G) :\n    â€–f.restrictScalars ğ•œ'â€– = â€–fâ€– :=\n  rfl\n\n"}
{"name":"ContinuousMultilinearMap.norm_image_sub_le'","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"ğ•œ : Type u\nÎ¹ : Type v\nE : Î¹ â†’ Type wE\nG : Type wG\ninstâœâ¶ : NontriviallyNormedField ğ•œ\ninstâœâµ : (i : Î¹) â†’ SeminormedAddCommGroup (E i)\ninstâœâ´ : (i : Î¹) â†’ NormedSpace ğ•œ (E i)\ninstâœÂ³ : SeminormedAddCommGroup G\ninstâœÂ² : NormedSpace ğ•œ G\ninstâœÂ¹ : Fintype Î¹\ninstâœ : DecidableEq Î¹\nf : ContinuousMultilinearMap ğ•œ E G\nmâ‚ mâ‚‚ : (i : Î¹) â†’ E i\nâŠ¢ LE.le (Norm.norm (HSub.hSub (f mâ‚) (f mâ‚‚))) (HMul.hMul (Norm.norm f) (Finset.univ.sum fun i => Finset.univ.prod fun j => ite (Eq j i) (Norm.norm (HSub.hSub (mâ‚ i) (mâ‚‚ i))) (Max.max (Norm.norm (mâ‚ j)) (Norm.norm (mâ‚‚ j)))))","decl":"/-- The difference `f mâ‚ - f mâ‚‚` is controlled in terms of `â€–fâ€–` and `â€–mâ‚ - mâ‚‚â€–`, precise version.\nFor a less precise but more usable version, see `norm_image_sub_le`. The bound reads\n`â€–f m - f m'â€– â‰¤\n  â€–fâ€– * â€–m 1 - m' 1â€– * max â€–m 2â€– â€–m' 2â€– * max â€–m 3â€– â€–m' 3â€– * ... * max â€–m nâ€– â€–m' nâ€– + ...`,\nwhere the other terms in the sum are the same products where `1` is replaced by any `i`. -/\ntheorem norm_image_sub_le' [DecidableEq Î¹] (f : ContinuousMultilinearMap ğ•œ E G) (mâ‚ mâ‚‚ : âˆ€ i, E i) :\n    â€–f mâ‚ - f mâ‚‚â€– â‰¤ â€–fâ€– * âˆ‘ i, âˆ j, if j = i then â€–mâ‚ i - mâ‚‚ iâ€– else max â€–mâ‚ jâ€– â€–mâ‚‚ jâ€– :=\n  f.toMultilinearMap.norm_image_sub_le_of_bound' (norm_nonneg _) f.le_opNorm _ _\n\n"}
{"name":"ContinuousMultilinearMap.norm_image_sub_le","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"ğ•œ : Type u\nÎ¹ : Type v\nE : Î¹ â†’ Type wE\nG : Type wG\ninstâœâµ : NontriviallyNormedField ğ•œ\ninstâœâ´ : (i : Î¹) â†’ SeminormedAddCommGroup (E i)\ninstâœÂ³ : (i : Î¹) â†’ NormedSpace ğ•œ (E i)\ninstâœÂ² : SeminormedAddCommGroup G\ninstâœÂ¹ : NormedSpace ğ•œ G\ninstâœ : Fintype Î¹\nf : ContinuousMultilinearMap ğ•œ E G\nmâ‚ mâ‚‚ : (i : Î¹) â†’ E i\nâŠ¢ LE.le (Norm.norm (HSub.hSub (f mâ‚) (f mâ‚‚))) (HMul.hMul (HMul.hMul (HMul.hMul (Norm.norm f) â†‘(Fintype.card Î¹)) (HPow.hPow (Max.max (Norm.norm mâ‚) (Norm.norm mâ‚‚)) (HSub.hSub (Fintype.card Î¹) 1))) (Norm.norm (HSub.hSub mâ‚ mâ‚‚)))","decl":"/-- The difference `f mâ‚ - f mâ‚‚` is controlled in terms of `â€–fâ€–` and `â€–mâ‚ - mâ‚‚â€–`, less precise\nversion. For a more precise but less usable version, see `norm_image_sub_le'`.\nThe bound is `â€–f m - f m'â€– â‰¤ â€–fâ€– * card Î¹ * â€–m - m'â€– * (max â€–mâ€– â€–m'â€–) ^ (card Î¹ - 1)`. -/\ntheorem norm_image_sub_le (f : ContinuousMultilinearMap ğ•œ E G) (mâ‚ mâ‚‚ : âˆ€ i, E i) :\n    â€–f mâ‚ - f mâ‚‚â€– â‰¤ â€–fâ€– * Fintype.card Î¹ * max â€–mâ‚â€– â€–mâ‚‚â€– ^ (Fintype.card Î¹ - 1) * â€–mâ‚ - mâ‚‚â€– :=\n  f.toMultilinearMap.norm_image_sub_le_of_bound (norm_nonneg _) f.le_opNorm _ _\n\n"}
{"name":"MultilinearMap.mkContinuous_norm_le","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"ğ•œ : Type u\nÎ¹ : Type v\nE : Î¹ â†’ Type wE\nG : Type wG\ninstâœâµ : NontriviallyNormedField ğ•œ\ninstâœâ´ : (i : Î¹) â†’ SeminormedAddCommGroup (E i)\ninstâœÂ³ : (i : Î¹) â†’ NormedSpace ğ•œ (E i)\ninstâœÂ² : SeminormedAddCommGroup G\ninstâœÂ¹ : NormedSpace ğ•œ G\ninstâœ : Fintype Î¹\nf : MultilinearMap ğ•œ E G\nC : Real\nhC : LE.le 0 C\nH : âˆ€ (m : (i : Î¹) â†’ E i), LE.le (Norm.norm (f m)) (HMul.hMul C (Finset.univ.prod fun i => Norm.norm (m i)))\nâŠ¢ LE.le (Norm.norm (f.mkContinuous C H)) C","decl":"/-- If a continuous multilinear map is constructed from a multilinear map via the constructor\n`mkContinuous`, then its norm is bounded by the bound given to the constructor if it is\nnonnegative. -/\ntheorem MultilinearMap.mkContinuous_norm_le (f : MultilinearMap ğ•œ E G) {C : â„} (hC : 0 â‰¤ C)\n    (H : âˆ€ m, â€–f mâ€– â‰¤ C * âˆ i, â€–m iâ€–) : â€–f.mkContinuous C Hâ€– â‰¤ C :=\n  ContinuousMultilinearMap.opNorm_le_bound hC fun m => H m\n\n"}
{"name":"MultilinearMap.mkContinuous_norm_le'","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"ğ•œ : Type u\nÎ¹ : Type v\nE : Î¹ â†’ Type wE\nG : Type wG\ninstâœâµ : NontriviallyNormedField ğ•œ\ninstâœâ´ : (i : Î¹) â†’ SeminormedAddCommGroup (E i)\ninstâœÂ³ : (i : Î¹) â†’ NormedSpace ğ•œ (E i)\ninstâœÂ² : SeminormedAddCommGroup G\ninstâœÂ¹ : NormedSpace ğ•œ G\ninstâœ : Fintype Î¹\nf : MultilinearMap ğ•œ E G\nC : Real\nH : âˆ€ (m : (i : Î¹) â†’ E i), LE.le (Norm.norm (f m)) (HMul.hMul C (Finset.univ.prod fun i => Norm.norm (m i)))\nâŠ¢ LE.le (Norm.norm (f.mkContinuous C H)) (Max.max C 0)","decl":"/-- If a continuous multilinear map is constructed from a multilinear map via the constructor\n`mkContinuous`, then its norm is bounded by the bound given to the constructor if it is\nnonnegative. -/\ntheorem MultilinearMap.mkContinuous_norm_le' (f : MultilinearMap ğ•œ E G) {C : â„}\n    (H : âˆ€ m, â€–f mâ€– â‰¤ C * âˆ i, â€–m iâ€–) : â€–f.mkContinuous C Hâ€– â‰¤ max C 0 :=\n  ContinuousMultilinearMap.opNorm_le_bound (le_max_right _ _) fun m â†¦ (H m).trans <|\n    mul_le_mul_of_nonneg_right (le_max_left _ _) <| by positivity\n\n"}
{"name":"ContinuousMultilinearMap.norm_restr","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"ğ•œ : Type u\nG : Type wG\nG' : Type wG'\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : SeminormedAddCommGroup G\ninstâœÂ² : NormedSpace ğ•œ G\ninstâœÂ¹ : SeminormedAddCommGroup G'\ninstâœ : NormedSpace ğ•œ G'\nk n : Nat\nf : ContinuousMultilinearMap ğ•œ (fun i => G) G'\ns : Finset (Fin n)\nhk : Eq s.card k\nz : G\nâŠ¢ LE.le (Norm.norm (f.restr s hk z)) (HMul.hMul (Norm.norm f) (HPow.hPow (Norm.norm z) (HSub.hSub n k)))","decl":"theorem norm_restr {k n : â„•} (f : G[Ã—n]â†’L[ğ•œ] G') (s : Finset (Fin n)) (hk : #s = k) (z : G) :\n    â€–f.restr s hk zâ€– â‰¤ â€–fâ€– * â€–zâ€– ^ (n - k) := by\n  apply MultilinearMap.mkContinuous_norm_le\n  exact mul_nonneg (norm_nonneg _) (pow_nonneg (norm_nonneg _) _)\n\n"}
{"name":"ContinuousMultilinearMap.norm_mkPiAlgebra_le","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"ğ•œ : Type u\nÎ¹ : Type v\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : Fintype Î¹\nA : Type u_1\ninstâœÂ² : NormedCommRing A\ninstâœÂ¹ : NormedAlgebra ğ•œ A\ninstâœ : Nonempty Î¹\nâŠ¢ LE.le (Norm.norm (ContinuousMultilinearMap.mkPiAlgebra ğ•œ Î¹ A)) 1","decl":"@[simp]\ntheorem norm_mkPiAlgebra_le [Nonempty Î¹] : â€–ContinuousMultilinearMap.mkPiAlgebra ğ•œ Î¹ Aâ€– â‰¤ 1 := by\n  refine opNorm_le_bound zero_le_one fun m => ?_\n  simp only [ContinuousMultilinearMap.mkPiAlgebra_apply, one_mul]\n  exact norm_prod_le' _ univ_nonempty _\n\n"}
{"name":"ContinuousMultilinearMap.norm_mkPiAlgebra_of_empty","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"ğ•œ : Type u\nÎ¹ : Type v\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : Fintype Î¹\nA : Type u_1\ninstâœÂ² : NormedCommRing A\ninstâœÂ¹ : NormedAlgebra ğ•œ A\ninstâœ : IsEmpty Î¹\nâŠ¢ Eq (Norm.norm (ContinuousMultilinearMap.mkPiAlgebra ğ•œ Î¹ A)) (Norm.norm 1)","decl":"theorem norm_mkPiAlgebra_of_empty [IsEmpty Î¹] :\n    â€–ContinuousMultilinearMap.mkPiAlgebra ğ•œ Î¹ Aâ€– = â€–(1 : A)â€– := by\n  apply le_antisymm\n  Â· apply opNorm_le_bound <;> simp\n  Â· -- Porting note: have to annotate types to get mvars to unify\n    convert ratio_le_opNorm (ContinuousMultilinearMap.mkPiAlgebra ğ•œ Î¹ A) fun _ => (1 : A)\n    simp [eq_empty_of_isEmpty (univ : Finset Î¹)]\n\n"}
{"name":"ContinuousMultilinearMap.norm_mkPiAlgebra","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"ğ•œ : Type u\nÎ¹ : Type v\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : Fintype Î¹\nA : Type u_1\ninstâœÂ² : NormedCommRing A\ninstâœÂ¹ : NormedAlgebra ğ•œ A\ninstâœ : NormOneClass A\nâŠ¢ Eq (Norm.norm (ContinuousMultilinearMap.mkPiAlgebra ğ•œ Î¹ A)) 1","decl":"@[simp]\ntheorem norm_mkPiAlgebra [NormOneClass A] : â€–ContinuousMultilinearMap.mkPiAlgebra ğ•œ Î¹ Aâ€– = 1 := by\n  cases isEmpty_or_nonempty Î¹\n  Â· simp [norm_mkPiAlgebra_of_empty]\n  Â· refine le_antisymm norm_mkPiAlgebra_le ?_\n    convert ratio_le_opNorm (ContinuousMultilinearMap.mkPiAlgebra ğ•œ Î¹ A) fun _ => 1\n    simp\n\n"}
{"name":"ContinuousMultilinearMap.norm_mkPiAlgebraFin_succ_le","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"ğ•œ : Type u\ninstâœÂ² : NontriviallyNormedField ğ•œ\nn : Nat\nA : Type u_1\ninstâœÂ¹ : SeminormedRing A\ninstâœ : NormedAlgebra ğ•œ A\nâŠ¢ LE.le (Norm.norm (ContinuousMultilinearMap.mkPiAlgebraFin ğ•œ n.succ A)) 1","decl":"theorem norm_mkPiAlgebraFin_succ_le : â€–ContinuousMultilinearMap.mkPiAlgebraFin ğ•œ n.succ Aâ€– â‰¤ 1 := by\n  refine opNorm_le_bound zero_le_one fun m => ?_\n  simp only [ContinuousMultilinearMap.mkPiAlgebraFin_apply, one_mul, List.ofFn_eq_map,\n    Fin.prod_univ_def, Multiset.map_coe, Multiset.prod_coe]\n  refine (List.norm_prod_le' ?_).trans_eq ?_\n  Â· rw [Ne, List.map_eq_nil_iff, List.finRange_eq_nil]\n    exact Nat.succ_ne_zero _\n  rw [List.map_map, Function.comp_def]\n\n"}
{"name":"ContinuousMultilinearMap.norm_mkPiAlgebraFin_le_of_pos","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"ğ•œ : Type u\ninstâœÂ² : NontriviallyNormedField ğ•œ\nn : Nat\nA : Type u_1\ninstâœÂ¹ : SeminormedRing A\ninstâœ : NormedAlgebra ğ•œ A\nhn : LT.lt 0 n\nâŠ¢ LE.le (Norm.norm (ContinuousMultilinearMap.mkPiAlgebraFin ğ•œ n A)) 1","decl":"theorem norm_mkPiAlgebraFin_le_of_pos (hn : 0 < n) :\n    â€–ContinuousMultilinearMap.mkPiAlgebraFin ğ•œ n Aâ€– â‰¤ 1 := by\n  obtain âŸ¨n, rflâŸ© := Nat.exists_eq_succ_of_ne_zero hn.ne'\n  exact norm_mkPiAlgebraFin_succ_le\n\n"}
{"name":"ContinuousMultilinearMap.norm_mkPiAlgebraFin_zero","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"ğ•œ : Type u\ninstâœÂ² : NontriviallyNormedField ğ•œ\nA : Type u_1\ninstâœÂ¹ : SeminormedRing A\ninstâœ : NormedAlgebra ğ•œ A\nâŠ¢ Eq (Norm.norm (ContinuousMultilinearMap.mkPiAlgebraFin ğ•œ 0 A)) (Norm.norm 1)","decl":"theorem norm_mkPiAlgebraFin_zero : â€–ContinuousMultilinearMap.mkPiAlgebraFin ğ•œ 0 Aâ€– = â€–(1 : A)â€– := by\n  refine le_antisymm ?_ ?_\n  Â· refine opNorm_le_bound (norm_nonneg (1 : A)) ?_\n    simp\n  Â· convert ratio_le_opNorm (ContinuousMultilinearMap.mkPiAlgebraFin ğ•œ 0 A) fun _ => (1 : A)\n    simp\n\n"}
{"name":"ContinuousMultilinearMap.norm_mkPiAlgebraFin_le","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"ğ•œ : Type u\ninstâœÂ² : NontriviallyNormedField ğ•œ\nn : Nat\nA : Type u_1\ninstâœÂ¹ : SeminormedRing A\ninstâœ : NormedAlgebra ğ•œ A\nâŠ¢ LE.le (Norm.norm (ContinuousMultilinearMap.mkPiAlgebraFin ğ•œ n A)) (Max.max 1 (Norm.norm 1))","decl":"theorem norm_mkPiAlgebraFin_le :\n    â€–ContinuousMultilinearMap.mkPiAlgebraFin ğ•œ n Aâ€– â‰¤ max 1 â€–(1 : A)â€– := by\n  cases n\n  Â· exact norm_mkPiAlgebraFin_zero.le.trans (le_max_right _ _)\n  Â· exact (norm_mkPiAlgebraFin_le_of_pos (Nat.zero_lt_succ _)).trans (le_max_left _ _)\n\n"}
{"name":"ContinuousMultilinearMap.norm_mkPiAlgebraFin","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"ğ•œ : Type u\ninstâœÂ³ : NontriviallyNormedField ğ•œ\nn : Nat\nA : Type u_1\ninstâœÂ² : SeminormedRing A\ninstâœÂ¹ : NormedAlgebra ğ•œ A\ninstâœ : NormOneClass A\nâŠ¢ Eq (Norm.norm (ContinuousMultilinearMap.mkPiAlgebraFin ğ•œ n A)) 1","decl":"@[simp]\ntheorem norm_mkPiAlgebraFin [NormOneClass A] :\n    â€–ContinuousMultilinearMap.mkPiAlgebraFin ğ•œ n Aâ€– = 1 := by\n  cases n\n  Â· rw [norm_mkPiAlgebraFin_zero]\n    simp\n  Â· refine le_antisymm norm_mkPiAlgebraFin_succ_le ?_\n    refine le_of_eq_of_le ?_ <|\n      ratio_le_opNorm (ContinuousMultilinearMap.mkPiAlgebraFin ğ•œ (Nat.succ _) A) fun _ => 1\n    simp\n\n"}
{"name":"ContinuousMultilinearMap.nnnorm_smulRight","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"ğ•œ : Type u\nÎ¹ : Type v\nE : Î¹ â†’ Type wE\nG : Type wG\ninstâœâµ : NontriviallyNormedField ğ•œ\ninstâœâ´ : (i : Î¹) â†’ SeminormedAddCommGroup (E i)\ninstâœÂ³ : (i : Î¹) â†’ NormedSpace ğ•œ (E i)\ninstâœÂ² : SeminormedAddCommGroup G\ninstâœÂ¹ : NormedSpace ğ•œ G\ninstâœ : Fintype Î¹\nf : ContinuousMultilinearMap ğ•œ E ğ•œ\nz : G\nâŠ¢ Eq (NNNorm.nnnorm (f.smulRight z)) (HMul.hMul (NNNorm.nnnorm f) (NNNorm.nnnorm z))","decl":"@[simp]\ntheorem nnnorm_smulRight (f : ContinuousMultilinearMap ğ•œ E ğ•œ) (z : G) :\n    â€–f.smulRight zâ€–â‚Š = â€–fâ€–â‚Š * â€–zâ€–â‚Š := by\n  refine le_antisymm ?_ ?_\n  Â· refine opNNNorm_le_iff.2 fun m => (nnnorm_smul_le _ _).trans ?_\n    rw [mul_right_comm]\n    gcongr\n    exact le_opNNNorm _ _\n  Â· obtain hz | hz := eq_zero_or_pos â€–zâ€–â‚Š\n    Â· simp [hz]\n    rw [â† le_div_iffâ‚€ hz, opNNNorm_le_iff]\n    intro m\n    rw [div_mul_eq_mul_div, le_div_iffâ‚€ hz]\n    refine le_trans ?_ ((f.smulRight z).le_opNNNorm m)\n    rw [smulRight_apply, nnnorm_smul]\n\n"}
{"name":"ContinuousMultilinearMap.norm_smulRight","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"ğ•œ : Type u\nÎ¹ : Type v\nE : Î¹ â†’ Type wE\nG : Type wG\ninstâœâµ : NontriviallyNormedField ğ•œ\ninstâœâ´ : (i : Î¹) â†’ SeminormedAddCommGroup (E i)\ninstâœÂ³ : (i : Î¹) â†’ NormedSpace ğ•œ (E i)\ninstâœÂ² : SeminormedAddCommGroup G\ninstâœÂ¹ : NormedSpace ğ•œ G\ninstâœ : Fintype Î¹\nf : ContinuousMultilinearMap ğ•œ E ğ•œ\nz : G\nâŠ¢ Eq (Norm.norm (f.smulRight z)) (HMul.hMul (Norm.norm f) (Norm.norm z))","decl":"@[simp]\ntheorem norm_smulRight (f : ContinuousMultilinearMap ğ•œ E ğ•œ) (z : G) :\n    â€–f.smulRight zâ€– = â€–fâ€– * â€–zâ€– :=\n  congr_arg NNReal.toReal (nnnorm_smulRight f z)\n\n"}
{"name":"ContinuousMultilinearMap.norm_mkPiRing","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"ğ•œ : Type u\nÎ¹ : Type v\nG : Type wG\ninstâœÂ³ : NontriviallyNormedField ğ•œ\ninstâœÂ² : SeminormedAddCommGroup G\ninstâœÂ¹ : NormedSpace ğ•œ G\ninstâœ : Fintype Î¹\nz : G\nâŠ¢ Eq (Norm.norm (ContinuousMultilinearMap.mkPiRing ğ•œ Î¹ z)) (Norm.norm z)","decl":"@[simp]\ntheorem norm_mkPiRing (z : G) : â€–ContinuousMultilinearMap.mkPiRing ğ•œ Î¹ zâ€– = â€–zâ€– := by\n  rw [ContinuousMultilinearMap.mkPiRing, norm_smulRight, norm_mkPiAlgebra, one_mul]\n\n"}
{"name":"ContinuousMultilinearMap.smulRightL_apply","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"ğ•œ : Type u\nÎ¹ : Type v\nE : Î¹ â†’ Type wE\nG : Type wG\ninstâœâµ : NontriviallyNormedField ğ•œ\ninstâœâ´ : (i : Î¹) â†’ SeminormedAddCommGroup (E i)\ninstâœÂ³ : (i : Î¹) â†’ NormedSpace ğ•œ (E i)\ninstâœÂ² : SeminormedAddCommGroup G\ninstâœÂ¹ : NormedSpace ğ•œ G\ninstâœ : Fintype Î¹\nf : ContinuousMultilinearMap ğ•œ E ğ•œ\nz : G\nâŠ¢ Eq (((ContinuousMultilinearMap.smulRightL ğ•œ E G) f) z) (f.smulRight z)","decl":"@[simp] lemma smulRightL_apply (f : ContinuousMultilinearMap ğ•œ E ğ•œ) (z : G) :\n  smulRightL ğ•œ E G f z = f.smulRight z := rfl\n\n"}
{"name":"ContinuousMultilinearMap.norm_smulRightL_le","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"ğ•œ : Type u\nÎ¹ : Type v\nE : Î¹ â†’ Type wE\nG : Type wG\ninstâœâµ : NontriviallyNormedField ğ•œ\ninstâœâ´ : (i : Î¹) â†’ SeminormedAddCommGroup (E i)\ninstâœÂ³ : (i : Î¹) â†’ NormedSpace ğ•œ (E i)\ninstâœÂ² : SeminormedAddCommGroup G\ninstâœÂ¹ : NormedSpace ğ•œ G\ninstâœ : Fintype Î¹\nâŠ¢ LE.le (Norm.norm (ContinuousMultilinearMap.smulRightL ğ•œ E G)) 1","decl":"set_option maxSynthPendingDepth 2 in\nlemma norm_smulRightL_le : â€–smulRightL ğ•œ E Gâ€– â‰¤ 1 :=\n  LinearMap.mkContinuousâ‚‚_norm_le _ zero_le_one _\n\n"}
{"name":"ContinuousLinearMap.norm_compContinuousMultilinearMap_le","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"ğ•œ : Type u\nÎ¹ : Type v\nE : Î¹ â†’ Type wE\nG : Type wG\nG' : Type wG'\ninstâœâ· : NontriviallyNormedField ğ•œ\ninstâœâ¶ : (i : Î¹) â†’ SeminormedAddCommGroup (E i)\ninstâœâµ : (i : Î¹) â†’ NormedSpace ğ•œ (E i)\ninstâœâ´ : SeminormedAddCommGroup G\ninstâœÂ³ : NormedSpace ğ•œ G\ninstâœÂ² : SeminormedAddCommGroup G'\ninstâœÂ¹ : NormedSpace ğ•œ G'\ninstâœ : Fintype Î¹\ng : ContinuousLinearMap (RingHom.id ğ•œ) G G'\nf : ContinuousMultilinearMap ğ•œ E G\nâŠ¢ LE.le (Norm.norm (g.compContinuousMultilinearMap f)) (HMul.hMul (Norm.norm g) (Norm.norm f))","decl":"theorem norm_compContinuousMultilinearMap_le (g : G â†’L[ğ•œ] G') (f : ContinuousMultilinearMap ğ•œ E G) :\n    â€–g.compContinuousMultilinearMap fâ€– â‰¤ â€–gâ€– * â€–fâ€– :=\n  ContinuousMultilinearMap.opNorm_le_bound (by positivity) fun m â†¦\n    calc\n      â€–g (f m)â€– â‰¤ â€–gâ€– * (â€–fâ€– * âˆ i, â€–m iâ€–) := g.le_opNorm_of_le <| f.le_opNorm _\n      _ = _ := (mul_assoc _ _ _).symm\n\n"}
{"name":"ContinuousLinearEquiv.compContinuousMultilinearMapL_symm","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"ğ•œ : Type u\nÎ¹ : Type v\nE : Î¹ â†’ Type wE\nG : Type wG\nG' : Type wG'\ninstâœâ· : NontriviallyNormedField ğ•œ\ninstâœâ¶ : (i : Î¹) â†’ SeminormedAddCommGroup (E i)\ninstâœâµ : (i : Î¹) â†’ NormedSpace ğ•œ (E i)\ninstâœâ´ : SeminormedAddCommGroup G\ninstâœÂ³ : NormedSpace ğ•œ G\ninstâœÂ² : SeminormedAddCommGroup G'\ninstâœÂ¹ : NormedSpace ğ•œ G'\ninstâœ : Fintype Î¹\ng : ContinuousLinearEquiv (RingHom.id ğ•œ) G G'\nâŠ¢ Eq (ContinuousLinearEquiv.compContinuousMultilinearMapL E g).symm (ContinuousLinearEquiv.compContinuousMultilinearMapL E g.symm)","decl":"@[simp]\ntheorem _root_.ContinuousLinearEquiv.compContinuousMultilinearMapL_symm (g : G â‰ƒL[ğ•œ] G') :\n    (g.compContinuousMultilinearMapL E).symm = g.symm.compContinuousMultilinearMapL E :=\n  rfl\n\n"}
{"name":"ContinuousLinearEquiv.compContinuousMultilinearMapL_apply","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"ğ•œ : Type u\nÎ¹ : Type v\nE : Î¹ â†’ Type wE\nG : Type wG\nG' : Type wG'\ninstâœâ· : NontriviallyNormedField ğ•œ\ninstâœâ¶ : (i : Î¹) â†’ SeminormedAddCommGroup (E i)\ninstâœâµ : (i : Î¹) â†’ NormedSpace ğ•œ (E i)\ninstâœâ´ : SeminormedAddCommGroup G\ninstâœÂ³ : NormedSpace ğ•œ G\ninstâœÂ² : SeminormedAddCommGroup G'\ninstâœÂ¹ : NormedSpace ğ•œ G'\ninstâœ : Fintype Î¹\ng : ContinuousLinearEquiv (RingHom.id ğ•œ) G G'\nf : ContinuousMultilinearMap ğ•œ E G\nâŠ¢ Eq ((ContinuousLinearEquiv.compContinuousMultilinearMapL E g) f) ((â†‘g).compContinuousMultilinearMap f)","decl":"@[simp]\ntheorem _root_.ContinuousLinearEquiv.compContinuousMultilinearMapL_apply (g : G â‰ƒL[ğ•œ] G')\n    (f : ContinuousMultilinearMap ğ•œ E G) :\n    g.compContinuousMultilinearMapL E f = (g : G â†’L[ğ•œ] G').compContinuousMultilinearMap f :=\n  rfl\n\n"}
{"name":"ContinuousLinearMap.flipMultilinear_apply_apply","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"ğ•œ : Type u\nÎ¹ : Type v\nE : Î¹ â†’ Type wE\nG : Type wG\nG' : Type wG'\ninstâœâ· : NontriviallyNormedField ğ•œ\ninstâœâ¶ : (i : Î¹) â†’ SeminormedAddCommGroup (E i)\ninstâœâµ : (i : Î¹) â†’ NormedSpace ğ•œ (E i)\ninstâœâ´ : SeminormedAddCommGroup G\ninstâœÂ³ : NormedSpace ğ•œ G\ninstâœÂ² : SeminormedAddCommGroup G'\ninstâœÂ¹ : NormedSpace ğ•œ G'\ninstâœ : Fintype Î¹\nf : ContinuousLinearMap (RingHom.id ğ•œ) G (ContinuousMultilinearMap ğ•œ E G')\nm : (i : Î¹) â†’ E i\nx : G\nâŠ¢ Eq ((f.flipMultilinear m) x) ((f x) m)","decl":"/-- Flip arguments in `f : G â†’L[ğ•œ] ContinuousMultilinearMap ğ•œ E G'` to get\n`ContinuousMultilinearMap ğ•œ E (G â†’L[ğ•œ] G')` -/\n@[simps! apply_apply]\ndef flipMultilinear (f : G â†’L[ğ•œ] ContinuousMultilinearMap ğ•œ E G') :\n    ContinuousMultilinearMap ğ•œ E (G â†’L[ğ•œ] G') :=\n  MultilinearMap.mkContinuous\n    { toFun := fun m =>\n        LinearMap.mkContinuous\n          { toFun := fun x => f x m\n            map_add' := fun x y => by simp only [map_add, ContinuousMultilinearMap.add_apply]\n            map_smul' := fun c x => by\n              simp only [ContinuousMultilinearMap.smul_apply, map_smul, RingHom.id_apply] }\n          (â€–fâ€– * âˆ i, â€–m iâ€–) fun x => by\n          rw [mul_right_comm]\n          exact (f x).le_of_opNorm_le (f.le_opNorm x) _\n      map_update_add' := fun m i x y => by\n        ext1\n        simp only [add_apply, ContinuousMultilinearMap.map_update_add, LinearMap.coe_mk,\n          LinearMap.mkContinuous_apply, AddHom.coe_mk]\n      map_update_smul' := fun m i c x => by\n        ext1\n        simp only [coe_smul', ContinuousMultilinearMap.map_update_smul, LinearMap.coe_mk,\n          LinearMap.mkContinuous_apply, Pi.smul_apply, AddHom.coe_mk] }\n    â€–fâ€– fun m => by\n      dsimp only [MultilinearMap.coe_mk]\n      exact LinearMap.mkContinuous_norm_le _ (by positivity) _\n\n"}
{"name":"LinearIsometry.norm_compContinuousMultilinearMap","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"ğ•œ : Type u\nÎ¹ : Type v\nE : Î¹ â†’ Type wE\nG : Type wG\nG' : Type wG'\ninstâœâ· : NontriviallyNormedField ğ•œ\ninstâœâ¶ : (i : Î¹) â†’ SeminormedAddCommGroup (E i)\ninstâœâµ : (i : Î¹) â†’ NormedSpace ğ•œ (E i)\ninstâœâ´ : SeminormedAddCommGroup G\ninstâœÂ³ : NormedSpace ğ•œ G\ninstâœÂ² : SeminormedAddCommGroup G'\ninstâœÂ¹ : NormedSpace ğ•œ G'\ninstâœ : Fintype Î¹\ng : LinearIsometry (RingHom.id ğ•œ) G G'\nf : ContinuousMultilinearMap ğ•œ E G\nâŠ¢ Eq (Norm.norm (g.toContinuousLinearMap.compContinuousMultilinearMap f)) (Norm.norm f)","decl":"theorem LinearIsometry.norm_compContinuousMultilinearMap (g : G â†’â‚—áµ¢[ğ•œ] G')\n    (f : ContinuousMultilinearMap ğ•œ E G) :\n    â€–g.toContinuousLinearMap.compContinuousMultilinearMap fâ€– = â€–fâ€– := by\n  simp only [ContinuousLinearMap.compContinuousMultilinearMap_coe,\n    LinearIsometry.coe_toContinuousLinearMap, LinearIsometry.norm_map,\n    ContinuousMultilinearMap.norm_def, Function.comp_apply]\n\n"}
{"name":"MultilinearMap.mkContinuousLinear_norm_le'","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"ğ•œ : Type u\nÎ¹ : Type v\nE : Î¹ â†’ Type wE\nG : Type wG\nG' : Type wG'\ninstâœâ· : NontriviallyNormedField ğ•œ\ninstâœâ¶ : (i : Î¹) â†’ SeminormedAddCommGroup (E i)\ninstâœâµ : (i : Î¹) â†’ NormedSpace ğ•œ (E i)\ninstâœâ´ : SeminormedAddCommGroup G\ninstâœÂ³ : NormedSpace ğ•œ G\ninstâœÂ² : SeminormedAddCommGroup G'\ninstâœÂ¹ : NormedSpace ğ•œ G'\ninstâœ : Fintype Î¹\nf : LinearMap (RingHom.id ğ•œ) G (MultilinearMap ğ•œ E G')\nC : Real\nH : âˆ€ (x : G) (m : (i : Î¹) â†’ E i), LE.le (Norm.norm ((f x) m)) (HMul.hMul (HMul.hMul C (Norm.norm x)) (Finset.univ.prod fun i => Norm.norm (m i)))\nâŠ¢ LE.le (Norm.norm (MultilinearMap.mkContinuousLinear f C H)) (Max.max C 0)","decl":"theorem mkContinuousLinear_norm_le' (f : G â†’â‚—[ğ•œ] MultilinearMap ğ•œ E G') (C : â„)\n    (H : âˆ€ x m, â€–f x mâ€– â‰¤ C * â€–xâ€– * âˆ i, â€–m iâ€–) : â€–mkContinuousLinear f C Hâ€– â‰¤ max C 0 := by\n  dsimp only [mkContinuousLinear]\n  exact LinearMap.mkContinuous_norm_le _ (le_max_right _ _) _\n\n"}
{"name":"MultilinearMap.mkContinuousLinear_norm_le","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"ğ•œ : Type u\nÎ¹ : Type v\nE : Î¹ â†’ Type wE\nG : Type wG\nG' : Type wG'\ninstâœâ· : NontriviallyNormedField ğ•œ\ninstâœâ¶ : (i : Î¹) â†’ SeminormedAddCommGroup (E i)\ninstâœâµ : (i : Î¹) â†’ NormedSpace ğ•œ (E i)\ninstâœâ´ : SeminormedAddCommGroup G\ninstâœÂ³ : NormedSpace ğ•œ G\ninstâœÂ² : SeminormedAddCommGroup G'\ninstâœÂ¹ : NormedSpace ğ•œ G'\ninstâœ : Fintype Î¹\nf : LinearMap (RingHom.id ğ•œ) G (MultilinearMap ğ•œ E G')\nC : Real\nhC : LE.le 0 C\nH : âˆ€ (x : G) (m : (i : Î¹) â†’ E i), LE.le (Norm.norm ((f x) m)) (HMul.hMul (HMul.hMul C (Norm.norm x)) (Finset.univ.prod fun i => Norm.norm (m i)))\nâŠ¢ LE.le (Norm.norm (MultilinearMap.mkContinuousLinear f C H)) C","decl":"theorem mkContinuousLinear_norm_le (f : G â†’â‚—[ğ•œ] MultilinearMap ğ•œ E G') {C : â„} (hC : 0 â‰¤ C)\n    (H : âˆ€ x m, â€–f x mâ€– â‰¤ C * â€–xâ€– * âˆ i, â€–m iâ€–) : â€–mkContinuousLinear f C Hâ€– â‰¤ C :=\n  (mkContinuousLinear_norm_le' f C H).trans_eq (max_eq_left hC)\n\n"}
{"name":"MultilinearMap.mkContinuousMultilinear_apply","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"ğ•œ : Type u\nÎ¹ : Type v\nÎ¹' : Type v'\nE : Î¹ â†’ Type wE\nE' : Î¹' â†’ Type wE'\nG : Type wG\ninstâœâ¸ : Fintype Î¹'\ninstâœâ· : NontriviallyNormedField ğ•œ\ninstâœâ¶ : (i : Î¹) â†’ SeminormedAddCommGroup (E i)\ninstâœâµ : (i : Î¹) â†’ NormedSpace ğ•œ (E i)\ninstâœâ´ : SeminormedAddCommGroup G\ninstâœÂ³ : NormedSpace ğ•œ G\ninstâœÂ² : Fintype Î¹\ninstâœÂ¹ : (i : Î¹') â†’ SeminormedAddCommGroup (E' i)\ninstâœ : (i : Î¹') â†’ NormedSpace ğ•œ (E' i)\nf : MultilinearMap ğ•œ E (MultilinearMap ğ•œ E' G)\nC : Real\nH : âˆ€ (mâ‚ : (i : Î¹) â†’ E i) (mâ‚‚ : (i : Î¹') â†’ E' i), LE.le (Norm.norm ((f mâ‚) mâ‚‚)) (HMul.hMul (HMul.hMul C (Finset.univ.prod fun i => Norm.norm (mâ‚ i))) (Finset.univ.prod fun i => Norm.norm (mâ‚‚ i)))\nm : (i : Î¹) â†’ E i\nâŠ¢ Eq â‡‘((f.mkContinuousMultilinear C H) m) â‡‘(f m)","decl":"@[simp]\ntheorem mkContinuousMultilinear_apply (f : MultilinearMap ğ•œ E (MultilinearMap ğ•œ E' G)) {C : â„}\n    (H : âˆ€ mâ‚ mâ‚‚, â€–f mâ‚ mâ‚‚â€– â‰¤ (C * âˆ i, â€–mâ‚ iâ€–) * âˆ i, â€–mâ‚‚ iâ€–) (m : âˆ€ i, E i) :\n    â‡‘(mkContinuousMultilinear f C H m) = f m :=\n  rfl\n\n"}
{"name":"MultilinearMap.mkContinuousMultilinear_norm_le'","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"ğ•œ : Type u\nÎ¹ : Type v\nÎ¹' : Type v'\nE : Î¹ â†’ Type wE\nE' : Î¹' â†’ Type wE'\nG : Type wG\ninstâœâ¸ : Fintype Î¹'\ninstâœâ· : NontriviallyNormedField ğ•œ\ninstâœâ¶ : (i : Î¹) â†’ SeminormedAddCommGroup (E i)\ninstâœâµ : (i : Î¹) â†’ NormedSpace ğ•œ (E i)\ninstâœâ´ : SeminormedAddCommGroup G\ninstâœÂ³ : NormedSpace ğ•œ G\ninstâœÂ² : Fintype Î¹\ninstâœÂ¹ : (i : Î¹') â†’ SeminormedAddCommGroup (E' i)\ninstâœ : (i : Î¹') â†’ NormedSpace ğ•œ (E' i)\nf : MultilinearMap ğ•œ E (MultilinearMap ğ•œ E' G)\nC : Real\nH : âˆ€ (mâ‚ : (i : Î¹) â†’ E i) (mâ‚‚ : (i : Î¹') â†’ E' i), LE.le (Norm.norm ((f mâ‚) mâ‚‚)) (HMul.hMul (HMul.hMul C (Finset.univ.prod fun i => Norm.norm (mâ‚ i))) (Finset.univ.prod fun i => Norm.norm (mâ‚‚ i)))\nâŠ¢ LE.le (Norm.norm (f.mkContinuousMultilinear C H)) (Max.max C 0)","decl":"theorem mkContinuousMultilinear_norm_le' (f : MultilinearMap ğ•œ E (MultilinearMap ğ•œ E' G)) (C : â„)\n    (H : âˆ€ mâ‚ mâ‚‚, â€–f mâ‚ mâ‚‚â€– â‰¤ (C * âˆ i, â€–mâ‚ iâ€–) * âˆ i, â€–mâ‚‚ iâ€–) :\n    â€–mkContinuousMultilinear f C Hâ€– â‰¤ max C 0 := by\n  dsimp only [mkContinuousMultilinear]\n  exact mkContinuous_norm_le _ (le_max_right _ _) _\n\n"}
{"name":"MultilinearMap.mkContinuousMultilinear_norm_le","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"ğ•œ : Type u\nÎ¹ : Type v\nÎ¹' : Type v'\nE : Î¹ â†’ Type wE\nE' : Î¹' â†’ Type wE'\nG : Type wG\ninstâœâ¸ : Fintype Î¹'\ninstâœâ· : NontriviallyNormedField ğ•œ\ninstâœâ¶ : (i : Î¹) â†’ SeminormedAddCommGroup (E i)\ninstâœâµ : (i : Î¹) â†’ NormedSpace ğ•œ (E i)\ninstâœâ´ : SeminormedAddCommGroup G\ninstâœÂ³ : NormedSpace ğ•œ G\ninstâœÂ² : Fintype Î¹\ninstâœÂ¹ : (i : Î¹') â†’ SeminormedAddCommGroup (E' i)\ninstâœ : (i : Î¹') â†’ NormedSpace ğ•œ (E' i)\nf : MultilinearMap ğ•œ E (MultilinearMap ğ•œ E' G)\nC : Real\nhC : LE.le 0 C\nH : âˆ€ (mâ‚ : (i : Î¹) â†’ E i) (mâ‚‚ : (i : Î¹') â†’ E' i), LE.le (Norm.norm ((f mâ‚) mâ‚‚)) (HMul.hMul (HMul.hMul C (Finset.univ.prod fun i => Norm.norm (mâ‚ i))) (Finset.univ.prod fun i => Norm.norm (mâ‚‚ i)))\nâŠ¢ LE.le (Norm.norm (f.mkContinuousMultilinear C H)) C","decl":"theorem mkContinuousMultilinear_norm_le (f : MultilinearMap ğ•œ E (MultilinearMap ğ•œ E' G)) {C : â„}\n    (hC : 0 â‰¤ C) (H : âˆ€ mâ‚ mâ‚‚, â€–f mâ‚ mâ‚‚â€– â‰¤ (C * âˆ i, â€–mâ‚ iâ€–) * âˆ i, â€–mâ‚‚ iâ€–) :\n    â€–mkContinuousMultilinear f C Hâ€– â‰¤ C :=\n  (mkContinuousMultilinear_norm_le' f C H).trans_eq (max_eq_left hC)\n\n"}
{"name":"ContinuousMultilinearMap.norm_compContinuousLinearMap_le","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"ğ•œ : Type u\nÎ¹ : Type v\nE : Î¹ â†’ Type wE\nEâ‚ : Î¹ â†’ Type wEâ‚\nG : Type wG\ninstâœâ· : NontriviallyNormedField ğ•œ\ninstâœâ¶ : (i : Î¹) â†’ SeminormedAddCommGroup (E i)\ninstâœâµ : (i : Î¹) â†’ NormedSpace ğ•œ (E i)\ninstâœâ´ : (i : Î¹) â†’ SeminormedAddCommGroup (Eâ‚ i)\ninstâœÂ³ : (i : Î¹) â†’ NormedSpace ğ•œ (Eâ‚ i)\ninstâœÂ² : SeminormedAddCommGroup G\ninstâœÂ¹ : NormedSpace ğ•œ G\ninstâœ : Fintype Î¹\ng : ContinuousMultilinearMap ğ•œ Eâ‚ G\nf : (i : Î¹) â†’ ContinuousLinearMap (RingHom.id ğ•œ) (E i) (Eâ‚ i)\nâŠ¢ LE.le (Norm.norm (g.compContinuousLinearMap f)) (HMul.hMul (Norm.norm g) (Finset.univ.prod fun i => Norm.norm (f i)))","decl":"theorem norm_compContinuousLinearMap_le (g : ContinuousMultilinearMap ğ•œ Eâ‚ G)\n    (f : âˆ€ i, E i â†’L[ğ•œ] Eâ‚ i) : â€–g.compContinuousLinearMap fâ€– â‰¤ â€–gâ€– * âˆ i, â€–f iâ€– :=\n  opNorm_le_bound (by positivity) fun m =>\n    calc\n      â€–g fun i => f i (m i)â€– â‰¤ â€–gâ€– * âˆ i, â€–f i (m i)â€– := g.le_opNorm _\n      _ â‰¤ â€–gâ€– * âˆ i, â€–f iâ€– * â€–m iâ€– :=\n        (mul_le_mul_of_nonneg_left\n          (prod_le_prod (fun _ _ => norm_nonneg _) fun i _ => (f i).le_opNorm (m i))\n          (norm_nonneg g))\n      _ = (â€–gâ€– * âˆ i, â€–f iâ€–) * âˆ i, â€–m iâ€– := by rw [prod_mul_distrib, mul_assoc]\n\n"}
{"name":"ContinuousMultilinearMap.norm_compContinuous_linearIsometry_le","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"ğ•œ : Type u\nÎ¹ : Type v\nE : Î¹ â†’ Type wE\nEâ‚ : Î¹ â†’ Type wEâ‚\nG : Type wG\ninstâœâ· : NontriviallyNormedField ğ•œ\ninstâœâ¶ : (i : Î¹) â†’ SeminormedAddCommGroup (E i)\ninstâœâµ : (i : Î¹) â†’ NormedSpace ğ•œ (E i)\ninstâœâ´ : (i : Î¹) â†’ SeminormedAddCommGroup (Eâ‚ i)\ninstâœÂ³ : (i : Î¹) â†’ NormedSpace ğ•œ (Eâ‚ i)\ninstâœÂ² : SeminormedAddCommGroup G\ninstâœÂ¹ : NormedSpace ğ•œ G\ninstâœ : Fintype Î¹\ng : ContinuousMultilinearMap ğ•œ Eâ‚ G\nf : (i : Î¹) â†’ LinearIsometry (RingHom.id ğ•œ) (E i) (Eâ‚ i)\nâŠ¢ LE.le (Norm.norm (g.compContinuousLinearMap fun i => (f i).toContinuousLinearMap)) (Norm.norm g)","decl":"theorem norm_compContinuous_linearIsometry_le (g : ContinuousMultilinearMap ğ•œ Eâ‚ G)\n    (f : âˆ€ i, E i â†’â‚—áµ¢[ğ•œ] Eâ‚ i) :\n    â€–g.compContinuousLinearMap fun i => (f i).toContinuousLinearMapâ€– â‰¤ â€–gâ€– := by\n  refine opNorm_le_bound (norm_nonneg _) fun m => ?_\n  apply (g.le_opNorm _).trans _\n  simp only [ContinuousLinearMap.coe_coe, LinearIsometry.coe_toContinuousLinearMap,\n    LinearIsometry.norm_map, le_rfl]\n\n"}
{"name":"ContinuousMultilinearMap.norm_compContinuous_linearIsometryEquiv","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"ğ•œ : Type u\nÎ¹ : Type v\nE : Î¹ â†’ Type wE\nEâ‚ : Î¹ â†’ Type wEâ‚\nG : Type wG\ninstâœâ· : NontriviallyNormedField ğ•œ\ninstâœâ¶ : (i : Î¹) â†’ SeminormedAddCommGroup (E i)\ninstâœâµ : (i : Î¹) â†’ NormedSpace ğ•œ (E i)\ninstâœâ´ : (i : Î¹) â†’ SeminormedAddCommGroup (Eâ‚ i)\ninstâœÂ³ : (i : Î¹) â†’ NormedSpace ğ•œ (Eâ‚ i)\ninstâœÂ² : SeminormedAddCommGroup G\ninstâœÂ¹ : NormedSpace ğ•œ G\ninstâœ : Fintype Î¹\ng : ContinuousMultilinearMap ğ•œ Eâ‚ G\nf : (i : Î¹) â†’ LinearIsometryEquiv (RingHom.id ğ•œ) (E i) (Eâ‚ i)\nâŠ¢ Eq (Norm.norm (g.compContinuousLinearMap fun i => â†‘{ toLinearEquiv := (f i).toLinearEquiv, continuous_toFun := â‹¯, continuous_invFun := â‹¯ })) (Norm.norm g)","decl":"theorem norm_compContinuous_linearIsometryEquiv (g : ContinuousMultilinearMap ğ•œ Eâ‚ G)\n    (f : âˆ€ i, E i â‰ƒâ‚—áµ¢[ğ•œ] Eâ‚ i) :\n    â€–g.compContinuousLinearMap fun i => (f i : E i â†’L[ğ•œ] Eâ‚ i)â€– = â€–gâ€– := by\n  apply le_antisymm (g.norm_compContinuous_linearIsometry_le fun i => (f i).toLinearIsometry)\n  have : g = (g.compContinuousLinearMap fun i => (f i : E i â†’L[ğ•œ] Eâ‚ i)).compContinuousLinearMap\n      fun i => ((f i).symm : Eâ‚ i â†’L[ğ•œ] E i) := by\n    ext1 m\n    simp only [compContinuousLinearMap_apply, LinearIsometryEquiv.coe_coe'',\n      LinearIsometryEquiv.apply_symm_apply]\n  conv_lhs => rw [this]\n  apply (g.compContinuousLinearMap fun i =>\n    (f i : E i â†’L[ğ•œ] Eâ‚ i)).norm_compContinuous_linearIsometry_le\n      fun i => (f i).symm.toLinearIsometry\n\n"}
{"name":"ContinuousMultilinearMap.compContinuousLinearMapL_apply","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"ğ•œ : Type u\nÎ¹ : Type v\nE : Î¹ â†’ Type wE\nEâ‚ : Î¹ â†’ Type wEâ‚\nG : Type wG\ninstâœâ· : NontriviallyNormedField ğ•œ\ninstâœâ¶ : (i : Î¹) â†’ SeminormedAddCommGroup (E i)\ninstâœâµ : (i : Î¹) â†’ NormedSpace ğ•œ (E i)\ninstâœâ´ : (i : Î¹) â†’ SeminormedAddCommGroup (Eâ‚ i)\ninstâœÂ³ : (i : Î¹) â†’ NormedSpace ğ•œ (Eâ‚ i)\ninstâœÂ² : SeminormedAddCommGroup G\ninstâœÂ¹ : NormedSpace ğ•œ G\ninstâœ : Fintype Î¹\ng : ContinuousMultilinearMap ğ•œ Eâ‚ G\nf : (i : Î¹) â†’ ContinuousLinearMap (RingHom.id ğ•œ) (E i) (Eâ‚ i)\nâŠ¢ Eq ((ContinuousMultilinearMap.compContinuousLinearMapL f) g) (g.compContinuousLinearMap f)","decl":"@[simp]\ntheorem compContinuousLinearMapL_apply (g : ContinuousMultilinearMap ğ•œ Eâ‚ G)\n    (f : âˆ€ i, E i â†’L[ğ•œ] Eâ‚ i) : compContinuousLinearMapL f g = g.compContinuousLinearMap f :=\n  rfl\n\n"}
{"name":"ContinuousMultilinearMap.norm_compContinuousLinearMapL_le","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"ğ•œ : Type u\nÎ¹ : Type v\nE : Î¹ â†’ Type wE\nEâ‚ : Î¹ â†’ Type wEâ‚\nG : Type wG\ninstâœâ· : NontriviallyNormedField ğ•œ\ninstâœâ¶ : (i : Î¹) â†’ SeminormedAddCommGroup (E i)\ninstâœâµ : (i : Î¹) â†’ NormedSpace ğ•œ (E i)\ninstâœâ´ : (i : Î¹) â†’ SeminormedAddCommGroup (Eâ‚ i)\ninstâœÂ³ : (i : Î¹) â†’ NormedSpace ğ•œ (Eâ‚ i)\ninstâœÂ² : SeminormedAddCommGroup G\ninstâœÂ¹ : NormedSpace ğ•œ G\ninstâœ : Fintype Î¹\nf : (i : Î¹) â†’ ContinuousLinearMap (RingHom.id ğ•œ) (E i) (Eâ‚ i)\nâŠ¢ LE.le (Norm.norm (ContinuousMultilinearMap.compContinuousLinearMapL f)) (Finset.univ.prod fun i => Norm.norm (f i))","decl":"variable (G) in\ntheorem norm_compContinuousLinearMapL_le (f : âˆ€ i, E i â†’L[ğ•œ] Eâ‚ i) :\n    â€–compContinuousLinearMapL (G := G) fâ€– â‰¤ âˆ i, â€–f iâ€– :=\n  LinearMap.mkContinuous_norm_le _ (by positivity) _\n\n"}
{"name":"ContinuousMultilinearMap.compContinuousLinearMapLRight_apply","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"ğ•œ : Type u\nÎ¹ : Type v\nE : Î¹ â†’ Type wE\nEâ‚ : Î¹ â†’ Type wEâ‚\nG : Type wG\ninstâœâ· : NontriviallyNormedField ğ•œ\ninstâœâ¶ : (i : Î¹) â†’ SeminormedAddCommGroup (E i)\ninstâœâµ : (i : Î¹) â†’ NormedSpace ğ•œ (E i)\ninstâœâ´ : (i : Î¹) â†’ SeminormedAddCommGroup (Eâ‚ i)\ninstâœÂ³ : (i : Î¹) â†’ NormedSpace ğ•œ (Eâ‚ i)\ninstâœÂ² : SeminormedAddCommGroup G\ninstâœÂ¹ : NormedSpace ğ•œ G\ninstâœ : Fintype Î¹\ng : ContinuousMultilinearMap ğ•œ Eâ‚ G\nf : (i : Î¹) â†’ ContinuousLinearMap (RingHom.id ğ•œ) (E i) (Eâ‚ i)\nâŠ¢ Eq (g.compContinuousLinearMapLRight f) (g.compContinuousLinearMap f)","decl":"@[simp]\ntheorem compContinuousLinearMapLRight_apply (g : ContinuousMultilinearMap ğ•œ Eâ‚ G)\n    (f : âˆ€ i, E i â†’L[ğ•œ] Eâ‚ i) : compContinuousLinearMapLRight g f = g.compContinuousLinearMap f :=\n  rfl\n\n"}
{"name":"ContinuousMultilinearMap.norm_compContinuousLinearMapLRight_le","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"ğ•œ : Type u\nÎ¹ : Type v\nE : Î¹ â†’ Type wE\nEâ‚ : Î¹ â†’ Type wEâ‚\nG : Type wG\ninstâœâ· : NontriviallyNormedField ğ•œ\ninstâœâ¶ : (i : Î¹) â†’ SeminormedAddCommGroup (E i)\ninstâœâµ : (i : Î¹) â†’ NormedSpace ğ•œ (E i)\ninstâœâ´ : (i : Î¹) â†’ SeminormedAddCommGroup (Eâ‚ i)\ninstâœÂ³ : (i : Î¹) â†’ NormedSpace ğ•œ (Eâ‚ i)\ninstâœÂ² : SeminormedAddCommGroup G\ninstâœÂ¹ : NormedSpace ğ•œ G\ninstâœ : Fintype Î¹\ng : ContinuousMultilinearMap ğ•œ Eâ‚ G\nâŠ¢ LE.le (Norm.norm g.compContinuousLinearMapLRight) (Norm.norm g)","decl":"variable (E) in\ntheorem norm_compContinuousLinearMapLRight_le (g : ContinuousMultilinearMap ğ•œ Eâ‚ G) :\n    â€–compContinuousLinearMapLRight (E := E) gâ€– â‰¤ â€–gâ€– :=\n  MultilinearMap.mkContinuous_norm_le _ (norm_nonneg _) _\n\n"}
{"name":"ContinuousMultilinearMap.compContinuousLinearMapEquivL_symm","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"ğ•œ : Type u\nÎ¹ : Type v\nE : Î¹ â†’ Type wE\nEâ‚ : Î¹ â†’ Type wEâ‚\nG : Type wG\ninstâœâ· : NontriviallyNormedField ğ•œ\ninstâœâ¶ : (i : Î¹) â†’ SeminormedAddCommGroup (E i)\ninstâœâµ : (i : Î¹) â†’ NormedSpace ğ•œ (E i)\ninstâœâ´ : (i : Î¹) â†’ SeminormedAddCommGroup (Eâ‚ i)\ninstâœÂ³ : (i : Î¹) â†’ NormedSpace ğ•œ (Eâ‚ i)\ninstâœÂ² : SeminormedAddCommGroup G\ninstâœÂ¹ : NormedSpace ğ•œ G\ninstâœ : Fintype Î¹\nf : (i : Î¹) â†’ ContinuousLinearEquiv (RingHom.id ğ•œ) (E i) (Eâ‚ i)\nâŠ¢ Eq (ContinuousMultilinearMap.compContinuousLinearMapEquivL G f).symm (ContinuousMultilinearMap.compContinuousLinearMapEquivL G fun i => (f i).symm)","decl":"@[simp]\ntheorem compContinuousLinearMapEquivL_symm (f : âˆ€ i, E i â‰ƒL[ğ•œ] Eâ‚ i) :\n    (compContinuousLinearMapEquivL G f).symm =\n      compContinuousLinearMapEquivL G fun i : Î¹ => (f i).symm :=\n  rfl\n\n"}
{"name":"ContinuousMultilinearMap.compContinuousLinearMapEquivL_apply","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"ğ•œ : Type u\nÎ¹ : Type v\nE : Î¹ â†’ Type wE\nEâ‚ : Î¹ â†’ Type wEâ‚\nG : Type wG\ninstâœâ· : NontriviallyNormedField ğ•œ\ninstâœâ¶ : (i : Î¹) â†’ SeminormedAddCommGroup (E i)\ninstâœâµ : (i : Î¹) â†’ NormedSpace ğ•œ (E i)\ninstâœâ´ : (i : Î¹) â†’ SeminormedAddCommGroup (Eâ‚ i)\ninstâœÂ³ : (i : Î¹) â†’ NormedSpace ğ•œ (Eâ‚ i)\ninstâœÂ² : SeminormedAddCommGroup G\ninstâœÂ¹ : NormedSpace ğ•œ G\ninstâœ : Fintype Î¹\ng : ContinuousMultilinearMap ğ•œ Eâ‚ G\nf : (i : Î¹) â†’ ContinuousLinearEquiv (RingHom.id ğ•œ) (E i) (Eâ‚ i)\nâŠ¢ Eq ((ContinuousMultilinearMap.compContinuousLinearMapEquivL G f) g) (g.compContinuousLinearMap fun i => â†‘(f i))","decl":"@[simp]\ntheorem compContinuousLinearMapEquivL_apply (g : ContinuousMultilinearMap ğ•œ Eâ‚ G)\n    (f : âˆ€ i, E i â‰ƒL[ğ•œ] Eâ‚ i) :\n    compContinuousLinearMapEquivL G f g =\n      g.compContinuousLinearMap fun i => (f i : E i â†’L[ğ•œ] Eâ‚ i) :=\n  rfl\n\n"}
{"name":"ContinuousMultilinearMap.iteratedFDerivComponent_apply","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"ğ•œ : Type u\nÎ¹ : Type v\nEâ‚ : Î¹ â†’ Type wEâ‚\nG : Type wG\ninstâœâ· : NontriviallyNormedField ğ•œ\ninstâœâ¶ : (i : Î¹) â†’ SeminormedAddCommGroup (Eâ‚ i)\ninstâœâµ : (i : Î¹) â†’ NormedSpace ğ•œ (Eâ‚ i)\ninstâœâ´ : SeminormedAddCommGroup G\ninstâœÂ³ : NormedSpace ğ•œ G\ninstâœÂ² : Fintype Î¹\nÎ± : Type u_1\ninstâœÂ¹ : Fintype Î±\nf : ContinuousMultilinearMap ğ•œ Eâ‚ G\ns : Set Î¹\ne : Equiv Î± â†‘s\ninstâœ : DecidablePred fun x => Membership.mem s x\nv : (i : Subtype fun a => Not (Membership.mem s a)) â†’ Eâ‚ â†‘i\nw : Î± â†’ (i : Î¹) â†’ Eâ‚ i\nâŠ¢ Eq (((f.iteratedFDerivComponent e) v) w) (f fun j => dite (Membership.mem s j) (fun h => w (e.symm âŸ¨j, hâŸ©) j) fun h => v âŸ¨j, hâŸ©)","decl":"@[simp] lemma iteratedFDerivComponent_apply {Î± : Type*} [Fintype Î±]\n    (f : ContinuousMultilinearMap ğ•œ Eâ‚ G) {s : Set Î¹} (e : Î± â‰ƒ s) [DecidablePred (Â· âˆˆ s)]\n    (v : âˆ€ i : {a : Î¹ // a âˆ‰ s}, Eâ‚ i) (w : Î± â†’ (âˆ€ i, Eâ‚ i)) :\n    f.iteratedFDerivComponent e v w =\n      f (fun j â†¦ if h : j âˆˆ s then w (e.symm âŸ¨j, hâŸ©) j else v âŸ¨j, hâŸ©) := by\n  simp [iteratedFDerivComponent, MultilinearMap.iteratedFDerivComponent,\n    MultilinearMap.domDomRestrictâ‚—]\n\n"}
{"name":"ContinuousMultilinearMap.norm_iteratedFDerivComponent_le","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"ğ•œ : Type u\nÎ¹ : Type v\nEâ‚ : Î¹ â†’ Type wEâ‚\nG : Type wG\ninstâœâ· : NontriviallyNormedField ğ•œ\ninstâœâ¶ : (i : Î¹) â†’ SeminormedAddCommGroup (Eâ‚ i)\ninstâœâµ : (i : Î¹) â†’ NormedSpace ğ•œ (Eâ‚ i)\ninstâœâ´ : SeminormedAddCommGroup G\ninstâœÂ³ : NormedSpace ğ•œ G\ninstâœÂ² : Fintype Î¹\nÎ± : Type u_1\ninstâœÂ¹ : Fintype Î±\nf : ContinuousMultilinearMap ğ•œ Eâ‚ G\ns : Set Î¹\ne : Equiv Î± â†‘s\ninstâœ : DecidablePred fun x => Membership.mem s x\nx : (i : Î¹) â†’ Eâ‚ i\nâŠ¢ LE.le (Norm.norm ((f.iteratedFDerivComponent e) fun x_1 => x â†‘x_1)) (HMul.hMul (Norm.norm f) (HPow.hPow (Norm.norm x) (HSub.hSub (Fintype.card Î¹) (Fintype.card Î±))))","decl":"lemma norm_iteratedFDerivComponent_le {Î± : Type*} [Fintype Î±]\n    (f : ContinuousMultilinearMap ğ•œ Eâ‚ G) {s : Set Î¹} (e : Î± â‰ƒ s) [DecidablePred (Â· âˆˆ s)]\n    (x : (i : Î¹) â†’ Eâ‚ i) :\n    â€–f.iteratedFDerivComponent e (x Â·)â€– â‰¤ â€–fâ€– * â€–xâ€– ^ (Fintype.card Î¹ - Fintype.card Î±) := calc\n  â€–f.iteratedFDerivComponent e (fun i â†¦ x i)â€–\n    â‰¤ â€–f.iteratedFDerivComponent eâ€– * âˆ i : {a : Î¹ // a âˆ‰ s}, â€–x iâ€– :=\n      ContinuousMultilinearMap.le_opNorm _ _\n  _ â‰¤ â€–fâ€– * âˆ _i : {a : Î¹ // a âˆ‰ s}, â€–xâ€– := by\n      gcongr\n      Â· exact MultilinearMap.mkContinuousMultilinear_norm_le _ (norm_nonneg _) _\n      Â· exact norm_le_pi_norm _ _\n  _ = â€–fâ€– * â€–xâ€– ^ (Fintype.card {a : Î¹ // a âˆ‰ s}) := by rw [prod_const, card_univ]\n  _ = â€–fâ€– * â€–xâ€– ^ (Fintype.card Î¹ - Fintype.card Î±) := by simp [Fintype.card_congr e]\n\n"}
{"name":"ContinuousMultilinearMap.norm_iteratedFDeriv_le'","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"ğ•œ : Type u\nÎ¹ : Type v\nEâ‚ : Î¹ â†’ Type wEâ‚\nG : Type wG\ninstâœâµ : NontriviallyNormedField ğ•œ\ninstâœâ´ : (i : Î¹) â†’ SeminormedAddCommGroup (Eâ‚ i)\ninstâœÂ³ : (i : Î¹) â†’ NormedSpace ğ•œ (Eâ‚ i)\ninstâœÂ² : SeminormedAddCommGroup G\ninstâœÂ¹ : NormedSpace ğ•œ G\ninstâœ : Fintype Î¹\nf : ContinuousMultilinearMap ğ•œ Eâ‚ G\nk : Nat\nx : (i : Î¹) â†’ Eâ‚ i\nâŠ¢ LE.le (Norm.norm (f.iteratedFDeriv k x)) (HMul.hMul (HMul.hMul (â†‘((Fintype.card Î¹).descFactorial k)) (Norm.norm f)) (HPow.hPow (Norm.norm x) (HSub.hSub (Fintype.card Î¹) k)))","decl":"/-- Controlling the norm of `f.iteratedFDeriv` when `f` is continuous multilinear. For the same\nbound on the iterated derivative of `f` in the calculus sense,\nsee `ContinuousMultilinearMap.norm_iteratedFDeriv_le`. -/\nlemma norm_iteratedFDeriv_le' (f : ContinuousMultilinearMap ğ•œ Eâ‚ G) (k : â„•) (x : (i : Î¹) â†’ Eâ‚ i) :\n    â€–f.iteratedFDeriv k xâ€–\n      â‰¤ Nat.descFactorial (Fintype.card Î¹) k * â€–fâ€– * â€–xâ€– ^ (Fintype.card Î¹ - k) := by\n  classical\n  calc â€–f.iteratedFDeriv k xâ€–\n  _ â‰¤ âˆ‘ e : Fin k â†ª Î¹, â€–iteratedFDerivComponent f e.toEquivRange (fun i â†¦ x i)â€– := norm_sum_le _ _\n  _ â‰¤ âˆ‘ _ : Fin k â†ª Î¹, â€–fâ€– * â€–xâ€– ^ (Fintype.card Î¹ - k) := by\n    gcongr with e _\n    simpa using norm_iteratedFDerivComponent_le f e.toEquivRange x\n  _ = Nat.descFactorial (Fintype.card Î¹) k * â€–fâ€– * â€–xâ€– ^ (Fintype.card Î¹ - k) := by\n    simp [card_univ, mul_assoc]\n\n"}
{"name":"ContinuousMultilinearMap.opNorm_zero_iff","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"ğ•œ : Type u\nÎ¹ : Type v\nE : Î¹ â†’ Type wE\nG : Type wG\ninstâœâµ : Fintype Î¹\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : (i : Î¹) â†’ SeminormedAddCommGroup (E i)\ninstâœÂ² : (i : Î¹) â†’ NormedSpace ğ•œ (E i)\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nf : ContinuousMultilinearMap ğ•œ E G\nâŠ¢ Iff (Eq (Norm.norm f) 0) (Eq f 0)","decl":"/-- A continuous linear map is zero iff its norm vanishes. -/\ntheorem opNorm_zero_iff {f : ContinuousMultilinearMap ğ•œ E G} : â€–fâ€– = 0 â†” f = 0 := by\n  simp [â† (opNorm_nonneg f).le_iff_eq, opNorm_le_iff le_rfl, ContinuousMultilinearMap.ext_iff]\n\n"}
{"name":"ContinuousMultilinearMap.norm_ofSubsingleton_id","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"ğ•œ : Type u\nÎ¹ : Type v\nG : Type wG\ninstâœâµ : Fintype Î¹\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup G\ninstâœÂ² : NormedSpace ğ•œ G\ninstâœÂ¹ : Subsingleton Î¹\ninstâœ : Nontrivial G\ni : Î¹\nâŠ¢ Eq (Norm.norm ((ContinuousMultilinearMap.ofSubsingleton ğ•œ G G i) (ContinuousLinearMap.id ğ•œ G))) 1","decl":"theorem norm_ofSubsingleton_id [Subsingleton Î¹] [Nontrivial G] (i : Î¹) :\n    â€–ofSubsingleton ğ•œ G G i (.id _ _)â€– = 1 := by\n  simp\n\n"}
{"name":"ContinuousMultilinearMap.nnnorm_ofSubsingleton_id","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"ğ•œ : Type u\nÎ¹ : Type v\nG : Type wG\ninstâœâµ : Fintype Î¹\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup G\ninstâœÂ² : NormedSpace ğ•œ G\ninstâœÂ¹ : Subsingleton Î¹\ninstâœ : Nontrivial G\ni : Î¹\nâŠ¢ Eq (NNNorm.nnnorm ((ContinuousMultilinearMap.ofSubsingleton ğ•œ G G i) (ContinuousLinearMap.id ğ•œ G))) 1","decl":"theorem nnnorm_ofSubsingleton_id [Subsingleton Î¹] [Nontrivial G] (i : Î¹) :\n    â€–ofSubsingleton ğ•œ G G i (.id _ _)â€–â‚Š = 1 :=\n  NNReal.eq <| norm_ofSubsingleton_id ..\n\n"}
{"name":"MultilinearMap.bound_of_shell","module":"Mathlib.Analysis.NormedSpace.Multilinear.Basic","initialProofState":"ğ•œ : Type u\nÎ¹ : Type v\nE : Î¹ â†’ Type wE\nG : Type wG\ninstâœâµ : Fintype Î¹\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : (i : Î¹) â†’ NormedAddCommGroup (E i)\ninstâœÂ² : (i : Î¹) â†’ NormedSpace ğ•œ (E i)\ninstâœÂ¹ : SeminormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nf : MultilinearMap ğ•œ E G\nÎµ : Î¹ â†’ Real\nC : Real\nc : Î¹ â†’ ğ•œ\nhÎµ : âˆ€ (i : Î¹), LT.lt 0 (Îµ i)\nhc : âˆ€ (i : Î¹), LT.lt 1 (Norm.norm (c i))\nhf : âˆ€ (m : (i : Î¹) â†’ E i), (âˆ€ (i : Î¹), LE.le (HDiv.hDiv (Îµ i) (Norm.norm (c i))) (Norm.norm (m i))) â†’ (âˆ€ (i : Î¹), LT.lt (Norm.norm (m i)) (Îµ i)) â†’ LE.le (Norm.norm (f m)) (HMul.hMul C (Finset.univ.prod fun i => Norm.norm (m i)))\nm : (i : Î¹) â†’ E i\nâŠ¢ LE.le (Norm.norm (f m)) (HMul.hMul C (Finset.univ.prod fun i => Norm.norm (m i)))","decl":"/-- If a multilinear map in finitely many variables on normed spaces satisfies the inequality\n`â€–f mâ€– â‰¤ C * âˆ i, â€–m iâ€–` on a shell `Îµ i / â€–c iâ€– < â€–m iâ€– < Îµ i` for some positive numbers `Îµ i`\nand elements `c i : ğ•œ`, `1 < â€–c iâ€–`, then it satisfies this inequality for all `m`. -/\ntheorem bound_of_shell (f : MultilinearMap ğ•œ E G) {Îµ : Î¹ â†’ â„} {C : â„} {c : Î¹ â†’ ğ•œ}\n    (hÎµ : âˆ€ i, 0 < Îµ i) (hc : âˆ€ i, 1 < â€–c iâ€–)\n    (hf : âˆ€ m : âˆ€ i, E i, (âˆ€ i, Îµ i / â€–c iâ€– â‰¤ â€–m iâ€–) â†’ (âˆ€ i, â€–m iâ€– < Îµ i) â†’ â€–f mâ€– â‰¤ C * âˆ i, â€–m iâ€–)\n    (m : âˆ€ i, E i) : â€–f mâ€– â‰¤ C * âˆ i, â€–m iâ€– :=\n  bound_of_shell_of_norm_map_coord_zero f\n    (fun h â†¦ by rw [map_coord_zero f _ (norm_eq_zero.1 h), norm_zero]) hÎµ hc hf m\n\n"}
