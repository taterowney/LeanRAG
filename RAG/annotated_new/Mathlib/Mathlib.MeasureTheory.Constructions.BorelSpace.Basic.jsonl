{"name":"borel_anti","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Basic","initialProofState":"α : Type u_1\n⊢ Antitone (@borel α)","decl":"theorem borel_anti : Antitone (@borel α) := fun _ _ h =>\n  MeasurableSpace.generateFrom_le fun _ hs => .basic _ (h _ hs)\n\n"}
{"name":"borel_eq_top_of_discrete","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Basic","initialProofState":"α : Type u_1\ninst✝¹ : TopologicalSpace α\ninst✝ : DiscreteTopology α\n⊢ Eq (borel α) Top.top","decl":"theorem borel_eq_top_of_discrete [TopologicalSpace α] [DiscreteTopology α] : borel α = ⊤ :=\n  top_le_iff.1 fun s _ => GenerateMeasurable.basic s (isOpen_discrete s)\n\n"}
{"name":"borel_eq_generateFrom_of_subbasis","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Basic","initialProofState":"α : Type u_1\ns : Set (Set α)\nt : TopologicalSpace α\ninst✝ : SecondCountableTopology α\nhs : Eq t (TopologicalSpace.generateFrom s)\n⊢ Eq (borel α) (MeasurableSpace.generateFrom s)","decl":"theorem borel_eq_generateFrom_of_subbasis {s : Set (Set α)} [t : TopologicalSpace α]\n    [SecondCountableTopology α] (hs : t = .generateFrom s) : borel α = .generateFrom s :=\n  le_antisymm\n    (generateFrom_le fun u (hu : t.IsOpen u) => by\n      rw [hs] at hu\n      induction hu with\n      | basic u hu => exact GenerateMeasurable.basic u hu\n      | univ => exact @MeasurableSet.univ α (generateFrom s)\n      | inter s₁ s₂ _ _ hs₁ hs₂ => exact @MeasurableSet.inter α (generateFrom s) _ _ hs₁ hs₂\n      | sUnion f hf ih =>\n        rcases isOpen_sUnion_countable f (by rwa [hs]) with ⟨v, hv, vf, vu⟩\n        rw [← vu]\n        exact @MeasurableSet.sUnion α (generateFrom s) _ hv fun x xv => ih _ (vf xv))\n    (generateFrom_le fun u hu =>\n      GenerateMeasurable.basic _ <| show t.IsOpen u by rw [hs]; exact GenerateOpen.basic _ hu)\n\n"}
{"name":"TopologicalSpace.IsTopologicalBasis.borel_eq_generateFrom","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Basic","initialProofState":"α : Type u_1\ninst✝¹ : TopologicalSpace α\ninst✝ : SecondCountableTopology α\ns : Set (Set α)\nhs : TopologicalSpace.IsTopologicalBasis s\n⊢ Eq (borel α) (MeasurableSpace.generateFrom s)","decl":"theorem TopologicalSpace.IsTopologicalBasis.borel_eq_generateFrom [TopologicalSpace α]\n    [SecondCountableTopology α] {s : Set (Set α)} (hs : IsTopologicalBasis s) :\n    borel α = .generateFrom s :=\n  borel_eq_generateFrom_of_subbasis hs.eq_generateFrom\n\n"}
{"name":"isPiSystem_isOpen","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Basic","initialProofState":"α : Type u_1\ninst✝ : TopologicalSpace α\n⊢ IsPiSystem (setOf fun s => IsOpen s)","decl":"theorem isPiSystem_isOpen [TopologicalSpace α] : IsPiSystem ({s : Set α | IsOpen s}) :=\n  fun _s hs _t ht _ => IsOpen.inter hs ht\n\n"}
{"name":"isPiSystem_isClosed","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Basic","initialProofState":"α : Type u_1\ninst✝ : TopologicalSpace α\n⊢ IsPiSystem (setOf fun s => IsClosed s)","decl":"lemma isPiSystem_isClosed [TopologicalSpace α] : IsPiSystem ({s : Set α | IsClosed s}) :=\n  fun _s hs _t ht _ ↦ IsClosed.inter hs ht\n\n"}
{"name":"borel_eq_generateFrom_isClosed","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Basic","initialProofState":"α : Type u_1\ninst✝ : TopologicalSpace α\n⊢ Eq (borel α) (MeasurableSpace.generateFrom (setOf fun s => IsClosed s))","decl":"theorem borel_eq_generateFrom_isClosed [TopologicalSpace α] :\n    borel α = .generateFrom { s | IsClosed s } :=\n  le_antisymm\n    (generateFrom_le fun _t ht =>\n      @MeasurableSet.of_compl α _ (generateFrom { s | IsClosed s })\n        (GenerateMeasurable.basic _ <| isClosed_compl_iff.2 ht))\n    (generateFrom_le fun _t ht =>\n      @MeasurableSet.of_compl α _ (borel α) (GenerateMeasurable.basic _ <| isOpen_compl_iff.2 ht))\n\n"}
{"name":"borel_comap","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nt : TopologicalSpace β\n⊢ Eq (borel α) (MeasurableSpace.comap f (borel β))","decl":"theorem borel_comap {f : α → β} {t : TopologicalSpace β} :\n    @borel α (t.induced f) = (@borel β t).comap f :=\n  comap_generateFrom.symm\n\n"}
{"name":"Continuous.borel_measurable","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : TopologicalSpace α\ninst✝ : TopologicalSpace β\nf : α → β\nhf : Continuous f\n⊢ Measurable f","decl":"theorem Continuous.borel_measurable [TopologicalSpace α] [TopologicalSpace β] {f : α → β}\n    (hf : Continuous f) : @Measurable α β (borel α) (borel β) f :=\n  Measurable.of_le_map <|\n    generateFrom_le fun s hs => GenerateMeasurable.basic (f ⁻¹' s) (hs.preimage hf)\n\n"}
{"name":"OpensMeasurableSpace.borel_le","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Basic","initialProofState":"α : Type u_6\ninst✝ : TopologicalSpace α\nh : MeasurableSpace α\nself : OpensMeasurableSpace α\n⊢ LE.le (borel α) h","decl":"/-- A space with `MeasurableSpace` and `TopologicalSpace` structures such that\nall open sets are measurable. -/\nclass OpensMeasurableSpace (α : Type*) [TopologicalSpace α] [h : MeasurableSpace α] : Prop where\n  /-- Borel-measurable sets are measurable. -/\n  borel_le : borel α ≤ h\n\n"}
{"name":"BorelSpace.measurable_eq","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Basic","initialProofState":"α : Type u_6\ninst✝¹ : TopologicalSpace α\ninst✝ : MeasurableSpace α\nself : BorelSpace α\n⊢ Eq inst✝ (borel α)","decl":"/-- A space with `MeasurableSpace` and `TopologicalSpace` structures such that\nthe `σ`-algebra of measurable sets is exactly the `σ`-algebra generated by open sets. -/\nclass BorelSpace (α : Type*) [TopologicalSpace α] [MeasurableSpace α] : Prop where\n  /-- The measurable sets are exactly the Borel-measurable sets. -/\n  measurable_eq : ‹MeasurableSpace α› = borel α\n\n"}
{"name":"OrderDual.opensMeasurableSpace","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Basic","initialProofState":"α : Type u_6\ninst✝¹ : TopologicalSpace α\ninst✝ : MeasurableSpace α\nh : OpensMeasurableSpace α\n⊢ OpensMeasurableSpace (OrderDual α)","decl":"instance (priority := 100) OrderDual.opensMeasurableSpace {α : Type*} [TopologicalSpace α]\n    [MeasurableSpace α] [h : OpensMeasurableSpace α] : OpensMeasurableSpace αᵒᵈ where\n  borel_le := h.borel_le\n\n"}
{"name":"OrderDual.borelSpace","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Basic","initialProofState":"α : Type u_6\ninst✝¹ : TopologicalSpace α\ninst✝ : MeasurableSpace α\nh : BorelSpace α\n⊢ BorelSpace (OrderDual α)","decl":"instance (priority := 100) OrderDual.borelSpace {α : Type*} [TopologicalSpace α]\n    [MeasurableSpace α] [h : BorelSpace α] : BorelSpace αᵒᵈ where\n  measurable_eq := h.measurable_eq\n\n"}
{"name":"BorelSpace.opensMeasurable","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Basic","initialProofState":"α : Type u_6\ninst✝² : TopologicalSpace α\ninst✝¹ : MeasurableSpace α\ninst✝ : BorelSpace α\n⊢ OpensMeasurableSpace α","decl":"/-- In a `BorelSpace` all open sets are measurable. -/\ninstance (priority := 100) BorelSpace.opensMeasurable {α : Type*} [TopologicalSpace α]\n    [MeasurableSpace α] [BorelSpace α] : OpensMeasurableSpace α :=\n  ⟨ge_of_eq <| BorelSpace.measurable_eq⟩\n\n"}
{"name":"Subtype.borelSpace","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Basic","initialProofState":"α : Type u_6\ninst✝¹ : TopologicalSpace α\ninst✝ : MeasurableSpace α\nhα : BorelSpace α\ns : Set α\n⊢ BorelSpace ↑s","decl":"instance Subtype.borelSpace {α : Type*} [TopologicalSpace α] [MeasurableSpace α]\n    [hα : BorelSpace α] (s : Set α) : BorelSpace s :=\n  ⟨by borelize α; symm; apply borel_comap⟩\n\n"}
{"name":"Countable.instBorelSpace","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Basic","initialProofState":"α : Type u_1\ninst✝⁴ : Countable α\ninst✝³ : MeasurableSpace α\ninst✝² : MeasurableSingletonClass α\ninst✝¹ : TopologicalSpace α\ninst✝ : DiscreteTopology α\n⊢ BorelSpace α","decl":"instance Countable.instBorelSpace [Countable α] [MeasurableSpace α] [MeasurableSingletonClass α]\n    [TopologicalSpace α] [DiscreteTopology α] : BorelSpace α := by\n  have : ∀ s, @MeasurableSet α inferInstance s := fun s ↦ s.to_countable.measurableSet\n  have : ∀ s, @MeasurableSet α (borel α) s := fun s ↦ measurableSet_generateFrom (isOpen_discrete s)\n  exact ⟨by aesop⟩\n\n"}
{"name":"Subtype.opensMeasurableSpace","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Basic","initialProofState":"α : Type u_6\ninst✝¹ : TopologicalSpace α\ninst✝ : MeasurableSpace α\nh : OpensMeasurableSpace α\ns : Set α\n⊢ OpensMeasurableSpace ↑s","decl":"instance Subtype.opensMeasurableSpace {α : Type*} [TopologicalSpace α] [MeasurableSpace α]\n    [h : OpensMeasurableSpace α] (s : Set α) : OpensMeasurableSpace s :=\n  ⟨by\n    rw [borel_comap]\n    exact comap_mono h.1⟩\n\n"}
{"name":"opensMeasurableSpace_iff_forall_measurableSet","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Basic","initialProofState":"α : Type u_1\ninst✝¹ : TopologicalSpace α\ninst✝ : MeasurableSpace α\n⊢ Iff (OpensMeasurableSpace α) (∀ (s : Set α), IsOpen s → MeasurableSet s)","decl":"lemma opensMeasurableSpace_iff_forall_measurableSet\n    [TopologicalSpace α] [MeasurableSpace α] :\n    OpensMeasurableSpace α ↔  (∀ (s : Set α), IsOpen s → MeasurableSet s) := by\n  refine ⟨fun h s hs ↦ ?_, fun h ↦ ⟨generateFrom_le h⟩⟩\n  exact OpensMeasurableSpace.borel_le _ <| GenerateMeasurable.basic _ hs\n\n"}
{"name":"BorelSpace.countablyGenerated","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Basic","initialProofState":"α : Type u_6\ninst✝³ : TopologicalSpace α\ninst✝² : MeasurableSpace α\ninst✝¹ : BorelSpace α\ninst✝ : SecondCountableTopology α\n⊢ MeasurableSpace.CountablyGenerated α","decl":"instance (priority := 100) BorelSpace.countablyGenerated {α : Type*} [TopologicalSpace α]\n    [MeasurableSpace α] [BorelSpace α] [SecondCountableTopology α] : CountablyGenerated α := by\n  obtain ⟨b, bct, -, hb⟩ := exists_countable_basis α\n  refine ⟨⟨b, bct, ?_⟩⟩\n  borelize α\n  exact hb.borel_eq_generateFrom\n\n"}
{"name":"IsOpen.measurableSet","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Basic","initialProofState":"α : Type u_1\ns : Set α\ninst✝² : TopologicalSpace α\ninst✝¹ : MeasurableSpace α\ninst✝ : OpensMeasurableSpace α\nh : IsOpen s\n⊢ MeasurableSet s","decl":"theorem IsOpen.measurableSet (h : IsOpen s) : MeasurableSet s :=\n  OpensMeasurableSpace.borel_le _ <| GenerateMeasurable.basic _ h\n\n"}
{"name":"IsOpen.nullMeasurableSet","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Basic","initialProofState":"α : Type u_1\ns : Set α\ninst✝² : TopologicalSpace α\ninst✝¹ : MeasurableSpace α\ninst✝ : OpensMeasurableSpace α\nμ : MeasureTheory.Measure α\nh : IsOpen s\n⊢ MeasureTheory.NullMeasurableSet s μ","decl":"theorem IsOpen.nullMeasurableSet {μ} (h : IsOpen s) : NullMeasurableSet s μ :=\n  h.measurableSet.nullMeasurableSet\n\n"}
{"name":"MeasurableSet.induction_on_open","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Basic","initialProofState":"γ : Type u_3\ninst✝² : TopologicalSpace γ\ninst✝¹ : MeasurableSpace γ\ninst✝ : BorelSpace γ\nC : (s : Set γ) → MeasurableSet s → Prop\nisOpen : ∀ (U : Set γ) (hU : IsOpen U), C U ⋯\ncompl : ∀ (t : Set γ) (ht : MeasurableSet t), C t ht → C (HasCompl.compl t) ⋯\niUnion : ∀ (f : Nat → Set γ), Pairwise (Function.onFun Disjoint f) → ∀ (hf : ∀ (i : Nat), MeasurableSet (f i)), (∀ (i : Nat), C (f i) ⋯) → C (Set.iUnion fun i => f i) ⋯\nt : Set γ\nht : MeasurableSet t\n⊢ C t ht","decl":"open scoped Function in -- required for scoped `on` notation\n@[elab_as_elim]\ntheorem MeasurableSet.induction_on_open {C : ∀ s : Set γ, MeasurableSet s → Prop}\n    (isOpen : ∀ U (hU : IsOpen U), C U hU.measurableSet)\n    (compl : ∀ t (ht : MeasurableSet t), C t ht → C tᶜ ht.compl)\n    (iUnion : ∀ f : ℕ → Set γ, Pairwise (Disjoint on f) → ∀ (hf : ∀ i, MeasurableSet (f i)),\n      (∀ i, C (f i) (hf i)) → C (⋃ i, f i) (.iUnion hf)) :\n    ∀ t (ht : MeasurableSet t), C t ht := fun t ht ↦\n  MeasurableSpace.induction_on_inter BorelSpace.measurable_eq isPiSystem_isOpen\n    (isOpen _ isOpen_empty) isOpen compl iUnion t ht\n\n"}
{"name":"instCountablySeparatedElemOfHasCountableSeparatingOnIsOpen","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Basic","initialProofState":"α : Type u_1\ninst✝¹ : TopologicalSpace α\ninst✝ : MeasurableSpace α\ns : Set α\nh : HasCountableSeparatingOn α IsOpen s\n⊢ MeasurableSpace.CountablySeparated ↑s","decl":"instance (priority := 1000) {s : Set α} [h : HasCountableSeparatingOn α IsOpen s] :\n    CountablySeparated s := by\n  rw [CountablySeparated.subtype_iff]\n  exact .mono (fun _ ↦ IsOpen.measurableSet) Subset.rfl\n\n"}
{"name":"measurableSet_interior","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Basic","initialProofState":"α : Type u_1\ns : Set α\ninst✝² : TopologicalSpace α\ninst✝¹ : MeasurableSpace α\ninst✝ : OpensMeasurableSpace α\n⊢ MeasurableSet (interior s)","decl":"@[measurability]\ntheorem measurableSet_interior : MeasurableSet (interior s) :=\n  isOpen_interior.measurableSet\n\n"}
{"name":"IsGδ.measurableSet","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Basic","initialProofState":"α : Type u_1\ns : Set α\ninst✝² : TopologicalSpace α\ninst✝¹ : MeasurableSpace α\ninst✝ : OpensMeasurableSpace α\nh : IsGδ s\n⊢ MeasurableSet s","decl":"theorem IsGδ.measurableSet (h : IsGδ s) : MeasurableSet s := by\n  rcases h with ⟨S, hSo, hSc, rfl⟩\n  exact MeasurableSet.sInter hSc fun t ht => (hSo t ht).measurableSet\n\n"}
{"name":"measurableSet_of_continuousAt","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Basic","initialProofState":"α : Type u_1\ninst✝³ : TopologicalSpace α\ninst✝² : MeasurableSpace α\ninst✝¹ : OpensMeasurableSpace α\nβ : Type u_6\ninst✝ : EMetricSpace β\nf : α → β\n⊢ MeasurableSet (setOf fun x => ContinuousAt f x)","decl":"theorem measurableSet_of_continuousAt {β} [EMetricSpace β] (f : α → β) :\n    MeasurableSet { x | ContinuousAt f x } :=\n  (IsGδ.setOf_continuousAt f).measurableSet\n\n"}
{"name":"IsClosed.measurableSet","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Basic","initialProofState":"α : Type u_1\ns : Set α\ninst✝² : TopologicalSpace α\ninst✝¹ : MeasurableSpace α\ninst✝ : OpensMeasurableSpace α\nh : IsClosed s\n⊢ MeasurableSet s","decl":"theorem IsClosed.measurableSet (h : IsClosed s) : MeasurableSet s :=\n  h.isOpen_compl.measurableSet.of_compl\n\n"}
{"name":"IsClosed.nullMeasurableSet","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Basic","initialProofState":"α : Type u_1\ns : Set α\ninst✝² : TopologicalSpace α\ninst✝¹ : MeasurableSpace α\ninst✝ : OpensMeasurableSpace α\nμ : MeasureTheory.Measure α\nh : IsClosed s\n⊢ MeasureTheory.NullMeasurableSet s μ","decl":"theorem IsClosed.nullMeasurableSet {μ} (h : IsClosed s) : NullMeasurableSet s μ :=\n  h.measurableSet.nullMeasurableSet\n\n"}
{"name":"IsCompact.measurableSet","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Basic","initialProofState":"α : Type u_1\ns : Set α\ninst✝³ : TopologicalSpace α\ninst✝² : MeasurableSpace α\ninst✝¹ : OpensMeasurableSpace α\ninst✝ : T2Space α\nh : IsCompact s\n⊢ MeasurableSet s","decl":"theorem IsCompact.measurableSet [T2Space α] (h : IsCompact s) : MeasurableSet s :=\n  h.isClosed.measurableSet\n\n"}
{"name":"IsCompact.nullMeasurableSet","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Basic","initialProofState":"α : Type u_1\ns : Set α\ninst✝³ : TopologicalSpace α\ninst✝² : MeasurableSpace α\ninst✝¹ : OpensMeasurableSpace α\ninst✝ : T2Space α\nμ : MeasureTheory.Measure α\nh : IsCompact s\n⊢ MeasureTheory.NullMeasurableSet s μ","decl":"theorem IsCompact.nullMeasurableSet [T2Space α] {μ} (h : IsCompact s) : NullMeasurableSet s μ :=\n  h.isClosed.nullMeasurableSet\n\n"}
{"name":"Inseparable.mem_measurableSet_iff","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Basic","initialProofState":"γ : Type u_3\ninst✝² : TopologicalSpace γ\ninst✝¹ : MeasurableSpace γ\ninst✝ : BorelSpace γ\nx y : γ\nh : Inseparable x y\ns : Set γ\nhs : MeasurableSet s\n⊢ Iff (Membership.mem s x) (Membership.mem s y)","decl":"/-- If two points are topologically inseparable,\nthen they can't be separated by a Borel measurable set. -/\ntheorem Inseparable.mem_measurableSet_iff {x y : γ} (h : Inseparable x y) {s : Set γ}\n    (hs : MeasurableSet s) : x ∈ s ↔ y ∈ s :=\n  MeasurableSet.induction_on_open (fun _ ↦ h.mem_open_iff) (fun _ _ ↦ Iff.not)\n    (fun _ _ _ h ↦ by simp [h]) s hs\n\n"}
{"name":"IsCompact.closure_subset_measurableSet","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Basic","initialProofState":"γ : Type u_3\ninst✝³ : TopologicalSpace γ\ninst✝² : MeasurableSpace γ\ninst✝¹ : BorelSpace γ\ninst✝ : R1Space γ\nK s : Set γ\nhK : IsCompact K\nhs : MeasurableSet s\nhKs : HasSubset.Subset K s\n⊢ HasSubset.Subset (closure K) s","decl":"/-- If `K` is a compact set in an R₁ space and `s ⊇ K` is a Borel measurable superset,\nthen `s` includes the closure of `K` as well. -/\ntheorem IsCompact.closure_subset_measurableSet [R1Space γ] {K s : Set γ} (hK : IsCompact K)\n    (hs : MeasurableSet s) (hKs : K ⊆ s) : closure K ⊆ s := by\n  rw [hK.closure_eq_biUnion_inseparable, iUnion₂_subset_iff]\n  exact fun x hx y hy ↦ (hy.mem_measurableSet_iff hs).1 (hKs hx)\n\n"}
{"name":"IsCompact.measure_closure","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Basic","initialProofState":"γ : Type u_3\ninst✝³ : TopologicalSpace γ\ninst✝² : MeasurableSpace γ\ninst✝¹ : BorelSpace γ\ninst✝ : R1Space γ\nK : Set γ\nhK : IsCompact K\nμ : MeasureTheory.Measure γ\n⊢ Eq (μ (closure K)) (μ K)","decl":"/-- In an R₁ topological space with Borel measure `μ`,\nthe measure of the closure of a compact set `K` is equal to the measure of `K`.\n\nSee also `MeasureTheory.Measure.OuterRegular.measure_closure_eq_of_isCompact`\nfor a version that assumes `μ` to be outer regular\nbut does not assume the `σ`-algebra to be Borel. -/\ntheorem IsCompact.measure_closure [R1Space γ] {K : Set γ} (hK : IsCompact K) (μ : Measure γ) :\n    μ (closure K) = μ K := by\n  refine le_antisymm ?_ (measure_mono subset_closure)\n  calc\n    μ (closure K) ≤ μ (toMeasurable μ K) := measure_mono <|\n      hK.closure_subset_measurableSet (measurableSet_toMeasurable ..) (subset_toMeasurable ..)\n    _ = μ K := measure_toMeasurable ..\n\n"}
{"name":"measurableSet_closure","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Basic","initialProofState":"α : Type u_1\ns : Set α\ninst✝² : TopologicalSpace α\ninst✝¹ : MeasurableSpace α\ninst✝ : OpensMeasurableSpace α\n⊢ MeasurableSet (closure s)","decl":"@[measurability]\ntheorem measurableSet_closure : MeasurableSet (closure s) :=\n  isClosed_closure.measurableSet\n\n"}
{"name":"measurable_of_isOpen","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Basic","initialProofState":"γ : Type u_3\nδ : Type u_5\ninst✝³ : TopologicalSpace γ\ninst✝² : MeasurableSpace γ\ninst✝¹ : BorelSpace γ\ninst✝ : MeasurableSpace δ\nf : δ → γ\nhf : ∀ (s : Set γ), IsOpen s → MeasurableSet (Set.preimage f s)\n⊢ Measurable f","decl":"theorem measurable_of_isOpen {f : δ → γ} (hf : ∀ s, IsOpen s → MeasurableSet (f ⁻¹' s)) :\n    Measurable f := by\n  rw [‹BorelSpace γ›.measurable_eq]\n  exact measurable_generateFrom hf\n\n"}
{"name":"measurable_of_isClosed","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Basic","initialProofState":"γ : Type u_3\nδ : Type u_5\ninst✝³ : TopologicalSpace γ\ninst✝² : MeasurableSpace γ\ninst✝¹ : BorelSpace γ\ninst✝ : MeasurableSpace δ\nf : δ → γ\nhf : ∀ (s : Set γ), IsClosed s → MeasurableSet (Set.preimage f s)\n⊢ Measurable f","decl":"theorem measurable_of_isClosed {f : δ → γ} (hf : ∀ s, IsClosed s → MeasurableSet (f ⁻¹' s)) :\n    Measurable f := by\n  apply measurable_of_isOpen; intro s hs\n  rw [← MeasurableSet.compl_iff, ← preimage_compl]; apply hf; rw [isClosed_compl_iff]; exact hs\n\n"}
{"name":"measurable_of_isClosed'","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Basic","initialProofState":"γ : Type u_3\nδ : Type u_5\ninst✝³ : TopologicalSpace γ\ninst✝² : MeasurableSpace γ\ninst✝¹ : BorelSpace γ\ninst✝ : MeasurableSpace δ\nf : δ → γ\nhf : ∀ (s : Set γ), IsClosed s → s.Nonempty → Ne s Set.univ → MeasurableSet (Set.preimage f s)\n⊢ Measurable f","decl":"theorem measurable_of_isClosed' {f : δ → γ}\n    (hf : ∀ s, IsClosed s → s.Nonempty → s ≠ univ → MeasurableSet (f ⁻¹' s)) : Measurable f := by\n  apply measurable_of_isClosed; intro s hs\n  rcases eq_empty_or_nonempty s with h1 | h1\n  · simp [h1]\n  by_cases h2 : s = univ\n  · simp [h2]\n  exact hf s hs h1 h2\n\n"}
{"name":"nhds_isMeasurablyGenerated","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Basic","initialProofState":"α : Type u_1\ninst✝¹ : TopologicalSpace α\ninst✝ : MeasurableSpace α\na : α\n⊢ (nhds a).IsMeasurablyGenerated","decl":"instance nhds_isMeasurablyGenerated (a : α) : (𝓝 a).IsMeasurablyGenerated := by\n  rw [nhds, iInf_subtype']\n  refine @Filter.iInf_isMeasurablyGenerated α _ _ _ fun i => ?_\n  exact i.2.2.measurableSet.principal_isMeasurablyGenerated\n\n"}
{"name":"MeasurableSet.nhdsWithin_isMeasurablyGenerated","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Basic","initialProofState":"α : Type u_1\ninst✝² : TopologicalSpace α\ninst✝¹ : MeasurableSpace α\ninst✝ : OpensMeasurableSpace α\ns : Set α\nhs : MeasurableSet s\na : α\n⊢ (nhdsWithin a s).IsMeasurablyGenerated","decl":"/-- If `s` is a measurable set, then `𝓝[s] a` is a measurably generated filter for\neach `a`. This cannot be an `instance` because it depends on a non-instance `hs : MeasurableSet s`.\n-/\ntheorem MeasurableSet.nhdsWithin_isMeasurablyGenerated {s : Set α} (hs : MeasurableSet s) (a : α) :\n    (𝓝[s] a).IsMeasurablyGenerated :=\n  haveI := hs.principal_isMeasurablyGenerated\n  Filter.inf_isMeasurablyGenerated _ _\n\n"}
{"name":"OpensMeasurableSpace.separatesPoints","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Basic","initialProofState":"α : Type u_1\ninst✝² : TopologicalSpace α\ninst✝¹ : MeasurableSpace α\ninst✝ : T0Space α\n⊢ MeasurableSpace.SeparatesPoints α","decl":"instance (priority := 100) OpensMeasurableSpace.separatesPoints [T0Space α] :\n    SeparatesPoints α := by\n  rw [separatesPoints_iff]\n  intro x y hxy\n  apply Inseparable.eq\n  rw [inseparable_iff_forall_isOpen]\n  exact fun s hs => hxy _ hs.measurableSet\n\n"}
{"name":"borel_eq_top_of_countable","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Basic","initialProofState":"α : Type u_6\ninst✝² : TopologicalSpace α\ninst✝¹ : T0Space α\ninst✝ : Countable α\n⊢ Eq (borel α) Top.top","decl":"theorem borel_eq_top_of_countable {α : Type*} [TopologicalSpace α] [T0Space α] [Countable α] :\n    borel α = ⊤ := by\n  refine top_unique fun s _ ↦ ?_\n  borelize α\n  exact .of_discrete\n\n-- see Note [lower instance priority]\n"}
{"name":"OpensMeasurableSpace.toMeasurableSingletonClass","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Basic","initialProofState":"α : Type u_1\ninst✝³ : TopologicalSpace α\ninst✝² : MeasurableSpace α\ninst✝¹ : OpensMeasurableSpace α\ninst✝ : T1Space α\n⊢ MeasurableSingletonClass α","decl":"instance (priority := 100) OpensMeasurableSpace.toMeasurableSingletonClass [T1Space α] :\n    MeasurableSingletonClass α :=\n  ⟨fun _ => isClosed_singleton.measurableSet⟩\n\n"}
{"name":"Pi.opensMeasurableSpace","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Basic","initialProofState":"ι : Type u_6\nπ : ι → Type u_7\ninst✝³ : Countable ι\nt' : (i : ι) → TopologicalSpace (π i)\ninst✝² : (i : ι) → MeasurableSpace (π i)\ninst✝¹ : ∀ (i : ι), SecondCountableTopology (π i)\ninst✝ : ∀ (i : ι), OpensMeasurableSpace (π i)\n⊢ OpensMeasurableSpace ((i : ι) → π i)","decl":"instance Pi.opensMeasurableSpace {ι : Type*} {π : ι → Type*} [Countable ι]\n    [t' : ∀ i, TopologicalSpace (π i)] [∀ i, MeasurableSpace (π i)]\n    [∀ i, SecondCountableTopology (π i)] [∀ i, OpensMeasurableSpace (π i)] :\n    OpensMeasurableSpace (∀ i, π i) := by\n  constructor\n  have : Pi.topologicalSpace = .generateFrom { t | ∃ (s : ∀ a, Set (π a)) (i : Finset ι),\n      (∀ a ∈ i, s a ∈ countableBasis (π a)) ∧ t = pi (↑i) s } := by\n    simp only [funext fun a => @eq_generateFrom_countableBasis (π a) _ _, pi_generateFrom_eq]\n  rw [borel_eq_generateFrom_of_subbasis this]\n  apply generateFrom_le\n  rintro _ ⟨s, i, hi, rfl⟩\n  refine MeasurableSet.pi i.countable_toSet fun a ha => IsOpen.measurableSet ?_\n  rw [eq_generateFrom_countableBasis (π a)]\n  exact .basic _ (hi a ha)\n\n"}
{"name":"SecondCountableTopologyEither.out","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Basic","initialProofState":"α : Type u_6\nβ : Type u_7\ninst✝¹ : TopologicalSpace α\ninst✝ : TopologicalSpace β\nself : SecondCountableTopologyEither α β\n⊢ Or (SecondCountableTopology α) (SecondCountableTopology β)","decl":"/-- The typeclass `SecondCountableTopologyEither α β` registers the fact that at least one of\nthe two spaces has second countable topology. This is the right assumption to ensure that continuous\nmaps from `α` to `β` are strongly measurable. -/\nclass SecondCountableTopologyEither (α β : Type*) [TopologicalSpace α] [TopologicalSpace β] :\n  Prop where\n  /-- The projection out of `SecondCountableTopologyEither` -/\n  out : SecondCountableTopology α ∨ SecondCountableTopology β\n\n"}
{"name":"secondCountableTopologyEither_of_left","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Basic","initialProofState":"α : Type u_6\nβ : Type u_7\ninst✝² : TopologicalSpace α\ninst✝¹ : TopologicalSpace β\ninst✝ : SecondCountableTopology α\n⊢ SecondCountableTopologyEither α β","decl":"instance (priority := 100) secondCountableTopologyEither_of_left (α β : Type*) [TopologicalSpace α]\n    [TopologicalSpace β] [SecondCountableTopology α] : SecondCountableTopologyEither α β where\n  out := Or.inl (by infer_instance)\n\n"}
{"name":"secondCountableTopologyEither_of_right","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Basic","initialProofState":"α : Type u_6\nβ : Type u_7\ninst✝² : TopologicalSpace α\ninst✝¹ : TopologicalSpace β\ninst✝ : SecondCountableTopology β\n⊢ SecondCountableTopologyEither α β","decl":"instance (priority := 100) secondCountableTopologyEither_of_right (α β : Type*)\n    [TopologicalSpace α] [TopologicalSpace β] [SecondCountableTopology β] :\n    SecondCountableTopologyEither α β where\n  out := Or.inr (by infer_instance)\n\n"}
{"name":"Prod.opensMeasurableSpace","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : TopologicalSpace α\ninst✝² : MeasurableSpace α\ninst✝¹ : TopologicalSpace β\ninst✝ : MeasurableSpace β\nh : SecondCountableTopologyEither α β\n⊢ OpensMeasurableSpace (Prod α β)","decl":"/-- If either `α` or `β` has second-countable topology, then the open sets in `α × β` belong to the\nproduct sigma-algebra. -/\ninstance Prod.opensMeasurableSpace [h : SecondCountableTopologyEither α β] :\n    OpensMeasurableSpace (α × β) := by\n  apply opensMeasurableSpace_iff_forall_measurableSet.2 (fun s hs ↦ ?_)\n  rcases h.out with hα|hβ\n  · let F : Set α → Set β := fun a ↦ {y | ∃ b, IsOpen b ∧ y ∈ b ∧ a ×ˢ b ⊆ s}\n    have A : ∀ a, IsOpen (F a) := by\n      intro a\n      apply isOpen_iff_forall_mem_open.2\n      rintro y ⟨b, b_open, yb, hb⟩\n      exact ⟨b, fun z zb ↦ ⟨b, b_open, zb, hb⟩, b_open, yb⟩\n    have : s = ⋃ a ∈ countableBasis α, a ×ˢ F a := by\n      apply Subset.antisymm\n      · rintro ⟨y1, y2⟩ hy\n        rcases isOpen_prod_iff.1 hs y1 y2 hy with ⟨u, v, u_open, v_open, yu, yv, huv⟩\n        obtain ⟨a, ha, ya, au⟩ : ∃ a ∈ countableBasis α, y1 ∈ a ∧ a ⊆ u :=\n          IsTopologicalBasis.exists_subset_of_mem_open (isBasis_countableBasis α) yu u_open\n        simp only [mem_iUnion, mem_prod, mem_setOf_eq, exists_and_left, exists_prop]\n        exact ⟨a, ya, ha, v, v_open, yv, (Set.prod_mono_left au).trans huv⟩\n      · rintro ⟨y1, y2⟩ hy\n        simp only [mem_iUnion, mem_prod, mem_setOf_eq, exists_and_left, exists_prop] at hy\n        rcases hy with ⟨a, ya, -, b, -, yb, hb⟩\n        exact hb (mem_prod.2 ⟨ya, yb⟩)\n    rw [this]\n    apply MeasurableSet.biUnion (countable_countableBasis α) (fun a ha ↦ ?_)\n    exact (isOpen_of_mem_countableBasis ha).measurableSet.prod (A a).measurableSet\n  · let F : Set β → Set α := fun a ↦ {y | ∃ b, IsOpen b ∧ y ∈ b ∧ b ×ˢ a ⊆ s}\n    have A : ∀ a, IsOpen (F a) := by\n      intro a\n      apply isOpen_iff_forall_mem_open.2\n      rintro y ⟨b, b_open, yb, hb⟩\n      exact ⟨b, fun z zb ↦ ⟨b, b_open, zb, hb⟩, b_open, yb⟩\n    have : s = ⋃ a ∈ countableBasis β, F a ×ˢ a := by\n      apply Subset.antisymm\n      · rintro ⟨y1, y2⟩ hy\n        rcases isOpen_prod_iff.1 hs y1 y2 hy with ⟨u, v, u_open, v_open, yu, yv, huv⟩\n        obtain ⟨a, ha, ya, au⟩ : ∃ a ∈ countableBasis β, y2 ∈ a ∧ a ⊆ v :=\n          IsTopologicalBasis.exists_subset_of_mem_open (isBasis_countableBasis β) yv v_open\n        simp only [mem_iUnion, mem_prod, mem_setOf_eq, exists_and_left, exists_prop]\n        exact ⟨a, ⟨u, u_open, yu, (Set.prod_mono_right au).trans huv⟩, ha, ya⟩\n      · rintro ⟨y1, y2⟩ hy\n        simp only [mem_iUnion, mem_prod, mem_setOf_eq, exists_and_left, exists_prop] at hy\n        rcases hy with ⟨a, ⟨b, -, yb, hb⟩, -, ya⟩\n        exact hb (mem_prod.2 ⟨yb, ya⟩)\n    rw [this]\n    apply MeasurableSet.biUnion (countable_countableBasis β) (fun a ha ↦ ?_)\n    exact (A a).measurableSet.prod (isOpen_of_mem_countableBasis ha).measurableSet\n\n"}
{"name":"interior_ae_eq_of_null_frontier","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Basic","initialProofState":"α' : Type u_6\ninst✝¹ : TopologicalSpace α'\ninst✝ : MeasurableSpace α'\nμ : MeasureTheory.Measure α'\ns : Set α'\nh : Eq (μ (frontier s)) 0\n⊢ (MeasureTheory.ae μ).EventuallyEq (interior s) s","decl":"theorem interior_ae_eq_of_null_frontier {μ : Measure α'} {s : Set α'} (h : μ (frontier s) = 0) :\n    interior s =ᵐ[μ] s :=\n  interior_subset.eventuallyLE.antisymm <| subset_closure.eventuallyLE.trans (ae_le_set.2 h)\n\n"}
{"name":"measure_interior_of_null_frontier","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Basic","initialProofState":"α' : Type u_6\ninst✝¹ : TopologicalSpace α'\ninst✝ : MeasurableSpace α'\nμ : MeasureTheory.Measure α'\ns : Set α'\nh : Eq (μ (frontier s)) 0\n⊢ Eq (μ (interior s)) (μ s)","decl":"theorem measure_interior_of_null_frontier {μ : Measure α'} {s : Set α'} (h : μ (frontier s) = 0) :\n    μ (interior s) = μ s :=\n  measure_congr (interior_ae_eq_of_null_frontier h)\n\n"}
{"name":"nullMeasurableSet_of_null_frontier","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Basic","initialProofState":"α : Type u_1\ninst✝² : TopologicalSpace α\ninst✝¹ : MeasurableSpace α\ninst✝ : OpensMeasurableSpace α\ns : Set α\nμ : MeasureTheory.Measure α\nh : Eq (μ (frontier s)) 0\n⊢ MeasureTheory.NullMeasurableSet s μ","decl":"theorem nullMeasurableSet_of_null_frontier {s : Set α} {μ : Measure α} (h : μ (frontier s) = 0) :\n    NullMeasurableSet s μ :=\n  ⟨interior s, isOpen_interior.measurableSet, (interior_ae_eq_of_null_frontier h).symm⟩\n\n"}
{"name":"closure_ae_eq_of_null_frontier","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Basic","initialProofState":"α' : Type u_6\ninst✝¹ : TopologicalSpace α'\ninst✝ : MeasurableSpace α'\nμ : MeasureTheory.Measure α'\ns : Set α'\nh : Eq (μ (frontier s)) 0\n⊢ (MeasureTheory.ae μ).EventuallyEq (closure s) s","decl":"theorem closure_ae_eq_of_null_frontier {μ : Measure α'} {s : Set α'} (h : μ (frontier s) = 0) :\n    closure s =ᵐ[μ] s :=\n  ((ae_le_set.2 h).trans interior_subset.eventuallyLE).antisymm <| subset_closure.eventuallyLE\n\n"}
{"name":"measure_closure_of_null_frontier","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Basic","initialProofState":"α' : Type u_6\ninst✝¹ : TopologicalSpace α'\ninst✝ : MeasurableSpace α'\nμ : MeasureTheory.Measure α'\ns : Set α'\nh : Eq (μ (frontier s)) 0\n⊢ Eq (μ (closure s)) (μ s)","decl":"theorem measure_closure_of_null_frontier {μ : Measure α'} {s : Set α'} (h : μ (frontier s) = 0) :\n    μ (closure s) = μ s :=\n  measure_congr (closure_ae_eq_of_null_frontier h)\n\n"}
{"name":"separatesPointsOfOpensMeasurableSpaceOfT0Space","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Basic","initialProofState":"α : Type u_1\ninst✝² : TopologicalSpace α\ninst✝¹ : MeasurableSpace α\ninst✝ : T0Space α\n⊢ MeasurableSpace.SeparatesPoints α","decl":"instance separatesPointsOfOpensMeasurableSpaceOfT0Space [T0Space α] :\n    MeasurableSpace.SeparatesPoints α where\n  separates x y := by\n    contrapose!\n    intro x_ne_y\n    obtain ⟨U, U_open, mem_U⟩ := exists_isOpen_xor'_mem x_ne_y\n    by_cases x_in_U : x ∈ U\n    · refine ⟨U, U_open.measurableSet, x_in_U, ?_⟩\n      simp_all only [ne_eq, xor_true, not_false_eq_true]\n    · refine ⟨Uᶜ, U_open.isClosed_compl.measurableSet, x_in_U, ?_⟩\n      simp_all only [ne_eq, xor_false, id_eq, mem_compl_iff, not_true_eq_false, not_false_eq_true]\n\n"}
{"name":"Continuous.measurable","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Basic","initialProofState":"α : Type u_1\nγ : Type u_3\ninst✝⁵ : TopologicalSpace α\ninst✝⁴ : MeasurableSpace α\ninst✝³ : OpensMeasurableSpace α\ninst✝² : TopologicalSpace γ\ninst✝¹ : MeasurableSpace γ\ninst✝ : BorelSpace γ\nf : α → γ\nhf : Continuous f\n⊢ Measurable f","decl":"/-- A continuous function from an `OpensMeasurableSpace` to a `BorelSpace`\nis measurable. -/\n@[fun_prop]\ntheorem Continuous.measurable {f : α → γ} (hf : Continuous f) : Measurable f :=\n  hf.borel_measurable.mono OpensMeasurableSpace.borel_le (le_of_eq <| BorelSpace.measurable_eq)\n\n"}
{"name":"Continuous.aemeasurable","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Basic","initialProofState":"α : Type u_1\nγ : Type u_3\ninst✝⁵ : TopologicalSpace α\ninst✝⁴ : MeasurableSpace α\ninst✝³ : OpensMeasurableSpace α\ninst✝² : TopologicalSpace γ\ninst✝¹ : MeasurableSpace γ\ninst✝ : BorelSpace γ\nf : α → γ\nh : Continuous f\nμ : MeasureTheory.Measure α\n⊢ AEMeasurable f μ","decl":"/-- A continuous function from an `OpensMeasurableSpace` to a `BorelSpace`\nis ae-measurable. -/\n@[fun_prop]\ntheorem Continuous.aemeasurable {f : α → γ} (h : Continuous f) {μ : Measure α} : AEMeasurable f μ :=\n  h.measurable.aemeasurable\n\n"}
{"name":"IsClosedEmbedding.measurable","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Basic","initialProofState":"α : Type u_1\nγ : Type u_3\ninst✝⁵ : TopologicalSpace α\ninst✝⁴ : MeasurableSpace α\ninst✝³ : OpensMeasurableSpace α\ninst✝² : TopologicalSpace γ\ninst✝¹ : MeasurableSpace γ\ninst✝ : BorelSpace γ\nf : α → γ\nhf : Topology.IsClosedEmbedding f\n⊢ Measurable f","decl":"theorem IsClosedEmbedding.measurable {f : α → γ} (hf : IsClosedEmbedding f) : Measurable f :=\n  hf.continuous.measurable\n\n"}
{"name":"ClosedEmbedding.measurable","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Basic","initialProofState":"α : Type u_1\nγ : Type u_3\ninst✝⁵ : TopologicalSpace α\ninst✝⁴ : MeasurableSpace α\ninst✝³ : OpensMeasurableSpace α\ninst✝² : TopologicalSpace γ\ninst✝¹ : MeasurableSpace γ\ninst✝ : BorelSpace γ\nf : α → γ\nhf : Topology.IsClosedEmbedding f\n⊢ Measurable f","decl":"@[deprecated (since := \"2024-10-20\")]\nalias ClosedEmbedding.measurable := IsClosedEmbedding.measurable\n\n"}
{"name":"ContinuousOn.measurable_piecewise","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Basic","initialProofState":"α : Type u_1\nγ : Type u_3\ninst✝⁶ : TopologicalSpace α\ninst✝⁵ : MeasurableSpace α\ninst✝⁴ : OpensMeasurableSpace α\ninst✝³ : TopologicalSpace γ\ninst✝² : MeasurableSpace γ\ninst✝¹ : BorelSpace γ\nf g : α → γ\ns : Set α\ninst✝ : (j : α) → Decidable (Membership.mem s j)\nhf : ContinuousOn f s\nhg : ContinuousOn g (HasCompl.compl s)\nhs : MeasurableSet s\n⊢ Measurable (s.piecewise f g)","decl":"/-- If a function is defined piecewise in terms of functions which are continuous on their\nrespective pieces, then it is measurable. -/\ntheorem ContinuousOn.measurable_piecewise {f g : α → γ} {s : Set α} [∀ j : α, Decidable (j ∈ s)]\n    (hf : ContinuousOn f s) (hg : ContinuousOn g sᶜ) (hs : MeasurableSet s) :\n    Measurable (s.piecewise f g) := by\n  refine measurable_of_isOpen fun t ht => ?_\n  rw [piecewise_preimage, Set.ite]\n  apply MeasurableSet.union\n  · rcases _root_.continuousOn_iff'.1 hf t ht with ⟨u, u_open, hu⟩\n    rw [hu]\n    exact u_open.measurableSet.inter hs\n  · rcases _root_.continuousOn_iff'.1 hg t ht with ⟨u, u_open, hu⟩\n    rw [diff_eq_compl_inter, inter_comm, hu]\n    exact u_open.measurableSet.inter hs.compl\n\n"}
{"name":"ContinuousAdd.measurableAdd","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Basic","initialProofState":"γ : Type u_3\ninst✝⁴ : TopologicalSpace γ\ninst✝³ : MeasurableSpace γ\ninst✝² : BorelSpace γ\ninst✝¹ : Add γ\ninst✝ : ContinuousAdd γ\n⊢ MeasurableAdd γ","decl":"@[to_additive]\ninstance (priority := 100) ContinuousMul.measurableMul [Mul γ] [ContinuousMul γ] :\n    MeasurableMul γ where\n  measurable_const_mul _ := (continuous_const.mul continuous_id).measurable\n  measurable_mul_const _ := (continuous_id.mul continuous_const).measurable\n\n"}
{"name":"ContinuousMul.measurableMul","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Basic","initialProofState":"γ : Type u_3\ninst✝⁴ : TopologicalSpace γ\ninst✝³ : MeasurableSpace γ\ninst✝² : BorelSpace γ\ninst✝¹ : Mul γ\ninst✝ : ContinuousMul γ\n⊢ MeasurableMul γ","decl":"@[to_additive]\ninstance (priority := 100) ContinuousMul.measurableMul [Mul γ] [ContinuousMul γ] :\n    MeasurableMul γ where\n  measurable_const_mul _ := (continuous_const.mul continuous_id).measurable\n  measurable_mul_const _ := (continuous_id.mul continuous_const).measurable\n\n"}
{"name":"ContinuousSub.measurableSub","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Basic","initialProofState":"γ : Type u_3\ninst✝⁴ : TopologicalSpace γ\ninst✝³ : MeasurableSpace γ\ninst✝² : BorelSpace γ\ninst✝¹ : Sub γ\ninst✝ : ContinuousSub γ\n⊢ MeasurableSub γ","decl":"instance (priority := 100) ContinuousSub.measurableSub [Sub γ] [ContinuousSub γ] :\n    MeasurableSub γ where\n  measurable_const_sub _ := (continuous_const.sub continuous_id).measurable\n  measurable_sub_const _ := (continuous_id.sub continuous_const).measurable\n\n"}
{"name":"ContinuousNeg.measurableNeg","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Basic","initialProofState":"γ : Type u_3\ninst✝⁴ : TopologicalSpace γ\ninst✝³ : MeasurableSpace γ\ninst✝² : BorelSpace γ\ninst✝¹ : Neg γ\ninst✝ : ContinuousNeg γ\n⊢ MeasurableNeg γ","decl":"@[to_additive]\ninstance (priority := 100) ContinuousInv.measurableInv [Inv γ] [ContinuousInv γ] :\n    MeasurableInv γ := ⟨continuous_inv.measurable⟩\n\n"}
{"name":"ContinuousInv.measurableInv","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Basic","initialProofState":"γ : Type u_3\ninst✝⁴ : TopologicalSpace γ\ninst✝³ : MeasurableSpace γ\ninst✝² : BorelSpace γ\ninst✝¹ : Inv γ\ninst✝ : ContinuousInv γ\n⊢ MeasurableInv γ","decl":"@[to_additive]\ninstance (priority := 100) ContinuousInv.measurableInv [Inv γ] [ContinuousInv γ] :\n    MeasurableInv γ := ⟨continuous_inv.measurable⟩\n\n"}
{"name":"ContinuousVAdd.measurableVAdd","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Basic","initialProofState":"M : Type u_7\nα : Type u_8\ninst✝⁷ : TopologicalSpace M\ninst✝⁶ : TopologicalSpace α\ninst✝⁵ : MeasurableSpace M\ninst✝⁴ : MeasurableSpace α\ninst✝³ : OpensMeasurableSpace M\ninst✝² : BorelSpace α\ninst✝¹ : VAdd M α\ninst✝ : ContinuousVAdd M α\n⊢ MeasurableVAdd M α","decl":"@[to_additive]\ninstance (priority := 100) ContinuousSMul.measurableSMul {M α} [TopologicalSpace M]\n    [TopologicalSpace α] [MeasurableSpace M] [MeasurableSpace α] [OpensMeasurableSpace M]\n    [BorelSpace α] [SMul M α] [ContinuousSMul M α] : MeasurableSMul M α :=\n  ⟨fun _ => (continuous_const_smul _).measurable, fun _ =>\n    (continuous_id.smul continuous_const).measurable⟩\n\n"}
{"name":"ContinuousSMul.measurableSMul","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Basic","initialProofState":"M : Type u_7\nα : Type u_8\ninst✝⁷ : TopologicalSpace M\ninst✝⁶ : TopologicalSpace α\ninst✝⁵ : MeasurableSpace M\ninst✝⁴ : MeasurableSpace α\ninst✝³ : OpensMeasurableSpace M\ninst✝² : BorelSpace α\ninst✝¹ : SMul M α\ninst✝ : ContinuousSMul M α\n⊢ MeasurableSMul M α","decl":"@[to_additive]\ninstance (priority := 100) ContinuousSMul.measurableSMul {M α} [TopologicalSpace M]\n    [TopologicalSpace α] [MeasurableSpace M] [MeasurableSpace α] [OpensMeasurableSpace M]\n    [BorelSpace α] [SMul M α] [ContinuousSMul M α] : MeasurableSMul M α :=\n  ⟨fun _ => (continuous_const_smul _).measurable, fun _ =>\n    (continuous_id.smul continuous_const).measurable⟩\n\n"}
{"name":"Homeomorph.measurable","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Basic","initialProofState":"α : Type u_1\nγ : Type u_3\ninst✝⁵ : TopologicalSpace α\ninst✝⁴ : MeasurableSpace α\ninst✝³ : OpensMeasurableSpace α\ninst✝² : TopologicalSpace γ\ninst✝¹ : MeasurableSpace γ\ninst✝ : BorelSpace γ\nh : Homeomorph α γ\n⊢ Measurable ⇑h","decl":"@[measurability]\nprotected theorem Homeomorph.measurable (h : α ≃ₜ γ) : Measurable h :=\n  h.continuous.measurable\n\n"}
{"name":"Homeomorph.measurableEmbedding","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Basic","initialProofState":"γ : Type u_3\nγ₂ : Type u_4\ninst✝⁵ : TopologicalSpace γ\ninst✝⁴ : MeasurableSpace γ\ninst✝³ : BorelSpace γ\ninst✝² : TopologicalSpace γ₂\ninst✝¹ : MeasurableSpace γ₂\ninst✝ : BorelSpace γ₂\nh : Homeomorph γ γ₂\n⊢ MeasurableEmbedding ⇑h","decl":"lemma Homeomorph.measurableEmbedding (h : γ ≃ₜ γ₂) : MeasurableEmbedding h :=\n  h.toMeasurableEquiv.measurableEmbedding\n\n"}
{"name":"Homeomorph.toMeasurableEquiv_coe","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Basic","initialProofState":"γ : Type u_3\nγ₂ : Type u_4\ninst✝⁵ : TopologicalSpace γ\ninst✝⁴ : MeasurableSpace γ\ninst✝³ : BorelSpace γ\ninst✝² : TopologicalSpace γ₂\ninst✝¹ : MeasurableSpace γ₂\ninst✝ : BorelSpace γ₂\nh : Homeomorph γ γ₂\n⊢ Eq ⇑h.toMeasurableEquiv ⇑h","decl":"@[simp]\ntheorem Homeomorph.toMeasurableEquiv_coe (h : γ ≃ₜ γ₂) : (h.toMeasurableEquiv : γ → γ₂) = h :=\n  rfl\n\n"}
{"name":"Homeomorph.toMeasurableEquiv_symm_coe","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Basic","initialProofState":"γ : Type u_3\nγ₂ : Type u_4\ninst✝⁵ : TopologicalSpace γ\ninst✝⁴ : MeasurableSpace γ\ninst✝³ : BorelSpace γ\ninst✝² : TopologicalSpace γ₂\ninst✝¹ : MeasurableSpace γ₂\ninst✝ : BorelSpace γ₂\nh : Homeomorph γ γ₂\n⊢ Eq ⇑h.toMeasurableEquiv.symm ⇑h.symm","decl":"@[simp]\ntheorem Homeomorph.toMeasurableEquiv_symm_coe (h : γ ≃ₜ γ₂) :\n    (h.toMeasurableEquiv.symm : γ₂ → γ) = h.symm :=\n  rfl\n\n"}
{"name":"ContinuousMap.measurable","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Basic","initialProofState":"α : Type u_1\nγ : Type u_3\ninst✝⁵ : TopologicalSpace α\ninst✝⁴ : MeasurableSpace α\ninst✝³ : OpensMeasurableSpace α\ninst✝² : TopologicalSpace γ\ninst✝¹ : MeasurableSpace γ\ninst✝ : BorelSpace γ\nf : ContinuousMap α γ\n⊢ Measurable ⇑f","decl":"@[measurability]\ntheorem ContinuousMap.measurable (f : C(α, γ)) : Measurable f :=\n  f.continuous.measurable\n\n"}
{"name":"measurable_of_continuousOn_compl_singleton","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Basic","initialProofState":"α : Type u_1\nγ : Type u_3\ninst✝⁶ : TopologicalSpace α\ninst✝⁵ : MeasurableSpace α\ninst✝⁴ : OpensMeasurableSpace α\ninst✝³ : TopologicalSpace γ\ninst✝² : MeasurableSpace γ\ninst✝¹ : BorelSpace γ\ninst✝ : T1Space α\nf : α → γ\na : α\nhf : ContinuousOn f (HasCompl.compl (Singleton.singleton a))\n⊢ Measurable f","decl":"@[fun_prop]\ntheorem measurable_of_continuousOn_compl_singleton [T1Space α] {f : α → γ} (a : α)\n    (hf : ContinuousOn f {a}ᶜ) : Measurable f :=\n  measurable_of_measurable_on_compl_singleton a\n    (continuousOn_iff_continuous_restrict.1 hf).measurable\n\n"}
{"name":"Continuous.measurable2","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nδ : Type u_5\ninst✝¹⁰ : TopologicalSpace α\ninst✝⁹ : MeasurableSpace α\ninst✝⁸ : OpensMeasurableSpace α\ninst✝⁷ : TopologicalSpace β\ninst✝⁶ : MeasurableSpace β\ninst✝⁵ : OpensMeasurableSpace β\ninst✝⁴ : TopologicalSpace γ\ninst✝³ : MeasurableSpace γ\ninst✝² : BorelSpace γ\ninst✝¹ : MeasurableSpace δ\ninst✝ : SecondCountableTopologyEither α β\nf : δ → α\ng : δ → β\nc : α → β → γ\nh : Continuous fun p => c p.1 p.2\nhf : Measurable f\nhg : Measurable g\n⊢ Measurable fun a => c (f a) (g a)","decl":"theorem Continuous.measurable2 [SecondCountableTopologyEither α β] {f : δ → α}\n    {g : δ → β} {c : α → β → γ} (h : Continuous fun p : α × β => c p.1 p.2) (hf : Measurable f)\n    (hg : Measurable g) : Measurable fun a => c (f a) (g a) :=\n  h.measurable.comp (hf.prod_mk hg)\n\n"}
{"name":"Continuous.aemeasurable2","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nδ : Type u_5\ninst✝¹⁰ : TopologicalSpace α\ninst✝⁹ : MeasurableSpace α\ninst✝⁸ : OpensMeasurableSpace α\ninst✝⁷ : TopologicalSpace β\ninst✝⁶ : MeasurableSpace β\ninst✝⁵ : OpensMeasurableSpace β\ninst✝⁴ : TopologicalSpace γ\ninst✝³ : MeasurableSpace γ\ninst✝² : BorelSpace γ\ninst✝¹ : MeasurableSpace δ\ninst✝ : SecondCountableTopologyEither α β\nf : δ → α\ng : δ → β\nc : α → β → γ\nμ : MeasureTheory.Measure δ\nh : Continuous fun p => c p.1 p.2\nhf : AEMeasurable f μ\nhg : AEMeasurable g μ\n⊢ AEMeasurable (fun a => c (f a) (g a)) μ","decl":"theorem Continuous.aemeasurable2 [SecondCountableTopologyEither α β]\n    {f : δ → α} {g : δ → β} {c : α → β → γ} {μ : Measure δ}\n    (h : Continuous fun p : α × β => c p.1 p.2) (hf : AEMeasurable f μ) (hg : AEMeasurable g μ) :\n    AEMeasurable (fun a => c (f a) (g a)) μ :=\n  h.measurable.comp_aemeasurable (hf.prod_mk hg)\n\n"}
{"name":"HasContinuousInv₀.measurableInv","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Basic","initialProofState":"γ : Type u_3\ninst✝⁵ : TopologicalSpace γ\ninst✝⁴ : MeasurableSpace γ\ninst✝³ : BorelSpace γ\ninst✝² : GroupWithZero γ\ninst✝¹ : T1Space γ\ninst✝ : HasContinuousInv₀ γ\n⊢ MeasurableInv γ","decl":"instance (priority := 100) HasContinuousInv₀.measurableInv [GroupWithZero γ] [T1Space γ]\n    [HasContinuousInv₀ γ] : MeasurableInv γ :=\n  ⟨measurable_of_continuousOn_compl_singleton 0 continuousOn_inv₀⟩\n\n"}
{"name":"ContinuousMul.measurableMul₂","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Basic","initialProofState":"γ : Type u_3\ninst✝⁵ : TopologicalSpace γ\ninst✝⁴ : MeasurableSpace γ\ninst✝³ : BorelSpace γ\ninst✝² : SecondCountableTopology γ\ninst✝¹ : Mul γ\ninst✝ : ContinuousMul γ\n⊢ MeasurableMul₂ γ","decl":"@[to_additive]\ninstance (priority := 100) ContinuousMul.measurableMul₂ [SecondCountableTopology γ] [Mul γ]\n    [ContinuousMul γ] : MeasurableMul₂ γ :=\n  ⟨continuous_mul.measurable⟩\n\n"}
{"name":"ContinuousAdd.measurableMul₂","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Basic","initialProofState":"γ : Type u_3\ninst✝⁵ : TopologicalSpace γ\ninst✝⁴ : MeasurableSpace γ\ninst✝³ : BorelSpace γ\ninst✝² : SecondCountableTopology γ\ninst✝¹ : Add γ\ninst✝ : ContinuousAdd γ\n⊢ MeasurableAdd₂ γ","decl":"@[to_additive]\ninstance (priority := 100) ContinuousMul.measurableMul₂ [SecondCountableTopology γ] [Mul γ]\n    [ContinuousMul γ] : MeasurableMul₂ γ :=\n  ⟨continuous_mul.measurable⟩\n\n"}
{"name":"ContinuousSub.measurableSub₂","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Basic","initialProofState":"γ : Type u_3\ninst✝⁵ : TopologicalSpace γ\ninst✝⁴ : MeasurableSpace γ\ninst✝³ : BorelSpace γ\ninst✝² : SecondCountableTopology γ\ninst✝¹ : Sub γ\ninst✝ : ContinuousSub γ\n⊢ MeasurableSub₂ γ","decl":"instance (priority := 100) ContinuousSub.measurableSub₂ [SecondCountableTopology γ] [Sub γ]\n    [ContinuousSub γ] : MeasurableSub₂ γ :=\n  ⟨continuous_sub.measurable⟩\n\n"}
{"name":"ContinuousSMul.measurableSMul₂","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Basic","initialProofState":"M : Type u_7\nα : Type u_8\ninst✝⁸ : TopologicalSpace M\ninst✝⁷ : MeasurableSpace M\ninst✝⁶ : OpensMeasurableSpace M\ninst✝⁵ : TopologicalSpace α\ninst✝⁴ : SecondCountableTopologyEither M α\ninst✝³ : MeasurableSpace α\ninst✝² : BorelSpace α\ninst✝¹ : SMul M α\ninst✝ : ContinuousSMul M α\n⊢ MeasurableSMul₂ M α","decl":"instance (priority := 100) ContinuousSMul.measurableSMul₂ {M α} [TopologicalSpace M]\n    [MeasurableSpace M] [OpensMeasurableSpace M] [TopologicalSpace α]\n    [SecondCountableTopologyEither M α] [MeasurableSpace α] [BorelSpace α] [SMul M α]\n    [ContinuousSMul M α] : MeasurableSMul₂ M α :=\n  ⟨continuous_smul.measurable⟩\n\n"}
{"name":"pi_le_borel_pi","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Basic","initialProofState":"ι : Type u_6\nπ : ι → Type u_7\ninst✝² : (i : ι) → TopologicalSpace (π i)\ninst✝¹ : (i : ι) → MeasurableSpace (π i)\ninst✝ : ∀ (i : ι), BorelSpace (π i)\n⊢ LE.le MeasurableSpace.pi (borel ((i : ι) → π i))","decl":"theorem pi_le_borel_pi {ι : Type*} {π : ι → Type*} [∀ i, TopologicalSpace (π i)]\n    [∀ i, MeasurableSpace (π i)] [∀ i, BorelSpace (π i)] :\n      MeasurableSpace.pi ≤ borel (∀ i, π i) := by\n  have : ‹∀ i, MeasurableSpace (π i)› = fun i => borel (π i) :=\n    funext fun i => BorelSpace.measurable_eq\n  rw [this]\n  exact iSup_le fun i => comap_le_iff_le_map.2 <| (continuous_apply i).borel_measurable\n\n"}
{"name":"prod_le_borel_prod","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝⁵ : TopologicalSpace α\ninst✝⁴ : MeasurableSpace α\ninst✝³ : BorelSpace α\ninst✝² : TopologicalSpace β\ninst✝¹ : MeasurableSpace β\ninst✝ : BorelSpace β\n⊢ LE.le Prod.instMeasurableSpace (borel (Prod α β))","decl":"theorem prod_le_borel_prod : Prod.instMeasurableSpace ≤ borel (α × β) := by\n  rw [‹BorelSpace α›.measurable_eq, ‹BorelSpace β›.measurable_eq]\n  refine sup_le ?_ ?_\n  · exact comap_le_iff_le_map.mpr continuous_fst.borel_measurable\n  · exact comap_le_iff_le_map.mpr continuous_snd.borel_measurable\n\n"}
{"name":"Pi.borelSpace","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Basic","initialProofState":"ι : Type u_6\nπ : ι → Type u_7\ninst✝⁴ : Countable ι\ninst✝³ : (i : ι) → TopologicalSpace (π i)\ninst✝² : (i : ι) → MeasurableSpace (π i)\ninst✝¹ : ∀ (i : ι), SecondCountableTopology (π i)\ninst✝ : ∀ (i : ι), BorelSpace (π i)\n⊢ BorelSpace ((i : ι) → π i)","decl":"instance Pi.borelSpace {ι : Type*} {π : ι → Type*} [Countable ι] [∀ i, TopologicalSpace (π i)]\n    [∀ i, MeasurableSpace (π i)] [∀ i, SecondCountableTopology (π i)] [∀ i, BorelSpace (π i)] :\n    BorelSpace (∀ i, π i) :=\n  ⟨le_antisymm pi_le_borel_pi OpensMeasurableSpace.borel_le⟩\n\n"}
{"name":"Prod.borelSpace","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝⁶ : TopologicalSpace α\ninst✝⁵ : MeasurableSpace α\ninst✝⁴ : BorelSpace α\ninst✝³ : TopologicalSpace β\ninst✝² : MeasurableSpace β\ninst✝¹ : BorelSpace β\ninst✝ : SecondCountableTopologyEither α β\n⊢ BorelSpace (Prod α β)","decl":"instance Prod.borelSpace [SecondCountableTopologyEither α β] :\n    BorelSpace (α × β) :=\n  ⟨le_antisymm prod_le_borel_prod OpensMeasurableSpace.borel_le⟩\n\n"}
{"name":"MeasurableEmbedding.borelSpace","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Basic","initialProofState":"α : Type u_6\nβ : Type u_7\ninst✝³ : MeasurableSpace α\ninst✝² : TopologicalSpace α\ninst✝¹ : MeasurableSpace β\ninst✝ : TopologicalSpace β\nhβ : BorelSpace β\ne : α → β\nh'e : MeasurableEmbedding e\nh''e : Topology.IsInducing e\n⊢ BorelSpace α","decl":"/-- Given a measurable embedding to a Borel space which is also a topological embedding, then the\nsource space is also a Borel space. -/\nlemma MeasurableEmbedding.borelSpace {α β : Type*} [MeasurableSpace α] [TopologicalSpace α]\n    [MeasurableSpace β] [TopologicalSpace β] [hβ : BorelSpace β] {e : α → β}\n    (h'e : MeasurableEmbedding e) (h''e : IsInducing e) :\n    BorelSpace α := by\n  constructor\n  have : MeasurableSpace.comap e (borel β) = ‹_› := by simpa [hβ.measurable_eq] using h'e.comap_eq\n  rw [← this, ← borel_comap, h''e.eq_induced]\n\n"}
{"name":"ULift.instBorelSpace","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Basic","initialProofState":"α : Type u_1\ninst✝² : TopologicalSpace α\ninst✝¹ : MeasurableSpace α\ninst✝ : BorelSpace α\n⊢ BorelSpace (ULift.{u_6, u_1} α)","decl":"instance _root_.ULift.instBorelSpace : BorelSpace (ULift α) :=\n  MeasurableEquiv.ulift.measurableEmbedding.borelSpace Homeomorph.ulift.isInducing\n\n"}
{"name":"DiscreteMeasurableSpace.toBorelSpace","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Basic","initialProofState":"α : Type u_6\ninst✝³ : TopologicalSpace α\ninst✝² : DiscreteTopology α\ninst✝¹ : MeasurableSpace α\ninst✝ : DiscreteMeasurableSpace α\n⊢ BorelSpace α","decl":"instance DiscreteMeasurableSpace.toBorelSpace {α : Type*} [TopologicalSpace α] [DiscreteTopology α]\n    [MeasurableSpace α] [DiscreteMeasurableSpace α] : BorelSpace α := by\n  constructor; ext; simp [MeasurableSpace.measurableSet_generateFrom, MeasurableSet.of_discrete]\n\n"}
{"name":"Topology.IsEmbedding.measurableEmbedding","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝⁵ : TopologicalSpace α\ninst✝⁴ : MeasurableSpace α\ninst✝³ : BorelSpace α\ninst✝² : TopologicalSpace β\ninst✝¹ : MeasurableSpace β\ninst✝ : BorelSpace β\nf : α → β\nh₁ : Topology.IsEmbedding f\nh₂ : MeasurableSet (Set.range f)\n⊢ MeasurableEmbedding f","decl":"protected theorem Topology.IsEmbedding.measurableEmbedding {f : α → β} (h₁ : IsEmbedding f)\n    (h₂ : MeasurableSet (range f)) : MeasurableEmbedding f :=\n  show MeasurableEmbedding\n      (((↑) : range f → β) ∘ (Homeomorph.ofIsEmbedding f h₁).toMeasurableEquiv) from\n    (MeasurableEmbedding.subtype_coe h₂).comp (MeasurableEquiv.measurableEmbedding _)\n\n"}
{"name":"Embedding.measurableEmbedding","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝⁵ : TopologicalSpace α\ninst✝⁴ : MeasurableSpace α\ninst✝³ : BorelSpace α\ninst✝² : TopologicalSpace β\ninst✝¹ : MeasurableSpace β\ninst✝ : BorelSpace β\nf : α → β\nh₁ : Topology.IsEmbedding f\nh₂ : MeasurableSet (Set.range f)\n⊢ MeasurableEmbedding f","decl":"@[deprecated (since := \"2024-10-26\")]\nalias Embedding.measurableEmbedding := IsEmbedding.measurableEmbedding\n\n"}
{"name":"Topology.IsClosedEmbedding.measurableEmbedding","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝⁵ : TopologicalSpace α\ninst✝⁴ : MeasurableSpace α\ninst✝³ : BorelSpace α\ninst✝² : TopologicalSpace β\ninst✝¹ : MeasurableSpace β\ninst✝ : BorelSpace β\nf : α → β\nh : Topology.IsClosedEmbedding f\n⊢ MeasurableEmbedding f","decl":"protected theorem Topology.IsClosedEmbedding.measurableEmbedding {f : α → β}\n    (h : IsClosedEmbedding f) : MeasurableEmbedding f :=\n  h.isEmbedding.measurableEmbedding h.isClosed_range.measurableSet\n\n"}
{"name":"ClosedEmbedding.measurableEmbedding","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝⁵ : TopologicalSpace α\ninst✝⁴ : MeasurableSpace α\ninst✝³ : BorelSpace α\ninst✝² : TopologicalSpace β\ninst✝¹ : MeasurableSpace β\ninst✝ : BorelSpace β\nf : α → β\nh : Topology.IsClosedEmbedding f\n⊢ MeasurableEmbedding f","decl":"@[deprecated (since := \"2024-10-20\")]\nalias ClosedEmbedding.measurableEmbedding := IsClosedEmbedding.measurableEmbedding\n\n"}
{"name":"Topology.IsOpenEmbedding.measurableEmbedding","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝⁵ : TopologicalSpace α\ninst✝⁴ : MeasurableSpace α\ninst✝³ : BorelSpace α\ninst✝² : TopologicalSpace β\ninst✝¹ : MeasurableSpace β\ninst✝ : BorelSpace β\nf : α → β\nh : Topology.IsOpenEmbedding f\n⊢ MeasurableEmbedding f","decl":"protected theorem Topology.IsOpenEmbedding.measurableEmbedding {f : α → β} (h : IsOpenEmbedding f) :\n    MeasurableEmbedding f :=\n  h.isEmbedding.measurableEmbedding h.isOpen_range.measurableSet\n\n"}
{"name":"OpenEmbedding.measurableEmbedding","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝⁵ : TopologicalSpace α\ninst✝⁴ : MeasurableSpace α\ninst✝³ : BorelSpace α\ninst✝² : TopologicalSpace β\ninst✝¹ : MeasurableSpace β\ninst✝ : BorelSpace β\nf : α → β\nh : Topology.IsOpenEmbedding f\n⊢ MeasurableEmbedding f","decl":"@[deprecated (since := \"2024-10-18\")]\nalias OpenEmbedding.measurableEmbedding := IsOpenEmbedding.measurableEmbedding\n\n"}
{"name":"Empty.borelSpace","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Basic","initialProofState":"⊢ BorelSpace Empty","decl":"instance Empty.borelSpace : BorelSpace Empty :=\n  ⟨borel_eq_top_of_discrete.symm⟩\n\n"}
{"name":"Unit.borelSpace","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Basic","initialProofState":"⊢ BorelSpace Unit","decl":"instance Unit.borelSpace : BorelSpace Unit :=\n  ⟨borel_eq_top_of_discrete.symm⟩\n\n"}
{"name":"Bool.borelSpace","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Basic","initialProofState":"⊢ BorelSpace Bool","decl":"instance Bool.borelSpace : BorelSpace Bool :=\n  ⟨borel_eq_top_of_discrete.symm⟩\n\n"}
{"name":"Nat.borelSpace","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Basic","initialProofState":"⊢ BorelSpace Nat","decl":"instance Nat.borelSpace : BorelSpace ℕ :=\n  ⟨borel_eq_top_of_discrete.symm⟩\n\n"}
{"name":"Int.borelSpace","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Basic","initialProofState":"⊢ BorelSpace Int","decl":"instance Int.borelSpace : BorelSpace ℤ :=\n  ⟨borel_eq_top_of_discrete.symm⟩\n\n"}
{"name":"Rat.borelSpace","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Basic","initialProofState":"⊢ BorelSpace Rat","decl":"instance Rat.borelSpace : BorelSpace ℚ :=\n  ⟨borel_eq_top_of_countable.symm⟩\n\n/- Instances on `Real` and `Complex` are special cases of `RCLike` but without these instances,\nLean fails to prove `BorelSpace (ι → ℝ)`, so we leave them here. -/\n"}
{"name":"Real.borelSpace","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Basic","initialProofState":"⊢ BorelSpace Real","decl":"instance Real.borelSpace : BorelSpace ℝ :=\n  ⟨rfl⟩\n\n"}
{"name":"NNReal.borelSpace","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Basic","initialProofState":"⊢ BorelSpace NNReal","decl":"instance NNReal.borelSpace : BorelSpace ℝ≥0 :=\n  Subtype.borelSpace _\n\n"}
{"name":"ENNReal.borelSpace","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Basic","initialProofState":"⊢ BorelSpace ENNReal","decl":"instance ENNReal.borelSpace : BorelSpace ℝ≥0∞ :=\n  ⟨rfl⟩\n\n"}
{"name":"EReal.borelSpace","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Basic","initialProofState":"⊢ BorelSpace EReal","decl":"instance EReal.borelSpace : BorelSpace EReal :=\n  ⟨rfl⟩\n\n"}
