{"name":"Commute.add_pow_prime_pow_eq","module":"Mathlib.Algebra.CharP.Lemmas","initialProofState":"R : Type u_1\ninst✝ : Semiring R\np : Nat\nhp : Nat.Prime p\nx y : R\nh : Commute x y\nn : Nat\n⊢ Eq (HPow.hPow (HAdd.hAdd x y) (HPow.hPow p n)) (HAdd.hAdd (HAdd.hAdd (HPow.hPow x (HPow.hPow p n)) (HPow.hPow y (HPow.hPow p n))) (HMul.hMul (↑p) ((Finset.Ioo 0 (HPow.hPow p n)).sum fun k => HMul.hMul (HMul.hMul (HPow.hPow x k) (HPow.hPow y (HSub.hSub (HPow.hPow p n) k))) ↑(HDiv.hDiv ((HPow.hPow p n).choose k) p))))","decl":"protected theorem add_pow_prime_pow_eq (h : Commute x y) (n : ℕ) :\n    (x + y) ^ p ^ n =\n      x ^ p ^ n + y ^ p ^ n +\n        p * ∑ k ∈ Ioo 0 (p ^ n), x ^ k * y ^ (p ^ n - k) * ↑((p ^ n).choose k / p) := by\n  trans x ^ p ^ n + y ^ p ^ n + ∑ k ∈ Ioo 0 (p ^ n), x ^ k * y ^ (p ^ n - k) * (p ^ n).choose k\n  · simp_rw [h.add_pow, ← Nat.Ico_zero_eq_range, Nat.Ico_succ_right, Icc_eq_cons_Ico (zero_le _),\n      Finset.sum_cons, Ico_eq_cons_Ioo (pow_pos hp.pos _), Finset.sum_cons, tsub_self, tsub_zero,\n      pow_zero, Nat.choose_zero_right, Nat.choose_self, Nat.cast_one, mul_one, one_mul, ← add_assoc]\n  · congr 1\n    simp_rw [Finset.mul_sum, Nat.cast_comm, mul_assoc _ _ (p : R), ← Nat.cast_mul]\n    refine Finset.sum_congr rfl fun i hi => ?_\n    rw [mem_Ioo] at hi\n    rw [Nat.div_mul_cancel (hp.dvd_choose_pow hi.1.ne' hi.2.ne)]\n\n"}
{"name":"Commute.add_pow_prime_eq","module":"Mathlib.Algebra.CharP.Lemmas","initialProofState":"R : Type u_1\ninst✝ : Semiring R\np : Nat\nhp : Nat.Prime p\nx y : R\nh : Commute x y\n⊢ Eq (HPow.hPow (HAdd.hAdd x y) p) (HAdd.hAdd (HAdd.hAdd (HPow.hPow x p) (HPow.hPow y p)) (HMul.hMul (↑p) ((Finset.Ioo 0 p).sum fun k => HMul.hMul (HMul.hMul (HPow.hPow x k) (HPow.hPow y (HSub.hSub p k))) ↑(HDiv.hDiv (p.choose k) p))))","decl":"protected theorem add_pow_prime_eq (h : Commute x y) :\n    (x + y) ^ p =\n      x ^ p + y ^ p + p * ∑ k ∈ Finset.Ioo 0 p, x ^ k * y ^ (p - k) * ↑(p.choose k / p) := by\n  simpa using h.add_pow_prime_pow_eq hp 1\n\n"}
{"name":"Commute.exists_add_pow_prime_pow_eq","module":"Mathlib.Algebra.CharP.Lemmas","initialProofState":"R : Type u_1\ninst✝ : Semiring R\np : Nat\nhp : Nat.Prime p\nx y : R\nh : Commute x y\nn : Nat\n⊢ Exists fun r => Eq (HPow.hPow (HAdd.hAdd x y) (HPow.hPow p n)) (HAdd.hAdd (HAdd.hAdd (HPow.hPow x (HPow.hPow p n)) (HPow.hPow y (HPow.hPow p n))) (HMul.hMul (↑p) r))","decl":"protected theorem exists_add_pow_prime_pow_eq (h : Commute x y) (n : ℕ) :\n    ∃ r, (x + y) ^ p ^ n = x ^ p ^ n + y ^ p ^ n + p * r :=\n  ⟨_, h.add_pow_prime_pow_eq hp n⟩\n\n"}
{"name":"Commute.exists_add_pow_prime_eq","module":"Mathlib.Algebra.CharP.Lemmas","initialProofState":"R : Type u_1\ninst✝ : Semiring R\np : Nat\nhp : Nat.Prime p\nx y : R\nh : Commute x y\n⊢ Exists fun r => Eq (HPow.hPow (HAdd.hAdd x y) p) (HAdd.hAdd (HAdd.hAdd (HPow.hPow x p) (HPow.hPow y p)) (HMul.hMul (↑p) r))","decl":"protected theorem exists_add_pow_prime_eq (h : Commute x y) :\n    ∃ r, (x + y) ^ p = x ^ p + y ^ p + p * r :=\n  ⟨_, h.add_pow_prime_eq hp⟩\n\n"}
{"name":"add_pow_prime_pow_eq","module":"Mathlib.Algebra.CharP.Lemmas","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\np : Nat\nhp : Nat.Prime p\nx y : R\nn : Nat\n⊢ Eq (HPow.hPow (HAdd.hAdd x y) (HPow.hPow p n)) (HAdd.hAdd (HAdd.hAdd (HPow.hPow x (HPow.hPow p n)) (HPow.hPow y (HPow.hPow p n))) (HMul.hMul (↑p) ((Finset.Ioo 0 (HPow.hPow p n)).sum fun k => HMul.hMul (HMul.hMul (HPow.hPow x k) (HPow.hPow y (HSub.hSub (HPow.hPow p n) k))) ↑(HDiv.hDiv ((HPow.hPow p n).choose k) p))))","decl":"theorem add_pow_prime_pow_eq :\n    (x + y) ^ p ^ n =\n      x ^ p ^ n + y ^ p ^ n +\n        p * ∑ k ∈ Finset.Ioo 0 (p ^ n), x ^ k * y ^ (p ^ n - k) * ↑((p ^ n).choose k / p) :=\n  (Commute.all x y).add_pow_prime_pow_eq hp n\n\n"}
{"name":"add_pow_prime_eq","module":"Mathlib.Algebra.CharP.Lemmas","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\np : Nat\nhp : Nat.Prime p\nx y : R\n⊢ Eq (HPow.hPow (HAdd.hAdd x y) p) (HAdd.hAdd (HAdd.hAdd (HPow.hPow x p) (HPow.hPow y p)) (HMul.hMul (↑p) ((Finset.Ioo 0 p).sum fun k => HMul.hMul (HMul.hMul (HPow.hPow x k) (HPow.hPow y (HSub.hSub p k))) ↑(HDiv.hDiv (p.choose k) p))))","decl":"theorem add_pow_prime_eq :\n    (x + y) ^ p =\n      x ^ p + y ^ p + p * ∑ k ∈ Finset.Ioo 0 p, x ^ k * y ^ (p - k) * ↑(p.choose k / p) :=\n  (Commute.all x y).add_pow_prime_eq hp\n\n"}
{"name":"exists_add_pow_prime_pow_eq","module":"Mathlib.Algebra.CharP.Lemmas","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\np : Nat\nhp : Nat.Prime p\nx y : R\nn : Nat\n⊢ Exists fun r => Eq (HPow.hPow (HAdd.hAdd x y) (HPow.hPow p n)) (HAdd.hAdd (HAdd.hAdd (HPow.hPow x (HPow.hPow p n)) (HPow.hPow y (HPow.hPow p n))) (HMul.hMul (↑p) r))","decl":"theorem exists_add_pow_prime_pow_eq :\n    ∃ r, (x + y) ^ p ^ n = x ^ p ^ n + y ^ p ^ n + p * r :=\n  (Commute.all x y).exists_add_pow_prime_pow_eq hp n\n\n"}
{"name":"exists_add_pow_prime_eq","module":"Mathlib.Algebra.CharP.Lemmas","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\np : Nat\nhp : Nat.Prime p\nx y : R\n⊢ Exists fun r => Eq (HPow.hPow (HAdd.hAdd x y) p) (HAdd.hAdd (HAdd.hAdd (HPow.hPow x p) (HPow.hPow y p)) (HMul.hMul (↑p) r))","decl":"theorem exists_add_pow_prime_eq :\n    ∃ r, (x + y) ^ p = x ^ p + y ^ p + p * r :=\n  (Commute.all x y).exists_add_pow_prime_eq hp\n\n"}
{"name":"add_pow_expChar_of_commute","module":"Mathlib.Algebra.CharP.Lemmas","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nx y : R\np : Nat\nhR : ExpChar R p\nh : Commute x y\n⊢ Eq (HPow.hPow (HAdd.hAdd x y) p) (HAdd.hAdd (HPow.hPow x p) (HPow.hPow y p))","decl":"lemma add_pow_expChar_of_commute (h : Commute x y) : (x + y) ^ p = x ^ p + y ^ p := by\n  obtain _ | hprime := hR\n  · simp only [pow_one]\n  · let ⟨r, hr⟩ := h.exists_add_pow_prime_eq hprime\n    simp [hr]\n\n"}
{"name":"add_pow_expChar_pow_of_commute","module":"Mathlib.Algebra.CharP.Lemmas","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nx y : R\np n : Nat\nhR : ExpChar R p\nh : Commute x y\n⊢ Eq (HPow.hPow (HAdd.hAdd x y) (HPow.hPow p n)) (HAdd.hAdd (HPow.hPow x (HPow.hPow p n)) (HPow.hPow y (HPow.hPow p n)))","decl":"lemma add_pow_expChar_pow_of_commute (h : Commute x y) :\n    (x + y) ^ p ^ n = x ^ p ^ n + y ^ p ^ n := by\n  obtain _ | hprime := hR\n  · simp only [one_pow, pow_one]\n  · let ⟨r, hr⟩ := h.exists_add_pow_prime_pow_eq hprime n\n    simp [hr]\n\n"}
{"name":"add_pow_eq_mul_pow_add_pow_div_expChar_of_commute","module":"Mathlib.Algebra.CharP.Lemmas","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nx y : R\np n : Nat\nhR : ExpChar R p\nh : Commute x y\n⊢ Eq (HPow.hPow (HAdd.hAdd x y) n) (HMul.hMul (HPow.hPow (HAdd.hAdd x y) (HMod.hMod n p)) (HPow.hPow (HAdd.hAdd (HPow.hPow x p) (HPow.hPow y p)) (HDiv.hDiv n p)))","decl":"lemma add_pow_eq_mul_pow_add_pow_div_expChar_of_commute (h : Commute x y) :\n    (x + y) ^ n = (x + y) ^ (n % p) * (x ^ p + y ^ p) ^ (n / p) := by\n  rw [← add_pow_expChar_of_commute _ h, ← pow_mul, ← pow_add, Nat.mod_add_div]\n\n"}
{"name":"add_pow_char_of_commute","module":"Mathlib.Algebra.CharP.Lemmas","initialProofState":"R : Type u_1\ninst✝¹ : Semiring R\nx y : R\np : Nat\nhp : Fact (Nat.Prime p)\ninst✝ : CharP R p\nh : Commute x y\n⊢ Eq (HPow.hPow (HAdd.hAdd x y) p) (HAdd.hAdd (HPow.hPow x p) (HPow.hPow y p))","decl":"lemma add_pow_char_of_commute (h : Commute x y) : (x + y) ^ p = x ^ p + y ^ p :=\n  add_pow_expChar_of_commute _ h\n\n"}
{"name":"add_pow_char_pow_of_commute","module":"Mathlib.Algebra.CharP.Lemmas","initialProofState":"R : Type u_1\ninst✝¹ : Semiring R\nx y : R\np n : Nat\nhp : Fact (Nat.Prime p)\ninst✝ : CharP R p\nh : Commute x y\n⊢ Eq (HPow.hPow (HAdd.hAdd x y) (HPow.hPow p n)) (HAdd.hAdd (HPow.hPow x (HPow.hPow p n)) (HPow.hPow y (HPow.hPow p n)))","decl":"lemma add_pow_char_pow_of_commute (h : Commute x y) : (x + y) ^ p ^ n = x ^ p ^ n + y ^ p ^ n :=\n  add_pow_expChar_pow_of_commute _ _ h\n\n"}
{"name":"add_pow_eq_mul_pow_add_pow_div_char_of_commute","module":"Mathlib.Algebra.CharP.Lemmas","initialProofState":"R : Type u_1\ninst✝¹ : Semiring R\nx y : R\np n : Nat\nhp : Fact (Nat.Prime p)\ninst✝ : CharP R p\nh : Commute x y\n⊢ Eq (HPow.hPow (HAdd.hAdd x y) n) (HMul.hMul (HPow.hPow (HAdd.hAdd x y) (HMod.hMod n p)) (HPow.hPow (HAdd.hAdd (HPow.hPow x p) (HPow.hPow y p)) (HDiv.hDiv n p)))","decl":"lemma add_pow_eq_mul_pow_add_pow_div_char_of_commute (h : Commute x y) :\n    (x + y) ^ n = (x + y) ^ (n % p) * (x ^ p + y ^ p) ^ (n / p) :=\n  add_pow_eq_mul_pow_add_pow_div_expChar_of_commute _ _ h\n\n"}
{"name":"add_pow_expChar","module":"Mathlib.Algebra.CharP.Lemmas","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\nx y : R\np : Nat\nhR : ExpChar R p\n⊢ Eq (HPow.hPow (HAdd.hAdd x y) p) (HAdd.hAdd (HPow.hPow x p) (HPow.hPow y p))","decl":"lemma add_pow_expChar : (x + y) ^ p = x ^ p + y ^ p := add_pow_expChar_of_commute _ <| .all ..\n\n"}
{"name":"add_pow_expChar_pow","module":"Mathlib.Algebra.CharP.Lemmas","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\nx y : R\np n : Nat\nhR : ExpChar R p\n⊢ Eq (HPow.hPow (HAdd.hAdd x y) (HPow.hPow p n)) (HAdd.hAdd (HPow.hPow x (HPow.hPow p n)) (HPow.hPow y (HPow.hPow p n)))","decl":"lemma add_pow_expChar_pow : (x + y) ^ p ^ n = x ^ p ^ n + y ^ p ^ n :=\n  add_pow_expChar_pow_of_commute _ _ <| .all ..\n\n"}
{"name":"add_pow_eq_mul_pow_add_pow_div_expChar","module":"Mathlib.Algebra.CharP.Lemmas","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\nx y : R\np n : Nat\nhR : ExpChar R p\n⊢ Eq (HPow.hPow (HAdd.hAdd x y) n) (HMul.hMul (HPow.hPow (HAdd.hAdd x y) (HMod.hMod n p)) (HPow.hPow (HAdd.hAdd (HPow.hPow x p) (HPow.hPow y p)) (HDiv.hDiv n p)))","decl":"lemma add_pow_eq_mul_pow_add_pow_div_expChar :\n    (x + y) ^ n = (x + y) ^ (n % p) * (x ^ p + y ^ p) ^ (n / p) :=\n  add_pow_eq_mul_pow_add_pow_div_expChar_of_commute _ _ <| .all ..\n\n"}
{"name":"add_pow_char","module":"Mathlib.Algebra.CharP.Lemmas","initialProofState":"R : Type u_1\ninst✝¹ : CommSemiring R\nx y : R\np : Nat\nhp : Fact (Nat.Prime p)\ninst✝ : CharP R p\n⊢ Eq (HPow.hPow (HAdd.hAdd x y) p) (HAdd.hAdd (HPow.hPow x p) (HPow.hPow y p))","decl":"lemma add_pow_char : (x + y) ^ p = x ^ p + y ^ p := add_pow_expChar ..\n"}
{"name":"add_pow_char_pow","module":"Mathlib.Algebra.CharP.Lemmas","initialProofState":"R : Type u_1\ninst✝¹ : CommSemiring R\nx y : R\np n : Nat\nhp : Fact (Nat.Prime p)\ninst✝ : CharP R p\n⊢ Eq (HPow.hPow (HAdd.hAdd x y) (HPow.hPow p n)) (HAdd.hAdd (HPow.hPow x (HPow.hPow p n)) (HPow.hPow y (HPow.hPow p n)))","decl":"lemma add_pow_char_pow : (x + y) ^ p ^ n = x ^ p ^ n + y ^ p ^ n := add_pow_expChar_pow ..\n\n"}
{"name":"add_pow_eq_mul_pow_add_pow_div_char","module":"Mathlib.Algebra.CharP.Lemmas","initialProofState":"R : Type u_1\ninst✝¹ : CommSemiring R\nx y : R\np n : Nat\nhp : Fact (Nat.Prime p)\ninst✝ : CharP R p\n⊢ Eq (HPow.hPow (HAdd.hAdd x y) n) (HMul.hMul (HPow.hPow (HAdd.hAdd x y) (HMod.hMod n p)) (HPow.hPow (HAdd.hAdd (HPow.hPow x p) (HPow.hPow y p)) (HDiv.hDiv n p)))","decl":"lemma add_pow_eq_mul_pow_add_pow_div_char :\n    (x + y) ^ n = (x + y) ^ (n % p) * (x ^ p + y ^ p) ^ (n / p) :=\n  add_pow_eq_mul_pow_add_pow_div_expChar ..\n\n"}
{"name":"add_pow_eq_add_pow_mod_mul_pow_add_pow_div","module":"Mathlib.Algebra.CharP.Lemmas","initialProofState":"R : Type u_1\ninst✝¹ : CommSemiring R\nx y : R\np n : Nat\nhp : Fact (Nat.Prime p)\ninst✝ : CharP R p\n⊢ Eq (HPow.hPow (HAdd.hAdd x y) n) (HMul.hMul (HPow.hPow (HAdd.hAdd x y) (HMod.hMod n p)) (HPow.hPow (HAdd.hAdd (HPow.hPow x p) (HPow.hPow y p)) (HDiv.hDiv n p)))","decl":"@[deprecated (since := \"2024-10-21\")]\nalias add_pow_eq_add_pow_mod_mul_pow_add_pow_div := add_pow_eq_mul_pow_add_pow_div_char\n\n"}
{"name":"sub_pow_expChar_of_commute","module":"Mathlib.Algebra.CharP.Lemmas","initialProofState":"R : Type u_1\ninst✝ : Ring R\nx y : R\np : Nat\nhR : ExpChar R p\nh : Commute x y\n⊢ Eq (HPow.hPow (HSub.hSub x y) p) (HSub.hSub (HPow.hPow x p) (HPow.hPow y p))","decl":"lemma sub_pow_expChar_of_commute (h : Commute x y) : (x - y) ^ p = x ^ p - y ^ p := by\n  simp [eq_sub_iff_add_eq, ← add_pow_expChar_of_commute _ (h.sub_left rfl)]\n\n"}
{"name":"sub_pow_expChar_pow_of_commute","module":"Mathlib.Algebra.CharP.Lemmas","initialProofState":"R : Type u_1\ninst✝ : Ring R\nx y : R\np n : Nat\nhR : ExpChar R p\nh : Commute x y\n⊢ Eq (HPow.hPow (HSub.hSub x y) (HPow.hPow p n)) (HSub.hSub (HPow.hPow x (HPow.hPow p n)) (HPow.hPow y (HPow.hPow p n)))","decl":"lemma sub_pow_expChar_pow_of_commute (h : Commute x y) :\n    (x - y) ^ p ^ n = x ^ p ^ n - y ^ p ^ n := by\n  simp [eq_sub_iff_add_eq, ← add_pow_expChar_pow_of_commute _ _ (h.sub_left rfl)]\n\n"}
{"name":"sub_pow_eq_mul_pow_sub_pow_div_expChar_of_commute","module":"Mathlib.Algebra.CharP.Lemmas","initialProofState":"R : Type u_1\ninst✝ : Ring R\nx y : R\np n : Nat\nhR : ExpChar R p\nh : Commute x y\n⊢ Eq (HPow.hPow (HSub.hSub x y) n) (HMul.hMul (HPow.hPow (HSub.hSub x y) (HMod.hMod n p)) (HPow.hPow (HSub.hSub (HPow.hPow x p) (HPow.hPow y p)) (HDiv.hDiv n p)))","decl":"lemma sub_pow_eq_mul_pow_sub_pow_div_expChar_of_commute (h : Commute x y) :\n    (x - y) ^ n = (x - y) ^ (n % p) * (x ^ p - y ^ p) ^ (n / p) := by\n  rw [← sub_pow_expChar_of_commute _ h, ← pow_mul, ← pow_add, Nat.mod_add_div]\n\n"}
{"name":"neg_one_pow_expChar","module":"Mathlib.Algebra.CharP.Lemmas","initialProofState":"R : Type u_1\ninst✝ : Ring R\np : Nat\nhR : ExpChar R p\n⊢ Eq (HPow.hPow (-1) p) (-1)","decl":"lemma neg_one_pow_expChar : (-1 : R) ^ p = -1 := by\n  rw [eq_neg_iff_add_eq_zero]\n  nth_rw 2 [← one_pow p]\n  rw [← add_pow_expChar_of_commute _ (Commute.one_right _), neg_add_cancel,\n    zero_pow (expChar_ne_zero R p)]\n\n"}
{"name":"neg_one_pow_expChar_pow","module":"Mathlib.Algebra.CharP.Lemmas","initialProofState":"R : Type u_1\ninst✝ : Ring R\np n : Nat\nhR : ExpChar R p\n⊢ Eq (HPow.hPow (-1) (HPow.hPow p n)) (-1)","decl":"lemma neg_one_pow_expChar_pow : (-1 : R) ^ p ^ n = -1 := by\n  rw [eq_neg_iff_add_eq_zero]\n  nth_rw 2 [← one_pow (p ^ n)]\n  rw [← add_pow_expChar_pow_of_commute _ _ (Commute.one_right _), neg_add_cancel,\n    zero_pow (pow_ne_zero _ <| expChar_ne_zero R p)]\n\n"}
{"name":"sub_pow_char_of_commute","module":"Mathlib.Algebra.CharP.Lemmas","initialProofState":"R : Type u_1\ninst✝¹ : Ring R\nx y : R\np : Nat\nhp : Fact (Nat.Prime p)\ninst✝ : CharP R p\nh : Commute x y\n⊢ Eq (HPow.hPow (HSub.hSub x y) p) (HSub.hSub (HPow.hPow x p) (HPow.hPow y p))","decl":"lemma sub_pow_char_of_commute (h : Commute x y) : (x - y) ^ p = x ^ p - y ^ p :=\n  sub_pow_expChar_of_commute _ h\n\n"}
{"name":"sub_pow_char_pow_of_commute","module":"Mathlib.Algebra.CharP.Lemmas","initialProofState":"R : Type u_1\ninst✝¹ : Ring R\nx y : R\np n : Nat\nhp : Fact (Nat.Prime p)\ninst✝ : CharP R p\nh : Commute x y\n⊢ Eq (HPow.hPow (HSub.hSub x y) (HPow.hPow p n)) (HSub.hSub (HPow.hPow x (HPow.hPow p n)) (HPow.hPow y (HPow.hPow p n)))","decl":"lemma sub_pow_char_pow_of_commute (h : Commute x y) : (x - y) ^ p ^ n = x ^ p ^ n - y ^ p ^ n :=\n  sub_pow_expChar_pow_of_commute _ _ h\n\n"}
{"name":"neg_one_pow_char","module":"Mathlib.Algebra.CharP.Lemmas","initialProofState":"R : Type u_1\ninst✝¹ : Ring R\np : Nat\nhp : Fact (Nat.Prime p)\ninst✝ : CharP R p\n⊢ Eq (HPow.hPow (-1) p) (-1)","decl":"lemma neg_one_pow_char : (-1 : R) ^ p = -1 := neg_one_pow_expChar ..\n\n"}
{"name":"neg_one_pow_char_pow","module":"Mathlib.Algebra.CharP.Lemmas","initialProofState":"R : Type u_1\ninst✝¹ : Ring R\np n : Nat\nhp : Fact (Nat.Prime p)\ninst✝ : CharP R p\n⊢ Eq (HPow.hPow (-1) (HPow.hPow p n)) (-1)","decl":"lemma neg_one_pow_char_pow : (-1 : R) ^ p ^ n = -1 := neg_one_pow_expChar_pow ..\n\n"}
{"name":"sub_pow_eq_mul_pow_sub_pow_div_char_of_commute","module":"Mathlib.Algebra.CharP.Lemmas","initialProofState":"R : Type u_1\ninst✝¹ : Ring R\nx y : R\np n : Nat\nhp : Fact (Nat.Prime p)\ninst✝ : CharP R p\nh : Commute x y\n⊢ Eq (HPow.hPow (HSub.hSub x y) n) (HMul.hMul (HPow.hPow (HSub.hSub x y) (HMod.hMod n p)) (HPow.hPow (HSub.hSub (HPow.hPow x p) (HPow.hPow y p)) (HDiv.hDiv n p)))","decl":"lemma sub_pow_eq_mul_pow_sub_pow_div_char_of_commute (h : Commute x y) :\n    (x - y) ^ n = (x - y) ^ (n % p) * (x ^ p - y ^ p) ^ (n / p) :=\n  sub_pow_eq_mul_pow_sub_pow_div_expChar_of_commute _ _ h\n\n"}
{"name":"sub_pow_expChar","module":"Mathlib.Algebra.CharP.Lemmas","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nx y : R\np : Nat\nhR : ExpChar R p\n⊢ Eq (HPow.hPow (HSub.hSub x y) p) (HSub.hSub (HPow.hPow x p) (HPow.hPow y p))","decl":"lemma sub_pow_expChar : (x - y) ^ p = x ^ p - y ^ p := sub_pow_expChar_of_commute _ <| .all ..\n\n"}
{"name":"sub_pow_expChar_pow","module":"Mathlib.Algebra.CharP.Lemmas","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nx y : R\nn p : Nat\nhR : ExpChar R p\n⊢ Eq (HPow.hPow (HSub.hSub x y) (HPow.hPow p n)) (HSub.hSub (HPow.hPow x (HPow.hPow p n)) (HPow.hPow y (HPow.hPow p n)))","decl":"lemma sub_pow_expChar_pow : (x - y) ^ p ^ n = x ^ p ^ n - y ^ p ^ n :=\n  sub_pow_expChar_pow_of_commute _ _ <| .all ..\n\n"}
{"name":"sub_pow_eq_mul_pow_sub_pow_div_expChar","module":"Mathlib.Algebra.CharP.Lemmas","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nx y : R\nn p : Nat\nhR : ExpChar R p\n⊢ Eq (HPow.hPow (HSub.hSub x y) n) (HMul.hMul (HPow.hPow (HSub.hSub x y) (HMod.hMod n p)) (HPow.hPow (HSub.hSub (HPow.hPow x p) (HPow.hPow y p)) (HDiv.hDiv n p)))","decl":"lemma sub_pow_eq_mul_pow_sub_pow_div_expChar :\n    (x - y) ^ n = (x - y) ^ (n % p) * (x ^ p - y ^ p) ^ (n / p) :=\n  sub_pow_eq_mul_pow_sub_pow_div_expChar_of_commute _ _ <| .all ..\n\n"}
{"name":"sub_pow_char","module":"Mathlib.Algebra.CharP.Lemmas","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\nx y : R\np : Nat\nhp : Fact (Nat.Prime p)\ninst✝ : CharP R p\n⊢ Eq (HPow.hPow (HSub.hSub x y) p) (HSub.hSub (HPow.hPow x p) (HPow.hPow y p))","decl":"lemma sub_pow_char : (x - y) ^ p = x ^ p - y ^ p := sub_pow_expChar ..\n"}
{"name":"sub_pow_char_pow","module":"Mathlib.Algebra.CharP.Lemmas","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\nx y : R\nn p : Nat\nhp : Fact (Nat.Prime p)\ninst✝ : CharP R p\n⊢ Eq (HPow.hPow (HSub.hSub x y) (HPow.hPow p n)) (HSub.hSub (HPow.hPow x (HPow.hPow p n)) (HPow.hPow y (HPow.hPow p n)))","decl":"lemma sub_pow_char_pow : (x - y) ^ p ^ n = x ^ p ^ n - y ^ p ^ n := sub_pow_expChar_pow ..\n\n"}
{"name":"sub_pow_eq_mul_pow_sub_pow_div_char","module":"Mathlib.Algebra.CharP.Lemmas","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\nx y : R\nn p : Nat\nhp : Fact (Nat.Prime p)\ninst✝ : CharP R p\n⊢ Eq (HPow.hPow (HSub.hSub x y) n) (HMul.hMul (HPow.hPow (HSub.hSub x y) (HMod.hMod n p)) (HPow.hPow (HSub.hSub (HPow.hPow x p) (HPow.hPow y p)) (HDiv.hDiv n p)))","decl":"lemma sub_pow_eq_mul_pow_sub_pow_div_char :\n    (x - y) ^ n = (x - y) ^ (n % p) * (x ^ p - y ^ p) ^ (n / p) :=\n  sub_pow_eq_mul_pow_sub_pow_div_expChar ..\n\n"}
{"name":"Nat.Prime.dvd_add_pow_sub_pow_of_dvd","module":"Mathlib.Algebra.CharP.Lemmas","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nx y : R\np : Nat\nhpri : Nat.Prime p\nr : R\nh₁ : Dvd.dvd r (HPow.hPow x p)\nh₂ : Dvd.dvd r (HMul.hMul (↑p) x)\n⊢ Dvd.dvd r (HSub.hSub (HPow.hPow (HAdd.hAdd x y) p) (HPow.hPow y p))","decl":"lemma Nat.Prime.dvd_add_pow_sub_pow_of_dvd (hpri : p.Prime) {r : R} (h₁ : r ∣ x ^ p)\n    (h₂ : r ∣ p * x) : r ∣ (x + y) ^ p - y ^ p := by\n  rw [add_pow_prime_eq hpri, add_right_comm, add_assoc, add_sub_assoc, add_sub_cancel_right]\n  apply dvd_add h₁ (h₂.trans <| mul_dvd_mul_left _ <| Finset.dvd_sum _)\n  simp only [Finset.mem_Ioo, and_imp, mul_assoc]\n  intro i hi0 _\n  exact dvd_mul_of_dvd_left (dvd_rfl.pow hi0.ne') _\n\n"}
{"name":"CharP.char_ne_zero_of_finite","module":"Mathlib.Algebra.CharP.Lemmas","initialProofState":"R : Type u_1\ninst✝² : NonAssocRing R\np : Nat\ninst✝¹ : CharP R p\ninst✝ : Finite R\n⊢ Ne p 0","decl":"/-- The characteristic of a finite ring cannot be zero. -/\ntheorem char_ne_zero_of_finite (p : ℕ) [CharP R p] [Finite R] : p ≠ 0 := by\n  rintro rfl\n  haveI : CharZero R := charP_to_charZero R\n  cases nonempty_fintype R\n  exact absurd Nat.cast_injective (not_injective_infinite_finite ((↑) : ℕ → R))\n\n"}
{"name":"CharP.ringChar_ne_zero_of_finite","module":"Mathlib.Algebra.CharP.Lemmas","initialProofState":"R : Type u_1\ninst✝¹ : NonAssocRing R\ninst✝ : Finite R\n⊢ Ne (ringChar R) 0","decl":"theorem ringChar_ne_zero_of_finite [Finite R] : ringChar R ≠ 0 :=\n  char_ne_zero_of_finite R (ringChar R)\n\n"}
{"name":"CharP.char_is_prime","module":"Mathlib.Algebra.CharP.Lemmas","initialProofState":"R : Type u_1\ninst✝⁴ : Ring R\ninst✝³ : NoZeroDivisors R\ninst✝² : Nontrivial R\ninst✝¹ : Finite R\np : Nat\ninst✝ : CharP R p\n⊢ Nat.Prime p","decl":"theorem char_is_prime (p : ℕ) [CharP R p] : p.Prime :=\n  Or.resolve_right (char_is_prime_or_zero R p) (char_ne_zero_of_finite R p)\n\n"}
{"name":"CharP.prime_ringChar","module":"Mathlib.Algebra.CharP.Lemmas","initialProofState":"R : Type u_1\ninst✝³ : Ring R\ninst✝² : NoZeroDivisors R\ninst✝¹ : Nontrivial R\ninst✝ : Finite R\n⊢ Nat.Prime (ringChar R)","decl":"lemma prime_ringChar : Nat.Prime (ringChar R) := by\n  apply CharP.char_prime_of_ne_zero R\n  exact CharP.ringChar_ne_zero_of_finite R\n\n"}
{"name":"frobenius_def","module":"Mathlib.Algebra.CharP.Lemmas","initialProofState":"R : Type u_1\ninst✝¹ : CommSemiring R\np : Nat\ninst✝ : ExpChar R p\nx : R\n⊢ Eq ((frobenius R p) x) (HPow.hPow x p)","decl":"lemma frobenius_def : frobenius R p x = x ^ p := rfl\n\n"}
{"name":"iterateFrobenius_def","module":"Mathlib.Algebra.CharP.Lemmas","initialProofState":"R : Type u_1\ninst✝¹ : CommSemiring R\np n : Nat\ninst✝ : ExpChar R p\nx : R\n⊢ Eq ((iterateFrobenius R p n) x) (HPow.hPow x (HPow.hPow p n))","decl":"lemma iterateFrobenius_def : iterateFrobenius R p n x = x ^ p ^ n := rfl\n\n"}
{"name":"iterate_frobenius","module":"Mathlib.Algebra.CharP.Lemmas","initialProofState":"R : Type u_1\ninst✝¹ : CommSemiring R\np n : Nat\ninst✝ : ExpChar R p\nx : R\n⊢ Eq (Nat.iterate (⇑(frobenius R p)) n x) (HPow.hPow x (HPow.hPow p n))","decl":"lemma iterate_frobenius : (frobenius R p)^[n] x = x ^ p ^ n := congr_fun (pow_iterate p n) x\n\n"}
{"name":"coe_iterateFrobenius","module":"Mathlib.Algebra.CharP.Lemmas","initialProofState":"R : Type u_1\ninst✝¹ : CommSemiring R\np n : Nat\ninst✝ : ExpChar R p\n⊢ Eq (⇑(iterateFrobenius R p n)) (Nat.iterate (⇑(frobenius R p)) n)","decl":"lemma coe_iterateFrobenius : iterateFrobenius R p n = (frobenius R p)^[n] :=\n  (pow_iterate p n).symm\n\n"}
{"name":"iterateFrobenius_one_apply","module":"Mathlib.Algebra.CharP.Lemmas","initialProofState":"R : Type u_1\ninst✝¹ : CommSemiring R\np : Nat\ninst✝ : ExpChar R p\nx : R\n⊢ Eq ((iterateFrobenius R p 1) x) (HPow.hPow x p)","decl":"lemma iterateFrobenius_one_apply : iterateFrobenius R p 1 x = x ^ p := by\n  rw [iterateFrobenius_def, pow_one]\n\n"}
{"name":"iterateFrobenius_one","module":"Mathlib.Algebra.CharP.Lemmas","initialProofState":"R : Type u_1\ninst✝¹ : CommSemiring R\np : Nat\ninst✝ : ExpChar R p\n⊢ Eq (iterateFrobenius R p 1) (frobenius R p)","decl":"@[simp]\nlemma iterateFrobenius_one : iterateFrobenius R p 1 = frobenius R p :=\n  RingHom.ext (iterateFrobenius_one_apply R p)\n\n"}
{"name":"iterateFrobenius_zero_apply","module":"Mathlib.Algebra.CharP.Lemmas","initialProofState":"R : Type u_1\ninst✝¹ : CommSemiring R\np : Nat\ninst✝ : ExpChar R p\nx : R\n⊢ Eq ((iterateFrobenius R p 0) x) x","decl":"lemma iterateFrobenius_zero_apply : iterateFrobenius R p 0 x = x := by\n  rw [iterateFrobenius_def, pow_zero, pow_one]\n\n"}
{"name":"iterateFrobenius_zero","module":"Mathlib.Algebra.CharP.Lemmas","initialProofState":"R : Type u_1\ninst✝¹ : CommSemiring R\np : Nat\ninst✝ : ExpChar R p\n⊢ Eq (iterateFrobenius R p 0) (RingHom.id R)","decl":"@[simp]\nlemma iterateFrobenius_zero : iterateFrobenius R p 0 = RingHom.id R :=\n  RingHom.ext (iterateFrobenius_zero_apply R p)\n\n"}
{"name":"iterateFrobenius_add_apply","module":"Mathlib.Algebra.CharP.Lemmas","initialProofState":"R : Type u_1\ninst✝¹ : CommSemiring R\np m n : Nat\ninst✝ : ExpChar R p\nx : R\n⊢ Eq ((iterateFrobenius R p (HAdd.hAdd m n)) x) ((iterateFrobenius R p m) ((iterateFrobenius R p n) x))","decl":"lemma iterateFrobenius_add_apply :\n    iterateFrobenius R p (m + n) x = iterateFrobenius R p m (iterateFrobenius R p n x) := by\n  simp_rw [iterateFrobenius_def, add_comm m n, pow_add, pow_mul]\n\n"}
{"name":"iterateFrobenius_add","module":"Mathlib.Algebra.CharP.Lemmas","initialProofState":"R : Type u_1\ninst✝¹ : CommSemiring R\np m n : Nat\ninst✝ : ExpChar R p\n⊢ Eq (iterateFrobenius R p (HAdd.hAdd m n)) ((iterateFrobenius R p m).comp (iterateFrobenius R p n))","decl":"lemma iterateFrobenius_add :\n    iterateFrobenius R p (m + n) = (iterateFrobenius R p m).comp (iterateFrobenius R p n) :=\n  RingHom.ext (iterateFrobenius_add_apply R p m n)\n\n"}
{"name":"iterateFrobenius_mul_apply","module":"Mathlib.Algebra.CharP.Lemmas","initialProofState":"R : Type u_1\ninst✝¹ : CommSemiring R\np m n : Nat\ninst✝ : ExpChar R p\nx : R\n⊢ Eq ((iterateFrobenius R p (HMul.hMul m n)) x) (Nat.iterate (⇑(iterateFrobenius R p m)) n x)","decl":"lemma iterateFrobenius_mul_apply :\n    iterateFrobenius R p (m * n) x = (iterateFrobenius R p m)^[n] x := by\n  simp_rw [coe_iterateFrobenius, Function.iterate_mul]\n\n"}
{"name":"coe_iterateFrobenius_mul","module":"Mathlib.Algebra.CharP.Lemmas","initialProofState":"R : Type u_1\ninst✝¹ : CommSemiring R\np m n : Nat\ninst✝ : ExpChar R p\n⊢ Eq (⇑(iterateFrobenius R p (HMul.hMul m n))) (Nat.iterate (⇑(iterateFrobenius R p m)) n)","decl":"lemma coe_iterateFrobenius_mul : iterateFrobenius R p (m * n) = (iterateFrobenius R p m)^[n] :=\n  funext (iterateFrobenius_mul_apply R p m n)\n\n"}
{"name":"frobenius_mul","module":"Mathlib.Algebra.CharP.Lemmas","initialProofState":"R : Type u_1\ninst✝¹ : CommSemiring R\np : Nat\ninst✝ : ExpChar R p\nx y : R\n⊢ Eq ((frobenius R p) (HMul.hMul x y)) (HMul.hMul ((frobenius R p) x) ((frobenius R p) y))","decl":"lemma frobenius_mul : frobenius R p (x * y) = frobenius R p x * frobenius R p y :=\n  map_mul (frobenius R p) x y\n\n"}
{"name":"frobenius_one","module":"Mathlib.Algebra.CharP.Lemmas","initialProofState":"R : Type u_1\ninst✝¹ : CommSemiring R\np : Nat\ninst✝ : ExpChar R p\n⊢ Eq ((frobenius R p) 1) 1","decl":"lemma frobenius_one : frobenius R p 1 = 1 := one_pow _\n\n"}
{"name":"MonoidHom.map_frobenius","module":"Mathlib.Algebra.CharP.Lemmas","initialProofState":"R : Type u_1\ninst✝³ : CommSemiring R\nS : Type u_3\ninst✝² : CommSemiring S\nf : MonoidHom R S\np : Nat\ninst✝¹ : ExpChar R p\ninst✝ : ExpChar S p\nx : R\n⊢ Eq (f ((frobenius R p) x)) ((frobenius S p) (f x))","decl":"lemma MonoidHom.map_frobenius : f (frobenius R p x) = frobenius S p (f x) := map_pow f x p\n"}
{"name":"RingHom.map_frobenius","module":"Mathlib.Algebra.CharP.Lemmas","initialProofState":"R : Type u_1\ninst✝³ : CommSemiring R\nS : Type u_3\ninst✝² : CommSemiring S\ng : RingHom R S\np : Nat\ninst✝¹ : ExpChar R p\ninst✝ : ExpChar S p\nx : R\n⊢ Eq (g ((frobenius R p) x)) ((frobenius S p) (g x))","decl":"lemma RingHom.map_frobenius : g (frobenius R p x) = frobenius S p (g x) := map_pow g x p\n\n"}
{"name":"MonoidHom.map_iterate_frobenius","module":"Mathlib.Algebra.CharP.Lemmas","initialProofState":"R : Type u_1\ninst✝³ : CommSemiring R\nS : Type u_3\ninst✝² : CommSemiring S\nf : MonoidHom R S\np : Nat\ninst✝¹ : ExpChar R p\ninst✝ : ExpChar S p\nx : R\nn : Nat\n⊢ Eq (f (Nat.iterate (⇑(frobenius R p)) n x)) (Nat.iterate (⇑(frobenius S p)) n (f x))","decl":"lemma MonoidHom.map_iterate_frobenius (n : ℕ) :\n    f ((frobenius R p)^[n] x) = (frobenius S p)^[n] (f x) :=\n  Function.Semiconj.iterate_right (f.map_frobenius p) n x\n\n"}
{"name":"RingHom.map_iterate_frobenius","module":"Mathlib.Algebra.CharP.Lemmas","initialProofState":"R : Type u_1\ninst✝³ : CommSemiring R\nS : Type u_3\ninst✝² : CommSemiring S\ng : RingHom R S\np : Nat\ninst✝¹ : ExpChar R p\ninst✝ : ExpChar S p\nx : R\nn : Nat\n⊢ Eq (g (Nat.iterate (⇑(frobenius R p)) n x)) (Nat.iterate (⇑(frobenius S p)) n (g x))","decl":"lemma RingHom.map_iterate_frobenius (n : ℕ) :\n    g ((frobenius R p)^[n] x) = (frobenius S p)^[n] (g x) :=\n  g.toMonoidHom.map_iterate_frobenius p x n\n\n"}
{"name":"MonoidHom.iterate_map_frobenius","module":"Mathlib.Algebra.CharP.Lemmas","initialProofState":"R : Type u_1\ninst✝¹ : CommSemiring R\nx : R\nf : MonoidHom R R\np : Nat\ninst✝ : ExpChar R p\nn : Nat\n⊢ Eq (Nat.iterate (⇑f) n ((frobenius R p) x)) ((frobenius R p) (Nat.iterate (⇑f) n x))","decl":"lemma MonoidHom.iterate_map_frobenius (f : R →* R) (p : ℕ) [ExpChar R p] (n : ℕ) :\n    f^[n] (frobenius R p x) = frobenius R p (f^[n] x) :=\n  iterate_map_pow f _ _ _\n\n"}
{"name":"RingHom.iterate_map_frobenius","module":"Mathlib.Algebra.CharP.Lemmas","initialProofState":"R : Type u_1\ninst✝¹ : CommSemiring R\nx : R\nf : RingHom R R\np : Nat\ninst✝ : ExpChar R p\nn : Nat\n⊢ Eq (Nat.iterate (⇑f) n ((frobenius R p) x)) ((frobenius R p) (Nat.iterate (⇑f) n x))","decl":"lemma RingHom.iterate_map_frobenius (f : R →+* R) (p : ℕ) [ExpChar R p] (n : ℕ) :\n    f^[n] (frobenius R p x) = frobenius R p (f^[n] x) := iterate_map_pow f _ _ _\n\n"}
{"name":"list_sum_pow_char","module":"Mathlib.Algebra.CharP.Lemmas","initialProofState":"R : Type u_1\ninst✝¹ : CommSemiring R\np : Nat\ninst✝ : ExpChar R p\nl : List R\n⊢ Eq (HPow.hPow l.sum p) (List.map (fun x => HPow.hPow x p) l).sum","decl":"lemma list_sum_pow_char (l : List R) : l.sum ^ p = (l.map (· ^ p : R → R)).sum :=\n  map_list_sum (frobenius R p) _\n\n"}
{"name":"multiset_sum_pow_char","module":"Mathlib.Algebra.CharP.Lemmas","initialProofState":"R : Type u_1\ninst✝¹ : CommSemiring R\np : Nat\ninst✝ : ExpChar R p\ns : Multiset R\n⊢ Eq (HPow.hPow s.sum p) (Multiset.map (fun x => HPow.hPow x p) s).sum","decl":"lemma multiset_sum_pow_char (s : Multiset R) : s.sum ^ p = (s.map (· ^ p : R → R)).sum :=\n  map_multiset_sum (frobenius R p) _\n\n"}
{"name":"sum_pow_char","module":"Mathlib.Algebra.CharP.Lemmas","initialProofState":"R : Type u_1\ninst✝¹ : CommSemiring R\np : Nat\ninst✝ : ExpChar R p\nι : Type u_4\ns : Finset ι\nf : ι → R\n⊢ Eq (HPow.hPow (s.sum fun i => f i) p) (s.sum fun i => HPow.hPow (f i) p)","decl":"lemma sum_pow_char {ι : Type*} (s : Finset ι) (f : ι → R) : (∑ i ∈ s, f i) ^ p = ∑ i ∈ s, f i ^ p :=\n  map_sum (frobenius R p) _ _\n\n"}
{"name":"list_sum_pow_char_pow","module":"Mathlib.Algebra.CharP.Lemmas","initialProofState":"R : Type u_1\ninst✝¹ : CommSemiring R\np : Nat\ninst✝ : ExpChar R p\nn : Nat\nl : List R\n⊢ Eq (HPow.hPow l.sum (HPow.hPow p n)) (List.map (fun x => HPow.hPow x (HPow.hPow p n)) l).sum","decl":"lemma list_sum_pow_char_pow (l : List R) : l.sum ^ p ^ n = (l.map (· ^ p ^ n : R → R)).sum :=\n  map_list_sum (iterateFrobenius R p n) _\n\n"}
{"name":"multiset_sum_pow_char_pow","module":"Mathlib.Algebra.CharP.Lemmas","initialProofState":"R : Type u_1\ninst✝¹ : CommSemiring R\np : Nat\ninst✝ : ExpChar R p\nn : Nat\ns : Multiset R\n⊢ Eq (HPow.hPow s.sum (HPow.hPow p n)) (Multiset.map (fun x => HPow.hPow x (HPow.hPow p n)) s).sum","decl":"lemma multiset_sum_pow_char_pow (s : Multiset R) :\n    s.sum ^ p ^ n = (s.map (· ^ p ^ n : R → R)).sum := map_multiset_sum (iterateFrobenius R p n) _\n\n"}
{"name":"sum_pow_char_pow","module":"Mathlib.Algebra.CharP.Lemmas","initialProofState":"R : Type u_1\ninst✝¹ : CommSemiring R\np : Nat\ninst✝ : ExpChar R p\nn : Nat\nι : Type u_4\ns : Finset ι\nf : ι → R\n⊢ Eq (HPow.hPow (s.sum fun i => f i) (HPow.hPow p n)) (s.sum fun i => HPow.hPow (f i) (HPow.hPow p n))","decl":"lemma sum_pow_char_pow {ι : Type*} (s : Finset ι) (f : ι → R) :\n    (∑ i ∈ s, f i) ^ p ^ n = ∑ i ∈ s, f i ^ p ^ n := map_sum (iterateFrobenius R p n) _ _\n\n"}
{"name":"frobenius_neg","module":"Mathlib.Algebra.CharP.Lemmas","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\np : Nat\ninst✝ : ExpChar R p\nx : R\n⊢ Eq ((frobenius R p) (Neg.neg x)) (Neg.neg ((frobenius R p) x))","decl":"lemma frobenius_neg : frobenius R p (-x) = -frobenius R p x := map_neg ..\n\n"}
{"name":"frobenius_sub","module":"Mathlib.Algebra.CharP.Lemmas","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\np : Nat\ninst✝ : ExpChar R p\nx y : R\n⊢ Eq ((frobenius R p) (HSub.hSub x y)) (HSub.hSub ((frobenius R p) x) ((frobenius R p) y))","decl":"lemma frobenius_sub : frobenius R p (x - y) = frobenius R p x - frobenius R p y := map_sub ..\n\n"}
