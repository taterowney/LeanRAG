{"name":"algebraMap_galRestrictHom_apply","module":"Mathlib.RingTheory.IntegralClosure.IntegralRestrict","initialProofState":"A : Type u_1\nK : Type u_2\nL : Type u_3\nB : Type u_4\ninst✝¹³ : CommRing A\ninst✝¹² : CommRing B\ninst✝¹¹ : Algebra A B\ninst✝¹⁰ : Field K\ninst✝⁹ : Field L\ninst✝⁸ : Algebra A K\ninst✝⁷ : IsFractionRing A K\ninst✝⁶ : Algebra B L\ninst✝⁵ : Algebra K L\ninst✝⁴ : Algebra A L\ninst✝³ : IsScalarTower A B L\ninst✝² : IsScalarTower A K L\ninst✝¹ : IsIntegralClosure B A L\ninst✝ : Algebra.IsAlgebraic K L\nσ : AlgHom K L L\nx : B\n⊢ Eq ((algebraMap B L) (((galRestrictHom A K L B) σ) x)) (σ ((algebraMap B L) x))","decl":"@[simp]\nlemma algebraMap_galRestrictHom_apply (σ : L →ₐ[K] L) (x : B) :\n    algebraMap B L (galRestrictHom A K L B σ x) = σ (algebraMap B L x) := by\n  simp [galRestrictHom, Subalgebra.algebraMap_eq, AlgHom.restrictDomain]\n\n"}
{"name":"galRestrictHom_symm_algebraMap_apply","module":"Mathlib.RingTheory.IntegralClosure.IntegralRestrict","initialProofState":"A : Type u_1\nK : Type u_2\nL : Type u_3\nB : Type u_4\ninst✝¹³ : CommRing A\ninst✝¹² : CommRing B\ninst✝¹¹ : Algebra A B\ninst✝¹⁰ : Field K\ninst✝⁹ : Field L\ninst✝⁸ : Algebra A K\ninst✝⁷ : IsFractionRing A K\ninst✝⁶ : Algebra B L\ninst✝⁵ : Algebra K L\ninst✝⁴ : Algebra A L\ninst✝³ : IsScalarTower A B L\ninst✝² : IsScalarTower A K L\ninst✝¹ : IsIntegralClosure B A L\ninst✝ : Algebra.IsAlgebraic K L\nσ : AlgHom A B B\nx : B\n⊢ Eq (((galRestrictHom A K L B).symm σ) ((algebraMap B L) x)) ((algebraMap B L) (σ x))","decl":"@[simp, nolint unusedHavesSuffices] -- false positive from unfolding galRestrictHom\nlemma galRestrictHom_symm_algebraMap_apply (σ : B →ₐ[A] B) (x : B) :\n    (galRestrictHom A K L B).symm σ (algebraMap B L x) = algebraMap B L (σ x) := by\n  have := (IsFractionRing.injective A K).isDomain\n  have := IsIntegralClosure.isLocalization A K L B\n  simp [galRestrictHom, galLift, Subalgebra.algebraMap_eq]\n\n"}
{"name":"coe_galRestrict_apply","module":"Mathlib.RingTheory.IntegralClosure.IntegralRestrict","initialProofState":"A : Type u_1\nK : Type u_2\nL : Type u_3\nB : Type u_4\ninst✝¹³ : CommRing A\ninst✝¹² : CommRing B\ninst✝¹¹ : Algebra A B\ninst✝¹⁰ : Field K\ninst✝⁹ : Field L\ninst✝⁸ : Algebra A K\ninst✝⁷ : IsFractionRing A K\ninst✝⁶ : Algebra B L\ninst✝⁵ : Algebra K L\ninst✝⁴ : Algebra A L\ninst✝³ : IsScalarTower A B L\ninst✝² : IsScalarTower A K L\ninst✝¹ : IsIntegralClosure B A L\ninst✝ : Algebra.IsAlgebraic K L\nσ : AlgEquiv K L L\n⊢ Eq (↑((galRestrict A K L B) σ)) ((galRestrictHom A K L B) ↑σ)","decl":"lemma coe_galRestrict_apply (σ : L ≃ₐ[K] L) :\n    (galRestrict A K L B σ : B →ₐ[A] B) = galRestrictHom A K L B σ := rfl\n\n"}
{"name":"galRestrict_apply","module":"Mathlib.RingTheory.IntegralClosure.IntegralRestrict","initialProofState":"A : Type u_1\nK : Type u_2\nL : Type u_3\nB : Type u_4\ninst✝¹³ : CommRing A\ninst✝¹² : CommRing B\ninst✝¹¹ : Algebra A B\ninst✝¹⁰ : Field K\ninst✝⁹ : Field L\ninst✝⁸ : Algebra A K\ninst✝⁷ : IsFractionRing A K\ninst✝⁶ : Algebra B L\ninst✝⁵ : Algebra K L\ninst✝⁴ : Algebra A L\ninst✝³ : IsScalarTower A B L\ninst✝² : IsScalarTower A K L\ninst✝¹ : IsIntegralClosure B A L\ninst✝ : Algebra.IsAlgebraic K L\nσ : AlgEquiv K L L\nx : B\n⊢ Eq (((galRestrict A K L B) σ) x) (((galRestrictHom A K L B) ↑σ) x)","decl":"lemma galRestrict_apply (σ : L ≃ₐ[K] L) (x : B) :\n    galRestrict A K L B σ x = galRestrictHom A K L B σ x := rfl\n\n"}
{"name":"algebraMap_galRestrict_apply","module":"Mathlib.RingTheory.IntegralClosure.IntegralRestrict","initialProofState":"A : Type u_1\nK : Type u_2\nL : Type u_3\nB : Type u_4\ninst✝¹³ : CommRing A\ninst✝¹² : CommRing B\ninst✝¹¹ : Algebra A B\ninst✝¹⁰ : Field K\ninst✝⁹ : Field L\ninst✝⁸ : Algebra A K\ninst✝⁷ : IsFractionRing A K\ninst✝⁶ : Algebra B L\ninst✝⁵ : Algebra K L\ninst✝⁴ : Algebra A L\ninst✝³ : IsScalarTower A B L\ninst✝² : IsScalarTower A K L\ninst✝¹ : IsIntegralClosure B A L\ninst✝ : Algebra.IsAlgebraic K L\nσ : AlgEquiv K L L\nx : B\n⊢ Eq ((algebraMap B L) (((galRestrict A K L B) σ) x)) (σ ((algebraMap B L) x))","decl":"lemma algebraMap_galRestrict_apply (σ : L ≃ₐ[K] L) (x : B) :\n    algebraMap B L (galRestrict A K L B σ x) = σ (algebraMap B L x) :=\n  algebraMap_galRestrictHom_apply A K L B σ.toAlgHom x\n\n"}
{"name":"prod_galRestrict_eq_norm","module":"Mathlib.RingTheory.IntegralClosure.IntegralRestrict","initialProofState":"A : Type u_1\nK : Type u_2\nL : Type u_3\nB : Type u_4\ninst✝¹⁵ : CommRing A\ninst✝¹⁴ : CommRing B\ninst✝¹³ : Algebra A B\ninst✝¹² : Field K\ninst✝¹¹ : Field L\ninst✝¹⁰ : Algebra A K\ninst✝⁹ : IsFractionRing A K\ninst✝⁸ : Algebra B L\ninst✝⁷ : Algebra K L\ninst✝⁶ : Algebra A L\ninst✝⁵ : IsScalarTower A B L\ninst✝⁴ : IsScalarTower A K L\ninst✝³ : IsIntegralClosure B A L\ninst✝² : FiniteDimensional K L\ninst✝¹ : IsGalois K L\ninst✝ : IsIntegrallyClosed A\nx : B\n⊢ Eq (Finset.univ.prod fun σ => ((galRestrict A K L B) σ) x) ((algebraMap A B) (IsIntegralClosure.mk' A ((Algebra.norm K) ((algebraMap B L) x)) ⋯))","decl":"lemma prod_galRestrict_eq_norm [IsGalois K L] [IsIntegrallyClosed A] (x : B) :\n    (∏ σ : L ≃ₐ[K] L, galRestrict A K L B σ x) =\n    algebraMap A B (IsIntegralClosure.mk' (R := A) A (Algebra.norm K <| algebraMap B L x)\n      (Algebra.isIntegral_norm K (IsIntegralClosure.isIntegral A L x).algebraMap)) := by\n  apply IsIntegralClosure.algebraMap_injective B A L\n  rw [← IsScalarTower.algebraMap_apply, IsScalarTower.algebraMap_eq A K L]\n  simp only [map_prod, algebraMap_galRestrict_apply, IsIntegralClosure.algebraMap_mk',\n    Algebra.norm_eq_prod_automorphisms, AlgHom.coe_coe, RingHom.coe_comp, Function.comp_apply]\n\n"}
{"name":"Algebra.map_intTraceAux","module":"Mathlib.RingTheory.IntegralClosure.IntegralRestrict","initialProofState":"A : Type u_1\nK : Type u_2\nL : Type u_3\nB : Type u_4\ninst✝¹⁴ : CommRing A\ninst✝¹³ : CommRing B\ninst✝¹² : Algebra A B\ninst✝¹¹ : Field K\ninst✝¹⁰ : Field L\ninst✝⁹ : Algebra A K\ninst✝⁸ : IsFractionRing A K\ninst✝⁷ : Algebra B L\ninst✝⁶ : Algebra K L\ninst✝⁵ : Algebra A L\ninst✝⁴ : IsScalarTower A B L\ninst✝³ : IsScalarTower A K L\ninst✝² : IsIntegralClosure B A L\ninst✝¹ : FiniteDimensional K L\ninst✝ : IsIntegrallyClosed A\nx : B\n⊢ Eq ((algebraMap A K) ((Algebra.intTraceAux A K L B) x)) ((Algebra.trace K L) ((algebraMap B L) x))","decl":"lemma Algebra.map_intTraceAux [IsIntegrallyClosed A] (x : B) :\n    algebraMap A K (Algebra.intTraceAux A K L B x) = Algebra.trace K L (algebraMap B L x) :=\n  IsIntegralClosure.algebraMap_equiv A (integralClosure A K) K A _\n\n"}
{"name":"Algebra.algebraMap_intTrace","module":"Mathlib.RingTheory.IntegralClosure.IntegralRestrict","initialProofState":"A : Type u_1\nK : Type u_2\nL : Type u_3\nB : Type u_4\ninst✝¹⁹ : CommRing A\ninst✝¹⁸ : CommRing B\ninst✝¹⁷ : Algebra A B\ninst✝¹⁶ : Field K\ninst✝¹⁵ : Field L\ninst✝¹⁴ : Algebra A K\ninst✝¹³ : IsFractionRing A K\ninst✝¹² : Algebra B L\ninst✝¹¹ : Algebra K L\ninst✝¹⁰ : Algebra A L\ninst✝⁹ : IsScalarTower A B L\ninst✝⁸ : IsScalarTower A K L\ninst✝⁷ : IsIntegralClosure B A L\ninst✝⁶ : FiniteDimensional K L\ninst✝⁵ : IsDomain A\ninst✝⁴ : IsIntegrallyClosed A\ninst✝³ : IsDomain B\ninst✝² : IsIntegrallyClosed B\ninst✝¹ : Module.Finite A B\ninst✝ : NoZeroSMulDivisors A B\nx : B\n⊢ Eq ((algebraMap A K) ((Algebra.intTrace A B) x)) ((Algebra.trace K L) ((algebraMap B L) x))","decl":"lemma Algebra.algebraMap_intTrace (x : B) :\n    algebraMap A K (Algebra.intTrace A B x) = Algebra.trace K L (algebraMap B L x) := by\n  haveI : IsIntegralClosure B A (FractionRing B) :=\n    IsIntegralClosure.of_isIntegrallyClosed _ _ _\n  haveI : IsLocalization (algebraMapSubmonoid B A⁰) (FractionRing B) :=\n    IsIntegralClosure.isLocalization _ (FractionRing A) _ _\n  haveI : FiniteDimensional (FractionRing A) (FractionRing B) :=\n    Module.Finite_of_isLocalization A B _ _ A⁰\n  haveI := IsIntegralClosure.isFractionRing_of_finite_extension A K L B\n  apply (FractionRing.algEquiv A K).symm.injective\n  rw [AlgEquiv.commutes, Algebra.intTrace, Algebra.map_intTraceAux,\n    ← AlgEquiv.commutes (FractionRing.algEquiv B L)]\n  apply Algebra.trace_eq_of_equiv_equiv (FractionRing.algEquiv A K).toRingEquiv\n    (FractionRing.algEquiv B L).toRingEquiv\n  apply IsLocalization.ringHom_ext A⁰\n  simp only [AlgEquiv.toRingEquiv_eq_coe, ← AlgEquiv.coe_ringHom_commutes, RingHom.comp_assoc,\n    AlgHom.comp_algebraMap_of_tower, ← IsScalarTower.algebraMap_eq, RingHom.comp_assoc]\n\n"}
{"name":"Algebra.algebraMap_intTrace_fractionRing","module":"Mathlib.RingTheory.IntegralClosure.IntegralRestrict","initialProofState":"A : Type u_1\nB : Type u_4\ninst✝⁸ : CommRing A\ninst✝⁷ : CommRing B\ninst✝⁶ : Algebra A B\ninst✝⁵ : IsDomain A\ninst✝⁴ : IsIntegrallyClosed A\ninst✝³ : IsDomain B\ninst✝² : IsIntegrallyClosed B\ninst✝¹ : Module.Finite A B\ninst✝ : NoZeroSMulDivisors A B\nx : B\n⊢ Eq ((algebraMap A (FractionRing A)) ((Algebra.intTrace A B) x)) ((Algebra.trace (FractionRing A) (FractionRing B)) ((algebraMap B (FractionRing B)) x))","decl":"lemma Algebra.algebraMap_intTrace_fractionRing (x : B) :\n    algebraMap A (FractionRing A) (Algebra.intTrace A B x) =\n      Algebra.trace (FractionRing A) (FractionRing B) (algebraMap B _ x) := by\n  haveI : IsIntegralClosure B A (FractionRing B) :=\n    IsIntegralClosure.of_isIntegrallyClosed _ _ _\n  haveI : IsLocalization (algebraMapSubmonoid B A⁰) (FractionRing B) :=\n    IsIntegralClosure.isLocalization _ (FractionRing A) _ _\n  haveI : FiniteDimensional (FractionRing A) (FractionRing B) :=\n    Module.Finite_of_isLocalization A B _ _ A⁰\n  exact Algebra.map_intTraceAux x\n\n"}
{"name":"Algebra.intTrace_eq_trace","module":"Mathlib.RingTheory.IntegralClosure.IntegralRestrict","initialProofState":"A : Type u_1\nB : Type u_4\ninst✝⁹ : CommRing A\ninst✝⁸ : CommRing B\ninst✝⁷ : Algebra A B\ninst✝⁶ : IsDomain A\ninst✝⁵ : IsIntegrallyClosed A\ninst✝⁴ : IsDomain B\ninst✝³ : IsIntegrallyClosed B\ninst✝² : Module.Finite A B\ninst✝¹ : NoZeroSMulDivisors A B\ninst✝ : Module.Free A B\n⊢ Eq (Algebra.intTrace A B) (Algebra.trace A B)","decl":"lemma Algebra.intTrace_eq_trace [Module.Free A B] : Algebra.intTrace A B = Algebra.trace A B := by\n  ext x\n  haveI : IsIntegralClosure B A (FractionRing B) :=\n    IsIntegralClosure.of_isIntegrallyClosed _ _ _\n  haveI : IsLocalization (algebraMapSubmonoid B A⁰) (FractionRing B) :=\n    IsIntegralClosure.isLocalization _ (FractionRing A) _ _\n  apply IsFractionRing.injective A (FractionRing A)\n  rw [Algebra.algebraMap_intTrace_fractionRing, Algebra.trace_localization A A⁰]\n\n"}
{"name":"Algebra.intTrace_eq_of_isLocalization","module":"Mathlib.RingTheory.IntegralClosure.IntegralRestrict","initialProofState":"A : Type u_1\nB : Type u_4\ninst✝²⁴ : CommRing A\ninst✝²³ : CommRing B\ninst✝²² : Algebra A B\nAₘ : Type u_5\nBₘ : Type u_6\ninst✝²¹ : CommRing Aₘ\ninst✝²⁰ : CommRing Bₘ\ninst✝¹⁹ : Algebra Aₘ Bₘ\ninst✝¹⁸ : Algebra A Aₘ\ninst✝¹⁷ : Algebra B Bₘ\ninst✝¹⁶ : Algebra A Bₘ\ninst✝¹⁵ : IsScalarTower A Aₘ Bₘ\ninst✝¹⁴ : IsScalarTower A B Bₘ\nM : Submonoid A\ninst✝¹³ : IsLocalization M Aₘ\ninst✝¹² : IsLocalization (Algebra.algebraMapSubmonoid B M) Bₘ\ninst✝¹¹ : IsDomain A\ninst✝¹⁰ : IsIntegrallyClosed A\ninst✝⁹ : IsDomain B\ninst✝⁸ : IsIntegrallyClosed B\ninst✝⁷ : Module.Finite A B\ninst✝⁶ : NoZeroSMulDivisors A B\ninst✝⁵ : IsDomain Aₘ\ninst✝⁴ : IsIntegrallyClosed Aₘ\ninst✝³ : IsDomain Bₘ\ninst✝² : IsIntegrallyClosed Bₘ\ninst✝¹ : NoZeroSMulDivisors Aₘ Bₘ\ninst✝ : Module.Finite Aₘ Bₘ\nx : B\n⊢ Eq ((algebraMap A Aₘ) ((Algebra.intTrace A B) x)) ((Algebra.intTrace Aₘ Bₘ) ((algebraMap B Bₘ) x))","decl":"include M in\nlemma Algebra.intTrace_eq_of_isLocalization\n    (x : B) :\n    algebraMap A Aₘ (Algebra.intTrace A B x) = Algebra.intTrace Aₘ Bₘ (algebraMap B Bₘ x) := by\n  by_cases hM : 0 ∈ M\n  · subsingleton [IsLocalization.uniqueOfZeroMem (S := Aₘ) hM]\n  replace hM : M ≤ A⁰ := fun x hx ↦ mem_nonZeroDivisors_iff_ne_zero.mpr (fun e ↦ hM (e ▸ hx))\n  let K := FractionRing A\n  let L := FractionRing B\n  have : IsIntegralClosure B A L :=\n    IsIntegralClosure.of_isIntegrallyClosed _ _ _\n  have : IsLocalization (algebraMapSubmonoid B A⁰) L :=\n    IsIntegralClosure.isLocalization _ (FractionRing A) _ _\n  let f : Aₘ →+* K := IsLocalization.map _ (T := A⁰) (RingHom.id A) hM\n  letI := f.toAlgebra\n  have : IsScalarTower A Aₘ K := IsScalarTower.of_algebraMap_eq'\n    (by rw [RingHom.algebraMap_toAlgebra, IsLocalization.map_comp, RingHomCompTriple.comp_eq])\n  letI := IsFractionRing.isFractionRing_of_isDomain_of_isLocalization M Aₘ K\n  let g : Bₘ →+* L := IsLocalization.map _\n      (M := algebraMapSubmonoid B M) (T := algebraMapSubmonoid B A⁰)\n      (RingHom.id B) (Submonoid.monotone_map hM)\n  letI := g.toAlgebra\n  have : IsScalarTower B Bₘ L := IsScalarTower.of_algebraMap_eq'\n    (by rw [RingHom.algebraMap_toAlgebra, IsLocalization.map_comp, RingHomCompTriple.comp_eq])\n  letI := ((algebraMap K L).comp f).toAlgebra\n  have : IsScalarTower Aₘ K L := IsScalarTower.of_algebraMap_eq' rfl\n  have : IsScalarTower Aₘ Bₘ L := by\n    apply IsScalarTower.of_algebraMap_eq'\n    apply IsLocalization.ringHom_ext M\n    rw [RingHom.algebraMap_toAlgebra, RingHom.algebraMap_toAlgebra (R := Bₘ), RingHom.comp_assoc,\n      RingHom.comp_assoc, ← IsScalarTower.algebraMap_eq, IsScalarTower.algebraMap_eq A B Bₘ,\n      IsLocalization.map_comp, RingHom.comp_id, ← RingHom.comp_assoc, IsLocalization.map_comp,\n      RingHom.comp_id, ← IsScalarTower.algebraMap_eq, ← IsScalarTower.algebraMap_eq]\n  letI := IsFractionRing.isFractionRing_of_isDomain_of_isLocalization\n    (algebraMapSubmonoid B M) Bₘ L\n  have : FiniteDimensional K L := Module.Finite_of_isLocalization A B _ _ A⁰\n  have : IsIntegralClosure Bₘ Aₘ L :=\n    IsIntegralClosure.of_isIntegrallyClosed _ _ _\n  apply IsFractionRing.injective Aₘ K\n  rw [← IsScalarTower.algebraMap_apply, Algebra.algebraMap_intTrace_fractionRing,\n    Algebra.algebraMap_intTrace (L := L), ← IsScalarTower.algebraMap_apply]\n\n"}
{"name":"Algebra.map_intNormAux","module":"Mathlib.RingTheory.IntegralClosure.IntegralRestrict","initialProofState":"A : Type u_1\nK : Type u_2\nL : Type u_3\nB : Type u_4\ninst✝¹⁵ : CommRing A\ninst✝¹⁴ : CommRing B\ninst✝¹³ : Algebra A B\ninst✝¹² : Field K\ninst✝¹¹ : Field L\ninst✝¹⁰ : Algebra A K\ninst✝⁹ : IsFractionRing A K\ninst✝⁸ : Algebra B L\ninst✝⁷ : Algebra K L\ninst✝⁶ : Algebra A L\ninst✝⁵ : IsScalarTower A B L\ninst✝⁴ : IsScalarTower A K L\ninst✝³ : IsIntegralClosure B A L\ninst✝² : FiniteDimensional K L\ninst✝¹ : IsIntegrallyClosed A\ninst✝ : Algebra.IsSeparable K L\nx : B\n⊢ Eq ((algebraMap A K) ((Algebra.intNormAux A K L B) x)) ((Algebra.norm K) ((algebraMap B L) x))","decl":"lemma Algebra.map_intNormAux [Algebra.IsSeparable K L] (x : B) :\n    algebraMap A K (Algebra.intNormAux A K L B x) = Algebra.norm K (algebraMap B L x) := by\n  dsimp [Algebra.intNormAux]\n  exact IsIntegralClosure.algebraMap_mk' _ _ _\n\n"}
{"name":"Algebra.algebraMap_intNorm","module":"Mathlib.RingTheory.IntegralClosure.IntegralRestrict","initialProofState":"A : Type u_1\nK : Type u_2\nL : Type u_3\nB : Type u_4\ninst✝²⁰ : CommRing A\ninst✝¹⁹ : CommRing B\ninst✝¹⁸ : Algebra A B\ninst✝¹⁷ : Field K\ninst✝¹⁶ : Field L\ninst✝¹⁵ : Algebra A K\ninst✝¹⁴ : IsFractionRing A K\ninst✝¹³ : Algebra B L\ninst✝¹² : Algebra K L\ninst✝¹¹ : Algebra A L\ninst✝¹⁰ : IsScalarTower A B L\ninst✝⁹ : IsScalarTower A K L\ninst✝⁸ : IsIntegralClosure B A L\ninst✝⁷ : FiniteDimensional K L\ninst✝⁶ : IsIntegrallyClosed A\ninst✝⁵ : IsDomain A\ninst✝⁴ : IsDomain B\ninst✝³ : IsIntegrallyClosed B\ninst✝² : Module.Finite A B\ninst✝¹ : NoZeroSMulDivisors A B\ninst✝ : Algebra.IsSeparable (FractionRing A) (FractionRing B)\nx : B\n⊢ Eq ((algebraMap A K) ((Algebra.intNorm A B) x)) ((Algebra.norm K) ((algebraMap B L) x))","decl":"lemma Algebra.algebraMap_intNorm (x : B) :\n    algebraMap A K (Algebra.intNorm A B x) = Algebra.norm K (algebraMap B L x) := by\n  haveI : IsIntegralClosure B A (FractionRing B) :=\n    IsIntegralClosure.of_isIntegrallyClosed _ _ _\n  haveI : IsLocalization (algebraMapSubmonoid B A⁰) (FractionRing B) :=\n    IsIntegralClosure.isLocalization _ (FractionRing A) _ _\n  haveI : FiniteDimensional (FractionRing A) (FractionRing B) :=\n    Module.Finite_of_isLocalization A B _ _ A⁰\n  haveI := IsIntegralClosure.isFractionRing_of_finite_extension A K L B\n  apply (FractionRing.algEquiv A K).symm.injective\n  rw [AlgEquiv.commutes, Algebra.intNorm, Algebra.map_intNormAux,\n    ← AlgEquiv.commutes (FractionRing.algEquiv B L)]\n  apply Algebra.norm_eq_of_equiv_equiv (FractionRing.algEquiv A K).toRingEquiv\n    (FractionRing.algEquiv B L).toRingEquiv\n  apply IsLocalization.ringHom_ext A⁰\n  simp only [AlgEquiv.toRingEquiv_eq_coe, ← AlgEquiv.coe_ringHom_commutes, RingHom.comp_assoc,\n    AlgHom.comp_algebraMap_of_tower, ← IsScalarTower.algebraMap_eq, RingHom.comp_assoc]\n\n"}
{"name":"Algebra.algebraMap_intNorm_fractionRing","module":"Mathlib.RingTheory.IntegralClosure.IntegralRestrict","initialProofState":"A : Type u_1\nB : Type u_4\ninst✝⁹ : CommRing A\ninst✝⁸ : CommRing B\ninst✝⁷ : Algebra A B\ninst✝⁶ : IsIntegrallyClosed A\ninst✝⁵ : IsDomain A\ninst✝⁴ : IsDomain B\ninst✝³ : IsIntegrallyClosed B\ninst✝² : Module.Finite A B\ninst✝¹ : NoZeroSMulDivisors A B\ninst✝ : Algebra.IsSeparable (FractionRing A) (FractionRing B)\nx : B\n⊢ Eq ((algebraMap A (FractionRing A)) ((Algebra.intNorm A B) x)) ((Algebra.norm (FractionRing A)) ((algebraMap B (FractionRing B)) x))","decl":"@[simp]\nlemma Algebra.algebraMap_intNorm_fractionRing (x : B) :\n    algebraMap A (FractionRing A) (Algebra.intNorm A B x) =\n      Algebra.norm (FractionRing A) (algebraMap B (FractionRing B) x) := by\n  haveI : IsIntegralClosure B A (FractionRing B) :=\n    IsIntegralClosure.of_isIntegrallyClosed _ _ _\n  haveI : IsLocalization (algebraMapSubmonoid B A⁰) (FractionRing B) :=\n    IsIntegralClosure.isLocalization _ (FractionRing A) _ _\n  haveI : FiniteDimensional (FractionRing A) (FractionRing B) :=\n    Module.Finite_of_isLocalization A B _ _ A⁰\n  exact Algebra.map_intNormAux x\n\n"}
{"name":"Algebra.intNorm_eq_norm","module":"Mathlib.RingTheory.IntegralClosure.IntegralRestrict","initialProofState":"A : Type u_1\nB : Type u_4\ninst✝¹⁰ : CommRing A\ninst✝⁹ : CommRing B\ninst✝⁸ : Algebra A B\ninst✝⁷ : IsIntegrallyClosed A\ninst✝⁶ : IsDomain A\ninst✝⁵ : IsDomain B\ninst✝⁴ : IsIntegrallyClosed B\ninst✝³ : Module.Finite A B\ninst✝² : NoZeroSMulDivisors A B\ninst✝¹ : Algebra.IsSeparable (FractionRing A) (FractionRing B)\ninst✝ : Module.Free A B\n⊢ Eq (Algebra.intNorm A B) (Algebra.norm A)","decl":"lemma Algebra.intNorm_eq_norm [Module.Free A B] : Algebra.intNorm A B = Algebra.norm A := by\n  ext x\n  haveI : IsIntegralClosure B A (FractionRing B) :=\n    IsIntegralClosure.of_isIntegrallyClosed _ _ _\n  haveI : IsLocalization (algebraMapSubmonoid B A⁰) (FractionRing B) :=\n    IsIntegralClosure.isLocalization _ (FractionRing A) _ _\n  apply IsFractionRing.injective A (FractionRing A)\n  rw [Algebra.algebraMap_intNorm_fractionRing, Algebra.norm_localization A A⁰]\n\n"}
{"name":"Algebra.intNorm_zero","module":"Mathlib.RingTheory.IntegralClosure.IntegralRestrict","initialProofState":"A : Type u_1\nB : Type u_4\ninst✝⁹ : CommRing A\ninst✝⁸ : CommRing B\ninst✝⁷ : Algebra A B\ninst✝⁶ : IsIntegrallyClosed A\ninst✝⁵ : IsDomain A\ninst✝⁴ : IsDomain B\ninst✝³ : IsIntegrallyClosed B\ninst✝² : Module.Finite A B\ninst✝¹ : NoZeroSMulDivisors A B\ninst✝ : Algebra.IsSeparable (FractionRing A) (FractionRing B)\n⊢ Eq ((Algebra.intNorm A B) 0) 0","decl":"@[simp]\nlemma Algebra.intNorm_zero : Algebra.intNorm A B 0 = 0 := by\n  haveI : IsIntegralClosure B A (FractionRing B) :=\n    IsIntegralClosure.of_isIntegrallyClosed _ _ _\n  haveI : IsLocalization (algebraMapSubmonoid B A⁰) (FractionRing B) :=\n    IsIntegralClosure.isLocalization _ (FractionRing A) _ _\n  haveI : FiniteDimensional (FractionRing A) (FractionRing B) :=\n    Module.Finite_of_isLocalization A B _ _ A⁰\n  apply IsFractionRing.injective A (FractionRing A)\n  simp only [algebraMap_intNorm_fractionRing, map_zero, norm_zero]\n\n"}
{"name":"Algebra.intNorm_eq_zero","module":"Mathlib.RingTheory.IntegralClosure.IntegralRestrict","initialProofState":"A : Type u_1\nB : Type u_4\ninst✝⁹ : CommRing A\ninst✝⁸ : CommRing B\ninst✝⁷ : Algebra A B\ninst✝⁶ : IsIntegrallyClosed A\ninst✝⁵ : IsDomain A\ninst✝⁴ : IsDomain B\ninst✝³ : IsIntegrallyClosed B\ninst✝² : Module.Finite A B\ninst✝¹ : NoZeroSMulDivisors A B\ninst✝ : Algebra.IsSeparable (FractionRing A) (FractionRing B)\nx : B\n⊢ Iff (Eq ((Algebra.intNorm A B) x) 0) (Eq x 0)","decl":"@[simp]\nlemma Algebra.intNorm_eq_zero {x : B} : Algebra.intNorm A B x = 0 ↔ x = 0 := by\n  haveI : IsIntegralClosure B A (FractionRing B) :=\n    IsIntegralClosure.of_isIntegrallyClosed _ _ _\n  haveI : IsLocalization (algebraMapSubmonoid B A⁰) (FractionRing B) :=\n    IsIntegralClosure.isLocalization _ (FractionRing A) _ _\n  haveI : FiniteDimensional (FractionRing A) (FractionRing B) :=\n    Module.Finite_of_isLocalization A B _ _ A⁰\n  rw [← (IsFractionRing.injective A (FractionRing A)).eq_iff,\n    ← (IsFractionRing.injective B (FractionRing B)).eq_iff]\n  simp only [algebraMap_intNorm_fractionRing, map_zero, norm_eq_zero_iff]\n\n"}
{"name":"Algebra.intNorm_ne_zero","module":"Mathlib.RingTheory.IntegralClosure.IntegralRestrict","initialProofState":"A : Type u_1\nB : Type u_4\ninst✝⁹ : CommRing A\ninst✝⁸ : CommRing B\ninst✝⁷ : Algebra A B\ninst✝⁶ : IsIntegrallyClosed A\ninst✝⁵ : IsDomain A\ninst✝⁴ : IsDomain B\ninst✝³ : IsIntegrallyClosed B\ninst✝² : Module.Finite A B\ninst✝¹ : NoZeroSMulDivisors A B\ninst✝ : Algebra.IsSeparable (FractionRing A) (FractionRing B)\nx : B\n⊢ Iff (Ne ((Algebra.intNorm A B) x) 0) (Ne x 0)","decl":"lemma Algebra.intNorm_ne_zero {x : B} : Algebra.intNorm A B x ≠ 0 ↔ x ≠ 0 := by simp\n\n"}
{"name":"Algebra.intNorm_eq_of_isLocalization","module":"Mathlib.RingTheory.IntegralClosure.IntegralRestrict","initialProofState":"A : Type u_1\nB : Type u_4\ninst✝²⁶ : CommRing A\ninst✝²⁵ : CommRing B\ninst✝²⁴ : Algebra A B\nAₘ : Type u_5\nBₘ : Type u_6\ninst✝²³ : CommRing Aₘ\ninst✝²² : CommRing Bₘ\ninst✝²¹ : Algebra Aₘ Bₘ\ninst✝²⁰ : Algebra A Aₘ\ninst✝¹⁹ : Algebra B Bₘ\ninst✝¹⁸ : Algebra A Bₘ\ninst✝¹⁷ : IsScalarTower A Aₘ Bₘ\ninst✝¹⁶ : IsScalarTower A B Bₘ\nM : Submonoid A\ninst✝¹⁵ : IsLocalization M Aₘ\ninst✝¹⁴ : IsLocalization (Algebra.algebraMapSubmonoid B M) Bₘ\ninst✝¹³ : IsIntegrallyClosed A\ninst✝¹² : IsDomain A\ninst✝¹¹ : IsDomain B\ninst✝¹⁰ : IsIntegrallyClosed B\ninst✝⁹ : Module.Finite A B\ninst✝⁸ : NoZeroSMulDivisors A B\ninst✝⁷ : Algebra.IsSeparable (FractionRing A) (FractionRing B)\ninst✝⁶ : IsDomain Aₘ\ninst✝⁵ : IsIntegrallyClosed Aₘ\ninst✝⁴ : IsDomain Bₘ\ninst✝³ : IsIntegrallyClosed Bₘ\ninst✝² : NoZeroSMulDivisors Aₘ Bₘ\ninst✝¹ : Module.Finite Aₘ Bₘ\ninst✝ : Algebra.IsSeparable (FractionRing Aₘ) (FractionRing Bₘ)\nx : B\n⊢ Eq ((algebraMap A Aₘ) ((Algebra.intNorm A B) x)) ((Algebra.intNorm Aₘ Bₘ) ((algebraMap B Bₘ) x))","decl":"include M in\nlemma Algebra.intNorm_eq_of_isLocalization (x : B) :\n    algebraMap A Aₘ (Algebra.intNorm A B x) = Algebra.intNorm Aₘ Bₘ (algebraMap B Bₘ x) := by\n  by_cases hM : 0 ∈ M\n  · subsingleton [IsLocalization.uniqueOfZeroMem (S := Aₘ) hM]\n  replace hM : M ≤ A⁰ := fun x hx ↦ mem_nonZeroDivisors_iff_ne_zero.mpr (fun e ↦ hM (e ▸ hx))\n  let K := FractionRing A\n  let L := FractionRing B\n  have : IsIntegralClosure B A L :=\n    IsIntegralClosure.of_isIntegrallyClosed _ _ _\n  have : IsLocalization (algebraMapSubmonoid B A⁰) L :=\n    IsIntegralClosure.isLocalization _ (FractionRing A) _ _\n  let f : Aₘ →+* K := IsLocalization.map _ (T := A⁰) (RingHom.id A) hM\n  letI := f.toAlgebra\n  have : IsScalarTower A Aₘ K := IsScalarTower.of_algebraMap_eq'\n    (by rw [RingHom.algebraMap_toAlgebra, IsLocalization.map_comp, RingHomCompTriple.comp_eq])\n  letI := IsFractionRing.isFractionRing_of_isDomain_of_isLocalization M Aₘ K\n  let g : Bₘ →+* L := IsLocalization.map _\n      (M := algebraMapSubmonoid B M) (T := algebraMapSubmonoid B A⁰)\n      (RingHom.id B) (Submonoid.monotone_map hM)\n  letI := g.toAlgebra\n  have : IsScalarTower B Bₘ L := IsScalarTower.of_algebraMap_eq'\n    (by rw [RingHom.algebraMap_toAlgebra, IsLocalization.map_comp, RingHomCompTriple.comp_eq])\n  letI := ((algebraMap K L).comp f).toAlgebra\n  have : IsScalarTower Aₘ K L := IsScalarTower.of_algebraMap_eq' rfl\n  have : IsScalarTower Aₘ Bₘ L := by\n    apply IsScalarTower.of_algebraMap_eq'\n    apply IsLocalization.ringHom_ext M\n    rw [RingHom.algebraMap_toAlgebra, RingHom.algebraMap_toAlgebra (R := Bₘ), RingHom.comp_assoc,\n      RingHom.comp_assoc, ← IsScalarTower.algebraMap_eq, IsScalarTower.algebraMap_eq A B Bₘ,\n      IsLocalization.map_comp, RingHom.comp_id, ← RingHom.comp_assoc, IsLocalization.map_comp,\n      RingHom.comp_id, ← IsScalarTower.algebraMap_eq, ← IsScalarTower.algebraMap_eq]\n  letI := IsFractionRing.isFractionRing_of_isDomain_of_isLocalization\n    (algebraMapSubmonoid B M) Bₘ L\n  have : FiniteDimensional K L := Module.Finite_of_isLocalization A B _ _ A⁰\n  have : IsIntegralClosure Bₘ Aₘ L :=\n    IsIntegralClosure.of_isIntegrallyClosed _ _ _\n  apply IsFractionRing.injective Aₘ K\n  rw [← IsScalarTower.algebraMap_apply, Algebra.algebraMap_intNorm_fractionRing,\n    Algebra.algebraMap_intNorm (L := L), ← IsScalarTower.algebraMap_apply]\n\n"}
{"name":"Algebra.algebraMap_intNorm_of_isGalois","module":"Mathlib.RingTheory.IntegralClosure.IntegralRestrict","initialProofState":"A : Type u_1\nB : Type u_4\ninst✝⁹ : CommRing A\ninst✝⁸ : CommRing B\ninst✝⁷ : Algebra A B\ninst✝⁶ : IsDomain A\ninst✝⁵ : IsIntegrallyClosed A\ninst✝⁴ : IsDomain B\ninst✝³ : IsIntegrallyClosed B\ninst✝² : Module.Finite A B\ninst✝¹ : NoZeroSMulDivisors A B\ninst✝ : IsGalois (FractionRing A) (FractionRing B)\nx : B\n⊢ Eq ((algebraMap A B) ((Algebra.intNorm A B) x)) (Finset.univ.prod fun σ => σ x)","decl":"lemma Algebra.algebraMap_intNorm_of_isGalois\n    [IsDomain A] [IsIntegrallyClosed A] [IsDomain B] [IsIntegrallyClosed B]\n    [Module.Finite A B] [NoZeroSMulDivisors A B] [IsGalois (FractionRing A) (FractionRing B)]\n    {x : B} :\n    algebraMap A B (Algebra.intNorm A B x) = ∏ σ : B ≃ₐ[A] B, σ x := by\n  haveI : IsIntegralClosure B A (FractionRing B) :=\n    IsIntegralClosure.of_isIntegrallyClosed _ _ _\n  haveI : IsLocalization (Algebra.algebraMapSubmonoid B A⁰) (FractionRing B) :=\n    IsIntegralClosure.isLocalization _ (FractionRing A) _ _\n  haveI : FiniteDimensional (FractionRing A) (FractionRing B) :=\n    Module.Finite_of_isLocalization A B _ _ A⁰\n  rw [← (galRestrict A (FractionRing A) (FractionRing B) B).toEquiv.prod_comp]\n  simp only [MulEquiv.toEquiv_eq_coe, EquivLike.coe_coe]\n  convert (prod_galRestrict_eq_norm A (FractionRing A) (FractionRing B) B x).symm\n"}
