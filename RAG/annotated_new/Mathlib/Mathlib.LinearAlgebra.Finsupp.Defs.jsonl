{"name":"Finsupp.linearEquivFunOnFinite_apply","module":"Mathlib.LinearAlgebra.Finsupp.Defs","initialProofState":"R : Type u_7\nM : Type u_9\nα : Type u_10\ninst✝³ : Finite α\ninst✝² : AddCommMonoid M\ninst✝¹ : Semiring R\ninst✝ : Module R M\na✝ : Finsupp α M\na : α\n⊢ Eq ((Finsupp.linearEquivFunOnFinite R M α) a✝ a) (a✝ a)","decl":"/-- Given `Finite α`, `linearEquivFunOnFinite R` is the natural `R`-linear equivalence between\n`α →₀ β` and `α → β`. -/\n@[simps apply]\nnoncomputable def linearEquivFunOnFinite : (α →₀ M) ≃ₗ[R] α → M :=\n  { equivFunOnFinite with\n    toFun := (⇑)\n    map_add' := fun _ _ => rfl\n    map_smul' := fun _ _ => rfl }\n\n"}
{"name":"Finsupp.linearEquivFunOnFinite_single","module":"Mathlib.LinearAlgebra.Finsupp.Defs","initialProofState":"R : Type u_7\nM : Type u_9\nα : Type u_10\ninst✝⁴ : Finite α\ninst✝³ : AddCommMonoid M\ninst✝² : Semiring R\ninst✝¹ : Module R M\ninst✝ : DecidableEq α\nx : α\nm : M\n⊢ Eq ((Finsupp.linearEquivFunOnFinite R M α) (Finsupp.single x m)) (Pi.single x m)","decl":"@[simp]\ntheorem linearEquivFunOnFinite_single [DecidableEq α] (x : α) (m : M) :\n    (linearEquivFunOnFinite R M α) (single x m) = Pi.single x m :=\n  equivFunOnFinite_single x m\n\n"}
{"name":"Finsupp.linearEquivFunOnFinite_symm_single","module":"Mathlib.LinearAlgebra.Finsupp.Defs","initialProofState":"R : Type u_7\nM : Type u_9\nα : Type u_10\ninst✝⁴ : Finite α\ninst✝³ : AddCommMonoid M\ninst✝² : Semiring R\ninst✝¹ : Module R M\ninst✝ : DecidableEq α\nx : α\nm : M\n⊢ Eq ((Finsupp.linearEquivFunOnFinite R M α).symm (Pi.single x m)) (Finsupp.single x m)","decl":"@[simp]\ntheorem linearEquivFunOnFinite_symm_single [DecidableEq α] (x : α) (m : M) :\n    (linearEquivFunOnFinite R M α).symm (Pi.single x m) = single x m :=\n  equivFunOnFinite_symm_single x m\n\n"}
{"name":"Finsupp.linearEquivFunOnFinite_symm_coe","module":"Mathlib.LinearAlgebra.Finsupp.Defs","initialProofState":"R : Type u_7\nM : Type u_9\nα : Type u_10\ninst✝³ : Finite α\ninst✝² : AddCommMonoid M\ninst✝¹ : Semiring R\ninst✝ : Module R M\nf : Finsupp α M\n⊢ Eq ((Finsupp.linearEquivFunOnFinite R M α).symm ⇑f) f","decl":"@[simp]\ntheorem linearEquivFunOnFinite_symm_coe (f : α →₀ M) : (linearEquivFunOnFinite R M α).symm f = f :=\n  (linearEquivFunOnFinite R M α).symm_apply_apply f\n\n"}
{"name":"Finsupp.lhom_ext","module":"Mathlib.LinearAlgebra.Finsupp.Defs","initialProofState":"α : Type u_1\nM : Type u_2\nN : Type u_3\nR : Type u_5\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : AddCommMonoid N\ninst✝ : Module R N\nφ ψ : LinearMap (RingHom.id R) (Finsupp α M) N\nh : ∀ (a : α) (b : M), Eq (φ (Finsupp.single a b)) (ψ (Finsupp.single a b))\n⊢ Eq φ ψ","decl":"/-- Two `R`-linear maps from `Finsupp X M` which agree on each `single x y` agree everywhere. -/\ntheorem lhom_ext ⦃φ ψ : (α →₀ M) →ₗ[R] N⦄ (h : ∀ a b, φ (single a b) = ψ (single a b)) : φ = ψ :=\n  LinearMap.toAddMonoidHom_injective <| addHom_ext h\n\n"}
{"name":"Finsupp.lhom_ext'","module":"Mathlib.LinearAlgebra.Finsupp.Defs","initialProofState":"α : Type u_1\nM : Type u_2\nN : Type u_3\nR : Type u_5\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : AddCommMonoid N\ninst✝ : Module R N\nφ ψ : LinearMap (RingHom.id R) (Finsupp α M) N\nh : ∀ (a : α), Eq (φ.comp (Finsupp.lsingle a)) (ψ.comp (Finsupp.lsingle a))\n⊢ Eq φ ψ","decl":"/-- Two `R`-linear maps from `Finsupp X M` which agree on each `single x y` agree everywhere.\n\nWe formulate this fact using equality of linear maps `φ.comp (lsingle a)` and `ψ.comp (lsingle a)`\nso that the `ext` tactic can apply a type-specific extensionality lemma to prove equality of these\nmaps. E.g., if `M = R`, then it suffices to verify `φ (single a 1) = ψ (single a 1)`. -/\n-- Porting note: The priority should be higher than `LinearMap.ext`.\n@[ext high]\ntheorem lhom_ext' ⦃φ ψ : (α →₀ M) →ₗ[R] N⦄ (h : ∀ a, φ.comp (lsingle a) = ψ.comp (lsingle a)) :\n    φ = ψ :=\n  lhom_ext fun a => LinearMap.congr_fun (h a)\n\n"}
{"name":"Finsupp.lhom_ext'_iff","module":"Mathlib.LinearAlgebra.Finsupp.Defs","initialProofState":"α : Type u_1\nM : Type u_2\nN : Type u_3\nR : Type u_5\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : AddCommMonoid N\ninst✝ : Module R N\nφ ψ : LinearMap (RingHom.id R) (Finsupp α M) N\n⊢ Iff (Eq φ ψ) (∀ (a : α), Eq (φ.comp (Finsupp.lsingle a)) (ψ.comp (Finsupp.lsingle a)))","decl":"/-- Two `R`-linear maps from `Finsupp X M` which agree on each `single x y` agree everywhere.\n\nWe formulate this fact using equality of linear maps `φ.comp (lsingle a)` and `ψ.comp (lsingle a)`\nso that the `ext` tactic can apply a type-specific extensionality lemma to prove equality of these\nmaps. E.g., if `M = R`, then it suffices to verify `φ (single a 1) = ψ (single a 1)`. -/\n-- Porting note: The priority should be higher than `LinearMap.ext`.\n@[ext high]\ntheorem lhom_ext' ⦃φ ψ : (α →₀ M) →ₗ[R] N⦄ (h : ∀ a, φ.comp (lsingle a) = ψ.comp (lsingle a)) :\n    φ = ψ :=\n  lhom_ext fun a => LinearMap.congr_fun (h a)\n\n"}
{"name":"Finsupp.lsubtypeDomain_apply","module":"Mathlib.LinearAlgebra.Finsupp.Defs","initialProofState":"α : Type u_1\nM : Type u_2\nR : Type u_5\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\ns : Set α\nf : Finsupp α M\n⊢ Eq ((Finsupp.lsubtypeDomain s) f) (Finsupp.subtypeDomain (fun x => Membership.mem s x) f)","decl":"theorem lsubtypeDomain_apply (f : α →₀ M) :\n    (lsubtypeDomain s : (α →₀ M) →ₗ[R] s →₀ M) f = subtypeDomain (fun x => x ∈ s) f :=\n  rfl\n\n"}
{"name":"Finsupp.lsingle_apply","module":"Mathlib.LinearAlgebra.Finsupp.Defs","initialProofState":"α : Type u_1\nM : Type u_2\nR : Type u_5\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\na : α\nb : M\n⊢ Eq ((Finsupp.lsingle a) b) (Finsupp.single a b)","decl":"@[simp]\ntheorem lsingle_apply (a : α) (b : M) : (lsingle a : M →ₗ[R] α →₀ M) b = single a b :=\n  rfl\n\n"}
{"name":"Finsupp.lapply_apply","module":"Mathlib.LinearAlgebra.Finsupp.Defs","initialProofState":"α : Type u_1\nM : Type u_2\nR : Type u_5\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\na : α\nf : Finsupp α M\n⊢ Eq ((Finsupp.lapply a) f) (f a)","decl":"@[simp]\ntheorem lapply_apply (a : α) (f : α →₀ M) : (lapply a : (α →₀ M) →ₗ[R] M) f = f a :=\n  rfl\n\n"}
{"name":"Finsupp.lapply_comp_lsingle_same","module":"Mathlib.LinearAlgebra.Finsupp.Defs","initialProofState":"α : Type u_1\nM : Type u_2\nR : Type u_5\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\na : α\n⊢ Eq ((Finsupp.lapply a).comp (Finsupp.lsingle a)) LinearMap.id","decl":"@[simp]\ntheorem lapply_comp_lsingle_same (a : α) : lapply a ∘ₗ lsingle a = (.id : M →ₗ[R] M) := by ext; simp\n\n"}
{"name":"Finsupp.lapply_comp_lsingle_of_ne","module":"Mathlib.LinearAlgebra.Finsupp.Defs","initialProofState":"α : Type u_1\nM : Type u_2\nR : Type u_5\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\na a' : α\nh : Ne a a'\n⊢ Eq ((Finsupp.lapply a).comp (Finsupp.lsingle a')) 0","decl":"@[simp]\ntheorem lapply_comp_lsingle_of_ne (a a' : α) (h : a ≠ a') :\n    lapply a ∘ₗ lsingle a' = (0 : M →ₗ[R] M) := by ext; simp [h.symm]\n\n"}
{"name":"Finsupp.lmapDomain_apply","module":"Mathlib.LinearAlgebra.Finsupp.Defs","initialProofState":"α : Type u_1\nM : Type u_2\nR : Type u_5\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nα' : Type u_7\nf : α → α'\nl : Finsupp α M\n⊢ Eq ((Finsupp.lmapDomain M R f) l) (Finsupp.mapDomain f l)","decl":"@[simp]\ntheorem lmapDomain_apply (f : α → α') (l : α →₀ M) :\n    (lmapDomain M R f : (α →₀ M) →ₗ[R] α' →₀ M) l = mapDomain f l :=\n  rfl\n\n"}
{"name":"Finsupp.lmapDomain_id","module":"Mathlib.LinearAlgebra.Finsupp.Defs","initialProofState":"α : Type u_1\nM : Type u_2\nR : Type u_5\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\n⊢ Eq (Finsupp.lmapDomain M R id) LinearMap.id","decl":"@[simp]\ntheorem lmapDomain_id : (lmapDomain M R _root_.id : (α →₀ M) →ₗ[R] α →₀ M) = LinearMap.id :=\n  LinearMap.ext fun _ => mapDomain_id\n\n"}
{"name":"Finsupp.lmapDomain_comp","module":"Mathlib.LinearAlgebra.Finsupp.Defs","initialProofState":"α : Type u_1\nM : Type u_2\nR : Type u_5\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nα' : Type u_7\nα'' : Type u_8\nf : α → α'\ng : α' → α''\n⊢ Eq (Finsupp.lmapDomain M R (Function.comp g f)) ((Finsupp.lmapDomain M R g).comp (Finsupp.lmapDomain M R f))","decl":"theorem lmapDomain_comp (f : α → α') (g : α' → α'') :\n    lmapDomain M R (g ∘ f) = (lmapDomain M R g).comp (lmapDomain M R f) :=\n  LinearMap.ext fun _ => mapDomain_comp\n\n"}
{"name":"Finsupp.lcomapDomain_apply","module":"Mathlib.LinearAlgebra.Finsupp.Defs","initialProofState":"α : Type u_1\nM : Type u_2\nR : Type u_5\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nβ : Type u_7\nf : α → β\nhf : Function.Injective f\nl : Finsupp β M\n⊢ Eq ((Finsupp.lcomapDomain f hf) l) (Finsupp.comapDomain f l ⋯)","decl":"/-- Given `f : α → β` and a proof `hf` that `f` is injective, `lcomapDomain f hf` is the linear map\nsending `l : β →₀ M` to the finitely supported function from `α` to `M` given by composing\n`l` with `f`.\n\nThis is the linear version of `Finsupp.comapDomain`. -/\n@[simps]\ndef lcomapDomain (f : α → β) (hf : Function.Injective f) : (β →₀ M) →ₗ[R] α →₀ M where\n  toFun l := Finsupp.comapDomain f l hf.injOn\n  map_add' x y := by ext; simp\n  map_smul' c x := by ext; simp\n\n"}
{"name":"Finsupp.mapRange.linearMap_apply","module":"Mathlib.LinearAlgebra.Finsupp.Defs","initialProofState":"α : Type u_1\nM : Type u_2\nN : Type u_3\nR : Type u_5\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : AddCommMonoid N\ninst✝ : Module R N\nf : LinearMap (RingHom.id R) M N\ng : Finsupp α M\n⊢ Eq ((Finsupp.mapRange.linearMap f) g) (Finsupp.mapRange ⇑f ⋯ g)","decl":"/-- `Finsupp.mapRange` as a `LinearMap`. -/\n@[simps apply]\ndef mapRange.linearMap (f : M →ₗ[R] N) : (α →₀ M) →ₗ[R] α →₀ N :=\n  { mapRange.addMonoidHom f.toAddMonoidHom with\n    toFun := (mapRange f f.map_zero : (α →₀ M) → α →₀ N)\n    -- Porting note: `hf` should be specified.\n    map_smul' := fun c v => mapRange_smul (hf := f.map_zero) c v (f.map_smul c) }\n\n"}
{"name":"Finsupp.mapRange.linearMap_id","module":"Mathlib.LinearAlgebra.Finsupp.Defs","initialProofState":"α : Type u_1\nM : Type u_2\nR : Type u_5\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\n⊢ Eq (Finsupp.mapRange.linearMap LinearMap.id) LinearMap.id","decl":"@[simp]\ntheorem mapRange.linearMap_id :\n    mapRange.linearMap LinearMap.id = (LinearMap.id : (α →₀ M) →ₗ[R] _) :=\n  LinearMap.ext mapRange_id\n\n"}
{"name":"Finsupp.mapRange.linearMap_comp","module":"Mathlib.LinearAlgebra.Finsupp.Defs","initialProofState":"α : Type u_1\nM : Type u_2\nN : Type u_3\nP : Type u_4\nR : Type u_5\ninst✝⁶ : Semiring R\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Module R M\ninst✝³ : AddCommMonoid N\ninst✝² : Module R N\ninst✝¹ : AddCommMonoid P\ninst✝ : Module R P\nf : LinearMap (RingHom.id R) N P\nf₂ : LinearMap (RingHom.id R) M N\n⊢ Eq (Finsupp.mapRange.linearMap (f.comp f₂)) ((Finsupp.mapRange.linearMap f).comp (Finsupp.mapRange.linearMap f₂))","decl":"theorem mapRange.linearMap_comp (f : N →ₗ[R] P) (f₂ : M →ₗ[R] N) :\n    (mapRange.linearMap (f.comp f₂) : (α →₀ _) →ₗ[R] _) =\n      (mapRange.linearMap f).comp (mapRange.linearMap f₂) :=\n  -- Porting note: Placeholders should be filled.\n  LinearMap.ext <| mapRange_comp f f.map_zero f₂ f₂.map_zero (comp f f₂).map_zero\n\n"}
{"name":"Finsupp.mapRange.linearMap_toAddMonoidHom","module":"Mathlib.LinearAlgebra.Finsupp.Defs","initialProofState":"α : Type u_1\nM : Type u_2\nN : Type u_3\nR : Type u_5\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : AddCommMonoid N\ninst✝ : Module R N\nf : LinearMap (RingHom.id R) M N\n⊢ Eq (Finsupp.mapRange.linearMap f).toAddMonoidHom (Finsupp.mapRange.addMonoidHom f.toAddMonoidHom)","decl":"@[simp]\ntheorem mapRange.linearMap_toAddMonoidHom (f : M →ₗ[R] N) :\n    (mapRange.linearMap f).toAddMonoidHom =\n      (mapRange.addMonoidHom f.toAddMonoidHom : (α →₀ M) →+ _) :=\n  AddMonoidHom.ext fun _ => rfl\n\n"}
{"name":"Finsupp.mapRange.linearEquiv_apply","module":"Mathlib.LinearAlgebra.Finsupp.Defs","initialProofState":"α : Type u_1\nM : Type u_2\nN : Type u_3\nR : Type u_5\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : AddCommMonoid N\ninst✝ : Module R N\ne : LinearEquiv (RingHom.id R) M N\ng : Finsupp α M\n⊢ Eq ((Finsupp.mapRange.linearEquiv e) g) (Finsupp.mapRange ⇑e ⋯ g)","decl":"/-- `Finsupp.mapRange` as a `LinearEquiv`. -/\n@[simps apply]\ndef mapRange.linearEquiv (e : M ≃ₗ[R] N) : (α →₀ M) ≃ₗ[R] α →₀ N :=\n  { mapRange.linearMap e.toLinearMap,\n    mapRange.addEquiv e.toAddEquiv with\n    toFun := mapRange e e.map_zero\n    invFun := mapRange e.symm e.symm.map_zero }\n\n"}
{"name":"Finsupp.mapRange.linearEquiv_refl","module":"Mathlib.LinearAlgebra.Finsupp.Defs","initialProofState":"α : Type u_1\nM : Type u_2\nR : Type u_5\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\n⊢ Eq (Finsupp.mapRange.linearEquiv (LinearEquiv.refl R M)) (LinearEquiv.refl R (Finsupp α M))","decl":"@[simp]\ntheorem mapRange.linearEquiv_refl :\n    mapRange.linearEquiv (LinearEquiv.refl R M) = LinearEquiv.refl R (α →₀ M) :=\n  LinearEquiv.ext mapRange_id\n\n"}
{"name":"Finsupp.mapRange.linearEquiv_trans","module":"Mathlib.LinearAlgebra.Finsupp.Defs","initialProofState":"α : Type u_1\nM : Type u_2\nN : Type u_3\nP : Type u_4\nR : Type u_5\ninst✝⁶ : Semiring R\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Module R M\ninst✝³ : AddCommMonoid N\ninst✝² : Module R N\ninst✝¹ : AddCommMonoid P\ninst✝ : Module R P\nf : LinearEquiv (RingHom.id R) M N\nf₂ : LinearEquiv (RingHom.id R) N P\n⊢ Eq (Finsupp.mapRange.linearEquiv (f.trans f₂)) ((Finsupp.mapRange.linearEquiv f).trans (Finsupp.mapRange.linearEquiv f₂))","decl":"theorem mapRange.linearEquiv_trans (f : M ≃ₗ[R] N) (f₂ : N ≃ₗ[R] P) :\n    (mapRange.linearEquiv (f.trans f₂) : (α →₀ _) ≃ₗ[R] _) =\n      (mapRange.linearEquiv f).trans (mapRange.linearEquiv f₂) :=\n  -- Porting note: Placeholders should be filled.\n  LinearEquiv.ext <| mapRange_comp f₂ f₂.map_zero f f.map_zero (f.trans f₂).map_zero\n\n"}
{"name":"Finsupp.mapRange.linearEquiv_symm","module":"Mathlib.LinearAlgebra.Finsupp.Defs","initialProofState":"α : Type u_1\nM : Type u_2\nN : Type u_3\nR : Type u_5\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : AddCommMonoid N\ninst✝ : Module R N\nf : LinearEquiv (RingHom.id R) M N\n⊢ Eq (Finsupp.mapRange.linearEquiv f).symm (Finsupp.mapRange.linearEquiv f.symm)","decl":"@[simp]\ntheorem mapRange.linearEquiv_symm (f : M ≃ₗ[R] N) :\n    ((mapRange.linearEquiv f).symm : (α →₀ _) ≃ₗ[R] _) = mapRange.linearEquiv f.symm :=\n  LinearEquiv.ext fun _x => rfl\n\n-- Porting note: This priority should be higher than `LinearEquiv.coe_toAddEquiv`.\n"}
{"name":"Finsupp.mapRange.linearEquiv_toAddEquiv","module":"Mathlib.LinearAlgebra.Finsupp.Defs","initialProofState":"α : Type u_1\nM : Type u_2\nN : Type u_3\nR : Type u_5\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : AddCommMonoid N\ninst✝ : Module R N\nf : LinearEquiv (RingHom.id R) M N\n⊢ Eq (Finsupp.mapRange.linearEquiv f).toAddEquiv (Finsupp.mapRange.addEquiv f.toAddEquiv)","decl":"@[simp 1500]\ntheorem mapRange.linearEquiv_toAddEquiv (f : M ≃ₗ[R] N) :\n    (mapRange.linearEquiv f).toAddEquiv = (mapRange.addEquiv f.toAddEquiv : (α →₀ M) ≃+ _) :=\n  AddEquiv.ext fun _ => rfl\n\n"}
{"name":"Finsupp.mapRange.linearEquiv_toLinearMap","module":"Mathlib.LinearAlgebra.Finsupp.Defs","initialProofState":"α : Type u_1\nM : Type u_2\nN : Type u_3\nR : Type u_5\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : AddCommMonoid N\ninst✝ : Module R N\nf : LinearEquiv (RingHom.id R) M N\n⊢ Eq (↑(Finsupp.mapRange.linearEquiv f)) (Finsupp.mapRange.linearMap ↑f)","decl":"@[simp]\ntheorem mapRange.linearEquiv_toLinearMap (f : M ≃ₗ[R] N) :\n    (mapRange.linearEquiv f).toLinearMap = (mapRange.linearMap f.toLinearMap : (α →₀ M) →ₗ[R] _) :=\n  LinearMap.ext fun _ => rfl\n\n"}
{"name":"Finsupp.finsuppProdLEquiv_apply","module":"Mathlib.LinearAlgebra.Finsupp.Defs","initialProofState":"α : Type u_7\nβ : Type u_8\nR : Type u_9\nM : Type u_10\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nf : Finsupp (Prod α β) M\nx : α\ny : β\n⊢ Eq ((((Finsupp.finsuppProdLEquiv R) f) x) y) (f { fst := x, snd := y })","decl":"@[simp]\ntheorem finsuppProdLEquiv_apply {α β R M : Type*} [Semiring R] [AddCommMonoid M] [Module R M]\n    (f : α × β →₀ M) (x y) : finsuppProdLEquiv R f x y = f (x, y) := by\n  rw [finsuppProdLEquiv, LinearEquiv.coe_mk, finsuppProdEquiv, Finsupp.curry_apply]\n\n"}
{"name":"Finsupp.finsuppProdLEquiv_symm_apply","module":"Mathlib.LinearAlgebra.Finsupp.Defs","initialProofState":"α : Type u_7\nβ : Type u_8\nR : Type u_9\nM : Type u_10\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nf : Finsupp α (Finsupp β M)\nxy : Prod α β\n⊢ Eq (((Finsupp.finsuppProdLEquiv R).symm f) xy) ((f xy.1) xy.2)","decl":"@[simp]\ntheorem finsuppProdLEquiv_symm_apply {α β R M : Type*} [Semiring R] [AddCommMonoid M] [Module R M]\n    (f : α →₀ β →₀ M) (xy) : (finsuppProdLEquiv R).symm f xy = f xy.1 xy.2 := by\n  conv_rhs =>\n    rw [← (finsuppProdLEquiv R).apply_symm_apply f, finsuppProdLEquiv_apply]\n\n"}
{"name":"Module.subsingletonEquiv_apply","module":"Mathlib.LinearAlgebra.Finsupp.Defs","initialProofState":"R : Type u_4\nM : Type u_5\nι : Type u_6\ninst✝³ : Semiring R\ninst✝² : Subsingleton R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nx✝ : M\n⊢ Eq ((Module.subsingletonEquiv R M ι) x✝) 0","decl":"/-- If `Subsingleton R`, then `M ≃ₗ[R] ι →₀ R` for any type `ι`. -/\n@[simps]\ndef Module.subsingletonEquiv (R M ι : Type*) [Semiring R] [Subsingleton R] [AddCommMonoid M]\n    [Module R M] : M ≃ₗ[R] ι →₀ R where\n  toFun _ := 0\n  invFun _ := 0\n  left_inv m := by\n    letI := Module.subsingleton R M\n    simp only [eq_iff_true_of_subsingleton]\n  right_inv f := by simp only [eq_iff_true_of_subsingleton]\n  map_add' _ _ := (add_zero 0).symm\n  map_smul' r _ := (smul_zero r).symm\n\n"}
{"name":"Module.subsingletonEquiv_symm_apply","module":"Mathlib.LinearAlgebra.Finsupp.Defs","initialProofState":"R : Type u_4\nM : Type u_5\nι : Type u_6\ninst✝³ : Semiring R\ninst✝² : Subsingleton R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nx✝ : Finsupp ι R\n⊢ Eq ((Module.subsingletonEquiv R M ι).symm x✝) 0","decl":"/-- If `Subsingleton R`, then `M ≃ₗ[R] ι →₀ R` for any type `ι`. -/\n@[simps]\ndef Module.subsingletonEquiv (R M ι : Type*) [Semiring R] [Subsingleton R] [AddCommMonoid M]\n    [Module R M] : M ≃ₗ[R] ι →₀ R where\n  toFun _ := 0\n  invFun _ := 0\n  left_inv m := by\n    letI := Module.subsingleton R M\n    simp only [eq_iff_true_of_subsingleton]\n  right_inv f := by simp only [eq_iff_true_of_subsingleton]\n  map_add' _ _ := (add_zero 0).symm\n  map_smul' r _ := (smul_zero r).symm\n\n"}
