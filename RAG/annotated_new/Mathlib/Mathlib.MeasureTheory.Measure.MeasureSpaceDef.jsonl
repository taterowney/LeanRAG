{"name":"MeasureTheory.Measure.m_iUnion","module":"Mathlib.MeasureTheory.Measure.MeasureSpaceDef","initialProofState":"α : Type u_6\ninst✝ : MeasurableSpace α\nself : MeasureTheory.Measure α\nf : Nat → Set α\na✝¹ : ∀ (i : Nat), MeasurableSet (f i)\na✝ : Pairwise (Function.onFun Disjoint f)\n⊢ Eq (self.toOuterMeasure (Set.iUnion fun i => f i)) (tsum fun i => self.toOuterMeasure (f i))","decl":"/-- A measure is defined to be an outer measure that is countably additive on\nmeasurable sets, with the additional assumption that the outer measure is the canonical\nextension of the restricted measure. -/\nstructure Measure (α : Type*) [MeasurableSpace α] extends OuterMeasure α where\n  m_iUnion ⦃f : ℕ → Set α⦄ : (∀ i, MeasurableSet (f i)) → Pairwise (Disjoint on f) →\n    toOuterMeasure (⋃ i, f i) = ∑' i, toOuterMeasure (f i)\n  trim_le : toOuterMeasure.trim ≤ toOuterMeasure\n\n"}
{"name":"MeasureTheory.Measure.mk.injEq","module":"Mathlib.MeasureTheory.Measure.MeasureSpaceDef","initialProofState":"α : Type u_6\ninst✝ : MeasurableSpace α\ntoOuterMeasure✝ : MeasureTheory.OuterMeasure α\nm_iUnion✝ : ∀ ⦃f : Nat → Set α⦄, (∀ (i : Nat), MeasurableSet (f i)) → Pairwise (Function.onFun Disjoint f) → Eq (toOuterMeasure✝ (Set.iUnion fun i => f i)) (tsum fun i => toOuterMeasure✝ (f i))\ntrim_le✝ : LE.le toOuterMeasure✝.trim toOuterMeasure✝\ntoOuterMeasure : MeasureTheory.OuterMeasure α\nm_iUnion : ∀ ⦃f : Nat → Set α⦄, (∀ (i : Nat), MeasurableSet (f i)) → Pairwise (Function.onFun Disjoint f) → Eq (toOuterMeasure (Set.iUnion fun i => f i)) (tsum fun i => toOuterMeasure (f i))\ntrim_le : LE.le toOuterMeasure.trim toOuterMeasure\n⊢ Eq (Eq { toOuterMeasure := toOuterMeasure✝, m_iUnion := m_iUnion✝, trim_le := trim_le✝ } { toOuterMeasure := toOuterMeasure, m_iUnion := m_iUnion, trim_le := trim_le }) (Eq toOuterMeasure✝ toOuterMeasure)","decl":"/-- A measure is defined to be an outer measure that is countably additive on\nmeasurable sets, with the additional assumption that the outer measure is the canonical\nextension of the restricted measure. -/\nstructure Measure (α : Type*) [MeasurableSpace α] extends OuterMeasure α where\n  m_iUnion ⦃f : ℕ → Set α⦄ : (∀ i, MeasurableSet (f i)) → Pairwise (Disjoint on f) →\n    toOuterMeasure (⋃ i, f i) = ∑' i, toOuterMeasure (f i)\n  trim_le : toOuterMeasure.trim ≤ toOuterMeasure\n\n"}
{"name":"MeasureTheory.Measure.mk.sizeOf_spec","module":"Mathlib.MeasureTheory.Measure.MeasureSpaceDef","initialProofState":"α : Type u_6\ninst✝¹ : MeasurableSpace α\ninst✝ : SizeOf α\ntoOuterMeasure : MeasureTheory.OuterMeasure α\nm_iUnion : ∀ ⦃f : Nat → Set α⦄, (∀ (i : Nat), MeasurableSet (f i)) → Pairwise (Function.onFun Disjoint f) → Eq (toOuterMeasure (Set.iUnion fun i => f i)) (tsum fun i => toOuterMeasure (f i))\ntrim_le : LE.le toOuterMeasure.trim toOuterMeasure\n⊢ Eq (SizeOf.sizeOf { toOuterMeasure := toOuterMeasure, m_iUnion := m_iUnion, trim_le := trim_le }) (HAdd.hAdd 1 (SizeOf.sizeOf toOuterMeasure))","decl":"/-- A measure is defined to be an outer measure that is countably additive on\nmeasurable sets, with the additional assumption that the outer measure is the canonical\nextension of the restricted measure. -/\nstructure Measure (α : Type*) [MeasurableSpace α] extends OuterMeasure α where\n  m_iUnion ⦃f : ℕ → Set α⦄ : (∀ i, MeasurableSet (f i)) → Pairwise (Disjoint on f) →\n    toOuterMeasure (⋃ i, f i) = ∑' i, toOuterMeasure (f i)\n  trim_le : toOuterMeasure.trim ≤ toOuterMeasure\n\n"}
{"name":"MeasureTheory.Measure.trim_le","module":"Mathlib.MeasureTheory.Measure.MeasureSpaceDef","initialProofState":"α : Type u_6\ninst✝ : MeasurableSpace α\nself : MeasureTheory.Measure α\n⊢ LE.le self.trim self.toOuterMeasure","decl":"/-- A measure is defined to be an outer measure that is countably additive on\nmeasurable sets, with the additional assumption that the outer measure is the canonical\nextension of the restricted measure. -/\nstructure Measure (α : Type*) [MeasurableSpace α] extends OuterMeasure α where\n  m_iUnion ⦃f : ℕ → Set α⦄ : (∀ i, MeasurableSet (f i)) → Pairwise (Disjoint on f) →\n    toOuterMeasure (⋃ i, f i) = ∑' i, toOuterMeasure (f i)\n  trim_le : toOuterMeasure.trim ≤ toOuterMeasure\n\n"}
{"name":"MeasureTheory.Measure.mk.inj","module":"Mathlib.MeasureTheory.Measure.MeasureSpaceDef","initialProofState":"α : Type u_6\ninst✝ : MeasurableSpace α\ntoOuterMeasure✝ : MeasureTheory.OuterMeasure α\nm_iUnion✝ : ∀ ⦃f : Nat → Set α⦄, (∀ (i : Nat), MeasurableSet (f i)) → Pairwise (Function.onFun Disjoint f) → Eq (toOuterMeasure✝ (Set.iUnion fun i => f i)) (tsum fun i => toOuterMeasure✝ (f i))\ntrim_le✝ : LE.le toOuterMeasure✝.trim toOuterMeasure✝\ntoOuterMeasure : MeasureTheory.OuterMeasure α\nm_iUnion : ∀ ⦃f : Nat → Set α⦄, (∀ (i : Nat), MeasurableSet (f i)) → Pairwise (Function.onFun Disjoint f) → Eq (toOuterMeasure (Set.iUnion fun i => f i)) (tsum fun i => toOuterMeasure (f i))\ntrim_le : LE.le toOuterMeasure.trim toOuterMeasure\nx✝ : Eq { toOuterMeasure := toOuterMeasure✝, m_iUnion := m_iUnion✝, trim_le := trim_le✝ } { toOuterMeasure := toOuterMeasure, m_iUnion := m_iUnion, trim_le := trim_le }\n⊢ Eq toOuterMeasure✝ toOuterMeasure","decl":"/-- A measure is defined to be an outer measure that is countably additive on\nmeasurable sets, with the additional assumption that the outer measure is the canonical\nextension of the restricted measure. -/\nstructure Measure (α : Type*) [MeasurableSpace α] extends OuterMeasure α where\n  m_iUnion ⦃f : ℕ → Set α⦄ : (∀ i, MeasurableSet (f i)) → Pairwise (Disjoint on f) →\n    toOuterMeasure (⋃ i, f i) = ∑' i, toOuterMeasure (f i)\n  trim_le : toOuterMeasure.trim ≤ toOuterMeasure\n\n"}
{"name":"MeasureTheory.Measure.toOuterMeasure_injective","module":"Mathlib.MeasureTheory.Measure.MeasureSpaceDef","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\n⊢ Function.Injective MeasureTheory.Measure.toOuterMeasure","decl":"theorem Measure.toOuterMeasure_injective [MeasurableSpace α] :\n    Injective (toOuterMeasure : Measure α → OuterMeasure α)\n  | ⟨_, _, _⟩, ⟨_, _, _⟩, rfl => rfl\n\n"}
{"name":"MeasureTheory.Measure.instOuterMeasureClass","module":"Mathlib.MeasureTheory.Measure.MeasureSpaceDef","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\n⊢ MeasureTheory.OuterMeasureClass (MeasureTheory.Measure α) α","decl":"instance Measure.instOuterMeasureClass [MeasurableSpace α] : OuterMeasureClass (Measure α) α where\n  measure_empty m := measure_empty (μ := m.toOuterMeasure)\n  measure_iUnion_nat_le m := m.iUnion_nat\n  measure_mono m := m.mono\n\n"}
{"name":"MeasureTheory.Measure.trimmed","module":"Mathlib.MeasureTheory.Measure.MeasureSpaceDef","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nμ : MeasureTheory.Measure α\n⊢ Eq μ.trim μ.toOuterMeasure","decl":"theorem trimmed (μ : Measure α) : μ.toOuterMeasure.trim = μ.toOuterMeasure :=\n  le_antisymm μ.trim_le μ.1.le_trim\n\n"}
{"name":"MeasureTheory.Measure.ofMeasurable_apply","module":"Mathlib.MeasureTheory.Measure.MeasureSpaceDef","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nm : (s : Set α) → MeasurableSet s → ENNReal\nm0 : Eq (m EmptyCollection.emptyCollection ⋯) 0\nmU : ∀ ⦃f : Nat → Set α⦄ (h : ∀ (i : Nat), MeasurableSet (f i)), Pairwise (Function.onFun Disjoint f) → Eq (m (Set.iUnion fun i => f i) ⋯) (tsum fun i => m (f i) ⋯)\ns : Set α\nhs : MeasurableSet s\n⊢ Eq ((MeasureTheory.Measure.ofMeasurable m m0 mU) s) (m s hs)","decl":"theorem ofMeasurable_apply {m : ∀ s : Set α, MeasurableSet s → ℝ≥0∞}\n    {m0 : m ∅ MeasurableSet.empty = 0}\n    {mU :\n      ∀ ⦃f : ℕ → Set α⦄ (h : ∀ i, MeasurableSet (f i)),\n        Pairwise (Disjoint on f) → m (⋃ i, f i) (MeasurableSet.iUnion h) = ∑' i, m (f i) (h i)}\n    (s : Set α) (hs : MeasurableSet s) : ofMeasurable m m0 mU s = m s hs :=\n  inducedOuterMeasure_eq m0 mU hs\n\n"}
{"name":"MeasureTheory.Measure.ext","module":"Mathlib.MeasureTheory.Measure.MeasureSpaceDef","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nμ₁ μ₂ : MeasureTheory.Measure α\nh : ∀ (s : Set α), MeasurableSet s → Eq (μ₁ s) (μ₂ s)\n⊢ Eq μ₁ μ₂","decl":"@[ext]\ntheorem ext (h : ∀ s, MeasurableSet s → μ₁ s = μ₂ s) : μ₁ = μ₂ :=\n  toOuterMeasure_injective <| by\n  rw [← trimmed, OuterMeasure.trim_congr (h _), trimmed]\n\n"}
{"name":"MeasureTheory.Measure.ext_iff","module":"Mathlib.MeasureTheory.Measure.MeasureSpaceDef","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nμ₁ μ₂ : MeasureTheory.Measure α\n⊢ Iff (Eq μ₁ μ₂) (∀ (s : Set α), MeasurableSet s → Eq (μ₁ s) (μ₂ s))","decl":"@[ext]\ntheorem ext (h : ∀ s, MeasurableSet s → μ₁ s = μ₂ s) : μ₁ = μ₂ :=\n  toOuterMeasure_injective <| by\n  rw [← trimmed, OuterMeasure.trim_congr (h _), trimmed]\n\n"}
{"name":"MeasureTheory.Measure.ext_iff'","module":"Mathlib.MeasureTheory.Measure.MeasureSpaceDef","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nμ₁ μ₂ : MeasureTheory.Measure α\n⊢ Iff (Eq μ₁ μ₂) (∀ (s : Set α), Eq (μ₁ s) (μ₂ s))","decl":"theorem ext_iff' : μ₁ = μ₂ ↔ ∀ s, μ₁ s = μ₂ s :=\n  ⟨by rintro rfl s; rfl, fun h ↦ Measure.ext (fun s _ ↦ h s)⟩\n\n"}
{"name":"MeasureTheory.Measure.outerMeasure_le_iff","module":"Mathlib.MeasureTheory.Measure.MeasureSpaceDef","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nμ : MeasureTheory.Measure α\nm : MeasureTheory.OuterMeasure α\n⊢ Iff (LE.le m μ.toOuterMeasure) (∀ (s : Set α), MeasurableSet s → LE.le (m s) (μ s))","decl":"theorem outerMeasure_le_iff {m : OuterMeasure α} : m ≤ μ.1 ↔ ∀ s, MeasurableSet s → m s ≤ μ s := by\n  simpa only [μ.trimmed] using OuterMeasure.le_trim_iff (m₂ := μ.1)\n\n"}
{"name":"MeasureTheory.Measure.coe_toOuterMeasure","module":"Mathlib.MeasureTheory.Measure.MeasureSpaceDef","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nμ : MeasureTheory.Measure α\n⊢ Eq ⇑μ.toOuterMeasure ⇑μ","decl":"@[simp] theorem Measure.coe_toOuterMeasure (μ : Measure α) : ⇑μ.toOuterMeasure = μ := rfl\n\n"}
{"name":"MeasureTheory.Measure.toOuterMeasure_apply","module":"Mathlib.MeasureTheory.Measure.MeasureSpaceDef","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : Set α\n⊢ Eq (μ.toOuterMeasure s) (μ s)","decl":"theorem Measure.toOuterMeasure_apply (μ : Measure α) (s : Set α) :\n    μ.toOuterMeasure s = μ s :=\n  rfl\n\n"}
{"name":"MeasureTheory.measure_eq_trim","module":"Mathlib.MeasureTheory.Measure.MeasureSpaceDef","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : Set α\n⊢ Eq (μ s) (μ.trim s)","decl":"theorem measure_eq_trim (s : Set α) : μ s = μ.toOuterMeasure.trim s := by\n  rw [μ.trimmed, μ.coe_toOuterMeasure]\n\n"}
{"name":"MeasureTheory.measure_eq_iInf","module":"Mathlib.MeasureTheory.Measure.MeasureSpaceDef","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : Set α\n⊢ Eq (μ s) (iInf fun t => iInf fun x => iInf fun x => μ t)","decl":"theorem measure_eq_iInf (s : Set α) : μ s = ⨅ (t) (_ : s ⊆ t) (_ : MeasurableSet t), μ t := by\n  rw [measure_eq_trim, OuterMeasure.trim_eq_iInf, μ.coe_toOuterMeasure]\n\n"}
{"name":"MeasureTheory.measure_eq_iInf'","module":"Mathlib.MeasureTheory.Measure.MeasureSpaceDef","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : Set α\n⊢ Eq (μ s) (iInf fun t => μ ↑t)","decl":"/-- A variant of `measure_eq_iInf` which has a single `iInf`. This is useful when applying a\n  lemma next that only works for non-empty infima, in which case you can use\n  `nonempty_measurable_superset`. -/\ntheorem measure_eq_iInf' (μ : Measure α) (s : Set α) :\n    μ s = ⨅ t : { t // s ⊆ t ∧ MeasurableSet t }, μ t := by\n  simp_rw [iInf_subtype, iInf_and, ← measure_eq_iInf]\n\n"}
{"name":"MeasureTheory.measure_eq_inducedOuterMeasure","module":"Mathlib.MeasureTheory.Measure.MeasureSpaceDef","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : Set α\n⊢ Eq (μ s) ((MeasureTheory.inducedOuterMeasure (fun s x => μ s) ⋯ ⋯) s)","decl":"theorem measure_eq_inducedOuterMeasure :\n    μ s = inducedOuterMeasure (fun s _ => μ s) MeasurableSet.empty μ.empty s :=\n  measure_eq_trim _\n\n"}
{"name":"MeasureTheory.toOuterMeasure_eq_inducedOuterMeasure","module":"Mathlib.MeasureTheory.Measure.MeasureSpaceDef","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nμ : MeasureTheory.Measure α\n⊢ Eq μ.toOuterMeasure (MeasureTheory.inducedOuterMeasure (fun s x => μ s) ⋯ ⋯)","decl":"theorem toOuterMeasure_eq_inducedOuterMeasure :\n    μ.toOuterMeasure = inducedOuterMeasure (fun s _ => μ s) MeasurableSet.empty μ.empty :=\n  μ.trimmed.symm\n\n"}
{"name":"MeasureTheory.measure_eq_extend","module":"Mathlib.MeasureTheory.Measure.MeasureSpaceDef","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : Set α\nhs : MeasurableSet s\n⊢ Eq (μ s) (MeasureTheory.extend (fun t _ht => μ t) s)","decl":"theorem measure_eq_extend (hs : MeasurableSet s) :\n    μ s = extend (fun t (_ht : MeasurableSet t) => μ t) s := by\n  rw [extend_eq]\n  exact hs\n\n"}
{"name":"MeasureTheory.nonempty_of_measure_ne_zero","module":"Mathlib.MeasureTheory.Measure.MeasureSpaceDef","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : Set α\nh : Ne (μ s) 0\n⊢ s.Nonempty","decl":"theorem nonempty_of_measure_ne_zero (h : μ s ≠ 0) : s.Nonempty :=\n  nonempty_iff_ne_empty.2 fun h' => h <| h'.symm ▸ measure_empty\n\n"}
{"name":"MeasureTheory.measure_mono_top","module":"Mathlib.MeasureTheory.Measure.MeasureSpaceDef","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns₁ s₂ : Set α\nh : HasSubset.Subset s₁ s₂\nh₁ : Eq (μ s₁) Top.top\n⊢ Eq (μ s₂) Top.top","decl":"theorem measure_mono_top (h : s₁ ⊆ s₂) (h₁ : μ s₁ = ∞) : μ s₂ = ∞ :=\n  top_unique <| h₁ ▸ measure_mono h\n\n"}
{"name":"MeasureTheory.measure_le_measure_union_left","module":"Mathlib.MeasureTheory.Measure.MeasureSpaceDef","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns t : Set α\n⊢ LE.le (μ s) (μ (Union.union s t))","decl":"@[simp, mono]\ntheorem measure_le_measure_union_left : μ s ≤ μ (s ∪ t) := μ.mono subset_union_left\n\n"}
{"name":"MeasureTheory.measure_le_measure_union_right","module":"Mathlib.MeasureTheory.Measure.MeasureSpaceDef","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns t : Set α\n⊢ LE.le (μ t) (μ (Union.union s t))","decl":"@[simp, mono]\ntheorem measure_le_measure_union_right : μ t ≤ μ (s ∪ t) := μ.mono subset_union_right\n\n"}
{"name":"MeasureTheory.exists_measurable_superset","module":"Mathlib.MeasureTheory.Measure.MeasureSpaceDef","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : Set α\n⊢ Exists fun t => And (HasSubset.Subset s t) (And (MeasurableSet t) (Eq (μ t) (μ s)))","decl":"/-- For every set there exists a measurable superset of the same measure. -/\ntheorem exists_measurable_superset (μ : Measure α) (s : Set α) :\n    ∃ t, s ⊆ t ∧ MeasurableSet t ∧ μ t = μ s := by\n  simpa only [← measure_eq_trim] using μ.toOuterMeasure.exists_measurable_superset_eq_trim s\n\n"}
{"name":"MeasureTheory.exists_measurable_superset_forall_eq","module":"Mathlib.MeasureTheory.Measure.MeasureSpaceDef","initialProofState":"α : Type u_1\nι : Sort u_5\ninst✝¹ : MeasurableSpace α\ninst✝ : Countable ι\nμ : ι → MeasureTheory.Measure α\ns : Set α\n⊢ Exists fun t => And (HasSubset.Subset s t) (And (MeasurableSet t) (∀ (i : ι), Eq ((μ i) t) ((μ i) s)))","decl":"/-- For every set `s` and a countable collection of measures `μ i` there exists a measurable\nsuperset `t ⊇ s` such that each measure `μ i` takes the same value on `s` and `t`. -/\ntheorem exists_measurable_superset_forall_eq [Countable ι] (μ : ι → Measure α) (s : Set α) :\n    ∃ t, s ⊆ t ∧ MeasurableSet t ∧ ∀ i, μ i t = μ i s := by\n  simpa only [← measure_eq_trim] using\n    OuterMeasure.exists_measurable_superset_forall_eq_trim (fun i => (μ i).toOuterMeasure) s\n\n"}
{"name":"MeasureTheory.exists_measurable_superset₂","module":"Mathlib.MeasureTheory.Measure.MeasureSpaceDef","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\ns : Set α\n⊢ Exists fun t => And (HasSubset.Subset s t) (And (MeasurableSet t) (And (Eq (μ t) (μ s)) (Eq (ν t) (ν s))))","decl":"theorem exists_measurable_superset₂ (μ ν : Measure α) (s : Set α) :\n    ∃ t, s ⊆ t ∧ MeasurableSet t ∧ μ t = μ s ∧ ν t = ν s := by\n  simpa only [Bool.forall_bool.trans and_comm] using\n    exists_measurable_superset_forall_eq (fun b => cond b μ ν) s\n\n"}
{"name":"MeasureTheory.exists_measurable_superset_of_null","module":"Mathlib.MeasureTheory.Measure.MeasureSpaceDef","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : Set α\nh : Eq (μ s) 0\n⊢ Exists fun t => And (HasSubset.Subset s t) (And (MeasurableSet t) (Eq (μ t) 0))","decl":"theorem exists_measurable_superset_of_null (h : μ s = 0) : ∃ t, s ⊆ t ∧ MeasurableSet t ∧ μ t = 0 :=\n  h ▸ exists_measurable_superset μ s\n\n"}
{"name":"MeasureTheory.exists_measurable_superset_iff_measure_eq_zero","module":"Mathlib.MeasureTheory.Measure.MeasureSpaceDef","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : Set α\n⊢ Iff (Exists fun t => And (HasSubset.Subset s t) (And (MeasurableSet t) (Eq (μ t) 0))) (Eq (μ s) 0)","decl":"theorem exists_measurable_superset_iff_measure_eq_zero :\n    (∃ t, s ⊆ t ∧ MeasurableSet t ∧ μ t = 0) ↔ μ s = 0 :=\n  ⟨fun ⟨_t, hst, _, ht⟩ => measure_mono_null hst ht, exists_measurable_superset_of_null⟩\n\n"}
{"name":"MeasureTheory.measure_biUnion_lt_top","module":"Mathlib.MeasureTheory.Measure.MeasureSpaceDef","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : Set β\nf : β → Set α\nhs : s.Finite\nhfin : ∀ (i : β), Membership.mem s i → LT.lt (μ (f i)) Top.top\n⊢ LT.lt (μ (Set.iUnion fun i => Set.iUnion fun h => f i)) Top.top","decl":"theorem measure_biUnion_lt_top {s : Set β} {f : β → Set α} (hs : s.Finite)\n    (hfin : ∀ i ∈ s, μ (f i) < ∞) : μ (⋃ i ∈ s, f i) < ∞ := by\n  convert (measure_biUnion_finset_le (μ := μ) hs.toFinset f).trans_lt _ using 3\n  · ext\n    rw [Finite.mem_toFinset]\n  · simpa only [ENNReal.sum_lt_top, Finite.mem_toFinset]\n\n"}
{"name":"MeasureTheory.measure_union_lt_top","module":"Mathlib.MeasureTheory.Measure.MeasureSpaceDef","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns t : Set α\nhs : LT.lt (μ s) Top.top\nht : LT.lt (μ t) Top.top\n⊢ LT.lt (μ (Union.union s t)) Top.top","decl":"theorem measure_union_lt_top (hs : μ s < ∞) (ht : μ t < ∞) : μ (s ∪ t) < ∞ :=\n  (measure_union_le s t).trans_lt (ENNReal.add_lt_top.mpr ⟨hs, ht⟩)\n\n"}
{"name":"MeasureTheory.measure_union_lt_top_iff","module":"Mathlib.MeasureTheory.Measure.MeasureSpaceDef","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns t : Set α\n⊢ Iff (LT.lt (μ (Union.union s t)) Top.top) (And (LT.lt (μ s) Top.top) (LT.lt (μ t) Top.top))","decl":"@[simp]\ntheorem measure_union_lt_top_iff : μ (s ∪ t) < ∞ ↔ μ s < ∞ ∧ μ t < ∞ := by\n  refine ⟨fun h => ⟨?_, ?_⟩, fun h => measure_union_lt_top h.1 h.2⟩\n  · exact (measure_mono Set.subset_union_left).trans_lt h\n  · exact (measure_mono Set.subset_union_right).trans_lt h\n\n"}
{"name":"MeasureTheory.measure_union_ne_top","module":"Mathlib.MeasureTheory.Measure.MeasureSpaceDef","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns t : Set α\nhs : Ne (μ s) Top.top\nht : Ne (μ t) Top.top\n⊢ Ne (μ (Union.union s t)) Top.top","decl":"theorem measure_union_ne_top (hs : μ s ≠ ∞) (ht : μ t ≠ ∞) : μ (s ∪ t) ≠ ∞ :=\n  (measure_union_lt_top hs.lt_top ht.lt_top).ne\n\n"}
{"name":"MeasureTheory.measure_symmDiff_ne_top","module":"Mathlib.MeasureTheory.Measure.MeasureSpaceDef","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns t : Set α\nhs : Ne (μ s) Top.top\nht : Ne (μ t) Top.top\n⊢ Ne (μ (symmDiff s t)) Top.top","decl":"open scoped symmDiff in\ntheorem measure_symmDiff_ne_top (hs : μ s ≠ ∞) (ht : μ t ≠ ∞) : μ (s ∆ t) ≠ ∞ :=\n  ne_top_of_le_ne_top (measure_union_ne_top hs ht) <| measure_mono symmDiff_subset_union\n\n"}
{"name":"MeasureTheory.measure_union_eq_top_iff","module":"Mathlib.MeasureTheory.Measure.MeasureSpaceDef","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns t : Set α\n⊢ Iff (Eq (μ (Union.union s t)) Top.top) (Or (Eq (μ s) Top.top) (Eq (μ t) Top.top))","decl":"@[simp]\ntheorem measure_union_eq_top_iff : μ (s ∪ t) = ∞ ↔ μ s = ∞ ∨ μ t = ∞ :=\n  not_iff_not.1 <| by simp only [← lt_top_iff_ne_top, ← Ne.eq_def, not_or, measure_union_lt_top_iff]\n\n"}
{"name":"MeasureTheory.exists_measure_pos_of_not_measure_iUnion_null","module":"Mathlib.MeasureTheory.Measure.MeasureSpaceDef","initialProofState":"α : Type u_1\nι : Sort u_5\ninst✝¹ : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : Countable ι\ns : ι → Set α\nhs : Ne (μ (Set.iUnion fun n => s n)) 0\n⊢ Exists fun n => LT.lt 0 (μ (s n))","decl":"theorem exists_measure_pos_of_not_measure_iUnion_null [Countable ι] {s : ι → Set α}\n    (hs : μ (⋃ n, s n) ≠ 0) : ∃ n, 0 < μ (s n) := by\n  contrapose! hs\n  exact measure_iUnion_null fun n => nonpos_iff_eq_zero.1 (hs n)\n\n"}
{"name":"MeasureTheory.measure_lt_top_of_subset","module":"Mathlib.MeasureTheory.Measure.MeasureSpaceDef","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns t : Set α\nhst : HasSubset.Subset t s\nhs : Ne (μ s) Top.top\n⊢ LT.lt (μ t) Top.top","decl":"theorem measure_lt_top_of_subset (hst : t ⊆ s) (hs : μ s ≠ ∞) : μ t < ∞ :=\n  lt_of_le_of_lt (μ.mono hst) hs.lt_top\n\n"}
{"name":"MeasureTheory.measure_inter_lt_top_of_left_ne_top","module":"Mathlib.MeasureTheory.Measure.MeasureSpaceDef","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns t : Set α\nhs_finite : Ne (μ s) Top.top\n⊢ LT.lt (μ (Inter.inter s t)) Top.top","decl":"theorem measure_inter_lt_top_of_left_ne_top (hs_finite : μ s ≠ ∞) : μ (s ∩ t) < ∞ :=\n  measure_lt_top_of_subset inter_subset_left hs_finite\n\n"}
{"name":"MeasureTheory.measure_inter_lt_top_of_right_ne_top","module":"Mathlib.MeasureTheory.Measure.MeasureSpaceDef","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns t : Set α\nht_finite : Ne (μ t) Top.top\n⊢ LT.lt (μ (Inter.inter s t)) Top.top","decl":"theorem measure_inter_lt_top_of_right_ne_top (ht_finite : μ t ≠ ∞) : μ (s ∩ t) < ∞ :=\n  measure_lt_top_of_subset inter_subset_right ht_finite\n\n"}
{"name":"MeasureTheory.measure_inter_null_of_null_right","module":"Mathlib.MeasureTheory.Measure.MeasureSpaceDef","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nμ : MeasureTheory.Measure α\nS T : Set α\nh : Eq (μ T) 0\n⊢ Eq (μ (Inter.inter S T)) 0","decl":"theorem measure_inter_null_of_null_right (S : Set α) {T : Set α} (h : μ T = 0) : μ (S ∩ T) = 0 :=\n  measure_mono_null inter_subset_right h\n\n"}
{"name":"MeasureTheory.measure_inter_null_of_null_left","module":"Mathlib.MeasureTheory.Measure.MeasureSpaceDef","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nμ : MeasureTheory.Measure α\nS T : Set α\nh : Eq (μ S) 0\n⊢ Eq (μ (Inter.inter S T)) 0","decl":"theorem measure_inter_null_of_null_left {S : Set α} (T : Set α) (h : μ S = 0) : μ (S ∩ T) = 0 :=\n  measure_mono_null inter_subset_left h\n\n"}
{"name":"MeasurableSpace.ae_induction_on_inter","module":"Mathlib.MeasureTheory.Measure.MeasureSpaceDef","initialProofState":"α : Type u_6\nβ : Type u_7\ninst✝ : MeasurableSpace β\nμ : MeasureTheory.Measure β\nC : β → Set α → Prop\ns : Set (Set α)\nm : MeasurableSpace α\nh_eq : Eq m (MeasurableSpace.generateFrom s)\nh_inter : IsPiSystem s\nh_empty : Filter.Eventually (fun x => C x EmptyCollection.emptyCollection) (MeasureTheory.ae μ)\nh_basic : Filter.Eventually (fun x => ∀ (t : Set α), Membership.mem s t → C x t) (MeasureTheory.ae μ)\nh_compl : Filter.Eventually (fun x => ∀ (t : Set α), MeasurableSet t → C x t → C x (HasCompl.compl t)) (MeasureTheory.ae μ)\nh_union : Filter.Eventually (fun x => ∀ (f : Nat → Set α), Pairwise (Function.onFun Disjoint f) → (∀ (i : Nat), MeasurableSet (f i)) → (∀ (i : Nat), C x (f i)) → C x (Set.iUnion fun i => f i)) (MeasureTheory.ae μ)\n⊢ Filter.Eventually (fun x => ∀ ⦃t : Set α⦄, MeasurableSet t → C x t) (MeasureTheory.ae μ)","decl":"/-- Given a predicate on `β` and `Set α` where both `α` and `β` are measurable spaces, if the\npredicate holds for almost every `x : β` and\n- `∅ : Set α`\n- a family of sets generating the σ-algebra of `α`\nMoreover, if for almost every `x : β`, the predicate is closed under complements and countable\ndisjoint unions, then the predicate holds for almost every `x : β` and all measurable sets of `α`.\n\nThis is an AE version of `MeasurableSpace.induction_on_inter` where the condition is dependent\non a measurable space `β`. -/\ntheorem _root_.MeasurableSpace.ae_induction_on_inter\n    {α β : Type*} [MeasurableSpace β] {μ : Measure β}\n    {C : β → Set α → Prop} {s : Set (Set α)} [m : MeasurableSpace α]\n    (h_eq : m = MeasurableSpace.generateFrom s)\n    (h_inter : IsPiSystem s) (h_empty : ∀ᵐ x ∂μ, C x ∅) (h_basic : ∀ᵐ x ∂μ, ∀ t ∈ s, C x t)\n    (h_compl : ∀ᵐ x ∂μ, ∀ t, MeasurableSet t → C x t → C x tᶜ)\n    (h_union : ∀ᵐ x ∂μ, ∀ f : ℕ → Set α,\n        Pairwise (Disjoint on f) → (∀ i, MeasurableSet (f i)) → (∀ i, C x (f i)) → C x (⋃ i, f i)) :\n    ∀ᵐ x ∂μ, ∀ ⦃t⦄, MeasurableSet t → C x t := by\n  filter_upwards [h_empty, h_basic, h_compl, h_union] with x hx_empty hx_basic hx_compl hx_union\n    using MeasurableSpace.induction_on_inter (C := fun t _ ↦ C x t)\n      h_eq h_inter hx_empty hx_basic hx_compl hx_union\n\n"}
{"name":"MeasureTheory.toMeasurable_def","module":"Mathlib.MeasureTheory.Measure.MeasureSpaceDef","initialProofState":"α : Type u_6\ninst✝ : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : Set α\n⊢ Eq (MeasureTheory.toMeasurable μ s) (dite (Exists fun t => And (Superset t s) (And (MeasurableSet t) ((MeasureTheory.ae μ).EventuallyEq t s))) (fun h => h.choose) fun h => dite (Exists fun t => And (Superset t s) (And (MeasurableSet t) (∀ (u : Set α), MeasurableSet u → Eq (μ (Inter.inter t u)) (μ (Inter.inter s u))))) (fun h' => h'.choose) fun h' => ⋯.choose)","decl":"open Classical in\n/-- A measurable set `t ⊇ s` such that `μ t = μ s`. It even satisfies `μ (t ∩ u) = μ (s ∩ u)` for\nany measurable set `u` if `μ s ≠ ∞`, see `measure_toMeasurable_inter`.\n(This property holds without the assumption `μ s ≠ ∞` when the space is s-finite -- for example\nσ-finite), see `measure_toMeasurable_inter_of_sFinite`).\nIf `s` is a null measurable set, then\nwe also have `t =ᵐ[μ] s`, see `NullMeasurableSet.toMeasurable_ae_eq`.\nThis notion is sometimes called a \"measurable hull\" in the literature. -/\nirreducible_def toMeasurable (μ : Measure α) (s : Set α) : Set α :=\n  if h : ∃ t, t ⊇ s ∧ MeasurableSet t ∧ t =ᵐ[μ] s then h.choose else\n    if h' : ∃ t, t ⊇ s ∧ MeasurableSet t ∧\n      ∀ u, MeasurableSet u → μ (t ∩ u) = μ (s ∩ u) then h'.choose\n    else (exists_measurable_superset μ s).choose\n\n"}
{"name":"MeasureTheory.subset_toMeasurable","module":"Mathlib.MeasureTheory.Measure.MeasureSpaceDef","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : Set α\n⊢ HasSubset.Subset s (MeasureTheory.toMeasurable μ s)","decl":"theorem subset_toMeasurable (μ : Measure α) (s : Set α) : s ⊆ toMeasurable μ s := by\n  rw [toMeasurable_def]; split_ifs with hs h's\n  exacts [hs.choose_spec.1, h's.choose_spec.1, (exists_measurable_superset μ s).choose_spec.1]\n\n"}
{"name":"MeasureTheory.ae_le_toMeasurable","module":"Mathlib.MeasureTheory.Measure.MeasureSpaceDef","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : Set α\n⊢ (MeasureTheory.ae μ).EventuallyLE s (MeasureTheory.toMeasurable μ s)","decl":"theorem ae_le_toMeasurable : s ≤ᵐ[μ] toMeasurable μ s :=\n  HasSubset.Subset.eventuallyLE (subset_toMeasurable _ _)\n\n"}
{"name":"MeasureTheory.measurableSet_toMeasurable","module":"Mathlib.MeasureTheory.Measure.MeasureSpaceDef","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : Set α\n⊢ MeasurableSet (MeasureTheory.toMeasurable μ s)","decl":"@[simp]\ntheorem measurableSet_toMeasurable (μ : Measure α) (s : Set α) :\n    MeasurableSet (toMeasurable μ s) := by\n  rw [toMeasurable_def]; split_ifs with hs h's\n  exacts [hs.choose_spec.2.1, h's.choose_spec.2.1,\n          (exists_measurable_superset μ s).choose_spec.2.1]\n\n"}
{"name":"MeasureTheory.measure_toMeasurable","module":"Mathlib.MeasureTheory.Measure.MeasureSpaceDef","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : Set α\n⊢ Eq (μ (MeasureTheory.toMeasurable μ s)) (μ s)","decl":"@[simp]\ntheorem measure_toMeasurable (s : Set α) : μ (toMeasurable μ s) = μ s := by\n  rw [toMeasurable_def]; split_ifs with hs h's\n  · exact measure_congr hs.choose_spec.2.2\n  · simpa only [inter_univ] using h's.choose_spec.2.2 univ MeasurableSet.univ\n  · exact (exists_measurable_superset μ s).choose_spec.2.2\n\n"}
{"name":"Measurable.aemeasurable","module":"Mathlib.MeasureTheory.Measure.MeasureSpaceDef","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\ninst✝ : MeasurableSpace β\nf : α → β\nμ : MeasureTheory.Measure α\nh : Measurable f\n⊢ AEMeasurable f μ","decl":"@[fun_prop, aesop unsafe 30% apply (rule_sets := [Measurable])]\ntheorem Measurable.aemeasurable (h : Measurable f) : AEMeasurable f μ :=\n  ⟨f, h, ae_eq_refl f⟩\n\n"}
{"name":"AEMeasurable.of_discrete","module":"Mathlib.MeasureTheory.Measure.MeasureSpaceDef","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\ninst✝¹ : MeasurableSpace β\nf : α → β\nμ : MeasureTheory.Measure α\ninst✝ : DiscreteMeasurableSpace α\n⊢ AEMeasurable f μ","decl":"lemma of_discrete [DiscreteMeasurableSpace α] : AEMeasurable f μ :=\n  Measurable.of_discrete.aemeasurable\n\n"}
{"name":"AEMeasurable.measurable_mk","module":"Mathlib.MeasureTheory.Measure.MeasureSpaceDef","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\ninst✝ : MeasurableSpace β\nf : α → β\nμ : MeasureTheory.Measure α\nh : AEMeasurable f μ\n⊢ Measurable (AEMeasurable.mk f h)","decl":"@[measurability]\ntheorem measurable_mk (h : AEMeasurable f μ) : Measurable (h.mk f) :=\n  (Classical.choose_spec h).1\n\n"}
{"name":"AEMeasurable.ae_eq_mk","module":"Mathlib.MeasureTheory.Measure.MeasureSpaceDef","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\ninst✝ : MeasurableSpace β\nf : α → β\nμ : MeasureTheory.Measure α\nh : AEMeasurable f μ\n⊢ (MeasureTheory.ae μ).EventuallyEq f (AEMeasurable.mk f h)","decl":"theorem ae_eq_mk (h : AEMeasurable f μ) : f =ᵐ[μ] h.mk f :=\n  (Classical.choose_spec h).2\n\n"}
{"name":"AEMeasurable.congr","module":"Mathlib.MeasureTheory.Measure.MeasureSpaceDef","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\ninst✝ : MeasurableSpace β\nf g : α → β\nμ : MeasureTheory.Measure α\nhf : AEMeasurable f μ\nh : (MeasureTheory.ae μ).EventuallyEq f g\n⊢ AEMeasurable g μ","decl":"theorem congr (hf : AEMeasurable f μ) (h : f =ᵐ[μ] g) : AEMeasurable g μ :=\n  ⟨hf.mk f, hf.measurable_mk, h.symm.trans hf.ae_eq_mk⟩\n\n"}
{"name":"aemeasurable_congr","module":"Mathlib.MeasureTheory.Measure.MeasureSpaceDef","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\ninst✝ : MeasurableSpace β\nf g : α → β\nμ : MeasureTheory.Measure α\nh : (MeasureTheory.ae μ).EventuallyEq f g\n⊢ Iff (AEMeasurable f μ) (AEMeasurable g μ)","decl":"theorem aemeasurable_congr (h : f =ᵐ[μ] g) : AEMeasurable f μ ↔ AEMeasurable g μ :=\n  ⟨fun hf => AEMeasurable.congr hf h, fun hg => AEMeasurable.congr hg h.symm⟩\n\n"}
{"name":"aemeasurable_const","module":"Mathlib.MeasureTheory.Measure.MeasureSpaceDef","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\ninst✝ : MeasurableSpace β\nμ : MeasureTheory.Measure α\nb : β\n⊢ AEMeasurable (fun _a => b) μ","decl":"@[simp, fun_prop, measurability]\ntheorem aemeasurable_const {b : β} : AEMeasurable (fun _a : α => b) μ :=\n  measurable_const.aemeasurable\n\n"}
{"name":"aemeasurable_id","module":"Mathlib.MeasureTheory.Measure.MeasureSpaceDef","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\n⊢ AEMeasurable id μ","decl":"@[measurability]\ntheorem aemeasurable_id : AEMeasurable id μ :=\n  measurable_id.aemeasurable\n\n"}
{"name":"aemeasurable_id'","module":"Mathlib.MeasureTheory.Measure.MeasureSpaceDef","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\n⊢ AEMeasurable (fun x => x) μ","decl":"@[measurability]\ntheorem aemeasurable_id' : AEMeasurable (fun x => x) μ :=\n  measurable_id.aemeasurable\n\n"}
{"name":"Measurable.comp_aemeasurable","module":"Mathlib.MeasureTheory.Measure.MeasureSpaceDef","initialProofState":"α : Type u_1\nβ : Type u_2\nδ : Type u_4\nm : MeasurableSpace α\ninst✝¹ : MeasurableSpace β\nμ : MeasureTheory.Measure α\ninst✝ : MeasurableSpace δ\nf : α → δ\ng : δ → β\nhg : Measurable g\nhf : AEMeasurable f μ\n⊢ AEMeasurable (Function.comp g f) μ","decl":"theorem Measurable.comp_aemeasurable [MeasurableSpace δ] {f : α → δ} {g : δ → β} (hg : Measurable g)\n    (hf : AEMeasurable f μ) : AEMeasurable (g ∘ f) μ :=\n  ⟨g ∘ hf.mk f, hg.comp hf.measurable_mk, EventuallyEq.fun_comp hf.ae_eq_mk _⟩\n\n"}
{"name":"Measurable.comp_aemeasurable'","module":"Mathlib.MeasureTheory.Measure.MeasureSpaceDef","initialProofState":"α : Type u_1\nβ : Type u_2\nδ : Type u_4\nm : MeasurableSpace α\ninst✝¹ : MeasurableSpace β\nμ : MeasureTheory.Measure α\ninst✝ : MeasurableSpace δ\nf : α → δ\ng : δ → β\nhg : Measurable g\nhf : AEMeasurable f μ\n⊢ AEMeasurable (fun x => g (f x)) μ","decl":"@[fun_prop, measurability]\ntheorem Measurable.comp_aemeasurable' [MeasurableSpace δ] {f : α → δ} {g : δ → β}\n    (hg : Measurable g) (hf : AEMeasurable f μ) : AEMeasurable (fun x ↦ g (f x)) μ :=\n  Measurable.comp_aemeasurable hg hf\n\n"}
