{"name":"FormalMultilinearSeries.changeOriginSeriesTerm_apply","module":"Mathlib.Analysis.Analytic.ChangeOrigin","initialProofState":"ùïú : Type u_1\nE : Type u_2\nF : Type u_3\ninst‚úù‚Å¥ : NontriviallyNormedField ùïú\ninst‚úù¬≥ : NormedAddCommGroup E\ninst‚úù¬≤ : NormedSpace ùïú E\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : NormedSpace ùïú F\np : FormalMultilinearSeries ùïú E F\nk l : Nat\ns : Finset (Fin (HAdd.hAdd k l))\nhs : Eq s.card l\nx y : E\n‚ä¢ Eq (((p.changeOriginSeriesTerm k l s hs) fun x_1 => x) fun x => y) ((p (HAdd.hAdd k l)) (s.piecewise (fun x_1 => x) fun x => y))","decl":"theorem changeOriginSeriesTerm_apply (k l : ‚Ñï) (s : Finset (Fin (k + l))) (hs : s.card = l)\n    (x y : E) :\n    (p.changeOriginSeriesTerm k l s hs (fun _ => x) fun _ => y) =\n      p (k + l) (s.piecewise (fun _ => x) fun _ => y) :=\n  ContinuousMultilinearMap.curryFinFinset_apply_const _ _ _ _ _\n\n"}
{"name":"FormalMultilinearSeries.norm_changeOriginSeriesTerm","module":"Mathlib.Analysis.Analytic.ChangeOrigin","initialProofState":"ùïú : Type u_1\nE : Type u_2\nF : Type u_3\ninst‚úù‚Å¥ : NontriviallyNormedField ùïú\ninst‚úù¬≥ : NormedAddCommGroup E\ninst‚úù¬≤ : NormedSpace ùïú E\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : NormedSpace ùïú F\np : FormalMultilinearSeries ùïú E F\nk l : Nat\ns : Finset (Fin (HAdd.hAdd k l))\nhs : Eq s.card l\n‚ä¢ Eq (Norm.norm (p.changeOriginSeriesTerm k l s hs)) (Norm.norm (p (HAdd.hAdd k l)))","decl":"@[simp]\ntheorem norm_changeOriginSeriesTerm (k l : ‚Ñï) (s : Finset (Fin (k + l))) (hs : s.card = l) :\n    ‚Äñp.changeOriginSeriesTerm k l s hs‚Äñ = ‚Äñp (k + l)‚Äñ := by\n  simp only [changeOriginSeriesTerm, LinearIsometryEquiv.norm_map]\n\n"}
{"name":"FormalMultilinearSeries.nnnorm_changeOriginSeriesTerm","module":"Mathlib.Analysis.Analytic.ChangeOrigin","initialProofState":"ùïú : Type u_1\nE : Type u_2\nF : Type u_3\ninst‚úù‚Å¥ : NontriviallyNormedField ùïú\ninst‚úù¬≥ : NormedAddCommGroup E\ninst‚úù¬≤ : NormedSpace ùïú E\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : NormedSpace ùïú F\np : FormalMultilinearSeries ùïú E F\nk l : Nat\ns : Finset (Fin (HAdd.hAdd k l))\nhs : Eq s.card l\n‚ä¢ Eq (NNNorm.nnnorm (p.changeOriginSeriesTerm k l s hs)) (NNNorm.nnnorm (p (HAdd.hAdd k l)))","decl":"@[simp]\ntheorem nnnorm_changeOriginSeriesTerm (k l : ‚Ñï) (s : Finset (Fin (k + l))) (hs : s.card = l) :\n    ‚Äñp.changeOriginSeriesTerm k l s hs‚Äñ‚Çä = ‚Äñp (k + l)‚Äñ‚Çä := by\n  simp only [changeOriginSeriesTerm, LinearIsometryEquiv.nnnorm_map]\n\n"}
{"name":"FormalMultilinearSeries.nnnorm_changeOriginSeriesTerm_apply_le","module":"Mathlib.Analysis.Analytic.ChangeOrigin","initialProofState":"ùïú : Type u_1\nE : Type u_2\nF : Type u_3\ninst‚úù‚Å¥ : NontriviallyNormedField ùïú\ninst‚úù¬≥ : NormedAddCommGroup E\ninst‚úù¬≤ : NormedSpace ùïú E\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : NormedSpace ùïú F\np : FormalMultilinearSeries ùïú E F\nk l : Nat\ns : Finset (Fin (HAdd.hAdd k l))\nhs : Eq s.card l\nx y : E\n‚ä¢ LE.le (NNNorm.nnnorm (((p.changeOriginSeriesTerm k l s hs) fun x_1 => x) fun x => y)) (HMul.hMul (HMul.hMul (NNNorm.nnnorm (p (HAdd.hAdd k l))) (HPow.hPow (NNNorm.nnnorm x) l)) (HPow.hPow (NNNorm.nnnorm y) k))","decl":"theorem nnnorm_changeOriginSeriesTerm_apply_le (k l : ‚Ñï) (s : Finset (Fin (k + l)))\n    (hs : s.card = l) (x y : E) :\n    ‚Äñp.changeOriginSeriesTerm k l s hs (fun _ => x) fun _ => y‚Äñ‚Çä ‚â§\n      ‚Äñp (k + l)‚Äñ‚Çä * ‚Äñx‚Äñ‚Çä ^ l * ‚Äñy‚Äñ‚Çä ^ k := by\n  rw [‚Üê p.nnnorm_changeOriginSeriesTerm k l s hs, ‚Üê Fin.prod_const, ‚Üê Fin.prod_const]\n  apply ContinuousMultilinearMap.le_of_opNNNorm_le\n  apply ContinuousMultilinearMap.le_opNNNorm\n\n"}
{"name":"FormalMultilinearSeries.nnnorm_changeOriginSeries_le_tsum","module":"Mathlib.Analysis.Analytic.ChangeOrigin","initialProofState":"ùïú : Type u_1\nE : Type u_2\nF : Type u_3\ninst‚úù‚Å¥ : NontriviallyNormedField ùïú\ninst‚úù¬≥ : NormedAddCommGroup E\ninst‚úù¬≤ : NormedSpace ùïú E\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : NormedSpace ùïú F\np : FormalMultilinearSeries ùïú E F\nk l : Nat\n‚ä¢ LE.le (NNNorm.nnnorm (p.changeOriginSeries k l)) (tsum fun x => NNNorm.nnnorm (p (HAdd.hAdd k l)))","decl":"theorem nnnorm_changeOriginSeries_le_tsum (k l : ‚Ñï) :\n    ‚Äñp.changeOriginSeries k l‚Äñ‚Çä ‚â§\n      ‚àë' _ : { s : Finset (Fin (k + l)) // s.card = l }, ‚Äñp (k + l)‚Äñ‚Çä :=\n  (nnnorm_sum_le _ (fun t => changeOriginSeriesTerm p k l (Subtype.val t) t.prop)).trans_eq <| by\n    simp_rw [tsum_fintype, nnnorm_changeOriginSeriesTerm (p := p) (k := k) (l := l)]\n\n"}
{"name":"FormalMultilinearSeries.nnnorm_changeOriginSeries_apply_le_tsum","module":"Mathlib.Analysis.Analytic.ChangeOrigin","initialProofState":"ùïú : Type u_1\nE : Type u_2\nF : Type u_3\ninst‚úù‚Å¥ : NontriviallyNormedField ùïú\ninst‚úù¬≥ : NormedAddCommGroup E\ninst‚úù¬≤ : NormedSpace ùïú E\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : NormedSpace ùïú F\np : FormalMultilinearSeries ùïú E F\nk l : Nat\nx : E\n‚ä¢ LE.le (NNNorm.nnnorm ((p.changeOriginSeries k l) fun x_1 => x)) (tsum fun x_1 => HMul.hMul (NNNorm.nnnorm (p (HAdd.hAdd k l))) (HPow.hPow (NNNorm.nnnorm x) l))","decl":"theorem nnnorm_changeOriginSeries_apply_le_tsum (k l : ‚Ñï) (x : E) :\n    ‚Äñp.changeOriginSeries k l fun _ => x‚Äñ‚Çä ‚â§\n      ‚àë' _ : { s : Finset (Fin (k + l)) // s.card = l }, ‚Äñp (k + l)‚Äñ‚Çä * ‚Äñx‚Äñ‚Çä ^ l := by\n  rw [NNReal.tsum_mul_right, ‚Üê Fin.prod_const]\n  exact (p.changeOriginSeries k l).le_of_opNNNorm_le (p.nnnorm_changeOriginSeries_le_tsum _ _) _\n\n"}
{"name":"FormalMultilinearSeries.changeOriginIndexEquiv_symm_apply_fst","module":"Mathlib.Analysis.Analytic.ChangeOrigin","initialProofState":"s : Sigma fun n => Finset (Fin n)\n‚ä¢ Eq (FormalMultilinearSeries.changeOriginIndexEquiv.symm s).fst (HSub.hSub s.fst s.snd.card)","decl":"/-- An auxiliary equivalence useful in the proofs about\n`FormalMultilinearSeries.changeOriginSeries`: the set of triples `(k, l, s)`, where `s` is a\n`Finset (Fin (k + l))` of cardinality `l` is equivalent to the set of pairs `(n, s)`, where `s` is a\n`Finset (Fin n)`.\n\nThe forward map sends `(k, l, s)` to `(k + l, s)` and the inverse map sends `(n, s)` to\n`(n - Finset.card s, Finset.card s, s)`. The actual definition is less readable because of problems\nwith non-definitional equalities. -/\n@[simps]\ndef changeOriginIndexEquiv :\n    (Œ£ k l : ‚Ñï, { s : Finset (Fin (k + l)) // s.card = l }) ‚âÉ Œ£ n : ‚Ñï, Finset (Fin n) where\n  toFun s := ‚ü®s.1 + s.2.1, s.2.2‚ü©\n  invFun s :=\n    ‚ü®s.1 - s.2.card, s.2.card,\n      ‚ü®s.2.map\n        (finCongr <| (tsub_add_cancel_of_le <| card_finset_fin_le s.2).symm).toEmbedding,\n        Finset.card_map _‚ü©‚ü©\n  left_inv := by\n    rintro ‚ü®k, l, ‚ü®s : Finset (Fin <| k + l), hs : s.card = l‚ü©‚ü©\n    dsimp only [Subtype.coe_mk]\n    -- Lean can't automatically generalize `k' = k + l - s.card`, `l' = s.card`, so we explicitly\n    -- formulate the generalized goal\n    suffices ‚àÄ k' l', k' = k ‚Üí l' = l ‚Üí ‚àÄ (hkl : k + l = k' + l') (hs'),\n        (‚ü®k', l', ‚ü®s.map (finCongr hkl).toEmbedding, hs'‚ü©‚ü© :\n          Œ£k l : ‚Ñï, { s : Finset (Fin (k + l)) // s.card = l }) = ‚ü®k, l, ‚ü®s, hs‚ü©‚ü© by\n      apply this <;> simp only [hs, add_tsub_cancel_right]\n    simp\n  right_inv := by\n    rintro ‚ü®n, s‚ü©\n    simp [tsub_add_cancel_of_le (card_finset_fin_le s), finCongr_eq_equivCast]\n\n"}
{"name":"FormalMultilinearSeries.changeOriginIndexEquiv_apply_fst","module":"Mathlib.Analysis.Analytic.ChangeOrigin","initialProofState":"s : Sigma fun k => Sigma fun l => Subtype fun s => Eq s.card l\n‚ä¢ Eq (FormalMultilinearSeries.changeOriginIndexEquiv s).fst (HAdd.hAdd s.fst s.snd.fst)","decl":"/-- An auxiliary equivalence useful in the proofs about\n`FormalMultilinearSeries.changeOriginSeries`: the set of triples `(k, l, s)`, where `s` is a\n`Finset (Fin (k + l))` of cardinality `l` is equivalent to the set of pairs `(n, s)`, where `s` is a\n`Finset (Fin n)`.\n\nThe forward map sends `(k, l, s)` to `(k + l, s)` and the inverse map sends `(n, s)` to\n`(n - Finset.card s, Finset.card s, s)`. The actual definition is less readable because of problems\nwith non-definitional equalities. -/\n@[simps]\ndef changeOriginIndexEquiv :\n    (Œ£ k l : ‚Ñï, { s : Finset (Fin (k + l)) // s.card = l }) ‚âÉ Œ£ n : ‚Ñï, Finset (Fin n) where\n  toFun s := ‚ü®s.1 + s.2.1, s.2.2‚ü©\n  invFun s :=\n    ‚ü®s.1 - s.2.card, s.2.card,\n      ‚ü®s.2.map\n        (finCongr <| (tsub_add_cancel_of_le <| card_finset_fin_le s.2).symm).toEmbedding,\n        Finset.card_map _‚ü©‚ü©\n  left_inv := by\n    rintro ‚ü®k, l, ‚ü®s : Finset (Fin <| k + l), hs : s.card = l‚ü©‚ü©\n    dsimp only [Subtype.coe_mk]\n    -- Lean can't automatically generalize `k' = k + l - s.card`, `l' = s.card`, so we explicitly\n    -- formulate the generalized goal\n    suffices ‚àÄ k' l', k' = k ‚Üí l' = l ‚Üí ‚àÄ (hkl : k + l = k' + l') (hs'),\n        (‚ü®k', l', ‚ü®s.map (finCongr hkl).toEmbedding, hs'‚ü©‚ü© :\n          Œ£k l : ‚Ñï, { s : Finset (Fin (k + l)) // s.card = l }) = ‚ü®k, l, ‚ü®s, hs‚ü©‚ü© by\n      apply this <;> simp only [hs, add_tsub_cancel_right]\n    simp\n  right_inv := by\n    rintro ‚ü®n, s‚ü©\n    simp [tsub_add_cancel_of_le (card_finset_fin_le s), finCongr_eq_equivCast]\n\n"}
{"name":"FormalMultilinearSeries.changeOriginIndexEquiv_symm_apply_snd_fst","module":"Mathlib.Analysis.Analytic.ChangeOrigin","initialProofState":"s : Sigma fun n => Finset (Fin n)\n‚ä¢ Eq (FormalMultilinearSeries.changeOriginIndexEquiv.symm s).snd.fst s.snd.card","decl":"/-- An auxiliary equivalence useful in the proofs about\n`FormalMultilinearSeries.changeOriginSeries`: the set of triples `(k, l, s)`, where `s` is a\n`Finset (Fin (k + l))` of cardinality `l` is equivalent to the set of pairs `(n, s)`, where `s` is a\n`Finset (Fin n)`.\n\nThe forward map sends `(k, l, s)` to `(k + l, s)` and the inverse map sends `(n, s)` to\n`(n - Finset.card s, Finset.card s, s)`. The actual definition is less readable because of problems\nwith non-definitional equalities. -/\n@[simps]\ndef changeOriginIndexEquiv :\n    (Œ£ k l : ‚Ñï, { s : Finset (Fin (k + l)) // s.card = l }) ‚âÉ Œ£ n : ‚Ñï, Finset (Fin n) where\n  toFun s := ‚ü®s.1 + s.2.1, s.2.2‚ü©\n  invFun s :=\n    ‚ü®s.1 - s.2.card, s.2.card,\n      ‚ü®s.2.map\n        (finCongr <| (tsub_add_cancel_of_le <| card_finset_fin_le s.2).symm).toEmbedding,\n        Finset.card_map _‚ü©‚ü©\n  left_inv := by\n    rintro ‚ü®k, l, ‚ü®s : Finset (Fin <| k + l), hs : s.card = l‚ü©‚ü©\n    dsimp only [Subtype.coe_mk]\n    -- Lean can't automatically generalize `k' = k + l - s.card`, `l' = s.card`, so we explicitly\n    -- formulate the generalized goal\n    suffices ‚àÄ k' l', k' = k ‚Üí l' = l ‚Üí ‚àÄ (hkl : k + l = k' + l') (hs'),\n        (‚ü®k', l', ‚ü®s.map (finCongr hkl).toEmbedding, hs'‚ü©‚ü© :\n          Œ£k l : ‚Ñï, { s : Finset (Fin (k + l)) // s.card = l }) = ‚ü®k, l, ‚ü®s, hs‚ü©‚ü© by\n      apply this <;> simp only [hs, add_tsub_cancel_right]\n    simp\n  right_inv := by\n    rintro ‚ü®n, s‚ü©\n    simp [tsub_add_cancel_of_le (card_finset_fin_le s), finCongr_eq_equivCast]\n\n"}
{"name":"FormalMultilinearSeries.changeOriginIndexEquiv_apply_snd","module":"Mathlib.Analysis.Analytic.ChangeOrigin","initialProofState":"s : Sigma fun k => Sigma fun l => Subtype fun s => Eq s.card l\n‚ä¢ Eq (FormalMultilinearSeries.changeOriginIndexEquiv s).snd ‚Üës.snd.snd","decl":"/-- An auxiliary equivalence useful in the proofs about\n`FormalMultilinearSeries.changeOriginSeries`: the set of triples `(k, l, s)`, where `s` is a\n`Finset (Fin (k + l))` of cardinality `l` is equivalent to the set of pairs `(n, s)`, where `s` is a\n`Finset (Fin n)`.\n\nThe forward map sends `(k, l, s)` to `(k + l, s)` and the inverse map sends `(n, s)` to\n`(n - Finset.card s, Finset.card s, s)`. The actual definition is less readable because of problems\nwith non-definitional equalities. -/\n@[simps]\ndef changeOriginIndexEquiv :\n    (Œ£ k l : ‚Ñï, { s : Finset (Fin (k + l)) // s.card = l }) ‚âÉ Œ£ n : ‚Ñï, Finset (Fin n) where\n  toFun s := ‚ü®s.1 + s.2.1, s.2.2‚ü©\n  invFun s :=\n    ‚ü®s.1 - s.2.card, s.2.card,\n      ‚ü®s.2.map\n        (finCongr <| (tsub_add_cancel_of_le <| card_finset_fin_le s.2).symm).toEmbedding,\n        Finset.card_map _‚ü©‚ü©\n  left_inv := by\n    rintro ‚ü®k, l, ‚ü®s : Finset (Fin <| k + l), hs : s.card = l‚ü©‚ü©\n    dsimp only [Subtype.coe_mk]\n    -- Lean can't automatically generalize `k' = k + l - s.card`, `l' = s.card`, so we explicitly\n    -- formulate the generalized goal\n    suffices ‚àÄ k' l', k' = k ‚Üí l' = l ‚Üí ‚àÄ (hkl : k + l = k' + l') (hs'),\n        (‚ü®k', l', ‚ü®s.map (finCongr hkl).toEmbedding, hs'‚ü©‚ü© :\n          Œ£k l : ‚Ñï, { s : Finset (Fin (k + l)) // s.card = l }) = ‚ü®k, l, ‚ü®s, hs‚ü©‚ü© by\n      apply this <;> simp only [hs, add_tsub_cancel_right]\n    simp\n  right_inv := by\n    rintro ‚ü®n, s‚ü©\n    simp [tsub_add_cancel_of_le (card_finset_fin_le s), finCongr_eq_equivCast]\n\n"}
{"name":"FormalMultilinearSeries.changeOriginIndexEquiv_symm_apply_snd_snd_coe","module":"Mathlib.Analysis.Analytic.ChangeOrigin","initialProofState":"s : Sigma fun n => Finset (Fin n)\n‚ä¢ Eq (‚Üë(FormalMultilinearSeries.changeOriginIndexEquiv.symm s).snd.snd) (Finset.map (finCongr ‚ãØ).toEmbedding s.snd)","decl":"/-- An auxiliary equivalence useful in the proofs about\n`FormalMultilinearSeries.changeOriginSeries`: the set of triples `(k, l, s)`, where `s` is a\n`Finset (Fin (k + l))` of cardinality `l` is equivalent to the set of pairs `(n, s)`, where `s` is a\n`Finset (Fin n)`.\n\nThe forward map sends `(k, l, s)` to `(k + l, s)` and the inverse map sends `(n, s)` to\n`(n - Finset.card s, Finset.card s, s)`. The actual definition is less readable because of problems\nwith non-definitional equalities. -/\n@[simps]\ndef changeOriginIndexEquiv :\n    (Œ£ k l : ‚Ñï, { s : Finset (Fin (k + l)) // s.card = l }) ‚âÉ Œ£ n : ‚Ñï, Finset (Fin n) where\n  toFun s := ‚ü®s.1 + s.2.1, s.2.2‚ü©\n  invFun s :=\n    ‚ü®s.1 - s.2.card, s.2.card,\n      ‚ü®s.2.map\n        (finCongr <| (tsub_add_cancel_of_le <| card_finset_fin_le s.2).symm).toEmbedding,\n        Finset.card_map _‚ü©‚ü©\n  left_inv := by\n    rintro ‚ü®k, l, ‚ü®s : Finset (Fin <| k + l), hs : s.card = l‚ü©‚ü©\n    dsimp only [Subtype.coe_mk]\n    -- Lean can't automatically generalize `k' = k + l - s.card`, `l' = s.card`, so we explicitly\n    -- formulate the generalized goal\n    suffices ‚àÄ k' l', k' = k ‚Üí l' = l ‚Üí ‚àÄ (hkl : k + l = k' + l') (hs'),\n        (‚ü®k', l', ‚ü®s.map (finCongr hkl).toEmbedding, hs'‚ü©‚ü© :\n          Œ£k l : ‚Ñï, { s : Finset (Fin (k + l)) // s.card = l }) = ‚ü®k, l, ‚ü®s, hs‚ü©‚ü© by\n      apply this <;> simp only [hs, add_tsub_cancel_right]\n    simp\n  right_inv := by\n    rintro ‚ü®n, s‚ü©\n    simp [tsub_add_cancel_of_le (card_finset_fin_le s), finCongr_eq_equivCast]\n\n"}
{"name":"FormalMultilinearSeries.changeOriginSeriesTerm_changeOriginIndexEquiv_symm","module":"Mathlib.Analysis.Analytic.ChangeOrigin","initialProofState":"ùïú : Type u_1\nE : Type u_2\nF : Type u_3\ninst‚úù‚Å¥ : NontriviallyNormedField ùïú\ninst‚úù¬≥ : NormedAddCommGroup E\ninst‚úù¬≤ : NormedSpace ùïú E\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : NormedSpace ùïú F\np : FormalMultilinearSeries ùïú E F\nx y : E\nn : Nat\nt : Finset (Fin n)\n‚ä¢ let s := FormalMultilinearSeries.changeOriginIndexEquiv.symm ‚ü®n, t‚ü©;\n  Eq (((p.changeOriginSeriesTerm s.fst s.snd.fst ‚Üës.snd.snd ‚ãØ) fun x_1 => x) fun x => y) ((p n) (t.piecewise (fun x_1 => x) fun x => y))","decl":"lemma changeOriginSeriesTerm_changeOriginIndexEquiv_symm (n t) :\n    let s := changeOriginIndexEquiv.symm ‚ü®n, t‚ü©\n    p.changeOriginSeriesTerm s.1 s.2.1 s.2.2 s.2.2.2 (fun _ ‚Ü¶ x) (fun _ ‚Ü¶ y) =\n    p n (t.piecewise (fun _ ‚Ü¶ x) fun _ ‚Ü¶ y) := by\n  have : ‚àÄ (m) (hm : n = m), p n (t.piecewise (fun _ ‚Ü¶ x) fun _ ‚Ü¶ y) =\n      p m ((t.map (finCongr hm).toEmbedding).piecewise (fun _ ‚Ü¶ x) fun _ ‚Ü¶ y) := by\n    rintro m rfl\n    simp (config := { unfoldPartialApp := true }) [Finset.piecewise]\n  simp_rw [changeOriginSeriesTerm_apply, eq_comm]; apply this\n\n"}
{"name":"FormalMultilinearSeries.changeOriginSeries_summable_aux‚ÇÅ","module":"Mathlib.Analysis.Analytic.ChangeOrigin","initialProofState":"ùïú : Type u_1\nE : Type u_2\nF : Type u_3\ninst‚úù‚Å¥ : NontriviallyNormedField ùïú\ninst‚úù¬≥ : NormedAddCommGroup E\ninst‚úù¬≤ : NormedSpace ùïú E\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : NormedSpace ùïú F\np : FormalMultilinearSeries ùïú E F\nr r' : NNReal\nhr : LT.lt (HAdd.hAdd ‚Üër ‚Üër') p.radius\n‚ä¢ Summable fun s => HMul.hMul (HMul.hMul (NNNorm.nnnorm (p (HAdd.hAdd s.fst s.snd.fst))) (HPow.hPow r s.snd.fst)) (HPow.hPow r' s.fst)","decl":"theorem changeOriginSeries_summable_aux‚ÇÅ {r r' : ‚Ñù‚â•0} (hr : (r + r' : ‚Ñù‚â•0‚àû) < p.radius) :\n    Summable fun s : Œ£k l : ‚Ñï, { s : Finset (Fin (k + l)) // s.card = l } =>\n      ‚Äñp (s.1 + s.2.1)‚Äñ‚Çä * r ^ s.2.1 * r' ^ s.1 := by\n  rw [‚Üê changeOriginIndexEquiv.symm.summable_iff]\n  dsimp only [Function.comp_def, changeOriginIndexEquiv_symm_apply_fst,\n    changeOriginIndexEquiv_symm_apply_snd_fst]\n  have : ‚àÄ n : ‚Ñï,\n      HasSum (fun s : Finset (Fin n) => ‚Äñp (n - s.card + s.card)‚Äñ‚Çä * r ^ s.card * r' ^ (n - s.card))\n        (‚Äñp n‚Äñ‚Çä * (r + r') ^ n) := by\n    intro n\n    -- TODO: why `simp only [tsub_add_cancel_of_le (card_finset_fin_le _)]` fails?\n    convert_to HasSum (fun s : Finset (Fin n) => ‚Äñp n‚Äñ‚Çä * (r ^ s.card * r' ^ (n - s.card))) _\n    ¬∑ ext1 s\n      rw [tsub_add_cancel_of_le (card_finset_fin_le _), mul_assoc]\n    rw [‚Üê Fin.sum_pow_mul_eq_add_pow]\n    exact (hasSum_fintype _).mul_left _\n  refine NNReal.summable_sigma.2 ‚ü®fun n => (this n).summable, ?_‚ü©\n  simp only [(this _).tsum_eq]\n  exact p.summable_nnnorm_mul_pow hr\n\n"}
{"name":"FormalMultilinearSeries.changeOriginSeries_summable_aux‚ÇÇ","module":"Mathlib.Analysis.Analytic.ChangeOrigin","initialProofState":"ùïú : Type u_1\nE : Type u_2\nF : Type u_3\ninst‚úù‚Å¥ : NontriviallyNormedField ùïú\ninst‚úù¬≥ : NormedAddCommGroup E\ninst‚úù¬≤ : NormedSpace ùïú E\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : NormedSpace ùïú F\np : FormalMultilinearSeries ùïú E F\nr : NNReal\nhr : LT.lt (‚Üër) p.radius\nk : Nat\n‚ä¢ Summable fun s => HMul.hMul (NNNorm.nnnorm (p (HAdd.hAdd k s.fst))) (HPow.hPow r s.fst)","decl":"theorem changeOriginSeries_summable_aux‚ÇÇ (hr : (r : ‚Ñù‚â•0‚àû) < p.radius) (k : ‚Ñï) :\n    Summable fun s : Œ£l : ‚Ñï, { s : Finset (Fin (k + l)) // s.card = l } =>\n      ‚Äñp (k + s.1)‚Äñ‚Çä * r ^ s.1 := by\n  rcases ENNReal.lt_iff_exists_add_pos_lt.1 hr with ‚ü®r', h0, hr'‚ü©\n  simpa only [mul_inv_cancel_right‚ÇÄ (pow_pos h0 _).ne'] using\n    ((NNReal.summable_sigma.1 (p.changeOriginSeries_summable_aux‚ÇÅ hr')).1 k).mul_right (r' ^ k)‚Åª¬π\n\n"}
{"name":"FormalMultilinearSeries.changeOriginSeries_summable_aux‚ÇÉ","module":"Mathlib.Analysis.Analytic.ChangeOrigin","initialProofState":"ùïú : Type u_1\nE : Type u_2\nF : Type u_3\ninst‚úù‚Å¥ : NontriviallyNormedField ùïú\ninst‚úù¬≥ : NormedAddCommGroup E\ninst‚úù¬≤ : NormedSpace ùïú E\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : NormedSpace ùïú F\np : FormalMultilinearSeries ùïú E F\nr : NNReal\nhr : LT.lt (‚Üër) p.radius\nk : Nat\n‚ä¢ Summable fun l => HMul.hMul (NNNorm.nnnorm (p.changeOriginSeries k l)) (HPow.hPow r l)","decl":"theorem changeOriginSeries_summable_aux‚ÇÉ {r : ‚Ñù‚â•0} (hr : ‚Üër < p.radius) (k : ‚Ñï) :\n    Summable fun l : ‚Ñï => ‚Äñp.changeOriginSeries k l‚Äñ‚Çä * r ^ l := by\n  refine NNReal.summable_of_le\n    (fun n => ?_) (NNReal.summable_sigma.1 <| p.changeOriginSeries_summable_aux‚ÇÇ hr k).2\n  simp only [NNReal.tsum_mul_right]\n  exact mul_le_mul' (p.nnnorm_changeOriginSeries_le_tsum _ _) le_rfl\n\n"}
{"name":"FormalMultilinearSeries.le_changeOriginSeries_radius","module":"Mathlib.Analysis.Analytic.ChangeOrigin","initialProofState":"ùïú : Type u_1\nE : Type u_2\nF : Type u_3\ninst‚úù‚Å¥ : NontriviallyNormedField ùïú\ninst‚úù¬≥ : NormedAddCommGroup E\ninst‚úù¬≤ : NormedSpace ùïú E\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : NormedSpace ùïú F\np : FormalMultilinearSeries ùïú E F\nk : Nat\n‚ä¢ LE.le p.radius (p.changeOriginSeries k).radius","decl":"theorem le_changeOriginSeries_radius (k : ‚Ñï) : p.radius ‚â§ (p.changeOriginSeries k).radius :=\n  ENNReal.le_of_forall_nnreal_lt fun _r hr =>\n    le_radius_of_summable_nnnorm _ (p.changeOriginSeries_summable_aux‚ÇÉ hr k)\n\n"}
{"name":"FormalMultilinearSeries.nnnorm_changeOrigin_le","module":"Mathlib.Analysis.Analytic.ChangeOrigin","initialProofState":"ùïú : Type u_1\nE : Type u_2\nF : Type u_3\ninst‚úù‚Å¥ : NontriviallyNormedField ùïú\ninst‚úù¬≥ : NormedAddCommGroup E\ninst‚úù¬≤ : NormedSpace ùïú E\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : NormedSpace ùïú F\np : FormalMultilinearSeries ùïú E F\nx : E\nk : Nat\nh : LT.lt (‚Üë(NNNorm.nnnorm x)) p.radius\n‚ä¢ LE.le (NNNorm.nnnorm (p.changeOrigin x k)) (tsum fun s => HMul.hMul (NNNorm.nnnorm (p (HAdd.hAdd k s.fst))) (HPow.hPow (NNNorm.nnnorm x) s.fst))","decl":"theorem nnnorm_changeOrigin_le (k : ‚Ñï) (h : (‚Äñx‚Äñ‚Çä : ‚Ñù‚â•0‚àû) < p.radius) :\n    ‚Äñp.changeOrigin x k‚Äñ‚Çä ‚â§\n      ‚àë' s : Œ£l : ‚Ñï, { s : Finset (Fin (k + l)) // s.card = l }, ‚Äñp (k + s.1)‚Äñ‚Çä * ‚Äñx‚Äñ‚Çä ^ s.1 := by\n  refine tsum_of_nnnorm_bounded ?_ fun l => p.nnnorm_changeOriginSeries_apply_le_tsum k l x\n  have := p.changeOriginSeries_summable_aux‚ÇÇ h k\n  refine HasSum.sigma this.hasSum fun l => ?_\n  exact ((NNReal.summable_sigma.1 this).1 l).hasSum\n\n"}
{"name":"FormalMultilinearSeries.changeOrigin_radius","module":"Mathlib.Analysis.Analytic.ChangeOrigin","initialProofState":"ùïú : Type u_1\nE : Type u_2\nF : Type u_3\ninst‚úù‚Å¥ : NontriviallyNormedField ùïú\ninst‚úù¬≥ : NormedAddCommGroup E\ninst‚úù¬≤ : NormedSpace ùïú E\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : NormedSpace ùïú F\np : FormalMultilinearSeries ùïú E F\nx : E\n‚ä¢ LE.le (HSub.hSub p.radius ‚Üë(NNNorm.nnnorm x)) (p.changeOrigin x).radius","decl":"/-- The radius of convergence of `p.changeOrigin x` is at least `p.radius - ‚Äñx‚Äñ`. In other words,\n`p.changeOrigin x` is well defined on the largest ball contained in the original ball of\nconvergence. -/\ntheorem changeOrigin_radius : p.radius - ‚Äñx‚Äñ‚Çä ‚â§ (p.changeOrigin x).radius := by\n  refine ENNReal.le_of_forall_pos_nnreal_lt fun r _h0 hr => ?_\n  rw [lt_tsub_iff_right, add_comm] at hr\n  have hr' : (‚Äñx‚Äñ‚Çä : ‚Ñù‚â•0‚àû) < p.radius := (le_add_right le_rfl).trans_lt hr\n  apply le_radius_of_summable_nnnorm\n  have : ‚àÄ k : ‚Ñï,\n      ‚Äñp.changeOrigin x k‚Äñ‚Çä * r ^ k ‚â§\n        (‚àë' s : Œ£l : ‚Ñï, { s : Finset (Fin (k + l)) // s.card = l }, ‚Äñp (k + s.1)‚Äñ‚Çä * ‚Äñx‚Äñ‚Çä ^ s.1) *\n          r ^ k :=\n    fun k => mul_le_mul_right' (p.nnnorm_changeOrigin_le k hr') (r ^ k)\n  refine NNReal.summable_of_le this ?_\n  simpa only [‚Üê NNReal.tsum_mul_right] using\n    (NNReal.summable_sigma.1 (p.changeOriginSeries_summable_aux‚ÇÅ hr)).2\n\n"}
{"name":"FormalMultilinearSeries.radius_le_radius_derivSeries","module":"Mathlib.Analysis.Analytic.ChangeOrigin","initialProofState":"ùïú : Type u_1\nE : Type u_2\nF : Type u_3\ninst‚úù‚Å¥ : NontriviallyNormedField ùïú\ninst‚úù¬≥ : NormedAddCommGroup E\ninst‚úù¬≤ : NormedSpace ùïú E\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : NormedSpace ùïú F\np : FormalMultilinearSeries ùïú E F\n‚ä¢ LE.le p.radius p.derivSeries.radius","decl":"theorem radius_le_radius_derivSeries : p.radius ‚â§ p.derivSeries.radius := by\n  apply (p.le_changeOriginSeries_radius 1).trans (radius_le_of_le (fun n ‚Ü¶ ?_))\n  apply (ContinuousLinearMap.norm_compContinuousMultilinearMap_le _ _).trans\n  apply mul_le_of_le_one_left (norm_nonneg  _)\n  exact ContinuousLinearMap.opNorm_le_bound _ zero_le_one (by simp)\n\n"}
{"name":"FormalMultilinearSeries.derivSeries_eq_zero","module":"Mathlib.Analysis.Analytic.ChangeOrigin","initialProofState":"ùïú : Type u_1\nE : Type u_2\nF : Type u_3\ninst‚úù‚Å¥ : NontriviallyNormedField ùïú\ninst‚úù¬≥ : NormedAddCommGroup E\ninst‚úù¬≤ : NormedSpace ùïú E\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : NormedSpace ùïú F\np : FormalMultilinearSeries ùïú E F\nn : Nat\nhp : Eq (p (HAdd.hAdd n 1)) 0\n‚ä¢ Eq (p.derivSeries n) 0","decl":"theorem derivSeries_eq_zero {n : ‚Ñï} (hp : p (n + 1) = 0) : p.derivSeries n = 0 := by\n  suffices p.changeOriginSeries 1 n = 0 by ext v; simp [derivSeries, this]\n  apply Finset.sum_eq_zero (fun s hs ‚Ü¶ ?_)\n  ext v\n  have : p (1 + n) = 0 := p.congr_zero (by abel) hp\n  simp [changeOriginSeriesTerm, ContinuousMultilinearMap.curryFinFinset_apply,\n    ContinuousMultilinearMap.zero_apply, this]\n\n"}
{"name":"FormalMultilinearSeries.hasFPowerSeriesOnBall_changeOrigin","module":"Mathlib.Analysis.Analytic.ChangeOrigin","initialProofState":"ùïú : Type u_1\nE : Type u_2\nF : Type u_3\ninst‚úù‚Åµ : NontriviallyNormedField ùïú\ninst‚úù‚Å¥ : NormedAddCommGroup E\ninst‚úù¬≥ : NormedSpace ùïú E\ninst‚úù¬≤ : NormedAddCommGroup F\ninst‚úù¬π : NormedSpace ùïú F\ninst‚úù : CompleteSpace F\np : FormalMultilinearSeries ùïú E F\nk : Nat\nhr : LT.lt 0 p.radius\n‚ä¢ HasFPowerSeriesOnBall (fun x => p.changeOrigin x k) (p.changeOriginSeries k) 0 p.radius","decl":"theorem hasFPowerSeriesOnBall_changeOrigin (k : ‚Ñï) (hr : 0 < p.radius) :\n    HasFPowerSeriesOnBall (fun x => p.changeOrigin x k) (p.changeOriginSeries k) 0 p.radius :=\n  have := p.le_changeOriginSeries_radius k\n  ((p.changeOriginSeries k).hasFPowerSeriesOnBall (hr.trans_le this)).mono hr this\n\n"}
{"name":"FormalMultilinearSeries.changeOrigin_eval","module":"Mathlib.Analysis.Analytic.ChangeOrigin","initialProofState":"ùïú : Type u_1\nE : Type u_2\nF : Type u_3\ninst‚úù‚Åµ : NontriviallyNormedField ùïú\ninst‚úù‚Å¥ : NormedAddCommGroup E\ninst‚úù¬≥ : NormedSpace ùïú E\ninst‚úù¬≤ : NormedAddCommGroup F\ninst‚úù¬π : NormedSpace ùïú F\ninst‚úù : CompleteSpace F\np : FormalMultilinearSeries ùïú E F\nx y : E\nh : LT.lt (HAdd.hAdd ‚Üë(NNNorm.nnnorm x) ‚Üë(NNNorm.nnnorm y)) p.radius\n‚ä¢ Eq ((p.changeOrigin x).sum y) (p.sum (HAdd.hAdd x y))","decl":"/-- Summing the series `p.changeOrigin x` at a point `y` gives back `p (x + y)`. -/\ntheorem changeOrigin_eval (h : (‚Äñx‚Äñ‚Çä + ‚Äñy‚Äñ‚Çä : ‚Ñù‚â•0‚àû) < p.radius) :\n    (p.changeOrigin x).sum y = p.sum (x + y) := by\n  have radius_pos : 0 < p.radius := lt_of_le_of_lt (zero_le _) h\n  have x_mem_ball : x ‚àà EMetric.ball (0 : E) p.radius :=\n    mem_emetric_ball_zero_iff.2 ((le_add_right le_rfl).trans_lt h)\n  have y_mem_ball : y ‚àà EMetric.ball (0 : E) (p.changeOrigin x).radius := by\n    refine mem_emetric_ball_zero_iff.2 (lt_of_lt_of_le ?_ p.changeOrigin_radius)\n    rwa [lt_tsub_iff_right, add_comm]\n  have x_add_y_mem_ball : x + y ‚àà EMetric.ball (0 : E) p.radius := by\n    refine mem_emetric_ball_zero_iff.2 (lt_of_le_of_lt ?_ h)\n    exact mod_cast nnnorm_add_le x y\n  set f : (Œ£ k l : ‚Ñï, { s : Finset (Fin (k + l)) // s.card = l }) ‚Üí F := fun s =>\n    p.changeOriginSeriesTerm s.1 s.2.1 s.2.2 s.2.2.2 (fun _ => x) fun _ => y\n  have hsf : Summable f := by\n    refine .of_nnnorm_bounded _ (p.changeOriginSeries_summable_aux‚ÇÅ h) ?_\n    rintro ‚ü®k, l, s, hs‚ü©\n    dsimp only [Subtype.coe_mk]\n    exact p.nnnorm_changeOriginSeriesTerm_apply_le _ _ _ _ _ _\n  have hf : HasSum f ((p.changeOrigin x).sum y) := by\n    refine HasSum.sigma_of_hasSum ((p.changeOrigin x).summable y_mem_ball).hasSum (fun k => ?_) hsf\n    ¬∑ dsimp only [f]\n      refine ContinuousMultilinearMap.hasSum_eval ?_ _\n      have := (p.hasFPowerSeriesOnBall_changeOrigin k radius_pos).hasSum x_mem_ball\n      rw [zero_add] at this\n      refine HasSum.sigma_of_hasSum this (fun l => ?_) ?_\n      ¬∑ simp only [changeOriginSeries, ContinuousMultilinearMap.sum_apply]\n        apply hasSum_fintype\n      ¬∑ refine .of_nnnorm_bounded _\n          (p.changeOriginSeries_summable_aux‚ÇÇ (mem_emetric_ball_zero_iff.1 x_mem_ball) k)\n            fun s => ?_\n        refine (ContinuousMultilinearMap.le_opNNNorm _ _).trans_eq ?_\n        simp\n  refine hf.unique (changeOriginIndexEquiv.symm.hasSum_iff.1 ?_)\n  refine HasSum.sigma_of_hasSum\n    (p.hasSum x_add_y_mem_ball) (fun n => ?_) (changeOriginIndexEquiv.symm.summable_iff.2 hsf)\n  erw [(p n).map_add_univ (fun _ => x) fun _ => y]\n  simp_rw [‚Üê changeOriginSeriesTerm_changeOriginIndexEquiv_symm]\n  exact hasSum_fintype (fun c => f (changeOriginIndexEquiv.symm ‚ü®n, c‚ü©))\n\n"}
{"name":"FormalMultilinearSeries.analyticAt_changeOrigin","module":"Mathlib.Analysis.Analytic.ChangeOrigin","initialProofState":"ùïú : Type u_1\nE : Type u_2\nF : Type u_3\ninst‚úù‚Åµ : NontriviallyNormedField ùïú\ninst‚úù‚Å¥ : NormedAddCommGroup E\ninst‚úù¬≥ : NormedSpace ùïú E\ninst‚úù¬≤ : NormedAddCommGroup F\ninst‚úù¬π : NormedSpace ùïú F\ninst‚úù : CompleteSpace F\np : FormalMultilinearSeries ùïú E F\nrp : GT.gt p.radius 0\nn : Nat\n‚ä¢ AnalyticAt ùïú (fun x => p.changeOrigin x n) 0","decl":"/-- Power series terms are analytic as we vary the origin -/\ntheorem analyticAt_changeOrigin (p : FormalMultilinearSeries ùïú E F) (rp : p.radius > 0) (n : ‚Ñï) :\n    AnalyticAt ùïú (fun x ‚Ü¶ p.changeOrigin x n) 0 :=\n  (FormalMultilinearSeries.hasFPowerSeriesOnBall_changeOrigin p n rp).analyticAt\n\n"}
{"name":"HasFPowerSeriesWithinOnBall.changeOrigin","module":"Mathlib.Analysis.Analytic.ChangeOrigin","initialProofState":"ùïú : Type u_1\nE : Type u_2\nF : Type u_3\ninst‚úù‚Åµ : NontriviallyNormedField ùïú\ninst‚úù‚Å¥ : NormedAddCommGroup E\ninst‚úù¬≥ : NormedSpace ùïú E\ninst‚úù¬≤ : NormedAddCommGroup F\ninst‚úù¬π : NormedSpace ùïú F\ninst‚úù : CompleteSpace F\nf : E ‚Üí F\np : FormalMultilinearSeries ùïú E F\ns : Set E\nx y : E\nr : ENNReal\nhf : HasFPowerSeriesWithinOnBall f p s x r\nh : LT.lt (ENorm.enorm y) r\nhy : Membership.mem (Insert.insert x s) (HAdd.hAdd x y)\n‚ä¢ HasFPowerSeriesWithinOnBall f (p.changeOrigin y) s (HAdd.hAdd x y) (HSub.hSub r (ENorm.enorm y))","decl":"/-- If a function admits a power series expansion `p` within a set `s` on a ball `B (x, r)`, then\nit also admits a power series on any subball of this ball (even with a different center provided\nit belongs to `s`), given by `p.changeOrigin`. -/\ntheorem HasFPowerSeriesWithinOnBall.changeOrigin (hf : HasFPowerSeriesWithinOnBall f p s x r)\n    (h : ‚Äñy‚Äñ‚Çë < r) (hy : x + y ‚àà insert x s) :\n    HasFPowerSeriesWithinOnBall f (p.changeOrigin y) s (x + y) (r - ‚Äñy‚Äñ‚Çë) where\n  r_le := by\n    apply le_trans _ p.changeOrigin_radius\n    exact tsub_le_tsub hf.r_le le_rfl\n  r_pos := by simp [h]\n  hasSum {z} h'z hz := by\n    have : f (x + y + z) =\n        FormalMultilinearSeries.sum (FormalMultilinearSeries.changeOrigin p y) z := by\n      rw [mem_emetric_ball_zero_iff, lt_tsub_iff_right, add_comm] at hz\n      rw [p.changeOrigin_eval (hz.trans_le hf.r_le), add_assoc, hf.sum]\n      ¬∑ have : insert (x + y) s ‚äÜ insert (x + y) (insert x s) := by\n          apply insert_subset_insert (subset_insert _ _)\n        rw [insert_eq_of_mem hy] at this\n        apply this\n        simpa [add_assoc] using h'z\n      exact mem_emetric_ball_zero_iff.2 (lt_of_le_of_lt (enorm_add_le _ _) hz)\n    rw [this]\n    apply (p.changeOrigin y).hasSum\n    refine EMetric.ball_subset_ball (le_trans ?_ p.changeOrigin_radius) hz\n    exact tsub_le_tsub hf.r_le le_rfl\n\n"}
{"name":"HasFPowerSeriesOnBall.changeOrigin","module":"Mathlib.Analysis.Analytic.ChangeOrigin","initialProofState":"ùïú : Type u_1\nE : Type u_2\nF : Type u_3\ninst‚úù‚Åµ : NontriviallyNormedField ùïú\ninst‚úù‚Å¥ : NormedAddCommGroup E\ninst‚úù¬≥ : NormedSpace ùïú E\ninst‚úù¬≤ : NormedAddCommGroup F\ninst‚úù¬π : NormedSpace ùïú F\ninst‚úù : CompleteSpace F\nf : E ‚Üí F\np : FormalMultilinearSeries ùïú E F\nx y : E\nr : ENNReal\nhf : HasFPowerSeriesOnBall f p x r\nh : LT.lt (‚Üë(NNNorm.nnnorm y)) r\n‚ä¢ HasFPowerSeriesOnBall f (p.changeOrigin y) (HAdd.hAdd x y) (HSub.hSub r ‚Üë(NNNorm.nnnorm y))","decl":"/-- If a function admits a power series expansion `p` on a ball `B (x, r)`, then it also admits a\npower series on any subball of this ball (even with a different center), given by `p.changeOrigin`.\n-/\ntheorem HasFPowerSeriesOnBall.changeOrigin (hf : HasFPowerSeriesOnBall f p x r)\n    (h : (‚Äñy‚Äñ‚Çä : ‚Ñù‚â•0‚àû) < r) : HasFPowerSeriesOnBall f (p.changeOrigin y) (x + y) (r - ‚Äñy‚Äñ‚Çä) := by\n  rw [‚Üê hasFPowerSeriesWithinOnBall_univ] at hf ‚ä¢\n  exact hf.changeOrigin h (by simp)\n\n"}
{"name":"HasFPowerSeriesWithinOnBall.analyticWithinAt_of_mem","module":"Mathlib.Analysis.Analytic.ChangeOrigin","initialProofState":"ùïú : Type u_1\nE : Type u_2\nF : Type u_3\ninst‚úù‚Åµ : NontriviallyNormedField ùïú\ninst‚úù‚Å¥ : NormedAddCommGroup E\ninst‚úù¬≥ : NormedSpace ùïú E\ninst‚úù¬≤ : NormedAddCommGroup F\ninst‚úù¬π : NormedSpace ùïú F\ninst‚úù : CompleteSpace F\nf : E ‚Üí F\np : FormalMultilinearSeries ùïú E F\ns : Set E\nx y : E\nr : ENNReal\nhf : HasFPowerSeriesWithinOnBall f p s x r\nh : Membership.mem (Inter.inter (Insert.insert x s) (EMetric.ball x r)) y\n‚ä¢ AnalyticWithinAt ùïú f s y","decl":"/-- If a function admits a power series expansion `p` on an open ball `B (x, r)`, then\nit is analytic at every point of this ball. -/\ntheorem HasFPowerSeriesWithinOnBall.analyticWithinAt_of_mem\n    (hf : HasFPowerSeriesWithinOnBall f p s x r)\n    (h : y ‚àà insert x s ‚à© EMetric.ball x r) : AnalyticWithinAt ùïú f s y := by\n  have : (‚Äñy - x‚Äñ‚Çä : ‚Ñù‚â•0‚àû) < r := by simpa [edist_eq_enorm_sub] using h.2\n  have := hf.changeOrigin this (by simpa using h.1)\n  rw [add_sub_cancel] at this\n  exact this.analyticWithinAt\n\n"}
{"name":"HasFPowerSeriesOnBall.analyticAt_of_mem","module":"Mathlib.Analysis.Analytic.ChangeOrigin","initialProofState":"ùïú : Type u_1\nE : Type u_2\nF : Type u_3\ninst‚úù‚Åµ : NontriviallyNormedField ùïú\ninst‚úù‚Å¥ : NormedAddCommGroup E\ninst‚úù¬≥ : NormedSpace ùïú E\ninst‚úù¬≤ : NormedAddCommGroup F\ninst‚úù¬π : NormedSpace ùïú F\ninst‚úù : CompleteSpace F\nf : E ‚Üí F\np : FormalMultilinearSeries ùïú E F\nx y : E\nr : ENNReal\nhf : HasFPowerSeriesOnBall f p x r\nh : Membership.mem (EMetric.ball x r) y\n‚ä¢ AnalyticAt ùïú f y","decl":"/-- If a function admits a power series expansion `p` on an open ball `B (x, r)`, then\nit is analytic at every point of this ball. -/\ntheorem HasFPowerSeriesOnBall.analyticAt_of_mem (hf : HasFPowerSeriesOnBall f p x r)\n    (h : y ‚àà EMetric.ball x r) : AnalyticAt ùïú f y := by\n  rw [‚Üê hasFPowerSeriesWithinOnBall_univ] at hf\n  rw [‚Üê analyticWithinAt_univ]\n  exact hf.analyticWithinAt_of_mem (by simpa using h)\n\n"}
{"name":"HasFPowerSeriesWithinOnBall.analyticOn","module":"Mathlib.Analysis.Analytic.ChangeOrigin","initialProofState":"ùïú : Type u_1\nE : Type u_2\nF : Type u_3\ninst‚úù‚Åµ : NontriviallyNormedField ùïú\ninst‚úù‚Å¥ : NormedAddCommGroup E\ninst‚úù¬≥ : NormedSpace ùïú E\ninst‚úù¬≤ : NormedAddCommGroup F\ninst‚úù¬π : NormedSpace ùïú F\ninst‚úù : CompleteSpace F\nf : E ‚Üí F\np : FormalMultilinearSeries ùïú E F\ns : Set E\nx : E\nr : ENNReal\nhf : HasFPowerSeriesWithinOnBall f p s x r\n‚ä¢ AnalyticOn ùïú f (Inter.inter (Insert.insert x s) (EMetric.ball x r))","decl":"theorem HasFPowerSeriesWithinOnBall.analyticOn (hf : HasFPowerSeriesWithinOnBall f p s x r) :\n    AnalyticOn ùïú f (insert x s ‚à© EMetric.ball x r) :=\n  fun _ hy ‚Ü¶ ((analyticWithinAt_insert (y := x)).2 (hf.analyticWithinAt_of_mem hy)).mono\n    inter_subset_left\n\n"}
{"name":"HasFPowerSeriesOnBall.analyticOnNhd","module":"Mathlib.Analysis.Analytic.ChangeOrigin","initialProofState":"ùïú : Type u_1\nE : Type u_2\nF : Type u_3\ninst‚úù‚Åµ : NontriviallyNormedField ùïú\ninst‚úù‚Å¥ : NormedAddCommGroup E\ninst‚úù¬≥ : NormedSpace ùïú E\ninst‚úù¬≤ : NormedAddCommGroup F\ninst‚úù¬π : NormedSpace ùïú F\ninst‚úù : CompleteSpace F\nf : E ‚Üí F\np : FormalMultilinearSeries ùïú E F\nx : E\nr : ENNReal\nhf : HasFPowerSeriesOnBall f p x r\n‚ä¢ AnalyticOnNhd ùïú f (EMetric.ball x r)","decl":"theorem HasFPowerSeriesOnBall.analyticOnNhd (hf : HasFPowerSeriesOnBall f p x r) :\n    AnalyticOnNhd ùïú f (EMetric.ball x r) :=\n  fun _y hy => hf.analyticAt_of_mem hy\n\n"}
{"name":"HasFPowerSeriesOnBall.analyticOn","module":"Mathlib.Analysis.Analytic.ChangeOrigin","initialProofState":"ùïú : Type u_1\nE : Type u_2\nF : Type u_3\ninst‚úù‚Åµ : NontriviallyNormedField ùïú\ninst‚úù‚Å¥ : NormedAddCommGroup E\ninst‚úù¬≥ : NormedSpace ùïú E\ninst‚úù¬≤ : NormedAddCommGroup F\ninst‚úù¬π : NormedSpace ùïú F\ninst‚úù : CompleteSpace F\nf : E ‚Üí F\np : FormalMultilinearSeries ùïú E F\nx : E\nr : ENNReal\nhf : HasFPowerSeriesOnBall f p x r\n‚ä¢ AnalyticOnNhd ùïú f (EMetric.ball x r)","decl":"@[deprecated (since := \"2024-09-26\")]\nalias HasFPowerSeriesOnBall.analyticOn := HasFPowerSeriesOnBall.analyticOnNhd\n\n"}
{"name":"isOpen_analyticAt","module":"Mathlib.Analysis.Analytic.ChangeOrigin","initialProofState":"ùïú : Type u_1\nE : Type u_2\nF : Type u_3\ninst‚úù‚Åµ : NontriviallyNormedField ùïú\ninst‚úù‚Å¥ : NormedAddCommGroup E\ninst‚úù¬≥ : NormedSpace ùïú E\ninst‚úù¬≤ : NormedAddCommGroup F\ninst‚úù¬π : NormedSpace ùïú F\ninst‚úù : CompleteSpace F\nf : E ‚Üí F\n‚ä¢ IsOpen (setOf fun x => AnalyticAt ùïú f x)","decl":"variable (ùïú f) in\n/-- For any function `f` from a normed vector space to a Banach space, the set of points `x` such\nthat `f` is analytic at `x` is open. -/\ntheorem isOpen_analyticAt : IsOpen { x | AnalyticAt ùïú f x } := by\n  rw [isOpen_iff_mem_nhds]\n  rintro x ‚ü®p, r, hr‚ü©\n  exact mem_of_superset (EMetric.ball_mem_nhds _ hr.r_pos) fun y hy => hr.analyticAt_of_mem hy\n\n"}
{"name":"AnalyticAt.eventually_analyticAt","module":"Mathlib.Analysis.Analytic.ChangeOrigin","initialProofState":"ùïú : Type u_1\nE : Type u_2\nF : Type u_3\ninst‚úù‚Åµ : NontriviallyNormedField ùïú\ninst‚úù‚Å¥ : NormedAddCommGroup E\ninst‚úù¬≥ : NormedSpace ùïú E\ninst‚úù¬≤ : NormedAddCommGroup F\ninst‚úù¬π : NormedSpace ùïú F\ninst‚úù : CompleteSpace F\nf : E ‚Üí F\nx : E\nh : AnalyticAt ùïú f x\n‚ä¢ Filter.Eventually (fun y => AnalyticAt ùïú f y) (nhds x)","decl":"theorem AnalyticAt.eventually_analyticAt (h : AnalyticAt ùïú f x) :\n    ‚àÄ·∂† y in ùìù x, AnalyticAt ùïú f y :=\n  (isOpen_analyticAt ùïú f).mem_nhds h\n\n"}
{"name":"AnalyticAt.exists_mem_nhds_analyticOnNhd","module":"Mathlib.Analysis.Analytic.ChangeOrigin","initialProofState":"ùïú : Type u_1\nE : Type u_2\nF : Type u_3\ninst‚úù‚Åµ : NontriviallyNormedField ùïú\ninst‚úù‚Å¥ : NormedAddCommGroup E\ninst‚úù¬≥ : NormedSpace ùïú E\ninst‚úù¬≤ : NormedAddCommGroup F\ninst‚úù¬π : NormedSpace ùïú F\ninst‚úù : CompleteSpace F\nf : E ‚Üí F\nx : E\nh : AnalyticAt ùïú f x\n‚ä¢ Exists fun s => And (Membership.mem (nhds x) s) (AnalyticOnNhd ùïú f s)","decl":"theorem AnalyticAt.exists_mem_nhds_analyticOnNhd (h : AnalyticAt ùïú f x) :\n    ‚àÉ s ‚àà ùìù x, AnalyticOnNhd ùïú f s :=\n  h.eventually_analyticAt.exists_mem\n\n"}
{"name":"AnalyticAt.exists_mem_nhds_analyticOn","module":"Mathlib.Analysis.Analytic.ChangeOrigin","initialProofState":"ùïú : Type u_1\nE : Type u_2\nF : Type u_3\ninst‚úù‚Åµ : NontriviallyNormedField ùïú\ninst‚úù‚Å¥ : NormedAddCommGroup E\ninst‚úù¬≥ : NormedSpace ùïú E\ninst‚úù¬≤ : NormedAddCommGroup F\ninst‚úù¬π : NormedSpace ùïú F\ninst‚úù : CompleteSpace F\nf : E ‚Üí F\nx : E\nh : AnalyticAt ùïú f x\n‚ä¢ Exists fun s => And (Membership.mem (nhds x) s) (AnalyticOnNhd ùïú f s)","decl":"@[deprecated (since := \"2024-09-26\")]\nalias AnalyticAt.exists_mem_nhds_analyticOn := AnalyticAt.exists_mem_nhds_analyticOnNhd\n\n"}
{"name":"AnalyticAt.exists_ball_analyticOnNhd","module":"Mathlib.Analysis.Analytic.ChangeOrigin","initialProofState":"ùïú : Type u_1\nE : Type u_2\nF : Type u_3\ninst‚úù‚Åµ : NontriviallyNormedField ùïú\ninst‚úù‚Å¥ : NormedAddCommGroup E\ninst‚úù¬≥ : NormedSpace ùïú E\ninst‚úù¬≤ : NormedAddCommGroup F\ninst‚úù¬π : NormedSpace ùïú F\ninst‚úù : CompleteSpace F\nf : E ‚Üí F\nx : E\nh : AnalyticAt ùïú f x\n‚ä¢ Exists fun r => And (LT.lt 0 r) (AnalyticOnNhd ùïú f (Metric.ball x r))","decl":"/-- If we're analytic at a point, we're analytic in a nonempty ball -/\ntheorem AnalyticAt.exists_ball_analyticOnNhd (h : AnalyticAt ùïú f x) :\n    ‚àÉ r : ‚Ñù, 0 < r ‚àß AnalyticOnNhd ùïú f (Metric.ball x r) :=\n  Metric.isOpen_iff.mp (isOpen_analyticAt _ _) _ h\n\n"}
{"name":"AnalyticAt.exists_ball_analyticOn","module":"Mathlib.Analysis.Analytic.ChangeOrigin","initialProofState":"ùïú : Type u_1\nE : Type u_2\nF : Type u_3\ninst‚úù‚Åµ : NontriviallyNormedField ùïú\ninst‚úù‚Å¥ : NormedAddCommGroup E\ninst‚úù¬≥ : NormedSpace ùïú E\ninst‚úù¬≤ : NormedAddCommGroup F\ninst‚úù¬π : NormedSpace ùïú F\ninst‚úù : CompleteSpace F\nf : E ‚Üí F\nx : E\nh : AnalyticAt ùïú f x\n‚ä¢ Exists fun r => And (LT.lt 0 r) (AnalyticOnNhd ùïú f (Metric.ball x r))","decl":"@[deprecated (since := \"2024-09-26\")]\nalias AnalyticAt.exists_ball_analyticOn := AnalyticAt.exists_ball_analyticOnNhd\n\n"}
