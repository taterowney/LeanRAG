{"name":"uniformCauchySeqOnFilter_of_fderiv","module":"Mathlib.Analysis.Calculus.UniformLimitsDeriv","initialProofState":"Œπ : Type u_1\nl : Filter Œπ\nE : Type u_2\ninst‚úù‚Åµ : NormedAddCommGroup E\nùïú : Type u_3\ninst‚úù‚Å¥ : NontriviallyNormedField ùïú\ninst‚úù¬≥ : IsRCLikeNormedField ùïú\ninst‚úù¬≤ : NormedSpace ùïú E\nG : Type u_4\ninst‚úù¬π : NormedAddCommGroup G\ninst‚úù : NormedSpace ùïú G\nf : Œπ ‚Üí E ‚Üí G\nf' : Œπ ‚Üí E ‚Üí ContinuousLinearMap (RingHom.id ùïú) E G\nx : E\nhf' : UniformCauchySeqOnFilter f' l (nhds x)\nhf : Filter.Eventually (fun n => HasFDerivAt (f n.1) (f' n.1 n.2) n.2) (SProd.sprod l (nhds x))\nhfg : Cauchy (Filter.map (fun n => f n x) l)\n‚ä¢ UniformCauchySeqOnFilter f l (nhds x)","decl":"/-- If a sequence of functions real or complex functions are eventually differentiable on a\nneighborhood of `x`, they are Cauchy _at_ `x`, and their derivatives\nare a uniform Cauchy sequence in a neighborhood of `x`, then the functions form a uniform Cauchy\nsequence in a neighborhood of `x`. -/\ntheorem uniformCauchySeqOnFilter_of_fderiv (hf' : UniformCauchySeqOnFilter f' l (ùìù x))\n    (hf : ‚àÄ·∂† n : Œπ √ó E in l √óÀ¢ ùìù x, HasFDerivAt (f n.1) (f' n.1 n.2) n.2)\n    (hfg : Cauchy (map (fun n => f n x) l)) : UniformCauchySeqOnFilter f l (ùìù x) := by\n  letI : RCLike ùïú := IsRCLikeNormedField.rclike ùïú\n  letI : NormedSpace ‚Ñù E := NormedSpace.restrictScalars ‚Ñù ùïú _\n  rw [SeminormedAddGroup.uniformCauchySeqOnFilter_iff_tendstoUniformlyOnFilter_zero] at hf' ‚ä¢\n  suffices\n    TendstoUniformlyOnFilter (fun (n : Œπ √ó Œπ) (z : E) => f n.1 z - f n.2 z - (f n.1 x - f n.2 x)) 0\n        (l √óÀ¢ l) (ùìù x) ‚àß\n      TendstoUniformlyOnFilter (fun (n : Œπ √ó Œπ) (_ : E) => f n.1 x - f n.2 x) 0 (l √óÀ¢ l) (ùìù x) by\n    have := this.1.add this.2\n    rw [add_zero] at this\n    exact this.congr (by simp)\n  constructor\n  ¬∑ -- This inequality follows from the mean value theorem. To apply it, we will need to shrink our\n    -- neighborhood to small enough ball\n    rw [Metric.tendstoUniformlyOnFilter_iff] at hf' ‚ä¢\n    intro Œµ hŒµ\n    have := (tendsto_swap4_prod.eventually (hf.prod_mk hf)).diag_of_prod_right\n    obtain ‚ü®a, b, c, d, e‚ü© := eventually_prod_iff.1 ((hf' Œµ hŒµ).and this)\n    obtain ‚ü®R, hR, hR'‚ü© := Metric.nhds_basis_ball.eventually_iff.mp d\n    let r := min 1 R\n    have hr : 0 < r := by simp [r, hR]\n    have hr' : ‚àÄ ‚¶Éy : E‚¶Ñ, y ‚àà Metric.ball x r ‚Üí c y := fun y hy =>\n      hR' (lt_of_lt_of_le (Metric.mem_ball.mp hy) (min_le_right _ _))\n    have hxy : ‚àÄ y : E, y ‚àà Metric.ball x r ‚Üí ‚Äñy - x‚Äñ < 1 := by\n      intro y hy\n      rw [Metric.mem_ball, dist_eq_norm] at hy\n      exact lt_of_lt_of_le hy (min_le_left _ _)\n    have hxyŒµ : ‚àÄ y : E, y ‚àà Metric.ball x r ‚Üí Œµ * ‚Äñy - x‚Äñ < Œµ := by\n      intro y hy\n      exact (mul_lt_iff_lt_one_right hŒµ.lt).mpr (hxy y hy)\n    -- With a small ball in hand, apply the mean value theorem\n    refine\n      eventually_prod_iff.mpr\n        ‚ü®_, b, fun e : E => Metric.ball x r e,\n          eventually_mem_set.mpr (Metric.nhds_basis_ball.mem_of_mem hr), fun {n} hn {y} hy => ?_‚ü©\n    simp only [Pi.zero_apply, dist_zero_left] at e ‚ä¢\n    refine lt_of_le_of_lt ?_ (hxyŒµ y hy)\n    exact\n      Convex.norm_image_sub_le_of_norm_hasFDerivWithin_le\n        (fun y hy => ((e hn (hr' hy)).2.1.sub (e hn (hr' hy)).2.2).hasFDerivWithinAt)\n        (fun y hy => (e hn (hr' hy)).1.le) (convex_ball x r) (Metric.mem_ball_self hr) hy\n  ¬∑ -- This is just `hfg` run through `eventually_prod_iff`\n    refine Metric.tendstoUniformlyOnFilter_iff.mpr fun Œµ hŒµ => ?_\n    obtain ‚ü®t, ht, ht'‚ü© := (Metric.cauchy_iff.mp hfg).2 Œµ hŒµ\n    exact\n      eventually_prod_iff.mpr\n        ‚ü®fun n : Œπ √ó Œπ => f n.1 x ‚àà t ‚àß f n.2 x ‚àà t,\n          eventually_prod_iff.mpr ‚ü®_, ht, _, ht, fun {n} hn {n'} hn' => ‚ü®hn, hn'‚ü©‚ü©,\n          fun _ => True,\n          by simp,\n          fun {n} hn {y} _ => by simpa [norm_sub_rev, dist_eq_norm] using ht' _ hn.1 _ hn.2‚ü©\n\n"}
{"name":"uniformCauchySeqOn_ball_of_fderiv","module":"Mathlib.Analysis.Calculus.UniformLimitsDeriv","initialProofState":"Œπ : Type u_1\nl : Filter Œπ\nE : Type u_2\ninst‚úù‚Åµ : NormedAddCommGroup E\nùïú : Type u_3\ninst‚úù‚Å¥ : NontriviallyNormedField ùïú\ninst‚úù¬≥ : IsRCLikeNormedField ùïú\ninst‚úù¬≤ : NormedSpace ùïú E\nG : Type u_4\ninst‚úù¬π : NormedAddCommGroup G\ninst‚úù : NormedSpace ùïú G\nf : Œπ ‚Üí E ‚Üí G\nf' : Œπ ‚Üí E ‚Üí ContinuousLinearMap (RingHom.id ùïú) E G\nx : E\nr : Real\nhf' : UniformCauchySeqOn f' l (Metric.ball x r)\nhf : ‚àÄ (n : Œπ) (y : E), Membership.mem (Metric.ball x r) y ‚Üí HasFDerivAt (f n) (f' n y) y\nhfg : Cauchy (Filter.map (fun n => f n x) l)\n‚ä¢ UniformCauchySeqOn f l (Metric.ball x r)","decl":"/-- A variant of the second fundamental theorem of calculus (FTC-2): If a sequence of functions\nbetween real or complex normed spaces are differentiable on a ball centered at `x`, they\nform a Cauchy sequence _at_ `x`, and their derivatives are Cauchy uniformly on the ball, then the\nfunctions form a uniform Cauchy sequence on the ball.\n\nNOTE: The fact that we work on a ball is typically all that is necessary to work with power series\nand Dirichlet series (our primary use case). However, this can be generalized by replacing the ball\nwith any connected, bounded, open set and replacing uniform convergence with local uniform\nconvergence. See `cauchy_map_of_uniformCauchySeqOn_fderiv`.\n-/\ntheorem uniformCauchySeqOn_ball_of_fderiv {r : ‚Ñù} (hf' : UniformCauchySeqOn f' l (Metric.ball x r))\n    (hf : ‚àÄ n : Œπ, ‚àÄ y : E, y ‚àà Metric.ball x r ‚Üí HasFDerivAt (f n) (f' n y) y)\n    (hfg : Cauchy (map (fun n => f n x) l)) : UniformCauchySeqOn f l (Metric.ball x r) := by\n  letI : RCLike ùïú := IsRCLikeNormedField.rclike ùïú\n  letI : NormedSpace ‚Ñù E := NormedSpace.restrictScalars ‚Ñù ùïú _\n  have : NeBot l := (cauchy_map_iff.1 hfg).1\n  rcases le_or_lt r 0 with (hr | hr)\n  ¬∑ simp only [Metric.ball_eq_empty.2 hr, UniformCauchySeqOn, Set.mem_empty_iff_false,\n      IsEmpty.forall_iff, eventually_const, imp_true_iff]\n  rw [SeminormedAddGroup.uniformCauchySeqOn_iff_tendstoUniformlyOn_zero] at hf' ‚ä¢\n  suffices\n    TendstoUniformlyOn (fun (n : Œπ √ó Œπ) (z : E) => f n.1 z - f n.2 z - (f n.1 x - f n.2 x)) 0\n        (l √óÀ¢ l) (Metric.ball x r) ‚àß\n      TendstoUniformlyOn (fun (n : Œπ √ó Œπ) (_ : E) => f n.1 x - f n.2 x) 0\n        (l √óÀ¢ l) (Metric.ball x r) by\n    have := this.1.add this.2\n    rw [add_zero] at this\n    refine this.congr ?_\n    filter_upwards with n z _ using (by simp)\n  constructor\n  ¬∑ -- This inequality follows from the mean value theorem\n    rw [Metric.tendstoUniformlyOn_iff] at hf' ‚ä¢\n    intro Œµ hŒµ\n    obtain ‚ü®q, hqpos, hq‚ü© : ‚àÉ q : ‚Ñù, 0 < q ‚àß q * r < Œµ := by\n      simp_rw [mul_comm]\n      exact exists_pos_mul_lt hŒµ.lt r\n    apply (hf' q hqpos.gt).mono\n    intro n hn y hy\n    simp_rw [dist_eq_norm, Pi.zero_apply, zero_sub, norm_neg] at hn ‚ä¢\n    have mvt :=\n      Convex.norm_image_sub_le_of_norm_hasFDerivWithin_le\n        (fun z hz => ((hf n.1 z hz).sub (hf n.2 z hz)).hasFDerivWithinAt) (fun z hz => (hn z hz).le)\n        (convex_ball x r) (Metric.mem_ball_self hr) hy\n    refine lt_of_le_of_lt mvt ?_\n    have : q * ‚Äñy - x‚Äñ < q * r :=\n      mul_lt_mul' rfl.le (by simpa only [dist_eq_norm] using Metric.mem_ball.mp hy) (norm_nonneg _)\n        hqpos\n    exact this.trans hq\n  ¬∑ -- This is just `hfg` run through `eventually_prod_iff`\n    refine Metric.tendstoUniformlyOn_iff.mpr fun Œµ hŒµ => ?_\n    obtain ‚ü®t, ht, ht'‚ü© := (Metric.cauchy_iff.mp hfg).2 Œµ hŒµ\n    rw [eventually_prod_iff]\n    refine ‚ü®fun n => f n x ‚àà t, ht, fun n => f n x ‚àà t, ht, ?_‚ü©\n    intro n hn n' hn' z _\n    rw [dist_eq_norm, Pi.zero_apply, zero_sub, norm_neg, ‚Üê dist_eq_norm]\n    exact ht' _ hn _ hn'\n\n"}
{"name":"cauchy_map_of_uniformCauchySeqOn_fderiv","module":"Mathlib.Analysis.Calculus.UniformLimitsDeriv","initialProofState":"Œπ : Type u_1\nl : Filter Œπ\nE : Type u_2\ninst‚úù‚Åµ : NormedAddCommGroup E\nùïú : Type u_3\ninst‚úù‚Å¥ : NontriviallyNormedField ùïú\ninst‚úù¬≥ : IsRCLikeNormedField ùïú\ninst‚úù¬≤ : NormedSpace ùïú E\nG : Type u_4\ninst‚úù¬π : NormedAddCommGroup G\ninst‚úù : NormedSpace ùïú G\nf : Œπ ‚Üí E ‚Üí G\nf' : Œπ ‚Üí E ‚Üí ContinuousLinearMap (RingHom.id ùïú) E G\ns : Set E\nhs : IsOpen s\nh's : IsPreconnected s\nhf' : UniformCauchySeqOn f' l s\nhf : ‚àÄ (n : Œπ) (y : E), Membership.mem s y ‚Üí HasFDerivAt (f n) (f' n y) y\nx‚ÇÄ x : E\nhx‚ÇÄ : Membership.mem s x‚ÇÄ\nhx : Membership.mem s x\nhfg : Cauchy (Filter.map (fun n => f n x‚ÇÄ) l)\n‚ä¢ Cauchy (Filter.map (fun n => f n x) l)","decl":"/-- If a sequence of functions between real or complex normed spaces are differentiable on a\npreconnected open set, they form a Cauchy sequence _at_ `x`, and their derivatives are Cauchy\nuniformly on the set, then the functions form a Cauchy sequence at any point in the set. -/\ntheorem cauchy_map_of_uniformCauchySeqOn_fderiv {s : Set E} (hs : IsOpen s) (h's : IsPreconnected s)\n    (hf' : UniformCauchySeqOn f' l s) (hf : ‚àÄ n : Œπ, ‚àÄ y : E, y ‚àà s ‚Üí HasFDerivAt (f n) (f' n y) y)\n    {x‚ÇÄ x : E} (hx‚ÇÄ : x‚ÇÄ ‚àà s) (hx : x ‚àà s) (hfg : Cauchy (map (fun n => f n x‚ÇÄ) l)) :\n    Cauchy (map (fun n => f n x) l) := by\n  have : NeBot l := (cauchy_map_iff.1 hfg).1\n  let t := { y | y ‚àà s ‚àß Cauchy (map (fun n => f n y) l) }\n  suffices H : s ‚äÜ t from (H hx).2\n  have A : ‚àÄ x Œµ, x ‚àà t ‚Üí Metric.ball x Œµ ‚äÜ s ‚Üí Metric.ball x Œµ ‚äÜ t := fun x Œµ xt hx y hy =>\n    ‚ü®hx hy,\n      (uniformCauchySeqOn_ball_of_fderiv (hf'.mono hx) (fun n y hy => hf n y (hx hy))\n            xt.2).cauchy_map\n        hy‚ü©\n  have open_t : IsOpen t := by\n    rw [Metric.isOpen_iff]\n    intro x hx\n    rcases Metric.isOpen_iff.1 hs x hx.1 with ‚ü®Œµ, Œµpos, hŒµ‚ü©\n    exact ‚ü®Œµ, Œµpos, A x Œµ hx hŒµ‚ü©\n  have st_nonempty : (s ‚à© t).Nonempty := ‚ü®x‚ÇÄ, hx‚ÇÄ, ‚ü®hx‚ÇÄ, hfg‚ü©‚ü©\n  suffices H : closure t ‚à© s ‚äÜ t from h's.subset_of_closure_inter_subset open_t st_nonempty H\n  rintro x ‚ü®xt, xs‚ü©\n  obtain ‚ü®Œµ, Œµpos, hŒµ‚ü© : ‚àÉ (Œµ : ‚Ñù), Œµ > 0 ‚àß Metric.ball x Œµ ‚äÜ s := Metric.isOpen_iff.1 hs x xs\n  obtain ‚ü®y, yt, hxy‚ü© : ‚àÉ (y : E), y ‚àà t ‚àß dist x y < Œµ / 2 :=\n    Metric.mem_closure_iff.1 xt _ (half_pos Œµpos)\n  have B : Metric.ball y (Œµ / 2) ‚äÜ Metric.ball x Œµ := by\n    apply Metric.ball_subset_ball'; rw [dist_comm]; linarith\n  exact A y (Œµ / 2) yt (B.trans hŒµ) (Metric.mem_ball.2 hxy)\n\n"}
{"name":"difference_quotients_converge_uniformly","module":"Mathlib.Analysis.Calculus.UniformLimitsDeriv","initialProofState":"Œπ : Type u_1\nl : Filter Œπ\nE : Type u_5\ninst‚úù‚Å¥ : NormedAddCommGroup E\nùïú : Type u_6\ninst‚úù¬≥ : RCLike ùïú\ninst‚úù¬≤ : NormedSpace ùïú E\nG : Type u_7\ninst‚úù¬π : NormedAddCommGroup G\ninst‚úù : NormedSpace ùïú G\nf : Œπ ‚Üí E ‚Üí G\ng : E ‚Üí G\nf' : Œπ ‚Üí E ‚Üí ContinuousLinearMap (RingHom.id ùïú) E G\ng' : E ‚Üí ContinuousLinearMap (RingHom.id ùïú) E G\nx : E\nhf' : TendstoUniformlyOnFilter f' g' l (nhds x)\nhf : Filter.Eventually (fun n => HasFDerivAt (f n.1) (f' n.1 n.2) n.2) (SProd.sprod l (nhds x))\nhfg : Filter.Eventually (fun y => Filter.Tendsto (fun n => f n y) l (nhds (g y))) (nhds x)\n‚ä¢ TendstoUniformlyOnFilter (fun n y => HSMul.hSMul (Inv.inv ‚Üë(Norm.norm (HSub.hSub y x))) (HSub.hSub (f n y) (f n x))) (fun y => HSMul.hSMul (Inv.inv ‚Üë(Norm.norm (HSub.hSub y x))) (HSub.hSub (g y) (g x))) l (nhds x)","decl":"/-- If `f_n ‚Üí g` pointwise and the derivatives `(f_n)' ‚Üí h` _uniformly_ converge, then\nin fact for a fixed `y`, the difference quotients `‚Äñz - y‚Äñ‚Åª¬π ‚Ä¢ (f_n z - f_n y)` converge\n_uniformly_ to `‚Äñz - y‚Äñ‚Åª¬π ‚Ä¢ (g z - g y)` -/\ntheorem difference_quotients_converge_uniformly\n    {E : Type*} [NormedAddCommGroup E] {ùïú : Type*} [RCLike ùïú]\n    [NormedSpace ùïú E] {G : Type*} [NormedAddCommGroup G] [NormedSpace ùïú G] {f : Œπ ‚Üí E ‚Üí G}\n    {g : E ‚Üí G} {f' : Œπ ‚Üí E ‚Üí E ‚ÜíL[ùïú] G} {g' : E ‚Üí E ‚ÜíL[ùïú] G} {x : E}\n    (hf' : TendstoUniformlyOnFilter f' g' l (ùìù x))\n    (hf : ‚àÄ·∂† n : Œπ √ó E in l √óÀ¢ ùìù x, HasFDerivAt (f n.1) (f' n.1 n.2) n.2)\n    (hfg : ‚àÄ·∂† y : E in ùìù x, Tendsto (fun n => f n y) l (ùìù (g y))) :\n    TendstoUniformlyOnFilter (fun n : Œπ => fun y : E => (‚Äñy - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (f n y - f n x))\n      (fun y : E => (‚Äñy - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (g y - g x)) l (ùìù x) := by\n  let A : NormedSpace ‚Ñù E := NormedSpace.restrictScalars ‚Ñù ùïú _\n  refine\n    UniformCauchySeqOnFilter.tendstoUniformlyOnFilter_of_tendsto ?_\n      ((hfg.and (eventually_const.mpr hfg.self_of_nhds)).mono fun y hy =>\n        (hy.1.sub hy.2).const_smul _)\n  rw [SeminormedAddGroup.uniformCauchySeqOnFilter_iff_tendstoUniformlyOnFilter_zero]\n  rw [Metric.tendstoUniformlyOnFilter_iff]\n  have hfg' := hf'.uniformCauchySeqOnFilter\n  rw [SeminormedAddGroup.uniformCauchySeqOnFilter_iff_tendstoUniformlyOnFilter_zero] at hfg'\n  rw [Metric.tendstoUniformlyOnFilter_iff] at hfg'\n  intro Œµ hŒµ\n  obtain ‚ü®q, hqpos, hqŒµ‚ü© := exists_pos_rat_lt hŒµ\n  specialize hfg' (q : ‚Ñù) (by simp [hqpos])\n  have := (tendsto_swap4_prod.eventually (hf.prod_mk hf)).diag_of_prod_right\n  obtain ‚ü®a, b, c, d, e‚ü© := eventually_prod_iff.1 (hfg'.and this)\n  obtain ‚ü®r, hr, hr'‚ü© := Metric.nhds_basis_ball.eventually_iff.mp d\n  rw [eventually_prod_iff]\n  refine\n    ‚ü®_, b, fun e : E => Metric.ball x r e,\n      eventually_mem_set.mpr (Metric.nhds_basis_ball.mem_of_mem hr), fun {n} hn {y} hy => ?_‚ü©\n  simp only [Pi.zero_apply, dist_zero_left]\n  rw [‚Üê smul_sub, norm_smul, norm_inv, RCLike.norm_coe_norm]\n  refine lt_of_le_of_lt ?_ hqŒµ\n  by_cases hyz' : x = y; ¬∑ simp [hyz', hqpos.le]\n  have hyz : 0 < ‚Äñy - x‚Äñ := by rw [norm_pos_iff]; intro hy'; exact hyz' (eq_of_sub_eq_zero hy').symm\n  rw [inv_mul_le_iff‚ÇÄ hyz, mul_comm, sub_sub_sub_comm]\n  simp only [Pi.zero_apply, dist_zero_left] at e\n  refine\n    Convex.norm_image_sub_le_of_norm_hasFDerivWithin_le\n      (fun y hy => ((e hn (hr' hy)).2.1.sub (e hn (hr' hy)).2.2).hasFDerivWithinAt)\n      (fun y hy => (e hn (hr' hy)).1.le) (convex_ball x r) (Metric.mem_ball_self hr) hy\n\n"}
{"name":"hasFDerivAt_of_tendstoUniformlyOnFilter","module":"Mathlib.Analysis.Calculus.UniformLimitsDeriv","initialProofState":"Œπ : Type u_1\nl : Filter Œπ\nE : Type u_2\ninst‚úù‚Å∂ : NormedAddCommGroup E\nùïú : Type u_3\ninst‚úù‚Åµ : NontriviallyNormedField ùïú\ninst‚úù‚Å¥ : IsRCLikeNormedField ùïú\ninst‚úù¬≥ : NormedSpace ùïú E\nG : Type u_4\ninst‚úù¬≤ : NormedAddCommGroup G\ninst‚úù¬π : NormedSpace ùïú G\nf : Œπ ‚Üí E ‚Üí G\ng : E ‚Üí G\nf' : Œπ ‚Üí E ‚Üí ContinuousLinearMap (RingHom.id ùïú) E G\ng' : E ‚Üí ContinuousLinearMap (RingHom.id ùïú) E G\nx : E\ninst‚úù : l.NeBot\nhf' : TendstoUniformlyOnFilter f' g' l (nhds x)\nhf : Filter.Eventually (fun n => HasFDerivAt (f n.1) (f' n.1 n.2) n.2) (SProd.sprod l (nhds x))\nhfg : Filter.Eventually (fun y => Filter.Tendsto (fun n => f n y) l (nhds (g y))) (nhds x)\n‚ä¢ HasFDerivAt g (g' x) x","decl":"/-- `(d/dx) lim_{n ‚Üí ‚àû} f n x = lim_{n ‚Üí ‚àû} f' n x` when the `f' n` converge\n_uniformly_ to their limit at `x`.\n\nIn words the assumptions mean the following:\n  * `hf'`: The `f'` converge \"uniformly at\" `x` to `g'`. This does not mean that the `f' n` even\n    converge away from `x`!\n  * `hf`: For all `(y, n)` with `y` sufficiently close to `x` and `n` sufficiently large, `f' n` is\n    the derivative of `f n`\n  * `hfg`: The `f n` converge pointwise to `g` on a neighborhood of `x` -/\ntheorem hasFDerivAt_of_tendstoUniformlyOnFilter [NeBot l]\n    (hf' : TendstoUniformlyOnFilter f' g' l (ùìù x))\n    (hf : ‚àÄ·∂† n : Œπ √ó E in l √óÀ¢ ùìù x, HasFDerivAt (f n.1) (f' n.1 n.2) n.2)\n    (hfg : ‚àÄ·∂† y in ùìù x, Tendsto (fun n => f n y) l (ùìù (g y))) : HasFDerivAt g (g' x) x := by\n  letI : RCLike ùïú := IsRCLikeNormedField.rclike ùïú\n  -- The proof strategy follows several steps:\n  --   1. The quantifiers in the definition of the derivative are\n  --      `‚àÄ Œµ > 0, ‚àÉŒ¥ > 0, ‚àÄy ‚àà B_Œ¥(x)`. We will introduce a quantifier in the middle:\n  --      `‚àÄ Œµ > 0, ‚àÉN, ‚àÄn ‚â• N, ‚àÉŒ¥ > 0, ‚àÄy ‚àà B_Œ¥(x)` which will allow us to introduce the `f(') n`\n  --   2. The order of the quantifiers `hfg` are opposite to what we need. We will be able to swap\n  --      the quantifiers using the uniform convergence assumption\n  rw [hasFDerivAt_iff_tendsto]\n  -- Introduce extra quantifier via curried filters\n  suffices\n    Tendsto (fun y : Œπ √ó E => ‚Äñy.2 - x‚Äñ‚Åª¬π * ‚Äñg y.2 - g x - (g' x) (y.2 - x)‚Äñ)\n      (l.curry (ùìù x)) (ùìù 0) by\n    rw [Metric.tendsto_nhds] at this ‚ä¢\n    intro Œµ hŒµ\n    specialize this Œµ hŒµ\n    rw [eventually_curry_iff] at this\n    simp only at this\n    exact (eventually_const.mp this).mono (by simp only [imp_self, forall_const])\n  -- With the new quantifier in hand, we can perform the famous `Œµ/3` proof. Specifically,\n  -- we will break up the limit (the difference functions minus the derivative go to 0) into 3:\n  --   * The difference functions of the `f n` converge *uniformly* to the difference functions\n  --     of the `g n`\n  --   * The `f' n` are the derivatives of the `f n`\n  --   * The `f' n` converge to `g'` at `x`\n  conv =>\n    congr\n    ext\n    rw [‚Üê abs_norm, ‚Üê abs_inv, ‚Üê @RCLike.norm_ofReal ùïú _ _, RCLike.ofReal_inv, ‚Üê norm_smul]\n  rw [‚Üê tendsto_zero_iff_norm_tendsto_zero]\n  have :\n    (fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (g a.2 - g x - (g' x) (a.2 - x))) =\n      ((fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (g a.2 - g x - (f a.1 a.2 - f a.1 x))) +\n          fun a : Œπ √ó E =>\n          (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (f a.1 a.2 - f a.1 x - ((f' a.1 x) a.2 - (f' a.1 x) x))) +\n        fun a : Œπ √ó E => (‚Äña.2 - x‚Äñ‚Åª¬π : ùïú) ‚Ä¢ (f' a.1 x - g' x) (a.2 - x) := by\n    ext; simp only [Pi.add_apply]; rw [‚Üê smul_add, ‚Üê smul_add]; congr\n    simp only [map_sub, sub_add_sub_cancel, ContinuousLinearMap.coe_sub', Pi.sub_apply]\n    -- Porting note: added\n    abel\n  simp_rw [this]\n  have : ùìù (0 : G) = ùìù (0 + 0 + 0) := by simp only [add_zero]\n  rw [this]\n  refine Tendsto.add (Tendsto.add ?_ ?_) ?_\n  ¬∑ have := difference_quotients_converge_uniformly hf' hf hfg\n    rw [Metric.tendstoUniformlyOnFilter_iff] at this\n    rw [Metric.tendsto_nhds]\n    intro Œµ hŒµ\n    apply ((this Œµ hŒµ).filter_mono curry_le_prod).mono\n    intro n hn\n    rw [dist_eq_norm] at hn ‚ä¢\n    convert hn using 2\n    module\n  ¬∑ -- (Almost) the definition of the derivatives\n    rw [Metric.tendsto_nhds]\n    intro Œµ hŒµ\n    rw [eventually_curry_iff]\n    refine hf.curry.mono fun n hn => ?_\n    have := hn.self_of_nhds\n    rw [hasFDerivAt_iff_tendsto, Metric.tendsto_nhds] at this\n    refine (this Œµ hŒµ).mono fun y hy => ?_\n    rw [dist_eq_norm] at hy ‚ä¢\n    simp only [sub_zero, map_sub, norm_mul, norm_inv, norm_norm] at hy ‚ä¢\n    rw [norm_smul, norm_inv, RCLike.norm_coe_norm]\n    exact hy\n  ¬∑ -- hfg' after specializing to `x` and applying the definition of the operator norm\n    refine Tendsto.mono_left ?_ curry_le_prod\n    have h1 : Tendsto (fun n : Œπ √ó E => g' n.2 - f' n.1 n.2) (l √óÀ¢ ùìù x) (ùìù 0) := by\n      rw [Metric.tendstoUniformlyOnFilter_iff] at hf'\n      exact Metric.tendsto_nhds.mpr fun Œµ hŒµ => by simpa using hf' Œµ hŒµ\n    have h2 : Tendsto (fun n : Œπ => g' x - f' n x) l (ùìù 0) := by\n      rw [Metric.tendsto_nhds] at h1 ‚ä¢\n      exact fun Œµ hŒµ => (h1 Œµ hŒµ).curry.mono fun n hn => hn.self_of_nhds\n    refine squeeze_zero_norm ?_\n      (tendsto_zero_iff_norm_tendsto_zero.mp (tendsto_fst.comp (h2.prod_map tendsto_id)))\n    intro n\n    simp_rw [norm_smul, norm_inv, RCLike.norm_coe_norm]\n    by_cases hx : x = n.2; ¬∑ simp [hx]\n    have hnx : 0 < ‚Äñn.2 - x‚Äñ := by\n      rw [norm_pos_iff]; intro hx'; exact hx (eq_of_sub_eq_zero hx').symm\n    rw [inv_mul_le_iff‚ÇÄ hnx, mul_comm]\n    simp only [Function.comp_apply, Prod.map_apply']\n    rw [norm_sub_rev]\n    exact (f' n.1 x - g' x).le_opNorm (n.2 - x)\n\n"}
{"name":"hasFDerivAt_of_tendstoLocallyUniformlyOn","module":"Mathlib.Analysis.Calculus.UniformLimitsDeriv","initialProofState":"Œπ : Type u_1\nl : Filter Œπ\nE : Type u_2\ninst‚úù‚Å∂ : NormedAddCommGroup E\nùïú : Type u_3\ninst‚úù‚Åµ : NontriviallyNormedField ùïú\ninst‚úù‚Å¥ : IsRCLikeNormedField ùïú\ninst‚úù¬≥ : NormedSpace ùïú E\nG : Type u_4\ninst‚úù¬≤ : NormedAddCommGroup G\ninst‚úù¬π : NormedSpace ùïú G\nf : Œπ ‚Üí E ‚Üí G\ng : E ‚Üí G\nf' : Œπ ‚Üí E ‚Üí ContinuousLinearMap (RingHom.id ùïú) E G\ng' : E ‚Üí ContinuousLinearMap (RingHom.id ùïú) E G\nx : E\ninst‚úù : l.NeBot\ns : Set E\nhs : IsOpen s\nhf' : TendstoLocallyUniformlyOn f' g' l s\nhf : ‚àÄ (n : Œπ) (x : E), Membership.mem s x ‚Üí HasFDerivAt (f n) (f' n x) x\nhfg : ‚àÄ (x : E), Membership.mem s x ‚Üí Filter.Tendsto (fun n => f n x) l (nhds (g x))\nhx : Membership.mem s x\n‚ä¢ HasFDerivAt g (g' x) x","decl":"theorem hasFDerivAt_of_tendstoLocallyUniformlyOn [NeBot l] {s : Set E} (hs : IsOpen s)\n    (hf' : TendstoLocallyUniformlyOn f' g' l s) (hf : ‚àÄ n, ‚àÄ x ‚àà s, HasFDerivAt (f n) (f' n x) x)\n    (hfg : ‚àÄ x ‚àà s, Tendsto (fun n => f n x) l (ùìù (g x))) (hx : x ‚àà s) :\n    HasFDerivAt g (g' x) x := by\n  have h1 : s ‚àà ùìù x := hs.mem_nhds hx\n  have h3 : Set.univ √óÀ¢ s ‚àà l √óÀ¢ ùìù x := by simp only [h1, prod_mem_prod_iff, univ_mem, and_self_iff]\n  have h4 : ‚àÄ·∂† n : Œπ √ó E in l √óÀ¢ ùìù x, HasFDerivAt (f n.1) (f' n.1 n.2) n.2 :=\n    eventually_of_mem h3 fun ‚ü®n, z‚ü© ‚ü®_, hz‚ü© => hf n z hz\n  refine hasFDerivAt_of_tendstoUniformlyOnFilter ?_ h4 (eventually_of_mem h1 hfg)\n  simpa [IsOpen.nhdsWithin_eq hs hx] using tendstoLocallyUniformlyOn_iff_filter.mp hf' x hx\n\n"}
{"name":"hasFDerivAt_of_tendsto_locally_uniformly_on'","module":"Mathlib.Analysis.Calculus.UniformLimitsDeriv","initialProofState":"Œπ : Type u_1\nl : Filter Œπ\nE : Type u_2\ninst‚úù‚Å∂ : NormedAddCommGroup E\nùïú : Type u_3\ninst‚úù‚Åµ : NontriviallyNormedField ùïú\ninst‚úù‚Å¥ : IsRCLikeNormedField ùïú\ninst‚úù¬≥ : NormedSpace ùïú E\nG : Type u_4\ninst‚úù¬≤ : NormedAddCommGroup G\ninst‚úù¬π : NormedSpace ùïú G\nf : Œπ ‚Üí E ‚Üí G\ng : E ‚Üí G\ng' : E ‚Üí ContinuousLinearMap (RingHom.id ùïú) E G\nx : E\ninst‚úù : l.NeBot\ns : Set E\nhs : IsOpen s\nhf' : TendstoLocallyUniformlyOn (Function.comp (fderiv ùïú) f) g' l s\nhf : ‚àÄ (n : Œπ), DifferentiableOn ùïú (f n) s\nhfg : ‚àÄ (x : E), Membership.mem s x ‚Üí Filter.Tendsto (fun n => f n x) l (nhds (g x))\nhx : Membership.mem s x\n‚ä¢ HasFDerivAt g (g' x) x","decl":"/-- A slight variant of `hasFDerivAt_of_tendstoLocallyUniformlyOn` with the assumption stated\nin terms of `DifferentiableOn` rather than `HasFDerivAt`. This makes a few proofs nicer in\ncomplex analysis where holomorphicity is assumed but the derivative is not known a priori. -/\ntheorem hasFDerivAt_of_tendsto_locally_uniformly_on' [NeBot l] {s : Set E} (hs : IsOpen s)\n    (hf' : TendstoLocallyUniformlyOn (fderiv ùïú ‚àò f) g' l s) (hf : ‚àÄ n, DifferentiableOn ùïú (f n) s)\n    (hfg : ‚àÄ x ‚àà s, Tendsto (fun n => f n x) l (ùìù (g x))) (hx : x ‚àà s) :\n    HasFDerivAt g (g' x) x := by\n  refine hasFDerivAt_of_tendstoLocallyUniformlyOn hs hf' (fun n z hz => ?_) hfg hx\n  exact ((hf n z hz).differentiableAt (hs.mem_nhds hz)).hasFDerivAt\n\n"}
{"name":"hasFDerivAt_of_tendstoUniformlyOn","module":"Mathlib.Analysis.Calculus.UniformLimitsDeriv","initialProofState":"Œπ : Type u_1\nl : Filter Œπ\nE : Type u_2\ninst‚úù‚Å∂ : NormedAddCommGroup E\nùïú : Type u_3\ninst‚úù‚Åµ : NontriviallyNormedField ùïú\ninst‚úù‚Å¥ : IsRCLikeNormedField ùïú\ninst‚úù¬≥ : NormedSpace ùïú E\nG : Type u_4\ninst‚úù¬≤ : NormedAddCommGroup G\ninst‚úù¬π : NormedSpace ùïú G\nf : Œπ ‚Üí E ‚Üí G\ng : E ‚Üí G\nf' : Œπ ‚Üí E ‚Üí ContinuousLinearMap (RingHom.id ùïú) E G\ng' : E ‚Üí ContinuousLinearMap (RingHom.id ùïú) E G\nx : E\ninst‚úù : l.NeBot\ns : Set E\nhs : IsOpen s\nhf' : TendstoUniformlyOn f' g' l s\nhf : ‚àÄ (n : Œπ) (x : E), Membership.mem s x ‚Üí HasFDerivAt (f n) (f' n x) x\nhfg : ‚àÄ (x : E), Membership.mem s x ‚Üí Filter.Tendsto (fun n => f n x) l (nhds (g x))\nhx : Membership.mem s x\n‚ä¢ HasFDerivAt g (g' x) x","decl":"/-- `(d/dx) lim_{n ‚Üí ‚àû} f n x = lim_{n ‚Üí ‚àû} f' n x` when the `f' n` converge\n_uniformly_ to their limit on an open set containing `x`. -/\ntheorem hasFDerivAt_of_tendstoUniformlyOn [NeBot l] {s : Set E} (hs : IsOpen s)\n    (hf' : TendstoUniformlyOn f' g' l s)\n    (hf : ‚àÄ n : Œπ, ‚àÄ x : E, x ‚àà s ‚Üí HasFDerivAt (f n) (f' n x) x)\n    (hfg : ‚àÄ x : E, x ‚àà s ‚Üí Tendsto (fun n => f n x) l (ùìù (g x))) (hx : x ‚àà s) :\n    HasFDerivAt g (g' x) x :=\n  hasFDerivAt_of_tendstoLocallyUniformlyOn hs hf'.tendstoLocallyUniformlyOn hf hfg hx\n\n"}
{"name":"hasFDerivAt_of_tendstoUniformly","module":"Mathlib.Analysis.Calculus.UniformLimitsDeriv","initialProofState":"Œπ : Type u_1\nl : Filter Œπ\nE : Type u_2\ninst‚úù‚Å∂ : NormedAddCommGroup E\nùïú : Type u_3\ninst‚úù‚Åµ : NontriviallyNormedField ùïú\ninst‚úù‚Å¥ : IsRCLikeNormedField ùïú\ninst‚úù¬≥ : NormedSpace ùïú E\nG : Type u_4\ninst‚úù¬≤ : NormedAddCommGroup G\ninst‚úù¬π : NormedSpace ùïú G\nf : Œπ ‚Üí E ‚Üí G\ng : E ‚Üí G\nf' : Œπ ‚Üí E ‚Üí ContinuousLinearMap (RingHom.id ùïú) E G\ng' : E ‚Üí ContinuousLinearMap (RingHom.id ùïú) E G\ninst‚úù : l.NeBot\nhf' : TendstoUniformly f' g' l\nhf : ‚àÄ (n : Œπ) (x : E), HasFDerivAt (f n) (f' n x) x\nhfg : ‚àÄ (x : E), Filter.Tendsto (fun n => f n x) l (nhds (g x))\nx : E\n‚ä¢ HasFDerivAt g (g' x) x","decl":"/-- `(d/dx) lim_{n ‚Üí ‚àû} f n x = lim_{n ‚Üí ‚àû} f' n x` when the `f' n` converge\n_uniformly_ to their limit. -/\ntheorem hasFDerivAt_of_tendstoUniformly [NeBot l] (hf' : TendstoUniformly f' g' l)\n    (hf : ‚àÄ n : Œπ, ‚àÄ x : E, HasFDerivAt (f n) (f' n x) x)\n    (hfg : ‚àÄ x : E, Tendsto (fun n => f n x) l (ùìù (g x))) (x : E) : HasFDerivAt g (g' x) x := by\n  have hf : ‚àÄ n : Œπ, ‚àÄ x : E, x ‚àà Set.univ ‚Üí HasFDerivAt (f n) (f' n x) x := by simp [hf]\n  have hfg : ‚àÄ x : E, x ‚àà Set.univ ‚Üí Tendsto (fun n => f n x) l (ùìù (g x)) := by simp [hfg]\n  have hf' : TendstoUniformlyOn f' g' l Set.univ := by rwa [tendstoUniformlyOn_univ]\n  exact hasFDerivAt_of_tendstoUniformlyOn isOpen_univ hf' hf hfg (Set.mem_univ x)\n\n"}
{"name":"UniformCauchySeqOnFilter.one_smulRight","module":"Mathlib.Analysis.Calculus.UniformLimitsDeriv","initialProofState":"Œπ : Type u_1\nl : Filter Œπ\nùïú : Type u_2\ninst‚úù¬≤ : NontriviallyNormedField ùïú\nG : Type u_3\ninst‚úù¬π : NormedAddCommGroup G\ninst‚úù : NormedSpace ùïú G\nf' : Œπ ‚Üí ùïú ‚Üí G\nl' : Filter ùïú\nhf' : UniformCauchySeqOnFilter f' l l'\n‚ä¢ UniformCauchySeqOnFilter (fun n z => ContinuousLinearMap.smulRight 1 (f' n z)) l l'","decl":"/-- If our derivatives converge uniformly, then the Fr√©chet derivatives converge uniformly -/\ntheorem UniformCauchySeqOnFilter.one_smulRight {l' : Filter ùïú}\n    (hf' : UniformCauchySeqOnFilter f' l l') :\n    UniformCauchySeqOnFilter (fun n => fun z => (1 : ùïú ‚ÜíL[ùïú] ùïú).smulRight (f' n z)) l l' := by\n  -- The tricky part of this proof is that operator norms are written in terms of `‚â§` whereas\n  -- metrics are written in terms of `<`. So we need to shrink `Œµ` utilizing the archimedean\n  -- property of `‚Ñù`\n  rw [SeminormedAddGroup.uniformCauchySeqOnFilter_iff_tendstoUniformlyOnFilter_zero,\n    Metric.tendstoUniformlyOnFilter_iff] at hf' ‚ä¢\n  intro Œµ hŒµ\n  obtain ‚ü®q, hq, hq'‚ü© := exists_between hŒµ.lt\n  apply (hf' q hq).mono\n  intro n hn\n  refine lt_of_le_of_lt ?_ hq'\n  simp only [dist_eq_norm, Pi.zero_apply, zero_sub, norm_neg] at hn ‚ä¢\n  refine ContinuousLinearMap.opNorm_le_bound _ hq.le ?_\n  intro z\n  simp only [ContinuousLinearMap.coe_sub', Pi.sub_apply, ContinuousLinearMap.smulRight_apply,\n    ContinuousLinearMap.one_apply]\n  rw [‚Üê smul_sub, norm_smul, mul_comm]\n  gcongr\n\n"}
{"name":"uniformCauchySeqOnFilter_of_deriv","module":"Mathlib.Analysis.Calculus.UniformLimitsDeriv","initialProofState":"Œπ : Type u_1\nl : Filter Œπ\nùïú : Type u_2\ninst‚úù¬≥ : NontriviallyNormedField ùïú\nG : Type u_3\ninst‚úù¬≤ : NormedAddCommGroup G\ninst‚úù¬π : NormedSpace ùïú G\nf f' : Œπ ‚Üí ùïú ‚Üí G\nx : ùïú\ninst‚úù : IsRCLikeNormedField ùïú\nhf' : UniformCauchySeqOnFilter f' l (nhds x)\nhf : Filter.Eventually (fun n => HasDerivAt (f n.1) (f' n.1 n.2) n.2) (SProd.sprod l (nhds x))\nhfg : Cauchy (Filter.map (fun n => f n x) l)\n‚ä¢ UniformCauchySeqOnFilter f l (nhds x)","decl":"theorem uniformCauchySeqOnFilter_of_deriv (hf' : UniformCauchySeqOnFilter f' l (ùìù x))\n    (hf : ‚àÄ·∂† n : Œπ √ó ùïú in l √óÀ¢ ùìù x, HasDerivAt (f n.1) (f' n.1 n.2) n.2)\n    (hfg : Cauchy (map (fun n => f n x) l)) : UniformCauchySeqOnFilter f l (ùìù x) := by\n  simp_rw [hasDerivAt_iff_hasFDerivAt] at hf\n  exact uniformCauchySeqOnFilter_of_fderiv hf'.one_smulRight hf hfg\n\n"}
{"name":"uniformCauchySeqOn_ball_of_deriv","module":"Mathlib.Analysis.Calculus.UniformLimitsDeriv","initialProofState":"Œπ : Type u_1\nl : Filter Œπ\nùïú : Type u_2\ninst‚úù¬≥ : NontriviallyNormedField ùïú\nG : Type u_3\ninst‚úù¬≤ : NormedAddCommGroup G\ninst‚úù¬π : NormedSpace ùïú G\nf f' : Œπ ‚Üí ùïú ‚Üí G\nx : ùïú\ninst‚úù : IsRCLikeNormedField ùïú\nr : Real\nhf' : UniformCauchySeqOn f' l (Metric.ball x r)\nhf : ‚àÄ (n : Œπ) (y : ùïú), Membership.mem (Metric.ball x r) y ‚Üí HasDerivAt (f n) (f' n y) y\nhfg : Cauchy (Filter.map (fun n => f n x) l)\n‚ä¢ UniformCauchySeqOn f l (Metric.ball x r)","decl":"theorem uniformCauchySeqOn_ball_of_deriv {r : ‚Ñù} (hf' : UniformCauchySeqOn f' l (Metric.ball x r))\n    (hf : ‚àÄ n : Œπ, ‚àÄ y : ùïú, y ‚àà Metric.ball x r ‚Üí HasDerivAt (f n) (f' n y) y)\n    (hfg : Cauchy (map (fun n => f n x) l)) : UniformCauchySeqOn f l (Metric.ball x r) := by\n  simp_rw [hasDerivAt_iff_hasFDerivAt] at hf\n  rw [uniformCauchySeqOn_iff_uniformCauchySeqOnFilter] at hf'\n  have hf' :\n    UniformCauchySeqOn (fun n => fun z => (1 : ùïú ‚ÜíL[ùïú] ùïú).smulRight (f' n z)) l\n      (Metric.ball x r) := by\n    rw [uniformCauchySeqOn_iff_uniformCauchySeqOnFilter]\n    exact hf'.one_smulRight\n  exact uniformCauchySeqOn_ball_of_fderiv hf' hf hfg\n\n"}
{"name":"hasDerivAt_of_tendstoUniformlyOnFilter","module":"Mathlib.Analysis.Calculus.UniformLimitsDeriv","initialProofState":"Œπ : Type u_1\nl : Filter Œπ\nùïú : Type u_2\ninst‚úù‚Å¥ : NontriviallyNormedField ùïú\nG : Type u_3\ninst‚úù¬≥ : NormedAddCommGroup G\ninst‚úù¬≤ : NormedSpace ùïú G\nf : Œπ ‚Üí ùïú ‚Üí G\ng : ùïú ‚Üí G\nf' : Œπ ‚Üí ùïú ‚Üí G\ng' : ùïú ‚Üí G\nx : ùïú\ninst‚úù¬π : IsRCLikeNormedField ùïú\ninst‚úù : l.NeBot\nhf' : TendstoUniformlyOnFilter f' g' l (nhds x)\nhf : Filter.Eventually (fun n => HasDerivAt (f n.1) (f' n.1 n.2) n.2) (SProd.sprod l (nhds x))\nhfg : Filter.Eventually (fun y => Filter.Tendsto (fun n => f n y) l (nhds (g y))) (nhds x)\n‚ä¢ HasDerivAt g (g' x) x","decl":"theorem hasDerivAt_of_tendstoUniformlyOnFilter [NeBot l]\n    (hf' : TendstoUniformlyOnFilter f' g' l (ùìù x))\n    (hf : ‚àÄ·∂† n : Œπ √ó ùïú in l √óÀ¢ ùìù x, HasDerivAt (f n.1) (f' n.1 n.2) n.2)\n    (hfg : ‚àÄ·∂† y in ùìù x, Tendsto (fun n => f n y) l (ùìù (g y))) : HasDerivAt g (g' x) x := by\n  -- The first part of the proof rewrites `hf` and the goal to be functions so that Lean\n  -- can recognize them when we apply `hasFDerivAt_of_tendstoUniformlyOnFilter`\n  let F' n z := (1 : ùïú ‚ÜíL[ùïú] ùïú).smulRight (f' n z)\n  let G' z := (1 : ùïú ‚ÜíL[ùïú] ùïú).smulRight (g' z)\n  simp_rw [hasDerivAt_iff_hasFDerivAt] at hf ‚ä¢\n  -- Now we need to rewrite hf' in terms of `ContinuousLinearMap`s. The tricky part is that\n  -- operator norms are written in terms of `‚â§` whereas metrics are written in terms of `<`. So we\n  -- need to shrink `Œµ` utilizing the archimedean property of `‚Ñù`\n  have hf' : TendstoUniformlyOnFilter F' G' l (ùìù x) := by\n    rw [Metric.tendstoUniformlyOnFilter_iff] at hf' ‚ä¢\n    intro Œµ hŒµ\n    obtain ‚ü®q, hq, hq'‚ü© := exists_between hŒµ.lt\n    apply (hf' q hq).mono\n    intro n hn\n    refine lt_of_le_of_lt ?_ hq'\n    simp only [dist_eq_norm] at hn ‚ä¢\n    refine ContinuousLinearMap.opNorm_le_bound _ hq.le ?_\n    intro z\n    simp only [F', G', ContinuousLinearMap.coe_sub', Pi.sub_apply,\n      ContinuousLinearMap.smulRight_apply, ContinuousLinearMap.one_apply]\n    rw [‚Üê smul_sub, norm_smul, mul_comm]\n    gcongr\n  exact hasFDerivAt_of_tendstoUniformlyOnFilter hf' hf hfg\n\n"}
{"name":"hasDerivAt_of_tendstoLocallyUniformlyOn","module":"Mathlib.Analysis.Calculus.UniformLimitsDeriv","initialProofState":"Œπ : Type u_1\nl : Filter Œπ\nùïú : Type u_2\ninst‚úù‚Å¥ : NontriviallyNormedField ùïú\nG : Type u_3\ninst‚úù¬≥ : NormedAddCommGroup G\ninst‚úù¬≤ : NormedSpace ùïú G\nf : Œπ ‚Üí ùïú ‚Üí G\ng : ùïú ‚Üí G\nf' : Œπ ‚Üí ùïú ‚Üí G\ng' : ùïú ‚Üí G\nx : ùïú\ninst‚úù¬π : IsRCLikeNormedField ùïú\ninst‚úù : l.NeBot\ns : Set ùïú\nhs : IsOpen s\nhf' : TendstoLocallyUniformlyOn f' g' l s\nhf : Filter.Eventually (fun n => ‚àÄ (x : ùïú), Membership.mem s x ‚Üí HasDerivAt (f n) (f' n x) x) l\nhfg : ‚àÄ (x : ùïú), Membership.mem s x ‚Üí Filter.Tendsto (fun n => f n x) l (nhds (g x))\nhx : Membership.mem s x\n‚ä¢ HasDerivAt g (g' x) x","decl":"theorem hasDerivAt_of_tendstoLocallyUniformlyOn [NeBot l] {s : Set ùïú} (hs : IsOpen s)\n    (hf' : TendstoLocallyUniformlyOn f' g' l s)\n    (hf : ‚àÄ·∂† n in l, ‚àÄ x ‚àà s, HasDerivAt (f n) (f' n x) x)\n    (hfg : ‚àÄ x ‚àà s, Tendsto (fun n => f n x) l (ùìù (g x))) (hx : x ‚àà s) : HasDerivAt g (g' x) x := by\n  have h1 : s ‚àà ùìù x := hs.mem_nhds hx\n  have h2 : ‚àÄ·∂† n : Œπ √ó ùïú in l √óÀ¢ ùìù x, HasDerivAt (f n.1) (f' n.1 n.2) n.2 :=\n    eventually_prod_iff.2 ‚ü®_, hf, fun x => x ‚àà s, h1, fun {n} => id‚ü©\n  refine hasDerivAt_of_tendstoUniformlyOnFilter ?_ h2 (eventually_of_mem h1 hfg)\n  simpa [IsOpen.nhdsWithin_eq hs hx] using tendstoLocallyUniformlyOn_iff_filter.mp hf' x hx\n\n"}
{"name":"hasDerivAt_of_tendsto_locally_uniformly_on'","module":"Mathlib.Analysis.Calculus.UniformLimitsDeriv","initialProofState":"Œπ : Type u_1\nl : Filter Œπ\nùïú : Type u_2\ninst‚úù‚Å¥ : NontriviallyNormedField ùïú\nG : Type u_3\ninst‚úù¬≥ : NormedAddCommGroup G\ninst‚úù¬≤ : NormedSpace ùïú G\nf : Œπ ‚Üí ùïú ‚Üí G\ng g' : ùïú ‚Üí G\nx : ùïú\ninst‚úù¬π : IsRCLikeNormedField ùïú\ninst‚úù : l.NeBot\ns : Set ùïú\nhs : IsOpen s\nhf' : TendstoLocallyUniformlyOn (Function.comp deriv f) g' l s\nhf : Filter.Eventually (fun n => DifferentiableOn ùïú (f n) s) l\nhfg : ‚àÄ (x : ùïú), Membership.mem s x ‚Üí Filter.Tendsto (fun n => f n x) l (nhds (g x))\nhx : Membership.mem s x\n‚ä¢ HasDerivAt g (g' x) x","decl":"/-- A slight variant of `hasDerivAt_of_tendstoLocallyUniformlyOn` with the assumption stated in\nterms of `DifferentiableOn` rather than `HasDerivAt`. This makes a few proofs nicer in complex\nanalysis where holomorphicity is assumed but the derivative is not known a priori. -/\ntheorem hasDerivAt_of_tendsto_locally_uniformly_on' [NeBot l] {s : Set ùïú} (hs : IsOpen s)\n    (hf' : TendstoLocallyUniformlyOn (deriv ‚àò f) g' l s)\n    (hf : ‚àÄ·∂† n in l, DifferentiableOn ùïú (f n) s)\n    (hfg : ‚àÄ x ‚àà s, Tendsto (fun n => f n x) l (ùìù (g x))) (hx : x ‚àà s) : HasDerivAt g (g' x) x := by\n  refine hasDerivAt_of_tendstoLocallyUniformlyOn hs hf' ?_ hfg hx\n  filter_upwards [hf] with n h z hz using ((h z hz).differentiableAt (hs.mem_nhds hz)).hasDerivAt\n\n"}
{"name":"hasDerivAt_of_tendstoUniformlyOn","module":"Mathlib.Analysis.Calculus.UniformLimitsDeriv","initialProofState":"Œπ : Type u_1\nl : Filter Œπ\nùïú : Type u_2\ninst‚úù‚Å¥ : NontriviallyNormedField ùïú\nG : Type u_3\ninst‚úù¬≥ : NormedAddCommGroup G\ninst‚úù¬≤ : NormedSpace ùïú G\nf : Œπ ‚Üí ùïú ‚Üí G\ng : ùïú ‚Üí G\nf' : Œπ ‚Üí ùïú ‚Üí G\ng' : ùïú ‚Üí G\nx : ùïú\ninst‚úù¬π : IsRCLikeNormedField ùïú\ninst‚úù : l.NeBot\ns : Set ùïú\nhs : IsOpen s\nhf' : TendstoUniformlyOn f' g' l s\nhf : Filter.Eventually (fun n => ‚àÄ (x : ùïú), Membership.mem s x ‚Üí HasDerivAt (f n) (f' n x) x) l\nhfg : ‚àÄ (x : ùïú), Membership.mem s x ‚Üí Filter.Tendsto (fun n => f n x) l (nhds (g x))\nhx : Membership.mem s x\n‚ä¢ HasDerivAt g (g' x) x","decl":"theorem hasDerivAt_of_tendstoUniformlyOn [NeBot l] {s : Set ùïú} (hs : IsOpen s)\n    (hf' : TendstoUniformlyOn f' g' l s)\n    (hf : ‚àÄ·∂† n in l, ‚àÄ x : ùïú, x ‚àà s ‚Üí HasDerivAt (f n) (f' n x) x)\n    (hfg : ‚àÄ x : ùïú, x ‚àà s ‚Üí Tendsto (fun n => f n x) l (ùìù (g x))) (hx : x ‚àà s) :\n    HasDerivAt g (g' x) x :=\n  hasDerivAt_of_tendstoLocallyUniformlyOn hs hf'.tendstoLocallyUniformlyOn hf hfg hx\n\n"}
{"name":"hasDerivAt_of_tendstoUniformly","module":"Mathlib.Analysis.Calculus.UniformLimitsDeriv","initialProofState":"Œπ : Type u_1\nl : Filter Œπ\nùïú : Type u_2\ninst‚úù‚Å¥ : NontriviallyNormedField ùïú\nG : Type u_3\ninst‚úù¬≥ : NormedAddCommGroup G\ninst‚úù¬≤ : NormedSpace ùïú G\nf : Œπ ‚Üí ùïú ‚Üí G\ng : ùïú ‚Üí G\nf' : Œπ ‚Üí ùïú ‚Üí G\ng' : ùïú ‚Üí G\ninst‚úù¬π : IsRCLikeNormedField ùïú\ninst‚úù : l.NeBot\nhf' : TendstoUniformly f' g' l\nhf : Filter.Eventually (fun n => ‚àÄ (x : ùïú), HasDerivAt (f n) (f' n x) x) l\nhfg : ‚àÄ (x : ùïú), Filter.Tendsto (fun n => f n x) l (nhds (g x))\nx : ùïú\n‚ä¢ HasDerivAt g (g' x) x","decl":"theorem hasDerivAt_of_tendstoUniformly [NeBot l] (hf' : TendstoUniformly f' g' l)\n    (hf : ‚àÄ·∂† n in l, ‚àÄ x : ùïú, HasDerivAt (f n) (f' n x) x)\n    (hfg : ‚àÄ x : ùïú, Tendsto (fun n => f n x) l (ùìù (g x))) (x : ùïú) : HasDerivAt g (g' x) x := by\n  have hf : ‚àÄ·∂† n in l, ‚àÄ x : ùïú, x ‚àà Set.univ ‚Üí HasDerivAt (f n) (f' n x) x := by\n    filter_upwards [hf] with n h x _ using h x\n  have hfg : ‚àÄ x : ùïú, x ‚àà Set.univ ‚Üí Tendsto (fun n => f n x) l (ùìù (g x)) := by simp [hfg]\n  have hf' : TendstoUniformlyOn f' g' l Set.univ := by rwa [tendstoUniformlyOn_univ]\n  exact hasDerivAt_of_tendstoUniformlyOn isOpen_univ hf' hf hfg (Set.mem_univ x)\n\n"}
