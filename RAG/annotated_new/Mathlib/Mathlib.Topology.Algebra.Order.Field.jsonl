{"name":"TopologicalRing.of_norm","module":"Mathlib.Topology.Algebra.Order.Field","initialProofState":"R : Type u_1\n𝕜 : Type u_2\ninst✝³ : NonUnitalNonAssocRing R\ninst✝² : LinearOrderedField 𝕜\ninst✝¹ : TopologicalSpace R\ninst✝ : TopologicalAddGroup R\nnorm : R → 𝕜\nnorm_nonneg : ∀ (x : R), LE.le 0 (norm x)\nnorm_mul_le : ∀ (x y : R), LE.le (norm (HMul.hMul x y)) (HMul.hMul (norm x) (norm y))\nnhds_basis : (nhds 0).HasBasis (fun x => LT.lt 0 x) fun ε => setOf fun x => LT.lt (norm x) ε\n⊢ TopologicalRing R","decl":"/-- If a (possibly non-unital and/or non-associative) ring `R` admits a submultiplicative\nnonnegative norm `norm : R → 𝕜`, where `𝕜` is a linear ordered field, and the open balls\n`{ x | norm x < ε }`, `ε > 0`, form a basis of neighborhoods of zero, then `R` is a topological\nring. -/\ntheorem TopologicalRing.of_norm {R 𝕜 : Type*} [NonUnitalNonAssocRing R] [LinearOrderedField 𝕜]\n    [TopologicalSpace R] [TopologicalAddGroup R] (norm : R → 𝕜)\n    (norm_nonneg : ∀ x, 0 ≤ norm x) (norm_mul_le : ∀ x y, norm (x * y) ≤ norm x * norm y)\n    (nhds_basis : (𝓝 (0 : R)).HasBasis ((0 : 𝕜) < ·) (fun ε ↦ { x | norm x < ε })) :\n    TopologicalRing R := by\n  have h0 : ∀ f : R → R, ∀ c ≥ (0 : 𝕜), (∀ x, norm (f x) ≤ c * norm x) →\n      Tendsto f (𝓝 0) (𝓝 0) := by\n    refine fun f c c0 hf ↦ (nhds_basis.tendsto_iff nhds_basis).2 fun ε ε0 ↦ ?_\n    rcases exists_pos_mul_lt ε0 c with ⟨δ, δ0, hδ⟩\n    refine ⟨δ, δ0, fun x hx ↦ (hf _).trans_lt ?_⟩\n    exact (mul_le_mul_of_nonneg_left (le_of_lt hx) c0).trans_lt hδ\n  apply TopologicalRing.of_addGroup_of_nhds_zero\n  case hmul =>\n    refine ((nhds_basis.prod nhds_basis).tendsto_iff nhds_basis).2 fun ε ε0 ↦ ?_\n    refine ⟨(1, ε), ⟨one_pos, ε0⟩, fun (x, y) ⟨hx, hy⟩ => ?_⟩\n    simp only [sub_zero] at *\n    calc norm (x * y) ≤ norm x * norm y := norm_mul_le _ _\n    _ < ε := mul_lt_of_le_one_of_lt_of_nonneg hx.le hy (norm_nonneg _)\n  case hmul_left => exact fun x => h0 _ (norm x) (norm_nonneg _) (norm_mul_le x)\n  case hmul_right =>\n    exact fun y => h0 (· * y) (norm y) (norm_nonneg y) fun x =>\n      (norm_mul_le x y).trans_eq (mul_comm _ _)\n\n"}
{"name":"LinearOrderedField.topologicalRing","module":"Mathlib.Topology.Algebra.Order.Field","initialProofState":"𝕜 : Type u_1\ninst✝² : LinearOrderedField 𝕜\ninst✝¹ : TopologicalSpace 𝕜\ninst✝ : OrderTopology 𝕜\n⊢ TopologicalRing 𝕜","decl":"instance (priority := 100) LinearOrderedField.topologicalRing : TopologicalRing 𝕜 :=\n  .of_norm abs abs_nonneg (fun _ _ ↦ (abs_mul _ _).le) <| by\n    simpa using nhds_basis_abs_sub_lt (0 : 𝕜)\n\n"}
{"name":"Filter.Tendsto.atTop_mul","module":"Mathlib.Topology.Algebra.Order.Field","initialProofState":"𝕜 : Type u_1\nα : Type u_2\ninst✝² : LinearOrderedField 𝕜\ninst✝¹ : TopologicalSpace 𝕜\ninst✝ : OrderTopology 𝕜\nl : Filter α\nf g : α → 𝕜\nC : 𝕜\nhC : LT.lt 0 C\nhf : Filter.Tendsto f l Filter.atTop\nhg : Filter.Tendsto g l (nhds C)\n⊢ Filter.Tendsto (fun x => HMul.hMul (f x) (g x)) l Filter.atTop","decl":"/-- In a linearly ordered field with the order topology, if `f` tends to `Filter.atTop` and `g`\ntends to a positive constant `C` then `f * g` tends to `Filter.atTop`. -/\ntheorem Filter.Tendsto.atTop_mul {C : 𝕜} (hC : 0 < C) (hf : Tendsto f l atTop)\n    (hg : Tendsto g l (𝓝 C)) : Tendsto (fun x => f x * g x) l atTop := by\n  refine tendsto_atTop_mono' _ ?_ (hf.atTop_mul_const (half_pos hC))\n  filter_upwards [hg.eventually (lt_mem_nhds (half_lt_self hC)), hf.eventually_ge_atTop 0]\n    with x hg hf using mul_le_mul_of_nonneg_left hg.le hf\n\n"}
{"name":"Filter.Tendsto.mul_atTop","module":"Mathlib.Topology.Algebra.Order.Field","initialProofState":"𝕜 : Type u_1\nα : Type u_2\ninst✝² : LinearOrderedField 𝕜\ninst✝¹ : TopologicalSpace 𝕜\ninst✝ : OrderTopology 𝕜\nl : Filter α\nf g : α → 𝕜\nC : 𝕜\nhC : LT.lt 0 C\nhf : Filter.Tendsto f l (nhds C)\nhg : Filter.Tendsto g l Filter.atTop\n⊢ Filter.Tendsto (fun x => HMul.hMul (f x) (g x)) l Filter.atTop","decl":"/-- In a linearly ordered field with the order topology, if `f` tends to a positive constant `C` and\n`g` tends to `Filter.atTop` then `f * g` tends to `Filter.atTop`. -/\ntheorem Filter.Tendsto.mul_atTop {C : 𝕜} (hC : 0 < C) (hf : Tendsto f l (𝓝 C))\n    (hg : Tendsto g l atTop) : Tendsto (fun x => f x * g x) l atTop := by\n  simpa only [mul_comm] using hg.atTop_mul hC hf\n\n"}
{"name":"Filter.Tendsto.atTop_mul_neg","module":"Mathlib.Topology.Algebra.Order.Field","initialProofState":"𝕜 : Type u_1\nα : Type u_2\ninst✝² : LinearOrderedField 𝕜\ninst✝¹ : TopologicalSpace 𝕜\ninst✝ : OrderTopology 𝕜\nl : Filter α\nf g : α → 𝕜\nC : 𝕜\nhC : LT.lt C 0\nhf : Filter.Tendsto f l Filter.atTop\nhg : Filter.Tendsto g l (nhds C)\n⊢ Filter.Tendsto (fun x => HMul.hMul (f x) (g x)) l Filter.atBot","decl":"/-- In a linearly ordered field with the order topology, if `f` tends to `Filter.atTop` and `g`\ntends to a negative constant `C` then `f * g` tends to `Filter.atBot`. -/\ntheorem Filter.Tendsto.atTop_mul_neg {C : 𝕜} (hC : C < 0) (hf : Tendsto f l atTop)\n    (hg : Tendsto g l (𝓝 C)) : Tendsto (fun x => f x * g x) l atBot := by\n  have := hf.atTop_mul (neg_pos.2 hC) hg.neg\n  simpa only [Function.comp_def, neg_mul_eq_mul_neg, neg_neg] using\n    tendsto_neg_atTop_atBot.comp this\n\n"}
{"name":"Filter.Tendsto.neg_mul_atTop","module":"Mathlib.Topology.Algebra.Order.Field","initialProofState":"𝕜 : Type u_1\nα : Type u_2\ninst✝² : LinearOrderedField 𝕜\ninst✝¹ : TopologicalSpace 𝕜\ninst✝ : OrderTopology 𝕜\nl : Filter α\nf g : α → 𝕜\nC : 𝕜\nhC : LT.lt C 0\nhf : Filter.Tendsto f l (nhds C)\nhg : Filter.Tendsto g l Filter.atTop\n⊢ Filter.Tendsto (fun x => HMul.hMul (f x) (g x)) l Filter.atBot","decl":"/-- In a linearly ordered field with the order topology, if `f` tends to a negative constant `C` and\n`g` tends to `Filter.atTop` then `f * g` tends to `Filter.atBot`. -/\ntheorem Filter.Tendsto.neg_mul_atTop {C : 𝕜} (hC : C < 0) (hf : Tendsto f l (𝓝 C))\n    (hg : Tendsto g l atTop) : Tendsto (fun x => f x * g x) l atBot := by\n  simpa only [mul_comm] using hg.atTop_mul_neg hC hf\n\n"}
{"name":"Filter.Tendsto.atBot_mul","module":"Mathlib.Topology.Algebra.Order.Field","initialProofState":"𝕜 : Type u_1\nα : Type u_2\ninst✝² : LinearOrderedField 𝕜\ninst✝¹ : TopologicalSpace 𝕜\ninst✝ : OrderTopology 𝕜\nl : Filter α\nf g : α → 𝕜\nC : 𝕜\nhC : LT.lt 0 C\nhf : Filter.Tendsto f l Filter.atBot\nhg : Filter.Tendsto g l (nhds C)\n⊢ Filter.Tendsto (fun x => HMul.hMul (f x) (g x)) l Filter.atBot","decl":"/-- In a linearly ordered field with the order topology, if `f` tends to `Filter.atBot` and `g`\ntends to a positive constant `C` then `f * g` tends to `Filter.atBot`. -/\ntheorem Filter.Tendsto.atBot_mul {C : 𝕜} (hC : 0 < C) (hf : Tendsto f l atBot)\n    (hg : Tendsto g l (𝓝 C)) : Tendsto (fun x => f x * g x) l atBot := by\n  have := (tendsto_neg_atBot_atTop.comp hf).atTop_mul hC hg\n  simpa [Function.comp_def] using tendsto_neg_atTop_atBot.comp this\n\n"}
{"name":"Filter.Tendsto.atBot_mul_neg","module":"Mathlib.Topology.Algebra.Order.Field","initialProofState":"𝕜 : Type u_1\nα : Type u_2\ninst✝² : LinearOrderedField 𝕜\ninst✝¹ : TopologicalSpace 𝕜\ninst✝ : OrderTopology 𝕜\nl : Filter α\nf g : α → 𝕜\nC : 𝕜\nhC : LT.lt C 0\nhf : Filter.Tendsto f l Filter.atBot\nhg : Filter.Tendsto g l (nhds C)\n⊢ Filter.Tendsto (fun x => HMul.hMul (f x) (g x)) l Filter.atTop","decl":"/-- In a linearly ordered field with the order topology, if `f` tends to `Filter.atBot` and `g`\ntends to a negative constant `C` then `f * g` tends to `Filter.atTop`. -/\ntheorem Filter.Tendsto.atBot_mul_neg {C : 𝕜} (hC : C < 0) (hf : Tendsto f l atBot)\n    (hg : Tendsto g l (𝓝 C)) : Tendsto (fun x => f x * g x) l atTop := by\n  have := (tendsto_neg_atBot_atTop.comp hf).atTop_mul_neg hC hg\n  simpa [Function.comp_def] using tendsto_neg_atBot_atTop.comp this\n\n"}
{"name":"Filter.Tendsto.mul_atBot","module":"Mathlib.Topology.Algebra.Order.Field","initialProofState":"𝕜 : Type u_1\nα : Type u_2\ninst✝² : LinearOrderedField 𝕜\ninst✝¹ : TopologicalSpace 𝕜\ninst✝ : OrderTopology 𝕜\nl : Filter α\nf g : α → 𝕜\nC : 𝕜\nhC : LT.lt 0 C\nhf : Filter.Tendsto f l (nhds C)\nhg : Filter.Tendsto g l Filter.atBot\n⊢ Filter.Tendsto (fun x => HMul.hMul (f x) (g x)) l Filter.atBot","decl":"/-- In a linearly ordered field with the order topology, if `f` tends to a positive constant `C` and\n`g` tends to `Filter.atBot` then `f * g` tends to `Filter.atBot`. -/\ntheorem Filter.Tendsto.mul_atBot {C : 𝕜} (hC : 0 < C) (hf : Tendsto f l (𝓝 C))\n    (hg : Tendsto g l atBot) : Tendsto (fun x => f x * g x) l atBot := by\n  simpa only [mul_comm] using hg.atBot_mul hC hf\n\n"}
{"name":"Filter.Tendsto.neg_mul_atBot","module":"Mathlib.Topology.Algebra.Order.Field","initialProofState":"𝕜 : Type u_1\nα : Type u_2\ninst✝² : LinearOrderedField 𝕜\ninst✝¹ : TopologicalSpace 𝕜\ninst✝ : OrderTopology 𝕜\nl : Filter α\nf g : α → 𝕜\nC : 𝕜\nhC : LT.lt C 0\nhf : Filter.Tendsto f l (nhds C)\nhg : Filter.Tendsto g l Filter.atBot\n⊢ Filter.Tendsto (fun x => HMul.hMul (f x) (g x)) l Filter.atTop","decl":"/-- In a linearly ordered field with the order topology, if `f` tends to a negative constant `C` and\n`g` tends to `Filter.atBot` then `f * g` tends to `Filter.atTop`. -/\ntheorem Filter.Tendsto.neg_mul_atBot {C : 𝕜} (hC : C < 0) (hf : Tendsto f l (𝓝 C))\n    (hg : Tendsto g l atBot) : Tendsto (fun x => f x * g x) l atTop := by\n  simpa only [mul_comm] using hg.atBot_mul_neg hC hf\n\n"}
{"name":"inv_atTop₀","module":"Mathlib.Topology.Algebra.Order.Field","initialProofState":"𝕜 : Type u_1\ninst✝² : LinearOrderedField 𝕜\ninst✝¹ : TopologicalSpace 𝕜\ninst✝ : OrderTopology 𝕜\n⊢ Eq (Inv.inv Filter.atTop) (nhdsWithin 0 (Set.Ioi 0))","decl":"@[simp]\nlemma inv_atTop₀ : (atTop : Filter 𝕜)⁻¹ = 𝓝[>] 0 :=\n  (((atTop_basis_Ioi' (0 : 𝕜)).map _).comp_surjective inv_surjective).eq_of_same_basis <|\n    (nhdsGT_basis _).congr (by simp) fun a ha ↦ by simp [inv_Ioi₀ (inv_pos.2 ha)]\n\n"}
{"name":"inv_atBot₀","module":"Mathlib.Topology.Algebra.Order.Field","initialProofState":"𝕜 : Type u_1\ninst✝² : LinearOrderedField 𝕜\ninst✝¹ : TopologicalSpace 𝕜\ninst✝ : OrderTopology 𝕜\n⊢ Eq (Inv.inv Filter.atBot) (nhdsWithin 0 (Set.Iio 0))","decl":"@[simp]\nlemma inv_atBot₀ : (atBot : Filter 𝕜)⁻¹ = 𝓝[<] 0 :=\n  (((atBot_basis_Iio' (0 : 𝕜)).map _).comp_surjective inv_surjective).eq_of_same_basis <|\n    (nhdsLT_basis _).congr (by simp) fun a ha ↦ by simp [inv_Iio₀ (inv_neg''.2 ha)]\n\n"}
{"name":"inv_nhdsGT_zero","module":"Mathlib.Topology.Algebra.Order.Field","initialProofState":"𝕜 : Type u_1\ninst✝² : LinearOrderedField 𝕜\ninst✝¹ : TopologicalSpace 𝕜\ninst✝ : OrderTopology 𝕜\n⊢ Eq (Inv.inv (nhdsWithin 0 (Set.Ioi 0))) Filter.atTop","decl":"@[simp]\nlemma inv_nhdsGT_zero : (𝓝[>] (0 : 𝕜))⁻¹ = atTop := by rw [← inv_atTop₀, inv_inv]\n\n"}
{"name":"inv_nhdsWithin_Ioi_zero","module":"Mathlib.Topology.Algebra.Order.Field","initialProofState":"𝕜 : Type u_1\ninst✝² : LinearOrderedField 𝕜\ninst✝¹ : TopologicalSpace 𝕜\ninst✝ : OrderTopology 𝕜\n⊢ Eq (Inv.inv (nhdsWithin 0 (Set.Ioi 0))) Filter.atTop","decl":"@[deprecated (since := \"2024-12-22\")] alias inv_nhdsWithin_Ioi_zero := inv_nhdsGT_zero\n\n"}
{"name":"inv_nhdsLT_zero","module":"Mathlib.Topology.Algebra.Order.Field","initialProofState":"𝕜 : Type u_1\ninst✝² : LinearOrderedField 𝕜\ninst✝¹ : TopologicalSpace 𝕜\ninst✝ : OrderTopology 𝕜\n⊢ Eq (Inv.inv (nhdsWithin 0 (Set.Iio 0))) Filter.atBot","decl":"@[simp]\nlemma inv_nhdsLT_zero : (𝓝[<] (0 : 𝕜))⁻¹ = atBot := by\n  rw [← inv_atBot₀, inv_inv]\n\n"}
{"name":"tendsto_inv_nhdsGT_zero","module":"Mathlib.Topology.Algebra.Order.Field","initialProofState":"𝕜 : Type u_1\ninst✝² : LinearOrderedField 𝕜\ninst✝¹ : TopologicalSpace 𝕜\ninst✝ : OrderTopology 𝕜\n⊢ Filter.Tendsto (fun x => Inv.inv x) (nhdsWithin 0 (Set.Ioi 0)) Filter.atTop","decl":"/-- The function `x ↦ x⁻¹` tends to `+∞` on the right of `0`. -/\ntheorem tendsto_inv_nhdsGT_zero : Tendsto (fun x : 𝕜 => x⁻¹) (𝓝[>] (0 : 𝕜)) atTop :=\n  inv_nhdsGT_zero.le\n\n"}
{"name":"tendsto_inv_zero_atTop","module":"Mathlib.Topology.Algebra.Order.Field","initialProofState":"𝕜 : Type u_1\ninst✝² : LinearOrderedField 𝕜\ninst✝¹ : TopologicalSpace 𝕜\ninst✝ : OrderTopology 𝕜\n⊢ Filter.Tendsto (fun x => Inv.inv x) (nhdsWithin 0 (Set.Ioi 0)) Filter.atTop","decl":"@[deprecated (since := \"2024-12-22\")]\nalias tendsto_inv_zero_atTop := tendsto_inv_nhdsGT_zero\n\n"}
{"name":"tendsto_inv_atTop_nhdsGT_zero","module":"Mathlib.Topology.Algebra.Order.Field","initialProofState":"𝕜 : Type u_1\ninst✝² : LinearOrderedField 𝕜\ninst✝¹ : TopologicalSpace 𝕜\ninst✝ : OrderTopology 𝕜\n⊢ Filter.Tendsto (fun r => Inv.inv r) Filter.atTop (nhdsWithin 0 (Set.Ioi 0))","decl":"/-- The function `r ↦ r⁻¹` tends to `0` on the right as `r → +∞`. -/\ntheorem tendsto_inv_atTop_nhdsGT_zero : Tendsto (fun r : 𝕜 => r⁻¹) atTop (𝓝[>] (0 : 𝕜)) :=\n  inv_atTop₀.le\n\n"}
{"name":"tendsto_inv_atTop_zero'","module":"Mathlib.Topology.Algebra.Order.Field","initialProofState":"𝕜 : Type u_1\ninst✝² : LinearOrderedField 𝕜\ninst✝¹ : TopologicalSpace 𝕜\ninst✝ : OrderTopology 𝕜\n⊢ Filter.Tendsto (fun r => Inv.inv r) Filter.atTop (nhdsWithin 0 (Set.Ioi 0))","decl":"@[deprecated (since := \"2024-12-22\")]\nalias tendsto_inv_atTop_zero' := tendsto_inv_atTop_nhdsGT_zero\n\n"}
{"name":"tendsto_inv_atTop_zero","module":"Mathlib.Topology.Algebra.Order.Field","initialProofState":"𝕜 : Type u_1\ninst✝² : LinearOrderedField 𝕜\ninst✝¹ : TopologicalSpace 𝕜\ninst✝ : OrderTopology 𝕜\n⊢ Filter.Tendsto (fun r => Inv.inv r) Filter.atTop (nhds 0)","decl":"theorem tendsto_inv_atTop_zero : Tendsto (fun r : 𝕜 => r⁻¹) atTop (𝓝 0) :=\n  tendsto_inv_atTop_nhdsGT_zero.mono_right inf_le_left\n\n"}
{"name":"tendsto_inv_zero_atBot","module":"Mathlib.Topology.Algebra.Order.Field","initialProofState":"𝕜 : Type u_1\ninst✝² : LinearOrderedField 𝕜\ninst✝¹ : TopologicalSpace 𝕜\ninst✝ : OrderTopology 𝕜\n⊢ Filter.Tendsto (fun x => Inv.inv x) (nhdsWithin 0 (Set.Iio 0)) Filter.atBot","decl":"/-- The function `x ↦ x⁻¹` tends to `-∞` on the left of `0`. -/\ntheorem tendsto_inv_zero_atBot : Tendsto (fun x : 𝕜 => x⁻¹) (𝓝[<] (0 : 𝕜)) atBot :=\n  inv_nhdsLT_zero.le\n\n"}
{"name":"tendsto_inv_atBot_zero'","module":"Mathlib.Topology.Algebra.Order.Field","initialProofState":"𝕜 : Type u_1\ninst✝² : LinearOrderedField 𝕜\ninst✝¹ : TopologicalSpace 𝕜\ninst✝ : OrderTopology 𝕜\n⊢ Filter.Tendsto (fun r => Inv.inv r) Filter.atBot (nhdsWithin 0 (Set.Iio 0))","decl":"/-- The function `r ↦ r⁻¹` tends to `0` on the left as `r → -∞`. -/\ntheorem tendsto_inv_atBot_zero' : Tendsto (fun r : 𝕜 => r⁻¹) atBot (𝓝[<] (0 : 𝕜)) :=\n  inv_atBot₀.le\n\n"}
{"name":"tendsto_inv_atBot_zero","module":"Mathlib.Topology.Algebra.Order.Field","initialProofState":"𝕜 : Type u_1\ninst✝² : LinearOrderedField 𝕜\ninst✝¹ : TopologicalSpace 𝕜\ninst✝ : OrderTopology 𝕜\n⊢ Filter.Tendsto (fun r => Inv.inv r) Filter.atBot (nhds 0)","decl":"theorem tendsto_inv_atBot_zero : Tendsto (fun r : 𝕜 => r⁻¹) atBot (𝓝 0) :=\n  tendsto_inv_atBot_zero'.mono_right inf_le_left\n\n"}
{"name":"Filter.Tendsto.div_atTop","module":"Mathlib.Topology.Algebra.Order.Field","initialProofState":"𝕜 : Type u_1\nα : Type u_2\ninst✝² : LinearOrderedField 𝕜\ninst✝¹ : TopologicalSpace 𝕜\ninst✝ : OrderTopology 𝕜\nl : Filter α\nf g : α → 𝕜\na : 𝕜\nh : Filter.Tendsto f l (nhds a)\nhg : Filter.Tendsto g l Filter.atTop\n⊢ Filter.Tendsto (fun x => HDiv.hDiv (f x) (g x)) l (nhds 0)","decl":"theorem Filter.Tendsto.div_atTop {a : 𝕜} (h : Tendsto f l (𝓝 a)) (hg : Tendsto g l atTop) :\n    Tendsto (fun x => f x / g x) l (𝓝 0) := by\n  simp only [div_eq_mul_inv]\n  exact mul_zero a ▸ h.mul (tendsto_inv_atTop_zero.comp hg)\n\n"}
{"name":"Filter.Tendsto.div_atBot","module":"Mathlib.Topology.Algebra.Order.Field","initialProofState":"𝕜 : Type u_1\nα : Type u_2\ninst✝² : LinearOrderedField 𝕜\ninst✝¹ : TopologicalSpace 𝕜\ninst✝ : OrderTopology 𝕜\nl : Filter α\nf g : α → 𝕜\na : 𝕜\nh : Filter.Tendsto f l (nhds a)\nhg : Filter.Tendsto g l Filter.atBot\n⊢ Filter.Tendsto (fun x => HDiv.hDiv (f x) (g x)) l (nhds 0)","decl":"theorem Filter.Tendsto.div_atBot {a : 𝕜} (h : Tendsto f l (𝓝 a)) (hg : Tendsto g l atBot) :\n    Tendsto (fun x => f x / g x) l (𝓝 0) := by\n  simp only [div_eq_mul_inv]\n  exact mul_zero a ▸ h.mul (tendsto_inv_atBot_zero.comp hg)\n\n"}
{"name":"Filter.Tendsto.const_div_atTop","module":"Mathlib.Topology.Algebra.Order.Field","initialProofState":"𝕜 : Type u_1\nα : Type u_2\ninst✝² : LinearOrderedField 𝕜\ninst✝¹ : TopologicalSpace 𝕜\ninst✝ : OrderTopology 𝕜\nl : Filter α\ng : α → 𝕜\nhg : Filter.Tendsto g l Filter.atTop\nr : 𝕜\n⊢ Filter.Tendsto (fun n => HDiv.hDiv r (g n)) l (nhds 0)","decl":"lemma Filter.Tendsto.const_div_atTop (hg : Tendsto g l atTop) (r : 𝕜)  :\n    Tendsto (fun n ↦ r / g n) l (𝓝 0) :=\n  tendsto_const_nhds.div_atTop hg\n\n"}
{"name":"Filter.Tendsto.const_div_atBot","module":"Mathlib.Topology.Algebra.Order.Field","initialProofState":"𝕜 : Type u_1\nα : Type u_2\ninst✝² : LinearOrderedField 𝕜\ninst✝¹ : TopologicalSpace 𝕜\ninst✝ : OrderTopology 𝕜\nl : Filter α\ng : α → 𝕜\nhg : Filter.Tendsto g l Filter.atBot\nr : 𝕜\n⊢ Filter.Tendsto (fun n => HDiv.hDiv r (g n)) l (nhds 0)","decl":"lemma Filter.Tendsto.const_div_atBot (hg : Tendsto g l atBot) (r : 𝕜)  :\n    Tendsto (fun n ↦ r / g n) l (𝓝 0) :=\n  tendsto_const_nhds.div_atBot hg\n\n"}
{"name":"Filter.Tendsto.inv_tendsto_atTop","module":"Mathlib.Topology.Algebra.Order.Field","initialProofState":"𝕜 : Type u_1\nα : Type u_2\ninst✝² : LinearOrderedField 𝕜\ninst✝¹ : TopologicalSpace 𝕜\ninst✝ : OrderTopology 𝕜\nl : Filter α\nf : α → 𝕜\nh : Filter.Tendsto f l Filter.atTop\n⊢ Filter.Tendsto (Inv.inv f) l (nhds 0)","decl":"theorem Filter.Tendsto.inv_tendsto_atTop (h : Tendsto f l atTop) : Tendsto f⁻¹ l (𝓝 0) :=\n  tendsto_inv_atTop_zero.comp h\n\n"}
{"name":"Filter.Tendsto.inv_tendsto_atBot","module":"Mathlib.Topology.Algebra.Order.Field","initialProofState":"𝕜 : Type u_1\nα : Type u_2\ninst✝² : LinearOrderedField 𝕜\ninst✝¹ : TopologicalSpace 𝕜\ninst✝ : OrderTopology 𝕜\nl : Filter α\nf : α → 𝕜\nh : Filter.Tendsto f l Filter.atBot\n⊢ Filter.Tendsto (Inv.inv f) l (nhds 0)","decl":"theorem Filter.Tendsto.inv_tendsto_atBot (h : Tendsto f l atBot) : Tendsto f⁻¹ l (𝓝 0) :=\n  tendsto_inv_atBot_zero.comp h\n\n"}
{"name":"Filter.Tendsto.inv_tendsto_nhdsGT_zero","module":"Mathlib.Topology.Algebra.Order.Field","initialProofState":"𝕜 : Type u_1\nα : Type u_2\ninst✝² : LinearOrderedField 𝕜\ninst✝¹ : TopologicalSpace 𝕜\ninst✝ : OrderTopology 𝕜\nl : Filter α\nf : α → 𝕜\nh : Filter.Tendsto f l (nhdsWithin 0 (Set.Ioi 0))\n⊢ Filter.Tendsto (Inv.inv f) l Filter.atTop","decl":"theorem Filter.Tendsto.inv_tendsto_nhdsGT_zero (h : Tendsto f l (𝓝[>] 0)) : Tendsto f⁻¹ l atTop :=\n  tendsto_inv_nhdsGT_zero.comp h\n\n"}
{"name":"Filter.Tendsto.inv_tendsto_zero","module":"Mathlib.Topology.Algebra.Order.Field","initialProofState":"𝕜 : Type u_1\nα : Type u_2\ninst✝² : LinearOrderedField 𝕜\ninst✝¹ : TopologicalSpace 𝕜\ninst✝ : OrderTopology 𝕜\nl : Filter α\nf : α → 𝕜\nh : Filter.Tendsto f l (nhdsWithin 0 (Set.Ioi 0))\n⊢ Filter.Tendsto (Inv.inv f) l Filter.atTop","decl":"@[deprecated (since := \"2024-12-22\")]\nalias Filter.Tendsto.inv_tendsto_zero := Filter.Tendsto.inv_tendsto_nhdsGT_zero\n\n"}
{"name":"Filter.Tendsto.inv_tendsto_nhdsLT_zero","module":"Mathlib.Topology.Algebra.Order.Field","initialProofState":"𝕜 : Type u_1\nα : Type u_2\ninst✝² : LinearOrderedField 𝕜\ninst✝¹ : TopologicalSpace 𝕜\ninst✝ : OrderTopology 𝕜\nl : Filter α\nf : α → 𝕜\nh : Filter.Tendsto f l (nhdsWithin 0 (Set.Iio 0))\n⊢ Filter.Tendsto (Inv.inv f) l Filter.atBot","decl":"theorem Filter.Tendsto.inv_tendsto_nhdsLT_zero (h : Tendsto f l (𝓝[<] 0)) : Tendsto f⁻¹ l atBot :=\n  tendsto_inv_zero_atBot.comp h\n\n"}
{"name":"bdd_le_mul_tendsto_zero'","module":"Mathlib.Topology.Algebra.Order.Field","initialProofState":"𝕜 : Type u_1\nα : Type u_2\ninst✝² : LinearOrderedField 𝕜\ninst✝¹ : TopologicalSpace 𝕜\ninst✝ : OrderTopology 𝕜\nl : Filter α\nf g : α → 𝕜\nC : 𝕜\nhf : Filter.Eventually (fun x => LE.le (abs (f x)) C) l\nhg : Filter.Tendsto g l (nhds 0)\n⊢ Filter.Tendsto (fun x => HMul.hMul (f x) (g x)) l (nhds 0)","decl":"/-- If `g` tends to zero and there exists a constant `C : 𝕜` such that eventually `|f x| ≤ C`,\n  then the product `f * g` tends to zero. -/\ntheorem bdd_le_mul_tendsto_zero' {f g : α → 𝕜} (C : 𝕜) (hf : ∀ᶠ x in l, |f x| ≤ C)\n    (hg : Tendsto g l (𝓝 0)) : Tendsto (fun x ↦ f x * g x) l (𝓝 0) := by\n  rw [tendsto_zero_iff_abs_tendsto_zero]\n  have hC : Tendsto (fun x ↦ |C * g x|) l (𝓝 0) := by\n    convert (hg.const_mul C).abs\n    simp_rw [mul_zero, abs_zero]\n  apply tendsto_of_tendsto_of_tendsto_of_le_of_le' tendsto_const_nhds hC\n  · filter_upwards [hf] with x _ using abs_nonneg _\n  · filter_upwards [hf] with x hx\n    simp only [comp_apply, abs_mul]\n    exact mul_le_mul_of_nonneg_right (hx.trans (le_abs_self C)) (abs_nonneg _)\n\n"}
{"name":"bdd_le_mul_tendsto_zero","module":"Mathlib.Topology.Algebra.Order.Field","initialProofState":"𝕜 : Type u_1\nα : Type u_2\ninst✝² : LinearOrderedField 𝕜\ninst✝¹ : TopologicalSpace 𝕜\ninst✝ : OrderTopology 𝕜\nl : Filter α\nf g : α → 𝕜\nb B : 𝕜\nhb : Filter.Eventually (fun x => LE.le b (f x)) l\nhB : Filter.Eventually (fun x => LE.le (f x) B) l\nhg : Filter.Tendsto g l (nhds 0)\n⊢ Filter.Tendsto (fun x => HMul.hMul (f x) (g x)) l (nhds 0)","decl":"/-- If `g` tends to zero and there exist constants `b B : 𝕜` such that eventually `b ≤ f x| ≤ B`,\n  then the product `f * g` tends to zero. -/\ntheorem bdd_le_mul_tendsto_zero {f g : α → 𝕜} {b B : 𝕜} (hb : ∀ᶠ x in l, b ≤ f x)\n    (hB : ∀ᶠ x in l, f x ≤ B) (hg : Tendsto g l (𝓝 0)) :\n    Tendsto (fun x ↦ f x * g x) l (𝓝 0) := by\n  set C := max |b| |B|\n  have hbC : -C ≤ b := neg_le.mpr (le_max_of_le_left (neg_le_abs b))\n  have hBC : B ≤ C := le_max_of_le_right (le_abs_self B)\n  apply bdd_le_mul_tendsto_zero' C _ hg\n  filter_upwards [hb, hB]\n  exact fun x hbx hBx ↦ abs_le.mpr ⟨hbC.trans hbx, hBx.trans hBC⟩\n\n"}
{"name":"tendsto_bdd_div_atTop_nhds_zero","module":"Mathlib.Topology.Algebra.Order.Field","initialProofState":"𝕜 : Type u_1\nα : Type u_2\ninst✝² : LinearOrderedField 𝕜\ninst✝¹ : TopologicalSpace 𝕜\ninst✝ : OrderTopology 𝕜\nl : Filter α\nf g : α → 𝕜\nb B : 𝕜\nhb : Filter.Eventually (fun x => LE.le b (f x)) l\nhB : Filter.Eventually (fun x => LE.le (f x) B) l\nhg : Filter.Tendsto g l Filter.atTop\n⊢ Filter.Tendsto (fun x => HDiv.hDiv (f x) (g x)) l (nhds 0)","decl":"/-- If `g` tends to `atTop` and there exist constants `b B : 𝕜` such that eventually\n  `b ≤ f x| ≤ B`, then the quotient `f / g` tends to zero. -/\ntheorem tendsto_bdd_div_atTop_nhds_zero {f g : α → 𝕜} {b B : 𝕜}\n    (hb : ∀ᶠ x in l, b ≤ f x) (hB : ∀ᶠ x in l, f x ≤ B) (hg : Tendsto g l atTop) :\n    Tendsto (fun x => f x / g x) l (𝓝 0) := by\n  simp only [div_eq_mul_inv]\n  exact bdd_le_mul_tendsto_zero hb hB hg.inv_tendsto_atTop\n\n"}
{"name":"tendsto_pow_neg_atTop","module":"Mathlib.Topology.Algebra.Order.Field","initialProofState":"𝕜 : Type u_1\ninst✝² : LinearOrderedField 𝕜\ninst✝¹ : TopologicalSpace 𝕜\ninst✝ : OrderTopology 𝕜\nn : Nat\nhn : Ne n 0\n⊢ Filter.Tendsto (fun x => HPow.hPow x (Neg.neg ↑n)) Filter.atTop (nhds 0)","decl":"/-- The function `x^(-n)` tends to `0` at `+∞` for any positive natural `n`.\nA version for positive real powers exists as `tendsto_rpow_neg_atTop`. -/\ntheorem tendsto_pow_neg_atTop {n : ℕ} (hn : n ≠ 0) :\n    Tendsto (fun x : 𝕜 => x ^ (-(n : ℤ))) atTop (𝓝 0) := by\n  simpa only [zpow_neg, zpow_natCast] using (@tendsto_pow_atTop 𝕜 _ _ hn).inv_tendsto_atTop\n\n"}
{"name":"tendsto_zpow_atTop_zero","module":"Mathlib.Topology.Algebra.Order.Field","initialProofState":"𝕜 : Type u_1\ninst✝² : LinearOrderedField 𝕜\ninst✝¹ : TopologicalSpace 𝕜\ninst✝ : OrderTopology 𝕜\nn : Int\nhn : LT.lt n 0\n⊢ Filter.Tendsto (fun x => HPow.hPow x n) Filter.atTop (nhds 0)","decl":"theorem tendsto_zpow_atTop_zero {n : ℤ} (hn : n < 0) :\n    Tendsto (fun x : 𝕜 => x ^ n) atTop (𝓝 0) := by\n  lift -n to ℕ using le_of_lt (neg_pos.mpr hn) with N h\n  rw [← neg_pos, ← h, Nat.cast_pos] at hn\n  simpa only [h, neg_neg] using tendsto_pow_neg_atTop hn.ne'\n\n"}
{"name":"tendsto_const_mul_zpow_atTop_zero","module":"Mathlib.Topology.Algebra.Order.Field","initialProofState":"𝕜 : Type u_1\ninst✝² : LinearOrderedField 𝕜\ninst✝¹ : TopologicalSpace 𝕜\ninst✝ : OrderTopology 𝕜\nn : Int\nc : 𝕜\nhn : LT.lt n 0\n⊢ Filter.Tendsto (fun x => HMul.hMul c (HPow.hPow x n)) Filter.atTop (nhds 0)","decl":"theorem tendsto_const_mul_zpow_atTop_zero {n : ℤ} {c : 𝕜} (hn : n < 0) :\n    Tendsto (fun x => c * x ^ n) atTop (𝓝 0) :=\n  mul_zero c ▸ Filter.Tendsto.const_mul c (tendsto_zpow_atTop_zero hn)\n\n"}
{"name":"tendsto_const_mul_pow_nhds_iff'","module":"Mathlib.Topology.Algebra.Order.Field","initialProofState":"𝕜 : Type u_1\ninst✝² : LinearOrderedField 𝕜\ninst✝¹ : TopologicalSpace 𝕜\ninst✝ : OrderTopology 𝕜\nn : Nat\nc d : 𝕜\n⊢ Iff (Filter.Tendsto (fun x => HMul.hMul c (HPow.hPow x n)) Filter.atTop (nhds d)) (And (Or (Eq c 0) (Eq n 0)) (Eq c d))","decl":"theorem tendsto_const_mul_pow_nhds_iff' {n : ℕ} {c d : 𝕜} :\n    Tendsto (fun x : 𝕜 => c * x ^ n) atTop (𝓝 d) ↔ (c = 0 ∨ n = 0) ∧ c = d := by\n  rcases eq_or_ne n 0 with (rfl | hn)\n  · simp [tendsto_const_nhds_iff]\n  rcases lt_trichotomy c 0 with (hc | rfl | hc)\n  · have := tendsto_const_mul_pow_atBot_iff.2 ⟨hn, hc⟩\n    simp [not_tendsto_nhds_of_tendsto_atBot this, hc.ne, hn]\n  · simp [tendsto_const_nhds_iff]\n  · have := tendsto_const_mul_pow_atTop_iff.2 ⟨hn, hc⟩\n    simp [not_tendsto_nhds_of_tendsto_atTop this, hc.ne', hn]\n\n"}
{"name":"tendsto_const_mul_pow_nhds_iff","module":"Mathlib.Topology.Algebra.Order.Field","initialProofState":"𝕜 : Type u_1\ninst✝² : LinearOrderedField 𝕜\ninst✝¹ : TopologicalSpace 𝕜\ninst✝ : OrderTopology 𝕜\nn : Nat\nc d : 𝕜\nhc : Ne c 0\n⊢ Iff (Filter.Tendsto (fun x => HMul.hMul c (HPow.hPow x n)) Filter.atTop (nhds d)) (And (Eq n 0) (Eq c d))","decl":"theorem tendsto_const_mul_pow_nhds_iff {n : ℕ} {c d : 𝕜} (hc : c ≠ 0) :\n    Tendsto (fun x : 𝕜 => c * x ^ n) atTop (𝓝 d) ↔ n = 0 ∧ c = d := by\n  simp [tendsto_const_mul_pow_nhds_iff', hc]\n\n"}
{"name":"tendsto_const_mul_zpow_atTop_nhds_iff","module":"Mathlib.Topology.Algebra.Order.Field","initialProofState":"𝕜 : Type u_1\ninst✝² : LinearOrderedField 𝕜\ninst✝¹ : TopologicalSpace 𝕜\ninst✝ : OrderTopology 𝕜\nn : Int\nc d : 𝕜\nhc : Ne c 0\n⊢ Iff (Filter.Tendsto (fun x => HMul.hMul c (HPow.hPow x n)) Filter.atTop (nhds d)) (Or (And (Eq n 0) (Eq c d)) (And (LT.lt n 0) (Eq d 0)))","decl":"theorem tendsto_const_mul_zpow_atTop_nhds_iff {n : ℤ} {c d : 𝕜} (hc : c ≠ 0) :\n    Tendsto (fun x : 𝕜 => c * x ^ n) atTop (𝓝 d) ↔ n = 0 ∧ c = d ∨ n < 0 ∧ d = 0 := by\n  refine ⟨fun h => ?_, fun h => ?_⟩\n  · cases n with -- Porting note: Lean 3 proof used `by_cases`, then `lift` but `lift` failed\n    | ofNat n =>\n      left\n      simpa [tendsto_const_mul_pow_nhds_iff hc] using h\n    | negSucc n =>\n      have hn := Int.negSucc_lt_zero n\n      exact Or.inr ⟨hn, tendsto_nhds_unique h (tendsto_const_mul_zpow_atTop_zero hn)⟩\n  · cases' h with h h\n    · simp only [h.left, h.right, zpow_zero, mul_one]\n      exact tendsto_const_nhds\n    · exact h.2.symm ▸ tendsto_const_mul_zpow_atTop_zero h.1\n\n-- see Note [lower instance priority]\n"}
{"name":"LinearOrderedSemifield.toHasContinuousInv₀","module":"Mathlib.Topology.Algebra.Order.Field","initialProofState":"𝕜 : Type u_3\ninst✝³ : LinearOrderedSemifield 𝕜\ninst✝² : TopologicalSpace 𝕜\ninst✝¹ : OrderTopology 𝕜\ninst✝ : ContinuousMul 𝕜\n⊢ HasContinuousInv₀ 𝕜","decl":"instance (priority := 100) LinearOrderedSemifield.toHasContinuousInv₀ {𝕜}\n    [LinearOrderedSemifield 𝕜] [TopologicalSpace 𝕜] [OrderTopology 𝕜] [ContinuousMul 𝕜] :\n    HasContinuousInv₀ 𝕜 := .of_nhds_one <| tendsto_order.2 <| by\n  refine ⟨fun x hx => ?_, fun x hx => ?_⟩\n  · obtain ⟨x', h₀, hxx', h₁⟩ : ∃ x', 0 < x' ∧ x ≤ x' ∧ x' < 1 :=\n      ⟨max x (1 / 2), one_half_pos.trans_le (le_max_right _ _), le_max_left _ _,\n        max_lt hx one_half_lt_one⟩\n    filter_upwards [Ioo_mem_nhds one_pos ((one_lt_inv₀ h₀).2 h₁)] with y hy\n    exact hxx'.trans_lt <| lt_inv_of_lt_inv₀ hy.1 hy.2\n  · filter_upwards [Ioi_mem_nhds (inv_lt_one_of_one_lt₀ hx)] with y hy\n    exact inv_lt_of_inv_lt₀ (by positivity) hy\n\n"}
{"name":"LinearOrderedField.toTopologicalDivisionRing","module":"Mathlib.Topology.Algebra.Order.Field","initialProofState":"𝕜 : Type u_1\ninst✝² : LinearOrderedField 𝕜\ninst✝¹ : TopologicalSpace 𝕜\ninst✝ : OrderTopology 𝕜\n⊢ TopologicalDivisionRing 𝕜","decl":"instance (priority := 100) LinearOrderedField.toTopologicalDivisionRing :\n    TopologicalDivisionRing 𝕜 := ⟨⟩\n\n-- Porting note (https://github.com/leanprover-community/mathlib4/issues/11215): TODO: generalize to a `GroupWithZero`\n"}
{"name":"comap_mulLeft_nhdsGT_zero","module":"Mathlib.Topology.Algebra.Order.Field","initialProofState":"𝕜 : Type u_1\ninst✝² : LinearOrderedField 𝕜\ninst✝¹ : TopologicalSpace 𝕜\ninst✝ : OrderTopology 𝕜\nx : 𝕜\nhx : LT.lt 0 x\n⊢ Eq (Filter.comap (fun x_1 => HMul.hMul x x_1) (nhdsWithin 0 (Set.Ioi 0))) (nhdsWithin 0 (Set.Ioi 0))","decl":"theorem comap_mulLeft_nhdsGT_zero {x : 𝕜} (hx : 0 < x) : comap (x * ·) (𝓝[>] 0) = 𝓝[>] 0 := by\n  rw [nhdsWithin, comap_inf, comap_principal, preimage_const_mul_Ioi _ hx, zero_div]\n  congr 1\n  refine ((Homeomorph.mulLeft₀ x hx.ne').comap_nhds_eq _).trans ?_\n  simp\n\n"}
{"name":"nhdsWithin_pos_comap_mul_left","module":"Mathlib.Topology.Algebra.Order.Field","initialProofState":"𝕜 : Type u_1\ninst✝² : LinearOrderedField 𝕜\ninst✝¹ : TopologicalSpace 𝕜\ninst✝ : OrderTopology 𝕜\nx : 𝕜\nhx : LT.lt 0 x\n⊢ Eq (Filter.comap (fun x_1 => HMul.hMul x x_1) (nhdsWithin 0 (Set.Ioi 0))) (nhdsWithin 0 (Set.Ioi 0))","decl":"@[deprecated (since := \"2024-12-22\")]\nalias nhdsWithin_pos_comap_mul_left := comap_mulLeft_nhdsGT_zero\n\n"}
{"name":"eventually_nhdsGT_zero_mul_left","module":"Mathlib.Topology.Algebra.Order.Field","initialProofState":"𝕜 : Type u_1\ninst✝² : LinearOrderedField 𝕜\ninst✝¹ : TopologicalSpace 𝕜\ninst✝ : OrderTopology 𝕜\nx : 𝕜\nhx : LT.lt 0 x\np : 𝕜 → Prop\nh : Filter.Eventually (fun ε => p ε) (nhdsWithin 0 (Set.Ioi 0))\n⊢ Filter.Eventually (fun ε => p (HMul.hMul x ε)) (nhdsWithin 0 (Set.Ioi 0))","decl":"theorem eventually_nhdsGT_zero_mul_left {x : 𝕜} (hx : 0 < x) {p : 𝕜 → Prop}\n    (h : ∀ᶠ ε in 𝓝[>] 0, p ε) : ∀ᶠ ε in 𝓝[>] 0, p (x * ε) := by\n  rw [← comap_mulLeft_nhdsGT_zero hx]\n  exact h.comap fun ε => x * ε\n\n"}
{"name":"eventually_nhdsWithin_pos_mul_left","module":"Mathlib.Topology.Algebra.Order.Field","initialProofState":"𝕜 : Type u_1\ninst✝² : LinearOrderedField 𝕜\ninst✝¹ : TopologicalSpace 𝕜\ninst✝ : OrderTopology 𝕜\nx : 𝕜\nhx : LT.lt 0 x\np : 𝕜 → Prop\nh : Filter.Eventually (fun ε => p ε) (nhdsWithin 0 (Set.Ioi 0))\n⊢ Filter.Eventually (fun ε => p (HMul.hMul x ε)) (nhdsWithin 0 (Set.Ioi 0))","decl":"@[deprecated (since := \"2024-12-22\")]\nalias eventually_nhdsWithin_pos_mul_left := eventually_nhdsGT_zero_mul_left\n"}
