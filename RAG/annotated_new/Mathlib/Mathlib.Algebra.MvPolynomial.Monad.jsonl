{"name":"MvPolynomial.aeval_eq_bind₁","module":"Mathlib.Algebra.MvPolynomial.Monad","initialProofState":"σ : Type u_1\nτ : Type u_2\nR : Type u_3\ninst✝ : CommSemiring R\nf : σ → MvPolynomial τ R\n⊢ Eq (MvPolynomial.aeval f) (MvPolynomial.bind₁ f)","decl":"@[simp]\ntheorem aeval_eq_bind₁ (f : σ → MvPolynomial τ R) : aeval f = bind₁ f :=\n  rfl\n\n"}
{"name":"MvPolynomial.eval₂Hom_C_eq_bind₁","module":"Mathlib.Algebra.MvPolynomial.Monad","initialProofState":"σ : Type u_1\nτ : Type u_2\nR : Type u_3\ninst✝ : CommSemiring R\nf : σ → MvPolynomial τ R\n⊢ Eq (MvPolynomial.eval₂Hom MvPolynomial.C f) ↑(MvPolynomial.bind₁ f)","decl":"@[simp]\ntheorem eval₂Hom_C_eq_bind₁ (f : σ → MvPolynomial τ R) : eval₂Hom C f = bind₁ f :=\n  rfl\n\n"}
{"name":"MvPolynomial.eval₂Hom_eq_bind₂","module":"Mathlib.Algebra.MvPolynomial.Monad","initialProofState":"σ : Type u_1\nR : Type u_3\nS : Type u_4\ninst✝¹ : CommSemiring R\ninst✝ : CommSemiring S\nf : RingHom R (MvPolynomial σ S)\n⊢ Eq (MvPolynomial.eval₂Hom f MvPolynomial.X) (MvPolynomial.bind₂ f)","decl":"@[simp]\ntheorem eval₂Hom_eq_bind₂ (f : R →+* MvPolynomial σ S) : eval₂Hom f X = bind₂ f :=\n  rfl\n\n"}
{"name":"MvPolynomial.aeval_id_eq_join₁","module":"Mathlib.Algebra.MvPolynomial.Monad","initialProofState":"σ : Type u_1\nR : Type u_3\ninst✝ : CommSemiring R\n⊢ Eq (MvPolynomial.aeval id) MvPolynomial.join₁","decl":"@[simp]\ntheorem aeval_id_eq_join₁ : aeval id = @join₁ σ R _ :=\n  rfl\n\n"}
{"name":"MvPolynomial.eval₂Hom_C_id_eq_join₁","module":"Mathlib.Algebra.MvPolynomial.Monad","initialProofState":"σ : Type u_1\nR : Type u_3\ninst✝ : CommSemiring R\nφ : MvPolynomial (MvPolynomial σ R) R\n⊢ Eq ((MvPolynomial.eval₂Hom MvPolynomial.C id) φ) (MvPolynomial.join₁ φ)","decl":"theorem eval₂Hom_C_id_eq_join₁ (φ : MvPolynomial (MvPolynomial σ R) R) :\n    eval₂Hom C id φ = join₁ φ :=\n  rfl\n\n"}
{"name":"MvPolynomial.eval₂Hom_id_X_eq_join₂","module":"Mathlib.Algebra.MvPolynomial.Monad","initialProofState":"σ : Type u_1\nR : Type u_3\ninst✝ : CommSemiring R\n⊢ Eq (MvPolynomial.eval₂Hom (RingHom.id (MvPolynomial σ R)) MvPolynomial.X) MvPolynomial.join₂","decl":"@[simp]\ntheorem eval₂Hom_id_X_eq_join₂ : eval₂Hom (RingHom.id _) X = @join₂ σ R _ :=\n  rfl\n\n"}
{"name":"MvPolynomial.bind₁_X_right","module":"Mathlib.Algebra.MvPolynomial.Monad","initialProofState":"σ : Type u_1\nτ : Type u_2\nR : Type u_3\ninst✝ : CommSemiring R\nf : σ → MvPolynomial τ R\ni : σ\n⊢ Eq ((MvPolynomial.bind₁ f) (MvPolynomial.X i)) (f i)","decl":"@[simp]\ntheorem bind₁_X_right (f : σ → MvPolynomial τ R) (i : σ) : bind₁ f (X i) = f i :=\n  aeval_X f i\n\n"}
{"name":"MvPolynomial.bind₂_X_right","module":"Mathlib.Algebra.MvPolynomial.Monad","initialProofState":"σ : Type u_1\nR : Type u_3\nS : Type u_4\ninst✝¹ : CommSemiring R\ninst✝ : CommSemiring S\nf : RingHom R (MvPolynomial σ S)\ni : σ\n⊢ Eq ((MvPolynomial.bind₂ f) (MvPolynomial.X i)) (MvPolynomial.X i)","decl":"@[simp]\ntheorem bind₂_X_right (f : R →+* MvPolynomial σ S) (i : σ) : bind₂ f (X i) = X i :=\n  eval₂Hom_X' f X i\n\n"}
{"name":"MvPolynomial.bind₁_X_left","module":"Mathlib.Algebra.MvPolynomial.Monad","initialProofState":"σ : Type u_1\nR : Type u_3\ninst✝ : CommSemiring R\n⊢ Eq (MvPolynomial.bind₁ MvPolynomial.X) (AlgHom.id R (MvPolynomial σ R))","decl":"@[simp]\ntheorem bind₁_X_left : bind₁ (X : σ → MvPolynomial σ R) = AlgHom.id R _ := by\n  ext1 i\n  simp\n\n"}
{"name":"MvPolynomial.bind₁_C_right","module":"Mathlib.Algebra.MvPolynomial.Monad","initialProofState":"σ : Type u_1\nτ : Type u_2\nR : Type u_3\ninst✝ : CommSemiring R\nf : σ → MvPolynomial τ R\nx : R\n⊢ Eq ((MvPolynomial.bind₁ f) (MvPolynomial.C x)) (MvPolynomial.C x)","decl":"theorem bind₁_C_right (f : σ → MvPolynomial τ R) (x) : bind₁ f (C x) = C x := algHom_C _ _\n\n"}
{"name":"MvPolynomial.bind₂_C_right","module":"Mathlib.Algebra.MvPolynomial.Monad","initialProofState":"σ : Type u_1\nR : Type u_3\nS : Type u_4\ninst✝¹ : CommSemiring R\ninst✝ : CommSemiring S\nf : RingHom R (MvPolynomial σ S)\nr : R\n⊢ Eq ((MvPolynomial.bind₂ f) (MvPolynomial.C r)) (f r)","decl":"@[simp]\ntheorem bind₂_C_right (f : R →+* MvPolynomial σ S) (r : R) : bind₂ f (C r) = f r :=\n  eval₂Hom_C f X r\n\n"}
{"name":"MvPolynomial.bind₂_C_left","module":"Mathlib.Algebra.MvPolynomial.Monad","initialProofState":"σ : Type u_1\nR : Type u_3\ninst✝ : CommSemiring R\n⊢ Eq (MvPolynomial.bind₂ MvPolynomial.C) (RingHom.id (MvPolynomial σ R))","decl":"@[simp]\ntheorem bind₂_C_left : bind₂ (C : R →+* MvPolynomial σ R) = RingHom.id _ := by ext : 2 <;> simp\n\n"}
{"name":"MvPolynomial.bind₂_comp_C","module":"Mathlib.Algebra.MvPolynomial.Monad","initialProofState":"σ : Type u_1\nR : Type u_3\nS : Type u_4\ninst✝¹ : CommSemiring R\ninst✝ : CommSemiring S\nf : RingHom R (MvPolynomial σ S)\n⊢ Eq ((MvPolynomial.bind₂ f).comp MvPolynomial.C) f","decl":"@[simp]\ntheorem bind₂_comp_C (f : R →+* MvPolynomial σ S) : (bind₂ f).comp C = f :=\n  RingHom.ext <| bind₂_C_right _\n\n"}
{"name":"MvPolynomial.join₂_map","module":"Mathlib.Algebra.MvPolynomial.Monad","initialProofState":"σ : Type u_1\nR : Type u_3\nS : Type u_4\ninst✝¹ : CommSemiring R\ninst✝ : CommSemiring S\nf : RingHom R (MvPolynomial σ S)\nφ : MvPolynomial σ R\n⊢ Eq (MvPolynomial.join₂ ((MvPolynomial.map f) φ)) ((MvPolynomial.bind₂ f) φ)","decl":"@[simp]\ntheorem join₂_map (f : R →+* MvPolynomial σ S) (φ : MvPolynomial σ R) :\n    join₂ (map f φ) = bind₂ f φ := by simp only [join₂, bind₂, eval₂Hom_map_hom, RingHom.id_comp]\n\n"}
{"name":"MvPolynomial.join₂_comp_map","module":"Mathlib.Algebra.MvPolynomial.Monad","initialProofState":"σ : Type u_1\nR : Type u_3\nS : Type u_4\ninst✝¹ : CommSemiring R\ninst✝ : CommSemiring S\nf : RingHom R (MvPolynomial σ S)\n⊢ Eq (MvPolynomial.join₂.comp (MvPolynomial.map f)) (MvPolynomial.bind₂ f)","decl":"@[simp]\ntheorem join₂_comp_map (f : R →+* MvPolynomial σ S) : join₂.comp (map f) = bind₂ f :=\n  RingHom.ext <| join₂_map _\n\n"}
{"name":"MvPolynomial.aeval_id_rename","module":"Mathlib.Algebra.MvPolynomial.Monad","initialProofState":"σ : Type u_1\nτ : Type u_2\nR : Type u_3\ninst✝ : CommSemiring R\nf : σ → MvPolynomial τ R\np : MvPolynomial σ R\n⊢ Eq ((MvPolynomial.aeval id) ((MvPolynomial.rename f) p)) ((MvPolynomial.aeval f) p)","decl":"theorem aeval_id_rename (f : σ → MvPolynomial τ R) (p : MvPolynomial σ R) :\n    aeval id (rename f p) = aeval f p := by rw [aeval_rename, Function.id_comp]\n\n"}
{"name":"MvPolynomial.join₁_rename","module":"Mathlib.Algebra.MvPolynomial.Monad","initialProofState":"σ : Type u_1\nτ : Type u_2\nR : Type u_3\ninst✝ : CommSemiring R\nf : σ → MvPolynomial τ R\nφ : MvPolynomial σ R\n⊢ Eq (MvPolynomial.join₁ ((MvPolynomial.rename f) φ)) ((MvPolynomial.bind₁ f) φ)","decl":"@[simp]\ntheorem join₁_rename (f : σ → MvPolynomial τ R) (φ : MvPolynomial σ R) :\n    join₁ (rename f φ) = bind₁ f φ :=\n  aeval_id_rename _ _\n\n"}
{"name":"MvPolynomial.bind₁_id","module":"Mathlib.Algebra.MvPolynomial.Monad","initialProofState":"σ : Type u_1\nR : Type u_3\ninst✝ : CommSemiring R\n⊢ Eq (MvPolynomial.bind₁ id) MvPolynomial.join₁","decl":"@[simp]\ntheorem bind₁_id : bind₁ (@id (MvPolynomial σ R)) = join₁ :=\n  rfl\n\n"}
{"name":"MvPolynomial.bind₂_id","module":"Mathlib.Algebra.MvPolynomial.Monad","initialProofState":"σ : Type u_1\nR : Type u_3\ninst✝ : CommSemiring R\n⊢ Eq (MvPolynomial.bind₂ (RingHom.id (MvPolynomial σ R))) MvPolynomial.join₂","decl":"@[simp]\ntheorem bind₂_id : bind₂ (RingHom.id (MvPolynomial σ R)) = join₂ :=\n  rfl\n\n"}
{"name":"MvPolynomial.bind₁_bind₁","module":"Mathlib.Algebra.MvPolynomial.Monad","initialProofState":"σ : Type u_1\nτ : Type u_2\nR : Type u_3\ninst✝ : CommSemiring R\nυ : Type u_6\nf : σ → MvPolynomial τ R\ng : τ → MvPolynomial υ R\nφ : MvPolynomial σ R\n⊢ Eq ((MvPolynomial.bind₁ g) ((MvPolynomial.bind₁ f) φ)) ((MvPolynomial.bind₁ fun i => (MvPolynomial.bind₁ g) (f i)) φ)","decl":"theorem bind₁_bind₁ {υ : Type*} (f : σ → MvPolynomial τ R) (g : τ → MvPolynomial υ R)\n    (φ : MvPolynomial σ R) : (bind₁ g) (bind₁ f φ) = bind₁ (fun i => bind₁ g (f i)) φ := by\n  simp [bind₁, ← comp_aeval]\n\n"}
{"name":"MvPolynomial.bind₁_comp_bind₁","module":"Mathlib.Algebra.MvPolynomial.Monad","initialProofState":"σ : Type u_1\nτ : Type u_2\nR : Type u_3\ninst✝ : CommSemiring R\nυ : Type u_6\nf : σ → MvPolynomial τ R\ng : τ → MvPolynomial υ R\n⊢ Eq ((MvPolynomial.bind₁ g).comp (MvPolynomial.bind₁ f)) (MvPolynomial.bind₁ fun i => (MvPolynomial.bind₁ g) (f i))","decl":"theorem bind₁_comp_bind₁ {υ : Type*} (f : σ → MvPolynomial τ R) (g : τ → MvPolynomial υ R) :\n    (bind₁ g).comp (bind₁ f) = bind₁ fun i => bind₁ g (f i) := by\n  ext1\n  apply bind₁_bind₁\n\n"}
{"name":"MvPolynomial.bind₂_comp_bind₂","module":"Mathlib.Algebra.MvPolynomial.Monad","initialProofState":"σ : Type u_1\nR : Type u_3\nS : Type u_4\nT : Type u_5\ninst✝² : CommSemiring R\ninst✝¹ : CommSemiring S\ninst✝ : CommSemiring T\nf : RingHom R (MvPolynomial σ S)\ng : RingHom S (MvPolynomial σ T)\n⊢ Eq ((MvPolynomial.bind₂ g).comp (MvPolynomial.bind₂ f)) (MvPolynomial.bind₂ ((MvPolynomial.bind₂ g).comp f))","decl":"theorem bind₂_comp_bind₂ (f : R →+* MvPolynomial σ S) (g : S →+* MvPolynomial σ T) :\n    (bind₂ g).comp (bind₂ f) = bind₂ ((bind₂ g).comp f) := by ext : 2 <;> simp\n\n"}
{"name":"MvPolynomial.bind₂_bind₂","module":"Mathlib.Algebra.MvPolynomial.Monad","initialProofState":"σ : Type u_1\nR : Type u_3\nS : Type u_4\nT : Type u_5\ninst✝² : CommSemiring R\ninst✝¹ : CommSemiring S\ninst✝ : CommSemiring T\nf : RingHom R (MvPolynomial σ S)\ng : RingHom S (MvPolynomial σ T)\nφ : MvPolynomial σ R\n⊢ Eq ((MvPolynomial.bind₂ g) ((MvPolynomial.bind₂ f) φ)) ((MvPolynomial.bind₂ ((MvPolynomial.bind₂ g).comp f)) φ)","decl":"theorem bind₂_bind₂ (f : R →+* MvPolynomial σ S) (g : S →+* MvPolynomial σ T)\n    (φ : MvPolynomial σ R) : (bind₂ g) (bind₂ f φ) = bind₂ ((bind₂ g).comp f) φ :=\n  RingHom.congr_fun (bind₂_comp_bind₂ f g) φ\n\n"}
{"name":"MvPolynomial.rename_comp_bind₁","module":"Mathlib.Algebra.MvPolynomial.Monad","initialProofState":"σ : Type u_1\nτ : Type u_2\nR : Type u_3\ninst✝ : CommSemiring R\nυ : Type u_6\nf : σ → MvPolynomial τ R\ng : τ → υ\n⊢ Eq ((MvPolynomial.rename g).comp (MvPolynomial.bind₁ f)) (MvPolynomial.bind₁ fun i => (MvPolynomial.rename g) (f i))","decl":"theorem rename_comp_bind₁ {υ : Type*} (f : σ → MvPolynomial τ R) (g : τ → υ) :\n    (rename g).comp (bind₁ f) = bind₁ fun i => rename g <| f i := by\n  ext1 i\n  simp\n\n"}
{"name":"MvPolynomial.rename_bind₁","module":"Mathlib.Algebra.MvPolynomial.Monad","initialProofState":"σ : Type u_1\nτ : Type u_2\nR : Type u_3\ninst✝ : CommSemiring R\nυ : Type u_6\nf : σ → MvPolynomial τ R\ng : τ → υ\nφ : MvPolynomial σ R\n⊢ Eq ((MvPolynomial.rename g) ((MvPolynomial.bind₁ f) φ)) ((MvPolynomial.bind₁ fun i => (MvPolynomial.rename g) (f i)) φ)","decl":"theorem rename_bind₁ {υ : Type*} (f : σ → MvPolynomial τ R) (g : τ → υ) (φ : MvPolynomial σ R) :\n    rename g (bind₁ f φ) = bind₁ (fun i => rename g <| f i) φ :=\n  AlgHom.congr_fun (rename_comp_bind₁ f g) φ\n\n"}
{"name":"MvPolynomial.map_bind₂","module":"Mathlib.Algebra.MvPolynomial.Monad","initialProofState":"σ : Type u_1\nR : Type u_3\nS : Type u_4\nT : Type u_5\ninst✝² : CommSemiring R\ninst✝¹ : CommSemiring S\ninst✝ : CommSemiring T\nf : RingHom R (MvPolynomial σ S)\ng : RingHom S T\nφ : MvPolynomial σ R\n⊢ Eq ((MvPolynomial.map g) ((MvPolynomial.bind₂ f) φ)) ((MvPolynomial.bind₂ ((MvPolynomial.map g).comp f)) φ)","decl":"theorem map_bind₂ (f : R →+* MvPolynomial σ S) (g : S →+* T) (φ : MvPolynomial σ R) :\n    map g (bind₂ f φ) = bind₂ ((map g).comp f) φ := by\n  simp only [bind₂, eval₂_comp_right, coe_eval₂Hom, eval₂_map]\n  congr 1 with : 1\n  simp only [Function.comp_apply, map_X]\n\n"}
{"name":"MvPolynomial.bind₁_comp_rename","module":"Mathlib.Algebra.MvPolynomial.Monad","initialProofState":"σ : Type u_1\nτ : Type u_2\nR : Type u_3\ninst✝ : CommSemiring R\nυ : Type u_6\nf : τ → MvPolynomial υ R\ng : σ → τ\n⊢ Eq ((MvPolynomial.bind₁ f).comp (MvPolynomial.rename g)) (MvPolynomial.bind₁ (Function.comp f g))","decl":"theorem bind₁_comp_rename {υ : Type*} (f : τ → MvPolynomial υ R) (g : σ → τ) :\n    (bind₁ f).comp (rename g) = bind₁ (f ∘ g) := by\n  ext1 i\n  simp\n\n"}
{"name":"MvPolynomial.bind₁_rename","module":"Mathlib.Algebra.MvPolynomial.Monad","initialProofState":"σ : Type u_1\nτ : Type u_2\nR : Type u_3\ninst✝ : CommSemiring R\nυ : Type u_6\nf : τ → MvPolynomial υ R\ng : σ → τ\nφ : MvPolynomial σ R\n⊢ Eq ((MvPolynomial.bind₁ f) ((MvPolynomial.rename g) φ)) ((MvPolynomial.bind₁ (Function.comp f g)) φ)","decl":"theorem bind₁_rename {υ : Type*} (f : τ → MvPolynomial υ R) (g : σ → τ) (φ : MvPolynomial σ R) :\n    bind₁ f (rename g φ) = bind₁ (f ∘ g) φ :=\n  AlgHom.congr_fun (bind₁_comp_rename f g) φ\n\n"}
{"name":"MvPolynomial.bind₂_map","module":"Mathlib.Algebra.MvPolynomial.Monad","initialProofState":"σ : Type u_1\nR : Type u_3\nS : Type u_4\nT : Type u_5\ninst✝² : CommSemiring R\ninst✝¹ : CommSemiring S\ninst✝ : CommSemiring T\nf : RingHom S (MvPolynomial σ T)\ng : RingHom R S\nφ : MvPolynomial σ R\n⊢ Eq ((MvPolynomial.bind₂ f) ((MvPolynomial.map g) φ)) ((MvPolynomial.bind₂ (f.comp g)) φ)","decl":"theorem bind₂_map (f : S →+* MvPolynomial σ T) (g : R →+* S) (φ : MvPolynomial σ R) :\n    bind₂ f (map g φ) = bind₂ (f.comp g) φ := by simp [bind₂]\n\n"}
{"name":"MvPolynomial.map_comp_C","module":"Mathlib.Algebra.MvPolynomial.Monad","initialProofState":"σ : Type u_1\nR : Type u_3\nS : Type u_4\ninst✝¹ : CommSemiring R\ninst✝ : CommSemiring S\nf : RingHom R S\n⊢ Eq ((MvPolynomial.map f).comp MvPolynomial.C) (MvPolynomial.C.comp f)","decl":"@[simp]\ntheorem map_comp_C (f : R →+* S) : (map f).comp (C : R →+* MvPolynomial σ R) = C.comp f := by\n  ext1\n  apply map_C\n\n-- mixing the two monad structures\n"}
{"name":"MvPolynomial.hom_bind₁","module":"Mathlib.Algebra.MvPolynomial.Monad","initialProofState":"σ : Type u_1\nτ : Type u_2\nR : Type u_3\nS : Type u_4\ninst✝¹ : CommSemiring R\ninst✝ : CommSemiring S\nf : RingHom (MvPolynomial τ R) S\ng : σ → MvPolynomial τ R\nφ : MvPolynomial σ R\n⊢ Eq (f ((MvPolynomial.bind₁ g) φ)) ((MvPolynomial.eval₂Hom (f.comp MvPolynomial.C) fun i => f (g i)) φ)","decl":"theorem hom_bind₁ (f : MvPolynomial τ R →+* S) (g : σ → MvPolynomial τ R) (φ : MvPolynomial σ R) :\n    f (bind₁ g φ) = eval₂Hom (f.comp C) (fun i => f (g i)) φ := by\n  rw [bind₁, map_aeval, algebraMap_eq]\n\n"}
{"name":"MvPolynomial.map_bind₁","module":"Mathlib.Algebra.MvPolynomial.Monad","initialProofState":"σ : Type u_1\nτ : Type u_2\nR : Type u_3\nS : Type u_4\ninst✝¹ : CommSemiring R\ninst✝ : CommSemiring S\nf : RingHom R S\ng : σ → MvPolynomial τ R\nφ : MvPolynomial σ R\n⊢ Eq ((MvPolynomial.map f) ((MvPolynomial.bind₁ g) φ)) ((MvPolynomial.bind₁ fun i => (MvPolynomial.map f) (g i)) ((MvPolynomial.map f) φ))","decl":"theorem map_bind₁ (f : R →+* S) (g : σ → MvPolynomial τ R) (φ : MvPolynomial σ R) :\n    map f (bind₁ g φ) = bind₁ (fun i : σ => (map f) (g i)) (map f φ) := by\n  rw [hom_bind₁, map_comp_C, ← eval₂Hom_map_hom]\n  rfl\n\n"}
{"name":"MvPolynomial.eval₂Hom_comp_C","module":"Mathlib.Algebra.MvPolynomial.Monad","initialProofState":"σ : Type u_1\nR : Type u_3\nS : Type u_4\ninst✝¹ : CommSemiring R\ninst✝ : CommSemiring S\nf : RingHom R S\ng : σ → S\n⊢ Eq ((MvPolynomial.eval₂Hom f g).comp MvPolynomial.C) f","decl":"@[simp]\ntheorem eval₂Hom_comp_C (f : R →+* S) (g : σ → S) : (eval₂Hom f g).comp C = f := by\n  ext1 r\n  exact eval₂_C f g r\n\n"}
{"name":"MvPolynomial.eval₂Hom_bind₁","module":"Mathlib.Algebra.MvPolynomial.Monad","initialProofState":"σ : Type u_1\nτ : Type u_2\nR : Type u_3\nS : Type u_4\ninst✝¹ : CommSemiring R\ninst✝ : CommSemiring S\nf : RingHom R S\ng : τ → S\nh : σ → MvPolynomial τ R\nφ : MvPolynomial σ R\n⊢ Eq ((MvPolynomial.eval₂Hom f g) ((MvPolynomial.bind₁ h) φ)) ((MvPolynomial.eval₂Hom f fun i => (MvPolynomial.eval₂Hom f g) (h i)) φ)","decl":"theorem eval₂Hom_bind₁ (f : R →+* S) (g : τ → S) (h : σ → MvPolynomial τ R) (φ : MvPolynomial σ R) :\n    eval₂Hom f g (bind₁ h φ) = eval₂Hom f (fun i => eval₂Hom f g (h i)) φ := by\n  rw [hom_bind₁, eval₂Hom_comp_C]\n\n"}
{"name":"MvPolynomial.aeval_bind₁","module":"Mathlib.Algebra.MvPolynomial.Monad","initialProofState":"σ : Type u_1\nτ : Type u_2\nR : Type u_3\nS : Type u_4\ninst✝² : CommSemiring R\ninst✝¹ : CommSemiring S\ninst✝ : Algebra R S\nf : τ → S\ng : σ → MvPolynomial τ R\nφ : MvPolynomial σ R\n⊢ Eq ((MvPolynomial.aeval f) ((MvPolynomial.bind₁ g) φ)) ((MvPolynomial.aeval fun i => (MvPolynomial.aeval f) (g i)) φ)","decl":"theorem aeval_bind₁ [Algebra R S] (f : τ → S) (g : σ → MvPolynomial τ R) (φ : MvPolynomial σ R) :\n    aeval f (bind₁ g φ) = aeval (fun i => aeval f (g i)) φ :=\n  eval₂Hom_bind₁ _ _ _ _\n\n"}
{"name":"MvPolynomial.aeval_comp_bind₁","module":"Mathlib.Algebra.MvPolynomial.Monad","initialProofState":"σ : Type u_1\nτ : Type u_2\nR : Type u_3\nS : Type u_4\ninst✝² : CommSemiring R\ninst✝¹ : CommSemiring S\ninst✝ : Algebra R S\nf : τ → S\ng : σ → MvPolynomial τ R\n⊢ Eq ((MvPolynomial.aeval f).comp (MvPolynomial.bind₁ g)) (MvPolynomial.aeval fun i => (MvPolynomial.aeval f) (g i))","decl":"theorem aeval_comp_bind₁ [Algebra R S] (f : τ → S) (g : σ → MvPolynomial τ R) :\n    (aeval f).comp (bind₁ g) = aeval fun i => aeval f (g i) := by\n  ext1\n  apply aeval_bind₁\n\n"}
{"name":"MvPolynomial.eval₂Hom_comp_bind₂","module":"Mathlib.Algebra.MvPolynomial.Monad","initialProofState":"σ : Type u_1\nR : Type u_3\nS : Type u_4\nT : Type u_5\ninst✝² : CommSemiring R\ninst✝¹ : CommSemiring S\ninst✝ : CommSemiring T\nf : RingHom S T\ng : σ → T\nh : RingHom R (MvPolynomial σ S)\n⊢ Eq ((MvPolynomial.eval₂Hom f g).comp (MvPolynomial.bind₂ h)) (MvPolynomial.eval₂Hom ((MvPolynomial.eval₂Hom f g).comp h) g)","decl":"theorem eval₂Hom_comp_bind₂ (f : S →+* T) (g : σ → T) (h : R →+* MvPolynomial σ S) :\n    (eval₂Hom f g).comp (bind₂ h) = eval₂Hom ((eval₂Hom f g).comp h) g := by ext : 2 <;> simp\n\n"}
{"name":"MvPolynomial.eval₂Hom_bind₂","module":"Mathlib.Algebra.MvPolynomial.Monad","initialProofState":"σ : Type u_1\nR : Type u_3\nS : Type u_4\nT : Type u_5\ninst✝² : CommSemiring R\ninst✝¹ : CommSemiring S\ninst✝ : CommSemiring T\nf : RingHom S T\ng : σ → T\nh : RingHom R (MvPolynomial σ S)\nφ : MvPolynomial σ R\n⊢ Eq ((MvPolynomial.eval₂Hom f g) ((MvPolynomial.bind₂ h) φ)) ((MvPolynomial.eval₂Hom ((MvPolynomial.eval₂Hom f g).comp h) g) φ)","decl":"theorem eval₂Hom_bind₂ (f : S →+* T) (g : σ → T) (h : R →+* MvPolynomial σ S)\n    (φ : MvPolynomial σ R) : eval₂Hom f g (bind₂ h φ) = eval₂Hom ((eval₂Hom f g).comp h) g φ :=\n  RingHom.congr_fun (eval₂Hom_comp_bind₂ f g h) φ\n\n"}
{"name":"MvPolynomial.aeval_bind₂","module":"Mathlib.Algebra.MvPolynomial.Monad","initialProofState":"σ : Type u_1\nR : Type u_3\nS : Type u_4\nT : Type u_5\ninst✝³ : CommSemiring R\ninst✝² : CommSemiring S\ninst✝¹ : CommSemiring T\ninst✝ : Algebra S T\nf : σ → T\ng : RingHom R (MvPolynomial σ S)\nφ : MvPolynomial σ R\n⊢ Eq ((MvPolynomial.aeval f) ((MvPolynomial.bind₂ g) φ)) ((MvPolynomial.eval₂Hom ((↑(MvPolynomial.aeval f)).comp g) f) φ)","decl":"theorem aeval_bind₂ [Algebra S T] (f : σ → T) (g : R →+* MvPolynomial σ S) (φ : MvPolynomial σ R) :\n    aeval f (bind₂ g φ) = eval₂Hom ((↑(aeval f : _ →ₐ[S] _) : _ →+* _).comp g) f φ :=\n  eval₂Hom_bind₂ _ _ _ _\n\n"}
{"name":"MvPolynomial.eval₂Hom_C_left","module":"Mathlib.Algebra.MvPolynomial.Monad","initialProofState":"σ : Type u_1\nτ : Type u_2\nR : Type u_3\ninst✝ : CommSemiring R\nf : σ → MvPolynomial τ R\n⊢ Eq (MvPolynomial.eval₂Hom MvPolynomial.C f) ↑(MvPolynomial.bind₁ f)","decl":"alias eval₂Hom_C_left := eval₂Hom_C_eq_bind₁\n\n"}
{"name":"MvPolynomial.bind₁_monomial","module":"Mathlib.Algebra.MvPolynomial.Monad","initialProofState":"σ : Type u_1\nτ : Type u_2\nR : Type u_3\ninst✝ : CommSemiring R\nf : σ → MvPolynomial τ R\nd : Finsupp σ Nat\nr : R\n⊢ Eq ((MvPolynomial.bind₁ f) ((MvPolynomial.monomial d) r)) (HMul.hMul (MvPolynomial.C r) (d.support.prod fun i => HPow.hPow (f i) (d i)))","decl":"theorem bind₁_monomial (f : σ → MvPolynomial τ R) (d : σ →₀ ℕ) (r : R) :\n    bind₁ f (monomial d r) = C r * ∏ i ∈ d.support, f i ^ d i := by\n  simp only [monomial_eq, map_mul, bind₁_C_right, Finsupp.prod, map_prod,\n    map_pow, bind₁_X_right]\n\n"}
{"name":"MvPolynomial.bind₂_monomial","module":"Mathlib.Algebra.MvPolynomial.Monad","initialProofState":"σ : Type u_1\nR : Type u_3\nS : Type u_4\ninst✝¹ : CommSemiring R\ninst✝ : CommSemiring S\nf : RingHom R (MvPolynomial σ S)\nd : Finsupp σ Nat\nr : R\n⊢ Eq ((MvPolynomial.bind₂ f) ((MvPolynomial.monomial d) r)) (HMul.hMul (f r) ((MvPolynomial.monomial d) 1))","decl":"theorem bind₂_monomial (f : R →+* MvPolynomial σ S) (d : σ →₀ ℕ) (r : R) :\n    bind₂ f (monomial d r) = f r * monomial d 1 := by\n  simp only [monomial_eq, RingHom.map_mul, bind₂_C_right, Finsupp.prod, map_prod,\n    map_pow, bind₂_X_right, C_1, one_mul]\n\n"}
{"name":"MvPolynomial.bind₂_monomial_one","module":"Mathlib.Algebra.MvPolynomial.Monad","initialProofState":"σ : Type u_1\nR : Type u_3\nS : Type u_4\ninst✝¹ : CommSemiring R\ninst✝ : CommSemiring S\nf : RingHom R (MvPolynomial σ S)\nd : Finsupp σ Nat\n⊢ Eq ((MvPolynomial.bind₂ f) ((MvPolynomial.monomial d) 1)) ((MvPolynomial.monomial d) 1)","decl":"@[simp]\ntheorem bind₂_monomial_one (f : R →+* MvPolynomial σ S) (d : σ →₀ ℕ) :\n    bind₂ f (monomial d 1) = monomial d 1 := by rw [bind₂_monomial, f.map_one, one_mul]\n\n"}
{"name":"MvPolynomial.vars_bind₁","module":"Mathlib.Algebra.MvPolynomial.Monad","initialProofState":"σ : Type u_1\nτ : Type u_2\nR : Type u_3\ninst✝¹ : CommSemiring R\ninst✝ : DecidableEq τ\nf : σ → MvPolynomial τ R\nφ : MvPolynomial σ R\n⊢ HasSubset.Subset ((MvPolynomial.bind₁ f) φ).vars (φ.vars.biUnion fun i => (f i).vars)","decl":"theorem vars_bind₁ [DecidableEq τ] (f : σ → MvPolynomial τ R) (φ : MvPolynomial σ R) :\n    (bind₁ f φ).vars ⊆ φ.vars.biUnion fun i => (f i).vars := by\n  calc (bind₁ f φ).vars\n    _ = (φ.support.sum fun x : σ →₀ ℕ => (bind₁ f) (monomial x (coeff x φ))).vars := by\n      rw [← map_sum, ← φ.as_sum]\n    _ ≤ φ.support.biUnion fun i : σ →₀ ℕ => ((bind₁ f) (monomial i (coeff i φ))).vars :=\n      (vars_sum_subset _ _)\n    _ = φ.support.biUnion fun d : σ →₀ ℕ => vars (C (coeff d φ) * ∏ i ∈ d.support, f i ^ d i) := by\n      simp only [bind₁_monomial]\n    _ ≤ φ.support.biUnion fun d : σ →₀ ℕ => d.support.biUnion fun i => vars (f i) := ?_\n    -- proof below\n    _ ≤ φ.vars.biUnion fun i : σ => vars (f i) := ?_\n    -- proof below\n  · apply Finset.biUnion_mono\n    intro d _hd\n    calc\n      vars (C (coeff d φ) * ∏ i ∈ d.support, f i ^ d i) ≤\n          (C (coeff d φ)).vars ∪ (∏ i ∈ d.support, f i ^ d i).vars :=\n        vars_mul _ _\n      _ ≤ (∏ i ∈ d.support, f i ^ d i).vars := by\n        simp only [Finset.empty_union, vars_C, Finset.le_iff_subset, Finset.Subset.refl]\n      _ ≤ d.support.biUnion fun i : σ => vars (f i ^ d i) := vars_prod _\n      _ ≤ d.support.biUnion fun i : σ => (f i).vars := ?_\n    apply Finset.biUnion_mono\n    intro i _hi\n    apply vars_pow\n  · intro j\n    simp_rw [Finset.mem_biUnion]\n    rintro ⟨d, hd, ⟨i, hi, hj⟩⟩\n    exact ⟨i, (mem_vars _).mpr ⟨d, hd, hi⟩, hj⟩\n\n"}
{"name":"MvPolynomial.mem_vars_bind₁","module":"Mathlib.Algebra.MvPolynomial.Monad","initialProofState":"σ : Type u_1\nτ : Type u_2\nR : Type u_3\ninst✝ : CommSemiring R\nf : σ → MvPolynomial τ R\nφ : MvPolynomial σ R\nj : τ\nh : Membership.mem ((MvPolynomial.bind₁ f) φ).vars j\n⊢ Exists fun i => And (Membership.mem φ.vars i) (Membership.mem (f i).vars j)","decl":"theorem mem_vars_bind₁ (f : σ → MvPolynomial τ R) (φ : MvPolynomial σ R) {j : τ}\n    (h : j ∈ (bind₁ f φ).vars) : ∃ i : σ, i ∈ φ.vars ∧ j ∈ (f i).vars := by\n  classical\n  simpa only [exists_prop, Finset.mem_biUnion, mem_support_iff, Ne] using vars_bind₁ f φ h\n\n"}
{"name":"MvPolynomial.lawfulFunctor","module":"Mathlib.Algebra.MvPolynomial.Monad","initialProofState":"R : Type u_3\ninst✝ : CommSemiring R\n⊢ LawfulFunctor fun σ => MvPolynomial σ R","decl":"instance lawfulFunctor : LawfulFunctor fun σ => MvPolynomial σ R where\n  map_const := by intros; rfl\n  -- Porting note: I guess `map_const` no longer has a default implementation?\n  id_map := by intros; simp [(· <$> ·)]\n  comp_map := by intros; simp [(· <$> ·)]\n\n"}
{"name":"MvPolynomial.lawfulMonad","module":"Mathlib.Algebra.MvPolynomial.Monad","initialProofState":"R : Type u_3\ninst✝ : CommSemiring R\n⊢ LawfulMonad fun σ => MvPolynomial σ R","decl":"instance lawfulMonad : LawfulMonad fun σ => MvPolynomial σ R where\n  pure_bind := by intros; simp [pure, bind]\n  bind_assoc := by intros; simp [bind, ← bind₁_comp_bind₁]\n  seqLeft_eq := by intros; simp [SeqLeft.seqLeft, Seq.seq, (· <$> ·), bind₁_rename]; rfl\n  seqRight_eq := by intros; simp [SeqRight.seqRight, Seq.seq, (· <$> ·), bind₁_rename]; rfl\n  pure_seq := by intros; simp [(· <$> ·), pure, Seq.seq]\n  bind_pure_comp := by aesop\n  bind_map := by aesop\n\n/-\nPossible TODO for the future:\nEnable the following definitions, and write a lot of supporting lemmas.\n\ndef bind (f : R →+* mv_polynomial τ S) (g : σ → mv_polynomial τ S) :\n    mv_polynomial σ R →+* mv_polynomial τ S :=\n  eval₂_hom f g\n\ndef join (f : R →+* S) : mv_polynomial (mv_polynomial σ R) S →ₐ[S] mv_polynomial σ S :=\n  aeval (map f)\n\ndef ajoin [algebra R S] : mv_polynomial (mv_polynomial σ R) S →ₐ[S] mv_polynomial σ S :=\n  join (algebra_map R S)\n\n-/\n"}
