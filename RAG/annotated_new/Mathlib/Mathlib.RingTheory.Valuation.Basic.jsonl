{"name":"Valuation.mk.sizeOf_spec","module":"Mathlib.RingTheory.Valuation.Basic","initialProofState":"R : Type u_3\nΓ₀ : Type u_4\ninst✝³ : LinearOrderedCommMonoidWithZero Γ₀\ninst✝² : Ring R\ninst✝¹ : SizeOf R\ninst✝ : SizeOf Γ₀\ntoMonoidWithZeroHom : MonoidWithZeroHom R Γ₀\nmap_add_le_max' : ∀ (x y : R), LE.le ((↑toMonoidWithZeroHom).toFun (HAdd.hAdd x y)) (Max.max ((↑toMonoidWithZeroHom).toFun x) ((↑toMonoidWithZeroHom).toFun y))\n⊢ Eq (SizeOf.sizeOf { toMonoidWithZeroHom := toMonoidWithZeroHom, map_add_le_max' := map_add_le_max' }) (HAdd.hAdd 1 (SizeOf.sizeOf toMonoidWithZeroHom))","decl":"/-- The type of `Γ₀`-valued valuations on `R`.\n\nWhen you extend this structure, make sure to extend `ValuationClass`. -/\nstructure Valuation extends R →*₀ Γ₀ where\n  /-- The valuation of a a sum is less that the sum of the valuations -/\n  map_add_le_max' : ∀ x y, toFun (x + y) ≤ max (toFun x) (toFun y)\n\n"}
{"name":"Valuation.mk.inj","module":"Mathlib.RingTheory.Valuation.Basic","initialProofState":"R : Type u_3\nΓ₀ : Type u_4\ninst✝¹ : LinearOrderedCommMonoidWithZero Γ₀\ninst✝ : Ring R\ntoMonoidWithZeroHom✝ : MonoidWithZeroHom R Γ₀\nmap_add_le_max'✝ : ∀ (x y : R), LE.le ((↑toMonoidWithZeroHom✝).toFun (HAdd.hAdd x y)) (Max.max ((↑toMonoidWithZeroHom✝).toFun x) ((↑toMonoidWithZeroHom✝).toFun y))\ntoMonoidWithZeroHom : MonoidWithZeroHom R Γ₀\nmap_add_le_max' : ∀ (x y : R), LE.le ((↑toMonoidWithZeroHom).toFun (HAdd.hAdd x y)) (Max.max ((↑toMonoidWithZeroHom).toFun x) ((↑toMonoidWithZeroHom).toFun y))\nx✝ : Eq { toMonoidWithZeroHom := toMonoidWithZeroHom✝, map_add_le_max' := map_add_le_max'✝ } { toMonoidWithZeroHom := toMonoidWithZeroHom, map_add_le_max' := map_add_le_max' }\n⊢ Eq toMonoidWithZeroHom✝ toMonoidWithZeroHom","decl":"/-- The type of `Γ₀`-valued valuations on `R`.\n\nWhen you extend this structure, make sure to extend `ValuationClass`. -/\nstructure Valuation extends R →*₀ Γ₀ where\n  /-- The valuation of a a sum is less that the sum of the valuations -/\n  map_add_le_max' : ∀ x y, toFun (x + y) ≤ max (toFun x) (toFun y)\n\n"}
{"name":"Valuation.map_add_le_max'","module":"Mathlib.RingTheory.Valuation.Basic","initialProofState":"R : Type u_3\nΓ₀ : Type u_4\ninst✝¹ : LinearOrderedCommMonoidWithZero Γ₀\ninst✝ : Ring R\nself : Valuation R Γ₀\nx y : R\n⊢ LE.le ((↑self.toMonoidWithZeroHom).toFun (HAdd.hAdd x y)) (Max.max ((↑self.toMonoidWithZeroHom).toFun x) ((↑self.toMonoidWithZeroHom).toFun y))","decl":"/-- The type of `Γ₀`-valued valuations on `R`.\n\nWhen you extend this structure, make sure to extend `ValuationClass`. -/\nstructure Valuation extends R →*₀ Γ₀ where\n  /-- The valuation of a a sum is less that the sum of the valuations -/\n  map_add_le_max' : ∀ x y, toFun (x + y) ≤ max (toFun x) (toFun y)\n\n"}
{"name":"Valuation.mk.injEq","module":"Mathlib.RingTheory.Valuation.Basic","initialProofState":"R : Type u_3\nΓ₀ : Type u_4\ninst✝¹ : LinearOrderedCommMonoidWithZero Γ₀\ninst✝ : Ring R\ntoMonoidWithZeroHom✝ : MonoidWithZeroHom R Γ₀\nmap_add_le_max'✝ : ∀ (x y : R), LE.le ((↑toMonoidWithZeroHom✝).toFun (HAdd.hAdd x y)) (Max.max ((↑toMonoidWithZeroHom✝).toFun x) ((↑toMonoidWithZeroHom✝).toFun y))\ntoMonoidWithZeroHom : MonoidWithZeroHom R Γ₀\nmap_add_le_max' : ∀ (x y : R), LE.le ((↑toMonoidWithZeroHom).toFun (HAdd.hAdd x y)) (Max.max ((↑toMonoidWithZeroHom).toFun x) ((↑toMonoidWithZeroHom).toFun y))\n⊢ Eq (Eq { toMonoidWithZeroHom := toMonoidWithZeroHom✝, map_add_le_max' := map_add_le_max'✝ } { toMonoidWithZeroHom := toMonoidWithZeroHom, map_add_le_max' := map_add_le_max' }) (Eq toMonoidWithZeroHom✝ toMonoidWithZeroHom)","decl":"/-- The type of `Γ₀`-valued valuations on `R`.\n\nWhen you extend this structure, make sure to extend `ValuationClass`. -/\nstructure Valuation extends R →*₀ Γ₀ where\n  /-- The valuation of a a sum is less that the sum of the valuations -/\n  map_add_le_max' : ∀ x y, toFun (x + y) ≤ max (toFun x) (toFun y)\n\n"}
{"name":"ValuationClass.map_add_le_max","module":"Mathlib.RingTheory.Valuation.Basic","initialProofState":"F : Type u_7\nR : outParam (Type u_5)\nΓ₀ : outParam (Type u_6)\ninst✝² : LinearOrderedCommMonoidWithZero Γ₀\ninst✝¹ : Ring R\ninst✝ : FunLike F R Γ₀\nself : ValuationClass F R Γ₀\nf : F\nx y : R\n⊢ LE.le (f (HAdd.hAdd x y)) (Max.max (f x) (f y))","decl":"/-- `ValuationClass F α β` states that `F` is a type of valuations.\n\nYou should also extend this typeclass when you extend `Valuation`. -/\nclass ValuationClass (F) (R Γ₀ : outParam Type*) [LinearOrderedCommMonoidWithZero Γ₀] [Ring R]\n  [FunLike F R Γ₀]\n  extends MonoidWithZeroHomClass F R Γ₀ : Prop where\n  /-- The valuation of a a sum is less that the sum of the valuations -/\n  map_add_le_max (f : F) (x y : R) : f (x + y) ≤ max (f x) (f y)\n\n"}
{"name":"ValuationClass.toMonoidWithZeroHomClass","module":"Mathlib.RingTheory.Valuation.Basic","initialProofState":"F : Type u_7\nR : outParam (Type u_5)\nΓ₀ : outParam (Type u_6)\ninst✝² : LinearOrderedCommMonoidWithZero Γ₀\ninst✝¹ : Ring R\ninst✝ : FunLike F R Γ₀\nself : ValuationClass F R Γ₀\n⊢ MonoidWithZeroHomClass F R Γ₀","decl":"/-- `ValuationClass F α β` states that `F` is a type of valuations.\n\nYou should also extend this typeclass when you extend `Valuation`. -/\nclass ValuationClass (F) (R Γ₀ : outParam Type*) [LinearOrderedCommMonoidWithZero Γ₀] [Ring R]\n  [FunLike F R Γ₀]\n  extends MonoidWithZeroHomClass F R Γ₀ : Prop where\n  /-- The valuation of a a sum is less that the sum of the valuations -/\n  map_add_le_max (f : F) (x y : R) : f (x + y) ≤ max (f x) (f y)\n\n"}
{"name":"Valuation.instValuationClass","module":"Mathlib.RingTheory.Valuation.Basic","initialProofState":"R : Type u_3\nΓ₀ : Type u_4\ninst✝¹ : Ring R\ninst✝ : LinearOrderedCommMonoidWithZero Γ₀\n⊢ ValuationClass (Valuation R Γ₀) R Γ₀","decl":"instance : ValuationClass (Valuation R Γ₀) R Γ₀ where\n  map_mul f := f.map_mul'\n  map_one f := f.map_one'\n  map_zero f := f.map_zero'\n  map_add_le_max f := f.map_add_le_max'\n\n"}
{"name":"Valuation.coe_mk","module":"Mathlib.RingTheory.Valuation.Basic","initialProofState":"R : Type u_3\nΓ₀ : Type u_4\ninst✝¹ : Ring R\ninst✝ : LinearOrderedCommMonoidWithZero Γ₀\nf : MonoidWithZeroHom R Γ₀\nh : ∀ (x y : R), LE.le ((↑f).toFun (HAdd.hAdd x y)) (Max.max ((↑f).toFun x) ((↑f).toFun y))\n⊢ Eq ⇑{ toMonoidWithZeroHom := f, map_add_le_max' := h } ⇑f","decl":"@[simp]\ntheorem coe_mk (f : R →*₀ Γ₀) (h) : ⇑(Valuation.mk f h) = f := rfl\n\n"}
{"name":"Valuation.toFun_eq_coe","module":"Mathlib.RingTheory.Valuation.Basic","initialProofState":"R : Type u_3\nΓ₀ : Type u_4\ninst✝¹ : Ring R\ninst✝ : LinearOrderedCommMonoidWithZero Γ₀\nv : Valuation R Γ₀\n⊢ Eq (↑v.toMonoidWithZeroHom).toFun ⇑v","decl":"theorem toFun_eq_coe (v : Valuation R Γ₀) : v.toFun = v := rfl\n\n"}
{"name":"Valuation.toMonoidWithZeroHom_coe_eq_coe","module":"Mathlib.RingTheory.Valuation.Basic","initialProofState":"R : Type u_3\nΓ₀ : Type u_4\ninst✝¹ : Ring R\ninst✝ : LinearOrderedCommMonoidWithZero Γ₀\nv : Valuation R Γ₀\n⊢ Eq ⇑v.toMonoidWithZeroHom ⇑v","decl":"@[simp]\ntheorem toMonoidWithZeroHom_coe_eq_coe (v : Valuation R Γ₀) :\n    (v.toMonoidWithZeroHom : R → Γ₀) = v := rfl\n\n"}
{"name":"Valuation.ext_iff","module":"Mathlib.RingTheory.Valuation.Basic","initialProofState":"R : Type u_3\nΓ₀ : Type u_4\ninst✝¹ : Ring R\ninst✝ : LinearOrderedCommMonoidWithZero Γ₀\nv₁ v₂ : Valuation R Γ₀\n⊢ Iff (Eq v₁ v₂) (∀ (r : R), Eq (v₁ r) (v₂ r))","decl":"@[ext]\ntheorem ext {v₁ v₂ : Valuation R Γ₀} (h : ∀ r, v₁ r = v₂ r) : v₁ = v₂ :=\n  DFunLike.ext _ _ h\n\n"}
{"name":"Valuation.ext","module":"Mathlib.RingTheory.Valuation.Basic","initialProofState":"R : Type u_3\nΓ₀ : Type u_4\ninst✝¹ : Ring R\ninst✝ : LinearOrderedCommMonoidWithZero Γ₀\nv₁ v₂ : Valuation R Γ₀\nh : ∀ (r : R), Eq (v₁ r) (v₂ r)\n⊢ Eq v₁ v₂","decl":"@[ext]\ntheorem ext {v₁ v₂ : Valuation R Γ₀} (h : ∀ r, v₁ r = v₂ r) : v₁ = v₂ :=\n  DFunLike.ext _ _ h\n\n"}
{"name":"Valuation.coe_coe","module":"Mathlib.RingTheory.Valuation.Basic","initialProofState":"R : Type u_3\nΓ₀ : Type u_4\ninst✝¹ : Ring R\ninst✝ : LinearOrderedCommMonoidWithZero Γ₀\nv : Valuation R Γ₀\n⊢ Eq ⇑↑v ⇑v","decl":"@[simp, norm_cast]\ntheorem coe_coe : ⇑(v : R →*₀ Γ₀) = v := rfl\n\n"}
{"name":"Valuation.map_zero","module":"Mathlib.RingTheory.Valuation.Basic","initialProofState":"R : Type u_3\nΓ₀ : Type u_4\ninst✝¹ : Ring R\ninst✝ : LinearOrderedCommMonoidWithZero Γ₀\nv : Valuation R Γ₀\n⊢ Eq (v 0) 0","decl":"theorem map_zero : v 0 = 0 :=\n  v.map_zero'\n\n"}
{"name":"Valuation.map_one","module":"Mathlib.RingTheory.Valuation.Basic","initialProofState":"R : Type u_3\nΓ₀ : Type u_4\ninst✝¹ : Ring R\ninst✝ : LinearOrderedCommMonoidWithZero Γ₀\nv : Valuation R Γ₀\n⊢ Eq (v 1) 1","decl":"theorem map_one : v 1 = 1 :=\n  v.map_one'\n\n"}
{"name":"Valuation.map_mul","module":"Mathlib.RingTheory.Valuation.Basic","initialProofState":"R : Type u_3\nΓ₀ : Type u_4\ninst✝¹ : Ring R\ninst✝ : LinearOrderedCommMonoidWithZero Γ₀\nv : Valuation R Γ₀\nx y : R\n⊢ Eq (v (HMul.hMul x y)) (HMul.hMul (v x) (v y))","decl":"theorem map_mul : ∀ x y, v (x * y) = v x * v y :=\n  v.map_mul'\n\n-- Porting note: LHS side simplified so created map_add'\n"}
{"name":"Valuation.map_add","module":"Mathlib.RingTheory.Valuation.Basic","initialProofState":"R : Type u_3\nΓ₀ : Type u_4\ninst✝¹ : Ring R\ninst✝ : LinearOrderedCommMonoidWithZero Γ₀\nv : Valuation R Γ₀\nx y : R\n⊢ LE.le (v (HAdd.hAdd x y)) (Max.max (v x) (v y))","decl":"theorem map_add : ∀ x y, v (x + y) ≤ max (v x) (v y) :=\n  v.map_add_le_max'\n\n"}
{"name":"Valuation.map_add'","module":"Mathlib.RingTheory.Valuation.Basic","initialProofState":"R : Type u_3\nΓ₀ : Type u_4\ninst✝¹ : Ring R\ninst✝ : LinearOrderedCommMonoidWithZero Γ₀\nv : Valuation R Γ₀\nx y : R\n⊢ Or (LE.le (v (HAdd.hAdd x y)) (v x)) (LE.le (v (HAdd.hAdd x y)) (v y))","decl":"@[simp]\ntheorem map_add' : ∀ x y, v (x + y) ≤ v x ∨ v (x + y) ≤ v y := by\n  intro x y\n  rw [← le_max_iff, ← ge_iff_le]\n  apply map_add\n\n"}
{"name":"Valuation.map_add_le","module":"Mathlib.RingTheory.Valuation.Basic","initialProofState":"R : Type u_3\nΓ₀ : Type u_4\ninst✝¹ : Ring R\ninst✝ : LinearOrderedCommMonoidWithZero Γ₀\nv : Valuation R Γ₀\nx y : R\ng : Γ₀\nhx : LE.le (v x) g\nhy : LE.le (v y) g\n⊢ LE.le (v (HAdd.hAdd x y)) g","decl":"theorem map_add_le {x y g} (hx : v x ≤ g) (hy : v y ≤ g) : v (x + y) ≤ g :=\n  le_trans (v.map_add x y) <| max_le hx hy\n\n"}
{"name":"Valuation.map_add_lt","module":"Mathlib.RingTheory.Valuation.Basic","initialProofState":"R : Type u_3\nΓ₀ : Type u_4\ninst✝¹ : Ring R\ninst✝ : LinearOrderedCommMonoidWithZero Γ₀\nv : Valuation R Γ₀\nx y : R\ng : Γ₀\nhx : LT.lt (v x) g\nhy : LT.lt (v y) g\n⊢ LT.lt (v (HAdd.hAdd x y)) g","decl":"theorem map_add_lt {x y g} (hx : v x < g) (hy : v y < g) : v (x + y) < g :=\n  lt_of_le_of_lt (v.map_add x y) <| max_lt hx hy\n\n"}
{"name":"Valuation.map_sum_le","module":"Mathlib.RingTheory.Valuation.Basic","initialProofState":"R : Type u_3\nΓ₀ : Type u_4\ninst✝¹ : Ring R\ninst✝ : LinearOrderedCommMonoidWithZero Γ₀\nv : Valuation R Γ₀\nι : Type u_7\ns : Finset ι\nf : ι → R\ng : Γ₀\nhf : ∀ (i : ι), Membership.mem s i → LE.le (v (f i)) g\n⊢ LE.le (v (s.sum fun i => f i)) g","decl":"theorem map_sum_le {ι : Type*} {s : Finset ι} {f : ι → R} {g : Γ₀} (hf : ∀ i ∈ s, v (f i) ≤ g) :\n    v (∑ i ∈ s, f i) ≤ g := by\n  classical\n  refine\n    Finset.induction_on s (fun _ => v.map_zero ▸ zero_le')\n      (fun a s has ih hf => ?_) hf\n  rw [Finset.forall_mem_insert] at hf; rw [Finset.sum_insert has]\n  exact v.map_add_le hf.1 (ih hf.2)\n\n"}
{"name":"Valuation.map_sum_lt","module":"Mathlib.RingTheory.Valuation.Basic","initialProofState":"R : Type u_3\nΓ₀ : Type u_4\ninst✝¹ : Ring R\ninst✝ : LinearOrderedCommMonoidWithZero Γ₀\nv : Valuation R Γ₀\nι : Type u_7\ns : Finset ι\nf : ι → R\ng : Γ₀\nhg : Ne g 0\nhf : ∀ (i : ι), Membership.mem s i → LT.lt (v (f i)) g\n⊢ LT.lt (v (s.sum fun i => f i)) g","decl":"theorem map_sum_lt {ι : Type*} {s : Finset ι} {f : ι → R} {g : Γ₀} (hg : g ≠ 0)\n    (hf : ∀ i ∈ s, v (f i) < g) : v (∑ i ∈ s, f i) < g := by\n  classical\n  refine\n    Finset.induction_on s (fun _ => v.map_zero ▸ (zero_lt_iff.2 hg))\n      (fun a s has ih hf => ?_) hf\n  rw [Finset.forall_mem_insert] at hf; rw [Finset.sum_insert has]\n  exact v.map_add_lt hf.1 (ih hf.2)\n\n"}
{"name":"Valuation.map_sum_lt'","module":"Mathlib.RingTheory.Valuation.Basic","initialProofState":"R : Type u_3\nΓ₀ : Type u_4\ninst✝¹ : Ring R\ninst✝ : LinearOrderedCommMonoidWithZero Γ₀\nv : Valuation R Γ₀\nι : Type u_7\ns : Finset ι\nf : ι → R\ng : Γ₀\nhg : LT.lt 0 g\nhf : ∀ (i : ι), Membership.mem s i → LT.lt (v (f i)) g\n⊢ LT.lt (v (s.sum fun i => f i)) g","decl":"theorem map_sum_lt' {ι : Type*} {s : Finset ι} {f : ι → R} {g : Γ₀} (hg : 0 < g)\n    (hf : ∀ i ∈ s, v (f i) < g) : v (∑ i ∈ s, f i) < g :=\n  v.map_sum_lt (ne_of_gt hg) hf\n\n"}
{"name":"Valuation.map_pow","module":"Mathlib.RingTheory.Valuation.Basic","initialProofState":"R : Type u_3\nΓ₀ : Type u_4\ninst✝¹ : Ring R\ninst✝ : LinearOrderedCommMonoidWithZero Γ₀\nv : Valuation R Γ₀\nx : R\nn : Nat\n⊢ Eq (v (HPow.hPow x n)) (HPow.hPow (v x) n)","decl":"theorem map_pow : ∀ (x) (n : ℕ), v (x ^ n) = v x ^ n :=\n  v.toMonoidWithZeroHom.toMonoidHom.map_pow\n\n-- The following definition is not an instance, because we have more than one `v` on a given `R`.\n-- In addition, type class inference would not be able to infer `v`.\n"}
{"name":"Valuation.zero_iff","module":"Mathlib.RingTheory.Valuation.Basic","initialProofState":"K : Type u_1\ninst✝² : DivisionRing K\nΓ₀ : Type u_4\ninst✝¹ : LinearOrderedCommMonoidWithZero Γ₀\ninst✝ : Nontrivial Γ₀\nv : Valuation K Γ₀\nx : K\n⊢ Iff (Eq (v x) 0) (Eq x 0)","decl":"/-- If `v` is a valuation on a division ring then `v(x) = 0` iff `x = 0`. -/\ntheorem zero_iff [Nontrivial Γ₀] (v : Valuation K Γ₀) {x : K} : v x = 0 ↔ x = 0 :=\n  map_eq_zero v\n\n"}
{"name":"Valuation.ne_zero_iff","module":"Mathlib.RingTheory.Valuation.Basic","initialProofState":"K : Type u_1\ninst✝² : DivisionRing K\nΓ₀ : Type u_4\ninst✝¹ : LinearOrderedCommMonoidWithZero Γ₀\ninst✝ : Nontrivial Γ₀\nv : Valuation K Γ₀\nx : K\n⊢ Iff (Ne (v x) 0) (Ne x 0)","decl":"theorem ne_zero_iff [Nontrivial Γ₀] (v : Valuation K Γ₀) {x : K} : v x ≠ 0 ↔ x ≠ 0 :=\n  map_ne_zero v\n\n"}
{"name":"Valuation.pos_iff","module":"Mathlib.RingTheory.Valuation.Basic","initialProofState":"K : Type u_1\ninst✝² : DivisionRing K\nΓ₀ : Type u_4\ninst✝¹ : LinearOrderedCommMonoidWithZero Γ₀\ninst✝ : Nontrivial Γ₀\nv : Valuation K Γ₀\nx : K\n⊢ Iff (LT.lt 0 (v x)) (Ne x 0)","decl":"lemma pos_iff [Nontrivial Γ₀] (v : Valuation K Γ₀) {x : K} : 0 < v x ↔ x ≠ 0 := by\n  rw [zero_lt_iff, ne_zero_iff]\n\n"}
{"name":"Valuation.unit_map_eq","module":"Mathlib.RingTheory.Valuation.Basic","initialProofState":"R : Type u_3\nΓ₀ : Type u_4\ninst✝¹ : Ring R\ninst✝ : LinearOrderedCommMonoidWithZero Γ₀\nv : Valuation R Γ₀\nu : Units R\n⊢ Eq (↑((Units.map ↑v) u)) (v ↑u)","decl":"theorem unit_map_eq (u : Rˣ) : (Units.map (v : R →* Γ₀) u : Γ₀) = v u :=\n  rfl\n\n"}
{"name":"Valuation.ne_zero_of_unit","module":"Mathlib.RingTheory.Valuation.Basic","initialProofState":"K : Type u_1\ninst✝² : DivisionRing K\nΓ₀ : Type u_4\ninst✝¹ : LinearOrderedCommMonoidWithZero Γ₀\ninst✝ : Nontrivial Γ₀\nv : Valuation K Γ₀\nx : Units K\n⊢ Ne (v ↑x) 0","decl":"theorem ne_zero_of_unit [Nontrivial Γ₀] (v : Valuation K Γ₀) (x : Kˣ) : v x ≠ (0 : Γ₀) := by\n  simp only [ne_eq, Valuation.zero_iff, Units.ne_zero x, not_false_iff]\n\n"}
{"name":"Valuation.ne_zero_of_isUnit","module":"Mathlib.RingTheory.Valuation.Basic","initialProofState":"K : Type u_1\ninst✝² : DivisionRing K\nΓ₀ : Type u_4\ninst✝¹ : LinearOrderedCommMonoidWithZero Γ₀\ninst✝ : Nontrivial Γ₀\nv : Valuation K Γ₀\nx : K\nhx : IsUnit x\n⊢ Ne (v x) 0","decl":"theorem ne_zero_of_isUnit [Nontrivial Γ₀] (v : Valuation K Γ₀) (x : K) (hx : IsUnit x) :\n    v x ≠ (0 : Γ₀) := by\n  simpa [hx.choose_spec] using ne_zero_of_unit v hx.choose\n\n"}
{"name":"Valuation.comap_apply","module":"Mathlib.RingTheory.Valuation.Basic","initialProofState":"R : Type u_3\nΓ₀ : Type u_4\ninst✝² : Ring R\ninst✝¹ : LinearOrderedCommMonoidWithZero Γ₀\nS : Type u_7\ninst✝ : Ring S\nf : RingHom S R\nv : Valuation R Γ₀\ns : S\n⊢ Eq ((Valuation.comap f v) s) (v (f s))","decl":"@[simp]\ntheorem comap_apply {S : Type*} [Ring S] (f : S →+* R) (v : Valuation R Γ₀) (s : S) :\n    v.comap f s = v (f s) := rfl\n\n"}
{"name":"Valuation.comap_id","module":"Mathlib.RingTheory.Valuation.Basic","initialProofState":"R : Type u_3\nΓ₀ : Type u_4\ninst✝¹ : Ring R\ninst✝ : LinearOrderedCommMonoidWithZero Γ₀\nv : Valuation R Γ₀\n⊢ Eq (Valuation.comap (RingHom.id R) v) v","decl":"@[simp]\ntheorem comap_id : v.comap (RingHom.id R) = v :=\n  ext fun _r => rfl\n\n"}
{"name":"Valuation.comap_comp","module":"Mathlib.RingTheory.Valuation.Basic","initialProofState":"R : Type u_3\nΓ₀ : Type u_4\ninst✝³ : Ring R\ninst✝² : LinearOrderedCommMonoidWithZero Γ₀\nv : Valuation R Γ₀\nS₁ : Type u_7\nS₂ : Type u_8\ninst✝¹ : Ring S₁\ninst✝ : Ring S₂\nf : RingHom S₁ S₂\ng : RingHom S₂ R\n⊢ Eq (Valuation.comap (g.comp f) v) (Valuation.comap f (Valuation.comap g v))","decl":"theorem comap_comp {S₁ : Type*} {S₂ : Type*} [Ring S₁] [Ring S₂] (f : S₁ →+* S₂) (g : S₂ →+* R) :\n    v.comap (g.comp f) = (v.comap g).comap f :=\n  ext fun _r => rfl\n\n"}
{"name":"Valuation.map_apply","module":"Mathlib.RingTheory.Valuation.Basic","initialProofState":"R : Type u_3\nΓ₀ : Type u_4\nΓ'₀ : Type u_5\ninst✝² : Ring R\ninst✝¹ : LinearOrderedCommMonoidWithZero Γ₀\ninst✝ : LinearOrderedCommMonoidWithZero Γ'₀\nf : MonoidWithZeroHom Γ₀ Γ'₀\nhf : Monotone ⇑f\nv : Valuation R Γ₀\nr : R\n⊢ Eq ((Valuation.map f hf v) r) (f (v r))","decl":"@[simp]\nlemma map_apply (f : Γ₀ →*₀ Γ'₀) (hf : Monotone f) (v : Valuation R Γ₀) (r : R) :\n    v.map f hf r = f (v r) := rfl\n\n"}
{"name":"Valuation.map_neg","module":"Mathlib.RingTheory.Valuation.Basic","initialProofState":"R : Type u_3\nΓ₀ : Type u_4\ninst✝¹ : Ring R\ninst✝ : LinearOrderedCommMonoidWithZero Γ₀\nv : Valuation R Γ₀\nx : R\n⊢ Eq (v (Neg.neg x)) (v x)","decl":"@[simp]\ntheorem map_neg (x : R) : v (-x) = v x :=\n  v.toMonoidWithZeroHom.toMonoidHom.map_neg x\n\n"}
{"name":"Valuation.map_sub_swap","module":"Mathlib.RingTheory.Valuation.Basic","initialProofState":"R : Type u_3\nΓ₀ : Type u_4\ninst✝¹ : Ring R\ninst✝ : LinearOrderedCommMonoidWithZero Γ₀\nv : Valuation R Γ₀\nx y : R\n⊢ Eq (v (HSub.hSub x y)) (v (HSub.hSub y x))","decl":"theorem map_sub_swap (x y : R) : v (x - y) = v (y - x) :=\n  v.toMonoidWithZeroHom.toMonoidHom.map_sub_swap x y\n\n"}
{"name":"Valuation.map_sub","module":"Mathlib.RingTheory.Valuation.Basic","initialProofState":"R : Type u_3\nΓ₀ : Type u_4\ninst✝¹ : Ring R\ninst✝ : LinearOrderedCommMonoidWithZero Γ₀\nv : Valuation R Γ₀\nx y : R\n⊢ LE.le (v (HSub.hSub x y)) (Max.max (v x) (v y))","decl":"theorem map_sub (x y : R) : v (x - y) ≤ max (v x) (v y) :=\n  calc\n    v (x - y) = v (x + -y) := by rw [sub_eq_add_neg]\n    _ ≤ max (v x) (v <| -y) := v.map_add _ _\n    _ = max (v x) (v y) := by rw [map_neg]\n\n"}
{"name":"Valuation.map_sub_le","module":"Mathlib.RingTheory.Valuation.Basic","initialProofState":"R : Type u_3\nΓ₀ : Type u_4\ninst✝¹ : Ring R\ninst✝ : LinearOrderedCommMonoidWithZero Γ₀\nv : Valuation R Γ₀\nx y : R\ng : Γ₀\nhx : LE.le (v x) g\nhy : LE.le (v y) g\n⊢ LE.le (v (HSub.hSub x y)) g","decl":"theorem map_sub_le {x y g} (hx : v x ≤ g) (hy : v y ≤ g) : v (x - y) ≤ g := by\n  rw [sub_eq_add_neg]\n  exact v.map_add_le hx (le_trans (le_of_eq (v.map_neg y)) hy)\n\n"}
{"name":"Valuation.map_add_of_distinct_val","module":"Mathlib.RingTheory.Valuation.Basic","initialProofState":"R : Type u_3\nΓ₀ : Type u_4\ninst✝¹ : Ring R\ninst✝ : LinearOrderedCommMonoidWithZero Γ₀\nv : Valuation R Γ₀\nx y : R\nh : Ne (v x) (v y)\n⊢ Eq (v (HAdd.hAdd x y)) (Max.max (v x) (v y))","decl":"theorem map_add_of_distinct_val (h : v x ≠ v y) : v (x + y) = max (v x) (v y) := by\n  suffices ¬v (x + y) < max (v x) (v y) from\n    or_iff_not_imp_right.1 (le_iff_eq_or_lt.1 (v.map_add x y)) this\n  intro h'\n  wlog vyx : v y < v x generalizing x y\n  · refine this h.symm ?_ (h.lt_or_lt.resolve_right vyx)\n    rwa [add_comm, max_comm]\n  rw [max_eq_left_of_lt vyx] at h'\n  apply lt_irrefl (v x)\n  calc\n    v x = v (x + y - y) := by simp\n    _ ≤ max (v <| x + y) (v y) := map_sub _ _ _\n    _ < v x := max_lt h' vyx\n\n"}
{"name":"Valuation.map_add_eq_of_lt_right","module":"Mathlib.RingTheory.Valuation.Basic","initialProofState":"R : Type u_3\nΓ₀ : Type u_4\ninst✝¹ : Ring R\ninst✝ : LinearOrderedCommMonoidWithZero Γ₀\nv : Valuation R Γ₀\nx y : R\nh : LT.lt (v x) (v y)\n⊢ Eq (v (HAdd.hAdd x y)) (v y)","decl":"theorem map_add_eq_of_lt_right (h : v x < v y) : v (x + y) = v y :=\n  (v.map_add_of_distinct_val h.ne).trans (max_eq_right_iff.mpr h.le)\n\n"}
{"name":"Valuation.map_add_eq_of_lt_left","module":"Mathlib.RingTheory.Valuation.Basic","initialProofState":"R : Type u_3\nΓ₀ : Type u_4\ninst✝¹ : Ring R\ninst✝ : LinearOrderedCommMonoidWithZero Γ₀\nv : Valuation R Γ₀\nx y : R\nh : LT.lt (v y) (v x)\n⊢ Eq (v (HAdd.hAdd x y)) (v x)","decl":"theorem map_add_eq_of_lt_left (h : v y < v x) : v (x + y) = v x := by\n  rw [add_comm]; exact map_add_eq_of_lt_right _ h\n\n"}
{"name":"Valuation.map_sub_eq_of_lt_right","module":"Mathlib.RingTheory.Valuation.Basic","initialProofState":"R : Type u_3\nΓ₀ : Type u_4\ninst✝¹ : Ring R\ninst✝ : LinearOrderedCommMonoidWithZero Γ₀\nv : Valuation R Γ₀\nx y : R\nh : LT.lt (v x) (v y)\n⊢ Eq (v (HSub.hSub x y)) (v y)","decl":"theorem map_sub_eq_of_lt_right (h : v x < v y) : v (x - y) = v y := by\n  rw [sub_eq_add_neg, map_add_eq_of_lt_right, map_neg]\n  rwa [map_neg]\n\n"}
{"name":"Valuation.map_sum_eq_of_lt","module":"Mathlib.RingTheory.Valuation.Basic","initialProofState":"R : Type u_3\nΓ₀ : Type u_4\ninst✝¹ : Ring R\ninst✝ : LinearOrderedCommMonoidWithZero Γ₀\nv : Valuation R Γ₀\nι : Type u_7\ns : Finset ι\nf : ι → R\nj : ι\nhj : Membership.mem s j\nh0 : Ne (v (f j)) 0\nhf : ∀ (i : ι), Membership.mem (SDiff.sdiff s (Singleton.singleton j)) i → LT.lt (v (f i)) (v (f j))\n⊢ Eq (v (s.sum fun i => f i)) (v (f j))","decl":"open scoped Classical in\ntheorem map_sum_eq_of_lt {ι : Type*} {s : Finset ι} {f : ι → R} {j : ι}\n    (hj : j ∈ s) (h0 : v (f j) ≠ 0) (hf : ∀ i ∈ s \\ {j}, v (f i) < v (f j)) :\n    v (∑ i ∈ s, f i) = v (f j) := by\n  rw [Finset.sum_eq_add_sum_diff_singleton hj]\n  exact map_add_eq_of_lt_left _ (map_sum_lt _ h0 hf)\n\n"}
{"name":"Valuation.map_sub_eq_of_lt_left","module":"Mathlib.RingTheory.Valuation.Basic","initialProofState":"R : Type u_3\nΓ₀ : Type u_4\ninst✝¹ : Ring R\ninst✝ : LinearOrderedCommMonoidWithZero Γ₀\nv : Valuation R Γ₀\nx y : R\nh : LT.lt (v y) (v x)\n⊢ Eq (v (HSub.hSub x y)) (v x)","decl":"theorem map_sub_eq_of_lt_left (h : v y < v x) : v (x - y) = v x := by\n  rw [sub_eq_add_neg, map_add_eq_of_lt_left]\n  rwa [map_neg]\n\n"}
{"name":"Valuation.map_eq_of_sub_lt","module":"Mathlib.RingTheory.Valuation.Basic","initialProofState":"R : Type u_3\nΓ₀ : Type u_4\ninst✝¹ : Ring R\ninst✝ : LinearOrderedCommMonoidWithZero Γ₀\nv : Valuation R Γ₀\nx y : R\nh : LT.lt (v (HSub.hSub y x)) (v x)\n⊢ Eq (v y) (v x)","decl":"theorem map_eq_of_sub_lt (h : v (y - x) < v x) : v y = v x := by\n  have := Valuation.map_add_of_distinct_val v (ne_of_gt h).symm\n  rw [max_eq_right (le_of_lt h)] at this\n  simpa using this\n\n"}
{"name":"Valuation.map_one_add_of_lt","module":"Mathlib.RingTheory.Valuation.Basic","initialProofState":"R : Type u_3\nΓ₀ : Type u_4\ninst✝¹ : Ring R\ninst✝ : LinearOrderedCommMonoidWithZero Γ₀\nv : Valuation R Γ₀\nx : R\nh : LT.lt (v x) 1\n⊢ Eq (v (HAdd.hAdd 1 x)) 1","decl":"theorem map_one_add_of_lt (h : v x < 1) : v (1 + x) = 1 := by\n  rw [← v.map_one] at h\n  simpa only [v.map_one] using v.map_add_eq_of_lt_left h\n\n"}
{"name":"Valuation.map_one_sub_of_lt","module":"Mathlib.RingTheory.Valuation.Basic","initialProofState":"R : Type u_3\nΓ₀ : Type u_4\ninst✝¹ : Ring R\ninst✝ : LinearOrderedCommMonoidWithZero Γ₀\nv : Valuation R Γ₀\nx : R\nh : LT.lt (v x) 1\n⊢ Eq (v (HSub.hSub 1 x)) 1","decl":"theorem map_one_sub_of_lt (h : v x < 1) : v (1 - x) = 1 := by\n  rw [← v.map_one, ← v.map_neg] at h\n  rw [sub_eq_add_neg 1 x]\n  simpa only [v.map_one, v.map_neg] using v.map_add_eq_of_lt_left h\n\n"}
{"name":"Valuation.map_inv","module":"Mathlib.RingTheory.Valuation.Basic","initialProofState":"Γ₀ : Type u_4\ninst✝¹ : LinearOrderedCommGroupWithZero Γ₀\nR : Type u_7\ninst✝ : DivisionRing R\nv : Valuation R Γ₀\nx : R\n⊢ Eq (v (Inv.inv x)) (Inv.inv (v x))","decl":"theorem map_inv {R : Type*} [DivisionRing R] (v : Valuation R Γ₀) : ∀ x, v x⁻¹ = (v x)⁻¹ :=\n  map_inv₀ _\n\n"}
{"name":"Valuation.map_div","module":"Mathlib.RingTheory.Valuation.Basic","initialProofState":"Γ₀ : Type u_4\ninst✝¹ : LinearOrderedCommGroupWithZero Γ₀\nR : Type u_7\ninst✝ : DivisionRing R\nv : Valuation R Γ₀\nx y : R\n⊢ Eq (v (HDiv.hDiv x y)) (HDiv.hDiv (v x) (v y))","decl":"theorem map_div {R : Type*} [DivisionRing R] (v : Valuation R Γ₀) : ∀ x y, v (x / y) = v x / v y :=\n  map_div₀ _\n\n"}
{"name":"Valuation.one_lt_val_iff","module":"Mathlib.RingTheory.Valuation.Basic","initialProofState":"K : Type u_1\ninst✝¹ : DivisionRing K\nΓ₀ : Type u_4\ninst✝ : LinearOrderedCommGroupWithZero Γ₀\nv : Valuation K Γ₀\nx : K\nh : Ne x 0\n⊢ Iff (LT.lt 1 (v x)) (LT.lt (v (Inv.inv x)) 1)","decl":"theorem one_lt_val_iff (v : Valuation K Γ₀) {x : K} (h : x ≠ 0) : 1 < v x ↔ v x⁻¹ < 1 := by\n  simp [inv_lt_one₀ (v.pos_iff.2 h)]\n\n"}
{"name":"Valuation.one_le_val_iff","module":"Mathlib.RingTheory.Valuation.Basic","initialProofState":"K : Type u_1\ninst✝¹ : DivisionRing K\nΓ₀ : Type u_4\ninst✝ : LinearOrderedCommGroupWithZero Γ₀\nv : Valuation K Γ₀\nx : K\nh : Ne x 0\n⊢ Iff (LE.le 1 (v x)) (LE.le (v (Inv.inv x)) 1)","decl":"theorem one_le_val_iff (v : Valuation K Γ₀) {x : K} (h : x ≠ 0) : 1 ≤ v x ↔ v x⁻¹ ≤ 1 := by\n  simp [inv_le_one₀ (v.pos_iff.2 h)]\n\n"}
{"name":"Valuation.val_lt_one_iff","module":"Mathlib.RingTheory.Valuation.Basic","initialProofState":"K : Type u_1\ninst✝¹ : DivisionRing K\nΓ₀ : Type u_4\ninst✝ : LinearOrderedCommGroupWithZero Γ₀\nv : Valuation K Γ₀\nx : K\nh : Ne x 0\n⊢ Iff (LT.lt (v x) 1) (LT.lt 1 (v (Inv.inv x)))","decl":"theorem val_lt_one_iff (v : Valuation K Γ₀) {x : K} (h : x ≠ 0) : v x < 1 ↔ 1 < v x⁻¹ := by\n  simp [one_lt_inv₀ (v.pos_iff.2 h)]\n\n"}
{"name":"Valuation.val_le_one_iff","module":"Mathlib.RingTheory.Valuation.Basic","initialProofState":"K : Type u_1\ninst✝¹ : DivisionRing K\nΓ₀ : Type u_4\ninst✝ : LinearOrderedCommGroupWithZero Γ₀\nv : Valuation K Γ₀\nx : K\nh : Ne x 0\n⊢ Iff (LE.le (v x) 1) (LE.le 1 (v (Inv.inv x)))","decl":"theorem val_le_one_iff (v : Valuation K Γ₀) {x : K} (h : x ≠ 0) : v x ≤ 1 ↔ 1 ≤ v x⁻¹ := by\n  simp [one_le_inv₀ (v.pos_iff.2 h)]\n\n"}
{"name":"Valuation.val_eq_one_iff","module":"Mathlib.RingTheory.Valuation.Basic","initialProofState":"K : Type u_1\ninst✝¹ : DivisionRing K\nΓ₀ : Type u_4\ninst✝ : LinearOrderedCommGroupWithZero Γ₀\nv : Valuation K Γ₀\nx : K\n⊢ Iff (Eq (v x) 1) (Eq (v (Inv.inv x)) 1)","decl":"theorem val_eq_one_iff (v : Valuation K Γ₀) {x : K} : v x = 1 ↔ v x⁻¹ = 1 := by\n  by_cases h : x = 0\n  · simp only [map_inv₀, inv_eq_one]\n  · simpa only [le_antisymm_iff, And.comm] using and_congr (one_le_val_iff v h) (val_le_one_iff v h)\n\n"}
{"name":"Valuation.val_le_one_or_val_inv_lt_one","module":"Mathlib.RingTheory.Valuation.Basic","initialProofState":"K : Type u_1\ninst✝¹ : DivisionRing K\nΓ₀ : Type u_4\ninst✝ : LinearOrderedCommGroupWithZero Γ₀\nv : Valuation K Γ₀\nx : K\n⊢ Or (LE.le (v x) 1) (LT.lt (v (Inv.inv x)) 1)","decl":"theorem val_le_one_or_val_inv_lt_one (v : Valuation K Γ₀) (x : K) : v x ≤ 1 ∨ v x⁻¹ < 1 := by\n  by_cases h : x = 0\n  · simp only [h, _root_.map_zero, zero_le', inv_zero, zero_lt_one, or_self]\n  · simp only [← one_lt_val_iff v h, le_or_lt]\n\n"}
{"name":"Valuation.val_le_one_or_val_inv_le_one","module":"Mathlib.RingTheory.Valuation.Basic","initialProofState":"K : Type u_1\ninst✝¹ : DivisionRing K\nΓ₀ : Type u_4\ninst✝ : LinearOrderedCommGroupWithZero Γ₀\nv : Valuation K Γ₀\nx : K\n⊢ Or (LE.le (v x) 1) (LE.le (v (Inv.inv x)) 1)","decl":"/--\nThis theorem is a weaker version of `Valuation.val_le_one_or_val_inv_lt_one`, but more symmetric\nin `x` and `x⁻¹`.\n-/\ntheorem val_le_one_or_val_inv_le_one (v : Valuation K Γ₀) (x : K) : v x ≤ 1 ∨ v x⁻¹ ≤ 1 := by\n  by_cases h : x = 0\n  · simp only [h, _root_.map_zero, zero_le', inv_zero, or_self]\n  · simp only [← one_le_val_iff v h, le_total]\n\n"}
{"name":"Valuation.IsEquiv.refl","module":"Mathlib.RingTheory.Valuation.Basic","initialProofState":"R : Type u_3\nΓ₀ : Type u_4\ninst✝¹ : Ring R\ninst✝ : LinearOrderedCommMonoidWithZero Γ₀\nv : Valuation R Γ₀\n⊢ v.IsEquiv v","decl":"@[refl]\ntheorem refl : v.IsEquiv v := fun _ _ => Iff.refl _\n\n"}
{"name":"Valuation.IsEquiv.symm","module":"Mathlib.RingTheory.Valuation.Basic","initialProofState":"R : Type u_3\nΓ₀ : Type u_4\nΓ'₀ : Type u_5\ninst✝² : Ring R\ninst✝¹ : LinearOrderedCommMonoidWithZero Γ₀\ninst✝ : LinearOrderedCommMonoidWithZero Γ'₀\nv₁ : Valuation R Γ₀\nv₂ : Valuation R Γ'₀\nh : v₁.IsEquiv v₂\n⊢ v₂.IsEquiv v₁","decl":"@[symm]\ntheorem symm (h : v₁.IsEquiv v₂) : v₂.IsEquiv v₁ := fun _ _ => Iff.symm (h _ _)\n\n"}
{"name":"Valuation.IsEquiv.trans","module":"Mathlib.RingTheory.Valuation.Basic","initialProofState":"R : Type u_3\nΓ₀ : Type u_4\nΓ'₀ : Type u_5\nΓ''₀ : Type u_6\ninst✝³ : LinearOrderedCommMonoidWithZero Γ''₀\ninst✝² : Ring R\ninst✝¹ : LinearOrderedCommMonoidWithZero Γ₀\ninst✝ : LinearOrderedCommMonoidWithZero Γ'₀\nv₁ : Valuation R Γ₀\nv₂ : Valuation R Γ'₀\nv₃ : Valuation R Γ''₀\nh₁₂ : v₁.IsEquiv v₂\nh₂₃ : v₂.IsEquiv v₃\n⊢ v₁.IsEquiv v₃","decl":"@[trans]\ntheorem trans (h₁₂ : v₁.IsEquiv v₂) (h₂₃ : v₂.IsEquiv v₃) : v₁.IsEquiv v₃ := fun _ _ =>\n  Iff.trans (h₁₂ _ _) (h₂₃ _ _)\n\n"}
{"name":"Valuation.IsEquiv.of_eq","module":"Mathlib.RingTheory.Valuation.Basic","initialProofState":"R : Type u_3\nΓ₀ : Type u_4\ninst✝¹ : Ring R\ninst✝ : LinearOrderedCommMonoidWithZero Γ₀\nv v' : Valuation R Γ₀\nh : Eq v v'\n⊢ v.IsEquiv v'","decl":"theorem of_eq {v' : Valuation R Γ₀} (h : v = v') : v.IsEquiv v' := by subst h; rfl\n\n"}
{"name":"Valuation.IsEquiv.map","module":"Mathlib.RingTheory.Valuation.Basic","initialProofState":"R : Type u_3\nΓ₀ : Type u_4\nΓ'₀ : Type u_5\ninst✝² : Ring R\ninst✝¹ : LinearOrderedCommMonoidWithZero Γ₀\ninst✝ : LinearOrderedCommMonoidWithZero Γ'₀\nv v' : Valuation R Γ₀\nf : MonoidWithZeroHom Γ₀ Γ'₀\nhf : Monotone ⇑f\ninf : Function.Injective ⇑f\nh : v.IsEquiv v'\n⊢ (Valuation.map f hf v).IsEquiv (Valuation.map f hf v')","decl":"theorem map {v' : Valuation R Γ₀} (f : Γ₀ →*₀ Γ'₀) (hf : Monotone f) (inf : Injective f)\n    (h : v.IsEquiv v') : (v.map f hf).IsEquiv (v'.map f hf) :=\n  let H : StrictMono f := hf.strictMono_of_injective inf\n  fun r s =>\n  calc\n    f (v r) ≤ f (v s) ↔ v r ≤ v s := by rw [H.le_iff_le]\n    _ ↔ v' r ≤ v' s := h r s\n    _ ↔ f (v' r) ≤ f (v' s) := by rw [H.le_iff_le]\n\n"}
{"name":"Valuation.IsEquiv.comap","module":"Mathlib.RingTheory.Valuation.Basic","initialProofState":"R : Type u_3\nΓ₀ : Type u_4\nΓ'₀ : Type u_5\ninst✝³ : Ring R\ninst✝² : LinearOrderedCommMonoidWithZero Γ₀\ninst✝¹ : LinearOrderedCommMonoidWithZero Γ'₀\nv₁ : Valuation R Γ₀\nv₂ : Valuation R Γ'₀\nS : Type u_7\ninst✝ : Ring S\nf : RingHom S R\nh : v₁.IsEquiv v₂\n⊢ (Valuation.comap f v₁).IsEquiv (Valuation.comap f v₂)","decl":"/-- `comap` preserves equivalence. -/\ntheorem comap {S : Type*} [Ring S] (f : S →+* R) (h : v₁.IsEquiv v₂) :\n    (v₁.comap f).IsEquiv (v₂.comap f) := fun r s => h (f r) (f s)\n\n"}
{"name":"Valuation.IsEquiv.val_eq","module":"Mathlib.RingTheory.Valuation.Basic","initialProofState":"R : Type u_3\nΓ₀ : Type u_4\nΓ'₀ : Type u_5\ninst✝² : Ring R\ninst✝¹ : LinearOrderedCommMonoidWithZero Γ₀\ninst✝ : LinearOrderedCommMonoidWithZero Γ'₀\nv₁ : Valuation R Γ₀\nv₂ : Valuation R Γ'₀\nh : v₁.IsEquiv v₂\nr s : R\n⊢ Iff (Eq (v₁ r) (v₁ s)) (Eq (v₂ r) (v₂ s))","decl":"theorem val_eq (h : v₁.IsEquiv v₂) {r s : R} : v₁ r = v₁ s ↔ v₂ r = v₂ s := by\n  simpa only [le_antisymm_iff] using and_congr (h r s) (h s r)\n\n"}
{"name":"Valuation.IsEquiv.ne_zero","module":"Mathlib.RingTheory.Valuation.Basic","initialProofState":"R : Type u_3\nΓ₀ : Type u_4\nΓ'₀ : Type u_5\ninst✝² : Ring R\ninst✝¹ : LinearOrderedCommMonoidWithZero Γ₀\ninst✝ : LinearOrderedCommMonoidWithZero Γ'₀\nv₁ : Valuation R Γ₀\nv₂ : Valuation R Γ'₀\nh : v₁.IsEquiv v₂\nr : R\n⊢ Iff (Ne (v₁ r) 0) (Ne (v₂ r) 0)","decl":"theorem ne_zero (h : v₁.IsEquiv v₂) {r : R} : v₁ r ≠ 0 ↔ v₂ r ≠ 0 := by\n  have : v₁ r ≠ v₁ 0 ↔ v₂ r ≠ v₂ 0 := not_congr h.val_eq\n  rwa [v₁.map_zero, v₂.map_zero] at this\n\n"}
{"name":"Valuation.isEquiv_of_map_strictMono","module":"Mathlib.RingTheory.Valuation.Basic","initialProofState":"R : Type u_3\nΓ₀ : Type u_4\nΓ'₀ : Type u_5\ninst✝² : LinearOrderedCommMonoidWithZero Γ₀\ninst✝¹ : LinearOrderedCommMonoidWithZero Γ'₀\ninst✝ : Ring R\nv : Valuation R Γ₀\nf : MonoidWithZeroHom Γ₀ Γ'₀\nH : StrictMono ⇑f\n⊢ (Valuation.map f ⋯ v).IsEquiv v","decl":"theorem isEquiv_of_map_strictMono [LinearOrderedCommMonoidWithZero Γ₀]\n    [LinearOrderedCommMonoidWithZero Γ'₀] [Ring R] {v : Valuation R Γ₀} (f : Γ₀ →*₀ Γ'₀)\n    (H : StrictMono f) : IsEquiv (v.map f H.monotone) v := fun _x _y =>\n  ⟨H.le_iff_le.mp, fun h => H.monotone h⟩\n\n"}
{"name":"Valuation.isEquiv_iff_val_lt_val","module":"Mathlib.RingTheory.Valuation.Basic","initialProofState":"K : Type u_1\ninst✝² : DivisionRing K\nΓ₀ : Type u_4\nΓ'₀ : Type u_5\ninst✝¹ : LinearOrderedCommGroupWithZero Γ₀\ninst✝ : LinearOrderedCommGroupWithZero Γ'₀\nv : Valuation K Γ₀\nv' : Valuation K Γ'₀\n⊢ Iff (v.IsEquiv v') (∀ {x y : K}, Iff (LT.lt (v x) (v y)) (LT.lt (v' x) (v' y)))","decl":"theorem isEquiv_iff_val_lt_val [LinearOrderedCommGroupWithZero Γ₀]\n    [LinearOrderedCommGroupWithZero Γ'₀] {v : Valuation K Γ₀} {v' : Valuation K Γ'₀} :\n    v.IsEquiv v' ↔ ∀ {x y : K}, v x < v y ↔ v' x < v' y := by\n  simp only [IsEquiv, le_iff_le_iff_lt_iff_lt]\n  exact forall_comm\n\n"}
{"name":"Valuation.IsEquiv.lt_iff_lt","module":"Mathlib.RingTheory.Valuation.Basic","initialProofState":"K : Type u_1\ninst✝² : DivisionRing K\nΓ₀ : Type u_4\nΓ'₀ : Type u_5\ninst✝¹ : LinearOrderedCommGroupWithZero Γ₀\ninst✝ : LinearOrderedCommGroupWithZero Γ'₀\nv : Valuation K Γ₀\nv' : Valuation K Γ'₀\na✝ : v.IsEquiv v'\nx y : K\n⊢ Iff (LT.lt (v x) (v y)) (LT.lt (v' x) (v' y))","decl":"alias ⟨IsEquiv.lt_iff_lt, _⟩ := isEquiv_iff_val_lt_val\n\n"}
{"name":"Valuation.isEquiv_of_val_le_one","module":"Mathlib.RingTheory.Valuation.Basic","initialProofState":"K : Type u_1\ninst✝² : DivisionRing K\nΓ₀ : Type u_4\nΓ'₀ : Type u_5\ninst✝¹ : LinearOrderedCommGroupWithZero Γ₀\ninst✝ : LinearOrderedCommGroupWithZero Γ'₀\nv : Valuation K Γ₀\nv' : Valuation K Γ'₀\nh : ∀ {x : K}, Iff (LE.le (v x) 1) (LE.le (v' x) 1)\n⊢ v.IsEquiv v'","decl":"theorem isEquiv_of_val_le_one [LinearOrderedCommGroupWithZero Γ₀]\n    [LinearOrderedCommGroupWithZero Γ'₀] {v : Valuation K Γ₀} {v' : Valuation K Γ'₀}\n    (h : ∀ {x : K}, v x ≤ 1 ↔ v' x ≤ 1) : v.IsEquiv v' := by\n  intro x y\n  obtain rfl | hy := eq_or_ne y 0\n  · simp\n  · rw [← div_le_one₀, ← v.map_div, h, v'.map_div, div_le_one₀] <;>\n      rwa [zero_lt_iff, ne_zero_iff]\n\n"}
{"name":"Valuation.isEquiv_iff_val_le_one","module":"Mathlib.RingTheory.Valuation.Basic","initialProofState":"K : Type u_1\ninst✝² : DivisionRing K\nΓ₀ : Type u_4\nΓ'₀ : Type u_5\ninst✝¹ : LinearOrderedCommGroupWithZero Γ₀\ninst✝ : LinearOrderedCommGroupWithZero Γ'₀\nv : Valuation K Γ₀\nv' : Valuation K Γ'₀\n⊢ Iff (v.IsEquiv v') (∀ {x : K}, Iff (LE.le (v x) 1) (LE.le (v' x) 1))","decl":"theorem isEquiv_iff_val_le_one [LinearOrderedCommGroupWithZero Γ₀]\n    [LinearOrderedCommGroupWithZero Γ'₀] {v : Valuation K Γ₀} {v' : Valuation K Γ'₀} :\n    v.IsEquiv v' ↔ ∀ {x : K}, v x ≤ 1 ↔ v' x ≤ 1 :=\n  ⟨fun h x => by simpa using h x 1, isEquiv_of_val_le_one⟩\n\n"}
{"name":"Valuation.IsEquiv.le_one_iff_le_one","module":"Mathlib.RingTheory.Valuation.Basic","initialProofState":"K : Type u_1\ninst✝² : DivisionRing K\nΓ₀ : Type u_4\nΓ'₀ : Type u_5\ninst✝¹ : LinearOrderedCommGroupWithZero Γ₀\ninst✝ : LinearOrderedCommGroupWithZero Γ'₀\nv : Valuation K Γ₀\nv' : Valuation K Γ'₀\na✝ : v.IsEquiv v'\nx : K\n⊢ Iff (LE.le (v x) 1) (LE.le (v' x) 1)","decl":"alias ⟨IsEquiv.le_one_iff_le_one, _⟩ := isEquiv_iff_val_le_one\n\n"}
{"name":"Valuation.isEquiv_iff_val_eq_one","module":"Mathlib.RingTheory.Valuation.Basic","initialProofState":"K : Type u_1\ninst✝² : DivisionRing K\nΓ₀ : Type u_4\nΓ'₀ : Type u_5\ninst✝¹ : LinearOrderedCommGroupWithZero Γ₀\ninst✝ : LinearOrderedCommGroupWithZero Γ'₀\nv : Valuation K Γ₀\nv' : Valuation K Γ'₀\n⊢ Iff (v.IsEquiv v') (∀ {x : K}, Iff (Eq (v x) 1) (Eq (v' x) 1))","decl":"theorem isEquiv_iff_val_eq_one [LinearOrderedCommGroupWithZero Γ₀]\n    [LinearOrderedCommGroupWithZero Γ'₀] {v : Valuation K Γ₀} {v' : Valuation K Γ'₀} :\n    v.IsEquiv v' ↔ ∀ {x : K}, v x = 1 ↔ v' x = 1 := by\n  constructor\n  · intro h x\n    simpa using @IsEquiv.val_eq _ _ _ _ _ _ v v' h x 1\n  · intro h\n    apply isEquiv_of_val_le_one\n    intro x\n    constructor\n    · intro hx\n      rcases lt_or_eq_of_le hx with hx' | hx'\n      · have : v (1 + x) = 1 := by\n          rw [← v.map_one]\n          apply map_add_eq_of_lt_left\n          simpa\n        rw [h] at this\n        rw [show x = -1 + (1 + x) by simp]\n        refine le_trans (v'.map_add _ _) ?_\n        simp [this]\n      · rw [h] at hx'\n        exact le_of_eq hx'\n    · intro hx\n      rcases lt_or_eq_of_le hx with hx' | hx'\n      · have : v' (1 + x) = 1 := by\n          rw [← v'.map_one]\n          apply map_add_eq_of_lt_left\n          simpa\n        rw [← h] at this\n        rw [show x = -1 + (1 + x) by simp]\n        refine le_trans (v.map_add _ _) ?_\n        simp [this]\n      · rw [← h] at hx'\n        exact le_of_eq hx'\n\n"}
{"name":"Valuation.IsEquiv.eq_one_iff_eq_one","module":"Mathlib.RingTheory.Valuation.Basic","initialProofState":"K : Type u_1\ninst✝² : DivisionRing K\nΓ₀ : Type u_4\nΓ'₀ : Type u_5\ninst✝¹ : LinearOrderedCommGroupWithZero Γ₀\ninst✝ : LinearOrderedCommGroupWithZero Γ'₀\nv : Valuation K Γ₀\nv' : Valuation K Γ'₀\na✝ : v.IsEquiv v'\nx : K\n⊢ Iff (Eq (v x) 1) (Eq (v' x) 1)","decl":"alias ⟨IsEquiv.eq_one_iff_eq_one, _⟩ := isEquiv_iff_val_eq_one\n\n"}
{"name":"Valuation.isEquiv_iff_val_lt_one","module":"Mathlib.RingTheory.Valuation.Basic","initialProofState":"K : Type u_1\ninst✝² : DivisionRing K\nΓ₀ : Type u_4\nΓ'₀ : Type u_5\ninst✝¹ : LinearOrderedCommGroupWithZero Γ₀\ninst✝ : LinearOrderedCommGroupWithZero Γ'₀\nv : Valuation K Γ₀\nv' : Valuation K Γ'₀\n⊢ Iff (v.IsEquiv v') (∀ {x : K}, Iff (LT.lt (v x) 1) (LT.lt (v' x) 1))","decl":"theorem isEquiv_iff_val_lt_one [LinearOrderedCommGroupWithZero Γ₀]\n    [LinearOrderedCommGroupWithZero Γ'₀] {v : Valuation K Γ₀} {v' : Valuation K Γ'₀} :\n    v.IsEquiv v' ↔ ∀ {x : K}, v x < 1 ↔ v' x < 1 := by\n  constructor\n  · intro h x\n    simp only [lt_iff_le_and_ne,\n      and_congr h.le_one_iff_le_one h.eq_one_iff_eq_one.not]\n  · rw [isEquiv_iff_val_eq_one]\n    intro h x\n    by_cases hx : x = 0\n    · simp only [(zero_iff _).2 hx, zero_ne_one]\n    constructor\n    · intro hh\n      by_contra h_1\n      cases ne_iff_lt_or_gt.1 h_1 with\n      | inl h_2 => simpa [hh, lt_self_iff_false] using h.2 h_2\n      | inr h_2 =>\n          rw [← inv_one, ← inv_eq_iff_eq_inv, ← map_inv₀] at hh\n          exact hh.not_lt (h.2 ((one_lt_val_iff v' hx).1 h_2))\n    · intro hh\n      by_contra h_1\n      cases ne_iff_lt_or_gt.1 h_1 with\n      | inl h_2 => simpa [hh, lt_self_iff_false] using h.1 h_2\n      | inr h_2 =>\n        rw [← inv_one, ← inv_eq_iff_eq_inv, ← map_inv₀] at hh\n        exact hh.not_lt (h.1 ((one_lt_val_iff v hx).1 h_2))\n\n"}
{"name":"Valuation.IsEquiv.lt_one_iff_lt_one","module":"Mathlib.RingTheory.Valuation.Basic","initialProofState":"K : Type u_1\ninst✝² : DivisionRing K\nΓ₀ : Type u_4\nΓ'₀ : Type u_5\ninst✝¹ : LinearOrderedCommGroupWithZero Γ₀\ninst✝ : LinearOrderedCommGroupWithZero Γ'₀\nv : Valuation K Γ₀\nv' : Valuation K Γ'₀\na✝ : v.IsEquiv v'\nx : K\n⊢ Iff (LT.lt (v x) 1) (LT.lt (v' x) 1)","decl":"alias ⟨IsEquiv.lt_one_iff_lt_one, _⟩ := isEquiv_iff_val_lt_one\n\n"}
{"name":"Valuation.isEquiv_iff_val_sub_one_lt_one","module":"Mathlib.RingTheory.Valuation.Basic","initialProofState":"K : Type u_1\ninst✝² : DivisionRing K\nΓ₀ : Type u_4\nΓ'₀ : Type u_5\ninst✝¹ : LinearOrderedCommGroupWithZero Γ₀\ninst✝ : LinearOrderedCommGroupWithZero Γ'₀\nv : Valuation K Γ₀\nv' : Valuation K Γ'₀\n⊢ Iff (v.IsEquiv v') (∀ {x : K}, Iff (LT.lt (v (HSub.hSub x 1)) 1) (LT.lt (v' (HSub.hSub x 1)) 1))","decl":"theorem isEquiv_iff_val_sub_one_lt_one [LinearOrderedCommGroupWithZero Γ₀]\n    [LinearOrderedCommGroupWithZero Γ'₀] {v : Valuation K Γ₀} {v' : Valuation K Γ'₀} :\n    v.IsEquiv v' ↔ ∀ {x : K}, v (x - 1) < 1 ↔ v' (x - 1) < 1 := by\n  rw [isEquiv_iff_val_lt_one]\n  exact (Equiv.subRight 1).surjective.forall\n\n"}
{"name":"Valuation.IsEquiv.val_sub_one_lt_one_iff","module":"Mathlib.RingTheory.Valuation.Basic","initialProofState":"K : Type u_1\ninst✝² : DivisionRing K\nΓ₀ : Type u_4\nΓ'₀ : Type u_5\ninst✝¹ : LinearOrderedCommGroupWithZero Γ₀\ninst✝ : LinearOrderedCommGroupWithZero Γ'₀\nv : Valuation K Γ₀\nv' : Valuation K Γ'₀\na✝ : v.IsEquiv v'\nx : K\n⊢ Iff (LT.lt (v (HSub.hSub x 1)) 1) (LT.lt (v' (HSub.hSub x 1)) 1)","decl":"alias ⟨IsEquiv.val_sub_one_lt_one_iff, _⟩ := isEquiv_iff_val_sub_one_lt_one\n\n"}
{"name":"Valuation.isEquiv_tfae","module":"Mathlib.RingTheory.Valuation.Basic","initialProofState":"K : Type u_1\ninst✝² : DivisionRing K\nΓ₀ : Type u_4\nΓ'₀ : Type u_5\ninst✝¹ : LinearOrderedCommGroupWithZero Γ₀\ninst✝ : LinearOrderedCommGroupWithZero Γ'₀\nv : Valuation K Γ₀\nv' : Valuation K Γ'₀\n⊢ (List.cons (v.IsEquiv v') (List.cons (∀ {x y : K}, Iff (LT.lt (v x) (v y)) (LT.lt (v' x) (v' y))) (List.cons (∀ {x : K}, Iff (LE.le (v x) 1) (LE.le (v' x) 1)) (List.cons (∀ {x : K}, Iff (Eq (v x) 1) (Eq (v' x) 1)) (List.cons (∀ {x : K}, Iff (LT.lt (v x) 1) (LT.lt (v' x) 1)) (List.cons (∀ {x : K}, Iff (LT.lt (v (HSub.hSub x 1)) 1) (LT.lt (v' (HSub.hSub x 1)) 1)) List.nil)))))).TFAE","decl":"theorem isEquiv_tfae [LinearOrderedCommGroupWithZero Γ₀] [LinearOrderedCommGroupWithZero Γ'₀]\n    (v : Valuation K Γ₀) (v' : Valuation K Γ'₀) :\n    [ v.IsEquiv v',\n      ∀ {x y}, v x < v y ↔ v' x < v' y,\n      ∀ {x}, v x ≤ 1 ↔ v' x ≤ 1,\n      ∀ {x}, v x = 1 ↔ v' x = 1,\n      ∀ {x}, v x < 1 ↔ v' x < 1,\n      ∀ {x}, v (x - 1) < 1 ↔ v' (x - 1) < 1 ].TFAE := by\n  tfae_have 1 ↔ 2 := isEquiv_iff_val_lt_val\n  tfae_have 1 ↔ 3 := isEquiv_iff_val_le_one\n  tfae_have 1 ↔ 4 := isEquiv_iff_val_eq_one\n  tfae_have 1 ↔ 5 := isEquiv_iff_val_lt_one\n  tfae_have 1 ↔ 6 := isEquiv_iff_val_sub_one_lt_one\n  tfae_finish\n\n"}
{"name":"Valuation.mem_supp_iff","module":"Mathlib.RingTheory.Valuation.Basic","initialProofState":"R : Type u_3\nΓ₀ : Type u_4\ninst✝¹ : CommRing R\ninst✝ : LinearOrderedCommMonoidWithZero Γ₀\nv : Valuation R Γ₀\nx : R\n⊢ Iff (Membership.mem v.supp x) (Eq (v x) 0)","decl":"@[simp]\ntheorem mem_supp_iff (x : R) : x ∈ supp v ↔ v x = 0 :=\n  Iff.rfl\n\n"}
{"name":"Valuation.instIsPrimeSuppOfNontrivialOfNoZeroDivisors","module":"Mathlib.RingTheory.Valuation.Basic","initialProofState":"R : Type u_3\nΓ₀ : Type u_4\ninst✝³ : CommRing R\ninst✝² : LinearOrderedCommMonoidWithZero Γ₀\nv : Valuation R Γ₀\ninst✝¹ : Nontrivial Γ₀\ninst✝ : NoZeroDivisors Γ₀\n⊢ v.supp.IsPrime","decl":"/-- The support of a valuation is a prime ideal. -/\ninstance [Nontrivial Γ₀] [NoZeroDivisors Γ₀] : Ideal.IsPrime (supp v) :=\n  ⟨fun h =>\n    one_ne_zero (α := Γ₀) <|\n      calc\n        1 = v 1 := v.map_one.symm\n        _ = 0 := by rw [← mem_supp_iff, h]; exact Submodule.mem_top,\n   fun {x y} hxy => by\n    simp only [mem_supp_iff] at hxy ⊢\n    rw [v.map_mul x y] at hxy\n    exact eq_zero_or_eq_zero_of_mul_eq_zero hxy⟩\n\n"}
{"name":"Valuation.map_add_supp","module":"Mathlib.RingTheory.Valuation.Basic","initialProofState":"R : Type u_3\nΓ₀ : Type u_4\ninst✝¹ : CommRing R\ninst✝ : LinearOrderedCommMonoidWithZero Γ₀\nv : Valuation R Γ₀\na s : R\nh : Membership.mem v.supp s\n⊢ Eq (v (HAdd.hAdd a s)) (v a)","decl":"theorem map_add_supp (a : R) {s : R} (h : s ∈ supp v) : v (a + s) = v a := by\n  have aux : ∀ a s, v s = 0 → v (a + s) ≤ v a := by\n    intro a' s' h'\n    refine le_trans (v.map_add a' s') (max_le le_rfl ?_)\n    simp [h']\n  apply le_antisymm (aux a s h)\n  calc\n    v a = v (a + s + -s) := by simp\n    _ ≤ v (a + s) := aux (a + s) (-s) (by rwa [← Ideal.neg_mem_iff] at h)\n\n"}
{"name":"Valuation.comap_supp","module":"Mathlib.RingTheory.Valuation.Basic","initialProofState":"R : Type u_3\nΓ₀ : Type u_4\ninst✝² : CommRing R\ninst✝¹ : LinearOrderedCommMonoidWithZero Γ₀\nv : Valuation R Γ₀\nS : Type u_7\ninst✝ : CommRing S\nf : RingHom S R\n⊢ Eq (Valuation.comap f v).supp (Ideal.comap f v.supp)","decl":"theorem comap_supp {S : Type*} [CommRing S] (f : S →+* R) :\n    supp (v.comap f) = Ideal.comap f v.supp :=\n  Ideal.ext fun x => by rw [mem_supp_iff, Ideal.mem_comap, mem_supp_iff, comap_apply]\n\n"}
{"name":"AddValuation.of_apply","module":"Mathlib.RingTheory.Valuation.Basic","initialProofState":"R : Type u_3\nΓ₀ : Type u_4\ninst✝¹ : Ring R\ninst✝ : LinearOrderedAddCommMonoidWithTop Γ₀\nf : R → Γ₀\nh0 : Eq (f 0) Top.top\nh1 : Eq (f 1) 0\nhadd : ∀ (x y : R), LE.le (Min.min (f x) (f y)) (f (HAdd.hAdd x y))\nhmul : ∀ (x y : R), Eq (f (HMul.hMul x y)) (HAdd.hAdd (f x) (f y))\nr : R\n⊢ Eq ((AddValuation.of f h0 h1 hadd hmul) r) (f r)","decl":"@[simp]\ntheorem of_apply : (of f h0 h1 hadd hmul) r = f r := rfl\n\n"}
{"name":"AddValuation.ofValuation_symm_eq","module":"Mathlib.RingTheory.Valuation.Basic","initialProofState":"R : Type u_3\nΓ₀ : Type u_4\ninst✝¹ : Ring R\ninst✝ : LinearOrderedAddCommMonoidWithTop Γ₀\n⊢ Eq AddValuation.ofValuation.symm AddValuation.toValuation","decl":"@[simp]\nlemma ofValuation_symm_eq : ofValuation.symm = toValuation (R := R) (Γ₀ := Γ₀) := rfl\n\n"}
{"name":"AddValuation.toValuation_symm_eq","module":"Mathlib.RingTheory.Valuation.Basic","initialProofState":"R : Type u_3\nΓ₀ : Type u_4\ninst✝¹ : Ring R\ninst✝ : LinearOrderedAddCommMonoidWithTop Γ₀\n⊢ Eq AddValuation.toValuation.symm AddValuation.ofValuation","decl":"@[simp]\nlemma toValuation_symm_eq : toValuation.symm = ofValuation (R := R) (Γ₀ := Γ₀) := rfl\n\n"}
{"name":"AddValuation.ofValuation_toValuation","module":"Mathlib.RingTheory.Valuation.Basic","initialProofState":"R : Type u_3\nΓ₀ : Type u_4\ninst✝¹ : Ring R\ninst✝ : LinearOrderedAddCommMonoidWithTop Γ₀\nv : AddValuation R Γ₀\n⊢ Eq (AddValuation.ofValuation (AddValuation.toValuation v)) v","decl":"@[simp]\nlemma ofValuation_toValuation : ofValuation (toValuation v) = v := rfl\n\n"}
{"name":"AddValuation.toValuation_ofValuation","module":"Mathlib.RingTheory.Valuation.Basic","initialProofState":"R : Type u_3\nΓ₀ : Type u_4\ninst✝¹ : Ring R\ninst✝ : LinearOrderedAddCommMonoidWithTop Γ₀\nv : Valuation R (Multiplicative (OrderDual Γ₀))\n⊢ Eq (AddValuation.toValuation (AddValuation.ofValuation v)) v","decl":"@[simp]\nlemma toValuation_ofValuation (v : Valuation R (Multiplicative Γ₀ᵒᵈ)) :\n    toValuation (ofValuation v) = v := rfl\n\n"}
{"name":"AddValuation.toValuation_apply","module":"Mathlib.RingTheory.Valuation.Basic","initialProofState":"R : Type u_3\nΓ₀ : Type u_4\ninst✝¹ : Ring R\ninst✝ : LinearOrderedAddCommMonoidWithTop Γ₀\nv : AddValuation R Γ₀\nr : R\n⊢ Eq ((AddValuation.toValuation v) r) (Multiplicative.ofAdd (OrderDual.toDual (v r)))","decl":"@[simp]\ntheorem toValuation_apply (r : R) :\n    toValuation v r = Multiplicative.ofAdd (OrderDual.toDual (v r)) :=\n  rfl\n\n"}
{"name":"AddValuation.valuation_apply","module":"Mathlib.RingTheory.Valuation.Basic","initialProofState":"R : Type u_3\nΓ₀ : Type u_4\ninst✝¹ : Ring R\ninst✝ : LinearOrderedAddCommMonoidWithTop Γ₀\nv : AddValuation R Γ₀\nr : R\n⊢ Eq ((AddValuation.toValuation v) r) (Multiplicative.ofAdd (OrderDual.toDual (v r)))","decl":"@[deprecated (since := \"2024-11-09\")]\nalias valuation_apply := toValuation_apply\n\n"}
{"name":"AddValuation.ofValuation_apply","module":"Mathlib.RingTheory.Valuation.Basic","initialProofState":"R : Type u_3\nΓ₀ : Type u_4\ninst✝¹ : Ring R\ninst✝ : LinearOrderedAddCommMonoidWithTop Γ₀\nv : Valuation R (Multiplicative (OrderDual Γ₀))\nr : R\n⊢ Eq ((AddValuation.ofValuation v) r) (OrderDual.ofDual (Multiplicative.toAdd (v r)))","decl":"@[simp]\ntheorem ofValuation_apply (v : Valuation R (Multiplicative Γ₀ᵒᵈ)) (r : R) :\n    ofValuation v r = OrderDual.ofDual (Multiplicative.toAdd (v r)) :=\n  rfl\n\n"}
{"name":"AddValuation.map_zero","module":"Mathlib.RingTheory.Valuation.Basic","initialProofState":"R : Type u_3\nΓ₀ : Type u_4\ninst✝¹ : Ring R\ninst✝ : LinearOrderedAddCommMonoidWithTop Γ₀\nv : AddValuation R Γ₀\n⊢ Eq (v 0) Top.top","decl":"@[simp]\ntheorem map_zero : v 0 = (⊤ : Γ₀) :=\n  Valuation.map_zero v\n\n"}
{"name":"AddValuation.map_one","module":"Mathlib.RingTheory.Valuation.Basic","initialProofState":"R : Type u_3\nΓ₀ : Type u_4\ninst✝¹ : Ring R\ninst✝ : LinearOrderedAddCommMonoidWithTop Γ₀\nv : AddValuation R Γ₀\n⊢ Eq (v 1) 0","decl":"@[simp]\ntheorem map_one : v 1 = (0 : Γ₀) :=\n  Valuation.map_one v\n\n/- Porting note: helper wrapper to coerce `v` to the correct function type -/\n"}
{"name":"AddValuation.map_mul","module":"Mathlib.RingTheory.Valuation.Basic","initialProofState":"R : Type u_3\nΓ₀ : Type u_4\ninst✝¹ : Ring R\ninst✝ : LinearOrderedAddCommMonoidWithTop Γ₀\nv : AddValuation R Γ₀\nx y : R\n⊢ Eq (v (HMul.hMul x y)) (HAdd.hAdd (v x) (v y))","decl":"@[simp]\ntheorem map_mul : ∀ (x y : R), v (x * y) = v x + v y :=\n  Valuation.map_mul v\n\n-- Porting note: LHS simplified so created map_add' and removed simp tag\n"}
{"name":"AddValuation.map_add","module":"Mathlib.RingTheory.Valuation.Basic","initialProofState":"R : Type u_3\nΓ₀ : Type u_4\ninst✝¹ : Ring R\ninst✝ : LinearOrderedAddCommMonoidWithTop Γ₀\nv : AddValuation R Γ₀\nx y : R\n⊢ LE.le (Min.min (v x) (v y)) (v (HAdd.hAdd x y))","decl":"theorem map_add : ∀ (x y : R), min (v x) (v y) ≤ v (x + y) :=\n  Valuation.map_add v\n\n"}
{"name":"AddValuation.map_add'","module":"Mathlib.RingTheory.Valuation.Basic","initialProofState":"R : Type u_3\nΓ₀ : Type u_4\ninst✝¹ : Ring R\ninst✝ : LinearOrderedAddCommMonoidWithTop Γ₀\nv : AddValuation R Γ₀\nx y : R\n⊢ Or (LE.le (v x) (v (HAdd.hAdd x y))) (LE.le (v y) (v (HAdd.hAdd x y)))","decl":"@[simp]\ntheorem map_add' : ∀ (x y : R), v x ≤ v (x + y) ∨ v y ≤ v (x + y) := by\n  intro x y\n  rw [← @min_le_iff _ _ (v x) (v y) (v (x+y)), ← ge_iff_le]\n  apply map_add\n\n"}
{"name":"AddValuation.map_le_add","module":"Mathlib.RingTheory.Valuation.Basic","initialProofState":"R : Type u_3\nΓ₀ : Type u_4\ninst✝¹ : Ring R\ninst✝ : LinearOrderedAddCommMonoidWithTop Γ₀\nv : AddValuation R Γ₀\nx y : R\ng : Γ₀\nhx : LE.le g (v x)\nhy : LE.le g (v y)\n⊢ LE.le g (v (HAdd.hAdd x y))","decl":"theorem map_le_add {x y : R} {g : Γ₀} (hx : g ≤ v x) (hy : g ≤ v y) : g ≤ v (x + y) :=\n  Valuation.map_add_le v hx hy\n\n"}
{"name":"AddValuation.map_lt_add","module":"Mathlib.RingTheory.Valuation.Basic","initialProofState":"R : Type u_3\nΓ₀ : Type u_4\ninst✝¹ : Ring R\ninst✝ : LinearOrderedAddCommMonoidWithTop Γ₀\nv : AddValuation R Γ₀\nx y : R\ng : Γ₀\nhx : LT.lt g (v x)\nhy : LT.lt g (v y)\n⊢ LT.lt g (v (HAdd.hAdd x y))","decl":"theorem map_lt_add {x y : R} {g : Γ₀} (hx : g < v x) (hy : g < v y) : g < v (x + y) :=\n  Valuation.map_add_lt v hx hy\n\n"}
{"name":"AddValuation.map_le_sum","module":"Mathlib.RingTheory.Valuation.Basic","initialProofState":"R : Type u_3\nΓ₀ : Type u_4\ninst✝¹ : Ring R\ninst✝ : LinearOrderedAddCommMonoidWithTop Γ₀\nv : AddValuation R Γ₀\nι : Type u_6\ns : Finset ι\nf : ι → R\ng : Γ₀\nhf : ∀ (i : ι), Membership.mem s i → LE.le g (v (f i))\n⊢ LE.le g (v (s.sum fun i => f i))","decl":"theorem map_le_sum {ι : Type*} {s : Finset ι} {f : ι → R} {g : Γ₀} (hf : ∀ i ∈ s, g ≤ v (f i)) :\n    g ≤ v (∑ i ∈ s, f i) :=\n  v.map_sum_le hf\n\n"}
{"name":"AddValuation.map_lt_sum","module":"Mathlib.RingTheory.Valuation.Basic","initialProofState":"R : Type u_3\nΓ₀ : Type u_4\ninst✝¹ : Ring R\ninst✝ : LinearOrderedAddCommMonoidWithTop Γ₀\nv : AddValuation R Γ₀\nι : Type u_6\ns : Finset ι\nf : ι → R\ng : Γ₀\nhg : Ne g Top.top\nhf : ∀ (i : ι), Membership.mem s i → LT.lt g (v (f i))\n⊢ LT.lt g (v (s.sum fun i => f i))","decl":"theorem map_lt_sum {ι : Type*} {s : Finset ι} {f : ι → R} {g : Γ₀} (hg : g ≠ ⊤)\n    (hf : ∀ i ∈ s, g < v (f i)) : g < v (∑ i ∈ s, f i) :=\n  v.map_sum_lt hg hf\n\n"}
{"name":"AddValuation.map_lt_sum'","module":"Mathlib.RingTheory.Valuation.Basic","initialProofState":"R : Type u_3\nΓ₀ : Type u_4\ninst✝¹ : Ring R\ninst✝ : LinearOrderedAddCommMonoidWithTop Γ₀\nv : AddValuation R Γ₀\nι : Type u_6\ns : Finset ι\nf : ι → R\ng : Γ₀\nhg : LT.lt g Top.top\nhf : ∀ (i : ι), Membership.mem s i → LT.lt g (v (f i))\n⊢ LT.lt g (v (s.sum fun i => f i))","decl":"theorem map_lt_sum' {ι : Type*} {s : Finset ι} {f : ι → R} {g : Γ₀} (hg : g < ⊤)\n    (hf : ∀ i ∈ s, g < v (f i)) : g < v (∑ i ∈ s, f i) :=\n  v.map_sum_lt' hg hf\n\n"}
{"name":"AddValuation.map_pow","module":"Mathlib.RingTheory.Valuation.Basic","initialProofState":"R : Type u_3\nΓ₀ : Type u_4\ninst✝¹ : Ring R\ninst✝ : LinearOrderedAddCommMonoidWithTop Γ₀\nv : AddValuation R Γ₀\nx : R\nn : Nat\n⊢ Eq (v (HPow.hPow x n)) (HSMul.hSMul n (v x))","decl":"@[simp]\ntheorem map_pow : ∀ (x : R) (n : ℕ), v (x ^ n) = n • (v x) :=\n  Valuation.map_pow v\n\n"}
{"name":"AddValuation.ext","module":"Mathlib.RingTheory.Valuation.Basic","initialProofState":"R : Type u_3\nΓ₀ : Type u_4\ninst✝¹ : Ring R\ninst✝ : LinearOrderedAddCommMonoidWithTop Γ₀\nv₁ v₂ : AddValuation R Γ₀\nh : ∀ (r : R), Eq (v₁ r) (v₂ r)\n⊢ Eq v₁ v₂","decl":"@[ext]\ntheorem ext {v₁ v₂ : AddValuation R Γ₀} (h : ∀ r, v₁ r = v₂ r) : v₁ = v₂ :=\n  Valuation.ext h\n\n-- The following definition is not an instance, because we have more than one `v` on a given `R`.\n-- In addition, type class inference would not be able to infer `v`.\n"}
{"name":"AddValuation.ext_iff","module":"Mathlib.RingTheory.Valuation.Basic","initialProofState":"R : Type u_3\nΓ₀ : Type u_4\ninst✝¹ : Ring R\ninst✝ : LinearOrderedAddCommMonoidWithTop Γ₀\nv₁ v₂ : AddValuation R Γ₀\n⊢ Iff (Eq v₁ v₂) (∀ (r : R), Eq (v₁ r) (v₂ r))","decl":"@[ext]\ntheorem ext {v₁ v₂ : AddValuation R Γ₀} (h : ∀ r, v₁ r = v₂ r) : v₁ = v₂ :=\n  Valuation.ext h\n\n-- The following definition is not an instance, because we have more than one `v` on a given `R`.\n-- In addition, type class inference would not be able to infer `v`.\n"}
{"name":"AddValuation.top_iff","module":"Mathlib.RingTheory.Valuation.Basic","initialProofState":"K : Type u_1\ninst✝² : DivisionRing K\nΓ₀ : Type u_4\ninst✝¹ : LinearOrderedAddCommMonoidWithTop Γ₀\ninst✝ : Nontrivial Γ₀\nv : AddValuation K Γ₀\nx : K\n⊢ Iff (Eq (v x) Top.top) (Eq x 0)","decl":"/-- If `v` is an additive valuation on a division ring then `v(x) = ⊤` iff `x = 0`. -/\n@[simp]\ntheorem top_iff [Nontrivial Γ₀] (v : AddValuation K Γ₀) {x : K} : v x = (⊤ : Γ₀) ↔ x = 0 :=\n  v.zero_iff\n\n"}
{"name":"AddValuation.ne_top_iff","module":"Mathlib.RingTheory.Valuation.Basic","initialProofState":"K : Type u_1\ninst✝² : DivisionRing K\nΓ₀ : Type u_4\ninst✝¹ : LinearOrderedAddCommMonoidWithTop Γ₀\ninst✝ : Nontrivial Γ₀\nv : AddValuation K Γ₀\nx : K\n⊢ Iff (Ne (v x) Top.top) (Ne x 0)","decl":"theorem ne_top_iff [Nontrivial Γ₀] (v : AddValuation K Γ₀) {x : K} : v x ≠ (⊤ : Γ₀) ↔ x ≠ 0 :=\n  v.ne_zero_iff\n\n"}
{"name":"AddValuation.comap_id","module":"Mathlib.RingTheory.Valuation.Basic","initialProofState":"R : Type u_3\nΓ₀ : Type u_4\ninst✝¹ : Ring R\ninst✝ : LinearOrderedAddCommMonoidWithTop Γ₀\nv : AddValuation R Γ₀\n⊢ Eq (AddValuation.comap (RingHom.id R) v) v","decl":"@[simp]\ntheorem comap_id : v.comap (RingHom.id R) = v :=\n  Valuation.comap_id v\n\n"}
{"name":"AddValuation.comap_comp","module":"Mathlib.RingTheory.Valuation.Basic","initialProofState":"R : Type u_3\nΓ₀ : Type u_4\ninst✝³ : Ring R\ninst✝² : LinearOrderedAddCommMonoidWithTop Γ₀\nv : AddValuation R Γ₀\nS₁ : Type u_6\nS₂ : Type u_7\ninst✝¹ : Ring S₁\ninst✝ : Ring S₂\nf : RingHom S₁ S₂\ng : RingHom S₂ R\n⊢ Eq (AddValuation.comap (g.comp f) v) (AddValuation.comap f (AddValuation.comap g v))","decl":"theorem comap_comp {S₁ : Type*} {S₂ : Type*} [Ring S₁] [Ring S₂] (f : S₁ →+* S₂) (g : S₂ →+* R) :\n    v.comap (g.comp f) = (v.comap g).comap f :=\n  Valuation.comap_comp v f g\n\n"}
{"name":"AddValuation.map_apply","module":"Mathlib.RingTheory.Valuation.Basic","initialProofState":"R : Type u_3\nΓ₀ : Type u_4\nΓ'₀ : Type u_5\ninst✝² : Ring R\ninst✝¹ : LinearOrderedAddCommMonoidWithTop Γ₀\ninst✝ : LinearOrderedAddCommMonoidWithTop Γ'₀\nf : AddMonoidHom Γ₀ Γ'₀\nht : Eq (f Top.top) Top.top\nhf : Monotone ⇑f\nv : AddValuation R Γ₀\nr : R\n⊢ Eq ((AddValuation.map f ht hf v) r) (f (v r))","decl":"@[simp]\nlemma map_apply (f : Γ₀ →+ Γ'₀) (ht : f ⊤ = ⊤) (hf : Monotone f) (v : AddValuation R Γ₀) (r : R) :\n    v.map f ht hf r = f (v r) := rfl\n\n"}
{"name":"AddValuation.map_neg","module":"Mathlib.RingTheory.Valuation.Basic","initialProofState":"R : Type u_3\nΓ₀ : Type u_4\ninst✝¹ : Ring R\ninst✝ : LinearOrderedAddCommMonoidWithTop Γ₀\nv : AddValuation R Γ₀\nx : R\n⊢ Eq (v (Neg.neg x)) (v x)","decl":"@[simp]\ntheorem map_neg (x : R) : v (-x) = v x :=\n  Valuation.map_neg v x\n\n"}
{"name":"AddValuation.map_sub_swap","module":"Mathlib.RingTheory.Valuation.Basic","initialProofState":"R : Type u_3\nΓ₀ : Type u_4\ninst✝¹ : Ring R\ninst✝ : LinearOrderedAddCommMonoidWithTop Γ₀\nv : AddValuation R Γ₀\nx y : R\n⊢ Eq (v (HSub.hSub x y)) (v (HSub.hSub y x))","decl":"theorem map_sub_swap (x y : R) : v (x - y) = v (y - x) :=\n  Valuation.map_sub_swap v x y\n\n"}
{"name":"AddValuation.map_sub","module":"Mathlib.RingTheory.Valuation.Basic","initialProofState":"R : Type u_3\nΓ₀ : Type u_4\ninst✝¹ : Ring R\ninst✝ : LinearOrderedAddCommMonoidWithTop Γ₀\nv : AddValuation R Γ₀\nx y : R\n⊢ LE.le (Min.min (v x) (v y)) (v (HSub.hSub x y))","decl":"theorem map_sub (x y : R) : min (v x) (v y) ≤ v (x - y) :=\n  Valuation.map_sub v x y\n\n"}
{"name":"AddValuation.map_le_sub","module":"Mathlib.RingTheory.Valuation.Basic","initialProofState":"R : Type u_3\nΓ₀ : Type u_4\ninst✝¹ : Ring R\ninst✝ : LinearOrderedAddCommMonoidWithTop Γ₀\nv : AddValuation R Γ₀\nx y : R\ng : Γ₀\nhx : LE.le g (v x)\nhy : LE.le g (v y)\n⊢ LE.le g (v (HSub.hSub x y))","decl":"theorem map_le_sub {x y : R} {g : Γ₀} (hx : g ≤ v x) (hy : g ≤ v y) : g ≤ v (x - y) :=\n  Valuation.map_sub_le v hx hy\n\n"}
{"name":"AddValuation.map_add_of_distinct_val","module":"Mathlib.RingTheory.Valuation.Basic","initialProofState":"R : Type u_3\nΓ₀ : Type u_4\ninst✝¹ : Ring R\ninst✝ : LinearOrderedAddCommMonoidWithTop Γ₀\nv : AddValuation R Γ₀\nx y : R\nh : Ne (v x) (v y)\n⊢ Eq (v (HAdd.hAdd x y)) (Min.min (v x) (v y))","decl":"theorem map_add_of_distinct_val (h : v x ≠ v y) : v (x + y) = @Min.min Γ₀ _ (v x) (v y) :=\n  Valuation.map_add_of_distinct_val v h\n\n"}
{"name":"AddValuation.map_add_eq_of_lt_left","module":"Mathlib.RingTheory.Valuation.Basic","initialProofState":"R : Type u_3\nΓ₀ : Type u_4\ninst✝¹ : Ring R\ninst✝ : LinearOrderedAddCommMonoidWithTop Γ₀\nv : AddValuation R Γ₀\nx y : R\nh : LT.lt (v x) (v y)\n⊢ Eq (v (HAdd.hAdd x y)) (v x)","decl":"theorem map_add_eq_of_lt_left {x y : R} (h : v x < v y) :\n    v (x + y) = v x := by\n  rw [map_add_of_distinct_val _ h.ne, min_eq_left h.le]\n\n"}
{"name":"AddValuation.map_add_eq_of_lt_right","module":"Mathlib.RingTheory.Valuation.Basic","initialProofState":"R : Type u_3\nΓ₀ : Type u_4\ninst✝¹ : Ring R\ninst✝ : LinearOrderedAddCommMonoidWithTop Γ₀\nv : AddValuation R Γ₀\nx y : R\nhx : LT.lt (v y) (v x)\n⊢ Eq (v (HAdd.hAdd x y)) (v y)","decl":"theorem map_add_eq_of_lt_right {x y : R} (hx : v y < v x) :\n    v (x + y) = v y := add_comm y x ▸ map_add_eq_of_lt_left v hx\n\n"}
{"name":"AddValuation.map_sub_eq_of_lt_left","module":"Mathlib.RingTheory.Valuation.Basic","initialProofState":"R : Type u_3\nΓ₀ : Type u_4\ninst✝¹ : Ring R\ninst✝ : LinearOrderedAddCommMonoidWithTop Γ₀\nv : AddValuation R Γ₀\nx y : R\nhx : LT.lt (v x) (v y)\n⊢ Eq (v (HSub.hSub x y)) (v x)","decl":"theorem map_sub_eq_of_lt_left {x y : R} (hx : v x < v y) :\n    v (x - y) = v x := by\n  rw [sub_eq_add_neg]\n  apply map_add_eq_of_lt_left\n  rwa [map_neg]\n\n"}
{"name":"AddValuation.map_sub_eq_of_lt_right","module":"Mathlib.RingTheory.Valuation.Basic","initialProofState":"R : Type u_3\nΓ₀ : Type u_4\ninst✝¹ : Ring R\ninst✝ : LinearOrderedAddCommMonoidWithTop Γ₀\nv : AddValuation R Γ₀\nx y : R\nhx : LT.lt (v y) (v x)\n⊢ Eq (v (HSub.hSub x y)) (v y)","decl":"theorem map_sub_eq_of_lt_right {x y : R} (hx : v y < v x) :\n    v (x - y) = v y := map_sub_swap v x y ▸ map_sub_eq_of_lt_left v hx\n\n"}
{"name":"AddValuation.map_eq_of_lt_sub","module":"Mathlib.RingTheory.Valuation.Basic","initialProofState":"R : Type u_3\nΓ₀ : Type u_4\ninst✝¹ : Ring R\ninst✝ : LinearOrderedAddCommMonoidWithTop Γ₀\nv : AddValuation R Γ₀\nx y : R\nh : LT.lt (v x) (v (HSub.hSub y x))\n⊢ Eq (v y) (v x)","decl":"theorem map_eq_of_lt_sub (h : v x < v (y - x)) : v y = v x :=\n  Valuation.map_eq_of_sub_lt v h\n\n"}
{"name":"AddValuation.map_inv","module":"Mathlib.RingTheory.Valuation.Basic","initialProofState":"K : Type u_1\ninst✝¹ : DivisionRing K\nΓ₀ : Type u_4\ninst✝ : LinearOrderedAddCommGroupWithTop Γ₀\nv : AddValuation K Γ₀\nx : K\n⊢ Eq (v (Inv.inv x)) (Neg.neg (v x))","decl":"@[simp]\ntheorem map_inv (v : AddValuation K Γ₀) {x : K} : v x⁻¹ = - (v x) :=\n  map_inv₀ (toValuation v) x\n\n"}
{"name":"AddValuation.map_div","module":"Mathlib.RingTheory.Valuation.Basic","initialProofState":"K : Type u_1\ninst✝¹ : DivisionRing K\nΓ₀ : Type u_4\ninst✝ : LinearOrderedAddCommGroupWithTop Γ₀\nv : AddValuation K Γ₀\nx y : K\n⊢ Eq (v (HDiv.hDiv x y)) (HSub.hSub (v x) (v y))","decl":"@[simp]\ntheorem map_div (v : AddValuation K Γ₀) {x y : K} : v (x / y) = v x - v y :=\n  map_div₀ (toValuation v) x y\n\n"}
{"name":"AddValuation.IsEquiv.refl","module":"Mathlib.RingTheory.Valuation.Basic","initialProofState":"R : Type u_3\nΓ₀ : Type u_4\ninst✝¹ : LinearOrderedAddCommMonoidWithTop Γ₀\ninst✝ : Ring R\nv : AddValuation R Γ₀\n⊢ v.IsEquiv v","decl":"@[refl]\ntheorem refl : v.IsEquiv v :=\n  Valuation.IsEquiv.refl\n\n"}
{"name":"AddValuation.IsEquiv.symm","module":"Mathlib.RingTheory.Valuation.Basic","initialProofState":"R : Type u_3\nΓ₀ : Type u_4\nΓ'₀ : Type u_5\ninst✝² : LinearOrderedAddCommMonoidWithTop Γ₀\ninst✝¹ : LinearOrderedAddCommMonoidWithTop Γ'₀\ninst✝ : Ring R\nv₁ : AddValuation R Γ₀\nv₂ : AddValuation R Γ'₀\nh : v₁.IsEquiv v₂\n⊢ v₂.IsEquiv v₁","decl":"@[symm]\ntheorem symm (h : v₁.IsEquiv v₂) : v₂.IsEquiv v₁ :=\n  Valuation.IsEquiv.symm h\n\n"}
{"name":"AddValuation.IsEquiv.trans","module":"Mathlib.RingTheory.Valuation.Basic","initialProofState":"R : Type u_3\nΓ₀ : Type u_4\nΓ'₀ : Type u_5\ninst✝³ : LinearOrderedAddCommMonoidWithTop Γ₀\ninst✝² : LinearOrderedAddCommMonoidWithTop Γ'₀\ninst✝¹ : Ring R\nΓ''₀ : Type u_6\ninst✝ : LinearOrderedAddCommMonoidWithTop Γ''₀\nv₁ : AddValuation R Γ₀\nv₂ : AddValuation R Γ'₀\nv₃ : AddValuation R Γ''₀\nh₁₂ : v₁.IsEquiv v₂\nh₂₃ : v₂.IsEquiv v₃\n⊢ v₁.IsEquiv v₃","decl":"@[trans]\ntheorem trans (h₁₂ : v₁.IsEquiv v₂) (h₂₃ : v₂.IsEquiv v₃) : v₁.IsEquiv v₃ :=\n  Valuation.IsEquiv.trans h₁₂ h₂₃\n\n"}
{"name":"AddValuation.IsEquiv.of_eq","module":"Mathlib.RingTheory.Valuation.Basic","initialProofState":"R : Type u_3\nΓ₀ : Type u_4\ninst✝¹ : LinearOrderedAddCommMonoidWithTop Γ₀\ninst✝ : Ring R\nv v' : AddValuation R Γ₀\nh : Eq v v'\n⊢ v.IsEquiv v'","decl":"theorem of_eq {v' : AddValuation R Γ₀} (h : v = v') : v.IsEquiv v' :=\n  Valuation.IsEquiv.of_eq h\n\n"}
{"name":"AddValuation.IsEquiv.map","module":"Mathlib.RingTheory.Valuation.Basic","initialProofState":"R : Type u_3\nΓ₀ : Type u_4\nΓ'₀ : Type u_5\ninst✝² : LinearOrderedAddCommMonoidWithTop Γ₀\ninst✝¹ : LinearOrderedAddCommMonoidWithTop Γ'₀\ninst✝ : Ring R\nv v' : AddValuation R Γ₀\nf : AddMonoidHom Γ₀ Γ'₀\nht : Eq (f Top.top) Top.top\nhf : Monotone ⇑f\ninf : Function.Injective ⇑f\nh : v.IsEquiv v'\n⊢ (AddValuation.map f ht hf v).IsEquiv (AddValuation.map f ht hf v')","decl":"theorem map {v' : AddValuation R Γ₀} (f : Γ₀ →+ Γ'₀) (ht : f ⊤ = ⊤) (hf : Monotone f)\n    (inf : Injective f) (h : v.IsEquiv v') : (v.map f ht hf).IsEquiv (v'.map f ht hf) :=\n  @Valuation.IsEquiv.map R (Multiplicative Γ₀ᵒᵈ) (Multiplicative Γ'₀ᵒᵈ) _ _ _ _ _\n    { toFun := f\n      map_mul' := f.map_add\n      map_one' := f.map_zero\n      map_zero' := ht } (fun _x _y h => hf h) inf h\n\n"}
{"name":"AddValuation.IsEquiv.comap","module":"Mathlib.RingTheory.Valuation.Basic","initialProofState":"R : Type u_3\nΓ₀ : Type u_4\nΓ'₀ : Type u_5\ninst✝³ : LinearOrderedAddCommMonoidWithTop Γ₀\ninst✝² : LinearOrderedAddCommMonoidWithTop Γ'₀\ninst✝¹ : Ring R\nv₁ : AddValuation R Γ₀\nv₂ : AddValuation R Γ'₀\nS : Type u_7\ninst✝ : Ring S\nf : RingHom S R\nh : v₁.IsEquiv v₂\n⊢ (AddValuation.comap f v₁).IsEquiv (AddValuation.comap f v₂)","decl":"/-- `comap` preserves equivalence. -/\ntheorem comap {S : Type*} [Ring S] (f : S →+* R) (h : v₁.IsEquiv v₂) :\n    (v₁.comap f).IsEquiv (v₂.comap f) :=\n  Valuation.IsEquiv.comap f h\n\n"}
{"name":"AddValuation.IsEquiv.val_eq","module":"Mathlib.RingTheory.Valuation.Basic","initialProofState":"R : Type u_3\nΓ₀ : Type u_4\nΓ'₀ : Type u_5\ninst✝² : LinearOrderedAddCommMonoidWithTop Γ₀\ninst✝¹ : LinearOrderedAddCommMonoidWithTop Γ'₀\ninst✝ : Ring R\nv₁ : AddValuation R Γ₀\nv₂ : AddValuation R Γ'₀\nh : v₁.IsEquiv v₂\nr s : R\n⊢ Iff (Eq (v₁ r) (v₁ s)) (Eq (v₂ r) (v₂ s))","decl":"theorem val_eq (h : v₁.IsEquiv v₂) {r s : R} : v₁ r = v₁ s ↔ v₂ r = v₂ s :=\n  Valuation.IsEquiv.val_eq h\n\n"}
{"name":"AddValuation.IsEquiv.ne_top","module":"Mathlib.RingTheory.Valuation.Basic","initialProofState":"R : Type u_3\nΓ₀ : Type u_4\nΓ'₀ : Type u_5\ninst✝² : LinearOrderedAddCommMonoidWithTop Γ₀\ninst✝¹ : LinearOrderedAddCommMonoidWithTop Γ'₀\ninst✝ : Ring R\nv₁ : AddValuation R Γ₀\nv₂ : AddValuation R Γ'₀\nh : v₁.IsEquiv v₂\nr : R\n⊢ Iff (Ne (v₁ r) Top.top) (Ne (v₂ r) Top.top)","decl":"theorem ne_top (h : v₁.IsEquiv v₂) {r : R} : v₁ r ≠ (⊤ : Γ₀) ↔ v₂ r ≠ (⊤ : Γ'₀) :=\n  Valuation.IsEquiv.ne_zero h\n\n"}
{"name":"AddValuation.mem_supp_iff","module":"Mathlib.RingTheory.Valuation.Basic","initialProofState":"R : Type u_3\nΓ₀ : Type u_4\ninst✝¹ : LinearOrderedAddCommMonoidWithTop Γ₀\ninst✝ : CommRing R\nv : AddValuation R Γ₀\nx : R\n⊢ Iff (Membership.mem v.supp x) (Eq (v x) Top.top)","decl":"@[simp]\ntheorem mem_supp_iff (x : R) : x ∈ supp v ↔ v x = (⊤ : Γ₀) :=\n  Valuation.mem_supp_iff v x\n\n"}
{"name":"AddValuation.map_add_supp","module":"Mathlib.RingTheory.Valuation.Basic","initialProofState":"R : Type u_3\nΓ₀ : Type u_4\ninst✝¹ : LinearOrderedAddCommMonoidWithTop Γ₀\ninst✝ : CommRing R\nv : AddValuation R Γ₀\na s : R\nh : Membership.mem v.supp s\n⊢ Eq (v (HAdd.hAdd a s)) (v a)","decl":"theorem map_add_supp (a : R) {s : R} (h : s ∈ supp v) : v (a + s) = v a :=\n  Valuation.map_add_supp v a h\n\n"}
{"name":"Valuation.ofAddValuation_symm_eq","module":"Mathlib.RingTheory.Valuation.Basic","initialProofState":"R : Type u_3\nΓ₀ : Type u_5\ninst✝¹ : Ring R\ninst✝ : LinearOrderedCommMonoidWithZero Γ₀\n⊢ Eq Valuation.ofAddValuation.symm Valuation.toAddValuation","decl":"@[simp]\nlemma ofAddValuation_symm_eq : ofAddValuation.symm = toAddValuation (R := R) (Γ₀ := Γ₀) := rfl\n\n"}
{"name":"Valuation.toAddValuation_symm_eq","module":"Mathlib.RingTheory.Valuation.Basic","initialProofState":"R : Type u_3\nΓ₀ : Type u_5\ninst✝¹ : Ring R\ninst✝ : LinearOrderedCommMonoidWithZero Γ₀\n⊢ Eq Valuation.toAddValuation.symm Valuation.ofAddValuation","decl":"@[simp]\nlemma toAddValuation_symm_eq : toAddValuation.symm = ofAddValuation (R := R) (Γ₀ := Γ₀) := rfl\n\n"}
{"name":"Valuation.ofAddValuation_toAddValuation","module":"Mathlib.RingTheory.Valuation.Basic","initialProofState":"R : Type u_3\nΓ₀ : Type u_5\ninst✝¹ : Ring R\ninst✝ : LinearOrderedCommMonoidWithZero Γ₀\nv : Valuation R Γ₀\n⊢ Eq (Valuation.ofAddValuation (Valuation.toAddValuation v)) v","decl":"@[simp]\nlemma ofAddValuation_toAddValuation (v : Valuation R Γ₀) :\n  ofAddValuation (toAddValuation v) = v := rfl\n\n"}
{"name":"Valuation.toValuation_ofValuation","module":"Mathlib.RingTheory.Valuation.Basic","initialProofState":"R : Type u_3\nΓ₀ : Type u_5\ninst✝¹ : Ring R\ninst✝ : LinearOrderedCommMonoidWithZero Γ₀\nv : AddValuation R (OrderDual (Additive Γ₀))\n⊢ Eq (Valuation.toAddValuation (Valuation.ofAddValuation v)) v","decl":"@[simp]\nlemma toValuation_ofValuation (v : AddValuation R (Additive Γ₀)ᵒᵈ) :\n    toAddValuation (ofAddValuation v) = v := rfl\n\n"}
{"name":"Valuation.toAddValuation_apply","module":"Mathlib.RingTheory.Valuation.Basic","initialProofState":"R : Type u_3\nΓ₀ : Type u_5\ninst✝¹ : Ring R\ninst✝ : LinearOrderedCommMonoidWithZero Γ₀\nv : Valuation R Γ₀\nr : R\n⊢ Eq ((Valuation.toAddValuation v) r) (OrderDual.toDual (Additive.ofMul (v r)))","decl":"@[simp]\ntheorem toAddValuation_apply (v : Valuation R Γ₀) (r : R) :\n    toAddValuation v r = OrderDual.toDual (Additive.ofMul (v r)) :=\n  rfl\n\n"}
{"name":"Valuation.ofAddValuation_apply","module":"Mathlib.RingTheory.Valuation.Basic","initialProofState":"R : Type u_3\nΓ₀ : Type u_5\ninst✝¹ : Ring R\ninst✝ : LinearOrderedCommMonoidWithZero Γ₀\nv : AddValuation R (OrderDual (Additive Γ₀))\nr : R\n⊢ Eq ((Valuation.ofAddValuation v) r) (Additive.toMul (OrderDual.ofDual (v r)))","decl":"@[simp]\ntheorem ofAddValuation_apply (v : AddValuation R (Additive Γ₀)ᵒᵈ) (r : R) :\n    ofAddValuation v r = Additive.toMul (OrderDual.ofDual (v r)) :=\n  rfl\n\n"}
{"name":"Valuation.val_mrange_zero","module":"Mathlib.RingTheory.Valuation.Basic","initialProofState":"R : Type u_3\nΓ₀ : Type u_5\ninst✝¹ : Ring R\ninst✝ : LinearOrderedCommMonoidWithZero Γ₀\nv : Valuation R Γ₀\n⊢ Eq (↑0) 0","decl":"@[simp]\nlemma val_mrange_zero (v : Valuation R Γ₀) : ((0 : MonoidHom.mrange v) : Γ₀) = 0 := rfl\n\n"}
