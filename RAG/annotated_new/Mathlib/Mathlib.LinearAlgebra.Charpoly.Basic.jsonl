{"name":"LinearMap.charpoly_def","module":"Mathlib.LinearAlgebra.Charpoly.Basic","initialProofState":"R : Type u\nM : Type v\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : Module.Free R M\ninst✝ : Module.Finite R M\nf : LinearMap (RingHom.id R) M M\n⊢ Eq f.charpoly ((LinearMap.toMatrix (Module.Free.chooseBasis R M) (Module.Free.chooseBasis R M)) f).charpoly","decl":"theorem charpoly_def : f.charpoly = (toMatrix (chooseBasis R M) (chooseBasis R M) f).charpoly :=\n  rfl\n\n"}
{"name":"LinearMap.charpoly_monic","module":"Mathlib.LinearAlgebra.Charpoly.Basic","initialProofState":"R : Type u\nM : Type v\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : Module.Free R M\ninst✝ : Module.Finite R M\nf : LinearMap (RingHom.id R) M M\n⊢ f.charpoly.Monic","decl":"theorem charpoly_monic : f.charpoly.Monic :=\n  Matrix.charpoly_monic _\n\n"}
{"name":"LinearMap.charpoly_natDegree","module":"Mathlib.LinearAlgebra.Charpoly.Basic","initialProofState":"R : Type u\nM : Type v\ninst✝⁶ : CommRing R\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\ninst✝³ : Module.Free R M\ninst✝² : Module.Finite R M\nf : LinearMap (RingHom.id R) M M\ninst✝¹ : Nontrivial R\ninst✝ : StrongRankCondition R\n⊢ Eq f.charpoly.natDegree (Module.finrank R M)","decl":"open Module in\nlemma charpoly_natDegree [Nontrivial R] [StrongRankCondition R] :\n    natDegree (charpoly f) = finrank R M := by\n  rw [charpoly, Matrix.charpoly_natDegree_eq_dim, finrank_eq_card_chooseBasisIndex]\n\n"}
{"name":"LinearMap.aeval_self_charpoly","module":"Mathlib.LinearAlgebra.Charpoly.Basic","initialProofState":"R : Type u\nM : Type v\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : Module.Free R M\ninst✝ : Module.Finite R M\nf : LinearMap (RingHom.id R) M M\n⊢ Eq ((Polynomial.aeval f) f.charpoly) 0","decl":"/-- The **Cayley-Hamilton Theorem**, that the characteristic polynomial of a linear map, applied\nto the linear map itself, is zero.\n\nSee `Matrix.aeval_self_charpoly` for the equivalent statement about matrices. -/\ntheorem aeval_self_charpoly : aeval f f.charpoly = 0 := by\n  apply (LinearEquiv.map_eq_zero_iff (algEquivMatrix (chooseBasis R M)).toLinearEquiv).1\n  rw [AlgEquiv.toLinearEquiv_apply, ← AlgEquiv.coe_algHom, ← Polynomial.aeval_algHom_apply _ _ _,\n    charpoly_def]\n  exact Matrix.aeval_self_charpoly _\n\n"}
{"name":"LinearMap.isIntegral","module":"Mathlib.LinearAlgebra.Charpoly.Basic","initialProofState":"R : Type u\nM : Type v\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : Module.Free R M\ninst✝ : Module.Finite R M\nf : LinearMap (RingHom.id R) M M\n⊢ IsIntegral R f","decl":"theorem isIntegral : IsIntegral R f :=\n  ⟨f.charpoly, ⟨charpoly_monic f, aeval_self_charpoly f⟩⟩\n\n"}
{"name":"LinearMap.minpoly_dvd_charpoly","module":"Mathlib.LinearAlgebra.Charpoly.Basic","initialProofState":"K : Type u\nM : Type v\ninst✝³ : Field K\ninst✝² : AddCommGroup M\ninst✝¹ : Module K M\ninst✝ : FiniteDimensional K M\nf : LinearMap (RingHom.id K) M M\n⊢ Dvd.dvd (minpoly K f) f.charpoly","decl":"theorem minpoly_dvd_charpoly {K : Type u} {M : Type v} [Field K] [AddCommGroup M] [Module K M]\n    [FiniteDimensional K M] (f : M →ₗ[K] M) : minpoly K f ∣ f.charpoly :=\n  minpoly.dvd _ _ (aeval_self_charpoly f)\n\n"}
{"name":"LinearMap.aeval_eq_aeval_mod_charpoly","module":"Mathlib.LinearAlgebra.Charpoly.Basic","initialProofState":"R : Type u\nM : Type v\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : Module.Free R M\ninst✝ : Module.Finite R M\nf : LinearMap (RingHom.id R) M M\np : Polynomial R\n⊢ Eq ((Polynomial.aeval f) p) ((Polynomial.aeval f) (p.modByMonic f.charpoly))","decl":"/-- Any endomorphism polynomial `p` is equivalent under evaluation to `p %ₘ f.charpoly`; that is,\n`p` is equivalent to a polynomial with degree less than the dimension of the module. -/\ntheorem aeval_eq_aeval_mod_charpoly (p : R[X]) : aeval f p = aeval f (p %ₘ f.charpoly) :=\n  (aeval_modByMonic_eq_self_of_root f.charpoly_monic f.aeval_self_charpoly).symm\n\n"}
{"name":"LinearMap.pow_eq_aeval_mod_charpoly","module":"Mathlib.LinearAlgebra.Charpoly.Basic","initialProofState":"R : Type u\nM : Type v\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : Module.Free R M\ninst✝ : Module.Finite R M\nf : LinearMap (RingHom.id R) M M\nk : Nat\n⊢ Eq (HPow.hPow f k) ((Polynomial.aeval f) ((HPow.hPow Polynomial.X k).modByMonic f.charpoly))","decl":"/-- Any endomorphism power can be computed as the sum of endomorphism powers less than the\ndimension of the module. -/\ntheorem pow_eq_aeval_mod_charpoly (k : ℕ) : f ^ k = aeval f (X ^ k %ₘ f.charpoly) := by\n  rw [← aeval_eq_aeval_mod_charpoly, map_pow, aeval_X]\n\n"}
{"name":"LinearMap.minpoly_coeff_zero_of_injective","module":"Mathlib.LinearAlgebra.Charpoly.Basic","initialProofState":"R : Type u\nM : Type v\ninst✝⁵ : CommRing R\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\ninst✝² : Module.Free R M\ninst✝¹ : Module.Finite R M\nf : LinearMap (RingHom.id R) M M\ninst✝ : Nontrivial R\nhf : Function.Injective ⇑f\n⊢ Ne ((minpoly R f).coeff 0) 0","decl":"theorem minpoly_coeff_zero_of_injective [Nontrivial R] (hf : Function.Injective f) :\n    (minpoly R f).coeff 0 ≠ 0 := by\n  intro h\n  obtain ⟨P, hP⟩ := X_dvd_iff.2 h\n  have hdegP : P.degree < (minpoly R f).degree := by\n    rw [hP, mul_comm]\n    refine degree_lt_degree_mul_X fun h => ?_\n    rw [h, mul_zero] at hP\n    exact minpoly.ne_zero (isIntegral f) hP\n  have hPmonic : P.Monic := by\n    suffices (minpoly R f).Monic by\n      rwa [Monic.def, hP, mul_comm, leadingCoeff_mul_X, ← Monic.def] at this\n    exact minpoly.monic (isIntegral f)\n  have hzero : aeval f (minpoly R f) = 0 := minpoly.aeval _ _\n  simp only [hP, mul_eq_comp, LinearMap.ext_iff, hf, aeval_X, map_eq_zero_iff, coe_comp,\n    _root_.map_mul, zero_apply, Function.comp_apply] at hzero\n  exact not_le.2 hdegP (minpoly.min _ _ hPmonic (LinearMap.ext hzero))\n\n"}
