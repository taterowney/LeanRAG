{"name":"extend_partialOrder","module":"Mathlib.Order.Extension.Linear","initialProofState":"α : Type u\nr : α → α → Prop\ninst✝ : IsPartialOrder α r\n⊢ Exists fun s => And (IsLinearOrder α s) (LE.le r s)","decl":"/-- Any partial order can be extended to a linear order.\n-/\ntheorem extend_partialOrder {α : Type u} (r : α → α → Prop) [IsPartialOrder α r] :\n    ∃ s : α → α → Prop, IsLinearOrder α s ∧ r ≤ s := by\n  let S := { s | IsPartialOrder α s }\n  have hS : ∀ c, c ⊆ S → IsChain (· ≤ ·) c → ∀ y ∈ c, ∃ ub ∈ S, ∀ z ∈ c, z ≤ ub := by\n    rintro c hc₁ hc₂ s hs\n    haveI := (hc₁ hs).1\n    refine ⟨sSup c, ?_, fun z hz => le_sSup hz⟩\n    refine\n        { refl := ?_\n          trans := ?_\n          antisymm := ?_ } <;>\n      simp_rw [binary_relation_sSup_iff]\n    · intro x\n      exact ⟨s, hs, refl x⟩\n    · rintro x y z ⟨s₁, h₁s₁, h₂s₁⟩ ⟨s₂, h₁s₂, h₂s₂⟩\n      haveI : IsPartialOrder _ _ := hc₁ h₁s₁\n      haveI : IsPartialOrder _ _ := hc₁ h₁s₂\n      cases' hc₂.total h₁s₁ h₁s₂ with h h\n      · exact ⟨s₂, h₁s₂, _root_.trans (h _ _ h₂s₁) h₂s₂⟩\n      · exact ⟨s₁, h₁s₁, _root_.trans h₂s₁ (h _ _ h₂s₂)⟩\n    · rintro x y ⟨s₁, h₁s₁, h₂s₁⟩ ⟨s₂, h₁s₂, h₂s₂⟩\n      haveI : IsPartialOrder _ _ := hc₁ h₁s₁\n      haveI : IsPartialOrder _ _ := hc₁ h₁s₂\n      cases' hc₂.total h₁s₁ h₁s₂ with h h\n      · exact antisymm (h _ _ h₂s₁) h₂s₂\n      · apply antisymm h₂s₁ (h _ _ h₂s₂)\n  obtain ⟨s, hrs, hs⟩ := zorn_le_nonempty₀ S hS r ‹_›\n  haveI : IsPartialOrder α s := hs.prop\n  refine ⟨s,\n    { total := ?_, refl := hs.1.refl, trans := hs.1.trans, antisymm := hs.1.antisymm }, hrs⟩\n  intro x y\n  by_contra! h\n  let s' x' y' := s x' y' ∨ s x' x ∧ s y y'\n  rw [hs.eq_of_le (y := s') ?_ fun _ _ ↦ Or.inl] at h\n  · apply h.1 (Or.inr ⟨refl _, refl _⟩)\n  · refine\n    { refl := fun x ↦ Or.inl (refl _)\n      trans := ?_\n      antisymm := ?_ }\n    · rintro a b c (ab | ⟨ax : s a x, yb : s y b⟩) (bc | ⟨bx : s b x, yc : s y c⟩)\n      · exact Or.inl (_root_.trans ab bc)\n      · exact Or.inr ⟨_root_.trans ab bx, yc⟩\n      · exact Or.inr ⟨ax, _root_.trans yb bc⟩\n      · exact Or.inr ⟨ax, yc⟩\n    rintro a b (ab | ⟨ax : s a x, yb : s y b⟩) (ba | ⟨bx : s b x, ya : s y a⟩)\n    · exact antisymm ab ba\n    · exact (h.2 (_root_.trans ya (_root_.trans ab bx))).elim\n    · exact (h.2 (_root_.trans yb (_root_.trans ba ax))).elim\n    · exact (h.2 (_root_.trans yb bx)).elim\n\n"}
