{"name":"ModuleCat.wellPowered_moduleCat","module":"Mathlib.Algebra.Category.ModuleCat.Subobject","initialProofState":"R : Type u\ninst✝ : Ring R\n⊢ CategoryTheory.WellPowered.{v, v, max (v + 1) u} (ModuleCat R)","decl":"instance wellPowered_moduleCat : WellPowered.{v} (ModuleCat.{v} R) :=\n  ⟨fun M => ⟨⟨_, ⟨(subobjectModule M).toEquiv⟩⟩⟩⟩\n\n"}
{"name":"ModuleCat.toKernelSubobject_arrow","module":"Mathlib.Algebra.Category.ModuleCat.Subobject","initialProofState":"R : Type u\ninst✝ : Ring R\nM N : ModuleCat R\nf : Quiver.Hom M N\nx : Subtype fun x => Membership.mem (LinearMap.ker (ModuleCat.Hom.hom f)) x\n⊢ Eq ((CategoryTheory.ConcreteCategory.hom (CategoryTheory.Limits.kernelSubobject f).arrow) (ModuleCat.toKernelSubobject x)) ↑x","decl":"@[simp]\ntheorem toKernelSubobject_arrow {M N : ModuleCat R} {f : M ⟶ N} (x : LinearMap.ker f.hom) :\n    (kernelSubobject f).arrow (toKernelSubobject x) = x.1 := by\n  -- Porting note (https://github.com/leanprover-community/mathlib4/pull/10959): the whole proof was just `simp [toKernelSubobject]`.\n  suffices ((arrow ((kernelSubobject f))) ∘ (kernelSubobjectIso f ≪≫ kernelIsoKer f).inv) x = x by\n    convert this\n  rw [Iso.trans_inv, ← LinearMap.coe_comp, ← hom_comp, Category.assoc]\n  simp\n\n"}
{"name":"ModuleCat.cokernel_π_imageSubobject_ext","module":"Mathlib.Algebra.Category.ModuleCat.Subobject","initialProofState":"R : Type u\ninst✝² : Ring R\nL M N : ModuleCat R\nf : Quiver.Hom L M\ninst✝¹ : CategoryTheory.Limits.HasImage f\ng : Quiver.Hom (CategoryTheory.Subobject.underlying.obj (CategoryTheory.Limits.imageSubobject f)) N\ninst✝ : CategoryTheory.Limits.HasCokernel g\nx y : ↑N\nl : ↑L\nw : Eq x (HAdd.hAdd y ((CategoryTheory.ConcreteCategory.hom g) ((CategoryTheory.ConcreteCategory.hom (CategoryTheory.Limits.factorThruImageSubobject f)) l)))\n⊢ Eq ((CategoryTheory.ConcreteCategory.hom (CategoryTheory.Limits.cokernel.π g)) x) ((CategoryTheory.ConcreteCategory.hom (CategoryTheory.Limits.cokernel.π g)) y)","decl":"/-- An extensionality lemma showing that two elements of a cokernel by an image\nare equal if they differ by an element of the image.\n\nThe application is for homology:\ntwo elements in homology are equal if they differ by a boundary.\n-/\n-- Porting note (https://github.com/leanprover-community/mathlib4/pull/11215): TODO compiler complains that this is marked with `@[ext]`.\n-- Should this be changed?\n-- @[ext] this is no longer an ext lemma under the current interpretation see eg\n-- the conversation beginning at\n-- https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/\n-- Goal.20state.20not.20updating.2C.20bugs.2C.20etc.2E/near/338456803\ntheorem cokernel_π_imageSubobject_ext {L M N : ModuleCat.{v} R} (f : L ⟶ M) [HasImage f]\n    (g : (imageSubobject f : ModuleCat.{v} R) ⟶ N) [HasCokernel g] {x y : N} (l : L)\n    (w : x = y + g (factorThruImageSubobject f l)) : cokernel.π g x = cokernel.π g y := by\n  subst w\n  -- Porting note (https://github.com/leanprover-community/mathlib4/pull/10959): The proof from here used to just be `simp`.\n  simp only [map_add, add_right_eq_self]\n  -- TODO: add a `@[simp]` lemma along the lines of:\n  -- ```\n  -- lemma ModuleCat.Hom.cokernel_condition : (cokernel.π g).hom (g.hom x) = 0\n  -- ```\n  -- ideally generated for all concrete categories (using a metaprogram like `@[elementwise]`?).\n  -- See also: https://github.com/leanprover-community/mathlib4/pull/19511#discussion_r1867083077\n  change ((factorThruImageSubobject f) ≫ g ≫ (cokernel.π g)).hom l = 0\n  simp\n\n"}
