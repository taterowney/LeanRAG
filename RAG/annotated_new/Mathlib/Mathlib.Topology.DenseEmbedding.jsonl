{"name":"IsDenseInducing.toIsInducing","module":"Mathlib.Topology.DenseEmbedding","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : TopologicalSpace α\ninst✝ : TopologicalSpace β\ni : α → β\nself : IsDenseInducing i\n⊢ Topology.IsInducing i","decl":"/-- `i : α → β` is \"dense inducing\" if it has dense range and the topology on `α`\n  is the one induced by `i` from the topology on `β`. -/\nstructure IsDenseInducing [TopologicalSpace α] [TopologicalSpace β] (i : α → β)\n    extends IsInducing i : Prop where\n  /-- The range of a dense inducing map is a dense set. -/\n  protected dense : DenseRange i\n\n"}
{"name":"IsDenseInducing.dense","module":"Mathlib.Topology.DenseEmbedding","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : TopologicalSpace α\ninst✝ : TopologicalSpace β\ni : α → β\nself : IsDenseInducing i\n⊢ DenseRange i","decl":"/-- `i : α → β` is \"dense inducing\" if it has dense range and the topology on `α`\n  is the one induced by `i` from the topology on `β`. -/\nstructure IsDenseInducing [TopologicalSpace α] [TopologicalSpace β] (i : α → β)\n    extends IsInducing i : Prop where\n  /-- The range of a dense inducing map is a dense set. -/\n  protected dense : DenseRange i\n\n"}
{"name":"Dense.isDenseInducing_val","module":"Mathlib.Topology.DenseEmbedding","initialProofState":"α : Type u_1\ninst✝ : TopologicalSpace α\ns : Set α\nhs : Dense s\n⊢ IsDenseInducing Subtype.val","decl":"theorem _root_.Dense.isDenseInducing_val {s : Set α} (hs : Dense s) :\n    IsDenseInducing (@Subtype.val α s) := ⟨IsInducing.subtypeVal, hs.denseRange_val⟩\n\n"}
{"name":"IsDenseInducing.isInducing","module":"Mathlib.Topology.DenseEmbedding","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : TopologicalSpace α\ninst✝ : TopologicalSpace β\ni : α → β\ndi : IsDenseInducing i\n⊢ Topology.IsInducing i","decl":"lemma isInducing (di : IsDenseInducing i) : IsInducing i := di.toIsInducing\n\n"}
{"name":"IsDenseInducing.nhds_eq_comap","module":"Mathlib.Topology.DenseEmbedding","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : TopologicalSpace α\ninst✝ : TopologicalSpace β\ni : α → β\ndi : IsDenseInducing i\na : α\n⊢ Eq (nhds a) (Filter.comap i (nhds (i a)))","decl":"theorem nhds_eq_comap (di : IsDenseInducing i) : ∀ a : α, 𝓝 a = comap i (𝓝 <| i a) :=\n  di.isInducing.nhds_eq_comap\n\n"}
{"name":"IsDenseInducing.continuous","module":"Mathlib.Topology.DenseEmbedding","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : TopologicalSpace α\ninst✝ : TopologicalSpace β\ni : α → β\ndi : IsDenseInducing i\n⊢ Continuous i","decl":"protected theorem continuous (di : IsDenseInducing i) : Continuous i :=\n  di.isInducing.continuous\n\n"}
{"name":"IsDenseInducing.closure_range","module":"Mathlib.Topology.DenseEmbedding","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : TopologicalSpace α\ninst✝ : TopologicalSpace β\ni : α → β\ndi : IsDenseInducing i\n⊢ Eq (closure (Set.range i)) Set.univ","decl":"theorem closure_range (di : IsDenseInducing i) : closure (range i) = univ :=\n  di.dense.closure_range\n\n"}
{"name":"IsDenseInducing.preconnectedSpace","module":"Mathlib.Topology.DenseEmbedding","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : TopologicalSpace α\ninst✝¹ : TopologicalSpace β\ni : α → β\ninst✝ : PreconnectedSpace α\ndi : IsDenseInducing i\n⊢ PreconnectedSpace β","decl":"protected theorem preconnectedSpace [PreconnectedSpace α] (di : IsDenseInducing i) :\n    PreconnectedSpace β :=\n  di.dense.preconnectedSpace di.continuous\n\n"}
{"name":"IsDenseInducing.closure_image_mem_nhds","module":"Mathlib.Topology.DenseEmbedding","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : TopologicalSpace α\ninst✝ : TopologicalSpace β\ni : α → β\ns : Set α\na : α\ndi : IsDenseInducing i\nhs : Membership.mem (nhds a) s\n⊢ Membership.mem (nhds (i a)) (closure (Set.image i s))","decl":"theorem closure_image_mem_nhds {s : Set α} {a : α} (di : IsDenseInducing i) (hs : s ∈ 𝓝 a) :\n    closure (i '' s) ∈ 𝓝 (i a) := by\n  rw [di.nhds_eq_comap a, ((nhds_basis_opens _).comap _).mem_iff] at hs\n  rcases hs with ⟨U, ⟨haU, hUo⟩, sub : i ⁻¹' U ⊆ s⟩\n  refine mem_of_superset (hUo.mem_nhds haU) ?_\n  calc\n    U ⊆ closure (i '' (i ⁻¹' U)) := di.dense.subset_closure_image_preimage_of_isOpen hUo\n    _ ⊆ closure (i '' s) := closure_mono (image_subset i sub)\n\n"}
{"name":"IsDenseInducing.dense_image","module":"Mathlib.Topology.DenseEmbedding","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : TopologicalSpace α\ninst✝ : TopologicalSpace β\ni : α → β\ndi : IsDenseInducing i\ns : Set α\n⊢ Iff (Dense (Set.image i s)) (Dense s)","decl":"theorem dense_image (di : IsDenseInducing i) {s : Set α} : Dense (i '' s) ↔ Dense s := by\n  refine ⟨fun H x => ?_, di.dense.dense_image di.continuous⟩\n  rw [di.isInducing.closure_eq_preimage_closure_image, H.closure_eq, preimage_univ]\n  trivial\n\n"}
{"name":"IsDenseInducing.interior_compact_eq_empty","module":"Mathlib.Topology.DenseEmbedding","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : TopologicalSpace α\ninst✝¹ : TopologicalSpace β\ni : α → β\ninst✝ : T2Space β\ndi : IsDenseInducing i\nhd : Dense (HasCompl.compl (Set.range i))\ns : Set α\nhs : IsCompact s\n⊢ Eq (interior s) EmptyCollection.emptyCollection","decl":"/-- If `i : α → β` is a dense embedding with dense complement of the range, then any compact set in\n`α` has empty interior. -/\ntheorem interior_compact_eq_empty [T2Space β] (di : IsDenseInducing i) (hd : Dense (range i)ᶜ)\n    {s : Set α} (hs : IsCompact s) : interior s = ∅ := by\n  refine eq_empty_iff_forall_not_mem.2 fun x hx => ?_\n  rw [mem_interior_iff_mem_nhds] at hx\n  have := di.closure_image_mem_nhds hx\n  rw [(hs.image di.continuous).isClosed.closure_eq] at this\n  rcases hd.inter_nhds_nonempty this with ⟨y, hyi, hys⟩\n  exact hyi (image_subset_range _ _ hys)\n\n"}
{"name":"IsDenseInducing.prodMap","module":"Mathlib.Topology.DenseEmbedding","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nδ : Type u_4\ninst✝³ : TopologicalSpace α\ninst✝² : TopologicalSpace β\ninst✝¹ : TopologicalSpace γ\ninst✝ : TopologicalSpace δ\ne₁ : α → β\ne₂ : γ → δ\nde₁ : IsDenseInducing e₁\nde₂ : IsDenseInducing e₂\n⊢ IsDenseInducing (Prod.map e₁ e₂)","decl":"/-- The product of two dense inducings is a dense inducing -/\nprotected theorem prodMap [TopologicalSpace γ] [TopologicalSpace δ] {e₁ : α → β} {e₂ : γ → δ}\n    (de₁ : IsDenseInducing e₁) (de₂ : IsDenseInducing e₂) :\n    IsDenseInducing (Prod.map e₁ e₂) where\n  toIsInducing := de₁.isInducing.prodMap de₂.isInducing\n  dense := de₁.dense.prodMap de₂.dense\n\n"}
{"name":"IsDenseInducing.prod","module":"Mathlib.Topology.DenseEmbedding","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nδ : Type u_4\ninst✝³ : TopologicalSpace α\ninst✝² : TopologicalSpace β\ninst✝¹ : TopologicalSpace γ\ninst✝ : TopologicalSpace δ\ne₁ : α → β\ne₂ : γ → δ\nde₁ : IsDenseInducing e₁\nde₂ : IsDenseInducing e₂\n⊢ IsDenseInducing (Prod.map e₁ e₂)","decl":"@[deprecated (since := \"2024-10-06\")]\nprotected alias prod := IsDenseInducing.prodMap\n\n"}
{"name":"IsDenseInducing.separableSpace","module":"Mathlib.Topology.DenseEmbedding","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : TopologicalSpace α\ninst✝¹ : TopologicalSpace β\ni : α → β\ninst✝ : TopologicalSpace.SeparableSpace α\ndi : IsDenseInducing i\n⊢ TopologicalSpace.SeparableSpace β","decl":"/-- If the domain of a `IsDenseInducing` map is a separable space, then so is the codomain. -/\nprotected theorem separableSpace [SeparableSpace α] (di : IsDenseInducing i) : SeparableSpace β :=\n  di.dense.separableSpace di.continuous\n\n"}
{"name":"IsDenseInducing.tendsto_comap_nhds_nhds","module":"Mathlib.Topology.DenseEmbedding","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nδ : Type u_4\ninst✝² : TopologicalSpace α\ninst✝¹ : TopologicalSpace β\ni : α → β\ninst✝ : TopologicalSpace δ\nf : γ → α\ng : γ → δ\nh : δ → β\nd : δ\na : α\ndi : IsDenseInducing i\nH : Filter.Tendsto h (nhds d) (nhds (i a))\ncomm : Eq (Function.comp h g) (Function.comp i f)\n⊢ Filter.Tendsto f (Filter.comap g (nhds d)) (nhds a)","decl":"/--\n```\n γ -f→ α\ng↓     ↓e\n δ -h→ β\n```\n-/\ntheorem tendsto_comap_nhds_nhds {d : δ} {a : α} (di : IsDenseInducing i)\n    (H : Tendsto h (𝓝 d) (𝓝 (i a))) (comm : h ∘ g = i ∘ f) : Tendsto f (comap g (𝓝 d)) (𝓝 a) := by\n  have lim1 : map g (comap g (𝓝 d)) ≤ 𝓝 d := map_comap_le\n  replace lim1 : map h (map g (comap g (𝓝 d))) ≤ map h (𝓝 d) := map_mono lim1\n  rw [Filter.map_map, comm, ← Filter.map_map, map_le_iff_le_comap] at lim1\n  have lim2 : comap i (map h (𝓝 d)) ≤ comap i (𝓝 (i a)) := comap_mono H\n  rw [← di.nhds_eq_comap] at lim2\n  exact le_trans lim1 lim2\n\n"}
{"name":"IsDenseInducing.nhdsWithin_neBot","module":"Mathlib.Topology.DenseEmbedding","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : TopologicalSpace α\ninst✝ : TopologicalSpace β\ni : α → β\ndi : IsDenseInducing i\nb : β\n⊢ (nhdsWithin b (Set.range i)).NeBot","decl":"protected theorem nhdsWithin_neBot (di : IsDenseInducing i) (b : β) : NeBot (𝓝[range i] b) :=\n  di.dense.nhdsWithin_neBot b\n\n"}
{"name":"IsDenseInducing.comap_nhds_neBot","module":"Mathlib.Topology.DenseEmbedding","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : TopologicalSpace α\ninst✝ : TopologicalSpace β\ni : α → β\ndi : IsDenseInducing i\nb : β\n⊢ (Filter.comap i (nhds b)).NeBot","decl":"theorem comap_nhds_neBot (di : IsDenseInducing i) (b : β) : NeBot (comap i (𝓝 b)) :=\n  comap_neBot fun s hs => by\n    rcases mem_closure_iff_nhds.1 (di.dense b) s hs with ⟨_, ⟨ha, a, rfl⟩⟩\n    exact ⟨a, ha⟩\n\n"}
{"name":"IsDenseInducing.extend_eq_of_tendsto","module":"Mathlib.Topology.DenseEmbedding","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝³ : TopologicalSpace α\ninst✝² : TopologicalSpace β\ni : α → β\ninst✝¹ : TopologicalSpace γ\ninst✝ : T2Space γ\ndi : IsDenseInducing i\nb : β\nc : γ\nf : α → γ\nhf : Filter.Tendsto f (Filter.comap i (nhds b)) (nhds c)\n⊢ Eq (di.extend f b) c","decl":"theorem extend_eq_of_tendsto [T2Space γ] (di : IsDenseInducing i) {b : β} {c : γ} {f : α → γ}\n    (hf : Tendsto f (comap i (𝓝 b)) (𝓝 c)) : di.extend f b = c :=\n  haveI := di.comap_nhds_neBot\n  hf.limUnder_eq\n\n"}
{"name":"IsDenseInducing.extend_eq_at","module":"Mathlib.Topology.DenseEmbedding","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝³ : TopologicalSpace α\ninst✝² : TopologicalSpace β\ni : α → β\ninst✝¹ : TopologicalSpace γ\ninst✝ : T2Space γ\ndi : IsDenseInducing i\nf : α → γ\na : α\nhf : ContinuousAt f a\n⊢ Eq (di.extend f (i a)) (f a)","decl":"theorem extend_eq_at [T2Space γ] (di : IsDenseInducing i) {f : α → γ} {a : α}\n    (hf : ContinuousAt f a) : di.extend f (i a) = f a :=\n  extend_eq_of_tendsto _ <| di.nhds_eq_comap a ▸ hf\n\n"}
{"name":"IsDenseInducing.extend_eq_at'","module":"Mathlib.Topology.DenseEmbedding","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝³ : TopologicalSpace α\ninst✝² : TopologicalSpace β\ni : α → β\ninst✝¹ : TopologicalSpace γ\ninst✝ : T2Space γ\ndi : IsDenseInducing i\nf : α → γ\na : α\nc : γ\nhf : Filter.Tendsto f (nhds a) (nhds c)\n⊢ Eq (di.extend f (i a)) (f a)","decl":"theorem extend_eq_at' [T2Space γ] (di : IsDenseInducing i) {f : α → γ} {a : α} (c : γ)\n    (hf : Tendsto f (𝓝 a) (𝓝 c)) : di.extend f (i a) = f a :=\n  di.extend_eq_at (continuousAt_of_tendsto_nhds hf)\n\n"}
{"name":"IsDenseInducing.extend_eq","module":"Mathlib.Topology.DenseEmbedding","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝³ : TopologicalSpace α\ninst✝² : TopologicalSpace β\ni : α → β\ninst✝¹ : TopologicalSpace γ\ninst✝ : T2Space γ\ndi : IsDenseInducing i\nf : α → γ\nhf : Continuous f\na : α\n⊢ Eq (di.extend f (i a)) (f a)","decl":"theorem extend_eq [T2Space γ] (di : IsDenseInducing i) {f : α → γ} (hf : Continuous f) (a : α) :\n    di.extend f (i a) = f a :=\n  di.extend_eq_at hf.continuousAt\n\n"}
{"name":"IsDenseInducing.extend_eq'","module":"Mathlib.Topology.DenseEmbedding","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝³ : TopologicalSpace α\ninst✝² : TopologicalSpace β\ni : α → β\ninst✝¹ : TopologicalSpace γ\ninst✝ : T2Space γ\nf : α → γ\ndi : IsDenseInducing i\nhf : ∀ (b : β), Exists fun c => Filter.Tendsto f (Filter.comap i (nhds b)) (nhds c)\na : α\n⊢ Eq (di.extend f (i a)) (f a)","decl":"/-- Variation of `extend_eq` where we ask that `f` has a limit along `comap i (𝓝 b)` for each\n`b : β`. This is a strictly stronger assumption than continuity of `f`, but in a lot of cases\nyou'd have to prove it anyway to use `continuous_extend`, so this avoids doing the work twice. -/\ntheorem extend_eq' [T2Space γ] {f : α → γ} (di : IsDenseInducing i)\n    (hf : ∀ b, ∃ c, Tendsto f (comap i (𝓝 b)) (𝓝 c)) (a : α) : di.extend f (i a) = f a := by\n  rcases hf (i a) with ⟨b, hb⟩\n  refine di.extend_eq_at' b ?_\n  rwa [← di.isInducing.nhds_eq_comap] at hb\n\n"}
{"name":"IsDenseInducing.extend_unique_at","module":"Mathlib.Topology.DenseEmbedding","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝³ : TopologicalSpace α\ninst✝² : TopologicalSpace β\ni : α → β\ninst✝¹ : TopologicalSpace γ\ninst✝ : T2Space γ\nb : β\nf : α → γ\ng : β → γ\ndi : IsDenseInducing i\nhf : Filter.Eventually (fun x => Eq (g (i x)) (f x)) (Filter.comap i (nhds b))\nhg : ContinuousAt g b\n⊢ Eq (di.extend f b) (g b)","decl":"theorem extend_unique_at [T2Space γ] {b : β} {f : α → γ} {g : β → γ} (di : IsDenseInducing i)\n    (hf : ∀ᶠ x in comap i (𝓝 b), g (i x) = f x) (hg : ContinuousAt g b) : di.extend f b = g b := by\n  refine di.extend_eq_of_tendsto fun s hs => mem_map.2 ?_\n  suffices ∀ᶠ x : α in comap i (𝓝 b), g (i x) ∈ s from\n    hf.mp (this.mono fun x hgx hfx => hfx ▸ hgx)\n  clear hf f\n  refine eventually_comap.2 ((hg.eventually hs).mono ?_)\n  rintro _ hxs x rfl\n  exact hxs\n\n"}
{"name":"IsDenseInducing.extend_unique","module":"Mathlib.Topology.DenseEmbedding","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝³ : TopologicalSpace α\ninst✝² : TopologicalSpace β\ni : α → β\ninst✝¹ : TopologicalSpace γ\ninst✝ : T2Space γ\nf : α → γ\ng : β → γ\ndi : IsDenseInducing i\nhf : ∀ (x : α), Eq (g (i x)) (f x)\nhg : Continuous g\n⊢ Eq (di.extend f) g","decl":"theorem extend_unique [T2Space γ] {f : α → γ} {g : β → γ} (di : IsDenseInducing i)\n    (hf : ∀ x, g (i x) = f x) (hg : Continuous g) : di.extend f = g :=\n  funext fun _ => extend_unique_at di (Eventually.of_forall hf) hg.continuousAt\n\n"}
{"name":"IsDenseInducing.continuousAt_extend","module":"Mathlib.Topology.DenseEmbedding","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝³ : TopologicalSpace α\ninst✝² : TopologicalSpace β\ni : α → β\ninst✝¹ : TopologicalSpace γ\ninst✝ : T3Space γ\nb : β\nf : α → γ\ndi : IsDenseInducing i\nhf : Filter.Eventually (fun x => Exists fun c => Filter.Tendsto f (Filter.comap i (nhds x)) (nhds c)) (nhds b)\n⊢ ContinuousAt (di.extend f) b","decl":"theorem continuousAt_extend [T3Space γ] {b : β} {f : α → γ} (di : IsDenseInducing i)\n    (hf : ∀ᶠ x in 𝓝 b, ∃ c, Tendsto f (comap i <| 𝓝 x) (𝓝 c)) : ContinuousAt (di.extend f) b := by\n  set φ := di.extend f\n  haveI := di.comap_nhds_neBot\n  suffices ∀ V' ∈ 𝓝 (φ b), IsClosed V' → φ ⁻¹' V' ∈ 𝓝 b by\n    simpa [ContinuousAt, (closed_nhds_basis (φ b)).tendsto_right_iff]\n  intro V' V'_in V'_closed\n  set V₁ := { x | Tendsto f (comap i <| 𝓝 x) (𝓝 <| φ x) }\n  have V₁_in : V₁ ∈ 𝓝 b := by\n    filter_upwards [hf]\n    rintro x ⟨c, hc⟩\n    rwa [← di.extend_eq_of_tendsto hc] at hc\n  obtain ⟨V₂, V₂_in, V₂_op, hV₂⟩ : ∃ V₂ ∈ 𝓝 b, IsOpen V₂ ∧ ∀ x ∈ i ⁻¹' V₂, f x ∈ V' := by\n    simpa [and_assoc] using\n      ((nhds_basis_opens' b).comap i).tendsto_left_iff.mp (mem_of_mem_nhds V₁_in : b ∈ V₁) V' V'_in\n  suffices ∀ x ∈ V₁ ∩ V₂, φ x ∈ V' by filter_upwards [inter_mem V₁_in V₂_in] using this\n  rintro x ⟨x_in₁, x_in₂⟩\n  have hV₂x : V₂ ∈ 𝓝 x := IsOpen.mem_nhds V₂_op x_in₂\n  apply V'_closed.mem_of_tendsto x_in₁\n  use V₂\n  tauto\n\n"}
{"name":"IsDenseInducing.continuous_extend","module":"Mathlib.Topology.DenseEmbedding","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝³ : TopologicalSpace α\ninst✝² : TopologicalSpace β\ni : α → β\ninst✝¹ : TopologicalSpace γ\ninst✝ : T3Space γ\nf : α → γ\ndi : IsDenseInducing i\nhf : ∀ (b : β), Exists fun c => Filter.Tendsto f (Filter.comap i (nhds b)) (nhds c)\n⊢ Continuous (di.extend f)","decl":"theorem continuous_extend [T3Space γ] {f : α → γ} (di : IsDenseInducing i)\n    (hf : ∀ b, ∃ c, Tendsto f (comap i (𝓝 b)) (𝓝 c)) : Continuous (di.extend f) :=\n  continuous_iff_continuousAt.mpr fun _ => di.continuousAt_extend <| univ_mem' hf\n\n"}
{"name":"IsDenseInducing.mk'","module":"Mathlib.Topology.DenseEmbedding","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : TopologicalSpace α\ninst✝ : TopologicalSpace β\ni : α → β\nc : Continuous i\ndense : ∀ (x : β), Membership.mem (closure (Set.range i)) x\nH : ∀ (a : α) (s : Set α), Membership.mem (nhds a) s → Exists fun t => And (Membership.mem (nhds (i a)) t) (∀ (b : α), Membership.mem t (i b) → Membership.mem s b)\n⊢ IsDenseInducing i","decl":"theorem mk' (i : α → β) (c : Continuous i) (dense : ∀ x, x ∈ closure (range i))\n    (H : ∀ (a : α), ∀ s ∈ 𝓝 a, ∃ t ∈ 𝓝 (i a), ∀ b, i b ∈ t → b ∈ s) : IsDenseInducing i where\n  toIsInducing := isInducing_iff_nhds.2 fun a =>\n      le_antisymm (c.tendsto _).le_comap (by simpa [Filter.le_def] using H a)\n  dense := dense\n\n"}
{"name":"Dense.extend_eq_of_tendsto","module":"Mathlib.Topology.DenseEmbedding","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : TopologicalSpace α\ninst✝¹ : TopologicalSpace β\ns : Set α\nf : ↑s → β\ninst✝ : T2Space β\nhs : Dense s\na : α\nb : β\nhf : Filter.Tendsto f (Filter.comap Subtype.val (nhds a)) (nhds b)\n⊢ Eq (hs.extend f a) b","decl":"theorem extend_eq_of_tendsto [T2Space β] (hs : Dense s) {a : α} {b : β}\n    (hf : Tendsto f (comap (↑) (𝓝 a)) (𝓝 b)) : hs.extend f a = b :=\n  hs.isDenseInducing_val.extend_eq_of_tendsto hf\n\n"}
{"name":"Dense.extend_eq_at","module":"Mathlib.Topology.DenseEmbedding","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : TopologicalSpace α\ninst✝¹ : TopologicalSpace β\ns : Set α\ninst✝ : T2Space β\nhs : Dense s\nf : ↑s → β\nx : ↑s\nhf : ContinuousAt f x\n⊢ Eq (hs.extend f ↑x) (f x)","decl":"theorem extend_eq_at [T2Space β] (hs : Dense s) {f : s → β} {x : s}\n    (hf : ContinuousAt f x) : hs.extend f x = f x :=\n  hs.isDenseInducing_val.extend_eq_at hf\n\n"}
{"name":"Dense.extend_eq","module":"Mathlib.Topology.DenseEmbedding","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : TopologicalSpace α\ninst✝¹ : TopologicalSpace β\ns : Set α\nf : ↑s → β\ninst✝ : T2Space β\nhs : Dense s\nhf : Continuous f\nx : ↑s\n⊢ Eq (hs.extend f ↑x) (f x)","decl":"theorem extend_eq [T2Space β] (hs : Dense s) (hf : Continuous f) (x : s) :\n    hs.extend f x = f x :=\n  hs.extend_eq_at hf.continuousAt\n\n"}
{"name":"Dense.extend_unique_at","module":"Mathlib.Topology.DenseEmbedding","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : TopologicalSpace α\ninst✝¹ : TopologicalSpace β\ns : Set α\nf : ↑s → β\ninst✝ : T2Space β\na : α\ng : α → β\nhs : Dense s\nhf : Filter.Eventually (fun x => Eq (g ↑x) (f x)) (Filter.comap Subtype.val (nhds a))\nhg : ContinuousAt g a\n⊢ Eq (hs.extend f a) (g a)","decl":"theorem extend_unique_at [T2Space β] {a : α} {g : α → β} (hs : Dense s)\n    (hf : ∀ᶠ x : s in comap (↑) (𝓝 a), g x = f x) (hg : ContinuousAt g a) :\n    hs.extend f a = g a :=\n  hs.isDenseInducing_val.extend_unique_at hf hg\n\n"}
{"name":"Dense.extend_unique","module":"Mathlib.Topology.DenseEmbedding","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : TopologicalSpace α\ninst✝¹ : TopologicalSpace β\ns : Set α\nf : ↑s → β\ninst✝ : T2Space β\ng : α → β\nhs : Dense s\nhf : ∀ (x : ↑s), Eq (g ↑x) (f x)\nhg : Continuous g\n⊢ Eq (hs.extend f) g","decl":"theorem extend_unique [T2Space β] {g : α → β} (hs : Dense s)\n    (hf : ∀ x : s, g x = f x) (hg : Continuous g) : hs.extend f = g :=\n  hs.isDenseInducing_val.extend_unique hf hg\n\n"}
{"name":"Dense.continuousAt_extend","module":"Mathlib.Topology.DenseEmbedding","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : TopologicalSpace α\ninst✝¹ : TopologicalSpace β\ns : Set α\nf : ↑s → β\ninst✝ : T3Space β\na : α\nhs : Dense s\nhf : Filter.Eventually (fun x => Exists fun b => Filter.Tendsto f (Filter.comap Subtype.val (nhds x)) (nhds b)) (nhds a)\n⊢ ContinuousAt (hs.extend f) a","decl":"theorem continuousAt_extend [T3Space β] {a : α} (hs : Dense s)\n    (hf : ∀ᶠ x in 𝓝 a, ∃ b, Tendsto f (comap (↑) <| 𝓝 x) (𝓝 b)) :\n    ContinuousAt (hs.extend f) a :=\n  hs.isDenseInducing_val.continuousAt_extend hf\n\n"}
{"name":"Dense.continuous_extend","module":"Mathlib.Topology.DenseEmbedding","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : TopologicalSpace α\ninst✝¹ : TopologicalSpace β\ns : Set α\nf : ↑s → β\ninst✝ : T3Space β\nhs : Dense s\nhf : ∀ (a : α), Exists fun b => Filter.Tendsto f (Filter.comap Subtype.val (nhds a)) (nhds b)\n⊢ Continuous (hs.extend f)","decl":"theorem continuous_extend [T3Space β] (hs : Dense s)\n    (hf : ∀ a : α, ∃ b, Tendsto f (comap (↑) (𝓝 a)) (𝓝 b)) : Continuous (hs.extend f) :=\n  hs.isDenseInducing_val.continuous_extend hf\n\n"}
{"name":"IsDenseEmbedding.toIsDenseInducing","module":"Mathlib.Topology.DenseEmbedding","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : TopologicalSpace α\ninst✝ : TopologicalSpace β\ne : α → β\nself : IsDenseEmbedding e\n⊢ IsDenseInducing e","decl":"/-- A dense embedding is an embedding with dense image. -/\nstructure IsDenseEmbedding [TopologicalSpace α] [TopologicalSpace β] (e : α → β) extends\n  IsDenseInducing e : Prop where\n  /-- A dense embedding is injective. -/\n  injective : Function.Injective e\n\n"}
{"name":"IsDenseEmbedding.injective","module":"Mathlib.Topology.DenseEmbedding","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : TopologicalSpace α\ninst✝ : TopologicalSpace β\ne : α → β\nself : IsDenseEmbedding e\n⊢ Function.Injective e","decl":"/-- A dense embedding is an embedding with dense image. -/\nstructure IsDenseEmbedding [TopologicalSpace α] [TopologicalSpace β] (e : α → β) extends\n  IsDenseInducing e : Prop where\n  /-- A dense embedding is injective. -/\n  injective : Function.Injective e\n\n"}
{"name":"IsDenseEmbedding.mk'","module":"Mathlib.Topology.DenseEmbedding","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : TopologicalSpace α\ninst✝ : TopologicalSpace β\ne : α → β\nc : Continuous e\ndense : DenseRange e\ninjective : Function.Injective e\nH : ∀ (a : α) (s : Set α), Membership.mem (nhds a) s → Exists fun t => And (Membership.mem (nhds (e a)) t) (∀ (b : α), Membership.mem t (e b) → Membership.mem s b)\n⊢ IsDenseEmbedding e","decl":"lemma IsDenseEmbedding.mk' [TopologicalSpace α] [TopologicalSpace β] (e : α → β) (c : Continuous e)\n    (dense : DenseRange e) (injective : Function.Injective e)\n    (H : ∀ (a : α), ∀ s ∈ 𝓝 a, ∃ t ∈ 𝓝 (e a), ∀ b, e b ∈ t → b ∈ s) : IsDenseEmbedding e :=\n  { IsDenseInducing.mk' e c dense H with injective }\n\n"}
{"name":"DenseEmbedding.mk'","module":"Mathlib.Topology.DenseEmbedding","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : TopologicalSpace α\ninst✝ : TopologicalSpace β\ne : α → β\nc : Continuous e\ndense : DenseRange e\ninjective : Function.Injective e\nH : ∀ (a : α) (s : Set α), Membership.mem (nhds a) s → Exists fun t => And (Membership.mem (nhds (e a)) t) (∀ (b : α), Membership.mem t (e b) → Membership.mem s b)\n⊢ IsDenseEmbedding e","decl":"@[deprecated (since := \"2024-09-30\")]\nalias DenseEmbedding.mk' := IsDenseEmbedding.mk'\n\n"}
{"name":"IsDenseEmbedding.isDenseInducing","module":"Mathlib.Topology.DenseEmbedding","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : TopologicalSpace α\ninst✝ : TopologicalSpace β\ne : α → β\nde : IsDenseEmbedding e\n⊢ IsDenseInducing e","decl":"lemma isDenseInducing (de : IsDenseEmbedding e) : IsDenseInducing e := de.toIsDenseInducing\n\n"}
{"name":"IsDenseEmbedding.inj_iff","module":"Mathlib.Topology.DenseEmbedding","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : TopologicalSpace α\ninst✝ : TopologicalSpace β\ne : α → β\nde : IsDenseEmbedding e\nx y : α\n⊢ Iff (Eq (e x) (e y)) (Eq x y)","decl":"theorem inj_iff (de : IsDenseEmbedding e) {x y} : e x = e y ↔ x = y :=\n  de.injective.eq_iff\n\n"}
{"name":"IsDenseEmbedding.isEmbedding","module":"Mathlib.Topology.DenseEmbedding","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : TopologicalSpace α\ninst✝ : TopologicalSpace β\ne : α → β\nde : IsDenseEmbedding e\n⊢ Topology.IsEmbedding e","decl":"theorem isEmbedding (de : IsDenseEmbedding e) : IsEmbedding e where __ := de\n\n"}
{"name":"IsDenseEmbedding.to_embedding","module":"Mathlib.Topology.DenseEmbedding","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : TopologicalSpace α\ninst✝ : TopologicalSpace β\ne : α → β\nde : IsDenseEmbedding e\n⊢ Topology.IsEmbedding e","decl":"@[deprecated (since := \"2024-10-26\")]\nalias to_embedding := isEmbedding\n\n"}
{"name":"IsDenseEmbedding.separableSpace","module":"Mathlib.Topology.DenseEmbedding","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : TopologicalSpace α\ninst✝¹ : TopologicalSpace β\ne : α → β\ninst✝ : TopologicalSpace.SeparableSpace α\nde : IsDenseEmbedding e\n⊢ TopologicalSpace.SeparableSpace β","decl":"/-- If the domain of a `IsDenseEmbedding` is a separable space, then so is its codomain. -/\nprotected theorem separableSpace [SeparableSpace α] (de : IsDenseEmbedding e) : SeparableSpace β :=\n  de.isDenseInducing.separableSpace\n\n"}
{"name":"IsDenseEmbedding.prodMap","module":"Mathlib.Topology.DenseEmbedding","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nδ : Type u_4\ninst✝³ : TopologicalSpace α\ninst✝² : TopologicalSpace β\ninst✝¹ : TopologicalSpace γ\ninst✝ : TopologicalSpace δ\ne₁ : α → β\ne₂ : γ → δ\nde₁ : IsDenseEmbedding e₁\nde₂ : IsDenseEmbedding e₂\n⊢ IsDenseEmbedding fun p => { fst := e₁ p.1, snd := e₂ p.2 }","decl":"/-- The product of two dense embeddings is a dense embedding. -/\nprotected theorem prodMap {e₁ : α → β} {e₂ : γ → δ} (de₁ : IsDenseEmbedding e₁)\n    (de₂ : IsDenseEmbedding e₂) : IsDenseEmbedding fun p : α × γ => (e₁ p.1, e₂ p.2) where\n  toIsDenseInducing := de₁.isDenseInducing.prodMap de₂.isDenseInducing\n  injective := de₁.injective.prodMap de₂.injective\n\n"}
{"name":"IsDenseEmbedding.prod","module":"Mathlib.Topology.DenseEmbedding","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nδ : Type u_4\ninst✝³ : TopologicalSpace α\ninst✝² : TopologicalSpace β\ninst✝¹ : TopologicalSpace γ\ninst✝ : TopologicalSpace δ\ne₁ : α → β\ne₂ : γ → δ\nde₁ : IsDenseEmbedding e₁\nde₂ : IsDenseEmbedding e₂\n⊢ IsDenseEmbedding fun p => { fst := e₁ p.1, snd := e₂ p.2 }","decl":"@[deprecated (since := \"2024-10-06\")] protected alias prod := IsDenseEmbedding.prodMap\n\n"}
{"name":"IsDenseEmbedding.subtypeEmb_coe","module":"Mathlib.Topology.DenseEmbedding","initialProofState":"β : Type u_2\ninst✝ : TopologicalSpace β\nα : Type u_5\np : α → Prop\ne : α → β\nx : Subtype fun x => p x\n⊢ Eq (↑(IsDenseEmbedding.subtypeEmb p e x)) (e ↑x)","decl":"/-- The dense embedding of a subtype inside its closure. -/\n@[simps]\ndef subtypeEmb {α : Type*} (p : α → Prop) (e : α → β) (x : { x // p x }) :\n    { x // x ∈ closure (e '' { x | p x }) } :=\n  ⟨e x, subset_closure <| mem_image_of_mem e x.prop⟩\n\n"}
{"name":"IsDenseEmbedding.subtype","module":"Mathlib.Topology.DenseEmbedding","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : TopologicalSpace α\ninst✝ : TopologicalSpace β\ne : α → β\nde : IsDenseEmbedding e\np : α → Prop\n⊢ IsDenseEmbedding (IsDenseEmbedding.subtypeEmb p e)","decl":"protected theorem subtype (de : IsDenseEmbedding e) (p : α → Prop) :\n    IsDenseEmbedding (subtypeEmb p e) where\n  dense :=\n    dense_iff_closure_eq.2 <| by\n      ext ⟨x, hx⟩\n      rw [image_eq_range] at hx\n      simpa [closure_subtype, ← range_comp, (· ∘ ·)]\n  injective := (de.injective.comp Subtype.coe_injective).codRestrict _\n  eq_induced :=\n    (induced_iff_nhds_eq _).2 fun ⟨x, hx⟩ => by\n      simp [subtypeEmb, nhds_subtype_eq_comap, de.isInducing.nhds_eq_comap, comap_comap,\n        Function.comp_def]\n\n"}
{"name":"IsDenseEmbedding.dense_image","module":"Mathlib.Topology.DenseEmbedding","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : TopologicalSpace α\ninst✝ : TopologicalSpace β\ne : α → β\nde : IsDenseEmbedding e\ns : Set α\n⊢ Iff (Dense (Set.image e s)) (Dense s)","decl":"theorem dense_image (de : IsDenseEmbedding e) {s : Set α} : Dense (e '' s) ↔ Dense s :=\n  de.isDenseInducing.dense_image\n\n"}
{"name":"IsDenseEmbedding.id","module":"Mathlib.Topology.DenseEmbedding","initialProofState":"α : Type u_5\ninst✝ : TopologicalSpace α\n⊢ IsDenseEmbedding id","decl":"protected lemma id {α : Type*} [TopologicalSpace α] : IsDenseEmbedding (id : α → α) :=\n  { IsEmbedding.id with dense := denseRange_id }\n\n"}
{"name":"denseEmbedding_id","module":"Mathlib.Topology.DenseEmbedding","initialProofState":"α : Type u_5\ninst✝ : TopologicalSpace α\n⊢ IsDenseEmbedding id","decl":"@[deprecated (since := \"2024-09-30\")]\nalias denseEmbedding_id := IsDenseEmbedding.id\n\n"}
{"name":"Dense.isDenseEmbedding_val","module":"Mathlib.Topology.DenseEmbedding","initialProofState":"α : Type u_1\ninst✝ : TopologicalSpace α\ns : Set α\nhs : Dense s\n⊢ IsDenseEmbedding Subtype.val","decl":"theorem Dense.isDenseEmbedding_val [TopologicalSpace α] {s : Set α} (hs : Dense s) :\n    IsDenseEmbedding ((↑) : s → α) :=\n  { IsEmbedding.subtypeVal with dense := hs.denseRange_val }\n\n"}
{"name":"Dense.denseEmbedding_val","module":"Mathlib.Topology.DenseEmbedding","initialProofState":"α : Type u_1\ninst✝ : TopologicalSpace α\ns : Set α\nhs : Dense s\n⊢ IsDenseEmbedding Subtype.val","decl":"@[deprecated (since := \"2024-09-30\")]\nalias Dense.denseEmbedding_val := Dense.isDenseEmbedding_val\n\n"}
{"name":"isClosed_property","module":"Mathlib.Topology.DenseEmbedding","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : TopologicalSpace β\ne : α → β\np : β → Prop\nhe : DenseRange e\nhp : IsClosed (setOf fun x => p x)\nh : ∀ (a : α), p (e a)\nb : β\n⊢ p b","decl":"theorem isClosed_property [TopologicalSpace β] {e : α → β} {p : β → Prop} (he : DenseRange e)\n    (hp : IsClosed { x | p x }) (h : ∀ a, p (e a)) : ∀ b, p b :=\n  have : univ ⊆ { b | p b } :=\n    calc\n      univ = closure (range e) := he.closure_range.symm\n      _ ⊆ closure { b | p b } := closure_mono <| range_subset_iff.mpr h\n      _ = _ := hp.closure_eq\n\n  fun _ => this trivial\n\n"}
{"name":"isClosed_property2","module":"Mathlib.Topology.DenseEmbedding","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : TopologicalSpace β\ne : α → β\np : β → β → Prop\nhe : DenseRange e\nhp : IsClosed (setOf fun q => p q.1 q.2)\nh : ∀ (a₁ a₂ : α), p (e a₁) (e a₂)\nb₁ b₂ : β\n⊢ p b₁ b₂","decl":"theorem isClosed_property2 [TopologicalSpace β] {e : α → β} {p : β → β → Prop} (he : DenseRange e)\n    (hp : IsClosed { q : β × β | p q.1 q.2 }) (h : ∀ a₁ a₂, p (e a₁) (e a₂)) : ∀ b₁ b₂, p b₁ b₂ :=\n  have : ∀ q : β × β, p q.1 q.2 := isClosed_property (he.prodMap he) hp fun _ => h _ _\n  fun b₁ b₂ => this ⟨b₁, b₂⟩\n\n"}
{"name":"isClosed_property3","module":"Mathlib.Topology.DenseEmbedding","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : TopologicalSpace β\ne : α → β\np : β → β → β → Prop\nhe : DenseRange e\nhp : IsClosed (setOf fun q => p q.1 q.2.1 q.2.2)\nh : ∀ (a₁ a₂ a₃ : α), p (e a₁) (e a₂) (e a₃)\nb₁ b₂ b₃ : β\n⊢ p b₁ b₂ b₃","decl":"theorem isClosed_property3 [TopologicalSpace β] {e : α → β} {p : β → β → β → Prop}\n    (he : DenseRange e) (hp : IsClosed { q : β × β × β | p q.1 q.2.1 q.2.2 })\n    (h : ∀ a₁ a₂ a₃, p (e a₁) (e a₂) (e a₃)) : ∀ b₁ b₂ b₃, p b₁ b₂ b₃ :=\n  have : ∀ q : β × β × β, p q.1 q.2.1 q.2.2 :=\n    isClosed_property (he.prodMap <| he.prodMap he) hp fun _ => h _ _ _\n  fun b₁ b₂ b₃ => this ⟨b₁, b₂, b₃⟩\n\n"}
{"name":"DenseRange.induction_on","module":"Mathlib.Topology.DenseEmbedding","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : TopologicalSpace β\ne : α → β\nhe : DenseRange e\np : β → Prop\nb₀ : β\nhp : IsClosed (setOf fun b => p b)\nih : ∀ (a : α), p (e a)\n⊢ p b₀","decl":"@[elab_as_elim]\ntheorem DenseRange.induction_on [TopologicalSpace β] {e : α → β} (he : DenseRange e) {p : β → Prop}\n    (b₀ : β) (hp : IsClosed { b | p b }) (ih : ∀ a : α, p <| e a) : p b₀ :=\n  isClosed_property he hp ih b₀\n\n"}
{"name":"DenseRange.induction_on₂","module":"Mathlib.Topology.DenseEmbedding","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : TopologicalSpace β\ne : α → β\np : β → β → Prop\nhe : DenseRange e\nhp : IsClosed (setOf fun q => p q.1 q.2)\nh : ∀ (a₁ a₂ : α), p (e a₁) (e a₂)\nb₁ b₂ : β\n⊢ p b₁ b₂","decl":"@[elab_as_elim]\ntheorem DenseRange.induction_on₂ [TopologicalSpace β] {e : α → β} {p : β → β → Prop}\n    (he : DenseRange e) (hp : IsClosed { q : β × β | p q.1 q.2 }) (h : ∀ a₁ a₂, p (e a₁) (e a₂))\n    (b₁ b₂ : β) : p b₁ b₂ :=\n  isClosed_property2 he hp h _ _\n\n"}
{"name":"DenseRange.induction_on₃","module":"Mathlib.Topology.DenseEmbedding","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : TopologicalSpace β\ne : α → β\np : β → β → β → Prop\nhe : DenseRange e\nhp : IsClosed (setOf fun q => p q.1 q.2.1 q.2.2)\nh : ∀ (a₁ a₂ a₃ : α), p (e a₁) (e a₂) (e a₃)\nb₁ b₂ b₃ : β\n⊢ p b₁ b₂ b₃","decl":"@[elab_as_elim]\ntheorem DenseRange.induction_on₃ [TopologicalSpace β] {e : α → β} {p : β → β → β → Prop}\n    (he : DenseRange e) (hp : IsClosed { q : β × β × β | p q.1 q.2.1 q.2.2 })\n    (h : ∀ a₁ a₂ a₃, p (e a₁) (e a₂) (e a₃)) (b₁ b₂ b₃ : β) : p b₁ b₂ b₃ :=\n  isClosed_property3 he hp h _ _ _\n\n"}
{"name":"DenseRange.equalizer","module":"Mathlib.Topology.DenseEmbedding","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝² : TopologicalSpace β\ninst✝¹ : TopologicalSpace γ\ninst✝ : T2Space γ\nf : α → β\nhfd : DenseRange f\ng h : β → γ\nhg : Continuous g\nhh : Continuous h\nH : Eq (Function.comp g f) (Function.comp h f)\n⊢ Eq g h","decl":"/-- Two continuous functions to a t2-space that agree on the dense range of a function are equal. -/\ntheorem DenseRange.equalizer (hfd : DenseRange f) {g h : β → γ} (hg : Continuous g)\n    (hh : Continuous h) (H : g ∘ f = h ∘ f) : g = h :=\n  funext fun y => hfd.induction_on y (isClosed_eq hg hh) <| congr_fun H\n\n"}
{"name":"Filter.HasBasis.hasBasis_of_isDenseInducing","module":"Mathlib.Topology.DenseEmbedding","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : TopologicalSpace α\ninst✝¹ : TopologicalSpace β\ninst✝ : T3Space β\nι : Type u_5\ns : ι → Set α\np : ι → Prop\nx : α\nh : (nhds x).HasBasis p s\nf : α → β\nhf : IsDenseInducing f\n⊢ (nhds (f x)).HasBasis p fun i => closure (Set.image f (s i))","decl":"theorem Filter.HasBasis.hasBasis_of_isDenseInducing [TopologicalSpace α] [TopologicalSpace β]\n    [T3Space β] {ι : Type*} {s : ι → Set α} {p : ι → Prop} {x : α} (h : (𝓝 x).HasBasis p s)\n    {f : α → β} (hf : IsDenseInducing f) : (𝓝 (f x)).HasBasis p fun i => closure <| f '' s i := by\n  rw [Filter.hasBasis_iff] at h ⊢\n  intro T\n  refine ⟨fun hT => ?_, fun hT => ?_⟩\n  · obtain ⟨T', hT₁, hT₂, hT₃⟩ := exists_mem_nhds_isClosed_subset hT\n    have hT₄ : f ⁻¹' T' ∈ 𝓝 x := by\n      rw [hf.isInducing.nhds_eq_comap x]\n      exact ⟨T', hT₁, Subset.rfl⟩\n    obtain ⟨i, hi, hi'⟩ := (h _).mp hT₄\n    exact\n      ⟨i, hi,\n        (closure_mono (image_subset f hi')).trans\n          (Subset.trans (closure_minimal (image_preimage_subset _ _) hT₂) hT₃)⟩\n  · obtain ⟨i, hi, hi'⟩ := hT\n    suffices closure (f '' s i) ∈ 𝓝 (f x) by filter_upwards [this] using hi'\n    replace h := (h (s i)).mpr ⟨i, hi, Subset.rfl⟩\n    exact hf.closure_image_mem_nhds h\n"}
