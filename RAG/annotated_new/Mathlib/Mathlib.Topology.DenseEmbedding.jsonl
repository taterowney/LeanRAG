{"name":"IsDenseInducing.toIsInducing","module":"Mathlib.Topology.DenseEmbedding","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : TopologicalSpace Î²\ni : Î± â†’ Î²\nself : IsDenseInducing i\nâŠ¢ Topology.IsInducing i","decl":"/-- `i : Î± â†’ Î²` is \"dense inducing\" if it has dense range and the topology on `Î±`\n  is the one induced by `i` from the topology on `Î²`. -/\nstructure IsDenseInducing [TopologicalSpace Î±] [TopologicalSpace Î²] (i : Î± â†’ Î²)\n    extends IsInducing i : Prop where\n  /-- The range of a dense inducing map is a dense set. -/\n  protected dense : DenseRange i\n\n"}
{"name":"IsDenseInducing.dense","module":"Mathlib.Topology.DenseEmbedding","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : TopologicalSpace Î²\ni : Î± â†’ Î²\nself : IsDenseInducing i\nâŠ¢ DenseRange i","decl":"/-- `i : Î± â†’ Î²` is \"dense inducing\" if it has dense range and the topology on `Î±`\n  is the one induced by `i` from the topology on `Î²`. -/\nstructure IsDenseInducing [TopologicalSpace Î±] [TopologicalSpace Î²] (i : Î± â†’ Î²)\n    extends IsInducing i : Prop where\n  /-- The range of a dense inducing map is a dense set. -/\n  protected dense : DenseRange i\n\n"}
{"name":"Dense.isDenseInducing_val","module":"Mathlib.Topology.DenseEmbedding","initialProofState":"Î± : Type u_1\ninstâœ : TopologicalSpace Î±\ns : Set Î±\nhs : Dense s\nâŠ¢ IsDenseInducing Subtype.val","decl":"theorem _root_.Dense.isDenseInducing_val {s : Set Î±} (hs : Dense s) :\n    IsDenseInducing (@Subtype.val Î± s) := âŸ¨IsInducing.subtypeVal, hs.denseRange_valâŸ©\n\n"}
{"name":"IsDenseInducing.isInducing","module":"Mathlib.Topology.DenseEmbedding","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : TopologicalSpace Î²\ni : Î± â†’ Î²\ndi : IsDenseInducing i\nâŠ¢ Topology.IsInducing i","decl":"lemma isInducing (di : IsDenseInducing i) : IsInducing i := di.toIsInducing\n\n"}
{"name":"IsDenseInducing.nhds_eq_comap","module":"Mathlib.Topology.DenseEmbedding","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : TopologicalSpace Î²\ni : Î± â†’ Î²\ndi : IsDenseInducing i\na : Î±\nâŠ¢ Eq (nhds a) (Filter.comap i (nhds (i a)))","decl":"theorem nhds_eq_comap (di : IsDenseInducing i) : âˆ€ a : Î±, ğ“ a = comap i (ğ“ <| i a) :=\n  di.isInducing.nhds_eq_comap\n\n"}
{"name":"IsDenseInducing.continuous","module":"Mathlib.Topology.DenseEmbedding","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : TopologicalSpace Î²\ni : Î± â†’ Î²\ndi : IsDenseInducing i\nâŠ¢ Continuous i","decl":"protected theorem continuous (di : IsDenseInducing i) : Continuous i :=\n  di.isInducing.continuous\n\n"}
{"name":"IsDenseInducing.closure_range","module":"Mathlib.Topology.DenseEmbedding","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : TopologicalSpace Î²\ni : Î± â†’ Î²\ndi : IsDenseInducing i\nâŠ¢ Eq (closure (Set.range i)) Set.univ","decl":"theorem closure_range (di : IsDenseInducing i) : closure (range i) = univ :=\n  di.dense.closure_range\n\n"}
{"name":"IsDenseInducing.preconnectedSpace","module":"Mathlib.Topology.DenseEmbedding","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : TopologicalSpace Î²\ni : Î± â†’ Î²\ninstâœ : PreconnectedSpace Î±\ndi : IsDenseInducing i\nâŠ¢ PreconnectedSpace Î²","decl":"protected theorem preconnectedSpace [PreconnectedSpace Î±] (di : IsDenseInducing i) :\n    PreconnectedSpace Î² :=\n  di.dense.preconnectedSpace di.continuous\n\n"}
{"name":"IsDenseInducing.closure_image_mem_nhds","module":"Mathlib.Topology.DenseEmbedding","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : TopologicalSpace Î²\ni : Î± â†’ Î²\ns : Set Î±\na : Î±\ndi : IsDenseInducing i\nhs : Membership.mem (nhds a) s\nâŠ¢ Membership.mem (nhds (i a)) (closure (Set.image i s))","decl":"theorem closure_image_mem_nhds {s : Set Î±} {a : Î±} (di : IsDenseInducing i) (hs : s âˆˆ ğ“ a) :\n    closure (i '' s) âˆˆ ğ“ (i a) := by\n  rw [di.nhds_eq_comap a, ((nhds_basis_opens _).comap _).mem_iff] at hs\n  rcases hs with âŸ¨U, âŸ¨haU, hUoâŸ©, sub : i â»Â¹' U âŠ† sâŸ©\n  refine mem_of_superset (hUo.mem_nhds haU) ?_\n  calc\n    U âŠ† closure (i '' (i â»Â¹' U)) := di.dense.subset_closure_image_preimage_of_isOpen hUo\n    _ âŠ† closure (i '' s) := closure_mono (image_subset i sub)\n\n"}
{"name":"IsDenseInducing.dense_image","module":"Mathlib.Topology.DenseEmbedding","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : TopologicalSpace Î²\ni : Î± â†’ Î²\ndi : IsDenseInducing i\ns : Set Î±\nâŠ¢ Iff (Dense (Set.image i s)) (Dense s)","decl":"theorem dense_image (di : IsDenseInducing i) {s : Set Î±} : Dense (i '' s) â†” Dense s := by\n  refine âŸ¨fun H x => ?_, di.dense.dense_image di.continuousâŸ©\n  rw [di.isInducing.closure_eq_preimage_closure_image, H.closure_eq, preimage_univ]\n  trivial\n\n"}
{"name":"IsDenseInducing.interior_compact_eq_empty","module":"Mathlib.Topology.DenseEmbedding","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : TopologicalSpace Î²\ni : Î± â†’ Î²\ninstâœ : T2Space Î²\ndi : IsDenseInducing i\nhd : Dense (HasCompl.compl (Set.range i))\ns : Set Î±\nhs : IsCompact s\nâŠ¢ Eq (interior s) EmptyCollection.emptyCollection","decl":"/-- If `i : Î± â†’ Î²` is a dense embedding with dense complement of the range, then any compact set in\n`Î±` has empty interior. -/\ntheorem interior_compact_eq_empty [T2Space Î²] (di : IsDenseInducing i) (hd : Dense (range i)á¶œ)\n    {s : Set Î±} (hs : IsCompact s) : interior s = âˆ… := by\n  refine eq_empty_iff_forall_not_mem.2 fun x hx => ?_\n  rw [mem_interior_iff_mem_nhds] at hx\n  have := di.closure_image_mem_nhds hx\n  rw [(hs.image di.continuous).isClosed.closure_eq] at this\n  rcases hd.inter_nhds_nonempty this with âŸ¨y, hyi, hysâŸ©\n  exact hyi (image_subset_range _ _ hys)\n\n"}
{"name":"IsDenseInducing.prodMap","module":"Mathlib.Topology.DenseEmbedding","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nÎ´ : Type u_4\ninstâœÂ³ : TopologicalSpace Î±\ninstâœÂ² : TopologicalSpace Î²\ninstâœÂ¹ : TopologicalSpace Î³\ninstâœ : TopologicalSpace Î´\neâ‚ : Î± â†’ Î²\neâ‚‚ : Î³ â†’ Î´\ndeâ‚ : IsDenseInducing eâ‚\ndeâ‚‚ : IsDenseInducing eâ‚‚\nâŠ¢ IsDenseInducing (Prod.map eâ‚ eâ‚‚)","decl":"/-- The product of two dense inducings is a dense inducing -/\nprotected theorem prodMap [TopologicalSpace Î³] [TopologicalSpace Î´] {eâ‚ : Î± â†’ Î²} {eâ‚‚ : Î³ â†’ Î´}\n    (deâ‚ : IsDenseInducing eâ‚) (deâ‚‚ : IsDenseInducing eâ‚‚) :\n    IsDenseInducing (Prod.map eâ‚ eâ‚‚) where\n  toIsInducing := deâ‚.isInducing.prodMap deâ‚‚.isInducing\n  dense := deâ‚.dense.prodMap deâ‚‚.dense\n\n"}
{"name":"IsDenseInducing.prod","module":"Mathlib.Topology.DenseEmbedding","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nÎ´ : Type u_4\ninstâœÂ³ : TopologicalSpace Î±\ninstâœÂ² : TopologicalSpace Î²\ninstâœÂ¹ : TopologicalSpace Î³\ninstâœ : TopologicalSpace Î´\neâ‚ : Î± â†’ Î²\neâ‚‚ : Î³ â†’ Î´\ndeâ‚ : IsDenseInducing eâ‚\ndeâ‚‚ : IsDenseInducing eâ‚‚\nâŠ¢ IsDenseInducing (Prod.map eâ‚ eâ‚‚)","decl":"@[deprecated (since := \"2024-10-06\")]\nprotected alias prod := IsDenseInducing.prodMap\n\n"}
{"name":"IsDenseInducing.separableSpace","module":"Mathlib.Topology.DenseEmbedding","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : TopologicalSpace Î²\ni : Î± â†’ Î²\ninstâœ : TopologicalSpace.SeparableSpace Î±\ndi : IsDenseInducing i\nâŠ¢ TopologicalSpace.SeparableSpace Î²","decl":"/-- If the domain of a `IsDenseInducing` map is a separable space, then so is the codomain. -/\nprotected theorem separableSpace [SeparableSpace Î±] (di : IsDenseInducing i) : SeparableSpace Î² :=\n  di.dense.separableSpace di.continuous\n\n"}
{"name":"IsDenseInducing.tendsto_comap_nhds_nhds","module":"Mathlib.Topology.DenseEmbedding","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nÎ´ : Type u_4\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : TopologicalSpace Î²\ni : Î± â†’ Î²\ninstâœ : TopologicalSpace Î´\nf : Î³ â†’ Î±\ng : Î³ â†’ Î´\nh : Î´ â†’ Î²\nd : Î´\na : Î±\ndi : IsDenseInducing i\nH : Filter.Tendsto h (nhds d) (nhds (i a))\ncomm : Eq (Function.comp h g) (Function.comp i f)\nâŠ¢ Filter.Tendsto f (Filter.comap g (nhds d)) (nhds a)","decl":"/--\n```\n Î³ -fâ†’ Î±\ngâ†“     â†“e\n Î´ -hâ†’ Î²\n```\n-/\ntheorem tendsto_comap_nhds_nhds {d : Î´} {a : Î±} (di : IsDenseInducing i)\n    (H : Tendsto h (ğ“ d) (ğ“ (i a))) (comm : h âˆ˜ g = i âˆ˜ f) : Tendsto f (comap g (ğ“ d)) (ğ“ a) := by\n  have lim1 : map g (comap g (ğ“ d)) â‰¤ ğ“ d := map_comap_le\n  replace lim1 : map h (map g (comap g (ğ“ d))) â‰¤ map h (ğ“ d) := map_mono lim1\n  rw [Filter.map_map, comm, â† Filter.map_map, map_le_iff_le_comap] at lim1\n  have lim2 : comap i (map h (ğ“ d)) â‰¤ comap i (ğ“ (i a)) := comap_mono H\n  rw [â† di.nhds_eq_comap] at lim2\n  exact le_trans lim1 lim2\n\n"}
{"name":"IsDenseInducing.nhdsWithin_neBot","module":"Mathlib.Topology.DenseEmbedding","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : TopologicalSpace Î²\ni : Î± â†’ Î²\ndi : IsDenseInducing i\nb : Î²\nâŠ¢ (nhdsWithin b (Set.range i)).NeBot","decl":"protected theorem nhdsWithin_neBot (di : IsDenseInducing i) (b : Î²) : NeBot (ğ“[range i] b) :=\n  di.dense.nhdsWithin_neBot b\n\n"}
{"name":"IsDenseInducing.comap_nhds_neBot","module":"Mathlib.Topology.DenseEmbedding","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : TopologicalSpace Î²\ni : Î± â†’ Î²\ndi : IsDenseInducing i\nb : Î²\nâŠ¢ (Filter.comap i (nhds b)).NeBot","decl":"theorem comap_nhds_neBot (di : IsDenseInducing i) (b : Î²) : NeBot (comap i (ğ“ b)) :=\n  comap_neBot fun s hs => by\n    rcases mem_closure_iff_nhds.1 (di.dense b) s hs with âŸ¨_, âŸ¨ha, a, rflâŸ©âŸ©\n    exact âŸ¨a, haâŸ©\n\n"}
{"name":"IsDenseInducing.extend_eq_of_tendsto","module":"Mathlib.Topology.DenseEmbedding","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\ninstâœÂ³ : TopologicalSpace Î±\ninstâœÂ² : TopologicalSpace Î²\ni : Î± â†’ Î²\ninstâœÂ¹ : TopologicalSpace Î³\ninstâœ : T2Space Î³\ndi : IsDenseInducing i\nb : Î²\nc : Î³\nf : Î± â†’ Î³\nhf : Filter.Tendsto f (Filter.comap i (nhds b)) (nhds c)\nâŠ¢ Eq (di.extend f b) c","decl":"theorem extend_eq_of_tendsto [T2Space Î³] (di : IsDenseInducing i) {b : Î²} {c : Î³} {f : Î± â†’ Î³}\n    (hf : Tendsto f (comap i (ğ“ b)) (ğ“ c)) : di.extend f b = c :=\n  haveI := di.comap_nhds_neBot\n  hf.limUnder_eq\n\n"}
{"name":"IsDenseInducing.extend_eq_at","module":"Mathlib.Topology.DenseEmbedding","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\ninstâœÂ³ : TopologicalSpace Î±\ninstâœÂ² : TopologicalSpace Î²\ni : Î± â†’ Î²\ninstâœÂ¹ : TopologicalSpace Î³\ninstâœ : T2Space Î³\ndi : IsDenseInducing i\nf : Î± â†’ Î³\na : Î±\nhf : ContinuousAt f a\nâŠ¢ Eq (di.extend f (i a)) (f a)","decl":"theorem extend_eq_at [T2Space Î³] (di : IsDenseInducing i) {f : Î± â†’ Î³} {a : Î±}\n    (hf : ContinuousAt f a) : di.extend f (i a) = f a :=\n  extend_eq_of_tendsto _ <| di.nhds_eq_comap a â–¸ hf\n\n"}
{"name":"IsDenseInducing.extend_eq_at'","module":"Mathlib.Topology.DenseEmbedding","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\ninstâœÂ³ : TopologicalSpace Î±\ninstâœÂ² : TopologicalSpace Î²\ni : Î± â†’ Î²\ninstâœÂ¹ : TopologicalSpace Î³\ninstâœ : T2Space Î³\ndi : IsDenseInducing i\nf : Î± â†’ Î³\na : Î±\nc : Î³\nhf : Filter.Tendsto f (nhds a) (nhds c)\nâŠ¢ Eq (di.extend f (i a)) (f a)","decl":"theorem extend_eq_at' [T2Space Î³] (di : IsDenseInducing i) {f : Î± â†’ Î³} {a : Î±} (c : Î³)\n    (hf : Tendsto f (ğ“ a) (ğ“ c)) : di.extend f (i a) = f a :=\n  di.extend_eq_at (continuousAt_of_tendsto_nhds hf)\n\n"}
{"name":"IsDenseInducing.extend_eq","module":"Mathlib.Topology.DenseEmbedding","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\ninstâœÂ³ : TopologicalSpace Î±\ninstâœÂ² : TopologicalSpace Î²\ni : Î± â†’ Î²\ninstâœÂ¹ : TopologicalSpace Î³\ninstâœ : T2Space Î³\ndi : IsDenseInducing i\nf : Î± â†’ Î³\nhf : Continuous f\na : Î±\nâŠ¢ Eq (di.extend f (i a)) (f a)","decl":"theorem extend_eq [T2Space Î³] (di : IsDenseInducing i) {f : Î± â†’ Î³} (hf : Continuous f) (a : Î±) :\n    di.extend f (i a) = f a :=\n  di.extend_eq_at hf.continuousAt\n\n"}
{"name":"IsDenseInducing.extend_eq'","module":"Mathlib.Topology.DenseEmbedding","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\ninstâœÂ³ : TopologicalSpace Î±\ninstâœÂ² : TopologicalSpace Î²\ni : Î± â†’ Î²\ninstâœÂ¹ : TopologicalSpace Î³\ninstâœ : T2Space Î³\nf : Î± â†’ Î³\ndi : IsDenseInducing i\nhf : âˆ€ (b : Î²), Exists fun c => Filter.Tendsto f (Filter.comap i (nhds b)) (nhds c)\na : Î±\nâŠ¢ Eq (di.extend f (i a)) (f a)","decl":"/-- Variation of `extend_eq` where we ask that `f` has a limit along `comap i (ğ“ b)` for each\n`b : Î²`. This is a strictly stronger assumption than continuity of `f`, but in a lot of cases\nyou'd have to prove it anyway to use `continuous_extend`, so this avoids doing the work twice. -/\ntheorem extend_eq' [T2Space Î³] {f : Î± â†’ Î³} (di : IsDenseInducing i)\n    (hf : âˆ€ b, âˆƒ c, Tendsto f (comap i (ğ“ b)) (ğ“ c)) (a : Î±) : di.extend f (i a) = f a := by\n  rcases hf (i a) with âŸ¨b, hbâŸ©\n  refine di.extend_eq_at' b ?_\n  rwa [â† di.isInducing.nhds_eq_comap] at hb\n\n"}
{"name":"IsDenseInducing.extend_unique_at","module":"Mathlib.Topology.DenseEmbedding","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\ninstâœÂ³ : TopologicalSpace Î±\ninstâœÂ² : TopologicalSpace Î²\ni : Î± â†’ Î²\ninstâœÂ¹ : TopologicalSpace Î³\ninstâœ : T2Space Î³\nb : Î²\nf : Î± â†’ Î³\ng : Î² â†’ Î³\ndi : IsDenseInducing i\nhf : Filter.Eventually (fun x => Eq (g (i x)) (f x)) (Filter.comap i (nhds b))\nhg : ContinuousAt g b\nâŠ¢ Eq (di.extend f b) (g b)","decl":"theorem extend_unique_at [T2Space Î³] {b : Î²} {f : Î± â†’ Î³} {g : Î² â†’ Î³} (di : IsDenseInducing i)\n    (hf : âˆ€á¶  x in comap i (ğ“ b), g (i x) = f x) (hg : ContinuousAt g b) : di.extend f b = g b := by\n  refine di.extend_eq_of_tendsto fun s hs => mem_map.2 ?_\n  suffices âˆ€á¶  x : Î± in comap i (ğ“ b), g (i x) âˆˆ s from\n    hf.mp (this.mono fun x hgx hfx => hfx â–¸ hgx)\n  clear hf f\n  refine eventually_comap.2 ((hg.eventually hs).mono ?_)\n  rintro _ hxs x rfl\n  exact hxs\n\n"}
{"name":"IsDenseInducing.extend_unique","module":"Mathlib.Topology.DenseEmbedding","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\ninstâœÂ³ : TopologicalSpace Î±\ninstâœÂ² : TopologicalSpace Î²\ni : Î± â†’ Î²\ninstâœÂ¹ : TopologicalSpace Î³\ninstâœ : T2Space Î³\nf : Î± â†’ Î³\ng : Î² â†’ Î³\ndi : IsDenseInducing i\nhf : âˆ€ (x : Î±), Eq (g (i x)) (f x)\nhg : Continuous g\nâŠ¢ Eq (di.extend f) g","decl":"theorem extend_unique [T2Space Î³] {f : Î± â†’ Î³} {g : Î² â†’ Î³} (di : IsDenseInducing i)\n    (hf : âˆ€ x, g (i x) = f x) (hg : Continuous g) : di.extend f = g :=\n  funext fun _ => extend_unique_at di (Eventually.of_forall hf) hg.continuousAt\n\n"}
{"name":"IsDenseInducing.continuousAt_extend","module":"Mathlib.Topology.DenseEmbedding","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\ninstâœÂ³ : TopologicalSpace Î±\ninstâœÂ² : TopologicalSpace Î²\ni : Î± â†’ Î²\ninstâœÂ¹ : TopologicalSpace Î³\ninstâœ : T3Space Î³\nb : Î²\nf : Î± â†’ Î³\ndi : IsDenseInducing i\nhf : Filter.Eventually (fun x => Exists fun c => Filter.Tendsto f (Filter.comap i (nhds x)) (nhds c)) (nhds b)\nâŠ¢ ContinuousAt (di.extend f) b","decl":"theorem continuousAt_extend [T3Space Î³] {b : Î²} {f : Î± â†’ Î³} (di : IsDenseInducing i)\n    (hf : âˆ€á¶  x in ğ“ b, âˆƒ c, Tendsto f (comap i <| ğ“ x) (ğ“ c)) : ContinuousAt (di.extend f) b := by\n  set Ï† := di.extend f\n  haveI := di.comap_nhds_neBot\n  suffices âˆ€ V' âˆˆ ğ“ (Ï† b), IsClosed V' â†’ Ï† â»Â¹' V' âˆˆ ğ“ b by\n    simpa [ContinuousAt, (closed_nhds_basis (Ï† b)).tendsto_right_iff]\n  intro V' V'_in V'_closed\n  set Vâ‚ := { x | Tendsto f (comap i <| ğ“ x) (ğ“ <| Ï† x) }\n  have Vâ‚_in : Vâ‚ âˆˆ ğ“ b := by\n    filter_upwards [hf]\n    rintro x âŸ¨c, hcâŸ©\n    rwa [â† di.extend_eq_of_tendsto hc] at hc\n  obtain âŸ¨Vâ‚‚, Vâ‚‚_in, Vâ‚‚_op, hVâ‚‚âŸ© : âˆƒ Vâ‚‚ âˆˆ ğ“ b, IsOpen Vâ‚‚ âˆ§ âˆ€ x âˆˆ i â»Â¹' Vâ‚‚, f x âˆˆ V' := by\n    simpa [and_assoc] using\n      ((nhds_basis_opens' b).comap i).tendsto_left_iff.mp (mem_of_mem_nhds Vâ‚_in : b âˆˆ Vâ‚) V' V'_in\n  suffices âˆ€ x âˆˆ Vâ‚ âˆ© Vâ‚‚, Ï† x âˆˆ V' by filter_upwards [inter_mem Vâ‚_in Vâ‚‚_in] using this\n  rintro x âŸ¨x_inâ‚, x_inâ‚‚âŸ©\n  have hVâ‚‚x : Vâ‚‚ âˆˆ ğ“ x := IsOpen.mem_nhds Vâ‚‚_op x_inâ‚‚\n  apply V'_closed.mem_of_tendsto x_inâ‚\n  use Vâ‚‚\n  tauto\n\n"}
{"name":"IsDenseInducing.continuous_extend","module":"Mathlib.Topology.DenseEmbedding","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\ninstâœÂ³ : TopologicalSpace Î±\ninstâœÂ² : TopologicalSpace Î²\ni : Î± â†’ Î²\ninstâœÂ¹ : TopologicalSpace Î³\ninstâœ : T3Space Î³\nf : Î± â†’ Î³\ndi : IsDenseInducing i\nhf : âˆ€ (b : Î²), Exists fun c => Filter.Tendsto f (Filter.comap i (nhds b)) (nhds c)\nâŠ¢ Continuous (di.extend f)","decl":"theorem continuous_extend [T3Space Î³] {f : Î± â†’ Î³} (di : IsDenseInducing i)\n    (hf : âˆ€ b, âˆƒ c, Tendsto f (comap i (ğ“ b)) (ğ“ c)) : Continuous (di.extend f) :=\n  continuous_iff_continuousAt.mpr fun _ => di.continuousAt_extend <| univ_mem' hf\n\n"}
{"name":"IsDenseInducing.mk'","module":"Mathlib.Topology.DenseEmbedding","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : TopologicalSpace Î²\ni : Î± â†’ Î²\nc : Continuous i\ndense : âˆ€ (x : Î²), Membership.mem (closure (Set.range i)) x\nH : âˆ€ (a : Î±) (s : Set Î±), Membership.mem (nhds a) s â†’ Exists fun t => And (Membership.mem (nhds (i a)) t) (âˆ€ (b : Î±), Membership.mem t (i b) â†’ Membership.mem s b)\nâŠ¢ IsDenseInducing i","decl":"theorem mk' (i : Î± â†’ Î²) (c : Continuous i) (dense : âˆ€ x, x âˆˆ closure (range i))\n    (H : âˆ€ (a : Î±), âˆ€ s âˆˆ ğ“ a, âˆƒ t âˆˆ ğ“ (i a), âˆ€ b, i b âˆˆ t â†’ b âˆˆ s) : IsDenseInducing i where\n  toIsInducing := isInducing_iff_nhds.2 fun a =>\n      le_antisymm (c.tendsto _).le_comap (by simpa [Filter.le_def] using H a)\n  dense := dense\n\n"}
{"name":"Dense.extend_eq_of_tendsto","module":"Mathlib.Topology.DenseEmbedding","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : TopologicalSpace Î²\ns : Set Î±\nf : â†‘s â†’ Î²\ninstâœ : T2Space Î²\nhs : Dense s\na : Î±\nb : Î²\nhf : Filter.Tendsto f (Filter.comap Subtype.val (nhds a)) (nhds b)\nâŠ¢ Eq (hs.extend f a) b","decl":"theorem extend_eq_of_tendsto [T2Space Î²] (hs : Dense s) {a : Î±} {b : Î²}\n    (hf : Tendsto f (comap (â†‘) (ğ“ a)) (ğ“ b)) : hs.extend f a = b :=\n  hs.isDenseInducing_val.extend_eq_of_tendsto hf\n\n"}
{"name":"Dense.extend_eq_at","module":"Mathlib.Topology.DenseEmbedding","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : TopologicalSpace Î²\ns : Set Î±\ninstâœ : T2Space Î²\nhs : Dense s\nf : â†‘s â†’ Î²\nx : â†‘s\nhf : ContinuousAt f x\nâŠ¢ Eq (hs.extend f â†‘x) (f x)","decl":"theorem extend_eq_at [T2Space Î²] (hs : Dense s) {f : s â†’ Î²} {x : s}\n    (hf : ContinuousAt f x) : hs.extend f x = f x :=\n  hs.isDenseInducing_val.extend_eq_at hf\n\n"}
{"name":"Dense.extend_eq","module":"Mathlib.Topology.DenseEmbedding","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : TopologicalSpace Î²\ns : Set Î±\nf : â†‘s â†’ Î²\ninstâœ : T2Space Î²\nhs : Dense s\nhf : Continuous f\nx : â†‘s\nâŠ¢ Eq (hs.extend f â†‘x) (f x)","decl":"theorem extend_eq [T2Space Î²] (hs : Dense s) (hf : Continuous f) (x : s) :\n    hs.extend f x = f x :=\n  hs.extend_eq_at hf.continuousAt\n\n"}
{"name":"Dense.extend_unique_at","module":"Mathlib.Topology.DenseEmbedding","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : TopologicalSpace Î²\ns : Set Î±\nf : â†‘s â†’ Î²\ninstâœ : T2Space Î²\na : Î±\ng : Î± â†’ Î²\nhs : Dense s\nhf : Filter.Eventually (fun x => Eq (g â†‘x) (f x)) (Filter.comap Subtype.val (nhds a))\nhg : ContinuousAt g a\nâŠ¢ Eq (hs.extend f a) (g a)","decl":"theorem extend_unique_at [T2Space Î²] {a : Î±} {g : Î± â†’ Î²} (hs : Dense s)\n    (hf : âˆ€á¶  x : s in comap (â†‘) (ğ“ a), g x = f x) (hg : ContinuousAt g a) :\n    hs.extend f a = g a :=\n  hs.isDenseInducing_val.extend_unique_at hf hg\n\n"}
{"name":"Dense.extend_unique","module":"Mathlib.Topology.DenseEmbedding","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : TopologicalSpace Î²\ns : Set Î±\nf : â†‘s â†’ Î²\ninstâœ : T2Space Î²\ng : Î± â†’ Î²\nhs : Dense s\nhf : âˆ€ (x : â†‘s), Eq (g â†‘x) (f x)\nhg : Continuous g\nâŠ¢ Eq (hs.extend f) g","decl":"theorem extend_unique [T2Space Î²] {g : Î± â†’ Î²} (hs : Dense s)\n    (hf : âˆ€ x : s, g x = f x) (hg : Continuous g) : hs.extend f = g :=\n  hs.isDenseInducing_val.extend_unique hf hg\n\n"}
{"name":"Dense.continuousAt_extend","module":"Mathlib.Topology.DenseEmbedding","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : TopologicalSpace Î²\ns : Set Î±\nf : â†‘s â†’ Î²\ninstâœ : T3Space Î²\na : Î±\nhs : Dense s\nhf : Filter.Eventually (fun x => Exists fun b => Filter.Tendsto f (Filter.comap Subtype.val (nhds x)) (nhds b)) (nhds a)\nâŠ¢ ContinuousAt (hs.extend f) a","decl":"theorem continuousAt_extend [T3Space Î²] {a : Î±} (hs : Dense s)\n    (hf : âˆ€á¶  x in ğ“ a, âˆƒ b, Tendsto f (comap (â†‘) <| ğ“ x) (ğ“ b)) :\n    ContinuousAt (hs.extend f) a :=\n  hs.isDenseInducing_val.continuousAt_extend hf\n\n"}
{"name":"Dense.continuous_extend","module":"Mathlib.Topology.DenseEmbedding","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : TopologicalSpace Î²\ns : Set Î±\nf : â†‘s â†’ Î²\ninstâœ : T3Space Î²\nhs : Dense s\nhf : âˆ€ (a : Î±), Exists fun b => Filter.Tendsto f (Filter.comap Subtype.val (nhds a)) (nhds b)\nâŠ¢ Continuous (hs.extend f)","decl":"theorem continuous_extend [T3Space Î²] (hs : Dense s)\n    (hf : âˆ€ a : Î±, âˆƒ b, Tendsto f (comap (â†‘) (ğ“ a)) (ğ“ b)) : Continuous (hs.extend f) :=\n  hs.isDenseInducing_val.continuous_extend hf\n\n"}
{"name":"IsDenseEmbedding.toIsDenseInducing","module":"Mathlib.Topology.DenseEmbedding","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : TopologicalSpace Î²\ne : Î± â†’ Î²\nself : IsDenseEmbedding e\nâŠ¢ IsDenseInducing e","decl":"/-- A dense embedding is an embedding with dense image. -/\nstructure IsDenseEmbedding [TopologicalSpace Î±] [TopologicalSpace Î²] (e : Î± â†’ Î²) extends\n  IsDenseInducing e : Prop where\n  /-- A dense embedding is injective. -/\n  injective : Function.Injective e\n\n"}
{"name":"IsDenseEmbedding.injective","module":"Mathlib.Topology.DenseEmbedding","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : TopologicalSpace Î²\ne : Î± â†’ Î²\nself : IsDenseEmbedding e\nâŠ¢ Function.Injective e","decl":"/-- A dense embedding is an embedding with dense image. -/\nstructure IsDenseEmbedding [TopologicalSpace Î±] [TopologicalSpace Î²] (e : Î± â†’ Î²) extends\n  IsDenseInducing e : Prop where\n  /-- A dense embedding is injective. -/\n  injective : Function.Injective e\n\n"}
{"name":"IsDenseEmbedding.mk'","module":"Mathlib.Topology.DenseEmbedding","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : TopologicalSpace Î²\ne : Î± â†’ Î²\nc : Continuous e\ndense : DenseRange e\ninjective : Function.Injective e\nH : âˆ€ (a : Î±) (s : Set Î±), Membership.mem (nhds a) s â†’ Exists fun t => And (Membership.mem (nhds (e a)) t) (âˆ€ (b : Î±), Membership.mem t (e b) â†’ Membership.mem s b)\nâŠ¢ IsDenseEmbedding e","decl":"lemma IsDenseEmbedding.mk' [TopologicalSpace Î±] [TopologicalSpace Î²] (e : Î± â†’ Î²) (c : Continuous e)\n    (dense : DenseRange e) (injective : Function.Injective e)\n    (H : âˆ€ (a : Î±), âˆ€ s âˆˆ ğ“ a, âˆƒ t âˆˆ ğ“ (e a), âˆ€ b, e b âˆˆ t â†’ b âˆˆ s) : IsDenseEmbedding e :=\n  { IsDenseInducing.mk' e c dense H with injective }\n\n"}
{"name":"DenseEmbedding.mk'","module":"Mathlib.Topology.DenseEmbedding","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : TopologicalSpace Î²\ne : Î± â†’ Î²\nc : Continuous e\ndense : DenseRange e\ninjective : Function.Injective e\nH : âˆ€ (a : Î±) (s : Set Î±), Membership.mem (nhds a) s â†’ Exists fun t => And (Membership.mem (nhds (e a)) t) (âˆ€ (b : Î±), Membership.mem t (e b) â†’ Membership.mem s b)\nâŠ¢ IsDenseEmbedding e","decl":"@[deprecated (since := \"2024-09-30\")]\nalias DenseEmbedding.mk' := IsDenseEmbedding.mk'\n\n"}
{"name":"IsDenseEmbedding.isDenseInducing","module":"Mathlib.Topology.DenseEmbedding","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : TopologicalSpace Î²\ne : Î± â†’ Î²\nde : IsDenseEmbedding e\nâŠ¢ IsDenseInducing e","decl":"lemma isDenseInducing (de : IsDenseEmbedding e) : IsDenseInducing e := de.toIsDenseInducing\n\n"}
{"name":"IsDenseEmbedding.inj_iff","module":"Mathlib.Topology.DenseEmbedding","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : TopologicalSpace Î²\ne : Î± â†’ Î²\nde : IsDenseEmbedding e\nx y : Î±\nâŠ¢ Iff (Eq (e x) (e y)) (Eq x y)","decl":"theorem inj_iff (de : IsDenseEmbedding e) {x y} : e x = e y â†” x = y :=\n  de.injective.eq_iff\n\n"}
{"name":"IsDenseEmbedding.isEmbedding","module":"Mathlib.Topology.DenseEmbedding","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : TopologicalSpace Î²\ne : Î± â†’ Î²\nde : IsDenseEmbedding e\nâŠ¢ Topology.IsEmbedding e","decl":"theorem isEmbedding (de : IsDenseEmbedding e) : IsEmbedding e where __ := de\n\n"}
{"name":"IsDenseEmbedding.to_embedding","module":"Mathlib.Topology.DenseEmbedding","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : TopologicalSpace Î²\ne : Î± â†’ Î²\nde : IsDenseEmbedding e\nâŠ¢ Topology.IsEmbedding e","decl":"@[deprecated (since := \"2024-10-26\")]\nalias to_embedding := isEmbedding\n\n"}
{"name":"IsDenseEmbedding.separableSpace","module":"Mathlib.Topology.DenseEmbedding","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : TopologicalSpace Î²\ne : Î± â†’ Î²\ninstâœ : TopologicalSpace.SeparableSpace Î±\nde : IsDenseEmbedding e\nâŠ¢ TopologicalSpace.SeparableSpace Î²","decl":"/-- If the domain of a `IsDenseEmbedding` is a separable space, then so is its codomain. -/\nprotected theorem separableSpace [SeparableSpace Î±] (de : IsDenseEmbedding e) : SeparableSpace Î² :=\n  de.isDenseInducing.separableSpace\n\n"}
{"name":"IsDenseEmbedding.prodMap","module":"Mathlib.Topology.DenseEmbedding","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nÎ´ : Type u_4\ninstâœÂ³ : TopologicalSpace Î±\ninstâœÂ² : TopologicalSpace Î²\ninstâœÂ¹ : TopologicalSpace Î³\ninstâœ : TopologicalSpace Î´\neâ‚ : Î± â†’ Î²\neâ‚‚ : Î³ â†’ Î´\ndeâ‚ : IsDenseEmbedding eâ‚\ndeâ‚‚ : IsDenseEmbedding eâ‚‚\nâŠ¢ IsDenseEmbedding fun p => { fst := eâ‚ p.1, snd := eâ‚‚ p.2 }","decl":"/-- The product of two dense embeddings is a dense embedding. -/\nprotected theorem prodMap {eâ‚ : Î± â†’ Î²} {eâ‚‚ : Î³ â†’ Î´} (deâ‚ : IsDenseEmbedding eâ‚)\n    (deâ‚‚ : IsDenseEmbedding eâ‚‚) : IsDenseEmbedding fun p : Î± Ã— Î³ => (eâ‚ p.1, eâ‚‚ p.2) where\n  toIsDenseInducing := deâ‚.isDenseInducing.prodMap deâ‚‚.isDenseInducing\n  injective := deâ‚.injective.prodMap deâ‚‚.injective\n\n"}
{"name":"IsDenseEmbedding.prod","module":"Mathlib.Topology.DenseEmbedding","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nÎ´ : Type u_4\ninstâœÂ³ : TopologicalSpace Î±\ninstâœÂ² : TopologicalSpace Î²\ninstâœÂ¹ : TopologicalSpace Î³\ninstâœ : TopologicalSpace Î´\neâ‚ : Î± â†’ Î²\neâ‚‚ : Î³ â†’ Î´\ndeâ‚ : IsDenseEmbedding eâ‚\ndeâ‚‚ : IsDenseEmbedding eâ‚‚\nâŠ¢ IsDenseEmbedding fun p => { fst := eâ‚ p.1, snd := eâ‚‚ p.2 }","decl":"@[deprecated (since := \"2024-10-06\")] protected alias prod := IsDenseEmbedding.prodMap\n\n"}
{"name":"IsDenseEmbedding.subtypeEmb_coe","module":"Mathlib.Topology.DenseEmbedding","initialProofState":"Î² : Type u_2\ninstâœ : TopologicalSpace Î²\nÎ± : Type u_5\np : Î± â†’ Prop\ne : Î± â†’ Î²\nx : Subtype fun x => p x\nâŠ¢ Eq (â†‘(IsDenseEmbedding.subtypeEmb p e x)) (e â†‘x)","decl":"/-- The dense embedding of a subtype inside its closure. -/\n@[simps]\ndef subtypeEmb {Î± : Type*} (p : Î± â†’ Prop) (e : Î± â†’ Î²) (x : { x // p x }) :\n    { x // x âˆˆ closure (e '' { x | p x }) } :=\n  âŸ¨e x, subset_closure <| mem_image_of_mem e x.propâŸ©\n\n"}
{"name":"IsDenseEmbedding.subtype","module":"Mathlib.Topology.DenseEmbedding","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : TopologicalSpace Î²\ne : Î± â†’ Î²\nde : IsDenseEmbedding e\np : Î± â†’ Prop\nâŠ¢ IsDenseEmbedding (IsDenseEmbedding.subtypeEmb p e)","decl":"protected theorem subtype (de : IsDenseEmbedding e) (p : Î± â†’ Prop) :\n    IsDenseEmbedding (subtypeEmb p e) where\n  dense :=\n    dense_iff_closure_eq.2 <| by\n      ext âŸ¨x, hxâŸ©\n      rw [image_eq_range] at hx\n      simpa [closure_subtype, â† range_comp, (Â· âˆ˜ Â·)]\n  injective := (de.injective.comp Subtype.coe_injective).codRestrict _\n  eq_induced :=\n    (induced_iff_nhds_eq _).2 fun âŸ¨x, hxâŸ© => by\n      simp [subtypeEmb, nhds_subtype_eq_comap, de.isInducing.nhds_eq_comap, comap_comap,\n        Function.comp_def]\n\n"}
{"name":"IsDenseEmbedding.dense_image","module":"Mathlib.Topology.DenseEmbedding","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : TopologicalSpace Î²\ne : Î± â†’ Î²\nde : IsDenseEmbedding e\ns : Set Î±\nâŠ¢ Iff (Dense (Set.image e s)) (Dense s)","decl":"theorem dense_image (de : IsDenseEmbedding e) {s : Set Î±} : Dense (e '' s) â†” Dense s :=\n  de.isDenseInducing.dense_image\n\n"}
{"name":"IsDenseEmbedding.id","module":"Mathlib.Topology.DenseEmbedding","initialProofState":"Î± : Type u_5\ninstâœ : TopologicalSpace Î±\nâŠ¢ IsDenseEmbedding id","decl":"protected lemma id {Î± : Type*} [TopologicalSpace Î±] : IsDenseEmbedding (id : Î± â†’ Î±) :=\n  { IsEmbedding.id with dense := denseRange_id }\n\n"}
{"name":"denseEmbedding_id","module":"Mathlib.Topology.DenseEmbedding","initialProofState":"Î± : Type u_5\ninstâœ : TopologicalSpace Î±\nâŠ¢ IsDenseEmbedding id","decl":"@[deprecated (since := \"2024-09-30\")]\nalias denseEmbedding_id := IsDenseEmbedding.id\n\n"}
{"name":"Dense.isDenseEmbedding_val","module":"Mathlib.Topology.DenseEmbedding","initialProofState":"Î± : Type u_1\ninstâœ : TopologicalSpace Î±\ns : Set Î±\nhs : Dense s\nâŠ¢ IsDenseEmbedding Subtype.val","decl":"theorem Dense.isDenseEmbedding_val [TopologicalSpace Î±] {s : Set Î±} (hs : Dense s) :\n    IsDenseEmbedding ((â†‘) : s â†’ Î±) :=\n  { IsEmbedding.subtypeVal with dense := hs.denseRange_val }\n\n"}
{"name":"Dense.denseEmbedding_val","module":"Mathlib.Topology.DenseEmbedding","initialProofState":"Î± : Type u_1\ninstâœ : TopologicalSpace Î±\ns : Set Î±\nhs : Dense s\nâŠ¢ IsDenseEmbedding Subtype.val","decl":"@[deprecated (since := \"2024-09-30\")]\nalias Dense.denseEmbedding_val := Dense.isDenseEmbedding_val\n\n"}
{"name":"isClosed_property","module":"Mathlib.Topology.DenseEmbedding","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœ : TopologicalSpace Î²\ne : Î± â†’ Î²\np : Î² â†’ Prop\nhe : DenseRange e\nhp : IsClosed (setOf fun x => p x)\nh : âˆ€ (a : Î±), p (e a)\nb : Î²\nâŠ¢ p b","decl":"theorem isClosed_property [TopologicalSpace Î²] {e : Î± â†’ Î²} {p : Î² â†’ Prop} (he : DenseRange e)\n    (hp : IsClosed { x | p x }) (h : âˆ€ a, p (e a)) : âˆ€ b, p b :=\n  have : univ âŠ† { b | p b } :=\n    calc\n      univ = closure (range e) := he.closure_range.symm\n      _ âŠ† closure { b | p b } := closure_mono <| range_subset_iff.mpr h\n      _ = _ := hp.closure_eq\n\n  fun _ => this trivial\n\n"}
{"name":"isClosed_property2","module":"Mathlib.Topology.DenseEmbedding","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœ : TopologicalSpace Î²\ne : Î± â†’ Î²\np : Î² â†’ Î² â†’ Prop\nhe : DenseRange e\nhp : IsClosed (setOf fun q => p q.1 q.2)\nh : âˆ€ (aâ‚ aâ‚‚ : Î±), p (e aâ‚) (e aâ‚‚)\nbâ‚ bâ‚‚ : Î²\nâŠ¢ p bâ‚ bâ‚‚","decl":"theorem isClosed_property2 [TopologicalSpace Î²] {e : Î± â†’ Î²} {p : Î² â†’ Î² â†’ Prop} (he : DenseRange e)\n    (hp : IsClosed { q : Î² Ã— Î² | p q.1 q.2 }) (h : âˆ€ aâ‚ aâ‚‚, p (e aâ‚) (e aâ‚‚)) : âˆ€ bâ‚ bâ‚‚, p bâ‚ bâ‚‚ :=\n  have : âˆ€ q : Î² Ã— Î², p q.1 q.2 := isClosed_property (he.prodMap he) hp fun _ => h _ _\n  fun bâ‚ bâ‚‚ => this âŸ¨bâ‚, bâ‚‚âŸ©\n\n"}
{"name":"isClosed_property3","module":"Mathlib.Topology.DenseEmbedding","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœ : TopologicalSpace Î²\ne : Î± â†’ Î²\np : Î² â†’ Î² â†’ Î² â†’ Prop\nhe : DenseRange e\nhp : IsClosed (setOf fun q => p q.1 q.2.1 q.2.2)\nh : âˆ€ (aâ‚ aâ‚‚ aâ‚ƒ : Î±), p (e aâ‚) (e aâ‚‚) (e aâ‚ƒ)\nbâ‚ bâ‚‚ bâ‚ƒ : Î²\nâŠ¢ p bâ‚ bâ‚‚ bâ‚ƒ","decl":"theorem isClosed_property3 [TopologicalSpace Î²] {e : Î± â†’ Î²} {p : Î² â†’ Î² â†’ Î² â†’ Prop}\n    (he : DenseRange e) (hp : IsClosed { q : Î² Ã— Î² Ã— Î² | p q.1 q.2.1 q.2.2 })\n    (h : âˆ€ aâ‚ aâ‚‚ aâ‚ƒ, p (e aâ‚) (e aâ‚‚) (e aâ‚ƒ)) : âˆ€ bâ‚ bâ‚‚ bâ‚ƒ, p bâ‚ bâ‚‚ bâ‚ƒ :=\n  have : âˆ€ q : Î² Ã— Î² Ã— Î², p q.1 q.2.1 q.2.2 :=\n    isClosed_property (he.prodMap <| he.prodMap he) hp fun _ => h _ _ _\n  fun bâ‚ bâ‚‚ bâ‚ƒ => this âŸ¨bâ‚, bâ‚‚, bâ‚ƒâŸ©\n\n"}
{"name":"DenseRange.induction_on","module":"Mathlib.Topology.DenseEmbedding","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœ : TopologicalSpace Î²\ne : Î± â†’ Î²\nhe : DenseRange e\np : Î² â†’ Prop\nbâ‚€ : Î²\nhp : IsClosed (setOf fun b => p b)\nih : âˆ€ (a : Î±), p (e a)\nâŠ¢ p bâ‚€","decl":"@[elab_as_elim]\ntheorem DenseRange.induction_on [TopologicalSpace Î²] {e : Î± â†’ Î²} (he : DenseRange e) {p : Î² â†’ Prop}\n    (bâ‚€ : Î²) (hp : IsClosed { b | p b }) (ih : âˆ€ a : Î±, p <| e a) : p bâ‚€ :=\n  isClosed_property he hp ih bâ‚€\n\n"}
{"name":"DenseRange.induction_onâ‚‚","module":"Mathlib.Topology.DenseEmbedding","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœ : TopologicalSpace Î²\ne : Î± â†’ Î²\np : Î² â†’ Î² â†’ Prop\nhe : DenseRange e\nhp : IsClosed (setOf fun q => p q.1 q.2)\nh : âˆ€ (aâ‚ aâ‚‚ : Î±), p (e aâ‚) (e aâ‚‚)\nbâ‚ bâ‚‚ : Î²\nâŠ¢ p bâ‚ bâ‚‚","decl":"@[elab_as_elim]\ntheorem DenseRange.induction_onâ‚‚ [TopologicalSpace Î²] {e : Î± â†’ Î²} {p : Î² â†’ Î² â†’ Prop}\n    (he : DenseRange e) (hp : IsClosed { q : Î² Ã— Î² | p q.1 q.2 }) (h : âˆ€ aâ‚ aâ‚‚, p (e aâ‚) (e aâ‚‚))\n    (bâ‚ bâ‚‚ : Î²) : p bâ‚ bâ‚‚ :=\n  isClosed_property2 he hp h _ _\n\n"}
{"name":"DenseRange.induction_onâ‚ƒ","module":"Mathlib.Topology.DenseEmbedding","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœ : TopologicalSpace Î²\ne : Î± â†’ Î²\np : Î² â†’ Î² â†’ Î² â†’ Prop\nhe : DenseRange e\nhp : IsClosed (setOf fun q => p q.1 q.2.1 q.2.2)\nh : âˆ€ (aâ‚ aâ‚‚ aâ‚ƒ : Î±), p (e aâ‚) (e aâ‚‚) (e aâ‚ƒ)\nbâ‚ bâ‚‚ bâ‚ƒ : Î²\nâŠ¢ p bâ‚ bâ‚‚ bâ‚ƒ","decl":"@[elab_as_elim]\ntheorem DenseRange.induction_onâ‚ƒ [TopologicalSpace Î²] {e : Î± â†’ Î²} {p : Î² â†’ Î² â†’ Î² â†’ Prop}\n    (he : DenseRange e) (hp : IsClosed { q : Î² Ã— Î² Ã— Î² | p q.1 q.2.1 q.2.2 })\n    (h : âˆ€ aâ‚ aâ‚‚ aâ‚ƒ, p (e aâ‚) (e aâ‚‚) (e aâ‚ƒ)) (bâ‚ bâ‚‚ bâ‚ƒ : Î²) : p bâ‚ bâ‚‚ bâ‚ƒ :=\n  isClosed_property3 he hp h _ _ _\n\n"}
{"name":"DenseRange.equalizer","module":"Mathlib.Topology.DenseEmbedding","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\ninstâœÂ² : TopologicalSpace Î²\ninstâœÂ¹ : TopologicalSpace Î³\ninstâœ : T2Space Î³\nf : Î± â†’ Î²\nhfd : DenseRange f\ng h : Î² â†’ Î³\nhg : Continuous g\nhh : Continuous h\nH : Eq (Function.comp g f) (Function.comp h f)\nâŠ¢ Eq g h","decl":"/-- Two continuous functions to a t2-space that agree on the dense range of a function are equal. -/\ntheorem DenseRange.equalizer (hfd : DenseRange f) {g h : Î² â†’ Î³} (hg : Continuous g)\n    (hh : Continuous h) (H : g âˆ˜ f = h âˆ˜ f) : g = h :=\n  funext fun y => hfd.induction_on y (isClosed_eq hg hh) <| congr_fun H\n\n"}
{"name":"Filter.HasBasis.hasBasis_of_isDenseInducing","module":"Mathlib.Topology.DenseEmbedding","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : TopologicalSpace Î²\ninstâœ : T3Space Î²\nÎ¹ : Type u_5\ns : Î¹ â†’ Set Î±\np : Î¹ â†’ Prop\nx : Î±\nh : (nhds x).HasBasis p s\nf : Î± â†’ Î²\nhf : IsDenseInducing f\nâŠ¢ (nhds (f x)).HasBasis p fun i => closure (Set.image f (s i))","decl":"theorem Filter.HasBasis.hasBasis_of_isDenseInducing [TopologicalSpace Î±] [TopologicalSpace Î²]\n    [T3Space Î²] {Î¹ : Type*} {s : Î¹ â†’ Set Î±} {p : Î¹ â†’ Prop} {x : Î±} (h : (ğ“ x).HasBasis p s)\n    {f : Î± â†’ Î²} (hf : IsDenseInducing f) : (ğ“ (f x)).HasBasis p fun i => closure <| f '' s i := by\n  rw [Filter.hasBasis_iff] at h âŠ¢\n  intro T\n  refine âŸ¨fun hT => ?_, fun hT => ?_âŸ©\n  Â· obtain âŸ¨T', hTâ‚, hTâ‚‚, hTâ‚ƒâŸ© := exists_mem_nhds_isClosed_subset hT\n    have hTâ‚„ : f â»Â¹' T' âˆˆ ğ“ x := by\n      rw [hf.isInducing.nhds_eq_comap x]\n      exact âŸ¨T', hTâ‚, Subset.rflâŸ©\n    obtain âŸ¨i, hi, hi'âŸ© := (h _).mp hTâ‚„\n    exact\n      âŸ¨i, hi,\n        (closure_mono (image_subset f hi')).trans\n          (Subset.trans (closure_minimal (image_preimage_subset _ _) hTâ‚‚) hTâ‚ƒ)âŸ©\n  Â· obtain âŸ¨i, hi, hi'âŸ© := hT\n    suffices closure (f '' s i) âˆˆ ğ“ (f x) by filter_upwards [this] using hi'\n    replace h := (h (s i)).mpr âŸ¨i, hi, Subset.rflâŸ©\n    exact hf.closure_image_mem_nhds h\n"}
