{"name":"IsLocalization.mem_localizationLocalizationSubmodule","module":"Mathlib.RingTheory.Localization.LocalizationLocalization","initialProofState":"R : Type u_1\ninst✝² : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst✝¹ : CommSemiring S\ninst✝ : Algebra R S\nN : Submonoid S\nx : R\n⊢ Iff (Membership.mem (IsLocalization.localizationLocalizationSubmodule M N) x) (Exists fun y => Exists fun z => Eq ((algebraMap R S) x) (HMul.hMul (↑y) ((algebraMap R S) ↑z)))","decl":"@[simp]\ntheorem mem_localizationLocalizationSubmodule {x : R} :\n    x ∈ localizationLocalizationSubmodule M N ↔\n      ∃ (y : N) (z : M), algebraMap R S x = y * algebraMap R S z := by\n  rw [localizationLocalizationSubmodule, Submonoid.mem_comap, Submonoid.mem_sup]\n  constructor\n  · rintro ⟨y, hy, _, ⟨z, hz, rfl⟩, e⟩\n    exact ⟨⟨y, hy⟩, ⟨z, hz⟩, e.symm⟩\n  · rintro ⟨y, z, e⟩\n    exact ⟨y, y.prop, _, ⟨z, z.prop, rfl⟩, e.symm⟩\n\n"}
{"name":"IsLocalization.localization_localization_map_units","module":"Mathlib.RingTheory.Localization.LocalizationLocalization","initialProofState":"R : Type u_1\ninst✝⁸ : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst✝⁷ : CommSemiring S\ninst✝⁶ : Algebra R S\nN : Submonoid S\nT : Type u_3\ninst✝⁵ : CommSemiring T\ninst✝⁴ : Algebra R T\ninst✝³ : Algebra S T\ninst✝² : IsScalarTower R S T\ninst✝¹ : IsLocalization M S\ninst✝ : IsLocalization N T\ny : Subtype fun x => Membership.mem (IsLocalization.localizationLocalizationSubmodule M N) x\n⊢ IsUnit ((algebraMap R T) ↑y)","decl":"theorem localization_localization_map_units [IsLocalization N T]\n    (y : localizationLocalizationSubmodule M N) : IsUnit (algebraMap R T y) := by\n  obtain ⟨y', z, eq⟩ := mem_localizationLocalizationSubmodule.mp y.prop\n  rw [IsScalarTower.algebraMap_apply R S T, eq, RingHom.map_mul, IsUnit.mul_iff]\n  exact ⟨IsLocalization.map_units T y', (IsLocalization.map_units _ z).map (algebraMap S T)⟩\n\n"}
{"name":"IsLocalization.localization_localization_surj","module":"Mathlib.RingTheory.Localization.LocalizationLocalization","initialProofState":"R : Type u_1\ninst✝⁸ : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst✝⁷ : CommSemiring S\ninst✝⁶ : Algebra R S\nN : Submonoid S\nT : Type u_3\ninst✝⁵ : CommSemiring T\ninst✝⁴ : Algebra R T\ninst✝³ : Algebra S T\ninst✝² : IsScalarTower R S T\ninst✝¹ : IsLocalization M S\ninst✝ : IsLocalization N T\nx : T\n⊢ Exists fun y => Eq (HMul.hMul x ((algebraMap R T) ↑y.2)) ((algebraMap R T) y.1)","decl":"theorem localization_localization_surj [IsLocalization N T] (x : T) :\n    ∃ y : R × localizationLocalizationSubmodule M N,\n        x * algebraMap R T y.2 = algebraMap R T y.1 := by\n  rcases IsLocalization.surj N x with ⟨⟨y, s⟩, eq₁⟩\n  -- x = y / s\n  rcases IsLocalization.surj M y with ⟨⟨z, t⟩, eq₂⟩\n  -- y = z / t\n  rcases IsLocalization.surj M (s : S) with ⟨⟨z', t'⟩, eq₃⟩\n  -- s = z' / t'\n  dsimp only at eq₁ eq₂ eq₃\n  refine ⟨⟨z * t', z' * t, ?_⟩, ?_⟩ -- x = y / s = (z * t') / (z' * t)\n  · rw [mem_localizationLocalizationSubmodule]\n    refine ⟨s, t * t', ?_⟩\n    rw [RingHom.map_mul, ← eq₃, mul_assoc, ← RingHom.map_mul, mul_comm t, Submonoid.coe_mul]\n  · simp only [Subtype.coe_mk, RingHom.map_mul, IsScalarTower.algebraMap_apply R S T, ← eq₃, ← eq₂,\n      ← eq₁]\n    ring\n\n"}
{"name":"IsLocalization.localization_localization_exists_of_eq","module":"Mathlib.RingTheory.Localization.LocalizationLocalization","initialProofState":"R : Type u_1\ninst✝⁸ : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst✝⁷ : CommSemiring S\ninst✝⁶ : Algebra R S\nN : Submonoid S\nT : Type u_3\ninst✝⁵ : CommSemiring T\ninst✝⁴ : Algebra R T\ninst✝³ : Algebra S T\ninst✝² : IsScalarTower R S T\ninst✝¹ : IsLocalization M S\ninst✝ : IsLocalization N T\nx y : R\na✝ : Eq ((algebraMap R T) x) ((algebraMap R T) y)\n⊢ Exists fun c => Eq (HMul.hMul (↑c) x) (HMul.hMul (↑c) y)","decl":"theorem localization_localization_exists_of_eq [IsLocalization N T] (x y : R) :\n    algebraMap R T x = algebraMap R T y →\n      ∃ c : localizationLocalizationSubmodule M N, ↑c * x = ↑c * y := by\n  rw [IsScalarTower.algebraMap_apply R S T, IsScalarTower.algebraMap_apply R S T,\n    IsLocalization.eq_iff_exists N T]\n  rintro ⟨z, eq₁⟩\n  rcases IsLocalization.surj M (z : S) with ⟨⟨z', s⟩, eq₂⟩\n  dsimp only at eq₂\n  suffices (algebraMap R S) (x * z' : R) = (algebraMap R S) (y * z') by\n    obtain ⟨c, eq₃ : ↑c * (x * z') = ↑c * (y * z')⟩ := (IsLocalization.eq_iff_exists M S).mp this\n    refine ⟨⟨c * z', ?_⟩, ?_⟩\n    · rw [mem_localizationLocalizationSubmodule]\n      refine ⟨z, c * s, ?_⟩\n      rw [map_mul, ← eq₂, Submonoid.coe_mul, map_mul, mul_left_comm]\n    · rwa [mul_comm _ z', mul_comm _ z', ← mul_assoc, ← mul_assoc] at eq₃\n  rw [map_mul, map_mul, ← eq₂, ← mul_assoc, ← mul_assoc, mul_comm _ (z : S), eq₁,\n    mul_comm _ (z : S)]\n\n"}
{"name":"IsLocalization.localization_localization_isLocalization","module":"Mathlib.RingTheory.Localization.LocalizationLocalization","initialProofState":"R : Type u_1\ninst✝⁸ : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst✝⁷ : CommSemiring S\ninst✝⁶ : Algebra R S\nN : Submonoid S\nT : Type u_3\ninst✝⁵ : CommSemiring T\ninst✝⁴ : Algebra R T\ninst✝³ : Algebra S T\ninst✝² : IsScalarTower R S T\ninst✝¹ : IsLocalization M S\ninst✝ : IsLocalization N T\n⊢ IsLocalization (IsLocalization.localizationLocalizationSubmodule M N) T","decl":"/-- Given submodules `M ⊆ R` and `N ⊆ S = M⁻¹R`, with `f : R →+* S` the localization map, we have\n`N ⁻¹ S = T = (f⁻¹ (N • f(M))) ⁻¹ R`. I.e., the localization of a localization is a localization.\n-/\ntheorem localization_localization_isLocalization [IsLocalization N T] :\n    IsLocalization (localizationLocalizationSubmodule M N) T :=\n  { map_units' := localization_localization_map_units M N T\n    surj' := localization_localization_surj M N T\n    exists_of_eq := localization_localization_exists_of_eq M N T _ _ }\n\n"}
{"name":"IsLocalization.localization_localization_isLocalization_of_has_all_units","module":"Mathlib.RingTheory.Localization.LocalizationLocalization","initialProofState":"R : Type u_1\ninst✝⁸ : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst✝⁷ : CommSemiring S\ninst✝⁶ : Algebra R S\nN : Submonoid S\nT : Type u_3\ninst✝⁵ : CommSemiring T\ninst✝⁴ : Algebra R T\ninst✝³ : Algebra S T\ninst✝² : IsScalarTower R S T\ninst✝¹ : IsLocalization M S\ninst✝ : IsLocalization N T\nH : ∀ (x : S), IsUnit x → Membership.mem N x\n⊢ IsLocalization (Submonoid.comap (algebraMap R S) N) T","decl":"include M in\n/-- Given submodules `M ⊆ R` and `N ⊆ S = M⁻¹R`, with `f : R →+* S` the localization map, if\n`N` contains all the units of `S`, then `N ⁻¹ S = T = (f⁻¹ N) ⁻¹ R`. I.e., the localization of a\nlocalization is a localization.\n-/\ntheorem localization_localization_isLocalization_of_has_all_units [IsLocalization N T]\n    (H : ∀ x : S, IsUnit x → x ∈ N) : IsLocalization (N.comap (algebraMap R S)) T := by\n  convert localization_localization_isLocalization M N T using 1\n  dsimp [localizationLocalizationSubmodule]\n  congr\n  symm\n  rw [sup_eq_left]\n  rintro _ ⟨x, hx, rfl⟩\n  exact H _ (IsLocalization.map_units _ ⟨x, hx⟩)\n\n"}
{"name":"IsLocalization.isLocalization_isLocalization_atPrime_isLocalization","module":"Mathlib.RingTheory.Localization.LocalizationLocalization","initialProofState":"R : Type u_1\ninst✝⁸ : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst✝⁷ : CommSemiring S\ninst✝⁶ : Algebra R S\nT : Type u_3\ninst✝⁵ : CommSemiring T\ninst✝⁴ : Algebra R T\ninst✝³ : Algebra S T\ninst✝² : IsScalarTower R S T\ninst✝¹ : IsLocalization M S\np : Ideal S\nHp : p.IsPrime\ninst✝ : IsLocalization.AtPrime T p\n⊢ IsLocalization.AtPrime T (Ideal.comap (algebraMap R S) p)","decl":"include M in\n/--\nGiven a submodule `M ⊆ R` and a prime ideal `p` of `S = M⁻¹R`, with `f : R →+* S` the localization\nmap, then `T = Sₚ` is the localization of `R` at `f⁻¹(p)`.\n-/\ntheorem isLocalization_isLocalization_atPrime_isLocalization (p : Ideal S) [Hp : p.IsPrime]\n    [IsLocalization.AtPrime T p] : IsLocalization.AtPrime T (p.comap (algebraMap R S)) := by\n  apply localization_localization_isLocalization_of_has_all_units M p.primeCompl T\n  intro x hx hx'\n  exact (Hp.1 : ¬_) (p.eq_top_of_isUnit_mem hx' hx)\n\n"}
{"name":"IsLocalization.instIsScalarTowerLocalizationAtPrime","module":"Mathlib.RingTheory.Localization.LocalizationLocalization","initialProofState":"R : Type u_1\ninst✝¹ : CommSemiring R\nM : Submonoid R\np : Ideal (Localization M)\ninst✝ : p.IsPrime\n⊢ IsScalarTower R (Localization M) (Localization.AtPrime p)","decl":"instance (p : Ideal (Localization M)) [p.IsPrime] :\n    IsScalarTower R (Localization M) (Localization.AtPrime p) :=\n  IsScalarTower.of_algebraMap_eq' rfl\n\n"}
{"name":"IsLocalization.localization_localization_atPrime_is_localization","module":"Mathlib.RingTheory.Localization.LocalizationLocalization","initialProofState":"R : Type u_1\ninst✝¹ : CommSemiring R\nM : Submonoid R\np : Ideal (Localization M)\ninst✝ : p.IsPrime\n⊢ IsLocalization.AtPrime (Localization.AtPrime p) (Ideal.comap (algebraMap R (Localization M)) p)","decl":"instance localization_localization_atPrime_is_localization (p : Ideal (Localization M))\n    [p.IsPrime] : IsLocalization.AtPrime (Localization.AtPrime p) (p.comap (algebraMap R _)) :=\n  isLocalization_isLocalization_atPrime_isLocalization M _ _\n\n"}
{"name":"IsLocalization.localization_isScalarTower_of_submonoid_le","module":"Mathlib.RingTheory.Localization.LocalizationLocalization","initialProofState":"R : Type u_1\ninst✝⁶ : CommSemiring R\nS : Type u_2\ninst✝⁵ : CommSemiring S\ninst✝⁴ : Algebra R S\nT : Type u_3\ninst✝³ : CommSemiring T\ninst✝² : Algebra R T\nM N : Submonoid R\nh : LE.le M N\ninst✝¹ : IsLocalization M S\ninst✝ : IsLocalization N T\n⊢ IsScalarTower R S T","decl":"/-- If `M ≤ N` are submonoids of `R`, then the natural map `M⁻¹S →+* N⁻¹S` commutes with the\nlocalization maps -/\ntheorem localization_isScalarTower_of_submonoid_le (M N : Submonoid R) (h : M ≤ N)\n    [IsLocalization M S] [IsLocalization N T] :\n    @IsScalarTower R S T _ (localizationAlgebraOfSubmonoidLe S T M N h).toSMul _ :=\n  letI := localizationAlgebraOfSubmonoidLe S T M N h\n  IsScalarTower.of_algebraMap_eq' (IsLocalization.lift_comp _).symm\n\n"}
{"name":"IsLocalization.instIsScalarTowerAtPrimeFractionRing","module":"Mathlib.RingTheory.Localization.LocalizationLocalization","initialProofState":"R : Type u_4\ninst✝² : CommRing R\ninst✝¹ : IsDomain R\np : Ideal R\ninst✝ : p.IsPrime\n⊢ IsScalarTower R (Localization.AtPrime p) (FractionRing R)","decl":"instance {R : Type*} [CommRing R] [IsDomain R] (p : Ideal R) [p.IsPrime] :\n    IsScalarTower R (Localization.AtPrime p) (FractionRing R) :=\n  localization_isScalarTower_of_submonoid_le (Localization.AtPrime p) (FractionRing R)\n    p.primeCompl (nonZeroDivisors R) p.primeCompl_le_nonZeroDivisors\n\n"}
{"name":"IsLocalization.isLocalization_of_submonoid_le","module":"Mathlib.RingTheory.Localization.LocalizationLocalization","initialProofState":"R : Type u_1\ninst✝⁸ : CommSemiring R\nS : Type u_2\ninst✝⁷ : CommSemiring S\ninst✝⁶ : Algebra R S\nT : Type u_3\ninst✝⁵ : CommSemiring T\ninst✝⁴ : Algebra R T\nM N : Submonoid R\nh : LE.le M N\ninst✝³ : IsLocalization M S\ninst✝² : IsLocalization N T\ninst✝¹ : Algebra S T\ninst✝ : IsScalarTower R S T\n⊢ IsLocalization (Submonoid.map (algebraMap R S) N) T","decl":"/-- If `M ≤ N` are submonoids of `R`, then `N⁻¹S` is also the localization of `M⁻¹S` at `N`. -/\ntheorem isLocalization_of_submonoid_le (M N : Submonoid R) (h : M ≤ N) [IsLocalization M S]\n    [IsLocalization N T] [Algebra S T] [IsScalarTower R S T] :\n    IsLocalization (N.map (algebraMap R S)) T :=\n  { map_units' := by\n      rintro ⟨_, ⟨y, hy, rfl⟩⟩\n      convert IsLocalization.map_units T ⟨y, hy⟩\n      exact (IsScalarTower.algebraMap_apply _ _ _ _).symm\n    surj' := fun y => by\n      obtain ⟨⟨x, s⟩, e⟩ := IsLocalization.surj N y\n      refine ⟨⟨algebraMap R S x, _, _, s.prop, rfl⟩, ?_⟩\n      simpa [← IsScalarTower.algebraMap_apply] using e\n    exists_of_eq := fun {x₁ x₂} => by\n      obtain ⟨⟨y₁, s₁⟩, e₁⟩ := IsLocalization.surj M x₁\n      obtain ⟨⟨y₂, s₂⟩, e₂⟩ := IsLocalization.surj M x₂\n      refine (Set.exists_image_iff (algebraMap R S) N fun c => c * x₁ = c * x₂).mpr.comp ?_\n      dsimp only at e₁ e₂ ⊢\n      suffices algebraMap R T (y₁ * s₂) = algebraMap R T (y₂ * s₁) →\n          ∃ a : N, algebraMap R S (a * (y₁ * s₂)) = algebraMap R S (a * (y₂ * s₁)) by\n        have h₁ := @IsUnit.mul_left_inj T _ _ (algebraMap S T x₁) (algebraMap S T x₂)\n          (IsLocalization.map_units T ⟨(s₁ : R), h s₁.prop⟩)\n        have h₂ := @IsUnit.mul_left_inj T _ _ ((algebraMap S T x₁) * (algebraMap R T s₁))\n          ((algebraMap S T x₂) * (algebraMap R T s₁))\n          (IsLocalization.map_units T ⟨(s₂ : R), h s₂.prop⟩)\n        simp only [IsScalarTower.algebraMap_apply R S T, Subtype.coe_mk] at h₁ h₂\n        simp only [IsScalarTower.algebraMap_apply R S T, map_mul, ← e₁, ← e₂, ← mul_assoc,\n          mul_right_comm _ (algebraMap R S s₂),\n          mul_right_comm _ (algebraMap S T (algebraMap R S s₂)),\n          (IsLocalization.map_units S s₁).mul_left_inj,\n          (IsLocalization.map_units S s₂).mul_left_inj] at this\n        rw [h₂, h₁] at this\n        simpa only [mul_comm] using this\n      simp_rw [IsLocalization.eq_iff_exists N T, IsLocalization.eq_iff_exists M S]\n      intro ⟨a, e⟩\n      exact ⟨a, 1, by convert e using 1 <;> simp⟩ }\n\n"}
{"name":"IsLocalization.isLocalization_of_is_exists_mul_mem","module":"Mathlib.RingTheory.Localization.LocalizationLocalization","initialProofState":"R : Type u_1\ninst✝³ : CommSemiring R\nS : Type u_2\ninst✝² : CommSemiring S\ninst✝¹ : Algebra R S\nM N : Submonoid R\ninst✝ : IsLocalization M S\nh : LE.le M N\nh' : ∀ (x : Subtype fun x => Membership.mem N x), Exists fun m => Membership.mem M (HMul.hMul m ↑x)\n⊢ IsLocalization N S","decl":"/-- If `M ≤ N` are submonoids of `R` such that `∀ x : N, ∃ m : R, m * x ∈ M`, then the\nlocalization at `N` is equal to the localizaton of `M`. -/\ntheorem isLocalization_of_is_exists_mul_mem (M N : Submonoid R) [IsLocalization M S] (h : M ≤ N)\n    (h' : ∀ x : N, ∃ m : R, m * x ∈ M) : IsLocalization N S :=\n  { map_units' := fun y => by\n      obtain ⟨m, hm⟩ := h' y\n      have := IsLocalization.map_units S ⟨_, hm⟩\n      rw [map_mul] at this\n      exact (IsUnit.mul_iff.mp this).2\n    surj' := fun z => by\n      obtain ⟨⟨y, s⟩, e⟩ := IsLocalization.surj M z\n      exact ⟨⟨y, _, h s.prop⟩, e⟩\n    exists_of_eq := fun {_ _} => by\n      rw [IsLocalization.eq_iff_exists M]\n      exact fun ⟨x, hx⟩ => ⟨⟨_, h x.prop⟩, hx⟩ }\n\n"}
{"name":"IsLocalization.mk'_eq_algebraMap_mk'_of_submonoid_le","module":"Mathlib.RingTheory.Localization.LocalizationLocalization","initialProofState":"R : Type u_1\ninst✝⁸ : CommSemiring R\nS : Type u_2\ninst✝⁷ : CommSemiring S\ninst✝⁶ : Algebra R S\nT : Type u_3\ninst✝⁵ : CommSemiring T\ninst✝⁴ : Algebra R T\nM N : Submonoid R\nh : LE.le M N\ninst✝³ : IsLocalization M S\ninst✝² : IsLocalization N T\ninst✝¹ : Algebra S T\ninst✝ : IsScalarTower R S T\nx : R\ny : Subtype fun a => Membership.mem M a\n⊢ Eq (IsLocalization.mk' T x ⟨↑y, ⋯⟩) ((algebraMap S T) (IsLocalization.mk' S x y))","decl":"theorem mk'_eq_algebraMap_mk'_of_submonoid_le {M N : Submonoid R} (h : M ≤ N) [IsLocalization M S]\n    [IsLocalization N T] [Algebra S T] [IsScalarTower R S T] (x : R) (y : {a : R // a ∈ M}) :\n    mk' T x ⟨y.1, h y.2⟩ = algebraMap S T (mk' S x y) :=\n  mk'_eq_iff_eq_mul.mpr (by simp only [IsScalarTower.algebraMap_apply R S T, ← map_mul, mk'_spec])\n\n"}
{"name":"IsFractionRing.isFractionRing_of_isLocalization","module":"Mathlib.RingTheory.Localization.LocalizationLocalization","initialProofState":"R : Type u_1\ninst✝⁸ : CommRing R\nM : Submonoid R\nS : Type u_2\nT : Type u_3\ninst✝⁷ : CommRing S\ninst✝⁶ : CommRing T\ninst✝⁵ : Algebra R S\ninst✝⁴ : Algebra R T\ninst✝³ : Algebra S T\ninst✝² : IsScalarTower R S T\ninst✝¹ : IsLocalization M S\ninst✝ : IsFractionRing R T\nhM : LE.le M (nonZeroDivisors R)\n⊢ IsFractionRing S T","decl":"theorem isFractionRing_of_isLocalization (S T : Type*) [CommRing S] [CommRing T] [Algebra R S]\n    [Algebra R T] [Algebra S T] [IsScalarTower R S T] [IsLocalization M S] [IsFractionRing R T]\n    (hM : M ≤ nonZeroDivisors R) : IsFractionRing S T := by\n  have := isLocalization_of_submonoid_le S T M (nonZeroDivisors R) hM\n  refine @isLocalization_of_is_exists_mul_mem _ _ _ _ _ _ _ this ?_ ?_\n  · exact map_nonZeroDivisors_le M S\n  · rintro ⟨x, hx⟩\n    obtain ⟨⟨y, s⟩, e⟩ := IsLocalization.surj M x\n    use algebraMap R S s\n    rw [mul_comm, Subtype.coe_mk, e]\n    refine Set.mem_image_of_mem (algebraMap R S) ?_\n    intro z hz\n    apply IsLocalization.injective S hM\n    rw [map_zero]\n    apply hx\n    rw [← (map_units S s).mul_left_inj, mul_assoc, e, ← map_mul, hz, map_zero,\n      zero_mul]\n\n"}
{"name":"IsFractionRing.isFractionRing_of_isDomain_of_isLocalization","module":"Mathlib.RingTheory.Localization.LocalizationLocalization","initialProofState":"R : Type u_1\ninst✝⁹ : CommRing R\nM : Submonoid R\ninst✝⁸ : IsDomain R\nS : Type u_2\nT : Type u_3\ninst✝⁷ : CommRing S\ninst✝⁶ : CommRing T\ninst✝⁵ : Algebra R S\ninst✝⁴ : Algebra R T\ninst✝³ : Algebra S T\ninst✝² : IsScalarTower R S T\ninst✝¹ : IsLocalization M S\ninst✝ : IsFractionRing R T\n⊢ IsFractionRing S T","decl":"theorem isFractionRing_of_isDomain_of_isLocalization [IsDomain R] (S T : Type*) [CommRing S]\n    [CommRing T] [Algebra R S] [Algebra R T] [Algebra S T] [IsScalarTower R S T]\n    [IsLocalization M S] [IsFractionRing R T] : IsFractionRing S T := by\n  haveI := IsFractionRing.nontrivial R T\n  haveI := (algebraMap S T).domain_nontrivial\n  apply isFractionRing_of_isLocalization M S T\n  intro x hx\n  rw [mem_nonZeroDivisors_iff_ne_zero]\n  intro hx'\n  apply @zero_ne_one S\n  rw [← (algebraMap R S).map_one, ← @mk'_one R _ M, @comm _ Eq, mk'_eq_zero_iff]\n  exact ⟨⟨x, hx⟩, by simp [hx']⟩\n\n"}
{"name":"IsFractionRing.instAtPrimeFractionRing","module":"Mathlib.RingTheory.Localization.LocalizationLocalization","initialProofState":"R : Type u_2\ninst✝² : CommRing R\ninst✝¹ : IsDomain R\np : Ideal R\ninst✝ : p.IsPrime\n⊢ IsFractionRing (Localization.AtPrime p) (FractionRing R)","decl":"instance {R : Type*} [CommRing R] [IsDomain R] (p : Ideal R) [p.IsPrime] :\n    IsFractionRing (Localization.AtPrime p) (FractionRing R) :=\n  IsFractionRing.isFractionRing_of_isDomain_of_isLocalization p.primeCompl\n    (Localization.AtPrime p) (FractionRing R)\n\n"}
