{"name":"Finset.product_eq_sprod","module":"Mathlib.Data.Finset.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Finset α\nt : Finset β\n⊢ Eq (s.product t) (SProd.sprod s t)","decl":"@[simp]\ntheorem product_eq_sprod : Finset.product s t = s ×ˢ t :=\n  rfl\n\n"}
{"name":"Finset.product_val","module":"Mathlib.Data.Finset.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Finset α\nt : Finset β\n⊢ Eq (SProd.sprod s t).val (SProd.sprod s.val t.val)","decl":"@[simp]\ntheorem product_val : (s ×ˢ t).1 = s.1 ×ˢ t.1 :=\n  rfl\n\n"}
{"name":"Finset.mem_product","module":"Mathlib.Data.Finset.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Finset α\nt : Finset β\np : Prod α β\n⊢ Iff (Membership.mem (SProd.sprod s t) p) (And (Membership.mem s p.1) (Membership.mem t p.2))","decl":"@[simp]\ntheorem mem_product {p : α × β} : p ∈ s ×ˢ t ↔ p.1 ∈ s ∧ p.2 ∈ t :=\n  Multiset.mem_product\n\n"}
{"name":"Finset.mk_mem_product","module":"Mathlib.Data.Finset.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Finset α\nt : Finset β\na : α\nb : β\nha : Membership.mem s a\nhb : Membership.mem t b\n⊢ Membership.mem (SProd.sprod s t) { fst := a, snd := b }","decl":"theorem mk_mem_product (ha : a ∈ s) (hb : b ∈ t) : (a, b) ∈ s ×ˢ t :=\n  mem_product.2 ⟨ha, hb⟩\n\n"}
{"name":"Finset.coe_product","module":"Mathlib.Data.Finset.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Finset α\nt : Finset β\n⊢ Eq (↑(SProd.sprod s t)) (SProd.sprod ↑s ↑t)","decl":"@[simp, norm_cast]\ntheorem coe_product (s : Finset α) (t : Finset β) :\n    (↑(s ×ˢ t) : Set (α × β)) = (s : Set α) ×ˢ t :=\n  Set.ext fun _ => Finset.mem_product\n\n"}
{"name":"Finset.subset_product_image_fst","module":"Mathlib.Data.Finset.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Finset α\nt : Finset β\ninst✝ : DecidableEq α\n⊢ HasSubset.Subset (Finset.image Prod.fst (SProd.sprod s t)) s","decl":"theorem subset_product_image_fst [DecidableEq α] : (s ×ˢ t).image Prod.fst ⊆ s := fun i => by\n  simp +contextual [mem_image]\n\n"}
{"name":"Finset.subset_product_image_snd","module":"Mathlib.Data.Finset.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Finset α\nt : Finset β\ninst✝ : DecidableEq β\n⊢ HasSubset.Subset (Finset.image Prod.snd (SProd.sprod s t)) t","decl":"theorem subset_product_image_snd [DecidableEq β] : (s ×ˢ t).image Prod.snd ⊆ t := fun i => by\n  simp +contextual [mem_image]\n\n"}
{"name":"Finset.product_image_fst","module":"Mathlib.Data.Finset.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Finset α\nt : Finset β\ninst✝ : DecidableEq α\nht : t.Nonempty\n⊢ Eq (Finset.image Prod.fst (SProd.sprod s t)) s","decl":"theorem product_image_fst [DecidableEq α] (ht : t.Nonempty) : (s ×ˢ t).image Prod.fst = s := by\n  ext i\n  simp [mem_image, ht.exists_mem]\n\n"}
{"name":"Finset.product_image_snd","module":"Mathlib.Data.Finset.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Finset α\nt : Finset β\ninst✝ : DecidableEq β\nht : s.Nonempty\n⊢ Eq (Finset.image Prod.snd (SProd.sprod s t)) t","decl":"theorem product_image_snd [DecidableEq β] (ht : s.Nonempty) : (s ×ˢ t).image Prod.snd = t := by\n  ext i\n  simp [mem_image, ht.exists_mem]\n\n"}
{"name":"Finset.subset_product","module":"Mathlib.Data.Finset.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : DecidableEq β\ns : Finset (Prod α β)\n⊢ HasSubset.Subset s (SProd.sprod (Finset.image Prod.fst s) (Finset.image Prod.snd s))","decl":"theorem subset_product [DecidableEq α] [DecidableEq β] {s : Finset (α × β)} :\n    s ⊆ s.image Prod.fst ×ˢ s.image Prod.snd := fun _ hp =>\n  mem_product.2 ⟨mem_image_of_mem _ hp, mem_image_of_mem _ hp⟩\n\n"}
{"name":"Finset.product_subset_product","module":"Mathlib.Data.Finset.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ns s' : Finset α\nt t' : Finset β\nhs : HasSubset.Subset s s'\nht : HasSubset.Subset t t'\n⊢ HasSubset.Subset (SProd.sprod s t) (SProd.sprod s' t')","decl":"@[gcongr]\ntheorem product_subset_product (hs : s ⊆ s') (ht : t ⊆ t') : s ×ˢ t ⊆ s' ×ˢ t' := fun ⟨_, _⟩ h =>\n  mem_product.2 ⟨hs (mem_product.1 h).1, ht (mem_product.1 h).2⟩\n\n"}
{"name":"Finset.product_subset_product_left","module":"Mathlib.Data.Finset.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ns s' : Finset α\nt : Finset β\nhs : HasSubset.Subset s s'\n⊢ HasSubset.Subset (SProd.sprod s t) (SProd.sprod s' t)","decl":"@[gcongr]\ntheorem product_subset_product_left (hs : s ⊆ s') : s ×ˢ t ⊆ s' ×ˢ t :=\n  product_subset_product hs (Subset.refl _)\n\n"}
{"name":"Finset.product_subset_product_right","module":"Mathlib.Data.Finset.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Finset α\nt t' : Finset β\nht : HasSubset.Subset t t'\n⊢ HasSubset.Subset (SProd.sprod s t) (SProd.sprod s t')","decl":"@[gcongr]\ntheorem product_subset_product_right (ht : t ⊆ t') : s ×ˢ t ⊆ s ×ˢ t' :=\n  product_subset_product (Subset.refl _) ht\n\n"}
{"name":"Finset.map_swap_product","module":"Mathlib.Data.Finset.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Finset α\nt : Finset β\n⊢ Eq (Finset.map { toFun := Prod.swap, inj' := ⋯ } (SProd.sprod t s)) (SProd.sprod s t)","decl":"theorem map_swap_product (s : Finset α) (t : Finset β) :\n    (t ×ˢ s).map ⟨Prod.swap, Prod.swap_injective⟩ = s ×ˢ t :=\n  coe_injective <| by\n    push_cast\n    exact Set.image_swap_prod _ _\n\n"}
{"name":"Finset.image_swap_product","module":"Mathlib.Data.Finset.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : DecidableEq (Prod α β)\ns : Finset α\nt : Finset β\n⊢ Eq (Finset.image Prod.swap (SProd.sprod t s)) (SProd.sprod s t)","decl":"@[simp]\ntheorem image_swap_product [DecidableEq (α × β)] (s : Finset α) (t : Finset β) :\n    (t ×ˢ s).image Prod.swap = s ×ˢ t :=\n  coe_injective <| by\n    push_cast\n    exact Set.image_swap_prod _ _\n\n"}
{"name":"Finset.product_eq_biUnion","module":"Mathlib.Data.Finset.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : DecidableEq (Prod α β)\ns : Finset α\nt : Finset β\n⊢ Eq (SProd.sprod s t) (s.biUnion fun a => Finset.image (fun b => { fst := a, snd := b }) t)","decl":"theorem product_eq_biUnion [DecidableEq (α × β)] (s : Finset α) (t : Finset β) :\n    s ×ˢ t = s.biUnion fun a => t.image fun b => (a, b) :=\n  ext fun ⟨x, y⟩ => by\n    simp only [mem_product, mem_biUnion, mem_image, exists_prop, Prod.mk.inj_iff, and_left_comm,\n      exists_and_left, exists_eq_right, exists_eq_left]\n\n"}
{"name":"Finset.product_eq_biUnion_right","module":"Mathlib.Data.Finset.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : DecidableEq (Prod α β)\ns : Finset α\nt : Finset β\n⊢ Eq (SProd.sprod s t) (t.biUnion fun b => Finset.image (fun a => { fst := a, snd := b }) s)","decl":"theorem product_eq_biUnion_right [DecidableEq (α × β)] (s : Finset α) (t : Finset β) :\n    s ×ˢ t = t.biUnion fun b => s.image fun a => (a, b) :=\n  ext fun ⟨x, y⟩ => by\n    simp only [mem_product, mem_biUnion, mem_image, exists_prop, Prod.mk.inj_iff, and_left_comm,\n      exists_and_left, exists_eq_right, exists_eq_left]\n\n"}
{"name":"Finset.product_biUnion","module":"Mathlib.Data.Finset.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝ : DecidableEq γ\ns : Finset α\nt : Finset β\nf : Prod α β → Finset γ\n⊢ Eq ((SProd.sprod s t).biUnion f) (s.biUnion fun a => t.biUnion fun b => f { fst := a, snd := b })","decl":"/-- See also `Finset.sup_product_left`. -/\n@[simp]\ntheorem product_biUnion [DecidableEq γ] (s : Finset α) (t : Finset β) (f : α × β → Finset γ) :\n    (s ×ˢ t).biUnion f = s.biUnion fun a => t.biUnion fun b => f (a, b) := by\n  classical simp_rw [product_eq_biUnion, biUnion_biUnion, image_biUnion]\n\n"}
{"name":"Finset.card_product","module":"Mathlib.Data.Finset.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Finset α\nt : Finset β\n⊢ Eq (SProd.sprod s t).card (HMul.hMul s.card t.card)","decl":"@[simp]\ntheorem card_product (s : Finset α) (t : Finset β) : card (s ×ˢ t) = card s * card t :=\n  Multiset.card_product _ _\n\n"}
{"name":"Finset.nontrivial_prod_iff","module":"Mathlib.Data.Finset.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Finset α\nt : Finset β\n⊢ Iff (SProd.sprod s t).Nontrivial (And s.Nonempty (And t.Nonempty (Or s.Nontrivial t.Nontrivial)))","decl":"/-- The product of two Finsets is nontrivial iff both are nonempty\n  at least one of them is nontrivial. -/\nlemma nontrivial_prod_iff : (s ×ˢ t).Nontrivial ↔\n    s.Nonempty ∧ t.Nonempty ∧ (s.Nontrivial ∨ t.Nontrivial) := by\n  simp_rw [← card_pos, ← one_lt_card_iff_nontrivial, card_product]; apply Nat.one_lt_mul_iff\n\n"}
{"name":"Finset.filter_product","module":"Mathlib.Data.Finset.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Finset α\nt : Finset β\np : α → Prop\nq : β → Prop\ninst✝¹ : DecidablePred p\ninst✝ : DecidablePred q\n⊢ Eq (Finset.filter (fun x => And (p x.1) (q x.2)) (SProd.sprod s t)) (SProd.sprod (Finset.filter p s) (Finset.filter q t))","decl":"theorem filter_product (p : α → Prop) (q : β → Prop) [DecidablePred p] [DecidablePred q] :\n    ((s ×ˢ t).filter fun x : α × β => p x.1 ∧ q x.2) = s.filter p ×ˢ t.filter q := by\n  ext ⟨a, b⟩\n  simp [mem_filter, mem_product, decide_eq_true_eq, and_comm, and_left_comm, and_assoc]\n\n"}
{"name":"Finset.filter_product_left","module":"Mathlib.Data.Finset.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Finset α\nt : Finset β\np : α → Prop\ninst✝ : DecidablePred p\n⊢ Eq (Finset.filter (fun x => p x.1) (SProd.sprod s t)) (SProd.sprod (Finset.filter p s) t)","decl":"theorem filter_product_left (p : α → Prop) [DecidablePred p] :\n    ((s ×ˢ t).filter fun x : α × β => p x.1) = s.filter p ×ˢ t := by\n  simpa using filter_product p fun _ => true\n\n"}
{"name":"Finset.filter_product_right","module":"Mathlib.Data.Finset.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Finset α\nt : Finset β\nq : β → Prop\ninst✝ : DecidablePred q\n⊢ Eq (Finset.filter (fun x => q x.2) (SProd.sprod s t)) (SProd.sprod s (Finset.filter q t))","decl":"theorem filter_product_right (q : β → Prop) [DecidablePred q] :\n    ((s ×ˢ t).filter fun x : α × β => q x.2) = s ×ˢ t.filter q := by\n  simpa using filter_product (fun _ : α => true) q\n\n"}
{"name":"Finset.filter_product_card","module":"Mathlib.Data.Finset.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Finset α\nt : Finset β\np : α → Prop\nq : β → Prop\ninst✝¹ : DecidablePred p\ninst✝ : DecidablePred q\n⊢ Eq (Finset.filter (fun x => Eq (p x.1) (q x.2)) (SProd.sprod s t)).card (HAdd.hAdd (HMul.hMul (Finset.filter p s).card (Finset.filter q t).card) (HMul.hMul (Finset.filter (fun x => Not (p x)) s).card (Finset.filter (fun x => Not (q x)) t).card))","decl":"theorem filter_product_card (s : Finset α) (t : Finset β) (p : α → Prop) (q : β → Prop)\n    [DecidablePred p] [DecidablePred q] :\n    ((s ×ˢ t).filter fun x : α × β => (p x.1) = (q x.2)).card =\n      (s.filter p).card * (t.filter q).card +\n        (s.filter (¬ p ·)).card * (t.filter (¬ q ·)).card := by\n  classical\n  rw [← card_product, ← card_product, ← filter_product, ← filter_product, ← card_union_of_disjoint]\n  · apply congr_arg\n    ext ⟨a, b⟩\n    simp only [filter_union_right, mem_filter, mem_product]\n    constructor <;> intro h <;> use h.1\n    · simp only [h.2, Function.comp_apply, Decidable.em, and_self]\n    · revert h\n      simp only [Function.comp_apply, and_imp]\n      rintro _ _ (_|_) <;> simp [*]\n  · apply Finset.disjoint_filter_filter'\n    exact (disjoint_compl_right.inf_left _).inf_right _\n\n"}
{"name":"Finset.empty_product","module":"Mathlib.Data.Finset.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\nt : Finset β\n⊢ Eq (SProd.sprod EmptyCollection.emptyCollection t) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem empty_product (t : Finset β) : (∅ : Finset α) ×ˢ t = ∅ :=\n  rfl\n\n"}
{"name":"Finset.product_empty","module":"Mathlib.Data.Finset.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Finset α\n⊢ Eq (SProd.sprod s EmptyCollection.emptyCollection) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem product_empty (s : Finset α) : s ×ˢ (∅ : Finset β) = ∅ :=\n  eq_empty_of_forall_not_mem fun _ h => not_mem_empty _ (Finset.mem_product.1 h).2\n\n"}
{"name":"Finset.Nonempty.product","module":"Mathlib.Data.Finset.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Finset α\nt : Finset β\nhs : s.Nonempty\nht : t.Nonempty\n⊢ (SProd.sprod s t).Nonempty","decl":"@[aesop safe apply (rule_sets := [finsetNonempty])]\ntheorem Nonempty.product (hs : s.Nonempty) (ht : t.Nonempty) : (s ×ˢ t).Nonempty :=\n  let ⟨x, hx⟩ := hs\n  let ⟨y, hy⟩ := ht\n  ⟨(x, y), mem_product.2 ⟨hx, hy⟩⟩\n\n"}
{"name":"Finset.Nonempty.fst","module":"Mathlib.Data.Finset.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Finset α\nt : Finset β\nh : (SProd.sprod s t).Nonempty\n⊢ s.Nonempty","decl":"theorem Nonempty.fst (h : (s ×ˢ t).Nonempty) : s.Nonempty :=\n  let ⟨xy, hxy⟩ := h\n  ⟨xy.1, (mem_product.1 hxy).1⟩\n\n"}
{"name":"Finset.Nonempty.snd","module":"Mathlib.Data.Finset.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Finset α\nt : Finset β\nh : (SProd.sprod s t).Nonempty\n⊢ t.Nonempty","decl":"theorem Nonempty.snd (h : (s ×ˢ t).Nonempty) : t.Nonempty :=\n  let ⟨xy, hxy⟩ := h\n  ⟨xy.2, (mem_product.1 hxy).2⟩\n\n"}
{"name":"Finset.nonempty_product","module":"Mathlib.Data.Finset.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Finset α\nt : Finset β\n⊢ Iff (SProd.sprod s t).Nonempty (And s.Nonempty t.Nonempty)","decl":"@[simp]\ntheorem nonempty_product : (s ×ˢ t).Nonempty ↔ s.Nonempty ∧ t.Nonempty :=\n  ⟨fun h => ⟨h.fst, h.snd⟩, fun h => h.1.product h.2⟩\n\n"}
{"name":"Finset.product_eq_empty","module":"Mathlib.Data.Finset.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Finset α\nt : Finset β\n⊢ Iff (Eq (SProd.sprod s t) EmptyCollection.emptyCollection) (Or (Eq s EmptyCollection.emptyCollection) (Eq t EmptyCollection.emptyCollection))","decl":"@[simp]\ntheorem product_eq_empty {s : Finset α} {t : Finset β} : s ×ˢ t = ∅ ↔ s = ∅ ∨ t = ∅ := by\n  rw [← not_nonempty_iff_eq_empty, nonempty_product, not_and_or, not_nonempty_iff_eq_empty,\n    not_nonempty_iff_eq_empty]\n\n"}
{"name":"Finset.singleton_product","module":"Mathlib.Data.Finset.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\nt : Finset β\na : α\n⊢ Eq (SProd.sprod (Singleton.singleton a) t) (Finset.map { toFun := Prod.mk a, inj' := ⋯ } t)","decl":"@[simp]\ntheorem singleton_product {a : α} :\n    ({a} : Finset α) ×ˢ t = t.map ⟨Prod.mk a, Prod.mk.inj_left _⟩ := by\n  ext ⟨x, y⟩\n  simp [and_left_comm, eq_comm]\n\n"}
{"name":"Finset.product_singleton","module":"Mathlib.Data.Finset.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Finset α\nb : β\n⊢ Eq (SProd.sprod s (Singleton.singleton b)) (Finset.map { toFun := fun i => { fst := i, snd := b }, inj' := ⋯ } s)","decl":"@[simp]\ntheorem product_singleton {b : β} : s ×ˢ {b} = s.map ⟨fun i => (i, b), Prod.mk.inj_right _⟩ := by\n  ext ⟨x, y⟩\n  simp [and_left_comm, eq_comm]\n\n"}
{"name":"Finset.singleton_product_singleton","module":"Mathlib.Data.Finset.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\na : α\nb : β\n⊢ Eq (SProd.sprod (Singleton.singleton a) (Singleton.singleton b)) (Singleton.singleton { fst := a, snd := b })","decl":"theorem singleton_product_singleton {a : α} {b : β} :\n    ({a} ×ˢ {b} : Finset _) = {(a, b)} := by\n  simp only [product_singleton, Function.Embedding.coeFn_mk, map_singleton]\n\n"}
{"name":"Finset.union_product","module":"Mathlib.Data.Finset.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ns s' : Finset α\nt : Finset β\ninst✝¹ : DecidableEq α\ninst✝ : DecidableEq β\n⊢ Eq (SProd.sprod (Union.union s s') t) (Union.union (SProd.sprod s t) (SProd.sprod s' t))","decl":"@[simp]\ntheorem union_product [DecidableEq α] [DecidableEq β] : (s ∪ s') ×ˢ t = s ×ˢ t ∪ s' ×ˢ t := by\n  ext ⟨x, y⟩\n  simp only [or_and_right, mem_union, mem_product]\n\n"}
{"name":"Finset.product_union","module":"Mathlib.Data.Finset.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Finset α\nt t' : Finset β\ninst✝¹ : DecidableEq α\ninst✝ : DecidableEq β\n⊢ Eq (SProd.sprod s (Union.union t t')) (Union.union (SProd.sprod s t) (SProd.sprod s t'))","decl":"@[simp]\ntheorem product_union [DecidableEq α] [DecidableEq β] : s ×ˢ (t ∪ t') = s ×ˢ t ∪ s ×ˢ t' := by\n  ext ⟨x, y⟩\n  simp only [and_or_left, mem_union, mem_product]\n\n"}
{"name":"Finset.inter_product","module":"Mathlib.Data.Finset.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ns s' : Finset α\nt : Finset β\ninst✝¹ : DecidableEq α\ninst✝ : DecidableEq β\n⊢ Eq (SProd.sprod (Inter.inter s s') t) (Inter.inter (SProd.sprod s t) (SProd.sprod s' t))","decl":"theorem inter_product [DecidableEq α] [DecidableEq β] : (s ∩ s') ×ˢ t = s ×ˢ t ∩ s' ×ˢ t := by\n  ext ⟨x, y⟩\n  simp only [← and_and_right, mem_inter, mem_product]\n\n"}
{"name":"Finset.product_inter","module":"Mathlib.Data.Finset.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Finset α\nt t' : Finset β\ninst✝¹ : DecidableEq α\ninst✝ : DecidableEq β\n⊢ Eq (SProd.sprod s (Inter.inter t t')) (Inter.inter (SProd.sprod s t) (SProd.sprod s t'))","decl":"theorem product_inter [DecidableEq α] [DecidableEq β] : s ×ˢ (t ∩ t') = s ×ˢ t ∩ s ×ˢ t' := by\n  ext ⟨x, y⟩\n  simp only [← and_and_left, mem_inter, mem_product]\n\n"}
{"name":"Finset.product_inter_product","module":"Mathlib.Data.Finset.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ns s' : Finset α\nt t' : Finset β\ninst✝¹ : DecidableEq α\ninst✝ : DecidableEq β\n⊢ Eq (Inter.inter (SProd.sprod s t) (SProd.sprod s' t')) (SProd.sprod (Inter.inter s s') (Inter.inter t t'))","decl":"theorem product_inter_product [DecidableEq α] [DecidableEq β] :\n    s ×ˢ t ∩ s' ×ˢ t' = (s ∩ s') ×ˢ (t ∩ t') := by\n  ext ⟨x, y⟩\n  simp only [and_assoc, and_left_comm, mem_inter, mem_product]\n\n"}
{"name":"Finset.disjoint_product","module":"Mathlib.Data.Finset.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ns s' : Finset α\nt t' : Finset β\n⊢ Iff (Disjoint (SProd.sprod s t) (SProd.sprod s' t')) (Or (Disjoint s s') (Disjoint t t'))","decl":"theorem disjoint_product : Disjoint (s ×ˢ t) (s' ×ˢ t') ↔ Disjoint s s' ∨ Disjoint t t' := by\n  simp_rw [← disjoint_coe, coe_product, Set.disjoint_prod]\n\n"}
{"name":"Finset.disjUnion_product","module":"Mathlib.Data.Finset.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ns s' : Finset α\nt : Finset β\nhs : Disjoint s s'\n⊢ Eq (SProd.sprod (s.disjUnion s' hs) t) ((SProd.sprod s t).disjUnion (SProd.sprod s' t) ⋯)","decl":"@[simp]\ntheorem disjUnion_product (hs : Disjoint s s') :\n    s.disjUnion s' hs ×ˢ t = (s ×ˢ t).disjUnion (s' ×ˢ t) (disjoint_product.mpr <| Or.inl hs) :=\n  eq_of_veq <| Multiset.add_product _ _ _\n\n"}
{"name":"Finset.product_disjUnion","module":"Mathlib.Data.Finset.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Finset α\nt t' : Finset β\nht : Disjoint t t'\n⊢ Eq (SProd.sprod s (t.disjUnion t' ht)) ((SProd.sprod s t).disjUnion (SProd.sprod s t') ⋯)","decl":"@[simp]\ntheorem product_disjUnion (ht : Disjoint t t') :\n    s ×ˢ t.disjUnion t' ht = (s ×ˢ t).disjUnion (s ×ˢ t') (disjoint_product.mpr <| Or.inr ht) :=\n  eq_of_veq <| Multiset.product_add _ _ _\n\n"}
{"name":"Finset.mem_diag","module":"Mathlib.Data.Finset.Prod","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : Finset α\nx : Prod α α\n⊢ Iff (Membership.mem s.diag x) (And (Membership.mem s x.1) (Eq x.1 x.2))","decl":"@[simp]\ntheorem mem_diag : x ∈ s.diag ↔ x.1 ∈ s ∧ x.1 = x.2 := by\n  simp +contextual [diag]\n\n"}
{"name":"Finset.mem_offDiag","module":"Mathlib.Data.Finset.Prod","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : Finset α\nx : Prod α α\n⊢ Iff (Membership.mem s.offDiag x) (And (Membership.mem s x.1) (And (Membership.mem s x.2) (Ne x.1 x.2)))","decl":"@[simp]\ntheorem mem_offDiag : x ∈ s.offDiag ↔ x.1 ∈ s ∧ x.2 ∈ s ∧ x.1 ≠ x.2 := by\n  simp [offDiag, and_assoc]\n\n"}
{"name":"Finset.coe_offDiag","module":"Mathlib.Data.Finset.Prod","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : Finset α\n⊢ Eq (↑s.offDiag) (↑s).offDiag","decl":"@[simp, norm_cast]\ntheorem coe_offDiag : (s.offDiag : Set (α × α)) = (s : Set α).offDiag :=\n  Set.ext fun _ => mem_offDiag\n\n"}
{"name":"Finset.diag_card","module":"Mathlib.Data.Finset.Prod","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : Finset α\n⊢ Eq s.diag.card s.card","decl":"@[simp]\ntheorem diag_card : (diag s).card = s.card := by\n  suffices diag s = s.image fun a => (a, a) by\n    rw [this]\n    apply card_image_of_injOn\n    exact fun x1 _ x2 _ h3 => (Prod.mk.inj h3).1\n  ext ⟨a₁, a₂⟩\n  rw [mem_diag]\n  constructor <;> intro h <;> rw [Finset.mem_image] at *\n  · use a₁\n    simpa using h\n  · rcases h with ⟨a, h1, h2⟩\n    have h := Prod.mk.inj h2\n    rw [← h.1, ← h.2]\n    use h1\n\n"}
{"name":"Finset.offDiag_card","module":"Mathlib.Data.Finset.Prod","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : Finset α\n⊢ Eq s.offDiag.card (HSub.hSub (HMul.hMul s.card s.card) s.card)","decl":"@[simp]\ntheorem offDiag_card : (offDiag s).card = s.card * s.card - s.card :=\n  suffices (diag s).card + (offDiag s).card = s.card * s.card by rw [s.diag_card] at this; omega\n  by rw [← card_product, diag, offDiag]\n     conv_rhs => rw [← filter_card_add_filter_neg_card_eq_card (fun a => a.1 = a.2)]\n\n"}
{"name":"Finset.diag_mono","module":"Mathlib.Data.Finset.Prod","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\n⊢ Monotone Finset.diag","decl":"@[mono]\ntheorem diag_mono : Monotone (diag : Finset α → Finset (α × α)) := fun _ _ h _ hx =>\n  mem_diag.2 <| And.imp_left (@h _) <| mem_diag.1 hx\n\n"}
{"name":"Finset.offDiag_mono","module":"Mathlib.Data.Finset.Prod","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\n⊢ Monotone Finset.offDiag","decl":"@[mono]\ntheorem offDiag_mono : Monotone (offDiag : Finset α → Finset (α × α)) := fun _ _ h _ hx =>\n  mem_offDiag.2 <| And.imp (@h _) (And.imp_left <| @h _) <| mem_offDiag.1 hx\n\n"}
{"name":"Finset.diag_empty","module":"Mathlib.Data.Finset.Prod","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\n⊢ Eq EmptyCollection.emptyCollection.diag EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem diag_empty : (∅ : Finset α).diag = ∅ :=\n  rfl\n\n"}
{"name":"Finset.offDiag_empty","module":"Mathlib.Data.Finset.Prod","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\n⊢ Eq EmptyCollection.emptyCollection.offDiag EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem offDiag_empty : (∅ : Finset α).offDiag = ∅ :=\n  rfl\n\n"}
{"name":"Finset.diag_union_offDiag","module":"Mathlib.Data.Finset.Prod","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : Finset α\n⊢ Eq (Union.union s.diag s.offDiag) (SProd.sprod s s)","decl":"@[simp]\ntheorem diag_union_offDiag : s.diag ∪ s.offDiag = s ×ˢ s := by\n  conv_rhs => rw [← filter_union_filter_neg_eq (fun a => a.1 = a.2) (s ×ˢ s)]\n  rfl\n\n"}
{"name":"Finset.disjoint_diag_offDiag","module":"Mathlib.Data.Finset.Prod","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : Finset α\n⊢ Disjoint s.diag s.offDiag","decl":"@[simp]\ntheorem disjoint_diag_offDiag : Disjoint s.diag s.offDiag :=\n  disjoint_filter_filter_neg (s ×ˢ s) (s ×ˢ s) (fun a => a.1 = a.2)\n\n"}
{"name":"Finset.product_sdiff_diag","module":"Mathlib.Data.Finset.Prod","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : Finset α\n⊢ Eq (SDiff.sdiff (SProd.sprod s s) s.diag) s.offDiag","decl":"theorem product_sdiff_diag : s ×ˢ s \\ s.diag = s.offDiag := by\n  rw [← diag_union_offDiag, union_comm, union_sdiff_self,\n    sdiff_eq_self_of_disjoint (disjoint_diag_offDiag _).symm]\n\n"}
{"name":"Finset.product_sdiff_offDiag","module":"Mathlib.Data.Finset.Prod","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : Finset α\n⊢ Eq (SDiff.sdiff (SProd.sprod s s) s.offDiag) s.diag","decl":"theorem product_sdiff_offDiag : s ×ˢ s \\ s.offDiag = s.diag := by\n  rw [← diag_union_offDiag, union_sdiff_self, sdiff_eq_self_of_disjoint (disjoint_diag_offDiag _)]\n\n"}
{"name":"Finset.diag_inter","module":"Mathlib.Data.Finset.Prod","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\n⊢ Eq (Inter.inter s t).diag (Inter.inter s.diag t.diag)","decl":"theorem diag_inter : (s ∩ t).diag = s.diag ∩ t.diag :=\n  ext fun x => by simpa only [mem_diag, mem_inter] using and_and_right\n\n"}
{"name":"Finset.offDiag_inter","module":"Mathlib.Data.Finset.Prod","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\n⊢ Eq (Inter.inter s t).offDiag (Inter.inter s.offDiag t.offDiag)","decl":"theorem offDiag_inter : (s ∩ t).offDiag = s.offDiag ∩ t.offDiag :=\n  coe_injective <| by\n    push_cast\n    exact Set.offDiag_inter _ _\n\n"}
{"name":"Finset.diag_union","module":"Mathlib.Data.Finset.Prod","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\n⊢ Eq (Union.union s t).diag (Union.union s.diag t.diag)","decl":"theorem diag_union : (s ∪ t).diag = s.diag ∪ t.diag := by\n  ext ⟨i, j⟩\n  simp only [mem_diag, mem_union, or_and_right]\n\n"}
{"name":"Finset.offDiag_union","module":"Mathlib.Data.Finset.Prod","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nh : Disjoint s t\n⊢ Eq (Union.union s t).offDiag (Union.union (Union.union (Union.union s.offDiag t.offDiag) (SProd.sprod s t)) (SProd.sprod t s))","decl":"theorem offDiag_union (h : Disjoint s t) :\n    (s ∪ t).offDiag = s.offDiag ∪ t.offDiag ∪ s ×ˢ t ∪ t ×ˢ s :=\n  coe_injective <| by\n    push_cast\n    exact Set.offDiag_union (disjoint_coe.2 h)\n\n"}
{"name":"Finset.offDiag_singleton","module":"Mathlib.Data.Finset.Prod","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na : α\n⊢ Eq (Singleton.singleton a).offDiag EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem offDiag_singleton : ({a} : Finset α).offDiag = ∅ := by simp [← Finset.card_eq_zero]\n\n"}
{"name":"Finset.diag_singleton","module":"Mathlib.Data.Finset.Prod","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na : α\n⊢ Eq (Singleton.singleton a).diag (Singleton.singleton { fst := a, snd := a })","decl":"theorem diag_singleton : ({a} : Finset α).diag = {(a, a)} := by\n  rw [← product_sdiff_offDiag, offDiag_singleton, sdiff_empty, singleton_product_singleton]\n\n"}
{"name":"Finset.diag_insert","module":"Mathlib.Data.Finset.Prod","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : Finset α\na : α\n⊢ Eq (Insert.insert a s).diag (Insert.insert { fst := a, snd := a } s.diag)","decl":"theorem diag_insert : (insert a s).diag = insert (a, a) s.diag := by\n  rw [insert_eq, insert_eq, diag_union, diag_singleton]\n\n"}
{"name":"Finset.offDiag_insert","module":"Mathlib.Data.Finset.Prod","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : Finset α\na : α\nhas : Not (Membership.mem s a)\n⊢ Eq (Insert.insert a s).offDiag (Union.union (Union.union s.offDiag (SProd.sprod (Singleton.singleton a) s)) (SProd.sprod s (Singleton.singleton a)))","decl":"theorem offDiag_insert (has : a ∉ s) : (insert a s).offDiag = s.offDiag ∪ {a} ×ˢ s ∪ s ×ˢ {a} := by\n  rw [insert_eq, union_comm, offDiag_union (disjoint_singleton_right.2 has), offDiag_singleton,\n    union_empty, union_right_comm]\n\n"}
{"name":"Finset.offDiag_filter_lt_eq_filter_le","module":"Mathlib.Data.Finset.Prod","initialProofState":"ι : Type u_4\ninst✝³ : PartialOrder ι\ninst✝² : DecidableEq ι\ninst✝¹ : DecidableRel LE.le\ninst✝ : DecidableRel LT.lt\ns : Finset ι\n⊢ Eq (Finset.filter (fun i => LT.lt i.1 i.2) s.offDiag) (Finset.filter (fun i => LE.le i.1 i.2) s.offDiag)","decl":"theorem offDiag_filter_lt_eq_filter_le {ι}\n    [PartialOrder ι] [DecidableEq ι]\n    [DecidableRel (LE.le (α := ι))] [DecidableRel (LT.lt (α := ι))]\n    (s : Finset ι) :\n    s.offDiag.filter (fun i => i.1 < i.2) = s.offDiag.filter (fun i => i.1 ≤ i.2) := by\n  rw [Finset.filter_inj']\n  rintro ⟨i, j⟩\n  simp_rw [mem_offDiag, and_imp]\n  rintro _ _ h\n  rw [Ne.le_iff_lt h]\n\n"}
