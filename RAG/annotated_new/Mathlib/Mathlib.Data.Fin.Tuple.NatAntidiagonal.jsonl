{"name":"List.Nat.antidiagonalTuple_zero_zero","module":"Mathlib.Data.Fin.Tuple.NatAntidiagonal","initialProofState":"⊢ Eq (List.Nat.antidiagonalTuple 0 0) (List.cons Matrix.vecEmpty List.nil)","decl":"@[simp]\ntheorem antidiagonalTuple_zero_zero : antidiagonalTuple 0 0 = [![]] :=\n  rfl\n\n"}
{"name":"List.Nat.antidiagonalTuple_zero_succ","module":"Mathlib.Data.Fin.Tuple.NatAntidiagonal","initialProofState":"n : Nat\n⊢ Eq (List.Nat.antidiagonalTuple 0 (HAdd.hAdd n 1)) List.nil","decl":"@[simp]\ntheorem antidiagonalTuple_zero_succ (n : ℕ) : antidiagonalTuple 0 (n + 1) = [] :=\n  rfl\n\n"}
{"name":"List.Nat.mem_antidiagonalTuple","module":"Mathlib.Data.Fin.Tuple.NatAntidiagonal","initialProofState":"n k : Nat\nx : Fin k → Nat\n⊢ Iff (Membership.mem (List.Nat.antidiagonalTuple k n) x) (Eq (Finset.univ.sum fun i => x i) n)","decl":"theorem mem_antidiagonalTuple {n : ℕ} {k : ℕ} {x : Fin k → ℕ} :\n    x ∈ antidiagonalTuple k n ↔ ∑ i, x i = n := by\n  induction x using Fin.consInduction generalizing n with\n  | h0 =>\n    cases n\n    · decide\n    · simp [eq_comm]\n  | h x₀ x ih =>\n    simp_rw [Fin.sum_cons, antidiagonalTuple, List.mem_flatMap, List.mem_map,\n      List.Nat.mem_antidiagonal, Fin.cons_inj, exists_eq_right_right, ih,\n      @eq_comm _ _ (Prod.snd _), and_comm (a := Prod.snd _ = _),\n      ← Prod.mk.inj_iff (a₁ := Prod.fst _), exists_eq_right]\n\n"}
{"name":"List.Nat.nodup_antidiagonalTuple","module":"Mathlib.Data.Fin.Tuple.NatAntidiagonal","initialProofState":"k n : Nat\n⊢ (List.Nat.antidiagonalTuple k n).Nodup","decl":"/-- The antidiagonal of `n` does not contain duplicate entries. -/\ntheorem nodup_antidiagonalTuple (k n : ℕ) : List.Nodup (antidiagonalTuple k n) := by\n  induction' k with k ih generalizing n\n  · cases n\n    · simp\n    · simp [eq_comm]\n  simp_rw [antidiagonalTuple, List.nodup_flatMap]\n  constructor\n  · intro i _\n    exact (ih i.snd).map (Fin.cons_right_injective (α := fun _ => ℕ) i.fst)\n  induction' n with n n_ih\n  · exact List.pairwise_singleton _ _\n  · rw [List.Nat.antidiagonal_succ]\n    refine List.Pairwise.cons (fun a ha x hx₁ hx₂ => ?_) (n_ih.map _ fun a b h x hx₁ hx₂ => ?_)\n    · rw [List.mem_map] at hx₁ hx₂ ha\n      obtain ⟨⟨a, -, rfl⟩, ⟨x₁, -, rfl⟩, ⟨x₂, -, h⟩⟩ := ha, hx₁, hx₂\n      rw [Fin.cons_inj] at h\n      injection h.1\n    · rw [List.mem_map] at hx₁ hx₂\n      obtain ⟨⟨x₁, hx₁, rfl⟩, ⟨x₂, hx₂, h₁₂⟩⟩ := hx₁, hx₂\n      dsimp at h₁₂\n      rw [Fin.cons_inj, Nat.succ_inj'] at h₁₂\n      obtain ⟨h₁₂, rfl⟩ := h₁₂\n      rw [Function.onFun, h₁₂] at h\n      exact h (List.mem_map_of_mem _ hx₁) (List.mem_map_of_mem _ hx₂)\n\n"}
{"name":"List.Nat.antidiagonalTuple_zero_right","module":"Mathlib.Data.Fin.Tuple.NatAntidiagonal","initialProofState":"k : Nat\n⊢ Eq (List.Nat.antidiagonalTuple k 0) (List.cons 0 List.nil)","decl":"theorem antidiagonalTuple_zero_right : ∀ k, antidiagonalTuple k 0 = [0]\n  | 0 => (congr_arg fun x => [x]) <| Subsingleton.elim _ _\n  | k + 1 => by\n    rw [antidiagonalTuple, antidiagonal_zero, List.flatMap_singleton,\n      antidiagonalTuple_zero_right k, List.map_singleton]\n    exact congr_arg (fun x => [x]) Matrix.cons_zero_zero\n\n"}
{"name":"List.Nat.antidiagonalTuple_one","module":"Mathlib.Data.Fin.Tuple.NatAntidiagonal","initialProofState":"n : Nat\n⊢ Eq (List.Nat.antidiagonalTuple 1 n) (List.cons (Matrix.vecCons n Matrix.vecEmpty) List.nil)","decl":"@[simp]\ntheorem antidiagonalTuple_one (n : ℕ) : antidiagonalTuple 1 n = [![n]] := by\n  simp_rw [antidiagonalTuple, antidiagonal, List.range_succ, List.map_append, List.map_singleton,\n    Nat.sub_self, List.flatMap_append, List.flatMap_singleton, List.flatMap_map]\n  conv_rhs => rw [← List.nil_append [![n]]]\n  congr 1\n  simp_rw [List.flatMap_eq_nil_iff, List.mem_range, List.map_eq_nil_iff]\n  intro x hx\n  obtain ⟨m, rfl⟩ := Nat.exists_eq_add_of_lt hx\n  rw [add_assoc, add_tsub_cancel_left, antidiagonalTuple_zero_succ]\n\n"}
{"name":"List.Nat.antidiagonalTuple_two","module":"Mathlib.Data.Fin.Tuple.NatAntidiagonal","initialProofState":"n : Nat\n⊢ Eq (List.Nat.antidiagonalTuple 2 n) (List.map (fun i => Matrix.vecCons i.1 (Matrix.vecCons i.2 Matrix.vecEmpty)) (List.Nat.antidiagonal n))","decl":"theorem antidiagonalTuple_two (n : ℕ) :\n    antidiagonalTuple 2 n = (antidiagonal n).map fun i => ![i.1, i.2] := by\n  rw [antidiagonalTuple]\n  simp_rw [antidiagonalTuple_one, List.map_singleton]\n  rw [List.map_eq_flatMap]\n  rfl\n\n"}
{"name":"List.Nat.antidiagonalTuple_pairwise_pi_lex","module":"Mathlib.Data.Fin.Tuple.NatAntidiagonal","initialProofState":"k n : Nat\n⊢ List.Pairwise (Pi.Lex (fun x1 x2 => LT.lt x1 x2) fun x x1 x2 => LT.lt x1 x2) (List.Nat.antidiagonalTuple k n)","decl":"theorem antidiagonalTuple_pairwise_pi_lex :\n    ∀ k n, (antidiagonalTuple k n).Pairwise (Pi.Lex (· < ·) @fun _ => (· < ·))\n  | 0, 0 => List.pairwise_singleton _ _\n  | 0, _ + 1 => List.Pairwise.nil\n  | k + 1, n => by\n    simp_rw [antidiagonalTuple, List.pairwise_flatMap, List.pairwise_map, List.mem_map,\n      forall_exists_index, and_imp, forall_apply_eq_imp_iff₂]\n    simp only [mem_antidiagonal, Prod.forall, and_imp, forall_apply_eq_imp_iff₂]\n    simp only [Fin.pi_lex_lt_cons_cons, eq_self_iff_true, true_and, lt_self_iff_false,\n      false_or]\n    refine ⟨fun _ _ _ => antidiagonalTuple_pairwise_pi_lex k _, ?_⟩\n    induction' n with n n_ih\n    · rw [antidiagonal_zero]\n      exact List.pairwise_singleton _ _\n    · rw [antidiagonal_succ, List.pairwise_cons, List.pairwise_map]\n      refine ⟨fun p hp x hx y hy => ?_, ?_⟩\n      · rw [List.mem_map, Prod.exists] at hp\n        obtain ⟨a, b, _, rfl : (Nat.succ a, b) = p⟩ := hp\n        exact Or.inl (Nat.zero_lt_succ _)\n      dsimp\n      simp_rw [Nat.succ_inj', Nat.succ_lt_succ_iff]\n      exact n_ih\n\n"}
{"name":"Multiset.Nat.antidiagonalTuple_zero_zero","module":"Mathlib.Data.Fin.Tuple.NatAntidiagonal","initialProofState":"⊢ Eq (Multiset.Nat.antidiagonalTuple 0 0) (Singleton.singleton Matrix.vecEmpty)","decl":"@[simp]\ntheorem antidiagonalTuple_zero_zero : antidiagonalTuple 0 0 = {![]} :=\n  rfl\n\n"}
{"name":"Multiset.Nat.antidiagonalTuple_zero_succ","module":"Mathlib.Data.Fin.Tuple.NatAntidiagonal","initialProofState":"n : Nat\n⊢ Eq (Multiset.Nat.antidiagonalTuple 0 n.succ) 0","decl":"@[simp]\ntheorem antidiagonalTuple_zero_succ (n : ℕ) : antidiagonalTuple 0 n.succ = 0 :=\n  rfl\n\n"}
{"name":"Multiset.Nat.mem_antidiagonalTuple","module":"Mathlib.Data.Fin.Tuple.NatAntidiagonal","initialProofState":"n k : Nat\nx : Fin k → Nat\n⊢ Iff (Membership.mem (Multiset.Nat.antidiagonalTuple k n) x) (Eq (Finset.univ.sum fun i => x i) n)","decl":"theorem mem_antidiagonalTuple {n : ℕ} {k : ℕ} {x : Fin k → ℕ} :\n    x ∈ antidiagonalTuple k n ↔ ∑ i, x i = n :=\n  List.Nat.mem_antidiagonalTuple\n\n"}
{"name":"Multiset.Nat.nodup_antidiagonalTuple","module":"Mathlib.Data.Fin.Tuple.NatAntidiagonal","initialProofState":"k n : Nat\n⊢ (Multiset.Nat.antidiagonalTuple k n).Nodup","decl":"theorem nodup_antidiagonalTuple (k n : ℕ) : (antidiagonalTuple k n).Nodup :=\n  List.Nat.nodup_antidiagonalTuple _ _\n\n"}
{"name":"Multiset.Nat.antidiagonalTuple_zero_right","module":"Mathlib.Data.Fin.Tuple.NatAntidiagonal","initialProofState":"k : Nat\n⊢ Eq (Multiset.Nat.antidiagonalTuple k 0) (Singleton.singleton 0)","decl":"theorem antidiagonalTuple_zero_right (k : ℕ) : antidiagonalTuple k 0 = {0} :=\n  congr_arg _ (List.Nat.antidiagonalTuple_zero_right k)\n\n"}
{"name":"Multiset.Nat.antidiagonalTuple_one","module":"Mathlib.Data.Fin.Tuple.NatAntidiagonal","initialProofState":"n : Nat\n⊢ Eq (Multiset.Nat.antidiagonalTuple 1 n) (Singleton.singleton (Matrix.vecCons n Matrix.vecEmpty))","decl":"@[simp]\ntheorem antidiagonalTuple_one (n : ℕ) : antidiagonalTuple 1 n = {![n]} :=\n  congr_arg _ (List.Nat.antidiagonalTuple_one n)\n\n"}
{"name":"Multiset.Nat.antidiagonalTuple_two","module":"Mathlib.Data.Fin.Tuple.NatAntidiagonal","initialProofState":"n : Nat\n⊢ Eq (Multiset.Nat.antidiagonalTuple 2 n) (Multiset.map (fun i => Matrix.vecCons i.1 (Matrix.vecCons i.2 Matrix.vecEmpty)) (Multiset.Nat.antidiagonal n))","decl":"theorem antidiagonalTuple_two (n : ℕ) :\n    antidiagonalTuple 2 n = (antidiagonal n).map fun i => ![i.1, i.2] :=\n  congr_arg _ (List.Nat.antidiagonalTuple_two n)\n\n"}
{"name":"Finset.Nat.antidiagonalTuple_zero_zero","module":"Mathlib.Data.Fin.Tuple.NatAntidiagonal","initialProofState":"⊢ Eq (Finset.Nat.antidiagonalTuple 0 0) (Singleton.singleton Matrix.vecEmpty)","decl":"@[simp]\ntheorem antidiagonalTuple_zero_zero : antidiagonalTuple 0 0 = {![]} :=\n  rfl\n\n"}
{"name":"Finset.Nat.antidiagonalTuple_zero_succ","module":"Mathlib.Data.Fin.Tuple.NatAntidiagonal","initialProofState":"n : Nat\n⊢ Eq (Finset.Nat.antidiagonalTuple 0 n.succ) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem antidiagonalTuple_zero_succ (n : ℕ) : antidiagonalTuple 0 n.succ = ∅ :=\n  rfl\n\n"}
{"name":"Finset.Nat.mem_antidiagonalTuple","module":"Mathlib.Data.Fin.Tuple.NatAntidiagonal","initialProofState":"n k : Nat\nx : Fin k → Nat\n⊢ Iff (Membership.mem (Finset.Nat.antidiagonalTuple k n) x) (Eq (Finset.univ.sum fun i => x i) n)","decl":"theorem mem_antidiagonalTuple {n : ℕ} {k : ℕ} {x : Fin k → ℕ} :\n    x ∈ antidiagonalTuple k n ↔ ∑ i, x i = n :=\n  List.Nat.mem_antidiagonalTuple\n\n"}
{"name":"Finset.Nat.antidiagonalTuple_zero_right","module":"Mathlib.Data.Fin.Tuple.NatAntidiagonal","initialProofState":"k : Nat\n⊢ Eq (Finset.Nat.antidiagonalTuple k 0) (Singleton.singleton 0)","decl":"theorem antidiagonalTuple_zero_right (k : ℕ) : antidiagonalTuple k 0 = {0} :=\n  Finset.eq_of_veq (Multiset.Nat.antidiagonalTuple_zero_right k)\n\n"}
{"name":"Finset.Nat.antidiagonalTuple_one","module":"Mathlib.Data.Fin.Tuple.NatAntidiagonal","initialProofState":"n : Nat\n⊢ Eq (Finset.Nat.antidiagonalTuple 1 n) (Singleton.singleton (Matrix.vecCons n Matrix.vecEmpty))","decl":"@[simp]\ntheorem antidiagonalTuple_one (n : ℕ) : antidiagonalTuple 1 n = {![n]} :=\n  Finset.eq_of_veq (Multiset.Nat.antidiagonalTuple_one n)\n\n"}
{"name":"Finset.Nat.antidiagonalTuple_two","module":"Mathlib.Data.Fin.Tuple.NatAntidiagonal","initialProofState":"n : Nat\n⊢ Eq (Finset.Nat.antidiagonalTuple 2 n) (Finset.map (piFinTwoEquiv fun x => Nat).symm.toEmbedding (Finset.HasAntidiagonal.antidiagonal n))","decl":"theorem antidiagonalTuple_two (n : ℕ) :\n    antidiagonalTuple 2 n = (antidiagonal n).map (piFinTwoEquiv fun _ => ℕ).symm.toEmbedding :=\n  Finset.eq_of_veq (Multiset.Nat.antidiagonalTuple_two n)\n\n"}
{"name":"Finset.Nat.sigmaAntidiagonalTupleEquivTuple_symm_apply_fst","module":"Mathlib.Data.Fin.Tuple.NatAntidiagonal","initialProofState":"k : Nat\nx : Fin k → Nat\n⊢ Eq ((Finset.Nat.sigmaAntidiagonalTupleEquivTuple k).symm x).fst (Finset.univ.sum fun i => x i)","decl":"/-- The disjoint union of antidiagonal tuples `Σ n, antidiagonalTuple k n` is equivalent to the\n`k`-tuple `Fin k → ℕ`. This is such an equivalence, obtained by mapping `(n, x)` to `x`.\n\nThis is the tuple version of `Finset.sigmaAntidiagonalEquivProd`. -/\n@[simps]\ndef sigmaAntidiagonalTupleEquivTuple (k : ℕ) : (Σ n, antidiagonalTuple k n) ≃ (Fin k → ℕ) where\n  toFun x := x.2\n  invFun x := ⟨∑ i, x i, x, mem_antidiagonalTuple.mpr rfl⟩\n  left_inv := fun ⟨_, _, h⟩ => Sigma.subtype_ext (mem_antidiagonalTuple.mp h) rfl\n  right_inv _ := rfl\n\n"}
{"name":"Finset.Nat.sigmaAntidiagonalTupleEquivTuple_symm_apply_snd_coe","module":"Mathlib.Data.Fin.Tuple.NatAntidiagonal","initialProofState":"k : Nat\nx : Fin k → Nat\na✝ : Fin k\n⊢ Eq (↑((Finset.Nat.sigmaAntidiagonalTupleEquivTuple k).symm x).snd a✝) (x a✝)","decl":"/-- The disjoint union of antidiagonal tuples `Σ n, antidiagonalTuple k n` is equivalent to the\n`k`-tuple `Fin k → ℕ`. This is such an equivalence, obtained by mapping `(n, x)` to `x`.\n\nThis is the tuple version of `Finset.sigmaAntidiagonalEquivProd`. -/\n@[simps]\ndef sigmaAntidiagonalTupleEquivTuple (k : ℕ) : (Σ n, antidiagonalTuple k n) ≃ (Fin k → ℕ) where\n  toFun x := x.2\n  invFun x := ⟨∑ i, x i, x, mem_antidiagonalTuple.mpr rfl⟩\n  left_inv := fun ⟨_, _, h⟩ => Sigma.subtype_ext (mem_antidiagonalTuple.mp h) rfl\n  right_inv _ := rfl\n\n"}
{"name":"Finset.Nat.sigmaAntidiagonalTupleEquivTuple_apply","module":"Mathlib.Data.Fin.Tuple.NatAntidiagonal","initialProofState":"k : Nat\nx : Sigma fun n => Subtype fun x => Membership.mem (Finset.Nat.antidiagonalTuple k n) x\na✝ : Fin k\n⊢ Eq ((Finset.Nat.sigmaAntidiagonalTupleEquivTuple k) x a✝) (↑x.snd a✝)","decl":"/-- The disjoint union of antidiagonal tuples `Σ n, antidiagonalTuple k n` is equivalent to the\n`k`-tuple `Fin k → ℕ`. This is such an equivalence, obtained by mapping `(n, x)` to `x`.\n\nThis is the tuple version of `Finset.sigmaAntidiagonalEquivProd`. -/\n@[simps]\ndef sigmaAntidiagonalTupleEquivTuple (k : ℕ) : (Σ n, antidiagonalTuple k n) ≃ (Fin k → ℕ) where\n  toFun x := x.2\n  invFun x := ⟨∑ i, x i, x, mem_antidiagonalTuple.mpr rfl⟩\n  left_inv := fun ⟨_, _, h⟩ => Sigma.subtype_ext (mem_antidiagonalTuple.mp h) rfl\n  right_inv _ := rfl\n\n"}
