{"name":"hom_coe_pow","module":"Mathlib.Algebra.GroupPower.IterateHom","initialProofState":"M : Type u_1\nF : Type u_4\ninst✝ : Monoid F\nc : F → M → M\nh1 : Eq (c 1) id\nhmul : ∀ (f g : F), Eq (c (HMul.hMul f g)) (Function.comp (c f) (c g))\nf : F\nn : Nat\n⊢ Eq (c (HPow.hPow f n)) (Nat.iterate (c f) n)","decl":"/-- An auxiliary lemma that can be used to prove `⇑(f ^ n) = ⇑f^[n]`. -/\ntheorem hom_coe_pow {F : Type*} [Monoid F] (c : F → M → M) (h1 : c 1 = id)\n    (hmul : ∀ f g, c (f * g) = c f ∘ c g) (f : F) : ∀ n, c (f ^ n) = (c f)^[n]\n  | 0 => by\n    rw [pow_zero, h1]\n    rfl\n  | n + 1 => by rw [pow_succ, iterate_succ, hmul, hom_coe_pow c h1 hmul f n]\n\n"}
{"name":"iterate_map_add","module":"Mathlib.Algebra.GroupPower.IterateHom","initialProofState":"M : Type u_4\nF : Type u_5\ninst✝² : Add M\ninst✝¹ : FunLike F M M\ninst✝ : AddHomClass F M M\nf : F\nn : Nat\nx y : M\n⊢ Eq (Nat.iterate (⇑f) n (HAdd.hAdd x y)) (HAdd.hAdd (Nat.iterate (⇑f) n x) (Nat.iterate (⇑f) n y))","decl":"@[to_additive (attr := simp)]\ntheorem iterate_map_mul {M F : Type*} [Mul M] [FunLike F M M] [MulHomClass F M M]\n    (f : F) (n : ℕ) (x y : M) :\n    f^[n] (x * y) = f^[n] x * f^[n] y :=\n  Function.Semiconj₂.iterate (map_mul f) n x y\n\n"}
{"name":"iterate_map_mul","module":"Mathlib.Algebra.GroupPower.IterateHom","initialProofState":"M : Type u_4\nF : Type u_5\ninst✝² : Mul M\ninst✝¹ : FunLike F M M\ninst✝ : MulHomClass F M M\nf : F\nn : Nat\nx y : M\n⊢ Eq (Nat.iterate (⇑f) n (HMul.hMul x y)) (HMul.hMul (Nat.iterate (⇑f) n x) (Nat.iterate (⇑f) n y))","decl":"@[to_additive (attr := simp)]\ntheorem iterate_map_mul {M F : Type*} [Mul M] [FunLike F M M] [MulHomClass F M M]\n    (f : F) (n : ℕ) (x y : M) :\n    f^[n] (x * y) = f^[n] x * f^[n] y :=\n  Function.Semiconj₂.iterate (map_mul f) n x y\n\n"}
{"name":"iterate_map_zero","module":"Mathlib.Algebra.GroupPower.IterateHom","initialProofState":"M : Type u_4\nF : Type u_5\ninst✝² : Zero M\ninst✝¹ : FunLike F M M\ninst✝ : ZeroHomClass F M M\nf : F\nn : Nat\n⊢ Eq (Nat.iterate (⇑f) n 0) 0","decl":"@[to_additive (attr := simp)]\ntheorem iterate_map_one {M F : Type*} [One M] [FunLike F M M] [OneHomClass F M M]\n    (f : F) (n : ℕ) :\n    f^[n] 1 = 1 :=\n  iterate_fixed (map_one f) n\n\n"}
{"name":"iterate_map_one","module":"Mathlib.Algebra.GroupPower.IterateHom","initialProofState":"M : Type u_4\nF : Type u_5\ninst✝² : One M\ninst✝¹ : FunLike F M M\ninst✝ : OneHomClass F M M\nf : F\nn : Nat\n⊢ Eq (Nat.iterate (⇑f) n 1) 1","decl":"@[to_additive (attr := simp)]\ntheorem iterate_map_one {M F : Type*} [One M] [FunLike F M M] [OneHomClass F M M]\n    (f : F) (n : ℕ) :\n    f^[n] 1 = 1 :=\n  iterate_fixed (map_one f) n\n\n"}
{"name":"iterate_map_neg","module":"Mathlib.Algebra.GroupPower.IterateHom","initialProofState":"M : Type u_4\nF : Type u_5\ninst✝² : AddGroup M\ninst✝¹ : FunLike F M M\ninst✝ : AddMonoidHomClass F M M\nf : F\nn : Nat\nx : M\n⊢ Eq (Nat.iterate (⇑f) n (Neg.neg x)) (Neg.neg (Nat.iterate (⇑f) n x))","decl":"@[to_additive (attr := simp)]\ntheorem iterate_map_inv {M F : Type*} [Group M] [FunLike F M M] [MonoidHomClass F M M]\n    (f : F) (n : ℕ) (x : M) :\n    f^[n] x⁻¹ = (f^[n] x)⁻¹ :=\n  Commute.iterate_left (map_inv f) n x\n\n"}
{"name":"iterate_map_inv","module":"Mathlib.Algebra.GroupPower.IterateHom","initialProofState":"M : Type u_4\nF : Type u_5\ninst✝² : Group M\ninst✝¹ : FunLike F M M\ninst✝ : MonoidHomClass F M M\nf : F\nn : Nat\nx : M\n⊢ Eq (Nat.iterate (⇑f) n (Inv.inv x)) (Inv.inv (Nat.iterate (⇑f) n x))","decl":"@[to_additive (attr := simp)]\ntheorem iterate_map_inv {M F : Type*} [Group M] [FunLike F M M] [MonoidHomClass F M M]\n    (f : F) (n : ℕ) (x : M) :\n    f^[n] x⁻¹ = (f^[n] x)⁻¹ :=\n  Commute.iterate_left (map_inv f) n x\n\n"}
{"name":"iterate_map_sub","module":"Mathlib.Algebra.GroupPower.IterateHom","initialProofState":"M : Type u_4\nF : Type u_5\ninst✝² : AddGroup M\ninst✝¹ : FunLike F M M\ninst✝ : AddMonoidHomClass F M M\nf : F\nn : Nat\nx y : M\n⊢ Eq (Nat.iterate (⇑f) n (HSub.hSub x y)) (HSub.hSub (Nat.iterate (⇑f) n x) (Nat.iterate (⇑f) n y))","decl":"@[to_additive (attr := simp)]\ntheorem iterate_map_div {M F : Type*} [Group M] [FunLike F M M] [MonoidHomClass F M M]\n    (f : F) (n : ℕ) (x y : M) :\n    f^[n] (x / y) = f^[n] x / f^[n] y :=\n  Semiconj₂.iterate (map_div f) n x y\n\n"}
{"name":"iterate_map_div","module":"Mathlib.Algebra.GroupPower.IterateHom","initialProofState":"M : Type u_4\nF : Type u_5\ninst✝² : Group M\ninst✝¹ : FunLike F M M\ninst✝ : MonoidHomClass F M M\nf : F\nn : Nat\nx y : M\n⊢ Eq (Nat.iterate (⇑f) n (HDiv.hDiv x y)) (HDiv.hDiv (Nat.iterate (⇑f) n x) (Nat.iterate (⇑f) n y))","decl":"@[to_additive (attr := simp)]\ntheorem iterate_map_div {M F : Type*} [Group M] [FunLike F M M] [MonoidHomClass F M M]\n    (f : F) (n : ℕ) (x y : M) :\n    f^[n] (x / y) = f^[n] x / f^[n] y :=\n  Semiconj₂.iterate (map_div f) n x y\n\n"}
{"name":"iterate_map_nsmul","module":"Mathlib.Algebra.GroupPower.IterateHom","initialProofState":"M : Type u_4\nF : Type u_5\ninst✝² : AddMonoid M\ninst✝¹ : FunLike F M M\ninst✝ : AddMonoidHomClass F M M\nf : F\nn : Nat\nx : M\nk : Nat\n⊢ Eq (Nat.iterate (⇑f) n (HSMul.hSMul k x)) (HSMul.hSMul k (Nat.iterate (⇑f) n x))","decl":"@[to_additive (attr := simp)]\ntheorem iterate_map_pow {M F : Type*} [Monoid M] [FunLike F M M] [MonoidHomClass F M M]\n    (f : F) (n : ℕ) (x : M) (k : ℕ) :\n    f^[n] (x ^ k) = f^[n] x ^ k :=\n  Commute.iterate_left (map_pow f · k) n x\n\n"}
{"name":"iterate_map_pow","module":"Mathlib.Algebra.GroupPower.IterateHom","initialProofState":"M : Type u_4\nF : Type u_5\ninst✝² : Monoid M\ninst✝¹ : FunLike F M M\ninst✝ : MonoidHomClass F M M\nf : F\nn : Nat\nx : M\nk : Nat\n⊢ Eq (Nat.iterate (⇑f) n (HPow.hPow x k)) (HPow.hPow (Nat.iterate (⇑f) n x) k)","decl":"@[to_additive (attr := simp)]\ntheorem iterate_map_pow {M F : Type*} [Monoid M] [FunLike F M M] [MonoidHomClass F M M]\n    (f : F) (n : ℕ) (x : M) (k : ℕ) :\n    f^[n] (x ^ k) = f^[n] x ^ k :=\n  Commute.iterate_left (map_pow f · k) n x\n\n"}
{"name":"iterate_map_zsmul","module":"Mathlib.Algebra.GroupPower.IterateHom","initialProofState":"M : Type u_4\nF : Type u_5\ninst✝² : AddGroup M\ninst✝¹ : FunLike F M M\ninst✝ : AddMonoidHomClass F M M\nf : F\nn : Nat\nx : M\nk : Int\n⊢ Eq (Nat.iterate (⇑f) n (HSMul.hSMul k x)) (HSMul.hSMul k (Nat.iterate (⇑f) n x))","decl":"@[to_additive (attr := simp)]\ntheorem iterate_map_zpow {M F : Type*} [Group M] [FunLike F M M] [MonoidHomClass F M M]\n    (f : F) (n : ℕ) (x : M) (k : ℤ) :\n    f^[n] (x ^ k) = f^[n] x ^ k :=\n  Commute.iterate_left (map_zpow f · k) n x\n\n--what should be the namespace for this section?\n"}
{"name":"iterate_map_zpow","module":"Mathlib.Algebra.GroupPower.IterateHom","initialProofState":"M : Type u_4\nF : Type u_5\ninst✝² : Group M\ninst✝¹ : FunLike F M M\ninst✝ : MonoidHomClass F M M\nf : F\nn : Nat\nx : M\nk : Int\n⊢ Eq (Nat.iterate (⇑f) n (HPow.hPow x k)) (HPow.hPow (Nat.iterate (⇑f) n x) k)","decl":"@[to_additive (attr := simp)]\ntheorem iterate_map_zpow {M F : Type*} [Group M] [FunLike F M M] [MonoidHomClass F M M]\n    (f : F) (n : ℕ) (x : M) (k : ℤ) :\n    f^[n] (x ^ k) = f^[n] x ^ k :=\n  Commute.iterate_left (map_zpow f · k) n x\n\n--what should be the namespace for this section?\n"}
{"name":"smul_iterate","module":"Mathlib.Algebra.GroupPower.IterateHom","initialProofState":"G : Type u_2\nH : Type u_3\ninst✝¹ : Monoid G\na : G\nn : Nat\ninst✝ : MulAction G H\n⊢ Eq (Nat.iterate (fun x => HSMul.hSMul a x) n) fun x => HSMul.hSMul (HPow.hPow a n) x","decl":"@[to_additive (attr := simp)]\ntheorem smul_iterate [MulAction G H] : (a • · : H → H)^[n] = (a ^ n • ·) :=\n  funext fun b =>\n    Nat.recOn n (by rw [iterate_zero, id, pow_zero, one_smul])\n    fun n ih => by rw [iterate_succ', comp_apply, ih, pow_succ', mul_smul]\n\n"}
{"name":"vadd_iterate","module":"Mathlib.Algebra.GroupPower.IterateHom","initialProofState":"G : Type u_2\nH : Type u_3\ninst✝¹ : AddMonoid G\na : G\nn : Nat\ninst✝ : AddAction G H\n⊢ Eq (Nat.iterate (fun x => HVAdd.hVAdd a x) n) fun x => HVAdd.hVAdd (HSMul.hSMul n a) x","decl":"@[to_additive (attr := simp)]\ntheorem smul_iterate [MulAction G H] : (a • · : H → H)^[n] = (a ^ n • ·) :=\n  funext fun b =>\n    Nat.recOn n (by rw [iterate_zero, id, pow_zero, one_smul])\n    fun n ih => by rw [iterate_succ', comp_apply, ih, pow_succ', mul_smul]\n\n"}
{"name":"smul_iterate_apply","module":"Mathlib.Algebra.GroupPower.IterateHom","initialProofState":"G : Type u_2\nH : Type u_3\ninst✝¹ : Monoid G\na : G\nn : Nat\ninst✝ : MulAction G H\nb : H\n⊢ Eq (Nat.iterate (fun x => HSMul.hSMul a x) n b) (HSMul.hSMul (HPow.hPow a n) b)","decl":"@[to_additive]\nlemma smul_iterate_apply [MulAction G H] {b : H} : (a • ·)^[n] b = a ^ n • b := by\n  rw [smul_iterate]\n\n"}
{"name":"vadd_iterate_apply","module":"Mathlib.Algebra.GroupPower.IterateHom","initialProofState":"G : Type u_2\nH : Type u_3\ninst✝¹ : AddMonoid G\na : G\nn : Nat\ninst✝ : AddAction G H\nb : H\n⊢ Eq (Nat.iterate (fun x => HVAdd.hVAdd a x) n b) (HVAdd.hVAdd (HSMul.hSMul n a) b)","decl":"@[to_additive]\nlemma smul_iterate_apply [MulAction G H] {b : H} : (a • ·)^[n] b = a ^ n • b := by\n  rw [smul_iterate]\n\n"}
{"name":"mul_left_iterate","module":"Mathlib.Algebra.GroupPower.IterateHom","initialProofState":"G : Type u_2\ninst✝ : Monoid G\na : G\nn : Nat\n⊢ Eq (Nat.iterate (fun x => HMul.hMul a x) n) fun x => HMul.hMul (HPow.hPow a n) x","decl":"@[to_additive (attr := simp)]\ntheorem mul_left_iterate : (a * ·)^[n] = (a ^ n * ·) :=\n  smul_iterate a n\n\n"}
{"name":"add_left_iterate","module":"Mathlib.Algebra.GroupPower.IterateHom","initialProofState":"G : Type u_2\ninst✝ : AddMonoid G\na : G\nn : Nat\n⊢ Eq (Nat.iterate (fun x => HAdd.hAdd a x) n) fun x => HAdd.hAdd (HSMul.hSMul n a) x","decl":"@[to_additive (attr := simp)]\ntheorem mul_left_iterate : (a * ·)^[n] = (a ^ n * ·) :=\n  smul_iterate a n\n\n"}
{"name":"add_right_iterate","module":"Mathlib.Algebra.GroupPower.IterateHom","initialProofState":"G : Type u_2\ninst✝ : AddMonoid G\na : G\nn : Nat\n⊢ Eq (Nat.iterate (fun x => HAdd.hAdd x a) n) fun x => HAdd.hAdd x (HSMul.hSMul n a)","decl":"@[to_additive (attr := simp)]\ntheorem mul_right_iterate : (· * a)^[n] = (· * a ^ n) :=\n  smul_iterate (MulOpposite.op a) n\n\n"}
{"name":"mul_right_iterate","module":"Mathlib.Algebra.GroupPower.IterateHom","initialProofState":"G : Type u_2\ninst✝ : Monoid G\na : G\nn : Nat\n⊢ Eq (Nat.iterate (fun x => HMul.hMul x a) n) fun x => HMul.hMul x (HPow.hPow a n)","decl":"@[to_additive (attr := simp)]\ntheorem mul_right_iterate : (· * a)^[n] = (· * a ^ n) :=\n  smul_iterate (MulOpposite.op a) n\n\n"}
{"name":"add_right_iterate_apply_zero","module":"Mathlib.Algebra.GroupPower.IterateHom","initialProofState":"G : Type u_2\ninst✝ : AddMonoid G\na : G\nn : Nat\n⊢ Eq (Nat.iterate (fun x => HAdd.hAdd x a) n 0) (HSMul.hSMul n a)","decl":"@[to_additive]\ntheorem mul_right_iterate_apply_one : (· * a)^[n] 1 = a ^ n := by simp [mul_right_iterate]\n\n"}
{"name":"mul_right_iterate_apply_one","module":"Mathlib.Algebra.GroupPower.IterateHom","initialProofState":"G : Type u_2\ninst✝ : Monoid G\na : G\nn : Nat\n⊢ Eq (Nat.iterate (fun x => HMul.hMul x a) n 1) (HPow.hPow a n)","decl":"@[to_additive]\ntheorem mul_right_iterate_apply_one : (· * a)^[n] 1 = a ^ n := by simp [mul_right_iterate]\n\n"}
{"name":"nsmul_iterate","module":"Mathlib.Algebra.GroupPower.IterateHom","initialProofState":"G : Type u_2\ninst✝ : AddMonoid G\nn j : Nat\n⊢ Eq (Nat.iterate (fun x => HSMul.hSMul n x) j) fun x => HSMul.hSMul (HPow.hPow n j) x","decl":"@[to_additive (attr := simp)]\ntheorem pow_iterate (n : ℕ) (j : ℕ) : (fun x : G => x ^ n)^[j] = fun x : G => x ^ n ^ j :=\n  letI : MulAction ℕ G :=\n    { smul := fun n g => g ^ n\n      one_smul := pow_one\n      mul_smul := fun m n g => pow_mul' g m n }\n  smul_iterate n j\n\n"}
{"name":"pow_iterate","module":"Mathlib.Algebra.GroupPower.IterateHom","initialProofState":"G : Type u_2\ninst✝ : Monoid G\nn j : Nat\n⊢ Eq (Nat.iterate (fun x => HPow.hPow x n) j) fun x => HPow.hPow x (HPow.hPow n j)","decl":"@[to_additive (attr := simp)]\ntheorem pow_iterate (n : ℕ) (j : ℕ) : (fun x : G => x ^ n)^[j] = fun x : G => x ^ n ^ j :=\n  letI : MulAction ℕ G :=\n    { smul := fun n g => g ^ n\n      one_smul := pow_one\n      mul_smul := fun m n g => pow_mul' g m n }\n  smul_iterate n j\n\n"}
{"name":"zpow_iterate","module":"Mathlib.Algebra.GroupPower.IterateHom","initialProofState":"G : Type u_2\ninst✝ : Group G\nn : Int\nj : Nat\n⊢ Eq (Nat.iterate (fun x => HPow.hPow x n) j) fun x => HPow.hPow x (HPow.hPow n j)","decl":"@[to_additive (attr := simp)]\ntheorem zpow_iterate (n : ℤ) (j : ℕ) : (fun x : G => x ^ n)^[j] = fun x => x ^ n ^ j :=\n  letI : MulAction ℤ G :=\n    { smul := fun n g => g ^ n\n      one_smul := zpow_one\n      mul_smul := fun m n g => zpow_mul' g m n }\n  smul_iterate n j\n\n"}
{"name":"zsmul_iterate","module":"Mathlib.Algebra.GroupPower.IterateHom","initialProofState":"G : Type u_2\ninst✝ : AddGroup G\nn : Int\nj : Nat\n⊢ Eq (Nat.iterate (fun x => HSMul.hSMul n x) j) fun x => HSMul.hSMul (HPow.hPow n j) x","decl":"@[to_additive (attr := simp)]\ntheorem zpow_iterate (n : ℤ) (j : ℕ) : (fun x : G => x ^ n)^[j] = fun x => x ^ n ^ j :=\n  letI : MulAction ℤ G :=\n    { smul := fun n g => g ^ n\n      one_smul := zpow_one\n      mul_smul := fun m n g => zpow_mul' g m n }\n  smul_iterate n j\n\n"}
{"name":"SemiconjBy.function_semiconj_mul_left","module":"Mathlib.Algebra.GroupPower.IterateHom","initialProofState":"G : Type u_2\ninst✝ : Semigroup G\na b c : G\nh : SemiconjBy a b c\n⊢ Function.Semiconj (fun x => HMul.hMul a x) (fun x => HMul.hMul b x) fun x => HMul.hMul c x","decl":"@[to_additive]\ntheorem SemiconjBy.function_semiconj_mul_left (h : SemiconjBy a b c) :\n    Function.Semiconj (a * ·) (b * ·) (c * ·) := fun j => by\n  beta_reduce; rw [← mul_assoc, h.eq, mul_assoc]\n\n"}
{"name":"AddSemiconjBy.function_semiconj_add_left","module":"Mathlib.Algebra.GroupPower.IterateHom","initialProofState":"G : Type u_2\ninst✝ : AddSemigroup G\na b c : G\nh : AddSemiconjBy a b c\n⊢ Function.Semiconj (fun x => HAdd.hAdd a x) (fun x => HAdd.hAdd b x) fun x => HAdd.hAdd c x","decl":"@[to_additive]\ntheorem SemiconjBy.function_semiconj_mul_left (h : SemiconjBy a b c) :\n    Function.Semiconj (a * ·) (b * ·) (c * ·) := fun j => by\n  beta_reduce; rw [← mul_assoc, h.eq, mul_assoc]\n\n"}
{"name":"AddCommute.function_commute_add_left","module":"Mathlib.Algebra.GroupPower.IterateHom","initialProofState":"G : Type u_2\ninst✝ : AddSemigroup G\na b : G\nh : AddCommute a b\n⊢ Function.Commute (fun x => HAdd.hAdd a x) fun x => HAdd.hAdd b x","decl":"@[to_additive]\ntheorem Commute.function_commute_mul_left (h : Commute a b) :\n    Function.Commute (a * ·) (b * ·) :=\n  SemiconjBy.function_semiconj_mul_left h\n\n"}
{"name":"Commute.function_commute_mul_left","module":"Mathlib.Algebra.GroupPower.IterateHom","initialProofState":"G : Type u_2\ninst✝ : Semigroup G\na b : G\nh : Commute a b\n⊢ Function.Commute (fun x => HMul.hMul a x) fun x => HMul.hMul b x","decl":"@[to_additive]\ntheorem Commute.function_commute_mul_left (h : Commute a b) :\n    Function.Commute (a * ·) (b * ·) :=\n  SemiconjBy.function_semiconj_mul_left h\n\n"}
{"name":"SemiconjBy.function_semiconj_mul_right_swap","module":"Mathlib.Algebra.GroupPower.IterateHom","initialProofState":"G : Type u_2\ninst✝ : Semigroup G\na b c : G\nh : SemiconjBy a b c\n⊢ Function.Semiconj (fun x => HMul.hMul x a) (fun x => HMul.hMul x c) fun x => HMul.hMul x b","decl":"@[to_additive]\ntheorem SemiconjBy.function_semiconj_mul_right_swap (h : SemiconjBy a b c) :\n    Function.Semiconj (· * a) (· * c) (· * b) := fun j => by simp_rw [mul_assoc, ← h.eq]\n\n"}
{"name":"AddSemiconjBy.function_semiconj_add_right_swap","module":"Mathlib.Algebra.GroupPower.IterateHom","initialProofState":"G : Type u_2\ninst✝ : AddSemigroup G\na b c : G\nh : AddSemiconjBy a b c\n⊢ Function.Semiconj (fun x => HAdd.hAdd x a) (fun x => HAdd.hAdd x c) fun x => HAdd.hAdd x b","decl":"@[to_additive]\ntheorem SemiconjBy.function_semiconj_mul_right_swap (h : SemiconjBy a b c) :\n    Function.Semiconj (· * a) (· * c) (· * b) := fun j => by simp_rw [mul_assoc, ← h.eq]\n\n"}
{"name":"AddCommute.function_commute_add_right","module":"Mathlib.Algebra.GroupPower.IterateHom","initialProofState":"G : Type u_2\ninst✝ : AddSemigroup G\na b : G\nh : AddCommute a b\n⊢ Function.Commute (fun x => HAdd.hAdd x a) fun x => HAdd.hAdd x b","decl":"@[to_additive]\ntheorem Commute.function_commute_mul_right (h : Commute a b) :\n    Function.Commute (· * a) (· * b) :=\n  SemiconjBy.function_semiconj_mul_right_swap h\n\n"}
{"name":"Commute.function_commute_mul_right","module":"Mathlib.Algebra.GroupPower.IterateHom","initialProofState":"G : Type u_2\ninst✝ : Semigroup G\na b : G\nh : Commute a b\n⊢ Function.Commute (fun x => HMul.hMul x a) fun x => HMul.hMul x b","decl":"@[to_additive]\ntheorem Commute.function_commute_mul_right (h : Commute a b) :\n    Function.Commute (· * a) (· * b) :=\n  SemiconjBy.function_semiconj_mul_right_swap h\n\n"}
