{"name":"Stirling.stirlingSeq_zero","module":"Mathlib.Analysis.SpecialFunctions.Stirling","initialProofState":"‚ä¢ Eq (Stirling.stirlingSeq 0) 0","decl":"@[simp]\ntheorem stirlingSeq_zero : stirlingSeq 0 = 0 := by\n  rw [stirlingSeq, cast_zero, mul_zero, Real.sqrt_zero, zero_mul, div_zero]\n\n"}
{"name":"Stirling.stirlingSeq_one","module":"Mathlib.Analysis.SpecialFunctions.Stirling","initialProofState":"‚ä¢ Eq (Stirling.stirlingSeq 1) (HDiv.hDiv (Real.exp 1) (Real.sqrt 2))","decl":"@[simp]\ntheorem stirlingSeq_one : stirlingSeq 1 = exp 1 / ‚àö2 := by\n  rw [stirlingSeq, pow_one, factorial_one, cast_one, mul_one, mul_one_div, one_div_div]\n\n"}
{"name":"Stirling.log_stirlingSeq_formula","module":"Mathlib.Analysis.SpecialFunctions.Stirling","initialProofState":"n : Nat\n‚ä¢ Eq (Real.log (Stirling.stirlingSeq n)) (HSub.hSub (HSub.hSub (Real.log ‚Üën.factorial) (HMul.hMul (1 / 2) (Real.log (HMul.hMul 2 ‚Üën)))) (HMul.hMul (‚Üën) (Real.log (HDiv.hDiv (‚Üën) (Real.exp 1)))))","decl":"theorem log_stirlingSeq_formula (n : ‚Ñï) :\n    log (stirlingSeq n) = Real.log n ! - 1 / 2 * Real.log (2 * n) - n * log (n / exp 1) := by\n  cases n\n  ¬∑ simp\n  ¬∑ rw [stirlingSeq, log_div, log_mul, sqrt_eq_rpow, log_rpow, Real.log_pow, tsub_tsub]\n      <;> positivity\n\n"}
{"name":"Stirling.log_stirlingSeq_diff_hasSum","module":"Mathlib.Analysis.SpecialFunctions.Stirling","initialProofState":"m : Nat\n‚ä¢ HasSum (fun k => HMul.hMul (HDiv.hDiv 1 (HAdd.hAdd (HMul.hMul 2 ‚Üë(HAdd.hAdd k 1)) 1)) (HPow.hPow (HPow.hPow (HDiv.hDiv 1 (HAdd.hAdd (HMul.hMul 2 ‚Üë(HAdd.hAdd m 1)) 1)) 2) (HAdd.hAdd k 1))) (HSub.hSub (Real.log (Stirling.stirlingSeq (HAdd.hAdd m 1))) (Real.log (Stirling.stirlingSeq (HAdd.hAdd m 2))))","decl":"/-- The sequence `log (stirlingSeq (m + 1)) - log (stirlingSeq (m + 2))` has the series expansion\n   `‚àë 1 / (2 * (k + 1) + 1) * (1 / 2 * (m + 1) + 1)^(2 * (k + 1))`\n-/\ntheorem log_stirlingSeq_diff_hasSum (m : ‚Ñï) :\n    HasSum (fun k : ‚Ñï => (1 : ‚Ñù) / (2 * ‚Üë(k + 1) + 1) * ((1 / (2 * ‚Üë(m + 1) + 1)) ^ 2) ^ ‚Üë(k + 1))\n      (log (stirlingSeq (m + 1)) - log (stirlingSeq (m + 2))) := by\n  let f (k : ‚Ñï) := (1 : ‚Ñù) / (2 * k + 1) * ((1 / (2 * ‚Üë(m + 1) + 1)) ^ 2) ^ k\n  change HasSum (fun k => f (k + 1)) _\n  rw [hasSum_nat_add_iff]\n  convert (hasSum_log_one_add_inv m.cast_add_one_pos).mul_left ((‚Üë(m + 1) : ‚Ñù) + 1 / 2) using 1\n  ¬∑ ext k\n    dsimp only [f]\n    rw [‚Üê pow_mul, pow_add]\n    push_cast\n    field_simp\n    ring\n  ¬∑ have h : ‚àÄ x ‚â† (0 : ‚Ñù), 1 + x‚Åª¬π = (x + 1) / x := fun x hx ‚Ü¶ by field_simp [hx]\n    simp (disch := positivity) only [log_stirlingSeq_formula, log_div, log_mul, log_exp,\n      factorial_succ, cast_mul, cast_succ, cast_zero, range_one, sum_singleton, h]\n    ring\n\n"}
{"name":"Stirling.log_stirlingSeq'_antitone","module":"Mathlib.Analysis.SpecialFunctions.Stirling","initialProofState":"‚ä¢ Antitone (Function.comp Real.log (Function.comp Stirling.stirlingSeq Nat.succ))","decl":"/-- The sequence `log ‚àò stirlingSeq ‚àò succ` is monotone decreasing -/\ntheorem log_stirlingSeq'_antitone : Antitone (Real.log ‚àò stirlingSeq ‚àò succ) :=\n  antitone_nat_of_succ_le fun n =>\n    sub_nonneg.mp <| (log_stirlingSeq_diff_hasSum n).nonneg fun m => by positivity\n\n"}
{"name":"Stirling.log_stirlingSeq_diff_le_geo_sum","module":"Mathlib.Analysis.SpecialFunctions.Stirling","initialProofState":"n : Nat\n‚ä¢ LE.le (HSub.hSub (Real.log (Stirling.stirlingSeq (HAdd.hAdd n 1))) (Real.log (Stirling.stirlingSeq (HAdd.hAdd n 2)))) (HDiv.hDiv (HPow.hPow (HDiv.hDiv 1 (HAdd.hAdd (HMul.hMul 2 ‚Üë(HAdd.hAdd n 1)) 1)) 2) (HSub.hSub 1 (HPow.hPow (HDiv.hDiv 1 (HAdd.hAdd (HMul.hMul 2 ‚Üë(HAdd.hAdd n 1)) 1)) 2)))","decl":"/-- We have a bound for successive elements in the sequence `log (stirlingSeq k)`.\n-/\ntheorem log_stirlingSeq_diff_le_geo_sum (n : ‚Ñï) :\n    log (stirlingSeq (n + 1)) - log (stirlingSeq (n + 2)) ‚â§\n      ((1 : ‚Ñù) / (2 * ‚Üë(n + 1) + 1)) ^ 2 / (1 - ((1 : ‚Ñù) / (2 * ‚Üë(n + 1) + 1)) ^ 2) := by\n  have h_nonneg : (0 : ‚Ñù) ‚â§ ((1 : ‚Ñù) / (2 * ‚Üë(n + 1) + 1)) ^ 2 := sq_nonneg _\n  have g : HasSum (fun k : ‚Ñï => (((1 : ‚Ñù) / (2 * ‚Üë(n + 1) + 1)) ^ 2) ^ ‚Üë(k + 1))\n      (((1 : ‚Ñù) / (2 * ‚Üë(n + 1) + 1)) ^ 2 / (1 - ((1 : ‚Ñù) / (2 * ‚Üë(n + 1) + 1)) ^ 2)) := by\n    have := (hasSum_geometric_of_lt_one h_nonneg ?_).mul_left (((1 : ‚Ñù) / (2 * ‚Üë(n + 1) + 1)) ^ 2)\n    ¬∑ simp_rw [‚Üê _root_.pow_succ'] at this\n      exact this\n    rw [one_div, inv_pow]\n    exact inv_lt_one_of_one_lt‚ÇÄ (one_lt_pow‚ÇÄ (lt_add_of_pos_left _ <| by positivity) two_ne_zero)\n  have hab (k : ‚Ñï) : (1 : ‚Ñù) / (2 * ‚Üë(k + 1) + 1) * ((1 / (2 * ‚Üë(n + 1) + 1)) ^ 2) ^ ‚Üë(k + 1) ‚â§\n      (((1 : ‚Ñù) / (2 * ‚Üë(n + 1) + 1)) ^ 2) ^ ‚Üë(k + 1) := by\n    refine mul_le_of_le_one_left (pow_nonneg h_nonneg ‚Üë(k + 1)) ?_\n    rw [one_div]\n    exact inv_le_one_of_one_le‚ÇÄ (le_add_of_nonneg_left <| by positivity)\n  exact hasSum_le hab (log_stirlingSeq_diff_hasSum n) g\n\n"}
{"name":"Stirling.log_stirlingSeq_sub_log_stirlingSeq_succ","module":"Mathlib.Analysis.SpecialFunctions.Stirling","initialProofState":"n : Nat\n‚ä¢ LE.le (HSub.hSub (Real.log (Stirling.stirlingSeq (HAdd.hAdd n 1))) (Real.log (Stirling.stirlingSeq (HAdd.hAdd n 2)))) (HDiv.hDiv 1 (HMul.hMul 4 (HPow.hPow (‚Üë(HAdd.hAdd n 1)) 2)))","decl":"/-- We have the bound `log (stirlingSeq n) - log (stirlingSeq (n+1))` ‚â§ 1/(4 n^2)\n-/\ntheorem log_stirlingSeq_sub_log_stirlingSeq_succ (n : ‚Ñï) :\n    log (stirlingSeq (n + 1)) - log (stirlingSeq (n + 2)) ‚â§ 1 / (4 * (‚Üë(n + 1) : ‚Ñù) ^ 2) := by\n  have h‚ÇÅ : (0 : ‚Ñù) < 4 * ((n : ‚Ñù) + 1) ^ 2 := by positivity\n  have h‚ÇÉ : (0 : ‚Ñù) < (2 * ((n : ‚Ñù) + 1) + 1) ^ 2 := by positivity\n  have h‚ÇÇ : (0 : ‚Ñù) < 1 - (1 / (2 * ((n : ‚Ñù) + 1) + 1)) ^ 2 := by\n    rw [‚Üê mul_lt_mul_right h‚ÇÉ]\n    have H : 0 < (2 * ((n : ‚Ñù) + 1) + 1) ^ 2 - 1 := by nlinarith [@cast_nonneg ‚Ñù _ n]\n    convert H using 1 <;> field_simp [h‚ÇÉ.ne']\n  refine (log_stirlingSeq_diff_le_geo_sum n).trans ?_\n  push_cast\n  rw [div_le_div_iff‚ÇÄ h‚ÇÇ h‚ÇÅ]\n  field_simp [h‚ÇÉ.ne']\n  rw [div_le_div_iff_of_pos_right h‚ÇÉ]\n  ring_nf\n  norm_cast\n  omega\n\n"}
{"name":"Stirling.log_stirlingSeq_bounded_aux","module":"Mathlib.Analysis.SpecialFunctions.Stirling","initialProofState":"‚ä¢ Exists fun c => ‚àÄ (n : Nat), LE.le (HSub.hSub (Real.log (Stirling.stirlingSeq 1)) (Real.log (Stirling.stirlingSeq (HAdd.hAdd n 1)))) c","decl":"/-- For any `n`, we have `log_stirlingSeq 1 - log_stirlingSeq n ‚â§ 1/4 * ‚àë' 1/k^2`  -/\ntheorem log_stirlingSeq_bounded_aux :\n    ‚àÉ c : ‚Ñù, ‚àÄ n : ‚Ñï, log (stirlingSeq 1) - log (stirlingSeq (n + 1)) ‚â§ c := by\n  let d : ‚Ñù := ‚àë' k : ‚Ñï, (1 : ‚Ñù) / (‚Üë(k + 1) : ‚Ñù) ^ 2\n  use 1 / 4 * d\n  let log_stirlingSeq' : ‚Ñï ‚Üí ‚Ñù := fun k => log (stirlingSeq (k + 1))\n  intro n\n  have h‚ÇÅ k : log_stirlingSeq' k - log_stirlingSeq' (k + 1) ‚â§ 1 / 4 * (1 / (‚Üë(k + 1) : ‚Ñù) ^ 2) := by\n    convert log_stirlingSeq_sub_log_stirlingSeq_succ k using 1; field_simp\n  have h‚ÇÇ : (‚àë k ‚àà range n, 1 / (‚Üë(k + 1) : ‚Ñù) ^ 2) ‚â§ d := by\n    have := (summable_nat_add_iff 1).mpr <| Real.summable_one_div_nat_pow.mpr one_lt_two\n    exact sum_le_tsum (range n) (fun k _ => by positivity) this\n  calc\n    log (stirlingSeq 1) - log (stirlingSeq (n + 1)) = log_stirlingSeq' 0 - log_stirlingSeq' n :=\n      rfl\n    _ = ‚àë k ‚àà range n, (log_stirlingSeq' k - log_stirlingSeq' (k + 1)) := by\n      rw [‚Üê sum_range_sub' log_stirlingSeq' n]\n    _ ‚â§ ‚àë k ‚àà range n, 1 / 4 * (1 / ‚Üë((k + 1)) ^ 2) := sum_le_sum fun k _ => h‚ÇÅ k\n    _ = 1 / 4 * ‚àë k ‚àà range n, 1 / ‚Üë((k + 1)) ^ 2 := by rw [mul_sum]\n    _ ‚â§ 1 / 4 * d := by gcongr\n\n"}
{"name":"Stirling.log_stirlingSeq_bounded_by_constant","module":"Mathlib.Analysis.SpecialFunctions.Stirling","initialProofState":"‚ä¢ Exists fun c => ‚àÄ (n : Nat), LE.le c (Real.log (Stirling.stirlingSeq (HAdd.hAdd n 1)))","decl":"/-- The sequence `log_stirlingSeq` is bounded below for `n ‚â• 1`. -/\ntheorem log_stirlingSeq_bounded_by_constant : ‚àÉ c, ‚àÄ n : ‚Ñï, c ‚â§ log (stirlingSeq (n + 1)) := by\n  obtain ‚ü®d, h‚ü© := log_stirlingSeq_bounded_aux\n  exact ‚ü®log (stirlingSeq 1) - d, fun n => sub_le_comm.mp (h n)‚ü©\n\n"}
{"name":"Stirling.stirlingSeq'_pos","module":"Mathlib.Analysis.SpecialFunctions.Stirling","initialProofState":"n : Nat\n‚ä¢ LT.lt 0 (Stirling.stirlingSeq (HAdd.hAdd n 1))","decl":"/-- The sequence `stirlingSeq` is positive for `n > 0`  -/\ntheorem stirlingSeq'_pos (n : ‚Ñï) : 0 < stirlingSeq (n + 1) := by unfold stirlingSeq; positivity\n\n"}
{"name":"Stirling.stirlingSeq'_bounded_by_pos_constant","module":"Mathlib.Analysis.SpecialFunctions.Stirling","initialProofState":"‚ä¢ Exists fun a => And (LT.lt 0 a) (‚àÄ (n : Nat), LE.le a (Stirling.stirlingSeq (HAdd.hAdd n 1)))","decl":"/-- The sequence `stirlingSeq` has a positive lower bound.\n-/\ntheorem stirlingSeq'_bounded_by_pos_constant : ‚àÉ a, 0 < a ‚àß ‚àÄ n : ‚Ñï, a ‚â§ stirlingSeq (n + 1) := by\n  cases' log_stirlingSeq_bounded_by_constant with c h\n  refine ‚ü®exp c, exp_pos _, fun n => ?_‚ü©\n  rw [‚Üê le_log_iff_exp_le (stirlingSeq'_pos n)]\n  exact h n\n\n"}
{"name":"Stirling.stirlingSeq'_antitone","module":"Mathlib.Analysis.SpecialFunctions.Stirling","initialProofState":"‚ä¢ Antitone (Function.comp Stirling.stirlingSeq Nat.succ)","decl":"/-- The sequence `stirlingSeq ‚àò succ` is monotone decreasing -/\ntheorem stirlingSeq'_antitone : Antitone (stirlingSeq ‚àò succ) := fun n m h =>\n  (log_le_log_iff (stirlingSeq'_pos m) (stirlingSeq'_pos n)).mp (log_stirlingSeq'_antitone h)\n\n"}
{"name":"Stirling.stirlingSeq_has_pos_limit_a","module":"Mathlib.Analysis.SpecialFunctions.Stirling","initialProofState":"‚ä¢ Exists fun a => And (LT.lt 0 a) (Filter.Tendsto Stirling.stirlingSeq Filter.atTop (nhds a))","decl":"/-- The limit `a` of the sequence `stirlingSeq` satisfies `0 < a` -/\ntheorem stirlingSeq_has_pos_limit_a : ‚àÉ a : ‚Ñù, 0 < a ‚àß Tendsto stirlingSeq atTop (ùìù a) := by\n  obtain ‚ü®x, x_pos, hx‚ü© := stirlingSeq'_bounded_by_pos_constant\n  have hx' : x ‚àà lowerBounds (Set.range (stirlingSeq ‚àò succ)) := by simpa [lowerBounds] using hx\n  refine ‚ü®_, lt_of_lt_of_le x_pos (le_csInf (Set.range_nonempty _) hx'), ?_‚ü©\n  rw [‚Üê Filter.tendsto_add_atTop_iff_nat 1]\n  exact tendsto_atTop_ciInf stirlingSeq'_antitone ‚ü®x, hx'‚ü©\n\n"}
{"name":"Stirling.tendsto_self_div_two_mul_self_add_one","module":"Mathlib.Analysis.SpecialFunctions.Stirling","initialProofState":"‚ä¢ Filter.Tendsto (fun n => HDiv.hDiv (‚Üën) (HAdd.hAdd (HMul.hMul 2 ‚Üën) 1)) Filter.atTop (nhds (1 / 2))","decl":"/-- The sequence `n / (2 * n + 1)` tends to `1/2` -/\ntheorem tendsto_self_div_two_mul_self_add_one :\n    Tendsto (fun n : ‚Ñï => (n : ‚Ñù) / (2 * n + 1)) atTop (ùìù (1 / 2)) := by\n  conv =>\n    congr\n    ¬∑ skip\n    ¬∑ skip\n    rw [one_div, ‚Üê add_zero (2 : ‚Ñù)]\n  refine (((tendsto_const_div_atTop_nhds_zero_nat 1).const_add (2 : ‚Ñù)).inv‚ÇÄ\n    ((add_zero (2 : ‚Ñù)).symm ‚ñ∏ two_ne_zero)).congr' (eventually_atTop.mpr ‚ü®1, fun n hn => ?_‚ü©)\n  rw [add_div' (1 : ‚Ñù) 2 n (cast_ne_zero.mpr (one_le_iff_ne_zero.mp hn)), inv_div]\n\n"}
{"name":"Stirling.stirlingSeq_pow_four_div_stirlingSeq_pow_two_eq","module":"Mathlib.Analysis.SpecialFunctions.Stirling","initialProofState":"n : Nat\nhn : Ne n 0\n‚ä¢ Eq (HMul.hMul (HDiv.hDiv (HPow.hPow (Stirling.stirlingSeq n) 4) (HPow.hPow (Stirling.stirlingSeq (HMul.hMul 2 n)) 2)) (HDiv.hDiv (‚Üën) (HAdd.hAdd (HMul.hMul 2 ‚Üën) 1))) (Real.Wallis.W n)","decl":"/-- For any `n ‚â† 0`, we have the identity\n`(stirlingSeq n)^4 / (stirlingSeq (2*n))^2 * (n / (2 * n + 1)) = W n`, where `W n` is the\n`n`-th partial product of Wallis' formula for `œÄ / 2`. -/\ntheorem stirlingSeq_pow_four_div_stirlingSeq_pow_two_eq (n : ‚Ñï) (hn : n ‚â† 0) :\n    stirlingSeq n ^ 4 / stirlingSeq (2 * n) ^ 2 * (n / (2 * n + 1)) = Wallis.W n := by\n  have : 4 = 2 * 2 := by rfl\n  rw [stirlingSeq, this, pow_mul, stirlingSeq, Wallis.W_eq_factorial_ratio]\n  simp_rw [div_pow, mul_pow]\n  rw [sq_sqrt, sq_sqrt]\n  any_goals positivity\n  field_simp [‚Üê exp_nsmul]\n  ring_nf\n\n"}
{"name":"Stirling.second_wallis_limit","module":"Mathlib.Analysis.SpecialFunctions.Stirling","initialProofState":"a : Real\nhane : Ne a 0\nha : Filter.Tendsto Stirling.stirlingSeq Filter.atTop (nhds a)\n‚ä¢ Filter.Tendsto Real.Wallis.W Filter.atTop (nhds (HDiv.hDiv (HPow.hPow a 2) 2))","decl":"/-- Suppose the sequence `stirlingSeq` (defined above) has the limit `a ‚â† 0`.\nThen the Wallis sequence `W n` has limit `a^2 / 2`.\n-/\ntheorem second_wallis_limit (a : ‚Ñù) (hane : a ‚â† 0) (ha : Tendsto stirlingSeq atTop (ùìù a)) :\n    Tendsto Wallis.W atTop (ùìù (a ^ 2 / 2)) := by\n  refine Tendsto.congr' (eventually_atTop.mpr ‚ü®1, fun n hn =>\n    stirlingSeq_pow_four_div_stirlingSeq_pow_two_eq n (one_le_iff_ne_zero.mp hn)‚ü©) ?_\n  have h : a ^ 2 / 2 = a ^ 4 / a ^ 2 * (1 / 2) := by\n    rw [mul_one_div, ‚Üê mul_one_div (a ^ 4) (a ^ 2), one_div, ‚Üê pow_sub_of_lt a]\n    norm_num\n  rw [h]\n  exact ((ha.pow 4).div ((ha.comp (tendsto_id.const_mul_atTop' two_pos)).pow 2)\n    (pow_ne_zero 2 hane)).mul tendsto_self_div_two_mul_self_add_one\n\n"}
{"name":"Stirling.tendsto_stirlingSeq_sqrt_pi","module":"Mathlib.Analysis.SpecialFunctions.Stirling","initialProofState":"‚ä¢ Filter.Tendsto Stirling.stirlingSeq Filter.atTop (nhds Real.pi.sqrt)","decl":"/-- **Stirling's Formula** -/\ntheorem tendsto_stirlingSeq_sqrt_pi : Tendsto stirlingSeq atTop (ùìù (‚àöœÄ)) := by\n  obtain ‚ü®a, hapos, halimit‚ü© := stirlingSeq_has_pos_limit_a\n  have hœÄ : œÄ / 2 = a ^ 2 / 2 :=\n    tendsto_nhds_unique Wallis.tendsto_W_nhds_pi_div_two (second_wallis_limit a hapos.ne' halimit)\n  rwa [(div_left_inj' (two_ne_zero' ‚Ñù)).mp hœÄ, sqrt_sq hapos.le]\n\n"}
{"name":"Stirling.factorial_isEquivalent_stirling","module":"Mathlib.Analysis.SpecialFunctions.Stirling","initialProofState":"‚ä¢ Asymptotics.IsEquivalent Filter.atTop (fun n => ‚Üën.factorial) fun n => HMul.hMul (HMul.hMul (HMul.hMul 2 ‚Üën) Real.pi).sqrt (HPow.hPow (HDiv.hDiv (‚Üën) (Real.exp 1)) n)","decl":"/-- **Stirling's Formula**, formulated in terms of `Asymptotics.IsEquivalent`. -/\nlemma factorial_isEquivalent_stirling :\n    (fun n ‚Ü¶ n ! : ‚Ñï ‚Üí ‚Ñù) ~[atTop] fun n ‚Ü¶ Real.sqrt (2 * n * œÄ) * (n / exp 1) ^ n := by\n  refine Asymptotics.isEquivalent_of_tendsto_one ?_ ?_\n  ¬∑ filter_upwards [eventually_ne_atTop 0] with n hn h\n    exact absurd h (by positivity)\n  ¬∑ have : sqrt œÄ ‚â† 0 := by positivity\n    nth_rewrite 2 [‚Üê div_self this]\n    convert tendsto_stirlingSeq_sqrt_pi.div tendsto_const_nhds this using 1\n    ext n\n    field_simp [stirlingSeq, mul_right_comm]\n\n"}
