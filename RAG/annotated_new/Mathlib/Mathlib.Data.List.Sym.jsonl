{"name":"List.sym2_map","module":"Mathlib.Data.List.Sym","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nxs : List α\n⊢ Eq (List.map f xs).sym2 (List.map (Sym2.map f) xs.sym2)","decl":"theorem sym2_map (f : α → β) (xs : List α) :\n    (xs.map f).sym2 = xs.sym2.map (Sym2.map f) := by\n  induction xs with\n  | nil => simp [List.sym2]\n  | cons x xs ih => simp [List.sym2, ih, Function.comp]\n\n"}
{"name":"List.mem_sym2_cons_iff","module":"Mathlib.Data.List.Sym","initialProofState":"α : Type u_1\nx : α\nxs : List α\nz : Sym2 α\n⊢ Iff (Membership.mem (List.cons x xs).sym2 z) (Or (Eq z (Sym2.mk { fst := x, snd := x })) (Or (Exists fun y => And (Membership.mem xs y) (Eq z (Sym2.mk { fst := x, snd := y }))) (Membership.mem xs.sym2 z)))","decl":"theorem mem_sym2_cons_iff {x : α} {xs : List α} {z : Sym2 α} :\n    z ∈ (x :: xs).sym2 ↔ z = s(x, x) ∨ (∃ y, y ∈ xs ∧ z = s(x, y)) ∨ z ∈ xs.sym2 := by\n  simp only [List.sym2, map_cons, cons_append, mem_cons, mem_append, mem_map]\n  simp only [eq_comm]\n\n"}
{"name":"List.sym2_eq_nil_iff","module":"Mathlib.Data.List.Sym","initialProofState":"α : Type u_1\nxs : List α\n⊢ Iff (Eq xs.sym2 List.nil) (Eq xs List.nil)","decl":"@[simp]\ntheorem sym2_eq_nil_iff {xs : List α} : xs.sym2 = [] ↔ xs = [] := by\n  cases xs <;> simp [List.sym2]\n\n"}
{"name":"List.left_mem_of_mk_mem_sym2","module":"Mathlib.Data.List.Sym","initialProofState":"α : Type u_1\nxs : List α\na b : α\nh : Membership.mem xs.sym2 (Sym2.mk { fst := a, snd := b })\n⊢ Membership.mem xs a","decl":"theorem left_mem_of_mk_mem_sym2 {xs : List α} {a b : α}\n    (h : s(a, b) ∈ xs.sym2) : a ∈ xs := by\n  induction xs with\n  | nil => exact (not_mem_nil _ h).elim\n  | cons x xs ih =>\n    rw [mem_cons]\n    rw [mem_sym2_cons_iff] at h\n    obtain (h | ⟨c, hc, h⟩ | h) := h\n    · rw [Sym2.eq_iff, ← and_or_left] at h\n      exact .inl h.1\n    · rw [Sym2.eq_iff] at h\n      obtain (⟨rfl, rfl⟩ | ⟨rfl, rfl⟩) := h <;> simp [hc]\n    · exact .inr <| ih h\n\n"}
{"name":"List.right_mem_of_mk_mem_sym2","module":"Mathlib.Data.List.Sym","initialProofState":"α : Type u_1\nxs : List α\na b : α\nh : Membership.mem xs.sym2 (Sym2.mk { fst := a, snd := b })\n⊢ Membership.mem xs b","decl":"theorem right_mem_of_mk_mem_sym2 {xs : List α} {a b : α}\n    (h : s(a, b) ∈ xs.sym2) : b ∈ xs := by\n  rw [Sym2.eq_swap] at h\n  exact left_mem_of_mk_mem_sym2 h\n\n"}
{"name":"List.mk_mem_sym2","module":"Mathlib.Data.List.Sym","initialProofState":"α : Type u_1\nxs : List α\na b : α\nha : Membership.mem xs a\nhb : Membership.mem xs b\n⊢ Membership.mem xs.sym2 (Sym2.mk { fst := a, snd := b })","decl":"theorem mk_mem_sym2 {xs : List α} {a b : α} (ha : a ∈ xs) (hb : b ∈ xs) :\n    s(a, b) ∈ xs.sym2 := by\n  induction xs with\n  | nil => simp at ha\n  | cons x xs ih =>\n    rw [mem_sym2_cons_iff]\n    rw [mem_cons] at ha hb\n    obtain (rfl | ha) := ha <;> obtain (rfl | hb) := hb\n    · left; rfl\n    · right; left; use b\n    · right; left; rw [Sym2.eq_swap]; use a\n    · right; right; exact ih ha hb\n\n"}
{"name":"List.mk_mem_sym2_iff","module":"Mathlib.Data.List.Sym","initialProofState":"α : Type u_1\nxs : List α\na b : α\n⊢ Iff (Membership.mem xs.sym2 (Sym2.mk { fst := a, snd := b })) (And (Membership.mem xs a) (Membership.mem xs b))","decl":"theorem mk_mem_sym2_iff {xs : List α} {a b : α} :\n    s(a, b) ∈ xs.sym2 ↔ a ∈ xs ∧ b ∈ xs := by\n  constructor\n  · intro h\n    exact ⟨left_mem_of_mk_mem_sym2 h, right_mem_of_mk_mem_sym2 h⟩\n  · rintro ⟨ha, hb⟩\n    exact mk_mem_sym2 ha hb\n\n"}
{"name":"List.mem_sym2_iff","module":"Mathlib.Data.List.Sym","initialProofState":"α : Type u_1\nxs : List α\nz : Sym2 α\n⊢ Iff (Membership.mem xs.sym2 z) (∀ (y : α), Membership.mem z y → Membership.mem xs y)","decl":"theorem mem_sym2_iff {xs : List α} {z : Sym2 α} :\n    z ∈ xs.sym2 ↔ ∀ y ∈ z, y ∈ xs := by\n  refine z.ind (fun a b => ?_)\n  simp [mk_mem_sym2_iff]\n\n"}
{"name":"List.Nodup.sym2","module":"Mathlib.Data.List.Sym","initialProofState":"α : Type u_1\nxs : List α\nh : xs.Nodup\n⊢ xs.sym2.Nodup","decl":"protected theorem Nodup.sym2 {xs : List α} (h : xs.Nodup) : xs.sym2.Nodup := by\n  induction xs with\n  | nil => simp only [List.sym2, nodup_nil]\n  | cons x xs ih =>\n    rw [List.sym2]\n    specialize ih h.of_cons\n    rw [nodup_cons] at h\n    refine Nodup.append (Nodup.cons ?notmem (h.2.map ?inj)) ih ?disj\n    case disj =>\n      intro z hz hz'\n      simp only [mem_cons, mem_map] at hz\n      obtain ⟨_, (rfl | _), rfl⟩ := hz\n        <;> simp [left_mem_of_mk_mem_sym2 hz'] at h\n    case notmem =>\n      intro h'\n      simp only [h.1, mem_map, Sym2.eq_iff, true_and, or_self, exists_eq_right] at h'\n    case inj =>\n      intro a b\n      simp only [Sym2.eq_iff, true_and]\n      rintro (rfl | ⟨rfl, rfl⟩) <;> rfl\n\n"}
{"name":"List.map_mk_sublist_sym2","module":"Mathlib.Data.List.Sym","initialProofState":"α : Type u_1\nx : α\nxs : List α\nh : Membership.mem xs x\n⊢ (List.map (fun y => Sym2.mk { fst := x, snd := y }) xs).Sublist xs.sym2","decl":"theorem map_mk_sublist_sym2 (x : α) (xs : List α) (h : x ∈ xs) :\n    map (fun y ↦ s(x, y)) xs <+ xs.sym2 := by\n  induction xs with\n  | nil => simp\n  | cons x' xs ih =>\n    simp only [map_cons, List.sym2, cons_append]\n    cases h with\n    | head =>\n      exact (sublist_append_left _ _).cons₂ _\n    | tail _ h =>\n      refine .cons _ ?_\n      rw [← singleton_append]\n      refine .append ?_ (ih h)\n      rw [singleton_sublist, mem_map]\n      exact ⟨_, h, Sym2.eq_swap⟩\n\n"}
{"name":"List.map_mk_disjoint_sym2","module":"Mathlib.Data.List.Sym","initialProofState":"α : Type u_1\nx : α\nxs : List α\nh : Not (Membership.mem xs x)\n⊢ (List.map (fun y => Sym2.mk { fst := x, snd := y }) xs).Disjoint xs.sym2","decl":"theorem map_mk_disjoint_sym2 (x : α) (xs : List α) (h : x ∉ xs) :\n    (map (fun y ↦ s(x, y)) xs).Disjoint xs.sym2 := by\n  induction xs with\n  | nil => simp\n  | cons x' xs ih =>\n    simp only [mem_cons, not_or] at h\n    rw [List.sym2, map_cons, map_cons, disjoint_cons_left, disjoint_append_right,\n      disjoint_cons_right]\n    refine ⟨?_, ⟨?_, ?_⟩, ?_⟩\n    · refine not_mem_cons_of_ne_of_not_mem ?_ (not_mem_append ?_ ?_)\n      · simp [h.1]\n      · simp_rw [mem_map, not_exists, not_and]\n        intro x'' hx\n        simp_rw [Sym2.mk_eq_mk_iff, Prod.swap_prod_mk, Prod.mk.injEq, true_and]\n        rintro (⟨rfl, rfl⟩ | rfl)\n        · exact h.2 hx\n        · exact h.2 hx\n      · simp [mk_mem_sym2_iff, h.2]\n    · simp [h.1]\n    · intro z hx hy\n      rw [List.mem_map] at hx hy\n      obtain ⟨a, hx, rfl⟩ := hx\n      obtain ⟨b, hy, hx⟩ := hy\n      simp [Sym2.mk_eq_mk_iff, Ne.symm h.1] at hx\n      obtain ⟨rfl, rfl⟩ := hx\n      exact h.2 hy\n    · exact ih h.2\n\n"}
{"name":"List.dedup_sym2","module":"Mathlib.Data.List.Sym","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nxs : List α\n⊢ Eq xs.sym2.dedup xs.dedup.sym2","decl":"theorem dedup_sym2 [DecidableEq α] (xs : List α) : xs.sym2.dedup = xs.dedup.sym2 := by\n  induction xs with\n  | nil => simp only [List.sym2, dedup_nil]\n  | cons x xs ih =>\n    simp only [List.sym2, map_cons, cons_append]\n    obtain hm | hm := Decidable.em (x ∈ xs)\n    · rw [dedup_cons_of_mem hm, ← ih, dedup_cons_of_mem,\n        List.Subset.dedup_append_right (map_mk_sublist_sym2 _ _ hm).subset]\n      refine mem_append_left _ ?_\n      rw [mem_map]\n      exact ⟨_, hm, Sym2.eq_swap⟩\n    · rw [dedup_cons_of_not_mem hm, List.sym2, map_cons, ← ih, dedup_cons_of_not_mem, cons_append,\n        List.Disjoint.dedup_append, dedup_map_of_injective]\n      · exact (Sym2.mkEmbedding _).injective\n      · exact map_mk_disjoint_sym2 x xs hm\n      · simp [hm, mem_sym2_iff]\n\n"}
{"name":"List.Perm.sym2","module":"Mathlib.Data.List.Sym","initialProofState":"α : Type u_1\nxs ys : List α\nh : xs.Perm ys\n⊢ xs.sym2.Perm ys.sym2","decl":"protected theorem Perm.sym2 {xs ys : List α} (h : xs ~ ys) :\n    xs.sym2 ~ ys.sym2 := by\n  induction h with\n  | nil => rfl\n  | cons x h ih =>\n    simp only [List.sym2, map_cons, cons_append, perm_cons]\n    exact (h.map _).append ih\n  | swap x y xs =>\n    simp only [List.sym2, map_cons, cons_append]\n    conv => enter [1,2,1]; rw [Sym2.eq_swap]\n    -- Explicit permutation to speed up simps that follow.\n    refine Perm.trans (Perm.swap ..) (Perm.trans (Perm.cons _ ?_) (Perm.swap ..))\n    simp only [← Multiset.coe_eq_coe, ← Multiset.cons_coe,\n      ← Multiset.coe_add, ← Multiset.singleton_add]\n    simp only [add_assoc, add_left_comm]\n  | trans _ _ ih1 ih2 => exact ih1.trans ih2\n\n"}
{"name":"List.Sublist.sym2","module":"Mathlib.Data.List.Sym","initialProofState":"α : Type u_1\nxs ys : List α\nh : xs.Sublist ys\n⊢ xs.sym2.Sublist ys.sym2","decl":"protected theorem Sublist.sym2 {xs ys : List α} (h : xs <+ ys) : xs.sym2 <+ ys.sym2 := by\n  induction h with\n  | slnil => apply slnil\n  | cons a h ih =>\n    simp only [List.sym2]\n    exact Sublist.append (nil_sublist _) ih\n  | cons₂ a h ih =>\n    simp only [List.sym2, map_cons, cons_append]\n    exact cons₂ _ (append (Sublist.map _ h) ih)\n\n"}
{"name":"List.Subperm.sym2","module":"Mathlib.Data.List.Sym","initialProofState":"α : Type u_1\nxs ys : List α\nh : xs.Subperm ys\n⊢ xs.sym2.Subperm ys.sym2","decl":"protected theorem Subperm.sym2 {xs ys : List α} (h : xs <+~ ys) : xs.sym2 <+~ ys.sym2 := by\n  obtain ⟨xs', hx, h⟩ := h\n  exact hx.sym2.symm.subperm.trans h.sym2.subperm\n\n"}
{"name":"List.length_sym2","module":"Mathlib.Data.List.Sym","initialProofState":"α : Type u_1\nxs : List α\n⊢ Eq xs.sym2.length ((HAdd.hAdd xs.length 1).choose 2)","decl":"theorem length_sym2 {xs : List α} : xs.sym2.length = Nat.choose (xs.length + 1) 2 := by\n  induction xs with\n  | nil => rfl\n  | cons x xs ih =>\n    rw [List.sym2, length_append, length_map, length_cons,\n        Nat.choose_succ_succ, ← ih, Nat.choose_one_right]\n\n"}
{"name":"List.sym_one_eq","module":"Mathlib.Data.List.Sym","initialProofState":"α : Type u_1\nxs : List α\n⊢ Eq (List.sym 1 xs) (List.map (fun x => Sym.cons x Sym.nil) xs)","decl":"theorem sym_one_eq : xs.sym 1 = xs.map (· ::ₛ .nil) := by\n  induction xs with\n  | nil => simp only [List.sym, Nat.succ_eq_add_one, Nat.reduceAdd, map_nil]\n  | cons x xs ih =>\n    rw [map_cons, ← ih, List.sym, List.sym, map_singleton, singleton_append]\n\n"}
{"name":"List.sym2_eq_sym_two","module":"Mathlib.Data.List.Sym","initialProofState":"α : Type u_1\nxs : List α\n⊢ Eq (List.map (⇑(Sym2.equivSym α)) xs.sym2) (List.sym 2 xs)","decl":"theorem sym2_eq_sym_two : xs.sym2.map (Sym2.equivSym α) = xs.sym 2 := by\n  induction xs with\n  | nil => simp only [List.sym, map_eq_nil_iff, sym2_eq_nil_iff]\n  | cons x xs ih =>\n    rw [List.sym, ← ih, sym_one_eq, map_map, List.sym2, map_append, map_map]\n    rfl\n\n"}
{"name":"List.sym_map","module":"Mathlib.Data.List.Sym","initialProofState":"α : Type u_1\nβ : Type u_3\nf : α → β\nn : Nat\nxs : List α\n⊢ Eq (List.sym n (List.map f xs)) (List.map (Sym.map f) (List.sym n xs))","decl":"theorem sym_map {β : Type*} (f : α → β) (n : ℕ) (xs : List α) :\n    (xs.map f).sym n = (xs.sym n).map (Sym.map f) :=\n  match n, xs with\n  | 0, _ => by simp only [List.sym]; rfl\n  | n + 1, [] => by simp [List.sym]\n  | n + 1, x :: xs => by\n    rw [map_cons, List.sym, ← map_cons, sym_map f n (x :: xs), sym_map f (n + 1) xs]\n    simp only [map_map, List.sym, map_append, append_cancel_right_eq]\n    congr\n    ext s\n    simp only [Function.comp_apply, Sym.map_cons]\n\n"}
{"name":"List.Sublist.sym","module":"Mathlib.Data.List.Sym","initialProofState":"α : Type u_1\nn : Nat\nxs ys : List α\nh : xs.Sublist ys\n⊢ (List.sym n xs).Sublist (List.sym n ys)","decl":"protected theorem Sublist.sym (n : ℕ) {xs ys : List α} (h : xs <+ ys) : xs.sym n <+ ys.sym n :=\n  match n, h with\n  | 0, _ => by simp [List.sym]\n  | n + 1, .slnil => by simp only [refl]\n  | n + 1, .cons a h => by\n    rw [List.sym, ← nil_append (List.sym (n + 1) xs)]\n    apply Sublist.append (nil_sublist _)\n    exact h.sym (n + 1)\n  | n + 1, .cons₂ a h => by\n    rw [List.sym, List.sym]\n    apply Sublist.append\n    · exact ((cons₂ a h).sym n).map _\n    · exact h.sym (n + 1)\n\n"}
{"name":"List.sym_sublist_sym_cons","module":"Mathlib.Data.List.Sym","initialProofState":"α : Type u_1\nxs : List α\nn : Nat\na : α\n⊢ (List.sym n xs).Sublist (List.sym n (List.cons a xs))","decl":"theorem sym_sublist_sym_cons {a : α} : xs.sym n <+ (a :: xs).sym n :=\n  (sublist_cons_self a xs).sym n\n\n"}
{"name":"List.mem_of_mem_of_mem_sym","module":"Mathlib.Data.List.Sym","initialProofState":"α : Type u_1\nn : Nat\nxs : List α\na : α\nz : Sym α n\nha : Membership.mem z a\nhz : Membership.mem (List.sym n xs) z\n⊢ Membership.mem xs a","decl":"theorem mem_of_mem_of_mem_sym {n : ℕ} {xs : List α} {a : α} {z : Sym α n}\n    (ha : a ∈ z) (hz : z ∈ xs.sym n) : a ∈ xs :=\n  match n, xs with\n  | 0, xs => by\n    cases Sym.eq_nil_of_card_zero z\n    simp at ha\n  | n + 1, [] => by simp [List.sym] at hz\n  | n + 1, x :: xs => by\n    rw [List.sym, mem_append, mem_map] at hz\n    obtain ⟨z, hz, rfl⟩ | hz := hz\n    · rw [Sym.mem_cons] at ha\n      obtain rfl | ha := ha\n      · simp\n      · exact mem_of_mem_of_mem_sym ha hz\n    · rw [mem_cons]\n      right\n      exact mem_of_mem_of_mem_sym ha hz\n\n"}
{"name":"List.first_mem_of_cons_mem_sym","module":"Mathlib.Data.List.Sym","initialProofState":"α : Type u_1\nxs : List α\nn : Nat\na : α\nz : Sym α n\nh : Membership.mem (List.sym (HAdd.hAdd n 1) xs) (Sym.cons a z)\n⊢ Membership.mem xs a","decl":"theorem first_mem_of_cons_mem_sym {xs : List α} {n : ℕ} {a : α} {z : Sym α n}\n    (h : a ::ₛ z ∈ xs.sym (n + 1)) : a ∈ xs :=\n  mem_of_mem_of_mem_sym (Sym.mem_cons_self a z) h\n\n"}
{"name":"List.Nodup.sym","module":"Mathlib.Data.List.Sym","initialProofState":"α : Type u_1\nn : Nat\nxs : List α\nh : xs.Nodup\n⊢ (List.sym n xs).Nodup","decl":"protected theorem Nodup.sym (n : ℕ) {xs : List α} (h : xs.Nodup) : (xs.sym n).Nodup :=\n  match n, xs with\n  | 0, _ => by simp [List.sym]\n  | n + 1, [] => by simp [List.sym]\n  | n + 1, x :: xs => by\n    rw [List.sym]\n    refine Nodup.append (Nodup.map ?inj (Nodup.sym n h)) (Nodup.sym (n + 1) h.of_cons) ?disj\n    case inj =>\n      intro z z'\n      simp\n    case disj =>\n      intro z hz hz'\n      rw [mem_map] at hz\n      obtain ⟨z, _hz, rfl⟩ := hz\n      have := first_mem_of_cons_mem_sym hz'\n      simp only [nodup_cons, this, not_true_eq_false, false_and] at h\n\n"}
{"name":"List.length_sym","module":"Mathlib.Data.List.Sym","initialProofState":"α : Type u_1\nn : Nat\nxs : List α\n⊢ Eq (List.sym n xs).length (xs.length.multichoose n)","decl":"theorem length_sym {n : ℕ} {xs : List α} :\n    (xs.sym n).length = Nat.multichoose xs.length n :=\n  match n, xs with\n  | 0, _ => by rw [List.sym, Nat.multichoose]; rfl\n  | n + 1, [] => by simp [List.sym]\n  | n + 1, x :: xs => by\n    rw [List.sym, length_append, length_map, length_cons]\n    rw [@length_sym n (x :: xs), @length_sym (n + 1) xs]\n    rw [Nat.multichoose_succ_succ, length_cons, add_comm]\n\n"}
