{"name":"Fin.pi_lex_lt_cons_cons","module":"Mathlib.Order.Fin.Tuple","initialProofState":"n : Nat\nα : Fin (HAdd.hAdd n 1) → Type u_1\nx₀ y₀ : α 0\nx y : (i : Fin n) → α i.succ\ns : {i : Fin n.succ} → α i → α i → Prop\n⊢ Iff (Pi.Lex (fun x1 x2 => LT.lt x1 x2) s (Fin.cons x₀ x) (Fin.cons y₀ y)) (Or (s x₀ y₀) (And (Eq x₀ y₀) (Pi.Lex (fun x1 x2 => LT.lt x1 x2) (fun i => s) x y)))","decl":"lemma pi_lex_lt_cons_cons {x₀ y₀ : α 0} {x y : ∀ i : Fin n, α i.succ}\n    (s : ∀ {i : Fin n.succ}, α i → α i → Prop) :\n    Pi.Lex (· < ·) (@s) (Fin.cons x₀ x) (Fin.cons y₀ y) ↔\n      s x₀ y₀ ∨ x₀ = y₀ ∧ Pi.Lex (· < ·) (@fun i : Fin n ↦ @s i.succ) x y := by\n  simp_rw [Pi.Lex, Fin.exists_fin_succ, Fin.cons_succ, Fin.cons_zero, Fin.forall_iff_succ]\n  simp [and_assoc, exists_and_left]\n\n"}
{"name":"Fin.insertNth_mem_Icc","module":"Mathlib.Order.Fin.Tuple","initialProofState":"n : Nat\nα : Fin (HAdd.hAdd n 1) → Type u_1\ninst✝ : (i : Fin (HAdd.hAdd n 1)) → Preorder (α i)\ni : Fin (HAdd.hAdd n 1)\nx : α i\np : (j : Fin n) → α (i.succAbove j)\nq₁ q₂ : (j : Fin (HAdd.hAdd n 1)) → α j\n⊢ Iff (Membership.mem (Set.Icc q₁ q₂) (i.insertNth x p)) (And (Membership.mem (Set.Icc (q₁ i) (q₂ i)) x) (Membership.mem (Set.Icc (fun j => q₁ (i.succAbove j)) fun j => q₂ (i.succAbove j)) p))","decl":"lemma insertNth_mem_Icc {i : Fin (n + 1)} {x : α i} {p : ∀ j, α (i.succAbove j)}\n    {q₁ q₂ : ∀ j, α j} :\n    i.insertNth x p ∈ Icc q₁ q₂ ↔\n      x ∈ Icc (q₁ i) (q₂ i) ∧ p ∈ Icc (fun j ↦ q₁ (i.succAbove j)) fun j ↦ q₂ (i.succAbove j) := by\n  simp only [mem_Icc, insertNth_le_iff, le_insertNth_iff, and_assoc, @and_left_comm (x ≤ q₂ i)]\n\n"}
{"name":"Fin.preimage_insertNth_Icc_of_mem","module":"Mathlib.Order.Fin.Tuple","initialProofState":"n : Nat\nα : Fin (HAdd.hAdd n 1) → Type u_1\ninst✝ : (i : Fin (HAdd.hAdd n 1)) → Preorder (α i)\ni : Fin (HAdd.hAdd n 1)\nx : α i\nq₁ q₂ : (j : Fin (HAdd.hAdd n 1)) → α j\nhx : Membership.mem (Set.Icc (q₁ i) (q₂ i)) x\n⊢ Eq (Set.preimage (i.insertNth x) (Set.Icc q₁ q₂)) (Set.Icc (fun j => q₁ (i.succAbove j)) fun j => q₂ (i.succAbove j))","decl":"lemma preimage_insertNth_Icc_of_mem {i : Fin (n + 1)} {x : α i} {q₁ q₂ : ∀ j, α j}\n    (hx : x ∈ Icc (q₁ i) (q₂ i)) :\n    i.insertNth x ⁻¹' Icc q₁ q₂ = Icc (fun j ↦ q₁ (i.succAbove j)) fun j ↦ q₂ (i.succAbove j) :=\n  Set.ext fun p ↦ by simp only [mem_preimage, insertNth_mem_Icc, hx, true_and]\n\n"}
{"name":"Fin.preimage_insertNth_Icc_of_not_mem","module":"Mathlib.Order.Fin.Tuple","initialProofState":"n : Nat\nα : Fin (HAdd.hAdd n 1) → Type u_1\ninst✝ : (i : Fin (HAdd.hAdd n 1)) → Preorder (α i)\ni : Fin (HAdd.hAdd n 1)\nx : α i\nq₁ q₂ : (j : Fin (HAdd.hAdd n 1)) → α j\nhx : Not (Membership.mem (Set.Icc (q₁ i) (q₂ i)) x)\n⊢ Eq (Set.preimage (i.insertNth x) (Set.Icc q₁ q₂)) EmptyCollection.emptyCollection","decl":"lemma preimage_insertNth_Icc_of_not_mem {i : Fin (n + 1)} {x : α i} {q₁ q₂ : ∀ j, α j}\n    (hx : x ∉ Icc (q₁ i) (q₂ i)) : i.insertNth x ⁻¹' Icc q₁ q₂ = ∅ :=\n  Set.ext fun p ↦ by\n    simp only [mem_preimage, insertNth_mem_Icc, hx, false_and, mem_empty_iff_false]\n\n"}
{"name":"liftFun_vecCons","module":"Mathlib.Order.Fin.Tuple","initialProofState":"α : Type u_1\nn : Nat\nr : α → α → Prop\ninst✝ : IsTrans α r\nf : Fin (HAdd.hAdd n 1) → α\na : α\n⊢ Iff (Relator.LiftFun (fun x1 x2 => LT.lt x1 x2) r (Matrix.vecCons a f) (Matrix.vecCons a f)) (And (r a (f 0)) (Relator.LiftFun (fun x1 x2 => LT.lt x1 x2) r f f))","decl":"lemma liftFun_vecCons {n : ℕ} (r : α → α → Prop) [IsTrans α r] {f : Fin (n + 1) → α} {a : α} :\n    ((· < ·) ⇒ r) (vecCons a f) (vecCons a f) ↔ r a (f 0) ∧ ((· < ·) ⇒ r) f f := by\n  simp only [liftFun_iff_succ r, forall_iff_succ, cons_val_succ, cons_val_zero, ← succ_castSucc,\n    castSucc_zero]\n\n"}
{"name":"strictMono_vecCons","module":"Mathlib.Order.Fin.Tuple","initialProofState":"α : Type u_1\ninst✝ : Preorder α\nn : Nat\nf : Fin (HAdd.hAdd n 1) → α\na : α\n⊢ Iff (StrictMono (Matrix.vecCons a f)) (And (LT.lt a (f 0)) (StrictMono f))","decl":"@[simp] lemma strictMono_vecCons : StrictMono (vecCons a f) ↔ a < f 0 ∧ StrictMono f :=\n  liftFun_vecCons (· < ·)\n\n"}
{"name":"monotone_vecCons","module":"Mathlib.Order.Fin.Tuple","initialProofState":"α : Type u_1\ninst✝ : Preorder α\nn : Nat\nf : Fin (HAdd.hAdd n 1) → α\na : α\n⊢ Iff (Monotone (Matrix.vecCons a f)) (And (LE.le a (f 0)) (Monotone f))","decl":"@[simp]\nlemma monotone_vecCons : Monotone (vecCons a f) ↔ a ≤ f 0 ∧ Monotone f := by\n  simpa only [monotone_iff_forall_lt] using @liftFun_vecCons α n (· ≤ ·) _ f a\n\n"}
{"name":"monotone_vecEmpty","module":"Mathlib.Order.Fin.Tuple","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na : α\n⊢ Monotone (Matrix.vecCons a Matrix.vecEmpty)","decl":"@[simp] lemma monotone_vecEmpty : Monotone ![a]\n  | ⟨0, _⟩, ⟨0, _⟩, _ => le_refl _\n\n"}
{"name":"strictMono_vecEmpty","module":"Mathlib.Order.Fin.Tuple","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na : α\n⊢ StrictMono (Matrix.vecCons a Matrix.vecEmpty)","decl":"@[simp] lemma strictMono_vecEmpty : StrictMono ![a]\n  | ⟨0, _⟩, ⟨0, _⟩, h => (irrefl _ h).elim\n\n"}
{"name":"strictAnti_vecCons","module":"Mathlib.Order.Fin.Tuple","initialProofState":"α : Type u_1\ninst✝ : Preorder α\nn : Nat\nf : Fin (HAdd.hAdd n 1) → α\na : α\n⊢ Iff (StrictAnti (Matrix.vecCons a f)) (And (LT.lt (f 0) a) (StrictAnti f))","decl":"@[simp] lemma strictAnti_vecCons : StrictAnti (vecCons a f) ↔ f 0 < a ∧ StrictAnti f :=\n  liftFun_vecCons (· > ·)\n\n"}
{"name":"antitone_vecCons","module":"Mathlib.Order.Fin.Tuple","initialProofState":"α : Type u_1\ninst✝ : Preorder α\nn : Nat\nf : Fin (HAdd.hAdd n 1) → α\na : α\n⊢ Iff (Antitone (Matrix.vecCons a f)) (And (LE.le (f 0) a) (Antitone f))","decl":"@[simp] lemma antitone_vecCons : Antitone (vecCons a f) ↔ f 0 ≤ a ∧ Antitone f :=\n  monotone_vecCons (α := αᵒᵈ)\n\n"}
{"name":"antitone_vecEmpty","module":"Mathlib.Order.Fin.Tuple","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na : α\n⊢ Antitone (Matrix.vecCons a Matrix.vecEmpty)","decl":"@[simp] lemma antitone_vecEmpty : Antitone (vecCons a vecEmpty)\n  | ⟨0, _⟩, ⟨0, _⟩, _ => le_rfl\n\n"}
{"name":"strictAnti_vecEmpty","module":"Mathlib.Order.Fin.Tuple","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na : α\n⊢ StrictAnti (Matrix.vecCons a Matrix.vecEmpty)","decl":"@[simp] lemma strictAnti_vecEmpty : StrictAnti (vecCons a vecEmpty)\n  | ⟨0, _⟩, ⟨0, _⟩, h => (irrefl _ h).elim\n\n"}
{"name":"StrictMono.vecCons","module":"Mathlib.Order.Fin.Tuple","initialProofState":"α : Type u_1\ninst✝ : Preorder α\nn : Nat\nf : Fin (HAdd.hAdd n 1) → α\na : α\nhf : StrictMono f\nha : LT.lt a (f 0)\n⊢ StrictMono (Matrix.vecCons a f)","decl":"lemma StrictMono.vecCons (hf : StrictMono f) (ha : a < f 0) : StrictMono (vecCons a f) :=\n  strictMono_vecCons.2 ⟨ha, hf⟩\n\n"}
{"name":"StrictAnti.vecCons","module":"Mathlib.Order.Fin.Tuple","initialProofState":"α : Type u_1\ninst✝ : Preorder α\nn : Nat\nf : Fin (HAdd.hAdd n 1) → α\na : α\nhf : StrictAnti f\nha : LT.lt (f 0) a\n⊢ StrictAnti (Matrix.vecCons a f)","decl":"lemma StrictAnti.vecCons (hf : StrictAnti f) (ha : f 0 < a) : StrictAnti (vecCons a f) :=\n  strictAnti_vecCons.2 ⟨ha, hf⟩\n\n"}
{"name":"Monotone.vecCons","module":"Mathlib.Order.Fin.Tuple","initialProofState":"α : Type u_1\ninst✝ : Preorder α\nn : Nat\nf : Fin (HAdd.hAdd n 1) → α\na : α\nhf : Monotone f\nha : LE.le a (f 0)\n⊢ Monotone (Matrix.vecCons a f)","decl":"lemma Monotone.vecCons (hf : Monotone f) (ha : a ≤ f 0) : Monotone (vecCons a f) :=\n  monotone_vecCons.2 ⟨ha, hf⟩\n\n"}
{"name":"Antitone.vecCons","module":"Mathlib.Order.Fin.Tuple","initialProofState":"α : Type u_1\ninst✝ : Preorder α\nn : Nat\nf : Fin (HAdd.hAdd n 1) → α\na : α\nhf : Antitone f\nha : LE.le (f 0) a\n⊢ Antitone (Matrix.vecCons a f)","decl":"lemma Antitone.vecCons (hf : Antitone f) (ha : f 0 ≤ a) : Antitone (vecCons a f) :=\n  antitone_vecCons.2 ⟨ha, hf⟩\n\n"}
{"name":"Fin.consOrderIso_symm_apply","module":"Mathlib.Order.Fin.Tuple","initialProofState":"n : Nat\nα : Fin (HAdd.hAdd n 1) → Type u_2\ninst✝ : (i : Fin (HAdd.hAdd n 1)) → LE (α i)\nf : (i : Fin (HAdd.hAdd n 1)) → α i\n⊢ Eq ((RelIso.symm (Fin.consOrderIso α)) f) { fst := f 0, snd := Fin.tail f }","decl":"/-- Order isomorphism between tuples of length `n + 1` and pairs of an element and a tuple of length\n`n` given by separating out the first element of the tuple.\n\nThis is `Fin.cons` as an `OrderIso`. -/\n@[simps!, simps toEquiv]\ndef consOrderIso (α : Fin (n + 1) → Type*) [∀ i, LE (α i)] :\n    α 0 × (∀ i, α (succ i)) ≃o ∀ i, α i where\n  toEquiv := consEquiv α\n  map_rel_iff' := forall_iff_succ\n\n"}
{"name":"Fin.consOrderIso_apply","module":"Mathlib.Order.Fin.Tuple","initialProofState":"n : Nat\nα : Fin (HAdd.hAdd n 1) → Type u_2\ninst✝ : (i : Fin (HAdd.hAdd n 1)) → LE (α i)\nf : Prod (α 0) ((i : Fin n) → α i.succ)\ni : Fin (HAdd.hAdd n 1)\n⊢ Eq ((Fin.consOrderIso α) f i) (Fin.cons f.1 f.2 i)","decl":"/-- Order isomorphism between tuples of length `n + 1` and pairs of an element and a tuple of length\n`n` given by separating out the first element of the tuple.\n\nThis is `Fin.cons` as an `OrderIso`. -/\n@[simps!, simps toEquiv]\ndef consOrderIso (α : Fin (n + 1) → Type*) [∀ i, LE (α i)] :\n    α 0 × (∀ i, α (succ i)) ≃o ∀ i, α i where\n  toEquiv := consEquiv α\n  map_rel_iff' := forall_iff_succ\n\n"}
{"name":"Fin.consOrderIso_toEquiv","module":"Mathlib.Order.Fin.Tuple","initialProofState":"n : Nat\nα : Fin (HAdd.hAdd n 1) → Type u_2\ninst✝ : (i : Fin (HAdd.hAdd n 1)) → LE (α i)\n⊢ Eq (Fin.consOrderIso α).toEquiv (Fin.consEquiv α)","decl":"/-- Order isomorphism between tuples of length `n + 1` and pairs of an element and a tuple of length\n`n` given by separating out the first element of the tuple.\n\nThis is `Fin.cons` as an `OrderIso`. -/\n@[simps!, simps toEquiv]\ndef consOrderIso (α : Fin (n + 1) → Type*) [∀ i, LE (α i)] :\n    α 0 × (∀ i, α (succ i)) ≃o ∀ i, α i where\n  toEquiv := consEquiv α\n  map_rel_iff' := forall_iff_succ\n\n"}
{"name":"Fin.snocOrderIso_symm_apply","module":"Mathlib.Order.Fin.Tuple","initialProofState":"n : Nat\nα : Fin (HAdd.hAdd n 1) → Type u_2\ninst✝ : (i : Fin (HAdd.hAdd n 1)) → LE (α i)\nf : (i : Fin (HAdd.hAdd n 1)) → α i\n⊢ Eq ((RelIso.symm (Fin.snocOrderIso α)) f) { fst := f (Fin.last n), snd := Fin.init f }","decl":"/-- Order isomorphism between tuples of length `n + 1` and pairs of an element and a tuple of length\n`n` given by separating out the last element of the tuple.\n\nThis is `Fin.snoc` as an `OrderIso`. -/\n@[simps!, simps toEquiv]\ndef snocOrderIso (α : Fin (n + 1) → Type*) [∀ i, LE (α i)] :\n    α (last n) × (∀ i, α (castSucc i)) ≃o ∀ i, α i where\n  toEquiv := snocEquiv α\n  map_rel_iff' := by simp [Pi.le_def, Prod.le_def, forall_iff_castSucc]\n\n"}
{"name":"Fin.snocOrderIso_apply","module":"Mathlib.Order.Fin.Tuple","initialProofState":"n : Nat\nα : Fin (HAdd.hAdd n 1) → Type u_2\ninst✝ : (i : Fin (HAdd.hAdd n 1)) → LE (α i)\nf : Prod (α (Fin.last n)) ((i : Fin n) → α i.castSucc)\nx✝ : Fin (HAdd.hAdd n 1)\n⊢ Eq ((Fin.snocOrderIso α) f x✝) (Fin.snoc f.2 f.1 x✝)","decl":"/-- Order isomorphism between tuples of length `n + 1` and pairs of an element and a tuple of length\n`n` given by separating out the last element of the tuple.\n\nThis is `Fin.snoc` as an `OrderIso`. -/\n@[simps!, simps toEquiv]\ndef snocOrderIso (α : Fin (n + 1) → Type*) [∀ i, LE (α i)] :\n    α (last n) × (∀ i, α (castSucc i)) ≃o ∀ i, α i where\n  toEquiv := snocEquiv α\n  map_rel_iff' := by simp [Pi.le_def, Prod.le_def, forall_iff_castSucc]\n\n"}
{"name":"Fin.snocOrderIso_toEquiv","module":"Mathlib.Order.Fin.Tuple","initialProofState":"n : Nat\nα : Fin (HAdd.hAdd n 1) → Type u_2\ninst✝ : (i : Fin (HAdd.hAdd n 1)) → LE (α i)\n⊢ Eq (Fin.snocOrderIso α).toEquiv (Fin.snocEquiv α)","decl":"/-- Order isomorphism between tuples of length `n + 1` and pairs of an element and a tuple of length\n`n` given by separating out the last element of the tuple.\n\nThis is `Fin.snoc` as an `OrderIso`. -/\n@[simps!, simps toEquiv]\ndef snocOrderIso (α : Fin (n + 1) → Type*) [∀ i, LE (α i)] :\n    α (last n) × (∀ i, α (castSucc i)) ≃o ∀ i, α i where\n  toEquiv := snocEquiv α\n  map_rel_iff' := by simp [Pi.le_def, Prod.le_def, forall_iff_castSucc]\n\n"}
{"name":"Fin.insertNthOrderIso_apply","module":"Mathlib.Order.Fin.Tuple","initialProofState":"n : Nat\nα : Fin (HAdd.hAdd n 1) → Type u_2\ninst✝ : (i : Fin (HAdd.hAdd n 1)) → LE (α i)\np : Fin (HAdd.hAdd n 1)\nf : Prod (α p) ((i : Fin n) → α (p.succAbove i))\nj : Fin (HAdd.hAdd n 1)\n⊢ Eq ((Fin.insertNthOrderIso α p) f j) (p.insertNth f.1 f.2 j)","decl":"/-- Order isomorphism between tuples of length `n + 1` and pairs of an element and a tuple of length\n`n` given by separating out the `p`-th element of the tuple.\n\nThis is `Fin.insertNth` as an `OrderIso`. -/\n@[simps!, simps toEquiv]\ndef insertNthOrderIso (α : Fin (n + 1) → Type*) [∀ i, LE (α i)] (p : Fin (n + 1)) :\n    α p × (∀ i, α (p.succAbove i)) ≃o ∀ i, α i where\n  toEquiv := insertNthEquiv α p\n  map_rel_iff' := by simp [Pi.le_def, Prod.le_def, p.forall_iff_succAbove]\n\n"}
{"name":"Fin.insertNthOrderIso_toEquiv","module":"Mathlib.Order.Fin.Tuple","initialProofState":"n : Nat\nα : Fin (HAdd.hAdd n 1) → Type u_2\ninst✝ : (i : Fin (HAdd.hAdd n 1)) → LE (α i)\np : Fin (HAdd.hAdd n 1)\n⊢ Eq (Fin.insertNthOrderIso α p).toEquiv (Fin.insertNthEquiv α p)","decl":"/-- Order isomorphism between tuples of length `n + 1` and pairs of an element and a tuple of length\n`n` given by separating out the `p`-th element of the tuple.\n\nThis is `Fin.insertNth` as an `OrderIso`. -/\n@[simps!, simps toEquiv]\ndef insertNthOrderIso (α : Fin (n + 1) → Type*) [∀ i, LE (α i)] (p : Fin (n + 1)) :\n    α p × (∀ i, α (p.succAbove i)) ≃o ∀ i, α i where\n  toEquiv := insertNthEquiv α p\n  map_rel_iff' := by simp [Pi.le_def, Prod.le_def, p.forall_iff_succAbove]\n\n"}
{"name":"Fin.insertNthOrderIso_symm_apply","module":"Mathlib.Order.Fin.Tuple","initialProofState":"n : Nat\nα : Fin (HAdd.hAdd n 1) → Type u_2\ninst✝ : (i : Fin (HAdd.hAdd n 1)) → LE (α i)\np : Fin (HAdd.hAdd n 1)\nf : (i : Fin (HAdd.hAdd n 1)) → α i\n⊢ Eq ((RelIso.symm (Fin.insertNthOrderIso α p)) f) { fst := f p, snd := p.removeNth f }","decl":"/-- Order isomorphism between tuples of length `n + 1` and pairs of an element and a tuple of length\n`n` given by separating out the `p`-th element of the tuple.\n\nThis is `Fin.insertNth` as an `OrderIso`. -/\n@[simps!, simps toEquiv]\ndef insertNthOrderIso (α : Fin (n + 1) → Type*) [∀ i, LE (α i)] (p : Fin (n + 1)) :\n    α p × (∀ i, α (p.succAbove i)) ≃o ∀ i, α i where\n  toEquiv := insertNthEquiv α p\n  map_rel_iff' := by simp [Pi.le_def, Prod.le_def, p.forall_iff_succAbove]\n\n"}
{"name":"Fin.insertNthOrderIso_zero","module":"Mathlib.Order.Fin.Tuple","initialProofState":"n : Nat\nα : Fin (HAdd.hAdd n 1) → Type u_2\ninst✝ : (i : Fin (HAdd.hAdd n 1)) → LE (α i)\n⊢ Eq (Fin.insertNthOrderIso α 0) (Fin.consOrderIso α)","decl":"@[simp] lemma insertNthOrderIso_zero (α : Fin (n + 1) → Type*) [∀ i, LE (α i)] :\n    insertNthOrderIso α 0 = consOrderIso α := by ext; simp [insertNthOrderIso]\n\n"}
{"name":"Fin.insertNthOrderIso_last","module":"Mathlib.Order.Fin.Tuple","initialProofState":"n : Nat\nα : Type u_2\ninst✝ : LE α\n⊢ Eq (Fin.insertNthOrderIso (fun x => α) (Fin.last n)) (Fin.snocOrderIso fun x => α)","decl":"/-- Note this lemma can only be written about non-dependent tuples as `insertNth (last n) = snoc` is\nnot a definitional equality. -/\n@[simp] lemma insertNthOrderIso_last (n : ℕ) (α : Type*) [LE α] :\n    insertNthOrderIso (fun _ ↦ α) (last n) = snocOrderIso (fun _ ↦ α) := by ext; simp\n\n"}
{"name":"finSuccAboveOrderIso_apply","module":"Mathlib.Order.Fin.Tuple","initialProofState":"n : Nat\np : Fin (HAdd.hAdd n 1)\ni : Fin n\n⊢ Eq ((finSuccAboveOrderIso p) i) ⟨p.succAbove i, ⋯⟩","decl":"lemma finSuccAboveOrderIso_apply (p : Fin (n + 1)) (i : Fin n) :\n    finSuccAboveOrderIso p i = ⟨p.succAbove i, p.succAbove_ne i⟩ := rfl\n\n"}
{"name":"finSuccAboveOrderIso_symm_apply_last","module":"Mathlib.Order.Fin.Tuple","initialProofState":"n : Nat\nx : Subtype fun x => Ne x (Fin.last n)\n⊢ Eq ((finSuccAboveOrderIso (Fin.last n)).symm x) ((↑x).castLT ⋯)","decl":"lemma finSuccAboveOrderIso_symm_apply_last (x : { x : Fin (n + 1) // x ≠ Fin.last n }) :\n    (finSuccAboveOrderIso (Fin.last n)).symm x = Fin.castLT x.1 (Fin.val_lt_last x.2) := by\n  rw [← Option.some_inj]\n  simpa [finSuccAboveOrderIso, finSuccAboveEquiv, OrderIso.symm]\n    using finSuccEquiv'_last_apply x.property\n\n"}
{"name":"finSuccAboveOrderIso_symm_apply_ne_last","module":"Mathlib.Order.Fin.Tuple","initialProofState":"n : Nat\np : Fin (HAdd.hAdd n 1)\nh : Ne p (Fin.last n)\nx : Subtype fun x => Ne x p\n⊢ Eq ((finSuccAboveEquiv p).symm x) ((p.castLT ⋯).predAbove ↑x)","decl":"lemma finSuccAboveOrderIso_symm_apply_ne_last {p : Fin (n + 1)} (h : p ≠ Fin.last n)\n    (x : { x : Fin (n + 1) // x ≠ p }) :\n    (finSuccAboveEquiv p).symm x = (p.castLT (Fin.val_lt_last h)).predAbove x := by\n  rw [← Option.some_inj]\n  simpa [finSuccAboveEquiv, OrderIso.symm] using finSuccEquiv'_ne_last_apply h x.property\n\n"}
{"name":"Fin.castLEOrderIso_symm_apply","module":"Mathlib.Order.Fin.Tuple","initialProofState":"n m : Nat\nh : LE.le n m\ni : Subtype fun i => LT.lt (↑i) n\n⊢ Eq ((RelIso.symm (Fin.castLEOrderIso h)) i) ⟨↑↑i, ⋯⟩","decl":"/-- Promote a `Fin n` into a larger `Fin m`, as a subtype where the underlying\nvalues are retained. This is the `OrderIso` version of `Fin.castLE`. -/\n@[simps apply symm_apply]\ndef Fin.castLEOrderIso {n m : ℕ} (h : n ≤ m) : Fin n ≃o { i : Fin m // (i : ℕ) < n } where\n  toFun i := ⟨Fin.castLE h i, by simp⟩\n  invFun i := ⟨i, i.prop⟩\n  left_inv _ := by simp\n  right_inv _ := by simp\n  map_rel_iff' := by simp [(strictMono_castLE h).le_iff_le]\n"}
{"name":"Fin.castLEOrderIso_apply","module":"Mathlib.Order.Fin.Tuple","initialProofState":"n m : Nat\nh : LE.le n m\ni : Fin n\n⊢ Eq ((Fin.castLEOrderIso h) i) ⟨Fin.castLE h i, ⋯⟩","decl":"/-- Promote a `Fin n` into a larger `Fin m`, as a subtype where the underlying\nvalues are retained. This is the `OrderIso` version of `Fin.castLE`. -/\n@[simps apply symm_apply]\ndef Fin.castLEOrderIso {n m : ℕ} (h : n ≤ m) : Fin n ≃o { i : Fin m // (i : ℕ) < n } where\n  toFun i := ⟨Fin.castLE h i, by simp⟩\n  invFun i := ⟨i, i.prop⟩\n  left_inv _ := by simp\n  right_inv _ := by simp\n  map_rel_iff' := by simp [(strictMono_castLE h).le_iff_le]\n"}
