{"name":"CategoryTheory.StructuredArrow.functor_map","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Functor","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nT : CategoryTheory.Functor C D\nX‚úù Y‚úù : Opposite D\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.StructuredArrow.functor T).map f) (CategoryTheory.StructuredArrow.map f.unop)","decl":"/-- The structured arrow category `StructuredArrow d T` depends on the chosen domain `d : D` in a\nfunctorial way, inducing a functor `D·µí·µñ ‚•§ Cat`. -/\n@[simps]\ndef functor (T : C ‚•§ D) : D·µí·µñ ‚•§ Cat where\n  obj d := .of <| StructuredArrow d.unop T\n  map f := map f.unop\n  map_id d := Functor.ext (fun ‚ü®_, _, _‚ü© => by simp [CostructuredArrow.map, Comma.mapRight])\n  map_comp f g := Functor.ext (fun _ => by simp [CostructuredArrow.map, Comma.mapRight])\n\n"}
{"name":"CategoryTheory.StructuredArrow.functor_obj","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Functor","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nT : CategoryTheory.Functor C D\nd : Opposite D\n‚ä¢ Eq ((CategoryTheory.StructuredArrow.functor T).obj d) (CategoryTheory.Cat.of (CategoryTheory.StructuredArrow (Opposite.unop d) T))","decl":"/-- The structured arrow category `StructuredArrow d T` depends on the chosen domain `d : D` in a\nfunctorial way, inducing a functor `D·µí·µñ ‚•§ Cat`. -/\n@[simps]\ndef functor (T : C ‚•§ D) : D·µí·µñ ‚•§ Cat where\n  obj d := .of <| StructuredArrow d.unop T\n  map f := map f.unop\n  map_id d := Functor.ext (fun ‚ü®_, _, _‚ü© => by simp [CostructuredArrow.map, Comma.mapRight])\n  map_comp f g := Functor.ext (fun _ => by simp [CostructuredArrow.map, Comma.mapRight])\n\n"}
{"name":"CategoryTheory.CostructuredArrow.functor_obj","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Functor","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nT : CategoryTheory.Functor C D\nd : D\n‚ä¢ Eq ((CategoryTheory.CostructuredArrow.functor T).obj d) (CategoryTheory.Cat.of (CategoryTheory.CostructuredArrow T d))","decl":"/-- The costructured arrow category `CostructuredArrow T d` depends on the chosen codomain `d : D`\nin a functorial way, inducing a functor `D ‚•§ Cat`. -/\n@[simps]\ndef functor (T : C ‚•§ D) : D ‚•§ Cat where\n  obj d := .of <| CostructuredArrow T d\n  map f := CostructuredArrow.map f\n  map_id d := Functor.ext (fun ‚ü®_, _, _‚ü© => by simp [CostructuredArrow.map, Comma.mapRight])\n  map_comp f g := Functor.ext (fun _ => by simp [CostructuredArrow.map, Comma.mapRight])\n\n"}
{"name":"CategoryTheory.CostructuredArrow.functor_map","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Functor","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nT : CategoryTheory.Functor C D\nX‚úù Y‚úù : D\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.CostructuredArrow.functor T).map f) (CategoryTheory.CostructuredArrow.map f)","decl":"/-- The costructured arrow category `CostructuredArrow T d` depends on the chosen codomain `d : D`\nin a functorial way, inducing a functor `D ‚•§ Cat`. -/\n@[simps]\ndef functor (T : C ‚•§ D) : D ‚•§ Cat where\n  obj d := .of <| CostructuredArrow T d\n  map f := CostructuredArrow.map f\n  map_id d := Functor.ext (fun ‚ü®_, _, _‚ü© => by simp [CostructuredArrow.map, Comma.mapRight])\n  map_comp f g := Functor.ext (fun _ => by simp [CostructuredArrow.map, Comma.mapRight])\n\n"}
{"name":"CategoryTheory.CostructuredArrow.grothendieckPrecompFunctorToComma_map_right","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Functor","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nL : CategoryTheory.Functor C D\nR : CategoryTheory.Functor E D\nX‚úù Y‚úù : CategoryTheory.Grothendieck (R.comp (CategoryTheory.CostructuredArrow.functor L))\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.CostructuredArrow.grothendieckPrecompFunctorToComma L R).map f).right f.base","decl":"/-- The functor used to establish the equivalence `grothendieckPrecompFunctorEquivalence` between\nthe Grothendieck construction on `CostructuredArrow.functor` and the comma category. -/\n@[simps]\ndef grothendieckPrecompFunctorToComma : Grothendieck (R ‚ãô functor L) ‚•§ Comma L R where\n  obj P := ‚ü®P.fiber.left, P.base, P.fiber.hom‚ü©\n  map f := ‚ü®f.fiber.left, f.base, by simp‚ü©\n\n"}
{"name":"CategoryTheory.CostructuredArrow.grothendieckPrecompFunctorToComma_obj_right","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Functor","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nL : CategoryTheory.Functor C D\nR : CategoryTheory.Functor E D\nP : CategoryTheory.Grothendieck (R.comp (CategoryTheory.CostructuredArrow.functor L))\n‚ä¢ Eq ((CategoryTheory.CostructuredArrow.grothendieckPrecompFunctorToComma L R).obj P).right P.base","decl":"/-- The functor used to establish the equivalence `grothendieckPrecompFunctorEquivalence` between\nthe Grothendieck construction on `CostructuredArrow.functor` and the comma category. -/\n@[simps]\ndef grothendieckPrecompFunctorToComma : Grothendieck (R ‚ãô functor L) ‚•§ Comma L R where\n  obj P := ‚ü®P.fiber.left, P.base, P.fiber.hom‚ü©\n  map f := ‚ü®f.fiber.left, f.base, by simp‚ü©\n\n"}
{"name":"CategoryTheory.CostructuredArrow.grothendieckPrecompFunctorToComma_obj_left","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Functor","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nL : CategoryTheory.Functor C D\nR : CategoryTheory.Functor E D\nP : CategoryTheory.Grothendieck (R.comp (CategoryTheory.CostructuredArrow.functor L))\n‚ä¢ Eq ((CategoryTheory.CostructuredArrow.grothendieckPrecompFunctorToComma L R).obj P).left P.fiber.left","decl":"/-- The functor used to establish the equivalence `grothendieckPrecompFunctorEquivalence` between\nthe Grothendieck construction on `CostructuredArrow.functor` and the comma category. -/\n@[simps]\ndef grothendieckPrecompFunctorToComma : Grothendieck (R ‚ãô functor L) ‚•§ Comma L R where\n  obj P := ‚ü®P.fiber.left, P.base, P.fiber.hom‚ü©\n  map f := ‚ü®f.fiber.left, f.base, by simp‚ü©\n\n"}
{"name":"CategoryTheory.CostructuredArrow.grothendieckPrecompFunctorToComma_obj_hom","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Functor","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nL : CategoryTheory.Functor C D\nR : CategoryTheory.Functor E D\nP : CategoryTheory.Grothendieck (R.comp (CategoryTheory.CostructuredArrow.functor L))\n‚ä¢ Eq ((CategoryTheory.CostructuredArrow.grothendieckPrecompFunctorToComma L R).obj P).hom P.fiber.hom","decl":"/-- The functor used to establish the equivalence `grothendieckPrecompFunctorEquivalence` between\nthe Grothendieck construction on `CostructuredArrow.functor` and the comma category. -/\n@[simps]\ndef grothendieckPrecompFunctorToComma : Grothendieck (R ‚ãô functor L) ‚•§ Comma L R where\n  obj P := ‚ü®P.fiber.left, P.base, P.fiber.hom‚ü©\n  map f := ‚ü®f.fiber.left, f.base, by simp‚ü©\n\n"}
{"name":"CategoryTheory.CostructuredArrow.grothendieckPrecompFunctorToComma_map_left","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Functor","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nL : CategoryTheory.Functor C D\nR : CategoryTheory.Functor E D\nX‚úù Y‚úù : CategoryTheory.Grothendieck (R.comp (CategoryTheory.CostructuredArrow.functor L))\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.CostructuredArrow.grothendieckPrecompFunctorToComma L R).map f).left f.fiber.left","decl":"/-- The functor used to establish the equivalence `grothendieckPrecompFunctorEquivalence` between\nthe Grothendieck construction on `CostructuredArrow.functor` and the comma category. -/\n@[simps]\ndef grothendieckPrecompFunctorToComma : Grothendieck (R ‚ãô functor L) ‚•§ Comma L R where\n  obj P := ‚ü®P.fiber.left, P.base, P.fiber.hom‚ü©\n  map f := ‚ü®f.fiber.left, f.base, by simp‚ü©\n\n"}
{"name":"CategoryTheory.CostructuredArrow.ŒπCompGrothendieckPrecompFunctorToCommaCompFst_hom_app","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Functor","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nL : CategoryTheory.Functor C D\nR : CategoryTheory.Functor E D\nX‚úù : E\nX : ‚Üë((R.comp (CategoryTheory.CostructuredArrow.functor L)).obj X‚úù)\n‚ä¢ Eq ((CategoryTheory.CostructuredArrow.ŒπCompGrothendieckPrecompFunctorToCommaCompFst L R X‚úù).hom.app X) (CategoryTheory.CategoryStruct.id X.left)","decl":"/-- Fibers of `grothendieckPrecompFunctorToComma L R`, composed with `Comma.fst L R`, are isomorphic\nto the projection `proj L (R.obj X)`. -/\n@[simps!]\ndef ŒπCompGrothendieckPrecompFunctorToCommaCompFst (X : E) :\n    Grothendieck.Œπ (R ‚ãô functor L) X ‚ãô grothendieckPrecompFunctorToComma L R ‚ãô Comma.fst _ _ ‚âÖ\n    proj L (R.obj X) :=\n  NatIso.ofComponents (fun X => Iso.refl _) (fun _ => by simp)\n\n"}
{"name":"CategoryTheory.CostructuredArrow.ŒπCompGrothendieckPrecompFunctorToCommaCompFst_inv_app","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Functor","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nL : CategoryTheory.Functor C D\nR : CategoryTheory.Functor E D\nX‚úù : E\nX : ‚Üë((R.comp (CategoryTheory.CostructuredArrow.functor L)).obj X‚úù)\n‚ä¢ Eq ((CategoryTheory.CostructuredArrow.ŒπCompGrothendieckPrecompFunctorToCommaCompFst L R X‚úù).inv.app X) (CategoryTheory.CategoryStruct.id X.left)","decl":"/-- Fibers of `grothendieckPrecompFunctorToComma L R`, composed with `Comma.fst L R`, are isomorphic\nto the projection `proj L (R.obj X)`. -/\n@[simps!]\ndef ŒπCompGrothendieckPrecompFunctorToCommaCompFst (X : E) :\n    Grothendieck.Œπ (R ‚ãô functor L) X ‚ãô grothendieckPrecompFunctorToComma L R ‚ãô Comma.fst _ _ ‚âÖ\n    proj L (R.obj X) :=\n  NatIso.ofComponents (fun X => Iso.refl _) (fun _ => by simp)\n\n"}
{"name":"CategoryTheory.CostructuredArrow.commaToGrothendieckPrecompFunctor_obj_fiber","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Functor","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nL : CategoryTheory.Functor C D\nR : CategoryTheory.Functor E D\nX : CategoryTheory.Comma L R\n‚ä¢ Eq ((CategoryTheory.CostructuredArrow.commaToGrothendieckPrecompFunctor L R).obj X).fiber (CategoryTheory.CostructuredArrow.mk X.hom)","decl":"/-- The inverse functor used to establish the equivalence `grothendieckPrecompFunctorEquivalence`\nbetween the Grothendieck construction on `CostructuredArrow.functor` and the comma category. -/\n@[simps]\ndef commaToGrothendieckPrecompFunctor : Comma L R ‚•§ Grothendieck (R ‚ãô functor L) where\n  obj X := ‚ü®X.right, mk X.hom‚ü©\n  map f := ‚ü®f.right, homMk f.left‚ü©\n  map_id X := Grothendieck.ext _ _ rfl (by simp)\n  map_comp f g := Grothendieck.ext _ _ rfl (by simp)\n\n"}
{"name":"CategoryTheory.CostructuredArrow.commaToGrothendieckPrecompFunctor_map_base","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Functor","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nL : CategoryTheory.Functor C D\nR : CategoryTheory.Functor E D\nX‚úù Y‚úù : CategoryTheory.Comma L R\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.CostructuredArrow.commaToGrothendieckPrecompFunctor L R).map f).base f.right","decl":"/-- The inverse functor used to establish the equivalence `grothendieckPrecompFunctorEquivalence`\nbetween the Grothendieck construction on `CostructuredArrow.functor` and the comma category. -/\n@[simps]\ndef commaToGrothendieckPrecompFunctor : Comma L R ‚•§ Grothendieck (R ‚ãô functor L) where\n  obj X := ‚ü®X.right, mk X.hom‚ü©\n  map f := ‚ü®f.right, homMk f.left‚ü©\n  map_id X := Grothendieck.ext _ _ rfl (by simp)\n  map_comp f g := Grothendieck.ext _ _ rfl (by simp)\n\n"}
{"name":"CategoryTheory.CostructuredArrow.commaToGrothendieckPrecompFunctor_map_fiber","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Functor","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nL : CategoryTheory.Functor C D\nR : CategoryTheory.Functor E D\nX‚úù Y‚úù : CategoryTheory.Comma L R\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.CostructuredArrow.commaToGrothendieckPrecompFunctor L R).map f).fiber (CategoryTheory.CostructuredArrow.homMk f.left ‚ãØ)","decl":"/-- The inverse functor used to establish the equivalence `grothendieckPrecompFunctorEquivalence`\nbetween the Grothendieck construction on `CostructuredArrow.functor` and the comma category. -/\n@[simps]\ndef commaToGrothendieckPrecompFunctor : Comma L R ‚•§ Grothendieck (R ‚ãô functor L) where\n  obj X := ‚ü®X.right, mk X.hom‚ü©\n  map f := ‚ü®f.right, homMk f.left‚ü©\n  map_id X := Grothendieck.ext _ _ rfl (by simp)\n  map_comp f g := Grothendieck.ext _ _ rfl (by simp)\n\n"}
{"name":"CategoryTheory.CostructuredArrow.commaToGrothendieckPrecompFunctor_obj_base","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Functor","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nL : CategoryTheory.Functor C D\nR : CategoryTheory.Functor E D\nX : CategoryTheory.Comma L R\n‚ä¢ Eq ((CategoryTheory.CostructuredArrow.commaToGrothendieckPrecompFunctor L R).obj X).base X.right","decl":"/-- The inverse functor used to establish the equivalence `grothendieckPrecompFunctorEquivalence`\nbetween the Grothendieck construction on `CostructuredArrow.functor` and the comma category. -/\n@[simps]\ndef commaToGrothendieckPrecompFunctor : Comma L R ‚•§ Grothendieck (R ‚ãô functor L) where\n  obj X := ‚ü®X.right, mk X.hom‚ü©\n  map f := ‚ü®f.right, homMk f.left‚ü©\n  map_id X := Grothendieck.ext _ _ rfl (by simp)\n  map_comp f g := Grothendieck.ext _ _ rfl (by simp)\n\n"}
{"name":"CategoryTheory.CostructuredArrow.grothendieckPrecompFunctorEquivalence_inverse","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Functor","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nL : CategoryTheory.Functor C D\nR : CategoryTheory.Functor E D\n‚ä¢ Eq (CategoryTheory.CostructuredArrow.grothendieckPrecompFunctorEquivalence L R).inverse (CategoryTheory.CostructuredArrow.commaToGrothendieckPrecompFunctor L R)","decl":"/-- For `L : C ‚•§ D`, taking the Grothendieck construction of `CostructuredArrow.functor L`\nprecomposed with another functor `R : E ‚•§ D` results in a category which is equivalent to\nthe comma category `Comma L R`. -/\n@[simps]\ndef grothendieckPrecompFunctorEquivalence : Grothendieck (R ‚ãô functor L) ‚âå Comma L R where\n  functor := grothendieckPrecompFunctorToComma _ _\n  inverse := commaToGrothendieckPrecompFunctor _ _\n  unitIso := NatIso.ofComponents (fun _ => Iso.refl _)\n  counitIso := NatIso.ofComponents (fun _ => Iso.refl _)\n\n"}
{"name":"CategoryTheory.CostructuredArrow.grothendieckPrecompFunctorEquivalence_counitIso","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Functor","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nL : CategoryTheory.Functor C D\nR : CategoryTheory.Functor E D\n‚ä¢ Eq (CategoryTheory.CostructuredArrow.grothendieckPrecompFunctorEquivalence L R).counitIso (CategoryTheory.NatIso.ofComponents (fun x => CategoryTheory.Iso.refl (((CategoryTheory.CostructuredArrow.commaToGrothendieckPrecompFunctor L R).comp (CategoryTheory.CostructuredArrow.grothendieckPrecompFunctorToComma L R)).obj x)) ‚ãØ)","decl":"/-- For `L : C ‚•§ D`, taking the Grothendieck construction of `CostructuredArrow.functor L`\nprecomposed with another functor `R : E ‚•§ D` results in a category which is equivalent to\nthe comma category `Comma L R`. -/\n@[simps]\ndef grothendieckPrecompFunctorEquivalence : Grothendieck (R ‚ãô functor L) ‚âå Comma L R where\n  functor := grothendieckPrecompFunctorToComma _ _\n  inverse := commaToGrothendieckPrecompFunctor _ _\n  unitIso := NatIso.ofComponents (fun _ => Iso.refl _)\n  counitIso := NatIso.ofComponents (fun _ => Iso.refl _)\n\n"}
{"name":"CategoryTheory.CostructuredArrow.grothendieckPrecompFunctorEquivalence_functor","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Functor","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nL : CategoryTheory.Functor C D\nR : CategoryTheory.Functor E D\n‚ä¢ Eq (CategoryTheory.CostructuredArrow.grothendieckPrecompFunctorEquivalence L R).functor (CategoryTheory.CostructuredArrow.grothendieckPrecompFunctorToComma L R)","decl":"/-- For `L : C ‚•§ D`, taking the Grothendieck construction of `CostructuredArrow.functor L`\nprecomposed with another functor `R : E ‚•§ D` results in a category which is equivalent to\nthe comma category `Comma L R`. -/\n@[simps]\ndef grothendieckPrecompFunctorEquivalence : Grothendieck (R ‚ãô functor L) ‚âå Comma L R where\n  functor := grothendieckPrecompFunctorToComma _ _\n  inverse := commaToGrothendieckPrecompFunctor _ _\n  unitIso := NatIso.ofComponents (fun _ => Iso.refl _)\n  counitIso := NatIso.ofComponents (fun _ => Iso.refl _)\n\n"}
{"name":"CategoryTheory.CostructuredArrow.grothendieckPrecompFunctorEquivalence_unitIso","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Functor","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nL : CategoryTheory.Functor C D\nR : CategoryTheory.Functor E D\n‚ä¢ Eq (CategoryTheory.CostructuredArrow.grothendieckPrecompFunctorEquivalence L R).unitIso (CategoryTheory.NatIso.ofComponents (fun x => CategoryTheory.Iso.refl ((CategoryTheory.Functor.id (CategoryTheory.Grothendieck (R.comp (CategoryTheory.CostructuredArrow.functor L)))).obj x)) ‚ãØ)","decl":"/-- For `L : C ‚•§ D`, taking the Grothendieck construction of `CostructuredArrow.functor L`\nprecomposed with another functor `R : E ‚•§ D` results in a category which is equivalent to\nthe comma category `Comma L R`. -/\n@[simps]\ndef grothendieckPrecompFunctorEquivalence : Grothendieck (R ‚ãô functor L) ‚âå Comma L R where\n  functor := grothendieckPrecompFunctorToComma _ _\n  inverse := commaToGrothendieckPrecompFunctor _ _\n  unitIso := NatIso.ofComponents (fun _ => Iso.refl _)\n  counitIso := NatIso.ofComponents (fun _ => Iso.refl _)\n\n"}
{"name":"CategoryTheory.CostructuredArrow.grothendieckProj_map","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Functor","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nL : CategoryTheory.Functor C D\nX‚úù Y‚úù : CategoryTheory.Grothendieck (CategoryTheory.CostructuredArrow.functor L)\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.CostructuredArrow.grothendieckProj L).map f) f.fiber.left","decl":"/-- The functor projecting out the domain of arrows from the Grothendieck construction on\ncostructured arrows. -/\n@[simps!]\ndef grothendieckProj : Grothendieck (functor L) ‚•§ C :=\n  grothendieckPrecompFunctorToComma L (ùü≠ _) ‚ãô Comma.fst _ _\n\n"}
{"name":"CategoryTheory.CostructuredArrow.grothendieckProj_obj","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Functor","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nL : CategoryTheory.Functor C D\nX : CategoryTheory.Grothendieck (CategoryTheory.CostructuredArrow.functor L)\n‚ä¢ Eq ((CategoryTheory.CostructuredArrow.grothendieckProj L).obj X) X.fiber.left","decl":"/-- The functor projecting out the domain of arrows from the Grothendieck construction on\ncostructured arrows. -/\n@[simps!]\ndef grothendieckProj : Grothendieck (functor L) ‚•§ C :=\n  grothendieckPrecompFunctorToComma L (ùü≠ _) ‚ãô Comma.fst _ _\n\n"}
{"name":"CategoryTheory.CostructuredArrow.ŒπCompGrothendieckProj_inv_app","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Functor","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nL : CategoryTheory.Functor C D\nX‚úù : D\nX : ‚Üë(((CategoryTheory.Functor.id D).comp (CategoryTheory.CostructuredArrow.functor L)).obj X‚úù)\n‚ä¢ Eq ((CategoryTheory.CostructuredArrow.ŒπCompGrothendieckProj L X‚úù).inv.app X) (CategoryTheory.CategoryStruct.id X.left)","decl":"/-- Fibers of `grothendieckProj L` are isomorphic to the projection `proj L X`. -/\n@[simps!]\ndef ŒπCompGrothendieckProj (X : D) :\n    Grothendieck.Œπ (functor L) X ‚ãô grothendieckProj L ‚âÖ proj L X :=\n  ŒπCompGrothendieckPrecompFunctorToCommaCompFst L (ùü≠ _) X\n\n"}
{"name":"CategoryTheory.CostructuredArrow.ŒπCompGrothendieckProj_hom_app","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Functor","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nL : CategoryTheory.Functor C D\nX‚úù : D\nX : ‚Üë(((CategoryTheory.Functor.id D).comp (CategoryTheory.CostructuredArrow.functor L)).obj X‚úù)\n‚ä¢ Eq ((CategoryTheory.CostructuredArrow.ŒπCompGrothendieckProj L X‚úù).hom.app X) (CategoryTheory.CategoryStruct.id X.left)","decl":"/-- Fibers of `grothendieckProj L` are isomorphic to the projection `proj L X`. -/\n@[simps!]\ndef ŒπCompGrothendieckProj (X : D) :\n    Grothendieck.Œπ (functor L) X ‚ãô grothendieckProj L ‚âÖ proj L X :=\n  ŒπCompGrothendieckPrecompFunctorToCommaCompFst L (ùü≠ _) X\n\n"}
{"name":"CategoryTheory.CostructuredArrow.mapCompŒπCompGrothendieckProj_hom_app","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Functor","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nL : CategoryTheory.Functor C D\nX‚úù Y : D\nf : Quiver.Hom X‚úù Y\nX : CategoryTheory.CostructuredArrow L X‚úù\n‚ä¢ Eq ((CategoryTheory.CostructuredArrow.mapCompŒπCompGrothendieckProj L f).hom.app X) (CategoryTheory.CategoryStruct.id X.left)","decl":"/-- Functors between costructured arrow categories induced by morphisms in the base category\ncomposed with fibers of `grothendieckProj L` are isomorphic to the projection `proj L X`. -/\n@[simps!]\ndef mapCompŒπCompGrothendieckProj {X Y : D} (f : X ‚ü∂ Y) :\n    CostructuredArrow.map f ‚ãô Grothendieck.Œπ (functor L) Y ‚ãô grothendieckProj L ‚âÖ proj L X :=\n  isoWhiskerLeft (CostructuredArrow.map f) (ŒπCompGrothendieckPrecompFunctorToCommaCompFst L (ùü≠ _) Y)\n\n"}
{"name":"CategoryTheory.CostructuredArrow.mapCompŒπCompGrothendieckProj_inv_app","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Functor","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nL : CategoryTheory.Functor C D\nX‚úù Y : D\nf : Quiver.Hom X‚úù Y\nX : CategoryTheory.CostructuredArrow L X‚úù\n‚ä¢ Eq ((CategoryTheory.CostructuredArrow.mapCompŒπCompGrothendieckProj L f).inv.app X) (CategoryTheory.CategoryStruct.id X.left)","decl":"/-- Functors between costructured arrow categories induced by morphisms in the base category\ncomposed with fibers of `grothendieckProj L` are isomorphic to the projection `proj L X`. -/\n@[simps!]\ndef mapCompŒπCompGrothendieckProj {X Y : D} (f : X ‚ü∂ Y) :\n    CostructuredArrow.map f ‚ãô Grothendieck.Œπ (functor L) Y ‚ãô grothendieckProj L ‚âÖ proj L X :=\n  isoWhiskerLeft (CostructuredArrow.map f) (ŒπCompGrothendieckPrecompFunctorToCommaCompFst L (ùü≠ _) Y)\n\n"}
