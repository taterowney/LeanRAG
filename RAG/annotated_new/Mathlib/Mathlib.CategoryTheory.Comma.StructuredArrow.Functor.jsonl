{"name":"CategoryTheory.StructuredArrow.functor_map","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Functor","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nT : CategoryTheory.Functor C D\nX✝ Y✝ : Opposite D\nf : Quiver.Hom X✝ Y✝\n⊢ Eq ((CategoryTheory.StructuredArrow.functor T).map f) (CategoryTheory.StructuredArrow.map f.unop)","decl":"/-- The structured arrow category `StructuredArrow d T` depends on the chosen domain `d : D` in a\nfunctorial way, inducing a functor `Dᵒᵖ ⥤ Cat`. -/\n@[simps]\ndef functor (T : C ⥤ D) : Dᵒᵖ ⥤ Cat where\n  obj d := .of <| StructuredArrow d.unop T\n  map f := map f.unop\n  map_id d := Functor.ext (fun ⟨_, _, _⟩ => by simp [CostructuredArrow.map, Comma.mapRight])\n  map_comp f g := Functor.ext (fun _ => by simp [CostructuredArrow.map, Comma.mapRight])\n\n"}
{"name":"CategoryTheory.StructuredArrow.functor_obj","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Functor","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nT : CategoryTheory.Functor C D\nd : Opposite D\n⊢ Eq ((CategoryTheory.StructuredArrow.functor T).obj d) (CategoryTheory.Cat.of (CategoryTheory.StructuredArrow (Opposite.unop d) T))","decl":"/-- The structured arrow category `StructuredArrow d T` depends on the chosen domain `d : D` in a\nfunctorial way, inducing a functor `Dᵒᵖ ⥤ Cat`. -/\n@[simps]\ndef functor (T : C ⥤ D) : Dᵒᵖ ⥤ Cat where\n  obj d := .of <| StructuredArrow d.unop T\n  map f := map f.unop\n  map_id d := Functor.ext (fun ⟨_, _, _⟩ => by simp [CostructuredArrow.map, Comma.mapRight])\n  map_comp f g := Functor.ext (fun _ => by simp [CostructuredArrow.map, Comma.mapRight])\n\n"}
{"name":"CategoryTheory.CostructuredArrow.functor_obj","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Functor","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nT : CategoryTheory.Functor C D\nd : D\n⊢ Eq ((CategoryTheory.CostructuredArrow.functor T).obj d) (CategoryTheory.Cat.of (CategoryTheory.CostructuredArrow T d))","decl":"/-- The costructured arrow category `CostructuredArrow T d` depends on the chosen codomain `d : D`\nin a functorial way, inducing a functor `D ⥤ Cat`. -/\n@[simps]\ndef functor (T : C ⥤ D) : D ⥤ Cat where\n  obj d := .of <| CostructuredArrow T d\n  map f := CostructuredArrow.map f\n  map_id d := Functor.ext (fun ⟨_, _, _⟩ => by simp [CostructuredArrow.map, Comma.mapRight])\n  map_comp f g := Functor.ext (fun _ => by simp [CostructuredArrow.map, Comma.mapRight])\n\n"}
{"name":"CategoryTheory.CostructuredArrow.functor_map","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Functor","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nT : CategoryTheory.Functor C D\nX✝ Y✝ : D\nf : Quiver.Hom X✝ Y✝\n⊢ Eq ((CategoryTheory.CostructuredArrow.functor T).map f) (CategoryTheory.CostructuredArrow.map f)","decl":"/-- The costructured arrow category `CostructuredArrow T d` depends on the chosen codomain `d : D`\nin a functorial way, inducing a functor `D ⥤ Cat`. -/\n@[simps]\ndef functor (T : C ⥤ D) : D ⥤ Cat where\n  obj d := .of <| CostructuredArrow T d\n  map f := CostructuredArrow.map f\n  map_id d := Functor.ext (fun ⟨_, _, _⟩ => by simp [CostructuredArrow.map, Comma.mapRight])\n  map_comp f g := Functor.ext (fun _ => by simp [CostructuredArrow.map, Comma.mapRight])\n\n"}
{"name":"CategoryTheory.CostructuredArrow.grothendieckPrecompFunctorToComma_map_right","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Functor","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nE : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} E\nL : CategoryTheory.Functor C D\nR : CategoryTheory.Functor E D\nX✝ Y✝ : CategoryTheory.Grothendieck (R.comp (CategoryTheory.CostructuredArrow.functor L))\nf : Quiver.Hom X✝ Y✝\n⊢ Eq ((CategoryTheory.CostructuredArrow.grothendieckPrecompFunctorToComma L R).map f).right f.base","decl":"/-- The functor used to establish the equivalence `grothendieckPrecompFunctorEquivalence` between\nthe Grothendieck construction on `CostructuredArrow.functor` and the comma category. -/\n@[simps]\ndef grothendieckPrecompFunctorToComma : Grothendieck (R ⋙ functor L) ⥤ Comma L R where\n  obj P := ⟨P.fiber.left, P.base, P.fiber.hom⟩\n  map f := ⟨f.fiber.left, f.base, by simp⟩\n\n"}
{"name":"CategoryTheory.CostructuredArrow.grothendieckPrecompFunctorToComma_obj_right","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Functor","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nE : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} E\nL : CategoryTheory.Functor C D\nR : CategoryTheory.Functor E D\nP : CategoryTheory.Grothendieck (R.comp (CategoryTheory.CostructuredArrow.functor L))\n⊢ Eq ((CategoryTheory.CostructuredArrow.grothendieckPrecompFunctorToComma L R).obj P).right P.base","decl":"/-- The functor used to establish the equivalence `grothendieckPrecompFunctorEquivalence` between\nthe Grothendieck construction on `CostructuredArrow.functor` and the comma category. -/\n@[simps]\ndef grothendieckPrecompFunctorToComma : Grothendieck (R ⋙ functor L) ⥤ Comma L R where\n  obj P := ⟨P.fiber.left, P.base, P.fiber.hom⟩\n  map f := ⟨f.fiber.left, f.base, by simp⟩\n\n"}
{"name":"CategoryTheory.CostructuredArrow.grothendieckPrecompFunctorToComma_obj_left","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Functor","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nE : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} E\nL : CategoryTheory.Functor C D\nR : CategoryTheory.Functor E D\nP : CategoryTheory.Grothendieck (R.comp (CategoryTheory.CostructuredArrow.functor L))\n⊢ Eq ((CategoryTheory.CostructuredArrow.grothendieckPrecompFunctorToComma L R).obj P).left P.fiber.left","decl":"/-- The functor used to establish the equivalence `grothendieckPrecompFunctorEquivalence` between\nthe Grothendieck construction on `CostructuredArrow.functor` and the comma category. -/\n@[simps]\ndef grothendieckPrecompFunctorToComma : Grothendieck (R ⋙ functor L) ⥤ Comma L R where\n  obj P := ⟨P.fiber.left, P.base, P.fiber.hom⟩\n  map f := ⟨f.fiber.left, f.base, by simp⟩\n\n"}
{"name":"CategoryTheory.CostructuredArrow.grothendieckPrecompFunctorToComma_obj_hom","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Functor","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nE : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} E\nL : CategoryTheory.Functor C D\nR : CategoryTheory.Functor E D\nP : CategoryTheory.Grothendieck (R.comp (CategoryTheory.CostructuredArrow.functor L))\n⊢ Eq ((CategoryTheory.CostructuredArrow.grothendieckPrecompFunctorToComma L R).obj P).hom P.fiber.hom","decl":"/-- The functor used to establish the equivalence `grothendieckPrecompFunctorEquivalence` between\nthe Grothendieck construction on `CostructuredArrow.functor` and the comma category. -/\n@[simps]\ndef grothendieckPrecompFunctorToComma : Grothendieck (R ⋙ functor L) ⥤ Comma L R where\n  obj P := ⟨P.fiber.left, P.base, P.fiber.hom⟩\n  map f := ⟨f.fiber.left, f.base, by simp⟩\n\n"}
{"name":"CategoryTheory.CostructuredArrow.grothendieckPrecompFunctorToComma_map_left","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Functor","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nE : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} E\nL : CategoryTheory.Functor C D\nR : CategoryTheory.Functor E D\nX✝ Y✝ : CategoryTheory.Grothendieck (R.comp (CategoryTheory.CostructuredArrow.functor L))\nf : Quiver.Hom X✝ Y✝\n⊢ Eq ((CategoryTheory.CostructuredArrow.grothendieckPrecompFunctorToComma L R).map f).left f.fiber.left","decl":"/-- The functor used to establish the equivalence `grothendieckPrecompFunctorEquivalence` between\nthe Grothendieck construction on `CostructuredArrow.functor` and the comma category. -/\n@[simps]\ndef grothendieckPrecompFunctorToComma : Grothendieck (R ⋙ functor L) ⥤ Comma L R where\n  obj P := ⟨P.fiber.left, P.base, P.fiber.hom⟩\n  map f := ⟨f.fiber.left, f.base, by simp⟩\n\n"}
{"name":"CategoryTheory.CostructuredArrow.ιCompGrothendieckPrecompFunctorToCommaCompFst_hom_app","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Functor","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nE : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} E\nL : CategoryTheory.Functor C D\nR : CategoryTheory.Functor E D\nX✝ : E\nX : ↑((R.comp (CategoryTheory.CostructuredArrow.functor L)).obj X✝)\n⊢ Eq ((CategoryTheory.CostructuredArrow.ιCompGrothendieckPrecompFunctorToCommaCompFst L R X✝).hom.app X) (CategoryTheory.CategoryStruct.id X.left)","decl":"/-- Fibers of `grothendieckPrecompFunctorToComma L R`, composed with `Comma.fst L R`, are isomorphic\nto the projection `proj L (R.obj X)`. -/\n@[simps!]\ndef ιCompGrothendieckPrecompFunctorToCommaCompFst (X : E) :\n    Grothendieck.ι (R ⋙ functor L) X ⋙ grothendieckPrecompFunctorToComma L R ⋙ Comma.fst _ _ ≅\n    proj L (R.obj X) :=\n  NatIso.ofComponents (fun X => Iso.refl _) (fun _ => by simp)\n\n"}
{"name":"CategoryTheory.CostructuredArrow.ιCompGrothendieckPrecompFunctorToCommaCompFst_inv_app","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Functor","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nE : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} E\nL : CategoryTheory.Functor C D\nR : CategoryTheory.Functor E D\nX✝ : E\nX : ↑((R.comp (CategoryTheory.CostructuredArrow.functor L)).obj X✝)\n⊢ Eq ((CategoryTheory.CostructuredArrow.ιCompGrothendieckPrecompFunctorToCommaCompFst L R X✝).inv.app X) (CategoryTheory.CategoryStruct.id X.left)","decl":"/-- Fibers of `grothendieckPrecompFunctorToComma L R`, composed with `Comma.fst L R`, are isomorphic\nto the projection `proj L (R.obj X)`. -/\n@[simps!]\ndef ιCompGrothendieckPrecompFunctorToCommaCompFst (X : E) :\n    Grothendieck.ι (R ⋙ functor L) X ⋙ grothendieckPrecompFunctorToComma L R ⋙ Comma.fst _ _ ≅\n    proj L (R.obj X) :=\n  NatIso.ofComponents (fun X => Iso.refl _) (fun _ => by simp)\n\n"}
{"name":"CategoryTheory.CostructuredArrow.commaToGrothendieckPrecompFunctor_obj_fiber","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Functor","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nE : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} E\nL : CategoryTheory.Functor C D\nR : CategoryTheory.Functor E D\nX : CategoryTheory.Comma L R\n⊢ Eq ((CategoryTheory.CostructuredArrow.commaToGrothendieckPrecompFunctor L R).obj X).fiber (CategoryTheory.CostructuredArrow.mk X.hom)","decl":"/-- The inverse functor used to establish the equivalence `grothendieckPrecompFunctorEquivalence`\nbetween the Grothendieck construction on `CostructuredArrow.functor` and the comma category. -/\n@[simps]\ndef commaToGrothendieckPrecompFunctor : Comma L R ⥤ Grothendieck (R ⋙ functor L) where\n  obj X := ⟨X.right, mk X.hom⟩\n  map f := ⟨f.right, homMk f.left⟩\n  map_id X := Grothendieck.ext _ _ rfl (by simp)\n  map_comp f g := Grothendieck.ext _ _ rfl (by simp)\n\n"}
{"name":"CategoryTheory.CostructuredArrow.commaToGrothendieckPrecompFunctor_map_base","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Functor","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nE : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} E\nL : CategoryTheory.Functor C D\nR : CategoryTheory.Functor E D\nX✝ Y✝ : CategoryTheory.Comma L R\nf : Quiver.Hom X✝ Y✝\n⊢ Eq ((CategoryTheory.CostructuredArrow.commaToGrothendieckPrecompFunctor L R).map f).base f.right","decl":"/-- The inverse functor used to establish the equivalence `grothendieckPrecompFunctorEquivalence`\nbetween the Grothendieck construction on `CostructuredArrow.functor` and the comma category. -/\n@[simps]\ndef commaToGrothendieckPrecompFunctor : Comma L R ⥤ Grothendieck (R ⋙ functor L) where\n  obj X := ⟨X.right, mk X.hom⟩\n  map f := ⟨f.right, homMk f.left⟩\n  map_id X := Grothendieck.ext _ _ rfl (by simp)\n  map_comp f g := Grothendieck.ext _ _ rfl (by simp)\n\n"}
{"name":"CategoryTheory.CostructuredArrow.commaToGrothendieckPrecompFunctor_map_fiber","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Functor","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nE : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} E\nL : CategoryTheory.Functor C D\nR : CategoryTheory.Functor E D\nX✝ Y✝ : CategoryTheory.Comma L R\nf : Quiver.Hom X✝ Y✝\n⊢ Eq ((CategoryTheory.CostructuredArrow.commaToGrothendieckPrecompFunctor L R).map f).fiber (CategoryTheory.CostructuredArrow.homMk f.left ⋯)","decl":"/-- The inverse functor used to establish the equivalence `grothendieckPrecompFunctorEquivalence`\nbetween the Grothendieck construction on `CostructuredArrow.functor` and the comma category. -/\n@[simps]\ndef commaToGrothendieckPrecompFunctor : Comma L R ⥤ Grothendieck (R ⋙ functor L) where\n  obj X := ⟨X.right, mk X.hom⟩\n  map f := ⟨f.right, homMk f.left⟩\n  map_id X := Grothendieck.ext _ _ rfl (by simp)\n  map_comp f g := Grothendieck.ext _ _ rfl (by simp)\n\n"}
{"name":"CategoryTheory.CostructuredArrow.commaToGrothendieckPrecompFunctor_obj_base","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Functor","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nE : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} E\nL : CategoryTheory.Functor C D\nR : CategoryTheory.Functor E D\nX : CategoryTheory.Comma L R\n⊢ Eq ((CategoryTheory.CostructuredArrow.commaToGrothendieckPrecompFunctor L R).obj X).base X.right","decl":"/-- The inverse functor used to establish the equivalence `grothendieckPrecompFunctorEquivalence`\nbetween the Grothendieck construction on `CostructuredArrow.functor` and the comma category. -/\n@[simps]\ndef commaToGrothendieckPrecompFunctor : Comma L R ⥤ Grothendieck (R ⋙ functor L) where\n  obj X := ⟨X.right, mk X.hom⟩\n  map f := ⟨f.right, homMk f.left⟩\n  map_id X := Grothendieck.ext _ _ rfl (by simp)\n  map_comp f g := Grothendieck.ext _ _ rfl (by simp)\n\n"}
{"name":"CategoryTheory.CostructuredArrow.grothendieckPrecompFunctorEquivalence_inverse","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Functor","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nE : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} E\nL : CategoryTheory.Functor C D\nR : CategoryTheory.Functor E D\n⊢ Eq (CategoryTheory.CostructuredArrow.grothendieckPrecompFunctorEquivalence L R).inverse (CategoryTheory.CostructuredArrow.commaToGrothendieckPrecompFunctor L R)","decl":"/-- For `L : C ⥤ D`, taking the Grothendieck construction of `CostructuredArrow.functor L`\nprecomposed with another functor `R : E ⥤ D` results in a category which is equivalent to\nthe comma category `Comma L R`. -/\n@[simps]\ndef grothendieckPrecompFunctorEquivalence : Grothendieck (R ⋙ functor L) ≌ Comma L R where\n  functor := grothendieckPrecompFunctorToComma _ _\n  inverse := commaToGrothendieckPrecompFunctor _ _\n  unitIso := NatIso.ofComponents (fun _ => Iso.refl _)\n  counitIso := NatIso.ofComponents (fun _ => Iso.refl _)\n\n"}
{"name":"CategoryTheory.CostructuredArrow.grothendieckPrecompFunctorEquivalence_counitIso","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Functor","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nE : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} E\nL : CategoryTheory.Functor C D\nR : CategoryTheory.Functor E D\n⊢ Eq (CategoryTheory.CostructuredArrow.grothendieckPrecompFunctorEquivalence L R).counitIso (CategoryTheory.NatIso.ofComponents (fun x => CategoryTheory.Iso.refl (((CategoryTheory.CostructuredArrow.commaToGrothendieckPrecompFunctor L R).comp (CategoryTheory.CostructuredArrow.grothendieckPrecompFunctorToComma L R)).obj x)) ⋯)","decl":"/-- For `L : C ⥤ D`, taking the Grothendieck construction of `CostructuredArrow.functor L`\nprecomposed with another functor `R : E ⥤ D` results in a category which is equivalent to\nthe comma category `Comma L R`. -/\n@[simps]\ndef grothendieckPrecompFunctorEquivalence : Grothendieck (R ⋙ functor L) ≌ Comma L R where\n  functor := grothendieckPrecompFunctorToComma _ _\n  inverse := commaToGrothendieckPrecompFunctor _ _\n  unitIso := NatIso.ofComponents (fun _ => Iso.refl _)\n  counitIso := NatIso.ofComponents (fun _ => Iso.refl _)\n\n"}
{"name":"CategoryTheory.CostructuredArrow.grothendieckPrecompFunctorEquivalence_functor","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Functor","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nE : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} E\nL : CategoryTheory.Functor C D\nR : CategoryTheory.Functor E D\n⊢ Eq (CategoryTheory.CostructuredArrow.grothendieckPrecompFunctorEquivalence L R).functor (CategoryTheory.CostructuredArrow.grothendieckPrecompFunctorToComma L R)","decl":"/-- For `L : C ⥤ D`, taking the Grothendieck construction of `CostructuredArrow.functor L`\nprecomposed with another functor `R : E ⥤ D` results in a category which is equivalent to\nthe comma category `Comma L R`. -/\n@[simps]\ndef grothendieckPrecompFunctorEquivalence : Grothendieck (R ⋙ functor L) ≌ Comma L R where\n  functor := grothendieckPrecompFunctorToComma _ _\n  inverse := commaToGrothendieckPrecompFunctor _ _\n  unitIso := NatIso.ofComponents (fun _ => Iso.refl _)\n  counitIso := NatIso.ofComponents (fun _ => Iso.refl _)\n\n"}
{"name":"CategoryTheory.CostructuredArrow.grothendieckPrecompFunctorEquivalence_unitIso","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Functor","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nE : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} E\nL : CategoryTheory.Functor C D\nR : CategoryTheory.Functor E D\n⊢ Eq (CategoryTheory.CostructuredArrow.grothendieckPrecompFunctorEquivalence L R).unitIso (CategoryTheory.NatIso.ofComponents (fun x => CategoryTheory.Iso.refl ((CategoryTheory.Functor.id (CategoryTheory.Grothendieck (R.comp (CategoryTheory.CostructuredArrow.functor L)))).obj x)) ⋯)","decl":"/-- For `L : C ⥤ D`, taking the Grothendieck construction of `CostructuredArrow.functor L`\nprecomposed with another functor `R : E ⥤ D` results in a category which is equivalent to\nthe comma category `Comma L R`. -/\n@[simps]\ndef grothendieckPrecompFunctorEquivalence : Grothendieck (R ⋙ functor L) ≌ Comma L R where\n  functor := grothendieckPrecompFunctorToComma _ _\n  inverse := commaToGrothendieckPrecompFunctor _ _\n  unitIso := NatIso.ofComponents (fun _ => Iso.refl _)\n  counitIso := NatIso.ofComponents (fun _ => Iso.refl _)\n\n"}
{"name":"CategoryTheory.CostructuredArrow.grothendieckProj_map","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Functor","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nL : CategoryTheory.Functor C D\nX✝ Y✝ : CategoryTheory.Grothendieck (CategoryTheory.CostructuredArrow.functor L)\nf : Quiver.Hom X✝ Y✝\n⊢ Eq ((CategoryTheory.CostructuredArrow.grothendieckProj L).map f) f.fiber.left","decl":"/-- The functor projecting out the domain of arrows from the Grothendieck construction on\ncostructured arrows. -/\n@[simps!]\ndef grothendieckProj : Grothendieck (functor L) ⥤ C :=\n  grothendieckPrecompFunctorToComma L (𝟭 _) ⋙ Comma.fst _ _\n\n"}
{"name":"CategoryTheory.CostructuredArrow.grothendieckProj_obj","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Functor","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nL : CategoryTheory.Functor C D\nX : CategoryTheory.Grothendieck (CategoryTheory.CostructuredArrow.functor L)\n⊢ Eq ((CategoryTheory.CostructuredArrow.grothendieckProj L).obj X) X.fiber.left","decl":"/-- The functor projecting out the domain of arrows from the Grothendieck construction on\ncostructured arrows. -/\n@[simps!]\ndef grothendieckProj : Grothendieck (functor L) ⥤ C :=\n  grothendieckPrecompFunctorToComma L (𝟭 _) ⋙ Comma.fst _ _\n\n"}
{"name":"CategoryTheory.CostructuredArrow.ιCompGrothendieckProj_inv_app","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Functor","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nL : CategoryTheory.Functor C D\nX✝ : D\nX : ↑(((CategoryTheory.Functor.id D).comp (CategoryTheory.CostructuredArrow.functor L)).obj X✝)\n⊢ Eq ((CategoryTheory.CostructuredArrow.ιCompGrothendieckProj L X✝).inv.app X) (CategoryTheory.CategoryStruct.id X.left)","decl":"/-- Fibers of `grothendieckProj L` are isomorphic to the projection `proj L X`. -/\n@[simps!]\ndef ιCompGrothendieckProj (X : D) :\n    Grothendieck.ι (functor L) X ⋙ grothendieckProj L ≅ proj L X :=\n  ιCompGrothendieckPrecompFunctorToCommaCompFst L (𝟭 _) X\n\n"}
{"name":"CategoryTheory.CostructuredArrow.ιCompGrothendieckProj_hom_app","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Functor","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nL : CategoryTheory.Functor C D\nX✝ : D\nX : ↑(((CategoryTheory.Functor.id D).comp (CategoryTheory.CostructuredArrow.functor L)).obj X✝)\n⊢ Eq ((CategoryTheory.CostructuredArrow.ιCompGrothendieckProj L X✝).hom.app X) (CategoryTheory.CategoryStruct.id X.left)","decl":"/-- Fibers of `grothendieckProj L` are isomorphic to the projection `proj L X`. -/\n@[simps!]\ndef ιCompGrothendieckProj (X : D) :\n    Grothendieck.ι (functor L) X ⋙ grothendieckProj L ≅ proj L X :=\n  ιCompGrothendieckPrecompFunctorToCommaCompFst L (𝟭 _) X\n\n"}
{"name":"CategoryTheory.CostructuredArrow.mapCompιCompGrothendieckProj_hom_app","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Functor","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nL : CategoryTheory.Functor C D\nX✝ Y : D\nf : Quiver.Hom X✝ Y\nX : CategoryTheory.CostructuredArrow L X✝\n⊢ Eq ((CategoryTheory.CostructuredArrow.mapCompιCompGrothendieckProj L f).hom.app X) (CategoryTheory.CategoryStruct.id X.left)","decl":"/-- Functors between costructured arrow categories induced by morphisms in the base category\ncomposed with fibers of `grothendieckProj L` are isomorphic to the projection `proj L X`. -/\n@[simps!]\ndef mapCompιCompGrothendieckProj {X Y : D} (f : X ⟶ Y) :\n    CostructuredArrow.map f ⋙ Grothendieck.ι (functor L) Y ⋙ grothendieckProj L ≅ proj L X :=\n  isoWhiskerLeft (CostructuredArrow.map f) (ιCompGrothendieckPrecompFunctorToCommaCompFst L (𝟭 _) Y)\n\n"}
{"name":"CategoryTheory.CostructuredArrow.mapCompιCompGrothendieckProj_inv_app","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Functor","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nL : CategoryTheory.Functor C D\nX✝ Y : D\nf : Quiver.Hom X✝ Y\nX : CategoryTheory.CostructuredArrow L X✝\n⊢ Eq ((CategoryTheory.CostructuredArrow.mapCompιCompGrothendieckProj L f).inv.app X) (CategoryTheory.CategoryStruct.id X.left)","decl":"/-- Functors between costructured arrow categories induced by morphisms in the base category\ncomposed with fibers of `grothendieckProj L` are isomorphic to the projection `proj L X`. -/\n@[simps!]\ndef mapCompιCompGrothendieckProj {X Y : D} (f : X ⟶ Y) :\n    CostructuredArrow.map f ⋙ Grothendieck.ι (functor L) Y ⋙ grothendieckProj L ≅ proj L X :=\n  isoWhiskerLeft (CostructuredArrow.map f) (ιCompGrothendieckPrecompFunctorToCommaCompFst L (𝟭 _) Y)\n\n"}
