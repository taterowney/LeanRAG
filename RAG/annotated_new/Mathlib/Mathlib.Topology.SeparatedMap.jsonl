{"name":"Topology.IsEmbedding.toPullbackDiag","module":"Mathlib.Topology.SeparatedMap","initialProofState":"X : Type u_1\nY : Sort u_2\ninst‚úù : TopologicalSpace X\nf : X ‚Üí Y\n‚ä¢ Topology.IsEmbedding (toPullbackDiag f)","decl":"protected lemma Topology.IsEmbedding.toPullbackDiag (f : X ‚Üí Y) : IsEmbedding (toPullbackDiag f) :=\n  .mk' _ (injective_toPullbackDiag f) fun x ‚Ü¶ by\n    rw [toPullbackDiag, nhds_induced, Filter.comap_comap, nhds_prod_eq, Filter.comap_prod]\n    erw [Filter.comap_id, inf_idem]\n\n"}
{"name":"embedding_toPullbackDiag","module":"Mathlib.Topology.SeparatedMap","initialProofState":"X : Type u_1\nY : Sort u_2\ninst‚úù : TopologicalSpace X\nf : X ‚Üí Y\n‚ä¢ Topology.IsEmbedding (toPullbackDiag f)","decl":"@[deprecated (since := \"2024-10-26\")]\nalias embedding_toPullbackDiag := IsEmbedding.toPullbackDiag\n\n"}
{"name":"Continuous.mapPullback","module":"Mathlib.Topology.SeparatedMap","initialProofState":"X‚ÇÅ : Type u_1\nX‚ÇÇ : Type u_2\nY‚ÇÅ : Sort u_3\nY‚ÇÇ : Sort u_4\nZ‚ÇÅ : Type u_5\nZ‚ÇÇ : Type u_6\ninst‚úù¬≥ : TopologicalSpace X‚ÇÅ\ninst‚úù¬≤ : TopologicalSpace X‚ÇÇ\ninst‚úù¬π : TopologicalSpace Z‚ÇÅ\ninst‚úù : TopologicalSpace Z‚ÇÇ\nf‚ÇÅ : X‚ÇÅ ‚Üí Y‚ÇÅ\ng‚ÇÅ : Z‚ÇÅ ‚Üí Y‚ÇÅ\nf‚ÇÇ : X‚ÇÇ ‚Üí Y‚ÇÇ\ng‚ÇÇ : Z‚ÇÇ ‚Üí Y‚ÇÇ\nmapX : X‚ÇÅ ‚Üí X‚ÇÇ\ncontX : Continuous mapX\nmapY : Y‚ÇÅ ‚Üí Y‚ÇÇ\nmapZ : Z‚ÇÅ ‚Üí Z‚ÇÇ\ncontZ : Continuous mapZ\ncommX : Eq (Function.comp f‚ÇÇ mapX) (Function.comp mapY f‚ÇÅ)\ncommZ : Eq (Function.comp g‚ÇÇ mapZ) (Function.comp mapY g‚ÇÅ)\n‚ä¢ Continuous (Function.mapPullback mapX mapY mapZ commX commZ)","decl":"lemma Continuous.mapPullback {X‚ÇÅ X‚ÇÇ Y‚ÇÅ Y‚ÇÇ Z‚ÇÅ Z‚ÇÇ}\n    [TopologicalSpace X‚ÇÅ] [TopologicalSpace X‚ÇÇ] [TopologicalSpace Z‚ÇÅ] [TopologicalSpace Z‚ÇÇ]\n    {f‚ÇÅ : X‚ÇÅ ‚Üí Y‚ÇÅ} {g‚ÇÅ : Z‚ÇÅ ‚Üí Y‚ÇÅ} {f‚ÇÇ : X‚ÇÇ ‚Üí Y‚ÇÇ} {g‚ÇÇ : Z‚ÇÇ ‚Üí Y‚ÇÇ}\n    {mapX : X‚ÇÅ ‚Üí X‚ÇÇ} (contX : Continuous mapX) {mapY : Y‚ÇÅ ‚Üí Y‚ÇÇ}\n    {mapZ : Z‚ÇÅ ‚Üí Z‚ÇÇ} (contZ : Continuous mapZ)\n    {commX : f‚ÇÇ ‚àò mapX = mapY ‚àò f‚ÇÅ} {commZ : g‚ÇÇ ‚àò mapZ = mapY ‚àò g‚ÇÅ} :\n    Continuous (Function.mapPullback mapX mapY mapZ commX commZ) := by\n  refine continuous_induced_rng.mpr (continuous_prod_mk.mpr ‚ü®?_, ?_‚ü©) <;>\n  apply_rules [continuous_fst, continuous_snd, continuous_subtype_val, Continuous.comp]\n\n"}
{"name":"t2space_iff_isSeparatedMap","module":"Mathlib.Topology.SeparatedMap","initialProofState":"X : Type u_1\nY : Sort u_2\ninst‚úù : TopologicalSpace X\ny : Y\n‚ä¢ Iff (T2Space X) (IsSeparatedMap fun x => y)","decl":"lemma t2space_iff_isSeparatedMap (y : Y) : T2Space X ‚Üî IsSeparatedMap fun _ : X ‚Ü¶ y :=\n  ‚ü®fun ‚ü®t2‚ü© _ _ _ hne ‚Ü¶ t2 hne, fun sep ‚Ü¶ ‚ü®fun x‚ÇÅ x‚ÇÇ hne ‚Ü¶ sep x‚ÇÅ x‚ÇÇ rfl hne‚ü©‚ü©\n\n"}
{"name":"T2Space.isSeparatedMap","module":"Mathlib.Topology.SeparatedMap","initialProofState":"X : Type u_1\nY : Sort u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : T2Space X\nf : X ‚Üí Y\n‚ä¢ IsSeparatedMap f","decl":"lemma T2Space.isSeparatedMap [T2Space X] (f : X ‚Üí Y) : IsSeparatedMap f := fun _ _ _ ‚Ü¶ t2_separation\n\n"}
{"name":"Function.Injective.isSeparatedMap","module":"Mathlib.Topology.SeparatedMap","initialProofState":"X : Type u_1\nY : Sort u_2\ninst‚úù : TopologicalSpace X\nf : X ‚Üí Y\ninj : Function.Injective f\n‚ä¢ IsSeparatedMap f","decl":"lemma Function.Injective.isSeparatedMap {f : X ‚Üí Y} (inj : f.Injective) : IsSeparatedMap f :=\n  fun _ _ he hne ‚Ü¶ (hne (inj he)).elim\n\n"}
{"name":"isSeparatedMap_iff_disjoint_nhds","module":"Mathlib.Topology.SeparatedMap","initialProofState":"X : Type u_1\nY : Sort u_2\ninst‚úù : TopologicalSpace X\nf : X ‚Üí Y\n‚ä¢ Iff (IsSeparatedMap f) (‚àÄ (x‚ÇÅ x‚ÇÇ : X), Eq (f x‚ÇÅ) (f x‚ÇÇ) ‚Üí Ne x‚ÇÅ x‚ÇÇ ‚Üí Disjoint (nhds x‚ÇÅ) (nhds x‚ÇÇ))","decl":"lemma isSeparatedMap_iff_disjoint_nhds {f : X ‚Üí Y} : IsSeparatedMap f ‚Üî\n    ‚àÄ x‚ÇÅ x‚ÇÇ, f x‚ÇÅ = f x‚ÇÇ ‚Üí x‚ÇÅ ‚â† x‚ÇÇ ‚Üí Disjoint (ùìù x‚ÇÅ) (ùìù x‚ÇÇ) :=\n  forall‚ÇÉ_congr fun x x' _ ‚Ü¶ by simp only [(nhds_basis_opens x).disjoint_iff (nhds_basis_opens x'),\n    exists_prop, ‚Üê exists_and_left, and_assoc, and_comm, and_left_comm]\n\n"}
{"name":"isSeparatedMap_iff_nhds","module":"Mathlib.Topology.SeparatedMap","initialProofState":"X : Type u_1\nY : Sort u_2\ninst‚úù : TopologicalSpace X\nf : X ‚Üí Y\n‚ä¢ Iff (IsSeparatedMap f) (‚àÄ (x‚ÇÅ x‚ÇÇ : X), Eq (f x‚ÇÅ) (f x‚ÇÇ) ‚Üí Ne x‚ÇÅ x‚ÇÇ ‚Üí Exists fun s‚ÇÅ => And (Membership.mem (nhds x‚ÇÅ) s‚ÇÅ) (Exists fun s‚ÇÇ => And (Membership.mem (nhds x‚ÇÇ) s‚ÇÇ) (Disjoint s‚ÇÅ s‚ÇÇ)))","decl":"lemma isSeparatedMap_iff_nhds {f : X ‚Üí Y} : IsSeparatedMap f ‚Üî\n    ‚àÄ x‚ÇÅ x‚ÇÇ, f x‚ÇÅ = f x‚ÇÇ ‚Üí x‚ÇÅ ‚â† x‚ÇÇ ‚Üí ‚àÉ s‚ÇÅ ‚àà ùìù x‚ÇÅ, ‚àÉ s‚ÇÇ ‚àà ùìù x‚ÇÇ, Disjoint s‚ÇÅ s‚ÇÇ := by\n  simp_rw [isSeparatedMap_iff_disjoint_nhds, Filter.disjoint_iff]\n\n"}
{"name":"isSeparatedMap_iff_isClosed_diagonal","module":"Mathlib.Topology.SeparatedMap","initialProofState":"X : Type u_1\nY : Sort u_2\ninst‚úù : TopologicalSpace X\nf : X ‚Üí Y\n‚ä¢ Iff (IsSeparatedMap f) (IsClosed (Function.pullbackDiagonal f))","decl":"open Set Filter in\ntheorem isSeparatedMap_iff_isClosed_diagonal {f : X ‚Üí Y} :\n    IsSeparatedMap f ‚Üî IsClosed f.pullbackDiagonal := by\n  simp_rw [isSeparatedMap_iff_nhds, ‚Üê isOpen_compl_iff, isOpen_iff_mem_nhds,\n    Subtype.forall, Prod.forall, nhds_induced, nhds_prod_eq]\n  refine forall‚ÇÑ_congr fun x‚ÇÅ x‚ÇÇ _ _ ‚Ü¶ ‚ü®fun h ‚Ü¶ ?_, fun ‚ü®t, ht, t_sub‚ü© ‚Ü¶ ?_‚ü©\n  ¬∑ simp_rw [‚Üê Filter.disjoint_iff, ‚Üê compl_diagonal_mem_prod] at h\n    exact ‚ü®_, h, subset_rfl‚ü©\n  ¬∑ obtain ‚ü®s‚ÇÅ, h‚ÇÅ, s‚ÇÇ, h‚ÇÇ, s_sub‚ü© := mem_prod_iff.mp ht\n    exact ‚ü®s‚ÇÅ, h‚ÇÅ, s‚ÇÇ, h‚ÇÇ, disjoint_left.2 fun x h‚ÇÅ h‚ÇÇ ‚Ü¶ @t_sub ‚ü®(x, x), rfl‚ü© (s_sub ‚ü®h‚ÇÅ, h‚ÇÇ‚ü©) rfl‚ü©\n\n"}
{"name":"isSeparatedMap_iff_isClosedEmbedding","module":"Mathlib.Topology.SeparatedMap","initialProofState":"X : Type u_1\nY : Sort u_2\ninst‚úù : TopologicalSpace X\nf : X ‚Üí Y\n‚ä¢ Iff (IsSeparatedMap f) (Topology.IsClosedEmbedding (toPullbackDiag f))","decl":"theorem isSeparatedMap_iff_isClosedEmbedding {f : X ‚Üí Y} :\n    IsSeparatedMap f ‚Üî IsClosedEmbedding (toPullbackDiag f) := by\n  rw [isSeparatedMap_iff_isClosed_diagonal, ‚Üê range_toPullbackDiag]\n  exact ‚ü®fun h ‚Ü¶ ‚ü®.toPullbackDiag f, h‚ü©, fun h ‚Ü¶ h.isClosed_range‚ü©\n\n"}
{"name":"isSeparatedMap_iff_closedEmbedding","module":"Mathlib.Topology.SeparatedMap","initialProofState":"X : Type u_1\nY : Sort u_2\ninst‚úù : TopologicalSpace X\nf : X ‚Üí Y\n‚ä¢ Iff (IsSeparatedMap f) (Topology.IsClosedEmbedding (toPullbackDiag f))","decl":"@[deprecated (since := \"2024-10-20\")]\nalias isSeparatedMap_iff_closedEmbedding := isSeparatedMap_iff_isClosedEmbedding\n\n"}
{"name":"isSeparatedMap_iff_isClosedMap","module":"Mathlib.Topology.SeparatedMap","initialProofState":"X : Type u_1\nY : Sort u_2\ninst‚úù : TopologicalSpace X\nf : X ‚Üí Y\n‚ä¢ Iff (IsSeparatedMap f) (IsClosedMap (toPullbackDiag f))","decl":"theorem isSeparatedMap_iff_isClosedMap {f : X ‚Üí Y} :\n    IsSeparatedMap f ‚Üî IsClosedMap (toPullbackDiag f) :=\n  isSeparatedMap_iff_isClosedEmbedding.trans\n    ‚ü®IsClosedEmbedding.isClosedMap, .of_continuous_injective_isClosedMap\n      (IsEmbedding.toPullbackDiag f).continuous (injective_toPullbackDiag f)‚ü©\n\n"}
{"name":"IsSeparatedMap.pullback","module":"Mathlib.Topology.SeparatedMap","initialProofState":"X : Type u_1\nY : Sort u_2\nA : Type u_3\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace A\nf : X ‚Üí Y\nsep : IsSeparatedMap f\ng : A ‚Üí Y\n‚ä¢ IsSeparatedMap Function.Pullback.snd","decl":"open Function.Pullback in\ntheorem IsSeparatedMap.pullback {f : X ‚Üí Y} (sep : IsSeparatedMap f) (g : A ‚Üí Y) :\n    IsSeparatedMap (@snd X Y A f g) := by\n  rw [isSeparatedMap_iff_isClosed_diagonal] at sep ‚ä¢\n  rw [‚Üê preimage_map_fst_pullbackDiagonal]\n  refine sep.preimage (Continuous.mapPullback ?_ ?_) <;>\n  apply_rules [continuous_fst, continuous_subtype_val, Continuous.comp]\n\n"}
{"name":"IsSeparatedMap.comp_left","module":"Mathlib.Topology.SeparatedMap","initialProofState":"X : Type u_2\nY : Sort u_3\ninst‚úù : TopologicalSpace X\nA : Sort u_1\nf : X ‚Üí Y\nsep : IsSeparatedMap f\ng : Y ‚Üí A\ninj : Function.Injective g\n‚ä¢ IsSeparatedMap (Function.comp g f)","decl":"theorem IsSeparatedMap.comp_left {A} {f : X ‚Üí Y} (sep : IsSeparatedMap f) {g : Y ‚Üí A}\n    (inj : g.Injective) : IsSeparatedMap (g ‚àò f) := fun x‚ÇÅ x‚ÇÇ he ‚Ü¶ sep x‚ÇÅ x‚ÇÇ (inj he)\n\n"}
{"name":"IsSeparatedMap.comp_right","module":"Mathlib.Topology.SeparatedMap","initialProofState":"X : Type u_1\nY : Sort u_2\nA : Type u_3\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace A\nf : X ‚Üí Y\nsep : IsSeparatedMap f\ng : A ‚Üí X\ncont : Continuous g\ninj : Function.Injective g\n‚ä¢ IsSeparatedMap (Function.comp f g)","decl":"theorem IsSeparatedMap.comp_right {f : X ‚Üí Y} (sep : IsSeparatedMap f) {g : A ‚Üí X}\n    (cont : Continuous g) (inj : g.Injective) : IsSeparatedMap (f ‚àò g) := by\n  rw [isSeparatedMap_iff_isClosed_diagonal] at sep ‚ä¢\n  rw [‚Üê inj.preimage_pullbackDiagonal]\n  exact sep.preimage (cont.mapPullback cont)\n\n"}
{"name":"Function.Injective.IsLocallyInjective","module":"Mathlib.Topology.SeparatedMap","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù : TopologicalSpace X\nf : X ‚Üí Y\ninj : Function.Injective f\n‚ä¢ IsLocallyInjective f","decl":"lemma Function.Injective.IsLocallyInjective {f : X ‚Üí Y} (inj : f.Injective) :\n    IsLocallyInjective f := fun _ ‚Ü¶ ‚ü®_, isOpen_univ, trivial, fun _ _ _ _ ‚Ü¶ @inj _ _‚ü©\n\n"}
{"name":"isLocallyInjective_iff_nhds","module":"Mathlib.Topology.SeparatedMap","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù : TopologicalSpace X\nf : X ‚Üí Y\n‚ä¢ Iff (IsLocallyInjective f) (‚àÄ (x : X), Exists fun U => And (Membership.mem (nhds x) U) (Set.InjOn f U))","decl":"lemma isLocallyInjective_iff_nhds {f : X ‚Üí Y} :\n    IsLocallyInjective f ‚Üî ‚àÄ x : X, ‚àÉ U ‚àà ùìù x, U.InjOn f := by\n  constructor <;> intro h x\n  ¬∑ obtain ‚ü®U, ho, hm, hi‚ü© := h x; exact ‚ü®U, ho.mem_nhds hm, hi‚ü©\n  ¬∑ obtain ‚ü®U, hn, hi‚ü© := h x\n    exact ‚ü®interior U, isOpen_interior, mem_interior_iff_mem_nhds.mpr hn, hi.mono interior_subset‚ü©\n\n"}
{"name":"isLocallyInjective_iff_isOpen_diagonal","module":"Mathlib.Topology.SeparatedMap","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù : TopologicalSpace X\nf : X ‚Üí Y\n‚ä¢ Iff (IsLocallyInjective f) (IsOpen (Function.pullbackDiagonal f))","decl":"theorem isLocallyInjective_iff_isOpen_diagonal {f : X ‚Üí Y} :\n    IsLocallyInjective f ‚Üî IsOpen f.pullbackDiagonal := by\n  simp_rw [isLocallyInjective_iff_nhds, isOpen_iff_mem_nhds,\n    Subtype.forall, Prod.forall, nhds_induced, nhds_prod_eq, Filter.mem_comap]\n  refine ‚ü®?_, fun h x ‚Ü¶ ?_‚ü©\n  ¬∑ rintro h x x' hx (rfl : x = x')\n    obtain ‚ü®U, hn, hi‚ü© := h x\n    exact ‚ü®_, Filter.prod_mem_prod hn hn, fun {p} hp ‚Ü¶ hi hp.1 hp.2 p.2‚ü©\n  ¬∑ obtain ‚ü®t, ht, t_sub‚ü© := h x x rfl rfl\n    obtain ‚ü®t‚ÇÅ, h‚ÇÅ, t‚ÇÇ, h‚ÇÇ, prod_sub‚ü© := Filter.mem_prod_iff.mp ht\n    exact ‚ü®t‚ÇÅ ‚à© t‚ÇÇ, Filter.inter_mem h‚ÇÅ h‚ÇÇ,\n      fun x‚ÇÅ h‚ÇÅ x‚ÇÇ h‚ÇÇ he ‚Ü¶ @t_sub ‚ü®(x‚ÇÅ, x‚ÇÇ), he‚ü© (prod_sub ‚ü®h‚ÇÅ.1, h‚ÇÇ.2‚ü©)‚ü©\n\n"}
{"name":"IsLocallyInjective_iff_isOpenEmbedding","module":"Mathlib.Topology.SeparatedMap","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù : TopologicalSpace X\nf : X ‚Üí Y\n‚ä¢ Iff (IsLocallyInjective f) (Topology.IsOpenEmbedding (toPullbackDiag f))","decl":"theorem IsLocallyInjective_iff_isOpenEmbedding {f : X ‚Üí Y} :\n    IsLocallyInjective f ‚Üî IsOpenEmbedding (toPullbackDiag f) := by\n  rw [isLocallyInjective_iff_isOpen_diagonal, ‚Üê range_toPullbackDiag]\n  exact ‚ü®fun h ‚Ü¶ ‚ü®.toPullbackDiag f, h‚ü©, fun h ‚Ü¶ h.isOpen_range‚ü©\n\n"}
{"name":"IsLocallyInjective_iff_openEmbedding","module":"Mathlib.Topology.SeparatedMap","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù : TopologicalSpace X\nf : X ‚Üí Y\n‚ä¢ Iff (IsLocallyInjective f) (Topology.IsOpenEmbedding (toPullbackDiag f))","decl":"@[deprecated (since := \"2024-10-18\")]\nalias IsLocallyInjective_iff_openEmbedding := IsLocallyInjective_iff_isOpenEmbedding\n\n"}
{"name":"isLocallyInjective_iff_isOpenMap","module":"Mathlib.Topology.SeparatedMap","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù : TopologicalSpace X\nf : X ‚Üí Y\n‚ä¢ Iff (IsLocallyInjective f) (IsOpenMap (toPullbackDiag f))","decl":"theorem isLocallyInjective_iff_isOpenMap {f : X ‚Üí Y} :\n    IsLocallyInjective f ‚Üî IsOpenMap (toPullbackDiag f) :=\n  IsLocallyInjective_iff_isOpenEmbedding.trans\n    ‚ü®IsOpenEmbedding.isOpenMap, .of_continuous_injective_isOpenMap\n      (IsEmbedding.toPullbackDiag f).continuous (injective_toPullbackDiag f)‚ü©\n\n"}
{"name":"discreteTopology_iff_locallyInjective","module":"Mathlib.Topology.SeparatedMap","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù : TopologicalSpace X\ny : Y\n‚ä¢ Iff (DiscreteTopology X) (IsLocallyInjective fun x => y)","decl":"theorem discreteTopology_iff_locallyInjective (y : Y) :\n    DiscreteTopology X ‚Üî IsLocallyInjective fun _ : X ‚Ü¶ y := by\n  rw [discreteTopology_iff_singleton_mem_nhds, isLocallyInjective_iff_nhds]\n  refine forall_congr' fun x ‚Ü¶ ‚ü®fun h ‚Ü¶ ‚ü®{x}, h, Set.injOn_singleton _ _‚ü©, fun ‚ü®U, hU, inj‚ü© ‚Ü¶ ?_‚ü©\n  convert hU; ext x'; refine ‚ü®?_, fun h ‚Ü¶ inj h (mem_of_mem_nhds hU) rfl‚ü©\n  rintro rfl; exact mem_of_mem_nhds hU\n\n"}
{"name":"IsLocallyInjective.comp_left","module":"Mathlib.Topology.SeparatedMap","initialProofState":"X : Type u_2\nY : Type u_3\ninst‚úù : TopologicalSpace X\nA : Type u_1\nf : X ‚Üí Y\nhf : IsLocallyInjective f\ng : Y ‚Üí A\nhg : Function.Injective g\n‚ä¢ IsLocallyInjective (Function.comp g f)","decl":"theorem IsLocallyInjective.comp_left {A} {f : X ‚Üí Y} (hf : IsLocallyInjective f) {g : Y ‚Üí A}\n    (hg : g.Injective) : IsLocallyInjective (g ‚àò f) :=\n  fun x ‚Ü¶ let ‚ü®U, hU, hx, inj‚ü© := hf x; ‚ü®U, hU, hx, hg.comp_injOn inj‚ü©\n\n"}
{"name":"IsLocallyInjective.comp_right","module":"Mathlib.Topology.SeparatedMap","initialProofState":"X : Type u_1\nY : Type u_2\nA : Type u_3\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace A\nf : X ‚Üí Y\nhf : IsLocallyInjective f\ng : A ‚Üí X\ncont : Continuous g\nhg : Function.Injective g\n‚ä¢ IsLocallyInjective (Function.comp f g)","decl":"theorem IsLocallyInjective.comp_right {f : X ‚Üí Y} (hf : IsLocallyInjective f) {g : A ‚Üí X}\n    (cont : Continuous g) (hg : g.Injective) : IsLocallyInjective (f ‚àò g) := by\n  rw [isLocallyInjective_iff_isOpen_diagonal] at hf ‚ä¢\n  rw [‚Üê hg.preimage_pullbackDiagonal]\n  apply hf.preimage (cont.mapPullback cont)\n\n"}
{"name":"IsSeparatedMap.isClosed_eqLocus","module":"Mathlib.Topology.SeparatedMap","initialProofState":"X : Type u_1\nY : Sort u_2\nA : Type u_3\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace A\nf : X ‚Üí Y\ng‚ÇÅ g‚ÇÇ : A ‚Üí X\nh‚ÇÅ : Continuous g‚ÇÅ\nh‚ÇÇ : Continuous g‚ÇÇ\nsep : IsSeparatedMap f\nhe : Eq (Function.comp f g‚ÇÅ) (Function.comp f g‚ÇÇ)\n‚ä¢ IsClosed (setOf fun a => Eq (g‚ÇÅ a) (g‚ÇÇ a))","decl":"theorem IsSeparatedMap.isClosed_eqLocus (sep : IsSeparatedMap f) (he : f ‚àò g‚ÇÅ = f ‚àò g‚ÇÇ) :\n    IsClosed {a | g‚ÇÅ a = g‚ÇÇ a} :=\n  let g : A ‚Üí f.Pullback f := fun a ‚Ü¶ ‚ü®‚ü®g‚ÇÅ a, g‚ÇÇ a‚ü©, congr_fun he a‚ü©\n  (isSeparatedMap_iff_isClosed_diagonal.mp sep).preimage (by fun_prop : Continuous g)\n\n"}
{"name":"IsLocallyInjective.isOpen_eqLocus","module":"Mathlib.Topology.SeparatedMap","initialProofState":"X : Type u_1\nY : Type u_2\nA : Type u_3\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace A\nf : X ‚Üí Y\ng‚ÇÅ g‚ÇÇ : A ‚Üí X\nh‚ÇÅ : Continuous g‚ÇÅ\nh‚ÇÇ : Continuous g‚ÇÇ\ninj : IsLocallyInjective f\nhe : Eq (Function.comp f g‚ÇÅ) (Function.comp f g‚ÇÇ)\n‚ä¢ IsOpen (setOf fun a => Eq (g‚ÇÅ a) (g‚ÇÇ a))","decl":"theorem IsLocallyInjective.isOpen_eqLocus (inj : IsLocallyInjective f) (he : f ‚àò g‚ÇÅ = f ‚àò g‚ÇÇ) :\n    IsOpen {a | g‚ÇÅ a = g‚ÇÇ a} :=\n  let g : A ‚Üí f.Pullback f := fun a ‚Ü¶ ‚ü®‚ü®g‚ÇÅ a, g‚ÇÇ a‚ü©, congr_fun he a‚ü©\n  (isLocallyInjective_iff_isOpen_diagonal.mp inj).preimage (by fun_prop : Continuous g)\n\n"}
{"name":"IsSeparatedMap.eq_of_comp_eq","module":"Mathlib.Topology.SeparatedMap","initialProofState":"X : Type u_1\nE : Type u_2\nA : Type u_3\ninst‚úù¬≤ : TopologicalSpace E\ninst‚úù¬π : TopologicalSpace A\np : E ‚Üí X\ng‚ÇÅ g‚ÇÇ : A ‚Üí E\nsep : IsSeparatedMap p\ninj : IsLocallyInjective p\ninst‚úù : PreconnectedSpace A\nh‚ÇÅ : Continuous g‚ÇÅ\nh‚ÇÇ : Continuous g‚ÇÇ\nhe : Eq (Function.comp p g‚ÇÅ) (Function.comp p g‚ÇÇ)\na : A\nha : Eq (g‚ÇÅ a) (g‚ÇÇ a)\n‚ä¢ Eq g‚ÇÅ g‚ÇÇ","decl":"/-- If `p` is a locally injective separated map, and `A` is a connected space,\n  then two lifts `g‚ÇÅ, g‚ÇÇ : A ‚Üí E` of a map `f : A ‚Üí X` are equal if they agree at one point. -/\ntheorem eq_of_comp_eq\n    [PreconnectedSpace A] (h‚ÇÅ : Continuous g‚ÇÅ) (h‚ÇÇ : Continuous g‚ÇÇ)\n    (he : p ‚àò g‚ÇÅ = p ‚àò g‚ÇÇ) (a : A) (ha : g‚ÇÅ a = g‚ÇÇ a) : g‚ÇÅ = g‚ÇÇ := funext fun a' ‚Ü¶ by\n  apply (IsClopen.eq_univ ‚ü®sep.isClosed_eqLocus h‚ÇÅ h‚ÇÇ he, inj.isOpen_eqLocus h‚ÇÅ h‚ÇÇ he‚ü© ‚ü®a, ha‚ü©).symm\n    ‚ñ∏ Set.mem_univ a'\n\n"}
{"name":"IsSeparatedMap.eqOn_of_comp_eqOn","module":"Mathlib.Topology.SeparatedMap","initialProofState":"X : Type u_1\nE : Type u_2\nA : Type u_3\ninst‚úù¬π : TopologicalSpace E\ninst‚úù : TopologicalSpace A\np : E ‚Üí X\ns : Set A\ng‚ÇÅ g‚ÇÇ : A ‚Üí E\nsep : IsSeparatedMap p\ninj : IsLocallyInjective p\nhs : IsPreconnected s\nh‚ÇÅ : ContinuousOn g‚ÇÅ s\nh‚ÇÇ : ContinuousOn g‚ÇÇ s\nhe : Set.EqOn (Function.comp p g‚ÇÅ) (Function.comp p g‚ÇÇ) s\na : A\nhas : Membership.mem s a\nha : Eq (g‚ÇÅ a) (g‚ÇÇ a)\n‚ä¢ Set.EqOn g‚ÇÅ g‚ÇÇ s","decl":"theorem eqOn_of_comp_eqOn (hs : IsPreconnected s) (h‚ÇÅ : ContinuousOn g‚ÇÅ s) (h‚ÇÇ : ContinuousOn g‚ÇÇ s)\n    (he : s.EqOn (p ‚àò g‚ÇÅ) (p ‚àò g‚ÇÇ)) {a : A} (has : a ‚àà s) (ha : g‚ÇÅ a = g‚ÇÇ a) : s.EqOn g‚ÇÅ g‚ÇÇ := by\n  rw [‚Üê Set.restrict_eq_restrict_iff] at he ‚ä¢\n  rw [continuousOn_iff_continuous_restrict] at h‚ÇÅ h‚ÇÇ\n  rw [isPreconnected_iff_preconnectedSpace] at hs\n  exact sep.eq_of_comp_eq inj h‚ÇÅ h‚ÇÇ he ‚ü®a, has‚ü© ha\n\n"}
{"name":"IsSeparatedMap.const_of_comp","module":"Mathlib.Topology.SeparatedMap","initialProofState":"X : Type u_1\nE : Type u_2\nA : Type u_3\ninst‚úù¬≤ : TopologicalSpace E\ninst‚úù¬π : TopologicalSpace A\np : E ‚Üí X\ng : A ‚Üí E\nsep : IsSeparatedMap p\ninj : IsLocallyInjective p\ninst‚úù : PreconnectedSpace A\ncont : Continuous g\nhe : ‚àÄ (a a' : A), Eq (p (g a)) (p (g a'))\na a' : A\n‚ä¢ Eq (g a) (g a')","decl":"theorem const_of_comp [PreconnectedSpace A] (cont : Continuous g)\n    (he : ‚àÄ a a', p (g a) = p (g a')) (a a') : g a = g a' :=\n  congr_fun (sep.eq_of_comp_eq inj cont continuous_const (funext fun a ‚Ü¶ he a a') a' rfl) a\n\n"}
{"name":"IsSeparatedMap.constOn_of_comp","module":"Mathlib.Topology.SeparatedMap","initialProofState":"X : Type u_1\nE : Type u_2\nA : Type u_3\ninst‚úù¬π : TopologicalSpace E\ninst‚úù : TopologicalSpace A\np : E ‚Üí X\ns : Set A\ng : A ‚Üí E\nsep : IsSeparatedMap p\ninj : IsLocallyInjective p\nhs : IsPreconnected s\ncont : ContinuousOn g s\nhe : ‚àÄ (a : A), Membership.mem s a ‚Üí ‚àÄ (a' : A), Membership.mem s a' ‚Üí Eq (p (g a)) (p (g a'))\na a' : A\nha : Membership.mem s a\nha' : Membership.mem s a'\n‚ä¢ Eq (g a) (g a')","decl":"theorem constOn_of_comp (hs : IsPreconnected s) (cont : ContinuousOn g s)\n    (he : ‚àÄ a ‚àà s, ‚àÄ a' ‚àà s, p (g a) = p (g a'))\n    {a a'} (ha : a ‚àà s) (ha' : a' ‚àà s) : g a = g a' :=\n  sep.eqOn_of_comp_eqOn inj hs cont continuous_const.continuousOn\n    (fun a ha ‚Ü¶ he a ha a' ha') ha' rfl ha\n\n"}
