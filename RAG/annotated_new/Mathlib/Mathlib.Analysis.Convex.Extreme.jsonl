{"name":"IsExtreme.refl","module":"Mathlib.Analysis.Convex.Extreme","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : OrderedSemiring 𝕜\ninst✝¹ : AddCommMonoid E\ninst✝ : SMul 𝕜 E\nA : Set E\n⊢ IsExtreme 𝕜 A A","decl":"@[refl]\nprotected theorem IsExtreme.refl (A : Set E) : IsExtreme 𝕜 A A :=\n  ⟨Subset.rfl, fun _ hx₁A _ hx₂A _ _ _ ↦ ⟨hx₁A, hx₂A⟩⟩\n\n"}
{"name":"IsExtreme.rfl","module":"Mathlib.Analysis.Convex.Extreme","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : OrderedSemiring 𝕜\ninst✝¹ : AddCommMonoid E\ninst✝ : SMul 𝕜 E\nA : Set E\n⊢ IsExtreme 𝕜 A A","decl":"protected theorem IsExtreme.rfl : IsExtreme 𝕜 A A :=\n  IsExtreme.refl 𝕜 A\n\n"}
{"name":"IsExtreme.trans","module":"Mathlib.Analysis.Convex.Extreme","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : OrderedSemiring 𝕜\ninst✝¹ : AddCommMonoid E\ninst✝ : SMul 𝕜 E\nA B C : Set E\nhAB : IsExtreme 𝕜 A B\nhBC : IsExtreme 𝕜 B C\n⊢ IsExtreme 𝕜 A C","decl":"@[trans]\nprotected theorem IsExtreme.trans (hAB : IsExtreme 𝕜 A B) (hBC : IsExtreme 𝕜 B C) :\n    IsExtreme 𝕜 A C := by\n  refine ⟨Subset.trans hBC.1 hAB.1, fun x₁ hx₁A x₂ hx₂A x hxC hx ↦ ?_⟩\n  obtain ⟨hx₁B, hx₂B⟩ := hAB.2 hx₁A hx₂A (hBC.1 hxC) hx\n  exact hBC.2 hx₁B hx₂B hxC hx\n\n"}
{"name":"IsExtreme.antisymm","module":"Mathlib.Analysis.Convex.Extreme","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : OrderedSemiring 𝕜\ninst✝¹ : AddCommMonoid E\ninst✝ : SMul 𝕜 E\n⊢ AntiSymmetric (IsExtreme 𝕜)","decl":"protected theorem IsExtreme.antisymm : AntiSymmetric (IsExtreme 𝕜 : Set E → Set E → Prop) :=\n  fun _ _ hAB hBA ↦ Subset.antisymm hBA.1 hAB.1\n\n"}
{"name":"instIsPartialOrderSetIsExtreme","module":"Mathlib.Analysis.Convex.Extreme","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : OrderedSemiring 𝕜\ninst✝¹ : AddCommMonoid E\ninst✝ : SMul 𝕜 E\n⊢ IsPartialOrder (Set E) (IsExtreme 𝕜)","decl":"instance : IsPartialOrder (Set E) (IsExtreme 𝕜) where\n  refl := IsExtreme.refl 𝕜\n  trans _ _ _ := IsExtreme.trans\n  antisymm := IsExtreme.antisymm\n\n"}
{"name":"IsExtreme.inter","module":"Mathlib.Analysis.Convex.Extreme","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : OrderedSemiring 𝕜\ninst✝¹ : AddCommMonoid E\ninst✝ : SMul 𝕜 E\nA B C : Set E\nhAB : IsExtreme 𝕜 A B\nhAC : IsExtreme 𝕜 A C\n⊢ IsExtreme 𝕜 A (Inter.inter B C)","decl":"theorem IsExtreme.inter (hAB : IsExtreme 𝕜 A B) (hAC : IsExtreme 𝕜 A C) :\n    IsExtreme 𝕜 A (B ∩ C) := by\n  use Subset.trans inter_subset_left hAB.1\n  rintro x₁ hx₁A x₂ hx₂A x ⟨hxB, hxC⟩ hx\n  obtain ⟨hx₁B, hx₂B⟩ := hAB.2 hx₁A hx₂A hxB hx\n  obtain ⟨hx₁C, hx₂C⟩ := hAC.2 hx₁A hx₂A hxC hx\n  exact ⟨⟨hx₁B, hx₁C⟩, hx₂B, hx₂C⟩\n\n"}
{"name":"IsExtreme.mono","module":"Mathlib.Analysis.Convex.Extreme","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : OrderedSemiring 𝕜\ninst✝¹ : AddCommMonoid E\ninst✝ : SMul 𝕜 E\nA B C : Set E\nhAC : IsExtreme 𝕜 A C\nhBA : HasSubset.Subset B A\nhCB : HasSubset.Subset C B\n⊢ IsExtreme 𝕜 B C","decl":"protected theorem IsExtreme.mono (hAC : IsExtreme 𝕜 A C) (hBA : B ⊆ A) (hCB : C ⊆ B) :\n    IsExtreme 𝕜 B C :=\n  ⟨hCB, fun _ hx₁B _ hx₂B _ hxC hx ↦ hAC.2 (hBA hx₁B) (hBA hx₂B) hxC hx⟩\n\n"}
{"name":"isExtreme_iInter","module":"Mathlib.Analysis.Convex.Extreme","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝³ : OrderedSemiring 𝕜\ninst✝² : AddCommMonoid E\ninst✝¹ : SMul 𝕜 E\nA : Set E\nι : Sort u_6\ninst✝ : Nonempty ι\nF : ι → Set E\nhAF : ∀ (i : ι), IsExtreme 𝕜 A (F i)\n⊢ IsExtreme 𝕜 A (Set.iInter fun i => F i)","decl":"theorem isExtreme_iInter {ι : Sort*} [Nonempty ι] {F : ι → Set E}\n    (hAF : ∀ i : ι, IsExtreme 𝕜 A (F i)) : IsExtreme 𝕜 A (⋂ i : ι, F i) := by\n  obtain i := Classical.arbitrary ι\n  refine ⟨iInter_subset_of_subset i (hAF i).1, fun x₁ hx₁A x₂ hx₂A x hxF hx ↦ ?_⟩\n  simp_rw [mem_iInter] at hxF ⊢\n  have h := fun i ↦ (hAF i).2 hx₁A hx₂A (hxF i) hx\n  exact ⟨fun i ↦ (h i).1, fun i ↦ (h i).2⟩\n\n"}
{"name":"isExtreme_biInter","module":"Mathlib.Analysis.Convex.Extreme","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : OrderedSemiring 𝕜\ninst✝¹ : AddCommMonoid E\ninst✝ : SMul 𝕜 E\nA : Set E\nF : Set (Set E)\nhF : F.Nonempty\nhA : ∀ (B : Set E), Membership.mem F B → IsExtreme 𝕜 A B\n⊢ IsExtreme 𝕜 A (Set.iInter fun B => Set.iInter fun h => B)","decl":"theorem isExtreme_biInter {F : Set (Set E)} (hF : F.Nonempty) (hA : ∀ B ∈ F, IsExtreme 𝕜 A B) :\n    IsExtreme 𝕜 A (⋂ B ∈ F, B) := by\n  haveI := hF.to_subtype\n  simpa only [iInter_subtype] using isExtreme_iInter fun i : F ↦ hA _ i.2\n\n"}
{"name":"isExtreme_sInter","module":"Mathlib.Analysis.Convex.Extreme","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : OrderedSemiring 𝕜\ninst✝¹ : AddCommMonoid E\ninst✝ : SMul 𝕜 E\nA : Set E\nF : Set (Set E)\nhF : F.Nonempty\nhAF : ∀ (B : Set E), Membership.mem F B → IsExtreme 𝕜 A B\n⊢ IsExtreme 𝕜 A F.sInter","decl":"theorem isExtreme_sInter {F : Set (Set E)} (hF : F.Nonempty) (hAF : ∀ B ∈ F, IsExtreme 𝕜 A B) :\n    IsExtreme 𝕜 A (⋂₀ F) := by simpa [sInter_eq_biInter] using isExtreme_biInter hF hAF\n\n"}
{"name":"mem_extremePoints","module":"Mathlib.Analysis.Convex.Extreme","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : OrderedSemiring 𝕜\ninst✝¹ : AddCommMonoid E\ninst✝ : SMul 𝕜 E\nA : Set E\nx : E\n⊢ Iff (Membership.mem (Set.extremePoints 𝕜 A) x) (And (Membership.mem A x) (∀ (x₁ : E), Membership.mem A x₁ → ∀ (x₂ : E), Membership.mem A x₂ → Membership.mem (openSegment 𝕜 x₁ x₂) x → And (Eq x₁ x) (Eq x₂ x)))","decl":"theorem mem_extremePoints : x ∈ A.extremePoints 𝕜 ↔\n    x ∈ A ∧ ∀ᵉ (x₁ ∈ A) (x₂ ∈ A), x ∈ openSegment 𝕜 x₁ x₂ → x₁ = x ∧ x₂ = x :=\n  Iff.rfl\n\n"}
{"name":"isExtreme_singleton","module":"Mathlib.Analysis.Convex.Extreme","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : OrderedSemiring 𝕜\ninst✝¹ : AddCommMonoid E\ninst✝ : SMul 𝕜 E\nA : Set E\nx : E\n⊢ Iff (IsExtreme 𝕜 A (Singleton.singleton x)) (Membership.mem (Set.extremePoints 𝕜 A) x)","decl":"/-- x is an extreme point to A iff {x} is an extreme set of A. -/\n@[simp] lemma isExtreme_singleton : IsExtreme 𝕜 A {x} ↔ x ∈ A.extremePoints 𝕜 := by\n  refine ⟨fun hx ↦ ⟨singleton_subset_iff.1 hx.1, fun x₁ hx₁ x₂ hx₂ ↦ hx.2 hx₁ hx₂ rfl⟩, ?_⟩\n  rintro ⟨hxA, hAx⟩\n  use singleton_subset_iff.2 hxA\n  rintro x₁ hx₁A x₂ hx₂A y (rfl : y = x)\n  exact hAx hx₁A hx₂A\n\n"}
{"name":"IsExtreme.mem_extremePoints","module":"Mathlib.Analysis.Convex.Extreme","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : OrderedSemiring 𝕜\ninst✝¹ : AddCommMonoid E\ninst✝ : SMul 𝕜 E\nA : Set E\nx : E\na✝ : IsExtreme 𝕜 A (Singleton.singleton x)\n⊢ Membership.mem (Set.extremePoints 𝕜 A) x","decl":"alias ⟨IsExtreme.mem_extremePoints, _⟩ := isExtreme_singleton\n\n"}
{"name":"extremePoints_subset","module":"Mathlib.Analysis.Convex.Extreme","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : OrderedSemiring 𝕜\ninst✝¹ : AddCommMonoid E\ninst✝ : SMul 𝕜 E\nA : Set E\n⊢ HasSubset.Subset (Set.extremePoints 𝕜 A) A","decl":"theorem extremePoints_subset : A.extremePoints 𝕜 ⊆ A :=\n  fun _ hx ↦ hx.1\n\n"}
{"name":"extremePoints_empty","module":"Mathlib.Analysis.Convex.Extreme","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : OrderedSemiring 𝕜\ninst✝¹ : AddCommMonoid E\ninst✝ : SMul 𝕜 E\n⊢ Eq (Set.extremePoints 𝕜 EmptyCollection.emptyCollection) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem extremePoints_empty : (∅ : Set E).extremePoints 𝕜 = ∅ :=\n  subset_empty_iff.1 extremePoints_subset\n\n"}
{"name":"extremePoints_singleton","module":"Mathlib.Analysis.Convex.Extreme","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : OrderedSemiring 𝕜\ninst✝¹ : AddCommMonoid E\ninst✝ : SMul 𝕜 E\nx : E\n⊢ Eq (Set.extremePoints 𝕜 (Singleton.singleton x)) (Singleton.singleton x)","decl":"@[simp]\ntheorem extremePoints_singleton : ({x} : Set E).extremePoints 𝕜 = {x} :=\n  extremePoints_subset.antisymm <|\n    singleton_subset_iff.2 ⟨mem_singleton x, fun _ hx₁ _ hx₂ _ ↦ ⟨hx₁, hx₂⟩⟩\n\n"}
{"name":"inter_extremePoints_subset_extremePoints_of_subset","module":"Mathlib.Analysis.Convex.Extreme","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : OrderedSemiring 𝕜\ninst✝¹ : AddCommMonoid E\ninst✝ : SMul 𝕜 E\nA B : Set E\nhBA : HasSubset.Subset B A\n⊢ HasSubset.Subset (Inter.inter B (Set.extremePoints 𝕜 A)) (Set.extremePoints 𝕜 B)","decl":"theorem inter_extremePoints_subset_extremePoints_of_subset (hBA : B ⊆ A) :\n    B ∩ A.extremePoints 𝕜 ⊆ B.extremePoints 𝕜 :=\n  fun _ ⟨hxB, hxA⟩ ↦ ⟨hxB, fun _ hx₁ _ hx₂ hx ↦ hxA.2 (hBA hx₁) (hBA hx₂) hx⟩\n\n"}
{"name":"IsExtreme.extremePoints_subset_extremePoints","module":"Mathlib.Analysis.Convex.Extreme","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : OrderedSemiring 𝕜\ninst✝¹ : AddCommMonoid E\ninst✝ : SMul 𝕜 E\nA B : Set E\nhAB : IsExtreme 𝕜 A B\n⊢ HasSubset.Subset (Set.extremePoints 𝕜 B) (Set.extremePoints 𝕜 A)","decl":"theorem IsExtreme.extremePoints_subset_extremePoints (hAB : IsExtreme 𝕜 A B) :\n    B.extremePoints 𝕜 ⊆ A.extremePoints 𝕜 :=\n  fun _ ↦ by simpa only [← isExtreme_singleton] using hAB.trans\n\n"}
{"name":"IsExtreme.extremePoints_eq","module":"Mathlib.Analysis.Convex.Extreme","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : OrderedSemiring 𝕜\ninst✝¹ : AddCommMonoid E\ninst✝ : SMul 𝕜 E\nA B : Set E\nhAB : IsExtreme 𝕜 A B\n⊢ Eq (Set.extremePoints 𝕜 B) (Inter.inter B (Set.extremePoints 𝕜 A))","decl":"theorem IsExtreme.extremePoints_eq (hAB : IsExtreme 𝕜 A B) :\n    B.extremePoints 𝕜 = B ∩ A.extremePoints 𝕜 :=\n  Subset.antisymm (fun _ hx ↦ ⟨hx.1, hAB.extremePoints_subset_extremePoints hx⟩)\n    (inter_extremePoints_subset_extremePoints_of_subset hAB.1)\n\n"}
{"name":"IsExtreme.convex_diff","module":"Mathlib.Analysis.Convex.Extreme","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : OrderedSemiring 𝕜\ninst✝¹ : AddCommGroup E\ninst✝ : Module 𝕜 E\nA B : Set E\nhA : Convex 𝕜 A\nhAB : IsExtreme 𝕜 A B\n⊢ Convex 𝕜 (SDiff.sdiff A B)","decl":"theorem IsExtreme.convex_diff (hA : Convex 𝕜 A) (hAB : IsExtreme 𝕜 A B) : Convex 𝕜 (A \\ B) :=\n  convex_iff_openSegment_subset.2 fun _ ⟨hx₁A, hx₁B⟩ _ ⟨hx₂A, _⟩ _ hx ↦\n    ⟨hA.openSegment_subset hx₁A hx₂A hx, fun hxB ↦ hx₁B (hAB.2 hx₁A hx₂A hxB hx).1⟩\n\n"}
{"name":"extremePoints_prod","module":"Mathlib.Analysis.Convex.Extreme","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : OrderedSemiring 𝕜\ninst✝³ : AddCommGroup E\ninst✝² : AddCommGroup F\ninst✝¹ : Module 𝕜 E\ninst✝ : Module 𝕜 F\ns : Set E\nt : Set F\n⊢ Eq (Set.extremePoints 𝕜 (SProd.sprod s t)) (SProd.sprod (Set.extremePoints 𝕜 s) (Set.extremePoints 𝕜 t))","decl":"@[simp]\ntheorem extremePoints_prod (s : Set E) (t : Set F) :\n    (s ×ˢ t).extremePoints 𝕜 = s.extremePoints 𝕜 ×ˢ t.extremePoints 𝕜 := by\n  ext\n  refine (and_congr_right fun hx ↦ ⟨fun h ↦ ?_, fun h ↦ ?_⟩).trans and_and_and_comm\n  constructor\n  · rintro x₁ hx₁ x₂ hx₂ hx_fst\n    refine (h (mk_mem_prod hx₁ hx.2) (mk_mem_prod hx₂ hx.2) ?_).imp (congr_arg Prod.fst)\n        (congr_arg Prod.fst)\n    rw [← Prod.image_mk_openSegment_left]\n    exact ⟨_, hx_fst, rfl⟩\n  · rintro x₁ hx₁ x₂ hx₂ hx_snd\n    refine (h (mk_mem_prod hx.1 hx₁) (mk_mem_prod hx.1 hx₂) ?_).imp (congr_arg Prod.snd)\n        (congr_arg Prod.snd)\n    rw [← Prod.image_mk_openSegment_right]\n    exact ⟨_, hx_snd, rfl⟩\n  · rintro x₁ hx₁ x₂ hx₂ ⟨a, b, ha, hb, hab, hx'⟩\n    simp_rw [Prod.ext_iff]\n    exact and_and_and_comm.1\n        ⟨h.1 hx₁.1 hx₂.1 ⟨a, b, ha, hb, hab, congr_arg Prod.fst hx'⟩,\n          h.2 hx₁.2 hx₂.2 ⟨a, b, ha, hb, hab, congr_arg Prod.snd hx'⟩⟩\n\n"}
{"name":"extremePoints_pi","module":"Mathlib.Analysis.Convex.Extreme","initialProofState":"𝕜 : Type u_1\nι : Type u_4\nπ : ι → Type u_5\ninst✝² : OrderedSemiring 𝕜\ninst✝¹ : (i : ι) → AddCommGroup (π i)\ninst✝ : (i : ι) → Module 𝕜 (π i)\ns : (i : ι) → Set (π i)\n⊢ Eq (Set.extremePoints 𝕜 (Set.univ.pi s)) (Set.univ.pi fun i => Set.extremePoints 𝕜 (s i))","decl":"@[simp]\ntheorem extremePoints_pi (s : ∀ i, Set (π i)) :\n    (univ.pi s).extremePoints 𝕜 = univ.pi fun i ↦ (s i).extremePoints 𝕜 := by\n  classical\n  ext x\n  simp only [mem_extremePoints, mem_pi, mem_univ, true_imp_iff, @forall_and ι]\n  refine and_congr_right fun hx ↦ ⟨fun h i ↦ ?_, fun h ↦ ?_⟩\n  · rintro x₁ hx₁ x₂ hx₂ hi\n    refine (h (update x i x₁) ?_ (update x i x₂) ?_ ?_).imp (fun h₁ ↦ by rw [← h₁, update_self])\n        fun h₂ ↦ by rw [← h₂, update_self]\n    iterate 2\n      rintro j\n      obtain rfl | hji := eq_or_ne j i\n      · rwa [update_self]\n      · rw [update_of_ne hji]\n        exact hx _\n    rw [← Pi.image_update_openSegment]\n    exact ⟨_, hi, update_eq_self _ _⟩\n  · rintro x₁ hx₁ x₂ hx₂ ⟨a, b, ha, hb, hab, hx'⟩\n    simp_rw [funext_iff, ← forall_and]\n    exact fun i ↦ h _ _ (hx₁ _) _ (hx₂ _) ⟨a, b, ha, hb, hab, congr_fun hx' _⟩\n\n"}
{"name":"image_extremePoints","module":"Mathlib.Analysis.Convex.Extreme","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\nL : Type u_6\ninst✝⁶ : OrderedRing 𝕜\ninst✝⁵ : AddCommGroup E\ninst✝⁴ : Module 𝕜 E\ninst✝³ : AddCommGroup F\ninst✝² : Module 𝕜 F\ninst✝¹ : EquivLike L E F\ninst✝ : LinearEquivClass L 𝕜 E F\nf : L\ns : Set E\n⊢ Eq (Set.image (⇑f) (Set.extremePoints 𝕜 s)) (Set.extremePoints 𝕜 (Set.image (⇑f) s))","decl":"lemma image_extremePoints (f : L) (s : Set E) :\n    f '' extremePoints 𝕜 s = extremePoints 𝕜 (f '' s) := by\n  ext b\n  obtain ⟨a, rfl⟩ := EquivLike.surjective f b\n  have : ∀ x y, f '' openSegment 𝕜 x y = openSegment 𝕜 (f x) (f y) :=\n    image_openSegment _ (LinearMapClass.linearMap f).toAffineMap\n  simp only [mem_extremePoints, (EquivLike.surjective f).forall,\n    (EquivLike.injective f).mem_set_image, (EquivLike.injective f).eq_iff, ← this]\n\n"}
{"name":"mem_extremePoints_iff_forall_segment","module":"Mathlib.Analysis.Convex.Extreme","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝⁴ : LinearOrderedRing 𝕜\ninst✝³ : AddCommGroup E\ninst✝² : Module 𝕜 E\ninst✝¹ : DenselyOrdered 𝕜\ninst✝ : NoZeroSMulDivisors 𝕜 E\nA : Set E\nx : E\n⊢ Iff (Membership.mem (Set.extremePoints 𝕜 A) x) (And (Membership.mem A x) (∀ (x₁ : E), Membership.mem A x₁ → ∀ (x₂ : E), Membership.mem A x₂ → Membership.mem (segment 𝕜 x₁ x₂) x → Or (Eq x₁ x) (Eq x₂ x)))","decl":"/-- A useful restatement using `segment`: `x` is an extreme point iff the only (closed) segments\nthat contain it are those with `x` as one of their endpoints. -/\ntheorem mem_extremePoints_iff_forall_segment : x ∈ A.extremePoints 𝕜 ↔\n    x ∈ A ∧ ∀ᵉ (x₁ ∈ A) (x₂ ∈ A), x ∈ segment 𝕜 x₁ x₂ → x₁ = x ∨ x₂ = x := by\n  refine and_congr_right fun hxA ↦ forall₄_congr fun x₁ h₁ x₂ h₂ ↦ ?_\n  constructor\n  · rw [← insert_endpoints_openSegment]\n    rintro H (rfl | rfl | hx)\n    exacts [Or.inl rfl, Or.inr rfl, Or.inl <| (H hx).1]\n  · intro H hx\n    rcases H (openSegment_subset_segment _ _ _ hx) with (rfl | rfl)\n    exacts [⟨rfl, (left_mem_openSegment_iff.1 hx).symm⟩, ⟨right_mem_openSegment_iff.1 hx, rfl⟩]\n\n"}
{"name":"Convex.mem_extremePoints_iff_convex_diff","module":"Mathlib.Analysis.Convex.Extreme","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝⁴ : LinearOrderedRing 𝕜\ninst✝³ : AddCommGroup E\ninst✝² : Module 𝕜 E\ninst✝¹ : DenselyOrdered 𝕜\ninst✝ : NoZeroSMulDivisors 𝕜 E\nA : Set E\nx : E\nhA : Convex 𝕜 A\n⊢ Iff (Membership.mem (Set.extremePoints 𝕜 A) x) (And (Membership.mem A x) (Convex 𝕜 (SDiff.sdiff A (Singleton.singleton x))))","decl":"theorem Convex.mem_extremePoints_iff_convex_diff (hA : Convex 𝕜 A) :\n    x ∈ A.extremePoints 𝕜 ↔ x ∈ A ∧ Convex 𝕜 (A \\ {x}) := by\n  use fun hx ↦ ⟨hx.1, (isExtreme_singleton.2 hx).convex_diff hA⟩\n  rintro ⟨hxA, hAx⟩\n  refine mem_extremePoints_iff_forall_segment.2 ⟨hxA, fun x₁ hx₁ x₂ hx₂ hx ↦ ?_⟩\n  rw [convex_iff_segment_subset] at hAx\n  by_contra! h\n  exact (hAx ⟨hx₁, fun hx₁ ↦ h.1 (mem_singleton_iff.2 hx₁)⟩\n      ⟨hx₂, fun hx₂ ↦ h.2 (mem_singleton_iff.2 hx₂)⟩ hx).2 rfl\n\n"}
{"name":"Convex.mem_extremePoints_iff_mem_diff_convexHull_diff","module":"Mathlib.Analysis.Convex.Extreme","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝⁴ : LinearOrderedRing 𝕜\ninst✝³ : AddCommGroup E\ninst✝² : Module 𝕜 E\ninst✝¹ : DenselyOrdered 𝕜\ninst✝ : NoZeroSMulDivisors 𝕜 E\nA : Set E\nx : E\nhA : Convex 𝕜 A\n⊢ Iff (Membership.mem (Set.extremePoints 𝕜 A) x) (Membership.mem (SDiff.sdiff A ((convexHull 𝕜) (SDiff.sdiff A (Singleton.singleton x)))) x)","decl":"theorem Convex.mem_extremePoints_iff_mem_diff_convexHull_diff (hA : Convex 𝕜 A) :\n    x ∈ A.extremePoints 𝕜 ↔ x ∈ A \\ convexHull 𝕜 (A \\ {x}) := by\n  rw [hA.mem_extremePoints_iff_convex_diff, hA.convex_remove_iff_not_mem_convexHull_remove,\n    mem_diff]\n\n"}
{"name":"extremePoints_convexHull_subset","module":"Mathlib.Analysis.Convex.Extreme","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝⁴ : LinearOrderedRing 𝕜\ninst✝³ : AddCommGroup E\ninst✝² : Module 𝕜 E\ninst✝¹ : DenselyOrdered 𝕜\ninst✝ : NoZeroSMulDivisors 𝕜 E\nA : Set E\n⊢ HasSubset.Subset (Set.extremePoints 𝕜 ((convexHull 𝕜) A)) A","decl":"theorem extremePoints_convexHull_subset : (convexHull 𝕜 A).extremePoints 𝕜 ⊆ A := by\n  rintro x hx\n  rw [(convex_convexHull 𝕜 _).mem_extremePoints_iff_convex_diff] at hx\n  by_contra h\n  exact (convexHull_min (subset_diff.2 ⟨subset_convexHull 𝕜 _, disjoint_singleton_right.2 h⟩) hx.2\n    hx.1).2 rfl\n\n"}
