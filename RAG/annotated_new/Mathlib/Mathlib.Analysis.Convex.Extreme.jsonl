{"name":"IsExtreme.refl","module":"Mathlib.Analysis.Convex.Extreme","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : OrderedSemiring ğ•œ\ninstâœÂ¹ : AddCommMonoid E\ninstâœ : SMul ğ•œ E\nA : Set E\nâŠ¢ IsExtreme ğ•œ A A","decl":"@[refl]\nprotected theorem IsExtreme.refl (A : Set E) : IsExtreme ğ•œ A A :=\n  âŸ¨Subset.rfl, fun _ hxâ‚A _ hxâ‚‚A _ _ _ â†¦ âŸ¨hxâ‚A, hxâ‚‚AâŸ©âŸ©\n\n"}
{"name":"IsExtreme.rfl","module":"Mathlib.Analysis.Convex.Extreme","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : OrderedSemiring ğ•œ\ninstâœÂ¹ : AddCommMonoid E\ninstâœ : SMul ğ•œ E\nA : Set E\nâŠ¢ IsExtreme ğ•œ A A","decl":"protected theorem IsExtreme.rfl : IsExtreme ğ•œ A A :=\n  IsExtreme.refl ğ•œ A\n\n"}
{"name":"IsExtreme.trans","module":"Mathlib.Analysis.Convex.Extreme","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : OrderedSemiring ğ•œ\ninstâœÂ¹ : AddCommMonoid E\ninstâœ : SMul ğ•œ E\nA B C : Set E\nhAB : IsExtreme ğ•œ A B\nhBC : IsExtreme ğ•œ B C\nâŠ¢ IsExtreme ğ•œ A C","decl":"@[trans]\nprotected theorem IsExtreme.trans (hAB : IsExtreme ğ•œ A B) (hBC : IsExtreme ğ•œ B C) :\n    IsExtreme ğ•œ A C := by\n  refine âŸ¨Subset.trans hBC.1 hAB.1, fun xâ‚ hxâ‚A xâ‚‚ hxâ‚‚A x hxC hx â†¦ ?_âŸ©\n  obtain âŸ¨hxâ‚B, hxâ‚‚BâŸ© := hAB.2 hxâ‚A hxâ‚‚A (hBC.1 hxC) hx\n  exact hBC.2 hxâ‚B hxâ‚‚B hxC hx\n\n"}
{"name":"IsExtreme.antisymm","module":"Mathlib.Analysis.Convex.Extreme","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : OrderedSemiring ğ•œ\ninstâœÂ¹ : AddCommMonoid E\ninstâœ : SMul ğ•œ E\nâŠ¢ AntiSymmetric (IsExtreme ğ•œ)","decl":"protected theorem IsExtreme.antisymm : AntiSymmetric (IsExtreme ğ•œ : Set E â†’ Set E â†’ Prop) :=\n  fun _ _ hAB hBA â†¦ Subset.antisymm hBA.1 hAB.1\n\n"}
{"name":"instIsPartialOrderSetIsExtreme","module":"Mathlib.Analysis.Convex.Extreme","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : OrderedSemiring ğ•œ\ninstâœÂ¹ : AddCommMonoid E\ninstâœ : SMul ğ•œ E\nâŠ¢ IsPartialOrder (Set E) (IsExtreme ğ•œ)","decl":"instance : IsPartialOrder (Set E) (IsExtreme ğ•œ) where\n  refl := IsExtreme.refl ğ•œ\n  trans _ _ _ := IsExtreme.trans\n  antisymm := IsExtreme.antisymm\n\n"}
{"name":"IsExtreme.inter","module":"Mathlib.Analysis.Convex.Extreme","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : OrderedSemiring ğ•œ\ninstâœÂ¹ : AddCommMonoid E\ninstâœ : SMul ğ•œ E\nA B C : Set E\nhAB : IsExtreme ğ•œ A B\nhAC : IsExtreme ğ•œ A C\nâŠ¢ IsExtreme ğ•œ A (Inter.inter B C)","decl":"theorem IsExtreme.inter (hAB : IsExtreme ğ•œ A B) (hAC : IsExtreme ğ•œ A C) :\n    IsExtreme ğ•œ A (B âˆ© C) := by\n  use Subset.trans inter_subset_left hAB.1\n  rintro xâ‚ hxâ‚A xâ‚‚ hxâ‚‚A x âŸ¨hxB, hxCâŸ© hx\n  obtain âŸ¨hxâ‚B, hxâ‚‚BâŸ© := hAB.2 hxâ‚A hxâ‚‚A hxB hx\n  obtain âŸ¨hxâ‚C, hxâ‚‚CâŸ© := hAC.2 hxâ‚A hxâ‚‚A hxC hx\n  exact âŸ¨âŸ¨hxâ‚B, hxâ‚CâŸ©, hxâ‚‚B, hxâ‚‚CâŸ©\n\n"}
{"name":"IsExtreme.mono","module":"Mathlib.Analysis.Convex.Extreme","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : OrderedSemiring ğ•œ\ninstâœÂ¹ : AddCommMonoid E\ninstâœ : SMul ğ•œ E\nA B C : Set E\nhAC : IsExtreme ğ•œ A C\nhBA : HasSubset.Subset B A\nhCB : HasSubset.Subset C B\nâŠ¢ IsExtreme ğ•œ B C","decl":"protected theorem IsExtreme.mono (hAC : IsExtreme ğ•œ A C) (hBA : B âŠ† A) (hCB : C âŠ† B) :\n    IsExtreme ğ•œ B C :=\n  âŸ¨hCB, fun _ hxâ‚B _ hxâ‚‚B _ hxC hx â†¦ hAC.2 (hBA hxâ‚B) (hBA hxâ‚‚B) hxC hxâŸ©\n\n"}
{"name":"isExtreme_iInter","module":"Mathlib.Analysis.Convex.Extreme","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ³ : OrderedSemiring ğ•œ\ninstâœÂ² : AddCommMonoid E\ninstâœÂ¹ : SMul ğ•œ E\nA : Set E\nÎ¹ : Sort u_6\ninstâœ : Nonempty Î¹\nF : Î¹ â†’ Set E\nhAF : âˆ€ (i : Î¹), IsExtreme ğ•œ A (F i)\nâŠ¢ IsExtreme ğ•œ A (Set.iInter fun i => F i)","decl":"theorem isExtreme_iInter {Î¹ : Sort*} [Nonempty Î¹] {F : Î¹ â†’ Set E}\n    (hAF : âˆ€ i : Î¹, IsExtreme ğ•œ A (F i)) : IsExtreme ğ•œ A (â‹‚ i : Î¹, F i) := by\n  obtain i := Classical.arbitrary Î¹\n  refine âŸ¨iInter_subset_of_subset i (hAF i).1, fun xâ‚ hxâ‚A xâ‚‚ hxâ‚‚A x hxF hx â†¦ ?_âŸ©\n  simp_rw [mem_iInter] at hxF âŠ¢\n  have h := fun i â†¦ (hAF i).2 hxâ‚A hxâ‚‚A (hxF i) hx\n  exact âŸ¨fun i â†¦ (h i).1, fun i â†¦ (h i).2âŸ©\n\n"}
{"name":"isExtreme_biInter","module":"Mathlib.Analysis.Convex.Extreme","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : OrderedSemiring ğ•œ\ninstâœÂ¹ : AddCommMonoid E\ninstâœ : SMul ğ•œ E\nA : Set E\nF : Set (Set E)\nhF : F.Nonempty\nhA : âˆ€ (B : Set E), Membership.mem F B â†’ IsExtreme ğ•œ A B\nâŠ¢ IsExtreme ğ•œ A (Set.iInter fun B => Set.iInter fun h => B)","decl":"theorem isExtreme_biInter {F : Set (Set E)} (hF : F.Nonempty) (hA : âˆ€ B âˆˆ F, IsExtreme ğ•œ A B) :\n    IsExtreme ğ•œ A (â‹‚ B âˆˆ F, B) := by\n  haveI := hF.to_subtype\n  simpa only [iInter_subtype] using isExtreme_iInter fun i : F â†¦ hA _ i.2\n\n"}
{"name":"isExtreme_sInter","module":"Mathlib.Analysis.Convex.Extreme","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : OrderedSemiring ğ•œ\ninstâœÂ¹ : AddCommMonoid E\ninstâœ : SMul ğ•œ E\nA : Set E\nF : Set (Set E)\nhF : F.Nonempty\nhAF : âˆ€ (B : Set E), Membership.mem F B â†’ IsExtreme ğ•œ A B\nâŠ¢ IsExtreme ğ•œ A F.sInter","decl":"theorem isExtreme_sInter {F : Set (Set E)} (hF : F.Nonempty) (hAF : âˆ€ B âˆˆ F, IsExtreme ğ•œ A B) :\n    IsExtreme ğ•œ A (â‹‚â‚€ F) := by simpa [sInter_eq_biInter] using isExtreme_biInter hF hAF\n\n"}
{"name":"mem_extremePoints","module":"Mathlib.Analysis.Convex.Extreme","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : OrderedSemiring ğ•œ\ninstâœÂ¹ : AddCommMonoid E\ninstâœ : SMul ğ•œ E\nA : Set E\nx : E\nâŠ¢ Iff (Membership.mem (Set.extremePoints ğ•œ A) x) (And (Membership.mem A x) (âˆ€ (xâ‚ : E), Membership.mem A xâ‚ â†’ âˆ€ (xâ‚‚ : E), Membership.mem A xâ‚‚ â†’ Membership.mem (openSegment ğ•œ xâ‚ xâ‚‚) x â†’ And (Eq xâ‚ x) (Eq xâ‚‚ x)))","decl":"theorem mem_extremePoints : x âˆˆ A.extremePoints ğ•œ â†”\n    x âˆˆ A âˆ§ âˆ€áµ‰ (xâ‚ âˆˆ A) (xâ‚‚ âˆˆ A), x âˆˆ openSegment ğ•œ xâ‚ xâ‚‚ â†’ xâ‚ = x âˆ§ xâ‚‚ = x :=\n  Iff.rfl\n\n"}
{"name":"isExtreme_singleton","module":"Mathlib.Analysis.Convex.Extreme","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : OrderedSemiring ğ•œ\ninstâœÂ¹ : AddCommMonoid E\ninstâœ : SMul ğ•œ E\nA : Set E\nx : E\nâŠ¢ Iff (IsExtreme ğ•œ A (Singleton.singleton x)) (Membership.mem (Set.extremePoints ğ•œ A) x)","decl":"/-- x is an extreme point to A iff {x} is an extreme set of A. -/\n@[simp] lemma isExtreme_singleton : IsExtreme ğ•œ A {x} â†” x âˆˆ A.extremePoints ğ•œ := by\n  refine âŸ¨fun hx â†¦ âŸ¨singleton_subset_iff.1 hx.1, fun xâ‚ hxâ‚ xâ‚‚ hxâ‚‚ â†¦ hx.2 hxâ‚ hxâ‚‚ rflâŸ©, ?_âŸ©\n  rintro âŸ¨hxA, hAxâŸ©\n  use singleton_subset_iff.2 hxA\n  rintro xâ‚ hxâ‚A xâ‚‚ hxâ‚‚A y (rfl : y = x)\n  exact hAx hxâ‚A hxâ‚‚A\n\n"}
{"name":"IsExtreme.mem_extremePoints","module":"Mathlib.Analysis.Convex.Extreme","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : OrderedSemiring ğ•œ\ninstâœÂ¹ : AddCommMonoid E\ninstâœ : SMul ğ•œ E\nA : Set E\nx : E\naâœ : IsExtreme ğ•œ A (Singleton.singleton x)\nâŠ¢ Membership.mem (Set.extremePoints ğ•œ A) x","decl":"alias âŸ¨IsExtreme.mem_extremePoints, _âŸ© := isExtreme_singleton\n\n"}
{"name":"extremePoints_subset","module":"Mathlib.Analysis.Convex.Extreme","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : OrderedSemiring ğ•œ\ninstâœÂ¹ : AddCommMonoid E\ninstâœ : SMul ğ•œ E\nA : Set E\nâŠ¢ HasSubset.Subset (Set.extremePoints ğ•œ A) A","decl":"theorem extremePoints_subset : A.extremePoints ğ•œ âŠ† A :=\n  fun _ hx â†¦ hx.1\n\n"}
{"name":"extremePoints_empty","module":"Mathlib.Analysis.Convex.Extreme","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : OrderedSemiring ğ•œ\ninstâœÂ¹ : AddCommMonoid E\ninstâœ : SMul ğ•œ E\nâŠ¢ Eq (Set.extremePoints ğ•œ EmptyCollection.emptyCollection) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem extremePoints_empty : (âˆ… : Set E).extremePoints ğ•œ = âˆ… :=\n  subset_empty_iff.1 extremePoints_subset\n\n"}
{"name":"extremePoints_singleton","module":"Mathlib.Analysis.Convex.Extreme","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : OrderedSemiring ğ•œ\ninstâœÂ¹ : AddCommMonoid E\ninstâœ : SMul ğ•œ E\nx : E\nâŠ¢ Eq (Set.extremePoints ğ•œ (Singleton.singleton x)) (Singleton.singleton x)","decl":"@[simp]\ntheorem extremePoints_singleton : ({x} : Set E).extremePoints ğ•œ = {x} :=\n  extremePoints_subset.antisymm <|\n    singleton_subset_iff.2 âŸ¨mem_singleton x, fun _ hxâ‚ _ hxâ‚‚ _ â†¦ âŸ¨hxâ‚, hxâ‚‚âŸ©âŸ©\n\n"}
{"name":"inter_extremePoints_subset_extremePoints_of_subset","module":"Mathlib.Analysis.Convex.Extreme","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : OrderedSemiring ğ•œ\ninstâœÂ¹ : AddCommMonoid E\ninstâœ : SMul ğ•œ E\nA B : Set E\nhBA : HasSubset.Subset B A\nâŠ¢ HasSubset.Subset (Inter.inter B (Set.extremePoints ğ•œ A)) (Set.extremePoints ğ•œ B)","decl":"theorem inter_extremePoints_subset_extremePoints_of_subset (hBA : B âŠ† A) :\n    B âˆ© A.extremePoints ğ•œ âŠ† B.extremePoints ğ•œ :=\n  fun _ âŸ¨hxB, hxAâŸ© â†¦ âŸ¨hxB, fun _ hxâ‚ _ hxâ‚‚ hx â†¦ hxA.2 (hBA hxâ‚) (hBA hxâ‚‚) hxâŸ©\n\n"}
{"name":"IsExtreme.extremePoints_subset_extremePoints","module":"Mathlib.Analysis.Convex.Extreme","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : OrderedSemiring ğ•œ\ninstâœÂ¹ : AddCommMonoid E\ninstâœ : SMul ğ•œ E\nA B : Set E\nhAB : IsExtreme ğ•œ A B\nâŠ¢ HasSubset.Subset (Set.extremePoints ğ•œ B) (Set.extremePoints ğ•œ A)","decl":"theorem IsExtreme.extremePoints_subset_extremePoints (hAB : IsExtreme ğ•œ A B) :\n    B.extremePoints ğ•œ âŠ† A.extremePoints ğ•œ :=\n  fun _ â†¦ by simpa only [â† isExtreme_singleton] using hAB.trans\n\n"}
{"name":"IsExtreme.extremePoints_eq","module":"Mathlib.Analysis.Convex.Extreme","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : OrderedSemiring ğ•œ\ninstâœÂ¹ : AddCommMonoid E\ninstâœ : SMul ğ•œ E\nA B : Set E\nhAB : IsExtreme ğ•œ A B\nâŠ¢ Eq (Set.extremePoints ğ•œ B) (Inter.inter B (Set.extremePoints ğ•œ A))","decl":"theorem IsExtreme.extremePoints_eq (hAB : IsExtreme ğ•œ A B) :\n    B.extremePoints ğ•œ = B âˆ© A.extremePoints ğ•œ :=\n  Subset.antisymm (fun _ hx â†¦ âŸ¨hx.1, hAB.extremePoints_subset_extremePoints hxâŸ©)\n    (inter_extremePoints_subset_extremePoints_of_subset hAB.1)\n\n"}
{"name":"IsExtreme.convex_diff","module":"Mathlib.Analysis.Convex.Extreme","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : OrderedSemiring ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module ğ•œ E\nA B : Set E\nhA : Convex ğ•œ A\nhAB : IsExtreme ğ•œ A B\nâŠ¢ Convex ğ•œ (SDiff.sdiff A B)","decl":"theorem IsExtreme.convex_diff (hA : Convex ğ•œ A) (hAB : IsExtreme ğ•œ A B) : Convex ğ•œ (A \\ B) :=\n  convex_iff_openSegment_subset.2 fun _ âŸ¨hxâ‚A, hxâ‚BâŸ© _ âŸ¨hxâ‚‚A, _âŸ© _ hx â†¦\n    âŸ¨hA.openSegment_subset hxâ‚A hxâ‚‚A hx, fun hxB â†¦ hxâ‚B (hAB.2 hxâ‚A hxâ‚‚A hxB hx).1âŸ©\n\n"}
{"name":"extremePoints_prod","module":"Mathlib.Analysis.Convex.Extreme","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : OrderedSemiring ğ•œ\ninstâœÂ³ : AddCommGroup E\ninstâœÂ² : AddCommGroup F\ninstâœÂ¹ : Module ğ•œ E\ninstâœ : Module ğ•œ F\ns : Set E\nt : Set F\nâŠ¢ Eq (Set.extremePoints ğ•œ (SProd.sprod s t)) (SProd.sprod (Set.extremePoints ğ•œ s) (Set.extremePoints ğ•œ t))","decl":"@[simp]\ntheorem extremePoints_prod (s : Set E) (t : Set F) :\n    (s Ã—Ë¢ t).extremePoints ğ•œ = s.extremePoints ğ•œ Ã—Ë¢ t.extremePoints ğ•œ := by\n  ext\n  refine (and_congr_right fun hx â†¦ âŸ¨fun h â†¦ ?_, fun h â†¦ ?_âŸ©).trans and_and_and_comm\n  constructor\n  Â· rintro xâ‚ hxâ‚ xâ‚‚ hxâ‚‚ hx_fst\n    refine (h (mk_mem_prod hxâ‚ hx.2) (mk_mem_prod hxâ‚‚ hx.2) ?_).imp (congr_arg Prod.fst)\n        (congr_arg Prod.fst)\n    rw [â† Prod.image_mk_openSegment_left]\n    exact âŸ¨_, hx_fst, rflâŸ©\n  Â· rintro xâ‚ hxâ‚ xâ‚‚ hxâ‚‚ hx_snd\n    refine (h (mk_mem_prod hx.1 hxâ‚) (mk_mem_prod hx.1 hxâ‚‚) ?_).imp (congr_arg Prod.snd)\n        (congr_arg Prod.snd)\n    rw [â† Prod.image_mk_openSegment_right]\n    exact âŸ¨_, hx_snd, rflâŸ©\n  Â· rintro xâ‚ hxâ‚ xâ‚‚ hxâ‚‚ âŸ¨a, b, ha, hb, hab, hx'âŸ©\n    simp_rw [Prod.ext_iff]\n    exact and_and_and_comm.1\n        âŸ¨h.1 hxâ‚.1 hxâ‚‚.1 âŸ¨a, b, ha, hb, hab, congr_arg Prod.fst hx'âŸ©,\n          h.2 hxâ‚.2 hxâ‚‚.2 âŸ¨a, b, ha, hb, hab, congr_arg Prod.snd hx'âŸ©âŸ©\n\n"}
{"name":"extremePoints_pi","module":"Mathlib.Analysis.Convex.Extreme","initialProofState":"ğ•œ : Type u_1\nÎ¹ : Type u_4\nÏ€ : Î¹ â†’ Type u_5\ninstâœÂ² : OrderedSemiring ğ•œ\ninstâœÂ¹ : (i : Î¹) â†’ AddCommGroup (Ï€ i)\ninstâœ : (i : Î¹) â†’ Module ğ•œ (Ï€ i)\ns : (i : Î¹) â†’ Set (Ï€ i)\nâŠ¢ Eq (Set.extremePoints ğ•œ (Set.univ.pi s)) (Set.univ.pi fun i => Set.extremePoints ğ•œ (s i))","decl":"@[simp]\ntheorem extremePoints_pi (s : âˆ€ i, Set (Ï€ i)) :\n    (univ.pi s).extremePoints ğ•œ = univ.pi fun i â†¦ (s i).extremePoints ğ•œ := by\n  classical\n  ext x\n  simp only [mem_extremePoints, mem_pi, mem_univ, true_imp_iff, @forall_and Î¹]\n  refine and_congr_right fun hx â†¦ âŸ¨fun h i â†¦ ?_, fun h â†¦ ?_âŸ©\n  Â· rintro xâ‚ hxâ‚ xâ‚‚ hxâ‚‚ hi\n    refine (h (update x i xâ‚) ?_ (update x i xâ‚‚) ?_ ?_).imp (fun hâ‚ â†¦ by rw [â† hâ‚, update_self])\n        fun hâ‚‚ â†¦ by rw [â† hâ‚‚, update_self]\n    iterate 2\n      rintro j\n      obtain rfl | hji := eq_or_ne j i\n      Â· rwa [update_self]\n      Â· rw [update_of_ne hji]\n        exact hx _\n    rw [â† Pi.image_update_openSegment]\n    exact âŸ¨_, hi, update_eq_self _ _âŸ©\n  Â· rintro xâ‚ hxâ‚ xâ‚‚ hxâ‚‚ âŸ¨a, b, ha, hb, hab, hx'âŸ©\n    simp_rw [funext_iff, â† forall_and]\n    exact fun i â†¦ h _ _ (hxâ‚ _) _ (hxâ‚‚ _) âŸ¨a, b, ha, hb, hab, congr_fun hx' _âŸ©\n\n"}
{"name":"image_extremePoints","module":"Mathlib.Analysis.Convex.Extreme","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\nL : Type u_6\ninstâœâ¶ : OrderedRing ğ•œ\ninstâœâµ : AddCommGroup E\ninstâœâ´ : Module ğ•œ E\ninstâœÂ³ : AddCommGroup F\ninstâœÂ² : Module ğ•œ F\ninstâœÂ¹ : EquivLike L E F\ninstâœ : LinearEquivClass L ğ•œ E F\nf : L\ns : Set E\nâŠ¢ Eq (Set.image (â‡‘f) (Set.extremePoints ğ•œ s)) (Set.extremePoints ğ•œ (Set.image (â‡‘f) s))","decl":"lemma image_extremePoints (f : L) (s : Set E) :\n    f '' extremePoints ğ•œ s = extremePoints ğ•œ (f '' s) := by\n  ext b\n  obtain âŸ¨a, rflâŸ© := EquivLike.surjective f b\n  have : âˆ€ x y, f '' openSegment ğ•œ x y = openSegment ğ•œ (f x) (f y) :=\n    image_openSegment _ (LinearMapClass.linearMap f).toAffineMap\n  simp only [mem_extremePoints, (EquivLike.surjective f).forall,\n    (EquivLike.injective f).mem_set_image, (EquivLike.injective f).eq_iff, â† this]\n\n"}
{"name":"mem_extremePoints_iff_forall_segment","module":"Mathlib.Analysis.Convex.Extreme","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœâ´ : LinearOrderedRing ğ•œ\ninstâœÂ³ : AddCommGroup E\ninstâœÂ² : Module ğ•œ E\ninstâœÂ¹ : DenselyOrdered ğ•œ\ninstâœ : NoZeroSMulDivisors ğ•œ E\nA : Set E\nx : E\nâŠ¢ Iff (Membership.mem (Set.extremePoints ğ•œ A) x) (And (Membership.mem A x) (âˆ€ (xâ‚ : E), Membership.mem A xâ‚ â†’ âˆ€ (xâ‚‚ : E), Membership.mem A xâ‚‚ â†’ Membership.mem (segment ğ•œ xâ‚ xâ‚‚) x â†’ Or (Eq xâ‚ x) (Eq xâ‚‚ x)))","decl":"/-- A useful restatement using `segment`: `x` is an extreme point iff the only (closed) segments\nthat contain it are those with `x` as one of their endpoints. -/\ntheorem mem_extremePoints_iff_forall_segment : x âˆˆ A.extremePoints ğ•œ â†”\n    x âˆˆ A âˆ§ âˆ€áµ‰ (xâ‚ âˆˆ A) (xâ‚‚ âˆˆ A), x âˆˆ segment ğ•œ xâ‚ xâ‚‚ â†’ xâ‚ = x âˆ¨ xâ‚‚ = x := by\n  refine and_congr_right fun hxA â†¦ forallâ‚„_congr fun xâ‚ hâ‚ xâ‚‚ hâ‚‚ â†¦ ?_\n  constructor\n  Â· rw [â† insert_endpoints_openSegment]\n    rintro H (rfl | rfl | hx)\n    exacts [Or.inl rfl, Or.inr rfl, Or.inl <| (H hx).1]\n  Â· intro H hx\n    rcases H (openSegment_subset_segment _ _ _ hx) with (rfl | rfl)\n    exacts [âŸ¨rfl, (left_mem_openSegment_iff.1 hx).symmâŸ©, âŸ¨right_mem_openSegment_iff.1 hx, rflâŸ©]\n\n"}
{"name":"Convex.mem_extremePoints_iff_convex_diff","module":"Mathlib.Analysis.Convex.Extreme","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœâ´ : LinearOrderedRing ğ•œ\ninstâœÂ³ : AddCommGroup E\ninstâœÂ² : Module ğ•œ E\ninstâœÂ¹ : DenselyOrdered ğ•œ\ninstâœ : NoZeroSMulDivisors ğ•œ E\nA : Set E\nx : E\nhA : Convex ğ•œ A\nâŠ¢ Iff (Membership.mem (Set.extremePoints ğ•œ A) x) (And (Membership.mem A x) (Convex ğ•œ (SDiff.sdiff A (Singleton.singleton x))))","decl":"theorem Convex.mem_extremePoints_iff_convex_diff (hA : Convex ğ•œ A) :\n    x âˆˆ A.extremePoints ğ•œ â†” x âˆˆ A âˆ§ Convex ğ•œ (A \\ {x}) := by\n  use fun hx â†¦ âŸ¨hx.1, (isExtreme_singleton.2 hx).convex_diff hAâŸ©\n  rintro âŸ¨hxA, hAxâŸ©\n  refine mem_extremePoints_iff_forall_segment.2 âŸ¨hxA, fun xâ‚ hxâ‚ xâ‚‚ hxâ‚‚ hx â†¦ ?_âŸ©\n  rw [convex_iff_segment_subset] at hAx\n  by_contra! h\n  exact (hAx âŸ¨hxâ‚, fun hxâ‚ â†¦ h.1 (mem_singleton_iff.2 hxâ‚)âŸ©\n      âŸ¨hxâ‚‚, fun hxâ‚‚ â†¦ h.2 (mem_singleton_iff.2 hxâ‚‚)âŸ© hx).2 rfl\n\n"}
{"name":"Convex.mem_extremePoints_iff_mem_diff_convexHull_diff","module":"Mathlib.Analysis.Convex.Extreme","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœâ´ : LinearOrderedRing ğ•œ\ninstâœÂ³ : AddCommGroup E\ninstâœÂ² : Module ğ•œ E\ninstâœÂ¹ : DenselyOrdered ğ•œ\ninstâœ : NoZeroSMulDivisors ğ•œ E\nA : Set E\nx : E\nhA : Convex ğ•œ A\nâŠ¢ Iff (Membership.mem (Set.extremePoints ğ•œ A) x) (Membership.mem (SDiff.sdiff A ((convexHull ğ•œ) (SDiff.sdiff A (Singleton.singleton x)))) x)","decl":"theorem Convex.mem_extremePoints_iff_mem_diff_convexHull_diff (hA : Convex ğ•œ A) :\n    x âˆˆ A.extremePoints ğ•œ â†” x âˆˆ A \\ convexHull ğ•œ (A \\ {x}) := by\n  rw [hA.mem_extremePoints_iff_convex_diff, hA.convex_remove_iff_not_mem_convexHull_remove,\n    mem_diff]\n\n"}
{"name":"extremePoints_convexHull_subset","module":"Mathlib.Analysis.Convex.Extreme","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœâ´ : LinearOrderedRing ğ•œ\ninstâœÂ³ : AddCommGroup E\ninstâœÂ² : Module ğ•œ E\ninstâœÂ¹ : DenselyOrdered ğ•œ\ninstâœ : NoZeroSMulDivisors ğ•œ E\nA : Set E\nâŠ¢ HasSubset.Subset (Set.extremePoints ğ•œ ((convexHull ğ•œ) A)) A","decl":"theorem extremePoints_convexHull_subset : (convexHull ğ•œ A).extremePoints ğ•œ âŠ† A := by\n  rintro x hx\n  rw [(convex_convexHull ğ•œ _).mem_extremePoints_iff_convex_diff] at hx\n  by_contra h\n  exact (convexHull_min (subset_diff.2 âŸ¨subset_convexHull ğ•œ _, disjoint_singleton_right.2 hâŸ©) hx.2\n    hx.1).2 rfl\n\n"}
