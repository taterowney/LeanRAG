{"name":"IsSimpleRing.isField_center","module":"Mathlib.RingTheory.SimpleRing.Field","initialProofState":"A : Type u_1\ninst✝¹ : Ring A\ninst✝ : IsSimpleRing A\n⊢ IsField (Subtype fun x => Membership.mem (Subring.center A) x)","decl":"open TwoSidedIdeal in\nlemma isField_center (A : Type*) [Ring A] [IsSimpleRing A] : IsField (Subring.center A) where\n  exists_pair_ne := ⟨0, 1, zero_ne_one⟩\n  mul_comm := mul_comm\n  mul_inv_cancel := by\n    rintro ⟨x, hx1⟩ hx2\n    rw [Subring.mem_center_iff] at hx1\n    replace hx2 : x ≠ 0 := by simpa [Subtype.ext_iff] using hx2\n    -- Todo: golf the following `let` once `TwoSidedIdeal.span` is defined\n    let I := TwoSidedIdeal.mk' (Set.range (x * ·)) ⟨0, by simp⟩\n      (by rintro _ _ ⟨x, rfl⟩ ⟨y, rfl⟩; exact ⟨x + y, mul_add _ _ _⟩)\n      (by rintro _ ⟨x, rfl⟩; exact ⟨-x, by simp⟩)\n      (by rintro a _ ⟨c, rfl⟩; exact ⟨a * c, by dsimp; rw [← mul_assoc, ← hx1, mul_assoc]⟩)\n      (by rintro _ b ⟨a, rfl⟩; exact ⟨a * b, by dsimp; rw [← mul_assoc, ← hx1, mul_assoc]⟩)\n    have mem : 1 ∈ I := one_mem_of_ne_zero_mem I hx2 (by simpa [I, mem_mk'] using ⟨1, by simp⟩)\n    simp only [TwoSidedIdeal.mem_mk', Set.mem_range, I] at mem\n    obtain ⟨y, hy⟩ := mem\n    refine ⟨⟨y, Subring.mem_center_iff.2 fun a ↦ ?_⟩, by ext; exact hy⟩\n    calc a * y\n      _ = (x * y) * a * y := by rw [hy, one_mul]\n      _ = (y * x) * a * y := by rw [hx1]\n      _ = y * (x * a) * y := by rw [mul_assoc y x a]\n      _ = y * (a * x) * y := by rw [hx1]\n      _ = y * ((a * x) * y) := by rw [mul_assoc]\n      _ = y * (a * (x * y)) := by rw [mul_assoc a x y]\n      _ = y * a := by rw [hy, mul_one]\n\n"}
{"name":"isSimpleRing_iff_isField","module":"Mathlib.RingTheory.SimpleRing.Field","initialProofState":"A : Type u_1\ninst✝ : CommRing A\n⊢ Iff (IsSimpleRing A) (IsField A)","decl":"lemma isSimpleRing_iff_isField (A : Type*) [CommRing A] : IsSimpleRing A ↔ IsField A :=\n  ⟨fun _ ↦ Subring.topEquiv.symm.toMulEquiv.isField _ <| by\n    rw [← Subring.center_eq_top A]; exact IsSimpleRing.isField_center A,\n    fun h ↦ letI := h.toField; inferInstance⟩\n"}
