{"name":"CategoryTheory.CommSq.right_adjoint","module":"Mathlib.CategoryTheory.LiftingProperties.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_4, u_1} C\ninst✝ : CategoryTheory.Category.{u_3, u_2} D\nG : CategoryTheory.Functor C D\nF : CategoryTheory.Functor D C\nA B : C\nX Y : D\ni : Quiver.Hom A B\np : Quiver.Hom X Y\nu : Quiver.Hom (G.obj A) X\nv : Quiver.Hom (G.obj B) Y\nsq : CategoryTheory.CommSq u (G.map i) p v\nadj : CategoryTheory.Adjunction G F\n⊢ CategoryTheory.CommSq ((adj.homEquiv A X) u) i (F.map p) ((adj.homEquiv B Y) v)","decl":"/-- When we have an adjunction `G ⊣ F`, any commutative square where the left\nmap is of the form `G.map i` and the right map is `p` has an \"adjoint\" commutative\nsquare whose left map is `i` and whose right map is `F.map p`. -/\ntheorem right_adjoint (sq : CommSq u (G.map i) p v) (adj : G ⊣ F) :\n    CommSq (adj.homEquiv _ _ u) i (F.map p) (adj.homEquiv _ _ v) :=\n  ⟨by\n    simp only [Adjunction.homEquiv_unit, assoc, ← F.map_comp, sq.w]\n    rw [F.map_comp, Adjunction.unit_naturality_assoc]⟩\n\n"}
{"name":"CategoryTheory.CommSq.right_adjoint_hasLift_iff","module":"Mathlib.CategoryTheory.LiftingProperties.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_3, u_1} C\ninst✝ : CategoryTheory.Category.{u_4, u_2} D\nG : CategoryTheory.Functor C D\nF : CategoryTheory.Functor D C\nA B : C\nX Y : D\ni : Quiver.Hom A B\np : Quiver.Hom X Y\nu : Quiver.Hom (G.obj A) X\nv : Quiver.Hom (G.obj B) Y\nsq : CategoryTheory.CommSq u (G.map i) p v\nadj : CategoryTheory.Adjunction G F\n⊢ Iff ⋯.HasLift sq.HasLift","decl":"/-- A square has a lifting if and only if its (right) adjoint square has a lifting. -/\ntheorem right_adjoint_hasLift_iff : HasLift (sq.right_adjoint adj) ↔ HasLift sq := by\n  simp only [HasLift.iff]\n  exact Equiv.nonempty_congr (sq.rightAdjointLiftStructEquiv adj).symm\n\n"}
{"name":"CategoryTheory.CommSq.instHasLift","module":"Mathlib.CategoryTheory.LiftingProperties.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝² : CategoryTheory.Category.{u_4, u_1} C\ninst✝¹ : CategoryTheory.Category.{u_3, u_2} D\nG : CategoryTheory.Functor C D\nF : CategoryTheory.Functor D C\nA B : C\nX Y : D\ni : Quiver.Hom A B\np : Quiver.Hom X Y\nu : Quiver.Hom (G.obj A) X\nv : Quiver.Hom (G.obj B) Y\nsq : CategoryTheory.CommSq u (G.map i) p v\nadj : CategoryTheory.Adjunction G F\ninst✝ : sq.HasLift\n⊢ ⋯.HasLift","decl":"instance [HasLift sq] : HasLift (sq.right_adjoint adj) := by\n  rw [right_adjoint_hasLift_iff]\n  infer_instance\n\n"}
{"name":"CategoryTheory.CommSq.left_adjoint","module":"Mathlib.CategoryTheory.LiftingProperties.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_3, u_1} C\ninst✝ : CategoryTheory.Category.{u_4, u_2} D\nG : CategoryTheory.Functor C D\nF : CategoryTheory.Functor D C\nA B : C\nX Y : D\ni : Quiver.Hom A B\np : Quiver.Hom X Y\nu : Quiver.Hom A (F.obj X)\nv : Quiver.Hom B (F.obj Y)\nsq : CategoryTheory.CommSq u i (F.map p) v\nadj : CategoryTheory.Adjunction G F\n⊢ CategoryTheory.CommSq ((adj.homEquiv A X).symm u) (G.map i) p ((adj.homEquiv B Y).symm v)","decl":"/-- When we have an adjunction `G ⊣ F`, any commutative square where the left\nmap is of the form `i` and the right map is `F.map p` has an \"adjoint\" commutative\nsquare whose left map is `G.map i` and whose right map is `p`. -/\ntheorem left_adjoint (sq : CommSq u i (F.map p) v) (adj : G ⊣ F) :\n    CommSq ((adj.homEquiv _ _).symm u) (G.map i) p ((adj.homEquiv _ _).symm v) :=\n  ⟨by\n    simp only [Adjunction.homEquiv_counit, assoc, ← G.map_comp_assoc, ← sq.w]\n    rw [G.map_comp, assoc, Adjunction.counit_naturality]⟩\n\n"}
{"name":"CategoryTheory.CommSq.left_adjoint_hasLift_iff","module":"Mathlib.CategoryTheory.LiftingProperties.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_4, u_1} C\ninst✝ : CategoryTheory.Category.{u_3, u_2} D\nG : CategoryTheory.Functor C D\nF : CategoryTheory.Functor D C\nA B : C\nX Y : D\ni : Quiver.Hom A B\np : Quiver.Hom X Y\nu : Quiver.Hom A (F.obj X)\nv : Quiver.Hom B (F.obj Y)\nsq : CategoryTheory.CommSq u i (F.map p) v\nadj : CategoryTheory.Adjunction G F\n⊢ Iff ⋯.HasLift sq.HasLift","decl":"/-- A (left) adjoint square has a lifting if and only if the original square has a lifting. -/\ntheorem left_adjoint_hasLift_iff : HasLift (sq.left_adjoint adj) ↔ HasLift sq := by\n  simp only [HasLift.iff]\n  exact Equiv.nonempty_congr (sq.leftAdjointLiftStructEquiv adj).symm\n\n"}
{"name":"CategoryTheory.CommSq.instHasLift_1","module":"Mathlib.CategoryTheory.LiftingProperties.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹ : CategoryTheory.Category.{u_4, u_2} D\nG : CategoryTheory.Functor C D\nF : CategoryTheory.Functor D C\nA B : C\nX Y : D\ni : Quiver.Hom A B\np : Quiver.Hom X Y\nu : Quiver.Hom A (F.obj X)\nv : Quiver.Hom B (F.obj Y)\nsq : CategoryTheory.CommSq u i (F.map p) v\nadj : CategoryTheory.Adjunction G F\ninst✝ : sq.HasLift\n⊢ ⋯.HasLift","decl":"instance [HasLift sq] : HasLift (sq.left_adjoint adj) := by\n  rw [left_adjoint_hasLift_iff]\n  infer_instance\n\n"}
{"name":"CategoryTheory.Adjunction.hasLiftingProperty_iff","module":"Mathlib.CategoryTheory.LiftingProperties.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_3, u_1} C\ninst✝ : CategoryTheory.Category.{u_4, u_2} D\nG : CategoryTheory.Functor C D\nF : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction G F\nA B : C\nX Y : D\ni : Quiver.Hom A B\np : Quiver.Hom X Y\n⊢ Iff (CategoryTheory.HasLiftingProperty (G.map i) p) (CategoryTheory.HasLiftingProperty i (F.map p))","decl":"theorem hasLiftingProperty_iff (adj : G ⊣ F) {A B : C} {X Y : D} (i : A ⟶ B) (p : X ⟶ Y) :\n    HasLiftingProperty (G.map i) p ↔ HasLiftingProperty i (F.map p) := by\n  constructor <;> intro <;> constructor <;> intro f g sq\n  · rw [← sq.left_adjoint_hasLift_iff adj]\n    infer_instance\n  · rw [← sq.right_adjoint_hasLift_iff adj]\n    infer_instance\n\n"}
