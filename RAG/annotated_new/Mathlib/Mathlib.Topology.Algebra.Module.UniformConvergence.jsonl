{"name":"UniformFun.continuousSMul_induced_of_range_bounded","module":"Mathlib.Topology.Algebra.Module.UniformConvergence","initialProofState":"ğ•œ : Type u_1\nÎ± : Type u_2\nE : Type u_3\nH : Type u_4\nhom : Type u_5\ninstâœÂ¹â° : NormedField ğ•œ\ninstâœâ¹ : AddCommGroup H\ninstâœâ¸ : Module ğ•œ H\ninstâœâ· : AddCommGroup E\ninstâœâ¶ : Module ğ•œ E\ninstâœâµ : TopologicalSpace H\ninstâœâ´ : UniformSpace E\ninstâœÂ³ : UniformAddGroup E\ninstâœÂ² : ContinuousSMul ğ•œ E\ninstâœÂ¹ : FunLike hom H (Î± â†’ E)\ninstâœ : LinearMapClass hom ğ•œ H (Î± â†’ E)\nÏ† : hom\nhÏ† : Topology.IsInducing (Function.comp â‡‘UniformFun.ofFun â‡‘Ï†)\nh : âˆ€ (u : H), Bornology.IsVonNBounded ğ•œ (Set.range (Ï† u))\nâŠ¢ ContinuousSMul ğ•œ H","decl":"/-- Let `E` be a topological vector space over a normed field `ğ•œ`, let `Î±` be any type.\nLet `H` be a submodule of `Î± â†’áµ¤ E` such that the range of each `f âˆˆ H` is von Neumann bounded.\nThen `H` is a topological vector space over `ğ•œ`,\ni.e., the pointwise scalar multiplication is continuous in both variables.\n\nFor convenience we require that `H` is a vector space over `ğ•œ`\nwith a topology induced by `UniformFun.ofFun âˆ˜ Ï†`, where `Ï† : H â†’â‚—[ğ•œ] (Î± â†’ E)`. -/\nlemma UniformFun.continuousSMul_induced_of_range_bounded (Ï† : hom)\n    (hÏ† : IsInducing (ofFun âˆ˜ Ï†)) (h : âˆ€ u : H, Bornology.IsVonNBounded ğ•œ (Set.range (Ï† u))) :\n    ContinuousSMul ğ•œ H := by\n  have : TopologicalAddGroup H :=\n    let ofFun' : (Î± â†’ E) â†’+ (Î± â†’áµ¤ E) := AddMonoidHom.id _\n    IsInducing.topologicalAddGroup (ofFun'.comp (Ï† : H â†’+ (Î± â†’ E))) hÏ†\n  have hb : (ğ“ (0 : H)).HasBasis (Â· âˆˆ ğ“ (0 : E)) fun V â†¦ {u | âˆ€ x, Ï† u x âˆˆ V} := by\n    simp only [hÏ†.nhds_eq_comap, Function.comp_apply, map_zero]\n    exact UniformFun.hasBasis_nhds_zero.comap _\n  apply ContinuousSMul.of_basis_zero hb\n  Â· intro U hU\n    have : Tendsto (fun x : ğ•œ Ã— E â†¦ x.1 â€¢ x.2) (ğ“ 0) (ğ“ 0) :=\n      continuous_smul.tendsto' _ _ (zero_smul _ _)\n    rcases ((Filter.basis_sets _).prod_nhds (Filter.basis_sets _)).tendsto_left_iff.1 this U hU\n      with âŸ¨âŸ¨V, WâŸ©, âŸ¨hV, hWâŸ©, hVWâŸ©\n    refine âŸ¨V, hV, W, hW, Set.smul_subset_iff.2 fun a ha u hu x â†¦ ?_âŸ©\n    rw [map_smul]\n    exact hVW (Set.mk_mem_prod ha (hu x))\n  Â· intro c U hU\n    have : Tendsto (c â€¢ Â· : E â†’ E) (ğ“ 0) (ğ“ 0) :=\n      (continuous_const_smul c).tendsto' _ _ (smul_zero _)\n    refine âŸ¨_, this hU, fun u hu x â†¦ ?_âŸ©\n    simpa only [map_smul] using hu x\n  Â· intro u U hU\n    simp only [Set.mem_setOf_eq, map_smul, Pi.smul_apply]\n    simpa only [Set.mapsTo_range_iff] using (h u hU).eventually_nhds_zero (mem_of_mem_nhds hU)\n\n"}
{"name":"UniformOnFun.continuousSMul_induced_of_image_bounded","module":"Mathlib.Topology.Algebra.Module.UniformConvergence","initialProofState":"ğ•œ : Type u_1\nÎ± : Type u_2\nE : Type u_3\nH : Type u_4\nhom : Type u_5\ninstâœÂ¹â° : NormedField ğ•œ\ninstâœâ¹ : AddCommGroup H\ninstâœâ¸ : Module ğ•œ H\ninstâœâ· : AddCommGroup E\ninstâœâ¶ : Module ğ•œ E\ninstâœâµ : TopologicalSpace H\ninstâœâ´ : UniformSpace E\ninstâœÂ³ : UniformAddGroup E\ninstâœÂ² : ContinuousSMul ğ•œ E\nğ”– : Set (Set Î±)\ninstâœÂ¹ : FunLike hom H (Î± â†’ E)\ninstâœ : LinearMapClass hom ğ•œ H (Î± â†’ E)\nÏ† : hom\nhÏ† : Topology.IsInducing (Function.comp â‡‘(UniformOnFun.ofFun ğ”–) â‡‘Ï†)\nh : âˆ€ (u : H) (s : Set Î±), Membership.mem ğ”– s â†’ Bornology.IsVonNBounded ğ•œ (Set.image (Ï† u) s)\nâŠ¢ ContinuousSMul ğ•œ H","decl":"/-- Let `E` be a TVS, `ğ”– : Set (Set Î±)` and `H` a submodule of `Î± â†’áµ¤[ğ”–] E`. If the image of any\n`S âˆˆ ğ”–` by any `u âˆˆ H` is bounded (in the sense of `Bornology.IsVonNBounded`), then `H`,\nequipped with the topology of `ğ”–`-convergence, is a TVS.\n\nFor convenience, we don't literally ask for `H : Submodule (Î± â†’áµ¤[ğ”–] E)`. Instead, we prove the\nresult for any vector space `H` equipped with a linear inducing to `Î± â†’áµ¤[ğ”–] E`, which is often\neasier to use. We also state the `Submodule` version as\n`UniformOnFun.continuousSMul_submodule_of_image_bounded`. -/\nlemma UniformOnFun.continuousSMul_induced_of_image_bounded (Ï† : hom) (hÏ† : IsInducing (ofFun ğ”– âˆ˜ Ï†))\n    (h : âˆ€ u : H, âˆ€ s âˆˆ ğ”–, Bornology.IsVonNBounded ğ•œ ((Ï† u : Î± â†’ E) '' s)) :\n    ContinuousSMul ğ•œ H := by\n  obtain rfl := hÏ†.eq_induced; clear hÏ†\n  simp only [induced_iInf, UniformOnFun.topologicalSpace_eq, induced_compose]\n  refine continuousSMul_iInf fun s â†¦ continuousSMul_iInf fun hs â†¦ ?_\n  letI : TopologicalSpace H :=\n    .induced (UniformFun.ofFun âˆ˜ s.restrict âˆ˜ Ï†) (UniformFun.topologicalSpace s E)\n  set Ï†' : H â†’â‚—[ğ•œ] (s â†’ E) :=\n    { toFun := s.restrict âˆ˜ Ï†,\n      map_smul' := fun c x â†¦ by exact congr_arg s.restrict (map_smul Ï† c x),\n      map_add' := fun x y â†¦ by exact congr_arg s.restrict (map_add Ï† x y) }\n  refine UniformFun.continuousSMul_induced_of_range_bounded ğ•œ s E H Ï†' âŸ¨rflâŸ© fun u â†¦ ?_\n  simpa only [Set.image_eq_range] using h u s hs\n\n"}
{"name":"UniformOnFun.continuousSMul_submodule_of_image_bounded","module":"Mathlib.Topology.Algebra.Module.UniformConvergence","initialProofState":"ğ•œ : Type u_1\nÎ± : Type u_2\nE : Type u_3\ninstâœâµ : NormedField ğ•œ\ninstâœâ´ : AddCommGroup E\ninstâœÂ³ : Module ğ•œ E\ninstâœÂ² : UniformSpace E\ninstâœÂ¹ : UniformAddGroup E\ninstâœ : ContinuousSMul ğ•œ E\nğ”– : Set (Set Î±)\nH : Submodule ğ•œ (UniformOnFun Î± E ğ”–)\nh : âˆ€ (u : UniformOnFun Î± E ğ”–), Membership.mem H u â†’ âˆ€ (s : Set Î±), Membership.mem ğ”– s â†’ Bornology.IsVonNBounded ğ•œ (Set.image u s)\nâŠ¢ ContinuousSMul ğ•œ (Subtype fun x => Membership.mem H x)","decl":"/-- Let `E` be a TVS, `ğ”– : Set (Set Î±)` and `H` a submodule of `Î± â†’áµ¤[ğ”–] E`. If the image of any\n`S âˆˆ ğ”–` by any `u âˆˆ H` is bounded (in the sense of `Bornology.IsVonNBounded`), then `H`,\nequipped with the topology of `ğ”–`-convergence, is a TVS.\n\nIf you have a hard time using this lemma, try the one above instead. -/\ntheorem UniformOnFun.continuousSMul_submodule_of_image_bounded (H : Submodule ğ•œ (Î± â†’áµ¤[ğ”–] E))\n    (h : âˆ€ u âˆˆ H, âˆ€ s âˆˆ ğ”–, Bornology.IsVonNBounded ğ•œ (u '' s)) :\n    @ContinuousSMul ğ•œ H _ _ ((UniformOnFun.topologicalSpace Î± E ğ”–).induced ((â†‘) : H â†’ Î± â†’áµ¤[ğ”–] E)) :=\n  UniformOnFun.continuousSMul_induced_of_image_bounded ğ•œ Î± E H\n    (LinearMap.id.domRestrict H : H â†’â‚—[ğ•œ] Î± â†’ E) IsInducing.subtypeVal fun âŸ¨u, huâŸ© => h u hu\n\n"}
