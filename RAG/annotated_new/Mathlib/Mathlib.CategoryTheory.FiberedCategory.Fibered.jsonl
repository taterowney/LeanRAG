{"name":"CategoryTheory.Functor.IsPreFibered.exists_isCartesian'","module":"Mathlib.CategoryTheory.FiberedCategory.Fibered","initialProofState":"𝒮 : Type u₁\n𝒳 : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} 𝒮\ninst✝ : CategoryTheory.Category.{v₂, u₂} 𝒳\np : CategoryTheory.Functor 𝒳 𝒮\nself : p.IsPreFibered\na : 𝒳\nR : 𝒮\nf : Quiver.Hom R (p.obj a)\n⊢ Exists fun b => Exists fun φ => p.IsCartesian f φ","decl":"/-- Definition of a prefibered category.\n\nSee SGA 1 VI.6.1. -/\nclass Functor.IsPreFibered (p : 𝒳 ⥤ 𝒮) : Prop where\n  exists_isCartesian' {a : 𝒳} {R : 𝒮} (f : R ⟶ p.obj a) : ∃ (b : 𝒳) (φ : b ⟶ a), IsCartesian p f φ\n\n"}
{"name":"CategoryTheory.IsPreFibered.exists_isCartesian","module":"Mathlib.CategoryTheory.FiberedCategory.Fibered","initialProofState":"𝒮 : Type u₁\n𝒳 : Type u₂\ninst✝² : CategoryTheory.Category.{v₁, u₁} 𝒮\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} 𝒳\np : CategoryTheory.Functor 𝒳 𝒮\ninst✝ : p.IsPreFibered\na : 𝒳\nR S : 𝒮\nha : Eq (p.obj a) S\nf : Quiver.Hom R S\n⊢ Exists fun b => Exists fun φ => p.IsCartesian f φ","decl":"protected lemma IsPreFibered.exists_isCartesian (p : 𝒳 ⥤ 𝒮) [p.IsPreFibered] {a : 𝒳} {R S : 𝒮}\n    (ha : p.obj a = S) (f : R ⟶ S) : ∃ (b : 𝒳) (φ : b ⟶ a), IsCartesian p f φ := by\n  subst ha; exact IsPreFibered.exists_isCartesian' f\n\n"}
{"name":"CategoryTheory.Functor.IsFibered.comp","module":"Mathlib.CategoryTheory.FiberedCategory.Fibered","initialProofState":"𝒮 : Type u₁\n𝒳 : Type u₂\ninst✝³ : CategoryTheory.Category.{v₁, u₁} 𝒮\ninst✝² : CategoryTheory.Category.{v₂, u₂} 𝒳\np : CategoryTheory.Functor 𝒳 𝒮\nself : p.IsFibered\nR S T : 𝒮\nf : Quiver.Hom R S\ng : Quiver.Hom S T\na b c : 𝒳\nφ : Quiver.Hom a b\nψ : Quiver.Hom b c\ninst✝¹ : p.IsCartesian f φ\ninst✝ : p.IsCartesian g ψ\n⊢ p.IsCartesian (CategoryTheory.CategoryStruct.comp f g) (CategoryTheory.CategoryStruct.comp φ ψ)","decl":"/-- Definition of a fibered category.\n\nSee SGA 1 VI.6.1. -/\nclass Functor.IsFibered (p : 𝒳 ⥤ 𝒮) extends IsPreFibered p : Prop where\n  comp {R S T : 𝒮} (f : R ⟶ S) (g : S ⟶ T) {a b c : 𝒳} (φ : a ⟶ b) (ψ : b ⟶ c)\n    [IsCartesian p f φ] [IsCartesian p g ψ] : IsCartesian p (f ≫ g) (φ ≫ ψ)\n\n"}
{"name":"CategoryTheory.Functor.IsFibered.toIsPreFibered","module":"Mathlib.CategoryTheory.FiberedCategory.Fibered","initialProofState":"𝒮 : Type u₁\n𝒳 : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} 𝒮\ninst✝ : CategoryTheory.Category.{v₂, u₂} 𝒳\np : CategoryTheory.Functor 𝒳 𝒮\nself : p.IsFibered\n⊢ p.IsPreFibered","decl":"/-- Definition of a fibered category.\n\nSee SGA 1 VI.6.1. -/\nclass Functor.IsFibered (p : 𝒳 ⥤ 𝒮) extends IsPreFibered p : Prop where\n  comp {R S T : 𝒮} (f : R ⟶ S) (g : S ⟶ T) {a b c : 𝒳} (φ : a ⟶ b) (ψ : b ⟶ c)\n    [IsCartesian p f φ] [IsCartesian p g ψ] : IsCartesian p (f ≫ g) (φ ≫ ψ)\n\n"}
{"name":"CategoryTheory.instIsCartesianCompOfIsFibered","module":"Mathlib.CategoryTheory.FiberedCategory.Fibered","initialProofState":"𝒮 : Type u₁\n𝒳 : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} 𝒮\ninst✝³ : CategoryTheory.Category.{v₂, u₂} 𝒳\np : CategoryTheory.Functor 𝒳 𝒮\ninst✝² : p.IsFibered\nR S T : 𝒮\nf : Quiver.Hom R S\ng : Quiver.Hom S T\na b c : 𝒳\nφ : Quiver.Hom a b\nψ : Quiver.Hom b c\ninst✝¹ : p.IsCartesian f φ\ninst✝ : p.IsCartesian g ψ\n⊢ p.IsCartesian (CategoryTheory.CategoryStruct.comp f g) (CategoryTheory.CategoryStruct.comp φ ψ)","decl":"instance (p : 𝒳 ⥤ 𝒮) [p.IsFibered] {R S T : 𝒮} (f : R ⟶ S) (g : S ⟶ T) {a b c : 𝒳} (φ : a ⟶ b)\n    (ψ : b ⟶ c) [IsCartesian p f φ] [IsCartesian p g ψ] : IsCartesian p (f ≫ g) (φ ≫ ψ) :=\n  IsFibered.comp f g φ ψ\n\n"}
{"name":"CategoryTheory.Functor.IsPreFibered.pullbackMap.IsCartesian","module":"Mathlib.CategoryTheory.FiberedCategory.Fibered","initialProofState":"𝒮 : Type u₁\n𝒳 : Type u₂\ninst✝² : CategoryTheory.Category.{v₁, u₁} 𝒮\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} 𝒳\np : CategoryTheory.Functor 𝒳 𝒮\ninst✝ : p.IsPreFibered\nR S : 𝒮\na : 𝒳\nha : Eq (p.obj a) S\nf : Quiver.Hom R S\n⊢ p.IsCartesian f (CategoryTheory.Functor.IsPreFibered.pullbackMap ha f)","decl":"instance pullbackMap.IsCartesian : IsCartesian p f (pullbackMap ha f) :=\n  Classical.choose_spec (Classical.choose_spec (IsPreFibered.exists_isCartesian p ha f))\n\n"}
{"name":"CategoryTheory.Functor.IsPreFibered.pullbackObj_proj","module":"Mathlib.CategoryTheory.FiberedCategory.Fibered","initialProofState":"𝒮 : Type u₁\n𝒳 : Type u₂\ninst✝² : CategoryTheory.Category.{v₁, u₁} 𝒮\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} 𝒳\np : CategoryTheory.Functor 𝒳 𝒮\ninst✝ : p.IsPreFibered\nR S : 𝒮\na : 𝒳\nha : Eq (p.obj a) S\nf : Quiver.Hom R S\n⊢ Eq (p.obj (CategoryTheory.Functor.IsPreFibered.pullbackObj ha f)) R","decl":"lemma pullbackObj_proj : p.obj (pullbackObj ha f) = R :=\n  domain_eq p f (pullbackMap ha f)\n\n"}
{"name":"CategoryTheory.Functor.IsFibered.isStronglyCartesian_of_isCartesian","module":"Mathlib.CategoryTheory.FiberedCategory.Fibered","initialProofState":"𝒮 : Type u₁\n𝒳 : Type u₂\ninst✝³ : CategoryTheory.Category.{v₁, u₁} 𝒮\ninst✝² : CategoryTheory.Category.{v₂, u₂} 𝒳\np : CategoryTheory.Functor 𝒳 𝒮\ninst✝¹ : p.IsFibered\nR S : 𝒮\nf : Quiver.Hom R S\na b : 𝒳\nφ : Quiver.Hom a b\ninst✝ : p.IsCartesian f φ\n⊢ p.IsStronglyCartesian f φ","decl":"/-- In a fibered category, any cartesian morphism is strongly cartesian. -/\ninstance isStronglyCartesian_of_isCartesian (p : 𝒳 ⥤ 𝒮) [p.IsFibered] {R S : 𝒮} (f : R ⟶ S)\n    {a b : 𝒳} (φ : a ⟶ b) [p.IsCartesian f φ] : p.IsStronglyCartesian f φ where\n  universal_property' g φ' hφ' := by\n    -- Let `ψ` be a cartesian arrow lying over `g`\n    let ψ := pullbackMap (domain_eq p f φ) g\n    -- Let `τ` be the map induced by the universal property of `ψ ≫ φ`.\n    let τ := IsCartesian.map p (g ≫ f) (ψ ≫ φ) φ'\n    use τ ≫ ψ\n    -- It is easily verified that `τ ≫ ψ` lifts `g` and `τ ≫ ψ ≫ φ = φ'`\n    refine ⟨⟨inferInstance, by simp only [assoc, IsCartesian.fac, τ]⟩, ?_⟩\n    -- It remains to check that `τ ≫ ψ` is unique.\n    -- So fix another lift `π` of `g` satisfying `π ≫ φ = φ'`.\n    intro π ⟨hπ, hπ_comp⟩\n    -- Write `π` as `π = τ' ≫ ψ` for some `τ'` induced by the universal property of `ψ`.\n    rw [← fac p g ψ π]\n    -- It remains to show that `τ' = τ`. This follows again from the universal property of `ψ`.\n    congr 1\n    apply map_uniq\n    rwa [← assoc, IsCartesian.fac]\n\n"}
{"name":"CategoryTheory.Functor.IsFibered.isStronglyCartesian_of_exists_isCartesian","module":"Mathlib.CategoryTheory.FiberedCategory.Fibered","initialProofState":"𝒮 : Type u₁\n𝒳 : Type u₂\ninst✝² : CategoryTheory.Category.{v₁, u₁} 𝒮\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} 𝒳\np : CategoryTheory.Functor 𝒳 𝒮\nh : ∀ (a : 𝒳) (R : 𝒮) (f : Quiver.Hom R (p.obj a)), Exists fun b => Exists fun φ => p.IsStronglyCartesian f φ\nR S : 𝒮\nf : Quiver.Hom R S\na b : 𝒳\nφ : Quiver.Hom a b\ninst✝ : p.IsCartesian f φ\n⊢ p.IsStronglyCartesian f φ","decl":"/-- In a category which admits strongly cartesian pullbacks, any cartesian morphism is\nstrongly cartesian. This is a helper-lemma for the fact that admitting strongly cartesian pullbacks\nimplies being fibered. -/\nlemma isStronglyCartesian_of_exists_isCartesian (p : 𝒳 ⥤ 𝒮) (h : ∀ (a : 𝒳) (R : 𝒮)\n    (f : R ⟶ p.obj a), ∃ (b : 𝒳) (φ : b ⟶ a), IsStronglyCartesian p f φ) {R S : 𝒮} (f : R ⟶ S)\n      {a b : 𝒳} (φ : a ⟶ b) [p.IsCartesian f φ] : p.IsStronglyCartesian f φ := by\n  constructor\n  intro c g φ' hφ'\n  subst_hom_lift p f φ; clear a b R S\n  -- Let `ψ` be a cartesian arrow lying over `g`\n  obtain ⟨a', ψ, hψ⟩ := h _ _ (p.map φ)\n  -- Let `τ' : c ⟶ a'` be the map induced by the universal property of `ψ`\n  let τ' := IsStronglyCartesian.map p (p.map φ) ψ (f':= g ≫ p.map φ) rfl φ'\n  -- Let `Φ : a' ≅ a` be natural isomorphism induced between `φ` and `ψ`.\n  let Φ := domainUniqueUpToIso p (p.map φ) φ ψ\n  -- The map induced by `φ` will be `τ' ≫ Φ.hom`\n  use τ' ≫ Φ.hom\n  -- It is easily verified that `τ' ≫ Φ.hom` lifts `g` and `τ' ≫ Φ.hom ≫ φ = φ'`\n  refine ⟨⟨by simp only [Φ]; infer_instance, ?_⟩, ?_⟩\n  · simp [τ', Φ, IsStronglyCartesian.map_uniq p (p.map φ) ψ rfl φ']\n  -- It remains to check that it is unique. This follows from the universal property of `ψ`.\n  intro π ⟨hπ, hπ_comp⟩\n  rw [← Iso.comp_inv_eq]\n  apply IsStronglyCartesian.map_uniq p (p.map φ) ψ rfl φ'\n  simp [hπ_comp, Φ]\n\n"}
{"name":"CategoryTheory.Functor.IsFibered.of_exists_isStronglyCartesian","module":"Mathlib.CategoryTheory.FiberedCategory.Fibered","initialProofState":"𝒮 : Type u₁\n𝒳 : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} 𝒮\ninst✝ : CategoryTheory.Category.{v₂, u₂} 𝒳\np : CategoryTheory.Functor 𝒳 𝒮\nh : ∀ (a : 𝒳) (R : 𝒮) (f : Quiver.Hom R (p.obj a)), Exists fun b => Exists fun φ => p.IsStronglyCartesian f φ\n⊢ p.IsFibered","decl":"/-- Alternate constructor for `IsFibered`, a functor `p : 𝒳 ⥤ 𝒴` is fibered if any diagram of the\nform\n```\n          a\n          -\n          |\n          v\nR --f--> p(a)\n```\nadmits a strongly cartesian lift `b ⟶ a` of `f`. -/\nlemma of_exists_isStronglyCartesian {p : 𝒳 ⥤ 𝒮}\n    (h : ∀ (a : 𝒳) (R : 𝒮) (f : R ⟶ p.obj a),\n      ∃ (b : 𝒳) (φ : b ⟶ a), IsStronglyCartesian p f φ) :\n    IsFibered p where\n  exists_isCartesian' := by\n    intro a R f\n    obtain ⟨b, φ, hφ⟩ := h a R f\n    refine ⟨b, φ, inferInstance⟩\n  comp := fun R S T f g {a b c} φ ψ _ _ =>\n    have : p.IsStronglyCartesian f φ := isStronglyCartesian_of_exists_isCartesian p h _ _\n    have : p.IsStronglyCartesian g ψ := isStronglyCartesian_of_exists_isCartesian p h _ _\n    inferInstance\n\n"}
