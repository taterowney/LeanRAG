{"name":"CategoryTheory.Functor.IsPreFibered.exists_isCartesian'","module":"Mathlib.CategoryTheory.FiberedCategory.Fibered","initialProofState":"ð’® : Type uâ‚\nð’³ : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} ð’®\ninstâœ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} ð’³\np : CategoryTheory.Functor ð’³ ð’®\nself : p.IsPreFibered\na : ð’³\nR : ð’®\nf : Quiver.Hom R (p.obj a)\nâŠ¢ Exists fun b => Exists fun Ï† => p.IsCartesian f Ï†","decl":"/-- Definition of a prefibered category.\n\nSee SGA 1 VI.6.1. -/\nclass Functor.IsPreFibered (p : ð’³ â¥¤ ð’®) : Prop where\n  exists_isCartesian' {a : ð’³} {R : ð’®} (f : R âŸ¶ p.obj a) : âˆƒ (b : ð’³) (Ï† : b âŸ¶ a), IsCartesian p f Ï†\n\n"}
{"name":"CategoryTheory.IsPreFibered.exists_isCartesian","module":"Mathlib.CategoryTheory.FiberedCategory.Fibered","initialProofState":"ð’® : Type uâ‚\nð’³ : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} ð’®\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} ð’³\np : CategoryTheory.Functor ð’³ ð’®\ninstâœ : p.IsPreFibered\na : ð’³\nR S : ð’®\nha : Eq (p.obj a) S\nf : Quiver.Hom R S\nâŠ¢ Exists fun b => Exists fun Ï† => p.IsCartesian f Ï†","decl":"protected lemma IsPreFibered.exists_isCartesian (p : ð’³ â¥¤ ð’®) [p.IsPreFibered] {a : ð’³} {R S : ð’®}\n    (ha : p.obj a = S) (f : R âŸ¶ S) : âˆƒ (b : ð’³) (Ï† : b âŸ¶ a), IsCartesian p f Ï† := by\n  subst ha; exact IsPreFibered.exists_isCartesian' f\n\n"}
{"name":"CategoryTheory.Functor.IsFibered.comp","module":"Mathlib.CategoryTheory.FiberedCategory.Fibered","initialProofState":"ð’® : Type uâ‚\nð’³ : Type uâ‚‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} ð’®\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} ð’³\np : CategoryTheory.Functor ð’³ ð’®\nself : p.IsFibered\nR S T : ð’®\nf : Quiver.Hom R S\ng : Quiver.Hom S T\na b c : ð’³\nÏ† : Quiver.Hom a b\nÏˆ : Quiver.Hom b c\ninstâœÂ¹ : p.IsCartesian f Ï†\ninstâœ : p.IsCartesian g Ïˆ\nâŠ¢ p.IsCartesian (CategoryTheory.CategoryStruct.comp f g) (CategoryTheory.CategoryStruct.comp Ï† Ïˆ)","decl":"/-- Definition of a fibered category.\n\nSee SGA 1 VI.6.1. -/\nclass Functor.IsFibered (p : ð’³ â¥¤ ð’®) extends IsPreFibered p : Prop where\n  comp {R S T : ð’®} (f : R âŸ¶ S) (g : S âŸ¶ T) {a b c : ð’³} (Ï† : a âŸ¶ b) (Ïˆ : b âŸ¶ c)\n    [IsCartesian p f Ï†] [IsCartesian p g Ïˆ] : IsCartesian p (f â‰« g) (Ï† â‰« Ïˆ)\n\n"}
{"name":"CategoryTheory.Functor.IsFibered.toIsPreFibered","module":"Mathlib.CategoryTheory.FiberedCategory.Fibered","initialProofState":"ð’® : Type uâ‚\nð’³ : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} ð’®\ninstâœ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} ð’³\np : CategoryTheory.Functor ð’³ ð’®\nself : p.IsFibered\nâŠ¢ p.IsPreFibered","decl":"/-- Definition of a fibered category.\n\nSee SGA 1 VI.6.1. -/\nclass Functor.IsFibered (p : ð’³ â¥¤ ð’®) extends IsPreFibered p : Prop where\n  comp {R S T : ð’®} (f : R âŸ¶ S) (g : S âŸ¶ T) {a b c : ð’³} (Ï† : a âŸ¶ b) (Ïˆ : b âŸ¶ c)\n    [IsCartesian p f Ï†] [IsCartesian p g Ïˆ] : IsCartesian p (f â‰« g) (Ï† â‰« Ïˆ)\n\n"}
{"name":"CategoryTheory.instIsCartesianCompOfIsFibered","module":"Mathlib.CategoryTheory.FiberedCategory.Fibered","initialProofState":"ð’® : Type uâ‚\nð’³ : Type uâ‚‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} ð’®\ninstâœÂ³ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} ð’³\np : CategoryTheory.Functor ð’³ ð’®\ninstâœÂ² : p.IsFibered\nR S T : ð’®\nf : Quiver.Hom R S\ng : Quiver.Hom S T\na b c : ð’³\nÏ† : Quiver.Hom a b\nÏˆ : Quiver.Hom b c\ninstâœÂ¹ : p.IsCartesian f Ï†\ninstâœ : p.IsCartesian g Ïˆ\nâŠ¢ p.IsCartesian (CategoryTheory.CategoryStruct.comp f g) (CategoryTheory.CategoryStruct.comp Ï† Ïˆ)","decl":"instance (p : ð’³ â¥¤ ð’®) [p.IsFibered] {R S T : ð’®} (f : R âŸ¶ S) (g : S âŸ¶ T) {a b c : ð’³} (Ï† : a âŸ¶ b)\n    (Ïˆ : b âŸ¶ c) [IsCartesian p f Ï†] [IsCartesian p g Ïˆ] : IsCartesian p (f â‰« g) (Ï† â‰« Ïˆ) :=\n  IsFibered.comp f g Ï† Ïˆ\n\n"}
{"name":"CategoryTheory.Functor.IsPreFibered.pullbackMap.IsCartesian","module":"Mathlib.CategoryTheory.FiberedCategory.Fibered","initialProofState":"ð’® : Type uâ‚\nð’³ : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} ð’®\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} ð’³\np : CategoryTheory.Functor ð’³ ð’®\ninstâœ : p.IsPreFibered\nR S : ð’®\na : ð’³\nha : Eq (p.obj a) S\nf : Quiver.Hom R S\nâŠ¢ p.IsCartesian f (CategoryTheory.Functor.IsPreFibered.pullbackMap ha f)","decl":"instance pullbackMap.IsCartesian : IsCartesian p f (pullbackMap ha f) :=\n  Classical.choose_spec (Classical.choose_spec (IsPreFibered.exists_isCartesian p ha f))\n\n"}
{"name":"CategoryTheory.Functor.IsPreFibered.pullbackObj_proj","module":"Mathlib.CategoryTheory.FiberedCategory.Fibered","initialProofState":"ð’® : Type uâ‚\nð’³ : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} ð’®\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} ð’³\np : CategoryTheory.Functor ð’³ ð’®\ninstâœ : p.IsPreFibered\nR S : ð’®\na : ð’³\nha : Eq (p.obj a) S\nf : Quiver.Hom R S\nâŠ¢ Eq (p.obj (CategoryTheory.Functor.IsPreFibered.pullbackObj ha f)) R","decl":"lemma pullbackObj_proj : p.obj (pullbackObj ha f) = R :=\n  domain_eq p f (pullbackMap ha f)\n\n"}
{"name":"CategoryTheory.Functor.IsFibered.isStronglyCartesian_of_isCartesian","module":"Mathlib.CategoryTheory.FiberedCategory.Fibered","initialProofState":"ð’® : Type uâ‚\nð’³ : Type uâ‚‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} ð’®\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} ð’³\np : CategoryTheory.Functor ð’³ ð’®\ninstâœÂ¹ : p.IsFibered\nR S : ð’®\nf : Quiver.Hom R S\na b : ð’³\nÏ† : Quiver.Hom a b\ninstâœ : p.IsCartesian f Ï†\nâŠ¢ p.IsStronglyCartesian f Ï†","decl":"/-- In a fibered category, any cartesian morphism is strongly cartesian. -/\ninstance isStronglyCartesian_of_isCartesian (p : ð’³ â¥¤ ð’®) [p.IsFibered] {R S : ð’®} (f : R âŸ¶ S)\n    {a b : ð’³} (Ï† : a âŸ¶ b) [p.IsCartesian f Ï†] : p.IsStronglyCartesian f Ï† where\n  universal_property' g Ï†' hÏ†' := by\n    -- Let `Ïˆ` be a cartesian arrow lying over `g`\n    let Ïˆ := pullbackMap (domain_eq p f Ï†) g\n    -- Let `Ï„` be the map induced by the universal property of `Ïˆ â‰« Ï†`.\n    let Ï„ := IsCartesian.map p (g â‰« f) (Ïˆ â‰« Ï†) Ï†'\n    use Ï„ â‰« Ïˆ\n    -- It is easily verified that `Ï„ â‰« Ïˆ` lifts `g` and `Ï„ â‰« Ïˆ â‰« Ï† = Ï†'`\n    refine âŸ¨âŸ¨inferInstance, by simp only [assoc, IsCartesian.fac, Ï„]âŸ©, ?_âŸ©\n    -- It remains to check that `Ï„ â‰« Ïˆ` is unique.\n    -- So fix another lift `Ï€` of `g` satisfying `Ï€ â‰« Ï† = Ï†'`.\n    intro Ï€ âŸ¨hÏ€, hÏ€_compâŸ©\n    -- Write `Ï€` as `Ï€ = Ï„' â‰« Ïˆ` for some `Ï„'` induced by the universal property of `Ïˆ`.\n    rw [â† fac p g Ïˆ Ï€]\n    -- It remains to show that `Ï„' = Ï„`. This follows again from the universal property of `Ïˆ`.\n    congr 1\n    apply map_uniq\n    rwa [â† assoc, IsCartesian.fac]\n\n"}
{"name":"CategoryTheory.Functor.IsFibered.isStronglyCartesian_of_exists_isCartesian","module":"Mathlib.CategoryTheory.FiberedCategory.Fibered","initialProofState":"ð’® : Type uâ‚\nð’³ : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} ð’®\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} ð’³\np : CategoryTheory.Functor ð’³ ð’®\nh : âˆ€ (a : ð’³) (R : ð’®) (f : Quiver.Hom R (p.obj a)), Exists fun b => Exists fun Ï† => p.IsStronglyCartesian f Ï†\nR S : ð’®\nf : Quiver.Hom R S\na b : ð’³\nÏ† : Quiver.Hom a b\ninstâœ : p.IsCartesian f Ï†\nâŠ¢ p.IsStronglyCartesian f Ï†","decl":"/-- In a category which admits strongly cartesian pullbacks, any cartesian morphism is\nstrongly cartesian. This is a helper-lemma for the fact that admitting strongly cartesian pullbacks\nimplies being fibered. -/\nlemma isStronglyCartesian_of_exists_isCartesian (p : ð’³ â¥¤ ð’®) (h : âˆ€ (a : ð’³) (R : ð’®)\n    (f : R âŸ¶ p.obj a), âˆƒ (b : ð’³) (Ï† : b âŸ¶ a), IsStronglyCartesian p f Ï†) {R S : ð’®} (f : R âŸ¶ S)\n      {a b : ð’³} (Ï† : a âŸ¶ b) [p.IsCartesian f Ï†] : p.IsStronglyCartesian f Ï† := by\n  constructor\n  intro c g Ï†' hÏ†'\n  subst_hom_lift p f Ï†; clear a b R S\n  -- Let `Ïˆ` be a cartesian arrow lying over `g`\n  obtain âŸ¨a', Ïˆ, hÏˆâŸ© := h _ _ (p.map Ï†)\n  -- Let `Ï„' : c âŸ¶ a'` be the map induced by the universal property of `Ïˆ`\n  let Ï„' := IsStronglyCartesian.map p (p.map Ï†) Ïˆ (f':= g â‰« p.map Ï†) rfl Ï†'\n  -- Let `Î¦ : a' â‰… a` be natural isomorphism induced between `Ï†` and `Ïˆ`.\n  let Î¦ := domainUniqueUpToIso p (p.map Ï†) Ï† Ïˆ\n  -- The map induced by `Ï†` will be `Ï„' â‰« Î¦.hom`\n  use Ï„' â‰« Î¦.hom\n  -- It is easily verified that `Ï„' â‰« Î¦.hom` lifts `g` and `Ï„' â‰« Î¦.hom â‰« Ï† = Ï†'`\n  refine âŸ¨âŸ¨by simp only [Î¦]; infer_instance, ?_âŸ©, ?_âŸ©\n  Â· simp [Ï„', Î¦, IsStronglyCartesian.map_uniq p (p.map Ï†) Ïˆ rfl Ï†']\n  -- It remains to check that it is unique. This follows from the universal property of `Ïˆ`.\n  intro Ï€ âŸ¨hÏ€, hÏ€_compâŸ©\n  rw [â† Iso.comp_inv_eq]\n  apply IsStronglyCartesian.map_uniq p (p.map Ï†) Ïˆ rfl Ï†'\n  simp [hÏ€_comp, Î¦]\n\n"}
{"name":"CategoryTheory.Functor.IsFibered.of_exists_isStronglyCartesian","module":"Mathlib.CategoryTheory.FiberedCategory.Fibered","initialProofState":"ð’® : Type uâ‚\nð’³ : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} ð’®\ninstâœ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} ð’³\np : CategoryTheory.Functor ð’³ ð’®\nh : âˆ€ (a : ð’³) (R : ð’®) (f : Quiver.Hom R (p.obj a)), Exists fun b => Exists fun Ï† => p.IsStronglyCartesian f Ï†\nâŠ¢ p.IsFibered","decl":"/-- Alternate constructor for `IsFibered`, a functor `p : ð’³ â¥¤ ð’´` is fibered if any diagram of the\nform\n```\n          a\n          -\n          |\n          v\nR --f--> p(a)\n```\nadmits a strongly cartesian lift `b âŸ¶ a` of `f`. -/\nlemma of_exists_isStronglyCartesian {p : ð’³ â¥¤ ð’®}\n    (h : âˆ€ (a : ð’³) (R : ð’®) (f : R âŸ¶ p.obj a),\n      âˆƒ (b : ð’³) (Ï† : b âŸ¶ a), IsStronglyCartesian p f Ï†) :\n    IsFibered p where\n  exists_isCartesian' := by\n    intro a R f\n    obtain âŸ¨b, Ï†, hÏ†âŸ© := h a R f\n    refine âŸ¨b, Ï†, inferInstanceâŸ©\n  comp := fun R S T f g {a b c} Ï† Ïˆ _ _ =>\n    have : p.IsStronglyCartesian f Ï† := isStronglyCartesian_of_exists_isCartesian p h _ _\n    have : p.IsStronglyCartesian g Ïˆ := isStronglyCartesian_of_exists_isCartesian p h _ _\n    inferInstance\n\n"}
