{"name":"FinEnum.recEmptyOption_of_card_eq_zero","module":"Mathlib.Data.FinEnum.Option","initialProofState":"P : Type u → Sort v\nfinChoice : (n : Nat) → Fin (HAdd.hAdd n 1)\ncongr : {α β : Type u} → (x : FinEnum α) → (x_1 : FinEnum β) → Eq (FinEnum.card β) (FinEnum.card α) → P α → P β\nempty : P PEmpty.{u + 1}\noption : {α : Type u} → FinEnum α → P α → P (Option α)\nα : Type u\ninst✝ : FinEnum α\nh : Eq (FinEnum.card α) 0\nx✝ : FinEnum PEmpty.{u + 1}\n⊢ Eq (FinEnum.recEmptyOption finChoice (fun {α β} => congr) empty (fun {α} => option) α) (congr x✝ inst✝ ⋯ empty)","decl":"/--\nFor an empty type, the recursion principle evaluates to whatever `congr`\nmakes of the base case.\n-/\ntheorem recEmptyOption_of_card_eq_zero {P : Type u → Sort v}\n    (finChoice : (n : ℕ) → Fin (n + 1))\n    (congr : {α β : Type u} → (_ : FinEnum α) → (_ : FinEnum β) → card β = card α → P α → P β)\n    (empty : P PEmpty.{u + 1})\n    (option : {α : Type u} → FinEnum α → P α → P (Option α))\n    (α : Type u) [FinEnum α] (h : card α = 0) (_ : FinEnum PEmpty.{u + 1}) :\n    recEmptyOption finChoice congr empty option α =\n      congr _ _ (h.trans card_eq_zero.symm) empty := by\n  unfold recEmptyOption\n  split\n  · congr 1; exact Subsingleton.allEq _ _\n  · exact Nat.noConfusion <| h.symm.trans ‹_›\n\n"}
{"name":"FinEnum.recEmptyOption_of_card_pos","module":"Mathlib.Data.FinEnum.Option","initialProofState":"P : Type u → Sort v\nfinChoice : (n : Nat) → Fin (HAdd.hAdd n 1)\ncongr : {α β : Type u} → (x : FinEnum α) → (x_1 : FinEnum β) → Eq (FinEnum.card β) (FinEnum.card α) → P α → P β\nempty : P PEmpty.{u + 1}\noption : {α : Type u} → FinEnum α → P α → P (Option α)\nα : Type u\ninst✝ : FinEnum α\nh : LT.lt 0 (FinEnum.card α)\n⊢ Eq (FinEnum.recEmptyOption finChoice (fun {α β} => congr) empty (fun {α} => option) α) (congr (FinEnum.insertNone (ULift.{u, 0} (Fin (HSub.hSub (FinEnum.card α) 1))) ↑↑(finChoice (HSub.hSub (FinEnum.card α) 1))) inst✝ ⋯ (option ULift.instFinEnum (FinEnum.recEmptyOption finChoice (fun {α β} => congr) empty (fun {α} => option) (ULift.{u, 0} (Fin (HSub.hSub (FinEnum.card α) 1))))))","decl":"/--\nFor a type with positive `card`, the recursion principle evaluates to whatever\n`congr` makes of the step result, where `Option.none` has been inserted into the\n`(finChoice (card α - 1))`th rank of the enumeration.\n-/\ntheorem recEmptyOption_of_card_pos {P : Type u → Sort v}\n    (finChoice : (n : ℕ) → Fin (n + 1))\n    (congr : {α β : Type u} → (_ : FinEnum α) → (_ : FinEnum β) → card β = card α → P α → P β)\n    (empty : P PEmpty.{u + 1})\n    (option : {α : Type u} → FinEnum α → P α → P (Option α))\n    (α : Type u) [FinEnum α] (h : 0 < card α) :\n    recEmptyOption finChoice congr empty option α =\n      congr (insertNone _ <| finChoice (card α - 1)) ‹_›\n        (congrArg (· + 1) card_fin |>.trans <| (card α).succ_pred_eq_of_pos h).symm\n        (option ULift.instFinEnum <|\n          recEmptyOption finChoice congr empty option (ULift.{u} <| Fin (card α - 1))) := by\n  conv => lhs; unfold recEmptyOption\n  split\n  · exact absurd (‹_› ▸ h) (card α).lt_irrefl\n  · rcases Nat.succ.inj <| (card α).succ_pred_eq_of_pos h |>.trans ‹_› with rfl; rfl\n\n"}
