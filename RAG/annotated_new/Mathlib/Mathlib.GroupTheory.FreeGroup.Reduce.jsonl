{"name":"FreeAddGroup.reduce_nil","module":"Mathlib.GroupTheory.FreeGroup.Reduce","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\n⊢ Eq (FreeAddGroup.reduce List.nil) List.nil","decl":"@[to_additive (attr := simp)] lemma reduce_nil : reduce ([] : List (α × Bool)) = [] := rfl\n"}
{"name":"FreeGroup.reduce_nil","module":"Mathlib.GroupTheory.FreeGroup.Reduce","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\n⊢ Eq (FreeGroup.reduce List.nil) List.nil","decl":"@[to_additive (attr := simp)] lemma reduce_nil : reduce ([] : List (α × Bool)) = [] := rfl\n"}
{"name":"FreeGroup.reduce_singleton","module":"Mathlib.GroupTheory.FreeGroup.Reduce","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : Prod α Bool\n⊢ Eq (FreeGroup.reduce (List.cons s List.nil)) (List.cons s List.nil)","decl":"@[to_additive] lemma reduce_singleton (s : α × Bool) : reduce [s] = [s] := rfl\n\n"}
{"name":"FreeAddGroup.reduce_singleton","module":"Mathlib.GroupTheory.FreeGroup.Reduce","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : Prod α Bool\n⊢ Eq (FreeAddGroup.reduce (List.cons s List.nil)) (List.cons s List.nil)","decl":"@[to_additive] lemma reduce_singleton (s : α × Bool) : reduce [s] = [s] := rfl\n\n"}
{"name":"FreeAddGroup.reduce.cons","module":"Mathlib.GroupTheory.FreeGroup.Reduce","initialProofState":"α : Type u_1\nL : List (Prod α Bool)\ninst✝ : DecidableEq α\nx : Prod α Bool\n⊢ Eq (FreeAddGroup.reduce (List.cons x L)) (List.casesOn (FreeAddGroup.reduce L) (List.cons x List.nil) fun hd tl => ite (And (Eq x.1 hd.1) (Eq x.2 hd.2.not)) tl (List.cons x (List.cons hd tl)))","decl":"@[to_additive (attr := simp)]\ntheorem reduce.cons (x) :\n    reduce (x :: L) =\n      List.casesOn (reduce L) [x] fun hd tl =>\n        if x.1 = hd.1 ∧ x.2 = not hd.2 then tl else x :: hd :: tl :=\n  rfl\n\n"}
{"name":"FreeGroup.reduce.cons","module":"Mathlib.GroupTheory.FreeGroup.Reduce","initialProofState":"α : Type u_1\nL : List (Prod α Bool)\ninst✝ : DecidableEq α\nx : Prod α Bool\n⊢ Eq (FreeGroup.reduce (List.cons x L)) (List.casesOn (FreeGroup.reduce L) (List.cons x List.nil) fun hd tl => ite (And (Eq x.1 hd.1) (Eq x.2 hd.2.not)) tl (List.cons x (List.cons hd tl)))","decl":"@[to_additive (attr := simp)]\ntheorem reduce.cons (x) :\n    reduce (x :: L) =\n      List.casesOn (reduce L) [x] fun hd tl =>\n        if x.1 = hd.1 ∧ x.2 = not hd.2 then tl else x :: hd :: tl :=\n  rfl\n\n"}
{"name":"FreeGroup.reduce_replicate","module":"Mathlib.GroupTheory.FreeGroup.Reduce","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nn : Nat\nx : Prod α Bool\n⊢ Eq (FreeGroup.reduce (List.replicate n x)) (List.replicate n x)","decl":"@[to_additive (attr := simp)]\ntheorem reduce_replicate (n : ℕ) (x : α × Bool) :\n    reduce (.replicate n x) = .replicate n x := by\n  induction n with\n  | zero => simp [reduce]\n  | succ n ih =>\n    rw [List.replicate_succ, reduce.cons, ih]\n    cases n with\n    | zero => simp\n    | succ n => simp [List.replicate_succ]\n\n"}
{"name":"FreeAddGroup.reduce_replicate","module":"Mathlib.GroupTheory.FreeGroup.Reduce","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nn : Nat\nx : Prod α Bool\n⊢ Eq (FreeAddGroup.reduce (List.replicate n x)) (List.replicate n x)","decl":"@[to_additive (attr := simp)]\ntheorem reduce_replicate (n : ℕ) (x : α × Bool) :\n    reduce (.replicate n x) = .replicate n x := by\n  induction n with\n  | zero => simp [reduce]\n  | succ n ih =>\n    rw [List.replicate_succ, reduce.cons, ih]\n    cases n with\n    | zero => simp\n    | succ n => simp [List.replicate_succ]\n\n"}
{"name":"FreeAddGroup.reduce.red","module":"Mathlib.GroupTheory.FreeGroup.Reduce","initialProofState":"α : Type u_1\nL : List (Prod α Bool)\ninst✝ : DecidableEq α\n⊢ FreeAddGroup.Red L (FreeAddGroup.reduce L)","decl":"/-- The first theorem that characterises the function `reduce`: a word reduces to its maximal\n  reduction. -/\n@[to_additive \"The first theorem that characterises the function `reduce`: a word reduces to its\n  maximal reduction.\"]\ntheorem reduce.red : Red L (reduce L) := by\n  induction L with\n  | nil => constructor\n  | cons hd1 tl1 ih =>\n    dsimp\n    revert ih\n    generalize htl : reduce tl1 = TL\n    intro ih\n    cases TL with\n    | nil => exact Red.cons_cons ih\n    | cons hd2 tl2 =>\n      dsimp only\n      split_ifs with h\n      · cases hd1\n        cases hd2\n        cases h\n        dsimp at *\n        subst_vars\n        apply Red.trans (Red.cons_cons ih)\n        exact Red.Step.cons_not_rev.to_red\n      · exact Red.cons_cons ih\n\n"}
{"name":"FreeGroup.reduce.red","module":"Mathlib.GroupTheory.FreeGroup.Reduce","initialProofState":"α : Type u_1\nL : List (Prod α Bool)\ninst✝ : DecidableEq α\n⊢ FreeGroup.Red L (FreeGroup.reduce L)","decl":"/-- The first theorem that characterises the function `reduce`: a word reduces to its maximal\n  reduction. -/\n@[to_additive \"The first theorem that characterises the function `reduce`: a word reduces to its\n  maximal reduction.\"]\ntheorem reduce.red : Red L (reduce L) := by\n  induction L with\n  | nil => constructor\n  | cons hd1 tl1 ih =>\n    dsimp\n    revert ih\n    generalize htl : reduce tl1 = TL\n    intro ih\n    cases TL with\n    | nil => exact Red.cons_cons ih\n    | cons hd2 tl2 =>\n      dsimp only\n      split_ifs with h\n      · cases hd1\n        cases hd2\n        cases h\n        dsimp at *\n        subst_vars\n        apply Red.trans (Red.cons_cons ih)\n        exact Red.Step.cons_not_rev.to_red\n      · exact Red.cons_cons ih\n\n"}
{"name":"FreeGroup.reduce.not","module":"Mathlib.GroupTheory.FreeGroup.Reduce","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\np : Prop\nL₁ L₂ L₃ : List (Prod α Bool)\nx : α\nb : Bool\na✝ : Eq (FreeGroup.reduce L₁) (HAppend.hAppend L₂ (List.cons { fst := x, snd := b } (List.cons { fst := x, snd := b.not } L₃)))\n⊢ p","decl":"@[to_additive]\ntheorem reduce.not {p : Prop} :\n    ∀ {L₁ L₂ L₃ : List (α × Bool)} {x b}, reduce L₁ = L₂ ++ (x, b) :: (x, !b) :: L₃ → p\n  | [], L2, L3, _, _ => fun h => by cases L2 <;> injections\n  | (x, b) :: L1, L2, L3, x', b' => by\n    dsimp\n    cases r : reduce L1 with\n    | nil =>\n      dsimp; intro h\n      exfalso\n      have := congr_arg List.length h\n      simp? [List.length] at this says\n        simp only [List.length, zero_add, List.length_append] at this\n      omega\n    | cons hd tail =>\n      cases' hd with y c\n      dsimp only\n      split_ifs with h <;> intro H\n      · rw [H] at r\n        exact @reduce.not _ L1 ((y, c) :: L2) L3 x' b' r\n      rcases L2 with (_ | ⟨a, L2⟩)\n      · injections; subst_vars\n        simp at h\n      · refine @reduce.not _ L1 L2 L3 x' b' ?_\n        injection H with _ H\n        rw [r, H]; rfl\n\n"}
{"name":"FreeAddGroup.reduce.not","module":"Mathlib.GroupTheory.FreeGroup.Reduce","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\np : Prop\nL₁ L₂ L₃ : List (Prod α Bool)\nx : α\nb : Bool\na✝ : Eq (FreeAddGroup.reduce L₁) (HAppend.hAppend L₂ (List.cons { fst := x, snd := b } (List.cons { fst := x, snd := b.not } L₃)))\n⊢ p","decl":"@[to_additive]\ntheorem reduce.not {p : Prop} :\n    ∀ {L₁ L₂ L₃ : List (α × Bool)} {x b}, reduce L₁ = L₂ ++ (x, b) :: (x, !b) :: L₃ → p\n  | [], L2, L3, _, _ => fun h => by cases L2 <;> injections\n  | (x, b) :: L1, L2, L3, x', b' => by\n    dsimp\n    cases r : reduce L1 with\n    | nil =>\n      dsimp; intro h\n      exfalso\n      have := congr_arg List.length h\n      simp? [List.length] at this says\n        simp only [List.length, zero_add, List.length_append] at this\n      omega\n    | cons hd tail =>\n      cases' hd with y c\n      dsimp only\n      split_ifs with h <;> intro H\n      · rw [H] at r\n        exact @reduce.not _ L1 ((y, c) :: L2) L3 x' b' r\n      rcases L2 with (_ | ⟨a, L2⟩)\n      · injections; subst_vars\n        simp at h\n      · refine @reduce.not _ L1 L2 L3 x' b' ?_\n        injection H with _ H\n        rw [r, H]; rfl\n\n"}
{"name":"FreeAddGroup.reduce.min","module":"Mathlib.GroupTheory.FreeGroup.Reduce","initialProofState":"α : Type u_1\nL₁ L₂ : List (Prod α Bool)\ninst✝ : DecidableEq α\nH : FreeAddGroup.Red (FreeAddGroup.reduce L₁) L₂\n⊢ Eq (FreeAddGroup.reduce L₁) L₂","decl":"/-- The second theorem that characterises the function `reduce`: the maximal reduction of a word\nonly reduces to itself. -/\n@[to_additive \"The second theorem that characterises the function `reduce`: the maximal reduction of\n  a word only reduces to itself.\"]\ntheorem reduce.min (H : Red (reduce L₁) L₂) : reduce L₁ = L₂ := by\n  induction' H with L1 L' L2 H1 H2 ih\n  · rfl\n  · cases' H1 with L4 L5 x b\n    exact reduce.not H2\n\n"}
{"name":"FreeGroup.reduce.min","module":"Mathlib.GroupTheory.FreeGroup.Reduce","initialProofState":"α : Type u_1\nL₁ L₂ : List (Prod α Bool)\ninst✝ : DecidableEq α\nH : FreeGroup.Red (FreeGroup.reduce L₁) L₂\n⊢ Eq (FreeGroup.reduce L₁) L₂","decl":"/-- The second theorem that characterises the function `reduce`: the maximal reduction of a word\nonly reduces to itself. -/\n@[to_additive \"The second theorem that characterises the function `reduce`: the maximal reduction of\n  a word only reduces to itself.\"]\ntheorem reduce.min (H : Red (reduce L₁) L₂) : reduce L₁ = L₂ := by\n  induction' H with L1 L' L2 H1 H2 ih\n  · rfl\n  · cases' H1 with L4 L5 x b\n    exact reduce.not H2\n\n"}
{"name":"FreeGroup.reduce.idem","module":"Mathlib.GroupTheory.FreeGroup.Reduce","initialProofState":"α : Type u_1\nL : List (Prod α Bool)\ninst✝ : DecidableEq α\n⊢ Eq (FreeGroup.reduce (FreeGroup.reduce L)) (FreeGroup.reduce L)","decl":"/-- `reduce` is idempotent, i.e. the maximal reduction of the maximal reduction of a word is the\n  maximal reduction of the word. -/\n@[to_additive (attr := simp) \"`reduce` is idempotent, i.e. the maximal reduction of the maximal\n  reduction of a word is the maximal reduction of the word.\"]\ntheorem reduce.idem : reduce (reduce L) = reduce L :=\n  Eq.symm <| reduce.min reduce.red\n\n"}
{"name":"FreeAddGroup.reduce.idem","module":"Mathlib.GroupTheory.FreeGroup.Reduce","initialProofState":"α : Type u_1\nL : List (Prod α Bool)\ninst✝ : DecidableEq α\n⊢ Eq (FreeAddGroup.reduce (FreeAddGroup.reduce L)) (FreeAddGroup.reduce L)","decl":"/-- `reduce` is idempotent, i.e. the maximal reduction of the maximal reduction of a word is the\n  maximal reduction of the word. -/\n@[to_additive (attr := simp) \"`reduce` is idempotent, i.e. the maximal reduction of the maximal\n  reduction of a word is the maximal reduction of the word.\"]\ntheorem reduce.idem : reduce (reduce L) = reduce L :=\n  Eq.symm <| reduce.min reduce.red\n\n"}
{"name":"FreeAddGroup.reduce.Step.eq","module":"Mathlib.GroupTheory.FreeGroup.Reduce","initialProofState":"α : Type u_1\nL₁ L₂ : List (Prod α Bool)\ninst✝ : DecidableEq α\nH : FreeAddGroup.Red.Step L₁ L₂\n⊢ Eq (FreeAddGroup.reduce L₁) (FreeAddGroup.reduce L₂)","decl":"@[to_additive]\ntheorem reduce.Step.eq (H : Red.Step L₁ L₂) : reduce L₁ = reduce L₂ :=\n  let ⟨_L₃, HR13, HR23⟩ := Red.church_rosser reduce.red (reduce.red.head H)\n  (reduce.min HR13).trans (reduce.min HR23).symm\n\n"}
{"name":"FreeGroup.reduce.Step.eq","module":"Mathlib.GroupTheory.FreeGroup.Reduce","initialProofState":"α : Type u_1\nL₁ L₂ : List (Prod α Bool)\ninst✝ : DecidableEq α\nH : FreeGroup.Red.Step L₁ L₂\n⊢ Eq (FreeGroup.reduce L₁) (FreeGroup.reduce L₂)","decl":"@[to_additive]\ntheorem reduce.Step.eq (H : Red.Step L₁ L₂) : reduce L₁ = reduce L₂ :=\n  let ⟨_L₃, HR13, HR23⟩ := Red.church_rosser reduce.red (reduce.red.head H)\n  (reduce.min HR13).trans (reduce.min HR23).symm\n\n"}
{"name":"FreeAddGroup.reduce.eq_of_red","module":"Mathlib.GroupTheory.FreeGroup.Reduce","initialProofState":"α : Type u_1\nL₁ L₂ : List (Prod α Bool)\ninst✝ : DecidableEq α\nH : FreeAddGroup.Red L₁ L₂\n⊢ Eq (FreeAddGroup.reduce L₁) (FreeAddGroup.reduce L₂)","decl":"/-- If a word reduces to another word, then they have a common maximal reduction. -/\n@[to_additive \"If a word reduces to another word, then they have a common maximal reduction.\"]\ntheorem reduce.eq_of_red (H : Red L₁ L₂) : reduce L₁ = reduce L₂ :=\n  let ⟨_L₃, HR13, HR23⟩ := Red.church_rosser reduce.red (Red.trans H reduce.red)\n  (reduce.min HR13).trans (reduce.min HR23).symm\n\n"}
{"name":"FreeGroup.reduce.eq_of_red","module":"Mathlib.GroupTheory.FreeGroup.Reduce","initialProofState":"α : Type u_1\nL₁ L₂ : List (Prod α Bool)\ninst✝ : DecidableEq α\nH : FreeGroup.Red L₁ L₂\n⊢ Eq (FreeGroup.reduce L₁) (FreeGroup.reduce L₂)","decl":"/-- If a word reduces to another word, then they have a common maximal reduction. -/\n@[to_additive \"If a word reduces to another word, then they have a common maximal reduction.\"]\ntheorem reduce.eq_of_red (H : Red L₁ L₂) : reduce L₁ = reduce L₂ :=\n  let ⟨_L₃, HR13, HR23⟩ := Red.church_rosser reduce.red (Red.trans H reduce.red)\n  (reduce.min HR13).trans (reduce.min HR23).symm\n\n"}
{"name":"FreeGroup.red.reduce_eq","module":"Mathlib.GroupTheory.FreeGroup.Reduce","initialProofState":"α : Type u_1\nL₁ L₂ : List (Prod α Bool)\ninst✝ : DecidableEq α\nH : FreeGroup.Red L₁ L₂\n⊢ Eq (FreeGroup.reduce L₁) (FreeGroup.reduce L₂)","decl":"alias red.reduce_eq := reduce.eq_of_red\n\n"}
{"name":"FreeGroup.freeAddGroup.red.reduce_eq","module":"Mathlib.GroupTheory.FreeGroup.Reduce","initialProofState":"α : Type u_1\nL₁ L₂ : List (Prod α Bool)\ninst✝ : DecidableEq α\nH : FreeAddGroup.Red L₁ L₂\n⊢ Eq (FreeAddGroup.reduce L₁) (FreeAddGroup.reduce L₂)","decl":"alias freeAddGroup.red.reduce_eq := FreeAddGroup.reduce.eq_of_red\n\n"}
{"name":"FreeGroup.Red.reduce_right","module":"Mathlib.GroupTheory.FreeGroup.Reduce","initialProofState":"α : Type u_1\nL₁ L₂ : List (Prod α Bool)\ninst✝ : DecidableEq α\nh : FreeGroup.Red L₁ L₂\n⊢ FreeGroup.Red L₁ (FreeGroup.reduce L₂)","decl":"@[to_additive]\ntheorem Red.reduce_right (h : Red L₁ L₂) : Red L₁ (reduce L₂) :=\n  reduce.eq_of_red h ▸ reduce.red\n\n"}
{"name":"FreeAddGroup.Red.reduce_right","module":"Mathlib.GroupTheory.FreeGroup.Reduce","initialProofState":"α : Type u_1\nL₁ L₂ : List (Prod α Bool)\ninst✝ : DecidableEq α\nh : FreeAddGroup.Red L₁ L₂\n⊢ FreeAddGroup.Red L₁ (FreeAddGroup.reduce L₂)","decl":"@[to_additive]\ntheorem Red.reduce_right (h : Red L₁ L₂) : Red L₁ (reduce L₂) :=\n  reduce.eq_of_red h ▸ reduce.red\n\n"}
{"name":"FreeAddGroup.Red.reduce_left","module":"Mathlib.GroupTheory.FreeGroup.Reduce","initialProofState":"α : Type u_1\nL₁ L₂ : List (Prod α Bool)\ninst✝ : DecidableEq α\nh : FreeAddGroup.Red L₁ L₂\n⊢ FreeAddGroup.Red L₂ (FreeAddGroup.reduce L₁)","decl":"@[to_additive]\ntheorem Red.reduce_left (h : Red L₁ L₂) : Red L₂ (reduce L₁) :=\n  (reduce.eq_of_red h).symm ▸ reduce.red\n\n"}
{"name":"FreeGroup.Red.reduce_left","module":"Mathlib.GroupTheory.FreeGroup.Reduce","initialProofState":"α : Type u_1\nL₁ L₂ : List (Prod α Bool)\ninst✝ : DecidableEq α\nh : FreeGroup.Red L₁ L₂\n⊢ FreeGroup.Red L₂ (FreeGroup.reduce L₁)","decl":"@[to_additive]\ntheorem Red.reduce_left (h : Red L₁ L₂) : Red L₂ (reduce L₁) :=\n  (reduce.eq_of_red h).symm ▸ reduce.red\n\n"}
{"name":"FreeAddGroup.reduce.sound","module":"Mathlib.GroupTheory.FreeGroup.Reduce","initialProofState":"α : Type u_1\nL₁ L₂ : List (Prod α Bool)\ninst✝ : DecidableEq α\nH : Eq (FreeAddGroup.mk L₁) (FreeAddGroup.mk L₂)\n⊢ Eq (FreeAddGroup.reduce L₁) (FreeAddGroup.reduce L₂)","decl":"/-- If two words correspond to the same element in the free group, then they\nhave a common maximal reduction. This is the proof that the function that sends\nan element of the free group to its maximal reduction is well-defined. -/\n@[to_additive \"If two words correspond to the same element in the additive free group, then they\n  have a common maximal reduction. This is the proof that the function that sends an element of the\n  free group to its maximal reduction is well-defined.\"]\ntheorem reduce.sound (H : mk L₁ = mk L₂) : reduce L₁ = reduce L₂ :=\n  let ⟨_L₃, H13, H23⟩ := Red.exact.1 H\n  (reduce.eq_of_red H13).trans (reduce.eq_of_red H23).symm\n\n"}
{"name":"FreeGroup.reduce.sound","module":"Mathlib.GroupTheory.FreeGroup.Reduce","initialProofState":"α : Type u_1\nL₁ L₂ : List (Prod α Bool)\ninst✝ : DecidableEq α\nH : Eq (FreeGroup.mk L₁) (FreeGroup.mk L₂)\n⊢ Eq (FreeGroup.reduce L₁) (FreeGroup.reduce L₂)","decl":"/-- If two words correspond to the same element in the free group, then they\nhave a common maximal reduction. This is the proof that the function that sends\nan element of the free group to its maximal reduction is well-defined. -/\n@[to_additive \"If two words correspond to the same element in the additive free group, then they\n  have a common maximal reduction. This is the proof that the function that sends an element of the\n  free group to its maximal reduction is well-defined.\"]\ntheorem reduce.sound (H : mk L₁ = mk L₂) : reduce L₁ = reduce L₂ :=\n  let ⟨_L₃, H13, H23⟩ := Red.exact.1 H\n  (reduce.eq_of_red H13).trans (reduce.eq_of_red H23).symm\n\n"}
{"name":"FreeGroup.reduce.exact","module":"Mathlib.GroupTheory.FreeGroup.Reduce","initialProofState":"α : Type u_1\nL₁ L₂ : List (Prod α Bool)\ninst✝ : DecidableEq α\nH : Eq (FreeGroup.reduce L₁) (FreeGroup.reduce L₂)\n⊢ Eq (FreeGroup.mk L₁) (FreeGroup.mk L₂)","decl":"/-- If two words have a common maximal reduction, then they correspond to the same element in the\n  free group. -/\n@[to_additive \"If two words have a common maximal reduction, then they correspond to the same\n  element in the additive free group.\"]\ntheorem reduce.exact (H : reduce L₁ = reduce L₂) : mk L₁ = mk L₂ :=\n  Red.exact.2 ⟨reduce L₂, H ▸ reduce.red, reduce.red⟩\n\n"}
{"name":"FreeAddGroup.reduce.exact","module":"Mathlib.GroupTheory.FreeGroup.Reduce","initialProofState":"α : Type u_1\nL₁ L₂ : List (Prod α Bool)\ninst✝ : DecidableEq α\nH : Eq (FreeAddGroup.reduce L₁) (FreeAddGroup.reduce L₂)\n⊢ Eq (FreeAddGroup.mk L₁) (FreeAddGroup.mk L₂)","decl":"/-- If two words have a common maximal reduction, then they correspond to the same element in the\n  free group. -/\n@[to_additive \"If two words have a common maximal reduction, then they correspond to the same\n  element in the additive free group.\"]\ntheorem reduce.exact (H : reduce L₁ = reduce L₂) : mk L₁ = mk L₂ :=\n  Red.exact.2 ⟨reduce L₂, H ▸ reduce.red, reduce.red⟩\n\n"}
{"name":"FreeGroup.reduce.self","module":"Mathlib.GroupTheory.FreeGroup.Reduce","initialProofState":"α : Type u_1\nL : List (Prod α Bool)\ninst✝ : DecidableEq α\n⊢ Eq (FreeGroup.mk (FreeGroup.reduce L)) (FreeGroup.mk L)","decl":"/-- A word and its maximal reduction correspond to the same element of the free group. -/\n@[to_additive \"A word and its maximal reduction correspond to the same element of the additive free\n  group.\"]\ntheorem reduce.self : mk (reduce L) = mk L :=\n  reduce.exact reduce.idem\n\n"}
{"name":"FreeAddGroup.reduce.self","module":"Mathlib.GroupTheory.FreeGroup.Reduce","initialProofState":"α : Type u_1\nL : List (Prod α Bool)\ninst✝ : DecidableEq α\n⊢ Eq (FreeAddGroup.mk (FreeAddGroup.reduce L)) (FreeAddGroup.mk L)","decl":"/-- A word and its maximal reduction correspond to the same element of the free group. -/\n@[to_additive \"A word and its maximal reduction correspond to the same element of the additive free\n  group.\"]\ntheorem reduce.self : mk (reduce L) = mk L :=\n  reduce.exact reduce.idem\n\n"}
{"name":"FreeGroup.reduce.rev","module":"Mathlib.GroupTheory.FreeGroup.Reduce","initialProofState":"α : Type u_1\nL₁ L₂ : List (Prod α Bool)\ninst✝ : DecidableEq α\nH : FreeGroup.Red L₁ L₂\n⊢ FreeGroup.Red L₂ (FreeGroup.reduce L₁)","decl":"/-- If words `w₁ w₂` are such that `w₁` reduces to `w₂`, then `w₂` reduces to the maximal reduction\n  of `w₁`. -/\n@[to_additive \"If words `w₁ w₂` are such that `w₁` reduces to `w₂`, then `w₂` reduces to the maximal\n  reduction of `w₁`.\"]\ntheorem reduce.rev (H : Red L₁ L₂) : Red L₂ (reduce L₁) :=\n  (reduce.eq_of_red H).symm ▸ reduce.red\n\n"}
{"name":"FreeAddGroup.reduce.rev","module":"Mathlib.GroupTheory.FreeGroup.Reduce","initialProofState":"α : Type u_1\nL₁ L₂ : List (Prod α Bool)\ninst✝ : DecidableEq α\nH : FreeAddGroup.Red L₁ L₂\n⊢ FreeAddGroup.Red L₂ (FreeAddGroup.reduce L₁)","decl":"/-- If words `w₁ w₂` are such that `w₁` reduces to `w₂`, then `w₂` reduces to the maximal reduction\n  of `w₁`. -/\n@[to_additive \"If words `w₁ w₂` are such that `w₁` reduces to `w₂`, then `w₂` reduces to the maximal\n  reduction of `w₁`.\"]\ntheorem reduce.rev (H : Red L₁ L₂) : Red L₂ (reduce L₁) :=\n  (reduce.eq_of_red H).symm ▸ reduce.red\n\n"}
{"name":"FreeGroup.mk_toWord","module":"Mathlib.GroupTheory.FreeGroup.Reduce","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nx : FreeGroup α\n⊢ Eq (FreeGroup.mk x.toWord) x","decl":"@[to_additive]\ntheorem mk_toWord : ∀ {x : FreeGroup α}, mk (toWord x) = x := by rintro ⟨L⟩; exact reduce.self\n\n"}
{"name":"FreeAddGroup.mk_toWord","module":"Mathlib.GroupTheory.FreeGroup.Reduce","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nx : FreeAddGroup α\n⊢ Eq (FreeAddGroup.mk x.toWord) x","decl":"@[to_additive]\ntheorem mk_toWord : ∀ {x : FreeGroup α}, mk (toWord x) = x := by rintro ⟨L⟩; exact reduce.self\n\n"}
{"name":"FreeAddGroup.toWord_injective","module":"Mathlib.GroupTheory.FreeGroup.Reduce","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\n⊢ Function.Injective FreeAddGroup.toWord","decl":"@[to_additive]\ntheorem toWord_injective : Function.Injective (toWord : FreeGroup α → List (α × Bool)) := by\n  rintro ⟨L₁⟩ ⟨L₂⟩; exact reduce.exact\n\n"}
{"name":"FreeGroup.toWord_injective","module":"Mathlib.GroupTheory.FreeGroup.Reduce","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\n⊢ Function.Injective FreeGroup.toWord","decl":"@[to_additive]\ntheorem toWord_injective : Function.Injective (toWord : FreeGroup α → List (α × Bool)) := by\n  rintro ⟨L₁⟩ ⟨L₂⟩; exact reduce.exact\n\n"}
{"name":"FreeAddGroup.toWord_inj","module":"Mathlib.GroupTheory.FreeGroup.Reduce","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nx y : FreeAddGroup α\n⊢ Iff (Eq x.toWord y.toWord) (Eq x y)","decl":"@[to_additive (attr := simp)]\ntheorem toWord_inj {x y : FreeGroup α} : toWord x = toWord y ↔ x = y :=\n  toWord_injective.eq_iff\n\n"}
{"name":"FreeGroup.toWord_inj","module":"Mathlib.GroupTheory.FreeGroup.Reduce","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nx y : FreeGroup α\n⊢ Iff (Eq x.toWord y.toWord) (Eq x y)","decl":"@[to_additive (attr := simp)]\ntheorem toWord_inj {x y : FreeGroup α} : toWord x = toWord y ↔ x = y :=\n  toWord_injective.eq_iff\n\n"}
{"name":"FreeAddGroup.toWord_mk","module":"Mathlib.GroupTheory.FreeGroup.Reduce","initialProofState":"α : Type u_1\nL₁ : List (Prod α Bool)\ninst✝ : DecidableEq α\n⊢ Eq (FreeAddGroup.mk L₁).toWord (FreeAddGroup.reduce L₁)","decl":"@[to_additive (attr := simp)]\ntheorem toWord_mk : (mk L₁).toWord = reduce L₁ :=\n  rfl\n\n"}
{"name":"FreeGroup.toWord_mk","module":"Mathlib.GroupTheory.FreeGroup.Reduce","initialProofState":"α : Type u_1\nL₁ : List (Prod α Bool)\ninst✝ : DecidableEq α\n⊢ Eq (FreeGroup.mk L₁).toWord (FreeGroup.reduce L₁)","decl":"@[to_additive (attr := simp)]\ntheorem toWord_mk : (mk L₁).toWord = reduce L₁ :=\n  rfl\n\n"}
{"name":"FreeGroup.toWord_of","module":"Mathlib.GroupTheory.FreeGroup.Reduce","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na : α\n⊢ Eq (FreeGroup.of a).toWord (List.cons { fst := a, snd := Bool.true } List.nil)","decl":"@[to_additive (attr := simp)]\ntheorem toWord_of (a : α) : (of a).toWord = [(a, true)] :=\n  rfl\n\n"}
{"name":"FreeAddGroup.toWord_of","module":"Mathlib.GroupTheory.FreeGroup.Reduce","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na : α\n⊢ Eq (FreeAddGroup.of a).toWord (List.cons { fst := a, snd := Bool.true } List.nil)","decl":"@[to_additive (attr := simp)]\ntheorem toWord_of (a : α) : (of a).toWord = [(a, true)] :=\n  rfl\n\n"}
{"name":"FreeAddGroup.reduce_toWord","module":"Mathlib.GroupTheory.FreeGroup.Reduce","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nx : FreeAddGroup α\n⊢ Eq (FreeAddGroup.reduce x.toWord) x.toWord","decl":"@[to_additive (attr := simp)]\ntheorem reduce_toWord : ∀ x : FreeGroup α, reduce (toWord x) = toWord x := by\n  rintro ⟨L⟩\n  exact reduce.idem\n\n"}
{"name":"FreeGroup.reduce_toWord","module":"Mathlib.GroupTheory.FreeGroup.Reduce","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nx : FreeGroup α\n⊢ Eq (FreeGroup.reduce x.toWord) x.toWord","decl":"@[to_additive (attr := simp)]\ntheorem reduce_toWord : ∀ x : FreeGroup α, reduce (toWord x) = toWord x := by\n  rintro ⟨L⟩\n  exact reduce.idem\n\n"}
{"name":"FreeGroup.toWord_one","module":"Mathlib.GroupTheory.FreeGroup.Reduce","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\n⊢ Eq (FreeGroup.toWord 1) List.nil","decl":"@[to_additive (attr := simp)]\ntheorem toWord_one : (1 : FreeGroup α).toWord = [] :=\n  rfl\n\n"}
{"name":"FreeAddGroup.toWord_zero","module":"Mathlib.GroupTheory.FreeGroup.Reduce","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\n⊢ Eq (FreeAddGroup.toWord 0) List.nil","decl":"@[to_additive (attr := simp)]\ntheorem toWord_one : (1 : FreeGroup α).toWord = [] :=\n  rfl\n\n"}
{"name":"FreeAddGroup.toWord_of_nsmul","module":"Mathlib.GroupTheory.FreeGroup.Reduce","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na : α\nn : Nat\n⊢ Eq (HSMul.hSMul n (FreeAddGroup.of a)).toWord (List.replicate n { fst := a, snd := Bool.true })","decl":"@[to_additive (attr := simp)]\ntheorem toWord_of_pow (a : α) (n : ℕ) : (of a ^ n).toWord = List.replicate n (a, true) := by\n  rw [of, pow_mk, List.flatten_replicate_singleton, toWord]\n  exact reduce_replicate _ _\n\n"}
{"name":"FreeGroup.toWord_of_pow","module":"Mathlib.GroupTheory.FreeGroup.Reduce","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na : α\nn : Nat\n⊢ Eq (HPow.hPow (FreeGroup.of a) n).toWord (List.replicate n { fst := a, snd := Bool.true })","decl":"@[to_additive (attr := simp)]\ntheorem toWord_of_pow (a : α) (n : ℕ) : (of a ^ n).toWord = List.replicate n (a, true) := by\n  rw [of, pow_mk, List.flatten_replicate_singleton, toWord]\n  exact reduce_replicate _ _\n\n"}
{"name":"FreeAddGroup.toWord_eq_nil_iff","module":"Mathlib.GroupTheory.FreeGroup.Reduce","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nx : FreeAddGroup α\n⊢ Iff (Eq x.toWord List.nil) (Eq x 0)","decl":"@[to_additive (attr := simp)]\ntheorem toWord_eq_nil_iff {x : FreeGroup α} : x.toWord = [] ↔ x = 1 :=\n  toWord_injective.eq_iff' toWord_one\n\n"}
{"name":"FreeGroup.toWord_eq_nil_iff","module":"Mathlib.GroupTheory.FreeGroup.Reduce","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nx : FreeGroup α\n⊢ Iff (Eq x.toWord List.nil) (Eq x 1)","decl":"@[to_additive (attr := simp)]\ntheorem toWord_eq_nil_iff {x : FreeGroup α} : x.toWord = [] ↔ x = 1 :=\n  toWord_injective.eq_iff' toWord_one\n\n"}
{"name":"FreeAddGroup.reduce_negRev","module":"Mathlib.GroupTheory.FreeGroup.Reduce","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nw : List (Prod α Bool)\n⊢ Eq (FreeAddGroup.reduce (FreeAddGroup.negRev w)) (FreeAddGroup.negRev (FreeAddGroup.reduce w))","decl":"@[to_additive]\ntheorem reduce_invRev {w : List (α × Bool)} : reduce (invRev w) = invRev (reduce w) := by\n  apply reduce.min\n  rw [← red_invRev_iff, invRev_invRev]\n  apply Red.reduce_left\n  have : Red (invRev (invRev w)) (invRev (reduce (invRev w))) := reduce.red.invRev\n  rwa [invRev_invRev] at this\n\n"}
{"name":"FreeGroup.reduce_invRev","module":"Mathlib.GroupTheory.FreeGroup.Reduce","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nw : List (Prod α Bool)\n⊢ Eq (FreeGroup.reduce (FreeGroup.invRev w)) (FreeGroup.invRev (FreeGroup.reduce w))","decl":"@[to_additive]\ntheorem reduce_invRev {w : List (α × Bool)} : reduce (invRev w) = invRev (reduce w) := by\n  apply reduce.min\n  rw [← red_invRev_iff, invRev_invRev]\n  apply Red.reduce_left\n  have : Red (invRev (invRev w)) (invRev (reduce (invRev w))) := reduce.red.invRev\n  rwa [invRev_invRev] at this\n\n"}
{"name":"FreeAddGroup.toWord_neg","module":"Mathlib.GroupTheory.FreeGroup.Reduce","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nx : FreeAddGroup α\n⊢ Eq (Neg.neg x).toWord (FreeAddGroup.negRev x.toWord)","decl":"@[to_additive (attr := simp)]\ntheorem toWord_inv (x : FreeGroup α) : x⁻¹.toWord = invRev x.toWord := by\n  rcases x with ⟨L⟩\n  rw [quot_mk_eq_mk, inv_mk, toWord_mk, toWord_mk, reduce_invRev]\n\n"}
{"name":"FreeGroup.toWord_inv","module":"Mathlib.GroupTheory.FreeGroup.Reduce","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nx : FreeGroup α\n⊢ Eq (Inv.inv x).toWord (FreeGroup.invRev x.toWord)","decl":"@[to_additive (attr := simp)]\ntheorem toWord_inv (x : FreeGroup α) : x⁻¹.toWord = invRev x.toWord := by\n  rcases x with ⟨L⟩\n  rw [quot_mk_eq_mk, inv_mk, toWord_mk, toWord_mk, reduce_invRev]\n\n"}
{"name":"FreeGroup.toWord_mul_sublist","module":"Mathlib.GroupTheory.FreeGroup.Reduce","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nx y : FreeGroup α\n⊢ (HMul.hMul x y).toWord.Sublist (HAppend.hAppend x.toWord y.toWord)","decl":"@[to_additive]\nlemma toWord_mul_sublist (x y : FreeGroup α) : (x * y).toWord <+ x.toWord ++ y.toWord := by\n  refine Red.sublist ?_\n  have : x * y = FreeGroup.mk (x.toWord ++ y.toWord) := by\n    rw [← FreeGroup.mul_mk, FreeGroup.mk_toWord, FreeGroup.mk_toWord]\n  rw [this]\n  exact FreeGroup.reduce.red\n\n"}
{"name":"FreeAddGroup.toWord_add_sublist","module":"Mathlib.GroupTheory.FreeGroup.Reduce","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nx y : FreeAddGroup α\n⊢ (HAdd.hAdd x y).toWord.Sublist (HAppend.hAppend x.toWord y.toWord)","decl":"@[to_additive]\nlemma toWord_mul_sublist (x y : FreeGroup α) : (x * y).toWord <+ x.toWord ++ y.toWord := by\n  refine Red.sublist ?_\n  have : x * y = FreeGroup.mk (x.toWord ++ y.toWord) := by\n    rw [← FreeGroup.mul_mk, FreeGroup.mk_toWord, FreeGroup.mk_toWord]\n  rw [this]\n  exact FreeGroup.reduce.red\n\n"}
{"name":"FreeGroup.Red.enum.sound","module":"Mathlib.GroupTheory.FreeGroup.Reduce","initialProofState":"α : Type u_1\nL₁ L₂ : List (Prod α Bool)\ninst✝ : DecidableEq α\nH : Membership.mem (List.filter (fun b => Decidable.decide (FreeGroup.Red L₁ b)) L₁.sublists) L₂\n⊢ FreeGroup.Red L₁ L₂","decl":"theorem Red.enum.sound (H : L₂ ∈ List.filter (Red L₁) (List.sublists L₁)) : Red L₁ L₂ :=\n  of_decide_eq_true (@List.of_mem_filter _ _ L₂ _ H)\n\n"}
{"name":"FreeGroup.Red.enum.complete","module":"Mathlib.GroupTheory.FreeGroup.Reduce","initialProofState":"α : Type u_1\nL₁ L₂ : List (Prod α Bool)\ninst✝ : DecidableEq α\nH : FreeGroup.Red L₁ L₂\n⊢ Membership.mem (FreeGroup.Red.enum L₁) L₂","decl":"theorem Red.enum.complete (H : Red L₁ L₂) : L₂ ∈ Red.enum L₁ :=\n  List.mem_filter_of_mem (List.mem_sublists.2 <| Red.sublist H) (decide_eq_true H)\n\n"}
{"name":"FreeAddGroup.zero_ne_of","module":"Mathlib.GroupTheory.FreeGroup.Reduce","initialProofState":"α : Type u_1\na : α\n⊢ Ne 0 (FreeAddGroup.of a)","decl":"@[to_additive (attr := simp)]\ntheorem one_ne_of (a : α) : 1 ≠ of a :=\n  letI := Classical.decEq α; ne_of_apply_ne toWord <| by simp\n\n"}
{"name":"FreeGroup.one_ne_of","module":"Mathlib.GroupTheory.FreeGroup.Reduce","initialProofState":"α : Type u_1\na : α\n⊢ Ne 1 (FreeGroup.of a)","decl":"@[to_additive (attr := simp)]\ntheorem one_ne_of (a : α) : 1 ≠ of a :=\n  letI := Classical.decEq α; ne_of_apply_ne toWord <| by simp\n\n"}
{"name":"FreeAddGroup.of_ne_zero","module":"Mathlib.GroupTheory.FreeGroup.Reduce","initialProofState":"α : Type u_1\na : α\n⊢ Ne (FreeAddGroup.of a) 0","decl":"@[to_additive (attr := simp)]\ntheorem of_ne_one (a : α) : of a ≠ 1 := one_ne_of _ |>.symm\n\n"}
{"name":"FreeGroup.of_ne_one","module":"Mathlib.GroupTheory.FreeGroup.Reduce","initialProofState":"α : Type u_1\na : α\n⊢ Ne (FreeGroup.of a) 1","decl":"@[to_additive (attr := simp)]\ntheorem of_ne_one (a : α) : of a ≠ 1 := one_ne_of _ |>.symm\n\n"}
{"name":"FreeAddGroup.instNontrivialOfNonempty","module":"Mathlib.GroupTheory.FreeGroup.Reduce","initialProofState":"α : Type u_1\ninst✝ : Nonempty α\n⊢ Nontrivial (FreeAddGroup α)","decl":"@[to_additive]\ninstance [Nonempty α] : Nontrivial (FreeGroup α) where\n  exists_pair_ne := let ⟨x⟩ := ‹Nonempty α›; ⟨1, of x, one_ne_of x⟩\n\n"}
{"name":"FreeGroup.instNontrivialOfNonempty","module":"Mathlib.GroupTheory.FreeGroup.Reduce","initialProofState":"α : Type u_1\ninst✝ : Nonempty α\n⊢ Nontrivial (FreeGroup α)","decl":"@[to_additive]\ninstance [Nonempty α] : Nontrivial (FreeGroup α) where\n  exists_pair_ne := let ⟨x⟩ := ‹Nonempty α›; ⟨1, of x, one_ne_of x⟩\n\n"}
{"name":"FreeAddGroup.norm_neg_eq","module":"Mathlib.GroupTheory.FreeGroup.Reduce","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nx : FreeAddGroup α\n⊢ Eq (Neg.neg x).norm x.norm","decl":"@[to_additive (attr := simp)]\ntheorem norm_inv_eq {x : FreeGroup α} : norm x⁻¹ = norm x := by\n  simp only [norm, toWord_inv, invRev_length]\n\n"}
{"name":"FreeGroup.norm_inv_eq","module":"Mathlib.GroupTheory.FreeGroup.Reduce","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nx : FreeGroup α\n⊢ Eq (Inv.inv x).norm x.norm","decl":"@[to_additive (attr := simp)]\ntheorem norm_inv_eq {x : FreeGroup α} : norm x⁻¹ = norm x := by\n  simp only [norm, toWord_inv, invRev_length]\n\n"}
{"name":"FreeAddGroup.norm_eq_zero","module":"Mathlib.GroupTheory.FreeGroup.Reduce","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nx : FreeAddGroup α\n⊢ Iff (Eq x.norm 0) (Eq x 0)","decl":"@[to_additive (attr := simp)]\ntheorem norm_eq_zero {x : FreeGroup α} : norm x = 0 ↔ x = 1 := by\n  simp only [norm, List.length_eq_zero, toWord_eq_nil_iff]\n\n"}
{"name":"FreeGroup.norm_eq_zero","module":"Mathlib.GroupTheory.FreeGroup.Reduce","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nx : FreeGroup α\n⊢ Iff (Eq x.norm 0) (Eq x 1)","decl":"@[to_additive (attr := simp)]\ntheorem norm_eq_zero {x : FreeGroup α} : norm x = 0 ↔ x = 1 := by\n  simp only [norm, List.length_eq_zero, toWord_eq_nil_iff]\n\n"}
{"name":"FreeAddGroup.norm_zero","module":"Mathlib.GroupTheory.FreeGroup.Reduce","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\n⊢ Eq (FreeAddGroup.norm 0) 0","decl":"@[to_additive (attr := simp)]\ntheorem norm_one : norm (1 : FreeGroup α) = 0 :=\n  rfl\n\n"}
{"name":"FreeGroup.norm_one","module":"Mathlib.GroupTheory.FreeGroup.Reduce","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\n⊢ Eq (FreeGroup.norm 1) 0","decl":"@[to_additive (attr := simp)]\ntheorem norm_one : norm (1 : FreeGroup α) = 0 :=\n  rfl\n\n"}
{"name":"FreeAddGroup.norm_of","module":"Mathlib.GroupTheory.FreeGroup.Reduce","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na : α\n⊢ Eq (FreeAddGroup.of a).norm 1","decl":"@[to_additive (attr := simp)]\ntheorem norm_of (a : α) : norm (of a) = 1 :=\n  rfl\n\n"}
{"name":"FreeGroup.norm_of","module":"Mathlib.GroupTheory.FreeGroup.Reduce","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na : α\n⊢ Eq (FreeGroup.of a).norm 1","decl":"@[to_additive (attr := simp)]\ntheorem norm_of (a : α) : norm (of a) = 1 :=\n  rfl\n\n"}
{"name":"FreeAddGroup.norm_mk_le","module":"Mathlib.GroupTheory.FreeGroup.Reduce","initialProofState":"α : Type u_1\nL₁ : List (Prod α Bool)\ninst✝ : DecidableEq α\n⊢ LE.le (FreeAddGroup.mk L₁).norm L₁.length","decl":"@[to_additive]\ntheorem norm_mk_le : norm (mk L₁) ≤ L₁.length :=\n  reduce.red.length_le\n\n"}
{"name":"FreeGroup.norm_mk_le","module":"Mathlib.GroupTheory.FreeGroup.Reduce","initialProofState":"α : Type u_1\nL₁ : List (Prod α Bool)\ninst✝ : DecidableEq α\n⊢ LE.le (FreeGroup.mk L₁).norm L₁.length","decl":"@[to_additive]\ntheorem norm_mk_le : norm (mk L₁) ≤ L₁.length :=\n  reduce.red.length_le\n\n"}
{"name":"FreeGroup.norm_mul_le","module":"Mathlib.GroupTheory.FreeGroup.Reduce","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nx y : FreeGroup α\n⊢ LE.le (HMul.hMul x y).norm (HAdd.hAdd x.norm y.norm)","decl":"@[to_additive]\ntheorem norm_mul_le (x y : FreeGroup α) : norm (x * y) ≤ norm x + norm y :=\n  calc\n    norm (x * y) = norm (mk (x.toWord ++ y.toWord)) := by rw [← mul_mk, mk_toWord, mk_toWord]\n    _ ≤ (x.toWord ++ y.toWord).length := norm_mk_le\n    _ = norm x + norm y := List.length_append _ _\n\n"}
{"name":"FreeAddGroup.norm_add_le","module":"Mathlib.GroupTheory.FreeGroup.Reduce","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nx y : FreeAddGroup α\n⊢ LE.le (HAdd.hAdd x y).norm (HAdd.hAdd x.norm y.norm)","decl":"@[to_additive]\ntheorem norm_mul_le (x y : FreeGroup α) : norm (x * y) ≤ norm x + norm y :=\n  calc\n    norm (x * y) = norm (mk (x.toWord ++ y.toWord)) := by rw [← mul_mk, mk_toWord, mk_toWord]\n    _ ≤ (x.toWord ++ y.toWord).length := norm_mk_le\n    _ = norm x + norm y := List.length_append _ _\n\n"}
{"name":"FreeAddGroup.norm_of_nsmul","module":"Mathlib.GroupTheory.FreeGroup.Reduce","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na : α\nn : Nat\n⊢ Eq (HSMul.hSMul n (FreeAddGroup.of a)).norm n","decl":"@[to_additive (attr := simp)]\ntheorem norm_of_pow (a : α) (n : ℕ) : norm (of a ^ n) = n := by\n  rw [norm, toWord_of_pow, List.length_replicate]\n\n"}
{"name":"FreeGroup.norm_of_pow","module":"Mathlib.GroupTheory.FreeGroup.Reduce","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na : α\nn : Nat\n⊢ Eq (HPow.hPow (FreeGroup.of a) n).norm n","decl":"@[to_additive (attr := simp)]\ntheorem norm_of_pow (a : α) (n : ℕ) : norm (of a ^ n) = n := by\n  rw [norm, toWord_of_pow, List.length_replicate]\n\n"}
{"name":"FreeAddGroup.norm_surjective","module":"Mathlib.GroupTheory.FreeGroup.Reduce","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Nonempty α\n⊢ Function.Surjective FreeAddGroup.norm","decl":"@[to_additive]\ntheorem norm_surjective [Nonempty α] : Function.Surjective (norm (α := α)) := by\n  let ⟨a⟩ := ‹Nonempty α›\n  exact Function.RightInverse.surjective <| norm_of_pow a\n\n"}
{"name":"FreeGroup.norm_surjective","module":"Mathlib.GroupTheory.FreeGroup.Reduce","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Nonempty α\n⊢ Function.Surjective FreeGroup.norm","decl":"@[to_additive]\ntheorem norm_surjective [Nonempty α] : Function.Surjective (norm (α := α)) := by\n  let ⟨a⟩ := ‹Nonempty α›\n  exact Function.RightInverse.surjective <| norm_of_pow a\n\n"}
