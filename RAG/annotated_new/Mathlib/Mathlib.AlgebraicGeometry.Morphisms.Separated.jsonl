{"name":"AlgebraicGeometry.isSeparated_iff","module":"Mathlib.AlgebraicGeometry.Morphisms.Separated","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nâŠ¢ Iff (AlgebraicGeometry.IsSeparated f) (autoParam (AlgebraicGeometry.IsClosedImmersion (CategoryTheory.Limits.pullback.diagonal f)) _autoâœ)","decl":"/-- A morphism is separated if the diagonal map is a closed immersion. -/\n@[mk_iff]\nclass IsSeparated : Prop where\n  /-- A morphism is separated if the diagonal map is a closed immersion. -/\n  diagonal_isClosedImmersion : IsClosedImmersion (pullback.diagonal f) := by infer_instance\n\n"}
{"name":"AlgebraicGeometry.IsSeparated.diagonal_isClosedImmersion","module":"Mathlib.AlgebraicGeometry.Morphisms.Separated","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nself : AlgebraicGeometry.IsSeparated f\nâŠ¢ AlgebraicGeometry.IsClosedImmersion (CategoryTheory.Limits.pullback.diagonal f)","decl":"/-- A morphism is separated if the diagonal map is a closed immersion. -/\n@[mk_iff]\nclass IsSeparated : Prop where\n  /-- A morphism is separated if the diagonal map is a closed immersion. -/\n  diagonal_isClosedImmersion : IsClosedImmersion (pullback.diagonal f) := by infer_instance\n\n"}
{"name":"AlgebraicGeometry.IsSeparated.isSeparated_eq_diagonal_isClosedImmersion","module":"Mathlib.AlgebraicGeometry.Morphisms.Separated","initialProofState":"âŠ¢ Eq (@AlgebraicGeometry.IsSeparated) (CategoryTheory.MorphismProperty.diagonal @AlgebraicGeometry.IsClosedImmersion)","decl":"theorem isSeparated_eq_diagonal_isClosedImmersion :\n    @IsSeparated = MorphismProperty.diagonal @IsClosedImmersion := by\n  ext\n  exact isSeparated_iff _\n\n"}
{"name":"AlgebraicGeometry.IsSeparated.isSeparated_of_mono","module":"Mathlib.AlgebraicGeometry.Morphisms.Separated","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\ninstâœ : CategoryTheory.Mono f\nâŠ¢ AlgebraicGeometry.IsSeparated f","decl":"/-- Monomorphisms are separated. -/\ninstance (priority := 900) isSeparated_of_mono [Mono f] : IsSeparated f where\n\n"}
{"name":"AlgebraicGeometry.IsSeparated.instRespectsIsoScheme","module":"Mathlib.AlgebraicGeometry.Morphisms.Separated","initialProofState":"âŠ¢ CategoryTheory.MorphismProperty.RespectsIso @AlgebraicGeometry.IsSeparated","decl":"instance : MorphismProperty.RespectsIso @IsSeparated := by\n  rw [isSeparated_eq_diagonal_isClosedImmersion]\n  infer_instance\n\n"}
{"name":"AlgebraicGeometry.IsSeparated.instQuasiSeparated","module":"Mathlib.AlgebraicGeometry.Morphisms.Separated","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\ninstâœ : AlgebraicGeometry.IsSeparated f\nâŠ¢ AlgebraicGeometry.QuasiSeparated f","decl":"instance (priority := 900) [IsSeparated f] : QuasiSeparated f where\n\n"}
{"name":"AlgebraicGeometry.IsSeparated.stableUnderComposition","module":"Mathlib.AlgebraicGeometry.Morphisms.Separated","initialProofState":"âŠ¢ CategoryTheory.MorphismProperty.IsStableUnderComposition @AlgebraicGeometry.IsSeparated","decl":"instance stableUnderComposition : MorphismProperty.IsStableUnderComposition @IsSeparated := by\n  rw [isSeparated_eq_diagonal_isClosedImmersion]\n  infer_instance\n\n"}
{"name":"AlgebraicGeometry.IsSeparated.instCompScheme","module":"Mathlib.AlgebraicGeometry.Morphisms.Separated","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\ninstâœÂ¹ : AlgebraicGeometry.IsSeparated f\ninstâœ : AlgebraicGeometry.IsSeparated g\nâŠ¢ AlgebraicGeometry.IsSeparated (CategoryTheory.CategoryStruct.comp f g)","decl":"instance [IsSeparated f] [IsSeparated g] : IsSeparated (f â‰« g) :=\n  stableUnderComposition.comp_mem f g inferInstance inferInstance\n\n"}
{"name":"AlgebraicGeometry.IsSeparated.instIsMultiplicativeScheme","module":"Mathlib.AlgebraicGeometry.Morphisms.Separated","initialProofState":"âŠ¢ CategoryTheory.MorphismProperty.IsMultiplicative @AlgebraicGeometry.IsSeparated","decl":"instance : MorphismProperty.IsMultiplicative @IsSeparated where\n  id_mem _ := inferInstance\n\n"}
{"name":"AlgebraicGeometry.IsSeparated.isStableUnderBaseChange","module":"Mathlib.AlgebraicGeometry.Morphisms.Separated","initialProofState":"âŠ¢ CategoryTheory.MorphismProperty.IsStableUnderBaseChange @AlgebraicGeometry.IsSeparated","decl":"instance isStableUnderBaseChange : MorphismProperty.IsStableUnderBaseChange @IsSeparated := by\n  rw [isSeparated_eq_diagonal_isClosedImmersion]\n  infer_instance\n\n"}
{"name":"AlgebraicGeometry.IsSeparated.instIsLocalAtTarget","module":"Mathlib.AlgebraicGeometry.Morphisms.Separated","initialProofState":"âŠ¢ AlgebraicGeometry.IsLocalAtTarget @AlgebraicGeometry.IsSeparated","decl":"instance : IsLocalAtTarget @IsSeparated := by\n  rw [isSeparated_eq_diagonal_isClosedImmersion]\n  infer_instance\n\n"}
{"name":"AlgebraicGeometry.IsSeparated.instMap","module":"Mathlib.AlgebraicGeometry.Morphisms.Separated","initialProofState":"R S : CommRingCat\nf : Quiver.Hom R S\nâŠ¢ AlgebraicGeometry.IsSeparated (AlgebraicGeometry.Spec.map f)","decl":"instance (R S : CommRingCat.{u}) (f : R âŸ¶ S) : IsSeparated (Spec.map f) := by\n  constructor\n  letI := f.hom.toAlgebra\n  show IsClosedImmersion (Limits.pullback.diagonal (Spec.map (CommRingCat.ofHom (algebraMap R S))))\n  rw [diagonal_Spec_map, MorphismProperty.cancel_right_of_respectsIso @IsClosedImmersion]\n  exact .spec_of_surjective _ fun x â†¦ âŸ¨.tmul R 1 x,\n    (Algebra.TensorProduct.lmul'_apply_tmul (R := R) (S := S) 1 x).trans (one_mul x)âŸ©\n\n"}
{"name":"AlgebraicGeometry.IsSeparated.of_isAffineHom","module":"Mathlib.AlgebraicGeometry.Morphisms.Separated","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nh : AlgebraicGeometry.IsAffineHom f\nâŠ¢ AlgebraicGeometry.IsSeparated f","decl":"@[instance 100]\nlemma of_isAffineHom [h : IsAffineHom f] : IsSeparated f := by\n  wlog hY : IsAffine Y\n  Â· rw [IsLocalAtTarget.iff_of_iSup_eq_top (P := @IsSeparated) _\n      (iSup_affineOpens_eq_top Y)]\n    intro U\n    have H : IsAffineHom (f âˆ£_ U) := IsLocalAtTarget.restrict h U\n    exact this _ U.2\n  have : IsAffine X := HasAffineProperty.iff_of_isAffine.mp h\n  rw [MorphismProperty.arrow_mk_iso_iff @IsSeparated (arrowIsoSpecÎ“OfIsAffine f)]\n  infer_instance\n\n"}
{"name":"AlgebraicGeometry.IsSeparated.instIsClosedImmersionMapDescScheme","module":"Mathlib.AlgebraicGeometry.Morphisms.Separated","initialProofState":"X Y S T : AlgebraicGeometry.Scheme\nf : Quiver.Hom X S\ng : Quiver.Hom Y S\ni : Quiver.Hom S T\ninstâœ : AlgebraicGeometry.IsSeparated i\nâŠ¢ AlgebraicGeometry.IsClosedImmersion (CategoryTheory.Limits.pullback.mapDesc f g i)","decl":"instance {S T : Scheme.{u}} (f : X âŸ¶ S) (g : Y âŸ¶ S) (i : S âŸ¶ T) [IsSeparated i] :\n    IsClosedImmersion (pullback.mapDesc f g i) :=\n  MorphismProperty.of_isPullback (pullback_map_diagonal_isPullback f g i)\n    inferInstance\n\n"}
{"name":"AlgebraicGeometry.IsSeparated.instIsClosedImmersionLiftSchemeId","module":"Mathlib.AlgebraicGeometry.Morphisms.Separated","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\ninstâœ : AlgebraicGeometry.IsSeparated g\nâŠ¢ AlgebraicGeometry.IsClosedImmersion (CategoryTheory.Limits.pullback.lift (CategoryTheory.CategoryStruct.id X) f â‹¯)","decl":"/-- Given `f : X âŸ¶ Y` and `g : Y âŸ¶ Z` such that `g` is separated, the induced map\n`X âŸ¶ X Ã—[Z] Y` is a closed immersion. -/\ninstance [IsSeparated g] :\n    IsClosedImmersion (pullback.lift (ğŸ™ _) f (Category.id_comp (f â‰« g))) := by\n  rw [â† MorphismProperty.cancel_left_of_respectsIso @IsClosedImmersion (pullback.fst f (ğŸ™ Y))]\n  rw [â† MorphismProperty.cancel_right_of_respectsIso @IsClosedImmersion _\n    (pullback.congrHom rfl (Category.id_comp g)).inv]\n  convert (inferInstanceAs <| IsClosedImmersion (pullback.mapDesc f (ğŸ™ _) g)) using 1\n  ext : 1 <;> simp [pullback.condition]\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.diagonalCoverDiagonalRange_eq_top_of_injective","module":"Mathlib.AlgebraicGeometry.Morphisms.Separated","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nğ’° : Y.OpenCover\nğ’± : (i : ğ’°.J) â†’ (CategoryTheory.Limits.pullback f (ğ’°.map i)).OpenCover\nhf : Function.Injective â‡‘f.base\nâŠ¢ Eq (AlgebraicGeometry.Scheme.Pullback.diagonalCoverDiagonalRange f ğ’° ğ’±) Top.top","decl":"lemma Scheme.Pullback.diagonalCoverDiagonalRange_eq_top_of_injective\n    (hf : Function.Injective f.base) :\n    diagonalCoverDiagonalRange f ğ’° ğ’± = âŠ¤ := by\n  rw [â† top_le_iff]\n  rintro x -\n  simp only [diagonalCoverDiagonalRange, openCoverOfBase_J, openCoverOfBase_obj,\n    openCoverOfLeftRight_J, Opens.iSup_mk, Opens.carrier_eq_coe, Hom.coe_opensRange, Opens.coe_mk,\n    Set.mem_iUnion, Set.mem_range, Sigma.exists]\n  have H : (pullback.fst f f).base x = (pullback.snd f f).base x :=\n    hf (by rw [â† Scheme.comp_base_apply, â† Scheme.comp_base_apply, pullback.condition])\n  let i := ğ’°.f (f.base ((pullback.fst f f).base x))\n  obtain âŸ¨y : ğ’°.obj i, hy : (ğ’°.map i).base y = f.base _âŸ© :=\n    ğ’°.covers (f.base ((pullback.fst f f).base x))\n  obtain âŸ¨z, hzâ‚, hzâ‚‚âŸ© := exists_preimage_pullback _ _ hy.symm\n  let j := (ğ’± i).f z\n  obtain âŸ¨w : (ğ’± i).obj j, hy : ((ğ’± i).map j).base w = zâŸ© := (ğ’± i).covers z\n  refine âŸ¨i, j, ?_âŸ©\n  simp_rw [diagonalCover_map]\n  show x âˆˆ Set.range _\n  dsimp only [diagonalCover, Cover.bind_obj, openCoverOfLeftRight_obj]\n  rw [range_map]\n  simp [â† H, â† hzâ‚, â† hy]\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.range_diagonal_subset_diagonalCoverDiagonalRange","module":"Mathlib.AlgebraicGeometry.Morphisms.Separated","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nğ’° : Y.OpenCover\nğ’± : (i : ğ’°.J) â†’ (CategoryTheory.Limits.pullback f (ğ’°.map i)).OpenCover\nâŠ¢ HasSubset.Subset (Set.range â‡‘(CategoryTheory.Limits.pullback.diagonal f).base) â†‘(AlgebraicGeometry.Scheme.Pullback.diagonalCoverDiagonalRange f ğ’° ğ’±)","decl":"lemma Scheme.Pullback.range_diagonal_subset_diagonalCoverDiagonalRange :\n    Set.range (pullback.diagonal f).base âŠ† diagonalCoverDiagonalRange f ğ’° ğ’± := by\n  rintro _ âŸ¨x, rflâŸ©\n  simp only [diagonalCoverDiagonalRange, openCoverOfBase_J, openCoverOfBase_obj,\n    openCoverOfLeftRight_J, Opens.iSup_mk, Opens.carrier_eq_coe, Hom.coe_opensRange, Opens.coe_mk,\n    Set.mem_iUnion, Set.mem_range, Sigma.exists]\n  let i := ğ’°.f (f.base x)\n  obtain âŸ¨y : ğ’°.obj i, hy : (ğ’°.map i).base y = f.base xâŸ© := ğ’°.covers (f.base x)\n  obtain âŸ¨z, hzâ‚, hzâ‚‚âŸ© := exists_preimage_pullback _ _ hy.symm\n  let j := (ğ’± i).f z\n  obtain âŸ¨w : (ğ’± i).obj j, hy : ((ğ’± i).map j).base w = zâŸ© := (ğ’± i).covers z\n  refine âŸ¨i, j, (pullback.diagonal ((ğ’± i).map j â‰« pullback.snd f (ğ’°.map i))).base w, ?_âŸ©\n  rw [â† hzâ‚, â† hy, â† Scheme.comp_base_apply, â† Scheme.comp_base_apply]\n  dsimp only [diagonalCover, Cover.pullbackHom, Cover.bind_obj, openCoverOfLeftRight_obj]\n  rw [â† Scheme.comp_base_apply]\n  congr 4\n  apply pullback.hom_ext <;> simp\n\n"}
{"name":"AlgebraicGeometry.isClosedImmersion_diagonal_restrict_diagonalCoverDiagonalRange","module":"Mathlib.AlgebraicGeometry.Morphisms.Separated","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nğ’° : Y.OpenCover\nğ’± : (i : ğ’°.J) â†’ (CategoryTheory.Limits.pullback f (ğ’°.map i)).OpenCover\ninstâœÂ¹ : âˆ€ (i : ğ’°.J), AlgebraicGeometry.IsAffine (ğ’°.obj i)\ninstâœ : âˆ€ (i : ğ’°.J) (j : (ğ’± i).J), AlgebraicGeometry.IsAffine ((ğ’± i).obj j)\nâŠ¢ AlgebraicGeometry.IsClosedImmersion (AlgebraicGeometry.morphismRestrict (CategoryTheory.Limits.pullback.diagonal f) (AlgebraicGeometry.Scheme.Pullback.diagonalCoverDiagonalRange f ğ’° ğ’±))","decl":"lemma isClosedImmersion_diagonal_restrict_diagonalCoverDiagonalRange\n    [âˆ€ i, IsAffine (ğ’°.obj i)] [âˆ€ i j, IsAffine ((ğ’± i).obj j)] :\n    IsClosedImmersion (pullback.diagonal f âˆ£_ diagonalCoverDiagonalRange f ğ’° ğ’±) := by\n  let U : (Î£ i, (ğ’± i).J) â†’ (diagonalCoverDiagonalRange f ğ’° ğ’±).toScheme.Opens := fun i â†¦\n    (diagonalCoverDiagonalRange f ğ’° ğ’±).Î¹ â»Â¹áµ ((diagonalCover f ğ’° ğ’±).map âŸ¨i.1, i.2, i.2âŸ©).opensRange\n  have hU (i) : (diagonalCoverDiagonalRange f ğ’° ğ’±).Î¹ ''áµ U i =\n      ((diagonalCover f ğ’° ğ’±).map âŸ¨i.1, i.2, i.2âŸ©).opensRange := by\n    rw [TopologicalSpace.Opens.functor_obj_map_obj, inf_eq_right, Hom.image_top_eq_opensRange,\n      Opens.opensRange_Î¹]\n    exact le_iSup (fun i : Î£ i, (ğ’± i).J â†¦ ((diagonalCover f ğ’° ğ’±).map âŸ¨i.1, i.2, i.2âŸ©).opensRange) i\n  have hf : iSup U = âŠ¤ := (TopologicalSpace.Opens.map_iSup _ _).symm.trans\n    (diagonalCoverDiagonalRange f ğ’° ğ’±).Î¹_preimage_self\n  rw [IsLocalAtTarget.iff_of_iSup_eq_top (P := @IsClosedImmersion) _ hf]\n  intro i\n  rw [MorphismProperty.arrow_mk_iso_iff (P := @IsClosedImmersion) (morphismRestrictRestrict _ _ _),\n    MorphismProperty.arrow_mk_iso_iff (P := @IsClosedImmersion) (morphismRestrictEq _ (hU i)),\n    MorphismProperty.arrow_mk_iso_iff (P := @IsClosedImmersion) (diagonalRestrictIsoDiagonal ..)]\n  infer_instance\n\n"}
{"name":"AlgebraicGeometry.isSeparated_of_injective","module":"Mathlib.AlgebraicGeometry.Morphisms.Separated","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nhf : Function.Injective â‡‘f.base\nâŠ¢ AlgebraicGeometry.IsSeparated f","decl":"@[stacks 0DVA]\nlemma isSeparated_of_injective (hf : Function.Injective f.base) :\n    IsSeparated f := by\n  constructor\n  let ğ’° := Y.affineCover\n  let ğ’± (i) := (pullback f (ğ’°.map i)).affineCover\n  refine IsLocalAtTarget.of_iSup_eq_top (fun i : PUnit.{0} â†¦ âŠ¤) (by simp) fun _ â†¦ ?_\n  rw [â† diagonalCoverDiagonalRange_eq_top_of_injective f ğ’° ğ’± hf]\n  exact isClosedImmersion_diagonal_restrict_diagonalCoverDiagonalRange f ğ’° ğ’±\n\n"}
{"name":"AlgebraicGeometry.IsClosedImmersion.of_comp","module":"Mathlib.AlgebraicGeometry.Morphisms.Separated","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\ninstâœÂ¹ : AlgebraicGeometry.IsClosedImmersion (CategoryTheory.CategoryStruct.comp f g)\ninstâœ : AlgebraicGeometry.IsSeparated g\nâŠ¢ AlgebraicGeometry.IsClosedImmersion f","decl":"lemma IsClosedImmersion.of_comp [IsClosedImmersion (f â‰« g)] [IsSeparated g] :\n    IsClosedImmersion f := by\n  rw [â† pullback.lift_snd (ğŸ™ _) f (Category.id_comp (f â‰« g))]\n  have := MorphismProperty.pullback_snd (P := @IsClosedImmersion) (f â‰« g) g inferInstance\n  infer_instance\n\n"}
{"name":"AlgebraicGeometry.IsSeparated.of_comp","module":"Mathlib.AlgebraicGeometry.Morphisms.Separated","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\ninstâœ : AlgebraicGeometry.IsSeparated (CategoryTheory.CategoryStruct.comp f g)\nâŠ¢ AlgebraicGeometry.IsSeparated f","decl":"lemma IsSeparated.of_comp [IsSeparated (f â‰« g)] : IsSeparated f := by\n  have := IsSeparated.diagonal_isClosedImmersion (f := f â‰« g)\n  rw [pullback.diagonal_comp] at this\n  exact âŸ¨@IsClosedImmersion.of_comp _ _ _ _ _ this inferInstanceâŸ©\n\n"}
{"name":"AlgebraicGeometry.IsSeparated.comp_iff","module":"Mathlib.AlgebraicGeometry.Morphisms.Separated","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\ninstâœ : AlgebraicGeometry.IsSeparated g\nâŠ¢ Iff (AlgebraicGeometry.IsSeparated (CategoryTheory.CategoryStruct.comp f g)) (AlgebraicGeometry.IsSeparated f)","decl":"lemma IsSeparated.comp_iff [IsSeparated g] : IsSeparated (f â‰« g) â†” IsSeparated f :=\n  âŸ¨fun _ â†¦ .of_comp f g, fun _ â†¦ inferInstanceâŸ©\n\n"}
{"name":"AlgebraicGeometry.isClosedImmersion_equalizer_Î¹_left","module":"Mathlib.AlgebraicGeometry.Morphisms.Separated","initialProofState":"S : AlgebraicGeometry.Scheme\nX Y : CategoryTheory.Over S\ninstâœ : AlgebraicGeometry.IsSeparated Y.hom\nf g : Quiver.Hom X Y\nâŠ¢ AlgebraicGeometry.IsClosedImmersion (CategoryTheory.Limits.equalizer.Î¹ f g).left","decl":"@[stacks 01KM]\ninstance isClosedImmersion_equalizer_Î¹_left {S : Scheme} {X Y : Over S} [IsSeparated Y.hom]\n    (f g : X âŸ¶ Y) : IsClosedImmersion (equalizer.Î¹ f g).left := by\n  refine MorphismProperty.of_isPullback\n    ((Limits.isPullback_equalizer_prod f g).map (Over.forget _)).flip ?_\n  rw [â† MorphismProperty.cancel_right_of_respectsIso @IsClosedImmersion _\n    (Over.prodLeftIsoPullback Y Y).hom]\n  convert (inferInstanceAs (IsClosedImmersion (pullback.diagonal Y.hom)))\n  ext1 <;> simp [â† Over.comp_left]\n\n"}
{"name":"AlgebraicGeometry.ext_of_isDominant_of_isSeparated","module":"Mathlib.AlgebraicGeometry.Morphisms.Separated","initialProofState":"W X Y Z : AlgebraicGeometry.Scheme\ninstâœÂ² : AlgebraicGeometry.IsReduced X\nf g : Quiver.Hom X Y\ns : Quiver.Hom Y Z\ninstâœÂ¹ : AlgebraicGeometry.IsSeparated s\nh : Eq (CategoryTheory.CategoryStruct.comp f s) (CategoryTheory.CategoryStruct.comp g s)\nÎ¹ : Quiver.Hom W X\ninstâœ : AlgebraicGeometry.IsDominant Î¹\nhU : Eq (CategoryTheory.CategoryStruct.comp Î¹ f) (CategoryTheory.CategoryStruct.comp Î¹ g)\nâŠ¢ Eq f g","decl":"/--\nSuppose `X` is a reduced scheme and that `f g : X âŸ¶ Y` agree over some separated `Y âŸ¶ Z`.\nThen `f = g` if `Î¹ â‰« f = Î¹ â‰« g` for some dominant `Î¹`.\n-/\nlemma ext_of_isDominant_of_isSeparated [IsReduced X] {f g : X âŸ¶ Y}\n    (s : Y âŸ¶ Z) [IsSeparated s] (h : f â‰« s = g â‰« s)\n    (Î¹ : W âŸ¶ X) [IsDominant Î¹] (hU : Î¹ â‰« f = Î¹ â‰« g) : f = g := by\n  let X' : Over Z := Over.mk (f â‰« s)\n  let Y' : Over Z := Over.mk s\n  let U' : Over Z := Over.mk (Î¹ â‰« f â‰« s)\n  let f' : X' âŸ¶ Y' := Over.homMk f\n  let g' : X' âŸ¶ Y' := Over.homMk g\n  let Î¹' : U' âŸ¶ X' := Over.homMk Î¹\n  have : IsSeparated Y'.hom := â€¹_â€º\n  have : IsDominant (equalizer.Î¹ f' g').left := by\n    apply (config := { allowSynthFailures := true }) IsDominant.of_comp (equalizer.lift Î¹' ?_).left\n    Â· rwa [â† Over.comp_left, equalizer.lift_Î¹]\n    Â· ext1; exact hU\n  have : Surjective (equalizer.Î¹ f' g').left :=\n    surjective_of_isDominant_of_isClosed_range _ IsClosedImmersion.base_closed.2\n  have := isIso_of_isClosedImmersion_of_surjective (Y := X) (equalizer.Î¹ f' g').left\n  rw [â† cancel_epi (equalizer.Î¹ f' g').left]\n  exact congr($(equalizer.condition f' g').left)\n\n"}
{"name":"AlgebraicGeometry.ext_of_isDominant_of_isSeparated'","module":"Mathlib.AlgebraicGeometry.Morphisms.Separated","initialProofState":"X Y S : AlgebraicGeometry.Scheme\ninstâœâ¶ : X.Over S\ninstâœâµ : Y.Over S\ninstâœâ´ : AlgebraicGeometry.IsReduced X\ninstâœÂ³ : AlgebraicGeometry.IsSeparated (CategoryTheory.over Y S inferInstance)\nf g : Quiver.Hom X Y\ninstâœÂ² : AlgebraicGeometry.Scheme.Hom.IsOver f S\ninstâœÂ¹ : AlgebraicGeometry.Scheme.Hom.IsOver g S\nW : AlgebraicGeometry.Scheme\nÎ¹ : Quiver.Hom W X\ninstâœ : AlgebraicGeometry.IsDominant Î¹\nhU : Eq (CategoryTheory.CategoryStruct.comp Î¹ f) (CategoryTheory.CategoryStruct.comp Î¹ g)\nâŠ¢ Eq f g","decl":"variable (S) in\n/--\nSuppose `X` is a reduced `S`-scheme and `Y` is a separated `S`-scheme.\nFor any `S`-morphisms `f g : X âŸ¶ Y`, `f = g` if `Î¹ â‰« f = Î¹ â‰« g` for some dominant `Î¹`.\n-/\nlemma ext_of_isDominant_of_isSeparated' [X.Over S] [Y.Over S] [IsReduced X] [IsSeparated (Y â†˜ S)]\n    {f g : X âŸ¶ Y} [f.IsOver S] [g.IsOver S] {W} (Î¹ : W âŸ¶ X) [IsDominant Î¹]\n    (hU : Î¹ â‰« f = Î¹ â‰« g) : f = g :=\n  ext_of_isDominant_of_isSeparated (Y â†˜ S) (by simp) Î¹ hU\n\n"}
{"name":"AlgebraicGeometry.Scheme.isSeparated_iff","module":"Mathlib.AlgebraicGeometry.Morphisms.Separated","initialProofState":"X : AlgebraicGeometry.Scheme\nâŠ¢ Iff X.IsSeparated (AlgebraicGeometry.IsSeparated (CategoryTheory.Limits.terminal.from X))","decl":"/-- A scheme `X` is separated if it is separated over `âŠ¤_ Scheme`. -/\n@[mk_iff]\nprotected class IsSeparated (X : Scheme.{u}) : Prop where\n  isSeparated_terminal_from : IsSeparated (terminal.from X)\n\n"}
{"name":"AlgebraicGeometry.Scheme.IsSeparated.isSeparated_terminal_from","module":"Mathlib.AlgebraicGeometry.Morphisms.Separated","initialProofState":"X : AlgebraicGeometry.Scheme\nself : X.IsSeparated\nâŠ¢ AlgebraicGeometry.IsSeparated (CategoryTheory.Limits.terminal.from X)","decl":"/-- A scheme `X` is separated if it is separated over `âŠ¤_ Scheme`. -/\n@[mk_iff]\nprotected class IsSeparated (X : Scheme.{u}) : Prop where\n  isSeparated_terminal_from : IsSeparated (terminal.from X)\n\n"}
{"name":"AlgebraicGeometry.Scheme.isSeparated_iff_isClosedImmersion_prod_lift","module":"Mathlib.AlgebraicGeometry.Morphisms.Separated","initialProofState":"X : AlgebraicGeometry.Scheme\nâŠ¢ Iff X.IsSeparated (AlgebraicGeometry.IsClosedImmersion (CategoryTheory.Limits.prod.lift (CategoryTheory.CategoryStruct.id X) (CategoryTheory.CategoryStruct.id X)))","decl":"lemma isSeparated_iff_isClosedImmersion_prod_lift {X : Scheme.{u}} :\n    X.IsSeparated â†” IsClosedImmersion (prod.lift (ğŸ™ X) (ğŸ™ X)) := by\n  rw [isSeparated_iff, AlgebraicGeometry.isSeparated_iff, iff_iff_eq,\n    â† MorphismProperty.cancel_right_of_respectsIso @IsClosedImmersion _ (prodIsoPullback X X).hom]\n  congr\n  ext : 1 <;> simp\n\n"}
{"name":"AlgebraicGeometry.Scheme.instIsClosedImmersionLiftIdOfIsSeparated","module":"Mathlib.AlgebraicGeometry.Morphisms.Separated","initialProofState":"X : AlgebraicGeometry.Scheme\ninstâœ : X.IsSeparated\nâŠ¢ AlgebraicGeometry.IsClosedImmersion (CategoryTheory.Limits.prod.lift (CategoryTheory.CategoryStruct.id X) (CategoryTheory.CategoryStruct.id X))","decl":"instance [X.IsSeparated] : IsClosedImmersion (prod.lift (ğŸ™ X) (ğŸ™ X)) := by\n  rwa [â† isSeparated_iff_isClosedImmersion_prod_lift]\n\n"}
{"name":"AlgebraicGeometry.Scheme.instIsSeparatedOfIsAffine","module":"Mathlib.AlgebraicGeometry.Morphisms.Separated","initialProofState":"X : AlgebraicGeometry.Scheme\ninstâœ : AlgebraicGeometry.IsAffine X\nâŠ¢ X.IsSeparated","decl":"instance (priority := 900) {X : Scheme.{u}} [IsAffine X] : X.IsSeparated := âŸ¨inferInstanceâŸ©\n\n"}
{"name":"AlgebraicGeometry.Scheme.instIsSeparatedOfIsSeparated","module":"Mathlib.AlgebraicGeometry.Morphisms.Separated","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\ninstâœ : X.IsSeparated\nâŠ¢ AlgebraicGeometry.IsSeparated f","decl":"instance (priority := 900) [X.IsSeparated] : IsSeparated f := by\n  apply (config := { allowSynthFailures := true }) @IsSeparated.of_comp (g := terminal.from Y)\n  rw [terminal.comp_from]\n  infer_instance\n\n"}
{"name":"AlgebraicGeometry.Scheme.instIsClosedImmersionÎ¹OfIsSeparated","module":"Mathlib.AlgebraicGeometry.Morphisms.Separated","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf g : Quiver.Hom X Y\ninstâœ : Y.IsSeparated\nâŠ¢ AlgebraicGeometry.IsClosedImmersion (CategoryTheory.Limits.equalizer.Î¹ f g)","decl":"instance (f g : X âŸ¶ Y) [Y.IsSeparated] : IsClosedImmersion (Limits.equalizer.Î¹ f g) :=\n  MorphismProperty.of_isPullback (isPullback_equalizer_prod f g).flip inferInstance\n\n"}
{"name":"AlgebraicGeometry.IsSeparated.hasAffineProperty","module":"Mathlib.AlgebraicGeometry.Morphisms.Separated","initialProofState":"âŠ¢ AlgebraicGeometry.HasAffineProperty @AlgebraicGeometry.IsSeparated fun X x x_1 x => X.IsSeparated","decl":"instance IsSeparated.hasAffineProperty :\n    HasAffineProperty @IsSeparated fun X _ _ _ â†¦ X.IsSeparated := by\n  convert HasAffineProperty.of_isLocalAtTarget @IsSeparated with X Y f hY\n  rw [Scheme.isSeparated_iff, â† terminal.comp_from f, IsSeparated.comp_iff]\n  rfl\n\n"}
{"name":"AlgebraicGeometry.ext_of_isDominant","module":"Mathlib.AlgebraicGeometry.Morphisms.Separated","initialProofState":"W X Y : AlgebraicGeometry.Scheme\ninstâœÂ² : AlgebraicGeometry.IsReduced X\nf g : Quiver.Hom X Y\ninstâœÂ¹ : Y.IsSeparated\nÎ¹ : Quiver.Hom W X\ninstâœ : AlgebraicGeometry.IsDominant Î¹\nhU : Eq (CategoryTheory.CategoryStruct.comp Î¹ f) (CategoryTheory.CategoryStruct.comp Î¹ g)\nâŠ¢ Eq f g","decl":"/--\nSuppose `f g : X âŸ¶ Y` where `X` is a reduced scheme and `Y` is a separated scheme.\nThen `f = g` if `Î¹ â‰« f = Î¹ â‰« g` for some dominant `Î¹`.\n\nAlso see `ext_of_isDominant_of_isSeparated` for the general version over arbitrary bases.\n-/\nlemma ext_of_isDominant [IsReduced X] {f g : X âŸ¶ Y} [Y.IsSeparated]\n    (Î¹ : W âŸ¶ X) [IsDominant Î¹] (hU : Î¹ â‰« f = Î¹ â‰« g) : f = g :=\n  ext_of_isDominant_of_isSeparated (Limits.terminal.from _) (Limits.terminal.hom_ext _ _) Î¹ hU\n\n"}
