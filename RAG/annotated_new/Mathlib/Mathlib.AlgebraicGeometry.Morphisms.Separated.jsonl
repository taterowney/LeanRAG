{"name":"AlgebraicGeometry.isSeparated_iff","module":"Mathlib.AlgebraicGeometry.Morphisms.Separated","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\n‚ä¢ Iff (AlgebraicGeometry.IsSeparated f) (autoParam (AlgebraicGeometry.IsClosedImmersion (CategoryTheory.Limits.pullback.diagonal f)) _auto‚úù)","decl":"/-- A morphism is separated if the diagonal map is a closed immersion. -/\n@[mk_iff]\nclass IsSeparated : Prop where\n  /-- A morphism is separated if the diagonal map is a closed immersion. -/\n  diagonal_isClosedImmersion : IsClosedImmersion (pullback.diagonal f) := by infer_instance\n\n"}
{"name":"AlgebraicGeometry.IsSeparated.diagonal_isClosedImmersion","module":"Mathlib.AlgebraicGeometry.Morphisms.Separated","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nself : AlgebraicGeometry.IsSeparated f\n‚ä¢ AlgebraicGeometry.IsClosedImmersion (CategoryTheory.Limits.pullback.diagonal f)","decl":"/-- A morphism is separated if the diagonal map is a closed immersion. -/\n@[mk_iff]\nclass IsSeparated : Prop where\n  /-- A morphism is separated if the diagonal map is a closed immersion. -/\n  diagonal_isClosedImmersion : IsClosedImmersion (pullback.diagonal f) := by infer_instance\n\n"}
{"name":"AlgebraicGeometry.IsSeparated.isSeparated_eq_diagonal_isClosedImmersion","module":"Mathlib.AlgebraicGeometry.Morphisms.Separated","initialProofState":"‚ä¢ Eq (@AlgebraicGeometry.IsSeparated) (CategoryTheory.MorphismProperty.diagonal @AlgebraicGeometry.IsClosedImmersion)","decl":"theorem isSeparated_eq_diagonal_isClosedImmersion :\n    @IsSeparated = MorphismProperty.diagonal @IsClosedImmersion := by\n  ext\n  exact isSeparated_iff _\n\n"}
{"name":"AlgebraicGeometry.IsSeparated.isSeparated_of_mono","module":"Mathlib.AlgebraicGeometry.Morphisms.Separated","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\ninst‚úù : CategoryTheory.Mono f\n‚ä¢ AlgebraicGeometry.IsSeparated f","decl":"/-- Monomorphisms are separated. -/\ninstance (priority := 900) isSeparated_of_mono [Mono f] : IsSeparated f where\n\n"}
{"name":"AlgebraicGeometry.IsSeparated.instRespectsIsoScheme","module":"Mathlib.AlgebraicGeometry.Morphisms.Separated","initialProofState":"‚ä¢ CategoryTheory.MorphismProperty.RespectsIso @AlgebraicGeometry.IsSeparated","decl":"instance : MorphismProperty.RespectsIso @IsSeparated := by\n  rw [isSeparated_eq_diagonal_isClosedImmersion]\n  infer_instance\n\n"}
{"name":"AlgebraicGeometry.IsSeparated.instQuasiSeparated","module":"Mathlib.AlgebraicGeometry.Morphisms.Separated","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\ninst‚úù : AlgebraicGeometry.IsSeparated f\n‚ä¢ AlgebraicGeometry.QuasiSeparated f","decl":"instance (priority := 900) [IsSeparated f] : QuasiSeparated f where\n\n"}
{"name":"AlgebraicGeometry.IsSeparated.stableUnderComposition","module":"Mathlib.AlgebraicGeometry.Morphisms.Separated","initialProofState":"‚ä¢ CategoryTheory.MorphismProperty.IsStableUnderComposition @AlgebraicGeometry.IsSeparated","decl":"instance stableUnderComposition : MorphismProperty.IsStableUnderComposition @IsSeparated := by\n  rw [isSeparated_eq_diagonal_isClosedImmersion]\n  infer_instance\n\n"}
{"name":"AlgebraicGeometry.IsSeparated.instCompScheme","module":"Mathlib.AlgebraicGeometry.Morphisms.Separated","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\ninst‚úù¬π : AlgebraicGeometry.IsSeparated f\ninst‚úù : AlgebraicGeometry.IsSeparated g\n‚ä¢ AlgebraicGeometry.IsSeparated (CategoryTheory.CategoryStruct.comp f g)","decl":"instance [IsSeparated f] [IsSeparated g] : IsSeparated (f ‚â´ g) :=\n  stableUnderComposition.comp_mem f g inferInstance inferInstance\n\n"}
{"name":"AlgebraicGeometry.IsSeparated.instIsMultiplicativeScheme","module":"Mathlib.AlgebraicGeometry.Morphisms.Separated","initialProofState":"‚ä¢ CategoryTheory.MorphismProperty.IsMultiplicative @AlgebraicGeometry.IsSeparated","decl":"instance : MorphismProperty.IsMultiplicative @IsSeparated where\n  id_mem _ := inferInstance\n\n"}
{"name":"AlgebraicGeometry.IsSeparated.isStableUnderBaseChange","module":"Mathlib.AlgebraicGeometry.Morphisms.Separated","initialProofState":"‚ä¢ CategoryTheory.MorphismProperty.IsStableUnderBaseChange @AlgebraicGeometry.IsSeparated","decl":"instance isStableUnderBaseChange : MorphismProperty.IsStableUnderBaseChange @IsSeparated := by\n  rw [isSeparated_eq_diagonal_isClosedImmersion]\n  infer_instance\n\n"}
{"name":"AlgebraicGeometry.IsSeparated.instIsLocalAtTarget","module":"Mathlib.AlgebraicGeometry.Morphisms.Separated","initialProofState":"‚ä¢ AlgebraicGeometry.IsLocalAtTarget @AlgebraicGeometry.IsSeparated","decl":"instance : IsLocalAtTarget @IsSeparated := by\n  rw [isSeparated_eq_diagonal_isClosedImmersion]\n  infer_instance\n\n"}
{"name":"AlgebraicGeometry.IsSeparated.instMap","module":"Mathlib.AlgebraicGeometry.Morphisms.Separated","initialProofState":"R S : CommRingCat\nf : Quiver.Hom R S\n‚ä¢ AlgebraicGeometry.IsSeparated (AlgebraicGeometry.Spec.map f)","decl":"instance (R S : CommRingCat.{u}) (f : R ‚ü∂ S) : IsSeparated (Spec.map f) := by\n  constructor\n  letI := f.hom.toAlgebra\n  show IsClosedImmersion (Limits.pullback.diagonal (Spec.map (CommRingCat.ofHom (algebraMap R S))))\n  rw [diagonal_Spec_map, MorphismProperty.cancel_right_of_respectsIso @IsClosedImmersion]\n  exact .spec_of_surjective _ fun x ‚Ü¶ ‚ü®.tmul R 1 x,\n    (Algebra.TensorProduct.lmul'_apply_tmul (R := R) (S := S) 1 x).trans (one_mul x)‚ü©\n\n"}
{"name":"AlgebraicGeometry.IsSeparated.of_isAffineHom","module":"Mathlib.AlgebraicGeometry.Morphisms.Separated","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nh : AlgebraicGeometry.IsAffineHom f\n‚ä¢ AlgebraicGeometry.IsSeparated f","decl":"@[instance 100]\nlemma of_isAffineHom [h : IsAffineHom f] : IsSeparated f := by\n  wlog hY : IsAffine Y\n  ¬∑ rw [IsLocalAtTarget.iff_of_iSup_eq_top (P := @IsSeparated) _\n      (iSup_affineOpens_eq_top Y)]\n    intro U\n    have H : IsAffineHom (f ‚à£_ U) := IsLocalAtTarget.restrict h U\n    exact this _ U.2\n  have : IsAffine X := HasAffineProperty.iff_of_isAffine.mp h\n  rw [MorphismProperty.arrow_mk_iso_iff @IsSeparated (arrowIsoSpecŒìOfIsAffine f)]\n  infer_instance\n\n"}
{"name":"AlgebraicGeometry.IsSeparated.instIsClosedImmersionMapDescScheme","module":"Mathlib.AlgebraicGeometry.Morphisms.Separated","initialProofState":"X Y S T : AlgebraicGeometry.Scheme\nf : Quiver.Hom X S\ng : Quiver.Hom Y S\ni : Quiver.Hom S T\ninst‚úù : AlgebraicGeometry.IsSeparated i\n‚ä¢ AlgebraicGeometry.IsClosedImmersion (CategoryTheory.Limits.pullback.mapDesc f g i)","decl":"instance {S T : Scheme.{u}} (f : X ‚ü∂ S) (g : Y ‚ü∂ S) (i : S ‚ü∂ T) [IsSeparated i] :\n    IsClosedImmersion (pullback.mapDesc f g i) :=\n  MorphismProperty.of_isPullback (pullback_map_diagonal_isPullback f g i)\n    inferInstance\n\n"}
{"name":"AlgebraicGeometry.IsSeparated.instIsClosedImmersionLiftSchemeId","module":"Mathlib.AlgebraicGeometry.Morphisms.Separated","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\ninst‚úù : AlgebraicGeometry.IsSeparated g\n‚ä¢ AlgebraicGeometry.IsClosedImmersion (CategoryTheory.Limits.pullback.lift (CategoryTheory.CategoryStruct.id X) f ‚ãØ)","decl":"/-- Given `f : X ‚ü∂ Y` and `g : Y ‚ü∂ Z` such that `g` is separated, the induced map\n`X ‚ü∂ X √ó[Z] Y` is a closed immersion. -/\ninstance [IsSeparated g] :\n    IsClosedImmersion (pullback.lift (ùüô _) f (Category.id_comp (f ‚â´ g))) := by\n  rw [‚Üê MorphismProperty.cancel_left_of_respectsIso @IsClosedImmersion (pullback.fst f (ùüô Y))]\n  rw [‚Üê MorphismProperty.cancel_right_of_respectsIso @IsClosedImmersion _\n    (pullback.congrHom rfl (Category.id_comp g)).inv]\n  convert (inferInstanceAs <| IsClosedImmersion (pullback.mapDesc f (ùüô _) g)) using 1\n  ext : 1 <;> simp [pullback.condition]\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.diagonalCoverDiagonalRange_eq_top_of_injective","module":"Mathlib.AlgebraicGeometry.Morphisms.Separated","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nùí∞ : Y.OpenCover\nùí± : (i : ùí∞.J) ‚Üí (CategoryTheory.Limits.pullback f (ùí∞.map i)).OpenCover\nhf : Function.Injective ‚áëf.base\n‚ä¢ Eq (AlgebraicGeometry.Scheme.Pullback.diagonalCoverDiagonalRange f ùí∞ ùí±) Top.top","decl":"lemma Scheme.Pullback.diagonalCoverDiagonalRange_eq_top_of_injective\n    (hf : Function.Injective f.base) :\n    diagonalCoverDiagonalRange f ùí∞ ùí± = ‚ä§ := by\n  rw [‚Üê top_le_iff]\n  rintro x -\n  simp only [diagonalCoverDiagonalRange, openCoverOfBase_J, openCoverOfBase_obj,\n    openCoverOfLeftRight_J, Opens.iSup_mk, Opens.carrier_eq_coe, Hom.coe_opensRange, Opens.coe_mk,\n    Set.mem_iUnion, Set.mem_range, Sigma.exists]\n  have H : (pullback.fst f f).base x = (pullback.snd f f).base x :=\n    hf (by rw [‚Üê Scheme.comp_base_apply, ‚Üê Scheme.comp_base_apply, pullback.condition])\n  let i := ùí∞.f (f.base ((pullback.fst f f).base x))\n  obtain ‚ü®y : ùí∞.obj i, hy : (ùí∞.map i).base y = f.base _‚ü© :=\n    ùí∞.covers (f.base ((pullback.fst f f).base x))\n  obtain ‚ü®z, hz‚ÇÅ, hz‚ÇÇ‚ü© := exists_preimage_pullback _ _ hy.symm\n  let j := (ùí± i).f z\n  obtain ‚ü®w : (ùí± i).obj j, hy : ((ùí± i).map j).base w = z‚ü© := (ùí± i).covers z\n  refine ‚ü®i, j, ?_‚ü©\n  simp_rw [diagonalCover_map]\n  show x ‚àà Set.range _\n  dsimp only [diagonalCover, Cover.bind_obj, openCoverOfLeftRight_obj]\n  rw [range_map]\n  simp [‚Üê H, ‚Üê hz‚ÇÅ, ‚Üê hy]\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.range_diagonal_subset_diagonalCoverDiagonalRange","module":"Mathlib.AlgebraicGeometry.Morphisms.Separated","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nùí∞ : Y.OpenCover\nùí± : (i : ùí∞.J) ‚Üí (CategoryTheory.Limits.pullback f (ùí∞.map i)).OpenCover\n‚ä¢ HasSubset.Subset (Set.range ‚áë(CategoryTheory.Limits.pullback.diagonal f).base) ‚Üë(AlgebraicGeometry.Scheme.Pullback.diagonalCoverDiagonalRange f ùí∞ ùí±)","decl":"lemma Scheme.Pullback.range_diagonal_subset_diagonalCoverDiagonalRange :\n    Set.range (pullback.diagonal f).base ‚äÜ diagonalCoverDiagonalRange f ùí∞ ùí± := by\n  rintro _ ‚ü®x, rfl‚ü©\n  simp only [diagonalCoverDiagonalRange, openCoverOfBase_J, openCoverOfBase_obj,\n    openCoverOfLeftRight_J, Opens.iSup_mk, Opens.carrier_eq_coe, Hom.coe_opensRange, Opens.coe_mk,\n    Set.mem_iUnion, Set.mem_range, Sigma.exists]\n  let i := ùí∞.f (f.base x)\n  obtain ‚ü®y : ùí∞.obj i, hy : (ùí∞.map i).base y = f.base x‚ü© := ùí∞.covers (f.base x)\n  obtain ‚ü®z, hz‚ÇÅ, hz‚ÇÇ‚ü© := exists_preimage_pullback _ _ hy.symm\n  let j := (ùí± i).f z\n  obtain ‚ü®w : (ùí± i).obj j, hy : ((ùí± i).map j).base w = z‚ü© := (ùí± i).covers z\n  refine ‚ü®i, j, (pullback.diagonal ((ùí± i).map j ‚â´ pullback.snd f (ùí∞.map i))).base w, ?_‚ü©\n  rw [‚Üê hz‚ÇÅ, ‚Üê hy, ‚Üê Scheme.comp_base_apply, ‚Üê Scheme.comp_base_apply]\n  dsimp only [diagonalCover, Cover.pullbackHom, Cover.bind_obj, openCoverOfLeftRight_obj]\n  rw [‚Üê Scheme.comp_base_apply]\n  congr 4\n  apply pullback.hom_ext <;> simp\n\n"}
{"name":"AlgebraicGeometry.isClosedImmersion_diagonal_restrict_diagonalCoverDiagonalRange","module":"Mathlib.AlgebraicGeometry.Morphisms.Separated","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nùí∞ : Y.OpenCover\nùí± : (i : ùí∞.J) ‚Üí (CategoryTheory.Limits.pullback f (ùí∞.map i)).OpenCover\ninst‚úù¬π : ‚àÄ (i : ùí∞.J), AlgebraicGeometry.IsAffine (ùí∞.obj i)\ninst‚úù : ‚àÄ (i : ùí∞.J) (j : (ùí± i).J), AlgebraicGeometry.IsAffine ((ùí± i).obj j)\n‚ä¢ AlgebraicGeometry.IsClosedImmersion (AlgebraicGeometry.morphismRestrict (CategoryTheory.Limits.pullback.diagonal f) (AlgebraicGeometry.Scheme.Pullback.diagonalCoverDiagonalRange f ùí∞ ùí±))","decl":"lemma isClosedImmersion_diagonal_restrict_diagonalCoverDiagonalRange\n    [‚àÄ i, IsAffine (ùí∞.obj i)] [‚àÄ i j, IsAffine ((ùí± i).obj j)] :\n    IsClosedImmersion (pullback.diagonal f ‚à£_ diagonalCoverDiagonalRange f ùí∞ ùí±) := by\n  let U : (Œ£ i, (ùí± i).J) ‚Üí (diagonalCoverDiagonalRange f ùí∞ ùí±).toScheme.Opens := fun i ‚Ü¶\n    (diagonalCoverDiagonalRange f ùí∞ ùí±).Œπ ‚Åª¬π·µÅ ((diagonalCover f ùí∞ ùí±).map ‚ü®i.1, i.2, i.2‚ü©).opensRange\n  have hU (i) : (diagonalCoverDiagonalRange f ùí∞ ùí±).Œπ ''·µÅ U i =\n      ((diagonalCover f ùí∞ ùí±).map ‚ü®i.1, i.2, i.2‚ü©).opensRange := by\n    rw [TopologicalSpace.Opens.functor_obj_map_obj, inf_eq_right, Hom.image_top_eq_opensRange,\n      Opens.opensRange_Œπ]\n    exact le_iSup (fun i : Œ£ i, (ùí± i).J ‚Ü¶ ((diagonalCover f ùí∞ ùí±).map ‚ü®i.1, i.2, i.2‚ü©).opensRange) i\n  have hf : iSup U = ‚ä§ := (TopologicalSpace.Opens.map_iSup _ _).symm.trans\n    (diagonalCoverDiagonalRange f ùí∞ ùí±).Œπ_preimage_self\n  rw [IsLocalAtTarget.iff_of_iSup_eq_top (P := @IsClosedImmersion) _ hf]\n  intro i\n  rw [MorphismProperty.arrow_mk_iso_iff (P := @IsClosedImmersion) (morphismRestrictRestrict _ _ _),\n    MorphismProperty.arrow_mk_iso_iff (P := @IsClosedImmersion) (morphismRestrictEq _ (hU i)),\n    MorphismProperty.arrow_mk_iso_iff (P := @IsClosedImmersion) (diagonalRestrictIsoDiagonal ..)]\n  infer_instance\n\n"}
{"name":"AlgebraicGeometry.isSeparated_of_injective","module":"Mathlib.AlgebraicGeometry.Morphisms.Separated","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nhf : Function.Injective ‚áëf.base\n‚ä¢ AlgebraicGeometry.IsSeparated f","decl":"@[stacks 0DVA]\nlemma isSeparated_of_injective (hf : Function.Injective f.base) :\n    IsSeparated f := by\n  constructor\n  let ùí∞ := Y.affineCover\n  let ùí± (i) := (pullback f (ùí∞.map i)).affineCover\n  refine IsLocalAtTarget.of_iSup_eq_top (fun i : PUnit.{0} ‚Ü¶ ‚ä§) (by simp) fun _ ‚Ü¶ ?_\n  rw [‚Üê diagonalCoverDiagonalRange_eq_top_of_injective f ùí∞ ùí± hf]\n  exact isClosedImmersion_diagonal_restrict_diagonalCoverDiagonalRange f ùí∞ ùí±\n\n"}
{"name":"AlgebraicGeometry.IsClosedImmersion.of_comp","module":"Mathlib.AlgebraicGeometry.Morphisms.Separated","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\ninst‚úù¬π : AlgebraicGeometry.IsClosedImmersion (CategoryTheory.CategoryStruct.comp f g)\ninst‚úù : AlgebraicGeometry.IsSeparated g\n‚ä¢ AlgebraicGeometry.IsClosedImmersion f","decl":"lemma IsClosedImmersion.of_comp [IsClosedImmersion (f ‚â´ g)] [IsSeparated g] :\n    IsClosedImmersion f := by\n  rw [‚Üê pullback.lift_snd (ùüô _) f (Category.id_comp (f ‚â´ g))]\n  have := MorphismProperty.pullback_snd (P := @IsClosedImmersion) (f ‚â´ g) g inferInstance\n  infer_instance\n\n"}
{"name":"AlgebraicGeometry.IsSeparated.of_comp","module":"Mathlib.AlgebraicGeometry.Morphisms.Separated","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\ninst‚úù : AlgebraicGeometry.IsSeparated (CategoryTheory.CategoryStruct.comp f g)\n‚ä¢ AlgebraicGeometry.IsSeparated f","decl":"lemma IsSeparated.of_comp [IsSeparated (f ‚â´ g)] : IsSeparated f := by\n  have := IsSeparated.diagonal_isClosedImmersion (f := f ‚â´ g)\n  rw [pullback.diagonal_comp] at this\n  exact ‚ü®@IsClosedImmersion.of_comp _ _ _ _ _ this inferInstance‚ü©\n\n"}
{"name":"AlgebraicGeometry.IsSeparated.comp_iff","module":"Mathlib.AlgebraicGeometry.Morphisms.Separated","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\ninst‚úù : AlgebraicGeometry.IsSeparated g\n‚ä¢ Iff (AlgebraicGeometry.IsSeparated (CategoryTheory.CategoryStruct.comp f g)) (AlgebraicGeometry.IsSeparated f)","decl":"lemma IsSeparated.comp_iff [IsSeparated g] : IsSeparated (f ‚â´ g) ‚Üî IsSeparated f :=\n  ‚ü®fun _ ‚Ü¶ .of_comp f g, fun _ ‚Ü¶ inferInstance‚ü©\n\n"}
{"name":"AlgebraicGeometry.isClosedImmersion_equalizer_Œπ_left","module":"Mathlib.AlgebraicGeometry.Morphisms.Separated","initialProofState":"S : AlgebraicGeometry.Scheme\nX Y : CategoryTheory.Over S\ninst‚úù : AlgebraicGeometry.IsSeparated Y.hom\nf g : Quiver.Hom X Y\n‚ä¢ AlgebraicGeometry.IsClosedImmersion (CategoryTheory.Limits.equalizer.Œπ f g).left","decl":"@[stacks 01KM]\ninstance isClosedImmersion_equalizer_Œπ_left {S : Scheme} {X Y : Over S} [IsSeparated Y.hom]\n    (f g : X ‚ü∂ Y) : IsClosedImmersion (equalizer.Œπ f g).left := by\n  refine MorphismProperty.of_isPullback\n    ((Limits.isPullback_equalizer_prod f g).map (Over.forget _)).flip ?_\n  rw [‚Üê MorphismProperty.cancel_right_of_respectsIso @IsClosedImmersion _\n    (Over.prodLeftIsoPullback Y Y).hom]\n  convert (inferInstanceAs (IsClosedImmersion (pullback.diagonal Y.hom)))\n  ext1 <;> simp [‚Üê Over.comp_left]\n\n"}
{"name":"AlgebraicGeometry.ext_of_isDominant_of_isSeparated","module":"Mathlib.AlgebraicGeometry.Morphisms.Separated","initialProofState":"W X Y Z : AlgebraicGeometry.Scheme\ninst‚úù¬≤ : AlgebraicGeometry.IsReduced X\nf g : Quiver.Hom X Y\ns : Quiver.Hom Y Z\ninst‚úù¬π : AlgebraicGeometry.IsSeparated s\nh : Eq (CategoryTheory.CategoryStruct.comp f s) (CategoryTheory.CategoryStruct.comp g s)\nŒπ : Quiver.Hom W X\ninst‚úù : AlgebraicGeometry.IsDominant Œπ\nhU : Eq (CategoryTheory.CategoryStruct.comp Œπ f) (CategoryTheory.CategoryStruct.comp Œπ g)\n‚ä¢ Eq f g","decl":"/--\nSuppose `X` is a reduced scheme and that `f g : X ‚ü∂ Y` agree over some separated `Y ‚ü∂ Z`.\nThen `f = g` if `Œπ ‚â´ f = Œπ ‚â´ g` for some dominant `Œπ`.\n-/\nlemma ext_of_isDominant_of_isSeparated [IsReduced X] {f g : X ‚ü∂ Y}\n    (s : Y ‚ü∂ Z) [IsSeparated s] (h : f ‚â´ s = g ‚â´ s)\n    (Œπ : W ‚ü∂ X) [IsDominant Œπ] (hU : Œπ ‚â´ f = Œπ ‚â´ g) : f = g := by\n  let X' : Over Z := Over.mk (f ‚â´ s)\n  let Y' : Over Z := Over.mk s\n  let U' : Over Z := Over.mk (Œπ ‚â´ f ‚â´ s)\n  let f' : X' ‚ü∂ Y' := Over.homMk f\n  let g' : X' ‚ü∂ Y' := Over.homMk g\n  let Œπ' : U' ‚ü∂ X' := Over.homMk Œπ\n  have : IsSeparated Y'.hom := ‚Äπ_‚Ä∫\n  have : IsDominant (equalizer.Œπ f' g').left := by\n    apply (config := { allowSynthFailures := true }) IsDominant.of_comp (equalizer.lift Œπ' ?_).left\n    ¬∑ rwa [‚Üê Over.comp_left, equalizer.lift_Œπ]\n    ¬∑ ext1; exact hU\n  have : Surjective (equalizer.Œπ f' g').left :=\n    surjective_of_isDominant_of_isClosed_range _ IsClosedImmersion.base_closed.2\n  have := isIso_of_isClosedImmersion_of_surjective (Y := X) (equalizer.Œπ f' g').left\n  rw [‚Üê cancel_epi (equalizer.Œπ f' g').left]\n  exact congr($(equalizer.condition f' g').left)\n\n"}
{"name":"AlgebraicGeometry.ext_of_isDominant_of_isSeparated'","module":"Mathlib.AlgebraicGeometry.Morphisms.Separated","initialProofState":"X Y S : AlgebraicGeometry.Scheme\ninst‚úù‚Å∂ : X.Over S\ninst‚úù‚Åµ : Y.Over S\ninst‚úù‚Å¥ : AlgebraicGeometry.IsReduced X\ninst‚úù¬≥ : AlgebraicGeometry.IsSeparated (CategoryTheory.over Y S inferInstance)\nf g : Quiver.Hom X Y\ninst‚úù¬≤ : AlgebraicGeometry.Scheme.Hom.IsOver f S\ninst‚úù¬π : AlgebraicGeometry.Scheme.Hom.IsOver g S\nW : AlgebraicGeometry.Scheme\nŒπ : Quiver.Hom W X\ninst‚úù : AlgebraicGeometry.IsDominant Œπ\nhU : Eq (CategoryTheory.CategoryStruct.comp Œπ f) (CategoryTheory.CategoryStruct.comp Œπ g)\n‚ä¢ Eq f g","decl":"variable (S) in\n/--\nSuppose `X` is a reduced `S`-scheme and `Y` is a separated `S`-scheme.\nFor any `S`-morphisms `f g : X ‚ü∂ Y`, `f = g` if `Œπ ‚â´ f = Œπ ‚â´ g` for some dominant `Œπ`.\n-/\nlemma ext_of_isDominant_of_isSeparated' [X.Over S] [Y.Over S] [IsReduced X] [IsSeparated (Y ‚Üò S)]\n    {f g : X ‚ü∂ Y} [f.IsOver S] [g.IsOver S] {W} (Œπ : W ‚ü∂ X) [IsDominant Œπ]\n    (hU : Œπ ‚â´ f = Œπ ‚â´ g) : f = g :=\n  ext_of_isDominant_of_isSeparated (Y ‚Üò S) (by simp) Œπ hU\n\n"}
{"name":"AlgebraicGeometry.Scheme.isSeparated_iff","module":"Mathlib.AlgebraicGeometry.Morphisms.Separated","initialProofState":"X : AlgebraicGeometry.Scheme\n‚ä¢ Iff X.IsSeparated (AlgebraicGeometry.IsSeparated (CategoryTheory.Limits.terminal.from X))","decl":"/-- A scheme `X` is separated if it is separated over `‚ä§_ Scheme`. -/\n@[mk_iff]\nprotected class IsSeparated (X : Scheme.{u}) : Prop where\n  isSeparated_terminal_from : IsSeparated (terminal.from X)\n\n"}
{"name":"AlgebraicGeometry.Scheme.IsSeparated.isSeparated_terminal_from","module":"Mathlib.AlgebraicGeometry.Morphisms.Separated","initialProofState":"X : AlgebraicGeometry.Scheme\nself : X.IsSeparated\n‚ä¢ AlgebraicGeometry.IsSeparated (CategoryTheory.Limits.terminal.from X)","decl":"/-- A scheme `X` is separated if it is separated over `‚ä§_ Scheme`. -/\n@[mk_iff]\nprotected class IsSeparated (X : Scheme.{u}) : Prop where\n  isSeparated_terminal_from : IsSeparated (terminal.from X)\n\n"}
{"name":"AlgebraicGeometry.Scheme.isSeparated_iff_isClosedImmersion_prod_lift","module":"Mathlib.AlgebraicGeometry.Morphisms.Separated","initialProofState":"X : AlgebraicGeometry.Scheme\n‚ä¢ Iff X.IsSeparated (AlgebraicGeometry.IsClosedImmersion (CategoryTheory.Limits.prod.lift (CategoryTheory.CategoryStruct.id X) (CategoryTheory.CategoryStruct.id X)))","decl":"lemma isSeparated_iff_isClosedImmersion_prod_lift {X : Scheme.{u}} :\n    X.IsSeparated ‚Üî IsClosedImmersion (prod.lift (ùüô X) (ùüô X)) := by\n  rw [isSeparated_iff, AlgebraicGeometry.isSeparated_iff, iff_iff_eq,\n    ‚Üê MorphismProperty.cancel_right_of_respectsIso @IsClosedImmersion _ (prodIsoPullback X X).hom]\n  congr\n  ext : 1 <;> simp\n\n"}
{"name":"AlgebraicGeometry.Scheme.instIsClosedImmersionLiftIdOfIsSeparated","module":"Mathlib.AlgebraicGeometry.Morphisms.Separated","initialProofState":"X : AlgebraicGeometry.Scheme\ninst‚úù : X.IsSeparated\n‚ä¢ AlgebraicGeometry.IsClosedImmersion (CategoryTheory.Limits.prod.lift (CategoryTheory.CategoryStruct.id X) (CategoryTheory.CategoryStruct.id X))","decl":"instance [X.IsSeparated] : IsClosedImmersion (prod.lift (ùüô X) (ùüô X)) := by\n  rwa [‚Üê isSeparated_iff_isClosedImmersion_prod_lift]\n\n"}
{"name":"AlgebraicGeometry.Scheme.instIsSeparatedOfIsAffine","module":"Mathlib.AlgebraicGeometry.Morphisms.Separated","initialProofState":"X : AlgebraicGeometry.Scheme\ninst‚úù : AlgebraicGeometry.IsAffine X\n‚ä¢ X.IsSeparated","decl":"instance (priority := 900) {X : Scheme.{u}} [IsAffine X] : X.IsSeparated := ‚ü®inferInstance‚ü©\n\n"}
{"name":"AlgebraicGeometry.Scheme.instIsSeparatedOfIsSeparated","module":"Mathlib.AlgebraicGeometry.Morphisms.Separated","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\ninst‚úù : X.IsSeparated\n‚ä¢ AlgebraicGeometry.IsSeparated f","decl":"instance (priority := 900) [X.IsSeparated] : IsSeparated f := by\n  apply (config := { allowSynthFailures := true }) @IsSeparated.of_comp (g := terminal.from Y)\n  rw [terminal.comp_from]\n  infer_instance\n\n"}
{"name":"AlgebraicGeometry.Scheme.instIsClosedImmersionŒπOfIsSeparated","module":"Mathlib.AlgebraicGeometry.Morphisms.Separated","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf g : Quiver.Hom X Y\ninst‚úù : Y.IsSeparated\n‚ä¢ AlgebraicGeometry.IsClosedImmersion (CategoryTheory.Limits.equalizer.Œπ f g)","decl":"instance (f g : X ‚ü∂ Y) [Y.IsSeparated] : IsClosedImmersion (Limits.equalizer.Œπ f g) :=\n  MorphismProperty.of_isPullback (isPullback_equalizer_prod f g).flip inferInstance\n\n"}
{"name":"AlgebraicGeometry.IsSeparated.hasAffineProperty","module":"Mathlib.AlgebraicGeometry.Morphisms.Separated","initialProofState":"‚ä¢ AlgebraicGeometry.HasAffineProperty @AlgebraicGeometry.IsSeparated fun X x x_1 x => X.IsSeparated","decl":"instance IsSeparated.hasAffineProperty :\n    HasAffineProperty @IsSeparated fun X _ _ _ ‚Ü¶ X.IsSeparated := by\n  convert HasAffineProperty.of_isLocalAtTarget @IsSeparated with X Y f hY\n  rw [Scheme.isSeparated_iff, ‚Üê terminal.comp_from f, IsSeparated.comp_iff]\n  rfl\n\n"}
{"name":"AlgebraicGeometry.ext_of_isDominant","module":"Mathlib.AlgebraicGeometry.Morphisms.Separated","initialProofState":"W X Y : AlgebraicGeometry.Scheme\ninst‚úù¬≤ : AlgebraicGeometry.IsReduced X\nf g : Quiver.Hom X Y\ninst‚úù¬π : Y.IsSeparated\nŒπ : Quiver.Hom W X\ninst‚úù : AlgebraicGeometry.IsDominant Œπ\nhU : Eq (CategoryTheory.CategoryStruct.comp Œπ f) (CategoryTheory.CategoryStruct.comp Œπ g)\n‚ä¢ Eq f g","decl":"/--\nSuppose `f g : X ‚ü∂ Y` where `X` is a reduced scheme and `Y` is a separated scheme.\nThen `f = g` if `Œπ ‚â´ f = Œπ ‚â´ g` for some dominant `Œπ`.\n\nAlso see `ext_of_isDominant_of_isSeparated` for the general version over arbitrary bases.\n-/\nlemma ext_of_isDominant [IsReduced X] {f g : X ‚ü∂ Y} [Y.IsSeparated]\n    (Œπ : W ‚ü∂ X) [IsDominant Œπ] (hU : Œπ ‚â´ f = Œπ ‚â´ g) : f = g :=\n  ext_of_isDominant_of_isSeparated (Limits.terminal.from _) (Limits.terminal.hom_ext _ _) Œπ hU\n\n"}
