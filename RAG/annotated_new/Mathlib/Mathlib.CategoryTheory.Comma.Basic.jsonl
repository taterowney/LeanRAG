{"name":"CategoryTheory.Comma.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝⁵ : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝³ : CategoryTheory.Category.{v₃, u₃} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\ninst✝² : SizeOf A\ninst✝¹ : SizeOf B\ninst✝ : SizeOf T\nleft : A\nright : B\nhom : Quiver.Hom (L.obj left) (R.obj right)\n⊢ Eq (SizeOf.sizeOf { left := left, right := right, hom := hom }) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf left)) (SizeOf.sizeOf right)) (SizeOf.sizeOf hom))","decl":"/-- The objects of the comma category are triples of an object `left : A`, an object\n   `right : B` and a morphism `hom : L.obj left ⟶ R.obj right`. -/\nstructure Comma (L : A ⥤ T) (R : B ⥤ T) : Type max u₁ u₂ v₃ where\n  left : A\n  right : B\n  hom : L.obj left ⟶ R.obj right\n\n-- Satisfying the inhabited linter\n"}
{"name":"CategoryTheory.Comma.mk.injEq","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nleft✝ : A\nright✝ : B\nhom✝ : Quiver.Hom (L.obj left✝) (R.obj right✝)\nleft : A\nright : B\nhom : Quiver.Hom (L.obj left) (R.obj right)\n⊢ Eq (Eq { left := left✝, right := right✝, hom := hom✝ } { left := left, right := right, hom := hom }) (And (Eq left✝ left) (And (Eq right✝ right) (HEq hom✝ hom)))","decl":"/-- The objects of the comma category are triples of an object `left : A`, an object\n   `right : B` and a morphism `hom : L.obj left ⟶ R.obj right`. -/\nstructure Comma (L : A ⥤ T) (R : B ⥤ T) : Type max u₁ u₂ v₃ where\n  left : A\n  right : B\n  hom : L.obj left ⟶ R.obj right\n\n-- Satisfying the inhabited linter\n"}
{"name":"CategoryTheory.Comma.mk.inj","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nleft✝ : A\nright✝ : B\nhom✝ : Quiver.Hom (L.obj left✝) (R.obj right✝)\nleft : A\nright : B\nhom : Quiver.Hom (L.obj left) (R.obj right)\nx✝ : Eq { left := left✝, right := right✝, hom := hom✝ } { left := left, right := right, hom := hom }\n⊢ And (Eq left✝ left) (And (Eq right✝ right) (HEq hom✝ hom))","decl":"/-- The objects of the comma category are triples of an object `left : A`, an object\n   `right : B` and a morphism `hom : L.obj left ⟶ R.obj right`. -/\nstructure Comma (L : A ⥤ T) (R : B ⥤ T) : Type max u₁ u₂ v₃ where\n  left : A\n  right : B\n  hom : L.obj left ⟶ R.obj right\n\n-- Satisfying the inhabited linter\n"}
{"name":"CategoryTheory.CommaMorphism.mk.injEq","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nX Y : CategoryTheory.Comma L R\nleft✝ : Quiver.Hom X.left Y.left\nright✝ : Quiver.Hom X.right Y.right\nw✝ : autoParam (Eq (CategoryTheory.CategoryStruct.comp (L.map left✝) Y.hom) (CategoryTheory.CategoryStruct.comp X.hom (R.map right✝))) _auto✝\nleft : Quiver.Hom X.left Y.left\nright : Quiver.Hom X.right Y.right\nw : autoParam (Eq (CategoryTheory.CategoryStruct.comp (L.map left) Y.hom) (CategoryTheory.CategoryStruct.comp X.hom (R.map right))) _auto✝\n⊢ Eq (Eq { left := left✝, right := right✝, w := w✝ } { left := left, right := right, w := w }) (And (Eq left✝ left) (Eq right✝ right))","decl":"/-- A morphism between two objects in the comma category is a commutative square connecting the\n    morphisms coming from the two objects using morphisms in the image of the functors `L` and `R`.\n-/\n@[ext]\nstructure CommaMorphism (X Y : Comma L R) where\n  left : X.left ⟶ Y.left\n  right : X.right ⟶ Y.right\n  w : L.map left ≫ Y.hom = X.hom ≫ R.map right := by aesop_cat\n\n-- Satisfying the inhabited linter\n"}
{"name":"CategoryTheory.CommaMorphism.w","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nX Y : CategoryTheory.Comma L R\nself : CategoryTheory.CommaMorphism X Y\n⊢ Eq (CategoryTheory.CategoryStruct.comp (L.map self.left) Y.hom) (CategoryTheory.CategoryStruct.comp X.hom (R.map self.right))","decl":"/-- A morphism between two objects in the comma category is a commutative square connecting the\n    morphisms coming from the two objects using morphisms in the image of the functors `L` and `R`.\n-/\n@[ext]\nstructure CommaMorphism (X Y : Comma L R) where\n  left : X.left ⟶ Y.left\n  right : X.right ⟶ Y.right\n  w : L.map left ≫ Y.hom = X.hom ≫ R.map right := by aesop_cat\n\n-- Satisfying the inhabited linter\n"}
{"name":"CategoryTheory.CommaMorphism.mk.inj","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nX Y : CategoryTheory.Comma L R\nleft✝ : Quiver.Hom X.left Y.left\nright✝ : Quiver.Hom X.right Y.right\nw✝ : autoParam (Eq (CategoryTheory.CategoryStruct.comp (L.map left✝) Y.hom) (CategoryTheory.CategoryStruct.comp X.hom (R.map right✝))) _auto✝\nleft : Quiver.Hom X.left Y.left\nright : Quiver.Hom X.right Y.right\nw : autoParam (Eq (CategoryTheory.CategoryStruct.comp (L.map left) Y.hom) (CategoryTheory.CategoryStruct.comp X.hom (R.map right))) _auto✝\nx✝ : Eq { left := left✝, right := right✝, w := w✝ } { left := left, right := right, w := w }\n⊢ And (Eq left✝ left) (Eq right✝ right)","decl":"/-- A morphism between two objects in the comma category is a commutative square connecting the\n    morphisms coming from the two objects using morphisms in the image of the functors `L` and `R`.\n-/\n@[ext]\nstructure CommaMorphism (X Y : Comma L R) where\n  left : X.left ⟶ Y.left\n  right : X.right ⟶ Y.right\n  w : L.map left ≫ Y.hom = X.hom ≫ R.map right := by aesop_cat\n\n-- Satisfying the inhabited linter\n"}
{"name":"CategoryTheory.CommaMorphism.ext","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nX Y : CategoryTheory.Comma L R\nx y : CategoryTheory.CommaMorphism X Y\nleft : Eq x.left y.left\nright : Eq x.right y.right\n⊢ Eq x y","decl":"/-- A morphism between two objects in the comma category is a commutative square connecting the\n    morphisms coming from the two objects using morphisms in the image of the functors `L` and `R`.\n-/\n@[ext]\nstructure CommaMorphism (X Y : Comma L R) where\n  left : X.left ⟶ Y.left\n  right : X.right ⟶ Y.right\n  w : L.map left ≫ Y.hom = X.hom ≫ R.map right := by aesop_cat\n\n-- Satisfying the inhabited linter\n"}
{"name":"CategoryTheory.CommaMorphism.ext_iff","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nX Y : CategoryTheory.Comma L R\nx y : CategoryTheory.CommaMorphism X Y\n⊢ Iff (Eq x y) (And (Eq x.left y.left) (Eq x.right y.right))","decl":"/-- A morphism between two objects in the comma category is a commutative square connecting the\n    morphisms coming from the two objects using morphisms in the image of the functors `L` and `R`.\n-/\n@[ext]\nstructure CommaMorphism (X Y : Comma L R) where\n  left : X.left ⟶ Y.left\n  right : X.right ⟶ Y.right\n  w : L.map left ≫ Y.hom = X.hom ≫ R.map right := by aesop_cat\n\n-- Satisfying the inhabited linter\n"}
{"name":"CategoryTheory.CommaMorphism.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝⁵ : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝³ : CategoryTheory.Category.{v₃, u₃} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nX Y : CategoryTheory.Comma L R\ninst✝² : SizeOf A\ninst✝¹ : SizeOf B\ninst✝ : SizeOf T\nleft : Quiver.Hom X.left Y.left\nright : Quiver.Hom X.right Y.right\nw : autoParam (Eq (CategoryTheory.CategoryStruct.comp (L.map left) Y.hom) (CategoryTheory.CategoryStruct.comp X.hom (R.map right))) _auto✝\n⊢ Eq (SizeOf.sizeOf { left := left, right := right, w := w }) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf left)) (SizeOf.sizeOf right)) (SizeOf.sizeOf w))","decl":"/-- A morphism between two objects in the comma category is a commutative square connecting the\n    morphisms coming from the two objects using morphisms in the image of the functors `L` and `R`.\n-/\n@[ext]\nstructure CommaMorphism (X Y : Comma L R) where\n  left : X.left ⟶ Y.left\n  right : X.right ⟶ Y.right\n  w : L.map left ≫ Y.hom = X.hom ≫ R.map right := by aesop_cat\n\n-- Satisfying the inhabited linter\n"}
{"name":"CategoryTheory.CommaMorphism.w_assoc","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nX Y : CategoryTheory.Comma L R\nself : CategoryTheory.CommaMorphism X Y\nZ : T\nh : Quiver.Hom (R.obj Y.right) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (L.map self.left) (CategoryTheory.CategoryStruct.comp Y.hom h)) (CategoryTheory.CategoryStruct.comp X.hom (CategoryTheory.CategoryStruct.comp (R.map self.right) h))","decl":"attribute [reassoc (attr := simp)] CommaMorphism.w\n\n"}
{"name":"CategoryTheory.Comma.hom_ext","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nX Y : CategoryTheory.Comma L R\nf g : Quiver.Hom X Y\nh₁ : Eq f.left g.left\nh₂ : Eq f.right g.right\n⊢ Eq f g","decl":"@[ext]\nlemma hom_ext (f g : X ⟶ Y) (h₁ : f.left = g.left) (h₂ : f.right = g.right) : f = g :=\n  CommaMorphism.ext h₁ h₂\n\n"}
{"name":"CategoryTheory.Comma.hom_ext_iff","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nX Y : CategoryTheory.Comma L R\nf g : Quiver.Hom X Y\n⊢ Iff (Eq f g) (And (Eq f.left g.left) (Eq f.right g.right))","decl":"@[ext]\nlemma hom_ext (f g : X ⟶ Y) (h₁ : f.left = g.left) (h₂ : f.right = g.right) : f = g :=\n  CommaMorphism.ext h₁ h₂\n\n"}
{"name":"CategoryTheory.Comma.id_left","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nX : CategoryTheory.Comma L R\n⊢ Eq (CategoryTheory.CategoryStruct.id X).left (CategoryTheory.CategoryStruct.id X.left)","decl":"@[simp]\ntheorem id_left : (𝟙 X : CommaMorphism X X).left = 𝟙 X.left :=\n  rfl\n\n"}
{"name":"CategoryTheory.Comma.id_right","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nX : CategoryTheory.Comma L R\n⊢ Eq (CategoryTheory.CategoryStruct.id X).right (CategoryTheory.CategoryStruct.id X.right)","decl":"@[simp]\ntheorem id_right : (𝟙 X : CommaMorphism X X).right = 𝟙 X.right :=\n  rfl\n\n"}
{"name":"CategoryTheory.Comma.comp_left","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nX Y Z : CategoryTheory.Comma L R\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp f g).left (CategoryTheory.CategoryStruct.comp f.left g.left)","decl":"@[simp]\ntheorem comp_left : (f ≫ g).left = f.left ≫ g.left :=\n  rfl\n\n"}
{"name":"CategoryTheory.Comma.comp_right","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nX Y Z : CategoryTheory.Comma L R\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp f g).right (CategoryTheory.CategoryStruct.comp f.right g.right)","decl":"@[simp]\ntheorem comp_right : (f ≫ g).right = f.right ≫ g.right :=\n  rfl\n\n"}
{"name":"CategoryTheory.Comma.fst_map","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nX✝ Y✝ : CategoryTheory.Comma L R\nf : Quiver.Hom X✝ Y✝\n⊢ Eq ((CategoryTheory.Comma.fst L R).map f) f.left","decl":"/-- The functor sending an object `X` in the comma category to `X.left`. -/\n@[simps]\ndef fst : Comma L R ⥤ A where\n  obj X := X.left\n  map f := f.left\n\n"}
{"name":"CategoryTheory.Comma.fst_obj","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nX : CategoryTheory.Comma L R\n⊢ Eq ((CategoryTheory.Comma.fst L R).obj X) X.left","decl":"/-- The functor sending an object `X` in the comma category to `X.left`. -/\n@[simps]\ndef fst : Comma L R ⥤ A where\n  obj X := X.left\n  map f := f.left\n\n"}
{"name":"CategoryTheory.Comma.snd_map","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nX✝ Y✝ : CategoryTheory.Comma L R\nf : Quiver.Hom X✝ Y✝\n⊢ Eq ((CategoryTheory.Comma.snd L R).map f) f.right","decl":"/-- The functor sending an object `X` in the comma category to `X.right`. -/\n@[simps]\ndef snd : Comma L R ⥤ B where\n  obj X := X.right\n  map f := f.right\n\n"}
{"name":"CategoryTheory.Comma.snd_obj","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nX : CategoryTheory.Comma L R\n⊢ Eq ((CategoryTheory.Comma.snd L R).obj X) X.right","decl":"/-- The functor sending an object `X` in the comma category to `X.right`. -/\n@[simps]\ndef snd : Comma L R ⥤ B where\n  obj X := X.right\n  map f := f.right\n\n"}
{"name":"CategoryTheory.Comma.natTrans_app","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nX : CategoryTheory.Comma L R\n⊢ Eq ((CategoryTheory.Comma.natTrans L R).app X) X.hom","decl":"/-- We can interpret the commutative square constituting a morphism in the comma category as a\n    natural transformation between the functors `fst ⋙ L` and `snd ⋙ R` from the comma category\n    to `T`, where the components are given by the morphism that constitutes an object of the comma\n    category. -/\n@[simps]\ndef natTrans : fst L R ⋙ L ⟶ snd L R ⋙ R where app X := X.hom\n\n"}
{"name":"CategoryTheory.Comma.eqToHom_left","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nX Y : CategoryTheory.Comma L R\nH : Eq X Y\n⊢ Eq (CategoryTheory.eqToHom H).left (CategoryTheory.eqToHom ⋯)","decl":"@[simp]\ntheorem eqToHom_left (X Y : Comma L R) (H : X = Y) :\n    CommaMorphism.left (eqToHom H) = eqToHom (by cases H; rfl) := by\n  cases H\n  rfl\n\n"}
{"name":"CategoryTheory.Comma.eqToHom_right","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nX Y : CategoryTheory.Comma L R\nH : Eq X Y\n⊢ Eq (CategoryTheory.eqToHom H).right (CategoryTheory.eqToHom ⋯)","decl":"@[simp]\ntheorem eqToHom_right (X Y : Comma L R) (H : X = Y) :\n    CommaMorphism.right (eqToHom H) = eqToHom (by cases H; rfl) := by\n  cases H\n  rfl\n\n"}
{"name":"CategoryTheory.Comma.instIsIsoLeft","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nX Y : CategoryTheory.Comma L R\ne : Quiver.Hom X Y\ninst✝ : CategoryTheory.IsIso e\n⊢ CategoryTheory.IsIso e.left","decl":"instance [IsIso e] : IsIso e.left :=\n  (Comma.fst L R).map_isIso e\n\n"}
{"name":"CategoryTheory.Comma.instIsIsoRight","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nX Y : CategoryTheory.Comma L R\ne : Quiver.Hom X Y\ninst✝ : CategoryTheory.IsIso e\n⊢ CategoryTheory.IsIso e.right","decl":"instance [IsIso e] : IsIso e.right :=\n  (Comma.snd L R).map_isIso e\n\n"}
{"name":"CategoryTheory.Comma.inv_left","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nX Y : CategoryTheory.Comma L R\ne : Quiver.Hom X Y\ninst✝ : CategoryTheory.IsIso e\n⊢ Eq (CategoryTheory.inv e).left (CategoryTheory.inv e.left)","decl":"@[simp]\nlemma inv_left [IsIso e] : (inv e).left = inv e.left := by\n  apply IsIso.eq_inv_of_hom_inv_id\n  rw [← Comma.comp_left, IsIso.hom_inv_id, id_left]\n\n"}
{"name":"CategoryTheory.Comma.inv_right","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nX Y : CategoryTheory.Comma L R\ne : Quiver.Hom X Y\ninst✝ : CategoryTheory.IsIso e\n⊢ Eq (CategoryTheory.inv e).right (CategoryTheory.inv e.right)","decl":"@[simp]\nlemma inv_right [IsIso e] : (inv e).right = inv e.right := by\n  apply IsIso.eq_inv_of_hom_inv_id\n  rw [← Comma.comp_right, IsIso.hom_inv_id, id_right]\n\n"}
{"name":"CategoryTheory.Comma.left_hom_inv_right","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nX Y : CategoryTheory.Comma L R\ne : Quiver.Hom X Y\ninst✝ : CategoryTheory.IsIso e\n⊢ Eq (CategoryTheory.CategoryStruct.comp (L.map e.left) (CategoryTheory.CategoryStruct.comp Y.hom (R.map (CategoryTheory.inv e.right)))) X.hom","decl":"lemma left_hom_inv_right [IsIso e] : L.map (e.left) ≫ Y.hom ≫ R.map (inv e.right) = X.hom := by\n  simp\n\n"}
{"name":"CategoryTheory.Comma.inv_left_hom_right","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nX Y : CategoryTheory.Comma L R\ne : Quiver.Hom X Y\ninst✝ : CategoryTheory.IsIso e\n⊢ Eq (CategoryTheory.CategoryStruct.comp (L.map (CategoryTheory.inv e.left)) (CategoryTheory.CategoryStruct.comp X.hom (R.map e.right))) Y.hom","decl":"lemma inv_left_hom_right [IsIso e] : L.map (inv e.left) ≫ X.hom ≫ R.map e.right = Y.hom := by\n  simp\n\n"}
{"name":"CategoryTheory.Comma.leftIso_hom","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} T\nL₁ : CategoryTheory.Functor A T\nR₁ : CategoryTheory.Functor B T\nX Y : CategoryTheory.Comma L₁ R₁\nα : CategoryTheory.Iso X Y\n⊢ Eq (CategoryTheory.Comma.leftIso α).hom α.hom.left","decl":"/-- Extract the isomorphism between the left objects from an isomorphism in the comma category. -/\n@[simps!]\ndef leftIso {X Y : Comma L₁ R₁} (α : X ≅ Y) : X.left ≅ Y.left := (fst L₁ R₁).mapIso α\n\n"}
{"name":"CategoryTheory.Comma.leftIso_inv","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} T\nL₁ : CategoryTheory.Functor A T\nR₁ : CategoryTheory.Functor B T\nX Y : CategoryTheory.Comma L₁ R₁\nα : CategoryTheory.Iso X Y\n⊢ Eq (CategoryTheory.Comma.leftIso α).inv α.inv.left","decl":"/-- Extract the isomorphism between the left objects from an isomorphism in the comma category. -/\n@[simps!]\ndef leftIso {X Y : Comma L₁ R₁} (α : X ≅ Y) : X.left ≅ Y.left := (fst L₁ R₁).mapIso α\n\n"}
{"name":"CategoryTheory.Comma.rightIso_hom","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} T\nL₁ : CategoryTheory.Functor A T\nR₁ : CategoryTheory.Functor B T\nX Y : CategoryTheory.Comma L₁ R₁\nα : CategoryTheory.Iso X Y\n⊢ Eq (CategoryTheory.Comma.rightIso α).hom α.hom.right","decl":"/-- Extract the isomorphism between the right objects from an isomorphism in the comma category. -/\n@[simps!]\ndef rightIso {X Y : Comma L₁ R₁} (α : X ≅ Y) : X.right ≅ Y.right := (snd L₁ R₁).mapIso α\n\n"}
{"name":"CategoryTheory.Comma.rightIso_inv","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} T\nL₁ : CategoryTheory.Functor A T\nR₁ : CategoryTheory.Functor B T\nX Y : CategoryTheory.Comma L₁ R₁\nα : CategoryTheory.Iso X Y\n⊢ Eq (CategoryTheory.Comma.rightIso α).inv α.inv.right","decl":"/-- Extract the isomorphism between the right objects from an isomorphism in the comma category. -/\n@[simps!]\ndef rightIso {X Y : Comma L₁ R₁} (α : X ≅ Y) : X.right ≅ Y.right := (snd L₁ R₁).mapIso α\n\n"}
{"name":"CategoryTheory.Comma.isoMk_hom_left","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} T\nL₁ : CategoryTheory.Functor A T\nR₁ : CategoryTheory.Functor B T\nX Y : CategoryTheory.Comma L₁ R₁\nl : CategoryTheory.Iso X.left Y.left\nr : CategoryTheory.Iso X.right Y.right\nh : autoParam (Eq (CategoryTheory.CategoryStruct.comp (L₁.map l.hom) Y.hom) (CategoryTheory.CategoryStruct.comp X.hom (R₁.map r.hom))) _auto✝\n⊢ Eq (CategoryTheory.Comma.isoMk l r h).hom.left l.hom","decl":"/-- Construct an isomorphism in the comma category given isomorphisms of the objects whose forward\ndirections give a commutative square.\n-/\n@[simps]\ndef isoMk {X Y : Comma L₁ R₁} (l : X.left ≅ Y.left) (r : X.right ≅ Y.right)\n    (h : L₁.map l.hom ≫ Y.hom = X.hom ≫ R₁.map r.hom := by aesop_cat) : X ≅ Y where\n  hom :=\n    { left := l.hom\n      right := r.hom\n      w := h }\n  inv :=\n    { left := l.inv\n      right := r.inv\n      w := by\n        rw [← L₁.mapIso_inv l, Iso.inv_comp_eq, L₁.mapIso_hom, ← Category.assoc, h,\n          Category.assoc, ← R₁.map_comp]\n        simp }\n\n"}
{"name":"CategoryTheory.Comma.isoMk_inv_left","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} T\nL₁ : CategoryTheory.Functor A T\nR₁ : CategoryTheory.Functor B T\nX Y : CategoryTheory.Comma L₁ R₁\nl : CategoryTheory.Iso X.left Y.left\nr : CategoryTheory.Iso X.right Y.right\nh : autoParam (Eq (CategoryTheory.CategoryStruct.comp (L₁.map l.hom) Y.hom) (CategoryTheory.CategoryStruct.comp X.hom (R₁.map r.hom))) _auto✝\n⊢ Eq (CategoryTheory.Comma.isoMk l r h).inv.left l.inv","decl":"/-- Construct an isomorphism in the comma category given isomorphisms of the objects whose forward\ndirections give a commutative square.\n-/\n@[simps]\ndef isoMk {X Y : Comma L₁ R₁} (l : X.left ≅ Y.left) (r : X.right ≅ Y.right)\n    (h : L₁.map l.hom ≫ Y.hom = X.hom ≫ R₁.map r.hom := by aesop_cat) : X ≅ Y where\n  hom :=\n    { left := l.hom\n      right := r.hom\n      w := h }\n  inv :=\n    { left := l.inv\n      right := r.inv\n      w := by\n        rw [← L₁.mapIso_inv l, Iso.inv_comp_eq, L₁.mapIso_hom, ← Category.assoc, h,\n          Category.assoc, ← R₁.map_comp]\n        simp }\n\n"}
{"name":"CategoryTheory.Comma.isoMk_hom_right","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} T\nL₁ : CategoryTheory.Functor A T\nR₁ : CategoryTheory.Functor B T\nX Y : CategoryTheory.Comma L₁ R₁\nl : CategoryTheory.Iso X.left Y.left\nr : CategoryTheory.Iso X.right Y.right\nh : autoParam (Eq (CategoryTheory.CategoryStruct.comp (L₁.map l.hom) Y.hom) (CategoryTheory.CategoryStruct.comp X.hom (R₁.map r.hom))) _auto✝\n⊢ Eq (CategoryTheory.Comma.isoMk l r h).hom.right r.hom","decl":"/-- Construct an isomorphism in the comma category given isomorphisms of the objects whose forward\ndirections give a commutative square.\n-/\n@[simps]\ndef isoMk {X Y : Comma L₁ R₁} (l : X.left ≅ Y.left) (r : X.right ≅ Y.right)\n    (h : L₁.map l.hom ≫ Y.hom = X.hom ≫ R₁.map r.hom := by aesop_cat) : X ≅ Y where\n  hom :=\n    { left := l.hom\n      right := r.hom\n      w := h }\n  inv :=\n    { left := l.inv\n      right := r.inv\n      w := by\n        rw [← L₁.mapIso_inv l, Iso.inv_comp_eq, L₁.mapIso_hom, ← Category.assoc, h,\n          Category.assoc, ← R₁.map_comp]\n        simp }\n\n"}
{"name":"CategoryTheory.Comma.isoMk_inv_right","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} T\nL₁ : CategoryTheory.Functor A T\nR₁ : CategoryTheory.Functor B T\nX Y : CategoryTheory.Comma L₁ R₁\nl : CategoryTheory.Iso X.left Y.left\nr : CategoryTheory.Iso X.right Y.right\nh : autoParam (Eq (CategoryTheory.CategoryStruct.comp (L₁.map l.hom) Y.hom) (CategoryTheory.CategoryStruct.comp X.hom (R₁.map r.hom))) _auto✝\n⊢ Eq (CategoryTheory.Comma.isoMk l r h).inv.right r.inv","decl":"/-- Construct an isomorphism in the comma category given isomorphisms of the objects whose forward\ndirections give a commutative square.\n-/\n@[simps]\ndef isoMk {X Y : Comma L₁ R₁} (l : X.left ≅ Y.left) (r : X.right ≅ Y.right)\n    (h : L₁.map l.hom ≫ Y.hom = X.hom ≫ R₁.map r.hom := by aesop_cat) : X ≅ Y where\n  hom :=\n    { left := l.hom\n      right := r.hom\n      w := h }\n  inv :=\n    { left := l.inv\n      right := r.inv\n      w := by\n        rw [← L₁.mapIso_inv l, Iso.inv_comp_eq, L₁.mapIso_hom, ← Category.assoc, h,\n          Category.assoc, ← R₁.map_comp]\n        simp }\n\n"}
{"name":"CategoryTheory.Comma.map_obj_hom","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝⁵ : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝³ : CategoryTheory.Category.{v₃, u₃} T\nA' : Type u₄\ninst✝² : CategoryTheory.Category.{v₄, u₄} A'\nB' : Type u₅\ninst✝¹ : CategoryTheory.Category.{v₅, u₅} B'\nT' : Type u₆\ninst✝ : CategoryTheory.Category.{v₆, u₆} T'\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nL' : CategoryTheory.Functor A' T'\nR' : CategoryTheory.Functor B' T'\nF₁ : CategoryTheory.Functor A A'\nF₂ : CategoryTheory.Functor B B'\nF : CategoryTheory.Functor T T'\nα : Quiver.Hom (F₁.comp L') (L.comp F)\nβ : Quiver.Hom (R.comp F) (F₂.comp R')\nX : CategoryTheory.Comma L R\n⊢ Eq ((CategoryTheory.Comma.map α β).obj X).hom (CategoryTheory.CategoryStruct.comp (α.app X.left) (CategoryTheory.CategoryStruct.comp (F.map X.hom) (β.app X.right)))","decl":"/-- The functor `Comma L R ⥤ Comma L' R'` induced by three functors `F₁`, `F₂`, `F`\nand two natural transformations `F₁ ⋙ L' ⟶ L ⋙ F` and `R ⋙ F ⟶ F₂ ⋙ R'`. -/\n@[simps]\ndef map : Comma L R ⥤ Comma L' R' where\n  obj X :=\n    { left := F₁.obj X.left\n      right := F₂.obj X.right\n      hom := α.app X.left ≫ F.map X.hom ≫ β.app X.right }\n  map {X Y} φ :=\n    { left := F₁.map φ.left\n      right := F₂.map φ.right\n      w := by\n        dsimp\n        rw [assoc, assoc]\n        erw [α.naturality_assoc, ← β.naturality]\n        dsimp\n        rw [← F.map_comp_assoc, ← F.map_comp_assoc, φ.w] }\n\n"}
{"name":"CategoryTheory.Comma.map_map_left","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝⁵ : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝³ : CategoryTheory.Category.{v₃, u₃} T\nA' : Type u₄\ninst✝² : CategoryTheory.Category.{v₄, u₄} A'\nB' : Type u₅\ninst✝¹ : CategoryTheory.Category.{v₅, u₅} B'\nT' : Type u₆\ninst✝ : CategoryTheory.Category.{v₆, u₆} T'\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nL' : CategoryTheory.Functor A' T'\nR' : CategoryTheory.Functor B' T'\nF₁ : CategoryTheory.Functor A A'\nF₂ : CategoryTheory.Functor B B'\nF : CategoryTheory.Functor T T'\nα : Quiver.Hom (F₁.comp L') (L.comp F)\nβ : Quiver.Hom (R.comp F) (F₂.comp R')\nX Y : CategoryTheory.Comma L R\nφ : Quiver.Hom X Y\n⊢ Eq ((CategoryTheory.Comma.map α β).map φ).left (F₁.map φ.left)","decl":"/-- The functor `Comma L R ⥤ Comma L' R'` induced by three functors `F₁`, `F₂`, `F`\nand two natural transformations `F₁ ⋙ L' ⟶ L ⋙ F` and `R ⋙ F ⟶ F₂ ⋙ R'`. -/\n@[simps]\ndef map : Comma L R ⥤ Comma L' R' where\n  obj X :=\n    { left := F₁.obj X.left\n      right := F₂.obj X.right\n      hom := α.app X.left ≫ F.map X.hom ≫ β.app X.right }\n  map {X Y} φ :=\n    { left := F₁.map φ.left\n      right := F₂.map φ.right\n      w := by\n        dsimp\n        rw [assoc, assoc]\n        erw [α.naturality_assoc, ← β.naturality]\n        dsimp\n        rw [← F.map_comp_assoc, ← F.map_comp_assoc, φ.w] }\n\n"}
{"name":"CategoryTheory.Comma.map_map_right","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝⁵ : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝³ : CategoryTheory.Category.{v₃, u₃} T\nA' : Type u₄\ninst✝² : CategoryTheory.Category.{v₄, u₄} A'\nB' : Type u₅\ninst✝¹ : CategoryTheory.Category.{v₅, u₅} B'\nT' : Type u₆\ninst✝ : CategoryTheory.Category.{v₆, u₆} T'\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nL' : CategoryTheory.Functor A' T'\nR' : CategoryTheory.Functor B' T'\nF₁ : CategoryTheory.Functor A A'\nF₂ : CategoryTheory.Functor B B'\nF : CategoryTheory.Functor T T'\nα : Quiver.Hom (F₁.comp L') (L.comp F)\nβ : Quiver.Hom (R.comp F) (F₂.comp R')\nX Y : CategoryTheory.Comma L R\nφ : Quiver.Hom X Y\n⊢ Eq ((CategoryTheory.Comma.map α β).map φ).right (F₂.map φ.right)","decl":"/-- The functor `Comma L R ⥤ Comma L' R'` induced by three functors `F₁`, `F₂`, `F`\nand two natural transformations `F₁ ⋙ L' ⟶ L ⋙ F` and `R ⋙ F ⟶ F₂ ⋙ R'`. -/\n@[simps]\ndef map : Comma L R ⥤ Comma L' R' where\n  obj X :=\n    { left := F₁.obj X.left\n      right := F₂.obj X.right\n      hom := α.app X.left ≫ F.map X.hom ≫ β.app X.right }\n  map {X Y} φ :=\n    { left := F₁.map φ.left\n      right := F₂.map φ.right\n      w := by\n        dsimp\n        rw [assoc, assoc]\n        erw [α.naturality_assoc, ← β.naturality]\n        dsimp\n        rw [← F.map_comp_assoc, ← F.map_comp_assoc, φ.w] }\n\n"}
{"name":"CategoryTheory.Comma.map_obj_left","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝⁵ : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝³ : CategoryTheory.Category.{v₃, u₃} T\nA' : Type u₄\ninst✝² : CategoryTheory.Category.{v₄, u₄} A'\nB' : Type u₅\ninst✝¹ : CategoryTheory.Category.{v₅, u₅} B'\nT' : Type u₆\ninst✝ : CategoryTheory.Category.{v₆, u₆} T'\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nL' : CategoryTheory.Functor A' T'\nR' : CategoryTheory.Functor B' T'\nF₁ : CategoryTheory.Functor A A'\nF₂ : CategoryTheory.Functor B B'\nF : CategoryTheory.Functor T T'\nα : Quiver.Hom (F₁.comp L') (L.comp F)\nβ : Quiver.Hom (R.comp F) (F₂.comp R')\nX : CategoryTheory.Comma L R\n⊢ Eq ((CategoryTheory.Comma.map α β).obj X).left (F₁.obj X.left)","decl":"/-- The functor `Comma L R ⥤ Comma L' R'` induced by three functors `F₁`, `F₂`, `F`\nand two natural transformations `F₁ ⋙ L' ⟶ L ⋙ F` and `R ⋙ F ⟶ F₂ ⋙ R'`. -/\n@[simps]\ndef map : Comma L R ⥤ Comma L' R' where\n  obj X :=\n    { left := F₁.obj X.left\n      right := F₂.obj X.right\n      hom := α.app X.left ≫ F.map X.hom ≫ β.app X.right }\n  map {X Y} φ :=\n    { left := F₁.map φ.left\n      right := F₂.map φ.right\n      w := by\n        dsimp\n        rw [assoc, assoc]\n        erw [α.naturality_assoc, ← β.naturality]\n        dsimp\n        rw [← F.map_comp_assoc, ← F.map_comp_assoc, φ.w] }\n\n"}
{"name":"CategoryTheory.Comma.map_obj_right","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝⁵ : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝³ : CategoryTheory.Category.{v₃, u₃} T\nA' : Type u₄\ninst✝² : CategoryTheory.Category.{v₄, u₄} A'\nB' : Type u₅\ninst✝¹ : CategoryTheory.Category.{v₅, u₅} B'\nT' : Type u₆\ninst✝ : CategoryTheory.Category.{v₆, u₆} T'\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nL' : CategoryTheory.Functor A' T'\nR' : CategoryTheory.Functor B' T'\nF₁ : CategoryTheory.Functor A A'\nF₂ : CategoryTheory.Functor B B'\nF : CategoryTheory.Functor T T'\nα : Quiver.Hom (F₁.comp L') (L.comp F)\nβ : Quiver.Hom (R.comp F) (F₂.comp R')\nX : CategoryTheory.Comma L R\n⊢ Eq ((CategoryTheory.Comma.map α β).obj X).right (F₂.obj X.right)","decl":"/-- The functor `Comma L R ⥤ Comma L' R'` induced by three functors `F₁`, `F₂`, `F`\nand two natural transformations `F₁ ⋙ L' ⟶ L ⋙ F` and `R ⋙ F ⟶ F₂ ⋙ R'`. -/\n@[simps]\ndef map : Comma L R ⥤ Comma L' R' where\n  obj X :=\n    { left := F₁.obj X.left\n      right := F₂.obj X.right\n      hom := α.app X.left ≫ F.map X.hom ≫ β.app X.right }\n  map {X Y} φ :=\n    { left := F₁.map φ.left\n      right := F₂.map φ.right\n      w := by\n        dsimp\n        rw [assoc, assoc]\n        erw [α.naturality_assoc, ← β.naturality]\n        dsimp\n        rw [← F.map_comp_assoc, ← F.map_comp_assoc, φ.w] }\n\n"}
{"name":"CategoryTheory.Comma.faithful_map","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝⁷ : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝⁶ : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝⁵ : CategoryTheory.Category.{v₃, u₃} T\nA' : Type u₄\ninst✝⁴ : CategoryTheory.Category.{v₄, u₄} A'\nB' : Type u₅\ninst✝³ : CategoryTheory.Category.{v₅, u₅} B'\nT' : Type u₆\ninst✝² : CategoryTheory.Category.{v₆, u₆} T'\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nL' : CategoryTheory.Functor A' T'\nR' : CategoryTheory.Functor B' T'\nF₁ : CategoryTheory.Functor A A'\nF₂ : CategoryTheory.Functor B B'\nF : CategoryTheory.Functor T T'\nα : Quiver.Hom (F₁.comp L') (L.comp F)\nβ : Quiver.Hom (R.comp F) (F₂.comp R')\ninst✝¹ : F₁.Faithful\ninst✝ : F₂.Faithful\n⊢ (CategoryTheory.Comma.map α β).Faithful","decl":"instance faithful_map [F₁.Faithful] [F₂.Faithful] : (map α β).Faithful where\n  map_injective {X Y} f g h := by\n    ext\n    · exact F₁.map_injective (congr_arg CommaMorphism.left h)\n    · exact F₂.map_injective (congr_arg CommaMorphism.right h)\n\n"}
{"name":"CategoryTheory.Comma.full_map","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝¹⁰ : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝⁹ : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝⁸ : CategoryTheory.Category.{v₃, u₃} T\nA' : Type u₄\ninst✝⁷ : CategoryTheory.Category.{v₄, u₄} A'\nB' : Type u₅\ninst✝⁶ : CategoryTheory.Category.{v₅, u₅} B'\nT' : Type u₆\ninst✝⁵ : CategoryTheory.Category.{v₆, u₆} T'\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nL' : CategoryTheory.Functor A' T'\nR' : CategoryTheory.Functor B' T'\nF₁ : CategoryTheory.Functor A A'\nF₂ : CategoryTheory.Functor B B'\nF : CategoryTheory.Functor T T'\nα : Quiver.Hom (F₁.comp L') (L.comp F)\nβ : Quiver.Hom (R.comp F) (F₂.comp R')\ninst✝⁴ : F.Faithful\ninst✝³ : F₁.Full\ninst✝² : F₂.Full\ninst✝¹ : CategoryTheory.IsIso α\ninst✝ : CategoryTheory.IsIso β\n⊢ (CategoryTheory.Comma.map α β).Full","decl":"instance full_map [F.Faithful] [F₁.Full] [F₂.Full] [IsIso α] [IsIso β] : (map α β).Full where\n  map_surjective {X Y} φ :=\n   ⟨{ left := F₁.preimage φ.left\n      right := F₂.preimage φ.right\n      w := F.map_injective (by\n        rw [← cancel_mono (β.app _), ← cancel_epi (α.app _), F.map_comp, F.map_comp,\n          assoc, assoc]\n        erw [← α.naturality_assoc, β.naturality]\n        dsimp\n        rw [F₁.map_preimage, F₂.map_preimage]\n        simpa using φ.w) }, by aesop_cat⟩\n\n"}
{"name":"CategoryTheory.Comma.essSurj_map","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝¹⁰ : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝⁹ : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝⁸ : CategoryTheory.Category.{v₃, u₃} T\nA' : Type u₄\ninst✝⁷ : CategoryTheory.Category.{v₄, u₄} A'\nB' : Type u₅\ninst✝⁶ : CategoryTheory.Category.{v₅, u₅} B'\nT' : Type u₆\ninst✝⁵ : CategoryTheory.Category.{v₆, u₆} T'\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nL' : CategoryTheory.Functor A' T'\nR' : CategoryTheory.Functor B' T'\nF₁ : CategoryTheory.Functor A A'\nF₂ : CategoryTheory.Functor B B'\nF : CategoryTheory.Functor T T'\nα : Quiver.Hom (F₁.comp L') (L.comp F)\nβ : Quiver.Hom (R.comp F) (F₂.comp R')\ninst✝⁴ : F₁.EssSurj\ninst✝³ : F₂.EssSurj\ninst✝² : F.Full\ninst✝¹ : CategoryTheory.IsIso α\ninst✝ : CategoryTheory.IsIso β\n⊢ (CategoryTheory.Comma.map α β).EssSurj","decl":"instance essSurj_map [F₁.EssSurj] [F₂.EssSurj] [F.Full] [IsIso α] [IsIso β] :\n    (map α β).EssSurj where\n  mem_essImage X :=\n    ⟨{  left := F₁.objPreimage X.left\n        right := F₂.objPreimage X.right\n        hom := F.preimage ((inv α).app _ ≫ L'.map (F₁.objObjPreimageIso X.left).hom ≫\n          X.hom ≫ R'.map (F₂.objObjPreimageIso X.right).inv ≫ (inv β).app _) },\n            ⟨isoMk (F₁.objObjPreimageIso X.left) (F₂.objObjPreimageIso X.right) (by\n              dsimp\n              simp only [NatIso.isIso_inv_app, Functor.comp_obj, Functor.map_preimage, assoc,\n                IsIso.inv_hom_id, comp_id, IsIso.hom_inv_id_assoc]\n              rw [← R'.map_comp, Iso.inv_hom_id, R'.map_id, comp_id])⟩⟩\n\n"}
{"name":"CategoryTheory.Comma.isEquivalenceMap","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝¹¹ : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝¹⁰ : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝⁹ : CategoryTheory.Category.{v₃, u₃} T\nA' : Type u₄\ninst✝⁸ : CategoryTheory.Category.{v₄, u₄} A'\nB' : Type u₅\ninst✝⁷ : CategoryTheory.Category.{v₅, u₅} B'\nT' : Type u₆\ninst✝⁶ : CategoryTheory.Category.{v₆, u₆} T'\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nL' : CategoryTheory.Functor A' T'\nR' : CategoryTheory.Functor B' T'\nF₁ : CategoryTheory.Functor A A'\nF₂ : CategoryTheory.Functor B B'\nF : CategoryTheory.Functor T T'\nα : Quiver.Hom (F₁.comp L') (L.comp F)\nβ : Quiver.Hom (R.comp F) (F₂.comp R')\ninst✝⁵ : F₁.IsEquivalence\ninst✝⁴ : F₂.IsEquivalence\ninst✝³ : F.Faithful\ninst✝² : F.Full\ninst✝¹ : CategoryTheory.IsIso α\ninst✝ : CategoryTheory.IsIso β\n⊢ (CategoryTheory.Comma.map α β).IsEquivalence","decl":"noncomputable instance isEquivalenceMap\n    [F₁.IsEquivalence] [F₂.IsEquivalence] [F.Faithful] [F.Full] [IsIso α] [IsIso β] :\n    (map α β).IsEquivalence where\n\n"}
{"name":"CategoryTheory.Comma.map_fst","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝⁵ : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝³ : CategoryTheory.Category.{v₃, u₃} T\nA' : Type u₄\ninst✝² : CategoryTheory.Category.{v₄, u₄} A'\nB' : Type u₅\ninst✝¹ : CategoryTheory.Category.{v₅, u₅} B'\nT' : Type u₆\ninst✝ : CategoryTheory.Category.{v₆, u₆} T'\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nL' : CategoryTheory.Functor A' T'\nR' : CategoryTheory.Functor B' T'\nF₁ : CategoryTheory.Functor A A'\nF₂ : CategoryTheory.Functor B B'\nF : CategoryTheory.Functor T T'\nα : Quiver.Hom (F₁.comp L') (L.comp F)\nβ : Quiver.Hom (R.comp F) (F₂.comp R')\n⊢ Eq ((CategoryTheory.Comma.map α β).comp (CategoryTheory.Comma.fst L' R')) ((CategoryTheory.Comma.fst L R).comp F₁)","decl":"/-- The equality between `map α β ⋙ fst L' R'` and `fst L R ⋙ F₁`,\nwhere `α : F₁ ⋙ L' ⟶ L ⋙ F`. -/\n@[simp]\ntheorem map_fst : map α β ⋙ fst L' R' = fst L R ⋙ F₁ :=\n  rfl\n\n"}
{"name":"CategoryTheory.Comma.mapFst_inv_app","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝⁵ : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝³ : CategoryTheory.Category.{v₃, u₃} T\nA' : Type u₄\ninst✝² : CategoryTheory.Category.{v₄, u₄} A'\nB' : Type u₅\ninst✝¹ : CategoryTheory.Category.{v₅, u₅} B'\nT' : Type u₆\ninst✝ : CategoryTheory.Category.{v₆, u₆} T'\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nL' : CategoryTheory.Functor A' T'\nR' : CategoryTheory.Functor B' T'\nF₁ : CategoryTheory.Functor A A'\nF₂ : CategoryTheory.Functor B B'\nF : CategoryTheory.Functor T T'\nα : Quiver.Hom (F₁.comp L') (L.comp F)\nβ : Quiver.Hom (R.comp F) (F₂.comp R')\nX : CategoryTheory.Comma L R\n⊢ Eq ((CategoryTheory.Comma.mapFst α β).inv.app X) (CategoryTheory.CategoryStruct.id (F₁.obj X.left))","decl":"/-- The isomorphism between `map α β ⋙ fst L' R'` and `fst L R ⋙ F₁`,\nwhere `α : F₁ ⋙ L' ⟶ L ⋙ F`. -/\n@[simps!]\ndef mapFst : map α β ⋙ fst L' R' ≅ fst L R ⋙ F₁ :=\n  NatIso.ofComponents (fun _ => Iso.refl _) (by simp)\n\n"}
{"name":"CategoryTheory.Comma.mapFst_hom_app","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝⁵ : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝³ : CategoryTheory.Category.{v₃, u₃} T\nA' : Type u₄\ninst✝² : CategoryTheory.Category.{v₄, u₄} A'\nB' : Type u₅\ninst✝¹ : CategoryTheory.Category.{v₅, u₅} B'\nT' : Type u₆\ninst✝ : CategoryTheory.Category.{v₆, u₆} T'\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nL' : CategoryTheory.Functor A' T'\nR' : CategoryTheory.Functor B' T'\nF₁ : CategoryTheory.Functor A A'\nF₂ : CategoryTheory.Functor B B'\nF : CategoryTheory.Functor T T'\nα : Quiver.Hom (F₁.comp L') (L.comp F)\nβ : Quiver.Hom (R.comp F) (F₂.comp R')\nX : CategoryTheory.Comma L R\n⊢ Eq ((CategoryTheory.Comma.mapFst α β).hom.app X) (CategoryTheory.CategoryStruct.id (F₁.obj X.left))","decl":"/-- The isomorphism between `map α β ⋙ fst L' R'` and `fst L R ⋙ F₁`,\nwhere `α : F₁ ⋙ L' ⟶ L ⋙ F`. -/\n@[simps!]\ndef mapFst : map α β ⋙ fst L' R' ≅ fst L R ⋙ F₁ :=\n  NatIso.ofComponents (fun _ => Iso.refl _) (by simp)\n\n"}
{"name":"CategoryTheory.Comma.map_snd","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝⁵ : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝³ : CategoryTheory.Category.{v₃, u₃} T\nA' : Type u₄\ninst✝² : CategoryTheory.Category.{v₄, u₄} A'\nB' : Type u₅\ninst✝¹ : CategoryTheory.Category.{v₅, u₅} B'\nT' : Type u₆\ninst✝ : CategoryTheory.Category.{v₆, u₆} T'\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nL' : CategoryTheory.Functor A' T'\nR' : CategoryTheory.Functor B' T'\nF₁ : CategoryTheory.Functor A A'\nF₂ : CategoryTheory.Functor B B'\nF : CategoryTheory.Functor T T'\nα : Quiver.Hom (F₁.comp L') (L.comp F)\nβ : Quiver.Hom (R.comp F) (F₂.comp R')\n⊢ Eq ((CategoryTheory.Comma.map α β).comp (CategoryTheory.Comma.snd L' R')) ((CategoryTheory.Comma.snd L R).comp F₂)","decl":"/-- The equality between `map α β ⋙ snd L' R'` and `snd L R ⋙ F₂`,\nwhere `β : R ⋙ F ⟶ F₂ ⋙ R'`. -/\n@[simp]\ntheorem map_snd : map α β ⋙ snd L' R' = snd L R ⋙ F₂ :=\n  rfl\n\n"}
{"name":"CategoryTheory.Comma.mapSnd_inv_app","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝⁵ : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝³ : CategoryTheory.Category.{v₃, u₃} T\nA' : Type u₄\ninst✝² : CategoryTheory.Category.{v₄, u₄} A'\nB' : Type u₅\ninst✝¹ : CategoryTheory.Category.{v₅, u₅} B'\nT' : Type u₆\ninst✝ : CategoryTheory.Category.{v₆, u₆} T'\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nL' : CategoryTheory.Functor A' T'\nR' : CategoryTheory.Functor B' T'\nF₁ : CategoryTheory.Functor A A'\nF₂ : CategoryTheory.Functor B B'\nF : CategoryTheory.Functor T T'\nα : Quiver.Hom (F₁.comp L') (L.comp F)\nβ : Quiver.Hom (R.comp F) (F₂.comp R')\nX : CategoryTheory.Comma L R\n⊢ Eq ((CategoryTheory.Comma.mapSnd α β).inv.app X) (CategoryTheory.CategoryStruct.id (F₂.obj X.right))","decl":"/-- The isomorphism between `map α β ⋙ snd L' R'` and `snd L R ⋙ F₂`,\nwhere `β : R ⋙ F ⟶ F₂ ⋙ R'`. -/\n@[simps!]\ndef mapSnd : map α β ⋙ snd L' R' ≅ snd L R ⋙ F₂ :=\n  NatIso.ofComponents (fun _ => Iso.refl _) (by simp)\n\n"}
{"name":"CategoryTheory.Comma.mapSnd_hom_app","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝⁵ : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝³ : CategoryTheory.Category.{v₃, u₃} T\nA' : Type u₄\ninst✝² : CategoryTheory.Category.{v₄, u₄} A'\nB' : Type u₅\ninst✝¹ : CategoryTheory.Category.{v₅, u₅} B'\nT' : Type u₆\ninst✝ : CategoryTheory.Category.{v₆, u₆} T'\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nL' : CategoryTheory.Functor A' T'\nR' : CategoryTheory.Functor B' T'\nF₁ : CategoryTheory.Functor A A'\nF₂ : CategoryTheory.Functor B B'\nF : CategoryTheory.Functor T T'\nα : Quiver.Hom (F₁.comp L') (L.comp F)\nβ : Quiver.Hom (R.comp F) (F₂.comp R')\nX : CategoryTheory.Comma L R\n⊢ Eq ((CategoryTheory.Comma.mapSnd α β).hom.app X) (CategoryTheory.CategoryStruct.id (F₂.obj X.right))","decl":"/-- The isomorphism between `map α β ⋙ snd L' R'` and `snd L R ⋙ F₂`,\nwhere `β : R ⋙ F ⟶ F₂ ⋙ R'`. -/\n@[simps!]\ndef mapSnd : map α β ⋙ snd L' R' ≅ snd L R ⋙ F₂ :=\n  NatIso.ofComponents (fun _ => Iso.refl _) (by simp)\n\n"}
{"name":"CategoryTheory.Comma.mapLeft_map_left","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} T\nR : CategoryTheory.Functor B T\nL₁ L₂ : CategoryTheory.Functor A T\nl : Quiver.Hom L₁ L₂\nX✝ Y✝ : CategoryTheory.Comma L₂ R\nf : Quiver.Hom X✝ Y✝\n⊢ Eq ((CategoryTheory.Comma.mapLeft R l).map f).left f.left","decl":"/-- A natural transformation `L₁ ⟶ L₂` induces a functor `Comma L₂ R ⥤ Comma L₁ R`. -/\n@[simps]\ndef mapLeft (l : L₁ ⟶ L₂) : Comma L₂ R ⥤ Comma L₁ R where\n  obj X :=\n    { left := X.left\n      right := X.right\n      hom := l.app X.left ≫ X.hom }\n  map f :=\n    { left := f.left\n      right := f.right }\n\n"}
{"name":"CategoryTheory.Comma.mapLeft_obj_hom","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} T\nR : CategoryTheory.Functor B T\nL₁ L₂ : CategoryTheory.Functor A T\nl : Quiver.Hom L₁ L₂\nX : CategoryTheory.Comma L₂ R\n⊢ Eq ((CategoryTheory.Comma.mapLeft R l).obj X).hom (CategoryTheory.CategoryStruct.comp (l.app X.left) X.hom)","decl":"/-- A natural transformation `L₁ ⟶ L₂` induces a functor `Comma L₂ R ⥤ Comma L₁ R`. -/\n@[simps]\ndef mapLeft (l : L₁ ⟶ L₂) : Comma L₂ R ⥤ Comma L₁ R where\n  obj X :=\n    { left := X.left\n      right := X.right\n      hom := l.app X.left ≫ X.hom }\n  map f :=\n    { left := f.left\n      right := f.right }\n\n"}
{"name":"CategoryTheory.Comma.mapLeft_map_right","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} T\nR : CategoryTheory.Functor B T\nL₁ L₂ : CategoryTheory.Functor A T\nl : Quiver.Hom L₁ L₂\nX✝ Y✝ : CategoryTheory.Comma L₂ R\nf : Quiver.Hom X✝ Y✝\n⊢ Eq ((CategoryTheory.Comma.mapLeft R l).map f).right f.right","decl":"/-- A natural transformation `L₁ ⟶ L₂` induces a functor `Comma L₂ R ⥤ Comma L₁ R`. -/\n@[simps]\ndef mapLeft (l : L₁ ⟶ L₂) : Comma L₂ R ⥤ Comma L₁ R where\n  obj X :=\n    { left := X.left\n      right := X.right\n      hom := l.app X.left ≫ X.hom }\n  map f :=\n    { left := f.left\n      right := f.right }\n\n"}
{"name":"CategoryTheory.Comma.mapLeft_obj_right","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} T\nR : CategoryTheory.Functor B T\nL₁ L₂ : CategoryTheory.Functor A T\nl : Quiver.Hom L₁ L₂\nX : CategoryTheory.Comma L₂ R\n⊢ Eq ((CategoryTheory.Comma.mapLeft R l).obj X).right X.right","decl":"/-- A natural transformation `L₁ ⟶ L₂` induces a functor `Comma L₂ R ⥤ Comma L₁ R`. -/\n@[simps]\ndef mapLeft (l : L₁ ⟶ L₂) : Comma L₂ R ⥤ Comma L₁ R where\n  obj X :=\n    { left := X.left\n      right := X.right\n      hom := l.app X.left ≫ X.hom }\n  map f :=\n    { left := f.left\n      right := f.right }\n\n"}
{"name":"CategoryTheory.Comma.mapLeft_obj_left","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} T\nR : CategoryTheory.Functor B T\nL₁ L₂ : CategoryTheory.Functor A T\nl : Quiver.Hom L₁ L₂\nX : CategoryTheory.Comma L₂ R\n⊢ Eq ((CategoryTheory.Comma.mapLeft R l).obj X).left X.left","decl":"/-- A natural transformation `L₁ ⟶ L₂` induces a functor `Comma L₂ R ⥤ Comma L₁ R`. -/\n@[simps]\ndef mapLeft (l : L₁ ⟶ L₂) : Comma L₂ R ⥤ Comma L₁ R where\n  obj X :=\n    { left := X.left\n      right := X.right\n      hom := l.app X.left ≫ X.hom }\n  map f :=\n    { left := f.left\n      right := f.right }\n\n"}
{"name":"CategoryTheory.Comma.mapLeftId_inv_app_right","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nX : CategoryTheory.Comma L R\n⊢ Eq ((CategoryTheory.Comma.mapLeftId L R).inv.app X).right (CategoryTheory.CategoryStruct.id X.right)","decl":"/-- The functor `Comma L R ⥤ Comma L R` induced by the identity natural transformation on `L` is\n    naturally isomorphic to the identity functor. -/\n@[simps!]\ndef mapLeftId : mapLeft R (𝟙 L) ≅ 𝟭 _ :=\n  NatIso.ofComponents (fun X => isoMk (Iso.refl _) (Iso.refl _))\n\n"}
{"name":"CategoryTheory.Comma.mapLeftId_inv_app_left","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nX : CategoryTheory.Comma L R\n⊢ Eq ((CategoryTheory.Comma.mapLeftId L R).inv.app X).left (CategoryTheory.CategoryStruct.id X.left)","decl":"/-- The functor `Comma L R ⥤ Comma L R` induced by the identity natural transformation on `L` is\n    naturally isomorphic to the identity functor. -/\n@[simps!]\ndef mapLeftId : mapLeft R (𝟙 L) ≅ 𝟭 _ :=\n  NatIso.ofComponents (fun X => isoMk (Iso.refl _) (Iso.refl _))\n\n"}
{"name":"CategoryTheory.Comma.mapLeftId_hom_app_left","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nX : CategoryTheory.Comma L R\n⊢ Eq ((CategoryTheory.Comma.mapLeftId L R).hom.app X).left (CategoryTheory.CategoryStruct.id X.left)","decl":"/-- The functor `Comma L R ⥤ Comma L R` induced by the identity natural transformation on `L` is\n    naturally isomorphic to the identity functor. -/\n@[simps!]\ndef mapLeftId : mapLeft R (𝟙 L) ≅ 𝟭 _ :=\n  NatIso.ofComponents (fun X => isoMk (Iso.refl _) (Iso.refl _))\n\n"}
{"name":"CategoryTheory.Comma.mapLeftId_hom_app_right","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nX : CategoryTheory.Comma L R\n⊢ Eq ((CategoryTheory.Comma.mapLeftId L R).hom.app X).right (CategoryTheory.CategoryStruct.id X.right)","decl":"/-- The functor `Comma L R ⥤ Comma L R` induced by the identity natural transformation on `L` is\n    naturally isomorphic to the identity functor. -/\n@[simps!]\ndef mapLeftId : mapLeft R (𝟙 L) ≅ 𝟭 _ :=\n  NatIso.ofComponents (fun X => isoMk (Iso.refl _) (Iso.refl _))\n\n"}
{"name":"CategoryTheory.Comma.mapLeftComp_inv_app_left","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} T\nR : CategoryTheory.Functor B T\nL₁ L₂ L₃ : CategoryTheory.Functor A T\nl : Quiver.Hom L₁ L₂\nl' : Quiver.Hom L₂ L₃\nX : CategoryTheory.Comma L₃ R\n⊢ Eq ((CategoryTheory.Comma.mapLeftComp R l l').inv.app X).left (CategoryTheory.CategoryStruct.id X.left)","decl":"/-- The functor `Comma L₁ R ⥤ Comma L₃ R` induced by the composition of two natural transformations\n    `l : L₁ ⟶ L₂` and `l' : L₂ ⟶ L₃` is naturally isomorphic to the composition of the two functors\n    induced by these natural transformations. -/\n@[simps!]\ndef mapLeftComp (l : L₁ ⟶ L₂) (l' : L₂ ⟶ L₃) :\n    mapLeft R (l ≫ l') ≅ mapLeft R l' ⋙ mapLeft R l :=\n  NatIso.ofComponents (fun X => isoMk (Iso.refl _) (Iso.refl _))\n\n"}
{"name":"CategoryTheory.Comma.mapLeftComp_hom_app_right","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} T\nR : CategoryTheory.Functor B T\nL₁ L₂ L₃ : CategoryTheory.Functor A T\nl : Quiver.Hom L₁ L₂\nl' : Quiver.Hom L₂ L₃\nX : CategoryTheory.Comma L₃ R\n⊢ Eq ((CategoryTheory.Comma.mapLeftComp R l l').hom.app X).right (CategoryTheory.CategoryStruct.id X.right)","decl":"/-- The functor `Comma L₁ R ⥤ Comma L₃ R` induced by the composition of two natural transformations\n    `l : L₁ ⟶ L₂` and `l' : L₂ ⟶ L₃` is naturally isomorphic to the composition of the two functors\n    induced by these natural transformations. -/\n@[simps!]\ndef mapLeftComp (l : L₁ ⟶ L₂) (l' : L₂ ⟶ L₃) :\n    mapLeft R (l ≫ l') ≅ mapLeft R l' ⋙ mapLeft R l :=\n  NatIso.ofComponents (fun X => isoMk (Iso.refl _) (Iso.refl _))\n\n"}
{"name":"CategoryTheory.Comma.mapLeftComp_inv_app_right","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} T\nR : CategoryTheory.Functor B T\nL₁ L₂ L₃ : CategoryTheory.Functor A T\nl : Quiver.Hom L₁ L₂\nl' : Quiver.Hom L₂ L₃\nX : CategoryTheory.Comma L₃ R\n⊢ Eq ((CategoryTheory.Comma.mapLeftComp R l l').inv.app X).right (CategoryTheory.CategoryStruct.id X.right)","decl":"/-- The functor `Comma L₁ R ⥤ Comma L₃ R` induced by the composition of two natural transformations\n    `l : L₁ ⟶ L₂` and `l' : L₂ ⟶ L₃` is naturally isomorphic to the composition of the two functors\n    induced by these natural transformations. -/\n@[simps!]\ndef mapLeftComp (l : L₁ ⟶ L₂) (l' : L₂ ⟶ L₃) :\n    mapLeft R (l ≫ l') ≅ mapLeft R l' ⋙ mapLeft R l :=\n  NatIso.ofComponents (fun X => isoMk (Iso.refl _) (Iso.refl _))\n\n"}
{"name":"CategoryTheory.Comma.mapLeftComp_hom_app_left","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} T\nR : CategoryTheory.Functor B T\nL₁ L₂ L₃ : CategoryTheory.Functor A T\nl : Quiver.Hom L₁ L₂\nl' : Quiver.Hom L₂ L₃\nX : CategoryTheory.Comma L₃ R\n⊢ Eq ((CategoryTheory.Comma.mapLeftComp R l l').hom.app X).left (CategoryTheory.CategoryStruct.id X.left)","decl":"/-- The functor `Comma L₁ R ⥤ Comma L₃ R` induced by the composition of two natural transformations\n    `l : L₁ ⟶ L₂` and `l' : L₂ ⟶ L₃` is naturally isomorphic to the composition of the two functors\n    induced by these natural transformations. -/\n@[simps!]\ndef mapLeftComp (l : L₁ ⟶ L₂) (l' : L₂ ⟶ L₃) :\n    mapLeft R (l ≫ l') ≅ mapLeft R l' ⋙ mapLeft R l :=\n  NatIso.ofComponents (fun X => isoMk (Iso.refl _) (Iso.refl _))\n\n"}
{"name":"CategoryTheory.Comma.mapLeftEq_hom_app_right","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} T\nR : CategoryTheory.Functor B T\nL₁ L₂ : CategoryTheory.Functor A T\nl l' : Quiver.Hom L₁ L₂\nh : Eq l l'\nX : CategoryTheory.Comma L₂ R\n⊢ Eq ((CategoryTheory.Comma.mapLeftEq R l l' h).hom.app X).right (CategoryTheory.CategoryStruct.id X.right)","decl":"/-- Two equal natural transformations `L₁ ⟶ L₂` yield naturally isomorphic functors\n    `Comma L₁ R ⥤ Comma L₂ R`. -/\n@[simps!]\ndef mapLeftEq (l l' : L₁ ⟶ L₂) (h : l = l') : mapLeft R l ≅ mapLeft R l' :=\n  NatIso.ofComponents (fun X => isoMk (Iso.refl _) (Iso.refl _))\n\n"}
{"name":"CategoryTheory.Comma.mapLeftEq_hom_app_left","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} T\nR : CategoryTheory.Functor B T\nL₁ L₂ : CategoryTheory.Functor A T\nl l' : Quiver.Hom L₁ L₂\nh : Eq l l'\nX : CategoryTheory.Comma L₂ R\n⊢ Eq ((CategoryTheory.Comma.mapLeftEq R l l' h).hom.app X).left (CategoryTheory.CategoryStruct.id X.left)","decl":"/-- Two equal natural transformations `L₁ ⟶ L₂` yield naturally isomorphic functors\n    `Comma L₁ R ⥤ Comma L₂ R`. -/\n@[simps!]\ndef mapLeftEq (l l' : L₁ ⟶ L₂) (h : l = l') : mapLeft R l ≅ mapLeft R l' :=\n  NatIso.ofComponents (fun X => isoMk (Iso.refl _) (Iso.refl _))\n\n"}
{"name":"CategoryTheory.Comma.mapLeftEq_inv_app_left","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} T\nR : CategoryTheory.Functor B T\nL₁ L₂ : CategoryTheory.Functor A T\nl l' : Quiver.Hom L₁ L₂\nh : Eq l l'\nX : CategoryTheory.Comma L₂ R\n⊢ Eq ((CategoryTheory.Comma.mapLeftEq R l l' h).inv.app X).left (CategoryTheory.CategoryStruct.id X.left)","decl":"/-- Two equal natural transformations `L₁ ⟶ L₂` yield naturally isomorphic functors\n    `Comma L₁ R ⥤ Comma L₂ R`. -/\n@[simps!]\ndef mapLeftEq (l l' : L₁ ⟶ L₂) (h : l = l') : mapLeft R l ≅ mapLeft R l' :=\n  NatIso.ofComponents (fun X => isoMk (Iso.refl _) (Iso.refl _))\n\n"}
{"name":"CategoryTheory.Comma.mapLeftEq_inv_app_right","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} T\nR : CategoryTheory.Functor B T\nL₁ L₂ : CategoryTheory.Functor A T\nl l' : Quiver.Hom L₁ L₂\nh : Eq l l'\nX : CategoryTheory.Comma L₂ R\n⊢ Eq ((CategoryTheory.Comma.mapLeftEq R l l' h).inv.app X).right (CategoryTheory.CategoryStruct.id X.right)","decl":"/-- Two equal natural transformations `L₁ ⟶ L₂` yield naturally isomorphic functors\n    `Comma L₁ R ⥤ Comma L₂ R`. -/\n@[simps!]\ndef mapLeftEq (l l' : L₁ ⟶ L₂) (h : l = l') : mapLeft R l ≅ mapLeft R l' :=\n  NatIso.ofComponents (fun X => isoMk (Iso.refl _) (Iso.refl _))\n\n"}
{"name":"CategoryTheory.Comma.mapLeftIso_counitIso_hom_app_left","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} T\nR : CategoryTheory.Functor B T\nL₁ L₂ : CategoryTheory.Functor A T\ni : CategoryTheory.Iso L₁ L₂\nX : CategoryTheory.Comma L₂ R\n⊢ Eq ((CategoryTheory.Comma.mapLeftIso R i).counitIso.hom.app X).left (CategoryTheory.CategoryStruct.id X.left)","decl":"/-- A natural isomorphism `L₁ ≅ L₂` induces an equivalence of categories\n    `Comma L₁ R ≌ Comma L₂ R`. -/\n@[simps!]\ndef mapLeftIso (i : L₁ ≅ L₂) : Comma L₁ R ≌ Comma L₂ R where\n  functor := mapLeft _ i.inv\n  inverse := mapLeft _ i.hom\n  unitIso := (mapLeftId _ _).symm ≪≫ mapLeftEq _ _ _ i.hom_inv_id.symm ≪≫ mapLeftComp _ _ _\n  counitIso := (mapLeftComp _ _ _).symm ≪≫ mapLeftEq _ _ _ i.inv_hom_id ≪≫ mapLeftId _ _\n\n"}
{"name":"CategoryTheory.Comma.mapLeftIso_functor_map_left","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} T\nR : CategoryTheory.Functor B T\nL₁ L₂ : CategoryTheory.Functor A T\ni : CategoryTheory.Iso L₁ L₂\nX✝ Y✝ : CategoryTheory.Comma L₁ R\nf : Quiver.Hom X✝ Y✝\n⊢ Eq ((CategoryTheory.Comma.mapLeftIso R i).functor.map f).left f.left","decl":"/-- A natural isomorphism `L₁ ≅ L₂` induces an equivalence of categories\n    `Comma L₁ R ≌ Comma L₂ R`. -/\n@[simps!]\ndef mapLeftIso (i : L₁ ≅ L₂) : Comma L₁ R ≌ Comma L₂ R where\n  functor := mapLeft _ i.inv\n  inverse := mapLeft _ i.hom\n  unitIso := (mapLeftId _ _).symm ≪≫ mapLeftEq _ _ _ i.hom_inv_id.symm ≪≫ mapLeftComp _ _ _\n  counitIso := (mapLeftComp _ _ _).symm ≪≫ mapLeftEq _ _ _ i.inv_hom_id ≪≫ mapLeftId _ _\n\n"}
{"name":"CategoryTheory.Comma.mapLeftIso_inverse_obj_hom","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} T\nR : CategoryTheory.Functor B T\nL₁ L₂ : CategoryTheory.Functor A T\ni : CategoryTheory.Iso L₁ L₂\nX : CategoryTheory.Comma L₂ R\n⊢ Eq ((CategoryTheory.Comma.mapLeftIso R i).inverse.obj X).hom (CategoryTheory.CategoryStruct.comp (i.hom.app X.left) X.hom)","decl":"/-- A natural isomorphism `L₁ ≅ L₂` induces an equivalence of categories\n    `Comma L₁ R ≌ Comma L₂ R`. -/\n@[simps!]\ndef mapLeftIso (i : L₁ ≅ L₂) : Comma L₁ R ≌ Comma L₂ R where\n  functor := mapLeft _ i.inv\n  inverse := mapLeft _ i.hom\n  unitIso := (mapLeftId _ _).symm ≪≫ mapLeftEq _ _ _ i.hom_inv_id.symm ≪≫ mapLeftComp _ _ _\n  counitIso := (mapLeftComp _ _ _).symm ≪≫ mapLeftEq _ _ _ i.inv_hom_id ≪≫ mapLeftId _ _\n\n"}
{"name":"CategoryTheory.Comma.mapLeftIso_functor_obj_hom","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} T\nR : CategoryTheory.Functor B T\nL₁ L₂ : CategoryTheory.Functor A T\ni : CategoryTheory.Iso L₁ L₂\nX : CategoryTheory.Comma L₁ R\n⊢ Eq ((CategoryTheory.Comma.mapLeftIso R i).functor.obj X).hom (CategoryTheory.CategoryStruct.comp (i.inv.app X.left) X.hom)","decl":"/-- A natural isomorphism `L₁ ≅ L₂` induces an equivalence of categories\n    `Comma L₁ R ≌ Comma L₂ R`. -/\n@[simps!]\ndef mapLeftIso (i : L₁ ≅ L₂) : Comma L₁ R ≌ Comma L₂ R where\n  functor := mapLeft _ i.inv\n  inverse := mapLeft _ i.hom\n  unitIso := (mapLeftId _ _).symm ≪≫ mapLeftEq _ _ _ i.hom_inv_id.symm ≪≫ mapLeftComp _ _ _\n  counitIso := (mapLeftComp _ _ _).symm ≪≫ mapLeftEq _ _ _ i.inv_hom_id ≪≫ mapLeftId _ _\n\n"}
{"name":"CategoryTheory.Comma.mapLeftIso_counitIso_hom_app_right","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} T\nR : CategoryTheory.Functor B T\nL₁ L₂ : CategoryTheory.Functor A T\ni : CategoryTheory.Iso L₁ L₂\nX : CategoryTheory.Comma L₂ R\n⊢ Eq ((CategoryTheory.Comma.mapLeftIso R i).counitIso.hom.app X).right (CategoryTheory.CategoryStruct.id X.right)","decl":"/-- A natural isomorphism `L₁ ≅ L₂` induces an equivalence of categories\n    `Comma L₁ R ≌ Comma L₂ R`. -/\n@[simps!]\ndef mapLeftIso (i : L₁ ≅ L₂) : Comma L₁ R ≌ Comma L₂ R where\n  functor := mapLeft _ i.inv\n  inverse := mapLeft _ i.hom\n  unitIso := (mapLeftId _ _).symm ≪≫ mapLeftEq _ _ _ i.hom_inv_id.symm ≪≫ mapLeftComp _ _ _\n  counitIso := (mapLeftComp _ _ _).symm ≪≫ mapLeftEq _ _ _ i.inv_hom_id ≪≫ mapLeftId _ _\n\n"}
{"name":"CategoryTheory.Comma.mapLeftIso_functor_obj_left","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} T\nR : CategoryTheory.Functor B T\nL₁ L₂ : CategoryTheory.Functor A T\ni : CategoryTheory.Iso L₁ L₂\nX : CategoryTheory.Comma L₁ R\n⊢ Eq ((CategoryTheory.Comma.mapLeftIso R i).functor.obj X).left X.left","decl":"/-- A natural isomorphism `L₁ ≅ L₂` induces an equivalence of categories\n    `Comma L₁ R ≌ Comma L₂ R`. -/\n@[simps!]\ndef mapLeftIso (i : L₁ ≅ L₂) : Comma L₁ R ≌ Comma L₂ R where\n  functor := mapLeft _ i.inv\n  inverse := mapLeft _ i.hom\n  unitIso := (mapLeftId _ _).symm ≪≫ mapLeftEq _ _ _ i.hom_inv_id.symm ≪≫ mapLeftComp _ _ _\n  counitIso := (mapLeftComp _ _ _).symm ≪≫ mapLeftEq _ _ _ i.inv_hom_id ≪≫ mapLeftId _ _\n\n"}
{"name":"CategoryTheory.Comma.mapLeftIso_inverse_map_left","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} T\nR : CategoryTheory.Functor B T\nL₁ L₂ : CategoryTheory.Functor A T\ni : CategoryTheory.Iso L₁ L₂\nX✝ Y✝ : CategoryTheory.Comma L₂ R\nf : Quiver.Hom X✝ Y✝\n⊢ Eq ((CategoryTheory.Comma.mapLeftIso R i).inverse.map f).left f.left","decl":"/-- A natural isomorphism `L₁ ≅ L₂` induces an equivalence of categories\n    `Comma L₁ R ≌ Comma L₂ R`. -/\n@[simps!]\ndef mapLeftIso (i : L₁ ≅ L₂) : Comma L₁ R ≌ Comma L₂ R where\n  functor := mapLeft _ i.inv\n  inverse := mapLeft _ i.hom\n  unitIso := (mapLeftId _ _).symm ≪≫ mapLeftEq _ _ _ i.hom_inv_id.symm ≪≫ mapLeftComp _ _ _\n  counitIso := (mapLeftComp _ _ _).symm ≪≫ mapLeftEq _ _ _ i.inv_hom_id ≪≫ mapLeftId _ _\n\n"}
{"name":"CategoryTheory.Comma.mapLeftIso_unitIso_hom_app_right","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} T\nR : CategoryTheory.Functor B T\nL₁ L₂ : CategoryTheory.Functor A T\ni : CategoryTheory.Iso L₁ L₂\nX : CategoryTheory.Comma L₁ R\n⊢ Eq ((CategoryTheory.Comma.mapLeftIso R i).unitIso.hom.app X).right (CategoryTheory.CategoryStruct.id X.right)","decl":"/-- A natural isomorphism `L₁ ≅ L₂` induces an equivalence of categories\n    `Comma L₁ R ≌ Comma L₂ R`. -/\n@[simps!]\ndef mapLeftIso (i : L₁ ≅ L₂) : Comma L₁ R ≌ Comma L₂ R where\n  functor := mapLeft _ i.inv\n  inverse := mapLeft _ i.hom\n  unitIso := (mapLeftId _ _).symm ≪≫ mapLeftEq _ _ _ i.hom_inv_id.symm ≪≫ mapLeftComp _ _ _\n  counitIso := (mapLeftComp _ _ _).symm ≪≫ mapLeftEq _ _ _ i.inv_hom_id ≪≫ mapLeftId _ _\n\n"}
{"name":"CategoryTheory.Comma.mapLeftIso_functor_map_right","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} T\nR : CategoryTheory.Functor B T\nL₁ L₂ : CategoryTheory.Functor A T\ni : CategoryTheory.Iso L₁ L₂\nX✝ Y✝ : CategoryTheory.Comma L₁ R\nf : Quiver.Hom X✝ Y✝\n⊢ Eq ((CategoryTheory.Comma.mapLeftIso R i).functor.map f).right f.right","decl":"/-- A natural isomorphism `L₁ ≅ L₂` induces an equivalence of categories\n    `Comma L₁ R ≌ Comma L₂ R`. -/\n@[simps!]\ndef mapLeftIso (i : L₁ ≅ L₂) : Comma L₁ R ≌ Comma L₂ R where\n  functor := mapLeft _ i.inv\n  inverse := mapLeft _ i.hom\n  unitIso := (mapLeftId _ _).symm ≪≫ mapLeftEq _ _ _ i.hom_inv_id.symm ≪≫ mapLeftComp _ _ _\n  counitIso := (mapLeftComp _ _ _).symm ≪≫ mapLeftEq _ _ _ i.inv_hom_id ≪≫ mapLeftId _ _\n\n"}
{"name":"CategoryTheory.Comma.mapLeftIso_unitIso_hom_app_left","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} T\nR : CategoryTheory.Functor B T\nL₁ L₂ : CategoryTheory.Functor A T\ni : CategoryTheory.Iso L₁ L₂\nX : CategoryTheory.Comma L₁ R\n⊢ Eq ((CategoryTheory.Comma.mapLeftIso R i).unitIso.hom.app X).left (CategoryTheory.CategoryStruct.id X.left)","decl":"/-- A natural isomorphism `L₁ ≅ L₂` induces an equivalence of categories\n    `Comma L₁ R ≌ Comma L₂ R`. -/\n@[simps!]\ndef mapLeftIso (i : L₁ ≅ L₂) : Comma L₁ R ≌ Comma L₂ R where\n  functor := mapLeft _ i.inv\n  inverse := mapLeft _ i.hom\n  unitIso := (mapLeftId _ _).symm ≪≫ mapLeftEq _ _ _ i.hom_inv_id.symm ≪≫ mapLeftComp _ _ _\n  counitIso := (mapLeftComp _ _ _).symm ≪≫ mapLeftEq _ _ _ i.inv_hom_id ≪≫ mapLeftId _ _\n\n"}
{"name":"CategoryTheory.Comma.mapLeftIso_unitIso_inv_app_left","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} T\nR : CategoryTheory.Functor B T\nL₁ L₂ : CategoryTheory.Functor A T\ni : CategoryTheory.Iso L₁ L₂\nX : CategoryTheory.Comma L₁ R\n⊢ Eq ((CategoryTheory.Comma.mapLeftIso R i).unitIso.inv.app X).left (CategoryTheory.CategoryStruct.id X.left)","decl":"/-- A natural isomorphism `L₁ ≅ L₂` induces an equivalence of categories\n    `Comma L₁ R ≌ Comma L₂ R`. -/\n@[simps!]\ndef mapLeftIso (i : L₁ ≅ L₂) : Comma L₁ R ≌ Comma L₂ R where\n  functor := mapLeft _ i.inv\n  inverse := mapLeft _ i.hom\n  unitIso := (mapLeftId _ _).symm ≪≫ mapLeftEq _ _ _ i.hom_inv_id.symm ≪≫ mapLeftComp _ _ _\n  counitIso := (mapLeftComp _ _ _).symm ≪≫ mapLeftEq _ _ _ i.inv_hom_id ≪≫ mapLeftId _ _\n\n"}
{"name":"CategoryTheory.Comma.mapLeftIso_inverse_obj_left","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} T\nR : CategoryTheory.Functor B T\nL₁ L₂ : CategoryTheory.Functor A T\ni : CategoryTheory.Iso L₁ L₂\nX : CategoryTheory.Comma L₂ R\n⊢ Eq ((CategoryTheory.Comma.mapLeftIso R i).inverse.obj X).left X.left","decl":"/-- A natural isomorphism `L₁ ≅ L₂` induces an equivalence of categories\n    `Comma L₁ R ≌ Comma L₂ R`. -/\n@[simps!]\ndef mapLeftIso (i : L₁ ≅ L₂) : Comma L₁ R ≌ Comma L₂ R where\n  functor := mapLeft _ i.inv\n  inverse := mapLeft _ i.hom\n  unitIso := (mapLeftId _ _).symm ≪≫ mapLeftEq _ _ _ i.hom_inv_id.symm ≪≫ mapLeftComp _ _ _\n  counitIso := (mapLeftComp _ _ _).symm ≪≫ mapLeftEq _ _ _ i.inv_hom_id ≪≫ mapLeftId _ _\n\n"}
{"name":"CategoryTheory.Comma.mapLeftIso_unitIso_inv_app_right","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} T\nR : CategoryTheory.Functor B T\nL₁ L₂ : CategoryTheory.Functor A T\ni : CategoryTheory.Iso L₁ L₂\nX : CategoryTheory.Comma L₁ R\n⊢ Eq ((CategoryTheory.Comma.mapLeftIso R i).unitIso.inv.app X).right (CategoryTheory.CategoryStruct.id X.right)","decl":"/-- A natural isomorphism `L₁ ≅ L₂` induces an equivalence of categories\n    `Comma L₁ R ≌ Comma L₂ R`. -/\n@[simps!]\ndef mapLeftIso (i : L₁ ≅ L₂) : Comma L₁ R ≌ Comma L₂ R where\n  functor := mapLeft _ i.inv\n  inverse := mapLeft _ i.hom\n  unitIso := (mapLeftId _ _).symm ≪≫ mapLeftEq _ _ _ i.hom_inv_id.symm ≪≫ mapLeftComp _ _ _\n  counitIso := (mapLeftComp _ _ _).symm ≪≫ mapLeftEq _ _ _ i.inv_hom_id ≪≫ mapLeftId _ _\n\n"}
{"name":"CategoryTheory.Comma.mapLeftIso_counitIso_inv_app_left","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} T\nR : CategoryTheory.Functor B T\nL₁ L₂ : CategoryTheory.Functor A T\ni : CategoryTheory.Iso L₁ L₂\nX : CategoryTheory.Comma L₂ R\n⊢ Eq ((CategoryTheory.Comma.mapLeftIso R i).counitIso.inv.app X).left (CategoryTheory.CategoryStruct.id X.left)","decl":"/-- A natural isomorphism `L₁ ≅ L₂` induces an equivalence of categories\n    `Comma L₁ R ≌ Comma L₂ R`. -/\n@[simps!]\ndef mapLeftIso (i : L₁ ≅ L₂) : Comma L₁ R ≌ Comma L₂ R where\n  functor := mapLeft _ i.inv\n  inverse := mapLeft _ i.hom\n  unitIso := (mapLeftId _ _).symm ≪≫ mapLeftEq _ _ _ i.hom_inv_id.symm ≪≫ mapLeftComp _ _ _\n  counitIso := (mapLeftComp _ _ _).symm ≪≫ mapLeftEq _ _ _ i.inv_hom_id ≪≫ mapLeftId _ _\n\n"}
{"name":"CategoryTheory.Comma.mapLeftIso_functor_obj_right","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} T\nR : CategoryTheory.Functor B T\nL₁ L₂ : CategoryTheory.Functor A T\ni : CategoryTheory.Iso L₁ L₂\nX : CategoryTheory.Comma L₁ R\n⊢ Eq ((CategoryTheory.Comma.mapLeftIso R i).functor.obj X).right X.right","decl":"/-- A natural isomorphism `L₁ ≅ L₂` induces an equivalence of categories\n    `Comma L₁ R ≌ Comma L₂ R`. -/\n@[simps!]\ndef mapLeftIso (i : L₁ ≅ L₂) : Comma L₁ R ≌ Comma L₂ R where\n  functor := mapLeft _ i.inv\n  inverse := mapLeft _ i.hom\n  unitIso := (mapLeftId _ _).symm ≪≫ mapLeftEq _ _ _ i.hom_inv_id.symm ≪≫ mapLeftComp _ _ _\n  counitIso := (mapLeftComp _ _ _).symm ≪≫ mapLeftEq _ _ _ i.inv_hom_id ≪≫ mapLeftId _ _\n\n"}
{"name":"CategoryTheory.Comma.mapLeftIso_inverse_obj_right","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} T\nR : CategoryTheory.Functor B T\nL₁ L₂ : CategoryTheory.Functor A T\ni : CategoryTheory.Iso L₁ L₂\nX : CategoryTheory.Comma L₂ R\n⊢ Eq ((CategoryTheory.Comma.mapLeftIso R i).inverse.obj X).right X.right","decl":"/-- A natural isomorphism `L₁ ≅ L₂` induces an equivalence of categories\n    `Comma L₁ R ≌ Comma L₂ R`. -/\n@[simps!]\ndef mapLeftIso (i : L₁ ≅ L₂) : Comma L₁ R ≌ Comma L₂ R where\n  functor := mapLeft _ i.inv\n  inverse := mapLeft _ i.hom\n  unitIso := (mapLeftId _ _).symm ≪≫ mapLeftEq _ _ _ i.hom_inv_id.symm ≪≫ mapLeftComp _ _ _\n  counitIso := (mapLeftComp _ _ _).symm ≪≫ mapLeftEq _ _ _ i.inv_hom_id ≪≫ mapLeftId _ _\n\n"}
{"name":"CategoryTheory.Comma.mapLeftIso_counitIso_inv_app_right","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} T\nR : CategoryTheory.Functor B T\nL₁ L₂ : CategoryTheory.Functor A T\ni : CategoryTheory.Iso L₁ L₂\nX : CategoryTheory.Comma L₂ R\n⊢ Eq ((CategoryTheory.Comma.mapLeftIso R i).counitIso.inv.app X).right (CategoryTheory.CategoryStruct.id X.right)","decl":"/-- A natural isomorphism `L₁ ≅ L₂` induces an equivalence of categories\n    `Comma L₁ R ≌ Comma L₂ R`. -/\n@[simps!]\ndef mapLeftIso (i : L₁ ≅ L₂) : Comma L₁ R ≌ Comma L₂ R where\n  functor := mapLeft _ i.inv\n  inverse := mapLeft _ i.hom\n  unitIso := (mapLeftId _ _).symm ≪≫ mapLeftEq _ _ _ i.hom_inv_id.symm ≪≫ mapLeftComp _ _ _\n  counitIso := (mapLeftComp _ _ _).symm ≪≫ mapLeftEq _ _ _ i.inv_hom_id ≪≫ mapLeftId _ _\n\n"}
{"name":"CategoryTheory.Comma.mapLeftIso_inverse_map_right","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} T\nR : CategoryTheory.Functor B T\nL₁ L₂ : CategoryTheory.Functor A T\ni : CategoryTheory.Iso L₁ L₂\nX✝ Y✝ : CategoryTheory.Comma L₂ R\nf : Quiver.Hom X✝ Y✝\n⊢ Eq ((CategoryTheory.Comma.mapLeftIso R i).inverse.map f).right f.right","decl":"/-- A natural isomorphism `L₁ ≅ L₂` induces an equivalence of categories\n    `Comma L₁ R ≌ Comma L₂ R`. -/\n@[simps!]\ndef mapLeftIso (i : L₁ ≅ L₂) : Comma L₁ R ≌ Comma L₂ R where\n  functor := mapLeft _ i.inv\n  inverse := mapLeft _ i.hom\n  unitIso := (mapLeftId _ _).symm ≪≫ mapLeftEq _ _ _ i.hom_inv_id.symm ≪≫ mapLeftComp _ _ _\n  counitIso := (mapLeftComp _ _ _).symm ≪≫ mapLeftEq _ _ _ i.inv_hom_id ≪≫ mapLeftId _ _\n\n"}
{"name":"CategoryTheory.Comma.mapRight_obj_left","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} T\nL : CategoryTheory.Functor A T\nR₁ R₂ : CategoryTheory.Functor B T\nr : Quiver.Hom R₁ R₂\nX : CategoryTheory.Comma L R₁\n⊢ Eq ((CategoryTheory.Comma.mapRight L r).obj X).left X.left","decl":"/-- A natural transformation `R₁ ⟶ R₂` induces a functor `Comma L R₁ ⥤ Comma L R₂`. -/\n@[simps]\ndef mapRight (r : R₁ ⟶ R₂) : Comma L R₁ ⥤ Comma L R₂ where\n  obj X :=\n    { left := X.left\n      right := X.right\n      hom := X.hom ≫ r.app X.right }\n  map f :=\n    { left := f.left\n      right := f.right }\n\n"}
{"name":"CategoryTheory.Comma.mapRight_obj_hom","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} T\nL : CategoryTheory.Functor A T\nR₁ R₂ : CategoryTheory.Functor B T\nr : Quiver.Hom R₁ R₂\nX : CategoryTheory.Comma L R₁\n⊢ Eq ((CategoryTheory.Comma.mapRight L r).obj X).hom (CategoryTheory.CategoryStruct.comp X.hom (r.app X.right))","decl":"/-- A natural transformation `R₁ ⟶ R₂` induces a functor `Comma L R₁ ⥤ Comma L R₂`. -/\n@[simps]\ndef mapRight (r : R₁ ⟶ R₂) : Comma L R₁ ⥤ Comma L R₂ where\n  obj X :=\n    { left := X.left\n      right := X.right\n      hom := X.hom ≫ r.app X.right }\n  map f :=\n    { left := f.left\n      right := f.right }\n\n"}
{"name":"CategoryTheory.Comma.mapRight_obj_right","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} T\nL : CategoryTheory.Functor A T\nR₁ R₂ : CategoryTheory.Functor B T\nr : Quiver.Hom R₁ R₂\nX : CategoryTheory.Comma L R₁\n⊢ Eq ((CategoryTheory.Comma.mapRight L r).obj X).right X.right","decl":"/-- A natural transformation `R₁ ⟶ R₂` induces a functor `Comma L R₁ ⥤ Comma L R₂`. -/\n@[simps]\ndef mapRight (r : R₁ ⟶ R₂) : Comma L R₁ ⥤ Comma L R₂ where\n  obj X :=\n    { left := X.left\n      right := X.right\n      hom := X.hom ≫ r.app X.right }\n  map f :=\n    { left := f.left\n      right := f.right }\n\n"}
{"name":"CategoryTheory.Comma.mapRight_map_right","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} T\nL : CategoryTheory.Functor A T\nR₁ R₂ : CategoryTheory.Functor B T\nr : Quiver.Hom R₁ R₂\nX✝ Y✝ : CategoryTheory.Comma L R₁\nf : Quiver.Hom X✝ Y✝\n⊢ Eq ((CategoryTheory.Comma.mapRight L r).map f).right f.right","decl":"/-- A natural transformation `R₁ ⟶ R₂` induces a functor `Comma L R₁ ⥤ Comma L R₂`. -/\n@[simps]\ndef mapRight (r : R₁ ⟶ R₂) : Comma L R₁ ⥤ Comma L R₂ where\n  obj X :=\n    { left := X.left\n      right := X.right\n      hom := X.hom ≫ r.app X.right }\n  map f :=\n    { left := f.left\n      right := f.right }\n\n"}
{"name":"CategoryTheory.Comma.mapRight_map_left","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} T\nL : CategoryTheory.Functor A T\nR₁ R₂ : CategoryTheory.Functor B T\nr : Quiver.Hom R₁ R₂\nX✝ Y✝ : CategoryTheory.Comma L R₁\nf : Quiver.Hom X✝ Y✝\n⊢ Eq ((CategoryTheory.Comma.mapRight L r).map f).left f.left","decl":"/-- A natural transformation `R₁ ⟶ R₂` induces a functor `Comma L R₁ ⥤ Comma L R₂`. -/\n@[simps]\ndef mapRight (r : R₁ ⟶ R₂) : Comma L R₁ ⥤ Comma L R₂ where\n  obj X :=\n    { left := X.left\n      right := X.right\n      hom := X.hom ≫ r.app X.right }\n  map f :=\n    { left := f.left\n      right := f.right }\n\n"}
{"name":"CategoryTheory.Comma.mapRightId_inv_app_left","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nX : CategoryTheory.Comma L R\n⊢ Eq ((CategoryTheory.Comma.mapRightId L R).inv.app X).left (CategoryTheory.CategoryStruct.id X.left)","decl":"/-- The functor `Comma L R ⥤ Comma L R` induced by the identity natural transformation on `R` is\n    naturally isomorphic to the identity functor. -/\n@[simps!]\ndef mapRightId : mapRight L (𝟙 R) ≅ 𝟭 _ :=\n  NatIso.ofComponents (fun X => isoMk (Iso.refl _) (Iso.refl _))\n\n"}
{"name":"CategoryTheory.Comma.mapRightId_hom_app_right","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nX : CategoryTheory.Comma L R\n⊢ Eq ((CategoryTheory.Comma.mapRightId L R).hom.app X).right (CategoryTheory.CategoryStruct.id X.right)","decl":"/-- The functor `Comma L R ⥤ Comma L R` induced by the identity natural transformation on `R` is\n    naturally isomorphic to the identity functor. -/\n@[simps!]\ndef mapRightId : mapRight L (𝟙 R) ≅ 𝟭 _ :=\n  NatIso.ofComponents (fun X => isoMk (Iso.refl _) (Iso.refl _))\n\n"}
{"name":"CategoryTheory.Comma.mapRightId_hom_app_left","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nX : CategoryTheory.Comma L R\n⊢ Eq ((CategoryTheory.Comma.mapRightId L R).hom.app X).left (CategoryTheory.CategoryStruct.id X.left)","decl":"/-- The functor `Comma L R ⥤ Comma L R` induced by the identity natural transformation on `R` is\n    naturally isomorphic to the identity functor. -/\n@[simps!]\ndef mapRightId : mapRight L (𝟙 R) ≅ 𝟭 _ :=\n  NatIso.ofComponents (fun X => isoMk (Iso.refl _) (Iso.refl _))\n\n"}
{"name":"CategoryTheory.Comma.mapRightId_inv_app_right","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nX : CategoryTheory.Comma L R\n⊢ Eq ((CategoryTheory.Comma.mapRightId L R).inv.app X).right (CategoryTheory.CategoryStruct.id X.right)","decl":"/-- The functor `Comma L R ⥤ Comma L R` induced by the identity natural transformation on `R` is\n    naturally isomorphic to the identity functor. -/\n@[simps!]\ndef mapRightId : mapRight L (𝟙 R) ≅ 𝟭 _ :=\n  NatIso.ofComponents (fun X => isoMk (Iso.refl _) (Iso.refl _))\n\n"}
{"name":"CategoryTheory.Comma.mapRightComp_inv_app_right","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} T\nL : CategoryTheory.Functor A T\nR₁ R₂ R₃ : CategoryTheory.Functor B T\nr : Quiver.Hom R₁ R₂\nr' : Quiver.Hom R₂ R₃\nX : CategoryTheory.Comma L R₁\n⊢ Eq ((CategoryTheory.Comma.mapRightComp L r r').inv.app X).right (CategoryTheory.CategoryStruct.id X.right)","decl":"/-- The functor `Comma L R₁ ⥤ Comma L R₃` induced by the composition of the natural transformations\n    `r : R₁ ⟶ R₂` and `r' : R₂ ⟶ R₃` is naturally isomorphic to the composition of the functors\n    induced by these natural transformations. -/\n@[simps!]\ndef mapRightComp (r : R₁ ⟶ R₂) (r' : R₂ ⟶ R₃) :\n    mapRight L (r ≫ r') ≅ mapRight L r ⋙ mapRight L r' :=\n  NatIso.ofComponents (fun X => isoMk (Iso.refl _) (Iso.refl _))\n\n"}
{"name":"CategoryTheory.Comma.mapRightComp_inv_app_left","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} T\nL : CategoryTheory.Functor A T\nR₁ R₂ R₃ : CategoryTheory.Functor B T\nr : Quiver.Hom R₁ R₂\nr' : Quiver.Hom R₂ R₃\nX : CategoryTheory.Comma L R₁\n⊢ Eq ((CategoryTheory.Comma.mapRightComp L r r').inv.app X).left (CategoryTheory.CategoryStruct.id X.left)","decl":"/-- The functor `Comma L R₁ ⥤ Comma L R₃` induced by the composition of the natural transformations\n    `r : R₁ ⟶ R₂` and `r' : R₂ ⟶ R₃` is naturally isomorphic to the composition of the functors\n    induced by these natural transformations. -/\n@[simps!]\ndef mapRightComp (r : R₁ ⟶ R₂) (r' : R₂ ⟶ R₃) :\n    mapRight L (r ≫ r') ≅ mapRight L r ⋙ mapRight L r' :=\n  NatIso.ofComponents (fun X => isoMk (Iso.refl _) (Iso.refl _))\n\n"}
{"name":"CategoryTheory.Comma.mapRightComp_hom_app_left","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} T\nL : CategoryTheory.Functor A T\nR₁ R₂ R₃ : CategoryTheory.Functor B T\nr : Quiver.Hom R₁ R₂\nr' : Quiver.Hom R₂ R₃\nX : CategoryTheory.Comma L R₁\n⊢ Eq ((CategoryTheory.Comma.mapRightComp L r r').hom.app X).left (CategoryTheory.CategoryStruct.id X.left)","decl":"/-- The functor `Comma L R₁ ⥤ Comma L R₃` induced by the composition of the natural transformations\n    `r : R₁ ⟶ R₂` and `r' : R₂ ⟶ R₃` is naturally isomorphic to the composition of the functors\n    induced by these natural transformations. -/\n@[simps!]\ndef mapRightComp (r : R₁ ⟶ R₂) (r' : R₂ ⟶ R₃) :\n    mapRight L (r ≫ r') ≅ mapRight L r ⋙ mapRight L r' :=\n  NatIso.ofComponents (fun X => isoMk (Iso.refl _) (Iso.refl _))\n\n"}
{"name":"CategoryTheory.Comma.mapRightComp_hom_app_right","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} T\nL : CategoryTheory.Functor A T\nR₁ R₂ R₃ : CategoryTheory.Functor B T\nr : Quiver.Hom R₁ R₂\nr' : Quiver.Hom R₂ R₃\nX : CategoryTheory.Comma L R₁\n⊢ Eq ((CategoryTheory.Comma.mapRightComp L r r').hom.app X).right (CategoryTheory.CategoryStruct.id X.right)","decl":"/-- The functor `Comma L R₁ ⥤ Comma L R₃` induced by the composition of the natural transformations\n    `r : R₁ ⟶ R₂` and `r' : R₂ ⟶ R₃` is naturally isomorphic to the composition of the functors\n    induced by these natural transformations. -/\n@[simps!]\ndef mapRightComp (r : R₁ ⟶ R₂) (r' : R₂ ⟶ R₃) :\n    mapRight L (r ≫ r') ≅ mapRight L r ⋙ mapRight L r' :=\n  NatIso.ofComponents (fun X => isoMk (Iso.refl _) (Iso.refl _))\n\n"}
{"name":"CategoryTheory.Comma.mapRightEq_inv_app_left","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} T\nL : CategoryTheory.Functor A T\nR₁ R₂ : CategoryTheory.Functor B T\nr r' : Quiver.Hom R₁ R₂\nh : Eq r r'\nX : CategoryTheory.Comma L R₁\n⊢ Eq ((CategoryTheory.Comma.mapRightEq L r r' h).inv.app X).left (CategoryTheory.CategoryStruct.id X.left)","decl":"/-- Two equal natural transformations `R₁ ⟶ R₂` yield naturally isomorphic functors\n    `Comma L R₁ ⥤ Comma L R₂`. -/\n@[simps!]\ndef mapRightEq (r r' : R₁ ⟶ R₂) (h : r = r') : mapRight L r ≅ mapRight L r' :=\n  NatIso.ofComponents (fun X => isoMk (Iso.refl _) (Iso.refl _))\n\n"}
{"name":"CategoryTheory.Comma.mapRightEq_inv_app_right","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} T\nL : CategoryTheory.Functor A T\nR₁ R₂ : CategoryTheory.Functor B T\nr r' : Quiver.Hom R₁ R₂\nh : Eq r r'\nX : CategoryTheory.Comma L R₁\n⊢ Eq ((CategoryTheory.Comma.mapRightEq L r r' h).inv.app X).right (CategoryTheory.CategoryStruct.id X.right)","decl":"/-- Two equal natural transformations `R₁ ⟶ R₂` yield naturally isomorphic functors\n    `Comma L R₁ ⥤ Comma L R₂`. -/\n@[simps!]\ndef mapRightEq (r r' : R₁ ⟶ R₂) (h : r = r') : mapRight L r ≅ mapRight L r' :=\n  NatIso.ofComponents (fun X => isoMk (Iso.refl _) (Iso.refl _))\n\n"}
{"name":"CategoryTheory.Comma.mapRightEq_hom_app_left","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} T\nL : CategoryTheory.Functor A T\nR₁ R₂ : CategoryTheory.Functor B T\nr r' : Quiver.Hom R₁ R₂\nh : Eq r r'\nX : CategoryTheory.Comma L R₁\n⊢ Eq ((CategoryTheory.Comma.mapRightEq L r r' h).hom.app X).left (CategoryTheory.CategoryStruct.id X.left)","decl":"/-- Two equal natural transformations `R₁ ⟶ R₂` yield naturally isomorphic functors\n    `Comma L R₁ ⥤ Comma L R₂`. -/\n@[simps!]\ndef mapRightEq (r r' : R₁ ⟶ R₂) (h : r = r') : mapRight L r ≅ mapRight L r' :=\n  NatIso.ofComponents (fun X => isoMk (Iso.refl _) (Iso.refl _))\n\n"}
{"name":"CategoryTheory.Comma.mapRightEq_hom_app_right","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} T\nL : CategoryTheory.Functor A T\nR₁ R₂ : CategoryTheory.Functor B T\nr r' : Quiver.Hom R₁ R₂\nh : Eq r r'\nX : CategoryTheory.Comma L R₁\n⊢ Eq ((CategoryTheory.Comma.mapRightEq L r r' h).hom.app X).right (CategoryTheory.CategoryStruct.id X.right)","decl":"/-- Two equal natural transformations `R₁ ⟶ R₂` yield naturally isomorphic functors\n    `Comma L R₁ ⥤ Comma L R₂`. -/\n@[simps!]\ndef mapRightEq (r r' : R₁ ⟶ R₂) (h : r = r') : mapRight L r ≅ mapRight L r' :=\n  NatIso.ofComponents (fun X => isoMk (Iso.refl _) (Iso.refl _))\n\n"}
{"name":"CategoryTheory.Comma.mapRightIso_counitIso_inv_app_left","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} T\nL : CategoryTheory.Functor A T\nR₁ R₂ : CategoryTheory.Functor B T\ni : CategoryTheory.Iso R₁ R₂\nX : CategoryTheory.Comma L R₂\n⊢ Eq ((CategoryTheory.Comma.mapRightIso L i).counitIso.inv.app X).left (CategoryTheory.CategoryStruct.id X.left)","decl":"/-- A natural isomorphism `R₁ ≅ R₂` induces an equivalence of categories\n    `Comma L R₁ ≌ Comma L R₂`. -/\n@[simps!]\ndef mapRightIso (i : R₁ ≅ R₂) : Comma L R₁ ≌ Comma L R₂ where\n  functor := mapRight _ i.hom\n  inverse := mapRight _ i.inv\n  unitIso := (mapRightId _ _).symm ≪≫ mapRightEq _ _ _ i.hom_inv_id.symm ≪≫ mapRightComp _ _ _\n  counitIso := (mapRightComp _ _ _).symm ≪≫ mapRightEq _ _ _ i.inv_hom_id ≪≫ mapRightId _ _\n\n"}
{"name":"CategoryTheory.Comma.mapRightIso_counitIso_hom_app_right","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} T\nL : CategoryTheory.Functor A T\nR₁ R₂ : CategoryTheory.Functor B T\ni : CategoryTheory.Iso R₁ R₂\nX : CategoryTheory.Comma L R₂\n⊢ Eq ((CategoryTheory.Comma.mapRightIso L i).counitIso.hom.app X).right (CategoryTheory.CategoryStruct.id X.right)","decl":"/-- A natural isomorphism `R₁ ≅ R₂` induces an equivalence of categories\n    `Comma L R₁ ≌ Comma L R₂`. -/\n@[simps!]\ndef mapRightIso (i : R₁ ≅ R₂) : Comma L R₁ ≌ Comma L R₂ where\n  functor := mapRight _ i.hom\n  inverse := mapRight _ i.inv\n  unitIso := (mapRightId _ _).symm ≪≫ mapRightEq _ _ _ i.hom_inv_id.symm ≪≫ mapRightComp _ _ _\n  counitIso := (mapRightComp _ _ _).symm ≪≫ mapRightEq _ _ _ i.inv_hom_id ≪≫ mapRightId _ _\n\n"}
{"name":"CategoryTheory.Comma.mapRightIso_unitIso_hom_app_left","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} T\nL : CategoryTheory.Functor A T\nR₁ R₂ : CategoryTheory.Functor B T\ni : CategoryTheory.Iso R₁ R₂\nX : CategoryTheory.Comma L R₁\n⊢ Eq ((CategoryTheory.Comma.mapRightIso L i).unitIso.hom.app X).left (CategoryTheory.CategoryStruct.id X.left)","decl":"/-- A natural isomorphism `R₁ ≅ R₂` induces an equivalence of categories\n    `Comma L R₁ ≌ Comma L R₂`. -/\n@[simps!]\ndef mapRightIso (i : R₁ ≅ R₂) : Comma L R₁ ≌ Comma L R₂ where\n  functor := mapRight _ i.hom\n  inverse := mapRight _ i.inv\n  unitIso := (mapRightId _ _).symm ≪≫ mapRightEq _ _ _ i.hom_inv_id.symm ≪≫ mapRightComp _ _ _\n  counitIso := (mapRightComp _ _ _).symm ≪≫ mapRightEq _ _ _ i.inv_hom_id ≪≫ mapRightId _ _\n\n"}
{"name":"CategoryTheory.Comma.mapRightIso_functor_obj_left","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} T\nL : CategoryTheory.Functor A T\nR₁ R₂ : CategoryTheory.Functor B T\ni : CategoryTheory.Iso R₁ R₂\nX : CategoryTheory.Comma L R₁\n⊢ Eq ((CategoryTheory.Comma.mapRightIso L i).functor.obj X).left X.left","decl":"/-- A natural isomorphism `R₁ ≅ R₂` induces an equivalence of categories\n    `Comma L R₁ ≌ Comma L R₂`. -/\n@[simps!]\ndef mapRightIso (i : R₁ ≅ R₂) : Comma L R₁ ≌ Comma L R₂ where\n  functor := mapRight _ i.hom\n  inverse := mapRight _ i.inv\n  unitIso := (mapRightId _ _).symm ≪≫ mapRightEq _ _ _ i.hom_inv_id.symm ≪≫ mapRightComp _ _ _\n  counitIso := (mapRightComp _ _ _).symm ≪≫ mapRightEq _ _ _ i.inv_hom_id ≪≫ mapRightId _ _\n\n"}
{"name":"CategoryTheory.Comma.mapRightIso_functor_obj_right","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} T\nL : CategoryTheory.Functor A T\nR₁ R₂ : CategoryTheory.Functor B T\ni : CategoryTheory.Iso R₁ R₂\nX : CategoryTheory.Comma L R₁\n⊢ Eq ((CategoryTheory.Comma.mapRightIso L i).functor.obj X).right X.right","decl":"/-- A natural isomorphism `R₁ ≅ R₂` induces an equivalence of categories\n    `Comma L R₁ ≌ Comma L R₂`. -/\n@[simps!]\ndef mapRightIso (i : R₁ ≅ R₂) : Comma L R₁ ≌ Comma L R₂ where\n  functor := mapRight _ i.hom\n  inverse := mapRight _ i.inv\n  unitIso := (mapRightId _ _).symm ≪≫ mapRightEq _ _ _ i.hom_inv_id.symm ≪≫ mapRightComp _ _ _\n  counitIso := (mapRightComp _ _ _).symm ≪≫ mapRightEq _ _ _ i.inv_hom_id ≪≫ mapRightId _ _\n\n"}
{"name":"CategoryTheory.Comma.mapRightIso_inverse_obj_left","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} T\nL : CategoryTheory.Functor A T\nR₁ R₂ : CategoryTheory.Functor B T\ni : CategoryTheory.Iso R₁ R₂\nX : CategoryTheory.Comma L R₂\n⊢ Eq ((CategoryTheory.Comma.mapRightIso L i).inverse.obj X).left X.left","decl":"/-- A natural isomorphism `R₁ ≅ R₂` induces an equivalence of categories\n    `Comma L R₁ ≌ Comma L R₂`. -/\n@[simps!]\ndef mapRightIso (i : R₁ ≅ R₂) : Comma L R₁ ≌ Comma L R₂ where\n  functor := mapRight _ i.hom\n  inverse := mapRight _ i.inv\n  unitIso := (mapRightId _ _).symm ≪≫ mapRightEq _ _ _ i.hom_inv_id.symm ≪≫ mapRightComp _ _ _\n  counitIso := (mapRightComp _ _ _).symm ≪≫ mapRightEq _ _ _ i.inv_hom_id ≪≫ mapRightId _ _\n\n"}
{"name":"CategoryTheory.Comma.mapRightIso_inverse_map_left","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} T\nL : CategoryTheory.Functor A T\nR₁ R₂ : CategoryTheory.Functor B T\ni : CategoryTheory.Iso R₁ R₂\nX✝ Y✝ : CategoryTheory.Comma L R₂\nf : Quiver.Hom X✝ Y✝\n⊢ Eq ((CategoryTheory.Comma.mapRightIso L i).inverse.map f).left f.left","decl":"/-- A natural isomorphism `R₁ ≅ R₂` induces an equivalence of categories\n    `Comma L R₁ ≌ Comma L R₂`. -/\n@[simps!]\ndef mapRightIso (i : R₁ ≅ R₂) : Comma L R₁ ≌ Comma L R₂ where\n  functor := mapRight _ i.hom\n  inverse := mapRight _ i.inv\n  unitIso := (mapRightId _ _).symm ≪≫ mapRightEq _ _ _ i.hom_inv_id.symm ≪≫ mapRightComp _ _ _\n  counitIso := (mapRightComp _ _ _).symm ≪≫ mapRightEq _ _ _ i.inv_hom_id ≪≫ mapRightId _ _\n\n"}
{"name":"CategoryTheory.Comma.mapRightIso_counitIso_hom_app_left","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} T\nL : CategoryTheory.Functor A T\nR₁ R₂ : CategoryTheory.Functor B T\ni : CategoryTheory.Iso R₁ R₂\nX : CategoryTheory.Comma L R₂\n⊢ Eq ((CategoryTheory.Comma.mapRightIso L i).counitIso.hom.app X).left (CategoryTheory.CategoryStruct.id X.left)","decl":"/-- A natural isomorphism `R₁ ≅ R₂` induces an equivalence of categories\n    `Comma L R₁ ≌ Comma L R₂`. -/\n@[simps!]\ndef mapRightIso (i : R₁ ≅ R₂) : Comma L R₁ ≌ Comma L R₂ where\n  functor := mapRight _ i.hom\n  inverse := mapRight _ i.inv\n  unitIso := (mapRightId _ _).symm ≪≫ mapRightEq _ _ _ i.hom_inv_id.symm ≪≫ mapRightComp _ _ _\n  counitIso := (mapRightComp _ _ _).symm ≪≫ mapRightEq _ _ _ i.inv_hom_id ≪≫ mapRightId _ _\n\n"}
{"name":"CategoryTheory.Comma.mapRightIso_functor_map_left","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} T\nL : CategoryTheory.Functor A T\nR₁ R₂ : CategoryTheory.Functor B T\ni : CategoryTheory.Iso R₁ R₂\nX✝ Y✝ : CategoryTheory.Comma L R₁\nf : Quiver.Hom X✝ Y✝\n⊢ Eq ((CategoryTheory.Comma.mapRightIso L i).functor.map f).left f.left","decl":"/-- A natural isomorphism `R₁ ≅ R₂` induces an equivalence of categories\n    `Comma L R₁ ≌ Comma L R₂`. -/\n@[simps!]\ndef mapRightIso (i : R₁ ≅ R₂) : Comma L R₁ ≌ Comma L R₂ where\n  functor := mapRight _ i.hom\n  inverse := mapRight _ i.inv\n  unitIso := (mapRightId _ _).symm ≪≫ mapRightEq _ _ _ i.hom_inv_id.symm ≪≫ mapRightComp _ _ _\n  counitIso := (mapRightComp _ _ _).symm ≪≫ mapRightEq _ _ _ i.inv_hom_id ≪≫ mapRightId _ _\n\n"}
{"name":"CategoryTheory.Comma.mapRightIso_unitIso_inv_app_right","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} T\nL : CategoryTheory.Functor A T\nR₁ R₂ : CategoryTheory.Functor B T\ni : CategoryTheory.Iso R₁ R₂\nX : CategoryTheory.Comma L R₁\n⊢ Eq ((CategoryTheory.Comma.mapRightIso L i).unitIso.inv.app X).right (CategoryTheory.CategoryStruct.id X.right)","decl":"/-- A natural isomorphism `R₁ ≅ R₂` induces an equivalence of categories\n    `Comma L R₁ ≌ Comma L R₂`. -/\n@[simps!]\ndef mapRightIso (i : R₁ ≅ R₂) : Comma L R₁ ≌ Comma L R₂ where\n  functor := mapRight _ i.hom\n  inverse := mapRight _ i.inv\n  unitIso := (mapRightId _ _).symm ≪≫ mapRightEq _ _ _ i.hom_inv_id.symm ≪≫ mapRightComp _ _ _\n  counitIso := (mapRightComp _ _ _).symm ≪≫ mapRightEq _ _ _ i.inv_hom_id ≪≫ mapRightId _ _\n\n"}
{"name":"CategoryTheory.Comma.mapRightIso_functor_obj_hom","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} T\nL : CategoryTheory.Functor A T\nR₁ R₂ : CategoryTheory.Functor B T\ni : CategoryTheory.Iso R₁ R₂\nX : CategoryTheory.Comma L R₁\n⊢ Eq ((CategoryTheory.Comma.mapRightIso L i).functor.obj X).hom (CategoryTheory.CategoryStruct.comp X.hom (i.hom.app X.right))","decl":"/-- A natural isomorphism `R₁ ≅ R₂` induces an equivalence of categories\n    `Comma L R₁ ≌ Comma L R₂`. -/\n@[simps!]\ndef mapRightIso (i : R₁ ≅ R₂) : Comma L R₁ ≌ Comma L R₂ where\n  functor := mapRight _ i.hom\n  inverse := mapRight _ i.inv\n  unitIso := (mapRightId _ _).symm ≪≫ mapRightEq _ _ _ i.hom_inv_id.symm ≪≫ mapRightComp _ _ _\n  counitIso := (mapRightComp _ _ _).symm ≪≫ mapRightEq _ _ _ i.inv_hom_id ≪≫ mapRightId _ _\n\n"}
{"name":"CategoryTheory.Comma.mapRightIso_counitIso_inv_app_right","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} T\nL : CategoryTheory.Functor A T\nR₁ R₂ : CategoryTheory.Functor B T\ni : CategoryTheory.Iso R₁ R₂\nX : CategoryTheory.Comma L R₂\n⊢ Eq ((CategoryTheory.Comma.mapRightIso L i).counitIso.inv.app X).right (CategoryTheory.CategoryStruct.id X.right)","decl":"/-- A natural isomorphism `R₁ ≅ R₂` induces an equivalence of categories\n    `Comma L R₁ ≌ Comma L R₂`. -/\n@[simps!]\ndef mapRightIso (i : R₁ ≅ R₂) : Comma L R₁ ≌ Comma L R₂ where\n  functor := mapRight _ i.hom\n  inverse := mapRight _ i.inv\n  unitIso := (mapRightId _ _).symm ≪≫ mapRightEq _ _ _ i.hom_inv_id.symm ≪≫ mapRightComp _ _ _\n  counitIso := (mapRightComp _ _ _).symm ≪≫ mapRightEq _ _ _ i.inv_hom_id ≪≫ mapRightId _ _\n\n"}
{"name":"CategoryTheory.Comma.mapRightIso_unitIso_hom_app_right","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} T\nL : CategoryTheory.Functor A T\nR₁ R₂ : CategoryTheory.Functor B T\ni : CategoryTheory.Iso R₁ R₂\nX : CategoryTheory.Comma L R₁\n⊢ Eq ((CategoryTheory.Comma.mapRightIso L i).unitIso.hom.app X).right (CategoryTheory.CategoryStruct.id X.right)","decl":"/-- A natural isomorphism `R₁ ≅ R₂` induces an equivalence of categories\n    `Comma L R₁ ≌ Comma L R₂`. -/\n@[simps!]\ndef mapRightIso (i : R₁ ≅ R₂) : Comma L R₁ ≌ Comma L R₂ where\n  functor := mapRight _ i.hom\n  inverse := mapRight _ i.inv\n  unitIso := (mapRightId _ _).symm ≪≫ mapRightEq _ _ _ i.hom_inv_id.symm ≪≫ mapRightComp _ _ _\n  counitIso := (mapRightComp _ _ _).symm ≪≫ mapRightEq _ _ _ i.inv_hom_id ≪≫ mapRightId _ _\n\n"}
{"name":"CategoryTheory.Comma.mapRightIso_inverse_obj_hom","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} T\nL : CategoryTheory.Functor A T\nR₁ R₂ : CategoryTheory.Functor B T\ni : CategoryTheory.Iso R₁ R₂\nX : CategoryTheory.Comma L R₂\n⊢ Eq ((CategoryTheory.Comma.mapRightIso L i).inverse.obj X).hom (CategoryTheory.CategoryStruct.comp X.hom (i.inv.app X.right))","decl":"/-- A natural isomorphism `R₁ ≅ R₂` induces an equivalence of categories\n    `Comma L R₁ ≌ Comma L R₂`. -/\n@[simps!]\ndef mapRightIso (i : R₁ ≅ R₂) : Comma L R₁ ≌ Comma L R₂ where\n  functor := mapRight _ i.hom\n  inverse := mapRight _ i.inv\n  unitIso := (mapRightId _ _).symm ≪≫ mapRightEq _ _ _ i.hom_inv_id.symm ≪≫ mapRightComp _ _ _\n  counitIso := (mapRightComp _ _ _).symm ≪≫ mapRightEq _ _ _ i.inv_hom_id ≪≫ mapRightId _ _\n\n"}
{"name":"CategoryTheory.Comma.mapRightIso_inverse_map_right","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} T\nL : CategoryTheory.Functor A T\nR₁ R₂ : CategoryTheory.Functor B T\ni : CategoryTheory.Iso R₁ R₂\nX✝ Y✝ : CategoryTheory.Comma L R₂\nf : Quiver.Hom X✝ Y✝\n⊢ Eq ((CategoryTheory.Comma.mapRightIso L i).inverse.map f).right f.right","decl":"/-- A natural isomorphism `R₁ ≅ R₂` induces an equivalence of categories\n    `Comma L R₁ ≌ Comma L R₂`. -/\n@[simps!]\ndef mapRightIso (i : R₁ ≅ R₂) : Comma L R₁ ≌ Comma L R₂ where\n  functor := mapRight _ i.hom\n  inverse := mapRight _ i.inv\n  unitIso := (mapRightId _ _).symm ≪≫ mapRightEq _ _ _ i.hom_inv_id.symm ≪≫ mapRightComp _ _ _\n  counitIso := (mapRightComp _ _ _).symm ≪≫ mapRightEq _ _ _ i.inv_hom_id ≪≫ mapRightId _ _\n\n"}
{"name":"CategoryTheory.Comma.mapRightIso_functor_map_right","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} T\nL : CategoryTheory.Functor A T\nR₁ R₂ : CategoryTheory.Functor B T\ni : CategoryTheory.Iso R₁ R₂\nX✝ Y✝ : CategoryTheory.Comma L R₁\nf : Quiver.Hom X✝ Y✝\n⊢ Eq ((CategoryTheory.Comma.mapRightIso L i).functor.map f).right f.right","decl":"/-- A natural isomorphism `R₁ ≅ R₂` induces an equivalence of categories\n    `Comma L R₁ ≌ Comma L R₂`. -/\n@[simps!]\ndef mapRightIso (i : R₁ ≅ R₂) : Comma L R₁ ≌ Comma L R₂ where\n  functor := mapRight _ i.hom\n  inverse := mapRight _ i.inv\n  unitIso := (mapRightId _ _).symm ≪≫ mapRightEq _ _ _ i.hom_inv_id.symm ≪≫ mapRightComp _ _ _\n  counitIso := (mapRightComp _ _ _).symm ≪≫ mapRightEq _ _ _ i.inv_hom_id ≪≫ mapRightId _ _\n\n"}
{"name":"CategoryTheory.Comma.mapRightIso_inverse_obj_right","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} T\nL : CategoryTheory.Functor A T\nR₁ R₂ : CategoryTheory.Functor B T\ni : CategoryTheory.Iso R₁ R₂\nX : CategoryTheory.Comma L R₂\n⊢ Eq ((CategoryTheory.Comma.mapRightIso L i).inverse.obj X).right X.right","decl":"/-- A natural isomorphism `R₁ ≅ R₂` induces an equivalence of categories\n    `Comma L R₁ ≌ Comma L R₂`. -/\n@[simps!]\ndef mapRightIso (i : R₁ ≅ R₂) : Comma L R₁ ≌ Comma L R₂ where\n  functor := mapRight _ i.hom\n  inverse := mapRight _ i.inv\n  unitIso := (mapRightId _ _).symm ≪≫ mapRightEq _ _ _ i.hom_inv_id.symm ≪≫ mapRightComp _ _ _\n  counitIso := (mapRightComp _ _ _).symm ≪≫ mapRightEq _ _ _ i.inv_hom_id ≪≫ mapRightId _ _\n\n"}
{"name":"CategoryTheory.Comma.mapRightIso_unitIso_inv_app_left","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} T\nL : CategoryTheory.Functor A T\nR₁ R₂ : CategoryTheory.Functor B T\ni : CategoryTheory.Iso R₁ R₂\nX : CategoryTheory.Comma L R₁\n⊢ Eq ((CategoryTheory.Comma.mapRightIso L i).unitIso.inv.app X).left (CategoryTheory.CategoryStruct.id X.left)","decl":"/-- A natural isomorphism `R₁ ≅ R₂` induces an equivalence of categories\n    `Comma L R₁ ≌ Comma L R₂`. -/\n@[simps!]\ndef mapRightIso (i : R₁ ≅ R₂) : Comma L R₁ ≌ Comma L R₂ where\n  functor := mapRight _ i.hom\n  inverse := mapRight _ i.inv\n  unitIso := (mapRightId _ _).symm ≪≫ mapRightEq _ _ _ i.hom_inv_id.symm ≪≫ mapRightComp _ _ _\n  counitIso := (mapRightComp _ _ _).symm ≪≫ mapRightEq _ _ _ i.inv_hom_id ≪≫ mapRightId _ _\n\n"}
{"name":"CategoryTheory.Comma.preLeft_obj_right","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} T\nC : Type u₄\ninst✝ : CategoryTheory.Category.{v₄, u₄} C\nF : CategoryTheory.Functor C A\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nX : CategoryTheory.Comma (F.comp L) R\n⊢ Eq ((CategoryTheory.Comma.preLeft F L R).obj X).right X.right","decl":"/-- The functor `(F ⋙ L, R) ⥤ (L, R)` -/\n@[simps]\ndef preLeft (F : C ⥤ A) (L : A ⥤ T) (R : B ⥤ T) : Comma (F ⋙ L) R ⥤ Comma L R where\n  obj X :=\n    { left := F.obj X.left\n      right := X.right\n      hom := X.hom }\n  map f :=\n    { left := F.map f.left\n      right := f.right\n      w := by simpa using f.w }\n\n"}
{"name":"CategoryTheory.Comma.preLeft_obj_left","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} T\nC : Type u₄\ninst✝ : CategoryTheory.Category.{v₄, u₄} C\nF : CategoryTheory.Functor C A\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nX : CategoryTheory.Comma (F.comp L) R\n⊢ Eq ((CategoryTheory.Comma.preLeft F L R).obj X).left (F.obj X.left)","decl":"/-- The functor `(F ⋙ L, R) ⥤ (L, R)` -/\n@[simps]\ndef preLeft (F : C ⥤ A) (L : A ⥤ T) (R : B ⥤ T) : Comma (F ⋙ L) R ⥤ Comma L R where\n  obj X :=\n    { left := F.obj X.left\n      right := X.right\n      hom := X.hom }\n  map f :=\n    { left := F.map f.left\n      right := f.right\n      w := by simpa using f.w }\n\n"}
{"name":"CategoryTheory.Comma.preLeft_map_left","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} T\nC : Type u₄\ninst✝ : CategoryTheory.Category.{v₄, u₄} C\nF : CategoryTheory.Functor C A\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nX✝ Y✝ : CategoryTheory.Comma (F.comp L) R\nf : Quiver.Hom X✝ Y✝\n⊢ Eq ((CategoryTheory.Comma.preLeft F L R).map f).left (F.map f.left)","decl":"/-- The functor `(F ⋙ L, R) ⥤ (L, R)` -/\n@[simps]\ndef preLeft (F : C ⥤ A) (L : A ⥤ T) (R : B ⥤ T) : Comma (F ⋙ L) R ⥤ Comma L R where\n  obj X :=\n    { left := F.obj X.left\n      right := X.right\n      hom := X.hom }\n  map f :=\n    { left := F.map f.left\n      right := f.right\n      w := by simpa using f.w }\n\n"}
{"name":"CategoryTheory.Comma.preLeft_map_right","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} T\nC : Type u₄\ninst✝ : CategoryTheory.Category.{v₄, u₄} C\nF : CategoryTheory.Functor C A\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nX✝ Y✝ : CategoryTheory.Comma (F.comp L) R\nf : Quiver.Hom X✝ Y✝\n⊢ Eq ((CategoryTheory.Comma.preLeft F L R).map f).right f.right","decl":"/-- The functor `(F ⋙ L, R) ⥤ (L, R)` -/\n@[simps]\ndef preLeft (F : C ⥤ A) (L : A ⥤ T) (R : B ⥤ T) : Comma (F ⋙ L) R ⥤ Comma L R where\n  obj X :=\n    { left := F.obj X.left\n      right := X.right\n      hom := X.hom }\n  map f :=\n    { left := F.map f.left\n      right := f.right\n      w := by simpa using f.w }\n\n"}
{"name":"CategoryTheory.Comma.preLeft_obj_hom","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} T\nC : Type u₄\ninst✝ : CategoryTheory.Category.{v₄, u₄} C\nF : CategoryTheory.Functor C A\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nX : CategoryTheory.Comma (F.comp L) R\n⊢ Eq ((CategoryTheory.Comma.preLeft F L R).obj X).hom X.hom","decl":"/-- The functor `(F ⋙ L, R) ⥤ (L, R)` -/\n@[simps]\ndef preLeft (F : C ⥤ A) (L : A ⥤ T) (R : B ⥤ T) : Comma (F ⋙ L) R ⥤ Comma L R where\n  obj X :=\n    { left := F.obj X.left\n      right := X.right\n      hom := X.hom }\n  map f :=\n    { left := F.map f.left\n      right := f.right\n      w := by simpa using f.w }\n\n"}
{"name":"CategoryTheory.Comma.instFaithfulCompPreLeft","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝² : CategoryTheory.Category.{v₃, u₃} T\nC : Type u₄\ninst✝¹ : CategoryTheory.Category.{v₄, u₄} C\nF : CategoryTheory.Functor C A\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\ninst✝ : F.Faithful\n⊢ (CategoryTheory.Comma.preLeft F L R).Faithful","decl":"instance (F : C ⥤ A) (L : A ⥤ T) (R : B ⥤ T) [F.Faithful] : (preLeft F L R).Faithful :=\n  Functor.Faithful.of_iso (preLeftIso F L R).symm\n\n"}
{"name":"CategoryTheory.Comma.instFullCompPreLeft","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝² : CategoryTheory.Category.{v₃, u₃} T\nC : Type u₄\ninst✝¹ : CategoryTheory.Category.{v₄, u₄} C\nF : CategoryTheory.Functor C A\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\ninst✝ : F.Full\n⊢ (CategoryTheory.Comma.preLeft F L R).Full","decl":"instance (F : C ⥤ A) (L : A ⥤ T) (R : B ⥤ T) [F.Full] : (preLeft F L R).Full :=\n  Functor.Full.of_iso (preLeftIso F L R).symm\n\n"}
{"name":"CategoryTheory.Comma.instEssSurjCompPreLeft","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝² : CategoryTheory.Category.{v₃, u₃} T\nC : Type u₄\ninst✝¹ : CategoryTheory.Category.{v₄, u₄} C\nF : CategoryTheory.Functor C A\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\ninst✝ : F.EssSurj\n⊢ (CategoryTheory.Comma.preLeft F L R).EssSurj","decl":"instance (F : C ⥤ A) (L : A ⥤ T) (R : B ⥤ T) [F.EssSurj] : (preLeft F L R).EssSurj :=\n  Functor.essSurj_of_iso (preLeftIso F L R).symm\n\n"}
{"name":"CategoryTheory.Comma.isEquivalence_preLeft","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝² : CategoryTheory.Category.{v₃, u₃} T\nC : Type u₄\ninst✝¹ : CategoryTheory.Category.{v₄, u₄} C\nF : CategoryTheory.Functor C A\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\ninst✝ : F.IsEquivalence\n⊢ (CategoryTheory.Comma.preLeft F L R).IsEquivalence","decl":"/-- If `F` is an equivalence, then so is `preLeft F L R`. -/\ninstance isEquivalence_preLeft (F : C ⥤ A) (L : A ⥤ T) (R : B ⥤ T) [F.IsEquivalence] :\n    (preLeft F L R).IsEquivalence where\n\n"}
{"name":"CategoryTheory.Comma.preRight_obj_right","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} T\nC : Type u₄\ninst✝ : CategoryTheory.Category.{v₄, u₄} C\nL : CategoryTheory.Functor A T\nF : CategoryTheory.Functor C B\nR : CategoryTheory.Functor B T\nX : CategoryTheory.Comma L (F.comp R)\n⊢ Eq ((CategoryTheory.Comma.preRight L F R).obj X).right (F.obj X.right)","decl":"/-- The functor `(F ⋙ L, R) ⥤ (L, R)` -/\n@[simps]\ndef preRight (L : A ⥤ T) (F : C ⥤ B) (R : B ⥤ T) : Comma L (F ⋙ R) ⥤ Comma L R where\n  obj X :=\n    { left := X.left\n      right := F.obj X.right\n      hom := X.hom }\n  map f :=\n    { left := f.left\n      right := F.map f.right }\n\n"}
{"name":"CategoryTheory.Comma.preRight_obj_hom","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} T\nC : Type u₄\ninst✝ : CategoryTheory.Category.{v₄, u₄} C\nL : CategoryTheory.Functor A T\nF : CategoryTheory.Functor C B\nR : CategoryTheory.Functor B T\nX : CategoryTheory.Comma L (F.comp R)\n⊢ Eq ((CategoryTheory.Comma.preRight L F R).obj X).hom X.hom","decl":"/-- The functor `(F ⋙ L, R) ⥤ (L, R)` -/\n@[simps]\ndef preRight (L : A ⥤ T) (F : C ⥤ B) (R : B ⥤ T) : Comma L (F ⋙ R) ⥤ Comma L R where\n  obj X :=\n    { left := X.left\n      right := F.obj X.right\n      hom := X.hom }\n  map f :=\n    { left := f.left\n      right := F.map f.right }\n\n"}
{"name":"CategoryTheory.Comma.preRight_obj_left","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} T\nC : Type u₄\ninst✝ : CategoryTheory.Category.{v₄, u₄} C\nL : CategoryTheory.Functor A T\nF : CategoryTheory.Functor C B\nR : CategoryTheory.Functor B T\nX : CategoryTheory.Comma L (F.comp R)\n⊢ Eq ((CategoryTheory.Comma.preRight L F R).obj X).left X.left","decl":"/-- The functor `(F ⋙ L, R) ⥤ (L, R)` -/\n@[simps]\ndef preRight (L : A ⥤ T) (F : C ⥤ B) (R : B ⥤ T) : Comma L (F ⋙ R) ⥤ Comma L R where\n  obj X :=\n    { left := X.left\n      right := F.obj X.right\n      hom := X.hom }\n  map f :=\n    { left := f.left\n      right := F.map f.right }\n\n"}
{"name":"CategoryTheory.Comma.preRight_map_left","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} T\nC : Type u₄\ninst✝ : CategoryTheory.Category.{v₄, u₄} C\nL : CategoryTheory.Functor A T\nF : CategoryTheory.Functor C B\nR : CategoryTheory.Functor B T\nX✝ Y✝ : CategoryTheory.Comma L (F.comp R)\nf : Quiver.Hom X✝ Y✝\n⊢ Eq ((CategoryTheory.Comma.preRight L F R).map f).left f.left","decl":"/-- The functor `(F ⋙ L, R) ⥤ (L, R)` -/\n@[simps]\ndef preRight (L : A ⥤ T) (F : C ⥤ B) (R : B ⥤ T) : Comma L (F ⋙ R) ⥤ Comma L R where\n  obj X :=\n    { left := X.left\n      right := F.obj X.right\n      hom := X.hom }\n  map f :=\n    { left := f.left\n      right := F.map f.right }\n\n"}
{"name":"CategoryTheory.Comma.preRight_map_right","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} T\nC : Type u₄\ninst✝ : CategoryTheory.Category.{v₄, u₄} C\nL : CategoryTheory.Functor A T\nF : CategoryTheory.Functor C B\nR : CategoryTheory.Functor B T\nX✝ Y✝ : CategoryTheory.Comma L (F.comp R)\nf : Quiver.Hom X✝ Y✝\n⊢ Eq ((CategoryTheory.Comma.preRight L F R).map f).right (F.map f.right)","decl":"/-- The functor `(F ⋙ L, R) ⥤ (L, R)` -/\n@[simps]\ndef preRight (L : A ⥤ T) (F : C ⥤ B) (R : B ⥤ T) : Comma L (F ⋙ R) ⥤ Comma L R where\n  obj X :=\n    { left := X.left\n      right := F.obj X.right\n      hom := X.hom }\n  map f :=\n    { left := f.left\n      right := F.map f.right }\n\n"}
{"name":"CategoryTheory.Comma.instFaithfulCompPreRight","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝² : CategoryTheory.Category.{v₃, u₃} T\nC : Type u₄\ninst✝¹ : CategoryTheory.Category.{v₄, u₄} C\nL : CategoryTheory.Functor A T\nF : CategoryTheory.Functor C B\nR : CategoryTheory.Functor B T\ninst✝ : F.Faithful\n⊢ (CategoryTheory.Comma.preRight L F R).Faithful","decl":"instance (L : A ⥤ T) (F : C ⥤ B) (R : B ⥤ T) [F.Faithful] : (preRight L F R).Faithful :=\n  Functor.Faithful.of_iso (preRightIso L F R).symm\n\n"}
{"name":"CategoryTheory.Comma.instFullCompPreRight","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝² : CategoryTheory.Category.{v₃, u₃} T\nC : Type u₄\ninst✝¹ : CategoryTheory.Category.{v₄, u₄} C\nL : CategoryTheory.Functor A T\nF : CategoryTheory.Functor C B\nR : CategoryTheory.Functor B T\ninst✝ : F.Full\n⊢ (CategoryTheory.Comma.preRight L F R).Full","decl":"instance (L : A ⥤ T) (F : C ⥤ B) (R : B ⥤ T) [F.Full] : (preRight L F R).Full :=\n  Functor.Full.of_iso (preRightIso L F R).symm\n\n"}
{"name":"CategoryTheory.Comma.instEssSurjCompPreRight","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝² : CategoryTheory.Category.{v₃, u₃} T\nC : Type u₄\ninst✝¹ : CategoryTheory.Category.{v₄, u₄} C\nL : CategoryTheory.Functor A T\nF : CategoryTheory.Functor C B\nR : CategoryTheory.Functor B T\ninst✝ : F.EssSurj\n⊢ (CategoryTheory.Comma.preRight L F R).EssSurj","decl":"instance (L : A ⥤ T) (F : C ⥤ B) (R : B ⥤ T) [F.EssSurj] : (preRight L F R).EssSurj :=\n  Functor.essSurj_of_iso (preRightIso L F R).symm\n\n"}
{"name":"CategoryTheory.Comma.isEquivalence_preRight","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝² : CategoryTheory.Category.{v₃, u₃} T\nC : Type u₄\ninst✝¹ : CategoryTheory.Category.{v₄, u₄} C\nL : CategoryTheory.Functor A T\nF : CategoryTheory.Functor C B\nR : CategoryTheory.Functor B T\ninst✝ : F.IsEquivalence\n⊢ (CategoryTheory.Comma.preRight L F R).IsEquivalence","decl":"/-- If `F` is an equivalence, then so is `preRight L F R`. -/\ninstance isEquivalence_preRight (L : A ⥤ T) (F : C ⥤ B) (R : B ⥤ T) [F.IsEquivalence] :\n    (preRight L F R).IsEquivalence where\n\n"}
{"name":"CategoryTheory.Comma.post_map_left","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} T\nC : Type u₄\ninst✝ : CategoryTheory.Category.{v₄, u₄} C\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nF : CategoryTheory.Functor T C\nX✝ Y✝ : CategoryTheory.Comma L R\nf : Quiver.Hom X✝ Y✝\n⊢ Eq ((CategoryTheory.Comma.post L R F).map f).left f.left","decl":"/-- The functor `(L, R) ⥤ (L ⋙ F, R ⋙ F)` -/\n@[simps]\ndef post (L : A ⥤ T) (R : B ⥤ T) (F : T ⥤ C) : Comma L R ⥤ Comma (L ⋙ F) (R ⋙ F) where\n  obj X :=\n    { left := X.left\n      right := X.right\n      hom := F.map X.hom }\n  map f :=\n    { left := f.left\n      right := f.right\n      w := by simp only [Functor.comp_map, ← F.map_comp, f.w] }\n\n"}
{"name":"CategoryTheory.Comma.post_obj_hom","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} T\nC : Type u₄\ninst✝ : CategoryTheory.Category.{v₄, u₄} C\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nF : CategoryTheory.Functor T C\nX : CategoryTheory.Comma L R\n⊢ Eq ((CategoryTheory.Comma.post L R F).obj X).hom (F.map X.hom)","decl":"/-- The functor `(L, R) ⥤ (L ⋙ F, R ⋙ F)` -/\n@[simps]\ndef post (L : A ⥤ T) (R : B ⥤ T) (F : T ⥤ C) : Comma L R ⥤ Comma (L ⋙ F) (R ⋙ F) where\n  obj X :=\n    { left := X.left\n      right := X.right\n      hom := F.map X.hom }\n  map f :=\n    { left := f.left\n      right := f.right\n      w := by simp only [Functor.comp_map, ← F.map_comp, f.w] }\n\n"}
{"name":"CategoryTheory.Comma.post_map_right","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} T\nC : Type u₄\ninst✝ : CategoryTheory.Category.{v₄, u₄} C\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nF : CategoryTheory.Functor T C\nX✝ Y✝ : CategoryTheory.Comma L R\nf : Quiver.Hom X✝ Y✝\n⊢ Eq ((CategoryTheory.Comma.post L R F).map f).right f.right","decl":"/-- The functor `(L, R) ⥤ (L ⋙ F, R ⋙ F)` -/\n@[simps]\ndef post (L : A ⥤ T) (R : B ⥤ T) (F : T ⥤ C) : Comma L R ⥤ Comma (L ⋙ F) (R ⋙ F) where\n  obj X :=\n    { left := X.left\n      right := X.right\n      hom := F.map X.hom }\n  map f :=\n    { left := f.left\n      right := f.right\n      w := by simp only [Functor.comp_map, ← F.map_comp, f.w] }\n\n"}
{"name":"CategoryTheory.Comma.post_obj_right","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} T\nC : Type u₄\ninst✝ : CategoryTheory.Category.{v₄, u₄} C\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nF : CategoryTheory.Functor T C\nX : CategoryTheory.Comma L R\n⊢ Eq ((CategoryTheory.Comma.post L R F).obj X).right X.right","decl":"/-- The functor `(L, R) ⥤ (L ⋙ F, R ⋙ F)` -/\n@[simps]\ndef post (L : A ⥤ T) (R : B ⥤ T) (F : T ⥤ C) : Comma L R ⥤ Comma (L ⋙ F) (R ⋙ F) where\n  obj X :=\n    { left := X.left\n      right := X.right\n      hom := F.map X.hom }\n  map f :=\n    { left := f.left\n      right := f.right\n      w := by simp only [Functor.comp_map, ← F.map_comp, f.w] }\n\n"}
{"name":"CategoryTheory.Comma.post_obj_left","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} T\nC : Type u₄\ninst✝ : CategoryTheory.Category.{v₄, u₄} C\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nF : CategoryTheory.Functor T C\nX : CategoryTheory.Comma L R\n⊢ Eq ((CategoryTheory.Comma.post L R F).obj X).left X.left","decl":"/-- The functor `(L, R) ⥤ (L ⋙ F, R ⋙ F)` -/\n@[simps]\ndef post (L : A ⥤ T) (R : B ⥤ T) (F : T ⥤ C) : Comma L R ⥤ Comma (L ⋙ F) (R ⋙ F) where\n  obj X :=\n    { left := X.left\n      right := X.right\n      hom := F.map X.hom }\n  map f :=\n    { left := f.left\n      right := f.right\n      w := by simp only [Functor.comp_map, ← F.map_comp, f.w] }\n\n"}
{"name":"CategoryTheory.Comma.instFaithfulCompPost","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} T\nC : Type u₄\ninst✝ : CategoryTheory.Category.{v₄, u₄} C\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nF : CategoryTheory.Functor T C\n⊢ (CategoryTheory.Comma.post L R F).Faithful","decl":"instance (L : A ⥤ T) (R : B ⥤ T) (F : T ⥤ C) : (post L R F).Faithful :=\n  Functor.Faithful.of_iso (postIso L R F).symm\n\n"}
{"name":"CategoryTheory.Comma.instFullCompPostOfFaithful","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝² : CategoryTheory.Category.{v₃, u₃} T\nC : Type u₄\ninst✝¹ : CategoryTheory.Category.{v₄, u₄} C\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nF : CategoryTheory.Functor T C\ninst✝ : F.Faithful\n⊢ (CategoryTheory.Comma.post L R F).Full","decl":"instance (L : A ⥤ T) (R : B ⥤ T) (F : T ⥤ C) [F.Faithful] : (post L R F).Full :=\n  Functor.Full.of_iso (postIso L R F).symm\n\n"}
{"name":"CategoryTheory.Comma.instEssSurjCompPostOfFull","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝² : CategoryTheory.Category.{v₃, u₃} T\nC : Type u₄\ninst✝¹ : CategoryTheory.Category.{v₄, u₄} C\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nF : CategoryTheory.Functor T C\ninst✝ : F.Full\n⊢ (CategoryTheory.Comma.post L R F).EssSurj","decl":"instance (L : A ⥤ T) (R : B ⥤ T) (F : T ⥤ C) [F.Full] : (post L R F).EssSurj :=\n  Functor.essSurj_of_iso (postIso L R F).symm\n\n"}
{"name":"CategoryTheory.Comma.isEquivalence_post","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝² : CategoryTheory.Category.{v₃, u₃} T\nC : Type u₄\ninst✝¹ : CategoryTheory.Category.{v₄, u₄} C\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nF : CategoryTheory.Functor T C\ninst✝ : F.IsEquivalence\n⊢ (CategoryTheory.Comma.post L R F).IsEquivalence","decl":"/-- If `F` is an equivalence, then so is `post L R F`. -/\ninstance isEquivalence_post (L : A ⥤ T) (R : B ⥤ T) (F : T ⥤ C) [F.IsEquivalence] :\n    (post L R F).IsEquivalence where\n\n"}
{"name":"CategoryTheory.Comma.fromProd_map_right","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} B\nL : CategoryTheory.Functor A (CategoryTheory.Discrete PUnit.{u_1 + 1})\nR : CategoryTheory.Functor B (CategoryTheory.Discrete PUnit.{u_1 + 1})\nX Y : Prod A B\nf : Quiver.Hom X Y\n⊢ Eq ((CategoryTheory.Comma.fromProd L R).map f).right f.2","decl":"/-- The canonical functor from the product of two categories to the comma category of their\nrespective functors into `Discrete PUnit`. -/\n@[simps]\ndef fromProd (L : A ⥤ Discrete PUnit) (R : B ⥤ Discrete PUnit) :\n    A × B ⥤ Comma L R where\n  obj X :=\n    { left := X.1\n      right := X.2\n      hom := Discrete.eqToHom rfl }\n  map {X} {Y} f :=\n    { left := f.1\n      right := f.2 }\n\n"}
{"name":"CategoryTheory.Comma.fromProd_map_left","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} B\nL : CategoryTheory.Functor A (CategoryTheory.Discrete PUnit.{u_1 + 1})\nR : CategoryTheory.Functor B (CategoryTheory.Discrete PUnit.{u_1 + 1})\nX Y : Prod A B\nf : Quiver.Hom X Y\n⊢ Eq ((CategoryTheory.Comma.fromProd L R).map f).left f.1","decl":"/-- The canonical functor from the product of two categories to the comma category of their\nrespective functors into `Discrete PUnit`. -/\n@[simps]\ndef fromProd (L : A ⥤ Discrete PUnit) (R : B ⥤ Discrete PUnit) :\n    A × B ⥤ Comma L R where\n  obj X :=\n    { left := X.1\n      right := X.2\n      hom := Discrete.eqToHom rfl }\n  map {X} {Y} f :=\n    { left := f.1\n      right := f.2 }\n\n"}
{"name":"CategoryTheory.Comma.fromProd_obj_right","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} B\nL : CategoryTheory.Functor A (CategoryTheory.Discrete PUnit.{u_1 + 1})\nR : CategoryTheory.Functor B (CategoryTheory.Discrete PUnit.{u_1 + 1})\nX : Prod A B\n⊢ Eq ((CategoryTheory.Comma.fromProd L R).obj X).right X.2","decl":"/-- The canonical functor from the product of two categories to the comma category of their\nrespective functors into `Discrete PUnit`. -/\n@[simps]\ndef fromProd (L : A ⥤ Discrete PUnit) (R : B ⥤ Discrete PUnit) :\n    A × B ⥤ Comma L R where\n  obj X :=\n    { left := X.1\n      right := X.2\n      hom := Discrete.eqToHom rfl }\n  map {X} {Y} f :=\n    { left := f.1\n      right := f.2 }\n\n"}
{"name":"CategoryTheory.Comma.fromProd_obj_hom","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} B\nL : CategoryTheory.Functor A (CategoryTheory.Discrete PUnit.{u_1 + 1})\nR : CategoryTheory.Functor B (CategoryTheory.Discrete PUnit.{u_1 + 1})\nX : Prod A B\n⊢ Eq ((CategoryTheory.Comma.fromProd L R).obj X).hom (CategoryTheory.Discrete.eqToHom ⋯)","decl":"/-- The canonical functor from the product of two categories to the comma category of their\nrespective functors into `Discrete PUnit`. -/\n@[simps]\ndef fromProd (L : A ⥤ Discrete PUnit) (R : B ⥤ Discrete PUnit) :\n    A × B ⥤ Comma L R where\n  obj X :=\n    { left := X.1\n      right := X.2\n      hom := Discrete.eqToHom rfl }\n  map {X} {Y} f :=\n    { left := f.1\n      right := f.2 }\n\n"}
{"name":"CategoryTheory.Comma.fromProd_obj_left","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} B\nL : CategoryTheory.Functor A (CategoryTheory.Discrete PUnit.{u_1 + 1})\nR : CategoryTheory.Functor B (CategoryTheory.Discrete PUnit.{u_1 + 1})\nX : Prod A B\n⊢ Eq ((CategoryTheory.Comma.fromProd L R).obj X).left X.1","decl":"/-- The canonical functor from the product of two categories to the comma category of their\nrespective functors into `Discrete PUnit`. -/\n@[simps]\ndef fromProd (L : A ⥤ Discrete PUnit) (R : B ⥤ Discrete PUnit) :\n    A × B ⥤ Comma L R where\n  obj X :=\n    { left := X.1\n      right := X.2\n      hom := Discrete.eqToHom rfl }\n  map {X} {Y} f :=\n    { left := f.1\n      right := f.2 }\n\n"}
{"name":"CategoryTheory.Comma.equivProd_unitIso_hom_app_right","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} B\nL : CategoryTheory.Functor A (CategoryTheory.Discrete PUnit.{u_1 + 1})\nR : CategoryTheory.Functor B (CategoryTheory.Discrete PUnit.{u_1 + 1})\nX : CategoryTheory.Comma L R\n⊢ Eq ((CategoryTheory.Comma.equivProd L R).unitIso.hom.app X).right (CategoryTheory.CategoryStruct.id X.right)","decl":"/-- Taking the comma category of two functors into `Discrete PUnit` results in something\nis equivalent to their product. -/\n@[simps!]\ndef equivProd (L : A ⥤ Discrete PUnit) (R : B ⥤ Discrete PUnit) :\n    Comma L R ≌ A × B where\n  functor := (fst L R).prod' (snd L R)\n  inverse := fromProd L R\n  unitIso := Iso.refl _\n  counitIso := Iso.refl _\n\n"}
{"name":"CategoryTheory.Comma.equivProd_unitIso_inv_app_left","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} B\nL : CategoryTheory.Functor A (CategoryTheory.Discrete PUnit.{u_1 + 1})\nR : CategoryTheory.Functor B (CategoryTheory.Discrete PUnit.{u_1 + 1})\nX : CategoryTheory.Comma L R\n⊢ Eq ((CategoryTheory.Comma.equivProd L R).unitIso.inv.app X).left (CategoryTheory.CategoryStruct.id X.left)","decl":"/-- Taking the comma category of two functors into `Discrete PUnit` results in something\nis equivalent to their product. -/\n@[simps!]\ndef equivProd (L : A ⥤ Discrete PUnit) (R : B ⥤ Discrete PUnit) :\n    Comma L R ≌ A × B where\n  functor := (fst L R).prod' (snd L R)\n  inverse := fromProd L R\n  unitIso := Iso.refl _\n  counitIso := Iso.refl _\n\n"}
{"name":"CategoryTheory.Comma.equivProd_counitIso_inv_app","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} B\nL : CategoryTheory.Functor A (CategoryTheory.Discrete PUnit.{u_1 + 1})\nR : CategoryTheory.Functor B (CategoryTheory.Discrete PUnit.{u_1 + 1})\nX : Prod A B\n⊢ Eq ((CategoryTheory.Comma.equivProd L R).counitIso.inv.app X) { fst := CategoryTheory.CategoryStruct.id X.1, snd := CategoryTheory.CategoryStruct.id X.2 }","decl":"/-- Taking the comma category of two functors into `Discrete PUnit` results in something\nis equivalent to their product. -/\n@[simps!]\ndef equivProd (L : A ⥤ Discrete PUnit) (R : B ⥤ Discrete PUnit) :\n    Comma L R ≌ A × B where\n  functor := (fst L R).prod' (snd L R)\n  inverse := fromProd L R\n  unitIso := Iso.refl _\n  counitIso := Iso.refl _\n\n"}
{"name":"CategoryTheory.Comma.equivProd_functor_obj","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} B\nL : CategoryTheory.Functor A (CategoryTheory.Discrete PUnit.{u_1 + 1})\nR : CategoryTheory.Functor B (CategoryTheory.Discrete PUnit.{u_1 + 1})\na : CategoryTheory.Comma L R\n⊢ Eq ((CategoryTheory.Comma.equivProd L R).functor.obj a) { fst := a.left, snd := a.right }","decl":"/-- Taking the comma category of two functors into `Discrete PUnit` results in something\nis equivalent to their product. -/\n@[simps!]\ndef equivProd (L : A ⥤ Discrete PUnit) (R : B ⥤ Discrete PUnit) :\n    Comma L R ≌ A × B where\n  functor := (fst L R).prod' (snd L R)\n  inverse := fromProd L R\n  unitIso := Iso.refl _\n  counitIso := Iso.refl _\n\n"}
{"name":"CategoryTheory.Comma.equivProd_functor_map","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} B\nL : CategoryTheory.Functor A (CategoryTheory.Discrete PUnit.{u_1 + 1})\nR : CategoryTheory.Functor B (CategoryTheory.Discrete PUnit.{u_1 + 1})\nX✝ Y✝ : CategoryTheory.Comma L R\nf : Quiver.Hom X✝ Y✝\n⊢ Eq ((CategoryTheory.Comma.equivProd L R).functor.map f) { fst := f.left, snd := f.right }","decl":"/-- Taking the comma category of two functors into `Discrete PUnit` results in something\nis equivalent to their product. -/\n@[simps!]\ndef equivProd (L : A ⥤ Discrete PUnit) (R : B ⥤ Discrete PUnit) :\n    Comma L R ≌ A × B where\n  functor := (fst L R).prod' (snd L R)\n  inverse := fromProd L R\n  unitIso := Iso.refl _\n  counitIso := Iso.refl _\n\n"}
{"name":"CategoryTheory.Comma.equivProd_inverse_obj_left","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} B\nL : CategoryTheory.Functor A (CategoryTheory.Discrete PUnit.{u_1 + 1})\nR : CategoryTheory.Functor B (CategoryTheory.Discrete PUnit.{u_1 + 1})\nX : Prod A B\n⊢ Eq ((CategoryTheory.Comma.equivProd L R).inverse.obj X).left X.1","decl":"/-- Taking the comma category of two functors into `Discrete PUnit` results in something\nis equivalent to their product. -/\n@[simps!]\ndef equivProd (L : A ⥤ Discrete PUnit) (R : B ⥤ Discrete PUnit) :\n    Comma L R ≌ A × B where\n  functor := (fst L R).prod' (snd L R)\n  inverse := fromProd L R\n  unitIso := Iso.refl _\n  counitIso := Iso.refl _\n\n"}
{"name":"CategoryTheory.Comma.equivProd_inverse_obj_hom_down_down","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} B\nL : CategoryTheory.Functor A (CategoryTheory.Discrete PUnit.{u_1 + 1})\nR : CategoryTheory.Functor B (CategoryTheory.Discrete PUnit.{u_1 + 1})\nX : Prod A B\n⊢ Eq ⋯ ⋯","decl":"/-- Taking the comma category of two functors into `Discrete PUnit` results in something\nis equivalent to their product. -/\n@[simps!]\ndef equivProd (L : A ⥤ Discrete PUnit) (R : B ⥤ Discrete PUnit) :\n    Comma L R ≌ A × B where\n  functor := (fst L R).prod' (snd L R)\n  inverse := fromProd L R\n  unitIso := Iso.refl _\n  counitIso := Iso.refl _\n\n"}
{"name":"CategoryTheory.Comma.equivProd_counitIso_hom_app","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} B\nL : CategoryTheory.Functor A (CategoryTheory.Discrete PUnit.{u_1 + 1})\nR : CategoryTheory.Functor B (CategoryTheory.Discrete PUnit.{u_1 + 1})\nX : Prod A B\n⊢ Eq ((CategoryTheory.Comma.equivProd L R).counitIso.hom.app X) { fst := CategoryTheory.CategoryStruct.id X.1, snd := CategoryTheory.CategoryStruct.id X.2 }","decl":"/-- Taking the comma category of two functors into `Discrete PUnit` results in something\nis equivalent to their product. -/\n@[simps!]\ndef equivProd (L : A ⥤ Discrete PUnit) (R : B ⥤ Discrete PUnit) :\n    Comma L R ≌ A × B where\n  functor := (fst L R).prod' (snd L R)\n  inverse := fromProd L R\n  unitIso := Iso.refl _\n  counitIso := Iso.refl _\n\n"}
{"name":"CategoryTheory.Comma.equivProd_unitIso_hom_app_left","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} B\nL : CategoryTheory.Functor A (CategoryTheory.Discrete PUnit.{u_1 + 1})\nR : CategoryTheory.Functor B (CategoryTheory.Discrete PUnit.{u_1 + 1})\nX : CategoryTheory.Comma L R\n⊢ Eq ((CategoryTheory.Comma.equivProd L R).unitIso.hom.app X).left (CategoryTheory.CategoryStruct.id X.left)","decl":"/-- Taking the comma category of two functors into `Discrete PUnit` results in something\nis equivalent to their product. -/\n@[simps!]\ndef equivProd (L : A ⥤ Discrete PUnit) (R : B ⥤ Discrete PUnit) :\n    Comma L R ≌ A × B where\n  functor := (fst L R).prod' (snd L R)\n  inverse := fromProd L R\n  unitIso := Iso.refl _\n  counitIso := Iso.refl _\n\n"}
{"name":"CategoryTheory.Comma.equivProd_inverse_map_left","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} B\nL : CategoryTheory.Functor A (CategoryTheory.Discrete PUnit.{u_1 + 1})\nR : CategoryTheory.Functor B (CategoryTheory.Discrete PUnit.{u_1 + 1})\nX Y : Prod A B\nf : Quiver.Hom X Y\n⊢ Eq ((CategoryTheory.Comma.equivProd L R).inverse.map f).left f.1","decl":"/-- Taking the comma category of two functors into `Discrete PUnit` results in something\nis equivalent to their product. -/\n@[simps!]\ndef equivProd (L : A ⥤ Discrete PUnit) (R : B ⥤ Discrete PUnit) :\n    Comma L R ≌ A × B where\n  functor := (fst L R).prod' (snd L R)\n  inverse := fromProd L R\n  unitIso := Iso.refl _\n  counitIso := Iso.refl _\n\n"}
{"name":"CategoryTheory.Comma.equivProd_unitIso_inv_app_right","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} B\nL : CategoryTheory.Functor A (CategoryTheory.Discrete PUnit.{u_1 + 1})\nR : CategoryTheory.Functor B (CategoryTheory.Discrete PUnit.{u_1 + 1})\nX : CategoryTheory.Comma L R\n⊢ Eq ((CategoryTheory.Comma.equivProd L R).unitIso.inv.app X).right (CategoryTheory.CategoryStruct.id X.right)","decl":"/-- Taking the comma category of two functors into `Discrete PUnit` results in something\nis equivalent to their product. -/\n@[simps!]\ndef equivProd (L : A ⥤ Discrete PUnit) (R : B ⥤ Discrete PUnit) :\n    Comma L R ≌ A × B where\n  functor := (fst L R).prod' (snd L R)\n  inverse := fromProd L R\n  unitIso := Iso.refl _\n  counitIso := Iso.refl _\n\n"}
{"name":"CategoryTheory.Comma.equivProd_inverse_obj_right","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} B\nL : CategoryTheory.Functor A (CategoryTheory.Discrete PUnit.{u_1 + 1})\nR : CategoryTheory.Functor B (CategoryTheory.Discrete PUnit.{u_1 + 1})\nX : Prod A B\n⊢ Eq ((CategoryTheory.Comma.equivProd L R).inverse.obj X).right X.2","decl":"/-- Taking the comma category of two functors into `Discrete PUnit` results in something\nis equivalent to their product. -/\n@[simps!]\ndef equivProd (L : A ⥤ Discrete PUnit) (R : B ⥤ Discrete PUnit) :\n    Comma L R ≌ A × B where\n  functor := (fst L R).prod' (snd L R)\n  inverse := fromProd L R\n  unitIso := Iso.refl _\n  counitIso := Iso.refl _\n\n"}
{"name":"CategoryTheory.Comma.equivProd_inverse_map_right","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} B\nL : CategoryTheory.Functor A (CategoryTheory.Discrete PUnit.{u_1 + 1})\nR : CategoryTheory.Functor B (CategoryTheory.Discrete PUnit.{u_1 + 1})\nX Y : Prod A B\nf : Quiver.Hom X Y\n⊢ Eq ((CategoryTheory.Comma.equivProd L R).inverse.map f).right f.2","decl":"/-- Taking the comma category of two functors into `Discrete PUnit` results in something\nis equivalent to their product. -/\n@[simps!]\ndef equivProd (L : A ⥤ Discrete PUnit) (R : B ⥤ Discrete PUnit) :\n    Comma L R ≌ A × B where\n  functor := (fst L R).prod' (snd L R)\n  inverse := fromProd L R\n  unitIso := Iso.refl _\n  counitIso := Iso.refl _\n\n"}
{"name":"CategoryTheory.Comma.toPUnitIdEquiv_unitIso_inv_app_left","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} A\nL : CategoryTheory.Functor A (CategoryTheory.Discrete PUnit.{u_1 + 1})\nR : CategoryTheory.Functor (CategoryTheory.Discrete PUnit.{u_2 + 1}) (CategoryTheory.Discrete PUnit.{u_1 + 1})\nX : CategoryTheory.Comma L R\n⊢ Eq ((CategoryTheory.Comma.toPUnitIdEquiv L R).unitIso.inv.app X).left (CategoryTheory.CategoryStruct.id X.left)","decl":"/-- Taking the comma category of a functor into `A ⥤ Discrete PUnit` and the identity\n`Discrete PUnit ⥤ Discrete PUnit` results in a category equivalent to `A`. -/\n@[simps!]\ndef toPUnitIdEquiv (L : A ⥤ Discrete PUnit) (R : Discrete PUnit ⥤ Discrete PUnit) :\n    Comma L R ≌ A :=\n  (equivProd L _).trans (prod.rightUnitorEquivalence A)\n\n"}
{"name":"CategoryTheory.Comma.toPUnitIdEquiv_functor_obj","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} A\nL : CategoryTheory.Functor A (CategoryTheory.Discrete PUnit.{u_1 + 1})\nR : CategoryTheory.Functor (CategoryTheory.Discrete PUnit.{u_2 + 1}) (CategoryTheory.Discrete PUnit.{u_1 + 1})\nX : CategoryTheory.Comma L R\n⊢ Eq ((CategoryTheory.Comma.toPUnitIdEquiv L R).functor.obj X) X.left","decl":"/-- Taking the comma category of a functor into `A ⥤ Discrete PUnit` and the identity\n`Discrete PUnit ⥤ Discrete PUnit` results in a category equivalent to `A`. -/\n@[simps!]\ndef toPUnitIdEquiv (L : A ⥤ Discrete PUnit) (R : Discrete PUnit ⥤ Discrete PUnit) :\n    Comma L R ≌ A :=\n  (equivProd L _).trans (prod.rightUnitorEquivalence A)\n\n"}
{"name":"CategoryTheory.Comma.toPUnitIdEquiv_unitIso_hom_app_left","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} A\nL : CategoryTheory.Functor A (CategoryTheory.Discrete PUnit.{u_1 + 1})\nR : CategoryTheory.Functor (CategoryTheory.Discrete PUnit.{u_2 + 1}) (CategoryTheory.Discrete PUnit.{u_1 + 1})\nX : CategoryTheory.Comma L R\n⊢ Eq ((CategoryTheory.Comma.toPUnitIdEquiv L R).unitIso.hom.app X).left (CategoryTheory.CategoryStruct.id X.left)","decl":"/-- Taking the comma category of a functor into `A ⥤ Discrete PUnit` and the identity\n`Discrete PUnit ⥤ Discrete PUnit` results in a category equivalent to `A`. -/\n@[simps!]\ndef toPUnitIdEquiv (L : A ⥤ Discrete PUnit) (R : Discrete PUnit ⥤ Discrete PUnit) :\n    Comma L R ≌ A :=\n  (equivProd L _).trans (prod.rightUnitorEquivalence A)\n\n"}
{"name":"CategoryTheory.Comma.toPUnitIdEquiv_inverse_obj_hom_down_down","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} A\nL : CategoryTheory.Functor A (CategoryTheory.Discrete PUnit.{u_1 + 1})\nR : CategoryTheory.Functor (CategoryTheory.Discrete PUnit.{u_2 + 1}) (CategoryTheory.Discrete PUnit.{u_1 + 1})\nX : A\n⊢ Eq ⋯ ⋯","decl":"/-- Taking the comma category of a functor into `A ⥤ Discrete PUnit` and the identity\n`Discrete PUnit ⥤ Discrete PUnit` results in a category equivalent to `A`. -/\n@[simps!]\ndef toPUnitIdEquiv (L : A ⥤ Discrete PUnit) (R : Discrete PUnit ⥤ Discrete PUnit) :\n    Comma L R ≌ A :=\n  (equivProd L _).trans (prod.rightUnitorEquivalence A)\n\n"}
{"name":"CategoryTheory.Comma.toPUnitIdEquiv_inverse_map_right_down_down","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} A\nL : CategoryTheory.Functor A (CategoryTheory.Discrete PUnit.{u_1 + 1})\nR : CategoryTheory.Functor (CategoryTheory.Discrete PUnit.{u_2 + 1}) (CategoryTheory.Discrete PUnit.{u_1 + 1})\nX✝ Y✝ : A\nf : Quiver.Hom X✝ Y✝\n⊢ Eq ⋯ ⋯","decl":"/-- Taking the comma category of a functor into `A ⥤ Discrete PUnit` and the identity\n`Discrete PUnit ⥤ Discrete PUnit` results in a category equivalent to `A`. -/\n@[simps!]\ndef toPUnitIdEquiv (L : A ⥤ Discrete PUnit) (R : Discrete PUnit ⥤ Discrete PUnit) :\n    Comma L R ≌ A :=\n  (equivProd L _).trans (prod.rightUnitorEquivalence A)\n\n"}
{"name":"CategoryTheory.Comma.toPUnitIdEquiv_unitIso_inv_app_right_down_down","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} A\nL : CategoryTheory.Functor A (CategoryTheory.Discrete PUnit.{u_1 + 1})\nR : CategoryTheory.Functor (CategoryTheory.Discrete PUnit.{u_2 + 1}) (CategoryTheory.Discrete PUnit.{u_1 + 1})\nX : CategoryTheory.Comma L R\n⊢ Eq ⋯ ⋯","decl":"/-- Taking the comma category of a functor into `A ⥤ Discrete PUnit` and the identity\n`Discrete PUnit ⥤ Discrete PUnit` results in a category equivalent to `A`. -/\n@[simps!]\ndef toPUnitIdEquiv (L : A ⥤ Discrete PUnit) (R : Discrete PUnit ⥤ Discrete PUnit) :\n    Comma L R ≌ A :=\n  (equivProd L _).trans (prod.rightUnitorEquivalence A)\n\n"}
{"name":"CategoryTheory.Comma.toPUnitIdEquiv_inverse_obj_right_as","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} A\nL : CategoryTheory.Functor A (CategoryTheory.Discrete PUnit.{u_1 + 1})\nR : CategoryTheory.Functor (CategoryTheory.Discrete PUnit.{u_2 + 1}) (CategoryTheory.Discrete PUnit.{u_1 + 1})\nX : A\n⊢ Eq ((CategoryTheory.Comma.toPUnitIdEquiv L R).inverse.obj X).right.as PUnit.unit","decl":"/-- Taking the comma category of a functor into `A ⥤ Discrete PUnit` and the identity\n`Discrete PUnit ⥤ Discrete PUnit` results in a category equivalent to `A`. -/\n@[simps!]\ndef toPUnitIdEquiv (L : A ⥤ Discrete PUnit) (R : Discrete PUnit ⥤ Discrete PUnit) :\n    Comma L R ≌ A :=\n  (equivProd L _).trans (prod.rightUnitorEquivalence A)\n\n"}
{"name":"CategoryTheory.Comma.toPUnitIdEquiv_inverse_map_left","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} A\nL : CategoryTheory.Functor A (CategoryTheory.Discrete PUnit.{u_1 + 1})\nR : CategoryTheory.Functor (CategoryTheory.Discrete PUnit.{u_2 + 1}) (CategoryTheory.Discrete PUnit.{u_1 + 1})\nX✝ Y✝ : A\nf : Quiver.Hom X✝ Y✝\n⊢ Eq ((CategoryTheory.Comma.toPUnitIdEquiv L R).inverse.map f).left f","decl":"/-- Taking the comma category of a functor into `A ⥤ Discrete PUnit` and the identity\n`Discrete PUnit ⥤ Discrete PUnit` results in a category equivalent to `A`. -/\n@[simps!]\ndef toPUnitIdEquiv (L : A ⥤ Discrete PUnit) (R : Discrete PUnit ⥤ Discrete PUnit) :\n    Comma L R ≌ A :=\n  (equivProd L _).trans (prod.rightUnitorEquivalence A)\n\n"}
{"name":"CategoryTheory.Comma.toPUnitIdEquiv_functor_map","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} A\nL : CategoryTheory.Functor A (CategoryTheory.Discrete PUnit.{u_1 + 1})\nR : CategoryTheory.Functor (CategoryTheory.Discrete PUnit.{u_2 + 1}) (CategoryTheory.Discrete PUnit.{u_1 + 1})\nX✝ Y✝ : CategoryTheory.Comma L R\nf : Quiver.Hom X✝ Y✝\n⊢ Eq ((CategoryTheory.Comma.toPUnitIdEquiv L R).functor.map f) f.left","decl":"/-- Taking the comma category of a functor into `A ⥤ Discrete PUnit` and the identity\n`Discrete PUnit ⥤ Discrete PUnit` results in a category equivalent to `A`. -/\n@[simps!]\ndef toPUnitIdEquiv (L : A ⥤ Discrete PUnit) (R : Discrete PUnit ⥤ Discrete PUnit) :\n    Comma L R ≌ A :=\n  (equivProd L _).trans (prod.rightUnitorEquivalence A)\n\n"}
{"name":"CategoryTheory.Comma.toPUnitIdEquiv_unitIso_hom_app_right_down_down","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} A\nL : CategoryTheory.Functor A (CategoryTheory.Discrete PUnit.{u_1 + 1})\nR : CategoryTheory.Functor (CategoryTheory.Discrete PUnit.{u_2 + 1}) (CategoryTheory.Discrete PUnit.{u_1 + 1})\nX : CategoryTheory.Comma L R\n⊢ Eq ⋯ ⋯","decl":"/-- Taking the comma category of a functor into `A ⥤ Discrete PUnit` and the identity\n`Discrete PUnit ⥤ Discrete PUnit` results in a category equivalent to `A`. -/\n@[simps!]\ndef toPUnitIdEquiv (L : A ⥤ Discrete PUnit) (R : Discrete PUnit ⥤ Discrete PUnit) :\n    Comma L R ≌ A :=\n  (equivProd L _).trans (prod.rightUnitorEquivalence A)\n\n"}
{"name":"CategoryTheory.Comma.toPUnitIdEquiv_inverse_obj_left","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} A\nL : CategoryTheory.Functor A (CategoryTheory.Discrete PUnit.{u_1 + 1})\nR : CategoryTheory.Functor (CategoryTheory.Discrete PUnit.{u_2 + 1}) (CategoryTheory.Discrete PUnit.{u_1 + 1})\nX : A\n⊢ Eq ((CategoryTheory.Comma.toPUnitIdEquiv L R).inverse.obj X).left X","decl":"/-- Taking the comma category of a functor into `A ⥤ Discrete PUnit` and the identity\n`Discrete PUnit ⥤ Discrete PUnit` results in a category equivalent to `A`. -/\n@[simps!]\ndef toPUnitIdEquiv (L : A ⥤ Discrete PUnit) (R : Discrete PUnit ⥤ Discrete PUnit) :\n    Comma L R ≌ A :=\n  (equivProd L _).trans (prod.rightUnitorEquivalence A)\n\n"}
{"name":"CategoryTheory.Comma.toPUnitIdEquiv_counitIso_hom_app","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} A\nL : CategoryTheory.Functor A (CategoryTheory.Discrete PUnit.{u_1 + 1})\nR : CategoryTheory.Functor (CategoryTheory.Discrete PUnit.{u_2 + 1}) (CategoryTheory.Discrete PUnit.{u_1 + 1})\nX : A\n⊢ Eq ((CategoryTheory.Comma.toPUnitIdEquiv L R).counitIso.hom.app X) (CategoryTheory.CategoryStruct.id X)","decl":"/-- Taking the comma category of a functor into `A ⥤ Discrete PUnit` and the identity\n`Discrete PUnit ⥤ Discrete PUnit` results in a category equivalent to `A`. -/\n@[simps!]\ndef toPUnitIdEquiv (L : A ⥤ Discrete PUnit) (R : Discrete PUnit ⥤ Discrete PUnit) :\n    Comma L R ≌ A :=\n  (equivProd L _).trans (prod.rightUnitorEquivalence A)\n\n"}
{"name":"CategoryTheory.Comma.toPUnitIdEquiv_counitIso_inv_app","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} A\nL : CategoryTheory.Functor A (CategoryTheory.Discrete PUnit.{u_1 + 1})\nR : CategoryTheory.Functor (CategoryTheory.Discrete PUnit.{u_2 + 1}) (CategoryTheory.Discrete PUnit.{u_1 + 1})\nX : A\n⊢ Eq ((CategoryTheory.Comma.toPUnitIdEquiv L R).counitIso.inv.app X) (CategoryTheory.CategoryStruct.id X)","decl":"/-- Taking the comma category of a functor into `A ⥤ Discrete PUnit` and the identity\n`Discrete PUnit ⥤ Discrete PUnit` results in a category equivalent to `A`. -/\n@[simps!]\ndef toPUnitIdEquiv (L : A ⥤ Discrete PUnit) (R : Discrete PUnit ⥤ Discrete PUnit) :\n    Comma L R ≌ A :=\n  (equivProd L _).trans (prod.rightUnitorEquivalence A)\n\n"}
{"name":"CategoryTheory.Comma.toPUnitIdEquiv_functor_iso","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} A\nL : CategoryTheory.Functor A (CategoryTheory.Discrete PUnit.{u_1 + 1})\nR : CategoryTheory.Functor (CategoryTheory.Discrete PUnit.{u_2 + 1}) (CategoryTheory.Discrete PUnit.{u_1 + 1})\n⊢ Eq (CategoryTheory.Comma.toPUnitIdEquiv L R).functor (CategoryTheory.Comma.fst L R)","decl":"@[simp]\ntheorem toPUnitIdEquiv_functor_iso {L : A ⥤ Discrete PUnit}\n    {R : Discrete PUnit ⥤ Discrete PUnit} :\n    (toPUnitIdEquiv L R).functor = fst L R :=\n  rfl\n\n"}
{"name":"CategoryTheory.Comma.toIdPUnitEquiv_counitIso_inv_app","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"B : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} B\nL : CategoryTheory.Functor (CategoryTheory.Discrete PUnit.{u_1 + 1}) (CategoryTheory.Discrete PUnit.{u_2 + 1})\nR : CategoryTheory.Functor B (CategoryTheory.Discrete PUnit.{u_2 + 1})\nX : B\n⊢ Eq ((CategoryTheory.Comma.toIdPUnitEquiv L R).counitIso.inv.app X) (CategoryTheory.CategoryStruct.id X)","decl":"/-- Taking the comma category of the identity `Discrete PUnit ⥤ Discrete PUnit`\nand a functor `B ⥤ Discrete PUnit` results in a category equivalent to `B`. -/\n@[simps!]\ndef toIdPUnitEquiv (L : Discrete PUnit ⥤ Discrete PUnit) (R : B ⥤ Discrete PUnit) :\n    Comma L R ≌ B :=\n  (equivProd _ R).trans (prod.leftUnitorEquivalence B)\n\n"}
{"name":"CategoryTheory.Comma.toIdPUnitEquiv_inverse_obj_left_as","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"B : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} B\nL : CategoryTheory.Functor (CategoryTheory.Discrete PUnit.{u_1 + 1}) (CategoryTheory.Discrete PUnit.{u_2 + 1})\nR : CategoryTheory.Functor B (CategoryTheory.Discrete PUnit.{u_2 + 1})\nX : B\n⊢ Eq ((CategoryTheory.Comma.toIdPUnitEquiv L R).inverse.obj X).left.as PUnit.unit","decl":"/-- Taking the comma category of the identity `Discrete PUnit ⥤ Discrete PUnit`\nand a functor `B ⥤ Discrete PUnit` results in a category equivalent to `B`. -/\n@[simps!]\ndef toIdPUnitEquiv (L : Discrete PUnit ⥤ Discrete PUnit) (R : B ⥤ Discrete PUnit) :\n    Comma L R ≌ B :=\n  (equivProd _ R).trans (prod.leftUnitorEquivalence B)\n\n"}
{"name":"CategoryTheory.Comma.toIdPUnitEquiv_functor_obj","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"B : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} B\nL : CategoryTheory.Functor (CategoryTheory.Discrete PUnit.{u_1 + 1}) (CategoryTheory.Discrete PUnit.{u_2 + 1})\nR : CategoryTheory.Functor B (CategoryTheory.Discrete PUnit.{u_2 + 1})\nX : CategoryTheory.Comma L R\n⊢ Eq ((CategoryTheory.Comma.toIdPUnitEquiv L R).functor.obj X) X.right","decl":"/-- Taking the comma category of the identity `Discrete PUnit ⥤ Discrete PUnit`\nand a functor `B ⥤ Discrete PUnit` results in a category equivalent to `B`. -/\n@[simps!]\ndef toIdPUnitEquiv (L : Discrete PUnit ⥤ Discrete PUnit) (R : B ⥤ Discrete PUnit) :\n    Comma L R ≌ B :=\n  (equivProd _ R).trans (prod.leftUnitorEquivalence B)\n\n"}
{"name":"CategoryTheory.Comma.toIdPUnitEquiv_unitIso_hom_app_left_down_down","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"B : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} B\nL : CategoryTheory.Functor (CategoryTheory.Discrete PUnit.{u_1 + 1}) (CategoryTheory.Discrete PUnit.{u_2 + 1})\nR : CategoryTheory.Functor B (CategoryTheory.Discrete PUnit.{u_2 + 1})\nX : CategoryTheory.Comma L R\n⊢ Eq ⋯ ⋯","decl":"/-- Taking the comma category of the identity `Discrete PUnit ⥤ Discrete PUnit`\nand a functor `B ⥤ Discrete PUnit` results in a category equivalent to `B`. -/\n@[simps!]\ndef toIdPUnitEquiv (L : Discrete PUnit ⥤ Discrete PUnit) (R : B ⥤ Discrete PUnit) :\n    Comma L R ≌ B :=\n  (equivProd _ R).trans (prod.leftUnitorEquivalence B)\n\n"}
{"name":"CategoryTheory.Comma.toIdPUnitEquiv_inverse_map_left_down_down","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"B : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} B\nL : CategoryTheory.Functor (CategoryTheory.Discrete PUnit.{u_1 + 1}) (CategoryTheory.Discrete PUnit.{u_2 + 1})\nR : CategoryTheory.Functor B (CategoryTheory.Discrete PUnit.{u_2 + 1})\nX✝ Y✝ : B\nf : Quiver.Hom X✝ Y✝\n⊢ Eq ⋯ ⋯","decl":"/-- Taking the comma category of the identity `Discrete PUnit ⥤ Discrete PUnit`\nand a functor `B ⥤ Discrete PUnit` results in a category equivalent to `B`. -/\n@[simps!]\ndef toIdPUnitEquiv (L : Discrete PUnit ⥤ Discrete PUnit) (R : B ⥤ Discrete PUnit) :\n    Comma L R ≌ B :=\n  (equivProd _ R).trans (prod.leftUnitorEquivalence B)\n\n"}
{"name":"CategoryTheory.Comma.toIdPUnitEquiv_inverse_obj_right","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"B : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} B\nL : CategoryTheory.Functor (CategoryTheory.Discrete PUnit.{u_1 + 1}) (CategoryTheory.Discrete PUnit.{u_2 + 1})\nR : CategoryTheory.Functor B (CategoryTheory.Discrete PUnit.{u_2 + 1})\nX : B\n⊢ Eq ((CategoryTheory.Comma.toIdPUnitEquiv L R).inverse.obj X).right X","decl":"/-- Taking the comma category of the identity `Discrete PUnit ⥤ Discrete PUnit`\nand a functor `B ⥤ Discrete PUnit` results in a category equivalent to `B`. -/\n@[simps!]\ndef toIdPUnitEquiv (L : Discrete PUnit ⥤ Discrete PUnit) (R : B ⥤ Discrete PUnit) :\n    Comma L R ≌ B :=\n  (equivProd _ R).trans (prod.leftUnitorEquivalence B)\n\n"}
{"name":"CategoryTheory.Comma.toIdPUnitEquiv_unitIso_inv_app_left_down_down","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"B : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} B\nL : CategoryTheory.Functor (CategoryTheory.Discrete PUnit.{u_1 + 1}) (CategoryTheory.Discrete PUnit.{u_2 + 1})\nR : CategoryTheory.Functor B (CategoryTheory.Discrete PUnit.{u_2 + 1})\nX : CategoryTheory.Comma L R\n⊢ Eq ⋯ ⋯","decl":"/-- Taking the comma category of the identity `Discrete PUnit ⥤ Discrete PUnit`\nand a functor `B ⥤ Discrete PUnit` results in a category equivalent to `B`. -/\n@[simps!]\ndef toIdPUnitEquiv (L : Discrete PUnit ⥤ Discrete PUnit) (R : B ⥤ Discrete PUnit) :\n    Comma L R ≌ B :=\n  (equivProd _ R).trans (prod.leftUnitorEquivalence B)\n\n"}
{"name":"CategoryTheory.Comma.toIdPUnitEquiv_inverse_obj_hom_down_down","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"B : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} B\nL : CategoryTheory.Functor (CategoryTheory.Discrete PUnit.{u_1 + 1}) (CategoryTheory.Discrete PUnit.{u_2 + 1})\nR : CategoryTheory.Functor B (CategoryTheory.Discrete PUnit.{u_2 + 1})\nX : B\n⊢ Eq ⋯ ⋯","decl":"/-- Taking the comma category of the identity `Discrete PUnit ⥤ Discrete PUnit`\nand a functor `B ⥤ Discrete PUnit` results in a category equivalent to `B`. -/\n@[simps!]\ndef toIdPUnitEquiv (L : Discrete PUnit ⥤ Discrete PUnit) (R : B ⥤ Discrete PUnit) :\n    Comma L R ≌ B :=\n  (equivProd _ R).trans (prod.leftUnitorEquivalence B)\n\n"}
{"name":"CategoryTheory.Comma.toIdPUnitEquiv_unitIso_hom_app_right","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"B : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} B\nL : CategoryTheory.Functor (CategoryTheory.Discrete PUnit.{u_1 + 1}) (CategoryTheory.Discrete PUnit.{u_2 + 1})\nR : CategoryTheory.Functor B (CategoryTheory.Discrete PUnit.{u_2 + 1})\nX : CategoryTheory.Comma L R\n⊢ Eq ((CategoryTheory.Comma.toIdPUnitEquiv L R).unitIso.hom.app X).right (CategoryTheory.CategoryStruct.id X.right)","decl":"/-- Taking the comma category of the identity `Discrete PUnit ⥤ Discrete PUnit`\nand a functor `B ⥤ Discrete PUnit` results in a category equivalent to `B`. -/\n@[simps!]\ndef toIdPUnitEquiv (L : Discrete PUnit ⥤ Discrete PUnit) (R : B ⥤ Discrete PUnit) :\n    Comma L R ≌ B :=\n  (equivProd _ R).trans (prod.leftUnitorEquivalence B)\n\n"}
{"name":"CategoryTheory.Comma.toIdPUnitEquiv_counitIso_hom_app","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"B : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} B\nL : CategoryTheory.Functor (CategoryTheory.Discrete PUnit.{u_1 + 1}) (CategoryTheory.Discrete PUnit.{u_2 + 1})\nR : CategoryTheory.Functor B (CategoryTheory.Discrete PUnit.{u_2 + 1})\nX : B\n⊢ Eq ((CategoryTheory.Comma.toIdPUnitEquiv L R).counitIso.hom.app X) (CategoryTheory.CategoryStruct.id X)","decl":"/-- Taking the comma category of the identity `Discrete PUnit ⥤ Discrete PUnit`\nand a functor `B ⥤ Discrete PUnit` results in a category equivalent to `B`. -/\n@[simps!]\ndef toIdPUnitEquiv (L : Discrete PUnit ⥤ Discrete PUnit) (R : B ⥤ Discrete PUnit) :\n    Comma L R ≌ B :=\n  (equivProd _ R).trans (prod.leftUnitorEquivalence B)\n\n"}
{"name":"CategoryTheory.Comma.toIdPUnitEquiv_unitIso_inv_app_right","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"B : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} B\nL : CategoryTheory.Functor (CategoryTheory.Discrete PUnit.{u_1 + 1}) (CategoryTheory.Discrete PUnit.{u_2 + 1})\nR : CategoryTheory.Functor B (CategoryTheory.Discrete PUnit.{u_2 + 1})\nX : CategoryTheory.Comma L R\n⊢ Eq ((CategoryTheory.Comma.toIdPUnitEquiv L R).unitIso.inv.app X).right (CategoryTheory.CategoryStruct.id X.right)","decl":"/-- Taking the comma category of the identity `Discrete PUnit ⥤ Discrete PUnit`\nand a functor `B ⥤ Discrete PUnit` results in a category equivalent to `B`. -/\n@[simps!]\ndef toIdPUnitEquiv (L : Discrete PUnit ⥤ Discrete PUnit) (R : B ⥤ Discrete PUnit) :\n    Comma L R ≌ B :=\n  (equivProd _ R).trans (prod.leftUnitorEquivalence B)\n\n"}
{"name":"CategoryTheory.Comma.toIdPUnitEquiv_functor_map","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"B : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} B\nL : CategoryTheory.Functor (CategoryTheory.Discrete PUnit.{u_1 + 1}) (CategoryTheory.Discrete PUnit.{u_2 + 1})\nR : CategoryTheory.Functor B (CategoryTheory.Discrete PUnit.{u_2 + 1})\nX✝ Y✝ : CategoryTheory.Comma L R\nf : Quiver.Hom X✝ Y✝\n⊢ Eq ((CategoryTheory.Comma.toIdPUnitEquiv L R).functor.map f) f.right","decl":"/-- Taking the comma category of the identity `Discrete PUnit ⥤ Discrete PUnit`\nand a functor `B ⥤ Discrete PUnit` results in a category equivalent to `B`. -/\n@[simps!]\ndef toIdPUnitEquiv (L : Discrete PUnit ⥤ Discrete PUnit) (R : B ⥤ Discrete PUnit) :\n    Comma L R ≌ B :=\n  (equivProd _ R).trans (prod.leftUnitorEquivalence B)\n\n"}
{"name":"CategoryTheory.Comma.toIdPUnitEquiv_inverse_map_right","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"B : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} B\nL : CategoryTheory.Functor (CategoryTheory.Discrete PUnit.{u_1 + 1}) (CategoryTheory.Discrete PUnit.{u_2 + 1})\nR : CategoryTheory.Functor B (CategoryTheory.Discrete PUnit.{u_2 + 1})\nX✝ Y✝ : B\nf : Quiver.Hom X✝ Y✝\n⊢ Eq ((CategoryTheory.Comma.toIdPUnitEquiv L R).inverse.map f).right f","decl":"/-- Taking the comma category of the identity `Discrete PUnit ⥤ Discrete PUnit`\nand a functor `B ⥤ Discrete PUnit` results in a category equivalent to `B`. -/\n@[simps!]\ndef toIdPUnitEquiv (L : Discrete PUnit ⥤ Discrete PUnit) (R : B ⥤ Discrete PUnit) :\n    Comma L R ≌ B :=\n  (equivProd _ R).trans (prod.leftUnitorEquivalence B)\n\n"}
{"name":"CategoryTheory.Comma.toIdPUnitEquiv_functor_iso","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"B : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} B\nL : CategoryTheory.Functor (CategoryTheory.Discrete PUnit.{u_1 + 1}) (CategoryTheory.Discrete PUnit.{u_2 + 1})\nR : CategoryTheory.Functor B (CategoryTheory.Discrete PUnit.{u_2 + 1})\n⊢ Eq (CategoryTheory.Comma.toIdPUnitEquiv L R).functor (CategoryTheory.Comma.snd L R)","decl":"@[simp]\ntheorem toIdPUnitEquiv_functor_iso {L : Discrete PUnit ⥤ Discrete PUnit}\n    {R : B ⥤ Discrete PUnit} :\n    (toIdPUnitEquiv L R).functor = snd L R :=\n  rfl\n\n"}
{"name":"CategoryTheory.Comma.opFunctor_obj","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nX : CategoryTheory.Comma L R\n⊢ Eq ((CategoryTheory.Comma.opFunctor L R).obj X) { unop := { left := { unop := X.right }, right := { unop := X.left }, hom := { unop := X.hom } } }","decl":"/-- The canonical functor from `Comma L R` to `(Comma R.op L.op)ᵒᵖ`. -/\n@[simps]\ndef opFunctor : Comma L R ⥤ (Comma R.op L.op)ᵒᵖ where\n  obj X := ⟨op X.right, op X.left, op X.hom⟩\n  map f := ⟨op f.right, op f.left, Quiver.Hom.unop_inj (by simp)⟩\n\n"}
{"name":"CategoryTheory.Comma.opFunctor_map","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nX✝ Y✝ : CategoryTheory.Comma L R\nf : Quiver.Hom X✝ Y✝\n⊢ Eq ((CategoryTheory.Comma.opFunctor L R).map f) { unop := { left := { unop := f.right }, right := { unop := f.left }, w := ⋯ } }","decl":"/-- The canonical functor from `Comma L R` to `(Comma R.op L.op)ᵒᵖ`. -/\n@[simps]\ndef opFunctor : Comma L R ⥤ (Comma R.op L.op)ᵒᵖ where\n  obj X := ⟨op X.right, op X.left, op X.hom⟩\n  map f := ⟨op f.right, op f.left, Quiver.Hom.unop_inj (by simp)⟩\n\n"}
{"name":"CategoryTheory.Comma.opFunctorCompFst_hom_app","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nX : Opposite (CategoryTheory.Comma L R)\n⊢ Eq ((CategoryTheory.Comma.opFunctorCompFst L R).hom.app X) (CategoryTheory.CategoryStruct.id { unop := (Opposite.unop X).right })","decl":"/-- Composing the `leftOp` of `opFunctor L R` with `fst L.op R.op` is naturally isomorphic\nto `snd L R`.-/\n@[simps!]\ndef opFunctorCompFst : (opFunctor L R).leftOp ⋙ fst _ _ ≅ (snd _ _).op :=\n  Iso.refl _\n\n"}
{"name":"CategoryTheory.Comma.opFunctorCompFst_inv_app","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nX : Opposite (CategoryTheory.Comma L R)\n⊢ Eq ((CategoryTheory.Comma.opFunctorCompFst L R).inv.app X) (CategoryTheory.CategoryStruct.id { unop := (Opposite.unop X).right })","decl":"/-- Composing the `leftOp` of `opFunctor L R` with `fst L.op R.op` is naturally isomorphic\nto `snd L R`.-/\n@[simps!]\ndef opFunctorCompFst : (opFunctor L R).leftOp ⋙ fst _ _ ≅ (snd _ _).op :=\n  Iso.refl _\n\n"}
{"name":"CategoryTheory.Comma.opFunctorCompSnd_inv_app","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nX : Opposite (CategoryTheory.Comma L R)\n⊢ Eq ((CategoryTheory.Comma.opFunctorCompSnd L R).inv.app X) (CategoryTheory.CategoryStruct.id { unop := (Opposite.unop X).left })","decl":"/-- Composing the `leftOp` of `opFunctor L R` with `snd L.op R.op` is naturally isomorphic\nto `fst L R`.-/\n@[simps!]\ndef opFunctorCompSnd : (opFunctor L R).leftOp ⋙ snd _ _ ≅ (fst _ _).op :=\n  Iso.refl _\n\n"}
{"name":"CategoryTheory.Comma.opFunctorCompSnd_hom_app","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nX : Opposite (CategoryTheory.Comma L R)\n⊢ Eq ((CategoryTheory.Comma.opFunctorCompSnd L R).hom.app X) (CategoryTheory.CategoryStruct.id { unop := (Opposite.unop X).left })","decl":"/-- Composing the `leftOp` of `opFunctor L R` with `snd L.op R.op` is naturally isomorphic\nto `fst L R`.-/\n@[simps!]\ndef opFunctorCompSnd : (opFunctor L R).leftOp ⋙ snd _ _ ≅ (fst _ _).op :=\n  Iso.refl _\n\n"}
{"name":"CategoryTheory.Comma.unopFunctor_map","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nX✝ Y✝ : CategoryTheory.Comma L.op R.op\nf : Quiver.Hom X✝ Y✝\n⊢ Eq ((CategoryTheory.Comma.unopFunctor L R).map f) { unop := { left := f.right.unop, right := f.left.unop, w := ⋯ } }","decl":"/-- The canonical functor from `Comma L.op R.op` to `(Comma R L)ᵒᵖ`. -/\n@[simps]\ndef unopFunctor : Comma L.op R.op ⥤ (Comma R L)ᵒᵖ where\n  obj X := ⟨X.right.unop, X.left.unop, X.hom.unop⟩\n  map f := ⟨f.right.unop, f.left.unop, Quiver.Hom.op_inj (by simpa using f.w.symm)⟩\n\n"}
{"name":"CategoryTheory.Comma.unopFunctor_obj","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nX : CategoryTheory.Comma L.op R.op\n⊢ Eq ((CategoryTheory.Comma.unopFunctor L R).obj X) { unop := { left := Opposite.unop X.right, right := Opposite.unop X.left, hom := X.hom.unop } }","decl":"/-- The canonical functor from `Comma L.op R.op` to `(Comma R L)ᵒᵖ`. -/\n@[simps]\ndef unopFunctor : Comma L.op R.op ⥤ (Comma R L)ᵒᵖ where\n  obj X := ⟨X.right.unop, X.left.unop, X.hom.unop⟩\n  map f := ⟨f.right.unop, f.left.unop, Quiver.Hom.op_inj (by simpa using f.w.symm)⟩\n\n"}
{"name":"CategoryTheory.Comma.unopFunctorCompFst_inv_app","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nX : CategoryTheory.Comma L.op R.op\n⊢ Eq ((CategoryTheory.Comma.unopFunctorCompFst L R).inv.app X) (CategoryTheory.CategoryStruct.id X.right)","decl":"/-- Composing `unopFunctor L R` with `(fst L R).op` is isomorphic to `snd L.op R.op`. -/\n@[simps!]\ndef unopFunctorCompFst : unopFunctor L R ⋙ (fst _ _).op ≅ snd _ _ :=\n  Iso.refl _\n\n"}
{"name":"CategoryTheory.Comma.unopFunctorCompFst_hom_app","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nX : CategoryTheory.Comma L.op R.op\n⊢ Eq ((CategoryTheory.Comma.unopFunctorCompFst L R).hom.app X) (CategoryTheory.CategoryStruct.id X.right)","decl":"/-- Composing `unopFunctor L R` with `(fst L R).op` is isomorphic to `snd L.op R.op`. -/\n@[simps!]\ndef unopFunctorCompFst : unopFunctor L R ⋙ (fst _ _).op ≅ snd _ _ :=\n  Iso.refl _\n\n"}
{"name":"CategoryTheory.Comma.unopFunctorCompSnd_hom_app","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nX : CategoryTheory.Comma L.op R.op\n⊢ Eq ((CategoryTheory.Comma.unopFunctorCompSnd L R).hom.app X) (CategoryTheory.CategoryStruct.id X.left)","decl":"/-- Composing `unopFunctor L R` with `(snd L R).op` is isomorphic to `fst L.op R.op`. -/\n@[simps!]\ndef unopFunctorCompSnd : unopFunctor L R ⋙ (snd _ _).op ≅ fst _ _ :=\n  Iso.refl _\n\n"}
{"name":"CategoryTheory.Comma.unopFunctorCompSnd_inv_app","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nX : CategoryTheory.Comma L.op R.op\n⊢ Eq ((CategoryTheory.Comma.unopFunctorCompSnd L R).inv.app X) (CategoryTheory.CategoryStruct.id X.left)","decl":"/-- Composing `unopFunctor L R` with `(snd L R).op` is isomorphic to `fst L.op R.op`. -/\n@[simps!]\ndef unopFunctorCompSnd : unopFunctor L R ⋙ (snd _ _).op ≅ fst _ _ :=\n  Iso.refl _\n\n"}
{"name":"CategoryTheory.Comma.opEquiv_unitIso","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\n⊢ Eq (CategoryTheory.Comma.opEquiv L R).unitIso (CategoryTheory.NatIso.ofComponents (fun X => CategoryTheory.Iso.refl ((CategoryTheory.Functor.id (CategoryTheory.Comma L R)).obj X)) ⋯)","decl":"/-- The canonical equivalence between `Comma L R` and `(Comma R.op L.op)ᵒᵖ`. -/\n@[simps]\ndef opEquiv : Comma L R ≌ (Comma R.op L.op)ᵒᵖ where\n  functor := opFunctor L R\n  inverse := (unopFunctor R L).leftOp\n  unitIso := NatIso.ofComponents (fun X => Iso.refl _)\n  counitIso := NatIso.ofComponents (fun X => Iso.refl _)\n\n"}
{"name":"CategoryTheory.Comma.opEquiv_functor","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\n⊢ Eq (CategoryTheory.Comma.opEquiv L R).functor (CategoryTheory.Comma.opFunctor L R)","decl":"/-- The canonical equivalence between `Comma L R` and `(Comma R.op L.op)ᵒᵖ`. -/\n@[simps]\ndef opEquiv : Comma L R ≌ (Comma R.op L.op)ᵒᵖ where\n  functor := opFunctor L R\n  inverse := (unopFunctor R L).leftOp\n  unitIso := NatIso.ofComponents (fun X => Iso.refl _)\n  counitIso := NatIso.ofComponents (fun X => Iso.refl _)\n\n"}
{"name":"CategoryTheory.Comma.opEquiv_inverse","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\n⊢ Eq (CategoryTheory.Comma.opEquiv L R).inverse (CategoryTheory.Comma.unopFunctor R L).leftOp","decl":"/-- The canonical equivalence between `Comma L R` and `(Comma R.op L.op)ᵒᵖ`. -/\n@[simps]\ndef opEquiv : Comma L R ≌ (Comma R.op L.op)ᵒᵖ where\n  functor := opFunctor L R\n  inverse := (unopFunctor R L).leftOp\n  unitIso := NatIso.ofComponents (fun X => Iso.refl _)\n  counitIso := NatIso.ofComponents (fun X => Iso.refl _)\n\n"}
{"name":"CategoryTheory.Comma.opEquiv_counitIso","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\n⊢ Eq (CategoryTheory.Comma.opEquiv L R).counitIso (CategoryTheory.NatIso.ofComponents (fun X => CategoryTheory.Iso.refl (((CategoryTheory.Comma.unopFunctor R L).leftOp.comp (CategoryTheory.Comma.opFunctor L R)).obj X)) ⋯)","decl":"/-- The canonical equivalence between `Comma L R` and `(Comma R.op L.op)ᵒᵖ`. -/\n@[simps]\ndef opEquiv : Comma L R ≌ (Comma R.op L.op)ᵒᵖ where\n  functor := opFunctor L R\n  inverse := (unopFunctor R L).leftOp\n  unitIso := NatIso.ofComponents (fun X => Iso.refl _)\n  counitIso := NatIso.ofComponents (fun X => Iso.refl _)\n\n"}
