{"name":"CategoryTheory.Comma.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœâµ : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœÂ³ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\ninstâœÂ² : SizeOf A\ninstâœÂ¹ : SizeOf B\ninstâœ : SizeOf T\nleft : A\nright : B\nhom : Quiver.Hom (L.obj left) (R.obj right)\nâŠ¢ Eq (SizeOf.sizeOf { left := left, right := right, hom := hom }) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf left)) (SizeOf.sizeOf right)) (SizeOf.sizeOf hom))","decl":"/-- The objects of the comma category are triples of an object `left : A`, an object\n   `right : B` and a morphism `hom : L.obj left âŸ¶ R.obj right`. -/\nstructure Comma (L : A â¥¤ T) (R : B â¥¤ T) : Type max uâ‚ uâ‚‚ vâ‚ƒ where\n  left : A\n  right : B\n  hom : L.obj left âŸ¶ R.obj right\n\n-- Satisfying the inhabited linter\n"}
{"name":"CategoryTheory.Comma.mk.injEq","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nleftâœ : A\nrightâœ : B\nhomâœ : Quiver.Hom (L.obj leftâœ) (R.obj rightâœ)\nleft : A\nright : B\nhom : Quiver.Hom (L.obj left) (R.obj right)\nâŠ¢ Eq (Eq { left := leftâœ, right := rightâœ, hom := homâœ } { left := left, right := right, hom := hom }) (And (Eq leftâœ left) (And (Eq rightâœ right) (HEq homâœ hom)))","decl":"/-- The objects of the comma category are triples of an object `left : A`, an object\n   `right : B` and a morphism `hom : L.obj left âŸ¶ R.obj right`. -/\nstructure Comma (L : A â¥¤ T) (R : B â¥¤ T) : Type max uâ‚ uâ‚‚ vâ‚ƒ where\n  left : A\n  right : B\n  hom : L.obj left âŸ¶ R.obj right\n\n-- Satisfying the inhabited linter\n"}
{"name":"CategoryTheory.Comma.mk.inj","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nleftâœ : A\nrightâœ : B\nhomâœ : Quiver.Hom (L.obj leftâœ) (R.obj rightâœ)\nleft : A\nright : B\nhom : Quiver.Hom (L.obj left) (R.obj right)\nxâœ : Eq { left := leftâœ, right := rightâœ, hom := homâœ } { left := left, right := right, hom := hom }\nâŠ¢ And (Eq leftâœ left) (And (Eq rightâœ right) (HEq homâœ hom))","decl":"/-- The objects of the comma category are triples of an object `left : A`, an object\n   `right : B` and a morphism `hom : L.obj left âŸ¶ R.obj right`. -/\nstructure Comma (L : A â¥¤ T) (R : B â¥¤ T) : Type max uâ‚ uâ‚‚ vâ‚ƒ where\n  left : A\n  right : B\n  hom : L.obj left âŸ¶ R.obj right\n\n-- Satisfying the inhabited linter\n"}
{"name":"CategoryTheory.CommaMorphism.mk.injEq","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nX Y : CategoryTheory.Comma L R\nleftâœ : Quiver.Hom X.left Y.left\nrightâœ : Quiver.Hom X.right Y.right\nwâœ : autoParam (Eq (CategoryTheory.CategoryStruct.comp (L.map leftâœ) Y.hom) (CategoryTheory.CategoryStruct.comp X.hom (R.map rightâœ))) _autoâœ\nleft : Quiver.Hom X.left Y.left\nright : Quiver.Hom X.right Y.right\nw : autoParam (Eq (CategoryTheory.CategoryStruct.comp (L.map left) Y.hom) (CategoryTheory.CategoryStruct.comp X.hom (R.map right))) _autoâœ\nâŠ¢ Eq (Eq { left := leftâœ, right := rightâœ, w := wâœ } { left := left, right := right, w := w }) (And (Eq leftâœ left) (Eq rightâœ right))","decl":"/-- A morphism between two objects in the comma category is a commutative square connecting the\n    morphisms coming from the two objects using morphisms in the image of the functors `L` and `R`.\n-/\n@[ext]\nstructure CommaMorphism (X Y : Comma L R) where\n  left : X.left âŸ¶ Y.left\n  right : X.right âŸ¶ Y.right\n  w : L.map left â‰« Y.hom = X.hom â‰« R.map right := by aesop_cat\n\n-- Satisfying the inhabited linter\n"}
{"name":"CategoryTheory.CommaMorphism.w","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nX Y : CategoryTheory.Comma L R\nself : CategoryTheory.CommaMorphism X Y\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (L.map self.left) Y.hom) (CategoryTheory.CategoryStruct.comp X.hom (R.map self.right))","decl":"/-- A morphism between two objects in the comma category is a commutative square connecting the\n    morphisms coming from the two objects using morphisms in the image of the functors `L` and `R`.\n-/\n@[ext]\nstructure CommaMorphism (X Y : Comma L R) where\n  left : X.left âŸ¶ Y.left\n  right : X.right âŸ¶ Y.right\n  w : L.map left â‰« Y.hom = X.hom â‰« R.map right := by aesop_cat\n\n-- Satisfying the inhabited linter\n"}
{"name":"CategoryTheory.CommaMorphism.mk.inj","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nX Y : CategoryTheory.Comma L R\nleftâœ : Quiver.Hom X.left Y.left\nrightâœ : Quiver.Hom X.right Y.right\nwâœ : autoParam (Eq (CategoryTheory.CategoryStruct.comp (L.map leftâœ) Y.hom) (CategoryTheory.CategoryStruct.comp X.hom (R.map rightâœ))) _autoâœ\nleft : Quiver.Hom X.left Y.left\nright : Quiver.Hom X.right Y.right\nw : autoParam (Eq (CategoryTheory.CategoryStruct.comp (L.map left) Y.hom) (CategoryTheory.CategoryStruct.comp X.hom (R.map right))) _autoâœ\nxâœ : Eq { left := leftâœ, right := rightâœ, w := wâœ } { left := left, right := right, w := w }\nâŠ¢ And (Eq leftâœ left) (Eq rightâœ right)","decl":"/-- A morphism between two objects in the comma category is a commutative square connecting the\n    morphisms coming from the two objects using morphisms in the image of the functors `L` and `R`.\n-/\n@[ext]\nstructure CommaMorphism (X Y : Comma L R) where\n  left : X.left âŸ¶ Y.left\n  right : X.right âŸ¶ Y.right\n  w : L.map left â‰« Y.hom = X.hom â‰« R.map right := by aesop_cat\n\n-- Satisfying the inhabited linter\n"}
{"name":"CategoryTheory.CommaMorphism.ext","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nX Y : CategoryTheory.Comma L R\nx y : CategoryTheory.CommaMorphism X Y\nleft : Eq x.left y.left\nright : Eq x.right y.right\nâŠ¢ Eq x y","decl":"/-- A morphism between two objects in the comma category is a commutative square connecting the\n    morphisms coming from the two objects using morphisms in the image of the functors `L` and `R`.\n-/\n@[ext]\nstructure CommaMorphism (X Y : Comma L R) where\n  left : X.left âŸ¶ Y.left\n  right : X.right âŸ¶ Y.right\n  w : L.map left â‰« Y.hom = X.hom â‰« R.map right := by aesop_cat\n\n-- Satisfying the inhabited linter\n"}
{"name":"CategoryTheory.CommaMorphism.ext_iff","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nX Y : CategoryTheory.Comma L R\nx y : CategoryTheory.CommaMorphism X Y\nâŠ¢ Iff (Eq x y) (And (Eq x.left y.left) (Eq x.right y.right))","decl":"/-- A morphism between two objects in the comma category is a commutative square connecting the\n    morphisms coming from the two objects using morphisms in the image of the functors `L` and `R`.\n-/\n@[ext]\nstructure CommaMorphism (X Y : Comma L R) where\n  left : X.left âŸ¶ Y.left\n  right : X.right âŸ¶ Y.right\n  w : L.map left â‰« Y.hom = X.hom â‰« R.map right := by aesop_cat\n\n-- Satisfying the inhabited linter\n"}
{"name":"CategoryTheory.CommaMorphism.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœâµ : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœÂ³ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nX Y : CategoryTheory.Comma L R\ninstâœÂ² : SizeOf A\ninstâœÂ¹ : SizeOf B\ninstâœ : SizeOf T\nleft : Quiver.Hom X.left Y.left\nright : Quiver.Hom X.right Y.right\nw : autoParam (Eq (CategoryTheory.CategoryStruct.comp (L.map left) Y.hom) (CategoryTheory.CategoryStruct.comp X.hom (R.map right))) _autoâœ\nâŠ¢ Eq (SizeOf.sizeOf { left := left, right := right, w := w }) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf left)) (SizeOf.sizeOf right)) (SizeOf.sizeOf w))","decl":"/-- A morphism between two objects in the comma category is a commutative square connecting the\n    morphisms coming from the two objects using morphisms in the image of the functors `L` and `R`.\n-/\n@[ext]\nstructure CommaMorphism (X Y : Comma L R) where\n  left : X.left âŸ¶ Y.left\n  right : X.right âŸ¶ Y.right\n  w : L.map left â‰« Y.hom = X.hom â‰« R.map right := by aesop_cat\n\n-- Satisfying the inhabited linter\n"}
{"name":"CategoryTheory.CommaMorphism.w_assoc","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nX Y : CategoryTheory.Comma L R\nself : CategoryTheory.CommaMorphism X Y\nZ : T\nh : Quiver.Hom (R.obj Y.right) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (L.map self.left) (CategoryTheory.CategoryStruct.comp Y.hom h)) (CategoryTheory.CategoryStruct.comp X.hom (CategoryTheory.CategoryStruct.comp (R.map self.right) h))","decl":"attribute [reassoc (attr := simp)] CommaMorphism.w\n\n"}
{"name":"CategoryTheory.Comma.hom_ext","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nX Y : CategoryTheory.Comma L R\nf g : Quiver.Hom X Y\nhâ‚ : Eq f.left g.left\nhâ‚‚ : Eq f.right g.right\nâŠ¢ Eq f g","decl":"@[ext]\nlemma hom_ext (f g : X âŸ¶ Y) (hâ‚ : f.left = g.left) (hâ‚‚ : f.right = g.right) : f = g :=\n  CommaMorphism.ext hâ‚ hâ‚‚\n\n"}
{"name":"CategoryTheory.Comma.hom_ext_iff","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nX Y : CategoryTheory.Comma L R\nf g : Quiver.Hom X Y\nâŠ¢ Iff (Eq f g) (And (Eq f.left g.left) (Eq f.right g.right))","decl":"@[ext]\nlemma hom_ext (f g : X âŸ¶ Y) (hâ‚ : f.left = g.left) (hâ‚‚ : f.right = g.right) : f = g :=\n  CommaMorphism.ext hâ‚ hâ‚‚\n\n"}
{"name":"CategoryTheory.Comma.id_left","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nX : CategoryTheory.Comma L R\nâŠ¢ Eq (CategoryTheory.CategoryStruct.id X).left (CategoryTheory.CategoryStruct.id X.left)","decl":"@[simp]\ntheorem id_left : (ğŸ™ X : CommaMorphism X X).left = ğŸ™ X.left :=\n  rfl\n\n"}
{"name":"CategoryTheory.Comma.id_right","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nX : CategoryTheory.Comma L R\nâŠ¢ Eq (CategoryTheory.CategoryStruct.id X).right (CategoryTheory.CategoryStruct.id X.right)","decl":"@[simp]\ntheorem id_right : (ğŸ™ X : CommaMorphism X X).right = ğŸ™ X.right :=\n  rfl\n\n"}
{"name":"CategoryTheory.Comma.comp_left","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nX Y Z : CategoryTheory.Comma L R\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp f g).left (CategoryTheory.CategoryStruct.comp f.left g.left)","decl":"@[simp]\ntheorem comp_left : (f â‰« g).left = f.left â‰« g.left :=\n  rfl\n\n"}
{"name":"CategoryTheory.Comma.comp_right","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nX Y Z : CategoryTheory.Comma L R\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp f g).right (CategoryTheory.CategoryStruct.comp f.right g.right)","decl":"@[simp]\ntheorem comp_right : (f â‰« g).right = f.right â‰« g.right :=\n  rfl\n\n"}
{"name":"CategoryTheory.Comma.fst_map","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nXâœ Yâœ : CategoryTheory.Comma L R\nf : Quiver.Hom Xâœ Yâœ\nâŠ¢ Eq ((CategoryTheory.Comma.fst L R).map f) f.left","decl":"/-- The functor sending an object `X` in the comma category to `X.left`. -/\n@[simps]\ndef fst : Comma L R â¥¤ A where\n  obj X := X.left\n  map f := f.left\n\n"}
{"name":"CategoryTheory.Comma.fst_obj","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nX : CategoryTheory.Comma L R\nâŠ¢ Eq ((CategoryTheory.Comma.fst L R).obj X) X.left","decl":"/-- The functor sending an object `X` in the comma category to `X.left`. -/\n@[simps]\ndef fst : Comma L R â¥¤ A where\n  obj X := X.left\n  map f := f.left\n\n"}
{"name":"CategoryTheory.Comma.snd_map","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nXâœ Yâœ : CategoryTheory.Comma L R\nf : Quiver.Hom Xâœ Yâœ\nâŠ¢ Eq ((CategoryTheory.Comma.snd L R).map f) f.right","decl":"/-- The functor sending an object `X` in the comma category to `X.right`. -/\n@[simps]\ndef snd : Comma L R â¥¤ B where\n  obj X := X.right\n  map f := f.right\n\n"}
{"name":"CategoryTheory.Comma.snd_obj","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nX : CategoryTheory.Comma L R\nâŠ¢ Eq ((CategoryTheory.Comma.snd L R).obj X) X.right","decl":"/-- The functor sending an object `X` in the comma category to `X.right`. -/\n@[simps]\ndef snd : Comma L R â¥¤ B where\n  obj X := X.right\n  map f := f.right\n\n"}
{"name":"CategoryTheory.Comma.natTrans_app","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nX : CategoryTheory.Comma L R\nâŠ¢ Eq ((CategoryTheory.Comma.natTrans L R).app X) X.hom","decl":"/-- We can interpret the commutative square constituting a morphism in the comma category as a\n    natural transformation between the functors `fst â‹™ L` and `snd â‹™ R` from the comma category\n    to `T`, where the components are given by the morphism that constitutes an object of the comma\n    category. -/\n@[simps]\ndef natTrans : fst L R â‹™ L âŸ¶ snd L R â‹™ R where app X := X.hom\n\n"}
{"name":"CategoryTheory.Comma.eqToHom_left","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nX Y : CategoryTheory.Comma L R\nH : Eq X Y\nâŠ¢ Eq (CategoryTheory.eqToHom H).left (CategoryTheory.eqToHom â‹¯)","decl":"@[simp]\ntheorem eqToHom_left (X Y : Comma L R) (H : X = Y) :\n    CommaMorphism.left (eqToHom H) = eqToHom (by cases H; rfl) := by\n  cases H\n  rfl\n\n"}
{"name":"CategoryTheory.Comma.eqToHom_right","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nX Y : CategoryTheory.Comma L R\nH : Eq X Y\nâŠ¢ Eq (CategoryTheory.eqToHom H).right (CategoryTheory.eqToHom â‹¯)","decl":"@[simp]\ntheorem eqToHom_right (X Y : Comma L R) (H : X = Y) :\n    CommaMorphism.right (eqToHom H) = eqToHom (by cases H; rfl) := by\n  cases H\n  rfl\n\n"}
{"name":"CategoryTheory.Comma.instIsIsoLeft","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nX Y : CategoryTheory.Comma L R\ne : Quiver.Hom X Y\ninstâœ : CategoryTheory.IsIso e\nâŠ¢ CategoryTheory.IsIso e.left","decl":"instance [IsIso e] : IsIso e.left :=\n  (Comma.fst L R).map_isIso e\n\n"}
{"name":"CategoryTheory.Comma.instIsIsoRight","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nX Y : CategoryTheory.Comma L R\ne : Quiver.Hom X Y\ninstâœ : CategoryTheory.IsIso e\nâŠ¢ CategoryTheory.IsIso e.right","decl":"instance [IsIso e] : IsIso e.right :=\n  (Comma.snd L R).map_isIso e\n\n"}
{"name":"CategoryTheory.Comma.inv_left","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nX Y : CategoryTheory.Comma L R\ne : Quiver.Hom X Y\ninstâœ : CategoryTheory.IsIso e\nâŠ¢ Eq (CategoryTheory.inv e).left (CategoryTheory.inv e.left)","decl":"@[simp]\nlemma inv_left [IsIso e] : (inv e).left = inv e.left := by\n  apply IsIso.eq_inv_of_hom_inv_id\n  rw [â† Comma.comp_left, IsIso.hom_inv_id, id_left]\n\n"}
{"name":"CategoryTheory.Comma.inv_right","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nX Y : CategoryTheory.Comma L R\ne : Quiver.Hom X Y\ninstâœ : CategoryTheory.IsIso e\nâŠ¢ Eq (CategoryTheory.inv e).right (CategoryTheory.inv e.right)","decl":"@[simp]\nlemma inv_right [IsIso e] : (inv e).right = inv e.right := by\n  apply IsIso.eq_inv_of_hom_inv_id\n  rw [â† Comma.comp_right, IsIso.hom_inv_id, id_right]\n\n"}
{"name":"CategoryTheory.Comma.left_hom_inv_right","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nX Y : CategoryTheory.Comma L R\ne : Quiver.Hom X Y\ninstâœ : CategoryTheory.IsIso e\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (L.map e.left) (CategoryTheory.CategoryStruct.comp Y.hom (R.map (CategoryTheory.inv e.right)))) X.hom","decl":"lemma left_hom_inv_right [IsIso e] : L.map (e.left) â‰« Y.hom â‰« R.map (inv e.right) = X.hom := by\n  simp\n\n"}
{"name":"CategoryTheory.Comma.inv_left_hom_right","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nX Y : CategoryTheory.Comma L R\ne : Quiver.Hom X Y\ninstâœ : CategoryTheory.IsIso e\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (L.map (CategoryTheory.inv e.left)) (CategoryTheory.CategoryStruct.comp X.hom (R.map e.right))) Y.hom","decl":"lemma inv_left_hom_right [IsIso e] : L.map (inv e.left) â‰« X.hom â‰« R.map e.right = Y.hom := by\n  simp\n\n"}
{"name":"CategoryTheory.Comma.leftIso_hom","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nLâ‚ : CategoryTheory.Functor A T\nRâ‚ : CategoryTheory.Functor B T\nX Y : CategoryTheory.Comma Lâ‚ Râ‚\nÎ± : CategoryTheory.Iso X Y\nâŠ¢ Eq (CategoryTheory.Comma.leftIso Î±).hom Î±.hom.left","decl":"/-- Extract the isomorphism between the left objects from an isomorphism in the comma category. -/\n@[simps!]\ndef leftIso {X Y : Comma Lâ‚ Râ‚} (Î± : X â‰… Y) : X.left â‰… Y.left := (fst Lâ‚ Râ‚).mapIso Î±\n\n"}
{"name":"CategoryTheory.Comma.leftIso_inv","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nLâ‚ : CategoryTheory.Functor A T\nRâ‚ : CategoryTheory.Functor B T\nX Y : CategoryTheory.Comma Lâ‚ Râ‚\nÎ± : CategoryTheory.Iso X Y\nâŠ¢ Eq (CategoryTheory.Comma.leftIso Î±).inv Î±.inv.left","decl":"/-- Extract the isomorphism between the left objects from an isomorphism in the comma category. -/\n@[simps!]\ndef leftIso {X Y : Comma Lâ‚ Râ‚} (Î± : X â‰… Y) : X.left â‰… Y.left := (fst Lâ‚ Râ‚).mapIso Î±\n\n"}
{"name":"CategoryTheory.Comma.rightIso_hom","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nLâ‚ : CategoryTheory.Functor A T\nRâ‚ : CategoryTheory.Functor B T\nX Y : CategoryTheory.Comma Lâ‚ Râ‚\nÎ± : CategoryTheory.Iso X Y\nâŠ¢ Eq (CategoryTheory.Comma.rightIso Î±).hom Î±.hom.right","decl":"/-- Extract the isomorphism between the right objects from an isomorphism in the comma category. -/\n@[simps!]\ndef rightIso {X Y : Comma Lâ‚ Râ‚} (Î± : X â‰… Y) : X.right â‰… Y.right := (snd Lâ‚ Râ‚).mapIso Î±\n\n"}
{"name":"CategoryTheory.Comma.rightIso_inv","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nLâ‚ : CategoryTheory.Functor A T\nRâ‚ : CategoryTheory.Functor B T\nX Y : CategoryTheory.Comma Lâ‚ Râ‚\nÎ± : CategoryTheory.Iso X Y\nâŠ¢ Eq (CategoryTheory.Comma.rightIso Î±).inv Î±.inv.right","decl":"/-- Extract the isomorphism between the right objects from an isomorphism in the comma category. -/\n@[simps!]\ndef rightIso {X Y : Comma Lâ‚ Râ‚} (Î± : X â‰… Y) : X.right â‰… Y.right := (snd Lâ‚ Râ‚).mapIso Î±\n\n"}
{"name":"CategoryTheory.Comma.isoMk_hom_left","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nLâ‚ : CategoryTheory.Functor A T\nRâ‚ : CategoryTheory.Functor B T\nX Y : CategoryTheory.Comma Lâ‚ Râ‚\nl : CategoryTheory.Iso X.left Y.left\nr : CategoryTheory.Iso X.right Y.right\nh : autoParam (Eq (CategoryTheory.CategoryStruct.comp (Lâ‚.map l.hom) Y.hom) (CategoryTheory.CategoryStruct.comp X.hom (Râ‚.map r.hom))) _autoâœ\nâŠ¢ Eq (CategoryTheory.Comma.isoMk l r h).hom.left l.hom","decl":"/-- Construct an isomorphism in the comma category given isomorphisms of the objects whose forward\ndirections give a commutative square.\n-/\n@[simps]\ndef isoMk {X Y : Comma Lâ‚ Râ‚} (l : X.left â‰… Y.left) (r : X.right â‰… Y.right)\n    (h : Lâ‚.map l.hom â‰« Y.hom = X.hom â‰« Râ‚.map r.hom := by aesop_cat) : X â‰… Y where\n  hom :=\n    { left := l.hom\n      right := r.hom\n      w := h }\n  inv :=\n    { left := l.inv\n      right := r.inv\n      w := by\n        rw [â† Lâ‚.mapIso_inv l, Iso.inv_comp_eq, Lâ‚.mapIso_hom, â† Category.assoc, h,\n          Category.assoc, â† Râ‚.map_comp]\n        simp }\n\n"}
{"name":"CategoryTheory.Comma.isoMk_inv_left","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nLâ‚ : CategoryTheory.Functor A T\nRâ‚ : CategoryTheory.Functor B T\nX Y : CategoryTheory.Comma Lâ‚ Râ‚\nl : CategoryTheory.Iso X.left Y.left\nr : CategoryTheory.Iso X.right Y.right\nh : autoParam (Eq (CategoryTheory.CategoryStruct.comp (Lâ‚.map l.hom) Y.hom) (CategoryTheory.CategoryStruct.comp X.hom (Râ‚.map r.hom))) _autoâœ\nâŠ¢ Eq (CategoryTheory.Comma.isoMk l r h).inv.left l.inv","decl":"/-- Construct an isomorphism in the comma category given isomorphisms of the objects whose forward\ndirections give a commutative square.\n-/\n@[simps]\ndef isoMk {X Y : Comma Lâ‚ Râ‚} (l : X.left â‰… Y.left) (r : X.right â‰… Y.right)\n    (h : Lâ‚.map l.hom â‰« Y.hom = X.hom â‰« Râ‚.map r.hom := by aesop_cat) : X â‰… Y where\n  hom :=\n    { left := l.hom\n      right := r.hom\n      w := h }\n  inv :=\n    { left := l.inv\n      right := r.inv\n      w := by\n        rw [â† Lâ‚.mapIso_inv l, Iso.inv_comp_eq, Lâ‚.mapIso_hom, â† Category.assoc, h,\n          Category.assoc, â† Râ‚.map_comp]\n        simp }\n\n"}
{"name":"CategoryTheory.Comma.isoMk_hom_right","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nLâ‚ : CategoryTheory.Functor A T\nRâ‚ : CategoryTheory.Functor B T\nX Y : CategoryTheory.Comma Lâ‚ Râ‚\nl : CategoryTheory.Iso X.left Y.left\nr : CategoryTheory.Iso X.right Y.right\nh : autoParam (Eq (CategoryTheory.CategoryStruct.comp (Lâ‚.map l.hom) Y.hom) (CategoryTheory.CategoryStruct.comp X.hom (Râ‚.map r.hom))) _autoâœ\nâŠ¢ Eq (CategoryTheory.Comma.isoMk l r h).hom.right r.hom","decl":"/-- Construct an isomorphism in the comma category given isomorphisms of the objects whose forward\ndirections give a commutative square.\n-/\n@[simps]\ndef isoMk {X Y : Comma Lâ‚ Râ‚} (l : X.left â‰… Y.left) (r : X.right â‰… Y.right)\n    (h : Lâ‚.map l.hom â‰« Y.hom = X.hom â‰« Râ‚.map r.hom := by aesop_cat) : X â‰… Y where\n  hom :=\n    { left := l.hom\n      right := r.hom\n      w := h }\n  inv :=\n    { left := l.inv\n      right := r.inv\n      w := by\n        rw [â† Lâ‚.mapIso_inv l, Iso.inv_comp_eq, Lâ‚.mapIso_hom, â† Category.assoc, h,\n          Category.assoc, â† Râ‚.map_comp]\n        simp }\n\n"}
{"name":"CategoryTheory.Comma.isoMk_inv_right","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nLâ‚ : CategoryTheory.Functor A T\nRâ‚ : CategoryTheory.Functor B T\nX Y : CategoryTheory.Comma Lâ‚ Râ‚\nl : CategoryTheory.Iso X.left Y.left\nr : CategoryTheory.Iso X.right Y.right\nh : autoParam (Eq (CategoryTheory.CategoryStruct.comp (Lâ‚.map l.hom) Y.hom) (CategoryTheory.CategoryStruct.comp X.hom (Râ‚.map r.hom))) _autoâœ\nâŠ¢ Eq (CategoryTheory.Comma.isoMk l r h).inv.right r.inv","decl":"/-- Construct an isomorphism in the comma category given isomorphisms of the objects whose forward\ndirections give a commutative square.\n-/\n@[simps]\ndef isoMk {X Y : Comma Lâ‚ Râ‚} (l : X.left â‰… Y.left) (r : X.right â‰… Y.right)\n    (h : Lâ‚.map l.hom â‰« Y.hom = X.hom â‰« Râ‚.map r.hom := by aesop_cat) : X â‰… Y where\n  hom :=\n    { left := l.hom\n      right := r.hom\n      w := h }\n  inv :=\n    { left := l.inv\n      right := r.inv\n      w := by\n        rw [â† Lâ‚.mapIso_inv l, Iso.inv_comp_eq, Lâ‚.mapIso_hom, â† Category.assoc, h,\n          Category.assoc, â† Râ‚.map_comp]\n        simp }\n\n"}
{"name":"CategoryTheory.Comma.map_obj_hom","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœâµ : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœÂ³ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nA' : Type uâ‚„\ninstâœÂ² : CategoryTheory.Category.{vâ‚„, uâ‚„} A'\nB' : Type uâ‚…\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚…, uâ‚…} B'\nT' : Type uâ‚†\ninstâœ : CategoryTheory.Category.{vâ‚†, uâ‚†} T'\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nL' : CategoryTheory.Functor A' T'\nR' : CategoryTheory.Functor B' T'\nFâ‚ : CategoryTheory.Functor A A'\nFâ‚‚ : CategoryTheory.Functor B B'\nF : CategoryTheory.Functor T T'\nÎ± : Quiver.Hom (Fâ‚.comp L') (L.comp F)\nÎ² : Quiver.Hom (R.comp F) (Fâ‚‚.comp R')\nX : CategoryTheory.Comma L R\nâŠ¢ Eq ((CategoryTheory.Comma.map Î± Î²).obj X).hom (CategoryTheory.CategoryStruct.comp (Î±.app X.left) (CategoryTheory.CategoryStruct.comp (F.map X.hom) (Î².app X.right)))","decl":"/-- The functor `Comma L R â¥¤ Comma L' R'` induced by three functors `Fâ‚`, `Fâ‚‚`, `F`\nand two natural transformations `Fâ‚ â‹™ L' âŸ¶ L â‹™ F` and `R â‹™ F âŸ¶ Fâ‚‚ â‹™ R'`. -/\n@[simps]\ndef map : Comma L R â¥¤ Comma L' R' where\n  obj X :=\n    { left := Fâ‚.obj X.left\n      right := Fâ‚‚.obj X.right\n      hom := Î±.app X.left â‰« F.map X.hom â‰« Î².app X.right }\n  map {X Y} Ï† :=\n    { left := Fâ‚.map Ï†.left\n      right := Fâ‚‚.map Ï†.right\n      w := by\n        dsimp\n        rw [assoc, assoc]\n        erw [Î±.naturality_assoc, â† Î².naturality]\n        dsimp\n        rw [â† F.map_comp_assoc, â† F.map_comp_assoc, Ï†.w] }\n\n"}
{"name":"CategoryTheory.Comma.map_map_left","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœâµ : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœÂ³ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nA' : Type uâ‚„\ninstâœÂ² : CategoryTheory.Category.{vâ‚„, uâ‚„} A'\nB' : Type uâ‚…\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚…, uâ‚…} B'\nT' : Type uâ‚†\ninstâœ : CategoryTheory.Category.{vâ‚†, uâ‚†} T'\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nL' : CategoryTheory.Functor A' T'\nR' : CategoryTheory.Functor B' T'\nFâ‚ : CategoryTheory.Functor A A'\nFâ‚‚ : CategoryTheory.Functor B B'\nF : CategoryTheory.Functor T T'\nÎ± : Quiver.Hom (Fâ‚.comp L') (L.comp F)\nÎ² : Quiver.Hom (R.comp F) (Fâ‚‚.comp R')\nX Y : CategoryTheory.Comma L R\nÏ† : Quiver.Hom X Y\nâŠ¢ Eq ((CategoryTheory.Comma.map Î± Î²).map Ï†).left (Fâ‚.map Ï†.left)","decl":"/-- The functor `Comma L R â¥¤ Comma L' R'` induced by three functors `Fâ‚`, `Fâ‚‚`, `F`\nand two natural transformations `Fâ‚ â‹™ L' âŸ¶ L â‹™ F` and `R â‹™ F âŸ¶ Fâ‚‚ â‹™ R'`. -/\n@[simps]\ndef map : Comma L R â¥¤ Comma L' R' where\n  obj X :=\n    { left := Fâ‚.obj X.left\n      right := Fâ‚‚.obj X.right\n      hom := Î±.app X.left â‰« F.map X.hom â‰« Î².app X.right }\n  map {X Y} Ï† :=\n    { left := Fâ‚.map Ï†.left\n      right := Fâ‚‚.map Ï†.right\n      w := by\n        dsimp\n        rw [assoc, assoc]\n        erw [Î±.naturality_assoc, â† Î².naturality]\n        dsimp\n        rw [â† F.map_comp_assoc, â† F.map_comp_assoc, Ï†.w] }\n\n"}
{"name":"CategoryTheory.Comma.map_map_right","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœâµ : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœÂ³ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nA' : Type uâ‚„\ninstâœÂ² : CategoryTheory.Category.{vâ‚„, uâ‚„} A'\nB' : Type uâ‚…\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚…, uâ‚…} B'\nT' : Type uâ‚†\ninstâœ : CategoryTheory.Category.{vâ‚†, uâ‚†} T'\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nL' : CategoryTheory.Functor A' T'\nR' : CategoryTheory.Functor B' T'\nFâ‚ : CategoryTheory.Functor A A'\nFâ‚‚ : CategoryTheory.Functor B B'\nF : CategoryTheory.Functor T T'\nÎ± : Quiver.Hom (Fâ‚.comp L') (L.comp F)\nÎ² : Quiver.Hom (R.comp F) (Fâ‚‚.comp R')\nX Y : CategoryTheory.Comma L R\nÏ† : Quiver.Hom X Y\nâŠ¢ Eq ((CategoryTheory.Comma.map Î± Î²).map Ï†).right (Fâ‚‚.map Ï†.right)","decl":"/-- The functor `Comma L R â¥¤ Comma L' R'` induced by three functors `Fâ‚`, `Fâ‚‚`, `F`\nand two natural transformations `Fâ‚ â‹™ L' âŸ¶ L â‹™ F` and `R â‹™ F âŸ¶ Fâ‚‚ â‹™ R'`. -/\n@[simps]\ndef map : Comma L R â¥¤ Comma L' R' where\n  obj X :=\n    { left := Fâ‚.obj X.left\n      right := Fâ‚‚.obj X.right\n      hom := Î±.app X.left â‰« F.map X.hom â‰« Î².app X.right }\n  map {X Y} Ï† :=\n    { left := Fâ‚.map Ï†.left\n      right := Fâ‚‚.map Ï†.right\n      w := by\n        dsimp\n        rw [assoc, assoc]\n        erw [Î±.naturality_assoc, â† Î².naturality]\n        dsimp\n        rw [â† F.map_comp_assoc, â† F.map_comp_assoc, Ï†.w] }\n\n"}
{"name":"CategoryTheory.Comma.map_obj_left","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœâµ : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœÂ³ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nA' : Type uâ‚„\ninstâœÂ² : CategoryTheory.Category.{vâ‚„, uâ‚„} A'\nB' : Type uâ‚…\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚…, uâ‚…} B'\nT' : Type uâ‚†\ninstâœ : CategoryTheory.Category.{vâ‚†, uâ‚†} T'\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nL' : CategoryTheory.Functor A' T'\nR' : CategoryTheory.Functor B' T'\nFâ‚ : CategoryTheory.Functor A A'\nFâ‚‚ : CategoryTheory.Functor B B'\nF : CategoryTheory.Functor T T'\nÎ± : Quiver.Hom (Fâ‚.comp L') (L.comp F)\nÎ² : Quiver.Hom (R.comp F) (Fâ‚‚.comp R')\nX : CategoryTheory.Comma L R\nâŠ¢ Eq ((CategoryTheory.Comma.map Î± Î²).obj X).left (Fâ‚.obj X.left)","decl":"/-- The functor `Comma L R â¥¤ Comma L' R'` induced by three functors `Fâ‚`, `Fâ‚‚`, `F`\nand two natural transformations `Fâ‚ â‹™ L' âŸ¶ L â‹™ F` and `R â‹™ F âŸ¶ Fâ‚‚ â‹™ R'`. -/\n@[simps]\ndef map : Comma L R â¥¤ Comma L' R' where\n  obj X :=\n    { left := Fâ‚.obj X.left\n      right := Fâ‚‚.obj X.right\n      hom := Î±.app X.left â‰« F.map X.hom â‰« Î².app X.right }\n  map {X Y} Ï† :=\n    { left := Fâ‚.map Ï†.left\n      right := Fâ‚‚.map Ï†.right\n      w := by\n        dsimp\n        rw [assoc, assoc]\n        erw [Î±.naturality_assoc, â† Î².naturality]\n        dsimp\n        rw [â† F.map_comp_assoc, â† F.map_comp_assoc, Ï†.w] }\n\n"}
{"name":"CategoryTheory.Comma.map_obj_right","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœâµ : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœÂ³ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nA' : Type uâ‚„\ninstâœÂ² : CategoryTheory.Category.{vâ‚„, uâ‚„} A'\nB' : Type uâ‚…\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚…, uâ‚…} B'\nT' : Type uâ‚†\ninstâœ : CategoryTheory.Category.{vâ‚†, uâ‚†} T'\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nL' : CategoryTheory.Functor A' T'\nR' : CategoryTheory.Functor B' T'\nFâ‚ : CategoryTheory.Functor A A'\nFâ‚‚ : CategoryTheory.Functor B B'\nF : CategoryTheory.Functor T T'\nÎ± : Quiver.Hom (Fâ‚.comp L') (L.comp F)\nÎ² : Quiver.Hom (R.comp F) (Fâ‚‚.comp R')\nX : CategoryTheory.Comma L R\nâŠ¢ Eq ((CategoryTheory.Comma.map Î± Î²).obj X).right (Fâ‚‚.obj X.right)","decl":"/-- The functor `Comma L R â¥¤ Comma L' R'` induced by three functors `Fâ‚`, `Fâ‚‚`, `F`\nand two natural transformations `Fâ‚ â‹™ L' âŸ¶ L â‹™ F` and `R â‹™ F âŸ¶ Fâ‚‚ â‹™ R'`. -/\n@[simps]\ndef map : Comma L R â¥¤ Comma L' R' where\n  obj X :=\n    { left := Fâ‚.obj X.left\n      right := Fâ‚‚.obj X.right\n      hom := Î±.app X.left â‰« F.map X.hom â‰« Î².app X.right }\n  map {X Y} Ï† :=\n    { left := Fâ‚.map Ï†.left\n      right := Fâ‚‚.map Ï†.right\n      w := by\n        dsimp\n        rw [assoc, assoc]\n        erw [Î±.naturality_assoc, â† Î².naturality]\n        dsimp\n        rw [â† F.map_comp_assoc, â† F.map_comp_assoc, Ï†.w] }\n\n"}
{"name":"CategoryTheory.Comma.faithful_map","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœâ· : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœâ¶ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœâµ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nA' : Type uâ‚„\ninstâœâ´ : CategoryTheory.Category.{vâ‚„, uâ‚„} A'\nB' : Type uâ‚…\ninstâœÂ³ : CategoryTheory.Category.{vâ‚…, uâ‚…} B'\nT' : Type uâ‚†\ninstâœÂ² : CategoryTheory.Category.{vâ‚†, uâ‚†} T'\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nL' : CategoryTheory.Functor A' T'\nR' : CategoryTheory.Functor B' T'\nFâ‚ : CategoryTheory.Functor A A'\nFâ‚‚ : CategoryTheory.Functor B B'\nF : CategoryTheory.Functor T T'\nÎ± : Quiver.Hom (Fâ‚.comp L') (L.comp F)\nÎ² : Quiver.Hom (R.comp F) (Fâ‚‚.comp R')\ninstâœÂ¹ : Fâ‚.Faithful\ninstâœ : Fâ‚‚.Faithful\nâŠ¢ (CategoryTheory.Comma.map Î± Î²).Faithful","decl":"instance faithful_map [Fâ‚.Faithful] [Fâ‚‚.Faithful] : (map Î± Î²).Faithful where\n  map_injective {X Y} f g h := by\n    ext\n    Â· exact Fâ‚.map_injective (congr_arg CommaMorphism.left h)\n    Â· exact Fâ‚‚.map_injective (congr_arg CommaMorphism.right h)\n\n"}
{"name":"CategoryTheory.Comma.full_map","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœÂ¹â° : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœâ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœâ¸ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nA' : Type uâ‚„\ninstâœâ· : CategoryTheory.Category.{vâ‚„, uâ‚„} A'\nB' : Type uâ‚…\ninstâœâ¶ : CategoryTheory.Category.{vâ‚…, uâ‚…} B'\nT' : Type uâ‚†\ninstâœâµ : CategoryTheory.Category.{vâ‚†, uâ‚†} T'\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nL' : CategoryTheory.Functor A' T'\nR' : CategoryTheory.Functor B' T'\nFâ‚ : CategoryTheory.Functor A A'\nFâ‚‚ : CategoryTheory.Functor B B'\nF : CategoryTheory.Functor T T'\nÎ± : Quiver.Hom (Fâ‚.comp L') (L.comp F)\nÎ² : Quiver.Hom (R.comp F) (Fâ‚‚.comp R')\ninstâœâ´ : F.Faithful\ninstâœÂ³ : Fâ‚.Full\ninstâœÂ² : Fâ‚‚.Full\ninstâœÂ¹ : CategoryTheory.IsIso Î±\ninstâœ : CategoryTheory.IsIso Î²\nâŠ¢ (CategoryTheory.Comma.map Î± Î²).Full","decl":"instance full_map [F.Faithful] [Fâ‚.Full] [Fâ‚‚.Full] [IsIso Î±] [IsIso Î²] : (map Î± Î²).Full where\n  map_surjective {X Y} Ï† :=\n   âŸ¨{ left := Fâ‚.preimage Ï†.left\n      right := Fâ‚‚.preimage Ï†.right\n      w := F.map_injective (by\n        rw [â† cancel_mono (Î².app _), â† cancel_epi (Î±.app _), F.map_comp, F.map_comp,\n          assoc, assoc]\n        erw [â† Î±.naturality_assoc, Î².naturality]\n        dsimp\n        rw [Fâ‚.map_preimage, Fâ‚‚.map_preimage]\n        simpa using Ï†.w) }, by aesop_catâŸ©\n\n"}
{"name":"CategoryTheory.Comma.essSurj_map","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœÂ¹â° : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœâ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœâ¸ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nA' : Type uâ‚„\ninstâœâ· : CategoryTheory.Category.{vâ‚„, uâ‚„} A'\nB' : Type uâ‚…\ninstâœâ¶ : CategoryTheory.Category.{vâ‚…, uâ‚…} B'\nT' : Type uâ‚†\ninstâœâµ : CategoryTheory.Category.{vâ‚†, uâ‚†} T'\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nL' : CategoryTheory.Functor A' T'\nR' : CategoryTheory.Functor B' T'\nFâ‚ : CategoryTheory.Functor A A'\nFâ‚‚ : CategoryTheory.Functor B B'\nF : CategoryTheory.Functor T T'\nÎ± : Quiver.Hom (Fâ‚.comp L') (L.comp F)\nÎ² : Quiver.Hom (R.comp F) (Fâ‚‚.comp R')\ninstâœâ´ : Fâ‚.EssSurj\ninstâœÂ³ : Fâ‚‚.EssSurj\ninstâœÂ² : F.Full\ninstâœÂ¹ : CategoryTheory.IsIso Î±\ninstâœ : CategoryTheory.IsIso Î²\nâŠ¢ (CategoryTheory.Comma.map Î± Î²).EssSurj","decl":"instance essSurj_map [Fâ‚.EssSurj] [Fâ‚‚.EssSurj] [F.Full] [IsIso Î±] [IsIso Î²] :\n    (map Î± Î²).EssSurj where\n  mem_essImage X :=\n    âŸ¨{  left := Fâ‚.objPreimage X.left\n        right := Fâ‚‚.objPreimage X.right\n        hom := F.preimage ((inv Î±).app _ â‰« L'.map (Fâ‚.objObjPreimageIso X.left).hom â‰«\n          X.hom â‰« R'.map (Fâ‚‚.objObjPreimageIso X.right).inv â‰« (inv Î²).app _) },\n            âŸ¨isoMk (Fâ‚.objObjPreimageIso X.left) (Fâ‚‚.objObjPreimageIso X.right) (by\n              dsimp\n              simp only [NatIso.isIso_inv_app, Functor.comp_obj, Functor.map_preimage, assoc,\n                IsIso.inv_hom_id, comp_id, IsIso.hom_inv_id_assoc]\n              rw [â† R'.map_comp, Iso.inv_hom_id, R'.map_id, comp_id])âŸ©âŸ©\n\n"}
{"name":"CategoryTheory.Comma.isEquivalenceMap","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœÂ¹Â¹ : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœÂ¹â° : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœâ¹ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nA' : Type uâ‚„\ninstâœâ¸ : CategoryTheory.Category.{vâ‚„, uâ‚„} A'\nB' : Type uâ‚…\ninstâœâ· : CategoryTheory.Category.{vâ‚…, uâ‚…} B'\nT' : Type uâ‚†\ninstâœâ¶ : CategoryTheory.Category.{vâ‚†, uâ‚†} T'\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nL' : CategoryTheory.Functor A' T'\nR' : CategoryTheory.Functor B' T'\nFâ‚ : CategoryTheory.Functor A A'\nFâ‚‚ : CategoryTheory.Functor B B'\nF : CategoryTheory.Functor T T'\nÎ± : Quiver.Hom (Fâ‚.comp L') (L.comp F)\nÎ² : Quiver.Hom (R.comp F) (Fâ‚‚.comp R')\ninstâœâµ : Fâ‚.IsEquivalence\ninstâœâ´ : Fâ‚‚.IsEquivalence\ninstâœÂ³ : F.Faithful\ninstâœÂ² : F.Full\ninstâœÂ¹ : CategoryTheory.IsIso Î±\ninstâœ : CategoryTheory.IsIso Î²\nâŠ¢ (CategoryTheory.Comma.map Î± Î²).IsEquivalence","decl":"noncomputable instance isEquivalenceMap\n    [Fâ‚.IsEquivalence] [Fâ‚‚.IsEquivalence] [F.Faithful] [F.Full] [IsIso Î±] [IsIso Î²] :\n    (map Î± Î²).IsEquivalence where\n\n"}
{"name":"CategoryTheory.Comma.map_fst","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœâµ : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœÂ³ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nA' : Type uâ‚„\ninstâœÂ² : CategoryTheory.Category.{vâ‚„, uâ‚„} A'\nB' : Type uâ‚…\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚…, uâ‚…} B'\nT' : Type uâ‚†\ninstâœ : CategoryTheory.Category.{vâ‚†, uâ‚†} T'\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nL' : CategoryTheory.Functor A' T'\nR' : CategoryTheory.Functor B' T'\nFâ‚ : CategoryTheory.Functor A A'\nFâ‚‚ : CategoryTheory.Functor B B'\nF : CategoryTheory.Functor T T'\nÎ± : Quiver.Hom (Fâ‚.comp L') (L.comp F)\nÎ² : Quiver.Hom (R.comp F) (Fâ‚‚.comp R')\nâŠ¢ Eq ((CategoryTheory.Comma.map Î± Î²).comp (CategoryTheory.Comma.fst L' R')) ((CategoryTheory.Comma.fst L R).comp Fâ‚)","decl":"/-- The equality between `map Î± Î² â‹™ fst L' R'` and `fst L R â‹™ Fâ‚`,\nwhere `Î± : Fâ‚ â‹™ L' âŸ¶ L â‹™ F`. -/\n@[simp]\ntheorem map_fst : map Î± Î² â‹™ fst L' R' = fst L R â‹™ Fâ‚ :=\n  rfl\n\n"}
{"name":"CategoryTheory.Comma.mapFst_inv_app","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœâµ : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœÂ³ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nA' : Type uâ‚„\ninstâœÂ² : CategoryTheory.Category.{vâ‚„, uâ‚„} A'\nB' : Type uâ‚…\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚…, uâ‚…} B'\nT' : Type uâ‚†\ninstâœ : CategoryTheory.Category.{vâ‚†, uâ‚†} T'\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nL' : CategoryTheory.Functor A' T'\nR' : CategoryTheory.Functor B' T'\nFâ‚ : CategoryTheory.Functor A A'\nFâ‚‚ : CategoryTheory.Functor B B'\nF : CategoryTheory.Functor T T'\nÎ± : Quiver.Hom (Fâ‚.comp L') (L.comp F)\nÎ² : Quiver.Hom (R.comp F) (Fâ‚‚.comp R')\nX : CategoryTheory.Comma L R\nâŠ¢ Eq ((CategoryTheory.Comma.mapFst Î± Î²).inv.app X) (CategoryTheory.CategoryStruct.id (Fâ‚.obj X.left))","decl":"/-- The isomorphism between `map Î± Î² â‹™ fst L' R'` and `fst L R â‹™ Fâ‚`,\nwhere `Î± : Fâ‚ â‹™ L' âŸ¶ L â‹™ F`. -/\n@[simps!]\ndef mapFst : map Î± Î² â‹™ fst L' R' â‰… fst L R â‹™ Fâ‚ :=\n  NatIso.ofComponents (fun _ => Iso.refl _) (by simp)\n\n"}
{"name":"CategoryTheory.Comma.mapFst_hom_app","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœâµ : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœÂ³ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nA' : Type uâ‚„\ninstâœÂ² : CategoryTheory.Category.{vâ‚„, uâ‚„} A'\nB' : Type uâ‚…\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚…, uâ‚…} B'\nT' : Type uâ‚†\ninstâœ : CategoryTheory.Category.{vâ‚†, uâ‚†} T'\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nL' : CategoryTheory.Functor A' T'\nR' : CategoryTheory.Functor B' T'\nFâ‚ : CategoryTheory.Functor A A'\nFâ‚‚ : CategoryTheory.Functor B B'\nF : CategoryTheory.Functor T T'\nÎ± : Quiver.Hom (Fâ‚.comp L') (L.comp F)\nÎ² : Quiver.Hom (R.comp F) (Fâ‚‚.comp R')\nX : CategoryTheory.Comma L R\nâŠ¢ Eq ((CategoryTheory.Comma.mapFst Î± Î²).hom.app X) (CategoryTheory.CategoryStruct.id (Fâ‚.obj X.left))","decl":"/-- The isomorphism between `map Î± Î² â‹™ fst L' R'` and `fst L R â‹™ Fâ‚`,\nwhere `Î± : Fâ‚ â‹™ L' âŸ¶ L â‹™ F`. -/\n@[simps!]\ndef mapFst : map Î± Î² â‹™ fst L' R' â‰… fst L R â‹™ Fâ‚ :=\n  NatIso.ofComponents (fun _ => Iso.refl _) (by simp)\n\n"}
{"name":"CategoryTheory.Comma.map_snd","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœâµ : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœÂ³ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nA' : Type uâ‚„\ninstâœÂ² : CategoryTheory.Category.{vâ‚„, uâ‚„} A'\nB' : Type uâ‚…\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚…, uâ‚…} B'\nT' : Type uâ‚†\ninstâœ : CategoryTheory.Category.{vâ‚†, uâ‚†} T'\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nL' : CategoryTheory.Functor A' T'\nR' : CategoryTheory.Functor B' T'\nFâ‚ : CategoryTheory.Functor A A'\nFâ‚‚ : CategoryTheory.Functor B B'\nF : CategoryTheory.Functor T T'\nÎ± : Quiver.Hom (Fâ‚.comp L') (L.comp F)\nÎ² : Quiver.Hom (R.comp F) (Fâ‚‚.comp R')\nâŠ¢ Eq ((CategoryTheory.Comma.map Î± Î²).comp (CategoryTheory.Comma.snd L' R')) ((CategoryTheory.Comma.snd L R).comp Fâ‚‚)","decl":"/-- The equality between `map Î± Î² â‹™ snd L' R'` and `snd L R â‹™ Fâ‚‚`,\nwhere `Î² : R â‹™ F âŸ¶ Fâ‚‚ â‹™ R'`. -/\n@[simp]\ntheorem map_snd : map Î± Î² â‹™ snd L' R' = snd L R â‹™ Fâ‚‚ :=\n  rfl\n\n"}
{"name":"CategoryTheory.Comma.mapSnd_inv_app","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœâµ : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœÂ³ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nA' : Type uâ‚„\ninstâœÂ² : CategoryTheory.Category.{vâ‚„, uâ‚„} A'\nB' : Type uâ‚…\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚…, uâ‚…} B'\nT' : Type uâ‚†\ninstâœ : CategoryTheory.Category.{vâ‚†, uâ‚†} T'\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nL' : CategoryTheory.Functor A' T'\nR' : CategoryTheory.Functor B' T'\nFâ‚ : CategoryTheory.Functor A A'\nFâ‚‚ : CategoryTheory.Functor B B'\nF : CategoryTheory.Functor T T'\nÎ± : Quiver.Hom (Fâ‚.comp L') (L.comp F)\nÎ² : Quiver.Hom (R.comp F) (Fâ‚‚.comp R')\nX : CategoryTheory.Comma L R\nâŠ¢ Eq ((CategoryTheory.Comma.mapSnd Î± Î²).inv.app X) (CategoryTheory.CategoryStruct.id (Fâ‚‚.obj X.right))","decl":"/-- The isomorphism between `map Î± Î² â‹™ snd L' R'` and `snd L R â‹™ Fâ‚‚`,\nwhere `Î² : R â‹™ F âŸ¶ Fâ‚‚ â‹™ R'`. -/\n@[simps!]\ndef mapSnd : map Î± Î² â‹™ snd L' R' â‰… snd L R â‹™ Fâ‚‚ :=\n  NatIso.ofComponents (fun _ => Iso.refl _) (by simp)\n\n"}
{"name":"CategoryTheory.Comma.mapSnd_hom_app","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœâµ : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœÂ³ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nA' : Type uâ‚„\ninstâœÂ² : CategoryTheory.Category.{vâ‚„, uâ‚„} A'\nB' : Type uâ‚…\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚…, uâ‚…} B'\nT' : Type uâ‚†\ninstâœ : CategoryTheory.Category.{vâ‚†, uâ‚†} T'\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nL' : CategoryTheory.Functor A' T'\nR' : CategoryTheory.Functor B' T'\nFâ‚ : CategoryTheory.Functor A A'\nFâ‚‚ : CategoryTheory.Functor B B'\nF : CategoryTheory.Functor T T'\nÎ± : Quiver.Hom (Fâ‚.comp L') (L.comp F)\nÎ² : Quiver.Hom (R.comp F) (Fâ‚‚.comp R')\nX : CategoryTheory.Comma L R\nâŠ¢ Eq ((CategoryTheory.Comma.mapSnd Î± Î²).hom.app X) (CategoryTheory.CategoryStruct.id (Fâ‚‚.obj X.right))","decl":"/-- The isomorphism between `map Î± Î² â‹™ snd L' R'` and `snd L R â‹™ Fâ‚‚`,\nwhere `Î² : R â‹™ F âŸ¶ Fâ‚‚ â‹™ R'`. -/\n@[simps!]\ndef mapSnd : map Î± Î² â‹™ snd L' R' â‰… snd L R â‹™ Fâ‚‚ :=\n  NatIso.ofComponents (fun _ => Iso.refl _) (by simp)\n\n"}
{"name":"CategoryTheory.Comma.mapLeft_map_left","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nR : CategoryTheory.Functor B T\nLâ‚ Lâ‚‚ : CategoryTheory.Functor A T\nl : Quiver.Hom Lâ‚ Lâ‚‚\nXâœ Yâœ : CategoryTheory.Comma Lâ‚‚ R\nf : Quiver.Hom Xâœ Yâœ\nâŠ¢ Eq ((CategoryTheory.Comma.mapLeft R l).map f).left f.left","decl":"/-- A natural transformation `Lâ‚ âŸ¶ Lâ‚‚` induces a functor `Comma Lâ‚‚ R â¥¤ Comma Lâ‚ R`. -/\n@[simps]\ndef mapLeft (l : Lâ‚ âŸ¶ Lâ‚‚) : Comma Lâ‚‚ R â¥¤ Comma Lâ‚ R where\n  obj X :=\n    { left := X.left\n      right := X.right\n      hom := l.app X.left â‰« X.hom }\n  map f :=\n    { left := f.left\n      right := f.right }\n\n"}
{"name":"CategoryTheory.Comma.mapLeft_obj_hom","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nR : CategoryTheory.Functor B T\nLâ‚ Lâ‚‚ : CategoryTheory.Functor A T\nl : Quiver.Hom Lâ‚ Lâ‚‚\nX : CategoryTheory.Comma Lâ‚‚ R\nâŠ¢ Eq ((CategoryTheory.Comma.mapLeft R l).obj X).hom (CategoryTheory.CategoryStruct.comp (l.app X.left) X.hom)","decl":"/-- A natural transformation `Lâ‚ âŸ¶ Lâ‚‚` induces a functor `Comma Lâ‚‚ R â¥¤ Comma Lâ‚ R`. -/\n@[simps]\ndef mapLeft (l : Lâ‚ âŸ¶ Lâ‚‚) : Comma Lâ‚‚ R â¥¤ Comma Lâ‚ R where\n  obj X :=\n    { left := X.left\n      right := X.right\n      hom := l.app X.left â‰« X.hom }\n  map f :=\n    { left := f.left\n      right := f.right }\n\n"}
{"name":"CategoryTheory.Comma.mapLeft_map_right","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nR : CategoryTheory.Functor B T\nLâ‚ Lâ‚‚ : CategoryTheory.Functor A T\nl : Quiver.Hom Lâ‚ Lâ‚‚\nXâœ Yâœ : CategoryTheory.Comma Lâ‚‚ R\nf : Quiver.Hom Xâœ Yâœ\nâŠ¢ Eq ((CategoryTheory.Comma.mapLeft R l).map f).right f.right","decl":"/-- A natural transformation `Lâ‚ âŸ¶ Lâ‚‚` induces a functor `Comma Lâ‚‚ R â¥¤ Comma Lâ‚ R`. -/\n@[simps]\ndef mapLeft (l : Lâ‚ âŸ¶ Lâ‚‚) : Comma Lâ‚‚ R â¥¤ Comma Lâ‚ R where\n  obj X :=\n    { left := X.left\n      right := X.right\n      hom := l.app X.left â‰« X.hom }\n  map f :=\n    { left := f.left\n      right := f.right }\n\n"}
{"name":"CategoryTheory.Comma.mapLeft_obj_right","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nR : CategoryTheory.Functor B T\nLâ‚ Lâ‚‚ : CategoryTheory.Functor A T\nl : Quiver.Hom Lâ‚ Lâ‚‚\nX : CategoryTheory.Comma Lâ‚‚ R\nâŠ¢ Eq ((CategoryTheory.Comma.mapLeft R l).obj X).right X.right","decl":"/-- A natural transformation `Lâ‚ âŸ¶ Lâ‚‚` induces a functor `Comma Lâ‚‚ R â¥¤ Comma Lâ‚ R`. -/\n@[simps]\ndef mapLeft (l : Lâ‚ âŸ¶ Lâ‚‚) : Comma Lâ‚‚ R â¥¤ Comma Lâ‚ R where\n  obj X :=\n    { left := X.left\n      right := X.right\n      hom := l.app X.left â‰« X.hom }\n  map f :=\n    { left := f.left\n      right := f.right }\n\n"}
{"name":"CategoryTheory.Comma.mapLeft_obj_left","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nR : CategoryTheory.Functor B T\nLâ‚ Lâ‚‚ : CategoryTheory.Functor A T\nl : Quiver.Hom Lâ‚ Lâ‚‚\nX : CategoryTheory.Comma Lâ‚‚ R\nâŠ¢ Eq ((CategoryTheory.Comma.mapLeft R l).obj X).left X.left","decl":"/-- A natural transformation `Lâ‚ âŸ¶ Lâ‚‚` induces a functor `Comma Lâ‚‚ R â¥¤ Comma Lâ‚ R`. -/\n@[simps]\ndef mapLeft (l : Lâ‚ âŸ¶ Lâ‚‚) : Comma Lâ‚‚ R â¥¤ Comma Lâ‚ R where\n  obj X :=\n    { left := X.left\n      right := X.right\n      hom := l.app X.left â‰« X.hom }\n  map f :=\n    { left := f.left\n      right := f.right }\n\n"}
{"name":"CategoryTheory.Comma.mapLeftId_inv_app_right","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nX : CategoryTheory.Comma L R\nâŠ¢ Eq ((CategoryTheory.Comma.mapLeftId L R).inv.app X).right (CategoryTheory.CategoryStruct.id X.right)","decl":"/-- The functor `Comma L R â¥¤ Comma L R` induced by the identity natural transformation on `L` is\n    naturally isomorphic to the identity functor. -/\n@[simps!]\ndef mapLeftId : mapLeft R (ğŸ™ L) â‰… ğŸ­ _ :=\n  NatIso.ofComponents (fun X => isoMk (Iso.refl _) (Iso.refl _))\n\n"}
{"name":"CategoryTheory.Comma.mapLeftId_inv_app_left","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nX : CategoryTheory.Comma L R\nâŠ¢ Eq ((CategoryTheory.Comma.mapLeftId L R).inv.app X).left (CategoryTheory.CategoryStruct.id X.left)","decl":"/-- The functor `Comma L R â¥¤ Comma L R` induced by the identity natural transformation on `L` is\n    naturally isomorphic to the identity functor. -/\n@[simps!]\ndef mapLeftId : mapLeft R (ğŸ™ L) â‰… ğŸ­ _ :=\n  NatIso.ofComponents (fun X => isoMk (Iso.refl _) (Iso.refl _))\n\n"}
{"name":"CategoryTheory.Comma.mapLeftId_hom_app_left","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nX : CategoryTheory.Comma L R\nâŠ¢ Eq ((CategoryTheory.Comma.mapLeftId L R).hom.app X).left (CategoryTheory.CategoryStruct.id X.left)","decl":"/-- The functor `Comma L R â¥¤ Comma L R` induced by the identity natural transformation on `L` is\n    naturally isomorphic to the identity functor. -/\n@[simps!]\ndef mapLeftId : mapLeft R (ğŸ™ L) â‰… ğŸ­ _ :=\n  NatIso.ofComponents (fun X => isoMk (Iso.refl _) (Iso.refl _))\n\n"}
{"name":"CategoryTheory.Comma.mapLeftId_hom_app_right","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nX : CategoryTheory.Comma L R\nâŠ¢ Eq ((CategoryTheory.Comma.mapLeftId L R).hom.app X).right (CategoryTheory.CategoryStruct.id X.right)","decl":"/-- The functor `Comma L R â¥¤ Comma L R` induced by the identity natural transformation on `L` is\n    naturally isomorphic to the identity functor. -/\n@[simps!]\ndef mapLeftId : mapLeft R (ğŸ™ L) â‰… ğŸ­ _ :=\n  NatIso.ofComponents (fun X => isoMk (Iso.refl _) (Iso.refl _))\n\n"}
{"name":"CategoryTheory.Comma.mapLeftComp_inv_app_left","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nR : CategoryTheory.Functor B T\nLâ‚ Lâ‚‚ Lâ‚ƒ : CategoryTheory.Functor A T\nl : Quiver.Hom Lâ‚ Lâ‚‚\nl' : Quiver.Hom Lâ‚‚ Lâ‚ƒ\nX : CategoryTheory.Comma Lâ‚ƒ R\nâŠ¢ Eq ((CategoryTheory.Comma.mapLeftComp R l l').inv.app X).left (CategoryTheory.CategoryStruct.id X.left)","decl":"/-- The functor `Comma Lâ‚ R â¥¤ Comma Lâ‚ƒ R` induced by the composition of two natural transformations\n    `l : Lâ‚ âŸ¶ Lâ‚‚` and `l' : Lâ‚‚ âŸ¶ Lâ‚ƒ` is naturally isomorphic to the composition of the two functors\n    induced by these natural transformations. -/\n@[simps!]\ndef mapLeftComp (l : Lâ‚ âŸ¶ Lâ‚‚) (l' : Lâ‚‚ âŸ¶ Lâ‚ƒ) :\n    mapLeft R (l â‰« l') â‰… mapLeft R l' â‹™ mapLeft R l :=\n  NatIso.ofComponents (fun X => isoMk (Iso.refl _) (Iso.refl _))\n\n"}
{"name":"CategoryTheory.Comma.mapLeftComp_hom_app_right","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nR : CategoryTheory.Functor B T\nLâ‚ Lâ‚‚ Lâ‚ƒ : CategoryTheory.Functor A T\nl : Quiver.Hom Lâ‚ Lâ‚‚\nl' : Quiver.Hom Lâ‚‚ Lâ‚ƒ\nX : CategoryTheory.Comma Lâ‚ƒ R\nâŠ¢ Eq ((CategoryTheory.Comma.mapLeftComp R l l').hom.app X).right (CategoryTheory.CategoryStruct.id X.right)","decl":"/-- The functor `Comma Lâ‚ R â¥¤ Comma Lâ‚ƒ R` induced by the composition of two natural transformations\n    `l : Lâ‚ âŸ¶ Lâ‚‚` and `l' : Lâ‚‚ âŸ¶ Lâ‚ƒ` is naturally isomorphic to the composition of the two functors\n    induced by these natural transformations. -/\n@[simps!]\ndef mapLeftComp (l : Lâ‚ âŸ¶ Lâ‚‚) (l' : Lâ‚‚ âŸ¶ Lâ‚ƒ) :\n    mapLeft R (l â‰« l') â‰… mapLeft R l' â‹™ mapLeft R l :=\n  NatIso.ofComponents (fun X => isoMk (Iso.refl _) (Iso.refl _))\n\n"}
{"name":"CategoryTheory.Comma.mapLeftComp_inv_app_right","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nR : CategoryTheory.Functor B T\nLâ‚ Lâ‚‚ Lâ‚ƒ : CategoryTheory.Functor A T\nl : Quiver.Hom Lâ‚ Lâ‚‚\nl' : Quiver.Hom Lâ‚‚ Lâ‚ƒ\nX : CategoryTheory.Comma Lâ‚ƒ R\nâŠ¢ Eq ((CategoryTheory.Comma.mapLeftComp R l l').inv.app X).right (CategoryTheory.CategoryStruct.id X.right)","decl":"/-- The functor `Comma Lâ‚ R â¥¤ Comma Lâ‚ƒ R` induced by the composition of two natural transformations\n    `l : Lâ‚ âŸ¶ Lâ‚‚` and `l' : Lâ‚‚ âŸ¶ Lâ‚ƒ` is naturally isomorphic to the composition of the two functors\n    induced by these natural transformations. -/\n@[simps!]\ndef mapLeftComp (l : Lâ‚ âŸ¶ Lâ‚‚) (l' : Lâ‚‚ âŸ¶ Lâ‚ƒ) :\n    mapLeft R (l â‰« l') â‰… mapLeft R l' â‹™ mapLeft R l :=\n  NatIso.ofComponents (fun X => isoMk (Iso.refl _) (Iso.refl _))\n\n"}
{"name":"CategoryTheory.Comma.mapLeftComp_hom_app_left","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nR : CategoryTheory.Functor B T\nLâ‚ Lâ‚‚ Lâ‚ƒ : CategoryTheory.Functor A T\nl : Quiver.Hom Lâ‚ Lâ‚‚\nl' : Quiver.Hom Lâ‚‚ Lâ‚ƒ\nX : CategoryTheory.Comma Lâ‚ƒ R\nâŠ¢ Eq ((CategoryTheory.Comma.mapLeftComp R l l').hom.app X).left (CategoryTheory.CategoryStruct.id X.left)","decl":"/-- The functor `Comma Lâ‚ R â¥¤ Comma Lâ‚ƒ R` induced by the composition of two natural transformations\n    `l : Lâ‚ âŸ¶ Lâ‚‚` and `l' : Lâ‚‚ âŸ¶ Lâ‚ƒ` is naturally isomorphic to the composition of the two functors\n    induced by these natural transformations. -/\n@[simps!]\ndef mapLeftComp (l : Lâ‚ âŸ¶ Lâ‚‚) (l' : Lâ‚‚ âŸ¶ Lâ‚ƒ) :\n    mapLeft R (l â‰« l') â‰… mapLeft R l' â‹™ mapLeft R l :=\n  NatIso.ofComponents (fun X => isoMk (Iso.refl _) (Iso.refl _))\n\n"}
{"name":"CategoryTheory.Comma.mapLeftEq_hom_app_right","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nR : CategoryTheory.Functor B T\nLâ‚ Lâ‚‚ : CategoryTheory.Functor A T\nl l' : Quiver.Hom Lâ‚ Lâ‚‚\nh : Eq l l'\nX : CategoryTheory.Comma Lâ‚‚ R\nâŠ¢ Eq ((CategoryTheory.Comma.mapLeftEq R l l' h).hom.app X).right (CategoryTheory.CategoryStruct.id X.right)","decl":"/-- Two equal natural transformations `Lâ‚ âŸ¶ Lâ‚‚` yield naturally isomorphic functors\n    `Comma Lâ‚ R â¥¤ Comma Lâ‚‚ R`. -/\n@[simps!]\ndef mapLeftEq (l l' : Lâ‚ âŸ¶ Lâ‚‚) (h : l = l') : mapLeft R l â‰… mapLeft R l' :=\n  NatIso.ofComponents (fun X => isoMk (Iso.refl _) (Iso.refl _))\n\n"}
{"name":"CategoryTheory.Comma.mapLeftEq_hom_app_left","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nR : CategoryTheory.Functor B T\nLâ‚ Lâ‚‚ : CategoryTheory.Functor A T\nl l' : Quiver.Hom Lâ‚ Lâ‚‚\nh : Eq l l'\nX : CategoryTheory.Comma Lâ‚‚ R\nâŠ¢ Eq ((CategoryTheory.Comma.mapLeftEq R l l' h).hom.app X).left (CategoryTheory.CategoryStruct.id X.left)","decl":"/-- Two equal natural transformations `Lâ‚ âŸ¶ Lâ‚‚` yield naturally isomorphic functors\n    `Comma Lâ‚ R â¥¤ Comma Lâ‚‚ R`. -/\n@[simps!]\ndef mapLeftEq (l l' : Lâ‚ âŸ¶ Lâ‚‚) (h : l = l') : mapLeft R l â‰… mapLeft R l' :=\n  NatIso.ofComponents (fun X => isoMk (Iso.refl _) (Iso.refl _))\n\n"}
{"name":"CategoryTheory.Comma.mapLeftEq_inv_app_left","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nR : CategoryTheory.Functor B T\nLâ‚ Lâ‚‚ : CategoryTheory.Functor A T\nl l' : Quiver.Hom Lâ‚ Lâ‚‚\nh : Eq l l'\nX : CategoryTheory.Comma Lâ‚‚ R\nâŠ¢ Eq ((CategoryTheory.Comma.mapLeftEq R l l' h).inv.app X).left (CategoryTheory.CategoryStruct.id X.left)","decl":"/-- Two equal natural transformations `Lâ‚ âŸ¶ Lâ‚‚` yield naturally isomorphic functors\n    `Comma Lâ‚ R â¥¤ Comma Lâ‚‚ R`. -/\n@[simps!]\ndef mapLeftEq (l l' : Lâ‚ âŸ¶ Lâ‚‚) (h : l = l') : mapLeft R l â‰… mapLeft R l' :=\n  NatIso.ofComponents (fun X => isoMk (Iso.refl _) (Iso.refl _))\n\n"}
{"name":"CategoryTheory.Comma.mapLeftEq_inv_app_right","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nR : CategoryTheory.Functor B T\nLâ‚ Lâ‚‚ : CategoryTheory.Functor A T\nl l' : Quiver.Hom Lâ‚ Lâ‚‚\nh : Eq l l'\nX : CategoryTheory.Comma Lâ‚‚ R\nâŠ¢ Eq ((CategoryTheory.Comma.mapLeftEq R l l' h).inv.app X).right (CategoryTheory.CategoryStruct.id X.right)","decl":"/-- Two equal natural transformations `Lâ‚ âŸ¶ Lâ‚‚` yield naturally isomorphic functors\n    `Comma Lâ‚ R â¥¤ Comma Lâ‚‚ R`. -/\n@[simps!]\ndef mapLeftEq (l l' : Lâ‚ âŸ¶ Lâ‚‚) (h : l = l') : mapLeft R l â‰… mapLeft R l' :=\n  NatIso.ofComponents (fun X => isoMk (Iso.refl _) (Iso.refl _))\n\n"}
{"name":"CategoryTheory.Comma.mapLeftIso_counitIso_hom_app_left","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nR : CategoryTheory.Functor B T\nLâ‚ Lâ‚‚ : CategoryTheory.Functor A T\ni : CategoryTheory.Iso Lâ‚ Lâ‚‚\nX : CategoryTheory.Comma Lâ‚‚ R\nâŠ¢ Eq ((CategoryTheory.Comma.mapLeftIso R i).counitIso.hom.app X).left (CategoryTheory.CategoryStruct.id X.left)","decl":"/-- A natural isomorphism `Lâ‚ â‰… Lâ‚‚` induces an equivalence of categories\n    `Comma Lâ‚ R â‰Œ Comma Lâ‚‚ R`. -/\n@[simps!]\ndef mapLeftIso (i : Lâ‚ â‰… Lâ‚‚) : Comma Lâ‚ R â‰Œ Comma Lâ‚‚ R where\n  functor := mapLeft _ i.inv\n  inverse := mapLeft _ i.hom\n  unitIso := (mapLeftId _ _).symm â‰ªâ‰« mapLeftEq _ _ _ i.hom_inv_id.symm â‰ªâ‰« mapLeftComp _ _ _\n  counitIso := (mapLeftComp _ _ _).symm â‰ªâ‰« mapLeftEq _ _ _ i.inv_hom_id â‰ªâ‰« mapLeftId _ _\n\n"}
{"name":"CategoryTheory.Comma.mapLeftIso_functor_map_left","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nR : CategoryTheory.Functor B T\nLâ‚ Lâ‚‚ : CategoryTheory.Functor A T\ni : CategoryTheory.Iso Lâ‚ Lâ‚‚\nXâœ Yâœ : CategoryTheory.Comma Lâ‚ R\nf : Quiver.Hom Xâœ Yâœ\nâŠ¢ Eq ((CategoryTheory.Comma.mapLeftIso R i).functor.map f).left f.left","decl":"/-- A natural isomorphism `Lâ‚ â‰… Lâ‚‚` induces an equivalence of categories\n    `Comma Lâ‚ R â‰Œ Comma Lâ‚‚ R`. -/\n@[simps!]\ndef mapLeftIso (i : Lâ‚ â‰… Lâ‚‚) : Comma Lâ‚ R â‰Œ Comma Lâ‚‚ R where\n  functor := mapLeft _ i.inv\n  inverse := mapLeft _ i.hom\n  unitIso := (mapLeftId _ _).symm â‰ªâ‰« mapLeftEq _ _ _ i.hom_inv_id.symm â‰ªâ‰« mapLeftComp _ _ _\n  counitIso := (mapLeftComp _ _ _).symm â‰ªâ‰« mapLeftEq _ _ _ i.inv_hom_id â‰ªâ‰« mapLeftId _ _\n\n"}
{"name":"CategoryTheory.Comma.mapLeftIso_inverse_obj_hom","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nR : CategoryTheory.Functor B T\nLâ‚ Lâ‚‚ : CategoryTheory.Functor A T\ni : CategoryTheory.Iso Lâ‚ Lâ‚‚\nX : CategoryTheory.Comma Lâ‚‚ R\nâŠ¢ Eq ((CategoryTheory.Comma.mapLeftIso R i).inverse.obj X).hom (CategoryTheory.CategoryStruct.comp (i.hom.app X.left) X.hom)","decl":"/-- A natural isomorphism `Lâ‚ â‰… Lâ‚‚` induces an equivalence of categories\n    `Comma Lâ‚ R â‰Œ Comma Lâ‚‚ R`. -/\n@[simps!]\ndef mapLeftIso (i : Lâ‚ â‰… Lâ‚‚) : Comma Lâ‚ R â‰Œ Comma Lâ‚‚ R where\n  functor := mapLeft _ i.inv\n  inverse := mapLeft _ i.hom\n  unitIso := (mapLeftId _ _).symm â‰ªâ‰« mapLeftEq _ _ _ i.hom_inv_id.symm â‰ªâ‰« mapLeftComp _ _ _\n  counitIso := (mapLeftComp _ _ _).symm â‰ªâ‰« mapLeftEq _ _ _ i.inv_hom_id â‰ªâ‰« mapLeftId _ _\n\n"}
{"name":"CategoryTheory.Comma.mapLeftIso_functor_obj_hom","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nR : CategoryTheory.Functor B T\nLâ‚ Lâ‚‚ : CategoryTheory.Functor A T\ni : CategoryTheory.Iso Lâ‚ Lâ‚‚\nX : CategoryTheory.Comma Lâ‚ R\nâŠ¢ Eq ((CategoryTheory.Comma.mapLeftIso R i).functor.obj X).hom (CategoryTheory.CategoryStruct.comp (i.inv.app X.left) X.hom)","decl":"/-- A natural isomorphism `Lâ‚ â‰… Lâ‚‚` induces an equivalence of categories\n    `Comma Lâ‚ R â‰Œ Comma Lâ‚‚ R`. -/\n@[simps!]\ndef mapLeftIso (i : Lâ‚ â‰… Lâ‚‚) : Comma Lâ‚ R â‰Œ Comma Lâ‚‚ R where\n  functor := mapLeft _ i.inv\n  inverse := mapLeft _ i.hom\n  unitIso := (mapLeftId _ _).symm â‰ªâ‰« mapLeftEq _ _ _ i.hom_inv_id.symm â‰ªâ‰« mapLeftComp _ _ _\n  counitIso := (mapLeftComp _ _ _).symm â‰ªâ‰« mapLeftEq _ _ _ i.inv_hom_id â‰ªâ‰« mapLeftId _ _\n\n"}
{"name":"CategoryTheory.Comma.mapLeftIso_counitIso_hom_app_right","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nR : CategoryTheory.Functor B T\nLâ‚ Lâ‚‚ : CategoryTheory.Functor A T\ni : CategoryTheory.Iso Lâ‚ Lâ‚‚\nX : CategoryTheory.Comma Lâ‚‚ R\nâŠ¢ Eq ((CategoryTheory.Comma.mapLeftIso R i).counitIso.hom.app X).right (CategoryTheory.CategoryStruct.id X.right)","decl":"/-- A natural isomorphism `Lâ‚ â‰… Lâ‚‚` induces an equivalence of categories\n    `Comma Lâ‚ R â‰Œ Comma Lâ‚‚ R`. -/\n@[simps!]\ndef mapLeftIso (i : Lâ‚ â‰… Lâ‚‚) : Comma Lâ‚ R â‰Œ Comma Lâ‚‚ R where\n  functor := mapLeft _ i.inv\n  inverse := mapLeft _ i.hom\n  unitIso := (mapLeftId _ _).symm â‰ªâ‰« mapLeftEq _ _ _ i.hom_inv_id.symm â‰ªâ‰« mapLeftComp _ _ _\n  counitIso := (mapLeftComp _ _ _).symm â‰ªâ‰« mapLeftEq _ _ _ i.inv_hom_id â‰ªâ‰« mapLeftId _ _\n\n"}
{"name":"CategoryTheory.Comma.mapLeftIso_functor_obj_left","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nR : CategoryTheory.Functor B T\nLâ‚ Lâ‚‚ : CategoryTheory.Functor A T\ni : CategoryTheory.Iso Lâ‚ Lâ‚‚\nX : CategoryTheory.Comma Lâ‚ R\nâŠ¢ Eq ((CategoryTheory.Comma.mapLeftIso R i).functor.obj X).left X.left","decl":"/-- A natural isomorphism `Lâ‚ â‰… Lâ‚‚` induces an equivalence of categories\n    `Comma Lâ‚ R â‰Œ Comma Lâ‚‚ R`. -/\n@[simps!]\ndef mapLeftIso (i : Lâ‚ â‰… Lâ‚‚) : Comma Lâ‚ R â‰Œ Comma Lâ‚‚ R where\n  functor := mapLeft _ i.inv\n  inverse := mapLeft _ i.hom\n  unitIso := (mapLeftId _ _).symm â‰ªâ‰« mapLeftEq _ _ _ i.hom_inv_id.symm â‰ªâ‰« mapLeftComp _ _ _\n  counitIso := (mapLeftComp _ _ _).symm â‰ªâ‰« mapLeftEq _ _ _ i.inv_hom_id â‰ªâ‰« mapLeftId _ _\n\n"}
{"name":"CategoryTheory.Comma.mapLeftIso_inverse_map_left","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nR : CategoryTheory.Functor B T\nLâ‚ Lâ‚‚ : CategoryTheory.Functor A T\ni : CategoryTheory.Iso Lâ‚ Lâ‚‚\nXâœ Yâœ : CategoryTheory.Comma Lâ‚‚ R\nf : Quiver.Hom Xâœ Yâœ\nâŠ¢ Eq ((CategoryTheory.Comma.mapLeftIso R i).inverse.map f).left f.left","decl":"/-- A natural isomorphism `Lâ‚ â‰… Lâ‚‚` induces an equivalence of categories\n    `Comma Lâ‚ R â‰Œ Comma Lâ‚‚ R`. -/\n@[simps!]\ndef mapLeftIso (i : Lâ‚ â‰… Lâ‚‚) : Comma Lâ‚ R â‰Œ Comma Lâ‚‚ R where\n  functor := mapLeft _ i.inv\n  inverse := mapLeft _ i.hom\n  unitIso := (mapLeftId _ _).symm â‰ªâ‰« mapLeftEq _ _ _ i.hom_inv_id.symm â‰ªâ‰« mapLeftComp _ _ _\n  counitIso := (mapLeftComp _ _ _).symm â‰ªâ‰« mapLeftEq _ _ _ i.inv_hom_id â‰ªâ‰« mapLeftId _ _\n\n"}
{"name":"CategoryTheory.Comma.mapLeftIso_unitIso_hom_app_right","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nR : CategoryTheory.Functor B T\nLâ‚ Lâ‚‚ : CategoryTheory.Functor A T\ni : CategoryTheory.Iso Lâ‚ Lâ‚‚\nX : CategoryTheory.Comma Lâ‚ R\nâŠ¢ Eq ((CategoryTheory.Comma.mapLeftIso R i).unitIso.hom.app X).right (CategoryTheory.CategoryStruct.id X.right)","decl":"/-- A natural isomorphism `Lâ‚ â‰… Lâ‚‚` induces an equivalence of categories\n    `Comma Lâ‚ R â‰Œ Comma Lâ‚‚ R`. -/\n@[simps!]\ndef mapLeftIso (i : Lâ‚ â‰… Lâ‚‚) : Comma Lâ‚ R â‰Œ Comma Lâ‚‚ R where\n  functor := mapLeft _ i.inv\n  inverse := mapLeft _ i.hom\n  unitIso := (mapLeftId _ _).symm â‰ªâ‰« mapLeftEq _ _ _ i.hom_inv_id.symm â‰ªâ‰« mapLeftComp _ _ _\n  counitIso := (mapLeftComp _ _ _).symm â‰ªâ‰« mapLeftEq _ _ _ i.inv_hom_id â‰ªâ‰« mapLeftId _ _\n\n"}
{"name":"CategoryTheory.Comma.mapLeftIso_functor_map_right","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nR : CategoryTheory.Functor B T\nLâ‚ Lâ‚‚ : CategoryTheory.Functor A T\ni : CategoryTheory.Iso Lâ‚ Lâ‚‚\nXâœ Yâœ : CategoryTheory.Comma Lâ‚ R\nf : Quiver.Hom Xâœ Yâœ\nâŠ¢ Eq ((CategoryTheory.Comma.mapLeftIso R i).functor.map f).right f.right","decl":"/-- A natural isomorphism `Lâ‚ â‰… Lâ‚‚` induces an equivalence of categories\n    `Comma Lâ‚ R â‰Œ Comma Lâ‚‚ R`. -/\n@[simps!]\ndef mapLeftIso (i : Lâ‚ â‰… Lâ‚‚) : Comma Lâ‚ R â‰Œ Comma Lâ‚‚ R where\n  functor := mapLeft _ i.inv\n  inverse := mapLeft _ i.hom\n  unitIso := (mapLeftId _ _).symm â‰ªâ‰« mapLeftEq _ _ _ i.hom_inv_id.symm â‰ªâ‰« mapLeftComp _ _ _\n  counitIso := (mapLeftComp _ _ _).symm â‰ªâ‰« mapLeftEq _ _ _ i.inv_hom_id â‰ªâ‰« mapLeftId _ _\n\n"}
{"name":"CategoryTheory.Comma.mapLeftIso_unitIso_hom_app_left","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nR : CategoryTheory.Functor B T\nLâ‚ Lâ‚‚ : CategoryTheory.Functor A T\ni : CategoryTheory.Iso Lâ‚ Lâ‚‚\nX : CategoryTheory.Comma Lâ‚ R\nâŠ¢ Eq ((CategoryTheory.Comma.mapLeftIso R i).unitIso.hom.app X).left (CategoryTheory.CategoryStruct.id X.left)","decl":"/-- A natural isomorphism `Lâ‚ â‰… Lâ‚‚` induces an equivalence of categories\n    `Comma Lâ‚ R â‰Œ Comma Lâ‚‚ R`. -/\n@[simps!]\ndef mapLeftIso (i : Lâ‚ â‰… Lâ‚‚) : Comma Lâ‚ R â‰Œ Comma Lâ‚‚ R where\n  functor := mapLeft _ i.inv\n  inverse := mapLeft _ i.hom\n  unitIso := (mapLeftId _ _).symm â‰ªâ‰« mapLeftEq _ _ _ i.hom_inv_id.symm â‰ªâ‰« mapLeftComp _ _ _\n  counitIso := (mapLeftComp _ _ _).symm â‰ªâ‰« mapLeftEq _ _ _ i.inv_hom_id â‰ªâ‰« mapLeftId _ _\n\n"}
{"name":"CategoryTheory.Comma.mapLeftIso_unitIso_inv_app_left","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nR : CategoryTheory.Functor B T\nLâ‚ Lâ‚‚ : CategoryTheory.Functor A T\ni : CategoryTheory.Iso Lâ‚ Lâ‚‚\nX : CategoryTheory.Comma Lâ‚ R\nâŠ¢ Eq ((CategoryTheory.Comma.mapLeftIso R i).unitIso.inv.app X).left (CategoryTheory.CategoryStruct.id X.left)","decl":"/-- A natural isomorphism `Lâ‚ â‰… Lâ‚‚` induces an equivalence of categories\n    `Comma Lâ‚ R â‰Œ Comma Lâ‚‚ R`. -/\n@[simps!]\ndef mapLeftIso (i : Lâ‚ â‰… Lâ‚‚) : Comma Lâ‚ R â‰Œ Comma Lâ‚‚ R where\n  functor := mapLeft _ i.inv\n  inverse := mapLeft _ i.hom\n  unitIso := (mapLeftId _ _).symm â‰ªâ‰« mapLeftEq _ _ _ i.hom_inv_id.symm â‰ªâ‰« mapLeftComp _ _ _\n  counitIso := (mapLeftComp _ _ _).symm â‰ªâ‰« mapLeftEq _ _ _ i.inv_hom_id â‰ªâ‰« mapLeftId _ _\n\n"}
{"name":"CategoryTheory.Comma.mapLeftIso_inverse_obj_left","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nR : CategoryTheory.Functor B T\nLâ‚ Lâ‚‚ : CategoryTheory.Functor A T\ni : CategoryTheory.Iso Lâ‚ Lâ‚‚\nX : CategoryTheory.Comma Lâ‚‚ R\nâŠ¢ Eq ((CategoryTheory.Comma.mapLeftIso R i).inverse.obj X).left X.left","decl":"/-- A natural isomorphism `Lâ‚ â‰… Lâ‚‚` induces an equivalence of categories\n    `Comma Lâ‚ R â‰Œ Comma Lâ‚‚ R`. -/\n@[simps!]\ndef mapLeftIso (i : Lâ‚ â‰… Lâ‚‚) : Comma Lâ‚ R â‰Œ Comma Lâ‚‚ R where\n  functor := mapLeft _ i.inv\n  inverse := mapLeft _ i.hom\n  unitIso := (mapLeftId _ _).symm â‰ªâ‰« mapLeftEq _ _ _ i.hom_inv_id.symm â‰ªâ‰« mapLeftComp _ _ _\n  counitIso := (mapLeftComp _ _ _).symm â‰ªâ‰« mapLeftEq _ _ _ i.inv_hom_id â‰ªâ‰« mapLeftId _ _\n\n"}
{"name":"CategoryTheory.Comma.mapLeftIso_unitIso_inv_app_right","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nR : CategoryTheory.Functor B T\nLâ‚ Lâ‚‚ : CategoryTheory.Functor A T\ni : CategoryTheory.Iso Lâ‚ Lâ‚‚\nX : CategoryTheory.Comma Lâ‚ R\nâŠ¢ Eq ((CategoryTheory.Comma.mapLeftIso R i).unitIso.inv.app X).right (CategoryTheory.CategoryStruct.id X.right)","decl":"/-- A natural isomorphism `Lâ‚ â‰… Lâ‚‚` induces an equivalence of categories\n    `Comma Lâ‚ R â‰Œ Comma Lâ‚‚ R`. -/\n@[simps!]\ndef mapLeftIso (i : Lâ‚ â‰… Lâ‚‚) : Comma Lâ‚ R â‰Œ Comma Lâ‚‚ R where\n  functor := mapLeft _ i.inv\n  inverse := mapLeft _ i.hom\n  unitIso := (mapLeftId _ _).symm â‰ªâ‰« mapLeftEq _ _ _ i.hom_inv_id.symm â‰ªâ‰« mapLeftComp _ _ _\n  counitIso := (mapLeftComp _ _ _).symm â‰ªâ‰« mapLeftEq _ _ _ i.inv_hom_id â‰ªâ‰« mapLeftId _ _\n\n"}
{"name":"CategoryTheory.Comma.mapLeftIso_counitIso_inv_app_left","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nR : CategoryTheory.Functor B T\nLâ‚ Lâ‚‚ : CategoryTheory.Functor A T\ni : CategoryTheory.Iso Lâ‚ Lâ‚‚\nX : CategoryTheory.Comma Lâ‚‚ R\nâŠ¢ Eq ((CategoryTheory.Comma.mapLeftIso R i).counitIso.inv.app X).left (CategoryTheory.CategoryStruct.id X.left)","decl":"/-- A natural isomorphism `Lâ‚ â‰… Lâ‚‚` induces an equivalence of categories\n    `Comma Lâ‚ R â‰Œ Comma Lâ‚‚ R`. -/\n@[simps!]\ndef mapLeftIso (i : Lâ‚ â‰… Lâ‚‚) : Comma Lâ‚ R â‰Œ Comma Lâ‚‚ R where\n  functor := mapLeft _ i.inv\n  inverse := mapLeft _ i.hom\n  unitIso := (mapLeftId _ _).symm â‰ªâ‰« mapLeftEq _ _ _ i.hom_inv_id.symm â‰ªâ‰« mapLeftComp _ _ _\n  counitIso := (mapLeftComp _ _ _).symm â‰ªâ‰« mapLeftEq _ _ _ i.inv_hom_id â‰ªâ‰« mapLeftId _ _\n\n"}
{"name":"CategoryTheory.Comma.mapLeftIso_functor_obj_right","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nR : CategoryTheory.Functor B T\nLâ‚ Lâ‚‚ : CategoryTheory.Functor A T\ni : CategoryTheory.Iso Lâ‚ Lâ‚‚\nX : CategoryTheory.Comma Lâ‚ R\nâŠ¢ Eq ((CategoryTheory.Comma.mapLeftIso R i).functor.obj X).right X.right","decl":"/-- A natural isomorphism `Lâ‚ â‰… Lâ‚‚` induces an equivalence of categories\n    `Comma Lâ‚ R â‰Œ Comma Lâ‚‚ R`. -/\n@[simps!]\ndef mapLeftIso (i : Lâ‚ â‰… Lâ‚‚) : Comma Lâ‚ R â‰Œ Comma Lâ‚‚ R where\n  functor := mapLeft _ i.inv\n  inverse := mapLeft _ i.hom\n  unitIso := (mapLeftId _ _).symm â‰ªâ‰« mapLeftEq _ _ _ i.hom_inv_id.symm â‰ªâ‰« mapLeftComp _ _ _\n  counitIso := (mapLeftComp _ _ _).symm â‰ªâ‰« mapLeftEq _ _ _ i.inv_hom_id â‰ªâ‰« mapLeftId _ _\n\n"}
{"name":"CategoryTheory.Comma.mapLeftIso_inverse_obj_right","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nR : CategoryTheory.Functor B T\nLâ‚ Lâ‚‚ : CategoryTheory.Functor A T\ni : CategoryTheory.Iso Lâ‚ Lâ‚‚\nX : CategoryTheory.Comma Lâ‚‚ R\nâŠ¢ Eq ((CategoryTheory.Comma.mapLeftIso R i).inverse.obj X).right X.right","decl":"/-- A natural isomorphism `Lâ‚ â‰… Lâ‚‚` induces an equivalence of categories\n    `Comma Lâ‚ R â‰Œ Comma Lâ‚‚ R`. -/\n@[simps!]\ndef mapLeftIso (i : Lâ‚ â‰… Lâ‚‚) : Comma Lâ‚ R â‰Œ Comma Lâ‚‚ R where\n  functor := mapLeft _ i.inv\n  inverse := mapLeft _ i.hom\n  unitIso := (mapLeftId _ _).symm â‰ªâ‰« mapLeftEq _ _ _ i.hom_inv_id.symm â‰ªâ‰« mapLeftComp _ _ _\n  counitIso := (mapLeftComp _ _ _).symm â‰ªâ‰« mapLeftEq _ _ _ i.inv_hom_id â‰ªâ‰« mapLeftId _ _\n\n"}
{"name":"CategoryTheory.Comma.mapLeftIso_counitIso_inv_app_right","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nR : CategoryTheory.Functor B T\nLâ‚ Lâ‚‚ : CategoryTheory.Functor A T\ni : CategoryTheory.Iso Lâ‚ Lâ‚‚\nX : CategoryTheory.Comma Lâ‚‚ R\nâŠ¢ Eq ((CategoryTheory.Comma.mapLeftIso R i).counitIso.inv.app X).right (CategoryTheory.CategoryStruct.id X.right)","decl":"/-- A natural isomorphism `Lâ‚ â‰… Lâ‚‚` induces an equivalence of categories\n    `Comma Lâ‚ R â‰Œ Comma Lâ‚‚ R`. -/\n@[simps!]\ndef mapLeftIso (i : Lâ‚ â‰… Lâ‚‚) : Comma Lâ‚ R â‰Œ Comma Lâ‚‚ R where\n  functor := mapLeft _ i.inv\n  inverse := mapLeft _ i.hom\n  unitIso := (mapLeftId _ _).symm â‰ªâ‰« mapLeftEq _ _ _ i.hom_inv_id.symm â‰ªâ‰« mapLeftComp _ _ _\n  counitIso := (mapLeftComp _ _ _).symm â‰ªâ‰« mapLeftEq _ _ _ i.inv_hom_id â‰ªâ‰« mapLeftId _ _\n\n"}
{"name":"CategoryTheory.Comma.mapLeftIso_inverse_map_right","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nR : CategoryTheory.Functor B T\nLâ‚ Lâ‚‚ : CategoryTheory.Functor A T\ni : CategoryTheory.Iso Lâ‚ Lâ‚‚\nXâœ Yâœ : CategoryTheory.Comma Lâ‚‚ R\nf : Quiver.Hom Xâœ Yâœ\nâŠ¢ Eq ((CategoryTheory.Comma.mapLeftIso R i).inverse.map f).right f.right","decl":"/-- A natural isomorphism `Lâ‚ â‰… Lâ‚‚` induces an equivalence of categories\n    `Comma Lâ‚ R â‰Œ Comma Lâ‚‚ R`. -/\n@[simps!]\ndef mapLeftIso (i : Lâ‚ â‰… Lâ‚‚) : Comma Lâ‚ R â‰Œ Comma Lâ‚‚ R where\n  functor := mapLeft _ i.inv\n  inverse := mapLeft _ i.hom\n  unitIso := (mapLeftId _ _).symm â‰ªâ‰« mapLeftEq _ _ _ i.hom_inv_id.symm â‰ªâ‰« mapLeftComp _ _ _\n  counitIso := (mapLeftComp _ _ _).symm â‰ªâ‰« mapLeftEq _ _ _ i.inv_hom_id â‰ªâ‰« mapLeftId _ _\n\n"}
{"name":"CategoryTheory.Comma.mapRight_obj_left","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nL : CategoryTheory.Functor A T\nRâ‚ Râ‚‚ : CategoryTheory.Functor B T\nr : Quiver.Hom Râ‚ Râ‚‚\nX : CategoryTheory.Comma L Râ‚\nâŠ¢ Eq ((CategoryTheory.Comma.mapRight L r).obj X).left X.left","decl":"/-- A natural transformation `Râ‚ âŸ¶ Râ‚‚` induces a functor `Comma L Râ‚ â¥¤ Comma L Râ‚‚`. -/\n@[simps]\ndef mapRight (r : Râ‚ âŸ¶ Râ‚‚) : Comma L Râ‚ â¥¤ Comma L Râ‚‚ where\n  obj X :=\n    { left := X.left\n      right := X.right\n      hom := X.hom â‰« r.app X.right }\n  map f :=\n    { left := f.left\n      right := f.right }\n\n"}
{"name":"CategoryTheory.Comma.mapRight_obj_hom","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nL : CategoryTheory.Functor A T\nRâ‚ Râ‚‚ : CategoryTheory.Functor B T\nr : Quiver.Hom Râ‚ Râ‚‚\nX : CategoryTheory.Comma L Râ‚\nâŠ¢ Eq ((CategoryTheory.Comma.mapRight L r).obj X).hom (CategoryTheory.CategoryStruct.comp X.hom (r.app X.right))","decl":"/-- A natural transformation `Râ‚ âŸ¶ Râ‚‚` induces a functor `Comma L Râ‚ â¥¤ Comma L Râ‚‚`. -/\n@[simps]\ndef mapRight (r : Râ‚ âŸ¶ Râ‚‚) : Comma L Râ‚ â¥¤ Comma L Râ‚‚ where\n  obj X :=\n    { left := X.left\n      right := X.right\n      hom := X.hom â‰« r.app X.right }\n  map f :=\n    { left := f.left\n      right := f.right }\n\n"}
{"name":"CategoryTheory.Comma.mapRight_obj_right","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nL : CategoryTheory.Functor A T\nRâ‚ Râ‚‚ : CategoryTheory.Functor B T\nr : Quiver.Hom Râ‚ Râ‚‚\nX : CategoryTheory.Comma L Râ‚\nâŠ¢ Eq ((CategoryTheory.Comma.mapRight L r).obj X).right X.right","decl":"/-- A natural transformation `Râ‚ âŸ¶ Râ‚‚` induces a functor `Comma L Râ‚ â¥¤ Comma L Râ‚‚`. -/\n@[simps]\ndef mapRight (r : Râ‚ âŸ¶ Râ‚‚) : Comma L Râ‚ â¥¤ Comma L Râ‚‚ where\n  obj X :=\n    { left := X.left\n      right := X.right\n      hom := X.hom â‰« r.app X.right }\n  map f :=\n    { left := f.left\n      right := f.right }\n\n"}
{"name":"CategoryTheory.Comma.mapRight_map_right","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nL : CategoryTheory.Functor A T\nRâ‚ Râ‚‚ : CategoryTheory.Functor B T\nr : Quiver.Hom Râ‚ Râ‚‚\nXâœ Yâœ : CategoryTheory.Comma L Râ‚\nf : Quiver.Hom Xâœ Yâœ\nâŠ¢ Eq ((CategoryTheory.Comma.mapRight L r).map f).right f.right","decl":"/-- A natural transformation `Râ‚ âŸ¶ Râ‚‚` induces a functor `Comma L Râ‚ â¥¤ Comma L Râ‚‚`. -/\n@[simps]\ndef mapRight (r : Râ‚ âŸ¶ Râ‚‚) : Comma L Râ‚ â¥¤ Comma L Râ‚‚ where\n  obj X :=\n    { left := X.left\n      right := X.right\n      hom := X.hom â‰« r.app X.right }\n  map f :=\n    { left := f.left\n      right := f.right }\n\n"}
{"name":"CategoryTheory.Comma.mapRight_map_left","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nL : CategoryTheory.Functor A T\nRâ‚ Râ‚‚ : CategoryTheory.Functor B T\nr : Quiver.Hom Râ‚ Râ‚‚\nXâœ Yâœ : CategoryTheory.Comma L Râ‚\nf : Quiver.Hom Xâœ Yâœ\nâŠ¢ Eq ((CategoryTheory.Comma.mapRight L r).map f).left f.left","decl":"/-- A natural transformation `Râ‚ âŸ¶ Râ‚‚` induces a functor `Comma L Râ‚ â¥¤ Comma L Râ‚‚`. -/\n@[simps]\ndef mapRight (r : Râ‚ âŸ¶ Râ‚‚) : Comma L Râ‚ â¥¤ Comma L Râ‚‚ where\n  obj X :=\n    { left := X.left\n      right := X.right\n      hom := X.hom â‰« r.app X.right }\n  map f :=\n    { left := f.left\n      right := f.right }\n\n"}
{"name":"CategoryTheory.Comma.mapRightId_inv_app_left","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nX : CategoryTheory.Comma L R\nâŠ¢ Eq ((CategoryTheory.Comma.mapRightId L R).inv.app X).left (CategoryTheory.CategoryStruct.id X.left)","decl":"/-- The functor `Comma L R â¥¤ Comma L R` induced by the identity natural transformation on `R` is\n    naturally isomorphic to the identity functor. -/\n@[simps!]\ndef mapRightId : mapRight L (ğŸ™ R) â‰… ğŸ­ _ :=\n  NatIso.ofComponents (fun X => isoMk (Iso.refl _) (Iso.refl _))\n\n"}
{"name":"CategoryTheory.Comma.mapRightId_hom_app_right","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nX : CategoryTheory.Comma L R\nâŠ¢ Eq ((CategoryTheory.Comma.mapRightId L R).hom.app X).right (CategoryTheory.CategoryStruct.id X.right)","decl":"/-- The functor `Comma L R â¥¤ Comma L R` induced by the identity natural transformation on `R` is\n    naturally isomorphic to the identity functor. -/\n@[simps!]\ndef mapRightId : mapRight L (ğŸ™ R) â‰… ğŸ­ _ :=\n  NatIso.ofComponents (fun X => isoMk (Iso.refl _) (Iso.refl _))\n\n"}
{"name":"CategoryTheory.Comma.mapRightId_hom_app_left","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nX : CategoryTheory.Comma L R\nâŠ¢ Eq ((CategoryTheory.Comma.mapRightId L R).hom.app X).left (CategoryTheory.CategoryStruct.id X.left)","decl":"/-- The functor `Comma L R â¥¤ Comma L R` induced by the identity natural transformation on `R` is\n    naturally isomorphic to the identity functor. -/\n@[simps!]\ndef mapRightId : mapRight L (ğŸ™ R) â‰… ğŸ­ _ :=\n  NatIso.ofComponents (fun X => isoMk (Iso.refl _) (Iso.refl _))\n\n"}
{"name":"CategoryTheory.Comma.mapRightId_inv_app_right","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nX : CategoryTheory.Comma L R\nâŠ¢ Eq ((CategoryTheory.Comma.mapRightId L R).inv.app X).right (CategoryTheory.CategoryStruct.id X.right)","decl":"/-- The functor `Comma L R â¥¤ Comma L R` induced by the identity natural transformation on `R` is\n    naturally isomorphic to the identity functor. -/\n@[simps!]\ndef mapRightId : mapRight L (ğŸ™ R) â‰… ğŸ­ _ :=\n  NatIso.ofComponents (fun X => isoMk (Iso.refl _) (Iso.refl _))\n\n"}
{"name":"CategoryTheory.Comma.mapRightComp_inv_app_right","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nL : CategoryTheory.Functor A T\nRâ‚ Râ‚‚ Râ‚ƒ : CategoryTheory.Functor B T\nr : Quiver.Hom Râ‚ Râ‚‚\nr' : Quiver.Hom Râ‚‚ Râ‚ƒ\nX : CategoryTheory.Comma L Râ‚\nâŠ¢ Eq ((CategoryTheory.Comma.mapRightComp L r r').inv.app X).right (CategoryTheory.CategoryStruct.id X.right)","decl":"/-- The functor `Comma L Râ‚ â¥¤ Comma L Râ‚ƒ` induced by the composition of the natural transformations\n    `r : Râ‚ âŸ¶ Râ‚‚` and `r' : Râ‚‚ âŸ¶ Râ‚ƒ` is naturally isomorphic to the composition of the functors\n    induced by these natural transformations. -/\n@[simps!]\ndef mapRightComp (r : Râ‚ âŸ¶ Râ‚‚) (r' : Râ‚‚ âŸ¶ Râ‚ƒ) :\n    mapRight L (r â‰« r') â‰… mapRight L r â‹™ mapRight L r' :=\n  NatIso.ofComponents (fun X => isoMk (Iso.refl _) (Iso.refl _))\n\n"}
{"name":"CategoryTheory.Comma.mapRightComp_inv_app_left","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nL : CategoryTheory.Functor A T\nRâ‚ Râ‚‚ Râ‚ƒ : CategoryTheory.Functor B T\nr : Quiver.Hom Râ‚ Râ‚‚\nr' : Quiver.Hom Râ‚‚ Râ‚ƒ\nX : CategoryTheory.Comma L Râ‚\nâŠ¢ Eq ((CategoryTheory.Comma.mapRightComp L r r').inv.app X).left (CategoryTheory.CategoryStruct.id X.left)","decl":"/-- The functor `Comma L Râ‚ â¥¤ Comma L Râ‚ƒ` induced by the composition of the natural transformations\n    `r : Râ‚ âŸ¶ Râ‚‚` and `r' : Râ‚‚ âŸ¶ Râ‚ƒ` is naturally isomorphic to the composition of the functors\n    induced by these natural transformations. -/\n@[simps!]\ndef mapRightComp (r : Râ‚ âŸ¶ Râ‚‚) (r' : Râ‚‚ âŸ¶ Râ‚ƒ) :\n    mapRight L (r â‰« r') â‰… mapRight L r â‹™ mapRight L r' :=\n  NatIso.ofComponents (fun X => isoMk (Iso.refl _) (Iso.refl _))\n\n"}
{"name":"CategoryTheory.Comma.mapRightComp_hom_app_left","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nL : CategoryTheory.Functor A T\nRâ‚ Râ‚‚ Râ‚ƒ : CategoryTheory.Functor B T\nr : Quiver.Hom Râ‚ Râ‚‚\nr' : Quiver.Hom Râ‚‚ Râ‚ƒ\nX : CategoryTheory.Comma L Râ‚\nâŠ¢ Eq ((CategoryTheory.Comma.mapRightComp L r r').hom.app X).left (CategoryTheory.CategoryStruct.id X.left)","decl":"/-- The functor `Comma L Râ‚ â¥¤ Comma L Râ‚ƒ` induced by the composition of the natural transformations\n    `r : Râ‚ âŸ¶ Râ‚‚` and `r' : Râ‚‚ âŸ¶ Râ‚ƒ` is naturally isomorphic to the composition of the functors\n    induced by these natural transformations. -/\n@[simps!]\ndef mapRightComp (r : Râ‚ âŸ¶ Râ‚‚) (r' : Râ‚‚ âŸ¶ Râ‚ƒ) :\n    mapRight L (r â‰« r') â‰… mapRight L r â‹™ mapRight L r' :=\n  NatIso.ofComponents (fun X => isoMk (Iso.refl _) (Iso.refl _))\n\n"}
{"name":"CategoryTheory.Comma.mapRightComp_hom_app_right","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nL : CategoryTheory.Functor A T\nRâ‚ Râ‚‚ Râ‚ƒ : CategoryTheory.Functor B T\nr : Quiver.Hom Râ‚ Râ‚‚\nr' : Quiver.Hom Râ‚‚ Râ‚ƒ\nX : CategoryTheory.Comma L Râ‚\nâŠ¢ Eq ((CategoryTheory.Comma.mapRightComp L r r').hom.app X).right (CategoryTheory.CategoryStruct.id X.right)","decl":"/-- The functor `Comma L Râ‚ â¥¤ Comma L Râ‚ƒ` induced by the composition of the natural transformations\n    `r : Râ‚ âŸ¶ Râ‚‚` and `r' : Râ‚‚ âŸ¶ Râ‚ƒ` is naturally isomorphic to the composition of the functors\n    induced by these natural transformations. -/\n@[simps!]\ndef mapRightComp (r : Râ‚ âŸ¶ Râ‚‚) (r' : Râ‚‚ âŸ¶ Râ‚ƒ) :\n    mapRight L (r â‰« r') â‰… mapRight L r â‹™ mapRight L r' :=\n  NatIso.ofComponents (fun X => isoMk (Iso.refl _) (Iso.refl _))\n\n"}
{"name":"CategoryTheory.Comma.mapRightEq_inv_app_left","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nL : CategoryTheory.Functor A T\nRâ‚ Râ‚‚ : CategoryTheory.Functor B T\nr r' : Quiver.Hom Râ‚ Râ‚‚\nh : Eq r r'\nX : CategoryTheory.Comma L Râ‚\nâŠ¢ Eq ((CategoryTheory.Comma.mapRightEq L r r' h).inv.app X).left (CategoryTheory.CategoryStruct.id X.left)","decl":"/-- Two equal natural transformations `Râ‚ âŸ¶ Râ‚‚` yield naturally isomorphic functors\n    `Comma L Râ‚ â¥¤ Comma L Râ‚‚`. -/\n@[simps!]\ndef mapRightEq (r r' : Râ‚ âŸ¶ Râ‚‚) (h : r = r') : mapRight L r â‰… mapRight L r' :=\n  NatIso.ofComponents (fun X => isoMk (Iso.refl _) (Iso.refl _))\n\n"}
{"name":"CategoryTheory.Comma.mapRightEq_inv_app_right","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nL : CategoryTheory.Functor A T\nRâ‚ Râ‚‚ : CategoryTheory.Functor B T\nr r' : Quiver.Hom Râ‚ Râ‚‚\nh : Eq r r'\nX : CategoryTheory.Comma L Râ‚\nâŠ¢ Eq ((CategoryTheory.Comma.mapRightEq L r r' h).inv.app X).right (CategoryTheory.CategoryStruct.id X.right)","decl":"/-- Two equal natural transformations `Râ‚ âŸ¶ Râ‚‚` yield naturally isomorphic functors\n    `Comma L Râ‚ â¥¤ Comma L Râ‚‚`. -/\n@[simps!]\ndef mapRightEq (r r' : Râ‚ âŸ¶ Râ‚‚) (h : r = r') : mapRight L r â‰… mapRight L r' :=\n  NatIso.ofComponents (fun X => isoMk (Iso.refl _) (Iso.refl _))\n\n"}
{"name":"CategoryTheory.Comma.mapRightEq_hom_app_left","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nL : CategoryTheory.Functor A T\nRâ‚ Râ‚‚ : CategoryTheory.Functor B T\nr r' : Quiver.Hom Râ‚ Râ‚‚\nh : Eq r r'\nX : CategoryTheory.Comma L Râ‚\nâŠ¢ Eq ((CategoryTheory.Comma.mapRightEq L r r' h).hom.app X).left (CategoryTheory.CategoryStruct.id X.left)","decl":"/-- Two equal natural transformations `Râ‚ âŸ¶ Râ‚‚` yield naturally isomorphic functors\n    `Comma L Râ‚ â¥¤ Comma L Râ‚‚`. -/\n@[simps!]\ndef mapRightEq (r r' : Râ‚ âŸ¶ Râ‚‚) (h : r = r') : mapRight L r â‰… mapRight L r' :=\n  NatIso.ofComponents (fun X => isoMk (Iso.refl _) (Iso.refl _))\n\n"}
{"name":"CategoryTheory.Comma.mapRightEq_hom_app_right","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nL : CategoryTheory.Functor A T\nRâ‚ Râ‚‚ : CategoryTheory.Functor B T\nr r' : Quiver.Hom Râ‚ Râ‚‚\nh : Eq r r'\nX : CategoryTheory.Comma L Râ‚\nâŠ¢ Eq ((CategoryTheory.Comma.mapRightEq L r r' h).hom.app X).right (CategoryTheory.CategoryStruct.id X.right)","decl":"/-- Two equal natural transformations `Râ‚ âŸ¶ Râ‚‚` yield naturally isomorphic functors\n    `Comma L Râ‚ â¥¤ Comma L Râ‚‚`. -/\n@[simps!]\ndef mapRightEq (r r' : Râ‚ âŸ¶ Râ‚‚) (h : r = r') : mapRight L r â‰… mapRight L r' :=\n  NatIso.ofComponents (fun X => isoMk (Iso.refl _) (Iso.refl _))\n\n"}
{"name":"CategoryTheory.Comma.mapRightIso_counitIso_inv_app_left","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nL : CategoryTheory.Functor A T\nRâ‚ Râ‚‚ : CategoryTheory.Functor B T\ni : CategoryTheory.Iso Râ‚ Râ‚‚\nX : CategoryTheory.Comma L Râ‚‚\nâŠ¢ Eq ((CategoryTheory.Comma.mapRightIso L i).counitIso.inv.app X).left (CategoryTheory.CategoryStruct.id X.left)","decl":"/-- A natural isomorphism `Râ‚ â‰… Râ‚‚` induces an equivalence of categories\n    `Comma L Râ‚ â‰Œ Comma L Râ‚‚`. -/\n@[simps!]\ndef mapRightIso (i : Râ‚ â‰… Râ‚‚) : Comma L Râ‚ â‰Œ Comma L Râ‚‚ where\n  functor := mapRight _ i.hom\n  inverse := mapRight _ i.inv\n  unitIso := (mapRightId _ _).symm â‰ªâ‰« mapRightEq _ _ _ i.hom_inv_id.symm â‰ªâ‰« mapRightComp _ _ _\n  counitIso := (mapRightComp _ _ _).symm â‰ªâ‰« mapRightEq _ _ _ i.inv_hom_id â‰ªâ‰« mapRightId _ _\n\n"}
{"name":"CategoryTheory.Comma.mapRightIso_counitIso_hom_app_right","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nL : CategoryTheory.Functor A T\nRâ‚ Râ‚‚ : CategoryTheory.Functor B T\ni : CategoryTheory.Iso Râ‚ Râ‚‚\nX : CategoryTheory.Comma L Râ‚‚\nâŠ¢ Eq ((CategoryTheory.Comma.mapRightIso L i).counitIso.hom.app X).right (CategoryTheory.CategoryStruct.id X.right)","decl":"/-- A natural isomorphism `Râ‚ â‰… Râ‚‚` induces an equivalence of categories\n    `Comma L Râ‚ â‰Œ Comma L Râ‚‚`. -/\n@[simps!]\ndef mapRightIso (i : Râ‚ â‰… Râ‚‚) : Comma L Râ‚ â‰Œ Comma L Râ‚‚ where\n  functor := mapRight _ i.hom\n  inverse := mapRight _ i.inv\n  unitIso := (mapRightId _ _).symm â‰ªâ‰« mapRightEq _ _ _ i.hom_inv_id.symm â‰ªâ‰« mapRightComp _ _ _\n  counitIso := (mapRightComp _ _ _).symm â‰ªâ‰« mapRightEq _ _ _ i.inv_hom_id â‰ªâ‰« mapRightId _ _\n\n"}
{"name":"CategoryTheory.Comma.mapRightIso_unitIso_hom_app_left","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nL : CategoryTheory.Functor A T\nRâ‚ Râ‚‚ : CategoryTheory.Functor B T\ni : CategoryTheory.Iso Râ‚ Râ‚‚\nX : CategoryTheory.Comma L Râ‚\nâŠ¢ Eq ((CategoryTheory.Comma.mapRightIso L i).unitIso.hom.app X).left (CategoryTheory.CategoryStruct.id X.left)","decl":"/-- A natural isomorphism `Râ‚ â‰… Râ‚‚` induces an equivalence of categories\n    `Comma L Râ‚ â‰Œ Comma L Râ‚‚`. -/\n@[simps!]\ndef mapRightIso (i : Râ‚ â‰… Râ‚‚) : Comma L Râ‚ â‰Œ Comma L Râ‚‚ where\n  functor := mapRight _ i.hom\n  inverse := mapRight _ i.inv\n  unitIso := (mapRightId _ _).symm â‰ªâ‰« mapRightEq _ _ _ i.hom_inv_id.symm â‰ªâ‰« mapRightComp _ _ _\n  counitIso := (mapRightComp _ _ _).symm â‰ªâ‰« mapRightEq _ _ _ i.inv_hom_id â‰ªâ‰« mapRightId _ _\n\n"}
{"name":"CategoryTheory.Comma.mapRightIso_functor_obj_left","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nL : CategoryTheory.Functor A T\nRâ‚ Râ‚‚ : CategoryTheory.Functor B T\ni : CategoryTheory.Iso Râ‚ Râ‚‚\nX : CategoryTheory.Comma L Râ‚\nâŠ¢ Eq ((CategoryTheory.Comma.mapRightIso L i).functor.obj X).left X.left","decl":"/-- A natural isomorphism `Râ‚ â‰… Râ‚‚` induces an equivalence of categories\n    `Comma L Râ‚ â‰Œ Comma L Râ‚‚`. -/\n@[simps!]\ndef mapRightIso (i : Râ‚ â‰… Râ‚‚) : Comma L Râ‚ â‰Œ Comma L Râ‚‚ where\n  functor := mapRight _ i.hom\n  inverse := mapRight _ i.inv\n  unitIso := (mapRightId _ _).symm â‰ªâ‰« mapRightEq _ _ _ i.hom_inv_id.symm â‰ªâ‰« mapRightComp _ _ _\n  counitIso := (mapRightComp _ _ _).symm â‰ªâ‰« mapRightEq _ _ _ i.inv_hom_id â‰ªâ‰« mapRightId _ _\n\n"}
{"name":"CategoryTheory.Comma.mapRightIso_functor_obj_right","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nL : CategoryTheory.Functor A T\nRâ‚ Râ‚‚ : CategoryTheory.Functor B T\ni : CategoryTheory.Iso Râ‚ Râ‚‚\nX : CategoryTheory.Comma L Râ‚\nâŠ¢ Eq ((CategoryTheory.Comma.mapRightIso L i).functor.obj X).right X.right","decl":"/-- A natural isomorphism `Râ‚ â‰… Râ‚‚` induces an equivalence of categories\n    `Comma L Râ‚ â‰Œ Comma L Râ‚‚`. -/\n@[simps!]\ndef mapRightIso (i : Râ‚ â‰… Râ‚‚) : Comma L Râ‚ â‰Œ Comma L Râ‚‚ where\n  functor := mapRight _ i.hom\n  inverse := mapRight _ i.inv\n  unitIso := (mapRightId _ _).symm â‰ªâ‰« mapRightEq _ _ _ i.hom_inv_id.symm â‰ªâ‰« mapRightComp _ _ _\n  counitIso := (mapRightComp _ _ _).symm â‰ªâ‰« mapRightEq _ _ _ i.inv_hom_id â‰ªâ‰« mapRightId _ _\n\n"}
{"name":"CategoryTheory.Comma.mapRightIso_inverse_obj_left","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nL : CategoryTheory.Functor A T\nRâ‚ Râ‚‚ : CategoryTheory.Functor B T\ni : CategoryTheory.Iso Râ‚ Râ‚‚\nX : CategoryTheory.Comma L Râ‚‚\nâŠ¢ Eq ((CategoryTheory.Comma.mapRightIso L i).inverse.obj X).left X.left","decl":"/-- A natural isomorphism `Râ‚ â‰… Râ‚‚` induces an equivalence of categories\n    `Comma L Râ‚ â‰Œ Comma L Râ‚‚`. -/\n@[simps!]\ndef mapRightIso (i : Râ‚ â‰… Râ‚‚) : Comma L Râ‚ â‰Œ Comma L Râ‚‚ where\n  functor := mapRight _ i.hom\n  inverse := mapRight _ i.inv\n  unitIso := (mapRightId _ _).symm â‰ªâ‰« mapRightEq _ _ _ i.hom_inv_id.symm â‰ªâ‰« mapRightComp _ _ _\n  counitIso := (mapRightComp _ _ _).symm â‰ªâ‰« mapRightEq _ _ _ i.inv_hom_id â‰ªâ‰« mapRightId _ _\n\n"}
{"name":"CategoryTheory.Comma.mapRightIso_inverse_map_left","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nL : CategoryTheory.Functor A T\nRâ‚ Râ‚‚ : CategoryTheory.Functor B T\ni : CategoryTheory.Iso Râ‚ Râ‚‚\nXâœ Yâœ : CategoryTheory.Comma L Râ‚‚\nf : Quiver.Hom Xâœ Yâœ\nâŠ¢ Eq ((CategoryTheory.Comma.mapRightIso L i).inverse.map f).left f.left","decl":"/-- A natural isomorphism `Râ‚ â‰… Râ‚‚` induces an equivalence of categories\n    `Comma L Râ‚ â‰Œ Comma L Râ‚‚`. -/\n@[simps!]\ndef mapRightIso (i : Râ‚ â‰… Râ‚‚) : Comma L Râ‚ â‰Œ Comma L Râ‚‚ where\n  functor := mapRight _ i.hom\n  inverse := mapRight _ i.inv\n  unitIso := (mapRightId _ _).symm â‰ªâ‰« mapRightEq _ _ _ i.hom_inv_id.symm â‰ªâ‰« mapRightComp _ _ _\n  counitIso := (mapRightComp _ _ _).symm â‰ªâ‰« mapRightEq _ _ _ i.inv_hom_id â‰ªâ‰« mapRightId _ _\n\n"}
{"name":"CategoryTheory.Comma.mapRightIso_counitIso_hom_app_left","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nL : CategoryTheory.Functor A T\nRâ‚ Râ‚‚ : CategoryTheory.Functor B T\ni : CategoryTheory.Iso Râ‚ Râ‚‚\nX : CategoryTheory.Comma L Râ‚‚\nâŠ¢ Eq ((CategoryTheory.Comma.mapRightIso L i).counitIso.hom.app X).left (CategoryTheory.CategoryStruct.id X.left)","decl":"/-- A natural isomorphism `Râ‚ â‰… Râ‚‚` induces an equivalence of categories\n    `Comma L Râ‚ â‰Œ Comma L Râ‚‚`. -/\n@[simps!]\ndef mapRightIso (i : Râ‚ â‰… Râ‚‚) : Comma L Râ‚ â‰Œ Comma L Râ‚‚ where\n  functor := mapRight _ i.hom\n  inverse := mapRight _ i.inv\n  unitIso := (mapRightId _ _).symm â‰ªâ‰« mapRightEq _ _ _ i.hom_inv_id.symm â‰ªâ‰« mapRightComp _ _ _\n  counitIso := (mapRightComp _ _ _).symm â‰ªâ‰« mapRightEq _ _ _ i.inv_hom_id â‰ªâ‰« mapRightId _ _\n\n"}
{"name":"CategoryTheory.Comma.mapRightIso_functor_map_left","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nL : CategoryTheory.Functor A T\nRâ‚ Râ‚‚ : CategoryTheory.Functor B T\ni : CategoryTheory.Iso Râ‚ Râ‚‚\nXâœ Yâœ : CategoryTheory.Comma L Râ‚\nf : Quiver.Hom Xâœ Yâœ\nâŠ¢ Eq ((CategoryTheory.Comma.mapRightIso L i).functor.map f).left f.left","decl":"/-- A natural isomorphism `Râ‚ â‰… Râ‚‚` induces an equivalence of categories\n    `Comma L Râ‚ â‰Œ Comma L Râ‚‚`. -/\n@[simps!]\ndef mapRightIso (i : Râ‚ â‰… Râ‚‚) : Comma L Râ‚ â‰Œ Comma L Râ‚‚ where\n  functor := mapRight _ i.hom\n  inverse := mapRight _ i.inv\n  unitIso := (mapRightId _ _).symm â‰ªâ‰« mapRightEq _ _ _ i.hom_inv_id.symm â‰ªâ‰« mapRightComp _ _ _\n  counitIso := (mapRightComp _ _ _).symm â‰ªâ‰« mapRightEq _ _ _ i.inv_hom_id â‰ªâ‰« mapRightId _ _\n\n"}
{"name":"CategoryTheory.Comma.mapRightIso_unitIso_inv_app_right","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nL : CategoryTheory.Functor A T\nRâ‚ Râ‚‚ : CategoryTheory.Functor B T\ni : CategoryTheory.Iso Râ‚ Râ‚‚\nX : CategoryTheory.Comma L Râ‚\nâŠ¢ Eq ((CategoryTheory.Comma.mapRightIso L i).unitIso.inv.app X).right (CategoryTheory.CategoryStruct.id X.right)","decl":"/-- A natural isomorphism `Râ‚ â‰… Râ‚‚` induces an equivalence of categories\n    `Comma L Râ‚ â‰Œ Comma L Râ‚‚`. -/\n@[simps!]\ndef mapRightIso (i : Râ‚ â‰… Râ‚‚) : Comma L Râ‚ â‰Œ Comma L Râ‚‚ where\n  functor := mapRight _ i.hom\n  inverse := mapRight _ i.inv\n  unitIso := (mapRightId _ _).symm â‰ªâ‰« mapRightEq _ _ _ i.hom_inv_id.symm â‰ªâ‰« mapRightComp _ _ _\n  counitIso := (mapRightComp _ _ _).symm â‰ªâ‰« mapRightEq _ _ _ i.inv_hom_id â‰ªâ‰« mapRightId _ _\n\n"}
{"name":"CategoryTheory.Comma.mapRightIso_functor_obj_hom","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nL : CategoryTheory.Functor A T\nRâ‚ Râ‚‚ : CategoryTheory.Functor B T\ni : CategoryTheory.Iso Râ‚ Râ‚‚\nX : CategoryTheory.Comma L Râ‚\nâŠ¢ Eq ((CategoryTheory.Comma.mapRightIso L i).functor.obj X).hom (CategoryTheory.CategoryStruct.comp X.hom (i.hom.app X.right))","decl":"/-- A natural isomorphism `Râ‚ â‰… Râ‚‚` induces an equivalence of categories\n    `Comma L Râ‚ â‰Œ Comma L Râ‚‚`. -/\n@[simps!]\ndef mapRightIso (i : Râ‚ â‰… Râ‚‚) : Comma L Râ‚ â‰Œ Comma L Râ‚‚ where\n  functor := mapRight _ i.hom\n  inverse := mapRight _ i.inv\n  unitIso := (mapRightId _ _).symm â‰ªâ‰« mapRightEq _ _ _ i.hom_inv_id.symm â‰ªâ‰« mapRightComp _ _ _\n  counitIso := (mapRightComp _ _ _).symm â‰ªâ‰« mapRightEq _ _ _ i.inv_hom_id â‰ªâ‰« mapRightId _ _\n\n"}
{"name":"CategoryTheory.Comma.mapRightIso_counitIso_inv_app_right","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nL : CategoryTheory.Functor A T\nRâ‚ Râ‚‚ : CategoryTheory.Functor B T\ni : CategoryTheory.Iso Râ‚ Râ‚‚\nX : CategoryTheory.Comma L Râ‚‚\nâŠ¢ Eq ((CategoryTheory.Comma.mapRightIso L i).counitIso.inv.app X).right (CategoryTheory.CategoryStruct.id X.right)","decl":"/-- A natural isomorphism `Râ‚ â‰… Râ‚‚` induces an equivalence of categories\n    `Comma L Râ‚ â‰Œ Comma L Râ‚‚`. -/\n@[simps!]\ndef mapRightIso (i : Râ‚ â‰… Râ‚‚) : Comma L Râ‚ â‰Œ Comma L Râ‚‚ where\n  functor := mapRight _ i.hom\n  inverse := mapRight _ i.inv\n  unitIso := (mapRightId _ _).symm â‰ªâ‰« mapRightEq _ _ _ i.hom_inv_id.symm â‰ªâ‰« mapRightComp _ _ _\n  counitIso := (mapRightComp _ _ _).symm â‰ªâ‰« mapRightEq _ _ _ i.inv_hom_id â‰ªâ‰« mapRightId _ _\n\n"}
{"name":"CategoryTheory.Comma.mapRightIso_unitIso_hom_app_right","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nL : CategoryTheory.Functor A T\nRâ‚ Râ‚‚ : CategoryTheory.Functor B T\ni : CategoryTheory.Iso Râ‚ Râ‚‚\nX : CategoryTheory.Comma L Râ‚\nâŠ¢ Eq ((CategoryTheory.Comma.mapRightIso L i).unitIso.hom.app X).right (CategoryTheory.CategoryStruct.id X.right)","decl":"/-- A natural isomorphism `Râ‚ â‰… Râ‚‚` induces an equivalence of categories\n    `Comma L Râ‚ â‰Œ Comma L Râ‚‚`. -/\n@[simps!]\ndef mapRightIso (i : Râ‚ â‰… Râ‚‚) : Comma L Râ‚ â‰Œ Comma L Râ‚‚ where\n  functor := mapRight _ i.hom\n  inverse := mapRight _ i.inv\n  unitIso := (mapRightId _ _).symm â‰ªâ‰« mapRightEq _ _ _ i.hom_inv_id.symm â‰ªâ‰« mapRightComp _ _ _\n  counitIso := (mapRightComp _ _ _).symm â‰ªâ‰« mapRightEq _ _ _ i.inv_hom_id â‰ªâ‰« mapRightId _ _\n\n"}
{"name":"CategoryTheory.Comma.mapRightIso_inverse_obj_hom","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nL : CategoryTheory.Functor A T\nRâ‚ Râ‚‚ : CategoryTheory.Functor B T\ni : CategoryTheory.Iso Râ‚ Râ‚‚\nX : CategoryTheory.Comma L Râ‚‚\nâŠ¢ Eq ((CategoryTheory.Comma.mapRightIso L i).inverse.obj X).hom (CategoryTheory.CategoryStruct.comp X.hom (i.inv.app X.right))","decl":"/-- A natural isomorphism `Râ‚ â‰… Râ‚‚` induces an equivalence of categories\n    `Comma L Râ‚ â‰Œ Comma L Râ‚‚`. -/\n@[simps!]\ndef mapRightIso (i : Râ‚ â‰… Râ‚‚) : Comma L Râ‚ â‰Œ Comma L Râ‚‚ where\n  functor := mapRight _ i.hom\n  inverse := mapRight _ i.inv\n  unitIso := (mapRightId _ _).symm â‰ªâ‰« mapRightEq _ _ _ i.hom_inv_id.symm â‰ªâ‰« mapRightComp _ _ _\n  counitIso := (mapRightComp _ _ _).symm â‰ªâ‰« mapRightEq _ _ _ i.inv_hom_id â‰ªâ‰« mapRightId _ _\n\n"}
{"name":"CategoryTheory.Comma.mapRightIso_inverse_map_right","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nL : CategoryTheory.Functor A T\nRâ‚ Râ‚‚ : CategoryTheory.Functor B T\ni : CategoryTheory.Iso Râ‚ Râ‚‚\nXâœ Yâœ : CategoryTheory.Comma L Râ‚‚\nf : Quiver.Hom Xâœ Yâœ\nâŠ¢ Eq ((CategoryTheory.Comma.mapRightIso L i).inverse.map f).right f.right","decl":"/-- A natural isomorphism `Râ‚ â‰… Râ‚‚` induces an equivalence of categories\n    `Comma L Râ‚ â‰Œ Comma L Râ‚‚`. -/\n@[simps!]\ndef mapRightIso (i : Râ‚ â‰… Râ‚‚) : Comma L Râ‚ â‰Œ Comma L Râ‚‚ where\n  functor := mapRight _ i.hom\n  inverse := mapRight _ i.inv\n  unitIso := (mapRightId _ _).symm â‰ªâ‰« mapRightEq _ _ _ i.hom_inv_id.symm â‰ªâ‰« mapRightComp _ _ _\n  counitIso := (mapRightComp _ _ _).symm â‰ªâ‰« mapRightEq _ _ _ i.inv_hom_id â‰ªâ‰« mapRightId _ _\n\n"}
{"name":"CategoryTheory.Comma.mapRightIso_functor_map_right","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nL : CategoryTheory.Functor A T\nRâ‚ Râ‚‚ : CategoryTheory.Functor B T\ni : CategoryTheory.Iso Râ‚ Râ‚‚\nXâœ Yâœ : CategoryTheory.Comma L Râ‚\nf : Quiver.Hom Xâœ Yâœ\nâŠ¢ Eq ((CategoryTheory.Comma.mapRightIso L i).functor.map f).right f.right","decl":"/-- A natural isomorphism `Râ‚ â‰… Râ‚‚` induces an equivalence of categories\n    `Comma L Râ‚ â‰Œ Comma L Râ‚‚`. -/\n@[simps!]\ndef mapRightIso (i : Râ‚ â‰… Râ‚‚) : Comma L Râ‚ â‰Œ Comma L Râ‚‚ where\n  functor := mapRight _ i.hom\n  inverse := mapRight _ i.inv\n  unitIso := (mapRightId _ _).symm â‰ªâ‰« mapRightEq _ _ _ i.hom_inv_id.symm â‰ªâ‰« mapRightComp _ _ _\n  counitIso := (mapRightComp _ _ _).symm â‰ªâ‰« mapRightEq _ _ _ i.inv_hom_id â‰ªâ‰« mapRightId _ _\n\n"}
{"name":"CategoryTheory.Comma.mapRightIso_inverse_obj_right","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nL : CategoryTheory.Functor A T\nRâ‚ Râ‚‚ : CategoryTheory.Functor B T\ni : CategoryTheory.Iso Râ‚ Râ‚‚\nX : CategoryTheory.Comma L Râ‚‚\nâŠ¢ Eq ((CategoryTheory.Comma.mapRightIso L i).inverse.obj X).right X.right","decl":"/-- A natural isomorphism `Râ‚ â‰… Râ‚‚` induces an equivalence of categories\n    `Comma L Râ‚ â‰Œ Comma L Râ‚‚`. -/\n@[simps!]\ndef mapRightIso (i : Râ‚ â‰… Râ‚‚) : Comma L Râ‚ â‰Œ Comma L Râ‚‚ where\n  functor := mapRight _ i.hom\n  inverse := mapRight _ i.inv\n  unitIso := (mapRightId _ _).symm â‰ªâ‰« mapRightEq _ _ _ i.hom_inv_id.symm â‰ªâ‰« mapRightComp _ _ _\n  counitIso := (mapRightComp _ _ _).symm â‰ªâ‰« mapRightEq _ _ _ i.inv_hom_id â‰ªâ‰« mapRightId _ _\n\n"}
{"name":"CategoryTheory.Comma.mapRightIso_unitIso_inv_app_left","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nL : CategoryTheory.Functor A T\nRâ‚ Râ‚‚ : CategoryTheory.Functor B T\ni : CategoryTheory.Iso Râ‚ Râ‚‚\nX : CategoryTheory.Comma L Râ‚\nâŠ¢ Eq ((CategoryTheory.Comma.mapRightIso L i).unitIso.inv.app X).left (CategoryTheory.CategoryStruct.id X.left)","decl":"/-- A natural isomorphism `Râ‚ â‰… Râ‚‚` induces an equivalence of categories\n    `Comma L Râ‚ â‰Œ Comma L Râ‚‚`. -/\n@[simps!]\ndef mapRightIso (i : Râ‚ â‰… Râ‚‚) : Comma L Râ‚ â‰Œ Comma L Râ‚‚ where\n  functor := mapRight _ i.hom\n  inverse := mapRight _ i.inv\n  unitIso := (mapRightId _ _).symm â‰ªâ‰« mapRightEq _ _ _ i.hom_inv_id.symm â‰ªâ‰« mapRightComp _ _ _\n  counitIso := (mapRightComp _ _ _).symm â‰ªâ‰« mapRightEq _ _ _ i.inv_hom_id â‰ªâ‰« mapRightId _ _\n\n"}
{"name":"CategoryTheory.Comma.preLeft_obj_right","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nC : Type uâ‚„\ninstâœ : CategoryTheory.Category.{vâ‚„, uâ‚„} C\nF : CategoryTheory.Functor C A\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nX : CategoryTheory.Comma (F.comp L) R\nâŠ¢ Eq ((CategoryTheory.Comma.preLeft F L R).obj X).right X.right","decl":"/-- The functor `(F â‹™ L, R) â¥¤ (L, R)` -/\n@[simps]\ndef preLeft (F : C â¥¤ A) (L : A â¥¤ T) (R : B â¥¤ T) : Comma (F â‹™ L) R â¥¤ Comma L R where\n  obj X :=\n    { left := F.obj X.left\n      right := X.right\n      hom := X.hom }\n  map f :=\n    { left := F.map f.left\n      right := f.right\n      w := by simpa using f.w }\n\n"}
{"name":"CategoryTheory.Comma.preLeft_obj_left","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nC : Type uâ‚„\ninstâœ : CategoryTheory.Category.{vâ‚„, uâ‚„} C\nF : CategoryTheory.Functor C A\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nX : CategoryTheory.Comma (F.comp L) R\nâŠ¢ Eq ((CategoryTheory.Comma.preLeft F L R).obj X).left (F.obj X.left)","decl":"/-- The functor `(F â‹™ L, R) â¥¤ (L, R)` -/\n@[simps]\ndef preLeft (F : C â¥¤ A) (L : A â¥¤ T) (R : B â¥¤ T) : Comma (F â‹™ L) R â¥¤ Comma L R where\n  obj X :=\n    { left := F.obj X.left\n      right := X.right\n      hom := X.hom }\n  map f :=\n    { left := F.map f.left\n      right := f.right\n      w := by simpa using f.w }\n\n"}
{"name":"CategoryTheory.Comma.preLeft_map_left","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nC : Type uâ‚„\ninstâœ : CategoryTheory.Category.{vâ‚„, uâ‚„} C\nF : CategoryTheory.Functor C A\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nXâœ Yâœ : CategoryTheory.Comma (F.comp L) R\nf : Quiver.Hom Xâœ Yâœ\nâŠ¢ Eq ((CategoryTheory.Comma.preLeft F L R).map f).left (F.map f.left)","decl":"/-- The functor `(F â‹™ L, R) â¥¤ (L, R)` -/\n@[simps]\ndef preLeft (F : C â¥¤ A) (L : A â¥¤ T) (R : B â¥¤ T) : Comma (F â‹™ L) R â¥¤ Comma L R where\n  obj X :=\n    { left := F.obj X.left\n      right := X.right\n      hom := X.hom }\n  map f :=\n    { left := F.map f.left\n      right := f.right\n      w := by simpa using f.w }\n\n"}
{"name":"CategoryTheory.Comma.preLeft_map_right","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nC : Type uâ‚„\ninstâœ : CategoryTheory.Category.{vâ‚„, uâ‚„} C\nF : CategoryTheory.Functor C A\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nXâœ Yâœ : CategoryTheory.Comma (F.comp L) R\nf : Quiver.Hom Xâœ Yâœ\nâŠ¢ Eq ((CategoryTheory.Comma.preLeft F L R).map f).right f.right","decl":"/-- The functor `(F â‹™ L, R) â¥¤ (L, R)` -/\n@[simps]\ndef preLeft (F : C â¥¤ A) (L : A â¥¤ T) (R : B â¥¤ T) : Comma (F â‹™ L) R â¥¤ Comma L R where\n  obj X :=\n    { left := F.obj X.left\n      right := X.right\n      hom := X.hom }\n  map f :=\n    { left := F.map f.left\n      right := f.right\n      w := by simpa using f.w }\n\n"}
{"name":"CategoryTheory.Comma.preLeft_obj_hom","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nC : Type uâ‚„\ninstâœ : CategoryTheory.Category.{vâ‚„, uâ‚„} C\nF : CategoryTheory.Functor C A\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nX : CategoryTheory.Comma (F.comp L) R\nâŠ¢ Eq ((CategoryTheory.Comma.preLeft F L R).obj X).hom X.hom","decl":"/-- The functor `(F â‹™ L, R) â¥¤ (L, R)` -/\n@[simps]\ndef preLeft (F : C â¥¤ A) (L : A â¥¤ T) (R : B â¥¤ T) : Comma (F â‹™ L) R â¥¤ Comma L R where\n  obj X :=\n    { left := F.obj X.left\n      right := X.right\n      hom := X.hom }\n  map f :=\n    { left := F.map f.left\n      right := f.right\n      w := by simpa using f.w }\n\n"}
{"name":"CategoryTheory.Comma.instFaithfulCompPreLeft","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœÂ² : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nC : Type uâ‚„\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚„, uâ‚„} C\nF : CategoryTheory.Functor C A\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\ninstâœ : F.Faithful\nâŠ¢ (CategoryTheory.Comma.preLeft F L R).Faithful","decl":"instance (F : C â¥¤ A) (L : A â¥¤ T) (R : B â¥¤ T) [F.Faithful] : (preLeft F L R).Faithful :=\n  Functor.Faithful.of_iso (preLeftIso F L R).symm\n\n"}
{"name":"CategoryTheory.Comma.instFullCompPreLeft","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœÂ² : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nC : Type uâ‚„\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚„, uâ‚„} C\nF : CategoryTheory.Functor C A\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\ninstâœ : F.Full\nâŠ¢ (CategoryTheory.Comma.preLeft F L R).Full","decl":"instance (F : C â¥¤ A) (L : A â¥¤ T) (R : B â¥¤ T) [F.Full] : (preLeft F L R).Full :=\n  Functor.Full.of_iso (preLeftIso F L R).symm\n\n"}
{"name":"CategoryTheory.Comma.instEssSurjCompPreLeft","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœÂ² : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nC : Type uâ‚„\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚„, uâ‚„} C\nF : CategoryTheory.Functor C A\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\ninstâœ : F.EssSurj\nâŠ¢ (CategoryTheory.Comma.preLeft F L R).EssSurj","decl":"instance (F : C â¥¤ A) (L : A â¥¤ T) (R : B â¥¤ T) [F.EssSurj] : (preLeft F L R).EssSurj :=\n  Functor.essSurj_of_iso (preLeftIso F L R).symm\n\n"}
{"name":"CategoryTheory.Comma.isEquivalence_preLeft","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœÂ² : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nC : Type uâ‚„\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚„, uâ‚„} C\nF : CategoryTheory.Functor C A\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\ninstâœ : F.IsEquivalence\nâŠ¢ (CategoryTheory.Comma.preLeft F L R).IsEquivalence","decl":"/-- If `F` is an equivalence, then so is `preLeft F L R`. -/\ninstance isEquivalence_preLeft (F : C â¥¤ A) (L : A â¥¤ T) (R : B â¥¤ T) [F.IsEquivalence] :\n    (preLeft F L R).IsEquivalence where\n\n"}
{"name":"CategoryTheory.Comma.preRight_obj_right","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nC : Type uâ‚„\ninstâœ : CategoryTheory.Category.{vâ‚„, uâ‚„} C\nL : CategoryTheory.Functor A T\nF : CategoryTheory.Functor C B\nR : CategoryTheory.Functor B T\nX : CategoryTheory.Comma L (F.comp R)\nâŠ¢ Eq ((CategoryTheory.Comma.preRight L F R).obj X).right (F.obj X.right)","decl":"/-- The functor `(F â‹™ L, R) â¥¤ (L, R)` -/\n@[simps]\ndef preRight (L : A â¥¤ T) (F : C â¥¤ B) (R : B â¥¤ T) : Comma L (F â‹™ R) â¥¤ Comma L R where\n  obj X :=\n    { left := X.left\n      right := F.obj X.right\n      hom := X.hom }\n  map f :=\n    { left := f.left\n      right := F.map f.right }\n\n"}
{"name":"CategoryTheory.Comma.preRight_obj_hom","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nC : Type uâ‚„\ninstâœ : CategoryTheory.Category.{vâ‚„, uâ‚„} C\nL : CategoryTheory.Functor A T\nF : CategoryTheory.Functor C B\nR : CategoryTheory.Functor B T\nX : CategoryTheory.Comma L (F.comp R)\nâŠ¢ Eq ((CategoryTheory.Comma.preRight L F R).obj X).hom X.hom","decl":"/-- The functor `(F â‹™ L, R) â¥¤ (L, R)` -/\n@[simps]\ndef preRight (L : A â¥¤ T) (F : C â¥¤ B) (R : B â¥¤ T) : Comma L (F â‹™ R) â¥¤ Comma L R where\n  obj X :=\n    { left := X.left\n      right := F.obj X.right\n      hom := X.hom }\n  map f :=\n    { left := f.left\n      right := F.map f.right }\n\n"}
{"name":"CategoryTheory.Comma.preRight_obj_left","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nC : Type uâ‚„\ninstâœ : CategoryTheory.Category.{vâ‚„, uâ‚„} C\nL : CategoryTheory.Functor A T\nF : CategoryTheory.Functor C B\nR : CategoryTheory.Functor B T\nX : CategoryTheory.Comma L (F.comp R)\nâŠ¢ Eq ((CategoryTheory.Comma.preRight L F R).obj X).left X.left","decl":"/-- The functor `(F â‹™ L, R) â¥¤ (L, R)` -/\n@[simps]\ndef preRight (L : A â¥¤ T) (F : C â¥¤ B) (R : B â¥¤ T) : Comma L (F â‹™ R) â¥¤ Comma L R where\n  obj X :=\n    { left := X.left\n      right := F.obj X.right\n      hom := X.hom }\n  map f :=\n    { left := f.left\n      right := F.map f.right }\n\n"}
{"name":"CategoryTheory.Comma.preRight_map_left","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nC : Type uâ‚„\ninstâœ : CategoryTheory.Category.{vâ‚„, uâ‚„} C\nL : CategoryTheory.Functor A T\nF : CategoryTheory.Functor C B\nR : CategoryTheory.Functor B T\nXâœ Yâœ : CategoryTheory.Comma L (F.comp R)\nf : Quiver.Hom Xâœ Yâœ\nâŠ¢ Eq ((CategoryTheory.Comma.preRight L F R).map f).left f.left","decl":"/-- The functor `(F â‹™ L, R) â¥¤ (L, R)` -/\n@[simps]\ndef preRight (L : A â¥¤ T) (F : C â¥¤ B) (R : B â¥¤ T) : Comma L (F â‹™ R) â¥¤ Comma L R where\n  obj X :=\n    { left := X.left\n      right := F.obj X.right\n      hom := X.hom }\n  map f :=\n    { left := f.left\n      right := F.map f.right }\n\n"}
{"name":"CategoryTheory.Comma.preRight_map_right","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nC : Type uâ‚„\ninstâœ : CategoryTheory.Category.{vâ‚„, uâ‚„} C\nL : CategoryTheory.Functor A T\nF : CategoryTheory.Functor C B\nR : CategoryTheory.Functor B T\nXâœ Yâœ : CategoryTheory.Comma L (F.comp R)\nf : Quiver.Hom Xâœ Yâœ\nâŠ¢ Eq ((CategoryTheory.Comma.preRight L F R).map f).right (F.map f.right)","decl":"/-- The functor `(F â‹™ L, R) â¥¤ (L, R)` -/\n@[simps]\ndef preRight (L : A â¥¤ T) (F : C â¥¤ B) (R : B â¥¤ T) : Comma L (F â‹™ R) â¥¤ Comma L R where\n  obj X :=\n    { left := X.left\n      right := F.obj X.right\n      hom := X.hom }\n  map f :=\n    { left := f.left\n      right := F.map f.right }\n\n"}
{"name":"CategoryTheory.Comma.instFaithfulCompPreRight","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœÂ² : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nC : Type uâ‚„\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚„, uâ‚„} C\nL : CategoryTheory.Functor A T\nF : CategoryTheory.Functor C B\nR : CategoryTheory.Functor B T\ninstâœ : F.Faithful\nâŠ¢ (CategoryTheory.Comma.preRight L F R).Faithful","decl":"instance (L : A â¥¤ T) (F : C â¥¤ B) (R : B â¥¤ T) [F.Faithful] : (preRight L F R).Faithful :=\n  Functor.Faithful.of_iso (preRightIso L F R).symm\n\n"}
{"name":"CategoryTheory.Comma.instFullCompPreRight","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœÂ² : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nC : Type uâ‚„\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚„, uâ‚„} C\nL : CategoryTheory.Functor A T\nF : CategoryTheory.Functor C B\nR : CategoryTheory.Functor B T\ninstâœ : F.Full\nâŠ¢ (CategoryTheory.Comma.preRight L F R).Full","decl":"instance (L : A â¥¤ T) (F : C â¥¤ B) (R : B â¥¤ T) [F.Full] : (preRight L F R).Full :=\n  Functor.Full.of_iso (preRightIso L F R).symm\n\n"}
{"name":"CategoryTheory.Comma.instEssSurjCompPreRight","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœÂ² : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nC : Type uâ‚„\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚„, uâ‚„} C\nL : CategoryTheory.Functor A T\nF : CategoryTheory.Functor C B\nR : CategoryTheory.Functor B T\ninstâœ : F.EssSurj\nâŠ¢ (CategoryTheory.Comma.preRight L F R).EssSurj","decl":"instance (L : A â¥¤ T) (F : C â¥¤ B) (R : B â¥¤ T) [F.EssSurj] : (preRight L F R).EssSurj :=\n  Functor.essSurj_of_iso (preRightIso L F R).symm\n\n"}
{"name":"CategoryTheory.Comma.isEquivalence_preRight","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœÂ² : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nC : Type uâ‚„\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚„, uâ‚„} C\nL : CategoryTheory.Functor A T\nF : CategoryTheory.Functor C B\nR : CategoryTheory.Functor B T\ninstâœ : F.IsEquivalence\nâŠ¢ (CategoryTheory.Comma.preRight L F R).IsEquivalence","decl":"/-- If `F` is an equivalence, then so is `preRight L F R`. -/\ninstance isEquivalence_preRight (L : A â¥¤ T) (F : C â¥¤ B) (R : B â¥¤ T) [F.IsEquivalence] :\n    (preRight L F R).IsEquivalence where\n\n"}
{"name":"CategoryTheory.Comma.post_map_left","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nC : Type uâ‚„\ninstâœ : CategoryTheory.Category.{vâ‚„, uâ‚„} C\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nF : CategoryTheory.Functor T C\nXâœ Yâœ : CategoryTheory.Comma L R\nf : Quiver.Hom Xâœ Yâœ\nâŠ¢ Eq ((CategoryTheory.Comma.post L R F).map f).left f.left","decl":"/-- The functor `(L, R) â¥¤ (L â‹™ F, R â‹™ F)` -/\n@[simps]\ndef post (L : A â¥¤ T) (R : B â¥¤ T) (F : T â¥¤ C) : Comma L R â¥¤ Comma (L â‹™ F) (R â‹™ F) where\n  obj X :=\n    { left := X.left\n      right := X.right\n      hom := F.map X.hom }\n  map f :=\n    { left := f.left\n      right := f.right\n      w := by simp only [Functor.comp_map, â† F.map_comp, f.w] }\n\n"}
{"name":"CategoryTheory.Comma.post_obj_hom","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nC : Type uâ‚„\ninstâœ : CategoryTheory.Category.{vâ‚„, uâ‚„} C\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nF : CategoryTheory.Functor T C\nX : CategoryTheory.Comma L R\nâŠ¢ Eq ((CategoryTheory.Comma.post L R F).obj X).hom (F.map X.hom)","decl":"/-- The functor `(L, R) â¥¤ (L â‹™ F, R â‹™ F)` -/\n@[simps]\ndef post (L : A â¥¤ T) (R : B â¥¤ T) (F : T â¥¤ C) : Comma L R â¥¤ Comma (L â‹™ F) (R â‹™ F) where\n  obj X :=\n    { left := X.left\n      right := X.right\n      hom := F.map X.hom }\n  map f :=\n    { left := f.left\n      right := f.right\n      w := by simp only [Functor.comp_map, â† F.map_comp, f.w] }\n\n"}
{"name":"CategoryTheory.Comma.post_map_right","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nC : Type uâ‚„\ninstâœ : CategoryTheory.Category.{vâ‚„, uâ‚„} C\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nF : CategoryTheory.Functor T C\nXâœ Yâœ : CategoryTheory.Comma L R\nf : Quiver.Hom Xâœ Yâœ\nâŠ¢ Eq ((CategoryTheory.Comma.post L R F).map f).right f.right","decl":"/-- The functor `(L, R) â¥¤ (L â‹™ F, R â‹™ F)` -/\n@[simps]\ndef post (L : A â¥¤ T) (R : B â¥¤ T) (F : T â¥¤ C) : Comma L R â¥¤ Comma (L â‹™ F) (R â‹™ F) where\n  obj X :=\n    { left := X.left\n      right := X.right\n      hom := F.map X.hom }\n  map f :=\n    { left := f.left\n      right := f.right\n      w := by simp only [Functor.comp_map, â† F.map_comp, f.w] }\n\n"}
{"name":"CategoryTheory.Comma.post_obj_right","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nC : Type uâ‚„\ninstâœ : CategoryTheory.Category.{vâ‚„, uâ‚„} C\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nF : CategoryTheory.Functor T C\nX : CategoryTheory.Comma L R\nâŠ¢ Eq ((CategoryTheory.Comma.post L R F).obj X).right X.right","decl":"/-- The functor `(L, R) â¥¤ (L â‹™ F, R â‹™ F)` -/\n@[simps]\ndef post (L : A â¥¤ T) (R : B â¥¤ T) (F : T â¥¤ C) : Comma L R â¥¤ Comma (L â‹™ F) (R â‹™ F) where\n  obj X :=\n    { left := X.left\n      right := X.right\n      hom := F.map X.hom }\n  map f :=\n    { left := f.left\n      right := f.right\n      w := by simp only [Functor.comp_map, â† F.map_comp, f.w] }\n\n"}
{"name":"CategoryTheory.Comma.post_obj_left","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nC : Type uâ‚„\ninstâœ : CategoryTheory.Category.{vâ‚„, uâ‚„} C\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nF : CategoryTheory.Functor T C\nX : CategoryTheory.Comma L R\nâŠ¢ Eq ((CategoryTheory.Comma.post L R F).obj X).left X.left","decl":"/-- The functor `(L, R) â¥¤ (L â‹™ F, R â‹™ F)` -/\n@[simps]\ndef post (L : A â¥¤ T) (R : B â¥¤ T) (F : T â¥¤ C) : Comma L R â¥¤ Comma (L â‹™ F) (R â‹™ F) where\n  obj X :=\n    { left := X.left\n      right := X.right\n      hom := F.map X.hom }\n  map f :=\n    { left := f.left\n      right := f.right\n      w := by simp only [Functor.comp_map, â† F.map_comp, f.w] }\n\n"}
{"name":"CategoryTheory.Comma.instFaithfulCompPost","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nC : Type uâ‚„\ninstâœ : CategoryTheory.Category.{vâ‚„, uâ‚„} C\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nF : CategoryTheory.Functor T C\nâŠ¢ (CategoryTheory.Comma.post L R F).Faithful","decl":"instance (L : A â¥¤ T) (R : B â¥¤ T) (F : T â¥¤ C) : (post L R F).Faithful :=\n  Functor.Faithful.of_iso (postIso L R F).symm\n\n"}
{"name":"CategoryTheory.Comma.instFullCompPostOfFaithful","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœÂ² : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nC : Type uâ‚„\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚„, uâ‚„} C\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nF : CategoryTheory.Functor T C\ninstâœ : F.Faithful\nâŠ¢ (CategoryTheory.Comma.post L R F).Full","decl":"instance (L : A â¥¤ T) (R : B â¥¤ T) (F : T â¥¤ C) [F.Faithful] : (post L R F).Full :=\n  Functor.Full.of_iso (postIso L R F).symm\n\n"}
{"name":"CategoryTheory.Comma.instEssSurjCompPostOfFull","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœÂ² : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nC : Type uâ‚„\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚„, uâ‚„} C\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nF : CategoryTheory.Functor T C\ninstâœ : F.Full\nâŠ¢ (CategoryTheory.Comma.post L R F).EssSurj","decl":"instance (L : A â¥¤ T) (R : B â¥¤ T) (F : T â¥¤ C) [F.Full] : (post L R F).EssSurj :=\n  Functor.essSurj_of_iso (postIso L R F).symm\n\n"}
{"name":"CategoryTheory.Comma.isEquivalence_post","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœÂ² : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nC : Type uâ‚„\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚„, uâ‚„} C\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nF : CategoryTheory.Functor T C\ninstâœ : F.IsEquivalence\nâŠ¢ (CategoryTheory.Comma.post L R F).IsEquivalence","decl":"/-- If `F` is an equivalence, then so is `post L R F`. -/\ninstance isEquivalence_post (L : A â¥¤ T) (R : B â¥¤ T) (F : T â¥¤ C) [F.IsEquivalence] :\n    (post L R F).IsEquivalence where\n\n"}
{"name":"CategoryTheory.Comma.fromProd_map_right","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nL : CategoryTheory.Functor A (CategoryTheory.Discrete PUnit.{u_1 + 1})\nR : CategoryTheory.Functor B (CategoryTheory.Discrete PUnit.{u_1 + 1})\nX Y : Prod A B\nf : Quiver.Hom X Y\nâŠ¢ Eq ((CategoryTheory.Comma.fromProd L R).map f).right f.2","decl":"/-- The canonical functor from the product of two categories to the comma category of their\nrespective functors into `Discrete PUnit`. -/\n@[simps]\ndef fromProd (L : A â¥¤ Discrete PUnit) (R : B â¥¤ Discrete PUnit) :\n    A Ã— B â¥¤ Comma L R where\n  obj X :=\n    { left := X.1\n      right := X.2\n      hom := Discrete.eqToHom rfl }\n  map {X} {Y} f :=\n    { left := f.1\n      right := f.2 }\n\n"}
{"name":"CategoryTheory.Comma.fromProd_map_left","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nL : CategoryTheory.Functor A (CategoryTheory.Discrete PUnit.{u_1 + 1})\nR : CategoryTheory.Functor B (CategoryTheory.Discrete PUnit.{u_1 + 1})\nX Y : Prod A B\nf : Quiver.Hom X Y\nâŠ¢ Eq ((CategoryTheory.Comma.fromProd L R).map f).left f.1","decl":"/-- The canonical functor from the product of two categories to the comma category of their\nrespective functors into `Discrete PUnit`. -/\n@[simps]\ndef fromProd (L : A â¥¤ Discrete PUnit) (R : B â¥¤ Discrete PUnit) :\n    A Ã— B â¥¤ Comma L R where\n  obj X :=\n    { left := X.1\n      right := X.2\n      hom := Discrete.eqToHom rfl }\n  map {X} {Y} f :=\n    { left := f.1\n      right := f.2 }\n\n"}
{"name":"CategoryTheory.Comma.fromProd_obj_right","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nL : CategoryTheory.Functor A (CategoryTheory.Discrete PUnit.{u_1 + 1})\nR : CategoryTheory.Functor B (CategoryTheory.Discrete PUnit.{u_1 + 1})\nX : Prod A B\nâŠ¢ Eq ((CategoryTheory.Comma.fromProd L R).obj X).right X.2","decl":"/-- The canonical functor from the product of two categories to the comma category of their\nrespective functors into `Discrete PUnit`. -/\n@[simps]\ndef fromProd (L : A â¥¤ Discrete PUnit) (R : B â¥¤ Discrete PUnit) :\n    A Ã— B â¥¤ Comma L R where\n  obj X :=\n    { left := X.1\n      right := X.2\n      hom := Discrete.eqToHom rfl }\n  map {X} {Y} f :=\n    { left := f.1\n      right := f.2 }\n\n"}
{"name":"CategoryTheory.Comma.fromProd_obj_hom","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nL : CategoryTheory.Functor A (CategoryTheory.Discrete PUnit.{u_1 + 1})\nR : CategoryTheory.Functor B (CategoryTheory.Discrete PUnit.{u_1 + 1})\nX : Prod A B\nâŠ¢ Eq ((CategoryTheory.Comma.fromProd L R).obj X).hom (CategoryTheory.Discrete.eqToHom â‹¯)","decl":"/-- The canonical functor from the product of two categories to the comma category of their\nrespective functors into `Discrete PUnit`. -/\n@[simps]\ndef fromProd (L : A â¥¤ Discrete PUnit) (R : B â¥¤ Discrete PUnit) :\n    A Ã— B â¥¤ Comma L R where\n  obj X :=\n    { left := X.1\n      right := X.2\n      hom := Discrete.eqToHom rfl }\n  map {X} {Y} f :=\n    { left := f.1\n      right := f.2 }\n\n"}
{"name":"CategoryTheory.Comma.fromProd_obj_left","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nL : CategoryTheory.Functor A (CategoryTheory.Discrete PUnit.{u_1 + 1})\nR : CategoryTheory.Functor B (CategoryTheory.Discrete PUnit.{u_1 + 1})\nX : Prod A B\nâŠ¢ Eq ((CategoryTheory.Comma.fromProd L R).obj X).left X.1","decl":"/-- The canonical functor from the product of two categories to the comma category of their\nrespective functors into `Discrete PUnit`. -/\n@[simps]\ndef fromProd (L : A â¥¤ Discrete PUnit) (R : B â¥¤ Discrete PUnit) :\n    A Ã— B â¥¤ Comma L R where\n  obj X :=\n    { left := X.1\n      right := X.2\n      hom := Discrete.eqToHom rfl }\n  map {X} {Y} f :=\n    { left := f.1\n      right := f.2 }\n\n"}
{"name":"CategoryTheory.Comma.equivProd_unitIso_hom_app_right","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nL : CategoryTheory.Functor A (CategoryTheory.Discrete PUnit.{u_1 + 1})\nR : CategoryTheory.Functor B (CategoryTheory.Discrete PUnit.{u_1 + 1})\nX : CategoryTheory.Comma L R\nâŠ¢ Eq ((CategoryTheory.Comma.equivProd L R).unitIso.hom.app X).right (CategoryTheory.CategoryStruct.id X.right)","decl":"/-- Taking the comma category of two functors into `Discrete PUnit` results in something\nis equivalent to their product. -/\n@[simps!]\ndef equivProd (L : A â¥¤ Discrete PUnit) (R : B â¥¤ Discrete PUnit) :\n    Comma L R â‰Œ A Ã— B where\n  functor := (fst L R).prod' (snd L R)\n  inverse := fromProd L R\n  unitIso := Iso.refl _\n  counitIso := Iso.refl _\n\n"}
{"name":"CategoryTheory.Comma.equivProd_unitIso_inv_app_left","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nL : CategoryTheory.Functor A (CategoryTheory.Discrete PUnit.{u_1 + 1})\nR : CategoryTheory.Functor B (CategoryTheory.Discrete PUnit.{u_1 + 1})\nX : CategoryTheory.Comma L R\nâŠ¢ Eq ((CategoryTheory.Comma.equivProd L R).unitIso.inv.app X).left (CategoryTheory.CategoryStruct.id X.left)","decl":"/-- Taking the comma category of two functors into `Discrete PUnit` results in something\nis equivalent to their product. -/\n@[simps!]\ndef equivProd (L : A â¥¤ Discrete PUnit) (R : B â¥¤ Discrete PUnit) :\n    Comma L R â‰Œ A Ã— B where\n  functor := (fst L R).prod' (snd L R)\n  inverse := fromProd L R\n  unitIso := Iso.refl _\n  counitIso := Iso.refl _\n\n"}
{"name":"CategoryTheory.Comma.equivProd_counitIso_inv_app","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nL : CategoryTheory.Functor A (CategoryTheory.Discrete PUnit.{u_1 + 1})\nR : CategoryTheory.Functor B (CategoryTheory.Discrete PUnit.{u_1 + 1})\nX : Prod A B\nâŠ¢ Eq ((CategoryTheory.Comma.equivProd L R).counitIso.inv.app X) { fst := CategoryTheory.CategoryStruct.id X.1, snd := CategoryTheory.CategoryStruct.id X.2 }","decl":"/-- Taking the comma category of two functors into `Discrete PUnit` results in something\nis equivalent to their product. -/\n@[simps!]\ndef equivProd (L : A â¥¤ Discrete PUnit) (R : B â¥¤ Discrete PUnit) :\n    Comma L R â‰Œ A Ã— B where\n  functor := (fst L R).prod' (snd L R)\n  inverse := fromProd L R\n  unitIso := Iso.refl _\n  counitIso := Iso.refl _\n\n"}
{"name":"CategoryTheory.Comma.equivProd_functor_obj","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nL : CategoryTheory.Functor A (CategoryTheory.Discrete PUnit.{u_1 + 1})\nR : CategoryTheory.Functor B (CategoryTheory.Discrete PUnit.{u_1 + 1})\na : CategoryTheory.Comma L R\nâŠ¢ Eq ((CategoryTheory.Comma.equivProd L R).functor.obj a) { fst := a.left, snd := a.right }","decl":"/-- Taking the comma category of two functors into `Discrete PUnit` results in something\nis equivalent to their product. -/\n@[simps!]\ndef equivProd (L : A â¥¤ Discrete PUnit) (R : B â¥¤ Discrete PUnit) :\n    Comma L R â‰Œ A Ã— B where\n  functor := (fst L R).prod' (snd L R)\n  inverse := fromProd L R\n  unitIso := Iso.refl _\n  counitIso := Iso.refl _\n\n"}
{"name":"CategoryTheory.Comma.equivProd_functor_map","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nL : CategoryTheory.Functor A (CategoryTheory.Discrete PUnit.{u_1 + 1})\nR : CategoryTheory.Functor B (CategoryTheory.Discrete PUnit.{u_1 + 1})\nXâœ Yâœ : CategoryTheory.Comma L R\nf : Quiver.Hom Xâœ Yâœ\nâŠ¢ Eq ((CategoryTheory.Comma.equivProd L R).functor.map f) { fst := f.left, snd := f.right }","decl":"/-- Taking the comma category of two functors into `Discrete PUnit` results in something\nis equivalent to their product. -/\n@[simps!]\ndef equivProd (L : A â¥¤ Discrete PUnit) (R : B â¥¤ Discrete PUnit) :\n    Comma L R â‰Œ A Ã— B where\n  functor := (fst L R).prod' (snd L R)\n  inverse := fromProd L R\n  unitIso := Iso.refl _\n  counitIso := Iso.refl _\n\n"}
{"name":"CategoryTheory.Comma.equivProd_inverse_obj_left","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nL : CategoryTheory.Functor A (CategoryTheory.Discrete PUnit.{u_1 + 1})\nR : CategoryTheory.Functor B (CategoryTheory.Discrete PUnit.{u_1 + 1})\nX : Prod A B\nâŠ¢ Eq ((CategoryTheory.Comma.equivProd L R).inverse.obj X).left X.1","decl":"/-- Taking the comma category of two functors into `Discrete PUnit` results in something\nis equivalent to their product. -/\n@[simps!]\ndef equivProd (L : A â¥¤ Discrete PUnit) (R : B â¥¤ Discrete PUnit) :\n    Comma L R â‰Œ A Ã— B where\n  functor := (fst L R).prod' (snd L R)\n  inverse := fromProd L R\n  unitIso := Iso.refl _\n  counitIso := Iso.refl _\n\n"}
{"name":"CategoryTheory.Comma.equivProd_inverse_obj_hom_down_down","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nL : CategoryTheory.Functor A (CategoryTheory.Discrete PUnit.{u_1 + 1})\nR : CategoryTheory.Functor B (CategoryTheory.Discrete PUnit.{u_1 + 1})\nX : Prod A B\nâŠ¢ Eq â‹¯ â‹¯","decl":"/-- Taking the comma category of two functors into `Discrete PUnit` results in something\nis equivalent to their product. -/\n@[simps!]\ndef equivProd (L : A â¥¤ Discrete PUnit) (R : B â¥¤ Discrete PUnit) :\n    Comma L R â‰Œ A Ã— B where\n  functor := (fst L R).prod' (snd L R)\n  inverse := fromProd L R\n  unitIso := Iso.refl _\n  counitIso := Iso.refl _\n\n"}
{"name":"CategoryTheory.Comma.equivProd_counitIso_hom_app","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nL : CategoryTheory.Functor A (CategoryTheory.Discrete PUnit.{u_1 + 1})\nR : CategoryTheory.Functor B (CategoryTheory.Discrete PUnit.{u_1 + 1})\nX : Prod A B\nâŠ¢ Eq ((CategoryTheory.Comma.equivProd L R).counitIso.hom.app X) { fst := CategoryTheory.CategoryStruct.id X.1, snd := CategoryTheory.CategoryStruct.id X.2 }","decl":"/-- Taking the comma category of two functors into `Discrete PUnit` results in something\nis equivalent to their product. -/\n@[simps!]\ndef equivProd (L : A â¥¤ Discrete PUnit) (R : B â¥¤ Discrete PUnit) :\n    Comma L R â‰Œ A Ã— B where\n  functor := (fst L R).prod' (snd L R)\n  inverse := fromProd L R\n  unitIso := Iso.refl _\n  counitIso := Iso.refl _\n\n"}
{"name":"CategoryTheory.Comma.equivProd_unitIso_hom_app_left","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nL : CategoryTheory.Functor A (CategoryTheory.Discrete PUnit.{u_1 + 1})\nR : CategoryTheory.Functor B (CategoryTheory.Discrete PUnit.{u_1 + 1})\nX : CategoryTheory.Comma L R\nâŠ¢ Eq ((CategoryTheory.Comma.equivProd L R).unitIso.hom.app X).left (CategoryTheory.CategoryStruct.id X.left)","decl":"/-- Taking the comma category of two functors into `Discrete PUnit` results in something\nis equivalent to their product. -/\n@[simps!]\ndef equivProd (L : A â¥¤ Discrete PUnit) (R : B â¥¤ Discrete PUnit) :\n    Comma L R â‰Œ A Ã— B where\n  functor := (fst L R).prod' (snd L R)\n  inverse := fromProd L R\n  unitIso := Iso.refl _\n  counitIso := Iso.refl _\n\n"}
{"name":"CategoryTheory.Comma.equivProd_inverse_map_left","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nL : CategoryTheory.Functor A (CategoryTheory.Discrete PUnit.{u_1 + 1})\nR : CategoryTheory.Functor B (CategoryTheory.Discrete PUnit.{u_1 + 1})\nX Y : Prod A B\nf : Quiver.Hom X Y\nâŠ¢ Eq ((CategoryTheory.Comma.equivProd L R).inverse.map f).left f.1","decl":"/-- Taking the comma category of two functors into `Discrete PUnit` results in something\nis equivalent to their product. -/\n@[simps!]\ndef equivProd (L : A â¥¤ Discrete PUnit) (R : B â¥¤ Discrete PUnit) :\n    Comma L R â‰Œ A Ã— B where\n  functor := (fst L R).prod' (snd L R)\n  inverse := fromProd L R\n  unitIso := Iso.refl _\n  counitIso := Iso.refl _\n\n"}
{"name":"CategoryTheory.Comma.equivProd_unitIso_inv_app_right","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nL : CategoryTheory.Functor A (CategoryTheory.Discrete PUnit.{u_1 + 1})\nR : CategoryTheory.Functor B (CategoryTheory.Discrete PUnit.{u_1 + 1})\nX : CategoryTheory.Comma L R\nâŠ¢ Eq ((CategoryTheory.Comma.equivProd L R).unitIso.inv.app X).right (CategoryTheory.CategoryStruct.id X.right)","decl":"/-- Taking the comma category of two functors into `Discrete PUnit` results in something\nis equivalent to their product. -/\n@[simps!]\ndef equivProd (L : A â¥¤ Discrete PUnit) (R : B â¥¤ Discrete PUnit) :\n    Comma L R â‰Œ A Ã— B where\n  functor := (fst L R).prod' (snd L R)\n  inverse := fromProd L R\n  unitIso := Iso.refl _\n  counitIso := Iso.refl _\n\n"}
{"name":"CategoryTheory.Comma.equivProd_inverse_obj_right","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nL : CategoryTheory.Functor A (CategoryTheory.Discrete PUnit.{u_1 + 1})\nR : CategoryTheory.Functor B (CategoryTheory.Discrete PUnit.{u_1 + 1})\nX : Prod A B\nâŠ¢ Eq ((CategoryTheory.Comma.equivProd L R).inverse.obj X).right X.2","decl":"/-- Taking the comma category of two functors into `Discrete PUnit` results in something\nis equivalent to their product. -/\n@[simps!]\ndef equivProd (L : A â¥¤ Discrete PUnit) (R : B â¥¤ Discrete PUnit) :\n    Comma L R â‰Œ A Ã— B where\n  functor := (fst L R).prod' (snd L R)\n  inverse := fromProd L R\n  unitIso := Iso.refl _\n  counitIso := Iso.refl _\n\n"}
{"name":"CategoryTheory.Comma.equivProd_inverse_map_right","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nL : CategoryTheory.Functor A (CategoryTheory.Discrete PUnit.{u_1 + 1})\nR : CategoryTheory.Functor B (CategoryTheory.Discrete PUnit.{u_1 + 1})\nX Y : Prod A B\nf : Quiver.Hom X Y\nâŠ¢ Eq ((CategoryTheory.Comma.equivProd L R).inverse.map f).right f.2","decl":"/-- Taking the comma category of two functors into `Discrete PUnit` results in something\nis equivalent to their product. -/\n@[simps!]\ndef equivProd (L : A â¥¤ Discrete PUnit) (R : B â¥¤ Discrete PUnit) :\n    Comma L R â‰Œ A Ã— B where\n  functor := (fst L R).prod' (snd L R)\n  inverse := fromProd L R\n  unitIso := Iso.refl _\n  counitIso := Iso.refl _\n\n"}
{"name":"CategoryTheory.Comma.toPUnitIdEquiv_unitIso_inv_app_left","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} A\nL : CategoryTheory.Functor A (CategoryTheory.Discrete PUnit.{u_1 + 1})\nR : CategoryTheory.Functor (CategoryTheory.Discrete PUnit.{u_2 + 1}) (CategoryTheory.Discrete PUnit.{u_1 + 1})\nX : CategoryTheory.Comma L R\nâŠ¢ Eq ((CategoryTheory.Comma.toPUnitIdEquiv L R).unitIso.inv.app X).left (CategoryTheory.CategoryStruct.id X.left)","decl":"/-- Taking the comma category of a functor into `A â¥¤ Discrete PUnit` and the identity\n`Discrete PUnit â¥¤ Discrete PUnit` results in a category equivalent to `A`. -/\n@[simps!]\ndef toPUnitIdEquiv (L : A â¥¤ Discrete PUnit) (R : Discrete PUnit â¥¤ Discrete PUnit) :\n    Comma L R â‰Œ A :=\n  (equivProd L _).trans (prod.rightUnitorEquivalence A)\n\n"}
{"name":"CategoryTheory.Comma.toPUnitIdEquiv_functor_obj","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} A\nL : CategoryTheory.Functor A (CategoryTheory.Discrete PUnit.{u_1 + 1})\nR : CategoryTheory.Functor (CategoryTheory.Discrete PUnit.{u_2 + 1}) (CategoryTheory.Discrete PUnit.{u_1 + 1})\nX : CategoryTheory.Comma L R\nâŠ¢ Eq ((CategoryTheory.Comma.toPUnitIdEquiv L R).functor.obj X) X.left","decl":"/-- Taking the comma category of a functor into `A â¥¤ Discrete PUnit` and the identity\n`Discrete PUnit â¥¤ Discrete PUnit` results in a category equivalent to `A`. -/\n@[simps!]\ndef toPUnitIdEquiv (L : A â¥¤ Discrete PUnit) (R : Discrete PUnit â¥¤ Discrete PUnit) :\n    Comma L R â‰Œ A :=\n  (equivProd L _).trans (prod.rightUnitorEquivalence A)\n\n"}
{"name":"CategoryTheory.Comma.toPUnitIdEquiv_unitIso_hom_app_left","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} A\nL : CategoryTheory.Functor A (CategoryTheory.Discrete PUnit.{u_1 + 1})\nR : CategoryTheory.Functor (CategoryTheory.Discrete PUnit.{u_2 + 1}) (CategoryTheory.Discrete PUnit.{u_1 + 1})\nX : CategoryTheory.Comma L R\nâŠ¢ Eq ((CategoryTheory.Comma.toPUnitIdEquiv L R).unitIso.hom.app X).left (CategoryTheory.CategoryStruct.id X.left)","decl":"/-- Taking the comma category of a functor into `A â¥¤ Discrete PUnit` and the identity\n`Discrete PUnit â¥¤ Discrete PUnit` results in a category equivalent to `A`. -/\n@[simps!]\ndef toPUnitIdEquiv (L : A â¥¤ Discrete PUnit) (R : Discrete PUnit â¥¤ Discrete PUnit) :\n    Comma L R â‰Œ A :=\n  (equivProd L _).trans (prod.rightUnitorEquivalence A)\n\n"}
{"name":"CategoryTheory.Comma.toPUnitIdEquiv_inverse_obj_hom_down_down","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} A\nL : CategoryTheory.Functor A (CategoryTheory.Discrete PUnit.{u_1 + 1})\nR : CategoryTheory.Functor (CategoryTheory.Discrete PUnit.{u_2 + 1}) (CategoryTheory.Discrete PUnit.{u_1 + 1})\nX : A\nâŠ¢ Eq â‹¯ â‹¯","decl":"/-- Taking the comma category of a functor into `A â¥¤ Discrete PUnit` and the identity\n`Discrete PUnit â¥¤ Discrete PUnit` results in a category equivalent to `A`. -/\n@[simps!]\ndef toPUnitIdEquiv (L : A â¥¤ Discrete PUnit) (R : Discrete PUnit â¥¤ Discrete PUnit) :\n    Comma L R â‰Œ A :=\n  (equivProd L _).trans (prod.rightUnitorEquivalence A)\n\n"}
{"name":"CategoryTheory.Comma.toPUnitIdEquiv_inverse_map_right_down_down","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} A\nL : CategoryTheory.Functor A (CategoryTheory.Discrete PUnit.{u_1 + 1})\nR : CategoryTheory.Functor (CategoryTheory.Discrete PUnit.{u_2 + 1}) (CategoryTheory.Discrete PUnit.{u_1 + 1})\nXâœ Yâœ : A\nf : Quiver.Hom Xâœ Yâœ\nâŠ¢ Eq â‹¯ â‹¯","decl":"/-- Taking the comma category of a functor into `A â¥¤ Discrete PUnit` and the identity\n`Discrete PUnit â¥¤ Discrete PUnit` results in a category equivalent to `A`. -/\n@[simps!]\ndef toPUnitIdEquiv (L : A â¥¤ Discrete PUnit) (R : Discrete PUnit â¥¤ Discrete PUnit) :\n    Comma L R â‰Œ A :=\n  (equivProd L _).trans (prod.rightUnitorEquivalence A)\n\n"}
{"name":"CategoryTheory.Comma.toPUnitIdEquiv_unitIso_inv_app_right_down_down","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} A\nL : CategoryTheory.Functor A (CategoryTheory.Discrete PUnit.{u_1 + 1})\nR : CategoryTheory.Functor (CategoryTheory.Discrete PUnit.{u_2 + 1}) (CategoryTheory.Discrete PUnit.{u_1 + 1})\nX : CategoryTheory.Comma L R\nâŠ¢ Eq â‹¯ â‹¯","decl":"/-- Taking the comma category of a functor into `A â¥¤ Discrete PUnit` and the identity\n`Discrete PUnit â¥¤ Discrete PUnit` results in a category equivalent to `A`. -/\n@[simps!]\ndef toPUnitIdEquiv (L : A â¥¤ Discrete PUnit) (R : Discrete PUnit â¥¤ Discrete PUnit) :\n    Comma L R â‰Œ A :=\n  (equivProd L _).trans (prod.rightUnitorEquivalence A)\n\n"}
{"name":"CategoryTheory.Comma.toPUnitIdEquiv_inverse_obj_right_as","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} A\nL : CategoryTheory.Functor A (CategoryTheory.Discrete PUnit.{u_1 + 1})\nR : CategoryTheory.Functor (CategoryTheory.Discrete PUnit.{u_2 + 1}) (CategoryTheory.Discrete PUnit.{u_1 + 1})\nX : A\nâŠ¢ Eq ((CategoryTheory.Comma.toPUnitIdEquiv L R).inverse.obj X).right.as PUnit.unit","decl":"/-- Taking the comma category of a functor into `A â¥¤ Discrete PUnit` and the identity\n`Discrete PUnit â¥¤ Discrete PUnit` results in a category equivalent to `A`. -/\n@[simps!]\ndef toPUnitIdEquiv (L : A â¥¤ Discrete PUnit) (R : Discrete PUnit â¥¤ Discrete PUnit) :\n    Comma L R â‰Œ A :=\n  (equivProd L _).trans (prod.rightUnitorEquivalence A)\n\n"}
{"name":"CategoryTheory.Comma.toPUnitIdEquiv_inverse_map_left","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} A\nL : CategoryTheory.Functor A (CategoryTheory.Discrete PUnit.{u_1 + 1})\nR : CategoryTheory.Functor (CategoryTheory.Discrete PUnit.{u_2 + 1}) (CategoryTheory.Discrete PUnit.{u_1 + 1})\nXâœ Yâœ : A\nf : Quiver.Hom Xâœ Yâœ\nâŠ¢ Eq ((CategoryTheory.Comma.toPUnitIdEquiv L R).inverse.map f).left f","decl":"/-- Taking the comma category of a functor into `A â¥¤ Discrete PUnit` and the identity\n`Discrete PUnit â¥¤ Discrete PUnit` results in a category equivalent to `A`. -/\n@[simps!]\ndef toPUnitIdEquiv (L : A â¥¤ Discrete PUnit) (R : Discrete PUnit â¥¤ Discrete PUnit) :\n    Comma L R â‰Œ A :=\n  (equivProd L _).trans (prod.rightUnitorEquivalence A)\n\n"}
{"name":"CategoryTheory.Comma.toPUnitIdEquiv_functor_map","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} A\nL : CategoryTheory.Functor A (CategoryTheory.Discrete PUnit.{u_1 + 1})\nR : CategoryTheory.Functor (CategoryTheory.Discrete PUnit.{u_2 + 1}) (CategoryTheory.Discrete PUnit.{u_1 + 1})\nXâœ Yâœ : CategoryTheory.Comma L R\nf : Quiver.Hom Xâœ Yâœ\nâŠ¢ Eq ((CategoryTheory.Comma.toPUnitIdEquiv L R).functor.map f) f.left","decl":"/-- Taking the comma category of a functor into `A â¥¤ Discrete PUnit` and the identity\n`Discrete PUnit â¥¤ Discrete PUnit` results in a category equivalent to `A`. -/\n@[simps!]\ndef toPUnitIdEquiv (L : A â¥¤ Discrete PUnit) (R : Discrete PUnit â¥¤ Discrete PUnit) :\n    Comma L R â‰Œ A :=\n  (equivProd L _).trans (prod.rightUnitorEquivalence A)\n\n"}
{"name":"CategoryTheory.Comma.toPUnitIdEquiv_unitIso_hom_app_right_down_down","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} A\nL : CategoryTheory.Functor A (CategoryTheory.Discrete PUnit.{u_1 + 1})\nR : CategoryTheory.Functor (CategoryTheory.Discrete PUnit.{u_2 + 1}) (CategoryTheory.Discrete PUnit.{u_1 + 1})\nX : CategoryTheory.Comma L R\nâŠ¢ Eq â‹¯ â‹¯","decl":"/-- Taking the comma category of a functor into `A â¥¤ Discrete PUnit` and the identity\n`Discrete PUnit â¥¤ Discrete PUnit` results in a category equivalent to `A`. -/\n@[simps!]\ndef toPUnitIdEquiv (L : A â¥¤ Discrete PUnit) (R : Discrete PUnit â¥¤ Discrete PUnit) :\n    Comma L R â‰Œ A :=\n  (equivProd L _).trans (prod.rightUnitorEquivalence A)\n\n"}
{"name":"CategoryTheory.Comma.toPUnitIdEquiv_inverse_obj_left","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} A\nL : CategoryTheory.Functor A (CategoryTheory.Discrete PUnit.{u_1 + 1})\nR : CategoryTheory.Functor (CategoryTheory.Discrete PUnit.{u_2 + 1}) (CategoryTheory.Discrete PUnit.{u_1 + 1})\nX : A\nâŠ¢ Eq ((CategoryTheory.Comma.toPUnitIdEquiv L R).inverse.obj X).left X","decl":"/-- Taking the comma category of a functor into `A â¥¤ Discrete PUnit` and the identity\n`Discrete PUnit â¥¤ Discrete PUnit` results in a category equivalent to `A`. -/\n@[simps!]\ndef toPUnitIdEquiv (L : A â¥¤ Discrete PUnit) (R : Discrete PUnit â¥¤ Discrete PUnit) :\n    Comma L R â‰Œ A :=\n  (equivProd L _).trans (prod.rightUnitorEquivalence A)\n\n"}
{"name":"CategoryTheory.Comma.toPUnitIdEquiv_counitIso_hom_app","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} A\nL : CategoryTheory.Functor A (CategoryTheory.Discrete PUnit.{u_1 + 1})\nR : CategoryTheory.Functor (CategoryTheory.Discrete PUnit.{u_2 + 1}) (CategoryTheory.Discrete PUnit.{u_1 + 1})\nX : A\nâŠ¢ Eq ((CategoryTheory.Comma.toPUnitIdEquiv L R).counitIso.hom.app X) (CategoryTheory.CategoryStruct.id X)","decl":"/-- Taking the comma category of a functor into `A â¥¤ Discrete PUnit` and the identity\n`Discrete PUnit â¥¤ Discrete PUnit` results in a category equivalent to `A`. -/\n@[simps!]\ndef toPUnitIdEquiv (L : A â¥¤ Discrete PUnit) (R : Discrete PUnit â¥¤ Discrete PUnit) :\n    Comma L R â‰Œ A :=\n  (equivProd L _).trans (prod.rightUnitorEquivalence A)\n\n"}
{"name":"CategoryTheory.Comma.toPUnitIdEquiv_counitIso_inv_app","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} A\nL : CategoryTheory.Functor A (CategoryTheory.Discrete PUnit.{u_1 + 1})\nR : CategoryTheory.Functor (CategoryTheory.Discrete PUnit.{u_2 + 1}) (CategoryTheory.Discrete PUnit.{u_1 + 1})\nX : A\nâŠ¢ Eq ((CategoryTheory.Comma.toPUnitIdEquiv L R).counitIso.inv.app X) (CategoryTheory.CategoryStruct.id X)","decl":"/-- Taking the comma category of a functor into `A â¥¤ Discrete PUnit` and the identity\n`Discrete PUnit â¥¤ Discrete PUnit` results in a category equivalent to `A`. -/\n@[simps!]\ndef toPUnitIdEquiv (L : A â¥¤ Discrete PUnit) (R : Discrete PUnit â¥¤ Discrete PUnit) :\n    Comma L R â‰Œ A :=\n  (equivProd L _).trans (prod.rightUnitorEquivalence A)\n\n"}
{"name":"CategoryTheory.Comma.toPUnitIdEquiv_functor_iso","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} A\nL : CategoryTheory.Functor A (CategoryTheory.Discrete PUnit.{u_1 + 1})\nR : CategoryTheory.Functor (CategoryTheory.Discrete PUnit.{u_2 + 1}) (CategoryTheory.Discrete PUnit.{u_1 + 1})\nâŠ¢ Eq (CategoryTheory.Comma.toPUnitIdEquiv L R).functor (CategoryTheory.Comma.fst L R)","decl":"@[simp]\ntheorem toPUnitIdEquiv_functor_iso {L : A â¥¤ Discrete PUnit}\n    {R : Discrete PUnit â¥¤ Discrete PUnit} :\n    (toPUnitIdEquiv L R).functor = fst L R :=\n  rfl\n\n"}
{"name":"CategoryTheory.Comma.toIdPUnitEquiv_counitIso_inv_app","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"B : Type uâ‚‚\ninstâœ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nL : CategoryTheory.Functor (CategoryTheory.Discrete PUnit.{u_1 + 1}) (CategoryTheory.Discrete PUnit.{u_2 + 1})\nR : CategoryTheory.Functor B (CategoryTheory.Discrete PUnit.{u_2 + 1})\nX : B\nâŠ¢ Eq ((CategoryTheory.Comma.toIdPUnitEquiv L R).counitIso.inv.app X) (CategoryTheory.CategoryStruct.id X)","decl":"/-- Taking the comma category of the identity `Discrete PUnit â¥¤ Discrete PUnit`\nand a functor `B â¥¤ Discrete PUnit` results in a category equivalent to `B`. -/\n@[simps!]\ndef toIdPUnitEquiv (L : Discrete PUnit â¥¤ Discrete PUnit) (R : B â¥¤ Discrete PUnit) :\n    Comma L R â‰Œ B :=\n  (equivProd _ R).trans (prod.leftUnitorEquivalence B)\n\n"}
{"name":"CategoryTheory.Comma.toIdPUnitEquiv_inverse_obj_left_as","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"B : Type uâ‚‚\ninstâœ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nL : CategoryTheory.Functor (CategoryTheory.Discrete PUnit.{u_1 + 1}) (CategoryTheory.Discrete PUnit.{u_2 + 1})\nR : CategoryTheory.Functor B (CategoryTheory.Discrete PUnit.{u_2 + 1})\nX : B\nâŠ¢ Eq ((CategoryTheory.Comma.toIdPUnitEquiv L R).inverse.obj X).left.as PUnit.unit","decl":"/-- Taking the comma category of the identity `Discrete PUnit â¥¤ Discrete PUnit`\nand a functor `B â¥¤ Discrete PUnit` results in a category equivalent to `B`. -/\n@[simps!]\ndef toIdPUnitEquiv (L : Discrete PUnit â¥¤ Discrete PUnit) (R : B â¥¤ Discrete PUnit) :\n    Comma L R â‰Œ B :=\n  (equivProd _ R).trans (prod.leftUnitorEquivalence B)\n\n"}
{"name":"CategoryTheory.Comma.toIdPUnitEquiv_functor_obj","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"B : Type uâ‚‚\ninstâœ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nL : CategoryTheory.Functor (CategoryTheory.Discrete PUnit.{u_1 + 1}) (CategoryTheory.Discrete PUnit.{u_2 + 1})\nR : CategoryTheory.Functor B (CategoryTheory.Discrete PUnit.{u_2 + 1})\nX : CategoryTheory.Comma L R\nâŠ¢ Eq ((CategoryTheory.Comma.toIdPUnitEquiv L R).functor.obj X) X.right","decl":"/-- Taking the comma category of the identity `Discrete PUnit â¥¤ Discrete PUnit`\nand a functor `B â¥¤ Discrete PUnit` results in a category equivalent to `B`. -/\n@[simps!]\ndef toIdPUnitEquiv (L : Discrete PUnit â¥¤ Discrete PUnit) (R : B â¥¤ Discrete PUnit) :\n    Comma L R â‰Œ B :=\n  (equivProd _ R).trans (prod.leftUnitorEquivalence B)\n\n"}
{"name":"CategoryTheory.Comma.toIdPUnitEquiv_unitIso_hom_app_left_down_down","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"B : Type uâ‚‚\ninstâœ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nL : CategoryTheory.Functor (CategoryTheory.Discrete PUnit.{u_1 + 1}) (CategoryTheory.Discrete PUnit.{u_2 + 1})\nR : CategoryTheory.Functor B (CategoryTheory.Discrete PUnit.{u_2 + 1})\nX : CategoryTheory.Comma L R\nâŠ¢ Eq â‹¯ â‹¯","decl":"/-- Taking the comma category of the identity `Discrete PUnit â¥¤ Discrete PUnit`\nand a functor `B â¥¤ Discrete PUnit` results in a category equivalent to `B`. -/\n@[simps!]\ndef toIdPUnitEquiv (L : Discrete PUnit â¥¤ Discrete PUnit) (R : B â¥¤ Discrete PUnit) :\n    Comma L R â‰Œ B :=\n  (equivProd _ R).trans (prod.leftUnitorEquivalence B)\n\n"}
{"name":"CategoryTheory.Comma.toIdPUnitEquiv_inverse_map_left_down_down","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"B : Type uâ‚‚\ninstâœ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nL : CategoryTheory.Functor (CategoryTheory.Discrete PUnit.{u_1 + 1}) (CategoryTheory.Discrete PUnit.{u_2 + 1})\nR : CategoryTheory.Functor B (CategoryTheory.Discrete PUnit.{u_2 + 1})\nXâœ Yâœ : B\nf : Quiver.Hom Xâœ Yâœ\nâŠ¢ Eq â‹¯ â‹¯","decl":"/-- Taking the comma category of the identity `Discrete PUnit â¥¤ Discrete PUnit`\nand a functor `B â¥¤ Discrete PUnit` results in a category equivalent to `B`. -/\n@[simps!]\ndef toIdPUnitEquiv (L : Discrete PUnit â¥¤ Discrete PUnit) (R : B â¥¤ Discrete PUnit) :\n    Comma L R â‰Œ B :=\n  (equivProd _ R).trans (prod.leftUnitorEquivalence B)\n\n"}
{"name":"CategoryTheory.Comma.toIdPUnitEquiv_inverse_obj_right","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"B : Type uâ‚‚\ninstâœ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nL : CategoryTheory.Functor (CategoryTheory.Discrete PUnit.{u_1 + 1}) (CategoryTheory.Discrete PUnit.{u_2 + 1})\nR : CategoryTheory.Functor B (CategoryTheory.Discrete PUnit.{u_2 + 1})\nX : B\nâŠ¢ Eq ((CategoryTheory.Comma.toIdPUnitEquiv L R).inverse.obj X).right X","decl":"/-- Taking the comma category of the identity `Discrete PUnit â¥¤ Discrete PUnit`\nand a functor `B â¥¤ Discrete PUnit` results in a category equivalent to `B`. -/\n@[simps!]\ndef toIdPUnitEquiv (L : Discrete PUnit â¥¤ Discrete PUnit) (R : B â¥¤ Discrete PUnit) :\n    Comma L R â‰Œ B :=\n  (equivProd _ R).trans (prod.leftUnitorEquivalence B)\n\n"}
{"name":"CategoryTheory.Comma.toIdPUnitEquiv_unitIso_inv_app_left_down_down","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"B : Type uâ‚‚\ninstâœ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nL : CategoryTheory.Functor (CategoryTheory.Discrete PUnit.{u_1 + 1}) (CategoryTheory.Discrete PUnit.{u_2 + 1})\nR : CategoryTheory.Functor B (CategoryTheory.Discrete PUnit.{u_2 + 1})\nX : CategoryTheory.Comma L R\nâŠ¢ Eq â‹¯ â‹¯","decl":"/-- Taking the comma category of the identity `Discrete PUnit â¥¤ Discrete PUnit`\nand a functor `B â¥¤ Discrete PUnit` results in a category equivalent to `B`. -/\n@[simps!]\ndef toIdPUnitEquiv (L : Discrete PUnit â¥¤ Discrete PUnit) (R : B â¥¤ Discrete PUnit) :\n    Comma L R â‰Œ B :=\n  (equivProd _ R).trans (prod.leftUnitorEquivalence B)\n\n"}
{"name":"CategoryTheory.Comma.toIdPUnitEquiv_inverse_obj_hom_down_down","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"B : Type uâ‚‚\ninstâœ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nL : CategoryTheory.Functor (CategoryTheory.Discrete PUnit.{u_1 + 1}) (CategoryTheory.Discrete PUnit.{u_2 + 1})\nR : CategoryTheory.Functor B (CategoryTheory.Discrete PUnit.{u_2 + 1})\nX : B\nâŠ¢ Eq â‹¯ â‹¯","decl":"/-- Taking the comma category of the identity `Discrete PUnit â¥¤ Discrete PUnit`\nand a functor `B â¥¤ Discrete PUnit` results in a category equivalent to `B`. -/\n@[simps!]\ndef toIdPUnitEquiv (L : Discrete PUnit â¥¤ Discrete PUnit) (R : B â¥¤ Discrete PUnit) :\n    Comma L R â‰Œ B :=\n  (equivProd _ R).trans (prod.leftUnitorEquivalence B)\n\n"}
{"name":"CategoryTheory.Comma.toIdPUnitEquiv_unitIso_hom_app_right","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"B : Type uâ‚‚\ninstâœ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nL : CategoryTheory.Functor (CategoryTheory.Discrete PUnit.{u_1 + 1}) (CategoryTheory.Discrete PUnit.{u_2 + 1})\nR : CategoryTheory.Functor B (CategoryTheory.Discrete PUnit.{u_2 + 1})\nX : CategoryTheory.Comma L R\nâŠ¢ Eq ((CategoryTheory.Comma.toIdPUnitEquiv L R).unitIso.hom.app X).right (CategoryTheory.CategoryStruct.id X.right)","decl":"/-- Taking the comma category of the identity `Discrete PUnit â¥¤ Discrete PUnit`\nand a functor `B â¥¤ Discrete PUnit` results in a category equivalent to `B`. -/\n@[simps!]\ndef toIdPUnitEquiv (L : Discrete PUnit â¥¤ Discrete PUnit) (R : B â¥¤ Discrete PUnit) :\n    Comma L R â‰Œ B :=\n  (equivProd _ R).trans (prod.leftUnitorEquivalence B)\n\n"}
{"name":"CategoryTheory.Comma.toIdPUnitEquiv_counitIso_hom_app","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"B : Type uâ‚‚\ninstâœ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nL : CategoryTheory.Functor (CategoryTheory.Discrete PUnit.{u_1 + 1}) (CategoryTheory.Discrete PUnit.{u_2 + 1})\nR : CategoryTheory.Functor B (CategoryTheory.Discrete PUnit.{u_2 + 1})\nX : B\nâŠ¢ Eq ((CategoryTheory.Comma.toIdPUnitEquiv L R).counitIso.hom.app X) (CategoryTheory.CategoryStruct.id X)","decl":"/-- Taking the comma category of the identity `Discrete PUnit â¥¤ Discrete PUnit`\nand a functor `B â¥¤ Discrete PUnit` results in a category equivalent to `B`. -/\n@[simps!]\ndef toIdPUnitEquiv (L : Discrete PUnit â¥¤ Discrete PUnit) (R : B â¥¤ Discrete PUnit) :\n    Comma L R â‰Œ B :=\n  (equivProd _ R).trans (prod.leftUnitorEquivalence B)\n\n"}
{"name":"CategoryTheory.Comma.toIdPUnitEquiv_unitIso_inv_app_right","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"B : Type uâ‚‚\ninstâœ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nL : CategoryTheory.Functor (CategoryTheory.Discrete PUnit.{u_1 + 1}) (CategoryTheory.Discrete PUnit.{u_2 + 1})\nR : CategoryTheory.Functor B (CategoryTheory.Discrete PUnit.{u_2 + 1})\nX : CategoryTheory.Comma L R\nâŠ¢ Eq ((CategoryTheory.Comma.toIdPUnitEquiv L R).unitIso.inv.app X).right (CategoryTheory.CategoryStruct.id X.right)","decl":"/-- Taking the comma category of the identity `Discrete PUnit â¥¤ Discrete PUnit`\nand a functor `B â¥¤ Discrete PUnit` results in a category equivalent to `B`. -/\n@[simps!]\ndef toIdPUnitEquiv (L : Discrete PUnit â¥¤ Discrete PUnit) (R : B â¥¤ Discrete PUnit) :\n    Comma L R â‰Œ B :=\n  (equivProd _ R).trans (prod.leftUnitorEquivalence B)\n\n"}
{"name":"CategoryTheory.Comma.toIdPUnitEquiv_functor_map","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"B : Type uâ‚‚\ninstâœ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nL : CategoryTheory.Functor (CategoryTheory.Discrete PUnit.{u_1 + 1}) (CategoryTheory.Discrete PUnit.{u_2 + 1})\nR : CategoryTheory.Functor B (CategoryTheory.Discrete PUnit.{u_2 + 1})\nXâœ Yâœ : CategoryTheory.Comma L R\nf : Quiver.Hom Xâœ Yâœ\nâŠ¢ Eq ((CategoryTheory.Comma.toIdPUnitEquiv L R).functor.map f) f.right","decl":"/-- Taking the comma category of the identity `Discrete PUnit â¥¤ Discrete PUnit`\nand a functor `B â¥¤ Discrete PUnit` results in a category equivalent to `B`. -/\n@[simps!]\ndef toIdPUnitEquiv (L : Discrete PUnit â¥¤ Discrete PUnit) (R : B â¥¤ Discrete PUnit) :\n    Comma L R â‰Œ B :=\n  (equivProd _ R).trans (prod.leftUnitorEquivalence B)\n\n"}
{"name":"CategoryTheory.Comma.toIdPUnitEquiv_inverse_map_right","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"B : Type uâ‚‚\ninstâœ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nL : CategoryTheory.Functor (CategoryTheory.Discrete PUnit.{u_1 + 1}) (CategoryTheory.Discrete PUnit.{u_2 + 1})\nR : CategoryTheory.Functor B (CategoryTheory.Discrete PUnit.{u_2 + 1})\nXâœ Yâœ : B\nf : Quiver.Hom Xâœ Yâœ\nâŠ¢ Eq ((CategoryTheory.Comma.toIdPUnitEquiv L R).inverse.map f).right f","decl":"/-- Taking the comma category of the identity `Discrete PUnit â¥¤ Discrete PUnit`\nand a functor `B â¥¤ Discrete PUnit` results in a category equivalent to `B`. -/\n@[simps!]\ndef toIdPUnitEquiv (L : Discrete PUnit â¥¤ Discrete PUnit) (R : B â¥¤ Discrete PUnit) :\n    Comma L R â‰Œ B :=\n  (equivProd _ R).trans (prod.leftUnitorEquivalence B)\n\n"}
{"name":"CategoryTheory.Comma.toIdPUnitEquiv_functor_iso","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"B : Type uâ‚‚\ninstâœ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nL : CategoryTheory.Functor (CategoryTheory.Discrete PUnit.{u_1 + 1}) (CategoryTheory.Discrete PUnit.{u_2 + 1})\nR : CategoryTheory.Functor B (CategoryTheory.Discrete PUnit.{u_2 + 1})\nâŠ¢ Eq (CategoryTheory.Comma.toIdPUnitEquiv L R).functor (CategoryTheory.Comma.snd L R)","decl":"@[simp]\ntheorem toIdPUnitEquiv_functor_iso {L : Discrete PUnit â¥¤ Discrete PUnit}\n    {R : B â¥¤ Discrete PUnit} :\n    (toIdPUnitEquiv L R).functor = snd L R :=\n  rfl\n\n"}
{"name":"CategoryTheory.Comma.opFunctor_obj","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nX : CategoryTheory.Comma L R\nâŠ¢ Eq ((CategoryTheory.Comma.opFunctor L R).obj X) { unop := { left := { unop := X.right }, right := { unop := X.left }, hom := { unop := X.hom } } }","decl":"/-- The canonical functor from `Comma L R` to `(Comma R.op L.op)áµ’áµ–`. -/\n@[simps]\ndef opFunctor : Comma L R â¥¤ (Comma R.op L.op)áµ’áµ– where\n  obj X := âŸ¨op X.right, op X.left, op X.homâŸ©\n  map f := âŸ¨op f.right, op f.left, Quiver.Hom.unop_inj (by simp)âŸ©\n\n"}
{"name":"CategoryTheory.Comma.opFunctor_map","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nXâœ Yâœ : CategoryTheory.Comma L R\nf : Quiver.Hom Xâœ Yâœ\nâŠ¢ Eq ((CategoryTheory.Comma.opFunctor L R).map f) { unop := { left := { unop := f.right }, right := { unop := f.left }, w := â‹¯ } }","decl":"/-- The canonical functor from `Comma L R` to `(Comma R.op L.op)áµ’áµ–`. -/\n@[simps]\ndef opFunctor : Comma L R â¥¤ (Comma R.op L.op)áµ’áµ– where\n  obj X := âŸ¨op X.right, op X.left, op X.homâŸ©\n  map f := âŸ¨op f.right, op f.left, Quiver.Hom.unop_inj (by simp)âŸ©\n\n"}
{"name":"CategoryTheory.Comma.opFunctorCompFst_hom_app","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nX : Opposite (CategoryTheory.Comma L R)\nâŠ¢ Eq ((CategoryTheory.Comma.opFunctorCompFst L R).hom.app X) (CategoryTheory.CategoryStruct.id { unop := (Opposite.unop X).right })","decl":"/-- Composing the `leftOp` of `opFunctor L R` with `fst L.op R.op` is naturally isomorphic\nto `snd L R`.-/\n@[simps!]\ndef opFunctorCompFst : (opFunctor L R).leftOp â‹™ fst _ _ â‰… (snd _ _).op :=\n  Iso.refl _\n\n"}
{"name":"CategoryTheory.Comma.opFunctorCompFst_inv_app","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nX : Opposite (CategoryTheory.Comma L R)\nâŠ¢ Eq ((CategoryTheory.Comma.opFunctorCompFst L R).inv.app X) (CategoryTheory.CategoryStruct.id { unop := (Opposite.unop X).right })","decl":"/-- Composing the `leftOp` of `opFunctor L R` with `fst L.op R.op` is naturally isomorphic\nto `snd L R`.-/\n@[simps!]\ndef opFunctorCompFst : (opFunctor L R).leftOp â‹™ fst _ _ â‰… (snd _ _).op :=\n  Iso.refl _\n\n"}
{"name":"CategoryTheory.Comma.opFunctorCompSnd_inv_app","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nX : Opposite (CategoryTheory.Comma L R)\nâŠ¢ Eq ((CategoryTheory.Comma.opFunctorCompSnd L R).inv.app X) (CategoryTheory.CategoryStruct.id { unop := (Opposite.unop X).left })","decl":"/-- Composing the `leftOp` of `opFunctor L R` with `snd L.op R.op` is naturally isomorphic\nto `fst L R`.-/\n@[simps!]\ndef opFunctorCompSnd : (opFunctor L R).leftOp â‹™ snd _ _ â‰… (fst _ _).op :=\n  Iso.refl _\n\n"}
{"name":"CategoryTheory.Comma.opFunctorCompSnd_hom_app","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nX : Opposite (CategoryTheory.Comma L R)\nâŠ¢ Eq ((CategoryTheory.Comma.opFunctorCompSnd L R).hom.app X) (CategoryTheory.CategoryStruct.id { unop := (Opposite.unop X).left })","decl":"/-- Composing the `leftOp` of `opFunctor L R` with `snd L.op R.op` is naturally isomorphic\nto `fst L R`.-/\n@[simps!]\ndef opFunctorCompSnd : (opFunctor L R).leftOp â‹™ snd _ _ â‰… (fst _ _).op :=\n  Iso.refl _\n\n"}
{"name":"CategoryTheory.Comma.unopFunctor_map","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nXâœ Yâœ : CategoryTheory.Comma L.op R.op\nf : Quiver.Hom Xâœ Yâœ\nâŠ¢ Eq ((CategoryTheory.Comma.unopFunctor L R).map f) { unop := { left := f.right.unop, right := f.left.unop, w := â‹¯ } }","decl":"/-- The canonical functor from `Comma L.op R.op` to `(Comma R L)áµ’áµ–`. -/\n@[simps]\ndef unopFunctor : Comma L.op R.op â¥¤ (Comma R L)áµ’áµ– where\n  obj X := âŸ¨X.right.unop, X.left.unop, X.hom.unopâŸ©\n  map f := âŸ¨f.right.unop, f.left.unop, Quiver.Hom.op_inj (by simpa using f.w.symm)âŸ©\n\n"}
{"name":"CategoryTheory.Comma.unopFunctor_obj","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nX : CategoryTheory.Comma L.op R.op\nâŠ¢ Eq ((CategoryTheory.Comma.unopFunctor L R).obj X) { unop := { left := Opposite.unop X.right, right := Opposite.unop X.left, hom := X.hom.unop } }","decl":"/-- The canonical functor from `Comma L.op R.op` to `(Comma R L)áµ’áµ–`. -/\n@[simps]\ndef unopFunctor : Comma L.op R.op â¥¤ (Comma R L)áµ’áµ– where\n  obj X := âŸ¨X.right.unop, X.left.unop, X.hom.unopâŸ©\n  map f := âŸ¨f.right.unop, f.left.unop, Quiver.Hom.op_inj (by simpa using f.w.symm)âŸ©\n\n"}
{"name":"CategoryTheory.Comma.unopFunctorCompFst_inv_app","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nX : CategoryTheory.Comma L.op R.op\nâŠ¢ Eq ((CategoryTheory.Comma.unopFunctorCompFst L R).inv.app X) (CategoryTheory.CategoryStruct.id X.right)","decl":"/-- Composing `unopFunctor L R` with `(fst L R).op` is isomorphic to `snd L.op R.op`. -/\n@[simps!]\ndef unopFunctorCompFst : unopFunctor L R â‹™ (fst _ _).op â‰… snd _ _ :=\n  Iso.refl _\n\n"}
{"name":"CategoryTheory.Comma.unopFunctorCompFst_hom_app","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nX : CategoryTheory.Comma L.op R.op\nâŠ¢ Eq ((CategoryTheory.Comma.unopFunctorCompFst L R).hom.app X) (CategoryTheory.CategoryStruct.id X.right)","decl":"/-- Composing `unopFunctor L R` with `(fst L R).op` is isomorphic to `snd L.op R.op`. -/\n@[simps!]\ndef unopFunctorCompFst : unopFunctor L R â‹™ (fst _ _).op â‰… snd _ _ :=\n  Iso.refl _\n\n"}
{"name":"CategoryTheory.Comma.unopFunctorCompSnd_hom_app","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nX : CategoryTheory.Comma L.op R.op\nâŠ¢ Eq ((CategoryTheory.Comma.unopFunctorCompSnd L R).hom.app X) (CategoryTheory.CategoryStruct.id X.left)","decl":"/-- Composing `unopFunctor L R` with `(snd L R).op` is isomorphic to `fst L.op R.op`. -/\n@[simps!]\ndef unopFunctorCompSnd : unopFunctor L R â‹™ (snd _ _).op â‰… fst _ _ :=\n  Iso.refl _\n\n"}
{"name":"CategoryTheory.Comma.unopFunctorCompSnd_inv_app","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nX : CategoryTheory.Comma L.op R.op\nâŠ¢ Eq ((CategoryTheory.Comma.unopFunctorCompSnd L R).inv.app X) (CategoryTheory.CategoryStruct.id X.left)","decl":"/-- Composing `unopFunctor L R` with `(snd L R).op` is isomorphic to `fst L.op R.op`. -/\n@[simps!]\ndef unopFunctorCompSnd : unopFunctor L R â‹™ (snd _ _).op â‰… fst _ _ :=\n  Iso.refl _\n\n"}
{"name":"CategoryTheory.Comma.opEquiv_unitIso","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nâŠ¢ Eq (CategoryTheory.Comma.opEquiv L R).unitIso (CategoryTheory.NatIso.ofComponents (fun X => CategoryTheory.Iso.refl ((CategoryTheory.Functor.id (CategoryTheory.Comma L R)).obj X)) â‹¯)","decl":"/-- The canonical equivalence between `Comma L R` and `(Comma R.op L.op)áµ’áµ–`. -/\n@[simps]\ndef opEquiv : Comma L R â‰Œ (Comma R.op L.op)áµ’áµ– where\n  functor := opFunctor L R\n  inverse := (unopFunctor R L).leftOp\n  unitIso := NatIso.ofComponents (fun X => Iso.refl _)\n  counitIso := NatIso.ofComponents (fun X => Iso.refl _)\n\n"}
{"name":"CategoryTheory.Comma.opEquiv_functor","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nâŠ¢ Eq (CategoryTheory.Comma.opEquiv L R).functor (CategoryTheory.Comma.opFunctor L R)","decl":"/-- The canonical equivalence between `Comma L R` and `(Comma R.op L.op)áµ’áµ–`. -/\n@[simps]\ndef opEquiv : Comma L R â‰Œ (Comma R.op L.op)áµ’áµ– where\n  functor := opFunctor L R\n  inverse := (unopFunctor R L).leftOp\n  unitIso := NatIso.ofComponents (fun X => Iso.refl _)\n  counitIso := NatIso.ofComponents (fun X => Iso.refl _)\n\n"}
{"name":"CategoryTheory.Comma.opEquiv_inverse","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nâŠ¢ Eq (CategoryTheory.Comma.opEquiv L R).inverse (CategoryTheory.Comma.unopFunctor R L).leftOp","decl":"/-- The canonical equivalence between `Comma L R` and `(Comma R.op L.op)áµ’áµ–`. -/\n@[simps]\ndef opEquiv : Comma L R â‰Œ (Comma R.op L.op)áµ’áµ– where\n  functor := opFunctor L R\n  inverse := (unopFunctor R L).leftOp\n  unitIso := NatIso.ofComponents (fun X => Iso.refl _)\n  counitIso := NatIso.ofComponents (fun X => Iso.refl _)\n\n"}
{"name":"CategoryTheory.Comma.opEquiv_counitIso","module":"Mathlib.CategoryTheory.Comma.Basic","initialProofState":"A : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nâŠ¢ Eq (CategoryTheory.Comma.opEquiv L R).counitIso (CategoryTheory.NatIso.ofComponents (fun X => CategoryTheory.Iso.refl (((CategoryTheory.Comma.unopFunctor R L).leftOp.comp (CategoryTheory.Comma.opFunctor L R)).obj X)) â‹¯)","decl":"/-- The canonical equivalence between `Comma L R` and `(Comma R.op L.op)áµ’áµ–`. -/\n@[simps]\ndef opEquiv : Comma L R â‰Œ (Comma R.op L.op)áµ’áµ– where\n  functor := opFunctor L R\n  inverse := (unopFunctor R L).leftOp\n  unitIso := NatIso.ofComponents (fun X => Iso.refl _)\n  counitIso := NatIso.ofComponents (fun X => Iso.refl _)\n\n"}
