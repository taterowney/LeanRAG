{"name":"MeasureTheory.HasPDF.haveLebesgueDecomposition'","module":"Mathlib.Probability.Density","initialProofState":"Ω : Type u_1\nE : Type u_2\ninst✝ : MeasurableSpace E\nm : MeasurableSpace Ω\nX : Ω → E\nℙ : MeasureTheory.Measure Ω\nμ : autoParam (MeasureTheory.Measure E) _auto✝\nself : MeasureTheory.HasPDF X ℙ μ\n⊢ (MeasureTheory.Measure.map X ℙ).HaveLebesgueDecomposition μ","decl":"/-- A random variable `X : Ω → E` is said to have a probability density function (`HasPDF`)\nwith respect to the measure `ℙ` on `Ω` and `μ` on `E`\nif the push-forward measure of `ℙ` along `X` is absolutely continuous with respect to `μ`\nand they have a Lebesgue decomposition (`HaveLebesgueDecomposition`). -/\nclass HasPDF {m : MeasurableSpace Ω} (X : Ω → E) (ℙ : Measure Ω) (μ : Measure E := by volume_tac) :\n    Prop where\n  protected aemeasurable' : AEMeasurable X ℙ\n  protected haveLebesgueDecomposition' : (map X ℙ).HaveLebesgueDecomposition μ\n  protected absolutelyContinuous' : map X ℙ ≪ μ\n\n"}
{"name":"MeasureTheory.HasPDF.aemeasurable'","module":"Mathlib.Probability.Density","initialProofState":"Ω : Type u_1\nE : Type u_2\ninst✝ : MeasurableSpace E\nm : MeasurableSpace Ω\nX : Ω → E\nℙ : MeasureTheory.Measure Ω\nμ : autoParam (MeasureTheory.Measure E) _auto✝\nself : MeasureTheory.HasPDF X ℙ μ\n⊢ AEMeasurable X ℙ","decl":"/-- A random variable `X : Ω → E` is said to have a probability density function (`HasPDF`)\nwith respect to the measure `ℙ` on `Ω` and `μ` on `E`\nif the push-forward measure of `ℙ` along `X` is absolutely continuous with respect to `μ`\nand they have a Lebesgue decomposition (`HaveLebesgueDecomposition`). -/\nclass HasPDF {m : MeasurableSpace Ω} (X : Ω → E) (ℙ : Measure Ω) (μ : Measure E := by volume_tac) :\n    Prop where\n  protected aemeasurable' : AEMeasurable X ℙ\n  protected haveLebesgueDecomposition' : (map X ℙ).HaveLebesgueDecomposition μ\n  protected absolutelyContinuous' : map X ℙ ≪ μ\n\n"}
{"name":"MeasureTheory.HasPDF.absolutelyContinuous'","module":"Mathlib.Probability.Density","initialProofState":"Ω : Type u_1\nE : Type u_2\ninst✝ : MeasurableSpace E\nm : MeasurableSpace Ω\nX : Ω → E\nℙ : MeasureTheory.Measure Ω\nμ : autoParam (MeasureTheory.Measure E) _auto✝\nself : MeasureTheory.HasPDF X ℙ μ\n⊢ (MeasureTheory.Measure.map X ℙ).AbsolutelyContinuous μ","decl":"/-- A random variable `X : Ω → E` is said to have a probability density function (`HasPDF`)\nwith respect to the measure `ℙ` on `Ω` and `μ` on `E`\nif the push-forward measure of `ℙ` along `X` is absolutely continuous with respect to `μ`\nand they have a Lebesgue decomposition (`HaveLebesgueDecomposition`). -/\nclass HasPDF {m : MeasurableSpace Ω} (X : Ω → E) (ℙ : Measure Ω) (μ : Measure E := by volume_tac) :\n    Prop where\n  protected aemeasurable' : AEMeasurable X ℙ\n  protected haveLebesgueDecomposition' : (map X ℙ).HaveLebesgueDecomposition μ\n  protected absolutelyContinuous' : map X ℙ ≪ μ\n\n"}
{"name":"MeasureTheory.hasPDF_iff","module":"Mathlib.Probability.Density","initialProofState":"Ω : Type u_1\nE : Type u_2\ninst✝ : MeasurableSpace E\nx✝ : MeasurableSpace Ω\nX : Ω → E\nℙ : MeasureTheory.Measure Ω\nμ : MeasureTheory.Measure E\n⊢ Iff (MeasureTheory.HasPDF X ℙ μ) (And (AEMeasurable X ℙ) (And ((MeasureTheory.Measure.map X ℙ).HaveLebesgueDecomposition μ) ((MeasureTheory.Measure.map X ℙ).AbsolutelyContinuous μ)))","decl":"theorem hasPDF_iff :\n    HasPDF X ℙ μ ↔ AEMeasurable X ℙ ∧ (map X ℙ).HaveLebesgueDecomposition μ ∧ map X ℙ ≪ μ :=\n  ⟨fun ⟨h₁, h₂, h₃⟩ ↦ ⟨h₁, h₂, h₃⟩, fun ⟨h₁, h₂, h₃⟩ ↦ ⟨h₁, h₂, h₃⟩⟩\n\n"}
{"name":"MeasureTheory.hasPDF_iff_of_aemeasurable","module":"Mathlib.Probability.Density","initialProofState":"Ω : Type u_1\nE : Type u_2\ninst✝ : MeasurableSpace E\nx✝ : MeasurableSpace Ω\nX : Ω → E\nℙ : MeasureTheory.Measure Ω\nμ : MeasureTheory.Measure E\nhX : AEMeasurable X ℙ\n⊢ Iff (MeasureTheory.HasPDF X ℙ μ) (And ((MeasureTheory.Measure.map X ℙ).HaveLebesgueDecomposition μ) ((MeasureTheory.Measure.map X ℙ).AbsolutelyContinuous μ))","decl":"theorem hasPDF_iff_of_aemeasurable (hX : AEMeasurable X ℙ) :\n    HasPDF X ℙ μ ↔ (map X ℙ).HaveLebesgueDecomposition μ ∧ map X ℙ ≪ μ := by\n  rw [hasPDF_iff]\n  simp only [hX, true_and]\n\n"}
{"name":"MeasureTheory.HasPDF.aemeasurable","module":"Mathlib.Probability.Density","initialProofState":"Ω : Type u_1\nE : Type u_2\ninst✝¹ : MeasurableSpace E\nx✝ : MeasurableSpace Ω\nX : Ω → E\nℙ : MeasureTheory.Measure Ω\nμ : MeasureTheory.Measure E\ninst✝ : MeasureTheory.HasPDF X ℙ μ\n⊢ AEMeasurable X ℙ","decl":"variable (X ℙ μ) in\n@[measurability]\ntheorem HasPDF.aemeasurable [HasPDF X ℙ μ] : AEMeasurable X ℙ := HasPDF.aemeasurable' μ\n\n"}
{"name":"MeasureTheory.HasPDF.haveLebesgueDecomposition","module":"Mathlib.Probability.Density","initialProofState":"Ω : Type u_1\nE : Type u_2\ninst✝¹ : MeasurableSpace E\nx✝ : MeasurableSpace Ω\nX : Ω → E\nℙ : MeasureTheory.Measure Ω\nμ : MeasureTheory.Measure E\ninst✝ : MeasureTheory.HasPDF X ℙ μ\n⊢ (MeasureTheory.Measure.map X ℙ).HaveLebesgueDecomposition μ","decl":"instance HasPDF.haveLebesgueDecomposition [HasPDF X ℙ μ] : (map X ℙ).HaveLebesgueDecomposition μ :=\n  HasPDF.haveLebesgueDecomposition'\n\n"}
{"name":"MeasureTheory.HasPDF.absolutelyContinuous","module":"Mathlib.Probability.Density","initialProofState":"Ω : Type u_1\nE : Type u_2\ninst✝¹ : MeasurableSpace E\nx✝ : MeasurableSpace Ω\nX : Ω → E\nℙ : MeasureTheory.Measure Ω\nμ : MeasureTheory.Measure E\ninst✝ : MeasureTheory.HasPDF X ℙ μ\n⊢ (MeasureTheory.Measure.map X ℙ).AbsolutelyContinuous μ","decl":"theorem HasPDF.absolutelyContinuous [HasPDF X ℙ μ] : map X ℙ ≪ μ := HasPDF.absolutelyContinuous'\n\n"}
{"name":"MeasureTheory.HasPDF.quasiMeasurePreserving_of_measurable","module":"Mathlib.Probability.Density","initialProofState":"Ω : Type u_1\nE : Type u_2\ninst✝¹ : MeasurableSpace E\nx✝ : MeasurableSpace Ω\nX : Ω → E\nℙ : MeasureTheory.Measure Ω\nμ : MeasureTheory.Measure E\ninst✝ : MeasureTheory.HasPDF X ℙ μ\nh : Measurable X\n⊢ MeasureTheory.Measure.QuasiMeasurePreserving X ℙ μ","decl":"/-- A random variable that `HasPDF` is quasi-measure preserving. -/\ntheorem HasPDF.quasiMeasurePreserving_of_measurable (X : Ω → E) (ℙ : Measure Ω) (μ : Measure E)\n    [HasPDF X ℙ μ] (h : Measurable X) : QuasiMeasurePreserving X ℙ μ :=\n  { measurable := h\n    absolutelyContinuous := HasPDF.absolutelyContinuous .. }\n\n"}
{"name":"MeasureTheory.HasPDF.congr","module":"Mathlib.Probability.Density","initialProofState":"Ω : Type u_1\nE : Type u_2\ninst✝ : MeasurableSpace E\nx✝ : MeasurableSpace Ω\nX Y : Ω → E\nℙ : MeasureTheory.Measure Ω\nμ : MeasureTheory.Measure E\nhXY : (MeasureTheory.ae ℙ).EventuallyEq X Y\nhX : MeasureTheory.HasPDF X ℙ μ\n⊢ MeasureTheory.HasPDF Y ℙ μ","decl":"theorem HasPDF.congr (hXY : X =ᵐ[ℙ] Y) [hX : HasPDF X ℙ μ] : HasPDF Y ℙ μ :=\n  ⟨(HasPDF.aemeasurable X ℙ μ).congr hXY, ℙ.map_congr hXY ▸ hX.haveLebesgueDecomposition,\n    ℙ.map_congr hXY ▸ hX.absolutelyContinuous⟩\n\n"}
{"name":"MeasureTheory.HasPDF.congr_iff","module":"Mathlib.Probability.Density","initialProofState":"Ω : Type u_1\nE : Type u_2\ninst✝ : MeasurableSpace E\nx✝ : MeasurableSpace Ω\nX Y : Ω → E\nℙ : MeasureTheory.Measure Ω\nμ : MeasureTheory.Measure E\nhXY : (MeasureTheory.ae ℙ).EventuallyEq X Y\n⊢ Iff (MeasureTheory.HasPDF X ℙ μ) (MeasureTheory.HasPDF Y ℙ μ)","decl":"theorem HasPDF.congr_iff (hXY : X =ᵐ[ℙ] Y) : HasPDF X ℙ μ ↔ HasPDF Y ℙ μ :=\n  ⟨fun _ ↦ HasPDF.congr hXY, fun _ ↦ HasPDF.congr hXY.symm⟩\n\n"}
{"name":"MeasureTheory.HasPDF.congr'","module":"Mathlib.Probability.Density","initialProofState":"Ω : Type u_1\nE : Type u_2\ninst✝ : MeasurableSpace E\nx✝ : MeasurableSpace Ω\nX Y : Ω → E\nℙ : MeasureTheory.Measure Ω\nμ : MeasureTheory.Measure E\nhXY : (MeasureTheory.ae ℙ).EventuallyEq X Y\n⊢ Iff (MeasureTheory.HasPDF X ℙ μ) (MeasureTheory.HasPDF Y ℙ μ)","decl":"@[deprecated (since := \"2024-10-28\")] alias HasPDF.congr' := HasPDF.congr_iff\n\n"}
{"name":"MeasureTheory.hasPDF_of_map_eq_withDensity","module":"Mathlib.Probability.Density","initialProofState":"Ω : Type u_1\nE : Type u_2\ninst✝ : MeasurableSpace E\nx✝ : MeasurableSpace Ω\nX : Ω → E\nℙ : MeasureTheory.Measure Ω\nμ : MeasureTheory.Measure E\nhX : AEMeasurable X ℙ\nf : E → ENNReal\nhf : AEMeasurable f μ\nh : Eq (MeasureTheory.Measure.map X ℙ) (μ.withDensity f)\n⊢ MeasureTheory.HasPDF X ℙ μ","decl":"/-- X `HasPDF` if there is a pdf `f` such that `map X ℙ = μ.withDensity f`. -/\ntheorem hasPDF_of_map_eq_withDensity (hX : AEMeasurable X ℙ) (f : E → ℝ≥0∞) (hf : AEMeasurable f μ)\n    (h : map X ℙ = μ.withDensity f) : HasPDF X ℙ μ := by\n  refine ⟨hX, ?_, ?_⟩ <;> rw [h]\n  · rw [withDensity_congr_ae hf.ae_eq_mk]\n    exact haveLebesgueDecomposition_withDensity μ hf.measurable_mk\n  · exact withDensity_absolutelyContinuous μ f\n\n"}
{"name":"MeasureTheory.pdf_def","module":"Mathlib.Probability.Density","initialProofState":"Ω : Type u_1\nE : Type u_2\ninst✝ : MeasurableSpace E\nx✝ : MeasurableSpace Ω\nℙ : MeasureTheory.Measure Ω\nμ : MeasureTheory.Measure E\nX : Ω → E\n⊢ Eq (MeasureTheory.pdf X ℙ μ) ((MeasureTheory.Measure.map X ℙ).rnDeriv μ)","decl":"theorem pdf_def {_ : MeasurableSpace Ω} {ℙ : Measure Ω} {μ : Measure E} {X : Ω → E} :\n    pdf X ℙ μ = (map X ℙ).rnDeriv μ := rfl\n\n"}
{"name":"MeasureTheory.pdf_of_not_aemeasurable","module":"Mathlib.Probability.Density","initialProofState":"Ω : Type u_1\nE : Type u_2\ninst✝ : MeasurableSpace E\nx✝ : MeasurableSpace Ω\nℙ : MeasureTheory.Measure Ω\nμ : MeasureTheory.Measure E\nX : Ω → E\nhX : Not (AEMeasurable X ℙ)\n⊢ (MeasureTheory.ae μ).EventuallyEq (MeasureTheory.pdf X ℙ μ) 0","decl":"theorem pdf_of_not_aemeasurable {_ : MeasurableSpace Ω} {ℙ : Measure Ω} {μ : Measure E}\n    {X : Ω → E} (hX : ¬AEMeasurable X ℙ) : pdf X ℙ μ =ᵐ[μ] 0 := by\n  rw [pdf_def, map_of_not_aemeasurable hX]\n  exact rnDeriv_zero μ\n\n"}
{"name":"MeasureTheory.pdf_of_not_haveLebesgueDecomposition","module":"Mathlib.Probability.Density","initialProofState":"Ω : Type u_1\nE : Type u_2\ninst✝ : MeasurableSpace E\nx✝ : MeasurableSpace Ω\nℙ : MeasureTheory.Measure Ω\nμ : MeasureTheory.Measure E\nX : Ω → E\nh : Not ((MeasureTheory.Measure.map X ℙ).HaveLebesgueDecomposition μ)\n⊢ Eq (MeasureTheory.pdf X ℙ μ) 0","decl":"theorem pdf_of_not_haveLebesgueDecomposition {_ : MeasurableSpace Ω} {ℙ : Measure Ω}\n    {μ : Measure E} {X : Ω → E} (h : ¬(map X ℙ).HaveLebesgueDecomposition μ) : pdf X ℙ μ = 0 :=\n  rnDeriv_of_not_haveLebesgueDecomposition h\n\n"}
{"name":"MeasureTheory.aemeasurable_of_pdf_ne_zero","module":"Mathlib.Probability.Density","initialProofState":"Ω : Type u_1\nE : Type u_2\ninst✝ : MeasurableSpace E\nm : MeasurableSpace Ω\nℙ : MeasureTheory.Measure Ω\nμ : MeasureTheory.Measure E\nX : Ω → E\nh : Not ((MeasureTheory.ae μ).EventuallyEq (MeasureTheory.pdf X ℙ μ) 0)\n⊢ AEMeasurable X ℙ","decl":"theorem aemeasurable_of_pdf_ne_zero {m : MeasurableSpace Ω} {ℙ : Measure Ω} {μ : Measure E}\n    (X : Ω → E) (h : ¬pdf X ℙ μ =ᵐ[μ] 0) : AEMeasurable X ℙ := by\n  contrapose! h\n  exact pdf_of_not_aemeasurable h\n\n"}
{"name":"MeasureTheory.hasPDF_of_pdf_ne_zero","module":"Mathlib.Probability.Density","initialProofState":"Ω : Type u_1\nE : Type u_2\ninst✝ : MeasurableSpace E\nm : MeasurableSpace Ω\nℙ : MeasureTheory.Measure Ω\nμ : MeasureTheory.Measure E\nX : Ω → E\nhac : (MeasureTheory.Measure.map X ℙ).AbsolutelyContinuous μ\nhpdf : Not ((MeasureTheory.ae μ).EventuallyEq (MeasureTheory.pdf X ℙ μ) 0)\n⊢ MeasureTheory.HasPDF X ℙ μ","decl":"theorem hasPDF_of_pdf_ne_zero {m : MeasurableSpace Ω} {ℙ : Measure Ω} {μ : Measure E} {X : Ω → E}\n    (hac : map X ℙ ≪ μ) (hpdf : ¬pdf X ℙ μ =ᵐ[μ] 0) : HasPDF X ℙ μ := by\n  refine ⟨?_, ?_, hac⟩\n  · exact aemeasurable_of_pdf_ne_zero X hpdf\n  · contrapose! hpdf\n    have := pdf_of_not_haveLebesgueDecomposition hpdf\n    filter_upwards using congrFun this\n\n"}
{"name":"MeasureTheory.measurable_pdf","module":"Mathlib.Probability.Density","initialProofState":"Ω : Type u_1\nE : Type u_2\ninst✝ : MeasurableSpace E\nm : MeasurableSpace Ω\nX : Ω → E\nℙ : MeasureTheory.Measure Ω\nμ : autoParam (MeasureTheory.Measure E) _auto✝\n⊢ Measurable (MeasureTheory.pdf X ℙ μ)","decl":"@[measurability]\ntheorem measurable_pdf {m : MeasurableSpace Ω} (X : Ω → E) (ℙ : Measure Ω)\n    (μ : Measure E := by volume_tac) : Measurable (pdf X ℙ μ) := by\n  exact measurable_rnDeriv _ _\n\n"}
{"name":"MeasureTheory.withDensity_pdf_le_map","module":"Mathlib.Probability.Density","initialProofState":"Ω : Type u_1\nE : Type u_2\ninst✝ : MeasurableSpace E\nx✝ : MeasurableSpace Ω\nX : Ω → E\nℙ : MeasureTheory.Measure Ω\nμ : autoParam (MeasureTheory.Measure E) _auto✝\n⊢ LE.le (MeasureTheory.Measure.withDensity μ (MeasureTheory.pdf X ℙ μ)) (MeasureTheory.Measure.map X ℙ)","decl":"theorem withDensity_pdf_le_map {_ : MeasurableSpace Ω} (X : Ω → E) (ℙ : Measure Ω)\n    (μ : Measure E := by volume_tac) : μ.withDensity (pdf X ℙ μ) ≤ map X ℙ :=\n  withDensity_rnDeriv_le _ _\n\n"}
{"name":"MeasureTheory.setLIntegral_pdf_le_map","module":"Mathlib.Probability.Density","initialProofState":"Ω : Type u_1\nE : Type u_2\ninst✝ : MeasurableSpace E\nm : MeasurableSpace Ω\nX : Ω → E\nℙ : MeasureTheory.Measure Ω\nμ : autoParam (MeasureTheory.Measure E) _auto✝\ns : Set E\n⊢ LE.le (MeasureTheory.lintegral (MeasureTheory.Measure.restrict μ s) fun x => MeasureTheory.pdf X ℙ μ x) ((MeasureTheory.Measure.map X ℙ) s)","decl":"theorem setLIntegral_pdf_le_map {m : MeasurableSpace Ω} (X : Ω → E) (ℙ : Measure Ω)\n    (μ : Measure E := by volume_tac) (s : Set E) :\n    ∫⁻ x in s, pdf X ℙ μ x ∂μ ≤ map X ℙ s := by\n  apply (withDensity_apply_le _ s).trans\n  exact withDensity_pdf_le_map _ _ _ s\n\n"}
{"name":"MeasureTheory.map_eq_withDensity_pdf","module":"Mathlib.Probability.Density","initialProofState":"Ω : Type u_1\nE : Type u_2\ninst✝ : MeasurableSpace E\nm : MeasurableSpace Ω\nX : Ω → E\nℙ : MeasureTheory.Measure Ω\nμ : autoParam (MeasureTheory.Measure E) _auto✝\nhX : MeasureTheory.HasPDF X ℙ μ\n⊢ Eq (MeasureTheory.Measure.map X ℙ) (MeasureTheory.Measure.withDensity μ (MeasureTheory.pdf X ℙ μ))","decl":"theorem map_eq_withDensity_pdf {m : MeasurableSpace Ω} (X : Ω → E) (ℙ : Measure Ω)\n    (μ : Measure E := by volume_tac) [hX : HasPDF X ℙ μ] :\n    map X ℙ = μ.withDensity (pdf X ℙ μ) := by\n  rw [pdf_def, withDensity_rnDeriv_eq _ _ hX.absolutelyContinuous]\n\n"}
{"name":"MeasureTheory.map_eq_setLIntegral_pdf","module":"Mathlib.Probability.Density","initialProofState":"Ω : Type u_1\nE : Type u_2\ninst✝ : MeasurableSpace E\nm : MeasurableSpace Ω\nX : Ω → E\nℙ : MeasureTheory.Measure Ω\nμ : autoParam (MeasureTheory.Measure E) _auto✝\nhX : MeasureTheory.HasPDF X ℙ μ\ns : Set E\nhs : MeasurableSet s\n⊢ Eq ((MeasureTheory.Measure.map X ℙ) s) (MeasureTheory.lintegral (MeasureTheory.Measure.restrict μ s) fun x => MeasureTheory.pdf X ℙ μ x)","decl":"theorem map_eq_setLIntegral_pdf {m : MeasurableSpace Ω} (X : Ω → E) (ℙ : Measure Ω)\n    (μ : Measure E := by volume_tac) [hX : HasPDF X ℙ μ] {s : Set E}\n    (hs : MeasurableSet s) : map X ℙ s = ∫⁻ x in s, pdf X ℙ μ x ∂μ := by\n  rw [← withDensity_apply _ hs, map_eq_withDensity_pdf X ℙ μ]\n\n"}
{"name":"MeasureTheory.pdf.congr","module":"Mathlib.Probability.Density","initialProofState":"Ω : Type u_1\nE : Type u_2\ninst✝ : MeasurableSpace E\nm : MeasurableSpace Ω\nℙ : MeasureTheory.Measure Ω\nμ : MeasureTheory.Measure E\nX Y : Ω → E\nhXY : (MeasureTheory.ae ℙ).EventuallyEq X Y\n⊢ Eq (MeasureTheory.pdf X ℙ μ) (MeasureTheory.pdf Y ℙ μ)","decl":"protected theorem congr {X Y : Ω → E} (hXY : X =ᵐ[ℙ] Y) : pdf X ℙ μ = pdf Y ℙ μ := by\n  rw [pdf_def, pdf_def, map_congr hXY]\n\n"}
{"name":"MeasureTheory.pdf.lintegral_eq_measure_univ","module":"Mathlib.Probability.Density","initialProofState":"Ω : Type u_1\nE : Type u_2\ninst✝¹ : MeasurableSpace E\nm : MeasurableSpace Ω\nℙ : MeasureTheory.Measure Ω\nμ : MeasureTheory.Measure E\nX : Ω → E\ninst✝ : MeasureTheory.HasPDF X ℙ μ\n⊢ Eq (MeasureTheory.lintegral μ fun x => MeasureTheory.pdf X ℙ μ x) (ℙ Set.univ)","decl":"theorem lintegral_eq_measure_univ {X : Ω → E} [HasPDF X ℙ μ] :\n    ∫⁻ x, pdf X ℙ μ x ∂μ = ℙ Set.univ := by\n  rw [← setLIntegral_univ, ← map_eq_setLIntegral_pdf X ℙ μ MeasurableSet.univ,\n    map_apply_of_aemeasurable (HasPDF.aemeasurable X ℙ μ) MeasurableSet.univ, Set.preimage_univ]\n\n"}
{"name":"MeasureTheory.pdf.eq_of_map_eq_withDensity","module":"Mathlib.Probability.Density","initialProofState":"Ω : Type u_1\nE : Type u_2\ninst✝² : MeasurableSpace E\nm : MeasurableSpace Ω\nℙ : MeasureTheory.Measure Ω\nμ : MeasureTheory.Measure E\ninst✝¹ : MeasureTheory.IsFiniteMeasure ℙ\nX : Ω → E\ninst✝ : MeasureTheory.HasPDF X ℙ μ\nf : E → ENNReal\nhmf : AEMeasurable f μ\n⊢ Iff (Eq (MeasureTheory.Measure.map X ℙ) (μ.withDensity f)) ((MeasureTheory.ae μ).EventuallyEq (MeasureTheory.pdf X ℙ μ) f)","decl":"theorem eq_of_map_eq_withDensity [IsFiniteMeasure ℙ] {X : Ω → E} [HasPDF X ℙ μ] (f : E → ℝ≥0∞)\n    (hmf : AEMeasurable f μ) : map X ℙ = μ.withDensity f ↔ pdf X ℙ μ =ᵐ[μ] f := by\n  rw [map_eq_withDensity_pdf X ℙ μ]\n  apply withDensity_eq_iff (measurable_pdf X ℙ μ).aemeasurable hmf\n  rw [lintegral_eq_measure_univ]\n  exact measure_ne_top _ _\n\n"}
{"name":"MeasureTheory.pdf.eq_of_map_eq_withDensity'","module":"Mathlib.Probability.Density","initialProofState":"Ω : Type u_1\nE : Type u_2\ninst✝² : MeasurableSpace E\nm : MeasurableSpace Ω\nℙ : MeasureTheory.Measure Ω\nμ : MeasureTheory.Measure E\ninst✝¹ : MeasureTheory.SigmaFinite μ\nX : Ω → E\ninst✝ : MeasureTheory.HasPDF X ℙ μ\nf : E → ENNReal\nhmf : AEMeasurable f μ\n⊢ Iff (Eq (MeasureTheory.Measure.map X ℙ) (μ.withDensity f)) ((MeasureTheory.ae μ).EventuallyEq (MeasureTheory.pdf X ℙ μ) f)","decl":"theorem eq_of_map_eq_withDensity' [SigmaFinite μ] {X : Ω → E} [HasPDF X ℙ μ] (f : E → ℝ≥0∞)\n    (hmf : AEMeasurable f μ) : map X ℙ = μ.withDensity f ↔ pdf X ℙ μ =ᵐ[μ] f :=\n  map_eq_withDensity_pdf X ℙ μ ▸\n    withDensity_eq_iff_of_sigmaFinite (measurable_pdf X ℙ μ).aemeasurable hmf\n\n"}
{"name":"MeasureTheory.pdf.ae_lt_top","module":"Mathlib.Probability.Density","initialProofState":"Ω : Type u_1\nE : Type u_2\ninst✝¹ : MeasurableSpace E\nm : MeasurableSpace Ω\nℙ : MeasureTheory.Measure Ω\ninst✝ : MeasureTheory.IsFiniteMeasure ℙ\nμ : MeasureTheory.Measure E\nX : Ω → E\n⊢ Filter.Eventually (fun x => LT.lt (MeasureTheory.pdf X ℙ μ x) Top.top) (MeasureTheory.ae μ)","decl":"nonrec theorem ae_lt_top [IsFiniteMeasure ℙ] {μ : Measure E} {X : Ω → E} :\n    ∀ᵐ x ∂μ, pdf X ℙ μ x < ∞ :=\n  rnDeriv_lt_top (map X ℙ) μ\n\n"}
{"name":"MeasureTheory.pdf.ofReal_toReal_ae_eq","module":"Mathlib.Probability.Density","initialProofState":"Ω : Type u_1\nE : Type u_2\ninst✝¹ : MeasurableSpace E\nm : MeasurableSpace Ω\nℙ : MeasureTheory.Measure Ω\nμ : MeasureTheory.Measure E\ninst✝ : MeasureTheory.IsFiniteMeasure ℙ\nX : Ω → E\n⊢ (MeasureTheory.ae μ).EventuallyEq (fun x => ENNReal.ofReal (MeasureTheory.pdf X ℙ μ x).toReal) (MeasureTheory.pdf X ℙ μ)","decl":"nonrec theorem ofReal_toReal_ae_eq [IsFiniteMeasure ℙ] {X : Ω → E} :\n    (fun x => ENNReal.ofReal (pdf X ℙ μ x).toReal) =ᵐ[μ] pdf X ℙ μ :=\n  ofReal_toReal_ae_eq ae_lt_top\n\n"}
{"name":"MeasureTheory.pdf.lintegral_pdf_mul","module":"Mathlib.Probability.Density","initialProofState":"Ω : Type u_1\nE : Type u_2\ninst✝¹ : MeasurableSpace E\nm : MeasurableSpace Ω\nℙ : MeasureTheory.Measure Ω\nμ : MeasureTheory.Measure E\nX : Ω → E\ninst✝ : MeasureTheory.HasPDF X ℙ μ\nf : E → ENNReal\nhf : AEMeasurable f μ\n⊢ Eq (MeasureTheory.lintegral μ fun x => HMul.hMul (MeasureTheory.pdf X ℙ μ x) (f x)) (MeasureTheory.lintegral ℙ fun x => f (X x))","decl":"/-- **The Law of the Unconscious Statistician** for nonnegative random variables. -/\ntheorem lintegral_pdf_mul {X : Ω → E} [HasPDF X ℙ μ] {f : E → ℝ≥0∞}\n    (hf : AEMeasurable f μ) : ∫⁻ x, pdf X ℙ μ x * f x ∂μ = ∫⁻ x, f (X x) ∂ℙ := by\n  rw [pdf_def,\n    ← lintegral_map' (hf.mono_ac HasPDF.absolutelyContinuous) (HasPDF.aemeasurable X ℙ μ),\n    lintegral_rnDeriv_mul HasPDF.absolutelyContinuous hf]\n\n"}
{"name":"MeasureTheory.pdf.integrable_pdf_smul_iff","module":"Mathlib.Probability.Density","initialProofState":"Ω : Type u_1\nE : Type u_2\ninst✝⁴ : MeasurableSpace E\nm : MeasurableSpace Ω\nℙ : MeasureTheory.Measure Ω\nμ : MeasureTheory.Measure E\nF : Type u_3\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace Real F\ninst✝¹ : MeasureTheory.IsFiniteMeasure ℙ\nX : Ω → E\ninst✝ : MeasureTheory.HasPDF X ℙ μ\nf : E → F\nhf : MeasureTheory.AEStronglyMeasurable f μ\n⊢ Iff (MeasureTheory.Integrable (fun x => HSMul.hSMul (MeasureTheory.pdf X ℙ μ x).toReal (f x)) μ) (MeasureTheory.Integrable (fun x => f (X x)) ℙ)","decl":"theorem integrable_pdf_smul_iff [IsFiniteMeasure ℙ] {X : Ω → E} [HasPDF X ℙ μ] {f : E → F}\n    (hf : AEStronglyMeasurable f μ) :\n    Integrable (fun x => (pdf X ℙ μ x).toReal • f x) μ ↔ Integrable (fun x => f (X x)) ℙ := by\n  rw [← Function.comp_def,\n    ← integrable_map_measure (hf.mono_ac HasPDF.absolutelyContinuous) (HasPDF.aemeasurable X ℙ μ),\n    map_eq_withDensity_pdf X ℙ μ, pdf_def, integrable_rnDeriv_smul_iff HasPDF.absolutelyContinuous]\n  rw [withDensity_rnDeriv_eq _ _ HasPDF.absolutelyContinuous]\n\n"}
{"name":"MeasureTheory.pdf.integral_pdf_smul","module":"Mathlib.Probability.Density","initialProofState":"Ω : Type u_1\nE : Type u_2\ninst✝⁴ : MeasurableSpace E\nm : MeasurableSpace Ω\nℙ : MeasureTheory.Measure Ω\nμ : MeasureTheory.Measure E\nF : Type u_3\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace Real F\ninst✝¹ : MeasureTheory.IsFiniteMeasure ℙ\nX : Ω → E\ninst✝ : MeasureTheory.HasPDF X ℙ μ\nf : E → F\nhf : MeasureTheory.AEStronglyMeasurable f μ\n⊢ Eq (MeasureTheory.integral μ fun x => HSMul.hSMul (MeasureTheory.pdf X ℙ μ x).toReal (f x)) (MeasureTheory.integral ℙ fun x => f (X x))","decl":"/-- **The Law of the Unconscious Statistician**: Given a random variable `X` and a measurable\nfunction `f`, `f ∘ X` is a random variable with expectation `∫ x, pdf X x • f x ∂μ`\nwhere `μ` is a measure on the codomain of `X`. -/\ntheorem integral_pdf_smul [IsFiniteMeasure ℙ] {X : Ω → E} [HasPDF X ℙ μ] {f : E → F}\n    (hf : AEStronglyMeasurable f μ) : ∫ x, (pdf X ℙ μ x).toReal • f x ∂μ = ∫ x, f (X x) ∂ℙ := by\n  rw [← integral_map (HasPDF.aemeasurable X ℙ μ) (hf.mono_ac HasPDF.absolutelyContinuous),\n    map_eq_withDensity_pdf X ℙ μ, pdf_def, integral_rnDeriv_smul HasPDF.absolutelyContinuous,\n    withDensity_rnDeriv_eq _ _ HasPDF.absolutelyContinuous]\n\n"}
{"name":"MeasureTheory.pdf.quasiMeasurePreserving_hasPDF","module":"Mathlib.Probability.Density","initialProofState":"Ω : Type u_1\nE : Type u_2\ninst✝² : MeasurableSpace E\nm : MeasurableSpace Ω\nℙ : MeasureTheory.Measure Ω\nμ : MeasureTheory.Measure E\nF : Type u_3\ninst✝¹ : MeasurableSpace F\nν : MeasureTheory.Measure F\nX : Ω → E\ninst✝ : MeasureTheory.HasPDF X ℙ μ\ng : E → F\nhg : MeasureTheory.Measure.QuasiMeasurePreserving g μ ν\nhmap : (MeasureTheory.Measure.map g (MeasureTheory.Measure.map X ℙ)).HaveLebesgueDecomposition ν\n⊢ MeasureTheory.HasPDF (Function.comp g X) ℙ ν","decl":"/-- A random variable that `HasPDF` transformed under a `QuasiMeasurePreserving`\nmap also `HasPDF` if `(map g (map X ℙ)).HaveLebesgueDecomposition μ`.\n\n`quasiMeasurePreserving_hasPDF` is more useful in the case we are working with a\nprobability measure and a real-valued random variable. -/\ntheorem quasiMeasurePreserving_hasPDF (hg : QuasiMeasurePreserving g μ ν)\n    (hmap : (map g (map X ℙ)).HaveLebesgueDecomposition ν) : HasPDF (g ∘ X) ℙ ν := by\n  have hgm : AEMeasurable g (map X ℙ) := hg.aemeasurable.mono_ac HasPDF.absolutelyContinuous\n  rw [hasPDF_iff, ← AEMeasurable.map_map_of_aemeasurable hgm (HasPDF.aemeasurable X ℙ μ)]\n  refine ⟨hg.measurable.comp_aemeasurable (HasPDF.aemeasurable _ _ μ), hmap, ?_⟩\n  exact (HasPDF.absolutelyContinuous.map hg.1).trans hg.2\n\n"}
{"name":"MeasureTheory.pdf.quasiMeasurePreserving_hasPDF'","module":"Mathlib.Probability.Density","initialProofState":"Ω : Type u_1\nE : Type u_2\ninst✝⁴ : MeasurableSpace E\nm : MeasurableSpace Ω\nℙ : MeasureTheory.Measure Ω\nμ : MeasureTheory.Measure E\nF : Type u_3\ninst✝³ : MeasurableSpace F\nν : MeasureTheory.Measure F\nX : Ω → E\ninst✝² : MeasureTheory.HasPDF X ℙ μ\ng : E → F\ninst✝¹ : MeasureTheory.SFinite ℙ\ninst✝ : MeasureTheory.SigmaFinite ν\nhg : MeasureTheory.Measure.QuasiMeasurePreserving g μ ν\n⊢ MeasureTheory.HasPDF (Function.comp g X) ℙ ν","decl":"theorem quasiMeasurePreserving_hasPDF' [SFinite ℙ] [SigmaFinite ν]\n    (hg : QuasiMeasurePreserving g μ ν) : HasPDF (g ∘ X) ℙ ν :=\n  quasiMeasurePreserving_hasPDF X hg inferInstance\n\n"}
{"name":"Real.hasPDF_iff","module":"Mathlib.Probability.Density","initialProofState":"Ω : Type u_1\nm : MeasurableSpace Ω\nℙ : MeasureTheory.Measure Ω\nX : Ω → Real\ninst✝ : MeasureTheory.SFinite ℙ\n⊢ Iff (MeasureTheory.HasPDF X ℙ MeasureTheory.MeasureSpace.volume) (And (AEMeasurable X ℙ) ((MeasureTheory.Measure.map X ℙ).AbsolutelyContinuous MeasureTheory.MeasureSpace.volume))","decl":"nonrec theorem _root_.Real.hasPDF_iff [SFinite ℙ] :\n    HasPDF X ℙ ↔ AEMeasurable X ℙ ∧ map X ℙ ≪ volume := by\n  rw [hasPDF_iff, and_iff_right (inferInstance : HaveLebesgueDecomposition _ _)]\n\n"}
{"name":"Real.hasPDF_iff_of_aemeasurable","module":"Mathlib.Probability.Density","initialProofState":"Ω : Type u_1\nm : MeasurableSpace Ω\nℙ : MeasureTheory.Measure Ω\nX : Ω → Real\ninst✝ : MeasureTheory.SFinite ℙ\nhX : AEMeasurable X ℙ\n⊢ Iff (MeasureTheory.HasPDF X ℙ MeasureTheory.MeasureSpace.volume) ((MeasureTheory.Measure.map X ℙ).AbsolutelyContinuous MeasureTheory.MeasureSpace.volume)","decl":"/-- A real-valued random variable `X` `HasPDF X ℙ λ` (where `λ` is the Lebesgue measure) if and\nonly if the push-forward measure of `ℙ` along `X` is absolutely continuous with respect to `λ`. -/\nnonrec theorem _root_.Real.hasPDF_iff_of_aemeasurable [SFinite ℙ] (hX : AEMeasurable X ℙ) :\n    HasPDF X ℙ ↔ map X ℙ ≪ volume := by\n  rw [Real.hasPDF_iff, and_iff_right hX]\n\n"}
{"name":"MeasureTheory.pdf.integral_mul_eq_integral","module":"Mathlib.Probability.Density","initialProofState":"Ω : Type u_1\nm : MeasurableSpace Ω\nℙ : MeasureTheory.Measure Ω\nX : Ω → Real\ninst✝¹ : MeasureTheory.IsFiniteMeasure ℙ\ninst✝ : MeasureTheory.HasPDF X ℙ MeasureTheory.MeasureSpace.volume\n⊢ Eq (MeasureTheory.integral MeasureTheory.MeasureSpace.volume fun x => HMul.hMul x (MeasureTheory.pdf X ℙ MeasureTheory.MeasureSpace.volume x).toReal) (MeasureTheory.integral ℙ fun x => X x)","decl":"/-- If `X` is a real-valued random variable that has pdf `f`, then the expectation of `X` equals\n`∫ x, x * f x ∂λ` where `λ` is the Lebesgue measure. -/\ntheorem integral_mul_eq_integral [HasPDF X ℙ] : ∫ x, x * (pdf X ℙ volume x).toReal = ∫ x, X x ∂ℙ :=\n  calc\n    _ = ∫ x, (pdf X ℙ volume x).toReal * x := by congr with x; exact mul_comm _ _\n    _ = _ := integral_pdf_smul measurable_id.aestronglyMeasurable\n\n"}
{"name":"MeasureTheory.pdf.hasFiniteIntegral_mul","module":"Mathlib.Probability.Density","initialProofState":"Ω : Type u_1\nm : MeasurableSpace Ω\nℙ : MeasureTheory.Measure Ω\nX : Ω → Real\ninst✝ : MeasureTheory.IsFiniteMeasure ℙ\nf : Real → Real\ng : Real → ENNReal\nhg : (MeasureTheory.ae MeasureTheory.MeasureSpace.volume).EventuallyEq (MeasureTheory.pdf X ℙ MeasureTheory.MeasureSpace.volume) g\nhgi : Ne (MeasureTheory.lintegral MeasureTheory.MeasureSpace.volume fun x => HMul.hMul (ENorm.enorm (f x)) (g x)) Top.top\n⊢ MeasureTheory.HasFiniteIntegral (fun x => HMul.hMul (f x) (MeasureTheory.pdf X ℙ MeasureTheory.MeasureSpace.volume x).toReal) MeasureTheory.MeasureSpace.volume","decl":"theorem hasFiniteIntegral_mul {f : ℝ → ℝ} {g : ℝ → ℝ≥0∞} (hg : pdf X ℙ =ᵐ[volume] g)\n    (hgi : ∫⁻ x, ‖f x‖ₑ * g x ≠ ∞) :\n    HasFiniteIntegral fun x => f x * (pdf X ℙ volume x).toReal := by\n  rw [hasFiniteIntegral_iff_enorm]\n  have : (fun x => ‖f x‖ₑ * g x) =ᵐ[volume] fun x => ‖f x * (pdf X ℙ volume x).toReal‖ₑ := by\n    refine ae_eq_trans ((ae_eq_refl _).mul (ae_eq_trans hg.symm ofReal_toReal_ae_eq.symm)) ?_\n    simp_rw [← smul_eq_mul, enorm_smul, smul_eq_mul]\n    refine .mul (ae_eq_refl _) ?_\n    simp only [Real.enorm_eq_ofReal ENNReal.toReal_nonneg, ae_eq_refl]\n  rwa [lt_top_iff_ne_top, ← lintegral_congr_ae this]\n\n"}
{"name":"MeasureTheory.pdf.indepFun_iff_pdf_prod_eq_pdf_mul_pdf","module":"Mathlib.Probability.Density","initialProofState":"Ω : Type u_1\nE : Type u_2\ninst✝⁵ : MeasurableSpace E\nm : MeasurableSpace Ω\nℙ : MeasureTheory.Measure Ω\nμ : MeasureTheory.Measure E\nF : Type u_3\ninst✝⁴ : MeasurableSpace F\nν : MeasureTheory.Measure F\nX : Ω → E\nY : Ω → F\ninst✝³ : MeasureTheory.IsFiniteMeasure ℙ\ninst✝² : MeasureTheory.SigmaFinite μ\ninst✝¹ : MeasureTheory.SigmaFinite ν\ninst✝ : MeasureTheory.HasPDF (fun ω => { fst := X ω, snd := Y ω }) ℙ (μ.prod ν)\n⊢ Iff (ProbabilityTheory.IndepFun X Y ℙ) ((MeasureTheory.ae (μ.prod ν)).EventuallyEq (MeasureTheory.pdf (fun ω => { fst := X ω, snd := Y ω }) ℙ (μ.prod ν)) fun z => HMul.hMul (MeasureTheory.pdf X ℙ μ z.1) (MeasureTheory.pdf Y ℙ ν z.2))","decl":"/-- Random variables are independent iff their joint density is a product of marginal densities. -/\ntheorem indepFun_iff_pdf_prod_eq_pdf_mul_pdf\n    [IsFiniteMeasure ℙ] [SigmaFinite μ] [SigmaFinite ν] [HasPDF (fun ω ↦ (X ω, Y ω)) ℙ (μ.prod ν)] :\n    IndepFun X Y ℙ ↔\n      pdf (fun ω ↦ (X ω, Y ω)) ℙ (μ.prod ν) =ᵐ[μ.prod ν] fun z ↦ pdf X ℙ μ z.1 * pdf Y ℙ ν z.2 := by\n  have : HasPDF X ℙ μ := quasiMeasurePreserving_hasPDF' (μ := μ.prod ν) (fun ω ↦ (X ω, Y ω))\n    quasiMeasurePreserving_fst\n  have : HasPDF Y ℙ ν := quasiMeasurePreserving_hasPDF' (μ := μ.prod ν) (fun ω ↦ (X ω, Y ω))\n    quasiMeasurePreserving_snd\n  have h₀ : (ℙ.map X).prod (ℙ.map Y) =\n      (μ.prod ν).withDensity fun z ↦ pdf X ℙ μ z.1 * pdf Y ℙ ν z.2 :=\n    prod_eq fun s t hs ht ↦ by rw [withDensity_apply _ (hs.prod ht), ← prod_restrict,\n      lintegral_prod_mul (measurable_pdf X ℙ μ).aemeasurable (measurable_pdf Y ℙ ν).aemeasurable,\n      map_eq_setLIntegral_pdf X ℙ μ hs, map_eq_setLIntegral_pdf Y ℙ ν ht]\n  rw [indepFun_iff_map_prod_eq_prod_map_map (HasPDF.aemeasurable X ℙ μ) (HasPDF.aemeasurable Y ℙ ν),\n    ← eq_of_map_eq_withDensity, h₀]\n  exact (((measurable_pdf X ℙ μ).comp measurable_fst).mul\n    ((measurable_pdf Y ℙ ν).comp measurable_snd)).aemeasurable\n\n"}
