{"name":"EuclideanGeometry.dist_left_midpoint_eq_dist_right_midpoint","module":"Mathlib.Geometry.Euclidean.Basic","initialProofState":"V : Type u_1\nP : Type u_2\ninst‚úù¬≥ : NormedAddCommGroup V\ninst‚úù¬≤ : InnerProductSpace Real V\ninst‚úù¬π : MetricSpace P\ninst‚úù : NormedAddTorsor V P\np1 p2 : P\n‚ä¢ Eq (Dist.dist p1 (midpoint Real p1 p2)) (Dist.dist p2 (midpoint Real p1 p2))","decl":"/-- The midpoint of the segment AB is the same distance from A as it is from B. -/\ntheorem dist_left_midpoint_eq_dist_right_midpoint (p1 p2 : P) :\n    dist p1 (midpoint ‚Ñù p1 p2) = dist p2 (midpoint ‚Ñù p1 p2) := by\n  rw [dist_left_midpoint (ùïú := ‚Ñù) p1 p2, dist_right_midpoint (ùïú := ‚Ñù) p1 p2]\n\n"}
{"name":"EuclideanGeometry.inner_weightedVSub","module":"Mathlib.Geometry.Euclidean.Basic","initialProofState":"V : Type u_1\nP : Type u_2\ninst‚úù¬≥ : NormedAddCommGroup V\ninst‚úù¬≤ : InnerProductSpace Real V\ninst‚úù¬π : MetricSpace P\ninst‚úù : NormedAddTorsor V P\nŒπ‚ÇÅ : Type u_3\ns‚ÇÅ : Finset Œπ‚ÇÅ\nw‚ÇÅ : Œπ‚ÇÅ ‚Üí Real\np‚ÇÅ : Œπ‚ÇÅ ‚Üí P\nh‚ÇÅ : Eq (s‚ÇÅ.sum fun i => w‚ÇÅ i) 0\nŒπ‚ÇÇ : Type u_4\ns‚ÇÇ : Finset Œπ‚ÇÇ\nw‚ÇÇ : Œπ‚ÇÇ ‚Üí Real\np‚ÇÇ : Œπ‚ÇÇ ‚Üí P\nh‚ÇÇ : Eq (s‚ÇÇ.sum fun i => w‚ÇÇ i) 0\n‚ä¢ Eq (Inner.inner ((s‚ÇÅ.weightedVSub p‚ÇÅ) w‚ÇÅ) ((s‚ÇÇ.weightedVSub p‚ÇÇ) w‚ÇÇ)) (HDiv.hDiv (Neg.neg (s‚ÇÅ.sum fun i‚ÇÅ => s‚ÇÇ.sum fun i‚ÇÇ => HMul.hMul (HMul.hMul (w‚ÇÅ i‚ÇÅ) (w‚ÇÇ i‚ÇÇ)) (HMul.hMul (Dist.dist (p‚ÇÅ i‚ÇÅ) (p‚ÇÇ i‚ÇÇ)) (Dist.dist (p‚ÇÅ i‚ÇÅ) (p‚ÇÇ i‚ÇÇ))))) 2)","decl":"/-- The inner product of two vectors given with `weightedVSub`, in\nterms of the pairwise distances. -/\ntheorem inner_weightedVSub {Œπ‚ÇÅ : Type*} {s‚ÇÅ : Finset Œπ‚ÇÅ} {w‚ÇÅ : Œπ‚ÇÅ ‚Üí ‚Ñù} (p‚ÇÅ : Œπ‚ÇÅ ‚Üí P)\n    (h‚ÇÅ : ‚àë i ‚àà s‚ÇÅ, w‚ÇÅ i = 0) {Œπ‚ÇÇ : Type*} {s‚ÇÇ : Finset Œπ‚ÇÇ} {w‚ÇÇ : Œπ‚ÇÇ ‚Üí ‚Ñù} (p‚ÇÇ : Œπ‚ÇÇ ‚Üí P)\n    (h‚ÇÇ : ‚àë i ‚àà s‚ÇÇ, w‚ÇÇ i = 0) :\n    ‚ü™s‚ÇÅ.weightedVSub p‚ÇÅ w‚ÇÅ, s‚ÇÇ.weightedVSub p‚ÇÇ w‚ÇÇ‚ü´ =\n      (-‚àë i‚ÇÅ ‚àà s‚ÇÅ, ‚àë i‚ÇÇ ‚àà s‚ÇÇ, w‚ÇÅ i‚ÇÅ * w‚ÇÇ i‚ÇÇ * (dist (p‚ÇÅ i‚ÇÅ) (p‚ÇÇ i‚ÇÇ) * dist (p‚ÇÅ i‚ÇÅ) (p‚ÇÇ i‚ÇÇ))) /\n        2 := by\n  rw [Finset.weightedVSub_apply, Finset.weightedVSub_apply,\n    inner_sum_smul_sum_smul_of_sum_eq_zero _ h‚ÇÅ _ h‚ÇÇ]\n  simp_rw [vsub_sub_vsub_cancel_right]\n  rcongr (i‚ÇÅ i‚ÇÇ) <;> rw [dist_eq_norm_vsub V (p‚ÇÅ i‚ÇÅ) (p‚ÇÇ i‚ÇÇ)]\n\n"}
{"name":"EuclideanGeometry.dist_affineCombination","module":"Mathlib.Geometry.Euclidean.Basic","initialProofState":"V : Type u_1\nP : Type u_2\ninst‚úù¬≥ : NormedAddCommGroup V\ninst‚úù¬≤ : InnerProductSpace Real V\ninst‚úù¬π : MetricSpace P\ninst‚úù : NormedAddTorsor V P\nŒπ : Type u_3\ns : Finset Œπ\nw‚ÇÅ w‚ÇÇ : Œπ ‚Üí Real\np : Œπ ‚Üí P\nh‚ÇÅ : Eq (s.sum fun i => w‚ÇÅ i) 1\nh‚ÇÇ : Eq (s.sum fun i => w‚ÇÇ i) 1\n‚ä¢ letFun ((Finset.affineCombination Real s p) w‚ÇÅ) fun a‚ÇÅ => letFun ((Finset.affineCombination Real s p) w‚ÇÇ) fun a‚ÇÇ => Eq (HMul.hMul (Dist.dist a‚ÇÅ a‚ÇÇ) (Dist.dist a‚ÇÅ a‚ÇÇ)) (HDiv.hDiv (Neg.neg (s.sum fun i‚ÇÅ => s.sum fun i‚ÇÇ => HMul.hMul (HMul.hMul (HSub.hSub w‚ÇÅ w‚ÇÇ i‚ÇÅ) (HSub.hSub w‚ÇÅ w‚ÇÇ i‚ÇÇ)) (HMul.hMul (Dist.dist (p i‚ÇÅ) (p i‚ÇÇ)) (Dist.dist (p i‚ÇÅ) (p i‚ÇÇ))))) 2)","decl":"/-- The distance between two points given with `affineCombination`,\nin terms of the pairwise distances between the points in that\ncombination. -/\ntheorem dist_affineCombination {Œπ : Type*} {s : Finset Œπ} {w‚ÇÅ w‚ÇÇ : Œπ ‚Üí ‚Ñù} (p : Œπ ‚Üí P)\n    (h‚ÇÅ : ‚àë i ‚àà s, w‚ÇÅ i = 1) (h‚ÇÇ : ‚àë i ‚àà s, w‚ÇÇ i = 1) : by\n      have a‚ÇÅ := s.affineCombination ‚Ñù p w‚ÇÅ\n      have a‚ÇÇ := s.affineCombination ‚Ñù p w‚ÇÇ\n      exact dist a‚ÇÅ a‚ÇÇ * dist a‚ÇÅ a‚ÇÇ = (-‚àë i‚ÇÅ ‚àà s, ‚àë i‚ÇÇ ‚àà s,\n        (w‚ÇÅ - w‚ÇÇ) i‚ÇÅ * (w‚ÇÅ - w‚ÇÇ) i‚ÇÇ * (dist (p i‚ÇÅ) (p i‚ÇÇ) * dist (p i‚ÇÅ) (p i‚ÇÇ))) / 2 := by\n  dsimp only\n  rw [dist_eq_norm_vsub V (s.affineCombination ‚Ñù p w‚ÇÅ) (s.affineCombination ‚Ñù p w‚ÇÇ), ‚Üê\n    @inner_self_eq_norm_mul_norm ‚Ñù, Finset.affineCombination_vsub]\n  have h : (‚àë i ‚àà s, (w‚ÇÅ - w‚ÇÇ) i) = 0 := by\n    simp_rw [Pi.sub_apply, Finset.sum_sub_distrib, h‚ÇÅ, h‚ÇÇ, sub_self]\n  exact inner_weightedVSub p h p h\n\n-- Porting note: `inner_vsub_vsub_of_dist_eq_of_dist_eq` moved to `PerpendicularBisector`\n\n"}
{"name":"EuclideanGeometry.dist_smul_vadd_sq","module":"Mathlib.Geometry.Euclidean.Basic","initialProofState":"V : Type u_1\nP : Type u_2\ninst‚úù¬≥ : NormedAddCommGroup V\ninst‚úù¬≤ : InnerProductSpace Real V\ninst‚úù¬π : MetricSpace P\ninst‚úù : NormedAddTorsor V P\nr : Real\nv : V\np‚ÇÅ p‚ÇÇ : P\n‚ä¢ Eq (HMul.hMul (Dist.dist (HVAdd.hVAdd (HSMul.hSMul r v) p‚ÇÅ) p‚ÇÇ) (Dist.dist (HVAdd.hVAdd (HSMul.hSMul r v) p‚ÇÅ) p‚ÇÇ)) (HAdd.hAdd (HAdd.hAdd (HMul.hMul (HMul.hMul (Inner.inner v v) r) r) (HMul.hMul (HMul.hMul 2 (Inner.inner v (VSub.vsub p‚ÇÅ p‚ÇÇ))) r)) (Inner.inner (VSub.vsub p‚ÇÅ p‚ÇÇ) (VSub.vsub p‚ÇÅ p‚ÇÇ)))","decl":"/-- The squared distance between points on a line (expressed as a\nmultiple of a fixed vector added to a point) and another point,\nexpressed as a quadratic. -/\ntheorem dist_smul_vadd_sq (r : ‚Ñù) (v : V) (p‚ÇÅ p‚ÇÇ : P) :\n    dist (r ‚Ä¢ v +·µ• p‚ÇÅ) p‚ÇÇ * dist (r ‚Ä¢ v +·µ• p‚ÇÅ) p‚ÇÇ =\n      ‚ü™v, v‚ü´ * r * r + 2 * ‚ü™v, p‚ÇÅ -·µ• p‚ÇÇ‚ü´ * r + ‚ü™p‚ÇÅ -·µ• p‚ÇÇ, p‚ÇÅ -·µ• p‚ÇÇ‚ü´ := by\n  rw [dist_eq_norm_vsub V _ p‚ÇÇ, ‚Üê real_inner_self_eq_norm_mul_norm, vadd_vsub_assoc,\n    real_inner_add_add_self, real_inner_smul_left, real_inner_smul_left, real_inner_smul_right]\n  ring\n\n"}
{"name":"EuclideanGeometry.dist_smul_vadd_eq_dist","module":"Mathlib.Geometry.Euclidean.Basic","initialProofState":"V : Type u_1\nP : Type u_2\ninst‚úù¬≥ : NormedAddCommGroup V\ninst‚úù¬≤ : InnerProductSpace Real V\ninst‚úù¬π : MetricSpace P\ninst‚úù : NormedAddTorsor V P\nv : V\np‚ÇÅ p‚ÇÇ : P\nhv : Ne v 0\nr : Real\n‚ä¢ Iff (Eq (Dist.dist (HVAdd.hVAdd (HSMul.hSMul r v) p‚ÇÅ) p‚ÇÇ) (Dist.dist p‚ÇÅ p‚ÇÇ)) (Or (Eq r 0) (Eq r (HDiv.hDiv (HMul.hMul (-2) (Inner.inner v (VSub.vsub p‚ÇÅ p‚ÇÇ))) (Inner.inner v v))))","decl":"/-- The condition for two points on a line to be equidistant from\nanother point. -/\ntheorem dist_smul_vadd_eq_dist {v : V} (p‚ÇÅ p‚ÇÇ : P) (hv : v ‚â† 0) (r : ‚Ñù) :\n    dist (r ‚Ä¢ v +·µ• p‚ÇÅ) p‚ÇÇ = dist p‚ÇÅ p‚ÇÇ ‚Üî r = 0 ‚à® r = -2 * ‚ü™v, p‚ÇÅ -·µ• p‚ÇÇ‚ü´ / ‚ü™v, v‚ü´ := by\n  conv_lhs =>\n    rw [‚Üê mul_self_inj_of_nonneg dist_nonneg dist_nonneg, dist_smul_vadd_sq, mul_assoc,\n      ‚Üê sub_eq_zero, add_sub_assoc, dist_eq_norm_vsub V p‚ÇÅ p‚ÇÇ, ‚Üê real_inner_self_eq_norm_mul_norm,\n      sub_self]\n  have hvi : ‚ü™v, v‚ü´ ‚â† 0 := by simpa using hv\n  have hd : discrim ‚ü™v, v‚ü´ (2 * ‚ü™v, p‚ÇÅ -·µ• p‚ÇÇ‚ü´) 0 = 2 * ‚ü™v, p‚ÇÅ -·µ• p‚ÇÇ‚ü´ * (2 * ‚ü™v, p‚ÇÅ -·µ• p‚ÇÇ‚ü´) := by\n    rw [discrim]\n    ring\n  rw [quadratic_eq_zero_iff hvi hd, neg_add_cancel, zero_div, neg_mul_eq_neg_mul, ‚Üê\n    mul_sub_right_distrib, sub_eq_add_neg, ‚Üê mul_two, mul_assoc, mul_div_assoc, mul_div_mul_left,\n    mul_div_assoc]\n  norm_num\n\n"}
{"name":"EuclideanGeometry.eq_of_dist_eq_of_dist_eq_of_mem_of_finrank_eq_two","module":"Mathlib.Geometry.Euclidean.Basic","initialProofState":"V : Type u_1\nP : Type u_2\ninst‚úù‚Å¥ : NormedAddCommGroup V\ninst‚úù¬≥ : InnerProductSpace Real V\ninst‚úù¬≤ : MetricSpace P\ninst‚úù¬π : NormedAddTorsor V P\ns : AffineSubspace Real P\ninst‚úù : FiniteDimensional Real (Subtype fun x => Membership.mem s.direction x)\nhd : Eq (Module.finrank Real (Subtype fun x => Membership.mem s.direction x)) 2\nc‚ÇÅ c‚ÇÇ p‚ÇÅ p‚ÇÇ p : P\nhc‚ÇÅs : Membership.mem s c‚ÇÅ\nhc‚ÇÇs : Membership.mem s c‚ÇÇ\nhp‚ÇÅs : Membership.mem s p‚ÇÅ\nhp‚ÇÇs : Membership.mem s p‚ÇÇ\nhps : Membership.mem s p\nr‚ÇÅ r‚ÇÇ : Real\nhc : Ne c‚ÇÅ c‚ÇÇ\nhp : Ne p‚ÇÅ p‚ÇÇ\nhp‚ÇÅc‚ÇÅ : Eq (Dist.dist p‚ÇÅ c‚ÇÅ) r‚ÇÅ\nhp‚ÇÇc‚ÇÅ : Eq (Dist.dist p‚ÇÇ c‚ÇÅ) r‚ÇÅ\nhpc‚ÇÅ : Eq (Dist.dist p c‚ÇÅ) r‚ÇÅ\nhp‚ÇÅc‚ÇÇ : Eq (Dist.dist p‚ÇÅ c‚ÇÇ) r‚ÇÇ\nhp‚ÇÇc‚ÇÇ : Eq (Dist.dist p‚ÇÇ c‚ÇÇ) r‚ÇÇ\nhpc‚ÇÇ : Eq (Dist.dist p c‚ÇÇ) r‚ÇÇ\n‚ä¢ Or (Eq p p‚ÇÅ) (Eq p p‚ÇÇ)","decl":"/-- Distances `r‚ÇÅ` `r‚ÇÇ` of `p` from two different points `c‚ÇÅ` `c‚ÇÇ` determine at\nmost two points `p‚ÇÅ` `p‚ÇÇ` in a two-dimensional subspace containing those points\n(two circles intersect in at most two points). -/\ntheorem eq_of_dist_eq_of_dist_eq_of_mem_of_finrank_eq_two {s : AffineSubspace ‚Ñù P}\n    [FiniteDimensional ‚Ñù s.direction] (hd : finrank ‚Ñù s.direction = 2) {c‚ÇÅ c‚ÇÇ p‚ÇÅ p‚ÇÇ p : P}\n    (hc‚ÇÅs : c‚ÇÅ ‚àà s) (hc‚ÇÇs : c‚ÇÇ ‚àà s) (hp‚ÇÅs : p‚ÇÅ ‚àà s) (hp‚ÇÇs : p‚ÇÇ ‚àà s) (hps : p ‚àà s) {r‚ÇÅ r‚ÇÇ : ‚Ñù}\n    (hc : c‚ÇÅ ‚â† c‚ÇÇ) (hp : p‚ÇÅ ‚â† p‚ÇÇ) (hp‚ÇÅc‚ÇÅ : dist p‚ÇÅ c‚ÇÅ = r‚ÇÅ) (hp‚ÇÇc‚ÇÅ : dist p‚ÇÇ c‚ÇÅ = r‚ÇÅ)\n    (hpc‚ÇÅ : dist p c‚ÇÅ = r‚ÇÅ) (hp‚ÇÅc‚ÇÇ : dist p‚ÇÅ c‚ÇÇ = r‚ÇÇ) (hp‚ÇÇc‚ÇÇ : dist p‚ÇÇ c‚ÇÇ = r‚ÇÇ)\n    (hpc‚ÇÇ : dist p c‚ÇÇ = r‚ÇÇ) : p = p‚ÇÅ ‚à® p = p‚ÇÇ := by\n  have ho : ‚ü™c‚ÇÇ -·µ• c‚ÇÅ, p‚ÇÇ -·µ• p‚ÇÅ‚ü´ = 0 :=\n    inner_vsub_vsub_of_dist_eq_of_dist_eq (hp‚ÇÅc‚ÇÅ.trans hp‚ÇÇc‚ÇÅ.symm) (hp‚ÇÅc‚ÇÇ.trans hp‚ÇÇc‚ÇÇ.symm)\n  have hop : ‚ü™c‚ÇÇ -·µ• c‚ÇÅ, p -·µ• p‚ÇÅ‚ü´ = 0 :=\n    inner_vsub_vsub_of_dist_eq_of_dist_eq (hp‚ÇÅc‚ÇÅ.trans hpc‚ÇÅ.symm) (hp‚ÇÅc‚ÇÇ.trans hpc‚ÇÇ.symm)\n  let b : Fin 2 ‚Üí V := ![c‚ÇÇ -·µ• c‚ÇÅ, p‚ÇÇ -·µ• p‚ÇÅ]\n  have hb : LinearIndependent ‚Ñù b := by\n    refine linearIndependent_of_ne_zero_of_inner_eq_zero ?_ ?_\n    ¬∑ intro i\n      fin_cases i <;> simp [b, hc.symm, hp.symm]\n    ¬∑ intro i j hij\n      fin_cases i <;> fin_cases j <;> try exact False.elim (hij rfl)\n      ¬∑ exact ho\n      ¬∑ rw [real_inner_comm]\n        exact ho\n  have hbs : Submodule.span ‚Ñù (Set.range b) = s.direction := by\n    refine Submodule.eq_of_le_of_finrank_eq ?_ ?_\n    ¬∑ rw [Submodule.span_le, Set.range_subset_iff]\n      intro i\n      fin_cases i\n      ¬∑ exact vsub_mem_direction hc‚ÇÇs hc‚ÇÅs\n      ¬∑ exact vsub_mem_direction hp‚ÇÇs hp‚ÇÅs\n    ¬∑ rw [finrank_span_eq_card hb, Fintype.card_fin, hd]\n  have hv : ‚àÄ v ‚àà s.direction, ‚àÉ t‚ÇÅ t‚ÇÇ : ‚Ñù, v = t‚ÇÅ ‚Ä¢ (c‚ÇÇ -·µ• c‚ÇÅ) + t‚ÇÇ ‚Ä¢ (p‚ÇÇ -·µ• p‚ÇÅ) := by\n    intro v hv\n    have hr : Set.range b = {c‚ÇÇ -·µ• c‚ÇÅ, p‚ÇÇ -·µ• p‚ÇÅ} := by\n      have hu : (Finset.univ : Finset (Fin 2)) = {0, 1} := by decide\n      classical\n      rw [‚Üê Fintype.coe_image_univ, hu]\n      simp [b]\n    rw [‚Üê hbs, hr, Submodule.mem_span_insert] at hv\n    rcases hv with ‚ü®t‚ÇÅ, v', hv', hv‚ü©\n    rw [Submodule.mem_span_singleton] at hv'\n    rcases hv' with ‚ü®t‚ÇÇ, rfl‚ü©\n    exact ‚ü®t‚ÇÅ, t‚ÇÇ, hv‚ü©\n  rcases hv (p -·µ• p‚ÇÅ) (vsub_mem_direction hps hp‚ÇÅs) with ‚ü®t‚ÇÅ, t‚ÇÇ, hpt‚ü©\n  simp only [hpt, inner_add_right, inner_smul_right, ho, mul_zero, add_zero,\n    mul_eq_zero, inner_self_eq_zero, vsub_eq_zero_iff_eq, hc.symm, or_false] at hop\n  rw [hop, zero_smul, zero_add, ‚Üê eq_vadd_iff_vsub_eq] at hpt\n  subst hpt\n  have hp' : (p‚ÇÇ -·µ• p‚ÇÅ : V) ‚â† 0 := by simp [hp.symm]\n  have hp‚ÇÇ : dist ((1 : ‚Ñù) ‚Ä¢ (p‚ÇÇ -·µ• p‚ÇÅ) +·µ• p‚ÇÅ) c‚ÇÅ = r‚ÇÅ := by simp [hp‚ÇÇc‚ÇÅ]\n  rw [‚Üê hp‚ÇÅc‚ÇÅ, dist_smul_vadd_eq_dist _ _ hp'] at hpc‚ÇÅ hp‚ÇÇ\n  simp only [one_ne_zero, false_or] at hp‚ÇÇ\n  rw [hp‚ÇÇ.symm] at hpc‚ÇÅ\n  cases' hpc‚ÇÅ with hpc‚ÇÅ hpc‚ÇÅ <;> simp [hpc‚ÇÅ]\n\n"}
{"name":"EuclideanGeometry.eq_of_dist_eq_of_dist_eq_of_finrank_eq_two","module":"Mathlib.Geometry.Euclidean.Basic","initialProofState":"V : Type u_1\nP : Type u_2\ninst‚úù‚Å¥ : NormedAddCommGroup V\ninst‚úù¬≥ : InnerProductSpace Real V\ninst‚úù¬≤ : MetricSpace P\ninst‚úù¬π : NormedAddTorsor V P\ninst‚úù : FiniteDimensional Real V\nhd : Eq (Module.finrank Real V) 2\nc‚ÇÅ c‚ÇÇ p‚ÇÅ p‚ÇÇ p : P\nr‚ÇÅ r‚ÇÇ : Real\nhc : Ne c‚ÇÅ c‚ÇÇ\nhp : Ne p‚ÇÅ p‚ÇÇ\nhp‚ÇÅc‚ÇÅ : Eq (Dist.dist p‚ÇÅ c‚ÇÅ) r‚ÇÅ\nhp‚ÇÇc‚ÇÅ : Eq (Dist.dist p‚ÇÇ c‚ÇÅ) r‚ÇÅ\nhpc‚ÇÅ : Eq (Dist.dist p c‚ÇÅ) r‚ÇÅ\nhp‚ÇÅc‚ÇÇ : Eq (Dist.dist p‚ÇÅ c‚ÇÇ) r‚ÇÇ\nhp‚ÇÇc‚ÇÇ : Eq (Dist.dist p‚ÇÇ c‚ÇÇ) r‚ÇÇ\nhpc‚ÇÇ : Eq (Dist.dist p c‚ÇÇ) r‚ÇÇ\n‚ä¢ Or (Eq p p‚ÇÅ) (Eq p p‚ÇÇ)","decl":"/-- Distances `r‚ÇÅ` `r‚ÇÇ` of `p` from two different points `c‚ÇÅ` `c‚ÇÇ` determine at\nmost two points `p‚ÇÅ` `p‚ÇÇ` in two-dimensional space (two circles intersect in at\nmost two points). -/\ntheorem eq_of_dist_eq_of_dist_eq_of_finrank_eq_two [FiniteDimensional ‚Ñù V] (hd : finrank ‚Ñù V = 2)\n    {c‚ÇÅ c‚ÇÇ p‚ÇÅ p‚ÇÇ p : P} {r‚ÇÅ r‚ÇÇ : ‚Ñù} (hc : c‚ÇÅ ‚â† c‚ÇÇ) (hp : p‚ÇÅ ‚â† p‚ÇÇ) (hp‚ÇÅc‚ÇÅ : dist p‚ÇÅ c‚ÇÅ = r‚ÇÅ)\n    (hp‚ÇÇc‚ÇÅ : dist p‚ÇÇ c‚ÇÅ = r‚ÇÅ) (hpc‚ÇÅ : dist p c‚ÇÅ = r‚ÇÅ) (hp‚ÇÅc‚ÇÇ : dist p‚ÇÅ c‚ÇÇ = r‚ÇÇ)\n    (hp‚ÇÇc‚ÇÇ : dist p‚ÇÇ c‚ÇÇ = r‚ÇÇ) (hpc‚ÇÇ : dist p c‚ÇÇ = r‚ÇÇ) : p = p‚ÇÅ ‚à® p = p‚ÇÇ :=\n  haveI hd' : finrank ‚Ñù (‚ä§ : AffineSubspace ‚Ñù P).direction = 2 := by\n    rw [direction_top, finrank_top]\n    exact hd\n  eq_of_dist_eq_of_dist_eq_of_mem_of_finrank_eq_two hd' (mem_top ‚Ñù V _) (mem_top ‚Ñù V _)\n    (mem_top ‚Ñù V _) (mem_top ‚Ñù V _) (mem_top ‚Ñù V _) hc hp hp‚ÇÅc‚ÇÅ hp‚ÇÇc‚ÇÅ hpc‚ÇÅ hp‚ÇÅc‚ÇÇ hp‚ÇÇc‚ÇÇ hpc‚ÇÇ\n\n"}
{"name":"EuclideanGeometry.inter_eq_singleton_orthogonalProjectionFn","module":"Mathlib.Geometry.Euclidean.Basic","initialProofState":"V : Type u_1\nP : Type u_2\ninst‚úù‚Åµ : NormedAddCommGroup V\ninst‚úù‚Å¥ : InnerProductSpace Real V\ninst‚úù¬≥ : MetricSpace P\ninst‚úù¬≤ : NormedAddTorsor V P\ns : AffineSubspace Real P\ninst‚úù¬π : Nonempty (Subtype fun x => Membership.mem s x)\ninst‚úù : HasOrthogonalProjection s.direction\np : P\n‚ä¢ Eq (Inter.inter ‚Üës ‚Üë(AffineSubspace.mk' p s.direction.orthogonal)) (Singleton.singleton (EuclideanGeometry.orthogonalProjectionFn s p))","decl":"/-- The intersection of the subspace and the orthogonal subspace\nthrough the given point is the `orthogonalProjectionFn` of that\npoint onto the subspace. This lemma is only intended for use in\nsetting up the bundled version and should not be used once that is\ndefined. -/\ntheorem inter_eq_singleton_orthogonalProjectionFn {s : AffineSubspace ‚Ñù P} [Nonempty s]\n    [HasOrthogonalProjection s.direction] (p : P) :\n    (s : Set P) ‚à© mk' p s.direction·óÆ = {orthogonalProjectionFn s p} :=\n  Classical.choose_spec <|\n    inter_eq_singleton_of_nonempty_of_isCompl (nonempty_subtype.mp ‚Äπ_‚Ä∫)\n      (mk'_nonempty p s.direction·óÆ)\n      (by\n        rw [direction_mk' p s.direction·óÆ]\n        exact Submodule.isCompl_orthogonal_of_completeSpace)\n\n"}
{"name":"EuclideanGeometry.orthogonalProjectionFn_mem","module":"Mathlib.Geometry.Euclidean.Basic","initialProofState":"V : Type u_1\nP : Type u_2\ninst‚úù‚Åµ : NormedAddCommGroup V\ninst‚úù‚Å¥ : InnerProductSpace Real V\ninst‚úù¬≥ : MetricSpace P\ninst‚úù¬≤ : NormedAddTorsor V P\ns : AffineSubspace Real P\ninst‚úù¬π : Nonempty (Subtype fun x => Membership.mem s x)\ninst‚úù : HasOrthogonalProjection s.direction\np : P\n‚ä¢ Membership.mem s (EuclideanGeometry.orthogonalProjectionFn s p)","decl":"/-- The `orthogonalProjectionFn` lies in the given subspace. This\nlemma is only intended for use in setting up the bundled version and\nshould not be used once that is defined. -/\ntheorem orthogonalProjectionFn_mem {s : AffineSubspace ‚Ñù P} [Nonempty s]\n    [HasOrthogonalProjection s.direction] (p : P) : orthogonalProjectionFn s p ‚àà s := by\n  rw [‚Üê mem_coe, ‚Üê Set.singleton_subset_iff, ‚Üê inter_eq_singleton_orthogonalProjectionFn]\n  exact Set.inter_subset_left\n\n"}
{"name":"EuclideanGeometry.orthogonalProjectionFn_mem_orthogonal","module":"Mathlib.Geometry.Euclidean.Basic","initialProofState":"V : Type u_1\nP : Type u_2\ninst‚úù‚Åµ : NormedAddCommGroup V\ninst‚úù‚Å¥ : InnerProductSpace Real V\ninst‚úù¬≥ : MetricSpace P\ninst‚úù¬≤ : NormedAddTorsor V P\ns : AffineSubspace Real P\ninst‚úù¬π : Nonempty (Subtype fun x => Membership.mem s x)\ninst‚úù : HasOrthogonalProjection s.direction\np : P\n‚ä¢ Membership.mem (AffineSubspace.mk' p s.direction.orthogonal) (EuclideanGeometry.orthogonalProjectionFn s p)","decl":"/-- The `orthogonalProjectionFn` lies in the orthogonal\nsubspace. This lemma is only intended for use in setting up the\nbundled version and should not be used once that is defined. -/\ntheorem orthogonalProjectionFn_mem_orthogonal {s : AffineSubspace ‚Ñù P} [Nonempty s]\n    [HasOrthogonalProjection s.direction] (p : P) :\n    orthogonalProjectionFn s p ‚àà mk' p s.direction·óÆ := by\n  rw [‚Üê mem_coe, ‚Üê Set.singleton_subset_iff, ‚Üê inter_eq_singleton_orthogonalProjectionFn]\n  exact Set.inter_subset_right\n\n"}
{"name":"EuclideanGeometry.orthogonalProjectionFn_vsub_mem_direction_orthogonal","module":"Mathlib.Geometry.Euclidean.Basic","initialProofState":"V : Type u_1\nP : Type u_2\ninst‚úù‚Åµ : NormedAddCommGroup V\ninst‚úù‚Å¥ : InnerProductSpace Real V\ninst‚úù¬≥ : MetricSpace P\ninst‚úù¬≤ : NormedAddTorsor V P\ns : AffineSubspace Real P\ninst‚úù¬π : Nonempty (Subtype fun x => Membership.mem s x)\ninst‚úù : HasOrthogonalProjection s.direction\np : P\n‚ä¢ Membership.mem s.direction.orthogonal (VSub.vsub (EuclideanGeometry.orthogonalProjectionFn s p) p)","decl":"/-- Subtracting `p` from its `orthogonalProjectionFn` produces a\nresult in the orthogonal direction. This lemma is only intended for\nuse in setting up the bundled version and should not be used once that\nis defined. -/\ntheorem orthogonalProjectionFn_vsub_mem_direction_orthogonal {s : AffineSubspace ‚Ñù P} [Nonempty s]\n    [HasOrthogonalProjection s.direction] (p : P) :\n    orthogonalProjectionFn s p -·µ• p ‚àà s.direction·óÆ :=\n  direction_mk' p s.direction·óÆ ‚ñ∏\n    vsub_mem_direction (orthogonalProjectionFn_mem_orthogonal p) (self_mem_mk' _ _)\n\n"}
{"name":"EuclideanGeometry.orthogonalProjectionFn_eq","module":"Mathlib.Geometry.Euclidean.Basic","initialProofState":"V : Type u_1\nP : Type u_2\ninst‚úù‚Åµ : NormedAddCommGroup V\ninst‚úù‚Å¥ : InnerProductSpace Real V\ninst‚úù¬≥ : MetricSpace P\ninst‚úù¬≤ : NormedAddTorsor V P\ns : AffineSubspace Real P\ninst‚úù¬π : Nonempty (Subtype fun x => Membership.mem s x)\ninst‚úù : HasOrthogonalProjection s.direction\np : P\n‚ä¢ Eq (EuclideanGeometry.orthogonalProjectionFn s p) ‚Üë((EuclideanGeometry.orthogonalProjection s) p)","decl":"@[simp]\ntheorem orthogonalProjectionFn_eq {s : AffineSubspace ‚Ñù P} [Nonempty s]\n    [HasOrthogonalProjection s.direction] (p : P) :\n    orthogonalProjectionFn s p = orthogonalProjection s p :=\n  rfl\n\n"}
{"name":"EuclideanGeometry.orthogonalProjection_linear","module":"Mathlib.Geometry.Euclidean.Basic","initialProofState":"V : Type u_1\nP : Type u_2\ninst‚úù‚Åµ : NormedAddCommGroup V\ninst‚úù‚Å¥ : InnerProductSpace Real V\ninst‚úù¬≥ : MetricSpace P\ninst‚úù¬≤ : NormedAddTorsor V P\ns : AffineSubspace Real P\ninst‚úù¬π : Nonempty (Subtype fun x => Membership.mem s x)\ninst‚úù : HasOrthogonalProjection s.direction\n‚ä¢ Eq (EuclideanGeometry.orthogonalProjection s).linear ‚Üë(orthogonalProjection s.direction)","decl":"/-- The linear map corresponding to `orthogonalProjection`. -/\n@[simp]\ntheorem orthogonalProjection_linear {s : AffineSubspace ‚Ñù P} [Nonempty s]\n    [HasOrthogonalProjection s.direction] :\n    (orthogonalProjection s).linear = _root_.orthogonalProjection s.direction :=\n  rfl\n\n"}
{"name":"EuclideanGeometry.inter_eq_singleton_orthogonalProjection","module":"Mathlib.Geometry.Euclidean.Basic","initialProofState":"V : Type u_1\nP : Type u_2\ninst‚úù‚Åµ : NormedAddCommGroup V\ninst‚úù‚Å¥ : InnerProductSpace Real V\ninst‚úù¬≥ : MetricSpace P\ninst‚úù¬≤ : NormedAddTorsor V P\ns : AffineSubspace Real P\ninst‚úù¬π : Nonempty (Subtype fun x => Membership.mem s x)\ninst‚úù : HasOrthogonalProjection s.direction\np : P\n‚ä¢ Eq (Inter.inter ‚Üës ‚Üë(AffineSubspace.mk' p s.direction.orthogonal)) (Singleton.singleton ‚Üë((EuclideanGeometry.orthogonalProjection s) p))","decl":"/-- The intersection of the subspace and the orthogonal subspace\nthrough the given point is the `orthogonalProjection` of that point\nonto the subspace. -/\ntheorem inter_eq_singleton_orthogonalProjection {s : AffineSubspace ‚Ñù P} [Nonempty s]\n    [HasOrthogonalProjection s.direction] (p : P) :\n    (s : Set P) ‚à© mk' p s.direction·óÆ = {‚Üë(orthogonalProjection s p)} := by\n  rw [‚Üê orthogonalProjectionFn_eq]\n  exact inter_eq_singleton_orthogonalProjectionFn p\n\n"}
{"name":"EuclideanGeometry.orthogonalProjection_mem","module":"Mathlib.Geometry.Euclidean.Basic","initialProofState":"V : Type u_1\nP : Type u_2\ninst‚úù‚Åµ : NormedAddCommGroup V\ninst‚úù‚Å¥ : InnerProductSpace Real V\ninst‚úù¬≥ : MetricSpace P\ninst‚úù¬≤ : NormedAddTorsor V P\ns : AffineSubspace Real P\ninst‚úù¬π : Nonempty (Subtype fun x => Membership.mem s x)\ninst‚úù : HasOrthogonalProjection s.direction\np : P\n‚ä¢ Membership.mem s ‚Üë((EuclideanGeometry.orthogonalProjection s) p)","decl":"/-- The `orthogonalProjection` lies in the given subspace. -/\ntheorem orthogonalProjection_mem {s : AffineSubspace ‚Ñù P} [Nonempty s]\n    [HasOrthogonalProjection s.direction] (p : P) : ‚Üë(orthogonalProjection s p) ‚àà s :=\n  (orthogonalProjection s p).2\n\n"}
{"name":"EuclideanGeometry.orthogonalProjection_mem_orthogonal","module":"Mathlib.Geometry.Euclidean.Basic","initialProofState":"V : Type u_1\nP : Type u_2\ninst‚úù‚Åµ : NormedAddCommGroup V\ninst‚úù‚Å¥ : InnerProductSpace Real V\ninst‚úù¬≥ : MetricSpace P\ninst‚úù¬≤ : NormedAddTorsor V P\ns : AffineSubspace Real P\ninst‚úù¬π : Nonempty (Subtype fun x => Membership.mem s x)\ninst‚úù : HasOrthogonalProjection s.direction\np : P\n‚ä¢ Membership.mem (AffineSubspace.mk' p s.direction.orthogonal) ‚Üë((EuclideanGeometry.orthogonalProjection s) p)","decl":"/-- The `orthogonalProjection` lies in the orthogonal subspace. -/\ntheorem orthogonalProjection_mem_orthogonal (s : AffineSubspace ‚Ñù P) [Nonempty s]\n    [HasOrthogonalProjection s.direction] (p : P) :\n    ‚Üë(orthogonalProjection s p) ‚àà mk' p s.direction·óÆ :=\n  orthogonalProjectionFn_mem_orthogonal p\n\n"}
{"name":"EuclideanGeometry.orthogonalProjection_vsub_mem_direction","module":"Mathlib.Geometry.Euclidean.Basic","initialProofState":"V : Type u_1\nP : Type u_2\ninst‚úù‚Åµ : NormedAddCommGroup V\ninst‚úù‚Å¥ : InnerProductSpace Real V\ninst‚úù¬≥ : MetricSpace P\ninst‚úù¬≤ : NormedAddTorsor V P\ns : AffineSubspace Real P\ninst‚úù¬π : Nonempty (Subtype fun x => Membership.mem s x)\ninst‚úù : HasOrthogonalProjection s.direction\np1 p2 : P\nhp1 : Membership.mem s p1\n‚ä¢ Membership.mem s.direction ‚Üë(VSub.vsub ((EuclideanGeometry.orthogonalProjection s) p2) ‚ü®p1, hp1‚ü©)","decl":"/-- Subtracting a point in the given subspace from the\n`orthogonalProjection` produces a result in the direction of the\ngiven subspace. -/\ntheorem orthogonalProjection_vsub_mem_direction {s : AffineSubspace ‚Ñù P} [Nonempty s]\n    [HasOrthogonalProjection s.direction] {p1 : P} (p2 : P) (hp1 : p1 ‚àà s) :\n    ‚Üë(orthogonalProjection s p2 -·µ• ‚ü®p1, hp1‚ü© : s.direction) ‚àà s.direction :=\n  (orthogonalProjection s p2 -·µ• ‚ü®p1, hp1‚ü© : s.direction).2\n\n"}
{"name":"EuclideanGeometry.vsub_orthogonalProjection_mem_direction","module":"Mathlib.Geometry.Euclidean.Basic","initialProofState":"V : Type u_1\nP : Type u_2\ninst‚úù‚Åµ : NormedAddCommGroup V\ninst‚úù‚Å¥ : InnerProductSpace Real V\ninst‚úù¬≥ : MetricSpace P\ninst‚úù¬≤ : NormedAddTorsor V P\ns : AffineSubspace Real P\ninst‚úù¬π : Nonempty (Subtype fun x => Membership.mem s x)\ninst‚úù : HasOrthogonalProjection s.direction\np1 p2 : P\nhp1 : Membership.mem s p1\n‚ä¢ Membership.mem s.direction ‚Üë(VSub.vsub ‚ü®p1, hp1‚ü© ((EuclideanGeometry.orthogonalProjection s) p2))","decl":"/-- Subtracting the `orthogonalProjection` from a point in the given\nsubspace produces a result in the direction of the given subspace. -/\ntheorem vsub_orthogonalProjection_mem_direction {s : AffineSubspace ‚Ñù P} [Nonempty s]\n    [HasOrthogonalProjection s.direction] {p1 : P} (p2 : P) (hp1 : p1 ‚àà s) :\n    ‚Üë((‚ü®p1, hp1‚ü© : s) -·µ• orthogonalProjection s p2 : s.direction) ‚àà s.direction :=\n  ((‚ü®p1, hp1‚ü© : s) -·µ• orthogonalProjection s p2 : s.direction).2\n\n"}
{"name":"EuclideanGeometry.orthogonalProjection_eq_self_iff","module":"Mathlib.Geometry.Euclidean.Basic","initialProofState":"V : Type u_1\nP : Type u_2\ninst‚úù‚Åµ : NormedAddCommGroup V\ninst‚úù‚Å¥ : InnerProductSpace Real V\ninst‚úù¬≥ : MetricSpace P\ninst‚úù¬≤ : NormedAddTorsor V P\ns : AffineSubspace Real P\ninst‚úù¬π : Nonempty (Subtype fun x => Membership.mem s x)\ninst‚úù : HasOrthogonalProjection s.direction\np : P\n‚ä¢ Iff (Eq (‚Üë((EuclideanGeometry.orthogonalProjection s) p)) p) (Membership.mem s p)","decl":"/-- A point equals its orthogonal projection if and only if it lies in\nthe subspace. -/\ntheorem orthogonalProjection_eq_self_iff {s : AffineSubspace ‚Ñù P} [Nonempty s]\n    [HasOrthogonalProjection s.direction] {p : P} : ‚Üë(orthogonalProjection s p) = p ‚Üî p ‚àà s := by\n  constructor\n  ¬∑ exact fun h => h ‚ñ∏ orthogonalProjection_mem p\n  ¬∑ intro h\n    have hp : p ‚àà (s : Set P) ‚à© mk' p s.direction·óÆ := ‚ü®h, self_mem_mk' p _‚ü©\n    rw [inter_eq_singleton_orthogonalProjection p] at hp\n    symm\n    exact hp\n\n"}
{"name":"EuclideanGeometry.orthogonalProjection_mem_subspace_eq_self","module":"Mathlib.Geometry.Euclidean.Basic","initialProofState":"V : Type u_1\nP : Type u_2\ninst‚úù‚Åµ : NormedAddCommGroup V\ninst‚úù‚Å¥ : InnerProductSpace Real V\ninst‚úù¬≥ : MetricSpace P\ninst‚úù¬≤ : NormedAddTorsor V P\ns : AffineSubspace Real P\ninst‚úù¬π : Nonempty (Subtype fun x => Membership.mem s x)\ninst‚úù : HasOrthogonalProjection s.direction\np : Subtype fun x => Membership.mem s x\n‚ä¢ Eq ((EuclideanGeometry.orthogonalProjection s) ‚Üëp) p","decl":"@[simp]\ntheorem orthogonalProjection_mem_subspace_eq_self {s : AffineSubspace ‚Ñù P} [Nonempty s]\n    [HasOrthogonalProjection s.direction] (p : s) : orthogonalProjection s p = p := by\n  ext\n  rw [orthogonalProjection_eq_self_iff]\n  exact p.2\n\n"}
{"name":"EuclideanGeometry.orthogonalProjection_orthogonalProjection","module":"Mathlib.Geometry.Euclidean.Basic","initialProofState":"V : Type u_1\nP : Type u_2\ninst‚úù‚Åµ : NormedAddCommGroup V\ninst‚úù‚Å¥ : InnerProductSpace Real V\ninst‚úù¬≥ : MetricSpace P\ninst‚úù¬≤ : NormedAddTorsor V P\ns : AffineSubspace Real P\ninst‚úù¬π : Nonempty (Subtype fun x => Membership.mem s x)\ninst‚úù : HasOrthogonalProjection s.direction\np : P\n‚ä¢ Eq ((EuclideanGeometry.orthogonalProjection s) ‚Üë((EuclideanGeometry.orthogonalProjection s) p)) ((EuclideanGeometry.orthogonalProjection s) p)","decl":"/-- Orthogonal projection is idempotent. -/\ntheorem orthogonalProjection_orthogonalProjection (s : AffineSubspace ‚Ñù P) [Nonempty s]\n    [HasOrthogonalProjection s.direction] (p : P) :\n    orthogonalProjection s (orthogonalProjection s p) = orthogonalProjection s p := by\n  ext\n  rw [orthogonalProjection_eq_self_iff]\n  exact orthogonalProjection_mem p\n\n"}
{"name":"EuclideanGeometry.eq_orthogonalProjection_of_eq_subspace","module":"Mathlib.Geometry.Euclidean.Basic","initialProofState":"V : Type u_1\nP : Type u_2\ninst‚úù‚Å∑ : NormedAddCommGroup V\ninst‚úù‚Å∂ : InnerProductSpace Real V\ninst‚úù‚Åµ : MetricSpace P\ninst‚úù‚Å¥ : NormedAddTorsor V P\ns s' : AffineSubspace Real P\ninst‚úù¬≥ : Nonempty (Subtype fun x => Membership.mem s x)\ninst‚úù¬≤ : Nonempty (Subtype fun x => Membership.mem s' x)\ninst‚úù¬π : HasOrthogonalProjection s.direction\ninst‚úù : HasOrthogonalProjection s'.direction\nh : Eq s s'\np : P\n‚ä¢ Eq ‚Üë((EuclideanGeometry.orthogonalProjection s) p) ‚Üë((EuclideanGeometry.orthogonalProjection s') p)","decl":"theorem eq_orthogonalProjection_of_eq_subspace {s s' : AffineSubspace ‚Ñù P} [Nonempty s]\n    [Nonempty s'] [HasOrthogonalProjection s.direction] [HasOrthogonalProjection s'.direction]\n    (h : s = s') (p : P) : (orthogonalProjection s p : P) = (orthogonalProjection s' p : P) := by\n  subst h\n  rfl\n\n"}
{"name":"EuclideanGeometry.dist_orthogonalProjection_eq_zero_iff","module":"Mathlib.Geometry.Euclidean.Basic","initialProofState":"V : Type u_1\nP : Type u_2\ninst‚úù‚Åµ : NormedAddCommGroup V\ninst‚úù‚Å¥ : InnerProductSpace Real V\ninst‚úù¬≥ : MetricSpace P\ninst‚úù¬≤ : NormedAddTorsor V P\ns : AffineSubspace Real P\ninst‚úù¬π : Nonempty (Subtype fun x => Membership.mem s x)\ninst‚úù : HasOrthogonalProjection s.direction\np : P\n‚ä¢ Iff (Eq (Dist.dist p ‚Üë((EuclideanGeometry.orthogonalProjection s) p)) 0) (Membership.mem s p)","decl":"/-- The distance to a point's orthogonal projection is 0 iff it lies in the subspace. -/\ntheorem dist_orthogonalProjection_eq_zero_iff {s : AffineSubspace ‚Ñù P} [Nonempty s]\n    [HasOrthogonalProjection s.direction] {p : P} :\n    dist p (orthogonalProjection s p) = 0 ‚Üî p ‚àà s := by\n  rw [dist_comm, dist_eq_zero, orthogonalProjection_eq_self_iff]\n\n"}
{"name":"EuclideanGeometry.dist_orthogonalProjection_ne_zero_of_not_mem","module":"Mathlib.Geometry.Euclidean.Basic","initialProofState":"V : Type u_1\nP : Type u_2\ninst‚úù‚Åµ : NormedAddCommGroup V\ninst‚úù‚Å¥ : InnerProductSpace Real V\ninst‚úù¬≥ : MetricSpace P\ninst‚úù¬≤ : NormedAddTorsor V P\ns : AffineSubspace Real P\ninst‚úù¬π : Nonempty (Subtype fun x => Membership.mem s x)\ninst‚úù : HasOrthogonalProjection s.direction\np : P\nhp : Not (Membership.mem s p)\n‚ä¢ Ne (Dist.dist p ‚Üë((EuclideanGeometry.orthogonalProjection s) p)) 0","decl":"/-- The distance between a point and its orthogonal projection is\nnonzero if it does not lie in the subspace. -/\ntheorem dist_orthogonalProjection_ne_zero_of_not_mem {s : AffineSubspace ‚Ñù P} [Nonempty s]\n    [HasOrthogonalProjection s.direction] {p : P} (hp : p ‚àâ s) :\n    dist p (orthogonalProjection s p) ‚â† 0 :=\n  mt dist_orthogonalProjection_eq_zero_iff.mp hp\n\n"}
{"name":"EuclideanGeometry.orthogonalProjection_vsub_mem_direction_orthogonal","module":"Mathlib.Geometry.Euclidean.Basic","initialProofState":"V : Type u_1\nP : Type u_2\ninst‚úù‚Åµ : NormedAddCommGroup V\ninst‚úù‚Å¥ : InnerProductSpace Real V\ninst‚úù¬≥ : MetricSpace P\ninst‚úù¬≤ : NormedAddTorsor V P\ns : AffineSubspace Real P\ninst‚úù¬π : Nonempty (Subtype fun x => Membership.mem s x)\ninst‚úù : HasOrthogonalProjection s.direction\np : P\n‚ä¢ Membership.mem s.direction.orthogonal (VSub.vsub (‚Üë((EuclideanGeometry.orthogonalProjection s) p)) p)","decl":"/-- Subtracting `p` from its `orthogonalProjection` produces a result\nin the orthogonal direction. -/\ntheorem orthogonalProjection_vsub_mem_direction_orthogonal (s : AffineSubspace ‚Ñù P) [Nonempty s]\n    [HasOrthogonalProjection s.direction] (p : P) :\n    (orthogonalProjection s p : P) -·µ• p ‚àà s.direction·óÆ :=\n  orthogonalProjectionFn_vsub_mem_direction_orthogonal p\n\n"}
{"name":"EuclideanGeometry.vsub_orthogonalProjection_mem_direction_orthogonal","module":"Mathlib.Geometry.Euclidean.Basic","initialProofState":"V : Type u_1\nP : Type u_2\ninst‚úù‚Åµ : NormedAddCommGroup V\ninst‚úù‚Å¥ : InnerProductSpace Real V\ninst‚úù¬≥ : MetricSpace P\ninst‚úù¬≤ : NormedAddTorsor V P\ns : AffineSubspace Real P\ninst‚úù¬π : Nonempty (Subtype fun x => Membership.mem s x)\ninst‚úù : HasOrthogonalProjection s.direction\np : P\n‚ä¢ Membership.mem s.direction.orthogonal (VSub.vsub p ‚Üë((EuclideanGeometry.orthogonalProjection s) p))","decl":"/-- Subtracting the `orthogonalProjection` from `p` produces a result\nin the orthogonal direction. -/\ntheorem vsub_orthogonalProjection_mem_direction_orthogonal (s : AffineSubspace ‚Ñù P) [Nonempty s]\n    [HasOrthogonalProjection s.direction] (p : P) : p -·µ• orthogonalProjection s p ‚àà s.direction·óÆ :=\n  direction_mk' p s.direction·óÆ ‚ñ∏\n    vsub_mem_direction (self_mem_mk' _ _) (orthogonalProjection_mem_orthogonal s p)\n\n"}
{"name":"EuclideanGeometry.orthogonalProjection_vsub_orthogonalProjection","module":"Mathlib.Geometry.Euclidean.Basic","initialProofState":"V : Type u_1\nP : Type u_2\ninst‚úù‚Åµ : NormedAddCommGroup V\ninst‚úù‚Å¥ : InnerProductSpace Real V\ninst‚úù¬≥ : MetricSpace P\ninst‚úù¬≤ : NormedAddTorsor V P\ns : AffineSubspace Real P\ninst‚úù¬π : Nonempty (Subtype fun x => Membership.mem s x)\ninst‚úù : HasOrthogonalProjection s.direction\np : P\n‚ä¢ Eq ((orthogonalProjection s.direction) (VSub.vsub p ‚Üë((EuclideanGeometry.orthogonalProjection s) p))) 0","decl":"/-- Subtracting the `orthogonalProjection` from `p` produces a result in the kernel of the linear\npart of the orthogonal projection. -/\ntheorem orthogonalProjection_vsub_orthogonalProjection (s : AffineSubspace ‚Ñù P) [Nonempty s]\n    [HasOrthogonalProjection s.direction] (p : P) :\n    _root_.orthogonalProjection s.direction (p -·µ• orthogonalProjection s p) = 0 := by\n  apply orthogonalProjection_mem_subspace_orthogonalComplement_eq_zero\n  intro c hc\n  rw [‚Üê neg_vsub_eq_vsub_rev, inner_neg_right,\n    orthogonalProjection_vsub_mem_direction_orthogonal s p c hc, neg_zero]\n\n"}
{"name":"EuclideanGeometry.orthogonalProjection_vadd_eq_self","module":"Mathlib.Geometry.Euclidean.Basic","initialProofState":"V : Type u_1\nP : Type u_2\ninst‚úù‚Åµ : NormedAddCommGroup V\ninst‚úù‚Å¥ : InnerProductSpace Real V\ninst‚úù¬≥ : MetricSpace P\ninst‚úù¬≤ : NormedAddTorsor V P\ns : AffineSubspace Real P\ninst‚úù¬π : Nonempty (Subtype fun x => Membership.mem s x)\ninst‚úù : HasOrthogonalProjection s.direction\np : P\nhp : Membership.mem s p\nv : V\nhv : Membership.mem s.direction.orthogonal v\n‚ä¢ Eq ((EuclideanGeometry.orthogonalProjection s) (HVAdd.hVAdd v p)) ‚ü®p, hp‚ü©","decl":"/-- Adding a vector to a point in the given subspace, then taking the\northogonal projection, produces the original point if the vector was\nin the orthogonal direction. -/\ntheorem orthogonalProjection_vadd_eq_self {s : AffineSubspace ‚Ñù P} [Nonempty s]\n    [HasOrthogonalProjection s.direction] {p : P} (hp : p ‚àà s) {v : V} (hv : v ‚àà s.direction·óÆ) :\n    orthogonalProjection s (v +·µ• p) = ‚ü®p, hp‚ü© := by\n  have h := vsub_orthogonalProjection_mem_direction_orthogonal s (v +·µ• p)\n  rw [vadd_vsub_assoc, Submodule.add_mem_iff_right _ hv] at h\n  refine (eq_of_vsub_eq_zero ?_).symm\n  ext\n  refine Submodule.disjoint_def.1 s.direction.orthogonal_disjoint _ ?_ h\n  exact (_ : s.direction).2\n\n"}
{"name":"EuclideanGeometry.orthogonalProjection_vadd_smul_vsub_orthogonalProjection","module":"Mathlib.Geometry.Euclidean.Basic","initialProofState":"V : Type u_1\nP : Type u_2\ninst‚úù‚Åµ : NormedAddCommGroup V\ninst‚úù‚Å¥ : InnerProductSpace Real V\ninst‚úù¬≥ : MetricSpace P\ninst‚úù¬≤ : NormedAddTorsor V P\ns : AffineSubspace Real P\ninst‚úù¬π : Nonempty (Subtype fun x => Membership.mem s x)\ninst‚úù : HasOrthogonalProjection s.direction\np1 p2 : P\nr : Real\nhp : Membership.mem s p1\n‚ä¢ Eq ((EuclideanGeometry.orthogonalProjection s) (HVAdd.hVAdd (HSMul.hSMul r (VSub.vsub p2 ‚Üë((EuclideanGeometry.orthogonalProjection s) p2))) p1)) ‚ü®p1, hp‚ü©","decl":"/-- Adding a vector to a point in the given subspace, then taking the\northogonal projection, produces the original point if the vector is a\nmultiple of the result of subtracting a point's orthogonal projection\nfrom that point. -/\ntheorem orthogonalProjection_vadd_smul_vsub_orthogonalProjection {s : AffineSubspace ‚Ñù P}\n    [Nonempty s] [HasOrthogonalProjection s.direction] {p1 : P} (p2 : P) (r : ‚Ñù) (hp : p1 ‚àà s) :\n    orthogonalProjection s (r ‚Ä¢ (p2 -·µ• orthogonalProjection s p2 : V) +·µ• p1) = ‚ü®p1, hp‚ü© :=\n  orthogonalProjection_vadd_eq_self hp\n    (Submodule.smul_mem _ _ (vsub_orthogonalProjection_mem_direction_orthogonal s _))\n\n"}
{"name":"EuclideanGeometry.dist_sq_eq_dist_orthogonalProjection_sq_add_dist_orthogonalProjection_sq","module":"Mathlib.Geometry.Euclidean.Basic","initialProofState":"V : Type u_1\nP : Type u_2\ninst‚úù‚Åµ : NormedAddCommGroup V\ninst‚úù‚Å¥ : InnerProductSpace Real V\ninst‚úù¬≥ : MetricSpace P\ninst‚úù¬≤ : NormedAddTorsor V P\ns : AffineSubspace Real P\ninst‚úù¬π : Nonempty (Subtype fun x => Membership.mem s x)\ninst‚úù : HasOrthogonalProjection s.direction\np1 p2 : P\nhp1 : Membership.mem s p1\n‚ä¢ Eq (HMul.hMul (Dist.dist p1 p2) (Dist.dist p1 p2)) (HAdd.hAdd (HMul.hMul (Dist.dist p1 ‚Üë((EuclideanGeometry.orthogonalProjection s) p2)) (Dist.dist p1 ‚Üë((EuclideanGeometry.orthogonalProjection s) p2))) (HMul.hMul (Dist.dist p2 ‚Üë((EuclideanGeometry.orthogonalProjection s) p2)) (Dist.dist p2 ‚Üë((EuclideanGeometry.orthogonalProjection s) p2))))","decl":"/-- The square of the distance from a point in `s` to `p2` equals the\nsum of the squares of the distances of the two points to the\n`orthogonalProjection`. -/\ntheorem dist_sq_eq_dist_orthogonalProjection_sq_add_dist_orthogonalProjection_sq\n    {s : AffineSubspace ‚Ñù P} [Nonempty s] [HasOrthogonalProjection s.direction] {p1 : P} (p2 : P)\n    (hp1 : p1 ‚àà s) :\n    dist p1 p2 * dist p1 p2 =\n      dist p1 (orthogonalProjection s p2) * dist p1 (orthogonalProjection s p2) +\n        dist p2 (orthogonalProjection s p2) * dist p2 (orthogonalProjection s p2) := by\n  rw [dist_comm p2 _, dist_eq_norm_vsub V p1 _, dist_eq_norm_vsub V p1 _, dist_eq_norm_vsub V _ p2,\n    ‚Üê vsub_add_vsub_cancel p1 (orthogonalProjection s p2) p2,\n    norm_add_sq_eq_norm_sq_add_norm_sq_iff_real_inner_eq_zero]\n  exact Submodule.inner_right_of_mem_orthogonal (vsub_orthogonalProjection_mem_direction p2 hp1)\n    (orthogonalProjection_vsub_mem_direction_orthogonal s p2)\n\n"}
{"name":"EuclideanGeometry.dist_sq_smul_orthogonal_vadd_smul_orthogonal_vadd","module":"Mathlib.Geometry.Euclidean.Basic","initialProofState":"V : Type u_1\nP : Type u_2\ninst‚úù¬≥ : NormedAddCommGroup V\ninst‚úù¬≤ : InnerProductSpace Real V\ninst‚úù¬π : MetricSpace P\ninst‚úù : NormedAddTorsor V P\ns : AffineSubspace Real P\np1 p2 : P\nhp1 : Membership.mem s p1\nhp2 : Membership.mem s p2\nr1 r2 : Real\nv : V\nhv : Membership.mem s.direction.orthogonal v\n‚ä¢ Eq (HMul.hMul (Dist.dist (HVAdd.hVAdd (HSMul.hSMul r1 v) p1) (HVAdd.hVAdd (HSMul.hSMul r2 v) p2)) (Dist.dist (HVAdd.hVAdd (HSMul.hSMul r1 v) p1) (HVAdd.hVAdd (HSMul.hSMul r2 v) p2))) (HAdd.hAdd (HMul.hMul (Dist.dist p1 p2) (Dist.dist p1 p2)) (HMul.hMul (HMul.hMul (HSub.hSub r1 r2) (HSub.hSub r1 r2)) (HMul.hMul (Norm.norm v) (Norm.norm v))))","decl":"/-- The square of the distance between two points constructed by\nadding multiples of the same orthogonal vector to points in the same\nsubspace. -/\ntheorem dist_sq_smul_orthogonal_vadd_smul_orthogonal_vadd {s : AffineSubspace ‚Ñù P} {p1 p2 : P}\n    (hp1 : p1 ‚àà s) (hp2 : p2 ‚àà s) (r1 r2 : ‚Ñù) {v : V} (hv : v ‚àà s.direction·óÆ) :\n    dist (r1 ‚Ä¢ v +·µ• p1) (r2 ‚Ä¢ v +·µ• p2) * dist (r1 ‚Ä¢ v +·µ• p1) (r2 ‚Ä¢ v +·µ• p2) =\n      dist p1 p2 * dist p1 p2 + (r1 - r2) * (r1 - r2) * (‚Äñv‚Äñ * ‚Äñv‚Äñ) :=\n  calc\n    dist (r1 ‚Ä¢ v +·µ• p1) (r2 ‚Ä¢ v +·µ• p2) * dist (r1 ‚Ä¢ v +·µ• p1) (r2 ‚Ä¢ v +·µ• p2) =\n        ‚Äñp1 -·µ• p2 + (r1 - r2) ‚Ä¢ v‚Äñ * ‚Äñp1 -·µ• p2 + (r1 - r2) ‚Ä¢ v‚Äñ := by\n      rw [dist_eq_norm_vsub V (r1 ‚Ä¢ v +·µ• p1), vsub_vadd_eq_vsub_sub, vadd_vsub_assoc, sub_smul,\n        add_comm, add_sub_assoc]\n    _ = ‚Äñp1 -·µ• p2‚Äñ * ‚Äñp1 -·µ• p2‚Äñ + ‚Äñ(r1 - r2) ‚Ä¢ v‚Äñ * ‚Äñ(r1 - r2) ‚Ä¢ v‚Äñ :=\n      (norm_add_sq_eq_norm_sq_add_norm_sq_real\n        (Submodule.inner_right_of_mem_orthogonal (vsub_mem_direction hp1 hp2)\n          (Submodule.smul_mem _ _ hv)))\n    _ = ‚Äñ(p1 -·µ• p2 : V)‚Äñ * ‚Äñ(p1 -·µ• p2 : V)‚Äñ + |r1 - r2| * |r1 - r2| * ‚Äñv‚Äñ * ‚Äñv‚Äñ := by\n      rw [norm_smul, Real.norm_eq_abs]\n      ring\n    _ = dist p1 p2 * dist p1 p2 + (r1 - r2) * (r1 - r2) * (‚Äñv‚Äñ * ‚Äñv‚Äñ) := by\n      rw [dist_eq_norm_vsub V p1, abs_mul_abs_self, mul_assoc]\n\n"}
{"name":"EuclideanGeometry.reflection_apply","module":"Mathlib.Geometry.Euclidean.Basic","initialProofState":"V : Type u_1\nP : Type u_2\ninst‚úù‚Åµ : NormedAddCommGroup V\ninst‚úù‚Å¥ : InnerProductSpace Real V\ninst‚úù¬≥ : MetricSpace P\ninst‚úù¬≤ : NormedAddTorsor V P\ns : AffineSubspace Real P\ninst‚úù¬π : Nonempty (Subtype fun x => Membership.mem s x)\ninst‚úù : HasOrthogonalProjection s.direction\np : P\n‚ä¢ Eq ((EuclideanGeometry.reflection s) p) (HVAdd.hVAdd (VSub.vsub (‚Üë((EuclideanGeometry.orthogonalProjection s) p)) p) ‚Üë((EuclideanGeometry.orthogonalProjection s) p))","decl":"/-- The result of reflecting. -/\ntheorem reflection_apply (s : AffineSubspace ‚Ñù P) [Nonempty s] [HasOrthogonalProjection s.direction]\n    (p : P) :\n    reflection s p = (‚Üë(orthogonalProjection s p) -·µ• p) +·µ• (orthogonalProjection s p : P) :=\n  rfl\n\n"}
{"name":"EuclideanGeometry.eq_reflection_of_eq_subspace","module":"Mathlib.Geometry.Euclidean.Basic","initialProofState":"V : Type u_1\nP : Type u_2\ninst‚úù‚Å∑ : NormedAddCommGroup V\ninst‚úù‚Å∂ : InnerProductSpace Real V\ninst‚úù‚Åµ : MetricSpace P\ninst‚úù‚Å¥ : NormedAddTorsor V P\ns s' : AffineSubspace Real P\ninst‚úù¬≥ : Nonempty (Subtype fun x => Membership.mem s x)\ninst‚úù¬≤ : Nonempty (Subtype fun x => Membership.mem s' x)\ninst‚úù¬π : HasOrthogonalProjection s.direction\ninst‚úù : HasOrthogonalProjection s'.direction\nh : Eq s s'\np : P\n‚ä¢ Eq ((EuclideanGeometry.reflection s) p) ((EuclideanGeometry.reflection s') p)","decl":"theorem eq_reflection_of_eq_subspace {s s' : AffineSubspace ‚Ñù P} [Nonempty s] [Nonempty s']\n    [HasOrthogonalProjection s.direction] [HasOrthogonalProjection s'.direction] (h : s = s')\n    (p : P) : (reflection s p : P) = (reflection s' p : P) := by\n  subst h\n  rfl\n\n"}
{"name":"EuclideanGeometry.reflection_reflection","module":"Mathlib.Geometry.Euclidean.Basic","initialProofState":"V : Type u_1\nP : Type u_2\ninst‚úù‚Åµ : NormedAddCommGroup V\ninst‚úù‚Å¥ : InnerProductSpace Real V\ninst‚úù¬≥ : MetricSpace P\ninst‚úù¬≤ : NormedAddTorsor V P\ns : AffineSubspace Real P\ninst‚úù¬π : Nonempty (Subtype fun x => Membership.mem s x)\ninst‚úù : HasOrthogonalProjection s.direction\np : P\n‚ä¢ Eq ((EuclideanGeometry.reflection s) ((EuclideanGeometry.reflection s) p)) p","decl":"/-- Reflecting twice in the same subspace. -/\n@[simp]\ntheorem reflection_reflection (s : AffineSubspace ‚Ñù P) [Nonempty s]\n    [HasOrthogonalProjection s.direction] (p : P) : reflection s (reflection s p) = p := by\n  have : ‚àÄ a : s, ‚àÄ b : V, (_root_.orthogonalProjection s.direction) b = 0 ‚Üí\n      reflection s (reflection s (b +·µ• (a : P))) = b +·µ• (a : P) := by\n    intro _ _ h\n    simp [reflection, h]\n  rw [‚Üê vsub_vadd p (orthogonalProjection s p)]\n  exact this (orthogonalProjection s p) _ (orthogonalProjection_vsub_orthogonalProjection s p)\n\n"}
{"name":"EuclideanGeometry.reflection_symm","module":"Mathlib.Geometry.Euclidean.Basic","initialProofState":"V : Type u_1\nP : Type u_2\ninst‚úù‚Åµ : NormedAddCommGroup V\ninst‚úù‚Å¥ : InnerProductSpace Real V\ninst‚úù¬≥ : MetricSpace P\ninst‚úù¬≤ : NormedAddTorsor V P\ns : AffineSubspace Real P\ninst‚úù¬π : Nonempty (Subtype fun x => Membership.mem s x)\ninst‚úù : HasOrthogonalProjection s.direction\n‚ä¢ Eq (EuclideanGeometry.reflection s).symm (EuclideanGeometry.reflection s)","decl":"/-- Reflection is its own inverse. -/\n@[simp]\ntheorem reflection_symm (s : AffineSubspace ‚Ñù P) [Nonempty s]\n    [HasOrthogonalProjection s.direction] : (reflection s).symm = reflection s := by\n  ext\n  rw [‚Üê (reflection s).injective.eq_iff]\n  simp\n\n"}
{"name":"EuclideanGeometry.reflection_involutive","module":"Mathlib.Geometry.Euclidean.Basic","initialProofState":"V : Type u_1\nP : Type u_2\ninst‚úù‚Åµ : NormedAddCommGroup V\ninst‚úù‚Å¥ : InnerProductSpace Real V\ninst‚úù¬≥ : MetricSpace P\ninst‚úù¬≤ : NormedAddTorsor V P\ns : AffineSubspace Real P\ninst‚úù¬π : Nonempty (Subtype fun x => Membership.mem s x)\ninst‚úù : HasOrthogonalProjection s.direction\n‚ä¢ Function.Involutive ‚áë(EuclideanGeometry.reflection s)","decl":"/-- Reflection is involutive. -/\ntheorem reflection_involutive (s : AffineSubspace ‚Ñù P) [Nonempty s]\n    [HasOrthogonalProjection s.direction] : Function.Involutive (reflection s) :=\n  reflection_reflection s\n\n"}
{"name":"EuclideanGeometry.reflection_eq_self_iff","module":"Mathlib.Geometry.Euclidean.Basic","initialProofState":"V : Type u_1\nP : Type u_2\ninst‚úù‚Åµ : NormedAddCommGroup V\ninst‚úù‚Å¥ : InnerProductSpace Real V\ninst‚úù¬≥ : MetricSpace P\ninst‚úù¬≤ : NormedAddTorsor V P\ns : AffineSubspace Real P\ninst‚úù¬π : Nonempty (Subtype fun x => Membership.mem s x)\ninst‚úù : HasOrthogonalProjection s.direction\np : P\n‚ä¢ Iff (Eq ((EuclideanGeometry.reflection s) p) p) (Membership.mem s p)","decl":"/-- A point is its own reflection if and only if it is in the subspace. -/\ntheorem reflection_eq_self_iff {s : AffineSubspace ‚Ñù P} [Nonempty s]\n    [HasOrthogonalProjection s.direction] (p : P) : reflection s p = p ‚Üî p ‚àà s := by\n  rw [‚Üê orthogonalProjection_eq_self_iff, reflection_apply]\n  constructor\n  ¬∑ intro h\n    rw [‚Üê @vsub_eq_zero_iff_eq V, vadd_vsub_assoc, ‚Üê two_smul ‚Ñù (‚Üë(orthogonalProjection s p) -·µ• p),\n      smul_eq_zero] at h\n    norm_num at h\n    exact h\n  ¬∑ intro h\n    simp [h]\n\n"}
{"name":"EuclideanGeometry.reflection_eq_iff_orthogonalProjection_eq","module":"Mathlib.Geometry.Euclidean.Basic","initialProofState":"V : Type u_1\nP : Type u_2\ninst‚úù‚Å∑ : NormedAddCommGroup V\ninst‚úù‚Å∂ : InnerProductSpace Real V\ninst‚úù‚Åµ : MetricSpace P\ninst‚úù‚Å¥ : NormedAddTorsor V P\ns‚ÇÅ s‚ÇÇ : AffineSubspace Real P\ninst‚úù¬≥ : Nonempty (Subtype fun x => Membership.mem s‚ÇÅ x)\ninst‚úù¬≤ : Nonempty (Subtype fun x => Membership.mem s‚ÇÇ x)\ninst‚úù¬π : HasOrthogonalProjection s‚ÇÅ.direction\ninst‚úù : HasOrthogonalProjection s‚ÇÇ.direction\np : P\n‚ä¢ Iff (Eq ((EuclideanGeometry.reflection s‚ÇÅ) p) ((EuclideanGeometry.reflection s‚ÇÇ) p)) (Eq ‚Üë((EuclideanGeometry.orthogonalProjection s‚ÇÅ) p) ‚Üë((EuclideanGeometry.orthogonalProjection s‚ÇÇ) p))","decl":"/-- Reflecting a point in two subspaces produces the same result if\nand only if the point has the same orthogonal projection in each of\nthose subspaces. -/\ntheorem reflection_eq_iff_orthogonalProjection_eq (s‚ÇÅ s‚ÇÇ : AffineSubspace ‚Ñù P) [Nonempty s‚ÇÅ]\n    [Nonempty s‚ÇÇ] [HasOrthogonalProjection s‚ÇÅ.direction] [HasOrthogonalProjection s‚ÇÇ.direction]\n    (p : P) :\n    reflection s‚ÇÅ p = reflection s‚ÇÇ p ‚Üî\n      (orthogonalProjection s‚ÇÅ p : P) = orthogonalProjection s‚ÇÇ p := by\n  rw [reflection_apply, reflection_apply]\n  constructor\n  ¬∑ intro h\n    rw [‚Üê @vsub_eq_zero_iff_eq V, vsub_vadd_eq_vsub_sub, vadd_vsub_assoc, add_comm, add_sub_assoc,\n      vsub_sub_vsub_cancel_right, ‚Üê\n      two_smul ‚Ñù ((orthogonalProjection s‚ÇÅ p : P) -·µ• orthogonalProjection s‚ÇÇ p), smul_eq_zero] at h\n    norm_num at h\n    exact h\n  ¬∑ intro h\n    rw [h]\n\n"}
{"name":"EuclideanGeometry.dist_reflection","module":"Mathlib.Geometry.Euclidean.Basic","initialProofState":"V : Type u_1\nP : Type u_2\ninst‚úù‚Åµ : NormedAddCommGroup V\ninst‚úù‚Å¥ : InnerProductSpace Real V\ninst‚úù¬≥ : MetricSpace P\ninst‚úù¬≤ : NormedAddTorsor V P\ns : AffineSubspace Real P\ninst‚úù¬π : Nonempty (Subtype fun x => Membership.mem s x)\ninst‚úù : HasOrthogonalProjection s.direction\np‚ÇÅ p‚ÇÇ : P\n‚ä¢ Eq (Dist.dist p‚ÇÅ ((EuclideanGeometry.reflection s) p‚ÇÇ)) (Dist.dist ((EuclideanGeometry.reflection s) p‚ÇÅ) p‚ÇÇ)","decl":"/-- The distance between `p‚ÇÅ` and the reflection of `p‚ÇÇ` equals that\nbetween the reflection of `p‚ÇÅ` and `p‚ÇÇ`. -/\ntheorem dist_reflection (s : AffineSubspace ‚Ñù P) [Nonempty s] [HasOrthogonalProjection s.direction]\n    (p‚ÇÅ p‚ÇÇ : P) : dist p‚ÇÅ (reflection s p‚ÇÇ) = dist (reflection s p‚ÇÅ) p‚ÇÇ := by\n  conv_lhs => rw [‚Üê reflection_reflection s p‚ÇÅ]\n  exact (reflection s).dist_map _ _\n\n"}
{"name":"EuclideanGeometry.dist_reflection_eq_of_mem","module":"Mathlib.Geometry.Euclidean.Basic","initialProofState":"V : Type u_1\nP : Type u_2\ninst‚úù‚Åµ : NormedAddCommGroup V\ninst‚úù‚Å¥ : InnerProductSpace Real V\ninst‚úù¬≥ : MetricSpace P\ninst‚úù¬≤ : NormedAddTorsor V P\ns : AffineSubspace Real P\ninst‚úù¬π : Nonempty (Subtype fun x => Membership.mem s x)\ninst‚úù : HasOrthogonalProjection s.direction\np‚ÇÅ : P\nhp‚ÇÅ : Membership.mem s p‚ÇÅ\np‚ÇÇ : P\n‚ä¢ Eq (Dist.dist p‚ÇÅ ((EuclideanGeometry.reflection s) p‚ÇÇ)) (Dist.dist p‚ÇÅ p‚ÇÇ)","decl":"/-- A point in the subspace is equidistant from another point and its\nreflection. -/\ntheorem dist_reflection_eq_of_mem (s : AffineSubspace ‚Ñù P) [Nonempty s]\n    [HasOrthogonalProjection s.direction] {p‚ÇÅ : P} (hp‚ÇÅ : p‚ÇÅ ‚àà s) (p‚ÇÇ : P) :\n    dist p‚ÇÅ (reflection s p‚ÇÇ) = dist p‚ÇÅ p‚ÇÇ := by\n  rw [‚Üê reflection_eq_self_iff p‚ÇÅ] at hp‚ÇÅ\n  convert (reflection s).dist_map p‚ÇÅ p‚ÇÇ\n  rw [hp‚ÇÅ]\n\n"}
{"name":"EuclideanGeometry.reflection_mem_of_le_of_mem","module":"Mathlib.Geometry.Euclidean.Basic","initialProofState":"V : Type u_1\nP : Type u_2\ninst‚úù‚Åµ : NormedAddCommGroup V\ninst‚úù‚Å¥ : InnerProductSpace Real V\ninst‚úù¬≥ : MetricSpace P\ninst‚úù¬≤ : NormedAddTorsor V P\ns‚ÇÅ s‚ÇÇ : AffineSubspace Real P\ninst‚úù¬π : Nonempty (Subtype fun x => Membership.mem s‚ÇÅ x)\ninst‚úù : HasOrthogonalProjection s‚ÇÅ.direction\nhle : LE.le s‚ÇÅ s‚ÇÇ\np : P\nhp : Membership.mem s‚ÇÇ p\n‚ä¢ Membership.mem s‚ÇÇ ((EuclideanGeometry.reflection s‚ÇÅ) p)","decl":"/-- The reflection of a point in a subspace is contained in any larger\nsubspace containing both the point and the subspace reflected in. -/\ntheorem reflection_mem_of_le_of_mem {s‚ÇÅ s‚ÇÇ : AffineSubspace ‚Ñù P} [Nonempty s‚ÇÅ]\n    [HasOrthogonalProjection s‚ÇÅ.direction] (hle : s‚ÇÅ ‚â§ s‚ÇÇ) {p : P} (hp : p ‚àà s‚ÇÇ) :\n    reflection s‚ÇÅ p ‚àà s‚ÇÇ := by\n  rw [reflection_apply]\n  have ho : ‚Üë(orthogonalProjection s‚ÇÅ p) ‚àà s‚ÇÇ := hle (orthogonalProjection_mem p)\n  exact vadd_mem_of_mem_direction (vsub_mem_direction ho hp) ho\n\n"}
{"name":"EuclideanGeometry.reflection_orthogonal_vadd","module":"Mathlib.Geometry.Euclidean.Basic","initialProofState":"V : Type u_1\nP : Type u_2\ninst‚úù‚Åµ : NormedAddCommGroup V\ninst‚úù‚Å¥ : InnerProductSpace Real V\ninst‚úù¬≥ : MetricSpace P\ninst‚úù¬≤ : NormedAddTorsor V P\ns : AffineSubspace Real P\ninst‚úù¬π : Nonempty (Subtype fun x => Membership.mem s x)\ninst‚úù : HasOrthogonalProjection s.direction\np : P\nhp : Membership.mem s p\nv : V\nhv : Membership.mem s.direction.orthogonal v\n‚ä¢ Eq ((EuclideanGeometry.reflection s) (HVAdd.hVAdd v p)) (HVAdd.hVAdd (Neg.neg v) p)","decl":"/-- Reflecting an orthogonal vector plus a point in the subspace\nproduces the negation of that vector plus the point. -/\ntheorem reflection_orthogonal_vadd {s : AffineSubspace ‚Ñù P} [Nonempty s]\n    [HasOrthogonalProjection s.direction] {p : P} (hp : p ‚àà s) {v : V} (hv : v ‚àà s.direction·óÆ) :\n    reflection s (v +·µ• p) = -v +·µ• p := by\n  rw [reflection_apply, orthogonalProjection_vadd_eq_self hp hv, vsub_vadd_eq_vsub_sub]\n  simp\n\n"}
{"name":"EuclideanGeometry.reflection_vadd_smul_vsub_orthogonalProjection","module":"Mathlib.Geometry.Euclidean.Basic","initialProofState":"V : Type u_1\nP : Type u_2\ninst‚úù‚Åµ : NormedAddCommGroup V\ninst‚úù‚Å¥ : InnerProductSpace Real V\ninst‚úù¬≥ : MetricSpace P\ninst‚úù¬≤ : NormedAddTorsor V P\ns : AffineSubspace Real P\ninst‚úù¬π : Nonempty (Subtype fun x => Membership.mem s x)\ninst‚úù : HasOrthogonalProjection s.direction\np‚ÇÅ p‚ÇÇ : P\nr : Real\nhp‚ÇÅ : Membership.mem s p‚ÇÅ\n‚ä¢ Eq ((EuclideanGeometry.reflection s) (HVAdd.hVAdd (HSMul.hSMul r (VSub.vsub p‚ÇÇ ‚Üë((EuclideanGeometry.orthogonalProjection s) p‚ÇÇ))) p‚ÇÅ)) (HVAdd.hVAdd (Neg.neg (HSMul.hSMul r (VSub.vsub p‚ÇÇ ‚Üë((EuclideanGeometry.orthogonalProjection s) p‚ÇÇ)))) p‚ÇÅ)","decl":"/-- Reflecting a vector plus a point in the subspace produces the\nnegation of that vector plus the point if the vector is a multiple of\nthe result of subtracting a point's orthogonal projection from that\npoint. -/\ntheorem reflection_vadd_smul_vsub_orthogonalProjection {s : AffineSubspace ‚Ñù P} [Nonempty s]\n    [HasOrthogonalProjection s.direction] {p‚ÇÅ : P} (p‚ÇÇ : P) (r : ‚Ñù) (hp‚ÇÅ : p‚ÇÅ ‚àà s) :\n    reflection s (r ‚Ä¢ (p‚ÇÇ -·µ• orthogonalProjection s p‚ÇÇ) +·µ• p‚ÇÅ) =\n      -(r ‚Ä¢ (p‚ÇÇ -·µ• orthogonalProjection s p‚ÇÇ)) +·µ• p‚ÇÅ :=\n  reflection_orthogonal_vadd hp‚ÇÅ\n    (Submodule.smul_mem _ _ (vsub_orthogonalProjection_mem_direction_orthogonal s _))\n\n"}
