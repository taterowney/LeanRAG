{"name":"FinBoolAlg.mk.inj","module":"Mathlib.Order.Category.FinBoolAlg","initialProofState":"toBoolAlg✝ : BoolAlg\nisFintype✝ : Fintype ↑toBoolAlg✝\ntoBoolAlg : BoolAlg\nisFintype : Fintype ↑toBoolAlg\nx✝ : Eq (FinBoolAlg.mk toBoolAlg✝) (FinBoolAlg.mk toBoolAlg)\n⊢ And (Eq toBoolAlg✝ toBoolAlg) (HEq isFintype✝ isFintype)","decl":"/-- The category of finite boolean algebras with bounded lattice morphisms. -/\nstructure FinBoolAlg where\n  toBoolAlg : BoolAlg\n  [isFintype : Fintype toBoolAlg]\n\n"}
{"name":"FinBoolAlg.mk.injEq","module":"Mathlib.Order.Category.FinBoolAlg","initialProofState":"toBoolAlg✝ : BoolAlg\nisFintype✝ : Fintype ↑toBoolAlg✝\ntoBoolAlg : BoolAlg\nisFintype : Fintype ↑toBoolAlg\n⊢ Eq (Eq (FinBoolAlg.mk toBoolAlg✝) (FinBoolAlg.mk toBoolAlg)) (And (Eq toBoolAlg✝ toBoolAlg) (HEq isFintype✝ isFintype))","decl":"/-- The category of finite boolean algebras with bounded lattice morphisms. -/\nstructure FinBoolAlg where\n  toBoolAlg : BoolAlg\n  [isFintype : Fintype toBoolAlg]\n\n"}
{"name":"FinBoolAlg.mk.sizeOf_spec","module":"Mathlib.Order.Category.FinBoolAlg","initialProofState":"toBoolAlg : BoolAlg\nisFintype : Fintype ↑toBoolAlg\n⊢ Eq (SizeOf.sizeOf (FinBoolAlg.mk toBoolAlg)) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf toBoolAlg)) (SizeOf.sizeOf isFintype))","decl":"/-- The category of finite boolean algebras with bounded lattice morphisms. -/\nstructure FinBoolAlg where\n  toBoolAlg : BoolAlg\n  [isFintype : Fintype toBoolAlg]\n\n"}
{"name":"FinBoolAlg.coe_of","module":"Mathlib.Order.Category.FinBoolAlg","initialProofState":"α : Type u_1\ninst✝¹ : BooleanAlgebra α\ninst✝ : Fintype α\n⊢ Eq (↑(FinBoolAlg.of α).toBoolAlg) α","decl":"@[simp]\ntheorem coe_of (α : Type*) [BooleanAlgebra α] [Fintype α] : ↥(of α) = α :=\n  rfl\n\n"}
{"name":"FinBoolAlg.instBoundedLatticeHomClass","module":"Mathlib.Order.Category.FinBoolAlg","initialProofState":"X Y : FinBoolAlg\n⊢ BoundedLatticeHomClass (Quiver.Hom X Y) ↑X.toBoolAlg ↑Y.toBoolAlg","decl":"instance instBoundedLatticeHomClass {X Y : FinBoolAlg} : BoundedLatticeHomClass (X ⟶ Y) X Y :=\n  BoundedLatticeHom.instBoundedLatticeHomClass\n\n"}
{"name":"FinBoolAlg.forgetToBoolAlg_full","module":"Mathlib.Order.Category.FinBoolAlg","initialProofState":"⊢ (CategoryTheory.forget₂ FinBoolAlg BoolAlg).Full","decl":"instance forgetToBoolAlg_full : (forget₂ FinBoolAlg BoolAlg).Full :=\n  InducedCategory.full _\n\n"}
{"name":"FinBoolAlg.forgetToBoolAlgFaithful","module":"Mathlib.Order.Category.FinBoolAlg","initialProofState":"⊢ (CategoryTheory.forget₂ FinBoolAlg BoolAlg).Faithful","decl":"instance forgetToBoolAlgFaithful : (forget₂ FinBoolAlg BoolAlg).Faithful :=\n  InducedCategory.faithful _\n\n"}
{"name":"FinBoolAlg.hasForgetToFinPartOrd_forget₂_map","module":"Mathlib.Order.Category.FinBoolAlg","initialProofState":"X Y : FinBoolAlg\nf : Quiver.Hom X Y\n⊢ Eq (CategoryTheory.HasForget₂.forget₂.map f) (letFun ↑(letFun f fun this => this) fun this => this)","decl":"@[simps]\ninstance hasForgetToFinPartOrd : HasForget₂ FinBoolAlg FinPartOrd where\n  forget₂.obj X := FinPartOrd.of X\n  forget₂.map {X Y} f := show OrderHom X Y from ↑(show BoundedLatticeHom X Y from f)\n\n"}
{"name":"FinBoolAlg.hasForgetToFinPartOrd_forget₂_obj","module":"Mathlib.Order.Category.FinBoolAlg","initialProofState":"X : FinBoolAlg\n⊢ Eq (CategoryTheory.HasForget₂.forget₂.obj X) (FinPartOrd.of ↑X.toBoolAlg)","decl":"@[simps]\ninstance hasForgetToFinPartOrd : HasForget₂ FinBoolAlg FinPartOrd where\n  forget₂.obj X := FinPartOrd.of X\n  forget₂.map {X Y} f := show OrderHom X Y from ↑(show BoundedLatticeHom X Y from f)\n\n"}
{"name":"FinBoolAlg.forgetToFinPartOrdFaithful","module":"Mathlib.Order.Category.FinBoolAlg","initialProofState":"⊢ (CategoryTheory.forget₂ FinBoolAlg FinPartOrd).Faithful","decl":"instance forgetToFinPartOrdFaithful : (forget₂ FinBoolAlg FinPartOrd).Faithful :=\n  -- Porting note: original code\n  -- ⟨fun {X Y} f g h =>\n  --   haveI := congr_arg (coeFn : _ → X → Y) h\n  --   DFunLike.coe_injective this⟩\n  -- Porting note: the coercions to functions for the various bundled order categories\n  -- are quite inconsistent. We need to go back through and make all these files uniform.\n  ⟨fun {X Y} f g h => by\n    dsimp at *\n    apply DFunLike.coe_injective\n    dsimp\n    ext x\n    apply_fun (fun f => f x) at h\n    exact h ⟩\n\n"}
{"name":"FinBoolAlg.Iso.mk_hom_toLatticeHom_toSupHom_toFun","module":"Mathlib.Order.Category.FinBoolAlg","initialProofState":"α β : FinBoolAlg\ne : OrderIso ↑α.toBoolAlg ↑β.toBoolAlg\na : ↑α.toBoolAlg\n⊢ Eq ((FinBoolAlg.Iso.mk e).hom.toSupHom a) (e a)","decl":"/-- Constructs an equivalence between finite Boolean algebras from an order isomorphism between\nthem. -/\n@[simps]\ndef Iso.mk {α β : FinBoolAlg.{u}} (e : α ≃o β) : α ≅ β where\n  hom := (e : BoundedLatticeHom α β)\n  inv := (e.symm : BoundedLatticeHom β α)\n  hom_inv_id := by ext; exact e.symm_apply_apply _\n  inv_hom_id := by ext; exact e.apply_symm_apply _\n\n"}
{"name":"FinBoolAlg.Iso.mk_inv_toLatticeHom_toSupHom_toFun","module":"Mathlib.Order.Category.FinBoolAlg","initialProofState":"α β : FinBoolAlg\ne : OrderIso ↑α.toBoolAlg ↑β.toBoolAlg\na : ↑β.toBoolAlg\n⊢ Eq ((FinBoolAlg.Iso.mk e).inv.toSupHom a) (e.symm a)","decl":"/-- Constructs an equivalence between finite Boolean algebras from an order isomorphism between\nthem. -/\n@[simps]\ndef Iso.mk {α β : FinBoolAlg.{u}} (e : α ≃o β) : α ≅ β where\n  hom := (e : BoundedLatticeHom α β)\n  inv := (e.symm : BoundedLatticeHom β α)\n  hom_inv_id := by ext; exact e.symm_apply_apply _\n  inv_hom_id := by ext; exact e.apply_symm_apply _\n\n"}
{"name":"FinBoolAlg.dual_map","module":"Mathlib.Order.Category.FinBoolAlg","initialProofState":"x✝¹ x✝ : FinBoolAlg\na : BoundedLatticeHom ↑x✝¹.toBoolAlg.toBddDistLat.toBddLat.toLat ↑x✝.toBoolAlg.toBddDistLat.toBddLat.toLat\n⊢ Eq (FinBoolAlg.dual.map a) (BoundedLatticeHom.dual a)","decl":"/-- `OrderDual` as a functor. -/\n@[simps]\ndef dual : FinBoolAlg ⥤ FinBoolAlg where\n  obj X := of Xᵒᵈ\n  map {_ _} := BoundedLatticeHom.dual\n\n"}
{"name":"FinBoolAlg.dual_obj","module":"Mathlib.Order.Category.FinBoolAlg","initialProofState":"X : FinBoolAlg\n⊢ Eq (FinBoolAlg.dual.obj X) (FinBoolAlg.of (OrderDual ↑X.toBoolAlg))","decl":"/-- `OrderDual` as a functor. -/\n@[simps]\ndef dual : FinBoolAlg ⥤ FinBoolAlg where\n  obj X := of Xᵒᵈ\n  map {_ _} := BoundedLatticeHom.dual\n\n"}
{"name":"FinBoolAlg.dualEquiv_inverse","module":"Mathlib.Order.Category.FinBoolAlg","initialProofState":"⊢ Eq FinBoolAlg.dualEquiv.inverse FinBoolAlg.dual","decl":"/-- The equivalence between `FinBoolAlg` and itself induced by `OrderDual` both ways. -/\n@[simps functor inverse]\ndef dualEquiv : FinBoolAlg ≌ FinBoolAlg where\n  functor := dual\n  inverse := dual\n  unitIso := NatIso.ofComponents fun X => Iso.mk <| OrderIso.dualDual X\n  counitIso := NatIso.ofComponents fun X => Iso.mk <| OrderIso.dualDual X\n\n"}
{"name":"FinBoolAlg.dualEquiv_functor","module":"Mathlib.Order.Category.FinBoolAlg","initialProofState":"⊢ Eq FinBoolAlg.dualEquiv.functor FinBoolAlg.dual","decl":"/-- The equivalence between `FinBoolAlg` and itself induced by `OrderDual` both ways. -/\n@[simps functor inverse]\ndef dualEquiv : FinBoolAlg ≌ FinBoolAlg where\n  functor := dual\n  inverse := dual\n  unitIso := NatIso.ofComponents fun X => Iso.mk <| OrderIso.dualDual X\n  counitIso := NatIso.ofComponents fun X => Iso.mk <| OrderIso.dualDual X\n\n"}
{"name":"finBoolAlg_dual_comp_forget_to_finBddDistLat","module":"Mathlib.Order.Category.FinBoolAlg","initialProofState":"⊢ Eq (FinBoolAlg.dual.comp (CategoryTheory.forget₂ FinBoolAlg FinBddDistLat)) ((CategoryTheory.forget₂ FinBoolAlg FinBddDistLat).comp FinBddDistLat.dual)","decl":"theorem finBoolAlg_dual_comp_forget_to_finBddDistLat :\n    FinBoolAlg.dual ⋙ forget₂ FinBoolAlg FinBddDistLat =\n      forget₂ FinBoolAlg FinBddDistLat ⋙ FinBddDistLat.dual :=\n  rfl\n\n"}
{"name":"fintypeToFinBoolAlgOp_obj","module":"Mathlib.Order.Category.FinBoolAlg","initialProofState":"X : FintypeCat\n⊢ Eq (fintypeToFinBoolAlgOp.obj X) { unop := FinBoolAlg.of (Set ↑X) }","decl":"/-- The powerset functor. `Set` as a functor. -/\n@[simps]\ndef fintypeToFinBoolAlgOp : FintypeCat ⥤ FinBoolAlgᵒᵖ where\n  obj X := op <| FinBoolAlg.of (Set X)\n  map {X Y} f :=\n    Quiver.Hom.op <| (CompleteLatticeHom.setPreimage f : BoundedLatticeHom (Set Y) (Set X))\n"}
{"name":"fintypeToFinBoolAlgOp_map","module":"Mathlib.Order.Category.FinBoolAlg","initialProofState":"X Y : FintypeCat\nf : Quiver.Hom X Y\n⊢ Eq (fintypeToFinBoolAlgOp.map f)\n    (Quiver.Hom.op\n      (let __src := { toFun := ⇑(CompleteLatticeHom.setPreimage f), map_sup' := ⋯, map_inf' := ⋯ };\n      { toFun := ⇑(CompleteLatticeHom.setPreimage f), map_sup' := ⋯, map_inf' := ⋯, map_top' := ⋯, map_bot' := ⋯ }))","decl":"/-- The powerset functor. `Set` as a functor. -/\n@[simps]\ndef fintypeToFinBoolAlgOp : FintypeCat ⥤ FinBoolAlgᵒᵖ where\n  obj X := op <| FinBoolAlg.of (Set X)\n  map {X Y} f :=\n    Quiver.Hom.op <| (CompleteLatticeHom.setPreimage f : BoundedLatticeHom (Set Y) (Set X))\n"}
