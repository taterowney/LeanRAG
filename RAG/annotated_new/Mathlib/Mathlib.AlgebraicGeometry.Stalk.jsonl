{"name":"AlgebraicGeometry.IsAffineOpen.fromSpecStalk_eq","module":"Mathlib.AlgebraicGeometry.Stalk","initialProofState":"X : AlgebraicGeometry.Scheme\nU V : X.Opens\nhU : AlgebraicGeometry.IsAffineOpen U\nhV : AlgebraicGeometry.IsAffineOpen V\nx : ↑↑X.toPresheafedSpace\nhxU : Membership.mem U x\nhxV : Membership.mem V x\n⊢ Eq (hU.fromSpecStalk hxU) (hV.fromSpecStalk hxV)","decl":"/--\nThe morphism from `Spec(O_x)` to `X` given by `IsAffineOpen.fromSpec` does not depend on the affine\nopen neighborhood of `x` we choose.\n-/\ntheorem IsAffineOpen.fromSpecStalk_eq (x : X) (hxU : x ∈ U) (hxV : x ∈ V) :\n    hU.fromSpecStalk hxU = hV.fromSpecStalk hxV := by\n  obtain ⟨U', h₁, h₂, h₃ : U' ≤ U ⊓ V⟩ :=\n    Opens.isBasis_iff_nbhd.mp (isBasis_affine_open X) (show x ∈ U ⊓ V from ⟨hxU, hxV⟩)\n  transitivity fromSpecStalk h₁ h₂\n  · delta fromSpecStalk\n    rw [← hU.map_fromSpec h₁ (homOfLE <| h₃.trans inf_le_left).op]\n    erw [← Scheme.Spec_map (X.presheaf.map _).op, ← Scheme.Spec_map (X.presheaf.germ _ x h₂).op]\n    rw [← Functor.map_comp_assoc, ← op_comp, TopCat.Presheaf.germ_res, Scheme.Spec_map,\n      Quiver.Hom.unop_op]\n  · delta fromSpecStalk\n    rw [← hV.map_fromSpec h₁ (homOfLE <| h₃.trans inf_le_right).op]\n    erw [← Scheme.Spec_map (X.presheaf.map _).op, ← Scheme.Spec_map (X.presheaf.germ _ x h₂).op]\n    rw [← Functor.map_comp_assoc, ← op_comp, TopCat.Presheaf.germ_res, Scheme.Spec_map,\n      Quiver.Hom.unop_op]\n\n"}
{"name":"AlgebraicGeometry.instOverSpecStalkCommRingCatPresheaf_over","module":"Mathlib.AlgebraicGeometry.Stalk","initialProofState":"X : AlgebraicGeometry.Scheme\nx : ↑↑X.toPresheafedSpace\n⊢ Eq (CategoryTheory.over (AlgebraicGeometry.Spec (X.presheaf.stalk x)) X inferInstance) (X.fromSpecStalk x)","decl":"@[simps over] noncomputable\ninstance (X : Scheme.{u}) (x : X) : (Spec (X.presheaf.stalk x)).Over X := ⟨X.fromSpecStalk x⟩\n\n"}
{"name":"AlgebraicGeometry.instCanonicallyOver_over","module":"Mathlib.AlgebraicGeometry.Stalk","initialProofState":"X : AlgebraicGeometry.Scheme\nx : ↑↑X.toPresheafedSpace\n⊢ Eq (CategoryTheory.over (AlgebraicGeometry.Spec (X.presheaf.stalk x)) X inferInstance) (X.fromSpecStalk x)","decl":"@[simps! over] noncomputable\ninstance (X : Scheme.{u}) (x : X) : (Spec (X.presheaf.stalk x)).CanonicallyOver X where\n\n"}
{"name":"AlgebraicGeometry.IsAffineOpen.fromSpecStalk_eq_fromSpecStalk","module":"Mathlib.AlgebraicGeometry.Stalk","initialProofState":"X : AlgebraicGeometry.Scheme\nU : X.Opens\nhU : AlgebraicGeometry.IsAffineOpen U\nx : ↑↑X.toPresheafedSpace\nhxU : Membership.mem U x\n⊢ Eq (hU.fromSpecStalk hxU) (X.fromSpecStalk x)","decl":"@[simp]\ntheorem IsAffineOpen.fromSpecStalk_eq_fromSpecStalk {x : X} (hxU : x ∈ U) :\n    hU.fromSpecStalk hxU = X.fromSpecStalk x := fromSpecStalk_eq ..\n\n"}
{"name":"AlgebraicGeometry.IsAffineOpen.fromSpecStalk_isPreimmersion","module":"Mathlib.AlgebraicGeometry.Stalk","initialProofState":"X : AlgebraicGeometry.Scheme\nU : TopologicalSpace.Opens ↑↑X.toPresheafedSpace\nhU : AlgebraicGeometry.IsAffineOpen U\nx : ↑↑X.toPresheafedSpace\nhx : Membership.mem U x\n⊢ AlgebraicGeometry.IsPreimmersion (hU.fromSpecStalk hx)","decl":"instance IsAffineOpen.fromSpecStalk_isPreimmersion {X : Scheme.{u}} {U : Opens X}\n    (hU : IsAffineOpen U) (x : X) (hx : x ∈ U) : IsPreimmersion (hU.fromSpecStalk hx) := by\n  dsimp [IsAffineOpen.fromSpecStalk]\n  haveI : IsPreimmersion (Spec.map (X.presheaf.germ U x hx)) :=\n    letI : Algebra Γ(X, U) (X.presheaf.stalk x) := (X.presheaf.germ U x hx).hom.toAlgebra\n    haveI := hU.isLocalization_stalk ⟨x, hx⟩\n    IsPreimmersion.of_isLocalization (R := Γ(X, U)) (S := X.presheaf.stalk x)\n      (hU.primeIdealOf ⟨x, hx⟩).asIdeal.primeCompl\n  apply IsPreimmersion.comp\n\n"}
{"name":"AlgebraicGeometry.instIsPreimmersionFromSpecStalk","module":"Mathlib.AlgebraicGeometry.Stalk","initialProofState":"X : AlgebraicGeometry.Scheme\nx : ↑↑X.toPresheafedSpace\n⊢ AlgebraicGeometry.IsPreimmersion (X.fromSpecStalk x)","decl":"instance {X : Scheme.{u}} (x : X) : IsPreimmersion (X.fromSpecStalk x) :=\n  IsAffineOpen.fromSpecStalk_isPreimmersion _ _ _\n\n"}
{"name":"AlgebraicGeometry.IsAffineOpen.fromSpecStalk_closedPoint","module":"Mathlib.AlgebraicGeometry.Stalk","initialProofState":"X : AlgebraicGeometry.Scheme\nU : TopologicalSpace.Opens ↑↑X.toPresheafedSpace\nhU : AlgebraicGeometry.IsAffineOpen U\nx : ↑↑X.toPresheafedSpace\nhxU : Membership.mem U x\n⊢ Eq ((hU.fromSpecStalk hxU).base (IsLocalRing.closedPoint ↑(X.presheaf.stalk x))) x","decl":"lemma IsAffineOpen.fromSpecStalk_closedPoint {U : Opens X} (hU : IsAffineOpen U)\n    {x : X} (hxU : x ∈ U) :\n    (hU.fromSpecStalk hxU).base (closedPoint (X.presheaf.stalk x)) = x := by\n  rw [IsAffineOpen.fromSpecStalk, Scheme.comp_base_apply]\n  rw [← hU.primeIdealOf_eq_map_closedPoint ⟨x, hxU⟩, hU.fromSpec_primeIdealOf ⟨x, hxU⟩]\n\n"}
{"name":"AlgebraicGeometry.Scheme.fromSpecStalk_closedPoint","module":"Mathlib.AlgebraicGeometry.Stalk","initialProofState":"X : AlgebraicGeometry.Scheme\nx : ↑↑X.toPresheafedSpace\n⊢ Eq ((X.fromSpecStalk x).base (IsLocalRing.closedPoint ↑(X.presheaf.stalk x))) x","decl":"@[simp]\nlemma fromSpecStalk_closedPoint {x : X} :\n    (X.fromSpecStalk x).base (closedPoint (X.presheaf.stalk x)) = x :=\n  IsAffineOpen.fromSpecStalk_closedPoint _ _\n\n"}
{"name":"AlgebraicGeometry.Scheme.fromSpecStalk_app","module":"Mathlib.AlgebraicGeometry.Stalk","initialProofState":"X : AlgebraicGeometry.Scheme\nU : X.Opens\nx : ↑↑X.toPresheafedSpace\nhxU : Membership.mem U x\n⊢ Eq (AlgebraicGeometry.Scheme.Hom.app (X.fromSpecStalk x) U) (CategoryTheory.CategoryStruct.comp (X.presheaf.germ U x hxU) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.ΓSpecIso (X.presheaf.stalk x)).inv ((AlgebraicGeometry.Spec (X.presheaf.stalk x)).presheaf.map (CategoryTheory.homOfLE ⋯).op)))","decl":"lemma fromSpecStalk_app {x : X} (hxU : x ∈ U) :\n    (X.fromSpecStalk x).app U =\n      X.presheaf.germ U x hxU ≫\n        (ΓSpecIso (X.presheaf.stalk x)).inv ≫\n          (Spec (X.presheaf.stalk x)).presheaf.map (homOfLE le_top).op := by\n  obtain ⟨_, ⟨V : X.Opens, hV, rfl⟩, hxV, hVU⟩ := (isBasis_affine_open X).exists_subset_of_mem_open\n    hxU U.2\n  rw [← hV.fromSpecStalk_eq_fromSpecStalk hxV, IsAffineOpen.fromSpecStalk, Scheme.comp_app,\n    hV.fromSpec_app_of_le _ hVU, ← X.presheaf.germ_res (homOfLE hVU) x hxV]\n  simp [Category.assoc, ← ΓSpecIso_inv_naturality_assoc]\n\n"}
{"name":"AlgebraicGeometry.Scheme.fromSpecStalk_appTop","module":"Mathlib.AlgebraicGeometry.Stalk","initialProofState":"X : AlgebraicGeometry.Scheme\nx : ↑↑X.toPresheafedSpace\n⊢ Eq (AlgebraicGeometry.Scheme.Hom.appTop (X.fromSpecStalk x)) (CategoryTheory.CategoryStruct.comp (X.presheaf.germ Top.top x trivial) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.ΓSpecIso (X.presheaf.stalk x)).inv ((AlgebraicGeometry.Spec (X.presheaf.stalk x)).presheaf.map (CategoryTheory.homOfLE ⋯).op)))","decl":"lemma fromSpecStalk_appTop {x : X} :\n    (X.fromSpecStalk x).appTop =\n      X.presheaf.germ ⊤ x trivial ≫\n        (ΓSpecIso (X.presheaf.stalk x)).inv ≫\n          (Spec (X.presheaf.stalk x)).presheaf.map (homOfLE le_top).op :=\n  fromSpecStalk_app ..\n\n"}
{"name":"AlgebraicGeometry.Scheme.Spec_map_stalkSpecializes_fromSpecStalk_assoc","module":"Mathlib.AlgebraicGeometry.Stalk","initialProofState":"X : AlgebraicGeometry.Scheme\nx y : ↑↑X.toPresheafedSpace\nh✝ : Specializes x y\nZ : AlgebraicGeometry.Scheme\nh : Quiver.Hom X Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Spec.map (X.presheaf.stalkSpecializes h✝)) (CategoryTheory.CategoryStruct.comp (X.fromSpecStalk y) h)) (CategoryTheory.CategoryStruct.comp (X.fromSpecStalk x) h)","decl":"@[reassoc (attr := simp)]\nlemma Spec_map_stalkSpecializes_fromSpecStalk {x y : X} (h : x ⤳ y) :\n    Spec.map (X.presheaf.stalkSpecializes h) ≫ X.fromSpecStalk y = X.fromSpecStalk x := by\n  obtain ⟨_, ⟨U, hU, rfl⟩, hyU, -⟩ :=\n    (isBasis_affine_open X).exists_subset_of_mem_open (Set.mem_univ y) isOpen_univ\n  have hxU : x ∈ U := h.mem_open U.2 hyU\n  rw [← hU.fromSpecStalk_eq_fromSpecStalk hyU, ← hU.fromSpecStalk_eq_fromSpecStalk hxU,\n    IsAffineOpen.fromSpecStalk, IsAffineOpen.fromSpecStalk, ← Category.assoc, ← Spec.map_comp,\n    TopCat.Presheaf.germ_stalkSpecializes]\n\n"}
{"name":"AlgebraicGeometry.Scheme.Spec_map_stalkSpecializes_fromSpecStalk","module":"Mathlib.AlgebraicGeometry.Stalk","initialProofState":"X : AlgebraicGeometry.Scheme\nx y : ↑↑X.toPresheafedSpace\nh : Specializes x y\n⊢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Spec.map (X.presheaf.stalkSpecializes h)) (X.fromSpecStalk y)) (X.fromSpecStalk x)","decl":"@[reassoc (attr := simp)]\nlemma Spec_map_stalkSpecializes_fromSpecStalk {x y : X} (h : x ⤳ y) :\n    Spec.map (X.presheaf.stalkSpecializes h) ≫ X.fromSpecStalk y = X.fromSpecStalk x := by\n  obtain ⟨_, ⟨U, hU, rfl⟩, hyU, -⟩ :=\n    (isBasis_affine_open X).exists_subset_of_mem_open (Set.mem_univ y) isOpen_univ\n  have hxU : x ∈ U := h.mem_open U.2 hyU\n  rw [← hU.fromSpecStalk_eq_fromSpecStalk hyU, ← hU.fromSpecStalk_eq_fromSpecStalk hxU,\n    IsAffineOpen.fromSpecStalk, IsAffineOpen.fromSpecStalk, ← Category.assoc, ← Spec.map_comp,\n    TopCat.Presheaf.germ_stalkSpecializes]\n\n"}
{"name":"AlgebraicGeometry.Scheme.instIsOverMapStalkSpecializesCommRingCatPresheaf","module":"Mathlib.AlgebraicGeometry.Stalk","initialProofState":"X : AlgebraicGeometry.Scheme\nx y : ↑↑X.toPresheafedSpace\nh : Specializes x y\n⊢ AlgebraicGeometry.Scheme.Hom.IsOver (AlgebraicGeometry.Spec.map (X.presheaf.stalkSpecializes h)) X","decl":"instance {x y : X} (h : x ⤳ y) : (Spec.map (X.presheaf.stalkSpecializes h)).IsOver X where\n\n"}
{"name":"AlgebraicGeometry.Scheme.Spec_map_stalkMap_fromSpecStalk","module":"Mathlib.AlgebraicGeometry.Stalk","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nx : ↑↑X.toPresheafedSpace\n⊢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Spec.map (AlgebraicGeometry.Scheme.Hom.stalkMap f x)) (Y.fromSpecStalk (f.base x))) (CategoryTheory.CategoryStruct.comp (X.fromSpecStalk x) f)","decl":"@[reassoc (attr := simp)]\nlemma Spec_map_stalkMap_fromSpecStalk {x} :\n    Spec.map (f.stalkMap x) ≫ Y.fromSpecStalk _ = X.fromSpecStalk x ≫ f := by\n  obtain ⟨_, ⟨U, hU, rfl⟩, hxU, -⟩ := (isBasis_affine_open Y).exists_subset_of_mem_open\n    (Set.mem_univ (f.base x)) isOpen_univ\n  obtain ⟨_, ⟨V, hV, rfl⟩, hxV, hVU⟩ := (isBasis_affine_open X).exists_subset_of_mem_open\n    hxU (f ⁻¹ᵁ U).2\n  rw [← hU.fromSpecStalk_eq_fromSpecStalk hxU, ← hV.fromSpecStalk_eq_fromSpecStalk hxV,\n    IsAffineOpen.fromSpecStalk, ← Spec.map_comp_assoc, Scheme.stalkMap_germ f _ x hxU,\n    IsAffineOpen.fromSpecStalk, Spec.map_comp_assoc, ← X.presheaf.germ_res (homOfLE hVU) x hxV,\n    Spec.map_comp_assoc, Category.assoc, ← Spec.map_comp_assoc (f.app _),\n      Hom.app_eq_appLE, Hom.appLE_map, IsAffineOpen.Spec_map_appLE_fromSpec]\n\n"}
{"name":"AlgebraicGeometry.Scheme.Spec_map_stalkMap_fromSpecStalk_assoc","module":"Mathlib.AlgebraicGeometry.Stalk","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nx : ↑↑X.toPresheafedSpace\nZ : AlgebraicGeometry.Scheme\nh : Quiver.Hom Y Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Spec.map (AlgebraicGeometry.Scheme.Hom.stalkMap f x)) (CategoryTheory.CategoryStruct.comp (Y.fromSpecStalk (f.base x)) h)) (CategoryTheory.CategoryStruct.comp (X.fromSpecStalk x) (CategoryTheory.CategoryStruct.comp f h))","decl":"@[reassoc (attr := simp)]\nlemma Spec_map_stalkMap_fromSpecStalk {x} :\n    Spec.map (f.stalkMap x) ≫ Y.fromSpecStalk _ = X.fromSpecStalk x ≫ f := by\n  obtain ⟨_, ⟨U, hU, rfl⟩, hxU, -⟩ := (isBasis_affine_open Y).exists_subset_of_mem_open\n    (Set.mem_univ (f.base x)) isOpen_univ\n  obtain ⟨_, ⟨V, hV, rfl⟩, hxV, hVU⟩ := (isBasis_affine_open X).exists_subset_of_mem_open\n    hxU (f ⁻¹ᵁ U).2\n  rw [← hU.fromSpecStalk_eq_fromSpecStalk hxU, ← hV.fromSpecStalk_eq_fromSpecStalk hxV,\n    IsAffineOpen.fromSpecStalk, ← Spec.map_comp_assoc, Scheme.stalkMap_germ f _ x hxU,\n    IsAffineOpen.fromSpecStalk, Spec.map_comp_assoc, ← X.presheaf.germ_res (homOfLE hVU) x hxV,\n    Spec.map_comp_assoc, Category.assoc, ← Spec.map_comp_assoc (f.app _),\n      Hom.app_eq_appLE, Hom.appLE_map, IsAffineOpen.Spec_map_appLE_fromSpec]\n\n"}
{"name":"AlgebraicGeometry.Scheme.instIsOverMapStalkMapOverInferInstanceOverClass","module":"Mathlib.AlgebraicGeometry.Stalk","initialProofState":"X Y : AlgebraicGeometry.Scheme\ninst✝ : X.Over Y\nx : ↑↑X.toPresheafedSpace\n⊢ AlgebraicGeometry.Scheme.Hom.IsOver (AlgebraicGeometry.Spec.map (AlgebraicGeometry.Scheme.Hom.stalkMap (CategoryTheory.over X Y inferInstance) x)) Y","decl":"instance [X.Over Y] {x} : Spec.map ((X ↘ Y).stalkMap x) |>.IsOver Y where\n\n"}
{"name":"AlgebraicGeometry.Scheme.Spec_fromSpecStalk","module":"Mathlib.AlgebraicGeometry.Stalk","initialProofState":"R : CommRingCat\nx : ↑↑(AlgebraicGeometry.Spec R).toPresheafedSpace\n⊢ Eq ((AlgebraicGeometry.Spec R).fromSpecStalk x) (AlgebraicGeometry.Spec.map (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.ΓSpecIso R).inv ((AlgebraicGeometry.Spec R).presheaf.germ Top.top x trivial)))","decl":"lemma Spec_fromSpecStalk (R : CommRingCat) (x) :\n    (Spec R).fromSpecStalk x =\n      Spec.map ((ΓSpecIso R).inv ≫ (Spec R).presheaf.germ ⊤ x trivial) := by\n  rw [← (isAffineOpen_top (Spec R)).fromSpecStalk_eq_fromSpecStalk (x := x) trivial,\n    IsAffineOpen.fromSpecStalk, IsAffineOpen.fromSpec_top, isoSpec_Spec_inv,\n    ← Spec.map_comp]\n\n-- This is not a simp lemma to respect the abstraction boundaries\n"}
{"name":"AlgebraicGeometry.Scheme.Spec_fromSpecStalk'","module":"Mathlib.AlgebraicGeometry.Stalk","initialProofState":"R : CommRingCat\nx : ↑↑(AlgebraicGeometry.Spec R).toPresheafedSpace\n⊢ Eq ((AlgebraicGeometry.Spec R).fromSpecStalk x) (AlgebraicGeometry.Spec.map (AlgebraicGeometry.StructureSheaf.toStalk (↑R) x))","decl":"/-- A variant of `Spec_fromSpecStalk` that breaks abstraction boundaries. -/\nlemma Spec_fromSpecStalk' (R : CommRingCat) (x) :\n    (Spec R).fromSpecStalk x = Spec.map (StructureSheaf.toStalk R _) :=\n  Spec_fromSpecStalk _ _\n\n"}
{"name":"AlgebraicGeometry.Scheme.range_fromSpecStalk","module":"Mathlib.AlgebraicGeometry.Stalk","initialProofState":"X : AlgebraicGeometry.Scheme\nx : ↑↑X.toPresheafedSpace\n⊢ Eq (Set.range ⇑(X.fromSpecStalk x).base) (setOf fun y => Specializes y x)","decl":"@[stacks 01J7]\nlemma range_fromSpecStalk {x : X} :\n    Set.range (X.fromSpecStalk x).base = { y | y ⤳ x } := by\n  ext y\n  constructor\n  · rintro ⟨y, rfl⟩\n    exact ((IsLocalRing.specializes_closedPoint y).map (X.fromSpecStalk x).base.2).trans\n      (specializes_of_eq fromSpecStalk_closedPoint)\n  · rintro (hy : y ⤳ x)\n    have := fromSpecStalk_closedPoint (x := y)\n    rw [← Spec_map_stalkSpecializes_fromSpecStalk hy] at this\n    exact ⟨_, this⟩\n\n"}
{"name":"AlgebraicGeometry.Scheme.Opens.fromSpecStalkOfMem_ι_assoc","module":"Mathlib.AlgebraicGeometry.Stalk","initialProofState":"X : AlgebraicGeometry.Scheme\nU : X.Opens\nx : ↑↑X.toPresheafedSpace\nhxU : Membership.mem U x\nZ : AlgebraicGeometry.Scheme\nh : Quiver.Hom X Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (U.fromSpecStalkOfMem x hxU) (CategoryTheory.CategoryStruct.comp U.ι h)) (CategoryTheory.CategoryStruct.comp (X.fromSpecStalk x) h)","decl":"@[reassoc (attr := simp)]\nlemma Opens.fromSpecStalkOfMem_ι {X : Scheme.{u}} (U : X.Opens) (x : X) (hxU : x ∈ U) :\n    U.fromSpecStalkOfMem x hxU ≫ U.ι = X.fromSpecStalk x := by\n  simp only [Opens.fromSpecStalkOfMem, Spec.map_inv, Category.assoc, IsIso.inv_comp_eq]\n  exact (Scheme.Spec_map_stalkMap_fromSpecStalk U.ι (x := ⟨x, hxU⟩)).symm\n\n"}
{"name":"AlgebraicGeometry.Scheme.Opens.fromSpecStalkOfMem_ι","module":"Mathlib.AlgebraicGeometry.Stalk","initialProofState":"X : AlgebraicGeometry.Scheme\nU : X.Opens\nx : ↑↑X.toPresheafedSpace\nhxU : Membership.mem U x\n⊢ Eq (CategoryTheory.CategoryStruct.comp (U.fromSpecStalkOfMem x hxU) U.ι) (X.fromSpecStalk x)","decl":"@[reassoc (attr := simp)]\nlemma Opens.fromSpecStalkOfMem_ι {X : Scheme.{u}} (U : X.Opens) (x : X) (hxU : x ∈ U) :\n    U.fromSpecStalkOfMem x hxU ≫ U.ι = X.fromSpecStalk x := by\n  simp only [Opens.fromSpecStalkOfMem, Spec.map_inv, Category.assoc, IsIso.inv_comp_eq]\n  exact (Scheme.Spec_map_stalkMap_fromSpecStalk U.ι (x := ⟨x, hxU⟩)).symm\n\n"}
{"name":"AlgebraicGeometry.Scheme.instIsOverFromSpecStalkOfMem","module":"Mathlib.AlgebraicGeometry.Stalk","initialProofState":"X : AlgebraicGeometry.Scheme\nU : X.Opens\nx : ↑↑X.toPresheafedSpace\nhxU : Membership.mem U x\n⊢ AlgebraicGeometry.Scheme.Hom.IsOver (U.fromSpecStalkOfMem x hxU) X","decl":"instance {X : Scheme.{u}} (U : X.Opens) (x : X) (hxU : x ∈ U) :\n    (U.fromSpecStalkOfMem x hxU).IsOver X where\n\n"}
{"name":"AlgebraicGeometry.Scheme.fromSpecStalk_toSpecΓ_assoc","module":"Mathlib.AlgebraicGeometry.Stalk","initialProofState":"X : AlgebraicGeometry.Scheme\nx : ↑↑X.toPresheafedSpace\nZ : AlgebraicGeometry.Scheme\nh : Quiver.Hom (AlgebraicGeometry.Spec (X.presheaf.obj { unop := Top.top })) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (X.fromSpecStalk x) (CategoryTheory.CategoryStruct.comp X.toSpecΓ h)) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Spec.map (X.presheaf.germ Top.top x trivial)) h)","decl":"@[reassoc]\nlemma fromSpecStalk_toSpecΓ (X : Scheme.{u}) (x : X) :\n    X.fromSpecStalk x ≫ X.toSpecΓ = Spec.map (X.presheaf.germ ⊤ x trivial) := by\n  rw [Scheme.toSpecΓ_naturality, ← SpecMap_ΓSpecIso_hom, ← Spec.map_comp,\n    Scheme.fromSpecStalk_appTop]\n  simp\n\n"}
{"name":"AlgebraicGeometry.Scheme.fromSpecStalk_toSpecΓ","module":"Mathlib.AlgebraicGeometry.Stalk","initialProofState":"X : AlgebraicGeometry.Scheme\nx : ↑↑X.toPresheafedSpace\n⊢ Eq (CategoryTheory.CategoryStruct.comp (X.fromSpecStalk x) X.toSpecΓ) (AlgebraicGeometry.Spec.map (X.presheaf.germ Top.top x trivial))","decl":"@[reassoc]\nlemma fromSpecStalk_toSpecΓ (X : Scheme.{u}) (x : X) :\n    X.fromSpecStalk x ≫ X.toSpecΓ = Spec.map (X.presheaf.germ ⊤ x trivial) := by\n  rw [Scheme.toSpecΓ_naturality, ← SpecMap_ΓSpecIso_hom, ← Spec.map_comp,\n    Scheme.fromSpecStalk_appTop]\n  simp\n\n"}
{"name":"AlgebraicGeometry.Scheme.Opens.fromSpecStalkOfMem_toSpecΓ_assoc","module":"Mathlib.AlgebraicGeometry.Stalk","initialProofState":"X : AlgebraicGeometry.Scheme\nU : X.Opens\nx : ↑↑X.toPresheafedSpace\nhxU : Membership.mem U x\nZ : AlgebraicGeometry.Scheme\nh : Quiver.Hom (AlgebraicGeometry.Spec (X.presheaf.obj { unop := U })) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (U.fromSpecStalkOfMem x hxU) (CategoryTheory.CategoryStruct.comp U.toSpecΓ h)) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Spec.map (X.presheaf.germ U x hxU)) h)","decl":"@[reassoc (attr := simp)]\nlemma Opens.fromSpecStalkOfMem_toSpecΓ {X : Scheme.{u}} (U : X.Opens) (x : X) (hxU : x ∈ U) :\n    U.fromSpecStalkOfMem x hxU ≫ U.toSpecΓ = Spec.map (X.presheaf.germ U x hxU) := by\n  rw [fromSpecStalkOfMem, Opens.toSpecΓ, Category.assoc, fromSpecStalk_toSpecΓ_assoc,\n    ← Spec.map_comp, ← Spec.map_comp]\n  congr 1\n  rw [IsIso.comp_inv_eq, Iso.inv_comp_eq]\n  erw [stalkMap_germ U.ι U ⟨x, hxU⟩]\n  rw [Opens.ι_app, Opens.topIso_hom, ← Functor.map_comp_assoc]\n  exact (U.toScheme.presheaf.germ_res (homOfLE le_top) ⟨x, hxU⟩ (U := U.ι ⁻¹ᵁ U) hxU).symm\n\n"}
{"name":"AlgebraicGeometry.Scheme.Opens.fromSpecStalkOfMem_toSpecΓ","module":"Mathlib.AlgebraicGeometry.Stalk","initialProofState":"X : AlgebraicGeometry.Scheme\nU : X.Opens\nx : ↑↑X.toPresheafedSpace\nhxU : Membership.mem U x\n⊢ Eq (CategoryTheory.CategoryStruct.comp (U.fromSpecStalkOfMem x hxU) U.toSpecΓ) (AlgebraicGeometry.Spec.map (X.presheaf.germ U x hxU))","decl":"@[reassoc (attr := simp)]\nlemma Opens.fromSpecStalkOfMem_toSpecΓ {X : Scheme.{u}} (U : X.Opens) (x : X) (hxU : x ∈ U) :\n    U.fromSpecStalkOfMem x hxU ≫ U.toSpecΓ = Spec.map (X.presheaf.germ U x hxU) := by\n  rw [fromSpecStalkOfMem, Opens.toSpecΓ, Category.assoc, fromSpecStalk_toSpecΓ_assoc,\n    ← Spec.map_comp, ← Spec.map_comp]\n  congr 1\n  rw [IsIso.comp_inv_eq, Iso.inv_comp_eq]\n  erw [stalkMap_germ U.ι U ⟨x, hxU⟩]\n  rw [Opens.ι_app, Opens.topIso_hom, ← Functor.map_comp_assoc]\n  exact (U.toScheme.presheaf.germ_res (homOfLE le_top) ⟨x, hxU⟩ (U := U.ι ⁻¹ᵁ U) hxU).symm\n\n"}
{"name":"AlgebraicGeometry.stalkClosedPointIso_inv","module":"Mathlib.AlgebraicGeometry.Stalk","initialProofState":"R : CommRingCat\ninst✝ : IsLocalRing ↑R\n⊢ Eq (AlgebraicGeometry.stalkClosedPointIso R).inv (AlgebraicGeometry.StructureSheaf.toStalk (↑R) (IsLocalRing.closedPoint ↑R))","decl":"lemma stalkClosedPointIso_inv :\n    (stalkClosedPointIso R).inv = StructureSheaf.toStalk R _ := by\n  ext x\n  exact StructureSheaf.localizationToStalk_of _ _ _\n\n"}
{"name":"AlgebraicGeometry.ΓSpecIso_hom_stalkClosedPointIso_inv","module":"Mathlib.AlgebraicGeometry.Stalk","initialProofState":"R : CommRingCat\ninst✝ : IsLocalRing ↑R\n⊢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.ΓSpecIso R).hom (AlgebraicGeometry.stalkClosedPointIso R).inv) ((AlgebraicGeometry.Spec R).presheaf.germ Top.top (IsLocalRing.closedPoint ↑R) trivial)","decl":"lemma ΓSpecIso_hom_stalkClosedPointIso_inv :\n    (Scheme.ΓSpecIso R).hom ≫ (stalkClosedPointIso R).inv =\n      (Spec R).presheaf.germ ⊤ (closedPoint _) trivial := by\n  rw [stalkClosedPointIso_inv, ← Iso.eq_inv_comp]\n  rfl\n\n"}
{"name":"AlgebraicGeometry.germ_stalkClosedPointIso_hom","module":"Mathlib.AlgebraicGeometry.Stalk","initialProofState":"R : CommRingCat\ninst✝ : IsLocalRing ↑R\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((AlgebraicGeometry.Spec R).presheaf.germ Top.top (IsLocalRing.closedPoint ↑R) trivial) (AlgebraicGeometry.stalkClosedPointIso R).hom) (AlgebraicGeometry.Scheme.ΓSpecIso R).hom","decl":"@[reassoc (attr := simp)]\nlemma germ_stalkClosedPointIso_hom :\n    (Spec R).presheaf.germ ⊤ (closedPoint _) trivial ≫ (stalkClosedPointIso R).hom =\n      (Scheme.ΓSpecIso R).hom := by\n  rw [← ΓSpecIso_hom_stalkClosedPointIso_inv, Category.assoc, Iso.inv_hom_id, Category.comp_id]\n\n"}
{"name":"AlgebraicGeometry.germ_stalkClosedPointIso_hom_assoc","module":"Mathlib.AlgebraicGeometry.Stalk","initialProofState":"R : CommRingCat\ninst✝ : IsLocalRing ↑R\nZ : CommRingCat\nh : Quiver.Hom R Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((AlgebraicGeometry.Spec R).presheaf.germ Top.top (IsLocalRing.closedPoint ↑R) trivial) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.stalkClosedPointIso R).hom h)) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.ΓSpecIso R).hom h)","decl":"@[reassoc (attr := simp)]\nlemma germ_stalkClosedPointIso_hom :\n    (Spec R).presheaf.germ ⊤ (closedPoint _) trivial ≫ (stalkClosedPointIso R).hom =\n      (Scheme.ΓSpecIso R).hom := by\n  rw [← ΓSpecIso_hom_stalkClosedPointIso_inv, Category.assoc, Iso.inv_hom_id, Category.comp_id]\n\n"}
{"name":"AlgebraicGeometry.Spec_stalkClosedPointIso","module":"Mathlib.AlgebraicGeometry.Stalk","initialProofState":"R : CommRingCat\ninst✝ : IsLocalRing ↑R\n⊢ Eq (AlgebraicGeometry.Spec.map (AlgebraicGeometry.stalkClosedPointIso R).inv) ((AlgebraicGeometry.Spec R).fromSpecStalk (IsLocalRing.closedPoint ↑R))","decl":"lemma Spec_stalkClosedPointIso :\n    Spec.map (stalkClosedPointIso R).inv = (Spec R).fromSpecStalk (closedPoint R) := by\n  rw [stalkClosedPointIso_inv, Scheme.Spec_fromSpecStalk']\n\n"}
{"name":"AlgebraicGeometry.Scheme.isLocalHom_stalkClosedPointTo","module":"Mathlib.AlgebraicGeometry.Stalk","initialProofState":"X : AlgebraicGeometry.Scheme\nR : CommRingCat\ninst✝ : IsLocalRing ↑R\nf : Quiver.Hom (AlgebraicGeometry.Spec R) X\n⊢ IsLocalHom (CommRingCat.Hom.hom (AlgebraicGeometry.Scheme.stalkClosedPointTo f))","decl":"instance isLocalHom_stalkClosedPointTo :\n    IsLocalHom (stalkClosedPointTo f).hom :=\n  inferInstanceAs <| IsLocalHom (f.stalkMap (closedPoint R) ≫ (stalkClosedPointIso R).hom).hom\n\n"}
{"name":"AlgebraicGeometry.Scheme.isLocalHom_stalkClosedPointTo'","module":"Mathlib.AlgebraicGeometry.Stalk","initialProofState":"X : AlgebraicGeometry.Scheme\nR : Type u\ninst✝¹ : CommRing R\ninst✝ : IsLocalRing R\nf : Quiver.Hom (AlgebraicGeometry.Spec (CommRingCat.of R)) X\n⊢ IsLocalHom (CommRingCat.Hom.hom (AlgebraicGeometry.Scheme.stalkClosedPointTo f))","decl":"/-- Copy of `isLocalHom_stalkClosedPointTo` which unbundles the comm ring.\n\nUseful for use in combination with `CommRingCat.of K` for a field `K`.\n-/\ninstance isLocalHom_stalkClosedPointTo' {R : Type u} [CommRing R] [IsLocalRing R]\n    (f : Spec (.of R) ⟶ X) :\n    IsLocalHom (stalkClosedPointTo f).hom :=\n  isLocalHom_stalkClosedPointTo f\n\n"}
{"name":"AlgebraicGeometry.Scheme.preimage_eq_top_of_closedPoint_mem","module":"Mathlib.AlgebraicGeometry.Stalk","initialProofState":"X : AlgebraicGeometry.Scheme\nR : CommRingCat\ninst✝ : IsLocalRing ↑R\nf : Quiver.Hom (AlgebraicGeometry.Spec R) X\nU : X.Opens\nhU : Membership.mem U (f.base (IsLocalRing.closedPoint ↑R))\n⊢ Eq ((TopologicalSpace.Opens.map f.base).obj U) Top.top","decl":"lemma preimage_eq_top_of_closedPoint_mem\n    {U : Opens X} (hU : f.base (closedPoint R) ∈ U) : f ⁻¹ᵁ U = ⊤ :=\n  IsLocalRing.closed_point_mem_iff.mp hU\n\n"}
{"name":"AlgebraicGeometry.Scheme.stalkClosedPointTo_comp","module":"Mathlib.AlgebraicGeometry.Stalk","initialProofState":"X Y : AlgebraicGeometry.Scheme\nR : CommRingCat\ninst✝ : IsLocalRing ↑R\nf : Quiver.Hom (AlgebraicGeometry.Spec R) X\ng : Quiver.Hom X Y\n⊢ Eq (AlgebraicGeometry.Scheme.stalkClosedPointTo (CategoryTheory.CategoryStruct.comp f g)) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Hom.stalkMap g (f.base (IsLocalRing.closedPoint ↑R))) (AlgebraicGeometry.Scheme.stalkClosedPointTo f))","decl":"lemma stalkClosedPointTo_comp (g : X ⟶ Y) :\n    stalkClosedPointTo (f ≫ g) = g.stalkMap _ ≫ stalkClosedPointTo f := by\n  rw [stalkClosedPointTo, Scheme.stalkMap_comp]\n  exact Category.assoc _ _ _\n\n"}
{"name":"AlgebraicGeometry.Scheme.germ_stalkClosedPointTo_Spec","module":"Mathlib.AlgebraicGeometry.Stalk","initialProofState":"R S : CommRingCat\ninst✝ : IsLocalRing ↑S\nφ : Quiver.Hom R S\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((AlgebraicGeometry.Spec R).presheaf.germ Top.top ((AlgebraicGeometry.Spec.map φ).base (IsLocalRing.closedPoint ↑S)) trivial) (AlgebraicGeometry.Scheme.stalkClosedPointTo (AlgebraicGeometry.Spec.map φ))) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.ΓSpecIso R).hom φ)","decl":"lemma germ_stalkClosedPointTo_Spec {R S : CommRingCat} [IsLocalRing S] (φ : R ⟶ S):\n    (Spec R).presheaf.germ ⊤ _ trivial ≫ stalkClosedPointTo (Spec.map φ) =\n      (ΓSpecIso R).hom ≫ φ := by\n  rw [stalkClosedPointTo, Scheme.stalkMap_germ_assoc, ← Iso.inv_comp_eq,\n    ← ΓSpecIso_inv_naturality_assoc]\n  simp_rw [Opens.map_top]\n  rw [germ_stalkClosedPointIso_hom, Iso.inv_hom_id, Category.comp_id]\n\n"}
{"name":"AlgebraicGeometry.Scheme.germ_stalkClosedPointTo_assoc","module":"Mathlib.AlgebraicGeometry.Stalk","initialProofState":"X : AlgebraicGeometry.Scheme\nR : CommRingCat\ninst✝ : IsLocalRing ↑R\nf : Quiver.Hom (AlgebraicGeometry.Spec R) X\nU : X.Opens\nhU : Membership.mem U (f.base (IsLocalRing.closedPoint ↑R))\nZ : CommRingCat\nh : Quiver.Hom R Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (X.presheaf.germ U (f.base (IsLocalRing.closedPoint ↑R)) hU) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.stalkClosedPointTo f) h)) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Hom.app f U) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Functor.mapIso (AlgebraicGeometry.Spec R).presheaf (CategoryTheory.eqToIso ⋯).op).trans (AlgebraicGeometry.Scheme.ΓSpecIso R)).hom h))","decl":"@[reassoc]\nlemma germ_stalkClosedPointTo (U : Opens X) (hU : f.base (closedPoint R) ∈ U) :\n    X.presheaf.germ U _ hU ≫ stalkClosedPointTo f = f.app U ≫\n      ((Spec R).presheaf.mapIso (eqToIso (preimage_eq_top_of_closedPoint_mem f hU).symm).op ≪≫\n        ΓSpecIso R).hom := by\n  rw [stalkClosedPointTo, Scheme.stalkMap_germ_assoc, Iso.trans_hom]\n  congr 1\n  rw [← Iso.eq_comp_inv, Category.assoc, ΓSpecIso_hom_stalkClosedPointIso_inv]\n  simp only [TopCat.Presheaf.pushforward_obj_obj, Functor.mapIso_hom, Iso.op_hom, eqToIso.hom,\n    TopCat.Presheaf.germ_res]\n\n"}
{"name":"AlgebraicGeometry.Scheme.germ_stalkClosedPointTo","module":"Mathlib.AlgebraicGeometry.Stalk","initialProofState":"X : AlgebraicGeometry.Scheme\nR : CommRingCat\ninst✝ : IsLocalRing ↑R\nf : Quiver.Hom (AlgebraicGeometry.Spec R) X\nU : X.Opens\nhU : Membership.mem U (f.base (IsLocalRing.closedPoint ↑R))\n⊢ Eq (CategoryTheory.CategoryStruct.comp (X.presheaf.germ U (f.base (IsLocalRing.closedPoint ↑R)) hU) (AlgebraicGeometry.Scheme.stalkClosedPointTo f)) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Hom.app f U) ((CategoryTheory.Functor.mapIso (AlgebraicGeometry.Spec R).presheaf (CategoryTheory.eqToIso ⋯).op).trans (AlgebraicGeometry.Scheme.ΓSpecIso R)).hom)","decl":"@[reassoc]\nlemma germ_stalkClosedPointTo (U : Opens X) (hU : f.base (closedPoint R) ∈ U) :\n    X.presheaf.germ U _ hU ≫ stalkClosedPointTo f = f.app U ≫\n      ((Spec R).presheaf.mapIso (eqToIso (preimage_eq_top_of_closedPoint_mem f hU).symm).op ≪≫\n        ΓSpecIso R).hom := by\n  rw [stalkClosedPointTo, Scheme.stalkMap_germ_assoc, Iso.trans_hom]\n  congr 1\n  rw [← Iso.eq_comp_inv, Category.assoc, ΓSpecIso_hom_stalkClosedPointIso_inv]\n  simp only [TopCat.Presheaf.pushforward_obj_obj, Functor.mapIso_hom, Iso.op_hom, eqToIso.hom,\n    TopCat.Presheaf.germ_res]\n\n"}
{"name":"AlgebraicGeometry.Scheme.germ_stalkClosedPointTo_Spec_fromSpecStalk_assoc","module":"Mathlib.AlgebraicGeometry.Stalk","initialProofState":"X : AlgebraicGeometry.Scheme\nR : CommRingCat\ninst✝¹ : IsLocalRing ↑R\nx : ↑↑X.toPresheafedSpace\nf : Quiver.Hom (X.presheaf.stalk x) R\ninst✝ : IsLocalHom (CommRingCat.Hom.hom f)\nU : X.Opens\nhU : Membership.mem U ((CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Spec.map f) (X.fromSpecStalk x)).base (IsLocalRing.closedPoint ↑R))\nZ : CommRingCat\nh : Quiver.Hom R Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (X.presheaf.germ U ((CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Spec.map f) (X.fromSpecStalk x)).base (IsLocalRing.closedPoint ↑R)) hU) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.stalkClosedPointTo (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Spec.map f) (X.fromSpecStalk x))) h)) (CategoryTheory.CategoryStruct.comp (X.presheaf.germ U x ⋯) (CategoryTheory.CategoryStruct.comp f h))","decl":"@[reassoc]\nlemma germ_stalkClosedPointTo_Spec_fromSpecStalk\n    {x : X} (f : X.presheaf.stalk x ⟶ R) [IsLocalHom f.hom] (U : Opens X) (hU) :\n    X.presheaf.germ U _ hU ≫ stalkClosedPointTo (Spec.map f ≫ X.fromSpecStalk x) =\n      X.presheaf.germ U x (by simpa using hU) ≫ f := by\n  have : (Spec.map f ≫ X.fromSpecStalk x).base (closedPoint R) = x := by\n    rw [comp_base_apply, Spec_closedPoint, fromSpecStalk_closedPoint]\n  have : x ∈ U := this ▸ hU\n  simp only [TopCat.Presheaf.stalkCongr_hom, TopCat.Presheaf.germ_stalkSpecializes_assoc,\n    germ_stalkClosedPointTo, comp_app,\n    fromSpecStalk_app (X := X) (x := x) this, Category.assoc, Iso.trans_hom,\n    Functor.mapIso_hom, Hom.naturality_assoc, ← Functor.map_comp_assoc,\n    (Spec.map f).app_eq_appLE, Hom.appLE_map_assoc, Hom.map_appLE_assoc]\n  simp_rw [← Opens.map_top (Spec.map f).base]\n  rw [← (Spec.map f).app_eq_appLE, ΓSpecIso_naturality, Iso.inv_hom_id_assoc]\n\n"}
{"name":"AlgebraicGeometry.Scheme.germ_stalkClosedPointTo_Spec_fromSpecStalk","module":"Mathlib.AlgebraicGeometry.Stalk","initialProofState":"X : AlgebraicGeometry.Scheme\nR : CommRingCat\ninst✝¹ : IsLocalRing ↑R\nx : ↑↑X.toPresheafedSpace\nf : Quiver.Hom (X.presheaf.stalk x) R\ninst✝ : IsLocalHom (CommRingCat.Hom.hom f)\nU : X.Opens\nhU : Membership.mem U ((CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Spec.map f) (X.fromSpecStalk x)).base (IsLocalRing.closedPoint ↑R))\n⊢ Eq (CategoryTheory.CategoryStruct.comp (X.presheaf.germ U ((CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Spec.map f) (X.fromSpecStalk x)).base (IsLocalRing.closedPoint ↑R)) hU) (AlgebraicGeometry.Scheme.stalkClosedPointTo (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Spec.map f) (X.fromSpecStalk x)))) (CategoryTheory.CategoryStruct.comp (X.presheaf.germ U x ⋯) f)","decl":"@[reassoc]\nlemma germ_stalkClosedPointTo_Spec_fromSpecStalk\n    {x : X} (f : X.presheaf.stalk x ⟶ R) [IsLocalHom f.hom] (U : Opens X) (hU) :\n    X.presheaf.germ U _ hU ≫ stalkClosedPointTo (Spec.map f ≫ X.fromSpecStalk x) =\n      X.presheaf.germ U x (by simpa using hU) ≫ f := by\n  have : (Spec.map f ≫ X.fromSpecStalk x).base (closedPoint R) = x := by\n    rw [comp_base_apply, Spec_closedPoint, fromSpecStalk_closedPoint]\n  have : x ∈ U := this ▸ hU\n  simp only [TopCat.Presheaf.stalkCongr_hom, TopCat.Presheaf.germ_stalkSpecializes_assoc,\n    germ_stalkClosedPointTo, comp_app,\n    fromSpecStalk_app (X := X) (x := x) this, Category.assoc, Iso.trans_hom,\n    Functor.mapIso_hom, Hom.naturality_assoc, ← Functor.map_comp_assoc,\n    (Spec.map f).app_eq_appLE, Hom.appLE_map_assoc, Hom.map_appLE_assoc]\n  simp_rw [← Opens.map_top (Spec.map f).base]\n  rw [← (Spec.map f).app_eq_appLE, ΓSpecIso_naturality, Iso.inv_hom_id_assoc]\n\n"}
{"name":"AlgebraicGeometry.Scheme.stalkClosedPointTo_fromSpecStalk","module":"Mathlib.AlgebraicGeometry.Stalk","initialProofState":"X : AlgebraicGeometry.Scheme\nx : ↑↑X.toPresheafedSpace\n⊢ Eq (AlgebraicGeometry.Scheme.stalkClosedPointTo (X.fromSpecStalk x)) (X.presheaf.stalkCongr ⋯).hom","decl":"lemma stalkClosedPointTo_fromSpecStalk (x : X) :\n    stalkClosedPointTo (X.fromSpecStalk x) =\n      (X.presheaf.stalkCongr (by rw [fromSpecStalk_closedPoint]; rfl)).hom := by\n  refine TopCat.Presheaf.stalk_hom_ext _ fun U hxU ↦ ?_\n  simp only [TopCat.Presheaf.stalkCongr_hom, TopCat.Presheaf.germ_stalkSpecializes, id_eq]\n  have : X.fromSpecStalk x = Spec.map (𝟙 (X.presheaf.stalk x)) ≫ X.fromSpecStalk x := by simp\n  convert germ_stalkClosedPointTo_Spec_fromSpecStalk (𝟙 (X.presheaf.stalk x)) U hxU\n\n"}
{"name":"AlgebraicGeometry.Scheme.Spec_stalkClosedPointTo_fromSpecStalk_assoc","module":"Mathlib.AlgebraicGeometry.Stalk","initialProofState":"X : AlgebraicGeometry.Scheme\nR : CommRingCat\ninst✝ : IsLocalRing ↑R\nf : Quiver.Hom (AlgebraicGeometry.Spec R) X\nZ : AlgebraicGeometry.Scheme\nh : Quiver.Hom X Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Spec.map (AlgebraicGeometry.Scheme.stalkClosedPointTo f)) (CategoryTheory.CategoryStruct.comp (X.fromSpecStalk (f.base (IsLocalRing.closedPoint ↑R))) h)) (CategoryTheory.CategoryStruct.comp f h)","decl":"@[reassoc]\nlemma Spec_stalkClosedPointTo_fromSpecStalk :\n    Spec.map (stalkClosedPointTo f) ≫ X.fromSpecStalk _ = f := by\n  obtain ⟨_, ⟨U, hU, rfl⟩, hxU, -⟩ := (isBasis_affine_open X).exists_subset_of_mem_open\n    (Set.mem_univ (f.base (closedPoint R))) isOpen_univ\n  have := IsAffineOpen.Spec_map_appLE_fromSpec f hU (isAffineOpen_top _)\n    (preimage_eq_top_of_closedPoint_mem f hxU).ge\n  rw [IsAffineOpen.fromSpec_top, Iso.eq_inv_comp, isoSpec_Spec_hom] at this\n  rw [← hU.fromSpecStalk_eq_fromSpecStalk hxU, IsAffineOpen.fromSpecStalk, ← Spec.map_comp_assoc,\n    germ_stalkClosedPointTo]\n  simpa only [Iso.trans_hom, Functor.mapIso_hom, Iso.op_hom, Category.assoc,\n    Hom.app_eq_appLE, Hom.appLE_map_assoc, Spec.map_comp_assoc]\n\n"}
{"name":"AlgebraicGeometry.Scheme.Spec_stalkClosedPointTo_fromSpecStalk","module":"Mathlib.AlgebraicGeometry.Stalk","initialProofState":"X : AlgebraicGeometry.Scheme\nR : CommRingCat\ninst✝ : IsLocalRing ↑R\nf : Quiver.Hom (AlgebraicGeometry.Spec R) X\n⊢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Spec.map (AlgebraicGeometry.Scheme.stalkClosedPointTo f)) (X.fromSpecStalk (f.base (IsLocalRing.closedPoint ↑R)))) f","decl":"@[reassoc]\nlemma Spec_stalkClosedPointTo_fromSpecStalk :\n    Spec.map (stalkClosedPointTo f) ≫ X.fromSpecStalk _ = f := by\n  obtain ⟨_, ⟨U, hU, rfl⟩, hxU, -⟩ := (isBasis_affine_open X).exists_subset_of_mem_open\n    (Set.mem_univ (f.base (closedPoint R))) isOpen_univ\n  have := IsAffineOpen.Spec_map_appLE_fromSpec f hU (isAffineOpen_top _)\n    (preimage_eq_top_of_closedPoint_mem f hxU).ge\n  rw [IsAffineOpen.fromSpec_top, Iso.eq_inv_comp, isoSpec_Spec_hom] at this\n  rw [← hU.fromSpecStalk_eq_fromSpecStalk hxU, IsAffineOpen.fromSpecStalk, ← Spec.map_comp_assoc,\n    germ_stalkClosedPointTo]\n  simpa only [Iso.trans_hom, Functor.mapIso_hom, Iso.op_hom, Category.assoc,\n    Hom.app_eq_appLE, Hom.appLE_map_assoc, Spec.map_comp_assoc]\n\n"}
{"name":"AlgebraicGeometry.SpecToEquivOfLocalRing_eq_iff","module":"Mathlib.AlgebraicGeometry.Stalk","initialProofState":"X : AlgebraicGeometry.Scheme\nR : CommRingCat\nf₁ f₂ : Sigma fun x => Subtype fun f => IsLocalHom (CommRingCat.Hom.hom f)\n⊢ Iff (Eq f₁ f₂) (Exists fun h₁ => Eq (↑f₁.snd) (CategoryTheory.CategoryStruct.comp (X.presheaf.stalkCongr ⋯).hom ↑f₂.snd))","decl":"omit [IsLocalRing R] in\n/-- useful lemma for applications of `SpecToEquivOfLocalRing` -/\nlemma SpecToEquivOfLocalRing_eq_iff\n    {f₁ f₂ : Σ x, { f : X.presheaf.stalk x ⟶ R // IsLocalHom f.hom }} :\n    f₁ = f₂ ↔ ∃ h₁ : f₁.1 = f₂.1, f₁.2.1 =\n      (X.presheaf.stalkCongr (by rw [h₁]; rfl)).hom ≫ f₂.2.1 := by\n  constructor\n  · rintro rfl; simp\n  · obtain ⟨x₁, ⟨f₁, h₁⟩⟩ := f₁\n    obtain ⟨x₂, ⟨f₂, h₂⟩⟩ := f₂\n    rintro ⟨rfl : x₁ = x₂, e : f₁ = _⟩\n    simp [e]\n\n"}
{"name":"AlgebraicGeometry.SpecToEquivOfLocalRing_apply_fst","module":"Mathlib.AlgebraicGeometry.Stalk","initialProofState":"X : AlgebraicGeometry.Scheme\nR : CommRingCat\ninst✝ : IsLocalRing ↑R\nf : Quiver.Hom (AlgebraicGeometry.Spec R) X\n⊢ Eq ((AlgebraicGeometry.SpecToEquivOfLocalRing X R) f).fst (f.base (IsLocalRing.closedPoint ↑R))","decl":"/--\nGiven a local ring `R` and scheme `X`, morphisms `Spec R ⟶ X` corresponds to pairs\n`(x, f)` where `x : X` and `f : 𝒪_{X, x} ⟶ R` is a local ring homomorphism.\n-/\n@[simps]\nnoncomputable\ndef SpecToEquivOfLocalRing :\n    (Spec R ⟶ X) ≃ Σ x, { f : X.presheaf.stalk x ⟶ R // IsLocalHom f.hom } where\n  toFun f := ⟨f.base (closedPoint R), Scheme.stalkClosedPointTo f, inferInstance⟩\n  invFun xf := Spec.map xf.2.1 ≫ X.fromSpecStalk xf.1\n  left_inv := Scheme.Spec_stalkClosedPointTo_fromSpecStalk\n  right_inv xf := by\n    obtain ⟨x, ⟨f, hf⟩⟩ := xf\n    symm\n    refine SpecToEquivOfLocalRing_eq_iff.mpr ⟨?_, ?_⟩\n    · simp only [Scheme.comp_coeBase, TopCat.coe_comp, Function.comp_apply, Spec_closedPoint,\n        Scheme.fromSpecStalk_closedPoint]\n    · refine TopCat.Presheaf.stalk_hom_ext _ fun U hxU ↦ ?_\n      simp only [Scheme.germ_stalkClosedPointTo_Spec_fromSpecStalk,\n        TopCat.Presheaf.stalkCongr_hom, TopCat.Presheaf.germ_stalkSpecializes_assoc]\n\n"}
{"name":"AlgebraicGeometry.SpecToEquivOfLocalRing_apply_snd_coe","module":"Mathlib.AlgebraicGeometry.Stalk","initialProofState":"X : AlgebraicGeometry.Scheme\nR : CommRingCat\ninst✝ : IsLocalRing ↑R\nf : Quiver.Hom (AlgebraicGeometry.Spec R) X\n⊢ Eq (↑((AlgebraicGeometry.SpecToEquivOfLocalRing X R) f).snd) (AlgebraicGeometry.Scheme.stalkClosedPointTo f)","decl":"/--\nGiven a local ring `R` and scheme `X`, morphisms `Spec R ⟶ X` corresponds to pairs\n`(x, f)` where `x : X` and `f : 𝒪_{X, x} ⟶ R` is a local ring homomorphism.\n-/\n@[simps]\nnoncomputable\ndef SpecToEquivOfLocalRing :\n    (Spec R ⟶ X) ≃ Σ x, { f : X.presheaf.stalk x ⟶ R // IsLocalHom f.hom } where\n  toFun f := ⟨f.base (closedPoint R), Scheme.stalkClosedPointTo f, inferInstance⟩\n  invFun xf := Spec.map xf.2.1 ≫ X.fromSpecStalk xf.1\n  left_inv := Scheme.Spec_stalkClosedPointTo_fromSpecStalk\n  right_inv xf := by\n    obtain ⟨x, ⟨f, hf⟩⟩ := xf\n    symm\n    refine SpecToEquivOfLocalRing_eq_iff.mpr ⟨?_, ?_⟩\n    · simp only [Scheme.comp_coeBase, TopCat.coe_comp, Function.comp_apply, Spec_closedPoint,\n        Scheme.fromSpecStalk_closedPoint]\n    · refine TopCat.Presheaf.stalk_hom_ext _ fun U hxU ↦ ?_\n      simp only [Scheme.germ_stalkClosedPointTo_Spec_fromSpecStalk,\n        TopCat.Presheaf.stalkCongr_hom, TopCat.Presheaf.germ_stalkSpecializes_assoc]\n\n"}
{"name":"AlgebraicGeometry.SpecToEquivOfLocalRing_symm_apply","module":"Mathlib.AlgebraicGeometry.Stalk","initialProofState":"X : AlgebraicGeometry.Scheme\nR : CommRingCat\ninst✝ : IsLocalRing ↑R\nxf : Sigma fun x => Subtype fun f => IsLocalHom (CommRingCat.Hom.hom f)\n⊢ Eq ((AlgebraicGeometry.SpecToEquivOfLocalRing X R).symm xf) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Spec.map ↑xf.snd) (X.fromSpecStalk xf.fst))","decl":"/--\nGiven a local ring `R` and scheme `X`, morphisms `Spec R ⟶ X` corresponds to pairs\n`(x, f)` where `x : X` and `f : 𝒪_{X, x} ⟶ R` is a local ring homomorphism.\n-/\n@[simps]\nnoncomputable\ndef SpecToEquivOfLocalRing :\n    (Spec R ⟶ X) ≃ Σ x, { f : X.presheaf.stalk x ⟶ R // IsLocalHom f.hom } where\n  toFun f := ⟨f.base (closedPoint R), Scheme.stalkClosedPointTo f, inferInstance⟩\n  invFun xf := Spec.map xf.2.1 ≫ X.fromSpecStalk xf.1\n  left_inv := Scheme.Spec_stalkClosedPointTo_fromSpecStalk\n  right_inv xf := by\n    obtain ⟨x, ⟨f, hf⟩⟩ := xf\n    symm\n    refine SpecToEquivOfLocalRing_eq_iff.mpr ⟨?_, ?_⟩\n    · simp only [Scheme.comp_coeBase, TopCat.coe_comp, Function.comp_apply, Spec_closedPoint,\n        Scheme.fromSpecStalk_closedPoint]\n    · refine TopCat.Presheaf.stalk_hom_ext _ fun U hxU ↦ ?_\n      simp only [Scheme.germ_stalkClosedPointTo_Spec_fromSpecStalk,\n        TopCat.Presheaf.stalkCongr_hom, TopCat.Presheaf.germ_stalkSpecializes_assoc]\n\n"}
