{"name":"AlgebraicGeometry.IsAffineOpen.fromSpecStalk_eq","module":"Mathlib.AlgebraicGeometry.Stalk","initialProofState":"X : AlgebraicGeometry.Scheme\nU V : X.Opens\nhU : AlgebraicGeometry.IsAffineOpen U\nhV : AlgebraicGeometry.IsAffineOpen V\nx : ‚Üë‚ÜëX.toPresheafedSpace\nhxU : Membership.mem U x\nhxV : Membership.mem V x\n‚ä¢ Eq (hU.fromSpecStalk hxU) (hV.fromSpecStalk hxV)","decl":"/--\nThe morphism from `Spec(O_x)` to `X` given by `IsAffineOpen.fromSpec` does not depend on the affine\nopen neighborhood of `x` we choose.\n-/\ntheorem IsAffineOpen.fromSpecStalk_eq (x : X) (hxU : x ‚àà U) (hxV : x ‚àà V) :\n    hU.fromSpecStalk hxU = hV.fromSpecStalk hxV := by\n  obtain ‚ü®U', h‚ÇÅ, h‚ÇÇ, h‚ÇÉ : U' ‚â§ U ‚äì V‚ü© :=\n    Opens.isBasis_iff_nbhd.mp (isBasis_affine_open X) (show x ‚àà U ‚äì V from ‚ü®hxU, hxV‚ü©)\n  transitivity fromSpecStalk h‚ÇÅ h‚ÇÇ\n  ¬∑ delta fromSpecStalk\n    rw [‚Üê hU.map_fromSpec h‚ÇÅ (homOfLE <| h‚ÇÉ.trans inf_le_left).op]\n    erw [‚Üê Scheme.Spec_map (X.presheaf.map _).op, ‚Üê Scheme.Spec_map (X.presheaf.germ _ x h‚ÇÇ).op]\n    rw [‚Üê Functor.map_comp_assoc, ‚Üê op_comp, TopCat.Presheaf.germ_res, Scheme.Spec_map,\n      Quiver.Hom.unop_op]\n  ¬∑ delta fromSpecStalk\n    rw [‚Üê hV.map_fromSpec h‚ÇÅ (homOfLE <| h‚ÇÉ.trans inf_le_right).op]\n    erw [‚Üê Scheme.Spec_map (X.presheaf.map _).op, ‚Üê Scheme.Spec_map (X.presheaf.germ _ x h‚ÇÇ).op]\n    rw [‚Üê Functor.map_comp_assoc, ‚Üê op_comp, TopCat.Presheaf.germ_res, Scheme.Spec_map,\n      Quiver.Hom.unop_op]\n\n"}
{"name":"AlgebraicGeometry.instOverSpecStalkCommRingCatPresheaf_over","module":"Mathlib.AlgebraicGeometry.Stalk","initialProofState":"X : AlgebraicGeometry.Scheme\nx : ‚Üë‚ÜëX.toPresheafedSpace\n‚ä¢ Eq (CategoryTheory.over (AlgebraicGeometry.Spec (X.presheaf.stalk x)) X inferInstance) (X.fromSpecStalk x)","decl":"@[simps over] noncomputable\ninstance (X : Scheme.{u}) (x : X) : (Spec (X.presheaf.stalk x)).Over X := ‚ü®X.fromSpecStalk x‚ü©\n\n"}
{"name":"AlgebraicGeometry.instCanonicallyOver_over","module":"Mathlib.AlgebraicGeometry.Stalk","initialProofState":"X : AlgebraicGeometry.Scheme\nx : ‚Üë‚ÜëX.toPresheafedSpace\n‚ä¢ Eq (CategoryTheory.over (AlgebraicGeometry.Spec (X.presheaf.stalk x)) X inferInstance) (X.fromSpecStalk x)","decl":"@[simps! over] noncomputable\ninstance (X : Scheme.{u}) (x : X) : (Spec (X.presheaf.stalk x)).CanonicallyOver X where\n\n"}
{"name":"AlgebraicGeometry.IsAffineOpen.fromSpecStalk_eq_fromSpecStalk","module":"Mathlib.AlgebraicGeometry.Stalk","initialProofState":"X : AlgebraicGeometry.Scheme\nU : X.Opens\nhU : AlgebraicGeometry.IsAffineOpen U\nx : ‚Üë‚ÜëX.toPresheafedSpace\nhxU : Membership.mem U x\n‚ä¢ Eq (hU.fromSpecStalk hxU) (X.fromSpecStalk x)","decl":"@[simp]\ntheorem IsAffineOpen.fromSpecStalk_eq_fromSpecStalk {x : X} (hxU : x ‚àà U) :\n    hU.fromSpecStalk hxU = X.fromSpecStalk x := fromSpecStalk_eq ..\n\n"}
{"name":"AlgebraicGeometry.IsAffineOpen.fromSpecStalk_isPreimmersion","module":"Mathlib.AlgebraicGeometry.Stalk","initialProofState":"X : AlgebraicGeometry.Scheme\nU : TopologicalSpace.Opens ‚Üë‚ÜëX.toPresheafedSpace\nhU : AlgebraicGeometry.IsAffineOpen U\nx : ‚Üë‚ÜëX.toPresheafedSpace\nhx : Membership.mem U x\n‚ä¢ AlgebraicGeometry.IsPreimmersion (hU.fromSpecStalk hx)","decl":"instance IsAffineOpen.fromSpecStalk_isPreimmersion {X : Scheme.{u}} {U : Opens X}\n    (hU : IsAffineOpen U) (x : X) (hx : x ‚àà U) : IsPreimmersion (hU.fromSpecStalk hx) := by\n  dsimp [IsAffineOpen.fromSpecStalk]\n  haveI : IsPreimmersion (Spec.map (X.presheaf.germ U x hx)) :=\n    letI : Algebra Œì(X, U) (X.presheaf.stalk x) := (X.presheaf.germ U x hx).hom.toAlgebra\n    haveI := hU.isLocalization_stalk ‚ü®x, hx‚ü©\n    IsPreimmersion.of_isLocalization (R := Œì(X, U)) (S := X.presheaf.stalk x)\n      (hU.primeIdealOf ‚ü®x, hx‚ü©).asIdeal.primeCompl\n  apply IsPreimmersion.comp\n\n"}
{"name":"AlgebraicGeometry.instIsPreimmersionFromSpecStalk","module":"Mathlib.AlgebraicGeometry.Stalk","initialProofState":"X : AlgebraicGeometry.Scheme\nx : ‚Üë‚ÜëX.toPresheafedSpace\n‚ä¢ AlgebraicGeometry.IsPreimmersion (X.fromSpecStalk x)","decl":"instance {X : Scheme.{u}} (x : X) : IsPreimmersion (X.fromSpecStalk x) :=\n  IsAffineOpen.fromSpecStalk_isPreimmersion _ _ _\n\n"}
{"name":"AlgebraicGeometry.IsAffineOpen.fromSpecStalk_closedPoint","module":"Mathlib.AlgebraicGeometry.Stalk","initialProofState":"X : AlgebraicGeometry.Scheme\nU : TopologicalSpace.Opens ‚Üë‚ÜëX.toPresheafedSpace\nhU : AlgebraicGeometry.IsAffineOpen U\nx : ‚Üë‚ÜëX.toPresheafedSpace\nhxU : Membership.mem U x\n‚ä¢ Eq ((hU.fromSpecStalk hxU).base (IsLocalRing.closedPoint ‚Üë(X.presheaf.stalk x))) x","decl":"lemma IsAffineOpen.fromSpecStalk_closedPoint {U : Opens X} (hU : IsAffineOpen U)\n    {x : X} (hxU : x ‚àà U) :\n    (hU.fromSpecStalk hxU).base (closedPoint (X.presheaf.stalk x)) = x := by\n  rw [IsAffineOpen.fromSpecStalk, Scheme.comp_base_apply]\n  rw [‚Üê hU.primeIdealOf_eq_map_closedPoint ‚ü®x, hxU‚ü©, hU.fromSpec_primeIdealOf ‚ü®x, hxU‚ü©]\n\n"}
{"name":"AlgebraicGeometry.Scheme.fromSpecStalk_closedPoint","module":"Mathlib.AlgebraicGeometry.Stalk","initialProofState":"X : AlgebraicGeometry.Scheme\nx : ‚Üë‚ÜëX.toPresheafedSpace\n‚ä¢ Eq ((X.fromSpecStalk x).base (IsLocalRing.closedPoint ‚Üë(X.presheaf.stalk x))) x","decl":"@[simp]\nlemma fromSpecStalk_closedPoint {x : X} :\n    (X.fromSpecStalk x).base (closedPoint (X.presheaf.stalk x)) = x :=\n  IsAffineOpen.fromSpecStalk_closedPoint _ _\n\n"}
{"name":"AlgebraicGeometry.Scheme.fromSpecStalk_app","module":"Mathlib.AlgebraicGeometry.Stalk","initialProofState":"X : AlgebraicGeometry.Scheme\nU : X.Opens\nx : ‚Üë‚ÜëX.toPresheafedSpace\nhxU : Membership.mem U x\n‚ä¢ Eq (AlgebraicGeometry.Scheme.Hom.app (X.fromSpecStalk x) U) (CategoryTheory.CategoryStruct.comp (X.presheaf.germ U x hxU) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.ŒìSpecIso (X.presheaf.stalk x)).inv ((AlgebraicGeometry.Spec (X.presheaf.stalk x)).presheaf.map (CategoryTheory.homOfLE ‚ãØ).op)))","decl":"lemma fromSpecStalk_app {x : X} (hxU : x ‚àà U) :\n    (X.fromSpecStalk x).app U =\n      X.presheaf.germ U x hxU ‚â´\n        (ŒìSpecIso (X.presheaf.stalk x)).inv ‚â´\n          (Spec (X.presheaf.stalk x)).presheaf.map (homOfLE le_top).op := by\n  obtain ‚ü®_, ‚ü®V : X.Opens, hV, rfl‚ü©, hxV, hVU‚ü© := (isBasis_affine_open X).exists_subset_of_mem_open\n    hxU U.2\n  rw [‚Üê hV.fromSpecStalk_eq_fromSpecStalk hxV, IsAffineOpen.fromSpecStalk, Scheme.comp_app,\n    hV.fromSpec_app_of_le _ hVU, ‚Üê X.presheaf.germ_res (homOfLE hVU) x hxV]\n  simp [Category.assoc, ‚Üê ŒìSpecIso_inv_naturality_assoc]\n\n"}
{"name":"AlgebraicGeometry.Scheme.fromSpecStalk_appTop","module":"Mathlib.AlgebraicGeometry.Stalk","initialProofState":"X : AlgebraicGeometry.Scheme\nx : ‚Üë‚ÜëX.toPresheafedSpace\n‚ä¢ Eq (AlgebraicGeometry.Scheme.Hom.appTop (X.fromSpecStalk x)) (CategoryTheory.CategoryStruct.comp (X.presheaf.germ Top.top x trivial) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.ŒìSpecIso (X.presheaf.stalk x)).inv ((AlgebraicGeometry.Spec (X.presheaf.stalk x)).presheaf.map (CategoryTheory.homOfLE ‚ãØ).op)))","decl":"lemma fromSpecStalk_appTop {x : X} :\n    (X.fromSpecStalk x).appTop =\n      X.presheaf.germ ‚ä§ x trivial ‚â´\n        (ŒìSpecIso (X.presheaf.stalk x)).inv ‚â´\n          (Spec (X.presheaf.stalk x)).presheaf.map (homOfLE le_top).op :=\n  fromSpecStalk_app ..\n\n"}
{"name":"AlgebraicGeometry.Scheme.Spec_map_stalkSpecializes_fromSpecStalk_assoc","module":"Mathlib.AlgebraicGeometry.Stalk","initialProofState":"X : AlgebraicGeometry.Scheme\nx y : ‚Üë‚ÜëX.toPresheafedSpace\nh‚úù : Specializes x y\nZ : AlgebraicGeometry.Scheme\nh : Quiver.Hom X Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Spec.map (X.presheaf.stalkSpecializes h‚úù)) (CategoryTheory.CategoryStruct.comp (X.fromSpecStalk y) h)) (CategoryTheory.CategoryStruct.comp (X.fromSpecStalk x) h)","decl":"@[reassoc (attr := simp)]\nlemma Spec_map_stalkSpecializes_fromSpecStalk {x y : X} (h : x ‚§≥ y) :\n    Spec.map (X.presheaf.stalkSpecializes h) ‚â´ X.fromSpecStalk y = X.fromSpecStalk x := by\n  obtain ‚ü®_, ‚ü®U, hU, rfl‚ü©, hyU, -‚ü© :=\n    (isBasis_affine_open X).exists_subset_of_mem_open (Set.mem_univ y) isOpen_univ\n  have hxU : x ‚àà U := h.mem_open U.2 hyU\n  rw [‚Üê hU.fromSpecStalk_eq_fromSpecStalk hyU, ‚Üê hU.fromSpecStalk_eq_fromSpecStalk hxU,\n    IsAffineOpen.fromSpecStalk, IsAffineOpen.fromSpecStalk, ‚Üê Category.assoc, ‚Üê Spec.map_comp,\n    TopCat.Presheaf.germ_stalkSpecializes]\n\n"}
{"name":"AlgebraicGeometry.Scheme.Spec_map_stalkSpecializes_fromSpecStalk","module":"Mathlib.AlgebraicGeometry.Stalk","initialProofState":"X : AlgebraicGeometry.Scheme\nx y : ‚Üë‚ÜëX.toPresheafedSpace\nh : Specializes x y\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Spec.map (X.presheaf.stalkSpecializes h)) (X.fromSpecStalk y)) (X.fromSpecStalk x)","decl":"@[reassoc (attr := simp)]\nlemma Spec_map_stalkSpecializes_fromSpecStalk {x y : X} (h : x ‚§≥ y) :\n    Spec.map (X.presheaf.stalkSpecializes h) ‚â´ X.fromSpecStalk y = X.fromSpecStalk x := by\n  obtain ‚ü®_, ‚ü®U, hU, rfl‚ü©, hyU, -‚ü© :=\n    (isBasis_affine_open X).exists_subset_of_mem_open (Set.mem_univ y) isOpen_univ\n  have hxU : x ‚àà U := h.mem_open U.2 hyU\n  rw [‚Üê hU.fromSpecStalk_eq_fromSpecStalk hyU, ‚Üê hU.fromSpecStalk_eq_fromSpecStalk hxU,\n    IsAffineOpen.fromSpecStalk, IsAffineOpen.fromSpecStalk, ‚Üê Category.assoc, ‚Üê Spec.map_comp,\n    TopCat.Presheaf.germ_stalkSpecializes]\n\n"}
{"name":"AlgebraicGeometry.Scheme.instIsOverMapStalkSpecializesCommRingCatPresheaf","module":"Mathlib.AlgebraicGeometry.Stalk","initialProofState":"X : AlgebraicGeometry.Scheme\nx y : ‚Üë‚ÜëX.toPresheafedSpace\nh : Specializes x y\n‚ä¢ AlgebraicGeometry.Scheme.Hom.IsOver (AlgebraicGeometry.Spec.map (X.presheaf.stalkSpecializes h)) X","decl":"instance {x y : X} (h : x ‚§≥ y) : (Spec.map (X.presheaf.stalkSpecializes h)).IsOver X where\n\n"}
{"name":"AlgebraicGeometry.Scheme.Spec_map_stalkMap_fromSpecStalk","module":"Mathlib.AlgebraicGeometry.Stalk","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nx : ‚Üë‚ÜëX.toPresheafedSpace\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Spec.map (AlgebraicGeometry.Scheme.Hom.stalkMap f x)) (Y.fromSpecStalk (f.base x))) (CategoryTheory.CategoryStruct.comp (X.fromSpecStalk x) f)","decl":"@[reassoc (attr := simp)]\nlemma Spec_map_stalkMap_fromSpecStalk {x} :\n    Spec.map (f.stalkMap x) ‚â´ Y.fromSpecStalk _ = X.fromSpecStalk x ‚â´ f := by\n  obtain ‚ü®_, ‚ü®U, hU, rfl‚ü©, hxU, -‚ü© := (isBasis_affine_open Y).exists_subset_of_mem_open\n    (Set.mem_univ (f.base x)) isOpen_univ\n  obtain ‚ü®_, ‚ü®V, hV, rfl‚ü©, hxV, hVU‚ü© := (isBasis_affine_open X).exists_subset_of_mem_open\n    hxU (f ‚Åª¬π·µÅ U).2\n  rw [‚Üê hU.fromSpecStalk_eq_fromSpecStalk hxU, ‚Üê hV.fromSpecStalk_eq_fromSpecStalk hxV,\n    IsAffineOpen.fromSpecStalk, ‚Üê Spec.map_comp_assoc, Scheme.stalkMap_germ f _ x hxU,\n    IsAffineOpen.fromSpecStalk, Spec.map_comp_assoc, ‚Üê X.presheaf.germ_res (homOfLE hVU) x hxV,\n    Spec.map_comp_assoc, Category.assoc, ‚Üê Spec.map_comp_assoc (f.app _),\n      Hom.app_eq_appLE, Hom.appLE_map, IsAffineOpen.Spec_map_appLE_fromSpec]\n\n"}
{"name":"AlgebraicGeometry.Scheme.Spec_map_stalkMap_fromSpecStalk_assoc","module":"Mathlib.AlgebraicGeometry.Stalk","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nx : ‚Üë‚ÜëX.toPresheafedSpace\nZ : AlgebraicGeometry.Scheme\nh : Quiver.Hom Y Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Spec.map (AlgebraicGeometry.Scheme.Hom.stalkMap f x)) (CategoryTheory.CategoryStruct.comp (Y.fromSpecStalk (f.base x)) h)) (CategoryTheory.CategoryStruct.comp (X.fromSpecStalk x) (CategoryTheory.CategoryStruct.comp f h))","decl":"@[reassoc (attr := simp)]\nlemma Spec_map_stalkMap_fromSpecStalk {x} :\n    Spec.map (f.stalkMap x) ‚â´ Y.fromSpecStalk _ = X.fromSpecStalk x ‚â´ f := by\n  obtain ‚ü®_, ‚ü®U, hU, rfl‚ü©, hxU, -‚ü© := (isBasis_affine_open Y).exists_subset_of_mem_open\n    (Set.mem_univ (f.base x)) isOpen_univ\n  obtain ‚ü®_, ‚ü®V, hV, rfl‚ü©, hxV, hVU‚ü© := (isBasis_affine_open X).exists_subset_of_mem_open\n    hxU (f ‚Åª¬π·µÅ U).2\n  rw [‚Üê hU.fromSpecStalk_eq_fromSpecStalk hxU, ‚Üê hV.fromSpecStalk_eq_fromSpecStalk hxV,\n    IsAffineOpen.fromSpecStalk, ‚Üê Spec.map_comp_assoc, Scheme.stalkMap_germ f _ x hxU,\n    IsAffineOpen.fromSpecStalk, Spec.map_comp_assoc, ‚Üê X.presheaf.germ_res (homOfLE hVU) x hxV,\n    Spec.map_comp_assoc, Category.assoc, ‚Üê Spec.map_comp_assoc (f.app _),\n      Hom.app_eq_appLE, Hom.appLE_map, IsAffineOpen.Spec_map_appLE_fromSpec]\n\n"}
{"name":"AlgebraicGeometry.Scheme.instIsOverMapStalkMapOverInferInstanceOverClass","module":"Mathlib.AlgebraicGeometry.Stalk","initialProofState":"X Y : AlgebraicGeometry.Scheme\ninst‚úù : X.Over Y\nx : ‚Üë‚ÜëX.toPresheafedSpace\n‚ä¢ AlgebraicGeometry.Scheme.Hom.IsOver (AlgebraicGeometry.Spec.map (AlgebraicGeometry.Scheme.Hom.stalkMap (CategoryTheory.over X Y inferInstance) x)) Y","decl":"instance [X.Over Y] {x} : Spec.map ((X ‚Üò Y).stalkMap x) |>.IsOver Y where\n\n"}
{"name":"AlgebraicGeometry.Scheme.Spec_fromSpecStalk","module":"Mathlib.AlgebraicGeometry.Stalk","initialProofState":"R : CommRingCat\nx : ‚Üë‚Üë(AlgebraicGeometry.Spec R).toPresheafedSpace\n‚ä¢ Eq ((AlgebraicGeometry.Spec R).fromSpecStalk x) (AlgebraicGeometry.Spec.map (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.ŒìSpecIso R).inv ((AlgebraicGeometry.Spec R).presheaf.germ Top.top x trivial)))","decl":"lemma Spec_fromSpecStalk (R : CommRingCat) (x) :\n    (Spec R).fromSpecStalk x =\n      Spec.map ((ŒìSpecIso R).inv ‚â´ (Spec R).presheaf.germ ‚ä§ x trivial) := by\n  rw [‚Üê (isAffineOpen_top (Spec R)).fromSpecStalk_eq_fromSpecStalk (x := x) trivial,\n    IsAffineOpen.fromSpecStalk, IsAffineOpen.fromSpec_top, isoSpec_Spec_inv,\n    ‚Üê Spec.map_comp]\n\n-- This is not a simp lemma to respect the abstraction boundaries\n"}
{"name":"AlgebraicGeometry.Scheme.Spec_fromSpecStalk'","module":"Mathlib.AlgebraicGeometry.Stalk","initialProofState":"R : CommRingCat\nx : ‚Üë‚Üë(AlgebraicGeometry.Spec R).toPresheafedSpace\n‚ä¢ Eq ((AlgebraicGeometry.Spec R).fromSpecStalk x) (AlgebraicGeometry.Spec.map (AlgebraicGeometry.StructureSheaf.toStalk (‚ÜëR) x))","decl":"/-- A variant of `Spec_fromSpecStalk` that breaks abstraction boundaries. -/\nlemma Spec_fromSpecStalk' (R : CommRingCat) (x) :\n    (Spec R).fromSpecStalk x = Spec.map (StructureSheaf.toStalk R _) :=\n  Spec_fromSpecStalk _ _\n\n"}
{"name":"AlgebraicGeometry.Scheme.range_fromSpecStalk","module":"Mathlib.AlgebraicGeometry.Stalk","initialProofState":"X : AlgebraicGeometry.Scheme\nx : ‚Üë‚ÜëX.toPresheafedSpace\n‚ä¢ Eq (Set.range ‚áë(X.fromSpecStalk x).base) (setOf fun y => Specializes y x)","decl":"@[stacks 01J7]\nlemma range_fromSpecStalk {x : X} :\n    Set.range (X.fromSpecStalk x).base = { y | y ‚§≥ x } := by\n  ext y\n  constructor\n  ¬∑ rintro ‚ü®y, rfl‚ü©\n    exact ((IsLocalRing.specializes_closedPoint y).map (X.fromSpecStalk x).base.2).trans\n      (specializes_of_eq fromSpecStalk_closedPoint)\n  ¬∑ rintro (hy : y ‚§≥ x)\n    have := fromSpecStalk_closedPoint (x := y)\n    rw [‚Üê Spec_map_stalkSpecializes_fromSpecStalk hy] at this\n    exact ‚ü®_, this‚ü©\n\n"}
{"name":"AlgebraicGeometry.Scheme.Opens.fromSpecStalkOfMem_Œπ_assoc","module":"Mathlib.AlgebraicGeometry.Stalk","initialProofState":"X : AlgebraicGeometry.Scheme\nU : X.Opens\nx : ‚Üë‚ÜëX.toPresheafedSpace\nhxU : Membership.mem U x\nZ : AlgebraicGeometry.Scheme\nh : Quiver.Hom X Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (U.fromSpecStalkOfMem x hxU) (CategoryTheory.CategoryStruct.comp U.Œπ h)) (CategoryTheory.CategoryStruct.comp (X.fromSpecStalk x) h)","decl":"@[reassoc (attr := simp)]\nlemma Opens.fromSpecStalkOfMem_Œπ {X : Scheme.{u}} (U : X.Opens) (x : X) (hxU : x ‚àà U) :\n    U.fromSpecStalkOfMem x hxU ‚â´ U.Œπ = X.fromSpecStalk x := by\n  simp only [Opens.fromSpecStalkOfMem, Spec.map_inv, Category.assoc, IsIso.inv_comp_eq]\n  exact (Scheme.Spec_map_stalkMap_fromSpecStalk U.Œπ (x := ‚ü®x, hxU‚ü©)).symm\n\n"}
{"name":"AlgebraicGeometry.Scheme.Opens.fromSpecStalkOfMem_Œπ","module":"Mathlib.AlgebraicGeometry.Stalk","initialProofState":"X : AlgebraicGeometry.Scheme\nU : X.Opens\nx : ‚Üë‚ÜëX.toPresheafedSpace\nhxU : Membership.mem U x\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (U.fromSpecStalkOfMem x hxU) U.Œπ) (X.fromSpecStalk x)","decl":"@[reassoc (attr := simp)]\nlemma Opens.fromSpecStalkOfMem_Œπ {X : Scheme.{u}} (U : X.Opens) (x : X) (hxU : x ‚àà U) :\n    U.fromSpecStalkOfMem x hxU ‚â´ U.Œπ = X.fromSpecStalk x := by\n  simp only [Opens.fromSpecStalkOfMem, Spec.map_inv, Category.assoc, IsIso.inv_comp_eq]\n  exact (Scheme.Spec_map_stalkMap_fromSpecStalk U.Œπ (x := ‚ü®x, hxU‚ü©)).symm\n\n"}
{"name":"AlgebraicGeometry.Scheme.instIsOverFromSpecStalkOfMem","module":"Mathlib.AlgebraicGeometry.Stalk","initialProofState":"X : AlgebraicGeometry.Scheme\nU : X.Opens\nx : ‚Üë‚ÜëX.toPresheafedSpace\nhxU : Membership.mem U x\n‚ä¢ AlgebraicGeometry.Scheme.Hom.IsOver (U.fromSpecStalkOfMem x hxU) X","decl":"instance {X : Scheme.{u}} (U : X.Opens) (x : X) (hxU : x ‚àà U) :\n    (U.fromSpecStalkOfMem x hxU).IsOver X where\n\n"}
{"name":"AlgebraicGeometry.Scheme.fromSpecStalk_toSpecŒì_assoc","module":"Mathlib.AlgebraicGeometry.Stalk","initialProofState":"X : AlgebraicGeometry.Scheme\nx : ‚Üë‚ÜëX.toPresheafedSpace\nZ : AlgebraicGeometry.Scheme\nh : Quiver.Hom (AlgebraicGeometry.Spec (X.presheaf.obj { unop := Top.top })) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (X.fromSpecStalk x) (CategoryTheory.CategoryStruct.comp X.toSpecŒì h)) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Spec.map (X.presheaf.germ Top.top x trivial)) h)","decl":"@[reassoc]\nlemma fromSpecStalk_toSpecŒì (X : Scheme.{u}) (x : X) :\n    X.fromSpecStalk x ‚â´ X.toSpecŒì = Spec.map (X.presheaf.germ ‚ä§ x trivial) := by\n  rw [Scheme.toSpecŒì_naturality, ‚Üê SpecMap_ŒìSpecIso_hom, ‚Üê Spec.map_comp,\n    Scheme.fromSpecStalk_appTop]\n  simp\n\n"}
{"name":"AlgebraicGeometry.Scheme.fromSpecStalk_toSpecŒì","module":"Mathlib.AlgebraicGeometry.Stalk","initialProofState":"X : AlgebraicGeometry.Scheme\nx : ‚Üë‚ÜëX.toPresheafedSpace\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (X.fromSpecStalk x) X.toSpecŒì) (AlgebraicGeometry.Spec.map (X.presheaf.germ Top.top x trivial))","decl":"@[reassoc]\nlemma fromSpecStalk_toSpecŒì (X : Scheme.{u}) (x : X) :\n    X.fromSpecStalk x ‚â´ X.toSpecŒì = Spec.map (X.presheaf.germ ‚ä§ x trivial) := by\n  rw [Scheme.toSpecŒì_naturality, ‚Üê SpecMap_ŒìSpecIso_hom, ‚Üê Spec.map_comp,\n    Scheme.fromSpecStalk_appTop]\n  simp\n\n"}
{"name":"AlgebraicGeometry.Scheme.Opens.fromSpecStalkOfMem_toSpecŒì_assoc","module":"Mathlib.AlgebraicGeometry.Stalk","initialProofState":"X : AlgebraicGeometry.Scheme\nU : X.Opens\nx : ‚Üë‚ÜëX.toPresheafedSpace\nhxU : Membership.mem U x\nZ : AlgebraicGeometry.Scheme\nh : Quiver.Hom (AlgebraicGeometry.Spec (X.presheaf.obj { unop := U })) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (U.fromSpecStalkOfMem x hxU) (CategoryTheory.CategoryStruct.comp U.toSpecŒì h)) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Spec.map (X.presheaf.germ U x hxU)) h)","decl":"@[reassoc (attr := simp)]\nlemma Opens.fromSpecStalkOfMem_toSpecŒì {X : Scheme.{u}} (U : X.Opens) (x : X) (hxU : x ‚àà U) :\n    U.fromSpecStalkOfMem x hxU ‚â´ U.toSpecŒì = Spec.map (X.presheaf.germ U x hxU) := by\n  rw [fromSpecStalkOfMem, Opens.toSpecŒì, Category.assoc, fromSpecStalk_toSpecŒì_assoc,\n    ‚Üê Spec.map_comp, ‚Üê Spec.map_comp]\n  congr 1\n  rw [IsIso.comp_inv_eq, Iso.inv_comp_eq]\n  erw [stalkMap_germ U.Œπ U ‚ü®x, hxU‚ü©]\n  rw [Opens.Œπ_app, Opens.topIso_hom, ‚Üê Functor.map_comp_assoc]\n  exact (U.toScheme.presheaf.germ_res (homOfLE le_top) ‚ü®x, hxU‚ü© (U := U.Œπ ‚Åª¬π·µÅ U) hxU).symm\n\n"}
{"name":"AlgebraicGeometry.Scheme.Opens.fromSpecStalkOfMem_toSpecŒì","module":"Mathlib.AlgebraicGeometry.Stalk","initialProofState":"X : AlgebraicGeometry.Scheme\nU : X.Opens\nx : ‚Üë‚ÜëX.toPresheafedSpace\nhxU : Membership.mem U x\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (U.fromSpecStalkOfMem x hxU) U.toSpecŒì) (AlgebraicGeometry.Spec.map (X.presheaf.germ U x hxU))","decl":"@[reassoc (attr := simp)]\nlemma Opens.fromSpecStalkOfMem_toSpecŒì {X : Scheme.{u}} (U : X.Opens) (x : X) (hxU : x ‚àà U) :\n    U.fromSpecStalkOfMem x hxU ‚â´ U.toSpecŒì = Spec.map (X.presheaf.germ U x hxU) := by\n  rw [fromSpecStalkOfMem, Opens.toSpecŒì, Category.assoc, fromSpecStalk_toSpecŒì_assoc,\n    ‚Üê Spec.map_comp, ‚Üê Spec.map_comp]\n  congr 1\n  rw [IsIso.comp_inv_eq, Iso.inv_comp_eq]\n  erw [stalkMap_germ U.Œπ U ‚ü®x, hxU‚ü©]\n  rw [Opens.Œπ_app, Opens.topIso_hom, ‚Üê Functor.map_comp_assoc]\n  exact (U.toScheme.presheaf.germ_res (homOfLE le_top) ‚ü®x, hxU‚ü© (U := U.Œπ ‚Åª¬π·µÅ U) hxU).symm\n\n"}
{"name":"AlgebraicGeometry.stalkClosedPointIso_inv","module":"Mathlib.AlgebraicGeometry.Stalk","initialProofState":"R : CommRingCat\ninst‚úù : IsLocalRing ‚ÜëR\n‚ä¢ Eq (AlgebraicGeometry.stalkClosedPointIso R).inv (AlgebraicGeometry.StructureSheaf.toStalk (‚ÜëR) (IsLocalRing.closedPoint ‚ÜëR))","decl":"lemma stalkClosedPointIso_inv :\n    (stalkClosedPointIso R).inv = StructureSheaf.toStalk R _ := by\n  ext x\n  exact StructureSheaf.localizationToStalk_of _ _ _\n\n"}
{"name":"AlgebraicGeometry.ŒìSpecIso_hom_stalkClosedPointIso_inv","module":"Mathlib.AlgebraicGeometry.Stalk","initialProofState":"R : CommRingCat\ninst‚úù : IsLocalRing ‚ÜëR\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.ŒìSpecIso R).hom (AlgebraicGeometry.stalkClosedPointIso R).inv) ((AlgebraicGeometry.Spec R).presheaf.germ Top.top (IsLocalRing.closedPoint ‚ÜëR) trivial)","decl":"lemma ŒìSpecIso_hom_stalkClosedPointIso_inv :\n    (Scheme.ŒìSpecIso R).hom ‚â´ (stalkClosedPointIso R).inv =\n      (Spec R).presheaf.germ ‚ä§ (closedPoint _) trivial := by\n  rw [stalkClosedPointIso_inv, ‚Üê Iso.eq_inv_comp]\n  rfl\n\n"}
{"name":"AlgebraicGeometry.germ_stalkClosedPointIso_hom","module":"Mathlib.AlgebraicGeometry.Stalk","initialProofState":"R : CommRingCat\ninst‚úù : IsLocalRing ‚ÜëR\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((AlgebraicGeometry.Spec R).presheaf.germ Top.top (IsLocalRing.closedPoint ‚ÜëR) trivial) (AlgebraicGeometry.stalkClosedPointIso R).hom) (AlgebraicGeometry.Scheme.ŒìSpecIso R).hom","decl":"@[reassoc (attr := simp)]\nlemma germ_stalkClosedPointIso_hom :\n    (Spec R).presheaf.germ ‚ä§ (closedPoint _) trivial ‚â´ (stalkClosedPointIso R).hom =\n      (Scheme.ŒìSpecIso R).hom := by\n  rw [‚Üê ŒìSpecIso_hom_stalkClosedPointIso_inv, Category.assoc, Iso.inv_hom_id, Category.comp_id]\n\n"}
{"name":"AlgebraicGeometry.germ_stalkClosedPointIso_hom_assoc","module":"Mathlib.AlgebraicGeometry.Stalk","initialProofState":"R : CommRingCat\ninst‚úù : IsLocalRing ‚ÜëR\nZ : CommRingCat\nh : Quiver.Hom R Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((AlgebraicGeometry.Spec R).presheaf.germ Top.top (IsLocalRing.closedPoint ‚ÜëR) trivial) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.stalkClosedPointIso R).hom h)) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.ŒìSpecIso R).hom h)","decl":"@[reassoc (attr := simp)]\nlemma germ_stalkClosedPointIso_hom :\n    (Spec R).presheaf.germ ‚ä§ (closedPoint _) trivial ‚â´ (stalkClosedPointIso R).hom =\n      (Scheme.ŒìSpecIso R).hom := by\n  rw [‚Üê ŒìSpecIso_hom_stalkClosedPointIso_inv, Category.assoc, Iso.inv_hom_id, Category.comp_id]\n\n"}
{"name":"AlgebraicGeometry.Spec_stalkClosedPointIso","module":"Mathlib.AlgebraicGeometry.Stalk","initialProofState":"R : CommRingCat\ninst‚úù : IsLocalRing ‚ÜëR\n‚ä¢ Eq (AlgebraicGeometry.Spec.map (AlgebraicGeometry.stalkClosedPointIso R).inv) ((AlgebraicGeometry.Spec R).fromSpecStalk (IsLocalRing.closedPoint ‚ÜëR))","decl":"lemma Spec_stalkClosedPointIso :\n    Spec.map (stalkClosedPointIso R).inv = (Spec R).fromSpecStalk (closedPoint R) := by\n  rw [stalkClosedPointIso_inv, Scheme.Spec_fromSpecStalk']\n\n"}
{"name":"AlgebraicGeometry.Scheme.isLocalHom_stalkClosedPointTo","module":"Mathlib.AlgebraicGeometry.Stalk","initialProofState":"X : AlgebraicGeometry.Scheme\nR : CommRingCat\ninst‚úù : IsLocalRing ‚ÜëR\nf : Quiver.Hom (AlgebraicGeometry.Spec R) X\n‚ä¢ IsLocalHom (CommRingCat.Hom.hom (AlgebraicGeometry.Scheme.stalkClosedPointTo f))","decl":"instance isLocalHom_stalkClosedPointTo :\n    IsLocalHom (stalkClosedPointTo f).hom :=\n  inferInstanceAs <| IsLocalHom (f.stalkMap (closedPoint R) ‚â´ (stalkClosedPointIso R).hom).hom\n\n"}
{"name":"AlgebraicGeometry.Scheme.isLocalHom_stalkClosedPointTo'","module":"Mathlib.AlgebraicGeometry.Stalk","initialProofState":"X : AlgebraicGeometry.Scheme\nR : Type u\ninst‚úù¬π : CommRing R\ninst‚úù : IsLocalRing R\nf : Quiver.Hom (AlgebraicGeometry.Spec (CommRingCat.of R)) X\n‚ä¢ IsLocalHom (CommRingCat.Hom.hom (AlgebraicGeometry.Scheme.stalkClosedPointTo f))","decl":"/-- Copy of `isLocalHom_stalkClosedPointTo` which unbundles the comm ring.\n\nUseful for use in combination with `CommRingCat.of K` for a field `K`.\n-/\ninstance isLocalHom_stalkClosedPointTo' {R : Type u} [CommRing R] [IsLocalRing R]\n    (f : Spec (.of R) ‚ü∂ X) :\n    IsLocalHom (stalkClosedPointTo f).hom :=\n  isLocalHom_stalkClosedPointTo f\n\n"}
{"name":"AlgebraicGeometry.Scheme.preimage_eq_top_of_closedPoint_mem","module":"Mathlib.AlgebraicGeometry.Stalk","initialProofState":"X : AlgebraicGeometry.Scheme\nR : CommRingCat\ninst‚úù : IsLocalRing ‚ÜëR\nf : Quiver.Hom (AlgebraicGeometry.Spec R) X\nU : X.Opens\nhU : Membership.mem U (f.base (IsLocalRing.closedPoint ‚ÜëR))\n‚ä¢ Eq ((TopologicalSpace.Opens.map f.base).obj U) Top.top","decl":"lemma preimage_eq_top_of_closedPoint_mem\n    {U : Opens X} (hU : f.base (closedPoint R) ‚àà U) : f ‚Åª¬π·µÅ U = ‚ä§ :=\n  IsLocalRing.closed_point_mem_iff.mp hU\n\n"}
{"name":"AlgebraicGeometry.Scheme.stalkClosedPointTo_comp","module":"Mathlib.AlgebraicGeometry.Stalk","initialProofState":"X Y : AlgebraicGeometry.Scheme\nR : CommRingCat\ninst‚úù : IsLocalRing ‚ÜëR\nf : Quiver.Hom (AlgebraicGeometry.Spec R) X\ng : Quiver.Hom X Y\n‚ä¢ Eq (AlgebraicGeometry.Scheme.stalkClosedPointTo (CategoryTheory.CategoryStruct.comp f g)) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Hom.stalkMap g (f.base (IsLocalRing.closedPoint ‚ÜëR))) (AlgebraicGeometry.Scheme.stalkClosedPointTo f))","decl":"lemma stalkClosedPointTo_comp (g : X ‚ü∂ Y) :\n    stalkClosedPointTo (f ‚â´ g) = g.stalkMap _ ‚â´ stalkClosedPointTo f := by\n  rw [stalkClosedPointTo, Scheme.stalkMap_comp]\n  exact Category.assoc _ _ _\n\n"}
{"name":"AlgebraicGeometry.Scheme.germ_stalkClosedPointTo_Spec","module":"Mathlib.AlgebraicGeometry.Stalk","initialProofState":"R S : CommRingCat\ninst‚úù : IsLocalRing ‚ÜëS\nœÜ : Quiver.Hom R S\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((AlgebraicGeometry.Spec R).presheaf.germ Top.top ((AlgebraicGeometry.Spec.map œÜ).base (IsLocalRing.closedPoint ‚ÜëS)) trivial) (AlgebraicGeometry.Scheme.stalkClosedPointTo (AlgebraicGeometry.Spec.map œÜ))) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.ŒìSpecIso R).hom œÜ)","decl":"lemma germ_stalkClosedPointTo_Spec {R S : CommRingCat} [IsLocalRing S] (œÜ : R ‚ü∂ S):\n    (Spec R).presheaf.germ ‚ä§ _ trivial ‚â´ stalkClosedPointTo (Spec.map œÜ) =\n      (ŒìSpecIso R).hom ‚â´ œÜ := by\n  rw [stalkClosedPointTo, Scheme.stalkMap_germ_assoc, ‚Üê Iso.inv_comp_eq,\n    ‚Üê ŒìSpecIso_inv_naturality_assoc]\n  simp_rw [Opens.map_top]\n  rw [germ_stalkClosedPointIso_hom, Iso.inv_hom_id, Category.comp_id]\n\n"}
{"name":"AlgebraicGeometry.Scheme.germ_stalkClosedPointTo_assoc","module":"Mathlib.AlgebraicGeometry.Stalk","initialProofState":"X : AlgebraicGeometry.Scheme\nR : CommRingCat\ninst‚úù : IsLocalRing ‚ÜëR\nf : Quiver.Hom (AlgebraicGeometry.Spec R) X\nU : X.Opens\nhU : Membership.mem U (f.base (IsLocalRing.closedPoint ‚ÜëR))\nZ : CommRingCat\nh : Quiver.Hom R Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (X.presheaf.germ U (f.base (IsLocalRing.closedPoint ‚ÜëR)) hU) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.stalkClosedPointTo f) h)) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Hom.app f U) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Functor.mapIso (AlgebraicGeometry.Spec R).presheaf (CategoryTheory.eqToIso ‚ãØ).op).trans (AlgebraicGeometry.Scheme.ŒìSpecIso R)).hom h))","decl":"@[reassoc]\nlemma germ_stalkClosedPointTo (U : Opens X) (hU : f.base (closedPoint R) ‚àà U) :\n    X.presheaf.germ U _ hU ‚â´ stalkClosedPointTo f = f.app U ‚â´\n      ((Spec R).presheaf.mapIso (eqToIso (preimage_eq_top_of_closedPoint_mem f hU).symm).op ‚â™‚â´\n        ŒìSpecIso R).hom := by\n  rw [stalkClosedPointTo, Scheme.stalkMap_germ_assoc, Iso.trans_hom]\n  congr 1\n  rw [‚Üê Iso.eq_comp_inv, Category.assoc, ŒìSpecIso_hom_stalkClosedPointIso_inv]\n  simp only [TopCat.Presheaf.pushforward_obj_obj, Functor.mapIso_hom, Iso.op_hom, eqToIso.hom,\n    TopCat.Presheaf.germ_res]\n\n"}
{"name":"AlgebraicGeometry.Scheme.germ_stalkClosedPointTo","module":"Mathlib.AlgebraicGeometry.Stalk","initialProofState":"X : AlgebraicGeometry.Scheme\nR : CommRingCat\ninst‚úù : IsLocalRing ‚ÜëR\nf : Quiver.Hom (AlgebraicGeometry.Spec R) X\nU : X.Opens\nhU : Membership.mem U (f.base (IsLocalRing.closedPoint ‚ÜëR))\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (X.presheaf.germ U (f.base (IsLocalRing.closedPoint ‚ÜëR)) hU) (AlgebraicGeometry.Scheme.stalkClosedPointTo f)) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Hom.app f U) ((CategoryTheory.Functor.mapIso (AlgebraicGeometry.Spec R).presheaf (CategoryTheory.eqToIso ‚ãØ).op).trans (AlgebraicGeometry.Scheme.ŒìSpecIso R)).hom)","decl":"@[reassoc]\nlemma germ_stalkClosedPointTo (U : Opens X) (hU : f.base (closedPoint R) ‚àà U) :\n    X.presheaf.germ U _ hU ‚â´ stalkClosedPointTo f = f.app U ‚â´\n      ((Spec R).presheaf.mapIso (eqToIso (preimage_eq_top_of_closedPoint_mem f hU).symm).op ‚â™‚â´\n        ŒìSpecIso R).hom := by\n  rw [stalkClosedPointTo, Scheme.stalkMap_germ_assoc, Iso.trans_hom]\n  congr 1\n  rw [‚Üê Iso.eq_comp_inv, Category.assoc, ŒìSpecIso_hom_stalkClosedPointIso_inv]\n  simp only [TopCat.Presheaf.pushforward_obj_obj, Functor.mapIso_hom, Iso.op_hom, eqToIso.hom,\n    TopCat.Presheaf.germ_res]\n\n"}
{"name":"AlgebraicGeometry.Scheme.germ_stalkClosedPointTo_Spec_fromSpecStalk_assoc","module":"Mathlib.AlgebraicGeometry.Stalk","initialProofState":"X : AlgebraicGeometry.Scheme\nR : CommRingCat\ninst‚úù¬π : IsLocalRing ‚ÜëR\nx : ‚Üë‚ÜëX.toPresheafedSpace\nf : Quiver.Hom (X.presheaf.stalk x) R\ninst‚úù : IsLocalHom (CommRingCat.Hom.hom f)\nU : X.Opens\nhU : Membership.mem U ((CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Spec.map f) (X.fromSpecStalk x)).base (IsLocalRing.closedPoint ‚ÜëR))\nZ : CommRingCat\nh : Quiver.Hom R Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (X.presheaf.germ U ((CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Spec.map f) (X.fromSpecStalk x)).base (IsLocalRing.closedPoint ‚ÜëR)) hU) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.stalkClosedPointTo (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Spec.map f) (X.fromSpecStalk x))) h)) (CategoryTheory.CategoryStruct.comp (X.presheaf.germ U x ‚ãØ) (CategoryTheory.CategoryStruct.comp f h))","decl":"@[reassoc]\nlemma germ_stalkClosedPointTo_Spec_fromSpecStalk\n    {x : X} (f : X.presheaf.stalk x ‚ü∂ R) [IsLocalHom f.hom] (U : Opens X) (hU) :\n    X.presheaf.germ U _ hU ‚â´ stalkClosedPointTo (Spec.map f ‚â´ X.fromSpecStalk x) =\n      X.presheaf.germ U x (by simpa using hU) ‚â´ f := by\n  have : (Spec.map f ‚â´ X.fromSpecStalk x).base (closedPoint R) = x := by\n    rw [comp_base_apply, Spec_closedPoint, fromSpecStalk_closedPoint]\n  have : x ‚àà U := this ‚ñ∏ hU\n  simp only [TopCat.Presheaf.stalkCongr_hom, TopCat.Presheaf.germ_stalkSpecializes_assoc,\n    germ_stalkClosedPointTo, comp_app,\n    fromSpecStalk_app (X := X) (x := x) this, Category.assoc, Iso.trans_hom,\n    Functor.mapIso_hom, Hom.naturality_assoc, ‚Üê Functor.map_comp_assoc,\n    (Spec.map f).app_eq_appLE, Hom.appLE_map_assoc, Hom.map_appLE_assoc]\n  simp_rw [‚Üê Opens.map_top (Spec.map f).base]\n  rw [‚Üê (Spec.map f).app_eq_appLE, ŒìSpecIso_naturality, Iso.inv_hom_id_assoc]\n\n"}
{"name":"AlgebraicGeometry.Scheme.germ_stalkClosedPointTo_Spec_fromSpecStalk","module":"Mathlib.AlgebraicGeometry.Stalk","initialProofState":"X : AlgebraicGeometry.Scheme\nR : CommRingCat\ninst‚úù¬π : IsLocalRing ‚ÜëR\nx : ‚Üë‚ÜëX.toPresheafedSpace\nf : Quiver.Hom (X.presheaf.stalk x) R\ninst‚úù : IsLocalHom (CommRingCat.Hom.hom f)\nU : X.Opens\nhU : Membership.mem U ((CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Spec.map f) (X.fromSpecStalk x)).base (IsLocalRing.closedPoint ‚ÜëR))\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (X.presheaf.germ U ((CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Spec.map f) (X.fromSpecStalk x)).base (IsLocalRing.closedPoint ‚ÜëR)) hU) (AlgebraicGeometry.Scheme.stalkClosedPointTo (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Spec.map f) (X.fromSpecStalk x)))) (CategoryTheory.CategoryStruct.comp (X.presheaf.germ U x ‚ãØ) f)","decl":"@[reassoc]\nlemma germ_stalkClosedPointTo_Spec_fromSpecStalk\n    {x : X} (f : X.presheaf.stalk x ‚ü∂ R) [IsLocalHom f.hom] (U : Opens X) (hU) :\n    X.presheaf.germ U _ hU ‚â´ stalkClosedPointTo (Spec.map f ‚â´ X.fromSpecStalk x) =\n      X.presheaf.germ U x (by simpa using hU) ‚â´ f := by\n  have : (Spec.map f ‚â´ X.fromSpecStalk x).base (closedPoint R) = x := by\n    rw [comp_base_apply, Spec_closedPoint, fromSpecStalk_closedPoint]\n  have : x ‚àà U := this ‚ñ∏ hU\n  simp only [TopCat.Presheaf.stalkCongr_hom, TopCat.Presheaf.germ_stalkSpecializes_assoc,\n    germ_stalkClosedPointTo, comp_app,\n    fromSpecStalk_app (X := X) (x := x) this, Category.assoc, Iso.trans_hom,\n    Functor.mapIso_hom, Hom.naturality_assoc, ‚Üê Functor.map_comp_assoc,\n    (Spec.map f).app_eq_appLE, Hom.appLE_map_assoc, Hom.map_appLE_assoc]\n  simp_rw [‚Üê Opens.map_top (Spec.map f).base]\n  rw [‚Üê (Spec.map f).app_eq_appLE, ŒìSpecIso_naturality, Iso.inv_hom_id_assoc]\n\n"}
{"name":"AlgebraicGeometry.Scheme.stalkClosedPointTo_fromSpecStalk","module":"Mathlib.AlgebraicGeometry.Stalk","initialProofState":"X : AlgebraicGeometry.Scheme\nx : ‚Üë‚ÜëX.toPresheafedSpace\n‚ä¢ Eq (AlgebraicGeometry.Scheme.stalkClosedPointTo (X.fromSpecStalk x)) (X.presheaf.stalkCongr ‚ãØ).hom","decl":"lemma stalkClosedPointTo_fromSpecStalk (x : X) :\n    stalkClosedPointTo (X.fromSpecStalk x) =\n      (X.presheaf.stalkCongr (by rw [fromSpecStalk_closedPoint]; rfl)).hom := by\n  refine TopCat.Presheaf.stalk_hom_ext _ fun U hxU ‚Ü¶ ?_\n  simp only [TopCat.Presheaf.stalkCongr_hom, TopCat.Presheaf.germ_stalkSpecializes, id_eq]\n  have : X.fromSpecStalk x = Spec.map (ùüô (X.presheaf.stalk x)) ‚â´ X.fromSpecStalk x := by simp\n  convert germ_stalkClosedPointTo_Spec_fromSpecStalk (ùüô (X.presheaf.stalk x)) U hxU\n\n"}
{"name":"AlgebraicGeometry.Scheme.Spec_stalkClosedPointTo_fromSpecStalk_assoc","module":"Mathlib.AlgebraicGeometry.Stalk","initialProofState":"X : AlgebraicGeometry.Scheme\nR : CommRingCat\ninst‚úù : IsLocalRing ‚ÜëR\nf : Quiver.Hom (AlgebraicGeometry.Spec R) X\nZ : AlgebraicGeometry.Scheme\nh : Quiver.Hom X Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Spec.map (AlgebraicGeometry.Scheme.stalkClosedPointTo f)) (CategoryTheory.CategoryStruct.comp (X.fromSpecStalk (f.base (IsLocalRing.closedPoint ‚ÜëR))) h)) (CategoryTheory.CategoryStruct.comp f h)","decl":"@[reassoc]\nlemma Spec_stalkClosedPointTo_fromSpecStalk :\n    Spec.map (stalkClosedPointTo f) ‚â´ X.fromSpecStalk _ = f := by\n  obtain ‚ü®_, ‚ü®U, hU, rfl‚ü©, hxU, -‚ü© := (isBasis_affine_open X).exists_subset_of_mem_open\n    (Set.mem_univ (f.base (closedPoint R))) isOpen_univ\n  have := IsAffineOpen.Spec_map_appLE_fromSpec f hU (isAffineOpen_top _)\n    (preimage_eq_top_of_closedPoint_mem f hxU).ge\n  rw [IsAffineOpen.fromSpec_top, Iso.eq_inv_comp, isoSpec_Spec_hom] at this\n  rw [‚Üê hU.fromSpecStalk_eq_fromSpecStalk hxU, IsAffineOpen.fromSpecStalk, ‚Üê Spec.map_comp_assoc,\n    germ_stalkClosedPointTo]\n  simpa only [Iso.trans_hom, Functor.mapIso_hom, Iso.op_hom, Category.assoc,\n    Hom.app_eq_appLE, Hom.appLE_map_assoc, Spec.map_comp_assoc]\n\n"}
{"name":"AlgebraicGeometry.Scheme.Spec_stalkClosedPointTo_fromSpecStalk","module":"Mathlib.AlgebraicGeometry.Stalk","initialProofState":"X : AlgebraicGeometry.Scheme\nR : CommRingCat\ninst‚úù : IsLocalRing ‚ÜëR\nf : Quiver.Hom (AlgebraicGeometry.Spec R) X\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Spec.map (AlgebraicGeometry.Scheme.stalkClosedPointTo f)) (X.fromSpecStalk (f.base (IsLocalRing.closedPoint ‚ÜëR)))) f","decl":"@[reassoc]\nlemma Spec_stalkClosedPointTo_fromSpecStalk :\n    Spec.map (stalkClosedPointTo f) ‚â´ X.fromSpecStalk _ = f := by\n  obtain ‚ü®_, ‚ü®U, hU, rfl‚ü©, hxU, -‚ü© := (isBasis_affine_open X).exists_subset_of_mem_open\n    (Set.mem_univ (f.base (closedPoint R))) isOpen_univ\n  have := IsAffineOpen.Spec_map_appLE_fromSpec f hU (isAffineOpen_top _)\n    (preimage_eq_top_of_closedPoint_mem f hxU).ge\n  rw [IsAffineOpen.fromSpec_top, Iso.eq_inv_comp, isoSpec_Spec_hom] at this\n  rw [‚Üê hU.fromSpecStalk_eq_fromSpecStalk hxU, IsAffineOpen.fromSpecStalk, ‚Üê Spec.map_comp_assoc,\n    germ_stalkClosedPointTo]\n  simpa only [Iso.trans_hom, Functor.mapIso_hom, Iso.op_hom, Category.assoc,\n    Hom.app_eq_appLE, Hom.appLE_map_assoc, Spec.map_comp_assoc]\n\n"}
{"name":"AlgebraicGeometry.SpecToEquivOfLocalRing_eq_iff","module":"Mathlib.AlgebraicGeometry.Stalk","initialProofState":"X : AlgebraicGeometry.Scheme\nR : CommRingCat\nf‚ÇÅ f‚ÇÇ : Sigma fun x => Subtype fun f => IsLocalHom (CommRingCat.Hom.hom f)\n‚ä¢ Iff (Eq f‚ÇÅ f‚ÇÇ) (Exists fun h‚ÇÅ => Eq (‚Üëf‚ÇÅ.snd) (CategoryTheory.CategoryStruct.comp (X.presheaf.stalkCongr ‚ãØ).hom ‚Üëf‚ÇÇ.snd))","decl":"omit [IsLocalRing R] in\n/-- useful lemma for applications of `SpecToEquivOfLocalRing` -/\nlemma SpecToEquivOfLocalRing_eq_iff\n    {f‚ÇÅ f‚ÇÇ : Œ£ x, { f : X.presheaf.stalk x ‚ü∂ R // IsLocalHom f.hom }} :\n    f‚ÇÅ = f‚ÇÇ ‚Üî ‚àÉ h‚ÇÅ : f‚ÇÅ.1 = f‚ÇÇ.1, f‚ÇÅ.2.1 =\n      (X.presheaf.stalkCongr (by rw [h‚ÇÅ]; rfl)).hom ‚â´ f‚ÇÇ.2.1 := by\n  constructor\n  ¬∑ rintro rfl; simp\n  ¬∑ obtain ‚ü®x‚ÇÅ, ‚ü®f‚ÇÅ, h‚ÇÅ‚ü©‚ü© := f‚ÇÅ\n    obtain ‚ü®x‚ÇÇ, ‚ü®f‚ÇÇ, h‚ÇÇ‚ü©‚ü© := f‚ÇÇ\n    rintro ‚ü®rfl : x‚ÇÅ = x‚ÇÇ, e : f‚ÇÅ = _‚ü©\n    simp [e]\n\n"}
{"name":"AlgebraicGeometry.SpecToEquivOfLocalRing_apply_fst","module":"Mathlib.AlgebraicGeometry.Stalk","initialProofState":"X : AlgebraicGeometry.Scheme\nR : CommRingCat\ninst‚úù : IsLocalRing ‚ÜëR\nf : Quiver.Hom (AlgebraicGeometry.Spec R) X\n‚ä¢ Eq ((AlgebraicGeometry.SpecToEquivOfLocalRing X R) f).fst (f.base (IsLocalRing.closedPoint ‚ÜëR))","decl":"/--\nGiven a local ring `R` and scheme `X`, morphisms `Spec R ‚ü∂ X` corresponds to pairs\n`(x, f)` where `x : X` and `f : ùí™_{X, x} ‚ü∂ R` is a local ring homomorphism.\n-/\n@[simps]\nnoncomputable\ndef SpecToEquivOfLocalRing :\n    (Spec R ‚ü∂ X) ‚âÉ Œ£ x, { f : X.presheaf.stalk x ‚ü∂ R // IsLocalHom f.hom } where\n  toFun f := ‚ü®f.base (closedPoint R), Scheme.stalkClosedPointTo f, inferInstance‚ü©\n  invFun xf := Spec.map xf.2.1 ‚â´ X.fromSpecStalk xf.1\n  left_inv := Scheme.Spec_stalkClosedPointTo_fromSpecStalk\n  right_inv xf := by\n    obtain ‚ü®x, ‚ü®f, hf‚ü©‚ü© := xf\n    symm\n    refine SpecToEquivOfLocalRing_eq_iff.mpr ‚ü®?_, ?_‚ü©\n    ¬∑ simp only [Scheme.comp_coeBase, TopCat.coe_comp, Function.comp_apply, Spec_closedPoint,\n        Scheme.fromSpecStalk_closedPoint]\n    ¬∑ refine TopCat.Presheaf.stalk_hom_ext _ fun U hxU ‚Ü¶ ?_\n      simp only [Scheme.germ_stalkClosedPointTo_Spec_fromSpecStalk,\n        TopCat.Presheaf.stalkCongr_hom, TopCat.Presheaf.germ_stalkSpecializes_assoc]\n\n"}
{"name":"AlgebraicGeometry.SpecToEquivOfLocalRing_apply_snd_coe","module":"Mathlib.AlgebraicGeometry.Stalk","initialProofState":"X : AlgebraicGeometry.Scheme\nR : CommRingCat\ninst‚úù : IsLocalRing ‚ÜëR\nf : Quiver.Hom (AlgebraicGeometry.Spec R) X\n‚ä¢ Eq (‚Üë((AlgebraicGeometry.SpecToEquivOfLocalRing X R) f).snd) (AlgebraicGeometry.Scheme.stalkClosedPointTo f)","decl":"/--\nGiven a local ring `R` and scheme `X`, morphisms `Spec R ‚ü∂ X` corresponds to pairs\n`(x, f)` where `x : X` and `f : ùí™_{X, x} ‚ü∂ R` is a local ring homomorphism.\n-/\n@[simps]\nnoncomputable\ndef SpecToEquivOfLocalRing :\n    (Spec R ‚ü∂ X) ‚âÉ Œ£ x, { f : X.presheaf.stalk x ‚ü∂ R // IsLocalHom f.hom } where\n  toFun f := ‚ü®f.base (closedPoint R), Scheme.stalkClosedPointTo f, inferInstance‚ü©\n  invFun xf := Spec.map xf.2.1 ‚â´ X.fromSpecStalk xf.1\n  left_inv := Scheme.Spec_stalkClosedPointTo_fromSpecStalk\n  right_inv xf := by\n    obtain ‚ü®x, ‚ü®f, hf‚ü©‚ü© := xf\n    symm\n    refine SpecToEquivOfLocalRing_eq_iff.mpr ‚ü®?_, ?_‚ü©\n    ¬∑ simp only [Scheme.comp_coeBase, TopCat.coe_comp, Function.comp_apply, Spec_closedPoint,\n        Scheme.fromSpecStalk_closedPoint]\n    ¬∑ refine TopCat.Presheaf.stalk_hom_ext _ fun U hxU ‚Ü¶ ?_\n      simp only [Scheme.germ_stalkClosedPointTo_Spec_fromSpecStalk,\n        TopCat.Presheaf.stalkCongr_hom, TopCat.Presheaf.germ_stalkSpecializes_assoc]\n\n"}
{"name":"AlgebraicGeometry.SpecToEquivOfLocalRing_symm_apply","module":"Mathlib.AlgebraicGeometry.Stalk","initialProofState":"X : AlgebraicGeometry.Scheme\nR : CommRingCat\ninst‚úù : IsLocalRing ‚ÜëR\nxf : Sigma fun x => Subtype fun f => IsLocalHom (CommRingCat.Hom.hom f)\n‚ä¢ Eq ((AlgebraicGeometry.SpecToEquivOfLocalRing X R).symm xf) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Spec.map ‚Üëxf.snd) (X.fromSpecStalk xf.fst))","decl":"/--\nGiven a local ring `R` and scheme `X`, morphisms `Spec R ‚ü∂ X` corresponds to pairs\n`(x, f)` where `x : X` and `f : ùí™_{X, x} ‚ü∂ R` is a local ring homomorphism.\n-/\n@[simps]\nnoncomputable\ndef SpecToEquivOfLocalRing :\n    (Spec R ‚ü∂ X) ‚âÉ Œ£ x, { f : X.presheaf.stalk x ‚ü∂ R // IsLocalHom f.hom } where\n  toFun f := ‚ü®f.base (closedPoint R), Scheme.stalkClosedPointTo f, inferInstance‚ü©\n  invFun xf := Spec.map xf.2.1 ‚â´ X.fromSpecStalk xf.1\n  left_inv := Scheme.Spec_stalkClosedPointTo_fromSpecStalk\n  right_inv xf := by\n    obtain ‚ü®x, ‚ü®f, hf‚ü©‚ü© := xf\n    symm\n    refine SpecToEquivOfLocalRing_eq_iff.mpr ‚ü®?_, ?_‚ü©\n    ¬∑ simp only [Scheme.comp_coeBase, TopCat.coe_comp, Function.comp_apply, Spec_closedPoint,\n        Scheme.fromSpecStalk_closedPoint]\n    ¬∑ refine TopCat.Presheaf.stalk_hom_ext _ fun U hxU ‚Ü¶ ?_\n      simp only [Scheme.germ_stalkClosedPointTo_Spec_fromSpecStalk,\n        TopCat.Presheaf.stalkCongr_hom, TopCat.Presheaf.germ_stalkSpecializes_assoc]\n\n"}
