{"name":"Subgroup.coe_comap","module":"Mathlib.Algebra.Group.Subgroup.Map","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nN : Type u_5\ninst✝ : Group N\nK : Subgroup N\nf : MonoidHom G N\n⊢ Eq (↑(Subgroup.comap f K)) (Set.preimage ⇑f ↑K)","decl":"@[to_additive (attr := simp)]\ntheorem coe_comap (K : Subgroup N) (f : G →* N) : (K.comap f : Set G) = f ⁻¹' K :=\n  rfl\n\n"}
{"name":"AddSubgroup.coe_comap","module":"Mathlib.Algebra.Group.Subgroup.Map","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nN : Type u_5\ninst✝ : AddGroup N\nK : AddSubgroup N\nf : AddMonoidHom G N\n⊢ Eq (↑(AddSubgroup.comap f K)) (Set.preimage ⇑f ↑K)","decl":"@[to_additive (attr := simp)]\ntheorem coe_comap (K : Subgroup N) (f : G →* N) : (K.comap f : Set G) = f ⁻¹' K :=\n  rfl\n\n"}
{"name":"AddSubgroup.mem_comap","module":"Mathlib.Algebra.Group.Subgroup.Map","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nN : Type u_5\ninst✝ : AddGroup N\nK : AddSubgroup N\nf : AddMonoidHom G N\nx : G\n⊢ Iff (Membership.mem (AddSubgroup.comap f K) x) (Membership.mem K (f x))","decl":"@[to_additive (attr := simp)]\ntheorem mem_comap {K : Subgroup N} {f : G →* N} {x : G} : x ∈ K.comap f ↔ f x ∈ K :=\n  Iff.rfl\n\n"}
{"name":"Subgroup.mem_comap","module":"Mathlib.Algebra.Group.Subgroup.Map","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nN : Type u_5\ninst✝ : Group N\nK : Subgroup N\nf : MonoidHom G N\nx : G\n⊢ Iff (Membership.mem (Subgroup.comap f K) x) (Membership.mem K (f x))","decl":"@[to_additive (attr := simp)]\ntheorem mem_comap {K : Subgroup N} {f : G →* N} {x : G} : x ∈ K.comap f ↔ f x ∈ K :=\n  Iff.rfl\n\n"}
{"name":"AddSubgroup.comap_mono","module":"Mathlib.Algebra.Group.Subgroup.Map","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nN : Type u_5\ninst✝ : AddGroup N\nf : AddMonoidHom G N\nK K' : AddSubgroup N\na✝ : LE.le K K'\n⊢ LE.le (AddSubgroup.comap f K) (AddSubgroup.comap f K')","decl":"@[to_additive]\ntheorem comap_mono {f : G →* N} {K K' : Subgroup N} : K ≤ K' → comap f K ≤ comap f K' :=\n  preimage_mono\n\n"}
{"name":"Subgroup.comap_mono","module":"Mathlib.Algebra.Group.Subgroup.Map","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nN : Type u_5\ninst✝ : Group N\nf : MonoidHom G N\nK K' : Subgroup N\na✝ : LE.le K K'\n⊢ LE.le (Subgroup.comap f K) (Subgroup.comap f K')","decl":"@[to_additive]\ntheorem comap_mono {f : G →* N} {K K' : Subgroup N} : K ≤ K' → comap f K ≤ comap f K' :=\n  preimage_mono\n\n"}
{"name":"Subgroup.comap_comap","module":"Mathlib.Algebra.Group.Subgroup.Map","initialProofState":"G : Type u_1\ninst✝² : Group G\nN : Type u_5\ninst✝¹ : Group N\nP : Type u_6\ninst✝ : Group P\nK : Subgroup P\ng : MonoidHom N P\nf : MonoidHom G N\n⊢ Eq (Subgroup.comap f (Subgroup.comap g K)) (Subgroup.comap (g.comp f) K)","decl":"@[to_additive]\ntheorem comap_comap (K : Subgroup P) (g : N →* P) (f : G →* N) :\n    (K.comap g).comap f = K.comap (g.comp f) :=\n  rfl\n\n"}
{"name":"AddSubgroup.comap_comap","module":"Mathlib.Algebra.Group.Subgroup.Map","initialProofState":"G : Type u_1\ninst✝² : AddGroup G\nN : Type u_5\ninst✝¹ : AddGroup N\nP : Type u_6\ninst✝ : AddGroup P\nK : AddSubgroup P\ng : AddMonoidHom N P\nf : AddMonoidHom G N\n⊢ Eq (AddSubgroup.comap f (AddSubgroup.comap g K)) (AddSubgroup.comap (g.comp f) K)","decl":"@[to_additive]\ntheorem comap_comap (K : Subgroup P) (g : N →* P) (f : G →* N) :\n    (K.comap g).comap f = K.comap (g.comp f) :=\n  rfl\n\n"}
{"name":"Subgroup.comap_id","module":"Mathlib.Algebra.Group.Subgroup.Map","initialProofState":"N : Type u_5\ninst✝ : Group N\nK : Subgroup N\n⊢ Eq (Subgroup.comap (MonoidHom.id N) K) K","decl":"@[to_additive (attr := simp)]\ntheorem comap_id (K : Subgroup N) : K.comap (MonoidHom.id _) = K := by\n  ext\n  rfl\n\n"}
{"name":"AddSubgroup.comap_id","module":"Mathlib.Algebra.Group.Subgroup.Map","initialProofState":"N : Type u_5\ninst✝ : AddGroup N\nK : AddSubgroup N\n⊢ Eq (AddSubgroup.comap (AddMonoidHom.id N) K) K","decl":"@[to_additive (attr := simp)]\ntheorem comap_id (K : Subgroup N) : K.comap (MonoidHom.id _) = K := by\n  ext\n  rfl\n\n"}
{"name":"Subgroup.toAddSubgroup_comap","module":"Mathlib.Algebra.Group.Subgroup.Map","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nG₂ : Type u_7\ninst✝ : Group G₂\nf : MonoidHom G G₂\ns : Subgroup G₂\n⊢ Eq (AddSubgroup.comap (MonoidHom.toAdditive f) (Subgroup.toAddSubgroup s)) (Subgroup.toAddSubgroup (Subgroup.comap f s))","decl":"@[simp]\ntheorem toAddSubgroup_comap {G₂ : Type*} [Group G₂] (f : G →* G₂) (s : Subgroup G₂) :\n    s.toAddSubgroup.comap (MonoidHom.toAdditive f) = Subgroup.toAddSubgroup (s.comap f) := rfl\n\n"}
{"name":"AddSubgroup.toSubgroup_comap","module":"Mathlib.Algebra.Group.Subgroup.Map","initialProofState":"A : Type u_7\nA₂ : Type u_8\ninst✝¹ : AddGroup A\ninst✝ : AddGroup A₂\nf : AddMonoidHom A A₂\ns : AddSubgroup A₂\n⊢ Eq (Subgroup.comap (AddMonoidHom.toMultiplicative f) (AddSubgroup.toSubgroup s)) (AddSubgroup.toSubgroup (AddSubgroup.comap f s))","decl":"@[simp]\ntheorem _root_.AddSubgroup.toSubgroup_comap {A A₂ : Type*} [AddGroup A] [AddGroup A₂]\n    (f : A →+ A₂) (s : AddSubgroup A₂) :\n    s.toSubgroup.comap (AddMonoidHom.toMultiplicative f) = AddSubgroup.toSubgroup (s.comap f) := rfl\n\n"}
{"name":"Subgroup.coe_map","module":"Mathlib.Algebra.Group.Subgroup.Map","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nN : Type u_5\ninst✝ : Group N\nf : MonoidHom G N\nK : Subgroup G\n⊢ Eq (↑(Subgroup.map f K)) (Set.image ⇑f ↑K)","decl":"@[to_additive (attr := simp)]\ntheorem coe_map (f : G →* N) (K : Subgroup G) : (K.map f : Set N) = f '' K :=\n  rfl\n\n"}
{"name":"AddSubgroup.coe_map","module":"Mathlib.Algebra.Group.Subgroup.Map","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nN : Type u_5\ninst✝ : AddGroup N\nf : AddMonoidHom G N\nK : AddSubgroup G\n⊢ Eq (↑(AddSubgroup.map f K)) (Set.image ⇑f ↑K)","decl":"@[to_additive (attr := simp)]\ntheorem coe_map (f : G →* N) (K : Subgroup G) : (K.map f : Set N) = f '' K :=\n  rfl\n\n"}
{"name":"AddSubgroup.mem_map","module":"Mathlib.Algebra.Group.Subgroup.Map","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nN : Type u_5\ninst✝ : AddGroup N\nf : AddMonoidHom G N\nK : AddSubgroup G\ny : N\n⊢ Iff (Membership.mem (AddSubgroup.map f K) y) (Exists fun x => And (Membership.mem K x) (Eq (f x) y))","decl":"@[to_additive (attr := simp)]\ntheorem mem_map {f : G →* N} {K : Subgroup G} {y : N} : y ∈ K.map f ↔ ∃ x ∈ K, f x = y := Iff.rfl\n\n"}
{"name":"Subgroup.mem_map","module":"Mathlib.Algebra.Group.Subgroup.Map","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nN : Type u_5\ninst✝ : Group N\nf : MonoidHom G N\nK : Subgroup G\ny : N\n⊢ Iff (Membership.mem (Subgroup.map f K) y) (Exists fun x => And (Membership.mem K x) (Eq (f x) y))","decl":"@[to_additive (attr := simp)]\ntheorem mem_map {f : G →* N} {K : Subgroup G} {y : N} : y ∈ K.map f ↔ ∃ x ∈ K, f x = y := Iff.rfl\n\n"}
{"name":"AddSubgroup.mem_map_of_mem","module":"Mathlib.Algebra.Group.Subgroup.Map","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nN : Type u_5\ninst✝ : AddGroup N\nf : AddMonoidHom G N\nK : AddSubgroup G\nx : G\nhx : Membership.mem K x\n⊢ Membership.mem (AddSubgroup.map f K) (f x)","decl":"@[to_additive]\ntheorem mem_map_of_mem (f : G →* N) {K : Subgroup G} {x : G} (hx : x ∈ K) : f x ∈ K.map f :=\n  mem_image_of_mem f hx\n\n"}
{"name":"Subgroup.mem_map_of_mem","module":"Mathlib.Algebra.Group.Subgroup.Map","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nN : Type u_5\ninst✝ : Group N\nf : MonoidHom G N\nK : Subgroup G\nx : G\nhx : Membership.mem K x\n⊢ Membership.mem (Subgroup.map f K) (f x)","decl":"@[to_additive]\ntheorem mem_map_of_mem (f : G →* N) {K : Subgroup G} {x : G} (hx : x ∈ K) : f x ∈ K.map f :=\n  mem_image_of_mem f hx\n\n"}
{"name":"AddSubgroup.apply_coe_mem_map","module":"Mathlib.Algebra.Group.Subgroup.Map","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nN : Type u_5\ninst✝ : AddGroup N\nf : AddMonoidHom G N\nK : AddSubgroup G\nx : Subtype fun x => Membership.mem K x\n⊢ Membership.mem (AddSubgroup.map f K) (f ↑x)","decl":"@[to_additive]\ntheorem apply_coe_mem_map (f : G →* N) (K : Subgroup G) (x : K) : f x ∈ K.map f :=\n  mem_map_of_mem f x.prop\n\n"}
{"name":"Subgroup.apply_coe_mem_map","module":"Mathlib.Algebra.Group.Subgroup.Map","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nN : Type u_5\ninst✝ : Group N\nf : MonoidHom G N\nK : Subgroup G\nx : Subtype fun x => Membership.mem K x\n⊢ Membership.mem (Subgroup.map f K) (f ↑x)","decl":"@[to_additive]\ntheorem apply_coe_mem_map (f : G →* N) (K : Subgroup G) (x : K) : f x ∈ K.map f :=\n  mem_map_of_mem f x.prop\n\n"}
{"name":"Subgroup.map_mono","module":"Mathlib.Algebra.Group.Subgroup.Map","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nN : Type u_5\ninst✝ : Group N\nf : MonoidHom G N\nK K' : Subgroup G\na✝ : LE.le K K'\n⊢ LE.le (Subgroup.map f K) (Subgroup.map f K')","decl":"@[to_additive]\ntheorem map_mono {f : G →* N} {K K' : Subgroup G} : K ≤ K' → map f K ≤ map f K' :=\n  image_subset _\n\n"}
{"name":"AddSubgroup.map_mono","module":"Mathlib.Algebra.Group.Subgroup.Map","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nN : Type u_5\ninst✝ : AddGroup N\nf : AddMonoidHom G N\nK K' : AddSubgroup G\na✝ : LE.le K K'\n⊢ LE.le (AddSubgroup.map f K) (AddSubgroup.map f K')","decl":"@[to_additive]\ntheorem map_mono {f : G →* N} {K K' : Subgroup G} : K ≤ K' → map f K ≤ map f K' :=\n  image_subset _\n\n"}
{"name":"Subgroup.map_id","module":"Mathlib.Algebra.Group.Subgroup.Map","initialProofState":"G : Type u_1\ninst✝ : Group G\nK : Subgroup G\n⊢ Eq (Subgroup.map (MonoidHom.id G) K) K","decl":"@[to_additive (attr := simp)]\ntheorem map_id : K.map (MonoidHom.id G) = K :=\n  SetLike.coe_injective <| image_id _\n\n"}
{"name":"AddSubgroup.map_id","module":"Mathlib.Algebra.Group.Subgroup.Map","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nK : AddSubgroup G\n⊢ Eq (AddSubgroup.map (AddMonoidHom.id G) K) K","decl":"@[to_additive (attr := simp)]\ntheorem map_id : K.map (MonoidHom.id G) = K :=\n  SetLike.coe_injective <| image_id _\n\n"}
{"name":"Subgroup.map_map","module":"Mathlib.Algebra.Group.Subgroup.Map","initialProofState":"G : Type u_1\ninst✝² : Group G\nK : Subgroup G\nN : Type u_5\ninst✝¹ : Group N\nP : Type u_6\ninst✝ : Group P\ng : MonoidHom N P\nf : MonoidHom G N\n⊢ Eq (Subgroup.map g (Subgroup.map f K)) (Subgroup.map (g.comp f) K)","decl":"@[to_additive]\ntheorem map_map (g : N →* P) (f : G →* N) : (K.map f).map g = K.map (g.comp f) :=\n  SetLike.coe_injective <| image_image _ _ _\n\n"}
{"name":"AddSubgroup.map_map","module":"Mathlib.Algebra.Group.Subgroup.Map","initialProofState":"G : Type u_1\ninst✝² : AddGroup G\nK : AddSubgroup G\nN : Type u_5\ninst✝¹ : AddGroup N\nP : Type u_6\ninst✝ : AddGroup P\ng : AddMonoidHom N P\nf : AddMonoidHom G N\n⊢ Eq (AddSubgroup.map g (AddSubgroup.map f K)) (AddSubgroup.map (g.comp f) K)","decl":"@[to_additive]\ntheorem map_map (g : N →* P) (f : G →* N) : (K.map f).map g = K.map (g.comp f) :=\n  SetLike.coe_injective <| image_image _ _ _\n\n"}
{"name":"AddSubgroup.map_zero_eq_bot","module":"Mathlib.Algebra.Group.Subgroup.Map","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nK : AddSubgroup G\nN : Type u_5\ninst✝ : AddGroup N\n⊢ Eq (AddSubgroup.map 0 K) Bot.bot","decl":"@[to_additive (attr := simp)]\ntheorem map_one_eq_bot : K.map (1 : G →* N) = ⊥ :=\n  eq_bot_iff.mpr <| by\n    rintro x ⟨y, _, rfl⟩\n    simp\n\n"}
{"name":"Subgroup.map_one_eq_bot","module":"Mathlib.Algebra.Group.Subgroup.Map","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nK : Subgroup G\nN : Type u_5\ninst✝ : Group N\n⊢ Eq (Subgroup.map 1 K) Bot.bot","decl":"@[to_additive (attr := simp)]\ntheorem map_one_eq_bot : K.map (1 : G →* N) = ⊥ :=\n  eq_bot_iff.mpr <| by\n    rintro x ⟨y, _, rfl⟩\n    simp\n\n"}
{"name":"AddSubgroup.mem_map_equiv","module":"Mathlib.Algebra.Group.Subgroup.Map","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nN : Type u_5\ninst✝ : AddGroup N\nf : AddEquiv G N\nK : AddSubgroup G\nx : N\n⊢ Iff (Membership.mem (AddSubgroup.map f.toAddMonoidHom K) x) (Membership.mem K (f.symm x))","decl":"@[to_additive]\ntheorem mem_map_equiv {f : G ≃* N} {K : Subgroup G} {x : N} :\n    x ∈ K.map f.toMonoidHom ↔ f.symm x ∈ K := by\n  erw [@Set.mem_image_equiv _ _ (↑K) f.toEquiv x]; rfl\n\n-- The simpNF linter says that the LHS can be simplified via `Subgroup.mem_map`.\n-- However this is a higher priority lemma.\n-- https://github.com/leanprover/std4/issues/207\n"}
{"name":"Subgroup.mem_map_equiv","module":"Mathlib.Algebra.Group.Subgroup.Map","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nN : Type u_5\ninst✝ : Group N\nf : MulEquiv G N\nK : Subgroup G\nx : N\n⊢ Iff (Membership.mem (Subgroup.map f.toMonoidHom K) x) (Membership.mem K (f.symm x))","decl":"@[to_additive]\ntheorem mem_map_equiv {f : G ≃* N} {K : Subgroup G} {x : N} :\n    x ∈ K.map f.toMonoidHom ↔ f.symm x ∈ K := by\n  erw [@Set.mem_image_equiv _ _ (↑K) f.toEquiv x]; rfl\n\n-- The simpNF linter says that the LHS can be simplified via `Subgroup.mem_map`.\n-- However this is a higher priority lemma.\n-- https://github.com/leanprover/std4/issues/207\n"}
{"name":"AddSubgroup.mem_map_iff_mem","module":"Mathlib.Algebra.Group.Subgroup.Map","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nN : Type u_5\ninst✝ : AddGroup N\nf : AddMonoidHom G N\nhf : Function.Injective ⇑f\nK : AddSubgroup G\nx : G\n⊢ Iff (Membership.mem (AddSubgroup.map f K) (f x)) (Membership.mem K x)","decl":"@[to_additive (attr := simp 1100, nolint simpNF)]\ntheorem mem_map_iff_mem {f : G →* N} (hf : Function.Injective f) {K : Subgroup G} {x : G} :\n    f x ∈ K.map f ↔ x ∈ K :=\n  hf.mem_set_image\n\n"}
{"name":"Subgroup.mem_map_iff_mem","module":"Mathlib.Algebra.Group.Subgroup.Map","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nN : Type u_5\ninst✝ : Group N\nf : MonoidHom G N\nhf : Function.Injective ⇑f\nK : Subgroup G\nx : G\n⊢ Iff (Membership.mem (Subgroup.map f K) (f x)) (Membership.mem K x)","decl":"@[to_additive (attr := simp 1100, nolint simpNF)]\ntheorem mem_map_iff_mem {f : G →* N} (hf : Function.Injective f) {K : Subgroup G} {x : G} :\n    f x ∈ K.map f ↔ x ∈ K :=\n  hf.mem_set_image\n\n"}
{"name":"AddSubgroup.map_equiv_eq_comap_symm'","module":"Mathlib.Algebra.Group.Subgroup.Map","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nN : Type u_5\ninst✝ : AddGroup N\nf : AddEquiv G N\nK : AddSubgroup G\n⊢ Eq (AddSubgroup.map f.toAddMonoidHom K) (AddSubgroup.comap f.symm.toAddMonoidHom K)","decl":"@[to_additive]\ntheorem map_equiv_eq_comap_symm' (f : G ≃* N) (K : Subgroup G) :\n    K.map f.toMonoidHom = K.comap f.symm.toMonoidHom :=\n  SetLike.coe_injective (f.toEquiv.image_eq_preimage K)\n\n"}
{"name":"Subgroup.map_equiv_eq_comap_symm'","module":"Mathlib.Algebra.Group.Subgroup.Map","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nN : Type u_5\ninst✝ : Group N\nf : MulEquiv G N\nK : Subgroup G\n⊢ Eq (Subgroup.map f.toMonoidHom K) (Subgroup.comap f.symm.toMonoidHom K)","decl":"@[to_additive]\ntheorem map_equiv_eq_comap_symm' (f : G ≃* N) (K : Subgroup G) :\n    K.map f.toMonoidHom = K.comap f.symm.toMonoidHom :=\n  SetLike.coe_injective (f.toEquiv.image_eq_preimage K)\n\n"}
{"name":"AddSubgroup.map_equiv_eq_comap_symm","module":"Mathlib.Algebra.Group.Subgroup.Map","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nN : Type u_5\ninst✝ : AddGroup N\nf : AddEquiv G N\nK : AddSubgroup G\n⊢ Eq (AddSubgroup.map (↑f) K) (AddSubgroup.comap (↑f.symm) K)","decl":"@[to_additive]\ntheorem map_equiv_eq_comap_symm (f : G ≃* N) (K : Subgroup G) :\n    K.map f = K.comap (G := N) f.symm :=\n  map_equiv_eq_comap_symm' _ _\n\n"}
{"name":"Subgroup.map_equiv_eq_comap_symm","module":"Mathlib.Algebra.Group.Subgroup.Map","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nN : Type u_5\ninst✝ : Group N\nf : MulEquiv G N\nK : Subgroup G\n⊢ Eq (Subgroup.map (↑f) K) (Subgroup.comap (↑f.symm) K)","decl":"@[to_additive]\ntheorem map_equiv_eq_comap_symm (f : G ≃* N) (K : Subgroup G) :\n    K.map f = K.comap (G := N) f.symm :=\n  map_equiv_eq_comap_symm' _ _\n\n"}
{"name":"AddSubgroup.comap_equiv_eq_map_symm","module":"Mathlib.Algebra.Group.Subgroup.Map","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nN : Type u_5\ninst✝ : AddGroup N\nf : AddEquiv N G\nK : AddSubgroup G\n⊢ Eq (AddSubgroup.comap (↑f) K) (AddSubgroup.map (↑f.symm) K)","decl":"@[to_additive]\ntheorem comap_equiv_eq_map_symm (f : N ≃* G) (K : Subgroup G) :\n    K.comap (G := N) f = K.map f.symm :=\n  (map_equiv_eq_comap_symm f.symm K).symm\n\n"}
{"name":"Subgroup.comap_equiv_eq_map_symm","module":"Mathlib.Algebra.Group.Subgroup.Map","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nN : Type u_5\ninst✝ : Group N\nf : MulEquiv N G\nK : Subgroup G\n⊢ Eq (Subgroup.comap (↑f) K) (Subgroup.map (↑f.symm) K)","decl":"@[to_additive]\ntheorem comap_equiv_eq_map_symm (f : N ≃* G) (K : Subgroup G) :\n    K.comap (G := N) f = K.map f.symm :=\n  (map_equiv_eq_comap_symm f.symm K).symm\n\n"}
{"name":"Subgroup.comap_equiv_eq_map_symm'","module":"Mathlib.Algebra.Group.Subgroup.Map","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nN : Type u_5\ninst✝ : Group N\nf : MulEquiv N G\nK : Subgroup G\n⊢ Eq (Subgroup.comap f.toMonoidHom K) (Subgroup.map f.symm.toMonoidHom K)","decl":"@[to_additive]\ntheorem comap_equiv_eq_map_symm' (f : N ≃* G) (K : Subgroup G) :\n    K.comap f.toMonoidHom = K.map f.symm.toMonoidHom :=\n  (map_equiv_eq_comap_symm f.symm K).symm\n\n"}
{"name":"AddSubgroup.comap_equiv_eq_map_symm'","module":"Mathlib.Algebra.Group.Subgroup.Map","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nN : Type u_5\ninst✝ : AddGroup N\nf : AddEquiv N G\nK : AddSubgroup G\n⊢ Eq (AddSubgroup.comap f.toAddMonoidHom K) (AddSubgroup.map f.symm.toAddMonoidHom K)","decl":"@[to_additive]\ntheorem comap_equiv_eq_map_symm' (f : N ≃* G) (K : Subgroup G) :\n    K.comap f.toMonoidHom = K.map f.symm.toMonoidHom :=\n  (map_equiv_eq_comap_symm f.symm K).symm\n\n"}
{"name":"Subgroup.map_symm_eq_iff_map_eq","module":"Mathlib.Algebra.Group.Subgroup.Map","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nK : Subgroup G\nN : Type u_5\ninst✝ : Group N\nH : Subgroup N\ne : MulEquiv G N\n⊢ Iff (Eq (Subgroup.map (↑e.symm) H) K) (Eq (Subgroup.map (↑e) K) H)","decl":"@[to_additive]\ntheorem map_symm_eq_iff_map_eq {H : Subgroup N} {e : G ≃* N} :\n    H.map ↑e.symm = K ↔ K.map ↑e = H := by\n  constructor <;> rintro rfl\n  · rw [map_map, ← MulEquiv.coe_monoidHom_trans, MulEquiv.symm_trans_self,\n      MulEquiv.coe_monoidHom_refl, map_id]\n  · rw [map_map, ← MulEquiv.coe_monoidHom_trans, MulEquiv.self_trans_symm,\n      MulEquiv.coe_monoidHom_refl, map_id]\n\n"}
{"name":"AddSubgroup.map_symm_eq_iff_map_eq","module":"Mathlib.Algebra.Group.Subgroup.Map","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nK : AddSubgroup G\nN : Type u_5\ninst✝ : AddGroup N\nH : AddSubgroup N\ne : AddEquiv G N\n⊢ Iff (Eq (AddSubgroup.map (↑e.symm) H) K) (Eq (AddSubgroup.map (↑e) K) H)","decl":"@[to_additive]\ntheorem map_symm_eq_iff_map_eq {H : Subgroup N} {e : G ≃* N} :\n    H.map ↑e.symm = K ↔ K.map ↑e = H := by\n  constructor <;> rintro rfl\n  · rw [map_map, ← MulEquiv.coe_monoidHom_trans, MulEquiv.symm_trans_self,\n      MulEquiv.coe_monoidHom_refl, map_id]\n  · rw [map_map, ← MulEquiv.coe_monoidHom_trans, MulEquiv.self_trans_symm,\n      MulEquiv.coe_monoidHom_refl, map_id]\n\n"}
{"name":"Subgroup.map_le_iff_le_comap","module":"Mathlib.Algebra.Group.Subgroup.Map","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nN : Type u_5\ninst✝ : Group N\nf : MonoidHom G N\nK : Subgroup G\nH : Subgroup N\n⊢ Iff (LE.le (Subgroup.map f K) H) (LE.le K (Subgroup.comap f H))","decl":"@[to_additive]\ntheorem map_le_iff_le_comap {f : G →* N} {K : Subgroup G} {H : Subgroup N} :\n    K.map f ≤ H ↔ K ≤ H.comap f :=\n  image_subset_iff\n\n"}
{"name":"AddSubgroup.map_le_iff_le_comap","module":"Mathlib.Algebra.Group.Subgroup.Map","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nN : Type u_5\ninst✝ : AddGroup N\nf : AddMonoidHom G N\nK : AddSubgroup G\nH : AddSubgroup N\n⊢ Iff (LE.le (AddSubgroup.map f K) H) (LE.le K (AddSubgroup.comap f H))","decl":"@[to_additive]\ntheorem map_le_iff_le_comap {f : G →* N} {K : Subgroup G} {H : Subgroup N} :\n    K.map f ≤ H ↔ K ≤ H.comap f :=\n  image_subset_iff\n\n"}
{"name":"Subgroup.gc_map_comap","module":"Mathlib.Algebra.Group.Subgroup.Map","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nN : Type u_5\ninst✝ : Group N\nf : MonoidHom G N\n⊢ GaloisConnection (Subgroup.map f) (Subgroup.comap f)","decl":"@[to_additive]\ntheorem gc_map_comap (f : G →* N) : GaloisConnection (map f) (comap f) := fun _ _ =>\n  map_le_iff_le_comap\n\n"}
{"name":"AddSubgroup.gc_map_comap","module":"Mathlib.Algebra.Group.Subgroup.Map","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nN : Type u_5\ninst✝ : AddGroup N\nf : AddMonoidHom G N\n⊢ GaloisConnection (AddSubgroup.map f) (AddSubgroup.comap f)","decl":"@[to_additive]\ntheorem gc_map_comap (f : G →* N) : GaloisConnection (map f) (comap f) := fun _ _ =>\n  map_le_iff_le_comap\n\n"}
{"name":"Subgroup.map_sup","module":"Mathlib.Algebra.Group.Subgroup.Map","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nN : Type u_5\ninst✝ : Group N\nH K : Subgroup G\nf : MonoidHom G N\n⊢ Eq (Subgroup.map f (Max.max H K)) (Max.max (Subgroup.map f H) (Subgroup.map f K))","decl":"@[to_additive]\ntheorem map_sup (H K : Subgroup G) (f : G →* N) : (H ⊔ K).map f = H.map f ⊔ K.map f :=\n  (gc_map_comap f).l_sup\n\n"}
{"name":"AddSubgroup.map_sup","module":"Mathlib.Algebra.Group.Subgroup.Map","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nN : Type u_5\ninst✝ : AddGroup N\nH K : AddSubgroup G\nf : AddMonoidHom G N\n⊢ Eq (AddSubgroup.map f (Max.max H K)) (Max.max (AddSubgroup.map f H) (AddSubgroup.map f K))","decl":"@[to_additive]\ntheorem map_sup (H K : Subgroup G) (f : G →* N) : (H ⊔ K).map f = H.map f ⊔ K.map f :=\n  (gc_map_comap f).l_sup\n\n"}
{"name":"AddSubgroup.map_iSup","module":"Mathlib.Algebra.Group.Subgroup.Map","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nN : Type u_5\ninst✝ : AddGroup N\nι : Sort u_7\nf : AddMonoidHom G N\ns : ι → AddSubgroup G\n⊢ Eq (AddSubgroup.map f (iSup s)) (iSup fun i => AddSubgroup.map f (s i))","decl":"@[to_additive]\ntheorem map_iSup {ι : Sort*} (f : G →* N) (s : ι → Subgroup G) :\n    (iSup s).map f = ⨆ i, (s i).map f :=\n  (gc_map_comap f).l_iSup\n\n"}
{"name":"Subgroup.map_iSup","module":"Mathlib.Algebra.Group.Subgroup.Map","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nN : Type u_5\ninst✝ : Group N\nι : Sort u_7\nf : MonoidHom G N\ns : ι → Subgroup G\n⊢ Eq (Subgroup.map f (iSup s)) (iSup fun i => Subgroup.map f (s i))","decl":"@[to_additive]\ntheorem map_iSup {ι : Sort*} (f : G →* N) (s : ι → Subgroup G) :\n    (iSup s).map f = ⨆ i, (s i).map f :=\n  (gc_map_comap f).l_iSup\n\n"}
{"name":"AddSubgroup.map_inf","module":"Mathlib.Algebra.Group.Subgroup.Map","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nN : Type u_5\ninst✝ : AddGroup N\nH K : AddSubgroup G\nf : AddMonoidHom G N\nhf : Function.Injective ⇑f\n⊢ Eq (AddSubgroup.map f (Min.min H K)) (Min.min (AddSubgroup.map f H) (AddSubgroup.map f K))","decl":"@[to_additive]\ntheorem map_inf (H K : Subgroup G) (f : G →* N) (hf : Function.Injective f) :\n    (H ⊓ K).map f = H.map f ⊓ K.map f := SetLike.coe_injective (Set.image_inter hf)\n\n"}
{"name":"Subgroup.map_inf","module":"Mathlib.Algebra.Group.Subgroup.Map","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nN : Type u_5\ninst✝ : Group N\nH K : Subgroup G\nf : MonoidHom G N\nhf : Function.Injective ⇑f\n⊢ Eq (Subgroup.map f (Min.min H K)) (Min.min (Subgroup.map f H) (Subgroup.map f K))","decl":"@[to_additive]\ntheorem map_inf (H K : Subgroup G) (f : G →* N) (hf : Function.Injective f) :\n    (H ⊓ K).map f = H.map f ⊓ K.map f := SetLike.coe_injective (Set.image_inter hf)\n\n"}
{"name":"Subgroup.map_iInf","module":"Mathlib.Algebra.Group.Subgroup.Map","initialProofState":"G : Type u_1\ninst✝² : Group G\nN : Type u_5\ninst✝¹ : Group N\nι : Sort u_7\ninst✝ : Nonempty ι\nf : MonoidHom G N\nhf : Function.Injective ⇑f\ns : ι → Subgroup G\n⊢ Eq (Subgroup.map f (iInf s)) (iInf fun i => Subgroup.map f (s i))","decl":"@[to_additive]\ntheorem map_iInf {ι : Sort*} [Nonempty ι] (f : G →* N) (hf : Function.Injective f)\n    (s : ι → Subgroup G) : (iInf s).map f = ⨅ i, (s i).map f := by\n  apply SetLike.coe_injective\n  simpa using (Set.injOn_of_injective hf).image_iInter_eq (s := SetLike.coe ∘ s)\n\n"}
{"name":"AddSubgroup.map_iInf","module":"Mathlib.Algebra.Group.Subgroup.Map","initialProofState":"G : Type u_1\ninst✝² : AddGroup G\nN : Type u_5\ninst✝¹ : AddGroup N\nι : Sort u_7\ninst✝ : Nonempty ι\nf : AddMonoidHom G N\nhf : Function.Injective ⇑f\ns : ι → AddSubgroup G\n⊢ Eq (AddSubgroup.map f (iInf s)) (iInf fun i => AddSubgroup.map f (s i))","decl":"@[to_additive]\ntheorem map_iInf {ι : Sort*} [Nonempty ι] (f : G →* N) (hf : Function.Injective f)\n    (s : ι → Subgroup G) : (iInf s).map f = ⨅ i, (s i).map f := by\n  apply SetLike.coe_injective\n  simpa using (Set.injOn_of_injective hf).image_iInter_eq (s := SetLike.coe ∘ s)\n\n"}
{"name":"Subgroup.comap_sup_comap_le","module":"Mathlib.Algebra.Group.Subgroup.Map","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nN : Type u_5\ninst✝ : Group N\nH K : Subgroup N\nf : MonoidHom G N\n⊢ LE.le (Max.max (Subgroup.comap f H) (Subgroup.comap f K)) (Subgroup.comap f (Max.max H K))","decl":"@[to_additive]\ntheorem comap_sup_comap_le (H K : Subgroup N) (f : G →* N) :\n    comap f H ⊔ comap f K ≤ comap f (H ⊔ K) :=\n  Monotone.le_map_sup (fun _ _ => comap_mono) H K\n\n"}
{"name":"AddSubgroup.comap_sup_comap_le","module":"Mathlib.Algebra.Group.Subgroup.Map","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nN : Type u_5\ninst✝ : AddGroup N\nH K : AddSubgroup N\nf : AddMonoidHom G N\n⊢ LE.le (Max.max (AddSubgroup.comap f H) (AddSubgroup.comap f K)) (AddSubgroup.comap f (Max.max H K))","decl":"@[to_additive]\ntheorem comap_sup_comap_le (H K : Subgroup N) (f : G →* N) :\n    comap f H ⊔ comap f K ≤ comap f (H ⊔ K) :=\n  Monotone.le_map_sup (fun _ _ => comap_mono) H K\n\n"}
{"name":"Subgroup.iSup_comap_le","module":"Mathlib.Algebra.Group.Subgroup.Map","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nN : Type u_5\ninst✝ : Group N\nι : Sort u_7\nf : MonoidHom G N\ns : ι → Subgroup N\n⊢ LE.le (iSup fun i => Subgroup.comap f (s i)) (Subgroup.comap f (iSup s))","decl":"@[to_additive]\ntheorem iSup_comap_le {ι : Sort*} (f : G →* N) (s : ι → Subgroup N) :\n    ⨆ i, (s i).comap f ≤ (iSup s).comap f :=\n  Monotone.le_map_iSup fun _ _ => comap_mono\n\n"}
{"name":"AddSubgroup.iSup_comap_le","module":"Mathlib.Algebra.Group.Subgroup.Map","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nN : Type u_5\ninst✝ : AddGroup N\nι : Sort u_7\nf : AddMonoidHom G N\ns : ι → AddSubgroup N\n⊢ LE.le (iSup fun i => AddSubgroup.comap f (s i)) (AddSubgroup.comap f (iSup s))","decl":"@[to_additive]\ntheorem iSup_comap_le {ι : Sort*} (f : G →* N) (s : ι → Subgroup N) :\n    ⨆ i, (s i).comap f ≤ (iSup s).comap f :=\n  Monotone.le_map_iSup fun _ _ => comap_mono\n\n"}
{"name":"Subgroup.comap_inf","module":"Mathlib.Algebra.Group.Subgroup.Map","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nN : Type u_5\ninst✝ : Group N\nH K : Subgroup N\nf : MonoidHom G N\n⊢ Eq (Subgroup.comap f (Min.min H K)) (Min.min (Subgroup.comap f H) (Subgroup.comap f K))","decl":"@[to_additive]\ntheorem comap_inf (H K : Subgroup N) (f : G →* N) : (H ⊓ K).comap f = H.comap f ⊓ K.comap f :=\n  (gc_map_comap f).u_inf\n\n"}
{"name":"AddSubgroup.comap_inf","module":"Mathlib.Algebra.Group.Subgroup.Map","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nN : Type u_5\ninst✝ : AddGroup N\nH K : AddSubgroup N\nf : AddMonoidHom G N\n⊢ Eq (AddSubgroup.comap f (Min.min H K)) (Min.min (AddSubgroup.comap f H) (AddSubgroup.comap f K))","decl":"@[to_additive]\ntheorem comap_inf (H K : Subgroup N) (f : G →* N) : (H ⊓ K).comap f = H.comap f ⊓ K.comap f :=\n  (gc_map_comap f).u_inf\n\n"}
{"name":"AddSubgroup.comap_iInf","module":"Mathlib.Algebra.Group.Subgroup.Map","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nN : Type u_5\ninst✝ : AddGroup N\nι : Sort u_7\nf : AddMonoidHom G N\ns : ι → AddSubgroup N\n⊢ Eq (AddSubgroup.comap f (iInf s)) (iInf fun i => AddSubgroup.comap f (s i))","decl":"@[to_additive]\ntheorem comap_iInf {ι : Sort*} (f : G →* N) (s : ι → Subgroup N) :\n    (iInf s).comap f = ⨅ i, (s i).comap f :=\n  (gc_map_comap f).u_iInf\n\n"}
{"name":"Subgroup.comap_iInf","module":"Mathlib.Algebra.Group.Subgroup.Map","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nN : Type u_5\ninst✝ : Group N\nι : Sort u_7\nf : MonoidHom G N\ns : ι → Subgroup N\n⊢ Eq (Subgroup.comap f (iInf s)) (iInf fun i => Subgroup.comap f (s i))","decl":"@[to_additive]\ntheorem comap_iInf {ι : Sort*} (f : G →* N) (s : ι → Subgroup N) :\n    (iInf s).comap f = ⨅ i, (s i).comap f :=\n  (gc_map_comap f).u_iInf\n\n"}
{"name":"AddSubgroup.map_inf_le","module":"Mathlib.Algebra.Group.Subgroup.Map","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nN : Type u_5\ninst✝ : AddGroup N\nH K : AddSubgroup G\nf : AddMonoidHom G N\n⊢ LE.le (AddSubgroup.map f (Min.min H K)) (Min.min (AddSubgroup.map f H) (AddSubgroup.map f K))","decl":"@[to_additive]\ntheorem map_inf_le (H K : Subgroup G) (f : G →* N) : map f (H ⊓ K) ≤ map f H ⊓ map f K :=\n  le_inf (map_mono inf_le_left) (map_mono inf_le_right)\n\n"}
{"name":"Subgroup.map_inf_le","module":"Mathlib.Algebra.Group.Subgroup.Map","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nN : Type u_5\ninst✝ : Group N\nH K : Subgroup G\nf : MonoidHom G N\n⊢ LE.le (Subgroup.map f (Min.min H K)) (Min.min (Subgroup.map f H) (Subgroup.map f K))","decl":"@[to_additive]\ntheorem map_inf_le (H K : Subgroup G) (f : G →* N) : map f (H ⊓ K) ≤ map f H ⊓ map f K :=\n  le_inf (map_mono inf_le_left) (map_mono inf_le_right)\n\n"}
{"name":"AddSubgroup.map_inf_eq","module":"Mathlib.Algebra.Group.Subgroup.Map","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nN : Type u_5\ninst✝ : AddGroup N\nH K : AddSubgroup G\nf : AddMonoidHom G N\nhf : Function.Injective ⇑f\n⊢ Eq (AddSubgroup.map f (Min.min H K)) (Min.min (AddSubgroup.map f H) (AddSubgroup.map f K))","decl":"@[to_additive]\ntheorem map_inf_eq (H K : Subgroup G) (f : G →* N) (hf : Function.Injective f) :\n    map f (H ⊓ K) = map f H ⊓ map f K := by\n  rw [← SetLike.coe_set_eq]\n  simp [Set.image_inter hf]\n\n"}
{"name":"Subgroup.map_inf_eq","module":"Mathlib.Algebra.Group.Subgroup.Map","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nN : Type u_5\ninst✝ : Group N\nH K : Subgroup G\nf : MonoidHom G N\nhf : Function.Injective ⇑f\n⊢ Eq (Subgroup.map f (Min.min H K)) (Min.min (Subgroup.map f H) (Subgroup.map f K))","decl":"@[to_additive]\ntheorem map_inf_eq (H K : Subgroup G) (f : G →* N) (hf : Function.Injective f) :\n    map f (H ⊓ K) = map f H ⊓ map f K := by\n  rw [← SetLike.coe_set_eq]\n  simp [Set.image_inter hf]\n\n"}
{"name":"AddSubgroup.map_bot","module":"Mathlib.Algebra.Group.Subgroup.Map","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nN : Type u_5\ninst✝ : AddGroup N\nf : AddMonoidHom G N\n⊢ Eq (AddSubgroup.map f Bot.bot) Bot.bot","decl":"@[to_additive (attr := simp)]\ntheorem map_bot (f : G →* N) : (⊥ : Subgroup G).map f = ⊥ :=\n  (gc_map_comap f).l_bot\n\n"}
{"name":"Subgroup.map_bot","module":"Mathlib.Algebra.Group.Subgroup.Map","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nN : Type u_5\ninst✝ : Group N\nf : MonoidHom G N\n⊢ Eq (Subgroup.map f Bot.bot) Bot.bot","decl":"@[to_additive (attr := simp)]\ntheorem map_bot (f : G →* N) : (⊥ : Subgroup G).map f = ⊥ :=\n  (gc_map_comap f).l_bot\n\n"}
{"name":"AddSubgroup.map_top_of_surjective","module":"Mathlib.Algebra.Group.Subgroup.Map","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nN : Type u_5\ninst✝ : AddGroup N\nf : AddMonoidHom G N\nh : Function.Surjective ⇑f\n⊢ Eq (AddSubgroup.map f Top.top) Top.top","decl":"@[to_additive (attr := simp)]\ntheorem map_top_of_surjective (f : G →* N) (h : Function.Surjective f) : Subgroup.map f ⊤ = ⊤ := by\n  rw [eq_top_iff]\n  intro x _\n  obtain ⟨y, hy⟩ := h x\n  exact ⟨y, trivial, hy⟩\n\n"}
{"name":"Subgroup.map_top_of_surjective","module":"Mathlib.Algebra.Group.Subgroup.Map","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nN : Type u_5\ninst✝ : Group N\nf : MonoidHom G N\nh : Function.Surjective ⇑f\n⊢ Eq (Subgroup.map f Top.top) Top.top","decl":"@[to_additive (attr := simp)]\ntheorem map_top_of_surjective (f : G →* N) (h : Function.Surjective f) : Subgroup.map f ⊤ = ⊤ := by\n  rw [eq_top_iff]\n  intro x _\n  obtain ⟨y, hy⟩ := h x\n  exact ⟨y, trivial, hy⟩\n\n"}
{"name":"Subgroup.comap_top","module":"Mathlib.Algebra.Group.Subgroup.Map","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nN : Type u_5\ninst✝ : Group N\nf : MonoidHom G N\n⊢ Eq (Subgroup.comap f Top.top) Top.top","decl":"@[to_additive (attr := simp)]\ntheorem comap_top (f : G →* N) : (⊤ : Subgroup N).comap f = ⊤ :=\n  (gc_map_comap f).u_top\n\n"}
{"name":"AddSubgroup.comap_top","module":"Mathlib.Algebra.Group.Subgroup.Map","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nN : Type u_5\ninst✝ : AddGroup N\nf : AddMonoidHom G N\n⊢ Eq (AddSubgroup.comap f Top.top) Top.top","decl":"@[to_additive (attr := simp)]\ntheorem comap_top (f : G →* N) : (⊤ : Subgroup N).comap f = ⊤ :=\n  (gc_map_comap f).u_top\n\n"}
{"name":"AddSubgroup.addSubgroupOfEquivOfLe_apply_coe","module":"Mathlib.Algebra.Group.Subgroup.Map","initialProofState":"G : Type u_7\ninst✝ : AddGroup G\nH K : AddSubgroup G\nh : LE.le H K\ng : Subtype fun x => Membership.mem (H.addSubgroupOf K) x\n⊢ Eq ↑((AddSubgroup.addSubgroupOfEquivOfLe h) g) ↑↑g","decl":"/-- If `H ≤ K`, then `H` as a subgroup of `K` is isomorphic to `H`. -/\n@[to_additive (attr := simps) \"If `H ≤ K`, then `H` as a subgroup of `K` is isomorphic to `H`.\"]\ndef subgroupOfEquivOfLe {G : Type*} [Group G] {H K : Subgroup G} (h : H ≤ K) :\n    H.subgroupOf K ≃* H where\n  toFun g := ⟨g.1, g.2⟩\n  invFun g := ⟨⟨g.1, h g.2⟩, g.2⟩\n  left_inv _g := Subtype.ext (Subtype.ext rfl)\n  right_inv _g := Subtype.ext rfl\n  map_mul' _g _h := rfl\n\n"}
{"name":"AddSubgroup.addSubgroupOfEquivOfLe_symm_apply_coe_coe","module":"Mathlib.Algebra.Group.Subgroup.Map","initialProofState":"G : Type u_7\ninst✝ : AddGroup G\nH K : AddSubgroup G\nh : LE.le H K\ng : Subtype fun x => Membership.mem H x\n⊢ Eq ↑↑((AddSubgroup.addSubgroupOfEquivOfLe h).symm g) ↑g","decl":"/-- If `H ≤ K`, then `H` as a subgroup of `K` is isomorphic to `H`. -/\n@[to_additive (attr := simps) \"If `H ≤ K`, then `H` as a subgroup of `K` is isomorphic to `H`.\"]\ndef subgroupOfEquivOfLe {G : Type*} [Group G] {H K : Subgroup G} (h : H ≤ K) :\n    H.subgroupOf K ≃* H where\n  toFun g := ⟨g.1, g.2⟩\n  invFun g := ⟨⟨g.1, h g.2⟩, g.2⟩\n  left_inv _g := Subtype.ext (Subtype.ext rfl)\n  right_inv _g := Subtype.ext rfl\n  map_mul' _g _h := rfl\n\n"}
{"name":"Subgroup.subgroupOfEquivOfLe_apply_coe","module":"Mathlib.Algebra.Group.Subgroup.Map","initialProofState":"G : Type u_7\ninst✝ : Group G\nH K : Subgroup G\nh : LE.le H K\ng : Subtype fun x => Membership.mem (H.subgroupOf K) x\n⊢ Eq ↑((Subgroup.subgroupOfEquivOfLe h) g) ↑↑g","decl":"/-- If `H ≤ K`, then `H` as a subgroup of `K` is isomorphic to `H`. -/\n@[to_additive (attr := simps) \"If `H ≤ K`, then `H` as a subgroup of `K` is isomorphic to `H`.\"]\ndef subgroupOfEquivOfLe {G : Type*} [Group G] {H K : Subgroup G} (h : H ≤ K) :\n    H.subgroupOf K ≃* H where\n  toFun g := ⟨g.1, g.2⟩\n  invFun g := ⟨⟨g.1, h g.2⟩, g.2⟩\n  left_inv _g := Subtype.ext (Subtype.ext rfl)\n  right_inv _g := Subtype.ext rfl\n  map_mul' _g _h := rfl\n\n"}
{"name":"Subgroup.subgroupOfEquivOfLe_symm_apply_coe_coe","module":"Mathlib.Algebra.Group.Subgroup.Map","initialProofState":"G : Type u_7\ninst✝ : Group G\nH K : Subgroup G\nh : LE.le H K\ng : Subtype fun x => Membership.mem H x\n⊢ Eq ↑↑((Subgroup.subgroupOfEquivOfLe h).symm g) ↑g","decl":"/-- If `H ≤ K`, then `H` as a subgroup of `K` is isomorphic to `H`. -/\n@[to_additive (attr := simps) \"If `H ≤ K`, then `H` as a subgroup of `K` is isomorphic to `H`.\"]\ndef subgroupOfEquivOfLe {G : Type*} [Group G] {H K : Subgroup G} (h : H ≤ K) :\n    H.subgroupOf K ≃* H where\n  toFun g := ⟨g.1, g.2⟩\n  invFun g := ⟨⟨g.1, h g.2⟩, g.2⟩\n  left_inv _g := Subtype.ext (Subtype.ext rfl)\n  right_inv _g := Subtype.ext rfl\n  map_mul' _g _h := rfl\n\n"}
{"name":"AddSubgroup.comap_subtype","module":"Mathlib.Algebra.Group.Subgroup.Map","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH K : AddSubgroup G\n⊢ Eq (AddSubgroup.comap K.subtype H) (H.addSubgroupOf K)","decl":"@[to_additive (attr := simp)]\ntheorem comap_subtype (H K : Subgroup G) : H.comap K.subtype = H.subgroupOf K :=\n  rfl\n\n"}
{"name":"Subgroup.comap_subtype","module":"Mathlib.Algebra.Group.Subgroup.Map","initialProofState":"G : Type u_1\ninst✝ : Group G\nH K : Subgroup G\n⊢ Eq (Subgroup.comap K.subtype H) (H.subgroupOf K)","decl":"@[to_additive (attr := simp)]\ntheorem comap_subtype (H K : Subgroup G) : H.comap K.subtype = H.subgroupOf K :=\n  rfl\n\n"}
{"name":"Subgroup.comap_inclusion_subgroupOf","module":"Mathlib.Algebra.Group.Subgroup.Map","initialProofState":"G : Type u_1\ninst✝ : Group G\nK₁ K₂ : Subgroup G\nh : LE.le K₁ K₂\nH : Subgroup G\n⊢ Eq (Subgroup.comap (Subgroup.inclusion h) (H.subgroupOf K₂)) (H.subgroupOf K₁)","decl":"@[to_additive (attr := simp)]\ntheorem comap_inclusion_subgroupOf {K₁ K₂ : Subgroup G} (h : K₁ ≤ K₂) (H : Subgroup G) :\n    (H.subgroupOf K₂).comap (inclusion h) = H.subgroupOf K₁ :=\n  rfl\n\n"}
{"name":"AddSubgroup.comap_inclusion_addSubgroupOf","module":"Mathlib.Algebra.Group.Subgroup.Map","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nK₁ K₂ : AddSubgroup G\nh : LE.le K₁ K₂\nH : AddSubgroup G\n⊢ Eq (AddSubgroup.comap (AddSubgroup.inclusion h) (H.addSubgroupOf K₂)) (H.addSubgroupOf K₁)","decl":"@[to_additive (attr := simp)]\ntheorem comap_inclusion_subgroupOf {K₁ K₂ : Subgroup G} (h : K₁ ≤ K₂) (H : Subgroup G) :\n    (H.subgroupOf K₂).comap (inclusion h) = H.subgroupOf K₁ :=\n  rfl\n\n"}
{"name":"AddSubgroup.coe_addSubgroupOf","module":"Mathlib.Algebra.Group.Subgroup.Map","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH K : AddSubgroup G\n⊢ Eq (↑(H.addSubgroupOf K)) (Set.preimage ⇑K.subtype ↑H)","decl":"@[to_additive]\ntheorem coe_subgroupOf (H K : Subgroup G) : (H.subgroupOf K : Set K) = K.subtype ⁻¹' H :=\n  rfl\n\n"}
{"name":"Subgroup.coe_subgroupOf","module":"Mathlib.Algebra.Group.Subgroup.Map","initialProofState":"G : Type u_1\ninst✝ : Group G\nH K : Subgroup G\n⊢ Eq (↑(H.subgroupOf K)) (Set.preimage ⇑K.subtype ↑H)","decl":"@[to_additive]\ntheorem coe_subgroupOf (H K : Subgroup G) : (H.subgroupOf K : Set K) = K.subtype ⁻¹' H :=\n  rfl\n\n"}
{"name":"Subgroup.mem_subgroupOf","module":"Mathlib.Algebra.Group.Subgroup.Map","initialProofState":"G : Type u_1\ninst✝ : Group G\nH K : Subgroup G\nh : Subtype fun x => Membership.mem K x\n⊢ Iff (Membership.mem (H.subgroupOf K) h) (Membership.mem H ↑h)","decl":"@[to_additive]\ntheorem mem_subgroupOf {H K : Subgroup G} {h : K} : h ∈ H.subgroupOf K ↔ (h : G) ∈ H :=\n  Iff.rfl\n\n-- TODO(kmill): use `K ⊓ H` order for RHS to match `Subtype.image_preimage_coe`\n"}
{"name":"AddSubgroup.mem_addSubgroupOf","module":"Mathlib.Algebra.Group.Subgroup.Map","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH K : AddSubgroup G\nh : Subtype fun x => Membership.mem K x\n⊢ Iff (Membership.mem (H.addSubgroupOf K) h) (Membership.mem H ↑h)","decl":"@[to_additive]\ntheorem mem_subgroupOf {H K : Subgroup G} {h : K} : h ∈ H.subgroupOf K ↔ (h : G) ∈ H :=\n  Iff.rfl\n\n-- TODO(kmill): use `K ⊓ H` order for RHS to match `Subtype.image_preimage_coe`\n"}
{"name":"AddSubgroup.addSubgroupOf_map_subtype","module":"Mathlib.Algebra.Group.Subgroup.Map","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH K : AddSubgroup G\n⊢ Eq (AddSubgroup.map K.subtype (H.addSubgroupOf K)) (Min.min H K)","decl":"@[to_additive (attr := simp)]\ntheorem subgroupOf_map_subtype (H K : Subgroup G) : (H.subgroupOf K).map K.subtype = H ⊓ K :=\n  SetLike.ext' <| by refine Subtype.image_preimage_coe _ _ |>.trans ?_; apply Set.inter_comm\n\n"}
{"name":"Subgroup.subgroupOf_map_subtype","module":"Mathlib.Algebra.Group.Subgroup.Map","initialProofState":"G : Type u_1\ninst✝ : Group G\nH K : Subgroup G\n⊢ Eq (Subgroup.map K.subtype (H.subgroupOf K)) (Min.min H K)","decl":"@[to_additive (attr := simp)]\ntheorem subgroupOf_map_subtype (H K : Subgroup G) : (H.subgroupOf K).map K.subtype = H ⊓ K :=\n  SetLike.ext' <| by refine Subtype.image_preimage_coe _ _ |>.trans ?_; apply Set.inter_comm\n\n"}
{"name":"Subgroup.map_subgroupOf_eq_of_le","module":"Mathlib.Algebra.Group.Subgroup.Map","initialProofState":"G : Type u_1\ninst✝ : Group G\nH K : Subgroup G\nh : LE.le H K\n⊢ Eq (Subgroup.map K.subtype (H.subgroupOf K)) H","decl":"@[to_additive]\ntheorem map_subgroupOf_eq_of_le {H K : Subgroup G} (h : H ≤ K) :\n    (H.subgroupOf K).map K.subtype = H := by\n  rwa [subgroupOf_map_subtype, inf_eq_left]\n\n"}
{"name":"AddSubgroup.map_addSubgroupOf_eq_of_le","module":"Mathlib.Algebra.Group.Subgroup.Map","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH K : AddSubgroup G\nh : LE.le H K\n⊢ Eq (AddSubgroup.map K.subtype (H.addSubgroupOf K)) H","decl":"@[to_additive]\ntheorem map_subgroupOf_eq_of_le {H K : Subgroup G} (h : H ≤ K) :\n    (H.subgroupOf K).map K.subtype = H := by\n  rwa [subgroupOf_map_subtype, inf_eq_left]\n\n"}
{"name":"AddSubgroup.bot_addSubgroupOf","module":"Mathlib.Algebra.Group.Subgroup.Map","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH : AddSubgroup G\n⊢ Eq (Bot.bot.addSubgroupOf H) Bot.bot","decl":"@[to_additive (attr := simp)]\ntheorem bot_subgroupOf : (⊥ : Subgroup G).subgroupOf H = ⊥ :=\n  Eq.symm (Subgroup.ext fun _g => Subtype.ext_iff)\n\n"}
{"name":"Subgroup.bot_subgroupOf","module":"Mathlib.Algebra.Group.Subgroup.Map","initialProofState":"G : Type u_1\ninst✝ : Group G\nH : Subgroup G\n⊢ Eq (Bot.bot.subgroupOf H) Bot.bot","decl":"@[to_additive (attr := simp)]\ntheorem bot_subgroupOf : (⊥ : Subgroup G).subgroupOf H = ⊥ :=\n  Eq.symm (Subgroup.ext fun _g => Subtype.ext_iff)\n\n"}
{"name":"Subgroup.top_subgroupOf","module":"Mathlib.Algebra.Group.Subgroup.Map","initialProofState":"G : Type u_1\ninst✝ : Group G\nH : Subgroup G\n⊢ Eq (Top.top.subgroupOf H) Top.top","decl":"@[to_additive (attr := simp)]\ntheorem top_subgroupOf : (⊤ : Subgroup G).subgroupOf H = ⊤ :=\n  rfl\n\n"}
{"name":"AddSubgroup.top_addSubgroupOf","module":"Mathlib.Algebra.Group.Subgroup.Map","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH : AddSubgroup G\n⊢ Eq (Top.top.addSubgroupOf H) Top.top","decl":"@[to_additive (attr := simp)]\ntheorem top_subgroupOf : (⊤ : Subgroup G).subgroupOf H = ⊤ :=\n  rfl\n\n"}
{"name":"Subgroup.subgroupOf_bot_eq_bot","module":"Mathlib.Algebra.Group.Subgroup.Map","initialProofState":"G : Type u_1\ninst✝ : Group G\nH : Subgroup G\n⊢ Eq (H.subgroupOf Bot.bot) Bot.bot","decl":"@[to_additive]\ntheorem subgroupOf_bot_eq_bot : H.subgroupOf ⊥ = ⊥ :=\n  Subsingleton.elim _ _\n\n"}
{"name":"AddSubgroup.addSubgroupOf_bot_eq_bot","module":"Mathlib.Algebra.Group.Subgroup.Map","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH : AddSubgroup G\n⊢ Eq (H.addSubgroupOf Bot.bot) Bot.bot","decl":"@[to_additive]\ntheorem subgroupOf_bot_eq_bot : H.subgroupOf ⊥ = ⊥ :=\n  Subsingleton.elim _ _\n\n"}
{"name":"AddSubgroup.addSubgroupOf_bot_eq_top","module":"Mathlib.Algebra.Group.Subgroup.Map","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH : AddSubgroup G\n⊢ Eq (H.addSubgroupOf Bot.bot) Top.top","decl":"@[to_additive]\ntheorem subgroupOf_bot_eq_top : H.subgroupOf ⊥ = ⊤ :=\n  Subsingleton.elim _ _\n\n"}
{"name":"Subgroup.subgroupOf_bot_eq_top","module":"Mathlib.Algebra.Group.Subgroup.Map","initialProofState":"G : Type u_1\ninst✝ : Group G\nH : Subgroup G\n⊢ Eq (H.subgroupOf Bot.bot) Top.top","decl":"@[to_additive]\ntheorem subgroupOf_bot_eq_top : H.subgroupOf ⊥ = ⊤ :=\n  Subsingleton.elim _ _\n\n"}
{"name":"Subgroup.subgroupOf_self","module":"Mathlib.Algebra.Group.Subgroup.Map","initialProofState":"G : Type u_1\ninst✝ : Group G\nH : Subgroup G\n⊢ Eq (H.subgroupOf H) Top.top","decl":"@[to_additive (attr := simp)]\ntheorem subgroupOf_self : H.subgroupOf H = ⊤ :=\n  top_unique fun g _hg => g.2\n\n"}
{"name":"AddSubgroup.addSubgroupOf_self","module":"Mathlib.Algebra.Group.Subgroup.Map","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH : AddSubgroup G\n⊢ Eq (H.addSubgroupOf H) Top.top","decl":"@[to_additive (attr := simp)]\ntheorem subgroupOf_self : H.subgroupOf H = ⊤ :=\n  top_unique fun g _hg => g.2\n\n"}
{"name":"Subgroup.subgroupOf_inj","module":"Mathlib.Algebra.Group.Subgroup.Map","initialProofState":"G : Type u_1\ninst✝ : Group G\nH₁ H₂ K : Subgroup G\n⊢ Iff (Eq (H₁.subgroupOf K) (H₂.subgroupOf K)) (Eq (Min.min H₁ K) (Min.min H₂ K))","decl":"@[to_additive (attr := simp)]\ntheorem subgroupOf_inj {H₁ H₂ K : Subgroup G} :\n    H₁.subgroupOf K = H₂.subgroupOf K ↔ H₁ ⊓ K = H₂ ⊓ K := by\n  simpa only [SetLike.ext_iff, mem_inf, mem_subgroupOf, and_congr_left_iff] using Subtype.forall\n\n"}
{"name":"AddSubgroup.addSubgroupOf_inj","module":"Mathlib.Algebra.Group.Subgroup.Map","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH₁ H₂ K : AddSubgroup G\n⊢ Iff (Eq (H₁.addSubgroupOf K) (H₂.addSubgroupOf K)) (Eq (Min.min H₁ K) (Min.min H₂ K))","decl":"@[to_additive (attr := simp)]\ntheorem subgroupOf_inj {H₁ H₂ K : Subgroup G} :\n    H₁.subgroupOf K = H₂.subgroupOf K ↔ H₁ ⊓ K = H₂ ⊓ K := by\n  simpa only [SetLike.ext_iff, mem_inf, mem_subgroupOf, and_congr_left_iff] using Subtype.forall\n\n"}
{"name":"AddSubgroup.inf_addSubgroupOf_right","module":"Mathlib.Algebra.Group.Subgroup.Map","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH K : AddSubgroup G\n⊢ Eq ((Min.min H K).addSubgroupOf K) (H.addSubgroupOf K)","decl":"@[to_additive (attr := simp)]\ntheorem inf_subgroupOf_right (H K : Subgroup G) : (H ⊓ K).subgroupOf K = H.subgroupOf K :=\n  subgroupOf_inj.2 (inf_right_idem _ _)\n\n"}
{"name":"Subgroup.inf_subgroupOf_right","module":"Mathlib.Algebra.Group.Subgroup.Map","initialProofState":"G : Type u_1\ninst✝ : Group G\nH K : Subgroup G\n⊢ Eq ((Min.min H K).subgroupOf K) (H.subgroupOf K)","decl":"@[to_additive (attr := simp)]\ntheorem inf_subgroupOf_right (H K : Subgroup G) : (H ⊓ K).subgroupOf K = H.subgroupOf K :=\n  subgroupOf_inj.2 (inf_right_idem _ _)\n\n"}
{"name":"Subgroup.inf_subgroupOf_left","module":"Mathlib.Algebra.Group.Subgroup.Map","initialProofState":"G : Type u_1\ninst✝ : Group G\nH K : Subgroup G\n⊢ Eq ((Min.min K H).subgroupOf K) (H.subgroupOf K)","decl":"@[to_additive (attr := simp)]\ntheorem inf_subgroupOf_left (H K : Subgroup G) : (K ⊓ H).subgroupOf K = H.subgroupOf K := by\n  rw [inf_comm, inf_subgroupOf_right]\n\n"}
{"name":"AddSubgroup.inf_addSubgroupOf_left","module":"Mathlib.Algebra.Group.Subgroup.Map","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH K : AddSubgroup G\n⊢ Eq ((Min.min K H).addSubgroupOf K) (H.addSubgroupOf K)","decl":"@[to_additive (attr := simp)]\ntheorem inf_subgroupOf_left (H K : Subgroup G) : (K ⊓ H).subgroupOf K = H.subgroupOf K := by\n  rw [inf_comm, inf_subgroupOf_right]\n\n"}
{"name":"AddSubgroup.addSubgroupOf_eq_bot","module":"Mathlib.Algebra.Group.Subgroup.Map","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH K : AddSubgroup G\n⊢ Iff (Eq (H.addSubgroupOf K) Bot.bot) (Disjoint H K)","decl":"@[to_additive (attr := simp)]\ntheorem subgroupOf_eq_bot {H K : Subgroup G} : H.subgroupOf K = ⊥ ↔ Disjoint H K := by\n  rw [disjoint_iff, ← bot_subgroupOf, subgroupOf_inj, bot_inf_eq]\n\n"}
{"name":"Subgroup.subgroupOf_eq_bot","module":"Mathlib.Algebra.Group.Subgroup.Map","initialProofState":"G : Type u_1\ninst✝ : Group G\nH K : Subgroup G\n⊢ Iff (Eq (H.subgroupOf K) Bot.bot) (Disjoint H K)","decl":"@[to_additive (attr := simp)]\ntheorem subgroupOf_eq_bot {H K : Subgroup G} : H.subgroupOf K = ⊥ ↔ Disjoint H K := by\n  rw [disjoint_iff, ← bot_subgroupOf, subgroupOf_inj, bot_inf_eq]\n\n"}
{"name":"AddSubgroup.addSubgroupOf_eq_top","module":"Mathlib.Algebra.Group.Subgroup.Map","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH K : AddSubgroup G\n⊢ Iff (Eq (H.addSubgroupOf K) Top.top) (LE.le K H)","decl":"@[to_additive (attr := simp)]\ntheorem subgroupOf_eq_top {H K : Subgroup G} : H.subgroupOf K = ⊤ ↔ K ≤ H := by\n  rw [← top_subgroupOf, subgroupOf_inj, top_inf_eq, inf_eq_right]\n\n"}
{"name":"Subgroup.subgroupOf_eq_top","module":"Mathlib.Algebra.Group.Subgroup.Map","initialProofState":"G : Type u_1\ninst✝ : Group G\nH K : Subgroup G\n⊢ Iff (Eq (H.subgroupOf K) Top.top) (LE.le K H)","decl":"@[to_additive (attr := simp)]\ntheorem subgroupOf_eq_top {H K : Subgroup G} : H.subgroupOf K = ⊤ ↔ K ≤ H := by\n  rw [← top_subgroupOf, subgroupOf_inj, top_inf_eq, inf_eq_right]\n\n"}
{"name":"AddSubgroup.map_isCommutative","module":"Mathlib.Algebra.Group.Subgroup.Map","initialProofState":"G : Type u_1\nG' : Type u_2\ninst✝² : AddGroup G\ninst✝¹ : AddGroup G'\nH : AddSubgroup G\nf : AddMonoidHom G G'\ninst✝ : H.IsCommutative\n⊢ (AddSubgroup.map f H).IsCommutative","decl":"@[to_additive]\ninstance map_isCommutative (f : G →* G') [H.IsCommutative] : (H.map f).IsCommutative :=\n  ⟨⟨by\n      rintro ⟨-, a, ha, rfl⟩ ⟨-, b, hb, rfl⟩\n      rw [Subtype.ext_iff, coe_mul, coe_mul, Subtype.coe_mk, Subtype.coe_mk, ← map_mul, ← map_mul]\n      exact congr_arg f (Subtype.ext_iff.mp (mul_comm (⟨a, ha⟩ : H) ⟨b, hb⟩))⟩⟩\n\n"}
{"name":"Subgroup.map_isCommutative","module":"Mathlib.Algebra.Group.Subgroup.Map","initialProofState":"G : Type u_1\nG' : Type u_2\ninst✝² : Group G\ninst✝¹ : Group G'\nH : Subgroup G\nf : MonoidHom G G'\ninst✝ : H.IsCommutative\n⊢ (Subgroup.map f H).IsCommutative","decl":"@[to_additive]\ninstance map_isCommutative (f : G →* G') [H.IsCommutative] : (H.map f).IsCommutative :=\n  ⟨⟨by\n      rintro ⟨-, a, ha, rfl⟩ ⟨-, b, hb, rfl⟩\n      rw [Subtype.ext_iff, coe_mul, coe_mul, Subtype.coe_mk, Subtype.coe_mk, ← map_mul, ← map_mul]\n      exact congr_arg f (Subtype.ext_iff.mp (mul_comm (⟨a, ha⟩ : H) ⟨b, hb⟩))⟩⟩\n\n"}
{"name":"AddSubgroup.comap_injective_isCommutative","module":"Mathlib.Algebra.Group.Subgroup.Map","initialProofState":"G : Type u_1\nG' : Type u_2\ninst✝² : AddGroup G\ninst✝¹ : AddGroup G'\nH : AddSubgroup G\nf : AddMonoidHom G' G\nhf : Function.Injective ⇑f\ninst✝ : H.IsCommutative\n⊢ (AddSubgroup.comap f H).IsCommutative","decl":"@[to_additive]\ntheorem comap_injective_isCommutative {f : G' →* G} (hf : Injective f) [H.IsCommutative] :\n    (H.comap f).IsCommutative :=\n  ⟨⟨fun a b =>\n      Subtype.ext\n        (by\n          have := mul_comm (⟨f a, a.2⟩ : H) (⟨f b, b.2⟩ : H)\n          rwa [Subtype.ext_iff, coe_mul, coe_mul, coe_mk, coe_mk, ← map_mul, ← map_mul,\n            hf.eq_iff] at this)⟩⟩\n\n"}
{"name":"Subgroup.comap_injective_isCommutative","module":"Mathlib.Algebra.Group.Subgroup.Map","initialProofState":"G : Type u_1\nG' : Type u_2\ninst✝² : Group G\ninst✝¹ : Group G'\nH : Subgroup G\nf : MonoidHom G' G\nhf : Function.Injective ⇑f\ninst✝ : H.IsCommutative\n⊢ (Subgroup.comap f H).IsCommutative","decl":"@[to_additive]\ntheorem comap_injective_isCommutative {f : G' →* G} (hf : Injective f) [H.IsCommutative] :\n    (H.comap f).IsCommutative :=\n  ⟨⟨fun a b =>\n      Subtype.ext\n        (by\n          have := mul_comm (⟨f a, a.2⟩ : H) (⟨f b, b.2⟩ : H)\n          rwa [Subtype.ext_iff, coe_mul, coe_mul, coe_mk, coe_mk, ← map_mul, ← map_mul,\n            hf.eq_iff] at this)⟩⟩\n\n"}
{"name":"AddSubgroup.addSubgroupOf_isCommutative","module":"Mathlib.Algebra.Group.Subgroup.Map","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nK H : AddSubgroup G\ninst✝ : H.IsCommutative\n⊢ (H.addSubgroupOf K).IsCommutative","decl":"@[to_additive]\ninstance subgroupOf_isCommutative [H.IsCommutative] : (H.subgroupOf K).IsCommutative :=\n  H.comap_injective_isCommutative Subtype.coe_injective\n\n"}
{"name":"Subgroup.subgroupOf_isCommutative","module":"Mathlib.Algebra.Group.Subgroup.Map","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nK H : Subgroup G\ninst✝ : H.IsCommutative\n⊢ (H.subgroupOf K).IsCommutative","decl":"@[to_additive]\ninstance subgroupOf_isCommutative [H.IsCommutative] : (H.subgroupOf K).IsCommutative :=\n  H.comap_injective_isCommutative Subtype.coe_injective\n\n"}
{"name":"MulEquiv.comapSubgroup_symm_apply","module":"Mathlib.Algebra.Group.Subgroup.Map","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nH✝ : Type u_5\ninst✝ : Group H✝\nf : MulEquiv G H✝\nH : Subgroup G\n⊢ Eq ((RelIso.symm f.comapSubgroup) H) (Subgroup.comap (↑f.symm) H)","decl":"/--\nAn isomorphism of groups gives an order isomorphism between the lattices of subgroups,\ndefined by sending subgroups to their inverse images.\n\nSee also `MulEquiv.mapSubgroup` which maps subgroups to their forward images.\n-/\n@[simps]\ndef comapSubgroup (f : G ≃* H) : Subgroup H ≃o Subgroup G where\n  toFun := Subgroup.comap f\n  invFun := Subgroup.comap f.symm\n  left_inv sg := by simp [Subgroup.comap_comap]\n  right_inv sh := by simp [Subgroup.comap_comap]\n  map_rel_iff' {sg1 sg2} :=\n    ⟨fun h => by simpa [Subgroup.comap_comap] using\n      Subgroup.comap_mono (f := (f.symm : H →* G)) h, Subgroup.comap_mono⟩\n\n"}
{"name":"MulEquiv.comapSubgroup_apply","module":"Mathlib.Algebra.Group.Subgroup.Map","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nH✝ : Type u_5\ninst✝ : Group H✝\nf : MulEquiv G H✝\nH : Subgroup H✝\n⊢ Eq (f.comapSubgroup H) (Subgroup.comap (↑f) H)","decl":"/--\nAn isomorphism of groups gives an order isomorphism between the lattices of subgroups,\ndefined by sending subgroups to their inverse images.\n\nSee also `MulEquiv.mapSubgroup` which maps subgroups to their forward images.\n-/\n@[simps]\ndef comapSubgroup (f : G ≃* H) : Subgroup H ≃o Subgroup G where\n  toFun := Subgroup.comap f\n  invFun := Subgroup.comap f.symm\n  left_inv sg := by simp [Subgroup.comap_comap]\n  right_inv sh := by simp [Subgroup.comap_comap]\n  map_rel_iff' {sg1 sg2} :=\n    ⟨fun h => by simpa [Subgroup.comap_comap] using\n      Subgroup.comap_mono (f := (f.symm : H →* G)) h, Subgroup.comap_mono⟩\n\n"}
{"name":"MulEquiv.mapSubgroup_symm_apply","module":"Mathlib.Algebra.Group.Subgroup.Map","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nH✝ : Type u_6\ninst✝ : Group H✝\nf : MulEquiv G H✝\nH : Subgroup H✝\n⊢ Eq ((RelIso.symm f.mapSubgroup) H) (Subgroup.map (↑f.symm) H)","decl":"/--\nAn isomorphism of groups gives an order isomorphism between the lattices of subgroups,\ndefined by sending subgroups to their forward images.\n\nSee also `MulEquiv.comapSubgroup` which maps subgroups to their inverse images.\n-/\n@[simps]\ndef mapSubgroup {H : Type*} [Group H] (f : G ≃* H) : Subgroup G ≃o Subgroup H where\n  toFun := Subgroup.map f\n  invFun := Subgroup.map f.symm\n  left_inv sg := by simp [Subgroup.map_map]\n  right_inv sh := by simp [Subgroup.map_map]\n  map_rel_iff' {sg1 sg2} :=\n    ⟨fun h => by simpa [Subgroup.map_map] using\n      Subgroup.map_mono (f := (f.symm : H →* G)) h, Subgroup.map_mono⟩\n\n"}
{"name":"MulEquiv.mapSubgroup_apply","module":"Mathlib.Algebra.Group.Subgroup.Map","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nH✝ : Type u_6\ninst✝ : Group H✝\nf : MulEquiv G H✝\nH : Subgroup G\n⊢ Eq (f.mapSubgroup H) (Subgroup.map (↑f) H)","decl":"/--\nAn isomorphism of groups gives an order isomorphism between the lattices of subgroups,\ndefined by sending subgroups to their forward images.\n\nSee also `MulEquiv.comapSubgroup` which maps subgroups to their inverse images.\n-/\n@[simps]\ndef mapSubgroup {H : Type*} [Group H] (f : G ≃* H) : Subgroup G ≃o Subgroup H where\n  toFun := Subgroup.map f\n  invFun := Subgroup.map f.symm\n  left_inv sg := by simp [Subgroup.map_map]\n  right_inv sh := by simp [Subgroup.map_map]\n  map_rel_iff' {sg1 sg2} :=\n    ⟨fun h => by simpa [Subgroup.map_map] using\n      Subgroup.map_mono (f := (f.symm : H →* G)) h, Subgroup.map_mono⟩\n\n"}
{"name":"AddSubgroup.map_comap_le","module":"Mathlib.Algebra.Group.Subgroup.Map","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nN : Type u_5\ninst✝ : AddGroup N\nf : AddMonoidHom G N\nH : AddSubgroup N\n⊢ LE.le (AddSubgroup.map f (AddSubgroup.comap f H)) H","decl":"@[to_additive]\ntheorem map_comap_le (H : Subgroup N) : map f (comap f H) ≤ H :=\n  (gc_map_comap f).l_u_le _\n\n"}
{"name":"Subgroup.map_comap_le","module":"Mathlib.Algebra.Group.Subgroup.Map","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nN : Type u_5\ninst✝ : Group N\nf : MonoidHom G N\nH : Subgroup N\n⊢ LE.le (Subgroup.map f (Subgroup.comap f H)) H","decl":"@[to_additive]\ntheorem map_comap_le (H : Subgroup N) : map f (comap f H) ≤ H :=\n  (gc_map_comap f).l_u_le _\n\n"}
{"name":"Subgroup.le_comap_map","module":"Mathlib.Algebra.Group.Subgroup.Map","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nN : Type u_5\ninst✝ : Group N\nf : MonoidHom G N\nH : Subgroup G\n⊢ LE.le H (Subgroup.comap f (Subgroup.map f H))","decl":"@[to_additive]\ntheorem le_comap_map (H : Subgroup G) : H ≤ comap f (map f H) :=\n  (gc_map_comap f).le_u_l _\n\n"}
{"name":"AddSubgroup.le_comap_map","module":"Mathlib.Algebra.Group.Subgroup.Map","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nN : Type u_5\ninst✝ : AddGroup N\nf : AddMonoidHom G N\nH : AddSubgroup G\n⊢ LE.le H (AddSubgroup.comap f (AddSubgroup.map f H))","decl":"@[to_additive]\ntheorem le_comap_map (H : Subgroup G) : H ≤ comap f (map f H) :=\n  (gc_map_comap f).le_u_l _\n\n"}
{"name":"AddSubgroup.map_eq_comap_of_inverse","module":"Mathlib.Algebra.Group.Subgroup.Map","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nN : Type u_5\ninst✝ : AddGroup N\nf : AddMonoidHom G N\ng : AddMonoidHom N G\nhl : Function.LeftInverse ⇑g ⇑f\nhr : Function.RightInverse ⇑g ⇑f\nH : AddSubgroup G\n⊢ Eq (AddSubgroup.map f H) (AddSubgroup.comap g H)","decl":"@[to_additive]\ntheorem map_eq_comap_of_inverse {f : G →* N} {g : N →* G} (hl : Function.LeftInverse g f)\n    (hr : Function.RightInverse g f) (H : Subgroup G) : map f H = comap g H :=\n  SetLike.ext' <| by rw [coe_map, coe_comap, Set.image_eq_preimage_of_inverse hl hr]\n\n"}
{"name":"Subgroup.map_eq_comap_of_inverse","module":"Mathlib.Algebra.Group.Subgroup.Map","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nN : Type u_5\ninst✝ : Group N\nf : MonoidHom G N\ng : MonoidHom N G\nhl : Function.LeftInverse ⇑g ⇑f\nhr : Function.RightInverse ⇑g ⇑f\nH : Subgroup G\n⊢ Eq (Subgroup.map f H) (Subgroup.comap g H)","decl":"@[to_additive]\ntheorem map_eq_comap_of_inverse {f : G →* N} {g : N →* G} (hl : Function.LeftInverse g f)\n    (hr : Function.RightInverse g f) (H : Subgroup G) : map f H = comap g H :=\n  SetLike.ext' <| by rw [coe_map, coe_comap, Set.image_eq_preimage_of_inverse hl hr]\n\n"}
{"name":"Subgroup.coe_equivMapOfInjective_apply","module":"Mathlib.Algebra.Group.Subgroup.Map","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nN : Type u_5\ninst✝ : Group N\nH : Subgroup G\nf : MonoidHom G N\nhf : Function.Injective ⇑f\nh : Subtype fun x => Membership.mem H x\n⊢ Eq (↑((H.equivMapOfInjective f hf) h)) (f ↑h)","decl":"@[to_additive (attr := simp)]\ntheorem coe_equivMapOfInjective_apply (H : Subgroup G) (f : G →* N) (hf : Function.Injective f)\n    (h : H) : (equivMapOfInjective H f hf h : N) = f h :=\n  rfl\n\n"}
{"name":"AddSubgroup.coe_equivMapOfInjective_apply","module":"Mathlib.Algebra.Group.Subgroup.Map","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nN : Type u_5\ninst✝ : AddGroup N\nH : AddSubgroup G\nf : AddMonoidHom G N\nhf : Function.Injective ⇑f\nh : Subtype fun x => Membership.mem H x\n⊢ Eq (↑((H.equivMapOfInjective f hf) h)) (f ↑h)","decl":"@[to_additive (attr := simp)]\ntheorem coe_equivMapOfInjective_apply (H : Subgroup G) (f : G →* N) (hf : Function.Injective f)\n    (h : H) : (equivMapOfInjective H f hf h : N) = f h :=\n  rfl\n\n"}
{"name":"AddMonoidHom.addSubgroupComap_apply_coe","module":"Mathlib.Algebra.Group.Subgroup.Map","initialProofState":"G : Type u_1\nG' : Type u_2\ninst✝¹ : AddGroup G\ninst✝ : AddGroup G'\nf : AddMonoidHom G G'\nH' : AddSubgroup G'\nx : Subtype fun x => Membership.mem (AddSubmonoid.comap f H'.toAddSubmonoid) x\n⊢ Eq (↑((f.addSubgroupComap H') x)) (f ↑x)","decl":"/-- The `MonoidHom` from the preimage of a subgroup to itself. -/\n@[to_additive (attr := simps!) \"the `AddMonoidHom` from the preimage of an\nadditive subgroup to itself.\"]\ndef subgroupComap (f : G →* G') (H' : Subgroup G') : H'.comap f →* H' :=\n  f.submonoidComap H'.toSubmonoid\n\n"}
{"name":"MonoidHom.subgroupComap_apply_coe","module":"Mathlib.Algebra.Group.Subgroup.Map","initialProofState":"G : Type u_1\nG' : Type u_2\ninst✝¹ : Group G\ninst✝ : Group G'\nf : MonoidHom G G'\nH' : Subgroup G'\nx : Subtype fun x => Membership.mem (Submonoid.comap f H'.toSubmonoid) x\n⊢ Eq (↑((f.subgroupComap H') x)) (f ↑x)","decl":"/-- The `MonoidHom` from the preimage of a subgroup to itself. -/\n@[to_additive (attr := simps!) \"the `AddMonoidHom` from the preimage of an\nadditive subgroup to itself.\"]\ndef subgroupComap (f : G →* G') (H' : Subgroup G') : H'.comap f →* H' :=\n  f.submonoidComap H'.toSubmonoid\n\n"}
{"name":"MonoidHom.subgroupMap_apply_coe","module":"Mathlib.Algebra.Group.Subgroup.Map","initialProofState":"G : Type u_1\nG' : Type u_2\ninst✝¹ : Group G\ninst✝ : Group G'\nf : MonoidHom G G'\nH : Subgroup G\nx : Subtype fun x => Membership.mem H.toSubmonoid x\n⊢ Eq (↑((f.subgroupMap H) x)) (f ↑x)","decl":"/-- The `MonoidHom` from a subgroup to its image. -/\n@[to_additive (attr := simps!) \"the `AddMonoidHom` from an additive subgroup to its image\"]\ndef subgroupMap (f : G →* G') (H : Subgroup G) : H →* H.map f :=\n  f.submonoidMap H.toSubmonoid\n\n"}
{"name":"AddMonoidHom.addSubgroupMap_apply_coe","module":"Mathlib.Algebra.Group.Subgroup.Map","initialProofState":"G : Type u_1\nG' : Type u_2\ninst✝¹ : AddGroup G\ninst✝ : AddGroup G'\nf : AddMonoidHom G G'\nH : AddSubgroup G\nx : Subtype fun x => Membership.mem H.toAddSubmonoid x\n⊢ Eq (↑((f.addSubgroupMap H) x)) (f ↑x)","decl":"/-- The `MonoidHom` from a subgroup to its image. -/\n@[to_additive (attr := simps!) \"the `AddMonoidHom` from an additive subgroup to its image\"]\ndef subgroupMap (f : G →* G') (H : Subgroup G) : H →* H.map f :=\n  f.submonoidMap H.toSubmonoid\n\n"}
{"name":"MonoidHom.subgroupMap_surjective","module":"Mathlib.Algebra.Group.Subgroup.Map","initialProofState":"G : Type u_1\nG' : Type u_2\ninst✝¹ : Group G\ninst✝ : Group G'\nf : MonoidHom G G'\nH : Subgroup G\n⊢ Function.Surjective ⇑(f.subgroupMap H)","decl":"@[to_additive]\ntheorem subgroupMap_surjective (f : G →* G') (H : Subgroup G) :\n    Function.Surjective (f.subgroupMap H) :=\n  f.submonoidMap_surjective H.toSubmonoid\n\n"}
{"name":"AddMonoidHom.addSubgroupMap_surjective","module":"Mathlib.Algebra.Group.Subgroup.Map","initialProofState":"G : Type u_1\nG' : Type u_2\ninst✝¹ : AddGroup G\ninst✝ : AddGroup G'\nf : AddMonoidHom G G'\nH : AddSubgroup G\n⊢ Function.Surjective ⇑(f.addSubgroupMap H)","decl":"@[to_additive]\ntheorem subgroupMap_surjective (f : G →* G') (H : Subgroup G) :\n    Function.Surjective (f.subgroupMap H) :=\n  f.submonoidMap_surjective H.toSubmonoid\n\n"}
{"name":"AddEquiv.addSubgroupCongr_apply","module":"Mathlib.Algebra.Group.Subgroup.Map","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH K : AddSubgroup G\nh : Eq H K\nx : Subtype fun x => Membership.mem H x\n⊢ Eq ↑((AddEquiv.addSubgroupCongr h) x) ↑x","decl":"@[to_additive (attr := simp)]\nlemma subgroupCongr_apply (h : H = K) (x) :\n    (MulEquiv.subgroupCongr h x : G) = x := rfl\n\n"}
{"name":"MulEquiv.subgroupCongr_apply","module":"Mathlib.Algebra.Group.Subgroup.Map","initialProofState":"G : Type u_1\ninst✝ : Group G\nH K : Subgroup G\nh : Eq H K\nx : Subtype fun x => Membership.mem H x\n⊢ Eq ↑((MulEquiv.subgroupCongr h) x) ↑x","decl":"@[to_additive (attr := simp)]\nlemma subgroupCongr_apply (h : H = K) (x) :\n    (MulEquiv.subgroupCongr h x : G) = x := rfl\n\n"}
{"name":"MulEquiv.subgroupCongr_symm_apply","module":"Mathlib.Algebra.Group.Subgroup.Map","initialProofState":"G : Type u_1\ninst✝ : Group G\nH K : Subgroup G\nh : Eq H K\nx : Subtype fun x => Membership.mem K x\n⊢ Eq ↑((MulEquiv.subgroupCongr h).symm x) ↑x","decl":"@[to_additive (attr := simp)]\nlemma subgroupCongr_symm_apply (h : H = K) (x) :\n    ((MulEquiv.subgroupCongr h).symm x : G) = x := rfl\n\n"}
{"name":"AddEquiv.addSubgroupCongr_symm_apply","module":"Mathlib.Algebra.Group.Subgroup.Map","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH K : AddSubgroup G\nh : Eq H K\nx : Subtype fun x => Membership.mem K x\n⊢ Eq ↑((AddEquiv.addSubgroupCongr h).symm x) ↑x","decl":"@[to_additive (attr := simp)]\nlemma subgroupCongr_symm_apply (h : H = K) (x) :\n    ((MulEquiv.subgroupCongr h).symm x : G) = x := rfl\n\n"}
{"name":"AddEquiv.coe_addSubgroupMap_apply","module":"Mathlib.Algebra.Group.Subgroup.Map","initialProofState":"G : Type u_1\nG' : Type u_2\ninst✝¹ : AddGroup G\ninst✝ : AddGroup G'\ne : AddEquiv G G'\nH : AddSubgroup G\ng : Subtype fun x => Membership.mem H x\n⊢ Eq (↑((e.addSubgroupMap H) g)) (e ↑g)","decl":"@[to_additive (attr := simp)]\ntheorem coe_subgroupMap_apply (e : G ≃* G') (H : Subgroup G) (g : H) :\n    ((subgroupMap e H g : H.map (e : G →* G')) : G') = e g :=\n  rfl\n\n"}
{"name":"MulEquiv.coe_subgroupMap_apply","module":"Mathlib.Algebra.Group.Subgroup.Map","initialProofState":"G : Type u_1\nG' : Type u_2\ninst✝¹ : Group G\ninst✝ : Group G'\ne : MulEquiv G G'\nH : Subgroup G\ng : Subtype fun x => Membership.mem H x\n⊢ Eq (↑((e.subgroupMap H) g)) (e ↑g)","decl":"@[to_additive (attr := simp)]\ntheorem coe_subgroupMap_apply (e : G ≃* G') (H : Subgroup G) (g : H) :\n    ((subgroupMap e H g : H.map (e : G →* G')) : G') = e g :=\n  rfl\n\n"}
{"name":"AddEquiv.addSubgroupMap_symm_apply","module":"Mathlib.Algebra.Group.Subgroup.Map","initialProofState":"G : Type u_1\nG' : Type u_2\ninst✝¹ : AddGroup G\ninst✝ : AddGroup G'\ne : AddEquiv G G'\nH : AddSubgroup G\ng : Subtype fun x => Membership.mem (AddSubgroup.map (↑e) H) x\n⊢ Eq ((e.addSubgroupMap H).symm g) ⟨e.symm ↑g, ⋯⟩","decl":"@[to_additive (attr := simp)]\ntheorem subgroupMap_symm_apply (e : G ≃* G') (H : Subgroup G) (g : H.map (e : G →* G')) :\n    (e.subgroupMap H).symm g = ⟨e.symm g, SetLike.mem_coe.1 <| Set.mem_image_equiv.1 g.2⟩ :=\n  rfl\n\n"}
{"name":"MulEquiv.subgroupMap_symm_apply","module":"Mathlib.Algebra.Group.Subgroup.Map","initialProofState":"G : Type u_1\nG' : Type u_2\ninst✝¹ : Group G\ninst✝ : Group G'\ne : MulEquiv G G'\nH : Subgroup G\ng : Subtype fun x => Membership.mem (Subgroup.map (↑e) H) x\n⊢ Eq ((e.subgroupMap H).symm g) ⟨e.symm ↑g, ⋯⟩","decl":"@[to_additive (attr := simp)]\ntheorem subgroupMap_symm_apply (e : G ≃* G') (H : Subgroup G) (g : H.map (e : G →* G')) :\n    (e.subgroupMap H).symm g = ⟨e.symm g, SetLike.mem_coe.1 <| Set.mem_image_equiv.1 g.2⟩ :=\n  rfl\n\n"}
{"name":"AddMonoidHom.closure_preimage_le","module":"Mathlib.Algebra.Group.Subgroup.Map","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nN : Type u_5\ninst✝ : AddGroup N\nf : AddMonoidHom G N\ns : Set N\n⊢ LE.le (AddSubgroup.closure (Set.preimage (⇑f) s)) (AddSubgroup.comap f (AddSubgroup.closure s))","decl":"@[to_additive]\ntheorem closure_preimage_le (f : G →* N) (s : Set N) : closure (f ⁻¹' s) ≤ (closure s).comap f :=\n  (closure_le _).2 fun x hx => by rw [SetLike.mem_coe, mem_comap]; exact subset_closure hx\n\n"}
{"name":"MonoidHom.closure_preimage_le","module":"Mathlib.Algebra.Group.Subgroup.Map","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nN : Type u_5\ninst✝ : Group N\nf : MonoidHom G N\ns : Set N\n⊢ LE.le (Subgroup.closure (Set.preimage (⇑f) s)) (Subgroup.comap f (Subgroup.closure s))","decl":"@[to_additive]\ntheorem closure_preimage_le (f : G →* N) (s : Set N) : closure (f ⁻¹' s) ≤ (closure s).comap f :=\n  (closure_le _).2 fun x hx => by rw [SetLike.mem_coe, mem_comap]; exact subset_closure hx\n\n"}
{"name":"MonoidHom.map_closure","module":"Mathlib.Algebra.Group.Subgroup.Map","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nN : Type u_5\ninst✝ : Group N\nf : MonoidHom G N\ns : Set G\n⊢ Eq (Subgroup.map f (Subgroup.closure s)) (Subgroup.closure (Set.image (⇑f) s))","decl":"/-- The image under a monoid homomorphism of the subgroup generated by a set equals the subgroup\ngenerated by the image of the set. -/\n@[to_additive\n      \"The image under an `AddMonoid` hom of the `AddSubgroup` generated by a set equals\n      the `AddSubgroup` generated by the image of the set.\"]\ntheorem map_closure (f : G →* N) (s : Set G) : (closure s).map f = closure (f '' s) :=\n  Set.image_preimage.l_comm_of_u_comm (gc_map_comap f) (Subgroup.gi N).gc (Subgroup.gi G).gc\n    fun _ ↦ rfl\n\n"}
{"name":"AddMonoidHom.map_closure","module":"Mathlib.Algebra.Group.Subgroup.Map","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nN : Type u_5\ninst✝ : AddGroup N\nf : AddMonoidHom G N\ns : Set G\n⊢ Eq (AddSubgroup.map f (AddSubgroup.closure s)) (AddSubgroup.closure (Set.image (⇑f) s))","decl":"/-- The image under a monoid homomorphism of the subgroup generated by a set equals the subgroup\ngenerated by the image of the set. -/\n@[to_additive\n      \"The image under an `AddMonoid` hom of the `AddSubgroup` generated by a set equals\n      the `AddSubgroup` generated by the image of the set.\"]\ntheorem map_closure (f : G →* N) (s : Set G) : (closure s).map f = closure (f '' s) :=\n  Set.image_preimage.l_comm_of_u_comm (gc_map_comap f) (Subgroup.gi N).gc (Subgroup.gi G).gc\n    fun _ ↦ rfl\n\n"}
{"name":"Subgroup.equivMapOfInjective_coe_mulEquiv","module":"Mathlib.Algebra.Group.Subgroup.Map","initialProofState":"G : Type u_1\nG' : Type u_2\ninst✝¹ : Group G\ninst✝ : Group G'\nH : Subgroup G\ne : MulEquiv G G'\n⊢ Eq (H.equivMapOfInjective ↑e ⋯) (e.subgroupMap H)","decl":"@[to_additive (attr := simp)]\ntheorem equivMapOfInjective_coe_mulEquiv (H : Subgroup G) (e : G ≃* G') :\n    H.equivMapOfInjective (e : G →* G') (EquivLike.injective e) = e.subgroupMap H := by\n  ext\n  rfl\n\n"}
{"name":"AddSubgroup.equivMapOfInjective_coe_addEquiv","module":"Mathlib.Algebra.Group.Subgroup.Map","initialProofState":"G : Type u_1\nG' : Type u_2\ninst✝¹ : AddGroup G\ninst✝ : AddGroup G'\nH : AddSubgroup G\ne : AddEquiv G G'\n⊢ Eq (H.equivMapOfInjective ↑e ⋯) (e.addSubgroupMap H)","decl":"@[to_additive (attr := simp)]\ntheorem equivMapOfInjective_coe_mulEquiv (H : Subgroup G) (e : G ≃* G') :\n    H.equivMapOfInjective (e : G →* G') (EquivLike.injective e) = e.subgroupMap H := by\n  ext\n  rfl\n\n"}
