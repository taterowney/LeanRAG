{"name":"PerfectClosure.r_iff","module":"Mathlib.FieldTheory.PerfectClosure","initialProofState":"K : Type u\ninst✝² : CommRing K\np : Nat\ninst✝¹ : Fact (Nat.Prime p)\ninst✝ : CharP K p\na✝¹ a✝ : Prod Nat K\n⊢ Iff (PerfectClosure.R K p a✝¹ a✝) (Exists fun n => Exists fun x => And (Eq a✝¹ { fst := n, snd := x }) (Eq a✝ { fst := HAdd.hAdd n 1, snd := (frobenius K p) x }))","decl":"/-- `PerfectClosure.R` is the relation `(n, x) ∼ (n + 1, x ^ p)` for `n : ℕ` and `x : K`.\n`PerfectClosure K p` is the quotient by this relation. -/\n@[mk_iff]\ninductive PerfectClosure.R : ℕ × K → ℕ × K → Prop\n  | intro : ∀ n x, PerfectClosure.R (n, x) (n + 1, frobenius K p x)\n\n"}
{"name":"PerfectClosure.mk_surjective","module":"Mathlib.FieldTheory.PerfectClosure","initialProofState":"K : Type u\ninst✝² : CommRing K\np : Nat\ninst✝¹ : Fact (Nat.Prime p)\ninst✝ : CharP K p\n⊢ Function.Surjective (PerfectClosure.mk K p)","decl":"theorem mk_surjective : Function.Surjective (mk K p) := Quot.mk_surjective\n\n"}
{"name":"PerfectClosure.mk_succ_pow","module":"Mathlib.FieldTheory.PerfectClosure","initialProofState":"K : Type u\ninst✝² : CommRing K\np : Nat\ninst✝¹ : Fact (Nat.Prime p)\ninst✝ : CharP K p\nm : Nat\nx : K\n⊢ Eq (PerfectClosure.mk K p { fst := HAdd.hAdd m 1, snd := HPow.hPow x p }) (PerfectClosure.mk K p { fst := m, snd := x })","decl":"@[simp] theorem mk_succ_pow (m : ℕ) (x : K) : mk K p ⟨m + 1, x ^ p⟩ = mk K p ⟨m, x⟩ :=\n  Eq.symm <| Quot.sound (R.intro m x)\n\n"}
{"name":"PerfectClosure.quot_mk_eq_mk","module":"Mathlib.FieldTheory.PerfectClosure","initialProofState":"K : Type u\ninst✝² : CommRing K\np : Nat\ninst✝¹ : Fact (Nat.Prime p)\ninst✝ : CharP K p\nx : Prod Nat K\n⊢ Eq (Quot.mk (PerfectClosure.R K p) x) (PerfectClosure.mk K p x)","decl":"@[simp]\ntheorem quot_mk_eq_mk (x : ℕ × K) : (Quot.mk (R K p) x : PerfectClosure K p) = mk K p x :=\n  rfl\n\n"}
{"name":"PerfectClosure.liftOn_mk","module":"Mathlib.FieldTheory.PerfectClosure","initialProofState":"K : Type u\ninst✝² : CommRing K\np : Nat\ninst✝¹ : Fact (Nat.Prime p)\ninst✝ : CharP K p\nL : Type u_1\nf : Prod Nat K → L\nhf : ∀ (x y : Prod Nat K), PerfectClosure.R K p x y → Eq (f x) (f y)\nx : Prod Nat K\n⊢ Eq ((PerfectClosure.mk K p x).liftOn f hf) (f x)","decl":"@[simp]\ntheorem liftOn_mk {L : Sort _} (f : ℕ × K → L) (hf : ∀ x y, R K p x y → f x = f y) (x : ℕ × K) :\n    (mk K p x).liftOn f hf = f x :=\n  rfl\n\n"}
{"name":"PerfectClosure.induction_on","module":"Mathlib.FieldTheory.PerfectClosure","initialProofState":"K : Type u\ninst✝² : CommRing K\np : Nat\ninst✝¹ : Fact (Nat.Prime p)\ninst✝ : CharP K p\nx : PerfectClosure K p\nq : PerfectClosure K p → Prop\nh : ∀ (x : Prod Nat K), q (PerfectClosure.mk K p x)\n⊢ q x","decl":"@[elab_as_elim]\ntheorem induction_on (x : PerfectClosure K p) {q : PerfectClosure K p → Prop}\n    (h : ∀ x, q (mk K p x)) : q x :=\n  Quot.inductionOn x h\n\n"}
{"name":"PerfectClosure.mk_mul_mk","module":"Mathlib.FieldTheory.PerfectClosure","initialProofState":"K : Type u\ninst✝² : CommRing K\np : Nat\ninst✝¹ : Fact (Nat.Prime p)\ninst✝ : CharP K p\nx y : Prod Nat K\n⊢ Eq (HMul.hMul (PerfectClosure.mk K p x) (PerfectClosure.mk K p y)) (PerfectClosure.mk K p { fst := HAdd.hAdd x.1 y.1, snd := HMul.hMul (Nat.iterate (⇑(frobenius K p)) y.1 x.2) (Nat.iterate (⇑(frobenius K p)) x.1 y.2) })","decl":"@[simp]\ntheorem mk_mul_mk (x y : ℕ × K) :\n    mk K p x * mk K p y =\n      mk K p (x.1 + y.1, (frobenius K p)^[y.1] x.2 * (frobenius K p)^[x.1] y.2) :=\n  rfl\n\n"}
{"name":"PerfectClosure.one_def","module":"Mathlib.FieldTheory.PerfectClosure","initialProofState":"K : Type u\ninst✝² : CommRing K\np : Nat\ninst✝¹ : Fact (Nat.Prime p)\ninst✝ : CharP K p\n⊢ Eq 1 (PerfectClosure.mk K p { fst := 0, snd := 1 })","decl":"theorem one_def : (1 : PerfectClosure K p) = mk K p (0, 1) :=\n  rfl\n\n"}
{"name":"PerfectClosure.mk_add_mk","module":"Mathlib.FieldTheory.PerfectClosure","initialProofState":"K : Type u\ninst✝² : CommRing K\np : Nat\ninst✝¹ : Fact (Nat.Prime p)\ninst✝ : CharP K p\nx y : Prod Nat K\n⊢ Eq (HAdd.hAdd (PerfectClosure.mk K p x) (PerfectClosure.mk K p y)) (PerfectClosure.mk K p { fst := HAdd.hAdd x.1 y.1, snd := HAdd.hAdd (Nat.iterate (⇑(frobenius K p)) y.1 x.2) (Nat.iterate (⇑(frobenius K p)) x.1 y.2) })","decl":"@[simp]\ntheorem mk_add_mk (x y : ℕ × K) :\n    mk K p x + mk K p y =\n      mk K p (x.1 + y.1, (frobenius K p)^[y.1] x.2 + (frobenius K p)^[x.1] y.2) :=\n  rfl\n\n"}
{"name":"PerfectClosure.neg_mk","module":"Mathlib.FieldTheory.PerfectClosure","initialProofState":"K : Type u\ninst✝² : CommRing K\np : Nat\ninst✝¹ : Fact (Nat.Prime p)\ninst✝ : CharP K p\nx : Prod Nat K\n⊢ Eq (Neg.neg (PerfectClosure.mk K p x)) (PerfectClosure.mk K p { fst := x.1, snd := Neg.neg x.2 })","decl":"@[simp]\ntheorem neg_mk (x : ℕ × K) : -mk K p x = mk K p (x.1, -x.2) :=\n  rfl\n\n"}
{"name":"PerfectClosure.zero_def","module":"Mathlib.FieldTheory.PerfectClosure","initialProofState":"K : Type u\ninst✝² : CommRing K\np : Nat\ninst✝¹ : Fact (Nat.Prime p)\ninst✝ : CharP K p\n⊢ Eq 0 (PerfectClosure.mk K p { fst := 0, snd := 0 })","decl":"theorem zero_def : (0 : PerfectClosure K p) = mk K p (0, 0) :=\n  rfl\n\n"}
{"name":"PerfectClosure.mk_zero","module":"Mathlib.FieldTheory.PerfectClosure","initialProofState":"K : Type u\ninst✝² : CommRing K\np : Nat\ninst✝¹ : Fact (Nat.Prime p)\ninst✝ : CharP K p\n⊢ Eq (PerfectClosure.mk K p 0) 0","decl":"/-- Prior to https://github.com/leanprover-community/mathlib4/pull/15862, this lemma was called `mk_zero_zero`.\nSee `mk_zero_right` for the lemma used to be called `mk_zero`. -/\n@[simp]\ntheorem mk_zero : mk K p 0 = 0 :=\n  rfl\n\n"}
{"name":"PerfectClosure.mk_zero_zero","module":"Mathlib.FieldTheory.PerfectClosure","initialProofState":"K : Type u\ninst✝² : CommRing K\np : Nat\ninst✝¹ : Fact (Nat.Prime p)\ninst✝ : CharP K p\n⊢ Eq (PerfectClosure.mk K p 0) 0","decl":"@[deprecated (since := \"2024-08-16\")] alias mk_zero_zero := mk_zero\n\n-- Porting note: improved proof structure\n"}
{"name":"PerfectClosure.mk_zero_right","module":"Mathlib.FieldTheory.PerfectClosure","initialProofState":"K : Type u\ninst✝² : CommRing K\np : Nat\ninst✝¹ : Fact (Nat.Prime p)\ninst✝ : CharP K p\nn : Nat\n⊢ Eq (PerfectClosure.mk K p { fst := n, snd := 0 }) 0","decl":"@[simp]\ntheorem mk_zero_right (n : ℕ) : mk K p (n, 0) = 0 := by\n  induction' n with n ih\n  · rfl\n  rw [← ih]\n  symm\n  apply Quot.sound\n  have := R.intro (p := p) n (0 : K)\n  rwa [frobenius_zero K p] at this\n\n-- Porting note: improved proof structure\n"}
{"name":"PerfectClosure.R.sound","module":"Mathlib.FieldTheory.PerfectClosure","initialProofState":"K : Type u\ninst✝² : CommRing K\np : Nat\ninst✝¹ : Fact (Nat.Prime p)\ninst✝ : CharP K p\nm n : Nat\nx y : K\nH : Eq (Nat.iterate (⇑(frobenius K p)) m x) y\n⊢ Eq (PerfectClosure.mk K p { fst := n, snd := x }) (PerfectClosure.mk K p { fst := HAdd.hAdd m n, snd := y })","decl":"theorem R.sound (m n : ℕ) (x y : K) (H : (frobenius K p)^[m] x = y) :\n    mk K p (n, x) = mk K p (m + n, y) := by\n  subst H\n  induction' m with m ih\n  · simp only [zero_add, iterate_zero_apply]\n  rw [ih, Nat.succ_add, iterate_succ']\n  apply Quot.sound\n  apply R.intro\n\n"}
{"name":"PerfectClosure.mk_eq_iff","module":"Mathlib.FieldTheory.PerfectClosure","initialProofState":"K : Type u\ninst✝² : CommRing K\np : Nat\ninst✝¹ : Fact (Nat.Prime p)\ninst✝ : CharP K p\nx y : Prod Nat K\n⊢ Iff (Eq (PerfectClosure.mk K p x) (PerfectClosure.mk K p y)) (Exists fun z => Eq (Nat.iterate (⇑(frobenius K p)) (HAdd.hAdd y.1 z) x.2) (Nat.iterate (⇑(frobenius K p)) (HAdd.hAdd x.1 z) y.2))","decl":"theorem mk_eq_iff (x y : ℕ × K) :\n    mk K p x = mk K p y ↔ ∃ z, (frobenius K p)^[y.1 + z] x.2 = (frobenius K p)^[x.1 + z] y.2 := by\n  constructor\n  · intro H\n    replace H := Quot.eqvGen_exact H\n    induction H with\n    | rel x y H => cases' H with n x; exact ⟨0, rfl⟩\n    | refl H => exact ⟨0, rfl⟩\n    | symm x y H ih => cases' ih with w ih; exact ⟨w, ih.symm⟩\n    | trans x y z H1 H2 ih1 ih2 =>\n      cases' ih1 with z1 ih1\n      cases' ih2 with z2 ih2\n      exists z2 + (y.1 + z1)\n      rw [← add_assoc, iterate_add_apply, ih1]\n      rw [← iterate_add_apply, add_comm, iterate_add_apply, ih2]\n      rw [← iterate_add_apply]\n      simp only [add_comm, add_left_comm]\n  intro H\n  cases' x with m x\n  cases' y with n y\n  cases' H with z H; dsimp only at H\n  rw [R.sound K p (n + z) m x _ rfl, R.sound K p (m + z) n y _ rfl, H]\n  rw [add_assoc, add_comm, add_comm z]\n\n"}
{"name":"PerfectClosure.mk_pow","module":"Mathlib.FieldTheory.PerfectClosure","initialProofState":"K : Type u\ninst✝² : CommRing K\np : Nat\ninst✝¹ : Fact (Nat.Prime p)\ninst✝ : CharP K p\nx : Prod Nat K\nn : Nat\n⊢ Eq (HPow.hPow (PerfectClosure.mk K p x) n) (PerfectClosure.mk K p { fst := x.1, snd := HPow.hPow x.2 n })","decl":"@[simp]\ntheorem mk_pow (x : ℕ × K) (n : ℕ) : mk K p x ^ n = mk K p (x.1, x.2 ^ n) := by\n  induction n with\n  | zero =>\n    rw [pow_zero, pow_zero, one_def, mk_eq_iff]\n    exact ⟨0, by simp_rw [← coe_iterateFrobenius, map_one]⟩\n  | succ n ih =>\n    rw [pow_succ, pow_succ, ih, mk_mul_mk, mk_eq_iff]\n    exact ⟨0, by simp_rw [iterate_frobenius, add_zero, mul_pow, ← pow_mul,\n      ← pow_add, mul_assoc, ← pow_add]⟩\n\n"}
{"name":"PerfectClosure.natCast","module":"Mathlib.FieldTheory.PerfectClosure","initialProofState":"K : Type u\ninst✝² : CommRing K\np : Nat\ninst✝¹ : Fact (Nat.Prime p)\ninst✝ : CharP K p\nn x : Nat\n⊢ Eq (↑x) (PerfectClosure.mk K p { fst := n, snd := ↑x })","decl":"theorem natCast (n x : ℕ) : (x : PerfectClosure K p) = mk K p (n, x) := by\n  induction' n with n ih\n  · induction' x with x ih\n    · simp\n    rw [Nat.cast_succ, Nat.cast_succ, ih]\n    rfl\n  rw [ih]; apply Quot.sound\n  -- Porting note: was `conv`\n  suffices R K p (n, (x : K)) (Nat.succ n, frobenius K p (x : K)) by\n    rwa [frobenius_natCast K p x] at this\n  apply R.intro\n\n"}
{"name":"PerfectClosure.intCast","module":"Mathlib.FieldTheory.PerfectClosure","initialProofState":"K : Type u\ninst✝² : CommRing K\np : Nat\ninst✝¹ : Fact (Nat.Prime p)\ninst✝ : CharP K p\nx : Int\n⊢ Eq (↑x) (PerfectClosure.mk K p { fst := 0, snd := ↑x })","decl":"theorem intCast (x : ℤ) : (x : PerfectClosure K p) = mk K p (0, x) := by\n  induction x <;> simp only [Int.ofNat_eq_coe, Int.cast_natCast, Int.cast_negSucc, natCast K p 0]\n  rfl\n\n"}
{"name":"PerfectClosure.natCast_eq_iff","module":"Mathlib.FieldTheory.PerfectClosure","initialProofState":"K : Type u\ninst✝² : CommRing K\np : Nat\ninst✝¹ : Fact (Nat.Prime p)\ninst✝ : CharP K p\nx y : Nat\n⊢ Iff (Eq ↑x ↑y) (Eq ↑x ↑y)","decl":"theorem natCast_eq_iff (x y : ℕ) : (x : PerfectClosure K p) = y ↔ (x : K) = y := by\n  constructor <;> intro H\n  · rw [natCast K p 0, natCast K p 0, mk_eq_iff] at H\n    cases' H with z H\n    simpa only [zero_add, iterate_fixed (frobenius_natCast K p _)] using H\n  rw [natCast K p 0, natCast K p 0, H]\n\n"}
{"name":"PerfectClosure.instCharP","module":"Mathlib.FieldTheory.PerfectClosure","initialProofState":"K : Type u\ninst✝² : CommRing K\np : Nat\ninst✝¹ : Fact (Nat.Prime p)\ninst✝ : CharP K p\n⊢ CharP (PerfectClosure K p) p","decl":"instance instCharP : CharP (PerfectClosure K p) p := by\n  constructor; intro x; rw [← CharP.cast_eq_zero_iff K]\n  rw [← Nat.cast_zero, natCast_eq_iff, Nat.cast_zero]\n\n"}
{"name":"PerfectClosure.frobenius_mk","module":"Mathlib.FieldTheory.PerfectClosure","initialProofState":"K : Type u\ninst✝² : CommRing K\np : Nat\ninst✝¹ : Fact (Nat.Prime p)\ninst✝ : CharP K p\nx : Prod Nat K\n⊢ Eq ((frobenius (PerfectClosure K p) p) (PerfectClosure.mk K p x)) (PerfectClosure.mk K p { fst := x.1, snd := HPow.hPow x.2 p })","decl":"theorem frobenius_mk (x : ℕ × K) :\n    (frobenius (PerfectClosure K p) p : PerfectClosure K p → PerfectClosure K p) (mk K p x) =\n      mk _ _ (x.1, x.2 ^ p) := by\n  simp only [frobenius_def]\n  exact mk_pow K p x p\n\n"}
{"name":"PerfectClosure.of_apply","module":"Mathlib.FieldTheory.PerfectClosure","initialProofState":"K : Type u\ninst✝² : CommRing K\np : Nat\ninst✝¹ : Fact (Nat.Prime p)\ninst✝ : CharP K p\nx : K\n⊢ Eq ((PerfectClosure.of K p) x) (PerfectClosure.mk K p { fst := 0, snd := x })","decl":"theorem of_apply (x : K) : of K p x = mk _ _ (0, x) :=\n  rfl\n\n"}
{"name":"PerfectClosure.instReduced","module":"Mathlib.FieldTheory.PerfectClosure","initialProofState":"K : Type u\ninst✝² : CommRing K\np : Nat\ninst✝¹ : Fact (Nat.Prime p)\ninst✝ : CharP K p\n⊢ IsReduced (PerfectClosure K p)","decl":"instance instReduced : IsReduced (PerfectClosure K p) where\n  eq_zero x := induction_on x fun x ⟨n, h⟩ ↦ by\n    replace h : mk K p x ^ p ^ n = 0 := by\n      rw [← Nat.sub_add_cancel ((n.lt_pow_self (Fact.out : p.Prime).one_lt).le),\n        pow_add, h, mul_zero]\n    simp only [zero_def, mk_pow, mk_eq_iff, zero_add, ← coe_iterateFrobenius, map_zero] at h ⊢\n    obtain ⟨m, h⟩ := h\n    exact ⟨n + m, by simpa only [iterateFrobenius_def, pow_add, pow_mul] using h⟩\n\n"}
{"name":"PerfectClosure.instPerfectRing","module":"Mathlib.FieldTheory.PerfectClosure","initialProofState":"K : Type u\ninst✝² : CommRing K\np : Nat\ninst✝¹ : Fact (Nat.Prime p)\ninst✝ : CharP K p\n⊢ PerfectRing (PerfectClosure K p) p","decl":"instance instPerfectRing : PerfectRing (PerfectClosure K p) p where\n  bijective_frobenius := by\n    let f : PerfectClosure K p → PerfectClosure K p := fun e ↦\n      liftOn e (fun x => mk K p (x.1 + 1, x.2)) fun x y H =>\n      match x, y, H with\n      | _, _, R.intro n x => Quot.sound (R.intro _ _)\n    refine bijective_iff_has_inverse.mpr ⟨f, fun e ↦ induction_on e fun ⟨n, x⟩ ↦ ?_,\n      fun e ↦ induction_on e fun ⟨n, x⟩ ↦ ?_⟩ <;>\n      simp only [f, liftOn_mk, frobenius_mk, mk_succ_pow]\n\n"}
{"name":"PerfectClosure.iterate_frobenius_mk","module":"Mathlib.FieldTheory.PerfectClosure","initialProofState":"K : Type u\ninst✝² : CommRing K\np : Nat\ninst✝¹ : Fact (Nat.Prime p)\ninst✝ : CharP K p\nn : Nat\nx : K\n⊢ Eq (Nat.iterate (⇑(frobenius (PerfectClosure K p) p)) n (PerfectClosure.mk K p { fst := n, snd := x })) ((PerfectClosure.of K p) x)","decl":"@[simp]\ntheorem iterate_frobenius_mk (n : ℕ) (x : K) :\n    (frobenius (PerfectClosure K p) p)^[n] (mk K p ⟨n, x⟩) = of K p x := by\n  induction' n with n ih\n  · rfl\n  rw [iterate_succ_apply, ← ih, frobenius_mk, mk_succ_pow]\n\n"}
{"name":"PerfectClosure.eq_iff","module":"Mathlib.FieldTheory.PerfectClosure","initialProofState":"K : Type u\ninst✝³ : CommRing K\ninst✝² : IsReduced K\np : Nat\ninst✝¹ : Fact (Nat.Prime p)\ninst✝ : CharP K p\nx y : Prod Nat K\n⊢ Iff (Eq (PerfectClosure.mk K p x) (PerfectClosure.mk K p y)) (Eq (Nat.iterate (⇑(frobenius K p)) y.1 x.2) (Nat.iterate (⇑(frobenius K p)) x.1 y.2))","decl":"theorem eq_iff [CommRing K] [IsReduced K] (p : ℕ) [Fact p.Prime] [CharP K p] (x y : ℕ × K) :\n    mk K p x = mk K p y ↔ (frobenius K p)^[y.1] x.2 = (frobenius K p)^[x.1] y.2 :=\n  (mk_eq_iff K p x y).trans\n    ⟨fun ⟨z, H⟩ => (frobenius_inj K p).iterate z <| by simpa only [add_comm, iterate_add] using H,\n      fun H => ⟨0, H⟩⟩\n\n"}
{"name":"PerfectClosure.mk_inv","module":"Mathlib.FieldTheory.PerfectClosure","initialProofState":"K : Type u\ninst✝² : Field K\np : Nat\ninst✝¹ : Fact (Nat.Prime p)\ninst✝ : CharP K p\nx : Prod Nat K\n⊢ Eq (Inv.inv (PerfectClosure.mk K p x)) (PerfectClosure.mk K p { fst := x.1, snd := Inv.inv x.2 })","decl":"@[simp]\ntheorem mk_inv (x : ℕ × K) : (mk K p x)⁻¹ = mk K p (x.1, x.2⁻¹) :=\n  rfl\n\n-- Porting note: added to avoid \"unknown free variable\" error\n"}
{"name":"PerfectClosure.instPerfectField","module":"Mathlib.FieldTheory.PerfectClosure","initialProofState":"K : Type u\ninst✝² : Field K\np : Nat\ninst✝¹ : Fact (Nat.Prime p)\ninst✝ : CharP K p\n⊢ PerfectField (PerfectClosure K p)","decl":"instance instPerfectField : PerfectField (PerfectClosure K p) := PerfectRing.toPerfectField _ p\n\n"}
