{"name":"Finset.card_mul_le_card_shadow_mul","module":"Mathlib.Combinatorics.SetFamily.LYM","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\n𝒜 : Finset (Finset α)\nr : Nat\nh𝒜 : Set.Sized r ↑𝒜\n⊢ LE.le (HMul.hMul 𝒜.card r) (HMul.hMul 𝒜.shadow.card (HAdd.hAdd (HSub.hSub (Fintype.card α) r) 1))","decl":"/-- The downward **local LYM inequality**, with cancelled denominators. `𝒜` takes up less of `α^(r)`\n(the finsets of card `r`) than `∂𝒜` takes up of `α^(r - 1)`. -/\ntheorem card_mul_le_card_shadow_mul (h𝒜 : (𝒜 : Set (Finset α)).Sized r) :\n    #𝒜 * r ≤ #(∂ 𝒜) * (Fintype.card α - r + 1) := by\n  let i : DecidableRel ((· ⊆ ·) : Finset α → Finset α → Prop) := fun _ _ => Classical.dec _\n  refine card_mul_le_card_mul' (· ⊆ ·) (fun s hs => ?_) (fun s hs => ?_)\n  · rw [← h𝒜 hs, ← card_image_of_injOn s.erase_injOn]\n    refine card_le_card ?_\n    simp_rw [image_subset_iff, mem_bipartiteBelow]\n    exact fun a ha => ⟨erase_mem_shadow hs ha, erase_subset _ _⟩\n  refine le_trans ?_ tsub_tsub_le_tsub_add\n  rw [← (Set.Sized.shadow h𝒜) hs, ← card_compl, ← card_image_of_injOn (insert_inj_on' _)]\n  refine card_le_card fun t ht => ?_\n  rw [mem_bipartiteAbove] at ht\n  have : ∅ ∉ 𝒜 := by\n    rw [← mem_coe, h𝒜.empty_mem_iff, coe_eq_singleton]\n    rintro rfl\n    rw [shadow_singleton_empty] at hs\n    exact not_mem_empty s hs\n  have h := exists_eq_insert_iff.2 ⟨ht.2, by\n    rw [(sized_shadow_iff this).1 (Set.Sized.shadow h𝒜) ht.1, (Set.Sized.shadow h𝒜) hs]⟩\n  rcases h with ⟨a, ha, rfl⟩\n  exact mem_image_of_mem _ (mem_compl.2 ha)\n\n"}
{"name":"Finset.card_div_choose_le_card_shadow_div_choose","module":"Mathlib.Combinatorics.SetFamily.LYM","initialProofState":"𝕜 : Type u_1\nα : Type u_2\ninst✝² : LinearOrderedField 𝕜\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\n𝒜 : Finset (Finset α)\nr : Nat\nhr : Ne r 0\nh𝒜 : Set.Sized r ↑𝒜\n⊢ LE.le (HDiv.hDiv ↑𝒜.card ↑((Fintype.card α).choose r)) (HDiv.hDiv ↑𝒜.shadow.card ↑((Fintype.card α).choose (HSub.hSub r 1)))","decl":"/-- The downward **local LYM inequality**. `𝒜` takes up less of `α^(r)` (the finsets of card `r`)\nthan `∂𝒜` takes up of `α^(r - 1)`. -/\ntheorem card_div_choose_le_card_shadow_div_choose (hr : r ≠ 0)\n    (h𝒜 : (𝒜 : Set (Finset α)).Sized r) : (#𝒜 : 𝕜) / (Fintype.card α).choose r\n    ≤ #(∂ 𝒜) / (Fintype.card α).choose (r - 1) := by\n  obtain hr' | hr' := lt_or_le (Fintype.card α) r\n  · rw [choose_eq_zero_of_lt hr', cast_zero, div_zero]\n    exact div_nonneg (cast_nonneg _) (cast_nonneg _)\n  replace h𝒜 := card_mul_le_card_shadow_mul h𝒜\n  rw [div_le_div_iff₀] <;> norm_cast\n  · cases' r with r\n    · exact (hr rfl).elim\n    rw [tsub_add_eq_add_tsub hr', add_tsub_add_eq_tsub_right] at h𝒜\n    apply le_of_mul_le_mul_right _ (pos_iff_ne_zero.2 hr)\n    convert Nat.mul_le_mul_right ((Fintype.card α).choose r) h𝒜 using 1\n    · simpa [mul_assoc, Nat.choose_succ_right_eq] using Or.inl (mul_comm _ _)\n    · simp only [mul_assoc, choose_succ_right_eq, mul_eq_mul_left_iff]\n      exact Or.inl (mul_comm _ _)\n  · exact Nat.choose_pos hr'\n  · exact Nat.choose_pos (r.pred_le.trans hr')\n\n"}
{"name":"Finset.mem_falling","module":"Mathlib.Combinatorics.SetFamily.LYM","initialProofState":"α : Type u_2\ninst✝ : DecidableEq α\nk : Nat\n𝒜 : Finset (Finset α)\ns : Finset α\n⊢ Iff (Membership.mem (Finset.falling k 𝒜) s) (And (Exists fun t => And (Membership.mem 𝒜 t) (HasSubset.Subset s t)) (Eq s.card k))","decl":"theorem mem_falling : s ∈ falling k 𝒜 ↔ (∃ t ∈ 𝒜, s ⊆ t) ∧ #s = k := by\n  simp_rw [falling, mem_sup, mem_powersetCard]\n  aesop\n\n"}
{"name":"Finset.sized_falling","module":"Mathlib.Combinatorics.SetFamily.LYM","initialProofState":"α : Type u_2\ninst✝ : DecidableEq α\nk : Nat\n𝒜 : Finset (Finset α)\n⊢ Set.Sized k ↑(Finset.falling k 𝒜)","decl":"theorem sized_falling : (falling k 𝒜 : Set (Finset α)).Sized k := fun _ hs => (mem_falling.1 hs).2\n\n"}
{"name":"Finset.slice_subset_falling","module":"Mathlib.Combinatorics.SetFamily.LYM","initialProofState":"α : Type u_2\ninst✝ : DecidableEq α\nk : Nat\n𝒜 : Finset (Finset α)\n⊢ HasSubset.Subset (𝒜.slice k) (Finset.falling k 𝒜)","decl":"theorem slice_subset_falling : 𝒜 # k ⊆ falling k 𝒜 := fun s hs =>\n  mem_falling.2 <| (mem_slice.1 hs).imp_left fun h => ⟨s, h, Subset.refl _⟩\n\n"}
{"name":"Finset.falling_zero_subset","module":"Mathlib.Combinatorics.SetFamily.LYM","initialProofState":"α : Type u_2\ninst✝ : DecidableEq α\n𝒜 : Finset (Finset α)\n⊢ HasSubset.Subset (Finset.falling 0 𝒜) (Singleton.singleton EmptyCollection.emptyCollection)","decl":"theorem falling_zero_subset : falling 0 𝒜 ⊆ {∅} :=\n  subset_singleton_iff'.2 fun _ ht => card_eq_zero.1 <| sized_falling _ _ ht\n\n"}
{"name":"Finset.slice_union_shadow_falling_succ","module":"Mathlib.Combinatorics.SetFamily.LYM","initialProofState":"α : Type u_2\ninst✝ : DecidableEq α\nk : Nat\n𝒜 : Finset (Finset α)\n⊢ Eq (Union.union (𝒜.slice k) (Finset.falling (HAdd.hAdd k 1) 𝒜).shadow) (Finset.falling k 𝒜)","decl":"theorem slice_union_shadow_falling_succ : 𝒜 # k ∪ ∂ (falling (k + 1) 𝒜) = falling k 𝒜 := by\n  ext s\n  simp_rw [mem_union, mem_slice, mem_shadow_iff, mem_falling]\n  constructor\n  · rintro (h | ⟨s, ⟨⟨t, ht, hst⟩, hs⟩, a, ha, rfl⟩)\n    · exact ⟨⟨s, h.1, Subset.refl _⟩, h.2⟩\n    refine ⟨⟨t, ht, (erase_subset _ _).trans hst⟩, ?_⟩\n    rw [card_erase_of_mem ha, hs]\n    rfl\n  · rintro ⟨⟨t, ht, hst⟩, hs⟩\n    by_cases h : s ∈ 𝒜\n    · exact Or.inl ⟨h, hs⟩\n    obtain ⟨a, ha, hst⟩ := ssubset_iff.1 (ssubset_of_subset_of_ne hst (ht.ne_of_not_mem h).symm)\n    refine Or.inr ⟨insert a s, ⟨⟨t, ht, hst⟩, ?_⟩, a, mem_insert_self _ _, erase_insert ha⟩\n    rw [card_insert_of_not_mem ha, hs]\n\n"}
{"name":"Finset.IsAntichain.disjoint_slice_shadow_falling","module":"Mathlib.Combinatorics.SetFamily.LYM","initialProofState":"α : Type u_2\ninst✝ : DecidableEq α\n𝒜 : Finset (Finset α)\nm n : Nat\nh𝒜 : IsAntichain (fun x1 x2 => HasSubset.Subset x1 x2) ↑𝒜\n⊢ Disjoint (𝒜.slice m) (Finset.falling n 𝒜).shadow","decl":"/-- The shadow of `falling m 𝒜` is disjoint from the `n`-sized elements of `𝒜`, thanks to the\nantichain property. -/\ntheorem IsAntichain.disjoint_slice_shadow_falling {m n : ℕ}\n    (h𝒜 : IsAntichain (· ⊆ ·) (𝒜 : Set (Finset α))) : Disjoint (𝒜 # m) (∂ (falling n 𝒜)) :=\n  disjoint_right.2 fun s h₁ h₂ => by\n    simp_rw [mem_shadow_iff, mem_falling] at h₁\n    obtain ⟨s, ⟨⟨t, ht, hst⟩, _⟩, a, ha, rfl⟩ := h₁\n    refine h𝒜 (slice_subset h₂) ht ?_ ((erase_subset _ _).trans hst)\n    rintro rfl\n    exact not_mem_erase _ _ (hst ha)\n\n"}
{"name":"Finset.le_card_falling_div_choose","module":"Mathlib.Combinatorics.SetFamily.LYM","initialProofState":"𝕜 : Type u_1\nα : Type u_2\ninst✝² : LinearOrderedField 𝕜\ninst✝¹ : DecidableEq α\nk : Nat\n𝒜 : Finset (Finset α)\ninst✝ : Fintype α\nhk : LE.le k (Fintype.card α)\nh𝒜 : IsAntichain (fun x1 x2 => HasSubset.Subset x1 x2) ↑𝒜\n⊢ LE.le ((Finset.range (HAdd.hAdd k 1)).sum fun r => HDiv.hDiv ↑(𝒜.slice (HSub.hSub (Fintype.card α) r)).card ↑((Fintype.card α).choose (HSub.hSub (Fintype.card α) r))) (HDiv.hDiv ↑(Finset.falling (HSub.hSub (Fintype.card α) k) 𝒜).card ↑((Fintype.card α).choose (HSub.hSub (Fintype.card α) k)))","decl":"/-- A bound on any top part of the sum in LYM in terms of the size of `falling k 𝒜`. -/\ntheorem le_card_falling_div_choose [Fintype α] (hk : k ≤ Fintype.card α)\n    (h𝒜 : IsAntichain (· ⊆ ·) (𝒜 : Set (Finset α))) :\n    (∑ r ∈ range (k + 1),\n        (#(𝒜 # (Fintype.card α - r)) : 𝕜) / (Fintype.card α).choose (Fintype.card α - r)) ≤\n      (falling (Fintype.card α - k) 𝒜).card / (Fintype.card α).choose (Fintype.card α - k) := by\n  induction' k with k ih\n  · simp only [tsub_zero, cast_one, cast_le, sum_singleton, div_one, choose_self, range_one,\n      zero_eq, zero_add, range_one, sum_singleton, nonpos_iff_eq_zero, tsub_zero,\n      choose_self, cast_one, div_one, cast_le]\n    exact card_le_card (slice_subset_falling _ _)\n  rw [sum_range_succ, ← slice_union_shadow_falling_succ,\n    card_union_of_disjoint (IsAntichain.disjoint_slice_shadow_falling h𝒜), cast_add, _root_.add_div,\n    add_comm]\n  rw [← tsub_tsub, tsub_add_cancel_of_le (le_tsub_of_add_le_left hk)]\n  exact\n    add_le_add_left\n      ((ih <| le_of_succ_le hk).trans <|\n        card_div_choose_le_card_shadow_div_choose (tsub_pos_iff_lt.2 <| Nat.succ_le_iff.1 hk).ne' <|\n          sized_falling _ _) _\n\n"}
{"name":"Finset.sum_card_slice_div_choose_le_one","module":"Mathlib.Combinatorics.SetFamily.LYM","initialProofState":"𝕜 : Type u_1\nα : Type u_2\ninst✝¹ : LinearOrderedField 𝕜\n𝒜 : Finset (Finset α)\ninst✝ : Fintype α\nh𝒜 : IsAntichain (fun x1 x2 => HasSubset.Subset x1 x2) ↑𝒜\n⊢ LE.le ((Finset.range (HAdd.hAdd (Fintype.card α) 1)).sum fun r => HDiv.hDiv ↑(𝒜.slice r).card ↑((Fintype.card α).choose r)) 1","decl":"/-- The **Lubell-Yamamoto-Meshalkin inequality**. If `𝒜` is an antichain, then the sum of the\nproportion of elements it takes from each layer is less than `1`. -/\ntheorem sum_card_slice_div_choose_le_one [Fintype α]\n    (h𝒜 : IsAntichain (· ⊆ ·) (𝒜 : Set (Finset α))) :\n    (∑ r ∈ range (Fintype.card α + 1), (#(𝒜 # r) : 𝕜) / (Fintype.card α).choose r) ≤ 1 := by\n  classical\n    rw [← sum_flip]\n    refine (le_card_falling_div_choose le_rfl h𝒜).trans ?_\n    rw [div_le_iff₀] <;> norm_cast\n    · simpa only [Nat.sub_self, one_mul, Nat.choose_zero_right, falling] using\n        Set.Sized.card_le (sized_falling 0 𝒜)\n    · rw [tsub_self, choose_zero_right]\n      exact zero_lt_one\n\n"}
{"name":"IsAntichain.sperner","module":"Mathlib.Combinatorics.SetFamily.LYM","initialProofState":"α : Type u_2\ninst✝ : Fintype α\n𝒜 : Finset (Finset α)\nh𝒜 : IsAntichain (fun x1 x2 => HasSubset.Subset x1 x2) ↑𝒜\n⊢ LE.le 𝒜.card ((Fintype.card α).choose (HDiv.hDiv (Fintype.card α) 2))","decl":"/-- **Sperner's theorem**. The size of an antichain in `Finset α` is bounded by the size of the\nmaximal layer in `Finset α`. This precisely means that `Finset α` is a Sperner order. -/\ntheorem _root_.IsAntichain.sperner [Fintype α] {𝒜 : Finset (Finset α)}\n    (h𝒜 : IsAntichain (· ⊆ ·) (𝒜 : Set (Finset α))) :\n    #𝒜 ≤ (Fintype.card α).choose (Fintype.card α / 2) := by\n  classical\n    suffices (∑ r ∈ Iic (Fintype.card α),\n        (#(𝒜 # r) : ℚ) / (Fintype.card α).choose (Fintype.card α / 2)) ≤ 1 by\n      rw [← sum_div, ← Nat.cast_sum, div_le_one] at this\n      · simp only [cast_le] at this\n        rwa [sum_card_slice] at this\n      simp only [cast_pos]\n      exact choose_pos (Nat.div_le_self _ _)\n    rw [Iic_eq_Icc, ← Ico_succ_right, bot_eq_zero, Ico_zero_eq_range]\n    refine (sum_le_sum fun r hr => ?_).trans (sum_card_slice_div_choose_le_one h𝒜)\n    rw [mem_range] at hr\n    refine div_le_div_of_nonneg_left ?_ ?_ ?_ <;> norm_cast\n    · exact Nat.zero_le _\n    · exact choose_pos (Nat.lt_succ_iff.1 hr)\n    · exact choose_le_middle _ _\n\n"}
