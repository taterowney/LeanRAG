{"name":"ContextFreeRule.mk.sizeOf_spec","module":"Mathlib.Computability.ContextFreeGrammar","initialProofState":"T : Type uT\nN : Type uN\ninst✝¹ : SizeOf T\ninst✝ : SizeOf N\ninput : N\noutput : List (Symbol T N)\n⊢ Eq (SizeOf.sizeOf { input := input, output := output }) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf input)) (SizeOf.sizeOf output))","decl":"universe uT uN in\n/-- Rule that rewrites a single nonterminal to any string (a list of symbols). -/\n@[ext]\nstructure ContextFreeRule (T : Type uT) (N : Type uN) where\n  /-- Input nonterminal a.k.a. left-hand side. -/\n  input : N\n  /-- Output string a.k.a. right-hand side. -/\n  output : List (Symbol T N)\n\n"}
{"name":"ContextFreeRule.ext","module":"Mathlib.Computability.ContextFreeGrammar","initialProofState":"T : Type uT\nN : Type uN\nx y : ContextFreeRule T N\ninput : Eq x.input y.input\noutput : Eq x.output y.output\n⊢ Eq x y","decl":"universe uT uN in\n/-- Rule that rewrites a single nonterminal to any string (a list of symbols). -/\n@[ext]\nstructure ContextFreeRule (T : Type uT) (N : Type uN) where\n  /-- Input nonterminal a.k.a. left-hand side. -/\n  input : N\n  /-- Output string a.k.a. right-hand side. -/\n  output : List (Symbol T N)\n\n"}
{"name":"ContextFreeRule.mk.injEq","module":"Mathlib.Computability.ContextFreeGrammar","initialProofState":"T : Type uT\nN : Type uN\ninput✝ : N\noutput✝ : List (Symbol T N)\ninput : N\noutput : List (Symbol T N)\n⊢ Eq (Eq { input := input✝, output := output✝ } { input := input, output := output }) (And (Eq input✝ input) (Eq output✝ output))","decl":"universe uT uN in\n/-- Rule that rewrites a single nonterminal to any string (a list of symbols). -/\n@[ext]\nstructure ContextFreeRule (T : Type uT) (N : Type uN) where\n  /-- Input nonterminal a.k.a. left-hand side. -/\n  input : N\n  /-- Output string a.k.a. right-hand side. -/\n  output : List (Symbol T N)\n\n"}
{"name":"ContextFreeRule.mk.inj","module":"Mathlib.Computability.ContextFreeGrammar","initialProofState":"T : Type uT\nN : Type uN\ninput✝ : N\noutput✝ : List (Symbol T N)\ninput : N\noutput : List (Symbol T N)\nx✝ : Eq { input := input✝, output := output✝ } { input := input, output := output }\n⊢ And (Eq input✝ input) (Eq output✝ output)","decl":"universe uT uN in\n/-- Rule that rewrites a single nonterminal to any string (a list of symbols). -/\n@[ext]\nstructure ContextFreeRule (T : Type uT) (N : Type uN) where\n  /-- Input nonterminal a.k.a. left-hand side. -/\n  input : N\n  /-- Output string a.k.a. right-hand side. -/\n  output : List (Symbol T N)\n\n"}
{"name":"ContextFreeRule.ext_iff","module":"Mathlib.Computability.ContextFreeGrammar","initialProofState":"T : Type uT\nN : Type uN\nx y : ContextFreeRule T N\n⊢ Iff (Eq x y) (And (Eq x.input y.input) (Eq x.output y.output))","decl":"universe uT uN in\n/-- Rule that rewrites a single nonterminal to any string (a list of symbols). -/\n@[ext]\nstructure ContextFreeRule (T : Type uT) (N : Type uN) where\n  /-- Input nonterminal a.k.a. left-hand side. -/\n  input : N\n  /-- Output string a.k.a. right-hand side. -/\n  output : List (Symbol T N)\n\n"}
{"name":"ContextFreeGrammar.mk.injEq","module":"Mathlib.Computability.ContextFreeGrammar","initialProofState":"T : Type uT\nNT✝ : Type uN\ninitial✝ : NT✝\nrules✝ : Finset (ContextFreeRule T NT✝)\nNT : Type uN\ninitial : NT\nrules : Finset (ContextFreeRule T NT)\n⊢ Eq (Eq { NT := NT✝, initial := initial✝, rules := rules✝ } { NT := NT, initial := initial, rules := rules }) (And (Eq NT✝ NT) (And (HEq initial✝ initial) (HEq rules✝ rules)))","decl":"/-- Context-free grammar that generates words over the alphabet `T` (a type of terminals). -/\nstructure ContextFreeGrammar.{uN,uT} (T : Type uT) where\n  /-- Type of nonterminals. -/\n  NT : Type uN\n  /-- Initial nonterminal. -/\n  initial : NT\n  /-- Rewrite rules. -/\n  rules : Finset (ContextFreeRule T NT)\n\n"}
{"name":"ContextFreeGrammar.mk.inj","module":"Mathlib.Computability.ContextFreeGrammar","initialProofState":"T : Type uT\nNT✝ : Type uN\ninitial✝ : NT✝\nrules✝ : Finset (ContextFreeRule T NT✝)\nNT : Type uN\ninitial : NT\nrules : Finset (ContextFreeRule T NT)\nx✝ : Eq { NT := NT✝, initial := initial✝, rules := rules✝ } { NT := NT, initial := initial, rules := rules }\n⊢ And (Eq NT✝ NT) (And (HEq initial✝ initial) (HEq rules✝ rules))","decl":"/-- Context-free grammar that generates words over the alphabet `T` (a type of terminals). -/\nstructure ContextFreeGrammar.{uN,uT} (T : Type uT) where\n  /-- Type of nonterminals. -/\n  NT : Type uN\n  /-- Initial nonterminal. -/\n  initial : NT\n  /-- Rewrite rules. -/\n  rules : Finset (ContextFreeRule T NT)\n\n"}
{"name":"ContextFreeGrammar.mk.sizeOf_spec","module":"Mathlib.Computability.ContextFreeGrammar","initialProofState":"T : Type uT\ninst✝ : SizeOf T\nNT : Type uN\ninitial : NT\nrules : Finset (ContextFreeRule T NT)\n⊢ Eq (SizeOf.sizeOf { NT := NT, initial := initial, rules := rules }) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf NT)) (SizeOf.sizeOf initial)) (SizeOf.sizeOf rules))","decl":"/-- Context-free grammar that generates words over the alphabet `T` (a type of terminals). -/\nstructure ContextFreeGrammar.{uN,uT} (T : Type uT) where\n  /-- Type of nonterminals. -/\n  NT : Type uN\n  /-- Initial nonterminal. -/\n  initial : NT\n  /-- Rewrite rules. -/\n  rules : Finset (ContextFreeRule T NT)\n\n"}
{"name":"ContextFreeRule.Rewrites.brecOn","module":"Mathlib.Computability.ContextFreeGrammar","initialProofState":"T : Type uT\nN : Type uN\nr : ContextFreeRule T N\nmotive✝ : (a a_1 : List (Symbol T N)) → r.Rewrites a a_1 → Prop\na✝¹ a✝ : List (Symbol T N)\nx✝ : r.Rewrites a✝¹ a✝\nih✝ : ∀ (a a_1 : List (Symbol T N)) (x : r.Rewrites a a_1), x.below → motive✝ a a_1 x\n⊢ motive✝ a✝¹ a✝ x✝","decl":"/-- Inductive definition of a single application of a given context-free rule `r` to a string `u`;\n`r.Rewrites u v` means that the `r` sends `u` to `v` (there may be multiple such strings `v`). -/\ninductive Rewrites (r : ContextFreeRule T N) : List (Symbol T N) → List (Symbol T N) → Prop\n  /-- The replacement is at the start of the remaining string. -/\n  | head (s : List (Symbol T N)) :\n      r.Rewrites (Symbol.nonterminal r.input :: s) (r.output ++ s)\n  /-- There is a replacement later in the string. -/\n  | cons (x : Symbol T N) {s₁ s₂ : List (Symbol T N)} (hrs : Rewrites r s₁ s₂) :\n      r.Rewrites (x :: s₁) (x :: s₂)\n\n"}
{"name":"ContextFreeRule.Rewrites.exists_parts","module":"Mathlib.Computability.ContextFreeGrammar","initialProofState":"T : Type uT\nN : Type uN\nr : ContextFreeRule T N\nu v : List (Symbol T N)\nhr : r.Rewrites u v\n⊢ Exists fun p => Exists fun q => And (Eq u (HAppend.hAppend (HAppend.hAppend p (List.cons (Symbol.nonterminal r.input) List.nil)) q)) (Eq v (HAppend.hAppend (HAppend.hAppend p r.output) q))","decl":"lemma Rewrites.exists_parts (hr : r.Rewrites u v) :\n    ∃ p q : List (Symbol T N),\n      u = p ++ [Symbol.nonterminal r.input] ++ q ∧ v = p ++ r.output ++ q := by\n  induction hr with\n  | head s =>\n    use [], s\n    simp\n  | cons x _ ih =>\n    rcases ih with ⟨p', q', rfl, rfl⟩\n    use x :: p', q'\n    simp\n\n"}
{"name":"ContextFreeRule.Rewrites.input_output","module":"Mathlib.Computability.ContextFreeGrammar","initialProofState":"T : Type uT\nN : Type uN\nr : ContextFreeRule T N\n⊢ r.Rewrites (List.cons (Symbol.nonterminal r.input) List.nil) r.output","decl":"lemma Rewrites.input_output : r.Rewrites [.nonterminal r.input] r.output := by\n  simpa using head []\n\n"}
{"name":"ContextFreeRule.rewrites_of_exists_parts","module":"Mathlib.Computability.ContextFreeGrammar","initialProofState":"T : Type uT\nN : Type uN\nr : ContextFreeRule T N\np q : List (Symbol T N)\n⊢ r.Rewrites (HAppend.hAppend (HAppend.hAppend p (List.cons (Symbol.nonterminal r.input) List.nil)) q) (HAppend.hAppend (HAppend.hAppend p r.output) q)","decl":"lemma rewrites_of_exists_parts (r : ContextFreeRule T N) (p q : List (Symbol T N)) :\n    r.Rewrites (p ++ [Symbol.nonterminal r.input] ++ q) (p ++ r.output ++ q) := by\n  induction p with\n  | nil         => exact Rewrites.head q\n  | cons d l ih => exact Rewrites.cons d ih\n\n"}
{"name":"ContextFreeRule.rewrites_iff","module":"Mathlib.Computability.ContextFreeGrammar","initialProofState":"T : Type uT\nN : Type uN\nr : ContextFreeRule T N\nu v : List (Symbol T N)\n⊢ Iff (r.Rewrites u v) (Exists fun p => Exists fun q => And (Eq u (HAppend.hAppend (HAppend.hAppend p (List.cons (Symbol.nonterminal r.input) List.nil)) q)) (Eq v (HAppend.hAppend (HAppend.hAppend p r.output) q)))","decl":"/-- Rule `r` rewrites string `u` is to string `v` iff they share both a prefix `p` and postfix `q`\nsuch that the remaining middle part of `u` is the input of `r` and the remaining middle part\nof `u` is the output of `r`. -/\ntheorem rewrites_iff :\n    r.Rewrites u v ↔ ∃ p q : List (Symbol T N),\n      u = p ++ [Symbol.nonterminal r.input] ++ q ∧ v = p ++ r.output ++ q :=\n  ⟨Rewrites.exists_parts, by rintro ⟨p, q, rfl, rfl⟩; apply rewrites_of_exists_parts⟩\n\n"}
{"name":"ContextFreeRule.Rewrites.append_left","module":"Mathlib.Computability.ContextFreeGrammar","initialProofState":"T : Type uT\nN : Type uN\nr : ContextFreeRule T N\nu v : List (Symbol T N)\nhvw : r.Rewrites u v\np : List (Symbol T N)\n⊢ r.Rewrites (HAppend.hAppend p u) (HAppend.hAppend p v)","decl":"/-- Add extra prefix to context-free rewriting. -/\nlemma Rewrites.append_left (hvw : r.Rewrites u v) (p : List (Symbol T N)) :\n    r.Rewrites (p ++ u) (p ++ v) := by\n  rw [rewrites_iff] at *\n  rcases hvw with ⟨x, y, hxy⟩\n  use p ++ x, y\n  simp_all\n\n"}
{"name":"ContextFreeRule.Rewrites.append_right","module":"Mathlib.Computability.ContextFreeGrammar","initialProofState":"T : Type uT\nN : Type uN\nr : ContextFreeRule T N\nu v : List (Symbol T N)\nhvw : r.Rewrites u v\np : List (Symbol T N)\n⊢ r.Rewrites (HAppend.hAppend u p) (HAppend.hAppend v p)","decl":"/-- Add extra postfix to context-free rewriting. -/\nlemma Rewrites.append_right (hvw : r.Rewrites u v) (p : List (Symbol T N)) :\n    r.Rewrites (u ++ p) (v ++ p) := by\n  rw [rewrites_iff] at *\n  rcases hvw with ⟨x, y, hxy⟩\n  use x, y ++ p\n  simp_all\n\n"}
{"name":"ContextFreeGrammar.mem_language_iff","module":"Mathlib.Computability.ContextFreeGrammar","initialProofState":"T : Type uT\ng : ContextFreeGrammar T\nw : List T\n⊢ Iff (Membership.mem g.language w) (g.Derives (List.cons (Symbol.nonterminal g.initial) List.nil) (List.map Symbol.terminal w))","decl":"/-- A given word `w` belongs to the language generated by a given context-free grammar `g` iff\n`g` can derive the word `w` (wrapped as a string) from the initial nonterminal of `g` in some\nnumber of steps. -/\n@[simp]\nlemma mem_language_iff (g : ContextFreeGrammar.{uN} T) (w : List T) :\n    w ∈ g.language ↔ g.Derives [Symbol.nonterminal g.initial] (List.map Symbol.terminal w) := by\n  rfl\n\n"}
{"name":"ContextFreeGrammar.Derives.refl","module":"Mathlib.Computability.ContextFreeGrammar","initialProofState":"T : Type uT\ng : ContextFreeGrammar T\nw : List (Symbol T g.NT)\n⊢ g.Derives w w","decl":"@[refl]\nlemma Derives.refl (w : List (Symbol T g.NT)) : g.Derives w w :=\n  Relation.ReflTransGen.refl\n\n"}
{"name":"ContextFreeGrammar.Produces.single","module":"Mathlib.Computability.ContextFreeGrammar","initialProofState":"T : Type uT\ng : ContextFreeGrammar T\nv w : List (Symbol T g.NT)\nhvw : g.Produces v w\n⊢ g.Derives v w","decl":"lemma Produces.single {v w : List (Symbol T g.NT)} (hvw : g.Produces v w) : g.Derives v w :=\n  Relation.ReflTransGen.single hvw\n\n"}
{"name":"ContextFreeGrammar.Derives.trans","module":"Mathlib.Computability.ContextFreeGrammar","initialProofState":"T : Type uT\ng : ContextFreeGrammar T\nu v w : List (Symbol T g.NT)\nhuv : g.Derives u v\nhvw : g.Derives v w\n⊢ g.Derives u w","decl":"@[trans]\nlemma Derives.trans {u v w : List (Symbol T g.NT)} (huv : g.Derives u v) (hvw : g.Derives v w) :\n    g.Derives u w :=\n  Relation.ReflTransGen.trans huv hvw\n\n"}
{"name":"ContextFreeGrammar.Derives.trans_produces","module":"Mathlib.Computability.ContextFreeGrammar","initialProofState":"T : Type uT\ng : ContextFreeGrammar T\nu v w : List (Symbol T g.NT)\nhuv : g.Derives u v\nhvw : g.Produces v w\n⊢ g.Derives u w","decl":"lemma Derives.trans_produces {u v w : List (Symbol T g.NT)}\n    (huv : g.Derives u v) (hvw : g.Produces v w) :\n    g.Derives u w :=\n  huv.trans hvw.single\n\n"}
{"name":"ContextFreeGrammar.Produces.trans_derives","module":"Mathlib.Computability.ContextFreeGrammar","initialProofState":"T : Type uT\ng : ContextFreeGrammar T\nu v w : List (Symbol T g.NT)\nhuv : g.Produces u v\nhvw : g.Derives v w\n⊢ g.Derives u w","decl":"lemma Produces.trans_derives {u v w : List (Symbol T g.NT)}\n    (huv : g.Produces u v) (hvw : g.Derives v w) :\n    g.Derives u w :=\n  huv.single.trans hvw\n\n"}
{"name":"ContextFreeGrammar.Derives.eq_or_head","module":"Mathlib.Computability.ContextFreeGrammar","initialProofState":"T : Type uT\ng : ContextFreeGrammar T\nu w : List (Symbol T g.NT)\nhuw : g.Derives u w\n⊢ Or (Eq u w) (Exists fun v => And (g.Produces u v) (g.Derives v w))","decl":"lemma Derives.eq_or_head {u w : List (Symbol T g.NT)} (huw : g.Derives u w) :\n    u = w ∨ ∃ v : List (Symbol T g.NT), g.Produces u v ∧ g.Derives v w :=\n  Relation.ReflTransGen.cases_head huw\n\n"}
{"name":"ContextFreeGrammar.Derives.eq_or_tail","module":"Mathlib.Computability.ContextFreeGrammar","initialProofState":"T : Type uT\ng : ContextFreeGrammar T\nu w : List (Symbol T g.NT)\nhuw : g.Derives u w\n⊢ Or (Eq u w) (Exists fun v => And (g.Derives u v) (g.Produces v w))","decl":"lemma Derives.eq_or_tail {u w : List (Symbol T g.NT)} (huw : g.Derives u w) :\n    u = w ∨ ∃ v : List (Symbol T g.NT), g.Derives u v ∧ g.Produces v w :=\n  (Relation.ReflTransGen.cases_tail huw).casesOn (Or.inl ∘ Eq.symm) Or.inr\n\n"}
{"name":"ContextFreeGrammar.Produces.append_left","module":"Mathlib.Computability.ContextFreeGrammar","initialProofState":"T : Type uT\ng : ContextFreeGrammar T\nv w : List (Symbol T g.NT)\nhvw : g.Produces v w\np : List (Symbol T g.NT)\n⊢ g.Produces (HAppend.hAppend p v) (HAppend.hAppend p w)","decl":"/-- Add extra prefix to context-free producing. -/\nlemma Produces.append_left {v w : List (Symbol T g.NT)}\n    (hvw : g.Produces v w) (p : List (Symbol T g.NT)) :\n    g.Produces (p ++ v) (p ++ w) :=\n  match hvw with | ⟨r, hrmem, hrvw⟩ => ⟨r, hrmem, hrvw.append_left p⟩\n\n"}
{"name":"ContextFreeGrammar.Produces.append_right","module":"Mathlib.Computability.ContextFreeGrammar","initialProofState":"T : Type uT\ng : ContextFreeGrammar T\nv w : List (Symbol T g.NT)\nhvw : g.Produces v w\np : List (Symbol T g.NT)\n⊢ g.Produces (HAppend.hAppend v p) (HAppend.hAppend w p)","decl":"/-- Add extra postfix to context-free producing. -/\nlemma Produces.append_right {v w : List (Symbol T g.NT)}\n    (hvw : g.Produces v w) (p : List (Symbol T g.NT)) :\n    g.Produces (v ++ p) (w ++ p) :=\n  match hvw with | ⟨r, hrmem, hrvw⟩ => ⟨r, hrmem, hrvw.append_right p⟩\n\n"}
{"name":"ContextFreeGrammar.Derives.append_left","module":"Mathlib.Computability.ContextFreeGrammar","initialProofState":"T : Type uT\ng : ContextFreeGrammar T\nv w : List (Symbol T g.NT)\nhvw : g.Derives v w\np : List (Symbol T g.NT)\n⊢ g.Derives (HAppend.hAppend p v) (HAppend.hAppend p w)","decl":"/-- Add extra prefix to context-free deriving. -/\nlemma Derives.append_left {v w : List (Symbol T g.NT)}\n    (hvw : g.Derives v w) (p : List (Symbol T g.NT)) :\n    g.Derives (p ++ v) (p ++ w) := by\n  induction hvw with\n  | refl => rfl\n  | tail _ last ih => exact ih.trans_produces <| last.append_left p\n\n"}
{"name":"ContextFreeGrammar.Derives.append_right","module":"Mathlib.Computability.ContextFreeGrammar","initialProofState":"T : Type uT\ng : ContextFreeGrammar T\nv w : List (Symbol T g.NT)\nhvw : g.Derives v w\np : List (Symbol T g.NT)\n⊢ g.Derives (HAppend.hAppend v p) (HAppend.hAppend w p)","decl":"/-- Add extra postfix to context-free deriving. -/\nlemma Derives.append_right {v w : List (Symbol T g.NT)}\n    (hvw : g.Derives v w) (p : List (Symbol T g.NT)) :\n    g.Derives (v ++ p) (w ++ p) := by\n  induction hvw with\n  | refl => rfl\n  | tail _ last ih => exact ih.trans_produces <| last.append_right p\n\n"}
{"name":"ContextFreeRule.reverse_reverse","module":"Mathlib.Computability.ContextFreeGrammar","initialProofState":"T : Type uT\nN : Type uN\nr : ContextFreeRule T N\n⊢ Eq r.reverse.reverse r","decl":"@[simp] lemma reverse_reverse (r : ContextFreeRule T N) : r.reverse.reverse = r := by simp [reverse]\n\n"}
{"name":"ContextFreeRule.reverse_comp_reverse","module":"Mathlib.Computability.ContextFreeGrammar","initialProofState":"T : Type uT\nN : Type uN\n⊢ Eq (Function.comp ContextFreeRule.reverse ContextFreeRule.reverse) id","decl":"@[simp] lemma reverse_comp_reverse :\n    reverse ∘ reverse = (id : ContextFreeRule T N → ContextFreeRule T N) := by ext : 1; simp\n\n"}
{"name":"ContextFreeRule.reverse_involutive","module":"Mathlib.Computability.ContextFreeGrammar","initialProofState":"T : Type uT\nN : Type uN\n⊢ Function.Involutive ContextFreeRule.reverse","decl":"lemma reverse_involutive : Involutive (reverse : ContextFreeRule T N → ContextFreeRule T N) :=\n  reverse_reverse\n\n"}
{"name":"ContextFreeRule.reverse_bijective","module":"Mathlib.Computability.ContextFreeGrammar","initialProofState":"T : Type uT\nN : Type uN\n⊢ Function.Bijective ContextFreeRule.reverse","decl":"lemma reverse_bijective : Bijective (reverse : ContextFreeRule T N → ContextFreeRule T N) :=\n  reverse_involutive.bijective\n\n"}
{"name":"ContextFreeRule.reverse_injective","module":"Mathlib.Computability.ContextFreeGrammar","initialProofState":"T : Type uT\nN : Type uN\n⊢ Function.Injective ContextFreeRule.reverse","decl":"lemma reverse_injective : Injective (reverse : ContextFreeRule T N → ContextFreeRule T N) :=\n  reverse_bijective.injective\n\n"}
{"name":"ContextFreeRule.reverse_surjective","module":"Mathlib.Computability.ContextFreeGrammar","initialProofState":"T : Type uT\nN : Type uN\n⊢ Function.Surjective ContextFreeRule.reverse","decl":"lemma reverse_surjective : Surjective (reverse : ContextFreeRule T N → ContextFreeRule T N) :=\n  reverse_bijective.surjective\n\n"}
{"name":"ContextFreeRule.Rewrites.reverse","module":"Mathlib.Computability.ContextFreeGrammar","initialProofState":"T : Type uT\nN : Type uN\nr : ContextFreeRule T N\nu v : List (Symbol T N)\na✝ : r.Rewrites u v\n⊢ r.reverse.Rewrites u.reverse v.reverse","decl":"protected lemma Rewrites.reverse : ∀ {u v}, r.Rewrites u v → r.reverse.Rewrites u.reverse v.reverse\n  | _, _, head s => by simpa using .append_left .input_output _\n  | _, _, @cons _ _ _ x u v h => by simpa using h.reverse.append_right _\n\n"}
{"name":"ContextFreeRule.rewrites_reverse","module":"Mathlib.Computability.ContextFreeGrammar","initialProofState":"T : Type uT\nN : Type uN\nr : ContextFreeRule T N\nu v : List (Symbol T N)\n⊢ Iff (r.reverse.Rewrites u.reverse v.reverse) (r.Rewrites u v)","decl":"lemma rewrites_reverse : r.reverse.Rewrites u.reverse v.reverse ↔ r.Rewrites u v :=\n  ⟨fun h ↦ by simpa using h.reverse, .reverse⟩\n\n"}
{"name":"ContextFreeRule.rewrites_reverse_comm","module":"Mathlib.Computability.ContextFreeGrammar","initialProofState":"T : Type uT\nN : Type uN\nr : ContextFreeRule T N\nu v : List (Symbol T N)\n⊢ Iff (r.reverse.Rewrites u v) (r.Rewrites u.reverse v.reverse)","decl":"@[simp] lemma rewrites_reverse_comm : r.reverse.Rewrites u v ↔ r.Rewrites u.reverse v.reverse := by\n  rw [← rewrites_reverse, reverse_reverse]\n\n"}
{"name":"ContextFreeGrammar.reverse_rules","module":"Mathlib.Computability.ContextFreeGrammar","initialProofState":"T : Type uT\ng : ContextFreeGrammar T\n⊢ Eq g.reverse.rules (Finset.map { toFun := ContextFreeRule.reverse, inj' := ⋯ } g.rules)","decl":"/-- Grammar for a reversed language. -/\n@[simps] def reverse (g : ContextFreeGrammar T) : ContextFreeGrammar T :=\n  ⟨g.NT, g.initial, g.rules.map (⟨ContextFreeRule.reverse, ContextFreeRule.reverse_injective⟩)⟩\n\n"}
{"name":"ContextFreeGrammar.reverse_initial","module":"Mathlib.Computability.ContextFreeGrammar","initialProofState":"T : Type uT\ng : ContextFreeGrammar T\n⊢ Eq g.reverse.initial g.initial","decl":"/-- Grammar for a reversed language. -/\n@[simps] def reverse (g : ContextFreeGrammar T) : ContextFreeGrammar T :=\n  ⟨g.NT, g.initial, g.rules.map (⟨ContextFreeRule.reverse, ContextFreeRule.reverse_injective⟩)⟩\n\n"}
{"name":"ContextFreeGrammar.reverse_NT","module":"Mathlib.Computability.ContextFreeGrammar","initialProofState":"T : Type uT\ng : ContextFreeGrammar T\n⊢ Eq g.reverse.NT g.NT","decl":"/-- Grammar for a reversed language. -/\n@[simps] def reverse (g : ContextFreeGrammar T) : ContextFreeGrammar T :=\n  ⟨g.NT, g.initial, g.rules.map (⟨ContextFreeRule.reverse, ContextFreeRule.reverse_injective⟩)⟩\n\n"}
{"name":"ContextFreeGrammar.reverse_reverse","module":"Mathlib.Computability.ContextFreeGrammar","initialProofState":"T : Type uT\ng : ContextFreeGrammar T\n⊢ Eq g.reverse.reverse g","decl":"@[simp] lemma reverse_reverse (g : ContextFreeGrammar T) : g.reverse.reverse = g := by\n  simp [reverse, Finset.map_map]\n\n"}
{"name":"ContextFreeGrammar.reverse_involutive","module":"Mathlib.Computability.ContextFreeGrammar","initialProofState":"T : Type uT\n⊢ Function.Involutive ContextFreeGrammar.reverse","decl":"lemma reverse_involutive : Involutive (reverse : ContextFreeGrammar T → ContextFreeGrammar T) :=\n  reverse_reverse\n\n"}
{"name":"ContextFreeGrammar.reverse_bijective","module":"Mathlib.Computability.ContextFreeGrammar","initialProofState":"T : Type uT\n⊢ Function.Bijective ContextFreeGrammar.reverse","decl":"lemma reverse_bijective : Bijective (reverse : ContextFreeGrammar T → ContextFreeGrammar T) :=\n  reverse_involutive.bijective\n\n"}
{"name":"ContextFreeGrammar.reverse_injective","module":"Mathlib.Computability.ContextFreeGrammar","initialProofState":"T : Type uT\n⊢ Function.Injective ContextFreeGrammar.reverse","decl":"lemma reverse_injective : Injective (reverse : ContextFreeGrammar T → ContextFreeGrammar T) :=\n  reverse_bijective.injective\n\n"}
{"name":"ContextFreeGrammar.reverse_surjective","module":"Mathlib.Computability.ContextFreeGrammar","initialProofState":"T : Type uT\n⊢ Function.Surjective ContextFreeGrammar.reverse","decl":"lemma reverse_surjective : Surjective (reverse : ContextFreeGrammar T → ContextFreeGrammar T) :=\n  reverse_bijective.surjective\n\n"}
{"name":"ContextFreeGrammar.produces_reverse","module":"Mathlib.Computability.ContextFreeGrammar","initialProofState":"T : Type uT\ng : ContextFreeGrammar T\nu v : List (Symbol T g.NT)\n⊢ Iff (g.reverse.Produces u.reverse v.reverse) (g.Produces u v)","decl":"lemma produces_reverse : g.reverse.Produces u.reverse v.reverse ↔ g.Produces u v :=\n  (Equiv.ofBijective _ ContextFreeRule.reverse_bijective).exists_congr\n    (by simp [ContextFreeRule.reverse_involutive.eq_iff])\n\n"}
{"name":"ContextFreeGrammar.Produces.reverse","module":"Mathlib.Computability.ContextFreeGrammar","initialProofState":"T : Type uT\ng : ContextFreeGrammar T\nu v : List (Symbol T g.NT)\na✝ : g.Produces u v\n⊢ g.reverse.Produces u.reverse v.reverse","decl":"alias ⟨_, Produces.reverse⟩ := produces_reverse\n\n"}
{"name":"ContextFreeGrammar.produces_reverse_comm","module":"Mathlib.Computability.ContextFreeGrammar","initialProofState":"T : Type uT\ng : ContextFreeGrammar T\nu v : List (Symbol T g.NT)\n⊢ Iff (g.reverse.Produces u v) (g.Produces u.reverse v.reverse)","decl":"@[simp] lemma produces_reverse_comm : g.reverse.Produces u v ↔ g.Produces u.reverse v.reverse :=\n  (Equiv.ofBijective _ ContextFreeRule.reverse_bijective).exists_congr\n    (by simp [ContextFreeRule.reverse_involutive.eq_iff])\n\n"}
{"name":"ContextFreeGrammar.Derives.reverse","module":"Mathlib.Computability.ContextFreeGrammar","initialProofState":"T : Type uT\ng : ContextFreeGrammar T\nu v : List (Symbol T g.NT)\nhg : g.Derives u v\n⊢ g.reverse.Derives u.reverse v.reverse","decl":"protected lemma Derives.reverse (hg : g.Derives u v) : g.reverse.Derives u.reverse v.reverse := by\n  induction hg with\n  | refl => rfl\n  | tail _ orig ih => exact ih.trans_produces orig.reverse\n\n"}
{"name":"ContextFreeGrammar.derives_reverse","module":"Mathlib.Computability.ContextFreeGrammar","initialProofState":"T : Type uT\ng : ContextFreeGrammar T\nu v : List (Symbol T g.NT)\n⊢ Iff (g.reverse.Derives u.reverse v.reverse) (g.Derives u v)","decl":"lemma derives_reverse : g.reverse.Derives u.reverse v.reverse ↔ g.Derives u v :=\n  ⟨fun h ↦ by convert h.reverse <;> simp, .reverse⟩\n\n"}
{"name":"ContextFreeGrammar.derives_reverse_comm","module":"Mathlib.Computability.ContextFreeGrammar","initialProofState":"T : Type uT\ng : ContextFreeGrammar T\nu v : List (Symbol T g.NT)\n⊢ Iff (g.reverse.Derives u v) (g.Derives u.reverse v.reverse)","decl":"@[simp] lemma derives_reverse_comm : g.reverse.Derives u v ↔ g.Derives u.reverse v.reverse := by\n  rw [iff_comm, ← derives_reverse, List.reverse_reverse, List.reverse_reverse]\n\n"}
{"name":"ContextFreeGrammar.generates_reverse","module":"Mathlib.Computability.ContextFreeGrammar","initialProofState":"T : Type uT\ng : ContextFreeGrammar T\nu : List (Symbol T g.NT)\n⊢ Iff (g.reverse.Generates u.reverse) (g.Generates u)","decl":"lemma generates_reverse : g.reverse.Generates u.reverse ↔ g.Generates u := by simp [Generates]\n\n"}
{"name":"ContextFreeGrammar.Generates.reverse","module":"Mathlib.Computability.ContextFreeGrammar","initialProofState":"T : Type uT\ng : ContextFreeGrammar T\nu : List (Symbol T g.NT)\na✝ : g.Generates u\n⊢ g.reverse.Generates u.reverse","decl":"alias ⟨_, Generates.reverse⟩ := generates_reverse\n\n"}
{"name":"ContextFreeGrammar.generates_reverse_comm","module":"Mathlib.Computability.ContextFreeGrammar","initialProofState":"T : Type uT\ng : ContextFreeGrammar T\nu : List (Symbol T g.NT)\n⊢ Iff (g.reverse.Generates u) (g.Generates u.reverse)","decl":"@[simp] lemma generates_reverse_comm : g.reverse.Generates u ↔ g.Generates u.reverse := by\n  simp [Generates]\n\n"}
{"name":"ContextFreeGrammar.language_reverse","module":"Mathlib.Computability.ContextFreeGrammar","initialProofState":"T : Type uT\ng : ContextFreeGrammar T\n⊢ Eq g.reverse.language g.language.reverse","decl":"@[simp] lemma language_reverse : g.reverse.language = g.language.reverse := by ext; simp\n\n"}
{"name":"Language.IsContextFree.reverse","module":"Mathlib.Computability.ContextFreeGrammar","initialProofState":"T : Type uT\nL : Language T\na✝ : L.IsContextFree\n⊢ L.reverse.IsContextFree","decl":"/-- The class of context-free languages is closed under reversal. -/\ntheorem Language.IsContextFree.reverse (L : Language T) :\n    L.IsContextFree → L.reverse.IsContextFree := by rintro ⟨g, rfl⟩; exact ⟨g.reverse, by simp⟩\n\n"}
