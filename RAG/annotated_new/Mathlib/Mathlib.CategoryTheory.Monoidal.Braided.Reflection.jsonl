{"name":"CategoryTheory.Monoidal.Reflective.isIso_tfae","module":"Mathlib.CategoryTheory.Monoidal.Braided.Reflection","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù‚Å∂ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù‚Åµ : CategoryTheory.Category.{u_3, u_2} D\ninst‚úù‚Å¥ : CategoryTheory.MonoidalCategory D\ninst‚úù¬≥ : CategoryTheory.SymmetricCategory D\ninst‚úù¬≤ : CategoryTheory.MonoidalClosed D\nR : CategoryTheory.Functor C D\ninst‚úù¬π : R.Faithful\ninst‚úù : R.Full\nL : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction L R\n‚ä¢ (List.cons (‚àÄ (c : C) (d : D), CategoryTheory.IsIso (adj.unit.app ((CategoryTheory.ihom d).obj (R.obj c)))) (List.cons (‚àÄ (c : C) (d : D), CategoryTheory.IsIso ((CategoryTheory.MonoidalClosed.pre (adj.unit.app d)).app (R.obj c))) (List.cons (‚àÄ (d d' : D), CategoryTheory.IsIso (L.map (CategoryTheory.MonoidalCategoryStruct.whiskerRight (adj.unit.app d) d'))) (List.cons (‚àÄ (d d' : D), CategoryTheory.IsIso (L.map (CategoryTheory.MonoidalCategoryStruct.tensorHom (adj.unit.app d) (adj.unit.app d')))) List.nil)))).TFAE","decl":"/--\nDay's reflection theorem.\n\nLet `D` be a symmetric monoidal closed category and let `C` be a reflective subcategory. Denote by\n`R : C ‚•§ D` the inclusion functor and by `L : D ‚•§ C` the reflector. Let `u` denote the unit of the\nadjunction `L ‚ä£ R`. Denote the internal hom by `[-,-]`. The following are equivalent:\n\n1. `u : [d, Rc] ‚ü∂ RL[d, Rc]` is an isomorphism,\n2. `[u, ùüô] : [RLd, Rc] ‚ü∂ [d, Rc]` is an isomorphism,\n3. `L(u ‚ñ∑ d') : L(d ‚äó d') ‚ü∂ L(RLd ‚äó d')` is an isomorphism,\n4. `L(u ‚äó u) : L(d ‚äó d') ‚ü∂ L(RLd ‚äó RLd')` is an isomorphism,\n\nwhere `c, d, d'` are arbitrary objects of `C`/`D`, quantified over separately in each condition.\n-/\ntheorem isIso_tfae : List.TFAE\n    [ ‚àÄ (c : C) (d : D), IsIso (adj.unit.app ((ihom d).obj (R.obj c)))\n    , ‚àÄ (c : C) (d : D), IsIso ((pre (adj.unit.app d)).app (R.obj c))\n    , ‚àÄ (d d' : D), IsIso (L.map ((adj.unit.app d) ‚ñ∑ d'))\n    , ‚àÄ (d d' : D), IsIso (L.map ((adj.unit.app d) ‚äó (adj.unit.app d')))] := by\n  tfae_have 3 ‚Üí 4\n  | h => by\n    -- We can commute the tensor product in the condition that `L.map ((adj.unit.app d) ‚ñ∑ d')` is\n    -- an isomorphism:\n    have h' : ‚àÄ d d', IsIso (L.map (d ‚óÅ (adj.unit.app d'))) := by\n      intro d d'\n      have := braiding_naturality (ùüô d) (adj.unit.app d')\n      rw [‚Üê Iso.eq_comp_inv, id_tensorHom] at this\n      rw [this]\n      simp only [map_comp, id_obj, comp_obj, tensorHom_id, Category.assoc]\n      infer_instance\n    intro d d'\n    -- We then write the tensor product of the two units as the composition of the whiskered units,\n    -- and conclude.\n    have : (adj.unit.app d) ‚äó (adj.unit.app d') =\n        (adj.unit.app d ‚ñ∑ d') ‚â´ (((L ‚ãô R).obj _) ‚óÅ adj.unit.app d') := by\n      simp [‚Üê tensorHom_id, ‚Üê id_tensorHom, ‚Üê tensor_comp]\n    rw [this, map_comp]\n    infer_instance\n  tfae_have 4 ‚Üí 1\n  | _, _, _ => by\n    -- It is enough to show that the unit is a split monomorphism, and the retraction is given\n    -- by `adjRetraction` above.\n    let _ : Reflective R := { L := L, adj := adj }\n    have : IsIso adj.toMonad.Œº := Œº_iso_of_reflective (R := R)\n    erw [‚Üê adj.toMonad.isSplitMono_iff_isIso_unit]\n    exact ‚ü®‚ü®adjRetraction adj _ _, adjRetraction_is_retraction adj _ _‚ü©‚ü©\n  tfae_have 1 ‚Üí 3\n  | h, d, d' => by\n    rw [isIso_iff_isIso_coyoneda_map]\n    intro c\n    -- `w‚ÇÅ, w‚ÇÉ, w‚ÇÑ` are the three stacked commutative squares in the proof on nLab:\n    have w‚ÇÅ : (coyoneda.map (L.map (adj.unit.app d ‚ñ∑ d')).op).app c = (adj.homEquiv _ _).symm ‚àò\n        (coyoneda.map (adj.unit.app d ‚ñ∑ d').op).app (R.obj c) ‚àò adj.homEquiv _ _ := by ext; simp\n    rw [w‚ÇÅ, isIso_iff_bijective]\n    simp only [comp_obj, coyoneda_obj_obj, id_obj, EquivLike.comp_bijective,\n      EquivLike.bijective_comp]\n    -- We commute the tensor product using the auxiliary commutative square `w‚ÇÇ`.\n    have w‚ÇÇ : ((coyoneda.map (adj.unit.app d ‚ñ∑ d').op).app (R.obj c)) =\n        ((yoneda.obj (R.obj c)).mapIso (Œ≤_ _ _)).hom ‚àò\n          ((coyoneda.map (d' ‚óÅ adj.unit.app d).op).app (R.obj c)) ‚àò\n            ((yoneda.obj (R.obj c)).mapIso (Œ≤_ _ _)).hom := by ext; simp\n    rw [w‚ÇÇ, ‚Üê types_comp, ‚Üê types_comp, ‚Üê isIso_iff_bijective]\n    refine IsIso.comp_isIso' (IsIso.comp_isIso' inferInstance ?_) inferInstance\n    have w‚ÇÉ : ((coyoneda.map (d' ‚óÅ adj.unit.app d).op).app (R.obj c)) =\n        ((ihom.adjunction d').homEquiv _ _).symm ‚àò\n          ((coyoneda.map (adj.unit.app _).op).app _) ‚àò (ihom.adjunction d').homEquiv _ _ := by\n      ext\n      simp only [id_obj, op_tensorObj, coyoneda_obj_obj, unop_tensorObj, comp_obj,\n        coyoneda_map_app, Quiver.Hom.unop_op, Function.comp_apply,\n        Adjunction.homEquiv_unit, Adjunction.homEquiv_counit]\n      simp\n    rw [w‚ÇÉ, isIso_iff_bijective]\n    simp only [comp_obj, op_tensorObj, coyoneda_obj_obj, unop_tensorObj, id_obj,\n      yoneda_obj_obj, tensorLeft_obj, EquivLike.comp_bijective, EquivLike.bijective_comp]\n    have w‚ÇÑ : (coyoneda.map (adj.unit.app d).op).app ((ihom d').obj (R.obj c)) ‚â´\n        (coyoneda.obj ‚ü®d‚ü©).map (adj.unit.app ((ihom d').obj (R.obj c))) =\n          (coyoneda.obj ‚ü®(L ‚ãô R).obj d‚ü©).map (adj.unit.app ((ihom d').obj (R.obj c))) ‚â´\n            (coyoneda.map (adj.unit.app d).op).app _ := by simp\n    rw [‚Üê isIso_iff_bijective]\n    suffices IsIso ((coyoneda.map (adj.unit.app d).op).app ((ihom d').obj (R.obj c)) ‚â´\n        (coyoneda.obj ‚ü®d‚ü©).map (adj.unit.app ((ihom d').obj (R.obj c)))) from\n      IsIso.of_isIso_comp_right _ ((coyoneda.obj ‚ü®d‚ü©).map (adj.unit.app ((ihom d').obj (R.obj c))))\n    rw [w‚ÇÑ]\n    refine IsIso.comp_isIso' inferInstance ?_\n    constructor\n    -- We give the inverse of the bottom map in the stack of commutative squares:\n    refine ‚ü®fun f ‚Ü¶ R.map ((adj.homEquiv _ _).symm f), ?_, by ext; simp‚ü©\n    ext f\n    simp only [comp_obj, coyoneda_obj_obj, id_obj, Adjunction.homEquiv_counit,\n      map_comp, types_comp_apply, coyoneda_map_app, Quiver.Hom.unop_op, Category.assoc,\n      types_id_apply]\n    have : f = R.map (R.preimage f) := by simp\n    rw [this]\n    simp [‚Üê map_comp, ‚Üê map_comp_assoc, -map_preimage]\n  tfae_have 2 ‚Üî 3 := by\n    conv => lhs; intro c d; rw [isIso_iff_isIso_yoneda_map]\n    conv => rhs; intro d d'; rw [isIso_iff_isIso_coyoneda_map]\n    -- bring the quantifiers out of the `‚Üî`:\n    rw [forall_swap]; apply forall_congr'; intro d\n    rw [forall_swap]; apply forall‚ÇÇ_congr; intro d' c\n    -- `w‚ÇÅ, w‚ÇÇ,` are the two stacked commutative squares in the proof on nLab:\n    have w‚ÇÅ : ((coyoneda.map (L.map (adj.unit.app d ‚ñ∑ d')).op).app c) =\n        (adj.homEquiv _ _).symm ‚àò\n          (coyoneda.map (adj.unit.app d ‚ñ∑ d').op).app (R.obj c) ‚àò\n            (adj.homEquiv _ _) := by ext; simp\n    have w‚ÇÇ : ((yoneda.map ((pre (adj.unit.app d)).app (R.obj c))).app ‚ü®d'‚ü©) =\n          ((ihom.adjunction d).homEquiv _ _) ‚àò\n            ((coyoneda.map (adj.unit.app d ‚ñ∑ d').op).app (R.obj c)) ‚àò\n              ((ihom.adjunction ((L ‚ãô R).obj d)).homEquiv _ _).symm := by\n      rw [‚Üê Function.comp_assoc, ((ihom.adjunction ((L ‚ãô R).obj d)).homEquiv _ _).eq_comp_symm]\n      ext\n      simp only [id_obj, yoneda_obj_obj, comp_obj, Function.comp_apply,\n        yoneda_map_app, op_tensorObj, coyoneda_obj_obj, unop_tensorObj, op_whiskerRight,\n        coyoneda_map_app, unop_whiskerRight, Quiver.Hom.unop_op]\n      rw [Adjunction.homEquiv_unit, Adjunction.homEquiv_unit]\n      simp\n    rw [w‚ÇÇ, w‚ÇÅ, isIso_iff_bijective, isIso_iff_bijective]\n    simp\n  tfae_finish\n\n"}
{"name":"CategoryTheory.Monoidal.Reflective.instIsIsoMapTensorHomAppUnit","module":"Mathlib.CategoryTheory.Monoidal.Braided.Reflection","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù¬≤ : CategoryTheory.Category.{u_3, u_1} C\ninst‚úù¬π : CategoryTheory.Category.{u_4, u_2} D\ninst‚úù : CategoryTheory.MonoidalCategory D\nL : CategoryTheory.Functor D C\nR : CategoryTheory.Functor C D\nadj : CategoryTheory.Adjunction L R\nd d' : D\n‚ä¢ CategoryTheory.IsIso (L.map (CategoryTheory.MonoidalCategoryStruct.tensorHom (adj.unit.app d) (adj.unit.app d')))","decl":"instance (d d' : D) : IsIso (L.map ((adj.unit.app d) ‚äó (adj.unit.app d'))) := by\n  have := Œ¥ _ _ _ ‚â´= Œº_natural L (adj.unit.app d) (adj.unit.app d')\n  rw [Œ¥_Œº_assoc] at this\n  rw [‚Üê this]\n  infer_instance\n\n"}
{"name":"CategoryTheory.Monoidal.Reflective.instIsIsoAppUnitObjIhom","module":"Mathlib.CategoryTheory.Monoidal.Braided.Reflection","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù¬≥ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù¬≤ : CategoryTheory.Category.{u_3, u_2} D\ninst‚úù¬π : CategoryTheory.MonoidalCategory D\ninst‚úù : CategoryTheory.MonoidalClosed D\nL : CategoryTheory.Functor D C\nR : CategoryTheory.Functor C D\nadj : CategoryTheory.Adjunction L R\nc : C\nd : D\n‚ä¢ CategoryTheory.IsIso (adj.unit.app ((CategoryTheory.ihom d).obj (R.obj c)))","decl":"instance (c : C) (d : D) : IsIso (adj.unit.app ((ihom d).obj (R.obj c))) := by\n  revert c d\n  rw [((isIso_tfae adj).out 0 3:)]\n  intro d d'\n  infer_instance\n\n"}
