{"name":"Set.mem_Ioo","module":"Mathlib.Order.Interval.Set.Defs","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b x : α\n⊢ Iff (Membership.mem (Set.Ioo a b) x) (And (LT.lt a x) (LT.lt x b))","decl":"@[simp] theorem mem_Ioo : x ∈ Ioo a b ↔ a < x ∧ x < b := Iff.rfl\n"}
{"name":"Set.Ioo_def","module":"Mathlib.Order.Interval.Set.Defs","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : α\n⊢ Eq (setOf fun x => And (LT.lt a x) (LT.lt x b)) (Set.Ioo a b)","decl":"theorem Ioo_def (a b : α) : { x | a < x ∧ x < b } = Ioo a b := rfl\n\n"}
{"name":"Set.mem_Ico","module":"Mathlib.Order.Interval.Set.Defs","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b x : α\n⊢ Iff (Membership.mem (Set.Ico a b) x) (And (LE.le a x) (LT.lt x b))","decl":"@[simp] theorem mem_Ico : x ∈ Ico a b ↔ a ≤ x ∧ x < b := Iff.rfl\n"}
{"name":"Set.Ico_def","module":"Mathlib.Order.Interval.Set.Defs","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : α\n⊢ Eq (setOf fun x => And (LE.le a x) (LT.lt x b)) (Set.Ico a b)","decl":"theorem Ico_def (a b : α) : { x | a ≤ x ∧ x < b } = Ico a b := rfl\n\n"}
{"name":"Set.mem_Iio","module":"Mathlib.Order.Interval.Set.Defs","initialProofState":"α : Type u_1\ninst✝ : Preorder α\nb x : α\n⊢ Iff (Membership.mem (Set.Iio b) x) (LT.lt x b)","decl":"@[simp] theorem mem_Iio : x ∈ Iio b ↔ x < b := Iff.rfl\n"}
{"name":"Set.Iio_def","module":"Mathlib.Order.Interval.Set.Defs","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na : α\n⊢ Eq (setOf fun x => LT.lt x a) (Set.Iio a)","decl":"theorem Iio_def (a : α) : { x | x < a } = Iio a := rfl\n\n"}
{"name":"Set.mem_Icc","module":"Mathlib.Order.Interval.Set.Defs","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b x : α\n⊢ Iff (Membership.mem (Set.Icc a b) x) (And (LE.le a x) (LE.le x b))","decl":"@[simp] theorem mem_Icc : x ∈ Icc a b ↔ a ≤ x ∧ x ≤ b := Iff.rfl\n"}
{"name":"Set.Icc_def","module":"Mathlib.Order.Interval.Set.Defs","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : α\n⊢ Eq (setOf fun x => And (LE.le a x) (LE.le x b)) (Set.Icc a b)","decl":"theorem Icc_def (a b : α) : { x | a ≤ x ∧ x ≤ b } = Icc a b := rfl\n\n"}
{"name":"Set.mem_Iic","module":"Mathlib.Order.Interval.Set.Defs","initialProofState":"α : Type u_1\ninst✝ : Preorder α\nb x : α\n⊢ Iff (Membership.mem (Set.Iic b) x) (LE.le x b)","decl":"@[simp] theorem mem_Iic : x ∈ Iic b ↔ x ≤ b := Iff.rfl\n"}
{"name":"Set.Iic_def","module":"Mathlib.Order.Interval.Set.Defs","initialProofState":"α : Type u_1\ninst✝ : Preorder α\nb : α\n⊢ Eq (setOf fun x => LE.le x b) (Set.Iic b)","decl":"theorem Iic_def (b : α) : { x | x ≤ b } = Iic b := rfl\n\n"}
{"name":"Set.mem_Ioc","module":"Mathlib.Order.Interval.Set.Defs","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b x : α\n⊢ Iff (Membership.mem (Set.Ioc a b) x) (And (LT.lt a x) (LE.le x b))","decl":"@[simp] theorem mem_Ioc : x ∈ Ioc a b ↔ a < x ∧ x ≤ b := Iff.rfl\n"}
{"name":"Set.Ioc_def","module":"Mathlib.Order.Interval.Set.Defs","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : α\n⊢ Eq (setOf fun x => And (LT.lt a x) (LE.le x b)) (Set.Ioc a b)","decl":"theorem Ioc_def (a b : α) : { x | a < x ∧ x ≤ b } = Ioc a b := rfl\n\n"}
{"name":"Set.mem_Ici","module":"Mathlib.Order.Interval.Set.Defs","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na x : α\n⊢ Iff (Membership.mem (Set.Ici a) x) (LE.le a x)","decl":"@[simp] theorem mem_Ici : x ∈ Ici a ↔ a ≤ x := Iff.rfl\n"}
{"name":"Set.Ici_def","module":"Mathlib.Order.Interval.Set.Defs","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na : α\n⊢ Eq (setOf fun x => LE.le a x) (Set.Ici a)","decl":"theorem Ici_def (a : α) : { x | a ≤ x } = Ici a := rfl\n\n"}
{"name":"Set.mem_Ioi","module":"Mathlib.Order.Interval.Set.Defs","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na x : α\n⊢ Iff (Membership.mem (Set.Ioi a) x) (LT.lt a x)","decl":"@[simp] theorem mem_Ioi : x ∈ Ioi a ↔ a < x := Iff.rfl\n"}
{"name":"Set.Ioi_def","module":"Mathlib.Order.Interval.Set.Defs","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na : α\n⊢ Eq (setOf fun x => LT.lt a x) (Set.Ioi a)","decl":"theorem Ioi_def (a : α) : { x | a < x } = Ioi a := rfl\n\n"}
{"name":"Set.OrdConnected.out'","module":"Mathlib.Order.Interval.Set.Defs","initialProofState":"α : Type u_1\ninst✝ : Preorder α\ns : Set α\nself : s.OrdConnected\nx : α\nhx : Membership.mem s x\ny : α\nhy : Membership.mem s y\n⊢ HasSubset.Subset (Set.Icc x y) s","decl":"/-- We say that a set `s : Set α` is `OrdConnected` if for all `x y ∈ s` it includes the\ninterval `[[x, y]]`. If `α` is a `DenselyOrdered` `ConditionallyCompleteLinearOrder` with\nthe `OrderTopology`, then this condition is equivalent to `IsPreconnected s`. If `α` is a\n`LinearOrderedField`, then this condition is also equivalent to `Convex α s`. -/\nclass OrdConnected (s : Set α) : Prop where\n  /-- `s : Set α` is `OrdConnected` if for all `x y ∈ s` it includes the interval `[[x, y]]`. -/\n  out' ⦃x⦄ (hx : x ∈ s) ⦃y⦄ (hy : y ∈ s) : Icc x y ⊆ s\n\n"}
