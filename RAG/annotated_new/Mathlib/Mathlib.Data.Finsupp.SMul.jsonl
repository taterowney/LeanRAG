{"name":"Finsupp.single_smul","module":"Mathlib.Data.Finsupp.SMul","initialProofState":"α : Type u_1\nM : Type u_3\nR : Type u_6\ninst✝² : Zero M\ninst✝¹ : MonoidWithZero R\ninst✝ : MulActionWithZero R M\na b : α\nf : α → M\nr : R\n⊢ Eq (HSMul.hSMul ((Finsupp.single a r) b) (f a)) ((Finsupp.single a (HSMul.hSMul r (f b))) b)","decl":"@[simp]\ntheorem single_smul (a b : α) (f : α → M) (r : R) : single a r b • f a = single a (r • f b) b := by\n  by_cases h : a = b <;> simp [h]\n\n"}
{"name":"Finsupp.comapSMul_def","module":"Mathlib.Data.Finsupp.SMul","initialProofState":"α : Type u_1\nM : Type u_3\nG : Type u_5\ninst✝² : Monoid G\ninst✝¹ : MulAction G α\ninst✝ : AddCommMonoid M\ng : G\nf : Finsupp α M\n⊢ Eq (HSMul.hSMul g f) (Finsupp.mapDomain (fun x => HSMul.hSMul g x) f)","decl":"theorem comapSMul_def (g : G) (f : α →₀ M) : g • f = mapDomain (g • ·) f :=\n  rfl\n\n"}
{"name":"Finsupp.comapSMul_single","module":"Mathlib.Data.Finsupp.SMul","initialProofState":"α : Type u_1\nM : Type u_3\nG : Type u_5\ninst✝² : Monoid G\ninst✝¹ : MulAction G α\ninst✝ : AddCommMonoid M\ng : G\na : α\nb : M\n⊢ Eq (HSMul.hSMul g (Finsupp.single a b)) (Finsupp.single (HSMul.hSMul g a) b)","decl":"@[simp]\ntheorem comapSMul_single (g : G) (a : α) (b : M) : g • single a b = single (g • a) b :=\n  mapDomain_single\n\n"}
{"name":"Finsupp.comapSMul_apply","module":"Mathlib.Data.Finsupp.SMul","initialProofState":"α : Type u_1\nM : Type u_3\nG : Type u_5\ninst✝² : Group G\ninst✝¹ : MulAction G α\ninst✝ : AddCommMonoid M\ng : G\nf : Finsupp α M\na : α\n⊢ Eq ((HSMul.hSMul g f) a) (f (HSMul.hSMul (Inv.inv g) a))","decl":"/-- When `G` is a group, `Finsupp.comapSMul` acts by precomposition with the action of `g⁻¹`.\n-/\n@[simp]\ntheorem comapSMul_apply (g : G) (f : α →₀ M) (a : α) : (g • f) a = f (g⁻¹ • a) := by\n  conv_lhs => rw [← smul_inv_smul g a]\n  exact mapDomain_apply (MulAction.injective g) _ (g⁻¹ • a)\n\n"}
{"name":"IsSMulRegular.finsupp","module":"Mathlib.Data.Finsupp.SMul","initialProofState":"α : Type u_1\nM : Type u_3\nR : Type u_6\ninst✝¹ : Zero M\ninst✝ : SMulZeroClass R M\nk : R\nhk : IsSMulRegular M k\n⊢ IsSMulRegular (Finsupp α M) k","decl":"theorem _root_.IsSMulRegular.finsupp [Zero M] [SMulZeroClass R M] {k : R}\n    (hk : IsSMulRegular M k) : IsSMulRegular (α →₀ M) k :=\n  fun _ _ h => ext fun i => hk (DFunLike.congr_fun h i)\n\n"}
{"name":"Finsupp.faithfulSMul","module":"Mathlib.Data.Finsupp.SMul","initialProofState":"α : Type u_1\nM : Type u_3\nR : Type u_6\ninst✝³ : Nonempty α\ninst✝² : Zero M\ninst✝¹ : SMulZeroClass R M\ninst✝ : FaithfulSMul R M\n⊢ FaithfulSMul R (Finsupp α M)","decl":"instance faithfulSMul [Nonempty α] [Zero M] [SMulZeroClass R M] [FaithfulSMul R M] :\n    FaithfulSMul R (α →₀ M) where\n  eq_of_smul_eq_smul h :=\n    let ⟨a⟩ := ‹Nonempty α›\n    eq_of_smul_eq_smul fun m : M => by simpa using DFunLike.congr_fun (h (single a m)) a\n\n"}
{"name":"Finsupp.support_smul_eq","module":"Mathlib.Data.Finsupp.SMul","initialProofState":"α : Type u_1\nM : Type u_3\nR : Type u_6\ninst✝³ : Semiring R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\ninst✝ : NoZeroSMulDivisors R M\nb : R\nhb : Ne b 0\ng : Finsupp α M\n⊢ Eq (HSMul.hSMul b g).support g.support","decl":"@[simp]\ntheorem support_smul_eq [Semiring R] [AddCommMonoid M] [Module R M] [NoZeroSMulDivisors R M] {b : R}\n    (hb : b ≠ 0) {g : α →₀ M} : (b • g).support = g.support :=\n  Finset.ext fun a => by simp [Finsupp.smul_apply, hb]\n\n"}
{"name":"Finsupp.filter_smul","module":"Mathlib.Data.Finsupp.SMul","initialProofState":"α : Type u_1\nM : Type u_3\nR : Type u_6\np : α → Prop\ninst✝² : DecidablePred p\nx✝ : Monoid R\ninst✝¹ : AddMonoid M\ninst✝ : DistribMulAction R M\nb : R\nv : Finsupp α M\n⊢ Eq (Finsupp.filter p (HSMul.hSMul b v)) (HSMul.hSMul b (Finsupp.filter p v))","decl":"@[simp]\ntheorem filter_smul {_ : Monoid R} [AddMonoid M] [DistribMulAction R M] {b : R} {v : α →₀ M} :\n    (b • v).filter p = b • v.filter p :=\n  DFunLike.coe_injective <| by\n    simp only [filter_eq_indicator, coe_smul]\n    exact Set.indicator_const_smul { x | p x } b v\n\n"}
{"name":"Finsupp.mapDomain_smul","module":"Mathlib.Data.Finsupp.SMul","initialProofState":"α : Type u_1\nβ : Type u_2\nM : Type u_3\nR : Type u_6\nx✝ : Monoid R\ninst✝¹ : AddCommMonoid M\ninst✝ : DistribMulAction R M\nf : α → β\nb : R\nv : Finsupp α M\n⊢ Eq (Finsupp.mapDomain f (HSMul.hSMul b v)) (HSMul.hSMul b (Finsupp.mapDomain f v))","decl":"theorem mapDomain_smul {_ : Monoid R} [AddCommMonoid M] [DistribMulAction R M] {f : α → β} (b : R)\n    (v : α →₀ M) : mapDomain f (b • v) = b • mapDomain f v :=\n  mapDomain_mapRange _ _ _ _ (smul_add b)\n\n"}
{"name":"Finsupp.smul_single'","module":"Mathlib.Data.Finsupp.SMul","initialProofState":"α : Type u_1\nR : Type u_6\nx✝ : Semiring R\nc : R\na : α\nb : R\n⊢ Eq (HSMul.hSMul c (Finsupp.single a b)) (Finsupp.single a (HMul.hMul c b))","decl":"theorem smul_single' {_ : Semiring R} (c : R) (a : α) (b : R) :\n    c • Finsupp.single a b = Finsupp.single a (c * b) := by simp\n\n"}
{"name":"Finsupp.smul_single_one","module":"Mathlib.Data.Finsupp.SMul","initialProofState":"α : Type u_1\nR : Type u_6\ninst✝ : Semiring R\na : α\nb : R\n⊢ Eq (HSMul.hSMul b (Finsupp.single a 1)) (Finsupp.single a b)","decl":"theorem smul_single_one [Semiring R] (a : α) (b : R) : b • single a (1 : R) = single a b := by\n  rw [smul_single, smul_eq_mul, mul_one]\n\n"}
{"name":"Finsupp.comapDomain_smul","module":"Mathlib.Data.Finsupp.SMul","initialProofState":"α : Type u_1\nβ : Type u_2\nM : Type u_3\nR : Type u_6\ninst✝² : AddMonoid M\ninst✝¹ : Monoid R\ninst✝ : DistribMulAction R M\nf : α → β\nr : R\nv : Finsupp β M\nhfv : Set.InjOn f (Set.preimage f ↑v.support)\nhfrv : optParam (Set.InjOn f (Set.preimage f ↑(HSMul.hSMul r v).support)) ⋯\n⊢ Eq (Finsupp.comapDomain f (HSMul.hSMul r v) hfrv) (HSMul.hSMul r (Finsupp.comapDomain f v hfv))","decl":"theorem comapDomain_smul [AddMonoid M] [Monoid R] [DistribMulAction R M] {f : α → β} (r : R)\n    (v : β →₀ M) (hfv : Set.InjOn f (f ⁻¹' ↑v.support))\n    (hfrv : Set.InjOn f (f ⁻¹' ↑(r • v).support) :=\n      hfv.mono <| Set.preimage_mono <| Finset.coe_subset.mpr support_smul) :\n    comapDomain f (r • v) hfrv = r • comapDomain f v hfv := by\n  ext\n  rfl\n\n"}
{"name":"Finsupp.comapDomain_smul_of_injective","module":"Mathlib.Data.Finsupp.SMul","initialProofState":"α : Type u_1\nβ : Type u_2\nM : Type u_3\nR : Type u_6\ninst✝² : AddMonoid M\ninst✝¹ : Monoid R\ninst✝ : DistribMulAction R M\nf : α → β\nhf : Function.Injective f\nr : R\nv : Finsupp β M\n⊢ Eq (Finsupp.comapDomain f (HSMul.hSMul r v) ⋯) (HSMul.hSMul r (Finsupp.comapDomain f v ⋯))","decl":"/-- A version of `Finsupp.comapDomain_smul` that's easier to use. -/\ntheorem comapDomain_smul_of_injective [AddMonoid M] [Monoid R] [DistribMulAction R M] {f : α → β}\n    (hf : Function.Injective f) (r : R) (v : β →₀ M) :\n    comapDomain f (r • v) hf.injOn = r • comapDomain f v hf.injOn :=\n  comapDomain_smul _ _ _ _\n\n"}
{"name":"Finsupp.sum_smul_index","module":"Mathlib.Data.Finsupp.SMul","initialProofState":"α : Type u_1\nM : Type u_3\nR : Type u_6\ninst✝¹ : Semiring R\ninst✝ : AddCommMonoid M\ng : Finsupp α R\nb : R\nh : α → R → M\nh0 : ∀ (i : α), Eq (h i 0) 0\n⊢ Eq ((HSMul.hSMul b g).sum h) (g.sum fun i a => h i (HMul.hMul b a))","decl":"theorem sum_smul_index [Semiring R] [AddCommMonoid M] {g : α →₀ R} {b : R} {h : α → R → M}\n    (h0 : ∀ i, h i 0 = 0) : (b • g).sum h = g.sum fun i a => h i (b * a) :=\n  Finsupp.sum_mapRange_index h0\n\n"}
{"name":"Finsupp.sum_smul_index'","module":"Mathlib.Data.Finsupp.SMul","initialProofState":"α : Type u_1\nM : Type u_3\nN : Type u_4\nR : Type u_6\ninst✝² : AddMonoid M\ninst✝¹ : DistribSMul R M\ninst✝ : AddCommMonoid N\ng : Finsupp α M\nb : R\nh : α → M → N\nh0 : ∀ (i : α), Eq (h i 0) 0\n⊢ Eq ((HSMul.hSMul b g).sum h) (g.sum fun i c => h i (HSMul.hSMul b c))","decl":"theorem sum_smul_index' [AddMonoid M] [DistribSMul R M] [AddCommMonoid N] {g : α →₀ M} {b : R}\n    {h : α → M → N} (h0 : ∀ i, h i 0 = 0) : (b • g).sum h = g.sum fun i c => h i (b • c) :=\n  Finsupp.sum_mapRange_index h0\n\n"}
{"name":"Finsupp.sum_smul_index_addMonoidHom","module":"Mathlib.Data.Finsupp.SMul","initialProofState":"α : Type u_1\nM : Type u_3\nN : Type u_4\nR : Type u_6\ninst✝² : AddMonoid M\ninst✝¹ : AddCommMonoid N\ninst✝ : DistribSMul R M\ng : Finsupp α M\nb : R\nh : α → AddMonoidHom M N\n⊢ Eq ((HSMul.hSMul b g).sum fun a => ⇑(h a)) (g.sum fun i c => (h i) (HSMul.hSMul b c))","decl":"/-- A version of `Finsupp.sum_smul_index'` for bundled additive maps. -/\ntheorem sum_smul_index_addMonoidHom [AddMonoid M] [AddCommMonoid N] [DistribSMul R M] {g : α →₀ M}\n    {b : R} {h : α → M →+ N} : ((b • g).sum fun a => h a) = g.sum fun i c => h i (b • c) :=\n  sum_mapRange_index fun i => (h i).map_zero\n\n"}
{"name":"Finsupp.noZeroSMulDivisors","module":"Mathlib.Data.Finsupp.SMul","initialProofState":"M : Type u_3\nR : Type u_6\ninst✝³ : Zero R\ninst✝² : Zero M\ninst✝¹ : SMulZeroClass R M\nι : Type u_7\ninst✝ : NoZeroSMulDivisors R M\n⊢ NoZeroSMulDivisors R (Finsupp ι M)","decl":"instance noZeroSMulDivisors [Zero R] [Zero M] [SMulZeroClass R M] {ι : Type*}\n    [NoZeroSMulDivisors R M] : NoZeroSMulDivisors R (ι →₀ M) :=\n  ⟨fun h => or_iff_not_imp_left.mpr fun hc => Finsupp.ext fun i =>\n    (eq_zero_or_eq_zero_of_smul_eq_zero (DFunLike.ext_iff.mp h i)).resolve_left hc⟩\n\n"}
{"name":"Finsupp.distribMulActionHom_ext","module":"Mathlib.Data.Finsupp.SMul","initialProofState":"α : Type u_1\nM : Type u_3\nN : Type u_4\nR : Type u_6\ninst✝⁴ : Monoid R\ninst✝³ : AddMonoid M\ninst✝² : AddMonoid N\ninst✝¹ : DistribMulAction R M\ninst✝ : DistribMulAction R N\nf g : DistribMulActionHom (MonoidHom.id R) (Finsupp α M) N\nh : ∀ (a : α) (m : M), Eq (f (Finsupp.single a m)) (g (Finsupp.single a m))\n⊢ Eq f g","decl":"theorem distribMulActionHom_ext {f g : (α →₀ M) →+[R] N}\n    (h : ∀ (a : α) (m : M), f (single a m) = g (single a m)) : f = g :=\n  DistribMulActionHom.toAddMonoidHom_injective <| addHom_ext h\n\n"}
{"name":"Finsupp.distribMulActionHom_ext'","module":"Mathlib.Data.Finsupp.SMul","initialProofState":"α : Type u_1\nM : Type u_3\nN : Type u_4\nR : Type u_6\ninst✝⁴ : Monoid R\ninst✝³ : AddMonoid M\ninst✝² : AddMonoid N\ninst✝¹ : DistribMulAction R M\ninst✝ : DistribMulAction R N\nf g : DistribMulActionHom (MonoidHom.id R) (Finsupp α M) N\nh : ∀ (a : α), Eq (f.comp (Finsupp.DistribMulActionHom.single a)) (g.comp (Finsupp.DistribMulActionHom.single a))\n⊢ Eq f g","decl":"/-- See note [partially-applied ext lemmas]. -/\n@[ext]\ntheorem distribMulActionHom_ext' {f g : (α →₀ M) →+[R] N}\n    (h : ∀ a : α, f.comp (DistribMulActionHom.single a) = g.comp (DistribMulActionHom.single a)) :\n    f = g :=\n  distribMulActionHom_ext fun a => DistribMulActionHom.congr_fun (h a)\n\n"}
{"name":"Finsupp.distribMulActionHom_ext'_iff","module":"Mathlib.Data.Finsupp.SMul","initialProofState":"α : Type u_1\nM : Type u_3\nN : Type u_4\nR : Type u_6\ninst✝⁴ : Monoid R\ninst✝³ : AddMonoid M\ninst✝² : AddMonoid N\ninst✝¹ : DistribMulAction R M\ninst✝ : DistribMulAction R N\nf g : DistribMulActionHom (MonoidHom.id R) (Finsupp α M) N\n⊢ Iff (Eq f g) (∀ (a : α), Eq (f.comp (Finsupp.DistribMulActionHom.single a)) (g.comp (Finsupp.DistribMulActionHom.single a)))","decl":"/-- See note [partially-applied ext lemmas]. -/\n@[ext]\ntheorem distribMulActionHom_ext' {f g : (α →₀ M) →+[R] N}\n    (h : ∀ a : α, f.comp (DistribMulActionHom.single a) = g.comp (DistribMulActionHom.single a)) :\n    f = g :=\n  distribMulActionHom_ext fun a => DistribMulActionHom.congr_fun (h a)\n\n"}
