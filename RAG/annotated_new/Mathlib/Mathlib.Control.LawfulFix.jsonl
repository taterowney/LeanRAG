{"name":"LawfulFix.fix_eq","module":"Mathlib.Control.LawfulFix","initialProofState":"α : Type u_3\ninst✝ : OmegaCompletePartialOrder α\nself : LawfulFix α\nf : α → α\na✝ : OmegaCompletePartialOrder.ωScottContinuous f\n⊢ Eq (Fix.fix f) (f (Fix.fix f))","decl":"/-- Intuitively, a fixed point operator `fix` is lawful if it satisfies `fix f = f (fix f)` for all\n`f`, but this is inconsistent / uninteresting in most cases due to the existence of \"exotic\"\nfunctions `f`, such as the function that is defined iff its argument is not, familiar from the\nhalting problem. Instead, this requirement is limited to only functions that are `Continuous` in the\nsense of `ω`-complete partial orders, which excludes the example because it is not monotone\n(making the input argument less defined can make `f` more defined). -/\nclass LawfulFix (α : Type*) [OmegaCompletePartialOrder α] extends Fix α where\n  fix_eq : ∀ {f : α → α}, ωScottContinuous f → Fix.fix f = f (Fix.fix f)\n\n"}
{"name":"LawfulFix.fix_eq'","module":"Mathlib.Control.LawfulFix","initialProofState":"α : Type u_3\ninst✝¹ : OmegaCompletePartialOrder α\ninst✝ : LawfulFix α\nf : α → α\nhf : OmegaCompletePartialOrder.ωScottContinuous f\n⊢ Eq (Fix.fix f) (f (Fix.fix f))","decl":"@[deprecated LawfulFix.fix_eq (since := \"2024-08-26\")]\ntheorem LawfulFix.fix_eq' {α} [OmegaCompletePartialOrder α] [LawfulFix α] {f : α → α}\n    (hf : ωScottContinuous f) : Fix.fix f = f (Fix.fix f) :=\n  LawfulFix.fix_eq hf\n\n"}
{"name":"Part.Fix.approx_mono'","module":"Mathlib.Control.LawfulFix","initialProofState":"α : Type u_1\nβ : α → Type u_2\nf : OrderHom ((a : α) → Part (β a)) ((a : α) → Part (β a))\ni : Nat\n⊢ LE.le (Part.Fix.approx (⇑f) i) (Part.Fix.approx (⇑f) i.succ)","decl":"theorem approx_mono' {i : ℕ} : Fix.approx f i ≤ Fix.approx f (succ i) := by\n  induction i with\n  | zero => dsimp [approx]; apply @bot_le _ _ _ (f ⊥)\n  | succ _ i_ih => intro; apply f.monotone; apply i_ih\n\n"}
{"name":"Part.Fix.approx_mono","module":"Mathlib.Control.LawfulFix","initialProofState":"α : Type u_1\nβ : α → Type u_2\nf : OrderHom ((a : α) → Part (β a)) ((a : α) → Part (β a))\ni j : Nat\nhij : LE.le i j\n⊢ LE.le (Part.Fix.approx (⇑f) i) (Part.Fix.approx (⇑f) j)","decl":"theorem approx_mono ⦃i j : ℕ⦄ (hij : i ≤ j) : approx f i ≤ approx f j := by\n  induction' j with j ih\n  · cases hij\n    exact le_rfl\n  cases hij; · exact le_rfl\n  exact le_trans (ih ‹_›) (approx_mono' f)\n\n"}
{"name":"Part.Fix.mem_iff","module":"Mathlib.Control.LawfulFix","initialProofState":"α : Type u_1\nβ : α → Type u_2\nf : OrderHom ((a : α) → Part (β a)) ((a : α) → Part (β a))\na : α\nb : β a\n⊢ Iff (Membership.mem (Part.fix (⇑f) a) b) (Exists fun i => Membership.mem (Part.Fix.approx (⇑f) i a) b)","decl":"theorem mem_iff (a : α) (b : β a) : b ∈ Part.fix f a ↔ ∃ i, b ∈ approx f i a := by\n  classical\n  by_cases h₀ : ∃ i : ℕ, (approx f i a).Dom\n  · simp only [Part.fix_def f h₀]\n    constructor <;> intro hh\n    · exact ⟨_, hh⟩\n    have h₁ := Nat.find_spec h₀\n    rw [dom_iff_mem] at h₁\n    cases' h₁ with y h₁\n    replace h₁ := approx_mono' f _ _ h₁\n    suffices y = b by\n      subst this\n      exact h₁\n    cases' hh with i hh\n    revert h₁; generalize succ (Nat.find h₀) = j; intro h₁\n    wlog case : i ≤ j\n    · rcases le_total i j with H | H <;> [skip; symm] <;> apply_assumption <;> assumption\n    replace hh := approx_mono f case _ _ hh\n    apply Part.mem_unique h₁ hh\n  · simp only [fix_def' (⇑f) h₀, not_exists, false_iff, not_mem_none]\n    simp only [dom_iff_mem, not_exists] at h₀\n    intro; apply h₀\n\n"}
{"name":"Part.Fix.approx_le_fix","module":"Mathlib.Control.LawfulFix","initialProofState":"α : Type u_1\nβ : α → Type u_2\nf : OrderHom ((a : α) → Part (β a)) ((a : α) → Part (β a))\ni : Nat\n⊢ LE.le (Part.Fix.approx (⇑f) i) (Part.fix ⇑f)","decl":"theorem approx_le_fix (i : ℕ) : approx f i ≤ Part.fix f := fun a b hh ↦ by\n  rw [mem_iff f]\n  exact ⟨_, hh⟩\n\n"}
{"name":"Part.Fix.exists_fix_le_approx","module":"Mathlib.Control.LawfulFix","initialProofState":"α : Type u_1\nβ : α → Type u_2\nf : OrderHom ((a : α) → Part (β a)) ((a : α) → Part (β a))\nx : α\n⊢ Exists fun i => LE.le (Part.fix (⇑f) x) (Part.Fix.approx (⇑f) i x)","decl":"theorem exists_fix_le_approx (x : α) : ∃ i, Part.fix f x ≤ approx f i x := by\n  by_cases hh : ∃ i b, b ∈ approx f i x\n  · rcases hh with ⟨i, b, hb⟩\n    exists i\n    intro b' h'\n    have hb' := approx_le_fix f i _ _ hb\n    obtain rfl := Part.mem_unique h' hb'\n    exact hb\n  · simp only [not_exists] at hh\n    exists 0\n    intro b' h'\n    simp only [mem_iff f] at h'\n    cases' h' with i h'\n    cases hh _ _ h'\n\n"}
{"name":"Part.Fix.le_f_of_mem_approx","module":"Mathlib.Control.LawfulFix","initialProofState":"α : Type u_1\nβ : α → Type u_2\nf : OrderHom ((a : α) → Part (β a)) ((a : α) → Part (β a))\nx : (a : α) → Part (β a)\na✝ : Membership.mem (Part.Fix.approxChain f) x\n⊢ LE.le x (f x)","decl":"theorem le_f_of_mem_approx {x} : x ∈ approxChain f → x ≤ f x := by\n  simp only [Membership.mem, forall_exists_index]\n  rintro i rfl\n  apply approx_mono'\n\n"}
{"name":"Part.Fix.approx_mem_approxChain","module":"Mathlib.Control.LawfulFix","initialProofState":"α : Type u_1\nβ : α → Type u_2\nf : OrderHom ((a : α) → Part (β a)) ((a : α) → Part (β a))\ni : Nat\n⊢ Membership.mem (Part.Fix.approxChain f) (Part.Fix.approx (⇑f) i)","decl":"theorem approx_mem_approxChain {i} : approx f i ∈ approxChain f :=\n  Stream'.mem_of_get_eq rfl\n\n"}
{"name":"Part.fix_eq_ωSup","module":"Mathlib.Control.LawfulFix","initialProofState":"α : Type u_1\nβ : α → Type u_2\nf : OrderHom ((a : α) → Part (β a)) ((a : α) → Part (β a))\n⊢ Eq (Part.fix ⇑f) (OmegaCompletePartialOrder.ωSup (Part.Fix.approxChain f))","decl":"theorem fix_eq_ωSup : Part.fix f = ωSup (approxChain f) := by\n  apply le_antisymm\n  · intro x\n    cases' exists_fix_le_approx f x with i hx\n    trans approx f i.succ x\n    · trans\n      · apply hx\n      · apply approx_mono' f\n    apply le_ωSup_of_le i.succ\n    dsimp [approx]\n    rfl\n  · apply ωSup_le _ _ _\n    simp only [Fix.approxChain, OrderHom.coe_mk]\n    intro y x\n    apply approx_le_fix f\n\n"}
{"name":"Part.fix_le","module":"Mathlib.Control.LawfulFix","initialProofState":"α : Type u_1\nβ : α → Type u_2\nf : OrderHom ((a : α) → Part (β a)) ((a : α) → Part (β a))\nX : (a : α) → Part (β a)\nhX : LE.le (f X) X\n⊢ LE.le (Part.fix ⇑f) X","decl":"theorem fix_le {X : (a : _) → Part <| β a} (hX : f X ≤ X) : Part.fix f ≤ X := by\n  rw [fix_eq_ωSup f]\n  apply ωSup_le _ _ _\n  simp only [Fix.approxChain, OrderHom.coe_mk]\n  intro i\n  induction i with\n  | zero => dsimp [Fix.approx]; apply bot_le\n  | succ _ i_ih =>\n    trans f X\n    · apply f.monotone i_ih\n    · apply hX\n\n"}
{"name":"Part.fix_eq_ωSup_of_ωScottContinuous","module":"Mathlib.Control.LawfulFix","initialProofState":"α : Type u_1\nβ : α → Type u_2\ng : ((a : α) → Part (β a)) → (a : α) → Part (β a)\nhc : OmegaCompletePartialOrder.ωScottContinuous g\n⊢ Eq (Part.fix g) (OmegaCompletePartialOrder.ωSup (Part.Fix.approxChain { toFun := g, monotone' := ⋯ }))","decl":"theorem fix_eq_ωSup_of_ωScottContinuous (hc : ωScottContinuous g) : Part.fix g =\n    ωSup (approxChain (⟨g,hc.monotone⟩ : ((a : _) → Part <| β a) →o (a : _) → Part <| β a)) := by\n  rw [← fix_eq_ωSup]\n  rfl\n\n"}
{"name":"Part.fix_eq_of_ωScottContinuous","module":"Mathlib.Control.LawfulFix","initialProofState":"α : Type u_1\nβ : α → Type u_2\ng : ((a : α) → Part (β a)) → (a : α) → Part (β a)\nhc : OmegaCompletePartialOrder.ωScottContinuous g\n⊢ Eq (Part.fix g) (g (Part.fix g))","decl":"theorem fix_eq_of_ωScottContinuous (hc : ωScottContinuous g) :\n    Part.fix g = g (Part.fix g) := by\n  rw [fix_eq_ωSup_of_ωScottContinuous hc, hc.map_ωSup]\n  apply le_antisymm\n  · apply ωSup_le_ωSup_of_le _\n    intro i\n    exists i\n    intro x\n    apply le_f_of_mem_approx _ ⟨i, rfl⟩\n  · apply ωSup_le_ωSup_of_le _\n    intro i\n    exists i.succ\n\n"}
{"name":"Part.fix_eq","module":"Mathlib.Control.LawfulFix","initialProofState":"α : Type u_1\nβ : α → Type u_2\ng : ((a : α) → Part (β a)) → (a : α) → Part (β a)\nhc : OmegaCompletePartialOrder.ωScottContinuous g\n⊢ Eq (Part.fix g) (g (Part.fix g))","decl":"@[deprecated (since := \"2024-08-26\")] alias fix_eq := fix_eq_of_ωScottContinuous\n\n"}
{"name":"Part.toUnitMono_coe","module":"Mathlib.Control.LawfulFix","initialProofState":"α : Type u_1\nf : OrderHom (Part α) (Part α)\nx : Unit → Part α\nu : Unit\n⊢ Eq ((Part.toUnitMono f) x u) (f (x u))","decl":"/-- `toUnit` as a monotone function -/\n@[simps]\ndef toUnitMono (f : Part α →o Part α) : (Unit → Part α) →o Unit → Part α where\n  toFun x u := f (x u)\n  monotone' x y (h : x ≤ y) u := f.monotone <| h u\n\n"}
{"name":"Part.ωScottContinuous_toUnitMono","module":"Mathlib.Control.LawfulFix","initialProofState":"α : Type u_1\nf : Part α → Part α\nhc : OmegaCompletePartialOrder.ωScottContinuous f\n⊢ OmegaCompletePartialOrder.ωScottContinuous ⇑(Part.toUnitMono { toFun := f, monotone' := ⋯ })","decl":"theorem ωScottContinuous_toUnitMono (f : Part α → Part α) (hc : ωScottContinuous f) :\n    ωScottContinuous (toUnitMono ⟨f,hc.monotone⟩) := .of_map_ωSup_of_orderHom fun _ => by\n  ext ⟨⟩ : 1\n  dsimp [OmegaCompletePartialOrder.ωSup]\n  erw [hc.map_ωSup, Chain.map_comp]; rfl\n\n"}
{"name":"Part.to_unit_cont","module":"Mathlib.Control.LawfulFix","initialProofState":"α : Type u_1\nf : Part α → Part α\nhc : OmegaCompletePartialOrder.ωScottContinuous f\n⊢ OmegaCompletePartialOrder.ωScottContinuous ⇑(Part.toUnitMono { toFun := f, monotone' := ⋯ })","decl":"@[deprecated (since := \"2024-08-26\")] alias to_unit_cont := ωScottContinuous_toUnitMono\n\n"}
{"name":"Pi.monotoneCurry_coe","module":"Mathlib.Control.LawfulFix","initialProofState":"α : Type u_1\nβ : α → Type u_2\nγ : (a : α) → β a → Type u_3\ninst✝ : (x : α) → (y : β x) → Preorder (γ x y)\nf : (x : Sigma fun a => β a) → γ x.fst x.snd\nx : α\ny : β x\n⊢ Eq ((Pi.monotoneCurry α β γ) f x y) (Sigma.curry f x y)","decl":"/-- `Sigma.curry` as a monotone function. -/\n@[simps]\ndef monotoneCurry [(x y : _) → Preorder <| γ x y] :\n    (∀ x : Σa, β a, γ x.1 x.2) →o ∀ (a) (b : β a), γ a b where\n  toFun := curry\n  monotone' _x _y h a b := h ⟨a, b⟩\n\n"}
{"name":"Pi.monotoneUncurry_coe","module":"Mathlib.Control.LawfulFix","initialProofState":"α : Type u_1\nβ : α → Type u_2\nγ : (a : α) → β a → Type u_3\ninst✝ : (x : α) → (y : β x) → Preorder (γ x y)\nf : (x : α) → (y : β x) → γ x y\nx : Sigma β\n⊢ Eq ((Pi.monotoneUncurry α β γ) f x) (Sigma.uncurry f x)","decl":"/-- `Sigma.uncurry` as a monotone function. -/\n@[simps]\ndef monotoneUncurry [(x y : _) → Preorder <| γ x y] :\n    (∀ (a) (b : β a), γ a b) →o ∀ x : Σa, β a, γ x.1 x.2 where\n  toFun := uncurry\n  monotone' _x _y h a := h a.1 a.2\n\n"}
{"name":"Pi.ωScottContinuous_curry","module":"Mathlib.Control.LawfulFix","initialProofState":"α : Type u_1\nβ : α → Type u_2\nγ : (a : α) → β a → Type u_3\ninst✝ : (x : α) → (y : β x) → OmegaCompletePartialOrder (γ x y)\n⊢ OmegaCompletePartialOrder.ωScottContinuous ⇑(Pi.monotoneCurry α β γ)","decl":"theorem ωScottContinuous_curry :\n    ωScottContinuous (monotoneCurry α β γ) :=\n  ωScottContinuous.of_map_ωSup_of_orderHom fun c ↦ by\n    ext x y\n    dsimp [curry, ωSup]\n    rw [map_comp, map_comp]\n    rfl\n\n"}
{"name":"Pi.continuous_curry","module":"Mathlib.Control.LawfulFix","initialProofState":"α : Type u_1\nβ : α → Type u_2\nγ : (a : α) → β a → Type u_3\ninst✝ : (x : α) → (y : β x) → OmegaCompletePartialOrder (γ x y)\n⊢ OmegaCompletePartialOrder.ωScottContinuous ⇑(Pi.monotoneCurry α β γ)","decl":"@[deprecated (since := \"2024-08-26\")] alias continuous_curry := ωScottContinuous_curry\n\n"}
{"name":"Pi.ωScottContinuous_uncurry","module":"Mathlib.Control.LawfulFix","initialProofState":"α : Type u_1\nβ : α → Type u_2\nγ : (a : α) → β a → Type u_3\ninst✝ : (x : α) → (y : β x) → OmegaCompletePartialOrder (γ x y)\n⊢ OmegaCompletePartialOrder.ωScottContinuous ⇑(Pi.monotoneUncurry α β γ)","decl":"theorem ωScottContinuous_uncurry :\n    ωScottContinuous (monotoneUncurry α β γ) :=\n    .of_map_ωSup_of_orderHom fun c ↦ by\n  ext ⟨x, y⟩\n  dsimp [uncurry, ωSup]\n  rw [map_comp, map_comp]\n  rfl\n\n"}
{"name":"Pi.continuous_uncurry","module":"Mathlib.Control.LawfulFix","initialProofState":"α : Type u_1\nβ : α → Type u_2\nγ : (a : α) → β a → Type u_3\ninst✝ : (x : α) → (y : β x) → OmegaCompletePartialOrder (γ x y)\n⊢ OmegaCompletePartialOrder.ωScottContinuous ⇑(Pi.monotoneUncurry α β γ)","decl":"@[deprecated (since := \"2024-08-26\")] alias continuous_uncurry := ωScottContinuous_uncurry\n\n"}
{"name":"Pi.uncurry_curry_ωScottContinuous","module":"Mathlib.Control.LawfulFix","initialProofState":"α : Type u_1\nβ : α → Type u_2\nγ : (a : α) → β a → Type u_3\ninst✝ : (x : α) → (y : β x) → OmegaCompletePartialOrder (γ x y)\nf : ((a : α) → (b : β a) → γ a b) → (a : α) → (b : β a) → γ a b\nhc : OmegaCompletePartialOrder.ωScottContinuous f\n⊢ OmegaCompletePartialOrder.ωScottContinuous ⇑((Pi.monotoneUncurry α β γ).comp ({ toFun := f, monotone' := ⋯ }.comp (Pi.monotoneCurry α β γ)))","decl":"theorem uncurry_curry_ωScottContinuous (hc : ωScottContinuous f) :\n    ωScottContinuous <| (monotoneUncurry α β γ).comp <|\n      (⟨f,hc.monotone⟩ : ((x : _) → (y : β x) → γ x y) →o (x : _) → (y : β x) → γ x y).comp <|\n      monotoneCurry α β γ :=\n  (ωScottContinuous_uncurry _ _ _).comp (hc.comp (ωScottContinuous_curry _ _ _))\n\n"}
{"name":"Pi.uncurry_curry_continuous","module":"Mathlib.Control.LawfulFix","initialProofState":"α : Type u_1\nβ : α → Type u_2\nγ : (a : α) → β a → Type u_3\ninst✝ : (x : α) → (y : β x) → OmegaCompletePartialOrder (γ x y)\nf : ((a : α) → (b : β a) → γ a b) → (a : α) → (b : β a) → γ a b\nhc : OmegaCompletePartialOrder.ωScottContinuous f\n⊢ OmegaCompletePartialOrder.ωScottContinuous ⇑((Pi.monotoneUncurry α β γ).comp ({ toFun := f, monotone' := ⋯ }.comp (Pi.monotoneCurry α β γ)))","decl":"@[deprecated (since := \"2024-08-26\")]\nalias uncurry_curry_continuous := uncurry_curry_ωScottContinuous\n\n"}
