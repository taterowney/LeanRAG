{"name":"VitaliFamily.ae_eventually_measure_pos","module":"Mathlib.MeasureTheory.Covering.Differentiation","initialProofState":"α : Type u_1\ninst✝¹ : PseudoMetricSpace α\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nv : VitaliFamily μ\ninst✝ : SecondCountableTopology α\n⊢ Filter.Eventually (fun x => Filter.Eventually (fun a => LT.lt 0 (μ a)) (v.filterAt x)) (MeasureTheory.ae μ)","decl":"/-- For almost every point `x`, sufficiently small sets in a Vitali family around `x` have positive\nmeasure. (This is a nontrivial result, following from the covering property of Vitali families). -/\ntheorem ae_eventually_measure_pos [SecondCountableTopology α] :\n    ∀ᵐ x ∂μ, ∀ᶠ a in v.filterAt x, 0 < μ a := by\n  set s := {x | ¬∀ᶠ a in v.filterAt x, 0 < μ a} with hs\n  simp (config := { zeta := false }) only [not_lt, not_eventually, nonpos_iff_eq_zero] at hs\n  change μ s = 0\n  let f : α → Set (Set α) := fun _ => {a | μ a = 0}\n  have h : v.FineSubfamilyOn f s := by\n    intro x hx ε εpos\n    rw [hs] at hx\n    simp only [frequently_filterAt_iff, exists_prop, gt_iff_lt, mem_setOf_eq] at hx\n    rcases hx ε εpos with ⟨a, a_sets, ax, μa⟩\n    exact ⟨a, ⟨a_sets, μa⟩, ax⟩\n  refine le_antisymm ?_ bot_le\n  calc\n    μ s ≤ ∑' x : h.index, μ (h.covering x) := h.measure_le_tsum\n    _ = ∑' x : h.index, 0 := by congr; ext1 x; exact h.covering_mem x.2\n    _ = 0 := by simp only [tsum_zero, add_zero]\n\n"}
{"name":"VitaliFamily.eventually_measure_lt_top","module":"Mathlib.MeasureTheory.Covering.Differentiation","initialProofState":"α : Type u_1\ninst✝¹ : PseudoMetricSpace α\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nv : VitaliFamily μ\ninst✝ : MeasureTheory.IsLocallyFiniteMeasure μ\nx : α\n⊢ Filter.Eventually (fun a => LT.lt (μ a) Top.top) (v.filterAt x)","decl":"/-- For every point `x`, sufficiently small sets in a Vitali family around `x` have finite measure.\n(This is a trivial result, following from the fact that the measure is locally finite). -/\ntheorem eventually_measure_lt_top [IsLocallyFiniteMeasure μ] (x : α) :\n    ∀ᶠ a in v.filterAt x, μ a < ∞ :=\n  (μ.finiteAt_nhds x).eventually.filter_mono inf_le_left\n\n"}
{"name":"VitaliFamily.measure_le_of_frequently_le","module":"Mathlib.MeasureTheory.Covering.Differentiation","initialProofState":"α : Type u_1\ninst✝³ : PseudoMetricSpace α\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nv : VitaliFamily μ\ninst✝² : SecondCountableTopology α\ninst✝¹ : BorelSpace α\nρ ν : MeasureTheory.Measure α\ninst✝ : MeasureTheory.IsLocallyFiniteMeasure ν\nhρ : ρ.AbsolutelyContinuous μ\ns : Set α\nhs : ∀ (x : α), Membership.mem s x → Filter.Frequently (fun a => LE.le (ρ a) (ν a)) (v.filterAt x)\n⊢ LE.le (ρ s) (ν s)","decl":"/-- If two measures `ρ` and `ν` have, at every point of a set `s`, arbitrarily small sets in a\nVitali family satisfying `ρ a ≤ ν a`, then `ρ s ≤ ν s` if `ρ ≪ μ`. -/\ntheorem measure_le_of_frequently_le [SecondCountableTopology α] [BorelSpace α] {ρ : Measure α}\n    (ν : Measure α) [IsLocallyFiniteMeasure ν] (hρ : ρ ≪ μ) (s : Set α)\n    (hs : ∀ x ∈ s, ∃ᶠ a in v.filterAt x, ρ a ≤ ν a) : ρ s ≤ ν s := by\n  -- this follows from a covering argument using the sets satisfying `ρ a ≤ ν a`.\n  apply ENNReal.le_of_forall_pos_le_add fun ε εpos _ => ?_\n  obtain ⟨U, sU, U_open, νU⟩ : ∃ (U : Set α), s ⊆ U ∧ IsOpen U ∧ ν U ≤ ν s + ε :=\n    exists_isOpen_le_add s ν (ENNReal.coe_pos.2 εpos).ne'\n  let f : α → Set (Set α) := fun _ => {a | ρ a ≤ ν a ∧ a ⊆ U}\n  have h : v.FineSubfamilyOn f s := by\n    apply v.fineSubfamilyOn_of_frequently f s fun x hx => ?_\n    have :=\n      (hs x hx).and_eventually\n        ((v.eventually_filterAt_mem_setsAt x).and\n          (v.eventually_filterAt_subset_of_nhds (U_open.mem_nhds (sU hx))))\n    apply Frequently.mono this\n    rintro a ⟨ρa, _, aU⟩\n    exact ⟨ρa, aU⟩\n  haveI : Encodable h.index := h.index_countable.toEncodable\n  calc\n    ρ s ≤ ∑' x : h.index, ρ (h.covering x) := h.measure_le_tsum_of_absolutelyContinuous hρ\n    _ ≤ ∑' x : h.index, ν (h.covering x) := ENNReal.tsum_le_tsum fun x => (h.covering_mem x.2).1\n    _ = ν (⋃ x : h.index, h.covering x) := by\n      rw [measure_iUnion h.covering_disjoint_subtype fun i => h.measurableSet_u i.2]\n    _ ≤ ν U := (measure_mono (iUnion_subset fun i => (h.covering_mem i.2).2))\n    _ ≤ ν s + ε := νU\n\n"}
{"name":"VitaliFamily.eventually_filterAt_integrableOn","module":"Mathlib.MeasureTheory.Covering.Differentiation","initialProofState":"α : Type u_1\ninst✝¹ : PseudoMetricSpace α\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nv : VitaliFamily μ\nE : Type u_2\ninst✝ : NormedAddCommGroup E\nx : α\nf : α → E\nhf : MeasureTheory.LocallyIntegrable f μ\n⊢ Filter.Eventually (fun a => MeasureTheory.IntegrableOn f a μ) (v.filterAt x)","decl":"theorem eventually_filterAt_integrableOn (x : α) {f : α → E} (hf : LocallyIntegrable f μ) :\n    ∀ᶠ a in v.filterAt x, IntegrableOn f a μ := by\n  rcases hf x with ⟨w, w_nhds, hw⟩\n  filter_upwards [v.eventually_filterAt_subset_of_nhds w_nhds] with a ha\n  exact hw.mono_set ha\n\n"}
{"name":"VitaliFamily.ae_eventually_measure_zero_of_singular","module":"Mathlib.MeasureTheory.Covering.Differentiation","initialProofState":"α : Type u_1\ninst✝⁴ : PseudoMetricSpace α\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nv : VitaliFamily μ\ninst✝³ : SecondCountableTopology α\ninst✝² : BorelSpace α\ninst✝¹ : MeasureTheory.IsLocallyFiniteMeasure μ\nρ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.IsLocallyFiniteMeasure ρ\nhρ : ρ.MutuallySingular μ\n⊢ Filter.Eventually (fun x => Filter.Tendsto (fun a => HDiv.hDiv (ρ a) (μ a)) (v.filterAt x) (nhds 0)) (MeasureTheory.ae μ)","decl":"/-- If a measure `ρ` is singular with respect to `μ`, then for `μ` almost every `x`, the ratio\n`ρ a / μ a` tends to zero when `a` shrinks to `x` along the Vitali family. This makes sense\nas `μ a` is eventually positive by `ae_eventually_measure_pos`. -/\ntheorem ae_eventually_measure_zero_of_singular (hρ : ρ ⟂ₘ μ) :\n    ∀ᵐ x ∂μ, Tendsto (fun a => ρ a / μ a) (v.filterAt x) (𝓝 0) := by\n  have A : ∀ ε > (0 : ℝ≥0), ∀ᵐ x ∂μ, ∀ᶠ a in v.filterAt x, ρ a < ε * μ a := by\n    intro ε εpos\n    set s := {x | ¬∀ᶠ a in v.filterAt x, ρ a < ε * μ a} with hs\n    change μ s = 0\n    obtain ⟨o, _, ρo, μo⟩ : ∃ o : Set α, MeasurableSet o ∧ ρ o = 0 ∧ μ oᶜ = 0 := hρ\n    apply le_antisymm _ bot_le\n    calc\n      μ s ≤ μ (s ∩ o ∪ oᶜ) := by\n        conv_lhs => rw [← inter_union_compl s o]\n        gcongr\n        apply inter_subset_right\n      _ ≤ μ (s ∩ o) + μ oᶜ := measure_union_le _ _\n      _ = μ (s ∩ o) := by rw [μo, add_zero]\n      _ = (ε : ℝ≥0∞)⁻¹ * (ε • μ) (s ∩ o) := by\n        simp only [coe_nnreal_smul_apply, ← mul_assoc, mul_comm _ (ε : ℝ≥0∞)]\n        rw [ENNReal.mul_inv_cancel (ENNReal.coe_pos.2 εpos).ne' ENNReal.coe_ne_top, one_mul]\n      _ ≤ (ε : ℝ≥0∞)⁻¹ * ρ (s ∩ o) := by\n        gcongr\n        refine v.measure_le_of_frequently_le ρ smul_absolutelyContinuous _ ?_\n        intro x hx\n        rw [hs] at hx\n        simp only [mem_inter_iff, not_lt, not_eventually, mem_setOf_eq] at hx\n        exact hx.1\n      _ ≤ (ε : ℝ≥0∞)⁻¹ * ρ o := by gcongr; apply inter_subset_right\n      _ = 0 := by rw [ρo, mul_zero]\n  obtain ⟨u, _, u_pos, u_lim⟩ :\n    ∃ u : ℕ → ℝ≥0, StrictAnti u ∧ (∀ n : ℕ, 0 < u n) ∧ Tendsto u atTop (𝓝 0) :=\n    exists_seq_strictAnti_tendsto (0 : ℝ≥0)\n  have B : ∀ᵐ x ∂μ, ∀ n, ∀ᶠ a in v.filterAt x, ρ a < u n * μ a :=\n    ae_all_iff.2 fun n => A (u n) (u_pos n)\n  filter_upwards [B, v.ae_eventually_measure_pos]\n  intro x hx h'x\n  refine tendsto_order.2 ⟨fun z hz => (ENNReal.not_lt_zero hz).elim, fun z hz => ?_⟩\n  obtain ⟨w, w_pos, w_lt⟩ : ∃ w : ℝ≥0, (0 : ℝ≥0∞) < w ∧ (w : ℝ≥0∞) < z :=\n    ENNReal.lt_iff_exists_nnreal_btwn.1 hz\n  obtain ⟨n, hn⟩ : ∃ n, u n < w := ((tendsto_order.1 u_lim).2 w (ENNReal.coe_pos.1 w_pos)).exists\n  filter_upwards [hx n, h'x, v.eventually_measure_lt_top x]\n  intro a ha μa_pos μa_lt_top\n  rw [ENNReal.div_lt_iff (Or.inl μa_pos.ne') (Or.inl μa_lt_top.ne)]\n  exact ha.trans_le (mul_le_mul_right' ((ENNReal.coe_le_coe.2 hn.le).trans w_lt.le) _)\n\n"}
{"name":"VitaliFamily.null_of_frequently_le_of_frequently_ge","module":"Mathlib.MeasureTheory.Covering.Differentiation","initialProofState":"α : Type u_1\ninst✝⁴ : PseudoMetricSpace α\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nv : VitaliFamily μ\ninst✝³ : SecondCountableTopology α\ninst✝² : BorelSpace α\ninst✝¹ : MeasureTheory.IsLocallyFiniteMeasure μ\nρ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.IsLocallyFiniteMeasure ρ\nhρ : ρ.AbsolutelyContinuous μ\nc d : NNReal\nhcd : LT.lt c d\ns : Set α\nhc : ∀ (x : α), Membership.mem s x → Filter.Frequently (fun a => LE.le (ρ a) (HMul.hMul (↑c) (μ a))) (v.filterAt x)\nhd : ∀ (x : α), Membership.mem s x → Filter.Frequently (fun a => LE.le (HMul.hMul (↑d) (μ a)) (ρ a)) (v.filterAt x)\n⊢ Eq (μ s) 0","decl":"/-- A set of points `s` satisfying both `ρ a ≤ c * μ a` and `ρ a ≥ d * μ a` at arbitrarily small\nsets in a Vitali family has measure `0` if `c < d`. Indeed, the first inequality should imply\nthat `ρ s ≤ c * μ s`, and the second one that `ρ s ≥ d * μ s`, a contradiction if `0 < μ s`. -/\ntheorem null_of_frequently_le_of_frequently_ge {c d : ℝ≥0} (hcd : c < d) (s : Set α)\n    (hc : ∀ x ∈ s, ∃ᶠ a in v.filterAt x, ρ a ≤ c * μ a)\n    (hd : ∀ x ∈ s, ∃ᶠ a in v.filterAt x, (d : ℝ≥0∞) * μ a ≤ ρ a) : μ s = 0 := by\n  apply measure_null_of_locally_null s fun x _ => ?_\n  obtain ⟨o, xo, o_open, μo⟩ : ∃ o : Set α, x ∈ o ∧ IsOpen o ∧ μ o < ∞ :=\n    Measure.exists_isOpen_measure_lt_top μ x\n  refine ⟨s ∩ o, inter_mem_nhdsWithin _ (o_open.mem_nhds xo), ?_⟩\n  let s' := s ∩ o\n  by_contra h\n  apply lt_irrefl (ρ s')\n  calc\n    ρ s' ≤ c * μ s' := v.measure_le_of_frequently_le (c • μ) hρ s' fun x hx => hc x hx.1\n    _ < d * μ s' := by\n      apply (ENNReal.mul_lt_mul_right h _).2 (ENNReal.coe_lt_coe.2 hcd)\n      exact (lt_of_le_of_lt (measure_mono inter_subset_right) μo).ne\n    _ ≤ ρ s' := v.measure_le_of_frequently_le ρ smul_absolutelyContinuous s' fun x hx ↦ hd x hx.1\n\n"}
{"name":"VitaliFamily.ae_tendsto_div","module":"Mathlib.MeasureTheory.Covering.Differentiation","initialProofState":"α : Type u_1\ninst✝⁴ : PseudoMetricSpace α\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nv : VitaliFamily μ\ninst✝³ : SecondCountableTopology α\ninst✝² : BorelSpace α\ninst✝¹ : MeasureTheory.IsLocallyFiniteMeasure μ\nρ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.IsLocallyFiniteMeasure ρ\nhρ : ρ.AbsolutelyContinuous μ\n⊢ Filter.Eventually (fun x => Exists fun c => Filter.Tendsto (fun a => HDiv.hDiv (ρ a) (μ a)) (v.filterAt x) (nhds c)) (MeasureTheory.ae μ)","decl":"/-- If `ρ` is absolutely continuous with respect to `μ`, then for almost every `x`,\nthe ratio `ρ a / μ a` converges as `a` shrinks to `x` along a Vitali family for `μ`. -/\ntheorem ae_tendsto_div : ∀ᵐ x ∂μ, ∃ c, Tendsto (fun a => ρ a / μ a) (v.filterAt x) (𝓝 c) := by\n  obtain ⟨w, w_count, w_dense, _, w_top⟩ :\n    ∃ w : Set ℝ≥0∞, w.Countable ∧ Dense w ∧ 0 ∉ w ∧ ∞ ∉ w :=\n    ENNReal.exists_countable_dense_no_zero_top\n  have I : ∀ x ∈ w, x ≠ ∞ := fun x xs hx => w_top (hx ▸ xs)\n  have A : ∀ c ∈ w, ∀ d ∈ w, c < d → ∀ᵐ x ∂μ,\n      ¬((∃ᶠ a in v.filterAt x, ρ a / μ a < c) ∧ ∃ᶠ a in v.filterAt x, d < ρ a / μ a) := by\n    intro c hc d hd hcd\n    lift c to ℝ≥0 using I c hc\n    lift d to ℝ≥0 using I d hd\n    apply v.null_of_frequently_le_of_frequently_ge hρ (ENNReal.coe_lt_coe.1 hcd)\n    · simp only [and_imp, exists_prop, not_frequently, not_and, not_lt, not_le, not_eventually,\n        mem_setOf_eq, mem_compl_iff, not_forall]\n      intro x h1x _\n      apply h1x.mono fun a ha => ?_\n      refine (ENNReal.div_le_iff_le_mul ?_ (Or.inr (bot_le.trans_lt ha).ne')).1 ha.le\n      simp only [ENNReal.coe_ne_top, Ne, or_true, not_false_iff]\n    · simp only [and_imp, exists_prop, not_frequently, not_and, not_lt, not_le, not_eventually,\n        mem_setOf_eq, mem_compl_iff, not_forall]\n      intro x _ h2x\n      apply h2x.mono fun a ha => ?_\n      exact ENNReal.mul_le_of_le_div ha.le\n  have B : ∀ᵐ x ∂μ, ∀ c ∈ w, ∀ d ∈ w, c < d →\n      ¬((∃ᶠ a in v.filterAt x, ρ a / μ a < c) ∧ ∃ᶠ a in v.filterAt x, d < ρ a / μ a) := by\n    #adaptation_note /-- 2024-04-23\n    The next two lines were previously just `simpa only [ae_ball_iff w_count, ae_all_iff]` -/\n    rw [ae_ball_iff w_count]; intro x hx; rw [ae_ball_iff w_count]; revert x\n    simpa only [ae_all_iff]\n  filter_upwards [B]\n  intro x hx\n  exact tendsto_of_no_upcrossings w_dense hx\n\n"}
{"name":"VitaliFamily.ae_tendsto_limRatio","module":"Mathlib.MeasureTheory.Covering.Differentiation","initialProofState":"α : Type u_1\ninst✝⁴ : PseudoMetricSpace α\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nv : VitaliFamily μ\ninst✝³ : SecondCountableTopology α\ninst✝² : BorelSpace α\ninst✝¹ : MeasureTheory.IsLocallyFiniteMeasure μ\nρ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.IsLocallyFiniteMeasure ρ\nhρ : ρ.AbsolutelyContinuous μ\n⊢ Filter.Eventually (fun x => Filter.Tendsto (fun a => HDiv.hDiv (ρ a) (μ a)) (v.filterAt x) (nhds (v.limRatio ρ x))) (MeasureTheory.ae μ)","decl":"theorem ae_tendsto_limRatio :\n    ∀ᵐ x ∂μ, Tendsto (fun a => ρ a / μ a) (v.filterAt x) (𝓝 (v.limRatio ρ x)) := by\n  filter_upwards [v.ae_tendsto_div hρ]\n  intro x hx\n  exact tendsto_nhds_limUnder hx\n\n"}
{"name":"VitaliFamily.exists_measurable_supersets_limRatio","module":"Mathlib.MeasureTheory.Covering.Differentiation","initialProofState":"α : Type u_1\ninst✝⁴ : PseudoMetricSpace α\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nv : VitaliFamily μ\ninst✝³ : SecondCountableTopology α\ninst✝² : BorelSpace α\ninst✝¹ : MeasureTheory.IsLocallyFiniteMeasure μ\nρ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.IsLocallyFiniteMeasure ρ\nhρ : ρ.AbsolutelyContinuous μ\np q : NNReal\nhpq : LT.lt p q\n⊢ Exists fun a => Exists fun b => And (MeasurableSet a) (And (MeasurableSet b) (And (HasSubset.Subset (setOf fun x => LT.lt (v.limRatio ρ x) ↑p) a) (And (HasSubset.Subset (setOf fun x => LT.lt (↑q) (v.limRatio ρ x)) b) (Eq (μ (Inter.inter a b)) 0))))","decl":"/-- Given two thresholds `p < q`, the sets `{x | v.limRatio ρ x < p}`\nand `{x | q < v.limRatio ρ x}` are obviously disjoint. The key to proving that `v.limRatio ρ` is\nalmost everywhere measurable is to show that these sets have measurable supersets which are also\ndisjoint, up to zero measure. This is the content of this lemma. -/\ntheorem exists_measurable_supersets_limRatio {p q : ℝ≥0} (hpq : p < q) :\n    ∃ a b, MeasurableSet a ∧ MeasurableSet b ∧\n      {x | v.limRatio ρ x < p} ⊆ a ∧ {x | (q : ℝ≥0∞) < v.limRatio ρ x} ⊆ b ∧ μ (a ∩ b) = 0 := by\n  /- Here is a rough sketch, assuming that the measure is finite and the limit is well defined\n    everywhere. Let `u := {x | v.limRatio ρ x < p}` and `w := {x | q < v.limRatio ρ x}`. They\n    have measurable supersets `u'` and `w'` of the same measure. We will show that these satisfy\n    the conclusion of the theorem, i.e., `μ (u' ∩ w') = 0`. For this, note that\n    `ρ (u' ∩ w') = ρ (u ∩ w')` (as `w'` is measurable, see `measure_toMeasurable_add_inter_left`).\n    The latter set is included in the set where the limit of the ratios is `< p`, and therefore\n    its measure is `≤ p * μ (u ∩ w')`. Using the same trick in the other direction gives that this\n    is `p * μ (u' ∩ w')`. We have shown that `ρ (u' ∩ w') ≤ p * μ (u' ∩ w')`. Arguing in the same\n    way but using the `w` part gives `q * μ (u' ∩ w') ≤ ρ (u' ∩ w')`. If `μ (u' ∩ w')` were nonzero,\n    this would be a contradiction as `p < q`.\n\n    For the rigorous proof, we need to work on a part of the space where the measure is finite\n    (provided by `spanningSets (ρ + μ)`) and to restrict to the set where the limit is well defined\n    (called `s` below, of full measure). Otherwise, the argument goes through.\n    -/\n  let s := {x | ∃ c, Tendsto (fun a => ρ a / μ a) (v.filterAt x) (𝓝 c)}\n  let o : ℕ → Set α := spanningSets (ρ + μ)\n  let u n := s ∩ {x | v.limRatio ρ x < p} ∩ o n\n  let w n := s ∩ {x | (q : ℝ≥0∞) < v.limRatio ρ x} ∩ o n\n  -- the supersets are obtained by restricting to the set `s` where the limit is well defined, to\n  -- a finite measure part `o n`, taking a measurable superset here, and then taking the union over\n  -- `n`.\n  refine\n    ⟨toMeasurable μ sᶜ ∪ ⋃ n, toMeasurable (ρ + μ) (u n),\n      toMeasurable μ sᶜ ∪ ⋃ n, toMeasurable (ρ + μ) (w n), ?_, ?_, ?_, ?_, ?_⟩\n  -- check that these sets are measurable supersets as required\n  · exact\n      (measurableSet_toMeasurable _ _).union\n        (MeasurableSet.iUnion fun n => measurableSet_toMeasurable _ _)\n  · exact\n      (measurableSet_toMeasurable _ _).union\n        (MeasurableSet.iUnion fun n => measurableSet_toMeasurable _ _)\n  · intro x hx\n    by_cases h : x ∈ s\n    · refine Or.inr (mem_iUnion.2 ⟨spanningSetsIndex (ρ + μ) x, ?_⟩)\n      exact subset_toMeasurable _ _ ⟨⟨h, hx⟩, mem_spanningSetsIndex _ _⟩\n    · exact Or.inl (subset_toMeasurable μ sᶜ h)\n  · intro x hx\n    by_cases h : x ∈ s\n    · refine Or.inr (mem_iUnion.2 ⟨spanningSetsIndex (ρ + μ) x, ?_⟩)\n      exact subset_toMeasurable _ _ ⟨⟨h, hx⟩, mem_spanningSetsIndex _ _⟩\n    · exact Or.inl (subset_toMeasurable μ sᶜ h)\n  -- it remains to check the nontrivial part that these sets have zero measure intersection.\n  -- it suffices to do it for fixed `m` and `n`, as one is taking countable unions.\n  suffices H : ∀ m n : ℕ, μ (toMeasurable (ρ + μ) (u m) ∩ toMeasurable (ρ + μ) (w n)) = 0 by\n    have A :\n      (toMeasurable μ sᶜ ∪ ⋃ n, toMeasurable (ρ + μ) (u n)) ∩\n          (toMeasurable μ sᶜ ∪ ⋃ n, toMeasurable (ρ + μ) (w n)) ⊆\n        toMeasurable μ sᶜ ∪\n          ⋃ (m) (n), toMeasurable (ρ + μ) (u m) ∩ toMeasurable (ρ + μ) (w n) := by\n      simp only [inter_union_distrib_left, union_inter_distrib_right, true_and,\n        subset_union_left, union_subset_iff, inter_self]\n      refine ⟨?_, ?_, ?_⟩\n      · exact inter_subset_right.trans subset_union_left\n      · exact inter_subset_left.trans subset_union_left\n      · simp_rw [iUnion_inter, inter_iUnion]; exact subset_union_right\n    refine le_antisymm ((measure_mono A).trans ?_) bot_le\n    calc\n      μ (toMeasurable μ sᶜ ∪\n        ⋃ (m) (n), toMeasurable (ρ + μ) (u m) ∩ toMeasurable (ρ + μ) (w n)) ≤\n          μ (toMeasurable μ sᶜ) +\n            μ (⋃ (m) (n), toMeasurable (ρ + μ) (u m) ∩ toMeasurable (ρ + μ) (w n)) :=\n        measure_union_le _ _\n      _ = μ (⋃ (m) (n), toMeasurable (ρ + μ) (u m) ∩ toMeasurable (ρ + μ) (w n)) := by\n        have : μ sᶜ = 0 := v.ae_tendsto_div hρ; rw [measure_toMeasurable, this, zero_add]\n      _ ≤ ∑' (m) (n), μ (toMeasurable (ρ + μ) (u m) ∩ toMeasurable (ρ + μ) (w n)) :=\n        ((measure_iUnion_le _).trans (ENNReal.tsum_le_tsum fun m => measure_iUnion_le _))\n      _ = 0 := by simp only [H, tsum_zero]\n  -- now starts the nontrivial part of the argument. We fix `m` and `n`, and show that the\n  -- measurable supersets of `u m` and `w n` have zero measure intersection by using the lemmas\n  -- `measure_toMeasurable_add_inter_left` (to reduce to `u m` or `w n` instead of the measurable\n  -- superset) and `measure_le_of_frequently_le` to compare their measures for `ρ` and `μ`.\n  intro m n\n  have I : (ρ + μ) (u m) ≠ ∞ := by\n    apply (lt_of_le_of_lt (measure_mono _) (measure_spanningSets_lt_top (ρ + μ) m)).ne\n    exact inter_subset_right\n  have J : (ρ + μ) (w n) ≠ ∞ := by\n    apply (lt_of_le_of_lt (measure_mono _) (measure_spanningSets_lt_top (ρ + μ) n)).ne\n    exact inter_subset_right\n  have A :\n    ρ (toMeasurable (ρ + μ) (u m) ∩ toMeasurable (ρ + μ) (w n)) ≤\n      p * μ (toMeasurable (ρ + μ) (u m) ∩ toMeasurable (ρ + μ) (w n)) :=\n    calc\n      ρ (toMeasurable (ρ + μ) (u m) ∩ toMeasurable (ρ + μ) (w n)) =\n          ρ (u m ∩ toMeasurable (ρ + μ) (w n)) :=\n        measure_toMeasurable_add_inter_left (measurableSet_toMeasurable _ _) I\n      _ ≤ (p • μ) (u m ∩ toMeasurable (ρ + μ) (w n)) := by\n        refine v.measure_le_of_frequently_le (p • μ) hρ _ fun x hx => ?_\n        have L : Tendsto (fun a : Set α => ρ a / μ a) (v.filterAt x) (𝓝 (v.limRatio ρ x)) :=\n          tendsto_nhds_limUnder hx.1.1.1\n        have I : ∀ᶠ b : Set α in v.filterAt x, ρ b / μ b < p := (tendsto_order.1 L).2 _ hx.1.1.2\n        apply I.frequently.mono fun a ha => ?_\n        rw [coe_nnreal_smul_apply]\n        refine (ENNReal.div_le_iff_le_mul ?_ (Or.inr (bot_le.trans_lt ha).ne')).1 ha.le\n        simp only [ENNReal.coe_ne_top, Ne, or_true, not_false_iff]\n      _ = p * μ (toMeasurable (ρ + μ) (u m) ∩ toMeasurable (ρ + μ) (w n)) := by\n        simp only [coe_nnreal_smul_apply,\n          measure_toMeasurable_add_inter_right (measurableSet_toMeasurable _ _) I]\n  have B :\n    (q : ℝ≥0∞) * μ (toMeasurable (ρ + μ) (u m) ∩ toMeasurable (ρ + μ) (w n)) ≤\n      ρ (toMeasurable (ρ + μ) (u m) ∩ toMeasurable (ρ + μ) (w n)) :=\n    calc\n      (q : ℝ≥0∞) * μ (toMeasurable (ρ + μ) (u m) ∩ toMeasurable (ρ + μ) (w n)) =\n          (q : ℝ≥0∞) * μ (toMeasurable (ρ + μ) (u m) ∩ w n) := by\n        conv_rhs => rw [inter_comm]\n        rw [inter_comm, measure_toMeasurable_add_inter_right (measurableSet_toMeasurable _ _) J]\n      _ ≤ ρ (toMeasurable (ρ + μ) (u m) ∩ w n) := by\n        rw [← coe_nnreal_smul_apply]\n        refine v.measure_le_of_frequently_le _ (.smul_left .rfl _) _ ?_\n        intro x hx\n        have L : Tendsto (fun a : Set α => ρ a / μ a) (v.filterAt x) (𝓝 (v.limRatio ρ x)) :=\n          tendsto_nhds_limUnder hx.2.1.1\n        have I : ∀ᶠ b : Set α in v.filterAt x, (q : ℝ≥0∞) < ρ b / μ b :=\n          (tendsto_order.1 L).1 _ hx.2.1.2\n        apply I.frequently.mono fun a ha => ?_\n        rw [coe_nnreal_smul_apply]\n        exact ENNReal.mul_le_of_le_div ha.le\n      _ = ρ (toMeasurable (ρ + μ) (u m) ∩ toMeasurable (ρ + μ) (w n)) := by\n        conv_rhs => rw [inter_comm]\n        rw [inter_comm]\n        exact (measure_toMeasurable_add_inter_left (measurableSet_toMeasurable _ _) J).symm\n  by_contra h\n  apply lt_irrefl (ρ (toMeasurable (ρ + μ) (u m) ∩ toMeasurable (ρ + μ) (w n)))\n  calc\n    ρ (toMeasurable (ρ + μ) (u m) ∩ toMeasurable (ρ + μ) (w n)) ≤\n        p * μ (toMeasurable (ρ + μ) (u m) ∩ toMeasurable (ρ + μ) (w n)) :=\n      A\n    _ < q * μ (toMeasurable (ρ + μ) (u m) ∩ toMeasurable (ρ + μ) (w n)) := by\n      gcongr\n      suffices H : (ρ + μ) (toMeasurable (ρ + μ) (u m) ∩ toMeasurable (ρ + μ) (w n)) ≠ ∞ by\n        simp only [not_or, ENNReal.add_eq_top, Pi.add_apply, Ne, coe_add] at H\n        exact H.2\n      apply (lt_of_le_of_lt (measure_mono inter_subset_left) _).ne\n      rw [measure_toMeasurable]\n      apply lt_of_le_of_lt (measure_mono _) (measure_spanningSets_lt_top (ρ + μ) m)\n      exact inter_subset_right\n    _ ≤ ρ (toMeasurable (ρ + μ) (u m) ∩ toMeasurable (ρ + μ) (w n)) := B\n\n"}
{"name":"VitaliFamily.aemeasurable_limRatio","module":"Mathlib.MeasureTheory.Covering.Differentiation","initialProofState":"α : Type u_1\ninst✝⁴ : PseudoMetricSpace α\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nv : VitaliFamily μ\ninst✝³ : SecondCountableTopology α\ninst✝² : BorelSpace α\ninst✝¹ : MeasureTheory.IsLocallyFiniteMeasure μ\nρ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.IsLocallyFiniteMeasure ρ\nhρ : ρ.AbsolutelyContinuous μ\n⊢ AEMeasurable (v.limRatio ρ) μ","decl":"theorem aemeasurable_limRatio : AEMeasurable (v.limRatio ρ) μ := by\n  apply ENNReal.aemeasurable_of_exist_almost_disjoint_supersets _ _ fun p q hpq => ?_\n  exact v.exists_measurable_supersets_limRatio hρ hpq\n\n"}
{"name":"VitaliFamily.limRatioMeas_measurable","module":"Mathlib.MeasureTheory.Covering.Differentiation","initialProofState":"α : Type u_1\ninst✝⁴ : PseudoMetricSpace α\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nv : VitaliFamily μ\ninst✝³ : SecondCountableTopology α\ninst✝² : BorelSpace α\ninst✝¹ : MeasureTheory.IsLocallyFiniteMeasure μ\nρ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.IsLocallyFiniteMeasure ρ\nhρ : ρ.AbsolutelyContinuous μ\n⊢ Measurable (v.limRatioMeas hρ)","decl":"theorem limRatioMeas_measurable : Measurable (v.limRatioMeas hρ) :=\n  AEMeasurable.measurable_mk _\n\n"}
{"name":"VitaliFamily.ae_tendsto_limRatioMeas","module":"Mathlib.MeasureTheory.Covering.Differentiation","initialProofState":"α : Type u_1\ninst✝⁴ : PseudoMetricSpace α\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nv : VitaliFamily μ\ninst✝³ : SecondCountableTopology α\ninst✝² : BorelSpace α\ninst✝¹ : MeasureTheory.IsLocallyFiniteMeasure μ\nρ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.IsLocallyFiniteMeasure ρ\nhρ : ρ.AbsolutelyContinuous μ\n⊢ Filter.Eventually (fun x => Filter.Tendsto (fun a => HDiv.hDiv (ρ a) (μ a)) (v.filterAt x) (nhds (v.limRatioMeas hρ x))) (MeasureTheory.ae μ)","decl":"theorem ae_tendsto_limRatioMeas :\n    ∀ᵐ x ∂μ, Tendsto (fun a => ρ a / μ a) (v.filterAt x) (𝓝 (v.limRatioMeas hρ x)) := by\n  filter_upwards [v.ae_tendsto_limRatio hρ, AEMeasurable.ae_eq_mk (v.aemeasurable_limRatio hρ)]\n  intro x hx h'x\n  rwa [h'x] at hx\n\n"}
{"name":"VitaliFamily.measure_le_mul_of_subset_limRatioMeas_lt","module":"Mathlib.MeasureTheory.Covering.Differentiation","initialProofState":"α : Type u_1\ninst✝⁴ : PseudoMetricSpace α\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nv : VitaliFamily μ\ninst✝³ : SecondCountableTopology α\ninst✝² : BorelSpace α\ninst✝¹ : MeasureTheory.IsLocallyFiniteMeasure μ\nρ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.IsLocallyFiniteMeasure ρ\nhρ : ρ.AbsolutelyContinuous μ\np : NNReal\ns : Set α\nh : HasSubset.Subset s (setOf fun x => LT.lt (v.limRatioMeas hρ x) ↑p)\n⊢ LE.le (ρ s) (HMul.hMul (↑p) (μ s))","decl":"/-- If, for all `x` in a set `s`, one has frequently `ρ a / μ a < p`, then `ρ s ≤ p * μ s`, as\nproved in `measure_le_of_frequently_le`. Since `ρ a / μ a` tends almost everywhere to\n`v.limRatioMeas hρ x`, the same property holds for sets `s` on which `v.limRatioMeas hρ < p`. -/\ntheorem measure_le_mul_of_subset_limRatioMeas_lt {p : ℝ≥0} {s : Set α}\n    (h : s ⊆ {x | v.limRatioMeas hρ x < p}) : ρ s ≤ p * μ s := by\n  let t := {x : α | Tendsto (fun a => ρ a / μ a) (v.filterAt x) (𝓝 (v.limRatioMeas hρ x))}\n  have A : μ tᶜ = 0 := v.ae_tendsto_limRatioMeas hρ\n  suffices H : ρ (s ∩ t) ≤ (p • μ) (s ∩ t) by calc\n    ρ s = ρ (s ∩ t ∪ s ∩ tᶜ) := by rw [inter_union_compl]\n    _ ≤ ρ (s ∩ t) + ρ (s ∩ tᶜ) := measure_union_le _ _\n    _ ≤ (p • μ) (s ∩ t) + ρ tᶜ := by gcongr; apply inter_subset_right\n    _ ≤ p * μ (s ∩ t) := by simp [(hρ A)]\n    _ ≤ p * μ s := by gcongr; apply inter_subset_left\n  refine v.measure_le_of_frequently_le (p • μ) hρ _ fun x hx => ?_\n  have I : ∀ᶠ b : Set α in v.filterAt x, ρ b / μ b < p := (tendsto_order.1 hx.2).2 _ (h hx.1)\n  apply I.frequently.mono fun a ha => ?_\n  rw [coe_nnreal_smul_apply]\n  refine (ENNReal.div_le_iff_le_mul ?_ (Or.inr (bot_le.trans_lt ha).ne')).1 ha.le\n  simp only [ENNReal.coe_ne_top, Ne, or_true, not_false_iff]\n\n"}
{"name":"VitaliFamily.mul_measure_le_of_subset_lt_limRatioMeas","module":"Mathlib.MeasureTheory.Covering.Differentiation","initialProofState":"α : Type u_1\ninst✝⁴ : PseudoMetricSpace α\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nv : VitaliFamily μ\ninst✝³ : SecondCountableTopology α\ninst✝² : BorelSpace α\ninst✝¹ : MeasureTheory.IsLocallyFiniteMeasure μ\nρ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.IsLocallyFiniteMeasure ρ\nhρ : ρ.AbsolutelyContinuous μ\nq : NNReal\ns : Set α\nh : HasSubset.Subset s (setOf fun x => LT.lt (↑q) (v.limRatioMeas hρ x))\n⊢ LE.le (HMul.hMul (↑q) (μ s)) (ρ s)","decl":"/-- If, for all `x` in a set `s`, one has frequently `q < ρ a / μ a`, then `q * μ s ≤ ρ s`, as\nproved in `measure_le_of_frequently_le`. Since `ρ a / μ a` tends almost everywhere to\n`v.limRatioMeas hρ x`, the same property holds for sets `s` on which `q < v.limRatioMeas hρ`. -/\ntheorem mul_measure_le_of_subset_lt_limRatioMeas {q : ℝ≥0} {s : Set α}\n    (h : s ⊆ {x | (q : ℝ≥0∞) < v.limRatioMeas hρ x}) : (q : ℝ≥0∞) * μ s ≤ ρ s := by\n  let t := {x : α | Tendsto (fun a => ρ a / μ a) (v.filterAt x) (𝓝 (v.limRatioMeas hρ x))}\n  have A : μ tᶜ = 0 := v.ae_tendsto_limRatioMeas hρ\n  suffices H : (q • μ) (s ∩ t) ≤ ρ (s ∩ t) by calc\n    (q • μ) s = (q • μ) (s ∩ t ∪ s ∩ tᶜ) := by rw [inter_union_compl]\n    _ ≤ (q • μ) (s ∩ t) + (q • μ) (s ∩ tᶜ) := measure_union_le _ _\n    _ ≤ ρ (s ∩ t) + (q • μ) tᶜ := by gcongr; apply inter_subset_right\n    _ = ρ (s ∩ t) := by simp [A]\n    _ ≤ ρ s := by gcongr; apply inter_subset_left\n  refine v.measure_le_of_frequently_le _ (.smul_left .rfl _) _ ?_\n  intro x hx\n  have I : ∀ᶠ a in v.filterAt x, (q : ℝ≥0∞) < ρ a / μ a := (tendsto_order.1 hx.2).1 _ (h hx.1)\n  apply I.frequently.mono fun a ha => ?_\n  rw [coe_nnreal_smul_apply]\n  exact ENNReal.mul_le_of_le_div ha.le\n\n"}
{"name":"VitaliFamily.measure_limRatioMeas_top","module":"Mathlib.MeasureTheory.Covering.Differentiation","initialProofState":"α : Type u_1\ninst✝⁴ : PseudoMetricSpace α\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nv : VitaliFamily μ\ninst✝³ : SecondCountableTopology α\ninst✝² : BorelSpace α\ninst✝¹ : MeasureTheory.IsLocallyFiniteMeasure μ\nρ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.IsLocallyFiniteMeasure ρ\nhρ : ρ.AbsolutelyContinuous μ\n⊢ Eq (μ (setOf fun x => Eq (v.limRatioMeas hρ x) Top.top)) 0","decl":"/-- The points with `v.limRatioMeas hρ x = ∞` have measure `0` for `μ`. -/\ntheorem measure_limRatioMeas_top : μ {x | v.limRatioMeas hρ x = ∞} = 0 := by\n  refine measure_null_of_locally_null _ fun x _ => ?_\n  obtain ⟨o, xo, o_open, μo⟩ : ∃ o : Set α, x ∈ o ∧ IsOpen o ∧ ρ o < ∞ :=\n    Measure.exists_isOpen_measure_lt_top ρ x\n  let s := {x : α | v.limRatioMeas hρ x = ∞} ∩ o\n  refine ⟨s, inter_mem_nhdsWithin _ (o_open.mem_nhds xo), le_antisymm ?_ bot_le⟩\n  have ρs : ρ s ≠ ∞ := ((measure_mono inter_subset_right).trans_lt μo).ne\n  have A : ∀ q : ℝ≥0, 1 ≤ q → μ s ≤ (q : ℝ≥0∞)⁻¹ * ρ s := by\n    intro q hq\n    rw [mul_comm, ← div_eq_mul_inv, ENNReal.le_div_iff_mul_le _ (Or.inr ρs), mul_comm]\n    · apply v.mul_measure_le_of_subset_lt_limRatioMeas hρ\n      intro y hy\n      have : v.limRatioMeas hρ y = ∞ := hy.1\n      simp only [this, ENNReal.coe_lt_top, mem_setOf_eq]\n    · simp only [(zero_lt_one.trans_le hq).ne', true_or, ENNReal.coe_eq_zero, Ne,\n        not_false_iff]\n  have B : Tendsto (fun q : ℝ≥0 => (q : ℝ≥0∞)⁻¹ * ρ s) atTop (𝓝 (∞⁻¹ * ρ s)) := by\n    apply ENNReal.Tendsto.mul_const _ (Or.inr ρs)\n    exact ENNReal.tendsto_inv_iff.2 (ENNReal.tendsto_coe_nhds_top.2 tendsto_id)\n  simp only [zero_mul, ENNReal.inv_top] at B\n  apply ge_of_tendsto B\n  exact eventually_atTop.2 ⟨1, A⟩\n\n"}
{"name":"VitaliFamily.measure_limRatioMeas_zero","module":"Mathlib.MeasureTheory.Covering.Differentiation","initialProofState":"α : Type u_1\ninst✝⁴ : PseudoMetricSpace α\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nv : VitaliFamily μ\ninst✝³ : SecondCountableTopology α\ninst✝² : BorelSpace α\ninst✝¹ : MeasureTheory.IsLocallyFiniteMeasure μ\nρ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.IsLocallyFiniteMeasure ρ\nhρ : ρ.AbsolutelyContinuous μ\n⊢ Eq (ρ (setOf fun x => Eq (v.limRatioMeas hρ x) 0)) 0","decl":"/-- The points with `v.limRatioMeas hρ x = 0` have measure `0` for `ρ`. -/\ntheorem measure_limRatioMeas_zero : ρ {x | v.limRatioMeas hρ x = 0} = 0 := by\n  refine measure_null_of_locally_null _ fun x _ => ?_\n  obtain ⟨o, xo, o_open, μo⟩ : ∃ o : Set α, x ∈ o ∧ IsOpen o ∧ μ o < ∞ :=\n    Measure.exists_isOpen_measure_lt_top μ x\n  let s := {x : α | v.limRatioMeas hρ x = 0} ∩ o\n  refine ⟨s, inter_mem_nhdsWithin _ (o_open.mem_nhds xo), le_antisymm ?_ bot_le⟩\n  have μs : μ s ≠ ∞ := ((measure_mono inter_subset_right).trans_lt μo).ne\n  have A : ∀ q : ℝ≥0, 0 < q → ρ s ≤ q * μ s := by\n    intro q hq\n    apply v.measure_le_mul_of_subset_limRatioMeas_lt hρ\n    intro y hy\n    have : v.limRatioMeas hρ y = 0 := hy.1\n    simp only [this, mem_setOf_eq, hq, ENNReal.coe_pos]\n  have B : Tendsto (fun q : ℝ≥0 => (q : ℝ≥0∞) * μ s) (𝓝[>] (0 : ℝ≥0)) (𝓝 ((0 : ℝ≥0) * μ s)) := by\n    apply ENNReal.Tendsto.mul_const _ (Or.inr μs)\n    rw [ENNReal.tendsto_coe]\n    exact nhdsWithin_le_nhds\n  simp only [zero_mul, ENNReal.coe_zero] at B\n  apply ge_of_tendsto B\n  filter_upwards [self_mem_nhdsWithin] using A\n\n"}
{"name":"VitaliFamily.withDensity_le_mul","module":"Mathlib.MeasureTheory.Covering.Differentiation","initialProofState":"α : Type u_1\ninst✝⁴ : PseudoMetricSpace α\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nv : VitaliFamily μ\ninst✝³ : SecondCountableTopology α\ninst✝² : BorelSpace α\ninst✝¹ : MeasureTheory.IsLocallyFiniteMeasure μ\nρ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.IsLocallyFiniteMeasure ρ\nhρ : ρ.AbsolutelyContinuous μ\ns : Set α\nhs : MeasurableSet s\nt : NNReal\nht : LT.lt 1 t\n⊢ LE.le ((μ.withDensity (v.limRatioMeas hρ)) s) (HMul.hMul (HPow.hPow (↑t) 2) (ρ s))","decl":"/-- As an intermediate step to show that `μ.withDensity (v.limRatioMeas hρ) = ρ`, we show here\nthat `μ.withDensity (v.limRatioMeas hρ) ≤ t^2 ρ` for any `t > 1`. -/\ntheorem withDensity_le_mul {s : Set α} (hs : MeasurableSet s) {t : ℝ≥0} (ht : 1 < t) :\n    μ.withDensity (v.limRatioMeas hρ) s ≤ (t : ℝ≥0∞) ^ 2 * ρ s := by\n  /- We cut `s` into the sets where `v.limRatioMeas hρ = 0`, where `v.limRatioMeas hρ = ∞`, and\n    where `v.limRatioMeas hρ ∈ [t^n, t^(n+1))` for `n : ℤ`. The first and second have measure `0`.\n    For the latter, since `v.limRatioMeas hρ` fluctuates by at most `t` on this slice, we can use\n    `measure_le_mul_of_subset_limRatioMeas_lt` and `mul_measure_le_of_subset_lt_limRatioMeas` to\n    show that the two measures are comparable up to `t` (in fact `t^2` for technical reasons of\n    strict inequalities). -/\n  have t_ne_zero' : t ≠ 0 := (zero_lt_one.trans ht).ne'\n  have t_ne_zero : (t : ℝ≥0∞) ≠ 0 := by simpa only [ENNReal.coe_eq_zero, Ne] using t_ne_zero'\n  let ν := μ.withDensity (v.limRatioMeas hρ)\n  let f := v.limRatioMeas hρ\n  have f_meas : Measurable f := v.limRatioMeas_measurable hρ\n  -- Note(kmill): smul elaborator when used for CoeFun fails to get CoeFun instance to trigger\n  -- unless you use the `(... :)` notation. Another fix is using `(2 : Nat)`, so this appears\n  -- to be an unpleasant interaction with default instances.\n  have A : ν (s ∩ f ⁻¹' {0}) ≤ ((t : ℝ≥0∞) ^ 2 • ρ :) (s ∩ f ⁻¹' {0}) := by\n    apply le_trans _ (zero_le _)\n    have M : MeasurableSet (s ∩ f ⁻¹' {0}) := hs.inter (f_meas (measurableSet_singleton _))\n    simp only [f, ν, nonpos_iff_eq_zero, M, withDensity_apply, lintegral_eq_zero_iff f_meas]\n    apply (ae_restrict_iff' M).2\n    exact Eventually.of_forall fun x hx => hx.2\n  have B : ν (s ∩ f ⁻¹' {∞}) ≤ ((t : ℝ≥0∞) ^ 2 • ρ :) (s ∩ f ⁻¹' {∞}) := by\n    apply le_trans (le_of_eq _) (zero_le _)\n    apply withDensity_absolutelyContinuous μ _\n    rw [← nonpos_iff_eq_zero]\n    exact (measure_mono inter_subset_right).trans (v.measure_limRatioMeas_top hρ).le\n  have C :\n    ∀ n : ℤ,\n      ν (s ∩ f ⁻¹' Ico ((t : ℝ≥0∞) ^ n) ((t : ℝ≥0∞) ^ (n + 1))) ≤\n        ((t : ℝ≥0∞) ^ 2 • ρ :) (s ∩ f ⁻¹' Ico ((t : ℝ≥0∞) ^ n) ((t : ℝ≥0∞) ^ (n + 1))) := by\n    intro n\n    let I := Ico ((t : ℝ≥0∞) ^ n) ((t : ℝ≥0∞) ^ (n + 1))\n    have M : MeasurableSet (s ∩ f ⁻¹' I) := hs.inter (f_meas measurableSet_Ico)\n    simp only [ν, I, M, withDensity_apply, coe_nnreal_smul_apply]\n    calc\n      (∫⁻ x in s ∩ f ⁻¹' I, f x ∂μ) ≤ ∫⁻ _ in s ∩ f ⁻¹' I, (t : ℝ≥0∞) ^ (n + 1) ∂μ :=\n        lintegral_mono_ae ((ae_restrict_iff' M).2 (Eventually.of_forall fun x hx => hx.2.2.le))\n      _ = (t : ℝ≥0∞) ^ (n + 1) * μ (s ∩ f ⁻¹' I) := by\n        simp only [lintegral_const, MeasurableSet.univ, Measure.restrict_apply, univ_inter]\n      _ = (t : ℝ≥0∞) ^ (2 : ℤ) * ((t : ℝ≥0∞) ^ (n - 1) * μ (s ∩ f ⁻¹' I)) := by\n        rw [← mul_assoc, ← ENNReal.zpow_add t_ne_zero ENNReal.coe_ne_top]\n        congr 2\n        abel\n      _ ≤ (t : ℝ≥0∞) ^ (2 : ℤ) * ρ (s ∩ f ⁻¹' I) := by\n        gcongr\n        rw [← ENNReal.coe_zpow (zero_lt_one.trans ht).ne']\n        apply v.mul_measure_le_of_subset_lt_limRatioMeas hρ\n        intro x hx\n        apply lt_of_lt_of_le _ hx.2.1\n        rw [← ENNReal.coe_zpow (zero_lt_one.trans ht).ne', ENNReal.coe_lt_coe, sub_eq_add_neg,\n          zpow_add₀ t_ne_zero']\n        conv_rhs => rw [← mul_one (t ^ n)]\n        gcongr\n        rw [zpow_neg_one]\n        exact inv_lt_one_of_one_lt₀ ht\n  calc\n    ν s =\n      ν (s ∩ f ⁻¹' {0}) + ν (s ∩ f ⁻¹' {∞}) +\n        ∑' n : ℤ, ν (s ∩ f ⁻¹' Ico ((t : ℝ≥0∞) ^ n) ((t : ℝ≥0∞) ^ (n + 1))) :=\n      measure_eq_measure_preimage_add_measure_tsum_Ico_zpow ν f_meas hs ht\n    _ ≤\n        ((t : ℝ≥0∞) ^ 2 • ρ :) (s ∩ f ⁻¹' {0}) + ((t : ℝ≥0∞) ^ 2 • ρ :) (s ∩ f ⁻¹' {∞}) +\n          ∑' n : ℤ, ((t : ℝ≥0∞) ^ 2 • ρ :) (s ∩ f ⁻¹' Ico (t ^ n) (t ^ (n + 1))) :=\n      (add_le_add (add_le_add A B) (ENNReal.tsum_le_tsum C))\n    _ = ((t : ℝ≥0∞) ^ 2 • ρ :) s :=\n      (measure_eq_measure_preimage_add_measure_tsum_Ico_zpow ((t : ℝ≥0∞) ^ 2 • ρ) f_meas hs ht).symm\n\n"}
{"name":"VitaliFamily.le_mul_withDensity","module":"Mathlib.MeasureTheory.Covering.Differentiation","initialProofState":"α : Type u_1\ninst✝⁴ : PseudoMetricSpace α\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nv : VitaliFamily μ\ninst✝³ : SecondCountableTopology α\ninst✝² : BorelSpace α\ninst✝¹ : MeasureTheory.IsLocallyFiniteMeasure μ\nρ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.IsLocallyFiniteMeasure ρ\nhρ : ρ.AbsolutelyContinuous μ\ns : Set α\nhs : MeasurableSet s\nt : NNReal\nht : LT.lt 1 t\n⊢ LE.le (ρ s) (HMul.hMul (↑t) ((μ.withDensity (v.limRatioMeas hρ)) s))","decl":"/-- As an intermediate step to show that `μ.withDensity (v.limRatioMeas hρ) = ρ`, we show here\nthat `ρ ≤ t μ.withDensity (v.limRatioMeas hρ)` for any `t > 1`. -/\ntheorem le_mul_withDensity {s : Set α} (hs : MeasurableSet s) {t : ℝ≥0} (ht : 1 < t) :\n    ρ s ≤ t * μ.withDensity (v.limRatioMeas hρ) s := by\n  /- We cut `s` into the sets where `v.limRatioMeas hρ = 0`, where `v.limRatioMeas hρ = ∞`, and\n    where `v.limRatioMeas hρ ∈ [t^n, t^(n+1))` for `n : ℤ`. The first and second have measure `0`.\n    For the latter, since `v.limRatioMeas hρ` fluctuates by at most `t` on this slice, we can use\n    `measure_le_mul_of_subset_limRatioMeas_lt` and `mul_measure_le_of_subset_lt_limRatioMeas` to\n    show that the two measures are comparable up to `t`. -/\n  have t_ne_zero' : t ≠ 0 := (zero_lt_one.trans ht).ne'\n  have t_ne_zero : (t : ℝ≥0∞) ≠ 0 := by simpa only [ENNReal.coe_eq_zero, Ne] using t_ne_zero'\n  let ν := μ.withDensity (v.limRatioMeas hρ)\n  let f := v.limRatioMeas hρ\n  have f_meas : Measurable f := v.limRatioMeas_measurable hρ\n  have A : ρ (s ∩ f ⁻¹' {0}) ≤ (t • ν) (s ∩ f ⁻¹' {0}) := by\n    refine le_trans (measure_mono inter_subset_right) (le_trans (le_of_eq ?_) (zero_le _))\n    exact v.measure_limRatioMeas_zero hρ\n  have B : ρ (s ∩ f ⁻¹' {∞}) ≤ (t • ν) (s ∩ f ⁻¹' {∞}) := by\n    apply le_trans (le_of_eq _) (zero_le _)\n    apply hρ\n    rw [← nonpos_iff_eq_zero]\n    exact (measure_mono inter_subset_right).trans (v.measure_limRatioMeas_top hρ).le\n  have C :\n    ∀ n : ℤ,\n      ρ (s ∩ f ⁻¹' Ico ((t : ℝ≥0∞) ^ n) ((t : ℝ≥0∞) ^ (n + 1))) ≤\n        (t • ν) (s ∩ f ⁻¹' Ico ((t : ℝ≥0∞) ^ n) ((t : ℝ≥0∞) ^ (n + 1))) := by\n    intro n\n    let I := Ico ((t : ℝ≥0∞) ^ n) ((t : ℝ≥0∞) ^ (n + 1))\n    have M : MeasurableSet (s ∩ f ⁻¹' I) := hs.inter (f_meas measurableSet_Ico)\n    simp only [ν, I, M, withDensity_apply, coe_nnreal_smul_apply]\n    calc\n      ρ (s ∩ f ⁻¹' I) ≤ (t : ℝ≥0∞) ^ (n + 1) * μ (s ∩ f ⁻¹' I) := by\n        rw [← ENNReal.coe_zpow t_ne_zero']\n        apply v.measure_le_mul_of_subset_limRatioMeas_lt hρ\n        intro x hx\n        apply hx.2.2.trans_le (le_of_eq _)\n        rw [ENNReal.coe_zpow t_ne_zero']\n      _ = ∫⁻ _ in s ∩ f ⁻¹' I, (t : ℝ≥0∞) ^ (n + 1) ∂μ := by\n        simp only [lintegral_const, MeasurableSet.univ, Measure.restrict_apply, univ_inter]\n      _ ≤ ∫⁻ x in s ∩ f ⁻¹' I, t * f x ∂μ := by\n        apply lintegral_mono_ae ((ae_restrict_iff' M).2 (Eventually.of_forall fun x hx => ?_))\n        rw [add_comm, ENNReal.zpow_add t_ne_zero ENNReal.coe_ne_top, zpow_one]\n        exact mul_le_mul_left' hx.2.1 _\n      _ = t * ∫⁻ x in s ∩ f ⁻¹' I, f x ∂μ := lintegral_const_mul _ f_meas\n  calc\n    ρ s =\n      ρ (s ∩ f ⁻¹' {0}) + ρ (s ∩ f ⁻¹' {∞}) +\n        ∑' n : ℤ, ρ (s ∩ f ⁻¹' Ico ((t : ℝ≥0∞) ^ n) ((t : ℝ≥0∞) ^ (n + 1))) :=\n      measure_eq_measure_preimage_add_measure_tsum_Ico_zpow ρ f_meas hs ht\n    _ ≤\n        (t • ν) (s ∩ f ⁻¹' {0}) + (t • ν) (s ∩ f ⁻¹' {∞}) +\n          ∑' n : ℤ, (t • ν) (s ∩ f ⁻¹' Ico ((t : ℝ≥0∞) ^ n) ((t : ℝ≥0∞) ^ (n + 1))) :=\n      (add_le_add (add_le_add A B) (ENNReal.tsum_le_tsum C))\n    _ = (t • ν) s :=\n      (measure_eq_measure_preimage_add_measure_tsum_Ico_zpow (t • ν) f_meas hs ht).symm\n\n"}
{"name":"VitaliFamily.withDensity_limRatioMeas_eq","module":"Mathlib.MeasureTheory.Covering.Differentiation","initialProofState":"α : Type u_1\ninst✝⁴ : PseudoMetricSpace α\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nv : VitaliFamily μ\ninst✝³ : SecondCountableTopology α\ninst✝² : BorelSpace α\ninst✝¹ : MeasureTheory.IsLocallyFiniteMeasure μ\nρ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.IsLocallyFiniteMeasure ρ\nhρ : ρ.AbsolutelyContinuous μ\n⊢ Eq (μ.withDensity (v.limRatioMeas hρ)) ρ","decl":"theorem withDensity_limRatioMeas_eq : μ.withDensity (v.limRatioMeas hρ) = ρ := by\n  ext1 s hs\n  refine le_antisymm ?_ ?_\n  · have : Tendsto (fun t : ℝ≥0 =>\n        ((t : ℝ≥0∞) ^ 2 * ρ s : ℝ≥0∞)) (𝓝[>] 1) (𝓝 ((1 : ℝ≥0∞) ^ 2 * ρ s)) := by\n      refine ENNReal.Tendsto.mul ?_ ?_ tendsto_const_nhds ?_\n      · exact ENNReal.Tendsto.pow (ENNReal.tendsto_coe.2 nhdsWithin_le_nhds)\n      · simp only [one_pow, ENNReal.coe_one, true_or, Ne, not_false_iff, one_ne_zero]\n      · simp only [one_pow, ENNReal.coe_one, Ne, or_true, ENNReal.one_ne_top, not_false_iff]\n    simp only [one_pow, one_mul, ENNReal.coe_one] at this\n    refine ge_of_tendsto this ?_\n    filter_upwards [self_mem_nhdsWithin] with _ ht\n    exact v.withDensity_le_mul hρ hs ht\n  · have :\n      Tendsto (fun t : ℝ≥0 => (t : ℝ≥0∞) * μ.withDensity (v.limRatioMeas hρ) s) (𝓝[>] 1)\n        (𝓝 ((1 : ℝ≥0∞) * μ.withDensity (v.limRatioMeas hρ) s)) := by\n      refine ENNReal.Tendsto.mul_const (ENNReal.tendsto_coe.2 nhdsWithin_le_nhds) ?_\n      simp only [ENNReal.coe_one, true_or, Ne, not_false_iff, one_ne_zero]\n    simp only [one_mul, ENNReal.coe_one] at this\n    refine ge_of_tendsto this ?_\n    filter_upwards [self_mem_nhdsWithin] with _ ht\n    exact v.le_mul_withDensity hρ hs ht\n\n"}
{"name":"VitaliFamily.ae_tendsto_rnDeriv_of_absolutelyContinuous","module":"Mathlib.MeasureTheory.Covering.Differentiation","initialProofState":"α : Type u_1\ninst✝⁴ : PseudoMetricSpace α\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nv : VitaliFamily μ\ninst✝³ : SecondCountableTopology α\ninst✝² : BorelSpace α\ninst✝¹ : MeasureTheory.IsLocallyFiniteMeasure μ\nρ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.IsLocallyFiniteMeasure ρ\nhρ : ρ.AbsolutelyContinuous μ\n⊢ Filter.Eventually (fun x => Filter.Tendsto (fun a => HDiv.hDiv (ρ a) (μ a)) (v.filterAt x) (nhds (ρ.rnDeriv μ x))) (MeasureTheory.ae μ)","decl":"/-- Weak version of the main theorem on differentiation of measures: given a Vitali family `v`\nfor a locally finite measure `μ`, and another locally finite measure `ρ`, then for `μ`-almost\nevery `x` the ratio `ρ a / μ a` converges, when `a` shrinks to `x` along the Vitali family,\ntowards the Radon-Nikodym derivative of `ρ` with respect to `μ`.\n\nThis version assumes that `ρ` is absolutely continuous with respect to `μ`. The general version\nwithout this superfluous assumption is `VitaliFamily.ae_tendsto_rnDeriv`.\n-/\ntheorem ae_tendsto_rnDeriv_of_absolutelyContinuous :\n    ∀ᵐ x ∂μ, Tendsto (fun a => ρ a / μ a) (v.filterAt x) (𝓝 (ρ.rnDeriv μ x)) := by\n  have A : (μ.withDensity (v.limRatioMeas hρ)).rnDeriv μ =ᵐ[μ] v.limRatioMeas hρ :=\n    rnDeriv_withDensity μ (v.limRatioMeas_measurable hρ)\n  rw [v.withDensity_limRatioMeas_eq hρ] at A\n  filter_upwards [v.ae_tendsto_limRatioMeas hρ, A] with _ _ h'x\n  rwa [h'x]\n\n"}
{"name":"VitaliFamily.ae_tendsto_rnDeriv","module":"Mathlib.MeasureTheory.Covering.Differentiation","initialProofState":"α : Type u_1\ninst✝⁴ : PseudoMetricSpace α\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nv : VitaliFamily μ\ninst✝³ : SecondCountableTopology α\ninst✝² : BorelSpace α\ninst✝¹ : MeasureTheory.IsLocallyFiniteMeasure μ\nρ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.IsLocallyFiniteMeasure ρ\n⊢ Filter.Eventually (fun x => Filter.Tendsto (fun a => HDiv.hDiv (ρ a) (μ a)) (v.filterAt x) (nhds (ρ.rnDeriv μ x))) (MeasureTheory.ae μ)","decl":"/-- Main theorem on differentiation of measures: given a Vitali family `v` for a locally finite\nmeasure `μ`, and another locally finite measure `ρ`, then for `μ`-almost every `x` the\nratio `ρ a / μ a` converges, when `a` shrinks to `x` along the Vitali family, towards the\nRadon-Nikodym derivative of `ρ` with respect to `μ`. -/\ntheorem ae_tendsto_rnDeriv :\n    ∀ᵐ x ∂μ, Tendsto (fun a => ρ a / μ a) (v.filterAt x) (𝓝 (ρ.rnDeriv μ x)) := by\n  let t := μ.withDensity (ρ.rnDeriv μ)\n  have eq_add : ρ = ρ.singularPart μ + t := haveLebesgueDecomposition_add _ _\n  have A : ∀ᵐ x ∂μ, Tendsto (fun a => ρ.singularPart μ a / μ a) (v.filterAt x) (𝓝 0) :=\n    v.ae_eventually_measure_zero_of_singular (mutuallySingular_singularPart ρ μ)\n  have B : ∀ᵐ x ∂μ, t.rnDeriv μ x = ρ.rnDeriv μ x :=\n    rnDeriv_withDensity μ (measurable_rnDeriv ρ μ)\n  have C : ∀ᵐ x ∂μ, Tendsto (fun a => t a / μ a) (v.filterAt x) (𝓝 (t.rnDeriv μ x)) :=\n    v.ae_tendsto_rnDeriv_of_absolutelyContinuous (withDensity_absolutelyContinuous _ _)\n  filter_upwards [A, B, C] with _ Ax Bx Cx\n  convert Ax.add Cx using 1\n  · ext1 a\n    conv_lhs => rw [eq_add]\n    simp only [Pi.add_apply, coe_add, ENNReal.add_div]\n  · simp only [Bx, zero_add]\n\n"}
{"name":"VitaliFamily.ae_tendsto_measure_inter_div_of_measurableSet","module":"Mathlib.MeasureTheory.Covering.Differentiation","initialProofState":"α : Type u_1\ninst✝³ : PseudoMetricSpace α\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nv : VitaliFamily μ\ninst✝² : SecondCountableTopology α\ninst✝¹ : BorelSpace α\ninst✝ : MeasureTheory.IsLocallyFiniteMeasure μ\ns : Set α\nhs : MeasurableSet s\n⊢ Filter.Eventually (fun x => Filter.Tendsto (fun a => HDiv.hDiv (μ (Inter.inter s a)) (μ a)) (v.filterAt x) (nhds (s.indicator 1 x))) (MeasureTheory.ae μ)","decl":"/-- Given a measurable set `s`, then `μ (s ∩ a) / μ a` converges when `a` shrinks to a typical\npoint `x` along a Vitali family. The limit is `1` for `x ∈ s` and `0` for `x ∉ s`. This shows that\nalmost every point of `s` is a Lebesgue density point for `s`. A version for non-measurable sets\nholds, but it only gives the first conclusion, see `ae_tendsto_measure_inter_div`. -/\ntheorem ae_tendsto_measure_inter_div_of_measurableSet {s : Set α} (hs : MeasurableSet s) :\n    ∀ᵐ x ∂μ, Tendsto (fun a => μ (s ∩ a) / μ a) (v.filterAt x) (𝓝 (s.indicator 1 x)) := by\n  haveI : IsLocallyFiniteMeasure (μ.restrict s) :=\n    isLocallyFiniteMeasure_of_le restrict_le_self\n  filter_upwards [ae_tendsto_rnDeriv v (μ.restrict s), rnDeriv_restrict_self μ hs]\n  intro x hx h'x\n  simpa only [h'x, restrict_apply' hs, inter_comm] using hx\n\n"}
{"name":"VitaliFamily.ae_tendsto_measure_inter_div","module":"Mathlib.MeasureTheory.Covering.Differentiation","initialProofState":"α : Type u_1\ninst✝³ : PseudoMetricSpace α\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nv : VitaliFamily μ\ninst✝² : SecondCountableTopology α\ninst✝¹ : BorelSpace α\ninst✝ : MeasureTheory.IsLocallyFiniteMeasure μ\ns : Set α\n⊢ Filter.Eventually (fun x => Filter.Tendsto (fun a => HDiv.hDiv (μ (Inter.inter s a)) (μ a)) (v.filterAt x) (nhds 1)) (MeasureTheory.ae (μ.restrict s))","decl":"/-- Given an arbitrary set `s`, then `μ (s ∩ a) / μ a` converges to `1` when `a` shrinks to a\ntypical point of `s` along a Vitali family. This shows that almost every point of `s` is a\nLebesgue density point for `s`. A stronger version for measurable sets is given\nin `ae_tendsto_measure_inter_div_of_measurableSet`. -/\ntheorem ae_tendsto_measure_inter_div (s : Set α) :\n    ∀ᵐ x ∂μ.restrict s, Tendsto (fun a => μ (s ∩ a) / μ a) (v.filterAt x) (𝓝 1) := by\n  let t := toMeasurable μ s\n  have A :\n    ∀ᵐ x ∂μ.restrict s,\n      Tendsto (fun a => μ (t ∩ a) / μ a) (v.filterAt x) (𝓝 (t.indicator 1 x)) := by\n    apply ae_mono restrict_le_self\n    apply ae_tendsto_measure_inter_div_of_measurableSet\n    exact measurableSet_toMeasurable _ _\n  have B : ∀ᵐ x ∂μ.restrict s, t.indicator 1 x = (1 : ℝ≥0∞) := by\n    refine ae_restrict_of_ae_restrict_of_subset (subset_toMeasurable μ s) ?_\n    filter_upwards [ae_restrict_mem (measurableSet_toMeasurable μ s)] with _ hx\n    simp only [t, hx, Pi.one_apply, indicator_of_mem]\n  filter_upwards [A, B] with x hx h'x\n  rw [h'x] at hx\n  apply hx.congr' _\n  filter_upwards [v.eventually_filterAt_measurableSet x] with _ ha\n  congr 1\n  exact measure_toMeasurable_inter_of_sFinite ha _\n\n"}
{"name":"VitaliFamily.ae_tendsto_lintegral_div'","module":"Mathlib.MeasureTheory.Covering.Differentiation","initialProofState":"α : Type u_1\ninst✝³ : PseudoMetricSpace α\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nv : VitaliFamily μ\ninst✝² : SecondCountableTopology α\ninst✝¹ : BorelSpace α\ninst✝ : MeasureTheory.IsLocallyFiniteMeasure μ\nf : α → ENNReal\nhf : Measurable f\nh'f : Ne (MeasureTheory.lintegral μ fun y => f y) Top.top\n⊢ Filter.Eventually (fun x => Filter.Tendsto (fun a => HDiv.hDiv (MeasureTheory.lintegral (μ.restrict a) fun y => f y) (μ a)) (v.filterAt x) (nhds (f x))) (MeasureTheory.ae μ)","decl":"theorem ae_tendsto_lintegral_div' {f : α → ℝ≥0∞} (hf : Measurable f) (h'f : (∫⁻ y, f y ∂μ) ≠ ∞) :\n    ∀ᵐ x ∂μ, Tendsto (fun a => (∫⁻ y in a, f y ∂μ) / μ a) (v.filterAt x) (𝓝 (f x)) := by\n  let ρ := μ.withDensity f\n  have : IsFiniteMeasure ρ := isFiniteMeasure_withDensity h'f\n  filter_upwards [ae_tendsto_rnDeriv v ρ, rnDeriv_withDensity μ hf] with x hx h'x\n  rw [← h'x]\n  apply hx.congr' _\n  filter_upwards [v.eventually_filterAt_measurableSet x] with a ha\n  rw [← withDensity_apply f ha]\n\n"}
{"name":"VitaliFamily.ae_tendsto_lintegral_div","module":"Mathlib.MeasureTheory.Covering.Differentiation","initialProofState":"α : Type u_1\ninst✝³ : PseudoMetricSpace α\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nv : VitaliFamily μ\ninst✝² : SecondCountableTopology α\ninst✝¹ : BorelSpace α\ninst✝ : MeasureTheory.IsLocallyFiniteMeasure μ\nf : α → ENNReal\nhf : AEMeasurable f μ\nh'f : Ne (MeasureTheory.lintegral μ fun y => f y) Top.top\n⊢ Filter.Eventually (fun x => Filter.Tendsto (fun a => HDiv.hDiv (MeasureTheory.lintegral (μ.restrict a) fun y => f y) (μ a)) (v.filterAt x) (nhds (f x))) (MeasureTheory.ae μ)","decl":"theorem ae_tendsto_lintegral_div {f : α → ℝ≥0∞} (hf : AEMeasurable f μ) (h'f : (∫⁻ y, f y ∂μ) ≠ ∞) :\n    ∀ᵐ x ∂μ, Tendsto (fun a => (∫⁻ y in a, f y ∂μ) / μ a) (v.filterAt x) (𝓝 (f x)) := by\n  have A : (∫⁻ y, hf.mk f y ∂μ) ≠ ∞ := by\n    convert h'f using 1\n    apply lintegral_congr_ae\n    exact hf.ae_eq_mk.symm\n  filter_upwards [v.ae_tendsto_lintegral_div' hf.measurable_mk A, hf.ae_eq_mk] with x hx h'x\n  rw [h'x]\n  convert hx using 1\n  ext1 a\n  congr 1\n  apply lintegral_congr_ae\n  exact ae_restrict_of_ae hf.ae_eq_mk\n\n"}
{"name":"VitaliFamily.ae_tendsto_lintegral_enorm_sub_div'_of_integrable","module":"Mathlib.MeasureTheory.Covering.Differentiation","initialProofState":"α : Type u_1\ninst✝⁴ : PseudoMetricSpace α\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nv : VitaliFamily μ\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : SecondCountableTopology α\ninst✝¹ : BorelSpace α\ninst✝ : MeasureTheory.IsLocallyFiniteMeasure μ\nf : α → E\nhf : MeasureTheory.Integrable f μ\nh'f : MeasureTheory.StronglyMeasurable f\n⊢ Filter.Eventually (fun x => Filter.Tendsto (fun a => HDiv.hDiv (MeasureTheory.lintegral (μ.restrict a) fun y => ENorm.enorm (HSub.hSub (f y) (f x))) (μ a)) (v.filterAt x) (nhds 0)) (MeasureTheory.ae μ)","decl":"theorem ae_tendsto_lintegral_enorm_sub_div'_of_integrable {f : α → E} (hf : Integrable f μ)\n    (h'f : StronglyMeasurable f) :\n    ∀ᵐ x ∂μ, Tendsto (fun a => (∫⁻ y in a, ‖f y - f x‖ₑ ∂μ) / μ a) (v.filterAt x) (𝓝 0) := by\n  /- For every `c`, then `(∫⁻ y in a, ‖f y - c‖ₑ ∂μ) / μ a` tends almost everywhere to `‖f x - c‖`.\n    We apply this to a countable set of `c` which is dense in the range of `f`, to deduce the\n    desired convergence.\n    A minor technical inconvenience is that constants are not integrable, so to apply previous\n    lemmas we need to replace `c` with the restriction of `c` to a finite measure set `A n` in the\n    above sketch. -/\n  let A := MeasureTheory.Measure.finiteSpanningSetsInOpen' μ\n  rcases h'f.isSeparable_range with ⟨t, t_count, ht⟩\n  have main :\n    ∀ᵐ x ∂μ,\n      ∀ᵉ (n : ℕ) (c ∈ t),\n        Tendsto (fun a => (∫⁻ y in a, ‖f y - (A.set n).indicator (fun _ => c) y‖ₑ ∂μ) / μ a)\n          (v.filterAt x) (𝓝 ‖f x - (A.set n).indicator (fun _ => c) x‖ₑ) := by\n    #adaptation_note /-- 2024-04-23\n    The next two lines were previously just `simp_rw [ae_all_iff, ae_ball_iff t_count]`. -/\n    simp_rw [ae_all_iff]\n    intro x; rw [ae_ball_iff t_count]; revert x\n    intro n c _\n    apply ae_tendsto_lintegral_div'\n    · refine (h'f.sub ?_).enorm\n      exact stronglyMeasurable_const.indicator (IsOpen.measurableSet (A.set_mem n))\n    · apply ne_of_lt\n      calc\n        ∫⁻ y, ‖f y - (A.set n).indicator (fun _ : α => c) y‖ₑ ∂μ\n          ≤ ∫⁻ y, ‖f y‖ₑ + ‖(A.set n).indicator (fun _ : α => c) y‖ₑ ∂μ :=\n          lintegral_mono fun x ↦ enorm_sub_le\n        _ = ∫⁻ y, ‖f y‖ₑ ∂μ + ∫⁻ y, ‖(A.set n).indicator (fun _ : α => c) y‖ₑ ∂μ :=\n          lintegral_add_left h'f.enorm _\n        _ < ∞ + ∞ :=\n          haveI I : Integrable ((A.set n).indicator fun _ : α => c) μ := by\n            simp only [integrable_indicator_iff (IsOpen.measurableSet (A.set_mem n)),\n              integrableOn_const, A.finite n, or_true]\n          ENNReal.add_lt_add hf.2 I.2\n  filter_upwards [main, v.ae_eventually_measure_pos] with x hx h'x\n  have M c (hc : c ∈ t) :\n      Tendsto (fun a => (∫⁻ y in a, ‖f y - c‖ₑ ∂μ) / μ a) (v.filterAt x) (𝓝 ‖f x - c‖ₑ) := by\n    obtain ⟨n, xn⟩ : ∃ n, x ∈ A.set n := by simpa [← A.spanning] using mem_univ x\n    specialize hx n c hc\n    simp only [xn, indicator_of_mem] at hx\n    apply hx.congr' _\n    filter_upwards [v.eventually_filterAt_subset_of_nhds (IsOpen.mem_nhds (A.set_mem n) xn),\n      v.eventually_filterAt_measurableSet x] with a ha h'a\n    congr 1\n    apply setLIntegral_congr_fun h'a\n    filter_upwards with y hy using (by simp only [ha hy, indicator_of_mem])\n  apply ENNReal.tendsto_nhds_zero.2 fun ε εpos => ?_\n  obtain ⟨c, ct, xc⟩ : ∃ c ∈ t, ‖f x - c‖ₑ < ε / 2 := by\n    simp_rw [← edist_eq_enorm_sub]\n    have : f x ∈ closure t := ht (mem_range_self _)\n    exact EMetric.mem_closure_iff.1 this (ε / 2) (ENNReal.half_pos (ne_of_gt εpos))\n  filter_upwards [(tendsto_order.1 (M c ct)).2 (ε / 2) xc, h'x, v.eventually_measure_lt_top x] with\n    a ha h'a h''a\n  apply ENNReal.div_le_of_le_mul\n  calc\n    (∫⁻ y in a, ‖f y - f x‖ₑ ∂μ) ≤ ∫⁻ y in a, ‖f y - c‖ₑ + ‖f x - c‖ₑ ∂μ := by\n      apply lintegral_mono fun x => ?_\n      simpa only [← edist_eq_enorm_sub] using edist_triangle_right _ _ _\n    _ = (∫⁻ y in a, ‖f y - c‖ₑ ∂μ) + ∫⁻ _ in a, ‖f x - c‖ₑ ∂μ :=\n      (lintegral_add_right _ measurable_const)\n    _ ≤ ε / 2 * μ a + ε / 2 * μ a := by\n      gcongr\n      · rw [ENNReal.div_lt_iff (Or.inl h'a.ne') (Or.inl h''a.ne)] at ha\n        exact ha.le\n      · simp only [lintegral_const, Measure.restrict_apply, MeasurableSet.univ, univ_inter]\n        gcongr\n    _ = ε * μ a := by rw [← add_mul, ENNReal.add_halves]\n\n"}
{"name":"VitaliFamily.ae_tendsto_lintegral_nnnorm_sub_div'_of_integrable","module":"Mathlib.MeasureTheory.Covering.Differentiation","initialProofState":"α : Type u_1\ninst✝⁴ : PseudoMetricSpace α\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nv : VitaliFamily μ\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : SecondCountableTopology α\ninst✝¹ : BorelSpace α\ninst✝ : MeasureTheory.IsLocallyFiniteMeasure μ\nf : α → E\nhf : MeasureTheory.Integrable f μ\nh'f : MeasureTheory.StronglyMeasurable f\n⊢ Filter.Eventually (fun x => Filter.Tendsto (fun a => HDiv.hDiv (MeasureTheory.lintegral (μ.restrict a) fun y => ENorm.enorm (HSub.hSub (f y) (f x))) (μ a)) (v.filterAt x) (nhds 0)) (MeasureTheory.ae μ)","decl":"@[deprecated (since := \"2025-01-22\")]\nalias ae_tendsto_lintegral_nnnorm_sub_div'_of_integrable :=\n  ae_tendsto_lintegral_enorm_sub_div'_of_integrable\n\n"}
{"name":"VitaliFamily.ae_tendsto_lintegral_enorm_sub_div_of_integrable","module":"Mathlib.MeasureTheory.Covering.Differentiation","initialProofState":"α : Type u_1\ninst✝⁴ : PseudoMetricSpace α\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nv : VitaliFamily μ\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : SecondCountableTopology α\ninst✝¹ : BorelSpace α\ninst✝ : MeasureTheory.IsLocallyFiniteMeasure μ\nf : α → E\nhf : MeasureTheory.Integrable f μ\n⊢ Filter.Eventually (fun x => Filter.Tendsto (fun a => HDiv.hDiv (MeasureTheory.lintegral (μ.restrict a) fun y => ENorm.enorm (HSub.hSub (f y) (f x))) (μ a)) (v.filterAt x) (nhds 0)) (MeasureTheory.ae μ)","decl":"theorem ae_tendsto_lintegral_enorm_sub_div_of_integrable {f : α → E} (hf : Integrable f μ) :\n    ∀ᵐ x ∂μ, Tendsto (fun a => (∫⁻ y in a, ‖f y - f x‖ₑ ∂μ) / μ a) (v.filterAt x) (𝓝 0) := by\n  have I : Integrable (hf.1.mk f) μ := hf.congr hf.1.ae_eq_mk\n  filter_upwards [v.ae_tendsto_lintegral_enorm_sub_div'_of_integrable I hf.1.stronglyMeasurable_mk,\n    hf.1.ae_eq_mk] with x hx h'x\n  apply hx.congr _\n  intro a\n  congr 1\n  apply lintegral_congr_ae\n  apply ae_restrict_of_ae\n  filter_upwards [hf.1.ae_eq_mk] with y hy\n  rw [hy, h'x]\n\n"}
{"name":"VitaliFamily.ae_tendsto_lintegral_nnnorm_sub_div_of_integrable","module":"Mathlib.MeasureTheory.Covering.Differentiation","initialProofState":"α : Type u_1\ninst✝⁴ : PseudoMetricSpace α\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nv : VitaliFamily μ\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : SecondCountableTopology α\ninst✝¹ : BorelSpace α\ninst✝ : MeasureTheory.IsLocallyFiniteMeasure μ\nf : α → E\nhf : MeasureTheory.Integrable f μ\n⊢ Filter.Eventually (fun x => Filter.Tendsto (fun a => HDiv.hDiv (MeasureTheory.lintegral (μ.restrict a) fun y => ENorm.enorm (HSub.hSub (f y) (f x))) (μ a)) (v.filterAt x) (nhds 0)) (MeasureTheory.ae μ)","decl":"@[deprecated (since := \"2025-01-22\")]\nalias ae_tendsto_lintegral_nnnorm_sub_div_of_integrable :=\n  ae_tendsto_lintegral_enorm_sub_div_of_integrable\n\n"}
{"name":"VitaliFamily.ae_tendsto_lintegral_enorm_sub_div","module":"Mathlib.MeasureTheory.Covering.Differentiation","initialProofState":"α : Type u_1\ninst✝⁴ : PseudoMetricSpace α\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nv : VitaliFamily μ\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : SecondCountableTopology α\ninst✝¹ : BorelSpace α\ninst✝ : MeasureTheory.IsLocallyFiniteMeasure μ\nf : α → E\nhf : MeasureTheory.LocallyIntegrable f μ\n⊢ Filter.Eventually (fun x => Filter.Tendsto (fun a => HDiv.hDiv (MeasureTheory.lintegral (μ.restrict a) fun y => ENorm.enorm (HSub.hSub (f y) (f x))) (μ a)) (v.filterAt x) (nhds 0)) (MeasureTheory.ae μ)","decl":"theorem ae_tendsto_lintegral_enorm_sub_div {f : α → E} (hf : LocallyIntegrable f μ) :\n    ∀ᵐ x ∂μ, Tendsto (fun a => (∫⁻ y in a, ‖f y - f x‖ₑ ∂μ) / μ a) (v.filterAt x) (𝓝 0) := by\n  rcases hf.exists_nat_integrableOn with ⟨u, u_open, u_univ, hu⟩\n  have : ∀ n, ∀ᵐ x ∂μ,\n      Tendsto (fun a => (∫⁻ y in a, ‖(u n).indicator f y - (u n).indicator f x‖ₑ ∂μ) / μ a)\n      (v.filterAt x) (𝓝 0) := by\n    intro n\n    apply ae_tendsto_lintegral_enorm_sub_div_of_integrable\n    exact (integrable_indicator_iff (u_open n).measurableSet).2 (hu n)\n  filter_upwards [ae_all_iff.2 this] with x hx\n  obtain ⟨n, hn⟩ : ∃ n, x ∈ u n := by simpa only [← u_univ, mem_iUnion] using mem_univ x\n  apply Tendsto.congr' _ (hx n)\n  filter_upwards [v.eventually_filterAt_subset_of_nhds ((u_open n).mem_nhds hn),\n    v.eventually_filterAt_measurableSet x] with a ha h'a\n  congr 1\n  refine setLIntegral_congr_fun h'a (Eventually.of_forall (fun y hy ↦ ?_))\n  rw [indicator_of_mem (ha hy) f, indicator_of_mem hn f]\n\n"}
{"name":"VitaliFamily.ae_tendsto_lintegral_nnnorm_sub_div","module":"Mathlib.MeasureTheory.Covering.Differentiation","initialProofState":"α : Type u_1\ninst✝⁴ : PseudoMetricSpace α\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nv : VitaliFamily μ\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : SecondCountableTopology α\ninst✝¹ : BorelSpace α\ninst✝ : MeasureTheory.IsLocallyFiniteMeasure μ\nf : α → E\nhf : MeasureTheory.LocallyIntegrable f μ\n⊢ Filter.Eventually (fun x => Filter.Tendsto (fun a => HDiv.hDiv (MeasureTheory.lintegral (μ.restrict a) fun y => ENorm.enorm (HSub.hSub (f y) (f x))) (μ a)) (v.filterAt x) (nhds 0)) (MeasureTheory.ae μ)","decl":"@[deprecated (since := \"2025-01-22\")]\nalias ae_tendsto_lintegral_nnnorm_sub_div := ae_tendsto_lintegral_enorm_sub_div\n\n"}
{"name":"VitaliFamily.ae_tendsto_average_norm_sub","module":"Mathlib.MeasureTheory.Covering.Differentiation","initialProofState":"α : Type u_1\ninst✝⁴ : PseudoMetricSpace α\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nv : VitaliFamily μ\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : SecondCountableTopology α\ninst✝¹ : BorelSpace α\ninst✝ : MeasureTheory.IsLocallyFiniteMeasure μ\nf : α → E\nhf : MeasureTheory.LocallyIntegrable f μ\n⊢ Filter.Eventually (fun x => Filter.Tendsto (fun a => MeasureTheory.average (μ.restrict a) fun y => Norm.norm (HSub.hSub (f y) (f x))) (v.filterAt x) (nhds 0)) (MeasureTheory.ae μ)","decl":"/-- *Lebesgue differentiation theorem*: for almost every point `x`, the\naverage of `‖f y - f x‖` on `a` tends to `0` as `a` shrinks to `x` along a Vitali family. -/\ntheorem ae_tendsto_average_norm_sub {f : α → E} (hf : LocallyIntegrable f μ) :\n    ∀ᵐ x ∂μ, Tendsto (fun a => ⨍ y in a, ‖f y - f x‖ ∂μ) (v.filterAt x) (𝓝 0) := by\n  filter_upwards [v.ae_tendsto_lintegral_enorm_sub_div hf] with x hx\n  have := (ENNReal.tendsto_toReal ENNReal.zero_ne_top).comp hx\n  simp only [ENNReal.zero_toReal] at this\n  apply Tendsto.congr' _ this\n  filter_upwards [v.eventually_measure_lt_top x, v.eventually_filterAt_integrableOn x hf]\n    with a h'a h''a\n  simp only [Function.comp_apply, ENNReal.toReal_div, setAverage_eq, div_eq_inv_mul]\n  have A : IntegrableOn (fun y => (‖f y - f x‖₊ : ℝ)) a μ := by\n    simp_rw [coe_nnnorm]\n    exact (h''a.sub (integrableOn_const.2 (Or.inr h'a))).norm\n  dsimp [enorm]\n  rw [lintegral_coe_eq_integral _ A, ENNReal.toReal_ofReal (by positivity)]\n  simp only [coe_nnnorm, smul_eq_mul]\n\n"}
{"name":"VitaliFamily.ae_tendsto_average","module":"Mathlib.MeasureTheory.Covering.Differentiation","initialProofState":"α : Type u_1\ninst✝⁶ : PseudoMetricSpace α\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nv : VitaliFamily μ\nE : Type u_2\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : SecondCountableTopology α\ninst✝³ : BorelSpace α\ninst✝² : MeasureTheory.IsLocallyFiniteMeasure μ\ninst✝¹ : NormedSpace Real E\ninst✝ : CompleteSpace E\nf : α → E\nhf : MeasureTheory.LocallyIntegrable f μ\n⊢ Filter.Eventually (fun x => Filter.Tendsto (fun a => MeasureTheory.average (μ.restrict a) fun y => f y) (v.filterAt x) (nhds (f x))) (MeasureTheory.ae μ)","decl":"/-- *Lebesgue differentiation theorem*: for almost every point `x`, the\naverage of `f` on `a` tends to `f x` as `a` shrinks to `x` along a Vitali family. -/\ntheorem ae_tendsto_average [NormedSpace ℝ E] [CompleteSpace E] {f : α → E}\n    (hf : LocallyIntegrable f μ) :\n    ∀ᵐ x ∂μ, Tendsto (fun a => ⨍ y in a, f y ∂μ) (v.filterAt x) (𝓝 (f x)) := by\n  filter_upwards [v.ae_tendsto_average_norm_sub hf, v.ae_eventually_measure_pos] with x hx h'x\n  rw [tendsto_iff_norm_sub_tendsto_zero]\n  refine squeeze_zero' (Eventually.of_forall fun a => norm_nonneg _) ?_ hx\n  filter_upwards [h'x, v.eventually_measure_lt_top x, v.eventually_filterAt_integrableOn x hf]\n    with a ha h'a h''a\n  nth_rw 1 [← setAverage_const ha.ne' h'a.ne (f x)]\n  simp_rw [setAverage_eq']\n  rw [← integral_sub]\n  · exact norm_integral_le_integral_norm _\n  · exact (integrable_inv_smul_measure ha.ne' h'a.ne).2 h''a\n  · exact (integrable_inv_smul_measure ha.ne' h'a.ne).2 (integrableOn_const.2 (Or.inr h'a))\n\n"}
