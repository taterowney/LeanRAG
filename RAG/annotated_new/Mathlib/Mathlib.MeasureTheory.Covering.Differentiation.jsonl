{"name":"VitaliFamily.ae_eventually_measure_pos","module":"Mathlib.MeasureTheory.Covering.Differentiation","initialProofState":"Î± : Type u_1\ninstâœÂ¹ : PseudoMetricSpace Î±\nm0 : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nv : VitaliFamily Î¼\ninstâœ : SecondCountableTopology Î±\nâŠ¢ Filter.Eventually (fun x => Filter.Eventually (fun a => LT.lt 0 (Î¼ a)) (v.filterAt x)) (MeasureTheory.ae Î¼)","decl":"/-- For almost every point `x`, sufficiently small sets in a Vitali family around `x` have positive\nmeasure. (This is a nontrivial result, following from the covering property of Vitali families). -/\ntheorem ae_eventually_measure_pos [SecondCountableTopology Î±] :\n    âˆ€áµ x âˆ‚Î¼, âˆ€á¶  a in v.filterAt x, 0 < Î¼ a := by\n  set s := {x | Â¬âˆ€á¶  a in v.filterAt x, 0 < Î¼ a} with hs\n  simp (config := { zeta := false }) only [not_lt, not_eventually, nonpos_iff_eq_zero] at hs\n  change Î¼ s = 0\n  let f : Î± â†’ Set (Set Î±) := fun _ => {a | Î¼ a = 0}\n  have h : v.FineSubfamilyOn f s := by\n    intro x hx Îµ Îµpos\n    rw [hs] at hx\n    simp only [frequently_filterAt_iff, exists_prop, gt_iff_lt, mem_setOf_eq] at hx\n    rcases hx Îµ Îµpos with âŸ¨a, a_sets, ax, Î¼aâŸ©\n    exact âŸ¨a, âŸ¨a_sets, Î¼aâŸ©, axâŸ©\n  refine le_antisymm ?_ bot_le\n  calc\n    Î¼ s â‰¤ âˆ‘' x : h.index, Î¼ (h.covering x) := h.measure_le_tsum\n    _ = âˆ‘' x : h.index, 0 := by congr; ext1 x; exact h.covering_mem x.2\n    _ = 0 := by simp only [tsum_zero, add_zero]\n\n"}
{"name":"VitaliFamily.eventually_measure_lt_top","module":"Mathlib.MeasureTheory.Covering.Differentiation","initialProofState":"Î± : Type u_1\ninstâœÂ¹ : PseudoMetricSpace Î±\nm0 : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nv : VitaliFamily Î¼\ninstâœ : MeasureTheory.IsLocallyFiniteMeasure Î¼\nx : Î±\nâŠ¢ Filter.Eventually (fun a => LT.lt (Î¼ a) Top.top) (v.filterAt x)","decl":"/-- For every point `x`, sufficiently small sets in a Vitali family around `x` have finite measure.\n(This is a trivial result, following from the fact that the measure is locally finite). -/\ntheorem eventually_measure_lt_top [IsLocallyFiniteMeasure Î¼] (x : Î±) :\n    âˆ€á¶  a in v.filterAt x, Î¼ a < âˆ :=\n  (Î¼.finiteAt_nhds x).eventually.filter_mono inf_le_left\n\n"}
{"name":"VitaliFamily.measure_le_of_frequently_le","module":"Mathlib.MeasureTheory.Covering.Differentiation","initialProofState":"Î± : Type u_1\ninstâœÂ³ : PseudoMetricSpace Î±\nm0 : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nv : VitaliFamily Î¼\ninstâœÂ² : SecondCountableTopology Î±\ninstâœÂ¹ : BorelSpace Î±\nÏ Î½ : MeasureTheory.Measure Î±\ninstâœ : MeasureTheory.IsLocallyFiniteMeasure Î½\nhÏ : Ï.AbsolutelyContinuous Î¼\ns : Set Î±\nhs : âˆ€ (x : Î±), Membership.mem s x â†’ Filter.Frequently (fun a => LE.le (Ï a) (Î½ a)) (v.filterAt x)\nâŠ¢ LE.le (Ï s) (Î½ s)","decl":"/-- If two measures `Ï` and `Î½` have, at every point of a set `s`, arbitrarily small sets in a\nVitali family satisfying `Ï a â‰¤ Î½ a`, then `Ï s â‰¤ Î½ s` if `Ï â‰ª Î¼`. -/\ntheorem measure_le_of_frequently_le [SecondCountableTopology Î±] [BorelSpace Î±] {Ï : Measure Î±}\n    (Î½ : Measure Î±) [IsLocallyFiniteMeasure Î½] (hÏ : Ï â‰ª Î¼) (s : Set Î±)\n    (hs : âˆ€ x âˆˆ s, âˆƒá¶  a in v.filterAt x, Ï a â‰¤ Î½ a) : Ï s â‰¤ Î½ s := by\n  -- this follows from a covering argument using the sets satisfying `Ï a â‰¤ Î½ a`.\n  apply ENNReal.le_of_forall_pos_le_add fun Îµ Îµpos _ => ?_\n  obtain âŸ¨U, sU, U_open, Î½UâŸ© : âˆƒ (U : Set Î±), s âŠ† U âˆ§ IsOpen U âˆ§ Î½ U â‰¤ Î½ s + Îµ :=\n    exists_isOpen_le_add s Î½ (ENNReal.coe_pos.2 Îµpos).ne'\n  let f : Î± â†’ Set (Set Î±) := fun _ => {a | Ï a â‰¤ Î½ a âˆ§ a âŠ† U}\n  have h : v.FineSubfamilyOn f s := by\n    apply v.fineSubfamilyOn_of_frequently f s fun x hx => ?_\n    have :=\n      (hs x hx).and_eventually\n        ((v.eventually_filterAt_mem_setsAt x).and\n          (v.eventually_filterAt_subset_of_nhds (U_open.mem_nhds (sU hx))))\n    apply Frequently.mono this\n    rintro a âŸ¨Ïa, _, aUâŸ©\n    exact âŸ¨Ïa, aUâŸ©\n  haveI : Encodable h.index := h.index_countable.toEncodable\n  calc\n    Ï s â‰¤ âˆ‘' x : h.index, Ï (h.covering x) := h.measure_le_tsum_of_absolutelyContinuous hÏ\n    _ â‰¤ âˆ‘' x : h.index, Î½ (h.covering x) := ENNReal.tsum_le_tsum fun x => (h.covering_mem x.2).1\n    _ = Î½ (â‹ƒ x : h.index, h.covering x) := by\n      rw [measure_iUnion h.covering_disjoint_subtype fun i => h.measurableSet_u i.2]\n    _ â‰¤ Î½ U := (measure_mono (iUnion_subset fun i => (h.covering_mem i.2).2))\n    _ â‰¤ Î½ s + Îµ := Î½U\n\n"}
{"name":"VitaliFamily.eventually_filterAt_integrableOn","module":"Mathlib.MeasureTheory.Covering.Differentiation","initialProofState":"Î± : Type u_1\ninstâœÂ¹ : PseudoMetricSpace Î±\nm0 : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nv : VitaliFamily Î¼\nE : Type u_2\ninstâœ : NormedAddCommGroup E\nx : Î±\nf : Î± â†’ E\nhf : MeasureTheory.LocallyIntegrable f Î¼\nâŠ¢ Filter.Eventually (fun a => MeasureTheory.IntegrableOn f a Î¼) (v.filterAt x)","decl":"theorem eventually_filterAt_integrableOn (x : Î±) {f : Î± â†’ E} (hf : LocallyIntegrable f Î¼) :\n    âˆ€á¶  a in v.filterAt x, IntegrableOn f a Î¼ := by\n  rcases hf x with âŸ¨w, w_nhds, hwâŸ©\n  filter_upwards [v.eventually_filterAt_subset_of_nhds w_nhds] with a ha\n  exact hw.mono_set ha\n\n"}
{"name":"VitaliFamily.ae_eventually_measure_zero_of_singular","module":"Mathlib.MeasureTheory.Covering.Differentiation","initialProofState":"Î± : Type u_1\ninstâœâ´ : PseudoMetricSpace Î±\nm0 : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nv : VitaliFamily Î¼\ninstâœÂ³ : SecondCountableTopology Î±\ninstâœÂ² : BorelSpace Î±\ninstâœÂ¹ : MeasureTheory.IsLocallyFiniteMeasure Î¼\nÏ : MeasureTheory.Measure Î±\ninstâœ : MeasureTheory.IsLocallyFiniteMeasure Ï\nhÏ : Ï.MutuallySingular Î¼\nâŠ¢ Filter.Eventually (fun x => Filter.Tendsto (fun a => HDiv.hDiv (Ï a) (Î¼ a)) (v.filterAt x) (nhds 0)) (MeasureTheory.ae Î¼)","decl":"/-- If a measure `Ï` is singular with respect to `Î¼`, then for `Î¼` almost every `x`, the ratio\n`Ï a / Î¼ a` tends to zero when `a` shrinks to `x` along the Vitali family. This makes sense\nas `Î¼ a` is eventually positive by `ae_eventually_measure_pos`. -/\ntheorem ae_eventually_measure_zero_of_singular (hÏ : Ï âŸ‚â‚˜ Î¼) :\n    âˆ€áµ x âˆ‚Î¼, Tendsto (fun a => Ï a / Î¼ a) (v.filterAt x) (ğ“ 0) := by\n  have A : âˆ€ Îµ > (0 : â„â‰¥0), âˆ€áµ x âˆ‚Î¼, âˆ€á¶  a in v.filterAt x, Ï a < Îµ * Î¼ a := by\n    intro Îµ Îµpos\n    set s := {x | Â¬âˆ€á¶  a in v.filterAt x, Ï a < Îµ * Î¼ a} with hs\n    change Î¼ s = 0\n    obtain âŸ¨o, _, Ïo, Î¼oâŸ© : âˆƒ o : Set Î±, MeasurableSet o âˆ§ Ï o = 0 âˆ§ Î¼ oá¶œ = 0 := hÏ\n    apply le_antisymm _ bot_le\n    calc\n      Î¼ s â‰¤ Î¼ (s âˆ© o âˆª oá¶œ) := by\n        conv_lhs => rw [â† inter_union_compl s o]\n        gcongr\n        apply inter_subset_right\n      _ â‰¤ Î¼ (s âˆ© o) + Î¼ oá¶œ := measure_union_le _ _\n      _ = Î¼ (s âˆ© o) := by rw [Î¼o, add_zero]\n      _ = (Îµ : â„â‰¥0âˆ)â»Â¹ * (Îµ â€¢ Î¼) (s âˆ© o) := by\n        simp only [coe_nnreal_smul_apply, â† mul_assoc, mul_comm _ (Îµ : â„â‰¥0âˆ)]\n        rw [ENNReal.mul_inv_cancel (ENNReal.coe_pos.2 Îµpos).ne' ENNReal.coe_ne_top, one_mul]\n      _ â‰¤ (Îµ : â„â‰¥0âˆ)â»Â¹ * Ï (s âˆ© o) := by\n        gcongr\n        refine v.measure_le_of_frequently_le Ï smul_absolutelyContinuous _ ?_\n        intro x hx\n        rw [hs] at hx\n        simp only [mem_inter_iff, not_lt, not_eventually, mem_setOf_eq] at hx\n        exact hx.1\n      _ â‰¤ (Îµ : â„â‰¥0âˆ)â»Â¹ * Ï o := by gcongr; apply inter_subset_right\n      _ = 0 := by rw [Ïo, mul_zero]\n  obtain âŸ¨u, _, u_pos, u_limâŸ© :\n    âˆƒ u : â„• â†’ â„â‰¥0, StrictAnti u âˆ§ (âˆ€ n : â„•, 0 < u n) âˆ§ Tendsto u atTop (ğ“ 0) :=\n    exists_seq_strictAnti_tendsto (0 : â„â‰¥0)\n  have B : âˆ€áµ x âˆ‚Î¼, âˆ€ n, âˆ€á¶  a in v.filterAt x, Ï a < u n * Î¼ a :=\n    ae_all_iff.2 fun n => A (u n) (u_pos n)\n  filter_upwards [B, v.ae_eventually_measure_pos]\n  intro x hx h'x\n  refine tendsto_order.2 âŸ¨fun z hz => (ENNReal.not_lt_zero hz).elim, fun z hz => ?_âŸ©\n  obtain âŸ¨w, w_pos, w_ltâŸ© : âˆƒ w : â„â‰¥0, (0 : â„â‰¥0âˆ) < w âˆ§ (w : â„â‰¥0âˆ) < z :=\n    ENNReal.lt_iff_exists_nnreal_btwn.1 hz\n  obtain âŸ¨n, hnâŸ© : âˆƒ n, u n < w := ((tendsto_order.1 u_lim).2 w (ENNReal.coe_pos.1 w_pos)).exists\n  filter_upwards [hx n, h'x, v.eventually_measure_lt_top x]\n  intro a ha Î¼a_pos Î¼a_lt_top\n  rw [ENNReal.div_lt_iff (Or.inl Î¼a_pos.ne') (Or.inl Î¼a_lt_top.ne)]\n  exact ha.trans_le (mul_le_mul_right' ((ENNReal.coe_le_coe.2 hn.le).trans w_lt.le) _)\n\n"}
{"name":"VitaliFamily.null_of_frequently_le_of_frequently_ge","module":"Mathlib.MeasureTheory.Covering.Differentiation","initialProofState":"Î± : Type u_1\ninstâœâ´ : PseudoMetricSpace Î±\nm0 : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nv : VitaliFamily Î¼\ninstâœÂ³ : SecondCountableTopology Î±\ninstâœÂ² : BorelSpace Î±\ninstâœÂ¹ : MeasureTheory.IsLocallyFiniteMeasure Î¼\nÏ : MeasureTheory.Measure Î±\ninstâœ : MeasureTheory.IsLocallyFiniteMeasure Ï\nhÏ : Ï.AbsolutelyContinuous Î¼\nc d : NNReal\nhcd : LT.lt c d\ns : Set Î±\nhc : âˆ€ (x : Î±), Membership.mem s x â†’ Filter.Frequently (fun a => LE.le (Ï a) (HMul.hMul (â†‘c) (Î¼ a))) (v.filterAt x)\nhd : âˆ€ (x : Î±), Membership.mem s x â†’ Filter.Frequently (fun a => LE.le (HMul.hMul (â†‘d) (Î¼ a)) (Ï a)) (v.filterAt x)\nâŠ¢ Eq (Î¼ s) 0","decl":"/-- A set of points `s` satisfying both `Ï a â‰¤ c * Î¼ a` and `Ï a â‰¥ d * Î¼ a` at arbitrarily small\nsets in a Vitali family has measure `0` if `c < d`. Indeed, the first inequality should imply\nthat `Ï s â‰¤ c * Î¼ s`, and the second one that `Ï s â‰¥ d * Î¼ s`, a contradiction if `0 < Î¼ s`. -/\ntheorem null_of_frequently_le_of_frequently_ge {c d : â„â‰¥0} (hcd : c < d) (s : Set Î±)\n    (hc : âˆ€ x âˆˆ s, âˆƒá¶  a in v.filterAt x, Ï a â‰¤ c * Î¼ a)\n    (hd : âˆ€ x âˆˆ s, âˆƒá¶  a in v.filterAt x, (d : â„â‰¥0âˆ) * Î¼ a â‰¤ Ï a) : Î¼ s = 0 := by\n  apply measure_null_of_locally_null s fun x _ => ?_\n  obtain âŸ¨o, xo, o_open, Î¼oâŸ© : âˆƒ o : Set Î±, x âˆˆ o âˆ§ IsOpen o âˆ§ Î¼ o < âˆ :=\n    Measure.exists_isOpen_measure_lt_top Î¼ x\n  refine âŸ¨s âˆ© o, inter_mem_nhdsWithin _ (o_open.mem_nhds xo), ?_âŸ©\n  let s' := s âˆ© o\n  by_contra h\n  apply lt_irrefl (Ï s')\n  calc\n    Ï s' â‰¤ c * Î¼ s' := v.measure_le_of_frequently_le (c â€¢ Î¼) hÏ s' fun x hx => hc x hx.1\n    _ < d * Î¼ s' := by\n      apply (ENNReal.mul_lt_mul_right h _).2 (ENNReal.coe_lt_coe.2 hcd)\n      exact (lt_of_le_of_lt (measure_mono inter_subset_right) Î¼o).ne\n    _ â‰¤ Ï s' := v.measure_le_of_frequently_le Ï smul_absolutelyContinuous s' fun x hx â†¦ hd x hx.1\n\n"}
{"name":"VitaliFamily.ae_tendsto_div","module":"Mathlib.MeasureTheory.Covering.Differentiation","initialProofState":"Î± : Type u_1\ninstâœâ´ : PseudoMetricSpace Î±\nm0 : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nv : VitaliFamily Î¼\ninstâœÂ³ : SecondCountableTopology Î±\ninstâœÂ² : BorelSpace Î±\ninstâœÂ¹ : MeasureTheory.IsLocallyFiniteMeasure Î¼\nÏ : MeasureTheory.Measure Î±\ninstâœ : MeasureTheory.IsLocallyFiniteMeasure Ï\nhÏ : Ï.AbsolutelyContinuous Î¼\nâŠ¢ Filter.Eventually (fun x => Exists fun c => Filter.Tendsto (fun a => HDiv.hDiv (Ï a) (Î¼ a)) (v.filterAt x) (nhds c)) (MeasureTheory.ae Î¼)","decl":"/-- If `Ï` is absolutely continuous with respect to `Î¼`, then for almost every `x`,\nthe ratio `Ï a / Î¼ a` converges as `a` shrinks to `x` along a Vitali family for `Î¼`. -/\ntheorem ae_tendsto_div : âˆ€áµ x âˆ‚Î¼, âˆƒ c, Tendsto (fun a => Ï a / Î¼ a) (v.filterAt x) (ğ“ c) := by\n  obtain âŸ¨w, w_count, w_dense, _, w_topâŸ© :\n    âˆƒ w : Set â„â‰¥0âˆ, w.Countable âˆ§ Dense w âˆ§ 0 âˆ‰ w âˆ§ âˆ âˆ‰ w :=\n    ENNReal.exists_countable_dense_no_zero_top\n  have I : âˆ€ x âˆˆ w, x â‰  âˆ := fun x xs hx => w_top (hx â–¸ xs)\n  have A : âˆ€ c âˆˆ w, âˆ€ d âˆˆ w, c < d â†’ âˆ€áµ x âˆ‚Î¼,\n      Â¬((âˆƒá¶  a in v.filterAt x, Ï a / Î¼ a < c) âˆ§ âˆƒá¶  a in v.filterAt x, d < Ï a / Î¼ a) := by\n    intro c hc d hd hcd\n    lift c to â„â‰¥0 using I c hc\n    lift d to â„â‰¥0 using I d hd\n    apply v.null_of_frequently_le_of_frequently_ge hÏ (ENNReal.coe_lt_coe.1 hcd)\n    Â· simp only [and_imp, exists_prop, not_frequently, not_and, not_lt, not_le, not_eventually,\n        mem_setOf_eq, mem_compl_iff, not_forall]\n      intro x h1x _\n      apply h1x.mono fun a ha => ?_\n      refine (ENNReal.div_le_iff_le_mul ?_ (Or.inr (bot_le.trans_lt ha).ne')).1 ha.le\n      simp only [ENNReal.coe_ne_top, Ne, or_true, not_false_iff]\n    Â· simp only [and_imp, exists_prop, not_frequently, not_and, not_lt, not_le, not_eventually,\n        mem_setOf_eq, mem_compl_iff, not_forall]\n      intro x _ h2x\n      apply h2x.mono fun a ha => ?_\n      exact ENNReal.mul_le_of_le_div ha.le\n  have B : âˆ€áµ x âˆ‚Î¼, âˆ€ c âˆˆ w, âˆ€ d âˆˆ w, c < d â†’\n      Â¬((âˆƒá¶  a in v.filterAt x, Ï a / Î¼ a < c) âˆ§ âˆƒá¶  a in v.filterAt x, d < Ï a / Î¼ a) := by\n    #adaptation_note /-- 2024-04-23\n    The next two lines were previously just `simpa only [ae_ball_iff w_count, ae_all_iff]` -/\n    rw [ae_ball_iff w_count]; intro x hx; rw [ae_ball_iff w_count]; revert x\n    simpa only [ae_all_iff]\n  filter_upwards [B]\n  intro x hx\n  exact tendsto_of_no_upcrossings w_dense hx\n\n"}
{"name":"VitaliFamily.ae_tendsto_limRatio","module":"Mathlib.MeasureTheory.Covering.Differentiation","initialProofState":"Î± : Type u_1\ninstâœâ´ : PseudoMetricSpace Î±\nm0 : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nv : VitaliFamily Î¼\ninstâœÂ³ : SecondCountableTopology Î±\ninstâœÂ² : BorelSpace Î±\ninstâœÂ¹ : MeasureTheory.IsLocallyFiniteMeasure Î¼\nÏ : MeasureTheory.Measure Î±\ninstâœ : MeasureTheory.IsLocallyFiniteMeasure Ï\nhÏ : Ï.AbsolutelyContinuous Î¼\nâŠ¢ Filter.Eventually (fun x => Filter.Tendsto (fun a => HDiv.hDiv (Ï a) (Î¼ a)) (v.filterAt x) (nhds (v.limRatio Ï x))) (MeasureTheory.ae Î¼)","decl":"theorem ae_tendsto_limRatio :\n    âˆ€áµ x âˆ‚Î¼, Tendsto (fun a => Ï a / Î¼ a) (v.filterAt x) (ğ“ (v.limRatio Ï x)) := by\n  filter_upwards [v.ae_tendsto_div hÏ]\n  intro x hx\n  exact tendsto_nhds_limUnder hx\n\n"}
{"name":"VitaliFamily.exists_measurable_supersets_limRatio","module":"Mathlib.MeasureTheory.Covering.Differentiation","initialProofState":"Î± : Type u_1\ninstâœâ´ : PseudoMetricSpace Î±\nm0 : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nv : VitaliFamily Î¼\ninstâœÂ³ : SecondCountableTopology Î±\ninstâœÂ² : BorelSpace Î±\ninstâœÂ¹ : MeasureTheory.IsLocallyFiniteMeasure Î¼\nÏ : MeasureTheory.Measure Î±\ninstâœ : MeasureTheory.IsLocallyFiniteMeasure Ï\nhÏ : Ï.AbsolutelyContinuous Î¼\np q : NNReal\nhpq : LT.lt p q\nâŠ¢ Exists fun a => Exists fun b => And (MeasurableSet a) (And (MeasurableSet b) (And (HasSubset.Subset (setOf fun x => LT.lt (v.limRatio Ï x) â†‘p) a) (And (HasSubset.Subset (setOf fun x => LT.lt (â†‘q) (v.limRatio Ï x)) b) (Eq (Î¼ (Inter.inter a b)) 0))))","decl":"/-- Given two thresholds `p < q`, the sets `{x | v.limRatio Ï x < p}`\nand `{x | q < v.limRatio Ï x}` are obviously disjoint. The key to proving that `v.limRatio Ï` is\nalmost everywhere measurable is to show that these sets have measurable supersets which are also\ndisjoint, up to zero measure. This is the content of this lemma. -/\ntheorem exists_measurable_supersets_limRatio {p q : â„â‰¥0} (hpq : p < q) :\n    âˆƒ a b, MeasurableSet a âˆ§ MeasurableSet b âˆ§\n      {x | v.limRatio Ï x < p} âŠ† a âˆ§ {x | (q : â„â‰¥0âˆ) < v.limRatio Ï x} âŠ† b âˆ§ Î¼ (a âˆ© b) = 0 := by\n  /- Here is a rough sketch, assuming that the measure is finite and the limit is well defined\n    everywhere. Let `u := {x | v.limRatio Ï x < p}` and `w := {x | q < v.limRatio Ï x}`. They\n    have measurable supersets `u'` and `w'` of the same measure. We will show that these satisfy\n    the conclusion of the theorem, i.e., `Î¼ (u' âˆ© w') = 0`. For this, note that\n    `Ï (u' âˆ© w') = Ï (u âˆ© w')` (as `w'` is measurable, see `measure_toMeasurable_add_inter_left`).\n    The latter set is included in the set where the limit of the ratios is `< p`, and therefore\n    its measure is `â‰¤ p * Î¼ (u âˆ© w')`. Using the same trick in the other direction gives that this\n    is `p * Î¼ (u' âˆ© w')`. We have shown that `Ï (u' âˆ© w') â‰¤ p * Î¼ (u' âˆ© w')`. Arguing in the same\n    way but using the `w` part gives `q * Î¼ (u' âˆ© w') â‰¤ Ï (u' âˆ© w')`. If `Î¼ (u' âˆ© w')` were nonzero,\n    this would be a contradiction as `p < q`.\n\n    For the rigorous proof, we need to work on a part of the space where the measure is finite\n    (provided by `spanningSets (Ï + Î¼)`) and to restrict to the set where the limit is well defined\n    (called `s` below, of full measure). Otherwise, the argument goes through.\n    -/\n  let s := {x | âˆƒ c, Tendsto (fun a => Ï a / Î¼ a) (v.filterAt x) (ğ“ c)}\n  let o : â„• â†’ Set Î± := spanningSets (Ï + Î¼)\n  let u n := s âˆ© {x | v.limRatio Ï x < p} âˆ© o n\n  let w n := s âˆ© {x | (q : â„â‰¥0âˆ) < v.limRatio Ï x} âˆ© o n\n  -- the supersets are obtained by restricting to the set `s` where the limit is well defined, to\n  -- a finite measure part `o n`, taking a measurable superset here, and then taking the union over\n  -- `n`.\n  refine\n    âŸ¨toMeasurable Î¼ sá¶œ âˆª â‹ƒ n, toMeasurable (Ï + Î¼) (u n),\n      toMeasurable Î¼ sá¶œ âˆª â‹ƒ n, toMeasurable (Ï + Î¼) (w n), ?_, ?_, ?_, ?_, ?_âŸ©\n  -- check that these sets are measurable supersets as required\n  Â· exact\n      (measurableSet_toMeasurable _ _).union\n        (MeasurableSet.iUnion fun n => measurableSet_toMeasurable _ _)\n  Â· exact\n      (measurableSet_toMeasurable _ _).union\n        (MeasurableSet.iUnion fun n => measurableSet_toMeasurable _ _)\n  Â· intro x hx\n    by_cases h : x âˆˆ s\n    Â· refine Or.inr (mem_iUnion.2 âŸ¨spanningSetsIndex (Ï + Î¼) x, ?_âŸ©)\n      exact subset_toMeasurable _ _ âŸ¨âŸ¨h, hxâŸ©, mem_spanningSetsIndex _ _âŸ©\n    Â· exact Or.inl (subset_toMeasurable Î¼ sá¶œ h)\n  Â· intro x hx\n    by_cases h : x âˆˆ s\n    Â· refine Or.inr (mem_iUnion.2 âŸ¨spanningSetsIndex (Ï + Î¼) x, ?_âŸ©)\n      exact subset_toMeasurable _ _ âŸ¨âŸ¨h, hxâŸ©, mem_spanningSetsIndex _ _âŸ©\n    Â· exact Or.inl (subset_toMeasurable Î¼ sá¶œ h)\n  -- it remains to check the nontrivial part that these sets have zero measure intersection.\n  -- it suffices to do it for fixed `m` and `n`, as one is taking countable unions.\n  suffices H : âˆ€ m n : â„•, Î¼ (toMeasurable (Ï + Î¼) (u m) âˆ© toMeasurable (Ï + Î¼) (w n)) = 0 by\n    have A :\n      (toMeasurable Î¼ sá¶œ âˆª â‹ƒ n, toMeasurable (Ï + Î¼) (u n)) âˆ©\n          (toMeasurable Î¼ sá¶œ âˆª â‹ƒ n, toMeasurable (Ï + Î¼) (w n)) âŠ†\n        toMeasurable Î¼ sá¶œ âˆª\n          â‹ƒ (m) (n), toMeasurable (Ï + Î¼) (u m) âˆ© toMeasurable (Ï + Î¼) (w n) := by\n      simp only [inter_union_distrib_left, union_inter_distrib_right, true_and,\n        subset_union_left, union_subset_iff, inter_self]\n      refine âŸ¨?_, ?_, ?_âŸ©\n      Â· exact inter_subset_right.trans subset_union_left\n      Â· exact inter_subset_left.trans subset_union_left\n      Â· simp_rw [iUnion_inter, inter_iUnion]; exact subset_union_right\n    refine le_antisymm ((measure_mono A).trans ?_) bot_le\n    calc\n      Î¼ (toMeasurable Î¼ sá¶œ âˆª\n        â‹ƒ (m) (n), toMeasurable (Ï + Î¼) (u m) âˆ© toMeasurable (Ï + Î¼) (w n)) â‰¤\n          Î¼ (toMeasurable Î¼ sá¶œ) +\n            Î¼ (â‹ƒ (m) (n), toMeasurable (Ï + Î¼) (u m) âˆ© toMeasurable (Ï + Î¼) (w n)) :=\n        measure_union_le _ _\n      _ = Î¼ (â‹ƒ (m) (n), toMeasurable (Ï + Î¼) (u m) âˆ© toMeasurable (Ï + Î¼) (w n)) := by\n        have : Î¼ sá¶œ = 0 := v.ae_tendsto_div hÏ; rw [measure_toMeasurable, this, zero_add]\n      _ â‰¤ âˆ‘' (m) (n), Î¼ (toMeasurable (Ï + Î¼) (u m) âˆ© toMeasurable (Ï + Î¼) (w n)) :=\n        ((measure_iUnion_le _).trans (ENNReal.tsum_le_tsum fun m => measure_iUnion_le _))\n      _ = 0 := by simp only [H, tsum_zero]\n  -- now starts the nontrivial part of the argument. We fix `m` and `n`, and show that the\n  -- measurable supersets of `u m` and `w n` have zero measure intersection by using the lemmas\n  -- `measure_toMeasurable_add_inter_left` (to reduce to `u m` or `w n` instead of the measurable\n  -- superset) and `measure_le_of_frequently_le` to compare their measures for `Ï` and `Î¼`.\n  intro m n\n  have I : (Ï + Î¼) (u m) â‰  âˆ := by\n    apply (lt_of_le_of_lt (measure_mono _) (measure_spanningSets_lt_top (Ï + Î¼) m)).ne\n    exact inter_subset_right\n  have J : (Ï + Î¼) (w n) â‰  âˆ := by\n    apply (lt_of_le_of_lt (measure_mono _) (measure_spanningSets_lt_top (Ï + Î¼) n)).ne\n    exact inter_subset_right\n  have A :\n    Ï (toMeasurable (Ï + Î¼) (u m) âˆ© toMeasurable (Ï + Î¼) (w n)) â‰¤\n      p * Î¼ (toMeasurable (Ï + Î¼) (u m) âˆ© toMeasurable (Ï + Î¼) (w n)) :=\n    calc\n      Ï (toMeasurable (Ï + Î¼) (u m) âˆ© toMeasurable (Ï + Î¼) (w n)) =\n          Ï (u m âˆ© toMeasurable (Ï + Î¼) (w n)) :=\n        measure_toMeasurable_add_inter_left (measurableSet_toMeasurable _ _) I\n      _ â‰¤ (p â€¢ Î¼) (u m âˆ© toMeasurable (Ï + Î¼) (w n)) := by\n        refine v.measure_le_of_frequently_le (p â€¢ Î¼) hÏ _ fun x hx => ?_\n        have L : Tendsto (fun a : Set Î± => Ï a / Î¼ a) (v.filterAt x) (ğ“ (v.limRatio Ï x)) :=\n          tendsto_nhds_limUnder hx.1.1.1\n        have I : âˆ€á¶  b : Set Î± in v.filterAt x, Ï b / Î¼ b < p := (tendsto_order.1 L).2 _ hx.1.1.2\n        apply I.frequently.mono fun a ha => ?_\n        rw [coe_nnreal_smul_apply]\n        refine (ENNReal.div_le_iff_le_mul ?_ (Or.inr (bot_le.trans_lt ha).ne')).1 ha.le\n        simp only [ENNReal.coe_ne_top, Ne, or_true, not_false_iff]\n      _ = p * Î¼ (toMeasurable (Ï + Î¼) (u m) âˆ© toMeasurable (Ï + Î¼) (w n)) := by\n        simp only [coe_nnreal_smul_apply,\n          measure_toMeasurable_add_inter_right (measurableSet_toMeasurable _ _) I]\n  have B :\n    (q : â„â‰¥0âˆ) * Î¼ (toMeasurable (Ï + Î¼) (u m) âˆ© toMeasurable (Ï + Î¼) (w n)) â‰¤\n      Ï (toMeasurable (Ï + Î¼) (u m) âˆ© toMeasurable (Ï + Î¼) (w n)) :=\n    calc\n      (q : â„â‰¥0âˆ) * Î¼ (toMeasurable (Ï + Î¼) (u m) âˆ© toMeasurable (Ï + Î¼) (w n)) =\n          (q : â„â‰¥0âˆ) * Î¼ (toMeasurable (Ï + Î¼) (u m) âˆ© w n) := by\n        conv_rhs => rw [inter_comm]\n        rw [inter_comm, measure_toMeasurable_add_inter_right (measurableSet_toMeasurable _ _) J]\n      _ â‰¤ Ï (toMeasurable (Ï + Î¼) (u m) âˆ© w n) := by\n        rw [â† coe_nnreal_smul_apply]\n        refine v.measure_le_of_frequently_le _ (.smul_left .rfl _) _ ?_\n        intro x hx\n        have L : Tendsto (fun a : Set Î± => Ï a / Î¼ a) (v.filterAt x) (ğ“ (v.limRatio Ï x)) :=\n          tendsto_nhds_limUnder hx.2.1.1\n        have I : âˆ€á¶  b : Set Î± in v.filterAt x, (q : â„â‰¥0âˆ) < Ï b / Î¼ b :=\n          (tendsto_order.1 L).1 _ hx.2.1.2\n        apply I.frequently.mono fun a ha => ?_\n        rw [coe_nnreal_smul_apply]\n        exact ENNReal.mul_le_of_le_div ha.le\n      _ = Ï (toMeasurable (Ï + Î¼) (u m) âˆ© toMeasurable (Ï + Î¼) (w n)) := by\n        conv_rhs => rw [inter_comm]\n        rw [inter_comm]\n        exact (measure_toMeasurable_add_inter_left (measurableSet_toMeasurable _ _) J).symm\n  by_contra h\n  apply lt_irrefl (Ï (toMeasurable (Ï + Î¼) (u m) âˆ© toMeasurable (Ï + Î¼) (w n)))\n  calc\n    Ï (toMeasurable (Ï + Î¼) (u m) âˆ© toMeasurable (Ï + Î¼) (w n)) â‰¤\n        p * Î¼ (toMeasurable (Ï + Î¼) (u m) âˆ© toMeasurable (Ï + Î¼) (w n)) :=\n      A\n    _ < q * Î¼ (toMeasurable (Ï + Î¼) (u m) âˆ© toMeasurable (Ï + Î¼) (w n)) := by\n      gcongr\n      suffices H : (Ï + Î¼) (toMeasurable (Ï + Î¼) (u m) âˆ© toMeasurable (Ï + Î¼) (w n)) â‰  âˆ by\n        simp only [not_or, ENNReal.add_eq_top, Pi.add_apply, Ne, coe_add] at H\n        exact H.2\n      apply (lt_of_le_of_lt (measure_mono inter_subset_left) _).ne\n      rw [measure_toMeasurable]\n      apply lt_of_le_of_lt (measure_mono _) (measure_spanningSets_lt_top (Ï + Î¼) m)\n      exact inter_subset_right\n    _ â‰¤ Ï (toMeasurable (Ï + Î¼) (u m) âˆ© toMeasurable (Ï + Î¼) (w n)) := B\n\n"}
{"name":"VitaliFamily.aemeasurable_limRatio","module":"Mathlib.MeasureTheory.Covering.Differentiation","initialProofState":"Î± : Type u_1\ninstâœâ´ : PseudoMetricSpace Î±\nm0 : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nv : VitaliFamily Î¼\ninstâœÂ³ : SecondCountableTopology Î±\ninstâœÂ² : BorelSpace Î±\ninstâœÂ¹ : MeasureTheory.IsLocallyFiniteMeasure Î¼\nÏ : MeasureTheory.Measure Î±\ninstâœ : MeasureTheory.IsLocallyFiniteMeasure Ï\nhÏ : Ï.AbsolutelyContinuous Î¼\nâŠ¢ AEMeasurable (v.limRatio Ï) Î¼","decl":"theorem aemeasurable_limRatio : AEMeasurable (v.limRatio Ï) Î¼ := by\n  apply ENNReal.aemeasurable_of_exist_almost_disjoint_supersets _ _ fun p q hpq => ?_\n  exact v.exists_measurable_supersets_limRatio hÏ hpq\n\n"}
{"name":"VitaliFamily.limRatioMeas_measurable","module":"Mathlib.MeasureTheory.Covering.Differentiation","initialProofState":"Î± : Type u_1\ninstâœâ´ : PseudoMetricSpace Î±\nm0 : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nv : VitaliFamily Î¼\ninstâœÂ³ : SecondCountableTopology Î±\ninstâœÂ² : BorelSpace Î±\ninstâœÂ¹ : MeasureTheory.IsLocallyFiniteMeasure Î¼\nÏ : MeasureTheory.Measure Î±\ninstâœ : MeasureTheory.IsLocallyFiniteMeasure Ï\nhÏ : Ï.AbsolutelyContinuous Î¼\nâŠ¢ Measurable (v.limRatioMeas hÏ)","decl":"theorem limRatioMeas_measurable : Measurable (v.limRatioMeas hÏ) :=\n  AEMeasurable.measurable_mk _\n\n"}
{"name":"VitaliFamily.ae_tendsto_limRatioMeas","module":"Mathlib.MeasureTheory.Covering.Differentiation","initialProofState":"Î± : Type u_1\ninstâœâ´ : PseudoMetricSpace Î±\nm0 : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nv : VitaliFamily Î¼\ninstâœÂ³ : SecondCountableTopology Î±\ninstâœÂ² : BorelSpace Î±\ninstâœÂ¹ : MeasureTheory.IsLocallyFiniteMeasure Î¼\nÏ : MeasureTheory.Measure Î±\ninstâœ : MeasureTheory.IsLocallyFiniteMeasure Ï\nhÏ : Ï.AbsolutelyContinuous Î¼\nâŠ¢ Filter.Eventually (fun x => Filter.Tendsto (fun a => HDiv.hDiv (Ï a) (Î¼ a)) (v.filterAt x) (nhds (v.limRatioMeas hÏ x))) (MeasureTheory.ae Î¼)","decl":"theorem ae_tendsto_limRatioMeas :\n    âˆ€áµ x âˆ‚Î¼, Tendsto (fun a => Ï a / Î¼ a) (v.filterAt x) (ğ“ (v.limRatioMeas hÏ x)) := by\n  filter_upwards [v.ae_tendsto_limRatio hÏ, AEMeasurable.ae_eq_mk (v.aemeasurable_limRatio hÏ)]\n  intro x hx h'x\n  rwa [h'x] at hx\n\n"}
{"name":"VitaliFamily.measure_le_mul_of_subset_limRatioMeas_lt","module":"Mathlib.MeasureTheory.Covering.Differentiation","initialProofState":"Î± : Type u_1\ninstâœâ´ : PseudoMetricSpace Î±\nm0 : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nv : VitaliFamily Î¼\ninstâœÂ³ : SecondCountableTopology Î±\ninstâœÂ² : BorelSpace Î±\ninstâœÂ¹ : MeasureTheory.IsLocallyFiniteMeasure Î¼\nÏ : MeasureTheory.Measure Î±\ninstâœ : MeasureTheory.IsLocallyFiniteMeasure Ï\nhÏ : Ï.AbsolutelyContinuous Î¼\np : NNReal\ns : Set Î±\nh : HasSubset.Subset s (setOf fun x => LT.lt (v.limRatioMeas hÏ x) â†‘p)\nâŠ¢ LE.le (Ï s) (HMul.hMul (â†‘p) (Î¼ s))","decl":"/-- If, for all `x` in a set `s`, one has frequently `Ï a / Î¼ a < p`, then `Ï s â‰¤ p * Î¼ s`, as\nproved in `measure_le_of_frequently_le`. Since `Ï a / Î¼ a` tends almost everywhere to\n`v.limRatioMeas hÏ x`, the same property holds for sets `s` on which `v.limRatioMeas hÏ < p`. -/\ntheorem measure_le_mul_of_subset_limRatioMeas_lt {p : â„â‰¥0} {s : Set Î±}\n    (h : s âŠ† {x | v.limRatioMeas hÏ x < p}) : Ï s â‰¤ p * Î¼ s := by\n  let t := {x : Î± | Tendsto (fun a => Ï a / Î¼ a) (v.filterAt x) (ğ“ (v.limRatioMeas hÏ x))}\n  have A : Î¼ tá¶œ = 0 := v.ae_tendsto_limRatioMeas hÏ\n  suffices H : Ï (s âˆ© t) â‰¤ (p â€¢ Î¼) (s âˆ© t) by calc\n    Ï s = Ï (s âˆ© t âˆª s âˆ© tá¶œ) := by rw [inter_union_compl]\n    _ â‰¤ Ï (s âˆ© t) + Ï (s âˆ© tá¶œ) := measure_union_le _ _\n    _ â‰¤ (p â€¢ Î¼) (s âˆ© t) + Ï tá¶œ := by gcongr; apply inter_subset_right\n    _ â‰¤ p * Î¼ (s âˆ© t) := by simp [(hÏ A)]\n    _ â‰¤ p * Î¼ s := by gcongr; apply inter_subset_left\n  refine v.measure_le_of_frequently_le (p â€¢ Î¼) hÏ _ fun x hx => ?_\n  have I : âˆ€á¶  b : Set Î± in v.filterAt x, Ï b / Î¼ b < p := (tendsto_order.1 hx.2).2 _ (h hx.1)\n  apply I.frequently.mono fun a ha => ?_\n  rw [coe_nnreal_smul_apply]\n  refine (ENNReal.div_le_iff_le_mul ?_ (Or.inr (bot_le.trans_lt ha).ne')).1 ha.le\n  simp only [ENNReal.coe_ne_top, Ne, or_true, not_false_iff]\n\n"}
{"name":"VitaliFamily.mul_measure_le_of_subset_lt_limRatioMeas","module":"Mathlib.MeasureTheory.Covering.Differentiation","initialProofState":"Î± : Type u_1\ninstâœâ´ : PseudoMetricSpace Î±\nm0 : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nv : VitaliFamily Î¼\ninstâœÂ³ : SecondCountableTopology Î±\ninstâœÂ² : BorelSpace Î±\ninstâœÂ¹ : MeasureTheory.IsLocallyFiniteMeasure Î¼\nÏ : MeasureTheory.Measure Î±\ninstâœ : MeasureTheory.IsLocallyFiniteMeasure Ï\nhÏ : Ï.AbsolutelyContinuous Î¼\nq : NNReal\ns : Set Î±\nh : HasSubset.Subset s (setOf fun x => LT.lt (â†‘q) (v.limRatioMeas hÏ x))\nâŠ¢ LE.le (HMul.hMul (â†‘q) (Î¼ s)) (Ï s)","decl":"/-- If, for all `x` in a set `s`, one has frequently `q < Ï a / Î¼ a`, then `q * Î¼ s â‰¤ Ï s`, as\nproved in `measure_le_of_frequently_le`. Since `Ï a / Î¼ a` tends almost everywhere to\n`v.limRatioMeas hÏ x`, the same property holds for sets `s` on which `q < v.limRatioMeas hÏ`. -/\ntheorem mul_measure_le_of_subset_lt_limRatioMeas {q : â„â‰¥0} {s : Set Î±}\n    (h : s âŠ† {x | (q : â„â‰¥0âˆ) < v.limRatioMeas hÏ x}) : (q : â„â‰¥0âˆ) * Î¼ s â‰¤ Ï s := by\n  let t := {x : Î± | Tendsto (fun a => Ï a / Î¼ a) (v.filterAt x) (ğ“ (v.limRatioMeas hÏ x))}\n  have A : Î¼ tá¶œ = 0 := v.ae_tendsto_limRatioMeas hÏ\n  suffices H : (q â€¢ Î¼) (s âˆ© t) â‰¤ Ï (s âˆ© t) by calc\n    (q â€¢ Î¼) s = (q â€¢ Î¼) (s âˆ© t âˆª s âˆ© tá¶œ) := by rw [inter_union_compl]\n    _ â‰¤ (q â€¢ Î¼) (s âˆ© t) + (q â€¢ Î¼) (s âˆ© tá¶œ) := measure_union_le _ _\n    _ â‰¤ Ï (s âˆ© t) + (q â€¢ Î¼) tá¶œ := by gcongr; apply inter_subset_right\n    _ = Ï (s âˆ© t) := by simp [A]\n    _ â‰¤ Ï s := by gcongr; apply inter_subset_left\n  refine v.measure_le_of_frequently_le _ (.smul_left .rfl _) _ ?_\n  intro x hx\n  have I : âˆ€á¶  a in v.filterAt x, (q : â„â‰¥0âˆ) < Ï a / Î¼ a := (tendsto_order.1 hx.2).1 _ (h hx.1)\n  apply I.frequently.mono fun a ha => ?_\n  rw [coe_nnreal_smul_apply]\n  exact ENNReal.mul_le_of_le_div ha.le\n\n"}
{"name":"VitaliFamily.measure_limRatioMeas_top","module":"Mathlib.MeasureTheory.Covering.Differentiation","initialProofState":"Î± : Type u_1\ninstâœâ´ : PseudoMetricSpace Î±\nm0 : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nv : VitaliFamily Î¼\ninstâœÂ³ : SecondCountableTopology Î±\ninstâœÂ² : BorelSpace Î±\ninstâœÂ¹ : MeasureTheory.IsLocallyFiniteMeasure Î¼\nÏ : MeasureTheory.Measure Î±\ninstâœ : MeasureTheory.IsLocallyFiniteMeasure Ï\nhÏ : Ï.AbsolutelyContinuous Î¼\nâŠ¢ Eq (Î¼ (setOf fun x => Eq (v.limRatioMeas hÏ x) Top.top)) 0","decl":"/-- The points with `v.limRatioMeas hÏ x = âˆ` have measure `0` for `Î¼`. -/\ntheorem measure_limRatioMeas_top : Î¼ {x | v.limRatioMeas hÏ x = âˆ} = 0 := by\n  refine measure_null_of_locally_null _ fun x _ => ?_\n  obtain âŸ¨o, xo, o_open, Î¼oâŸ© : âˆƒ o : Set Î±, x âˆˆ o âˆ§ IsOpen o âˆ§ Ï o < âˆ :=\n    Measure.exists_isOpen_measure_lt_top Ï x\n  let s := {x : Î± | v.limRatioMeas hÏ x = âˆ} âˆ© o\n  refine âŸ¨s, inter_mem_nhdsWithin _ (o_open.mem_nhds xo), le_antisymm ?_ bot_leâŸ©\n  have Ïs : Ï s â‰  âˆ := ((measure_mono inter_subset_right).trans_lt Î¼o).ne\n  have A : âˆ€ q : â„â‰¥0, 1 â‰¤ q â†’ Î¼ s â‰¤ (q : â„â‰¥0âˆ)â»Â¹ * Ï s := by\n    intro q hq\n    rw [mul_comm, â† div_eq_mul_inv, ENNReal.le_div_iff_mul_le _ (Or.inr Ïs), mul_comm]\n    Â· apply v.mul_measure_le_of_subset_lt_limRatioMeas hÏ\n      intro y hy\n      have : v.limRatioMeas hÏ y = âˆ := hy.1\n      simp only [this, ENNReal.coe_lt_top, mem_setOf_eq]\n    Â· simp only [(zero_lt_one.trans_le hq).ne', true_or, ENNReal.coe_eq_zero, Ne,\n        not_false_iff]\n  have B : Tendsto (fun q : â„â‰¥0 => (q : â„â‰¥0âˆ)â»Â¹ * Ï s) atTop (ğ“ (âˆâ»Â¹ * Ï s)) := by\n    apply ENNReal.Tendsto.mul_const _ (Or.inr Ïs)\n    exact ENNReal.tendsto_inv_iff.2 (ENNReal.tendsto_coe_nhds_top.2 tendsto_id)\n  simp only [zero_mul, ENNReal.inv_top] at B\n  apply ge_of_tendsto B\n  exact eventually_atTop.2 âŸ¨1, AâŸ©\n\n"}
{"name":"VitaliFamily.measure_limRatioMeas_zero","module":"Mathlib.MeasureTheory.Covering.Differentiation","initialProofState":"Î± : Type u_1\ninstâœâ´ : PseudoMetricSpace Î±\nm0 : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nv : VitaliFamily Î¼\ninstâœÂ³ : SecondCountableTopology Î±\ninstâœÂ² : BorelSpace Î±\ninstâœÂ¹ : MeasureTheory.IsLocallyFiniteMeasure Î¼\nÏ : MeasureTheory.Measure Î±\ninstâœ : MeasureTheory.IsLocallyFiniteMeasure Ï\nhÏ : Ï.AbsolutelyContinuous Î¼\nâŠ¢ Eq (Ï (setOf fun x => Eq (v.limRatioMeas hÏ x) 0)) 0","decl":"/-- The points with `v.limRatioMeas hÏ x = 0` have measure `0` for `Ï`. -/\ntheorem measure_limRatioMeas_zero : Ï {x | v.limRatioMeas hÏ x = 0} = 0 := by\n  refine measure_null_of_locally_null _ fun x _ => ?_\n  obtain âŸ¨o, xo, o_open, Î¼oâŸ© : âˆƒ o : Set Î±, x âˆˆ o âˆ§ IsOpen o âˆ§ Î¼ o < âˆ :=\n    Measure.exists_isOpen_measure_lt_top Î¼ x\n  let s := {x : Î± | v.limRatioMeas hÏ x = 0} âˆ© o\n  refine âŸ¨s, inter_mem_nhdsWithin _ (o_open.mem_nhds xo), le_antisymm ?_ bot_leâŸ©\n  have Î¼s : Î¼ s â‰  âˆ := ((measure_mono inter_subset_right).trans_lt Î¼o).ne\n  have A : âˆ€ q : â„â‰¥0, 0 < q â†’ Ï s â‰¤ q * Î¼ s := by\n    intro q hq\n    apply v.measure_le_mul_of_subset_limRatioMeas_lt hÏ\n    intro y hy\n    have : v.limRatioMeas hÏ y = 0 := hy.1\n    simp only [this, mem_setOf_eq, hq, ENNReal.coe_pos]\n  have B : Tendsto (fun q : â„â‰¥0 => (q : â„â‰¥0âˆ) * Î¼ s) (ğ“[>] (0 : â„â‰¥0)) (ğ“ ((0 : â„â‰¥0) * Î¼ s)) := by\n    apply ENNReal.Tendsto.mul_const _ (Or.inr Î¼s)\n    rw [ENNReal.tendsto_coe]\n    exact nhdsWithin_le_nhds\n  simp only [zero_mul, ENNReal.coe_zero] at B\n  apply ge_of_tendsto B\n  filter_upwards [self_mem_nhdsWithin] using A\n\n"}
{"name":"VitaliFamily.withDensity_le_mul","module":"Mathlib.MeasureTheory.Covering.Differentiation","initialProofState":"Î± : Type u_1\ninstâœâ´ : PseudoMetricSpace Î±\nm0 : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nv : VitaliFamily Î¼\ninstâœÂ³ : SecondCountableTopology Î±\ninstâœÂ² : BorelSpace Î±\ninstâœÂ¹ : MeasureTheory.IsLocallyFiniteMeasure Î¼\nÏ : MeasureTheory.Measure Î±\ninstâœ : MeasureTheory.IsLocallyFiniteMeasure Ï\nhÏ : Ï.AbsolutelyContinuous Î¼\ns : Set Î±\nhs : MeasurableSet s\nt : NNReal\nht : LT.lt 1 t\nâŠ¢ LE.le ((Î¼.withDensity (v.limRatioMeas hÏ)) s) (HMul.hMul (HPow.hPow (â†‘t) 2) (Ï s))","decl":"/-- As an intermediate step to show that `Î¼.withDensity (v.limRatioMeas hÏ) = Ï`, we show here\nthat `Î¼.withDensity (v.limRatioMeas hÏ) â‰¤ t^2 Ï` for any `t > 1`. -/\ntheorem withDensity_le_mul {s : Set Î±} (hs : MeasurableSet s) {t : â„â‰¥0} (ht : 1 < t) :\n    Î¼.withDensity (v.limRatioMeas hÏ) s â‰¤ (t : â„â‰¥0âˆ) ^ 2 * Ï s := by\n  /- We cut `s` into the sets where `v.limRatioMeas hÏ = 0`, where `v.limRatioMeas hÏ = âˆ`, and\n    where `v.limRatioMeas hÏ âˆˆ [t^n, t^(n+1))` for `n : â„¤`. The first and second have measure `0`.\n    For the latter, since `v.limRatioMeas hÏ` fluctuates by at most `t` on this slice, we can use\n    `measure_le_mul_of_subset_limRatioMeas_lt` and `mul_measure_le_of_subset_lt_limRatioMeas` to\n    show that the two measures are comparable up to `t` (in fact `t^2` for technical reasons of\n    strict inequalities). -/\n  have t_ne_zero' : t â‰  0 := (zero_lt_one.trans ht).ne'\n  have t_ne_zero : (t : â„â‰¥0âˆ) â‰  0 := by simpa only [ENNReal.coe_eq_zero, Ne] using t_ne_zero'\n  let Î½ := Î¼.withDensity (v.limRatioMeas hÏ)\n  let f := v.limRatioMeas hÏ\n  have f_meas : Measurable f := v.limRatioMeas_measurable hÏ\n  -- Note(kmill): smul elaborator when used for CoeFun fails to get CoeFun instance to trigger\n  -- unless you use the `(... :)` notation. Another fix is using `(2 : Nat)`, so this appears\n  -- to be an unpleasant interaction with default instances.\n  have A : Î½ (s âˆ© f â»Â¹' {0}) â‰¤ ((t : â„â‰¥0âˆ) ^ 2 â€¢ Ï :) (s âˆ© f â»Â¹' {0}) := by\n    apply le_trans _ (zero_le _)\n    have M : MeasurableSet (s âˆ© f â»Â¹' {0}) := hs.inter (f_meas (measurableSet_singleton _))\n    simp only [f, Î½, nonpos_iff_eq_zero, M, withDensity_apply, lintegral_eq_zero_iff f_meas]\n    apply (ae_restrict_iff' M).2\n    exact Eventually.of_forall fun x hx => hx.2\n  have B : Î½ (s âˆ© f â»Â¹' {âˆ}) â‰¤ ((t : â„â‰¥0âˆ) ^ 2 â€¢ Ï :) (s âˆ© f â»Â¹' {âˆ}) := by\n    apply le_trans (le_of_eq _) (zero_le _)\n    apply withDensity_absolutelyContinuous Î¼ _\n    rw [â† nonpos_iff_eq_zero]\n    exact (measure_mono inter_subset_right).trans (v.measure_limRatioMeas_top hÏ).le\n  have C :\n    âˆ€ n : â„¤,\n      Î½ (s âˆ© f â»Â¹' Ico ((t : â„â‰¥0âˆ) ^ n) ((t : â„â‰¥0âˆ) ^ (n + 1))) â‰¤\n        ((t : â„â‰¥0âˆ) ^ 2 â€¢ Ï :) (s âˆ© f â»Â¹' Ico ((t : â„â‰¥0âˆ) ^ n) ((t : â„â‰¥0âˆ) ^ (n + 1))) := by\n    intro n\n    let I := Ico ((t : â„â‰¥0âˆ) ^ n) ((t : â„â‰¥0âˆ) ^ (n + 1))\n    have M : MeasurableSet (s âˆ© f â»Â¹' I) := hs.inter (f_meas measurableSet_Ico)\n    simp only [Î½, I, M, withDensity_apply, coe_nnreal_smul_apply]\n    calc\n      (âˆ«â» x in s âˆ© f â»Â¹' I, f x âˆ‚Î¼) â‰¤ âˆ«â» _ in s âˆ© f â»Â¹' I, (t : â„â‰¥0âˆ) ^ (n + 1) âˆ‚Î¼ :=\n        lintegral_mono_ae ((ae_restrict_iff' M).2 (Eventually.of_forall fun x hx => hx.2.2.le))\n      _ = (t : â„â‰¥0âˆ) ^ (n + 1) * Î¼ (s âˆ© f â»Â¹' I) := by\n        simp only [lintegral_const, MeasurableSet.univ, Measure.restrict_apply, univ_inter]\n      _ = (t : â„â‰¥0âˆ) ^ (2 : â„¤) * ((t : â„â‰¥0âˆ) ^ (n - 1) * Î¼ (s âˆ© f â»Â¹' I)) := by\n        rw [â† mul_assoc, â† ENNReal.zpow_add t_ne_zero ENNReal.coe_ne_top]\n        congr 2\n        abel\n      _ â‰¤ (t : â„â‰¥0âˆ) ^ (2 : â„¤) * Ï (s âˆ© f â»Â¹' I) := by\n        gcongr\n        rw [â† ENNReal.coe_zpow (zero_lt_one.trans ht).ne']\n        apply v.mul_measure_le_of_subset_lt_limRatioMeas hÏ\n        intro x hx\n        apply lt_of_lt_of_le _ hx.2.1\n        rw [â† ENNReal.coe_zpow (zero_lt_one.trans ht).ne', ENNReal.coe_lt_coe, sub_eq_add_neg,\n          zpow_addâ‚€ t_ne_zero']\n        conv_rhs => rw [â† mul_one (t ^ n)]\n        gcongr\n        rw [zpow_neg_one]\n        exact inv_lt_one_of_one_ltâ‚€ ht\n  calc\n    Î½ s =\n      Î½ (s âˆ© f â»Â¹' {0}) + Î½ (s âˆ© f â»Â¹' {âˆ}) +\n        âˆ‘' n : â„¤, Î½ (s âˆ© f â»Â¹' Ico ((t : â„â‰¥0âˆ) ^ n) ((t : â„â‰¥0âˆ) ^ (n + 1))) :=\n      measure_eq_measure_preimage_add_measure_tsum_Ico_zpow Î½ f_meas hs ht\n    _ â‰¤\n        ((t : â„â‰¥0âˆ) ^ 2 â€¢ Ï :) (s âˆ© f â»Â¹' {0}) + ((t : â„â‰¥0âˆ) ^ 2 â€¢ Ï :) (s âˆ© f â»Â¹' {âˆ}) +\n          âˆ‘' n : â„¤, ((t : â„â‰¥0âˆ) ^ 2 â€¢ Ï :) (s âˆ© f â»Â¹' Ico (t ^ n) (t ^ (n + 1))) :=\n      (add_le_add (add_le_add A B) (ENNReal.tsum_le_tsum C))\n    _ = ((t : â„â‰¥0âˆ) ^ 2 â€¢ Ï :) s :=\n      (measure_eq_measure_preimage_add_measure_tsum_Ico_zpow ((t : â„â‰¥0âˆ) ^ 2 â€¢ Ï) f_meas hs ht).symm\n\n"}
{"name":"VitaliFamily.le_mul_withDensity","module":"Mathlib.MeasureTheory.Covering.Differentiation","initialProofState":"Î± : Type u_1\ninstâœâ´ : PseudoMetricSpace Î±\nm0 : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nv : VitaliFamily Î¼\ninstâœÂ³ : SecondCountableTopology Î±\ninstâœÂ² : BorelSpace Î±\ninstâœÂ¹ : MeasureTheory.IsLocallyFiniteMeasure Î¼\nÏ : MeasureTheory.Measure Î±\ninstâœ : MeasureTheory.IsLocallyFiniteMeasure Ï\nhÏ : Ï.AbsolutelyContinuous Î¼\ns : Set Î±\nhs : MeasurableSet s\nt : NNReal\nht : LT.lt 1 t\nâŠ¢ LE.le (Ï s) (HMul.hMul (â†‘t) ((Î¼.withDensity (v.limRatioMeas hÏ)) s))","decl":"/-- As an intermediate step to show that `Î¼.withDensity (v.limRatioMeas hÏ) = Ï`, we show here\nthat `Ï â‰¤ t Î¼.withDensity (v.limRatioMeas hÏ)` for any `t > 1`. -/\ntheorem le_mul_withDensity {s : Set Î±} (hs : MeasurableSet s) {t : â„â‰¥0} (ht : 1 < t) :\n    Ï s â‰¤ t * Î¼.withDensity (v.limRatioMeas hÏ) s := by\n  /- We cut `s` into the sets where `v.limRatioMeas hÏ = 0`, where `v.limRatioMeas hÏ = âˆ`, and\n    where `v.limRatioMeas hÏ âˆˆ [t^n, t^(n+1))` for `n : â„¤`. The first and second have measure `0`.\n    For the latter, since `v.limRatioMeas hÏ` fluctuates by at most `t` on this slice, we can use\n    `measure_le_mul_of_subset_limRatioMeas_lt` and `mul_measure_le_of_subset_lt_limRatioMeas` to\n    show that the two measures are comparable up to `t`. -/\n  have t_ne_zero' : t â‰  0 := (zero_lt_one.trans ht).ne'\n  have t_ne_zero : (t : â„â‰¥0âˆ) â‰  0 := by simpa only [ENNReal.coe_eq_zero, Ne] using t_ne_zero'\n  let Î½ := Î¼.withDensity (v.limRatioMeas hÏ)\n  let f := v.limRatioMeas hÏ\n  have f_meas : Measurable f := v.limRatioMeas_measurable hÏ\n  have A : Ï (s âˆ© f â»Â¹' {0}) â‰¤ (t â€¢ Î½) (s âˆ© f â»Â¹' {0}) := by\n    refine le_trans (measure_mono inter_subset_right) (le_trans (le_of_eq ?_) (zero_le _))\n    exact v.measure_limRatioMeas_zero hÏ\n  have B : Ï (s âˆ© f â»Â¹' {âˆ}) â‰¤ (t â€¢ Î½) (s âˆ© f â»Â¹' {âˆ}) := by\n    apply le_trans (le_of_eq _) (zero_le _)\n    apply hÏ\n    rw [â† nonpos_iff_eq_zero]\n    exact (measure_mono inter_subset_right).trans (v.measure_limRatioMeas_top hÏ).le\n  have C :\n    âˆ€ n : â„¤,\n      Ï (s âˆ© f â»Â¹' Ico ((t : â„â‰¥0âˆ) ^ n) ((t : â„â‰¥0âˆ) ^ (n + 1))) â‰¤\n        (t â€¢ Î½) (s âˆ© f â»Â¹' Ico ((t : â„â‰¥0âˆ) ^ n) ((t : â„â‰¥0âˆ) ^ (n + 1))) := by\n    intro n\n    let I := Ico ((t : â„â‰¥0âˆ) ^ n) ((t : â„â‰¥0âˆ) ^ (n + 1))\n    have M : MeasurableSet (s âˆ© f â»Â¹' I) := hs.inter (f_meas measurableSet_Ico)\n    simp only [Î½, I, M, withDensity_apply, coe_nnreal_smul_apply]\n    calc\n      Ï (s âˆ© f â»Â¹' I) â‰¤ (t : â„â‰¥0âˆ) ^ (n + 1) * Î¼ (s âˆ© f â»Â¹' I) := by\n        rw [â† ENNReal.coe_zpow t_ne_zero']\n        apply v.measure_le_mul_of_subset_limRatioMeas_lt hÏ\n        intro x hx\n        apply hx.2.2.trans_le (le_of_eq _)\n        rw [ENNReal.coe_zpow t_ne_zero']\n      _ = âˆ«â» _ in s âˆ© f â»Â¹' I, (t : â„â‰¥0âˆ) ^ (n + 1) âˆ‚Î¼ := by\n        simp only [lintegral_const, MeasurableSet.univ, Measure.restrict_apply, univ_inter]\n      _ â‰¤ âˆ«â» x in s âˆ© f â»Â¹' I, t * f x âˆ‚Î¼ := by\n        apply lintegral_mono_ae ((ae_restrict_iff' M).2 (Eventually.of_forall fun x hx => ?_))\n        rw [add_comm, ENNReal.zpow_add t_ne_zero ENNReal.coe_ne_top, zpow_one]\n        exact mul_le_mul_left' hx.2.1 _\n      _ = t * âˆ«â» x in s âˆ© f â»Â¹' I, f x âˆ‚Î¼ := lintegral_const_mul _ f_meas\n  calc\n    Ï s =\n      Ï (s âˆ© f â»Â¹' {0}) + Ï (s âˆ© f â»Â¹' {âˆ}) +\n        âˆ‘' n : â„¤, Ï (s âˆ© f â»Â¹' Ico ((t : â„â‰¥0âˆ) ^ n) ((t : â„â‰¥0âˆ) ^ (n + 1))) :=\n      measure_eq_measure_preimage_add_measure_tsum_Ico_zpow Ï f_meas hs ht\n    _ â‰¤\n        (t â€¢ Î½) (s âˆ© f â»Â¹' {0}) + (t â€¢ Î½) (s âˆ© f â»Â¹' {âˆ}) +\n          âˆ‘' n : â„¤, (t â€¢ Î½) (s âˆ© f â»Â¹' Ico ((t : â„â‰¥0âˆ) ^ n) ((t : â„â‰¥0âˆ) ^ (n + 1))) :=\n      (add_le_add (add_le_add A B) (ENNReal.tsum_le_tsum C))\n    _ = (t â€¢ Î½) s :=\n      (measure_eq_measure_preimage_add_measure_tsum_Ico_zpow (t â€¢ Î½) f_meas hs ht).symm\n\n"}
{"name":"VitaliFamily.withDensity_limRatioMeas_eq","module":"Mathlib.MeasureTheory.Covering.Differentiation","initialProofState":"Î± : Type u_1\ninstâœâ´ : PseudoMetricSpace Î±\nm0 : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nv : VitaliFamily Î¼\ninstâœÂ³ : SecondCountableTopology Î±\ninstâœÂ² : BorelSpace Î±\ninstâœÂ¹ : MeasureTheory.IsLocallyFiniteMeasure Î¼\nÏ : MeasureTheory.Measure Î±\ninstâœ : MeasureTheory.IsLocallyFiniteMeasure Ï\nhÏ : Ï.AbsolutelyContinuous Î¼\nâŠ¢ Eq (Î¼.withDensity (v.limRatioMeas hÏ)) Ï","decl":"theorem withDensity_limRatioMeas_eq : Î¼.withDensity (v.limRatioMeas hÏ) = Ï := by\n  ext1 s hs\n  refine le_antisymm ?_ ?_\n  Â· have : Tendsto (fun t : â„â‰¥0 =>\n        ((t : â„â‰¥0âˆ) ^ 2 * Ï s : â„â‰¥0âˆ)) (ğ“[>] 1) (ğ“ ((1 : â„â‰¥0âˆ) ^ 2 * Ï s)) := by\n      refine ENNReal.Tendsto.mul ?_ ?_ tendsto_const_nhds ?_\n      Â· exact ENNReal.Tendsto.pow (ENNReal.tendsto_coe.2 nhdsWithin_le_nhds)\n      Â· simp only [one_pow, ENNReal.coe_one, true_or, Ne, not_false_iff, one_ne_zero]\n      Â· simp only [one_pow, ENNReal.coe_one, Ne, or_true, ENNReal.one_ne_top, not_false_iff]\n    simp only [one_pow, one_mul, ENNReal.coe_one] at this\n    refine ge_of_tendsto this ?_\n    filter_upwards [self_mem_nhdsWithin] with _ ht\n    exact v.withDensity_le_mul hÏ hs ht\n  Â· have :\n      Tendsto (fun t : â„â‰¥0 => (t : â„â‰¥0âˆ) * Î¼.withDensity (v.limRatioMeas hÏ) s) (ğ“[>] 1)\n        (ğ“ ((1 : â„â‰¥0âˆ) * Î¼.withDensity (v.limRatioMeas hÏ) s)) := by\n      refine ENNReal.Tendsto.mul_const (ENNReal.tendsto_coe.2 nhdsWithin_le_nhds) ?_\n      simp only [ENNReal.coe_one, true_or, Ne, not_false_iff, one_ne_zero]\n    simp only [one_mul, ENNReal.coe_one] at this\n    refine ge_of_tendsto this ?_\n    filter_upwards [self_mem_nhdsWithin] with _ ht\n    exact v.le_mul_withDensity hÏ hs ht\n\n"}
{"name":"VitaliFamily.ae_tendsto_rnDeriv_of_absolutelyContinuous","module":"Mathlib.MeasureTheory.Covering.Differentiation","initialProofState":"Î± : Type u_1\ninstâœâ´ : PseudoMetricSpace Î±\nm0 : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nv : VitaliFamily Î¼\ninstâœÂ³ : SecondCountableTopology Î±\ninstâœÂ² : BorelSpace Î±\ninstâœÂ¹ : MeasureTheory.IsLocallyFiniteMeasure Î¼\nÏ : MeasureTheory.Measure Î±\ninstâœ : MeasureTheory.IsLocallyFiniteMeasure Ï\nhÏ : Ï.AbsolutelyContinuous Î¼\nâŠ¢ Filter.Eventually (fun x => Filter.Tendsto (fun a => HDiv.hDiv (Ï a) (Î¼ a)) (v.filterAt x) (nhds (Ï.rnDeriv Î¼ x))) (MeasureTheory.ae Î¼)","decl":"/-- Weak version of the main theorem on differentiation of measures: given a Vitali family `v`\nfor a locally finite measure `Î¼`, and another locally finite measure `Ï`, then for `Î¼`-almost\nevery `x` the ratio `Ï a / Î¼ a` converges, when `a` shrinks to `x` along the Vitali family,\ntowards the Radon-Nikodym derivative of `Ï` with respect to `Î¼`.\n\nThis version assumes that `Ï` is absolutely continuous with respect to `Î¼`. The general version\nwithout this superfluous assumption is `VitaliFamily.ae_tendsto_rnDeriv`.\n-/\ntheorem ae_tendsto_rnDeriv_of_absolutelyContinuous :\n    âˆ€áµ x âˆ‚Î¼, Tendsto (fun a => Ï a / Î¼ a) (v.filterAt x) (ğ“ (Ï.rnDeriv Î¼ x)) := by\n  have A : (Î¼.withDensity (v.limRatioMeas hÏ)).rnDeriv Î¼ =áµ[Î¼] v.limRatioMeas hÏ :=\n    rnDeriv_withDensity Î¼ (v.limRatioMeas_measurable hÏ)\n  rw [v.withDensity_limRatioMeas_eq hÏ] at A\n  filter_upwards [v.ae_tendsto_limRatioMeas hÏ, A] with _ _ h'x\n  rwa [h'x]\n\n"}
{"name":"VitaliFamily.ae_tendsto_rnDeriv","module":"Mathlib.MeasureTheory.Covering.Differentiation","initialProofState":"Î± : Type u_1\ninstâœâ´ : PseudoMetricSpace Î±\nm0 : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nv : VitaliFamily Î¼\ninstâœÂ³ : SecondCountableTopology Î±\ninstâœÂ² : BorelSpace Î±\ninstâœÂ¹ : MeasureTheory.IsLocallyFiniteMeasure Î¼\nÏ : MeasureTheory.Measure Î±\ninstâœ : MeasureTheory.IsLocallyFiniteMeasure Ï\nâŠ¢ Filter.Eventually (fun x => Filter.Tendsto (fun a => HDiv.hDiv (Ï a) (Î¼ a)) (v.filterAt x) (nhds (Ï.rnDeriv Î¼ x))) (MeasureTheory.ae Î¼)","decl":"/-- Main theorem on differentiation of measures: given a Vitali family `v` for a locally finite\nmeasure `Î¼`, and another locally finite measure `Ï`, then for `Î¼`-almost every `x` the\nratio `Ï a / Î¼ a` converges, when `a` shrinks to `x` along the Vitali family, towards the\nRadon-Nikodym derivative of `Ï` with respect to `Î¼`. -/\ntheorem ae_tendsto_rnDeriv :\n    âˆ€áµ x âˆ‚Î¼, Tendsto (fun a => Ï a / Î¼ a) (v.filterAt x) (ğ“ (Ï.rnDeriv Î¼ x)) := by\n  let t := Î¼.withDensity (Ï.rnDeriv Î¼)\n  have eq_add : Ï = Ï.singularPart Î¼ + t := haveLebesgueDecomposition_add _ _\n  have A : âˆ€áµ x âˆ‚Î¼, Tendsto (fun a => Ï.singularPart Î¼ a / Î¼ a) (v.filterAt x) (ğ“ 0) :=\n    v.ae_eventually_measure_zero_of_singular (mutuallySingular_singularPart Ï Î¼)\n  have B : âˆ€áµ x âˆ‚Î¼, t.rnDeriv Î¼ x = Ï.rnDeriv Î¼ x :=\n    rnDeriv_withDensity Î¼ (measurable_rnDeriv Ï Î¼)\n  have C : âˆ€áµ x âˆ‚Î¼, Tendsto (fun a => t a / Î¼ a) (v.filterAt x) (ğ“ (t.rnDeriv Î¼ x)) :=\n    v.ae_tendsto_rnDeriv_of_absolutelyContinuous (withDensity_absolutelyContinuous _ _)\n  filter_upwards [A, B, C] with _ Ax Bx Cx\n  convert Ax.add Cx using 1\n  Â· ext1 a\n    conv_lhs => rw [eq_add]\n    simp only [Pi.add_apply, coe_add, ENNReal.add_div]\n  Â· simp only [Bx, zero_add]\n\n"}
{"name":"VitaliFamily.ae_tendsto_measure_inter_div_of_measurableSet","module":"Mathlib.MeasureTheory.Covering.Differentiation","initialProofState":"Î± : Type u_1\ninstâœÂ³ : PseudoMetricSpace Î±\nm0 : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nv : VitaliFamily Î¼\ninstâœÂ² : SecondCountableTopology Î±\ninstâœÂ¹ : BorelSpace Î±\ninstâœ : MeasureTheory.IsLocallyFiniteMeasure Î¼\ns : Set Î±\nhs : MeasurableSet s\nâŠ¢ Filter.Eventually (fun x => Filter.Tendsto (fun a => HDiv.hDiv (Î¼ (Inter.inter s a)) (Î¼ a)) (v.filterAt x) (nhds (s.indicator 1 x))) (MeasureTheory.ae Î¼)","decl":"/-- Given a measurable set `s`, then `Î¼ (s âˆ© a) / Î¼ a` converges when `a` shrinks to a typical\npoint `x` along a Vitali family. The limit is `1` for `x âˆˆ s` and `0` for `x âˆ‰ s`. This shows that\nalmost every point of `s` is a Lebesgue density point for `s`. A version for non-measurable sets\nholds, but it only gives the first conclusion, see `ae_tendsto_measure_inter_div`. -/\ntheorem ae_tendsto_measure_inter_div_of_measurableSet {s : Set Î±} (hs : MeasurableSet s) :\n    âˆ€áµ x âˆ‚Î¼, Tendsto (fun a => Î¼ (s âˆ© a) / Î¼ a) (v.filterAt x) (ğ“ (s.indicator 1 x)) := by\n  haveI : IsLocallyFiniteMeasure (Î¼.restrict s) :=\n    isLocallyFiniteMeasure_of_le restrict_le_self\n  filter_upwards [ae_tendsto_rnDeriv v (Î¼.restrict s), rnDeriv_restrict_self Î¼ hs]\n  intro x hx h'x\n  simpa only [h'x, restrict_apply' hs, inter_comm] using hx\n\n"}
{"name":"VitaliFamily.ae_tendsto_measure_inter_div","module":"Mathlib.MeasureTheory.Covering.Differentiation","initialProofState":"Î± : Type u_1\ninstâœÂ³ : PseudoMetricSpace Î±\nm0 : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nv : VitaliFamily Î¼\ninstâœÂ² : SecondCountableTopology Î±\ninstâœÂ¹ : BorelSpace Î±\ninstâœ : MeasureTheory.IsLocallyFiniteMeasure Î¼\ns : Set Î±\nâŠ¢ Filter.Eventually (fun x => Filter.Tendsto (fun a => HDiv.hDiv (Î¼ (Inter.inter s a)) (Î¼ a)) (v.filterAt x) (nhds 1)) (MeasureTheory.ae (Î¼.restrict s))","decl":"/-- Given an arbitrary set `s`, then `Î¼ (s âˆ© a) / Î¼ a` converges to `1` when `a` shrinks to a\ntypical point of `s` along a Vitali family. This shows that almost every point of `s` is a\nLebesgue density point for `s`. A stronger version for measurable sets is given\nin `ae_tendsto_measure_inter_div_of_measurableSet`. -/\ntheorem ae_tendsto_measure_inter_div (s : Set Î±) :\n    âˆ€áµ x âˆ‚Î¼.restrict s, Tendsto (fun a => Î¼ (s âˆ© a) / Î¼ a) (v.filterAt x) (ğ“ 1) := by\n  let t := toMeasurable Î¼ s\n  have A :\n    âˆ€áµ x âˆ‚Î¼.restrict s,\n      Tendsto (fun a => Î¼ (t âˆ© a) / Î¼ a) (v.filterAt x) (ğ“ (t.indicator 1 x)) := by\n    apply ae_mono restrict_le_self\n    apply ae_tendsto_measure_inter_div_of_measurableSet\n    exact measurableSet_toMeasurable _ _\n  have B : âˆ€áµ x âˆ‚Î¼.restrict s, t.indicator 1 x = (1 : â„â‰¥0âˆ) := by\n    refine ae_restrict_of_ae_restrict_of_subset (subset_toMeasurable Î¼ s) ?_\n    filter_upwards [ae_restrict_mem (measurableSet_toMeasurable Î¼ s)] with _ hx\n    simp only [t, hx, Pi.one_apply, indicator_of_mem]\n  filter_upwards [A, B] with x hx h'x\n  rw [h'x] at hx\n  apply hx.congr' _\n  filter_upwards [v.eventually_filterAt_measurableSet x] with _ ha\n  congr 1\n  exact measure_toMeasurable_inter_of_sFinite ha _\n\n"}
{"name":"VitaliFamily.ae_tendsto_lintegral_div'","module":"Mathlib.MeasureTheory.Covering.Differentiation","initialProofState":"Î± : Type u_1\ninstâœÂ³ : PseudoMetricSpace Î±\nm0 : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nv : VitaliFamily Î¼\ninstâœÂ² : SecondCountableTopology Î±\ninstâœÂ¹ : BorelSpace Î±\ninstâœ : MeasureTheory.IsLocallyFiniteMeasure Î¼\nf : Î± â†’ ENNReal\nhf : Measurable f\nh'f : Ne (MeasureTheory.lintegral Î¼ fun y => f y) Top.top\nâŠ¢ Filter.Eventually (fun x => Filter.Tendsto (fun a => HDiv.hDiv (MeasureTheory.lintegral (Î¼.restrict a) fun y => f y) (Î¼ a)) (v.filterAt x) (nhds (f x))) (MeasureTheory.ae Î¼)","decl":"theorem ae_tendsto_lintegral_div' {f : Î± â†’ â„â‰¥0âˆ} (hf : Measurable f) (h'f : (âˆ«â» y, f y âˆ‚Î¼) â‰  âˆ) :\n    âˆ€áµ x âˆ‚Î¼, Tendsto (fun a => (âˆ«â» y in a, f y âˆ‚Î¼) / Î¼ a) (v.filterAt x) (ğ“ (f x)) := by\n  let Ï := Î¼.withDensity f\n  have : IsFiniteMeasure Ï := isFiniteMeasure_withDensity h'f\n  filter_upwards [ae_tendsto_rnDeriv v Ï, rnDeriv_withDensity Î¼ hf] with x hx h'x\n  rw [â† h'x]\n  apply hx.congr' _\n  filter_upwards [v.eventually_filterAt_measurableSet x] with a ha\n  rw [â† withDensity_apply f ha]\n\n"}
{"name":"VitaliFamily.ae_tendsto_lintegral_div","module":"Mathlib.MeasureTheory.Covering.Differentiation","initialProofState":"Î± : Type u_1\ninstâœÂ³ : PseudoMetricSpace Î±\nm0 : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nv : VitaliFamily Î¼\ninstâœÂ² : SecondCountableTopology Î±\ninstâœÂ¹ : BorelSpace Î±\ninstâœ : MeasureTheory.IsLocallyFiniteMeasure Î¼\nf : Î± â†’ ENNReal\nhf : AEMeasurable f Î¼\nh'f : Ne (MeasureTheory.lintegral Î¼ fun y => f y) Top.top\nâŠ¢ Filter.Eventually (fun x => Filter.Tendsto (fun a => HDiv.hDiv (MeasureTheory.lintegral (Î¼.restrict a) fun y => f y) (Î¼ a)) (v.filterAt x) (nhds (f x))) (MeasureTheory.ae Î¼)","decl":"theorem ae_tendsto_lintegral_div {f : Î± â†’ â„â‰¥0âˆ} (hf : AEMeasurable f Î¼) (h'f : (âˆ«â» y, f y âˆ‚Î¼) â‰  âˆ) :\n    âˆ€áµ x âˆ‚Î¼, Tendsto (fun a => (âˆ«â» y in a, f y âˆ‚Î¼) / Î¼ a) (v.filterAt x) (ğ“ (f x)) := by\n  have A : (âˆ«â» y, hf.mk f y âˆ‚Î¼) â‰  âˆ := by\n    convert h'f using 1\n    apply lintegral_congr_ae\n    exact hf.ae_eq_mk.symm\n  filter_upwards [v.ae_tendsto_lintegral_div' hf.measurable_mk A, hf.ae_eq_mk] with x hx h'x\n  rw [h'x]\n  convert hx using 1\n  ext1 a\n  congr 1\n  apply lintegral_congr_ae\n  exact ae_restrict_of_ae hf.ae_eq_mk\n\n"}
{"name":"VitaliFamily.ae_tendsto_lintegral_enorm_sub_div'_of_integrable","module":"Mathlib.MeasureTheory.Covering.Differentiation","initialProofState":"Î± : Type u_1\ninstâœâ´ : PseudoMetricSpace Î±\nm0 : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nv : VitaliFamily Î¼\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : SecondCountableTopology Î±\ninstâœÂ¹ : BorelSpace Î±\ninstâœ : MeasureTheory.IsLocallyFiniteMeasure Î¼\nf : Î± â†’ E\nhf : MeasureTheory.Integrable f Î¼\nh'f : MeasureTheory.StronglyMeasurable f\nâŠ¢ Filter.Eventually (fun x => Filter.Tendsto (fun a => HDiv.hDiv (MeasureTheory.lintegral (Î¼.restrict a) fun y => ENorm.enorm (HSub.hSub (f y) (f x))) (Î¼ a)) (v.filterAt x) (nhds 0)) (MeasureTheory.ae Î¼)","decl":"theorem ae_tendsto_lintegral_enorm_sub_div'_of_integrable {f : Î± â†’ E} (hf : Integrable f Î¼)\n    (h'f : StronglyMeasurable f) :\n    âˆ€áµ x âˆ‚Î¼, Tendsto (fun a => (âˆ«â» y in a, â€–f y - f xâ€–â‚‘ âˆ‚Î¼) / Î¼ a) (v.filterAt x) (ğ“ 0) := by\n  /- For every `c`, then `(âˆ«â» y in a, â€–f y - câ€–â‚‘ âˆ‚Î¼) / Î¼ a` tends almost everywhere to `â€–f x - câ€–`.\n    We apply this to a countable set of `c` which is dense in the range of `f`, to deduce the\n    desired convergence.\n    A minor technical inconvenience is that constants are not integrable, so to apply previous\n    lemmas we need to replace `c` with the restriction of `c` to a finite measure set `A n` in the\n    above sketch. -/\n  let A := MeasureTheory.Measure.finiteSpanningSetsInOpen' Î¼\n  rcases h'f.isSeparable_range with âŸ¨t, t_count, htâŸ©\n  have main :\n    âˆ€áµ x âˆ‚Î¼,\n      âˆ€áµ‰ (n : â„•) (c âˆˆ t),\n        Tendsto (fun a => (âˆ«â» y in a, â€–f y - (A.set n).indicator (fun _ => c) yâ€–â‚‘ âˆ‚Î¼) / Î¼ a)\n          (v.filterAt x) (ğ“ â€–f x - (A.set n).indicator (fun _ => c) xâ€–â‚‘) := by\n    #adaptation_note /-- 2024-04-23\n    The next two lines were previously just `simp_rw [ae_all_iff, ae_ball_iff t_count]`. -/\n    simp_rw [ae_all_iff]\n    intro x; rw [ae_ball_iff t_count]; revert x\n    intro n c _\n    apply ae_tendsto_lintegral_div'\n    Â· refine (h'f.sub ?_).enorm\n      exact stronglyMeasurable_const.indicator (IsOpen.measurableSet (A.set_mem n))\n    Â· apply ne_of_lt\n      calc\n        âˆ«â» y, â€–f y - (A.set n).indicator (fun _ : Î± => c) yâ€–â‚‘ âˆ‚Î¼\n          â‰¤ âˆ«â» y, â€–f yâ€–â‚‘ + â€–(A.set n).indicator (fun _ : Î± => c) yâ€–â‚‘ âˆ‚Î¼ :=\n          lintegral_mono fun x â†¦ enorm_sub_le\n        _ = âˆ«â» y, â€–f yâ€–â‚‘ âˆ‚Î¼ + âˆ«â» y, â€–(A.set n).indicator (fun _ : Î± => c) yâ€–â‚‘ âˆ‚Î¼ :=\n          lintegral_add_left h'f.enorm _\n        _ < âˆ + âˆ :=\n          haveI I : Integrable ((A.set n).indicator fun _ : Î± => c) Î¼ := by\n            simp only [integrable_indicator_iff (IsOpen.measurableSet (A.set_mem n)),\n              integrableOn_const, A.finite n, or_true]\n          ENNReal.add_lt_add hf.2 I.2\n  filter_upwards [main, v.ae_eventually_measure_pos] with x hx h'x\n  have M c (hc : c âˆˆ t) :\n      Tendsto (fun a => (âˆ«â» y in a, â€–f y - câ€–â‚‘ âˆ‚Î¼) / Î¼ a) (v.filterAt x) (ğ“ â€–f x - câ€–â‚‘) := by\n    obtain âŸ¨n, xnâŸ© : âˆƒ n, x âˆˆ A.set n := by simpa [â† A.spanning] using mem_univ x\n    specialize hx n c hc\n    simp only [xn, indicator_of_mem] at hx\n    apply hx.congr' _\n    filter_upwards [v.eventually_filterAt_subset_of_nhds (IsOpen.mem_nhds (A.set_mem n) xn),\n      v.eventually_filterAt_measurableSet x] with a ha h'a\n    congr 1\n    apply setLIntegral_congr_fun h'a\n    filter_upwards with y hy using (by simp only [ha hy, indicator_of_mem])\n  apply ENNReal.tendsto_nhds_zero.2 fun Îµ Îµpos => ?_\n  obtain âŸ¨c, ct, xcâŸ© : âˆƒ c âˆˆ t, â€–f x - câ€–â‚‘ < Îµ / 2 := by\n    simp_rw [â† edist_eq_enorm_sub]\n    have : f x âˆˆ closure t := ht (mem_range_self _)\n    exact EMetric.mem_closure_iff.1 this (Îµ / 2) (ENNReal.half_pos (ne_of_gt Îµpos))\n  filter_upwards [(tendsto_order.1 (M c ct)).2 (Îµ / 2) xc, h'x, v.eventually_measure_lt_top x] with\n    a ha h'a h''a\n  apply ENNReal.div_le_of_le_mul\n  calc\n    (âˆ«â» y in a, â€–f y - f xâ€–â‚‘ âˆ‚Î¼) â‰¤ âˆ«â» y in a, â€–f y - câ€–â‚‘ + â€–f x - câ€–â‚‘ âˆ‚Î¼ := by\n      apply lintegral_mono fun x => ?_\n      simpa only [â† edist_eq_enorm_sub] using edist_triangle_right _ _ _\n    _ = (âˆ«â» y in a, â€–f y - câ€–â‚‘ âˆ‚Î¼) + âˆ«â» _ in a, â€–f x - câ€–â‚‘ âˆ‚Î¼ :=\n      (lintegral_add_right _ measurable_const)\n    _ â‰¤ Îµ / 2 * Î¼ a + Îµ / 2 * Î¼ a := by\n      gcongr\n      Â· rw [ENNReal.div_lt_iff (Or.inl h'a.ne') (Or.inl h''a.ne)] at ha\n        exact ha.le\n      Â· simp only [lintegral_const, Measure.restrict_apply, MeasurableSet.univ, univ_inter]\n        gcongr\n    _ = Îµ * Î¼ a := by rw [â† add_mul, ENNReal.add_halves]\n\n"}
{"name":"VitaliFamily.ae_tendsto_lintegral_nnnorm_sub_div'_of_integrable","module":"Mathlib.MeasureTheory.Covering.Differentiation","initialProofState":"Î± : Type u_1\ninstâœâ´ : PseudoMetricSpace Î±\nm0 : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nv : VitaliFamily Î¼\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : SecondCountableTopology Î±\ninstâœÂ¹ : BorelSpace Î±\ninstâœ : MeasureTheory.IsLocallyFiniteMeasure Î¼\nf : Î± â†’ E\nhf : MeasureTheory.Integrable f Î¼\nh'f : MeasureTheory.StronglyMeasurable f\nâŠ¢ Filter.Eventually (fun x => Filter.Tendsto (fun a => HDiv.hDiv (MeasureTheory.lintegral (Î¼.restrict a) fun y => ENorm.enorm (HSub.hSub (f y) (f x))) (Î¼ a)) (v.filterAt x) (nhds 0)) (MeasureTheory.ae Î¼)","decl":"@[deprecated (since := \"2025-01-22\")]\nalias ae_tendsto_lintegral_nnnorm_sub_div'_of_integrable :=\n  ae_tendsto_lintegral_enorm_sub_div'_of_integrable\n\n"}
{"name":"VitaliFamily.ae_tendsto_lintegral_enorm_sub_div_of_integrable","module":"Mathlib.MeasureTheory.Covering.Differentiation","initialProofState":"Î± : Type u_1\ninstâœâ´ : PseudoMetricSpace Î±\nm0 : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nv : VitaliFamily Î¼\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : SecondCountableTopology Î±\ninstâœÂ¹ : BorelSpace Î±\ninstâœ : MeasureTheory.IsLocallyFiniteMeasure Î¼\nf : Î± â†’ E\nhf : MeasureTheory.Integrable f Î¼\nâŠ¢ Filter.Eventually (fun x => Filter.Tendsto (fun a => HDiv.hDiv (MeasureTheory.lintegral (Î¼.restrict a) fun y => ENorm.enorm (HSub.hSub (f y) (f x))) (Î¼ a)) (v.filterAt x) (nhds 0)) (MeasureTheory.ae Î¼)","decl":"theorem ae_tendsto_lintegral_enorm_sub_div_of_integrable {f : Î± â†’ E} (hf : Integrable f Î¼) :\n    âˆ€áµ x âˆ‚Î¼, Tendsto (fun a => (âˆ«â» y in a, â€–f y - f xâ€–â‚‘ âˆ‚Î¼) / Î¼ a) (v.filterAt x) (ğ“ 0) := by\n  have I : Integrable (hf.1.mk f) Î¼ := hf.congr hf.1.ae_eq_mk\n  filter_upwards [v.ae_tendsto_lintegral_enorm_sub_div'_of_integrable I hf.1.stronglyMeasurable_mk,\n    hf.1.ae_eq_mk] with x hx h'x\n  apply hx.congr _\n  intro a\n  congr 1\n  apply lintegral_congr_ae\n  apply ae_restrict_of_ae\n  filter_upwards [hf.1.ae_eq_mk] with y hy\n  rw [hy, h'x]\n\n"}
{"name":"VitaliFamily.ae_tendsto_lintegral_nnnorm_sub_div_of_integrable","module":"Mathlib.MeasureTheory.Covering.Differentiation","initialProofState":"Î± : Type u_1\ninstâœâ´ : PseudoMetricSpace Î±\nm0 : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nv : VitaliFamily Î¼\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : SecondCountableTopology Î±\ninstâœÂ¹ : BorelSpace Î±\ninstâœ : MeasureTheory.IsLocallyFiniteMeasure Î¼\nf : Î± â†’ E\nhf : MeasureTheory.Integrable f Î¼\nâŠ¢ Filter.Eventually (fun x => Filter.Tendsto (fun a => HDiv.hDiv (MeasureTheory.lintegral (Î¼.restrict a) fun y => ENorm.enorm (HSub.hSub (f y) (f x))) (Î¼ a)) (v.filterAt x) (nhds 0)) (MeasureTheory.ae Î¼)","decl":"@[deprecated (since := \"2025-01-22\")]\nalias ae_tendsto_lintegral_nnnorm_sub_div_of_integrable :=\n  ae_tendsto_lintegral_enorm_sub_div_of_integrable\n\n"}
{"name":"VitaliFamily.ae_tendsto_lintegral_enorm_sub_div","module":"Mathlib.MeasureTheory.Covering.Differentiation","initialProofState":"Î± : Type u_1\ninstâœâ´ : PseudoMetricSpace Î±\nm0 : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nv : VitaliFamily Î¼\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : SecondCountableTopology Î±\ninstâœÂ¹ : BorelSpace Î±\ninstâœ : MeasureTheory.IsLocallyFiniteMeasure Î¼\nf : Î± â†’ E\nhf : MeasureTheory.LocallyIntegrable f Î¼\nâŠ¢ Filter.Eventually (fun x => Filter.Tendsto (fun a => HDiv.hDiv (MeasureTheory.lintegral (Î¼.restrict a) fun y => ENorm.enorm (HSub.hSub (f y) (f x))) (Î¼ a)) (v.filterAt x) (nhds 0)) (MeasureTheory.ae Î¼)","decl":"theorem ae_tendsto_lintegral_enorm_sub_div {f : Î± â†’ E} (hf : LocallyIntegrable f Î¼) :\n    âˆ€áµ x âˆ‚Î¼, Tendsto (fun a => (âˆ«â» y in a, â€–f y - f xâ€–â‚‘ âˆ‚Î¼) / Î¼ a) (v.filterAt x) (ğ“ 0) := by\n  rcases hf.exists_nat_integrableOn with âŸ¨u, u_open, u_univ, huâŸ©\n  have : âˆ€ n, âˆ€áµ x âˆ‚Î¼,\n      Tendsto (fun a => (âˆ«â» y in a, â€–(u n).indicator f y - (u n).indicator f xâ€–â‚‘ âˆ‚Î¼) / Î¼ a)\n      (v.filterAt x) (ğ“ 0) := by\n    intro n\n    apply ae_tendsto_lintegral_enorm_sub_div_of_integrable\n    exact (integrable_indicator_iff (u_open n).measurableSet).2 (hu n)\n  filter_upwards [ae_all_iff.2 this] with x hx\n  obtain âŸ¨n, hnâŸ© : âˆƒ n, x âˆˆ u n := by simpa only [â† u_univ, mem_iUnion] using mem_univ x\n  apply Tendsto.congr' _ (hx n)\n  filter_upwards [v.eventually_filterAt_subset_of_nhds ((u_open n).mem_nhds hn),\n    v.eventually_filterAt_measurableSet x] with a ha h'a\n  congr 1\n  refine setLIntegral_congr_fun h'a (Eventually.of_forall (fun y hy â†¦ ?_))\n  rw [indicator_of_mem (ha hy) f, indicator_of_mem hn f]\n\n"}
{"name":"VitaliFamily.ae_tendsto_lintegral_nnnorm_sub_div","module":"Mathlib.MeasureTheory.Covering.Differentiation","initialProofState":"Î± : Type u_1\ninstâœâ´ : PseudoMetricSpace Î±\nm0 : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nv : VitaliFamily Î¼\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : SecondCountableTopology Î±\ninstâœÂ¹ : BorelSpace Î±\ninstâœ : MeasureTheory.IsLocallyFiniteMeasure Î¼\nf : Î± â†’ E\nhf : MeasureTheory.LocallyIntegrable f Î¼\nâŠ¢ Filter.Eventually (fun x => Filter.Tendsto (fun a => HDiv.hDiv (MeasureTheory.lintegral (Î¼.restrict a) fun y => ENorm.enorm (HSub.hSub (f y) (f x))) (Î¼ a)) (v.filterAt x) (nhds 0)) (MeasureTheory.ae Î¼)","decl":"@[deprecated (since := \"2025-01-22\")]\nalias ae_tendsto_lintegral_nnnorm_sub_div := ae_tendsto_lintegral_enorm_sub_div\n\n"}
{"name":"VitaliFamily.ae_tendsto_average_norm_sub","module":"Mathlib.MeasureTheory.Covering.Differentiation","initialProofState":"Î± : Type u_1\ninstâœâ´ : PseudoMetricSpace Î±\nm0 : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nv : VitaliFamily Î¼\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : SecondCountableTopology Î±\ninstâœÂ¹ : BorelSpace Î±\ninstâœ : MeasureTheory.IsLocallyFiniteMeasure Î¼\nf : Î± â†’ E\nhf : MeasureTheory.LocallyIntegrable f Î¼\nâŠ¢ Filter.Eventually (fun x => Filter.Tendsto (fun a => MeasureTheory.average (Î¼.restrict a) fun y => Norm.norm (HSub.hSub (f y) (f x))) (v.filterAt x) (nhds 0)) (MeasureTheory.ae Î¼)","decl":"/-- *Lebesgue differentiation theorem*: for almost every point `x`, the\naverage of `â€–f y - f xâ€–` on `a` tends to `0` as `a` shrinks to `x` along a Vitali family. -/\ntheorem ae_tendsto_average_norm_sub {f : Î± â†’ E} (hf : LocallyIntegrable f Î¼) :\n    âˆ€áµ x âˆ‚Î¼, Tendsto (fun a => â¨ y in a, â€–f y - f xâ€– âˆ‚Î¼) (v.filterAt x) (ğ“ 0) := by\n  filter_upwards [v.ae_tendsto_lintegral_enorm_sub_div hf] with x hx\n  have := (ENNReal.tendsto_toReal ENNReal.zero_ne_top).comp hx\n  simp only [ENNReal.zero_toReal] at this\n  apply Tendsto.congr' _ this\n  filter_upwards [v.eventually_measure_lt_top x, v.eventually_filterAt_integrableOn x hf]\n    with a h'a h''a\n  simp only [Function.comp_apply, ENNReal.toReal_div, setAverage_eq, div_eq_inv_mul]\n  have A : IntegrableOn (fun y => (â€–f y - f xâ€–â‚Š : â„)) a Î¼ := by\n    simp_rw [coe_nnnorm]\n    exact (h''a.sub (integrableOn_const.2 (Or.inr h'a))).norm\n  dsimp [enorm]\n  rw [lintegral_coe_eq_integral _ A, ENNReal.toReal_ofReal (by positivity)]\n  simp only [coe_nnnorm, smul_eq_mul]\n\n"}
{"name":"VitaliFamily.ae_tendsto_average","module":"Mathlib.MeasureTheory.Covering.Differentiation","initialProofState":"Î± : Type u_1\ninstâœâ¶ : PseudoMetricSpace Î±\nm0 : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nv : VitaliFamily Î¼\nE : Type u_2\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : SecondCountableTopology Î±\ninstâœÂ³ : BorelSpace Î±\ninstâœÂ² : MeasureTheory.IsLocallyFiniteMeasure Î¼\ninstâœÂ¹ : NormedSpace Real E\ninstâœ : CompleteSpace E\nf : Î± â†’ E\nhf : MeasureTheory.LocallyIntegrable f Î¼\nâŠ¢ Filter.Eventually (fun x => Filter.Tendsto (fun a => MeasureTheory.average (Î¼.restrict a) fun y => f y) (v.filterAt x) (nhds (f x))) (MeasureTheory.ae Î¼)","decl":"/-- *Lebesgue differentiation theorem*: for almost every point `x`, the\naverage of `f` on `a` tends to `f x` as `a` shrinks to `x` along a Vitali family. -/\ntheorem ae_tendsto_average [NormedSpace â„ E] [CompleteSpace E] {f : Î± â†’ E}\n    (hf : LocallyIntegrable f Î¼) :\n    âˆ€áµ x âˆ‚Î¼, Tendsto (fun a => â¨ y in a, f y âˆ‚Î¼) (v.filterAt x) (ğ“ (f x)) := by\n  filter_upwards [v.ae_tendsto_average_norm_sub hf, v.ae_eventually_measure_pos] with x hx h'x\n  rw [tendsto_iff_norm_sub_tendsto_zero]\n  refine squeeze_zero' (Eventually.of_forall fun a => norm_nonneg _) ?_ hx\n  filter_upwards [h'x, v.eventually_measure_lt_top x, v.eventually_filterAt_integrableOn x hf]\n    with a ha h'a h''a\n  nth_rw 1 [â† setAverage_const ha.ne' h'a.ne (f x)]\n  simp_rw [setAverage_eq']\n  rw [â† integral_sub]\n  Â· exact norm_integral_le_integral_norm _\n  Â· exact (integrable_inv_smul_measure ha.ne' h'a.ne).2 h''a\n  Â· exact (integrable_inv_smul_measure ha.ne' h'a.ne).2 (integrableOn_const.2 (Or.inr h'a))\n\n"}
