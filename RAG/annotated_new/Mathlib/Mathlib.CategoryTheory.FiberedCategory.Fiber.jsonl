{"name":"CategoryTheory.Functor.Fiber.instIsHomLiftIdMapFiberInclusion","module":"Mathlib.CategoryTheory.FiberedCategory.Fiber","initialProofState":"ğ’® : Type uâ‚\nğ’³ : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} ğ’®\ninstâœ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} ğ’³\np : CategoryTheory.Functor ğ’³ ğ’®\nS : ğ’®\na b : p.Fiber S\nÏ† : Quiver.Hom a b\nâŠ¢ p.IsHomLift (CategoryTheory.CategoryStruct.id S) (CategoryTheory.Functor.Fiber.fiberInclusion.map Ï†)","decl":"instance {a b : Fiber p S} (Ï† : a âŸ¶ b) : IsHomLift p (ğŸ™ S) (fiberInclusion.map Ï†) := Ï†.2\n\n"}
{"name":"CategoryTheory.Functor.Fiber.hom_ext_iff","module":"Mathlib.CategoryTheory.FiberedCategory.Fiber","initialProofState":"ğ’® : Type uâ‚\nğ’³ : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} ğ’®\ninstâœ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} ğ’³\np : CategoryTheory.Functor ğ’³ ğ’®\nS : ğ’®\na b : p.Fiber S\nÏ† Ïˆ : Quiver.Hom a b\nâŠ¢ Iff (Eq Ï† Ïˆ) (Eq (CategoryTheory.Functor.Fiber.fiberInclusion.map Ï†) (CategoryTheory.Functor.Fiber.fiberInclusion.map Ïˆ))","decl":"@[ext]\nlemma hom_ext {a b : Fiber p S} {Ï† Ïˆ : a âŸ¶ b}\n    (h : fiberInclusion.map Ï† = fiberInclusion.map Ïˆ) : Ï† = Ïˆ :=\n  Subtype.ext h\n\n"}
{"name":"CategoryTheory.Functor.Fiber.hom_ext","module":"Mathlib.CategoryTheory.FiberedCategory.Fiber","initialProofState":"ğ’® : Type uâ‚\nğ’³ : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} ğ’®\ninstâœ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} ğ’³\np : CategoryTheory.Functor ğ’³ ğ’®\nS : ğ’®\na b : p.Fiber S\nÏ† Ïˆ : Quiver.Hom a b\nh : Eq (CategoryTheory.Functor.Fiber.fiberInclusion.map Ï†) (CategoryTheory.Functor.Fiber.fiberInclusion.map Ïˆ)\nâŠ¢ Eq Ï† Ïˆ","decl":"@[ext]\nlemma hom_ext {a b : Fiber p S} {Ï† Ïˆ : a âŸ¶ b}\n    (h : fiberInclusion.map Ï† = fiberInclusion.map Ïˆ) : Ï† = Ïˆ :=\n  Subtype.ext h\n\n"}
{"name":"CategoryTheory.Functor.Fiber.instFaithfulFiberInclusion","module":"Mathlib.CategoryTheory.FiberedCategory.Fiber","initialProofState":"ğ’® : Type uâ‚\nğ’³ : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} ğ’®\ninstâœ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} ğ’³\np : CategoryTheory.Functor ğ’³ ğ’®\nS : ğ’®\nâŠ¢ CategoryTheory.Functor.Fiber.fiberInclusion.Faithful","decl":"instance : (fiberInclusion : Fiber p S â¥¤ _).Faithful where\n\n"}
{"name":"CategoryTheory.Functor.Fiber.fiberInclusionCompIsoConst_hom_app","module":"Mathlib.CategoryTheory.FiberedCategory.Fiber","initialProofState":"ğ’® : Type uâ‚\nğ’³ : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} ğ’®\ninstâœ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} ğ’³\np : CategoryTheory.Functor ğ’³ ğ’®\nS : ğ’®\nX : p.Fiber S\nâŠ¢ Eq (CategoryTheory.Functor.Fiber.fiberInclusionCompIsoConst.hom.app X) (CategoryTheory.eqToHom â‹¯)","decl":"/-- For fixed `S : ğ’®` this is the natural isomorphism between `fiberInclusion â‹™ p` and the constant\nfunction valued at `S`. -/\n@[simps!]\ndef fiberInclusionCompIsoConst : fiberInclusion â‹™ p â‰… (const (Fiber p S)).obj S :=\n  NatIso.ofComponents (fun X â†¦ eqToIso X.2)\n    (fun Ï† â†¦ by simp [IsHomLift.fac' p (ğŸ™ S) (fiberInclusion.map Ï†)])\n\n"}
{"name":"CategoryTheory.Functor.Fiber.fiberInclusionCompIsoConst_inv_app","module":"Mathlib.CategoryTheory.FiberedCategory.Fiber","initialProofState":"ğ’® : Type uâ‚\nğ’³ : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} ğ’®\ninstâœ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} ğ’³\np : CategoryTheory.Functor ğ’³ ğ’®\nS : ğ’®\nX : p.Fiber S\nâŠ¢ Eq (CategoryTheory.Functor.Fiber.fiberInclusionCompIsoConst.inv.app X) (CategoryTheory.eqToHom â‹¯)","decl":"/-- For fixed `S : ğ’®` this is the natural isomorphism between `fiberInclusion â‹™ p` and the constant\nfunction valued at `S`. -/\n@[simps!]\ndef fiberInclusionCompIsoConst : fiberInclusion â‹™ p â‰… (const (Fiber p S)).obj S :=\n  NatIso.ofComponents (fun X â†¦ eqToIso X.2)\n    (fun Ï† â†¦ by simp [IsHomLift.fac' p (ğŸ™ S) (fiberInclusion.map Ï†)])\n\n"}
{"name":"CategoryTheory.Functor.Fiber.fiberInclusion_comp_eq_const","module":"Mathlib.CategoryTheory.FiberedCategory.Fiber","initialProofState":"ğ’® : Type uâ‚\nğ’³ : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} ğ’®\ninstâœ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} ğ’³\np : CategoryTheory.Functor ğ’³ ğ’®\nS : ğ’®\nâŠ¢ Eq (CategoryTheory.Functor.Fiber.fiberInclusion.comp p) ((CategoryTheory.Functor.const (p.Fiber S)).obj S)","decl":"lemma fiberInclusion_comp_eq_const : fiberInclusion â‹™ p = (const (Fiber p S)).obj S :=\n  Functor.ext (fun x â†¦ x.2) (fun _ _ Ï† â†¦ IsHomLift.fac' p (ğŸ™ S) (fiberInclusion.map Ï†))\n\n"}
{"name":"CategoryTheory.Functor.Fiber.fiberInclusion_mk","module":"Mathlib.CategoryTheory.FiberedCategory.Fiber","initialProofState":"ğ’® : Type uâ‚\nğ’³ : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} ğ’®\ninstâœ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} ğ’³\np : CategoryTheory.Functor ğ’³ ğ’®\nS : ğ’®\na : ğ’³\nha : Eq (p.obj a) S\nâŠ¢ Eq (CategoryTheory.Functor.Fiber.fiberInclusion.obj (CategoryTheory.Functor.Fiber.mk ha)) a","decl":"@[simp]\nlemma fiberInclusion_mk {p : ğ’³ â¥¤ ğ’®} {S : ğ’®} {a : ğ’³} (ha : p.obj a = S) :\n    fiberInclusion.obj (mk ha) = a :=\n  rfl\n\n"}
{"name":"CategoryTheory.Functor.Fiber.fiberInclusion_homMk","module":"Mathlib.CategoryTheory.FiberedCategory.Fiber","initialProofState":"ğ’® : Type uâ‚\nğ’³ : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} ğ’®\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} ğ’³\np : CategoryTheory.Functor ğ’³ ğ’®\nS : ğ’®\na b : ğ’³\nÏ† : Quiver.Hom a b\ninstâœ : p.IsHomLift (CategoryTheory.CategoryStruct.id S) Ï†\nâŠ¢ Eq (CategoryTheory.Functor.Fiber.fiberInclusion.map (CategoryTheory.Functor.Fiber.homMk p S Ï†)) Ï†","decl":"@[simp]\nlemma fiberInclusion_homMk (p : ğ’³ â¥¤ ğ’®) (S : ğ’®) {a b : ğ’³} (Ï† : a âŸ¶ b) [IsHomLift p (ğŸ™ S) Ï†] :\n    fiberInclusion.map (homMk p S Ï†) = Ï† :=\n  rfl\n\n"}
{"name":"CategoryTheory.Functor.Fiber.homMk_id","module":"Mathlib.CategoryTheory.FiberedCategory.Fiber","initialProofState":"ğ’® : Type uâ‚\nğ’³ : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} ğ’®\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} ğ’³\np : CategoryTheory.Functor ğ’³ ğ’®\nS : ğ’®\na : ğ’³\ninstâœ : p.IsHomLift (CategoryTheory.CategoryStruct.id S) (CategoryTheory.CategoryStruct.id a)\nâŠ¢ Eq (CategoryTheory.Functor.Fiber.homMk p S (CategoryTheory.CategoryStruct.id a)) (CategoryTheory.CategoryStruct.id (CategoryTheory.Functor.Fiber.mk â‹¯))","decl":"@[simp]\nlemma homMk_id (p : ğ’³ â¥¤ ğ’®) (S : ğ’®) (a : ğ’³) [IsHomLift p (ğŸ™ S) (ğŸ™ a)] :\n    homMk p S (ğŸ™ a) = ğŸ™ (mk (domain_eq p (ğŸ™ S) (ğŸ™ a))) :=\n  rfl\n\n"}
{"name":"CategoryTheory.Functor.Fiber.homMk_comp","module":"Mathlib.CategoryTheory.FiberedCategory.Fiber","initialProofState":"ğ’® : Type uâ‚\nğ’³ : Type uâ‚‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} ğ’®\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} ğ’³\np : CategoryTheory.Functor ğ’³ ğ’®\nS : ğ’®\na b c : ğ’³\nÏ† : Quiver.Hom a b\nÏˆ : Quiver.Hom b c\ninstâœÂ¹ : p.IsHomLift (CategoryTheory.CategoryStruct.id S) Ï†\ninstâœ : p.IsHomLift (CategoryTheory.CategoryStruct.id S) Ïˆ\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.Fiber.homMk p S Ï†) (CategoryTheory.Functor.Fiber.homMk p S Ïˆ)) (CategoryTheory.Functor.Fiber.homMk p S (CategoryTheory.CategoryStruct.comp Ï† Ïˆ))","decl":"@[simp]\nlemma homMk_comp {a b c : ğ’³} (Ï† : a âŸ¶ b) (Ïˆ : b âŸ¶ c) [IsHomLift p (ğŸ™ S) Ï†]\n    [IsHomLift p (ğŸ™ S) Ïˆ] : homMk p S Ï† â‰« homMk p S Ïˆ = homMk p S (Ï† â‰« Ïˆ) :=\n  rfl\n\n"}
{"name":"CategoryTheory.Functor.Fiber.inducedFunctor_map","module":"Mathlib.CategoryTheory.FiberedCategory.Fiber","initialProofState":"ğ’® : Type uâ‚\nğ’³ : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} ğ’®\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} ğ’³\np : CategoryTheory.Functor ğ’³ ğ’®\nS : ğ’®\nC : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} C\nF : CategoryTheory.Functor C ğ’³\nhF : Eq (F.comp p) ((CategoryTheory.Functor.const C).obj S)\nX Y : C\nf : Quiver.Hom X Y\nâŠ¢ Eq (CategoryTheory.Functor.Fiber.fiberInclusion.map ((CategoryTheory.Functor.Fiber.inducedFunctor hF).map f)) (F.map f)","decl":"@[simp]\nlemma inducedFunctor_map {X Y : C} (f : X âŸ¶ Y) :\n    fiberInclusion.map ((inducedFunctor hF).map f) = F.map f := rfl\n\n"}
{"name":"CategoryTheory.Functor.Fiber.inducedFunctorCompIsoSelf_inv_app","module":"Mathlib.CategoryTheory.FiberedCategory.Fiber","initialProofState":"ğ’® : Type uâ‚\nğ’³ : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} ğ’®\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} ğ’³\np : CategoryTheory.Functor ğ’³ ğ’®\nS : ğ’®\nC : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} C\nF : CategoryTheory.Functor C ğ’³\nhF : Eq (F.comp p) ((CategoryTheory.Functor.const C).obj S)\nX : C\nâŠ¢ Eq ((CategoryTheory.Functor.Fiber.inducedFunctorCompIsoSelf hF).inv.app X) (CategoryTheory.CategoryStruct.id (CategoryTheory.Functor.Fiber.fiberInclusion.obj ((CategoryTheory.Functor.Fiber.inducedFunctor hF).obj X)))","decl":"/-- Given a functor `F : C â¥¤ ğ’³` such that `F â‹™ p` is constant at some `S : ğ’®`, then\nwe get a natural isomorphism between `inducedFunctor _ â‹™ fiberInclusion` and `F`. -/\n@[simps!]\ndef inducedFunctorCompIsoSelf : (inducedFunctor hF) â‹™ fiberInclusion â‰… F := Iso.refl _\n\n"}
{"name":"CategoryTheory.Functor.Fiber.inducedFunctorCompIsoSelf_hom_app","module":"Mathlib.CategoryTheory.FiberedCategory.Fiber","initialProofState":"ğ’® : Type uâ‚\nğ’³ : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} ğ’®\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} ğ’³\np : CategoryTheory.Functor ğ’³ ğ’®\nS : ğ’®\nC : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} C\nF : CategoryTheory.Functor C ğ’³\nhF : Eq (F.comp p) ((CategoryTheory.Functor.const C).obj S)\nX : C\nâŠ¢ Eq ((CategoryTheory.Functor.Fiber.inducedFunctorCompIsoSelf hF).hom.app X) (CategoryTheory.CategoryStruct.id (CategoryTheory.Functor.Fiber.fiberInclusion.obj ((CategoryTheory.Functor.Fiber.inducedFunctor hF).obj X)))","decl":"/-- Given a functor `F : C â¥¤ ğ’³` such that `F â‹™ p` is constant at some `S : ğ’®`, then\nwe get a natural isomorphism between `inducedFunctor _ â‹™ fiberInclusion` and `F`. -/\n@[simps!]\ndef inducedFunctorCompIsoSelf : (inducedFunctor hF) â‹™ fiberInclusion â‰… F := Iso.refl _\n\n"}
{"name":"CategoryTheory.Functor.Fiber.inducedFunctor_comp","module":"Mathlib.CategoryTheory.FiberedCategory.Fiber","initialProofState":"ğ’® : Type uâ‚\nğ’³ : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} ğ’®\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} ğ’³\np : CategoryTheory.Functor ğ’³ ğ’®\nS : ğ’®\nC : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} C\nF : CategoryTheory.Functor C ğ’³\nhF : Eq (F.comp p) ((CategoryTheory.Functor.const C).obj S)\nâŠ¢ Eq ((CategoryTheory.Functor.Fiber.inducedFunctor hF).comp CategoryTheory.Functor.Fiber.fiberInclusion) F","decl":"lemma inducedFunctor_comp : (inducedFunctor hF) â‹™ fiberInclusion = F := rfl\n\n"}
