{"name":"CategoryTheory.Functor.Fiber.instIsHomLiftIdMapFiberInclusion","module":"Mathlib.CategoryTheory.FiberedCategory.Fiber","initialProofState":"𝒮 : Type u₁\n𝒳 : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} 𝒮\ninst✝ : CategoryTheory.Category.{v₂, u₂} 𝒳\np : CategoryTheory.Functor 𝒳 𝒮\nS : 𝒮\na b : p.Fiber S\nφ : Quiver.Hom a b\n⊢ p.IsHomLift (CategoryTheory.CategoryStruct.id S) (CategoryTheory.Functor.Fiber.fiberInclusion.map φ)","decl":"instance {a b : Fiber p S} (φ : a ⟶ b) : IsHomLift p (𝟙 S) (fiberInclusion.map φ) := φ.2\n\n"}
{"name":"CategoryTheory.Functor.Fiber.hom_ext_iff","module":"Mathlib.CategoryTheory.FiberedCategory.Fiber","initialProofState":"𝒮 : Type u₁\n𝒳 : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} 𝒮\ninst✝ : CategoryTheory.Category.{v₂, u₂} 𝒳\np : CategoryTheory.Functor 𝒳 𝒮\nS : 𝒮\na b : p.Fiber S\nφ ψ : Quiver.Hom a b\n⊢ Iff (Eq φ ψ) (Eq (CategoryTheory.Functor.Fiber.fiberInclusion.map φ) (CategoryTheory.Functor.Fiber.fiberInclusion.map ψ))","decl":"@[ext]\nlemma hom_ext {a b : Fiber p S} {φ ψ : a ⟶ b}\n    (h : fiberInclusion.map φ = fiberInclusion.map ψ) : φ = ψ :=\n  Subtype.ext h\n\n"}
{"name":"CategoryTheory.Functor.Fiber.hom_ext","module":"Mathlib.CategoryTheory.FiberedCategory.Fiber","initialProofState":"𝒮 : Type u₁\n𝒳 : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} 𝒮\ninst✝ : CategoryTheory.Category.{v₂, u₂} 𝒳\np : CategoryTheory.Functor 𝒳 𝒮\nS : 𝒮\na b : p.Fiber S\nφ ψ : Quiver.Hom a b\nh : Eq (CategoryTheory.Functor.Fiber.fiberInclusion.map φ) (CategoryTheory.Functor.Fiber.fiberInclusion.map ψ)\n⊢ Eq φ ψ","decl":"@[ext]\nlemma hom_ext {a b : Fiber p S} {φ ψ : a ⟶ b}\n    (h : fiberInclusion.map φ = fiberInclusion.map ψ) : φ = ψ :=\n  Subtype.ext h\n\n"}
{"name":"CategoryTheory.Functor.Fiber.instFaithfulFiberInclusion","module":"Mathlib.CategoryTheory.FiberedCategory.Fiber","initialProofState":"𝒮 : Type u₁\n𝒳 : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} 𝒮\ninst✝ : CategoryTheory.Category.{v₂, u₂} 𝒳\np : CategoryTheory.Functor 𝒳 𝒮\nS : 𝒮\n⊢ CategoryTheory.Functor.Fiber.fiberInclusion.Faithful","decl":"instance : (fiberInclusion : Fiber p S ⥤ _).Faithful where\n\n"}
{"name":"CategoryTheory.Functor.Fiber.fiberInclusionCompIsoConst_hom_app","module":"Mathlib.CategoryTheory.FiberedCategory.Fiber","initialProofState":"𝒮 : Type u₁\n𝒳 : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} 𝒮\ninst✝ : CategoryTheory.Category.{v₂, u₂} 𝒳\np : CategoryTheory.Functor 𝒳 𝒮\nS : 𝒮\nX : p.Fiber S\n⊢ Eq (CategoryTheory.Functor.Fiber.fiberInclusionCompIsoConst.hom.app X) (CategoryTheory.eqToHom ⋯)","decl":"/-- For fixed `S : 𝒮` this is the natural isomorphism between `fiberInclusion ⋙ p` and the constant\nfunction valued at `S`. -/\n@[simps!]\ndef fiberInclusionCompIsoConst : fiberInclusion ⋙ p ≅ (const (Fiber p S)).obj S :=\n  NatIso.ofComponents (fun X ↦ eqToIso X.2)\n    (fun φ ↦ by simp [IsHomLift.fac' p (𝟙 S) (fiberInclusion.map φ)])\n\n"}
{"name":"CategoryTheory.Functor.Fiber.fiberInclusionCompIsoConst_inv_app","module":"Mathlib.CategoryTheory.FiberedCategory.Fiber","initialProofState":"𝒮 : Type u₁\n𝒳 : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} 𝒮\ninst✝ : CategoryTheory.Category.{v₂, u₂} 𝒳\np : CategoryTheory.Functor 𝒳 𝒮\nS : 𝒮\nX : p.Fiber S\n⊢ Eq (CategoryTheory.Functor.Fiber.fiberInclusionCompIsoConst.inv.app X) (CategoryTheory.eqToHom ⋯)","decl":"/-- For fixed `S : 𝒮` this is the natural isomorphism between `fiberInclusion ⋙ p` and the constant\nfunction valued at `S`. -/\n@[simps!]\ndef fiberInclusionCompIsoConst : fiberInclusion ⋙ p ≅ (const (Fiber p S)).obj S :=\n  NatIso.ofComponents (fun X ↦ eqToIso X.2)\n    (fun φ ↦ by simp [IsHomLift.fac' p (𝟙 S) (fiberInclusion.map φ)])\n\n"}
{"name":"CategoryTheory.Functor.Fiber.fiberInclusion_comp_eq_const","module":"Mathlib.CategoryTheory.FiberedCategory.Fiber","initialProofState":"𝒮 : Type u₁\n𝒳 : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} 𝒮\ninst✝ : CategoryTheory.Category.{v₂, u₂} 𝒳\np : CategoryTheory.Functor 𝒳 𝒮\nS : 𝒮\n⊢ Eq (CategoryTheory.Functor.Fiber.fiberInclusion.comp p) ((CategoryTheory.Functor.const (p.Fiber S)).obj S)","decl":"lemma fiberInclusion_comp_eq_const : fiberInclusion ⋙ p = (const (Fiber p S)).obj S :=\n  Functor.ext (fun x ↦ x.2) (fun _ _ φ ↦ IsHomLift.fac' p (𝟙 S) (fiberInclusion.map φ))\n\n"}
{"name":"CategoryTheory.Functor.Fiber.fiberInclusion_mk","module":"Mathlib.CategoryTheory.FiberedCategory.Fiber","initialProofState":"𝒮 : Type u₁\n𝒳 : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} 𝒮\ninst✝ : CategoryTheory.Category.{v₂, u₂} 𝒳\np : CategoryTheory.Functor 𝒳 𝒮\nS : 𝒮\na : 𝒳\nha : Eq (p.obj a) S\n⊢ Eq (CategoryTheory.Functor.Fiber.fiberInclusion.obj (CategoryTheory.Functor.Fiber.mk ha)) a","decl":"@[simp]\nlemma fiberInclusion_mk {p : 𝒳 ⥤ 𝒮} {S : 𝒮} {a : 𝒳} (ha : p.obj a = S) :\n    fiberInclusion.obj (mk ha) = a :=\n  rfl\n\n"}
{"name":"CategoryTheory.Functor.Fiber.fiberInclusion_homMk","module":"Mathlib.CategoryTheory.FiberedCategory.Fiber","initialProofState":"𝒮 : Type u₁\n𝒳 : Type u₂\ninst✝² : CategoryTheory.Category.{v₁, u₁} 𝒮\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} 𝒳\np : CategoryTheory.Functor 𝒳 𝒮\nS : 𝒮\na b : 𝒳\nφ : Quiver.Hom a b\ninst✝ : p.IsHomLift (CategoryTheory.CategoryStruct.id S) φ\n⊢ Eq (CategoryTheory.Functor.Fiber.fiberInclusion.map (CategoryTheory.Functor.Fiber.homMk p S φ)) φ","decl":"@[simp]\nlemma fiberInclusion_homMk (p : 𝒳 ⥤ 𝒮) (S : 𝒮) {a b : 𝒳} (φ : a ⟶ b) [IsHomLift p (𝟙 S) φ] :\n    fiberInclusion.map (homMk p S φ) = φ :=\n  rfl\n\n"}
{"name":"CategoryTheory.Functor.Fiber.homMk_id","module":"Mathlib.CategoryTheory.FiberedCategory.Fiber","initialProofState":"𝒮 : Type u₁\n𝒳 : Type u₂\ninst✝² : CategoryTheory.Category.{v₁, u₁} 𝒮\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} 𝒳\np : CategoryTheory.Functor 𝒳 𝒮\nS : 𝒮\na : 𝒳\ninst✝ : p.IsHomLift (CategoryTheory.CategoryStruct.id S) (CategoryTheory.CategoryStruct.id a)\n⊢ Eq (CategoryTheory.Functor.Fiber.homMk p S (CategoryTheory.CategoryStruct.id a)) (CategoryTheory.CategoryStruct.id (CategoryTheory.Functor.Fiber.mk ⋯))","decl":"@[simp]\nlemma homMk_id (p : 𝒳 ⥤ 𝒮) (S : 𝒮) (a : 𝒳) [IsHomLift p (𝟙 S) (𝟙 a)] :\n    homMk p S (𝟙 a) = 𝟙 (mk (domain_eq p (𝟙 S) (𝟙 a))) :=\n  rfl\n\n"}
{"name":"CategoryTheory.Functor.Fiber.homMk_comp","module":"Mathlib.CategoryTheory.FiberedCategory.Fiber","initialProofState":"𝒮 : Type u₁\n𝒳 : Type u₂\ninst✝³ : CategoryTheory.Category.{v₁, u₁} 𝒮\ninst✝² : CategoryTheory.Category.{v₂, u₂} 𝒳\np : CategoryTheory.Functor 𝒳 𝒮\nS : 𝒮\na b c : 𝒳\nφ : Quiver.Hom a b\nψ : Quiver.Hom b c\ninst✝¹ : p.IsHomLift (CategoryTheory.CategoryStruct.id S) φ\ninst✝ : p.IsHomLift (CategoryTheory.CategoryStruct.id S) ψ\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.Fiber.homMk p S φ) (CategoryTheory.Functor.Fiber.homMk p S ψ)) (CategoryTheory.Functor.Fiber.homMk p S (CategoryTheory.CategoryStruct.comp φ ψ))","decl":"@[simp]\nlemma homMk_comp {a b c : 𝒳} (φ : a ⟶ b) (ψ : b ⟶ c) [IsHomLift p (𝟙 S) φ]\n    [IsHomLift p (𝟙 S) ψ] : homMk p S φ ≫ homMk p S ψ = homMk p S (φ ≫ ψ) :=\n  rfl\n\n"}
{"name":"CategoryTheory.Functor.Fiber.inducedFunctor_map","module":"Mathlib.CategoryTheory.FiberedCategory.Fiber","initialProofState":"𝒮 : Type u₁\n𝒳 : Type u₂\ninst✝² : CategoryTheory.Category.{v₁, u₁} 𝒮\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} 𝒳\np : CategoryTheory.Functor 𝒳 𝒮\nS : 𝒮\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor C 𝒳\nhF : Eq (F.comp p) ((CategoryTheory.Functor.const C).obj S)\nX Y : C\nf : Quiver.Hom X Y\n⊢ Eq (CategoryTheory.Functor.Fiber.fiberInclusion.map ((CategoryTheory.Functor.Fiber.inducedFunctor hF).map f)) (F.map f)","decl":"@[simp]\nlemma inducedFunctor_map {X Y : C} (f : X ⟶ Y) :\n    fiberInclusion.map ((inducedFunctor hF).map f) = F.map f := rfl\n\n"}
{"name":"CategoryTheory.Functor.Fiber.inducedFunctorCompIsoSelf_inv_app","module":"Mathlib.CategoryTheory.FiberedCategory.Fiber","initialProofState":"𝒮 : Type u₁\n𝒳 : Type u₂\ninst✝² : CategoryTheory.Category.{v₁, u₁} 𝒮\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} 𝒳\np : CategoryTheory.Functor 𝒳 𝒮\nS : 𝒮\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor C 𝒳\nhF : Eq (F.comp p) ((CategoryTheory.Functor.const C).obj S)\nX : C\n⊢ Eq ((CategoryTheory.Functor.Fiber.inducedFunctorCompIsoSelf hF).inv.app X) (CategoryTheory.CategoryStruct.id (CategoryTheory.Functor.Fiber.fiberInclusion.obj ((CategoryTheory.Functor.Fiber.inducedFunctor hF).obj X)))","decl":"/-- Given a functor `F : C ⥤ 𝒳` such that `F ⋙ p` is constant at some `S : 𝒮`, then\nwe get a natural isomorphism between `inducedFunctor _ ⋙ fiberInclusion` and `F`. -/\n@[simps!]\ndef inducedFunctorCompIsoSelf : (inducedFunctor hF) ⋙ fiberInclusion ≅ F := Iso.refl _\n\n"}
{"name":"CategoryTheory.Functor.Fiber.inducedFunctorCompIsoSelf_hom_app","module":"Mathlib.CategoryTheory.FiberedCategory.Fiber","initialProofState":"𝒮 : Type u₁\n𝒳 : Type u₂\ninst✝² : CategoryTheory.Category.{v₁, u₁} 𝒮\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} 𝒳\np : CategoryTheory.Functor 𝒳 𝒮\nS : 𝒮\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor C 𝒳\nhF : Eq (F.comp p) ((CategoryTheory.Functor.const C).obj S)\nX : C\n⊢ Eq ((CategoryTheory.Functor.Fiber.inducedFunctorCompIsoSelf hF).hom.app X) (CategoryTheory.CategoryStruct.id (CategoryTheory.Functor.Fiber.fiberInclusion.obj ((CategoryTheory.Functor.Fiber.inducedFunctor hF).obj X)))","decl":"/-- Given a functor `F : C ⥤ 𝒳` such that `F ⋙ p` is constant at some `S : 𝒮`, then\nwe get a natural isomorphism between `inducedFunctor _ ⋙ fiberInclusion` and `F`. -/\n@[simps!]\ndef inducedFunctorCompIsoSelf : (inducedFunctor hF) ⋙ fiberInclusion ≅ F := Iso.refl _\n\n"}
{"name":"CategoryTheory.Functor.Fiber.inducedFunctor_comp","module":"Mathlib.CategoryTheory.FiberedCategory.Fiber","initialProofState":"𝒮 : Type u₁\n𝒳 : Type u₂\ninst✝² : CategoryTheory.Category.{v₁, u₁} 𝒮\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} 𝒳\np : CategoryTheory.Functor 𝒳 𝒮\nS : 𝒮\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor C 𝒳\nhF : Eq (F.comp p) ((CategoryTheory.Functor.const C).obj S)\n⊢ Eq ((CategoryTheory.Functor.Fiber.inducedFunctor hF).comp CategoryTheory.Functor.Fiber.fiberInclusion) F","decl":"lemma inducedFunctor_comp : (inducedFunctor hF) ⋙ fiberInclusion = F := rfl\n\n"}
