{"name":"VectorField.lieBracket_eq","module":"Mathlib.Analysis.Calculus.VectorField","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\nV W : E → E\n⊢ Eq (VectorField.lieBracket 𝕜 V W) fun x => HSub.hSub ((fderiv 𝕜 W x) (V x)) ((fderiv 𝕜 V x) (W x))","decl":"lemma lieBracket_eq :\n    lieBracket 𝕜 V W = fun x ↦ fderiv 𝕜 W x (V x) - fderiv 𝕜 V x (W x) := rfl\n\n"}
{"name":"VectorField.lieBracketWithin_eq","module":"Mathlib.Analysis.Calculus.VectorField","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\nV W : E → E\ns : Set E\n⊢ Eq (VectorField.lieBracketWithin 𝕜 V W s) fun x => HSub.hSub ((fderivWithin 𝕜 W s x) (V x)) ((fderivWithin 𝕜 V s x) (W x))","decl":"lemma lieBracketWithin_eq :\n    lieBracketWithin 𝕜 V W s =\n      fun x ↦ fderivWithin 𝕜 W s x (V x) - fderivWithin 𝕜 V s x (W x) := rfl\n\n"}
{"name":"VectorField.lieBracketWithin_univ","module":"Mathlib.Analysis.Calculus.VectorField","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\nV W : E → E\n⊢ Eq (VectorField.lieBracketWithin 𝕜 V W Set.univ) (VectorField.lieBracket 𝕜 V W)","decl":"@[simp]\ntheorem lieBracketWithin_univ : lieBracketWithin 𝕜 V W univ = lieBracket 𝕜 V W := by\n  ext1 x\n  simp [lieBracketWithin, lieBracket]\n\n"}
{"name":"VectorField.lieBracketWithin_eq_zero_of_eq_zero","module":"Mathlib.Analysis.Calculus.VectorField","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\nV W : E → E\ns : Set E\nx : E\nhV : Eq (V x) 0\nhW : Eq (W x) 0\n⊢ Eq (VectorField.lieBracketWithin 𝕜 V W s x) 0","decl":"lemma lieBracketWithin_eq_zero_of_eq_zero (hV : V x = 0) (hW : W x = 0) :\n    lieBracketWithin 𝕜 V W s x = 0 := by\n  simp [lieBracketWithin, hV, hW]\n\n"}
{"name":"VectorField.lieBracket_eq_zero_of_eq_zero","module":"Mathlib.Analysis.Calculus.VectorField","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\nV W : E → E\nx : E\nhV : Eq (V x) 0\nhW : Eq (W x) 0\n⊢ Eq (VectorField.lieBracket 𝕜 V W x) 0","decl":"lemma lieBracket_eq_zero_of_eq_zero (hV : V x = 0) (hW : W x = 0) :\n    lieBracket 𝕜 V W x = 0 := by\n  simp [lieBracket, hV, hW]\n\n"}
{"name":"VectorField.lieBracketWithin_smul_left","module":"Mathlib.Analysis.Calculus.VectorField","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\nV W : E → E\ns : Set E\nx : E\nc : 𝕜\nhV : DifferentiableWithinAt 𝕜 V s x\nhs : UniqueDiffWithinAt 𝕜 s x\n⊢ Eq (VectorField.lieBracketWithin 𝕜 (HSMul.hSMul c V) W s x) (HSMul.hSMul c (VectorField.lieBracketWithin 𝕜 V W s x))","decl":"lemma lieBracketWithin_smul_left {c : 𝕜} (hV : DifferentiableWithinAt 𝕜 V s x)\n    (hs : UniqueDiffWithinAt 𝕜 s x) :\n    lieBracketWithin 𝕜 (c • V) W s x =\n      c • lieBracketWithin 𝕜 V W s x := by\n  simp only [lieBracketWithin, Pi.add_apply, map_add, Pi.smul_apply, map_smul, smul_sub]\n  rw [fderivWithin_const_smul' hs hV]\n  rfl\n\n"}
{"name":"VectorField.lieBracket_smul_left","module":"Mathlib.Analysis.Calculus.VectorField","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\nV W : E → E\nx : E\nc : 𝕜\nhV : DifferentiableAt 𝕜 V x\n⊢ Eq (VectorField.lieBracket 𝕜 (HSMul.hSMul c V) W x) (HSMul.hSMul c (VectorField.lieBracket 𝕜 V W x))","decl":"lemma lieBracket_smul_left {c : 𝕜} (hV : DifferentiableAt 𝕜 V x) :\n    lieBracket 𝕜 (c • V) W x = c • lieBracket 𝕜 V W x := by\n  simp only [← differentiableWithinAt_univ, ← lieBracketWithin_univ] at hV ⊢\n  exact lieBracketWithin_smul_left hV uniqueDiffWithinAt_univ\n\n"}
{"name":"VectorField.lieBracketWithin_smul_right","module":"Mathlib.Analysis.Calculus.VectorField","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\nV W : E → E\ns : Set E\nx : E\nc : 𝕜\nhW : DifferentiableWithinAt 𝕜 W s x\nhs : UniqueDiffWithinAt 𝕜 s x\n⊢ Eq (VectorField.lieBracketWithin 𝕜 V (HSMul.hSMul c W) s x) (HSMul.hSMul c (VectorField.lieBracketWithin 𝕜 V W s x))","decl":"lemma lieBracketWithin_smul_right {c : 𝕜} (hW : DifferentiableWithinAt 𝕜 W s x)\n    (hs : UniqueDiffWithinAt 𝕜 s x) :\n    lieBracketWithin 𝕜 V (c • W) s x =\n      c • lieBracketWithin 𝕜 V W s x := by\n  simp only [lieBracketWithin, Pi.add_apply, map_add, Pi.smul_apply, map_smul, smul_sub]\n  rw [fderivWithin_const_smul' hs hW]\n  rfl\n\n"}
{"name":"VectorField.lieBracket_smul_right","module":"Mathlib.Analysis.Calculus.VectorField","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\nV W : E → E\nx : E\nc : 𝕜\nhW : DifferentiableAt 𝕜 W x\n⊢ Eq (VectorField.lieBracket 𝕜 V (HSMul.hSMul c W) x) (HSMul.hSMul c (VectorField.lieBracket 𝕜 V W x))","decl":"lemma lieBracket_smul_right {c : 𝕜} (hW : DifferentiableAt 𝕜 W x) :\n    lieBracket 𝕜 V (c • W) x = c • lieBracket 𝕜 V W x := by\n  simp only [← differentiableWithinAt_univ, ← lieBracketWithin_univ] at hW ⊢\n  exact lieBracketWithin_smul_right hW uniqueDiffWithinAt_univ\n\n"}
{"name":"VectorField.lieBracketWithin_add_left","module":"Mathlib.Analysis.Calculus.VectorField","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\nV W V₁ : E → E\ns : Set E\nx : E\nhV : DifferentiableWithinAt 𝕜 V s x\nhV₁ : DifferentiableWithinAt 𝕜 V₁ s x\nhs : UniqueDiffWithinAt 𝕜 s x\n⊢ Eq (VectorField.lieBracketWithin 𝕜 (HAdd.hAdd V V₁) W s x) (HAdd.hAdd (VectorField.lieBracketWithin 𝕜 V W s x) (VectorField.lieBracketWithin 𝕜 V₁ W s x))","decl":"lemma lieBracketWithin_add_left (hV : DifferentiableWithinAt 𝕜 V s x)\n    (hV₁ : DifferentiableWithinAt 𝕜 V₁ s x) (hs : UniqueDiffWithinAt 𝕜 s x) :\n    lieBracketWithin 𝕜 (V + V₁) W s x =\n      lieBracketWithin 𝕜 V W s x + lieBracketWithin 𝕜 V₁ W s x := by\n  simp only [lieBracketWithin, Pi.add_apply, map_add]\n  rw [fderivWithin_add' hs hV hV₁, ContinuousLinearMap.add_apply]\n  abel\n\n"}
{"name":"VectorField.lieBracket_add_left","module":"Mathlib.Analysis.Calculus.VectorField","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\nV W V₁ : E → E\nx : E\nhV : DifferentiableAt 𝕜 V x\nhV₁ : DifferentiableAt 𝕜 V₁ x\n⊢ Eq (VectorField.lieBracket 𝕜 (HAdd.hAdd V V₁) W x) (HAdd.hAdd (VectorField.lieBracket 𝕜 V W x) (VectorField.lieBracket 𝕜 V₁ W x))","decl":"lemma lieBracket_add_left (hV : DifferentiableAt 𝕜 V x) (hV₁ : DifferentiableAt 𝕜 V₁ x) :\n    lieBracket 𝕜 (V + V₁) W  x =\n      lieBracket 𝕜 V W x + lieBracket 𝕜 V₁ W x := by\n  simp only [lieBracket, Pi.add_apply, map_add]\n  rw [fderiv_add' hV hV₁, ContinuousLinearMap.add_apply]\n  abel\n\n"}
{"name":"VectorField.lieBracketWithin_add_right","module":"Mathlib.Analysis.Calculus.VectorField","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\nV W W₁ : E → E\ns : Set E\nx : E\nhW : DifferentiableWithinAt 𝕜 W s x\nhW₁ : DifferentiableWithinAt 𝕜 W₁ s x\nhs : UniqueDiffWithinAt 𝕜 s x\n⊢ Eq (VectorField.lieBracketWithin 𝕜 V (HAdd.hAdd W W₁) s x) (HAdd.hAdd (VectorField.lieBracketWithin 𝕜 V W s x) (VectorField.lieBracketWithin 𝕜 V W₁ s x))","decl":"lemma lieBracketWithin_add_right (hW : DifferentiableWithinAt 𝕜 W s x)\n    (hW₁ : DifferentiableWithinAt 𝕜 W₁ s x) (hs :  UniqueDiffWithinAt 𝕜 s x) :\n    lieBracketWithin 𝕜 V (W + W₁) s x =\n      lieBracketWithin 𝕜 V W s x + lieBracketWithin 𝕜 V W₁ s x := by\n  simp only [lieBracketWithin, Pi.add_apply, map_add]\n  rw [fderivWithin_add' hs hW hW₁, ContinuousLinearMap.add_apply]\n  abel\n\n"}
{"name":"VectorField.lieBracket_add_right","module":"Mathlib.Analysis.Calculus.VectorField","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\nV W W₁ : E → E\nx : E\nhW : DifferentiableAt 𝕜 W x\nhW₁ : DifferentiableAt 𝕜 W₁ x\n⊢ Eq (VectorField.lieBracket 𝕜 V (HAdd.hAdd W W₁) x) (HAdd.hAdd (VectorField.lieBracket 𝕜 V W x) (VectorField.lieBracket 𝕜 V W₁ x))","decl":"lemma lieBracket_add_right (hW : DifferentiableAt 𝕜 W x) (hW₁ : DifferentiableAt 𝕜 W₁ x) :\n    lieBracket 𝕜 V (W + W₁) x =\n      lieBracket 𝕜 V W x + lieBracket 𝕜 V W₁ x := by\n  simp only [lieBracket, Pi.add_apply, map_add]\n  rw [fderiv_add' hW hW₁, ContinuousLinearMap.add_apply]\n  abel\n\n"}
{"name":"VectorField.lieBracketWithin_swap","module":"Mathlib.Analysis.Calculus.VectorField","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\nV W : E → E\ns : Set E\n⊢ Eq (VectorField.lieBracketWithin 𝕜 V W s) (Neg.neg (VectorField.lieBracketWithin 𝕜 W V s))","decl":"lemma lieBracketWithin_swap : lieBracketWithin 𝕜 V W s = - lieBracketWithin 𝕜 W V s := by\n  ext x; simp [lieBracketWithin]\n\n"}
{"name":"VectorField.lieBracket_swap","module":"Mathlib.Analysis.Calculus.VectorField","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\nV W : E → E\nx : E\n⊢ Eq (VectorField.lieBracket 𝕜 V W x) (Neg.neg (VectorField.lieBracket 𝕜 W V x))","decl":"lemma lieBracket_swap : lieBracket 𝕜 V W x = - lieBracket 𝕜 W V x := by\n  simp [lieBracket]\n\n"}
{"name":"VectorField.lieBracketWithin_self","module":"Mathlib.Analysis.Calculus.VectorField","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\nV : E → E\ns : Set E\n⊢ Eq (VectorField.lieBracketWithin 𝕜 V V s) 0","decl":"@[simp] lemma lieBracketWithin_self : lieBracketWithin 𝕜 V V s = 0 := by\n  ext x; simp [lieBracketWithin]\n\n"}
{"name":"VectorField.lieBracket_self","module":"Mathlib.Analysis.Calculus.VectorField","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\nV : E → E\n⊢ Eq (VectorField.lieBracket 𝕜 V V) 0","decl":"@[simp] lemma lieBracket_self : lieBracket 𝕜 V V = 0 := by\n  ext x; simp [lieBracket]\n\n"}
{"name":"ContDiffWithinAt.lieBracketWithin_vectorField","module":"Mathlib.Analysis.Calculus.VectorField","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\nV W : E → E\ns : Set E\nx : E\nm n : WithTop ENat\nhV : ContDiffWithinAt 𝕜 n V s x\nhW : ContDiffWithinAt 𝕜 n W s x\nhs : UniqueDiffOn 𝕜 s\nhmn : LE.le (HAdd.hAdd m 1) n\nhx : Membership.mem s x\n⊢ ContDiffWithinAt 𝕜 m (VectorField.lieBracketWithin 𝕜 V W s) s x","decl":"lemma _root_.ContDiffWithinAt.lieBracketWithin_vectorField\n    {m n : WithTop ℕ∞} (hV : ContDiffWithinAt 𝕜 n V s x)\n    (hW : ContDiffWithinAt 𝕜 n W s x) (hs : UniqueDiffOn 𝕜 s) (hmn : m + 1 ≤ n) (hx : x ∈ s) :\n    ContDiffWithinAt 𝕜 m (lieBracketWithin 𝕜 V W s) s x := by\n  apply ContDiffWithinAt.sub\n  · exact ContDiffWithinAt.clm_apply (hW.fderivWithin_right hs hmn hx)\n      (hV.of_le (le_trans le_self_add hmn))\n  · exact ContDiffWithinAt.clm_apply (hV.fderivWithin_right hs hmn hx)\n      (hW.of_le (le_trans le_self_add hmn))\n\n"}
{"name":"ContDiffAt.lieBracket_vectorField","module":"Mathlib.Analysis.Calculus.VectorField","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\nV W : E → E\nx : E\nm n : WithTop ENat\nhV : ContDiffAt 𝕜 n V x\nhW : ContDiffAt 𝕜 n W x\nhmn : LE.le (HAdd.hAdd m 1) n\n⊢ ContDiffAt 𝕜 m (VectorField.lieBracket 𝕜 V W) x","decl":"lemma _root_.ContDiffAt.lieBracket_vectorField {m n : WithTop ℕ∞} (hV : ContDiffAt 𝕜 n V x)\n    (hW : ContDiffAt 𝕜 n W x) (hmn : m + 1 ≤ n) :\n    ContDiffAt 𝕜 m (lieBracket 𝕜 V W) x := by\n  rw [← contDiffWithinAt_univ] at hV hW ⊢\n  simp_rw [← lieBracketWithin_univ]\n  exact hV.lieBracketWithin_vectorField hW uniqueDiffOn_univ hmn (mem_univ _)\n\n"}
{"name":"ContDiffOn.lieBracketWithin_vectorField","module":"Mathlib.Analysis.Calculus.VectorField","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\nV W : E → E\ns : Set E\nm n : WithTop ENat\nhV : ContDiffOn 𝕜 n V s\nhW : ContDiffOn 𝕜 n W s\nhs : UniqueDiffOn 𝕜 s\nhmn : LE.le (HAdd.hAdd m 1) n\n⊢ ContDiffOn 𝕜 m (VectorField.lieBracketWithin 𝕜 V W s) s","decl":"lemma _root_.ContDiffOn.lieBracketWithin_vectorField {m n : WithTop ℕ∞} (hV : ContDiffOn 𝕜 n V s)\n    (hW : ContDiffOn 𝕜 n W s) (hs : UniqueDiffOn 𝕜 s) (hmn : m + 1 ≤ n) :\n    ContDiffOn 𝕜 m (lieBracketWithin 𝕜 V W s) s :=\n  fun x hx ↦ (hV x hx).lieBracketWithin_vectorField (hW x hx) hs hmn hx\n\n"}
{"name":"ContDiff.lieBracket_vectorField","module":"Mathlib.Analysis.Calculus.VectorField","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\nV W : E → E\nm n : WithTop ENat\nhV : ContDiff 𝕜 n V\nhW : ContDiff 𝕜 n W\nhmn : LE.le (HAdd.hAdd m 1) n\n⊢ ContDiff 𝕜 m (VectorField.lieBracket 𝕜 V W)","decl":"lemma _root_.ContDiff.lieBracket_vectorField {m n : WithTop ℕ∞} (hV : ContDiff 𝕜 n V)\n    (hW : ContDiff 𝕜 n W) (hmn : m + 1 ≤ n) :\n    ContDiff 𝕜 m (lieBracket 𝕜 V W) :=\n  contDiff_iff_contDiffAt.2 (fun _ ↦ hV.contDiffAt.lieBracket_vectorField hW.contDiffAt hmn)\n\n"}
{"name":"VectorField.lieBracketWithin_of_mem_nhdsWithin","module":"Mathlib.Analysis.Calculus.VectorField","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\nV W : E → E\ns t : Set E\nx : E\nst : Membership.mem (nhdsWithin x s) t\nhs : UniqueDiffWithinAt 𝕜 s x\nhV : DifferentiableWithinAt 𝕜 V t x\nhW : DifferentiableWithinAt 𝕜 W t x\n⊢ Eq (VectorField.lieBracketWithin 𝕜 V W s x) (VectorField.lieBracketWithin 𝕜 V W t x)","decl":"theorem lieBracketWithin_of_mem_nhdsWithin (st : t ∈ 𝓝[s] x) (hs : UniqueDiffWithinAt 𝕜 s x)\n    (hV : DifferentiableWithinAt 𝕜 V t x) (hW : DifferentiableWithinAt 𝕜 W t x) :\n    lieBracketWithin 𝕜 V W s x = lieBracketWithin 𝕜 V W t x := by\n  simp [lieBracketWithin, fderivWithin_of_mem_nhdsWithin st hs hV,\n    fderivWithin_of_mem_nhdsWithin st hs hW]\n\n"}
{"name":"VectorField.lieBracketWithin_subset","module":"Mathlib.Analysis.Calculus.VectorField","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\nV W : E → E\ns t : Set E\nx : E\nst : HasSubset.Subset s t\nht : UniqueDiffWithinAt 𝕜 s x\nhV : DifferentiableWithinAt 𝕜 V t x\nhW : DifferentiableWithinAt 𝕜 W t x\n⊢ Eq (VectorField.lieBracketWithin 𝕜 V W s x) (VectorField.lieBracketWithin 𝕜 V W t x)","decl":"theorem lieBracketWithin_subset (st : s ⊆ t) (ht : UniqueDiffWithinAt 𝕜 s x)\n    (hV : DifferentiableWithinAt 𝕜 V t x) (hW : DifferentiableWithinAt 𝕜 W t x) :\n    lieBracketWithin 𝕜 V W s x = lieBracketWithin 𝕜 V W t x :=\n  lieBracketWithin_of_mem_nhdsWithin (nhdsWithin_mono _ st self_mem_nhdsWithin) ht hV hW\n\n"}
{"name":"VectorField.lieBracketWithin_inter","module":"Mathlib.Analysis.Calculus.VectorField","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\nV W : E → E\ns t : Set E\nx : E\nht : Membership.mem (nhds x) t\n⊢ Eq (VectorField.lieBracketWithin 𝕜 V W (Inter.inter s t) x) (VectorField.lieBracketWithin 𝕜 V W s x)","decl":"theorem lieBracketWithin_inter (ht : t ∈ 𝓝 x) :\n    lieBracketWithin 𝕜 V W (s ∩ t) x = lieBracketWithin 𝕜 V W s x := by\n  simp [lieBracketWithin, fderivWithin_inter, ht]\n\n"}
{"name":"VectorField.lieBracketWithin_of_mem_nhds","module":"Mathlib.Analysis.Calculus.VectorField","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\nV W : E → E\ns : Set E\nx : E\nh : Membership.mem (nhds x) s\n⊢ Eq (VectorField.lieBracketWithin 𝕜 V W s x) (VectorField.lieBracket 𝕜 V W x)","decl":"theorem lieBracketWithin_of_mem_nhds (h : s ∈ 𝓝 x) :\n    lieBracketWithin 𝕜 V W s x = lieBracket 𝕜 V W x := by\n  rw [← lieBracketWithin_univ, ← univ_inter s, lieBracketWithin_inter h]\n\n"}
{"name":"VectorField.lieBracketWithin_of_isOpen","module":"Mathlib.Analysis.Calculus.VectorField","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\nV W : E → E\ns : Set E\nx : E\nhs : IsOpen s\nhx : Membership.mem s x\n⊢ Eq (VectorField.lieBracketWithin 𝕜 V W s x) (VectorField.lieBracket 𝕜 V W x)","decl":"theorem lieBracketWithin_of_isOpen (hs : IsOpen s) (hx : x ∈ s) :\n    lieBracketWithin 𝕜 V W s x = lieBracket 𝕜 V W x :=\n  lieBracketWithin_of_mem_nhds (hs.mem_nhds hx)\n\n"}
{"name":"VectorField.lieBracketWithin_eq_lieBracket","module":"Mathlib.Analysis.Calculus.VectorField","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\nV W : E → E\ns : Set E\nx : E\nhs : UniqueDiffWithinAt 𝕜 s x\nhV : DifferentiableAt 𝕜 V x\nhW : DifferentiableAt 𝕜 W x\n⊢ Eq (VectorField.lieBracketWithin 𝕜 V W s x) (VectorField.lieBracket 𝕜 V W x)","decl":"theorem lieBracketWithin_eq_lieBracket (hs : UniqueDiffWithinAt 𝕜 s x)\n    (hV : DifferentiableAt 𝕜 V x) (hW : DifferentiableAt 𝕜 W x) :\n    lieBracketWithin 𝕜 V W s x = lieBracket 𝕜 V W x := by\n  simp [lieBracketWithin, lieBracket, fderivWithin_eq_fderiv, hs, hV, hW]\n\n"}
{"name":"VectorField.lieBracketWithin_congr_set'","module":"Mathlib.Analysis.Calculus.VectorField","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\nV W : E → E\ns t : Set E\nx y : E\nh : (nhdsWithin x (HasCompl.compl (Singleton.singleton y))).EventuallyEq s t\n⊢ Eq (VectorField.lieBracketWithin 𝕜 V W s x) (VectorField.lieBracketWithin 𝕜 V W t x)","decl":"/-- Variant of `lieBracketWithin_congr_set` where one requires the sets to coincide only in\nthe complement of a point. -/\ntheorem lieBracketWithin_congr_set' (y : E) (h : s =ᶠ[𝓝[{y}ᶜ] x] t) :\n    lieBracketWithin 𝕜 V W s x = lieBracketWithin 𝕜 V W t x := by\n  simp [lieBracketWithin, fderivWithin_congr_set' _ h]\n\n"}
{"name":"VectorField.lieBracketWithin_congr_set","module":"Mathlib.Analysis.Calculus.VectorField","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\nV W : E → E\ns t : Set E\nx : E\nh : (nhds x).EventuallyEq s t\n⊢ Eq (VectorField.lieBracketWithin 𝕜 V W s x) (VectorField.lieBracketWithin 𝕜 V W t x)","decl":"theorem lieBracketWithin_congr_set (h : s =ᶠ[𝓝 x] t) :\n    lieBracketWithin 𝕜 V W s x = lieBracketWithin 𝕜 V W t x :=\n  lieBracketWithin_congr_set' x <| h.filter_mono inf_le_left\n\n"}
{"name":"VectorField.lieBracketWithin_eventually_congr_set'","module":"Mathlib.Analysis.Calculus.VectorField","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\nV W : E → E\ns t : Set E\nx y : E\nh : (nhdsWithin x (HasCompl.compl (Singleton.singleton y))).EventuallyEq s t\n⊢ (nhds x).EventuallyEq (VectorField.lieBracketWithin 𝕜 V W s) (VectorField.lieBracketWithin 𝕜 V W t)","decl":"/-- Variant of `lieBracketWithin_eventually_congr_set` where one requires the sets to coincide only\nin  the complement of a point. -/\ntheorem lieBracketWithin_eventually_congr_set' (y : E) (h : s =ᶠ[𝓝[{y}ᶜ] x] t) :\n    lieBracketWithin 𝕜 V W s =ᶠ[𝓝 x] lieBracketWithin 𝕜 V W t :=\n  (eventually_nhds_nhdsWithin.2 h).mono fun _ => lieBracketWithin_congr_set' y\n\n"}
{"name":"VectorField.lieBracketWithin_eventually_congr_set","module":"Mathlib.Analysis.Calculus.VectorField","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\nV W : E → E\ns t : Set E\nx : E\nh : (nhds x).EventuallyEq s t\n⊢ (nhds x).EventuallyEq (VectorField.lieBracketWithin 𝕜 V W s) (VectorField.lieBracketWithin 𝕜 V W t)","decl":"theorem lieBracketWithin_eventually_congr_set (h : s =ᶠ[𝓝 x] t) :\n    lieBracketWithin 𝕜 V W s =ᶠ[𝓝 x] lieBracketWithin 𝕜 V W t :=\n  lieBracketWithin_eventually_congr_set' x <| h.filter_mono inf_le_left\n\n"}
{"name":"DifferentiableWithinAt.lieBracketWithin_congr_mono","module":"Mathlib.Analysis.Calculus.VectorField","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\nV W V₁ W₁ : E → E\ns t : Set E\nx : E\nhV : DifferentiableWithinAt 𝕜 V s x\nhVs : Set.EqOn V₁ V t\nhVx : Eq (V₁ x) (V x)\nhW : DifferentiableWithinAt 𝕜 W s x\nhWs : Set.EqOn W₁ W t\nhWx : Eq (W₁ x) (W x)\nhxt : UniqueDiffWithinAt 𝕜 t x\nh₁ : HasSubset.Subset t s\n⊢ Eq (VectorField.lieBracketWithin 𝕜 V₁ W₁ t x) (VectorField.lieBracketWithin 𝕜 V W s x)","decl":"theorem _root_.DifferentiableWithinAt.lieBracketWithin_congr_mono\n    (hV : DifferentiableWithinAt 𝕜 V s x) (hVs : EqOn V₁ V t) (hVx : V₁ x = V x)\n    (hW : DifferentiableWithinAt 𝕜 W s x) (hWs : EqOn W₁ W t) (hWx : W₁ x = W x)\n    (hxt : UniqueDiffWithinAt 𝕜 t x) (h₁ : t ⊆ s) :\n    lieBracketWithin 𝕜 V₁ W₁ t x = lieBracketWithin 𝕜 V W s x := by\n  simp [lieBracketWithin, hV.fderivWithin_congr_mono, hW.fderivWithin_congr_mono, hVs, hVx,\n    hWs, hWx, hxt, h₁]\n\n"}
{"name":"Filter.EventuallyEq.lieBracketWithin_vectorField_eq","module":"Mathlib.Analysis.Calculus.VectorField","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\nV W V₁ W₁ : E → E\ns : Set E\nx : E\nhV : (nhdsWithin x s).EventuallyEq V₁ V\nhxV : Eq (V₁ x) (V x)\nhW : (nhdsWithin x s).EventuallyEq W₁ W\nhxW : Eq (W₁ x) (W x)\n⊢ Eq (VectorField.lieBracketWithin 𝕜 V₁ W₁ s x) (VectorField.lieBracketWithin 𝕜 V W s x)","decl":"theorem _root_.Filter.EventuallyEq.lieBracketWithin_vectorField_eq\n    (hV : V₁ =ᶠ[𝓝[s] x] V) (hxV : V₁ x = V x) (hW : W₁ =ᶠ[𝓝[s] x] W) (hxW : W₁ x = W x) :\n    lieBracketWithin 𝕜 V₁ W₁ s x = lieBracketWithin 𝕜 V W s x := by\n  simp only [lieBracketWithin, hV.fderivWithin_eq hxV, hW.fderivWithin_eq hxW, hxV, hxW]\n\n"}
{"name":"Filter.EventuallyEq.lieBracketWithin_vectorField_eq_of_mem","module":"Mathlib.Analysis.Calculus.VectorField","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\nV W V₁ W₁ : E → E\ns : Set E\nx : E\nhV : (nhdsWithin x s).EventuallyEq V₁ V\nhW : (nhdsWithin x s).EventuallyEq W₁ W\nhx : Membership.mem s x\n⊢ Eq (VectorField.lieBracketWithin 𝕜 V₁ W₁ s x) (VectorField.lieBracketWithin 𝕜 V W s x)","decl":"theorem _root_.Filter.EventuallyEq.lieBracketWithin_vectorField_eq_of_mem\n    (hV : V₁ =ᶠ[𝓝[s] x] V) (hW : W₁ =ᶠ[𝓝[s] x] W) (hx : x ∈ s) :\n    lieBracketWithin 𝕜 V₁ W₁ s x = lieBracketWithin 𝕜 V W s x :=\n  hV.lieBracketWithin_vectorField_eq (mem_of_mem_nhdsWithin hx hV :)\n    hW (mem_of_mem_nhdsWithin hx hW :)\n\n"}
{"name":"Filter.EventuallyEq.lieBracketWithin_vectorField'","module":"Mathlib.Analysis.Calculus.VectorField","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\nV W V₁ W₁ : E → E\ns t : Set E\nx : E\nhV : (nhdsWithin x s).EventuallyEq V₁ V\nhW : (nhdsWithin x s).EventuallyEq W₁ W\nht : HasSubset.Subset t s\n⊢ (nhdsWithin x s).EventuallyEq (VectorField.lieBracketWithin 𝕜 V₁ W₁ t) (VectorField.lieBracketWithin 𝕜 V W t)","decl":"/-- If vector fields coincide on a neighborhood of a point within a set, then the Lie brackets\nalso coincide on a neighborhood of this point within this set. Version where one considers the Lie\nbracket within a subset. -/\ntheorem _root_.Filter.EventuallyEq.lieBracketWithin_vectorField'\n    (hV : V₁ =ᶠ[𝓝[s] x] V) (hW : W₁ =ᶠ[𝓝[s] x] W) (ht : t ⊆ s) :\n    lieBracketWithin 𝕜 V₁ W₁ t =ᶠ[𝓝[s] x] lieBracketWithin 𝕜 V W t := by\n  filter_upwards [hV.fderivWithin' ht (𝕜 := 𝕜), hW.fderivWithin' ht (𝕜 := 𝕜), hV, hW]\n    with x hV' hW' hV hW\n  simp [lieBracketWithin, hV', hW', hV, hW]\n\n"}
{"name":"Filter.EventuallyEq.lieBracketWithin_vectorField","module":"Mathlib.Analysis.Calculus.VectorField","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\nV W V₁ W₁ : E → E\ns : Set E\nx : E\nhV : (nhdsWithin x s).EventuallyEq V₁ V\nhW : (nhdsWithin x s).EventuallyEq W₁ W\n⊢ (nhdsWithin x s).EventuallyEq (VectorField.lieBracketWithin 𝕜 V₁ W₁ s) (VectorField.lieBracketWithin 𝕜 V W s)","decl":"protected theorem _root_.Filter.EventuallyEq.lieBracketWithin_vectorField\n    (hV : V₁ =ᶠ[𝓝[s] x] V) (hW : W₁ =ᶠ[𝓝[s] x] W) :\n    lieBracketWithin 𝕜 V₁ W₁ s =ᶠ[𝓝[s] x] lieBracketWithin 𝕜 V W s :=\n  hV.lieBracketWithin_vectorField' hW Subset.rfl\n\n"}
{"name":"Filter.EventuallyEq.lieBracketWithin_vectorField_eq_of_insert","module":"Mathlib.Analysis.Calculus.VectorField","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\nV W V₁ W₁ : E → E\ns : Set E\nx : E\nhV : (nhdsWithin x (Insert.insert x s)).EventuallyEq V₁ V\nhW : (nhdsWithin x (Insert.insert x s)).EventuallyEq W₁ W\n⊢ Eq (VectorField.lieBracketWithin 𝕜 V₁ W₁ s x) (VectorField.lieBracketWithin 𝕜 V W s x)","decl":"protected theorem _root_.Filter.EventuallyEq.lieBracketWithin_vectorField_eq_of_insert\n    (hV : V₁ =ᶠ[𝓝[insert x s] x] V) (hW : W₁ =ᶠ[𝓝[insert x s] x] W) :\n    lieBracketWithin 𝕜 V₁ W₁ s x = lieBracketWithin 𝕜 V W s x := by\n  apply mem_of_mem_nhdsWithin (mem_insert x s) (hV.lieBracketWithin_vectorField' hW\n    (subset_insert x s))\n\n"}
{"name":"Filter.EventuallyEq.lieBracketWithin_vectorField_eq_nhds","module":"Mathlib.Analysis.Calculus.VectorField","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\nV W V₁ W₁ : E → E\ns : Set E\nx : E\nhV : (nhds x).EventuallyEq V₁ V\nhW : (nhds x).EventuallyEq W₁ W\n⊢ Eq (VectorField.lieBracketWithin 𝕜 V₁ W₁ s x) (VectorField.lieBracketWithin 𝕜 V W s x)","decl":"theorem _root_.Filter.EventuallyEq.lieBracketWithin_vectorField_eq_nhds\n    (hV : V₁ =ᶠ[𝓝 x] V) (hW : W₁ =ᶠ[𝓝 x] W) :\n    lieBracketWithin 𝕜 V₁ W₁ s x = lieBracketWithin 𝕜 V W s x :=\n  (hV.filter_mono nhdsWithin_le_nhds).lieBracketWithin_vectorField_eq hV.self_of_nhds\n    (hW.filter_mono nhdsWithin_le_nhds) hW.self_of_nhds\n\n"}
{"name":"VectorField.lieBracketWithin_congr","module":"Mathlib.Analysis.Calculus.VectorField","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\nV W V₁ W₁ : E → E\ns : Set E\nx : E\nhV : Set.EqOn V₁ V s\nhVx : Eq (V₁ x) (V x)\nhW : Set.EqOn W₁ W s\nhWx : Eq (W₁ x) (W x)\n⊢ Eq (VectorField.lieBracketWithin 𝕜 V₁ W₁ s x) (VectorField.lieBracketWithin 𝕜 V W s x)","decl":"theorem lieBracketWithin_congr\n    (hV : EqOn V₁ V s) (hVx : V₁ x = V x) (hW : EqOn W₁ W s) (hWx : W₁ x = W x) :\n    lieBracketWithin 𝕜 V₁ W₁ s x = lieBracketWithin 𝕜 V W s x :=\n  (hV.eventuallyEq.filter_mono inf_le_right).lieBracketWithin_vectorField_eq hVx\n    (hW.eventuallyEq.filter_mono inf_le_right) hWx\n\n"}
{"name":"VectorField.lieBracketWithin_congr'","module":"Mathlib.Analysis.Calculus.VectorField","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\nV W V₁ W₁ : E → E\ns : Set E\nx : E\nhV : Set.EqOn V₁ V s\nhW : Set.EqOn W₁ W s\nhx : Membership.mem s x\n⊢ Eq (VectorField.lieBracketWithin 𝕜 V₁ W₁ s x) (VectorField.lieBracketWithin 𝕜 V W s x)","decl":"/-- Version of `lieBracketWithin_congr` in which one assumes that the point belongs to the\ngiven set. -/\ntheorem lieBracketWithin_congr' (hV : EqOn V₁ V s) (hW : EqOn W₁ W s) (hx : x ∈ s) :\n    lieBracketWithin 𝕜 V₁ W₁ s x = lieBracketWithin 𝕜 V W s x :=\n  lieBracketWithin_congr hV (hV hx) hW (hW hx)\n\n"}
{"name":"Filter.EventuallyEq.lieBracket_vectorField_eq","module":"Mathlib.Analysis.Calculus.VectorField","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\nV W V₁ W₁ : E → E\nx : E\nhV : (nhds x).EventuallyEq V₁ V\nhW : (nhds x).EventuallyEq W₁ W\n⊢ Eq (VectorField.lieBracket 𝕜 V₁ W₁ x) (VectorField.lieBracket 𝕜 V W x)","decl":"theorem _root_.Filter.EventuallyEq.lieBracket_vectorField_eq\n    (hV : V₁ =ᶠ[𝓝 x] V) (hW : W₁ =ᶠ[𝓝 x] W) :\n    lieBracket 𝕜 V₁ W₁ x = lieBracket 𝕜 V W x := by\n  rw [← lieBracketWithin_univ, ← lieBracketWithin_univ, hV.lieBracketWithin_vectorField_eq_nhds hW]\n\n"}
{"name":"Filter.EventuallyEq.lieBracket_vectorField","module":"Mathlib.Analysis.Calculus.VectorField","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\nV W V₁ W₁ : E → E\nx : E\nhV : (nhds x).EventuallyEq V₁ V\nhW : (nhds x).EventuallyEq W₁ W\n⊢ (nhds x).EventuallyEq (VectorField.lieBracket 𝕜 V₁ W₁) (VectorField.lieBracket 𝕜 V W)","decl":"protected theorem _root_.Filter.EventuallyEq.lieBracket_vectorField\n    (hV : V₁ =ᶠ[𝓝 x] V) (hW : W₁ =ᶠ[𝓝 x] W) : lieBracket 𝕜 V₁ W₁ =ᶠ[𝓝 x] lieBracket 𝕜 V W := by\n  filter_upwards [hV.eventuallyEq_nhds, hW.eventuallyEq_nhds] with y hVy hWy\n  exact hVy.lieBracket_vectorField_eq hWy\n\n"}
{"name":"VectorField.leibniz_identity_lieBracketWithin_of_isSymmSndFDerivWithinAt","module":"Mathlib.Analysis.Calculus.VectorField","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\nU V W : E → E\ns : Set E\nx : E\nhs : UniqueDiffOn 𝕜 s\nhx : Membership.mem s x\nhU : ContDiffWithinAt 𝕜 2 U s x\nhV : ContDiffWithinAt 𝕜 2 V s x\nhW : ContDiffWithinAt 𝕜 2 W s x\nh'U : IsSymmSndFDerivWithinAt 𝕜 U s x\nh'V : IsSymmSndFDerivWithinAt 𝕜 V s x\nh'W : IsSymmSndFDerivWithinAt 𝕜 W s x\n⊢ Eq (VectorField.lieBracketWithin 𝕜 U (VectorField.lieBracketWithin 𝕜 V W s) s x) (HAdd.hAdd (VectorField.lieBracketWithin 𝕜 (VectorField.lieBracketWithin 𝕜 U V s) W s x) (VectorField.lieBracketWithin 𝕜 V (VectorField.lieBracketWithin 𝕜 U W s) s x))","decl":"/-- The Lie bracket of vector fields in vector spaces satisfies the Leibniz identity\n`[U, [V, W]] = [[U, V], W] + [V, [U, W]]`. -/\nlemma leibniz_identity_lieBracketWithin_of_isSymmSndFDerivWithinAt\n    {U V W : E → E} {s : Set E} {x : E} (hs : UniqueDiffOn 𝕜 s) (hx : x ∈ s)\n    (hU : ContDiffWithinAt 𝕜 2 U s x) (hV : ContDiffWithinAt 𝕜 2 V s x)\n    (hW : ContDiffWithinAt 𝕜 2 W s x)\n    (h'U : IsSymmSndFDerivWithinAt 𝕜 U s x) (h'V : IsSymmSndFDerivWithinAt 𝕜 V s x)\n    (h'W : IsSymmSndFDerivWithinAt 𝕜 W s x) :\n    lieBracketWithin 𝕜 U (lieBracketWithin 𝕜 V W s) s x =\n      lieBracketWithin 𝕜 (lieBracketWithin 𝕜 U V s) W s x\n      + lieBracketWithin 𝕜 V (lieBracketWithin 𝕜 U W s) s x := by\n  simp only [lieBracketWithin_eq, map_sub]\n  have aux₁ {U V : E → E} (hU : ContDiffWithinAt 𝕜 2 U s x) (hV : ContDiffWithinAt 𝕜 2 V s x) :\n      DifferentiableWithinAt 𝕜 (fun x ↦ (fderivWithin 𝕜 V s x) (U x)) s x :=\n    have := hV.fderivWithin_right_apply (hU.of_le one_le_two) hs le_rfl hx\n    this.differentiableWithinAt le_rfl\n  have aux₂ {U V : E → E} (hU : ContDiffWithinAt 𝕜 2 U s x) (hV : ContDiffWithinAt 𝕜 2 V s x) :\n      fderivWithin 𝕜 (fun y ↦ (fderivWithin 𝕜 U s y) (V y)) s x =\n        (fderivWithin 𝕜 U s x).comp (fderivWithin 𝕜 V s x) +\n        (fderivWithin 𝕜 (fderivWithin 𝕜 U s) s x).flip (V x) := by\n    refine fderivWithin_clm_apply (hs x hx) ?_ (hV.differentiableWithinAt one_le_two)\n    exact (hU.fderivWithin_right hs le_rfl hx).differentiableWithinAt le_rfl\n  rw [fderivWithin_sub (hs x hx) (aux₁ hV hW) (aux₁ hW hV)]\n  rw [fderivWithin_sub (hs x hx) (aux₁ hU hV) (aux₁ hV hU)]\n  rw [fderivWithin_sub (hs x hx) (aux₁ hU hW) (aux₁ hW hU)]\n  rw [aux₂ hW hV, aux₂ hV hW, aux₂ hV hU, aux₂ hU hV, aux₂ hW hU, aux₂ hU hW]\n  simp only [ContinuousLinearMap.coe_sub', Pi.sub_apply, ContinuousLinearMap.add_apply,\n    ContinuousLinearMap.coe_comp', Function.comp_apply, ContinuousLinearMap.flip_apply, h'V.eq,\n    h'U.eq, h'W.eq]\n  abel\n\n"}
{"name":"VectorField.leibniz_identity_lieBracketWithin","module":"Mathlib.Analysis.Calculus.VectorField","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nn : WithTop ENat\nE : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\nhn : LE.le (minSmoothness 𝕜 2) n\nU V W : E → E\ns : Set E\nx : E\nhs : UniqueDiffOn 𝕜 s\nh'x : Membership.mem (closure (interior s)) x\nhx : Membership.mem s x\nhU : ContDiffWithinAt 𝕜 n U s x\nhV : ContDiffWithinAt 𝕜 n V s x\nhW : ContDiffWithinAt 𝕜 n W s x\n⊢ Eq (VectorField.lieBracketWithin 𝕜 U (VectorField.lieBracketWithin 𝕜 V W s) s x) (HAdd.hAdd (VectorField.lieBracketWithin 𝕜 (VectorField.lieBracketWithin 𝕜 U V s) W s x) (VectorField.lieBracketWithin 𝕜 V (VectorField.lieBracketWithin 𝕜 U W s) s x))","decl":"/-- The Lie bracket of vector fields in vector spaces satisfies the Leibniz identity\n`[U, [V, W]] = [[U, V], W] + [V, [U, W]]`. -/\nlemma leibniz_identity_lieBracketWithin (hn : minSmoothness 𝕜 2 ≤ n)\n    {U V W : E → E} {s : Set E} {x : E}\n    (hs : UniqueDiffOn 𝕜 s) (h'x : x ∈ closure (interior s)) (hx : x ∈ s)\n    (hU : ContDiffWithinAt 𝕜 n U s x) (hV : ContDiffWithinAt 𝕜 n V s x)\n    (hW : ContDiffWithinAt 𝕜 n W s x) :\n    lieBracketWithin 𝕜 U (lieBracketWithin 𝕜 V W s) s x =\n      lieBracketWithin 𝕜 (lieBracketWithin 𝕜 U V s) W s x\n      + lieBracketWithin 𝕜 V (lieBracketWithin 𝕜 U W s) s x := by\n  apply leibniz_identity_lieBracketWithin_of_isSymmSndFDerivWithinAt hs hx\n    (hU.of_le (le_minSmoothness.trans hn)) (hV.of_le (le_minSmoothness.trans hn))\n    (hW.of_le (le_minSmoothness.trans hn))\n  · exact hU.isSymmSndFDerivWithinAt hn hs h'x hx\n  · exact hV.isSymmSndFDerivWithinAt hn hs h'x hx\n  · exact hW.isSymmSndFDerivWithinAt hn hs h'x hx\n\n"}
{"name":"VectorField.leibniz_identity_lieBracket","module":"Mathlib.Analysis.Calculus.VectorField","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nn : WithTop ENat\nE : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\nhn : LE.le (minSmoothness 𝕜 2) n\nU V W : E → E\nx : E\nhU : ContDiffAt 𝕜 n U x\nhV : ContDiffAt 𝕜 n V x\nhW : ContDiffAt 𝕜 n W x\n⊢ Eq (VectorField.lieBracket 𝕜 U (VectorField.lieBracket 𝕜 V W) x) (HAdd.hAdd (VectorField.lieBracket 𝕜 (VectorField.lieBracket 𝕜 U V) W x) (VectorField.lieBracket 𝕜 V (VectorField.lieBracket 𝕜 U W) x))","decl":"/-- The Lie bracket of vector fields in vector spaces satisfies the Leibniz identity\n`[U, [V, W]] = [[U, V], W] + [V, [U, W]]`. -/\nlemma leibniz_identity_lieBracket (hn : minSmoothness 𝕜 2 ≤ n) {U V W : E → E} {x : E}\n    (hU : ContDiffAt 𝕜 n U x) (hV : ContDiffAt 𝕜 n V x) (hW : ContDiffAt 𝕜 n W x) :\n    lieBracket 𝕜 U (lieBracket 𝕜 V W) x =\n      lieBracket 𝕜 (lieBracket 𝕜 U V) W x + lieBracket 𝕜 V (lieBracket 𝕜 U W) x := by\n  simp only [← lieBracketWithin_univ, ← contDiffWithinAt_univ] at hU hV hW ⊢\n  exact leibniz_identity_lieBracketWithin hn uniqueDiffOn_univ (by simp) (mem_univ _) hU hV hW\n\n\n"}
{"name":"VectorField.pullbackWithin_eq","module":"Mathlib.Analysis.Calculus.VectorField","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nV : F → F\ns : Set E\n⊢ Eq (VectorField.pullbackWithin 𝕜 f V s) fun x => (fderivWithin 𝕜 f s x).inverse (V (f x))","decl":"lemma pullbackWithin_eq {f : E → F} {V : F → F} {s : Set E} :\n    pullbackWithin 𝕜 f V s = fun x ↦ (fderivWithin 𝕜 f s x).inverse (V (f x)) := rfl\n\n"}
{"name":"VectorField.pullback_eq_of_fderiv_eq","module":"Mathlib.Analysis.Calculus.VectorField","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nM : ContinuousLinearEquiv (RingHom.id 𝕜) E F\nx : E\nhf : Eq (↑M) (fderiv 𝕜 f x)\nV : F → F\n⊢ Eq (VectorField.pullback 𝕜 f V x) (M.symm (V (f x)))","decl":"lemma pullback_eq_of_fderiv_eq\n    {f : E → F} {M : E ≃L[𝕜] F} {x : E} (hf : M = fderiv 𝕜 f x) (V : F → F) :\n    pullback 𝕜 f V x = M.symm (V (f x)) := by\n  simp [pullback, ← hf]\n\n"}
{"name":"VectorField.pullback_eq_of_not_isInvertible","module":"Mathlib.Analysis.Calculus.VectorField","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nx : E\nh : Not (fderiv 𝕜 f x).IsInvertible\nV : F → F\n⊢ Eq (VectorField.pullback 𝕜 f V x) 0","decl":"lemma pullback_eq_of_not_isInvertible {f : E → F} {x : E}\n    (h : ¬(fderiv 𝕜 f x).IsInvertible) (V : F → F) :\n    pullback 𝕜 f V x = 0 := by\n  simp [pullback, h]\n\n"}
{"name":"VectorField.pullbackWithin_eq_of_not_isInvertible","module":"Mathlib.Analysis.Calculus.VectorField","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\ns : Set E\nf : E → F\nx : E\nh : Not (fderivWithin 𝕜 f s x).IsInvertible\nV : F → F\n⊢ Eq (VectorField.pullbackWithin 𝕜 f V s x) 0","decl":"lemma pullbackWithin_eq_of_not_isInvertible {f : E → F} {x : E}\n    (h : ¬(fderivWithin 𝕜 f s x).IsInvertible) (V : F → F) :\n    pullbackWithin 𝕜 f V s x = 0 := by\n  simp [pullbackWithin, h]\n\n"}
{"name":"VectorField.pullbackWithin_eq_of_fderivWithin_eq","module":"Mathlib.Analysis.Calculus.VectorField","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\ns : Set E\nf : E → F\nM : ContinuousLinearEquiv (RingHom.id 𝕜) E F\nx : E\nhf : Eq (↑M) (fderivWithin 𝕜 f s x)\nV : F → F\n⊢ Eq (VectorField.pullbackWithin 𝕜 f V s x) (M.symm (V (f x)))","decl":"lemma pullbackWithin_eq_of_fderivWithin_eq\n    {f : E → F} {M : E ≃L[𝕜] F} {x : E} (hf : M = fderivWithin 𝕜 f s x) (V : F → F) :\n    pullbackWithin 𝕜 f V s x = M.symm (V (f x)) := by\n  simp [pullbackWithin, ← hf]\n\n"}
{"name":"VectorField.pullbackWithin_univ","module":"Mathlib.Analysis.Calculus.VectorField","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nV : F → F\n⊢ Eq (VectorField.pullbackWithin 𝕜 f V Set.univ) (VectorField.pullback 𝕜 f V)","decl":"@[simp] lemma pullbackWithin_univ {f : E → F} {V : F → F} :\n    pullbackWithin 𝕜 f V univ = pullback 𝕜 f V := by\n  ext x\n  simp [pullbackWithin, pullback]\n\n"}
{"name":"VectorField.fderiv_pullback","module":"Mathlib.Analysis.Calculus.VectorField","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nV : F → F\nx : E\nh'f : (fderiv 𝕜 f x).IsInvertible\n⊢ Eq ((fderiv 𝕜 f x) (VectorField.pullback 𝕜 f V x)) (V (f x))","decl":"lemma fderiv_pullback (f : E → F) (V : F → F) (x : E) (h'f : (fderiv 𝕜 f x).IsInvertible) :\n    fderiv 𝕜 f x (pullback 𝕜 f V x) = V (f x) := by\n  rcases h'f with ⟨M, hM⟩\n  simp [pullback_eq_of_fderiv_eq hM, ← hM]\n\n"}
{"name":"VectorField.fderivWithin_pullbackWithin","module":"Mathlib.Analysis.Calculus.VectorField","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\ns : Set E\nf : E → F\nV : F → F\nx : E\nh'f : (fderivWithin 𝕜 f s x).IsInvertible\n⊢ Eq ((fderivWithin 𝕜 f s x) (VectorField.pullbackWithin 𝕜 f V s x)) (V (f x))","decl":"lemma fderivWithin_pullbackWithin {f : E → F} {V : F → F} {x : E}\n    (h'f : (fderivWithin 𝕜 f s x).IsInvertible) :\n    fderivWithin 𝕜 f s x (pullbackWithin 𝕜 f V s x) = V (f x) := by\n  rcases h'f with ⟨M, hM⟩\n  simp [pullbackWithin_eq_of_fderivWithin_eq hM, ← hM]\n\n"}
{"name":"exists_continuousLinearEquiv_fderivWithin_symm_eq","module":"Mathlib.Analysis.Calculus.VectorField","initialProofState":"𝕜 : Type u_1\ninst✝⁵ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace 𝕜 F\ninst✝ : CompleteSpace E\nf : E → F\ns : Set E\nx : E\nh'f : ContDiffWithinAt 𝕜 2 f s x\nhf : (fderivWithin 𝕜 f s x).IsInvertible\nhs : UniqueDiffOn 𝕜 s\nhx : Membership.mem s x\n⊢ Exists fun N => And (ContDiffWithinAt 𝕜 1 (fun y => ↑(N y)) s x) (And (ContDiffWithinAt 𝕜 1 (fun y => ↑(N y).symm) s x) (And (Filter.Eventually (fun y => Eq (↑(N y)) (fderivWithin 𝕜 f s y)) (nhdsWithin x s)) (∀ (v : E), Eq ((fderivWithin 𝕜 (fun y => ↑(N y).symm) s x) v) (Neg.neg ((↑(N x).symm).comp (((fderivWithin 𝕜 (fderivWithin 𝕜 f s) s x) v).comp ↑(N x).symm))))))","decl":"/-- If a `C^2` map has an invertible derivative within a set at a point, then nearby derivatives\ncan be written as continuous linear equivs, which depend in a `C^1` way on the point, as well as\ntheir inverse, and moreover one can compute the derivative of the inverse. -/\nlemma _root_.exists_continuousLinearEquiv_fderivWithin_symm_eq\n    {f : E → F} {s : Set E} {x : E} (h'f : ContDiffWithinAt 𝕜 2 f s x)\n    (hf : (fderivWithin 𝕜 f s x).IsInvertible) (hs : UniqueDiffOn 𝕜 s) (hx : x ∈ s) :\n    ∃ N : E → (E ≃L[𝕜] F), ContDiffWithinAt 𝕜 1 (fun y ↦ (N y : E →L[𝕜] F)) s x\n    ∧ ContDiffWithinAt 𝕜 1 (fun y ↦ ((N y).symm : F →L[𝕜] E)) s x\n    ∧ (∀ᶠ y in 𝓝[s] x, N y = fderivWithin 𝕜 f s y)\n    ∧ ∀ v, fderivWithin 𝕜 (fun y ↦ ((N y).symm : F →L[𝕜] E)) s x v\n      = - (N x).symm  ∘L ((fderivWithin 𝕜 (fderivWithin 𝕜 f s) s x v)) ∘L (N x).symm := by\n  classical\n  rcases hf with ⟨M, hM⟩\n  let U := {y | ∃ (N : E ≃L[𝕜] F), N = fderivWithin 𝕜 f s y}\n  have hU : U ∈ 𝓝[s] x := by\n    have I : range ((↑) : (E ≃L[𝕜] F) → E →L[𝕜] F) ∈ 𝓝 (fderivWithin 𝕜 f s x) := by\n      rw [← hM]\n      exact M.nhds\n    have : ContinuousWithinAt (fderivWithin 𝕜 f s) s x :=\n      (h'f.fderivWithin_right (m := 1) hs le_rfl hx).continuousWithinAt\n    exact this I\n  let N : E → (E ≃L[𝕜] F) := fun x ↦ if h : x ∈ U then h.choose else M\n  have eN : (fun y ↦ (N y : E →L[𝕜] F)) =ᶠ[𝓝[s] x] fun y ↦ fderivWithin 𝕜 f s y := by\n    filter_upwards [hU] with y hy\n    simpa only [hy, ↓reduceDIte, N] using Exists.choose_spec hy\n  have e'N : N x = fderivWithin 𝕜 f s x := by apply mem_of_mem_nhdsWithin hx eN\n  have hN : ContDiffWithinAt 𝕜 1 (fun y ↦ (N y : E →L[𝕜] F)) s x := by\n    have : ContDiffWithinAt 𝕜 1 (fun y ↦ fderivWithin 𝕜 f s y) s x :=\n      h'f.fderivWithin_right (m := 1) hs le_rfl hx\n    apply this.congr_of_eventuallyEq eN e'N\n  have hN' : ContDiffWithinAt 𝕜 1 (fun y ↦ ((N y).symm : F →L[𝕜] E)) s x := by\n    have : ContDiffWithinAt 𝕜 1 (ContinuousLinearMap.inverse ∘ (fun y ↦ (N y : E →L[𝕜] F))) s x :=\n      (contDiffAt_map_inverse (N x)).comp_contDiffWithinAt x hN\n    convert this with y\n    simp only [Function.comp_apply, ContinuousLinearMap.inverse_equiv]\n  refine ⟨N, hN, hN', eN, fun v ↦ ?_⟩\n  have A' y : ContinuousLinearMap.compL 𝕜 F E F (N y : E →L[𝕜] F) ((N y).symm : F →L[𝕜] E)\n      = ContinuousLinearMap.id 𝕜 F := by ext; simp\n  have : fderivWithin 𝕜 (fun y ↦ ContinuousLinearMap.compL 𝕜 F E F (N y : E →L[𝕜] F)\n      ((N y).symm : F →L[𝕜] E)) s x v = 0 := by\n    simp [A', fderivWithin_const_apply, hs x hx]\n  have I : (N x : E →L[𝕜] F) ∘L (fderivWithin 𝕜 (fun y ↦ ((N y).symm : F →L[𝕜] E)) s x v) =\n      - (fderivWithin 𝕜 (fun y ↦ (N y : E →L[𝕜] F)) s x v) ∘L ((N x).symm : F →L[𝕜] E) := by\n    rw [ContinuousLinearMap.fderivWithin_of_bilinear _ (hN.differentiableWithinAt le_rfl)\n      (hN'.differentiableWithinAt le_rfl) (hs x hx)] at this\n    simpa [eq_neg_iff_add_eq_zero] using this\n  have B (M : F →L[𝕜] E) : M = ((N x).symm : F →L[𝕜] E) ∘L ((N x) ∘L M) := by\n    ext; simp\n  rw [B (fderivWithin 𝕜 (fun y ↦ ((N y).symm : F →L[𝕜] E)) s x v), I]\n  simp only [ContinuousLinearMap.comp_neg, neg_inj, eN.fderivWithin_eq e'N]\n\n"}
{"name":"VectorField.DifferentiableWithinAt.pullbackWithin","module":"Mathlib.Analysis.Calculus.VectorField","initialProofState":"𝕜 : Type u_1\ninst✝⁵ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace 𝕜 F\ninst✝ : CompleteSpace E\nf : E → F\nV : F → F\ns : Set E\nt : Set F\nx : E\nhV : DifferentiableWithinAt 𝕜 V t (f x)\nhf : ContDiffWithinAt 𝕜 2 f s x\nhf' : (fderivWithin 𝕜 f s x).IsInvertible\nhs : UniqueDiffOn 𝕜 s\nhx : Membership.mem s x\nhst : Set.MapsTo f s t\n⊢ DifferentiableWithinAt 𝕜 (VectorField.pullbackWithin 𝕜 f V s) s x","decl":"lemma DifferentiableWithinAt.pullbackWithin {f : E → F} {V : F → F} {s : Set E} {t : Set F} {x : E}\n    (hV : DifferentiableWithinAt 𝕜 V t (f x))\n    (hf : ContDiffWithinAt 𝕜 2 f s x) (hf' : (fderivWithin 𝕜 f s x).IsInvertible)\n    (hs : UniqueDiffOn 𝕜 s) (hx : x ∈ s) (hst : MapsTo f s t) :\n    DifferentiableWithinAt 𝕜 (pullbackWithin 𝕜 f V s) s x := by\n  rcases exists_continuousLinearEquiv_fderivWithin_symm_eq hf hf' hs hx\n    with ⟨M, -, M_symm_smooth, hM, -⟩\n  simp only [pullbackWithin_eq]\n  have : DifferentiableWithinAt 𝕜 (fun y ↦ ((M y).symm : F →L[𝕜] E) (V (f y))) s x := by\n    apply DifferentiableWithinAt.clm_apply\n    · exact M_symm_smooth.differentiableWithinAt le_rfl\n    · exact hV.comp _ (hf.differentiableWithinAt one_le_two) hst\n  apply this.congr_of_eventuallyEq\n  · filter_upwards [hM] with y hy using by simp [← hy]\n  · have hMx : M x = fderivWithin 𝕜 f s x := by apply mem_of_mem_nhdsWithin hx hM\n    simp [← hMx]\n\n"}
{"name":"exists_continuousLinearEquiv_fderiv_symm_eq","module":"Mathlib.Analysis.Calculus.VectorField","initialProofState":"𝕜 : Type u_1\ninst✝⁵ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace 𝕜 F\ninst✝ : CompleteSpace E\nf : E → F\nx : E\nh'f : ContDiffAt 𝕜 2 f x\nhf : (fderiv 𝕜 f x).IsInvertible\n⊢ Exists fun N => And (ContDiffAt 𝕜 1 (fun y => ↑(N y)) x) (And (ContDiffAt 𝕜 1 (fun y => ↑(N y).symm) x) (And (Filter.Eventually (fun y => Eq (↑(N y)) (fderiv 𝕜 f y)) (nhds x)) (∀ (v : E), Eq ((fderiv 𝕜 (fun y => ↑(N y).symm) x) v) (Neg.neg ((↑(N x).symm).comp (((fderiv 𝕜 (fderiv 𝕜 f) x) v).comp ↑(N x).symm))))))","decl":"/-- If a `C^2` map has an invertible derivative at a point, then nearby derivatives can be written\nas continuous linear equivs, which depend in a `C^1` way on the point, as well as their inverse, and\nmoreover one can compute the derivative of the inverse. -/\nlemma _root_.exists_continuousLinearEquiv_fderiv_symm_eq\n    {f : E → F} {x : E} (h'f : ContDiffAt 𝕜 2 f x) (hf : (fderiv 𝕜 f x).IsInvertible) :\n    ∃ N : E → (E ≃L[𝕜] F), ContDiffAt 𝕜 1 (fun y ↦ (N y : E →L[𝕜] F)) x\n    ∧ ContDiffAt 𝕜 1 (fun y ↦ ((N y).symm : F →L[𝕜] E)) x\n    ∧ (∀ᶠ y in 𝓝 x, N y = fderiv 𝕜 f y)\n    ∧ ∀ v, fderiv 𝕜 (fun y ↦ ((N y).symm : F →L[𝕜] E)) x v\n      = - (N x).symm  ∘L ((fderiv 𝕜 (fderiv 𝕜 f) x v)) ∘L (N x).symm := by\n  simp only [← fderivWithin_univ, ← contDiffWithinAt_univ, ← nhdsWithin_univ] at hf h'f ⊢\n  exact exists_continuousLinearEquiv_fderivWithin_symm_eq h'f hf uniqueDiffOn_univ (mem_univ _)\n\n"}
{"name":"VectorField.pullbackWithin_lieBracketWithin_of_isSymmSndFDerivWithinAt","module":"Mathlib.Analysis.Calculus.VectorField","initialProofState":"𝕜 : Type u_1\ninst✝⁵ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace 𝕜 F\ns : Set E\ninst✝ : CompleteSpace E\nf : E → F\nV W : F → F\nx : E\nt : Set F\nhf : IsSymmSndFDerivWithinAt 𝕜 f s x\nh'f : ContDiffWithinAt 𝕜 2 f s x\nhV : DifferentiableWithinAt 𝕜 V t (f x)\nhW : DifferentiableWithinAt 𝕜 W t (f x)\nhu : UniqueDiffOn 𝕜 s\nhx : Membership.mem s x\nhst : Set.MapsTo f s t\n⊢ Eq (VectorField.pullbackWithin 𝕜 f (VectorField.lieBracketWithin 𝕜 V W t) s x) (VectorField.lieBracketWithin 𝕜 (VectorField.pullbackWithin 𝕜 f V s) (VectorField.pullbackWithin 𝕜 f W s) s x)","decl":"/-- The Lie bracket commutes with taking pullbacks. This requires the function to have symmetric\nsecond derivative. Version in a complete space. One could also give a version avoiding\ncompleteness but requiring that `f` is a local diffeo. -/\nlemma pullbackWithin_lieBracketWithin_of_isSymmSndFDerivWithinAt\n    {f : E → F} {V W : F → F} {x : E} {t : Set F}\n    (hf : IsSymmSndFDerivWithinAt 𝕜 f s x) (h'f : ContDiffWithinAt 𝕜 2 f s x)\n    (hV : DifferentiableWithinAt 𝕜 V t (f x)) (hW : DifferentiableWithinAt 𝕜 W t (f x))\n    (hu : UniqueDiffOn 𝕜 s) (hx : x ∈ s) (hst : MapsTo f s t) :\n    pullbackWithin 𝕜 f (lieBracketWithin 𝕜 V W t) s x\n      = lieBracketWithin 𝕜 (pullbackWithin 𝕜 f V s) (pullbackWithin 𝕜 f W s) s x := by\n  by_cases h : (fderivWithin 𝕜 f s x).IsInvertible; swap\n  · simp [pullbackWithin_eq_of_not_isInvertible h, lieBracketWithin_eq]\n  rcases exists_continuousLinearEquiv_fderivWithin_symm_eq h'f h hu hx\n    with ⟨M, -, M_symm_smooth, hM, M_diff⟩\n  have hMx : M x = fderivWithin 𝕜 f s x := (mem_of_mem_nhdsWithin hx hM :)\n  have AV : fderivWithin 𝕜 (pullbackWithin 𝕜 f V s) s x =\n      fderivWithin 𝕜 (fun y ↦ ((M y).symm : F →L[𝕜] E) (V (f y))) s x := by\n    apply Filter.EventuallyEq.fderivWithin_eq_of_mem _ hx\n    filter_upwards [hM] with y hy using pullbackWithin_eq_of_fderivWithin_eq hy _\n  have AW : fderivWithin 𝕜 (pullbackWithin 𝕜 f W s) s x =\n      fderivWithin 𝕜 (fun y ↦ ((M y).symm : F →L[𝕜] E) (W (f y))) s x := by\n    apply Filter.EventuallyEq.fderivWithin_eq_of_mem _ hx\n    filter_upwards [hM] with y hy using pullbackWithin_eq_of_fderivWithin_eq hy _\n  have Af : DifferentiableWithinAt 𝕜 f s x := h'f.differentiableWithinAt one_le_two\n  simp only [lieBracketWithin_eq, pullbackWithin_eq_of_fderivWithin_eq hMx, map_sub, AV, AW]\n  rw [fderivWithin_clm_apply, fderivWithin_clm_apply]\n  · simp [fderivWithin_comp' x hW Af hst (hu x hx), ← hMx,\n      fderivWithin_comp' x hV Af hst (hu x hx), M_diff, hf.eq]\n  · exact hu x hx\n  · exact M_symm_smooth.differentiableWithinAt le_rfl\n  · exact hV.comp x Af hst\n  · exact hu x hx\n  · exact M_symm_smooth.differentiableWithinAt le_rfl\n  · exact hW.comp x Af hst\n\n"}
{"name":"VectorField.pullbackWithin_lieBracketWithin_of_isSymmSndFDerivWithinAt_of_eventuallyEq","module":"Mathlib.Analysis.Calculus.VectorField","initialProofState":"𝕜 : Type u_1\ninst✝⁵ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace 𝕜 F\ns : Set E\ninst✝ : CompleteSpace E\nf : E → F\nV W : F → F\nx : E\nt : Set F\nu : Set E\nhf : IsSymmSndFDerivWithinAt 𝕜 f s x\nh'f : ContDiffWithinAt 𝕜 2 f s x\nhV : DifferentiableWithinAt 𝕜 V t (f x)\nhW : DifferentiableWithinAt 𝕜 W t (f x)\nhu : UniqueDiffOn 𝕜 u\nhx : Membership.mem u x\nhst : Set.MapsTo f u t\nhus : (nhds x).EventuallyEq u s\n⊢ Eq (VectorField.pullbackWithin 𝕜 f (VectorField.lieBracketWithin 𝕜 V W t) s x) (VectorField.lieBracketWithin 𝕜 (VectorField.pullbackWithin 𝕜 f V s) (VectorField.pullbackWithin 𝕜 f W s) s x)","decl":"/-- The Lie bracket commutes with taking pullbacks. This requires the function to have symmetric\nsecond derivative. Version in a complete space. One could also give a version avoiding\ncompleteness but requiring that `f` is a local diffeo. Variant where unique differentiability and\nthe invariance property are only required in a smaller set `u`. -/\nlemma pullbackWithin_lieBracketWithin_of_isSymmSndFDerivWithinAt_of_eventuallyEq\n    {f : E → F} {V W : F → F} {x : E} {t : Set F} {u : Set E}\n    (hf : IsSymmSndFDerivWithinAt 𝕜 f s x) (h'f : ContDiffWithinAt 𝕜 2 f s x)\n    (hV : DifferentiableWithinAt 𝕜 V t (f x)) (hW : DifferentiableWithinAt 𝕜 W t (f x))\n    (hu : UniqueDiffOn 𝕜 u) (hx : x ∈ u) (hst : MapsTo f u t) (hus : u =ᶠ[𝓝 x] s) :\n    pullbackWithin 𝕜 f (lieBracketWithin 𝕜 V W t) s x\n      = lieBracketWithin 𝕜 (pullbackWithin 𝕜 f V s) (pullbackWithin 𝕜 f W s) s x := calc\n  pullbackWithin 𝕜 f (lieBracketWithin 𝕜 V W t) s x\n  _ = pullbackWithin 𝕜 f (lieBracketWithin 𝕜 V W t) u x := by\n    simp only [pullbackWithin]\n    congr 2\n    exact fderivWithin_congr_set hus.symm\n  _ = lieBracketWithin 𝕜 (pullbackWithin 𝕜 f V u) (pullbackWithin 𝕜 f W u) u x :=\n    pullbackWithin_lieBracketWithin_of_isSymmSndFDerivWithinAt\n      (hf.congr_set hus.symm) (h'f.congr_set hus.symm) hV hW hu hx hst\n  _ = lieBracketWithin 𝕜 (pullbackWithin 𝕜 f V s) (pullbackWithin 𝕜 f W s) u x := by\n    apply Filter.EventuallyEq.lieBracketWithin_vectorField_eq_of_mem _ _ hx\n    · apply nhdsWithin_le_nhds\n      filter_upwards [fderivWithin_eventually_congr_set (𝕜 := 𝕜) (f := f) hus] with y hy\n      simp [pullbackWithin, hy]\n    · apply nhdsWithin_le_nhds\n      filter_upwards [fderivWithin_eventually_congr_set (𝕜 := 𝕜) (f := f) hus] with y hy\n      simp [pullbackWithin, hy]\n  _ = lieBracketWithin 𝕜 (pullbackWithin 𝕜 f V s) (pullbackWithin 𝕜 f W s) s x :=\n    lieBracketWithin_congr_set hus\n\n"}
{"name":"VectorField.pullback_lieBracket_of_isSymmSndFDerivAt","module":"Mathlib.Analysis.Calculus.VectorField","initialProofState":"𝕜 : Type u_1\ninst✝⁵ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace 𝕜 F\ninst✝ : CompleteSpace E\nf : E → F\nV W : F → F\nx : E\nhf : IsSymmSndFDerivAt 𝕜 f x\nh'f : ContDiffAt 𝕜 2 f x\nhV : DifferentiableAt 𝕜 V (f x)\nhW : DifferentiableAt 𝕜 W (f x)\n⊢ Eq (VectorField.pullback 𝕜 f (VectorField.lieBracket 𝕜 V W) x) (VectorField.lieBracket 𝕜 (VectorField.pullback 𝕜 f V) (VectorField.pullback 𝕜 f W) x)","decl":"/-- The Lie bracket commutes with taking pullbacks. This requires the function to have symmetric\nsecond derivative. Version in a complete space. One could also give a version avoiding\ncompleteness but requiring that `f` is a local diffeo. -/\nlemma pullback_lieBracket_of_isSymmSndFDerivAt {f : E → F} {V W : F → F} {x : E}\n    (hf : IsSymmSndFDerivAt 𝕜 f x) (h'f : ContDiffAt 𝕜 2 f x)\n    (hV : DifferentiableAt 𝕜 V (f x)) (hW : DifferentiableAt 𝕜 W (f x)) :\n    pullback 𝕜 f (lieBracket 𝕜 V W) x = lieBracket 𝕜 (pullback 𝕜 f V) (pullback 𝕜 f W) x := by\n  simp only [← lieBracketWithin_univ, ← pullbackWithin_univ, ← isSymmSndFDerivWithinAt_univ,\n    ← differentiableWithinAt_univ] at hf h'f hV hW ⊢\n  exact pullbackWithin_lieBracketWithin_of_isSymmSndFDerivWithinAt hf h'f hV hW uniqueDiffOn_univ\n    (mem_univ _) (mapsTo_univ _ _)\n\n"}
{"name":"VectorField.pullbackWithin_lieBracketWithin","module":"Mathlib.Analysis.Calculus.VectorField","initialProofState":"𝕜 : Type u_1\ninst✝⁵ : NontriviallyNormedField 𝕜\nn : WithTop ENat\nE : Type u_2\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace 𝕜 F\ns : Set E\ninst✝ : CompleteSpace E\nf : E → F\nV W : F → F\nx : E\nt : Set F\nhn : LE.le (minSmoothness 𝕜 2) n\nh'f : ContDiffWithinAt 𝕜 n f s x\nhV : DifferentiableWithinAt 𝕜 V t (f x)\nhW : DifferentiableWithinAt 𝕜 W t (f x)\nhu : UniqueDiffOn 𝕜 s\nhx : Membership.mem s x\nh'x : Membership.mem (closure (interior s)) x\nhst : Set.MapsTo f s t\n⊢ Eq (VectorField.pullbackWithin 𝕜 f (VectorField.lieBracketWithin 𝕜 V W t) s x) (VectorField.lieBracketWithin 𝕜 (VectorField.pullbackWithin 𝕜 f V s) (VectorField.pullbackWithin 𝕜 f W s) s x)","decl":"/-- The Lie bracket commutes with taking pullbacks. This requires the function to have symmetric\nsecond derivative. Version in a complete space. One could also give a version avoiding\ncompleteness but requiring that `f` is a local diffeo. -/\nlemma pullbackWithin_lieBracketWithin\n    {f : E → F} {V W : F → F} {x : E} {t : Set F} (hn : minSmoothness 𝕜 2 ≤ n)\n    (h'f : ContDiffWithinAt 𝕜 n f s x)\n    (hV : DifferentiableWithinAt 𝕜 V t (f x)) (hW : DifferentiableWithinAt 𝕜 W t (f x))\n    (hu : UniqueDiffOn 𝕜 s) (hx : x ∈ s) (h'x : x ∈ closure (interior s)) (hst : MapsTo f s t) :\n    pullbackWithin 𝕜 f (lieBracketWithin 𝕜 V W t) s x\n      = lieBracketWithin 𝕜 (pullbackWithin 𝕜 f V s) (pullbackWithin 𝕜 f W s) s x :=\n  pullbackWithin_lieBracketWithin_of_isSymmSndFDerivWithinAt\n  (h'f.isSymmSndFDerivWithinAt hn hu h'x hx) (h'f.of_le (le_minSmoothness.trans hn)) hV hW hu hx hst\n\n"}
{"name":"VectorField.pullback_lieBracket","module":"Mathlib.Analysis.Calculus.VectorField","initialProofState":"𝕜 : Type u_1\ninst✝⁵ : NontriviallyNormedField 𝕜\nn : WithTop ENat\nE : Type u_2\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace 𝕜 F\ninst✝ : CompleteSpace E\nhn : LE.le (minSmoothness 𝕜 2) n\nf : E → F\nV W : F → F\nx : E\nh'f : ContDiffAt 𝕜 n f x\nhV : DifferentiableAt 𝕜 V (f x)\nhW : DifferentiableAt 𝕜 W (f x)\n⊢ Eq (VectorField.pullback 𝕜 f (VectorField.lieBracket 𝕜 V W) x) (VectorField.lieBracket 𝕜 (VectorField.pullback 𝕜 f V) (VectorField.pullback 𝕜 f W) x)","decl":"/-- The Lie bracket commutes with taking pullbacks. One could also give a version avoiding\ncompleteness but requiring that `f` is a local diffeo. -/\nlemma pullback_lieBracket (hn : minSmoothness 𝕜 2 ≤ n)\n    {f : E → F} {V W : F → F} {x : E} (h'f : ContDiffAt 𝕜 n f x)\n    (hV : DifferentiableAt 𝕜 V (f x)) (hW : DifferentiableAt 𝕜 W (f x)) :\n    pullback 𝕜 f (lieBracket 𝕜 V W) x = lieBracket 𝕜 (pullback 𝕜 f V) (pullback 𝕜 f W) x :=\n  pullback_lieBracket_of_isSymmSndFDerivAt (h'f.isSymmSndFDerivAt hn)\n    (h'f.of_le (le_minSmoothness.trans hn)) hV hW\n\n"}
