{"name":"VectorField.lieBracket_eq","module":"Mathlib.Analysis.Calculus.VectorField","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nV W : E â†’ E\nâŠ¢ Eq (VectorField.lieBracket ğ•œ V W) fun x => HSub.hSub ((fderiv ğ•œ W x) (V x)) ((fderiv ğ•œ V x) (W x))","decl":"lemma lieBracket_eq :\n    lieBracket ğ•œ V W = fun x â†¦ fderiv ğ•œ W x (V x) - fderiv ğ•œ V x (W x) := rfl\n\n"}
{"name":"VectorField.lieBracketWithin_eq","module":"Mathlib.Analysis.Calculus.VectorField","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nV W : E â†’ E\ns : Set E\nâŠ¢ Eq (VectorField.lieBracketWithin ğ•œ V W s) fun x => HSub.hSub ((fderivWithin ğ•œ W s x) (V x)) ((fderivWithin ğ•œ V s x) (W x))","decl":"lemma lieBracketWithin_eq :\n    lieBracketWithin ğ•œ V W s =\n      fun x â†¦ fderivWithin ğ•œ W s x (V x) - fderivWithin ğ•œ V s x (W x) := rfl\n\n"}
{"name":"VectorField.lieBracketWithin_univ","module":"Mathlib.Analysis.Calculus.VectorField","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nV W : E â†’ E\nâŠ¢ Eq (VectorField.lieBracketWithin ğ•œ V W Set.univ) (VectorField.lieBracket ğ•œ V W)","decl":"@[simp]\ntheorem lieBracketWithin_univ : lieBracketWithin ğ•œ V W univ = lieBracket ğ•œ V W := by\n  ext1 x\n  simp [lieBracketWithin, lieBracket]\n\n"}
{"name":"VectorField.lieBracketWithin_eq_zero_of_eq_zero","module":"Mathlib.Analysis.Calculus.VectorField","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nV W : E â†’ E\ns : Set E\nx : E\nhV : Eq (V x) 0\nhW : Eq (W x) 0\nâŠ¢ Eq (VectorField.lieBracketWithin ğ•œ V W s x) 0","decl":"lemma lieBracketWithin_eq_zero_of_eq_zero (hV : V x = 0) (hW : W x = 0) :\n    lieBracketWithin ğ•œ V W s x = 0 := by\n  simp [lieBracketWithin, hV, hW]\n\n"}
{"name":"VectorField.lieBracket_eq_zero_of_eq_zero","module":"Mathlib.Analysis.Calculus.VectorField","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nV W : E â†’ E\nx : E\nhV : Eq (V x) 0\nhW : Eq (W x) 0\nâŠ¢ Eq (VectorField.lieBracket ğ•œ V W x) 0","decl":"lemma lieBracket_eq_zero_of_eq_zero (hV : V x = 0) (hW : W x = 0) :\n    lieBracket ğ•œ V W x = 0 := by\n  simp [lieBracket, hV, hW]\n\n"}
{"name":"VectorField.lieBracketWithin_smul_left","module":"Mathlib.Analysis.Calculus.VectorField","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nV W : E â†’ E\ns : Set E\nx : E\nc : ğ•œ\nhV : DifferentiableWithinAt ğ•œ V s x\nhs : UniqueDiffWithinAt ğ•œ s x\nâŠ¢ Eq (VectorField.lieBracketWithin ğ•œ (HSMul.hSMul c V) W s x) (HSMul.hSMul c (VectorField.lieBracketWithin ğ•œ V W s x))","decl":"lemma lieBracketWithin_smul_left {c : ğ•œ} (hV : DifferentiableWithinAt ğ•œ V s x)\n    (hs : UniqueDiffWithinAt ğ•œ s x) :\n    lieBracketWithin ğ•œ (c â€¢ V) W s x =\n      c â€¢ lieBracketWithin ğ•œ V W s x := by\n  simp only [lieBracketWithin, Pi.add_apply, map_add, Pi.smul_apply, map_smul, smul_sub]\n  rw [fderivWithin_const_smul' hs hV]\n  rfl\n\n"}
{"name":"VectorField.lieBracket_smul_left","module":"Mathlib.Analysis.Calculus.VectorField","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nV W : E â†’ E\nx : E\nc : ğ•œ\nhV : DifferentiableAt ğ•œ V x\nâŠ¢ Eq (VectorField.lieBracket ğ•œ (HSMul.hSMul c V) W x) (HSMul.hSMul c (VectorField.lieBracket ğ•œ V W x))","decl":"lemma lieBracket_smul_left {c : ğ•œ} (hV : DifferentiableAt ğ•œ V x) :\n    lieBracket ğ•œ (c â€¢ V) W x = c â€¢ lieBracket ğ•œ V W x := by\n  simp only [â† differentiableWithinAt_univ, â† lieBracketWithin_univ] at hV âŠ¢\n  exact lieBracketWithin_smul_left hV uniqueDiffWithinAt_univ\n\n"}
{"name":"VectorField.lieBracketWithin_smul_right","module":"Mathlib.Analysis.Calculus.VectorField","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nV W : E â†’ E\ns : Set E\nx : E\nc : ğ•œ\nhW : DifferentiableWithinAt ğ•œ W s x\nhs : UniqueDiffWithinAt ğ•œ s x\nâŠ¢ Eq (VectorField.lieBracketWithin ğ•œ V (HSMul.hSMul c W) s x) (HSMul.hSMul c (VectorField.lieBracketWithin ğ•œ V W s x))","decl":"lemma lieBracketWithin_smul_right {c : ğ•œ} (hW : DifferentiableWithinAt ğ•œ W s x)\n    (hs : UniqueDiffWithinAt ğ•œ s x) :\n    lieBracketWithin ğ•œ V (c â€¢ W) s x =\n      c â€¢ lieBracketWithin ğ•œ V W s x := by\n  simp only [lieBracketWithin, Pi.add_apply, map_add, Pi.smul_apply, map_smul, smul_sub]\n  rw [fderivWithin_const_smul' hs hW]\n  rfl\n\n"}
{"name":"VectorField.lieBracket_smul_right","module":"Mathlib.Analysis.Calculus.VectorField","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nV W : E â†’ E\nx : E\nc : ğ•œ\nhW : DifferentiableAt ğ•œ W x\nâŠ¢ Eq (VectorField.lieBracket ğ•œ V (HSMul.hSMul c W) x) (HSMul.hSMul c (VectorField.lieBracket ğ•œ V W x))","decl":"lemma lieBracket_smul_right {c : ğ•œ} (hW : DifferentiableAt ğ•œ W x) :\n    lieBracket ğ•œ V (c â€¢ W) x = c â€¢ lieBracket ğ•œ V W x := by\n  simp only [â† differentiableWithinAt_univ, â† lieBracketWithin_univ] at hW âŠ¢\n  exact lieBracketWithin_smul_right hW uniqueDiffWithinAt_univ\n\n"}
{"name":"VectorField.lieBracketWithin_add_left","module":"Mathlib.Analysis.Calculus.VectorField","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nV W Vâ‚ : E â†’ E\ns : Set E\nx : E\nhV : DifferentiableWithinAt ğ•œ V s x\nhVâ‚ : DifferentiableWithinAt ğ•œ Vâ‚ s x\nhs : UniqueDiffWithinAt ğ•œ s x\nâŠ¢ Eq (VectorField.lieBracketWithin ğ•œ (HAdd.hAdd V Vâ‚) W s x) (HAdd.hAdd (VectorField.lieBracketWithin ğ•œ V W s x) (VectorField.lieBracketWithin ğ•œ Vâ‚ W s x))","decl":"lemma lieBracketWithin_add_left (hV : DifferentiableWithinAt ğ•œ V s x)\n    (hVâ‚ : DifferentiableWithinAt ğ•œ Vâ‚ s x) (hs : UniqueDiffWithinAt ğ•œ s x) :\n    lieBracketWithin ğ•œ (V + Vâ‚) W s x =\n      lieBracketWithin ğ•œ V W s x + lieBracketWithin ğ•œ Vâ‚ W s x := by\n  simp only [lieBracketWithin, Pi.add_apply, map_add]\n  rw [fderivWithin_add' hs hV hVâ‚, ContinuousLinearMap.add_apply]\n  abel\n\n"}
{"name":"VectorField.lieBracket_add_left","module":"Mathlib.Analysis.Calculus.VectorField","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nV W Vâ‚ : E â†’ E\nx : E\nhV : DifferentiableAt ğ•œ V x\nhVâ‚ : DifferentiableAt ğ•œ Vâ‚ x\nâŠ¢ Eq (VectorField.lieBracket ğ•œ (HAdd.hAdd V Vâ‚) W x) (HAdd.hAdd (VectorField.lieBracket ğ•œ V W x) (VectorField.lieBracket ğ•œ Vâ‚ W x))","decl":"lemma lieBracket_add_left (hV : DifferentiableAt ğ•œ V x) (hVâ‚ : DifferentiableAt ğ•œ Vâ‚ x) :\n    lieBracket ğ•œ (V + Vâ‚) W  x =\n      lieBracket ğ•œ V W x + lieBracket ğ•œ Vâ‚ W x := by\n  simp only [lieBracket, Pi.add_apply, map_add]\n  rw [fderiv_add' hV hVâ‚, ContinuousLinearMap.add_apply]\n  abel\n\n"}
{"name":"VectorField.lieBracketWithin_add_right","module":"Mathlib.Analysis.Calculus.VectorField","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nV W Wâ‚ : E â†’ E\ns : Set E\nx : E\nhW : DifferentiableWithinAt ğ•œ W s x\nhWâ‚ : DifferentiableWithinAt ğ•œ Wâ‚ s x\nhs : UniqueDiffWithinAt ğ•œ s x\nâŠ¢ Eq (VectorField.lieBracketWithin ğ•œ V (HAdd.hAdd W Wâ‚) s x) (HAdd.hAdd (VectorField.lieBracketWithin ğ•œ V W s x) (VectorField.lieBracketWithin ğ•œ V Wâ‚ s x))","decl":"lemma lieBracketWithin_add_right (hW : DifferentiableWithinAt ğ•œ W s x)\n    (hWâ‚ : DifferentiableWithinAt ğ•œ Wâ‚ s x) (hs :  UniqueDiffWithinAt ğ•œ s x) :\n    lieBracketWithin ğ•œ V (W + Wâ‚) s x =\n      lieBracketWithin ğ•œ V W s x + lieBracketWithin ğ•œ V Wâ‚ s x := by\n  simp only [lieBracketWithin, Pi.add_apply, map_add]\n  rw [fderivWithin_add' hs hW hWâ‚, ContinuousLinearMap.add_apply]\n  abel\n\n"}
{"name":"VectorField.lieBracket_add_right","module":"Mathlib.Analysis.Calculus.VectorField","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nV W Wâ‚ : E â†’ E\nx : E\nhW : DifferentiableAt ğ•œ W x\nhWâ‚ : DifferentiableAt ğ•œ Wâ‚ x\nâŠ¢ Eq (VectorField.lieBracket ğ•œ V (HAdd.hAdd W Wâ‚) x) (HAdd.hAdd (VectorField.lieBracket ğ•œ V W x) (VectorField.lieBracket ğ•œ V Wâ‚ x))","decl":"lemma lieBracket_add_right (hW : DifferentiableAt ğ•œ W x) (hWâ‚ : DifferentiableAt ğ•œ Wâ‚ x) :\n    lieBracket ğ•œ V (W + Wâ‚) x =\n      lieBracket ğ•œ V W x + lieBracket ğ•œ V Wâ‚ x := by\n  simp only [lieBracket, Pi.add_apply, map_add]\n  rw [fderiv_add' hW hWâ‚, ContinuousLinearMap.add_apply]\n  abel\n\n"}
{"name":"VectorField.lieBracketWithin_swap","module":"Mathlib.Analysis.Calculus.VectorField","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nV W : E â†’ E\ns : Set E\nâŠ¢ Eq (VectorField.lieBracketWithin ğ•œ V W s) (Neg.neg (VectorField.lieBracketWithin ğ•œ W V s))","decl":"lemma lieBracketWithin_swap : lieBracketWithin ğ•œ V W s = - lieBracketWithin ğ•œ W V s := by\n  ext x; simp [lieBracketWithin]\n\n"}
{"name":"VectorField.lieBracket_swap","module":"Mathlib.Analysis.Calculus.VectorField","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nV W : E â†’ E\nx : E\nâŠ¢ Eq (VectorField.lieBracket ğ•œ V W x) (Neg.neg (VectorField.lieBracket ğ•œ W V x))","decl":"lemma lieBracket_swap : lieBracket ğ•œ V W x = - lieBracket ğ•œ W V x := by\n  simp [lieBracket]\n\n"}
{"name":"VectorField.lieBracketWithin_self","module":"Mathlib.Analysis.Calculus.VectorField","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nV : E â†’ E\ns : Set E\nâŠ¢ Eq (VectorField.lieBracketWithin ğ•œ V V s) 0","decl":"@[simp] lemma lieBracketWithin_self : lieBracketWithin ğ•œ V V s = 0 := by\n  ext x; simp [lieBracketWithin]\n\n"}
{"name":"VectorField.lieBracket_self","module":"Mathlib.Analysis.Calculus.VectorField","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nV : E â†’ E\nâŠ¢ Eq (VectorField.lieBracket ğ•œ V V) 0","decl":"@[simp] lemma lieBracket_self : lieBracket ğ•œ V V = 0 := by\n  ext x; simp [lieBracket]\n\n"}
{"name":"ContDiffWithinAt.lieBracketWithin_vectorField","module":"Mathlib.Analysis.Calculus.VectorField","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nV W : E â†’ E\ns : Set E\nx : E\nm n : WithTop ENat\nhV : ContDiffWithinAt ğ•œ n V s x\nhW : ContDiffWithinAt ğ•œ n W s x\nhs : UniqueDiffOn ğ•œ s\nhmn : LE.le (HAdd.hAdd m 1) n\nhx : Membership.mem s x\nâŠ¢ ContDiffWithinAt ğ•œ m (VectorField.lieBracketWithin ğ•œ V W s) s x","decl":"lemma _root_.ContDiffWithinAt.lieBracketWithin_vectorField\n    {m n : WithTop â„•âˆ} (hV : ContDiffWithinAt ğ•œ n V s x)\n    (hW : ContDiffWithinAt ğ•œ n W s x) (hs : UniqueDiffOn ğ•œ s) (hmn : m + 1 â‰¤ n) (hx : x âˆˆ s) :\n    ContDiffWithinAt ğ•œ m (lieBracketWithin ğ•œ V W s) s x := by\n  apply ContDiffWithinAt.sub\n  Â· exact ContDiffWithinAt.clm_apply (hW.fderivWithin_right hs hmn hx)\n      (hV.of_le (le_trans le_self_add hmn))\n  Â· exact ContDiffWithinAt.clm_apply (hV.fderivWithin_right hs hmn hx)\n      (hW.of_le (le_trans le_self_add hmn))\n\n"}
{"name":"ContDiffAt.lieBracket_vectorField","module":"Mathlib.Analysis.Calculus.VectorField","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nV W : E â†’ E\nx : E\nm n : WithTop ENat\nhV : ContDiffAt ğ•œ n V x\nhW : ContDiffAt ğ•œ n W x\nhmn : LE.le (HAdd.hAdd m 1) n\nâŠ¢ ContDiffAt ğ•œ m (VectorField.lieBracket ğ•œ V W) x","decl":"lemma _root_.ContDiffAt.lieBracket_vectorField {m n : WithTop â„•âˆ} (hV : ContDiffAt ğ•œ n V x)\n    (hW : ContDiffAt ğ•œ n W x) (hmn : m + 1 â‰¤ n) :\n    ContDiffAt ğ•œ m (lieBracket ğ•œ V W) x := by\n  rw [â† contDiffWithinAt_univ] at hV hW âŠ¢\n  simp_rw [â† lieBracketWithin_univ]\n  exact hV.lieBracketWithin_vectorField hW uniqueDiffOn_univ hmn (mem_univ _)\n\n"}
{"name":"ContDiffOn.lieBracketWithin_vectorField","module":"Mathlib.Analysis.Calculus.VectorField","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nV W : E â†’ E\ns : Set E\nm n : WithTop ENat\nhV : ContDiffOn ğ•œ n V s\nhW : ContDiffOn ğ•œ n W s\nhs : UniqueDiffOn ğ•œ s\nhmn : LE.le (HAdd.hAdd m 1) n\nâŠ¢ ContDiffOn ğ•œ m (VectorField.lieBracketWithin ğ•œ V W s) s","decl":"lemma _root_.ContDiffOn.lieBracketWithin_vectorField {m n : WithTop â„•âˆ} (hV : ContDiffOn ğ•œ n V s)\n    (hW : ContDiffOn ğ•œ n W s) (hs : UniqueDiffOn ğ•œ s) (hmn : m + 1 â‰¤ n) :\n    ContDiffOn ğ•œ m (lieBracketWithin ğ•œ V W s) s :=\n  fun x hx â†¦ (hV x hx).lieBracketWithin_vectorField (hW x hx) hs hmn hx\n\n"}
{"name":"ContDiff.lieBracket_vectorField","module":"Mathlib.Analysis.Calculus.VectorField","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nV W : E â†’ E\nm n : WithTop ENat\nhV : ContDiff ğ•œ n V\nhW : ContDiff ğ•œ n W\nhmn : LE.le (HAdd.hAdd m 1) n\nâŠ¢ ContDiff ğ•œ m (VectorField.lieBracket ğ•œ V W)","decl":"lemma _root_.ContDiff.lieBracket_vectorField {m n : WithTop â„•âˆ} (hV : ContDiff ğ•œ n V)\n    (hW : ContDiff ğ•œ n W) (hmn : m + 1 â‰¤ n) :\n    ContDiff ğ•œ m (lieBracket ğ•œ V W) :=\n  contDiff_iff_contDiffAt.2 (fun _ â†¦ hV.contDiffAt.lieBracket_vectorField hW.contDiffAt hmn)\n\n"}
{"name":"VectorField.lieBracketWithin_of_mem_nhdsWithin","module":"Mathlib.Analysis.Calculus.VectorField","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nV W : E â†’ E\ns t : Set E\nx : E\nst : Membership.mem (nhdsWithin x s) t\nhs : UniqueDiffWithinAt ğ•œ s x\nhV : DifferentiableWithinAt ğ•œ V t x\nhW : DifferentiableWithinAt ğ•œ W t x\nâŠ¢ Eq (VectorField.lieBracketWithin ğ•œ V W s x) (VectorField.lieBracketWithin ğ•œ V W t x)","decl":"theorem lieBracketWithin_of_mem_nhdsWithin (st : t âˆˆ ğ“[s] x) (hs : UniqueDiffWithinAt ğ•œ s x)\n    (hV : DifferentiableWithinAt ğ•œ V t x) (hW : DifferentiableWithinAt ğ•œ W t x) :\n    lieBracketWithin ğ•œ V W s x = lieBracketWithin ğ•œ V W t x := by\n  simp [lieBracketWithin, fderivWithin_of_mem_nhdsWithin st hs hV,\n    fderivWithin_of_mem_nhdsWithin st hs hW]\n\n"}
{"name":"VectorField.lieBracketWithin_subset","module":"Mathlib.Analysis.Calculus.VectorField","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nV W : E â†’ E\ns t : Set E\nx : E\nst : HasSubset.Subset s t\nht : UniqueDiffWithinAt ğ•œ s x\nhV : DifferentiableWithinAt ğ•œ V t x\nhW : DifferentiableWithinAt ğ•œ W t x\nâŠ¢ Eq (VectorField.lieBracketWithin ğ•œ V W s x) (VectorField.lieBracketWithin ğ•œ V W t x)","decl":"theorem lieBracketWithin_subset (st : s âŠ† t) (ht : UniqueDiffWithinAt ğ•œ s x)\n    (hV : DifferentiableWithinAt ğ•œ V t x) (hW : DifferentiableWithinAt ğ•œ W t x) :\n    lieBracketWithin ğ•œ V W s x = lieBracketWithin ğ•œ V W t x :=\n  lieBracketWithin_of_mem_nhdsWithin (nhdsWithin_mono _ st self_mem_nhdsWithin) ht hV hW\n\n"}
{"name":"VectorField.lieBracketWithin_inter","module":"Mathlib.Analysis.Calculus.VectorField","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nV W : E â†’ E\ns t : Set E\nx : E\nht : Membership.mem (nhds x) t\nâŠ¢ Eq (VectorField.lieBracketWithin ğ•œ V W (Inter.inter s t) x) (VectorField.lieBracketWithin ğ•œ V W s x)","decl":"theorem lieBracketWithin_inter (ht : t âˆˆ ğ“ x) :\n    lieBracketWithin ğ•œ V W (s âˆ© t) x = lieBracketWithin ğ•œ V W s x := by\n  simp [lieBracketWithin, fderivWithin_inter, ht]\n\n"}
{"name":"VectorField.lieBracketWithin_of_mem_nhds","module":"Mathlib.Analysis.Calculus.VectorField","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nV W : E â†’ E\ns : Set E\nx : E\nh : Membership.mem (nhds x) s\nâŠ¢ Eq (VectorField.lieBracketWithin ğ•œ V W s x) (VectorField.lieBracket ğ•œ V W x)","decl":"theorem lieBracketWithin_of_mem_nhds (h : s âˆˆ ğ“ x) :\n    lieBracketWithin ğ•œ V W s x = lieBracket ğ•œ V W x := by\n  rw [â† lieBracketWithin_univ, â† univ_inter s, lieBracketWithin_inter h]\n\n"}
{"name":"VectorField.lieBracketWithin_of_isOpen","module":"Mathlib.Analysis.Calculus.VectorField","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nV W : E â†’ E\ns : Set E\nx : E\nhs : IsOpen s\nhx : Membership.mem s x\nâŠ¢ Eq (VectorField.lieBracketWithin ğ•œ V W s x) (VectorField.lieBracket ğ•œ V W x)","decl":"theorem lieBracketWithin_of_isOpen (hs : IsOpen s) (hx : x âˆˆ s) :\n    lieBracketWithin ğ•œ V W s x = lieBracket ğ•œ V W x :=\n  lieBracketWithin_of_mem_nhds (hs.mem_nhds hx)\n\n"}
{"name":"VectorField.lieBracketWithin_eq_lieBracket","module":"Mathlib.Analysis.Calculus.VectorField","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nV W : E â†’ E\ns : Set E\nx : E\nhs : UniqueDiffWithinAt ğ•œ s x\nhV : DifferentiableAt ğ•œ V x\nhW : DifferentiableAt ğ•œ W x\nâŠ¢ Eq (VectorField.lieBracketWithin ğ•œ V W s x) (VectorField.lieBracket ğ•œ V W x)","decl":"theorem lieBracketWithin_eq_lieBracket (hs : UniqueDiffWithinAt ğ•œ s x)\n    (hV : DifferentiableAt ğ•œ V x) (hW : DifferentiableAt ğ•œ W x) :\n    lieBracketWithin ğ•œ V W s x = lieBracket ğ•œ V W x := by\n  simp [lieBracketWithin, lieBracket, fderivWithin_eq_fderiv, hs, hV, hW]\n\n"}
{"name":"VectorField.lieBracketWithin_congr_set'","module":"Mathlib.Analysis.Calculus.VectorField","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nV W : E â†’ E\ns t : Set E\nx y : E\nh : (nhdsWithin x (HasCompl.compl (Singleton.singleton y))).EventuallyEq s t\nâŠ¢ Eq (VectorField.lieBracketWithin ğ•œ V W s x) (VectorField.lieBracketWithin ğ•œ V W t x)","decl":"/-- Variant of `lieBracketWithin_congr_set` where one requires the sets to coincide only in\nthe complement of a point. -/\ntheorem lieBracketWithin_congr_set' (y : E) (h : s =á¶ [ğ“[{y}á¶œ] x] t) :\n    lieBracketWithin ğ•œ V W s x = lieBracketWithin ğ•œ V W t x := by\n  simp [lieBracketWithin, fderivWithin_congr_set' _ h]\n\n"}
{"name":"VectorField.lieBracketWithin_congr_set","module":"Mathlib.Analysis.Calculus.VectorField","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nV W : E â†’ E\ns t : Set E\nx : E\nh : (nhds x).EventuallyEq s t\nâŠ¢ Eq (VectorField.lieBracketWithin ğ•œ V W s x) (VectorField.lieBracketWithin ğ•œ V W t x)","decl":"theorem lieBracketWithin_congr_set (h : s =á¶ [ğ“ x] t) :\n    lieBracketWithin ğ•œ V W s x = lieBracketWithin ğ•œ V W t x :=\n  lieBracketWithin_congr_set' x <| h.filter_mono inf_le_left\n\n"}
{"name":"VectorField.lieBracketWithin_eventually_congr_set'","module":"Mathlib.Analysis.Calculus.VectorField","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nV W : E â†’ E\ns t : Set E\nx y : E\nh : (nhdsWithin x (HasCompl.compl (Singleton.singleton y))).EventuallyEq s t\nâŠ¢ (nhds x).EventuallyEq (VectorField.lieBracketWithin ğ•œ V W s) (VectorField.lieBracketWithin ğ•œ V W t)","decl":"/-- Variant of `lieBracketWithin_eventually_congr_set` where one requires the sets to coincide only\nin  the complement of a point. -/\ntheorem lieBracketWithin_eventually_congr_set' (y : E) (h : s =á¶ [ğ“[{y}á¶œ] x] t) :\n    lieBracketWithin ğ•œ V W s =á¶ [ğ“ x] lieBracketWithin ğ•œ V W t :=\n  (eventually_nhds_nhdsWithin.2 h).mono fun _ => lieBracketWithin_congr_set' y\n\n"}
{"name":"VectorField.lieBracketWithin_eventually_congr_set","module":"Mathlib.Analysis.Calculus.VectorField","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nV W : E â†’ E\ns t : Set E\nx : E\nh : (nhds x).EventuallyEq s t\nâŠ¢ (nhds x).EventuallyEq (VectorField.lieBracketWithin ğ•œ V W s) (VectorField.lieBracketWithin ğ•œ V W t)","decl":"theorem lieBracketWithin_eventually_congr_set (h : s =á¶ [ğ“ x] t) :\n    lieBracketWithin ğ•œ V W s =á¶ [ğ“ x] lieBracketWithin ğ•œ V W t :=\n  lieBracketWithin_eventually_congr_set' x <| h.filter_mono inf_le_left\n\n"}
{"name":"DifferentiableWithinAt.lieBracketWithin_congr_mono","module":"Mathlib.Analysis.Calculus.VectorField","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nV W Vâ‚ Wâ‚ : E â†’ E\ns t : Set E\nx : E\nhV : DifferentiableWithinAt ğ•œ V s x\nhVs : Set.EqOn Vâ‚ V t\nhVx : Eq (Vâ‚ x) (V x)\nhW : DifferentiableWithinAt ğ•œ W s x\nhWs : Set.EqOn Wâ‚ W t\nhWx : Eq (Wâ‚ x) (W x)\nhxt : UniqueDiffWithinAt ğ•œ t x\nhâ‚ : HasSubset.Subset t s\nâŠ¢ Eq (VectorField.lieBracketWithin ğ•œ Vâ‚ Wâ‚ t x) (VectorField.lieBracketWithin ğ•œ V W s x)","decl":"theorem _root_.DifferentiableWithinAt.lieBracketWithin_congr_mono\n    (hV : DifferentiableWithinAt ğ•œ V s x) (hVs : EqOn Vâ‚ V t) (hVx : Vâ‚ x = V x)\n    (hW : DifferentiableWithinAt ğ•œ W s x) (hWs : EqOn Wâ‚ W t) (hWx : Wâ‚ x = W x)\n    (hxt : UniqueDiffWithinAt ğ•œ t x) (hâ‚ : t âŠ† s) :\n    lieBracketWithin ğ•œ Vâ‚ Wâ‚ t x = lieBracketWithin ğ•œ V W s x := by\n  simp [lieBracketWithin, hV.fderivWithin_congr_mono, hW.fderivWithin_congr_mono, hVs, hVx,\n    hWs, hWx, hxt, hâ‚]\n\n"}
{"name":"Filter.EventuallyEq.lieBracketWithin_vectorField_eq","module":"Mathlib.Analysis.Calculus.VectorField","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nV W Vâ‚ Wâ‚ : E â†’ E\ns : Set E\nx : E\nhV : (nhdsWithin x s).EventuallyEq Vâ‚ V\nhxV : Eq (Vâ‚ x) (V x)\nhW : (nhdsWithin x s).EventuallyEq Wâ‚ W\nhxW : Eq (Wâ‚ x) (W x)\nâŠ¢ Eq (VectorField.lieBracketWithin ğ•œ Vâ‚ Wâ‚ s x) (VectorField.lieBracketWithin ğ•œ V W s x)","decl":"theorem _root_.Filter.EventuallyEq.lieBracketWithin_vectorField_eq\n    (hV : Vâ‚ =á¶ [ğ“[s] x] V) (hxV : Vâ‚ x = V x) (hW : Wâ‚ =á¶ [ğ“[s] x] W) (hxW : Wâ‚ x = W x) :\n    lieBracketWithin ğ•œ Vâ‚ Wâ‚ s x = lieBracketWithin ğ•œ V W s x := by\n  simp only [lieBracketWithin, hV.fderivWithin_eq hxV, hW.fderivWithin_eq hxW, hxV, hxW]\n\n"}
{"name":"Filter.EventuallyEq.lieBracketWithin_vectorField_eq_of_mem","module":"Mathlib.Analysis.Calculus.VectorField","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nV W Vâ‚ Wâ‚ : E â†’ E\ns : Set E\nx : E\nhV : (nhdsWithin x s).EventuallyEq Vâ‚ V\nhW : (nhdsWithin x s).EventuallyEq Wâ‚ W\nhx : Membership.mem s x\nâŠ¢ Eq (VectorField.lieBracketWithin ğ•œ Vâ‚ Wâ‚ s x) (VectorField.lieBracketWithin ğ•œ V W s x)","decl":"theorem _root_.Filter.EventuallyEq.lieBracketWithin_vectorField_eq_of_mem\n    (hV : Vâ‚ =á¶ [ğ“[s] x] V) (hW : Wâ‚ =á¶ [ğ“[s] x] W) (hx : x âˆˆ s) :\n    lieBracketWithin ğ•œ Vâ‚ Wâ‚ s x = lieBracketWithin ğ•œ V W s x :=\n  hV.lieBracketWithin_vectorField_eq (mem_of_mem_nhdsWithin hx hV :)\n    hW (mem_of_mem_nhdsWithin hx hW :)\n\n"}
{"name":"Filter.EventuallyEq.lieBracketWithin_vectorField'","module":"Mathlib.Analysis.Calculus.VectorField","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nV W Vâ‚ Wâ‚ : E â†’ E\ns t : Set E\nx : E\nhV : (nhdsWithin x s).EventuallyEq Vâ‚ V\nhW : (nhdsWithin x s).EventuallyEq Wâ‚ W\nht : HasSubset.Subset t s\nâŠ¢ (nhdsWithin x s).EventuallyEq (VectorField.lieBracketWithin ğ•œ Vâ‚ Wâ‚ t) (VectorField.lieBracketWithin ğ•œ V W t)","decl":"/-- If vector fields coincide on a neighborhood of a point within a set, then the Lie brackets\nalso coincide on a neighborhood of this point within this set. Version where one considers the Lie\nbracket within a subset. -/\ntheorem _root_.Filter.EventuallyEq.lieBracketWithin_vectorField'\n    (hV : Vâ‚ =á¶ [ğ“[s] x] V) (hW : Wâ‚ =á¶ [ğ“[s] x] W) (ht : t âŠ† s) :\n    lieBracketWithin ğ•œ Vâ‚ Wâ‚ t =á¶ [ğ“[s] x] lieBracketWithin ğ•œ V W t := by\n  filter_upwards [hV.fderivWithin' ht (ğ•œ := ğ•œ), hW.fderivWithin' ht (ğ•œ := ğ•œ), hV, hW]\n    with x hV' hW' hV hW\n  simp [lieBracketWithin, hV', hW', hV, hW]\n\n"}
{"name":"Filter.EventuallyEq.lieBracketWithin_vectorField","module":"Mathlib.Analysis.Calculus.VectorField","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nV W Vâ‚ Wâ‚ : E â†’ E\ns : Set E\nx : E\nhV : (nhdsWithin x s).EventuallyEq Vâ‚ V\nhW : (nhdsWithin x s).EventuallyEq Wâ‚ W\nâŠ¢ (nhdsWithin x s).EventuallyEq (VectorField.lieBracketWithin ğ•œ Vâ‚ Wâ‚ s) (VectorField.lieBracketWithin ğ•œ V W s)","decl":"protected theorem _root_.Filter.EventuallyEq.lieBracketWithin_vectorField\n    (hV : Vâ‚ =á¶ [ğ“[s] x] V) (hW : Wâ‚ =á¶ [ğ“[s] x] W) :\n    lieBracketWithin ğ•œ Vâ‚ Wâ‚ s =á¶ [ğ“[s] x] lieBracketWithin ğ•œ V W s :=\n  hV.lieBracketWithin_vectorField' hW Subset.rfl\n\n"}
{"name":"Filter.EventuallyEq.lieBracketWithin_vectorField_eq_of_insert","module":"Mathlib.Analysis.Calculus.VectorField","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nV W Vâ‚ Wâ‚ : E â†’ E\ns : Set E\nx : E\nhV : (nhdsWithin x (Insert.insert x s)).EventuallyEq Vâ‚ V\nhW : (nhdsWithin x (Insert.insert x s)).EventuallyEq Wâ‚ W\nâŠ¢ Eq (VectorField.lieBracketWithin ğ•œ Vâ‚ Wâ‚ s x) (VectorField.lieBracketWithin ğ•œ V W s x)","decl":"protected theorem _root_.Filter.EventuallyEq.lieBracketWithin_vectorField_eq_of_insert\n    (hV : Vâ‚ =á¶ [ğ“[insert x s] x] V) (hW : Wâ‚ =á¶ [ğ“[insert x s] x] W) :\n    lieBracketWithin ğ•œ Vâ‚ Wâ‚ s x = lieBracketWithin ğ•œ V W s x := by\n  apply mem_of_mem_nhdsWithin (mem_insert x s) (hV.lieBracketWithin_vectorField' hW\n    (subset_insert x s))\n\n"}
{"name":"Filter.EventuallyEq.lieBracketWithin_vectorField_eq_nhds","module":"Mathlib.Analysis.Calculus.VectorField","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nV W Vâ‚ Wâ‚ : E â†’ E\ns : Set E\nx : E\nhV : (nhds x).EventuallyEq Vâ‚ V\nhW : (nhds x).EventuallyEq Wâ‚ W\nâŠ¢ Eq (VectorField.lieBracketWithin ğ•œ Vâ‚ Wâ‚ s x) (VectorField.lieBracketWithin ğ•œ V W s x)","decl":"theorem _root_.Filter.EventuallyEq.lieBracketWithin_vectorField_eq_nhds\n    (hV : Vâ‚ =á¶ [ğ“ x] V) (hW : Wâ‚ =á¶ [ğ“ x] W) :\n    lieBracketWithin ğ•œ Vâ‚ Wâ‚ s x = lieBracketWithin ğ•œ V W s x :=\n  (hV.filter_mono nhdsWithin_le_nhds).lieBracketWithin_vectorField_eq hV.self_of_nhds\n    (hW.filter_mono nhdsWithin_le_nhds) hW.self_of_nhds\n\n"}
{"name":"VectorField.lieBracketWithin_congr","module":"Mathlib.Analysis.Calculus.VectorField","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nV W Vâ‚ Wâ‚ : E â†’ E\ns : Set E\nx : E\nhV : Set.EqOn Vâ‚ V s\nhVx : Eq (Vâ‚ x) (V x)\nhW : Set.EqOn Wâ‚ W s\nhWx : Eq (Wâ‚ x) (W x)\nâŠ¢ Eq (VectorField.lieBracketWithin ğ•œ Vâ‚ Wâ‚ s x) (VectorField.lieBracketWithin ğ•œ V W s x)","decl":"theorem lieBracketWithin_congr\n    (hV : EqOn Vâ‚ V s) (hVx : Vâ‚ x = V x) (hW : EqOn Wâ‚ W s) (hWx : Wâ‚ x = W x) :\n    lieBracketWithin ğ•œ Vâ‚ Wâ‚ s x = lieBracketWithin ğ•œ V W s x :=\n  (hV.eventuallyEq.filter_mono inf_le_right).lieBracketWithin_vectorField_eq hVx\n    (hW.eventuallyEq.filter_mono inf_le_right) hWx\n\n"}
{"name":"VectorField.lieBracketWithin_congr'","module":"Mathlib.Analysis.Calculus.VectorField","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nV W Vâ‚ Wâ‚ : E â†’ E\ns : Set E\nx : E\nhV : Set.EqOn Vâ‚ V s\nhW : Set.EqOn Wâ‚ W s\nhx : Membership.mem s x\nâŠ¢ Eq (VectorField.lieBracketWithin ğ•œ Vâ‚ Wâ‚ s x) (VectorField.lieBracketWithin ğ•œ V W s x)","decl":"/-- Version of `lieBracketWithin_congr` in which one assumes that the point belongs to the\ngiven set. -/\ntheorem lieBracketWithin_congr' (hV : EqOn Vâ‚ V s) (hW : EqOn Wâ‚ W s) (hx : x âˆˆ s) :\n    lieBracketWithin ğ•œ Vâ‚ Wâ‚ s x = lieBracketWithin ğ•œ V W s x :=\n  lieBracketWithin_congr hV (hV hx) hW (hW hx)\n\n"}
{"name":"Filter.EventuallyEq.lieBracket_vectorField_eq","module":"Mathlib.Analysis.Calculus.VectorField","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nV W Vâ‚ Wâ‚ : E â†’ E\nx : E\nhV : (nhds x).EventuallyEq Vâ‚ V\nhW : (nhds x).EventuallyEq Wâ‚ W\nâŠ¢ Eq (VectorField.lieBracket ğ•œ Vâ‚ Wâ‚ x) (VectorField.lieBracket ğ•œ V W x)","decl":"theorem _root_.Filter.EventuallyEq.lieBracket_vectorField_eq\n    (hV : Vâ‚ =á¶ [ğ“ x] V) (hW : Wâ‚ =á¶ [ğ“ x] W) :\n    lieBracket ğ•œ Vâ‚ Wâ‚ x = lieBracket ğ•œ V W x := by\n  rw [â† lieBracketWithin_univ, â† lieBracketWithin_univ, hV.lieBracketWithin_vectorField_eq_nhds hW]\n\n"}
{"name":"Filter.EventuallyEq.lieBracket_vectorField","module":"Mathlib.Analysis.Calculus.VectorField","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nV W Vâ‚ Wâ‚ : E â†’ E\nx : E\nhV : (nhds x).EventuallyEq Vâ‚ V\nhW : (nhds x).EventuallyEq Wâ‚ W\nâŠ¢ (nhds x).EventuallyEq (VectorField.lieBracket ğ•œ Vâ‚ Wâ‚) (VectorField.lieBracket ğ•œ V W)","decl":"protected theorem _root_.Filter.EventuallyEq.lieBracket_vectorField\n    (hV : Vâ‚ =á¶ [ğ“ x] V) (hW : Wâ‚ =á¶ [ğ“ x] W) : lieBracket ğ•œ Vâ‚ Wâ‚ =á¶ [ğ“ x] lieBracket ğ•œ V W := by\n  filter_upwards [hV.eventuallyEq_nhds, hW.eventuallyEq_nhds] with y hVy hWy\n  exact hVy.lieBracket_vectorField_eq hWy\n\n"}
{"name":"VectorField.leibniz_identity_lieBracketWithin_of_isSymmSndFDerivWithinAt","module":"Mathlib.Analysis.Calculus.VectorField","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nU V W : E â†’ E\ns : Set E\nx : E\nhs : UniqueDiffOn ğ•œ s\nhx : Membership.mem s x\nhU : ContDiffWithinAt ğ•œ 2 U s x\nhV : ContDiffWithinAt ğ•œ 2 V s x\nhW : ContDiffWithinAt ğ•œ 2 W s x\nh'U : IsSymmSndFDerivWithinAt ğ•œ U s x\nh'V : IsSymmSndFDerivWithinAt ğ•œ V s x\nh'W : IsSymmSndFDerivWithinAt ğ•œ W s x\nâŠ¢ Eq (VectorField.lieBracketWithin ğ•œ U (VectorField.lieBracketWithin ğ•œ V W s) s x) (HAdd.hAdd (VectorField.lieBracketWithin ğ•œ (VectorField.lieBracketWithin ğ•œ U V s) W s x) (VectorField.lieBracketWithin ğ•œ V (VectorField.lieBracketWithin ğ•œ U W s) s x))","decl":"/-- The Lie bracket of vector fields in vector spaces satisfies the Leibniz identity\n`[U, [V, W]] = [[U, V], W] + [V, [U, W]]`. -/\nlemma leibniz_identity_lieBracketWithin_of_isSymmSndFDerivWithinAt\n    {U V W : E â†’ E} {s : Set E} {x : E} (hs : UniqueDiffOn ğ•œ s) (hx : x âˆˆ s)\n    (hU : ContDiffWithinAt ğ•œ 2 U s x) (hV : ContDiffWithinAt ğ•œ 2 V s x)\n    (hW : ContDiffWithinAt ğ•œ 2 W s x)\n    (h'U : IsSymmSndFDerivWithinAt ğ•œ U s x) (h'V : IsSymmSndFDerivWithinAt ğ•œ V s x)\n    (h'W : IsSymmSndFDerivWithinAt ğ•œ W s x) :\n    lieBracketWithin ğ•œ U (lieBracketWithin ğ•œ V W s) s x =\n      lieBracketWithin ğ•œ (lieBracketWithin ğ•œ U V s) W s x\n      + lieBracketWithin ğ•œ V (lieBracketWithin ğ•œ U W s) s x := by\n  simp only [lieBracketWithin_eq, map_sub]\n  have auxâ‚ {U V : E â†’ E} (hU : ContDiffWithinAt ğ•œ 2 U s x) (hV : ContDiffWithinAt ğ•œ 2 V s x) :\n      DifferentiableWithinAt ğ•œ (fun x â†¦ (fderivWithin ğ•œ V s x) (U x)) s x :=\n    have := hV.fderivWithin_right_apply (hU.of_le one_le_two) hs le_rfl hx\n    this.differentiableWithinAt le_rfl\n  have auxâ‚‚ {U V : E â†’ E} (hU : ContDiffWithinAt ğ•œ 2 U s x) (hV : ContDiffWithinAt ğ•œ 2 V s x) :\n      fderivWithin ğ•œ (fun y â†¦ (fderivWithin ğ•œ U s y) (V y)) s x =\n        (fderivWithin ğ•œ U s x).comp (fderivWithin ğ•œ V s x) +\n        (fderivWithin ğ•œ (fderivWithin ğ•œ U s) s x).flip (V x) := by\n    refine fderivWithin_clm_apply (hs x hx) ?_ (hV.differentiableWithinAt one_le_two)\n    exact (hU.fderivWithin_right hs le_rfl hx).differentiableWithinAt le_rfl\n  rw [fderivWithin_sub (hs x hx) (auxâ‚ hV hW) (auxâ‚ hW hV)]\n  rw [fderivWithin_sub (hs x hx) (auxâ‚ hU hV) (auxâ‚ hV hU)]\n  rw [fderivWithin_sub (hs x hx) (auxâ‚ hU hW) (auxâ‚ hW hU)]\n  rw [auxâ‚‚ hW hV, auxâ‚‚ hV hW, auxâ‚‚ hV hU, auxâ‚‚ hU hV, auxâ‚‚ hW hU, auxâ‚‚ hU hW]\n  simp only [ContinuousLinearMap.coe_sub', Pi.sub_apply, ContinuousLinearMap.add_apply,\n    ContinuousLinearMap.coe_comp', Function.comp_apply, ContinuousLinearMap.flip_apply, h'V.eq,\n    h'U.eq, h'W.eq]\n  abel\n\n"}
{"name":"VectorField.leibniz_identity_lieBracketWithin","module":"Mathlib.Analysis.Calculus.VectorField","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nn : WithTop ENat\nE : Type u_2\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nhn : LE.le (minSmoothness ğ•œ 2) n\nU V W : E â†’ E\ns : Set E\nx : E\nhs : UniqueDiffOn ğ•œ s\nh'x : Membership.mem (closure (interior s)) x\nhx : Membership.mem s x\nhU : ContDiffWithinAt ğ•œ n U s x\nhV : ContDiffWithinAt ğ•œ n V s x\nhW : ContDiffWithinAt ğ•œ n W s x\nâŠ¢ Eq (VectorField.lieBracketWithin ğ•œ U (VectorField.lieBracketWithin ğ•œ V W s) s x) (HAdd.hAdd (VectorField.lieBracketWithin ğ•œ (VectorField.lieBracketWithin ğ•œ U V s) W s x) (VectorField.lieBracketWithin ğ•œ V (VectorField.lieBracketWithin ğ•œ U W s) s x))","decl":"/-- The Lie bracket of vector fields in vector spaces satisfies the Leibniz identity\n`[U, [V, W]] = [[U, V], W] + [V, [U, W]]`. -/\nlemma leibniz_identity_lieBracketWithin (hn : minSmoothness ğ•œ 2 â‰¤ n)\n    {U V W : E â†’ E} {s : Set E} {x : E}\n    (hs : UniqueDiffOn ğ•œ s) (h'x : x âˆˆ closure (interior s)) (hx : x âˆˆ s)\n    (hU : ContDiffWithinAt ğ•œ n U s x) (hV : ContDiffWithinAt ğ•œ n V s x)\n    (hW : ContDiffWithinAt ğ•œ n W s x) :\n    lieBracketWithin ğ•œ U (lieBracketWithin ğ•œ V W s) s x =\n      lieBracketWithin ğ•œ (lieBracketWithin ğ•œ U V s) W s x\n      + lieBracketWithin ğ•œ V (lieBracketWithin ğ•œ U W s) s x := by\n  apply leibniz_identity_lieBracketWithin_of_isSymmSndFDerivWithinAt hs hx\n    (hU.of_le (le_minSmoothness.trans hn)) (hV.of_le (le_minSmoothness.trans hn))\n    (hW.of_le (le_minSmoothness.trans hn))\n  Â· exact hU.isSymmSndFDerivWithinAt hn hs h'x hx\n  Â· exact hV.isSymmSndFDerivWithinAt hn hs h'x hx\n  Â· exact hW.isSymmSndFDerivWithinAt hn hs h'x hx\n\n"}
{"name":"VectorField.leibniz_identity_lieBracket","module":"Mathlib.Analysis.Calculus.VectorField","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nn : WithTop ENat\nE : Type u_2\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nhn : LE.le (minSmoothness ğ•œ 2) n\nU V W : E â†’ E\nx : E\nhU : ContDiffAt ğ•œ n U x\nhV : ContDiffAt ğ•œ n V x\nhW : ContDiffAt ğ•œ n W x\nâŠ¢ Eq (VectorField.lieBracket ğ•œ U (VectorField.lieBracket ğ•œ V W) x) (HAdd.hAdd (VectorField.lieBracket ğ•œ (VectorField.lieBracket ğ•œ U V) W x) (VectorField.lieBracket ğ•œ V (VectorField.lieBracket ğ•œ U W) x))","decl":"/-- The Lie bracket of vector fields in vector spaces satisfies the Leibniz identity\n`[U, [V, W]] = [[U, V], W] + [V, [U, W]]`. -/\nlemma leibniz_identity_lieBracket (hn : minSmoothness ğ•œ 2 â‰¤ n) {U V W : E â†’ E} {x : E}\n    (hU : ContDiffAt ğ•œ n U x) (hV : ContDiffAt ğ•œ n V x) (hW : ContDiffAt ğ•œ n W x) :\n    lieBracket ğ•œ U (lieBracket ğ•œ V W) x =\n      lieBracket ğ•œ (lieBracket ğ•œ U V) W x + lieBracket ğ•œ V (lieBracket ğ•œ U W) x := by\n  simp only [â† lieBracketWithin_univ, â† contDiffWithinAt_univ] at hU hV hW âŠ¢\n  exact leibniz_identity_lieBracketWithin hn uniqueDiffOn_univ (by simp) (mem_univ _) hU hV hW\n\n\n"}
{"name":"VectorField.pullbackWithin_eq","module":"Mathlib.Analysis.Calculus.VectorField","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nV : F â†’ F\ns : Set E\nâŠ¢ Eq (VectorField.pullbackWithin ğ•œ f V s) fun x => (fderivWithin ğ•œ f s x).inverse (V (f x))","decl":"lemma pullbackWithin_eq {f : E â†’ F} {V : F â†’ F} {s : Set E} :\n    pullbackWithin ğ•œ f V s = fun x â†¦ (fderivWithin ğ•œ f s x).inverse (V (f x)) := rfl\n\n"}
{"name":"VectorField.pullback_eq_of_fderiv_eq","module":"Mathlib.Analysis.Calculus.VectorField","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nM : ContinuousLinearEquiv (RingHom.id ğ•œ) E F\nx : E\nhf : Eq (â†‘M) (fderiv ğ•œ f x)\nV : F â†’ F\nâŠ¢ Eq (VectorField.pullback ğ•œ f V x) (M.symm (V (f x)))","decl":"lemma pullback_eq_of_fderiv_eq\n    {f : E â†’ F} {M : E â‰ƒL[ğ•œ] F} {x : E} (hf : M = fderiv ğ•œ f x) (V : F â†’ F) :\n    pullback ğ•œ f V x = M.symm (V (f x)) := by\n  simp [pullback, â† hf]\n\n"}
{"name":"VectorField.pullback_eq_of_not_isInvertible","module":"Mathlib.Analysis.Calculus.VectorField","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nx : E\nh : Not (fderiv ğ•œ f x).IsInvertible\nV : F â†’ F\nâŠ¢ Eq (VectorField.pullback ğ•œ f V x) 0","decl":"lemma pullback_eq_of_not_isInvertible {f : E â†’ F} {x : E}\n    (h : Â¬(fderiv ğ•œ f x).IsInvertible) (V : F â†’ F) :\n    pullback ğ•œ f V x = 0 := by\n  simp [pullback, h]\n\n"}
{"name":"VectorField.pullbackWithin_eq_of_not_isInvertible","module":"Mathlib.Analysis.Calculus.VectorField","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nf : E â†’ F\nx : E\nh : Not (fderivWithin ğ•œ f s x).IsInvertible\nV : F â†’ F\nâŠ¢ Eq (VectorField.pullbackWithin ğ•œ f V s x) 0","decl":"lemma pullbackWithin_eq_of_not_isInvertible {f : E â†’ F} {x : E}\n    (h : Â¬(fderivWithin ğ•œ f s x).IsInvertible) (V : F â†’ F) :\n    pullbackWithin ğ•œ f V s x = 0 := by\n  simp [pullbackWithin, h]\n\n"}
{"name":"VectorField.pullbackWithin_eq_of_fderivWithin_eq","module":"Mathlib.Analysis.Calculus.VectorField","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nf : E â†’ F\nM : ContinuousLinearEquiv (RingHom.id ğ•œ) E F\nx : E\nhf : Eq (â†‘M) (fderivWithin ğ•œ f s x)\nV : F â†’ F\nâŠ¢ Eq (VectorField.pullbackWithin ğ•œ f V s x) (M.symm (V (f x)))","decl":"lemma pullbackWithin_eq_of_fderivWithin_eq\n    {f : E â†’ F} {M : E â‰ƒL[ğ•œ] F} {x : E} (hf : M = fderivWithin ğ•œ f s x) (V : F â†’ F) :\n    pullbackWithin ğ•œ f V s x = M.symm (V (f x)) := by\n  simp [pullbackWithin, â† hf]\n\n"}
{"name":"VectorField.pullbackWithin_univ","module":"Mathlib.Analysis.Calculus.VectorField","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nV : F â†’ F\nâŠ¢ Eq (VectorField.pullbackWithin ğ•œ f V Set.univ) (VectorField.pullback ğ•œ f V)","decl":"@[simp] lemma pullbackWithin_univ {f : E â†’ F} {V : F â†’ F} :\n    pullbackWithin ğ•œ f V univ = pullback ğ•œ f V := by\n  ext x\n  simp [pullbackWithin, pullback]\n\n"}
{"name":"VectorField.fderiv_pullback","module":"Mathlib.Analysis.Calculus.VectorField","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nV : F â†’ F\nx : E\nh'f : (fderiv ğ•œ f x).IsInvertible\nâŠ¢ Eq ((fderiv ğ•œ f x) (VectorField.pullback ğ•œ f V x)) (V (f x))","decl":"lemma fderiv_pullback (f : E â†’ F) (V : F â†’ F) (x : E) (h'f : (fderiv ğ•œ f x).IsInvertible) :\n    fderiv ğ•œ f x (pullback ğ•œ f V x) = V (f x) := by\n  rcases h'f with âŸ¨M, hMâŸ©\n  simp [pullback_eq_of_fderiv_eq hM, â† hM]\n\n"}
{"name":"VectorField.fderivWithin_pullbackWithin","module":"Mathlib.Analysis.Calculus.VectorField","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nf : E â†’ F\nV : F â†’ F\nx : E\nh'f : (fderivWithin ğ•œ f s x).IsInvertible\nâŠ¢ Eq ((fderivWithin ğ•œ f s x) (VectorField.pullbackWithin ğ•œ f V s x)) (V (f x))","decl":"lemma fderivWithin_pullbackWithin {f : E â†’ F} {V : F â†’ F} {x : E}\n    (h'f : (fderivWithin ğ•œ f s x).IsInvertible) :\n    fderivWithin ğ•œ f s x (pullbackWithin ğ•œ f V s x) = V (f x) := by\n  rcases h'f with âŸ¨M, hMâŸ©\n  simp [pullbackWithin_eq_of_fderivWithin_eq hM, â† hM]\n\n"}
{"name":"exists_continuousLinearEquiv_fderivWithin_symm_eq","module":"Mathlib.Analysis.Calculus.VectorField","initialProofState":"ğ•œ : Type u_1\ninstâœâµ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace ğ•œ F\ninstâœ : CompleteSpace E\nf : E â†’ F\ns : Set E\nx : E\nh'f : ContDiffWithinAt ğ•œ 2 f s x\nhf : (fderivWithin ğ•œ f s x).IsInvertible\nhs : UniqueDiffOn ğ•œ s\nhx : Membership.mem s x\nâŠ¢ Exists fun N => And (ContDiffWithinAt ğ•œ 1 (fun y => â†‘(N y)) s x) (And (ContDiffWithinAt ğ•œ 1 (fun y => â†‘(N y).symm) s x) (And (Filter.Eventually (fun y => Eq (â†‘(N y)) (fderivWithin ğ•œ f s y)) (nhdsWithin x s)) (âˆ€ (v : E), Eq ((fderivWithin ğ•œ (fun y => â†‘(N y).symm) s x) v) (Neg.neg ((â†‘(N x).symm).comp (((fderivWithin ğ•œ (fderivWithin ğ•œ f s) s x) v).comp â†‘(N x).symm))))))","decl":"/-- If a `C^2` map has an invertible derivative within a set at a point, then nearby derivatives\ncan be written as continuous linear equivs, which depend in a `C^1` way on the point, as well as\ntheir inverse, and moreover one can compute the derivative of the inverse. -/\nlemma _root_.exists_continuousLinearEquiv_fderivWithin_symm_eq\n    {f : E â†’ F} {s : Set E} {x : E} (h'f : ContDiffWithinAt ğ•œ 2 f s x)\n    (hf : (fderivWithin ğ•œ f s x).IsInvertible) (hs : UniqueDiffOn ğ•œ s) (hx : x âˆˆ s) :\n    âˆƒ N : E â†’ (E â‰ƒL[ğ•œ] F), ContDiffWithinAt ğ•œ 1 (fun y â†¦ (N y : E â†’L[ğ•œ] F)) s x\n    âˆ§ ContDiffWithinAt ğ•œ 1 (fun y â†¦ ((N y).symm : F â†’L[ğ•œ] E)) s x\n    âˆ§ (âˆ€á¶  y in ğ“[s] x, N y = fderivWithin ğ•œ f s y)\n    âˆ§ âˆ€ v, fderivWithin ğ•œ (fun y â†¦ ((N y).symm : F â†’L[ğ•œ] E)) s x v\n      = - (N x).symm  âˆ˜L ((fderivWithin ğ•œ (fderivWithin ğ•œ f s) s x v)) âˆ˜L (N x).symm := by\n  classical\n  rcases hf with âŸ¨M, hMâŸ©\n  let U := {y | âˆƒ (N : E â‰ƒL[ğ•œ] F), N = fderivWithin ğ•œ f s y}\n  have hU : U âˆˆ ğ“[s] x := by\n    have I : range ((â†‘) : (E â‰ƒL[ğ•œ] F) â†’ E â†’L[ğ•œ] F) âˆˆ ğ“ (fderivWithin ğ•œ f s x) := by\n      rw [â† hM]\n      exact M.nhds\n    have : ContinuousWithinAt (fderivWithin ğ•œ f s) s x :=\n      (h'f.fderivWithin_right (m := 1) hs le_rfl hx).continuousWithinAt\n    exact this I\n  let N : E â†’ (E â‰ƒL[ğ•œ] F) := fun x â†¦ if h : x âˆˆ U then h.choose else M\n  have eN : (fun y â†¦ (N y : E â†’L[ğ•œ] F)) =á¶ [ğ“[s] x] fun y â†¦ fderivWithin ğ•œ f s y := by\n    filter_upwards [hU] with y hy\n    simpa only [hy, â†“reduceDIte, N] using Exists.choose_spec hy\n  have e'N : N x = fderivWithin ğ•œ f s x := by apply mem_of_mem_nhdsWithin hx eN\n  have hN : ContDiffWithinAt ğ•œ 1 (fun y â†¦ (N y : E â†’L[ğ•œ] F)) s x := by\n    have : ContDiffWithinAt ğ•œ 1 (fun y â†¦ fderivWithin ğ•œ f s y) s x :=\n      h'f.fderivWithin_right (m := 1) hs le_rfl hx\n    apply this.congr_of_eventuallyEq eN e'N\n  have hN' : ContDiffWithinAt ğ•œ 1 (fun y â†¦ ((N y).symm : F â†’L[ğ•œ] E)) s x := by\n    have : ContDiffWithinAt ğ•œ 1 (ContinuousLinearMap.inverse âˆ˜ (fun y â†¦ (N y : E â†’L[ğ•œ] F))) s x :=\n      (contDiffAt_map_inverse (N x)).comp_contDiffWithinAt x hN\n    convert this with y\n    simp only [Function.comp_apply, ContinuousLinearMap.inverse_equiv]\n  refine âŸ¨N, hN, hN', eN, fun v â†¦ ?_âŸ©\n  have A' y : ContinuousLinearMap.compL ğ•œ F E F (N y : E â†’L[ğ•œ] F) ((N y).symm : F â†’L[ğ•œ] E)\n      = ContinuousLinearMap.id ğ•œ F := by ext; simp\n  have : fderivWithin ğ•œ (fun y â†¦ ContinuousLinearMap.compL ğ•œ F E F (N y : E â†’L[ğ•œ] F)\n      ((N y).symm : F â†’L[ğ•œ] E)) s x v = 0 := by\n    simp [A', fderivWithin_const_apply, hs x hx]\n  have I : (N x : E â†’L[ğ•œ] F) âˆ˜L (fderivWithin ğ•œ (fun y â†¦ ((N y).symm : F â†’L[ğ•œ] E)) s x v) =\n      - (fderivWithin ğ•œ (fun y â†¦ (N y : E â†’L[ğ•œ] F)) s x v) âˆ˜L ((N x).symm : F â†’L[ğ•œ] E) := by\n    rw [ContinuousLinearMap.fderivWithin_of_bilinear _ (hN.differentiableWithinAt le_rfl)\n      (hN'.differentiableWithinAt le_rfl) (hs x hx)] at this\n    simpa [eq_neg_iff_add_eq_zero] using this\n  have B (M : F â†’L[ğ•œ] E) : M = ((N x).symm : F â†’L[ğ•œ] E) âˆ˜L ((N x) âˆ˜L M) := by\n    ext; simp\n  rw [B (fderivWithin ğ•œ (fun y â†¦ ((N y).symm : F â†’L[ğ•œ] E)) s x v), I]\n  simp only [ContinuousLinearMap.comp_neg, neg_inj, eN.fderivWithin_eq e'N]\n\n"}
{"name":"VectorField.DifferentiableWithinAt.pullbackWithin","module":"Mathlib.Analysis.Calculus.VectorField","initialProofState":"ğ•œ : Type u_1\ninstâœâµ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace ğ•œ F\ninstâœ : CompleteSpace E\nf : E â†’ F\nV : F â†’ F\ns : Set E\nt : Set F\nx : E\nhV : DifferentiableWithinAt ğ•œ V t (f x)\nhf : ContDiffWithinAt ğ•œ 2 f s x\nhf' : (fderivWithin ğ•œ f s x).IsInvertible\nhs : UniqueDiffOn ğ•œ s\nhx : Membership.mem s x\nhst : Set.MapsTo f s t\nâŠ¢ DifferentiableWithinAt ğ•œ (VectorField.pullbackWithin ğ•œ f V s) s x","decl":"lemma DifferentiableWithinAt.pullbackWithin {f : E â†’ F} {V : F â†’ F} {s : Set E} {t : Set F} {x : E}\n    (hV : DifferentiableWithinAt ğ•œ V t (f x))\n    (hf : ContDiffWithinAt ğ•œ 2 f s x) (hf' : (fderivWithin ğ•œ f s x).IsInvertible)\n    (hs : UniqueDiffOn ğ•œ s) (hx : x âˆˆ s) (hst : MapsTo f s t) :\n    DifferentiableWithinAt ğ•œ (pullbackWithin ğ•œ f V s) s x := by\n  rcases exists_continuousLinearEquiv_fderivWithin_symm_eq hf hf' hs hx\n    with âŸ¨M, -, M_symm_smooth, hM, -âŸ©\n  simp only [pullbackWithin_eq]\n  have : DifferentiableWithinAt ğ•œ (fun y â†¦ ((M y).symm : F â†’L[ğ•œ] E) (V (f y))) s x := by\n    apply DifferentiableWithinAt.clm_apply\n    Â· exact M_symm_smooth.differentiableWithinAt le_rfl\n    Â· exact hV.comp _ (hf.differentiableWithinAt one_le_two) hst\n  apply this.congr_of_eventuallyEq\n  Â· filter_upwards [hM] with y hy using by simp [â† hy]\n  Â· have hMx : M x = fderivWithin ğ•œ f s x := by apply mem_of_mem_nhdsWithin hx hM\n    simp [â† hMx]\n\n"}
{"name":"exists_continuousLinearEquiv_fderiv_symm_eq","module":"Mathlib.Analysis.Calculus.VectorField","initialProofState":"ğ•œ : Type u_1\ninstâœâµ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace ğ•œ F\ninstâœ : CompleteSpace E\nf : E â†’ F\nx : E\nh'f : ContDiffAt ğ•œ 2 f x\nhf : (fderiv ğ•œ f x).IsInvertible\nâŠ¢ Exists fun N => And (ContDiffAt ğ•œ 1 (fun y => â†‘(N y)) x) (And (ContDiffAt ğ•œ 1 (fun y => â†‘(N y).symm) x) (And (Filter.Eventually (fun y => Eq (â†‘(N y)) (fderiv ğ•œ f y)) (nhds x)) (âˆ€ (v : E), Eq ((fderiv ğ•œ (fun y => â†‘(N y).symm) x) v) (Neg.neg ((â†‘(N x).symm).comp (((fderiv ğ•œ (fderiv ğ•œ f) x) v).comp â†‘(N x).symm))))))","decl":"/-- If a `C^2` map has an invertible derivative at a point, then nearby derivatives can be written\nas continuous linear equivs, which depend in a `C^1` way on the point, as well as their inverse, and\nmoreover one can compute the derivative of the inverse. -/\nlemma _root_.exists_continuousLinearEquiv_fderiv_symm_eq\n    {f : E â†’ F} {x : E} (h'f : ContDiffAt ğ•œ 2 f x) (hf : (fderiv ğ•œ f x).IsInvertible) :\n    âˆƒ N : E â†’ (E â‰ƒL[ğ•œ] F), ContDiffAt ğ•œ 1 (fun y â†¦ (N y : E â†’L[ğ•œ] F)) x\n    âˆ§ ContDiffAt ğ•œ 1 (fun y â†¦ ((N y).symm : F â†’L[ğ•œ] E)) x\n    âˆ§ (âˆ€á¶  y in ğ“ x, N y = fderiv ğ•œ f y)\n    âˆ§ âˆ€ v, fderiv ğ•œ (fun y â†¦ ((N y).symm : F â†’L[ğ•œ] E)) x v\n      = - (N x).symm  âˆ˜L ((fderiv ğ•œ (fderiv ğ•œ f) x v)) âˆ˜L (N x).symm := by\n  simp only [â† fderivWithin_univ, â† contDiffWithinAt_univ, â† nhdsWithin_univ] at hf h'f âŠ¢\n  exact exists_continuousLinearEquiv_fderivWithin_symm_eq h'f hf uniqueDiffOn_univ (mem_univ _)\n\n"}
{"name":"VectorField.pullbackWithin_lieBracketWithin_of_isSymmSndFDerivWithinAt","module":"Mathlib.Analysis.Calculus.VectorField","initialProofState":"ğ•œ : Type u_1\ninstâœâµ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace ğ•œ F\ns : Set E\ninstâœ : CompleteSpace E\nf : E â†’ F\nV W : F â†’ F\nx : E\nt : Set F\nhf : IsSymmSndFDerivWithinAt ğ•œ f s x\nh'f : ContDiffWithinAt ğ•œ 2 f s x\nhV : DifferentiableWithinAt ğ•œ V t (f x)\nhW : DifferentiableWithinAt ğ•œ W t (f x)\nhu : UniqueDiffOn ğ•œ s\nhx : Membership.mem s x\nhst : Set.MapsTo f s t\nâŠ¢ Eq (VectorField.pullbackWithin ğ•œ f (VectorField.lieBracketWithin ğ•œ V W t) s x) (VectorField.lieBracketWithin ğ•œ (VectorField.pullbackWithin ğ•œ f V s) (VectorField.pullbackWithin ğ•œ f W s) s x)","decl":"/-- The Lie bracket commutes with taking pullbacks. This requires the function to have symmetric\nsecond derivative. Version in a complete space. One could also give a version avoiding\ncompleteness but requiring that `f` is a local diffeo. -/\nlemma pullbackWithin_lieBracketWithin_of_isSymmSndFDerivWithinAt\n    {f : E â†’ F} {V W : F â†’ F} {x : E} {t : Set F}\n    (hf : IsSymmSndFDerivWithinAt ğ•œ f s x) (h'f : ContDiffWithinAt ğ•œ 2 f s x)\n    (hV : DifferentiableWithinAt ğ•œ V t (f x)) (hW : DifferentiableWithinAt ğ•œ W t (f x))\n    (hu : UniqueDiffOn ğ•œ s) (hx : x âˆˆ s) (hst : MapsTo f s t) :\n    pullbackWithin ğ•œ f (lieBracketWithin ğ•œ V W t) s x\n      = lieBracketWithin ğ•œ (pullbackWithin ğ•œ f V s) (pullbackWithin ğ•œ f W s) s x := by\n  by_cases h : (fderivWithin ğ•œ f s x).IsInvertible; swap\n  Â· simp [pullbackWithin_eq_of_not_isInvertible h, lieBracketWithin_eq]\n  rcases exists_continuousLinearEquiv_fderivWithin_symm_eq h'f h hu hx\n    with âŸ¨M, -, M_symm_smooth, hM, M_diffâŸ©\n  have hMx : M x = fderivWithin ğ•œ f s x := (mem_of_mem_nhdsWithin hx hM :)\n  have AV : fderivWithin ğ•œ (pullbackWithin ğ•œ f V s) s x =\n      fderivWithin ğ•œ (fun y â†¦ ((M y).symm : F â†’L[ğ•œ] E) (V (f y))) s x := by\n    apply Filter.EventuallyEq.fderivWithin_eq_of_mem _ hx\n    filter_upwards [hM] with y hy using pullbackWithin_eq_of_fderivWithin_eq hy _\n  have AW : fderivWithin ğ•œ (pullbackWithin ğ•œ f W s) s x =\n      fderivWithin ğ•œ (fun y â†¦ ((M y).symm : F â†’L[ğ•œ] E) (W (f y))) s x := by\n    apply Filter.EventuallyEq.fderivWithin_eq_of_mem _ hx\n    filter_upwards [hM] with y hy using pullbackWithin_eq_of_fderivWithin_eq hy _\n  have Af : DifferentiableWithinAt ğ•œ f s x := h'f.differentiableWithinAt one_le_two\n  simp only [lieBracketWithin_eq, pullbackWithin_eq_of_fderivWithin_eq hMx, map_sub, AV, AW]\n  rw [fderivWithin_clm_apply, fderivWithin_clm_apply]\n  Â· simp [fderivWithin_comp' x hW Af hst (hu x hx), â† hMx,\n      fderivWithin_comp' x hV Af hst (hu x hx), M_diff, hf.eq]\n  Â· exact hu x hx\n  Â· exact M_symm_smooth.differentiableWithinAt le_rfl\n  Â· exact hV.comp x Af hst\n  Â· exact hu x hx\n  Â· exact M_symm_smooth.differentiableWithinAt le_rfl\n  Â· exact hW.comp x Af hst\n\n"}
{"name":"VectorField.pullbackWithin_lieBracketWithin_of_isSymmSndFDerivWithinAt_of_eventuallyEq","module":"Mathlib.Analysis.Calculus.VectorField","initialProofState":"ğ•œ : Type u_1\ninstâœâµ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace ğ•œ F\ns : Set E\ninstâœ : CompleteSpace E\nf : E â†’ F\nV W : F â†’ F\nx : E\nt : Set F\nu : Set E\nhf : IsSymmSndFDerivWithinAt ğ•œ f s x\nh'f : ContDiffWithinAt ğ•œ 2 f s x\nhV : DifferentiableWithinAt ğ•œ V t (f x)\nhW : DifferentiableWithinAt ğ•œ W t (f x)\nhu : UniqueDiffOn ğ•œ u\nhx : Membership.mem u x\nhst : Set.MapsTo f u t\nhus : (nhds x).EventuallyEq u s\nâŠ¢ Eq (VectorField.pullbackWithin ğ•œ f (VectorField.lieBracketWithin ğ•œ V W t) s x) (VectorField.lieBracketWithin ğ•œ (VectorField.pullbackWithin ğ•œ f V s) (VectorField.pullbackWithin ğ•œ f W s) s x)","decl":"/-- The Lie bracket commutes with taking pullbacks. This requires the function to have symmetric\nsecond derivative. Version in a complete space. One could also give a version avoiding\ncompleteness but requiring that `f` is a local diffeo. Variant where unique differentiability and\nthe invariance property are only required in a smaller set `u`. -/\nlemma pullbackWithin_lieBracketWithin_of_isSymmSndFDerivWithinAt_of_eventuallyEq\n    {f : E â†’ F} {V W : F â†’ F} {x : E} {t : Set F} {u : Set E}\n    (hf : IsSymmSndFDerivWithinAt ğ•œ f s x) (h'f : ContDiffWithinAt ğ•œ 2 f s x)\n    (hV : DifferentiableWithinAt ğ•œ V t (f x)) (hW : DifferentiableWithinAt ğ•œ W t (f x))\n    (hu : UniqueDiffOn ğ•œ u) (hx : x âˆˆ u) (hst : MapsTo f u t) (hus : u =á¶ [ğ“ x] s) :\n    pullbackWithin ğ•œ f (lieBracketWithin ğ•œ V W t) s x\n      = lieBracketWithin ğ•œ (pullbackWithin ğ•œ f V s) (pullbackWithin ğ•œ f W s) s x := calc\n  pullbackWithin ğ•œ f (lieBracketWithin ğ•œ V W t) s x\n  _ = pullbackWithin ğ•œ f (lieBracketWithin ğ•œ V W t) u x := by\n    simp only [pullbackWithin]\n    congr 2\n    exact fderivWithin_congr_set hus.symm\n  _ = lieBracketWithin ğ•œ (pullbackWithin ğ•œ f V u) (pullbackWithin ğ•œ f W u) u x :=\n    pullbackWithin_lieBracketWithin_of_isSymmSndFDerivWithinAt\n      (hf.congr_set hus.symm) (h'f.congr_set hus.symm) hV hW hu hx hst\n  _ = lieBracketWithin ğ•œ (pullbackWithin ğ•œ f V s) (pullbackWithin ğ•œ f W s) u x := by\n    apply Filter.EventuallyEq.lieBracketWithin_vectorField_eq_of_mem _ _ hx\n    Â· apply nhdsWithin_le_nhds\n      filter_upwards [fderivWithin_eventually_congr_set (ğ•œ := ğ•œ) (f := f) hus] with y hy\n      simp [pullbackWithin, hy]\n    Â· apply nhdsWithin_le_nhds\n      filter_upwards [fderivWithin_eventually_congr_set (ğ•œ := ğ•œ) (f := f) hus] with y hy\n      simp [pullbackWithin, hy]\n  _ = lieBracketWithin ğ•œ (pullbackWithin ğ•œ f V s) (pullbackWithin ğ•œ f W s) s x :=\n    lieBracketWithin_congr_set hus\n\n"}
{"name":"VectorField.pullback_lieBracket_of_isSymmSndFDerivAt","module":"Mathlib.Analysis.Calculus.VectorField","initialProofState":"ğ•œ : Type u_1\ninstâœâµ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace ğ•œ F\ninstâœ : CompleteSpace E\nf : E â†’ F\nV W : F â†’ F\nx : E\nhf : IsSymmSndFDerivAt ğ•œ f x\nh'f : ContDiffAt ğ•œ 2 f x\nhV : DifferentiableAt ğ•œ V (f x)\nhW : DifferentiableAt ğ•œ W (f x)\nâŠ¢ Eq (VectorField.pullback ğ•œ f (VectorField.lieBracket ğ•œ V W) x) (VectorField.lieBracket ğ•œ (VectorField.pullback ğ•œ f V) (VectorField.pullback ğ•œ f W) x)","decl":"/-- The Lie bracket commutes with taking pullbacks. This requires the function to have symmetric\nsecond derivative. Version in a complete space. One could also give a version avoiding\ncompleteness but requiring that `f` is a local diffeo. -/\nlemma pullback_lieBracket_of_isSymmSndFDerivAt {f : E â†’ F} {V W : F â†’ F} {x : E}\n    (hf : IsSymmSndFDerivAt ğ•œ f x) (h'f : ContDiffAt ğ•œ 2 f x)\n    (hV : DifferentiableAt ğ•œ V (f x)) (hW : DifferentiableAt ğ•œ W (f x)) :\n    pullback ğ•œ f (lieBracket ğ•œ V W) x = lieBracket ğ•œ (pullback ğ•œ f V) (pullback ğ•œ f W) x := by\n  simp only [â† lieBracketWithin_univ, â† pullbackWithin_univ, â† isSymmSndFDerivWithinAt_univ,\n    â† differentiableWithinAt_univ] at hf h'f hV hW âŠ¢\n  exact pullbackWithin_lieBracketWithin_of_isSymmSndFDerivWithinAt hf h'f hV hW uniqueDiffOn_univ\n    (mem_univ _) (mapsTo_univ _ _)\n\n"}
{"name":"VectorField.pullbackWithin_lieBracketWithin","module":"Mathlib.Analysis.Calculus.VectorField","initialProofState":"ğ•œ : Type u_1\ninstâœâµ : NontriviallyNormedField ğ•œ\nn : WithTop ENat\nE : Type u_2\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace ğ•œ F\ns : Set E\ninstâœ : CompleteSpace E\nf : E â†’ F\nV W : F â†’ F\nx : E\nt : Set F\nhn : LE.le (minSmoothness ğ•œ 2) n\nh'f : ContDiffWithinAt ğ•œ n f s x\nhV : DifferentiableWithinAt ğ•œ V t (f x)\nhW : DifferentiableWithinAt ğ•œ W t (f x)\nhu : UniqueDiffOn ğ•œ s\nhx : Membership.mem s x\nh'x : Membership.mem (closure (interior s)) x\nhst : Set.MapsTo f s t\nâŠ¢ Eq (VectorField.pullbackWithin ğ•œ f (VectorField.lieBracketWithin ğ•œ V W t) s x) (VectorField.lieBracketWithin ğ•œ (VectorField.pullbackWithin ğ•œ f V s) (VectorField.pullbackWithin ğ•œ f W s) s x)","decl":"/-- The Lie bracket commutes with taking pullbacks. This requires the function to have symmetric\nsecond derivative. Version in a complete space. One could also give a version avoiding\ncompleteness but requiring that `f` is a local diffeo. -/\nlemma pullbackWithin_lieBracketWithin\n    {f : E â†’ F} {V W : F â†’ F} {x : E} {t : Set F} (hn : minSmoothness ğ•œ 2 â‰¤ n)\n    (h'f : ContDiffWithinAt ğ•œ n f s x)\n    (hV : DifferentiableWithinAt ğ•œ V t (f x)) (hW : DifferentiableWithinAt ğ•œ W t (f x))\n    (hu : UniqueDiffOn ğ•œ s) (hx : x âˆˆ s) (h'x : x âˆˆ closure (interior s)) (hst : MapsTo f s t) :\n    pullbackWithin ğ•œ f (lieBracketWithin ğ•œ V W t) s x\n      = lieBracketWithin ğ•œ (pullbackWithin ğ•œ f V s) (pullbackWithin ğ•œ f W s) s x :=\n  pullbackWithin_lieBracketWithin_of_isSymmSndFDerivWithinAt\n  (h'f.isSymmSndFDerivWithinAt hn hu h'x hx) (h'f.of_le (le_minSmoothness.trans hn)) hV hW hu hx hst\n\n"}
{"name":"VectorField.pullback_lieBracket","module":"Mathlib.Analysis.Calculus.VectorField","initialProofState":"ğ•œ : Type u_1\ninstâœâµ : NontriviallyNormedField ğ•œ\nn : WithTop ENat\nE : Type u_2\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace ğ•œ F\ninstâœ : CompleteSpace E\nhn : LE.le (minSmoothness ğ•œ 2) n\nf : E â†’ F\nV W : F â†’ F\nx : E\nh'f : ContDiffAt ğ•œ n f x\nhV : DifferentiableAt ğ•œ V (f x)\nhW : DifferentiableAt ğ•œ W (f x)\nâŠ¢ Eq (VectorField.pullback ğ•œ f (VectorField.lieBracket ğ•œ V W) x) (VectorField.lieBracket ğ•œ (VectorField.pullback ğ•œ f V) (VectorField.pullback ğ•œ f W) x)","decl":"/-- The Lie bracket commutes with taking pullbacks. One could also give a version avoiding\ncompleteness but requiring that `f` is a local diffeo. -/\nlemma pullback_lieBracket (hn : minSmoothness ğ•œ 2 â‰¤ n)\n    {f : E â†’ F} {V W : F â†’ F} {x : E} (h'f : ContDiffAt ğ•œ n f x)\n    (hV : DifferentiableAt ğ•œ V (f x)) (hW : DifferentiableAt ğ•œ W (f x)) :\n    pullback ğ•œ f (lieBracket ğ•œ V W) x = lieBracket ğ•œ (pullback ğ•œ f V) (pullback ğ•œ f W) x :=\n  pullback_lieBracket_of_isSymmSndFDerivAt (h'f.isSymmSndFDerivAt hn)\n    (h'f.of_le (le_minSmoothness.trans hn)) hV hW\n\n"}
