{"name":"WithLp.instNontrivial","module":"Mathlib.Analysis.Normed.Lp.WithLp","initialProofState":"p : ENNReal\nV : Type uV\ninst✝ : Nontrivial V\n⊢ Nontrivial (WithLp p V)","decl":"instance instNontrivial [Nontrivial V] : Nontrivial (WithLp p V) := ‹Nontrivial V›\n"}
{"name":"WithLp.instIsScalarTower","module":"Mathlib.Analysis.Normed.Lp.WithLp","initialProofState":"p : ENNReal\nK : Type uK\nK' : Type uK'\nV : Type uV\ninst✝⁶ : Semiring K\ninst✝⁵ : Semiring K'\ninst✝⁴ : AddCommGroup V\ninst✝³ : SMul K K'\ninst✝² : Module K V\ninst✝¹ : Module K' V\ninst✝ : IsScalarTower K K' V\n⊢ IsScalarTower K K' (WithLp p V)","decl":"instance instIsScalarTower [SMul K K'] [Module K V] [Module K' V] [IsScalarTower K K' V] :\n    IsScalarTower K K' (WithLp p V) :=\n  ‹IsScalarTower K K' V›\n\n"}
{"name":"WithLp.instSMulCommClass","module":"Mathlib.Analysis.Normed.Lp.WithLp","initialProofState":"p : ENNReal\nK : Type uK\nK' : Type uK'\nV : Type uV\ninst✝⁵ : Semiring K\ninst✝⁴ : Semiring K'\ninst✝³ : AddCommGroup V\ninst✝² : Module K V\ninst✝¹ : Module K' V\ninst✝ : SMulCommClass K K' V\n⊢ SMulCommClass K K' (WithLp p V)","decl":"instance instSMulCommClass [Module K V] [Module K' V] [SMulCommClass K K' V] :\n    SMulCommClass K K' (WithLp p V) :=\n  ‹SMulCommClass K K' V›\n\n"}
{"name":"WithLp.instModuleFinite","module":"Mathlib.Analysis.Normed.Lp.WithLp","initialProofState":"p : ENNReal\nK : Type uK\nV : Type uV\ninst✝³ : Semiring K\ninst✝² : AddCommGroup V\ninst✝¹ : Module K V\ninst✝ : Module.Finite K V\n⊢ Module.Finite K (WithLp p V)","decl":"instance instModuleFinite [Module K V] [Module.Finite K V] : Module.Finite K (WithLp p V) :=\n  ‹Module.Finite K V›\n\n"}
{"name":"WithLp.equiv_zero","module":"Mathlib.Analysis.Normed.Lp.WithLp","initialProofState":"p : ENNReal\nV : Type uV\ninst✝ : AddCommGroup V\n⊢ Eq ((WithLp.equiv p V) 0) 0","decl":"@[simp]\ntheorem equiv_zero : WithLp.equiv p V 0 = 0 :=\n  rfl\n\n"}
{"name":"WithLp.equiv_symm_zero","module":"Mathlib.Analysis.Normed.Lp.WithLp","initialProofState":"p : ENNReal\nV : Type uV\ninst✝ : AddCommGroup V\n⊢ Eq ((WithLp.equiv p V).symm 0) 0","decl":"@[simp]\ntheorem equiv_symm_zero : (WithLp.equiv p V).symm 0 = 0 :=\n  rfl\n\n"}
{"name":"WithLp.equiv_add","module":"Mathlib.Analysis.Normed.Lp.WithLp","initialProofState":"p : ENNReal\nV : Type uV\ninst✝ : AddCommGroup V\nx y : WithLp p V\n⊢ Eq ((WithLp.equiv p V) (HAdd.hAdd x y)) (HAdd.hAdd ((WithLp.equiv p V) x) ((WithLp.equiv p V) y))","decl":"@[simp]\ntheorem equiv_add : WithLp.equiv p V (x + y) = WithLp.equiv p V x + WithLp.equiv p V y :=\n  rfl\n\n"}
{"name":"WithLp.equiv_symm_add","module":"Mathlib.Analysis.Normed.Lp.WithLp","initialProofState":"p : ENNReal\nV : Type uV\ninst✝ : AddCommGroup V\nx' y' : V\n⊢ Eq ((WithLp.equiv p V).symm (HAdd.hAdd x' y')) (HAdd.hAdd ((WithLp.equiv p V).symm x') ((WithLp.equiv p V).symm y'))","decl":"@[simp]\ntheorem equiv_symm_add :\n    (WithLp.equiv p V).symm (x' + y') = (WithLp.equiv p V).symm x' + (WithLp.equiv p V).symm y' :=\n  rfl\n\n"}
{"name":"WithLp.equiv_sub","module":"Mathlib.Analysis.Normed.Lp.WithLp","initialProofState":"p : ENNReal\nV : Type uV\ninst✝ : AddCommGroup V\nx y : WithLp p V\n⊢ Eq ((WithLp.equiv p V) (HSub.hSub x y)) (HSub.hSub ((WithLp.equiv p V) x) ((WithLp.equiv p V) y))","decl":"@[simp]\ntheorem equiv_sub : WithLp.equiv p V (x - y) = WithLp.equiv p V x - WithLp.equiv p V y :=\n  rfl\n\n"}
{"name":"WithLp.equiv_symm_sub","module":"Mathlib.Analysis.Normed.Lp.WithLp","initialProofState":"p : ENNReal\nV : Type uV\ninst✝ : AddCommGroup V\nx' y' : V\n⊢ Eq ((WithLp.equiv p V).symm (HSub.hSub x' y')) (HSub.hSub ((WithLp.equiv p V).symm x') ((WithLp.equiv p V).symm y'))","decl":"@[simp]\ntheorem equiv_symm_sub :\n    (WithLp.equiv p V).symm (x' - y') = (WithLp.equiv p V).symm x' - (WithLp.equiv p V).symm y' :=\n  rfl\n\n"}
{"name":"WithLp.equiv_neg","module":"Mathlib.Analysis.Normed.Lp.WithLp","initialProofState":"p : ENNReal\nV : Type uV\ninst✝ : AddCommGroup V\nx : WithLp p V\n⊢ Eq ((WithLp.equiv p V) (Neg.neg x)) (Neg.neg ((WithLp.equiv p V) x))","decl":"@[simp]\ntheorem equiv_neg : WithLp.equiv p V (-x) = -WithLp.equiv p V x :=\n  rfl\n\n"}
{"name":"WithLp.equiv_symm_neg","module":"Mathlib.Analysis.Normed.Lp.WithLp","initialProofState":"p : ENNReal\nV : Type uV\ninst✝ : AddCommGroup V\nx' : V\n⊢ Eq ((WithLp.equiv p V).symm (Neg.neg x')) (Neg.neg ((WithLp.equiv p V).symm x'))","decl":"@[simp]\ntheorem equiv_symm_neg : (WithLp.equiv p V).symm (-x') = -(WithLp.equiv p V).symm x' :=\n  rfl\n\n"}
{"name":"WithLp.equiv_smul","module":"Mathlib.Analysis.Normed.Lp.WithLp","initialProofState":"p : ENNReal\nK : Type uK\nV : Type uV\ninst✝² : Semiring K\ninst✝¹ : AddCommGroup V\ninst✝ : Module K V\nc : K\nx : WithLp p V\n⊢ Eq ((WithLp.equiv p V) (HSMul.hSMul c x)) (HSMul.hSMul c ((WithLp.equiv p V) x))","decl":"@[simp]\ntheorem equiv_smul : WithLp.equiv p V (c • x) = c • WithLp.equiv p V x :=\n  rfl\n\n"}
{"name":"WithLp.equiv_symm_smul","module":"Mathlib.Analysis.Normed.Lp.WithLp","initialProofState":"p : ENNReal\nK : Type uK\nV : Type uV\ninst✝² : Semiring K\ninst✝¹ : AddCommGroup V\ninst✝ : Module K V\nc : K\nx' : V\n⊢ Eq ((WithLp.equiv p V).symm (HSMul.hSMul c x')) (HSMul.hSMul c ((WithLp.equiv p V).symm x'))","decl":"@[simp]\ntheorem equiv_symm_smul : (WithLp.equiv p V).symm (c • x') = c • (WithLp.equiv p V).symm x' :=\n  rfl\n\n"}
{"name":"WithLp.linearEquiv_symm_apply","module":"Mathlib.Analysis.Normed.Lp.WithLp","initialProofState":"p : ENNReal\nK : Type uK\nV : Type uV\ninst✝² : Semiring K\ninst✝¹ : AddCommGroup V\ninst✝ : Module K V\n⊢ Eq ⇑(WithLp.linearEquiv p K V).symm ⇑(WithLp.equiv p V).symm","decl":"/-- `WithLp.equiv` as a linear equivalence. -/\n@[simps (config := .asFn)]\nprotected def linearEquiv : WithLp p V ≃ₗ[K] V :=\n  { LinearEquiv.refl _ _ with\n    toFun := WithLp.equiv _ _\n    invFun := (WithLp.equiv _ _).symm }\n\n"}
{"name":"WithLp.linearEquiv_apply","module":"Mathlib.Analysis.Normed.Lp.WithLp","initialProofState":"p : ENNReal\nK : Type uK\nV : Type uV\ninst✝² : Semiring K\ninst✝¹ : AddCommGroup V\ninst✝ : Module K V\n⊢ Eq ⇑(WithLp.linearEquiv p K V) ⇑(WithLp.equiv p V)","decl":"/-- `WithLp.equiv` as a linear equivalence. -/\n@[simps (config := .asFn)]\nprotected def linearEquiv : WithLp p V ≃ₗ[K] V :=\n  { LinearEquiv.refl _ _ with\n    toFun := WithLp.equiv _ _\n    invFun := (WithLp.equiv _ _).symm }\n\n"}
