{"name":"diffToIdealOfQuotientCompEq_apply","module":"Mathlib.RingTheory.Derivation.ToSquareZero","initialProofState":"R : Type u\nA : Type v\nB : Type w\ninst✝⁴ : CommSemiring R\ninst✝³ : CommSemiring A\ninst✝² : CommRing B\ninst✝¹ : Algebra R A\ninst✝ : Algebra R B\nI : Ideal B\nf₁ f₂ : AlgHom R A B\ne : Eq ((Ideal.Quotient.mkₐ R I).comp f₁) ((Ideal.Quotient.mkₐ R I).comp f₂)\nx : A\n⊢ Eq (↑((diffToIdealOfQuotientCompEq I f₁ f₂ e) x)) (HSub.hSub (f₁ x) (f₂ x))","decl":"@[simp]\ntheorem diffToIdealOfQuotientCompEq_apply (f₁ f₂ : A →ₐ[R] B)\n    (e : (Ideal.Quotient.mkₐ R I).comp f₁ = (Ideal.Quotient.mkₐ R I).comp f₂) (x : A) :\n    ((diffToIdealOfQuotientCompEq I f₁ f₂ e) x : B) = f₁ x - f₂ x :=\n  rfl\n\n"}
{"name":"derivationToSquareZeroOfLift_apply","module":"Mathlib.RingTheory.Derivation.ToSquareZero","initialProofState":"R : Type u\nA : Type v\nB : Type w\ninst✝⁶ : CommSemiring R\ninst✝⁵ : CommSemiring A\ninst✝⁴ : CommRing B\ninst✝³ : Algebra R A\ninst✝² : Algebra R B\nI : Ideal B\ninst✝¹ : Algebra A B\nhI : Eq (HPow.hPow I 2) Bot.bot\ninst✝ : IsScalarTower R A B\nf : AlgHom R A B\ne : Eq ((Ideal.Quotient.mkₐ R I).comp f) (IsScalarTower.toAlgHom R A (HasQuotient.Quotient B I))\nx : A\n⊢ Eq (↑((derivationToSquareZeroOfLift I hI f e) x)) (HSub.hSub (f x) ((algebraMap A B) x))","decl":"theorem derivationToSquareZeroOfLift_apply [IsScalarTower R A B] (f : A →ₐ[R] B)\n    (e : (Ideal.Quotient.mkₐ R I).comp f = IsScalarTower.toAlgHom R A (B ⧸ I)) (x : A) :\n    (derivationToSquareZeroOfLift I hI f e x : B) = f x - algebraMap A B x :=\n  rfl\n\n"}
{"name":"liftOfDerivationToSquareZero_apply","module":"Mathlib.RingTheory.Derivation.ToSquareZero","initialProofState":"R : Type u\nA : Type v\nB : Type w\ninst✝⁶ : CommSemiring R\ninst✝⁵ : CommSemiring A\ninst✝⁴ : CommRing B\ninst✝³ : Algebra R A\ninst✝² : Algebra R B\nI : Ideal B\ninst✝¹ : Algebra A B\ninst✝ : IsScalarTower R A B\nhI : Eq (HPow.hPow I 2) Bot.bot\nf : Derivation R A (Subtype fun x => Membership.mem I x)\nx : A\n⊢ Eq ((liftOfDerivationToSquareZero I hI f) x) (HAdd.hAdd (↑(f x)) ((algebraMap A B) x))","decl":"/-- Given a tower of algebras `R → A → B`, and a square-zero `I : Ideal B`, each `R`-derivation\nfrom `A` to `I` corresponds to a lift `A →ₐ[R] B` of the canonical map `A →ₐ[R] B ⧸ I`. -/\n@[simps (config := .lemmasOnly)]\ndef liftOfDerivationToSquareZero [IsScalarTower R A B]  (hI : I ^ 2 = ⊥) (f : Derivation R A I) :\n    A →ₐ[R] B :=\n  { ((I.restrictScalars R).subtype.comp f.toLinearMap + (IsScalarTower.toAlgHom R A B).toLinearMap :\n      A →ₗ[R] B) with\n    toFun := fun x => f x + algebraMap A B x\n    map_one' := by\n      dsimp\n      -- Note: added the `(algebraMap _ _)` hint because otherwise it would match `f 1`\n      rw [map_one (algebraMap _ _), f.map_one_eq_zero, Submodule.coe_zero, zero_add]\n    map_mul' := fun x y => by\n      have : (f x : B) * f y = 0 := by\n        rw [← Ideal.mem_bot, ← hI, pow_two]\n        convert Ideal.mul_mem_mul (f x).2 (f y).2 using 1\n      simp only [map_mul, f.leibniz, add_mul, mul_add, Submodule.coe_add,\n        Submodule.coe_smul_of_tower, Algebra.smul_def, this]\n      ring\n    commutes' := fun r => by\n      simp only [Derivation.map_algebraMap, eq_self_iff_true, zero_add, Submodule.coe_zero, ←\n        IsScalarTower.algebraMap_apply R A B r]\n    map_zero' := ((I.restrictScalars R).subtype.comp f.toLinearMap +\n      (IsScalarTower.toAlgHom R A B).toLinearMap).map_zero }\n\n-- @[simp] -- Porting note: simp normal form is `liftOfDerivationToSquareZero_mk_apply'`\n"}
{"name":"liftOfDerivationToSquareZero_mk_apply","module":"Mathlib.RingTheory.Derivation.ToSquareZero","initialProofState":"R : Type u\nA : Type v\nB : Type w\ninst✝⁶ : CommSemiring R\ninst✝⁵ : CommSemiring A\ninst✝⁴ : CommRing B\ninst✝³ : Algebra R A\ninst✝² : Algebra R B\nI : Ideal B\ninst✝¹ : Algebra A B\nhI : Eq (HPow.hPow I 2) Bot.bot\ninst✝ : IsScalarTower R A B\nd : Derivation R A (Subtype fun x => Membership.mem I x)\nx : A\n⊢ Eq ((Ideal.Quotient.mk I) ((liftOfDerivationToSquareZero I hI d) x)) ((algebraMap A (HasQuotient.Quotient B I)) x)","decl":"theorem liftOfDerivationToSquareZero_mk_apply [IsScalarTower R A B] (d : Derivation R A I) (x : A) :\n    Ideal.Quotient.mk I (liftOfDerivationToSquareZero I hI d x) = algebraMap A (B ⧸ I) x := by\n  rw [liftOfDerivationToSquareZero_apply, map_add, Ideal.Quotient.eq_zero_iff_mem.mpr (d x).prop,\n    zero_add]\n  rfl\n\n"}
{"name":"liftOfDerivationToSquareZero_mk_apply'","module":"Mathlib.RingTheory.Derivation.ToSquareZero","initialProofState":"R : Type u\nA : Type v\nB : Type w\ninst✝⁵ : CommSemiring R\ninst✝⁴ : CommSemiring A\ninst✝³ : CommRing B\ninst✝² : Algebra R A\ninst✝¹ : Algebra R B\nI : Ideal B\ninst✝ : Algebra A B\nd : Derivation R A (Subtype fun x => Membership.mem I x)\nx : A\n⊢ Eq (HAdd.hAdd ((Ideal.Quotient.mk I) ↑(d x)) ((algebraMap A (HasQuotient.Quotient B I)) x)) ((algebraMap A (HasQuotient.Quotient B I)) x)","decl":"@[simp]\ntheorem liftOfDerivationToSquareZero_mk_apply' (d : Derivation R A I) (x : A) :\n    (Ideal.Quotient.mk I) (d x) + (algebraMap A (B ⧸ I)) x = algebraMap A (B ⧸ I) x := by\n  simp only [Ideal.Quotient.eq_zero_iff_mem.mpr (d x).prop, zero_add]\n\n"}
{"name":"derivationToSquareZeroEquivLift_symm_apply_apply_coe","module":"Mathlib.RingTheory.Derivation.ToSquareZero","initialProofState":"R : Type u\nA : Type v\nB : Type w\ninst✝⁶ : CommSemiring R\ninst✝⁵ : CommSemiring A\ninst✝⁴ : CommRing B\ninst✝³ : Algebra R A\ninst✝² : Algebra R B\nI : Ideal B\ninst✝¹ : Algebra A B\nhI : Eq (HPow.hPow I 2) Bot.bot\ninst✝ : IsScalarTower R A B\nf : Subtype fun f => Eq ((Ideal.Quotient.mkₐ R I).comp f) (IsScalarTower.toAlgHom R A (HasQuotient.Quotient B I))\nc : A\n⊢ Eq (↑(((derivationToSquareZeroEquivLift I hI).symm f) c)) (HSub.hSub (↑f c) ((algebraMap A B) c))","decl":"/-- Given a tower of algebras `R → A → B`, and a square-zero `I : Ideal B`,\nthere is a 1-1 correspondence between `R`-derivations from `A` to `I` and\nlifts `A →ₐ[R] B` of the canonical map `A →ₐ[R] B ⧸ I`. -/\n@[simps!]\ndef derivationToSquareZeroEquivLift [IsScalarTower R A B] : Derivation R A I ≃\n    { f : A →ₐ[R] B // (Ideal.Quotient.mkₐ R I).comp f = IsScalarTower.toAlgHom R A (B ⧸ I) } := by\n  refine ⟨fun d => ⟨liftOfDerivationToSquareZero I hI d, ?_⟩, fun f =>\n    (derivationToSquareZeroOfLift I hI f.1 f.2 :), ?_, ?_⟩\n  · ext x; exact liftOfDerivationToSquareZero_mk_apply I hI d x\n  · intro d; ext x; exact add_sub_cancel_right (d x : B) (algebraMap A B x)\n  · rintro ⟨f, hf⟩; ext x; exact sub_add_cancel (f x) (algebraMap A B x)\n\n"}
{"name":"derivationToSquareZeroEquivLift_apply_coe_apply","module":"Mathlib.RingTheory.Derivation.ToSquareZero","initialProofState":"R : Type u\nA : Type v\nB : Type w\ninst✝⁶ : CommSemiring R\ninst✝⁵ : CommSemiring A\ninst✝⁴ : CommRing B\ninst✝³ : Algebra R A\ninst✝² : Algebra R B\nI : Ideal B\ninst✝¹ : Algebra A B\nhI : Eq (HPow.hPow I 2) Bot.bot\ninst✝ : IsScalarTower R A B\nd : Derivation R A (Subtype fun x => Membership.mem I x)\nx : A\n⊢ Eq (↑((derivationToSquareZeroEquivLift I hI) d) x) (HAdd.hAdd (↑(d x)) ((algebraMap A B) x))","decl":"/-- Given a tower of algebras `R → A → B`, and a square-zero `I : Ideal B`,\nthere is a 1-1 correspondence between `R`-derivations from `A` to `I` and\nlifts `A →ₐ[R] B` of the canonical map `A →ₐ[R] B ⧸ I`. -/\n@[simps!]\ndef derivationToSquareZeroEquivLift [IsScalarTower R A B] : Derivation R A I ≃\n    { f : A →ₐ[R] B // (Ideal.Quotient.mkₐ R I).comp f = IsScalarTower.toAlgHom R A (B ⧸ I) } := by\n  refine ⟨fun d => ⟨liftOfDerivationToSquareZero I hI d, ?_⟩, fun f =>\n    (derivationToSquareZeroOfLift I hI f.1 f.2 :), ?_, ?_⟩\n  · ext x; exact liftOfDerivationToSquareZero_mk_apply I hI d x\n  · intro d; ext x; exact add_sub_cancel_right (d x : B) (algebraMap A B x)\n  · rintro ⟨f, hf⟩; ext x; exact sub_add_cancel (f x) (algebraMap A B x)\n\n"}
