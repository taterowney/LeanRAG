{"name":"PEquiv.inv","module":"Mathlib.Data.PEquiv","initialProofState":"α : Type u\nβ : Type v\nself : PEquiv α β\na : α\nb : β\n⊢ Iff (Membership.mem (self.invFun b) a) (Membership.mem (self.toFun a) b)","decl":"/-- A `PEquiv` is a partial equivalence, a representation of a bijection between a subset\n  of `α` and a subset of `β`. See also `PartialEquiv` for a version that requires `toFun` and\n`invFun` to be globally defined functions and has `source` and `target` sets as extra fields. -/\nstructure PEquiv (α : Type u) (β : Type v) where\n  /-- The underlying partial function of a `PEquiv` -/\n  toFun : α → Option β\n  /-- The partial inverse of `toFun` -/\n  invFun : β → Option α\n  /-- `invFun` is the partial inverse of `toFun`  -/\n  inv : ∀ (a : α) (b : β), a ∈ invFun b ↔ b ∈ toFun a\n\n"}
{"name":"PEquiv.mk.inj","module":"Mathlib.Data.PEquiv","initialProofState":"α : Type u\nβ : Type v\ntoFun✝ : α → Option β\ninvFun✝ : β → Option α\ninv✝ : ∀ (a : α) (b : β), Iff (Membership.mem (invFun✝ b) a) (Membership.mem (toFun✝ a) b)\ntoFun : α → Option β\ninvFun : β → Option α\ninv : ∀ (a : α) (b : β), Iff (Membership.mem (invFun b) a) (Membership.mem (toFun a) b)\nx✝ : Eq { toFun := toFun✝, invFun := invFun✝, inv := inv✝ } { toFun := toFun, invFun := invFun, inv := inv }\n⊢ And (Eq toFun✝ toFun) (Eq invFun✝ invFun)","decl":"/-- A `PEquiv` is a partial equivalence, a representation of a bijection between a subset\n  of `α` and a subset of `β`. See also `PartialEquiv` for a version that requires `toFun` and\n`invFun` to be globally defined functions and has `source` and `target` sets as extra fields. -/\nstructure PEquiv (α : Type u) (β : Type v) where\n  /-- The underlying partial function of a `PEquiv` -/\n  toFun : α → Option β\n  /-- The partial inverse of `toFun` -/\n  invFun : β → Option α\n  /-- `invFun` is the partial inverse of `toFun`  -/\n  inv : ∀ (a : α) (b : β), a ∈ invFun b ↔ b ∈ toFun a\n\n"}
{"name":"PEquiv.mk.sizeOf_spec","module":"Mathlib.Data.PEquiv","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : SizeOf α\ninst✝ : SizeOf β\ntoFun : α → Option β\ninvFun : β → Option α\ninv : ∀ (a : α) (b : β), Iff (Membership.mem (invFun b) a) (Membership.mem (toFun a) b)\n⊢ Eq (SizeOf.sizeOf { toFun := toFun, invFun := invFun, inv := inv }) 1","decl":"/-- A `PEquiv` is a partial equivalence, a representation of a bijection between a subset\n  of `α` and a subset of `β`. See also `PartialEquiv` for a version that requires `toFun` and\n`invFun` to be globally defined functions and has `source` and `target` sets as extra fields. -/\nstructure PEquiv (α : Type u) (β : Type v) where\n  /-- The underlying partial function of a `PEquiv` -/\n  toFun : α → Option β\n  /-- The partial inverse of `toFun` -/\n  invFun : β → Option α\n  /-- `invFun` is the partial inverse of `toFun`  -/\n  inv : ∀ (a : α) (b : β), a ∈ invFun b ↔ b ∈ toFun a\n\n"}
{"name":"PEquiv.mk.injEq","module":"Mathlib.Data.PEquiv","initialProofState":"α : Type u\nβ : Type v\ntoFun✝ : α → Option β\ninvFun✝ : β → Option α\ninv✝ : ∀ (a : α) (b : β), Iff (Membership.mem (invFun✝ b) a) (Membership.mem (toFun✝ a) b)\ntoFun : α → Option β\ninvFun : β → Option α\ninv : ∀ (a : α) (b : β), Iff (Membership.mem (invFun b) a) (Membership.mem (toFun a) b)\n⊢ Eq (Eq { toFun := toFun✝, invFun := invFun✝, inv := inv✝ } { toFun := toFun, invFun := invFun, inv := inv }) (And (Eq toFun✝ toFun) (Eq invFun✝ invFun))","decl":"/-- A `PEquiv` is a partial equivalence, a representation of a bijection between a subset\n  of `α` and a subset of `β`. See also `PartialEquiv` for a version that requires `toFun` and\n`invFun` to be globally defined functions and has `source` and `target` sets as extra fields. -/\nstructure PEquiv (α : Type u) (β : Type v) where\n  /-- The underlying partial function of a `PEquiv` -/\n  toFun : α → Option β\n  /-- The partial inverse of `toFun` -/\n  invFun : β → Option α\n  /-- `invFun` is the partial inverse of `toFun`  -/\n  inv : ∀ (a : α) (b : β), a ∈ invFun b ↔ b ∈ toFun a\n\n"}
{"name":"PEquiv.coe_mk","module":"Mathlib.Data.PEquiv","initialProofState":"α : Type u\nβ : Type v\nf₁ : α → Option β\nf₂ : β → Option α\nh : ∀ (a : α) (b : β), Iff (Membership.mem (f₂ b) a) (Membership.mem (f₁ a) b)\n⊢ Eq (⇑{ toFun := f₁, invFun := f₂, inv := h }) f₁","decl":"@[simp] theorem coe_mk (f₁ : α → Option β) (f₂ h) : (mk f₁ f₂ h : α → Option β) = f₁ :=\n  rfl\n\n"}
{"name":"PEquiv.coe_mk_apply","module":"Mathlib.Data.PEquiv","initialProofState":"α : Type u\nβ : Type v\nf₁ : α → Option β\nf₂ : β → Option α\nh : ∀ (a : α) (b : β), Iff (Membership.mem (f₂ b) a) (Membership.mem (f₁ a) b)\nx : α\n⊢ Eq ({ toFun := f₁, invFun := f₂, inv := h } x) (f₁ x)","decl":"theorem coe_mk_apply (f₁ : α → Option β) (f₂ : β → Option α) (h) (x : α) :\n    (PEquiv.mk f₁ f₂ h : α → Option β) x = f₁ x :=\n  rfl\n\n"}
{"name":"PEquiv.ext","module":"Mathlib.Data.PEquiv","initialProofState":"α : Type u\nβ : Type v\nf g : PEquiv α β\nh : ∀ (x : α), Eq (f x) (g x)\n⊢ Eq f g","decl":"@[ext] theorem ext {f g : α ≃. β} (h : ∀ x, f x = g x) : f = g :=\n  DFunLike.ext f g h\n\n"}
{"name":"PEquiv.ext_iff","module":"Mathlib.Data.PEquiv","initialProofState":"α : Type u\nβ : Type v\nf g : PEquiv α β\n⊢ Iff (Eq f g) (∀ (x : α), Eq (f x) (g x))","decl":"@[ext] theorem ext {f g : α ≃. β} (h : ∀ x, f x = g x) : f = g :=\n  DFunLike.ext f g h\n\n"}
{"name":"PEquiv.mem_iff_mem","module":"Mathlib.Data.PEquiv","initialProofState":"α : Type u\nβ : Type v\nf : PEquiv α β\na : α\nb : β\n⊢ Iff (Membership.mem (f.symm b) a) (Membership.mem (f a) b)","decl":"theorem mem_iff_mem (f : α ≃. β) : ∀ {a : α} {b : β}, a ∈ f.symm b ↔ b ∈ f a :=\n  f.3 _ _\n\n"}
{"name":"PEquiv.eq_some_iff","module":"Mathlib.Data.PEquiv","initialProofState":"α : Type u\nβ : Type v\nf : PEquiv α β\na : α\nb : β\n⊢ Iff (Eq (f.symm b) (Option.some a)) (Eq (f a) (Option.some b))","decl":"theorem eq_some_iff (f : α ≃. β) : ∀ {a : α} {b : β}, f.symm b = some a ↔ f a = some b :=\n  f.3 _ _\n\n"}
{"name":"PEquiv.refl_apply","module":"Mathlib.Data.PEquiv","initialProofState":"α : Type u\na : α\n⊢ Eq ((PEquiv.refl α) a) (Option.some a)","decl":"@[simp]\ntheorem refl_apply (a : α) : PEquiv.refl α a = some a :=\n  rfl\n\n"}
{"name":"PEquiv.symm_refl","module":"Mathlib.Data.PEquiv","initialProofState":"α : Type u\n⊢ Eq (PEquiv.refl α).symm (PEquiv.refl α)","decl":"@[simp]\ntheorem symm_refl : (PEquiv.refl α).symm = PEquiv.refl α :=\n  rfl\n\n"}
{"name":"PEquiv.symm_symm","module":"Mathlib.Data.PEquiv","initialProofState":"α : Type u\nβ : Type v\nf : PEquiv α β\n⊢ Eq f.symm.symm f","decl":"@[simp]\ntheorem symm_symm (f : α ≃. β) : f.symm.symm = f := rfl\n\n"}
{"name":"PEquiv.symm_bijective","module":"Mathlib.Data.PEquiv","initialProofState":"α : Type u\nβ : Type v\n⊢ Function.Bijective PEquiv.symm","decl":"theorem symm_bijective : Function.Bijective (PEquiv.symm : (α ≃. β) → β ≃. α) :=\n  Function.bijective_iff_has_inverse.mpr ⟨_, symm_symm, symm_symm⟩\n\n"}
{"name":"PEquiv.symm_injective","module":"Mathlib.Data.PEquiv","initialProofState":"α : Type u\nβ : Type v\n⊢ Function.Injective PEquiv.symm","decl":"theorem symm_injective : Function.Injective (@PEquiv.symm α β) :=\n  symm_bijective.injective\n\n"}
{"name":"PEquiv.trans_assoc","module":"Mathlib.Data.PEquiv","initialProofState":"α : Type u\nβ : Type v\nγ : Type w\nδ : Type x\nf : PEquiv α β\ng : PEquiv β γ\nh : PEquiv γ δ\n⊢ Eq ((f.trans g).trans h) (f.trans (g.trans h))","decl":"theorem trans_assoc (f : α ≃. β) (g : β ≃. γ) (h : γ ≃. δ) :\n    (f.trans g).trans h = f.trans (g.trans h) :=\n  ext fun _ => Option.bind_assoc _ _ _\n\n"}
{"name":"PEquiv.mem_trans","module":"Mathlib.Data.PEquiv","initialProofState":"α : Type u\nβ : Type v\nγ : Type w\nf : PEquiv α β\ng : PEquiv β γ\na : α\nc : γ\n⊢ Iff (Membership.mem ((f.trans g) a) c) (Exists fun b => And (Membership.mem (f a) b) (Membership.mem (g b) c))","decl":"theorem mem_trans (f : α ≃. β) (g : β ≃. γ) (a : α) (c : γ) :\n    c ∈ f.trans g a ↔ ∃ b, b ∈ f a ∧ c ∈ g b :=\n  Option.bind_eq_some'\n\n"}
{"name":"PEquiv.trans_eq_some","module":"Mathlib.Data.PEquiv","initialProofState":"α : Type u\nβ : Type v\nγ : Type w\nf : PEquiv α β\ng : PEquiv β γ\na : α\nc : γ\n⊢ Iff (Eq ((f.trans g) a) (Option.some c)) (Exists fun b => And (Eq (f a) (Option.some b)) (Eq (g b) (Option.some c)))","decl":"theorem trans_eq_some (f : α ≃. β) (g : β ≃. γ) (a : α) (c : γ) :\n    f.trans g a = some c ↔ ∃ b, f a = some b ∧ g b = some c :=\n  Option.bind_eq_some'\n\n"}
{"name":"PEquiv.trans_eq_none","module":"Mathlib.Data.PEquiv","initialProofState":"α : Type u\nβ : Type v\nγ : Type w\nf : PEquiv α β\ng : PEquiv β γ\na : α\n⊢ Iff (Eq ((f.trans g) a) Option.none) (∀ (b : β) (c : γ), Or (Not (Membership.mem (f a) b)) (Not (Membership.mem (g b) c)))","decl":"theorem trans_eq_none (f : α ≃. β) (g : β ≃. γ) (a : α) :\n    f.trans g a = none ↔ ∀ b c, b ∉ f a ∨ c ∉ g b := by\n  simp only [eq_none_iff_forall_not_mem, mem_trans, imp_iff_not_or.symm]\n  push_neg\n  exact forall_swap\n\n"}
{"name":"PEquiv.refl_trans","module":"Mathlib.Data.PEquiv","initialProofState":"α : Type u\nβ : Type v\nf : PEquiv α β\n⊢ Eq ((PEquiv.refl α).trans f) f","decl":"@[simp]\ntheorem refl_trans (f : α ≃. β) : (PEquiv.refl α).trans f = f := by\n  ext; dsimp [PEquiv.trans]; rfl\n\n"}
{"name":"PEquiv.trans_refl","module":"Mathlib.Data.PEquiv","initialProofState":"α : Type u\nβ : Type v\nf : PEquiv α β\n⊢ Eq (f.trans (PEquiv.refl β)) f","decl":"@[simp]\ntheorem trans_refl (f : α ≃. β) : f.trans (PEquiv.refl β) = f := by\n  ext; dsimp [PEquiv.trans]; simp\n\n"}
{"name":"PEquiv.inj","module":"Mathlib.Data.PEquiv","initialProofState":"α : Type u\nβ : Type v\nf : PEquiv α β\na₁ a₂ : α\nb : β\nh₁ : Membership.mem (f a₁) b\nh₂ : Membership.mem (f a₂) b\n⊢ Eq a₁ a₂","decl":"protected theorem inj (f : α ≃. β) {a₁ a₂ : α} {b : β} (h₁ : b ∈ f a₁) (h₂ : b ∈ f a₂) :\n    a₁ = a₂ := by rw [← mem_iff_mem] at *; cases h : f.symm b <;> simp_all\n\n"}
{"name":"PEquiv.injective_of_forall_ne_isSome","module":"Mathlib.Data.PEquiv","initialProofState":"α : Type u\nβ : Type v\nf : PEquiv α β\na₂ : α\nh : ∀ (a₁ : α), Ne a₁ a₂ → Eq (f a₁).isSome Bool.true\n⊢ Function.Injective ⇑f","decl":"/-- If the domain of a `PEquiv` is `α` except a point, its forward direction is injective. -/\ntheorem injective_of_forall_ne_isSome (f : α ≃. β) (a₂ : α)\n    (h : ∀ a₁ : α, a₁ ≠ a₂ → isSome (f a₁)) : Injective f :=\n  HasLeftInverse.injective\n    ⟨fun b => Option.recOn b a₂ fun b' => Option.recOn (f.symm b') a₂ id, fun x => by\n      classical\n        cases hfx : f x\n        · have : x = a₂ := not_imp_comm.1 (h x) (hfx.symm ▸ by simp)\n          simp [this]\n        · dsimp only\n          rw [(eq_some_iff f).2 hfx]\n          rfl⟩\n\n"}
{"name":"PEquiv.injective_of_forall_isSome","module":"Mathlib.Data.PEquiv","initialProofState":"α : Type u\nβ : Type v\nf : PEquiv α β\nh : ∀ (a : α), Eq (f a).isSome Bool.true\n⊢ Function.Injective ⇑f","decl":"/-- If the domain of a `PEquiv` is all of `α`, its forward direction is injective. -/\ntheorem injective_of_forall_isSome {f : α ≃. β} (h : ∀ a : α, isSome (f a)) : Injective f :=\n  (Classical.em (Nonempty α)).elim\n    (fun hn => injective_of_forall_ne_isSome f (Classical.choice hn) fun a _ => h a) fun hn x =>\n    (hn ⟨x⟩).elim\n\n"}
{"name":"PEquiv.mem_ofSet_self_iff","module":"Mathlib.Data.PEquiv","initialProofState":"α : Type u\ns : Set α\ninst✝ : DecidablePred fun x => Membership.mem s x\na : α\n⊢ Iff (Membership.mem ((PEquiv.ofSet s) a) a) (Membership.mem s a)","decl":"theorem mem_ofSet_self_iff {s : Set α} [DecidablePred (· ∈ s)] {a : α} : a ∈ ofSet s a ↔ a ∈ s := by\n  dsimp [ofSet]; split_ifs <;> simp [*]\n\n"}
{"name":"PEquiv.mem_ofSet_iff","module":"Mathlib.Data.PEquiv","initialProofState":"α : Type u\ns : Set α\ninst✝ : DecidablePred fun x => Membership.mem s x\na b : α\n⊢ Iff (Membership.mem ((PEquiv.ofSet s) b) a) (And (Eq a b) (Membership.mem s a))","decl":"theorem mem_ofSet_iff {s : Set α} [DecidablePred (· ∈ s)] {a b : α} :\n    a ∈ ofSet s b ↔ a = b ∧ a ∈ s := by\n  dsimp [ofSet]\n  split_ifs with h\n  · simp only [mem_def, eq_comm, some.injEq, iff_self_and]\n    rintro rfl\n    exact h\n  · simp only [mem_def, false_iff, not_and, reduceCtorEq]\n    rintro rfl\n    exact h\n\n"}
{"name":"PEquiv.ofSet_eq_some_iff","module":"Mathlib.Data.PEquiv","initialProofState":"α : Type u\ns : Set α\nx✝ : DecidablePred fun x => Membership.mem s x\na b : α\n⊢ Iff (Eq ((PEquiv.ofSet s) b) (Option.some a)) (And (Eq a b) (Membership.mem s a))","decl":"@[simp]\ntheorem ofSet_eq_some_iff {s : Set α} {_ : DecidablePred (· ∈ s)} {a b : α} :\n    ofSet s b = some a ↔ a = b ∧ a ∈ s :=\n  mem_ofSet_iff\n\n"}
{"name":"PEquiv.ofSet_eq_some_self_iff","module":"Mathlib.Data.PEquiv","initialProofState":"α : Type u\ns : Set α\nx✝ : DecidablePred fun x => Membership.mem s x\na : α\n⊢ Iff (Eq ((PEquiv.ofSet s) a) (Option.some a)) (Membership.mem s a)","decl":"theorem ofSet_eq_some_self_iff {s : Set α} {_ : DecidablePred (· ∈ s)} {a : α} :\n    ofSet s a = some a ↔ a ∈ s :=\n  mem_ofSet_self_iff\n\n"}
{"name":"PEquiv.ofSet_symm","module":"Mathlib.Data.PEquiv","initialProofState":"α : Type u\ns : Set α\ninst✝ : DecidablePred fun x => Membership.mem s x\n⊢ Eq (PEquiv.ofSet s).symm (PEquiv.ofSet s)","decl":"@[simp]\ntheorem ofSet_symm : (ofSet s).symm = ofSet s :=\n  rfl\n\n"}
{"name":"PEquiv.ofSet_univ","module":"Mathlib.Data.PEquiv","initialProofState":"α : Type u\n⊢ Eq (PEquiv.ofSet Set.univ) (PEquiv.refl α)","decl":"@[simp]\ntheorem ofSet_univ : ofSet Set.univ = PEquiv.refl α :=\n  rfl\n\n"}
{"name":"PEquiv.ofSet_eq_refl","module":"Mathlib.Data.PEquiv","initialProofState":"α : Type u\ns : Set α\ninst✝ : DecidablePred fun x => Membership.mem s x\n⊢ Iff (Eq (PEquiv.ofSet s) (PEquiv.refl α)) (Eq s Set.univ)","decl":"@[simp]\ntheorem ofSet_eq_refl {s : Set α} [DecidablePred (· ∈ s)] :\n    ofSet s = PEquiv.refl α ↔ s = Set.univ :=\n  ⟨fun h => by\n    rw [Set.eq_univ_iff_forall]\n    intro\n    rw [← mem_ofSet_self_iff, h]\n    exact rfl, fun h => by simp only [← ofSet_univ, h]⟩\n\n"}
{"name":"PEquiv.symm_trans_rev","module":"Mathlib.Data.PEquiv","initialProofState":"α : Type u\nβ : Type v\nγ : Type w\nf : PEquiv α β\ng : PEquiv β γ\n⊢ Eq (f.trans g).symm (g.symm.trans f.symm)","decl":"theorem symm_trans_rev (f : α ≃. β) (g : β ≃. γ) : (f.trans g).symm = g.symm.trans f.symm :=\n  rfl\n\n"}
{"name":"PEquiv.self_trans_symm","module":"Mathlib.Data.PEquiv","initialProofState":"α : Type u\nβ : Type v\nf : PEquiv α β\n⊢ Eq (f.trans f.symm) (PEquiv.ofSet (setOf fun a => Eq (f a).isSome Bool.true))","decl":"theorem self_trans_symm (f : α ≃. β) : f.trans f.symm = ofSet { a | (f a).isSome } := by\n  ext\n  dsimp [PEquiv.trans]\n  simp only [eq_some_iff f, Option.isSome_iff_exists, Option.mem_def, bind_eq_some',\n    ofSet_eq_some_iff]\n  constructor\n  · rintro ⟨b, hb₁, hb₂⟩\n    exact ⟨PEquiv.inj _ hb₂ hb₁, b, hb₂⟩\n  · simp +contextual\n\n"}
{"name":"PEquiv.symm_trans_self","module":"Mathlib.Data.PEquiv","initialProofState":"α : Type u\nβ : Type v\nf : PEquiv α β\n⊢ Eq (f.symm.trans f) (PEquiv.ofSet (setOf fun b => Eq (f.symm b).isSome Bool.true))","decl":"theorem symm_trans_self (f : α ≃. β) : f.symm.trans f = ofSet { b | (f.symm b).isSome } :=\n  symm_injective <| by simp [symm_trans_rev, self_trans_symm, -symm_symm]\n\n"}
{"name":"PEquiv.trans_symm_eq_iff_forall_isSome","module":"Mathlib.Data.PEquiv","initialProofState":"α : Type u\nβ : Type v\nf : PEquiv α β\n⊢ Iff (Eq (f.trans f.symm) (PEquiv.refl α)) (∀ (a : α), Eq (f a).isSome Bool.true)","decl":"theorem trans_symm_eq_iff_forall_isSome {f : α ≃. β} :\n    f.trans f.symm = PEquiv.refl α ↔ ∀ a, isSome (f a) := by\n  rw [self_trans_symm, ofSet_eq_refl, Set.eq_univ_iff_forall]; rfl\n\n"}
{"name":"PEquiv.bot_apply","module":"Mathlib.Data.PEquiv","initialProofState":"α : Type u\nβ : Type v\na : α\n⊢ Eq (Bot.bot a) Option.none","decl":"@[simp]\ntheorem bot_apply (a : α) : (⊥ : α ≃. β) a = none :=\n  rfl\n\n"}
{"name":"PEquiv.symm_bot","module":"Mathlib.Data.PEquiv","initialProofState":"α : Type u\nβ : Type v\n⊢ Eq Bot.bot.symm Bot.bot","decl":"@[simp]\ntheorem symm_bot : (⊥ : α ≃. β).symm = ⊥ :=\n  rfl\n\n"}
{"name":"PEquiv.trans_bot","module":"Mathlib.Data.PEquiv","initialProofState":"α : Type u\nβ : Type v\nγ : Type w\nf : PEquiv α β\n⊢ Eq (f.trans Bot.bot) Bot.bot","decl":"@[simp]\ntheorem trans_bot (f : α ≃. β) : f.trans (⊥ : β ≃. γ) = ⊥ := by\n  ext; dsimp [PEquiv.trans]; simp\n\n"}
{"name":"PEquiv.bot_trans","module":"Mathlib.Data.PEquiv","initialProofState":"α : Type u\nβ : Type v\nγ : Type w\nf : PEquiv β γ\n⊢ Eq (Bot.bot.trans f) Bot.bot","decl":"@[simp]\ntheorem bot_trans (f : β ≃. γ) : (⊥ : α ≃. β).trans f = ⊥ := by\n  ext; dsimp [PEquiv.trans]; simp\n\n"}
{"name":"PEquiv.isSome_symm_get","module":"Mathlib.Data.PEquiv","initialProofState":"α : Type u\nβ : Type v\nf : PEquiv α β\na : α\nh : Eq (f a).isSome Bool.true\n⊢ Eq (f.symm ((f a).get h)).isSome Bool.true","decl":"theorem isSome_symm_get (f : α ≃. β) {a : α} (h : isSome (f a)) :\n    isSome (f.symm (Option.get _ h)) :=\n  isSome_iff_exists.2 ⟨a, by rw [f.eq_some_iff, some_get]⟩\n\n"}
{"name":"PEquiv.mem_single","module":"Mathlib.Data.PEquiv","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : DecidableEq α\ninst✝ : DecidableEq β\na : α\nb : β\n⊢ Membership.mem ((PEquiv.single a b) a) b","decl":"theorem mem_single (a : α) (b : β) : b ∈ single a b a :=\n  if_pos rfl\n\n"}
{"name":"PEquiv.mem_single_iff","module":"Mathlib.Data.PEquiv","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : DecidableEq α\ninst✝ : DecidableEq β\na₁ a₂ : α\nb₁ b₂ : β\n⊢ Iff (Membership.mem ((PEquiv.single a₂ b₂) a₁) b₁) (And (Eq a₁ a₂) (Eq b₁ b₂))","decl":"theorem mem_single_iff (a₁ a₂ : α) (b₁ b₂ : β) : b₁ ∈ single a₂ b₂ a₁ ↔ a₁ = a₂ ∧ b₁ = b₂ := by\n  dsimp [single]; split_ifs <;> simp [*, eq_comm]\n\n"}
{"name":"PEquiv.symm_single","module":"Mathlib.Data.PEquiv","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : DecidableEq α\ninst✝ : DecidableEq β\na : α\nb : β\n⊢ Eq (PEquiv.single a b).symm (PEquiv.single b a)","decl":"@[simp]\ntheorem symm_single (a : α) (b : β) : (single a b).symm = single b a :=\n  rfl\n\n"}
{"name":"PEquiv.single_apply","module":"Mathlib.Data.PEquiv","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : DecidableEq α\ninst✝ : DecidableEq β\na : α\nb : β\n⊢ Eq ((PEquiv.single a b) a) (Option.some b)","decl":"@[simp]\ntheorem single_apply (a : α) (b : β) : single a b a = some b :=\n  if_pos rfl\n\n"}
{"name":"PEquiv.single_apply_of_ne","module":"Mathlib.Data.PEquiv","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : DecidableEq α\ninst✝ : DecidableEq β\na₁ a₂ : α\nh : Ne a₁ a₂\nb : β\n⊢ Eq ((PEquiv.single a₁ b) a₂) Option.none","decl":"theorem single_apply_of_ne {a₁ a₂ : α} (h : a₁ ≠ a₂) (b : β) : single a₁ b a₂ = none :=\n  if_neg h.symm\n\n"}
{"name":"PEquiv.single_trans_of_mem","module":"Mathlib.Data.PEquiv","initialProofState":"α : Type u\nβ : Type v\nγ : Type w\ninst✝² : DecidableEq α\ninst✝¹ : DecidableEq β\ninst✝ : DecidableEq γ\na : α\nb : β\nc : γ\nf : PEquiv β γ\nh : Membership.mem (f b) c\n⊢ Eq ((PEquiv.single a b).trans f) (PEquiv.single a c)","decl":"theorem single_trans_of_mem (a : α) {b : β} {c : γ} {f : β ≃. γ} (h : c ∈ f b) :\n    (single a b).trans f = single a c := by\n  ext\n  dsimp [single, PEquiv.trans]\n  split_ifs <;> simp_all\n\n"}
{"name":"PEquiv.trans_single_of_mem","module":"Mathlib.Data.PEquiv","initialProofState":"α : Type u\nβ : Type v\nγ : Type w\ninst✝² : DecidableEq α\ninst✝¹ : DecidableEq β\ninst✝ : DecidableEq γ\na : α\nb : β\nc : γ\nf : PEquiv α β\nh : Membership.mem (f a) b\n⊢ Eq (f.trans (PEquiv.single b c)) (PEquiv.single a c)","decl":"theorem trans_single_of_mem {a : α} {b : β} (c : γ) {f : α ≃. β} (h : b ∈ f a) :\n    f.trans (single b c) = single a c :=\n  symm_injective <| single_trans_of_mem _ ((mem_iff_mem f).2 h)\n\n"}
{"name":"PEquiv.single_trans_single","module":"Mathlib.Data.PEquiv","initialProofState":"α : Type u\nβ : Type v\nγ : Type w\ninst✝² : DecidableEq α\ninst✝¹ : DecidableEq β\ninst✝ : DecidableEq γ\na : α\nb : β\nc : γ\n⊢ Eq ((PEquiv.single a b).trans (PEquiv.single b c)) (PEquiv.single a c)","decl":"@[simp]\ntheorem single_trans_single (a : α) (b : β) (c : γ) :\n    (single a b).trans (single b c) = single a c :=\n  single_trans_of_mem _ (mem_single _ _)\n\n"}
{"name":"PEquiv.single_subsingleton_eq_refl","module":"Mathlib.Data.PEquiv","initialProofState":"α : Type u\ninst✝¹ : DecidableEq α\ninst✝ : Subsingleton α\na b : α\n⊢ Eq (PEquiv.single a b) (PEquiv.refl α)","decl":"@[simp]\ntheorem single_subsingleton_eq_refl [Subsingleton α] (a b : α) : single a b = PEquiv.refl α := by\n  ext i j\n  dsimp [single]\n  rw [if_pos (Subsingleton.elim i a), Subsingleton.elim i j, Subsingleton.elim b j]\n\n"}
{"name":"PEquiv.trans_single_of_eq_none","module":"Mathlib.Data.PEquiv","initialProofState":"β : Type v\nγ : Type w\nδ : Type x\ninst✝¹ : DecidableEq β\ninst✝ : DecidableEq γ\nb : β\nc : γ\nf : PEquiv δ β\nh : Eq (f.symm b) Option.none\n⊢ Eq (f.trans (PEquiv.single b c)) Bot.bot","decl":"theorem trans_single_of_eq_none {b : β} (c : γ) {f : δ ≃. β} (h : f.symm b = none) :\n    f.trans (single b c) = ⊥ := by\n  ext\n  simp only [eq_none_iff_forall_not_mem, Option.mem_def, f.eq_some_iff] at h\n  dsimp [PEquiv.trans, single]\n  simp only [mem_def, bind_eq_some, iff_false, not_exists, not_and, reduceCtorEq]\n  intros\n  split_ifs <;> simp_all\n\n"}
{"name":"PEquiv.single_trans_of_eq_none","module":"Mathlib.Data.PEquiv","initialProofState":"α : Type u\nβ : Type v\nδ : Type x\ninst✝¹ : DecidableEq α\ninst✝ : DecidableEq β\na : α\nb : β\nf : PEquiv β δ\nh : Eq (f b) Option.none\n⊢ Eq ((PEquiv.single a b).trans f) Bot.bot","decl":"theorem single_trans_of_eq_none (a : α) {b : β} {f : β ≃. δ} (h : f b = none) :\n    (single a b).trans f = ⊥ :=\n  symm_injective <| trans_single_of_eq_none _ h\n\n"}
{"name":"PEquiv.single_trans_single_of_ne","module":"Mathlib.Data.PEquiv","initialProofState":"α : Type u\nβ : Type v\nγ : Type w\ninst✝² : DecidableEq α\ninst✝¹ : DecidableEq β\ninst✝ : DecidableEq γ\nb₁ b₂ : β\nh : Ne b₁ b₂\na : α\nc : γ\n⊢ Eq ((PEquiv.single a b₁).trans (PEquiv.single b₂ c)) Bot.bot","decl":"theorem single_trans_single_of_ne {b₁ b₂ : β} (h : b₁ ≠ b₂) (a : α) (c : γ) :\n    (single a b₁).trans (single b₂ c) = ⊥ :=\n  single_trans_of_eq_none _ (single_apply_of_ne h.symm _)\n\n"}
{"name":"PEquiv.le_def","module":"Mathlib.Data.PEquiv","initialProofState":"α : Type u\nβ : Type v\nf g : PEquiv α β\n⊢ Iff (LE.le f g) (∀ (a : α) (b : β), Membership.mem (f a) b → Membership.mem (g a) b)","decl":"theorem le_def {f g : α ≃. β} : f ≤ g ↔ ∀ (a : α) (b : β), b ∈ f a → b ∈ g a :=\n  Iff.rfl\n\n"}
{"name":"Equiv.toPEquiv_refl","module":"Mathlib.Data.PEquiv","initialProofState":"α : Type u_1\n⊢ Eq (Equiv.refl α).toPEquiv (PEquiv.refl α)","decl":"@[simp]\ntheorem toPEquiv_refl : (Equiv.refl α).toPEquiv = PEquiv.refl α :=\n  rfl\n\n"}
{"name":"Equiv.toPEquiv_trans","module":"Mathlib.Data.PEquiv","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nf : Equiv α β\ng : Equiv β γ\n⊢ Eq (f.trans g).toPEquiv (f.toPEquiv.trans g.toPEquiv)","decl":"theorem toPEquiv_trans (f : α ≃ β) (g : β ≃ γ) :\n    (f.trans g).toPEquiv = f.toPEquiv.trans g.toPEquiv :=\n  rfl\n\n"}
{"name":"Equiv.toPEquiv_symm","module":"Mathlib.Data.PEquiv","initialProofState":"α : Type u_1\nβ : Type u_2\nf : Equiv α β\n⊢ Eq f.symm.toPEquiv f.toPEquiv.symm","decl":"theorem toPEquiv_symm (f : α ≃ β) : f.symm.toPEquiv = f.toPEquiv.symm :=\n  rfl\n\n"}
{"name":"Equiv.toPEquiv_apply","module":"Mathlib.Data.PEquiv","initialProofState":"α : Type u_1\nβ : Type u_2\nf : Equiv α β\nx : α\n⊢ Eq (f.toPEquiv x) (Option.some (f x))","decl":"@[simp]\ntheorem toPEquiv_apply (f : α ≃ β) (x : α) : f.toPEquiv x = some (f x) :=\n  rfl\n\n"}
