{"name":"AlgebraicGeometry.Scheme.GlueData.oneHypercover_X","module":"Mathlib.AlgebraicGeometry.GluingOneHypercover","initialProofState":"D : AlgebraicGeometry.Scheme.GlueData\na‚úù : D.J\n‚ä¢ Eq (D.oneHypercover.X a‚úù) (D.U a‚úù)","decl":"/-- The 1-hypercover of `D.glued` in the big Zariski site that is given by the\nopen cover `D.U` from the glue data `D`.\nThe \"covering of the intersection of two such open subsets\" is the trivial\ncovering given by `D.V`. -/\n@[simps]\nnoncomputable def oneHypercover : Scheme.zariskiTopology.OneHypercover D.glued where\n  I‚ÇÄ := D.J\n  X := D.U\n  f := D.Œπ\n  I‚ÇÅ _ _ := PUnit\n  Y i‚ÇÅ i‚ÇÇ _ := D.V (i‚ÇÅ, i‚ÇÇ)\n  p‚ÇÅ i‚ÇÅ i‚ÇÇ _ := D.f i‚ÇÅ i‚ÇÇ\n  p‚ÇÇ i‚ÇÅ i‚ÇÇ _ := D.t i‚ÇÅ i‚ÇÇ ‚â´ D.f i‚ÇÇ i‚ÇÅ\n  w i‚ÇÅ i‚ÇÇ _ := by simp only [Category.assoc, Scheme.GlueData.glue_condition]\n  mem‚ÇÄ := by\n    refine zariskiTopology.superset_covering ?_ (grothendieckTopology_cover D.openCover)\n    rw [Sieve.generate_le_iff]\n    rintro W _ ‚ü®i‚ü©\n    exact ‚ü®_, ùüô _, _, ‚ü®i‚ü©, by simp; rfl‚ü©\n  mem‚ÇÅ i‚ÇÅ i‚ÇÇ W p‚ÇÅ p‚ÇÇ fac := by\n    refine zariskiTopology.superset_covering (fun T g _ ‚Ü¶ ?_) (zariskiTopology.top_mem _)\n    have ‚ü®œÜ, h‚ÇÅ, h‚ÇÇ‚ü© := PullbackCone.IsLimit.lift' (D.vPullbackConeIsLimit i‚ÇÅ i‚ÇÇ)\n      (g ‚â´ p‚ÇÅ) (g ‚â´ p‚ÇÇ) (by simpa using g ‚â´= fac)\n    exact ‚ü®‚ü®‚ü©, œÜ, h‚ÇÅ.symm, h‚ÇÇ.symm‚ü©\n\n"}
{"name":"AlgebraicGeometry.Scheme.GlueData.oneHypercover_I‚ÇÅ","module":"Mathlib.AlgebraicGeometry.GluingOneHypercover","initialProofState":"D : AlgebraicGeometry.Scheme.GlueData\nx‚úù¬π x‚úù : D.J\n‚ä¢ Eq (D.oneHypercover.I‚ÇÅ x‚úù¬π x‚úù) PUnit.{u + 1}","decl":"/-- The 1-hypercover of `D.glued` in the big Zariski site that is given by the\nopen cover `D.U` from the glue data `D`.\nThe \"covering of the intersection of two such open subsets\" is the trivial\ncovering given by `D.V`. -/\n@[simps]\nnoncomputable def oneHypercover : Scheme.zariskiTopology.OneHypercover D.glued where\n  I‚ÇÄ := D.J\n  X := D.U\n  f := D.Œπ\n  I‚ÇÅ _ _ := PUnit\n  Y i‚ÇÅ i‚ÇÇ _ := D.V (i‚ÇÅ, i‚ÇÇ)\n  p‚ÇÅ i‚ÇÅ i‚ÇÇ _ := D.f i‚ÇÅ i‚ÇÇ\n  p‚ÇÇ i‚ÇÅ i‚ÇÇ _ := D.t i‚ÇÅ i‚ÇÇ ‚â´ D.f i‚ÇÇ i‚ÇÅ\n  w i‚ÇÅ i‚ÇÇ _ := by simp only [Category.assoc, Scheme.GlueData.glue_condition]\n  mem‚ÇÄ := by\n    refine zariskiTopology.superset_covering ?_ (grothendieckTopology_cover D.openCover)\n    rw [Sieve.generate_le_iff]\n    rintro W _ ‚ü®i‚ü©\n    exact ‚ü®_, ùüô _, _, ‚ü®i‚ü©, by simp; rfl‚ü©\n  mem‚ÇÅ i‚ÇÅ i‚ÇÇ W p‚ÇÅ p‚ÇÇ fac := by\n    refine zariskiTopology.superset_covering (fun T g _ ‚Ü¶ ?_) (zariskiTopology.top_mem _)\n    have ‚ü®œÜ, h‚ÇÅ, h‚ÇÇ‚ü© := PullbackCone.IsLimit.lift' (D.vPullbackConeIsLimit i‚ÇÅ i‚ÇÇ)\n      (g ‚â´ p‚ÇÅ) (g ‚â´ p‚ÇÇ) (by simpa using g ‚â´= fac)\n    exact ‚ü®‚ü®‚ü©, œÜ, h‚ÇÅ.symm, h‚ÇÇ.symm‚ü©\n\n"}
{"name":"AlgebraicGeometry.Scheme.GlueData.oneHypercover_f","module":"Mathlib.AlgebraicGeometry.GluingOneHypercover","initialProofState":"D : AlgebraicGeometry.Scheme.GlueData\ni : D.J\n‚ä¢ Eq (D.oneHypercover.f i) (D.Œπ i)","decl":"/-- The 1-hypercover of `D.glued` in the big Zariski site that is given by the\nopen cover `D.U` from the glue data `D`.\nThe \"covering of the intersection of two such open subsets\" is the trivial\ncovering given by `D.V`. -/\n@[simps]\nnoncomputable def oneHypercover : Scheme.zariskiTopology.OneHypercover D.glued where\n  I‚ÇÄ := D.J\n  X := D.U\n  f := D.Œπ\n  I‚ÇÅ _ _ := PUnit\n  Y i‚ÇÅ i‚ÇÇ _ := D.V (i‚ÇÅ, i‚ÇÇ)\n  p‚ÇÅ i‚ÇÅ i‚ÇÇ _ := D.f i‚ÇÅ i‚ÇÇ\n  p‚ÇÇ i‚ÇÅ i‚ÇÇ _ := D.t i‚ÇÅ i‚ÇÇ ‚â´ D.f i‚ÇÇ i‚ÇÅ\n  w i‚ÇÅ i‚ÇÇ _ := by simp only [Category.assoc, Scheme.GlueData.glue_condition]\n  mem‚ÇÄ := by\n    refine zariskiTopology.superset_covering ?_ (grothendieckTopology_cover D.openCover)\n    rw [Sieve.generate_le_iff]\n    rintro W _ ‚ü®i‚ü©\n    exact ‚ü®_, ùüô _, _, ‚ü®i‚ü©, by simp; rfl‚ü©\n  mem‚ÇÅ i‚ÇÅ i‚ÇÇ W p‚ÇÅ p‚ÇÇ fac := by\n    refine zariskiTopology.superset_covering (fun T g _ ‚Ü¶ ?_) (zariskiTopology.top_mem _)\n    have ‚ü®œÜ, h‚ÇÅ, h‚ÇÇ‚ü© := PullbackCone.IsLimit.lift' (D.vPullbackConeIsLimit i‚ÇÅ i‚ÇÇ)\n      (g ‚â´ p‚ÇÅ) (g ‚â´ p‚ÇÇ) (by simpa using g ‚â´= fac)\n    exact ‚ü®‚ü®‚ü©, œÜ, h‚ÇÅ.symm, h‚ÇÇ.symm‚ü©\n\n"}
{"name":"AlgebraicGeometry.Scheme.GlueData.oneHypercover_Y","module":"Mathlib.AlgebraicGeometry.GluingOneHypercover","initialProofState":"D : AlgebraicGeometry.Scheme.GlueData\ni‚ÇÅ i‚ÇÇ : D.J\nx‚úù : PUnit.{u + 1}\n‚ä¢ Eq (D.oneHypercover.Y x‚úù) (D.V { fst := i‚ÇÅ, snd := i‚ÇÇ })","decl":"/-- The 1-hypercover of `D.glued` in the big Zariski site that is given by the\nopen cover `D.U` from the glue data `D`.\nThe \"covering of the intersection of two such open subsets\" is the trivial\ncovering given by `D.V`. -/\n@[simps]\nnoncomputable def oneHypercover : Scheme.zariskiTopology.OneHypercover D.glued where\n  I‚ÇÄ := D.J\n  X := D.U\n  f := D.Œπ\n  I‚ÇÅ _ _ := PUnit\n  Y i‚ÇÅ i‚ÇÇ _ := D.V (i‚ÇÅ, i‚ÇÇ)\n  p‚ÇÅ i‚ÇÅ i‚ÇÇ _ := D.f i‚ÇÅ i‚ÇÇ\n  p‚ÇÇ i‚ÇÅ i‚ÇÇ _ := D.t i‚ÇÅ i‚ÇÇ ‚â´ D.f i‚ÇÇ i‚ÇÅ\n  w i‚ÇÅ i‚ÇÇ _ := by simp only [Category.assoc, Scheme.GlueData.glue_condition]\n  mem‚ÇÄ := by\n    refine zariskiTopology.superset_covering ?_ (grothendieckTopology_cover D.openCover)\n    rw [Sieve.generate_le_iff]\n    rintro W _ ‚ü®i‚ü©\n    exact ‚ü®_, ùüô _, _, ‚ü®i‚ü©, by simp; rfl‚ü©\n  mem‚ÇÅ i‚ÇÅ i‚ÇÇ W p‚ÇÅ p‚ÇÇ fac := by\n    refine zariskiTopology.superset_covering (fun T g _ ‚Ü¶ ?_) (zariskiTopology.top_mem _)\n    have ‚ü®œÜ, h‚ÇÅ, h‚ÇÇ‚ü© := PullbackCone.IsLimit.lift' (D.vPullbackConeIsLimit i‚ÇÅ i‚ÇÇ)\n      (g ‚â´ p‚ÇÅ) (g ‚â´ p‚ÇÇ) (by simpa using g ‚â´= fac)\n    exact ‚ü®‚ü®‚ü©, œÜ, h‚ÇÅ.symm, h‚ÇÇ.symm‚ü©\n\n"}
{"name":"AlgebraicGeometry.Scheme.GlueData.oneHypercover_p‚ÇÇ","module":"Mathlib.AlgebraicGeometry.GluingOneHypercover","initialProofState":"D : AlgebraicGeometry.Scheme.GlueData\ni‚ÇÅ i‚ÇÇ : D.J\nx‚úù : PUnit.{u + 1}\n‚ä¢ Eq (D.oneHypercover.p‚ÇÇ x‚úù) (CategoryTheory.CategoryStruct.comp (D.t i‚ÇÅ i‚ÇÇ) (D.f i‚ÇÇ i‚ÇÅ))","decl":"/-- The 1-hypercover of `D.glued` in the big Zariski site that is given by the\nopen cover `D.U` from the glue data `D`.\nThe \"covering of the intersection of two such open subsets\" is the trivial\ncovering given by `D.V`. -/\n@[simps]\nnoncomputable def oneHypercover : Scheme.zariskiTopology.OneHypercover D.glued where\n  I‚ÇÄ := D.J\n  X := D.U\n  f := D.Œπ\n  I‚ÇÅ _ _ := PUnit\n  Y i‚ÇÅ i‚ÇÇ _ := D.V (i‚ÇÅ, i‚ÇÇ)\n  p‚ÇÅ i‚ÇÅ i‚ÇÇ _ := D.f i‚ÇÅ i‚ÇÇ\n  p‚ÇÇ i‚ÇÅ i‚ÇÇ _ := D.t i‚ÇÅ i‚ÇÇ ‚â´ D.f i‚ÇÇ i‚ÇÅ\n  w i‚ÇÅ i‚ÇÇ _ := by simp only [Category.assoc, Scheme.GlueData.glue_condition]\n  mem‚ÇÄ := by\n    refine zariskiTopology.superset_covering ?_ (grothendieckTopology_cover D.openCover)\n    rw [Sieve.generate_le_iff]\n    rintro W _ ‚ü®i‚ü©\n    exact ‚ü®_, ùüô _, _, ‚ü®i‚ü©, by simp; rfl‚ü©\n  mem‚ÇÅ i‚ÇÅ i‚ÇÇ W p‚ÇÅ p‚ÇÇ fac := by\n    refine zariskiTopology.superset_covering (fun T g _ ‚Ü¶ ?_) (zariskiTopology.top_mem _)\n    have ‚ü®œÜ, h‚ÇÅ, h‚ÇÇ‚ü© := PullbackCone.IsLimit.lift' (D.vPullbackConeIsLimit i‚ÇÅ i‚ÇÇ)\n      (g ‚â´ p‚ÇÅ) (g ‚â´ p‚ÇÇ) (by simpa using g ‚â´= fac)\n    exact ‚ü®‚ü®‚ü©, œÜ, h‚ÇÅ.symm, h‚ÇÇ.symm‚ü©\n\n"}
{"name":"AlgebraicGeometry.Scheme.GlueData.oneHypercover_p‚ÇÅ","module":"Mathlib.AlgebraicGeometry.GluingOneHypercover","initialProofState":"D : AlgebraicGeometry.Scheme.GlueData\ni‚ÇÅ i‚ÇÇ : D.J\nx‚úù : PUnit.{u + 1}\n‚ä¢ Eq (D.oneHypercover.p‚ÇÅ x‚úù) (D.f i‚ÇÅ i‚ÇÇ)","decl":"/-- The 1-hypercover of `D.glued` in the big Zariski site that is given by the\nopen cover `D.U` from the glue data `D`.\nThe \"covering of the intersection of two such open subsets\" is the trivial\ncovering given by `D.V`. -/\n@[simps]\nnoncomputable def oneHypercover : Scheme.zariskiTopology.OneHypercover D.glued where\n  I‚ÇÄ := D.J\n  X := D.U\n  f := D.Œπ\n  I‚ÇÅ _ _ := PUnit\n  Y i‚ÇÅ i‚ÇÇ _ := D.V (i‚ÇÅ, i‚ÇÇ)\n  p‚ÇÅ i‚ÇÅ i‚ÇÇ _ := D.f i‚ÇÅ i‚ÇÇ\n  p‚ÇÇ i‚ÇÅ i‚ÇÇ _ := D.t i‚ÇÅ i‚ÇÇ ‚â´ D.f i‚ÇÇ i‚ÇÅ\n  w i‚ÇÅ i‚ÇÇ _ := by simp only [Category.assoc, Scheme.GlueData.glue_condition]\n  mem‚ÇÄ := by\n    refine zariskiTopology.superset_covering ?_ (grothendieckTopology_cover D.openCover)\n    rw [Sieve.generate_le_iff]\n    rintro W _ ‚ü®i‚ü©\n    exact ‚ü®_, ùüô _, _, ‚ü®i‚ü©, by simp; rfl‚ü©\n  mem‚ÇÅ i‚ÇÅ i‚ÇÇ W p‚ÇÅ p‚ÇÇ fac := by\n    refine zariskiTopology.superset_covering (fun T g _ ‚Ü¶ ?_) (zariskiTopology.top_mem _)\n    have ‚ü®œÜ, h‚ÇÅ, h‚ÇÇ‚ü© := PullbackCone.IsLimit.lift' (D.vPullbackConeIsLimit i‚ÇÅ i‚ÇÇ)\n      (g ‚â´ p‚ÇÅ) (g ‚â´ p‚ÇÇ) (by simpa using g ‚â´= fac)\n    exact ‚ü®‚ü®‚ü©, œÜ, h‚ÇÅ.symm, h‚ÇÇ.symm‚ü©\n\n"}
{"name":"AlgebraicGeometry.Scheme.GlueData.oneHypercover_I‚ÇÄ","module":"Mathlib.AlgebraicGeometry.GluingOneHypercover","initialProofState":"D : AlgebraicGeometry.Scheme.GlueData\n‚ä¢ Eq D.oneHypercover.I‚ÇÄ D.J","decl":"/-- The 1-hypercover of `D.glued` in the big Zariski site that is given by the\nopen cover `D.U` from the glue data `D`.\nThe \"covering of the intersection of two such open subsets\" is the trivial\ncovering given by `D.V`. -/\n@[simps]\nnoncomputable def oneHypercover : Scheme.zariskiTopology.OneHypercover D.glued where\n  I‚ÇÄ := D.J\n  X := D.U\n  f := D.Œπ\n  I‚ÇÅ _ _ := PUnit\n  Y i‚ÇÅ i‚ÇÇ _ := D.V (i‚ÇÅ, i‚ÇÇ)\n  p‚ÇÅ i‚ÇÅ i‚ÇÇ _ := D.f i‚ÇÅ i‚ÇÇ\n  p‚ÇÇ i‚ÇÅ i‚ÇÇ _ := D.t i‚ÇÅ i‚ÇÇ ‚â´ D.f i‚ÇÇ i‚ÇÅ\n  w i‚ÇÅ i‚ÇÇ _ := by simp only [Category.assoc, Scheme.GlueData.glue_condition]\n  mem‚ÇÄ := by\n    refine zariskiTopology.superset_covering ?_ (grothendieckTopology_cover D.openCover)\n    rw [Sieve.generate_le_iff]\n    rintro W _ ‚ü®i‚ü©\n    exact ‚ü®_, ùüô _, _, ‚ü®i‚ü©, by simp; rfl‚ü©\n  mem‚ÇÅ i‚ÇÅ i‚ÇÇ W p‚ÇÅ p‚ÇÇ fac := by\n    refine zariskiTopology.superset_covering (fun T g _ ‚Ü¶ ?_) (zariskiTopology.top_mem _)\n    have ‚ü®œÜ, h‚ÇÅ, h‚ÇÇ‚ü© := PullbackCone.IsLimit.lift' (D.vPullbackConeIsLimit i‚ÇÅ i‚ÇÇ)\n      (g ‚â´ p‚ÇÅ) (g ‚â´ p‚ÇÇ) (by simpa using g ‚â´= fac)\n    exact ‚ü®‚ü®‚ü©, œÜ, h‚ÇÅ.symm, h‚ÇÇ.symm‚ü©\n\n"}
{"name":"AlgebraicGeometry.Scheme.GlueData.sheafValGluedMk_val","module":"Mathlib.AlgebraicGeometry.GluingOneHypercover","initialProofState":"D : AlgebraicGeometry.Scheme.GlueData\nF : CategoryTheory.Sheaf AlgebraicGeometry.Scheme.zariskiTopology (Type v)\ns : (j : D.J) ‚Üí F.val.obj { unop := D.U j }\nh : ‚àÄ (i j : D.J), Eq (F.val.map (D.f i j).op (s i)) (F.val.map (CategoryTheory.CategoryStruct.comp (D.f j i).op (D.t i j).op) (s j))\nj : D.J\n‚ä¢ Eq (F.val.map (D.Œπ j).op (D.sheafValGluedMk s h)) (s j)","decl":"@[simp]\nlemma sheafValGluedMk_val (j : D.J) : F.val.map (D.Œπ j).op (D.sheafValGluedMk s h) = s j :=\n  Multifork.IsLimit.sectionsEquiv_apply_val (D.oneHypercover.isLimitMultifork F) _ _\n\n"}
