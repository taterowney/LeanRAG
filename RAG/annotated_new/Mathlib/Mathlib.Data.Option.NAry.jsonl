{"name":"Option.map₂_def","module":"Mathlib.Data.Option.NAry","initialProofState":"α β γ : Type u\nf : α → β → γ\na : Option α\nb : Option β\n⊢ Eq (Option.map₂ f a b) (Seq.seq (Functor.map f a) fun x => b)","decl":"/-- `Option.map₂` in terms of monadic operations. Note that this can't be taken as the definition\nbecause of the lack of universe polymorphism. -/\ntheorem map₂_def {α β γ : Type u} (f : α → β → γ) (a : Option α) (b : Option β) :\n    map₂ f a b = f <$> a <*> b := by\n  cases a <;> rfl\n\n"}
{"name":"Option.map₂_some_some","module":"Mathlib.Data.Option.NAry","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nf : α → β → γ\na : α\nb : β\n⊢ Eq (Option.map₂ f (Option.some a) (Option.some b)) (Option.some (f a b))","decl":"@[simp]\ntheorem map₂_some_some (f : α → β → γ) (a : α) (b : β) : map₂ f (some a) (some b) = f a b := rfl\n\n"}
{"name":"Option.map₂_coe_coe","module":"Mathlib.Data.Option.NAry","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nf : α → β → γ\na : α\nb : β\n⊢ Eq (Option.map₂ f (Option.some a) (Option.some b)) (Option.some (f a b))","decl":"theorem map₂_coe_coe (f : α → β → γ) (a : α) (b : β) : map₂ f a b = f a b := rfl\n\n"}
{"name":"Option.map₂_none_left","module":"Mathlib.Data.Option.NAry","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nf : α → β → γ\nb : Option β\n⊢ Eq (Option.map₂ f Option.none b) Option.none","decl":"@[simp]\ntheorem map₂_none_left (f : α → β → γ) (b : Option β) : map₂ f none b = none := rfl\n\n"}
{"name":"Option.map₂_none_right","module":"Mathlib.Data.Option.NAry","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nf : α → β → γ\na : Option α\n⊢ Eq (Option.map₂ f a Option.none) Option.none","decl":"@[simp]\ntheorem map₂_none_right (f : α → β → γ) (a : Option α) : map₂ f a none = none := by cases a <;> rfl\n\n"}
{"name":"Option.map₂_coe_left","module":"Mathlib.Data.Option.NAry","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nf : α → β → γ\na : α\nb : Option β\n⊢ Eq (Option.map₂ f (Option.some a) b) (Option.map (fun b => f a b) b)","decl":"@[simp]\ntheorem map₂_coe_left (f : α → β → γ) (a : α) (b : Option β) : map₂ f a b = b.map fun b => f a b :=\n  rfl\n\n-- Porting note: This proof was `rfl` in Lean3, but now is not.\n"}
{"name":"Option.map₂_coe_right","module":"Mathlib.Data.Option.NAry","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nf : α → β → γ\na : Option α\nb : β\n⊢ Eq (Option.map₂ f a (Option.some b)) (Option.map (fun a => f a b) a)","decl":"@[simp]\ntheorem map₂_coe_right (f : α → β → γ) (a : Option α) (b : β) :\n    map₂ f a b = a.map fun a => f a b := by cases a <;> rfl\n\n-- Porting note: Removed the `@[simp]` tag as membership of an `Option` is no-longer simp-normal.\n"}
{"name":"Option.mem_map₂_iff","module":"Mathlib.Data.Option.NAry","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nf : α → β → γ\na : Option α\nb : Option β\nc : γ\n⊢ Iff (Membership.mem (Option.map₂ f a b) c) (Exists fun a' => Exists fun b' => And (Membership.mem a a') (And (Membership.mem b b') (Eq (f a' b') c)))","decl":"theorem mem_map₂_iff {c : γ} : c ∈ map₂ f a b ↔ ∃ a' b', a' ∈ a ∧ b' ∈ b ∧ f a' b' = c := by\n  simp [map₂, bind_eq_some]\n\n"}
{"name":"Option.map₂_eq_none_iff","module":"Mathlib.Data.Option.NAry","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nf : α → β → γ\na : Option α\nb : Option β\n⊢ Iff (Eq (Option.map₂ f a b) Option.none) (Or (Eq a Option.none) (Eq b Option.none))","decl":"@[simp]\ntheorem map₂_eq_none_iff : map₂ f a b = none ↔ a = none ∨ b = none := by\n  cases a <;> cases b <;> simp\n\n"}
{"name":"Option.map₂_swap","module":"Mathlib.Data.Option.NAry","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nf : α → β → γ\na : Option α\nb : Option β\n⊢ Eq (Option.map₂ f a b) (Option.map₂ (fun a b => f b a) b a)","decl":"theorem map₂_swap (f : α → β → γ) (a : Option α) (b : Option β) :\n    map₂ f a b = map₂ (fun a b => f b a) b a := by cases a <;> cases b <;> rfl\n\n"}
{"name":"Option.map_map₂","module":"Mathlib.Data.Option.NAry","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nδ : Type u_4\na : Option α\nb : Option β\nf : α → β → γ\ng : γ → δ\n⊢ Eq (Option.map g (Option.map₂ f a b)) (Option.map₂ (fun a b => g (f a b)) a b)","decl":"theorem map_map₂ (f : α → β → γ) (g : γ → δ) :\n    (map₂ f a b).map g = map₂ (fun a b => g (f a b)) a b := by cases a <;> cases b <;> rfl\n\n"}
{"name":"Option.map₂_map_left","module":"Mathlib.Data.Option.NAry","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nδ : Type u_4\na : Option α\nb : Option β\nf : γ → β → δ\ng : α → γ\n⊢ Eq (Option.map₂ f (Option.map g a) b) (Option.map₂ (fun a b => f (g a) b) a b)","decl":"theorem map₂_map_left (f : γ → β → δ) (g : α → γ) :\n    map₂ f (a.map g) b = map₂ (fun a b => f (g a) b) a b := by cases a <;> rfl\n\n"}
{"name":"Option.map₂_map_right","module":"Mathlib.Data.Option.NAry","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nδ : Type u_4\na : Option α\nb : Option β\nf : α → γ → δ\ng : β → γ\n⊢ Eq (Option.map₂ f a (Option.map g b)) (Option.map₂ (fun a b => f a (g b)) a b)","decl":"theorem map₂_map_right (f : α → γ → δ) (g : β → γ) :\n    map₂ f a (b.map g) = map₂ (fun a b => f a (g b)) a b := by cases b <;> rfl\n\n"}
{"name":"Option.map₂_curry","module":"Mathlib.Data.Option.NAry","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nf : Prod α β → γ\na : Option α\nb : Option β\n⊢ Eq (Option.map₂ (Function.curry f) a b) (Option.map f (Option.map₂ Prod.mk a b))","decl":"@[simp]\ntheorem map₂_curry (f : α × β → γ) (a : Option α) (b : Option β) :\n    map₂ (curry f) a b = Option.map f (map₂ Prod.mk a b) := (map_map₂ _ _).symm\n\n"}
{"name":"Option.map_uncurry","module":"Mathlib.Data.Option.NAry","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nf : α → β → γ\nx : Option (Prod α β)\n⊢ Eq (Option.map (Function.uncurry f) x) (Option.map₂ f (Option.map Prod.fst x) (Option.map Prod.snd x))","decl":"@[simp]\ntheorem map_uncurry (f : α → β → γ) (x : Option (α × β)) :\n    x.map (uncurry f) = map₂ f (x.map Prod.fst) (x.map Prod.snd) := by cases x <;> rfl\n\n"}
{"name":"Option.map₂_assoc","module":"Mathlib.Data.Option.NAry","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nδ : Type u_4\na : Option α\nb : Option β\nc : Option γ\nε : Type u_8\nε' : Type u_9\nf : δ → γ → ε\ng : α → β → δ\nf' : α → ε' → ε\ng' : β → γ → ε'\nh_assoc : ∀ (a : α) (b : β) (c : γ), Eq (f (g a b) c) (f' a (g' b c))\n⊢ Eq (Option.map₂ f (Option.map₂ g a b) c) (Option.map₂ f' a (Option.map₂ g' b c))","decl":"theorem map₂_assoc {f : δ → γ → ε} {g : α → β → δ} {f' : α → ε' → ε} {g' : β → γ → ε'}\n    (h_assoc : ∀ a b c, f (g a b) c = f' a (g' b c)) :\n    map₂ f (map₂ g a b) c = map₂ f' a (map₂ g' b c) := by\n  cases a <;> cases b <;> cases c <;> simp [h_assoc]\n\n"}
{"name":"Option.map₂_comm","module":"Mathlib.Data.Option.NAry","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nf : α → β → γ\na : Option α\nb : Option β\ng : β → α → γ\nh_comm : ∀ (a : α) (b : β), Eq (f a b) (g b a)\n⊢ Eq (Option.map₂ f a b) (Option.map₂ g b a)","decl":"theorem map₂_comm {g : β → α → γ} (h_comm : ∀ a b, f a b = g b a) : map₂ f a b = map₂ g b a := by\n  cases a <;> cases b <;> simp [h_comm]\n\n"}
{"name":"Option.map₂_left_comm","module":"Mathlib.Data.Option.NAry","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nδ : Type u_4\na : Option α\nb : Option β\nc : Option γ\nδ' : Type u_7\nε : Type u_8\nf : α → δ → ε\ng : β → γ → δ\nf' : α → γ → δ'\ng' : β → δ' → ε\nh_left_comm : ∀ (a : α) (b : β) (c : γ), Eq (f a (g b c)) (g' b (f' a c))\n⊢ Eq (Option.map₂ f a (Option.map₂ g b c)) (Option.map₂ g' b (Option.map₂ f' a c))","decl":"theorem map₂_left_comm {f : α → δ → ε} {g : β → γ → δ} {f' : α → γ → δ'} {g' : β → δ' → ε}\n    (h_left_comm : ∀ a b c, f a (g b c) = g' b (f' a c)) :\n    map₂ f a (map₂ g b c) = map₂ g' b (map₂ f' a c) := by\n  cases a <;> cases b <;> cases c <;> simp [h_left_comm]\n\n"}
{"name":"Option.map₂_right_comm","module":"Mathlib.Data.Option.NAry","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nδ : Type u_4\na : Option α\nb : Option β\nc : Option γ\nδ' : Type u_7\nε : Type u_8\nf : δ → γ → ε\ng : α → β → δ\nf' : α → γ → δ'\ng' : δ' → β → ε\nh_right_comm : ∀ (a : α) (b : β) (c : γ), Eq (f (g a b) c) (g' (f' a c) b)\n⊢ Eq (Option.map₂ f (Option.map₂ g a b) c) (Option.map₂ g' (Option.map₂ f' a c) b)","decl":"theorem map₂_right_comm {f : δ → γ → ε} {g : α → β → δ} {f' : α → γ → δ'} {g' : δ' → β → ε}\n    (h_right_comm : ∀ a b c, f (g a b) c = g' (f' a c) b) :\n    map₂ f (map₂ g a b) c = map₂ g' (map₂ f' a c) b := by\n  cases a <;> cases b <;> cases c <;> simp [h_right_comm]\n\n"}
{"name":"Option.map_map₂_distrib","module":"Mathlib.Data.Option.NAry","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nδ : Type u_4\nf : α → β → γ\na : Option α\nb : Option β\nα' : Type u_5\nβ' : Type u_6\ng : γ → δ\nf' : α' → β' → δ\ng₁ : α → α'\ng₂ : β → β'\nh_distrib : ∀ (a : α) (b : β), Eq (g (f a b)) (f' (g₁ a) (g₂ b))\n⊢ Eq (Option.map g (Option.map₂ f a b)) (Option.map₂ f' (Option.map g₁ a) (Option.map g₂ b))","decl":"theorem map_map₂_distrib {g : γ → δ} {f' : α' → β' → δ} {g₁ : α → α'} {g₂ : β → β'}\n    (h_distrib : ∀ a b, g (f a b) = f' (g₁ a) (g₂ b)) :\n    (map₂ f a b).map g = map₂ f' (a.map g₁) (b.map g₂) := by\n  cases a <;> cases b <;> simp [h_distrib]\n\n"}
{"name":"Option.map_map₂_distrib_left","module":"Mathlib.Data.Option.NAry","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nδ : Type u_4\nf : α → β → γ\na : Option α\nb : Option β\nα' : Type u_5\ng : γ → δ\nf' : α' → β → δ\ng' : α → α'\nh_distrib : ∀ (a : α) (b : β), Eq (g (f a b)) (f' (g' a) b)\n⊢ Eq (Option.map g (Option.map₂ f a b)) (Option.map₂ f' (Option.map g' a) b)","decl":"/-- Symmetric statement to `Option.map₂_map_left_comm`. -/\ntheorem map_map₂_distrib_left {g : γ → δ} {f' : α' → β → δ} {g' : α → α'}\n    (h_distrib : ∀ a b, g (f a b) = f' (g' a) b) :\n    (map₂ f a b).map g = map₂ f' (a.map g') b := by cases a <;> cases b <;> simp [h_distrib]\n\n"}
{"name":"Option.map_map₂_distrib_right","module":"Mathlib.Data.Option.NAry","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nδ : Type u_4\nf : α → β → γ\na : Option α\nb : Option β\nβ' : Type u_6\ng : γ → δ\nf' : α → β' → δ\ng' : β → β'\nh_distrib : ∀ (a : α) (b : β), Eq (g (f a b)) (f' a (g' b))\n⊢ Eq (Option.map g (Option.map₂ f a b)) (Option.map₂ f' a (Option.map g' b))","decl":"/-- Symmetric statement to `Option.map_map₂_right_comm`. -/\ntheorem map_map₂_distrib_right {g : γ → δ} {f' : α → β' → δ} {g' : β → β'}\n    (h_distrib : ∀ a b, g (f a b) = f' a (g' b)) : (map₂ f a b).map g = map₂ f' a (b.map g') := by\n  cases a <;> cases b <;> simp [h_distrib]\n\n"}
{"name":"Option.map₂_map_left_comm","module":"Mathlib.Data.Option.NAry","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nδ : Type u_4\na : Option α\nb : Option β\nα' : Type u_5\nf : α' → β → γ\ng : α → α'\nf' : α → β → δ\ng' : δ → γ\nh_left_comm : ∀ (a : α) (b : β), Eq (f (g a) b) (g' (f' a b))\n⊢ Eq (Option.map₂ f (Option.map g a) b) (Option.map g' (Option.map₂ f' a b))","decl":"/-- Symmetric statement to `Option.map_map₂_distrib_left`. -/\ntheorem map₂_map_left_comm {f : α' → β → γ} {g : α → α'} {f' : α → β → δ} {g' : δ → γ}\n    (h_left_comm : ∀ a b, f (g a) b = g' (f' a b)) : map₂ f (a.map g) b = (map₂ f' a b).map g' := by\n  cases a <;> cases b <;> simp [h_left_comm]\n\n"}
{"name":"Option.map_map₂_right_comm","module":"Mathlib.Data.Option.NAry","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nδ : Type u_4\na : Option α\nb : Option β\nβ' : Type u_6\nf : α → β' → γ\ng : β → β'\nf' : α → β → δ\ng' : δ → γ\nh_right_comm : ∀ (a : α) (b : β), Eq (f a (g b)) (g' (f' a b))\n⊢ Eq (Option.map₂ f a (Option.map g b)) (Option.map g' (Option.map₂ f' a b))","decl":"/-- Symmetric statement to `Option.map_map₂_distrib_right`. -/\ntheorem map_map₂_right_comm {f : α → β' → γ} {g : β → β'} {f' : α → β → δ} {g' : δ → γ}\n    (h_right_comm : ∀ a b, f a (g b) = g' (f' a b)) :\n    map₂ f a (b.map g) = (map₂ f' a b).map g' := by cases a <;> cases b <;> simp [h_right_comm]\n\n"}
{"name":"Option.map_map₂_antidistrib","module":"Mathlib.Data.Option.NAry","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nδ : Type u_4\nf : α → β → γ\na : Option α\nb : Option β\nα' : Type u_5\nβ' : Type u_6\ng : γ → δ\nf' : β' → α' → δ\ng₁ : β → β'\ng₂ : α → α'\nh_antidistrib : ∀ (a : α) (b : β), Eq (g (f a b)) (f' (g₁ b) (g₂ a))\n⊢ Eq (Option.map g (Option.map₂ f a b)) (Option.map₂ f' (Option.map g₁ b) (Option.map g₂ a))","decl":"theorem map_map₂_antidistrib {g : γ → δ} {f' : β' → α' → δ} {g₁ : β → β'} {g₂ : α → α'}\n    (h_antidistrib : ∀ a b, g (f a b) = f' (g₁ b) (g₂ a)) :\n    (map₂ f a b).map g = map₂ f' (b.map g₁) (a.map g₂) := by\n  cases a <;> cases b <;> simp [h_antidistrib]\n\n"}
{"name":"Option.map_map₂_antidistrib_left","module":"Mathlib.Data.Option.NAry","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nδ : Type u_4\nf : α → β → γ\na : Option α\nb : Option β\nβ' : Type u_6\ng : γ → δ\nf' : β' → α → δ\ng' : β → β'\nh_antidistrib : ∀ (a : α) (b : β), Eq (g (f a b)) (f' (g' b) a)\n⊢ Eq (Option.map g (Option.map₂ f a b)) (Option.map₂ f' (Option.map g' b) a)","decl":"/-- Symmetric statement to `Option.map₂_map_left_anticomm`. -/\ntheorem map_map₂_antidistrib_left {g : γ → δ} {f' : β' → α → δ} {g' : β → β'}\n    (h_antidistrib : ∀ a b, g (f a b) = f' (g' b) a) :\n    (map₂ f a b).map g = map₂ f' (b.map g') a := by\n  cases a <;> cases b <;> simp [h_antidistrib]\n\n"}
{"name":"Option.map_map₂_antidistrib_right","module":"Mathlib.Data.Option.NAry","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nδ : Type u_4\nf : α → β → γ\na : Option α\nb : Option β\nα' : Type u_5\ng : γ → δ\nf' : β → α' → δ\ng' : α → α'\nh_antidistrib : ∀ (a : α) (b : β), Eq (g (f a b)) (f' b (g' a))\n⊢ Eq (Option.map g (Option.map₂ f a b)) (Option.map₂ f' b (Option.map g' a))","decl":"/-- Symmetric statement to `Option.map_map₂_right_anticomm`. -/\ntheorem map_map₂_antidistrib_right {g : γ → δ} {f' : β → α' → δ} {g' : α → α'}\n    (h_antidistrib : ∀ a b, g (f a b) = f' b (g' a)) :\n    (map₂ f a b).map g = map₂ f' b (a.map g') := by cases a <;> cases b <;> simp [h_antidistrib]\n\n"}
{"name":"Option.map₂_map_left_anticomm","module":"Mathlib.Data.Option.NAry","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nδ : Type u_4\na : Option α\nb : Option β\nα' : Type u_5\nf : α' → β → γ\ng : α → α'\nf' : β → α → δ\ng' : δ → γ\nh_left_anticomm : ∀ (a : α) (b : β), Eq (f (g a) b) (g' (f' b a))\n⊢ Eq (Option.map₂ f (Option.map g a) b) (Option.map g' (Option.map₂ f' b a))","decl":"/-- Symmetric statement to `Option.map_map₂_antidistrib_left`. -/\ntheorem map₂_map_left_anticomm {f : α' → β → γ} {g : α → α'} {f' : β → α → δ} {g' : δ → γ}\n    (h_left_anticomm : ∀ a b, f (g a) b = g' (f' b a)) :\n    map₂ f (a.map g) b = (map₂ f' b a).map g' := by cases a <;> cases b <;> simp [h_left_anticomm]\n\n"}
{"name":"Option.map_map₂_right_anticomm","module":"Mathlib.Data.Option.NAry","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nδ : Type u_4\na : Option α\nb : Option β\nβ' : Type u_6\nf : α → β' → γ\ng : β → β'\nf' : β → α → δ\ng' : δ → γ\nh_right_anticomm : ∀ (a : α) (b : β), Eq (f a (g b)) (g' (f' b a))\n⊢ Eq (Option.map₂ f a (Option.map g b)) (Option.map g' (Option.map₂ f' b a))","decl":"/-- Symmetric statement to `Option.map_map₂_antidistrib_right`. -/\ntheorem map_map₂_right_anticomm {f : α → β' → γ} {g : β → β'} {f' : β → α → δ} {g' : δ → γ}\n    (h_right_anticomm : ∀ a b, f a (g b) = g' (f' b a)) :\n    map₂ f a (b.map g) = (map₂ f' b a).map g' := by cases a <;> cases b <;> simp [h_right_anticomm]\n\n"}
{"name":"Option.map₂_left_identity","module":"Mathlib.Data.Option.NAry","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β → β\na : α\nh : ∀ (b : β), Eq (f a b) b\no : Option β\n⊢ Eq (Option.map₂ f (Option.some a) o) o","decl":"/-- If `a` is a left identity for a binary operation `f`, then `some a` is a left identity for\n`Option.map₂ f`. -/\nlemma map₂_left_identity {f : α → β → β} {a : α} (h : ∀ b, f a b = b) (o : Option β) :\n    map₂ f (some a) o = o := by\n  cases o; exacts [rfl, congr_arg some (h _)]\n\n"}
{"name":"Option.map₂_right_identity","module":"Mathlib.Data.Option.NAry","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β → α\nb : β\nh : ∀ (a : α), Eq (f a b) a\no : Option α\n⊢ Eq (Option.map₂ f o (Option.some b)) o","decl":"/-- If `b` is a right identity for a binary operation `f`, then `some b` is a right identity for\n`Option.map₂ f`. -/\nlemma map₂_right_identity {f : α → β → α} {b : β} (h : ∀ a, f a b = a) (o : Option α) :\n    map₂ f o (some b) = o := by\n  simp [h, map₂]\n\n"}
