{"name":"isPeriodicPt_mul_iff_pow_eq_one","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝ : Monoid G\nn : Nat\nx : G\n⊢ Iff (Function.IsPeriodicPt (fun x_1 => HMul.hMul x x_1) n 1) (Eq (HPow.hPow x n) 1)","decl":"@[to_additive]\ntheorem isPeriodicPt_mul_iff_pow_eq_one (x : G) : IsPeriodicPt (x * ·) n 1 ↔ x ^ n = 1 := by\n  rw [IsPeriodicPt, IsFixedPt, mul_left_iterate]; beta_reduce; rw [mul_one]\n\n"}
{"name":"isPeriodicPt_add_iff_nsmul_eq_zero","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝ : AddMonoid G\nn : Nat\nx : G\n⊢ Iff (Function.IsPeriodicPt (fun x_1 => HAdd.hAdd x x_1) n 0) (Eq (HSMul.hSMul n x) 0)","decl":"@[to_additive]\ntheorem isPeriodicPt_mul_iff_pow_eq_one (x : G) : IsPeriodicPt (x * ·) n 1 ↔ x ^ n = 1 := by\n  rw [IsPeriodicPt, IsFixedPt, mul_left_iterate]; beta_reduce; rw [mul_one]\n\n"}
{"name":"isOfFinAddOrder_ofMul_iff","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝ : Monoid G\nx : G\n⊢ Iff (IsOfFinAddOrder (Additive.ofMul x)) (IsOfFinOrder x)","decl":"theorem isOfFinAddOrder_ofMul_iff : IsOfFinAddOrder (Additive.ofMul x) ↔ IsOfFinOrder x :=\n  Iff.rfl\n\n"}
{"name":"isOfFinOrder_ofAdd_iff","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"α : Type u_6\ninst✝ : AddMonoid α\nx : α\n⊢ Iff (IsOfFinOrder (Multiplicative.ofAdd x)) (IsOfFinAddOrder x)","decl":"theorem isOfFinOrder_ofAdd_iff {α : Type*} [AddMonoid α] {x : α} :\n    IsOfFinOrder (Multiplicative.ofAdd x) ↔ IsOfFinAddOrder x := Iff.rfl\n\n"}
{"name":"isOfFinOrder_iff_pow_eq_one","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝ : Monoid G\nx : G\n⊢ Iff (IsOfFinOrder x) (Exists fun n => And (LT.lt 0 n) (Eq (HPow.hPow x n) 1))","decl":"@[to_additive]\ntheorem isOfFinOrder_iff_pow_eq_one : IsOfFinOrder x ↔ ∃ n, 0 < n ∧ x ^ n = 1 := by\n  simp [IsOfFinOrder, mem_periodicPts, isPeriodicPt_mul_iff_pow_eq_one]\n\n"}
{"name":"isOfFinAddOrder_iff_nsmul_eq_zero","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝ : AddMonoid G\nx : G\n⊢ Iff (IsOfFinAddOrder x) (Exists fun n => And (LT.lt 0 n) (Eq (HSMul.hSMul n x) 0))","decl":"@[to_additive]\ntheorem isOfFinOrder_iff_pow_eq_one : IsOfFinOrder x ↔ ∃ n, 0 < n ∧ x ^ n = 1 := by\n  simp [IsOfFinOrder, mem_periodicPts, isPeriodicPt_mul_iff_pow_eq_one]\n\n"}
{"name":"IsOfFinAddOrder.exists_nsmul_eq_zero","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝ : AddMonoid G\nx : G\na✝ : IsOfFinAddOrder x\n⊢ Exists fun n => And (LT.lt 0 n) (Eq (HSMul.hSMul n x) 0)","decl":"@[to_additive] alias ⟨IsOfFinOrder.exists_pow_eq_one, _⟩ := isOfFinOrder_iff_pow_eq_one\n\n"}
{"name":"IsOfFinOrder.exists_pow_eq_one","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝ : Monoid G\nx : G\na✝ : IsOfFinOrder x\n⊢ Exists fun n => And (LT.lt 0 n) (Eq (HPow.hPow x n) 1)","decl":"@[to_additive] alias ⟨IsOfFinOrder.exists_pow_eq_one, _⟩ := isOfFinOrder_iff_pow_eq_one\n\n"}
{"name":"isOfFinAddOrder_iff_zsmul_eq_zero","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_6\ninst✝ : AddGroup G\nx : G\n⊢ Iff (IsOfFinAddOrder x) (Exists fun n => And (Ne n 0) (Eq (HSMul.hSMul n x) 0))","decl":"@[to_additive]\nlemma isOfFinOrder_iff_zpow_eq_one {G} [Group G] {x : G} :\n    IsOfFinOrder x ↔ ∃ (n : ℤ), n ≠ 0 ∧ x ^ n = 1 := by\n  rw [isOfFinOrder_iff_pow_eq_one]\n  refine ⟨fun ⟨n, hn, hn'⟩ ↦ ⟨n, Int.natCast_ne_zero_iff_pos.mpr hn, zpow_natCast x n ▸ hn'⟩,\n    fun ⟨n, hn, hn'⟩ ↦ ⟨n.natAbs, Int.natAbs_pos.mpr hn, ?_⟩⟩\n  cases' (Int.natAbs_eq_iff (a := n)).mp rfl with h h\n  · rwa [h, zpow_natCast] at hn'\n  · rwa [h, zpow_neg, inv_eq_one, zpow_natCast] at hn'\n\n"}
{"name":"isOfFinOrder_iff_zpow_eq_one","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_6\ninst✝ : Group G\nx : G\n⊢ Iff (IsOfFinOrder x) (Exists fun n => And (Ne n 0) (Eq (HPow.hPow x n) 1))","decl":"@[to_additive]\nlemma isOfFinOrder_iff_zpow_eq_one {G} [Group G] {x : G} :\n    IsOfFinOrder x ↔ ∃ (n : ℤ), n ≠ 0 ∧ x ^ n = 1 := by\n  rw [isOfFinOrder_iff_pow_eq_one]\n  refine ⟨fun ⟨n, hn, hn'⟩ ↦ ⟨n, Int.natCast_ne_zero_iff_pos.mpr hn, zpow_natCast x n ▸ hn'⟩,\n    fun ⟨n, hn, hn'⟩ ↦ ⟨n.natAbs, Int.natAbs_pos.mpr hn, ?_⟩⟩\n  cases' (Int.natAbs_eq_iff (a := n)).mp rfl with h h\n  · rwa [h, zpow_natCast] at hn'\n  · rwa [h, zpow_neg, inv_eq_one, zpow_natCast] at hn'\n\n"}
{"name":"not_isOfFinAddOrder_of_injective_nsmul","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝ : AddMonoid G\nx : G\nh : Function.Injective fun n => HSMul.hSMul n x\n⊢ Not (IsOfFinAddOrder x)","decl":"/-- See also `injective_pow_iff_not_isOfFinOrder`. -/\n@[to_additive \"See also `injective_nsmul_iff_not_isOfFinAddOrder`.\"]\ntheorem not_isOfFinOrder_of_injective_pow {x : G} (h : Injective fun n : ℕ => x ^ n) :\n    ¬IsOfFinOrder x := by\n  simp_rw [isOfFinOrder_iff_pow_eq_one, not_exists, not_and]\n  intro n hn_pos hnx\n  rw [← pow_zero x] at hnx\n  rw [h hnx] at hn_pos\n  exact irrefl 0 hn_pos\n\n"}
{"name":"not_isOfFinOrder_of_injective_pow","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝ : Monoid G\nx : G\nh : Function.Injective fun n => HPow.hPow x n\n⊢ Not (IsOfFinOrder x)","decl":"/-- See also `injective_pow_iff_not_isOfFinOrder`. -/\n@[to_additive \"See also `injective_nsmul_iff_not_isOfFinAddOrder`.\"]\ntheorem not_isOfFinOrder_of_injective_pow {x : G} (h : Injective fun n : ℕ => x ^ n) :\n    ¬IsOfFinOrder x := by\n  simp_rw [isOfFinOrder_iff_pow_eq_one, not_exists, not_and]\n  intro n hn_pos hnx\n  rw [← pow_zero x] at hnx\n  rw [h hnx] at hn_pos\n  exact irrefl 0 hn_pos\n\n"}
{"name":"IsOfFinOrder.one","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝ : Monoid G\n⊢ IsOfFinOrder 1","decl":"/-- 1 is of finite order in any monoid. -/\n@[to_additive (attr := simp) \"0 is of finite order in any additive monoid.\"]\ntheorem IsOfFinOrder.one : IsOfFinOrder (1 : G) :=\n  isOfFinOrder_iff_pow_eq_one.mpr ⟨1, Nat.one_pos, one_pow 1⟩\n\n"}
{"name":"IsOfFinAddOrder.zero","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝ : AddMonoid G\n⊢ IsOfFinAddOrder 0","decl":"/-- 1 is of finite order in any monoid. -/\n@[to_additive (attr := simp) \"0 is of finite order in any additive monoid.\"]\ntheorem IsOfFinOrder.one : IsOfFinOrder (1 : G) :=\n  isOfFinOrder_iff_pow_eq_one.mpr ⟨1, Nat.one_pos, one_pow 1⟩\n\n"}
{"name":"isOfFinAddOrder_zero","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝ : AddMonoid G\n⊢ IsOfFinAddOrder 0","decl":"@[to_additive]\nalias isOfFinOrder_one := IsOfFinOrder.one\n\n-- `alias` doesn't add the deprecation suggestion to the `to_additive` version\n-- see https://github.com/leanprover-community/mathlib4/issues/19424\n"}
{"name":"isOfFinOrder_one","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝ : Monoid G\n⊢ IsOfFinOrder 1","decl":"@[to_additive]\nalias isOfFinOrder_one := IsOfFinOrder.one\n\n-- `alias` doesn't add the deprecation suggestion to the `to_additive` version\n-- see https://github.com/leanprover-community/mathlib4/issues/19424\n"}
{"name":"IsOfFinOrder.pow","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝ : Monoid G\na : G\nn : Nat\na✝ : IsOfFinOrder a\n⊢ IsOfFinOrder (HPow.hPow a n)","decl":"@[to_additive]\nlemma IsOfFinOrder.pow {n : ℕ} : IsOfFinOrder a → IsOfFinOrder (a ^ n) := by\n  simp_rw [isOfFinOrder_iff_pow_eq_one]\n  rintro ⟨m, hm, ha⟩\n  exact ⟨m, hm, by simp [pow_right_comm _ n, ha]⟩\n\n"}
{"name":"IsOfFinAddOrder.nsmul","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝ : AddMonoid G\na : G\nn : Nat\na✝ : IsOfFinAddOrder a\n⊢ IsOfFinAddOrder (HSMul.hSMul n a)","decl":"@[to_additive]\nlemma IsOfFinOrder.pow {n : ℕ} : IsOfFinOrder a → IsOfFinOrder (a ^ n) := by\n  simp_rw [isOfFinOrder_iff_pow_eq_one]\n  rintro ⟨m, hm, ha⟩\n  exact ⟨m, hm, by simp [pow_right_comm _ n, ha]⟩\n\n"}
{"name":"IsOfFinAddOrder.of_nsmul","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝ : AddMonoid G\na : G\nn : Nat\nh : IsOfFinAddOrder (HSMul.hSMul n a)\nhn : Ne n 0\n⊢ IsOfFinAddOrder a","decl":"@[to_additive]\nlemma IsOfFinOrder.of_pow {n : ℕ} (h : IsOfFinOrder (a ^ n)) (hn : n ≠ 0) : IsOfFinOrder a := by\n  rw [isOfFinOrder_iff_pow_eq_one] at *\n  rcases h with ⟨m, hm, ha⟩\n  exact ⟨n * m, by positivity, by rwa [pow_mul]⟩\n\n"}
{"name":"IsOfFinOrder.of_pow","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝ : Monoid G\na : G\nn : Nat\nh : IsOfFinOrder (HPow.hPow a n)\nhn : Ne n 0\n⊢ IsOfFinOrder a","decl":"@[to_additive]\nlemma IsOfFinOrder.of_pow {n : ℕ} (h : IsOfFinOrder (a ^ n)) (hn : n ≠ 0) : IsOfFinOrder a := by\n  rw [isOfFinOrder_iff_pow_eq_one] at *\n  rcases h with ⟨m, hm, ha⟩\n  exact ⟨n * m, by positivity, by rwa [pow_mul]⟩\n\n"}
{"name":"isOfFinAddOrder_nsmul","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝ : AddMonoid G\na : G\nn : Nat\n⊢ Iff (IsOfFinAddOrder (HSMul.hSMul n a)) (Or (IsOfFinAddOrder a) (Eq n 0))","decl":"@[to_additive (attr := simp)]\nlemma isOfFinOrder_pow {n : ℕ} : IsOfFinOrder (a ^ n) ↔ IsOfFinOrder a ∨ n = 0 := by\n  rcases Decidable.eq_or_ne n 0 with rfl | hn\n  · simp\n  · exact ⟨fun h ↦ .inl <| h.of_pow hn, fun h ↦ (h.resolve_right hn).pow⟩\n\n"}
{"name":"isOfFinOrder_pow","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝ : Monoid G\na : G\nn : Nat\n⊢ Iff (IsOfFinOrder (HPow.hPow a n)) (Or (IsOfFinOrder a) (Eq n 0))","decl":"@[to_additive (attr := simp)]\nlemma isOfFinOrder_pow {n : ℕ} : IsOfFinOrder (a ^ n) ↔ IsOfFinOrder a ∨ n = 0 := by\n  rcases Decidable.eq_or_ne n 0 with rfl | hn\n  · simp\n  · exact ⟨fun h ↦ .inl <| h.of_pow hn, fun h ↦ (h.resolve_right hn).pow⟩\n\n"}
{"name":"Submonoid.isOfFinOrder_coe","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝ : Monoid G\nH : Submonoid G\nx : Subtype fun x => Membership.mem H x\n⊢ Iff (IsOfFinOrder ↑x) (IsOfFinOrder x)","decl":"/-- Elements of finite order are of finite order in submonoids. -/\n@[to_additive \"Elements of finite order are of finite order in submonoids.\"]\ntheorem Submonoid.isOfFinOrder_coe {H : Submonoid G} {x : H} :\n    IsOfFinOrder (x : G) ↔ IsOfFinOrder x := by\n  rw [isOfFinOrder_iff_pow_eq_one, isOfFinOrder_iff_pow_eq_one]\n  norm_cast\n\n"}
{"name":"AddSubmonoid.isOfFinAddOrder_coe","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝ : AddMonoid G\nH : AddSubmonoid G\nx : Subtype fun x => Membership.mem H x\n⊢ Iff (IsOfFinAddOrder ↑x) (IsOfFinAddOrder x)","decl":"/-- Elements of finite order are of finite order in submonoids. -/\n@[to_additive \"Elements of finite order are of finite order in submonoids.\"]\ntheorem Submonoid.isOfFinOrder_coe {H : Submonoid G} {x : H} :\n    IsOfFinOrder (x : G) ↔ IsOfFinOrder x := by\n  rw [isOfFinOrder_iff_pow_eq_one, isOfFinOrder_iff_pow_eq_one]\n  norm_cast\n\n"}
{"name":"MonoidHom.isOfFinOrder","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\nH : Type u_2\ninst✝¹ : Monoid G\ninst✝ : Monoid H\nf : MonoidHom G H\nx : G\nh : IsOfFinOrder x\n⊢ IsOfFinOrder (f x)","decl":"/-- The image of an element of finite order has finite order. -/\n@[to_additive \"The image of an element of finite additive order has finite additive order.\"]\ntheorem MonoidHom.isOfFinOrder [Monoid H] (f : G →* H) {x : G} (h : IsOfFinOrder x) :\n    IsOfFinOrder <| f x :=\n  isOfFinOrder_iff_pow_eq_one.mpr <| by\n    obtain ⟨n, npos, hn⟩ := h.exists_pow_eq_one\n    exact ⟨n, npos, by rw [← f.map_pow, hn, f.map_one]⟩\n\n"}
{"name":"AddMonoidHom.isOfFinAddOrder","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\nH : Type u_2\ninst✝¹ : AddMonoid G\ninst✝ : AddMonoid H\nf : AddMonoidHom G H\nx : G\nh : IsOfFinAddOrder x\n⊢ IsOfFinAddOrder (f x)","decl":"/-- The image of an element of finite order has finite order. -/\n@[to_additive \"The image of an element of finite additive order has finite additive order.\"]\ntheorem MonoidHom.isOfFinOrder [Monoid H] (f : G →* H) {x : G} (h : IsOfFinOrder x) :\n    IsOfFinOrder <| f x :=\n  isOfFinOrder_iff_pow_eq_one.mpr <| by\n    obtain ⟨n, npos, hn⟩ := h.exists_pow_eq_one\n    exact ⟨n, npos, by rw [← f.map_pow, hn, f.map_one]⟩\n\n"}
{"name":"IsOfFinAddOrder.apply","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"η : Type u_6\nGs : η → Type u_7\ninst✝ : (i : η) → AddMonoid (Gs i)\nx : (i : η) → Gs i\nh : IsOfFinAddOrder x\ni : η\n⊢ IsOfFinAddOrder (x i)","decl":"/-- If a direct product has finite order then so does each component. -/\n@[to_additive \"If a direct product has finite additive order then so does each component.\"]\ntheorem IsOfFinOrder.apply {η : Type*} {Gs : η → Type*} [∀ i, Monoid (Gs i)] {x : ∀ i, Gs i}\n    (h : IsOfFinOrder x) : ∀ i, IsOfFinOrder (x i) := by\n  obtain ⟨n, npos, hn⟩ := h.exists_pow_eq_one\n  exact fun _ => isOfFinOrder_iff_pow_eq_one.mpr ⟨n, npos, (congr_fun hn.symm _).symm⟩\n\n"}
{"name":"IsOfFinOrder.apply","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"η : Type u_6\nGs : η → Type u_7\ninst✝ : (i : η) → Monoid (Gs i)\nx : (i : η) → Gs i\nh : IsOfFinOrder x\ni : η\n⊢ IsOfFinOrder (x i)","decl":"/-- If a direct product has finite order then so does each component. -/\n@[to_additive \"If a direct product has finite additive order then so does each component.\"]\ntheorem IsOfFinOrder.apply {η : Type*} {Gs : η → Type*} [∀ i, Monoid (Gs i)] {x : ∀ i, Gs i}\n    (h : IsOfFinOrder x) : ∀ i, IsOfFinOrder (x i) := by\n  obtain ⟨n, npos, hn⟩ := h.exists_pow_eq_one\n  exact fun _ => isOfFinOrder_iff_pow_eq_one.mpr ⟨n, npos, (congr_fun hn.symm _).symm⟩\n\n"}
{"name":"addOrderOf_ofMul_eq_orderOf","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝ : Monoid G\nx : G\n⊢ Eq (addOrderOf (Additive.ofMul x)) (orderOf x)","decl":"@[simp]\ntheorem addOrderOf_ofMul_eq_orderOf (x : G) : addOrderOf (Additive.ofMul x) = orderOf x :=\n  rfl\n\n"}
{"name":"orderOf_ofAdd_eq_addOrderOf","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"α : Type u_6\ninst✝ : AddMonoid α\na : α\n⊢ Eq (orderOf (Multiplicative.ofAdd a)) (addOrderOf a)","decl":"@[simp]\nlemma orderOf_ofAdd_eq_addOrderOf {α : Type*} [AddMonoid α] (a : α) :\n    orderOf (Multiplicative.ofAdd a) = addOrderOf a := rfl\n\n"}
{"name":"IsOfFinOrder.orderOf_pos","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝ : Monoid G\nx : G\nh : IsOfFinOrder x\n⊢ LT.lt 0 (orderOf x)","decl":"@[to_additive]\nprotected lemma IsOfFinOrder.orderOf_pos (h : IsOfFinOrder x) : 0 < orderOf x :=\n  minimalPeriod_pos_of_mem_periodicPts h\n\n"}
{"name":"IsOfFinAddOrder.addOrderOf_pos","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝ : AddMonoid G\nx : G\nh : IsOfFinAddOrder x\n⊢ LT.lt 0 (addOrderOf x)","decl":"@[to_additive]\nprotected lemma IsOfFinOrder.orderOf_pos (h : IsOfFinOrder x) : 0 < orderOf x :=\n  minimalPeriod_pos_of_mem_periodicPts h\n\n"}
{"name":"addOrderOf_nsmul_eq_zero","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝ : AddMonoid G\nx : G\n⊢ Eq (HSMul.hSMul (addOrderOf x) x) 0","decl":"@[to_additive addOrderOf_nsmul_eq_zero]\ntheorem pow_orderOf_eq_one (x : G) : x ^ orderOf x = 1 := by\n  convert Eq.trans _ (isPeriodicPt_minimalPeriod (x * ·) 1)\n  -- Porting note (https://github.com/leanprover-community/mathlib4/issues/12129): additional beta reduction needed in the middle of the rewrite\n  rw [orderOf, mul_left_iterate]; beta_reduce; rw [mul_one]\n\n"}
{"name":"pow_orderOf_eq_one","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝ : Monoid G\nx : G\n⊢ Eq (HPow.hPow x (orderOf x)) 1","decl":"@[to_additive addOrderOf_nsmul_eq_zero]\ntheorem pow_orderOf_eq_one (x : G) : x ^ orderOf x = 1 := by\n  convert Eq.trans _ (isPeriodicPt_minimalPeriod (x * ·) 1)\n  -- Porting note (https://github.com/leanprover-community/mathlib4/issues/12129): additional beta reduction needed in the middle of the rewrite\n  rw [orderOf, mul_left_iterate]; beta_reduce; rw [mul_one]\n\n"}
{"name":"orderOf_eq_zero","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝ : Monoid G\nx : G\nh : Not (IsOfFinOrder x)\n⊢ Eq (orderOf x) 0","decl":"@[to_additive]\ntheorem orderOf_eq_zero (h : ¬IsOfFinOrder x) : orderOf x = 0 := by\n  rwa [orderOf, minimalPeriod, dif_neg]\n\n"}
{"name":"addOrderOf_eq_zero","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝ : AddMonoid G\nx : G\nh : Not (IsOfFinAddOrder x)\n⊢ Eq (addOrderOf x) 0","decl":"@[to_additive]\ntheorem orderOf_eq_zero (h : ¬IsOfFinOrder x) : orderOf x = 0 := by\n  rwa [orderOf, minimalPeriod, dif_neg]\n\n"}
{"name":"orderOf_eq_zero_iff","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝ : Monoid G\nx : G\n⊢ Iff (Eq (orderOf x) 0) (Not (IsOfFinOrder x))","decl":"@[to_additive]\ntheorem orderOf_eq_zero_iff : orderOf x = 0 ↔ ¬IsOfFinOrder x :=\n  ⟨fun h H ↦ H.orderOf_pos.ne' h, orderOf_eq_zero⟩\n\n"}
{"name":"addOrderOf_eq_zero_iff","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝ : AddMonoid G\nx : G\n⊢ Iff (Eq (addOrderOf x) 0) (Not (IsOfFinAddOrder x))","decl":"@[to_additive]\ntheorem orderOf_eq_zero_iff : orderOf x = 0 ↔ ¬IsOfFinOrder x :=\n  ⟨fun h H ↦ H.orderOf_pos.ne' h, orderOf_eq_zero⟩\n\n"}
{"name":"orderOf_eq_zero_iff'","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝ : Monoid G\nx : G\n⊢ Iff (Eq (orderOf x) 0) (∀ (n : Nat), LT.lt 0 n → Ne (HPow.hPow x n) 1)","decl":"@[to_additive]\ntheorem orderOf_eq_zero_iff' : orderOf x = 0 ↔ ∀ n : ℕ, 0 < n → x ^ n ≠ 1 := by\n  simp_rw [orderOf_eq_zero_iff, isOfFinOrder_iff_pow_eq_one, not_exists, not_and]\n\n"}
{"name":"addOrderOf_eq_zero_iff'","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝ : AddMonoid G\nx : G\n⊢ Iff (Eq (addOrderOf x) 0) (∀ (n : Nat), LT.lt 0 n → Ne (HSMul.hSMul n x) 0)","decl":"@[to_additive]\ntheorem orderOf_eq_zero_iff' : orderOf x = 0 ↔ ∀ n : ℕ, 0 < n → x ^ n ≠ 1 := by\n  simp_rw [orderOf_eq_zero_iff, isOfFinOrder_iff_pow_eq_one, not_exists, not_and]\n\n"}
{"name":"orderOf_eq_iff","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝ : Monoid G\nx : G\nn : Nat\nh : LT.lt 0 n\n⊢ Iff (Eq (orderOf x) n) (And (Eq (HPow.hPow x n) 1) (∀ (m : Nat), LT.lt m n → LT.lt 0 m → Ne (HPow.hPow x m) 1))","decl":"@[to_additive]\ntheorem orderOf_eq_iff {n} (h : 0 < n) :\n    orderOf x = n ↔ x ^ n = 1 ∧ ∀ m, m < n → 0 < m → x ^ m ≠ 1 := by\n  simp_rw [Ne, ← isPeriodicPt_mul_iff_pow_eq_one, orderOf, minimalPeriod]\n  split_ifs with h1\n  · classical\n    rw [find_eq_iff]\n    simp only [h, true_and]\n    push_neg\n    rfl\n  · rw [iff_false_left h.ne]\n    rintro ⟨h', -⟩\n    exact h1 ⟨n, h, h'⟩\n\n"}
{"name":"addOrderOf_eq_iff","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝ : AddMonoid G\nx : G\nn : Nat\nh : LT.lt 0 n\n⊢ Iff (Eq (addOrderOf x) n) (And (Eq (HSMul.hSMul n x) 0) (∀ (m : Nat), LT.lt m n → LT.lt 0 m → Ne (HSMul.hSMul m x) 0))","decl":"@[to_additive]\ntheorem orderOf_eq_iff {n} (h : 0 < n) :\n    orderOf x = n ↔ x ^ n = 1 ∧ ∀ m, m < n → 0 < m → x ^ m ≠ 1 := by\n  simp_rw [Ne, ← isPeriodicPt_mul_iff_pow_eq_one, orderOf, minimalPeriod]\n  split_ifs with h1\n  · classical\n    rw [find_eq_iff]\n    simp only [h, true_and]\n    push_neg\n    rfl\n  · rw [iff_false_left h.ne]\n    rintro ⟨h', -⟩\n    exact h1 ⟨n, h, h'⟩\n\n"}
{"name":"orderOf_pos_iff","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝ : Monoid G\nx : G\n⊢ Iff (LT.lt 0 (orderOf x)) (IsOfFinOrder x)","decl":"/-- A group element has finite order iff its order is positive. -/\n@[to_additive\n      \"A group element has finite additive order iff its order is positive.\"]\ntheorem orderOf_pos_iff : 0 < orderOf x ↔ IsOfFinOrder x := by\n  rw [iff_not_comm.mp orderOf_eq_zero_iff, pos_iff_ne_zero]\n\n"}
{"name":"addOrderOf_pos_iff","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝ : AddMonoid G\nx : G\n⊢ Iff (LT.lt 0 (addOrderOf x)) (IsOfFinAddOrder x)","decl":"/-- A group element has finite order iff its order is positive. -/\n@[to_additive\n      \"A group element has finite additive order iff its order is positive.\"]\ntheorem orderOf_pos_iff : 0 < orderOf x ↔ IsOfFinOrder x := by\n  rw [iff_not_comm.mp orderOf_eq_zero_iff, pos_iff_ne_zero]\n\n"}
{"name":"IsOfFinOrder.mono","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\nβ : Type u_5\ninst✝¹ : Monoid G\nx : G\ninst✝ : Monoid β\ny : β\nhx : IsOfFinOrder x\nh : Dvd.dvd (orderOf y) (orderOf x)\n⊢ IsOfFinOrder y","decl":"@[to_additive]\ntheorem IsOfFinOrder.mono [Monoid β] {y : β} (hx : IsOfFinOrder x) (h : orderOf y ∣ orderOf x) :\n    IsOfFinOrder y := by rw [← orderOf_pos_iff] at hx ⊢; exact Nat.pos_of_dvd_of_pos h hx\n\n"}
{"name":"IsOfFinAddOrder.mono","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\nβ : Type u_5\ninst✝¹ : AddMonoid G\nx : G\ninst✝ : AddMonoid β\ny : β\nhx : IsOfFinAddOrder x\nh : Dvd.dvd (addOrderOf y) (addOrderOf x)\n⊢ IsOfFinAddOrder y","decl":"@[to_additive]\ntheorem IsOfFinOrder.mono [Monoid β] {y : β} (hx : IsOfFinOrder x) (h : orderOf y ∣ orderOf x) :\n    IsOfFinOrder y := by rw [← orderOf_pos_iff] at hx ⊢; exact Nat.pos_of_dvd_of_pos h hx\n\n"}
{"name":"pow_ne_one_of_lt_orderOf","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝ : Monoid G\nx : G\nn : Nat\nn0 : Ne n 0\nh : LT.lt n (orderOf x)\n⊢ Ne (HPow.hPow x n) 1","decl":"@[to_additive]\ntheorem pow_ne_one_of_lt_orderOf (n0 : n ≠ 0) (h : n < orderOf x) : x ^ n ≠ 1 := fun j =>\n  not_isPeriodicPt_of_pos_of_lt_minimalPeriod n0 h ((isPeriodicPt_mul_iff_pow_eq_one x).mpr j)\n"}
{"name":"nsmul_ne_zero_of_lt_addOrderOf","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝ : AddMonoid G\nx : G\nn : Nat\nn0 : Ne n 0\nh : LT.lt n (addOrderOf x)\n⊢ Ne (HSMul.hSMul n x) 0","decl":"@[to_additive]\ntheorem pow_ne_one_of_lt_orderOf (n0 : n ≠ 0) (h : n < orderOf x) : x ^ n ≠ 1 := fun j =>\n  not_isPeriodicPt_of_pos_of_lt_minimalPeriod n0 h ((isPeriodicPt_mul_iff_pow_eq_one x).mpr j)\n"}
{"name":"orderOf_le_of_pow_eq_one","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝ : Monoid G\nx : G\nn : Nat\nhn : LT.lt 0 n\nh : Eq (HPow.hPow x n) 1\n⊢ LE.le (orderOf x) n","decl":"@[to_additive]\ntheorem orderOf_le_of_pow_eq_one (hn : 0 < n) (h : x ^ n = 1) : orderOf x ≤ n :=\n  IsPeriodicPt.minimalPeriod_le hn (by rwa [isPeriodicPt_mul_iff_pow_eq_one])\n\n"}
{"name":"addOrderOf_le_of_nsmul_eq_zero","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝ : AddMonoid G\nx : G\nn : Nat\nhn : LT.lt 0 n\nh : Eq (HSMul.hSMul n x) 0\n⊢ LE.le (addOrderOf x) n","decl":"@[to_additive]\ntheorem orderOf_le_of_pow_eq_one (hn : 0 < n) (h : x ^ n = 1) : orderOf x ≤ n :=\n  IsPeriodicPt.minimalPeriod_le hn (by rwa [isPeriodicPt_mul_iff_pow_eq_one])\n\n"}
{"name":"orderOf_one","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝ : Monoid G\n⊢ Eq (orderOf 1) 1","decl":"@[to_additive (attr := simp)]\ntheorem orderOf_one : orderOf (1 : G) = 1 := by\n  rw [orderOf, ← minimalPeriod_id (x := (1 : G)), ← one_mul_eq_id]\n\n"}
{"name":"addOrderOf_zero","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝ : AddMonoid G\n⊢ Eq (addOrderOf 0) 1","decl":"@[to_additive (attr := simp)]\ntheorem orderOf_one : orderOf (1 : G) = 1 := by\n  rw [orderOf, ← minimalPeriod_id (x := (1 : G)), ← one_mul_eq_id]\n\n"}
{"name":"AddMonoid.addOrderOf_eq_one_iff","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝ : AddMonoid G\nx : G\n⊢ Iff (Eq (addOrderOf x) 1) (Eq x 0)","decl":"@[to_additive (attr := simp) AddMonoid.addOrderOf_eq_one_iff]\ntheorem orderOf_eq_one_iff : orderOf x = 1 ↔ x = 1 := by\n  rw [orderOf, minimalPeriod_eq_one_iff_isFixedPt, IsFixedPt, mul_one]\n\n"}
{"name":"orderOf_eq_one_iff","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝ : Monoid G\nx : G\n⊢ Iff (Eq (orderOf x) 1) (Eq x 1)","decl":"@[to_additive (attr := simp) AddMonoid.addOrderOf_eq_one_iff]\ntheorem orderOf_eq_one_iff : orderOf x = 1 ↔ x = 1 := by\n  rw [orderOf, minimalPeriod_eq_one_iff_isFixedPt, IsFixedPt, mul_one]\n\n"}
{"name":"pow_mod_orderOf","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝ : Monoid G\nx : G\nn : Nat\n⊢ Eq (HPow.hPow x (HMod.hMod n (orderOf x))) (HPow.hPow x n)","decl":"@[to_additive (attr := simp) mod_addOrderOf_nsmul]\nlemma pow_mod_orderOf (x : G) (n : ℕ) : x ^ (n % orderOf x) = x ^ n :=\n  calc\n    x ^ (n % orderOf x) = x ^ (n % orderOf x + orderOf x * (n / orderOf x)) := by\n        simp [pow_add, pow_mul, pow_orderOf_eq_one]\n    _ = x ^ n := by rw [Nat.mod_add_div]\n\n"}
{"name":"mod_addOrderOf_nsmul","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝ : AddMonoid G\nx : G\nn : Nat\n⊢ Eq (HSMul.hSMul (HMod.hMod n (addOrderOf x)) x) (HSMul.hSMul n x)","decl":"@[to_additive (attr := simp) mod_addOrderOf_nsmul]\nlemma pow_mod_orderOf (x : G) (n : ℕ) : x ^ (n % orderOf x) = x ^ n :=\n  calc\n    x ^ (n % orderOf x) = x ^ (n % orderOf x + orderOf x * (n / orderOf x)) := by\n        simp [pow_add, pow_mul, pow_orderOf_eq_one]\n    _ = x ^ n := by rw [Nat.mod_add_div]\n\n"}
{"name":"addOrderOf_dvd_of_nsmul_eq_zero","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝ : AddMonoid G\nx : G\nn : Nat\nh : Eq (HSMul.hSMul n x) 0\n⊢ Dvd.dvd (addOrderOf x) n","decl":"@[to_additive]\ntheorem orderOf_dvd_of_pow_eq_one (h : x ^ n = 1) : orderOf x ∣ n :=\n  IsPeriodicPt.minimalPeriod_dvd ((isPeriodicPt_mul_iff_pow_eq_one _).mpr h)\n\n"}
{"name":"orderOf_dvd_of_pow_eq_one","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝ : Monoid G\nx : G\nn : Nat\nh : Eq (HPow.hPow x n) 1\n⊢ Dvd.dvd (orderOf x) n","decl":"@[to_additive]\ntheorem orderOf_dvd_of_pow_eq_one (h : x ^ n = 1) : orderOf x ∣ n :=\n  IsPeriodicPt.minimalPeriod_dvd ((isPeriodicPt_mul_iff_pow_eq_one _).mpr h)\n\n"}
{"name":"orderOf_dvd_iff_pow_eq_one","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝ : Monoid G\nx : G\nn : Nat\n⊢ Iff (Dvd.dvd (orderOf x) n) (Eq (HPow.hPow x n) 1)","decl":"@[to_additive]\ntheorem orderOf_dvd_iff_pow_eq_one {n : ℕ} : orderOf x ∣ n ↔ x ^ n = 1 :=\n  ⟨fun h => by rw [← pow_mod_orderOf, Nat.mod_eq_zero_of_dvd h, _root_.pow_zero],\n    orderOf_dvd_of_pow_eq_one⟩\n\n"}
{"name":"addOrderOf_dvd_iff_nsmul_eq_zero","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝ : AddMonoid G\nx : G\nn : Nat\n⊢ Iff (Dvd.dvd (addOrderOf x) n) (Eq (HSMul.hSMul n x) 0)","decl":"@[to_additive]\ntheorem orderOf_dvd_iff_pow_eq_one {n : ℕ} : orderOf x ∣ n ↔ x ^ n = 1 :=\n  ⟨fun h => by rw [← pow_mod_orderOf, Nat.mod_eq_zero_of_dvd h, _root_.pow_zero],\n    orderOf_dvd_of_pow_eq_one⟩\n\n"}
{"name":"addOrderOf_smul_dvd","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝ : AddMonoid G\nx : G\nn : Nat\n⊢ Dvd.dvd (addOrderOf (HSMul.hSMul n x)) (addOrderOf x)","decl":"@[to_additive addOrderOf_smul_dvd]\ntheorem orderOf_pow_dvd (n : ℕ) : orderOf (x ^ n) ∣ orderOf x := by\n  rw [orderOf_dvd_iff_pow_eq_one, pow_right_comm, pow_orderOf_eq_one, one_pow]\n\n"}
{"name":"orderOf_pow_dvd","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝ : Monoid G\nx : G\nn : Nat\n⊢ Dvd.dvd (orderOf (HPow.hPow x n)) (orderOf x)","decl":"@[to_additive addOrderOf_smul_dvd]\ntheorem orderOf_pow_dvd (n : ℕ) : orderOf (x ^ n) ∣ orderOf x := by\n  rw [orderOf_dvd_iff_pow_eq_one, pow_right_comm, pow_orderOf_eq_one, one_pow]\n\n"}
{"name":"nsmul_injOn_Iio_addOrderOf","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝ : AddMonoid G\nx : G\n⊢ Set.InjOn (fun x_1 => HSMul.hSMul x_1 x) (Set.Iio (addOrderOf x))","decl":"@[to_additive]\nlemma pow_injOn_Iio_orderOf : (Set.Iio <| orderOf x).InjOn (x ^ ·) := by\n  simpa only [mul_left_iterate, mul_one]\n    using iterate_injOn_Iio_minimalPeriod (f := (x * ·)) (x := 1)\n\n"}
{"name":"pow_injOn_Iio_orderOf","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝ : Monoid G\nx : G\n⊢ Set.InjOn (fun x_1 => HPow.hPow x x_1) (Set.Iio (orderOf x))","decl":"@[to_additive]\nlemma pow_injOn_Iio_orderOf : (Set.Iio <| orderOf x).InjOn (x ^ ·) := by\n  simpa only [mul_left_iterate, mul_one]\n    using iterate_injOn_Iio_minimalPeriod (f := (x * ·)) (x := 1)\n\n"}
{"name":"IsOfFinOrder.mem_powers_iff_mem_range_orderOf","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝¹ : Monoid G\nx y : G\ninst✝ : DecidableEq G\nhx : IsOfFinOrder x\n⊢ Iff (Membership.mem (Submonoid.powers x) y) (Membership.mem (Finset.image (fun x_1 => HPow.hPow x x_1) (Finset.range (orderOf x))) y)","decl":"@[to_additive]\nprotected lemma IsOfFinOrder.mem_powers_iff_mem_range_orderOf [DecidableEq G]\n    (hx : IsOfFinOrder x) :\n    y ∈ Submonoid.powers x ↔ y ∈ (Finset.range (orderOf x)).image (x ^ ·) :=\n  Finset.mem_range_iff_mem_finset_range_of_mod_eq' hx.orderOf_pos <| pow_mod_orderOf _\n\n"}
{"name":"IsOfFinAddOrder.mem_multiples_iff_mem_range_addOrderOf","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝¹ : AddMonoid G\nx y : G\ninst✝ : DecidableEq G\nhx : IsOfFinAddOrder x\n⊢ Iff (Membership.mem (AddSubmonoid.multiples x) y) (Membership.mem (Finset.image (fun x_1 => HSMul.hSMul x_1 x) (Finset.range (addOrderOf x))) y)","decl":"@[to_additive]\nprotected lemma IsOfFinOrder.mem_powers_iff_mem_range_orderOf [DecidableEq G]\n    (hx : IsOfFinOrder x) :\n    y ∈ Submonoid.powers x ↔ y ∈ (Finset.range (orderOf x)).image (x ^ ·) :=\n  Finset.mem_range_iff_mem_finset_range_of_mod_eq' hx.orderOf_pos <| pow_mod_orderOf _\n\n"}
{"name":"IsOfFinOrder.powers_eq_image_range_orderOf","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝¹ : Monoid G\nx : G\ninst✝ : DecidableEq G\nhx : IsOfFinOrder x\n⊢ Eq ↑(Submonoid.powers x) ↑(Finset.image (fun x_1 => HPow.hPow x x_1) (Finset.range (orderOf x)))","decl":"@[to_additive]\nprotected lemma IsOfFinOrder.powers_eq_image_range_orderOf [DecidableEq G] (hx : IsOfFinOrder x) :\n    (Submonoid.powers x : Set G) = (Finset.range (orderOf x)).image (x ^ ·) :=\n  Set.ext fun _ ↦ hx.mem_powers_iff_mem_range_orderOf\n\n"}
{"name":"IsOfFinAddOrder.multiples_eq_image_range_addOrderOf","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝¹ : AddMonoid G\nx : G\ninst✝ : DecidableEq G\nhx : IsOfFinAddOrder x\n⊢ Eq ↑(AddSubmonoid.multiples x) ↑(Finset.image (fun x_1 => HSMul.hSMul x_1 x) (Finset.range (addOrderOf x)))","decl":"@[to_additive]\nprotected lemma IsOfFinOrder.powers_eq_image_range_orderOf [DecidableEq G] (hx : IsOfFinOrder x) :\n    (Submonoid.powers x : Set G) = (Finset.range (orderOf x)).image (x ^ ·) :=\n  Set.ext fun _ ↦ hx.mem_powers_iff_mem_range_orderOf\n\n"}
{"name":"nsmul_eq_zero_iff_modEq","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝ : AddMonoid G\nx : G\nn : Nat\n⊢ Iff (Eq (HSMul.hSMul n x) 0) ((addOrderOf x).ModEq n 0)","decl":"@[to_additive]\ntheorem pow_eq_one_iff_modEq : x ^ n = 1 ↔ n ≡ 0 [MOD orderOf x] := by\n  rw [modEq_zero_iff_dvd, orderOf_dvd_iff_pow_eq_one]\n\n"}
{"name":"pow_eq_one_iff_modEq","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝ : Monoid G\nx : G\nn : Nat\n⊢ Iff (Eq (HPow.hPow x n) 1) ((orderOf x).ModEq n 0)","decl":"@[to_additive]\ntheorem pow_eq_one_iff_modEq : x ^ n = 1 ↔ n ≡ 0 [MOD orderOf x] := by\n  rw [modEq_zero_iff_dvd, orderOf_dvd_iff_pow_eq_one]\n\n"}
{"name":"addOrderOf_map_dvd","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝¹ : AddMonoid G\nH : Type u_6\ninst✝ : AddMonoid H\nψ : AddMonoidHom G H\nx : G\n⊢ Dvd.dvd (addOrderOf (ψ x)) (addOrderOf x)","decl":"@[to_additive]\ntheorem orderOf_map_dvd {H : Type*} [Monoid H] (ψ : G →* H) (x : G) :\n    orderOf (ψ x) ∣ orderOf x := by\n  apply orderOf_dvd_of_pow_eq_one\n  rw [← map_pow, pow_orderOf_eq_one]\n  apply map_one\n\n"}
{"name":"orderOf_map_dvd","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝¹ : Monoid G\nH : Type u_6\ninst✝ : Monoid H\nψ : MonoidHom G H\nx : G\n⊢ Dvd.dvd (orderOf (ψ x)) (orderOf x)","decl":"@[to_additive]\ntheorem orderOf_map_dvd {H : Type*} [Monoid H] (ψ : G →* H) (x : G) :\n    orderOf (ψ x) ∣ orderOf x := by\n  apply orderOf_dvd_of_pow_eq_one\n  rw [← map_pow, pow_orderOf_eq_one]\n  apply map_one\n\n"}
{"name":"exists_nsmul_eq_self_of_coprime","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝ : AddMonoid G\nx : G\nn : Nat\nh : n.Coprime (addOrderOf x)\n⊢ Exists fun m => Eq (HSMul.hSMul m (HSMul.hSMul n x)) x","decl":"@[to_additive]\ntheorem exists_pow_eq_self_of_coprime (h : n.Coprime (orderOf x)) : ∃ m : ℕ, (x ^ n) ^ m = x := by\n  by_cases h0 : orderOf x = 0\n  · rw [h0, coprime_zero_right] at h\n    exact ⟨1, by rw [h, pow_one, pow_one]⟩\n  by_cases h1 : orderOf x = 1\n  · exact ⟨0, by rw [orderOf_eq_one_iff.mp h1, one_pow, one_pow]⟩\n  obtain ⟨m, h⟩ := exists_mul_emod_eq_one_of_coprime h (one_lt_iff_ne_zero_and_ne_one.mpr ⟨h0, h1⟩)\n  exact ⟨m, by rw [← pow_mul, ← pow_mod_orderOf, h, pow_one]⟩\n\n"}
{"name":"exists_pow_eq_self_of_coprime","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝ : Monoid G\nx : G\nn : Nat\nh : n.Coprime (orderOf x)\n⊢ Exists fun m => Eq (HPow.hPow (HPow.hPow x n) m) x","decl":"@[to_additive]\ntheorem exists_pow_eq_self_of_coprime (h : n.Coprime (orderOf x)) : ∃ m : ℕ, (x ^ n) ^ m = x := by\n  by_cases h0 : orderOf x = 0\n  · rw [h0, coprime_zero_right] at h\n    exact ⟨1, by rw [h, pow_one, pow_one]⟩\n  by_cases h1 : orderOf x = 1\n  · exact ⟨0, by rw [orderOf_eq_one_iff.mp h1, one_pow, one_pow]⟩\n  obtain ⟨m, h⟩ := exists_mul_emod_eq_one_of_coprime h (one_lt_iff_ne_zero_and_ne_one.mpr ⟨h0, h1⟩)\n  exact ⟨m, by rw [← pow_mul, ← pow_mod_orderOf, h, pow_one]⟩\n\n"}
{"name":"addOrderOf_eq_of_nsmul_and_div_prime_nsmul","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝ : AddMonoid G\nx : G\nn : Nat\nhn : LT.lt 0 n\nhx : Eq (HSMul.hSMul n x) 0\nhd : ∀ (p : Nat), Nat.Prime p → Dvd.dvd p n → Ne (HSMul.hSMul (HDiv.hDiv n p) x) 0\n⊢ Eq (addOrderOf x) n","decl":"/-- If `x^n = 1`, but `x^(n/p) ≠ 1` for all prime factors `p` of `n`,\nthen `x` has order `n` in `G`. -/\n@[to_additive addOrderOf_eq_of_nsmul_and_div_prime_nsmul \"If `n * x = 0`, but `n/p * x ≠ 0` for\nall prime factors `p` of `n`, then `x` has order `n` in `G`.\"]\ntheorem orderOf_eq_of_pow_and_pow_div_prime (hn : 0 < n) (hx : x ^ n = 1)\n    (hd : ∀ p : ℕ, p.Prime → p ∣ n → x ^ (n / p) ≠ 1) : orderOf x = n := by\n  -- Let `a` be `n/(orderOf x)`, and show `a = 1`\n  cases' exists_eq_mul_right_of_dvd (orderOf_dvd_of_pow_eq_one hx) with a ha\n  suffices a = 1 by simp [this, ha]\n  -- Assume `a` is not one...\n  by_contra h\n  have a_min_fac_dvd_p_sub_one : a.minFac ∣ n := by\n    obtain ⟨b, hb⟩ : ∃ b : ℕ, a = b * a.minFac := exists_eq_mul_left_of_dvd a.minFac_dvd\n    rw [hb, ← mul_assoc] at ha\n    exact Dvd.intro_left (orderOf x * b) ha.symm\n  -- Use the minimum prime factor of `a` as `p`.\n  refine hd a.minFac (Nat.minFac_prime h) a_min_fac_dvd_p_sub_one ?_\n  rw [← orderOf_dvd_iff_pow_eq_one, Nat.dvd_div_iff_mul_dvd a_min_fac_dvd_p_sub_one, ha, mul_comm,\n    Nat.mul_dvd_mul_iff_left (IsOfFinOrder.orderOf_pos _)]\n  · exact Nat.minFac_dvd a\n  · rw [isOfFinOrder_iff_pow_eq_one]\n    exact Exists.intro n (id ⟨hn, hx⟩)\n\n"}
{"name":"orderOf_eq_of_pow_and_pow_div_prime","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝ : Monoid G\nx : G\nn : Nat\nhn : LT.lt 0 n\nhx : Eq (HPow.hPow x n) 1\nhd : ∀ (p : Nat), Nat.Prime p → Dvd.dvd p n → Ne (HPow.hPow x (HDiv.hDiv n p)) 1\n⊢ Eq (orderOf x) n","decl":"/-- If `x^n = 1`, but `x^(n/p) ≠ 1` for all prime factors `p` of `n`,\nthen `x` has order `n` in `G`. -/\n@[to_additive addOrderOf_eq_of_nsmul_and_div_prime_nsmul \"If `n * x = 0`, but `n/p * x ≠ 0` for\nall prime factors `p` of `n`, then `x` has order `n` in `G`.\"]\ntheorem orderOf_eq_of_pow_and_pow_div_prime (hn : 0 < n) (hx : x ^ n = 1)\n    (hd : ∀ p : ℕ, p.Prime → p ∣ n → x ^ (n / p) ≠ 1) : orderOf x = n := by\n  -- Let `a` be `n/(orderOf x)`, and show `a = 1`\n  cases' exists_eq_mul_right_of_dvd (orderOf_dvd_of_pow_eq_one hx) with a ha\n  suffices a = 1 by simp [this, ha]\n  -- Assume `a` is not one...\n  by_contra h\n  have a_min_fac_dvd_p_sub_one : a.minFac ∣ n := by\n    obtain ⟨b, hb⟩ : ∃ b : ℕ, a = b * a.minFac := exists_eq_mul_left_of_dvd a.minFac_dvd\n    rw [hb, ← mul_assoc] at ha\n    exact Dvd.intro_left (orderOf x * b) ha.symm\n  -- Use the minimum prime factor of `a` as `p`.\n  refine hd a.minFac (Nat.minFac_prime h) a_min_fac_dvd_p_sub_one ?_\n  rw [← orderOf_dvd_iff_pow_eq_one, Nat.dvd_div_iff_mul_dvd a_min_fac_dvd_p_sub_one, ha, mul_comm,\n    Nat.mul_dvd_mul_iff_left (IsOfFinOrder.orderOf_pos _)]\n  · exact Nat.minFac_dvd a\n  · rw [isOfFinOrder_iff_pow_eq_one]\n    exact Exists.intro n (id ⟨hn, hx⟩)\n\n"}
{"name":"orderOf_eq_orderOf_iff","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝¹ : Monoid G\nx : G\nH : Type u_6\ninst✝ : Monoid H\ny : H\n⊢ Iff (Eq (orderOf x) (orderOf y)) (∀ (n : Nat), Iff (Eq (HPow.hPow x n) 1) (Eq (HPow.hPow y n) 1))","decl":"@[to_additive]\ntheorem orderOf_eq_orderOf_iff {H : Type*} [Monoid H] {y : H} :\n    orderOf x = orderOf y ↔ ∀ n : ℕ, x ^ n = 1 ↔ y ^ n = 1 := by\n  simp_rw [← isPeriodicPt_mul_iff_pow_eq_one, ← minimalPeriod_eq_minimalPeriod_iff, orderOf]\n\n"}
{"name":"addOrderOf_eq_addOrderOf_iff","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝¹ : AddMonoid G\nx : G\nH : Type u_6\ninst✝ : AddMonoid H\ny : H\n⊢ Iff (Eq (addOrderOf x) (addOrderOf y)) (∀ (n : Nat), Iff (Eq (HSMul.hSMul n x) 0) (Eq (HSMul.hSMul n y) 0))","decl":"@[to_additive]\ntheorem orderOf_eq_orderOf_iff {H : Type*} [Monoid H] {y : H} :\n    orderOf x = orderOf y ↔ ∀ n : ℕ, x ^ n = 1 ↔ y ^ n = 1 := by\n  simp_rw [← isPeriodicPt_mul_iff_pow_eq_one, ← minimalPeriod_eq_minimalPeriod_iff, orderOf]\n\n"}
{"name":"addOrderOf_injective","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝¹ : AddMonoid G\nH : Type u_6\ninst✝ : AddMonoid H\nf : AddMonoidHom G H\nhf : Function.Injective ⇑f\nx : G\n⊢ Eq (addOrderOf (f x)) (addOrderOf x)","decl":"/-- An injective homomorphism of monoids preserves orders of elements. -/\n@[to_additive \"An injective homomorphism of additive monoids preserves orders of elements.\"]\ntheorem orderOf_injective {H : Type*} [Monoid H] (f : G →* H) (hf : Function.Injective f) (x : G) :\n    orderOf (f x) = orderOf x := by\n  simp_rw [orderOf_eq_orderOf_iff, ← f.map_pow, ← f.map_one, hf.eq_iff, forall_const]\n\n"}
{"name":"orderOf_injective","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝¹ : Monoid G\nH : Type u_6\ninst✝ : Monoid H\nf : MonoidHom G H\nhf : Function.Injective ⇑f\nx : G\n⊢ Eq (orderOf (f x)) (orderOf x)","decl":"/-- An injective homomorphism of monoids preserves orders of elements. -/\n@[to_additive \"An injective homomorphism of additive monoids preserves orders of elements.\"]\ntheorem orderOf_injective {H : Type*} [Monoid H] (f : G →* H) (hf : Function.Injective f) (x : G) :\n    orderOf (f x) = orderOf x := by\n  simp_rw [orderOf_eq_orderOf_iff, ← f.map_pow, ← f.map_one, hf.eq_iff, forall_const]\n\n"}
{"name":"AddEquiv.addOrderOf_eq","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝¹ : AddMonoid G\nH : Type u_6\ninst✝ : AddMonoid H\ne : AddEquiv G H\nx : G\n⊢ Eq (addOrderOf (e x)) (addOrderOf x)","decl":"/-- A multiplicative equivalence preserves orders of elements. -/\n@[to_additive (attr := simp) \"An additive equivalence preserves orders of elements.\"]\nlemma MulEquiv.orderOf_eq {H : Type*} [Monoid H] (e : G ≃* H) (x : G) :\n    orderOf (e x) = orderOf x :=\n  orderOf_injective e.toMonoidHom e.injective x\n\n"}
{"name":"MulEquiv.orderOf_eq","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝¹ : Monoid G\nH : Type u_6\ninst✝ : Monoid H\ne : MulEquiv G H\nx : G\n⊢ Eq (orderOf (e x)) (orderOf x)","decl":"/-- A multiplicative equivalence preserves orders of elements. -/\n@[to_additive (attr := simp) \"An additive equivalence preserves orders of elements.\"]\nlemma MulEquiv.orderOf_eq {H : Type*} [Monoid H] (e : G ≃* H) (x : G) :\n    orderOf (e x) = orderOf x :=\n  orderOf_injective e.toMonoidHom e.injective x\n\n"}
{"name":"Function.Injective.isOfFinAddOrder_iff","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\nH : Type u_2\ninst✝¹ : AddMonoid G\nx : G\ninst✝ : AddMonoid H\nf : AddMonoidHom G H\nhf : Function.Injective ⇑f\n⊢ Iff (IsOfFinAddOrder (f x)) (IsOfFinAddOrder x)","decl":"@[to_additive]\ntheorem Function.Injective.isOfFinOrder_iff [Monoid H] {f : G →* H} (hf : Injective f) :\n    IsOfFinOrder (f x) ↔ IsOfFinOrder x := by\n  rw [← orderOf_pos_iff, orderOf_injective f hf x, ← orderOf_pos_iff]\n\n"}
{"name":"Function.Injective.isOfFinOrder_iff","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\nH : Type u_2\ninst✝¹ : Monoid G\nx : G\ninst✝ : Monoid H\nf : MonoidHom G H\nhf : Function.Injective ⇑f\n⊢ Iff (IsOfFinOrder (f x)) (IsOfFinOrder x)","decl":"@[to_additive]\ntheorem Function.Injective.isOfFinOrder_iff [Monoid H] {f : G →* H} (hf : Injective f) :\n    IsOfFinOrder (f x) ↔ IsOfFinOrder x := by\n  rw [← orderOf_pos_iff, orderOf_injective f hf x, ← orderOf_pos_iff]\n\n"}
{"name":"orderOf_submonoid","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝ : Monoid G\nH : Submonoid G\ny : Subtype fun x => Membership.mem H x\n⊢ Eq (orderOf ↑y) (orderOf y)","decl":"@[to_additive (attr := norm_cast, simp)]\ntheorem orderOf_submonoid {H : Submonoid G} (y : H) : orderOf (y : G) = orderOf y :=\n  orderOf_injective H.subtype Subtype.coe_injective y\n\n"}
{"name":"addOrderOf_addSubmonoid","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝ : AddMonoid G\nH : AddSubmonoid G\ny : Subtype fun x => Membership.mem H x\n⊢ Eq (addOrderOf ↑y) (addOrderOf y)","decl":"@[to_additive (attr := norm_cast, simp)]\ntheorem orderOf_submonoid {H : Submonoid G} (y : H) : orderOf (y : G) = orderOf y :=\n  orderOf_injective H.subtype Subtype.coe_injective y\n\n"}
{"name":"addOrderOf_addUnits","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝ : AddMonoid G\ny : AddUnits G\n⊢ Eq (addOrderOf ↑y) (addOrderOf y)","decl":"@[to_additive]\ntheorem orderOf_units {y : Gˣ} : orderOf (y : G) = orderOf y :=\n  orderOf_injective (Units.coeHom G) Units.ext y\n\n"}
{"name":"orderOf_units","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝ : Monoid G\ny : Units G\n⊢ Eq (orderOf ↑y) (orderOf y)","decl":"@[to_additive]\ntheorem orderOf_units {y : Gˣ} : orderOf (y : G) = orderOf y :=\n  orderOf_injective (Units.coeHom G) Units.ext y\n\n"}
{"name":"IsOfFinOrder.val_unit","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"M : Type u_6\ninst✝ : Monoid M\nx : M\nhx : IsOfFinOrder x\n⊢ Eq (↑hx.unit) x","decl":"/-- If the order of `x` is finite, then `x` is a unit with inverse `x ^ (orderOf x - 1)`. -/\n@[simps]\nnoncomputable\ndef IsOfFinOrder.unit {M} [Monoid M] {x : M} (hx : IsOfFinOrder x) : Mˣ :=\n⟨x, x ^ (orderOf x - 1),\n  by rw [← _root_.pow_succ', tsub_add_cancel_of_le (by exact hx.orderOf_pos), pow_orderOf_eq_one],\n  by rw [← _root_.pow_succ, tsub_add_cancel_of_le (by exact hx.orderOf_pos), pow_orderOf_eq_one]⟩\n\n"}
{"name":"IsOfFinOrder.val_inv_unit","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"M : Type u_6\ninst✝ : Monoid M\nx : M\nhx : IsOfFinOrder x\n⊢ Eq (↑(Inv.inv hx.unit)) (HPow.hPow x (HSub.hSub (orderOf x) 1))","decl":"/-- If the order of `x` is finite, then `x` is a unit with inverse `x ^ (orderOf x - 1)`. -/\n@[simps]\nnoncomputable\ndef IsOfFinOrder.unit {M} [Monoid M] {x : M} (hx : IsOfFinOrder x) : Mˣ :=\n⟨x, x ^ (orderOf x - 1),\n  by rw [← _root_.pow_succ', tsub_add_cancel_of_le (by exact hx.orderOf_pos), pow_orderOf_eq_one],\n  by rw [← _root_.pow_succ, tsub_add_cancel_of_le (by exact hx.orderOf_pos), pow_orderOf_eq_one]⟩\n\n"}
{"name":"IsOfFinOrder.isUnit","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"M : Type u_6\ninst✝ : Monoid M\nx : M\nhx : IsOfFinOrder x\n⊢ IsUnit x","decl":"lemma IsOfFinOrder.isUnit {M} [Monoid M] {x : M} (hx : IsOfFinOrder x) : IsUnit x := ⟨hx.unit, rfl⟩\n\n"}
{"name":"orderOf_pow'","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝ : Monoid G\nx : G\nn : Nat\nh : Ne n 0\n⊢ Eq (orderOf (HPow.hPow x n)) (HDiv.hDiv (orderOf x) ((orderOf x).gcd n))","decl":"@[to_additive]\ntheorem orderOf_pow' (h : n ≠ 0) : orderOf (x ^ n) = orderOf x / gcd (orderOf x) n := by\n  unfold orderOf\n  rw [← minimalPeriod_iterate_eq_div_gcd h, mul_left_iterate]\n\n"}
{"name":"addOrderOf_nsmul'","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝ : AddMonoid G\nx : G\nn : Nat\nh : Ne n 0\n⊢ Eq (addOrderOf (HSMul.hSMul n x)) (HDiv.hDiv (addOrderOf x) ((addOrderOf x).gcd n))","decl":"@[to_additive]\ntheorem orderOf_pow' (h : n ≠ 0) : orderOf (x ^ n) = orderOf x / gcd (orderOf x) n := by\n  unfold orderOf\n  rw [← minimalPeriod_iterate_eq_div_gcd h, mul_left_iterate]\n\n"}
{"name":"addOrderOf_nsmul_of_dvd","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝ : AddMonoid G\nx : G\nn : Nat\nhn : Ne n 0\ndvd : Dvd.dvd n (addOrderOf x)\n⊢ Eq (addOrderOf (HSMul.hSMul n x)) (HDiv.hDiv (addOrderOf x) n)","decl":"@[to_additive]\nlemma orderOf_pow_of_dvd {x : G} {n : ℕ} (hn : n ≠ 0) (dvd : n ∣ orderOf x) :\n    orderOf (x ^ n) = orderOf x / n := by rw [orderOf_pow' _ hn, Nat.gcd_eq_right dvd]\n\n"}
{"name":"orderOf_pow_of_dvd","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝ : Monoid G\nx : G\nn : Nat\nhn : Ne n 0\ndvd : Dvd.dvd n (orderOf x)\n⊢ Eq (orderOf (HPow.hPow x n)) (HDiv.hDiv (orderOf x) n)","decl":"@[to_additive]\nlemma orderOf_pow_of_dvd {x : G} {n : ℕ} (hn : n ≠ 0) (dvd : n ∣ orderOf x) :\n    orderOf (x ^ n) = orderOf x / n := by rw [orderOf_pow' _ hn, Nat.gcd_eq_right dvd]\n\n"}
{"name":"addOrderOf_nsmul_addOrderOf_sub","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝ : AddMonoid G\nx : G\nn : Nat\nhx : Ne (addOrderOf x) 0\nhn : Dvd.dvd n (addOrderOf x)\n⊢ Eq (addOrderOf (HSMul.hSMul (HDiv.hDiv (addOrderOf x) n) x)) n","decl":"@[to_additive]\nlemma orderOf_pow_orderOf_div {x : G} {n : ℕ} (hx : orderOf x ≠ 0) (hn : n ∣ orderOf x) :\n    orderOf (x ^ (orderOf x / n)) = n := by\n  rw [orderOf_pow_of_dvd _ (Nat.div_dvd_of_dvd hn), Nat.div_div_self hn hx]\n  rw [← Nat.div_mul_cancel hn] at hx; exact left_ne_zero_of_mul hx\n\n"}
{"name":"orderOf_pow_orderOf_div","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝ : Monoid G\nx : G\nn : Nat\nhx : Ne (orderOf x) 0\nhn : Dvd.dvd n (orderOf x)\n⊢ Eq (orderOf (HPow.hPow x (HDiv.hDiv (orderOf x) n))) n","decl":"@[to_additive]\nlemma orderOf_pow_orderOf_div {x : G} {n : ℕ} (hx : orderOf x ≠ 0) (hn : n ∣ orderOf x) :\n    orderOf (x ^ (orderOf x / n)) = n := by\n  rw [orderOf_pow_of_dvd _ (Nat.div_dvd_of_dvd hn), Nat.div_div_self hn hx]\n  rw [← Nat.div_mul_cancel hn] at hx; exact left_ne_zero_of_mul hx\n\n"}
{"name":"IsOfFinAddOrder.addOrderOf_nsmul","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝ : AddMonoid G\nx : G\nn : Nat\nh : IsOfFinAddOrder x\n⊢ Eq (addOrderOf (HSMul.hSMul n x)) (HDiv.hDiv (addOrderOf x) ((addOrderOf x).gcd n))","decl":"@[to_additive]\nprotected lemma IsOfFinOrder.orderOf_pow (h : IsOfFinOrder x) :\n    orderOf (x ^ n) = orderOf x / gcd (orderOf x) n := by\n  unfold orderOf\n  rw [← minimalPeriod_iterate_eq_div_gcd' h, mul_left_iterate]\n\n"}
{"name":"IsOfFinOrder.orderOf_pow","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝ : Monoid G\nx : G\nn : Nat\nh : IsOfFinOrder x\n⊢ Eq (orderOf (HPow.hPow x n)) (HDiv.hDiv (orderOf x) ((orderOf x).gcd n))","decl":"@[to_additive]\nprotected lemma IsOfFinOrder.orderOf_pow (h : IsOfFinOrder x) :\n    orderOf (x ^ n) = orderOf x / gcd (orderOf x) n := by\n  unfold orderOf\n  rw [← minimalPeriod_iterate_eq_div_gcd' h, mul_left_iterate]\n\n"}
{"name":"Nat.Coprime.addOrderOf_nsmul","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝ : AddMonoid G\ny : G\nm : Nat\nh : (addOrderOf y).Coprime m\n⊢ Eq (addOrderOf (HSMul.hSMul m y)) (addOrderOf y)","decl":"@[to_additive]\nlemma Nat.Coprime.orderOf_pow (h : (orderOf y).Coprime m) : orderOf (y ^ m) = orderOf y := by\n  by_cases hg : IsOfFinOrder y\n  · rw [hg.orderOf_pow y m , h.gcd_eq_one, Nat.div_one]\n  · rw [m.coprime_zero_left.1 (orderOf_eq_zero hg ▸ h), pow_one]\n\n"}
{"name":"Nat.Coprime.orderOf_pow","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝ : Monoid G\ny : G\nm : Nat\nh : (orderOf y).Coprime m\n⊢ Eq (orderOf (HPow.hPow y m)) (orderOf y)","decl":"@[to_additive]\nlemma Nat.Coprime.orderOf_pow (h : (orderOf y).Coprime m) : orderOf (y ^ m) = orderOf y := by\n  by_cases hg : IsOfFinOrder y\n  · rw [hg.orderOf_pow y m , h.gcd_eq_one, Nat.div_one]\n  · rw [m.coprime_zero_left.1 (orderOf_eq_zero hg ▸ h), pow_one]\n\n"}
{"name":"IsOfFinAddOrder.natCard_multiples_le_addOrderOf","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝ : AddMonoid G\na : G\nha : IsOfFinAddOrder a\n⊢ LE.le (Nat.card ↑↑(AddSubmonoid.multiples a)) (addOrderOf a)","decl":"@[to_additive]\nlemma IsOfFinOrder.natCard_powers_le_orderOf (ha : IsOfFinOrder a) :\n    Nat.card (powers a : Set G) ≤ orderOf a := by\n  classical\n  simpa [ha.powers_eq_image_range_orderOf, Finset.card_range, Nat.Iio_eq_range]\n    using Finset.card_image_le (s := Finset.range (orderOf a))\n\n"}
{"name":"IsOfFinOrder.natCard_powers_le_orderOf","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝ : Monoid G\na : G\nha : IsOfFinOrder a\n⊢ LE.le (Nat.card ↑↑(Submonoid.powers a)) (orderOf a)","decl":"@[to_additive]\nlemma IsOfFinOrder.natCard_powers_le_orderOf (ha : IsOfFinOrder a) :\n    Nat.card (powers a : Set G) ≤ orderOf a := by\n  classical\n  simpa [ha.powers_eq_image_range_orderOf, Finset.card_range, Nat.Iio_eq_range]\n    using Finset.card_image_le (s := Finset.range (orderOf a))\n\n"}
{"name":"IsOfFinOrder.finite_powers","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝ : Monoid G\na : G\nha : IsOfFinOrder a\n⊢ (↑(Submonoid.powers a)).Finite","decl":"@[to_additive]\nlemma IsOfFinOrder.finite_powers (ha : IsOfFinOrder a) : (powers a : Set G).Finite := by\n  classical rw [ha.powers_eq_image_range_orderOf]; exact Finset.finite_toSet _\n\n"}
{"name":"IsOfFinAddOrder.finite_multiples","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝ : AddMonoid G\na : G\nha : IsOfFinAddOrder a\n⊢ (↑(AddSubmonoid.multiples a)).Finite","decl":"@[to_additive]\nlemma IsOfFinOrder.finite_powers (ha : IsOfFinOrder a) : (powers a : Set G).Finite := by\n  classical rw [ha.powers_eq_image_range_orderOf]; exact Finset.finite_toSet _\n\n"}
{"name":"Commute.orderOf_mul_dvd_lcm","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝ : Monoid G\nx y : G\nh : Commute x y\n⊢ Dvd.dvd (orderOf (HMul.hMul x y)) ((orderOf x).lcm (orderOf y))","decl":"@[to_additive]\ntheorem orderOf_mul_dvd_lcm (h : Commute x y) :\n    orderOf (x * y) ∣ Nat.lcm (orderOf x) (orderOf y) := by\n  rw [orderOf, ← comp_mul_left]\n  exact Function.Commute.minimalPeriod_of_comp_dvd_lcm h.function_commute_mul_left\n\n"}
{"name":"AddCommute.addOrderOf_add_dvd_lcm","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝ : AddMonoid G\nx y : G\nh : AddCommute x y\n⊢ Dvd.dvd (addOrderOf (HAdd.hAdd x y)) ((addOrderOf x).lcm (addOrderOf y))","decl":"@[to_additive]\ntheorem orderOf_mul_dvd_lcm (h : Commute x y) :\n    orderOf (x * y) ∣ Nat.lcm (orderOf x) (orderOf y) := by\n  rw [orderOf, ← comp_mul_left]\n  exact Function.Commute.minimalPeriod_of_comp_dvd_lcm h.function_commute_mul_left\n\n"}
{"name":"Commute.orderOf_dvd_lcm_mul","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝ : Monoid G\nx y : G\nh : Commute x y\n⊢ Dvd.dvd (orderOf y) ((orderOf x).lcm (orderOf (HMul.hMul x y)))","decl":"@[to_additive]\ntheorem orderOf_dvd_lcm_mul (h : Commute x y):\n    orderOf y ∣ Nat.lcm (orderOf x) (orderOf (x * y)) := by\n  by_cases h0 : orderOf x = 0\n  · rw [h0, lcm_zero_left]\n    apply dvd_zero\n  conv_lhs =>\n    rw [← one_mul y, ← pow_orderOf_eq_one x, ← succ_pred_eq_of_pos (Nat.pos_of_ne_zero h0),\n      _root_.pow_succ, mul_assoc]\n  exact\n    (((Commute.refl x).mul_right h).pow_left _).orderOf_mul_dvd_lcm.trans\n      (lcm_dvd_iff.2 ⟨(orderOf_pow_dvd _).trans (dvd_lcm_left _ _), dvd_lcm_right _ _⟩)\n\n"}
{"name":"AddCommute.addOrderOf_dvd_lcm_add","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝ : AddMonoid G\nx y : G\nh : AddCommute x y\n⊢ Dvd.dvd (addOrderOf y) ((addOrderOf x).lcm (addOrderOf (HAdd.hAdd x y)))","decl":"@[to_additive]\ntheorem orderOf_dvd_lcm_mul (h : Commute x y):\n    orderOf y ∣ Nat.lcm (orderOf x) (orderOf (x * y)) := by\n  by_cases h0 : orderOf x = 0\n  · rw [h0, lcm_zero_left]\n    apply dvd_zero\n  conv_lhs =>\n    rw [← one_mul y, ← pow_orderOf_eq_one x, ← succ_pred_eq_of_pos (Nat.pos_of_ne_zero h0),\n      _root_.pow_succ, mul_assoc]\n  exact\n    (((Commute.refl x).mul_right h).pow_left _).orderOf_mul_dvd_lcm.trans\n      (lcm_dvd_iff.2 ⟨(orderOf_pow_dvd _).trans (dvd_lcm_left _ _), dvd_lcm_right _ _⟩)\n\n"}
{"name":"AddCommute.addOrderOf_add_dvd_mul_addOrderOf","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝ : AddMonoid G\nx y : G\nh : AddCommute x y\n⊢ Dvd.dvd (addOrderOf (HAdd.hAdd x y)) (HMul.hMul (addOrderOf x) (addOrderOf y))","decl":"@[to_additive addOrderOf_add_dvd_mul_addOrderOf]\ntheorem orderOf_mul_dvd_mul_orderOf (h : Commute x y):\n    orderOf (x * y) ∣ orderOf x * orderOf y :=\n  dvd_trans h.orderOf_mul_dvd_lcm (lcm_dvd_mul _ _)\n\n"}
{"name":"Commute.orderOf_mul_dvd_mul_orderOf","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝ : Monoid G\nx y : G\nh : Commute x y\n⊢ Dvd.dvd (orderOf (HMul.hMul x y)) (HMul.hMul (orderOf x) (orderOf y))","decl":"@[to_additive addOrderOf_add_dvd_mul_addOrderOf]\ntheorem orderOf_mul_dvd_mul_orderOf (h : Commute x y):\n    orderOf (x * y) ∣ orderOf x * orderOf y :=\n  dvd_trans h.orderOf_mul_dvd_lcm (lcm_dvd_mul _ _)\n\n"}
{"name":"AddCommute.addOrderOf_add_eq_mul_addOrderOf_of_coprime","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝ : AddMonoid G\nx y : G\nh : AddCommute x y\nhco : (addOrderOf x).Coprime (addOrderOf y)\n⊢ Eq (addOrderOf (HAdd.hAdd x y)) (HMul.hMul (addOrderOf x) (addOrderOf y))","decl":"@[to_additive addOrderOf_add_eq_mul_addOrderOf_of_coprime]\ntheorem orderOf_mul_eq_mul_orderOf_of_coprime (h : Commute x y)\n    (hco : (orderOf x).Coprime (orderOf y)) : orderOf (x * y) = orderOf x * orderOf y := by\n  rw [orderOf, ← comp_mul_left]\n  exact h.function_commute_mul_left.minimalPeriod_of_comp_eq_mul_of_coprime hco\n\n"}
{"name":"Commute.orderOf_mul_eq_mul_orderOf_of_coprime","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝ : Monoid G\nx y : G\nh : Commute x y\nhco : (orderOf x).Coprime (orderOf y)\n⊢ Eq (orderOf (HMul.hMul x y)) (HMul.hMul (orderOf x) (orderOf y))","decl":"@[to_additive addOrderOf_add_eq_mul_addOrderOf_of_coprime]\ntheorem orderOf_mul_eq_mul_orderOf_of_coprime (h : Commute x y)\n    (hco : (orderOf x).Coprime (orderOf y)) : orderOf (x * y) = orderOf x * orderOf y := by\n  rw [orderOf, ← comp_mul_left]\n  exact h.function_commute_mul_left.minimalPeriod_of_comp_eq_mul_of_coprime hco\n\n"}
{"name":"Commute.isOfFinOrder_mul","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝ : Monoid G\nx y : G\nh : Commute x y\nhx : IsOfFinOrder x\nhy : IsOfFinOrder y\n⊢ IsOfFinOrder (HMul.hMul x y)","decl":"/-- Commuting elements of finite order are closed under multiplication. -/\n@[to_additive \"Commuting elements of finite additive order are closed under addition.\"]\ntheorem isOfFinOrder_mul (h : Commute x y) (hx : IsOfFinOrder x) (hy : IsOfFinOrder y) :\n    IsOfFinOrder (x * y) :=\n  orderOf_pos_iff.mp <|\n    pos_of_dvd_of_pos h.orderOf_mul_dvd_mul_orderOf <| mul_pos hx.orderOf_pos hy.orderOf_pos\n\n"}
{"name":"AddCommute.isOfFinAddOrder_add","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝ : AddMonoid G\nx y : G\nh : AddCommute x y\nhx : IsOfFinAddOrder x\nhy : IsOfFinAddOrder y\n⊢ IsOfFinAddOrder (HAdd.hAdd x y)","decl":"/-- Commuting elements of finite order are closed under multiplication. -/\n@[to_additive \"Commuting elements of finite additive order are closed under addition.\"]\ntheorem isOfFinOrder_mul (h : Commute x y) (hx : IsOfFinOrder x) (hy : IsOfFinOrder y) :\n    IsOfFinOrder (x * y) :=\n  orderOf_pos_iff.mp <|\n    pos_of_dvd_of_pos h.orderOf_mul_dvd_mul_orderOf <| mul_pos hx.orderOf_pos hy.orderOf_pos\n\n"}
{"name":"Commute.orderOf_mul_eq_right_of_forall_prime_mul_dvd","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝ : Monoid G\nx y : G\nh : Commute x y\nhy : IsOfFinOrder y\nhdvd : ∀ (p : Nat), Nat.Prime p → Dvd.dvd p (orderOf x) → Dvd.dvd (HMul.hMul p (orderOf x)) (orderOf y)\n⊢ Eq (orderOf (HMul.hMul x y)) (orderOf y)","decl":"/-- If each prime factor of `orderOf x` has higher multiplicity in `orderOf y`, and `x` commutes\n  with `y`, then `x * y` has the same order as `y`. -/\n@[to_additive addOrderOf_add_eq_right_of_forall_prime_mul_dvd\n  \"If each prime factor of\n  `addOrderOf x` has higher multiplicity in `addOrderOf y`, and `x` commutes with `y`,\n  then `x + y` has the same order as `y`.\"]\ntheorem orderOf_mul_eq_right_of_forall_prime_mul_dvd (h : Commute x y) (hy : IsOfFinOrder y)\n    (hdvd : ∀ p : ℕ, p.Prime → p ∣ orderOf x → p * orderOf x ∣ orderOf y) :\n    orderOf (x * y) = orderOf y := by\n  have hoy := hy.orderOf_pos\n  have hxy := dvd_of_forall_prime_mul_dvd hdvd\n  apply orderOf_eq_of_pow_and_pow_div_prime hoy <;> simp only [Ne, ← orderOf_dvd_iff_pow_eq_one]\n  · exact h.orderOf_mul_dvd_lcm.trans (lcm_dvd hxy dvd_rfl)\n  refine fun p hp hpy hd => hp.ne_one ?_\n  rw [← Nat.dvd_one, ← mul_dvd_mul_iff_right hoy.ne', one_mul, ← dvd_div_iff_mul_dvd hpy]\n  refine (orderOf_dvd_lcm_mul h).trans (lcm_dvd ((dvd_div_iff_mul_dvd hpy).2 ?_) hd)\n  by_cases h : p ∣ orderOf x\n  exacts [hdvd p hp h, (hp.coprime_iff_not_dvd.2 h).mul_dvd_of_dvd_of_dvd hpy hxy]\n\n"}
{"name":"AddCommute.addOrderOf_add_eq_right_of_forall_prime_mul_dvd","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝ : AddMonoid G\nx y : G\nh : AddCommute x y\nhy : IsOfFinAddOrder y\nhdvd : ∀ (p : Nat), Nat.Prime p → Dvd.dvd p (addOrderOf x) → Dvd.dvd (HMul.hMul p (addOrderOf x)) (addOrderOf y)\n⊢ Eq (addOrderOf (HAdd.hAdd x y)) (addOrderOf y)","decl":"/-- If each prime factor of `orderOf x` has higher multiplicity in `orderOf y`, and `x` commutes\n  with `y`, then `x * y` has the same order as `y`. -/\n@[to_additive addOrderOf_add_eq_right_of_forall_prime_mul_dvd\n  \"If each prime factor of\n  `addOrderOf x` has higher multiplicity in `addOrderOf y`, and `x` commutes with `y`,\n  then `x + y` has the same order as `y`.\"]\ntheorem orderOf_mul_eq_right_of_forall_prime_mul_dvd (h : Commute x y) (hy : IsOfFinOrder y)\n    (hdvd : ∀ p : ℕ, p.Prime → p ∣ orderOf x → p * orderOf x ∣ orderOf y) :\n    orderOf (x * y) = orderOf y := by\n  have hoy := hy.orderOf_pos\n  have hxy := dvd_of_forall_prime_mul_dvd hdvd\n  apply orderOf_eq_of_pow_and_pow_div_prime hoy <;> simp only [Ne, ← orderOf_dvd_iff_pow_eq_one]\n  · exact h.orderOf_mul_dvd_lcm.trans (lcm_dvd hxy dvd_rfl)\n  refine fun p hp hpy hd => hp.ne_one ?_\n  rw [← Nat.dvd_one, ← mul_dvd_mul_iff_right hoy.ne', one_mul, ← dvd_div_iff_mul_dvd hpy]\n  refine (orderOf_dvd_lcm_mul h).trans (lcm_dvd ((dvd_div_iff_mul_dvd hpy).2 ?_) hd)\n  by_cases h : p ∣ orderOf x\n  exacts [hdvd p hp h, (hp.coprime_iff_not_dvd.2 h).mul_dvd_of_dvd_of_dvd hpy hxy]\n\n"}
{"name":"orderOf_eq_prime","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝ : Monoid G\nx : G\np : Nat\nhp : Fact (Nat.Prime p)\nhg : Eq (HPow.hPow x p) 1\nhg1 : Ne x 1\n⊢ Eq (orderOf x) p","decl":"@[to_additive]\ntheorem orderOf_eq_prime (hg : x ^ p = 1) (hg1 : x ≠ 1) : orderOf x = p :=\n  minimalPeriod_eq_prime ((isPeriodicPt_mul_iff_pow_eq_one _).mpr hg)\n    (by rwa [IsFixedPt, mul_one])\n\n"}
{"name":"addOrderOf_eq_prime","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝ : AddMonoid G\nx : G\np : Nat\nhp : Fact (Nat.Prime p)\nhg : Eq (HSMul.hSMul p x) 0\nhg1 : Ne x 0\n⊢ Eq (addOrderOf x) p","decl":"@[to_additive]\ntheorem orderOf_eq_prime (hg : x ^ p = 1) (hg1 : x ≠ 1) : orderOf x = p :=\n  minimalPeriod_eq_prime ((isPeriodicPt_mul_iff_pow_eq_one _).mpr hg)\n    (by rwa [IsFixedPt, mul_one])\n\n"}
{"name":"addOrderOf_eq_prime_pow","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝ : AddMonoid G\nx : G\nn p : Nat\nhp : Fact (Nat.Prime p)\nhnot : Not (Eq (HSMul.hSMul (HPow.hPow p n) x) 0)\nhfin : Eq (HSMul.hSMul (HPow.hPow p (HAdd.hAdd n 1)) x) 0\n⊢ Eq (addOrderOf x) (HPow.hPow p (HAdd.hAdd n 1))","decl":"@[to_additive addOrderOf_eq_prime_pow]\ntheorem orderOf_eq_prime_pow (hnot : ¬x ^ p ^ n = 1) (hfin : x ^ p ^ (n + 1) = 1) :\n    orderOf x = p ^ (n + 1) := by\n  apply minimalPeriod_eq_prime_pow <;> rwa [isPeriodicPt_mul_iff_pow_eq_one]\n\n"}
{"name":"orderOf_eq_prime_pow","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝ : Monoid G\nx : G\nn p : Nat\nhp : Fact (Nat.Prime p)\nhnot : Not (Eq (HPow.hPow x (HPow.hPow p n)) 1)\nhfin : Eq (HPow.hPow x (HPow.hPow p (HAdd.hAdd n 1))) 1\n⊢ Eq (orderOf x) (HPow.hPow p (HAdd.hAdd n 1))","decl":"@[to_additive addOrderOf_eq_prime_pow]\ntheorem orderOf_eq_prime_pow (hnot : ¬x ^ p ^ n = 1) (hfin : x ^ p ^ (n + 1) = 1) :\n    orderOf x = p ^ (n + 1) := by\n  apply minimalPeriod_eq_prime_pow <;> rwa [isPeriodicPt_mul_iff_pow_eq_one]\n\n"}
{"name":"exists_orderOf_eq_prime_pow_iff","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝ : Monoid G\nx : G\np : Nat\nhp : Fact (Nat.Prime p)\n⊢ Iff (Exists fun k => Eq (orderOf x) (HPow.hPow p k)) (Exists fun m => Eq (HPow.hPow x (HPow.hPow p m)) 1)","decl":"@[to_additive exists_addOrderOf_eq_prime_pow_iff]\ntheorem exists_orderOf_eq_prime_pow_iff :\n    (∃ k : ℕ, orderOf x = p ^ k) ↔ ∃ m : ℕ, x ^ (p : ℕ) ^ m = 1 :=\n  ⟨fun ⟨k, hk⟩ => ⟨k, by rw [← hk, pow_orderOf_eq_one]⟩, fun ⟨_, hm⟩ => by\n    obtain ⟨k, _, hk⟩ := (Nat.dvd_prime_pow hp.elim).mp (orderOf_dvd_of_pow_eq_one hm)\n    exact ⟨k, hk⟩⟩\n\n"}
{"name":"exists_addOrderOf_eq_prime_pow_iff","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝ : AddMonoid G\nx : G\np : Nat\nhp : Fact (Nat.Prime p)\n⊢ Iff (Exists fun k => Eq (addOrderOf x) (HPow.hPow p k)) (Exists fun m => Eq (HSMul.hSMul (HPow.hPow p m) x) 0)","decl":"@[to_additive exists_addOrderOf_eq_prime_pow_iff]\ntheorem exists_orderOf_eq_prime_pow_iff :\n    (∃ k : ℕ, orderOf x = p ^ k) ↔ ∃ m : ℕ, x ^ (p : ℕ) ^ m = 1 :=\n  ⟨fun ⟨k, hk⟩ => ⟨k, by rw [← hk, pow_orderOf_eq_one]⟩, fun ⟨_, hm⟩ => by\n    obtain ⟨k, _, hk⟩ := (Nat.dvd_prime_pow hp.elim).mp (orderOf_dvd_of_pow_eq_one hm)\n    exact ⟨k, hk⟩⟩\n\n"}
{"name":"nsmul_eq_nsmul_iff_modEq","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝ : AddLeftCancelMonoid G\nx : G\nm n : Nat\n⊢ Iff (Eq (HSMul.hSMul n x) (HSMul.hSMul m x)) ((addOrderOf x).ModEq n m)","decl":"@[to_additive]\ntheorem pow_eq_pow_iff_modEq : x ^ n = x ^ m ↔ n ≡ m [MOD orderOf x] := by\n  wlog hmn : m ≤ n generalizing m n\n  · rw [eq_comm, ModEq.comm, this (le_of_not_le hmn)]\n  obtain ⟨k, rfl⟩ := Nat.exists_eq_add_of_le hmn\n  rw [← mul_one (x ^ m), pow_add, mul_left_cancel_iff, pow_eq_one_iff_modEq]\n  exact ⟨fun h => Nat.ModEq.add_left _ h, fun h => Nat.ModEq.add_left_cancel' _ h⟩\n\n"}
{"name":"pow_eq_pow_iff_modEq","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝ : LeftCancelMonoid G\nx : G\nm n : Nat\n⊢ Iff (Eq (HPow.hPow x n) (HPow.hPow x m)) ((orderOf x).ModEq n m)","decl":"@[to_additive]\ntheorem pow_eq_pow_iff_modEq : x ^ n = x ^ m ↔ n ≡ m [MOD orderOf x] := by\n  wlog hmn : m ≤ n generalizing m n\n  · rw [eq_comm, ModEq.comm, this (le_of_not_le hmn)]\n  obtain ⟨k, rfl⟩ := Nat.exists_eq_add_of_le hmn\n  rw [← mul_one (x ^ m), pow_add, mul_left_cancel_iff, pow_eq_one_iff_modEq]\n  exact ⟨fun h => Nat.ModEq.add_left _ h, fun h => Nat.ModEq.add_left_cancel' _ h⟩\n\n"}
{"name":"injective_pow_iff_not_isOfFinOrder","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝ : LeftCancelMonoid G\nx : G\n⊢ Iff (Function.Injective fun n => HPow.hPow x n) (Not (IsOfFinOrder x))","decl":"@[to_additive (attr := simp)]\nlemma injective_pow_iff_not_isOfFinOrder : Injective (fun n : ℕ ↦ x ^ n) ↔ ¬IsOfFinOrder x := by\n  refine ⟨fun h => not_isOfFinOrder_of_injective_pow h, fun h n m hnm => ?_⟩\n  rwa [pow_eq_pow_iff_modEq, orderOf_eq_zero_iff.mpr h, modEq_zero_iff] at hnm\n\n"}
{"name":"injective_nsmul_iff_not_isOfFinAddOrder","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝ : AddLeftCancelMonoid G\nx : G\n⊢ Iff (Function.Injective fun n => HSMul.hSMul n x) (Not (IsOfFinAddOrder x))","decl":"@[to_additive (attr := simp)]\nlemma injective_pow_iff_not_isOfFinOrder : Injective (fun n : ℕ ↦ x ^ n) ↔ ¬IsOfFinOrder x := by\n  refine ⟨fun h => not_isOfFinOrder_of_injective_pow h, fun h n m hnm => ?_⟩\n  rwa [pow_eq_pow_iff_modEq, orderOf_eq_zero_iff.mpr h, modEq_zero_iff] at hnm\n\n"}
{"name":"nsmul_inj_mod","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝ : AddLeftCancelMonoid G\nx : G\nn m : Nat\n⊢ Iff (Eq (HSMul.hSMul n x) (HSMul.hSMul m x)) (Eq (HMod.hMod n (addOrderOf x)) (HMod.hMod m (addOrderOf x)))","decl":"@[to_additive]\nlemma pow_inj_mod {n m : ℕ} : x ^ n = x ^ m ↔ n % orderOf x = m % orderOf x := pow_eq_pow_iff_modEq\n\n"}
{"name":"pow_inj_mod","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝ : LeftCancelMonoid G\nx : G\nn m : Nat\n⊢ Iff (Eq (HPow.hPow x n) (HPow.hPow x m)) (Eq (HMod.hMod n (orderOf x)) (HMod.hMod m (orderOf x)))","decl":"@[to_additive]\nlemma pow_inj_mod {n m : ℕ} : x ^ n = x ^ m ↔ n % orderOf x = m % orderOf x := pow_eq_pow_iff_modEq\n\n"}
{"name":"nsmul_inj_iff_of_addOrderOf_eq_zero","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝ : AddLeftCancelMonoid G\nx : G\nh : Eq (addOrderOf x) 0\nn m : Nat\n⊢ Iff (Eq (HSMul.hSMul n x) (HSMul.hSMul m x)) (Eq n m)","decl":"@[to_additive]\ntheorem pow_inj_iff_of_orderOf_eq_zero (h : orderOf x = 0) {n m : ℕ} : x ^ n = x ^ m ↔ n = m := by\n  rw [pow_eq_pow_iff_modEq, h, modEq_zero_iff]\n\n"}
{"name":"pow_inj_iff_of_orderOf_eq_zero","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝ : LeftCancelMonoid G\nx : G\nh : Eq (orderOf x) 0\nn m : Nat\n⊢ Iff (Eq (HPow.hPow x n) (HPow.hPow x m)) (Eq n m)","decl":"@[to_additive]\ntheorem pow_inj_iff_of_orderOf_eq_zero (h : orderOf x = 0) {n m : ℕ} : x ^ n = x ^ m ↔ n = m := by\n  rw [pow_eq_pow_iff_modEq, h, modEq_zero_iff]\n\n"}
{"name":"infinite_not_isOfFinOrder","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝ : LeftCancelMonoid G\nx : G\nh : Not (IsOfFinOrder x)\n⊢ (setOf fun y => Not (IsOfFinOrder y)).Infinite","decl":"@[to_additive]\ntheorem infinite_not_isOfFinOrder {x : G} (h : ¬IsOfFinOrder x) :\n    { y : G | ¬IsOfFinOrder y }.Infinite := by\n  let s := { n | 0 < n }.image fun n : ℕ => x ^ n\n  have hs : s ⊆ { y : G | ¬IsOfFinOrder y } := by\n    rintro - ⟨n, hn : 0 < n, rfl⟩ (contra : IsOfFinOrder (x ^ n))\n    apply h\n    rw [isOfFinOrder_iff_pow_eq_one] at contra ⊢\n    obtain ⟨m, hm, hm'⟩ := contra\n    exact ⟨n * m, mul_pos hn hm, by rwa [pow_mul]⟩\n  suffices s.Infinite by exact this.mono hs\n  contrapose! h\n  have : ¬Injective fun n : ℕ => x ^ n := by\n    have := Set.not_injOn_infinite_finite_image (Set.Ioi_infinite 0) (Set.not_infinite.mp h)\n    contrapose! this\n    exact Set.injOn_of_injective this\n  rwa [injective_pow_iff_not_isOfFinOrder, Classical.not_not] at this\n\n"}
{"name":"infinite_not_isOfFinAddOrder","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝ : AddLeftCancelMonoid G\nx : G\nh : Not (IsOfFinAddOrder x)\n⊢ (setOf fun y => Not (IsOfFinAddOrder y)).Infinite","decl":"@[to_additive]\ntheorem infinite_not_isOfFinOrder {x : G} (h : ¬IsOfFinOrder x) :\n    { y : G | ¬IsOfFinOrder y }.Infinite := by\n  let s := { n | 0 < n }.image fun n : ℕ => x ^ n\n  have hs : s ⊆ { y : G | ¬IsOfFinOrder y } := by\n    rintro - ⟨n, hn : 0 < n, rfl⟩ (contra : IsOfFinOrder (x ^ n))\n    apply h\n    rw [isOfFinOrder_iff_pow_eq_one] at contra ⊢\n    obtain ⟨m, hm, hm'⟩ := contra\n    exact ⟨n * m, mul_pos hn hm, by rwa [pow_mul]⟩\n  suffices s.Infinite by exact this.mono hs\n  contrapose! h\n  have : ¬Injective fun n : ℕ => x ^ n := by\n    have := Set.not_injOn_infinite_finite_image (Set.Ioi_infinite 0) (Set.not_infinite.mp h)\n    contrapose! this\n    exact Set.injOn_of_injective this\n  rwa [injective_pow_iff_not_isOfFinOrder, Classical.not_not] at this\n\n"}
{"name":"finite_powers","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝ : LeftCancelMonoid G\na : G\n⊢ Iff (↑(Submonoid.powers a)).Finite (IsOfFinOrder a)","decl":"@[to_additive (attr := simp)]\nlemma finite_powers : (powers a : Set G).Finite ↔ IsOfFinOrder a := by\n  refine ⟨fun h ↦ ?_, IsOfFinOrder.finite_powers⟩\n  obtain ⟨m, n, hmn, ha⟩ := h.exists_lt_map_eq_of_forall_mem (f := fun n : ℕ ↦ a ^ n)\n    (fun n ↦ by simp [mem_powers_iff])\n  refine isOfFinOrder_iff_pow_eq_one.2 ⟨n - m, tsub_pos_iff_lt.2 hmn, ?_⟩\n  rw [← mul_left_cancel_iff (a := a ^ m), ← pow_add, add_tsub_cancel_of_le hmn.le, ha, mul_one]\n\n"}
{"name":"finite_multiples","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝ : AddLeftCancelMonoid G\na : G\n⊢ Iff (↑(AddSubmonoid.multiples a)).Finite (IsOfFinAddOrder a)","decl":"@[to_additive (attr := simp)]\nlemma finite_powers : (powers a : Set G).Finite ↔ IsOfFinOrder a := by\n  refine ⟨fun h ↦ ?_, IsOfFinOrder.finite_powers⟩\n  obtain ⟨m, n, hmn, ha⟩ := h.exists_lt_map_eq_of_forall_mem (f := fun n : ℕ ↦ a ^ n)\n    (fun n ↦ by simp [mem_powers_iff])\n  refine isOfFinOrder_iff_pow_eq_one.2 ⟨n - m, tsub_pos_iff_lt.2 hmn, ?_⟩\n  rw [← mul_left_cancel_iff (a := a ^ m), ← pow_add, add_tsub_cancel_of_le hmn.le, ha, mul_one]\n\n"}
{"name":"infinite_multiples","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝ : AddLeftCancelMonoid G\na : G\n⊢ Iff (↑(AddSubmonoid.multiples a)).Infinite (Not (IsOfFinAddOrder a))","decl":"@[to_additive (attr := simp)]\nlemma infinite_powers : (powers a : Set G).Infinite ↔ ¬ IsOfFinOrder a := finite_powers.not\n\n"}
{"name":"infinite_powers","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝ : LeftCancelMonoid G\na : G\n⊢ Iff (↑(Submonoid.powers a)).Infinite (Not (IsOfFinOrder a))","decl":"@[to_additive (attr := simp)]\nlemma infinite_powers : (powers a : Set G).Infinite ↔ ¬ IsOfFinOrder a := finite_powers.not\n\n"}
{"name":"finEquivMultiples_apply","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝ : AddLeftCancelMonoid G\nx : G\nhx : IsOfFinAddOrder x\nn : Fin (addOrderOf x)\n⊢ Eq ((finEquivMultiples x hx) n) ⟨HSMul.hSMul (↑n) x, ⋯⟩","decl":"@[to_additive (attr := simp)]\nlemma finEquivPowers_apply (x : G) (hx) {n : Fin (orderOf x)} :\n    finEquivPowers x hx n = ⟨x ^ (n : ℕ), n, rfl⟩ := rfl\n\n"}
{"name":"finEquivPowers_apply","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝ : LeftCancelMonoid G\nx : G\nhx : IsOfFinOrder x\nn : Fin (orderOf x)\n⊢ Eq ((finEquivPowers x hx) n) ⟨HPow.hPow x ↑n, ⋯⟩","decl":"@[to_additive (attr := simp)]\nlemma finEquivPowers_apply (x : G) (hx) {n : Fin (orderOf x)} :\n    finEquivPowers x hx n = ⟨x ^ (n : ℕ), n, rfl⟩ := rfl\n\n"}
{"name":"finEquivPowers_symm_apply","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝ : LeftCancelMonoid G\nx : G\nhx : IsOfFinOrder x\nn : Nat\nhn : Exists fun m => Eq (HPow.hPow x m) (HPow.hPow x n)\n⊢ Eq ((finEquivPowers x hx).symm ⟨HPow.hPow x n, hn⟩) ⟨HMod.hMod n (orderOf x), ⋯⟩","decl":"@[to_additive (attr := simp)]\nlemma finEquivPowers_symm_apply (x : G) (hx) (n : ℕ) {hn : ∃ m : ℕ, x ^ m = x ^ n} :\n    (finEquivPowers x hx).symm ⟨x ^ n, hn⟩ = ⟨n % orderOf x, Nat.mod_lt _ hx.orderOf_pos⟩ := by\n  rw [Equiv.symm_apply_eq, finEquivPowers_apply, Subtype.mk_eq_mk, ← pow_mod_orderOf, Fin.val_mk]\n\n"}
{"name":"finEquivMultiples_symm_apply","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝ : AddLeftCancelMonoid G\nx : G\nhx : IsOfFinAddOrder x\nn : Nat\nhn : Exists fun m => Eq (HSMul.hSMul m x) (HSMul.hSMul n x)\n⊢ Eq ((finEquivMultiples x hx).symm ⟨HSMul.hSMul n x, hn⟩) ⟨HMod.hMod n (addOrderOf x), ⋯⟩","decl":"@[to_additive (attr := simp)]\nlemma finEquivPowers_symm_apply (x : G) (hx) (n : ℕ) {hn : ∃ m : ℕ, x ^ m = x ^ n} :\n    (finEquivPowers x hx).symm ⟨x ^ n, hn⟩ = ⟨n % orderOf x, Nat.mod_lt _ hx.orderOf_pos⟩ := by\n  rw [Equiv.symm_apply_eq, finEquivPowers_apply, Subtype.mk_eq_mk, ← pow_mod_orderOf, Fin.val_mk]\n\n"}
{"name":"Nat.card_submonoidPowers","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝ : LeftCancelMonoid G\na : G\n⊢ Eq (Nat.card (Subtype fun x => Membership.mem (Submonoid.powers a) x)) (orderOf a)","decl":"/-- See also `orderOf_eq_card_powers`. -/\n@[to_additive \"See also `addOrder_eq_card_multiples`.\"]\nlemma Nat.card_submonoidPowers : Nat.card (powers a) = orderOf a := by\n  classical\n  by_cases ha : IsOfFinOrder a\n  · exact (Nat.card_congr (finEquivPowers _ ha).symm).trans <| by simp\n  · have := (infinite_powers.2 ha).to_subtype\n    rw [orderOf_eq_zero ha, Nat.card_eq_zero_of_infinite]\n\n"}
{"name":"Nat.card_addSubmonoidMultiples","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝ : AddLeftCancelMonoid G\na : G\n⊢ Eq (Nat.card (Subtype fun x => Membership.mem (AddSubmonoid.multiples a) x)) (addOrderOf a)","decl":"/-- See also `orderOf_eq_card_powers`. -/\n@[to_additive \"See also `addOrder_eq_card_multiples`.\"]\nlemma Nat.card_submonoidPowers : Nat.card (powers a) = orderOf a := by\n  classical\n  by_cases ha : IsOfFinOrder a\n  · exact (Nat.card_congr (finEquivPowers _ ha).symm).trans <| by simp\n  · have := (infinite_powers.2 ha).to_subtype\n    rw [orderOf_eq_zero ha, Nat.card_eq_zero_of_infinite]\n\n"}
{"name":"isOfFinAddOrder_neg_iff","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nx : G\n⊢ Iff (IsOfFinAddOrder (Neg.neg x)) (IsOfFinAddOrder x)","decl":"/-- Inverses of elements of finite order have finite order. -/\n@[to_additive (attr := simp) \"Inverses of elements of finite additive order\nhave finite additive order.\"]\ntheorem isOfFinOrder_inv_iff {x : G} : IsOfFinOrder x⁻¹ ↔ IsOfFinOrder x := by\n  simp [isOfFinOrder_iff_pow_eq_one]\n\n"}
{"name":"isOfFinOrder_inv_iff","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝ : Group G\nx : G\n⊢ Iff (IsOfFinOrder (Inv.inv x)) (IsOfFinOrder x)","decl":"/-- Inverses of elements of finite order have finite order. -/\n@[to_additive (attr := simp) \"Inverses of elements of finite additive order\nhave finite additive order.\"]\ntheorem isOfFinOrder_inv_iff {x : G} : IsOfFinOrder x⁻¹ ↔ IsOfFinOrder x := by\n  simp [isOfFinOrder_iff_pow_eq_one]\n\n"}
{"name":"IsOfFinAddOrder.neg","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nx : G\na✝ : IsOfFinAddOrder x\n⊢ IsOfFinAddOrder (Neg.neg x)","decl":"@[to_additive] alias ⟨IsOfFinOrder.of_inv, IsOfFinOrder.inv⟩ := isOfFinOrder_inv_iff\n\n"}
{"name":"IsOfFinOrder.inv","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝ : Group G\nx : G\na✝ : IsOfFinOrder x\n⊢ IsOfFinOrder (Inv.inv x)","decl":"@[to_additive] alias ⟨IsOfFinOrder.of_inv, IsOfFinOrder.inv⟩ := isOfFinOrder_inv_iff\n\n"}
{"name":"IsOfFinAddOrder.of_neg","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nx : G\na✝ : IsOfFinAddOrder (Neg.neg x)\n⊢ IsOfFinAddOrder x","decl":"@[to_additive] alias ⟨IsOfFinOrder.of_inv, IsOfFinOrder.inv⟩ := isOfFinOrder_inv_iff\n\n"}
{"name":"IsOfFinOrder.of_inv","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝ : Group G\nx : G\na✝ : IsOfFinOrder (Inv.inv x)\n⊢ IsOfFinOrder x","decl":"@[to_additive] alias ⟨IsOfFinOrder.of_inv, IsOfFinOrder.inv⟩ := isOfFinOrder_inv_iff\n\n"}
{"name":"orderOf_dvd_iff_zpow_eq_one","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝ : Group G\nx : G\ni : Int\n⊢ Iff (Dvd.dvd (↑(orderOf x)) i) (Eq (HPow.hPow x i) 1)","decl":"@[to_additive]\ntheorem orderOf_dvd_iff_zpow_eq_one : (orderOf x : ℤ) ∣ i ↔ x ^ i = 1 := by\n  rcases Int.eq_nat_or_neg i with ⟨i, rfl | rfl⟩\n  · rw [Int.natCast_dvd_natCast, orderOf_dvd_iff_pow_eq_one, zpow_natCast]\n  · rw [dvd_neg, Int.natCast_dvd_natCast, zpow_neg, inv_eq_one, zpow_natCast,\n      orderOf_dvd_iff_pow_eq_one]\n\n"}
{"name":"addOrderOf_dvd_iff_zsmul_eq_zero","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nx : G\ni : Int\n⊢ Iff (Dvd.dvd (↑(addOrderOf x)) i) (Eq (HSMul.hSMul i x) 0)","decl":"@[to_additive]\ntheorem orderOf_dvd_iff_zpow_eq_one : (orderOf x : ℤ) ∣ i ↔ x ^ i = 1 := by\n  rcases Int.eq_nat_or_neg i with ⟨i, rfl | rfl⟩\n  · rw [Int.natCast_dvd_natCast, orderOf_dvd_iff_pow_eq_one, zpow_natCast]\n  · rw [dvd_neg, Int.natCast_dvd_natCast, zpow_neg, inv_eq_one, zpow_natCast,\n      orderOf_dvd_iff_pow_eq_one]\n\n"}
{"name":"addOrderOf_neg","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nx : G\n⊢ Eq (addOrderOf (Neg.neg x)) (addOrderOf x)","decl":"@[to_additive (attr := simp)]\ntheorem orderOf_inv (x : G) : orderOf x⁻¹ = orderOf x := by simp [orderOf_eq_orderOf_iff]\n\n"}
{"name":"orderOf_inv","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝ : Group G\nx : G\n⊢ Eq (orderOf (Inv.inv x)) (orderOf x)","decl":"@[to_additive (attr := simp)]\ntheorem orderOf_inv (x : G) : orderOf x⁻¹ = orderOf x := by simp [orderOf_eq_orderOf_iff]\n\n"}
{"name":"orderOf_dvd_sub_iff_zpow_eq_zpow","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝ : Group G\nx : G\na b : Int\n⊢ Iff (Dvd.dvd (↑(orderOf x)) (HSub.hSub a b)) (Eq (HPow.hPow x a) (HPow.hPow x b))","decl":"@[to_additive]\ntheorem orderOf_dvd_sub_iff_zpow_eq_zpow {a b : ℤ} : (orderOf x : ℤ) ∣ a - b ↔ x ^ a = x ^ b := by\n  rw [orderOf_dvd_iff_zpow_eq_one, zpow_sub, mul_inv_eq_one]\n\n"}
{"name":"addOrderOf_dvd_sub_iff_zsmul_eq_zsmul","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nx : G\na b : Int\n⊢ Iff (Dvd.dvd (↑(addOrderOf x)) (HSub.hSub a b)) (Eq (HSMul.hSMul a x) (HSMul.hSMul b x))","decl":"@[to_additive]\ntheorem orderOf_dvd_sub_iff_zpow_eq_zpow {a b : ℤ} : (orderOf x : ℤ) ∣ a - b ↔ x ^ a = x ^ b := by\n  rw [orderOf_dvd_iff_zpow_eq_one, zpow_sub, mul_inv_eq_one]\n\n"}
{"name":"Subgroup.orderOf_coe","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝ : Group G\nH : Subgroup G\na : Subtype fun x => Membership.mem H x\n⊢ Eq (orderOf ↑a) (orderOf a)","decl":"@[to_additive (attr := norm_cast)]\nlemma orderOf_coe (a : H) : orderOf (a : G) = orderOf a :=\n  orderOf_injective H.subtype Subtype.coe_injective _\n\n"}
{"name":"AddSubgroup.addOrderOf_coe","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH : AddSubgroup G\na : Subtype fun x => Membership.mem H x\n⊢ Eq (addOrderOf ↑a) (addOrderOf a)","decl":"@[to_additive (attr := norm_cast)]\nlemma orderOf_coe (a : H) : orderOf (a : G) = orderOf a :=\n  orderOf_injective H.subtype Subtype.coe_injective _\n\n"}
{"name":"AddSubgroup.addOrderOf_mk","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH : AddSubgroup G\na : G\nha : Membership.mem H a\n⊢ Eq (addOrderOf ⟨a, ha⟩) (addOrderOf a)","decl":"@[to_additive (attr := simp)]\nlemma orderOf_mk (a : G) (ha) : orderOf (⟨a, ha⟩ : H) = orderOf a := (orderOf_coe _).symm\n\n"}
{"name":"Subgroup.orderOf_mk","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝ : Group G\nH : Subgroup G\na : G\nha : Membership.mem H a\n⊢ Eq (orderOf ⟨a, ha⟩) (orderOf a)","decl":"@[to_additive (attr := simp)]\nlemma orderOf_mk (a : G) (ha) : orderOf (⟨a, ha⟩ : H) = orderOf a := (orderOf_coe _).symm\n\n"}
{"name":"mod_addOrderOf_zsmul","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nx : G\nz : Int\n⊢ Eq (HSMul.hSMul (HMod.hMod z ↑(addOrderOf x)) x) (HSMul.hSMul z x)","decl":"@[to_additive mod_addOrderOf_zsmul]\nlemma zpow_mod_orderOf (x : G) (z : ℤ) : x ^ (z % (orderOf x : ℤ)) = x ^ z :=\n  calc\n    x ^ (z % (orderOf x : ℤ)) = x ^ (z % orderOf x + orderOf x * (z / orderOf x) : ℤ) := by\n        simp [zpow_add, zpow_mul, pow_orderOf_eq_one]\n    _ = x ^ z := by rw [Int.emod_add_ediv]\n\n"}
{"name":"zpow_mod_orderOf","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝ : Group G\nx : G\nz : Int\n⊢ Eq (HPow.hPow x (HMod.hMod z ↑(orderOf x))) (HPow.hPow x z)","decl":"@[to_additive mod_addOrderOf_zsmul]\nlemma zpow_mod_orderOf (x : G) (z : ℤ) : x ^ (z % (orderOf x : ℤ)) = x ^ z :=\n  calc\n    x ^ (z % (orderOf x : ℤ)) = x ^ (z % orderOf x + orderOf x * (z / orderOf x) : ℤ) := by\n        simp [zpow_add, zpow_mul, pow_orderOf_eq_one]\n    _ = x ^ z := by rw [Int.emod_add_ediv]\n\n"}
{"name":"zpow_pow_orderOf","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝ : Group G\nx : G\ni : Int\n⊢ Eq (HPow.hPow (HPow.hPow x i) (orderOf x)) 1","decl":"@[to_additive (attr := simp) zsmul_smul_addOrderOf]\ntheorem zpow_pow_orderOf : (x ^ i) ^ orderOf x = 1 := by\n  by_cases h : IsOfFinOrder x\n  · rw [← zpow_natCast, ← zpow_mul, mul_comm, zpow_mul, zpow_natCast, pow_orderOf_eq_one, one_zpow]\n  · rw [orderOf_eq_zero h, _root_.pow_zero]\n\n"}
{"name":"zsmul_smul_addOrderOf","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nx : G\ni : Int\n⊢ Eq (HSMul.hSMul (addOrderOf x) (HSMul.hSMul i x)) 0","decl":"@[to_additive (attr := simp) zsmul_smul_addOrderOf]\ntheorem zpow_pow_orderOf : (x ^ i) ^ orderOf x = 1 := by\n  by_cases h : IsOfFinOrder x\n  · rw [← zpow_natCast, ← zpow_mul, mul_comm, zpow_mul, zpow_natCast, pow_orderOf_eq_one, one_zpow]\n  · rw [orderOf_eq_zero h, _root_.pow_zero]\n\n"}
{"name":"IsOfFinOrder.zpow","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝ : Group G\nx : G\nh : IsOfFinOrder x\ni : Int\n⊢ IsOfFinOrder (HPow.hPow x i)","decl":"@[to_additive]\ntheorem IsOfFinOrder.zpow (h : IsOfFinOrder x) {i : ℤ} : IsOfFinOrder (x ^ i) :=\n  isOfFinOrder_iff_pow_eq_one.mpr ⟨orderOf x, h.orderOf_pos, zpow_pow_orderOf⟩\n\n"}
{"name":"IsOfFinAddOrder.zsmul","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nx : G\nh : IsOfFinAddOrder x\ni : Int\n⊢ IsOfFinAddOrder (HSMul.hSMul i x)","decl":"@[to_additive]\ntheorem IsOfFinOrder.zpow (h : IsOfFinOrder x) {i : ℤ} : IsOfFinOrder (x ^ i) :=\n  isOfFinOrder_iff_pow_eq_one.mpr ⟨orderOf x, h.orderOf_pos, zpow_pow_orderOf⟩\n\n"}
{"name":"IsOfFinOrder.of_mem_zpowers","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝ : Group G\nx y : G\nh : IsOfFinOrder x\nh' : Membership.mem (Subgroup.zpowers x) y\n⊢ IsOfFinOrder y","decl":"@[to_additive]\ntheorem IsOfFinOrder.of_mem_zpowers (h : IsOfFinOrder x) (h' : y ∈ Subgroup.zpowers x) :\n    IsOfFinOrder y := by\n  obtain ⟨k, rfl⟩ := Subgroup.mem_zpowers_iff.mp h'\n  exact h.zpow\n\n"}
{"name":"IsOfFinAddOrder.of_mem_zmultiples","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nx y : G\nh : IsOfFinAddOrder x\nh' : Membership.mem (AddSubgroup.zmultiples x) y\n⊢ IsOfFinAddOrder y","decl":"@[to_additive]\ntheorem IsOfFinOrder.of_mem_zpowers (h : IsOfFinOrder x) (h' : y ∈ Subgroup.zpowers x) :\n    IsOfFinOrder y := by\n  obtain ⟨k, rfl⟩ := Subgroup.mem_zpowers_iff.mp h'\n  exact h.zpow\n\n"}
{"name":"orderOf_dvd_of_mem_zpowers","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝ : Group G\nx y : G\nh : Membership.mem (Subgroup.zpowers x) y\n⊢ Dvd.dvd (orderOf y) (orderOf x)","decl":"@[to_additive]\ntheorem orderOf_dvd_of_mem_zpowers (h : y ∈ Subgroup.zpowers x) : orderOf y ∣ orderOf x := by\n  obtain ⟨k, rfl⟩ := Subgroup.mem_zpowers_iff.mp h\n  rw [orderOf_dvd_iff_pow_eq_one]\n  exact zpow_pow_orderOf\n\n"}
{"name":"addOrderOf_dvd_of_mem_zmultiples","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nx y : G\nh : Membership.mem (AddSubgroup.zmultiples x) y\n⊢ Dvd.dvd (addOrderOf y) (addOrderOf x)","decl":"@[to_additive]\ntheorem orderOf_dvd_of_mem_zpowers (h : y ∈ Subgroup.zpowers x) : orderOf y ∣ orderOf x := by\n  obtain ⟨k, rfl⟩ := Subgroup.mem_zpowers_iff.mp h\n  rw [orderOf_dvd_iff_pow_eq_one]\n  exact zpow_pow_orderOf\n\n"}
{"name":"smul_eq_self_of_mem_zpowers","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nx y : G\nα : Type u_6\ninst✝ : MulAction G α\nhx : Membership.mem (Subgroup.zpowers y) x\na : α\nhs : Eq (HSMul.hSMul y a) a\n⊢ Eq (HSMul.hSMul x a) a","decl":"theorem smul_eq_self_of_mem_zpowers {α : Type*} [MulAction G α] (hx : x ∈ Subgroup.zpowers y)\n    {a : α} (hs : y • a = a) : x • a = a := by\n  obtain ⟨k, rfl⟩ := Subgroup.mem_zpowers_iff.mp hx\n  rw [← MulAction.toPerm_apply, ← MulAction.toPermHom_apply, MonoidHom.map_zpow _ y k,\n    MulAction.toPermHom_apply]\n  exact Function.IsFixedPt.perm_zpow (by exact hs) k -- Porting note: help elab'n with `by exact`\n\n"}
{"name":"vadd_eq_self_of_mem_zmultiples","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"α : Type u_6\nG : Type u_7\ninst✝¹ : AddGroup G\ninst✝ : AddAction G α\nx y : G\nhx : Membership.mem (AddSubgroup.zmultiples y) x\na : α\nhs : Eq (HVAdd.hVAdd y a) a\n⊢ Eq (HVAdd.hVAdd x a) a","decl":"theorem vadd_eq_self_of_mem_zmultiples {α G : Type*} [AddGroup G] [AddAction G α] {x y : G}\n    (hx : x ∈ AddSubgroup.zmultiples y) {a : α} (hs : y +ᵥ a = a) : x +ᵥ a = a :=\n  @smul_eq_self_of_mem_zpowers (Multiplicative G) _ _ _ α _ hx a hs\n\n"}
{"name":"IsOfFinAddOrder.mem_multiples_iff_mem_zmultiples","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nx y : G\nhx : IsOfFinAddOrder x\n⊢ Iff (Membership.mem (AddSubmonoid.multiples x) y) (Membership.mem (AddSubgroup.zmultiples x) y)","decl":"@[to_additive]\nlemma IsOfFinOrder.mem_powers_iff_mem_zpowers (hx : IsOfFinOrder x) :\n    y ∈ powers x ↔ y ∈ zpowers x :=\n  ⟨fun ⟨n, hn⟩ ↦ ⟨n, by simp_all⟩, fun ⟨i, hi⟩ ↦ ⟨(i % orderOf x).natAbs, by\n    dsimp only\n    rwa [← zpow_natCast, Int.natAbs_of_nonneg <| Int.emod_nonneg _ <|\n      Int.natCast_ne_zero_iff_pos.2 <| hx.orderOf_pos, zpow_mod_orderOf]⟩⟩\n\n"}
{"name":"IsOfFinOrder.mem_powers_iff_mem_zpowers","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝ : Group G\nx y : G\nhx : IsOfFinOrder x\n⊢ Iff (Membership.mem (Submonoid.powers x) y) (Membership.mem (Subgroup.zpowers x) y)","decl":"@[to_additive]\nlemma IsOfFinOrder.mem_powers_iff_mem_zpowers (hx : IsOfFinOrder x) :\n    y ∈ powers x ↔ y ∈ zpowers x :=\n  ⟨fun ⟨n, hn⟩ ↦ ⟨n, by simp_all⟩, fun ⟨i, hi⟩ ↦ ⟨(i % orderOf x).natAbs, by\n    dsimp only\n    rwa [← zpow_natCast, Int.natAbs_of_nonneg <| Int.emod_nonneg _ <|\n      Int.natCast_ne_zero_iff_pos.2 <| hx.orderOf_pos, zpow_mod_orderOf]⟩⟩\n\n"}
{"name":"IsOfFinOrder.powers_eq_zpowers","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝ : Group G\nx : G\nhx : IsOfFinOrder x\n⊢ Eq ↑(Submonoid.powers x) ↑(Subgroup.zpowers x)","decl":"@[to_additive]\nlemma IsOfFinOrder.powers_eq_zpowers (hx : IsOfFinOrder x) : (powers x : Set G) = zpowers x :=\n  Set.ext fun _ ↦ hx.mem_powers_iff_mem_zpowers\n\n"}
{"name":"IsOfFinAddOrder.multiples_eq_zmultiples","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nx : G\nhx : IsOfFinAddOrder x\n⊢ Eq ↑(AddSubmonoid.multiples x) ↑(AddSubgroup.zmultiples x)","decl":"@[to_additive]\nlemma IsOfFinOrder.powers_eq_zpowers (hx : IsOfFinOrder x) : (powers x : Set G) = zpowers x :=\n  Set.ext fun _ ↦ hx.mem_powers_iff_mem_zpowers\n\n"}
{"name":"IsOfFinOrder.mem_zpowers_iff_mem_range_orderOf","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nx y : G\ninst✝ : DecidableEq G\nhx : IsOfFinOrder x\n⊢ Iff (Membership.mem (Subgroup.zpowers x) y) (Membership.mem (Finset.image (fun x_1 => HPow.hPow x x_1) (Finset.range (orderOf x))) y)","decl":"@[to_additive]\nlemma IsOfFinOrder.mem_zpowers_iff_mem_range_orderOf [DecidableEq G] (hx : IsOfFinOrder x) :\n    y ∈ zpowers x ↔ y ∈ (Finset.range (orderOf x)).image (x ^ ·) :=\n  hx.mem_powers_iff_mem_zpowers.symm.trans hx.mem_powers_iff_mem_range_orderOf\n\n"}
{"name":"IsOfFinAddOrder.mem_zmultiples_iff_mem_range_addOrderOf","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nx y : G\ninst✝ : DecidableEq G\nhx : IsOfFinAddOrder x\n⊢ Iff (Membership.mem (AddSubgroup.zmultiples x) y) (Membership.mem (Finset.image (fun x_1 => HSMul.hSMul x_1 x) (Finset.range (addOrderOf x))) y)","decl":"@[to_additive]\nlemma IsOfFinOrder.mem_zpowers_iff_mem_range_orderOf [DecidableEq G] (hx : IsOfFinOrder x) :\n    y ∈ zpowers x ↔ y ∈ (Finset.range (orderOf x)).image (x ^ ·) :=\n  hx.mem_powers_iff_mem_zpowers.symm.trans hx.mem_powers_iff_mem_range_orderOf\n\n"}
{"name":"finEquivZMultiples_apply","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nx : G\nhx : IsOfFinAddOrder x\nn : Fin (addOrderOf x)\n⊢ Eq ((finEquivZMultiples x hx) n) ⟨HSMul.hSMul (↑n) x, ⋯⟩","decl":"@[to_additive]\nlemma finEquivZPowers_apply (hx) {n : Fin (orderOf x)} :\n    finEquivZPowers x hx n = ⟨x ^ (n : ℕ), n, zpow_natCast x n⟩ := rfl\n\n"}
{"name":"finEquivZPowers_apply","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝ : Group G\nx : G\nhx : IsOfFinOrder x\nn : Fin (orderOf x)\n⊢ Eq ((finEquivZPowers x hx) n) ⟨HPow.hPow x ↑n, ⋯⟩","decl":"@[to_additive]\nlemma finEquivZPowers_apply (hx) {n : Fin (orderOf x)} :\n    finEquivZPowers x hx n = ⟨x ^ (n : ℕ), n, zpow_natCast x n⟩ := rfl\n\n"}
{"name":"finEquivZMultiples_symm_apply","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nx : G\nhx : IsOfFinAddOrder x\nn : Nat\n⊢ Eq ((finEquivZMultiples x hx).symm ⟨HSMul.hSMul n x, ⋯⟩) ⟨HMod.hMod n (addOrderOf x), ⋯⟩","decl":"@[to_additive]\nlemma finEquivZPowers_symm_apply (x : G) (hx) (n : ℕ) :\n    (finEquivZPowers x hx).symm ⟨x ^ n, ⟨n, by simp⟩⟩ =\n    ⟨n % orderOf x, Nat.mod_lt _ hx.orderOf_pos⟩ := by\n  rw [finEquivZPowers, Equiv.symm_trans_apply]; exact finEquivPowers_symm_apply x _ n\n\n"}
{"name":"finEquivZPowers_symm_apply","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝ : Group G\nx : G\nhx : IsOfFinOrder x\nn : Nat\n⊢ Eq ((finEquivZPowers x hx).symm ⟨HPow.hPow x n, ⋯⟩) ⟨HMod.hMod n (orderOf x), ⋯⟩","decl":"@[to_additive]\nlemma finEquivZPowers_symm_apply (x : G) (hx) (n : ℕ) :\n    (finEquivZPowers x hx).symm ⟨x ^ n, ⟨n, by simp⟩⟩ =\n    ⟨n % orderOf x, Nat.mod_lt _ hx.orderOf_pos⟩ := by\n  rw [finEquivZPowers, Equiv.symm_trans_apply]; exact finEquivPowers_symm_apply x _ n\n\n"}
{"name":"IsOfFinAddOrder.add","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝ : AddCommMonoid G\nx y : G\nhx : IsOfFinAddOrder x\nhy : IsOfFinAddOrder y\n⊢ IsOfFinAddOrder (HAdd.hAdd x y)","decl":"/-- Elements of finite order are closed under multiplication. -/\n@[to_additive \"Elements of finite additive order are closed under addition.\"]\ntheorem IsOfFinOrder.mul (hx : IsOfFinOrder x) (hy : IsOfFinOrder y) : IsOfFinOrder (x * y) :=\n  (Commute.all x y).isOfFinOrder_mul hx hy\n\n"}
{"name":"IsOfFinOrder.mul","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝ : CommMonoid G\nx y : G\nhx : IsOfFinOrder x\nhy : IsOfFinOrder y\n⊢ IsOfFinOrder (HMul.hMul x y)","decl":"/-- Elements of finite order are closed under multiplication. -/\n@[to_additive \"Elements of finite additive order are closed under addition.\"]\ntheorem IsOfFinOrder.mul (hx : IsOfFinOrder x) (hy : IsOfFinOrder y) : IsOfFinOrder (x * y) :=\n  (Commute.all x y).isOfFinOrder_mul hx hy\n\n"}
{"name":"sum_card_addOrderOf_eq_card_nsmul_eq_zero","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝² : AddMonoid G\nn : Nat\ninst✝¹ : Fintype G\ninst✝ : DecidableEq G\nhn : Ne n 0\n⊢ Eq (n.divisors.sum fun m => (Finset.filter (fun x => Eq (addOrderOf x) m) Finset.univ).card) (Finset.filter (fun x => Eq (HSMul.hSMul n x) 0) Finset.univ).card","decl":"@[to_additive]\ntheorem sum_card_orderOf_eq_card_pow_eq_one [Fintype G] [DecidableEq G] (hn : n ≠ 0) :\n    (∑ m ∈ divisors n,\n        (Finset.univ.filter fun x : G => orderOf x = m).card) =\n      (Finset.univ.filter fun x : G => x ^ n = 1).card := by\n  refine (Finset.card_biUnion ?_).symm.trans ?_\n  · simp +contextual [disjoint_iff, Finset.ext_iff]\n  · congr; ext; simp [hn, orderOf_dvd_iff_pow_eq_one]\n\n"}
{"name":"sum_card_orderOf_eq_card_pow_eq_one","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝² : Monoid G\nn : Nat\ninst✝¹ : Fintype G\ninst✝ : DecidableEq G\nhn : Ne n 0\n⊢ Eq (n.divisors.sum fun m => (Finset.filter (fun x => Eq (orderOf x) m) Finset.univ).card) (Finset.filter (fun x => Eq (HPow.hPow x n) 1) Finset.univ).card","decl":"@[to_additive]\ntheorem sum_card_orderOf_eq_card_pow_eq_one [Fintype G] [DecidableEq G] (hn : n ≠ 0) :\n    (∑ m ∈ divisors n,\n        (Finset.univ.filter fun x : G => orderOf x = m).card) =\n      (Finset.univ.filter fun x : G => x ^ n = 1).card := by\n  refine (Finset.card_biUnion ?_).symm.trans ?_\n  · simp +contextual [disjoint_iff, Finset.ext_iff]\n  · congr; ext; simp [hn, orderOf_dvd_iff_pow_eq_one]\n\n"}
{"name":"orderOf_le_card_univ","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝¹ : Monoid G\nx : G\ninst✝ : Fintype G\n⊢ LE.le (orderOf x) (Fintype.card G)","decl":"@[to_additive]\ntheorem orderOf_le_card_univ [Fintype G] : orderOf x ≤ Fintype.card G :=\n  Finset.le_card_of_inj_on_range (x ^ ·) (fun _ _ ↦ Finset.mem_univ _) pow_injOn_Iio_orderOf\n\n"}
{"name":"addOrderOf_le_card_univ","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝¹ : AddMonoid G\nx : G\ninst✝ : Fintype G\n⊢ LE.le (addOrderOf x) (Fintype.card G)","decl":"@[to_additive]\ntheorem orderOf_le_card_univ [Fintype G] : orderOf x ≤ Fintype.card G :=\n  Finset.le_card_of_inj_on_range (x ^ ·) (fun _ _ ↦ Finset.mem_univ _) pow_injOn_Iio_orderOf\n\n"}
{"name":"orderOf_le_card","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝¹ : Monoid G\nx : G\ninst✝ : Finite G\n⊢ LE.le (orderOf x) (Nat.card G)","decl":"@[to_additive]\ntheorem orderOf_le_card [Finite G] : orderOf x ≤ Nat.card G := by\n  obtain ⟨⟩ := nonempty_fintype G\n  simpa using orderOf_le_card_univ\n\n"}
{"name":"addOrderOf_le_card","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝¹ : AddMonoid G\nx : G\ninst✝ : Finite G\n⊢ LE.le (addOrderOf x) (Nat.card G)","decl":"@[to_additive]\ntheorem orderOf_le_card [Finite G] : orderOf x ≤ Nat.card G := by\n  obtain ⟨⟩ := nonempty_fintype G\n  simpa using orderOf_le_card_univ\n\n"}
{"name":"isOfFinOrder_of_finite","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝¹ : LeftCancelMonoid G\ninst✝ : Finite G\nx : G\n⊢ IsOfFinOrder x","decl":"@[to_additive]\nlemma isOfFinOrder_of_finite (x : G) : IsOfFinOrder x := by\n  by_contra h; exact infinite_not_isOfFinOrder h <| Set.toFinite _\n\n"}
{"name":"isOfFinAddOrder_of_finite","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝¹ : AddLeftCancelMonoid G\ninst✝ : Finite G\nx : G\n⊢ IsOfFinAddOrder x","decl":"@[to_additive]\nlemma isOfFinOrder_of_finite (x : G) : IsOfFinOrder x := by\n  by_contra h; exact infinite_not_isOfFinOrder h <| Set.toFinite _\n\n"}
{"name":"orderOf_pos","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝¹ : LeftCancelMonoid G\ninst✝ : Finite G\nx : G\n⊢ LT.lt 0 (orderOf x)","decl":"/-- This is the same as `IsOfFinOrder.orderOf_pos` but with one fewer explicit assumption since this\nis automatic in case of a finite cancellative monoid. -/\n@[to_additive \"This is the same as `IsOfFinAddOrder.addOrderOf_pos` but with one fewer explicit\nassumption since this is automatic in case of a finite cancellative additive monoid.\"]\nlemma orderOf_pos (x : G) : 0 < orderOf x := (isOfFinOrder_of_finite x).orderOf_pos\n\n"}
{"name":"addOrderOf_pos","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝¹ : AddLeftCancelMonoid G\ninst✝ : Finite G\nx : G\n⊢ LT.lt 0 (addOrderOf x)","decl":"/-- This is the same as `IsOfFinOrder.orderOf_pos` but with one fewer explicit assumption since this\nis automatic in case of a finite cancellative monoid. -/\n@[to_additive \"This is the same as `IsOfFinAddOrder.addOrderOf_pos` but with one fewer explicit\nassumption since this is automatic in case of a finite cancellative additive monoid.\"]\nlemma orderOf_pos (x : G) : 0 < orderOf x := (isOfFinOrder_of_finite x).orderOf_pos\n\n"}
{"name":"addOrderOf_nsmul","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝¹ : AddLeftCancelMonoid G\ninst✝ : Finite G\nn : Nat\nx : G\n⊢ Eq (addOrderOf (HSMul.hSMul n x)) (HDiv.hDiv (addOrderOf x) ((addOrderOf x).gcd n))","decl":"/-- This is the same as `orderOf_pow'` and `orderOf_pow''` but with one assumption less which is\nautomatic in the case of a finite cancellative monoid. -/\n@[to_additive \"This is the same as `addOrderOf_nsmul'` and\n`addOrderOf_nsmul` but with one assumption less which is automatic in the case of a\nfinite cancellative additive monoid.\"]\ntheorem orderOf_pow (x : G) : orderOf (x ^ n) = orderOf x / gcd (orderOf x) n :=\n  (isOfFinOrder_of_finite _).orderOf_pow ..\n\n"}
{"name":"orderOf_pow","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝¹ : LeftCancelMonoid G\ninst✝ : Finite G\nn : Nat\nx : G\n⊢ Eq (orderOf (HPow.hPow x n)) (HDiv.hDiv (orderOf x) ((orderOf x).gcd n))","decl":"/-- This is the same as `orderOf_pow'` and `orderOf_pow''` but with one assumption less which is\nautomatic in the case of a finite cancellative monoid. -/\n@[to_additive \"This is the same as `addOrderOf_nsmul'` and\n`addOrderOf_nsmul` but with one assumption less which is automatic in the case of a\nfinite cancellative additive monoid.\"]\ntheorem orderOf_pow (x : G) : orderOf (x ^ n) = orderOf x / gcd (orderOf x) n :=\n  (isOfFinOrder_of_finite _).orderOf_pow ..\n\n"}
{"name":"mem_multiples_iff_mem_range_addOrderOf","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝² : AddLeftCancelMonoid G\ninst✝¹ : Finite G\nx y : G\ninst✝ : DecidableEq G\n⊢ Iff (Membership.mem (AddSubmonoid.multiples x) y) (Membership.mem (Finset.image (fun x_1 => HSMul.hSMul x_1 x) (Finset.range (addOrderOf x))) y)","decl":"@[to_additive]\ntheorem mem_powers_iff_mem_range_orderOf [DecidableEq G] :\n    y ∈ powers x ↔ y ∈ (Finset.range (orderOf x)).image (x ^ ·) :=\n  Finset.mem_range_iff_mem_finset_range_of_mod_eq' (orderOf_pos x) <| pow_mod_orderOf _\n\n"}
{"name":"mem_powers_iff_mem_range_orderOf","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝² : LeftCancelMonoid G\ninst✝¹ : Finite G\nx y : G\ninst✝ : DecidableEq G\n⊢ Iff (Membership.mem (Submonoid.powers x) y) (Membership.mem (Finset.image (fun x_1 => HPow.hPow x x_1) (Finset.range (orderOf x))) y)","decl":"@[to_additive]\ntheorem mem_powers_iff_mem_range_orderOf [DecidableEq G] :\n    y ∈ powers x ↔ y ∈ (Finset.range (orderOf x)).image (x ^ ·) :=\n  Finset.mem_range_iff_mem_finset_range_of_mod_eq' (orderOf_pos x) <| pow_mod_orderOf _\n\n"}
{"name":"powersEquivPowers_apply","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝¹ : LeftCancelMonoid G\ninst✝ : Finite G\nx y : G\nh : Eq (orderOf x) (orderOf y)\nn : Nat\n⊢ Eq ((powersEquivPowers h) ⟨HPow.hPow x n, ⋯⟩) ⟨HPow.hPow y n, ⋯⟩","decl":"@[to_additive (attr := simp)]\ntheorem powersEquivPowers_apply (h : orderOf x = orderOf y) (n : ℕ) :\n    powersEquivPowers h ⟨x ^ n, n, rfl⟩ = ⟨y ^ n, n, rfl⟩ := by\n  rw [powersEquivPowers, Equiv.trans_apply, Equiv.trans_apply, finEquivPowers_symm_apply, ←\n    Equiv.eq_symm_apply, finEquivPowers_symm_apply]\n  simp [h]\n\n"}
{"name":"multiplesEquivMultiples_apply","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝¹ : AddLeftCancelMonoid G\ninst✝ : Finite G\nx y : G\nh : Eq (addOrderOf x) (addOrderOf y)\nn : Nat\n⊢ Eq ((multiplesEquivMultiples h) ⟨HSMul.hSMul n x, ⋯⟩) ⟨HSMul.hSMul n y, ⋯⟩","decl":"@[to_additive (attr := simp)]\ntheorem powersEquivPowers_apply (h : orderOf x = orderOf y) (n : ℕ) :\n    powersEquivPowers h ⟨x ^ n, n, rfl⟩ = ⟨y ^ n, n, rfl⟩ := by\n  rw [powersEquivPowers, Equiv.trans_apply, Equiv.trans_apply, finEquivPowers_symm_apply, ←\n    Equiv.eq_symm_apply, finEquivPowers_symm_apply]\n  simp [h]\n\n"}
{"name":"addOrderOf_eq_card_multiples","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝¹ : AddLeftCancelMonoid G\ninst✝ : Fintype G\nx : G\n⊢ Eq (addOrderOf x) (Fintype.card (Subtype fun x_1 => Membership.mem (AddSubmonoid.multiples x) x_1))","decl":"@[to_additive]\nlemma orderOf_eq_card_powers : orderOf x = Fintype.card (powers x : Submonoid G) :=\n  (Fintype.card_fin (orderOf x)).symm.trans <|\n    Fintype.card_eq.2 ⟨finEquivPowers x <| isOfFinOrder_of_finite _⟩\n\n"}
{"name":"orderOf_eq_card_powers","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝¹ : LeftCancelMonoid G\ninst✝ : Fintype G\nx : G\n⊢ Eq (orderOf x) (Fintype.card (Subtype fun x_1 => Membership.mem (Submonoid.powers x) x_1))","decl":"@[to_additive]\nlemma orderOf_eq_card_powers : orderOf x = Fintype.card (powers x : Submonoid G) :=\n  (Fintype.card_fin (orderOf x)).symm.trans <|\n    Fintype.card_eq.2 ⟨finEquivPowers x <| isOfFinOrder_of_finite _⟩\n\n"}
{"name":"zsmul_eq_zero_iff_modEq","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nx : G\nn : Int\n⊢ Iff (Eq (HSMul.hSMul n x) 0) ((↑(addOrderOf x)).ModEq n 0)","decl":"@[to_additive]\ntheorem zpow_eq_one_iff_modEq {n : ℤ} : x ^ n = 1 ↔ n ≡ 0 [ZMOD orderOf x] := by\n  rw [Int.modEq_zero_iff_dvd, orderOf_dvd_iff_zpow_eq_one]\n\n\n"}
{"name":"zpow_eq_one_iff_modEq","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝ : Group G\nx : G\nn : Int\n⊢ Iff (Eq (HPow.hPow x n) 1) ((↑(orderOf x)).ModEq n 0)","decl":"@[to_additive]\ntheorem zpow_eq_one_iff_modEq {n : ℤ} : x ^ n = 1 ↔ n ≡ 0 [ZMOD orderOf x] := by\n  rw [Int.modEq_zero_iff_dvd, orderOf_dvd_iff_zpow_eq_one]\n\n\n"}
{"name":"zpow_eq_zpow_iff_modEq","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝ : Group G\nx : G\nm n : Int\n⊢ Iff (Eq (HPow.hPow x m) (HPow.hPow x n)) ((↑(orderOf x)).ModEq m n)","decl":"@[to_additive]\ntheorem zpow_eq_zpow_iff_modEq {m n : ℤ} : x ^ m = x ^ n ↔ m ≡ n [ZMOD orderOf x] := by\n  rw [← mul_inv_eq_one, ← zpow_sub, zpow_eq_one_iff_modEq, Int.modEq_iff_dvd, Int.modEq_iff_dvd,\n    zero_sub, neg_sub]\n\n"}
{"name":"zsmul_eq_zsmul_iff_modEq","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nx : G\nm n : Int\n⊢ Iff (Eq (HSMul.hSMul m x) (HSMul.hSMul n x)) ((↑(addOrderOf x)).ModEq m n)","decl":"@[to_additive]\ntheorem zpow_eq_zpow_iff_modEq {m n : ℤ} : x ^ m = x ^ n ↔ m ≡ n [ZMOD orderOf x] := by\n  rw [← mul_inv_eq_one, ← zpow_sub, zpow_eq_one_iff_modEq, Int.modEq_iff_dvd, Int.modEq_iff_dvd,\n    zero_sub, neg_sub]\n\n"}
{"name":"injective_zpow_iff_not_isOfFinOrder","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝ : Group G\nx : G\n⊢ Iff (Function.Injective fun n => HPow.hPow x n) (Not (IsOfFinOrder x))","decl":"@[to_additive (attr := simp)]\ntheorem injective_zpow_iff_not_isOfFinOrder : (Injective fun n : ℤ => x ^ n) ↔ ¬IsOfFinOrder x := by\n  refine ⟨?_, fun h n m hnm => ?_⟩\n  · simp_rw [isOfFinOrder_iff_pow_eq_one]\n    rintro h ⟨n, hn, hx⟩\n    exact Nat.cast_ne_zero.2 hn.ne' (h <| by simpa using hx)\n  rwa [zpow_eq_zpow_iff_modEq, orderOf_eq_zero_iff.2 h, Nat.cast_zero, Int.modEq_zero_iff] at hnm\n\n"}
{"name":"injective_zsmul_iff_not_isOfFinAddOrder","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nx : G\n⊢ Iff (Function.Injective fun n => HSMul.hSMul n x) (Not (IsOfFinAddOrder x))","decl":"@[to_additive (attr := simp)]\ntheorem injective_zpow_iff_not_isOfFinOrder : (Injective fun n : ℤ => x ^ n) ↔ ¬IsOfFinOrder x := by\n  refine ⟨?_, fun h n m hnm => ?_⟩\n  · simp_rw [isOfFinOrder_iff_pow_eq_one]\n    rintro h ⟨n, hn, hx⟩\n    exact Nat.cast_ne_zero.2 hn.ne' (h <| by simpa using hx)\n  rwa [zpow_eq_zpow_iff_modEq, orderOf_eq_zero_iff.2 h, Nat.cast_zero, Int.modEq_zero_iff] at hnm\n\n"}
{"name":"exists_zsmul_eq_zero","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\ninst✝ : Finite G\nx : G\n⊢ Exists fun i => Exists fun x_1 => Eq (HSMul.hSMul i x) 0","decl":"@[to_additive]\ntheorem exists_zpow_eq_one (x : G) : ∃ (i : ℤ) (_ : i ≠ 0), x ^ (i : ℤ) = 1 := by\n  obtain ⟨w, hw1, hw2⟩ := isOfFinOrder_of_finite x\n  refine ⟨w, Int.natCast_ne_zero.mpr (_root_.ne_of_gt hw1), ?_⟩\n  rw [zpow_natCast]\n  exact (isPeriodicPt_mul_iff_pow_eq_one _).mp hw2\n\n"}
{"name":"exists_zpow_eq_one","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝¹ : Group G\ninst✝ : Finite G\nx : G\n⊢ Exists fun i => Exists fun x_1 => Eq (HPow.hPow x i) 1","decl":"@[to_additive]\ntheorem exists_zpow_eq_one (x : G) : ∃ (i : ℤ) (_ : i ≠ 0), x ^ (i : ℤ) = 1 := by\n  obtain ⟨w, hw1, hw2⟩ := isOfFinOrder_of_finite x\n  refine ⟨w, Int.natCast_ne_zero.mpr (_root_.ne_of_gt hw1), ?_⟩\n  rw [zpow_natCast]\n  exact (isPeriodicPt_mul_iff_pow_eq_one _).mp hw2\n\n"}
{"name":"mem_powers_iff_mem_zpowers","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nx y : G\ninst✝ : Finite G\n⊢ Iff (Membership.mem (Submonoid.powers x) y) (Membership.mem (Subgroup.zpowers x) y)","decl":"@[to_additive]\nlemma mem_powers_iff_mem_zpowers : y ∈ powers x ↔ y ∈ zpowers x :=\n  (isOfFinOrder_of_finite _).mem_powers_iff_mem_zpowers\n\n"}
{"name":"mem_multiples_iff_mem_zmultiples","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nx y : G\ninst✝ : Finite G\n⊢ Iff (Membership.mem (AddSubmonoid.multiples x) y) (Membership.mem (AddSubgroup.zmultiples x) y)","decl":"@[to_additive]\nlemma mem_powers_iff_mem_zpowers : y ∈ powers x ↔ y ∈ zpowers x :=\n  (isOfFinOrder_of_finite _).mem_powers_iff_mem_zpowers\n\n"}
{"name":"powers_eq_zpowers","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝¹ : Group G\ninst✝ : Finite G\nx : G\n⊢ Eq ↑(Submonoid.powers x) ↑(Subgroup.zpowers x)","decl":"@[to_additive]\nlemma powers_eq_zpowers (x : G) : (powers x : Set G) = zpowers x :=\n  (isOfFinOrder_of_finite _).powers_eq_zpowers\n\n"}
{"name":"multiples_eq_zmultiples","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\ninst✝ : Finite G\nx : G\n⊢ Eq ↑(AddSubmonoid.multiples x) ↑(AddSubgroup.zmultiples x)","decl":"@[to_additive]\nlemma powers_eq_zpowers (x : G) : (powers x : Set G) = zpowers x :=\n  (isOfFinOrder_of_finite _).powers_eq_zpowers\n\n"}
{"name":"mem_zmultiples_iff_mem_range_addOrderOf","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝² : AddGroup G\nx y : G\ninst✝¹ : Finite G\ninst✝ : DecidableEq G\n⊢ Iff (Membership.mem (AddSubgroup.zmultiples x) y) (Membership.mem (Finset.image (fun x_1 => HSMul.hSMul x_1 x) (Finset.range (addOrderOf x))) y)","decl":"@[to_additive]\nlemma mem_zpowers_iff_mem_range_orderOf [DecidableEq G] :\n    y ∈ zpowers x ↔ y ∈ (Finset.range (orderOf x)).image (x ^ ·) :=\n  (isOfFinOrder_of_finite _).mem_zpowers_iff_mem_range_orderOf\n\n"}
{"name":"mem_zpowers_iff_mem_range_orderOf","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝² : Group G\nx y : G\ninst✝¹ : Finite G\ninst✝ : DecidableEq G\n⊢ Iff (Membership.mem (Subgroup.zpowers x) y) (Membership.mem (Finset.image (fun x_1 => HPow.hPow x x_1) (Finset.range (orderOf x))) y)","decl":"@[to_additive]\nlemma mem_zpowers_iff_mem_range_orderOf [DecidableEq G] :\n    y ∈ zpowers x ↔ y ∈ (Finset.range (orderOf x)).image (x ^ ·) :=\n  (isOfFinOrder_of_finite _).mem_zpowers_iff_mem_range_orderOf\n\n"}
{"name":"zpowersEquivZPowers_apply","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nx y : G\ninst✝ : Finite G\nh : Eq (orderOf x) (orderOf y)\nn : Nat\n⊢ Eq ((zpowersEquivZPowers h) ⟨HPow.hPow x n, ⋯⟩) ⟨HPow.hPow y n, ⋯⟩","decl":"@[to_additive (attr := simp, nolint simpNF) zmultiples_equiv_zmultiples_apply]\ntheorem zpowersEquivZPowers_apply (h : orderOf x = orderOf y) (n : ℕ) :\n    zpowersEquivZPowers h ⟨x ^ n, n, zpow_natCast x n⟩ = ⟨y ^ n, n, zpow_natCast y n⟩ := by\n  rw [zpowersEquivZPowers, Equiv.trans_apply, Equiv.trans_apply, finEquivZPowers_symm_apply, ←\n    Equiv.eq_symm_apply, finEquivZPowers_symm_apply]\n  simp [h]\n\n"}
{"name":"zmultiples_equiv_zmultiples_apply","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nx y : G\ninst✝ : Finite G\nh : Eq (addOrderOf x) (addOrderOf y)\nn : Nat\n⊢ Eq ((zmultiplesEquivZMultiples h) ⟨HSMul.hSMul n x, ⋯⟩) ⟨HSMul.hSMul n y, ⋯⟩","decl":"@[to_additive (attr := simp, nolint simpNF) zmultiples_equiv_zmultiples_apply]\ntheorem zpowersEquivZPowers_apply (h : orderOf x = orderOf y) (n : ℕ) :\n    zpowersEquivZPowers h ⟨x ^ n, n, zpow_natCast x n⟩ = ⟨y ^ n, n, zpow_natCast y n⟩ := by\n  rw [zpowersEquivZPowers, Equiv.trans_apply, Equiv.trans_apply, finEquivZPowers_symm_apply, ←\n    Equiv.eq_symm_apply, finEquivZPowers_symm_apply]\n  simp [h]\n\n"}
{"name":"Fintype.card_zmultiples","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\ninst✝ : Fintype G\nx : G\n⊢ Eq (Fintype.card (Subtype fun x_1 => Membership.mem (AddSubgroup.zmultiples x) x_1)) (addOrderOf x)","decl":"/-- See also `Nat.card_addSubgroupZPowers`. -/\n@[to_additive \"See also `Nat.card_subgroup`.\"]\ntheorem Fintype.card_zpowers : Fintype.card (zpowers x) = orderOf x :=\n  letI : Fintype (zpowers x) := (Subgroup.zpowers x).instFintypeSubtypeMemOfDecidablePred\n  (Fintype.card_eq.2 ⟨finEquivZPowers x <| isOfFinOrder_of_finite _⟩).symm.trans <|\n    Fintype.card_fin (orderOf x)\n\n"}
{"name":"Fintype.card_zpowers","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝¹ : Group G\ninst✝ : Fintype G\nx : G\n⊢ Eq (Fintype.card (Subtype fun x_1 => Membership.mem (Subgroup.zpowers x) x_1)) (orderOf x)","decl":"/-- See also `Nat.card_addSubgroupZPowers`. -/\n@[to_additive \"See also `Nat.card_subgroup`.\"]\ntheorem Fintype.card_zpowers : Fintype.card (zpowers x) = orderOf x :=\n  letI : Fintype (zpowers x) := (Subgroup.zpowers x).instFintypeSubtypeMemOfDecidablePred\n  (Fintype.card_eq.2 ⟨finEquivZPowers x <| isOfFinOrder_of_finite _⟩).symm.trans <|\n    Fintype.card_fin (orderOf x)\n\n"}
{"name":"card_zpowers_le","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝¹ : Group G\ninst✝ : Fintype G\na : G\nk : Nat\nk_pos : Ne k 0\nha : Eq (HPow.hPow a k) 1\n⊢ LE.le (Fintype.card (Subtype fun x => Membership.mem (Subgroup.zpowers a) x)) k","decl":"@[to_additive]\ntheorem card_zpowers_le (a : G) {k : ℕ} (k_pos : k ≠ 0)\n    (ha : a ^ k = 1) : Fintype.card (Subgroup.zpowers a) ≤ k := by\n  rw [Fintype.card_zpowers]\n  apply orderOf_le_of_pow_eq_one k_pos.bot_lt ha\n\n"}
{"name":"card_zmultiples_le","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\ninst✝ : Fintype G\na : G\nk : Nat\nk_pos : Ne k 0\nha : Eq (HSMul.hSMul k a) 0\n⊢ LE.le (Fintype.card (Subtype fun x => Membership.mem (AddSubgroup.zmultiples a) x)) k","decl":"@[to_additive]\ntheorem card_zpowers_le (a : G) {k : ℕ} (k_pos : k ≠ 0)\n    (ha : a ^ k = 1) : Fintype.card (Subgroup.zpowers a) ≤ k := by\n  rw [Fintype.card_zpowers]\n  apply orderOf_le_of_pow_eq_one k_pos.bot_lt ha\n\n"}
{"name":"orderOf_dvd_card","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝¹ : Group G\ninst✝ : Fintype G\nx : G\n⊢ Dvd.dvd (orderOf x) (Fintype.card G)","decl":"@[to_additive]\ntheorem orderOf_dvd_card : orderOf x ∣ Fintype.card G := by\n  classical\n    have ft_prod : Fintype ((G ⧸ zpowers x) × zpowers x) :=\n      Fintype.ofEquiv G groupEquivQuotientProdSubgroup\n    have ft_s : Fintype (zpowers x) := @Fintype.prodRight _ _ _ ft_prod _\n    have ft_cosets : Fintype (G ⧸ zpowers x) :=\n      @Fintype.prodLeft _ _ _ ft_prod ⟨⟨1, (zpowers x).one_mem⟩⟩\n    have eq₁ : Fintype.card G = @Fintype.card _ ft_cosets * @Fintype.card _ ft_s :=\n      calc\n        Fintype.card G = @Fintype.card _ ft_prod :=\n          @Fintype.card_congr _ _ _ ft_prod groupEquivQuotientProdSubgroup\n        _ = @Fintype.card _ (@instFintypeProd _ _ ft_cosets ft_s) :=\n          congr_arg (@Fintype.card _) <| Subsingleton.elim _ _\n        _ = @Fintype.card _ ft_cosets * @Fintype.card _ ft_s :=\n          @Fintype.card_prod _ _ ft_cosets ft_s\n\n    have eq₂ : orderOf x = @Fintype.card _ ft_s :=\n      calc\n        orderOf x = _ := Fintype.card_zpowers.symm\n        _ = _ := congr_arg (@Fintype.card _) <| Subsingleton.elim _ _\n\n    exact Dvd.intro (@Fintype.card (G ⧸ Subgroup.zpowers x) ft_cosets) (by rw [eq₁, eq₂, mul_comm])\n\n"}
{"name":"addOrderOf_dvd_card","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\ninst✝ : Fintype G\nx : G\n⊢ Dvd.dvd (addOrderOf x) (Fintype.card G)","decl":"@[to_additive]\ntheorem orderOf_dvd_card : orderOf x ∣ Fintype.card G := by\n  classical\n    have ft_prod : Fintype ((G ⧸ zpowers x) × zpowers x) :=\n      Fintype.ofEquiv G groupEquivQuotientProdSubgroup\n    have ft_s : Fintype (zpowers x) := @Fintype.prodRight _ _ _ ft_prod _\n    have ft_cosets : Fintype (G ⧸ zpowers x) :=\n      @Fintype.prodLeft _ _ _ ft_prod ⟨⟨1, (zpowers x).one_mem⟩⟩\n    have eq₁ : Fintype.card G = @Fintype.card _ ft_cosets * @Fintype.card _ ft_s :=\n      calc\n        Fintype.card G = @Fintype.card _ ft_prod :=\n          @Fintype.card_congr _ _ _ ft_prod groupEquivQuotientProdSubgroup\n        _ = @Fintype.card _ (@instFintypeProd _ _ ft_cosets ft_s) :=\n          congr_arg (@Fintype.card _) <| Subsingleton.elim _ _\n        _ = @Fintype.card _ ft_cosets * @Fintype.card _ ft_s :=\n          @Fintype.card_prod _ _ ft_cosets ft_s\n\n    have eq₂ : orderOf x = @Fintype.card _ ft_s :=\n      calc\n        orderOf x = _ := Fintype.card_zpowers.symm\n        _ = _ := congr_arg (@Fintype.card _) <| Subsingleton.elim _ _\n\n    exact Dvd.intro (@Fintype.card (G ⧸ Subgroup.zpowers x) ft_cosets) (by rw [eq₁, eq₂, mul_comm])\n\n"}
{"name":"orderOf_dvd_natCard","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_6\ninst✝ : Group G\nx : G\n⊢ Dvd.dvd (orderOf x) (Nat.card G)","decl":"@[to_additive]\ntheorem orderOf_dvd_natCard {G : Type*} [Group G] (x : G) : orderOf x ∣ Nat.card G := by\n  cases' fintypeOrInfinite G with h h\n  · simp only [Nat.card_eq_fintype_card, orderOf_dvd_card]\n  · simp only [card_eq_zero_of_infinite, dvd_zero]\n\n"}
{"name":"addOrderOf_dvd_natCard","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_6\ninst✝ : AddGroup G\nx : G\n⊢ Dvd.dvd (addOrderOf x) (Nat.card G)","decl":"@[to_additive]\ntheorem orderOf_dvd_natCard {G : Type*} [Group G] (x : G) : orderOf x ∣ Nat.card G := by\n  cases' fintypeOrInfinite G with h h\n  · simp only [Nat.card_eq_fintype_card, orderOf_dvd_card]\n  · simp only [card_eq_zero_of_infinite, dvd_zero]\n\n"}
{"name":"Subgroup.orderOf_dvd_natCard","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_6\ninst✝ : Group G\ns : Subgroup G\nx : G\nhx : Membership.mem s x\n⊢ Dvd.dvd (orderOf x) (Nat.card (Subtype fun x => Membership.mem s x))","decl":"@[to_additive]\nnonrec lemma Subgroup.orderOf_dvd_natCard {G : Type*} [Group G] (s : Subgroup G) {x} (hx : x ∈ s) :\n  orderOf x ∣ Nat.card s := by simpa using orderOf_dvd_natCard (⟨x, hx⟩ : s)\n\n"}
{"name":"AddSubgroup.addOrderOf_dvd_natCard","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_6\ninst✝ : AddGroup G\ns : AddSubgroup G\nx : G\nhx : Membership.mem s x\n⊢ Dvd.dvd (addOrderOf x) (Nat.card (Subtype fun x => Membership.mem s x))","decl":"@[to_additive]\nnonrec lemma Subgroup.orderOf_dvd_natCard {G : Type*} [Group G] (s : Subgroup G) {x} (hx : x ∈ s) :\n  orderOf x ∣ Nat.card s := by simpa using orderOf_dvd_natCard (⟨x, hx⟩ : s)\n\n"}
{"name":"Subgroup.orderOf_le_card","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_6\ninst✝ : Group G\ns : Subgroup G\nhs : (↑s).Finite\nx : G\nhx : Membership.mem s x\n⊢ LE.le (orderOf x) (Nat.card (Subtype fun x => Membership.mem s x))","decl":"@[to_additive]\nlemma Subgroup.orderOf_le_card {G : Type*} [Group G] (s : Subgroup G) (hs : (s : Set G).Finite)\n    {x} (hx : x ∈ s) : orderOf x ≤ Nat.card s :=\n  le_of_dvd (Nat.card_pos_iff.2 <| ⟨s.coe_nonempty.to_subtype, hs.to_subtype⟩) <|\n    s.orderOf_dvd_natCard hx\n\n"}
{"name":"AddSubgroup.addOrderOf_le_card","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_6\ninst✝ : AddGroup G\ns : AddSubgroup G\nhs : (↑s).Finite\nx : G\nhx : Membership.mem s x\n⊢ LE.le (addOrderOf x) (Nat.card (Subtype fun x => Membership.mem s x))","decl":"@[to_additive]\nlemma Subgroup.orderOf_le_card {G : Type*} [Group G] (s : Subgroup G) (hs : (s : Set G).Finite)\n    {x} (hx : x ∈ s) : orderOf x ≤ Nat.card s :=\n  le_of_dvd (Nat.card_pos_iff.2 <| ⟨s.coe_nonempty.to_subtype, hs.to_subtype⟩) <|\n    s.orderOf_dvd_natCard hx\n\n"}
{"name":"Submonoid.orderOf_le_card","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_6\ninst✝ : Group G\ns : Submonoid G\nhs : (↑s).Finite\nx : G\nhx : Membership.mem s x\n⊢ LE.le (orderOf x) (Nat.card (Subtype fun x => Membership.mem s x))","decl":"@[to_additive]\nlemma Submonoid.orderOf_le_card {G : Type*} [Group G] (s : Submonoid G) (hs : (s : Set G).Finite)\n    {x} (hx : x ∈ s) : orderOf x ≤ Nat.card s := by\n  rw [← Nat.card_submonoidPowers]; exact Nat.card_mono hs <| powers_le.2 hx\n\n"}
{"name":"AddSubmonoid.addOrderOf_le_card","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_6\ninst✝ : AddGroup G\ns : AddSubmonoid G\nhs : (↑s).Finite\nx : G\nhx : Membership.mem s x\n⊢ LE.le (addOrderOf x) (Nat.card (Subtype fun x => Membership.mem s x))","decl":"@[to_additive]\nlemma Submonoid.orderOf_le_card {G : Type*} [Group G] (s : Submonoid G) (hs : (s : Set G).Finite)\n    {x} (hx : x ∈ s) : orderOf x ≤ Nat.card s := by\n  rw [← Nat.card_submonoidPowers]; exact Nat.card_mono hs <| powers_le.2 hx\n\n"}
{"name":"pow_card_eq_one'","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_6\ninst✝ : Group G\nx : G\n⊢ Eq (HPow.hPow x (Nat.card G)) 1","decl":"@[to_additive (attr := simp) card_nsmul_eq_zero']\ntheorem pow_card_eq_one' {G : Type*} [Group G] {x : G} : x ^ Nat.card G = 1 :=\n  orderOf_dvd_iff_pow_eq_one.mp <| orderOf_dvd_natCard _\n\n"}
{"name":"card_nsmul_eq_zero'","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_6\ninst✝ : AddGroup G\nx : G\n⊢ Eq (HSMul.hSMul (Nat.card G) x) 0","decl":"@[to_additive (attr := simp) card_nsmul_eq_zero']\ntheorem pow_card_eq_one' {G : Type*} [Group G] {x : G} : x ^ Nat.card G = 1 :=\n  orderOf_dvd_iff_pow_eq_one.mp <| orderOf_dvd_natCard _\n\n"}
{"name":"pow_card_eq_one","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝¹ : Group G\ninst✝ : Fintype G\nx : G\n⊢ Eq (HPow.hPow x (Fintype.card G)) 1","decl":"@[to_additive (attr := simp) card_nsmul_eq_zero]\ntheorem pow_card_eq_one : x ^ Fintype.card G = 1 := by\n  rw [← Nat.card_eq_fintype_card, pow_card_eq_one']\n\n"}
{"name":"card_nsmul_eq_zero","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\ninst✝ : Fintype G\nx : G\n⊢ Eq (HSMul.hSMul (Fintype.card G) x) 0","decl":"@[to_additive (attr := simp) card_nsmul_eq_zero]\ntheorem pow_card_eq_one : x ^ Fintype.card G = 1 := by\n  rw [← Nat.card_eq_fintype_card, pow_card_eq_one']\n\n"}
{"name":"AddSubgroup.nsmul_index_mem","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_6\ninst✝¹ : AddGroup G\nH : AddSubgroup G\ninst✝ : H.Normal\ng : G\n⊢ Membership.mem H (HSMul.hSMul H.index g)","decl":"@[to_additive]\ntheorem Subgroup.pow_index_mem {G : Type*} [Group G] (H : Subgroup G) [Normal H] (g : G) :\n    g ^ index H ∈ H := by rw [← eq_one_iff, QuotientGroup.mk_pow H, index, pow_card_eq_one']\n\n\n"}
{"name":"Subgroup.pow_index_mem","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_6\ninst✝¹ : Group G\nH : Subgroup G\ninst✝ : H.Normal\ng : G\n⊢ Membership.mem H (HPow.hPow g H.index)","decl":"@[to_additive]\ntheorem Subgroup.pow_index_mem {G : Type*} [Group G] (H : Subgroup G) [Normal H] (g : G) :\n    g ^ index H ∈ H := by rw [← eq_one_iff, QuotientGroup.mk_pow H, index, pow_card_eq_one']\n\n\n"}
{"name":"pow_mod_card","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝¹ : Group G\ninst✝ : Fintype G\na : G\nn : Nat\n⊢ Eq (HPow.hPow a (HMod.hMod n (Fintype.card G))) (HPow.hPow a n)","decl":"@[to_additive (attr := simp) mod_card_nsmul]\nlemma pow_mod_card (a : G) (n : ℕ) : a ^ (n % card G) = a ^ n := by\n  rw [eq_comm, ← pow_mod_orderOf, ← Nat.mod_mod_of_dvd n orderOf_dvd_card, pow_mod_orderOf]\n\n"}
{"name":"mod_card_nsmul","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\ninst✝ : Fintype G\na : G\nn : Nat\n⊢ Eq (HSMul.hSMul (HMod.hMod n (Fintype.card G)) a) (HSMul.hSMul n a)","decl":"@[to_additive (attr := simp) mod_card_nsmul]\nlemma pow_mod_card (a : G) (n : ℕ) : a ^ (n % card G) = a ^ n := by\n  rw [eq_comm, ← pow_mod_orderOf, ← Nat.mod_mod_of_dvd n orderOf_dvd_card, pow_mod_orderOf]\n\n"}
{"name":"zpow_mod_card","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝¹ : Group G\ninst✝ : Fintype G\na : G\nn : Int\n⊢ Eq (HPow.hPow a (HMod.hMod n ↑(Fintype.card G))) (HPow.hPow a n)","decl":"@[to_additive (attr := simp) mod_card_zsmul]\ntheorem zpow_mod_card (a : G) (n : ℤ) : a ^ (n % Fintype.card G : ℤ) = a ^ n := by\n  rw [eq_comm, ← zpow_mod_orderOf, ← Int.emod_emod_of_dvd n\n    (Int.natCast_dvd_natCast.2 orderOf_dvd_card), zpow_mod_orderOf]\n\n"}
{"name":"mod_card_zsmul","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\ninst✝ : Fintype G\na : G\nn : Int\n⊢ Eq (HSMul.hSMul (HMod.hMod n ↑(Fintype.card G)) a) (HSMul.hSMul n a)","decl":"@[to_additive (attr := simp) mod_card_zsmul]\ntheorem zpow_mod_card (a : G) (n : ℤ) : a ^ (n % Fintype.card G : ℤ) = a ^ n := by\n  rw [eq_comm, ← zpow_mod_orderOf, ← Int.emod_emod_of_dvd n\n    (Int.natCast_dvd_natCast.2 orderOf_dvd_card), zpow_mod_orderOf]\n\n"}
{"name":"mod_natCard_nsmul","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_6\ninst✝ : AddGroup G\na : G\nn : Nat\n⊢ Eq (HSMul.hSMul (HMod.hMod n (Nat.card G)) a) (HSMul.hSMul n a)","decl":"@[to_additive (attr := simp) mod_natCard_nsmul]\nlemma pow_mod_natCard {G} [Group G] (a : G) (n : ℕ) : a ^ (n % Nat.card G) = a ^ n := by\n  rw [eq_comm, ← pow_mod_orderOf, ← Nat.mod_mod_of_dvd n <| orderOf_dvd_natCard _, pow_mod_orderOf]\n\n"}
{"name":"pow_mod_natCard","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_6\ninst✝ : Group G\na : G\nn : Nat\n⊢ Eq (HPow.hPow a (HMod.hMod n (Nat.card G))) (HPow.hPow a n)","decl":"@[to_additive (attr := simp) mod_natCard_nsmul]\nlemma pow_mod_natCard {G} [Group G] (a : G) (n : ℕ) : a ^ (n % Nat.card G) = a ^ n := by\n  rw [eq_comm, ← pow_mod_orderOf, ← Nat.mod_mod_of_dvd n <| orderOf_dvd_natCard _, pow_mod_orderOf]\n\n"}
{"name":"mod_natCard_zsmul","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_6\ninst✝ : AddGroup G\na : G\nn : Int\n⊢ Eq (HSMul.hSMul (HMod.hMod n ↑(Nat.card G)) a) (HSMul.hSMul n a)","decl":"@[to_additive (attr := simp) mod_natCard_zsmul]\nlemma zpow_mod_natCard {G} [Group G] (a : G) (n : ℤ) : a ^ (n % Nat.card G : ℤ) = a ^ n := by\n  rw [eq_comm, ← zpow_mod_orderOf, ← Int.emod_emod_of_dvd n <|\n    Int.natCast_dvd_natCast.2 <| orderOf_dvd_natCard _, zpow_mod_orderOf]\n\n"}
{"name":"zpow_mod_natCard","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_6\ninst✝ : Group G\na : G\nn : Int\n⊢ Eq (HPow.hPow a (HMod.hMod n ↑(Nat.card G))) (HPow.hPow a n)","decl":"@[to_additive (attr := simp) mod_natCard_zsmul]\nlemma zpow_mod_natCard {G} [Group G] (a : G) (n : ℤ) : a ^ (n % Nat.card G : ℤ) = a ^ n := by\n  rw [eq_comm, ← zpow_mod_orderOf, ← Int.emod_emod_of_dvd n <|\n    Int.natCast_dvd_natCast.2 <| orderOf_dvd_natCard _, zpow_mod_orderOf]\n\n"}
{"name":"powCoprime_apply","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"n : Nat\nG : Type u_6\ninst✝ : Group G\nh : (Nat.card G).Coprime n\ng : G\n⊢ Eq ((powCoprime h) g) (HPow.hPow g n)","decl":"/-- If `gcd(|G|,n)=1` then the `n`th power map is a bijection -/\n@[to_additive (attr := simps) \"If `gcd(|G|,n)=1` then the smul by `n` is a bijection\"]\nnoncomputable def powCoprime {G : Type*} [Group G] (h : (Nat.card G).Coprime n) : G ≃ G where\n  toFun g := g ^ n\n  invFun g := g ^ (Nat.card G).gcdB n\n  left_inv g := by\n    have key := congr_arg (g ^ ·) ((Nat.card G).gcd_eq_gcd_ab n)\n    dsimp only at key\n    rwa [zpow_add, zpow_mul, zpow_mul, zpow_natCast, zpow_natCast, zpow_natCast, h.gcd_eq_one,\n      pow_one, pow_card_eq_one', one_zpow, one_mul, eq_comm] at key\n  right_inv g := by\n    have key := congr_arg (g ^ ·) ((Nat.card G).gcd_eq_gcd_ab n)\n    dsimp only at key\n    rwa [zpow_add, zpow_mul, zpow_mul', zpow_natCast, zpow_natCast, zpow_natCast, h.gcd_eq_one,\n      pow_one, pow_card_eq_one', one_zpow, one_mul, eq_comm] at key\n\n"}
{"name":"nsmulCoprime_symm_apply","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"n : Nat\nG : Type u_6\ninst✝ : AddGroup G\nh : (Nat.card G).Coprime n\ng : G\n⊢ Eq ((nsmulCoprime h).symm g) (HSMul.hSMul ((Nat.card G).gcdB n) g)","decl":"/-- If `gcd(|G|,n)=1` then the `n`th power map is a bijection -/\n@[to_additive (attr := simps) \"If `gcd(|G|,n)=1` then the smul by `n` is a bijection\"]\nnoncomputable def powCoprime {G : Type*} [Group G] (h : (Nat.card G).Coprime n) : G ≃ G where\n  toFun g := g ^ n\n  invFun g := g ^ (Nat.card G).gcdB n\n  left_inv g := by\n    have key := congr_arg (g ^ ·) ((Nat.card G).gcd_eq_gcd_ab n)\n    dsimp only at key\n    rwa [zpow_add, zpow_mul, zpow_mul, zpow_natCast, zpow_natCast, zpow_natCast, h.gcd_eq_one,\n      pow_one, pow_card_eq_one', one_zpow, one_mul, eq_comm] at key\n  right_inv g := by\n    have key := congr_arg (g ^ ·) ((Nat.card G).gcd_eq_gcd_ab n)\n    dsimp only at key\n    rwa [zpow_add, zpow_mul, zpow_mul', zpow_natCast, zpow_natCast, zpow_natCast, h.gcd_eq_one,\n      pow_one, pow_card_eq_one', one_zpow, one_mul, eq_comm] at key\n\n"}
{"name":"nsmulCoprime_apply","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"n : Nat\nG : Type u_6\ninst✝ : AddGroup G\nh : (Nat.card G).Coprime n\ng : G\n⊢ Eq ((nsmulCoprime h) g) (HSMul.hSMul n g)","decl":"/-- If `gcd(|G|,n)=1` then the `n`th power map is a bijection -/\n@[to_additive (attr := simps) \"If `gcd(|G|,n)=1` then the smul by `n` is a bijection\"]\nnoncomputable def powCoprime {G : Type*} [Group G] (h : (Nat.card G).Coprime n) : G ≃ G where\n  toFun g := g ^ n\n  invFun g := g ^ (Nat.card G).gcdB n\n  left_inv g := by\n    have key := congr_arg (g ^ ·) ((Nat.card G).gcd_eq_gcd_ab n)\n    dsimp only at key\n    rwa [zpow_add, zpow_mul, zpow_mul, zpow_natCast, zpow_natCast, zpow_natCast, h.gcd_eq_one,\n      pow_one, pow_card_eq_one', one_zpow, one_mul, eq_comm] at key\n  right_inv g := by\n    have key := congr_arg (g ^ ·) ((Nat.card G).gcd_eq_gcd_ab n)\n    dsimp only at key\n    rwa [zpow_add, zpow_mul, zpow_mul', zpow_natCast, zpow_natCast, zpow_natCast, h.gcd_eq_one,\n      pow_one, pow_card_eq_one', one_zpow, one_mul, eq_comm] at key\n\n"}
{"name":"powCoprime_symm_apply","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"n : Nat\nG : Type u_6\ninst✝ : Group G\nh : (Nat.card G).Coprime n\ng : G\n⊢ Eq ((powCoprime h).symm g) (HPow.hPow g ((Nat.card G).gcdB n))","decl":"/-- If `gcd(|G|,n)=1` then the `n`th power map is a bijection -/\n@[to_additive (attr := simps) \"If `gcd(|G|,n)=1` then the smul by `n` is a bijection\"]\nnoncomputable def powCoprime {G : Type*} [Group G] (h : (Nat.card G).Coprime n) : G ≃ G where\n  toFun g := g ^ n\n  invFun g := g ^ (Nat.card G).gcdB n\n  left_inv g := by\n    have key := congr_arg (g ^ ·) ((Nat.card G).gcd_eq_gcd_ab n)\n    dsimp only at key\n    rwa [zpow_add, zpow_mul, zpow_mul, zpow_natCast, zpow_natCast, zpow_natCast, h.gcd_eq_one,\n      pow_one, pow_card_eq_one', one_zpow, one_mul, eq_comm] at key\n  right_inv g := by\n    have key := congr_arg (g ^ ·) ((Nat.card G).gcd_eq_gcd_ab n)\n    dsimp only at key\n    rwa [zpow_add, zpow_mul, zpow_mul', zpow_natCast, zpow_natCast, zpow_natCast, h.gcd_eq_one,\n      pow_one, pow_card_eq_one', one_zpow, one_mul, eq_comm] at key\n\n"}
{"name":"powCoprime_one","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"n : Nat\nG : Type u_6\ninst✝ : Group G\nh : (Nat.card G).Coprime n\n⊢ Eq ((powCoprime h) 1) 1","decl":"@[to_additive]\ntheorem powCoprime_one {G : Type*} [Group G] (h : (Nat.card G).Coprime n) : powCoprime h 1 = 1 :=\n  one_pow n\n\n"}
{"name":"nsmulCoprime_zero","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"n : Nat\nG : Type u_6\ninst✝ : AddGroup G\nh : (Nat.card G).Coprime n\n⊢ Eq ((nsmulCoprime h) 0) 0","decl":"@[to_additive]\ntheorem powCoprime_one {G : Type*} [Group G] (h : (Nat.card G).Coprime n) : powCoprime h 1 = 1 :=\n  one_pow n\n\n"}
{"name":"nsmulCoprime_neg","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"n : Nat\nG : Type u_6\ninst✝ : AddGroup G\nh : (Nat.card G).Coprime n\ng : G\n⊢ Eq ((nsmulCoprime h) (Neg.neg g)) (Neg.neg ((nsmulCoprime h) g))","decl":"@[to_additive]\ntheorem powCoprime_inv {G : Type*} [Group G] (h : (Nat.card G).Coprime n) {g : G} :\n    powCoprime h g⁻¹ = (powCoprime h g)⁻¹ :=\n  inv_pow g n\n\n"}
{"name":"powCoprime_inv","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"n : Nat\nG : Type u_6\ninst✝ : Group G\nh : (Nat.card G).Coprime n\ng : G\n⊢ Eq ((powCoprime h) (Inv.inv g)) (Inv.inv ((powCoprime h) g))","decl":"@[to_additive]\ntheorem powCoprime_inv {G : Type*} [Group G] (h : (Nat.card G).Coprime n) {g : G} :\n    powCoprime h g⁻¹ = (powCoprime h g)⁻¹ :=\n  inv_pow g n\n\n"}
{"name":"Nat.Coprime.nsmul_right_bijective","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"n : Nat\nG : Type u_6\ninst✝ : AddGroup G\nhn : (Nat.card G).Coprime n\n⊢ Function.Bijective fun x => HSMul.hSMul n x","decl":"@[to_additive Nat.Coprime.nsmul_right_bijective]\nlemma Nat.Coprime.pow_left_bijective {G} [Group G] (hn : (Nat.card G).Coprime n) :\n    Bijective (· ^ n : G → G) :=\n  (powCoprime hn).bijective\n\n/- TODO: Generalise to `Submonoid.powers`. -/\n"}
{"name":"Nat.Coprime.pow_left_bijective","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"n : Nat\nG : Type u_6\ninst✝ : Group G\nhn : (Nat.card G).Coprime n\n⊢ Function.Bijective fun x => HPow.hPow x n","decl":"@[to_additive Nat.Coprime.nsmul_right_bijective]\nlemma Nat.Coprime.pow_left_bijective {G} [Group G] (hn : (Nat.card G).Coprime n) :\n    Bijective (· ^ n : G → G) :=\n  (powCoprime hn).bijective\n\n/- TODO: Generalise to `Submonoid.powers`. -/\n"}
{"name":"image_range_orderOf","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝² : Group G\ninst✝¹ : Fintype G\nx : G\ninst✝ : DecidableEq G\n⊢ Eq (Finset.image (fun i => HPow.hPow x i) (Finset.range (orderOf x))) (↑(Subgroup.zpowers x)).toFinset","decl":"@[to_additive]\ntheorem image_range_orderOf [DecidableEq G] :\n    letI : Fintype (zpowers x) := (Subgroup.zpowers x).instFintypeSubtypeMemOfDecidablePred\n    Finset.image (fun i => x ^ i) (Finset.range (orderOf x)) = (zpowers x : Set G).toFinset := by\n  letI : Fintype (zpowers x) := (Subgroup.zpowers x).instFintypeSubtypeMemOfDecidablePred\n  ext x\n  rw [Set.mem_toFinset, SetLike.mem_coe, mem_zpowers_iff_mem_range_orderOf]\n\n/- TODO: Generalise to `Finite` + `CancelMonoid`. -/\n"}
{"name":"image_range_addOrderOf","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝² : AddGroup G\ninst✝¹ : Fintype G\nx : G\ninst✝ : DecidableEq G\n⊢ Eq (Finset.image (fun i => HSMul.hSMul i x) (Finset.range (addOrderOf x))) (↑(AddSubgroup.zmultiples x)).toFinset","decl":"@[to_additive]\ntheorem image_range_orderOf [DecidableEq G] :\n    letI : Fintype (zpowers x) := (Subgroup.zpowers x).instFintypeSubtypeMemOfDecidablePred\n    Finset.image (fun i => x ^ i) (Finset.range (orderOf x)) = (zpowers x : Set G).toFinset := by\n  letI : Fintype (zpowers x) := (Subgroup.zpowers x).instFintypeSubtypeMemOfDecidablePred\n  ext x\n  rw [Set.mem_toFinset, SetLike.mem_coe, mem_zpowers_iff_mem_range_orderOf]\n\n/- TODO: Generalise to `Finite` + `CancelMonoid`. -/\n"}
{"name":"pow_gcd_card_eq_one_iff","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝¹ : Group G\ninst✝ : Fintype G\nx : G\nn : Nat\n⊢ Iff (Eq (HPow.hPow x n) 1) (Eq (HPow.hPow x (n.gcd (Fintype.card G))) 1)","decl":"@[to_additive gcd_nsmul_card_eq_zero_iff]\ntheorem pow_gcd_card_eq_one_iff : x ^ n = 1 ↔ x ^ gcd n (Fintype.card G) = 1 :=\n  ⟨fun h => pow_gcd_eq_one _ h <| pow_card_eq_one, fun h => by\n    let ⟨m, hm⟩ := gcd_dvd_left n (Fintype.card G)\n    rw [hm, pow_mul, h, one_pow]⟩\n\n"}
{"name":"gcd_nsmul_card_eq_zero_iff","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\ninst✝ : Fintype G\nx : G\nn : Nat\n⊢ Iff (Eq (HSMul.hSMul n x) 0) (Eq (HSMul.hSMul (n.gcd (Fintype.card G)) x) 0)","decl":"@[to_additive gcd_nsmul_card_eq_zero_iff]\ntheorem pow_gcd_card_eq_one_iff : x ^ n = 1 ↔ x ^ gcd n (Fintype.card G) = 1 :=\n  ⟨fun h => pow_gcd_eq_one _ h <| pow_card_eq_one, fun h => by\n    let ⟨m, hm⟩ := gcd_dvd_left n (Fintype.card G)\n    rw [hm, pow_mul, h, one_pow]⟩\n\n"}
{"name":"smul_eq_of_le_smul","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_6\ninst✝⁴ : Group G\ninst✝³ : Finite G\nα : Type u_7\ninst✝² : PartialOrder α\ng : G\na : α\ninst✝¹ : MulAction G α\ninst✝ : CovariantClass G α HSMul.hSMul LE.le\nh : LE.le a (HSMul.hSMul g a)\n⊢ Eq (HSMul.hSMul g a) a","decl":"lemma smul_eq_of_le_smul\n    {G : Type*} [Group G] [Finite G] {α : Type*} [PartialOrder α] {g : G} {a : α}\n    [MulAction G α] [CovariantClass G α HSMul.hSMul LE.le] (h : a ≤ g • a) : g • a = a := by\n  have key := smul_mono_right g (le_pow_smul h (Nat.card G - 1))\n  rw [smul_smul, ← _root_.pow_succ',\n    Nat.sub_one_add_one_eq_of_pos Nat.card_pos, pow_card_eq_one', one_smul] at key\n  exact le_antisymm key h\n\n"}
{"name":"smul_eq_of_smul_le","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_6\ninst✝⁴ : Group G\ninst✝³ : Finite G\nα : Type u_7\ninst✝² : PartialOrder α\ng : G\na : α\ninst✝¹ : MulAction G α\ninst✝ : CovariantClass G α HSMul.hSMul LE.le\nh : LE.le (HSMul.hSMul g a) a\n⊢ Eq (HSMul.hSMul g a) a","decl":"lemma smul_eq_of_smul_le\n    {G : Type*} [Group G] [Finite G] {α : Type*} [PartialOrder α] {g : G} {a : α}\n    [MulAction G α] [CovariantClass G α HSMul.hSMul LE.le] (h : g • a ≤ a) : g • a = a := by\n  have key := smul_mono_right g (pow_smul_le h (Nat.card G - 1))\n  rw [smul_smul, ← _root_.pow_succ',\n    Nat.sub_one_add_one_eq_of_pos Nat.card_pos, pow_card_eq_one', one_smul] at key\n  exact le_antisymm h key\n\n"}
{"name":"coe_smulCardAddSubgroup","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_6\ninst✝¹ : AddGroup G\ninst✝ : Fintype G\nS : Set G\nhS : S.Nonempty\n⊢ Eq (↑(smulCardAddSubgroup S hS)) (HSMul.hSMul (Fintype.card G) S)","decl":"/-- If `S` is a nonempty subset of a finite group `G`, then `S ^ |G|` is a subgroup -/\n@[to_additive (attr := simps!) smulCardAddSubgroup\n  \"If `S` is a nonempty subset of a finite add group `G`, then `|G| • S` is a subgroup\"]\ndef powCardSubgroup {G : Type*} [Group G] [Fintype G] (S : Set G) (hS : S.Nonempty) : Subgroup G :=\n  have one_mem : (1 : G) ∈ S ^ Fintype.card G := by\n    obtain ⟨a, ha⟩ := hS\n    rw [← pow_card_eq_one]\n    exact Set.pow_mem_pow ha\n  subgroupOfIdempotent (S ^ Fintype.card G) ⟨1, one_mem⟩ <| by\n    classical\n    apply (Set.eq_of_subset_of_card_le (Set.subset_mul_left _ one_mem) (ge_of_eq _)).symm\n    simp_rw [← pow_add,\n        Group.card_pow_eq_card_pow_card_univ S (Fintype.card G + Fintype.card G) le_add_self]\n\n"}
{"name":"coe_powCardSubgroup","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_6\ninst✝¹ : Group G\ninst✝ : Fintype G\nS : Set G\nhS : S.Nonempty\n⊢ Eq (↑(powCardSubgroup S hS)) (HPow.hPow S (Fintype.card G))","decl":"/-- If `S` is a nonempty subset of a finite group `G`, then `S ^ |G|` is a subgroup -/\n@[to_additive (attr := simps!) smulCardAddSubgroup\n  \"If `S` is a nonempty subset of a finite add group `G`, then `|G| • S` is a subgroup\"]\ndef powCardSubgroup {G : Type*} [Group G] [Fintype G] (S : Set G) (hS : S.Nonempty) : Subgroup G :=\n  have one_mem : (1 : G) ∈ S ^ Fintype.card G := by\n    obtain ⟨a, ha⟩ := hS\n    rw [← pow_card_eq_one]\n    exact Set.pow_mem_pow ha\n  subgroupOfIdempotent (S ^ Fintype.card G) ⟨1, one_mem⟩ <| by\n    classical\n    apply (Set.eq_of_subset_of_card_le (Set.subset_mul_left _ one_mem) (ge_of_eq _)).symm\n    simp_rw [← pow_add,\n        Group.card_pow_eq_card_pow_card_univ S (Fintype.card G + Fintype.card G) le_add_self]\n\n"}
{"name":"IsOfFinOrder.eq_one","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝ : LinearOrderedSemiring G\na : G\nha₀ : LE.le 0 a\nha : IsOfFinOrder a\n⊢ Eq a 1","decl":"protected lemma IsOfFinOrder.eq_one (ha₀ : 0 ≤ a) (ha : IsOfFinOrder a) : a = 1 := by\n  obtain ⟨n, hn, ha⟩ := ha.exists_pow_eq_one\n  exact (pow_eq_one_iff_of_nonneg ha₀ hn.ne').1 ha\n\n"}
{"name":"IsOfFinOrder.eq_neg_one","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝ : LinearOrderedRing G\na : G\nha₀ : LE.le a 0\nha : IsOfFinOrder a\n⊢ Eq a (-1)","decl":"protected lemma IsOfFinOrder.eq_neg_one (ha₀ : a ≤ 0) (ha : IsOfFinOrder a) : a = -1 :=\n  (sq_eq_one_iff.1 <| ha.pow.eq_one <| sq_nonneg a).resolve_left <| by\n    rintro rfl; exact one_pos.not_le ha₀\n\n"}
{"name":"orderOf_abs_ne_one","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝ : LinearOrderedRing G\nx : G\nh : Ne (abs x) 1\n⊢ Eq (orderOf x) 0","decl":"theorem orderOf_abs_ne_one (h : |x| ≠ 1) : orderOf x = 0 := by\n  rw [orderOf_eq_zero_iff']\n  intro n hn hx\n  replace hx : |x| ^ n = 1 := by simpa only [abs_one, abs_pow] using congr_arg abs hx\n  cases' h.lt_or_lt with h h\n  · exact ((pow_lt_one₀ (abs_nonneg x) h hn.ne').ne hx).elim\n  · exact ((one_lt_pow₀ h hn.ne').ne' hx).elim\n\n"}
{"name":"LinearOrderedRing.orderOf_le_two","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝ : LinearOrderedRing G\nx : G\n⊢ LE.le (orderOf x) 2","decl":"theorem LinearOrderedRing.orderOf_le_two : orderOf x ≤ 2 := by\n  cases' ne_or_eq |x| 1 with h h\n  · simp [orderOf_abs_ne_one h]\n  rcases eq_or_eq_neg_of_abs_eq h with (rfl | rfl)\n  · simp\n  apply orderOf_le_of_pow_eq_one <;> norm_num\n\n"}
{"name":"Prod.addOrderOf","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"α : Type u_4\nβ : Type u_5\ninst✝¹ : AddMonoid α\ninst✝ : AddMonoid β\nx : Prod α β\n⊢ Eq (addOrderOf x) ((addOrderOf x.1).lcm (addOrderOf x.2))","decl":"@[to_additive]\nprotected theorem Prod.orderOf (x : α × β) : orderOf x = (orderOf x.1).lcm (orderOf x.2) :=\n  minimalPeriod_prod_map _ _ _\n\n"}
{"name":"Prod.orderOf","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"α : Type u_4\nβ : Type u_5\ninst✝¹ : Monoid α\ninst✝ : Monoid β\nx : Prod α β\n⊢ Eq (orderOf x) ((orderOf x.1).lcm (orderOf x.2))","decl":"@[to_additive]\nprotected theorem Prod.orderOf (x : α × β) : orderOf x = (orderOf x.1).lcm (orderOf x.2) :=\n  minimalPeriod_prod_map _ _ _\n\n"}
{"name":"addOrderOf_fst_dvd_addOrderOf","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"α : Type u_4\nβ : Type u_5\ninst✝¹ : AddMonoid α\ninst✝ : AddMonoid β\nx : Prod α β\n⊢ Dvd.dvd (addOrderOf x.1) (addOrderOf x)","decl":"@[to_additive]\ntheorem orderOf_fst_dvd_orderOf : orderOf x.1 ∣ orderOf x :=\n  minimalPeriod_fst_dvd\n\n"}
{"name":"orderOf_fst_dvd_orderOf","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"α : Type u_4\nβ : Type u_5\ninst✝¹ : Monoid α\ninst✝ : Monoid β\nx : Prod α β\n⊢ Dvd.dvd (orderOf x.1) (orderOf x)","decl":"@[to_additive]\ntheorem orderOf_fst_dvd_orderOf : orderOf x.1 ∣ orderOf x :=\n  minimalPeriod_fst_dvd\n\n"}
{"name":"addOrderOf_snd_dvd_addOrderOf","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"α : Type u_4\nβ : Type u_5\ninst✝¹ : AddMonoid α\ninst✝ : AddMonoid β\nx : Prod α β\n⊢ Dvd.dvd (addOrderOf x.2) (addOrderOf x)","decl":"@[to_additive]\ntheorem orderOf_snd_dvd_orderOf : orderOf x.2 ∣ orderOf x :=\n  minimalPeriod_snd_dvd\n\n"}
{"name":"orderOf_snd_dvd_orderOf","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"α : Type u_4\nβ : Type u_5\ninst✝¹ : Monoid α\ninst✝ : Monoid β\nx : Prod α β\n⊢ Dvd.dvd (orderOf x.2) (orderOf x)","decl":"@[to_additive]\ntheorem orderOf_snd_dvd_orderOf : orderOf x.2 ∣ orderOf x :=\n  minimalPeriod_snd_dvd\n\n"}
{"name":"IsOfFinAddOrder.fst","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"α : Type u_4\nβ : Type u_5\ninst✝¹ : AddMonoid α\ninst✝ : AddMonoid β\nx : Prod α β\nhx : IsOfFinAddOrder x\n⊢ IsOfFinAddOrder x.1","decl":"@[to_additive]\ntheorem IsOfFinOrder.fst {x : α × β} (hx : IsOfFinOrder x) : IsOfFinOrder x.1 :=\n  hx.mono orderOf_fst_dvd_orderOf\n\n"}
{"name":"IsOfFinOrder.fst","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"α : Type u_4\nβ : Type u_5\ninst✝¹ : Monoid α\ninst✝ : Monoid β\nx : Prod α β\nhx : IsOfFinOrder x\n⊢ IsOfFinOrder x.1","decl":"@[to_additive]\ntheorem IsOfFinOrder.fst {x : α × β} (hx : IsOfFinOrder x) : IsOfFinOrder x.1 :=\n  hx.mono orderOf_fst_dvd_orderOf\n\n"}
{"name":"IsOfFinOrder.snd","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"α : Type u_4\nβ : Type u_5\ninst✝¹ : Monoid α\ninst✝ : Monoid β\nx : Prod α β\nhx : IsOfFinOrder x\n⊢ IsOfFinOrder x.2","decl":"@[to_additive]\ntheorem IsOfFinOrder.snd {x : α × β} (hx : IsOfFinOrder x) : IsOfFinOrder x.2 :=\n  hx.mono orderOf_snd_dvd_orderOf\n\n"}
{"name":"IsOfFinAddOrder.snd","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"α : Type u_4\nβ : Type u_5\ninst✝¹ : AddMonoid α\ninst✝ : AddMonoid β\nx : Prod α β\nhx : IsOfFinAddOrder x\n⊢ IsOfFinAddOrder x.2","decl":"@[to_additive]\ntheorem IsOfFinOrder.snd {x : α × β} (hx : IsOfFinOrder x) : IsOfFinOrder x.2 :=\n  hx.mono orderOf_snd_dvd_orderOf\n\n"}
{"name":"IsOfFinOrder.prod_mk","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"α : Type u_4\nβ : Type u_5\ninst✝¹ : Monoid α\ninst✝ : Monoid β\na : α\nb : β\na✝¹ : IsOfFinOrder a\na✝ : IsOfFinOrder b\n⊢ IsOfFinOrder { fst := a, snd := b }","decl":"@[to_additive IsOfFinAddOrder.prod_mk]\ntheorem IsOfFinOrder.prod_mk : IsOfFinOrder a → IsOfFinOrder b → IsOfFinOrder (a, b) := by\n  simpa only [← orderOf_pos_iff, Prod.orderOf] using Nat.lcm_pos\n\n"}
{"name":"IsOfFinAddOrder.prod_mk","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"α : Type u_4\nβ : Type u_5\ninst✝¹ : AddMonoid α\ninst✝ : AddMonoid β\na : α\nb : β\na✝¹ : IsOfFinAddOrder a\na✝ : IsOfFinAddOrder b\n⊢ IsOfFinAddOrder { fst := a, snd := b }","decl":"@[to_additive IsOfFinAddOrder.prod_mk]\ntheorem IsOfFinOrder.prod_mk : IsOfFinOrder a → IsOfFinOrder b → IsOfFinOrder (a, b) := by\n  simpa only [← orderOf_pos_iff, Prod.orderOf] using Nat.lcm_pos\n\n"}
{"name":"Prod.addOrderOf_mk","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"α : Type u_4\nβ : Type u_5\ninst✝¹ : AddMonoid α\ninst✝ : AddMonoid β\na : α\nb : β\n⊢ Eq (addOrderOf { fst := a, snd := b }) ((addOrderOf a).lcm (addOrderOf b))","decl":"@[to_additive]\nlemma Prod.orderOf_mk : orderOf (a, b) = Nat.lcm (orderOf a) (orderOf b) :=\n  (a, b).orderOf\n\n"}
{"name":"Prod.orderOf_mk","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"α : Type u_4\nβ : Type u_5\ninst✝¹ : Monoid α\ninst✝ : Monoid β\na : α\nb : β\n⊢ Eq (orderOf { fst := a, snd := b }) ((orderOf a).lcm (orderOf b))","decl":"@[to_additive]\nlemma Prod.orderOf_mk : orderOf (a, b) = Nat.lcm (orderOf a) (orderOf b) :=\n  (a, b).orderOf\n\n"}
{"name":"Nat.cast_card_eq_zero","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"R : Type u_6\ninst✝¹ : AddGroupWithOne R\ninst✝ : Fintype R\n⊢ Eq (↑(Fintype.card R)) 0","decl":"@[simp]\nlemma Nat.cast_card_eq_zero (R) [AddGroupWithOne R] [Fintype R] : (Fintype.card R : R) = 0 := by\n  rw [← nsmul_one, card_nsmul_eq_zero]\n\n"}
{"name":"CharP.addOrderOf_one","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"R : Type u_6\ninst✝ : NonAssocRing R\n⊢ CharP R (addOrderOf 1)","decl":"lemma CharP.addOrderOf_one : CharP R (addOrderOf (1 : R)) where\n  cast_eq_zero_iff' n := by rw [← Nat.smul_one_eq_cast, addOrderOf_dvd_iff_nsmul_eq_zero]\n\n"}
{"name":"charP_of_ne_zero","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"R : Type u_6\ninst✝¹ : NonAssocRing R\np : Nat\ninst✝ : Fintype R\nhn : Eq (Fintype.card R) p\nhR : ∀ (i : Nat), LT.lt i p → Eq (↑i) 0 → Eq i 0\n⊢ CharP R p","decl":"variable {R} in\nlemma charP_of_ne_zero (hn : card R = p) (hR : ∀ i < p, (i : R) = 0 → i = 0) : CharP R p where\n  cast_eq_zero_iff' n := by\n    have H : (p : R) = 0 := by rw [← hn, Nat.cast_card_eq_zero]\n    constructor\n    · intro h\n      rw [← Nat.mod_add_div n p, Nat.cast_add, Nat.cast_mul, H, zero_mul, add_zero] at h\n      rw [Nat.dvd_iff_mod_eq_zero]\n      apply hR _ (Nat.mod_lt _ _) h\n      rw [← hn, gt_iff_lt, Fintype.card_pos_iff]\n      exact ⟨0⟩\n    · rintro ⟨n, rfl⟩\n      rw [Nat.cast_mul, H, zero_mul]\n\n"}
{"name":"charP_of_prime_pow_injective","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"R : Type u_6\ninst✝¹ : Ring R\ninst✝ : Fintype R\np n : Nat\nhp : Fact (Nat.Prime p)\nhn : Eq (Fintype.card R) (HPow.hPow p n)\nhR : ∀ (i : Nat), LE.le i n → Eq (HPow.hPow (↑p) i) 0 → Eq i n\n⊢ CharP R (HPow.hPow p n)","decl":"lemma charP_of_prime_pow_injective (R) [Ring R] [Fintype R] (p n : ℕ) [hp : Fact p.Prime]\n    (hn : card R = p ^ n) (hR : ∀ i ≤ n, (p : R) ^ i = 0 → i = n) : CharP R (p ^ n) := by\n  obtain ⟨c, hc⟩ := CharP.exists R\n  have hcpn : c ∣ p ^ n := by rw [← CharP.cast_eq_zero_iff R c, ← hn, Nat.cast_card_eq_zero]\n  obtain ⟨i, hi, rfl⟩ : ∃ i ≤ n, c = p ^ i := by rwa [Nat.dvd_prime_pow hp.1] at hcpn\n  obtain rfl : i = n := hR i hi <| by rw [← Nat.cast_pow, CharP.cast_eq_zero]\n  assumption\n\n"}
{"name":"SemiconjBy.orderOf_eq","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝ : Group G\na x y : G\nh : SemiconjBy a x y\n⊢ Eq (orderOf x) (orderOf y)","decl":"@[to_additive]\nlemma orderOf_eq [Group G] (a : G) {x y : G} (h : SemiconjBy a x y) : orderOf x = orderOf y := by\n  rw [orderOf_eq_orderOf_iff]\n  intro n\n  exact (h.pow_right n).eq_one_iff\n\n"}
{"name":"AddSemiconjBy.addOrderOf_eq","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\na x y : G\nh : AddSemiconjBy a x y\n⊢ Eq (addOrderOf x) (addOrderOf y)","decl":"@[to_additive]\nlemma orderOf_eq [Group G] (a : G) {x y : G} (h : SemiconjBy a x y) : orderOf x = orderOf y := by\n  rw [orderOf_eq_orderOf_iff]\n  intro n\n  exact (h.pow_right n).eq_one_iff\n\n"}
{"name":"orderOf_piMulSingle","module":"Mathlib.GroupTheory.OrderOfElement","initialProofState":"ι : Type u_6\ninst✝¹ : DecidableEq ι\nM : ι → Type u_7\ninst✝ : (i : ι) → Monoid (M i)\ni : ι\ng : M i\n⊢ Eq (orderOf (Pi.mulSingle i g)) (orderOf g)","decl":"lemma orderOf_piMulSingle {ι : Type*} [DecidableEq ι] {M : ι → Type*} [(i : ι) → Monoid (M i)]\n    (i : ι) (g : M i) :\n    orderOf (Pi.mulSingle i g) = orderOf g :=\n  orderOf_injective (MonoidHom.mulSingle M i) (Pi.mulSingle_injective M i) g\n\n"}
