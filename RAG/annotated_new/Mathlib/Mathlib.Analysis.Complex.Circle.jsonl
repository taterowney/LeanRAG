{"name":"Circle.ext","module":"Mathlib.Analysis.Complex.Circle","initialProofState":"x y : Circle\na✝ : Eq ↑x ↑y\n⊢ Eq x y","decl":"@[ext] lemma ext : (x : ℂ) = y → x = y := Subtype.ext\n\n"}
{"name":"Circle.ext_iff","module":"Mathlib.Analysis.Complex.Circle","initialProofState":"x y : Circle\n⊢ Iff (Eq x y) (Eq ↑x ↑y)","decl":"@[ext] lemma ext : (x : ℂ) = y → x = y := Subtype.ext\n\n"}
{"name":"Circle.coe_injective","module":"Mathlib.Analysis.Complex.Circle","initialProofState":"⊢ Function.Injective Subtype.val","decl":"lemma coe_injective : Injective ((↑) : Circle → ℂ) := fun _ _ ↦ ext\n\n-- Not simp because `SetLike.coe_eq_coe` already proves it\n"}
{"name":"Circle.coe_inj","module":"Mathlib.Analysis.Complex.Circle","initialProofState":"x y : Circle\n⊢ Iff (Eq ↑x ↑y) (Eq x y)","decl":"lemma coe_inj : (x : ℂ) = y ↔ x = y := coe_injective.eq_iff\n\n"}
{"name":"Circle.abs_coe","module":"Mathlib.Analysis.Complex.Circle","initialProofState":"z : Circle\n⊢ Eq (Complex.abs ↑z) 1","decl":"@[simp] lemma abs_coe (z : Circle) : abs z = 1 := mem_sphere_zero_iff_norm.1 z.2\n"}
{"name":"Circle.normSq_coe","module":"Mathlib.Analysis.Complex.Circle","initialProofState":"z : Circle\n⊢ Eq (Complex.normSq ↑z) 1","decl":"@[simp] lemma normSq_coe (z : Circle) : normSq z = 1 := by simp [normSq_eq_abs]\n"}
{"name":"Circle.coe_ne_zero","module":"Mathlib.Analysis.Complex.Circle","initialProofState":"z : Circle\n⊢ Ne (↑z) 0","decl":"@[simp] lemma coe_ne_zero (z : Circle) : (z : ℂ) ≠ 0 := ne_zero_of_mem_unit_sphere z\n"}
{"name":"Circle.coe_one","module":"Mathlib.Analysis.Complex.Circle","initialProofState":"⊢ Eq (↑1) 1","decl":"@[simp, norm_cast] lemma coe_one : ↑(1 : Circle) = (1 : ℂ) := rfl\n-- Not simp because `OneMemClass.coe_eq_one` already proves it\n"}
{"name":"Circle.coe_eq_one","module":"Mathlib.Analysis.Complex.Circle","initialProofState":"x : Circle\n⊢ Iff (Eq (↑x) 1) (Eq x 1)","decl":"@[norm_cast] lemma coe_eq_one : (x : ℂ) = 1 ↔ x = 1 := by rw [← coe_inj, coe_one]\n"}
{"name":"Circle.coe_mul","module":"Mathlib.Analysis.Complex.Circle","initialProofState":"z w : Circle\n⊢ Eq (↑(HMul.hMul z w)) (HMul.hMul ↑z ↑w)","decl":"@[simp, norm_cast] lemma coe_mul (z w : Circle) : ↑(z * w) = (z : ℂ) * w := rfl\n"}
{"name":"Circle.coe_inv","module":"Mathlib.Analysis.Complex.Circle","initialProofState":"z : Circle\n⊢ Eq (↑(Inv.inv z)) (Inv.inv ↑z)","decl":"@[simp, norm_cast] lemma coe_inv (z : Circle) : ↑z⁻¹ = (z : ℂ)⁻¹ := rfl\n"}
{"name":"Circle.coe_inv_eq_conj","module":"Mathlib.Analysis.Complex.Circle","initialProofState":"z : Circle\n⊢ Eq (↑(Inv.inv z)) ((starRingEnd Complex) ↑z)","decl":"lemma coe_inv_eq_conj (z : Circle) : ↑z⁻¹ = conj (z : ℂ) := by\n  rw [coe_inv, inv_def, normSq_coe, inv_one, ofReal_one, mul_one]\n\n"}
{"name":"Circle.coe_div","module":"Mathlib.Analysis.Complex.Circle","initialProofState":"z w : Circle\n⊢ Eq (↑(HDiv.hDiv z w)) (HDiv.hDiv ↑z ↑w)","decl":"@[simp, norm_cast] lemma coe_div (z w : Circle) : ↑(z / w) = (z : ℂ) / w := rfl\n\n"}
{"name":"Circle.coeHom_apply","module":"Mathlib.Analysis.Complex.Circle","initialProofState":"self : Subtype fun x => Membership.mem (Submonoid.unitSphere Complex) x\n⊢ Eq (Circle.coeHom self) ↑self","decl":"/-- The coercion `Circle → ℂ` as a monoid homomorphism. -/\n@[simps]\ndef coeHom : Circle →* ℂ where\n  toFun := (↑)\n  map_one' := coe_one\n  map_mul' := coe_mul\n\n"}
{"name":"Circle.toUnits_apply","module":"Mathlib.Analysis.Complex.Circle","initialProofState":"z : Circle\n⊢ Eq (Circle.toUnits z) (Units.mk0 ↑z ⋯)","decl":"@[simp] lemma toUnits_apply (z : Circle) : toUnits z = Units.mk0 ↑z z.coe_ne_zero := rfl\n\n"}
{"name":"Circle.instCompactSpace","module":"Mathlib.Analysis.Complex.Circle","initialProofState":"⊢ CompactSpace Circle","decl":"instance : CompactSpace Circle := Metric.sphere.compactSpace _ _\n"}
{"name":"Circle.instTopologicalGroup","module":"Mathlib.Analysis.Complex.Circle","initialProofState":"⊢ TopologicalGroup Circle","decl":"instance : TopologicalGroup Circle := Metric.sphere.topologicalGroup\n"}
{"name":"Circle.instUniformGroup","module":"Mathlib.Analysis.Complex.Circle","initialProofState":"⊢ UniformGroup Circle","decl":"instance : UniformGroup Circle := by\n  convert topologicalGroup_is_uniform_of_compactSpace Circle\n  exact unique_uniformity_of_compact rfl rfl\n\n"}
{"name":"Circle.ofConjDivSelf_coe","module":"Mathlib.Analysis.Complex.Circle","initialProofState":"z : Complex\nhz : Ne z 0\n⊢ Eq (↑(Circle.ofConjDivSelf z hz)) (HDiv.hDiv ((starRingEnd Complex) z) z)","decl":"/-- If `z` is a nonzero complex number, then `conj z / z` belongs to the unit circle. -/\n@[simps]\ndef ofConjDivSelf (z : ℂ) (hz : z ≠ 0) : Circle where\n  val := conj z / z\n  property := mem_sphere_zero_iff_norm.2 <| by\n    rw [norm_div, RCLike.norm_conj, div_self]; exact Complex.abs.ne_zero hz\n\n"}
{"name":"Circle.coe_exp","module":"Mathlib.Analysis.Complex.Circle","initialProofState":"t : Real\n⊢ Eq (↑(Circle.exp t)) (Complex.exp (HMul.hMul (↑t) Complex.I))","decl":"@[simp, norm_cast]\ntheorem coe_exp (t : ℝ) : exp t = Complex.exp (t * Complex.I) := rfl\n\n"}
{"name":"Circle.exp_zero","module":"Mathlib.Analysis.Complex.Circle","initialProofState":"⊢ Eq (Circle.exp 0) 1","decl":"@[simp]\ntheorem exp_zero : exp 0 = 1 :=\n  Subtype.ext <| by rw [coe_exp, ofReal_zero, zero_mul, Complex.exp_zero, coe_one]\n\n"}
{"name":"Circle.exp_add","module":"Mathlib.Analysis.Complex.Circle","initialProofState":"x y : Real\n⊢ Eq (Circle.exp (HAdd.hAdd x y)) (HMul.hMul (Circle.exp x) (Circle.exp y))","decl":"@[simp]\ntheorem exp_add (x y : ℝ) : exp (x + y) = exp x * exp y :=\n  Subtype.ext <| by\n    simp only [coe_exp, Submonoid.coe_mul, ofReal_add, add_mul, Complex.exp_add, coe_mul]\n\n"}
{"name":"Circle.expHom_apply","module":"Mathlib.Analysis.Complex.Circle","initialProofState":"a✝ : Real\n⊢ Eq (Circle.expHom a✝) (Function.comp (⇑Additive.ofMul) (⇑Circle.exp) a✝)","decl":"/-- The map `fun t => exp (t * I)` from `ℝ` to the unit circle in `ℂ`,\nconsidered as a homomorphism of groups. -/\n@[simps]\ndef expHom : ℝ →+ Additive Circle where\n  toFun := Additive.ofMul ∘ exp\n  map_zero' := exp_zero\n  map_add' := exp_add\n\n"}
{"name":"Circle.exp_sub","module":"Mathlib.Analysis.Complex.Circle","initialProofState":"x y : Real\n⊢ Eq (Circle.exp (HSub.hSub x y)) (HDiv.hDiv (Circle.exp x) (Circle.exp y))","decl":"@[simp] lemma exp_sub (x y : ℝ) : exp (x - y) = exp x / exp y := expHom.map_sub x y\n"}
{"name":"Circle.exp_neg","module":"Mathlib.Analysis.Complex.Circle","initialProofState":"x : Real\n⊢ Eq (Circle.exp (Neg.neg x)) (Inv.inv (Circle.exp x))","decl":"@[simp] lemma exp_neg (x : ℝ) : exp (-x) = (exp x)⁻¹ := expHom.map_neg x\n\n"}
{"name":"Circle.instSMulCommClass_left","module":"Mathlib.Analysis.Complex.Circle","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : SMul Complex β\ninst✝¹ : SMul α β\ninst✝ : SMulCommClass Complex α β\n⊢ SMulCommClass Circle α β","decl":"instance instSMulCommClass_left [SMul ℂ β] [SMul α β] [SMulCommClass ℂ α β] :\n    SMulCommClass Circle α β := Submonoid.smulCommClass_left _\n\n"}
{"name":"Circle.instSMulCommClass_right","module":"Mathlib.Analysis.Complex.Circle","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : SMul Complex β\ninst✝¹ : SMul α β\ninst✝ : SMulCommClass α Complex β\n⊢ SMulCommClass α Circle β","decl":"instance instSMulCommClass_right [SMul ℂ β] [SMul α β] [SMulCommClass α ℂ β] :\n    SMulCommClass α Circle β := Submonoid.smulCommClass_right _\n\n"}
{"name":"Circle.instIsScalarTower","module":"Mathlib.Analysis.Complex.Circle","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : SMul Complex α\ninst✝² : SMul Complex β\ninst✝¹ : SMul α β\ninst✝ : IsScalarTower Complex α β\n⊢ IsScalarTower Circle α β","decl":"instance instIsScalarTower [SMul ℂ α] [SMul ℂ β] [SMul α β] [IsScalarTower ℂ α β] :\n    IsScalarTower Circle α β := Submonoid.isScalarTower _\n\n"}
{"name":"Circle.smul_def","module":"Mathlib.Analysis.Complex.Circle","initialProofState":"α : Type u_1\ninst✝ : SMul Complex α\nz : Circle\na : α\n⊢ Eq (HSMul.hSMul z a) (HSMul.hSMul (↑z) a)","decl":"lemma smul_def [SMul ℂ α] (z : Circle) (a : α) : z • a = (z : ℂ) • a := rfl\n\n"}
{"name":"Circle.instContinuousSMul","module":"Mathlib.Analysis.Complex.Circle","initialProofState":"α : Type u_1\ninst✝² : TopologicalSpace α\ninst✝¹ : MulAction Complex α\ninst✝ : ContinuousSMul Complex α\n⊢ ContinuousSMul Circle α","decl":"instance instContinuousSMul [TopologicalSpace α] [MulAction ℂ α] [ContinuousSMul ℂ α] :\n    ContinuousSMul Circle α := Submonoid.continuousSMul\n\n"}
{"name":"Circle.norm_smul","module":"Mathlib.Analysis.Complex.Circle","initialProofState":"E : Type u_4\ninst✝¹ : SeminormedAddCommGroup E\ninst✝ : NormedSpace Complex E\nu : Circle\nv : E\n⊢ Eq (Norm.norm (HSMul.hSMul u v)) (Norm.norm v)","decl":"@[simp]\nprotected lemma norm_smul {E : Type*} [SeminormedAddCommGroup E] [NormedSpace ℂ E]\n    (u : Circle) (v : E) :\n    ‖u • v‖ = ‖v‖ := by\n  rw [Submonoid.smul_def, norm_smul, norm_eq_of_mem_sphere, one_mul]\n\n"}
