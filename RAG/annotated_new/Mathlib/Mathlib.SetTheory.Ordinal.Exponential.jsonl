{"name":"Ordinal.zero_opow'","module":"Mathlib.SetTheory.Ordinal.Exponential","initialProofState":"a : Ordinal.{u_1}\n⊢ Eq (HPow.hPow 0 a) (HSub.hSub 1 a)","decl":"/-- `0 ^ a = 1` if `a = 0` and `0 ^ a = 0` otherwise. -/\ntheorem zero_opow' (a : Ordinal) : 0 ^ a = 1 - a :=\n  if_pos rfl\n\n"}
{"name":"Ordinal.zero_opow_le","module":"Mathlib.SetTheory.Ordinal.Exponential","initialProofState":"a : Ordinal.{u_1}\n⊢ LE.le (HPow.hPow 0 a) 1","decl":"theorem zero_opow_le (a : Ordinal) : (0 : Ordinal) ^ a ≤ 1 := by\n  rw [zero_opow']\n  exact sub_le_self 1 a\n\n"}
{"name":"Ordinal.zero_opow","module":"Mathlib.SetTheory.Ordinal.Exponential","initialProofState":"a : Ordinal.{u_1}\na0 : Ne a 0\n⊢ Eq (HPow.hPow 0 a) 0","decl":"@[simp]\ntheorem zero_opow {a : Ordinal} (a0 : a ≠ 0) : (0 : Ordinal) ^ a = 0 := by\n  rwa [zero_opow', Ordinal.sub_eq_zero_iff_le, one_le_iff_ne_zero]\n\n"}
{"name":"Ordinal.opow_zero","module":"Mathlib.SetTheory.Ordinal.Exponential","initialProofState":"a : Ordinal.{u_1}\n⊢ Eq (HPow.hPow a 0) 1","decl":"@[simp]\ntheorem opow_zero (a : Ordinal) : a ^ (0 : Ordinal) = 1 := by\n  obtain rfl | h := eq_or_ne a 0\n  · rw [zero_opow', Ordinal.sub_zero]\n  · rw [opow_of_ne_zero h, limitRecOn_zero]\n\n"}
{"name":"Ordinal.opow_succ","module":"Mathlib.SetTheory.Ordinal.Exponential","initialProofState":"a b : Ordinal.{u_1}\n⊢ Eq (HPow.hPow a (Order.succ b)) (HMul.hMul (HPow.hPow a b) a)","decl":"@[simp]\ntheorem opow_succ (a b : Ordinal) : a ^ succ b = a ^ b * a := by\n  obtain rfl | h := eq_or_ne a 0\n  · rw [zero_opow (succ_ne_zero b), mul_zero]\n  · rw [opow_of_ne_zero h, opow_of_ne_zero h, limitRecOn_succ]\n\n"}
{"name":"Ordinal.opow_limit","module":"Mathlib.SetTheory.Ordinal.Exponential","initialProofState":"a b : Ordinal.{u_1}\nha : Ne a 0\nhb : b.IsLimit\n⊢ Eq (HPow.hPow a b) (iSup fun x => HPow.hPow a ↑x)","decl":"theorem opow_limit {a b : Ordinal} (ha : a ≠ 0) (hb : IsLimit b) :\n    a ^ b = ⨆ x : Iio b, a ^ x.1 := by\n  simp_rw [opow_of_ne_zero ha, limitRecOn_limit _ _ _ _ hb]\n\n"}
{"name":"Ordinal.opow_le_of_limit","module":"Mathlib.SetTheory.Ordinal.Exponential","initialProofState":"a b c : Ordinal.{u_1}\na0 : Ne a 0\nh : b.IsLimit\n⊢ Iff (LE.le (HPow.hPow a b) c) (∀ (b' : Ordinal.{u_1}), LT.lt b' b → LE.le (HPow.hPow a b') c)","decl":"theorem opow_le_of_limit {a b c : Ordinal} (a0 : a ≠ 0) (h : IsLimit b) :\n    a ^ b ≤ c ↔ ∀ b' < b, a ^ b' ≤ c := by\n  rw [opow_limit a0 h, Ordinal.iSup_le_iff, Subtype.forall]\n  rfl\n\n"}
{"name":"Ordinal.lt_opow_of_limit","module":"Mathlib.SetTheory.Ordinal.Exponential","initialProofState":"a b c : Ordinal.{u_1}\nb0 : Ne b 0\nh : c.IsLimit\n⊢ Iff (LT.lt a (HPow.hPow b c)) (Exists fun c' => And (LT.lt c' c) (LT.lt a (HPow.hPow b c')))","decl":"theorem lt_opow_of_limit {a b c : Ordinal} (b0 : b ≠ 0) (h : IsLimit c) :\n    a < b ^ c ↔ ∃ c' < c, a < b ^ c' := by\n  rw [← not_iff_not, not_exists]\n  simp only [not_lt, opow_le_of_limit b0 h, exists_prop, not_and]\n\n"}
{"name":"Ordinal.opow_one","module":"Mathlib.SetTheory.Ordinal.Exponential","initialProofState":"a : Ordinal.{u_1}\n⊢ Eq (HPow.hPow a 1) a","decl":"@[simp]\ntheorem opow_one (a : Ordinal) : a ^ (1 : Ordinal) = a := by\n  rw [← succ_zero, opow_succ]\n  simp only [opow_zero, one_mul]\n\n"}
{"name":"Ordinal.one_opow","module":"Mathlib.SetTheory.Ordinal.Exponential","initialProofState":"a : Ordinal.{u_1}\n⊢ Eq (HPow.hPow 1 a) 1","decl":"@[simp]\ntheorem one_opow (a : Ordinal) : (1 : Ordinal) ^ a = 1 := by\n  induction a using limitRecOn with\n  | H₁ => simp only [opow_zero]\n  | H₂ _ ih =>\n    simp only [opow_succ, ih, mul_one]\n  | H₃ b l IH =>\n    refine eq_of_forall_ge_iff fun c => ?_\n    rw [opow_le_of_limit Ordinal.one_ne_zero l]\n    exact ⟨fun H => by simpa only [opow_zero] using H 0 l.pos, fun H b' h => by rwa [IH _ h]⟩\n\n"}
{"name":"Ordinal.opow_pos","module":"Mathlib.SetTheory.Ordinal.Exponential","initialProofState":"a b : Ordinal.{u_1}\na0 : LT.lt 0 a\n⊢ LT.lt 0 (HPow.hPow a b)","decl":"theorem opow_pos {a : Ordinal} (b : Ordinal) (a0 : 0 < a) : 0 < a ^ b := by\n  have h0 : 0 < a ^ (0 : Ordinal) := by simp only [opow_zero, zero_lt_one]\n  induction b using limitRecOn with\n  | H₁ => exact h0\n  | H₂ b IH =>\n    rw [opow_succ]\n    exact mul_pos IH a0\n  | H₃ b l _ =>\n    exact (lt_opow_of_limit (Ordinal.pos_iff_ne_zero.1 a0) l).2 ⟨0, l.pos, h0⟩\n\n"}
{"name":"Ordinal.opow_ne_zero","module":"Mathlib.SetTheory.Ordinal.Exponential","initialProofState":"a b : Ordinal.{u_1}\na0 : Ne a 0\n⊢ Ne (HPow.hPow a b) 0","decl":"theorem opow_ne_zero {a : Ordinal} (b : Ordinal) (a0 : a ≠ 0) : a ^ b ≠ 0 :=\n  Ordinal.pos_iff_ne_zero.1 <| opow_pos b <| Ordinal.pos_iff_ne_zero.2 a0\n\n"}
{"name":"Ordinal.opow_eq_zero","module":"Mathlib.SetTheory.Ordinal.Exponential","initialProofState":"a b : Ordinal.{u_1}\n⊢ Iff (Eq (HPow.hPow a b) 0) (And (Eq a 0) (Ne b 0))","decl":"@[simp]\ntheorem opow_eq_zero {a b : Ordinal} : a ^ b = 0 ↔ a = 0 ∧ b ≠ 0 := by\n  obtain rfl | ha := eq_or_ne a 0\n  · obtain rfl | hb := eq_or_ne b 0\n    · simp\n    · simp [hb]\n  · simp [opow_ne_zero b ha, ha]\n\n"}
{"name":"Ordinal.opow_natCast","module":"Mathlib.SetTheory.Ordinal.Exponential","initialProofState":"a : Ordinal.{u_1}\nn : Nat\n⊢ Eq (HPow.hPow a ↑n) (HPow.hPow a n)","decl":"@[simp, norm_cast]\ntheorem opow_natCast (a : Ordinal) (n : ℕ) : a ^ (n : Ordinal) = a ^ n := by\n  induction n with\n  | zero => rw [Nat.cast_zero, opow_zero, pow_zero]\n  | succ n IH => rw [Nat.cast_succ, add_one_eq_succ, opow_succ, pow_succ, IH]\n\n"}
{"name":"Ordinal.isNormal_opow","module":"Mathlib.SetTheory.Ordinal.Exponential","initialProofState":"a : Ordinal.{u_1}\nh : LT.lt 1 a\n⊢ Ordinal.IsNormal fun x => HPow.hPow a x","decl":"theorem isNormal_opow {a : Ordinal} (h : 1 < a) : IsNormal (a ^ ·) :=\n  have a0 : 0 < a := zero_lt_one.trans h\n  ⟨fun b => by simpa only [mul_one, opow_succ] using (mul_lt_mul_iff_left (opow_pos b a0)).2 h,\n    fun _ l _ => opow_le_of_limit (ne_of_gt a0) l⟩\n\n"}
{"name":"Ordinal.opow_isNormal","module":"Mathlib.SetTheory.Ordinal.Exponential","initialProofState":"a : Ordinal.{u_1}\nh : LT.lt 1 a\n⊢ Ordinal.IsNormal fun x => HPow.hPow a x","decl":"@[deprecated isNormal_opow (since := \"2024-10-11\")]\nalias opow_isNormal := isNormal_opow\n\n"}
{"name":"Ordinal.opow_lt_opow_iff_right","module":"Mathlib.SetTheory.Ordinal.Exponential","initialProofState":"a b c : Ordinal.{u_1}\na1 : LT.lt 1 a\n⊢ Iff (LT.lt (HPow.hPow a b) (HPow.hPow a c)) (LT.lt b c)","decl":"theorem opow_lt_opow_iff_right {a b c : Ordinal} (a1 : 1 < a) : a ^ b < a ^ c ↔ b < c :=\n  (isNormal_opow a1).lt_iff\n\n"}
{"name":"Ordinal.opow_le_opow_iff_right","module":"Mathlib.SetTheory.Ordinal.Exponential","initialProofState":"a b c : Ordinal.{u_1}\na1 : LT.lt 1 a\n⊢ Iff (LE.le (HPow.hPow a b) (HPow.hPow a c)) (LE.le b c)","decl":"theorem opow_le_opow_iff_right {a b c : Ordinal} (a1 : 1 < a) : a ^ b ≤ a ^ c ↔ b ≤ c :=\n  (isNormal_opow a1).le_iff\n\n"}
{"name":"Ordinal.opow_right_inj","module":"Mathlib.SetTheory.Ordinal.Exponential","initialProofState":"a b c : Ordinal.{u_1}\na1 : LT.lt 1 a\n⊢ Iff (Eq (HPow.hPow a b) (HPow.hPow a c)) (Eq b c)","decl":"theorem opow_right_inj {a b c : Ordinal} (a1 : 1 < a) : a ^ b = a ^ c ↔ b = c :=\n  (isNormal_opow a1).inj\n\n"}
{"name":"Ordinal.isLimit_opow","module":"Mathlib.SetTheory.Ordinal.Exponential","initialProofState":"a b : Ordinal.{u_1}\na1 : LT.lt 1 a\na✝ : b.IsLimit\n⊢ (HPow.hPow a b).IsLimit","decl":"theorem isLimit_opow {a b : Ordinal} (a1 : 1 < a) : IsLimit b → IsLimit (a ^ b) :=\n  (isNormal_opow a1).isLimit\n\n"}
{"name":"Ordinal.opow_isLimit","module":"Mathlib.SetTheory.Ordinal.Exponential","initialProofState":"a b : Ordinal.{u_1}\na1 : LT.lt 1 a\na✝ : b.IsLimit\n⊢ (HPow.hPow a b).IsLimit","decl":"@[deprecated isLimit_opow (since := \"2024-10-11\")]\nalias opow_isLimit := isLimit_opow\n\n"}
{"name":"Ordinal.isLimit_opow_left","module":"Mathlib.SetTheory.Ordinal.Exponential","initialProofState":"a b : Ordinal.{u_1}\nl : a.IsLimit\nhb : Ne b 0\n⊢ (HPow.hPow a b).IsLimit","decl":"theorem isLimit_opow_left {a b : Ordinal} (l : IsLimit a) (hb : b ≠ 0) : IsLimit (a ^ b) := by\n  rcases zero_or_succ_or_limit b with (e | ⟨b, rfl⟩ | l')\n  · exact absurd e hb\n  · rw [opow_succ]\n    exact isLimit_mul (opow_pos _ l.pos) l\n  · exact isLimit_opow l.one_lt l'\n\n"}
{"name":"Ordinal.opow_isLimit_left","module":"Mathlib.SetTheory.Ordinal.Exponential","initialProofState":"a b : Ordinal.{u_1}\nl : a.IsLimit\nhb : Ne b 0\n⊢ (HPow.hPow a b).IsLimit","decl":"@[deprecated isLimit_opow_left (since := \"2024-10-11\")]\nalias opow_isLimit_left := isLimit_opow_left\n\n"}
{"name":"Ordinal.opow_le_opow_right","module":"Mathlib.SetTheory.Ordinal.Exponential","initialProofState":"a b c : Ordinal.{u_1}\nh₁ : LT.lt 0 a\nh₂ : LE.le b c\n⊢ LE.le (HPow.hPow a b) (HPow.hPow a c)","decl":"theorem opow_le_opow_right {a b c : Ordinal} (h₁ : 0 < a) (h₂ : b ≤ c) : a ^ b ≤ a ^ c := by\n  rcases lt_or_eq_of_le (one_le_iff_pos.2 h₁) with h₁ | h₁\n  · exact (opow_le_opow_iff_right h₁).2 h₂\n  · subst a\n    -- Porting note: `le_refl` is required.\n    simp only [one_opow, le_refl]\n\n"}
{"name":"Ordinal.opow_le_opow_left","module":"Mathlib.SetTheory.Ordinal.Exponential","initialProofState":"a b c : Ordinal.{u_1}\nab : LE.le a b\n⊢ LE.le (HPow.hPow a c) (HPow.hPow b c)","decl":"theorem opow_le_opow_left {a b : Ordinal} (c : Ordinal) (ab : a ≤ b) : a ^ c ≤ b ^ c := by\n  by_cases a0 : a = 0\n  -- Porting note: `le_refl` is required.\n  · subst a\n    by_cases c0 : c = 0\n    · subst c\n      simp only [opow_zero, le_refl]\n    · simp only [zero_opow c0, Ordinal.zero_le]\n  · induction c using limitRecOn with\n    | H₁ => simp only [opow_zero, le_refl]\n    | H₂ c IH =>\n      simpa only [opow_succ] using mul_le_mul' IH ab\n    | H₃ c l IH =>\n      exact\n        (opow_le_of_limit a0 l).2 fun b' h =>\n          (IH _ h).trans (opow_le_opow_right ((Ordinal.pos_iff_ne_zero.2 a0).trans_le ab) h.le)\n\n"}
{"name":"Ordinal.opow_le_opow","module":"Mathlib.SetTheory.Ordinal.Exponential","initialProofState":"a b c d : Ordinal.{u_1}\nhac : LE.le a c\nhbd : LE.le b d\nhc : LT.lt 0 c\n⊢ LE.le (HPow.hPow a b) (HPow.hPow c d)","decl":"theorem opow_le_opow {a b c d : Ordinal} (hac : a ≤ c) (hbd : b ≤ d) (hc : 0 < c) : a ^ b ≤ c ^ d :=\n  (opow_le_opow_left b hac).trans (opow_le_opow_right hc hbd)\n\n"}
{"name":"Ordinal.left_le_opow","module":"Mathlib.SetTheory.Ordinal.Exponential","initialProofState":"a b : Ordinal.{u_1}\nb1 : LT.lt 0 b\n⊢ LE.le a (HPow.hPow a b)","decl":"theorem left_le_opow (a : Ordinal) {b : Ordinal} (b1 : 0 < b) : a ≤ a ^ b := by\n  nth_rw 1 [← opow_one a]\n  cases' le_or_gt a 1 with a1 a1\n  · rcases lt_or_eq_of_le a1 with a0 | a1\n    · rw [lt_one_iff_zero] at a0\n      rw [a0, zero_opow Ordinal.one_ne_zero]\n      exact Ordinal.zero_le _\n    rw [a1, one_opow, one_opow]\n  rwa [opow_le_opow_iff_right a1, one_le_iff_pos]\n\n"}
{"name":"Ordinal.left_lt_opow","module":"Mathlib.SetTheory.Ordinal.Exponential","initialProofState":"a b : Ordinal.{u_1}\nha : LT.lt 1 a\nhb : LT.lt 1 b\n⊢ LT.lt a (HPow.hPow a b)","decl":"theorem left_lt_opow {a b : Ordinal} (ha : 1 < a) (hb : 1 < b) : a < a ^ b := by\n  conv_lhs => rw [← opow_one a]\n  rwa [opow_lt_opow_iff_right ha]\n\n"}
{"name":"Ordinal.right_le_opow","module":"Mathlib.SetTheory.Ordinal.Exponential","initialProofState":"a b : Ordinal.{u_1}\na1 : LT.lt 1 a\n⊢ LE.le b (HPow.hPow a b)","decl":"theorem right_le_opow {a : Ordinal} (b : Ordinal) (a1 : 1 < a) : b ≤ a ^ b :=\n  (isNormal_opow a1).le_apply\n\n"}
{"name":"Ordinal.opow_lt_opow_left_of_succ","module":"Mathlib.SetTheory.Ordinal.Exponential","initialProofState":"a b c : Ordinal.{u_1}\nab : LT.lt a b\n⊢ LT.lt (HPow.hPow a (Order.succ c)) (HPow.hPow b (Order.succ c))","decl":"theorem opow_lt_opow_left_of_succ {a b c : Ordinal} (ab : a < b) : a ^ succ c < b ^ succ c := by\n  rw [opow_succ, opow_succ]\n  exact\n    (mul_le_mul_right' (opow_le_opow_left c ab.le) a).trans_lt\n      (mul_lt_mul_of_pos_left ab (opow_pos c ((Ordinal.zero_le a).trans_lt ab)))\n\n"}
{"name":"Ordinal.opow_add","module":"Mathlib.SetTheory.Ordinal.Exponential","initialProofState":"a b c : Ordinal.{u_1}\n⊢ Eq (HPow.hPow a (HAdd.hAdd b c)) (HMul.hMul (HPow.hPow a b) (HPow.hPow a c))","decl":"theorem opow_add (a b c : Ordinal) : a ^ (b + c) = a ^ b * a ^ c := by\n  rcases eq_or_ne a 0 with (rfl | a0)\n  · rcases eq_or_ne c 0 with (rfl | c0)\n    · simp\n    have : b + c ≠ 0 := ((Ordinal.pos_iff_ne_zero.2 c0).trans_le (le_add_left _ _)).ne'\n    simp only [zero_opow c0, zero_opow this, mul_zero]\n  rcases eq_or_lt_of_le (one_le_iff_ne_zero.2 a0) with (rfl | a1)\n  · simp only [one_opow, mul_one]\n  induction c using limitRecOn with\n  | H₁ => simp\n  | H₂ c IH =>\n    rw [add_succ, opow_succ, IH, opow_succ, mul_assoc]\n  | H₃ c l IH =>\n    refine\n      eq_of_forall_ge_iff fun d =>\n        (((isNormal_opow a1).trans (isNormal_add_right b)).limit_le l).trans ?_\n    dsimp only [Function.comp_def]\n    simp +contextual only [IH]\n    exact\n      (((isNormal_mul_right <| opow_pos b (Ordinal.pos_iff_ne_zero.2 a0)).trans\n              (isNormal_opow a1)).limit_le\n          l).symm\n\n"}
{"name":"Ordinal.opow_one_add","module":"Mathlib.SetTheory.Ordinal.Exponential","initialProofState":"a b : Ordinal.{u_1}\n⊢ Eq (HPow.hPow a (HAdd.hAdd 1 b)) (HMul.hMul a (HPow.hPow a b))","decl":"theorem opow_one_add (a b : Ordinal) : a ^ (1 + b) = a * a ^ b := by rw [opow_add, opow_one]\n\n"}
{"name":"Ordinal.opow_dvd_opow","module":"Mathlib.SetTheory.Ordinal.Exponential","initialProofState":"a b c : Ordinal.{u_1}\nh : LE.le b c\n⊢ Dvd.dvd (HPow.hPow a b) (HPow.hPow a c)","decl":"theorem opow_dvd_opow (a : Ordinal) {b c : Ordinal} (h : b ≤ c) : a ^ b ∣ a ^ c :=\n  ⟨a ^ (c - b), by rw [← opow_add, Ordinal.add_sub_cancel_of_le h]⟩\n\n"}
{"name":"Ordinal.opow_dvd_opow_iff","module":"Mathlib.SetTheory.Ordinal.Exponential","initialProofState":"a b c : Ordinal.{u_1}\na1 : LT.lt 1 a\n⊢ Iff (Dvd.dvd (HPow.hPow a b) (HPow.hPow a c)) (LE.le b c)","decl":"theorem opow_dvd_opow_iff {a b c : Ordinal} (a1 : 1 < a) : a ^ b ∣ a ^ c ↔ b ≤ c :=\n  ⟨fun h =>\n    le_of_not_lt fun hn =>\n      not_le_of_lt ((opow_lt_opow_iff_right a1).2 hn) <|\n        le_of_dvd (opow_ne_zero _ <| one_le_iff_ne_zero.1 <| a1.le) h,\n    opow_dvd_opow _⟩\n\n"}
{"name":"Ordinal.opow_mul","module":"Mathlib.SetTheory.Ordinal.Exponential","initialProofState":"a b c : Ordinal.{u_1}\n⊢ Eq (HPow.hPow a (HMul.hMul b c)) (HPow.hPow (HPow.hPow a b) c)","decl":"theorem opow_mul (a b c : Ordinal) : a ^ (b * c) = (a ^ b) ^ c := by\n  by_cases b0 : b = 0; · simp only [b0, zero_mul, opow_zero, one_opow]\n  by_cases a0 : a = 0\n  · subst a\n    by_cases c0 : c = 0\n    · simp only [c0, mul_zero, opow_zero]\n    simp only [zero_opow b0, zero_opow c0, zero_opow (mul_ne_zero b0 c0)]\n  cases' eq_or_lt_of_le (one_le_iff_ne_zero.2 a0) with a1 a1\n  · subst a1\n    simp only [one_opow]\n  induction c using limitRecOn with\n  | H₁ => simp only [mul_zero, opow_zero]\n  | H₂ c IH =>\n    rw [mul_succ, opow_add, IH, opow_succ]\n  | H₃ c l IH =>\n    refine\n      eq_of_forall_ge_iff fun d =>\n        (((isNormal_opow a1).trans (isNormal_mul_right (Ordinal.pos_iff_ne_zero.2 b0))).limit_le\n              l).trans\n          ?_\n    dsimp only [Function.comp_def]\n    simp +contextual only [IH]\n    exact (opow_le_of_limit (opow_ne_zero _ a0) l).symm\n\n"}
{"name":"Ordinal.opow_mul_add_pos","module":"Mathlib.SetTheory.Ordinal.Exponential","initialProofState":"b v : Ordinal.{u_1}\nhb : Ne b 0\nu : Ordinal.{u_1}\nhv : Ne v 0\nw : Ordinal.{u_1}\n⊢ LT.lt 0 (HAdd.hAdd (HMul.hMul (HPow.hPow b u) v) w)","decl":"theorem opow_mul_add_pos {b v : Ordinal} (hb : b ≠ 0) (u : Ordinal) (hv : v ≠ 0) (w : Ordinal) :\n    0 < b ^ u * v + w :=\n  (opow_pos u <| Ordinal.pos_iff_ne_zero.2 hb).trans_le <|\n    (le_mul_left _ <| Ordinal.pos_iff_ne_zero.2 hv).trans <| le_add_right _ _\n\n"}
{"name":"Ordinal.opow_mul_add_lt_opow_mul_succ","module":"Mathlib.SetTheory.Ordinal.Exponential","initialProofState":"b u w v : Ordinal.{u_1}\nhw : LT.lt w (HPow.hPow b u)\n⊢ LT.lt (HAdd.hAdd (HMul.hMul (HPow.hPow b u) v) w) (HMul.hMul (HPow.hPow b u) (Order.succ v))","decl":"theorem opow_mul_add_lt_opow_mul_succ {b u w : Ordinal} (v : Ordinal) (hw : w < b ^ u) :\n    b ^ u * v + w < b ^ u * succ v := by\n  rwa [mul_succ, add_lt_add_iff_left]\n\n"}
{"name":"Ordinal.opow_mul_add_lt_opow_succ","module":"Mathlib.SetTheory.Ordinal.Exponential","initialProofState":"b u v w : Ordinal.{u_1}\nhvb : LT.lt v b\nhw : LT.lt w (HPow.hPow b u)\n⊢ LT.lt (HAdd.hAdd (HMul.hMul (HPow.hPow b u) v) w) (HPow.hPow b (Order.succ u))","decl":"theorem opow_mul_add_lt_opow_succ {b u v w : Ordinal} (hvb : v < b) (hw : w < b ^ u) :\n    b ^ u * v + w < b ^ succ u := by\n  convert (opow_mul_add_lt_opow_mul_succ v hw).trans_le\n    (mul_le_mul_left' (succ_le_of_lt hvb) _) using 1\n  exact opow_succ b u\n\n"}
{"name":"Ordinal.log_def","module":"Mathlib.SetTheory.Ordinal.Exponential","initialProofState":"b : Ordinal.{u_1}\nh : LT.lt 1 b\nx : Ordinal.{u_1}\n⊢ Eq (Ordinal.log b x) (InfSet.sInf (setOf fun o => LT.lt x (HPow.hPow b o))).pred","decl":"theorem log_def {b : Ordinal} (h : 1 < b) (x : Ordinal) : log b x = pred (sInf { o | x < b ^ o }) :=\n  if_pos h\n\n"}
{"name":"Ordinal.log_of_left_le_one","module":"Mathlib.SetTheory.Ordinal.Exponential","initialProofState":"b : Ordinal.{u_1}\nh : LE.le b 1\nx : Ordinal.{u_1}\n⊢ Eq (Ordinal.log b x) 0","decl":"theorem log_of_left_le_one {b : Ordinal} (h : b ≤ 1) (x : Ordinal) : log b x = 0 :=\n  if_neg h.not_lt\n\n"}
{"name":"Ordinal.log_of_not_one_lt_left","module":"Mathlib.SetTheory.Ordinal.Exponential","initialProofState":"b : Ordinal.{u_1}\nh : Not (LT.lt 1 b)\nx : Ordinal.{u_1}\n⊢ Eq (Ordinal.log b x) 0","decl":"@[deprecated log_of_left_le_one (since := \"2024-10-10\")]\ntheorem log_of_not_one_lt_left {b : Ordinal} (h : ¬1 < b) (x : Ordinal) : log b x = 0 := by\n  simp only [log, if_neg h]\n\n"}
{"name":"Ordinal.log_zero_left","module":"Mathlib.SetTheory.Ordinal.Exponential","initialProofState":"b : Ordinal.{u_1}\n⊢ Eq (Ordinal.log 0 b) 0","decl":"@[simp]\ntheorem log_zero_left : ∀ b, log 0 b = 0 :=\n  log_of_left_le_one zero_le_one\n\n"}
{"name":"Ordinal.log_zero_right","module":"Mathlib.SetTheory.Ordinal.Exponential","initialProofState":"b : Ordinal.{u_1}\n⊢ Eq (Ordinal.log b 0) 0","decl":"@[simp]\ntheorem log_zero_right (b : Ordinal) : log b 0 = 0 := by\n  obtain hb | hb := lt_or_le 1 b\n  · rw [log_def hb, ← Ordinal.le_zero, pred_le, succ_zero]\n    apply csInf_le'\n    rw [mem_setOf, opow_one]\n    exact bot_lt_of_lt hb\n  · rw [log_of_left_le_one hb]\n\n"}
{"name":"Ordinal.log_one_left","module":"Mathlib.SetTheory.Ordinal.Exponential","initialProofState":"b : Ordinal.{u_1}\n⊢ Eq (Ordinal.log 1 b) 0","decl":"@[simp]\ntheorem log_one_left : ∀ b, log 1 b = 0 :=\n  log_of_left_le_one le_rfl\n\n"}
{"name":"Ordinal.succ_log_def","module":"Mathlib.SetTheory.Ordinal.Exponential","initialProofState":"b x : Ordinal.{u_1}\nhb : LT.lt 1 b\nhx : Ne x 0\n⊢ Eq (Order.succ (Ordinal.log b x)) (InfSet.sInf (setOf fun o => LT.lt x (HPow.hPow b o)))","decl":"theorem succ_log_def {b x : Ordinal} (hb : 1 < b) (hx : x ≠ 0) :\n    succ (log b x) = sInf { o : Ordinal | x < b ^ o } := by\n  let t := sInf { o : Ordinal | x < b ^ o }\n  have : x < b ^ t := csInf_mem (log_nonempty hb)\n  rcases zero_or_succ_or_limit t with (h | h | h)\n  · refine ((one_le_iff_ne_zero.2 hx).not_lt ?_).elim\n    simpa only [h, opow_zero] using this\n  · rw [show log b x = pred t from log_def hb x, succ_pred_iff_is_succ.2 h]\n  · rcases (lt_opow_of_limit (zero_lt_one.trans hb).ne' h).1 this with ⟨a, h₁, h₂⟩\n    exact h₁.not_le.elim ((le_csInf_iff'' (log_nonempty hb)).1 le_rfl a h₂)\n\n"}
{"name":"Ordinal.lt_opow_succ_log_self","module":"Mathlib.SetTheory.Ordinal.Exponential","initialProofState":"b : Ordinal.{u_1}\nhb : LT.lt 1 b\nx : Ordinal.{u_1}\n⊢ LT.lt x (HPow.hPow b (Order.succ (Ordinal.log b x)))","decl":"theorem lt_opow_succ_log_self {b : Ordinal} (hb : 1 < b) (x : Ordinal) :\n    x < b ^ succ (log b x) := by\n  rcases eq_or_ne x 0 with (rfl | hx)\n  · apply opow_pos _ (zero_lt_one.trans hb)\n  · rw [succ_log_def hb hx]\n    exact csInf_mem (log_nonempty hb)\n\n"}
{"name":"Ordinal.opow_log_le_self","module":"Mathlib.SetTheory.Ordinal.Exponential","initialProofState":"b x : Ordinal.{u_1}\nhx : Ne x 0\n⊢ LE.le (HPow.hPow b (Ordinal.log b x)) x","decl":"theorem opow_log_le_self (b : Ordinal) {x : Ordinal} (hx : x ≠ 0) : b ^ log b x ≤ x := by\n  rcases eq_or_ne b 0 with (rfl | b0)\n  · exact (zero_opow_le _).trans (one_le_iff_ne_zero.2 hx)\n  rcases lt_or_eq_of_le (one_le_iff_ne_zero.2 b0) with (hb | rfl)\n  · refine le_of_not_lt fun h => (lt_succ (log b x)).not_le ?_\n    have := @csInf_le' _ _ { o | x < b ^ o } _ h\n    rwa [← succ_log_def hb hx] at this\n  · rwa [one_opow, one_le_iff_ne_zero]\n\n"}
{"name":"Ordinal.opow_le_iff_le_log","module":"Mathlib.SetTheory.Ordinal.Exponential","initialProofState":"b x c : Ordinal.{u_1}\nhb : LT.lt 1 b\nhx : Ne x 0\n⊢ Iff (LE.le (HPow.hPow b c) x) (LE.le c (Ordinal.log b x))","decl":"/-- `opow b` and `log b` (almost) form a Galois connection.\n\nSee `opow_le_iff_le_log'` for a variant assuming `c ≠ 0` rather than `x ≠ 0`. See also\n`le_log_of_opow_le` and `opow_le_of_le_log`, which are both separate implications under weaker\nassumptions. -/\ntheorem opow_le_iff_le_log {b x c : Ordinal} (hb : 1 < b) (hx : x ≠ 0) :\n    b ^ c ≤ x ↔ c ≤ log b x := by\n  constructor <;>\n  intro h\n  · apply le_of_not_lt\n    intro hn\n    apply (lt_opow_succ_log_self hb x).not_le <|\n      ((opow_le_opow_iff_right hb).2 <| succ_le_of_lt hn).trans h\n  · exact ((opow_le_opow_iff_right hb).2 h).trans <| opow_log_le_self b hx\n\n"}
{"name":"Ordinal.opow_le_iff_le_log'","module":"Mathlib.SetTheory.Ordinal.Exponential","initialProofState":"b x c : Ordinal.{u_1}\nhb : LT.lt 1 b\nhc : Ne c 0\n⊢ Iff (LE.le (HPow.hPow b c) x) (LE.le c (Ordinal.log b x))","decl":"/-- `opow b` and `log b` (almost) form a Galois connection.\n\nSee `opow_le_iff_le_log` for a variant assuming `x ≠ 0` rather than `c ≠ 0`. See also\n`le_log_of_opow_le` and `opow_le_of_le_log`, which are both separate implications under weaker\nassumptions. -/\ntheorem opow_le_iff_le_log' {b x c : Ordinal} (hb : 1 < b) (hc : c ≠ 0) :\n    b ^ c ≤ x ↔ c ≤ log b x := by\n  obtain rfl | hx := eq_or_ne x 0\n  · rw [log_zero_right, Ordinal.le_zero, Ordinal.le_zero, opow_eq_zero]\n    simp [hc, (zero_lt_one.trans hb).ne']\n  · exact opow_le_iff_le_log hb hx\n\n"}
{"name":"Ordinal.le_log_of_opow_le","module":"Mathlib.SetTheory.Ordinal.Exponential","initialProofState":"b x c : Ordinal.{u_1}\nhb : LT.lt 1 b\nh : LE.le (HPow.hPow b c) x\n⊢ LE.le c (Ordinal.log b x)","decl":"theorem le_log_of_opow_le {b x c : Ordinal} (hb : 1 < b) (h : b ^ c ≤ x) : c ≤ log b x := by\n  obtain rfl | hx := eq_or_ne x 0\n  · rw [Ordinal.le_zero, opow_eq_zero] at h\n    exact (zero_lt_one.asymm <| h.1 ▸ hb).elim\n  · exact (opow_le_iff_le_log hb hx).1 h\n\n"}
{"name":"Ordinal.opow_le_of_le_log","module":"Mathlib.SetTheory.Ordinal.Exponential","initialProofState":"b x c : Ordinal.{u_1}\nhc : Ne c 0\nh : LE.le c (Ordinal.log b x)\n⊢ LE.le (HPow.hPow b c) x","decl":"theorem opow_le_of_le_log {b x c : Ordinal} (hc : c ≠ 0) (h : c ≤ log b x) : b ^ c ≤ x := by\n  obtain hb | hb := le_or_lt b 1\n  · rw [log_of_left_le_one hb] at h\n    exact (h.not_lt (Ordinal.pos_iff_ne_zero.2 hc)).elim\n  · rwa [opow_le_iff_le_log' hb hc]\n\n"}
{"name":"Ordinal.lt_opow_iff_log_lt","module":"Mathlib.SetTheory.Ordinal.Exponential","initialProofState":"b x c : Ordinal.{u_1}\nhb : LT.lt 1 b\nhx : Ne x 0\n⊢ Iff (LT.lt x (HPow.hPow b c)) (LT.lt (Ordinal.log b x) c)","decl":"/-- `opow b` and `log b` (almost) form a Galois connection.\n\nSee `lt_opow_iff_log_lt'` for a variant assuming `c ≠ 0` rather than `x ≠ 0`. See also\n`lt_opow_of_log_lt` and `lt_log_of_lt_opow`, which are both separate implications under weaker\nassumptions. -/\ntheorem lt_opow_iff_log_lt {b x c : Ordinal} (hb : 1 < b) (hx : x ≠ 0) : x < b ^ c ↔ log b x < c :=\n  lt_iff_lt_of_le_iff_le (opow_le_iff_le_log hb hx)\n\n"}
{"name":"Ordinal.lt_opow_iff_log_lt'","module":"Mathlib.SetTheory.Ordinal.Exponential","initialProofState":"b x c : Ordinal.{u_1}\nhb : LT.lt 1 b\nhc : Ne c 0\n⊢ Iff (LT.lt x (HPow.hPow b c)) (LT.lt (Ordinal.log b x) c)","decl":"/-- `opow b` and `log b` (almost) form a Galois connection.\n\nSee `lt_opow_iff_log_lt` for a variant assuming `x ≠ 0` rather than `c ≠ 0`. See also\n`lt_opow_of_log_lt` and `lt_log_of_lt_opow`, which are both separate implications under weaker\nassumptions. -/\ntheorem lt_opow_iff_log_lt' {b x c : Ordinal} (hb : 1 < b) (hc : c ≠ 0) : x < b ^ c ↔ log b x < c :=\n  lt_iff_lt_of_le_iff_le (opow_le_iff_le_log' hb hc)\n\n"}
{"name":"Ordinal.lt_opow_of_log_lt","module":"Mathlib.SetTheory.Ordinal.Exponential","initialProofState":"b x c : Ordinal.{u_1}\nhb : LT.lt 1 b\na✝ : LT.lt (Ordinal.log b x) c\n⊢ LT.lt x (HPow.hPow b c)","decl":"theorem lt_opow_of_log_lt {b x c : Ordinal} (hb : 1 < b) : log b x < c → x < b ^ c :=\n  lt_imp_lt_of_le_imp_le <| le_log_of_opow_le hb\n\n"}
{"name":"Ordinal.lt_log_of_lt_opow","module":"Mathlib.SetTheory.Ordinal.Exponential","initialProofState":"b x c : Ordinal.{u_1}\nhc : Ne c 0\na✝ : LT.lt x (HPow.hPow b c)\n⊢ LT.lt (Ordinal.log b x) c","decl":"theorem lt_log_of_lt_opow {b x c : Ordinal} (hc : c ≠ 0) : x < b ^ c → log b x < c :=\n  lt_imp_lt_of_le_imp_le <| opow_le_of_le_log hc\n\n"}
{"name":"Ordinal.log_pos","module":"Mathlib.SetTheory.Ordinal.Exponential","initialProofState":"b o : Ordinal.{u_1}\nhb : LT.lt 1 b\nho : Ne o 0\nhbo : LE.le b o\n⊢ LT.lt 0 (Ordinal.log b o)","decl":"theorem log_pos {b o : Ordinal} (hb : 1 < b) (ho : o ≠ 0) (hbo : b ≤ o) : 0 < log b o := by\n  rwa [← succ_le_iff, succ_zero, ← opow_le_iff_le_log hb ho, opow_one]\n\n"}
{"name":"Ordinal.log_eq_zero","module":"Mathlib.SetTheory.Ordinal.Exponential","initialProofState":"b o : Ordinal.{u_1}\nhbo : LT.lt o b\n⊢ Eq (Ordinal.log b o) 0","decl":"theorem log_eq_zero {b o : Ordinal} (hbo : o < b) : log b o = 0 := by\n  rcases eq_or_ne o 0 with (rfl | ho)\n  · exact log_zero_right b\n  rcases le_or_lt b 1 with hb | hb\n  · rcases le_one_iff.1 hb with (rfl | rfl)\n    · exact log_zero_left o\n    · exact log_one_left o\n  · rwa [← Ordinal.le_zero, ← lt_succ_iff, succ_zero, ← lt_opow_iff_log_lt hb ho, opow_one]\n\n"}
{"name":"Ordinal.log_mono_right","module":"Mathlib.SetTheory.Ordinal.Exponential","initialProofState":"b x y : Ordinal.{u_1}\nxy : LE.le x y\n⊢ LE.le (Ordinal.log b x) (Ordinal.log b y)","decl":"@[mono]\ntheorem log_mono_right (b : Ordinal) {x y : Ordinal} (xy : x ≤ y) : log b x ≤ log b y := by\n  obtain rfl | hx := eq_or_ne x 0\n  · simp_rw [log_zero_right, Ordinal.zero_le]\n  · obtain hb | hb := lt_or_le 1 b\n    · exact (opow_le_iff_le_log hb (hx.bot_lt.trans_le xy).ne').1 <|\n        (opow_log_le_self _ hx).trans xy\n    · rw [log_of_left_le_one hb, log_of_left_le_one hb]\n\n"}
{"name":"Ordinal.log_le_self","module":"Mathlib.SetTheory.Ordinal.Exponential","initialProofState":"b x : Ordinal.{u_1}\n⊢ LE.le (Ordinal.log b x) x","decl":"theorem log_le_self (b x : Ordinal) : log b x ≤ x := by\n  obtain rfl | hx := eq_or_ne x 0\n  · rw [log_zero_right]\n  · obtain hb | hb := lt_or_le 1 b\n    · exact (right_le_opow _ hb).trans (opow_log_le_self b hx)\n    · simp_rw [log_of_left_le_one hb, Ordinal.zero_le]\n\n"}
{"name":"Ordinal.log_one_right","module":"Mathlib.SetTheory.Ordinal.Exponential","initialProofState":"b : Ordinal.{u_1}\n⊢ Eq (Ordinal.log b 1) 0","decl":"@[simp]\ntheorem log_one_right (b : Ordinal) : log b 1 = 0 := by\n  obtain hb | hb := lt_or_le 1 b\n  · exact log_eq_zero hb\n  · exact log_of_left_le_one hb 1\n\n"}
{"name":"Ordinal.mod_opow_log_lt_self","module":"Mathlib.SetTheory.Ordinal.Exponential","initialProofState":"b o : Ordinal.{u_1}\nho : Ne o 0\n⊢ LT.lt (HMod.hMod o (HPow.hPow b (Ordinal.log b o))) o","decl":"theorem mod_opow_log_lt_self (b : Ordinal) {o : Ordinal} (ho : o ≠ 0) : o % (b ^ log b o) < o := by\n  rcases eq_or_ne b 0 with (rfl | hb)\n  · simpa using Ordinal.pos_iff_ne_zero.2 ho\n  · exact (mod_lt _ <| opow_ne_zero _ hb).trans_le (opow_log_le_self _ ho)\n\n"}
{"name":"Ordinal.log_mod_opow_log_lt_log_self","module":"Mathlib.SetTheory.Ordinal.Exponential","initialProofState":"b o : Ordinal.{u_1}\nhb : LT.lt 1 b\nhbo : LE.le b o\n⊢ LT.lt (Ordinal.log b (HMod.hMod o (HPow.hPow b (Ordinal.log b o)))) (Ordinal.log b o)","decl":"theorem log_mod_opow_log_lt_log_self {b o : Ordinal} (hb : 1 < b) (hbo : b ≤ o) :\n    log b (o % (b ^ log b o)) < log b o := by\n  rcases eq_or_ne (o % (b ^ log b o)) 0 with h | h\n  · rw [h, log_zero_right]\n    exact log_pos hb (one_le_iff_ne_zero.1 (hb.le.trans hbo)) hbo\n  · rw [← succ_le_iff, succ_log_def hb h]\n    apply csInf_le'\n    apply mod_lt\n    rw [← Ordinal.pos_iff_ne_zero]\n    exact opow_pos _ (zero_lt_one.trans hb)\n\n"}
{"name":"Ordinal.log_eq_iff","module":"Mathlib.SetTheory.Ordinal.Exponential","initialProofState":"b x : Ordinal.{u_1}\nhb : LT.lt 1 b\nhx : Ne x 0\ny : Ordinal.{u_1}\n⊢ Iff (Eq (Ordinal.log b x) y) (And (LE.le (HPow.hPow b y) x) (LT.lt x (HPow.hPow b (Order.succ y))))","decl":"theorem log_eq_iff {b x : Ordinal} (hb : 1 < b) (hx : x ≠ 0) (y : Ordinal) :\n    log b x = y ↔ b ^ y ≤ x ∧ x < b ^ succ y := by\n  constructor\n  · rintro rfl\n    use opow_log_le_self b hx, lt_opow_succ_log_self hb x\n  · rintro ⟨hx₁, hx₂⟩\n    apply le_antisymm\n    · rwa [← lt_succ_iff, ← lt_opow_iff_log_lt hb hx]\n    · rwa [← opow_le_iff_le_log hb hx]\n\n"}
{"name":"Ordinal.log_opow_mul_add","module":"Mathlib.SetTheory.Ordinal.Exponential","initialProofState":"b u v w : Ordinal.{u_1}\nhb : LT.lt 1 b\nhv : Ne v 0\nhw : LT.lt w (HPow.hPow b u)\n⊢ Eq (Ordinal.log b (HAdd.hAdd (HMul.hMul (HPow.hPow b u) v) w)) (HAdd.hAdd u (Ordinal.log b v))","decl":"theorem log_opow_mul_add {b u v w : Ordinal} (hb : 1 < b) (hv : v ≠ 0) (hw : w < b ^ u) :\n    log b (b ^ u * v + w) = u + log b v := by\n  rw [log_eq_iff hb]\n  · constructor\n    · rw [opow_add]\n      exact (mul_le_mul_left' (opow_log_le_self b hv) _).trans (le_add_right _ w)\n    · apply (add_lt_add_left hw _).trans_le\n      rw [← mul_succ, ← add_succ, opow_add]\n      apply mul_le_mul_left'\n      rw [succ_le_iff]\n      exact lt_opow_succ_log_self hb _\n  · exact fun h ↦ mul_ne_zero (opow_ne_zero u (bot_lt_of_lt hb).ne') hv <|\n      left_eq_zero_of_add_eq_zero h\n\n"}
{"name":"Ordinal.log_opow_mul","module":"Mathlib.SetTheory.Ordinal.Exponential","initialProofState":"b v : Ordinal.{u_1}\nhb : LT.lt 1 b\nu : Ordinal.{u_1}\nhv : Ne v 0\n⊢ Eq (Ordinal.log b (HMul.hMul (HPow.hPow b u) v)) (HAdd.hAdd u (Ordinal.log b v))","decl":"theorem log_opow_mul {b v : Ordinal} (hb : 1 < b) (u : Ordinal) (hv : v ≠ 0) :\n    log b (b ^ u * v) = u + log b v := by\n  simpa using log_opow_mul_add hb hv (opow_pos u (bot_lt_of_lt hb))\n\n"}
{"name":"Ordinal.log_opow","module":"Mathlib.SetTheory.Ordinal.Exponential","initialProofState":"b : Ordinal.{u_1}\nhb : LT.lt 1 b\nx : Ordinal.{u_1}\n⊢ Eq (Ordinal.log b (HPow.hPow b x)) x","decl":"theorem log_opow {b : Ordinal} (hb : 1 < b) (x : Ordinal) : log b (b ^ x) = x := by\n  convert log_opow_mul hb x zero_ne_one.symm using 1\n  · rw [mul_one]\n  · rw [log_one_right, add_zero]\n\n"}
{"name":"Ordinal.div_opow_log_pos","module":"Mathlib.SetTheory.Ordinal.Exponential","initialProofState":"b o : Ordinal.{u_1}\nho : Ne o 0\n⊢ LT.lt 0 (HDiv.hDiv o (HPow.hPow b (Ordinal.log b o)))","decl":"theorem div_opow_log_pos (b : Ordinal) {o : Ordinal} (ho : o ≠ 0) : 0 < o / (b ^ log b o) := by\n  rcases eq_zero_or_pos b with (rfl | hb)\n  · simpa using Ordinal.pos_iff_ne_zero.2 ho\n  · rw [div_pos (opow_ne_zero _ hb.ne')]\n    exact opow_log_le_self b ho\n\n"}
{"name":"Ordinal.div_opow_log_lt","module":"Mathlib.SetTheory.Ordinal.Exponential","initialProofState":"b o : Ordinal.{u_1}\nhb : LT.lt 1 b\n⊢ LT.lt (HDiv.hDiv o (HPow.hPow b (Ordinal.log b o))) b","decl":"theorem div_opow_log_lt {b : Ordinal} (o : Ordinal) (hb : 1 < b) : o / (b ^ log b o) < b := by\n  rw [div_lt (opow_pos _ (zero_lt_one.trans hb)).ne', ← opow_succ]\n  exact lt_opow_succ_log_self hb o\n\n"}
{"name":"Ordinal.add_log_le_log_mul","module":"Mathlib.SetTheory.Ordinal.Exponential","initialProofState":"x y b : Ordinal.{u_1}\nhx : Ne x 0\nhy : Ne y 0\n⊢ LE.le (HAdd.hAdd (Ordinal.log b x) (Ordinal.log b y)) (Ordinal.log b (HMul.hMul x y))","decl":"theorem add_log_le_log_mul {x y : Ordinal} (b : Ordinal) (hx : x ≠ 0) (hy : y ≠ 0) :\n    log b x + log b y ≤ log b (x * y) := by\n  obtain hb | hb := lt_or_le 1 b\n  · rw [← opow_le_iff_le_log hb (mul_ne_zero hx hy), opow_add]\n    exact mul_le_mul' (opow_log_le_self b hx) (opow_log_le_self b hy)\n  · simpa only [log_of_left_le_one hb, zero_add] using le_rfl\n\n"}
{"name":"Ordinal.omega0_opow_mul_nat_lt","module":"Mathlib.SetTheory.Ordinal.Exponential","initialProofState":"a b : Ordinal.{u_1}\nh : LT.lt a b\nn : Nat\n⊢ LT.lt (HMul.hMul (HPow.hPow Ordinal.omega0 a) ↑n) (HPow.hPow Ordinal.omega0 b)","decl":"theorem omega0_opow_mul_nat_lt {a b : Ordinal} (h : a < b) (n : ℕ) : ω ^ a * n < ω ^ b := by\n  apply lt_of_lt_of_le _ (opow_le_opow_right omega0_pos (succ_le_of_lt h))\n  rw [opow_succ]\n  exact mul_lt_mul_of_pos_left (nat_lt_omega0 n) (opow_pos a omega0_pos)\n\n"}
{"name":"Ordinal.lt_omega0_opow","module":"Mathlib.SetTheory.Ordinal.Exponential","initialProofState":"a b : Ordinal.{u_1}\nhb : Ne b 0\n⊢ Iff (LT.lt a (HPow.hPow Ordinal.omega0 b)) (Exists fun c => And (LT.lt c b) (Exists fun n => LT.lt a (HMul.hMul (HPow.hPow Ordinal.omega0 c) ↑n)))","decl":"theorem lt_omega0_opow {a b : Ordinal} (hb : b ≠ 0) :\n    a < ω ^ b ↔ ∃ c < b, ∃ n : ℕ, a < ω ^ c * n := by\n  refine ⟨fun ha ↦ ⟨_, lt_log_of_lt_opow hb ha, ?_⟩,\n    fun ⟨c, hc, n, hn⟩ ↦ hn.trans (omega0_opow_mul_nat_lt hc n)⟩\n  obtain ⟨n, hn⟩ := lt_omega0.1 (div_opow_log_lt a one_lt_omega0)\n  use n.succ\n  rw [natCast_succ, ← hn]\n  exact lt_mul_succ_div a (opow_ne_zero _ omega0_ne_zero)\n\n"}
{"name":"Ordinal.lt_omega0_opow_succ","module":"Mathlib.SetTheory.Ordinal.Exponential","initialProofState":"a b : Ordinal.{u_1}\n⊢ Iff (LT.lt a (HPow.hPow Ordinal.omega0 (Order.succ b))) (Exists fun n => LT.lt a (HMul.hMul (HPow.hPow Ordinal.omega0 b) ↑n))","decl":"theorem lt_omega0_opow_succ {a b : Ordinal} : a < ω ^ succ b ↔ ∃ n : ℕ, a < ω ^ b * n := by\n  refine ⟨fun ha ↦ ?_, fun ⟨n, hn⟩ ↦ hn.trans (omega0_opow_mul_nat_lt (lt_succ b) n)⟩\n  obtain ⟨c, hc, n, hn⟩ := (lt_omega0_opow (succ_ne_zero b)).1 ha\n  refine ⟨n, hn.trans_le (mul_le_mul_right' ?_ _)⟩\n  rwa [opow_le_opow_iff_right one_lt_omega0, ← lt_succ_iff]\n\n"}
{"name":"Ordinal.natCast_opow","module":"Mathlib.SetTheory.Ordinal.Exponential","initialProofState":"m n : Nat\n⊢ Eq (↑(HPow.hPow m n)) (HPow.hPow ↑m ↑n)","decl":"@[simp, norm_cast]\ntheorem natCast_opow (m : ℕ) : ∀ n : ℕ, ↑(m ^ n : ℕ) = (m : Ordinal) ^ (n : Ordinal)\n  | 0 => by simp\n  | n + 1 => by\n    rw [pow_succ, natCast_mul, natCast_opow m n, Nat.cast_succ, add_one_eq_succ, opow_succ]\n\n"}
{"name":"Ordinal.iSup_pow","module":"Mathlib.SetTheory.Ordinal.Exponential","initialProofState":"o : Ordinal.{u_1}\nho : LT.lt 0 o\n⊢ Eq (iSup fun n => HPow.hPow o n) (HPow.hPow o Ordinal.omega0)","decl":"theorem iSup_pow {o : Ordinal} (ho : 0 < o) : ⨆ n : ℕ, o ^ n = o ^ ω := by\n  simp_rw [← opow_natCast]\n  rcases (one_le_iff_pos.2 ho).lt_or_eq with ho₁ | rfl\n  · exact (isNormal_opow ho₁).apply_omega0\n  · rw [one_opow]\n    refine le_antisymm (Ordinal.iSup_le fun n => by rw [one_opow]) ?_\n    exact_mod_cast Ordinal.le_iSup _ 0\n\n"}
{"name":"Ordinal.sup_opow_nat","module":"Mathlib.SetTheory.Ordinal.Exponential","initialProofState":"o : Ordinal.{u_1}\nho : LT.lt 0 o\n⊢ Eq (Ordinal.sup fun n => HPow.hPow o n) (HPow.hPow o Ordinal.omega0)","decl":"set_option linter.deprecated false in\n@[deprecated iSup_pow (since := \"2024-08-27\")]\ntheorem sup_opow_nat {o : Ordinal} (ho : 0 < o) : (sup fun n : ℕ => o ^ n) = o ^ ω := by\n  simp_rw [← opow_natCast]\n  rcases (one_le_iff_pos.2 ho).lt_or_eq with ho₁ | rfl\n  · exact (isNormal_opow ho₁).apply_omega0\n  · rw [one_opow]\n    refine le_antisymm (sup_le fun n => by rw [one_opow]) ?_\n    convert le_sup (fun n : ℕ => 1 ^ (n : Ordinal)) 0\n    rw [Nat.cast_zero, opow_zero]\n\n"}
