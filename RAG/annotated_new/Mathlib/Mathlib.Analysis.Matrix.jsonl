{"name":"Matrix.norm_def","module":"Mathlib.Analysis.Matrix","initialProofState":"m : Type u_3\nn : Type u_4\nα : Type u_5\ninst✝² : Fintype m\ninst✝¹ : Fintype n\ninst✝ : SeminormedAddCommGroup α\nA : Matrix m n α\n⊢ Eq (Norm.norm A) (Norm.norm fun i j => A i j)","decl":"theorem norm_def (A : Matrix m n α) : ‖A‖ = ‖fun i j => A i j‖ := rfl\n\n"}
{"name":"Matrix.norm_eq_sup_sup_nnnorm","module":"Mathlib.Analysis.Matrix","initialProofState":"m : Type u_3\nn : Type u_4\nα : Type u_5\ninst✝² : Fintype m\ninst✝¹ : Fintype n\ninst✝ : SeminormedAddCommGroup α\nA : Matrix m n α\n⊢ Eq (Norm.norm A) ↑(Finset.univ.sup fun i => Finset.univ.sup fun j => NNNorm.nnnorm (A i j))","decl":"/-- The norm of a matrix is the sup of the sup of the nnnorm of the entries -/\nlemma norm_eq_sup_sup_nnnorm (A : Matrix m n α) :\n    ‖A‖ = Finset.sup Finset.univ fun i ↦ Finset.sup Finset.univ fun j ↦ ‖A i j‖₊ := by\n  simp_rw [Matrix.norm_def, Pi.norm_def, Pi.nnnorm_def]\n\n"}
{"name":"Matrix.nnnorm_def","module":"Mathlib.Analysis.Matrix","initialProofState":"m : Type u_3\nn : Type u_4\nα : Type u_5\ninst✝² : Fintype m\ninst✝¹ : Fintype n\ninst✝ : SeminormedAddCommGroup α\nA : Matrix m n α\n⊢ Eq (NNNorm.nnnorm A) (NNNorm.nnnorm fun i j => A i j)","decl":"theorem nnnorm_def (A : Matrix m n α) : ‖A‖₊ = ‖fun i j => A i j‖₊ := rfl\n\n"}
{"name":"Matrix.norm_le_iff","module":"Mathlib.Analysis.Matrix","initialProofState":"m : Type u_3\nn : Type u_4\nα : Type u_5\ninst✝² : Fintype m\ninst✝¹ : Fintype n\ninst✝ : SeminormedAddCommGroup α\nr : Real\nhr : LE.le 0 r\nA : Matrix m n α\n⊢ Iff (LE.le (Norm.norm A) r) (∀ (i : m) (j : n), LE.le (Norm.norm (A i j)) r)","decl":"theorem norm_le_iff {r : ℝ} (hr : 0 ≤ r) {A : Matrix m n α} : ‖A‖ ≤ r ↔ ∀ i j, ‖A i j‖ ≤ r := by\n  simp_rw [norm_def, pi_norm_le_iff_of_nonneg hr]\n\n"}
{"name":"Matrix.nnnorm_le_iff","module":"Mathlib.Analysis.Matrix","initialProofState":"m : Type u_3\nn : Type u_4\nα : Type u_5\ninst✝² : Fintype m\ninst✝¹ : Fintype n\ninst✝ : SeminormedAddCommGroup α\nr : NNReal\nA : Matrix m n α\n⊢ Iff (LE.le (NNNorm.nnnorm A) r) (∀ (i : m) (j : n), LE.le (NNNorm.nnnorm (A i j)) r)","decl":"theorem nnnorm_le_iff {r : ℝ≥0} {A : Matrix m n α} : ‖A‖₊ ≤ r ↔ ∀ i j, ‖A i j‖₊ ≤ r := by\n  simp_rw [nnnorm_def, pi_nnnorm_le_iff]\n\n"}
{"name":"Matrix.norm_lt_iff","module":"Mathlib.Analysis.Matrix","initialProofState":"m : Type u_3\nn : Type u_4\nα : Type u_5\ninst✝² : Fintype m\ninst✝¹ : Fintype n\ninst✝ : SeminormedAddCommGroup α\nr : Real\nhr : LT.lt 0 r\nA : Matrix m n α\n⊢ Iff (LT.lt (Norm.norm A) r) (∀ (i : m) (j : n), LT.lt (Norm.norm (A i j)) r)","decl":"theorem norm_lt_iff {r : ℝ} (hr : 0 < r) {A : Matrix m n α} : ‖A‖ < r ↔ ∀ i j, ‖A i j‖ < r := by\n  simp_rw [norm_def, pi_norm_lt_iff hr]\n\n"}
{"name":"Matrix.nnnorm_lt_iff","module":"Mathlib.Analysis.Matrix","initialProofState":"m : Type u_3\nn : Type u_4\nα : Type u_5\ninst✝² : Fintype m\ninst✝¹ : Fintype n\ninst✝ : SeminormedAddCommGroup α\nr : NNReal\nhr : LT.lt 0 r\nA : Matrix m n α\n⊢ Iff (LT.lt (NNNorm.nnnorm A) r) (∀ (i : m) (j : n), LT.lt (NNNorm.nnnorm (A i j)) r)","decl":"theorem nnnorm_lt_iff {r : ℝ≥0} (hr : 0 < r) {A : Matrix m n α} :\n    ‖A‖₊ < r ↔ ∀ i j, ‖A i j‖₊ < r := by\n  simp_rw [nnnorm_def, pi_nnnorm_lt_iff hr]\n\n"}
{"name":"Matrix.norm_entry_le_entrywise_sup_norm","module":"Mathlib.Analysis.Matrix","initialProofState":"m : Type u_3\nn : Type u_4\nα : Type u_5\ninst✝² : Fintype m\ninst✝¹ : Fintype n\ninst✝ : SeminormedAddCommGroup α\nA : Matrix m n α\ni : m\nj : n\n⊢ LE.le (Norm.norm (A i j)) (Norm.norm A)","decl":"theorem norm_entry_le_entrywise_sup_norm (A : Matrix m n α) {i : m} {j : n} : ‖A i j‖ ≤ ‖A‖ :=\n  (norm_le_pi_norm (A i) j).trans (norm_le_pi_norm A i)\n\n"}
{"name":"Matrix.nnnorm_entry_le_entrywise_sup_nnnorm","module":"Mathlib.Analysis.Matrix","initialProofState":"m : Type u_3\nn : Type u_4\nα : Type u_5\ninst✝² : Fintype m\ninst✝¹ : Fintype n\ninst✝ : SeminormedAddCommGroup α\nA : Matrix m n α\ni : m\nj : n\n⊢ LE.le (NNNorm.nnnorm (A i j)) (NNNorm.nnnorm A)","decl":"theorem nnnorm_entry_le_entrywise_sup_nnnorm (A : Matrix m n α) {i : m} {j : n} : ‖A i j‖₊ ≤ ‖A‖₊ :=\n  (nnnorm_le_pi_nnnorm (A i) j).trans (nnnorm_le_pi_nnnorm A i)\n\n"}
{"name":"Matrix.nnnorm_map_eq","module":"Mathlib.Analysis.Matrix","initialProofState":"m : Type u_3\nn : Type u_4\nα : Type u_5\nβ : Type u_6\ninst✝³ : Fintype m\ninst✝² : Fintype n\ninst✝¹ : SeminormedAddCommGroup α\ninst✝ : SeminormedAddCommGroup β\nA : Matrix m n α\nf : α → β\nhf : ∀ (a : α), Eq (NNNorm.nnnorm (f a)) (NNNorm.nnnorm a)\n⊢ Eq (NNNorm.nnnorm (A.map f)) (NNNorm.nnnorm A)","decl":"@[simp]\ntheorem nnnorm_map_eq (A : Matrix m n α) (f : α → β) (hf : ∀ a, ‖f a‖₊ = ‖a‖₊) :\n    ‖A.map f‖₊ = ‖A‖₊ := by\n  simp only [nnnorm_def, Pi.nnnorm_def, Matrix.map_apply, hf]\n\n"}
{"name":"Matrix.norm_map_eq","module":"Mathlib.Analysis.Matrix","initialProofState":"m : Type u_3\nn : Type u_4\nα : Type u_5\nβ : Type u_6\ninst✝³ : Fintype m\ninst✝² : Fintype n\ninst✝¹ : SeminormedAddCommGroup α\ninst✝ : SeminormedAddCommGroup β\nA : Matrix m n α\nf : α → β\nhf : ∀ (a : α), Eq (Norm.norm (f a)) (Norm.norm a)\n⊢ Eq (Norm.norm (A.map f)) (Norm.norm A)","decl":"@[simp]\ntheorem norm_map_eq (A : Matrix m n α) (f : α → β) (hf : ∀ a, ‖f a‖ = ‖a‖) : ‖A.map f‖ = ‖A‖ :=\n  (congr_arg ((↑) : ℝ≥0 → ℝ) <| nnnorm_map_eq A f fun a => Subtype.ext <| hf a :)\n\n"}
{"name":"Matrix.nnnorm_transpose","module":"Mathlib.Analysis.Matrix","initialProofState":"m : Type u_3\nn : Type u_4\nα : Type u_5\ninst✝² : Fintype m\ninst✝¹ : Fintype n\ninst✝ : SeminormedAddCommGroup α\nA : Matrix m n α\n⊢ Eq (NNNorm.nnnorm A.transpose) (NNNorm.nnnorm A)","decl":"@[simp]\ntheorem nnnorm_transpose (A : Matrix m n α) : ‖Aᵀ‖₊ = ‖A‖₊ :=\n  Finset.sup_comm _ _ _\n\n"}
{"name":"Matrix.norm_transpose","module":"Mathlib.Analysis.Matrix","initialProofState":"m : Type u_3\nn : Type u_4\nα : Type u_5\ninst✝² : Fintype m\ninst✝¹ : Fintype n\ninst✝ : SeminormedAddCommGroup α\nA : Matrix m n α\n⊢ Eq (Norm.norm A.transpose) (Norm.norm A)","decl":"@[simp]\ntheorem norm_transpose (A : Matrix m n α) : ‖Aᵀ‖ = ‖A‖ :=\n  congr_arg ((↑) : ℝ≥0 → ℝ) <| nnnorm_transpose A\n\n"}
{"name":"Matrix.nnnorm_conjTranspose","module":"Mathlib.Analysis.Matrix","initialProofState":"m : Type u_3\nn : Type u_4\nα : Type u_5\ninst✝⁴ : Fintype m\ninst✝³ : Fintype n\ninst✝² : SeminormedAddCommGroup α\ninst✝¹ : StarAddMonoid α\ninst✝ : NormedStarGroup α\nA : Matrix m n α\n⊢ Eq (NNNorm.nnnorm A.conjTranspose) (NNNorm.nnnorm A)","decl":"@[simp]\ntheorem nnnorm_conjTranspose [StarAddMonoid α] [NormedStarGroup α] (A : Matrix m n α) :\n    ‖Aᴴ‖₊ = ‖A‖₊ :=\n  (nnnorm_map_eq _ _ nnnorm_star).trans A.nnnorm_transpose\n\n"}
{"name":"Matrix.norm_conjTranspose","module":"Mathlib.Analysis.Matrix","initialProofState":"m : Type u_3\nn : Type u_4\nα : Type u_5\ninst✝⁴ : Fintype m\ninst✝³ : Fintype n\ninst✝² : SeminormedAddCommGroup α\ninst✝¹ : StarAddMonoid α\ninst✝ : NormedStarGroup α\nA : Matrix m n α\n⊢ Eq (Norm.norm A.conjTranspose) (Norm.norm A)","decl":"@[simp]\ntheorem norm_conjTranspose [StarAddMonoid α] [NormedStarGroup α] (A : Matrix m n α) : ‖Aᴴ‖ = ‖A‖ :=\n  congr_arg ((↑) : ℝ≥0 → ℝ) <| nnnorm_conjTranspose A\n\n"}
{"name":"Matrix.instNormedStarGroup","module":"Mathlib.Analysis.Matrix","initialProofState":"m : Type u_3\nα : Type u_5\ninst✝³ : Fintype m\ninst✝² : SeminormedAddCommGroup α\ninst✝¹ : StarAddMonoid α\ninst✝ : NormedStarGroup α\n⊢ NormedStarGroup (Matrix m m α)","decl":"instance [StarAddMonoid α] [NormedStarGroup α] : NormedStarGroup (Matrix m m α) :=\n  ⟨norm_conjTranspose⟩\n\n"}
{"name":"Matrix.nnnorm_col","module":"Mathlib.Analysis.Matrix","initialProofState":"m : Type u_3\nα : Type u_5\nι : Type u_7\ninst✝² : Fintype m\ninst✝¹ : Unique ι\ninst✝ : SeminormedAddCommGroup α\nv : m → α\n⊢ Eq (NNNorm.nnnorm (Matrix.col ι v)) (NNNorm.nnnorm v)","decl":"@[simp]\ntheorem nnnorm_col (v : m → α) : ‖col ι v‖₊ = ‖v‖₊ := by\n  simp [nnnorm_def, Pi.nnnorm_def]\n\n"}
{"name":"Matrix.norm_col","module":"Mathlib.Analysis.Matrix","initialProofState":"m : Type u_3\nα : Type u_5\nι : Type u_7\ninst✝² : Fintype m\ninst✝¹ : Unique ι\ninst✝ : SeminormedAddCommGroup α\nv : m → α\n⊢ Eq (Norm.norm (Matrix.col ι v)) (Norm.norm v)","decl":"@[simp]\ntheorem norm_col (v : m → α) : ‖col ι v‖ = ‖v‖ :=\n  congr_arg ((↑) : ℝ≥0 → ℝ) <| nnnorm_col v\n\n"}
{"name":"Matrix.nnnorm_row","module":"Mathlib.Analysis.Matrix","initialProofState":"n : Type u_4\nα : Type u_5\nι : Type u_7\ninst✝² : Fintype n\ninst✝¹ : Unique ι\ninst✝ : SeminormedAddCommGroup α\nv : n → α\n⊢ Eq (NNNorm.nnnorm (Matrix.row ι v)) (NNNorm.nnnorm v)","decl":"@[simp]\ntheorem nnnorm_row (v : n → α) : ‖row ι v‖₊ = ‖v‖₊ := by\n  simp [nnnorm_def, Pi.nnnorm_def]\n\n"}
{"name":"Matrix.norm_row","module":"Mathlib.Analysis.Matrix","initialProofState":"n : Type u_4\nα : Type u_5\nι : Type u_7\ninst✝² : Fintype n\ninst✝¹ : Unique ι\ninst✝ : SeminormedAddCommGroup α\nv : n → α\n⊢ Eq (Norm.norm (Matrix.row ι v)) (Norm.norm v)","decl":"@[simp]\ntheorem norm_row (v : n → α) : ‖row ι v‖ = ‖v‖ :=\n  congr_arg ((↑) : ℝ≥0 → ℝ) <| nnnorm_row v\n\n"}
{"name":"Matrix.nnnorm_diagonal","module":"Mathlib.Analysis.Matrix","initialProofState":"n : Type u_4\nα : Type u_5\ninst✝² : Fintype n\ninst✝¹ : SeminormedAddCommGroup α\ninst✝ : DecidableEq n\nv : n → α\n⊢ Eq (NNNorm.nnnorm (Matrix.diagonal v)) (NNNorm.nnnorm v)","decl":"@[simp]\ntheorem nnnorm_diagonal [DecidableEq n] (v : n → α) : ‖diagonal v‖₊ = ‖v‖₊ := by\n  simp_rw [nnnorm_def, Pi.nnnorm_def]\n  congr 1 with i : 1\n  refine le_antisymm (Finset.sup_le fun j hj => ?_) ?_\n  · obtain rfl | hij := eq_or_ne i j\n    · rw [diagonal_apply_eq]\n    · rw [diagonal_apply_ne _ hij, nnnorm_zero]\n      exact zero_le _\n  · refine Eq.trans_le ?_ (Finset.le_sup (Finset.mem_univ i))\n    rw [diagonal_apply_eq]\n\n"}
{"name":"Matrix.norm_diagonal","module":"Mathlib.Analysis.Matrix","initialProofState":"n : Type u_4\nα : Type u_5\ninst✝² : Fintype n\ninst✝¹ : SeminormedAddCommGroup α\ninst✝ : DecidableEq n\nv : n → α\n⊢ Eq (Norm.norm (Matrix.diagonal v)) (Norm.norm v)","decl":"@[simp]\ntheorem norm_diagonal [DecidableEq n] (v : n → α) : ‖diagonal v‖ = ‖v‖ :=\n  congr_arg ((↑) : ℝ≥0 → ℝ) <| nnnorm_diagonal v\n\n"}
{"name":"Matrix.instNormOneClassOfNonempty","module":"Mathlib.Analysis.Matrix","initialProofState":"n : Type u_4\nα : Type u_5\ninst✝⁵ : Fintype n\ninst✝⁴ : SeminormedAddCommGroup α\ninst✝³ : Nonempty n\ninst✝² : DecidableEq n\ninst✝¹ : One α\ninst✝ : NormOneClass α\n⊢ NormOneClass (Matrix n n α)","decl":"/-- Note this is safe as an instance as it carries no data. -/\n-- Porting note: not yet implemented: `@[nolint fails_quickly]`\ninstance [Nonempty n] [DecidableEq n] [One α] [NormOneClass α] : NormOneClass (Matrix n n α) :=\n  ⟨(norm_diagonal _).trans <| norm_one⟩\n\n"}
{"name":"Matrix.boundedSMul","module":"Mathlib.Analysis.Matrix","initialProofState":"R : Type u_1\nm : Type u_3\nn : Type u_4\nα : Type u_5\ninst✝⁵ : Fintype m\ninst✝⁴ : Fintype n\ninst✝³ : SeminormedRing R\ninst✝² : SeminormedAddCommGroup α\ninst✝¹ : Module R α\ninst✝ : BoundedSMul R α\n⊢ BoundedSMul R (Matrix m n α)","decl":"/-- This applies to the sup norm of sup norm. -/\nprotected theorem boundedSMul [SeminormedRing R] [SeminormedAddCommGroup α] [Module R α]\n    [BoundedSMul R α] : BoundedSMul R (Matrix m n α) :=\n  Pi.instBoundedSMul\n\n"}
{"name":"Matrix.linftyOpBoundedSMul","module":"Mathlib.Analysis.Matrix","initialProofState":"R : Type u_1\nm : Type u_3\nn : Type u_4\nα : Type u_5\ninst✝⁵ : Fintype m\ninst✝⁴ : Fintype n\ninst✝³ : SeminormedRing R\ninst✝² : SeminormedAddCommGroup α\ninst✝¹ : Module R α\ninst✝ : BoundedSMul R α\n⊢ BoundedSMul R (Matrix m n α)","decl":"/-- This applies to the sup norm of L1 norm. -/\n@[local instance]\nprotected theorem linftyOpBoundedSMul\n    [SeminormedRing R] [SeminormedAddCommGroup α] [Module R α] [BoundedSMul R α] :\n    BoundedSMul R (Matrix m n α) :=\n  (by infer_instance : BoundedSMul R (m → PiLp 1 fun j : n => α))\n\n"}
{"name":"Matrix.linfty_opNorm_def","module":"Mathlib.Analysis.Matrix","initialProofState":"m : Type u_3\nn : Type u_4\nα : Type u_5\ninst✝² : Fintype m\ninst✝¹ : Fintype n\ninst✝ : SeminormedAddCommGroup α\nA : Matrix m n α\n⊢ Eq (Norm.norm A) ↑(Finset.univ.sup fun i => Finset.univ.sum fun j => NNNorm.nnnorm (A i j))","decl":"theorem linfty_opNorm_def (A : Matrix m n α) :\n    ‖A‖ = ((Finset.univ : Finset m).sup fun i : m => ∑ j : n, ‖A i j‖₊ : ℝ≥0) := by\n  -- Porting note: added\n  change ‖fun i => (WithLp.equiv 1 _).symm (A i)‖ = _\n  simp [Pi.norm_def, PiLp.nnnorm_eq_of_L1]\n\n"}
{"name":"Matrix.linfty_opNNNorm_def","module":"Mathlib.Analysis.Matrix","initialProofState":"m : Type u_3\nn : Type u_4\nα : Type u_5\ninst✝² : Fintype m\ninst✝¹ : Fintype n\ninst✝ : SeminormedAddCommGroup α\nA : Matrix m n α\n⊢ Eq (NNNorm.nnnorm A) (Finset.univ.sup fun i => Finset.univ.sum fun j => NNNorm.nnnorm (A i j))","decl":"theorem linfty_opNNNorm_def (A : Matrix m n α) :\n    ‖A‖₊ = (Finset.univ : Finset m).sup fun i : m => ∑ j : n, ‖A i j‖₊ :=\n  Subtype.ext <| linfty_opNorm_def A\n\n"}
{"name":"Matrix.linfty_opNNNorm_col","module":"Mathlib.Analysis.Matrix","initialProofState":"m : Type u_3\nα : Type u_5\nι : Type u_7\ninst✝² : Fintype m\ninst✝¹ : Unique ι\ninst✝ : SeminormedAddCommGroup α\nv : m → α\n⊢ Eq (NNNorm.nnnorm (Matrix.col ι v)) (NNNorm.nnnorm v)","decl":"@[simp]\ntheorem linfty_opNNNorm_col (v : m → α) : ‖col ι v‖₊ = ‖v‖₊ := by\n  rw [linfty_opNNNorm_def, Pi.nnnorm_def]\n  simp\n\n"}
{"name":"Matrix.linfty_opNorm_col","module":"Mathlib.Analysis.Matrix","initialProofState":"m : Type u_3\nα : Type u_5\nι : Type u_7\ninst✝² : Fintype m\ninst✝¹ : Unique ι\ninst✝ : SeminormedAddCommGroup α\nv : m → α\n⊢ Eq (Norm.norm (Matrix.col ι v)) (Norm.norm v)","decl":"@[simp]\ntheorem linfty_opNorm_col (v : m → α) : ‖col ι v‖ = ‖v‖ :=\n  congr_arg ((↑) : ℝ≥0 → ℝ) <| linfty_opNNNorm_col v\n\n"}
{"name":"Matrix.linfty_opNNNorm_row","module":"Mathlib.Analysis.Matrix","initialProofState":"n : Type u_4\nα : Type u_5\nι : Type u_7\ninst✝² : Fintype n\ninst✝¹ : Unique ι\ninst✝ : SeminormedAddCommGroup α\nv : n → α\n⊢ Eq (NNNorm.nnnorm (Matrix.row ι v)) (Finset.univ.sum fun i => NNNorm.nnnorm (v i))","decl":"@[simp]\ntheorem linfty_opNNNorm_row (v : n → α) : ‖row ι v‖₊ = ∑ i, ‖v i‖₊ := by\n  simp [linfty_opNNNorm_def]\n\n"}
{"name":"Matrix.linfty_opNorm_row","module":"Mathlib.Analysis.Matrix","initialProofState":"n : Type u_4\nα : Type u_5\nι : Type u_7\ninst✝² : Fintype n\ninst✝¹ : Unique ι\ninst✝ : SeminormedAddCommGroup α\nv : n → α\n⊢ Eq (Norm.norm (Matrix.row ι v)) (Finset.univ.sum fun i => Norm.norm (v i))","decl":"@[simp]\ntheorem linfty_opNorm_row (v : n → α) : ‖row ι v‖ = ∑ i, ‖v i‖ :=\n  (congr_arg ((↑) : ℝ≥0 → ℝ) <| linfty_opNNNorm_row v).trans <| by simp [NNReal.coe_sum]\n\n"}
{"name":"Matrix.linfty_opNNNorm_diagonal","module":"Mathlib.Analysis.Matrix","initialProofState":"m : Type u_3\nα : Type u_5\ninst✝² : Fintype m\ninst✝¹ : SeminormedAddCommGroup α\ninst✝ : DecidableEq m\nv : m → α\n⊢ Eq (NNNorm.nnnorm (Matrix.diagonal v)) (NNNorm.nnnorm v)","decl":"@[simp]\ntheorem linfty_opNNNorm_diagonal [DecidableEq m] (v : m → α) : ‖diagonal v‖₊ = ‖v‖₊ := by\n  rw [linfty_opNNNorm_def, Pi.nnnorm_def]\n  congr 1 with i : 1\n  refine (Finset.sum_eq_single_of_mem _ (Finset.mem_univ i) fun j _hj hij => ?_).trans ?_\n  · rw [diagonal_apply_ne' _ hij, nnnorm_zero]\n  · rw [diagonal_apply_eq]\n\n"}
{"name":"Matrix.linfty_opNorm_diagonal","module":"Mathlib.Analysis.Matrix","initialProofState":"m : Type u_3\nα : Type u_5\ninst✝² : Fintype m\ninst✝¹ : SeminormedAddCommGroup α\ninst✝ : DecidableEq m\nv : m → α\n⊢ Eq (Norm.norm (Matrix.diagonal v)) (Norm.norm v)","decl":"@[simp]\ntheorem linfty_opNorm_diagonal [DecidableEq m] (v : m → α) : ‖diagonal v‖ = ‖v‖ :=\n  congr_arg ((↑) : ℝ≥0 → ℝ) <| linfty_opNNNorm_diagonal v\n\n"}
{"name":"Matrix.linfty_opNNNorm_mul","module":"Mathlib.Analysis.Matrix","initialProofState":"l : Type u_2\nm : Type u_3\nn : Type u_4\nα : Type u_5\ninst✝³ : Fintype l\ninst✝² : Fintype m\ninst✝¹ : Fintype n\ninst✝ : NonUnitalSeminormedRing α\nA : Matrix l m α\nB : Matrix m n α\n⊢ LE.le (NNNorm.nnnorm (HMul.hMul A B)) (HMul.hMul (NNNorm.nnnorm A) (NNNorm.nnnorm B))","decl":"theorem linfty_opNNNorm_mul (A : Matrix l m α) (B : Matrix m n α) : ‖A * B‖₊ ≤ ‖A‖₊ * ‖B‖₊ := by\n  simp_rw [linfty_opNNNorm_def, Matrix.mul_apply]\n  calc\n    (Finset.univ.sup fun i => ∑ k, ‖∑ j, A i j * B j k‖₊) ≤\n        Finset.univ.sup fun i => ∑ k, ∑ j, ‖A i j‖₊ * ‖B j k‖₊ :=\n      Finset.sup_mono_fun fun i _hi =>\n        Finset.sum_le_sum fun k _hk => nnnorm_sum_le_of_le _ fun j _hj => nnnorm_mul_le _ _\n    _ = Finset.univ.sup fun i => ∑ j, ‖A i j‖₊ * ∑ k, ‖B j k‖₊ := by\n      simp_rw [@Finset.sum_comm m, Finset.mul_sum]\n    _ ≤ Finset.univ.sup fun i => ∑ j, ‖A i j‖₊ * Finset.univ.sup fun i => ∑ j, ‖B i j‖₊ := by\n      refine Finset.sup_mono_fun fun i _hi => ?_\n      gcongr with j hj\n      exact Finset.le_sup (f := fun i ↦ ∑ k : n, ‖B i k‖₊) hj\n    _ ≤ (Finset.univ.sup fun i => ∑ j, ‖A i j‖₊) * Finset.univ.sup fun i => ∑ j, ‖B i j‖₊ := by\n      simp_rw [← Finset.sum_mul, ← NNReal.finset_sup_mul]\n      rfl\n\n"}
{"name":"Matrix.linfty_opNorm_mul","module":"Mathlib.Analysis.Matrix","initialProofState":"l : Type u_2\nm : Type u_3\nn : Type u_4\nα : Type u_5\ninst✝³ : Fintype l\ninst✝² : Fintype m\ninst✝¹ : Fintype n\ninst✝ : NonUnitalSeminormedRing α\nA : Matrix l m α\nB : Matrix m n α\n⊢ LE.le (Norm.norm (HMul.hMul A B)) (HMul.hMul (Norm.norm A) (Norm.norm B))","decl":"theorem linfty_opNorm_mul (A : Matrix l m α) (B : Matrix m n α) : ‖A * B‖ ≤ ‖A‖ * ‖B‖ :=\n  linfty_opNNNorm_mul _ _\n\n"}
{"name":"Matrix.linfty_opNNNorm_mulVec","module":"Mathlib.Analysis.Matrix","initialProofState":"l : Type u_2\nm : Type u_3\nα : Type u_5\ninst✝² : Fintype l\ninst✝¹ : Fintype m\ninst✝ : NonUnitalSeminormedRing α\nA : Matrix l m α\nv : m → α\n⊢ LE.le (NNNorm.nnnorm (A.mulVec v)) (HMul.hMul (NNNorm.nnnorm A) (NNNorm.nnnorm v))","decl":"theorem linfty_opNNNorm_mulVec (A : Matrix l m α) (v : m → α) : ‖A *ᵥ v‖₊ ≤ ‖A‖₊ * ‖v‖₊ := by\n  rw [← linfty_opNNNorm_col (ι := Fin 1) (A *ᵥ v), ← linfty_opNNNorm_col v (ι := Fin 1)]\n  exact linfty_opNNNorm_mul A (col (Fin 1) v)\n\n"}
{"name":"Matrix.linfty_opNorm_mulVec","module":"Mathlib.Analysis.Matrix","initialProofState":"l : Type u_2\nm : Type u_3\nα : Type u_5\ninst✝² : Fintype l\ninst✝¹ : Fintype m\ninst✝ : NonUnitalSeminormedRing α\nA : Matrix l m α\nv : m → α\n⊢ LE.le (Norm.norm (A.mulVec v)) (HMul.hMul (Norm.norm A) (Norm.norm v))","decl":"theorem linfty_opNorm_mulVec (A : Matrix l m α) (v : m → α) : ‖A *ᵥ v‖ ≤ ‖A‖ * ‖v‖ :=\n  linfty_opNNNorm_mulVec _ _\n\n"}
{"name":"Matrix.linfty_opNormOneClass","module":"Mathlib.Analysis.Matrix","initialProofState":"n : Type u_4\nα : Type u_5\ninst✝⁴ : Fintype n\ninst✝³ : SeminormedRing α\ninst✝² : NormOneClass α\ninst✝¹ : DecidableEq n\ninst✝ : Nonempty n\n⊢ NormOneClass (Matrix n n α)","decl":"/-- The `L₁-L∞` norm preserves one on non-empty matrices. Note this is safe as an instance, as it\ncarries no data. -/\ninstance linfty_opNormOneClass [SeminormedRing α] [NormOneClass α] [DecidableEq n] [Nonempty n] :\n    NormOneClass (Matrix n n α) where norm_one := (linfty_opNorm_diagonal _).trans norm_one\n\n"}
{"name":"Matrix.linfty_opNNNorm_eq_opNNNorm","module":"Mathlib.Analysis.Matrix","initialProofState":"m : Type u_3\nn : Type u_4\nα : Type u_5\ninst✝³ : Fintype m\ninst✝² : Fintype n\ninst✝¹ : NontriviallyNormedField α\ninst✝ : NormedAlgebra Real α\nA : Matrix m n α\n⊢ Eq (NNNorm.nnnorm A) (NNNorm.nnnorm { toLinearMap := A.mulVecLin, cont := ⋯ })","decl":"lemma linfty_opNNNorm_eq_opNNNorm (A : Matrix m n α) :\n    ‖A‖₊ = ‖ContinuousLinearMap.mk (Matrix.mulVecLin A)‖₊ := by\n  rw [ContinuousLinearMap.opNNNorm_eq_of_bounds _ (linfty_opNNNorm_mulVec _) fun N hN => ?_]\n  rw [linfty_opNNNorm_def]\n  refine Finset.sup_le fun i _ => ?_\n  cases isEmpty_or_nonempty n\n  · simp\n  classical\n  let x : n → α := fun j => unitOf (A i j)\n  have hxn : ‖x‖₊ = 1 := by\n    simp_rw [x, Pi.nnnorm_def, norm_unitOf, Finset.sup_const Finset.univ_nonempty]\n  specialize hN x\n  rw [hxn, mul_one, Pi.nnnorm_def, Finset.sup_le_iff] at hN\n  replace hN := hN i (Finset.mem_univ _)\n  dsimp [mulVec, dotProduct] at hN\n  simp_rw [x, mul_unitOf, ← map_sum, nnnorm_algebraMap, ← NNReal.coe_sum, NNReal.nnnorm_eq,\n    nnnorm_one, mul_one] at hN\n  exact hN\n\n"}
{"name":"Matrix.linfty_opNorm_eq_opNorm","module":"Mathlib.Analysis.Matrix","initialProofState":"m : Type u_3\nn : Type u_4\nα : Type u_5\ninst✝³ : Fintype m\ninst✝² : Fintype n\ninst✝¹ : NontriviallyNormedField α\ninst✝ : NormedAlgebra Real α\nA : Matrix m n α\n⊢ Eq (Norm.norm A) (Norm.norm { toLinearMap := A.mulVecLin, cont := ⋯ })","decl":"lemma linfty_opNorm_eq_opNorm (A : Matrix m n α) :\n    ‖A‖ = ‖ContinuousLinearMap.mk (Matrix.mulVecLin A)‖ :=\n  congr_arg NNReal.toReal (linfty_opNNNorm_eq_opNNNorm A)\n\n"}
{"name":"Matrix.linfty_opNNNorm_toMatrix","module":"Mathlib.Analysis.Matrix","initialProofState":"m : Type u_3\nn : Type u_4\nα : Type u_5\ninst✝⁴ : Fintype m\ninst✝³ : Fintype n\ninst✝² : NontriviallyNormedField α\ninst✝¹ : NormedAlgebra Real α\ninst✝ : DecidableEq n\nf : ContinuousLinearMap (RingHom.id α) (n → α) (m → α)\n⊢ Eq (NNNorm.nnnorm (LinearMap.toMatrix' ↑f)) (NNNorm.nnnorm f)","decl":"@[simp] lemma linfty_opNNNorm_toMatrix (f : (n → α) →L[α] (m → α)) :\n    ‖LinearMap.toMatrix' (↑f : (n → α) →ₗ[α] (m → α))‖₊ = ‖f‖₊ := by\n  rw [linfty_opNNNorm_eq_opNNNorm]\n  simp only [← toLin'_apply', toLin'_toMatrix']\n\n"}
{"name":"Matrix.linfty_opNorm_toMatrix","module":"Mathlib.Analysis.Matrix","initialProofState":"m : Type u_3\nn : Type u_4\nα : Type u_5\ninst✝⁴ : Fintype m\ninst✝³ : Fintype n\ninst✝² : NontriviallyNormedField α\ninst✝¹ : NormedAlgebra Real α\ninst✝ : DecidableEq n\nf : ContinuousLinearMap (RingHom.id α) (n → α) (m → α)\n⊢ Eq (Norm.norm (LinearMap.toMatrix' ↑f)) (Norm.norm f)","decl":"@[simp] lemma linfty_opNorm_toMatrix (f : (n → α) →L[α] (m → α)) :\n    ‖LinearMap.toMatrix' (↑f : (n → α) →ₗ[α] (m → α))‖ = ‖f‖ :=\n  congr_arg NNReal.toReal (linfty_opNNNorm_toMatrix f)\n\n"}
{"name":"Matrix.frobeniusBoundedSMul","module":"Mathlib.Analysis.Matrix","initialProofState":"R : Type u_1\nm : Type u_3\nn : Type u_4\nα : Type u_5\ninst✝⁵ : Fintype m\ninst✝⁴ : Fintype n\ninst✝³ : SeminormedRing R\ninst✝² : SeminormedAddCommGroup α\ninst✝¹ : Module R α\ninst✝ : BoundedSMul R α\n⊢ BoundedSMul R (Matrix m n α)","decl":"/-- This applies to the frobenius norm. -/\n@[local instance]\ntheorem frobeniusBoundedSMul [SeminormedRing R] [SeminormedAddCommGroup α] [Module R α]\n    [BoundedSMul R α] :\n    BoundedSMul R (Matrix m n α) :=\n  (by infer_instance : BoundedSMul R (PiLp 2 fun i : m => PiLp 2 fun j : n => α))\n\n"}
{"name":"Matrix.frobenius_nnnorm_def","module":"Mathlib.Analysis.Matrix","initialProofState":"m : Type u_3\nn : Type u_4\nα : Type u_5\ninst✝² : Fintype m\ninst✝¹ : Fintype n\ninst✝ : SeminormedAddCommGroup α\nA : Matrix m n α\n⊢ Eq (NNNorm.nnnorm A) (HPow.hPow (Finset.univ.sum fun i => Finset.univ.sum fun j => HPow.hPow (NNNorm.nnnorm (A i j)) 2) (1 / 2))","decl":"theorem frobenius_nnnorm_def (A : Matrix m n α) :\n    ‖A‖₊ = (∑ i, ∑ j, ‖A i j‖₊ ^ (2 : ℝ)) ^ (1 / 2 : ℝ) := by\n  -- Porting note: added, along with `WithLp.equiv_symm_pi_apply` below\n  change ‖(WithLp.equiv 2 _).symm fun i => (WithLp.equiv 2 _).symm fun j => A i j‖₊ = _\n  simp_rw [PiLp.nnnorm_eq_of_L2, NNReal.sq_sqrt, NNReal.sqrt_eq_rpow, NNReal.rpow_two,\n    WithLp.equiv_symm_pi_apply]\n\n"}
{"name":"Matrix.frobenius_norm_def","module":"Mathlib.Analysis.Matrix","initialProofState":"m : Type u_3\nn : Type u_4\nα : Type u_5\ninst✝² : Fintype m\ninst✝¹ : Fintype n\ninst✝ : SeminormedAddCommGroup α\nA : Matrix m n α\n⊢ Eq (Norm.norm A) (HPow.hPow (Finset.univ.sum fun i => Finset.univ.sum fun j => HPow.hPow (Norm.norm (A i j)) 2) (1 / 2))","decl":"theorem frobenius_norm_def (A : Matrix m n α) :\n    ‖A‖ = (∑ i, ∑ j, ‖A i j‖ ^ (2 : ℝ)) ^ (1 / 2 : ℝ) :=\n  (congr_arg ((↑) : ℝ≥0 → ℝ) (frobenius_nnnorm_def A)).trans <| by simp [NNReal.coe_sum]\n\n"}
{"name":"Matrix.frobenius_nnnorm_map_eq","module":"Mathlib.Analysis.Matrix","initialProofState":"m : Type u_3\nn : Type u_4\nα : Type u_5\nβ : Type u_6\ninst✝³ : Fintype m\ninst✝² : Fintype n\ninst✝¹ : SeminormedAddCommGroup α\ninst✝ : SeminormedAddCommGroup β\nA : Matrix m n α\nf : α → β\nhf : ∀ (a : α), Eq (NNNorm.nnnorm (f a)) (NNNorm.nnnorm a)\n⊢ Eq (NNNorm.nnnorm (A.map f)) (NNNorm.nnnorm A)","decl":"@[simp]\ntheorem frobenius_nnnorm_map_eq (A : Matrix m n α) (f : α → β) (hf : ∀ a, ‖f a‖₊ = ‖a‖₊) :\n    ‖A.map f‖₊ = ‖A‖₊ := by simp_rw [frobenius_nnnorm_def, Matrix.map_apply, hf]\n\n"}
{"name":"Matrix.frobenius_norm_map_eq","module":"Mathlib.Analysis.Matrix","initialProofState":"m : Type u_3\nn : Type u_4\nα : Type u_5\nβ : Type u_6\ninst✝³ : Fintype m\ninst✝² : Fintype n\ninst✝¹ : SeminormedAddCommGroup α\ninst✝ : SeminormedAddCommGroup β\nA : Matrix m n α\nf : α → β\nhf : ∀ (a : α), Eq (Norm.norm (f a)) (Norm.norm a)\n⊢ Eq (Norm.norm (A.map f)) (Norm.norm A)","decl":"@[simp]\ntheorem frobenius_norm_map_eq (A : Matrix m n α) (f : α → β) (hf : ∀ a, ‖f a‖ = ‖a‖) :\n    ‖A.map f‖ = ‖A‖ :=\n  (congr_arg ((↑) : ℝ≥0 → ℝ) <| frobenius_nnnorm_map_eq A f fun a => Subtype.ext <| hf a :)\n\n"}
{"name":"Matrix.frobenius_nnnorm_transpose","module":"Mathlib.Analysis.Matrix","initialProofState":"m : Type u_3\nn : Type u_4\nα : Type u_5\ninst✝² : Fintype m\ninst✝¹ : Fintype n\ninst✝ : SeminormedAddCommGroup α\nA : Matrix m n α\n⊢ Eq (NNNorm.nnnorm A.transpose) (NNNorm.nnnorm A)","decl":"@[simp]\ntheorem frobenius_nnnorm_transpose (A : Matrix m n α) : ‖Aᵀ‖₊ = ‖A‖₊ := by\n  rw [frobenius_nnnorm_def, frobenius_nnnorm_def, Finset.sum_comm]\n  simp_rw [Matrix.transpose_apply]  -- Porting note: added\n\n"}
{"name":"Matrix.frobenius_norm_transpose","module":"Mathlib.Analysis.Matrix","initialProofState":"m : Type u_3\nn : Type u_4\nα : Type u_5\ninst✝² : Fintype m\ninst✝¹ : Fintype n\ninst✝ : SeminormedAddCommGroup α\nA : Matrix m n α\n⊢ Eq (Norm.norm A.transpose) (Norm.norm A)","decl":"@[simp]\ntheorem frobenius_norm_transpose (A : Matrix m n α) : ‖Aᵀ‖ = ‖A‖ :=\n  congr_arg ((↑) : ℝ≥0 → ℝ) <| frobenius_nnnorm_transpose A\n\n"}
{"name":"Matrix.frobenius_nnnorm_conjTranspose","module":"Mathlib.Analysis.Matrix","initialProofState":"m : Type u_3\nn : Type u_4\nα : Type u_5\ninst✝⁴ : Fintype m\ninst✝³ : Fintype n\ninst✝² : SeminormedAddCommGroup α\ninst✝¹ : StarAddMonoid α\ninst✝ : NormedStarGroup α\nA : Matrix m n α\n⊢ Eq (NNNorm.nnnorm A.conjTranspose) (NNNorm.nnnorm A)","decl":"@[simp]\ntheorem frobenius_nnnorm_conjTranspose [StarAddMonoid α] [NormedStarGroup α] (A : Matrix m n α) :\n    ‖Aᴴ‖₊ = ‖A‖₊ :=\n  (frobenius_nnnorm_map_eq _ _ nnnorm_star).trans A.frobenius_nnnorm_transpose\n\n"}
{"name":"Matrix.frobenius_norm_conjTranspose","module":"Mathlib.Analysis.Matrix","initialProofState":"m : Type u_3\nn : Type u_4\nα : Type u_5\ninst✝⁴ : Fintype m\ninst✝³ : Fintype n\ninst✝² : SeminormedAddCommGroup α\ninst✝¹ : StarAddMonoid α\ninst✝ : NormedStarGroup α\nA : Matrix m n α\n⊢ Eq (Norm.norm A.conjTranspose) (Norm.norm A)","decl":"@[simp]\ntheorem frobenius_norm_conjTranspose [StarAddMonoid α] [NormedStarGroup α] (A : Matrix m n α) :\n    ‖Aᴴ‖ = ‖A‖ :=\n  congr_arg ((↑) : ℝ≥0 → ℝ) <| frobenius_nnnorm_conjTranspose A\n\n"}
{"name":"Matrix.frobenius_normedStarGroup","module":"Mathlib.Analysis.Matrix","initialProofState":"m : Type u_3\nα : Type u_5\ninst✝³ : Fintype m\ninst✝² : SeminormedAddCommGroup α\ninst✝¹ : StarAddMonoid α\ninst✝ : NormedStarGroup α\n⊢ NormedStarGroup (Matrix m m α)","decl":"instance frobenius_normedStarGroup [StarAddMonoid α] [NormedStarGroup α] :\n    NormedStarGroup (Matrix m m α) :=\n  ⟨frobenius_norm_conjTranspose⟩\n\n"}
{"name":"Matrix.frobenius_norm_row","module":"Mathlib.Analysis.Matrix","initialProofState":"m : Type u_3\nα : Type u_5\nι : Type u_7\ninst✝² : Fintype m\ninst✝¹ : Unique ι\ninst✝ : SeminormedAddCommGroup α\nv : m → α\n⊢ Eq (Norm.norm (Matrix.row ι v)) (Norm.norm ((WithLp.equiv 2 (m → α)).symm v))","decl":"@[simp]\ntheorem frobenius_norm_row (v : m → α) : ‖row ι v‖ = ‖(WithLp.equiv 2 _).symm v‖ := by\n  rw [frobenius_norm_def, Fintype.sum_unique, PiLp.norm_eq_of_L2, Real.sqrt_eq_rpow]\n  simp only [row_apply, Real.rpow_two, WithLp.equiv_symm_pi_apply]\n\n"}
{"name":"Matrix.frobenius_nnnorm_row","module":"Mathlib.Analysis.Matrix","initialProofState":"m : Type u_3\nα : Type u_5\nι : Type u_7\ninst✝² : Fintype m\ninst✝¹ : Unique ι\ninst✝ : SeminormedAddCommGroup α\nv : m → α\n⊢ Eq (NNNorm.nnnorm (Matrix.row ι v)) (NNNorm.nnnorm ((WithLp.equiv 2 (m → α)).symm v))","decl":"@[simp]\ntheorem frobenius_nnnorm_row (v : m → α) : ‖row ι v‖₊ = ‖(WithLp.equiv 2 _).symm v‖₊ :=\n  Subtype.ext <| frobenius_norm_row v\n\n"}
{"name":"Matrix.frobenius_norm_col","module":"Mathlib.Analysis.Matrix","initialProofState":"n : Type u_4\nα : Type u_5\nι : Type u_7\ninst✝² : Fintype n\ninst✝¹ : Unique ι\ninst✝ : SeminormedAddCommGroup α\nv : n → α\n⊢ Eq (Norm.norm (Matrix.col ι v)) (Norm.norm ((WithLp.equiv 2 (n → α)).symm v))","decl":"@[simp]\ntheorem frobenius_norm_col (v : n → α) : ‖col ι v‖ = ‖(WithLp.equiv 2 _).symm v‖ := by\n  simp_rw [frobenius_norm_def, Fintype.sum_unique, PiLp.norm_eq_of_L2, Real.sqrt_eq_rpow]\n  simp only [col_apply, Real.rpow_two, WithLp.equiv_symm_pi_apply]\n\n"}
{"name":"Matrix.frobenius_nnnorm_col","module":"Mathlib.Analysis.Matrix","initialProofState":"n : Type u_4\nα : Type u_5\nι : Type u_7\ninst✝² : Fintype n\ninst✝¹ : Unique ι\ninst✝ : SeminormedAddCommGroup α\nv : n → α\n⊢ Eq (NNNorm.nnnorm (Matrix.col ι v)) (NNNorm.nnnorm ((WithLp.equiv 2 (n → α)).symm v))","decl":"@[simp]\ntheorem frobenius_nnnorm_col (v : n → α) : ‖col ι v‖₊ = ‖(WithLp.equiv 2 _).symm v‖₊ :=\n  Subtype.ext <| frobenius_norm_col v\n\n"}
{"name":"Matrix.frobenius_nnnorm_diagonal","module":"Mathlib.Analysis.Matrix","initialProofState":"n : Type u_4\nα : Type u_5\ninst✝² : Fintype n\ninst✝¹ : SeminormedAddCommGroup α\ninst✝ : DecidableEq n\nv : n → α\n⊢ Eq (NNNorm.nnnorm (Matrix.diagonal v)) (NNNorm.nnnorm ((WithLp.equiv 2 (n → α)).symm v))","decl":"@[simp]\ntheorem frobenius_nnnorm_diagonal [DecidableEq n] (v : n → α) :\n    ‖diagonal v‖₊ = ‖(WithLp.equiv 2 _).symm v‖₊ := by\n  simp_rw [frobenius_nnnorm_def, ← Finset.sum_product', Finset.univ_product_univ,\n    PiLp.nnnorm_eq_of_L2]\n  let s := (Finset.univ : Finset n).map ⟨fun i : n => (i, i), fun i j h => congr_arg Prod.fst h⟩\n  rw [← Finset.sum_subset (Finset.subset_univ s) fun i _hi his => ?_]\n  · rw [Finset.sum_map, NNReal.sqrt_eq_rpow]\n    dsimp\n    simp_rw [diagonal_apply_eq, NNReal.rpow_two]\n  · suffices i.1 ≠ i.2 by rw [diagonal_apply_ne _ this, nnnorm_zero, NNReal.zero_rpow two_ne_zero]\n    intro h\n    exact Finset.mem_map.not.mp his ⟨i.1, Finset.mem_univ _, Prod.ext rfl h⟩\n\n"}
{"name":"Matrix.frobenius_norm_diagonal","module":"Mathlib.Analysis.Matrix","initialProofState":"n : Type u_4\nα : Type u_5\ninst✝² : Fintype n\ninst✝¹ : SeminormedAddCommGroup α\ninst✝ : DecidableEq n\nv : n → α\n⊢ Eq (Norm.norm (Matrix.diagonal v)) (Norm.norm ((WithLp.equiv 2 (n → α)).symm v))","decl":"@[simp]\ntheorem frobenius_norm_diagonal [DecidableEq n] (v : n → α) :\n    ‖diagonal v‖ = ‖(WithLp.equiv 2 _).symm v‖ :=\n  (congr_arg ((↑) : ℝ≥0 → ℝ) <| frobenius_nnnorm_diagonal v :).trans rfl\n\n"}
{"name":"Matrix.frobenius_nnnorm_one","module":"Mathlib.Analysis.Matrix","initialProofState":"n : Type u_4\nα : Type u_5\ninst✝³ : Fintype n\ninst✝² : DecidableEq n\ninst✝¹ : SeminormedAddCommGroup α\ninst✝ : One α\n⊢ Eq (NNNorm.nnnorm 1) (HMul.hMul (NNReal.sqrt ↑(Fintype.card n)) (NNNorm.nnnorm 1))","decl":"theorem frobenius_nnnorm_one [DecidableEq n] [SeminormedAddCommGroup α] [One α] :\n    ‖(1 : Matrix n n α)‖₊ = .sqrt (Fintype.card n) * ‖(1 : α)‖₊ := by\n  calc\n    ‖(diagonal 1 : Matrix n n α)‖₊\n    _ = ‖(WithLp.equiv 2 (n → α)).symm (Function.const _ 1)‖₊ := frobenius_nnnorm_diagonal _\n    _ = .sqrt (Fintype.card n) * ‖(1 : α)‖₊ := by\n      rw [PiLp.nnnorm_equiv_symm_const (ENNReal.ofNat_ne_top (n := 2))]\n      simp [NNReal.sqrt_eq_rpow]\n\n"}
{"name":"Matrix.frobenius_nnnorm_mul","module":"Mathlib.Analysis.Matrix","initialProofState":"l : Type u_2\nm : Type u_3\nn : Type u_4\nα : Type u_5\ninst✝³ : Fintype l\ninst✝² : Fintype m\ninst✝¹ : Fintype n\ninst✝ : RCLike α\nA : Matrix l m α\nB : Matrix m n α\n⊢ LE.le (NNNorm.nnnorm (HMul.hMul A B)) (HMul.hMul (NNNorm.nnnorm A) (NNNorm.nnnorm B))","decl":"theorem frobenius_nnnorm_mul (A : Matrix l m α) (B : Matrix m n α) : ‖A * B‖₊ ≤ ‖A‖₊ * ‖B‖₊ := by\n  simp_rw [frobenius_nnnorm_def, Matrix.mul_apply]\n  rw [← NNReal.mul_rpow, @Finset.sum_comm _ _ m, Finset.sum_mul_sum]\n  gcongr with i _ j\n  rw [← NNReal.rpow_le_rpow_iff one_half_pos, ← NNReal.rpow_mul,\n    mul_div_cancel₀ (1 : ℝ) two_ne_zero, NNReal.rpow_one, NNReal.mul_rpow]\n  have :=\n    @nnnorm_inner_le_nnnorm α _ _ _ _ ((WithLp.equiv 2 <| _ → α).symm fun j => star (A i j))\n      ((WithLp.equiv 2 <| _ → α).symm fun k => B k j)\n  simpa only [WithLp.equiv_symm_pi_apply, PiLp.inner_apply, RCLike.inner_apply, starRingEnd_apply,\n    Pi.nnnorm_def, PiLp.nnnorm_eq_of_L2, star_star, nnnorm_star, NNReal.sqrt_eq_rpow,\n    NNReal.rpow_two] using this\n\n"}
{"name":"Matrix.frobenius_norm_mul","module":"Mathlib.Analysis.Matrix","initialProofState":"l : Type u_2\nm : Type u_3\nn : Type u_4\nα : Type u_5\ninst✝³ : Fintype l\ninst✝² : Fintype m\ninst✝¹ : Fintype n\ninst✝ : RCLike α\nA : Matrix l m α\nB : Matrix m n α\n⊢ LE.le (Norm.norm (HMul.hMul A B)) (HMul.hMul (Norm.norm A) (Norm.norm B))","decl":"theorem frobenius_norm_mul (A : Matrix l m α) (B : Matrix m n α) : ‖A * B‖ ≤ ‖A‖ * ‖B‖ :=\n  frobenius_nnnorm_mul A B\n\n"}
