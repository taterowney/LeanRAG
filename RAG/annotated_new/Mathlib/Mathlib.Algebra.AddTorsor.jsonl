{"name":"AddTorsor.nonempty","module":"Mathlib.Algebra.AddTorsor","initialProofState":"G : outParam (Type u_1)\nP : Type u_2\ninst✝ : AddGroup G\nself : AddTorsor G P\n⊢ Nonempty P","decl":"/-- An `AddTorsor G P` gives a structure to the nonempty type `P`,\nacted on by an `AddGroup G` with a transitive and free action given\nby the `+ᵥ` operation and a corresponding subtraction given by the\n`-ᵥ` operation. In the case of a vector space, it is an affine\nspace. -/\nclass AddTorsor (G : outParam Type*) (P : Type*) [AddGroup G] extends AddAction G P,\n  VSub G P where\n  [nonempty : Nonempty P]\n  /-- Torsor subtraction and addition with the same element cancels out. -/\n  vsub_vadd' : ∀ p₁ p₂ : P, (p₁ -ᵥ p₂ : G) +ᵥ p₂ = p₁\n  /-- Torsor addition and subtraction with the same element cancels out. -/\n  vadd_vsub' : ∀ (g : G) (p : P), (g +ᵥ p) -ᵥ p = g\n\n -- Porting note (https://github.com/leanprover-community/mathlib4/issues/12096): removed `nolint instance_priority`; lint not ported yet\n"}
{"name":"AddTorsor.vsub_vadd'","module":"Mathlib.Algebra.AddTorsor","initialProofState":"G : outParam (Type u_1)\nP : Type u_2\ninst✝ : AddGroup G\nself : AddTorsor G P\np₁ p₂ : P\n⊢ Eq (HVAdd.hVAdd (VSub.vsub p₁ p₂) p₂) p₁","decl":"/-- An `AddTorsor G P` gives a structure to the nonempty type `P`,\nacted on by an `AddGroup G` with a transitive and free action given\nby the `+ᵥ` operation and a corresponding subtraction given by the\n`-ᵥ` operation. In the case of a vector space, it is an affine\nspace. -/\nclass AddTorsor (G : outParam Type*) (P : Type*) [AddGroup G] extends AddAction G P,\n  VSub G P where\n  [nonempty : Nonempty P]\n  /-- Torsor subtraction and addition with the same element cancels out. -/\n  vsub_vadd' : ∀ p₁ p₂ : P, (p₁ -ᵥ p₂ : G) +ᵥ p₂ = p₁\n  /-- Torsor addition and subtraction with the same element cancels out. -/\n  vadd_vsub' : ∀ (g : G) (p : P), (g +ᵥ p) -ᵥ p = g\n\n -- Porting note (https://github.com/leanprover-community/mathlib4/issues/12096): removed `nolint instance_priority`; lint not ported yet\n"}
{"name":"AddTorsor.vadd_vsub'","module":"Mathlib.Algebra.AddTorsor","initialProofState":"G : outParam (Type u_1)\nP : Type u_2\ninst✝ : AddGroup G\nself : AddTorsor G P\ng : G\np : P\n⊢ Eq (VSub.vsub (HVAdd.hVAdd g p) p) g","decl":"/-- An `AddTorsor G P` gives a structure to the nonempty type `P`,\nacted on by an `AddGroup G` with a transitive and free action given\nby the `+ᵥ` operation and a corresponding subtraction given by the\n`-ᵥ` operation. In the case of a vector space, it is an affine\nspace. -/\nclass AddTorsor (G : outParam Type*) (P : Type*) [AddGroup G] extends AddAction G P,\n  VSub G P where\n  [nonempty : Nonempty P]\n  /-- Torsor subtraction and addition with the same element cancels out. -/\n  vsub_vadd' : ∀ p₁ p₂ : P, (p₁ -ᵥ p₂ : G) +ᵥ p₂ = p₁\n  /-- Torsor addition and subtraction with the same element cancels out. -/\n  vadd_vsub' : ∀ (g : G) (p : P), (g +ᵥ p) -ᵥ p = g\n\n -- Porting note (https://github.com/leanprover-community/mathlib4/issues/12096): removed `nolint instance_priority`; lint not ported yet\n"}
{"name":"vsub_eq_sub","module":"Mathlib.Algebra.AddTorsor","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\ng₁ g₂ : G\n⊢ Eq (VSub.vsub g₁ g₂) (HSub.hSub g₁ g₂)","decl":"/-- Simplify subtraction for a torsor for an `AddGroup G` over\nitself. -/\n@[simp]\ntheorem vsub_eq_sub {G : Type*} [AddGroup G] (g₁ g₂ : G) : g₁ -ᵥ g₂ = g₁ - g₂ :=\n  rfl\n\n"}
{"name":"vsub_vadd","module":"Mathlib.Algebra.AddTorsor","initialProofState":"G : Type u_1\nP : Type u_2\ninst✝ : AddGroup G\nT : AddTorsor G P\np₁ p₂ : P\n⊢ Eq (HVAdd.hVAdd (VSub.vsub p₁ p₂) p₂) p₁","decl":"/-- Adding the result of subtracting from another point produces that\npoint. -/\n@[simp]\ntheorem vsub_vadd (p₁ p₂ : P) : (p₁ -ᵥ p₂) +ᵥ p₂ = p₁ :=\n  AddTorsor.vsub_vadd' p₁ p₂\n\n"}
{"name":"vadd_vsub","module":"Mathlib.Algebra.AddTorsor","initialProofState":"G : Type u_1\nP : Type u_2\ninst✝ : AddGroup G\nT : AddTorsor G P\ng : G\np : P\n⊢ Eq (VSub.vsub (HVAdd.hVAdd g p) p) g","decl":"/-- Adding a group element then subtracting the original point\nproduces that group element. -/\n@[simp]\ntheorem vadd_vsub (g : G) (p : P) : (g +ᵥ p) -ᵥ p = g :=\n  AddTorsor.vadd_vsub' g p\n\n"}
{"name":"vadd_right_cancel","module":"Mathlib.Algebra.AddTorsor","initialProofState":"G : Type u_1\nP : Type u_2\ninst✝ : AddGroup G\nT : AddTorsor G P\ng₁ g₂ : G\np : P\nh : Eq (HVAdd.hVAdd g₁ p) (HVAdd.hVAdd g₂ p)\n⊢ Eq g₁ g₂","decl":"/-- If the same point added to two group elements produces equal\nresults, those group elements are equal. -/\ntheorem vadd_right_cancel {g₁ g₂ : G} (p : P) (h : g₁ +ᵥ p = g₂ +ᵥ p) : g₁ = g₂ := by\n  rw [← vadd_vsub g₁ p, h, vadd_vsub]\n\n"}
{"name":"vadd_right_cancel_iff","module":"Mathlib.Algebra.AddTorsor","initialProofState":"G : Type u_1\nP : Type u_2\ninst✝ : AddGroup G\nT : AddTorsor G P\ng₁ g₂ : G\np : P\n⊢ Iff (Eq (HVAdd.hVAdd g₁ p) (HVAdd.hVAdd g₂ p)) (Eq g₁ g₂)","decl":"@[simp]\ntheorem vadd_right_cancel_iff {g₁ g₂ : G} (p : P) : g₁ +ᵥ p = g₂ +ᵥ p ↔ g₁ = g₂ :=\n  ⟨vadd_right_cancel p, fun h => h ▸ rfl⟩\n\n"}
{"name":"vadd_right_injective","module":"Mathlib.Algebra.AddTorsor","initialProofState":"G : Type u_1\nP : Type u_2\ninst✝ : AddGroup G\nT : AddTorsor G P\np : P\n⊢ Function.Injective fun x => HVAdd.hVAdd x p","decl":"/-- Adding a group element to the point `p` is an injective\nfunction. -/\ntheorem vadd_right_injective (p : P) : Function.Injective ((· +ᵥ p) : G → P) := fun _ _ =>\n  vadd_right_cancel p\n\n"}
{"name":"vadd_vsub_assoc","module":"Mathlib.Algebra.AddTorsor","initialProofState":"G : Type u_1\nP : Type u_2\ninst✝ : AddGroup G\nT : AddTorsor G P\ng : G\np₁ p₂ : P\n⊢ Eq (VSub.vsub (HVAdd.hVAdd g p₁) p₂) (HAdd.hAdd g (VSub.vsub p₁ p₂))","decl":"/-- Adding a group element to a point, then subtracting another point,\nproduces the same result as subtracting the points then adding the\ngroup element. -/\ntheorem vadd_vsub_assoc (g : G) (p₁ p₂ : P) : (g +ᵥ p₁) -ᵥ p₂ = g + (p₁ -ᵥ p₂) := by\n  apply vadd_right_cancel p₂\n  rw [vsub_vadd, add_vadd, vsub_vadd]\n\n"}
{"name":"vsub_self","module":"Mathlib.Algebra.AddTorsor","initialProofState":"G : Type u_1\nP : Type u_2\ninst✝ : AddGroup G\nT : AddTorsor G P\np : P\n⊢ Eq (VSub.vsub p p) 0","decl":"/-- Subtracting a point from itself produces 0. -/\n@[simp]\ntheorem vsub_self (p : P) : p -ᵥ p = (0 : G) := by\n  rw [← zero_add (p -ᵥ p), ← vadd_vsub_assoc, vadd_vsub]\n\n"}
{"name":"eq_of_vsub_eq_zero","module":"Mathlib.Algebra.AddTorsor","initialProofState":"G : Type u_1\nP : Type u_2\ninst✝ : AddGroup G\nT : AddTorsor G P\np₁ p₂ : P\nh : Eq (VSub.vsub p₁ p₂) 0\n⊢ Eq p₁ p₂","decl":"/-- If subtracting two points produces 0, they are equal. -/\ntheorem eq_of_vsub_eq_zero {p₁ p₂ : P} (h : p₁ -ᵥ p₂ = (0 : G)) : p₁ = p₂ := by\n  rw [← vsub_vadd p₁ p₂, h, zero_vadd]\n\n"}
{"name":"vsub_eq_zero_iff_eq","module":"Mathlib.Algebra.AddTorsor","initialProofState":"G : Type u_1\nP : Type u_2\ninst✝ : AddGroup G\nT : AddTorsor G P\np₁ p₂ : P\n⊢ Iff (Eq (VSub.vsub p₁ p₂) 0) (Eq p₁ p₂)","decl":"/-- Subtracting two points produces 0 if and only if they are\nequal. -/\n@[simp]\ntheorem vsub_eq_zero_iff_eq {p₁ p₂ : P} : p₁ -ᵥ p₂ = (0 : G) ↔ p₁ = p₂ :=\n  Iff.intro eq_of_vsub_eq_zero fun h => h ▸ vsub_self _\n\n"}
{"name":"vsub_ne_zero","module":"Mathlib.Algebra.AddTorsor","initialProofState":"G : Type u_1\nP : Type u_2\ninst✝ : AddGroup G\nT : AddTorsor G P\np q : P\n⊢ Iff (Ne (VSub.vsub p q) 0) (Ne p q)","decl":"theorem vsub_ne_zero {p q : P} : p -ᵥ q ≠ (0 : G) ↔ p ≠ q :=\n  not_congr vsub_eq_zero_iff_eq\n\n"}
{"name":"vsub_add_vsub_cancel","module":"Mathlib.Algebra.AddTorsor","initialProofState":"G : Type u_1\nP : Type u_2\ninst✝ : AddGroup G\nT : AddTorsor G P\np₁ p₂ p₃ : P\n⊢ Eq (HAdd.hAdd (VSub.vsub p₁ p₂) (VSub.vsub p₂ p₃)) (VSub.vsub p₁ p₃)","decl":"/-- Cancellation adding the results of two subtractions. -/\n@[simp]\ntheorem vsub_add_vsub_cancel (p₁ p₂ p₃ : P) : p₁ -ᵥ p₂ + (p₂ -ᵥ p₃) = p₁ -ᵥ p₃ := by\n  apply vadd_right_cancel p₃\n  rw [add_vadd, vsub_vadd, vsub_vadd, vsub_vadd]\n\n"}
{"name":"neg_vsub_eq_vsub_rev","module":"Mathlib.Algebra.AddTorsor","initialProofState":"G : Type u_1\nP : Type u_2\ninst✝ : AddGroup G\nT : AddTorsor G P\np₁ p₂ : P\n⊢ Eq (Neg.neg (VSub.vsub p₁ p₂)) (VSub.vsub p₂ p₁)","decl":"/-- Subtracting two points in the reverse order produces the negation\nof subtracting them. -/\n@[simp]\ntheorem neg_vsub_eq_vsub_rev (p₁ p₂ : P) : -(p₁ -ᵥ p₂) = p₂ -ᵥ p₁ := by\n  refine neg_eq_of_add_eq_zero_right (vadd_right_cancel p₁ ?_)\n  rw [vsub_add_vsub_cancel, vsub_self]\n\n"}
{"name":"vadd_vsub_eq_sub_vsub","module":"Mathlib.Algebra.AddTorsor","initialProofState":"G : Type u_1\nP : Type u_2\ninst✝ : AddGroup G\nT : AddTorsor G P\ng : G\np q : P\n⊢ Eq (VSub.vsub (HVAdd.hVAdd g p) q) (HSub.hSub g (VSub.vsub q p))","decl":"theorem vadd_vsub_eq_sub_vsub (g : G) (p q : P) : (g +ᵥ p) -ᵥ q = g - (q -ᵥ p) := by\n  rw [vadd_vsub_assoc, sub_eq_add_neg, neg_vsub_eq_vsub_rev]\n\n"}
{"name":"vsub_vadd_eq_vsub_sub","module":"Mathlib.Algebra.AddTorsor","initialProofState":"G : Type u_1\nP : Type u_2\ninst✝ : AddGroup G\nT : AddTorsor G P\np₁ p₂ : P\ng : G\n⊢ Eq (VSub.vsub p₁ (HVAdd.hVAdd g p₂)) (HSub.hSub (VSub.vsub p₁ p₂) g)","decl":"/-- Subtracting the result of adding a group element produces the same result\nas subtracting the points and subtracting that group element. -/\ntheorem vsub_vadd_eq_vsub_sub (p₁ p₂ : P) (g : G) : p₁ -ᵥ (g +ᵥ p₂) = p₁ -ᵥ p₂ - g := by\n  rw [← add_right_inj (p₂ -ᵥ p₁ : G), vsub_add_vsub_cancel, ← neg_vsub_eq_vsub_rev, vadd_vsub, ←\n    add_sub_assoc, ← neg_vsub_eq_vsub_rev, neg_add_cancel, zero_sub]\n\n"}
{"name":"vsub_sub_vsub_cancel_right","module":"Mathlib.Algebra.AddTorsor","initialProofState":"G : Type u_1\nP : Type u_2\ninst✝ : AddGroup G\nT : AddTorsor G P\np₁ p₂ p₃ : P\n⊢ Eq (HSub.hSub (VSub.vsub p₁ p₃) (VSub.vsub p₂ p₃)) (VSub.vsub p₁ p₂)","decl":"/-- Cancellation subtracting the results of two subtractions. -/\n@[simp]\ntheorem vsub_sub_vsub_cancel_right (p₁ p₂ p₃ : P) : p₁ -ᵥ p₃ - (p₂ -ᵥ p₃) = p₁ -ᵥ p₂ := by\n  rw [← vsub_vadd_eq_vsub_sub, vsub_vadd]\n\n"}
{"name":"eq_vadd_iff_vsub_eq","module":"Mathlib.Algebra.AddTorsor","initialProofState":"G : Type u_1\nP : Type u_2\ninst✝ : AddGroup G\nT : AddTorsor G P\np₁ : P\ng : G\np₂ : P\n⊢ Iff (Eq p₁ (HVAdd.hVAdd g p₂)) (Eq (VSub.vsub p₁ p₂) g)","decl":"/-- Convert between an equality with adding a group element to a point\nand an equality of a subtraction of two points with a group\nelement. -/\ntheorem eq_vadd_iff_vsub_eq (p₁ : P) (g : G) (p₂ : P) : p₁ = g +ᵥ p₂ ↔ p₁ -ᵥ p₂ = g :=\n  ⟨fun h => h.symm ▸ vadd_vsub _ _, fun h => h ▸ (vsub_vadd _ _).symm⟩\n\n"}
{"name":"vadd_eq_vadd_iff_neg_add_eq_vsub","module":"Mathlib.Algebra.AddTorsor","initialProofState":"G : Type u_1\nP : Type u_2\ninst✝ : AddGroup G\nT : AddTorsor G P\nv₁ v₂ : G\np₁ p₂ : P\n⊢ Iff (Eq (HVAdd.hVAdd v₁ p₁) (HVAdd.hVAdd v₂ p₂)) (Eq (HAdd.hAdd (Neg.neg v₁) v₂) (VSub.vsub p₁ p₂))","decl":"theorem vadd_eq_vadd_iff_neg_add_eq_vsub {v₁ v₂ : G} {p₁ p₂ : P} :\n    v₁ +ᵥ p₁ = v₂ +ᵥ p₂ ↔ -v₁ + v₂ = p₁ -ᵥ p₂ := by\n  rw [eq_vadd_iff_vsub_eq, vadd_vsub_assoc, ← add_right_inj (-v₁), neg_add_cancel_left, eq_comm]\n\n"}
{"name":"Set.singleton_vsub_self","module":"Mathlib.Algebra.AddTorsor","initialProofState":"G : Type u_1\nP : Type u_2\ninst✝ : AddGroup G\nT : AddTorsor G P\np : P\n⊢ Eq (VSub.vsub (Singleton.singleton p) (Singleton.singleton p)) (Singleton.singleton 0)","decl":"theorem singleton_vsub_self (p : P) : ({p} : Set P) -ᵥ {p} = {(0 : G)} := by\n  rw [Set.singleton_vsub_singleton, vsub_self]\n\n"}
{"name":"vadd_vsub_vadd_cancel_right","module":"Mathlib.Algebra.AddTorsor","initialProofState":"G : Type u_1\nP : Type u_2\ninst✝ : AddGroup G\nT : AddTorsor G P\nv₁ v₂ : G\np : P\n⊢ Eq (VSub.vsub (HVAdd.hVAdd v₁ p) (HVAdd.hVAdd v₂ p)) (HSub.hSub v₁ v₂)","decl":"@[simp]\ntheorem vadd_vsub_vadd_cancel_right (v₁ v₂ : G) (p : P) : (v₁ +ᵥ p) -ᵥ (v₂ +ᵥ p) = v₁ - v₂ := by\n  rw [vsub_vadd_eq_vsub_sub, vadd_vsub_assoc, vsub_self, add_zero]\n\n"}
{"name":"vsub_left_cancel","module":"Mathlib.Algebra.AddTorsor","initialProofState":"G : Type u_1\nP : Type u_2\ninst✝ : AddGroup G\nT : AddTorsor G P\np₁ p₂ p : P\nh : Eq (VSub.vsub p₁ p) (VSub.vsub p₂ p)\n⊢ Eq p₁ p₂","decl":"/-- If the same point subtracted from two points produces equal\nresults, those points are equal. -/\ntheorem vsub_left_cancel {p₁ p₂ p : P} (h : p₁ -ᵥ p = p₂ -ᵥ p) : p₁ = p₂ := by\n  rwa [← sub_eq_zero, vsub_sub_vsub_cancel_right, vsub_eq_zero_iff_eq] at h\n\n"}
{"name":"vsub_left_cancel_iff","module":"Mathlib.Algebra.AddTorsor","initialProofState":"G : Type u_1\nP : Type u_2\ninst✝ : AddGroup G\nT : AddTorsor G P\np₁ p₂ p : P\n⊢ Iff (Eq (VSub.vsub p₁ p) (VSub.vsub p₂ p)) (Eq p₁ p₂)","decl":"/-- The same point subtracted from two points produces equal results\nif and only if those points are equal. -/\n@[simp]\ntheorem vsub_left_cancel_iff {p₁ p₂ p : P} : p₁ -ᵥ p = p₂ -ᵥ p ↔ p₁ = p₂ :=\n  ⟨vsub_left_cancel, fun h => h ▸ rfl⟩\n\n"}
{"name":"vsub_left_injective","module":"Mathlib.Algebra.AddTorsor","initialProofState":"G : Type u_1\nP : Type u_2\ninst✝ : AddGroup G\nT : AddTorsor G P\np : P\n⊢ Function.Injective fun x => VSub.vsub x p","decl":"/-- Subtracting the point `p` is an injective function. -/\ntheorem vsub_left_injective (p : P) : Function.Injective ((· -ᵥ p) : P → G) := fun _ _ =>\n  vsub_left_cancel\n\n"}
{"name":"vsub_right_cancel","module":"Mathlib.Algebra.AddTorsor","initialProofState":"G : Type u_1\nP : Type u_2\ninst✝ : AddGroup G\nT : AddTorsor G P\np₁ p₂ p : P\nh : Eq (VSub.vsub p p₁) (VSub.vsub p p₂)\n⊢ Eq p₁ p₂","decl":"/-- If subtracting two points from the same point produces equal\nresults, those points are equal. -/\ntheorem vsub_right_cancel {p₁ p₂ p : P} (h : p -ᵥ p₁ = p -ᵥ p₂) : p₁ = p₂ := by\n  refine vadd_left_cancel (p -ᵥ p₂) ?_\n  rw [vsub_vadd, ← h, vsub_vadd]\n\n"}
{"name":"vsub_right_cancel_iff","module":"Mathlib.Algebra.AddTorsor","initialProofState":"G : Type u_1\nP : Type u_2\ninst✝ : AddGroup G\nT : AddTorsor G P\np₁ p₂ p : P\n⊢ Iff (Eq (VSub.vsub p p₁) (VSub.vsub p p₂)) (Eq p₁ p₂)","decl":"/-- Subtracting two points from the same point produces equal results\nif and only if those points are equal. -/\n@[simp]\ntheorem vsub_right_cancel_iff {p₁ p₂ p : P} : p -ᵥ p₁ = p -ᵥ p₂ ↔ p₁ = p₂ :=\n  ⟨vsub_right_cancel, fun h => h ▸ rfl⟩\n\n"}
{"name":"vsub_right_injective","module":"Mathlib.Algebra.AddTorsor","initialProofState":"G : Type u_1\nP : Type u_2\ninst✝ : AddGroup G\nT : AddTorsor G P\np : P\n⊢ Function.Injective fun x => VSub.vsub p x","decl":"/-- Subtracting a point from the point `p` is an injective\nfunction. -/\ntheorem vsub_right_injective (p : P) : Function.Injective ((p -ᵥ ·) : P → G) := fun _ _ =>\n  vsub_right_cancel\n\n"}
{"name":"vsub_sub_vsub_cancel_left","module":"Mathlib.Algebra.AddTorsor","initialProofState":"G : Type u_1\nP : Type u_2\ninst✝¹ : AddCommGroup G\ninst✝ : AddTorsor G P\np₁ p₂ p₃ : P\n⊢ Eq (HSub.hSub (VSub.vsub p₃ p₂) (VSub.vsub p₃ p₁)) (VSub.vsub p₁ p₂)","decl":"/-- Cancellation subtracting the results of two subtractions. -/\n@[simp]\ntheorem vsub_sub_vsub_cancel_left (p₁ p₂ p₃ : P) : p₃ -ᵥ p₂ - (p₃ -ᵥ p₁) = p₁ -ᵥ p₂ := by\n  rw [sub_eq_add_neg, neg_vsub_eq_vsub_rev, add_comm, vsub_add_vsub_cancel]\n\n"}
{"name":"vadd_vsub_vadd_cancel_left","module":"Mathlib.Algebra.AddTorsor","initialProofState":"G : Type u_1\nP : Type u_2\ninst✝¹ : AddCommGroup G\ninst✝ : AddTorsor G P\nv : G\np₁ p₂ : P\n⊢ Eq (VSub.vsub (HVAdd.hVAdd v p₁) (HVAdd.hVAdd v p₂)) (VSub.vsub p₁ p₂)","decl":"@[simp]\ntheorem vadd_vsub_vadd_cancel_left (v : G) (p₁ p₂ : P) : (v +ᵥ p₁) -ᵥ (v +ᵥ p₂) = p₁ -ᵥ p₂ := by\n  rw [vsub_vadd_eq_vsub_sub, vadd_vsub_assoc, add_sub_cancel_left]\n\n"}
{"name":"vsub_vadd_comm","module":"Mathlib.Algebra.AddTorsor","initialProofState":"G : Type u_1\nP : Type u_2\ninst✝¹ : AddCommGroup G\ninst✝ : AddTorsor G P\np₁ p₂ p₃ : P\n⊢ Eq (HVAdd.hVAdd (VSub.vsub p₁ p₂) p₃) (HVAdd.hVAdd (VSub.vsub p₃ p₂) p₁)","decl":"theorem vsub_vadd_comm (p₁ p₂ p₃ : P) : (p₁ -ᵥ p₂ : G) +ᵥ p₃ = (p₃ -ᵥ p₂) +ᵥ p₁ := by\n  rw [← @vsub_eq_zero_iff_eq G, vadd_vsub_assoc, vsub_vadd_eq_vsub_sub]\n  simp\n\n"}
{"name":"vadd_eq_vadd_iff_sub_eq_vsub","module":"Mathlib.Algebra.AddTorsor","initialProofState":"G : Type u_1\nP : Type u_2\ninst✝¹ : AddCommGroup G\ninst✝ : AddTorsor G P\nv₁ v₂ : G\np₁ p₂ : P\n⊢ Iff (Eq (HVAdd.hVAdd v₁ p₁) (HVAdd.hVAdd v₂ p₂)) (Eq (HSub.hSub v₂ v₁) (VSub.vsub p₁ p₂))","decl":"theorem vadd_eq_vadd_iff_sub_eq_vsub {v₁ v₂ : G} {p₁ p₂ : P} :\n    v₁ +ᵥ p₁ = v₂ +ᵥ p₂ ↔ v₂ - v₁ = p₁ -ᵥ p₂ := by\n  rw [vadd_eq_vadd_iff_neg_add_eq_vsub, neg_add_eq_sub]\n\n"}
{"name":"vsub_sub_vsub_comm","module":"Mathlib.Algebra.AddTorsor","initialProofState":"G : Type u_1\nP : Type u_2\ninst✝¹ : AddCommGroup G\ninst✝ : AddTorsor G P\np₁ p₂ p₃ p₄ : P\n⊢ Eq (HSub.hSub (VSub.vsub p₁ p₂) (VSub.vsub p₃ p₄)) (HSub.hSub (VSub.vsub p₁ p₃) (VSub.vsub p₂ p₄))","decl":"theorem vsub_sub_vsub_comm (p₁ p₂ p₃ p₄ : P) : p₁ -ᵥ p₂ - (p₃ -ᵥ p₄) = p₁ -ᵥ p₃ - (p₂ -ᵥ p₄) := by\n  rw [← vsub_vadd_eq_vsub_sub, vsub_vadd_comm, vsub_vadd_eq_vsub_sub]\n\n"}
{"name":"Set.vadd_set_vsub_vadd_set","module":"Mathlib.Algebra.AddTorsor","initialProofState":"G : Type u_1\nP : Type u_2\ninst✝¹ : AddCommGroup G\ninst✝ : AddTorsor G P\nv : G\ns t : Set P\n⊢ Eq (VSub.vsub (HVAdd.hVAdd v s) (HVAdd.hVAdd v t)) (VSub.vsub s t)","decl":"@[simp] lemma vadd_set_vsub_vadd_set (v : G) (s t : Set P) : (v +ᵥ s) -ᵥ (v +ᵥ t) = s -ᵥ t := by\n  ext; simp [mem_vsub, mem_vadd_set]\n\n"}
{"name":"Prod.fst_vadd","module":"Mathlib.Algebra.AddTorsor","initialProofState":"G : Type u_1\nG' : Type u_2\nP : Type u_3\nP' : Type u_4\ninst✝³ : AddGroup G\ninst✝² : AddGroup G'\ninst✝¹ : AddTorsor G P\ninst✝ : AddTorsor G' P'\nv : Prod G G'\np : Prod P P'\n⊢ Eq (HVAdd.hVAdd v p).1 (HVAdd.hVAdd v.1 p.1)","decl":"@[simp]\ntheorem fst_vadd (v : G × G') (p : P × P') : (v +ᵥ p).1 = v.1 +ᵥ p.1 :=\n  rfl\n\n"}
{"name":"Prod.snd_vadd","module":"Mathlib.Algebra.AddTorsor","initialProofState":"G : Type u_1\nG' : Type u_2\nP : Type u_3\nP' : Type u_4\ninst✝³ : AddGroup G\ninst✝² : AddGroup G'\ninst✝¹ : AddTorsor G P\ninst✝ : AddTorsor G' P'\nv : Prod G G'\np : Prod P P'\n⊢ Eq (HVAdd.hVAdd v p).2 (HVAdd.hVAdd v.2 p.2)","decl":"@[simp]\ntheorem snd_vadd (v : G × G') (p : P × P') : (v +ᵥ p).2 = v.2 +ᵥ p.2 :=\n  rfl\n\n"}
{"name":"Prod.mk_vadd_mk","module":"Mathlib.Algebra.AddTorsor","initialProofState":"G : Type u_1\nG' : Type u_2\nP : Type u_3\nP' : Type u_4\ninst✝³ : AddGroup G\ninst✝² : AddGroup G'\ninst✝¹ : AddTorsor G P\ninst✝ : AddTorsor G' P'\nv : G\nv' : G'\np : P\np' : P'\n⊢ Eq (HVAdd.hVAdd { fst := v, snd := v' } { fst := p, snd := p' }) { fst := HVAdd.hVAdd v p, snd := HVAdd.hVAdd v' p' }","decl":"@[simp]\ntheorem mk_vadd_mk (v : G) (v' : G') (p : P) (p' : P') : (v, v') +ᵥ (p, p') = (v +ᵥ p, v' +ᵥ p') :=\n  rfl\n\n"}
{"name":"Prod.fst_vsub","module":"Mathlib.Algebra.AddTorsor","initialProofState":"G : Type u_1\nG' : Type u_2\nP : Type u_3\nP' : Type u_4\ninst✝³ : AddGroup G\ninst✝² : AddGroup G'\ninst✝¹ : AddTorsor G P\ninst✝ : AddTorsor G' P'\np₁ p₂ : Prod P P'\n⊢ Eq (VSub.vsub p₁ p₂).1 (VSub.vsub p₁.1 p₂.1)","decl":"@[simp]\ntheorem fst_vsub (p₁ p₂ : P × P') : (p₁ -ᵥ p₂ : G × G').1 = p₁.1 -ᵥ p₂.1 :=\n  rfl\n\n"}
{"name":"Prod.snd_vsub","module":"Mathlib.Algebra.AddTorsor","initialProofState":"G : Type u_1\nG' : Type u_2\nP : Type u_3\nP' : Type u_4\ninst✝³ : AddGroup G\ninst✝² : AddGroup G'\ninst✝¹ : AddTorsor G P\ninst✝ : AddTorsor G' P'\np₁ p₂ : Prod P P'\n⊢ Eq (VSub.vsub p₁ p₂).2 (VSub.vsub p₁.2 p₂.2)","decl":"@[simp]\ntheorem snd_vsub (p₁ p₂ : P × P') : (p₁ -ᵥ p₂ : G × G').2 = p₁.2 -ᵥ p₂.2 :=\n  rfl\n\n"}
{"name":"Prod.mk_vsub_mk","module":"Mathlib.Algebra.AddTorsor","initialProofState":"G : Type u_1\nG' : Type u_2\nP : Type u_3\nP' : Type u_4\ninst✝³ : AddGroup G\ninst✝² : AddGroup G'\ninst✝¹ : AddTorsor G P\ninst✝ : AddTorsor G' P'\np₁ p₂ : P\np₁' p₂' : P'\n⊢ Eq (VSub.vsub { fst := p₁, snd := p₁' } { fst := p₂, snd := p₂' }) { fst := VSub.vsub p₁ p₂, snd := VSub.vsub p₁' p₂' }","decl":"@[simp]\ntheorem mk_vsub_mk (p₁ p₂ : P) (p₁' p₂' : P') :\n    ((p₁, p₁') -ᵥ (p₂, p₂') : G × G') = (p₁ -ᵥ p₂, p₁' -ᵥ p₂') :=\n  rfl\n\n"}
{"name":"Equiv.coe_vaddConst","module":"Mathlib.Algebra.AddTorsor","initialProofState":"G : Type u_1\nP : Type u_2\ninst✝¹ : AddGroup G\ninst✝ : AddTorsor G P\np : P\n⊢ Eq ⇑(Equiv.vaddConst p) fun v => HVAdd.hVAdd v p","decl":"@[simp]\ntheorem coe_vaddConst (p : P) : ⇑(vaddConst p) = fun v => v +ᵥ p :=\n  rfl\n\n"}
{"name":"Equiv.coe_vaddConst_symm","module":"Mathlib.Algebra.AddTorsor","initialProofState":"G : Type u_1\nP : Type u_2\ninst✝¹ : AddGroup G\ninst✝ : AddTorsor G P\np : P\n⊢ Eq ⇑(Equiv.vaddConst p).symm fun p' => VSub.vsub p' p","decl":"@[simp]\ntheorem coe_vaddConst_symm (p : P) : ⇑(vaddConst p).symm = fun p' => p' -ᵥ p :=\n  rfl\n\n"}
{"name":"Equiv.coe_constVSub","module":"Mathlib.Algebra.AddTorsor","initialProofState":"G : Type u_1\nP : Type u_2\ninst✝¹ : AddGroup G\ninst✝ : AddTorsor G P\np : P\n⊢ Eq ⇑(Equiv.constVSub p) fun x => VSub.vsub p x","decl":"@[simp] lemma coe_constVSub (p : P) : ⇑(constVSub p) = (p -ᵥ ·) := rfl\n\n"}
{"name":"Equiv.coe_constVSub_symm","module":"Mathlib.Algebra.AddTorsor","initialProofState":"G : Type u_1\nP : Type u_2\ninst✝¹ : AddGroup G\ninst✝ : AddTorsor G P\np : P\n⊢ Eq ⇑(Equiv.constVSub p).symm fun v => HVAdd.hVAdd (Neg.neg v) p","decl":"@[simp]\ntheorem coe_constVSub_symm (p : P) : ⇑(constVSub p).symm = fun (v : G) => -v +ᵥ p :=\n  rfl\n\n"}
{"name":"Equiv.coe_constVAdd","module":"Mathlib.Algebra.AddTorsor","initialProofState":"G : Type u_1\nP : Type u_2\ninst✝¹ : AddGroup G\ninst✝ : AddTorsor G P\nv : G\n⊢ Eq ⇑(Equiv.constVAdd P v) fun x => HVAdd.hVAdd v x","decl":"@[simp] lemma coe_constVAdd (v : G) : ⇑(constVAdd P v) = (v +ᵥ ·) := rfl\n\n"}
{"name":"Equiv.constVAdd_zero","module":"Mathlib.Algebra.AddTorsor","initialProofState":"G : Type u_1\nP : Type u_2\ninst✝¹ : AddGroup G\ninst✝ : AddTorsor G P\n⊢ Eq (Equiv.constVAdd P 0) 1","decl":"@[simp]\ntheorem constVAdd_zero : constVAdd P (0 : G) = 1 :=\n  ext <| zero_vadd G\n\n"}
{"name":"Equiv.constVAdd_add","module":"Mathlib.Algebra.AddTorsor","initialProofState":"G : Type u_1\nP : Type u_2\ninst✝¹ : AddGroup G\ninst✝ : AddTorsor G P\nv₁ v₂ : G\n⊢ Eq (Equiv.constVAdd P (HAdd.hAdd v₁ v₂)) (HMul.hMul (Equiv.constVAdd P v₁) (Equiv.constVAdd P v₂))","decl":"@[simp]\ntheorem constVAdd_add (v₁ v₂ : G) : constVAdd P (v₁ + v₂) = constVAdd P v₁ * constVAdd P v₂ :=\n  ext <| add_vadd v₁ v₂\n\n"}
{"name":"Equiv.pointReflection_apply","module":"Mathlib.Algebra.AddTorsor","initialProofState":"G : Type u_1\nP : Type u_2\ninst✝¹ : AddGroup G\ninst✝ : AddTorsor G P\nx y : P\n⊢ Eq ((Equiv.pointReflection x) y) (HVAdd.hVAdd (VSub.vsub x y) x)","decl":"theorem pointReflection_apply (x y : P) : pointReflection x y = (x -ᵥ y) +ᵥ x :=\n  rfl\n\n"}
{"name":"Equiv.pointReflection_vsub_left","module":"Mathlib.Algebra.AddTorsor","initialProofState":"G : Type u_1\nP : Type u_2\ninst✝¹ : AddGroup G\ninst✝ : AddTorsor G P\nx y : P\n⊢ Eq (VSub.vsub ((Equiv.pointReflection x) y) x) (VSub.vsub x y)","decl":"@[simp]\ntheorem pointReflection_vsub_left (x y : P) : pointReflection x y -ᵥ x = x -ᵥ y :=\n  vadd_vsub ..\n\n"}
{"name":"Equiv.left_vsub_pointReflection","module":"Mathlib.Algebra.AddTorsor","initialProofState":"G : Type u_1\nP : Type u_2\ninst✝¹ : AddGroup G\ninst✝ : AddTorsor G P\nx y : P\n⊢ Eq (VSub.vsub x ((Equiv.pointReflection x) y)) (VSub.vsub y x)","decl":"@[simp]\ntheorem left_vsub_pointReflection (x y : P) : x -ᵥ pointReflection x y = y -ᵥ x :=\n  neg_injective <| by simp\n\n"}
{"name":"Equiv.pointReflection_vsub_right","module":"Mathlib.Algebra.AddTorsor","initialProofState":"G : Type u_1\nP : Type u_2\ninst✝¹ : AddGroup G\ninst✝ : AddTorsor G P\nx y : P\n⊢ Eq (VSub.vsub ((Equiv.pointReflection x) y) y) (HSMul.hSMul 2 (VSub.vsub x y))","decl":"@[simp]\ntheorem pointReflection_vsub_right (x y : P) : pointReflection x y -ᵥ y = 2 • (x -ᵥ y) := by\n  simp [pointReflection, two_nsmul, vadd_vsub_assoc]\n\n"}
{"name":"Equiv.right_vsub_pointReflection","module":"Mathlib.Algebra.AddTorsor","initialProofState":"G : Type u_1\nP : Type u_2\ninst✝¹ : AddGroup G\ninst✝ : AddTorsor G P\nx y : P\n⊢ Eq (VSub.vsub y ((Equiv.pointReflection x) y)) (HSMul.hSMul 2 (VSub.vsub y x))","decl":"@[simp]\ntheorem right_vsub_pointReflection (x y : P) : y -ᵥ pointReflection x y = 2 • (y -ᵥ x) :=\n  neg_injective <| by simp [← neg_nsmul]\n\n"}
{"name":"Equiv.pointReflection_symm","module":"Mathlib.Algebra.AddTorsor","initialProofState":"G : Type u_1\nP : Type u_2\ninst✝¹ : AddGroup G\ninst✝ : AddTorsor G P\nx : P\n⊢ Eq (Equiv.symm (Equiv.pointReflection x)) (Equiv.pointReflection x)","decl":"@[simp]\ntheorem pointReflection_symm (x : P) : (pointReflection x).symm = pointReflection x :=\n  ext <| by simp [pointReflection]\n\n"}
{"name":"Equiv.pointReflection_self","module":"Mathlib.Algebra.AddTorsor","initialProofState":"G : Type u_1\nP : Type u_2\ninst✝¹ : AddGroup G\ninst✝ : AddTorsor G P\nx : P\n⊢ Eq ((Equiv.pointReflection x) x) x","decl":"@[simp]\ntheorem pointReflection_self (x : P) : pointReflection x x = x :=\n  vsub_vadd _ _\n\n"}
{"name":"Equiv.pointReflection_involutive","module":"Mathlib.Algebra.AddTorsor","initialProofState":"G : Type u_1\nP : Type u_2\ninst✝¹ : AddGroup G\ninst✝ : AddTorsor G P\nx : P\n⊢ Function.Involutive ⇑(Equiv.pointReflection x)","decl":"theorem pointReflection_involutive (x : P) : Involutive (pointReflection x : P → P) := fun y =>\n  (Equiv.apply_eq_iff_eq_symm_apply _).2 <| by rw [pointReflection_symm]\n\n"}
{"name":"Equiv.pointReflection_fixed_iff_of_injective_two_nsmul","module":"Mathlib.Algebra.AddTorsor","initialProofState":"G : Type u_1\nP : Type u_2\ninst✝¹ : AddGroup G\ninst✝ : AddTorsor G P\nx y : P\nh : Function.Injective fun x => HSMul.hSMul 2 x\n⊢ Iff (Eq ((Equiv.pointReflection x) y) y) (Eq y x)","decl":"/-- `x` is the only fixed point of `pointReflection x`. This lemma requires\n`x + x = y + y ↔ x = y`. There is no typeclass to use here, so we add it as an explicit argument. -/\ntheorem pointReflection_fixed_iff_of_injective_two_nsmul {x y : P} (h : Injective (2 • · : G → G)) :\n    pointReflection x y = y ↔ y = x := by\n  rw [pointReflection_apply, eq_comm, eq_vadd_iff_vsub_eq, ← neg_vsub_eq_vsub_rev,\n    neg_eq_iff_add_eq_zero, ← two_nsmul, ← nsmul_zero 2, h.eq_iff, vsub_eq_zero_iff_eq, eq_comm]\n\n"}
{"name":"Equiv.pointReflection_fixed_iff_of_injective_bit0","module":"Mathlib.Algebra.AddTorsor","initialProofState":"G : Type u_1\nP : Type u_2\ninst✝¹ : AddGroup G\ninst✝ : AddTorsor G P\nx y : P\nh : Function.Injective fun x => HSMul.hSMul 2 x\n⊢ Iff (Eq ((Equiv.pointReflection x) y) y) (Eq y x)","decl":"@[deprecated (since := \"2024-11-18\")] alias pointReflection_fixed_iff_of_injective_bit0 :=\npointReflection_fixed_iff_of_injective_two_nsmul\n\n"}
{"name":"Equiv.injective_pointReflection_left_of_injective_two_nsmul","module":"Mathlib.Algebra.AddTorsor","initialProofState":"G : Type u_3\nP : Type u_4\ninst✝¹ : AddCommGroup G\ninst✝ : AddTorsor G P\nh : Function.Injective fun x => HSMul.hSMul 2 x\ny : P\n⊢ Function.Injective fun x => (Equiv.pointReflection x) y","decl":"theorem injective_pointReflection_left_of_injective_two_nsmul {G P : Type*} [AddCommGroup G]\n    [AddTorsor G P] (h : Injective (2 • · : G → G)) (y : P) :\n    Injective fun x : P => pointReflection x y :=\n  fun x₁ x₂ (hy : pointReflection x₁ y = pointReflection x₂ y) => by\n  rwa [pointReflection_apply, pointReflection_apply, vadd_eq_vadd_iff_sub_eq_vsub,\n    vsub_sub_vsub_cancel_right, ← neg_vsub_eq_vsub_rev, neg_eq_iff_add_eq_zero,\n    ← two_nsmul, ← nsmul_zero 2, h.eq_iff, vsub_eq_zero_iff_eq] at hy\n\n"}
{"name":"Equiv.injective_pointReflection_left_of_injective_bit0","module":"Mathlib.Algebra.AddTorsor","initialProofState":"G : Type u_3\nP : Type u_4\ninst✝¹ : AddCommGroup G\ninst✝ : AddTorsor G P\nh : Function.Injective fun x => HSMul.hSMul 2 x\ny : P\n⊢ Function.Injective fun x => (Equiv.pointReflection x) y","decl":"@[deprecated (since := \"2024-11-18\")] alias injective_pointReflection_left_of_injective_bit0 :=\ninjective_pointReflection_left_of_injective_two_nsmul\n\n"}
{"name":"AddTorsor.subsingleton_iff","module":"Mathlib.Algebra.AddTorsor","initialProofState":"G : Type u_1\nP : Type u_2\ninst✝¹ : AddGroup G\ninst✝ : AddTorsor G P\n⊢ Iff (Subsingleton G) (Subsingleton P)","decl":"theorem AddTorsor.subsingleton_iff (G P : Type*) [AddGroup G] [AddTorsor G P] :\n    Subsingleton G ↔ Subsingleton P := by\n  inhabit P\n  exact (Equiv.vaddConst default).subsingleton_congr\n"}
