{"name":"CategoryTheory.MorphismProperty.LeftFraction₂.symm_add","module":"Mathlib.CategoryTheory.Localization.CalculusOfFractions.Preadditive","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_3, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nW : CategoryTheory.MorphismProperty C\nX Y : C\nφ : W.LeftFraction₂ X Y\n⊢ Eq φ.symm.add φ.add","decl":"@[simp]\nlemma symm_add : φ.symm.add = φ.add := by\n  dsimp [add, symm]\n  congr 1\n  apply add_comm\n\n"}
{"name":"CategoryTheory.MorphismProperty.LeftFraction₂.map_add","module":"Mathlib.CategoryTheory.Localization.CalculusOfFractions.Preadditive","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁴ : CategoryTheory.Category.{u_3, u_1} C\ninst✝³ : CategoryTheory.Category.{u_4, u_2} D\ninst✝² : CategoryTheory.Preadditive C\nW : CategoryTheory.MorphismProperty C\nX Y : C\nφ : W.LeftFraction₂ X Y\nF : CategoryTheory.Functor C D\nhF : W.IsInvertedBy F\ninst✝¹ : CategoryTheory.Preadditive D\ninst✝ : F.Additive\n⊢ Eq (φ.add.map F hF) (HAdd.hAdd (φ.fst.map F hF) (φ.snd.map F hF))","decl":"@[simp]\nlemma map_add (F : C ⥤ D) (hF : W.IsInvertedBy F) [Preadditive D] [F.Additive] :\n    φ.add.map F hF = φ.fst.map F hF + φ.snd.map F hF := by\n  have := hF φ.s φ.hs\n  rw [← cancel_mono (F.map φ.s), add_comp, LeftFraction.map_comp_map_s,\n    LeftFraction.map_comp_map_s, LeftFraction.map_comp_map_s, F.map_add]\n\n"}
{"name":"CategoryTheory.Localization.Preadditive.neg'_eq","module":"Mathlib.CategoryTheory.Localization.CalculusOfFractions.Preadditive","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁴ : CategoryTheory.Category.{u_4, u_1} C\ninst✝³ : CategoryTheory.Category.{u_3, u_2} D\ninst✝² : CategoryTheory.Preadditive C\nL : CategoryTheory.Functor C D\nW : CategoryTheory.MorphismProperty C\ninst✝¹ : L.IsLocalization W\ninst✝ : W.HasLeftCalculusOfFractions\nX Y : C\nf : Quiver.Hom (L.obj X) (L.obj Y)\nφ : W.LeftFraction X Y\nhφ : Eq f (φ.map L ⋯)\n⊢ Eq (CategoryTheory.Localization.Preadditive.neg' W f) (φ.neg.map L ⋯)","decl":"lemma neg'_eq (f : L.obj X ⟶ L.obj Y) (φ : W.LeftFraction X Y)\n    (hφ : f = φ.map L (inverts L W)) :\n    neg' W f = φ.neg.map L (inverts L W) := by\n  obtain ⟨φ₀, rfl, hφ₀⟩ : ∃ (φ₀ : W.LeftFraction X Y)\n    (_ : f = φ₀.map L (inverts L W)),\n      neg' W f = φ₀.neg.map L (inverts L W) :=\n    ⟨_, (exists_leftFraction L W f).choose_spec, rfl⟩\n  rw [MorphismProperty.LeftFraction.map_eq_iff] at hφ\n  obtain ⟨Y', t₁, t₂, hst, hft, ht⟩ := hφ\n  have := inverts L W _ ht\n  rw [← cancel_mono (L.map (φ₀.s ≫ t₁))]\n  nth_rw 1 [L.map_comp]\n  rw [hφ₀, hst, LeftFraction.map_comp_map_s_assoc, L.map_comp,\n    LeftFraction.map_comp_map_s_assoc, ← L.map_comp, ← L.map_comp,\n    neg_comp, neg_comp, hft]\n\n"}
{"name":"CategoryTheory.Localization.Preadditive.add'_eq","module":"Mathlib.CategoryTheory.Localization.CalculusOfFractions.Preadditive","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁴ : CategoryTheory.Category.{u_4, u_1} C\ninst✝³ : CategoryTheory.Category.{u_3, u_2} D\ninst✝² : CategoryTheory.Preadditive C\nL : CategoryTheory.Functor C D\nW : CategoryTheory.MorphismProperty C\ninst✝¹ : L.IsLocalization W\ninst✝ : W.HasLeftCalculusOfFractions\nX Y : C\nf₁ f₂ : Quiver.Hom (L.obj X) (L.obj Y)\nφ : W.LeftFraction₂ X Y\nhφ₁ : Eq f₁ (φ.fst.map L ⋯)\nhφ₂ : Eq f₂ (φ.snd.map L ⋯)\n⊢ Eq (CategoryTheory.Localization.Preadditive.add' W f₁ f₂) (φ.add.map L ⋯)","decl":"lemma add'_eq (f₁ f₂ : L.obj X ⟶ L.obj Y) (φ : W.LeftFraction₂ X Y)\n    (hφ₁ : f₁ = φ.fst.map L (inverts L W))\n    (hφ₂ : f₂ = φ.snd.map L (inverts L W)) :\n    add' W f₁ f₂ = φ.add.map L (inverts L W) := by\n  obtain ⟨φ₀, rfl, rfl, hφ₀⟩ : ∃ (φ₀ : W.LeftFraction₂ X Y)\n    (_ : f₁ = φ₀.fst.map L (inverts L W))\n    (_ : f₂ = φ₀.snd.map L (inverts L W)),\n    add' W f₁ f₂ = φ₀.add.map L (inverts L W) :=\n    ⟨(exists_leftFraction₂ L W f₁ f₂).choose,\n      (exists_leftFraction₂ L W f₁ f₂).choose_spec.1,\n      (exists_leftFraction₂ L W f₁ f₂).choose_spec.2, rfl⟩\n  obtain ⟨Z, t₁, t₂, hst, hft, hft', ht⟩ := (LeftFraction₂.map_eq_iff L W φ₀ φ).1 ⟨hφ₁, hφ₂⟩\n  have := inverts L W _ ht\n  rw [hφ₀, ← cancel_mono (L.map (φ₀.s ≫ t₁))]\n  nth_rw 2 [hst]\n  rw [L.map_comp, L.map_comp, LeftFraction.map_comp_map_s_assoc,\n    LeftFraction.map_comp_map_s_assoc, ← L.map_comp, ← L.map_comp,\n    add_comp, add_comp, hft, hft']\n\n"}
{"name":"CategoryTheory.Localization.Preadditive.add'_comm","module":"Mathlib.CategoryTheory.Localization.CalculusOfFractions.Preadditive","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁴ : CategoryTheory.Category.{u_4, u_1} C\ninst✝³ : CategoryTheory.Category.{u_3, u_2} D\ninst✝² : CategoryTheory.Preadditive C\nL : CategoryTheory.Functor C D\nW : CategoryTheory.MorphismProperty C\ninst✝¹ : L.IsLocalization W\ninst✝ : W.HasLeftCalculusOfFractions\nX Y : C\nf₁ f₂ : Quiver.Hom (L.obj X) (L.obj Y)\n⊢ Eq (CategoryTheory.Localization.Preadditive.add' W f₁ f₂) (CategoryTheory.Localization.Preadditive.add' W f₂ f₁)","decl":"lemma add'_comm (f₁ f₂ : L.obj X ⟶ L.obj Y) :\n    add' W f₁ f₂ = add' W f₂ f₁ := by\n  obtain ⟨α, h₁, h₂⟩ := exists_leftFraction₂ L W f₁ f₂\n  rw [add'_eq W f₁ f₂ α h₁ h₂, add'_eq W f₂ f₁ α.symm h₂ h₁, α.symm_add]\n\n"}
{"name":"CategoryTheory.Localization.Preadditive.add'_zero","module":"Mathlib.CategoryTheory.Localization.CalculusOfFractions.Preadditive","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁴ : CategoryTheory.Category.{u_4, u_1} C\ninst✝³ : CategoryTheory.Category.{u_3, u_2} D\ninst✝² : CategoryTheory.Preadditive C\nL : CategoryTheory.Functor C D\nW : CategoryTheory.MorphismProperty C\ninst✝¹ : L.IsLocalization W\ninst✝ : W.HasLeftCalculusOfFractions\nX Y : C\nf : Quiver.Hom (L.obj X) (L.obj Y)\n⊢ Eq (CategoryTheory.Localization.Preadditive.add' W f (L.map 0)) f","decl":"lemma add'_zero (f : L.obj X ⟶ L.obj Y) :\n    add' W f (L.map 0) = f := by\n  obtain ⟨α, hα⟩ := exists_leftFraction L W f\n  rw [add'_eq W f (L.map 0) (LeftFraction₂.mk α.f 0 α.s α.hs) hα, hα]; swap\n  · have := inverts L W _ α.hs\n    rw [← cancel_mono (L.map α.s), ← L.map_comp, Limits.zero_comp,\n      LeftFraction.map_comp_map_s]\n  dsimp [LeftFraction₂.add]\n  rw [add_zero]\n\n"}
{"name":"CategoryTheory.Localization.Preadditive.zero_add'","module":"Mathlib.CategoryTheory.Localization.CalculusOfFractions.Preadditive","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁴ : CategoryTheory.Category.{u_4, u_1} C\ninst✝³ : CategoryTheory.Category.{u_3, u_2} D\ninst✝² : CategoryTheory.Preadditive C\nL : CategoryTheory.Functor C D\nW : CategoryTheory.MorphismProperty C\ninst✝¹ : L.IsLocalization W\ninst✝ : W.HasLeftCalculusOfFractions\nX Y : C\nf : Quiver.Hom (L.obj X) (L.obj Y)\n⊢ Eq (CategoryTheory.Localization.Preadditive.add' W (L.map 0) f) f","decl":"lemma zero_add' (f : L.obj X ⟶ L.obj Y) :\n    add' W (L.map 0) f = f := by\n  rw [add'_comm, add'_zero]\n\n"}
{"name":"CategoryTheory.Localization.Preadditive.neg'_add'_self","module":"Mathlib.CategoryTheory.Localization.CalculusOfFractions.Preadditive","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁴ : CategoryTheory.Category.{u_4, u_1} C\ninst✝³ : CategoryTheory.Category.{u_3, u_2} D\ninst✝² : CategoryTheory.Preadditive C\nL : CategoryTheory.Functor C D\nW : CategoryTheory.MorphismProperty C\ninst✝¹ : L.IsLocalization W\ninst✝ : W.HasLeftCalculusOfFractions\nX Y : C\nf : Quiver.Hom (L.obj X) (L.obj Y)\n⊢ Eq (CategoryTheory.Localization.Preadditive.add' W (CategoryTheory.Localization.Preadditive.neg' W f) f) (L.map 0)","decl":"lemma neg'_add'_self (f : L.obj X ⟶ L.obj Y) :\n    add' W (neg' W f) f = L.map 0 := by\n  obtain ⟨α, rfl⟩ := exists_leftFraction L W f\n  have := inverts L W _ α.hs\n  rw [add'_eq W _ _ (LeftFraction₂.mk (-α.f) α.f α.s α.hs) (neg'_eq W _ _ rfl) rfl]\n  simp only [← cancel_mono (L.map α.s), LeftFraction.map_comp_map_s, ← L.map_comp,\n    Limits.zero_comp, neg_add_cancel]\n\n"}
{"name":"CategoryTheory.Localization.Preadditive.add'_assoc","module":"Mathlib.CategoryTheory.Localization.CalculusOfFractions.Preadditive","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁴ : CategoryTheory.Category.{u_4, u_1} C\ninst✝³ : CategoryTheory.Category.{u_3, u_2} D\ninst✝² : CategoryTheory.Preadditive C\nL : CategoryTheory.Functor C D\nW : CategoryTheory.MorphismProperty C\ninst✝¹ : L.IsLocalization W\ninst✝ : W.HasLeftCalculusOfFractions\nX Y : C\nf₁ f₂ f₃ : Quiver.Hom (L.obj X) (L.obj Y)\n⊢ Eq (CategoryTheory.Localization.Preadditive.add' W (CategoryTheory.Localization.Preadditive.add' W f₁ f₂) f₃) (CategoryTheory.Localization.Preadditive.add' W f₁ (CategoryTheory.Localization.Preadditive.add' W f₂ f₃))","decl":"lemma add'_assoc (f₁ f₂ f₃ : L.obj X ⟶ L.obj Y) :\n    add' W (add' W f₁ f₂) f₃ = add' W f₁ (add' W f₂ f₃) := by\n  obtain ⟨α, h₁, h₂, h₃⟩ := exists_leftFraction₃ L W f₁ f₂ f₃\n  rw [add'_eq W f₁ f₂ α.forgetThd h₁ h₂, add'_eq W f₂ f₃ α.forgetFst h₂ h₃,\n    add'_eq W _ _ (LeftFraction₂.mk (α.f + α.f') α.f'' α.s α.hs) rfl h₃,\n    add'_eq W _ _ (LeftFraction₂.mk α.f (α.f' + α.f'') α.s α.hs) h₁ rfl]\n  dsimp [LeftFraction₂.add]\n  rw [add_assoc]\n\n"}
{"name":"CategoryTheory.Localization.Preadditive.add'_comp_assoc","module":"Mathlib.CategoryTheory.Localization.CalculusOfFractions.Preadditive","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁴ : CategoryTheory.Category.{u_4, u_1} C\ninst✝³ : CategoryTheory.Category.{u_3, u_2} D\ninst✝² : CategoryTheory.Preadditive C\nL : CategoryTheory.Functor C D\nW : CategoryTheory.MorphismProperty C\ninst✝¹ : L.IsLocalization W\ninst✝ : W.HasLeftCalculusOfFractions\nX Y Z✝ : C\nf₁ f₂ : Quiver.Hom (L.obj X) (L.obj Y)\ng : Quiver.Hom (L.obj Y) (L.obj Z✝)\nZ : D\nh : Quiver.Hom (L.obj Z✝) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Localization.Preadditive.add' W f₁ f₂) (CategoryTheory.CategoryStruct.comp g h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Localization.Preadditive.add' W (CategoryTheory.CategoryStruct.comp f₁ g) (CategoryTheory.CategoryStruct.comp f₂ g)) h)","decl":"@[reassoc (attr := simp)]\nlemma add'_comp (f₁ f₂ : L.obj X ⟶ L.obj Y) (g : L.obj Y ⟶ L.obj Z) :\n    add' W f₁ f₂ ≫ g = add' W (f₁ ≫ g) (f₂ ≫ g) := by\n  obtain ⟨α, h₁, h₂⟩ := exists_leftFraction₂ L W f₁ f₂\n  obtain ⟨β, hβ⟩ := exists_leftFraction L W g\n  obtain ⟨γ, hγ⟩ := (RightFraction.mk _ α.hs β.f).exists_leftFraction\n  dsimp at hγ\n  rw [add'_eq W f₁ f₂ α h₁ h₂, add'_eq W (f₁ ≫ g) (f₂ ≫ g)\n    (LeftFraction₂.mk (α.f ≫ γ.f) (α.f' ≫ γ.f) (β.s ≫ γ.s)\n    (W.comp_mem _ _ β.hs γ.hs))]; rotate_left\n  · rw [h₁, hβ]\n    exact LeftFraction.map_comp_map_eq_map _ _ _ hγ _\n  · rw [h₂, hβ]\n    exact LeftFraction.map_comp_map_eq_map _ _ _ hγ _\n  rw [hβ, LeftFraction.map_comp_map_eq_map _ _ γ hγ]\n  dsimp [LeftFraction₂.add]\n  rw [add_comp]\n\n"}
{"name":"CategoryTheory.Localization.Preadditive.add'_comp","module":"Mathlib.CategoryTheory.Localization.CalculusOfFractions.Preadditive","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁴ : CategoryTheory.Category.{u_4, u_1} C\ninst✝³ : CategoryTheory.Category.{u_3, u_2} D\ninst✝² : CategoryTheory.Preadditive C\nL : CategoryTheory.Functor C D\nW : CategoryTheory.MorphismProperty C\ninst✝¹ : L.IsLocalization W\ninst✝ : W.HasLeftCalculusOfFractions\nX Y Z : C\nf₁ f₂ : Quiver.Hom (L.obj X) (L.obj Y)\ng : Quiver.Hom (L.obj Y) (L.obj Z)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Localization.Preadditive.add' W f₁ f₂) g) (CategoryTheory.Localization.Preadditive.add' W (CategoryTheory.CategoryStruct.comp f₁ g) (CategoryTheory.CategoryStruct.comp f₂ g))","decl":"@[reassoc (attr := simp)]\nlemma add'_comp (f₁ f₂ : L.obj X ⟶ L.obj Y) (g : L.obj Y ⟶ L.obj Z) :\n    add' W f₁ f₂ ≫ g = add' W (f₁ ≫ g) (f₂ ≫ g) := by\n  obtain ⟨α, h₁, h₂⟩ := exists_leftFraction₂ L W f₁ f₂\n  obtain ⟨β, hβ⟩ := exists_leftFraction L W g\n  obtain ⟨γ, hγ⟩ := (RightFraction.mk _ α.hs β.f).exists_leftFraction\n  dsimp at hγ\n  rw [add'_eq W f₁ f₂ α h₁ h₂, add'_eq W (f₁ ≫ g) (f₂ ≫ g)\n    (LeftFraction₂.mk (α.f ≫ γ.f) (α.f' ≫ γ.f) (β.s ≫ γ.s)\n    (W.comp_mem _ _ β.hs γ.hs))]; rotate_left\n  · rw [h₁, hβ]\n    exact LeftFraction.map_comp_map_eq_map _ _ _ hγ _\n  · rw [h₂, hβ]\n    exact LeftFraction.map_comp_map_eq_map _ _ _ hγ _\n  rw [hβ, LeftFraction.map_comp_map_eq_map _ _ γ hγ]\n  dsimp [LeftFraction₂.add]\n  rw [add_comp]\n\n"}
{"name":"CategoryTheory.Localization.Preadditive.comp_add'_assoc","module":"Mathlib.CategoryTheory.Localization.CalculusOfFractions.Preadditive","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁴ : CategoryTheory.Category.{u_4, u_1} C\ninst✝³ : CategoryTheory.Category.{u_3, u_2} D\ninst✝² : CategoryTheory.Preadditive C\nL : CategoryTheory.Functor C D\nW : CategoryTheory.MorphismProperty C\ninst✝¹ : L.IsLocalization W\ninst✝ : W.HasLeftCalculusOfFractions\nX Y Z✝ : C\nf : Quiver.Hom (L.obj X) (L.obj Y)\ng₁ g₂ : Quiver.Hom (L.obj Y) (L.obj Z✝)\nZ : D\nh : Quiver.Hom (L.obj Z✝) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp f (CategoryTheory.CategoryStruct.comp (CategoryTheory.Localization.Preadditive.add' W g₁ g₂) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Localization.Preadditive.add' W (CategoryTheory.CategoryStruct.comp f g₁) (CategoryTheory.CategoryStruct.comp f g₂)) h)","decl":"@[reassoc (attr := simp)]\nlemma comp_add' (f : L.obj X ⟶ L.obj Y) (g₁ g₂ : L.obj Y ⟶ L.obj Z) :\n    f ≫ add' W g₁ g₂ = add' W (f ≫ g₁) (f ≫ g₂) := by\n  obtain ⟨α, hα⟩ := exists_leftFraction L W f\n  obtain ⟨β, hβ₁, hβ₂⟩ := exists_leftFraction₂ L W g₁ g₂\n  obtain ⟨γ, hγ₁, hγ₂⟩ := (RightFraction₂.mk _ α.hs β.f β.f').exists_leftFraction₂\n  dsimp at hγ₁ hγ₂\n  rw [add'_eq W g₁ g₂ β hβ₁ hβ₂, add'_eq W (f ≫ g₁) (f ≫ g₂)\n    (LeftFraction₂.mk (α.f ≫ γ.f) (α.f ≫ γ.f') (β.s ≫ γ.s) (W.comp_mem _ _ β.hs γ.hs))\n    (by simpa only [hα, hβ₁] using LeftFraction.map_comp_map_eq_map α β.fst γ.fst hγ₁ L)\n    (by simpa only [hα, hβ₂] using LeftFraction.map_comp_map_eq_map α β.snd γ.snd hγ₂ L),\n    hα, LeftFraction.map_comp_map_eq_map α β.add γ.add\n      (by simp only [add_comp, hγ₁, hγ₂, comp_add])]\n  dsimp [LeftFraction₂.add]\n  rw [comp_add]\n\n"}
{"name":"CategoryTheory.Localization.Preadditive.comp_add'","module":"Mathlib.CategoryTheory.Localization.CalculusOfFractions.Preadditive","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁴ : CategoryTheory.Category.{u_4, u_1} C\ninst✝³ : CategoryTheory.Category.{u_3, u_2} D\ninst✝² : CategoryTheory.Preadditive C\nL : CategoryTheory.Functor C D\nW : CategoryTheory.MorphismProperty C\ninst✝¹ : L.IsLocalization W\ninst✝ : W.HasLeftCalculusOfFractions\nX Y Z : C\nf : Quiver.Hom (L.obj X) (L.obj Y)\ng₁ g₂ : Quiver.Hom (L.obj Y) (L.obj Z)\n⊢ Eq (CategoryTheory.CategoryStruct.comp f (CategoryTheory.Localization.Preadditive.add' W g₁ g₂)) (CategoryTheory.Localization.Preadditive.add' W (CategoryTheory.CategoryStruct.comp f g₁) (CategoryTheory.CategoryStruct.comp f g₂))","decl":"@[reassoc (attr := simp)]\nlemma comp_add' (f : L.obj X ⟶ L.obj Y) (g₁ g₂ : L.obj Y ⟶ L.obj Z) :\n    f ≫ add' W g₁ g₂ = add' W (f ≫ g₁) (f ≫ g₂) := by\n  obtain ⟨α, hα⟩ := exists_leftFraction L W f\n  obtain ⟨β, hβ₁, hβ₂⟩ := exists_leftFraction₂ L W g₁ g₂\n  obtain ⟨γ, hγ₁, hγ₂⟩ := (RightFraction₂.mk _ α.hs β.f β.f').exists_leftFraction₂\n  dsimp at hγ₁ hγ₂\n  rw [add'_eq W g₁ g₂ β hβ₁ hβ₂, add'_eq W (f ≫ g₁) (f ≫ g₂)\n    (LeftFraction₂.mk (α.f ≫ γ.f) (α.f ≫ γ.f') (β.s ≫ γ.s) (W.comp_mem _ _ β.hs γ.hs))\n    (by simpa only [hα, hβ₁] using LeftFraction.map_comp_map_eq_map α β.fst γ.fst hγ₁ L)\n    (by simpa only [hα, hβ₂] using LeftFraction.map_comp_map_eq_map α β.snd γ.snd hγ₂ L),\n    hα, LeftFraction.map_comp_map_eq_map α β.add γ.add\n      (by simp only [add_comp, hγ₁, hγ₂, comp_add])]\n  dsimp [LeftFraction₂.add]\n  rw [comp_add]\n\n"}
{"name":"CategoryTheory.Localization.Preadditive.add'_map","module":"Mathlib.CategoryTheory.Localization.CalculusOfFractions.Preadditive","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁴ : CategoryTheory.Category.{u_3, u_1} C\ninst✝³ : CategoryTheory.Category.{u_4, u_2} D\ninst✝² : CategoryTheory.Preadditive C\nL : CategoryTheory.Functor C D\nW : CategoryTheory.MorphismProperty C\ninst✝¹ : L.IsLocalization W\ninst✝ : W.HasLeftCalculusOfFractions\nX Y : C\nf₁ f₂ : Quiver.Hom X Y\n⊢ Eq (CategoryTheory.Localization.Preadditive.add' W (L.map f₁) (L.map f₂)) (L.map (HAdd.hAdd f₁ f₂))","decl":"@[simp]\nlemma add'_map (f₁ f₂ : X ⟶ Y) :\n    add' W (L.map f₁) (L.map f₂) = L.map (f₁ + f₂) :=\n  (add'_eq W (L.map f₁) (L.map f₂) (LeftFraction₂.mk f₁ f₂ (𝟙 _) (W.id_mem _))\n    (LeftFraction.map_ofHom _ _ _ _).symm (LeftFraction.map_ofHom _ _ _ _).symm).trans\n    (LeftFraction.map_ofHom _ _ _ _)\n\n"}
{"name":"CategoryTheory.Localization.Preadditive.homEquiv_apply","module":"Mathlib.CategoryTheory.Localization.CalculusOfFractions.Preadditive","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_3, u_1} C\ninst✝ : CategoryTheory.Category.{u_4, u_2} D\nL : CategoryTheory.Functor C D\nX Y : C\nX' Y' : D\neX : CategoryTheory.Iso (L.obj X) X'\neY : CategoryTheory.Iso (L.obj Y) Y'\nf : Quiver.Hom X' Y'\n⊢ Eq ((CategoryTheory.Localization.Preadditive.homEquiv eX eY) f) (CategoryTheory.CategoryStruct.comp eX.hom (CategoryTheory.CategoryStruct.comp f eY.inv))","decl":"/-- The bijection `(X' ⟶ Y') ≃ (L.obj X ⟶ L.obj Y)` induced by isomorphisms\n`eX : L.obj X ≅ X'` and `eY : L.obj Y ≅ Y'`. -/\n@[simps]\ndef homEquiv : (X' ⟶ Y') ≃ (L.obj X ⟶ L.obj Y) where\n  toFun f := eX.hom ≫ f ≫ eY.inv\n  invFun g := eX.inv ≫ g ≫ eY.hom\n  left_inv _ := by simp\n  right_inv _ := by simp\n\n"}
{"name":"CategoryTheory.Localization.Preadditive.homEquiv_symm_apply","module":"Mathlib.CategoryTheory.Localization.CalculusOfFractions.Preadditive","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_3, u_1} C\ninst✝ : CategoryTheory.Category.{u_4, u_2} D\nL : CategoryTheory.Functor C D\nX Y : C\nX' Y' : D\neX : CategoryTheory.Iso (L.obj X) X'\neY : CategoryTheory.Iso (L.obj Y) Y'\ng : Quiver.Hom (L.obj X) (L.obj Y)\n⊢ Eq ((CategoryTheory.Localization.Preadditive.homEquiv eX eY).symm g) (CategoryTheory.CategoryStruct.comp eX.inv (CategoryTheory.CategoryStruct.comp g eY.hom))","decl":"/-- The bijection `(X' ⟶ Y') ≃ (L.obj X ⟶ L.obj Y)` induced by isomorphisms\n`eX : L.obj X ≅ X'` and `eY : L.obj Y ≅ Y'`. -/\n@[simps]\ndef homEquiv : (X' ⟶ Y') ≃ (L.obj X ⟶ L.obj Y) where\n  toFun f := eX.hom ≫ f ≫ eY.inv\n  invFun g := eX.inv ≫ g ≫ eY.hom\n  left_inv _ := by simp\n  right_inv _ := by simp\n\n"}
{"name":"CategoryTheory.Localization.Preadditive.add_comp_assoc","module":"Mathlib.CategoryTheory.Localization.CalculusOfFractions.Preadditive","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁴ : CategoryTheory.Category.{u_4, u_1} C\ninst✝³ : CategoryTheory.Category.{u_3, u_2} D\ninst✝² : CategoryTheory.Preadditive C\nL : CategoryTheory.Functor C D\nW : CategoryTheory.MorphismProperty C\ninst✝¹ : L.IsLocalization W\ninst✝ : W.HasLeftCalculusOfFractions\nX Y Z✝ : C\nX' Y' Z' : D\neX : CategoryTheory.Iso (L.obj X) X'\neY : CategoryTheory.Iso (L.obj Y) Y'\neZ : CategoryTheory.Iso (L.obj Z✝) Z'\nf₁ f₂ : Quiver.Hom X' Y'\ng : Quiver.Hom Y' Z'\nZ : D\nh : Quiver.Hom Z' Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Localization.Preadditive.add W eX eY f₁ f₂) (CategoryTheory.CategoryStruct.comp g h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Localization.Preadditive.add W eX eZ (CategoryTheory.CategoryStruct.comp f₁ g) (CategoryTheory.CategoryStruct.comp f₂ g)) h)","decl":"@[reassoc]\nlemma add_comp (f₁ f₂ : X' ⟶ Y') (g : Y' ⟶ Z') :\n    add W eX eY f₁ f₂ ≫ g = add W eX eZ (f₁ ≫ g) (f₂ ≫ g) := by\n  obtain ⟨f₁, rfl⟩ := (homEquiv eX eY).symm.surjective f₁\n  obtain ⟨f₂, rfl⟩ := (homEquiv eX eY).symm.surjective f₂\n  obtain ⟨g, rfl⟩ := (homEquiv eY eZ).symm.surjective g\n  simp [add]\n\n"}
{"name":"CategoryTheory.Localization.Preadditive.add_comp","module":"Mathlib.CategoryTheory.Localization.CalculusOfFractions.Preadditive","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁴ : CategoryTheory.Category.{u_4, u_1} C\ninst✝³ : CategoryTheory.Category.{u_3, u_2} D\ninst✝² : CategoryTheory.Preadditive C\nL : CategoryTheory.Functor C D\nW : CategoryTheory.MorphismProperty C\ninst✝¹ : L.IsLocalization W\ninst✝ : W.HasLeftCalculusOfFractions\nX Y Z : C\nX' Y' Z' : D\neX : CategoryTheory.Iso (L.obj X) X'\neY : CategoryTheory.Iso (L.obj Y) Y'\neZ : CategoryTheory.Iso (L.obj Z) Z'\nf₁ f₂ : Quiver.Hom X' Y'\ng : Quiver.Hom Y' Z'\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Localization.Preadditive.add W eX eY f₁ f₂) g) (CategoryTheory.Localization.Preadditive.add W eX eZ (CategoryTheory.CategoryStruct.comp f₁ g) (CategoryTheory.CategoryStruct.comp f₂ g))","decl":"@[reassoc]\nlemma add_comp (f₁ f₂ : X' ⟶ Y') (g : Y' ⟶ Z') :\n    add W eX eY f₁ f₂ ≫ g = add W eX eZ (f₁ ≫ g) (f₂ ≫ g) := by\n  obtain ⟨f₁, rfl⟩ := (homEquiv eX eY).symm.surjective f₁\n  obtain ⟨f₂, rfl⟩ := (homEquiv eX eY).symm.surjective f₂\n  obtain ⟨g, rfl⟩ := (homEquiv eY eZ).symm.surjective g\n  simp [add]\n\n"}
{"name":"CategoryTheory.Localization.Preadditive.comp_add","module":"Mathlib.CategoryTheory.Localization.CalculusOfFractions.Preadditive","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁴ : CategoryTheory.Category.{u_4, u_1} C\ninst✝³ : CategoryTheory.Category.{u_3, u_2} D\ninst✝² : CategoryTheory.Preadditive C\nL : CategoryTheory.Functor C D\nW : CategoryTheory.MorphismProperty C\ninst✝¹ : L.IsLocalization W\ninst✝ : W.HasLeftCalculusOfFractions\nX Y Z : C\nX' Y' Z' : D\neX : CategoryTheory.Iso (L.obj X) X'\neY : CategoryTheory.Iso (L.obj Y) Y'\neZ : CategoryTheory.Iso (L.obj Z) Z'\nf : Quiver.Hom X' Y'\ng₁ g₂ : Quiver.Hom Y' Z'\n⊢ Eq (CategoryTheory.CategoryStruct.comp f (CategoryTheory.Localization.Preadditive.add W eY eZ g₁ g₂)) (CategoryTheory.Localization.Preadditive.add W eX eZ (CategoryTheory.CategoryStruct.comp f g₁) (CategoryTheory.CategoryStruct.comp f g₂))","decl":"@[reassoc]\nlemma comp_add (f : X' ⟶ Y') (g₁ g₂ : Y' ⟶ Z') :\n    f ≫ add W eY eZ g₁ g₂ = add W eX eZ (f ≫ g₁) (f ≫ g₂) := by\n  obtain ⟨f, rfl⟩ := (homEquiv eX eY).symm.surjective f\n  obtain ⟨g₁, rfl⟩ := (homEquiv eY eZ).symm.surjective g₁\n  obtain ⟨g₂, rfl⟩ := (homEquiv eY eZ).symm.surjective g₂\n  simp [add]\n\n"}
{"name":"CategoryTheory.Localization.Preadditive.comp_add_assoc","module":"Mathlib.CategoryTheory.Localization.CalculusOfFractions.Preadditive","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁴ : CategoryTheory.Category.{u_4, u_1} C\ninst✝³ : CategoryTheory.Category.{u_3, u_2} D\ninst✝² : CategoryTheory.Preadditive C\nL : CategoryTheory.Functor C D\nW : CategoryTheory.MorphismProperty C\ninst✝¹ : L.IsLocalization W\ninst✝ : W.HasLeftCalculusOfFractions\nX Y Z✝ : C\nX' Y' Z' : D\neX : CategoryTheory.Iso (L.obj X) X'\neY : CategoryTheory.Iso (L.obj Y) Y'\neZ : CategoryTheory.Iso (L.obj Z✝) Z'\nf : Quiver.Hom X' Y'\ng₁ g₂ : Quiver.Hom Y' Z'\nZ : D\nh : Quiver.Hom Z' Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp f (CategoryTheory.CategoryStruct.comp (CategoryTheory.Localization.Preadditive.add W eY eZ g₁ g₂) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Localization.Preadditive.add W eX eZ (CategoryTheory.CategoryStruct.comp f g₁) (CategoryTheory.CategoryStruct.comp f g₂)) h)","decl":"@[reassoc]\nlemma comp_add (f : X' ⟶ Y') (g₁ g₂ : Y' ⟶ Z') :\n    f ≫ add W eY eZ g₁ g₂ = add W eX eZ (f ≫ g₁) (f ≫ g₂) := by\n  obtain ⟨f, rfl⟩ := (homEquiv eX eY).symm.surjective f\n  obtain ⟨g₁, rfl⟩ := (homEquiv eY eZ).symm.surjective g₁\n  obtain ⟨g₂, rfl⟩ := (homEquiv eY eZ).symm.surjective g₂\n  simp [add]\n\n"}
{"name":"CategoryTheory.Localization.Preadditive.add_eq_add","module":"Mathlib.CategoryTheory.Localization.CalculusOfFractions.Preadditive","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁴ : CategoryTheory.Category.{u_4, u_1} C\ninst✝³ : CategoryTheory.Category.{u_3, u_2} D\ninst✝² : CategoryTheory.Preadditive C\nL : CategoryTheory.Functor C D\nW : CategoryTheory.MorphismProperty C\ninst✝¹ : L.IsLocalization W\ninst✝ : W.HasLeftCalculusOfFractions\nX Y : C\nX' Y' : D\neX : CategoryTheory.Iso (L.obj X) X'\neY : CategoryTheory.Iso (L.obj Y) Y'\nX'' Y'' : C\neX' : CategoryTheory.Iso (L.obj X'') X'\neY' : CategoryTheory.Iso (L.obj Y'') Y'\nf₁ f₂ : Quiver.Hom X' Y'\n⊢ Eq (CategoryTheory.Localization.Preadditive.add W eX eY f₁ f₂) (CategoryTheory.Localization.Preadditive.add W eX' eY' f₁ f₂)","decl":"lemma add_eq_add {X'' Y'' : C} (eX' : L.obj X'' ≅ X') (eY' : L.obj Y'' ≅ Y')\n    (f₁ f₂ : X' ⟶ Y') :\n    add W eX eY f₁ f₂ = add W eX' eY' f₁ f₂ := by\n  have h₁ := comp_add W eX' eX eY (𝟙 _) f₁ f₂\n  have h₂ := add_comp W eX' eY eY' f₁ f₂ (𝟙 _)\n  simp only [id_comp] at h₁\n  simp only [comp_id] at h₂\n  rw [h₁, h₂]\n\n"}
{"name":"CategoryTheory.Localization.Preadditive.add_eq","module":"Mathlib.CategoryTheory.Localization.CalculusOfFractions.Preadditive","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁴ : CategoryTheory.Category.{u_4, u_1} C\ninst✝³ : CategoryTheory.Category.{u_3, u_2} D\ninst✝² : CategoryTheory.Preadditive C\nL : CategoryTheory.Functor C D\nW : CategoryTheory.MorphismProperty C\ninst✝¹ : L.IsLocalization W\ninst✝ : W.HasLeftCalculusOfFractions\nX Y : C\nX' Y' : D\neX : CategoryTheory.Iso (L.obj X) X'\neY : CategoryTheory.Iso (L.obj Y) Y'\nf₁ f₂ : Quiver.Hom X' Y'\n⊢ Eq (HAdd.hAdd f₁ f₂) (CategoryTheory.Localization.Preadditive.add W eX eY f₁ f₂)","decl":"lemma add_eq (f₁ f₂ : X' ⟶ Y') :\n    letI := addCommGroup L W X' Y'\n    f₁ + f₂ = add W eX eY f₁ f₂ := by\n  apply add_eq_add\n\n"}
{"name":"CategoryTheory.Localization.Preadditive.map_add","module":"Mathlib.CategoryTheory.Localization.CalculusOfFractions.Preadditive","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁴ : CategoryTheory.Category.{u_3, u_1} C\ninst✝³ : CategoryTheory.Category.{u_4, u_2} D\ninst✝² : CategoryTheory.Preadditive C\nL : CategoryTheory.Functor C D\nW : CategoryTheory.MorphismProperty C\ninst✝¹ : L.IsLocalization W\ninst✝ : W.HasLeftCalculusOfFractions\nX Y : C\nf₁ f₂ : Quiver.Hom X Y\n⊢ Eq (L.map (HAdd.hAdd f₁ f₂)) (HAdd.hAdd (L.map f₁) (L.map f₂))","decl":"lemma map_add (f₁ f₂ : X ⟶ Y) :\n    letI := addCommGroup L W (L.obj X) (L.obj Y)\n    L.map (f₁ + f₂) = L.map f₁ + L.map f₂ := by\n  rw [add_eq W (Iso.refl _) (Iso.refl _) (L.map f₁) (L.map f₂)]\n  simp [add]\n\n"}
{"name":"CategoryTheory.Localization.functor_additive","module":"Mathlib.CategoryTheory.Localization.CalculusOfFractions.Preadditive","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁴ : CategoryTheory.Category.{u_3, u_1} C\ninst✝³ : CategoryTheory.Category.{u_4, u_2} D\ninst✝² : CategoryTheory.Preadditive C\nL : CategoryTheory.Functor C D\nW : CategoryTheory.MorphismProperty C\ninst✝¹ : L.IsLocalization W\ninst✝ : W.HasLeftCalculusOfFractions\n⊢ L.Additive","decl":"lemma functor_additive :\n    letI := preadditive L W\n    L.Additive :=\n  letI := preadditive L W\n  ⟨by apply Preadditive.map_add⟩\n\n"}
{"name":"CategoryTheory.Localization.functor_additive_iff","module":"Mathlib.CategoryTheory.Localization.CalculusOfFractions.Preadditive","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁸ : CategoryTheory.Category.{u_6, u_1} C\ninst✝⁷ : CategoryTheory.Category.{u_5, u_2} D\ninst✝⁶ : CategoryTheory.Preadditive C\nL : CategoryTheory.Functor C D\nW : CategoryTheory.MorphismProperty C\ninst✝⁵ : L.IsLocalization W\ninst✝⁴ : W.HasLeftCalculusOfFractions\nE : Type u_3\ninst✝³ : CategoryTheory.Category.{u_4, u_3} E\ninst✝² : CategoryTheory.Preadditive E\ninst✝¹ : CategoryTheory.Preadditive D\ninst✝ : L.Additive\nG : CategoryTheory.Functor D E\n⊢ Iff G.Additive (L.comp G).Additive","decl":"include W in\nlemma functor_additive_iff {E : Type*} [Category E] [Preadditive E] [Preadditive D] [L.Additive]\n    (G : D ⥤ E) :\n    G.Additive ↔ (L ⋙ G).Additive := by\n  constructor\n  · intro\n    infer_instance\n  · intro h\n    suffices ∀ ⦃X Y : C⦄ (f g : L.obj X ⟶ L.obj Y), G.map (f + g) = G.map f + G.map g by\n      refine ⟨fun {X Y f g} => ?_⟩\n      have hL := essSurj L W\n      have eq := this ((L.objObjPreimageIso X).hom ≫ f ≫ (L.objObjPreimageIso Y).inv)\n        ((L.objObjPreimageIso X).hom ≫ g ≫ (L.objObjPreimageIso Y).inv)\n      rw [Functor.map_comp, Functor.map_comp, Functor.map_comp, Functor.map_comp,\n        ← comp_add, ← comp_add, ← add_comp, ← add_comp, Functor.map_comp, Functor.map_comp] at eq\n      rw [← cancel_mono (G.map (L.objObjPreimageIso Y).inv),\n        ← cancel_epi (G.map (L.objObjPreimageIso X).hom), eq]\n    intros X Y f g\n    obtain ⟨φ, rfl, rfl⟩ := exists_leftFraction₂ L W f g\n    have := Localization.inverts L W φ.s φ.hs\n    rw [← φ.map_add L (inverts L W), ← cancel_mono (G.map (L.map φ.s)), ← G.map_comp,\n      add_comp, ← G.map_comp, ← G.map_comp, LeftFraction.map_comp_map_s,\n      LeftFraction.map_comp_map_s, LeftFraction.map_comp_map_s, ← Functor.comp_map,\n      Functor.map_add, Functor.comp_map, Functor.comp_map]\n\n"}
{"name":"CategoryTheory.Localization.instAdditiveLocalizationQ","module":"Mathlib.CategoryTheory.Localization.CalculusOfFractions.Preadditive","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\nW : CategoryTheory.MorphismProperty C\ninst✝ : W.HasLeftCalculusOfFractions\n⊢ W.Q.Additive","decl":"instance : W.Q.Additive := functor_additive W.Q W\n"}
{"name":"CategoryTheory.Localization.instHasZeroObjectLocalization","module":"Mathlib.CategoryTheory.Localization.CalculusOfFractions.Preadditive","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_3, u_1} C\ninst✝² : CategoryTheory.Preadditive C\nW : CategoryTheory.MorphismProperty C\ninst✝¹ : W.HasLeftCalculusOfFractions\ninst✝ : CategoryTheory.Limits.HasZeroObject C\n⊢ CategoryTheory.Limits.HasZeroObject W.Localization","decl":"instance [HasZeroObject C] : HasZeroObject W.Localization := W.Q.hasZeroObject_of_additive\n\n"}
{"name":"CategoryTheory.Localization.instAdditiveLocalization'Q'","module":"Mathlib.CategoryTheory.Localization.CalculusOfFractions.Preadditive","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_3, u_1} C\ninst✝² : CategoryTheory.Preadditive C\nW : CategoryTheory.MorphismProperty C\ninst✝¹ : W.HasLeftCalculusOfFractions\ninst✝ : W.HasLocalization\n⊢ W.Q'.Additive","decl":"instance : W.Q'.Additive := functor_additive W.Q' W\n"}
{"name":"CategoryTheory.Localization.instHasZeroObjectLocalization'","module":"Mathlib.CategoryTheory.Localization.CalculusOfFractions.Preadditive","initialProofState":"C : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_3, u_1} C\ninst✝³ : CategoryTheory.Preadditive C\nW : CategoryTheory.MorphismProperty C\ninst✝² : W.HasLeftCalculusOfFractions\ninst✝¹ : W.HasLocalization\ninst✝ : CategoryTheory.Limits.HasZeroObject C\n⊢ CategoryTheory.Limits.HasZeroObject W.Localization'","decl":"instance [HasZeroObject C] : HasZeroObject W.Localization' := W.Q'.hasZeroObject_of_additive\n\n"}
