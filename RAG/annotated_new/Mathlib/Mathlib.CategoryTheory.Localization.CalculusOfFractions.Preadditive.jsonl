{"name":"CategoryTheory.MorphismProperty.LeftFractionâ‚‚.symm_add","module":"Mathlib.CategoryTheory.Localization.CalculusOfFractions.Preadditive","initialProofState":"C : Type u_1\ninstâœÂ¹ : CategoryTheory.Category.{u_3, u_1} C\ninstâœ : CategoryTheory.Preadditive C\nW : CategoryTheory.MorphismProperty C\nX Y : C\nÏ† : W.LeftFractionâ‚‚ X Y\nâŠ¢ Eq Ï†.symm.add Ï†.add","decl":"@[simp]\nlemma symm_add : Ï†.symm.add = Ï†.add := by\n  dsimp [add, symm]\n  congr 1\n  apply add_comm\n\n"}
{"name":"CategoryTheory.MorphismProperty.LeftFractionâ‚‚.map_add","module":"Mathlib.CategoryTheory.Localization.CalculusOfFractions.Preadditive","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœâ´ : CategoryTheory.Category.{u_3, u_1} C\ninstâœÂ³ : CategoryTheory.Category.{u_4, u_2} D\ninstâœÂ² : CategoryTheory.Preadditive C\nW : CategoryTheory.MorphismProperty C\nX Y : C\nÏ† : W.LeftFractionâ‚‚ X Y\nF : CategoryTheory.Functor C D\nhF : W.IsInvertedBy F\ninstâœÂ¹ : CategoryTheory.Preadditive D\ninstâœ : F.Additive\nâŠ¢ Eq (Ï†.add.map F hF) (HAdd.hAdd (Ï†.fst.map F hF) (Ï†.snd.map F hF))","decl":"@[simp]\nlemma map_add (F : C â¥¤ D) (hF : W.IsInvertedBy F) [Preadditive D] [F.Additive] :\n    Ï†.add.map F hF = Ï†.fst.map F hF + Ï†.snd.map F hF := by\n  have := hF Ï†.s Ï†.hs\n  rw [â† cancel_mono (F.map Ï†.s), add_comp, LeftFraction.map_comp_map_s,\n    LeftFraction.map_comp_map_s, LeftFraction.map_comp_map_s, F.map_add]\n\n"}
{"name":"CategoryTheory.Localization.Preadditive.neg'_eq","module":"Mathlib.CategoryTheory.Localization.CalculusOfFractions.Preadditive","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœâ´ : CategoryTheory.Category.{u_4, u_1} C\ninstâœÂ³ : CategoryTheory.Category.{u_3, u_2} D\ninstâœÂ² : CategoryTheory.Preadditive C\nL : CategoryTheory.Functor C D\nW : CategoryTheory.MorphismProperty C\ninstâœÂ¹ : L.IsLocalization W\ninstâœ : W.HasLeftCalculusOfFractions\nX Y : C\nf : Quiver.Hom (L.obj X) (L.obj Y)\nÏ† : W.LeftFraction X Y\nhÏ† : Eq f (Ï†.map L â‹¯)\nâŠ¢ Eq (CategoryTheory.Localization.Preadditive.neg' W f) (Ï†.neg.map L â‹¯)","decl":"lemma neg'_eq (f : L.obj X âŸ¶ L.obj Y) (Ï† : W.LeftFraction X Y)\n    (hÏ† : f = Ï†.map L (inverts L W)) :\n    neg' W f = Ï†.neg.map L (inverts L W) := by\n  obtain âŸ¨Ï†â‚€, rfl, hÏ†â‚€âŸ© : âˆƒ (Ï†â‚€ : W.LeftFraction X Y)\n    (_ : f = Ï†â‚€.map L (inverts L W)),\n      neg' W f = Ï†â‚€.neg.map L (inverts L W) :=\n    âŸ¨_, (exists_leftFraction L W f).choose_spec, rflâŸ©\n  rw [MorphismProperty.LeftFraction.map_eq_iff] at hÏ†\n  obtain âŸ¨Y', tâ‚, tâ‚‚, hst, hft, htâŸ© := hÏ†\n  have := inverts L W _ ht\n  rw [â† cancel_mono (L.map (Ï†â‚€.s â‰« tâ‚))]\n  nth_rw 1 [L.map_comp]\n  rw [hÏ†â‚€, hst, LeftFraction.map_comp_map_s_assoc, L.map_comp,\n    LeftFraction.map_comp_map_s_assoc, â† L.map_comp, â† L.map_comp,\n    neg_comp, neg_comp, hft]\n\n"}
{"name":"CategoryTheory.Localization.Preadditive.add'_eq","module":"Mathlib.CategoryTheory.Localization.CalculusOfFractions.Preadditive","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœâ´ : CategoryTheory.Category.{u_4, u_1} C\ninstâœÂ³ : CategoryTheory.Category.{u_3, u_2} D\ninstâœÂ² : CategoryTheory.Preadditive C\nL : CategoryTheory.Functor C D\nW : CategoryTheory.MorphismProperty C\ninstâœÂ¹ : L.IsLocalization W\ninstâœ : W.HasLeftCalculusOfFractions\nX Y : C\nfâ‚ fâ‚‚ : Quiver.Hom (L.obj X) (L.obj Y)\nÏ† : W.LeftFractionâ‚‚ X Y\nhÏ†â‚ : Eq fâ‚ (Ï†.fst.map L â‹¯)\nhÏ†â‚‚ : Eq fâ‚‚ (Ï†.snd.map L â‹¯)\nâŠ¢ Eq (CategoryTheory.Localization.Preadditive.add' W fâ‚ fâ‚‚) (Ï†.add.map L â‹¯)","decl":"lemma add'_eq (fâ‚ fâ‚‚ : L.obj X âŸ¶ L.obj Y) (Ï† : W.LeftFractionâ‚‚ X Y)\n    (hÏ†â‚ : fâ‚ = Ï†.fst.map L (inverts L W))\n    (hÏ†â‚‚ : fâ‚‚ = Ï†.snd.map L (inverts L W)) :\n    add' W fâ‚ fâ‚‚ = Ï†.add.map L (inverts L W) := by\n  obtain âŸ¨Ï†â‚€, rfl, rfl, hÏ†â‚€âŸ© : âˆƒ (Ï†â‚€ : W.LeftFractionâ‚‚ X Y)\n    (_ : fâ‚ = Ï†â‚€.fst.map L (inverts L W))\n    (_ : fâ‚‚ = Ï†â‚€.snd.map L (inverts L W)),\n    add' W fâ‚ fâ‚‚ = Ï†â‚€.add.map L (inverts L W) :=\n    âŸ¨(exists_leftFractionâ‚‚ L W fâ‚ fâ‚‚).choose,\n      (exists_leftFractionâ‚‚ L W fâ‚ fâ‚‚).choose_spec.1,\n      (exists_leftFractionâ‚‚ L W fâ‚ fâ‚‚).choose_spec.2, rflâŸ©\n  obtain âŸ¨Z, tâ‚, tâ‚‚, hst, hft, hft', htâŸ© := (LeftFractionâ‚‚.map_eq_iff L W Ï†â‚€ Ï†).1 âŸ¨hÏ†â‚, hÏ†â‚‚âŸ©\n  have := inverts L W _ ht\n  rw [hÏ†â‚€, â† cancel_mono (L.map (Ï†â‚€.s â‰« tâ‚))]\n  nth_rw 2 [hst]\n  rw [L.map_comp, L.map_comp, LeftFraction.map_comp_map_s_assoc,\n    LeftFraction.map_comp_map_s_assoc, â† L.map_comp, â† L.map_comp,\n    add_comp, add_comp, hft, hft']\n\n"}
{"name":"CategoryTheory.Localization.Preadditive.add'_comm","module":"Mathlib.CategoryTheory.Localization.CalculusOfFractions.Preadditive","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœâ´ : CategoryTheory.Category.{u_4, u_1} C\ninstâœÂ³ : CategoryTheory.Category.{u_3, u_2} D\ninstâœÂ² : CategoryTheory.Preadditive C\nL : CategoryTheory.Functor C D\nW : CategoryTheory.MorphismProperty C\ninstâœÂ¹ : L.IsLocalization W\ninstâœ : W.HasLeftCalculusOfFractions\nX Y : C\nfâ‚ fâ‚‚ : Quiver.Hom (L.obj X) (L.obj Y)\nâŠ¢ Eq (CategoryTheory.Localization.Preadditive.add' W fâ‚ fâ‚‚) (CategoryTheory.Localization.Preadditive.add' W fâ‚‚ fâ‚)","decl":"lemma add'_comm (fâ‚ fâ‚‚ : L.obj X âŸ¶ L.obj Y) :\n    add' W fâ‚ fâ‚‚ = add' W fâ‚‚ fâ‚ := by\n  obtain âŸ¨Î±, hâ‚, hâ‚‚âŸ© := exists_leftFractionâ‚‚ L W fâ‚ fâ‚‚\n  rw [add'_eq W fâ‚ fâ‚‚ Î± hâ‚ hâ‚‚, add'_eq W fâ‚‚ fâ‚ Î±.symm hâ‚‚ hâ‚, Î±.symm_add]\n\n"}
{"name":"CategoryTheory.Localization.Preadditive.add'_zero","module":"Mathlib.CategoryTheory.Localization.CalculusOfFractions.Preadditive","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœâ´ : CategoryTheory.Category.{u_4, u_1} C\ninstâœÂ³ : CategoryTheory.Category.{u_3, u_2} D\ninstâœÂ² : CategoryTheory.Preadditive C\nL : CategoryTheory.Functor C D\nW : CategoryTheory.MorphismProperty C\ninstâœÂ¹ : L.IsLocalization W\ninstâœ : W.HasLeftCalculusOfFractions\nX Y : C\nf : Quiver.Hom (L.obj X) (L.obj Y)\nâŠ¢ Eq (CategoryTheory.Localization.Preadditive.add' W f (L.map 0)) f","decl":"lemma add'_zero (f : L.obj X âŸ¶ L.obj Y) :\n    add' W f (L.map 0) = f := by\n  obtain âŸ¨Î±, hÎ±âŸ© := exists_leftFraction L W f\n  rw [add'_eq W f (L.map 0) (LeftFractionâ‚‚.mk Î±.f 0 Î±.s Î±.hs) hÎ±, hÎ±]; swap\n  Â· have := inverts L W _ Î±.hs\n    rw [â† cancel_mono (L.map Î±.s), â† L.map_comp, Limits.zero_comp,\n      LeftFraction.map_comp_map_s]\n  dsimp [LeftFractionâ‚‚.add]\n  rw [add_zero]\n\n"}
{"name":"CategoryTheory.Localization.Preadditive.zero_add'","module":"Mathlib.CategoryTheory.Localization.CalculusOfFractions.Preadditive","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœâ´ : CategoryTheory.Category.{u_4, u_1} C\ninstâœÂ³ : CategoryTheory.Category.{u_3, u_2} D\ninstâœÂ² : CategoryTheory.Preadditive C\nL : CategoryTheory.Functor C D\nW : CategoryTheory.MorphismProperty C\ninstâœÂ¹ : L.IsLocalization W\ninstâœ : W.HasLeftCalculusOfFractions\nX Y : C\nf : Quiver.Hom (L.obj X) (L.obj Y)\nâŠ¢ Eq (CategoryTheory.Localization.Preadditive.add' W (L.map 0) f) f","decl":"lemma zero_add' (f : L.obj X âŸ¶ L.obj Y) :\n    add' W (L.map 0) f = f := by\n  rw [add'_comm, add'_zero]\n\n"}
{"name":"CategoryTheory.Localization.Preadditive.neg'_add'_self","module":"Mathlib.CategoryTheory.Localization.CalculusOfFractions.Preadditive","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœâ´ : CategoryTheory.Category.{u_4, u_1} C\ninstâœÂ³ : CategoryTheory.Category.{u_3, u_2} D\ninstâœÂ² : CategoryTheory.Preadditive C\nL : CategoryTheory.Functor C D\nW : CategoryTheory.MorphismProperty C\ninstâœÂ¹ : L.IsLocalization W\ninstâœ : W.HasLeftCalculusOfFractions\nX Y : C\nf : Quiver.Hom (L.obj X) (L.obj Y)\nâŠ¢ Eq (CategoryTheory.Localization.Preadditive.add' W (CategoryTheory.Localization.Preadditive.neg' W f) f) (L.map 0)","decl":"lemma neg'_add'_self (f : L.obj X âŸ¶ L.obj Y) :\n    add' W (neg' W f) f = L.map 0 := by\n  obtain âŸ¨Î±, rflâŸ© := exists_leftFraction L W f\n  have := inverts L W _ Î±.hs\n  rw [add'_eq W _ _ (LeftFractionâ‚‚.mk (-Î±.f) Î±.f Î±.s Î±.hs) (neg'_eq W _ _ rfl) rfl]\n  simp only [â† cancel_mono (L.map Î±.s), LeftFraction.map_comp_map_s, â† L.map_comp,\n    Limits.zero_comp, neg_add_cancel]\n\n"}
{"name":"CategoryTheory.Localization.Preadditive.add'_assoc","module":"Mathlib.CategoryTheory.Localization.CalculusOfFractions.Preadditive","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœâ´ : CategoryTheory.Category.{u_4, u_1} C\ninstâœÂ³ : CategoryTheory.Category.{u_3, u_2} D\ninstâœÂ² : CategoryTheory.Preadditive C\nL : CategoryTheory.Functor C D\nW : CategoryTheory.MorphismProperty C\ninstâœÂ¹ : L.IsLocalization W\ninstâœ : W.HasLeftCalculusOfFractions\nX Y : C\nfâ‚ fâ‚‚ fâ‚ƒ : Quiver.Hom (L.obj X) (L.obj Y)\nâŠ¢ Eq (CategoryTheory.Localization.Preadditive.add' W (CategoryTheory.Localization.Preadditive.add' W fâ‚ fâ‚‚) fâ‚ƒ) (CategoryTheory.Localization.Preadditive.add' W fâ‚ (CategoryTheory.Localization.Preadditive.add' W fâ‚‚ fâ‚ƒ))","decl":"lemma add'_assoc (fâ‚ fâ‚‚ fâ‚ƒ : L.obj X âŸ¶ L.obj Y) :\n    add' W (add' W fâ‚ fâ‚‚) fâ‚ƒ = add' W fâ‚ (add' W fâ‚‚ fâ‚ƒ) := by\n  obtain âŸ¨Î±, hâ‚, hâ‚‚, hâ‚ƒâŸ© := exists_leftFractionâ‚ƒ L W fâ‚ fâ‚‚ fâ‚ƒ\n  rw [add'_eq W fâ‚ fâ‚‚ Î±.forgetThd hâ‚ hâ‚‚, add'_eq W fâ‚‚ fâ‚ƒ Î±.forgetFst hâ‚‚ hâ‚ƒ,\n    add'_eq W _ _ (LeftFractionâ‚‚.mk (Î±.f + Î±.f') Î±.f'' Î±.s Î±.hs) rfl hâ‚ƒ,\n    add'_eq W _ _ (LeftFractionâ‚‚.mk Î±.f (Î±.f' + Î±.f'') Î±.s Î±.hs) hâ‚ rfl]\n  dsimp [LeftFractionâ‚‚.add]\n  rw [add_assoc]\n\n"}
{"name":"CategoryTheory.Localization.Preadditive.add'_comp_assoc","module":"Mathlib.CategoryTheory.Localization.CalculusOfFractions.Preadditive","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœâ´ : CategoryTheory.Category.{u_4, u_1} C\ninstâœÂ³ : CategoryTheory.Category.{u_3, u_2} D\ninstâœÂ² : CategoryTheory.Preadditive C\nL : CategoryTheory.Functor C D\nW : CategoryTheory.MorphismProperty C\ninstâœÂ¹ : L.IsLocalization W\ninstâœ : W.HasLeftCalculusOfFractions\nX Y Zâœ : C\nfâ‚ fâ‚‚ : Quiver.Hom (L.obj X) (L.obj Y)\ng : Quiver.Hom (L.obj Y) (L.obj Zâœ)\nZ : D\nh : Quiver.Hom (L.obj Zâœ) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Localization.Preadditive.add' W fâ‚ fâ‚‚) (CategoryTheory.CategoryStruct.comp g h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Localization.Preadditive.add' W (CategoryTheory.CategoryStruct.comp fâ‚ g) (CategoryTheory.CategoryStruct.comp fâ‚‚ g)) h)","decl":"@[reassoc (attr := simp)]\nlemma add'_comp (fâ‚ fâ‚‚ : L.obj X âŸ¶ L.obj Y) (g : L.obj Y âŸ¶ L.obj Z) :\n    add' W fâ‚ fâ‚‚ â‰« g = add' W (fâ‚ â‰« g) (fâ‚‚ â‰« g) := by\n  obtain âŸ¨Î±, hâ‚, hâ‚‚âŸ© := exists_leftFractionâ‚‚ L W fâ‚ fâ‚‚\n  obtain âŸ¨Î², hÎ²âŸ© := exists_leftFraction L W g\n  obtain âŸ¨Î³, hÎ³âŸ© := (RightFraction.mk _ Î±.hs Î².f).exists_leftFraction\n  dsimp at hÎ³\n  rw [add'_eq W fâ‚ fâ‚‚ Î± hâ‚ hâ‚‚, add'_eq W (fâ‚ â‰« g) (fâ‚‚ â‰« g)\n    (LeftFractionâ‚‚.mk (Î±.f â‰« Î³.f) (Î±.f' â‰« Î³.f) (Î².s â‰« Î³.s)\n    (W.comp_mem _ _ Î².hs Î³.hs))]; rotate_left\n  Â· rw [hâ‚, hÎ²]\n    exact LeftFraction.map_comp_map_eq_map _ _ _ hÎ³ _\n  Â· rw [hâ‚‚, hÎ²]\n    exact LeftFraction.map_comp_map_eq_map _ _ _ hÎ³ _\n  rw [hÎ², LeftFraction.map_comp_map_eq_map _ _ Î³ hÎ³]\n  dsimp [LeftFractionâ‚‚.add]\n  rw [add_comp]\n\n"}
{"name":"CategoryTheory.Localization.Preadditive.add'_comp","module":"Mathlib.CategoryTheory.Localization.CalculusOfFractions.Preadditive","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœâ´ : CategoryTheory.Category.{u_4, u_1} C\ninstâœÂ³ : CategoryTheory.Category.{u_3, u_2} D\ninstâœÂ² : CategoryTheory.Preadditive C\nL : CategoryTheory.Functor C D\nW : CategoryTheory.MorphismProperty C\ninstâœÂ¹ : L.IsLocalization W\ninstâœ : W.HasLeftCalculusOfFractions\nX Y Z : C\nfâ‚ fâ‚‚ : Quiver.Hom (L.obj X) (L.obj Y)\ng : Quiver.Hom (L.obj Y) (L.obj Z)\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Localization.Preadditive.add' W fâ‚ fâ‚‚) g) (CategoryTheory.Localization.Preadditive.add' W (CategoryTheory.CategoryStruct.comp fâ‚ g) (CategoryTheory.CategoryStruct.comp fâ‚‚ g))","decl":"@[reassoc (attr := simp)]\nlemma add'_comp (fâ‚ fâ‚‚ : L.obj X âŸ¶ L.obj Y) (g : L.obj Y âŸ¶ L.obj Z) :\n    add' W fâ‚ fâ‚‚ â‰« g = add' W (fâ‚ â‰« g) (fâ‚‚ â‰« g) := by\n  obtain âŸ¨Î±, hâ‚, hâ‚‚âŸ© := exists_leftFractionâ‚‚ L W fâ‚ fâ‚‚\n  obtain âŸ¨Î², hÎ²âŸ© := exists_leftFraction L W g\n  obtain âŸ¨Î³, hÎ³âŸ© := (RightFraction.mk _ Î±.hs Î².f).exists_leftFraction\n  dsimp at hÎ³\n  rw [add'_eq W fâ‚ fâ‚‚ Î± hâ‚ hâ‚‚, add'_eq W (fâ‚ â‰« g) (fâ‚‚ â‰« g)\n    (LeftFractionâ‚‚.mk (Î±.f â‰« Î³.f) (Î±.f' â‰« Î³.f) (Î².s â‰« Î³.s)\n    (W.comp_mem _ _ Î².hs Î³.hs))]; rotate_left\n  Â· rw [hâ‚, hÎ²]\n    exact LeftFraction.map_comp_map_eq_map _ _ _ hÎ³ _\n  Â· rw [hâ‚‚, hÎ²]\n    exact LeftFraction.map_comp_map_eq_map _ _ _ hÎ³ _\n  rw [hÎ², LeftFraction.map_comp_map_eq_map _ _ Î³ hÎ³]\n  dsimp [LeftFractionâ‚‚.add]\n  rw [add_comp]\n\n"}
{"name":"CategoryTheory.Localization.Preadditive.comp_add'_assoc","module":"Mathlib.CategoryTheory.Localization.CalculusOfFractions.Preadditive","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœâ´ : CategoryTheory.Category.{u_4, u_1} C\ninstâœÂ³ : CategoryTheory.Category.{u_3, u_2} D\ninstâœÂ² : CategoryTheory.Preadditive C\nL : CategoryTheory.Functor C D\nW : CategoryTheory.MorphismProperty C\ninstâœÂ¹ : L.IsLocalization W\ninstâœ : W.HasLeftCalculusOfFractions\nX Y Zâœ : C\nf : Quiver.Hom (L.obj X) (L.obj Y)\ngâ‚ gâ‚‚ : Quiver.Hom (L.obj Y) (L.obj Zâœ)\nZ : D\nh : Quiver.Hom (L.obj Zâœ) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp f (CategoryTheory.CategoryStruct.comp (CategoryTheory.Localization.Preadditive.add' W gâ‚ gâ‚‚) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Localization.Preadditive.add' W (CategoryTheory.CategoryStruct.comp f gâ‚) (CategoryTheory.CategoryStruct.comp f gâ‚‚)) h)","decl":"@[reassoc (attr := simp)]\nlemma comp_add' (f : L.obj X âŸ¶ L.obj Y) (gâ‚ gâ‚‚ : L.obj Y âŸ¶ L.obj Z) :\n    f â‰« add' W gâ‚ gâ‚‚ = add' W (f â‰« gâ‚) (f â‰« gâ‚‚) := by\n  obtain âŸ¨Î±, hÎ±âŸ© := exists_leftFraction L W f\n  obtain âŸ¨Î², hÎ²â‚, hÎ²â‚‚âŸ© := exists_leftFractionâ‚‚ L W gâ‚ gâ‚‚\n  obtain âŸ¨Î³, hÎ³â‚, hÎ³â‚‚âŸ© := (RightFractionâ‚‚.mk _ Î±.hs Î².f Î².f').exists_leftFractionâ‚‚\n  dsimp at hÎ³â‚ hÎ³â‚‚\n  rw [add'_eq W gâ‚ gâ‚‚ Î² hÎ²â‚ hÎ²â‚‚, add'_eq W (f â‰« gâ‚) (f â‰« gâ‚‚)\n    (LeftFractionâ‚‚.mk (Î±.f â‰« Î³.f) (Î±.f â‰« Î³.f') (Î².s â‰« Î³.s) (W.comp_mem _ _ Î².hs Î³.hs))\n    (by simpa only [hÎ±, hÎ²â‚] using LeftFraction.map_comp_map_eq_map Î± Î².fst Î³.fst hÎ³â‚ L)\n    (by simpa only [hÎ±, hÎ²â‚‚] using LeftFraction.map_comp_map_eq_map Î± Î².snd Î³.snd hÎ³â‚‚ L),\n    hÎ±, LeftFraction.map_comp_map_eq_map Î± Î².add Î³.add\n      (by simp only [add_comp, hÎ³â‚, hÎ³â‚‚, comp_add])]\n  dsimp [LeftFractionâ‚‚.add]\n  rw [comp_add]\n\n"}
{"name":"CategoryTheory.Localization.Preadditive.comp_add'","module":"Mathlib.CategoryTheory.Localization.CalculusOfFractions.Preadditive","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœâ´ : CategoryTheory.Category.{u_4, u_1} C\ninstâœÂ³ : CategoryTheory.Category.{u_3, u_2} D\ninstâœÂ² : CategoryTheory.Preadditive C\nL : CategoryTheory.Functor C D\nW : CategoryTheory.MorphismProperty C\ninstâœÂ¹ : L.IsLocalization W\ninstâœ : W.HasLeftCalculusOfFractions\nX Y Z : C\nf : Quiver.Hom (L.obj X) (L.obj Y)\ngâ‚ gâ‚‚ : Quiver.Hom (L.obj Y) (L.obj Z)\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp f (CategoryTheory.Localization.Preadditive.add' W gâ‚ gâ‚‚)) (CategoryTheory.Localization.Preadditive.add' W (CategoryTheory.CategoryStruct.comp f gâ‚) (CategoryTheory.CategoryStruct.comp f gâ‚‚))","decl":"@[reassoc (attr := simp)]\nlemma comp_add' (f : L.obj X âŸ¶ L.obj Y) (gâ‚ gâ‚‚ : L.obj Y âŸ¶ L.obj Z) :\n    f â‰« add' W gâ‚ gâ‚‚ = add' W (f â‰« gâ‚) (f â‰« gâ‚‚) := by\n  obtain âŸ¨Î±, hÎ±âŸ© := exists_leftFraction L W f\n  obtain âŸ¨Î², hÎ²â‚, hÎ²â‚‚âŸ© := exists_leftFractionâ‚‚ L W gâ‚ gâ‚‚\n  obtain âŸ¨Î³, hÎ³â‚, hÎ³â‚‚âŸ© := (RightFractionâ‚‚.mk _ Î±.hs Î².f Î².f').exists_leftFractionâ‚‚\n  dsimp at hÎ³â‚ hÎ³â‚‚\n  rw [add'_eq W gâ‚ gâ‚‚ Î² hÎ²â‚ hÎ²â‚‚, add'_eq W (f â‰« gâ‚) (f â‰« gâ‚‚)\n    (LeftFractionâ‚‚.mk (Î±.f â‰« Î³.f) (Î±.f â‰« Î³.f') (Î².s â‰« Î³.s) (W.comp_mem _ _ Î².hs Î³.hs))\n    (by simpa only [hÎ±, hÎ²â‚] using LeftFraction.map_comp_map_eq_map Î± Î².fst Î³.fst hÎ³â‚ L)\n    (by simpa only [hÎ±, hÎ²â‚‚] using LeftFraction.map_comp_map_eq_map Î± Î².snd Î³.snd hÎ³â‚‚ L),\n    hÎ±, LeftFraction.map_comp_map_eq_map Î± Î².add Î³.add\n      (by simp only [add_comp, hÎ³â‚, hÎ³â‚‚, comp_add])]\n  dsimp [LeftFractionâ‚‚.add]\n  rw [comp_add]\n\n"}
{"name":"CategoryTheory.Localization.Preadditive.add'_map","module":"Mathlib.CategoryTheory.Localization.CalculusOfFractions.Preadditive","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœâ´ : CategoryTheory.Category.{u_3, u_1} C\ninstâœÂ³ : CategoryTheory.Category.{u_4, u_2} D\ninstâœÂ² : CategoryTheory.Preadditive C\nL : CategoryTheory.Functor C D\nW : CategoryTheory.MorphismProperty C\ninstâœÂ¹ : L.IsLocalization W\ninstâœ : W.HasLeftCalculusOfFractions\nX Y : C\nfâ‚ fâ‚‚ : Quiver.Hom X Y\nâŠ¢ Eq (CategoryTheory.Localization.Preadditive.add' W (L.map fâ‚) (L.map fâ‚‚)) (L.map (HAdd.hAdd fâ‚ fâ‚‚))","decl":"@[simp]\nlemma add'_map (fâ‚ fâ‚‚ : X âŸ¶ Y) :\n    add' W (L.map fâ‚) (L.map fâ‚‚) = L.map (fâ‚ + fâ‚‚) :=\n  (add'_eq W (L.map fâ‚) (L.map fâ‚‚) (LeftFractionâ‚‚.mk fâ‚ fâ‚‚ (ğŸ™ _) (W.id_mem _))\n    (LeftFraction.map_ofHom _ _ _ _).symm (LeftFraction.map_ofHom _ _ _ _).symm).trans\n    (LeftFraction.map_ofHom _ _ _ _)\n\n"}
{"name":"CategoryTheory.Localization.Preadditive.homEquiv_apply","module":"Mathlib.CategoryTheory.Localization.CalculusOfFractions.Preadditive","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœÂ¹ : CategoryTheory.Category.{u_3, u_1} C\ninstâœ : CategoryTheory.Category.{u_4, u_2} D\nL : CategoryTheory.Functor C D\nX Y : C\nX' Y' : D\neX : CategoryTheory.Iso (L.obj X) X'\neY : CategoryTheory.Iso (L.obj Y) Y'\nf : Quiver.Hom X' Y'\nâŠ¢ Eq ((CategoryTheory.Localization.Preadditive.homEquiv eX eY) f) (CategoryTheory.CategoryStruct.comp eX.hom (CategoryTheory.CategoryStruct.comp f eY.inv))","decl":"/-- The bijection `(X' âŸ¶ Y') â‰ƒ (L.obj X âŸ¶ L.obj Y)` induced by isomorphisms\n`eX : L.obj X â‰… X'` and `eY : L.obj Y â‰… Y'`. -/\n@[simps]\ndef homEquiv : (X' âŸ¶ Y') â‰ƒ (L.obj X âŸ¶ L.obj Y) where\n  toFun f := eX.hom â‰« f â‰« eY.inv\n  invFun g := eX.inv â‰« g â‰« eY.hom\n  left_inv _ := by simp\n  right_inv _ := by simp\n\n"}
{"name":"CategoryTheory.Localization.Preadditive.homEquiv_symm_apply","module":"Mathlib.CategoryTheory.Localization.CalculusOfFractions.Preadditive","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœÂ¹ : CategoryTheory.Category.{u_3, u_1} C\ninstâœ : CategoryTheory.Category.{u_4, u_2} D\nL : CategoryTheory.Functor C D\nX Y : C\nX' Y' : D\neX : CategoryTheory.Iso (L.obj X) X'\neY : CategoryTheory.Iso (L.obj Y) Y'\ng : Quiver.Hom (L.obj X) (L.obj Y)\nâŠ¢ Eq ((CategoryTheory.Localization.Preadditive.homEquiv eX eY).symm g) (CategoryTheory.CategoryStruct.comp eX.inv (CategoryTheory.CategoryStruct.comp g eY.hom))","decl":"/-- The bijection `(X' âŸ¶ Y') â‰ƒ (L.obj X âŸ¶ L.obj Y)` induced by isomorphisms\n`eX : L.obj X â‰… X'` and `eY : L.obj Y â‰… Y'`. -/\n@[simps]\ndef homEquiv : (X' âŸ¶ Y') â‰ƒ (L.obj X âŸ¶ L.obj Y) where\n  toFun f := eX.hom â‰« f â‰« eY.inv\n  invFun g := eX.inv â‰« g â‰« eY.hom\n  left_inv _ := by simp\n  right_inv _ := by simp\n\n"}
{"name":"CategoryTheory.Localization.Preadditive.add_comp_assoc","module":"Mathlib.CategoryTheory.Localization.CalculusOfFractions.Preadditive","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœâ´ : CategoryTheory.Category.{u_4, u_1} C\ninstâœÂ³ : CategoryTheory.Category.{u_3, u_2} D\ninstâœÂ² : CategoryTheory.Preadditive C\nL : CategoryTheory.Functor C D\nW : CategoryTheory.MorphismProperty C\ninstâœÂ¹ : L.IsLocalization W\ninstâœ : W.HasLeftCalculusOfFractions\nX Y Zâœ : C\nX' Y' Z' : D\neX : CategoryTheory.Iso (L.obj X) X'\neY : CategoryTheory.Iso (L.obj Y) Y'\neZ : CategoryTheory.Iso (L.obj Zâœ) Z'\nfâ‚ fâ‚‚ : Quiver.Hom X' Y'\ng : Quiver.Hom Y' Z'\nZ : D\nh : Quiver.Hom Z' Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Localization.Preadditive.add W eX eY fâ‚ fâ‚‚) (CategoryTheory.CategoryStruct.comp g h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Localization.Preadditive.add W eX eZ (CategoryTheory.CategoryStruct.comp fâ‚ g) (CategoryTheory.CategoryStruct.comp fâ‚‚ g)) h)","decl":"@[reassoc]\nlemma add_comp (fâ‚ fâ‚‚ : X' âŸ¶ Y') (g : Y' âŸ¶ Z') :\n    add W eX eY fâ‚ fâ‚‚ â‰« g = add W eX eZ (fâ‚ â‰« g) (fâ‚‚ â‰« g) := by\n  obtain âŸ¨fâ‚, rflâŸ© := (homEquiv eX eY).symm.surjective fâ‚\n  obtain âŸ¨fâ‚‚, rflâŸ© := (homEquiv eX eY).symm.surjective fâ‚‚\n  obtain âŸ¨g, rflâŸ© := (homEquiv eY eZ).symm.surjective g\n  simp [add]\n\n"}
{"name":"CategoryTheory.Localization.Preadditive.add_comp","module":"Mathlib.CategoryTheory.Localization.CalculusOfFractions.Preadditive","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœâ´ : CategoryTheory.Category.{u_4, u_1} C\ninstâœÂ³ : CategoryTheory.Category.{u_3, u_2} D\ninstâœÂ² : CategoryTheory.Preadditive C\nL : CategoryTheory.Functor C D\nW : CategoryTheory.MorphismProperty C\ninstâœÂ¹ : L.IsLocalization W\ninstâœ : W.HasLeftCalculusOfFractions\nX Y Z : C\nX' Y' Z' : D\neX : CategoryTheory.Iso (L.obj X) X'\neY : CategoryTheory.Iso (L.obj Y) Y'\neZ : CategoryTheory.Iso (L.obj Z) Z'\nfâ‚ fâ‚‚ : Quiver.Hom X' Y'\ng : Quiver.Hom Y' Z'\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Localization.Preadditive.add W eX eY fâ‚ fâ‚‚) g) (CategoryTheory.Localization.Preadditive.add W eX eZ (CategoryTheory.CategoryStruct.comp fâ‚ g) (CategoryTheory.CategoryStruct.comp fâ‚‚ g))","decl":"@[reassoc]\nlemma add_comp (fâ‚ fâ‚‚ : X' âŸ¶ Y') (g : Y' âŸ¶ Z') :\n    add W eX eY fâ‚ fâ‚‚ â‰« g = add W eX eZ (fâ‚ â‰« g) (fâ‚‚ â‰« g) := by\n  obtain âŸ¨fâ‚, rflâŸ© := (homEquiv eX eY).symm.surjective fâ‚\n  obtain âŸ¨fâ‚‚, rflâŸ© := (homEquiv eX eY).symm.surjective fâ‚‚\n  obtain âŸ¨g, rflâŸ© := (homEquiv eY eZ).symm.surjective g\n  simp [add]\n\n"}
{"name":"CategoryTheory.Localization.Preadditive.comp_add","module":"Mathlib.CategoryTheory.Localization.CalculusOfFractions.Preadditive","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœâ´ : CategoryTheory.Category.{u_4, u_1} C\ninstâœÂ³ : CategoryTheory.Category.{u_3, u_2} D\ninstâœÂ² : CategoryTheory.Preadditive C\nL : CategoryTheory.Functor C D\nW : CategoryTheory.MorphismProperty C\ninstâœÂ¹ : L.IsLocalization W\ninstâœ : W.HasLeftCalculusOfFractions\nX Y Z : C\nX' Y' Z' : D\neX : CategoryTheory.Iso (L.obj X) X'\neY : CategoryTheory.Iso (L.obj Y) Y'\neZ : CategoryTheory.Iso (L.obj Z) Z'\nf : Quiver.Hom X' Y'\ngâ‚ gâ‚‚ : Quiver.Hom Y' Z'\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp f (CategoryTheory.Localization.Preadditive.add W eY eZ gâ‚ gâ‚‚)) (CategoryTheory.Localization.Preadditive.add W eX eZ (CategoryTheory.CategoryStruct.comp f gâ‚) (CategoryTheory.CategoryStruct.comp f gâ‚‚))","decl":"@[reassoc]\nlemma comp_add (f : X' âŸ¶ Y') (gâ‚ gâ‚‚ : Y' âŸ¶ Z') :\n    f â‰« add W eY eZ gâ‚ gâ‚‚ = add W eX eZ (f â‰« gâ‚) (f â‰« gâ‚‚) := by\n  obtain âŸ¨f, rflâŸ© := (homEquiv eX eY).symm.surjective f\n  obtain âŸ¨gâ‚, rflâŸ© := (homEquiv eY eZ).symm.surjective gâ‚\n  obtain âŸ¨gâ‚‚, rflâŸ© := (homEquiv eY eZ).symm.surjective gâ‚‚\n  simp [add]\n\n"}
{"name":"CategoryTheory.Localization.Preadditive.comp_add_assoc","module":"Mathlib.CategoryTheory.Localization.CalculusOfFractions.Preadditive","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœâ´ : CategoryTheory.Category.{u_4, u_1} C\ninstâœÂ³ : CategoryTheory.Category.{u_3, u_2} D\ninstâœÂ² : CategoryTheory.Preadditive C\nL : CategoryTheory.Functor C D\nW : CategoryTheory.MorphismProperty C\ninstâœÂ¹ : L.IsLocalization W\ninstâœ : W.HasLeftCalculusOfFractions\nX Y Zâœ : C\nX' Y' Z' : D\neX : CategoryTheory.Iso (L.obj X) X'\neY : CategoryTheory.Iso (L.obj Y) Y'\neZ : CategoryTheory.Iso (L.obj Zâœ) Z'\nf : Quiver.Hom X' Y'\ngâ‚ gâ‚‚ : Quiver.Hom Y' Z'\nZ : D\nh : Quiver.Hom Z' Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp f (CategoryTheory.CategoryStruct.comp (CategoryTheory.Localization.Preadditive.add W eY eZ gâ‚ gâ‚‚) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Localization.Preadditive.add W eX eZ (CategoryTheory.CategoryStruct.comp f gâ‚) (CategoryTheory.CategoryStruct.comp f gâ‚‚)) h)","decl":"@[reassoc]\nlemma comp_add (f : X' âŸ¶ Y') (gâ‚ gâ‚‚ : Y' âŸ¶ Z') :\n    f â‰« add W eY eZ gâ‚ gâ‚‚ = add W eX eZ (f â‰« gâ‚) (f â‰« gâ‚‚) := by\n  obtain âŸ¨f, rflâŸ© := (homEquiv eX eY).symm.surjective f\n  obtain âŸ¨gâ‚, rflâŸ© := (homEquiv eY eZ).symm.surjective gâ‚\n  obtain âŸ¨gâ‚‚, rflâŸ© := (homEquiv eY eZ).symm.surjective gâ‚‚\n  simp [add]\n\n"}
{"name":"CategoryTheory.Localization.Preadditive.add_eq_add","module":"Mathlib.CategoryTheory.Localization.CalculusOfFractions.Preadditive","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœâ´ : CategoryTheory.Category.{u_4, u_1} C\ninstâœÂ³ : CategoryTheory.Category.{u_3, u_2} D\ninstâœÂ² : CategoryTheory.Preadditive C\nL : CategoryTheory.Functor C D\nW : CategoryTheory.MorphismProperty C\ninstâœÂ¹ : L.IsLocalization W\ninstâœ : W.HasLeftCalculusOfFractions\nX Y : C\nX' Y' : D\neX : CategoryTheory.Iso (L.obj X) X'\neY : CategoryTheory.Iso (L.obj Y) Y'\nX'' Y'' : C\neX' : CategoryTheory.Iso (L.obj X'') X'\neY' : CategoryTheory.Iso (L.obj Y'') Y'\nfâ‚ fâ‚‚ : Quiver.Hom X' Y'\nâŠ¢ Eq (CategoryTheory.Localization.Preadditive.add W eX eY fâ‚ fâ‚‚) (CategoryTheory.Localization.Preadditive.add W eX' eY' fâ‚ fâ‚‚)","decl":"lemma add_eq_add {X'' Y'' : C} (eX' : L.obj X'' â‰… X') (eY' : L.obj Y'' â‰… Y')\n    (fâ‚ fâ‚‚ : X' âŸ¶ Y') :\n    add W eX eY fâ‚ fâ‚‚ = add W eX' eY' fâ‚ fâ‚‚ := by\n  have hâ‚ := comp_add W eX' eX eY (ğŸ™ _) fâ‚ fâ‚‚\n  have hâ‚‚ := add_comp W eX' eY eY' fâ‚ fâ‚‚ (ğŸ™ _)\n  simp only [id_comp] at hâ‚\n  simp only [comp_id] at hâ‚‚\n  rw [hâ‚, hâ‚‚]\n\n"}
{"name":"CategoryTheory.Localization.Preadditive.add_eq","module":"Mathlib.CategoryTheory.Localization.CalculusOfFractions.Preadditive","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœâ´ : CategoryTheory.Category.{u_4, u_1} C\ninstâœÂ³ : CategoryTheory.Category.{u_3, u_2} D\ninstâœÂ² : CategoryTheory.Preadditive C\nL : CategoryTheory.Functor C D\nW : CategoryTheory.MorphismProperty C\ninstâœÂ¹ : L.IsLocalization W\ninstâœ : W.HasLeftCalculusOfFractions\nX Y : C\nX' Y' : D\neX : CategoryTheory.Iso (L.obj X) X'\neY : CategoryTheory.Iso (L.obj Y) Y'\nfâ‚ fâ‚‚ : Quiver.Hom X' Y'\nâŠ¢ Eq (HAdd.hAdd fâ‚ fâ‚‚) (CategoryTheory.Localization.Preadditive.add W eX eY fâ‚ fâ‚‚)","decl":"lemma add_eq (fâ‚ fâ‚‚ : X' âŸ¶ Y') :\n    letI := addCommGroup L W X' Y'\n    fâ‚ + fâ‚‚ = add W eX eY fâ‚ fâ‚‚ := by\n  apply add_eq_add\n\n"}
{"name":"CategoryTheory.Localization.Preadditive.map_add","module":"Mathlib.CategoryTheory.Localization.CalculusOfFractions.Preadditive","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœâ´ : CategoryTheory.Category.{u_3, u_1} C\ninstâœÂ³ : CategoryTheory.Category.{u_4, u_2} D\ninstâœÂ² : CategoryTheory.Preadditive C\nL : CategoryTheory.Functor C D\nW : CategoryTheory.MorphismProperty C\ninstâœÂ¹ : L.IsLocalization W\ninstâœ : W.HasLeftCalculusOfFractions\nX Y : C\nfâ‚ fâ‚‚ : Quiver.Hom X Y\nâŠ¢ Eq (L.map (HAdd.hAdd fâ‚ fâ‚‚)) (HAdd.hAdd (L.map fâ‚) (L.map fâ‚‚))","decl":"lemma map_add (fâ‚ fâ‚‚ : X âŸ¶ Y) :\n    letI := addCommGroup L W (L.obj X) (L.obj Y)\n    L.map (fâ‚ + fâ‚‚) = L.map fâ‚ + L.map fâ‚‚ := by\n  rw [add_eq W (Iso.refl _) (Iso.refl _) (L.map fâ‚) (L.map fâ‚‚)]\n  simp [add]\n\n"}
{"name":"CategoryTheory.Localization.functor_additive","module":"Mathlib.CategoryTheory.Localization.CalculusOfFractions.Preadditive","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœâ´ : CategoryTheory.Category.{u_3, u_1} C\ninstâœÂ³ : CategoryTheory.Category.{u_4, u_2} D\ninstâœÂ² : CategoryTheory.Preadditive C\nL : CategoryTheory.Functor C D\nW : CategoryTheory.MorphismProperty C\ninstâœÂ¹ : L.IsLocalization W\ninstâœ : W.HasLeftCalculusOfFractions\nâŠ¢ L.Additive","decl":"lemma functor_additive :\n    letI := preadditive L W\n    L.Additive :=\n  letI := preadditive L W\n  âŸ¨by apply Preadditive.map_addâŸ©\n\n"}
{"name":"CategoryTheory.Localization.functor_additive_iff","module":"Mathlib.CategoryTheory.Localization.CalculusOfFractions.Preadditive","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœâ¸ : CategoryTheory.Category.{u_6, u_1} C\ninstâœâ· : CategoryTheory.Category.{u_5, u_2} D\ninstâœâ¶ : CategoryTheory.Preadditive C\nL : CategoryTheory.Functor C D\nW : CategoryTheory.MorphismProperty C\ninstâœâµ : L.IsLocalization W\ninstâœâ´ : W.HasLeftCalculusOfFractions\nE : Type u_3\ninstâœÂ³ : CategoryTheory.Category.{u_4, u_3} E\ninstâœÂ² : CategoryTheory.Preadditive E\ninstâœÂ¹ : CategoryTheory.Preadditive D\ninstâœ : L.Additive\nG : CategoryTheory.Functor D E\nâŠ¢ Iff G.Additive (L.comp G).Additive","decl":"include W in\nlemma functor_additive_iff {E : Type*} [Category E] [Preadditive E] [Preadditive D] [L.Additive]\n    (G : D â¥¤ E) :\n    G.Additive â†” (L â‹™ G).Additive := by\n  constructor\n  Â· intro\n    infer_instance\n  Â· intro h\n    suffices âˆ€ â¦ƒX Y : Câ¦„ (f g : L.obj X âŸ¶ L.obj Y), G.map (f + g) = G.map f + G.map g by\n      refine âŸ¨fun {X Y f g} => ?_âŸ©\n      have hL := essSurj L W\n      have eq := this ((L.objObjPreimageIso X).hom â‰« f â‰« (L.objObjPreimageIso Y).inv)\n        ((L.objObjPreimageIso X).hom â‰« g â‰« (L.objObjPreimageIso Y).inv)\n      rw [Functor.map_comp, Functor.map_comp, Functor.map_comp, Functor.map_comp,\n        â† comp_add, â† comp_add, â† add_comp, â† add_comp, Functor.map_comp, Functor.map_comp] at eq\n      rw [â† cancel_mono (G.map (L.objObjPreimageIso Y).inv),\n        â† cancel_epi (G.map (L.objObjPreimageIso X).hom), eq]\n    intros X Y f g\n    obtain âŸ¨Ï†, rfl, rflâŸ© := exists_leftFractionâ‚‚ L W f g\n    have := Localization.inverts L W Ï†.s Ï†.hs\n    rw [â† Ï†.map_add L (inverts L W), â† cancel_mono (G.map (L.map Ï†.s)), â† G.map_comp,\n      add_comp, â† G.map_comp, â† G.map_comp, LeftFraction.map_comp_map_s,\n      LeftFraction.map_comp_map_s, LeftFraction.map_comp_map_s, â† Functor.comp_map,\n      Functor.map_add, Functor.comp_map, Functor.comp_map]\n\n"}
{"name":"CategoryTheory.Localization.instAdditiveLocalizationQ","module":"Mathlib.CategoryTheory.Localization.CalculusOfFractions.Preadditive","initialProofState":"C : Type u_1\ninstâœÂ² : CategoryTheory.Category.{u_3, u_1} C\ninstâœÂ¹ : CategoryTheory.Preadditive C\nW : CategoryTheory.MorphismProperty C\ninstâœ : W.HasLeftCalculusOfFractions\nâŠ¢ W.Q.Additive","decl":"instance : W.Q.Additive := functor_additive W.Q W\n"}
{"name":"CategoryTheory.Localization.instHasZeroObjectLocalization","module":"Mathlib.CategoryTheory.Localization.CalculusOfFractions.Preadditive","initialProofState":"C : Type u_1\ninstâœÂ³ : CategoryTheory.Category.{u_3, u_1} C\ninstâœÂ² : CategoryTheory.Preadditive C\nW : CategoryTheory.MorphismProperty C\ninstâœÂ¹ : W.HasLeftCalculusOfFractions\ninstâœ : CategoryTheory.Limits.HasZeroObject C\nâŠ¢ CategoryTheory.Limits.HasZeroObject W.Localization","decl":"instance [HasZeroObject C] : HasZeroObject W.Localization := W.Q.hasZeroObject_of_additive\n\n"}
{"name":"CategoryTheory.Localization.instAdditiveLocalization'Q'","module":"Mathlib.CategoryTheory.Localization.CalculusOfFractions.Preadditive","initialProofState":"C : Type u_1\ninstâœÂ³ : CategoryTheory.Category.{u_3, u_1} C\ninstâœÂ² : CategoryTheory.Preadditive C\nW : CategoryTheory.MorphismProperty C\ninstâœÂ¹ : W.HasLeftCalculusOfFractions\ninstâœ : W.HasLocalization\nâŠ¢ W.Q'.Additive","decl":"instance : W.Q'.Additive := functor_additive W.Q' W\n"}
{"name":"CategoryTheory.Localization.instHasZeroObjectLocalization'","module":"Mathlib.CategoryTheory.Localization.CalculusOfFractions.Preadditive","initialProofState":"C : Type u_1\ninstâœâ´ : CategoryTheory.Category.{u_3, u_1} C\ninstâœÂ³ : CategoryTheory.Preadditive C\nW : CategoryTheory.MorphismProperty C\ninstâœÂ² : W.HasLeftCalculusOfFractions\ninstâœÂ¹ : W.HasLocalization\ninstâœ : CategoryTheory.Limits.HasZeroObject C\nâŠ¢ CategoryTheory.Limits.HasZeroObject W.Localization'","decl":"instance [HasZeroObject C] : HasZeroObject W.Localization' := W.Q'.hasZeroObject_of_additive\n\n"}
