{"name":"AddCommute.addUnits_neg_right","module":"Mathlib.Algebra.Group.Commute.Units","initialProofState":"M : Type u_1\ninst✝ : AddMonoid M\na : M\nu : AddUnits M\na✝ : AddCommute a ↑u\n⊢ AddCommute a ↑(Neg.neg u)","decl":"@[to_additive]\ntheorem units_inv_right : Commute a u → Commute a ↑u⁻¹ :=\n  SemiconjBy.units_inv_right\n\n"}
{"name":"Commute.units_inv_right","module":"Mathlib.Algebra.Group.Commute.Units","initialProofState":"M : Type u_1\ninst✝ : Monoid M\na : M\nu : Units M\na✝ : Commute a ↑u\n⊢ Commute a ↑(Inv.inv u)","decl":"@[to_additive]\ntheorem units_inv_right : Commute a u → Commute a ↑u⁻¹ :=\n  SemiconjBy.units_inv_right\n\n"}
{"name":"AddCommute.addUnits_neg_right_iff","module":"Mathlib.Algebra.Group.Commute.Units","initialProofState":"M : Type u_1\ninst✝ : AddMonoid M\na : M\nu : AddUnits M\n⊢ Iff (AddCommute a ↑(Neg.neg u)) (AddCommute a ↑u)","decl":"@[to_additive (attr := simp)]\ntheorem units_inv_right_iff : Commute a ↑u⁻¹ ↔ Commute a u :=\n  SemiconjBy.units_inv_right_iff\n\n"}
{"name":"Commute.units_inv_right_iff","module":"Mathlib.Algebra.Group.Commute.Units","initialProofState":"M : Type u_1\ninst✝ : Monoid M\na : M\nu : Units M\n⊢ Iff (Commute a ↑(Inv.inv u)) (Commute a ↑u)","decl":"@[to_additive (attr := simp)]\ntheorem units_inv_right_iff : Commute a ↑u⁻¹ ↔ Commute a u :=\n  SemiconjBy.units_inv_right_iff\n\n"}
{"name":"AddCommute.addUnits_neg_left","module":"Mathlib.Algebra.Group.Commute.Units","initialProofState":"M : Type u_1\ninst✝ : AddMonoid M\na : M\nu : AddUnits M\na✝ : AddCommute (↑u) a\n⊢ AddCommute (↑(Neg.neg u)) a","decl":"@[to_additive]\ntheorem units_inv_left : Commute (↑u) a → Commute (↑u⁻¹) a :=\n  SemiconjBy.units_inv_symm_left\n\n"}
{"name":"Commute.units_inv_left","module":"Mathlib.Algebra.Group.Commute.Units","initialProofState":"M : Type u_1\ninst✝ : Monoid M\na : M\nu : Units M\na✝ : Commute (↑u) a\n⊢ Commute (↑(Inv.inv u)) a","decl":"@[to_additive]\ntheorem units_inv_left : Commute (↑u) a → Commute (↑u⁻¹) a :=\n  SemiconjBy.units_inv_symm_left\n\n"}
{"name":"Commute.units_inv_left_iff","module":"Mathlib.Algebra.Group.Commute.Units","initialProofState":"M : Type u_1\ninst✝ : Monoid M\na : M\nu : Units M\n⊢ Iff (Commute (↑(Inv.inv u)) a) (Commute (↑u) a)","decl":"@[to_additive (attr := simp)]\ntheorem units_inv_left_iff : Commute (↑u⁻¹) a ↔ Commute (↑u) a :=\n  SemiconjBy.units_inv_symm_left_iff\n\n"}
{"name":"AddCommute.addUnits_neg_left_iff","module":"Mathlib.Algebra.Group.Commute.Units","initialProofState":"M : Type u_1\ninst✝ : AddMonoid M\na : M\nu : AddUnits M\n⊢ Iff (AddCommute (↑(Neg.neg u)) a) (AddCommute (↑u) a)","decl":"@[to_additive (attr := simp)]\ntheorem units_inv_left_iff : Commute (↑u⁻¹) a ↔ Commute (↑u) a :=\n  SemiconjBy.units_inv_symm_left_iff\n\n"}
{"name":"Commute.units_val","module":"Mathlib.Algebra.Group.Commute.Units","initialProofState":"M : Type u_1\ninst✝ : Monoid M\nu₁ u₂ : Units M\na✝ : Commute u₁ u₂\n⊢ Commute ↑u₁ ↑u₂","decl":"@[to_additive]\ntheorem units_val : Commute u₁ u₂ → Commute (u₁ : M) u₂ :=\n  SemiconjBy.units_val\n\n"}
{"name":"AddCommute.addUnits_val","module":"Mathlib.Algebra.Group.Commute.Units","initialProofState":"M : Type u_1\ninst✝ : AddMonoid M\nu₁ u₂ : AddUnits M\na✝ : AddCommute u₁ u₂\n⊢ AddCommute ↑u₁ ↑u₂","decl":"@[to_additive]\ntheorem units_val : Commute u₁ u₂ → Commute (u₁ : M) u₂ :=\n  SemiconjBy.units_val\n\n"}
{"name":"Commute.units_of_val","module":"Mathlib.Algebra.Group.Commute.Units","initialProofState":"M : Type u_1\ninst✝ : Monoid M\nu₁ u₂ : Units M\na✝ : Commute ↑u₁ ↑u₂\n⊢ Commute u₁ u₂","decl":"@[to_additive]\ntheorem units_of_val : Commute (u₁ : M) u₂ → Commute u₁ u₂ :=\n  SemiconjBy.units_of_val\n\n"}
{"name":"AddCommute.addUnits_of_val","module":"Mathlib.Algebra.Group.Commute.Units","initialProofState":"M : Type u_1\ninst✝ : AddMonoid M\nu₁ u₂ : AddUnits M\na✝ : AddCommute ↑u₁ ↑u₂\n⊢ AddCommute u₁ u₂","decl":"@[to_additive]\ntheorem units_of_val : Commute (u₁ : M) u₂ → Commute u₁ u₂ :=\n  SemiconjBy.units_of_val\n\n"}
{"name":"Commute.units_val_iff","module":"Mathlib.Algebra.Group.Commute.Units","initialProofState":"M : Type u_1\ninst✝ : Monoid M\nu₁ u₂ : Units M\n⊢ Iff (Commute ↑u₁ ↑u₂) (Commute u₁ u₂)","decl":"@[to_additive (attr := simp)]\ntheorem units_val_iff : Commute (u₁ : M) u₂ ↔ Commute u₁ u₂ :=\n  SemiconjBy.units_val_iff\n\n"}
{"name":"AddCommute.addUnits_val_iff","module":"Mathlib.Algebra.Group.Commute.Units","initialProofState":"M : Type u_1\ninst✝ : AddMonoid M\nu₁ u₂ : AddUnits M\n⊢ Iff (AddCommute ↑u₁ ↑u₂) (AddCommute u₁ u₂)","decl":"@[to_additive (attr := simp)]\ntheorem units_val_iff : Commute (u₁ : M) u₂ ↔ Commute u₁ u₂ :=\n  SemiconjBy.units_val_iff\n\n"}
{"name":"AddCommute.isAddUnit_add_iff","module":"Mathlib.Algebra.Group.Commute.Units","initialProofState":"M : Type u_1\ninst✝ : AddMonoid M\na b : M\nh : AddCommute a b\n⊢ Iff (IsAddUnit (HAdd.hAdd a b)) (And (IsAddUnit a) (IsAddUnit b))","decl":"@[to_additive]\ntheorem Commute.isUnit_mul_iff (h : Commute a b) : IsUnit (a * b) ↔ IsUnit a ∧ IsUnit b :=\n  ⟨fun ⟨u, hu⟩ => ⟨(u.leftOfMul a b hu.symm h).isUnit, (u.rightOfMul a b hu.symm h).isUnit⟩,\n  fun H => H.1.mul H.2⟩\n\n"}
{"name":"Commute.isUnit_mul_iff","module":"Mathlib.Algebra.Group.Commute.Units","initialProofState":"M : Type u_1\ninst✝ : Monoid M\na b : M\nh : Commute a b\n⊢ Iff (IsUnit (HMul.hMul a b)) (And (IsUnit a) (IsUnit b))","decl":"@[to_additive]\ntheorem Commute.isUnit_mul_iff (h : Commute a b) : IsUnit (a * b) ↔ IsUnit a ∧ IsUnit b :=\n  ⟨fun ⟨u, hu⟩ => ⟨(u.leftOfMul a b hu.symm h).isUnit, (u.rightOfMul a b hu.symm h).isUnit⟩,\n  fun H => H.1.mul H.2⟩\n\n"}
{"name":"isUnit_mul_self_iff","module":"Mathlib.Algebra.Group.Commute.Units","initialProofState":"M : Type u_1\ninst✝ : Monoid M\na : M\n⊢ Iff (IsUnit (HMul.hMul a a)) (IsUnit a)","decl":"@[to_additive (attr := simp)]\ntheorem isUnit_mul_self_iff : IsUnit (a * a) ↔ IsUnit a :=\n  (Commute.refl a).isUnit_mul_iff.trans and_self_iff\n\n"}
{"name":"isAddUnit_add_self_iff","module":"Mathlib.Algebra.Group.Commute.Units","initialProofState":"M : Type u_1\ninst✝ : AddMonoid M\na : M\n⊢ Iff (IsAddUnit (HAdd.hAdd a a)) (IsAddUnit a)","decl":"@[to_additive (attr := simp)]\ntheorem isUnit_mul_self_iff : IsUnit (a * a) ↔ IsUnit a :=\n  (Commute.refl a).isUnit_mul_iff.trans and_self_iff\n\n"}
{"name":"Commute.units_zpow_right","module":"Mathlib.Algebra.Group.Commute.Units","initialProofState":"M : Type u_1\ninst✝ : Monoid M\na : M\nu : Units M\nh : Commute a ↑u\nm : Int\n⊢ Commute a ↑(HPow.hPow u m)","decl":"@[to_additive (attr := simp)]\nlemma Commute.units_zpow_right (h : Commute a u) (m : ℤ) : Commute a ↑(u ^ m) :=\n  SemiconjBy.units_zpow_right h m\n\n"}
{"name":"AddCommute.addUnits_zsmul_right","module":"Mathlib.Algebra.Group.Commute.Units","initialProofState":"M : Type u_1\ninst✝ : AddMonoid M\na : M\nu : AddUnits M\nh : AddCommute a ↑u\nm : Int\n⊢ AddCommute a ↑(HSMul.hSMul m u)","decl":"@[to_additive (attr := simp)]\nlemma Commute.units_zpow_right (h : Commute a u) (m : ℤ) : Commute a ↑(u ^ m) :=\n  SemiconjBy.units_zpow_right h m\n\n"}
{"name":"AddCommute.addUnits_zsmul_left","module":"Mathlib.Algebra.Group.Commute.Units","initialProofState":"M : Type u_1\ninst✝ : AddMonoid M\na : M\nu : AddUnits M\nh : AddCommute (↑u) a\nm : Int\n⊢ AddCommute (↑(HSMul.hSMul m u)) a","decl":"@[to_additive (attr := simp)]\nlemma Commute.units_zpow_left (h : Commute ↑u a) (m : ℤ) : Commute ↑(u ^ m) a :=\n  (h.symm.units_zpow_right m).symm\n\n"}
{"name":"Commute.units_zpow_left","module":"Mathlib.Algebra.Group.Commute.Units","initialProofState":"M : Type u_1\ninst✝ : Monoid M\na : M\nu : Units M\nh : Commute (↑u) a\nm : Int\n⊢ Commute (↑(HPow.hPow u m)) a","decl":"@[to_additive (attr := simp)]\nlemma Commute.units_zpow_left (h : Commute ↑u a) (m : ℤ) : Commute ↑(u ^ m) a :=\n  (h.symm.units_zpow_right m).symm\n\n"}
{"name":"isAddUnit_nsmul_iff","module":"Mathlib.Algebra.Group.Commute.Units","initialProofState":"M : Type u_1\ninst✝ : AddMonoid M\nn : Nat\na : M\nhn : Ne n 0\n⊢ Iff (IsAddUnit (HSMul.hSMul n a)) (IsAddUnit a)","decl":"@[to_additive (attr := simp)] lemma isUnit_pow_iff (hn : n ≠ 0) : IsUnit (a ^ n) ↔ IsUnit a :=\n  ⟨fun ⟨u, hu⟩ ↦ (u.ofPow a hn hu.symm).isUnit, IsUnit.pow n⟩\n\n"}
{"name":"isUnit_pow_iff","module":"Mathlib.Algebra.Group.Commute.Units","initialProofState":"M : Type u_1\ninst✝ : Monoid M\nn : Nat\na : M\nhn : Ne n 0\n⊢ Iff (IsUnit (HPow.hPow a n)) (IsUnit a)","decl":"@[to_additive (attr := simp)] lemma isUnit_pow_iff (hn : n ≠ 0) : IsUnit (a ^ n) ↔ IsUnit a :=\n  ⟨fun ⟨u, hu⟩ ↦ (u.ofPow a hn hu.symm).isUnit, IsUnit.pow n⟩\n\n"}
{"name":"isUnit_pow_succ_iff","module":"Mathlib.Algebra.Group.Commute.Units","initialProofState":"M : Type u_1\ninst✝ : Monoid M\nn : Nat\na : M\n⊢ Iff (IsUnit (HPow.hPow a (HAdd.hAdd n 1))) (IsUnit a)","decl":"@[to_additive]\nlemma isUnit_pow_succ_iff : IsUnit (a ^ (n + 1)) ↔ IsUnit a := isUnit_pow_iff n.succ_ne_zero\n\n"}
{"name":"isAddUnit_nsmul_succ_iff","module":"Mathlib.Algebra.Group.Commute.Units","initialProofState":"M : Type u_1\ninst✝ : AddMonoid M\nn : Nat\na : M\n⊢ Iff (IsAddUnit (HSMul.hSMul (HAdd.hAdd n 1) a)) (IsAddUnit a)","decl":"@[to_additive]\nlemma isUnit_pow_succ_iff : IsUnit (a ^ (n + 1)) ↔ IsUnit a := isUnit_pow_iff n.succ_ne_zero\n\n"}
{"name":"AddUnits.val_ofNSMulEqZero","module":"Mathlib.Algebra.Group.Commute.Units","initialProofState":"M : Type u_1\ninst✝ : AddMonoid M\na : M\nn : Nat\nha : Eq (HSMul.hSMul n a) 0\nhn : Ne n 0\n⊢ Eq (↑(AddUnits.ofNSMulEqZero a n ha hn)) a","decl":"/-- If `a ^ n = 1`, `n ≠ 0`, then `a` is a unit. -/\n@[to_additive (attr := simps!) \"If `n • x = 0`, `n ≠ 0`, then `x` is an additive unit.\"]\ndef Units.ofPowEqOne (a : M) (n : ℕ) (ha : a ^ n = 1) (hn : n ≠ 0) : Mˣ := Units.ofPow 1 a hn ha\n\n"}
{"name":"AddUnits.val_neg_ofNSMulEqZero","module":"Mathlib.Algebra.Group.Commute.Units","initialProofState":"M : Type u_1\ninst✝ : AddMonoid M\na : M\nn : Nat\nha : Eq (HSMul.hSMul n a) 0\nhn : Ne n 0\n⊢ Eq (↑(Neg.neg (AddUnits.ofNSMulEqZero a n ha hn))) (HSMul.hSMul (HSub.hSub n 1) a)","decl":"/-- If `a ^ n = 1`, `n ≠ 0`, then `a` is a unit. -/\n@[to_additive (attr := simps!) \"If `n • x = 0`, `n ≠ 0`, then `x` is an additive unit.\"]\ndef Units.ofPowEqOne (a : M) (n : ℕ) (ha : a ^ n = 1) (hn : n ≠ 0) : Mˣ := Units.ofPow 1 a hn ha\n\n"}
{"name":"Units.val_ofPowEqOne","module":"Mathlib.Algebra.Group.Commute.Units","initialProofState":"M : Type u_1\ninst✝ : Monoid M\na : M\nn : Nat\nha : Eq (HPow.hPow a n) 1\nhn : Ne n 0\n⊢ Eq (↑(Units.ofPowEqOne a n ha hn)) a","decl":"/-- If `a ^ n = 1`, `n ≠ 0`, then `a` is a unit. -/\n@[to_additive (attr := simps!) \"If `n • x = 0`, `n ≠ 0`, then `x` is an additive unit.\"]\ndef Units.ofPowEqOne (a : M) (n : ℕ) (ha : a ^ n = 1) (hn : n ≠ 0) : Mˣ := Units.ofPow 1 a hn ha\n\n"}
{"name":"Units.val_inv_ofPowEqOne","module":"Mathlib.Algebra.Group.Commute.Units","initialProofState":"M : Type u_1\ninst✝ : Monoid M\na : M\nn : Nat\nha : Eq (HPow.hPow a n) 1\nhn : Ne n 0\n⊢ Eq (↑(Inv.inv (Units.ofPowEqOne a n ha hn))) (HPow.hPow a (HSub.hSub n 1))","decl":"/-- If `a ^ n = 1`, `n ≠ 0`, then `a` is a unit. -/\n@[to_additive (attr := simps!) \"If `n • x = 0`, `n ≠ 0`, then `x` is an additive unit.\"]\ndef Units.ofPowEqOne (a : M) (n : ℕ) (ha : a ^ n = 1) (hn : n ≠ 0) : Mˣ := Units.ofPow 1 a hn ha\n\n"}
{"name":"Units.pow_ofPowEqOne","module":"Mathlib.Algebra.Group.Commute.Units","initialProofState":"M : Type u_1\ninst✝ : Monoid M\nn : Nat\na : M\nha : Eq (HPow.hPow a n) 1\nhn : Ne n 0\n⊢ Eq (HPow.hPow (Units.ofPowEqOne a n ha hn) n) 1","decl":"@[to_additive (attr := simp)]\nlemma Units.pow_ofPowEqOne (ha : a ^ n = 1) (hn : n ≠ 0) :\n    Units.ofPowEqOne _ n ha hn ^ n = 1 := Units.ext <| by simp [ha]\n\n"}
{"name":"AddUnits.nsmul_ofNSMulEqZero","module":"Mathlib.Algebra.Group.Commute.Units","initialProofState":"M : Type u_1\ninst✝ : AddMonoid M\nn : Nat\na : M\nha : Eq (HSMul.hSMul n a) 0\nhn : Ne n 0\n⊢ Eq (HSMul.hSMul n (AddUnits.ofNSMulEqZero a n ha hn)) 0","decl":"@[to_additive (attr := simp)]\nlemma Units.pow_ofPowEqOne (ha : a ^ n = 1) (hn : n ≠ 0) :\n    Units.ofPowEqOne _ n ha hn ^ n = 1 := Units.ext <| by simp [ha]\n\n"}
{"name":"isUnit_ofPowEqOne","module":"Mathlib.Algebra.Group.Commute.Units","initialProofState":"M : Type u_1\ninst✝ : Monoid M\nn : Nat\na : M\nha : Eq (HPow.hPow a n) 1\nhn : Ne n 0\n⊢ IsUnit a","decl":"@[to_additive]\nlemma isUnit_ofPowEqOne (ha : a ^ n = 1) (hn : n ≠ 0) : IsUnit a :=\n  (Units.ofPowEqOne _ n ha hn).isUnit\n\n"}
{"name":"isAddUnit_ofNSMulEqZero","module":"Mathlib.Algebra.Group.Commute.Units","initialProofState":"M : Type u_1\ninst✝ : AddMonoid M\nn : Nat\na : M\nha : Eq (HSMul.hSMul n a) 0\nhn : Ne n 0\n⊢ IsAddUnit a","decl":"@[to_additive]\nlemma isUnit_ofPowEqOne (ha : a ^ n = 1) (hn : n ≠ 0) : IsUnit a :=\n  (Units.ofPowEqOne _ n ha hn).isUnit\n\n"}
{"name":"Commute.div_eq_div_iff_of_isUnit","module":"Mathlib.Algebra.Group.Commute.Units","initialProofState":"M : Type u_1\ninst✝ : DivisionMonoid M\na b c d : M\nhbd : Commute b d\nhb : IsUnit b\nhd : IsUnit d\n⊢ Iff (Eq (HDiv.hDiv a b) (HDiv.hDiv c d)) (Eq (HMul.hMul a d) (HMul.hMul c b))","decl":"@[to_additive]\nlemma Commute.div_eq_div_iff_of_isUnit (hbd : Commute b d) (hb : IsUnit b) (hd : IsUnit d) :\n    a / b = c / d ↔ a * d = c * b := by\n  rw [← (hb.mul hd).mul_left_inj, ← mul_assoc, hb.div_mul_cancel, ← mul_assoc, hbd.right_comm,\n    hd.div_mul_cancel]\n\n"}
{"name":"AddCommute.sub_eq_sub_iff_of_isAddUnit","module":"Mathlib.Algebra.Group.Commute.Units","initialProofState":"M : Type u_1\ninst✝ : SubtractionMonoid M\na b c d : M\nhbd : AddCommute b d\nhb : IsAddUnit b\nhd : IsAddUnit d\n⊢ Iff (Eq (HSub.hSub a b) (HSub.hSub c d)) (Eq (HAdd.hAdd a d) (HAdd.hAdd c b))","decl":"@[to_additive]\nlemma Commute.div_eq_div_iff_of_isUnit (hbd : Commute b d) (hb : IsUnit b) (hd : IsUnit d) :\n    a / b = c / d ↔ a * d = c * b := by\n  rw [← (hb.mul hd).mul_left_inj, ← mul_assoc, hb.div_mul_cancel, ← mul_assoc, hbd.right_comm,\n    hd.div_mul_cancel]\n\n"}
