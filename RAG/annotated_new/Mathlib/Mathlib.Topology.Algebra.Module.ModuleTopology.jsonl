{"name":"IsModuleTopology.eq_moduleTopology'","module":"Mathlib.Topology.Algebra.Module.ModuleTopology","initialProofState":"R : Type u_1\ninst✝² : TopologicalSpace R\nA : Type u_2\ninst✝¹ : Add A\ninst✝ : SMul R A\nτA : TopologicalSpace A\nself : IsModuleTopology R A\n⊢ Eq τA (moduleTopology R A)","decl":"/-- A class asserting that the topology on a module over a topological ring `R` is\nthe module topology. See `moduleTopology` for more discussion of the module topology. -/\nclass IsModuleTopology [τA : TopologicalSpace A] : Prop where\n  /-- Note that this should not be used directly, and `eq_moduleTopology`, which takes `R` and `A`\n  explicitly, should be used instead. -/\n  eq_moduleTopology' : τA = moduleTopology R A\n\n"}
{"name":"eq_moduleTopology","module":"Mathlib.Topology.Algebra.Module.ModuleTopology","initialProofState":"R : Type u_1\ninst✝³ : TopologicalSpace R\nA : Type u_2\ninst✝² : Add A\ninst✝¹ : SMul R A\nτA : TopologicalSpace A\ninst✝ : IsModuleTopology R A\n⊢ Eq τA (moduleTopology R A)","decl":"theorem eq_moduleTopology [τA : TopologicalSpace A] [IsModuleTopology R A] :\n    τA = moduleTopology R A :=\n  IsModuleTopology.eq_moduleTopology' (R := R) (A := A)\n\n"}
{"name":"ModuleTopology.continuousSMul","module":"Mathlib.Topology.Algebra.Module.ModuleTopology","initialProofState":"R : Type u_1\ninst✝² : TopologicalSpace R\nA : Type u_2\ninst✝¹ : Add A\ninst✝ : SMul R A\n⊢ ContinuousSMul R A","decl":"/-- Scalar multiplication `• : R × A → A` is continuous if `R` is a topological\nring, and `A` is an `R` module with the module topology. -/\ntheorem ModuleTopology.continuousSMul : @ContinuousSMul R A _ _ (moduleTopology R A) :=\n  /- Proof: We need to prove that the product topology is finer than the pullback\n     of the module topology. But the module topology is an Inf and thus a limit,\n     and pullback is a right adjoint, so it preserves limits.\n     We must thus show that the product topology is finer than an Inf, so it suffices\n     to show it's a lower bound, which is not hard. All this is wrapped into\n     `continuousSMul_sInf`.\n  -/\n  continuousSMul_sInf fun _ h ↦ h.1\n\n"}
{"name":"ModuleTopology.continuousAdd","module":"Mathlib.Topology.Algebra.Module.ModuleTopology","initialProofState":"R : Type u_1\ninst✝² : TopologicalSpace R\nA : Type u_2\ninst✝¹ : Add A\ninst✝ : SMul R A\n⊢ ContinuousAdd A","decl":"/-- Addition `+ : A × A → A` is continuous if `R` is a topological\nring, and `A` is an `R` module with the module topology. -/\ntheorem ModuleTopology.continuousAdd : @ContinuousAdd A (moduleTopology R A) _ :=\n  continuousAdd_sInf fun _ h ↦ h.2\n\n"}
{"name":"IsModuleTopology.toContinuousSMul","module":"Mathlib.Topology.Algebra.Module.ModuleTopology","initialProofState":"R : Type u_1\ninst✝⁴ : TopologicalSpace R\nA : Type u_2\ninst✝³ : Add A\ninst✝² : SMul R A\ninst✝¹ : TopologicalSpace A\ninst✝ : IsModuleTopology R A\n⊢ ContinuousSMul R A","decl":"instance IsModuleTopology.toContinuousSMul [TopologicalSpace A] [IsModuleTopology R A] :\n    ContinuousSMul R A := eq_moduleTopology R A ▸ ModuleTopology.continuousSMul R A\n\n-- this can't be an instance because typclass inference can't be expected to find `R`.\n"}
{"name":"IsModuleTopology.toContinuousAdd","module":"Mathlib.Topology.Algebra.Module.ModuleTopology","initialProofState":"R : Type u_1\ninst✝⁴ : TopologicalSpace R\nA : Type u_2\ninst✝³ : Add A\ninst✝² : SMul R A\ninst✝¹ : TopologicalSpace A\ninst✝ : IsModuleTopology R A\n⊢ ContinuousAdd A","decl":"theorem IsModuleTopology.toContinuousAdd [TopologicalSpace A] [IsModuleTopology R A] :\n    ContinuousAdd A := eq_moduleTopology R A ▸ ModuleTopology.continuousAdd R A\n\n"}
{"name":"moduleTopology_le","module":"Mathlib.Topology.Algebra.Module.ModuleTopology","initialProofState":"R : Type u_1\ninst✝⁴ : TopologicalSpace R\nA : Type u_2\ninst✝³ : Add A\ninst✝² : SMul R A\nτA : TopologicalSpace A\ninst✝¹ : ContinuousSMul R A\ninst✝ : ContinuousAdd A\n⊢ LE.le (moduleTopology R A) τA","decl":"/-- The module topology is `≤` any topology making `A` into a topological module. -/\ntheorem moduleTopology_le [τA : TopologicalSpace A] [ContinuousSMul R A] [ContinuousAdd A] :\n    moduleTopology R A ≤ τA := sInf_le ⟨inferInstance, inferInstance⟩\n\n"}
{"name":"IsModuleTopology.of_continuous_id","module":"Mathlib.Topology.Algebra.Module.ModuleTopology","initialProofState":"R : Type u_1\ninst✝⁴ : TopologicalSpace R\nA : Type u_2\ninst✝³ : Add A\ninst✝² : SMul R A\nτA : TopologicalSpace A\ninst✝¹ : ContinuousAdd A\ninst✝ : ContinuousSMul R A\nh : Continuous id\n⊢ IsModuleTopology R A","decl":"/-- If `A` is a topological `R`-module and the identity map from (`A` with its given\ntopology) to (`A` with the module topology) is continuous, then the topology on `A` is\nthe module topology. -/\ntheorem of_continuous_id [ContinuousAdd A] [ContinuousSMul R A]\n    (h : @Continuous A A τA (moduleTopology R A) id):\n    IsModuleTopology R A where\n  -- The topologies are equal because each is finer than the other. One inclusion\n  -- follows from the continuity hypothesis; the other is because the module topology\n  -- is the inf of all the topologies making `A` a topological module.\n  eq_moduleTopology' := le_antisymm (continuous_id_iff_le.1 h) (moduleTopology_le _ _)\n\n"}
{"name":"IsModuleTopology.instSubsingleton","module":"Mathlib.Topology.Algebra.Module.ModuleTopology","initialProofState":"R : Type u_1\ninst✝³ : TopologicalSpace R\nA : Type u_2\ninst✝² : Add A\ninst✝¹ : SMul R A\nτA : TopologicalSpace A\ninst✝ : Subsingleton A\n⊢ IsModuleTopology R A","decl":"/-- The zero module has the module topology. -/\ninstance instSubsingleton [Subsingleton A] : IsModuleTopology R A where\n  eq_moduleTopology' := Subsingleton.elim _ _\n\n"}
{"name":"IsModuleTopology.iso","module":"Mathlib.Topology.Algebra.Module.ModuleTopology","initialProofState":"R : Type u_1\nτR : TopologicalSpace R\ninst✝⁵ : Semiring R\nA : Type u_2\ninst✝⁴ : AddCommMonoid A\ninst✝³ : Module R A\nτA : TopologicalSpace A\ninst✝² : IsModuleTopology R A\nB : Type u_3\ninst✝¹ : AddCommMonoid B\ninst✝ : Module R B\nτB : TopologicalSpace B\ne : ContinuousLinearEquiv (RingHom.id R) A B\n⊢ IsModuleTopology R B","decl":"/-- If `A` and `B` are `R`-modules, homeomorphic via an `R`-linear homeomorphism, and if\n`A` has the module topology, then so does `B`. -/\ntheorem iso (e : A ≃L[R] B) : IsModuleTopology R B where\n  eq_moduleTopology' := by\n    -- get these in before I start putting new topologies on A and B and have to use `@`\n    let g : A →ₗ[R] B := e\n    let g' : B →ₗ[R] A := e.symm\n    let h : A →+ B := e\n    let h' : B →+ A := e.symm\n    simp_rw [e.toHomeomorph.symm.isInducing.1, eq_moduleTopology R A, moduleTopology, induced_sInf]\n    apply congr_arg\n    ext τ -- from this point on the definitions of `g`, `g'` etc above don't work without `@`.\n    rw [Set.mem_image]\n    constructor\n    · rintro ⟨σ, ⟨hσ1, hσ2⟩, rfl⟩\n      exact ⟨continuousSMul_induced g'.toMulActionHom, continuousAdd_induced h'⟩\n    · rintro ⟨h1, h2⟩\n      use τ.induced e\n      rw [induced_compose]\n      refine ⟨⟨continuousSMul_induced g.toMulActionHom, continuousAdd_induced h⟩, ?_⟩\n      nth_rw 2 [← induced_id (t := τ)]\n      simp\n\n"}
{"name":"TopologicalSemiring.toIsModuleTopology","module":"Mathlib.Topology.Algebra.Module.ModuleTopology","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nτR : TopologicalSpace R\n⊢ IsModuleTopology R R","decl":"/-- The topology on a topological semiring `R` agrees with the module topology when considering\n`R` as an `R`-module in the obvious way (i.e., via `Semiring.toModule`). -/\ninstance _root_.TopologicalSemiring.toIsModuleTopology : IsModuleTopology R R := by\n  /- By a previous lemma it suffices to show that the identity from (R,usual) to\n  (R, module topology) is continuous. -/\n  apply of_continuous_id\n  /-\n  The idea needed here is to rewrite the identity function as the composite of `r ↦ (r,1)`\n  from `R` to `R × R`, and multiplication `R × R → R`.\n  -/\n  rw [show (id : R → R) = (fun rs ↦ rs.1 • rs.2) ∘ (fun r ↦ (r, 1)) by ext; simp]\n  /-\n  It thus suffices to show that each of these maps are continuous. For this claim to even make\n  sense, we need to topologise `R × R`. The trick is to do this by giving the first `R` the usual\n  topology `τR` and the second `R` the module topology. To do this we have to \"fight mathlib\"\n  a bit with `@`, because there is more than one topology on `R` here.\n  -/\n  apply @Continuous.comp R (R × R) R τR (@instTopologicalSpaceProd R R τR (moduleTopology R R))\n      (moduleTopology R R)\n  · /-\n    The map R × R → R is `•`, so by a fundamental property of the module topology,\n    this is continuous. -/\n    exact @continuous_smul _ _ _ _ (moduleTopology R R) <| ModuleTopology.continuousSMul ..\n  · /-\n    The map `R → R × R` sending `r` to `(r,1)` is a map into a product, so it suffices to show\n    that each of the two factors is continuous. But the first is the identity function\n    on `(R, usual topology)` and the second is a constant function. -/\n    exact @Continuous.prod_mk _ _ _ _ (moduleTopology R R) _ _ _ continuous_id <|\n      @continuous_const _ _ _ (moduleTopology R R) _\n\n"}
{"name":"TopologicalSemiring.toOppositeIsModuleTopology","module":"Mathlib.Topology.Algebra.Module.ModuleTopology","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nτR : TopologicalSpace R\n⊢ IsModuleTopology (MulOpposite R) R","decl":"/-- The module topology coming from the action of the topological ring `Rᵐᵒᵖ` on `R`\n  (via `Semiring.toOppositeModule`, i.e. via `(op r) • m = m * r`) is `R`'s topology. -/\ninstance _root_.TopologicalSemiring.toOppositeIsModuleTopology : IsModuleTopology Rᵐᵒᵖ R :=\n  .iso (MulOpposite.opContinuousLinearEquiv Rᵐᵒᵖ).symm\n\n"}
{"name":"IsModuleTopology.continuous_of_distribMulActionHom","module":"Mathlib.Topology.Algebra.Module.ModuleTopology","initialProofState":"R : Type u_1\nτR : TopologicalSpace R\ninst✝⁷ : Semiring R\nA : Type u_2\ninst✝⁶ : AddCommMonoid A\ninst✝⁵ : Module R A\naA : TopologicalSpace A\ninst✝⁴ : IsModuleTopology R A\nB : Type u_3\ninst✝³ : AddCommMonoid B\ninst✝² : Module R B\naB : TopologicalSpace B\ninst✝¹ : ContinuousAdd B\ninst✝ : ContinuousSMul R B\nφ : DistribMulActionHom (MonoidHom.id R) A B\n⊢ Continuous ⇑φ","decl":"/-- Every `R`-linear map between two topological `R`-modules, where the source has the module\ntopology, is continuous. -/\n@[fun_prop, continuity]\ntheorem continuous_of_distribMulActionHom (φ : A →+[R] B) : Continuous φ := by\n  -- the proof: We know that `+ : B × B → B` and `• : R × B → B` are continuous for the module\n  -- topology on `B`, and two earlier theorems (`continuousSMul_induced` and\n  -- `continuousAdd_induced`) say that hence `+` and `•` on `A` are continuous if `A`\n  -- is given the topology induced from `φ`. Hence the module topology is finer than\n  -- the induced topology, and so the function is continuous.\n  rw [eq_moduleTopology R A, continuous_iff_le_induced]\n  exact sInf_le <| ⟨continuousSMul_induced (φ.toMulActionHom),\n    continuousAdd_induced φ.toAddMonoidHom⟩\n\n"}
{"name":"IsModuleTopology.continuous_of_linearMap","module":"Mathlib.Topology.Algebra.Module.ModuleTopology","initialProofState":"R : Type u_1\nτR : TopologicalSpace R\ninst✝⁷ : Semiring R\nA : Type u_2\ninst✝⁶ : AddCommMonoid A\ninst✝⁵ : Module R A\naA : TopologicalSpace A\ninst✝⁴ : IsModuleTopology R A\nB : Type u_3\ninst✝³ : AddCommMonoid B\ninst✝² : Module R B\naB : TopologicalSpace B\ninst✝¹ : ContinuousAdd B\ninst✝ : ContinuousSMul R B\nφ : LinearMap (RingHom.id R) A B\n⊢ Continuous ⇑φ","decl":"@[fun_prop, continuity]\ntheorem continuous_of_linearMap (φ : A →ₗ[R] B) : Continuous φ :=\n  continuous_of_distribMulActionHom φ.toDistribMulActionHom\n\n"}
{"name":"IsModuleTopology.continuous_neg","module":"Mathlib.Topology.Algebra.Module.ModuleTopology","initialProofState":"R : Type u_1\nτR : TopologicalSpace R\ninst✝⁴ : Semiring R\nC : Type u_4\ninst✝³ : AddCommGroup C\ninst✝² : Module R C\ninst✝¹ : TopologicalSpace C\ninst✝ : IsModuleTopology R C\n⊢ Continuous fun a => Neg.neg a","decl":"variable (R) in\ntheorem continuous_neg (C : Type*) [AddCommGroup C] [Module R C] [TopologicalSpace C]\n    [IsModuleTopology R C] : Continuous (fun a ↦ -a : C → C) :=\n  haveI : ContinuousAdd C := IsModuleTopology.toContinuousAdd R C\n  continuous_of_linearMap (LinearEquiv.neg R).toLinearMap\n\n"}
{"name":"IsModuleTopology.continuousNeg","module":"Mathlib.Topology.Algebra.Module.ModuleTopology","initialProofState":"R : Type u_1\nτR : TopologicalSpace R\ninst✝⁴ : Semiring R\nC : Type u_4\ninst✝³ : AddCommGroup C\ninst✝² : Module R C\ninst✝¹ : TopologicalSpace C\ninst✝ : IsModuleTopology R C\n⊢ ContinuousNeg C","decl":"variable (R) in\ntheorem continuousNeg (C : Type*) [AddCommGroup C] [Module R C] [TopologicalSpace C]\n    [IsModuleTopology R C] : ContinuousNeg C where\n  continuous_neg := continuous_neg R C\n\n"}
{"name":"IsModuleTopology.topologicalAddGroup","module":"Mathlib.Topology.Algebra.Module.ModuleTopology","initialProofState":"R : Type u_1\nτR : TopologicalSpace R\ninst✝⁴ : Semiring R\nC : Type u_4\ninst✝³ : AddCommGroup C\ninst✝² : Module R C\ninst✝¹ : TopologicalSpace C\ninst✝ : IsModuleTopology R C\n⊢ TopologicalAddGroup C","decl":"variable (R) in\ntheorem topologicalAddGroup (C : Type*) [AddCommGroup C] [Module R C] [TopologicalSpace C]\n    [IsModuleTopology R C] : TopologicalAddGroup C where\n      continuous_add := (IsModuleTopology.toContinuousAdd R C).1\n      continuous_neg := continuous_neg R C\n\n"}
{"name":"IsModuleTopology.continuous_of_ringHom","module":"Mathlib.Topology.Algebra.Module.ModuleTopology","initialProofState":"R : Type u_4\nA : Type u_5\nB : Type u_6\ninst✝⁸ : CommSemiring R\ninst✝⁷ : Semiring A\ninst✝⁶ : Algebra R A\ninst✝⁵ : Semiring B\ninst✝⁴ : TopologicalSpace R\ninst✝³ : TopologicalSpace A\ninst✝² : IsModuleTopology R A\ninst✝¹ : TopologicalSpace B\ninst✝ : TopologicalSemiring B\nφ : RingHom A B\nhφ : Continuous ⇑(φ.comp (algebraMap R A))\n⊢ Continuous ⇑φ","decl":"@[fun_prop, continuity]\ntheorem continuous_of_ringHom {R A B} [CommSemiring R] [Semiring A] [Algebra R A] [Semiring B]\n    [TopologicalSpace R] [TopologicalSpace A] [IsModuleTopology R A] [TopologicalSpace B]\n    [TopologicalSemiring B]\n    (φ : A →+* B) (hφ : Continuous (φ.comp (algebraMap R A))) : Continuous φ := by\n  let inst := Module.compHom B (φ.comp (algebraMap R A))\n  let φ' : A →ₗ[R] B := ⟨φ, fun r m ↦ by simp [Algebra.smul_def]; rfl⟩\n  have : ContinuousSMul R B := ⟨(hφ.comp continuous_fst).mul continuous_snd⟩\n  exact continuous_of_linearMap φ'\n\n"}
{"name":"IsModuleTopology.isQuotientMap_of_surjective","module":"Mathlib.Topology.Algebra.Module.ModuleTopology","initialProofState":"R : Type u_1\nτR : TopologicalSpace R\ninst✝⁷ : Ring R\nA : Type u_2\ninst✝⁶ : AddCommGroup A\ninst✝⁵ : Module R A\ninst✝⁴ : TopologicalSpace A\ninst✝³ : IsModuleTopology R A\nB : Type u_3\ninst✝² : AddCommGroup B\ninst✝¹ : Module R B\nτB : TopologicalSpace B\ninst✝ : IsModuleTopology R B\nφ : LinearMap (RingHom.id R) A B\nhφ : Function.Surjective ⇑φ\n⊢ Topology.IsQuotientMap ⇑φ","decl":"open Topology in\n/-- A linear surjection between modules with the module topology is a quotient map.\nEquivalently, the pushforward of the module topology along a surjective linear map is\nagain the module topology. -/\ntheorem isQuotientMap_of_surjective [τB : TopologicalSpace B] [IsModuleTopology R B]\n    {φ : A →ₗ[R] B} (hφ : Function.Surjective φ) :\n    IsQuotientMap φ where\n  surjective := hφ\n  eq_coinduced := by\n    -- We need to prove that the topology on B is coinduced from that on A.\n    -- First tell the typeclass inference system that A and B are topological groups.\n    haveI := topologicalAddGroup R A\n    haveI := topologicalAddGroup R B\n    -- Because φ is linear, it's continuous for the module topologies (by a previous result).\n    have this : Continuous φ := continuous_of_linearMap φ\n    -- So the coinduced topology is finer than the module topology on B.\n    rw [continuous_iff_coinduced_le] at this\n    -- So STP the module topology on B is ≤ the topology coinduced from A\n    refine le_antisymm ?_ this\n    rw [eq_moduleTopology R B]\n    -- Now let's remove B's topology from the typeclass system\n    clear! τB\n    -- and replace it with the coinduced topology (which will be the same, but that's what we're\n    -- trying to prove). This means we don't have to fight with the typeclass system.\n    letI : TopologicalSpace B := .coinduced φ inferInstance\n    -- With this new topology on `B`, φ is a quotient map by definition,\n    -- and hence an open quotient map by a result in the library.\n    have hφo : IsOpenQuotientMap φ := AddMonoidHom.isOpenQuotientMap_of_isQuotientMap ⟨hφ, rfl⟩\n    -- We're trying to prove the module topology on B is ≤ the coinduced topology.\n    -- But recall that the module topology is the Inf of the topologies on B making addition\n    -- and scalar multiplication continuous, so it suffices to prove\n    -- that the coinduced topology on B has these properties.\n    refine sInf_le ⟨?_, ?_⟩\n    · -- In this branch, we prove that `• : R × B → B` is continuous for the coinduced topology.\n      apply ContinuousSMul.mk\n      -- We know that `• : R × A → A` is continuous, by assumption.\n      obtain ⟨hA⟩ : ContinuousSMul R A := inferInstance\n      /- By linearity of φ, this diagram commutes:\n        R × A --(•)--> A\n          |            |\n          |id × φ      |φ\n          |            |\n         \\/            \\/\n        R × B --(•)--> B\n      -/\n      have hφ2 : (fun p ↦ p.1 • p.2 : R × B → B) ∘ (Prod.map id φ) =\n        φ ∘ (fun p ↦ p.1 • p.2 : R × A → A) := by ext; simp\n      -- Furthermore, the identity from R to R is an open quotient map as is `φ`,\n      -- so the product `id × φ` is an open quotient map, by a result in the library.\n      have hoq : IsOpenQuotientMap (_ : R × A → R × B) := IsOpenQuotientMap.prodMap .id hφo\n      -- This is the left map in the diagram. So by a standard fact about open quotient maps,\n      -- to prove that the bottom map is continuous, it suffices to prove\n      -- that the diagonal map is continuous.\n      rw [← hoq.continuous_comp_iff]\n      -- but the diagonal is the composite of the continuous maps `φ` and `• : R × A → A`\n      rw [hφ2]\n      -- so we're done\n      exact Continuous.comp hφo.continuous hA\n    · /- In this branch we show that addition is continuous for the coinduced topology on `B`.\n        The argument is basically the same, this time using commutativity of\n        A × A --(+)--> A\n          |            |\n          |φ × φ       |φ\n          |            |\n         \\/            \\/\n        B × B --(+)--> B\n      -/\n      apply ContinuousAdd.mk\n      obtain ⟨hA⟩ := IsModuleTopology.toContinuousAdd R A\n      have hφ2 : (fun p ↦ p.1 + p.2 : B × B → B) ∘ (Prod.map φ φ) =\n        φ ∘ (fun p ↦ p.1 + p.2 : A × A → A) := by ext; simp\n      rw [← (IsOpenQuotientMap.prodMap hφo hφo).continuous_comp_iff, hφ2]\n      exact Continuous.comp hφo.continuous hA\n\n"}
{"name":"ModuleTopology.eq_coinduced_of_surjective","module":"Mathlib.Topology.Algebra.Module.ModuleTopology","initialProofState":"R : Type u_1\nτR : TopologicalSpace R\ninst✝⁶ : Ring R\nA : Type u_2\ninst✝⁵ : AddCommGroup A\ninst✝⁴ : Module R A\ninst✝³ : TopologicalSpace A\ninst✝² : IsModuleTopology R A\nB : Type u_3\ninst✝¹ : AddCommGroup B\ninst✝ : Module R B\nφ : LinearMap (RingHom.id R) A B\nhφ : Function.Surjective ⇑φ\n⊢ Eq (moduleTopology R B) (TopologicalSpace.coinduced (⇑φ) inferInstance)","decl":"lemma _root_.ModuleTopology.eq_coinduced_of_surjective\n    {φ : A →ₗ[R] B} (hφ : Function.Surjective φ) :\n    moduleTopology R B = TopologicalSpace.coinduced φ inferInstance := by\n  letI : TopologicalSpace B := moduleTopology R B\n  haveI : IsModuleTopology R B := ⟨rfl⟩\n  exact (isQuotientMap_of_surjective hφ).eq_coinduced\n\n"}
{"name":"IsModuleTopology.instProd","module":"Mathlib.Topology.Algebra.Module.ModuleTopology","initialProofState":"R : Type u_1\ninst✝⁷ : TopologicalSpace R\ninst✝⁶ : Semiring R\nM : Type u_2\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Module R M\ninst✝³ : TopologicalSpace M\nN : Type u_3\ninst✝² : AddCommMonoid N\ninst✝¹ : Module R N\ninst✝ : TopologicalSpace N\n⊢ IsModuleTopology R (Prod M N)","decl":"/-- The product of the module topologies for two modules over a topological ring\nis the module topology. -/\ninstance instProd : IsModuleTopology R (M × N) := by\n  constructor\n  have : ContinuousAdd M := toContinuousAdd R M\n  have : ContinuousAdd N := toContinuousAdd R N\n  -- In this proof, `M × N` always denotes the product with its *product* topology.\n  -- Addition `(M × N)² → M × N` and scalar multiplication `R × (M × N) → M × N`\n  -- are continuous for the product topology (by results in the library), so the module topology\n  -- on `M × N` is finer than the product topology (as it's the Inf of such topologies).\n  -- It thus remains to show that the product topology is finer than the module topology.\n  refine le_antisymm ?_ <| sInf_le ⟨Prod.continuousSMul, Prod.continuousAdd⟩\n  -- Or equivalently, if `P` denotes `M × N` with the module topology,\n  let P := M × N\n  let τP : TopologicalSpace P := moduleTopology R P\n  have : IsModuleTopology R P := ⟨rfl⟩\n  have : ContinuousAdd P := ModuleTopology.continuousAdd R P\n  -- and if `i` denotes the identity map from `M × N` to `P`\n  let i : M × N → P := id\n  -- then we need to show that `i` is continuous.\n  rw [← continuous_id_iff_le]\n  change @Continuous (M × N) P instTopologicalSpaceProd τP i\n  -- But `i` can be written as (m, n) ↦ (m, 0) + (0, n)\n  -- or equivalently as i₁ ∘ pr₁ + i₂ ∘ pr₂, where prᵢ are the projections,\n  -- the iⱼ's are linear inclusions M → P and N → P, and the addition is P × P → P.\n  let i₁ : M →ₗ[R] P := LinearMap.inl R M N\n  let i₂ : N →ₗ[R] P := LinearMap.inr R M N\n  rw [show (i : M × N → P) =\n       (fun abcd ↦ abcd.1 + abcd.2 : P × P → P) ∘\n       (fun ab ↦ (i₁ ab.1,i₂ ab.2)) by\n       ext ⟨a, b⟩ <;> aesop]\n  -- and these maps are all continuous, hence `i` is too\n  fun_prop\n\n"}
{"name":"IsModuleTopology.instPi","module":"Mathlib.Topology.Algebra.Module.ModuleTopology","initialProofState":"R : Type u_1\ninst✝⁴ : TopologicalSpace R\ninst✝³ : Semiring R\nι : Type u_2\nA : ι → Type u_3\ninst✝² : (i : ι) → AddCommMonoid (A i)\ninst✝¹ : (i : ι) → Module R (A i)\ninst✝ : (i : ι) → TopologicalSpace (A i)\n⊢ IsModuleTopology R ((i : ι) → A i)","decl":"/-- The product of the module topologies for a finite family of modules over a topological ring\nis the module topology. -/\ninstance instPi : IsModuleTopology R (∀ i, A i) := by\n  -- This is an easy induction on the size of the finite type, given the result\n  -- for binary products above. We use a \"decategorified\" induction principle for finite types.\n  induction ι using Finite.induction_empty_option\n  · -- invariance under equivalence of the finite type we're taking the product over\n    case of_equiv X Y e _ _ _ _ _ =>\n    exact iso (ContinuousLinearEquiv.piCongrLeft R A e)\n  · -- empty case\n    infer_instance\n  · -- \"inductive step\" is to check for product over `Option ι` case when known for product over `ι`\n    case h_option ι _ hind _ _ _ _ =>\n    -- `Option ι` is a `Sum` of `ι` and `Unit`\n    let e : Option ι ≃ ι ⊕ Unit := Equiv.optionEquivSumPUnit ι\n    -- so suffices to check for a product of modules over `ι ⊕ Unit`\n    suffices IsModuleTopology R ((i' : ι ⊕ Unit) → A (e.symm i')) from iso (.piCongrLeft R A e.symm)\n    -- but such a product is isomorphic to a binary product\n    -- of (product over `ι`) and (product over `Unit`)\n    suffices IsModuleTopology R\n      (((s : ι) → A (e.symm (Sum.inl s))) × ((t : Unit) → A (e.symm (Sum.inr t)))) from\n      iso (ContinuousLinearEquiv.sumPiEquivProdPi R ι Unit _).symm\n    -- The product over `ι` has the module topology by the inductive hypothesis,\n    -- and the product over `Unit` is just a module which is assumed to have the module topology\n    have := iso (ContinuousLinearEquiv.piUnique R (fun t ↦ A (e.symm (Sum.inr t)))).symm\n    -- so the result follows from the previous lemma (binary products).\n    infer_instance\n\n"}
