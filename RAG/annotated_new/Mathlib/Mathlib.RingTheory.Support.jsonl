{"name":"Module.mem_support_iff","module":"Mathlib.RingTheory.Support","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\np : PrimeSpectrum R\n⊢ Iff (Membership.mem (Module.support R M) p) (Nontrivial (LocalizedModule p.asIdeal.primeCompl M))","decl":"lemma Module.mem_support_iff :\n    p ∈ Module.support R M ↔ Nontrivial (LocalizedModule p.asIdeal.primeCompl M) := Iff.rfl\n\n"}
{"name":"Module.not_mem_support_iff","module":"Mathlib.RingTheory.Support","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\np : PrimeSpectrum R\n⊢ Iff (Not (Membership.mem (Module.support R M) p)) (Subsingleton (LocalizedModule p.asIdeal.primeCompl M))","decl":"lemma Module.not_mem_support_iff :\n    p ∉ Module.support R M ↔ Subsingleton (LocalizedModule p.asIdeal.primeCompl M) :=\n  not_nontrivial_iff_subsingleton\n\n"}
{"name":"Module.not_mem_support_iff'","module":"Mathlib.RingTheory.Support","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\np : PrimeSpectrum R\n⊢ Iff (Not (Membership.mem (Module.support R M) p)) (∀ (m : M), Exists fun r => And (Not (Membership.mem p.asIdeal r)) (Eq (HSMul.hSMul r m) 0))","decl":"lemma Module.not_mem_support_iff' :\n    p ∉ Module.support R M ↔ ∀ m : M, ∃ r ∉ p.asIdeal, r • m = 0 := by\n  simp only [not_mem_support_iff, Ideal.primeCompl, LocalizedModule.subsingleton_iff,\n    Submonoid.mem_mk, Subsemigroup.mem_mk, Set.mem_compl_iff, SetLike.mem_coe]\n\n"}
{"name":"Module.mem_support_iff'","module":"Mathlib.RingTheory.Support","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\np : PrimeSpectrum R\n⊢ Iff (Membership.mem (Module.support R M) p) (Exists fun m => ∀ (r : R), Not (Membership.mem p.asIdeal r) → Ne (HSMul.hSMul r m) 0)","decl":"lemma Module.mem_support_iff' :\n    p ∈ Module.support R M ↔ ∃ m : M, ∀ r ∉ p.asIdeal, r • m ≠ 0 := by\n  rw [← @not_not (_ ∈ _), not_mem_support_iff']\n  push_neg\n  rfl\n\n"}
{"name":"Module.mem_support_iff_exists_annihilator","module":"Mathlib.RingTheory.Support","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\np : PrimeSpectrum R\n⊢ Iff (Membership.mem (Module.support R M) p) (Exists fun m => LE.le (Submodule.span R (Singleton.singleton m)).annihilator p.asIdeal)","decl":"lemma Module.mem_support_iff_exists_annihilator :\n    p ∈ Module.support R M ↔ ∃ m : M, (R ∙ m).annihilator ≤ p.asIdeal := by\n  rw [Module.mem_support_iff']\n  simp_rw [not_imp_not, SetLike.le_def, Submodule.mem_annihilator_span_singleton]\n\n"}
{"name":"Module.mem_support_iff_of_span_eq_top","module":"Mathlib.RingTheory.Support","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\np : PrimeSpectrum R\ns : Set M\nhs : Eq (Submodule.span R s) Top.top\n⊢ Iff (Membership.mem (Module.support R M) p) (Exists fun m => And (Membership.mem s m) (LE.le (Submodule.span R (Singleton.singleton m)).annihilator p.asIdeal))","decl":"lemma Module.mem_support_iff_of_span_eq_top {s : Set M} (hs : Submodule.span R s = ⊤) :\n    p ∈ Module.support R M ↔ ∃ m ∈ s, (R ∙ m).annihilator ≤ p.asIdeal := by\n  constructor\n  · contrapose\n    rw [not_mem_support_iff, LocalizedModule.subsingleton_iff_ker_eq_top, ← top_le_iff,\n      ← hs, Submodule.span_le, Set.subset_def]\n    simp_rw [SetLike.le_def, Submodule.mem_annihilator_span_singleton, SetLike.mem_coe,\n      LocalizedModule.mem_ker_mkLinearMap_iff]\n    push_neg\n    simp_rw [and_comm]\n    exact id\n  · intro ⟨m, _, hm⟩\n    exact mem_support_iff_exists_annihilator.mpr ⟨m, hm⟩\n\n"}
{"name":"Module.annihilator_le_of_mem_support","module":"Mathlib.RingTheory.Support","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\np : PrimeSpectrum R\nhp : Membership.mem (Module.support R M) p\n⊢ LE.le (Module.annihilator R M) p.asIdeal","decl":"lemma Module.annihilator_le_of_mem_support (hp : p ∈ Module.support R M) :\n    Module.annihilator R M ≤ p.asIdeal := by\n  obtain ⟨m, hm⟩ := mem_support_iff_exists_annihilator.mp hp\n  exact le_trans ((Submodule.subtype _).annihilator_le_of_injective Subtype.val_injective) hm\n\n"}
{"name":"LocalizedModule.subsingleton_iff_support_subset","module":"Mathlib.RingTheory.Support","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nf : R\n⊢ Iff (Subsingleton (LocalizedModule (Submonoid.powers f) M)) (HasSubset.Subset (Module.support R M) (PrimeSpectrum.zeroLocus (Singleton.singleton f)))","decl":"lemma LocalizedModule.subsingleton_iff_support_subset {f : R} :\n    Subsingleton (LocalizedModule (.powers f) M) ↔\n      Module.support R M ⊆ PrimeSpectrum.zeroLocus {f} := by\n  rw [LocalizedModule.subsingleton_iff]\n  constructor\n  · rintro H x hx' f rfl\n    obtain ⟨m, hm⟩ := Module.mem_support_iff_exists_annihilator.mp hx'\n    obtain ⟨_, ⟨n, rfl⟩, e⟩ := H m\n    exact Ideal.IsPrime.mem_of_pow_mem inferInstance n\n      (hm ((Submodule.mem_annihilator_span_singleton _ _).mpr e))\n  · intro H m\n    by_cases h : (Submodule.span R {m}).annihilator = ⊤\n    · rw [Submodule.annihilator_eq_top_iff, Submodule.span_singleton_eq_bot] at h\n      exact ⟨1, one_mem _, by simpa using h⟩\n    obtain ⟨n, hn⟩ : f ∈ (Submodule.span R {m}).annihilator.radical := by\n      rw [Ideal.radical_eq_sInf, Ideal.mem_sInf]\n      rintro p ⟨hp, hp'⟩\n      simpa using H (Module.mem_support_iff_exists_annihilator (p := ⟨p, hp'⟩).mpr ⟨_, hp⟩)\n    exact ⟨_, ⟨n, rfl⟩, (Submodule.mem_annihilator_span_singleton _ _).mp hn⟩\n\n"}
{"name":"Module.support_eq_empty_iff","module":"Mathlib.RingTheory.Support","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\n⊢ Iff (Eq (Module.support R M) EmptyCollection.emptyCollection) (Subsingleton M)","decl":"lemma Module.support_eq_empty_iff :\n    Module.support R M = ∅ ↔ Subsingleton M := by\n  rw [← Set.subset_empty_iff, ← PrimeSpectrum.zeroLocus_singleton_one,\n    ← LocalizedModule.subsingleton_iff_support_subset, LocalizedModule.subsingleton_iff,\n    subsingleton_iff_forall_eq 0]\n  simp only [Submonoid.powers_one, Submonoid.mem_bot, exists_eq_left, one_smul]\n\n"}
{"name":"Module.support_eq_empty","module":"Mathlib.RingTheory.Support","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝³ : CommRing R\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : Subsingleton M\n⊢ Eq (Module.support R M) EmptyCollection.emptyCollection","decl":"lemma Module.support_eq_empty [Subsingleton M] :\n    Module.support R M = ∅ :=\n  Module.support_eq_empty_iff.mpr ‹_›\n\n"}
{"name":"Module.support_of_algebra","module":"Mathlib.RingTheory.Support","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nA : Type u_3\ninst✝¹ : Ring A\ninst✝ : Algebra R A\n⊢ Eq (Module.support R A) (PrimeSpectrum.zeroLocus ↑(RingHom.ker (algebraMap R A)))","decl":"lemma Module.support_of_algebra {A : Type*} [Ring A] [Algebra R A] :\n    Module.support R A = PrimeSpectrum.zeroLocus (RingHom.ker (algebraMap R A)) := by\n  ext p\n  simp only [mem_support_iff', ne_eq, PrimeSpectrum.mem_zeroLocus, SetLike.coe_subset_coe]\n  refine ⟨fun ⟨m, hm⟩ x hx ↦ not_not.mp fun hx' ↦ ?_, fun H ↦ ⟨1, fun r hr e ↦ ?_⟩⟩\n  · simpa [Algebra.smul_def, (show _ = _ from hx)] using hm _ hx'\n  · exact hr (H ((Algebra.algebraMap_eq_smul_one _).trans e))\n\n"}
{"name":"Module.support_of_noZeroSMulDivisors","module":"Mathlib.RingTheory.Support","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : NoZeroSMulDivisors R M\ninst✝ : Nontrivial M\n⊢ Eq (Module.support R M) Set.univ","decl":"lemma Module.support_of_noZeroSMulDivisors [NoZeroSMulDivisors R M] [Nontrivial M] :\n    Module.support R M = Set.univ := by\n  simp only [Set.eq_univ_iff_forall, mem_support_iff', ne_eq, smul_eq_zero, not_or]\n  obtain ⟨x, hx⟩ := exists_ne (0 : M)\n  exact fun p ↦ ⟨x, fun r hr ↦ ⟨fun e ↦ hr (e ▸ p.asIdeal.zero_mem), hx⟩⟩\n\n"}
{"name":"Module.mem_support_iff_of_finite","module":"Mathlib.RingTheory.Support","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝³ : CommRing R\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\np : PrimeSpectrum R\ninst✝ : Module.Finite R M\n⊢ Iff (Membership.mem (Module.support R M) p) (LE.le (Module.annihilator R M) p.asIdeal)","decl":"lemma Module.mem_support_iff_of_finite [Module.Finite R M] :\n    p ∈ Module.support R M ↔ Module.annihilator R M ≤ p.asIdeal := by\n  classical\n  obtain ⟨s, hs⟩ := ‹Module.Finite R M›\n  refine ⟨annihilator_le_of_mem_support, fun H ↦ (mem_support_iff_of_span_eq_top hs).mpr ?_⟩\n  simp only [SetLike.le_def, Submodule.mem_annihilator_span_singleton] at H ⊢\n  contrapose! H\n  choose x hx hx' using Subtype.forall'.mp H\n  refine ⟨s.attach.prod x, ?_, ?_⟩\n  · rw [← Submodule.annihilator_top, ← hs, Submodule.mem_annihilator_span]\n    intro m\n    obtain ⟨k, hk⟩ := Finset.dvd_prod_of_mem x (Finset.mem_attach _ m)\n    rw [hk, mul_comm, mul_smul, hx, smul_zero]\n  · exact p.asIdeal.primeCompl.prod_mem (fun x _ ↦ hx' x)\n\n"}
{"name":"Module.support_subset_of_injective","module":"Mathlib.RingTheory.Support","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\nN : Type u_3\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nf : LinearMap (RingHom.id R) M N\nhf : Function.Injective ⇑f\n⊢ HasSubset.Subset (Module.support R M) (Module.support R N)","decl":"lemma Module.support_subset_of_injective (hf : Function.Injective f) :\n    Module.support R M ⊆ Module.support R N := by\n  simp_rw [Set.subset_def, mem_support_iff']\n  rintro x ⟨m, hm⟩\n  exact ⟨f m, fun r hr ↦ by simpa using hf.ne (hm r hr)⟩\n\n"}
{"name":"Module.support_subset_of_surjective","module":"Mathlib.RingTheory.Support","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\nN : Type u_3\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nf : LinearMap (RingHom.id R) M N\nhf : Function.Surjective ⇑f\n⊢ HasSubset.Subset (Module.support R N) (Module.support R M)","decl":"lemma Module.support_subset_of_surjective (hf : Function.Surjective f) :\n    Module.support R N ⊆ Module.support R M := by\n  simp_rw [Set.subset_def, mem_support_iff']\n  rintro x ⟨m, hm⟩\n  obtain ⟨m, rfl⟩ := hf m\n  exact ⟨m, fun r hr e ↦ hm r hr (by simpa using congr(f $e))⟩\n\n"}
{"name":"Module.support_of_exact","module":"Mathlib.RingTheory.Support","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝⁶ : CommRing R\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\nN : Type u_3\nP : Type u_4\ninst✝³ : AddCommGroup N\ninst✝² : Module R N\ninst✝¹ : AddCommGroup P\ninst✝ : Module R P\nf : LinearMap (RingHom.id R) M N\ng : LinearMap (RingHom.id R) N P\nh : Function.Exact ⇑f ⇑g\nhf : Function.Injective ⇑f\nhg : Function.Surjective ⇑g\n⊢ Eq (Module.support R N) (Union.union (Module.support R M) (Module.support R P))","decl":"variable {f g} in\n/-- Given an exact sequence `0 → M → N → P → 0` of `R`-modules, `Supp N = Supp M ∪ Supp P`. -/\nlemma Module.support_of_exact (h : Function.Exact f g)\n    (hf : Function.Injective f) (hg : Function.Surjective g) :\n    Module.support R N = Module.support R M ∪ Module.support R P := by\n  refine subset_antisymm ?_ (Set.union_subset (Module.support_subset_of_injective f hf)\n    (Module.support_subset_of_surjective g hg))\n  intro x\n  contrapose\n  simp only [Set.mem_union, not_or, and_imp, not_mem_support_iff']\n  intro H₁ H₂ m\n  obtain ⟨r, hr, e₁⟩ := H₂ (g m)\n  rw [← map_smul, h] at e₁\n  obtain ⟨m', hm'⟩ := e₁\n  obtain ⟨s, hs, e₁⟩ := H₁ m'\n  exact ⟨_, x.asIdeal.primeCompl.mul_mem hs hr, by rw [mul_smul, ← hm', ← map_smul, e₁, map_zero]⟩\n\n"}
{"name":"LinearEquiv.support_eq","module":"Mathlib.RingTheory.Support","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\nN : Type u_3\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\ne : LinearEquiv (RingHom.id R) M N\n⊢ Eq (Module.support R M) (Module.support R N)","decl":"lemma LinearEquiv.support_eq (e : M ≃ₗ[R] N) :\n    Module.support R M = Module.support R N :=\n  (Module.support_subset_of_injective e.toLinearMap e.injective).antisymm\n    (Module.support_subset_of_surjective e.toLinearMap e.surjective)\n\n"}
{"name":"Module.support_eq_zeroLocus","module":"Mathlib.RingTheory.Support","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝³ : CommRing R\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : Module.Finite R M\n⊢ Eq (Module.support R M) (PrimeSpectrum.zeroLocus ↑(Module.annihilator R M))","decl":"/-- If `M` is `R`-finite, then `Supp M = Z(Ann(M))`. -/\nlemma Module.support_eq_zeroLocus [Module.Finite R M] :\n    Module.support R M = PrimeSpectrum.zeroLocus (Module.annihilator R M) :=\n  Set.ext fun _ ↦ mem_support_iff_of_finite\n\n"}
{"name":"LocalizedModule.exists_subsingleton_away","module":"Mathlib.RingTheory.Support","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝⁵ : CommRing R\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\ninst✝² : Module.Finite R M\np : Ideal R\ninst✝¹ : p.IsPrime\ninst✝ : Subsingleton (LocalizedModule p.primeCompl M)\n⊢ Exists fun f => And (Not (Membership.mem p f)) (Subsingleton (LocalizedModule (Submonoid.powers f) M))","decl":"/-- If `M` is a finite module such that `Mₚ = 0` for some `p`,\nthen `M[1/f] = 0` for some `p ∈ D(f)`. -/\nlemma LocalizedModule.exists_subsingleton_away [Module.Finite R M] (p : Ideal R) [p.IsPrime]\n    [Subsingleton (LocalizedModule p.primeCompl M)] :\n    ∃ f ∉ p, Subsingleton (LocalizedModule (.powers f) M) := by\n  have : ⟨p, inferInstance⟩ ∈ (Module.support R M)ᶜ := by\n    simpa [Module.not_mem_support_iff]\n  rw [Module.support_eq_zeroLocus, ← Set.biUnion_of_singleton (Module.annihilator R M : Set R),\n    PrimeSpectrum.zeroLocus_iUnion₂, Set.compl_iInter₂, Set.mem_iUnion₂] at this\n  obtain ⟨f, hf, hf'⟩ := this\n  exact ⟨f, by simpa using hf', subsingleton_iff.mpr\n    fun m ↦ ⟨f, Submonoid.mem_powers f, Module.mem_annihilator.mp hf _⟩⟩\n\n"}
