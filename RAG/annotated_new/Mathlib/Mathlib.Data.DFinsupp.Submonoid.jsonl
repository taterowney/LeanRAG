{"name":"dfinsupp_sum_mem","module":"Mathlib.Data.DFinsupp.Submonoid","initialProofState":"ι : Type u\nγ : Type w\nβ : ι → Type v\ninst✝⁵ : DecidableEq ι\ninst✝⁴ : (i : ι) → Zero (β i)\ninst✝³ : (i : ι) → (x : β i) → Decidable (Ne x 0)\ninst✝² : AddCommMonoid γ\nS : Type u_1\ninst✝¹ : SetLike S γ\ninst✝ : AddSubmonoidClass S γ\ns : S\nf : DFinsupp fun i => β i\ng : (i : ι) → β i → γ\nh : ∀ (c : ι), Ne (f c) 0 → Membership.mem s (g c (f c))\n⊢ Membership.mem s (f.sum g)","decl":"@[to_additive]\ntheorem dfinsupp_prod_mem [∀ i, Zero (β i)] [∀ (i) (x : β i), Decidable (x ≠ 0)]\n    [CommMonoid γ] {S : Type*} [SetLike S γ] [SubmonoidClass S γ]\n    (s : S) (f : Π₀ i, β i) (g : ∀ i, β i → γ)\n    (h : ∀ c, f c ≠ 0 → g c (f c) ∈ s) : f.prod g ∈ s :=\n  prod_mem fun _ hi => h _ <| mem_support_iff.1 hi\n\n"}
{"name":"dfinsupp_prod_mem","module":"Mathlib.Data.DFinsupp.Submonoid","initialProofState":"ι : Type u\nγ : Type w\nβ : ι → Type v\ninst✝⁵ : DecidableEq ι\ninst✝⁴ : (i : ι) → Zero (β i)\ninst✝³ : (i : ι) → (x : β i) → Decidable (Ne x 0)\ninst✝² : CommMonoid γ\nS : Type u_1\ninst✝¹ : SetLike S γ\ninst✝ : SubmonoidClass S γ\ns : S\nf : DFinsupp fun i => β i\ng : (i : ι) → β i → γ\nh : ∀ (c : ι), Ne (f c) 0 → Membership.mem s (g c (f c))\n⊢ Membership.mem s (f.prod g)","decl":"@[to_additive]\ntheorem dfinsupp_prod_mem [∀ i, Zero (β i)] [∀ (i) (x : β i), Decidable (x ≠ 0)]\n    [CommMonoid γ] {S : Type*} [SetLike S γ] [SubmonoidClass S γ]\n    (s : S) (f : Π₀ i, β i) (g : ∀ i, β i → γ)\n    (h : ∀ c, f c ≠ 0 → g c (f c) ∈ s) : f.prod g ∈ s :=\n  prod_mem fun _ hi => h _ <| mem_support_iff.1 hi\n\n"}
{"name":"dfinsupp_sumAddHom_mem","module":"Mathlib.Data.DFinsupp.Submonoid","initialProofState":"ι : Type u\nγ : Type w\nβ : ι → Type v\ninst✝⁴ : DecidableEq ι\ninst✝³ : (i : ι) → AddZeroClass (β i)\ninst✝² : AddCommMonoid γ\nS : Type u_1\ninst✝¹ : SetLike S γ\ninst✝ : AddSubmonoidClass S γ\ns : S\nf : DFinsupp fun i => β i\ng : (i : ι) → AddMonoidHom (β i) γ\nh : ∀ (c : ι), Ne (f c) 0 → Membership.mem s ((g c) (f c))\n⊢ Membership.mem s ((DFinsupp.sumAddHom g) f)","decl":"theorem dfinsupp_sumAddHom_mem [∀ i, AddZeroClass (β i)] [AddCommMonoid γ] {S : Type*}\n    [SetLike S γ] [AddSubmonoidClass S γ] (s : S) (f : Π₀ i, β i) (g : ∀ i, β i →+ γ)\n    (h : ∀ c, f c ≠ 0 → g c (f c) ∈ s) : DFinsupp.sumAddHom g f ∈ s := by\n  classical\n    rw [DFinsupp.sumAddHom_apply]\n    exact dfinsupp_sum_mem s f (g ·) h\n\n"}
{"name":"AddSubmonoid.iSup_eq_mrange_dfinsupp_sumAddHom","module":"Mathlib.Data.DFinsupp.Submonoid","initialProofState":"ι : Type u\nγ : Type w\ninst✝¹ : DecidableEq ι\ninst✝ : AddCommMonoid γ\nS : ι → AddSubmonoid γ\n⊢ Eq (iSup S) (AddMonoidHom.mrange (DFinsupp.sumAddHom fun i => (S i).subtype))","decl":"/-- The supremum of a family of commutative additive submonoids is equal to the range of\n`DFinsupp.sumAddHom`; that is, every element in the `iSup` can be produced from taking a finite\nnumber of non-zero elements of `S i`, coercing them to `γ`, and summing them. -/\ntheorem AddSubmonoid.iSup_eq_mrange_dfinsupp_sumAddHom\n    [AddCommMonoid γ] (S : ι → AddSubmonoid γ) :\n    iSup S = AddMonoidHom.mrange (DFinsupp.sumAddHom fun i => (S i).subtype) := by\n  apply le_antisymm\n  · apply iSup_le _\n    intro i y hy\n    exact ⟨DFinsupp.single i ⟨y, hy⟩, DFinsupp.sumAddHom_single _ _ _⟩\n  · rintro x ⟨v, rfl⟩\n    exact dfinsupp_sumAddHom_mem _ v _ fun i _ => (le_iSup S i : S i ≤ _) (v i).prop\n\n"}
{"name":"AddSubmonoid.bsupr_eq_mrange_dfinsupp_sumAddHom","module":"Mathlib.Data.DFinsupp.Submonoid","initialProofState":"ι : Type u\nγ : Type w\ninst✝² : DecidableEq ι\np : ι → Prop\ninst✝¹ : DecidablePred p\ninst✝ : AddCommMonoid γ\nS : ι → AddSubmonoid γ\n⊢ Eq (iSup fun i => iSup fun x => S i) (AddMonoidHom.mrange ((DFinsupp.sumAddHom fun i => (S i).subtype).comp (DFinsupp.filterAddMonoidHom (fun i => Subtype fun x => Membership.mem (S i) x) p)))","decl":"/-- The bounded supremum of a family of commutative additive submonoids is equal to the range of\n`DFinsupp.sumAddHom` composed with `DFinsupp.filterAddMonoidHom`; that is, every element in the\nbounded `iSup` can be produced from taking a finite number of non-zero elements from the `S i` that\nsatisfy `p i`, coercing them to `γ`, and summing them. -/\ntheorem AddSubmonoid.bsupr_eq_mrange_dfinsupp_sumAddHom (p : ι → Prop) [DecidablePred p]\n    [AddCommMonoid γ] (S : ι → AddSubmonoid γ) :\n    ⨆ (i) (_ : p i), S i =\n      AddMonoidHom.mrange ((sumAddHom fun i => (S i).subtype).comp (filterAddMonoidHom _ p)) := by\n  apply le_antisymm\n  · refine iSup₂_le fun i hi y hy => ⟨DFinsupp.single i ⟨y, hy⟩, ?_⟩\n    rw [AddMonoidHom.comp_apply, filterAddMonoidHom_apply, filter_single_pos _ _ hi]\n    exact sumAddHom_single _ _ _\n  · rintro x ⟨v, rfl⟩\n    refine dfinsupp_sumAddHom_mem _ _ _ fun i _ => ?_\n    refine AddSubmonoid.mem_iSup_of_mem i ?_\n    by_cases hp : p i\n    · simp [hp]\n    · simp [hp]\n\n"}
{"name":"AddSubmonoid.mem_iSup_iff_exists_dfinsupp","module":"Mathlib.Data.DFinsupp.Submonoid","initialProofState":"ι : Type u\nγ : Type w\ninst✝¹ : DecidableEq ι\ninst✝ : AddCommMonoid γ\nS : ι → AddSubmonoid γ\nx : γ\n⊢ Iff (Membership.mem (iSup S) x) (Exists fun f => Eq ((DFinsupp.sumAddHom fun i => (S i).subtype) f) x)","decl":"theorem AddSubmonoid.mem_iSup_iff_exists_dfinsupp [AddCommMonoid γ] (S : ι → AddSubmonoid γ)\n    (x : γ) : x ∈ iSup S ↔ ∃ f : Π₀ i, S i, DFinsupp.sumAddHom (fun i => (S i).subtype) f = x :=\n  SetLike.ext_iff.mp (AddSubmonoid.iSup_eq_mrange_dfinsupp_sumAddHom S) x\n\n"}
{"name":"AddSubmonoid.mem_iSup_iff_exists_dfinsupp'","module":"Mathlib.Data.DFinsupp.Submonoid","initialProofState":"ι : Type u\nγ : Type w\ninst✝² : DecidableEq ι\ninst✝¹ : AddCommMonoid γ\nS : ι → AddSubmonoid γ\ninst✝ : (i : ι) → (x : Subtype fun x => Membership.mem (S i) x) → Decidable (Ne x 0)\nx : γ\n⊢ Iff (Membership.mem (iSup S) x) (Exists fun f => Eq (f.sum fun x xi => ↑xi) x)","decl":"/-- A variant of `AddSubmonoid.mem_iSup_iff_exists_dfinsupp` with the RHS fully unfolded. -/\ntheorem AddSubmonoid.mem_iSup_iff_exists_dfinsupp' [AddCommMonoid γ] (S : ι → AddSubmonoid γ)\n    [∀ (i) (x : S i), Decidable (x ≠ 0)] (x : γ) :\n    x ∈ iSup S ↔ ∃ f : Π₀ i, S i, (f.sum fun _ xi => ↑xi) = x := by\n  rw [AddSubmonoid.mem_iSup_iff_exists_dfinsupp]\n  simp_rw [sumAddHom_apply]\n  rfl\n\n"}
{"name":"AddSubmonoid.mem_bsupr_iff_exists_dfinsupp","module":"Mathlib.Data.DFinsupp.Submonoid","initialProofState":"ι : Type u\nγ : Type w\ninst✝² : DecidableEq ι\np : ι → Prop\ninst✝¹ : DecidablePred p\ninst✝ : AddCommMonoid γ\nS : ι → AddSubmonoid γ\nx : γ\n⊢ Iff (Membership.mem (iSup fun i => iSup fun x => S i) x) (Exists fun f => Eq ((DFinsupp.sumAddHom fun i => (S i).subtype) (DFinsupp.filter p f)) x)","decl":"theorem AddSubmonoid.mem_bsupr_iff_exists_dfinsupp (p : ι → Prop) [DecidablePred p]\n    [AddCommMonoid γ] (S : ι → AddSubmonoid γ) (x : γ) :\n    (x ∈ ⨆ (i) (_ : p i), S i) ↔\n      ∃ f : Π₀ i, S i, DFinsupp.sumAddHom (fun i => (S i).subtype) (f.filter p) = x :=\n  SetLike.ext_iff.mp (AddSubmonoid.bsupr_eq_mrange_dfinsupp_sumAddHom p S) x\n"}
