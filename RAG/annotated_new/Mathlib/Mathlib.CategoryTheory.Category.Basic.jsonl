{"name":"CategoryTheory.Category.assoc","module":"Mathlib.CategoryTheory.Category.Basic","initialProofState":"obj : Type u\nself : CategoryTheory.Category.{v, u} obj\nW X Y Z : obj\nf : Quiver.Hom W X\ng : Quiver.Hom X Y\nh : Quiver.Hom Y Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.CategoryStruct.comp f g) h) (CategoryTheory.CategoryStruct.comp f (CategoryTheory.CategoryStruct.comp g h))","decl":"/-- The typeclass `Category C` describes morphisms associated to objects of type `C`.\nThe universe levels of the objects and morphisms are unconstrained, and will often need to be\nspecified explicitly, as `Category.{v} C`. (See also `LargeCategory` and `SmallCategory`.) -/\n@[pp_with_univ, stacks 0014]\nclass Category (obj : Type u) extends CategoryStruct.{v} obj : Type max u (v + 1) where\n  /-- Identity morphisms are left identities for composition. -/\n  id_comp : âˆ€ {X Y : obj} (f : X âŸ¶ Y), ğŸ™ X â‰« f = f := by aesop_cat\n  /-- Identity morphisms are right identities for composition. -/\n  comp_id : âˆ€ {X Y : obj} (f : X âŸ¶ Y), f â‰« ğŸ™ Y = f := by aesop_cat\n  /-- Composition in a category is associative. -/\n  assoc : âˆ€ {W X Y Z : obj} (f : W âŸ¶ X) (g : X âŸ¶ Y) (h : Y âŸ¶ Z), (f â‰« g) â‰« h = f â‰« g â‰« h := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.Category.comp_id","module":"Mathlib.CategoryTheory.Category.Basic","initialProofState":"obj : Type u\nself : CategoryTheory.Category.{v, u} obj\nX Y : obj\nf : Quiver.Hom X Y\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp f (CategoryTheory.CategoryStruct.id Y)) f","decl":"/-- The typeclass `Category C` describes morphisms associated to objects of type `C`.\nThe universe levels of the objects and morphisms are unconstrained, and will often need to be\nspecified explicitly, as `Category.{v} C`. (See also `LargeCategory` and `SmallCategory`.) -/\n@[pp_with_univ, stacks 0014]\nclass Category (obj : Type u) extends CategoryStruct.{v} obj : Type max u (v + 1) where\n  /-- Identity morphisms are left identities for composition. -/\n  id_comp : âˆ€ {X Y : obj} (f : X âŸ¶ Y), ğŸ™ X â‰« f = f := by aesop_cat\n  /-- Identity morphisms are right identities for composition. -/\n  comp_id : âˆ€ {X Y : obj} (f : X âŸ¶ Y), f â‰« ğŸ™ Y = f := by aesop_cat\n  /-- Composition in a category is associative. -/\n  assoc : âˆ€ {W X Y Z : obj} (f : W âŸ¶ X) (g : X âŸ¶ Y) (h : Y âŸ¶ Z), (f â‰« g) â‰« h = f â‰« g â‰« h := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.Category.id_comp","module":"Mathlib.CategoryTheory.Category.Basic","initialProofState":"obj : Type u\nself : CategoryTheory.Category.{v, u} obj\nX Y : obj\nf : Quiver.Hom X Y\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.CategoryStruct.id X) f) f","decl":"/-- The typeclass `Category C` describes morphisms associated to objects of type `C`.\nThe universe levels of the objects and morphisms are unconstrained, and will often need to be\nspecified explicitly, as `Category.{v} C`. (See also `LargeCategory` and `SmallCategory`.) -/\n@[pp_with_univ, stacks 0014]\nclass Category (obj : Type u) extends CategoryStruct.{v} obj : Type max u (v + 1) where\n  /-- Identity morphisms are left identities for composition. -/\n  id_comp : âˆ€ {X Y : obj} (f : X âŸ¶ Y), ğŸ™ X â‰« f = f := by aesop_cat\n  /-- Identity morphisms are right identities for composition. -/\n  comp_id : âˆ€ {X Y : obj} (f : X âŸ¶ Y), f â‰« ğŸ™ Y = f := by aesop_cat\n  /-- Composition in a category is associative. -/\n  assoc : âˆ€ {W X Y Z : obj} (f : W âŸ¶ X) (g : X âŸ¶ Y) (h : Y âŸ¶ Z), (f â‰« g) â‰« h = f â‰« g â‰« h := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.eq_whisker","module":"Mathlib.CategoryTheory.Category.Basic","initialProofState":"C : Type u\ninstâœ : CategoryTheory.Category.{v, u} C\nX Y Z : C\nf g : Quiver.Hom X Y\nw : Eq f g\nh : Quiver.Hom Y Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp f h) (CategoryTheory.CategoryStruct.comp g h)","decl":"/-- postcompose an equation between morphisms by another morphism -/\ntheorem eq_whisker {f g : X âŸ¶ Y} (w : f = g) (h : Y âŸ¶ Z) : f â‰« h = g â‰« h := by rw [w]\n\n"}
{"name":"CategoryTheory.whisker_eq","module":"Mathlib.CategoryTheory.Category.Basic","initialProofState":"C : Type u\ninstâœ : CategoryTheory.Category.{v, u} C\nX Y Z : C\nf : Quiver.Hom X Y\ng h : Quiver.Hom Y Z\nw : Eq g h\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp f g) (CategoryTheory.CategoryStruct.comp f h)","decl":"/-- precompose an equation between morphisms by another morphism -/\ntheorem whisker_eq (f : X âŸ¶ Y) {g h : Y âŸ¶ Z} (w : g = h) : f â‰« g = f â‰« h := by rw [w]\n\n"}
{"name":"CategoryTheory.eq_of_comp_left_eq","module":"Mathlib.CategoryTheory.Category.Basic","initialProofState":"C : Type u\ninstâœ : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\nw : âˆ€ {Z : C} (h : Quiver.Hom Y Z), Eq (CategoryTheory.CategoryStruct.comp f h) (CategoryTheory.CategoryStruct.comp g h)\nâŠ¢ Eq f g","decl":"theorem eq_of_comp_left_eq {f g : X âŸ¶ Y} (w : âˆ€ {Z : C} (h : Y âŸ¶ Z), f â‰« h = g â‰« h) :\n    f = g := by\n  convert w (ğŸ™ Y) <;> simp\n\n"}
{"name":"CategoryTheory.eq_of_comp_right_eq","module":"Mathlib.CategoryTheory.Category.Basic","initialProofState":"C : Type u\ninstâœ : CategoryTheory.Category.{v, u} C\nY Z : C\nf g : Quiver.Hom Y Z\nw : âˆ€ {X : C} (h : Quiver.Hom X Y), Eq (CategoryTheory.CategoryStruct.comp h f) (CategoryTheory.CategoryStruct.comp h g)\nâŠ¢ Eq f g","decl":"theorem eq_of_comp_right_eq {f g : Y âŸ¶ Z} (w : âˆ€ {X : C} (h : X âŸ¶ Y), h â‰« f = h â‰« g) :\n    f = g := by\n  convert w (ğŸ™ Y) <;> simp\n\n"}
{"name":"CategoryTheory.eq_of_comp_left_eq'","module":"Mathlib.CategoryTheory.Category.Basic","initialProofState":"C : Type u\ninstâœ : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\nw : Eq (fun {Z} h => CategoryTheory.CategoryStruct.comp f h) fun {Z} h => CategoryTheory.CategoryStruct.comp g h\nâŠ¢ Eq f g","decl":"theorem eq_of_comp_left_eq' (f g : X âŸ¶ Y)\n    (w : (fun {Z} (h : Y âŸ¶ Z) => f â‰« h) = fun {Z} (h : Y âŸ¶ Z) => g â‰« h) : f = g :=\n  eq_of_comp_left_eq @fun Z h => by convert congr_fun (congr_fun w Z) h\n\n"}
{"name":"CategoryTheory.eq_of_comp_right_eq'","module":"Mathlib.CategoryTheory.Category.Basic","initialProofState":"C : Type u\ninstâœ : CategoryTheory.Category.{v, u} C\nY Z : C\nf g : Quiver.Hom Y Z\nw : Eq (fun {X} h => CategoryTheory.CategoryStruct.comp h f) fun {X} h => CategoryTheory.CategoryStruct.comp h g\nâŠ¢ Eq f g","decl":"theorem eq_of_comp_right_eq' (f g : Y âŸ¶ Z)\n    (w : (fun {X} (h : X âŸ¶ Y) => h â‰« f) = fun {X} (h : X âŸ¶ Y) => h â‰« g) : f = g :=\n  eq_of_comp_right_eq @fun X h => by convert congr_fun (congr_fun w X) h\n\n"}
{"name":"CategoryTheory.id_of_comp_left_id","module":"Mathlib.CategoryTheory.Category.Basic","initialProofState":"C : Type u\ninstâœ : CategoryTheory.Category.{v, u} C\nX : C\nf : Quiver.Hom X X\nw : âˆ€ {Y : C} (g : Quiver.Hom X Y), Eq (CategoryTheory.CategoryStruct.comp f g) g\nâŠ¢ Eq f (CategoryTheory.CategoryStruct.id X)","decl":"theorem id_of_comp_left_id (f : X âŸ¶ X) (w : âˆ€ {Y : C} (g : X âŸ¶ Y), f â‰« g = g) : f = ğŸ™ X := by\n  convert w (ğŸ™ X)\n  simp\n\n"}
{"name":"CategoryTheory.id_of_comp_right_id","module":"Mathlib.CategoryTheory.Category.Basic","initialProofState":"C : Type u\ninstâœ : CategoryTheory.Category.{v, u} C\nX : C\nf : Quiver.Hom X X\nw : âˆ€ {Y : C} (g : Quiver.Hom Y X), Eq (CategoryTheory.CategoryStruct.comp g f) g\nâŠ¢ Eq f (CategoryTheory.CategoryStruct.id X)","decl":"theorem id_of_comp_right_id (f : X âŸ¶ X) (w : âˆ€ {Y : C} (g : Y âŸ¶ X), g â‰« f = g) : f = ğŸ™ X := by\n  convert w (ğŸ™ X)\n  simp\n\n"}
{"name":"CategoryTheory.comp_ite","module":"Mathlib.CategoryTheory.Category.Basic","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nP : Prop\ninstâœ : Decidable P\nX Y Z : C\nf : Quiver.Hom X Y\ng g' : Quiver.Hom Y Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp f (ite P g g')) (ite P (CategoryTheory.CategoryStruct.comp f g) (CategoryTheory.CategoryStruct.comp f g'))","decl":"theorem comp_ite {P : Prop} [Decidable P] {X Y Z : C} (f : X âŸ¶ Y) (g g' : Y âŸ¶ Z) :\n    (f â‰« if P then g else g') = if P then f â‰« g else f â‰« g' := by aesop\n\n"}
{"name":"CategoryTheory.ite_comp","module":"Mathlib.CategoryTheory.Category.Basic","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nP : Prop\ninstâœ : Decidable P\nX Y Z : C\nf f' : Quiver.Hom X Y\ng : Quiver.Hom Y Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (ite P f f') g) (ite P (CategoryTheory.CategoryStruct.comp f g) (CategoryTheory.CategoryStruct.comp f' g))","decl":"theorem ite_comp {P : Prop} [Decidable P] {X Y Z : C} (f f' : X âŸ¶ Y) (g : Y âŸ¶ Z) :\n    (if P then f else f') â‰« g = if P then f â‰« g else f' â‰« g := by aesop\n\n"}
{"name":"CategoryTheory.comp_dite","module":"Mathlib.CategoryTheory.Category.Basic","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nP : Prop\ninstâœ : Decidable P\nX Y Z : C\nf : Quiver.Hom X Y\ng : P â†’ Quiver.Hom Y Z\ng' : Not P â†’ Quiver.Hom Y Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp f (dite P (fun h => g h) fun h => g' h)) (dite P (fun h => CategoryTheory.CategoryStruct.comp f (g h)) fun h => CategoryTheory.CategoryStruct.comp f (g' h))","decl":"theorem comp_dite {P : Prop} [Decidable P]\n    {X Y Z : C} (f : X âŸ¶ Y) (g : P â†’ (Y âŸ¶ Z)) (g' : Â¬P â†’ (Y âŸ¶ Z)) :\n    (f â‰« if h : P then g h else g' h) = if h : P then f â‰« g h else f â‰« g' h := by aesop\n\n"}
{"name":"CategoryTheory.dite_comp","module":"Mathlib.CategoryTheory.Category.Basic","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nP : Prop\ninstâœ : Decidable P\nX Y Z : C\nf : P â†’ Quiver.Hom X Y\nf' : Not P â†’ Quiver.Hom X Y\ng : Quiver.Hom Y Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (dite P (fun h => f h) fun h => f' h) g) (dite P (fun h => CategoryTheory.CategoryStruct.comp (f h) g) fun h => CategoryTheory.CategoryStruct.comp (f' h) g)","decl":"theorem dite_comp {P : Prop} [Decidable P]\n    {X Y Z : C} (f : P â†’ (X âŸ¶ Y)) (f' : Â¬P â†’ (X âŸ¶ Y)) (g : Y âŸ¶ Z) :\n    (if h : P then f h else f' h) â‰« g = if h : P then f h â‰« g else f' h â‰« g := by aesop\n\n"}
{"name":"CategoryTheory.Epi.left_cancellation","module":"Mathlib.CategoryTheory.Category.Basic","initialProofState":"C : Type u\ninstâœ : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\nself : CategoryTheory.Epi f\nZ : C\ng h : Quiver.Hom Y Z\naâœ : Eq (CategoryTheory.CategoryStruct.comp f g) (CategoryTheory.CategoryStruct.comp f h)\nâŠ¢ Eq g h","decl":"/-- A morphism `f` is an epimorphism if it can be cancelled when precomposed:\n`f â‰« g = f â‰« h` implies `g = h`. -/\n@[stacks 003B]\nclass Epi (f : X âŸ¶ Y) : Prop where\n  /-- A morphism `f` is an epimorphism if it can be cancelled when precomposed. -/\n  left_cancellation : âˆ€ {Z : C} (g h : Y âŸ¶ Z), f â‰« g = f â‰« h â†’ g = h\n\n"}
{"name":"CategoryTheory.Mono.right_cancellation","module":"Mathlib.CategoryTheory.Category.Basic","initialProofState":"C : Type u\ninstâœ : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\nself : CategoryTheory.Mono f\nZ : C\ng h : Quiver.Hom Z X\naâœ : Eq (CategoryTheory.CategoryStruct.comp g f) (CategoryTheory.CategoryStruct.comp h f)\nâŠ¢ Eq g h","decl":"/-- A morphism `f` is a monomorphism if it can be cancelled when postcomposed:\n`g â‰« f = h â‰« f` implies `g = h`. -/\n@[stacks 003B]\nclass Mono (f : X âŸ¶ Y) : Prop where\n  /-- A morphism `f` is a monomorphism if it can be cancelled when postcomposed. -/\n  right_cancellation : âˆ€ {Z : C} (g h : Z âŸ¶ X), g â‰« f = h â‰« f â†’ g = h\n\n"}
{"name":"CategoryTheory.instEpiId","module":"Mathlib.CategoryTheory.Category.Basic","initialProofState":"C : Type u\ninstâœ : CategoryTheory.Category.{v, u} C\nX : C\nâŠ¢ CategoryTheory.Epi (CategoryTheory.CategoryStruct.id X)","decl":"instance (X : C) : Epi (ğŸ™ X) :=\n  âŸ¨fun g h w => by aesopâŸ©\n\n"}
{"name":"CategoryTheory.instMonoId","module":"Mathlib.CategoryTheory.Category.Basic","initialProofState":"C : Type u\ninstâœ : CategoryTheory.Category.{v, u} C\nX : C\nâŠ¢ CategoryTheory.Mono (CategoryTheory.CategoryStruct.id X)","decl":"instance (X : C) : Mono (ğŸ™ X) :=\n  âŸ¨fun g h w => by aesopâŸ©\n\n"}
{"name":"CategoryTheory.cancel_epi","module":"Mathlib.CategoryTheory.Category.Basic","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nX Y Z : C\nf : Quiver.Hom X Y\ninstâœ : CategoryTheory.Epi f\ng h : Quiver.Hom Y Z\nâŠ¢ Iff (Eq (CategoryTheory.CategoryStruct.comp f g) (CategoryTheory.CategoryStruct.comp f h)) (Eq g h)","decl":"theorem cancel_epi (f : X âŸ¶ Y) [Epi f] {g h : Y âŸ¶ Z} : f â‰« g = f â‰« h â†” g = h :=\n  âŸ¨fun p => Epi.left_cancellation g h p, congr_arg _âŸ©\n\n"}
{"name":"CategoryTheory.cancel_epi_assoc_iff","module":"Mathlib.CategoryTheory.Category.Basic","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nX Y Z : C\nf : Quiver.Hom X Y\ninstâœ : CategoryTheory.Epi f\ng h : Quiver.Hom Y Z\nW : C\nk l : Quiver.Hom Z W\nâŠ¢ Iff (Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.CategoryStruct.comp f g) k) (CategoryTheory.CategoryStruct.comp (CategoryTheory.CategoryStruct.comp f h) l)) (Eq (CategoryTheory.CategoryStruct.comp g k) (CategoryTheory.CategoryStruct.comp h l))","decl":"theorem cancel_epi_assoc_iff (f : X âŸ¶ Y) [Epi f] {g h : Y âŸ¶ Z} {W : C} {k l : Z âŸ¶ W} :\n    (f â‰« g) â‰« k = (f â‰« h) â‰« l â†” g â‰« k = h â‰« l :=\n  âŸ¨fun p => (cancel_epi f).1 <| by simpa using p, fun p => by simp only [Category.assoc, p]âŸ©\n\n"}
{"name":"CategoryTheory.cancel_mono","module":"Mathlib.CategoryTheory.Category.Basic","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nX Y Z : C\nf : Quiver.Hom X Y\ninstâœ : CategoryTheory.Mono f\ng h : Quiver.Hom Z X\nâŠ¢ Iff (Eq (CategoryTheory.CategoryStruct.comp g f) (CategoryTheory.CategoryStruct.comp h f)) (Eq g h)","decl":"theorem cancel_mono (f : X âŸ¶ Y) [Mono f] {g h : Z âŸ¶ X} : g â‰« f = h â‰« f â†” g = h :=\n  -- Porting note: in Lean 3 we could just write `congr_arg _` here.\n  âŸ¨fun p => Mono.right_cancellation g h p, congr_arg (fun k => k â‰« f)âŸ©\n\n"}
{"name":"CategoryTheory.cancel_mono_assoc_iff","module":"Mathlib.CategoryTheory.Category.Basic","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nX Y Z : C\nf : Quiver.Hom X Y\ninstâœ : CategoryTheory.Mono f\ng h : Quiver.Hom Z X\nW : C\nk l : Quiver.Hom W Z\nâŠ¢ Iff (Eq (CategoryTheory.CategoryStruct.comp k (CategoryTheory.CategoryStruct.comp g f)) (CategoryTheory.CategoryStruct.comp l (CategoryTheory.CategoryStruct.comp h f))) (Eq (CategoryTheory.CategoryStruct.comp k g) (CategoryTheory.CategoryStruct.comp l h))","decl":"theorem cancel_mono_assoc_iff (f : X âŸ¶ Y) [Mono f] {g h : Z âŸ¶ X} {W : C} {k l : W âŸ¶ Z} :\n    k â‰« (g â‰« f) = l â‰« (h â‰« f) â†” k â‰« g = l â‰« h :=\n  âŸ¨fun p => (cancel_mono f).1 <| by simpa using p, fun p => by simp only [â† Category.assoc, p]âŸ©\n\n"}
{"name":"CategoryTheory.cancel_epi_id","module":"Mathlib.CategoryTheory.Category.Basic","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\ninstâœ : CategoryTheory.Epi f\nh : Quiver.Hom Y Y\nâŠ¢ Iff (Eq (CategoryTheory.CategoryStruct.comp f h) f) (Eq h (CategoryTheory.CategoryStruct.id Y))","decl":"theorem cancel_epi_id (f : X âŸ¶ Y) [Epi f] {h : Y âŸ¶ Y} : f â‰« h = f â†” h = ğŸ™ Y := by\n  convert cancel_epi f\n  simp\n\n"}
{"name":"CategoryTheory.cancel_mono_id","module":"Mathlib.CategoryTheory.Category.Basic","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\ninstâœ : CategoryTheory.Mono f\ng : Quiver.Hom X X\nâŠ¢ Iff (Eq (CategoryTheory.CategoryStruct.comp g f) f) (Eq g (CategoryTheory.CategoryStruct.id X))","decl":"theorem cancel_mono_id (f : X âŸ¶ Y) [Mono f] {g : X âŸ¶ X} : g â‰« f = f â†” g = ğŸ™ X := by\n  convert cancel_mono f\n  simp\n\n"}
{"name":"CategoryTheory.epi_comp","module":"Mathlib.CategoryTheory.Category.Basic","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nX Y Z : C\nf : Quiver.Hom X Y\ninstâœÂ¹ : CategoryTheory.Epi f\ng : Quiver.Hom Y Z\ninstâœ : CategoryTheory.Epi g\nâŠ¢ CategoryTheory.Epi (CategoryTheory.CategoryStruct.comp f g)","decl":"instance epi_comp {X Y Z : C} (f : X âŸ¶ Y) [Epi f] (g : Y âŸ¶ Z) [Epi g] : Epi (f â‰« g) :=\n  âŸ¨fun _ _ w => (cancel_epi g).1 <| (cancel_epi_assoc_iff f).1 wâŸ©\n\n"}
{"name":"CategoryTheory.mono_comp","module":"Mathlib.CategoryTheory.Category.Basic","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nX Y Z : C\nf : Quiver.Hom X Y\ninstâœÂ¹ : CategoryTheory.Mono f\ng : Quiver.Hom Y Z\ninstâœ : CategoryTheory.Mono g\nâŠ¢ CategoryTheory.Mono (CategoryTheory.CategoryStruct.comp f g)","decl":"instance mono_comp {X Y Z : C} (f : X âŸ¶ Y) [Mono f] (g : Y âŸ¶ Z) [Mono g] : Mono (f â‰« g) :=\n  âŸ¨fun _ _ w => (cancel_mono f).1 <| (cancel_mono_assoc_iff g).1 wâŸ©\n\n"}
{"name":"CategoryTheory.mono_of_mono","module":"Mathlib.CategoryTheory.Category.Basic","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nX Y Z : C\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\ninstâœ : CategoryTheory.Mono (CategoryTheory.CategoryStruct.comp f g)\nâŠ¢ CategoryTheory.Mono f","decl":"theorem mono_of_mono {X Y Z : C} (f : X âŸ¶ Y) (g : Y âŸ¶ Z) [Mono (f â‰« g)] : Mono f :=\n  âŸ¨fun _ _ w => (cancel_mono (f â‰« g)).1 <| by simp only [â† Category.assoc, w]âŸ©\n\n"}
{"name":"CategoryTheory.mono_of_mono_fac","module":"Mathlib.CategoryTheory.Category.Basic","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nX Y Z : C\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\nh : Quiver.Hom X Z\ninstâœ : CategoryTheory.Mono h\nw : Eq (CategoryTheory.CategoryStruct.comp f g) h\nâŠ¢ CategoryTheory.Mono f","decl":"theorem mono_of_mono_fac {X Y Z : C} {f : X âŸ¶ Y} {g : Y âŸ¶ Z} {h : X âŸ¶ Z} [Mono h]\n    (w : f â‰« g = h) : Mono f := by\n  subst h; exact mono_of_mono f g\n\n"}
{"name":"CategoryTheory.epi_of_epi","module":"Mathlib.CategoryTheory.Category.Basic","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nX Y Z : C\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\ninstâœ : CategoryTheory.Epi (CategoryTheory.CategoryStruct.comp f g)\nâŠ¢ CategoryTheory.Epi g","decl":"theorem epi_of_epi {X Y Z : C} (f : X âŸ¶ Y) (g : Y âŸ¶ Z) [Epi (f â‰« g)] : Epi g :=\n  âŸ¨fun _ _ w => (cancel_epi (f â‰« g)).1 <| by simp only [Category.assoc, w]âŸ©\n\n"}
{"name":"CategoryTheory.epi_of_epi_fac","module":"Mathlib.CategoryTheory.Category.Basic","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nX Y Z : C\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\nh : Quiver.Hom X Z\ninstâœ : CategoryTheory.Epi h\nw : Eq (CategoryTheory.CategoryStruct.comp f g) h\nâŠ¢ CategoryTheory.Epi g","decl":"theorem epi_of_epi_fac {X Y Z : C} {f : X âŸ¶ Y} {g : Y âŸ¶ Z} {h : X âŸ¶ Z} [Epi h]\n    (w : f â‰« g = h) : Epi g := by\n  subst h; exact epi_of_epi f g\n\n"}
{"name":"CategoryTheory.instMono","module":"Mathlib.CategoryTheory.Category.Basic","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nX Y : C\ninstâœ : Quiver.IsThin C\nf : Quiver.Hom X Y\nâŠ¢ CategoryTheory.Mono f","decl":"instance : Mono f where\n  right_cancellation _ _ _ := Subsingleton.elim _ _\n\n"}
{"name":"CategoryTheory.instEpi","module":"Mathlib.CategoryTheory.Category.Basic","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nX Y : C\ninstâœ : Quiver.IsThin C\nf : Quiver.Hom X Y\nâŠ¢ CategoryTheory.Epi f","decl":"instance : Epi f where\n  left_cancellation _ _ _ := Subsingleton.elim _ _\n\n"}
