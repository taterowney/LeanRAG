{"name":"CategoryTheory.Category.assoc","module":"Mathlib.CategoryTheory.Category.Basic","initialProofState":"obj : Type u\nself : CategoryTheory.Category.{v, u} obj\nW X Y Z : obj\nf : Quiver.Hom W X\ng : Quiver.Hom X Y\nh : Quiver.Hom Y Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.CategoryStruct.comp f g) h) (CategoryTheory.CategoryStruct.comp f (CategoryTheory.CategoryStruct.comp g h))","decl":"/-- The typeclass `Category C` describes morphisms associated to objects of type `C`.\nThe universe levels of the objects and morphisms are unconstrained, and will often need to be\nspecified explicitly, as `Category.{v} C`. (See also `LargeCategory` and `SmallCategory`.) -/\n@[pp_with_univ, stacks 0014]\nclass Category (obj : Type u) extends CategoryStruct.{v} obj : Type max u (v + 1) where\n  /-- Identity morphisms are left identities for composition. -/\n  id_comp : ∀ {X Y : obj} (f : X ⟶ Y), 𝟙 X ≫ f = f := by aesop_cat\n  /-- Identity morphisms are right identities for composition. -/\n  comp_id : ∀ {X Y : obj} (f : X ⟶ Y), f ≫ 𝟙 Y = f := by aesop_cat\n  /-- Composition in a category is associative. -/\n  assoc : ∀ {W X Y Z : obj} (f : W ⟶ X) (g : X ⟶ Y) (h : Y ⟶ Z), (f ≫ g) ≫ h = f ≫ g ≫ h := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.Category.comp_id","module":"Mathlib.CategoryTheory.Category.Basic","initialProofState":"obj : Type u\nself : CategoryTheory.Category.{v, u} obj\nX Y : obj\nf : Quiver.Hom X Y\n⊢ Eq (CategoryTheory.CategoryStruct.comp f (CategoryTheory.CategoryStruct.id Y)) f","decl":"/-- The typeclass `Category C` describes morphisms associated to objects of type `C`.\nThe universe levels of the objects and morphisms are unconstrained, and will often need to be\nspecified explicitly, as `Category.{v} C`. (See also `LargeCategory` and `SmallCategory`.) -/\n@[pp_with_univ, stacks 0014]\nclass Category (obj : Type u) extends CategoryStruct.{v} obj : Type max u (v + 1) where\n  /-- Identity morphisms are left identities for composition. -/\n  id_comp : ∀ {X Y : obj} (f : X ⟶ Y), 𝟙 X ≫ f = f := by aesop_cat\n  /-- Identity morphisms are right identities for composition. -/\n  comp_id : ∀ {X Y : obj} (f : X ⟶ Y), f ≫ 𝟙 Y = f := by aesop_cat\n  /-- Composition in a category is associative. -/\n  assoc : ∀ {W X Y Z : obj} (f : W ⟶ X) (g : X ⟶ Y) (h : Y ⟶ Z), (f ≫ g) ≫ h = f ≫ g ≫ h := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.Category.id_comp","module":"Mathlib.CategoryTheory.Category.Basic","initialProofState":"obj : Type u\nself : CategoryTheory.Category.{v, u} obj\nX Y : obj\nf : Quiver.Hom X Y\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.CategoryStruct.id X) f) f","decl":"/-- The typeclass `Category C` describes morphisms associated to objects of type `C`.\nThe universe levels of the objects and morphisms are unconstrained, and will often need to be\nspecified explicitly, as `Category.{v} C`. (See also `LargeCategory` and `SmallCategory`.) -/\n@[pp_with_univ, stacks 0014]\nclass Category (obj : Type u) extends CategoryStruct.{v} obj : Type max u (v + 1) where\n  /-- Identity morphisms are left identities for composition. -/\n  id_comp : ∀ {X Y : obj} (f : X ⟶ Y), 𝟙 X ≫ f = f := by aesop_cat\n  /-- Identity morphisms are right identities for composition. -/\n  comp_id : ∀ {X Y : obj} (f : X ⟶ Y), f ≫ 𝟙 Y = f := by aesop_cat\n  /-- Composition in a category is associative. -/\n  assoc : ∀ {W X Y Z : obj} (f : W ⟶ X) (g : X ⟶ Y) (h : Y ⟶ Z), (f ≫ g) ≫ h = f ≫ g ≫ h := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.eq_whisker","module":"Mathlib.CategoryTheory.Category.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y Z : C\nf g : Quiver.Hom X Y\nw : Eq f g\nh : Quiver.Hom Y Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp f h) (CategoryTheory.CategoryStruct.comp g h)","decl":"/-- postcompose an equation between morphisms by another morphism -/\ntheorem eq_whisker {f g : X ⟶ Y} (w : f = g) (h : Y ⟶ Z) : f ≫ h = g ≫ h := by rw [w]\n\n"}
{"name":"CategoryTheory.whisker_eq","module":"Mathlib.CategoryTheory.Category.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y Z : C\nf : Quiver.Hom X Y\ng h : Quiver.Hom Y Z\nw : Eq g h\n⊢ Eq (CategoryTheory.CategoryStruct.comp f g) (CategoryTheory.CategoryStruct.comp f h)","decl":"/-- precompose an equation between morphisms by another morphism -/\ntheorem whisker_eq (f : X ⟶ Y) {g h : Y ⟶ Z} (w : g = h) : f ≫ g = f ≫ h := by rw [w]\n\n"}
{"name":"CategoryTheory.eq_of_comp_left_eq","module":"Mathlib.CategoryTheory.Category.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\nw : ∀ {Z : C} (h : Quiver.Hom Y Z), Eq (CategoryTheory.CategoryStruct.comp f h) (CategoryTheory.CategoryStruct.comp g h)\n⊢ Eq f g","decl":"theorem eq_of_comp_left_eq {f g : X ⟶ Y} (w : ∀ {Z : C} (h : Y ⟶ Z), f ≫ h = g ≫ h) :\n    f = g := by\n  convert w (𝟙 Y) <;> simp\n\n"}
{"name":"CategoryTheory.eq_of_comp_right_eq","module":"Mathlib.CategoryTheory.Category.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nY Z : C\nf g : Quiver.Hom Y Z\nw : ∀ {X : C} (h : Quiver.Hom X Y), Eq (CategoryTheory.CategoryStruct.comp h f) (CategoryTheory.CategoryStruct.comp h g)\n⊢ Eq f g","decl":"theorem eq_of_comp_right_eq {f g : Y ⟶ Z} (w : ∀ {X : C} (h : X ⟶ Y), h ≫ f = h ≫ g) :\n    f = g := by\n  convert w (𝟙 Y) <;> simp\n\n"}
{"name":"CategoryTheory.eq_of_comp_left_eq'","module":"Mathlib.CategoryTheory.Category.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\nw : Eq (fun {Z} h => CategoryTheory.CategoryStruct.comp f h) fun {Z} h => CategoryTheory.CategoryStruct.comp g h\n⊢ Eq f g","decl":"theorem eq_of_comp_left_eq' (f g : X ⟶ Y)\n    (w : (fun {Z} (h : Y ⟶ Z) => f ≫ h) = fun {Z} (h : Y ⟶ Z) => g ≫ h) : f = g :=\n  eq_of_comp_left_eq @fun Z h => by convert congr_fun (congr_fun w Z) h\n\n"}
{"name":"CategoryTheory.eq_of_comp_right_eq'","module":"Mathlib.CategoryTheory.Category.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nY Z : C\nf g : Quiver.Hom Y Z\nw : Eq (fun {X} h => CategoryTheory.CategoryStruct.comp h f) fun {X} h => CategoryTheory.CategoryStruct.comp h g\n⊢ Eq f g","decl":"theorem eq_of_comp_right_eq' (f g : Y ⟶ Z)\n    (w : (fun {X} (h : X ⟶ Y) => h ≫ f) = fun {X} (h : X ⟶ Y) => h ≫ g) : f = g :=\n  eq_of_comp_right_eq @fun X h => by convert congr_fun (congr_fun w X) h\n\n"}
{"name":"CategoryTheory.id_of_comp_left_id","module":"Mathlib.CategoryTheory.Category.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX : C\nf : Quiver.Hom X X\nw : ∀ {Y : C} (g : Quiver.Hom X Y), Eq (CategoryTheory.CategoryStruct.comp f g) g\n⊢ Eq f (CategoryTheory.CategoryStruct.id X)","decl":"theorem id_of_comp_left_id (f : X ⟶ X) (w : ∀ {Y : C} (g : X ⟶ Y), f ≫ g = g) : f = 𝟙 X := by\n  convert w (𝟙 X)\n  simp\n\n"}
{"name":"CategoryTheory.id_of_comp_right_id","module":"Mathlib.CategoryTheory.Category.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX : C\nf : Quiver.Hom X X\nw : ∀ {Y : C} (g : Quiver.Hom Y X), Eq (CategoryTheory.CategoryStruct.comp g f) g\n⊢ Eq f (CategoryTheory.CategoryStruct.id X)","decl":"theorem id_of_comp_right_id (f : X ⟶ X) (w : ∀ {Y : C} (g : Y ⟶ X), g ≫ f = g) : f = 𝟙 X := by\n  convert w (𝟙 X)\n  simp\n\n"}
{"name":"CategoryTheory.comp_ite","module":"Mathlib.CategoryTheory.Category.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nP : Prop\ninst✝ : Decidable P\nX Y Z : C\nf : Quiver.Hom X Y\ng g' : Quiver.Hom Y Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp f (ite P g g')) (ite P (CategoryTheory.CategoryStruct.comp f g) (CategoryTheory.CategoryStruct.comp f g'))","decl":"theorem comp_ite {P : Prop} [Decidable P] {X Y Z : C} (f : X ⟶ Y) (g g' : Y ⟶ Z) :\n    (f ≫ if P then g else g') = if P then f ≫ g else f ≫ g' := by aesop\n\n"}
{"name":"CategoryTheory.ite_comp","module":"Mathlib.CategoryTheory.Category.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nP : Prop\ninst✝ : Decidable P\nX Y Z : C\nf f' : Quiver.Hom X Y\ng : Quiver.Hom Y Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (ite P f f') g) (ite P (CategoryTheory.CategoryStruct.comp f g) (CategoryTheory.CategoryStruct.comp f' g))","decl":"theorem ite_comp {P : Prop} [Decidable P] {X Y Z : C} (f f' : X ⟶ Y) (g : Y ⟶ Z) :\n    (if P then f else f') ≫ g = if P then f ≫ g else f' ≫ g := by aesop\n\n"}
{"name":"CategoryTheory.comp_dite","module":"Mathlib.CategoryTheory.Category.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nP : Prop\ninst✝ : Decidable P\nX Y Z : C\nf : Quiver.Hom X Y\ng : P → Quiver.Hom Y Z\ng' : Not P → Quiver.Hom Y Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp f (dite P (fun h => g h) fun h => g' h)) (dite P (fun h => CategoryTheory.CategoryStruct.comp f (g h)) fun h => CategoryTheory.CategoryStruct.comp f (g' h))","decl":"theorem comp_dite {P : Prop} [Decidable P]\n    {X Y Z : C} (f : X ⟶ Y) (g : P → (Y ⟶ Z)) (g' : ¬P → (Y ⟶ Z)) :\n    (f ≫ if h : P then g h else g' h) = if h : P then f ≫ g h else f ≫ g' h := by aesop\n\n"}
{"name":"CategoryTheory.dite_comp","module":"Mathlib.CategoryTheory.Category.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nP : Prop\ninst✝ : Decidable P\nX Y Z : C\nf : P → Quiver.Hom X Y\nf' : Not P → Quiver.Hom X Y\ng : Quiver.Hom Y Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (dite P (fun h => f h) fun h => f' h) g) (dite P (fun h => CategoryTheory.CategoryStruct.comp (f h) g) fun h => CategoryTheory.CategoryStruct.comp (f' h) g)","decl":"theorem dite_comp {P : Prop} [Decidable P]\n    {X Y Z : C} (f : P → (X ⟶ Y)) (f' : ¬P → (X ⟶ Y)) (g : Y ⟶ Z) :\n    (if h : P then f h else f' h) ≫ g = if h : P then f h ≫ g else f' h ≫ g := by aesop\n\n"}
{"name":"CategoryTheory.Epi.left_cancellation","module":"Mathlib.CategoryTheory.Category.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\nself : CategoryTheory.Epi f\nZ : C\ng h : Quiver.Hom Y Z\na✝ : Eq (CategoryTheory.CategoryStruct.comp f g) (CategoryTheory.CategoryStruct.comp f h)\n⊢ Eq g h","decl":"/-- A morphism `f` is an epimorphism if it can be cancelled when precomposed:\n`f ≫ g = f ≫ h` implies `g = h`. -/\n@[stacks 003B]\nclass Epi (f : X ⟶ Y) : Prop where\n  /-- A morphism `f` is an epimorphism if it can be cancelled when precomposed. -/\n  left_cancellation : ∀ {Z : C} (g h : Y ⟶ Z), f ≫ g = f ≫ h → g = h\n\n"}
{"name":"CategoryTheory.Mono.right_cancellation","module":"Mathlib.CategoryTheory.Category.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\nself : CategoryTheory.Mono f\nZ : C\ng h : Quiver.Hom Z X\na✝ : Eq (CategoryTheory.CategoryStruct.comp g f) (CategoryTheory.CategoryStruct.comp h f)\n⊢ Eq g h","decl":"/-- A morphism `f` is a monomorphism if it can be cancelled when postcomposed:\n`g ≫ f = h ≫ f` implies `g = h`. -/\n@[stacks 003B]\nclass Mono (f : X ⟶ Y) : Prop where\n  /-- A morphism `f` is a monomorphism if it can be cancelled when postcomposed. -/\n  right_cancellation : ∀ {Z : C} (g h : Z ⟶ X), g ≫ f = h ≫ f → g = h\n\n"}
{"name":"CategoryTheory.instEpiId","module":"Mathlib.CategoryTheory.Category.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX : C\n⊢ CategoryTheory.Epi (CategoryTheory.CategoryStruct.id X)","decl":"instance (X : C) : Epi (𝟙 X) :=\n  ⟨fun g h w => by aesop⟩\n\n"}
{"name":"CategoryTheory.instMonoId","module":"Mathlib.CategoryTheory.Category.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX : C\n⊢ CategoryTheory.Mono (CategoryTheory.CategoryStruct.id X)","decl":"instance (X : C) : Mono (𝟙 X) :=\n  ⟨fun g h w => by aesop⟩\n\n"}
{"name":"CategoryTheory.cancel_epi","module":"Mathlib.CategoryTheory.Category.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX Y Z : C\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.Epi f\ng h : Quiver.Hom Y Z\n⊢ Iff (Eq (CategoryTheory.CategoryStruct.comp f g) (CategoryTheory.CategoryStruct.comp f h)) (Eq g h)","decl":"theorem cancel_epi (f : X ⟶ Y) [Epi f] {g h : Y ⟶ Z} : f ≫ g = f ≫ h ↔ g = h :=\n  ⟨fun p => Epi.left_cancellation g h p, congr_arg _⟩\n\n"}
{"name":"CategoryTheory.cancel_epi_assoc_iff","module":"Mathlib.CategoryTheory.Category.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX Y Z : C\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.Epi f\ng h : Quiver.Hom Y Z\nW : C\nk l : Quiver.Hom Z W\n⊢ Iff (Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.CategoryStruct.comp f g) k) (CategoryTheory.CategoryStruct.comp (CategoryTheory.CategoryStruct.comp f h) l)) (Eq (CategoryTheory.CategoryStruct.comp g k) (CategoryTheory.CategoryStruct.comp h l))","decl":"theorem cancel_epi_assoc_iff (f : X ⟶ Y) [Epi f] {g h : Y ⟶ Z} {W : C} {k l : Z ⟶ W} :\n    (f ≫ g) ≫ k = (f ≫ h) ≫ l ↔ g ≫ k = h ≫ l :=\n  ⟨fun p => (cancel_epi f).1 <| by simpa using p, fun p => by simp only [Category.assoc, p]⟩\n\n"}
{"name":"CategoryTheory.cancel_mono","module":"Mathlib.CategoryTheory.Category.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX Y Z : C\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.Mono f\ng h : Quiver.Hom Z X\n⊢ Iff (Eq (CategoryTheory.CategoryStruct.comp g f) (CategoryTheory.CategoryStruct.comp h f)) (Eq g h)","decl":"theorem cancel_mono (f : X ⟶ Y) [Mono f] {g h : Z ⟶ X} : g ≫ f = h ≫ f ↔ g = h :=\n  -- Porting note: in Lean 3 we could just write `congr_arg _` here.\n  ⟨fun p => Mono.right_cancellation g h p, congr_arg (fun k => k ≫ f)⟩\n\n"}
{"name":"CategoryTheory.cancel_mono_assoc_iff","module":"Mathlib.CategoryTheory.Category.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX Y Z : C\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.Mono f\ng h : Quiver.Hom Z X\nW : C\nk l : Quiver.Hom W Z\n⊢ Iff (Eq (CategoryTheory.CategoryStruct.comp k (CategoryTheory.CategoryStruct.comp g f)) (CategoryTheory.CategoryStruct.comp l (CategoryTheory.CategoryStruct.comp h f))) (Eq (CategoryTheory.CategoryStruct.comp k g) (CategoryTheory.CategoryStruct.comp l h))","decl":"theorem cancel_mono_assoc_iff (f : X ⟶ Y) [Mono f] {g h : Z ⟶ X} {W : C} {k l : W ⟶ Z} :\n    k ≫ (g ≫ f) = l ≫ (h ≫ f) ↔ k ≫ g = l ≫ h :=\n  ⟨fun p => (cancel_mono f).1 <| by simpa using p, fun p => by simp only [← Category.assoc, p]⟩\n\n"}
{"name":"CategoryTheory.cancel_epi_id","module":"Mathlib.CategoryTheory.Category.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.Epi f\nh : Quiver.Hom Y Y\n⊢ Iff (Eq (CategoryTheory.CategoryStruct.comp f h) f) (Eq h (CategoryTheory.CategoryStruct.id Y))","decl":"theorem cancel_epi_id (f : X ⟶ Y) [Epi f] {h : Y ⟶ Y} : f ≫ h = f ↔ h = 𝟙 Y := by\n  convert cancel_epi f\n  simp\n\n"}
{"name":"CategoryTheory.cancel_mono_id","module":"Mathlib.CategoryTheory.Category.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.Mono f\ng : Quiver.Hom X X\n⊢ Iff (Eq (CategoryTheory.CategoryStruct.comp g f) f) (Eq g (CategoryTheory.CategoryStruct.id X))","decl":"theorem cancel_mono_id (f : X ⟶ Y) [Mono f] {g : X ⟶ X} : g ≫ f = f ↔ g = 𝟙 X := by\n  convert cancel_mono f\n  simp\n\n"}
{"name":"CategoryTheory.epi_comp","module":"Mathlib.CategoryTheory.Category.Basic","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nX Y Z : C\nf : Quiver.Hom X Y\ninst✝¹ : CategoryTheory.Epi f\ng : Quiver.Hom Y Z\ninst✝ : CategoryTheory.Epi g\n⊢ CategoryTheory.Epi (CategoryTheory.CategoryStruct.comp f g)","decl":"instance epi_comp {X Y Z : C} (f : X ⟶ Y) [Epi f] (g : Y ⟶ Z) [Epi g] : Epi (f ≫ g) :=\n  ⟨fun _ _ w => (cancel_epi g).1 <| (cancel_epi_assoc_iff f).1 w⟩\n\n"}
{"name":"CategoryTheory.mono_comp","module":"Mathlib.CategoryTheory.Category.Basic","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nX Y Z : C\nf : Quiver.Hom X Y\ninst✝¹ : CategoryTheory.Mono f\ng : Quiver.Hom Y Z\ninst✝ : CategoryTheory.Mono g\n⊢ CategoryTheory.Mono (CategoryTheory.CategoryStruct.comp f g)","decl":"instance mono_comp {X Y Z : C} (f : X ⟶ Y) [Mono f] (g : Y ⟶ Z) [Mono g] : Mono (f ≫ g) :=\n  ⟨fun _ _ w => (cancel_mono f).1 <| (cancel_mono_assoc_iff g).1 w⟩\n\n"}
{"name":"CategoryTheory.mono_of_mono","module":"Mathlib.CategoryTheory.Category.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX Y Z : C\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\ninst✝ : CategoryTheory.Mono (CategoryTheory.CategoryStruct.comp f g)\n⊢ CategoryTheory.Mono f","decl":"theorem mono_of_mono {X Y Z : C} (f : X ⟶ Y) (g : Y ⟶ Z) [Mono (f ≫ g)] : Mono f :=\n  ⟨fun _ _ w => (cancel_mono (f ≫ g)).1 <| by simp only [← Category.assoc, w]⟩\n\n"}
{"name":"CategoryTheory.mono_of_mono_fac","module":"Mathlib.CategoryTheory.Category.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX Y Z : C\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\nh : Quiver.Hom X Z\ninst✝ : CategoryTheory.Mono h\nw : Eq (CategoryTheory.CategoryStruct.comp f g) h\n⊢ CategoryTheory.Mono f","decl":"theorem mono_of_mono_fac {X Y Z : C} {f : X ⟶ Y} {g : Y ⟶ Z} {h : X ⟶ Z} [Mono h]\n    (w : f ≫ g = h) : Mono f := by\n  subst h; exact mono_of_mono f g\n\n"}
{"name":"CategoryTheory.epi_of_epi","module":"Mathlib.CategoryTheory.Category.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX Y Z : C\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\ninst✝ : CategoryTheory.Epi (CategoryTheory.CategoryStruct.comp f g)\n⊢ CategoryTheory.Epi g","decl":"theorem epi_of_epi {X Y Z : C} (f : X ⟶ Y) (g : Y ⟶ Z) [Epi (f ≫ g)] : Epi g :=\n  ⟨fun _ _ w => (cancel_epi (f ≫ g)).1 <| by simp only [Category.assoc, w]⟩\n\n"}
{"name":"CategoryTheory.epi_of_epi_fac","module":"Mathlib.CategoryTheory.Category.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX Y Z : C\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\nh : Quiver.Hom X Z\ninst✝ : CategoryTheory.Epi h\nw : Eq (CategoryTheory.CategoryStruct.comp f g) h\n⊢ CategoryTheory.Epi g","decl":"theorem epi_of_epi_fac {X Y Z : C} {f : X ⟶ Y} {g : Y ⟶ Z} {h : X ⟶ Z} [Epi h]\n    (w : f ≫ g = h) : Epi g := by\n  subst h; exact epi_of_epi f g\n\n"}
{"name":"CategoryTheory.instMono","module":"Mathlib.CategoryTheory.Category.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX Y : C\ninst✝ : Quiver.IsThin C\nf : Quiver.Hom X Y\n⊢ CategoryTheory.Mono f","decl":"instance : Mono f where\n  right_cancellation _ _ _ := Subsingleton.elim _ _\n\n"}
{"name":"CategoryTheory.instEpi","module":"Mathlib.CategoryTheory.Category.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX Y : C\ninst✝ : Quiver.IsThin C\nf : Quiver.Hom X Y\n⊢ CategoryTheory.Epi f","decl":"instance : Epi f where\n  left_cancellation _ _ _ := Subsingleton.elim _ _\n\n"}
