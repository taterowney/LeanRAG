{"name":"Polynomial.dickson_zero","module":"Mathlib.RingTheory.Polynomial.Dickson","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nk : Nat\na : R\n⊢ Eq (Polynomial.dickson k a 0) (HSub.hSub 3 ↑k)","decl":"@[simp]\ntheorem dickson_zero : dickson k a 0 = 3 - k :=\n  rfl\n\n"}
{"name":"Polynomial.dickson_one","module":"Mathlib.RingTheory.Polynomial.Dickson","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nk : Nat\na : R\n⊢ Eq (Polynomial.dickson k a 1) Polynomial.X","decl":"@[simp]\ntheorem dickson_one : dickson k a 1 = X :=\n  rfl\n\n"}
{"name":"Polynomial.dickson_two","module":"Mathlib.RingTheory.Polynomial.Dickson","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nk : Nat\na : R\n⊢ Eq (Polynomial.dickson k a 2) (HSub.hSub (HPow.hPow Polynomial.X 2) (HMul.hMul (Polynomial.C a) (HSub.hSub 3 ↑k)))","decl":"theorem dickson_two : dickson k a 2 = X ^ 2 - C a * (3 - k : R[X]) := by\n  simp only [dickson, sq]\n\n"}
{"name":"Polynomial.dickson_add_two","module":"Mathlib.RingTheory.Polynomial.Dickson","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nk : Nat\na : R\nn : Nat\n⊢ Eq (Polynomial.dickson k a (HAdd.hAdd n 2)) (HSub.hSub (HMul.hMul Polynomial.X (Polynomial.dickson k a (HAdd.hAdd n 1))) (HMul.hMul (Polynomial.C a) (Polynomial.dickson k a n)))","decl":"@[simp]\ntheorem dickson_add_two (n : ℕ) :\n    dickson k a (n + 2) = X * dickson k a (n + 1) - C a * dickson k a n := by rw [dickson]\n\n"}
{"name":"Polynomial.dickson_of_two_le","module":"Mathlib.RingTheory.Polynomial.Dickson","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nk : Nat\na : R\nn : Nat\nh : LE.le 2 n\n⊢ Eq (Polynomial.dickson k a n) (HSub.hSub (HMul.hMul Polynomial.X (Polynomial.dickson k a (HSub.hSub n 1))) (HMul.hMul (Polynomial.C a) (Polynomial.dickson k a (HSub.hSub n 2))))","decl":"theorem dickson_of_two_le {n : ℕ} (h : 2 ≤ n) :\n    dickson k a n = X * dickson k a (n - 1) - C a * dickson k a (n - 2) := by\n  obtain ⟨n, rfl⟩ := Nat.exists_eq_add_of_le h\n  rw [add_comm]\n  exact dickson_add_two k a n\n\n"}
{"name":"Polynomial.map_dickson","module":"Mathlib.RingTheory.Polynomial.Dickson","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝¹ : CommRing R\ninst✝ : CommRing S\nk : Nat\na : R\nf : RingHom R S\nn : Nat\n⊢ Eq (Polynomial.map f (Polynomial.dickson k a n)) (Polynomial.dickson k (f a) n)","decl":"theorem map_dickson (f : R →+* S) : ∀ n : ℕ, map f (dickson k a n) = dickson k (f a) n\n  | 0 => by\n    simp_rw [dickson_zero, Polynomial.map_sub, Polynomial.map_natCast, Polynomial.map_ofNat]\n  | 1 => by simp only [dickson_one, map_X]\n  | n + 2 => by\n    simp only [dickson_add_two, Polynomial.map_sub, Polynomial.map_mul, map_X, map_C]\n    rw [map_dickson f n, map_dickson f (n + 1)]\n\n"}
{"name":"Polynomial.dickson_two_zero","module":"Mathlib.RingTheory.Polynomial.Dickson","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nn : Nat\n⊢ Eq (Polynomial.dickson 2 0 n) (HPow.hPow Polynomial.X n)","decl":"@[simp]\ntheorem dickson_two_zero : ∀ n : ℕ, dickson 2 (0 : R) n = X ^ n\n  | 0 => by\n    simp only [dickson_zero, pow_zero]\n    norm_num\n  | 1 => by simp only [dickson_one, pow_one]\n  | n + 2 => by\n    simp only [dickson_add_two, C_0, zero_mul, sub_zero]\n    rw [dickson_two_zero (n + 1), pow_add X (n + 1) 1, mul_comm, pow_one]\n\n"}
{"name":"Polynomial.dickson_one_one_eval_add_inv","module":"Mathlib.RingTheory.Polynomial.Dickson","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nx y : R\nh : Eq (HMul.hMul x y) 1\nn : Nat\n⊢ Eq (Polynomial.eval (HAdd.hAdd x y) (Polynomial.dickson 1 1 n)) (HAdd.hAdd (HPow.hPow x n) (HPow.hPow y n))","decl":"theorem dickson_one_one_eval_add_inv (x y : R) (h : x * y = 1) :\n    ∀ n, (dickson 1 (1 : R) n).eval (x + y) = x ^ n + y ^ n\n  | 0 => by\n    simp only [eval_one, eval_add, pow_zero, dickson_zero]; norm_num\n  | 1 => by simp only [eval_X, dickson_one, pow_one]\n  | n + 2 => by\n    simp only [eval_sub, eval_mul, dickson_one_one_eval_add_inv x y h _, eval_X, dickson_add_two,\n      C_1, eval_one]\n    conv_lhs => simp only [pow_succ', add_mul, mul_add, h, ← mul_assoc, mul_comm y x, one_mul]\n    ring\n\n"}
{"name":"Polynomial.dickson_one_one_eq_chebyshev_C","module":"Mathlib.RingTheory.Polynomial.Dickson","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nn : Nat\n⊢ Eq (Polynomial.dickson 1 1 n) (Polynomial.Chebyshev.C R ↑n)","decl":"theorem dickson_one_one_eq_chebyshev_C : ∀ n, dickson 1 (1 : R) n = Chebyshev.C R n\n  | 0 => by\n    simp only [Chebyshev.C_zero, mul_one, one_comp, dickson_zero]\n    norm_num\n  | 1 => by\n    rw [dickson_one, Nat.cast_one, Chebyshev.C_one]\n  | n + 2 => by\n    rw [dickson_add_two, C_1, Nat.cast_add, Nat.cast_two, Chebyshev.C_add_two,\n      dickson_one_one_eq_chebyshev_C (n + 1), dickson_one_one_eq_chebyshev_C n]\n    push_cast\n    ring\n\n"}
{"name":"Polynomial.dickson_one_one_eq_chebyshev_T","module":"Mathlib.RingTheory.Polynomial.Dickson","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\ninst✝ : Invertible 2\nn : Nat\n⊢ Eq (Polynomial.dickson 1 1 n) (HMul.hMul 2 ((Polynomial.Chebyshev.T R ↑n).comp (HMul.hMul (Polynomial.C (Invertible.invOf 2)) Polynomial.X)))","decl":"theorem dickson_one_one_eq_chebyshev_T [Invertible (2 : R)] (n : ℕ) :\n    dickson 1 (1 : R) n = 2 * (Chebyshev.T R n).comp (C (⅟ 2) * X) :=\n  (dickson_one_one_eq_chebyshev_C R n).trans (Chebyshev.C_eq_two_mul_T_comp_half_mul_X R n)\n\n"}
{"name":"Polynomial.chebyshev_T_eq_dickson_one_one","module":"Mathlib.RingTheory.Polynomial.Dickson","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\ninst✝ : Invertible 2\nn : Nat\n⊢ Eq (Polynomial.Chebyshev.T R ↑n) (HMul.hMul (Polynomial.C (Invertible.invOf 2)) ((Polynomial.dickson 1 1 n).comp (HMul.hMul 2 Polynomial.X)))","decl":"theorem chebyshev_T_eq_dickson_one_one [Invertible (2 : R)] (n : ℕ) :\n    Chebyshev.T R n = C (⅟ 2) * (dickson 1 1 n).comp (2 * X) :=\n  dickson_one_one_eq_chebyshev_C R n ▸ Chebyshev.T_eq_half_mul_C_comp_two_mul_X R n\n\n"}
{"name":"Polynomial.dickson_two_one_eq_chebyshev_S","module":"Mathlib.RingTheory.Polynomial.Dickson","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nn : Nat\n⊢ Eq (Polynomial.dickson 2 1 n) (Polynomial.Chebyshev.S R ↑n)","decl":"theorem dickson_two_one_eq_chebyshev_S : ∀ n, dickson 2 (1 : R) n = Chebyshev.S R n\n  | 0 => by\n    simp only [Chebyshev.S_zero, mul_one, one_comp, dickson_zero]\n    norm_num\n  | 1 => by\n    rw [dickson_one, Nat.cast_one, Chebyshev.S_one]\n  | n + 2 => by\n    rw [dickson_add_two, C_1, Nat.cast_add, Nat.cast_two, Chebyshev.S_add_two,\n      dickson_two_one_eq_chebyshev_S (n + 1), dickson_two_one_eq_chebyshev_S n]\n    push_cast\n    ring\n\n"}
{"name":"Polynomial.dickson_two_one_eq_chebyshev_U","module":"Mathlib.RingTheory.Polynomial.Dickson","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\ninst✝ : Invertible 2\nn : Nat\n⊢ Eq (Polynomial.dickson 2 1 n) ((Polynomial.Chebyshev.U R ↑n).comp (HMul.hMul (Polynomial.C (Invertible.invOf 2)) Polynomial.X))","decl":"theorem dickson_two_one_eq_chebyshev_U [Invertible (2 : R)] (n : ℕ) :\n    dickson 2 (1 : R) n = (Chebyshev.U R n).comp (C (⅟ 2) * X) :=\n  (dickson_two_one_eq_chebyshev_S R n).trans (Chebyshev.S_eq_U_comp_half_mul_X R n)\n\n"}
{"name":"Polynomial.chebyshev_U_eq_dickson_two_one","module":"Mathlib.RingTheory.Polynomial.Dickson","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nn : Nat\n⊢ Eq (Polynomial.Chebyshev.U R ↑n) ((Polynomial.dickson 2 1 n).comp (HMul.hMul 2 Polynomial.X))","decl":"theorem chebyshev_U_eq_dickson_two_one (n : ℕ) :\n    Chebyshev.U R n = (dickson 2 (1 : R) n).comp (2 * X) :=\n  dickson_two_one_eq_chebyshev_S R n ▸ (Chebyshev.S_comp_two_mul_X R n).symm\n\n"}
{"name":"Polynomial.dickson_one_one_mul","module":"Mathlib.RingTheory.Polynomial.Dickson","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nm n : Nat\n⊢ Eq (Polynomial.dickson 1 1 (HMul.hMul m n)) ((Polynomial.dickson 1 1 m).comp (Polynomial.dickson 1 1 n))","decl":"/-- The `(m * n)`-th Dickson polynomial of the first kind is the composition of the `m`-th and\n`n`-th. -/\ntheorem dickson_one_one_mul (m n : ℕ) :\n    dickson 1 (1 : R) (m * n) = (dickson 1 1 m).comp (dickson 1 1 n) := by\n  have h : (1 : R) = Int.castRingHom R 1 := by simp only [eq_intCast, Int.cast_one]\n  rw [h]\n  simp only [← map_dickson (Int.castRingHom R), ← map_comp]\n  congr 1\n  apply map_injective (Int.castRingHom ℚ) Int.cast_injective\n  simp only [map_dickson, map_comp, eq_intCast, Int.cast_one, dickson_one_one_eq_chebyshev_T,\n    Nat.cast_mul, Chebyshev.T_mul, two_mul, ← add_comp]\n  simp only [← two_mul, ← comp_assoc]\n  apply eval₂_congr rfl rfl\n  rw [comp_assoc]\n  apply eval₂_congr rfl _ rfl\n  rw [mul_comp, C_comp, X_comp, ← mul_assoc, C_half_mul_two_eq_one, one_mul]\n\n"}
{"name":"Polynomial.dickson_one_one_comp_comm","module":"Mathlib.RingTheory.Polynomial.Dickson","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nm n : Nat\n⊢ Eq ((Polynomial.dickson 1 1 m).comp (Polynomial.dickson 1 1 n)) ((Polynomial.dickson 1 1 n).comp (Polynomial.dickson 1 1 m))","decl":"theorem dickson_one_one_comp_comm (m n : ℕ) :\n    (dickson 1 (1 : R) m).comp (dickson 1 1 n) = (dickson 1 1 n).comp (dickson 1 1 m) := by\n  rw [← dickson_one_one_mul, mul_comm, dickson_one_one_mul]\n\n"}
{"name":"Polynomial.dickson_one_one_zmod_p","module":"Mathlib.RingTheory.Polynomial.Dickson","initialProofState":"p : Nat\ninst✝ : Fact (Nat.Prime p)\n⊢ Eq (Polynomial.dickson 1 1 p) (HPow.hPow Polynomial.X p)","decl":"theorem dickson_one_one_zmod_p (p : ℕ) [Fact p.Prime] : dickson 1 (1 : ZMod p) p = X ^ p := by\n  -- Recall that `dickson_one_one_eval_add_inv` characterises `dickson 1 1 p`\n  -- as a polynomial that maps `x + x⁻¹` to `x ^ p + (x⁻¹) ^ p`.\n  -- Since `X ^ p` also satisfies this property in characteristic `p`,\n  -- we can use a variant on `Polynomial.funext` to conclude that these polynomials are equal.\n  -- For this argument, we need an arbitrary infinite field of characteristic `p`.\n  obtain ⟨K, _, _, H⟩ : ∃ (K : Type) (_ : Field K), ∃ _ : CharP K p, Infinite K := by\n    let K := FractionRing (Polynomial (ZMod p))\n    let f : ZMod p →+* K := (algebraMap _ (FractionRing _)).comp C\n    have : CharP K p := by\n      rw [← f.charP_iff_charP]\n      infer_instance\n    haveI : Infinite K :=\n      Infinite.of_injective (algebraMap (Polynomial (ZMod p)) (FractionRing (Polynomial (ZMod p))))\n        (IsFractionRing.injective _ _)\n    refine ⟨K, ?_, ?_, ?_⟩ <;> infer_instance\n  apply map_injective (ZMod.castHom (dvd_refl p) K) (RingHom.injective _)\n  rw [map_dickson, Polynomial.map_pow, map_X]\n  apply eq_of_infinite_eval_eq\n  -- The two polynomials agree on all `x` of the form `x = y + y⁻¹`.\n  apply @Set.Infinite.mono _ { x : K | ∃ y, x = y + y⁻¹ ∧ y ≠ 0 }\n  · rintro _ ⟨x, rfl, hx⟩\n    simp only [eval_X, eval_pow, Set.mem_setOf_eq, ZMod.cast_one', add_pow_char,\n      dickson_one_one_eval_add_inv _ _ (mul_inv_cancel₀ hx), ZMod.castHom_apply]\n  -- Now we need to show that the set of such `x` is infinite.\n  -- If the set is finite, then we will show that `K` is also finite.\n  · intro h\n    rw [← Set.infinite_univ_iff] at H\n    apply H\n    -- To each `x` of the form `x = y + y⁻¹`\n    -- we `bind` the set of `y` that solve the equation `x = y + y⁻¹`.\n    -- For every `x`, that set is finite (since it is governed by a quadratic equation).\n    -- For the moment, we claim that all these sets together cover `K`.\n    suffices (Set.univ : Set K) =\n        ⋃ x ∈ { x : K | ∃ y : K, x = y + y⁻¹ ∧ y ≠ 0 }, { y | x = y + y⁻¹ ∨ y = 0 }  by\n      rw [this]\n      clear this\n      refine h.biUnion fun x _ => ?_\n      -- The following quadratic polynomial has as solutions the `y` for which `x = y + y⁻¹`.\n      let φ : K[X] := X ^ 2 - C x * X + 1\n      have hφ : φ ≠ 0 := by\n        intro H\n        have : φ.eval 0 = 0 := by rw [H, eval_zero]\n        simpa [φ, eval_X, eval_one, eval_pow, eval_sub, sub_zero, eval_add, eval_mul,\n          mul_zero, sq, zero_add, one_ne_zero]\n      classical\n        convert (φ.roots ∪ {0}).toFinset.finite_toSet using 1\n        ext1 y\n        simp only [φ, Multiset.mem_toFinset, Set.mem_setOf_eq, Finset.mem_coe, Multiset.mem_union,\n          mem_roots hφ, IsRoot, eval_add, eval_sub, eval_pow, eval_mul, eval_X, eval_C, eval_one,\n          Multiset.mem_singleton]\n        by_cases hy : y = 0\n        · simp only [hy, eq_self_iff_true, or_true]\n        apply or_congr _ Iff.rfl\n        rw [← mul_left_inj' hy, eq_comm, ← sub_eq_zero, add_mul, inv_mul_cancel₀ hy]\n        apply eq_iff_eq_cancel_right.mpr\n        ring\n    -- Finally, we prove the claim that our finite union of finite sets covers all of `K`.\n    apply (Set.eq_univ_of_forall _).symm\n    intro x\n    simp only [exists_prop, Set.mem_iUnion, Ne, Set.mem_setOf_eq]\n    by_cases hx : x = 0\n    · simp only [hx, and_true, eq_self_iff_true, inv_zero, or_true]\n      exact ⟨_, 1, rfl, one_ne_zero⟩\n    · simp only [hx, or_false, exists_eq_right]\n      exact ⟨_, rfl, hx⟩\n\n"}
{"name":"Polynomial.dickson_one_one_charP","module":"Mathlib.RingTheory.Polynomial.Dickson","initialProofState":"R : Type u_1\ninst✝² : CommRing R\np : Nat\ninst✝¹ : Fact (Nat.Prime p)\ninst✝ : CharP R p\n⊢ Eq (Polynomial.dickson 1 1 p) (HPow.hPow Polynomial.X p)","decl":"theorem dickson_one_one_charP (p : ℕ) [Fact p.Prime] [CharP R p] : dickson 1 (1 : R) p = X ^ p := by\n  have h : (1 : R) = ZMod.castHom (dvd_refl p) R 1 := by\n    simp only [ZMod.castHom_apply, ZMod.cast_one']\n  rw [h, ← map_dickson (ZMod.castHom (dvd_refl p) R), dickson_one_one_zmod_p, Polynomial.map_pow,\n    map_X]\n\n"}
