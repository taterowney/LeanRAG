{"name":"MeasurableEmbedding.measurable","module":"Mathlib.MeasureTheory.MeasurableSpace.Embedding","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : MeasurableSpace α\ninst✝ : MeasurableSpace β\nf : α → β\nself : MeasurableEmbedding f\n⊢ Measurable f","decl":"/-- A map `f : α → β` is called a *measurable embedding* if it is injective, measurable, and sends\nmeasurable sets to measurable sets. The latter assumption can be replaced with “`f` has measurable\ninverse `g : Set.range f → α`”, see `MeasurableEmbedding.measurable_rangeSplitting`,\n`MeasurableEmbedding.of_measurable_inverse_range`, and\n`MeasurableEmbedding.of_measurable_inverse`.\n\nOne more interpretation: `f` is a measurable embedding if it defines a measurable equivalence to its\nrange and the range is a measurable set. One implication is formalized as\n`MeasurableEmbedding.equivRange`; the other one follows from\n`MeasurableEquiv.measurableEmbedding`, `MeasurableEmbedding.subtype_coe`, and\n`MeasurableEmbedding.comp`. -/\nstructure MeasurableEmbedding [MeasurableSpace α] [MeasurableSpace β] (f : α → β) : Prop where\n  /-- A measurable embedding is injective. -/\n  protected injective : Injective f\n  /-- A measurable embedding is a measurable function. -/\n  protected measurable : Measurable f\n  /-- The image of a measurable set under a measurable embedding is a measurable set. -/\n  protected measurableSet_image' : ∀ ⦃s⦄, MeasurableSet s → MeasurableSet (f '' s)\n\n"}
{"name":"MeasurableEmbedding.measurableSet_image'","module":"Mathlib.MeasureTheory.MeasurableSpace.Embedding","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : MeasurableSpace α\ninst✝ : MeasurableSpace β\nf : α → β\nself : MeasurableEmbedding f\ns : Set α\na✝ : MeasurableSet s\n⊢ MeasurableSet (Set.image f s)","decl":"/-- A map `f : α → β` is called a *measurable embedding* if it is injective, measurable, and sends\nmeasurable sets to measurable sets. The latter assumption can be replaced with “`f` has measurable\ninverse `g : Set.range f → α`”, see `MeasurableEmbedding.measurable_rangeSplitting`,\n`MeasurableEmbedding.of_measurable_inverse_range`, and\n`MeasurableEmbedding.of_measurable_inverse`.\n\nOne more interpretation: `f` is a measurable embedding if it defines a measurable equivalence to its\nrange and the range is a measurable set. One implication is formalized as\n`MeasurableEmbedding.equivRange`; the other one follows from\n`MeasurableEquiv.measurableEmbedding`, `MeasurableEmbedding.subtype_coe`, and\n`MeasurableEmbedding.comp`. -/\nstructure MeasurableEmbedding [MeasurableSpace α] [MeasurableSpace β] (f : α → β) : Prop where\n  /-- A measurable embedding is injective. -/\n  protected injective : Injective f\n  /-- A measurable embedding is a measurable function. -/\n  protected measurable : Measurable f\n  /-- The image of a measurable set under a measurable embedding is a measurable set. -/\n  protected measurableSet_image' : ∀ ⦃s⦄, MeasurableSet s → MeasurableSet (f '' s)\n\n"}
{"name":"MeasurableEmbedding.injective","module":"Mathlib.MeasureTheory.MeasurableSpace.Embedding","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : MeasurableSpace α\ninst✝ : MeasurableSpace β\nf : α → β\nself : MeasurableEmbedding f\n⊢ Function.Injective f","decl":"/-- A map `f : α → β` is called a *measurable embedding* if it is injective, measurable, and sends\nmeasurable sets to measurable sets. The latter assumption can be replaced with “`f` has measurable\ninverse `g : Set.range f → α`”, see `MeasurableEmbedding.measurable_rangeSplitting`,\n`MeasurableEmbedding.of_measurable_inverse_range`, and\n`MeasurableEmbedding.of_measurable_inverse`.\n\nOne more interpretation: `f` is a measurable embedding if it defines a measurable equivalence to its\nrange and the range is a measurable set. One implication is formalized as\n`MeasurableEmbedding.equivRange`; the other one follows from\n`MeasurableEquiv.measurableEmbedding`, `MeasurableEmbedding.subtype_coe`, and\n`MeasurableEmbedding.comp`. -/\nstructure MeasurableEmbedding [MeasurableSpace α] [MeasurableSpace β] (f : α → β) : Prop where\n  /-- A measurable embedding is injective. -/\n  protected injective : Injective f\n  /-- A measurable embedding is a measurable function. -/\n  protected measurable : Measurable f\n  /-- The image of a measurable set under a measurable embedding is a measurable set. -/\n  protected measurableSet_image' : ∀ ⦃s⦄, MeasurableSet s → MeasurableSet (f '' s)\n\n"}
{"name":"MeasurableEmbedding.measurableSet_image","module":"Mathlib.MeasureTheory.MeasurableSpace.Embedding","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nmα : MeasurableSpace α\ninst✝ : MeasurableSpace β\nf : α → β\nhf : MeasurableEmbedding f\n⊢ Iff (MeasurableSet (Set.image f s)) (MeasurableSet s)","decl":"theorem measurableSet_image (hf : MeasurableEmbedding f) :\n    MeasurableSet (f '' s) ↔ MeasurableSet s :=\n  ⟨fun h => by simpa only [hf.injective.preimage_image] using hf.measurable h, fun h =>\n    hf.measurableSet_image' h⟩\n\n"}
{"name":"MeasurableEmbedding.id","module":"Mathlib.MeasureTheory.MeasurableSpace.Embedding","initialProofState":"α : Type u_1\nmα : MeasurableSpace α\n⊢ MeasurableEmbedding id","decl":"theorem id : MeasurableEmbedding (id : α → α) :=\n  ⟨injective_id, measurable_id, fun s hs => by rwa [image_id]⟩\n\n"}
{"name":"MeasurableEmbedding.comp","module":"Mathlib.MeasureTheory.MeasurableSpace.Embedding","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nmα : MeasurableSpace α\ninst✝¹ : MeasurableSpace β\ninst✝ : MeasurableSpace γ\nf : α → β\ng : β → γ\nhg : MeasurableEmbedding g\nhf : MeasurableEmbedding f\n⊢ MeasurableEmbedding (Function.comp g f)","decl":"theorem comp (hg : MeasurableEmbedding g) (hf : MeasurableEmbedding f) :\n    MeasurableEmbedding (g ∘ f) :=\n  ⟨hg.injective.comp hf.injective, hg.measurable.comp hf.measurable, fun s hs => by\n    rwa [image_comp, hg.measurableSet_image, hf.measurableSet_image]⟩\n\n"}
{"name":"MeasurableEmbedding.subtype_coe","module":"Mathlib.MeasureTheory.MeasurableSpace.Embedding","initialProofState":"α : Type u_1\ns : Set α\nmα : MeasurableSpace α\nhs : MeasurableSet s\n⊢ MeasurableEmbedding Subtype.val","decl":"theorem subtype_coe (hs : MeasurableSet s) : MeasurableEmbedding ((↑) : s → α) where\n  injective := Subtype.coe_injective\n  measurable := measurable_subtype_coe\n  measurableSet_image' := fun _ => MeasurableSet.subtype_image hs\n\n"}
{"name":"MeasurableEmbedding.measurableSet_range","module":"Mathlib.MeasureTheory.MeasurableSpace.Embedding","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\ninst✝ : MeasurableSpace β\nf : α → β\nhf : MeasurableEmbedding f\n⊢ MeasurableSet (Set.range f)","decl":"theorem measurableSet_range (hf : MeasurableEmbedding f) : MeasurableSet (range f) := by\n  rw [← image_univ]\n  exact hf.measurableSet_image' MeasurableSet.univ\n\n"}
{"name":"MeasurableEmbedding.measurableSet_preimage","module":"Mathlib.MeasureTheory.MeasurableSpace.Embedding","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\ninst✝ : MeasurableSpace β\nf : α → β\nhf : MeasurableEmbedding f\ns : Set β\n⊢ Iff (MeasurableSet (Set.preimage f s)) (MeasurableSet (Inter.inter s (Set.range f)))","decl":"theorem measurableSet_preimage (hf : MeasurableEmbedding f) {s : Set β} :\n    MeasurableSet (f ⁻¹' s) ↔ MeasurableSet (s ∩ range f) := by\n  rw [← image_preimage_eq_inter_range, hf.measurableSet_image]\n\n"}
{"name":"MeasurableEmbedding.measurable_rangeSplitting","module":"Mathlib.MeasureTheory.MeasurableSpace.Embedding","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\ninst✝ : MeasurableSpace β\nf : α → β\nhf : MeasurableEmbedding f\n⊢ Measurable (Set.rangeSplitting f)","decl":"theorem measurable_rangeSplitting (hf : MeasurableEmbedding f) :\n    Measurable (rangeSplitting f) := fun s hs => by\n  rwa [preimage_rangeSplitting hf.injective,\n    ← (subtype_coe hf.measurableSet_range).measurableSet_image, ← image_comp,\n    coe_comp_rangeFactorization, hf.measurableSet_image]\n\n"}
{"name":"MeasurableEmbedding.measurable_extend","module":"Mathlib.MeasureTheory.MeasurableSpace.Embedding","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nmα : MeasurableSpace α\ninst✝¹ : MeasurableSpace β\ninst✝ : MeasurableSpace γ\nf : α → β\nhf : MeasurableEmbedding f\ng : α → γ\ng' : β → γ\nhg : Measurable g\nhg' : Measurable g'\n⊢ Measurable (Function.extend f g g')","decl":"theorem measurable_extend (hf : MeasurableEmbedding f) {g : α → γ} {g' : β → γ} (hg : Measurable g)\n    (hg' : Measurable g') : Measurable (extend f g g') := by\n  refine measurable_of_restrict_of_restrict_compl hf.measurableSet_range ?_ ?_\n  · rw [restrict_extend_range]\n    simpa only [rangeSplitting] using hg.comp hf.measurable_rangeSplitting\n  · rw [restrict_extend_compl_range]\n    exact hg'.comp measurable_subtype_coe\n\n"}
{"name":"MeasurableEmbedding.exists_measurable_extend","module":"Mathlib.MeasureTheory.MeasurableSpace.Embedding","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nmα : MeasurableSpace α\ninst✝¹ : MeasurableSpace β\ninst✝ : MeasurableSpace γ\nf : α → β\nhf : MeasurableEmbedding f\ng : α → γ\nhg : Measurable g\nhne : β → Nonempty γ\n⊢ Exists fun g' => And (Measurable g') (Eq (Function.comp g' f) g)","decl":"theorem exists_measurable_extend (hf : MeasurableEmbedding f) {g : α → γ} (hg : Measurable g)\n    (hne : β → Nonempty γ) : ∃ g' : β → γ, Measurable g' ∧ g' ∘ f = g :=\n  ⟨extend f g fun x => Classical.choice (hne x),\n    hf.measurable_extend hg (measurable_const' fun _ _ => rfl),\n    funext fun _ => hf.injective.extend_apply _ _ _⟩\n\n"}
{"name":"MeasurableEmbedding.measurable_comp_iff","module":"Mathlib.MeasureTheory.MeasurableSpace.Embedding","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nmα : MeasurableSpace α\ninst✝¹ : MeasurableSpace β\ninst✝ : MeasurableSpace γ\nf : α → β\ng : β → γ\nhg : MeasurableEmbedding g\n⊢ Iff (Measurable (Function.comp g f)) (Measurable f)","decl":"theorem measurable_comp_iff (hg : MeasurableEmbedding g) : Measurable (g ∘ f) ↔ Measurable f := by\n  refine ⟨fun H => ?_, hg.measurable.comp⟩\n  suffices Measurable ((rangeSplitting g ∘ rangeFactorization g) ∘ f) by\n    rwa [(rightInverse_rangeSplitting hg.injective).comp_eq_id] at this\n  exact hg.measurable_rangeSplitting.comp H.subtype_mk\n\n"}
{"name":"MeasurableSet.of_union_range_cover","module":"Mathlib.MeasureTheory.MeasurableSpace.Embedding","initialProofState":"α : Type u_1\nα₁ : Type u_6\nα₂ : Type u_7\nmα : MeasurableSpace α\nmα₁ : MeasurableSpace α₁\nmα₂ : MeasurableSpace α₂\ni₁ : α₁ → α\ni₂ : α₂ → α\ns : Set α\nhi₁ : MeasurableEmbedding i₁\nhi₂ : MeasurableEmbedding i₂\nh : HasSubset.Subset Set.univ (Union.union (Set.range i₁) (Set.range i₂))\nhs₁ : MeasurableSet (Set.preimage i₁ s)\nhs₂ : MeasurableSet (Set.preimage i₂ s)\n⊢ MeasurableSet s","decl":"lemma MeasurableSet.of_union_range_cover (hi₁ : MeasurableEmbedding i₁)\n    (hi₂ : MeasurableEmbedding i₂) (h : univ ⊆ range i₁ ∪ range i₂)\n    (hs₁ : MeasurableSet (i₁ ⁻¹' s)) (hs₂ : MeasurableSet (i₂ ⁻¹' s)) : MeasurableSet s := by\n  convert (hi₁.measurableSet_image' hs₁).union (hi₂.measurableSet_image' hs₂)\n  simp [image_preimage_eq_range_inter, ← union_inter_distrib_right,univ_subset_iff.1 h]\n\n"}
{"name":"MeasurableSet.of_union₃_range_cover","module":"Mathlib.MeasureTheory.MeasurableSpace.Embedding","initialProofState":"α : Type u_1\nα₁ : Type u_6\nα₂ : Type u_7\nα₃ : Type u_8\nmα : MeasurableSpace α\nmα₁ : MeasurableSpace α₁\nmα₂ : MeasurableSpace α₂\nmα₃ : MeasurableSpace α₃\ni₁ : α₁ → α\ni₂ : α₂ → α\ni₃ : α₃ → α\ns : Set α\nhi₁ : MeasurableEmbedding i₁\nhi₂ : MeasurableEmbedding i₂\nhi₃ : MeasurableEmbedding i₃\nh : HasSubset.Subset Set.univ (Union.union (Union.union (Set.range i₁) (Set.range i₂)) (Set.range i₃))\nhs₁ : MeasurableSet (Set.preimage i₁ s)\nhs₂ : MeasurableSet (Set.preimage i₂ s)\nhs₃ : MeasurableSet (Set.preimage i₃ s)\n⊢ MeasurableSet s","decl":"lemma MeasurableSet.of_union₃_range_cover (hi₁ : MeasurableEmbedding i₁)\n    (hi₂ : MeasurableEmbedding i₂) (hi₃ : MeasurableEmbedding i₃)\n    (h : univ ⊆ range i₁ ∪ range i₂ ∪ range i₃) (hs₁ : MeasurableSet (i₁ ⁻¹' s))\n    (hs₂ : MeasurableSet (i₂ ⁻¹' s)) (hs₃ : MeasurableSet (i₃ ⁻¹' s)) : MeasurableSet s := by\n  convert (hi₁.measurableSet_image' hs₁).union (hi₂.measurableSet_image' hs₂) |>.union\n    (hi₃.measurableSet_image' hs₃)\n  simp [image_preimage_eq_range_inter, ← union_inter_distrib_right, univ_subset_iff.1 h]\n\n"}
{"name":"Measurable.of_union_range_cover","module":"Mathlib.MeasureTheory.MeasurableSpace.Embedding","initialProofState":"α : Type u_1\nβ : Type u_2\nα₁ : Type u_6\nα₂ : Type u_7\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nmα₁ : MeasurableSpace α₁\nmα₂ : MeasurableSpace α₂\ni₁ : α₁ → α\ni₂ : α₂ → α\nf : α → β\nhi₁ : MeasurableEmbedding i₁\nhi₂ : MeasurableEmbedding i₂\nh : HasSubset.Subset Set.univ (Union.union (Set.range i₁) (Set.range i₂))\nhf₁ : Measurable (Function.comp f i₁)\nhf₂ : Measurable (Function.comp f i₂)\n⊢ Measurable f","decl":"lemma Measurable.of_union_range_cover (hi₁ : MeasurableEmbedding i₁)\n    (hi₂ : MeasurableEmbedding i₂) (h : univ ⊆ range i₁ ∪ range i₂)\n    (hf₁ : Measurable (f ∘ i₁)) (hf₂ : Measurable (f ∘ i₂)) : Measurable f :=\n  fun _s hs ↦ .of_union_range_cover hi₁ hi₂ h (hf₁ hs) (hf₂ hs)\n\n"}
{"name":"Measurable.of_union₃_range_cover","module":"Mathlib.MeasureTheory.MeasurableSpace.Embedding","initialProofState":"α : Type u_1\nβ : Type u_2\nα₁ : Type u_6\nα₂ : Type u_7\nα₃ : Type u_8\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nmα₁ : MeasurableSpace α₁\nmα₂ : MeasurableSpace α₂\nmα₃ : MeasurableSpace α₃\ni₁ : α₁ → α\ni₂ : α₂ → α\ni₃ : α₃ → α\nf : α → β\nhi₁ : MeasurableEmbedding i₁\nhi₂ : MeasurableEmbedding i₂\nhi₃ : MeasurableEmbedding i₃\nh : HasSubset.Subset Set.univ (Union.union (Union.union (Set.range i₁) (Set.range i₂)) (Set.range i₃))\nhf₁ : Measurable (Function.comp f i₁)\nhf₂ : Measurable (Function.comp f i₂)\nhf₃ : Measurable (Function.comp f i₃)\n⊢ Measurable f","decl":"lemma Measurable.of_union₃_range_cover (hi₁ : MeasurableEmbedding i₁)\n    (hi₂ : MeasurableEmbedding i₂) (hi₃ : MeasurableEmbedding i₃)\n    (h : univ ⊆ range i₁ ∪ range i₂ ∪ range i₃) (hf₁ : Measurable (f ∘ i₁))\n    (hf₂ : Measurable (f ∘ i₂)) (hf₃ : Measurable (f ∘ i₃)) : Measurable f :=\n  fun _s hs ↦ .of_union₃_range_cover hi₁ hi₂ hi₃ h (hf₁ hs) (hf₂ hs) (hf₃ hs)\n\n"}
{"name":"MeasurableSet.exists_measurable_proj","module":"Mathlib.MeasureTheory.MeasurableSpace.Embedding","initialProofState":"α : Type u_1\ns : Set α\nx✝ : MeasurableSpace α\nhs : MeasurableSet s\nhne : s.Nonempty\n⊢ Exists fun f => And (Measurable f) (∀ (x : ↑s), Eq (f ↑x) x)","decl":"theorem MeasurableSet.exists_measurable_proj {_ : MeasurableSpace α}\n    (hs : MeasurableSet s) (hne : s.Nonempty) : ∃ f : α → s, Measurable f ∧ ∀ x : s, f x = x :=\n  let ⟨f, hfm, hf⟩ :=\n    (MeasurableEmbedding.subtype_coe hs).exists_measurable_extend measurable_id fun _ =>\n      hne.to_subtype\n  ⟨f, hfm, congr_fun hf⟩\n\n"}
{"name":"MeasurableEquiv.mk.injEq","module":"Mathlib.MeasureTheory.MeasurableSpace.Embedding","initialProofState":"α : Type u_6\nβ : Type u_7\ninst✝¹ : MeasurableSpace α\ninst✝ : MeasurableSpace β\ntoEquiv✝ : Equiv α β\nmeasurable_toFun✝ : Measurable ⇑toEquiv✝\nmeasurable_invFun✝ : Measurable ⇑toEquiv✝.symm\ntoEquiv : Equiv α β\nmeasurable_toFun : Measurable ⇑toEquiv\nmeasurable_invFun : Measurable ⇑toEquiv.symm\n⊢ Eq (Eq { toEquiv := toEquiv✝, measurable_toFun := measurable_toFun✝, measurable_invFun := measurable_invFun✝ } { toEquiv := toEquiv, measurable_toFun := measurable_toFun, measurable_invFun := measurable_invFun }) (Eq toEquiv✝ toEquiv)","decl":"/-- Equivalences between measurable spaces. Main application is the simplification of measurability\nstatements along measurable equivalences. -/\nstructure MeasurableEquiv (α β : Type*) [MeasurableSpace α] [MeasurableSpace β] extends α ≃ β where\n  /-- The forward function of a measurable equivalence is measurable. -/\n  measurable_toFun : Measurable toEquiv\n  /-- The inverse function of a measurable equivalence is measurable. -/\n  measurable_invFun : Measurable toEquiv.symm\n\n"}
{"name":"MeasurableEquiv.mk.inj","module":"Mathlib.MeasureTheory.MeasurableSpace.Embedding","initialProofState":"α : Type u_6\nβ : Type u_7\ninst✝¹ : MeasurableSpace α\ninst✝ : MeasurableSpace β\ntoEquiv✝ : Equiv α β\nmeasurable_toFun✝ : Measurable ⇑toEquiv✝\nmeasurable_invFun✝ : Measurable ⇑toEquiv✝.symm\ntoEquiv : Equiv α β\nmeasurable_toFun : Measurable ⇑toEquiv\nmeasurable_invFun : Measurable ⇑toEquiv.symm\nx✝ : Eq { toEquiv := toEquiv✝, measurable_toFun := measurable_toFun✝, measurable_invFun := measurable_invFun✝ } { toEquiv := toEquiv, measurable_toFun := measurable_toFun, measurable_invFun := measurable_invFun }\n⊢ Eq toEquiv✝ toEquiv","decl":"/-- Equivalences between measurable spaces. Main application is the simplification of measurability\nstatements along measurable equivalences. -/\nstructure MeasurableEquiv (α β : Type*) [MeasurableSpace α] [MeasurableSpace β] extends α ≃ β where\n  /-- The forward function of a measurable equivalence is measurable. -/\n  measurable_toFun : Measurable toEquiv\n  /-- The inverse function of a measurable equivalence is measurable. -/\n  measurable_invFun : Measurable toEquiv.symm\n\n"}
{"name":"MeasurableEquiv.mk.sizeOf_spec","module":"Mathlib.MeasureTheory.MeasurableSpace.Embedding","initialProofState":"α : Type u_6\nβ : Type u_7\ninst✝³ : MeasurableSpace α\ninst✝² : MeasurableSpace β\ninst✝¹ : SizeOf α\ninst✝ : SizeOf β\ntoEquiv : Equiv α β\nmeasurable_toFun : Measurable ⇑toEquiv\nmeasurable_invFun : Measurable ⇑toEquiv.symm\n⊢ Eq (SizeOf.sizeOf { toEquiv := toEquiv, measurable_toFun := measurable_toFun, measurable_invFun := measurable_invFun }) (HAdd.hAdd 1 (SizeOf.sizeOf toEquiv))","decl":"/-- Equivalences between measurable spaces. Main application is the simplification of measurability\nstatements along measurable equivalences. -/\nstructure MeasurableEquiv (α β : Type*) [MeasurableSpace α] [MeasurableSpace β] extends α ≃ β where\n  /-- The forward function of a measurable equivalence is measurable. -/\n  measurable_toFun : Measurable toEquiv\n  /-- The inverse function of a measurable equivalence is measurable. -/\n  measurable_invFun : Measurable toEquiv.symm\n\n"}
{"name":"MeasurableEquiv.measurable_toFun","module":"Mathlib.MeasureTheory.MeasurableSpace.Embedding","initialProofState":"α : Type u_6\nβ : Type u_7\ninst✝¹ : MeasurableSpace α\ninst✝ : MeasurableSpace β\nself : MeasurableEquiv α β\n⊢ Measurable ⇑self.toEquiv","decl":"/-- Equivalences between measurable spaces. Main application is the simplification of measurability\nstatements along measurable equivalences. -/\nstructure MeasurableEquiv (α β : Type*) [MeasurableSpace α] [MeasurableSpace β] extends α ≃ β where\n  /-- The forward function of a measurable equivalence is measurable. -/\n  measurable_toFun : Measurable toEquiv\n  /-- The inverse function of a measurable equivalence is measurable. -/\n  measurable_invFun : Measurable toEquiv.symm\n\n"}
{"name":"MeasurableEquiv.measurable_invFun","module":"Mathlib.MeasureTheory.MeasurableSpace.Embedding","initialProofState":"α : Type u_6\nβ : Type u_7\ninst✝¹ : MeasurableSpace α\ninst✝ : MeasurableSpace β\nself : MeasurableEquiv α β\n⊢ Measurable ⇑self.symm","decl":"/-- Equivalences between measurable spaces. Main application is the simplification of measurability\nstatements along measurable equivalences. -/\nstructure MeasurableEquiv (α β : Type*) [MeasurableSpace α] [MeasurableSpace β] extends α ≃ β where\n  /-- The forward function of a measurable equivalence is measurable. -/\n  measurable_toFun : Measurable toEquiv\n  /-- The inverse function of a measurable equivalence is measurable. -/\n  measurable_invFun : Measurable toEquiv.symm\n\n"}
{"name":"MeasurableEquiv.toEquiv_injective","module":"Mathlib.MeasureTheory.MeasurableSpace.Embedding","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : MeasurableSpace α\ninst✝ : MeasurableSpace β\n⊢ Function.Injective MeasurableEquiv.toEquiv","decl":"theorem toEquiv_injective : Injective (toEquiv : α ≃ᵐ β → α ≃ β) := by\n  rintro ⟨e₁, _, _⟩ ⟨e₂, _, _⟩ (rfl : e₁ = e₂)\n  rfl\n\n"}
{"name":"MeasurableEquiv.coe_toEquiv","module":"Mathlib.MeasureTheory.MeasurableSpace.Embedding","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : MeasurableSpace α\ninst✝ : MeasurableSpace β\ne : MeasurableEquiv α β\n⊢ Eq ⇑e.toEquiv ⇑e","decl":"@[simp]\ntheorem coe_toEquiv (e : α ≃ᵐ β) : (e.toEquiv : α → β) = e :=\n  rfl\n\n"}
{"name":"MeasurableEquiv.measurable","module":"Mathlib.MeasureTheory.MeasurableSpace.Embedding","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : MeasurableSpace α\ninst✝ : MeasurableSpace β\ne : MeasurableEquiv α β\n⊢ Measurable ⇑e","decl":"@[measurability, fun_prop]\nprotected theorem measurable (e : α ≃ᵐ β) : Measurable (e : α → β) :=\n  e.measurable_toFun\n\n"}
{"name":"MeasurableEquiv.coe_mk","module":"Mathlib.MeasureTheory.MeasurableSpace.Embedding","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : MeasurableSpace α\ninst✝ : MeasurableSpace β\ne : Equiv α β\nh1 : Measurable ⇑e\nh2 : Measurable ⇑e.symm\n⊢ Eq ⇑{ toEquiv := e, measurable_toFun := h1, measurable_invFun := h2 } ⇑e","decl":"@[simp]\ntheorem coe_mk (e : α ≃ β) (h1 : Measurable e) (h2 : Measurable e.symm) :\n    ((⟨e, h1, h2⟩ : α ≃ᵐ β) : α → β) = e :=\n  rfl\n\n"}
{"name":"MeasurableEquiv.coe_trans","module":"Mathlib.MeasureTheory.MeasurableSpace.Embedding","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝² : MeasurableSpace α\ninst✝¹ : MeasurableSpace β\ninst✝ : MeasurableSpace γ\nab : MeasurableEquiv α β\nbc : MeasurableEquiv β γ\n⊢ Eq (⇑(ab.trans bc)) (Function.comp ⇑bc ⇑ab)","decl":"theorem coe_trans (ab : α ≃ᵐ β) (bc : β ≃ᵐ γ) : ⇑(ab.trans bc) = bc ∘ ab := rfl\n\n"}
{"name":"MeasurableEquiv.coe_toEquiv_symm","module":"Mathlib.MeasureTheory.MeasurableSpace.Embedding","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : MeasurableSpace α\ninst✝ : MeasurableSpace β\ne : MeasurableEquiv α β\n⊢ Eq ⇑e.symm ⇑e.symm","decl":"@[simp]\ntheorem coe_toEquiv_symm (e : α ≃ᵐ β) : (e.toEquiv.symm : β → α) = e.symm :=\n  rfl\n\n"}
{"name":"MeasurableEquiv.ext_iff","module":"Mathlib.MeasureTheory.MeasurableSpace.Embedding","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : MeasurableSpace α\ninst✝ : MeasurableSpace β\ne₁ e₂ : MeasurableEquiv α β\n⊢ Iff (Eq e₁ e₂) (Eq ⇑e₁ ⇑e₂)","decl":"@[ext] theorem ext {e₁ e₂ : α ≃ᵐ β} (h : (e₁ : α → β) = e₂) : e₁ = e₂ := DFunLike.ext' h\n\n"}
{"name":"MeasurableEquiv.ext","module":"Mathlib.MeasureTheory.MeasurableSpace.Embedding","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : MeasurableSpace α\ninst✝ : MeasurableSpace β\ne₁ e₂ : MeasurableEquiv α β\nh : Eq ⇑e₁ ⇑e₂\n⊢ Eq e₁ e₂","decl":"@[ext] theorem ext {e₁ e₂ : α ≃ᵐ β} (h : (e₁ : α → β) = e₂) : e₁ = e₂ := DFunLike.ext' h\n\n"}
{"name":"MeasurableEquiv.symm_mk","module":"Mathlib.MeasureTheory.MeasurableSpace.Embedding","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : MeasurableSpace α\ninst✝ : MeasurableSpace β\ne : Equiv α β\nh1 : Measurable ⇑e\nh2 : Measurable ⇑e.symm\n⊢ Eq { toEquiv := e, measurable_toFun := h1, measurable_invFun := h2 }.symm { toEquiv := e.symm, measurable_toFun := h2, measurable_invFun := h1 }","decl":"@[simp]\ntheorem symm_mk (e : α ≃ β) (h1 : Measurable e) (h2 : Measurable e.symm) :\n    (⟨e, h1, h2⟩ : α ≃ᵐ β).symm = ⟨e.symm, h2, h1⟩ :=\n  rfl\n\n"}
{"name":"MeasurableEquiv.refl_apply","module":"Mathlib.MeasureTheory.MeasurableSpace.Embedding","initialProofState":"α : Type u_6\ninst✝ : MeasurableSpace α\na : α\n⊢ Eq ((MeasurableEquiv.refl α) a) a","decl":"attribute [simps! apply toEquiv] trans refl\n\n"}
{"name":"MeasurableEquiv.trans_toEquiv","module":"Mathlib.MeasureTheory.MeasurableSpace.Embedding","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝² : MeasurableSpace α\ninst✝¹ : MeasurableSpace β\ninst✝ : MeasurableSpace γ\nab : MeasurableEquiv α β\nbc : MeasurableEquiv β γ\n⊢ Eq (ab.trans bc).toEquiv (ab.trans bc.toEquiv)","decl":"attribute [simps! apply toEquiv] trans refl\n\n"}
{"name":"MeasurableEquiv.refl_toEquiv","module":"Mathlib.MeasureTheory.MeasurableSpace.Embedding","initialProofState":"α : Type u_6\ninst✝ : MeasurableSpace α\n⊢ Eq (MeasurableEquiv.refl α).toEquiv (Equiv.refl α)","decl":"attribute [simps! apply toEquiv] trans refl\n\n"}
{"name":"MeasurableEquiv.trans_apply","module":"Mathlib.MeasureTheory.MeasurableSpace.Embedding","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝² : MeasurableSpace α\ninst✝¹ : MeasurableSpace β\ninst✝ : MeasurableSpace γ\nab : MeasurableEquiv α β\nbc : MeasurableEquiv β γ\na✝ : α\n⊢ Eq ((ab.trans bc) a✝) (bc (ab a✝))","decl":"attribute [simps! apply toEquiv] trans refl\n\n"}
{"name":"MeasurableEquiv.symm_symm","module":"Mathlib.MeasureTheory.MeasurableSpace.Embedding","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : MeasurableSpace α\ninst✝ : MeasurableSpace β\ne : MeasurableEquiv α β\n⊢ Eq e.symm.symm e","decl":"@[simp]\ntheorem symm_symm (e : α ≃ᵐ β) : e.symm.symm = e := rfl\n\n"}
{"name":"MeasurableEquiv.symm_bijective","module":"Mathlib.MeasureTheory.MeasurableSpace.Embedding","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : MeasurableSpace α\ninst✝ : MeasurableSpace β\n⊢ Function.Bijective MeasurableEquiv.symm","decl":"theorem symm_bijective :\n    Function.Bijective (MeasurableEquiv.symm : (α ≃ᵐ β) → β ≃ᵐ α) :=\n  Function.bijective_iff_has_inverse.mpr ⟨_, symm_symm, symm_symm⟩\n\n"}
{"name":"MeasurableEquiv.symm_refl","module":"Mathlib.MeasureTheory.MeasurableSpace.Embedding","initialProofState":"α : Type u_6\ninst✝ : MeasurableSpace α\n⊢ Eq (MeasurableEquiv.refl α).symm (MeasurableEquiv.refl α)","decl":"@[simp]\ntheorem symm_refl (α : Type*) [MeasurableSpace α] : (refl α).symm = refl α :=\n  rfl\n\n"}
{"name":"MeasurableEquiv.symm_comp_self","module":"Mathlib.MeasureTheory.MeasurableSpace.Embedding","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : MeasurableSpace α\ninst✝ : MeasurableSpace β\ne : MeasurableEquiv α β\n⊢ Eq (Function.comp ⇑e.symm ⇑e) id","decl":"@[simp]\ntheorem symm_comp_self (e : α ≃ᵐ β) : e.symm ∘ e = id :=\n  funext e.left_inv\n\n"}
{"name":"MeasurableEquiv.self_comp_symm","module":"Mathlib.MeasureTheory.MeasurableSpace.Embedding","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : MeasurableSpace α\ninst✝ : MeasurableSpace β\ne : MeasurableEquiv α β\n⊢ Eq (Function.comp ⇑e ⇑e.symm) id","decl":"@[simp]\ntheorem self_comp_symm (e : α ≃ᵐ β) : e ∘ e.symm = id :=\n  funext e.right_inv\n\n"}
{"name":"MeasurableEquiv.apply_symm_apply","module":"Mathlib.MeasureTheory.MeasurableSpace.Embedding","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : MeasurableSpace α\ninst✝ : MeasurableSpace β\ne : MeasurableEquiv α β\ny : β\n⊢ Eq (e (e.symm y)) y","decl":"@[simp]\ntheorem apply_symm_apply (e : α ≃ᵐ β) (y : β) : e (e.symm y) = y :=\n  e.right_inv y\n\n"}
{"name":"MeasurableEquiv.symm_apply_apply","module":"Mathlib.MeasureTheory.MeasurableSpace.Embedding","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : MeasurableSpace α\ninst✝ : MeasurableSpace β\ne : MeasurableEquiv α β\nx : α\n⊢ Eq (e.symm (e x)) x","decl":"@[simp]\ntheorem symm_apply_apply (e : α ≃ᵐ β) (x : α) : e.symm (e x) = x :=\n  e.left_inv x\n\n"}
{"name":"MeasurableEquiv.symm_trans_self","module":"Mathlib.MeasureTheory.MeasurableSpace.Embedding","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : MeasurableSpace α\ninst✝ : MeasurableSpace β\ne : MeasurableEquiv α β\n⊢ Eq (e.symm.trans e) (MeasurableEquiv.refl β)","decl":"@[simp]\ntheorem symm_trans_self (e : α ≃ᵐ β) : e.symm.trans e = refl β :=\n  ext e.self_comp_symm\n\n"}
{"name":"MeasurableEquiv.self_trans_symm","module":"Mathlib.MeasureTheory.MeasurableSpace.Embedding","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : MeasurableSpace α\ninst✝ : MeasurableSpace β\ne : MeasurableEquiv α β\n⊢ Eq (e.trans e.symm) (MeasurableEquiv.refl α)","decl":"@[simp]\ntheorem self_trans_symm (e : α ≃ᵐ β) : e.trans e.symm = refl α :=\n  ext e.symm_comp_self\n\n"}
{"name":"MeasurableEquiv.surjective","module":"Mathlib.MeasureTheory.MeasurableSpace.Embedding","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : MeasurableSpace α\ninst✝ : MeasurableSpace β\ne : MeasurableEquiv α β\n⊢ Function.Surjective ⇑e","decl":"protected theorem surjective (e : α ≃ᵐ β) : Surjective e :=\n  e.toEquiv.surjective\n\n"}
{"name":"MeasurableEquiv.bijective","module":"Mathlib.MeasureTheory.MeasurableSpace.Embedding","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : MeasurableSpace α\ninst✝ : MeasurableSpace β\ne : MeasurableEquiv α β\n⊢ Function.Bijective ⇑e","decl":"protected theorem bijective (e : α ≃ᵐ β) : Bijective e :=\n  e.toEquiv.bijective\n\n"}
{"name":"MeasurableEquiv.injective","module":"Mathlib.MeasureTheory.MeasurableSpace.Embedding","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : MeasurableSpace α\ninst✝ : MeasurableSpace β\ne : MeasurableEquiv α β\n⊢ Function.Injective ⇑e","decl":"protected theorem injective (e : α ≃ᵐ β) : Injective e :=\n  e.toEquiv.injective\n\n"}
{"name":"MeasurableEquiv.symm_preimage_preimage","module":"Mathlib.MeasureTheory.MeasurableSpace.Embedding","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : MeasurableSpace α\ninst✝ : MeasurableSpace β\ne : MeasurableEquiv α β\ns : Set β\n⊢ Eq (Set.preimage (⇑e.symm) (Set.preimage (⇑e) s)) s","decl":"@[simp]\ntheorem symm_preimage_preimage (e : α ≃ᵐ β) (s : Set β) : e.symm ⁻¹' (e ⁻¹' s) = s :=\n  e.toEquiv.symm_preimage_preimage s\n\n"}
{"name":"MeasurableEquiv.image_eq_preimage","module":"Mathlib.MeasureTheory.MeasurableSpace.Embedding","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : MeasurableSpace α\ninst✝ : MeasurableSpace β\ne : MeasurableEquiv α β\ns : Set α\n⊢ Eq (Set.image (⇑e) s) (Set.preimage (⇑e.symm) s)","decl":"theorem image_eq_preimage (e : α ≃ᵐ β) (s : Set α) : e '' s = e.symm ⁻¹' s :=\n  e.toEquiv.image_eq_preimage s\n\n"}
{"name":"MeasurableEquiv.preimage_symm","module":"Mathlib.MeasureTheory.MeasurableSpace.Embedding","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : MeasurableSpace α\ninst✝ : MeasurableSpace β\ne : MeasurableEquiv α β\ns : Set α\n⊢ Eq (Set.preimage (⇑e.symm) s) (Set.image (⇑e) s)","decl":"lemma preimage_symm (e : α ≃ᵐ β) (s : Set α) : e.symm ⁻¹' s = e '' s := (image_eq_preimage _ _).symm\n\n"}
{"name":"MeasurableEquiv.image_symm","module":"Mathlib.MeasureTheory.MeasurableSpace.Embedding","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : MeasurableSpace α\ninst✝ : MeasurableSpace β\ne : MeasurableEquiv α β\ns : Set β\n⊢ Eq (Set.image (⇑e.symm) s) (Set.preimage (⇑e) s)","decl":"lemma image_symm (e : α ≃ᵐ β) (s : Set β) : e.symm '' s = e ⁻¹' s := by\n  rw [← symm_symm e, preimage_symm, symm_symm]\n\n"}
{"name":"MeasurableEquiv.eq_image_iff_symm_image_eq","module":"Mathlib.MeasureTheory.MeasurableSpace.Embedding","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : MeasurableSpace α\ninst✝ : MeasurableSpace β\ne : MeasurableEquiv α β\ns : Set β\nt : Set α\n⊢ Iff (Eq s (Set.image (⇑e) t)) (Eq (Set.image (⇑e.symm) s) t)","decl":"lemma eq_image_iff_symm_image_eq (e : α ≃ᵐ β) (s : Set β) (t : Set α) :\n    s = e '' t ↔ e.symm '' s = t := by\n  rw [← coe_toEquiv, Equiv.eq_image_iff_symm_image_eq, coe_toEquiv_symm]\n\n"}
{"name":"MeasurableEquiv.image_preimage","module":"Mathlib.MeasureTheory.MeasurableSpace.Embedding","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : MeasurableSpace α\ninst✝ : MeasurableSpace β\ne : MeasurableEquiv α β\ns : Set β\n⊢ Eq (Set.image (⇑e) (Set.preimage (⇑e) s)) s","decl":"@[simp]\nlemma image_preimage (e : α ≃ᵐ β) (s : Set β) : e '' (e ⁻¹' s) = s := by\n  rw [← coe_toEquiv, Equiv.image_preimage]\n\n"}
{"name":"MeasurableEquiv.preimage_image","module":"Mathlib.MeasureTheory.MeasurableSpace.Embedding","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : MeasurableSpace α\ninst✝ : MeasurableSpace β\ne : MeasurableEquiv α β\ns : Set α\n⊢ Eq (Set.preimage (⇑e) (Set.image (⇑e) s)) s","decl":"@[simp]\nlemma preimage_image (e : α ≃ᵐ β) (s : Set α) : e ⁻¹' (e '' s) = s := by\n  rw [← coe_toEquiv, Equiv.preimage_image]\n\n"}
{"name":"MeasurableEquiv.measurableSet_preimage","module":"Mathlib.MeasureTheory.MeasurableSpace.Embedding","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : MeasurableSpace α\ninst✝ : MeasurableSpace β\ne : MeasurableEquiv α β\ns : Set β\n⊢ Iff (MeasurableSet (Set.preimage (⇑e) s)) (MeasurableSet s)","decl":"@[simp]\ntheorem measurableSet_preimage (e : α ≃ᵐ β) {s : Set β} :\n    MeasurableSet (e ⁻¹' s) ↔ MeasurableSet s :=\n  ⟨fun h => by simpa only [symm_preimage_preimage] using e.symm.measurable h, fun h =>\n    e.measurable h⟩\n\n"}
{"name":"MeasurableEquiv.measurableSet_image","module":"Mathlib.MeasureTheory.MeasurableSpace.Embedding","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\ninst✝¹ : MeasurableSpace α\ninst✝ : MeasurableSpace β\ne : MeasurableEquiv α β\n⊢ Iff (MeasurableSet (Set.image (⇑e) s)) (MeasurableSet s)","decl":"@[simp]\ntheorem measurableSet_image (e : α ≃ᵐ β) :\n    MeasurableSet (e '' s) ↔ MeasurableSet s := by rw [image_eq_preimage, measurableSet_preimage]\n\n"}
{"name":"MeasurableEquiv.map_eq","module":"Mathlib.MeasureTheory.MeasurableSpace.Embedding","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : MeasurableSpace α\ninst✝ : MeasurableSpace β\ne : MeasurableEquiv α β\n⊢ Eq (MeasurableSpace.map (⇑e) inst✝¹) inst✝","decl":"@[simp] theorem map_eq (e : α ≃ᵐ β) : MeasurableSpace.map e ‹_› = ‹_› :=\n  e.measurable.le_map.antisymm' fun _s ↦ e.measurableSet_preimage.1\n\n"}
{"name":"MeasurableEquiv.measurableEmbedding","module":"Mathlib.MeasureTheory.MeasurableSpace.Embedding","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : MeasurableSpace α\ninst✝ : MeasurableSpace β\ne : MeasurableEquiv α β\n⊢ MeasurableEmbedding ⇑e","decl":"/-- A measurable equivalence is a measurable embedding. -/\nprotected theorem measurableEmbedding (e : α ≃ᵐ β) : MeasurableEmbedding e where\n  injective := e.injective\n  measurable := e.measurable\n  measurableSet_image' := fun _ => e.measurableSet_image.2\n\n"}
{"name":"MeasurableEquiv.measurable_comp_iff","module":"Mathlib.MeasureTheory.MeasurableSpace.Embedding","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝² : MeasurableSpace α\ninst✝¹ : MeasurableSpace β\ninst✝ : MeasurableSpace γ\nf : β → γ\ne : MeasurableEquiv α β\n⊢ Iff (Measurable (Function.comp f ⇑e)) (Measurable f)","decl":"protected theorem measurable_comp_iff {f : β → γ} (e : α ≃ᵐ β) :\n    Measurable (f ∘ e) ↔ Measurable f :=\n  Iff.intro\n    (fun hfe => by\n      have : Measurable (f ∘ (e.symm.trans e).toEquiv) := hfe.comp e.symm.measurable\n      rwa [coe_toEquiv, symm_trans_self] at this)\n    fun h => h.comp e.measurable\n\n"}
{"name":"MeasurableEquiv.coe_piCongrLeft","module":"Mathlib.MeasureTheory.MeasurableSpace.Embedding","initialProofState":"δ : Type u_4\nδ' : Type u_5\nπ : δ' → Type u_6\ninst✝ : (x : δ') → MeasurableSpace (π x)\nf : Equiv δ δ'\n⊢ Eq ⇑(MeasurableEquiv.piCongrLeft π f) ⇑(Equiv.piCongrLeft π f)","decl":"theorem coe_piCongrLeft (f : δ ≃ δ') :\n    ⇑(MeasurableEquiv.piCongrLeft π f) = f.piCongrLeft π := by rfl\n\n"}
{"name":"MeasurableEquiv.piCongrLeft_apply_apply","module":"Mathlib.MeasureTheory.MeasurableSpace.Embedding","initialProofState":"ι : Type u_8\nι' : Type u_9\ne : Equiv ι ι'\nβ : ι' → Type u_10\ninst✝ : (i' : ι') → MeasurableSpace (β i')\nx : (i : ι) → β (e i)\ni : ι\n⊢ Eq ((MeasurableEquiv.piCongrLeft (fun i' => β i') e) x (e i)) (x i)","decl":"lemma piCongrLeft_apply_apply {ι ι' : Type*} (e : ι ≃ ι') {β : ι' → Type*}\n    [∀ i', MeasurableSpace (β i')] (x : (i : ι) → β (e i)) (i : ι) :\n    piCongrLeft (fun i' ↦ β i') e x (e i) = x i := by\n  rw [piCongrLeft, coe_mk, Equiv.piCongrLeft_apply_apply]\n\n"}
{"name":"MeasurableEquiv.piMeasurableEquivTProd_symm_apply","module":"Mathlib.MeasureTheory.MeasurableSpace.Embedding","initialProofState":"δ' : Type u_5\nπ : δ' → Type u_6\ninst✝¹ : (x : δ') → MeasurableSpace (π x)\ninst✝ : DecidableEq δ'\nl : List δ'\nhnd : l.Nodup\nh : ∀ (i : δ'), Membership.mem l i\n⊢ Eq (⇑(MeasurableEquiv.piMeasurableEquivTProd hnd h).symm) (List.TProd.elim' h)","decl":"/-- Pi-types are measurably equivalent to iterated products. -/\n@[simps! (config := .asFn)]\ndef piMeasurableEquivTProd [DecidableEq δ'] {l : List δ'} (hnd : l.Nodup) (h : ∀ i, i ∈ l) :\n    (∀ i, π i) ≃ᵐ List.TProd π l where\n  toEquiv := List.TProd.piEquivTProd hnd h\n  measurable_toFun := measurable_tProd_mk l\n  measurable_invFun := measurable_tProd_elim' h\n\n"}
{"name":"MeasurableEquiv.piMeasurableEquivTProd_apply","module":"Mathlib.MeasureTheory.MeasurableSpace.Embedding","initialProofState":"δ' : Type u_5\nπ : δ' → Type u_6\ninst✝¹ : (x : δ') → MeasurableSpace (π x)\ninst✝ : DecidableEq δ'\nl : List δ'\nhnd : l.Nodup\nh : ∀ (i : δ'), Membership.mem l i\n⊢ Eq (⇑(MeasurableEquiv.piMeasurableEquivTProd hnd h)) (List.TProd.mk l)","decl":"/-- Pi-types are measurably equivalent to iterated products. -/\n@[simps! (config := .asFn)]\ndef piMeasurableEquivTProd [DecidableEq δ'] {l : List δ'} (hnd : l.Nodup) (h : ∀ i, i ∈ l) :\n    (∀ i, π i) ≃ᵐ List.TProd π l where\n  toEquiv := List.TProd.piEquivTProd hnd h\n  measurable_toFun := measurable_tProd_mk l\n  measurable_invFun := measurable_tProd_elim' h\n\n"}
{"name":"MeasurableEquiv.piUnique_symm_apply","module":"Mathlib.MeasureTheory.MeasurableSpace.Embedding","initialProofState":"δ' : Type u_5\nπ : δ' → Type u_6\ninst✝¹ : (x : δ') → MeasurableSpace (π x)\ninst✝ : Unique δ'\n⊢ Eq (⇑(MeasurableEquiv.piUnique π).symm) uniqueElim","decl":"variable (π) in\n/-- The measurable equivalence `(∀ i, π i) ≃ᵐ π ⋆` when the domain of `π` only contains `⋆` -/\n@[simps! (config := .asFn)]\ndef piUnique [Unique δ'] : (∀ i, π i) ≃ᵐ π default where\n  toEquiv := Equiv.piUnique π\n  measurable_toFun := measurable_pi_apply _\n  measurable_invFun := measurable_uniqueElim\n\n"}
{"name":"MeasurableEquiv.piUnique_apply","module":"Mathlib.MeasureTheory.MeasurableSpace.Embedding","initialProofState":"δ' : Type u_5\nπ : δ' → Type u_6\ninst✝¹ : (x : δ') → MeasurableSpace (π x)\ninst✝ : Unique δ'\n⊢ Eq ⇑(MeasurableEquiv.piUnique π) fun f => f Inhabited.default","decl":"variable (π) in\n/-- The measurable equivalence `(∀ i, π i) ≃ᵐ π ⋆` when the domain of `π` only contains `⋆` -/\n@[simps! (config := .asFn)]\ndef piUnique [Unique δ'] : (∀ i, π i) ≃ᵐ π default where\n  toEquiv := Equiv.piUnique π\n  measurable_toFun := measurable_pi_apply _\n  measurable_invFun := measurable_uniqueElim\n\n"}
{"name":"MeasurableEquiv.funUnique_symm_apply","module":"Mathlib.MeasureTheory.MeasurableSpace.Embedding","initialProofState":"α : Type u_8\nβ : Type u_9\ninst✝¹ : Unique α\ninst✝ : MeasurableSpace β\n⊢ Eq (⇑(MeasurableEquiv.funUnique α β).symm) uniqueElim","decl":"/-- If `α` has a unique term, then the type of function `α → β` is measurably equivalent to `β`. -/\n@[simps! (config := .asFn)]\ndef funUnique (α β : Type*) [Unique α] [MeasurableSpace β] : (α → β) ≃ᵐ β :=\n  MeasurableEquiv.piUnique _\n\n"}
{"name":"MeasurableEquiv.funUnique_apply","module":"Mathlib.MeasureTheory.MeasurableSpace.Embedding","initialProofState":"α : Type u_8\nβ : Type u_9\ninst✝¹ : Unique α\ninst✝ : MeasurableSpace β\n⊢ Eq ⇑(MeasurableEquiv.funUnique α β) fun f => f Inhabited.default","decl":"/-- If `α` has a unique term, then the type of function `α → β` is measurably equivalent to `β`. -/\n@[simps! (config := .asFn)]\ndef funUnique (α β : Type*) [Unique α] [MeasurableSpace β] : (α → β) ≃ᵐ β :=\n  MeasurableEquiv.piUnique _\n\n"}
{"name":"MeasurableEquiv.piFinTwo_symm_apply","module":"Mathlib.MeasureTheory.MeasurableSpace.Embedding","initialProofState":"α : Fin 2 → Type u_8\ninst✝ : (i : Fin 2) → MeasurableSpace (α i)\n⊢ Eq ⇑(MeasurableEquiv.piFinTwo α).symm fun p => Fin.cons p.1 (Fin.cons p.2 finZeroElim)","decl":"/-- The space `Π i : Fin 2, α i` is measurably equivalent to `α 0 × α 1`. -/\n@[simps! (config := .asFn)]\ndef piFinTwo (α : Fin 2 → Type*) [∀ i, MeasurableSpace (α i)] : (∀ i, α i) ≃ᵐ α 0 × α 1 where\n  toEquiv := piFinTwoEquiv α\n  measurable_toFun := Measurable.prod (measurable_pi_apply _) (measurable_pi_apply _)\n  measurable_invFun := measurable_pi_iff.2 <| Fin.forall_fin_two.2 ⟨measurable_fst, measurable_snd⟩\n\n"}
{"name":"MeasurableEquiv.piFinTwo_apply","module":"Mathlib.MeasureTheory.MeasurableSpace.Embedding","initialProofState":"α : Fin 2 → Type u_8\ninst✝ : (i : Fin 2) → MeasurableSpace (α i)\n⊢ Eq ⇑(MeasurableEquiv.piFinTwo α) fun f => { fst := f 0, snd := f 1 }","decl":"/-- The space `Π i : Fin 2, α i` is measurably equivalent to `α 0 × α 1`. -/\n@[simps! (config := .asFn)]\ndef piFinTwo (α : Fin 2 → Type*) [∀ i, MeasurableSpace (α i)] : (∀ i, α i) ≃ᵐ α 0 × α 1 where\n  toEquiv := piFinTwoEquiv α\n  measurable_toFun := Measurable.prod (measurable_pi_apply _) (measurable_pi_apply _)\n  measurable_invFun := measurable_pi_iff.2 <| Fin.forall_fin_two.2 ⟨measurable_fst, measurable_snd⟩\n\n"}
{"name":"MeasurableEquiv.finTwoArrow_symm_apply","module":"Mathlib.MeasureTheory.MeasurableSpace.Embedding","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\n⊢ Eq ⇑MeasurableEquiv.finTwoArrow.symm fun p => Fin.cons p.1 (Fin.cons p.2 finZeroElim)","decl":"/-- The space `Fin 2 → α` is measurably equivalent to `α × α`. -/\n@[simps! (config := .asFn)]\ndef finTwoArrow : (Fin 2 → α) ≃ᵐ α × α :=\n  piFinTwo fun _ => α\n\n"}
{"name":"MeasurableEquiv.finTwoArrow_apply","module":"Mathlib.MeasureTheory.MeasurableSpace.Embedding","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\n⊢ Eq ⇑MeasurableEquiv.finTwoArrow fun f => { fst := f 0, snd := f 1 }","decl":"/-- The space `Fin 2 → α` is measurably equivalent to `α × α`. -/\n@[simps! (config := .asFn)]\ndef finTwoArrow : (Fin 2 → α) ≃ᵐ α × α :=\n  piFinTwo fun _ => α\n\n"}
{"name":"MeasurableEquiv.piFinSuccAbove_apply","module":"Mathlib.MeasureTheory.MeasurableSpace.Embedding","initialProofState":"n : Nat\nα : Fin (HAdd.hAdd n 1) → Type u_8\ninst✝ : (i : Fin (HAdd.hAdd n 1)) → MeasurableSpace (α i)\ni : Fin (HAdd.hAdd n 1)\n⊢ Eq ⇑(MeasurableEquiv.piFinSuccAbove α i) ⇑(Fin.insertNthEquiv α i).symm","decl":"/-- Measurable equivalence between `Π j : Fin (n + 1), α j` and\n`α i × Π j : Fin n, α (Fin.succAbove i j)`.\n\nMeasurable version of `Fin.insertNthEquiv`. -/\n@[simps! (config := .asFn)]\ndef piFinSuccAbove {n : ℕ} (α : Fin (n + 1) → Type*) [∀ i, MeasurableSpace (α i)]\n    (i : Fin (n + 1)) : (∀ j, α j) ≃ᵐ α i × ∀ j, α (i.succAbove j) where\n  toEquiv := (Fin.insertNthEquiv α i).symm\n  measurable_toFun := (measurable_pi_apply i).prod_mk <| measurable_pi_iff.2 fun _ =>\n    measurable_pi_apply _\n  measurable_invFun := measurable_pi_iff.2 <| i.forall_iff_succAbove.2\n    ⟨by simp [measurable_fst], fun j => by simpa using (measurable_pi_apply _).comp measurable_snd⟩\n\n"}
{"name":"MeasurableEquiv.piFinSuccAbove_symm_apply","module":"Mathlib.MeasureTheory.MeasurableSpace.Embedding","initialProofState":"n : Nat\nα : Fin (HAdd.hAdd n 1) → Type u_8\ninst✝ : (i : Fin (HAdd.hAdd n 1)) → MeasurableSpace (α i)\ni : Fin (HAdd.hAdd n 1)\n⊢ Eq ⇑(MeasurableEquiv.piFinSuccAbove α i).symm ⇑(Fin.insertNthEquiv α i)","decl":"/-- Measurable equivalence between `Π j : Fin (n + 1), α j` and\n`α i × Π j : Fin n, α (Fin.succAbove i j)`.\n\nMeasurable version of `Fin.insertNthEquiv`. -/\n@[simps! (config := .asFn)]\ndef piFinSuccAbove {n : ℕ} (α : Fin (n + 1) → Type*) [∀ i, MeasurableSpace (α i)]\n    (i : Fin (n + 1)) : (∀ j, α j) ≃ᵐ α i × ∀ j, α (i.succAbove j) where\n  toEquiv := (Fin.insertNthEquiv α i).symm\n  measurable_toFun := (measurable_pi_apply i).prod_mk <| measurable_pi_iff.2 fun _ =>\n    measurable_pi_apply _\n  measurable_invFun := measurable_pi_iff.2 <| i.forall_iff_succAbove.2\n    ⟨by simp [measurable_fst], fun j => by simpa using (measurable_pi_apply _).comp measurable_snd⟩\n\n"}
{"name":"MeasurableEquiv.piEquivPiSubtypeProd_apply","module":"Mathlib.MeasureTheory.MeasurableSpace.Embedding","initialProofState":"δ' : Type u_5\nπ : δ' → Type u_6\ninst✝¹ : (x : δ') → MeasurableSpace (π x)\np : δ' → Prop\ninst✝ : DecidablePred p\n⊢ Eq ⇑(MeasurableEquiv.piEquivPiSubtypeProd π p) fun f => { fst := fun x => f ↑x, snd := fun x => f ↑x }","decl":"/-- Measurable equivalence between (dependent) functions on a type and pairs of functions on\n`{i // p i}` and `{i // ¬p i}`. See also `Equiv.piEquivPiSubtypeProd`. -/\n@[simps! (config := .asFn)]\ndef piEquivPiSubtypeProd (p : δ' → Prop) [DecidablePred p] :\n    (∀ i, π i) ≃ᵐ (∀ i : Subtype p, π i) × ∀ i : { i // ¬p i }, π i where\n  toEquiv := .piEquivPiSubtypeProd p π\n  measurable_toFun := measurable_piEquivPiSubtypeProd π p\n  measurable_invFun := measurable_piEquivPiSubtypeProd_symm π p\n\n"}
{"name":"MeasurableEquiv.piEquivPiSubtypeProd_symm_apply","module":"Mathlib.MeasureTheory.MeasurableSpace.Embedding","initialProofState":"δ' : Type u_5\nπ : δ' → Type u_6\ninst✝¹ : (x : δ') → MeasurableSpace (π x)\np : δ' → Prop\ninst✝ : DecidablePred p\n⊢ Eq ⇑(MeasurableEquiv.piEquivPiSubtypeProd π p).symm fun f x => dite (p x) (fun h => f.1 ⟨x, h⟩) fun h => f.2 ⟨x, h⟩","decl":"/-- Measurable equivalence between (dependent) functions on a type and pairs of functions on\n`{i // p i}` and `{i // ¬p i}`. See also `Equiv.piEquivPiSubtypeProd`. -/\n@[simps! (config := .asFn)]\ndef piEquivPiSubtypeProd (p : δ' → Prop) [DecidablePred p] :\n    (∀ i, π i) ≃ᵐ (∀ i : Subtype p, π i) × ∀ i : { i // ¬p i }, π i where\n  toEquiv := .piEquivPiSubtypeProd p π\n  measurable_toFun := measurable_piEquivPiSubtypeProd π p\n  measurable_invFun := measurable_piEquivPiSubtypeProd_symm π p\n\n"}
{"name":"MeasurableEquiv.coe_sumPiEquivProdPi","module":"Mathlib.MeasureTheory.MeasurableSpace.Embedding","initialProofState":"δ : Type u_4\nδ' : Type u_5\nα : Sum δ δ' → Type u_8\ninst✝ : (i : Sum δ δ') → MeasurableSpace (α i)\n⊢ Eq ⇑(MeasurableEquiv.sumPiEquivProdPi α) ⇑(Equiv.sumPiEquivProdPi α)","decl":"theorem coe_sumPiEquivProdPi (α : δ ⊕ δ' → Type*) [∀ i, MeasurableSpace (α i)] :\n    ⇑(MeasurableEquiv.sumPiEquivProdPi α) = Equiv.sumPiEquivProdPi α := by rfl\n\n"}
{"name":"MeasurableEquiv.coe_sumPiEquivProdPi_symm","module":"Mathlib.MeasureTheory.MeasurableSpace.Embedding","initialProofState":"δ : Type u_4\nδ' : Type u_5\nα : Sum δ δ' → Type u_8\ninst✝ : (i : Sum δ δ') → MeasurableSpace (α i)\n⊢ Eq ⇑(MeasurableEquiv.sumPiEquivProdPi α).symm ⇑(Equiv.sumPiEquivProdPi α).symm","decl":"theorem coe_sumPiEquivProdPi_symm (α : δ ⊕ δ' → Type*) [∀ i, MeasurableSpace (α i)] :\n    ⇑(MeasurableEquiv.sumPiEquivProdPi α).symm = (Equiv.sumPiEquivProdPi α).symm := by rfl\n\n"}
{"name":"MeasurableEquiv.ofInvolutive_toEquiv","module":"Mathlib.MeasureTheory.MeasurableSpace.Embedding","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nf : α → α\nhf : Function.Involutive f\nhf' : Measurable f\n⊢ Eq (MeasurableEquiv.ofInvolutive f hf hf').toEquiv (Function.Involutive.toPerm f hf)","decl":"/-- Convert a measurable involutive function `f` to a measurable permutation with\n`toFun = invFun = f`. See also `Function.Involutive.toPerm`. -/\n@[simps toEquiv]\ndef ofInvolutive (f : α → α) (hf : Involutive f) (hf' : Measurable f) : α ≃ᵐ α where\n  toEquiv := hf.toPerm\n  measurable_toFun := hf'\n  measurable_invFun := hf'\n\n"}
{"name":"MeasurableEquiv.ofInvolutive_apply","module":"Mathlib.MeasureTheory.MeasurableSpace.Embedding","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nf : α → α\nhf : Function.Involutive f\nhf' : Measurable f\na : α\n⊢ Eq ((MeasurableEquiv.ofInvolutive f hf hf') a) (f a)","decl":"@[simp] theorem ofInvolutive_apply (f : α → α) (hf : Involutive f) (hf' : Measurable f) (a : α) :\n    ofInvolutive f hf hf' a = f a := rfl\n\n"}
{"name":"MeasurableEquiv.ofInvolutive_symm","module":"Mathlib.MeasureTheory.MeasurableSpace.Embedding","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nf : α → α\nhf : Function.Involutive f\nhf' : Measurable f\n⊢ Eq (MeasurableEquiv.ofInvolutive f hf hf').symm (MeasurableEquiv.ofInvolutive f hf hf')","decl":"@[simp] theorem ofInvolutive_symm (f : α → α) (hf : Involutive f) (hf' : Measurable f) :\n    (ofInvolutive f hf hf').symm = ofInvolutive f hf hf' := rfl\n\n"}
{"name":"MeasurableEmbedding.comap_eq","module":"Mathlib.MeasureTheory.MeasurableSpace.Embedding","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : MeasurableSpace α\ninst✝ : MeasurableSpace β\nf : α → β\nhf : MeasurableEmbedding f\n⊢ Eq (MeasurableSpace.comap f inst✝) inst✝¹","decl":"@[simp] theorem comap_eq (hf : MeasurableEmbedding f) : MeasurableSpace.comap f ‹_› = ‹_› :=\n  hf.measurable.comap_le.antisymm fun _s h ↦\n    ⟨_, hf.measurableSet_image' h, hf.injective.preimage_image _⟩\n\n"}
{"name":"MeasurableEmbedding.iff_comap_eq","module":"Mathlib.MeasureTheory.MeasurableSpace.Embedding","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : MeasurableSpace α\ninst✝ : MeasurableSpace β\nf : α → β\n⊢ Iff (MeasurableEmbedding f) (And (Function.Injective f) (And (Eq (MeasurableSpace.comap f inst✝) inst✝¹) (MeasurableSet (Set.range f))))","decl":"theorem iff_comap_eq :\n    MeasurableEmbedding f ↔\n      Injective f ∧ MeasurableSpace.comap f ‹_› = ‹_› ∧ MeasurableSet (range f) :=\n  ⟨fun hf ↦ ⟨hf.injective, hf.comap_eq, hf.measurableSet_range⟩, fun hf ↦\n    { injective := hf.1\n      measurable := by rw [← hf.2.1]; exact comap_measurable f\n      measurableSet_image' := by\n        rw [← hf.2.1]\n        rintro _ ⟨s, hs, rfl⟩\n        simpa only [image_preimage_eq_inter_range] using hs.inter hf.2.2 }⟩\n\n"}
{"name":"MeasurableEmbedding.of_measurable_inverse_on_range","module":"Mathlib.MeasureTheory.MeasurableSpace.Embedding","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : MeasurableSpace α\ninst✝ : MeasurableSpace β\nf : α → β\ng : ↑(Set.range f) → α\nhf₁ : Measurable f\nhf₂ : MeasurableSet (Set.range f)\nhg : Measurable g\nH : Function.LeftInverse g (Set.rangeFactorization f)\n⊢ MeasurableEmbedding f","decl":"theorem of_measurable_inverse_on_range {g : range f → α} (hf₁ : Measurable f)\n    (hf₂ : MeasurableSet (range f)) (hg : Measurable g) (H : LeftInverse g (rangeFactorization f)) :\n    MeasurableEmbedding f := by\n  set e : α ≃ᵐ range f :=\n    ⟨⟨rangeFactorization f, g, H, H.rightInverse_of_surjective surjective_onto_range⟩,\n      hf₁.subtype_mk, hg⟩\n  exact (MeasurableEmbedding.subtype_coe hf₂).comp e.measurableEmbedding\n\n"}
{"name":"MeasurableEmbedding.of_measurable_inverse","module":"Mathlib.MeasureTheory.MeasurableSpace.Embedding","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : MeasurableSpace α\ninst✝ : MeasurableSpace β\nf : α → β\ng : β → α\nhf₁ : Measurable f\nhf₂ : MeasurableSet (Set.range f)\nhg : Measurable g\nH : Function.LeftInverse g f\n⊢ MeasurableEmbedding f","decl":"theorem of_measurable_inverse (hf₁ : Measurable f) (hf₂ : MeasurableSet (range f))\n    (hg : Measurable g) (H : LeftInverse g f) : MeasurableEmbedding f :=\n  of_measurable_inverse_on_range hf₁ hf₂ (hg.comp measurable_subtype_coe) H\n\n"}
{"name":"MeasurableSpace.comap_compl","module":"Mathlib.MeasureTheory.MeasurableSpace.Embedding","initialProofState":"α : Type u_1\nβ : Type u_2\nm' : MeasurableSpace β\ninst✝ : BooleanAlgebra β\nh : Measurable HasCompl.compl\nf : α → β\n⊢ Eq (MeasurableSpace.comap (fun a => HasCompl.compl (f a)) inferInstance) (MeasurableSpace.comap f inferInstance)","decl":"theorem MeasurableSpace.comap_compl {m' : MeasurableSpace β} [BooleanAlgebra β]\n    (h : Measurable (compl : β → β)) (f : α → β) :\n    MeasurableSpace.comap (fun a => (f a)ᶜ) inferInstance =\n      MeasurableSpace.comap f inferInstance := by\n  rw [← Function.comp_def, ← MeasurableSpace.comap_comp]\n  congr\n  exact (MeasurableEquiv.ofInvolutive _ compl_involutive h).measurableEmbedding.comap_eq\n\n"}
{"name":"MeasurableSpace.comap_not","module":"Mathlib.MeasureTheory.MeasurableSpace.Embedding","initialProofState":"α : Type u_1\np : α → Prop\n⊢ Eq (MeasurableSpace.comap (fun a => Not (p a)) inferInstance) (MeasurableSpace.comap p inferInstance)","decl":"@[simp] theorem MeasurableSpace.comap_not (p : α → Prop) :\n    MeasurableSpace.comap (fun a ↦ ¬p a) inferInstance = MeasurableSpace.comap p inferInstance :=\n  MeasurableSpace.comap_compl (fun _ _ ↦ measurableSet_top) _\n"}
