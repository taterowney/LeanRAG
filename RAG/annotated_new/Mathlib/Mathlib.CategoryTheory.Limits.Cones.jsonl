{"name":"CategoryTheory.Functor.cones_obj","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\nX : Opposite C\n⊢ Eq (F.cones.obj X) (Quiver.Hom ((CategoryTheory.Functor.const J).obj (Opposite.unop X)) F)","decl":"/-- If `F : J ⥤ C` then `F.cones` is the functor assigning to an object `X : C` the\ntype of natural transformations from the constant functor with value `X` to `F`.\nAn object representing this functor is a limit of `F`.\n-/\n@[simps!]\ndef cones : Cᵒᵖ ⥤ Type max u₁ v₃ :=\n  (const J).op ⋙ yoneda.obj F\n\n"}
{"name":"CategoryTheory.Functor.cones_map_app","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\nX✝ Y✝ : Opposite C\nf : Quiver.Hom X✝ Y✝\na✝ : (CategoryTheory.yoneda.obj F).obj ((CategoryTheory.Functor.const J).op.obj X✝)\nX : J\n⊢ Eq ((F.cones.map f a✝).app X) (CategoryTheory.CategoryStruct.comp f.unop (a✝.app X))","decl":"/-- If `F : J ⥤ C` then `F.cones` is the functor assigning to an object `X : C` the\ntype of natural transformations from the constant functor with value `X` to `F`.\nAn object representing this functor is a limit of `F`.\n-/\n@[simps!]\ndef cones : Cᵒᵖ ⥤ Type max u₁ v₃ :=\n  (const J).op ⋙ yoneda.obj F\n\n"}
{"name":"CategoryTheory.Functor.cocones_map_app","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\nX✝ Y✝ : C\nf : Quiver.Hom X✝ Y✝\na✝ : (CategoryTheory.coyoneda.obj { unop := F }).obj ((CategoryTheory.Functor.const J).obj X✝)\nX : J\n⊢ Eq ((F.cocones.map f a✝).app X) (CategoryTheory.CategoryStruct.comp (a✝.app X) f)","decl":"/-- If `F : J ⥤ C` then `F.cocones` is the functor assigning to an object `(X : C)`\nthe type of natural transformations from `F` to the constant functor with value `X`.\nAn object corepresenting this functor is a colimit of `F`.\n-/\n@[simps!]\ndef cocones : C ⥤ Type max u₁ v₃ :=\n  const J ⋙ coyoneda.obj (op F)\n\n"}
{"name":"CategoryTheory.Functor.cocones_obj","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\nX : C\n⊢ Eq (F.cocones.obj X) (Quiver.Hom F ((CategoryTheory.Functor.const J).obj X))","decl":"/-- If `F : J ⥤ C` then `F.cocones` is the functor assigning to an object `(X : C)`\nthe type of natural transformations from `F` to the constant functor with value `X`.\nAn object corepresenting this functor is a colimit of `F`.\n-/\n@[simps!]\ndef cocones : C ⥤ Type max u₁ v₃ :=\n  const J ⋙ coyoneda.obj (op F)\n\n"}
{"name":"CategoryTheory.cones_map_app_app","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nX✝¹ Y✝ : CategoryTheory.Functor J C\nf : Quiver.Hom X✝¹ Y✝\nX✝ : Opposite C\na✝ : (CategoryTheory.yoneda.obj X✝¹).obj ((CategoryTheory.Functor.const J).op.obj X✝)\nX : J\n⊢ Eq ((((CategoryTheory.cones J C).map f).app X✝ a✝).app X) (CategoryTheory.CategoryStruct.comp (a✝.app X) (f.app X))","decl":"/-- Functorially associated to each functor `J ⥤ C`, we have the `C`-presheaf consisting of\ncones with a given cone point.\n-/\n@[simps!]\ndef cones : (J ⥤ C) ⥤ Cᵒᵖ ⥤ Type max u₁ v₃ where\n  obj := Functor.cones\n  map f := whiskerLeft (const J).op (yoneda.map f)\n\n"}
{"name":"CategoryTheory.cones_obj_obj","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\nX : Opposite C\n⊢ Eq (((CategoryTheory.cones J C).obj F).obj X) (Quiver.Hom ((CategoryTheory.Functor.const J).obj (Opposite.unop X)) F)","decl":"/-- Functorially associated to each functor `J ⥤ C`, we have the `C`-presheaf consisting of\ncones with a given cone point.\n-/\n@[simps!]\ndef cones : (J ⥤ C) ⥤ Cᵒᵖ ⥤ Type max u₁ v₃ where\n  obj := Functor.cones\n  map f := whiskerLeft (const J).op (yoneda.map f)\n\n"}
{"name":"CategoryTheory.cones_obj_map_app","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\nX✝ Y✝ : Opposite C\nf : Quiver.Hom X✝ Y✝\na✝ : (CategoryTheory.yoneda.obj F).obj ((CategoryTheory.Functor.const J).op.obj X✝)\nX : J\n⊢ Eq ((((CategoryTheory.cones J C).obj F).map f a✝).app X) (CategoryTheory.CategoryStruct.comp f.unop (a✝.app X))","decl":"/-- Functorially associated to each functor `J ⥤ C`, we have the `C`-presheaf consisting of\ncones with a given cone point.\n-/\n@[simps!]\ndef cones : (J ⥤ C) ⥤ Cᵒᵖ ⥤ Type max u₁ v₃ where\n  obj := Functor.cones\n  map f := whiskerLeft (const J).op (yoneda.map f)\n\n"}
{"name":"CategoryTheory.cocones_obj_obj","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : Opposite (CategoryTheory.Functor J C)\nX : C\n⊢ Eq (((CategoryTheory.cocones J C).obj F).obj X) (Quiver.Hom (Opposite.unop F) ((CategoryTheory.Functor.const J).obj X))","decl":"/-- Contravariantly associated to each functor `J ⥤ C`, we have the `C`-copresheaf consisting of\ncocones with a given cocone point.\n-/\n@[simps!]\ndef cocones : (J ⥤ C)ᵒᵖ ⥤ C ⥤ Type max u₁ v₃ where\n  obj F := Functor.cocones (unop F)\n  map f := whiskerLeft (const J) (coyoneda.map f)\n\n"}
{"name":"CategoryTheory.cocones_obj_map_app","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : Opposite (CategoryTheory.Functor J C)\nX✝ Y✝ : C\nf : Quiver.Hom X✝ Y✝\na✝ : (CategoryTheory.coyoneda.obj { unop := Opposite.unop F }).obj ((CategoryTheory.Functor.const J).obj X✝)\nX : J\n⊢ Eq ((((CategoryTheory.cocones J C).obj F).map f a✝).app X) (CategoryTheory.CategoryStruct.comp (a✝.app X) f)","decl":"/-- Contravariantly associated to each functor `J ⥤ C`, we have the `C`-copresheaf consisting of\ncocones with a given cocone point.\n-/\n@[simps!]\ndef cocones : (J ⥤ C)ᵒᵖ ⥤ C ⥤ Type max u₁ v₃ where\n  obj F := Functor.cocones (unop F)\n  map f := whiskerLeft (const J) (coyoneda.map f)\n\n"}
{"name":"CategoryTheory.cocones_map_app_app","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nX✝¹ Y✝ : Opposite (CategoryTheory.Functor J C)\nf : Quiver.Hom X✝¹ Y✝\nX✝ : C\na✝ : (CategoryTheory.coyoneda.obj X✝¹).obj ((CategoryTheory.Functor.const J).obj X✝)\nX : J\n⊢ Eq ((((CategoryTheory.cocones J C).map f).app X✝ a✝).app X) (CategoryTheory.CategoryStruct.comp (f.unop.app X) (a✝.app X))","decl":"/-- Contravariantly associated to each functor `J ⥤ C`, we have the `C`-copresheaf consisting of\ncocones with a given cocone point.\n-/\n@[simps!]\ndef cocones : (J ⥤ C)ᵒᵖ ⥤ C ⥤ Type max u₁ v₃ where\n  obj F := Functor.cocones (unop F)\n  map f := whiskerLeft (const J) (coyoneda.map f)\n\n"}
{"name":"CategoryTheory.Limits.Cone.mk.injEq","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\npt✝ : C\nπ✝ : Quiver.Hom ((CategoryTheory.Functor.const J).obj pt✝) F\npt : C\nπ : Quiver.Hom ((CategoryTheory.Functor.const J).obj pt) F\n⊢ Eq (Eq { pt := pt✝, π := π✝ } { pt := pt, π := π }) (And (Eq pt✝ pt) (HEq π✝ π))","decl":"/-- A `c : Cone F` is:\n* an object `c.pt` and\n* a natural transformation `c.π : c.pt ⟶ F` from the constant `c.pt` functor to `F`.\n\nExample: if `J` is a category coming from a poset then the data required to make\na term of type `Cone F` is morphisms `πⱼ : c.pt ⟶ F j` for all `j : J` and,\nfor all `i ≤ j` in `J`, morphisms `πᵢⱼ : F i ⟶ F j` such that `πᵢ ≫ πᵢⱼ = πᵢ`.\n\n`Cone F` is equivalent, via `cone.equiv` below, to `Σ X, F.cones.obj X`.\n-/\nstructure Cone (F : J ⥤ C) where\n  /-- An object of `C` -/\n  pt : C\n  /-- A natural transformation from the constant functor at `X` to `F` -/\n  π : (const J).obj pt ⟶ F\n\n"}
{"name":"CategoryTheory.Limits.Cone.mk.inj","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\npt✝ : C\nπ✝ : Quiver.Hom ((CategoryTheory.Functor.const J).obj pt✝) F\npt : C\nπ : Quiver.Hom ((CategoryTheory.Functor.const J).obj pt) F\nx✝ : Eq { pt := pt✝, π := π✝ } { pt := pt, π := π }\n⊢ And (Eq pt✝ pt) (HEq π✝ π)","decl":"/-- A `c : Cone F` is:\n* an object `c.pt` and\n* a natural transformation `c.π : c.pt ⟶ F` from the constant `c.pt` functor to `F`.\n\nExample: if `J` is a category coming from a poset then the data required to make\na term of type `Cone F` is morphisms `πⱼ : c.pt ⟶ F j` for all `j : J` and,\nfor all `i ≤ j` in `J`, morphisms `πᵢⱼ : F i ⟶ F j` such that `πᵢ ≫ πᵢⱼ = πᵢ`.\n\n`Cone F` is equivalent, via `cone.equiv` below, to `Σ X, F.cones.obj X`.\n-/\nstructure Cone (F : J ⥤ C) where\n  /-- An object of `C` -/\n  pt : C\n  /-- A natural transformation from the constant functor at `X` to `F` -/\n  π : (const J).obj pt ⟶ F\n\n"}
{"name":"CategoryTheory.Limits.Cone.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝² : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\ninst✝¹ : SizeOf J\ninst✝ : SizeOf C\npt : C\nπ : Quiver.Hom ((CategoryTheory.Functor.const J).obj pt) F\n⊢ Eq (SizeOf.sizeOf { pt := pt, π := π }) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf pt)) (SizeOf.sizeOf π))","decl":"/-- A `c : Cone F` is:\n* an object `c.pt` and\n* a natural transformation `c.π : c.pt ⟶ F` from the constant `c.pt` functor to `F`.\n\nExample: if `J` is a category coming from a poset then the data required to make\na term of type `Cone F` is morphisms `πⱼ : c.pt ⟶ F j` for all `j : J` and,\nfor all `i ≤ j` in `J`, morphisms `πᵢⱼ : F i ⟶ F j` such that `πᵢ ≫ πᵢⱼ = πᵢ`.\n\n`Cone F` is equivalent, via `cone.equiv` below, to `Σ X, F.cones.obj X`.\n-/\nstructure Cone (F : J ⥤ C) where\n  /-- An object of `C` -/\n  pt : C\n  /-- A natural transformation from the constant functor at `X` to `F` -/\n  π : (const J).obj pt ⟶ F\n\n"}
{"name":"CategoryTheory.Limits.Cone.w","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\nc : CategoryTheory.Limits.Cone F\nj j' : J\nf : Quiver.Hom j j'\n⊢ Eq (CategoryTheory.CategoryStruct.comp (c.π.app j) (F.map f)) (c.π.app j')","decl":"@[reassoc (attr := simp)]\ntheorem Cone.w {F : J ⥤ C} (c : Cone F) {j j' : J} (f : j ⟶ j') :\n    c.π.app j ≫ F.map f = c.π.app j' := by\n  rw [← c.π.naturality f]\n  apply id_comp\n\n"}
{"name":"CategoryTheory.Limits.Cone.w_assoc","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\nc : CategoryTheory.Limits.Cone F\nj j' : J\nf : Quiver.Hom j j'\nZ : C\nh : Quiver.Hom (F.obj j') Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (c.π.app j) (CategoryTheory.CategoryStruct.comp (F.map f) h)) (CategoryTheory.CategoryStruct.comp (c.π.app j') h)","decl":"@[reassoc (attr := simp)]\ntheorem Cone.w {F : J ⥤ C} (c : Cone F) {j j' : J} (f : j ⟶ j') :\n    c.π.app j ≫ F.map f = c.π.app j' := by\n  rw [← c.π.naturality f]\n  apply id_comp\n\n"}
{"name":"CategoryTheory.Limits.Cocone.mk.injEq","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\npt✝ : C\nι✝ : Quiver.Hom F ((CategoryTheory.Functor.const J).obj pt✝)\npt : C\nι : Quiver.Hom F ((CategoryTheory.Functor.const J).obj pt)\n⊢ Eq (Eq { pt := pt✝, ι := ι✝ } { pt := pt, ι := ι }) (And (Eq pt✝ pt) (HEq ι✝ ι))","decl":"/-- A `c : Cocone F` is\n* an object `c.pt` and\n* a natural transformation `c.ι : F ⟶ c.pt` from `F` to the constant `c.pt` functor.\n\nFor example, if the source `J` of `F` is a partially ordered set, then to give\n`c : Cocone F` is to give a collection of morphisms `ιⱼ : F j ⟶ c.pt` and, for\nall `j ≤ k` in `J`, morphisms `ιⱼₖ : F j ⟶ F k` such that `Fⱼₖ ≫ Fₖ = Fⱼ` for all `j ≤ k`.\n\n`Cocone F` is equivalent, via `Cone.equiv` below, to `Σ X, F.cocones.obj X`.\n-/\nstructure Cocone (F : J ⥤ C) where\n  /-- An object of `C` -/\n  pt : C\n  /-- A natural transformation from `F` to the constant functor at `pt` -/\n  ι : F ⟶ (const J).obj pt\n\n"}
{"name":"CategoryTheory.Limits.Cocone.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝² : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\ninst✝¹ : SizeOf J\ninst✝ : SizeOf C\npt : C\nι : Quiver.Hom F ((CategoryTheory.Functor.const J).obj pt)\n⊢ Eq (SizeOf.sizeOf { pt := pt, ι := ι }) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf pt)) (SizeOf.sizeOf ι))","decl":"/-- A `c : Cocone F` is\n* an object `c.pt` and\n* a natural transformation `c.ι : F ⟶ c.pt` from `F` to the constant `c.pt` functor.\n\nFor example, if the source `J` of `F` is a partially ordered set, then to give\n`c : Cocone F` is to give a collection of morphisms `ιⱼ : F j ⟶ c.pt` and, for\nall `j ≤ k` in `J`, morphisms `ιⱼₖ : F j ⟶ F k` such that `Fⱼₖ ≫ Fₖ = Fⱼ` for all `j ≤ k`.\n\n`Cocone F` is equivalent, via `Cone.equiv` below, to `Σ X, F.cocones.obj X`.\n-/\nstructure Cocone (F : J ⥤ C) where\n  /-- An object of `C` -/\n  pt : C\n  /-- A natural transformation from `F` to the constant functor at `pt` -/\n  ι : F ⟶ (const J).obj pt\n\n"}
{"name":"CategoryTheory.Limits.Cocone.mk.inj","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\npt✝ : C\nι✝ : Quiver.Hom F ((CategoryTheory.Functor.const J).obj pt✝)\npt : C\nι : Quiver.Hom F ((CategoryTheory.Functor.const J).obj pt)\nx✝ : Eq { pt := pt✝, ι := ι✝ } { pt := pt, ι := ι }\n⊢ And (Eq pt✝ pt) (HEq ι✝ ι)","decl":"/-- A `c : Cocone F` is\n* an object `c.pt` and\n* a natural transformation `c.ι : F ⟶ c.pt` from `F` to the constant `c.pt` functor.\n\nFor example, if the source `J` of `F` is a partially ordered set, then to give\n`c : Cocone F` is to give a collection of morphisms `ιⱼ : F j ⟶ c.pt` and, for\nall `j ≤ k` in `J`, morphisms `ιⱼₖ : F j ⟶ F k` such that `Fⱼₖ ≫ Fₖ = Fⱼ` for all `j ≤ k`.\n\n`Cocone F` is equivalent, via `Cone.equiv` below, to `Σ X, F.cocones.obj X`.\n-/\nstructure Cocone (F : J ⥤ C) where\n  /-- An object of `C` -/\n  pt : C\n  /-- A natural transformation from `F` to the constant functor at `pt` -/\n  ι : F ⟶ (const J).obj pt\n\n"}
{"name":"CategoryTheory.Limits.Cocone.w_assoc","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\nc : CategoryTheory.Limits.Cocone F\nj j' : J\nf : Quiver.Hom j j'\nZ : C\nh : Quiver.Hom (((CategoryTheory.Functor.const J).obj c.pt).obj j') Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (F.map f) (CategoryTheory.CategoryStruct.comp (c.ι.app j') h)) (CategoryTheory.CategoryStruct.comp (c.ι.app j) h)","decl":"@[reassoc]\ntheorem Cocone.w {F : J ⥤ C} (c : Cocone F) {j j' : J} (f : j ⟶ j') :\n    F.map f ≫ c.ι.app j' = c.ι.app j := by\n  rw [c.ι.naturality f]\n  apply comp_id\n\n"}
{"name":"CategoryTheory.Limits.Cocone.w","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\nc : CategoryTheory.Limits.Cocone F\nj j' : J\nf : Quiver.Hom j j'\n⊢ Eq (CategoryTheory.CategoryStruct.comp (F.map f) (c.ι.app j')) (c.ι.app j)","decl":"@[reassoc]\ntheorem Cocone.w {F : J ⥤ C} (c : Cocone F) {j j' : J} (f : j ⟶ j') :\n    F.map f ≫ c.ι.app j' = c.ι.app j := by\n  rw [c.ι.naturality f]\n  apply comp_id\n\n"}
{"name":"CategoryTheory.Limits.Cone.equiv_inv_π","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\nc : Sigma fun X => F.cones.obj X\n⊢ Eq ((CategoryTheory.Limits.Cone.equiv F).inv c).π c.snd","decl":"/-- The isomorphism between a cone on `F` and an element of the functor `F.cones`. -/\n@[simps!]\ndef equiv (F : J ⥤ C) : Cone F ≅ ΣX, F.cones.obj X where\n  hom c := ⟨op c.pt, c.π⟩\n  inv c :=\n    { pt := c.1.unop\n      π := c.2 }\n  hom_inv_id := by\n    funext X\n    cases X\n    rfl\n  inv_hom_id := by\n    funext X\n    cases X\n    rfl\n\n"}
{"name":"CategoryTheory.Limits.Cone.equiv_inv_pt","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\nc : Sigma fun X => F.cones.obj X\n⊢ Eq ((CategoryTheory.Limits.Cone.equiv F).inv c).pt (Opposite.unop c.fst)","decl":"/-- The isomorphism between a cone on `F` and an element of the functor `F.cones`. -/\n@[simps!]\ndef equiv (F : J ⥤ C) : Cone F ≅ ΣX, F.cones.obj X where\n  hom c := ⟨op c.pt, c.π⟩\n  inv c :=\n    { pt := c.1.unop\n      π := c.2 }\n  hom_inv_id := by\n    funext X\n    cases X\n    rfl\n  inv_hom_id := by\n    funext X\n    cases X\n    rfl\n\n"}
{"name":"CategoryTheory.Limits.Cone.equiv_hom_snd","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\nc : CategoryTheory.Limits.Cone F\n⊢ Eq ((CategoryTheory.Limits.Cone.equiv F).hom c).snd c.π","decl":"/-- The isomorphism between a cone on `F` and an element of the functor `F.cones`. -/\n@[simps!]\ndef equiv (F : J ⥤ C) : Cone F ≅ ΣX, F.cones.obj X where\n  hom c := ⟨op c.pt, c.π⟩\n  inv c :=\n    { pt := c.1.unop\n      π := c.2 }\n  hom_inv_id := by\n    funext X\n    cases X\n    rfl\n  inv_hom_id := by\n    funext X\n    cases X\n    rfl\n\n"}
{"name":"CategoryTheory.Limits.Cone.equiv_hom_fst","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\nc : CategoryTheory.Limits.Cone F\n⊢ Eq ((CategoryTheory.Limits.Cone.equiv F).hom c).fst { unop := c.pt }","decl":"/-- The isomorphism between a cone on `F` and an element of the functor `F.cones`. -/\n@[simps!]\ndef equiv (F : J ⥤ C) : Cone F ≅ ΣX, F.cones.obj X where\n  hom c := ⟨op c.pt, c.π⟩\n  inv c :=\n    { pt := c.1.unop\n      π := c.2 }\n  hom_inv_id := by\n    funext X\n    cases X\n    rfl\n  inv_hom_id := by\n    funext X\n    cases X\n    rfl\n\n"}
{"name":"CategoryTheory.Limits.Cone.extensions_app","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\nc : CategoryTheory.Limits.Cone F\nx✝ : Opposite C\nf : ((CategoryTheory.yoneda.obj c.pt).comp CategoryTheory.uliftFunctor.{u₁, v₃}).obj x✝\n⊢ Eq (c.extensions.app x✝ f) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Functor.const J).map f.down) c.π)","decl":"/-- A map to the vertex of a cone naturally induces a cone by composition. -/\n@[simps]\ndef extensions (c : Cone F) : yoneda.obj c.pt ⋙ uliftFunctor.{u₁} ⟶ F.cones where\n  app _ f := (const J).map f.down ≫ c.π\n\n"}
{"name":"CategoryTheory.Limits.Cone.extend_π","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\nc : CategoryTheory.Limits.Cone F\nX : C\nf : Quiver.Hom X c.pt\n⊢ Eq (c.extend f).π (c.extensions.app { unop := X } { down := f })","decl":"/-- A map to the vertex of a cone induces a cone by composition. -/\n@[simps]\ndef extend (c : Cone F) {X : C} (f : X ⟶ c.pt) : Cone F :=\n  { pt := X\n    π := c.extensions.app (op X) ⟨f⟩ }\n\n"}
{"name":"CategoryTheory.Limits.Cone.extend_pt","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\nc : CategoryTheory.Limits.Cone F\nX : C\nf : Quiver.Hom X c.pt\n⊢ Eq (c.extend f).pt X","decl":"/-- A map to the vertex of a cone induces a cone by composition. -/\n@[simps]\ndef extend (c : Cone F) {X : C} (f : X ⟶ c.pt) : Cone F :=\n  { pt := X\n    π := c.extensions.app (op X) ⟨f⟩ }\n\n"}
{"name":"CategoryTheory.Limits.Cone.whisker_pt","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nK : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} K\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\nE : CategoryTheory.Functor K J\nc : CategoryTheory.Limits.Cone F\n⊢ Eq (CategoryTheory.Limits.Cone.whisker E c).pt c.pt","decl":"/-- Whisker a cone by precomposition of a functor. -/\n@[simps]\ndef whisker (E : K ⥤ J) (c : Cone F) : Cone (E ⋙ F) where\n  pt := c.pt\n  π := whiskerLeft E c.π\n\n"}
{"name":"CategoryTheory.Limits.Cone.whisker_π","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nK : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} K\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\nE : CategoryTheory.Functor K J\nc : CategoryTheory.Limits.Cone F\n⊢ Eq (CategoryTheory.Limits.Cone.whisker E c).π (CategoryTheory.whiskerLeft E c.π)","decl":"/-- Whisker a cone by precomposition of a functor. -/\n@[simps]\ndef whisker (E : K ⥤ J) (c : Cone F) : Cone (E ⋙ F) where\n  pt := c.pt\n  π := whiskerLeft E c.π\n\n"}
{"name":"CategoryTheory.Limits.Cocone.extensions_app","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\nc : CategoryTheory.Limits.Cocone F\nx✝ : C\nf : ((CategoryTheory.coyoneda.obj { unop := c.pt }).comp CategoryTheory.uliftFunctor.{u₁, v₃}).obj x✝\n⊢ Eq (c.extensions.app x✝ f) (CategoryTheory.CategoryStruct.comp c.ι ((CategoryTheory.Functor.const J).map f.down))","decl":"/-- A map from the vertex of a cocone naturally induces a cocone by composition. -/\n@[simps]\ndef extensions (c : Cocone F) : coyoneda.obj (op c.pt) ⋙ uliftFunctor.{u₁} ⟶ F.cocones where\n  app _ f := c.ι ≫ (const J).map f.down\n\n"}
{"name":"CategoryTheory.Limits.Cocone.extend_ι","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\nc : CategoryTheory.Limits.Cocone F\nY : C\nf : Quiver.Hom c.pt Y\n⊢ Eq (c.extend f).ι (c.extensions.app Y { down := f })","decl":"/-- A map from the vertex of a cocone induces a cocone by composition. -/\n@[simps]\ndef extend (c : Cocone F) {Y : C} (f : c.pt ⟶ Y) : Cocone F where\n  pt := Y\n  ι := c.extensions.app Y ⟨f⟩\n\n"}
{"name":"CategoryTheory.Limits.Cocone.extend_pt","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\nc : CategoryTheory.Limits.Cocone F\nY : C\nf : Quiver.Hom c.pt Y\n⊢ Eq (c.extend f).pt Y","decl":"/-- A map from the vertex of a cocone induces a cocone by composition. -/\n@[simps]\ndef extend (c : Cocone F) {Y : C} (f : c.pt ⟶ Y) : Cocone F where\n  pt := Y\n  ι := c.extensions.app Y ⟨f⟩\n\n"}
{"name":"CategoryTheory.Limits.Cocone.whisker_ι","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nK : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} K\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\nE : CategoryTheory.Functor K J\nc : CategoryTheory.Limits.Cocone F\n⊢ Eq (CategoryTheory.Limits.Cocone.whisker E c).ι (CategoryTheory.whiskerLeft E c.ι)","decl":"/-- Whisker a cocone by precomposition of a functor. See `whiskering` for a functorial\nversion.\n-/\n@[simps]\ndef whisker (E : K ⥤ J) (c : Cocone F) : Cocone (E ⋙ F) where\n  pt := c.pt\n  ι := whiskerLeft E c.ι\n\n"}
{"name":"CategoryTheory.Limits.Cocone.whisker_pt","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nK : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} K\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\nE : CategoryTheory.Functor K J\nc : CategoryTheory.Limits.Cocone F\n⊢ Eq (CategoryTheory.Limits.Cocone.whisker E c).pt c.pt","decl":"/-- Whisker a cocone by precomposition of a functor. See `whiskering` for a functorial\nversion.\n-/\n@[simps]\ndef whisker (E : K ⥤ J) (c : Cocone F) : Cocone (E ⋙ F) where\n  pt := c.pt\n  ι := whiskerLeft E c.ι\n\n"}
{"name":"CategoryTheory.Limits.ConeMorphism.mk.injEq","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\nA B : CategoryTheory.Limits.Cone F\nhom✝ : Quiver.Hom A.pt B.pt\nw✝ : autoParam (∀ (j : J), Eq (CategoryTheory.CategoryStruct.comp hom✝ (B.π.app j)) (A.π.app j)) _auto✝\nhom : Quiver.Hom A.pt B.pt\nw : autoParam (∀ (j : J), Eq (CategoryTheory.CategoryStruct.comp hom (B.π.app j)) (A.π.app j)) _auto✝\n⊢ Eq (Eq { hom := hom✝, w := w✝ } { hom := hom, w := w }) (Eq hom✝ hom)","decl":"/-- A cone morphism between two cones for the same diagram is a morphism of the cone points which\ncommutes with the cone legs. -/\nstructure ConeMorphism (A B : Cone F) where\n  /-- A morphism between the two vertex objects of the cones -/\n  hom : A.pt ⟶ B.pt\n  /-- The triangle consisting of the two natural transformations and `hom` commutes -/\n  w : ∀ j : J, hom ≫ B.π.app j = A.π.app j := by aesop_cat\n\n"}
{"name":"CategoryTheory.Limits.ConeMorphism.w","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\nA B : CategoryTheory.Limits.Cone F\nself : CategoryTheory.Limits.ConeMorphism A B\nj : J\n⊢ Eq (CategoryTheory.CategoryStruct.comp self.hom (B.π.app j)) (A.π.app j)","decl":"/-- A cone morphism between two cones for the same diagram is a morphism of the cone points which\ncommutes with the cone legs. -/\nstructure ConeMorphism (A B : Cone F) where\n  /-- A morphism between the two vertex objects of the cones -/\n  hom : A.pt ⟶ B.pt\n  /-- The triangle consisting of the two natural transformations and `hom` commutes -/\n  w : ∀ j : J, hom ≫ B.π.app j = A.π.app j := by aesop_cat\n\n"}
{"name":"CategoryTheory.Limits.ConeMorphism.mk.inj","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\nA B : CategoryTheory.Limits.Cone F\nhom✝ : Quiver.Hom A.pt B.pt\nw✝ : autoParam (∀ (j : J), Eq (CategoryTheory.CategoryStruct.comp hom✝ (B.π.app j)) (A.π.app j)) _auto✝\nhom : Quiver.Hom A.pt B.pt\nw : autoParam (∀ (j : J), Eq (CategoryTheory.CategoryStruct.comp hom (B.π.app j)) (A.π.app j)) _auto✝\nx✝ : Eq { hom := hom✝, w := w✝ } { hom := hom, w := w }\n⊢ Eq hom✝ hom","decl":"/-- A cone morphism between two cones for the same diagram is a morphism of the cone points which\ncommutes with the cone legs. -/\nstructure ConeMorphism (A B : Cone F) where\n  /-- A morphism between the two vertex objects of the cones -/\n  hom : A.pt ⟶ B.pt\n  /-- The triangle consisting of the two natural transformations and `hom` commutes -/\n  w : ∀ j : J, hom ≫ B.π.app j = A.π.app j := by aesop_cat\n\n"}
{"name":"CategoryTheory.Limits.ConeMorphism.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝² : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\nA B : CategoryTheory.Limits.Cone F\ninst✝¹ : SizeOf J\ninst✝ : SizeOf C\nhom : Quiver.Hom A.pt B.pt\nw : autoParam (∀ (j : J), Eq (CategoryTheory.CategoryStruct.comp hom (B.π.app j)) (A.π.app j)) _auto✝\n⊢ Eq (SizeOf.sizeOf { hom := hom, w := w }) (HAdd.hAdd 1 (SizeOf.sizeOf hom))","decl":"/-- A cone morphism between two cones for the same diagram is a morphism of the cone points which\ncommutes with the cone legs. -/\nstructure ConeMorphism (A B : Cone F) where\n  /-- A morphism between the two vertex objects of the cones -/\n  hom : A.pt ⟶ B.pt\n  /-- The triangle consisting of the two natural transformations and `hom` commutes -/\n  w : ∀ j : J, hom ≫ B.π.app j = A.π.app j := by aesop_cat\n\n"}
{"name":"CategoryTheory.Limits.ConeMorphism.w_assoc","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\nA B : CategoryTheory.Limits.Cone F\nself : CategoryTheory.Limits.ConeMorphism A B\nj : J\nZ : C\nh : Quiver.Hom (F.obj j) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp self.hom (CategoryTheory.CategoryStruct.comp (B.π.app j) h)) (CategoryTheory.CategoryStruct.comp (A.π.app j) h)","decl":"attribute [reassoc (attr := simp)] ConeMorphism.w\n\n"}
{"name":"CategoryTheory.Limits.Cone.category_comp_hom","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\nX✝ Y✝ Z✝ : CategoryTheory.Limits.Cone F\nf : Quiver.Hom X✝ Y✝\ng : Quiver.Hom Y✝ Z✝\n⊢ Eq (CategoryTheory.CategoryStruct.comp f g).hom (CategoryTheory.CategoryStruct.comp f.hom g.hom)","decl":"/-- The category of cones on a given diagram. -/\n@[simps]\ninstance Cone.category : Category (Cone F) where\n  Hom A B := ConeMorphism A B\n  comp f g := { hom := f.hom ≫ g.hom }\n  id B := { hom := 𝟙 B.pt }\n\n-- Porting note: if we do not have `simps` automatically generate the lemma for simplifying\n-- the hom field of a category, we need to write the `ext` lemma in terms of the categorical\n-- morphism, rather than the underlying structure.\n"}
{"name":"CategoryTheory.Limits.Cone.category_id_hom","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\nB : CategoryTheory.Limits.Cone F\n⊢ Eq (CategoryTheory.CategoryStruct.id B).hom (CategoryTheory.CategoryStruct.id B.pt)","decl":"/-- The category of cones on a given diagram. -/\n@[simps]\ninstance Cone.category : Category (Cone F) where\n  Hom A B := ConeMorphism A B\n  comp f g := { hom := f.hom ≫ g.hom }\n  id B := { hom := 𝟙 B.pt }\n\n-- Porting note: if we do not have `simps` automatically generate the lemma for simplifying\n-- the hom field of a category, we need to write the `ext` lemma in terms of the categorical\n-- morphism, rather than the underlying structure.\n"}
{"name":"CategoryTheory.Limits.ConeMorphism.ext_iff","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\nc c' : CategoryTheory.Limits.Cone F\nf g : Quiver.Hom c c'\n⊢ Iff (Eq f g) (Eq f.hom g.hom)","decl":"@[ext]\ntheorem ConeMorphism.ext {c c' : Cone F} (f g : c ⟶ c') (w : f.hom = g.hom) : f = g := by\n  cases f\n  cases g\n  congr\n\n"}
{"name":"CategoryTheory.Limits.ConeMorphism.ext","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\nc c' : CategoryTheory.Limits.Cone F\nf g : Quiver.Hom c c'\nw : Eq f.hom g.hom\n⊢ Eq f g","decl":"@[ext]\ntheorem ConeMorphism.ext {c c' : Cone F} (f g : c ⟶ c') (w : f.hom = g.hom) : f = g := by\n  cases f\n  cases g\n  congr\n\n"}
{"name":"CategoryTheory.Limits.Cones.ext_hom_hom","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\nc c' : CategoryTheory.Limits.Cone F\nφ : CategoryTheory.Iso c.pt c'.pt\nw : autoParam (∀ (j : J), Eq (c.π.app j) (CategoryTheory.CategoryStruct.comp φ.hom (c'.π.app j))) _auto✝\n⊢ Eq (CategoryTheory.Limits.Cones.ext φ w).hom.hom φ.hom","decl":"/-- To give an isomorphism between cones, it suffices to give an\n  isomorphism between their vertices which commutes with the cone\n  maps. -/\n@[aesop apply safe (rule_sets := [CategoryTheory]), simps]\ndef ext {c c' : Cone F} (φ : c.pt ≅ c'.pt)\n    (w : ∀ j, c.π.app j = φ.hom ≫ c'.π.app j := by aesop_cat) : c ≅ c' where\n  hom := { hom := φ.hom }\n  inv :=\n    { hom := φ.inv\n      w := fun j => φ.inv_comp_eq.mpr (w j) }\n\n"}
{"name":"CategoryTheory.Limits.Cones.ext_inv_hom","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\nc c' : CategoryTheory.Limits.Cone F\nφ : CategoryTheory.Iso c.pt c'.pt\nw : autoParam (∀ (j : J), Eq (c.π.app j) (CategoryTheory.CategoryStruct.comp φ.hom (c'.π.app j))) _auto✝\n⊢ Eq (CategoryTheory.Limits.Cones.ext φ w).inv.hom φ.inv","decl":"/-- To give an isomorphism between cones, it suffices to give an\n  isomorphism between their vertices which commutes with the cone\n  maps. -/\n@[aesop apply safe (rule_sets := [CategoryTheory]), simps]\ndef ext {c c' : Cone F} (φ : c.pt ≅ c'.pt)\n    (w : ∀ j, c.π.app j = φ.hom ≫ c'.π.app j := by aesop_cat) : c ≅ c' where\n  hom := { hom := φ.hom }\n  inv :=\n    { hom := φ.inv\n      w := fun j => φ.inv_comp_eq.mpr (w j) }\n\n"}
{"name":"CategoryTheory.Limits.Cones.eta_hom_hom","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\nc : CategoryTheory.Limits.Cone F\n⊢ Eq (CategoryTheory.Limits.Cones.eta c).hom.hom (CategoryTheory.CategoryStruct.id c.pt)","decl":"/-- Eta rule for cones. -/\n@[simps!]\ndef eta (c : Cone F) : c ≅ ⟨c.pt, c.π⟩ :=\n  Cones.ext (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Limits.Cones.eta_inv_hom","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\nc : CategoryTheory.Limits.Cone F\n⊢ Eq (CategoryTheory.Limits.Cones.eta c).inv.hom (CategoryTheory.CategoryStruct.id c.pt)","decl":"/-- Eta rule for cones. -/\n@[simps!]\ndef eta (c : Cone F) : c ≅ ⟨c.pt, c.π⟩ :=\n  Cones.ext (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Limits.Cones.cone_iso_of_hom_iso","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nK : CategoryTheory.Functor J C\nc d : CategoryTheory.Limits.Cone K\nf : Quiver.Hom c d\ni : CategoryTheory.IsIso f.hom\n⊢ CategoryTheory.IsIso f","decl":"/-- Given a cone morphism whose object part is an isomorphism, produce an\nisomorphism of cones.\n-/\ntheorem cone_iso_of_hom_iso {K : J ⥤ C} {c d : Cone K} (f : c ⟶ d) [i : IsIso f.hom] : IsIso f :=\n  ⟨⟨{   hom := inv f.hom\n        w := fun j => (asIso f.hom).inv_comp_eq.2 (f.w j).symm }, by aesop_cat⟩⟩\n\n"}
{"name":"CategoryTheory.Limits.Cones.extend_hom","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\ns : CategoryTheory.Limits.Cone F\nX : C\nf : Quiver.Hom X s.pt\n⊢ Eq (CategoryTheory.Limits.Cones.extend s f).hom f","decl":"/-- There is a morphism from an extended cone to the original cone. -/\n@[simps]\ndef extend (s : Cone F) {X : C} (f : X ⟶ s.pt) : s.extend f ⟶ s where\n  hom := f\n\n"}
{"name":"CategoryTheory.Limits.Cones.extendId_inv_hom","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\ns : CategoryTheory.Limits.Cone F\n⊢ Eq (CategoryTheory.Limits.Cones.extendId s).inv.hom (CategoryTheory.CategoryStruct.id s.pt)","decl":"/-- Extending a cone by the identity does nothing. -/\n@[simps!]\ndef extendId (s : Cone F) : s.extend (𝟙 s.pt) ≅ s :=\n  Cones.ext (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Limits.Cones.extendId_hom_hom","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\ns : CategoryTheory.Limits.Cone F\n⊢ Eq (CategoryTheory.Limits.Cones.extendId s).hom.hom (CategoryTheory.CategoryStruct.id s.pt)","decl":"/-- Extending a cone by the identity does nothing. -/\n@[simps!]\ndef extendId (s : Cone F) : s.extend (𝟙 s.pt) ≅ s :=\n  Cones.ext (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Limits.Cones.extendComp_inv_hom","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\ns : CategoryTheory.Limits.Cone F\nX Y : C\nf : Quiver.Hom X Y\ng : Quiver.Hom Y s.pt\n⊢ Eq (CategoryTheory.Limits.Cones.extendComp s f g).inv.hom (CategoryTheory.CategoryStruct.id X)","decl":"/-- Extending a cone by a composition is the same as extending the cone twice. -/\n@[simps!]\ndef extendComp (s : Cone F) {X Y : C} (f : X ⟶ Y) (g : Y ⟶ s.pt) :\n    s.extend (f ≫ g) ≅ (s.extend g).extend f :=\n  Cones.ext (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Limits.Cones.extendComp_hom_hom","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\ns : CategoryTheory.Limits.Cone F\nX Y : C\nf : Quiver.Hom X Y\ng : Quiver.Hom Y s.pt\n⊢ Eq (CategoryTheory.Limits.Cones.extendComp s f g).hom.hom (CategoryTheory.CategoryStruct.id X)","decl":"/-- Extending a cone by a composition is the same as extending the cone twice. -/\n@[simps!]\ndef extendComp (s : Cone F) {X Y : C} (f : X ⟶ Y) (g : Y ⟶ s.pt) :\n    s.extend (f ≫ g) ≅ (s.extend g).extend f :=\n  Cones.ext (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Limits.Cones.extendIso_inv_hom","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\ns : CategoryTheory.Limits.Cone F\nX : C\nf : CategoryTheory.Iso X s.pt\n⊢ Eq (CategoryTheory.Limits.Cones.extendIso s f).inv.hom f.inv","decl":"/-- A cone extended by an isomorphism is isomorphic to the original cone. -/\n@[simps]\ndef extendIso (s : Cone F) {X : C} (f : X ≅ s.pt) : s.extend f.hom ≅ s where\n  hom := { hom := f.hom }\n  inv := { hom := f.inv }\n\n"}
{"name":"CategoryTheory.Limits.Cones.extendIso_hom_hom","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\ns : CategoryTheory.Limits.Cone F\nX : C\nf : CategoryTheory.Iso X s.pt\n⊢ Eq (CategoryTheory.Limits.Cones.extendIso s f).hom.hom f.hom","decl":"/-- A cone extended by an isomorphism is isomorphic to the original cone. -/\n@[simps]\ndef extendIso (s : Cone F) {X : C} (f : X ≅ s.pt) : s.extend f.hom ≅ s where\n  hom := { hom := f.hom }\n  inv := { hom := f.inv }\n\n"}
{"name":"CategoryTheory.Limits.Cones.instIsIsoConeExtend","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\ns : CategoryTheory.Limits.Cone F\nX : C\nf : Quiver.Hom X s.pt\ninst✝ : CategoryTheory.IsIso f\n⊢ CategoryTheory.IsIso (CategoryTheory.Limits.Cones.extend s f)","decl":"instance {s : Cone F} {X : C} (f : X ⟶ s.pt) [IsIso f] : IsIso (Cones.extend s f) :=\n  ⟨(extendIso s (asIso f)).inv, by aesop_cat⟩\n\n"}
{"name":"CategoryTheory.Limits.Cones.postcompose_map_hom","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF G : CategoryTheory.Functor J C\nα : Quiver.Hom F G\nX✝ Y✝ : CategoryTheory.Limits.Cone F\nf : Quiver.Hom X✝ Y✝\n⊢ Eq ((CategoryTheory.Limits.Cones.postcompose α).map f).hom f.hom","decl":"/--\nFunctorially postcompose a cone for `F` by a natural transformation `F ⟶ G` to give a cone for `G`.\n-/\n@[simps]\ndef postcompose {G : J ⥤ C} (α : F ⟶ G) : Cone F ⥤ Cone G where\n  obj c :=\n    { pt := c.pt\n      π := c.π ≫ α }\n  map f := { hom := f.hom }\n\n"}
{"name":"CategoryTheory.Limits.Cones.postcompose_obj_pt","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF G : CategoryTheory.Functor J C\nα : Quiver.Hom F G\nc : CategoryTheory.Limits.Cone F\n⊢ Eq ((CategoryTheory.Limits.Cones.postcompose α).obj c).pt c.pt","decl":"/--\nFunctorially postcompose a cone for `F` by a natural transformation `F ⟶ G` to give a cone for `G`.\n-/\n@[simps]\ndef postcompose {G : J ⥤ C} (α : F ⟶ G) : Cone F ⥤ Cone G where\n  obj c :=\n    { pt := c.pt\n      π := c.π ≫ α }\n  map f := { hom := f.hom }\n\n"}
{"name":"CategoryTheory.Limits.Cones.postcompose_obj_π","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF G : CategoryTheory.Functor J C\nα : Quiver.Hom F G\nc : CategoryTheory.Limits.Cone F\n⊢ Eq ((CategoryTheory.Limits.Cones.postcompose α).obj c).π (CategoryTheory.CategoryStruct.comp c.π α)","decl":"/--\nFunctorially postcompose a cone for `F` by a natural transformation `F ⟶ G` to give a cone for `G`.\n-/\n@[simps]\ndef postcompose {G : J ⥤ C} (α : F ⟶ G) : Cone F ⥤ Cone G where\n  obj c :=\n    { pt := c.pt\n      π := c.π ≫ α }\n  map f := { hom := f.hom }\n\n"}
{"name":"CategoryTheory.Limits.Cones.postcomposeComp_hom_app_hom","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF G H : CategoryTheory.Functor J C\nα : Quiver.Hom F G\nβ : Quiver.Hom G H\nX : CategoryTheory.Limits.Cone F\n⊢ Eq ((CategoryTheory.Limits.Cones.postcomposeComp α β).hom.app X).hom (CategoryTheory.CategoryStruct.id X.pt)","decl":"/-- Postcomposing a cone by the composite natural transformation `α ≫ β` is the same as\npostcomposing by `α` and then by `β`. -/\n@[simps!]\ndef postcomposeComp {G H : J ⥤ C} (α : F ⟶ G) (β : G ⟶ H) :\n    postcompose (α ≫ β) ≅ postcompose α ⋙ postcompose β :=\n  NatIso.ofComponents fun s => Cones.ext (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Limits.Cones.postcomposeComp_inv_app_hom","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF G H : CategoryTheory.Functor J C\nα : Quiver.Hom F G\nβ : Quiver.Hom G H\nX : CategoryTheory.Limits.Cone F\n⊢ Eq ((CategoryTheory.Limits.Cones.postcomposeComp α β).inv.app X).hom (CategoryTheory.CategoryStruct.id X.pt)","decl":"/-- Postcomposing a cone by the composite natural transformation `α ≫ β` is the same as\npostcomposing by `α` and then by `β`. -/\n@[simps!]\ndef postcomposeComp {G H : J ⥤ C} (α : F ⟶ G) (β : G ⟶ H) :\n    postcompose (α ≫ β) ≅ postcompose α ⋙ postcompose β :=\n  NatIso.ofComponents fun s => Cones.ext (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Limits.Cones.postcomposeId_hom_app_hom","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\nX : CategoryTheory.Limits.Cone F\n⊢ Eq (CategoryTheory.Limits.Cones.postcomposeId.hom.app X).hom (CategoryTheory.CategoryStruct.id X.pt)","decl":"/-- Postcomposing by the identity does not change the cone up to isomorphism. -/\n@[simps!]\ndef postcomposeId : postcompose (𝟙 F) ≅ 𝟭 (Cone F) :=\n  NatIso.ofComponents fun s => Cones.ext (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Limits.Cones.postcomposeId_inv_app_hom","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\nX : CategoryTheory.Limits.Cone F\n⊢ Eq (CategoryTheory.Limits.Cones.postcomposeId.inv.app X).hom (CategoryTheory.CategoryStruct.id X.pt)","decl":"/-- Postcomposing by the identity does not change the cone up to isomorphism. -/\n@[simps!]\ndef postcomposeId : postcompose (𝟙 F) ≅ 𝟭 (Cone F) :=\n  NatIso.ofComponents fun s => Cones.ext (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Limits.Cones.postcomposeEquivalence_unitIso","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF G : CategoryTheory.Functor J C\nα : CategoryTheory.Iso F G\n⊢ Eq (CategoryTheory.Limits.Cones.postcomposeEquivalence α).unitIso (CategoryTheory.NatIso.ofComponents (fun s => CategoryTheory.Limits.Cones.ext (CategoryTheory.Iso.refl ((CategoryTheory.Functor.id (CategoryTheory.Limits.Cone F)).obj s).pt) ⋯) ⋯)","decl":"/-- If `F` and `G` are naturally isomorphic functors, then they have equivalent categories of\ncones.\n-/\n@[simps]\ndef postcomposeEquivalence {G : J ⥤ C} (α : F ≅ G) : Cone F ≌ Cone G where\n  functor := postcompose α.hom\n  inverse := postcompose α.inv\n  unitIso := NatIso.ofComponents fun s => Cones.ext (Iso.refl _)\n  counitIso := NatIso.ofComponents fun s => Cones.ext (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Limits.Cones.postcomposeEquivalence_functor","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF G : CategoryTheory.Functor J C\nα : CategoryTheory.Iso F G\n⊢ Eq (CategoryTheory.Limits.Cones.postcomposeEquivalence α).functor (CategoryTheory.Limits.Cones.postcompose α.hom)","decl":"/-- If `F` and `G` are naturally isomorphic functors, then they have equivalent categories of\ncones.\n-/\n@[simps]\ndef postcomposeEquivalence {G : J ⥤ C} (α : F ≅ G) : Cone F ≌ Cone G where\n  functor := postcompose α.hom\n  inverse := postcompose α.inv\n  unitIso := NatIso.ofComponents fun s => Cones.ext (Iso.refl _)\n  counitIso := NatIso.ofComponents fun s => Cones.ext (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Limits.Cones.postcomposeEquivalence_counitIso","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF G : CategoryTheory.Functor J C\nα : CategoryTheory.Iso F G\n⊢ Eq (CategoryTheory.Limits.Cones.postcomposeEquivalence α).counitIso (CategoryTheory.NatIso.ofComponents (fun s => CategoryTheory.Limits.Cones.ext (CategoryTheory.Iso.refl (((CategoryTheory.Limits.Cones.postcompose α.inv).comp (CategoryTheory.Limits.Cones.postcompose α.hom)).obj s).pt) ⋯) ⋯)","decl":"/-- If `F` and `G` are naturally isomorphic functors, then they have equivalent categories of\ncones.\n-/\n@[simps]\ndef postcomposeEquivalence {G : J ⥤ C} (α : F ≅ G) : Cone F ≌ Cone G where\n  functor := postcompose α.hom\n  inverse := postcompose α.inv\n  unitIso := NatIso.ofComponents fun s => Cones.ext (Iso.refl _)\n  counitIso := NatIso.ofComponents fun s => Cones.ext (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Limits.Cones.postcomposeEquivalence_inverse","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF G : CategoryTheory.Functor J C\nα : CategoryTheory.Iso F G\n⊢ Eq (CategoryTheory.Limits.Cones.postcomposeEquivalence α).inverse (CategoryTheory.Limits.Cones.postcompose α.inv)","decl":"/-- If `F` and `G` are naturally isomorphic functors, then they have equivalent categories of\ncones.\n-/\n@[simps]\ndef postcomposeEquivalence {G : J ⥤ C} (α : F ≅ G) : Cone F ≌ Cone G where\n  functor := postcompose α.hom\n  inverse := postcompose α.inv\n  unitIso := NatIso.ofComponents fun s => Cones.ext (Iso.refl _)\n  counitIso := NatIso.ofComponents fun s => Cones.ext (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Limits.Cones.whiskering_map_hom","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nK : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} K\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\nE : CategoryTheory.Functor K J\nX✝ Y✝ : CategoryTheory.Limits.Cone F\nf : Quiver.Hom X✝ Y✝\n⊢ Eq ((CategoryTheory.Limits.Cones.whiskering E).map f).hom f.hom","decl":"/-- Whiskering on the left by `E : K ⥤ J` gives a functor from `Cone F` to `Cone (E ⋙ F)`.\n-/\n@[simps]\ndef whiskering (E : K ⥤ J) : Cone F ⥤ Cone (E ⋙ F) where\n  obj c := c.whisker E\n  map f := { hom := f.hom }\n\n"}
{"name":"CategoryTheory.Limits.Cones.whiskering_obj","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nK : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} K\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\nE : CategoryTheory.Functor K J\nc : CategoryTheory.Limits.Cone F\n⊢ Eq ((CategoryTheory.Limits.Cones.whiskering E).obj c) (CategoryTheory.Limits.Cone.whisker E c)","decl":"/-- Whiskering on the left by `E : K ⥤ J` gives a functor from `Cone F` to `Cone (E ⋙ F)`.\n-/\n@[simps]\ndef whiskering (E : K ⥤ J) : Cone F ⥤ Cone (E ⋙ F) where\n  obj c := c.whisker E\n  map f := { hom := f.hom }\n\n"}
{"name":"CategoryTheory.Limits.Cones.whiskeringEquivalence_inverse","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nK : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} K\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\ne : CategoryTheory.Equivalence K J\n⊢ Eq (CategoryTheory.Limits.Cones.whiskeringEquivalence e).inverse ((CategoryTheory.Limits.Cones.whiskering e.inverse).comp (CategoryTheory.Limits.Cones.postcompose (e.invFunIdAssoc F).hom))","decl":"/-- Whiskering by an equivalence gives an equivalence between categories of cones.\n-/\n@[simps]\ndef whiskeringEquivalence (e : K ≌ J) : Cone F ≌ Cone (e.functor ⋙ F) where\n  functor := whiskering e.functor\n  inverse := whiskering e.inverse ⋙ postcompose (e.invFunIdAssoc F).hom\n  unitIso := NatIso.ofComponents fun s => Cones.ext (Iso.refl _)\n  counitIso :=\n    NatIso.ofComponents\n      fun s =>\n        Cones.ext (Iso.refl _)\n          (by\n            intro k\n            simpa [e.counit_app_functor] using s.w (e.unitInv.app k))\n\n"}
{"name":"CategoryTheory.Limits.Cones.whiskeringEquivalence_unitIso","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nK : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} K\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\ne : CategoryTheory.Equivalence K J\n⊢ Eq (CategoryTheory.Limits.Cones.whiskeringEquivalence e).unitIso (CategoryTheory.NatIso.ofComponents (fun s => CategoryTheory.Limits.Cones.ext (CategoryTheory.Iso.refl ((CategoryTheory.Functor.id (CategoryTheory.Limits.Cone F)).obj s).pt) ⋯) ⋯)","decl":"/-- Whiskering by an equivalence gives an equivalence between categories of cones.\n-/\n@[simps]\ndef whiskeringEquivalence (e : K ≌ J) : Cone F ≌ Cone (e.functor ⋙ F) where\n  functor := whiskering e.functor\n  inverse := whiskering e.inverse ⋙ postcompose (e.invFunIdAssoc F).hom\n  unitIso := NatIso.ofComponents fun s => Cones.ext (Iso.refl _)\n  counitIso :=\n    NatIso.ofComponents\n      fun s =>\n        Cones.ext (Iso.refl _)\n          (by\n            intro k\n            simpa [e.counit_app_functor] using s.w (e.unitInv.app k))\n\n"}
{"name":"CategoryTheory.Limits.Cones.whiskeringEquivalence_functor","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nK : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} K\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\ne : CategoryTheory.Equivalence K J\n⊢ Eq (CategoryTheory.Limits.Cones.whiskeringEquivalence e).functor (CategoryTheory.Limits.Cones.whiskering e.functor)","decl":"/-- Whiskering by an equivalence gives an equivalence between categories of cones.\n-/\n@[simps]\ndef whiskeringEquivalence (e : K ≌ J) : Cone F ≌ Cone (e.functor ⋙ F) where\n  functor := whiskering e.functor\n  inverse := whiskering e.inverse ⋙ postcompose (e.invFunIdAssoc F).hom\n  unitIso := NatIso.ofComponents fun s => Cones.ext (Iso.refl _)\n  counitIso :=\n    NatIso.ofComponents\n      fun s =>\n        Cones.ext (Iso.refl _)\n          (by\n            intro k\n            simpa [e.counit_app_functor] using s.w (e.unitInv.app k))\n\n"}
{"name":"CategoryTheory.Limits.Cones.whiskeringEquivalence_counitIso","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nK : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} K\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\ne : CategoryTheory.Equivalence K J\n⊢ Eq (CategoryTheory.Limits.Cones.whiskeringEquivalence e).counitIso (CategoryTheory.NatIso.ofComponents (fun s => CategoryTheory.Limits.Cones.ext (CategoryTheory.Iso.refl ((((CategoryTheory.Limits.Cones.whiskering e.inverse).comp (CategoryTheory.Limits.Cones.postcompose (e.invFunIdAssoc F).hom)).comp (CategoryTheory.Limits.Cones.whiskering e.functor)).obj s).pt) ⋯) ⋯)","decl":"/-- Whiskering by an equivalence gives an equivalence between categories of cones.\n-/\n@[simps]\ndef whiskeringEquivalence (e : K ≌ J) : Cone F ≌ Cone (e.functor ⋙ F) where\n  functor := whiskering e.functor\n  inverse := whiskering e.inverse ⋙ postcompose (e.invFunIdAssoc F).hom\n  unitIso := NatIso.ofComponents fun s => Cones.ext (Iso.refl _)\n  counitIso :=\n    NatIso.ofComponents\n      fun s =>\n        Cones.ext (Iso.refl _)\n          (by\n            intro k\n            simpa [e.counit_app_functor] using s.w (e.unitInv.app k))\n\n"}
{"name":"CategoryTheory.Limits.Cones.equivalenceOfReindexing_unitIso","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nK : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} K\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\nG : CategoryTheory.Functor K C\ne : CategoryTheory.Equivalence K J\nα : CategoryTheory.Iso (e.functor.comp F) G\n⊢ Eq (CategoryTheory.Limits.Cones.equivalenceOfReindexing e α).unitIso ((CategoryTheory.NatIso.ofComponents (fun s => CategoryTheory.Limits.Cones.ext (CategoryTheory.Iso.refl s.pt) ⋯) ⋯).trans ((CategoryTheory.isoWhiskerRight ((CategoryTheory.Limits.Cones.whiskering e.functor).rightUnitor.symm.trans ((CategoryTheory.isoWhiskerLeft (CategoryTheory.Limits.Cones.whiskering e.functor) (CategoryTheory.NatIso.ofComponents (fun s => CategoryTheory.Limits.Cones.ext (CategoryTheory.Iso.refl s.pt) ⋯) ⋯)).trans ((CategoryTheory.Limits.Cones.whiskering e.functor).associator (CategoryTheory.Limits.Cones.postcompose α.hom) (CategoryTheory.Limits.Cones.postcompose α.inv)).symm)) ((CategoryTheory.Limits.Cones.whiskering e.inverse).comp (CategoryTheory.Limits.Cones.postcompose (e.invFunIdAssoc F).hom))).trans (((CategoryTheory.Limits.Cones.whiskering e.functor).comp (CategoryTheory.Limits.Cones.postcompose α.hom)).associator (CategoryTheory.Limits.Cones.postcompose α.inv) ((CategoryTheory.Limits.Cones.whiskering e.inverse).comp (CategoryTheory.Limits.Cones.postcompose (e.invFunIdAssoc F).hom)))))","decl":"/-- The categories of cones over `F` and `G` are equivalent if `F` and `G` are naturally isomorphic\n(possibly after changing the indexing category by an equivalence).\n-/\n@[simps! functor inverse unitIso counitIso]\ndef equivalenceOfReindexing {G : K ⥤ C} (e : K ≌ J) (α : e.functor ⋙ F ≅ G) : Cone F ≌ Cone G :=\n  (whiskeringEquivalence e).trans (postcomposeEquivalence α)\n\n"}
{"name":"CategoryTheory.Limits.Cones.equivalenceOfReindexing_functor","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nK : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} K\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\nG : CategoryTheory.Functor K C\ne : CategoryTheory.Equivalence K J\nα : CategoryTheory.Iso (e.functor.comp F) G\n⊢ Eq (CategoryTheory.Limits.Cones.equivalenceOfReindexing e α).functor ((CategoryTheory.Limits.Cones.whiskering e.functor).comp (CategoryTheory.Limits.Cones.postcompose α.hom))","decl":"/-- The categories of cones over `F` and `G` are equivalent if `F` and `G` are naturally isomorphic\n(possibly after changing the indexing category by an equivalence).\n-/\n@[simps! functor inverse unitIso counitIso]\ndef equivalenceOfReindexing {G : K ⥤ C} (e : K ≌ J) (α : e.functor ⋙ F ≅ G) : Cone F ≌ Cone G :=\n  (whiskeringEquivalence e).trans (postcomposeEquivalence α)\n\n"}
{"name":"CategoryTheory.Limits.Cones.equivalenceOfReindexing_counitIso","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nK : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} K\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\nG : CategoryTheory.Functor K C\ne : CategoryTheory.Equivalence K J\nα : CategoryTheory.Iso (e.functor.comp F) G\n⊢ Eq (CategoryTheory.Limits.Cones.equivalenceOfReindexing e α).counitIso ((((CategoryTheory.Limits.Cones.postcompose α.inv).comp ((CategoryTheory.Limits.Cones.whiskering e.inverse).comp (CategoryTheory.Limits.Cones.postcompose (e.invFunIdAssoc F).hom))).associator (CategoryTheory.Limits.Cones.whiskering e.functor) (CategoryTheory.Limits.Cones.postcompose α.hom)).symm.trans ((CategoryTheory.isoWhiskerRight (((CategoryTheory.Limits.Cones.postcompose α.inv).associator ((CategoryTheory.Limits.Cones.whiskering e.inverse).comp (CategoryTheory.Limits.Cones.postcompose (e.invFunIdAssoc F).hom)) (CategoryTheory.Limits.Cones.whiskering e.functor)).trans ((CategoryTheory.isoWhiskerLeft (CategoryTheory.Limits.Cones.postcompose α.inv) (CategoryTheory.NatIso.ofComponents (fun s => CategoryTheory.Limits.Cones.ext (CategoryTheory.Iso.refl s.pt) ⋯) ⋯)).trans (CategoryTheory.Limits.Cones.postcompose α.inv).rightUnitor)) (CategoryTheory.Limits.Cones.postcompose α.hom)).trans (CategoryTheory.NatIso.ofComponents (fun s => CategoryTheory.Limits.Cones.ext (CategoryTheory.Iso.refl s.pt) ⋯) ⋯)))","decl":"/-- The categories of cones over `F` and `G` are equivalent if `F` and `G` are naturally isomorphic\n(possibly after changing the indexing category by an equivalence).\n-/\n@[simps! functor inverse unitIso counitIso]\ndef equivalenceOfReindexing {G : K ⥤ C} (e : K ≌ J) (α : e.functor ⋙ F ≅ G) : Cone F ≌ Cone G :=\n  (whiskeringEquivalence e).trans (postcomposeEquivalence α)\n\n"}
{"name":"CategoryTheory.Limits.Cones.equivalenceOfReindexing_inverse","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nK : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} K\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\nG : CategoryTheory.Functor K C\ne : CategoryTheory.Equivalence K J\nα : CategoryTheory.Iso (e.functor.comp F) G\n⊢ Eq (CategoryTheory.Limits.Cones.equivalenceOfReindexing e α).inverse ((CategoryTheory.Limits.Cones.postcompose α.inv).comp ((CategoryTheory.Limits.Cones.whiskering e.inverse).comp (CategoryTheory.Limits.Cones.postcompose (e.invFunIdAssoc F).hom)))","decl":"/-- The categories of cones over `F` and `G` are equivalent if `F` and `G` are naturally isomorphic\n(possibly after changing the indexing category by an equivalence).\n-/\n@[simps! functor inverse unitIso counitIso]\ndef equivalenceOfReindexing {G : K ⥤ C} (e : K ≌ J) (α : e.functor ⋙ F ≅ G) : Cone F ≌ Cone G :=\n  (whiskeringEquivalence e).trans (postcomposeEquivalence α)\n\n"}
{"name":"CategoryTheory.Limits.Cones.forget_obj","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\nt : CategoryTheory.Limits.Cone F\n⊢ Eq ((CategoryTheory.Limits.Cones.forget F).obj t) t.pt","decl":"/-- Forget the cone structure and obtain just the cone point. -/\n@[simps]\ndef forget : Cone F ⥤ C where\n  obj t := t.pt\n  map f := f.hom\n\n"}
{"name":"CategoryTheory.Limits.Cones.forget_map","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\nX✝ Y✝ : CategoryTheory.Limits.Cone F\nf : Quiver.Hom X✝ Y✝\n⊢ Eq ((CategoryTheory.Limits.Cones.forget F).map f) f.hom","decl":"/-- Forget the cone structure and obtain just the cone point. -/\n@[simps]\ndef forget : Cone F ⥤ C where\n  obj t := t.pt\n  map f := f.hom\n\n"}
{"name":"CategoryTheory.Limits.Cones.functoriality_obj_pt","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} C\nD : Type u₄\ninst✝ : CategoryTheory.Category.{v₄, u₄} D\nF : CategoryTheory.Functor J C\nG : CategoryTheory.Functor C D\nA : CategoryTheory.Limits.Cone F\n⊢ Eq ((CategoryTheory.Limits.Cones.functoriality F G).obj A).pt (G.obj A.pt)","decl":"/-- A functor `G : C ⥤ D` sends cones over `F` to cones over `F ⋙ G` functorially. -/\n@[simps]\ndef functoriality : Cone F ⥤ Cone (F ⋙ G) where\n  obj A :=\n    { pt := G.obj A.pt\n      π :=\n        { app := fun j => G.map (A.π.app j)\n          naturality := by intros; erw [← G.map_comp]; simp } }\n  map f :=\n    { hom := G.map f.hom\n      w := fun j => by simp [-ConeMorphism.w, ← f.w j] }\n\n"}
{"name":"CategoryTheory.Limits.Cones.functoriality_obj_π_app","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} C\nD : Type u₄\ninst✝ : CategoryTheory.Category.{v₄, u₄} D\nF : CategoryTheory.Functor J C\nG : CategoryTheory.Functor C D\nA : CategoryTheory.Limits.Cone F\nj : J\n⊢ Eq (((CategoryTheory.Limits.Cones.functoriality F G).obj A).π.app j) (G.map (A.π.app j))","decl":"/-- A functor `G : C ⥤ D` sends cones over `F` to cones over `F ⋙ G` functorially. -/\n@[simps]\ndef functoriality : Cone F ⥤ Cone (F ⋙ G) where\n  obj A :=\n    { pt := G.obj A.pt\n      π :=\n        { app := fun j => G.map (A.π.app j)\n          naturality := by intros; erw [← G.map_comp]; simp } }\n  map f :=\n    { hom := G.map f.hom\n      w := fun j => by simp [-ConeMorphism.w, ← f.w j] }\n\n"}
{"name":"CategoryTheory.Limits.Cones.functoriality_map_hom","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} C\nD : Type u₄\ninst✝ : CategoryTheory.Category.{v₄, u₄} D\nF : CategoryTheory.Functor J C\nG : CategoryTheory.Functor C D\nX✝ Y✝ : CategoryTheory.Limits.Cone F\nf : Quiver.Hom X✝ Y✝\n⊢ Eq ((CategoryTheory.Limits.Cones.functoriality F G).map f).hom (G.map f.hom)","decl":"/-- A functor `G : C ⥤ D` sends cones over `F` to cones over `F ⋙ G` functorially. -/\n@[simps]\ndef functoriality : Cone F ⥤ Cone (F ⋙ G) where\n  obj A :=\n    { pt := G.obj A.pt\n      π :=\n        { app := fun j => G.map (A.π.app j)\n          naturality := by intros; erw [← G.map_comp]; simp } }\n  map f :=\n    { hom := G.map f.hom\n      w := fun j => by simp [-ConeMorphism.w, ← f.w j] }\n\n"}
{"name":"CategoryTheory.Limits.Cones.functoriality_full","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝³ : CategoryTheory.Category.{v₃, u₃} C\nD : Type u₄\ninst✝² : CategoryTheory.Category.{v₄, u₄} D\nF : CategoryTheory.Functor J C\nG : CategoryTheory.Functor C D\ninst✝¹ : G.Full\ninst✝ : G.Faithful\n⊢ (CategoryTheory.Limits.Cones.functoriality F G).Full","decl":"instance functoriality_full [G.Full] [G.Faithful] : (functoriality F G).Full where\n  map_surjective t :=\n    ⟨{ hom := G.preimage t.hom\n       w := fun j => G.map_injective (by simpa using t.w j) }, by aesop_cat⟩\n\n"}
{"name":"CategoryTheory.Limits.Cones.functoriality_faithful","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝² : CategoryTheory.Category.{v₃, u₃} C\nD : Type u₄\ninst✝¹ : CategoryTheory.Category.{v₄, u₄} D\nF : CategoryTheory.Functor J C\nG : CategoryTheory.Functor C D\ninst✝ : G.Faithful\n⊢ (CategoryTheory.Limits.Cones.functoriality F G).Faithful","decl":"instance functoriality_faithful [G.Faithful] : (Cones.functoriality F G).Faithful where\n  map_injective {_X} {_Y} f g h :=\n    ConeMorphism.ext f g <| G.map_injective <| congr_arg ConeMorphism.hom h\n\n"}
{"name":"CategoryTheory.Limits.Cones.functorialityEquivalence_functor","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} C\nD : Type u₄\ninst✝ : CategoryTheory.Category.{v₄, u₄} D\nF : CategoryTheory.Functor J C\ne : CategoryTheory.Equivalence C D\n⊢ Eq (CategoryTheory.Limits.Cones.functorialityEquivalence F e).functor (CategoryTheory.Limits.Cones.functoriality F e.functor)","decl":"/-- If `e : C ≌ D` is an equivalence of categories, then `functoriality F e.functor` induces an\nequivalence between cones over `F` and cones over `F ⋙ e.functor`.\n-/\n@[simps]\ndef functorialityEquivalence (e : C ≌ D) : Cone F ≌ Cone (F ⋙ e.functor) :=\n  let f : (F ⋙ e.functor) ⋙ e.inverse ≅ F :=\n    Functor.associator _ _ _ ≪≫ isoWhiskerLeft _ e.unitIso.symm ≪≫ Functor.rightUnitor _\n  { functor := functoriality F e.functor\n    inverse := functoriality (F ⋙ e.functor) e.inverse ⋙ (postcomposeEquivalence f).functor\n    unitIso := NatIso.ofComponents fun c => Cones.ext (e.unitIso.app _)\n    counitIso := NatIso.ofComponents fun c => Cones.ext (e.counitIso.app _) }\n\n"}
{"name":"CategoryTheory.Limits.Cones.functorialityEquivalence_counitIso","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} C\nD : Type u₄\ninst✝ : CategoryTheory.Category.{v₄, u₄} D\nF : CategoryTheory.Functor J C\ne : CategoryTheory.Equivalence C D\n⊢ Eq (CategoryTheory.Limits.Cones.functorialityEquivalence F e).counitIso (CategoryTheory.NatIso.ofComponents (fun c => CategoryTheory.Limits.Cones.ext (e.counitIso.app c.pt) ⋯) ⋯)","decl":"/-- If `e : C ≌ D` is an equivalence of categories, then `functoriality F e.functor` induces an\nequivalence between cones over `F` and cones over `F ⋙ e.functor`.\n-/\n@[simps]\ndef functorialityEquivalence (e : C ≌ D) : Cone F ≌ Cone (F ⋙ e.functor) :=\n  let f : (F ⋙ e.functor) ⋙ e.inverse ≅ F :=\n    Functor.associator _ _ _ ≪≫ isoWhiskerLeft _ e.unitIso.symm ≪≫ Functor.rightUnitor _\n  { functor := functoriality F e.functor\n    inverse := functoriality (F ⋙ e.functor) e.inverse ⋙ (postcomposeEquivalence f).functor\n    unitIso := NatIso.ofComponents fun c => Cones.ext (e.unitIso.app _)\n    counitIso := NatIso.ofComponents fun c => Cones.ext (e.counitIso.app _) }\n\n"}
{"name":"CategoryTheory.Limits.Cones.functorialityEquivalence_unitIso","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} C\nD : Type u₄\ninst✝ : CategoryTheory.Category.{v₄, u₄} D\nF : CategoryTheory.Functor J C\ne : CategoryTheory.Equivalence C D\n⊢ Eq (CategoryTheory.Limits.Cones.functorialityEquivalence F e).unitIso (CategoryTheory.NatIso.ofComponents (fun c => CategoryTheory.Limits.Cones.ext (e.unitIso.app ((CategoryTheory.Functor.id (CategoryTheory.Limits.Cone F)).obj c).1) ⋯) ⋯)","decl":"/-- If `e : C ≌ D` is an equivalence of categories, then `functoriality F e.functor` induces an\nequivalence between cones over `F` and cones over `F ⋙ e.functor`.\n-/\n@[simps]\ndef functorialityEquivalence (e : C ≌ D) : Cone F ≌ Cone (F ⋙ e.functor) :=\n  let f : (F ⋙ e.functor) ⋙ e.inverse ≅ F :=\n    Functor.associator _ _ _ ≪≫ isoWhiskerLeft _ e.unitIso.symm ≪≫ Functor.rightUnitor _\n  { functor := functoriality F e.functor\n    inverse := functoriality (F ⋙ e.functor) e.inverse ⋙ (postcomposeEquivalence f).functor\n    unitIso := NatIso.ofComponents fun c => Cones.ext (e.unitIso.app _)\n    counitIso := NatIso.ofComponents fun c => Cones.ext (e.counitIso.app _) }\n\n"}
{"name":"CategoryTheory.Limits.Cones.functorialityEquivalence_inverse","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} C\nD : Type u₄\ninst✝ : CategoryTheory.Category.{v₄, u₄} D\nF : CategoryTheory.Functor J C\ne : CategoryTheory.Equivalence C D\n⊢ Eq (CategoryTheory.Limits.Cones.functorialityEquivalence F e).inverse ((CategoryTheory.Limits.Cones.functoriality (F.comp e.functor) e.inverse).comp (CategoryTheory.Limits.Cones.postcomposeEquivalence ((F.associator e.functor e.inverse).trans ((CategoryTheory.isoWhiskerLeft F e.unitIso.symm).trans F.rightUnitor))).functor)","decl":"/-- If `e : C ≌ D` is an equivalence of categories, then `functoriality F e.functor` induces an\nequivalence between cones over `F` and cones over `F ⋙ e.functor`.\n-/\n@[simps]\ndef functorialityEquivalence (e : C ≌ D) : Cone F ≌ Cone (F ⋙ e.functor) :=\n  let f : (F ⋙ e.functor) ⋙ e.inverse ≅ F :=\n    Functor.associator _ _ _ ≪≫ isoWhiskerLeft _ e.unitIso.symm ≪≫ Functor.rightUnitor _\n  { functor := functoriality F e.functor\n    inverse := functoriality (F ⋙ e.functor) e.inverse ⋙ (postcomposeEquivalence f).functor\n    unitIso := NatIso.ofComponents fun c => Cones.ext (e.unitIso.app _)\n    counitIso := NatIso.ofComponents fun c => Cones.ext (e.counitIso.app _) }\n\n"}
{"name":"CategoryTheory.Limits.Cones.reflects_cone_isomorphism","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝² : CategoryTheory.Category.{v₃, u₃} C\nD : Type u₄\ninst✝¹ : CategoryTheory.Category.{v₄, u₄} D\nF : CategoryTheory.Functor C D\ninst✝ : F.ReflectsIsomorphisms\nK : CategoryTheory.Functor J C\n⊢ (CategoryTheory.Limits.Cones.functoriality K F).ReflectsIsomorphisms","decl":"/-- If `F` reflects isomorphisms, then `Cones.functoriality F` reflects isomorphisms\nas well.\n-/\ninstance reflects_cone_isomorphism (F : C ⥤ D) [F.ReflectsIsomorphisms] (K : J ⥤ C) :\n    (Cones.functoriality K F).ReflectsIsomorphisms := by\n  constructor\n  intro A B f _\n  haveI : IsIso (F.map f.hom) :=\n    (Cones.forget (K ⋙ F)).map_isIso ((Cones.functoriality K F).map f)\n  haveI := ReflectsIsomorphisms.reflects F f.hom\n  apply cone_iso_of_hom_iso\n\n"}
{"name":"CategoryTheory.Limits.CoconeMorphism.mk.inj","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\nA B : CategoryTheory.Limits.Cocone F\nhom✝ : Quiver.Hom A.pt B.pt\nw✝ : autoParam (∀ (j : J), Eq (CategoryTheory.CategoryStruct.comp (A.ι.app j) hom✝) (B.ι.app j)) _auto✝\nhom : Quiver.Hom A.pt B.pt\nw : autoParam (∀ (j : J), Eq (CategoryTheory.CategoryStruct.comp (A.ι.app j) hom) (B.ι.app j)) _auto✝\nx✝ : Eq { hom := hom✝, w := w✝ } { hom := hom, w := w }\n⊢ Eq hom✝ hom","decl":"/-- A cocone morphism between two cocones for the same diagram is a morphism of the cocone points\nwhich commutes with the cocone legs. -/\nstructure CoconeMorphism (A B : Cocone F) where\n  /-- A morphism between the (co)vertex objects in `C` -/\n  hom : A.pt ⟶ B.pt\n  /-- The triangle made from the two natural transformations and `hom` commutes -/\n  w : ∀ j : J, A.ι.app j ≫ hom = B.ι.app j := by aesop_cat\n\n"}
{"name":"CategoryTheory.Limits.CoconeMorphism.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝² : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\nA B : CategoryTheory.Limits.Cocone F\ninst✝¹ : SizeOf J\ninst✝ : SizeOf C\nhom : Quiver.Hom A.pt B.pt\nw : autoParam (∀ (j : J), Eq (CategoryTheory.CategoryStruct.comp (A.ι.app j) hom) (B.ι.app j)) _auto✝\n⊢ Eq (SizeOf.sizeOf { hom := hom, w := w }) (HAdd.hAdd 1 (SizeOf.sizeOf hom))","decl":"/-- A cocone morphism between two cocones for the same diagram is a morphism of the cocone points\nwhich commutes with the cocone legs. -/\nstructure CoconeMorphism (A B : Cocone F) where\n  /-- A morphism between the (co)vertex objects in `C` -/\n  hom : A.pt ⟶ B.pt\n  /-- The triangle made from the two natural transformations and `hom` commutes -/\n  w : ∀ j : J, A.ι.app j ≫ hom = B.ι.app j := by aesop_cat\n\n"}
{"name":"CategoryTheory.Limits.CoconeMorphism.mk.injEq","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\nA B : CategoryTheory.Limits.Cocone F\nhom✝ : Quiver.Hom A.pt B.pt\nw✝ : autoParam (∀ (j : J), Eq (CategoryTheory.CategoryStruct.comp (A.ι.app j) hom✝) (B.ι.app j)) _auto✝\nhom : Quiver.Hom A.pt B.pt\nw : autoParam (∀ (j : J), Eq (CategoryTheory.CategoryStruct.comp (A.ι.app j) hom) (B.ι.app j)) _auto✝\n⊢ Eq (Eq { hom := hom✝, w := w✝ } { hom := hom, w := w }) (Eq hom✝ hom)","decl":"/-- A cocone morphism between two cocones for the same diagram is a morphism of the cocone points\nwhich commutes with the cocone legs. -/\nstructure CoconeMorphism (A B : Cocone F) where\n  /-- A morphism between the (co)vertex objects in `C` -/\n  hom : A.pt ⟶ B.pt\n  /-- The triangle made from the two natural transformations and `hom` commutes -/\n  w : ∀ j : J, A.ι.app j ≫ hom = B.ι.app j := by aesop_cat\n\n"}
{"name":"CategoryTheory.Limits.CoconeMorphism.w","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\nA B : CategoryTheory.Limits.Cocone F\nself : CategoryTheory.Limits.CoconeMorphism A B\nj : J\n⊢ Eq (CategoryTheory.CategoryStruct.comp (A.ι.app j) self.hom) (B.ι.app j)","decl":"/-- A cocone morphism between two cocones for the same diagram is a morphism of the cocone points\nwhich commutes with the cocone legs. -/\nstructure CoconeMorphism (A B : Cocone F) where\n  /-- A morphism between the (co)vertex objects in `C` -/\n  hom : A.pt ⟶ B.pt\n  /-- The triangle made from the two natural transformations and `hom` commutes -/\n  w : ∀ j : J, A.ι.app j ≫ hom = B.ι.app j := by aesop_cat\n\n"}
{"name":"CategoryTheory.Limits.CoconeMorphism.w_assoc","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\nA B : CategoryTheory.Limits.Cocone F\nself : CategoryTheory.Limits.CoconeMorphism A B\nj : J\nZ : C\nh : Quiver.Hom B.pt Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (A.ι.app j) (CategoryTheory.CategoryStruct.comp self.hom h)) (CategoryTheory.CategoryStruct.comp (B.ι.app j) h)","decl":"attribute [reassoc (attr := simp)] CoconeMorphism.w\n\n"}
{"name":"CategoryTheory.Limits.Cocone.category_id_hom","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\nB : CategoryTheory.Limits.Cocone F\n⊢ Eq (CategoryTheory.CategoryStruct.id B).hom (CategoryTheory.CategoryStruct.id B.pt)","decl":"@[simps]\ninstance Cocone.category : Category (Cocone F) where\n  Hom A B := CoconeMorphism A B\n  comp f g := { hom := f.hom ≫ g.hom }\n  id B := { hom := 𝟙 B.pt }\n\n-- Porting note: if we do not have `simps` automatically generate the lemma for simplifying\n-- the hom field of a category, we need to write the `ext` lemma in terms of the categorical\n-- morphism, rather than the underlying structure.\n"}
{"name":"CategoryTheory.Limits.Cocone.category_comp_hom","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\nX✝ Y✝ Z✝ : CategoryTheory.Limits.Cocone F\nf : Quiver.Hom X✝ Y✝\ng : Quiver.Hom Y✝ Z✝\n⊢ Eq (CategoryTheory.CategoryStruct.comp f g).hom (CategoryTheory.CategoryStruct.comp f.hom g.hom)","decl":"@[simps]\ninstance Cocone.category : Category (Cocone F) where\n  Hom A B := CoconeMorphism A B\n  comp f g := { hom := f.hom ≫ g.hom }\n  id B := { hom := 𝟙 B.pt }\n\n-- Porting note: if we do not have `simps` automatically generate the lemma for simplifying\n-- the hom field of a category, we need to write the `ext` lemma in terms of the categorical\n-- morphism, rather than the underlying structure.\n"}
{"name":"CategoryTheory.Limits.CoconeMorphism.ext","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\nc c' : CategoryTheory.Limits.Cocone F\nf g : Quiver.Hom c c'\nw : Eq f.hom g.hom\n⊢ Eq f g","decl":"@[ext]\ntheorem CoconeMorphism.ext {c c' : Cocone F} (f g : c ⟶ c') (w : f.hom = g.hom) : f = g := by\n  cases f\n  cases g\n  congr\n\n"}
{"name":"CategoryTheory.Limits.CoconeMorphism.ext_iff","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\nc c' : CategoryTheory.Limits.Cocone F\nf g : Quiver.Hom c c'\n⊢ Iff (Eq f g) (Eq f.hom g.hom)","decl":"@[ext]\ntheorem CoconeMorphism.ext {c c' : Cocone F} (f g : c ⟶ c') (w : f.hom = g.hom) : f = g := by\n  cases f\n  cases g\n  congr\n\n"}
{"name":"CategoryTheory.Limits.Cocones.ext_hom_hom","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\nc c' : CategoryTheory.Limits.Cocone F\nφ : CategoryTheory.Iso c.pt c'.pt\nw : autoParam (∀ (j : J), Eq (CategoryTheory.CategoryStruct.comp (c.ι.app j) φ.hom) (c'.ι.app j)) _auto✝\n⊢ Eq (CategoryTheory.Limits.Cocones.ext φ w).hom.hom φ.hom","decl":"/-- To give an isomorphism between cocones, it suffices to give an\n  isomorphism between their vertices which commutes with the cocone\n  maps. -/\n@[aesop apply safe (rule_sets := [CategoryTheory]), simps]\ndef ext {c c' : Cocone F} (φ : c.pt ≅ c'.pt)\n    (w : ∀ j, c.ι.app j ≫ φ.hom = c'.ι.app j := by aesop_cat) : c ≅ c' where\n  hom := { hom := φ.hom }\n  inv :=\n    { hom := φ.inv\n      w := fun j => φ.comp_inv_eq.mpr (w j).symm }\n\n"}
{"name":"CategoryTheory.Limits.Cocones.ext_inv_hom","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\nc c' : CategoryTheory.Limits.Cocone F\nφ : CategoryTheory.Iso c.pt c'.pt\nw : autoParam (∀ (j : J), Eq (CategoryTheory.CategoryStruct.comp (c.ι.app j) φ.hom) (c'.ι.app j)) _auto✝\n⊢ Eq (CategoryTheory.Limits.Cocones.ext φ w).inv.hom φ.inv","decl":"/-- To give an isomorphism between cocones, it suffices to give an\n  isomorphism between their vertices which commutes with the cocone\n  maps. -/\n@[aesop apply safe (rule_sets := [CategoryTheory]), simps]\ndef ext {c c' : Cocone F} (φ : c.pt ≅ c'.pt)\n    (w : ∀ j, c.ι.app j ≫ φ.hom = c'.ι.app j := by aesop_cat) : c ≅ c' where\n  hom := { hom := φ.hom }\n  inv :=\n    { hom := φ.inv\n      w := fun j => φ.comp_inv_eq.mpr (w j).symm }\n\n"}
{"name":"CategoryTheory.Limits.Cocones.eta_inv_hom","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\nc : CategoryTheory.Limits.Cocone F\n⊢ Eq (CategoryTheory.Limits.Cocones.eta c).inv.hom (CategoryTheory.CategoryStruct.id c.pt)","decl":"/-- Eta rule for cocones. -/\n@[simps!]\ndef eta (c : Cocone F) : c ≅ ⟨c.pt, c.ι⟩ :=\n  Cocones.ext (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Limits.Cocones.eta_hom_hom","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\nc : CategoryTheory.Limits.Cocone F\n⊢ Eq (CategoryTheory.Limits.Cocones.eta c).hom.hom (CategoryTheory.CategoryStruct.id c.pt)","decl":"/-- Eta rule for cocones. -/\n@[simps!]\ndef eta (c : Cocone F) : c ≅ ⟨c.pt, c.ι⟩ :=\n  Cocones.ext (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Limits.Cocones.cocone_iso_of_hom_iso","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nK : CategoryTheory.Functor J C\nc d : CategoryTheory.Limits.Cocone K\nf : Quiver.Hom c d\ni : CategoryTheory.IsIso f.hom\n⊢ CategoryTheory.IsIso f","decl":"/-- Given a cocone morphism whose object part is an isomorphism, produce an\nisomorphism of cocones.\n-/\ntheorem cocone_iso_of_hom_iso {K : J ⥤ C} {c d : Cocone K} (f : c ⟶ d) [i : IsIso f.hom] :\n    IsIso f :=\n  ⟨⟨{ hom := inv f.hom\n      w := fun j => (asIso f.hom).comp_inv_eq.2 (f.w j).symm }, by aesop_cat⟩⟩\n\n"}
{"name":"CategoryTheory.Limits.Cocones.extend_hom","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\ns : CategoryTheory.Limits.Cocone F\nX : C\nf : Quiver.Hom s.pt X\n⊢ Eq (CategoryTheory.Limits.Cocones.extend s f).hom f","decl":"/-- There is a morphism from a cocone to its extension. -/\n@[simps]\ndef extend (s : Cocone F) {X : C} (f : s.pt ⟶ X) : s ⟶ s.extend f where\n  hom := f\n\n"}
{"name":"CategoryTheory.Limits.Cocones.extendId_hom_hom","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\ns : CategoryTheory.Limits.Cocone F\n⊢ Eq (CategoryTheory.Limits.Cocones.extendId s).hom.hom (CategoryTheory.CategoryStruct.id s.pt)","decl":"/-- Extending a cocone by the identity does nothing. -/\n@[simps!]\ndef extendId (s : Cocone F) : s ≅ s.extend (𝟙 s.pt) :=\n  Cocones.ext (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Limits.Cocones.extendId_inv_hom","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\ns : CategoryTheory.Limits.Cocone F\n⊢ Eq (CategoryTheory.Limits.Cocones.extendId s).inv.hom (CategoryTheory.CategoryStruct.id s.pt)","decl":"/-- Extending a cocone by the identity does nothing. -/\n@[simps!]\ndef extendId (s : Cocone F) : s ≅ s.extend (𝟙 s.pt) :=\n  Cocones.ext (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Limits.Cocones.extendComp_inv_hom","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\ns : CategoryTheory.Limits.Cocone F\nX Y : C\nf : Quiver.Hom s.pt X\ng : Quiver.Hom X Y\n⊢ Eq (CategoryTheory.Limits.Cocones.extendComp s f g).inv.hom (CategoryTheory.CategoryStruct.id Y)","decl":"/-- Extending a cocone by a composition is the same as extending the cone twice. -/\n@[simps!]\ndef extendComp (s : Cocone F) {X Y : C} (f : s.pt ⟶ X) (g : X ⟶ Y) :\n    s.extend (f ≫ g) ≅ (s.extend f).extend g :=\n  Cocones.ext (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Limits.Cocones.extendComp_hom_hom","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\ns : CategoryTheory.Limits.Cocone F\nX Y : C\nf : Quiver.Hom s.pt X\ng : Quiver.Hom X Y\n⊢ Eq (CategoryTheory.Limits.Cocones.extendComp s f g).hom.hom (CategoryTheory.CategoryStruct.id Y)","decl":"/-- Extending a cocone by a composition is the same as extending the cone twice. -/\n@[simps!]\ndef extendComp (s : Cocone F) {X Y : C} (f : s.pt ⟶ X) (g : X ⟶ Y) :\n    s.extend (f ≫ g) ≅ (s.extend f).extend g :=\n  Cocones.ext (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Limits.Cocones.extendIso_inv_hom","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\ns : CategoryTheory.Limits.Cocone F\nX : C\nf : CategoryTheory.Iso s.pt X\n⊢ Eq (CategoryTheory.Limits.Cocones.extendIso s f).inv.hom f.inv","decl":"/-- A cocone extended by an isomorphism is isomorphic to the original cone. -/\n@[simps]\ndef extendIso (s : Cocone F) {X : C} (f : s.pt ≅ X) : s ≅ s.extend f.hom where\n  hom := { hom := f.hom }\n  inv := { hom := f.inv }\n\n"}
{"name":"CategoryTheory.Limits.Cocones.extendIso_hom_hom","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\ns : CategoryTheory.Limits.Cocone F\nX : C\nf : CategoryTheory.Iso s.pt X\n⊢ Eq (CategoryTheory.Limits.Cocones.extendIso s f).hom.hom f.hom","decl":"/-- A cocone extended by an isomorphism is isomorphic to the original cone. -/\n@[simps]\ndef extendIso (s : Cocone F) {X : C} (f : s.pt ≅ X) : s ≅ s.extend f.hom where\n  hom := { hom := f.hom }\n  inv := { hom := f.inv }\n\n"}
{"name":"CategoryTheory.Limits.Cocones.instIsIsoCoconeExtend","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\ns : CategoryTheory.Limits.Cocone F\nX : C\nf : Quiver.Hom s.pt X\ninst✝ : CategoryTheory.IsIso f\n⊢ CategoryTheory.IsIso (CategoryTheory.Limits.Cocones.extend s f)","decl":"instance {s : Cocone F} {X : C} (f : s.pt ⟶ X) [IsIso f] : IsIso (Cocones.extend s f) :=\n  ⟨(extendIso s (asIso f)).inv, by aesop_cat⟩\n\n"}
{"name":"CategoryTheory.Limits.Cocones.precompose_obj_ι","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF G : CategoryTheory.Functor J C\nα : Quiver.Hom G F\nc : CategoryTheory.Limits.Cocone F\n⊢ Eq ((CategoryTheory.Limits.Cocones.precompose α).obj c).ι (CategoryTheory.CategoryStruct.comp α c.ι)","decl":"/-- Functorially precompose a cocone for `F` by a natural transformation `G ⟶ F` to give a cocone\nfor `G`. -/\n@[simps]\ndef precompose {G : J ⥤ C} (α : G ⟶ F) : Cocone F ⥤ Cocone G where\n  obj c :=\n    { pt := c.pt\n      ι := α ≫ c.ι }\n  map f := { hom := f.hom }\n\n"}
{"name":"CategoryTheory.Limits.Cocones.precompose_map_hom","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF G : CategoryTheory.Functor J C\nα : Quiver.Hom G F\nX✝ Y✝ : CategoryTheory.Limits.Cocone F\nf : Quiver.Hom X✝ Y✝\n⊢ Eq ((CategoryTheory.Limits.Cocones.precompose α).map f).hom f.hom","decl":"/-- Functorially precompose a cocone for `F` by a natural transformation `G ⟶ F` to give a cocone\nfor `G`. -/\n@[simps]\ndef precompose {G : J ⥤ C} (α : G ⟶ F) : Cocone F ⥤ Cocone G where\n  obj c :=\n    { pt := c.pt\n      ι := α ≫ c.ι }\n  map f := { hom := f.hom }\n\n"}
{"name":"CategoryTheory.Limits.Cocones.precompose_obj_pt","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF G : CategoryTheory.Functor J C\nα : Quiver.Hom G F\nc : CategoryTheory.Limits.Cocone F\n⊢ Eq ((CategoryTheory.Limits.Cocones.precompose α).obj c).pt c.pt","decl":"/-- Functorially precompose a cocone for `F` by a natural transformation `G ⟶ F` to give a cocone\nfor `G`. -/\n@[simps]\ndef precompose {G : J ⥤ C} (α : G ⟶ F) : Cocone F ⥤ Cocone G where\n  obj c :=\n    { pt := c.pt\n      ι := α ≫ c.ι }\n  map f := { hom := f.hom }\n\n"}
{"name":"CategoryTheory.Limits.Cocones.precomposeEquivalence_inverse","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF G : CategoryTheory.Functor J C\nα : CategoryTheory.Iso G F\n⊢ Eq (CategoryTheory.Limits.Cocones.precomposeEquivalence α).inverse (CategoryTheory.Limits.Cocones.precompose α.inv)","decl":"/-- If `F` and `G` are naturally isomorphic functors, then they have equivalent categories of\ncocones.\n-/\n@[simps]\ndef precomposeEquivalence {G : J ⥤ C} (α : G ≅ F) : Cocone F ≌ Cocone G where\n  functor := precompose α.hom\n  inverse := precompose α.inv\n  unitIso := NatIso.ofComponents fun s => Cocones.ext (Iso.refl _)\n  counitIso := NatIso.ofComponents fun s => Cocones.ext (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Limits.Cocones.precomposeEquivalence_functor","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF G : CategoryTheory.Functor J C\nα : CategoryTheory.Iso G F\n⊢ Eq (CategoryTheory.Limits.Cocones.precomposeEquivalence α).functor (CategoryTheory.Limits.Cocones.precompose α.hom)","decl":"/-- If `F` and `G` are naturally isomorphic functors, then they have equivalent categories of\ncocones.\n-/\n@[simps]\ndef precomposeEquivalence {G : J ⥤ C} (α : G ≅ F) : Cocone F ≌ Cocone G where\n  functor := precompose α.hom\n  inverse := precompose α.inv\n  unitIso := NatIso.ofComponents fun s => Cocones.ext (Iso.refl _)\n  counitIso := NatIso.ofComponents fun s => Cocones.ext (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Limits.Cocones.precomposeEquivalence_unitIso","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF G : CategoryTheory.Functor J C\nα : CategoryTheory.Iso G F\n⊢ Eq (CategoryTheory.Limits.Cocones.precomposeEquivalence α).unitIso (CategoryTheory.NatIso.ofComponents (fun s => CategoryTheory.Limits.Cocones.ext (CategoryTheory.Iso.refl ((CategoryTheory.Functor.id (CategoryTheory.Limits.Cocone F)).obj s).pt) ⋯) ⋯)","decl":"/-- If `F` and `G` are naturally isomorphic functors, then they have equivalent categories of\ncocones.\n-/\n@[simps]\ndef precomposeEquivalence {G : J ⥤ C} (α : G ≅ F) : Cocone F ≌ Cocone G where\n  functor := precompose α.hom\n  inverse := precompose α.inv\n  unitIso := NatIso.ofComponents fun s => Cocones.ext (Iso.refl _)\n  counitIso := NatIso.ofComponents fun s => Cocones.ext (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Limits.Cocones.precomposeEquivalence_counitIso","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF G : CategoryTheory.Functor J C\nα : CategoryTheory.Iso G F\n⊢ Eq (CategoryTheory.Limits.Cocones.precomposeEquivalence α).counitIso (CategoryTheory.NatIso.ofComponents (fun s => CategoryTheory.Limits.Cocones.ext (CategoryTheory.Iso.refl (((CategoryTheory.Limits.Cocones.precompose α.inv).comp (CategoryTheory.Limits.Cocones.precompose α.hom)).obj s).pt) ⋯) ⋯)","decl":"/-- If `F` and `G` are naturally isomorphic functors, then they have equivalent categories of\ncocones.\n-/\n@[simps]\ndef precomposeEquivalence {G : J ⥤ C} (α : G ≅ F) : Cocone F ≌ Cocone G where\n  functor := precompose α.hom\n  inverse := precompose α.inv\n  unitIso := NatIso.ofComponents fun s => Cocones.ext (Iso.refl _)\n  counitIso := NatIso.ofComponents fun s => Cocones.ext (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Limits.Cocones.whiskering_obj","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nK : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} K\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\nE : CategoryTheory.Functor K J\nc : CategoryTheory.Limits.Cocone F\n⊢ Eq ((CategoryTheory.Limits.Cocones.whiskering E).obj c) (CategoryTheory.Limits.Cocone.whisker E c)","decl":"/-- Whiskering on the left by `E : K ⥤ J` gives a functor from `Cocone F` to `Cocone (E ⋙ F)`.\n-/\n@[simps]\ndef whiskering (E : K ⥤ J) : Cocone F ⥤ Cocone (E ⋙ F) where\n  obj c := c.whisker E\n  map f := { hom := f.hom }\n\n"}
{"name":"CategoryTheory.Limits.Cocones.whiskering_map_hom","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nK : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} K\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\nE : CategoryTheory.Functor K J\nX✝ Y✝ : CategoryTheory.Limits.Cocone F\nf : Quiver.Hom X✝ Y✝\n⊢ Eq ((CategoryTheory.Limits.Cocones.whiskering E).map f).hom f.hom","decl":"/-- Whiskering on the left by `E : K ⥤ J` gives a functor from `Cocone F` to `Cocone (E ⋙ F)`.\n-/\n@[simps]\ndef whiskering (E : K ⥤ J) : Cocone F ⥤ Cocone (E ⋙ F) where\n  obj c := c.whisker E\n  map f := { hom := f.hom }\n\n"}
{"name":"CategoryTheory.Limits.Cocones.whiskeringEquivalence_counitIso","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nK : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} K\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\ne : CategoryTheory.Equivalence K J\n⊢ Eq (CategoryTheory.Limits.Cocones.whiskeringEquivalence e).counitIso (CategoryTheory.NatIso.ofComponents (fun s => CategoryTheory.Limits.Cocones.ext (CategoryTheory.Iso.refl ((((CategoryTheory.Limits.Cocones.whiskering e.inverse).comp (CategoryTheory.Limits.Cocones.precompose (CategoryTheory.CategoryStruct.comp F.leftUnitor.inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerRight e.counitIso.inv F) (e.inverse.associator e.functor F).inv)))).comp (CategoryTheory.Limits.Cocones.whiskering e.functor)).obj s).pt) ⋯) ⋯)","decl":"/-- Whiskering by an equivalence gives an equivalence between categories of cones.\n-/\n@[simps]\ndef whiskeringEquivalence (e : K ≌ J) : Cocone F ≌ Cocone (e.functor ⋙ F) where\n  functor := whiskering e.functor\n  inverse :=\n    whiskering e.inverse ⋙\n      precompose\n        ((Functor.leftUnitor F).inv ≫\n          whiskerRight e.counitIso.inv F ≫ (Functor.associator _ _ _).inv)\n  unitIso := NatIso.ofComponents fun s => Cocones.ext (Iso.refl _)\n  counitIso := NatIso.ofComponents fun s =>\n    Cocones.ext (Iso.refl _) fun k => by simpa [e.counitInv_app_functor k] using s.w (e.unit.app k)\n\n"}
{"name":"CategoryTheory.Limits.Cocones.whiskeringEquivalence_functor","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nK : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} K\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\ne : CategoryTheory.Equivalence K J\n⊢ Eq (CategoryTheory.Limits.Cocones.whiskeringEquivalence e).functor (CategoryTheory.Limits.Cocones.whiskering e.functor)","decl":"/-- Whiskering by an equivalence gives an equivalence between categories of cones.\n-/\n@[simps]\ndef whiskeringEquivalence (e : K ≌ J) : Cocone F ≌ Cocone (e.functor ⋙ F) where\n  functor := whiskering e.functor\n  inverse :=\n    whiskering e.inverse ⋙\n      precompose\n        ((Functor.leftUnitor F).inv ≫\n          whiskerRight e.counitIso.inv F ≫ (Functor.associator _ _ _).inv)\n  unitIso := NatIso.ofComponents fun s => Cocones.ext (Iso.refl _)\n  counitIso := NatIso.ofComponents fun s =>\n    Cocones.ext (Iso.refl _) fun k => by simpa [e.counitInv_app_functor k] using s.w (e.unit.app k)\n\n"}
{"name":"CategoryTheory.Limits.Cocones.whiskeringEquivalence_unitIso","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nK : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} K\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\ne : CategoryTheory.Equivalence K J\n⊢ Eq (CategoryTheory.Limits.Cocones.whiskeringEquivalence e).unitIso (CategoryTheory.NatIso.ofComponents (fun s => CategoryTheory.Limits.Cocones.ext (CategoryTheory.Iso.refl ((CategoryTheory.Functor.id (CategoryTheory.Limits.Cocone F)).obj s).pt) ⋯) ⋯)","decl":"/-- Whiskering by an equivalence gives an equivalence between categories of cones.\n-/\n@[simps]\ndef whiskeringEquivalence (e : K ≌ J) : Cocone F ≌ Cocone (e.functor ⋙ F) where\n  functor := whiskering e.functor\n  inverse :=\n    whiskering e.inverse ⋙\n      precompose\n        ((Functor.leftUnitor F).inv ≫\n          whiskerRight e.counitIso.inv F ≫ (Functor.associator _ _ _).inv)\n  unitIso := NatIso.ofComponents fun s => Cocones.ext (Iso.refl _)\n  counitIso := NatIso.ofComponents fun s =>\n    Cocones.ext (Iso.refl _) fun k => by simpa [e.counitInv_app_functor k] using s.w (e.unit.app k)\n\n"}
{"name":"CategoryTheory.Limits.Cocones.whiskeringEquivalence_inverse","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nK : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} K\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\ne : CategoryTheory.Equivalence K J\n⊢ Eq (CategoryTheory.Limits.Cocones.whiskeringEquivalence e).inverse ((CategoryTheory.Limits.Cocones.whiskering e.inverse).comp (CategoryTheory.Limits.Cocones.precompose (CategoryTheory.CategoryStruct.comp F.leftUnitor.inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerRight e.counitIso.inv F) (e.inverse.associator e.functor F).inv))))","decl":"/-- Whiskering by an equivalence gives an equivalence between categories of cones.\n-/\n@[simps]\ndef whiskeringEquivalence (e : K ≌ J) : Cocone F ≌ Cocone (e.functor ⋙ F) where\n  functor := whiskering e.functor\n  inverse :=\n    whiskering e.inverse ⋙\n      precompose\n        ((Functor.leftUnitor F).inv ≫\n          whiskerRight e.counitIso.inv F ≫ (Functor.associator _ _ _).inv)\n  unitIso := NatIso.ofComponents fun s => Cocones.ext (Iso.refl _)\n  counitIso := NatIso.ofComponents fun s =>\n    Cocones.ext (Iso.refl _) fun k => by simpa [e.counitInv_app_functor k] using s.w (e.unit.app k)\n\n"}
{"name":"CategoryTheory.Limits.Cocones.equivalenceOfReindexing_functor_obj","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nK : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} K\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\nG : CategoryTheory.Functor K C\ne : CategoryTheory.Equivalence K J\nα : CategoryTheory.Iso (e.functor.comp F) G\nX : CategoryTheory.Limits.Cocone F\n⊢ Eq ((CategoryTheory.Limits.Cocones.equivalenceOfReindexing e α).functor.obj X) ((CategoryTheory.Limits.Cocones.precompose α.inv).obj (CategoryTheory.Limits.Cocone.whisker e.functor X))","decl":"/--\nThe categories of cocones over `F` and `G` are equivalent if `F` and `G` are naturally isomorphic\n(possibly after changing the indexing category by an equivalence).\n-/\n@[simps! functor_obj]\ndef equivalenceOfReindexing {G : K ⥤ C} (e : K ≌ J) (α : e.functor ⋙ F ≅ G) : Cocone F ≌ Cocone G :=\n  (whiskeringEquivalence e).trans (precomposeEquivalence α.symm)\n\n"}
{"name":"CategoryTheory.Limits.Cocones.forget_obj","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\nt : CategoryTheory.Limits.Cocone F\n⊢ Eq ((CategoryTheory.Limits.Cocones.forget F).obj t) t.pt","decl":"/-- Forget the cocone structure and obtain just the cocone point. -/\n@[simps]\ndef forget : Cocone F ⥤ C where\n  obj t := t.pt\n  map f := f.hom\n\n"}
{"name":"CategoryTheory.Limits.Cocones.forget_map","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\nX✝ Y✝ : CategoryTheory.Limits.Cocone F\nf : Quiver.Hom X✝ Y✝\n⊢ Eq ((CategoryTheory.Limits.Cocones.forget F).map f) f.hom","decl":"/-- Forget the cocone structure and obtain just the cocone point. -/\n@[simps]\ndef forget : Cocone F ⥤ C where\n  obj t := t.pt\n  map f := f.hom\n\n"}
{"name":"CategoryTheory.Limits.Cocones.functoriality_obj_ι_app","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} C\nD : Type u₄\ninst✝ : CategoryTheory.Category.{v₄, u₄} D\nF : CategoryTheory.Functor J C\nG : CategoryTheory.Functor C D\nA : CategoryTheory.Limits.Cocone F\nj : J\n⊢ Eq (((CategoryTheory.Limits.Cocones.functoriality F G).obj A).ι.app j) (G.map (A.ι.app j))","decl":"/-- A functor `G : C ⥤ D` sends cocones over `F` to cocones over `F ⋙ G` functorially. -/\n@[simps]\ndef functoriality : Cocone F ⥤ Cocone (F ⋙ G) where\n  obj A :=\n    { pt := G.obj A.pt\n      ι :=\n        { app := fun j => G.map (A.ι.app j)\n          naturality := by intros; erw [← G.map_comp]; simp } }\n  map f :=\n    { hom := G.map f.hom\n      w := by intros; rw [← Functor.map_comp, CoconeMorphism.w] }\n\n"}
{"name":"CategoryTheory.Limits.Cocones.functoriality_obj_pt","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} C\nD : Type u₄\ninst✝ : CategoryTheory.Category.{v₄, u₄} D\nF : CategoryTheory.Functor J C\nG : CategoryTheory.Functor C D\nA : CategoryTheory.Limits.Cocone F\n⊢ Eq ((CategoryTheory.Limits.Cocones.functoriality F G).obj A).pt (G.obj A.pt)","decl":"/-- A functor `G : C ⥤ D` sends cocones over `F` to cocones over `F ⋙ G` functorially. -/\n@[simps]\ndef functoriality : Cocone F ⥤ Cocone (F ⋙ G) where\n  obj A :=\n    { pt := G.obj A.pt\n      ι :=\n        { app := fun j => G.map (A.ι.app j)\n          naturality := by intros; erw [← G.map_comp]; simp } }\n  map f :=\n    { hom := G.map f.hom\n      w := by intros; rw [← Functor.map_comp, CoconeMorphism.w] }\n\n"}
{"name":"CategoryTheory.Limits.Cocones.functoriality_map_hom","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} C\nD : Type u₄\ninst✝ : CategoryTheory.Category.{v₄, u₄} D\nF : CategoryTheory.Functor J C\nG : CategoryTheory.Functor C D\nX✝ Y✝ : CategoryTheory.Limits.Cocone F\nf : Quiver.Hom X✝ Y✝\n⊢ Eq ((CategoryTheory.Limits.Cocones.functoriality F G).map f).hom (G.map f.hom)","decl":"/-- A functor `G : C ⥤ D` sends cocones over `F` to cocones over `F ⋙ G` functorially. -/\n@[simps]\ndef functoriality : Cocone F ⥤ Cocone (F ⋙ G) where\n  obj A :=\n    { pt := G.obj A.pt\n      ι :=\n        { app := fun j => G.map (A.ι.app j)\n          naturality := by intros; erw [← G.map_comp]; simp } }\n  map f :=\n    { hom := G.map f.hom\n      w := by intros; rw [← Functor.map_comp, CoconeMorphism.w] }\n\n"}
{"name":"CategoryTheory.Limits.Cocones.functoriality_full","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝³ : CategoryTheory.Category.{v₃, u₃} C\nD : Type u₄\ninst✝² : CategoryTheory.Category.{v₄, u₄} D\nF : CategoryTheory.Functor J C\nG : CategoryTheory.Functor C D\ninst✝¹ : G.Full\ninst✝ : G.Faithful\n⊢ (CategoryTheory.Limits.Cocones.functoriality F G).Full","decl":"instance functoriality_full [G.Full] [G.Faithful] : (functoriality F G).Full where\n  map_surjective t :=\n    ⟨{ hom := G.preimage t.hom\n       w := fun j => G.map_injective (by simpa using t.w j) }, by aesop_cat⟩\n\n"}
{"name":"CategoryTheory.Limits.Cocones.functoriality_faithful","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝² : CategoryTheory.Category.{v₃, u₃} C\nD : Type u₄\ninst✝¹ : CategoryTheory.Category.{v₄, u₄} D\nF : CategoryTheory.Functor J C\nG : CategoryTheory.Functor C D\ninst✝ : G.Faithful\n⊢ (CategoryTheory.Limits.Cocones.functoriality F G).Faithful","decl":"instance functoriality_faithful [G.Faithful] : (functoriality F G).Faithful where\n  map_injective {_X} {_Y} f g h :=\n    CoconeMorphism.ext f g <| G.map_injective <| congr_arg CoconeMorphism.hom h\n\n"}
{"name":"CategoryTheory.Limits.Cocones.functorialityEquivalence_functor","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} C\nD : Type u₄\ninst✝ : CategoryTheory.Category.{v₄, u₄} D\nF : CategoryTheory.Functor J C\ne : CategoryTheory.Equivalence C D\n⊢ Eq (CategoryTheory.Limits.Cocones.functorialityEquivalence F e).functor (CategoryTheory.Limits.Cocones.functoriality F e.functor)","decl":"/-- If `e : C ≌ D` is an equivalence of categories, then `functoriality F e.functor` induces an\nequivalence between cocones over `F` and cocones over `F ⋙ e.functor`.\n-/\n@[simps]\ndef functorialityEquivalence (e : C ≌ D) : Cocone F ≌ Cocone (F ⋙ e.functor) :=\n  let f : (F ⋙ e.functor) ⋙ e.inverse ≅ F :=\n    Functor.associator _ _ _ ≪≫ isoWhiskerLeft _ e.unitIso.symm ≪≫ Functor.rightUnitor _\n  { functor := functoriality F e.functor\n    inverse := functoriality (F ⋙ e.functor) e.inverse ⋙ (precomposeEquivalence f.symm).functor\n    unitIso := NatIso.ofComponents fun c => Cocones.ext (e.unitIso.app _)\n    counitIso := NatIso.ofComponents fun c => Cocones.ext (e.counitIso.app _) }\n\n"}
{"name":"CategoryTheory.Limits.Cocones.functorialityEquivalence_inverse","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} C\nD : Type u₄\ninst✝ : CategoryTheory.Category.{v₄, u₄} D\nF : CategoryTheory.Functor J C\ne : CategoryTheory.Equivalence C D\n⊢ Eq (CategoryTheory.Limits.Cocones.functorialityEquivalence F e).inverse ((CategoryTheory.Limits.Cocones.functoriality (F.comp e.functor) e.inverse).comp (CategoryTheory.Limits.Cocones.precomposeEquivalence ((F.associator e.functor e.inverse).trans ((CategoryTheory.isoWhiskerLeft F e.unitIso.symm).trans F.rightUnitor)).symm).functor)","decl":"/-- If `e : C ≌ D` is an equivalence of categories, then `functoriality F e.functor` induces an\nequivalence between cocones over `F` and cocones over `F ⋙ e.functor`.\n-/\n@[simps]\ndef functorialityEquivalence (e : C ≌ D) : Cocone F ≌ Cocone (F ⋙ e.functor) :=\n  let f : (F ⋙ e.functor) ⋙ e.inverse ≅ F :=\n    Functor.associator _ _ _ ≪≫ isoWhiskerLeft _ e.unitIso.symm ≪≫ Functor.rightUnitor _\n  { functor := functoriality F e.functor\n    inverse := functoriality (F ⋙ e.functor) e.inverse ⋙ (precomposeEquivalence f.symm).functor\n    unitIso := NatIso.ofComponents fun c => Cocones.ext (e.unitIso.app _)\n    counitIso := NatIso.ofComponents fun c => Cocones.ext (e.counitIso.app _) }\n\n"}
{"name":"CategoryTheory.Limits.Cocones.functorialityEquivalence_unitIso","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} C\nD : Type u₄\ninst✝ : CategoryTheory.Category.{v₄, u₄} D\nF : CategoryTheory.Functor J C\ne : CategoryTheory.Equivalence C D\n⊢ Eq (CategoryTheory.Limits.Cocones.functorialityEquivalence F e).unitIso (CategoryTheory.NatIso.ofComponents (fun c => CategoryTheory.Limits.Cocones.ext (e.unitIso.app ((CategoryTheory.Functor.id (CategoryTheory.Limits.Cocone F)).obj c).1) ⋯) ⋯)","decl":"/-- If `e : C ≌ D` is an equivalence of categories, then `functoriality F e.functor` induces an\nequivalence between cocones over `F` and cocones over `F ⋙ e.functor`.\n-/\n@[simps]\ndef functorialityEquivalence (e : C ≌ D) : Cocone F ≌ Cocone (F ⋙ e.functor) :=\n  let f : (F ⋙ e.functor) ⋙ e.inverse ≅ F :=\n    Functor.associator _ _ _ ≪≫ isoWhiskerLeft _ e.unitIso.symm ≪≫ Functor.rightUnitor _\n  { functor := functoriality F e.functor\n    inverse := functoriality (F ⋙ e.functor) e.inverse ⋙ (precomposeEquivalence f.symm).functor\n    unitIso := NatIso.ofComponents fun c => Cocones.ext (e.unitIso.app _)\n    counitIso := NatIso.ofComponents fun c => Cocones.ext (e.counitIso.app _) }\n\n"}
{"name":"CategoryTheory.Limits.Cocones.functorialityEquivalence_counitIso","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} C\nD : Type u₄\ninst✝ : CategoryTheory.Category.{v₄, u₄} D\nF : CategoryTheory.Functor J C\ne : CategoryTheory.Equivalence C D\n⊢ Eq (CategoryTheory.Limits.Cocones.functorialityEquivalence F e).counitIso (CategoryTheory.NatIso.ofComponents (fun c => CategoryTheory.Limits.Cocones.ext (e.counitIso.app c.pt) ⋯) ⋯)","decl":"/-- If `e : C ≌ D` is an equivalence of categories, then `functoriality F e.functor` induces an\nequivalence between cocones over `F` and cocones over `F ⋙ e.functor`.\n-/\n@[simps]\ndef functorialityEquivalence (e : C ≌ D) : Cocone F ≌ Cocone (F ⋙ e.functor) :=\n  let f : (F ⋙ e.functor) ⋙ e.inverse ≅ F :=\n    Functor.associator _ _ _ ≪≫ isoWhiskerLeft _ e.unitIso.symm ≪≫ Functor.rightUnitor _\n  { functor := functoriality F e.functor\n    inverse := functoriality (F ⋙ e.functor) e.inverse ⋙ (precomposeEquivalence f.symm).functor\n    unitIso := NatIso.ofComponents fun c => Cocones.ext (e.unitIso.app _)\n    counitIso := NatIso.ofComponents fun c => Cocones.ext (e.counitIso.app _) }\n\n"}
{"name":"CategoryTheory.Limits.Cocones.reflects_cocone_isomorphism","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝² : CategoryTheory.Category.{v₃, u₃} C\nD : Type u₄\ninst✝¹ : CategoryTheory.Category.{v₄, u₄} D\nF : CategoryTheory.Functor C D\ninst✝ : F.ReflectsIsomorphisms\nK : CategoryTheory.Functor J C\n⊢ (CategoryTheory.Limits.Cocones.functoriality K F).ReflectsIsomorphisms","decl":"/-- If `F` reflects isomorphisms, then `Cocones.functoriality F` reflects isomorphisms\nas well.\n-/\ninstance reflects_cocone_isomorphism (F : C ⥤ D) [F.ReflectsIsomorphisms] (K : J ⥤ C) :\n    (Cocones.functoriality K F).ReflectsIsomorphisms := by\n  constructor\n  intro A B f _\n  haveI : IsIso (F.map f.hom) :=\n    (Cocones.forget (K ⋙ F)).map_isIso ((Cocones.functoriality K F).map f)\n  haveI := ReflectsIsomorphisms.reflects F f.hom\n  apply cocone_iso_of_hom_iso\n\n"}
{"name":"CategoryTheory.Functor.mapCone_pt","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} C\nD : Type u₄\ninst✝ : CategoryTheory.Category.{v₄, u₄} D\nH : CategoryTheory.Functor C D\nF : CategoryTheory.Functor J C\nc : CategoryTheory.Limits.Cone F\n⊢ Eq (H.mapCone c).pt (H.obj c.pt)","decl":"/-- The image of a cone in C under a functor G : C ⥤ D is a cone in D. -/\n@[simps!]\ndef mapCone (c : Cone F) : Cone (F ⋙ H) :=\n  (Cones.functoriality F H).obj c\n\n"}
{"name":"CategoryTheory.Functor.mapCone_π_app","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} C\nD : Type u₄\ninst✝ : CategoryTheory.Category.{v₄, u₄} D\nH : CategoryTheory.Functor C D\nF : CategoryTheory.Functor J C\nc : CategoryTheory.Limits.Cone F\nj : J\n⊢ Eq ((H.mapCone c).π.app j) (H.map (c.π.app j))","decl":"/-- The image of a cone in C under a functor G : C ⥤ D is a cone in D. -/\n@[simps!]\ndef mapCone (c : Cone F) : Cone (F ⋙ H) :=\n  (Cones.functoriality F H).obj c\n\n"}
{"name":"CategoryTheory.Functor.mapConeMapCone_inv_hom","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝² : CategoryTheory.Category.{v₃, u₃} C\nD : Type u₄\ninst✝¹ : CategoryTheory.Category.{v₄, u₄} D\nE : Type u₅\ninst✝ : CategoryTheory.Category.{v₅, u₅} E\nF : CategoryTheory.Functor J C\nH : CategoryTheory.Functor C D\nH' : CategoryTheory.Functor D E\nc : CategoryTheory.Limits.Cone F\n⊢ Eq (CategoryTheory.Functor.mapConeMapCone c).inv.hom (CategoryTheory.CategoryStruct.id (H'.obj (H.obj c.pt)))","decl":"/-- The construction `mapCone` respects functor composition. -/\n@[simps!]\nnoncomputable def mapConeMapCone {F : J ⥤ C} {H : C ⥤ D} {H' : D ⥤ E} (c : Cone F) :\n    H'.mapCone (H.mapCone c) ≅ (H ⋙ H').mapCone c := Cones.ext (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Functor.mapConeMapCone_hom_hom","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝² : CategoryTheory.Category.{v₃, u₃} C\nD : Type u₄\ninst✝¹ : CategoryTheory.Category.{v₄, u₄} D\nE : Type u₅\ninst✝ : CategoryTheory.Category.{v₅, u₅} E\nF : CategoryTheory.Functor J C\nH : CategoryTheory.Functor C D\nH' : CategoryTheory.Functor D E\nc : CategoryTheory.Limits.Cone F\n⊢ Eq (CategoryTheory.Functor.mapConeMapCone c).hom.hom (CategoryTheory.CategoryStruct.id (H'.obj (H.obj c.pt)))","decl":"/-- The construction `mapCone` respects functor composition. -/\n@[simps!]\nnoncomputable def mapConeMapCone {F : J ⥤ C} {H : C ⥤ D} {H' : D ⥤ E} (c : Cone F) :\n    H'.mapCone (H.mapCone c) ≅ (H ⋙ H').mapCone c := Cones.ext (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Functor.mapCocone_ι_app","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} C\nD : Type u₄\ninst✝ : CategoryTheory.Category.{v₄, u₄} D\nH : CategoryTheory.Functor C D\nF : CategoryTheory.Functor J C\nc : CategoryTheory.Limits.Cocone F\nj : J\n⊢ Eq ((H.mapCocone c).ι.app j) (H.map (c.ι.app j))","decl":"/-- The image of a cocone in C under a functor G : C ⥤ D is a cocone in D. -/\n@[simps!]\ndef mapCocone (c : Cocone F) : Cocone (F ⋙ H) :=\n  (Cocones.functoriality F H).obj c\n\n"}
{"name":"CategoryTheory.Functor.mapCocone_pt","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} C\nD : Type u₄\ninst✝ : CategoryTheory.Category.{v₄, u₄} D\nH : CategoryTheory.Functor C D\nF : CategoryTheory.Functor J C\nc : CategoryTheory.Limits.Cocone F\n⊢ Eq (H.mapCocone c).pt (H.obj c.pt)","decl":"/-- The image of a cocone in C under a functor G : C ⥤ D is a cocone in D. -/\n@[simps!]\ndef mapCocone (c : Cocone F) : Cocone (F ⋙ H) :=\n  (Cocones.functoriality F H).obj c\n\n"}
{"name":"CategoryTheory.Functor.mapCoconeMapCocone_inv_hom","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝² : CategoryTheory.Category.{v₃, u₃} C\nD : Type u₄\ninst✝¹ : CategoryTheory.Category.{v₄, u₄} D\nE : Type u₅\ninst✝ : CategoryTheory.Category.{v₅, u₅} E\nF : CategoryTheory.Functor J C\nH : CategoryTheory.Functor C D\nH' : CategoryTheory.Functor D E\nc : CategoryTheory.Limits.Cocone F\n⊢ Eq (CategoryTheory.Functor.mapCoconeMapCocone c).inv.hom (CategoryTheory.CategoryStruct.id (H'.obj (H.obj c.pt)))","decl":"/-- The construction `mapCocone` respects functor composition. -/\n@[simps!]\nnoncomputable def mapCoconeMapCocone {F : J ⥤ C} {H : C ⥤ D} {H' : D ⥤ E} (c : Cocone F) :\n    H'.mapCocone (H.mapCocone c) ≅ (H ⋙ H').mapCocone c := Cocones.ext (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Functor.mapCoconeMapCocone_hom_hom","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝² : CategoryTheory.Category.{v₃, u₃} C\nD : Type u₄\ninst✝¹ : CategoryTheory.Category.{v₄, u₄} D\nE : Type u₅\ninst✝ : CategoryTheory.Category.{v₅, u₅} E\nF : CategoryTheory.Functor J C\nH : CategoryTheory.Functor C D\nH' : CategoryTheory.Functor D E\nc : CategoryTheory.Limits.Cocone F\n⊢ Eq (CategoryTheory.Functor.mapCoconeMapCocone c).hom.hom (CategoryTheory.CategoryStruct.id (H'.obj (H.obj c.pt)))","decl":"/-- The construction `mapCocone` respects functor composition. -/\n@[simps!]\nnoncomputable def mapCoconeMapCocone {F : J ⥤ C} {H : C ⥤ D} {H' : D ⥤ E} (c : Cocone F) :\n    H'.mapCocone (H.mapCocone c) ≅ (H ⋙ H').mapCocone c := Cocones.ext (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Functor.functorialityCompPostcompose_hom_app_hom","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} C\nD : Type u₄\ninst✝ : CategoryTheory.Category.{v₄, u₄} D\nF : CategoryTheory.Functor J C\nH H' : CategoryTheory.Functor C D\nα : CategoryTheory.Iso H H'\nX : CategoryTheory.Limits.Cone F\n⊢ Eq ((CategoryTheory.Functor.functorialityCompPostcompose α).hom.app X).hom (α.hom.app X.pt)","decl":"/-- `functoriality F _ ⋙ postcompose (whisker_left F _)` simplifies to `functoriality F _`. -/\n@[simps!]\ndef functorialityCompPostcompose {H H' : C ⥤ D} (α : H ≅ H') :\n    Cones.functoriality F H ⋙ Cones.postcompose (whiskerLeft F α.hom) ≅ Cones.functoriality F H' :=\n  NatIso.ofComponents fun c => Cones.ext (α.app _)\n\n"}
{"name":"CategoryTheory.Functor.functorialityCompPostcompose_inv_app_hom","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} C\nD : Type u₄\ninst✝ : CategoryTheory.Category.{v₄, u₄} D\nF : CategoryTheory.Functor J C\nH H' : CategoryTheory.Functor C D\nα : CategoryTheory.Iso H H'\nX : CategoryTheory.Limits.Cone F\n⊢ Eq ((CategoryTheory.Functor.functorialityCompPostcompose α).inv.app X).hom (α.inv.app X.pt)","decl":"/-- `functoriality F _ ⋙ postcompose (whisker_left F _)` simplifies to `functoriality F _`. -/\n@[simps!]\ndef functorialityCompPostcompose {H H' : C ⥤ D} (α : H ≅ H') :\n    Cones.functoriality F H ⋙ Cones.postcompose (whiskerLeft F α.hom) ≅ Cones.functoriality F H' :=\n  NatIso.ofComponents fun c => Cones.ext (α.app _)\n\n"}
{"name":"CategoryTheory.Functor.postcomposeWhiskerLeftMapCone_hom_hom","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} C\nD : Type u₄\ninst✝ : CategoryTheory.Category.{v₄, u₄} D\nF : CategoryTheory.Functor J C\nH H' : CategoryTheory.Functor C D\nα : CategoryTheory.Iso H H'\nc : CategoryTheory.Limits.Cone F\n⊢ Eq (CategoryTheory.Functor.postcomposeWhiskerLeftMapCone α c).hom.hom (α.hom.app c.pt)","decl":"/-- For `F : J ⥤ C`, given a cone `c : Cone F`, and a natural isomorphism `α : H ≅ H'` for functors\n`H H' : C ⥤ D`, the postcomposition of the cone `H.mapCone` using the isomorphism `α` is\nisomorphic to the cone `H'.mapCone`.\n-/\n@[simps!]\ndef postcomposeWhiskerLeftMapCone {H H' : C ⥤ D} (α : H ≅ H') (c : Cone F) :\n    (Cones.postcompose (whiskerLeft F α.hom :)).obj (mapCone H c) ≅ mapCone H' c :=\n  (functorialityCompPostcompose α).app c\n\n"}
{"name":"CategoryTheory.Functor.postcomposeWhiskerLeftMapCone_inv_hom","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} C\nD : Type u₄\ninst✝ : CategoryTheory.Category.{v₄, u₄} D\nF : CategoryTheory.Functor J C\nH H' : CategoryTheory.Functor C D\nα : CategoryTheory.Iso H H'\nc : CategoryTheory.Limits.Cone F\n⊢ Eq (CategoryTheory.Functor.postcomposeWhiskerLeftMapCone α c).inv.hom (α.inv.app c.pt)","decl":"/-- For `F : J ⥤ C`, given a cone `c : Cone F`, and a natural isomorphism `α : H ≅ H'` for functors\n`H H' : C ⥤ D`, the postcomposition of the cone `H.mapCone` using the isomorphism `α` is\nisomorphic to the cone `H'.mapCone`.\n-/\n@[simps!]\ndef postcomposeWhiskerLeftMapCone {H H' : C ⥤ D} (α : H ≅ H') (c : Cone F) :\n    (Cones.postcompose (whiskerLeft F α.hom :)).obj (mapCone H c) ≅ mapCone H' c :=\n  (functorialityCompPostcompose α).app c\n\n"}
{"name":"CategoryTheory.Functor.mapConePostcompose_inv_hom","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} C\nD : Type u₄\ninst✝ : CategoryTheory.Category.{v₄, u₄} D\nH : CategoryTheory.Functor C D\nF G : CategoryTheory.Functor J C\nα : Quiver.Hom F G\nc : CategoryTheory.Limits.Cone F\n⊢ Eq H.mapConePostcompose.inv.hom (CategoryTheory.CategoryStruct.id (H.obj c.pt))","decl":"/--\n`mapCone` commutes with `postcompose`. In particular, for `F : J ⥤ C`, given a cone `c : Cone F`, a\nnatural transformation `α : F ⟶ G` and a functor `H : C ⥤ D`, we have two obvious ways of producing\na cone over `G ⋙ H`, and they are both isomorphic.\n-/\n@[simps!]\ndef mapConePostcompose {α : F ⟶ G} {c} :\n    mapCone H ((Cones.postcompose α).obj c) ≅\n      (Cones.postcompose (whiskerRight α H :)).obj (mapCone H c) :=\n  Cones.ext (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Functor.mapConePostcompose_hom_hom","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} C\nD : Type u₄\ninst✝ : CategoryTheory.Category.{v₄, u₄} D\nH : CategoryTheory.Functor C D\nF G : CategoryTheory.Functor J C\nα : Quiver.Hom F G\nc : CategoryTheory.Limits.Cone F\n⊢ Eq H.mapConePostcompose.hom.hom (CategoryTheory.CategoryStruct.id (H.obj c.pt))","decl":"/--\n`mapCone` commutes with `postcompose`. In particular, for `F : J ⥤ C`, given a cone `c : Cone F`, a\nnatural transformation `α : F ⟶ G` and a functor `H : C ⥤ D`, we have two obvious ways of producing\na cone over `G ⋙ H`, and they are both isomorphic.\n-/\n@[simps!]\ndef mapConePostcompose {α : F ⟶ G} {c} :\n    mapCone H ((Cones.postcompose α).obj c) ≅\n      (Cones.postcompose (whiskerRight α H :)).obj (mapCone H c) :=\n  Cones.ext (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Functor.mapConePostcomposeEquivalenceFunctor_inv_hom","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} C\nD : Type u₄\ninst✝ : CategoryTheory.Category.{v₄, u₄} D\nH : CategoryTheory.Functor C D\nF G : CategoryTheory.Functor J C\nα : CategoryTheory.Iso F G\nc : CategoryTheory.Limits.Cone F\n⊢ Eq H.mapConePostcomposeEquivalenceFunctor.inv.hom (CategoryTheory.CategoryStruct.id (H.obj c.pt))","decl":"/-- `mapCone` commutes with `postcomposeEquivalence`\n-/\n@[simps!]\ndef mapConePostcomposeEquivalenceFunctor {α : F ≅ G} {c} :\n    mapCone H ((Cones.postcomposeEquivalence α).functor.obj c) ≅\n      (Cones.postcomposeEquivalence (isoWhiskerRight α H :)).functor.obj (mapCone H c) :=\n  Cones.ext (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Functor.mapConePostcomposeEquivalenceFunctor_hom_hom","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} C\nD : Type u₄\ninst✝ : CategoryTheory.Category.{v₄, u₄} D\nH : CategoryTheory.Functor C D\nF G : CategoryTheory.Functor J C\nα : CategoryTheory.Iso F G\nc : CategoryTheory.Limits.Cone F\n⊢ Eq H.mapConePostcomposeEquivalenceFunctor.hom.hom (CategoryTheory.CategoryStruct.id (H.obj c.pt))","decl":"/-- `mapCone` commutes with `postcomposeEquivalence`\n-/\n@[simps!]\ndef mapConePostcomposeEquivalenceFunctor {α : F ≅ G} {c} :\n    mapCone H ((Cones.postcomposeEquivalence α).functor.obj c) ≅\n      (Cones.postcomposeEquivalence (isoWhiskerRight α H :)).functor.obj (mapCone H c) :=\n  Cones.ext (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Functor.functorialityCompPrecompose_hom_app_hom","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} C\nD : Type u₄\ninst✝ : CategoryTheory.Category.{v₄, u₄} D\nF : CategoryTheory.Functor J C\nH H' : CategoryTheory.Functor C D\nα : CategoryTheory.Iso H H'\nX : CategoryTheory.Limits.Cocone F\n⊢ Eq ((CategoryTheory.Functor.functorialityCompPrecompose α).hom.app X).hom (α.hom.app X.pt)","decl":"/-- `functoriality F _ ⋙ precompose (whiskerLeft F _)` simplifies to `functoriality F _`. -/\n@[simps!]\ndef functorialityCompPrecompose {H H' : C ⥤ D} (α : H ≅ H') :\n    Cocones.functoriality F H ⋙ Cocones.precompose (whiskerLeft F α.inv) ≅\n      Cocones.functoriality F H' :=\n  NatIso.ofComponents fun c => Cocones.ext (α.app _)\n\n"}
{"name":"CategoryTheory.Functor.functorialityCompPrecompose_inv_app_hom","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} C\nD : Type u₄\ninst✝ : CategoryTheory.Category.{v₄, u₄} D\nF : CategoryTheory.Functor J C\nH H' : CategoryTheory.Functor C D\nα : CategoryTheory.Iso H H'\nX : CategoryTheory.Limits.Cocone F\n⊢ Eq ((CategoryTheory.Functor.functorialityCompPrecompose α).inv.app X).hom (α.inv.app X.pt)","decl":"/-- `functoriality F _ ⋙ precompose (whiskerLeft F _)` simplifies to `functoriality F _`. -/\n@[simps!]\ndef functorialityCompPrecompose {H H' : C ⥤ D} (α : H ≅ H') :\n    Cocones.functoriality F H ⋙ Cocones.precompose (whiskerLeft F α.inv) ≅\n      Cocones.functoriality F H' :=\n  NatIso.ofComponents fun c => Cocones.ext (α.app _)\n\n"}
{"name":"CategoryTheory.Functor.precomposeWhiskerLeftMapCocone_hom_hom","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} C\nD : Type u₄\ninst✝ : CategoryTheory.Category.{v₄, u₄} D\nF : CategoryTheory.Functor J C\nH H' : CategoryTheory.Functor C D\nα : CategoryTheory.Iso H H'\nc : CategoryTheory.Limits.Cocone F\n⊢ Eq (CategoryTheory.Functor.precomposeWhiskerLeftMapCocone α c).hom.hom (α.hom.app c.pt)","decl":"/--\nFor `F : J ⥤ C`, given a cocone `c : Cocone F`, and a natural isomorphism `α : H ≅ H'` for functors\n`H H' : C ⥤ D`, the precomposition of the cocone `H.mapCocone` using the isomorphism `α` is\nisomorphic to the cocone `H'.mapCocone`.\n-/\n@[simps!]\ndef precomposeWhiskerLeftMapCocone {H H' : C ⥤ D} (α : H ≅ H') (c : Cocone F) :\n    (Cocones.precompose (whiskerLeft F α.inv :)).obj (mapCocone H c) ≅ mapCocone H' c :=\n  (functorialityCompPrecompose α).app c\n\n"}
{"name":"CategoryTheory.Functor.precomposeWhiskerLeftMapCocone_inv_hom","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} C\nD : Type u₄\ninst✝ : CategoryTheory.Category.{v₄, u₄} D\nF : CategoryTheory.Functor J C\nH H' : CategoryTheory.Functor C D\nα : CategoryTheory.Iso H H'\nc : CategoryTheory.Limits.Cocone F\n⊢ Eq (CategoryTheory.Functor.precomposeWhiskerLeftMapCocone α c).inv.hom (α.inv.app c.pt)","decl":"/--\nFor `F : J ⥤ C`, given a cocone `c : Cocone F`, and a natural isomorphism `α : H ≅ H'` for functors\n`H H' : C ⥤ D`, the precomposition of the cocone `H.mapCocone` using the isomorphism `α` is\nisomorphic to the cocone `H'.mapCocone`.\n-/\n@[simps!]\ndef precomposeWhiskerLeftMapCocone {H H' : C ⥤ D} (α : H ≅ H') (c : Cocone F) :\n    (Cocones.precompose (whiskerLeft F α.inv :)).obj (mapCocone H c) ≅ mapCocone H' c :=\n  (functorialityCompPrecompose α).app c\n\n"}
{"name":"CategoryTheory.Functor.mapCoconePrecompose_hom_hom","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} C\nD : Type u₄\ninst✝ : CategoryTheory.Category.{v₄, u₄} D\nH : CategoryTheory.Functor C D\nF G : CategoryTheory.Functor J C\nα : Quiver.Hom F G\nc : CategoryTheory.Limits.Cocone G\n⊢ Eq H.mapCoconePrecompose.hom.hom (CategoryTheory.CategoryStruct.id (H.obj c.pt))","decl":"/-- `map_cocone` commutes with `precompose`. In particular, for `F : J ⥤ C`, given a cocone\n`c : Cocone F`, a natural transformation `α : F ⟶ G` and a functor `H : C ⥤ D`, we have two obvious\nways of producing a cocone over `G ⋙ H`, and they are both isomorphic.\n-/\n@[simps!]\ndef mapCoconePrecompose {α : F ⟶ G} {c} :\n    mapCocone H ((Cocones.precompose α).obj c) ≅\n      (Cocones.precompose (whiskerRight α H :)).obj (mapCocone H c) :=\n  Cocones.ext (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Functor.mapCoconePrecompose_inv_hom","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} C\nD : Type u₄\ninst✝ : CategoryTheory.Category.{v₄, u₄} D\nH : CategoryTheory.Functor C D\nF G : CategoryTheory.Functor J C\nα : Quiver.Hom F G\nc : CategoryTheory.Limits.Cocone G\n⊢ Eq H.mapCoconePrecompose.inv.hom (CategoryTheory.CategoryStruct.id (H.obj c.pt))","decl":"/-- `map_cocone` commutes with `precompose`. In particular, for `F : J ⥤ C`, given a cocone\n`c : Cocone F`, a natural transformation `α : F ⟶ G` and a functor `H : C ⥤ D`, we have two obvious\nways of producing a cocone over `G ⋙ H`, and they are both isomorphic.\n-/\n@[simps!]\ndef mapCoconePrecompose {α : F ⟶ G} {c} :\n    mapCocone H ((Cocones.precompose α).obj c) ≅\n      (Cocones.precompose (whiskerRight α H :)).obj (mapCocone H c) :=\n  Cocones.ext (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Functor.mapCoconePrecomposeEquivalenceFunctor_inv_hom","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} C\nD : Type u₄\ninst✝ : CategoryTheory.Category.{v₄, u₄} D\nH : CategoryTheory.Functor C D\nF G : CategoryTheory.Functor J C\nα : CategoryTheory.Iso F G\nc : CategoryTheory.Limits.Cocone G\n⊢ Eq H.mapCoconePrecomposeEquivalenceFunctor.inv.hom (CategoryTheory.CategoryStruct.id (H.obj c.pt))","decl":"/-- `mapCocone` commutes with `precomposeEquivalence`\n-/\n@[simps!]\ndef mapCoconePrecomposeEquivalenceFunctor {α : F ≅ G} {c} :\n    mapCocone H ((Cocones.precomposeEquivalence α).functor.obj c) ≅\n      (Cocones.precomposeEquivalence (isoWhiskerRight α H :)).functor.obj (mapCocone H c) :=\n  Cocones.ext (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Functor.mapCoconePrecomposeEquivalenceFunctor_hom_hom","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} C\nD : Type u₄\ninst✝ : CategoryTheory.Category.{v₄, u₄} D\nH : CategoryTheory.Functor C D\nF G : CategoryTheory.Functor J C\nα : CategoryTheory.Iso F G\nc : CategoryTheory.Limits.Cocone G\n⊢ Eq H.mapCoconePrecomposeEquivalenceFunctor.hom.hom (CategoryTheory.CategoryStruct.id (H.obj c.pt))","decl":"/-- `mapCocone` commutes with `precomposeEquivalence`\n-/\n@[simps!]\ndef mapCoconePrecomposeEquivalenceFunctor {α : F ≅ G} {c} :\n    mapCocone H ((Cocones.precomposeEquivalence α).functor.obj c) ≅\n      (Cocones.precomposeEquivalence (isoWhiskerRight α H :)).functor.obj (mapCocone H c) :=\n  Cocones.ext (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Functor.mapConeWhisker_hom_hom","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} J\nK : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} K\nC : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} C\nD : Type u₄\ninst✝ : CategoryTheory.Category.{v₄, u₄} D\nH : CategoryTheory.Functor C D\nF : CategoryTheory.Functor J C\nE : CategoryTheory.Functor K J\nc : CategoryTheory.Limits.Cone F\n⊢ Eq H.mapConeWhisker.hom.hom (CategoryTheory.CategoryStruct.id (H.obj c.pt))","decl":"/-- `mapCone` commutes with `whisker`\n-/\n@[simps!]\ndef mapConeWhisker {E : K ⥤ J} {c : Cone F} : mapCone H (c.whisker E) ≅ (mapCone H c).whisker E :=\n  Cones.ext (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Functor.mapConeWhisker_inv_hom","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} J\nK : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} K\nC : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} C\nD : Type u₄\ninst✝ : CategoryTheory.Category.{v₄, u₄} D\nH : CategoryTheory.Functor C D\nF : CategoryTheory.Functor J C\nE : CategoryTheory.Functor K J\nc : CategoryTheory.Limits.Cone F\n⊢ Eq H.mapConeWhisker.inv.hom (CategoryTheory.CategoryStruct.id (H.obj c.pt))","decl":"/-- `mapCone` commutes with `whisker`\n-/\n@[simps!]\ndef mapConeWhisker {E : K ⥤ J} {c : Cone F} : mapCone H (c.whisker E) ≅ (mapCone H c).whisker E :=\n  Cones.ext (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Functor.mapCoconeWhisker_hom_hom","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} J\nK : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} K\nC : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} C\nD : Type u₄\ninst✝ : CategoryTheory.Category.{v₄, u₄} D\nH : CategoryTheory.Functor C D\nF : CategoryTheory.Functor J C\nE : CategoryTheory.Functor K J\nc : CategoryTheory.Limits.Cocone F\n⊢ Eq H.mapCoconeWhisker.hom.hom (CategoryTheory.CategoryStruct.id (H.obj c.pt))","decl":"/-- `mapCocone` commutes with `whisker`\n-/\n@[simps!]\ndef mapCoconeWhisker {E : K ⥤ J} {c : Cocone F} :\n    mapCocone H (c.whisker E) ≅ (mapCocone H c).whisker E :=\n  Cocones.ext (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Functor.mapCoconeWhisker_inv_hom","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} J\nK : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} K\nC : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} C\nD : Type u₄\ninst✝ : CategoryTheory.Category.{v₄, u₄} D\nH : CategoryTheory.Functor C D\nF : CategoryTheory.Functor J C\nE : CategoryTheory.Functor K J\nc : CategoryTheory.Limits.Cocone F\n⊢ Eq H.mapCoconeWhisker.inv.hom (CategoryTheory.CategoryStruct.id (H.obj c.pt))","decl":"/-- `mapCocone` commutes with `whisker`\n-/\n@[simps!]\ndef mapCoconeWhisker {E : K ⥤ J} {c : Cocone F} :\n    mapCocone H (c.whisker E) ≅ (mapCocone H c).whisker E :=\n  Cocones.ext (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Limits.Cocone.op_pt","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\nc : CategoryTheory.Limits.Cocone F\n⊢ Eq c.op.pt { unop := c.pt }","decl":"/-- Change a `Cocone F` into a `Cone F.op`. -/\n@[simps]\ndef Cocone.op (c : Cocone F) : Cone F.op where\n  pt := Opposite.op c.pt\n  π := NatTrans.op c.ι\n\n"}
{"name":"CategoryTheory.Limits.Cocone.op_π","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\nc : CategoryTheory.Limits.Cocone F\n⊢ Eq c.op.π (CategoryTheory.NatTrans.op c.ι)","decl":"/-- Change a `Cocone F` into a `Cone F.op`. -/\n@[simps]\ndef Cocone.op (c : Cocone F) : Cone F.op where\n  pt := Opposite.op c.pt\n  π := NatTrans.op c.ι\n\n"}
{"name":"CategoryTheory.Limits.Cone.op_ι","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\nc : CategoryTheory.Limits.Cone F\n⊢ Eq c.op.ι (CategoryTheory.NatTrans.op c.π)","decl":"/-- Change a `Cone F` into a `Cocone F.op`. -/\n@[simps]\ndef Cone.op (c : Cone F) : Cocone F.op where\n  pt := Opposite.op c.pt\n  ι := NatTrans.op c.π\n\n"}
{"name":"CategoryTheory.Limits.Cone.op_pt","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\nc : CategoryTheory.Limits.Cone F\n⊢ Eq c.op.pt { unop := c.pt }","decl":"/-- Change a `Cone F` into a `Cocone F.op`. -/\n@[simps]\ndef Cone.op (c : Cone F) : Cocone F.op where\n  pt := Opposite.op c.pt\n  ι := NatTrans.op c.π\n\n"}
{"name":"CategoryTheory.Limits.Cocone.unop_pt","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\nc : CategoryTheory.Limits.Cocone F.op\n⊢ Eq c.unop.pt (Opposite.unop c.pt)","decl":"/-- Change a `Cocone F.op` into a `Cone F`. -/\n@[simps]\ndef Cocone.unop (c : Cocone F.op) : Cone F where\n  pt := Opposite.unop c.pt\n  π := NatTrans.removeOp c.ι\n\n"}
{"name":"CategoryTheory.Limits.Cocone.unop_π","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\nc : CategoryTheory.Limits.Cocone F.op\n⊢ Eq c.unop.π (CategoryTheory.NatTrans.removeOp c.ι)","decl":"/-- Change a `Cocone F.op` into a `Cone F`. -/\n@[simps]\ndef Cocone.unop (c : Cocone F.op) : Cone F where\n  pt := Opposite.unop c.pt\n  π := NatTrans.removeOp c.ι\n\n"}
{"name":"CategoryTheory.Limits.Cone.unop_pt","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\nc : CategoryTheory.Limits.Cone F.op\n⊢ Eq c.unop.pt (Opposite.unop c.pt)","decl":"/-- Change a `Cone F.op` into a `Cocone F`. -/\n@[simps]\ndef Cone.unop (c : Cone F.op) : Cocone F where\n  pt := Opposite.unop c.pt\n  ι := NatTrans.removeOp c.π\n\n"}
{"name":"CategoryTheory.Limits.Cone.unop_ι","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\nc : CategoryTheory.Limits.Cone F.op\n⊢ Eq c.unop.ι (CategoryTheory.NatTrans.removeOp c.π)","decl":"/-- Change a `Cone F.op` into a `Cocone F`. -/\n@[simps]\ndef Cone.unop (c : Cone F.op) : Cocone F where\n  pt := Opposite.unop c.pt\n  ι := NatTrans.removeOp c.π\n\n"}
{"name":"CategoryTheory.Limits.coconeEquivalenceOpConeOp_functor_obj","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\nc : CategoryTheory.Limits.Cocone F\n⊢ Eq ((CategoryTheory.Limits.coconeEquivalenceOpConeOp F).functor.obj c) { unop := c.op }","decl":"attribute [simps] coconeEquivalenceOpConeOp\n\n"}
{"name":"CategoryTheory.Limits.coconeEquivalenceOpConeOp_inverse_map_hom","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\nX Y : Opposite (CategoryTheory.Limits.Cone F.op)\nf : Quiver.Hom X Y\n⊢ Eq ((CategoryTheory.Limits.coconeEquivalenceOpConeOp F).inverse.map f).hom f.unop.hom.unop","decl":"attribute [simps] coconeEquivalenceOpConeOp\n\n"}
{"name":"CategoryTheory.Limits.coconeEquivalenceOpConeOp_unitIso","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\n⊢ Eq (CategoryTheory.Limits.coconeEquivalenceOpConeOp F).unitIso (CategoryTheory.NatIso.ofComponents (fun c => CategoryTheory.Limits.Cocones.ext (CategoryTheory.Iso.refl ((CategoryTheory.Functor.id (CategoryTheory.Limits.Cocone F)).obj c).pt) ⋯) ⋯)","decl":"attribute [simps] coconeEquivalenceOpConeOp\n\n"}
{"name":"CategoryTheory.Limits.coconeEquivalenceOpConeOp_counitIso","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\n⊢ Eq (CategoryTheory.Limits.coconeEquivalenceOpConeOp F).counitIso (CategoryTheory.NatIso.ofComponents (fun c => Opposite.rec' (fun X => (CategoryTheory.Limits.Cones.ext (CategoryTheory.Iso.refl X.pt) ⋯).op) c) ⋯)","decl":"attribute [simps] coconeEquivalenceOpConeOp\n\n"}
{"name":"CategoryTheory.Limits.coconeEquivalenceOpConeOp_inverse_obj","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\nc : Opposite (CategoryTheory.Limits.Cone F.op)\n⊢ Eq ((CategoryTheory.Limits.coconeEquivalenceOpConeOp F).inverse.obj c) (Opposite.unop c).unop","decl":"attribute [simps] coconeEquivalenceOpConeOp\n\n"}
{"name":"CategoryTheory.Limits.coconeEquivalenceOpConeOp_functor_map","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\nX Y : CategoryTheory.Limits.Cocone F\nf : Quiver.Hom X Y\n⊢ Eq ((CategoryTheory.Limits.coconeEquivalenceOpConeOp F).functor.map f) (Quiver.Hom.op { hom := f.hom.op, w := ⋯ })","decl":"attribute [simps] coconeEquivalenceOpConeOp\n\n"}
{"name":"CategoryTheory.Limits.coneOfCoconeLeftOp_pt","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J (Opposite C)\nc : CategoryTheory.Limits.Cocone F.leftOp\n⊢ Eq (CategoryTheory.Limits.coneOfCoconeLeftOp c).pt { unop := c.pt }","decl":"/-- Change a cocone on `F.leftOp : Jᵒᵖ ⥤ C` to a cocone on `F : J ⥤ Cᵒᵖ`. -/\n@[simps!]\ndef coneOfCoconeLeftOp (c : Cocone F.leftOp) : Cone F where\n  pt := op c.pt\n  π := NatTrans.removeLeftOp c.ι\n\n"}
{"name":"CategoryTheory.Limits.coneOfCoconeLeftOp_π_app","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J (Opposite C)\nc : CategoryTheory.Limits.Cocone F.leftOp\nX : J\n⊢ Eq ((CategoryTheory.Limits.coneOfCoconeLeftOp c).π.app X) (c.ι.app { unop := X }).op","decl":"/-- Change a cocone on `F.leftOp : Jᵒᵖ ⥤ C` to a cocone on `F : J ⥤ Cᵒᵖ`. -/\n@[simps!]\ndef coneOfCoconeLeftOp (c : Cocone F.leftOp) : Cone F where\n  pt := op c.pt\n  π := NatTrans.removeLeftOp c.ι\n\n"}
{"name":"CategoryTheory.Limits.coconeLeftOpOfCone_ι_app","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J (Opposite C)\nc : CategoryTheory.Limits.Cone F\nX : Opposite J\n⊢ Eq ((CategoryTheory.Limits.coconeLeftOpOfCone c).ι.app X) (c.π.app (Opposite.unop X)).unop","decl":"/-- Change a cone on `F : J ⥤ Cᵒᵖ` to a cocone on `F.leftOp : Jᵒᵖ ⥤ C`. -/\n@[simps!]\ndef coconeLeftOpOfCone (c : Cone F) : Cocone F.leftOp where\n  pt := unop c.pt\n  ι := NatTrans.leftOp c.π\n\n/- When trying use `@[simps]` to generate the `ι_app` field of this definition, `@[simps]` tries to\n  reduce the RHS using `expr.dsimp` and `expr.simp`, but for some reason the expression is not\n  being simplified properly. -/\n"}
{"name":"CategoryTheory.Limits.coconeLeftOpOfCone_pt","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J (Opposite C)\nc : CategoryTheory.Limits.Cone F\n⊢ Eq (CategoryTheory.Limits.coconeLeftOpOfCone c).pt (Opposite.unop c.pt)","decl":"/-- Change a cone on `F : J ⥤ Cᵒᵖ` to a cocone on `F.leftOp : Jᵒᵖ ⥤ C`. -/\n@[simps!]\ndef coconeLeftOpOfCone (c : Cone F) : Cocone F.leftOp where\n  pt := unop c.pt\n  ι := NatTrans.leftOp c.π\n\n/- When trying use `@[simps]` to generate the `ι_app` field of this definition, `@[simps]` tries to\n  reduce the RHS using `expr.dsimp` and `expr.simp`, but for some reason the expression is not\n  being simplified properly. -/\n"}
{"name":"CategoryTheory.Limits.coconeOfConeLeftOp_pt","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J (Opposite C)\nc : CategoryTheory.Limits.Cone F.leftOp\n⊢ Eq (CategoryTheory.Limits.coconeOfConeLeftOp c).pt { unop := c.pt }","decl":"/-- Change a cone on `F.leftOp : Jᵒᵖ ⥤ C` to a cocone on `F : J ⥤ Cᵒᵖ`. -/\n@[simps pt]\ndef coconeOfConeLeftOp (c : Cone F.leftOp) : Cocone F where\n  pt := op c.pt\n  ι := NatTrans.removeLeftOp c.π\n\n"}
{"name":"CategoryTheory.Limits.coconeOfConeLeftOp_ι_app","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J (Opposite C)\nc : CategoryTheory.Limits.Cone F.leftOp\nj : J\n⊢ Eq ((CategoryTheory.Limits.coconeOfConeLeftOp c).ι.app j) (c.π.app { unop := j }).op","decl":"@[simp]\ntheorem coconeOfConeLeftOp_ι_app (c : Cone F.leftOp) (j) :\n    (coconeOfConeLeftOp c).ι.app j = (c.π.app (op j)).op := by\n  dsimp only [coconeOfConeLeftOp]\n  simp\n\n"}
{"name":"CategoryTheory.Limits.coneLeftOpOfCocone_π_app","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J (Opposite C)\nc : CategoryTheory.Limits.Cocone F\nX : Opposite J\n⊢ Eq ((CategoryTheory.Limits.coneLeftOpOfCocone c).π.app X) (c.ι.app (Opposite.unop X)).unop","decl":"/-- Change a cocone on `F : J ⥤ Cᵒᵖ` to a cone on `F.leftOp : Jᵒᵖ ⥤ C`. -/\n@[simps!]\ndef coneLeftOpOfCocone (c : Cocone F) : Cone F.leftOp where\n  pt := unop c.pt\n  π := NatTrans.leftOp c.ι\n\n"}
{"name":"CategoryTheory.Limits.coneLeftOpOfCocone_pt","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J (Opposite C)\nc : CategoryTheory.Limits.Cocone F\n⊢ Eq (CategoryTheory.Limits.coneLeftOpOfCocone c).pt (Opposite.unop c.pt)","decl":"/-- Change a cocone on `F : J ⥤ Cᵒᵖ` to a cone on `F.leftOp : Jᵒᵖ ⥤ C`. -/\n@[simps!]\ndef coneLeftOpOfCocone (c : Cocone F) : Cone F.leftOp where\n  pt := unop c.pt\n  π := NatTrans.leftOp c.ι\n\n"}
{"name":"CategoryTheory.Limits.coneOfCoconeRightOp_π","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor (Opposite J) C\nc : CategoryTheory.Limits.Cocone F.rightOp\n⊢ Eq (CategoryTheory.Limits.coneOfCoconeRightOp c).π (CategoryTheory.NatTrans.removeRightOp c.ι)","decl":"/-- Change a cocone on `F.rightOp : J ⥤ Cᵒᵖ` to a cone on `F : Jᵒᵖ ⥤ C`. -/\n@[simps]\ndef coneOfCoconeRightOp (c : Cocone F.rightOp) : Cone F where\n  pt := unop c.pt\n  π := NatTrans.removeRightOp c.ι\n\n"}
{"name":"CategoryTheory.Limits.coneOfCoconeRightOp_pt","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor (Opposite J) C\nc : CategoryTheory.Limits.Cocone F.rightOp\n⊢ Eq (CategoryTheory.Limits.coneOfCoconeRightOp c).pt (Opposite.unop c.pt)","decl":"/-- Change a cocone on `F.rightOp : J ⥤ Cᵒᵖ` to a cone on `F : Jᵒᵖ ⥤ C`. -/\n@[simps]\ndef coneOfCoconeRightOp (c : Cocone F.rightOp) : Cone F where\n  pt := unop c.pt\n  π := NatTrans.removeRightOp c.ι\n\n"}
{"name":"CategoryTheory.Limits.coconeRightOpOfCone_ι","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor (Opposite J) C\nc : CategoryTheory.Limits.Cone F\n⊢ Eq (CategoryTheory.Limits.coconeRightOpOfCone c).ι (CategoryTheory.NatTrans.rightOp c.π)","decl":"/-- Change a cone on `F : Jᵒᵖ ⥤ C` to a cocone on `F.rightOp : Jᵒᵖ ⥤ C`. -/\n@[simps]\ndef coconeRightOpOfCone (c : Cone F) : Cocone F.rightOp where\n  pt := op c.pt\n  ι := NatTrans.rightOp c.π\n\n"}
{"name":"CategoryTheory.Limits.coconeRightOpOfCone_pt","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor (Opposite J) C\nc : CategoryTheory.Limits.Cone F\n⊢ Eq (CategoryTheory.Limits.coconeRightOpOfCone c).pt { unop := c.pt }","decl":"/-- Change a cone on `F : Jᵒᵖ ⥤ C` to a cocone on `F.rightOp : Jᵒᵖ ⥤ C`. -/\n@[simps]\ndef coconeRightOpOfCone (c : Cone F) : Cocone F.rightOp where\n  pt := op c.pt\n  ι := NatTrans.rightOp c.π\n\n"}
{"name":"CategoryTheory.Limits.coconeOfConeRightOp_pt","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor (Opposite J) C\nc : CategoryTheory.Limits.Cone F.rightOp\n⊢ Eq (CategoryTheory.Limits.coconeOfConeRightOp c).pt (Opposite.unop c.pt)","decl":"/-- Change a cone on `F.rightOp : J ⥤ Cᵒᵖ` to a cocone on `F : Jᵒᵖ ⥤ C`. -/\n@[simps]\ndef coconeOfConeRightOp (c : Cone F.rightOp) : Cocone F where\n  pt := unop c.pt\n  ι := NatTrans.removeRightOp c.π\n\n"}
{"name":"CategoryTheory.Limits.coconeOfConeRightOp_ι","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor (Opposite J) C\nc : CategoryTheory.Limits.Cone F.rightOp\n⊢ Eq (CategoryTheory.Limits.coconeOfConeRightOp c).ι (CategoryTheory.NatTrans.removeRightOp c.π)","decl":"/-- Change a cone on `F.rightOp : J ⥤ Cᵒᵖ` to a cocone on `F : Jᵒᵖ ⥤ C`. -/\n@[simps]\ndef coconeOfConeRightOp (c : Cone F.rightOp) : Cocone F where\n  pt := unop c.pt\n  ι := NatTrans.removeRightOp c.π\n\n"}
{"name":"CategoryTheory.Limits.coneRightOpOfCocone_π","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor (Opposite J) C\nc : CategoryTheory.Limits.Cocone F\n⊢ Eq (CategoryTheory.Limits.coneRightOpOfCocone c).π (CategoryTheory.NatTrans.rightOp c.ι)","decl":"/-- Change a cocone on `F : Jᵒᵖ ⥤ C` to a cone on `F.rightOp : J ⥤ Cᵒᵖ`. -/\n@[simps]\ndef coneRightOpOfCocone (c : Cocone F) : Cone F.rightOp where\n  pt := op c.pt\n  π := NatTrans.rightOp c.ι\n\n"}
{"name":"CategoryTheory.Limits.coneRightOpOfCocone_pt","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor (Opposite J) C\nc : CategoryTheory.Limits.Cocone F\n⊢ Eq (CategoryTheory.Limits.coneRightOpOfCocone c).pt { unop := c.pt }","decl":"/-- Change a cocone on `F : Jᵒᵖ ⥤ C` to a cone on `F.rightOp : J ⥤ Cᵒᵖ`. -/\n@[simps]\ndef coneRightOpOfCocone (c : Cocone F) : Cone F.rightOp where\n  pt := op c.pt\n  π := NatTrans.rightOp c.ι\n\n"}
{"name":"CategoryTheory.Limits.coneOfCoconeUnop_pt","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor (Opposite J) (Opposite C)\nc : CategoryTheory.Limits.Cocone F.unop\n⊢ Eq (CategoryTheory.Limits.coneOfCoconeUnop c).pt { unop := c.pt }","decl":"/-- Change a cocone on `F.unop : J ⥤ C` into a cone on `F : Jᵒᵖ ⥤ Cᵒᵖ`. -/\n@[simps]\ndef coneOfCoconeUnop (c : Cocone F.unop) : Cone F where\n  pt := op c.pt\n  π := NatTrans.removeUnop c.ι\n\n"}
{"name":"CategoryTheory.Limits.coneOfCoconeUnop_π","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor (Opposite J) (Opposite C)\nc : CategoryTheory.Limits.Cocone F.unop\n⊢ Eq (CategoryTheory.Limits.coneOfCoconeUnop c).π (CategoryTheory.NatTrans.removeUnop c.ι)","decl":"/-- Change a cocone on `F.unop : J ⥤ C` into a cone on `F : Jᵒᵖ ⥤ Cᵒᵖ`. -/\n@[simps]\ndef coneOfCoconeUnop (c : Cocone F.unop) : Cone F where\n  pt := op c.pt\n  π := NatTrans.removeUnop c.ι\n\n"}
{"name":"CategoryTheory.Limits.coconeUnopOfCone_ι","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor (Opposite J) (Opposite C)\nc : CategoryTheory.Limits.Cone F\n⊢ Eq (CategoryTheory.Limits.coconeUnopOfCone c).ι (CategoryTheory.NatTrans.unop c.π)","decl":"/-- Change a cone on `F : Jᵒᵖ ⥤ Cᵒᵖ` into a cocone on `F.unop : J ⥤ C`. -/\n@[simps]\ndef coconeUnopOfCone (c : Cone F) : Cocone F.unop where\n  pt := unop c.pt\n  ι := NatTrans.unop c.π\n\n"}
{"name":"CategoryTheory.Limits.coconeUnopOfCone_pt","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor (Opposite J) (Opposite C)\nc : CategoryTheory.Limits.Cone F\n⊢ Eq (CategoryTheory.Limits.coconeUnopOfCone c).pt (Opposite.unop c.pt)","decl":"/-- Change a cone on `F : Jᵒᵖ ⥤ Cᵒᵖ` into a cocone on `F.unop : J ⥤ C`. -/\n@[simps]\ndef coconeUnopOfCone (c : Cone F) : Cocone F.unop where\n  pt := unop c.pt\n  ι := NatTrans.unop c.π\n\n"}
{"name":"CategoryTheory.Limits.coconeOfConeUnop_ι","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor (Opposite J) (Opposite C)\nc : CategoryTheory.Limits.Cone F.unop\n⊢ Eq (CategoryTheory.Limits.coconeOfConeUnop c).ι (CategoryTheory.NatTrans.removeUnop c.π)","decl":"/-- Change a cone on `F.unop : J ⥤ C` into a cocone on `F : Jᵒᵖ ⥤ Cᵒᵖ`. -/\n@[simps]\ndef coconeOfConeUnop (c : Cone F.unop) : Cocone F where\n  pt := op c.pt\n  ι := NatTrans.removeUnop c.π\n\n"}
{"name":"CategoryTheory.Limits.coconeOfConeUnop_pt","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor (Opposite J) (Opposite C)\nc : CategoryTheory.Limits.Cone F.unop\n⊢ Eq (CategoryTheory.Limits.coconeOfConeUnop c).pt { unop := c.pt }","decl":"/-- Change a cone on `F.unop : J ⥤ C` into a cocone on `F : Jᵒᵖ ⥤ Cᵒᵖ`. -/\n@[simps]\ndef coconeOfConeUnop (c : Cone F.unop) : Cocone F where\n  pt := op c.pt\n  ι := NatTrans.removeUnop c.π\n\n"}
{"name":"CategoryTheory.Limits.coneUnopOfCocone_π","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor (Opposite J) (Opposite C)\nc : CategoryTheory.Limits.Cocone F\n⊢ Eq (CategoryTheory.Limits.coneUnopOfCocone c).π (CategoryTheory.NatTrans.unop c.ι)","decl":"/-- Change a cocone on `F : Jᵒᵖ ⥤ Cᵒᵖ` into a cone on `F.unop : J ⥤ C`. -/\n@[simps]\ndef coneUnopOfCocone (c : Cocone F) : Cone F.unop where\n  pt := unop c.pt\n  π := NatTrans.unop c.ι\n\n"}
{"name":"CategoryTheory.Limits.coneUnopOfCocone_pt","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor (Opposite J) (Opposite C)\nc : CategoryTheory.Limits.Cocone F\n⊢ Eq (CategoryTheory.Limits.coneUnopOfCocone c).pt (Opposite.unop c.pt)","decl":"/-- Change a cocone on `F : Jᵒᵖ ⥤ Cᵒᵖ` into a cone on `F.unop : J ⥤ C`. -/\n@[simps]\ndef coneUnopOfCocone (c : Cocone F) : Cone F.unop where\n  pt := unop c.pt\n  π := NatTrans.unop c.ι\n\n"}
{"name":"CategoryTheory.Functor.mapConeOp_hom_hom","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} C\nD : Type u₄\ninst✝ : CategoryTheory.Category.{v₄, u₄} D\nF : CategoryTheory.Functor J C\nG : CategoryTheory.Functor C D\nt : CategoryTheory.Limits.Cone F\n⊢ Eq (CategoryTheory.Functor.mapConeOp G t).hom.hom (CategoryTheory.CategoryStruct.id { unop := G.obj t.pt })","decl":"/-- The opposite cocone of the image of a cone is the image of the opposite cocone. -/\n@[simps!]\ndef mapConeOp (t : Cone F) : (mapCone G t).op ≅ mapCocone G.op t.op :=\n  Cocones.ext (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Functor.mapConeOp_inv_hom","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} C\nD : Type u₄\ninst✝ : CategoryTheory.Category.{v₄, u₄} D\nF : CategoryTheory.Functor J C\nG : CategoryTheory.Functor C D\nt : CategoryTheory.Limits.Cone F\n⊢ Eq (CategoryTheory.Functor.mapConeOp G t).inv.hom (CategoryTheory.CategoryStruct.id { unop := G.obj t.pt })","decl":"/-- The opposite cocone of the image of a cone is the image of the opposite cocone. -/\n@[simps!]\ndef mapConeOp (t : Cone F) : (mapCone G t).op ≅ mapCocone G.op t.op :=\n  Cocones.ext (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Functor.mapCoconeOp_hom_hom","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} C\nD : Type u₄\ninst✝ : CategoryTheory.Category.{v₄, u₄} D\nF : CategoryTheory.Functor J C\nG : CategoryTheory.Functor C D\nt : CategoryTheory.Limits.Cocone F\n⊢ Eq (CategoryTheory.Functor.mapCoconeOp G).hom.hom (CategoryTheory.CategoryStruct.id { unop := G.obj t.pt })","decl":"/-- The opposite cone of the image of a cocone is the image of the opposite cone. -/\n@[simps!]\ndef mapCoconeOp {t : Cocone F} : (mapCocone G t).op ≅ mapCone G.op t.op :=\n  Cones.ext (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Functor.mapCoconeOp_inv_hom","module":"Mathlib.CategoryTheory.Limits.Cones","initialProofState":"J : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} C\nD : Type u₄\ninst✝ : CategoryTheory.Category.{v₄, u₄} D\nF : CategoryTheory.Functor J C\nG : CategoryTheory.Functor C D\nt : CategoryTheory.Limits.Cocone F\n⊢ Eq (CategoryTheory.Functor.mapCoconeOp G).inv.hom (CategoryTheory.CategoryStruct.id { unop := G.obj t.pt })","decl":"/-- The opposite cone of the image of a cocone is the image of the opposite cone. -/\n@[simps!]\ndef mapCoconeOp {t : Cocone F} : (mapCocone G t).op ≅ mapCone G.op t.op :=\n  Cones.ext (Iso.refl _)\n\n"}
